WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.030 --> 00:00:04.650
嘿，大家有时间再来

00:00:02.159 --> 00:00:05.640
我的相机的开发者日记之一

00:00:04.650 --> 00:00:07.140
让我兴奋的事情

00:00:05.640 --> 00:00:09.150
这个项目首先是

00:00:07.140 --> 00:00:10.620
图像滤镜我所做的滤镜

00:00:09.150 --> 00:00:11.940
你可能会比较标准的事情

00:00:10.620 --> 00:00:13.980
在其他相机应用或图像中查看

00:00:11.940 --> 00:00:15.719
编辑软件，例如更改

00:00:13.980 --> 00:00:18.119
亮度对比之类的

00:00:15.719 --> 00:00:20.310
东西在这个应用程序的过滤器书面

00:00:18.119 --> 00:00:22.080
使用WebGL我不会深入探讨

00:00:20.310 --> 00:00:23.279
本集中有关WebGL的详细信息，但

00:00:22.080 --> 00:00:25.320
我最近录制了一集

00:00:23.279 --> 00:00:27.300
我写的机械增压的Reaser mer 

00:00:25.320 --> 00:00:29.609
一些设置WebGL的代码，以便您可以

00:00:27.300 --> 00:00:30.900
用它来操纵一张关于它的图像

00:00:29.609 --> 00:00:32.550
一个小时的时间，所以我不会去假设

00:00:30.900 --> 00:00:33.809
您已经看过了，但是有一个

00:00:32.550 --> 00:00:36.809
如果要链接说明中的链接

00:00:33.809 --> 00:00:38.700
现在就去做一个非常简短的总结

00:00:36.809 --> 00:00:40.770
 WebGL设置是您创建一个

00:00:38.700 --> 00:00:43.320
 canvas元素，并将一些代码附加到

00:00:40.770 --> 00:00:45.000
它必须为每个像素运行

00:00:43.320 --> 00:00:47.960
输出该像素应该是什么颜色

00:00:45.000 --> 00:00:50.129
应该将此代码称为着色器

00:00:47.960 --> 00:00:51.809
着色器的代码写在

00:00:50.129 --> 00:00:53.489
类似于C的特殊语言

00:00:51.809 --> 00:00:54.899
我不会详细介绍

00:00:53.489 --> 00:00:57.050
语言，但我想谈谈

00:00:54.899 --> 00:00:59.129
关于我的代码实际上在做什么

00:00:57.050 --> 00:01:01.500
着色器可以查看来自

00:00:59.129 --> 00:01:03.510
仅当您说话时才显示原始图片

00:01:01.500 --> 00:01:06.510
有关您倾向于参考的WebGL中的图像

00:01:03.510 --> 00:01:08.909
作为纹理，所以在这里

00:01:06.510 --> 00:01:12.150
着色器的代码，我们有一条细线

00:01:08.909 --> 00:01:14.010
在这里变化称为特克斯

00:01:12.150 --> 00:01:17.100
线，这是

00:01:14.010 --> 00:01:18.420
画布中可以使用的像素

00:01:17.100 --> 00:01:21.630
查看原始图像

00:01:18.420 --> 00:01:23.580
纹理因此特克斯线，这是一个

00:01:21.630 --> 00:01:26.340
每个像素的不同值是

00:01:23.580 --> 00:01:28.049
为什么它是变化的，您也可以传递

00:01:26.340 --> 00:01:29.729
 JavaScript中的一些值

00:01:28.049 --> 00:01:31.740
被这些像素共享

00:01:29.729 --> 00:01:33.840
变量称为统一，因为

00:01:31.740 --> 00:01:35.130
每个像素都相同

00:01:33.840 --> 00:01:37.079
它如何通过诸如

00:01:35.130 --> 00:01:39.450
对比度或亮度水平

00:01:37.079 --> 00:01:40.759
其实是这样，我们这里有制服

00:01:39.450 --> 00:01:43.560
对于所有过滤器设置

00:01:40.759 --> 00:01:45.659
饱和温暖等这种质地

00:01:43.560 --> 00:01:48.390
采样器是我们要参考的方式

00:01:45.659 --> 00:01:51.240
我们的原始形象和这个女人，她是

00:01:48.390 --> 00:01:52.979
源大小，这给了我们宽度和

00:01:51.240 --> 00:01:55.979
原始图像的高度（以像素为单位） 

00:01:52.979 --> 00:01:57.810
那么这些过滤器实际上是如何工作的

00:01:55.979 --> 00:02:00.180
我们做得如何？ 

00:01:57.810 --> 00:02:04.500
我在我的代码中所做的事情是

00:02:00.180 --> 00:02:06.450
叫做卷积滤波器的东西

00:02:04.500 --> 00:02:07.649
卷积滤波器，有点像

00:02:06.450 --> 00:02:09.869
复杂的名字是

00:02:07.649 --> 00:02:11.250
实际上相对简单

00:02:09.869 --> 00:02:13.330
我们要做的是计算

00:02:11.250 --> 00:02:17.920
外出的颜色

00:02:13.330 --> 00:02:21.040
基于多个输入像素的像素

00:02:17.920 --> 00:02:22.870
所以在这里我想算出什么颜色

00:02:21.040 --> 00:02:25.270
特定像素应该是当我

00:02:22.870 --> 00:02:27.850
产生我的形象和我的方式

00:02:25.270 --> 00:02:31.030
我在看颜色的值吗

00:02:27.850 --> 00:02:34.420
对于那个像素及其周围的一些像素

00:02:31.030 --> 00:02:36.190
所以在这里我们有一个3x3卷积

00:02:34.420 --> 00:02:38.740
因为我们要看九点

00:02:36.190 --> 00:02:41.710
像素和每个像素的3x3网格

00:02:38.740 --> 00:02:44.770
给定重量，这是多么重要

00:02:41.710 --> 00:02:48.070
就是输出这个特定的

00:02:44.770 --> 00:02:51.490
重量将给我们所知道的

00:02:48.070 --> 00:02:53.800
作为模糊，所以我们要做的是收集

00:02:51.490 --> 00:02:56.920
周围所有像素的颜色

00:02:53.800 --> 00:03:00.780
然后将所有颜色值相乘

00:02:56.920 --> 00:03:02.770
对于每个像素，按权重

00:03:00.780 --> 00:03:05.170
因为所有这些颜色值都在变化

00:03:02.770 --> 00:03:06.430
是从0到1的数字，然后我们

00:03:05.170 --> 00:03:08.770
将它们加在一起我们就能赚到

00:03:06.430 --> 00:03:13.030
在0和此之间的数字

00:03:08.770 --> 00:03:15.220
 16一旦我们将它们添加在一起

00:03:13.030 --> 00:03:17.020
知道加上权重

00:03:15.220 --> 00:03:18.040
除以16可返回值

00:03:17.020 --> 00:03:19.750
在0和1之间

00:03:18.040 --> 00:03:22.720
你可能以为自己是

00:03:19.750 --> 00:03:25.209
要做的是你有一个数组

00:03:22.720 --> 00:03:28.150
尽力而为

00:03:25.209 --> 00:03:31.840
通过您知道从负1减1到

00:03:28.150 --> 00:03:35.410
 1 1并且您仔细查看所有9 

00:03:31.840 --> 00:03:36.940
循环中的像素，您会获得每种颜色

00:03:35.410 --> 00:03:38.590
然后乘以它的重量

00:03:36.940 --> 00:03:41.020
您将它们添加到总计中，最后

00:03:38.590 --> 00:03:43.570
你除以所有这些的总和

00:03:41.020 --> 00:03:46.959
重量，或多或少就是你

00:03:43.570 --> 00:03:49.120
除了在WebGL着色器中要做之外

00:03:46.959 --> 00:03:51.430
通过展开此内容对其进行优化

00:03:49.120 --> 00:03:53.530
循环，所以没有做

00:03:51.430 --> 00:03:55.120
循环作为循环，我要写出来

00:03:53.530 --> 00:03:57.310
每个单独的陈述

00:03:55.120 --> 00:03:59.739
自行运行，所以在那里

00:03:57.310 --> 00:04:02.230
而不是运行九次循环

00:03:59.739 --> 00:04:03.970
要写九条指令，所以你

00:04:02.230 --> 00:04:06.310
可能想知道我为什么要这样做

00:04:03.970 --> 00:04:07.989
虽然我们没有所有这些循环，但确实有

00:04:06.310 --> 00:04:10.510
每个指令分开而不是

00:04:07.989 --> 00:04:13.269
遍历它们，这与

00:04:10.510 --> 00:04:16.019
图形卡如何工作，因此图形

00:04:13.269 --> 00:04:18.310
卡包含数百个GPU内核

00:04:16.019 --> 00:04:20.260
擅长数学

00:04:18.310 --> 00:04:22.740
计算，但我认为并非如此

00:04:20.260 --> 00:04:25.690
擅长普通CPU的是

00:04:22.740 --> 00:04:26.760
分支，以便当事物发生时

00:04:25.690 --> 00:04:30.300
不同

00:04:26.760 --> 00:04:32.250
当您再次在GPU中运行代码时

00:04:30.300 --> 00:04:33.510
它用来做相同的计算

00:04:32.250 --> 00:04:35.400
一而再，再而三

00:04:33.510 --> 00:04:38.640
它建立了一个管道以供读入

00:04:35.400 --> 00:04:42.330
无需执行数据和输出输出

00:04:38.640 --> 00:04:45.750
任何类似的决策，所以当我们有

00:04:42.330 --> 00:04:47.910
我们的循环中许多显卡驱动程序会

00:04:45.750 --> 00:04:50.100
实际自动优化

00:04:47.910 --> 00:04:55.410
你会说好吧，所以这是一个常数

00:04:50.100 --> 00:04:57.300
此代码的运行次数，我们可以

00:04:55.410 --> 00:04:58.710
在编译时计算出这是

00:04:57.300 --> 00:05:00.180
将要运行九次

00:04:58.710 --> 00:05:02.460
使用这些值，它可以产生

00:05:00.180 --> 00:05:05.460
该展开版本适合您，但不适合

00:05:02.460 --> 00:05:07.320
每个司机都这样做，尤其是

00:05:05.460 --> 00:05:08.760
像纹理这样的东西我们正在寻找

00:05:07.320 --> 00:05:12.450
在原件的颜色信息上

00:05:08.760 --> 00:05:15.600
可以非常优化的图像

00:05:12.450 --> 00:05:19.200
而且你知道那些流水线

00:05:15.600 --> 00:05:20.550
颜色，您根据事实知道

00:05:19.200 --> 00:05:22.980
我们要从左到右，而我们

00:05:20.550 --> 00:05:25.320
总是把东西拉出来

00:05:22.980 --> 00:05:27.740
订购，以便显卡可以

00:05:25.320 --> 00:05:30.570
如果它提前知道的话真的很快

00:05:27.740 --> 00:05:32.310
像素将是什么

00:05:30.570 --> 00:05:34.410
会被抬头，当你

00:05:32.310 --> 00:05:37.470
介绍一下循环一些显卡

00:05:34.410 --> 00:05:39.540
司机把它作为一个分支，他们

00:05:37.470 --> 00:05:41.790
不要为任何人优化，所以这可以

00:05:39.540 --> 00:05:44.430
在某些显卡上会非常慢

00:05:41.790 --> 00:05:47.040
现在大多数时候这会很快

00:05:44.430 --> 00:05:49.320
最现代的设备，这将工作

00:05:47.040 --> 00:05:50.790
很好，但不是所有人都可以测试

00:05:49.320 --> 00:05:53.190
一些设备，这是非常

00:05:50.790 --> 00:05:54.840
慢，所以这就是我这样做的原因

00:05:53.190 --> 00:05:58.320
让我们看一下其中的实际代码

00:05:54.840 --> 00:06:01.410
我的着色器为此，我做了一个3x3矩阵

00:05:58.320 --> 00:06:04.830
在示例中，我实际上使用了5x5 

00:06:01.410 --> 00:06:07.230
我的代码中的矩阵，因为采样良好

00:06:04.830 --> 00:06:09.570
值可获得更平滑的模糊效果

00:06:07.230 --> 00:06:11.520
但在其他方面完全一样

00:06:09.570 --> 00:06:14.130
这里我使用的是纹理2D调用

00:06:11.520 --> 00:06:16.140
在我的着色器语言中查找

00:06:14.130 --> 00:06:18.150
纹理采样器一些坐标

00:06:16.140 --> 00:06:21.840
包括我正在查看的偏移量

00:06:18.150 --> 00:06:24.510
得到一个像素的颜色值，然后

00:06:21.840 --> 00:06:26.250
在这里，我将所有这些加起来

00:06:24.510 --> 00:06:28.380
颜色值及其权重

00:06:26.250 --> 00:06:30.300
然后除以那些总和

00:06:28.380 --> 00:06:33.390
重量，您现在可能会注意到

00:06:30.300 --> 00:06:35.340
我实际上没有模糊的应用程序

00:06:33.390 --> 00:06:37.650
我实际上拥有的一个选择是

00:06:35.340 --> 00:06:40.920
现在在这里锐化

00:06:37.650 --> 00:06:42.600
调高了，但是我可以调低到

00:06:40.920 --> 00:06:46.230
什么都没有，你可以看到

00:06:42.600 --> 00:06:49.440
当我改变图像的清晰度时

00:06:46.230 --> 00:06:52.170
移动滑块，如何使用模糊

00:06:49.440 --> 00:06:53.970
使图像更清晰锐利

00:06:52.170 --> 00:06:56.430
起作用的东西正在使用

00:06:53.970 --> 00:06:58.170
称为不锐利的面具，这是一个

00:06:56.430 --> 00:07:01.380
实际发明的技术

00:06:58.170 --> 00:07:04.380
拍回当时真的是拍这个

00:07:01.380 --> 00:07:06.510
是一种前数字技术

00:07:04.380 --> 00:07:09.330
事情变得更加犀利

00:07:06.510 --> 00:07:11.640
原始图像，然后您将

00:07:09.330 --> 00:07:15.450
模糊版本，您会发现

00:07:11.640 --> 00:07:17.520
他们之间的差异，所以你

00:07:15.450 --> 00:07:21.540
基本上说这个形象如何

00:07:17.520 --> 00:07:24.300
当它变得模糊时改变，然后

00:07:21.540 --> 00:07:28.400
你可以做的是可以撤消，所以如果

00:07:24.300 --> 00:07:32.400
像素变红变蓝

00:07:28.400 --> 00:07:34.980
当它模糊时，你可以做

00:07:32.400 --> 00:07:39.150
少点红色，多点蓝色

00:07:34.980 --> 00:07:42.390
更锐利，实际上是非常极端的

00:07:39.150 --> 00:07:45.270
做到这一点的聪明方法

00:07:42.390 --> 00:07:47.400
负模糊几乎如此

00:07:45.270 --> 00:07:49.919
在这里实现的是我解决这个问题

00:07:47.400 --> 00:07:52.950
纹理与

00:07:49.919 --> 00:07:54.870
模糊版本，并将其添加到

00:07:52.950 --> 00:07:57.510
原来的纹理颜色然后我

00:07:54.870 --> 00:07:59.100
实际通过

00:07:57.510 --> 00:08:01.980
滑块的清晰度值

00:07:59.100 --> 00:08:04.250
所以如果在这里锐化这只是一个

00:08:01.980 --> 00:08:06.660
数字，如果说这是零，那么

00:08:04.250 --> 00:08:08.550
这整个事情也将是零

00:08:06.660 --> 00:08:10.620
虽然我们不会添加任何东西

00:08:08.550 --> 00:08:13.020
这不会有任何效果，但如果

00:08:10.620 --> 00:08:15.990
锐化为负，那么我们实际上

00:08:13.020 --> 00:08:17.730
只需添加我们制作的模糊版本

00:08:15.990 --> 00:08:19.260
图像更加模糊，您可以看到

00:08:17.730 --> 00:08:21.419
在应用程序中，所以在这里我们

00:08:19.260 --> 00:08:23.610
清晰度，我们将其向下移动到

00:08:21.419 --> 00:08:25.560
负片，图像变得模糊

00:08:23.610 --> 00:08:28.919
比以前要应用

00:08:25.560 --> 00:08:31.590
卷积滤波器在这种情况下使用

00:08:28.919 --> 00:08:33.000
模糊以锐化图像

00:08:31.590 --> 00:08:34.560
卷积滤波器可以做到所有这些

00:08:33.000 --> 00:08:37.890
带给您浮雕图像的东西

00:08:34.560 --> 00:08:39.060
或边缘狭窄

00:08:37.890 --> 00:08:40.650
卷积可以做的事情

00:08:39.060 --> 00:08:43.800
过滤器我只是用它来增加

00:08:40.650 --> 00:08:46.880
清晰度现在有一些简单的方法

00:08:43.800 --> 00:08:50.730
您也可以做的操作

00:08:46.880 --> 00:08:53.220
我在这里实际所做的就是我

00:08:50.730 --> 00:08:56.129
取每种颜色

00:08:53.220 --> 00:08:57.720
原始的，我乘以

00:08:56.129 --> 00:08:59.579
无论亮度值是多少，如果

00:08:57.720 --> 00:09:00.240
您的亮度为1 

00:08:59.579 --> 00:09:01.649
发生

00:09:00.240 --> 00:09:04.649
而如果您的亮度为2 

00:09:01.649 --> 00:09:06.329
每个像素的亮度是

00:09:04.649 --> 00:09:08.670
红色绿色和蓝色值为

00:09:06.329 --> 00:09:11.670
翻倍，亮度类似

00:09:08.670 --> 00:09:14.040
 1/2将意味着一切都会

00:09:11.670 --> 00:09:16.079
所有像素值都变暗

00:09:14.040 --> 00:09:18.209
他们想要的一半是另一个

00:09:16.079 --> 00:09:20.189
我觉得这很有趣

00:09:18.209 --> 00:09:23.459
会复杂得多，但我

00:09:20.189 --> 00:09:26.430
找到了一个非常简单的公式

00:09:23.459 --> 00:09:30.600
很好，所以您对

00:09:26.430 --> 00:09:33.000
值，您只需增加阅读

00:09:30.600 --> 00:09:35.339
通过您添加的温暖值得出的像素

00:09:33.000 --> 00:09:38.009
想要的价值就得到了蓝色

00:09:35.339 --> 00:09:40.709
值，然后从中减去温暖

00:09:38.009 --> 00:09:41.790
这是一个非常简单的公式，但是

00:09:40.709 --> 00:09:43.949
它实际上产生了很好的效果

00:09:41.790 --> 00:09:46.620
所以你可以看到发生的是

00:09:43.949 --> 00:09:49.019
当您增加温暖滑块时

00:09:46.620 --> 00:09:50.850
图像变少，变蓝，变红

00:09:49.019 --> 00:09:53.490
给它一个温暖的色调，类似

00:09:50.850 --> 00:09:55.860
当减小滑块时，图像

00:09:53.490 --> 00:09:57.750
变蓝，变红，所以这是

00:09:55.860 --> 00:10:00.000
显然，这是一种非常简单的方法

00:09:57.750 --> 00:10:03.809
达到我发现的效果

00:10:00.000 --> 00:10:06.059
非常令人惊讶，我发现

00:10:03.809 --> 00:10:07.980
大部分用于

00:10:06.059 --> 00:10:11.730
过滤器有两种学校

00:10:07.980 --> 00:10:13.920
每个人的思想之一

00:10:11.730 --> 00:10:15.899
将是一个非常简单的机械

00:10:13.920 --> 00:10:17.550
达到效果的方法

00:10:15.899 --> 00:10:20.970
温暖只是改变红色和蓝色

00:10:17.550 --> 00:10:24.079
值，只是一个固定值

00:10:20.970 --> 00:10:28.079
这样效果很好

00:10:24.079 --> 00:10:30.360
其他人正在采用详细模型

00:10:28.079 --> 00:10:33.420
你们当中的人知道大脑如何感知

00:10:30.360 --> 00:10:36.240
图像以及您的眼睛如何产生

00:10:33.420 --> 00:10:38.879
比较自然的模型

00:10:36.240 --> 00:10:41.370
比较复杂，所以我选择了这个

00:10:38.879 --> 00:10:43.829
所有这些中的简单方法，但您可能

00:10:41.370 --> 00:10:45.509
发现如果您四处寻找

00:10:43.829 --> 00:10:46.769
实际实现这些

00:10:45.509 --> 00:10:48.569
一些复杂的版本

00:10:46.769 --> 00:10:50.399
以及通过下一个

00:10:48.569 --> 00:10:51.660
我想说的滤镜是对比

00:10:50.399 --> 00:10:52.829
这是另一个

00:10:51.660 --> 00:10:54.540
有趣的是我不知道这怎么

00:10:52.829 --> 00:10:56.759
在开始这个项目之前工作过

00:10:54.540 --> 00:10:59.339
我们正在做的想法是

00:10:56.759 --> 00:11:01.470
像素看起来更加鲜明

00:10:59.339 --> 00:11:04.679
图像的每个部分

00:11:01.470 --> 00:11:06.620
与其他部分不同

00:11:04.679 --> 00:11:08.690
像这样

00:11:06.620 --> 00:11:11.930
我们可以做到的方式是

00:11:08.690 --> 00:11:13.970
说让我们让每个像素都

00:11:11.930 --> 00:11:19.430
颜色离得更远

00:11:13.970 --> 00:11:21.680
灰色所以面包才是灰色

00:11:19.430 --> 00:11:23.830
一半的绿色等于一半的蓝色等于一半

00:11:21.680 --> 00:11:26.270
在白色和黑色之间， 

00:11:23.830 --> 00:11:28.610
我们增加对比度的方式

00:11:26.270 --> 00:11:31.970
这种情况是如果

00:11:28.610 --> 00:11:33.380
我们的像素超过一半，然后我们

00:11:31.970 --> 00:11:35.210
它更大，如果小于一半，我们

00:11:33.380 --> 00:11:39.830
缩小它，我们制作所有像素

00:11:35.210 --> 00:11:42.530
远离灰色

00:11:39.830 --> 00:11:45.530
现在增加对比度，这不会

00:11:42.530 --> 00:11:47.720
如果您的形象让我们工作得很好

00:11:45.530 --> 00:11:49.190
说它很暗所以大部分像素

00:11:47.720 --> 00:11:51.290
实际上会小于灰色

00:11:49.190 --> 00:11:53.150
会降低对比度

00:11:51.290 --> 00:11:55.310
他们都变黑了

00:11:53.150 --> 00:11:57.650
非常黑暗，如果发生同样的情况

00:11:55.310 --> 00:11:59.570
一切都很轻，所以其他

00:11:57.650 --> 00:12:01.730
我在这里有能力

00:11:59.570 --> 00:12:05.390
改变灰点，这就是

00:12:01.730 --> 00:12:07.460
值被用作灰色，所以我们可以设置

00:12:05.390 --> 00:12:09.830
从几乎黑色到灰色的灰点

00:12:07.460 --> 00:12:13.490
几乎是白色且灰点是

00:12:09.830 --> 00:12:16.640
几乎是白色的，那意味着很多

00:12:13.490 --> 00:12:18.560
较亮的像素仍然会

00:12:16.640 --> 00:12:21.680
当我们移动

00:12:18.560 --> 00:12:23.750
灰色点朝黑色变暗

00:12:21.680 --> 00:12:25.730
其中一些像素会变亮，所以

00:12:23.750 --> 00:12:28.010
您可以选择适合您的灰色点

00:12:25.730 --> 00:12:31.520
一般来说要设置的图像

00:12:28.010 --> 00:12:33.800
灰点是所有平均值

00:12:31.520 --> 00:12:36.110
图像中的像素数，以便更多

00:12:33.800 --> 00:12:38.210
像素彼此远离

00:12:36.110 --> 00:12:40.040
平均而言，我还没有实现

00:12:38.210 --> 00:12:42.590
自动，虽然那是一回事

00:12:40.040 --> 00:12:43.640
一些图像应用程序代替

00:12:42.590 --> 00:12:45.530
我刚刚给了一个滑块，您可以

00:12:43.640 --> 00:12:48.410
选择任何看起来不错的东西，这样

00:12:45.530 --> 00:12:50.480
我实现了其中一些过滤器

00:12:48.410 --> 00:12:52.970
知道像小插图一样

00:12:50.480 --> 00:12:54.910
使图像越远越暗

00:12:52.970 --> 00:12:56.960
是从中心而来的

00:12:54.910 --> 00:12:58.730
还有许多其他类型的过滤器

00:12:56.960 --> 00:13:00.980
我本可以实现你

00:12:58.730 --> 00:13:02.000
可能会在其他应用程序中找到

00:13:00.980 --> 00:13:04.280
在更复杂的情况下做到了

00:13:02.000 --> 00:13:07.850
方式，但我希望这是合理的

00:13:04.280 --> 00:13:09.650
这些事情如何运作的例子，所以我

00:13:07.850 --> 00:13:10.790
希望你喜欢这个节目， 

00:13:09.650 --> 00:13:12.400
下次我们聊天时您会加入我的行列

00:13:10.790 --> 00:13:14.750
关于其他事情

00:13:12.400 --> 00:13:16.430
感谢您收看我的视频

00:13:14.750 --> 00:13:18.530
您可以订阅以下频道

00:13:16.430 --> 00:13:19.800
来自Chrome开发人员的更多内容或关注

00:13:18.530 --> 00:13:23.510
屏幕上的链接以观看其他

00:13:19.800 --> 00:13:23.510
着装奇兹的情节

