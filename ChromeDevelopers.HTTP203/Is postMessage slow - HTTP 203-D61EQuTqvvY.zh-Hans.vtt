WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.210 --> 00:00:06.720
 [笑声] 

00:00:08.189 --> 00:00:18.240
 [音乐] 

00:00:14.000 --> 00:00:20.730
好吧，所以我基本上就是

00:00:18.240 --> 00:00:23.070
正确地写了一篇博客文章

00:00:20.730 --> 00:00:24.420
有趣的是它很好很好

00:00:23.070 --> 00:00:25.920
似乎没有其他人同意

00:00:24.420 --> 00:00:27.480
辉煌，所以你可以把它推下来

00:00:25.920 --> 00:00:30.630
每个人的喉咙放到2 

00:00:27.480 --> 00:00:33.270
或3集繁荣好战术出色

00:00:30.630 --> 00:00:35.820
我们在说什么，所以哦，您的

00:00:33.270 --> 00:00:38.219
文章是是我们再次交谈

00:00:35.820 --> 00:00:39.780
我说的是卢卡斯

00:00:38.219 --> 00:00:42.180
我一直在做一些研究

00:00:39.780 --> 00:00:44.550
并找出粗糙的边缘

00:00:42.180 --> 00:00:46.379
工人的实际表现是什么

00:00:44.550 --> 00:00:49.110
利益和绩效影响

00:00:46.379 --> 00:00:51.750
一分钟内成本又最差的地方

00:00:49.110 --> 00:00:53.760
基本上至少是我

00:00:51.750 --> 00:00:56.070
希望大多数应用程序使用工作人员来管理

00:00:53.760 --> 00:00:58.770
状态，因为大部分时间都是州

00:00:56.070 --> 00:01:01.410
与任何Dom或

00:00:58.770 --> 00:01:03.030
最主要的线程ap只是一个状态

00:01:01.410 --> 00:01:05.309
对象是的，我们看到了像

00:01:03.030 --> 00:01:08.580
 Redux存储了很多东西

00:01:05.309 --> 00:01:10.260
那里就像Dom一样

00:01:08.580 --> 00:01:11.670
具体的，那么为什么不使用Redux 

00:01:10.260 --> 00:01:14.250
工人例如右权利会看到

00:01:11.670 --> 00:01:17.189
一个例子好吧，让我们来谈论一个

00:01:14.250 --> 00:01:19.200
虚构的另一个做这个程序，因为

00:01:17.189 --> 00:01:21.540
虽然还不够，我们还不够

00:01:19.200 --> 00:01:24.000
假设我们会将我们的状态放在一个类中

00:01:21.540 --> 00:01:25.860
声明它拥有您所有的方法

00:01:24.000 --> 00:01:26.700
想要你加做你

00:01:25.860 --> 00:01:29.130
谈了一点

00:01:26.700 --> 00:01:30.659
您甚至可以订阅更改，因此

00:01:29.130 --> 00:01:32.720
您会接到一个电话

00:01:30.659 --> 00:01:35.820
待办事项清单中有一些变化， 

00:01:32.720 --> 00:01:38.280
到杰​​森湾（Jason Bay），看到这堂课变成了

00:01:35.820 --> 00:01:40.229
可以序列化的小型JSON对象

00:01:38.280 --> 00:01:42.329
或通过电汇发送，然后您就可以

00:01:40.229 --> 00:01:47.070
内部通知功能

00:01:42.329 --> 00:01:48.750
通知所有订阅者，所以如果您

00:01:47.070 --> 00:01:51.180
放置一个回调来订阅它

00:01:48.750 --> 00:01:52.920
要将其添加到订户费率

00:01:51.180 --> 00:01:54.119
大概对吧好吧好吧，所以我知道

00:01:52.920 --> 00:01:56.939
我们在这里所做的只是在

00:01:54.119 --> 00:01:58.530
其他我添加一个通讯链接，因为它使

00:01:56.939 --> 00:02:00.360
更容易，所以从某种意义上说，我们只是

00:01:58.530 --> 00:02:01.649
公开执行状态的实例

00:02:00.360 --> 00:02:02.820
这意味着我们可以在其他地方使用它

00:02:01.649 --> 00:02:05.009
线程而不必担心

00:02:02.820 --> 00:02:07.710
发布消息有意义，好的

00:02:05.009 --> 00:02:09.179
所以这意味着在主线程上

00:02:07.710 --> 00:02:11.700
看起来像这样，我们创建了一个工人

00:02:09.179 --> 00:02:13.709
我们将其包装在comlink中，现在我们有了

00:02:11.700 --> 00:02:15.569
这个实例

00:02:13.709 --> 00:02:18.180
即使它实际上生活在某个地方

00:02:15.569 --> 00:02:19.799
否则汤姆眨眼是魔术，所以我们可以

00:02:18.180 --> 00:02:21.870
我们可以知道吗，谁说我们可以

00:02:19.799 --> 00:02:24.450
调用订阅传递我们的回调，所以

00:02:21.870 --> 00:02:25.980
每次都会调用此回调

00:02:24.450 --> 00:02:28.560
说我们可以称之为渲染的更改

00:02:25.980 --> 00:02:30.629
可以是反应渲染或HTML或

00:02:28.560 --> 00:02:32.819
现在什么都不重要

00:02:30.629 --> 00:02:35.220
确实在使用分号时不一致

00:02:32.819 --> 00:02:36.470
这张幻灯片我其实不是很

00:02:35.220 --> 00:02:40.980
困扰着我

00:02:36.470 --> 00:02:43.109
只有我想念一个，哦，好吧，我

00:02:40.980 --> 00:02:45.359
缺少两个，所以一旦他们在那里

00:02:43.109 --> 00:02:47.639
像我的技能一样发明的更漂亮

00:02:45.359 --> 00:02:48.629
毁了，因为我只是我没有

00:02:47.639 --> 00:02:50.639
由于某种原因我在此运行

00:02:48.629 --> 00:02:52.200
应该是，如果您有，我们有

00:02:50.639 --> 00:02:55.260
像新任务按钮一样，您可以添加一个

00:02:52.200 --> 00:02:57.120
单击监听器，您知道将呼叫添加到

00:02:55.260 --> 00:02:58.319
这样做是因为那就是好处

00:02:57.120 --> 00:03:00.629
翅膀来给你，好吧

00:02:58.319 --> 00:03:03.450
大家都在同一页面上

00:03:00.629 --> 00:03:04.829
大概是我想象人们使用

00:03:03.450 --> 00:03:06.269
像字面上的工人只是写一堂课

00:03:04.829 --> 00:03:07.950
它具有您的状态，您只需致电

00:03:06.269 --> 00:03:09.720
方法，突然之间你有了你的

00:03:07.950 --> 00:03:11.250
主线程的逻辑有很多

00:03:09.720 --> 00:03:12.689
好处，但我不会去找我

00:03:11.250 --> 00:03:14.459
写了关于他们的博客文章，我们可以链接

00:03:12.689 --> 00:03:17.099
他们在描述中为我读了更多

00:03:14.459 --> 00:03:19.919
是的，但我想更进一步

00:03:17.099 --> 00:03:22.109
看一下这个通知功能，因为

00:03:19.919 --> 00:03:24.269
事实，我们正在调用一个函数

00:03:22.109 --> 00:03:26.040
在主线程上时

00:03:24.269 --> 00:03:28.680
工作才是真正的核心

00:03:26.040 --> 00:03:31.979
 comlink权利的魔力，那是一种

00:03:28.680 --> 00:03:34.079
与之相当的你知道

00:03:31.979 --> 00:03:35.879
引擎盖下发生的更多细节

00:03:34.079 --> 00:03:39.150
但实际上comlink在做什么

00:03:35.879 --> 00:03:41.159
通过发布消息发送消息到

00:03:39.150 --> 00:03:43.440
另一个线程说你知道

00:03:41.159 --> 00:03:45.030
用这些调用这个函数

00:03:43.440 --> 00:03:46.859
论点，让我知道

00:03:45.030 --> 00:03:49.409
返回值很多comlink只是

00:03:46.859 --> 00:03:51.000
知道像叫它的东西

00:03:49.409 --> 00:03:52.889
在哪里将回复发送给您

00:03:51.000 --> 00:03:56.220
正是最核心的

00:03:52.889 --> 00:03:58.799
艾米莉的逻辑是大多数人的真实

00:03:56.220 --> 00:04:01.169
出于某种原因而担心的是

00:03:58.799 --> 00:04:03.629
慢或者或者如果他们实际上有

00:04:01.169 --> 00:04:05.900
那种认为这很慢的假设

00:04:03.629 --> 00:04:08.340
或您的线程跳序列化

00:04:05.900 --> 00:04:10.310
关于文明的事，但没人

00:04:08.340 --> 00:04:12.359
我真的知道他们的意思

00:04:10.310 --> 00:04:14.009
特别是在这个头上，所以我想我

00:04:12.359 --> 00:04:16.259
想深入研究，我想

00:04:14.009 --> 00:04:18.750
测量它，我想看看

00:04:16.259 --> 00:04:21.690
指出我们实际上正在遇到问题

00:04:18.750 --> 00:04:25.050
区域好吧好吧，所以我看着

00:04:21.690 --> 00:04:27.120
规格，我一直在看规格

00:04:25.050 --> 00:04:29.820
我当时有点

00:04:27.120 --> 00:04:31.949
我告诉的HTML规范不堪重负

00:04:29.820 --> 00:04:34.080
颜色恰好让我通过它

00:04:31.949 --> 00:04:35.580
现在得到它，但我要去

00:04:34.080 --> 00:04:37.320
为了这个情节，我该看书了

00:04:35.580 --> 00:04:41.550
我要变成伪代码哦

00:04:37.320 --> 00:04:43.979
哦，精神很好，所以当你

00:04:41.550 --> 00:04:46.110
发送呼叫后消息的参数是

00:04:43.979 --> 00:04:49.260
您要发送的邮件

00:04:46.110 --> 00:04:50.639
如果工作，目标是隐式的

00:04:49.260 --> 00:04:53.430
在帖子消息中，您显然会

00:04:50.639 --> 00:04:55.860
在世界上工作是它的自我点张贴

00:04:53.430 --> 00:04:57.690
隐含地意味着主要的信息

00:04:55.860 --> 00:04:59.340
产生您的线程，您将收到

00:04:57.690 --> 00:05:00.990
消息正在发生的是

00:04:59.340 --> 00:05:03.930
我调用数据的参数

00:05:00.990 --> 00:05:05.580
发送的消息被序列化为

00:05:03.930 --> 00:05:08.340
一种称为结构化序列化的功能

00:05:05.580 --> 00:05:10.080
该函数不是实数，至少不在

00:05:08.340 --> 00:05:12.330
第七个暴露给JavaScript，但它

00:05:10.080 --> 00:05:14.160
规格中存在，所以我想我们应该

00:05:12.330 --> 00:05:15.449
说New Yor to Jason的功能

00:05:14.160 --> 00:05:17.850
我们在返回对象之前使用的

00:05:15.449 --> 00:05:19.560
不只是一个字符串，您还知道一个对象

00:05:17.850 --> 00:05:21.690
是的，它也是一个字符串，不是

00:05:19.560 --> 00:05:23.039
像结构化CS不在乎，但它

00:05:21.690 --> 00:05:25.160
没有自己做序列化

00:05:23.039 --> 00:05:27.620
没那么多，只是把你变成一个

00:05:25.160 --> 00:05:29.699
邻近的不可能的物体，是的，对

00:05:27.620 --> 00:05:32.970
所以结构会改变这一点

00:05:29.699 --> 00:05:37.820
变成序列化的格式

00:05:32.970 --> 00:05:42.060
格式不是JavaScript的方面

00:05:37.820 --> 00:05:44.160
引擎内部写了陷阱，但是它

00:05:42.060 --> 00:05:46.710
基本只是意味着它是某种形式

00:05:44.160 --> 00:05:48.090
不是Java的二进制表示形式

00:05:46.710 --> 00:05:49.950
对象处于其当前状态，但

00:05:48.090 --> 00:05:53.760
封装s-所有键和值

00:05:49.950 --> 00:05:57.270
所有正确的事物都包含

00:05:53.760 --> 00:05:59.729
下一步是在目标中排队任务

00:05:57.270 --> 00:06:01.710
现在，目标领域基本上是

00:05:59.729 --> 00:06:03.780
将收到消息的威胁

00:06:01.710 --> 00:06:06.210
现在我们要在

00:06:03.780 --> 00:06:07.650
任务队列将运行一次代码

00:06:06.210 --> 00:06:08.669
该任务变得标量，我们没有

00:06:07.650 --> 00:06:10.020
需要或什么时候会

00:06:08.669 --> 00:06:11.430
这就是它的显示方式

00:06:10.020 --> 00:06:12.810
您目前或在HTML中

00:06:11.430 --> 00:06:14.190
记录它需要做的事情

00:06:12.810 --> 00:06:15.449
在工作线程上的工作中

00:06:14.190 --> 00:06:17.729
这就是它进入线程的方式

00:06:15.449 --> 00:06:20.220
恰好现在的第一步

00:06:17.729 --> 00:06:23.250
任务是转回序列化数据

00:06:20.220 --> 00:06:26.130
到新的数据实例中，所以这是

00:06:23.250 --> 00:06:28.979
垂直添加我们的深层副本

00:06:26.130 --> 00:06:30.030
原始消息对象，是的，这是

00:06:28.979 --> 00:06:31.680
很重要，因为在JavaScript中

00:06:30.030 --> 00:06:32.940
您可以共享以下对象之一

00:06:31.680 --> 00:06:34.349
童年的基本假设是

00:06:32.940 --> 00:06:38.580
一切都是单线程的，所以

00:06:34.349 --> 00:06:40.650
没有同步或并行访问

00:06:38.580 --> 00:06:42.840
相同的数据对象或相同的内存

00:06:40.650 --> 00:06:45.030
使用JavaScript，所以我们不能只是发送

00:06:42.840 --> 00:06:47.430
相同的对象必须是副本

00:06:45.030 --> 00:06:49.620
对，这两个步骤就是这样

00:06:47.430 --> 00:06:51.360
实现了陷阱，这是一个轻微的

00:06:49.620 --> 00:06:53.070
这与JSON序列化不同

00:06:51.360 --> 00:06:55.830
因为它支持更多格式

00:06:53.070 --> 00:07:00.960
处理诸如循环数据之类的东西

00:06:55.830 --> 00:07:03.930
结构是的，它可以使您的斑点

00:07:00.960 --> 00:07:07.259
设置数组缓冲区所有这些东西

00:07:03.930 --> 00:07:09.240
杰森不能做，然后最后

00:07:07.259 --> 00:07:10.979
这里的步骤基本上是调度

00:07:09.240 --> 00:07:12.660
实际事件，所以在那时

00:07:10.979 --> 00:07:15.900
消息事件处理程序将被调用

00:07:12.660 --> 00:07:17.460
然后将数据对象放在

00:07:15.900 --> 00:07:18.840
您可以访问的事件对象

00:07:17.460 --> 00:07:20.490
现在你拥有它，它就在你自己的

00:07:18.840 --> 00:07:22.350
和它所有的好酷大脑是的

00:07:20.490 --> 00:07:24.330
所以这就是现在的后消息工作方式

00:07:22.350 --> 00:07:25.979
有趣的一点当然是结构化的

00:07:24.330 --> 00:07:28.440
序列化和结构化反序列化

00:07:25.979 --> 00:07:31.889
最重要的功能

00:07:28.440 --> 00:07:33.750
当然可能是昂贵的

00:07:31.889 --> 00:07:35.190
但更重要的是

00:07:33.750 --> 00:07:37.770
我没有写之前就没有意识到

00:07:35.190 --> 00:07:40.470
文章是结构化序列化是

00:07:37.770 --> 00:07:43.919
阻止发送的功能

00:07:40.470 --> 00:07:48.240
结构化反序列化的领域将

00:07:43.919 --> 00:07:52.139
阻止接收领域，我想还可以

00:07:48.240 --> 00:07:53.970
所以为此进行序列化

00:07:52.139 --> 00:07:55.289
感觉是因为它不想成为

00:07:53.970 --> 00:07:57.419
在编辑

00:07:55.289 --> 00:07:59.520
物体物体物体物体物体物体

00:07:57.419 --> 00:08:01.860
即使进行反序列化也很有意义

00:07:59.520 --> 00:08:04.050
因为它正在使用您的对象

00:08:01.860 --> 00:08:05.820
像数组这样的领域，什么都不是

00:08:04.050 --> 00:08:07.320
不能真的运行那些

00:08:05.820 --> 00:08:09.930
您的代码仍在正确运行，因此如果

00:08:07.320 --> 00:08:11.340
你改变了，就像我不知道

00:08:09.930 --> 00:08:12.510
原型或一半的东西

00:08:11.340 --> 00:08:14.610
你不希望这一点得到体现

00:08:12.510 --> 00:08:16.110
恰好，但这将称为

00:08:14.610 --> 00:08:18.389
不会像电话上的东西那样打电话

00:08:16.110 --> 00:08:20.669
像现在种族的东西一样不确定

00:08:18.389 --> 00:08:22.560
我觉得那可能是我想

00:08:20.669 --> 00:08:24.599
听说他们已经考虑过这样做

00:08:22.560 --> 00:08:26.520
但到目前为止，这不是当前的意愿

00:08:24.599 --> 00:08:27.780
阻止接收领域的陷阱

00:08:26.520 --> 00:08:30.720
所以这实际上很有趣，因为

00:08:27.780 --> 00:08:34.500
这意味着到目前为止我一直都在

00:08:30.720 --> 00:08:36.240
测量III继续测量

00:08:34.500 --> 00:08:38.190
从我开始发送

00:08:36.240 --> 00:08:40.200
反对当我收到它，但

00:08:38.190 --> 00:08:42.450
我得到的数字实际上是两个部分

00:08:40.200 --> 00:08:43.740
这是一部分是序列化，另一部分是

00:08:42.450 --> 00:08:45.660
部分是反序列化

00:08:43.740 --> 00:08:48.000
不同的权利

00:08:45.660 --> 00:08:49.170
领域，所以我想衡量

00:08:48.000 --> 00:08:50.190
他们分开，但我还没有找到一个

00:08:49.170 --> 00:08:51.810
这样做的好方法，所以我还是

00:08:50.190 --> 00:08:53.370
测量在我的长凳上，我们要

00:08:51.810 --> 00:08:54.510
谈论但只是要保留的东西

00:08:53.370 --> 00:08:56.520
请记住，数字

00:08:54.510 --> 00:09:00.540
我们将在谈论的同时

00:08:56.520 --> 00:09:03.410
这些可怕的微观基准

00:09:00.540 --> 00:09:05.970
数字将代表

00:09:03.410 --> 00:09:07.980
序列化和反序列化

00:09:05.970 --> 00:09:10.140
每个线程的实际成本为

00:09:07.980 --> 00:09:11.550
比这个数字低的东西

00:09:10.140 --> 00:09:14.460
你在测量那基本上是我吗

00:09:11.550 --> 00:09:16.500
你只是在你之前做一个记号笔

00:09:14.460 --> 00:09:18.990
电话留言，这是您的n或

00:09:16.500 --> 00:09:20.280
不太好，是的，我收到的消息很漂亮

00:09:18.990 --> 00:09:23.250
这就是我要测量的

00:09:20.280 --> 00:09:25.590
是的，我决定这样做，因为我

00:09:23.250 --> 00:09:27.720
找到了几种方法，也许

00:09:25.590 --> 00:09:29.700
测量只是反序列化隔离我

00:09:27.720 --> 00:09:31.920
发现没有办法只测量序列化

00:09:29.700 --> 00:09:33.750
孤立，但我只能找出

00:09:31.920 --> 00:09:35.610
这些方法在Chrome中使用这些方法， 

00:09:33.750 --> 00:09:38.040
 Safari，所以我无法

00:09:35.610 --> 00:09:39.750
做Firefox，所以我认为

00:09:38.040 --> 00:09:41.550
端到端测试为我提供了一个上限

00:09:39.750 --> 00:09:44.550
消息传递的两边给什么

00:09:41.550 --> 00:09:48.030
您的序列化时间不确定吗

00:09:44.550 --> 00:09:49.590
也许我可能会添加其他内容

00:09:48.030 --> 00:09:51.030
好吧好吧好吧，所以每个人都做

00:09:49.590 --> 00:09:52.620
端到端是这样吗

00:09:51.030 --> 00:09:54.240
一定会减少

00:09:52.620 --> 00:09:55.920
比这贵，所以它给你

00:09:54.240 --> 00:09:57.720
它给您带来最坏的情况

00:09:55.920 --> 00:09:59.010
我运动的原因是

00:09:57.720 --> 00:10:01.110
如果我们谈论的话可能会更好

00:09:59.010 --> 00:10:03.690
弹性和类似问题第一

00:10:01.110 --> 00:10:05.070
我想找出的东西不是

00:10:03.690 --> 00:10:08.850
必然得到硬数字，但仅仅是

00:10:05.070 --> 00:10:11.610
弄清楚消息的形状

00:10:08.850 --> 00:10:14.130
使帖子消息变慢是否一般

00:10:11.610 --> 00:10:15.690
真的很复杂的对象很多笔记或

00:10:14.130 --> 00:10:19.140
也不能是非常简单的对象

00:10:15.690 --> 00:10:20.490
非常大的字符串作为值，所以我

00:10:19.140 --> 00:10:23.580
贝蒂是我写的一个函数

00:10:20.490 --> 00:10:25.830
产生非常不同的对象

00:10:23.580 --> 00:10:28.170
有时很小，有很长很长的键

00:10:25.830 --> 00:10:32.040
大约2至4 KB 

00:10:28.170 --> 00:10:34.740
有时对象的图非常复杂

00:10:32.040 --> 00:10:36.270
只是很短的键和短的

00:10:34.740 --> 00:10:39.510
重视那些感觉的线条

00:10:36.270 --> 00:10:41.250
像深入一样会更努力，因为

00:10:39.510 --> 00:10:42.990
试图让他转过身来

00:10:41.250 --> 00:10:44.610
这些序列化的你们知道，如果你

00:10:42.990 --> 00:10:48.090
考虑一下这两个功能

00:10:44.610 --> 00:10:51.120
以某种方式遍历整个对象

00:10:48.090 --> 00:10:52.470
我的直觉也很简单

00:10:51.120 --> 00:10:55.350
具有更长的值将更快

00:10:52.470 --> 00:10:57.900
复制然后使用更简单的复杂对象

00:10:55.350 --> 00:11:01.620
事实证明，它实际上是线性的

00:10:57.900 --> 00:11:04.230
具有此序列化的有效负载大小，因此如果

00:11:01.620 --> 00:11:05.490
你有像波浪一样的物体

00:11:04.230 --> 00:11:07.620
发生了什么事

00:11:05.490 --> 00:11:08.779
我是，但是会解释的，但是如果你

00:11:07.620 --> 00:11:12.360
基本上

00:11:08.779 --> 00:11:16.410
杰森（Jason）整理您的有效载荷并查看

00:11:12.360 --> 00:11:19.470
该字符串的长度是作为大小

00:11:16.410 --> 00:11:21.150
这是非常非常有力的指标

00:11:19.470 --> 00:11:22.320
到底要持续多久

00:11:21.150 --> 00:11:24.240
就像这是一个东西一样

00:11:22.320 --> 00:11:26.700
巨大的弦甚至是长弦

00:11:24.240 --> 00:11:28.290
需要很长时间才能复制它，或者

00:11:26.700 --> 00:11:30.060
其他方式不是一样快

00:11:28.290 --> 00:11:32.790
将复杂对象复制到简单对象中

00:11:30.060 --> 00:11:35.040
如果大小相同，那么您去哪一个

00:11:32.790 --> 00:11:37.380
记住两个尺度都是

00:11:35.040 --> 00:11:40.800
对数的，因为否则

00:11:37.380 --> 00:11:43.950
是嗯，所以这种相关性成立

00:11:40.800 --> 00:11:46.140
数学上，嗯，但实际上只有四个

00:11:43.950 --> 00:11:47.279
超过10 KB的对象，因为

00:11:46.140 --> 00:11:48.900
你看着它，你会看到它弯曲

00:11:47.279 --> 00:11:49.440
里面有几个离群值

00:11:48.900 --> 00:11:51.240
是的

00:11:49.440 --> 00:11:53.010
这是出于两个原因

00:11:51.240 --> 00:11:54.960
我们仍然降低了精度

00:11:53.010 --> 00:11:57.060
计时器归因于频谱崩溃

00:11:54.960 --> 00:11:59.070
是的，甚至还会增加一些抖动

00:11:57.060 --> 00:12:00.900
定时，以便您可以知道

00:11:59.070 --> 00:12:02.670
减少这些高

00:12:00.900 --> 00:12:04.890
精确定时攻击

00:12:02.670 --> 00:12:07.410
当然也参与其中

00:12:04.890 --> 00:12:09.180
下端有些奇怪

00:12:07.410 --> 00:12:12.630
波动和设置开销只是

00:12:09.180 --> 00:12:14.970
借口数字更多点肯定是这样

00:12:12.630 --> 00:12:17.610
这是在我的Macbook Pro上运行的

00:12:14.970 --> 00:12:19.950
大约用了五微秒

00:12:17.610 --> 00:12:21.720
每千字节这个数字不是真的

00:12:19.950 --> 00:12:23.550
有用的，我会有所不同

00:12:21.720 --> 00:12:25.080
其他设备没问题

00:12:23.550 --> 00:12:27.000
定位是否值得衡量

00:12:25.080 --> 00:12:29.550
以低端为目标，所以我

00:12:27.000 --> 00:12:30.720
绝对不要测量这些数字

00:12:29.550 --> 00:12:32.430
并做出我只想做的决定

00:12:30.720 --> 00:12:34.560
有趣的是看到什么样的

00:12:32.430 --> 00:12:35.520
规模，我们说得很好，所以在

00:12:34.560 --> 00:12:37.709
换句话说，你现在所做的就是我

00:12:35.520 --> 00:12:39.690
知道基本上没关系

00:12:37.709 --> 00:12:41.339
如字符串，如果我要的大小是

00:12:39.690 --> 00:12:43.470
我可以工作多长时间的好指标

00:12:41.339 --> 00:12:46.589
只是想在几个

00:12:43.470 --> 00:12:49.470
设备，看看我们在什么时候运行

00:12:46.589 --> 00:12:51.540
铁路预算陷入困境

00:12:49.470 --> 00:12:53.190
好的，所以我们在谈论它何时开始

00:12:51.540 --> 00:12:54.959
例如超过16岁

00:12:53.190 --> 00:12:58.740
基本上就是我开始的时候

00:12:54.959 --> 00:13:00.390
 chrome中的MacBook，可以运行一千个

00:12:58.740 --> 00:13:02.760
对于这里的每个星座

00:13:00.390 --> 00:13:04.740
基本上看我们在什么时候运行

00:13:02.760 --> 00:13:06.570
基本上陷入铁路预算问题

00:13:04.740 --> 00:13:09.120
我们正在寻找这个数字或

00:13:06.570 --> 00:13:10.350
大于60毫秒，因此，如果您

00:13:09.120 --> 00:13:11.790
看着这边的绿色

00:13:10.350 --> 00:13:13.560
在她之间意味着任何东西的区域

00:13:11.790 --> 00:13:16.320
千字节和1兆字节的有效负载

00:13:13.560 --> 00:13:20.070
尺寸就是MacBook Pro的尺寸

00:13:16.320 --> 00:13:21.630
铬我们处于麻烦区和更低

00:13:20.070 --> 00:13:23.970
比那我们绝对

00:13:21.630 --> 00:13:25.290
当你说有效载荷布雷特时，我重生了

00:13:23.970 --> 00:13:27.300
因为这里的单位不只是

00:13:25.290 --> 00:13:29.910
喜欢免费的物体D，因为我的意思是

00:13:27.300 --> 00:13:32.610
就像每一个呼吸音符一样

00:13:29.910 --> 00:13:34.410
注意具有三个值或四个值或

00:13:32.610 --> 00:13:36.690
五个值，深度是多深

00:13:34.410 --> 00:13:38.190
我们走到那棵树有多复杂

00:13:36.690 --> 00:13:39.600
我在这里建立我有更多的例子

00:13:38.190 --> 00:13:41.130
在我的博客文章上，但是基本上

00:13:39.600 --> 00:13:44.730
真的只是因为我们

00:13:41.130 --> 00:13:48.120
现在知道对象大小还是不错的

00:13:44.730 --> 00:13:49.920
我们真的只是看着颜色

00:13:48.120 --> 00:13:52.079
生病了，所以我们在说36 

00:13:49.920 --> 00:13:53.160
六点到六点六点到六点

00:13:52.079 --> 00:13:55.139
当然会咳嗽

00:13:53.160 --> 00:13:56.670
好吧，所以这是一个很大的对象

00:13:55.139 --> 00:13:57.569
是的，这就是为什么我们想出了

00:13:56.670 --> 00:14:00.389
就像十兆字节

00:13:57.569 --> 00:14:02.399
而且我认为每个键叶子键都是两个

00:14:00.389 --> 00:14:03.959
千字节字符串，所以加起来很多

00:14:02.399 --> 00:14:06.660
很多数据陷阱

00:14:03.959 --> 00:14:07.740
好吧，我正在追踪，是的，我们可以

00:14:06.660 --> 00:14:09.779
看看我们是否百分之十兆

00:14:07.740 --> 00:14:11.250
阻塞474毫秒

00:14:09.779 --> 00:14:15.209
很多，如果我们运行动画

00:14:11.250 --> 00:14:19.980
那将太多47 47毫秒

00:14:15.209 --> 00:14:24.180
所以只有德国格式德国是

00:14:19.980 --> 00:14:28.620
令人惊讶的是我没有32德语

00:14:24.180 --> 00:14:31.740
默默地做间谍哦，对，我以为你

00:14:28.620 --> 00:14:33.870
刚开玩笑就不像四点以后

00:14:31.740 --> 00:14:35.699
多年在这里让我搞砸了是免费的

00:14:33.870 --> 00:14:36.959
和二十多岁，他们就像我不

00:14:35.699 --> 00:14:39.329
知道为什么会像其他德语一样

00:14:36.959 --> 00:14:42.689
很合乎逻辑，所以需要七个

00:14:39.329 --> 00:14:45.060
 40毫秒是47微米

00:14:42.689 --> 00:14:47.310
但是任何低于硬千字节的东西

00:14:45.060 --> 00:14:49.560
绝对可以，我们不会阻止

00:14:47.310 --> 00:14:52.439
主要威胁太久而无法做出

00:14:49.560 --> 00:14:53.790
我们的动画很烂，但这是

00:14:52.439 --> 00:14:54.959
最重要的一点是

00:14:53.790 --> 00:14:56.430
像这样的MacBook Pro不是

00:14:54.959 --> 00:14:58.769
代表平均设备

00:14:56.430 --> 00:15:01.199
设备特别是哦，所以这会

00:14:58.769 --> 00:15:04.019
在手机上工作就可以了

00:15:01.199 --> 00:15:05.610
危险区域我也在诺基亚上运行过

00:15:04.019 --> 00:15:08.880
实际上代表了

00:15:05.610 --> 00:15:09.269
第50个百分位设备

00:15:08.880 --> 00:15:11.579
世界

00:15:09.269 --> 00:15:13.170
是的，尽管中间

00:15:11.579 --> 00:15:16.500
硬件陷入2014年

00:15:13.170 --> 00:15:18.990
大概说mm-hmm回家但是

00:15:16.500 --> 00:15:21.180
好圈子变得更大了，所以如果我们

00:15:18.990 --> 00:15:23.819
现在寻找您知道周围的数字

00:15:21.180 --> 00:15:26.130
现在我们可以看到60毫秒大关

00:15:23.819 --> 00:15:28.100
你知道什么是安全的我们不能去

00:15:26.130 --> 00:15:31.319
大于10 KB 

00:15:28.100 --> 00:15:33.149
好的，这在这里，我们有一个

00:15:31.319 --> 00:15:35.340
 12在这里可能还可以12 

00:15:33.149 --> 00:15:37.740
你知道我们是否看一下

00:15:35.340 --> 00:15:39.180
蓝色和绿松石之间，是的哦

00:15:37.740 --> 00:15:41.880
我们不能超过10 KB 

00:15:39.180 --> 00:15:44.850
或在我们的铁路预算中，但实际

00:15:41.880 --> 00:15:46.380
边界并没有改变太多

00:15:44.850 --> 00:15:47.730
就像这个数字一样

00:15:46.380 --> 00:15:50.040
更大的权利，但如果您发送

00:15:47.730 --> 00:15:51.000
兆字节你是疯子，是的

00:15:50.040 --> 00:15:53.040
需要很长时间才能接管

00:15:51.000 --> 00:15:54.570
半秒，但通常是

00:15:53.040 --> 00:15:56.370
其实我们真的很高兴

00:15:54.570 --> 00:15:58.680
因为我觉得如果你有

00:15:56.370 --> 00:16:00.660
运行您的国家/地区仅限10个

00:15:58.680 --> 00:16:02.910
千字节实际上是十千字节

00:16:00.660 --> 00:16:04.020
很多东西你什么都可以丢掉

00:16:02.910 --> 00:16:05.280
有点像是的，如果你只是喜欢

00:16:04.020 --> 00:16:07.800
转移数十亿和数字

00:16:05.280 --> 00:16:11.520
是的，那是你说的

00:16:07.800 --> 00:16:11.940
记住我们建造的这款游戏哦，我的

00:16:11.520 --> 00:16:13.830
字

00:16:11.940 --> 00:16:16.410
是的，是的，因为这是

00:16:13.830 --> 00:16:17.880
最大可能的感觉是

00:16:16.410 --> 00:16:19.470
甚至可以放到屏幕上40 

00:16:17.880 --> 00:16:22.440
到40岁，这是我们最大的领域

00:16:19.470 --> 00:16:25.470
目前允许1,600个单元格对

00:16:22.440 --> 00:16:28.380
是的，每个这些细胞都有一个

00:16:25.470 --> 00:16:30.990
确实可以存储几个标志

00:16:28.380 --> 00:16:32.340
这些在代码中是

00:16:30.990 --> 00:16:33.870
当然，这基本上是我们的游戏

00:16:32.340 --> 00:16:36.810
像我们有40 40 

00:16:33.870 --> 00:16:38.820
二维数组，每个单元格都有

00:16:36.810 --> 00:16:39.660
这些数据存储在里面，所以我们知道

00:16:38.820 --> 00:16:42.270
游戏领域看起来像

00:16:39.660 --> 00:16:44.190
现在证明那个json字符串化了

00:16:42.270 --> 00:16:47.370
触觉上加起来约一百

00:16:44.190 --> 00:16:49.260
 30 KB的Jason哦，所以我们可以

00:16:47.370 --> 00:16:52.050
太大而无法发送整个状态

00:16:49.260 --> 00:16:56.700
是的，它会说我们正在

00:16:52.050 --> 00:16:58.200
有点像不懒，但像我们

00:16:56.700 --> 00:16:59.820
每个单元只能有一个或一个代表

00:16:58.200 --> 00:17:02.160
例如，还是可以的

00:16:59.820 --> 00:17:04.560
是一个数组缓冲区，因为是的

00:17:02.160 --> 00:17:06.060
大约32位或多少位

00:17:04.560 --> 00:17:07.709
在这里我们需要信息吗？ 

00:17:06.060 --> 00:17:09.420
 32很好，我的意思是因为像

00:17:07.709 --> 00:17:12.150
触动心灵的切换

00:17:09.420 --> 00:17:14.940
最多8位，这3位，然后

00:17:12.150 --> 00:17:16.380
你有9位9位9位

00:17:14.940 --> 00:17:17.790
好，所以这可能只是一个数组

00:17:16.380 --> 00:17:18.120
缓冲并不需要全是

00:17:17.790 --> 00:17:19.170
数

00:17:18.120 --> 00:17:20.130
它不需要二维

00:17:19.170 --> 00:17:22.980
因为我们只要知道宽度

00:17:20.130 --> 00:17:25.320
就像是的，是的，是的，我们

00:17:22.980 --> 00:17:26.370
最终注意到我们采取了

00:17:25.320 --> 00:17:28.140
开始你只要被设置

00:17:26.370 --> 00:17:30.060
有人窃听我们必须发送的东西

00:17:28.140 --> 00:17:32.250
更新到主线程的状态

00:17:30.060 --> 00:17:33.660
是的，所以我们可以后方渲染

00:17:32.250 --> 00:17:34.950
像这样的低端手机花了太长时间

00:17:33.660 --> 00:17:36.870
我们做不到，我们知道很多

00:17:34.950 --> 00:17:39.380
从效果面板上

00:17:36.870 --> 00:17:43.560
太久了的开发工具

00:17:39.380 --> 00:17:45.450
现在我们要做的是另一件事

00:17:43.560 --> 00:17:46.560
又是我给你的，但我们说我们

00:17:45.450 --> 00:17:49.170
而不是发送整个

00:17:46.560 --> 00:17:51.870
说明我们正在发送

00:17:49.170 --> 00:17:54.360
是改变的领域，所以我们

00:17:51.870 --> 00:17:56.130
基本上做了一个DIF，这有点

00:17:54.360 --> 00:17:57.660
很酷，因为这意味着我们的数量

00:17:56.130 --> 00:17:59.520
我们必须发送的不是

00:17:57.660 --> 00:18:01.500
与游戏设定成正比，但

00:17:59.520 --> 00:18:03.870
仅限于我们所做的更改

00:18:01.500 --> 00:18:05.430
进入游戏状态是的，即使现在

00:18:03.870 --> 00:18:08.070
有些情况，尤其是在第一种情况下

00:18:05.430 --> 00:18:10.290
点击可能会增加很多数据，因为

00:18:08.070 --> 00:18:12.090
从一开始就大显身手

00:18:10.290 --> 00:18:14.250
理论上大约是70 

00:18:12.090 --> 00:18:15.810
如果我们假设80％的

00:18:14.250 --> 00:18:17.460
一个字段被揭示，这不太可能

00:18:15.810 --> 00:18:19.080
但是你知道最坏的情况吗

00:18:17.460 --> 00:18:20.250
好的，所以我们做了另一件事， 

00:18:19.080 --> 00:18:21.510
那就是我想说的

00:18:20.250 --> 00:18:22.740
因为我觉得它真的很聪明

00:18:21.510 --> 00:18:24.480
我们已经完成了您想要的事情

00:18:22.740 --> 00:18:27.780
说说我们可能正在录音

00:18:24.480 --> 00:18:30.120
就目前而言，我们了解了

00:18:27.780 --> 00:18:32.580
插曲权利有人轻拍是

00:18:30.120 --> 00:18:33.660
我们的游戏逻辑基本上可以遍历

00:18:32.580 --> 00:18:35.820
通过游戏来解决

00:18:33.660 --> 00:18:38.280
哪些字段需要更改状态

00:18:35.820 --> 00:18:39.660
 mm-hmm，我们记录这些变化

00:18:38.280 --> 00:18:41.880
因为我们要发送更改

00:18:39.660 --> 00:18:44.490
但是只要我们发现10个变化或

00:18:41.880 --> 00:18:46.050
我们更喜欢10的更多原因

00:18:44.490 --> 00:18:48.210
以前是我们拉他们的号码

00:18:46.050 --> 00:18:50.520
是的，我们凭空寄出了那十个

00:18:48.210 --> 00:18:51.720
立即更改主线程

00:18:50.520 --> 00:18:53.370
可以开始渲染和做事

00:18:51.720 --> 00:18:54.630
当工人继续前进并保持

00:18:53.370 --> 00:18:56.280
遍历，因为它不仅是

00:18:54.630 --> 00:18:57.660
序列化和反序列化成本是

00:18:56.280 --> 00:19:00.690
爬网的成本是的

00:18:57.660 --> 00:19:02.310
好吧，是的，然后我们

00:19:00.690 --> 00:19:03.840
意识到我们写的方式

00:19:02.310 --> 00:19:06.660
遍历字段的算法

00:19:03.840 --> 00:19:08.520
看起来真的很好，所以慢

00:19:06.660 --> 00:19:11.010
我在这里录音的手机

00:19:08.520 --> 00:19:12.840
看起来你真的很漂亮

00:19:11.010 --> 00:19:14.490
动画，即使在更大的设备上

00:19:12.840 --> 00:19:16.380
这将像它做任何事的实例

00:19:14.490 --> 00:19:17.610
矩阵能够，所以我们不会

00:19:16.380 --> 00:19:19.770
立即到那里，但是慢一点

00:19:17.610 --> 00:19:22.410
设备，您将获得不错的动画，是的

00:19:19.770 --> 00:19:24.630
这就是我们使这个巨大状态的方式

00:19:22.410 --> 00:19:27.330
对象实际在最低的

00:19:24.630 --> 00:19:28.620
你知道我以为是低端设备

00:19:27.330 --> 00:19:30.810
为我们的出色表现而感到自豪

00:19:28.620 --> 00:19:33.510
当我们发现

00:19:30.810 --> 00:19:34.290
当我们看到这种情况时，我们做了

00:19:33.510 --> 00:19:37.080
它也发生在桌面上

00:19:34.290 --> 00:19:38.940
人为地与一个惊人的

00:19:37.080 --> 00:19:40.950
来获得这个动画，因为它是

00:19:38.940 --> 00:19:42.930
该算法的第二遍

00:19:40.950 --> 00:19:44.610
因为我们第一次是你

00:19:42.930 --> 00:19:46.500
深度优先，我们遇到了麻烦

00:19:44.610 --> 00:19:47.850
问题，然后我们切换到EQ 

00:19:46.500 --> 00:19:52.710
基于，这就是我们最终

00:19:47.850 --> 00:19:54.840
我的意思是为了你

00:19:52.710 --> 00:19:56.550
在一个工人中管理您的证书

00:19:54.840 --> 00:19:59.700
如此多的小技巧，您可以不用

00:19:56.550 --> 00:20:01.950
我认为向后弯腰

00:19:59.700 --> 00:20:02.860
没有不放你的好借口

00:20:01.950 --> 00:20:04.210
表示工作和帮助

00:20:02.860 --> 00:20:06.490
这个借贷设备上有很多

00:20:04.210 --> 00:20:09.040
实际上我们已经进行了测试，或者我们跑了

00:20:06.490 --> 00:20:10.600
在主线程上执行所有操作

00:20:09.040 --> 00:20:12.760
表现糟糕，所以我们实际上

00:20:10.600 --> 00:20:14.320
已经知道要使用工人了

00:20:12.760 --> 00:20:15.700
从一开始就特别是因为

00:20:14.320 --> 00:20:17.230
我们一直都在发生动画

00:20:15.700 --> 00:20:18.910
是的，很难从中看到

00:20:17.230 --> 00:20:20.650
从这个角度来看， 

00:20:18.910 --> 00:20:22.720
因为这是没有动画的视图

00:20:20.650 --> 00:20:24.220
好吧，但通常这些小方块

00:20:22.720 --> 00:20:25.570
像我们一样连续演出

00:20:24.220 --> 00:20:26.920
实际上，在运行WebGL时，我们需要所有

00:20:25.570 --> 00:20:29.080
预算和我们可以得到的主要

00:20:26.920 --> 00:20:30.640
到WebGL，所以其他一切都一样

00:20:29.080 --> 00:20:32.020
我们可以将它移到其他地方， 

00:20:30.640 --> 00:20:34.600
我们很高兴我们做到了，所以我认为

00:20:32.020 --> 00:20:36.220
邮寄费用或其他要点

00:20:34.600 --> 00:20:37.900
它使主线程消失的地方

00:20:36.220 --> 00:20:39.309
完全不可用，所以我希望

00:20:37.900 --> 00:20:41.020
你知道这个人会

00:20:39.309 --> 00:20:43.720
有点启发尝试并给予

00:20:41.020 --> 00:20:47.500
在主线程之外进行管理

00:20:43.720 --> 00:20:49.450
是的，我们有些抖动

00:20:47.500 --> 00:20:55.630
人工添加，当然不是

00:20:49.450 --> 00:20:59.350
人工添加抖动后抱歉

00:20:55.630 --> 00:21:01.330
说你也说这是人为的

00:20:59.350 --> 00:21:04.470
再次添加，因为我打断了它， 

00:21:01.330 --> 00:21:07.770
你也说过我今天会诚实的

00:21:04.470 --> 00:21:07.770
确定你做了

