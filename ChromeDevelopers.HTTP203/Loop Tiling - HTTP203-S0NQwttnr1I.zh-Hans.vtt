WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.030 --> 00:00:17.340
但坚持三不知道你是否

00:00:13.860 --> 00:00:18.930
注意到让我建立一个东西是我们

00:00:17.340 --> 00:00:21.630
再来谈谈史克鲁奇

00:00:18.930 --> 00:00:23.250
好的，Skoosh的另一方面

00:00:21.630 --> 00:00:25.260
对，所以这很有趣

00:00:23.250 --> 00:00:27.900
所以这可能是一个很长的时间，所以请忍受

00:00:25.260 --> 00:00:30.990
我我将从我们开始的地方开始

00:00:27.900 --> 00:00:33.780
然后我们就掉进了这个

00:00:30.990 --> 00:00:35.820
兔子洞，我希望观众

00:00:33.780 --> 00:00:38.100
与我们一起陷入兔子洞

00:00:35.820 --> 00:00:40.559
是的，我真的很期待

00:00:38.100 --> 00:00:42.750
这是因为有时候我们

00:00:40.559 --> 00:00:44.850
是的，我们当中的一员可能

00:00:42.750 --> 00:00:47.489
假装少了解

00:00:44.850 --> 00:00:49.289
比我们做的更重要

00:00:47.489 --> 00:00:51.840
我真的没有很多

00:00:49.289 --> 00:00:53.760
了解，我真的很担心， 

00:00:51.840 --> 00:00:55.500
可能实际上无法解释

00:00:53.760 --> 00:00:57.750
你想要我的一切

00:00:55.500 --> 00:00:59.250
好吧，让我们看看我们的结局

00:00:57.750 --> 00:01:01.739
是的，老实说，我会让你知道

00:00:59.250 --> 00:01:04.320
从我们在网络上的图像开始

00:01:01.739 --> 00:01:06.000
我们用JavaScript操作它们，因此

00:01:04.320 --> 00:01:07.920
让我们来谈谈图像数据

00:01:06.000 --> 00:01:09.360
我们在壁球中使用的数据结构

00:01:07.920 --> 00:01:11.189
一旦您收到图片，我们就会对其进行解码

00:01:09.360 --> 00:01:12.689
然后把它变成一个图像数据对象

00:01:11.189 --> 00:01:14.189
这是存在于

00:01:12.689 --> 00:01:17.610
一个平台基本上有三个

00:01:14.189 --> 00:01:21.750
具有高度和数据的属性是数据

00:01:17.610 --> 00:01:23.759
有一个un8钳位阵列， 

00:01:21.750 --> 00:01:27.150
每个像素只有四个字节

00:01:23.759 --> 00:01:29.400
是的，这是第一行， 

00:01:27.150 --> 00:01:32.250
第二排，依此类推，每个人都像

00:01:29.400 --> 00:01:33.810
红色，绿色，蓝色Alpha正是这样

00:01:32.250 --> 00:01:35.369
这就像是红色像素而不是

00:01:33.810 --> 00:01:37.259
绿色像素，蓝色像素，白色

00:01:35.369 --> 00:01:39.119
像素，因为图像是两个

00:01:37.259 --> 00:01:41.189
这就是图像看起来的两个

00:01:39.119 --> 00:01:44.700
就像不错，所以它只是一个

00:01:41.189 --> 00:01:46.920
一系列没有概念的数字

00:01:44.700 --> 00:01:48.450
行或列，但正因为如此

00:01:46.920 --> 00:01:50.369
我们可以重新排列的信息意味着

00:01:48.450 --> 00:01:52.170
将它们解释为适当的两个

00:01:50.369 --> 00:01:52.710
尺寸像环

00:01:52.170 --> 00:01:56.759
这个怎么运作

00:01:52.710 --> 00:01:58.950
好的，所以现在在Scrooged，我们有了

00:01:56.759 --> 00:02:00.780
目标将图像旋转90度

00:01:58.950 --> 00:02:03.420
听起来似乎很简单

00:02:00.780 --> 00:02:06.570
花10分钟，我是说你写了

00:02:03.420 --> 00:02:08.160
第一个版本正确，所以让我们

00:02:06.570 --> 00:02:09.750
谈论你如何写它，你旋转

00:02:08.160 --> 00:02:11.220
 90度图像

00:02:09.750 --> 00:02:13.920
获取输入图像即该图像

00:02:11.220 --> 00:02:15.810
数据对象是的，以及我们所做的

00:02:13.920 --> 00:02:17.819
通过ng增长找出新的

00:02:15.810 --> 00:02:19.260
新高度的宽度

00:02:17.819 --> 00:02:21.239
只是你知道高度和宽度

00:02:19.260 --> 00:02:23.430
交换了您正在做的Surma代码

00:02:21.239 --> 00:02:24.300
已经有一点，因为否则

00:02:23.430 --> 00:02:26.819
那不合适

00:02:24.300 --> 00:02:28.290
所以我正在压缩东西

00:02:26.819 --> 00:02:30.239
好的

00:02:28.290 --> 00:02:32.280
所以在这里您实际上是在分配

00:02:30.239 --> 00:02:33.989
高度到宽度，鞭子到

00:02:32.280 --> 00:02:35.310
高，因为它是90度，还可以

00:02:33.989 --> 00:02:37.260
我很喜欢，我正在训练新的

00:02:35.310 --> 00:02:39.390
输出图像宽度具有此新宽度

00:02:37.260 --> 00:02:41.130
和新的高度是的，所以现在的目标

00:02:39.390 --> 00:02:44.400
是通过像素并将其放入

00:02:41.130 --> 00:02:46.680
 Alpha的正确位置，因此您可以

00:02:44.400 --> 00:02:50.040
缓解循环中的所有像素

00:02:46.680 --> 00:02:52.200
输入图像，我们找出在哪里

00:02:50.040 --> 00:02:54.030
他们将不得不降落在输出中

00:02:52.200 --> 00:02:55.799
因此基本上是新的x坐标

00:02:54.030 --> 00:02:57.900
是那种形式的

00:02:55.799 --> 00:03:00.030
 y坐标，然后我们计算

00:02:57.900 --> 00:03:01.709
哪个输入像素是哪个

00:03:00.030 --> 00:03:03.060
人们，只是复制更多的幻想

00:03:01.709 --> 00:03:06.930
所以我的代码不会通过

00:03:03.060 --> 00:03:09.959
回顾我知道还可以，因为

00:03:06.930 --> 00:03:11.549
每个像素有四个字节，我们只是循环

00:03:09.959 --> 00:03:13.860
超过四次，随便做什么

00:03:11.549 --> 00:03:15.660
就像我们复制R值G 

00:03:13.860 --> 00:03:17.370
重视B值和a值

00:03:15.660 --> 00:03:19.170
我们去了足够多，这有效并且

00:03:17.370 --> 00:03:20.400
这实际上是相当快的

00:03:19.170 --> 00:03:24.290
这样运输我们应该说

00:03:20.400 --> 00:03:26.549
我们这样做而不是使用画布的原因是

00:03:24.290 --> 00:03:27.959
因为我们想在一个工人中运行它

00:03:26.549 --> 00:03:31.530
完全不同哦，是的

00:03:27.959 --> 00:03:34.170
我们做了很多测试，似乎

00:03:31.530 --> 00:03:35.519
更多的时尚技术没有

00:03:34.170 --> 00:03:37.049
似乎有效，所以我们最终写了我们的

00:03:35.519 --> 00:03:38.400
自己的一段JavaScript为此

00:03:37.049 --> 00:03:40.049
问题是，因为屏幕外的画布

00:03:38.400 --> 00:03:42.720
仅在几个浏览器中

00:03:40.049 --> 00:03:44.220
这只是基本的JavaScript JavaScript 

00:03:42.720 --> 00:03:45.780
这样就可以在任何地方

00:03:44.220 --> 00:03:48.030
工人，因为它是它的形象，所以

00:03:45.780 --> 00:03:49.200
这是我们应该做的，是的，是的

00:03:48.030 --> 00:03:52.380
然后我看了一下

00:03:49.200 --> 00:03:54.150
就像实际上有某种

00:03:52.380 --> 00:03:56.910
您错过的太明显的优化

00:03:54.150 --> 00:03:59.459
所以我基本上打赌您会添加一个

00:03:56.910 --> 00:04:01.769
小补丁，这一切都说明了

00:03:59.459 --> 00:04:05.940
和以前一样，但是现在我正在创建

00:04:01.769 --> 00:04:07.380
你一个32数组是的，但这是这样

00:04:05.940 --> 00:04:10.079
基本上我们有相同的底层

00:04:07.380 --> 00:04:12.930
大块的内存，但没有看到它

00:04:10.079 --> 00:04:14.340
作为一系列字节，我们将其视为

00:04:12.930 --> 00:04:18.180
系列的32位

00:04:14.340 --> 00:04:21.000
数字右像素由32位组成

00:04:18.180 --> 00:04:24.270
 RGB和a的数字正确，所以这

00:04:21.000 --> 00:04:25.950
我们可以简化或实际删除的方式

00:04:24.270 --> 00:04:27.150
内部循环所以是的，只是

00:04:25.950 --> 00:04:28.800
那是在那

00:04:27.150 --> 00:04:30.840
你知道做四次

00:04:28.800 --> 00:04:32.610
每次我们现在只做一次

00:04:30.840 --> 00:04:34.080
实际映射到

00:04:32.610 --> 00:04:35.490
机器指令或有时是v8 

00:04:34.080 --> 00:04:37.620
会像超级聪明，像

00:04:35.490 --> 00:04:40.290
好快，所以他们排序实际上知道

00:04:37.620 --> 00:04:42.030
快很多，是的，然后很酷，然后

00:04:40.290 --> 00:04:44.760
我们出货还不错，然后

00:04:42.030 --> 00:04:47.970
结果是出于某种原因

00:04:44.760 --> 00:04:51.060
浏览器，这是超级慢的权利， 

00:04:47.970 --> 00:04:52.710
我们已经通过法律咨询了我们

00:04:51.060 --> 00:04:55.260
部门未命名浏览器

00:04:52.710 --> 00:04:56.940
显然，这是Chrome政策，不是

00:04:55.260 --> 00:04:58.169
我以前从未听过，但没有

00:04:56.940 --> 00:05:00.330
我们不允许谈论其他

00:04:58.169 --> 00:05:03.000
浏览器，所以我们不能提及哪个

00:05:00.330 --> 00:05:04.320
浏览器是没有运行的浏览器

00:05:03.000 --> 00:05:06.479
没有在您的计算机上运行的计算机

00:05:04.320 --> 00:05:08.940
你知道吗，知道吗

00:05:06.479 --> 00:05:11.370
这种不同的浏览器可以

00:05:08.940 --> 00:05:13.620
就像大多数兄弟都足够好

00:05:11.370 --> 00:05:14.880
至少出于某种原因

00:05:13.620 --> 00:05:17.370
一位兄弟刚被

00:05:14.880 --> 00:05:18.840
如此极其缓慢甚至缓慢

00:05:17.370 --> 00:05:21.660
所以我们一定碰到了一个怪异的角落

00:05:18.840 --> 00:05:23.729
情况是是是弟弟通常不慢

00:05:21.660 --> 00:05:25.199
这是一个非常好的浏览器，是的，并且

00:05:23.729 --> 00:05:26.400
优化了不同的JavaScript引擎

00:05:25.199 --> 00:05:28.770
与不同的东西，所以事实

00:05:26.400 --> 00:05:30.330
一个浏览器的速度慢，这里不是说

00:05:28.770 --> 00:05:33.360
那个浏览器很糟糕

00:05:30.330 --> 00:05:35.520
说像v8这样很好

00:05:33.360 --> 00:05:38.190
那种紧密循环的代码，是的，其他

00:05:35.520 --> 00:05:40.740
引擎已针对更多dom进行了优化

00:05:38.190 --> 00:05:42.030
绑定确切，所以不是

00:05:40.740 --> 00:05:44.310
令人惊讶的是，一个浏览器是

00:05:42.030 --> 00:05:46.260
计划完全不同

00:05:44.310 --> 00:05:48.599
用这段代码，所以我们认为没有

00:05:46.260 --> 00:05:50.430
我们该怎么做，也许我们会炒更多的网络

00:05:48.599 --> 00:05:52.979
在问题上集会吧

00:05:50.430 --> 00:05:54.930
研究了第一个问题

00:05:52.979 --> 00:05:56.430
当你聪明的时候我们就代表

00:05:54.930 --> 00:05:58.680
李和您加载它变成一个

00:05:56.430 --> 00:06:00.240
具有功能的模块功能

00:05:58.680 --> 00:06:02.039
你用任何语言写的

00:06:00.240 --> 00:06:04.110
使用是的，对，这是

00:06:02.039 --> 00:06:06.060
与回显脚本模块不同的是

00:06:04.110 --> 00:06:08.820
这不是模块中的另一件事

00:06:06.060 --> 00:06:12.180
不同的东西，这些功能可以

00:06:08.820 --> 00:06:15.300
只接受并返回数字，所以

00:06:12.180 --> 00:06:18.630
没有简单的方法直达传递

00:06:15.300 --> 00:06:20.039
一张图片，所以你怎么做就正确

00:06:18.630 --> 00:06:22.289
我们最终要做的是

00:06:20.039 --> 00:06:24.030
重用我为文章制作的视频

00:06:22.289 --> 00:06:25.650
基本上是Java的辉煌，所以我们

00:06:24.030 --> 00:06:27.510
要加载图像，将其放入

00:06:25.650 --> 00:06:29.250
 Web程序集内存，然后我们要

00:06:27.510 --> 00:06:31.139
使用网络程序集来完成

00:06:29.250 --> 00:06:33.300
在网络组装中重新排序

00:06:31.139 --> 00:06:35.610
内存缓冲区并使用JavaScript读取

00:06:33.300 --> 00:06:37.200
然后将其返回，这意味着

00:06:35.610 --> 00:06:40.050
代表我真的是完全

00:06:37.200 --> 00:06:40.950
与外界隔绝

00:06:40.050 --> 00:06:42.990
真的是这样

00:06:40.950 --> 00:06:44.370
它只有一块内存可以工作

00:06:42.990 --> 00:06:46.140
在我们将读入图像中做

00:06:44.370 --> 00:06:47.940
重新排序我们之前显示的

00:06:46.140 --> 00:06:49.680
然后Java猛扑回来接手

00:06:47.940 --> 00:06:51.450
并读回生成的图像，这样

00:06:49.680 --> 00:06:54.150
这些javascript和网络程序集

00:06:51.450 --> 00:06:55.890
他们分享的是像他们一样的记忆

00:06:54.150 --> 00:06:58.280
携带很多，但十二集

00:06:55.890 --> 00:07:00.750
这是它的汇编狗记忆

00:06:58.280 --> 00:07:02.610
 Webassembly特定的内存，但它是

00:07:00.750 --> 00:07:04.620
也暴露为数组缓冲区

00:07:02.610 --> 00:07:06.330
可以在Java中使用32数组或

00:07:04.620 --> 00:07:08.040
在那种情况下我们需要的

00:07:06.330 --> 00:07:09.720
对，所以我们需要网络存储

00:07:08.040 --> 00:07:11.760
组装实质上是尺寸的两倍

00:07:09.720 --> 00:07:13.110
的图像，因为它会

00:07:11.760 --> 00:07:14.910
您可以从中的主图像开始

00:07:13.110 --> 00:07:17.880
记忆，然后下一位，然后

00:07:14.910 --> 00:07:19.440
好的，我们如何创建区域

00:07:17.880 --> 00:07:21.900
我们之前已经用C中的M脚本做到了

00:07:19.440 --> 00:07:23.580
但是的也生锈，但我们实际上发现

00:07:21.900 --> 00:07:26.010
我们偶然发现了一个非常有趣的项目

00:07:23.580 --> 00:07:29.670
在被称为汇编脚本是

00:07:26.010 --> 00:07:31.790
他们称自己为类型脚本

00:07:29.670 --> 00:07:34.680
 Webassembly编译器mm-hmm这是

00:07:31.790 --> 00:07:36.390
是的，但可能会有点

00:07:34.680 --> 00:07:38.220
误导，因为那不是你不能

00:07:36.390 --> 00:07:40.650
只需采用任何类型的脚本并进行编译

00:07:38.220 --> 00:07:42.810
到Epis Emily，它正在使用打字稿

00:07:40.650 --> 00:07:45.000
语法和打字稿标准

00:07:42.810 --> 00:07:46.350
图书馆的东西，但有自己的

00:07:45.000 --> 00:07:48.780
某些库的版本是

00:07:46.350 --> 00:07:50.130
专为网络组装量身定制

00:07:48.780 --> 00:07:52.230
您在这里看到的是签名

00:07:50.130 --> 00:07:54.780
现在我们有类型，如您所知

00:07:52.230 --> 00:07:56.880
网络表格打字稿，但我32 

00:07:54.780 --> 00:07:58.680
 Web程序集具有的类型，但是

00:07:56.880 --> 00:08:01.350
 JavaScript没有，那是32位

00:07:58.680 --> 00:08:03.120
整数正确是符号32位

00:08:01.350 --> 00:08:05.520
签署利益也没关系

00:08:03.120 --> 00:08:09.000
您32这是我们未签名的

00:08:05.520 --> 00:08:10.980
出于某些原因使用签名

00:08:09.000 --> 00:08:13.080
好吧，让我们掩饰它，是的，这是

00:08:10.980 --> 00:08:14.820
好的cuz II可以识别它，看起来

00:08:13.080 --> 00:08:16.470
非常像JavaScript，也非常像

00:08:14.820 --> 00:08:19.440
其余两行除外

00:08:16.470 --> 00:08:22.170
这看起来和你知道的Hyden一样

00:08:19.440 --> 00:08:24.960
是的，这有点有趣

00:08:22.170 --> 00:08:27.600
因为我们有这块记忆

00:08:24.960 --> 00:08:29.730
嗯，我们什至不知道我们的输入在哪里

00:08:27.600 --> 00:08:31.710
图像开始以及输出图像的位置

00:08:29.730 --> 00:08:33.150
正确的开始就是这两个

00:08:31.710 --> 00:08:34.830
变量是我们输入图像的开始

00:08:33.150 --> 00:08:36.570
在此存储器中地址0处为零

00:08:34.830 --> 00:08:38.760
你总是可以说那些索引为0 

00:08:36.570 --> 00:08:40.800
输出图像就在

00:08:38.760 --> 00:08:43.919
输入图像结束，输入图像

00:08:40.800 --> 00:08:46.290
由宽度乘以高度乘以4 5 

00:08:43.919 --> 00:08:48.680
每个像素4比特的完美照明

00:08:46.290 --> 00:08:51.630
所以谢谢

00:08:48.680 --> 00:08:53.250
看到这件事，我很抱歉

00:08:51.630 --> 00:08:54.100
中断流程说我应该说

00:08:53.250 --> 00:08:57.430
那

00:08:54.100 --> 00:08:59.620
我作为CSS专家CSS来到网络上

00:08:57.430 --> 00:09:02.139
前端，我学习了JavaScript 

00:08:59.620 --> 00:09:03.880
而您从成为一个

00:09:02.139 --> 00:09:07.000
程序员很好，然后您去了

00:09:03.880 --> 00:09:09.370
我当时的办公桌是嵌入式系统

00:09:07.000 --> 00:09:10.810
我实际上是在编写内核代码， 

00:09:09.370 --> 00:09:13.690
像低级的内存管理，我

00:09:10.810 --> 00:09:15.790
不了解CSS以及如何做UI 

00:09:13.690 --> 00:09:18.220
在任何类似的事情中

00:09:15.790 --> 00:09:19.660
两个完全不同的角度

00:09:18.220 --> 00:09:22.540
如果有人在看这个

00:09:19.660 --> 00:09:24.790
想着怎么回事，这是我

00:09:22.540 --> 00:09:26.199
我感觉完全相同的系统不

00:09:24.790 --> 00:09:29.259
太担心了吧，来吧

00:09:26.199 --> 00:09:31.209
但目前这些基本上是指数

00:09:29.259 --> 00:09:33.130
在图像从哪里开始的数组中

00:09:31.209 --> 00:09:34.660
在输出图像开始的位置，然后

00:09:33.130 --> 00:09:38.230
这看起来很熟悉循环所有

00:09:34.660 --> 00:09:39.670
像素，是的，我吓坏了

00:09:38.230 --> 00:09:40.060
新坐标是我们做的所有这些吗

00:09:39.670 --> 00:09:42.670
之前

00:09:40.060 --> 00:09:45.100
是的，现在有这些要组装

00:09:42.670 --> 00:09:47.880
脚本特定功能的第一个

00:09:45.100 --> 00:09:51.759
是加载，允许我加载u-32 

00:09:47.880 --> 00:09:52.990
从内存中的给定地址开始

00:09:51.759 --> 00:09:54.790
所以在这种情况下，我正在做的是

00:09:52.990 --> 00:09:57.250
我正在使用输入图像空间

00:09:54.790 --> 00:09:58.540
图像开始的位置加上像素I 

00:09:57.250 --> 00:10:00.370
想阅读，所以这非常类似于

00:09:58.540 --> 00:10:02.529
我们之前在U中所做的

00:10:00.370 --> 00:10:04.720
 32 ye ray 

00:10:02.529 --> 00:10:06.279
但这是词，但我似乎

00:10:04.720 --> 00:10:07.839
从内存中直接获取它Ravi是的

00:10:06.279 --> 00:10:09.250
因为这是一个Webassembly内存， 

00:10:07.839 --> 00:10:10.689
就像正确的听

00:10:09.250 --> 00:10:12.939
你得到FS作为参考

00:10:10.689 --> 00:10:14.439
就像全球一样

00:10:12.939 --> 00:10:16.569
但这是我们过去的一件事

00:10:14.439 --> 00:10:18.699
与X完全相同的行业

00:10:16.569 --> 00:10:20.050
好，所以我们要加载像素，然后

00:10:18.699 --> 00:10:21.399
我们要做的就像写回去

00:10:20.050 --> 00:10:22.899
到输出图像，它是相同的

00:10:21.399 --> 00:10:23.410
我们正在存储值V 

00:10:22.899 --> 00:10:25.689
刚读

00:10:23.410 --> 00:10:28.389
 mm-hm像往常一样回到

00:10:25.689 --> 00:10:31.360
输出图像库好了，现在我们有了

00:10:28.389 --> 00:10:34.060
书面汇编脚本和这个

00:10:31.360 --> 00:10:35.829
转换为网络程序集，我该怎么办

00:10:34.060 --> 00:10:38.740
真正令我震惊的是，如果我

00:10:35.829 --> 00:10:40.839
想写网页汇编这是

00:10:38.740 --> 00:10:43.509
我会用的工具，因为这看起来

00:10:40.839 --> 00:10:45.579
很早就很对，因为

00:10:43.509 --> 00:10:48.459
是的，我想你已经学到了一些

00:10:45.579 --> 00:10:49.689
 C是因为Skoosh是的，但是那是

00:10:48.459 --> 00:10:52.180
据我所知你几乎拥有

00:10:49.689 --> 00:10:56.019
没有写锈我想你可以写

00:10:52.180 --> 00:10:58.000
我知道PHP PHP可以进行webassembly 

00:10:56.019 --> 00:11:00.040
编译器，但我会喜欢它

00:10:58.000 --> 00:11:01.750
我学到的第一门母语，所以我们

00:11:00.040 --> 00:11:03.279
现在要拥有此功能

00:11:01.750 --> 00:11:05.260
幸运地编译为网络汇编

00:11:03.279 --> 00:11:07.779
组装非常容易，所以我们只是

00:11:05.260 --> 00:11:10.379
安装程序集脚本包并

00:11:07.779 --> 00:11:13.029
我们有一个ASC命令，我们给我们

00:11:10.379 --> 00:11:15.699
打字稿过滤器，还给我们

00:11:13.029 --> 00:11:17.499
无附加胶水的webassembly文件

00:11:15.699 --> 00:11:18.910
或我认为相当不错的JavaScript 

00:11:17.499 --> 00:11:20.980
有趣，因为其他大多数

00:11:18.910 --> 00:11:23.230
 Web程序集的实现

00:11:20.980 --> 00:11:25.990
你蓝色的代码，这是巨大的JavaScript 

00:11:23.230 --> 00:11:28.290
文件设备真的是很难

00:11:25.990 --> 00:11:32.019
处理和合作，但这仅仅是

00:11:28.290 --> 00:11:34.449
是的，只是一个不对，所以我们做到了

00:11:32.019 --> 00:11:37.180
我们有一条路，这不是犯规，现在

00:11:34.449 --> 00:11:39.009
有趣的一点可能是如何加载它

00:11:37.180 --> 00:11:40.779
因为通常蓝色代码会为其加载

00:11:39.009 --> 00:11:42.220
你，但现在你没有胶水代码

00:11:40.779 --> 00:11:44.220
这项工作实际上不是

00:11:42.220 --> 00:11:46.720
困难的是你采取了

00:11:44.220 --> 00:11:48.339
从实例化流功能

00:11:46.720 --> 00:11:49.959
 Web程序集对象正确，然后将

00:11:48.339 --> 00:11:52.629
行动在那里，因为网络大会

00:11:49.959 --> 00:11:54.939
编译器至少是非优化的

00:11:52.629 --> 00:11:56.559
天气仍然可以编译

00:11:54.939 --> 00:11:58.389
这样下载本质上

00:11:56.559 --> 00:12:01.360
尖叫承诺一个承诺或

00:11:58.389 --> 00:12:03.879
响应或数组缓冲区，或者

00:12:01.360 --> 00:12:05.980
奇怪的API，就像为什么会为什么

00:12:03.879 --> 00:12:07.269
是否承诺他们是我们想要的

00:12:05.980 --> 00:12:10.449
使这个简单，如果您不必

00:12:07.269 --> 00:12:11.829
等待提取正确，好吧，我不要

00:12:10.449 --> 00:12:13.920
同意，但这很好，你应该

00:12:11.829 --> 00:12:16.420
我把它放在那里

00:12:13.920 --> 00:12:19.209
开始编译钱包，所以亲爱的

00:12:16.420 --> 00:12:22.089
这不像下载然后编译它

00:12:19.209 --> 00:12:24.399
实际上几乎是并行的

00:12:22.089 --> 00:12:26.529
最了解网络装配

00:12:24.399 --> 00:12:29.170
很大，你知道，就像我认为单位

00:12:26.529 --> 00:12:30.519
虚幻引擎之一就像40 

00:12:29.170 --> 00:12:32.019
兆字节将使

00:12:30.519 --> 00:12:34.959
差异是绝对的

00:12:32.019 --> 00:12:36.519
这里不是很多，所以绝对不是这样

00:12:34.959 --> 00:12:38.949
是的，有一些模型

00:12:36.519 --> 00:12:41.079
像500字节之类的东西

00:12:38.949 --> 00:12:43.209
非常小，比它还小

00:12:41.079 --> 00:12:45.610
压缩和gzip JavaScript代码

00:12:43.209 --> 00:12:47.050
其实我们很酷，现在

00:12:45.610 --> 00:12:50.649
我们从这个实例中得到一个实例

00:12:47.050 --> 00:12:52.269
在这种情况下，我们可以出口

00:12:50.649 --> 00:12:53.860
然后导出就是所有功能

00:12:52.269 --> 00:12:56.410
还有我们要去的记忆

00:12:53.860 --> 00:12:57.699
正确地工作，以便我们增加记忆

00:12:56.410 --> 00:12:59.559
因为我们不知道它有多大

00:12:57.699 --> 00:13:02.920
但我们必须达到它的大小

00:12:59.559 --> 00:13:04.240
适合我们的图像两次正确

00:13:02.920 --> 00:13:06.519
今年必须做微积分

00:13:04.240 --> 00:13:08.230
但这就是

00:13:06.519 --> 00:13:10.389
无效数组的大小

00:13:08.230 --> 00:13:12.279
他们是时候了，好吧好吧， 

00:13:10.389 --> 00:13:14.019
然后我将以某种方式将该图像加载到

00:13:12.279 --> 00:13:15.459
缓冲区实际上只是内存

00:13:14.019 --> 00:13:17.110
关于缓冲属性，这是一个

00:13:15.459 --> 00:13:19.149
普通的数组缓冲区，所以我们可以使用所有

00:13:17.110 --> 00:13:21.089
您知道的放入数据的方法

00:13:19.149 --> 00:13:24.629
那里是这个

00:13:21.089 --> 00:13:25.829
然后您是Korell的90分

00:13:24.629 --> 00:13:28.019
图像回来，你也完成了

00:13:25.829 --> 00:13:29.399
出口有方法的目标，所以这

00:13:28.019 --> 00:13:30.660
是方法，这就是魔术， 

00:13:29.399 --> 00:13:32.519
你打电话到webassembly 

00:13:30.660 --> 00:13:33.600
大家都可以看到它是同步的

00:13:32.519 --> 00:13:35.430
网络组装将

00:13:33.600 --> 00:13:37.350
实际上将控制权从

00:13:35.430 --> 00:13:39.149
 javascript并执行其操作，然后

00:13:37.350 --> 00:13:41.189
将控件返回到javascript 

00:13:39.149 --> 00:13:42.990
就像实际功能一样

00:13:41.189 --> 00:13:45.269
好吧，我认为这非常好，所以这

00:13:42.990 --> 00:13:48.629
很快，我们对此感到非常高兴

00:13:45.269 --> 00:13:51.360
是的，这要快得多

00:13:48.629 --> 00:13:53.189
从某种意义上说，在Chrome中并没有更快

00:13:51.360 --> 00:13:55.290
像它没有表现出茉莉花

00:13:53.189 --> 00:13:57.689
被快速问到或几乎被问到，但是

00:13:55.290 --> 00:14:00.629
整个过程都一贯快速

00:13:57.689 --> 00:14:02.550
浏览器是的，这是浏览器

00:14:00.629 --> 00:14:05.910
从七秒钟起，它就无法在Mac上运行

00:14:02.550 --> 00:14:06.990
到500左右的湖

00:14:05.910 --> 00:14:09.240
毫秒的东西非常非常

00:14:06.990 --> 00:14:11.100
是的，这真的很棒

00:14:09.240 --> 00:14:13.050
看到所有的相似价值

00:14:11.100 --> 00:14:15.329
浏览器，所以我们对此感到非常高兴

00:14:13.050 --> 00:14:16.800
我们知道我们打开PRN或Scrooged 

00:14:15.329 --> 00:14:21.180
然后您进行了审核，我们写了一篇

00:14:16.800 --> 00:14:22.589
文章，然后发生骇客新闻

00:14:21.180 --> 00:14:23.699
如何使用发生了那是

00:14:22.589 --> 00:14:25.889
我永远不会说的东西，因为

00:14:23.699 --> 00:14:32.459
通常我们文章的评论是

00:14:25.889 --> 00:14:34.829
我可以用的很烦

00:14:32.459 --> 00:14:37.980
有时我会忘记书呆子，但是

00:14:34.829 --> 00:14:40.439
在这种情况下，有一些脚手架

00:14:37.980 --> 00:14:41.730
但是学脚真的很有趣

00:14:40.439 --> 00:14:45.720
有些事情真的很难

00:14:41.730 --> 00:14:47.100
令人着迷的结果，我俩只是

00:14:45.720 --> 00:14:48.059
我不明白的很多

00:14:47.100 --> 00:14:50.220
是的，我希望你能解释一下

00:14:48.059 --> 00:14:52.019
对我来说，所以有人说为什么不

00:14:50.220 --> 00:14:53.309
他们使用平铺瓷砖将使

00:14:52.019 --> 00:14:55.110
这么快，但他们很快尝试了

00:14:53.309 --> 00:14:58.999
是的，我完全像20 

00:14:55.110 --> 00:15:01.290
毫秒我就像是这样

00:14:58.999 --> 00:15:02.970
他们从什么中拿走了

00:15:01.290 --> 00:15:05.550
有点友好的400毫秒下降

00:15:02.970 --> 00:15:08.189
到底是什么，我认为四十四岁

00:15:05.550 --> 00:15:09.449
这是被批准的，那是

00:15:08.189 --> 00:15:12.300
甚至比我们从

00:15:09.449 --> 00:15:14.100
像这样对元素进行画布处理

00:15:12.300 --> 00:15:15.779
我显然想坐下来

00:15:14.100 --> 00:15:17.939
真正了解发生了什么

00:15:15.779 --> 00:15:20.490
让我们谈一谈实际的平铺

00:15:17.939 --> 00:15:22.499
是的，请这样做，因为我不知道

00:15:20.490 --> 00:15:24.300
我要解释平铺，但这也是

00:15:22.499 --> 00:15:25.259
另一个表现的建议

00:15:24.300 --> 00:15:28.019
我要谈论两个

00:15:25.259 --> 00:15:29.699
这些其他的第一，因为得到它

00:15:28.019 --> 00:15:31.860
基本上是有些人

00:15:29.699 --> 00:15:35.070
说哦，如果你看这Y次

00:15:31.860 --> 00:15:36.890
宽度完全独立

00:15:35.070 --> 00:15:39.180
内循环的，所以如果我将其移出

00:15:36.890 --> 00:15:40.680
在外循环和内循环之间

00:15:39.180 --> 00:15:42.750
会更快，因为我

00:15:40.680 --> 00:15:44.160
计算只能发生一次/外部

00:15:42.750 --> 00:15:46.170
循环并不需要每个都

00:15:44.160 --> 00:15:48.000
时间在内循环是的，我想

00:15:46.170 --> 00:15:50.910
这将是那种事情

00:15:48.000 --> 00:15:53.160
我会做优化器的事情

00:15:50.910 --> 00:15:54.780
为此我照顾好这个

00:15:53.160 --> 00:15:56.190
正是您的建议

00:15:54.780 --> 00:15:58.440
不必担心这种

00:15:56.190 --> 00:16:00.450
或将常量移出

00:15:58.440 --> 00:16:01.860
循环不仅是大多数

00:16:00.450 --> 00:16:03.090
编译器可以做到

00:16:01.860 --> 00:16:06.710
分配您的编译器可以做到这一点

00:16:03.090 --> 00:16:08.760
或RUS编译器，甚至v8 

00:16:06.710 --> 00:16:11.190
编译器从

00:16:08.760 --> 00:16:13.050
 JavaScript到机器代码或从Web 

00:16:11.190 --> 00:16:15.360
汇编字节码到机器码将

00:16:13.050 --> 00:16:17.250
这样做，嗯，这是一个操作

00:16:15.360 --> 00:16:18.540
我们不必做，我们可以在哪里说

00:16:17.250 --> 00:16:19.890
你知道让我们保持可读性

00:16:18.540 --> 00:16:21.660
很明显，不要介绍另一个

00:16:19.890 --> 00:16:23.520
读取代码的人的变量

00:16:21.660 --> 00:16:24.870
将不得不有更多的状态

00:16:23.520 --> 00:16:27.240
他们的头了解发生了什么

00:16:24.870 --> 00:16:30.090
是的，但是另一件事是平铺

00:16:27.240 --> 00:16:32.040
瓷砖是我所没有的

00:16:30.090 --> 00:16:33.420
听说我实际上听说过

00:16:32.040 --> 00:16:35.160
我也不是觉得

00:16:33.420 --> 00:16:37.440
编译器将为我们做到这一点

00:16:35.160 --> 00:16:39.750
情况不是这样的平铺

00:16:37.440 --> 00:16:41.310
所以这是一张图片，或者实际上是

00:16:39.750 --> 00:16:43.110
我不知道播客的专辑封面

00:16:41.310 --> 00:16:44.760
你知道我们做了一个播客

00:16:43.110 --> 00:16:48.300
以及我们应该在

00:16:44.760 --> 00:16:51.420
描述杰克是的，我们应该这样，我们

00:16:48.300 --> 00:16:54.060
到目前为止一直在阅读这张图片

00:16:51.420 --> 00:16:56.070
我们应该逐行走

00:16:54.060 --> 00:16:57.870
只要你知道这是什么像素对

00:16:56.070 --> 00:16:59.430
鲍鱼好了，再看看下一个

00:16:57.870 --> 00:17:01.920
同一房间里的像素

00:16:59.430 --> 00:17:03.540
我们做了什么，我们认为要铺好瓷砖

00:17:01.920 --> 00:17:06.750
是您平铺的另一种方法

00:17:03.540 --> 00:17:09.420
图像变成好瓷砖

00:17:06.750 --> 00:17:12.570
这些是瓷砖，然后做任何事情

00:17:09.420 --> 00:17:14.910
你想先在瓷砖内做

00:17:12.570 --> 00:17:16.829
因此，与其逐行

00:17:14.910 --> 00:17:19.020
一块又一块地内的学校

00:17:16.829 --> 00:17:22.260
你逐行去，这是

00:17:19.020 --> 00:17:24.150
当然这是同一件事

00:17:22.260 --> 00:17:26.100
完全是另一种方式

00:17:24.150 --> 00:17:27.750
我现在知道的同一件事

00:17:26.100 --> 00:17:30.900
有趣的是，事实证明这是

00:17:27.750 --> 00:17:33.090
速度要快得多

00:17:30.900 --> 00:17:34.260
时间我仍然还不明白

00:17:33.090 --> 00:17:36.750
让我们实现这个真正的快速

00:17:34.260 --> 00:17:39.450
因为实际上我不能说

00:17:36.750 --> 00:17:41.400
我们最近的一集

00:17:39.450 --> 00:17:44.820
谈到过度的危险

00:17:41.400 --> 00:17:47.190
是的，是什么，为什么？ 

00:17:44.820 --> 00:17:48.570
我们这样做是因为它最终被

00:17:47.190 --> 00:17:50.279
这么快好吗

00:17:48.570 --> 00:17:52.740
好吧，我们实际上遇到了这个

00:17:50.279 --> 00:17:54.630
优化，我们最终进展顺利

00:17:52.740 --> 00:17:56.009
轨道内的100毫秒

00:17:54.630 --> 00:17:58.169
指南使人感觉像

00:17:56.009 --> 00:18:00.059
瞬时响应按钮呢

00:17:58.169 --> 00:18:04.409
是我们之前的优化

00:18:00.059 --> 00:18:06.149
以300到500的符号，但是你知道

00:18:04.409 --> 00:18:08.130
我们可以跌破100我们应该跌破

00:18:06.149 --> 00:18:10.799
 100，尤其是对于较大的图像，这样

00:18:08.130 --> 00:18:12.750
基本上我只是再做两个

00:18:10.799 --> 00:18:14.940
外循环，但通常听起来是错误的，但是

00:18:12.750 --> 00:18:17.070
在这种情况下，我们非常正确

00:18:14.940 --> 00:18:20.610
遍历我们拥有的所有瓷砖

00:18:17.070 --> 00:18:21.990
然后在那里，我们基本上有了

00:18:20.610 --> 00:18:23.610
相同的旧循环，我们循环遍历每个循环

00:18:21.990 --> 00:18:24.269
我要开始的单个图块

00:18:23.610 --> 00:18:30.419
换气过度

00:18:24.269 --> 00:18:32.970
等等，为什么好，所以我正在平铺

00:18:30.419 --> 00:18:35.370
实施它，这样我就可以说

00:18:32.970 --> 00:18:36.840
关于为什么这可能会想做事情

00:18:35.370 --> 00:18:38.879
快一点，好吧，我不知道

00:18:36.840 --> 00:18:41.549
原来这么理解

00:18:38.879 --> 00:18:44.639
当我用Google平铺并研究它时，你

00:18:41.549 --> 00:18:46.980
这主要是矩阵的用例

00:18:44.639 --> 00:18:49.830
乘法是另一种用法

00:18:46.980 --> 00:18:53.090
情况是因为我使用了输入值

00:18:49.830 --> 00:18:55.409
好几次，如果你愿意的话

00:18:53.090 --> 00:18:58.470
将两个矩阵相乘

00:18:55.409 --> 00:19:00.330
对我来说，细胞是一对一的

00:18:58.470 --> 00:19:02.159
想一想你的每一列

00:19:00.330 --> 00:19:04.169
切割输出矩阵就可以了

00:19:02.159 --> 00:19:05.490
有道理，如果您平铺

00:19:04.169 --> 00:19:07.980
有更好的机会

00:19:05.490 --> 00:19:10.440
值仍在我们正在谈论的缓存中

00:19:07.980 --> 00:19:15.179
现在处理器一级缓存

00:19:10.440 --> 00:19:16.649
所以就像我们需要的那样挂了

00:19:15.179 --> 00:19:19.169
解释在什么时候

00:19:16.649 --> 00:19:21.720
好吧，但后来我的感觉是通过阅读

00:19:19.169 --> 00:19:23.879
顺序记忆，您更有可能

00:19:21.720 --> 00:19:25.440
去缓存，因为你在说话

00:19:23.879 --> 00:19:26.909
你正在处理一些

00:19:25.440 --> 00:19:29.820
记忆非常接近最后一个

00:19:26.909 --> 00:19:32.460
是的，如果我有两个很大的

00:19:29.820 --> 00:19:34.799
矩阵，我经过第一行

00:19:32.460 --> 00:19:38.039
我来的时候输入矩阵的总和

00:19:34.799 --> 00:19:39.299
最终从

00:19:38.039 --> 00:19:40.799
开始可能已被踢出

00:19:39.299 --> 00:19:42.570
现金，因为一级缓存和

00:19:40.799 --> 00:19:44.340
处理器真的很小，我们在说

00:19:42.570 --> 00:19:47.070
像200 KB的缓存

00:19:44.340 --> 00:19:49.470
也许没事，所以处理器

00:19:47.070 --> 00:19:51.870
就像一级缓存一样

00:19:49.470 --> 00:19:54.120
超级快，所以有这些

00:19:51.870 --> 00:19:55.799
高速缓存变得越来越大，是的

00:19:54.120 --> 00:19:56.940
直到你记住你的记忆

00:19:55.799 --> 00:20:00.059
记忆真的很慢

00:19:56.940 --> 00:20:02.490
就相对而言，是的，所以

00:20:00.059 --> 00:20:05.160
拼贴的作用是在岸边

00:20:02.490 --> 00:20:07.590
表示您花费的时间

00:20:05.160 --> 00:20:08.760
偏离您的初始值，您

00:20:07.590 --> 00:20:13.080
有更好的机会开始

00:20:08.760 --> 00:20:15.090
矩阵的价值仍然很好

00:20:13.080 --> 00:20:16.559
如此相乘

00:20:15.090 --> 00:20:18.420
这是一个感动的原因

00:20:16.559 --> 00:20:20.970
之所以会成功，是因为ER，因为

00:20:18.420 --> 00:20:22.980
第二排是从

00:20:20.970 --> 00:20:24.690
首先旋转我们读取每个值

00:20:22.980 --> 00:20:26.460
一次，我们写一次，为什么

00:20:24.690 --> 00:20:28.230
缓存使事情变得更好

00:20:26.460 --> 00:20:30.510
那大概就是我的问题

00:20:28.230 --> 00:20:31.530
在我的脑海中，所以有两种理论

00:20:30.510 --> 00:20:33.150
我也不知道

00:20:31.530 --> 00:20:34.590
其中之一实际上是

00:20:33.150 --> 00:20:35.370
真的，你是在告诉我你甚至没有

00:20:34.590 --> 00:20:38.130
知道

00:20:35.370 --> 00:20:40.470
好吧，我什至还和本尼迪克特（Benedict）交流了

00:20:38.130 --> 00:20:44.280
工程师和我有两种理论，但是

00:20:40.470 --> 00:20:46.170
真的很难测试，所以好的

00:20:44.280 --> 00:20:48.360
版本是很多处理

00:20:46.170 --> 00:20:50.990
艺术家真的很聪明

00:20:48.360 --> 00:20:54.000
接下来您要获取什么内存

00:20:50.990 --> 00:20:57.120
所以基本上可以看到孩子

00:20:54.000 --> 00:20:58.950
做出更好的预测哦卖给什么

00:20:57.120 --> 00:21:00.420
抓斗已经为您放入缓存

00:20:58.950 --> 00:21:03.150
即使您退出该代码

00:21:00.420 --> 00:21:05.040
然而，另一件事是因为

00:21:03.150 --> 00:21:08.460
缓存非常小，以至于

00:21:05.040 --> 00:21:11.790
可以缓存哪个单元格的特定模式

00:21:08.460 --> 00:21:13.320
在哪个缓存单元中，所以得到一个

00:21:11.790 --> 00:21:14.370
有点令人困惑，但基本上如果

00:21:13.320 --> 00:21:16.320
你想想如果你有

00:21:14.370 --> 00:21:18.210
像三个缓存单元一样，三个

00:21:16.320 --> 00:21:20.100
个体细胞什么是什么可以

00:21:18.210 --> 00:21:22.320
像一个值一样进入一个值

00:21:20.100 --> 00:21:24.570
好的，好的，你说好的，所以记忆

00:21:22.320 --> 00:21:27.000
地址0只能进入缓存单元零

00:21:24.570 --> 00:21:29.670
和虹膜1可以去抓钱

00:21:27.000 --> 00:21:31.590
两个可以放入缓存单元中的两个内存

00:21:29.670 --> 00:21:33.390
地址3只能进人ziering， 

00:21:31.590 --> 00:21:35.940
你环绕正确，所以你分配

00:21:33.390 --> 00:21:37.590
那些是，然后通过保留

00:21:35.940 --> 00:21:39.300
较小的你有更大的机会

00:21:37.590 --> 00:21:42.809
如果有的话，覆盖旧的veldt 

00:21:39.300 --> 00:21:45.570
放入您的1级缓存中

00:21:42.809 --> 00:21:48.660
基本上，这就是通过

00:21:45.570 --> 00:21:50.580
使您的访问内存更小的事物

00:21:48.660 --> 00:21:52.290
这样您就不会从中收回现金

00:21:50.580 --> 00:21:54.030
你那是什么东西

00:21:52.290 --> 00:21:57.120
基本上是有效的，因为我们的内心

00:21:54.030 --> 00:21:59.429
循环更小是的，它可以做得更好

00:21:57.120 --> 00:22:01.920
它使处理器变得更好

00:21:59.429 --> 00:22:04.230
预测，也使那些不

00:22:01.920 --> 00:22:08.510
驱逐缓存，因为我们工作的区域

00:22:04.230 --> 00:22:08.510
上的较小，因此只有磁贴大小

00:22:08.630 --> 00:22:13.830
是的，最重要的是什么

00:22:11.850 --> 00:22:16.210
我以为好，所以我做了一些

00:22:13.830 --> 00:22:18.340
 iMac上的MacBook上的基准测试

00:22:16.210 --> 00:22:21.399
和一个像素三，因为更大

00:22:18.340 --> 00:22:23.019
机器或更大的处理器

00:22:21.399 --> 00:22:24.399
级别越高，通常会缓存一个

00:22:23.019 --> 00:22:27.220
是对的

00:22:24.399 --> 00:22:30.879
所以我拥有的iMac就像18 

00:22:27.220 --> 00:22:33.340
核心大规模结构

00:22:30.879 --> 00:22:35.740
大规模l1而像素3明显

00:22:33.340 --> 00:22:37.419
具有非常非常小的1级缓存

00:22:35.740 --> 00:22:40.899
该代码仍然是单次调用

00:22:37.419 --> 00:22:43.210
是的，所以基本上是0 

00:22:40.899 --> 00:22:44.470
不需要平铺的相对时间，因此

00:22:43.210 --> 00:22:46.809
那是原始的

00:22:44.470 --> 00:22:49.509
基准时间不是，所以您可以

00:22:46.809 --> 00:22:51.820
看到这里是我们时移的方式

00:22:49.509 --> 00:22:54.159
相对拖曳基准时间

00:22:51.820 --> 00:22:57.249
瓷砖的尺寸是危险的，所以如果

00:22:54.159 --> 00:22:59.889
我的磁贴大小为2 a 2 x 2像素

00:22:57.249 --> 00:23:01.539
网格它使代码变慢，这是

00:22:59.889 --> 00:23:03.190
并不奇怪，因为你有

00:23:01.539 --> 00:23:06.399
抢劫发生的更多等等

00:23:03.190 --> 00:23:09.249
跳得好，它真的变得更快

00:23:06.399 --> 00:23:11.860
在这里的某些地方很快

00:23:09.249 --> 00:23:15.490
有点命中1级缓存边界

00:23:11.860 --> 00:23:17.019
然后又变慢了，我知道了

00:23:15.490 --> 00:23:19.149
老实说，有一件事很奇怪

00:23:17.019 --> 00:23:21.460
像素3即使在

00:23:19.149 --> 00:23:23.889
我不确定的大网格

00:23:21.460 --> 00:23:25.509
为什么我认为那实际上甚至快

00:23:23.889 --> 00:23:27.850
是的，这只是我期望的碎片

00:23:25.509 --> 00:23:30.059
就像在这里附近的某个地方

00:23:27.850 --> 00:23:32.350
假设1级缓存小于

00:23:30.059 --> 00:23:33.940
 Mac可能就是这样

00:23:32.350 --> 00:23:36.039
其他受影响我不太了解

00:23:33.940 --> 00:23:37.539
好的，但是我认为建筑是

00:23:36.039 --> 00:23:41.019
在那个处理器中很好，但似乎

00:23:37.539 --> 00:23:43.809
是我和16岁之间的最爱

00:23:41.019 --> 00:23:45.700
不知道64取决于你想要什么

00:23:43.809 --> 00:23:48.009
我真的觉得16看起来真的

00:23:45.700 --> 00:23:50.590
在这张图中很有希望，这意味着你

00:23:48.009 --> 00:23:52.240
喜欢它的256像素砂砾

00:23:50.590 --> 00:23:54.730
和我一起工作我以为我会来

00:23:52.240 --> 00:23:56.740
进入这一集，我要去

00:23:54.730 --> 00:24:00.580
理解为什么平铺有效

00:23:56.740 --> 00:24:02.499
不，只是它，它是因为我

00:24:00.580 --> 00:24:04.059
在这个右边度过了最后一个星期

00:24:02.499 --> 00:24:05.889
你一直坐在对面

00:24:04.059 --> 00:24:07.509
月亮听我和人聊天， 

00:24:05.889 --> 00:24:09.519
试图找出这个是

00:24:07.509 --> 00:24:11.649
关闭我已经了解了

00:24:09.519 --> 00:24:14.110
之间存在这种相互作用

00:24:11.649 --> 00:24:16.389
这个过程正在预测什么价值

00:24:14.110 --> 00:24:17.740
在缓存中，然后不强制

00:24:16.389 --> 00:24:20.169
缓存的积极驱逐是因为

00:24:17.740 --> 00:24:22.240
你读得太远了，但这是一个

00:24:20.169 --> 00:24:24.159
工具的大量案例不正确

00:24:22.240 --> 00:24:26.649
就像不要走开并重写所有内容

00:24:24.159 --> 00:24:27.850
您的标题平铺的代码不

00:24:26.649 --> 00:24:29.800
伙计们，你将不得不非常

00:24:27.850 --> 00:24:31.690
仔细剖析

00:24:29.800 --> 00:24:33.490
如此广泛的机器

00:24:31.690 --> 00:24:35.770
看到的处理器架构是这个

00:24:33.490 --> 00:24:37.450
其实当我们穿越时我发现了什么

00:24:35.770 --> 00:24:40.180
因为我们开始旋转

00:24:37.450 --> 00:24:42.430
描绘一个非常高级的用例，我们

00:24:40.180 --> 00:24:44.290
跌倒了，最终像我们这样

00:24:42.430 --> 00:24:47.710
谈论处理器架构和

00:24:44.290 --> 00:24:49.810
 1级缓存是，所以多亏了黑客

00:24:47.710 --> 00:24:51.610
我猜新闻毁了我的一周，但

00:24:49.810 --> 00:24:52.540
实际上这一直非常有教育意义

00:24:51.610 --> 00:24:54.520
即使我还没有完全

00:24:52.540 --> 00:24:56.290
了解它，但我感觉就像嘿男人

00:24:54.520 --> 00:24:58.480
是的，我觉得我的理解力

00:24:56.290 --> 00:25:00.010
低级的东西就像我说的

00:24:58.480 --> 00:25:01.570
有那种困惑的元素，但我

00:25:00.010 --> 00:25:04.450
觉得我很感激

00:25:01.570 --> 00:25:07.540
像聪明人，对，我去

00:25:04.450 --> 00:25:09.940
这是令人难以置信的

00:25:07.540 --> 00:25:13.800
让我们喘口气我知道

00:25:09.940 --> 00:25:16.060
下次您会看到我们的Rikuo观众

00:25:13.800 --> 00:25:20.740
但这是描述中的事情吗

00:25:16.060 --> 00:25:24.490
是的，这是对的，是的

00:25:20.740 --> 00:25:25.090
哦，那是一件事，让我们

00:25:24.490 --> 00:25:32.080
写下来

00:25:25.090 --> 00:25:36.420
嗯，我该如何解决这个问题哦，编辑

00:25:32.080 --> 00:25:36.420
哦，好吧，是的

