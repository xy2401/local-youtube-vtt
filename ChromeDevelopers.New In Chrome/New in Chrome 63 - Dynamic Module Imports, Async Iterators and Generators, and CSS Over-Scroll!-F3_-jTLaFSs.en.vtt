WEBVTT
Kind: captions
Language: en

00:00:00.590 --> 00:00:02.780
PETE LEPAGE: Chrome 63
allows you to import

00:00:02.780 --> 00:00:04.970
JavaScript modules dynamically.

00:00:04.970 --> 00:00:07.130
My favorite interview
coding question

00:00:07.130 --> 00:00:10.850
becomes a piece of cake with
async iterators and generators.

00:00:10.850 --> 00:00:14.180
And you can override the
browser's default overflow

00:00:14.180 --> 00:00:17.820
scroll behavior with the
CSS overflow scroll behavior

00:00:17.820 --> 00:00:18.320
property.

00:00:18.320 --> 00:00:19.670
I'm Pete LePage.

00:00:19.670 --> 00:00:22.490
Let's dive in and see what's
new for developers in Chrome 63.

00:00:22.490 --> 00:00:25.210
[MUSIC PLAYING]

00:00:25.210 --> 00:00:27.700
Importing JavaScript
modules is super handy.

00:00:27.700 --> 00:00:28.960
But it's static.

00:00:28.960 --> 00:00:32.290
You can't import a module
based on runtime conditions.

00:00:32.290 --> 00:00:34.810
Thankfully, that
changes in Chrome 63

00:00:34.810 --> 00:00:37.270
with a new dynamic
import syntax.

00:00:37.270 --> 00:00:40.180
It allows you to dynamically
load code into modules

00:00:40.180 --> 00:00:42.250
and scripts at runtime.

00:00:42.250 --> 00:00:44.650
It can be used to lazy
load a script only

00:00:44.650 --> 00:00:46.780
when it's needed,
improving the performance

00:00:46.780 --> 00:00:48.310
of your applications.

00:00:48.310 --> 00:00:51.070
Instead of loading your whole
application when the user first

00:00:51.070 --> 00:00:53.770
hits your page, you can
grab only the resources

00:00:53.770 --> 00:00:55.660
you need for them to sign in.

00:00:55.660 --> 00:00:58.930
Your initial load is
small and screaming fast.

00:00:58.930 --> 00:01:01.480
Then, once the user
signs in, load the rest.

00:01:01.480 --> 00:01:03.220
And you're good to go.

00:01:03.220 --> 00:01:06.250
Writing code that does
any sort of iteration

00:01:06.250 --> 00:01:08.590
with async functions
can be ugly.

00:01:08.590 --> 00:01:11.890
In fact, it's the core part of
my favorite interview coding

00:01:11.890 --> 00:01:12.970
question.

00:01:12.970 --> 00:01:15.430
Now with async
generator functions

00:01:15.430 --> 00:01:17.560
and the async
iteration protocol,

00:01:17.560 --> 00:01:20.770
consumption or implementation
of streaming data sources

00:01:20.770 --> 00:01:22.000
become streamlined.

00:01:22.000 --> 00:01:25.300
And my coding question
becomes much easier.

00:01:25.300 --> 00:01:28.480
Async iterators can be
used in for-of loops

00:01:28.480 --> 00:01:31.420
to create your own
custom async iterators

00:01:31.420 --> 00:01:34.300
through async
iterator factories.

00:01:34.300 --> 00:01:37.090
Scrolling is one of the
most fundamental ways

00:01:37.090 --> 00:01:38.560
to interact with a page.

00:01:38.560 --> 00:01:41.360
But certain patterns can
be tricky to deal with--

00:01:41.360 --> 00:01:43.980
for example, the browser's
pull-to-refresh feature,

00:01:43.980 --> 00:01:48.430
where swiping down at the top of
the page causes a hard reload.

00:01:48.430 --> 00:01:51.490
In some cases, you might want
to override that behavior

00:01:51.490 --> 00:01:53.500
and provide your own experience.

00:01:53.500 --> 00:01:55.780
That's what Twitter's
Progressive Web App does.

00:01:55.780 --> 00:01:59.050
When you pull down, instead
of reloading the whole page,

00:01:59.050 --> 00:02:01.990
it adds any new tweets
to the current view.

00:02:01.990 --> 00:02:06.710
Chrome 63 now supports the CSS
over-scroll behavior property,

00:02:06.710 --> 00:02:10.449
making it easy to override
the browser's default overflow

00:02:10.449 --> 00:02:11.860
scroll behavior.

00:02:11.860 --> 00:02:14.080
You can use it to
cancel scroll training,

00:02:14.080 --> 00:02:17.570
disable or customize the
pull-to-refresh action,

00:02:17.570 --> 00:02:20.390
disable rubber banding
effects on iOS,

00:02:20.390 --> 00:02:22.840
add swipe navigations, and more.

00:02:22.840 --> 00:02:25.270
The best part--
over-scroll behavior

00:02:25.270 --> 00:02:29.380
doesn't have a negative effect
on your page performance.

00:02:29.380 --> 00:02:31.930
I love web push notifications.

00:02:31.930 --> 00:02:34.240
But I've been really
frustrated by the number

00:02:34.240 --> 00:02:36.910
of sites asking for
permission on page load

00:02:36.910 --> 00:02:38.200
without any context.

00:02:38.200 --> 00:02:39.940
And I'm not alone.

00:02:39.940 --> 00:02:42.460
90% of all permission
requests are

00:02:42.460 --> 00:02:45.360
ignored or temporarily blocked.

00:02:45.360 --> 00:02:48.220
In Chrome 59, we
started to address this

00:02:48.220 --> 00:02:50.690
by temporarily
blocking a permission

00:02:50.690 --> 00:02:54.250
if the user dismissed
the request three times.

00:02:54.250 --> 00:02:58.810
Now in M63, Chrome for Android
will make permission requests

00:02:58.810 --> 00:03:00.430
modal dialogs.

00:03:00.430 --> 00:03:03.500
Now, remember, this isn't
just for push notifications.

00:03:03.500 --> 00:03:06.290
This is for all
permission requests.

00:03:06.290 --> 00:03:08.830
If you ask for permission
at the appropriate time

00:03:08.830 --> 00:03:12.280
and in context, we found that
users are 2 and 1/2 times

00:03:12.280 --> 00:03:15.370
more likely to grant permission.

00:03:15.370 --> 00:03:17.800
These are just a few of
the changes in Chrome 63

00:03:17.800 --> 00:03:18.710
for developers.

00:03:18.710 --> 00:03:20.680
Of course, there's plenty more.

00:03:20.680 --> 00:03:24.100
The finally method is now
available on promise instances

00:03:24.100 --> 00:03:28.600
and is invoked after a promise
has been fulfilled or rejected.

00:03:28.600 --> 00:03:31.390
The new device
memory JavaScript API

00:03:31.390 --> 00:03:33.880
helps you understand
performance constraints

00:03:33.880 --> 00:03:36.640
by giving you hints about
the total amount of RAM

00:03:36.640 --> 00:03:38.110
on a user's device.

00:03:38.110 --> 00:03:42.010
You can tailor your experience
at runtime, reducing complexity

00:03:42.010 --> 00:03:44.380
on lower end devices,
providing users

00:03:44.380 --> 00:03:47.920
with a better experience
and fewer frustrations.

00:03:47.920 --> 00:03:50.530
The Intl, dot,
PluralRules API allows

00:03:50.530 --> 00:03:54.160
you to build applications
that understand pluralization

00:03:54.160 --> 00:03:56.380
of a given language
by indicating

00:03:56.380 --> 00:04:00.220
which plural forms for a
given number and language--

00:04:00.220 --> 00:04:02.980
and that can help
with ordinal numbers.

00:04:02.980 --> 00:04:06.220
All the details, including
links to the docs and specs,

00:04:06.220 --> 00:04:07.840
are in the description below.

00:04:07.840 --> 00:04:10.120
And be sure to check out
the latest "New in Chrome"

00:04:10.120 --> 00:04:12.880
DevTools video to learn
what's new in DevTools.

00:04:12.880 --> 00:04:14.920
Then click the Subscribe button.

00:04:14.920 --> 00:04:16.450
And you'll get an
email notification

00:04:16.450 --> 00:04:18.110
whenever we launch a new video.

00:04:18.110 --> 00:04:19.240
I'm Pete LePage.

00:04:19.240 --> 00:04:21.279
And as soon as Chrome
64 is released,

00:04:21.279 --> 00:04:23.710
I'll be right here to tell
you what's new in Chrome.

00:04:23.710 --> 00:04:26.460
[MUSIC PLAYING]

