WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.185 --> 00:00:05.920
嗨，Polycast用户。 

00:00:05.920 --> 00:00:07.000
我是罗布

00:00:07.000 --> 00:00:09.775
今天我要向您坦白。 

00:00:09.775 --> 00:00:11.400
我正在使用数据链接系统

00:00:11.400 --> 00:00:14.040
在《聚合物》杂志上将近两年， 

00:00:14.040 --> 00:00:18.110
但是直到最近我才知道它是如何工作的。 

00:00:18.110 --> 00:00:20.080
我当然可以使用链接结构

00:00:20.080 --> 00:00:23.160
在我的应用程序内传递数据

00:00:23.160 --> 00:00:26.410
但是由于我对执行机制缺乏了解

00:00:26.410 --> 00:00:28.800
对我来说似乎有点神秘。 

00:00:28.800 --> 00:00:31.110
这最终使纠正错误变得困难

00:00:31.110 --> 00:00:32.710
应用程序。 

00:00:32.710 --> 00:00:35.020
所以我想拍这一系列的视频

00:00:35.020 --> 00:00:37.100
这样您就可以了解绑定的工作方式

00:00:37.100 --> 00:00:39.290
在您的应用程序内部。 

00:00:39.290 --> 00:00:41.190
要掌握这一点，我们必须开始

00:00:41.190 --> 00:00:45.000
了解有关链接的注释。 

00:00:45.000 --> 00:00:48.160
它们被定义为您在HTML中键入的小图标

00:00:48.160 --> 00:00:51.620
告诉Polymer您要在此站点上创建链接。 

00:00:51.620 --> 00:00:55.140
和单向注释

00:00:55.140 --> 00:00:58.910
用方括号标记，您可以流式传输来自主机元素的数据

00:00:58.910 --> 00:01:02.096
到目标，但没有从该目标返回到主机。 

00:01:02.096 --> 00:01:03.470
为了做这样的事情， 

00:01:03.470 --> 00:01:05.770
您需要使用双向注释

00:01:05.770 --> 00:01:08.440
或有时称为自动注释。 

00:01:08.440 --> 00:01:10.280
有了它，您可以托管和定位

00:01:10.280 --> 00:01:12.335
来回滚动数据。 

00:01:12.335 --> 00:01:14.460
我现在将在稍后详细解释

00:01:14.460 --> 00:01:16.850
但是首先我要引导

00:01:16.850 --> 00:01:19.970
关于我的应用程序内部已经发生的事情

00:01:19.970 --> 00:01:23.310
当Polymer找到注释时。 

00:01:23.310 --> 00:01:26.031
最初，当Polymer找到您的商品时

00:01:26.031 --> 00:01:28.280
当您尝试记录时，它将进行分析

00:01:28.280 --> 00:01:30.540
元素模板

00:01:30.540 --> 00:01:34.230
他将寻找带注释的这些节点

00:01:34.230 --> 00:01:35.710
用于绑定。 

00:01:35.710 --> 00:01:38.270
当他找到链接的这些注释时， 

00:01:38.270 --> 00:01:42.890
会产生所谓的属性效果。 

00:01:42.890 --> 00:01:45.170
该属性的影响很小

00:01:45.170 --> 00:01:49.070
已知DOM中的节点类型已更新

00:01:49.070 --> 00:01:51.490
每当此属性更改时。 

00:01:51.490 --> 00:01:53.090
因此，在此示例中，创建了聚合物

00:01:53.090 --> 00:01:56.200
 div属性的效果直接在这里

00:01:56.200 --> 00:01:59.670
而此纸张输入元素的另一个属性效果。 

00:01:59.670 --> 00:02:01.880
因此，我们将产生两种效果。 

00:02:01.880 --> 00:02:06.390
所有属性效果对象都存储在数组中。 

00:02:06.390 --> 00:02:09.250
我现在想考虑一下这一系列的属性效果

00:02:09.250 --> 00:02:11.770
就像动作清单一样

00:02:11.770 --> 00:02:15.220
必须在属性更新时执行。 

00:02:15.220 --> 00:02:20.090
如果需要，可以实际查看此实际数组。 

00:02:20.090 --> 00:02:24.165
您可以转到开发人员工具，看到的是您创建的项目。 

00:02:24.165 --> 00:02:26.540
您可以使用我之前向您展示的小技巧， 

00:02:26.540 --> 00:02:30.450
您可以在“项目”面板中选择项目

00:02:30.450 --> 00:02:36.000
然后输入“ $ 0”，然后输入“ ._propertyeffects” 

00:02:36.000 --> 00:02:37.584
这是聚合物中的一个特殊部分

00:02:37.584 --> 00:02:40.420
禁止篡改它，但我们可以对其进行检查。 

00:02:40.420 --> 00:02:41.750
很好玩

00:02:41.750 --> 00:02:45.050
您将看到此对象与此数组。 

00:02:45.050 --> 00:02:47.760
您可以在此处看到两个对象。 

00:02:47.760 --> 00:02:49.220
我们创建的两个效果

00:02:49.220 --> 00:02:52.320
关于财产本身的影响的信息很少。 

00:02:52.320 --> 00:02:54.720
这是文本属性效果。 

00:02:54.720 --> 00:02:58.500
设置为使用包围模式

00:02:58.500 --> 00:03:01.685
我认为这是一种双向连接。 

00:03:01.685 --> 00:03:03.810
所以进入这里很有趣

00:03:03.810 --> 00:03:07.350
您可以检查一下此清单。 

00:03:07.350 --> 00:03:09.180
回到我们的例子，我现在将

00:03:09.180 --> 00:03:10.630
为了简化一点

00:03:10.630 --> 00:03:12.000
直到我们检查较少的编码。 

00:03:12.000 --> 00:03:14.610
这是我们的模板，这是元素的定义

00:03:14.610 --> 00:03:15.592
聚合物。 

00:03:15.592 --> 00:03:17.050
 Polymer会做的另一件事

00:03:17.050 --> 00:03:19.890
创建效果属性旁边

00:03:19.890 --> 00:03:24.330
是为属性创建一个setter函数

00:03:24.330 --> 00:03:27.090
我们在这里拥有任何foo属性。 

00:03:27.090 --> 00:03:30.340
如您所见，我们在此处删除了set foo setter 

00:03:30.340 --> 00:03:32.610
如果您不习惯这样的结构

00:03:32.610 --> 00:03:35.940
我将链接到MDN上的一个小文档

00:03:35.940 --> 00:03:38.340
它讨论了JavaScript setter的功能。 

00:03:38.340 --> 00:03:41.310
我必须强调，这不是实际的结构

00:03:41.310 --> 00:03:42.410
由聚合物使用； 

00:03:42.410 --> 00:03:45.610
运行时几乎没有差异

00:03:45.610 --> 00:03:49.310
但是创建效果后会发生什么

00:03:49.310 --> 00:03:51.350
对于财产，它还会创建

00:03:51.350 --> 00:03:53.670
该属性的Setter函数。 

00:03:53.670 --> 00:03:56.780
在此setter函数中， 

00:03:56.780 --> 00:03:59.390
一些有趣的事情发生了。 

00:03:59.390 --> 00:04:01.700
首先是，只要属性发生变化， 

00:04:01.700 --> 00:04:06.540
 Polymer进行所谓的检查更改。 

00:04:06.540 --> 00:04:10.170
比较旧值时会检查更改

00:04:10.170 --> 00:04:13.280
新值，看看是否已经有更改。 

00:04:13.280 --> 00:04:15.090
聚合物已经在做什么

00:04:15.090 --> 00:04:20.300
此foo属性存储在一个出色的私有变量中

00:04:20.300 --> 00:04:23.837
被称为“ _ _ data_ _”。 

00:04:23.837 --> 00:04:27.420
您也可以在开发人员工具中进行搜索和查看。 

00:04:27.420 --> 00:04:30.280
原始值存储在此处

00:04:30.280 --> 00:04:33.140
当有人改变财产时， 

00:04:33.140 --> 00:04:35.180
即通过更改foo的属性

00:04:35.180 --> 00:04:37.414
例如，JavaScript或通过更改属性

00:04:37.414 --> 00:04:38.830
或类似，将首先检查

00:04:38.830 --> 00:04:41.600
在旧的和新的价值观中

00:04:41.600 --> 00:04:42.360
不一样

00:04:42.360 --> 00:04:43.910
因为如果两个值没有不同， 

00:04:43.910 --> 00:04:45.900
努力是没有意义的。 

00:04:45.900 --> 00:04:48.920
使用检查更改检测到差异时

00:04:48.920 --> 00:04:52.309
我们将保持这一新价值。 

00:04:52.309 --> 00:04:54.100
接下来的事情

00:04:54.100 --> 00:04:57.180
是我们重复属性的所有作用吗

00:04:57.180 --> 00:04:59.610
并赋予它新的价值

00:04:59.610 --> 00:05:03.780
然后，我们邀请他们更新DOM中的这些节点。 

00:05:03.780 --> 00:05:07.250
因此，这大概是一个属性选择清单

00:05:07.250 --> 00:05:09.180
这也是假设所有代码

00:05:09.180 --> 00:05:10.596
但这是他们的外表， 

00:05:10.596 --> 00:05:13.120
有人介绍了新的价值， 

00:05:13.120 --> 00:05:15.770
但是我们发现它与新价值不同。 

00:05:15.770 --> 00:05:17.490
所以我们保留它。 

00:05:17.490 --> 00:05:20.100
现在让我们检查选择列表

00:05:20.100 --> 00:05:23.720
这些属性并分配该新值

00:05:23.720 --> 00:05:25.820
在这里。 

00:05:25.820 --> 00:05:27.580
做完了

00:05:27.580 --> 00:05:30.470
现在让我们设置新值

00:05:30.470 --> 00:05:34.630
在输入元素中，依此类推。 

00:05:34.630 --> 00:05:38.200
如果这些要素

00:05:38.200 --> 00:05:41.120
它具有属性效果，因此您可以开始工作。 

00:05:41.120 --> 00:05:44.460
这就是数据传递的方式

00:05:44.460 --> 00:05:46.864
它遍历所有各种依赖元素的整个过程。 

00:05:46.864 --> 00:05:49.280
我确定您现在已经看过了，您会问： 

00:05:49.280 --> 00:05:51.290
那属性对象呢？ 

00:05:51.290 --> 00:05:55.320
因为我知道这是其中的一部分，对吗？ 

00:05:55.320 --> 00:05:57.370
但是，这和它有什么关系呢？ 

00:05:57.370 --> 00:05:59.470
好吧，属性对象基本上允许

00:05:59.470 --> 00:06:03.260
您添加我认为是某种元数据的内容

00:06:03.260 --> 00:06:06.110
在需要时为您的财产设置功能。 

00:06:06.110 --> 00:06:09.170
再回到我们的例子，我有这个属性对象

00:06:09.170 --> 00:06:12.300
还有foo属性。 

00:06:12.300 --> 00:06:13.730
设定器功能已经设定。 

00:06:13.730 --> 00:06:16.740
因此，将首先检查新的价值变化， 

00:06:16.740 --> 00:06:18.470
并打开属性效果

00:06:18.470 --> 00:06:20.080
如果值不同。 

00:06:20.080 --> 00:06:22.600
让我在我的属性对象中

00:06:22.600 --> 00:06:24.639
添加了观察者功能。 

00:06:24.639 --> 00:06:26.180
然后我选择确定，当foo更改时， 

00:06:26.180 --> 00:06:29.630
我希望您在此处运行观察器功能。 

00:06:29.630 --> 00:06:31.850
在setter函数中发生了什么

00:06:31.850 --> 00:06:35.590
聚合物调用该函数。 

00:06:35.590 --> 00:06:36.969
我知道似乎还有更多歧义

00:06:36.969 --> 00:06:39.510
在此过程中，事实就是如此。 

00:06:39.510 --> 00:06:41.718
完成后会调用该函数

00:06:41.718 --> 00:06:43.900
比任何其他业务。 

00:06:43.900 --> 00:06:47.940
如果您在旁边添加true标签以进行通知

00:06:47.940 --> 00:06:51.440
在整个Polymer系统中启用了双向连接， 

00:06:51.440 --> 00:06:55.120
所以实际发生的是称之为this.fire 

00:06:55.120 --> 00:06:58.580
那发送一个事件叫做

00:06:58.580 --> 00:07:03.110
 “ foo-changed”并传递值， 

00:07:03.110 --> 00:07:04.700
我的意思是全新的价值。 

00:07:04.700 --> 00:07:07.280
因此，无论何时使用属性进行此操作， 

00:07:07.280 --> 00:07:10.180
 Polymer将始终创建此事件提交活动。 

00:07:10.180 --> 00:07:13.720
事件名称始终由事物组成，然后“更改”。 

00:07:13.720 --> 00:07:16.800
无论属性名称是什么，都添加“ -changed”。 

00:07:16.800 --> 00:07:18.520
这真的很有趣

00:07:18.520 --> 00:07:22.760
因为这意味着如果您要链接到某个项目， 

00:07:22.760 --> 00:07:27.200
链接纸张输入值属性

00:07:27.200 --> 00:07:29.670
所以聚合物在启动时会说

00:07:29.670 --> 00:07:32.460
好吧，我在这里找到了注释。 

00:07:32.460 --> 00:07:34.760
让我创建一个属性效果， 

00:07:34.760 --> 00:07:38.154
我们是否有其他功能的链接？ 

00:07:38.154 --> 00:07:38.820
是的

00:07:38.820 --> 00:07:41.380
我可以看到我们有一个指向该值的链接。 

00:07:41.380 --> 00:07:48.130
因此，当这触发一个称为“值更改”的事件时

00:07:48.130 --> 00:07:51.450
该事件的标志将邀请我更新

00:07:51.450 --> 00:07:53.016
该属性就在这里。 

00:07:53.016 --> 00:07:55.140
这就是属性之间真正发生的全部

00:07:55.140 --> 00:07:56.280
以及任何连接系统。 

00:07:56.280 --> 00:07:58.860
您的物品触发了变化的事件

00:07:58.860 --> 00:08:01.180
另一个关联的项目监听

00:08:01.180 --> 00:08:04.280
然后，此变量更新其属性

00:08:04.280 --> 00:08:05.890
因此。 

00:08:05.890 --> 00:08:07.740
这里我们有双向连接

00:08:07.740 --> 00:08:09.950
您已经可以看到您刚才解释的系统

00:08:09.950 --> 00:08:11.010
可以用

00:08:11.010 --> 00:08:12.510
我要搬到这里

00:08:12.510 --> 00:08:14.130
这是我们元素的代表。 

00:08:14.130 --> 00:08:17.340
我可以在纸张输入栏中输入

00:08:17.340 --> 00:08:19.630
这些事件改变了

00:08:19.630 --> 00:08:23.049
这意味着我的foo更新

00:08:23.049 --> 00:08:25.340
因为它将移动并通过所有效果

00:08:25.340 --> 00:08:28.150
我的属性，也在这里更新foo。 

00:08:28.150 --> 00:08:29.270
您可以在这里看到它。 

00:08:29.270 --> 00:08:31.000
最后，它们是匹配的。 

00:08:31.000 --> 00:08:33.780
但是，如果我使用单向连接怎么办？ 

00:08:33.780 --> 00:08:35.580
在这里我用方括号

00:08:35.580 --> 00:08:37.120
而不是花括号。 

00:08:37.120 --> 00:08:40.870
这告诉Polymer不要成为听众

00:08:40.870 --> 00:08:42.390
变量值事件。 

00:08:42.390 --> 00:08:43.980
而这一切都是真的。 

00:08:43.980 --> 00:08:46.590
我现在将移至此处并在此输入字段中输入

00:08:46.590 --> 00:08:49.320
由于我不向这些事件分发消息， 

00:08:49.320 --> 00:08:52.110
我什么也收不到，财产留在这里

00:08:52.110 --> 00:08:53.770
一如既往。 

00:08:53.770 --> 00:08:56.924
我们不会在其中包含任何新数据。 

00:08:56.924 --> 00:08:59.590
我最后要谈的是只读属性。 

00:08:59.590 --> 00:09:02.540
您可以设置一个只读标志

00:09:02.540 --> 00:09:05.710
这意味着没有外部用户可以拥有您的商品

00:09:05.710 --> 00:09:08.560
以任何方式插入数据。 

00:09:08.560 --> 00:09:11.010
所以这里发生的是聚合物不会产生

00:09:11.010 --> 00:09:12.530
二传手功能，对吗？ 

00:09:12.530 --> 00:09:14.240
根本不会创建通用设置器功能

00:09:14.240 --> 00:09:16.720
因为我们不希望别人意外召回。 

00:09:16.720 --> 00:09:19.800
相反，因为它仍然需要

00:09:19.800 --> 00:09:23.020
在内部使用该数据，它会创建一个小的私有设置器函数

00:09:23.020 --> 00:09:25.340
其名称以前缀“ _”开头。 

00:09:25.340 --> 00:09:27.000
这些实际上可以使用。 

00:09:27.000 --> 00:09:29.640
这是他使用的实际结构。 

00:09:29.640 --> 00:09:32.080
因此，如果您需要使用“只读” 

00:09:32.080 --> 00:09:35.570
您可以在商品中使用此特殊的设置器功能

00:09:35.570 --> 00:09:38.840
要执行更新，这是作用机制。 

00:09:38.840 --> 00:09:41.420
好了，现在您知道了数据绑定的基础。 

00:09:41.420 --> 00:09:43.280
但是还有很多奇妙的事情

00:09:43.280 --> 00:09:46.540
例如连接两个数组和深层嵌套的对象

00:09:46.540 --> 00:09:49.840
以及计算机属性和更改日志

00:09:49.840 --> 00:09:52.800
和注意，无论如何

00:09:52.800 --> 00:09:54.680
我将其推迟另一集。 

00:09:54.680 --> 00:09:57.672
如果您喜欢视频，别忘了下来

00:09:57.672 --> 00:10:00.130
然后点击“订阅”按钮，因为实际上

00:10:00.130 --> 00:10:02.080
是什么使我们步入正轨。 

00:10:02.080 --> 00:10:03.790
如果您有问题要问我， 

00:10:03.790 --> 00:10:05.780
写在评论中或询问我

00:10:05.780 --> 00:10:09.570
在使用主题标签“ #askPolymer”的社交网络上。 

00:10:09.570 --> 00:10:11.900
和往常一样，感谢您的收看。 

00:10:11.900 --> 00:10:12.900
待会见。 

