WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.000 --> 00:00:09.296
 [音乐] 

00:00:09.296 --> 00:00:11.420
阿德：服务人员很强

00:00:11.420 --> 00:00:13.100
在离线缓存中， 

00:00:13.100 --> 00:00:16.750
但这也很能为您带来即时上传性能的好处

00:00:16.750 --> 00:00:18.474
当涉及到频繁访问时。 

00:00:18.474 --> 00:00:19.200
马特：是的。 

00:00:19.200 --> 00:00:19.961
艾迪：对吗？ 

00:00:19.961 --> 00:00:23.700
您可以通过使用应用程序结构的几何结构来实现。 

00:00:23.702 --> 00:00:24.970
马特：是的。 

00:00:24.970 --> 00:00:28.170
这种想法-即作为内容分离

00:00:28.170 --> 00:00:29.835
实际的视觉用户界面。 

00:00:29.835 --> 00:00:31.580
在我看来，就像在应用程序中一样， 

00:00:31.580 --> 00:00:32.600
您总是有徽标。 

00:00:32.600 --> 00:00:34.164
您的侧面有导航路由器， 

00:00:34.164 --> 00:00:35.750
首先有一些小碎片。 

00:00:35.750 --> 00:00:38.050
在几乎90％的应用中都是如此。 

00:00:38.050 --> 00:00:39.390
你总是在那里想要它。 

00:00:39.390 --> 00:00:40.720
阿迪：当我们谈论圣殿时， 

00:00:40.720 --> 00:00:42.470
我们正在谈论HTML和CSS 

00:00:42.470 --> 00:00:45.170
代表UI核心的Java文件， 

00:00:45.170 --> 00:00:47.420
事情，如果您将其存储，则可以继续

00:00:47.420 --> 00:00:50.060
在中间上传内容

00:00:50.060 --> 00:00:52.740
并保存自己不断重载，对吗？ 

00:00:52.740 --> 00:00:54.660
马特：是的，这很好

00:00:54.660 --> 00:00:56.780
访问以前没有访问过的页面。 

00:00:56.780 --> 00:00:58.870
如果您知道用户界面将一直存在， 

00:00:58.870 --> 00:01:00.683
您可以在继续时下载此文件

00:01:00.683 --> 00:01:02.060
在后台上传内容。 

00:01:02.060 --> 00:01:03.518
艾迪：他只是确保

00:01:03.518 --> 00:01:06.180
您的用户将获得非常好的性能。 

00:01:06.180 --> 00:01:09.210
第一次上传时

00:01:09.210 --> 00:01:11.480
您形成结构本身。 

00:01:11.480 --> 00:01:13.280
您将其存储在服务代理中。 

00:01:13.280 --> 00:01:14.821
可能会显示标签，正在熨烫

00:01:14.821 --> 00:01:18.100
告诉他们在哪里，此应用现在无需网络连接即可运行。 

00:01:18.100 --> 00:01:20.600
那意味着当他们回来时- 

00:01:20.600 --> 00:01:22.860
假设他们处于飞行模式。 

00:01:22.860 --> 00:01:25.102
机箱将非常非常快地加载。 

00:01:25.102 --> 00:01:26.560
然后，您可以使用网络

00:01:26.560 --> 00:01:28.220
下载其余内容。 

00:01:28.220 --> 00:01:31.900
然后，您可以存储内容，场景变满

00:01:31.900 --> 00:01:33.938
每当他们尝试访问时可用

00:01:33.938 --> 00:01:35.146
没有网络连接。 

00:01:35.146 --> 00:01:36.229
马特：是的。 

00:01:36.229 --> 00:01:37.530
我击中了目标。 

00:01:37.530 --> 00:01:39.290
艾迪：我们进行了一些性能测试

00:01:39.290 --> 00:01:42.470
我们在应用程序结构模型中所做的。 

00:01:42.470 --> 00:01:43.850
其中使用WebPagetest。 

00:01:43.850 --> 00:01:48.550
第一次访问时，我们的时间相对较快

00:01:48.550 --> 00:01:49.974
到初始的表达图。 

00:01:49.974 --> 00:01:51.640
马特：这很重要， 

00:01:51.640 --> 00:01:54.731
因为我认为在某种情况下，一个人可能

00:01:54.731 --> 00:01:56.710
利用服务因素，就好像说

00:01:56.710 --> 00:01:58.000
不用担心第一次上传。 

00:01:58.000 --> 00:02:00.560
好吧，我要讲的是兆字节的东西

00:02:00.560 --> 00:02:01.656
那我要储存。 

00:02:01.656 --> 00:02:03.030
在那之后，它将变得非常快。 

00:02:03.030 --> 00:02:05.830
但是第一次下载，如果花了这么长时间

00:02:05.830 --> 00:02:08.530
服务人员甚至没有注册， 

00:02:08.530 --> 00:02:09.810
没有意义。 

00:02:09.810 --> 00:02:11.320
此外，对于某些浏览器

00:02:11.320 --> 00:02:12.750
那不支持服务人员， 

00:02:12.750 --> 00:02:14.570
您在那种情况下伤害自己。 

00:02:14.570 --> 00:02:16.660
艾迪：这会让您的用户在角落哭。 

00:02:16.660 --> 00:02:17.540
而且你不想要那样。 

00:02:17.540 --> 00:02:18.760
马特：您可能想服务

00:02:18.760 --> 00:02:21.410
您的网站的统计配置，以便保存

00:02:21.410 --> 00:02:24.530
尽快人类，然后逐渐

00:02:24.530 --> 00:02:27.150
激励服务人员使用应用程序结构模型。 

00:02:27.150 --> 00:02:29.020
阿德：如果您使用应用程序结构模型， 

00:02:29.020 --> 00:02:31.540
如您所见，我们做得很好-实际上， 

00:02:31.540 --> 00:02:36.310
减少重复访问时第一个表达图形的加载时间。 

00:02:36.330 --> 00:02:39.560
说到效果

00:02:39.560 --> 00:02:42.120
在其上形成服务方， 

00:02:42.120 --> 00:02:45.037
您不必使用服务代理

00:02:45.037 --> 00:02:46.120
获得丰厚的收益。 

00:02:46.120 --> 00:02:48.602
如果您正在设计应用程序结构模型， 

00:02:48.602 --> 00:02:50.060
您想象中的服务形成方面， 

00:02:50.060 --> 00:02:54.170
即使在Safari上，您也将获得非常好的初始草图

00:02:54.170 --> 00:02:56.287
并在iOS上的Safari移动浏览器上。 

00:02:56.287 --> 00:02:58.370
马特：是的，在所有浏览器上

00:02:58.370 --> 00:02:59.480
那没有服务人员。 

00:02:59.480 --> 00:03:00.440
艾迪：是的。 

00:03:00.440 --> 00:03:01.910
现在，如果您想知道，好吧， 

00:03:01.910 --> 00:03:03.634
我是否必须使用应用程序结构模型

00:03:03.634 --> 00:03:05.809
在我所有的应用中

00:03:05.809 --> 00:03:08.100
有一些类型的应用程序-非常简单， 

00:03:08.100 --> 00:03:10.176
它可能被夸大了。 

00:03:10.176 --> 00:03:11.800
但是，如果您正在设计某些东西

00:03:11.800 --> 00:03:14.440
有点复杂，有点有效， 

00:03:14.440 --> 00:03:17.106
这种模型非常合乎逻辑。 

00:03:17.106 --> 00:03:19.839
在Google中，我们将其用于收件箱之类的东西。 

00:03:19.839 --> 00:03:21.120
在那里工作良好。 

00:03:21.120 --> 00:03:23.590
马特：我认为是这些事情-您最终会- 

00:03:23.590 --> 00:03:24.760
坐下来思考

00:03:24.760 --> 00:03:26.593
是否对我的网站合理？ 

00:03:26.593 --> 00:03:28.880
但我认为这通常是一个模型

00:03:28.880 --> 00:03:30.910
在许多情况下都是实用的。 

00:03:30.910 --> 00:03:33.000
艾迪：这个模型背后有很多东西

00:03:33.000 --> 00:03:35.810
您可能会解释比仅仅一部视频更好。 

00:03:35.810 --> 00:03:39.090
但是我们为此写了一篇很棒的文章， 

00:03:39.090 --> 00:03:40.330
如果你对我们自己这么说。 

00:03:40.330 --> 00:03:42.150
马特：恩，你写了，我读了。 

00:03:42.150 --> 00:03:44.080
艾迪：您在最后添加了姓名。 

00:03:44.080 --> 00:03:45.350
马特：是的，这就是我的方式。 

00:03:45.350 --> 00:03:47.660
艾迪：是的。效果。值得一看。 

00:03:47.660 --> 00:03:48.880
马特：这是程序模式。 

00:03:48.880 --> 00:03:50.750
 Ady：这是一篇普通文章，但其中包含漂亮的形状。 

00:03:50.750 --> 00:03:51.640
马特：是的。 

00:03:51.640 --> 00:03:53.400
阿迪：人们应该看到它， 

00:03:53.400 --> 00:03:54.800
并了解有关应用程序结构的更多信息。 

00:03:54.800 --> 00:03:57.082
马特：还有一个初学者指南

00:03:57.082 --> 00:03:59.290
在您的第一个应用中，他谈到

00:03:59.290 --> 00:04:01.610
应用程序结构模型， 

00:04:01.610 --> 00:04:03.270
如何从中受益， 

00:04:03.270 --> 00:04:05.070
以及它如何应用于演示应用程序

00:04:05.070 --> 00:04:07.130
由这个心爱的实验室设计。 

00:04:07.130 --> 00:04:08.620
艾迪：在那篇文章中，我们添加了链接

00:04:08.620 --> 00:04:10.980
帮助您快速入门的工具

00:04:10.980 --> 00:04:13.810
在示例应用程序中，我们正在努力。 

00:04:13.810 --> 00:04:15.287
所以检查一下。 

00:04:15.287 --> 00:04:16.870
 Matt：是的，他们设计了air应用程序。 

00:04:16.870 --> 00:04:21.970
 [音乐] 

