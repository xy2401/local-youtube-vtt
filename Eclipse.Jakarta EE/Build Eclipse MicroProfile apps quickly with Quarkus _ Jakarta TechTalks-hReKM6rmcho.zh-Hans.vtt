WEBVTT
Kind: captions
Language: zh-Hans

00:00:15.600 --> 00:00:23.040
好的，大家好，我们即将

00:00:20.080 --> 00:00:28.420
开始另一个激动人心的技术讲座， 

00:00:23.040 --> 00:00:31.180
 cas体是本月的团队

00:00:28.420 --> 00:00:35.350
确保每个人都在嗡嗡作响，我们

00:00:31.180 --> 00:00:37.630
有机会拥有约翰

00:00:35.350 --> 00:00:43.090
克林格在这里和我们在一起，他将

00:00:37.630 --> 00:00:46.980
谈论如何构建Eclipse micro 

00:00:43.090 --> 00:00:51.550
 car体的轮廓应用

00:00:46.980 --> 00:00:54.460
不会浪费太多时间

00:00:51.550 --> 00:00:59.250
我会交给约翰和约翰

00:00:54.460 --> 00:01:04.260
如果您想接管并继续

00:00:59.250 --> 00:01:04.260
可以，所以我要分享我的屏幕

00:01:06.420 --> 00:01:14.229
好吧，每个人都看到屏幕好了，我输了

00:01:12.429 --> 00:01:22.090
您的音频不知道是我还是

00:01:14.229 --> 00:01:24.850
你好吧，你的屏幕很棒吗

00:01:22.090 --> 00:01:27.009
所以欢迎大家谢谢

00:01:24.850 --> 00:01:29.020
您宝贵的时间来了解如何

00:01:27.009 --> 00:01:31.929
用Korkis构建微型个人资料应用

00:01:29.020 --> 00:01:36.689
我叫John Klingon，我是

00:01:31.929 --> 00:01:38.799
 Red Hat的产品经理

00:01:36.689 --> 00:01:41.259
微型个人资料提交者之一

00:01:38.799 --> 00:01:44.829
联合创始人有点帮助开始我的

00:01:41.259 --> 00:01:47.770
个人资料，我的推特手柄位于

00:01:44.829 --> 00:01:50.200
 Jaclyn所以你会看到我聊天的

00:01:47.770 --> 00:01:51.869
关于夸克的很多东西是

00:01:50.200 --> 00:01:55.929
微观轮廓和类似的东西

00:01:51.869 --> 00:01:58.270
我有几张幻灯片，然后又很多

00:01:55.929 --> 00:02:01.119
实时编码，所以我们将看看如何

00:01:58.270 --> 00:02:04.270
这就是我现在要原谅

00:02:01.119 --> 00:02:07.299
万一我们遇到问题好吧，让我

00:02:04.270 --> 00:02:11.250
看到这里好了再说一点

00:02:07.299 --> 00:02:13.920
关于Java堆栈的演变

00:02:11.250 --> 00:02:15.520
怀疑你们中许多人都熟悉

00:02:13.920 --> 00:02:18.970
做发展

00:02:15.520 --> 00:02:22.600
正确使用Java EE，所以我们已经

00:02:18.970 --> 00:02:25.660
这个堆栈这个Java堆栈

00:02:22.600 --> 00:02:27.820
在过去20年的大部分时间里进行了优化

00:02:25.660 --> 00:02:31.240
用于基本运行的Java应用程序

00:02:27.820 --> 00:02:33.070
和服务器正确，所以期望是

00:02:31.240 --> 00:02:35.610
您正在直接运行

00:02:33.070 --> 00:02:40.960
在硬件或虚拟机上

00:02:35.610 --> 00:02:44.380
您正在运行大量的应用程序

00:02:40.960 --> 00:02:47.260
服务器在服务器上运行

00:02:44.380 --> 00:02:49.720
 JDK的顶部

00:02:47.260 --> 00:02:51.070
在很大程度上进行了优化

00:02:49.720 --> 00:02:54.910
正确运行应用程序服务器

00:02:51.070 --> 00:02:57.790
运行大量的线程

00:02:54.910 --> 00:03:00.190
没有部署时的动态活动

00:02:57.790 --> 00:03:02.200
部署应用程序，您已经

00:03:00.190 --> 00:03:04.900
越来越多的框架

00:03:02.200 --> 00:03:06.610
时间变得越来越充满活力， 

00:03:04.900 --> 00:03:10.830
这意味着要进行大量反思

00:03:06.610 --> 00:03:10.830
在运行时做出很多决定，所以

00:03:12.300 --> 00:03:19.060
我们一直在搬家

00:03:16.480 --> 00:03:20.440
在过去的三四年中

00:03:19.060 --> 00:03:23.740
越来越倾向于微型

00:03:20.440 --> 00:03:26.920
服务，并且您知道Java EE变慢了

00:03:23.740 --> 00:03:29.200
下降了一段时间，现在它正在向

00:03:26.920 --> 00:03:32.280
 Eclipse Foundation命名为Jakarta EE，但是为什么

00:03:29.200 --> 00:03:36.820
它会放慢一会儿吗

00:03:32.280 --> 00:03:39.310
我们基本上是一个社区，如您所知

00:03:36.820 --> 00:03:42.190
是供应商还是个人Java 

00:03:39.310 --> 00:03:44.860
用户组创建了Eclipse micro 

00:03:42.190 --> 00:03:48.670
正确的想法是继续

00:03:44.860 --> 00:03:51.730
创建规范的想法

00:03:48.670 --> 00:03:54.100
培养您知道多种实现

00:03:51.730 --> 00:03:57.910
但是我们用不同于以往的方式

00:03:54.100 --> 00:04:00.130
使用Java EE完成，甚至有所不同

00:03:57.910 --> 00:04:02.020
我认为Jakarta EE将如何发展

00:04:00.130 --> 00:04:04.209
这基本上意味着我们对待微

00:04:02.020 --> 00:04:08.440
就像它是一个开源一样

00:04:04.209 --> 00:04:11.590
社区权利，所以它是一个开源

00:04:08.440 --> 00:04:14.760
项目，我的意思是，我们有多个

00:04:11.590 --> 00:04:18.160
每年的发行量我们不一定

00:04:14.760 --> 00:04:20.470
相当保证向后兼容性

00:04:18.160 --> 00:04:23.230
像Java EE甚至Jakarta EE 

00:04:20.470 --> 00:04:26.680
计划写，所以我们考虑自己

00:04:23.230 --> 00:04:28.250
移动速度更快的社区来解决

00:04:26.680 --> 00:04:29.900
需要

00:04:28.250 --> 00:04:32.510
微服务开发仍然存在

00:04:29.900 --> 00:04:34.910
这个区域有很多运动，所以如果你

00:04:32.510 --> 00:04:38.360
看看这个的右边

00:04:34.910 --> 00:04:43.160
图表中您会看到有一个

00:04:38.360 --> 00:04:45.970
健康的规范集有一个

00:04:43.160 --> 00:04:50.390
 Java EE的基础编程模型

00:04:45.970 --> 00:04:52.700
与CDI JSON处理和Jason 

00:04:50.390 --> 00:04:54.560
绑定，然后用jax-rs 

00:04:52.700 --> 00:04:56.620
定义基本的编程模型并

00:04:54.560 --> 00:05:02.650
最重要的是，我们有规格

00:04:56.620 --> 00:05:06.020
定义如何利用

00:05:02.650 --> 00:05:08.300
具有特定功能的微服务模式

00:05:06.020 --> 00:05:10.490
一套api，在市场上

00:05:08.300 --> 00:05:13.310
这些api的多种实现

00:05:10.490 --> 00:05:16.880
所以在左下角

00:05:13.310 --> 00:05:19.700
可以看到这是一个相当大的社区

00:05:16.880 --> 00:05:21.830
供应商组织和

00:05:19.700 --> 00:05:26.840
个人是一个非常活跃的社区

00:05:21.830 --> 00:05:28.070
微型轮廓大王和下

00:05:26.840 --> 00:05:30.830
右边你会看到一堆

00:05:28.070 --> 00:05:32.390
实现和我将成为的Korkis 

00:05:30.830 --> 00:05:34.940
谈论它也是

00:05:32.390 --> 00:05:39.620
实施我们还没有完全运行

00:05:34.940 --> 00:05:42.440
微型配置文件还可以，但是有

00:05:39.620 --> 00:05:45.800
也有多种规格

00:05:42.440 --> 00:05:48.470
管道实际上是其中之一

00:05:45.800 --> 00:05:51.320
完成了我们的微轮廓反应

00:05:48.470 --> 00:05:54.410
流运算符，并且有反应

00:05:51.320 --> 00:05:56.690
消息传递规范上下文传播图

00:05:54.410 --> 00:05:59.390
 QL长期运行的动作，所以有很多

00:05:56.690 --> 00:06:02.090
规范的存在

00:05:59.390 --> 00:06:04.160
可能应该出来的烤

00:06:02.090 --> 00:06:06.410
在您知道的未来六个月内，或

00:06:04.160 --> 00:06:09.470
所以我们会继续发展

00:06:06.410 --> 00:06:11.960
很快，但我们又在不断发展

00:06:09.470 --> 00:06:14.510
微服务开发的背景

00:06:11.960 --> 00:06:16.820
现在有趣的是，如果我们

00:06:14.510 --> 00:06:19.370
考虑一下现代企业Java 

00:06:16.820 --> 00:06:22.610
微服务真的是我们的工作

00:06:19.370 --> 00:06:25.430
我们是否遵循相同的哲学

00:06:22.610 --> 00:06:27.290
在很多情况下，我们都拥有相同的

00:06:25.430 --> 00:06:31.160
我们已经让您了解的框架

00:06:27.290 --> 00:06:32.840
您知道的最后15年左右，我们

00:06:31.160 --> 00:06:36.320
刚刚将它们应用于微服务

00:06:32.840 --> 00:06:39.110
因此，与其在上面部署多个应用

00:06:36.320 --> 00:06:41.580
 JVM的顶部我们要做的是

00:06:39.110 --> 00:06:43.050
只需部署单个应用

00:06:41.580 --> 00:06:45.659
再次平均许多相同的

00:06:43.050 --> 00:06:47.400
有新的框架

00:06:45.659 --> 00:06:50.340
对，因此Micro个人资料就是一个很好的例子

00:06:47.400 --> 00:06:52.830
对，我们到目前为止有八九个人

00:06:50.340 --> 00:06:54.629
本地规格，还有更多

00:06:52.830 --> 00:06:57.120
就像我提到的管道，所以有

00:06:54.629 --> 00:07:00.539
一些新的框架，但是

00:06:57.120 --> 00:07:02.490
这些框架一直在发展

00:07:00.539 --> 00:07:04.729
如果他们仍然相当动态吧

00:07:02.490 --> 00:07:08.879
他们做出很多运行时决策， 

00:07:04.729 --> 00:07:11.599
甚至是下面的运行时

00:07:08.879 --> 00:07:14.490
应用服务器仍然做很多事情

00:07:11.599 --> 00:07:18.300
的优化和决策

00:07:14.490 --> 00:07:21.120
好的运行时，这就是我们要做的

00:07:18.300 --> 00:07:24.780
当然进来的夸克基本上是

00:07:21.120 --> 00:07:28.740
重新考虑这一点，它说的很好，让我们

00:07:24.780 --> 00:07:30.210
让我们优化此堆栈，以便我们

00:07:28.740 --> 00:07:32.129
了解我们的目标环境

00:07:30.210 --> 00:07:34.919
不一定要运行多个

00:07:32.129 --> 00:07:37.379
应用服务器上的应用

00:07:34.919 --> 00:07:40.219
顺便说一句Java EE 

00:07:37.379 --> 00:07:42.719
仍然可用的模型，所以嗯

00:07:40.219 --> 00:07:45.150
我们在这里谈论的是如果我是

00:07:42.719 --> 00:07:48.360
专门针对微服务

00:07:45.150 --> 00:07:49.620
和单个应用堆栈

00:07:48.360 --> 00:07:53.099
我们正在寻找类似的东西

00:07:49.620 --> 00:07:56.699
 Korkis对，我可以拿这些

00:07:53.099 --> 00:07:59.219
应用程序以及这些框架

00:07:56.699 --> 00:08:02.430
并在理解的基础上建立他们

00:07:59.219 --> 00:08:05.490
它将被部署到

00:08:02.430 --> 00:08:07.620
基于kubernetes Linux容器

00:08:05.490 --> 00:08:09.690
环境，这两种

00:08:07.620 --> 00:08:09.960
您在堆栈下看到的所有图标

00:08:09.690 --> 00:08:11.879
对

00:08:09.960 --> 00:08:14.969
这就是新的目标

00:08:11.879 --> 00:08:16.919
组织所处的环境

00:08:14.969 --> 00:08:18.870
部署到夸克是

00:08:16.919 --> 00:08:23.190
专门针对kubernetes和

00:08:18.870 --> 00:08:27.659
容器，这意味着在

00:08:23.190 --> 00:08:31.800
 kubernetes环境，这是一个

00:08:27.659 --> 00:08:34.199
这是一个不变的环境

00:08:31.800 --> 00:08:36.479
这意味着当我开发一个容器时

00:08:34.199 --> 00:08:38.699
我倾向于不登录到容器中

00:08:36.479 --> 00:08:41.699
正确地进行更改我所做的就是

00:08:38.699 --> 00:08:44.399
我的代码更改，然后运行

00:08:41.699 --> 00:08:46.860
通过管道进行代码重新部署

00:08:44.399 --> 00:08:49.260
一个新的容器，所以这是

00:08:46.860 --> 00:08:50.819
可变基础设施的想法，如果

00:08:49.260 --> 00:08:52.110
您考虑那些动态框架

00:08:50.819 --> 00:08:53.850
我一直在谈论

00:08:52.110 --> 00:08:55.140
我们进行了很多反思

00:08:53.850 --> 00:08:58.980
跑很多

00:08:55.140 --> 00:09:01.470
部署到它的决定是什么

00:08:58.980 --> 00:09:03.030
真正的不变基础架构

00:09:01.470 --> 00:09:07.950
 Korkis树认为它说得很好

00:09:03.030 --> 00:09:12.090
我们不瞄准目标或不赚很多钱

00:09:07.950 --> 00:09:14.370
这些决策在运行时

00:09:12.090 --> 00:09:15.540
通过优化框架

00:09:14.370 --> 00:09:17.790
了解我的目标

00:09:15.540 --> 00:09:19.590
不变的基础设施，所以我们要做的

00:09:17.790 --> 00:09:21.570
是我们做优化之类的事情吗

00:09:19.590 --> 00:09:25.650
扫描类路径或注释

00:09:21.570 --> 00:09:29.040
将结果预先编译成

00:09:25.650 --> 00:09:33.420
 jar文件（如果要运行） 

00:09:29.040 --> 00:09:35.460
在Java之上或在本机二进制文件中

00:09:33.420 --> 00:09:37.770
如果您要跑步，您会知道

00:09:35.460 --> 00:09:40.230
直接在操作系统上

00:09:37.770 --> 00:09:41.760
它没有JDK，所以我们做了很多

00:09:40.230 --> 00:09:43.050
现在在构建时使用

00:09:41.760 --> 00:09:44.940
了解我们将成为

00:09:43.050 --> 00:09:49.800
部署两个不变的基础架构

00:09:44.940 --> 00:09:53.970
所以我们基本上是在优化

00:09:49.800 --> 00:09:57.300
整个堆栈正确，所以您会看到一些

00:09:53.970 --> 00:09:59.760
这种无夸克的例子可以在

00:09:57.300 --> 00:10:01.440
在JDK上，您可以将其放入

00:09:59.760 --> 00:10:04.470
如果要在JDK上进行生产

00:10:01.440 --> 00:10:07.110
好吧，但是你也可以把它编译下来

00:10:04.470 --> 00:10:09.780
到本地二进制文件，实际上

00:10:07.110 --> 00:10:10.940
开发模式，我们将严格按照

00:10:09.780 --> 00:10:12.840
 JDK的顶部

00:10:10.940 --> 00:10:16.530
好吧，我要快点

00:10:12.840 --> 00:10:20.940
如果我想现在检查所有

00:10:16.530 --> 00:10:25.410
编译为我们利用的二进制井

00:10:20.940 --> 00:10:30.690
咆哮的虚拟机做到这一点咆哮的虚拟机是一个漂亮的

00:10:25.410 --> 00:10:32.730
令人敬畏的项目，可以高度运行

00:10:30.690 --> 00:10:36.090
高效的Java代码甚至是动态的

00:10:32.730 --> 00:10:37.860
现在可以在JVM上运行的语言

00:10:36.090 --> 00:10:39.510
 Korkis并不真正专注于此

00:10:37.860 --> 00:10:42.270
它在动态语言上的方面

00:10:39.510 --> 00:10:43.830
方面，但它确实利用善良

00:10:42.270 --> 00:10:49.350
您在此看到的那些红色方框中

00:10:43.830 --> 00:10:50.990
图咆哮编译器或

00:10:49.350 --> 00:10:54.000
编译成本地代码，我们

00:10:50.990 --> 00:10:57.180
真正专注于Java语言

00:10:54.000 --> 00:11:00.140
尽管我们确实支持Kotlin在

00:10:57.180 --> 00:11:03.330
 Korkis的顶部以及所有

00:11:00.140 --> 00:11:04.980
甚至在您的二进制文件内部

00:11:03.330 --> 00:11:07.530
仍然有一个虚拟机在运行

00:11:04.980 --> 00:11:09.970
但是它的作用大大降低了

00:11:07.530 --> 00:11:13.430
与刚跑步相比

00:11:09.970 --> 00:11:16.130
具有热点vm的OpenJDK怎么办

00:11:13.430 --> 00:11:18.260
 Korkis利用生长vm既是

00:11:16.130 --> 00:11:20.090
本机编译和无效代码

00:11:18.260 --> 00:11:21.890
消除，所以其中之一是

00:11:20.090 --> 00:11:25.520
我们对Korkis所做的就是

00:11:21.890 --> 00:11:28.400
优化了很多库，以便

00:11:25.520 --> 00:11:31.430
我们减少了

00:11:28.400 --> 00:11:34.460
图书馆，甚至跨图书馆

00:11:31.430 --> 00:11:37.400
这意味着如果您的应用程序

00:11:34.460 --> 00:11:39.080
不使用某些代码

00:11:37.400 --> 00:11:40.370
在编译阶段消除

00:11:39.080 --> 00:11:45.410
那意味着你得到一个相对

00:11:40.370 --> 00:11:53.840
小可执行二进制文件，好吧，让我们

00:11:45.410 --> 00:11:56.870
做一些现场编码好吧

00:11:53.840 --> 00:11:59.210
大家可以看看我们在这里吗

00:11:56.870 --> 00:12:02.120
会变得更大，我确实有

00:11:59.210 --> 00:12:05.330
聊天在另一台显示器上打开，所以如果人们

00:12:02.120 --> 00:12:07.400
想问问题或发表评论

00:12:05.330 --> 00:12:09.080
关于你知道能够看到

00:12:07.400 --> 00:12:09.490
我写的代码和东西只是让我

00:12:09.080 --> 00:12:13.190
知道

00:12:09.490 --> 00:12:15.050
好吧，所以创建一个项目

00:12:13.190 --> 00:12:18.920
 Korkis我们要做的是

00:12:15.050 --> 00:12:21.320
要使用Quercus maven插件，所以

00:12:18.920 --> 00:12:24.950
这实际上会产生轮廓

00:12:21.320 --> 00:12:26.360
我们一个非常简单的宁静终点

00:12:24.950 --> 00:12:29.720
正在基于网络

00:12:26.360 --> 00:12:30.950
也是首发，但现在我们是

00:12:29.720 --> 00:12:35.360
将要使用的是Maven插件

00:12:30.950 --> 00:12:40.240
生成源代码，所以你

00:12:35.360 --> 00:12:43.610
可以看到这里是我刚刚提供的

00:12:40.240 --> 00:12:45.080
我的Maven工件信息

00:12:43.610 --> 00:12:46.850
希望为此而产生

00:12:45.080 --> 00:12:48.950
对于这个项目，什么小组

00:12:46.850 --> 00:12:50.630
想法是工件的想法，我们在这里

00:12:48.950 --> 00:12:53.210
我们要称呼它

00:12:50.630 --> 00:12:56.000
创建一个称为人员的宁静资源

00:12:53.210 --> 00:12:59.780
资源，它将在

00:12:56.000 --> 00:13:08.450
人端点，嘿，我要继续

00:12:59.780 --> 00:13:10.250
并创建这个好吧，所以如果我想

00:13:08.450 --> 00:13:13.460
看一下真实的源代码

00:13:10.250 --> 00:13:15.050
很快你看到的是你知道

00:13:13.460 --> 00:13:20.649
就像我说的那样

00:13:15.050 --> 00:13:25.059
现在简单的宁静端点

00:13:20.649 --> 00:13:27.970
让我们添加一些其他的专家

00:13:25.059 --> 00:13:30.819
依赖关系，以便我们可以建立一个

00:13:27.970 --> 00:13:34.149
实际的微轮廓应用程序

00:13:30.819 --> 00:13:36.100
 Korkis再次使用了Maven插件

00:13:34.149 --> 00:13:38.860
有一个目标叫清单

00:13:36.100 --> 00:13:40.300
扩展Quercus中的扩展是

00:13:38.860 --> 00:13:45.910
基本上我提到的是一个漂亮的

00:13:40.300 --> 00:13:48.040
优化的框架

00:13:45.910 --> 00:13:51.100
像我一样优化效率

00:13:48.040 --> 00:13:53.079
之前提到过，但是你也可以

00:13:51.100 --> 00:13:54.970
假设它在合唱中

00:13:53.079 --> 00:13:57.220
扩展它也可以被编译下来

00:13:54.970 --> 00:14:00.160
到本地二进制文件

00:13:57.220 --> 00:14:04.389
 Java生态系统中的框架可以

00:14:00.160 --> 00:14:06.100
编译成本地二进制文件

00:14:04.389 --> 00:14:08.499
没有一些额外的工作，我们很友善

00:14:06.100 --> 00:14:12.309
代表做了额外的工作

00:14:08.499 --> 00:14:15.309
这些框架的开发者，所以如果我们

00:14:12.309 --> 00:14:17.679
看看我们拥有的扩展

00:14:15.309 --> 00:14:20.230
我们的关键是我们的CDI实现

00:14:17.679 --> 00:14:24.490
 Korkis，你看到我们有一些骆驼

00:14:20.230 --> 00:14:27.579
扩展flyweight和其他数据库

00:14:24.490 --> 00:14:31.029
相关扩展休眠了一些JDBC 

00:14:27.579 --> 00:14:35.850
司机让我们看看我们还有什么

00:14:31.029 --> 00:14:40.199
芬兰乐队支持杰森

00:14:35.850 --> 00:14:42.730
通过Jason消费和生产Jason 

00:14:40.199 --> 00:14:45.759
绑定和处理密钥斗篷

00:14:42.730 --> 00:14:47.910
我希望有时间安全kubernetes 

00:14:45.759 --> 00:14:49.660
证明它能产生戊基

00:14:47.910 --> 00:14:51.009
使您能够

00:14:49.660 --> 00:14:53.470
应用程序并将其部署到

00:14:51.009 --> 00:14:56.230
 kubernetes环境Catelyn I 

00:14:53.470 --> 00:14:57.929
提到看到所有交易

00:14:56.230 --> 00:15:01.059
这些小的正确的基本上

00:14:57.929 --> 00:15:03.579
微型配置文件规范的实现正确

00:15:01.059 --> 00:15:06.519
这样就可以看到上下文传播错误

00:15:03.579 --> 00:15:09.639
耐受性健康指标很多

00:15:06.519 --> 00:15:13.179
在小权利中实施

00:15:09.639 --> 00:15:15.339
项目和kafka支持以及所有这些

00:15:13.179 --> 00:15:21.850
好吧，那是一个很大的清单，所以

00:15:15.339 --> 00:15:25.839
我现在要做的就是

00:15:21.850 --> 00:15:29.519
向您展示如何向其中添加一些扩展

00:15:25.839 --> 00:15:34.209
我们的项目，所以我们要做的是

00:15:29.519 --> 00:15:37.360
使用添加扩展名

00:15:34.209 --> 00:15:40.839
目标，我们将指定

00:15:37.360 --> 00:15:48.399
如果我能拼写，扩展哎呀

00:15:40.839 --> 00:15:50.499
很好，所以很好的之一

00:15:48.399 --> 00:15:52.300
关于这个扩展的事情是你不

00:15:50.499 --> 00:15:56.529
必须输入整个

00:15:52.300 --> 00:15:58.529
您在这里看到的字符串

00:15:56.529 --> 00:16:01.119
输入子集，如果可以找到

00:15:58.529 --> 00:16:02.410
没有任何名字

00:16:01.119 --> 00:16:05.649
一种名称冲突，它将添加它

00:16:02.410 --> 00:16:08.339
好吧，让我们做一个我提到的Kubb 

00:16:05.649 --> 00:16:12.129
为了做kubernetes ya mole 

00:16:08.339 --> 00:16:14.439
代容错性让我们使用

00:16:12.129 --> 00:16:16.559
我要去的微型个人资料restclient 

00:16:14.439 --> 00:16:23.050
表明我要显示一些指标

00:16:16.559 --> 00:16:25.899
我将展示开放的API并夸大其词

00:16:23.050 --> 00:16:28.240
我不想要的，因为我们将击中

00:16:25.899 --> 00:16:32.259
命名空间冲突Korkis轻松自在

00:16:28.240 --> 00:16:34.720
 Jason binding让我们看看我要去做

00:16:32.259 --> 00:16:37.959
 panache panache是​​一层又容易

00:16:34.720 --> 00:16:40.029
在GPA之上使用层并休眠

00:16:37.959 --> 00:16:42.040
那将是一个有趣的节目，我要

00:16:40.029 --> 00:16:45.579
展示我们将使用h2数据库

00:16:42.040 --> 00:16:47.949
当我们在本地发展时

00:16:45.579 --> 00:16:49.899
我们在内存数据库中使用，但是当我们去时

00:16:47.949 --> 00:16:51.160
在我们的kubernetes上投入生产

00:16:49.899 --> 00:16:54.759
我在我的集​​群上运行的集群

00:16:51.160 --> 00:16:57.129
笔记本电脑，请张贴克里斯，我们将使用

00:16:54.759 --> 00:16:58.860
微型个人资料运行状况检查，我们将看看

00:16:57.129 --> 00:17:03.610
我们实际上可以得到的很多

00:16:58.860 --> 00:17:06.159
在这个小时里，所以现在

00:17:03.610 --> 00:17:07.750
失败，因为我们实际上遇到了

00:17:06.159 --> 00:17:09.850
我提到过的命名空间冲突

00:17:07.750 --> 00:17:13.990
克里斯，但实际上有两个不同

00:17:09.850 --> 00:17:15.819
为您发布CRA的数据库驱动程序

00:17:13.990 --> 00:17:17.500
用于使用异步反应驱动程序

00:17:15.819 --> 00:17:20.439
另一个用于使用标准JDBC 

00:17:17.500 --> 00:17:27.299
司机，所以我要做的就是选择

00:17:20.439 --> 00:17:27.299
标准的JDBC，我们将对其进行修复

00:17:27.659 --> 00:17:32.620
好的，现在添加了，我要去做

00:17:30.850 --> 00:17:36.850
另一种预

00:17:32.620 --> 00:17:38.320
为此在此进行优化

00:17:36.850 --> 00:17:40.750
项目，我要设置一个

00:17:38.320 --> 00:17:45.909
环境变量，所以我要设置

00:17:40.750 --> 00:17:48.070
任务或配置文件上的Quercus等于dev这样

00:17:45.909 --> 00:17:50.530
这将在我们使用时派上用场

00:17:48.070 --> 00:17:52.120
使用微配置文件配置，我们可以

00:17:50.530 --> 00:17:53.590
具有不同的配置文件

00:17:52.120 --> 00:17:56.260
一个用于发展，另一个用于

00:17:53.590 --> 00:17:59.290
生产现在我要去

00:17:56.260 --> 00:18:04.230
将这些全部打开到Visual Studio代码中

00:17:59.290 --> 00:18:07.030
当然，您可以使用自己喜欢的IDE 

00:18:04.230 --> 00:18:10.870
好吧，让我们来看看手掌

00:18:07.030 --> 00:18:12.640
文件，您会看到我们正在使用版本

00:18:10.870 --> 00:18:15.000
夸克17是最新的

00:18:12.640 --> 00:18:17.080
版本，您可以看到所有这些

00:18:15.000 --> 00:18:20.700
我们刚刚添加的Maven依赖项

00:18:17.080 --> 00:18:23.140
扩展好了，还有

00:18:20.700 --> 00:18:26.440
如果我们想编译成本地的

00:18:23.140 --> 00:18:28.210
编码，您将看到的一件事是

00:18:26.440 --> 00:18:29.820
 pro maven配置文件称为native和

00:18:28.210 --> 00:18:32.290
让我们生成一个本地二进制文件

00:18:29.820 --> 00:18:33.910
我要尽量减少这种情况，因为

00:18:32.290 --> 00:18:35.200
需要一段时间，我们没有很多

00:18:33.910 --> 00:18:38.830
有时间展示很多

00:18:35.200 --> 00:18:41.170
功能，所以我要创建一个

00:18:38.830 --> 00:18:44.590
终端现在我要做的就是放

00:18:41.170 --> 00:18:46.240
我在开发模式中的Quercus 

00:18:44.590 --> 00:18:49.420
应该在这里设置配置文件

00:18:46.240 --> 00:18:53.710
事实上，当我们在此终端中执行此操作时

00:18:49.420 --> 00:18:54.970
窗口，现在我们要运行Quercus 

00:18:53.710 --> 00:18:55.860
开发人员模式，以便我可以开发

00:18:54.970 --> 00:18:59.680
项目

00:18:55.860 --> 00:19:01.600
夸克夸克是：开发人员，这是什么

00:18:59.680 --> 00:19:03.460
要去做，这将打开一个

00:19:01.600 --> 00:19:05.290
如果我想调试端点

00:19:03.460 --> 00:19:08.380
我不觉得我会表现出来

00:19:05.290 --> 00:19:12.100
一次又一次因为时间

00:19:08.380 --> 00:19:14.800
它实际上正在运行该应用程序，现在让我们看看

00:19:12.100 --> 00:19:22.930
在这里我要把车停下来

00:19:14.800 --> 00:19:27.510
另一个窗口，我们要去

00:19:22.930 --> 00:19:34.180
 localhost 冒号8080 / ui 

00:19:27.510 --> 00:19:35.820
因此，微型配置文件具有开放的API支持

00:19:34.180 --> 00:19:39.280
这就是潜在的一种

00:19:35.820 --> 00:19:42.220
该端点Korkis支持

00:19:39.280 --> 00:19:44.740
嵌入式swagger用户界面，使您

00:19:42.220 --> 00:19:47.320
可以尝试宁静的端点

00:19:44.740 --> 00:19:50.590
您在这种情况下创建的方法很简单

00:19:47.320 --> 00:19:53.290
你好，世界，所以哎呀实际上要

00:19:50.590 --> 00:19:56.500
扩展一下，让我们实际尝试一下

00:19:53.290 --> 00:20:00.419
我可能要面对的宁静的终点

00:19:56.500 --> 00:20:03.029
让这个更大吧

00:20:00.419 --> 00:20:05.090
我们将执行端点

00:20:03.029 --> 00:20:07.649
您会看到它以“你好”回应

00:20:05.090 --> 00:20:09.139
现在我将不会使用

00:20:07.649 --> 00:20:10.799
浏览器与应用程序进行交互

00:20:09.139 --> 00:20:12.960
因为我想要

00:20:10.799 --> 00:20:17.009
不断地在之间来回切换

00:20:12.960 --> 00:20:17.940
浏览器和应用程序

00:20:17.009 --> 00:20:20.940
我将做大部分工作

00:20:17.940 --> 00:20:25.470
直接在IDE和终端中

00:20:20.940 --> 00:20:27.269
好吧，所以你可以检查一下

00:20:25.470 --> 00:20:32.009
取消micah个人资料这一事实

00:20:27.269 --> 00:20:33.509
支持开箱即用的开放式api，所以我

00:20:32.009 --> 00:20:38.759
要回到实际上

00:20:33.509 --> 00:20:42.559
演示文稿在这里全屏讨论

00:20:38.759 --> 00:20:42.559
关于微型配置文件的一些信息

00:20:42.919 --> 00:20:47.039
良好的微轮廓

00:20:44.999 --> 00:20:48.779
对不起，良好的微服务开发

00:20:47.039 --> 00:20:49.980
你知道的十二种风格

00:20:48.779 --> 00:20:52.649
应用是您要外部化您的

00:20:49.980 --> 00:20:55.109
应用程序配置，您可以

00:20:52.649 --> 00:20:59.220
使用微配置文件配置来做到这一点

00:20:55.109 --> 00:21:02.519
您可以注入属性的值

00:20:59.220 --> 00:21:06.419
进入您的应用程序并在

00:21:02.519 --> 00:21:08.669
场景中有多个属性来源

00:21:06.419 --> 00:21:13.350
配置资源正确，因此您可以指定

00:21:08.669 --> 00:21:15.629
使用java属性的属性

00:21:13.350 --> 00:21:17.100
命令行，也可以设置一个

00:21:15.629 --> 00:21:20.519
中间的环境变量

00:21:17.100 --> 00:21:22.350
底部的方框，也可以定义它

00:21:20.519 --> 00:21:25.350
在微型配置文件中-配置点

00:21:22.350 --> 00:21:27.899
属性文件，现在我们的Quercus做到了

00:21:25.350 --> 00:21:30.119
确实支持该微型配置文件配置

00:21:27.899 --> 00:21:31.710
属性文件，但它也支持

00:21:30.119 --> 00:21:33.889
应用程序类型属性文件和

00:21:31.710 --> 00:21:36.539
那是我在此期间要使用的那个

00:21:33.889 --> 00:21:40.499
演示文稿，您也可以创建

00:21:36.539 --> 00:21:44.759
自定义配置源，因此您可以

00:21:40.499 --> 00:21:48.889
为Vault创建配置源

00:21:44.759 --> 00:21:52.220
尤里卡无论有什么权利

00:21:48.889 --> 00:21:56.039
实际上，事件配置源

00:21:52.220 --> 00:21:58.379
有一个微型个人资料扩展名

00:21:56.039 --> 00:22:00.450
实际上扩展了很多项目

00:21:58.379 --> 00:22:02.639
这些微轮廓的功能

00:22:00.450 --> 00:22:06.509
微型github我认为这是一个github通讯

00:22:02.639 --> 00:22:10.710
 slash micro profile-扩展项目

00:22:06.509 --> 00:22:12.950
好吧，让我们回去做一点

00:22:10.710 --> 00:22:12.950
一点

00:22:13.350 --> 00:22:21.960
编码，所以我要提起糟糕

00:22:17.340 --> 00:22:22.470
在这里不测试我的Java人员资源

00:22:21.960 --> 00:22:24.120
我们去

00:22:22.470 --> 00:22:25.860
所以这是原来的代码

00:22:24.120 --> 00:22:30.210
现在生成的我们要做的是

00:22:25.860 --> 00:22:31.830
增加注入资源的能力

00:22:30.210 --> 00:22:37.350
从外部位置可以

00:22:31.830 --> 00:22:42.029
让我们在注入配置属性

00:22:37.350 --> 00:22:46.110
是一个微型配置文件API，请确保

00:22:42.029 --> 00:22:49.980
我们选择合适的，让我们看看

00:22:46.110 --> 00:22:52.620
我们要在这里做名字吗

00:22:49.980 --> 00:22:54.240
问候，我们也将

00:22:52.620 --> 00:22:56.340
给它一个默认值，以便我们可以

00:22:54.240 --> 00:22:59.100
现在进行测试并使用默认设置

00:22:56.340 --> 00:23:03.830
价值将是你好，而且

00:22:59.100 --> 00:23:09.539
我们将其注入字符串中

00:23:03.830 --> 00:23:13.679
在这里阅读变量，我们只是

00:23:09.539 --> 00:23:16.049
要回去问候好吧

00:23:13.679 --> 00:23:17.419
让我们回到我认为创建一个新的

00:23:16.049 --> 00:23:20.009
终端窗口

00:23:17.419 --> 00:23:22.230
而我只是要使用HTTP即

00:23:20.009 --> 00:23:24.929
一种命令行工具，所以您只是

00:23:22.230 --> 00:23:28.500
键入HTTP，然后输入所需的URL 

00:23:24.929 --> 00:23:35.250
访问，所以我们要做一个HTTP 

00:23:28.500 --> 00:23:38.279
 localhost 冒号8080斜杠/真诚得到

00:23:35.250 --> 00:23:39.960
你好现在你可能没有注意到

00:23:38.279 --> 00:23:42.470
是我不必编译

00:23:39.960 --> 00:23:45.179
我不需要按Control-C的任何内容

00:23:42.470 --> 00:23:49.049
重新编译然后重新启动应用程序吧

00:23:45.179 --> 00:23:50.669
所以Korkis实际上是实时加载所有

00:23:49.049 --> 00:23:52.799
我所做的改变

00:23:50.669 --> 00:23:56.340
他们是对的，这不仅是为了

00:23:52.799 --> 00:23:57.840
代码，也可以用于

00:23:56.340 --> 00:23:59.029
属性文件，让我们继续进行

00:23:57.840 --> 00:24:01.559
那

00:23:59.029 --> 00:24:03.330
糟糕，我们去应用DEP 

00:24:01.559 --> 00:24:05.730
属性，所以我们要在这里做的是

00:24:03.330 --> 00:24:10.879
我们要在这里添加问候

00:24:05.730 --> 00:24:14.580
让我们看看我们想称它为好吧

00:24:10.879 --> 00:24:21.210
好吧，我会去呼啦，我们去

00:24:14.580 --> 00:24:22.110
又在终点了

00:24:21.210 --> 00:24:25.740
我们会看到的是

00:24:22.110 --> 00:24:27.029
起床离开属性文件，以便

00:24:25.740 --> 00:24:31.049
有一个优先顺序

00:24:27.029 --> 00:24:37.049
 micah配置文件在哪里看

00:24:31.049 --> 00:24:38.669
首先配置文件并将其拉出

00:24:37.049 --> 00:24:40.380
在那里您可以使用

00:24:38.669 --> 00:24:42.059
环境变量，你可以吃

00:24:40.380 --> 00:24:44.340
如果您使用Java，请同时覆盖两者

00:24:42.059 --> 00:24:48.630
系统财产权再见-迪问候语

00:24:44.340 --> 00:24:54.059
好吧，那很酷，现在让我们

00:24:48.630 --> 00:24:55.409
看一下另一个API 

00:24:54.059 --> 00:25:00.659
个人资料其余客户

00:24:55.409 --> 00:25:03.419
因此，与jax-rs一起，红色建筑就成了

00:25:00.659 --> 00:25:08.429
 REST API需要一些工作

00:25:03.419 --> 00:25:11.460
使用构建器模式与之交互

00:25:08.429 --> 00:25:13.620
微观特征的宁静服务

00:25:11.460 --> 00:25:18.350
休息客户要做的是

00:25:13.620 --> 00:25:22.019
非常安全的做法

00:25:18.350 --> 00:25:24.450
开发一个宁静的客户，以便

00:25:22.019 --> 00:25:25.710
与宁静的服务互动

00:25:24.450 --> 00:25:30.500
真的，您只是在操纵Java 

00:25:25.710 --> 00:25:40.830
好的，让我们继续吧， 

00:25:30.500 --> 00:25:42.480
建立一个宁静的客户，所以回去

00:25:40.830 --> 00:25:44.220
到我们的代码，还有什么好处

00:25:42.480 --> 00:25:46.320
宁静的客户有没有礼物

00:25:44.220 --> 00:25:53.639
一些样板，所以我要

00:25:46.320 --> 00:25:53.840
去这里找到我们的项目哦，我搬到了

00:25:53.639 --> 00:25:55.840
文件

00:25:53.840 --> 00:25:58.630
偶然地我要删除那个

00:25:55.840 --> 00:26:01.700
早些时候我向上滚动时

00:25:58.630 --> 00:26:03.980
意外复制了文件

00:26:01.700 --> 00:26:05.120
这里我们走，让我们回到这里，现在

00:26:03.980 --> 00:26:09.070
我们要创建一个新文件

00:26:05.120 --> 00:26:13.120
要称呼它为您好休息的客户

00:26:09.070 --> 00:26:15.080
点Java可以了

00:26:13.120 --> 00:26:23.779
和我们

00:26:15.080 --> 00:26:28.909
一个包，我们要做的就是创建

00:26:23.779 --> 00:26:32.480
一个接口接口你好休息

00:26:28.909 --> 00:26:34.880
客户现在我们必须对此进行注释

00:26:32.480 --> 00:26:40.370
与几件事接口

00:26:34.880 --> 00:26:44.360
首先是注册其余客户，然后

00:26:40.370 --> 00:26:46.179
我们将要注册这个

00:26:44.360 --> 00:26:49.610
宁静的客户，以便我们实际上可以

00:26:46.179 --> 00:26:53.210
将其注入我们的实际应用程序代码中

00:26:49.610 --> 00:26:56.470
所以接下来我要走的路是

00:26:53.210 --> 00:27:05.980
这将访问哪个端点

00:26:56.470 --> 00:27:05.980
斜杠和远程服务是什么

00:27:06.620 --> 00:27:11.389
什么是远程服务方法

00:27:09.590 --> 00:27:14.389
签名看起来像从你知道

00:27:11.389 --> 00:27:16.460
方法以及HTT和HTTP 

00:27:14.389 --> 00:27:22.490
端点看起来像这样，我们将使用

00:27:16.460 --> 00:27:28.690
得到，我们将生产果汁

00:27:22.490 --> 00:27:34.519
媒体类型不，那不是我想要的

00:27:28.690 --> 00:27:43.440
那是不好的自动完成

00:27:34.519 --> 00:27:45.179
键入点文字平面好，乱七八糟

00:27:43.440 --> 00:27:49.679
这只是公开字符串

00:27:45.179 --> 00:27:53.639
你好，所以基本上我要解决

00:27:49.679 --> 00:27:56.059
我们的进口以及jax-rs生产的产品

00:27:53.639 --> 00:27:59.960
我们去

00:27:56.059 --> 00:28:02.940
所以什么时候我调用这个

00:27:59.960 --> 00:28:04.259
这个终点还是抱歉

00:28:02.940 --> 00:28:06.240
方法，它将称为宁静

00:28:04.259 --> 00:28:13.139
端点，但我们需要做的事情之一

00:28:06.240 --> 00:28:16.200
要做的就是指向URL 

00:28:13.139 --> 00:28:20.580
实际的终点是，我可以

00:28:16.200 --> 00:28:22.679
指定我认为在这里或我可以

00:28:20.580 --> 00:28:24.149
在属性文件中指定它，如此

00:28:22.679 --> 00:28:27.000
我要做的是在

00:28:24.149 --> 00:28:33.240
财产文件还可以，所以我要

00:28:27.000 --> 00:28:34.889
回到实际上我必须证明

00:28:33.240 --> 00:28:41.070
首先我有点不同

00:28:34.889 --> 00:28:43.980
要回到命令行，但是

00:28:41.070 --> 00:28:46.139
相反，我要告诉你的事实是

00:28:43.980 --> 00:28:49.679
我已经在运行hello服务

00:28:46.139 --> 00:28:52.259
所以基本上我必须开始

00:28:49.679 --> 00:28:54.269
你好服务是以前的代码

00:28:52.259 --> 00:28:55.649
当我生成时基本上生成

00:28:54.269 --> 00:28:58.049
首先这个项目只是一个

00:28:55.649 --> 00:29:00.090
回复你好或是其他消息

00:28:58.049 --> 00:29:01.769
所以我所做的就是我接受了

00:29:00.090 --> 00:29:08.120
实际上将其编译为本地

00:29:01.769 --> 00:29:11.399
二进制并将其部署到kubernetes和

00:29:08.120 --> 00:29:13.590
如果你看看这里真的很快

00:29:11.399 --> 00:29:16.080
您会看到我是否查看实际的日志

00:29:13.590 --> 00:29:18.690
您会看到这实际上是从

00:29:16.080 --> 00:29:19.980
正确的是39毫秒

00:29:18.690 --> 00:29:22.860
通常是从慢开始

00:29:19.980 --> 00:29:24.090
大概10毫秒，但是我有很多

00:29:22.860 --> 00:29:27.179
机器上正在发生的事情

00:29:24.090 --> 00:29:30.690
因此对于Java来说，这是非常令人印象深刻的

00:29:27.179 --> 00:29:37.770
申请权还不错，所以我需要

00:29:30.690 --> 00:29:39.930
是端点，是数字

00:29:37.770 --> 00:29:48.180
回到我的源代码，我要打开

00:29:39.930 --> 00:29:50.700
上属性文件，我要

00:29:48.180 --> 00:29:55.320
将此粘贴到我现在可以拥有的内容中

00:29:50.700 --> 00:29:59.550
要做的就是提供

00:29:55.320 --> 00:30:02.880
微型个人资料其余客户将阅读并

00:29:59.550 --> 00:30:05.700
有一个特定的模式

00:30:02.880 --> 00:30:08.460
模式基本上以名称开头

00:30:05.700 --> 00:30:13.230
的包装，所以我要复制

00:30:08.460 --> 00:30:17.840
因为方便点了

00:30:13.230 --> 00:30:22.670
该类lo restclient 

00:30:17.840 --> 00:30:26.460
然后是MP休息，然后是URL 

00:30:22.670 --> 00:30:29.640
好吧，这将是终点

00:30:26.460 --> 00:30:31.770
而且我认为我还必须添加

00:30:29.640 --> 00:30:34.830
你好

00:30:31.770 --> 00:30:36.780
因此，微型个人资料其余客户将阅读

00:30:34.830 --> 00:30:40.980
这个属性，找出这是

00:30:36.780 --> 00:30:43.620
我需要访问并进入

00:30:40.980 --> 00:30:49.170
 Java绑定Java对象绑定（如果我

00:30:43.620 --> 00:30:52.470
需要好的，所以让我们回去

00:30:49.170 --> 00:30:55.830
现在在这里给我们的客户

00:30:52.470 --> 00:30:59.300
宁静的客户权利，所以在注入

00:30:55.830 --> 00:31:06.660
现在我们要去休息的客户

00:30:59.300 --> 00:31:10.920
好吧，我们将要拥有我们的

00:31:06.660 --> 00:31:16.050
你好，休息客户，我会打个招呼

00:31:10.920 --> 00:31:23.220
好的客户

00:31:16.050 --> 00:31:24.270
很抱歉，我要这样做一些不同

00:31:23.220 --> 00:31:30.520
我在后台发生的事情

00:31:24.270 --> 00:31:34.500
试图停止好

00:31:30.520 --> 00:31:38.500
现在这实际上应该注入我们的

00:31:34.500 --> 00:31:40.990
你好客户端代理直接进入

00:31:38.500 --> 00:31:42.910
你好客户端变量，然后调用

00:31:40.990 --> 00:31:44.650
当我实际调用你好

00:31:42.910 --> 00:31:47.410
方法实际上将使遥控器

00:31:44.650 --> 00:31:52.179
打电话，所以我在这里要做的是

00:31:47.410 --> 00:31:54.220
你好客户点你好吧，让我们

00:31:52.179 --> 00:32:01.679
交叉我们的手指，并确保这

00:31:54.220 --> 00:32:03.700
实际有效，确实做到了

00:32:01.679 --> 00:32:06.070
叫你好，这是消息

00:32:03.700 --> 00:32:07.240
实际上是在hello中预定义的

00:32:06.070 --> 00:32:08.650
轻松在CUDA中运行的服务

00:32:07.240 --> 00:32:13.840
运行时权限是OpenShift 

00:32:08.650 --> 00:32:18.309
好吧，让我们回到我们的

00:32:13.840 --> 00:32:20.230
如果我们现在可以幻灯片的话，很好的是

00:32:18.309 --> 00:32:22.090
再次，你没有看到我重新编译你

00:32:20.230 --> 00:32:24.760
知道我要做的就是说没有

00:32:22.090 --> 00:32:26.920
重建重建重新启动非常好

00:32:24.760 --> 00:32:29.770
自然流向发展

00:32:26.920 --> 00:32:33.420
现在，因为我们正在拨打远程电话

00:32:29.770 --> 00:32:35.890
我们将增加一些容错能力

00:32:33.420 --> 00:32:38.650
支持我们的应用程序，怎么办

00:32:35.890 --> 00:32:41.800
如果服务水平低，我们会处理失败

00:32:38.650 --> 00:32:44.800
碰巧掉下来，所以实际上我们甚至

00:32:41.800 --> 00:32:46.929
让我们这样做，实际上不

00:32:44.800 --> 00:32:48.580
我待会再做

00:32:46.929 --> 00:32:50.590
我们必须处理错误的策略

00:32:48.580 --> 00:32:53.470
宽容我可以用

00:32:50.590 --> 00:32:57.070
异步注释并运行方法

00:32:53.470 --> 00:32:59.380
在我可以使用的其他线程中调用

00:32:57.070 --> 00:33:02.500
基本上限制了

00:32:59.380 --> 00:33:03.970
并发访问次数

00:33:02.500 --> 00:33:06.550
资源，这样您就不会

00:33:03.970 --> 00:33:08.410
电路过载使很多

00:33:06.550 --> 00:33:12.130
你可能知道那是什么，但是

00:33:08.410 --> 00:33:15.220
基本上让您快速失败，它会

00:33:12.130 --> 00:33:18.400
偶尔检查远程服务以

00:33:15.220 --> 00:33:20.020
看看是否上升，然后上升

00:33:18.400 --> 00:33:22.750
将调用它，如果不是，它将

00:33:20.020 --> 00:33:25.330
可能会进行回退，这就是

00:33:22.750 --> 00:33:27.970
下一个注释，所以如果您要

00:33:25.330 --> 00:33:28.480
方法调用，而该方法恰好

00:33:27.970 --> 00:33:30.280
失败

00:33:28.480 --> 00:33:32.350
您可以提供替代逻辑

00:33:30.280 --> 00:33:36.179
我将显示的后备注释

00:33:32.350 --> 00:33:40.480
如果您碰巧失败了

00:33:36.179 --> 00:33:43.330
您还可以将重试逻辑与

00:33:40.480 --> 00:33:44.470
重试注释，有些人可能认为是

00:33:43.330 --> 00:33:46.210
反模式，但

00:33:44.470 --> 00:33:48.520
如果您的网络不稳定，则可能

00:33:46.210 --> 00:33:50.890
其实有点方便，然后

00:33:48.520 --> 00:33:55.020
最后一个是超时，如果你想

00:33:50.890 --> 00:33:57.640
确保您提供响应

00:33:55.020 --> 00:34:00.240
很好地回应您对您的

00:33:57.640 --> 00:34:02.710
客户您可以限制时间

00:34:00.240 --> 00:34:04.750
您的远程呼叫可能会拨打，因此您可以

00:34:02.710 --> 00:34:06.450
设置它虽然会抛出超时

00:34:04.750 --> 00:34:10.480
如果超过某个阈值，则为异常

00:34:06.450 --> 00:34:13.570
所以我要在这里做的是

00:34:10.480 --> 00:34:15.660
我想接这个电话

00:34:13.570 --> 00:34:18.370
在这一点上，我可以摆脱

00:34:15.660 --> 00:34:20.950
那个大你的终点

00:34:18.370 --> 00:34:23.290
 jax-rs端点，只是简单地

00:34:20.950 --> 00:34:25.450
方法调用以及我们要做的事情

00:34:23.290 --> 00:34:30.370
是我们将基本上使它成为

00:34:25.450 --> 00:34:32.919
超时和一定时间后

00:34:30.370 --> 00:34:37.240
时间，如果我们没有回应，那么

00:34:32.919 --> 00:34:40.750
它会超时返回

00:34:37.240 --> 00:34:43.530
好的，让我们在这里看看

00:34:40.750 --> 00:34:46.450
想我现在需要导入

00:34:43.530 --> 00:34:49.960
我可以提供两个参数

00:34:46.450 --> 00:34:51.190
是单位，所以我只是时间单位

00:34:49.960 --> 00:34:56.470
将其保留为默认值

00:34:51.190 --> 00:34:58.000
毫秒，也要等到

00:34:56.470 --> 00:34:59.200
默认需要一秒钟2,000 

00:34:58.000 --> 00:35:03.360
毫秒，但我们只做这个

00:34:59.200 --> 00:35:06.910
简短一点，我们会说它有什么价值

00:35:03.360 --> 00:35:08.080
等于半毫秒，所以

00:35:06.910 --> 00:35:11.200
半分钟后将要超时

00:35:08.080 --> 00:35:17.170
毫秒，我们还将提供

00:35:11.200 --> 00:35:20.410
后备方法，所以如果此方法

00:35:17.170 --> 00:35:22.450
由于某些异常而失败

00:35:20.410 --> 00:35:25.210
那我们要做的就是提供一些

00:35:22.450 --> 00:35:27.100
后备逻辑，所以我们要做的是

00:35:25.210 --> 00:35:27.970
指定要使用的备用方法

00:35:27.100 --> 00:35:32.850
打个招呼吧

00:35:27.970 --> 00:35:34.970
现在回去好吗

00:35:32.850 --> 00:35:40.020
要做的是提供后备方法

00:35:34.970 --> 00:35:42.780
哎呀，对不起，去这里， 

00:35:40.020 --> 00:35:44.520
说公开和后备方法只是

00:35:42.780 --> 00:35:46.770
必须具有与以下方法相同的方法签名

00:35:44.520 --> 00:35:49.230
后备注释的方法

00:35:46.770 --> 00:35:53.010
是在公开穿线，我们要

00:35:49.230 --> 00:35:54.750
叫你好后备，它必须

00:35:53.010 --> 00:36:01.340
返回一个字符串好吧，我要

00:35:54.750 --> 00:36:07.080
返回，这是“怀疑之火”，我们去了

00:36:01.340 --> 00:36:15.120
所以我现在要重新运行

00:36:07.080 --> 00:36:20.280
申请并在这里等一下啊

00:36:15.120 --> 00:36:21.810
我忘了做些让我切换的事情

00:36:20.280 --> 00:36:26.940
齿轮这里真的很快，我要添加一个

00:36:21.810 --> 00:36:28.140
一点点的JPA逻辑首先像

00:36:26.940 --> 00:36:29.580
实际上我应该做吗

00:36:28.140 --> 00:36:30.810
这样生活的问题

00:36:29.580 --> 00:36:33.810
编码有很多不同的路径

00:36:30.810 --> 00:36:39.090
你可以拿嗯，实际上不，我们只是

00:36:33.810 --> 00:36:44.010
我猜是这样的

00:36:39.090 --> 00:36:45.960
哦，我摘掉了终点，让我们

00:36:44.010 --> 00:36:53.220
用这种方式做到这一点，我们将很快添加

00:36:45.960 --> 00:36:57.900
它回到它里面，那里有一条路

00:36:53.220 --> 00:37:04.580
走吧，哦，不，我只是作为唯一的角色

00:36:57.900 --> 00:37:04.580
认为我们需要没事，所以现在

00:37:09.110 --> 00:37:13.980
好吧，我在这里出故障了

00:37:12.090 --> 00:37:16.890
我打算做的一点

00:37:13.980 --> 00:37:20.040
所以我要回去再回去

00:37:16.890 --> 00:37:22.980
点餐，所以我们先来做一个JP 

00:37:20.040 --> 00:37:25.170
实体使用panache，然后我们

00:37:22.980 --> 00:37:30.060
实际上要依靠后备

00:37:25.170 --> 00:37:33.780
方法，所以让我们实际去吧

00:37:30.060 --> 00:37:37.290
创建一个新文件，我们将其称为

00:37:33.780 --> 00:37:39.860
人点Java还可以

00:37:37.290 --> 00:37:39.860
人

00:37:40.750 --> 00:37:46.030
我们可能会得到一个GPA实体，我在一个GP中

00:37:45.310 --> 00:37:48.010
实体

00:37:46.030 --> 00:37:50.230
它基本上是一个带注释的Java Bean 

00:37:48.010 --> 00:37:51.310
在很多方面都正确，但是我们

00:37:50.230 --> 00:37:55.810
我们要做的就是使用

00:37:51.310 --> 00:38:02.460
一种叫做panache的东西

00:37:55.810 --> 00:38:05.380
 Panache我们将扩展Panache 

00:38:02.460 --> 00:38:08.440
实体，由于某种原因我不是

00:38:05.380 --> 00:38:11.340
得到自动完成，所以让

00:38:08.440 --> 00:38:11.340
我回到我的手掌

00:38:11.490 --> 00:38:16.980
我在这里有松饼吗？ 

00:38:14.860 --> 00:38:16.980
上

00:38:20.970 --> 00:38:32.110
实体让我尝试去那里哦

00:38:25.210 --> 00:38:40.840
这样做会很好吗

00:38:32.110 --> 00:38:44.410
问题，我们将要导入

00:38:40.840 --> 00:38:45.550
 JPA实体现在可以得到一些

00:38:44.410 --> 00:38:47.200
真的很棒

00:38:45.550 --> 00:38:48.580
通常，您必须创建

00:38:47.200 --> 00:38:50.860
带有getter和setter的私有字段

00:38:48.580 --> 00:38:52.270
但是用煎饼你可以把它们做成

00:38:50.860 --> 00:38:56.790
公共领域，所以我们会想念一个

00:38:52.270 --> 00:39:00.390
公共字符串名称和公共整数年龄

00:38:56.790 --> 00:39:03.220
对的，我可以用JP注释这些

00:39:00.390 --> 00:39:04.540
像您在第一列中知道的注释

00:39:03.220 --> 00:39:07.300
可以放入休眠验证器

00:39:04.540 --> 00:39:11.170
约束等

00:39:07.300 --> 00:39:13.150
时间我不会那样做，但是

00:39:11.170 --> 00:39:15.370
这一点基本上是一个JPA 

00:39:13.150 --> 00:39:20.710
现在我们要做的就是去

00:39:15.370 --> 00:39:27.820
回到我们的代码，让我们提供一个新的

00:39:20.710 --> 00:39:29.560
方法get和at path我们会说list 

00:39:27.820 --> 00:39:37.200
全部列出所有实体

00:39:29.560 --> 00:39:37.200
数据库，我们将产生

00:39:39.900 --> 00:39:51.790
我认为这是输入错误的

00:39:43.540 --> 00:39:53.569
不，我生产的产品是

00:39:51.790 --> 00:40:01.200
错误的一位好先生

00:39:53.569 --> 00:40:08.390
产生我们坚持jax-rs的地方

00:40:01.200 --> 00:40:12.979
可以的媒体类型点的版本

00:40:08.390 --> 00:40:12.979
我们要归还杰森

00:40:14.599 --> 00:40:32.219
应用程序杰森，为什么我得到

00:40:23.809 --> 00:40:35.670
应用程序我有正确的媒体吗

00:40:32.219 --> 00:40:37.739
键入否，我出于某种原因不参加

00:40:35.670 --> 00:40:51.690
今天很难导入

00:40:37.739 --> 00:40:56.430
合适的包裹好吧，这里很黑

00:40:51.690 --> 00:41:00.420
来媒体类型，我们希望

00:40:56.430 --> 00:41:08.960
 Jason的jax-rs版本好了

00:41:00.420 --> 00:41:12.900
终于把它变成现在，我们要

00:41:08.960 --> 00:41:14.940
返回所有人员列表

00:41:12.900 --> 00:41:22.940
数据库，所以我们要返回

00:41:14.940 --> 00:41:26.700
让我们看看所有人的公开名单

00:41:22.940 --> 00:41:28.349
现在因为我们没有名字

00:41:26.700 --> 00:41:31.469
查询我们将使用一个不错的

00:41:28.349 --> 00:41:33.349
在panache基地的便利方法

00:41:31.469 --> 00:41:42.180
类称为

00:41:33.349 --> 00:41:44.219
人点找到好吧就是找到

00:41:42.180 --> 00:41:47.900
我们走了

00:41:44.219 --> 00:41:54.440
并将其作为实体列表返回

00:41:47.900 --> 00:42:00.719
现在我们要公开修复进口

00:41:54.440 --> 00:42:05.700
清单必须返回哦，我还没有回来

00:42:00.719 --> 00:42:13.770
现在那会很好

00:42:05.700 --> 00:42:16.260
尝试并实际到达终点列表

00:42:13.770 --> 00:42:19.980
全部都会失败，因为我们

00:42:16.260 --> 00:42:25.830
尚未定义我们的应用程序

00:42:19.980 --> 00:42:26.910
 JPA数据源的属性，因此

00:42:25.830 --> 00:42:27.960
我要做的就是在这里

00:42:26.910 --> 00:42:30.600
我要作弊一点

00:42:27.960 --> 00:42:33.810
要复制并粘贴好了吗

00:42:30.600 --> 00:42:35.550
我现在有一个发展

00:42:33.810 --> 00:42:39.480
我要谈的开发模式

00:42:35.550 --> 00:42:41.670
 H2在内存数据库和

00:42:39.480 --> 00:42:44.100
我们要谈的生产

00:42:41.670 --> 00:42:44.730
 Postgres现在这是该配置文件所在的位置

00:42:44.100 --> 00:42:48.690
进来

00:42:44.730 --> 00:42:50.880
所以如果您有Korkis 

00:42:48.690 --> 00:42:52.940
环境变量或属性集

00:42:50.880 --> 00:42:58.020
叫做Korkis和方形的轮廓

00:42:52.940 --> 00:42:59.760
然后实际上将利用该配置文件

00:42:58.020 --> 00:43:01.380
在这里命名并选择属性

00:42:59.760 --> 00:43:04.200
该配置文件名称正确，所以我指定了

00:43:01.380 --> 00:43:07.770
开发人员作为配置文件的权利，所以我前缀

00:43:04.200 --> 00:43:11.670
这些现在与开发人员简介

00:43:07.770 --> 00:43:16.020
让我们继续尝试这个，我

00:43:11.670 --> 00:43:20.510
仍然遇到错误，让我们在这里看到

00:43:16.020 --> 00:43:20.510
未指定数据库驱动程序

00:43:20.550 --> 00:43:38.600
我没有坚持开发，确保我设置了我的

00:43:26.970 --> 00:43:38.600
我的个人资料可能还可以，并且

00:43:40.550 --> 00:43:44.880
仍然有问题，因为我想知道

00:43:42.870 --> 00:43:49.950
如果我有h2数据库驱动程序

00:43:44.880 --> 00:43:52.110
手掌这是现场编码的问题

00:43:49.950 --> 00:43:55.470
使用实时编码没有h2是正确的

00:43:52.110 --> 00:43:56.940
现在你可能都在尖叫

00:43:55.470 --> 00:44:01.200
现在对我说你忘了

00:43:56.940 --> 00:44:03.810
没有指定对话驱动程序的内容

00:44:01.200 --> 00:44:04.860
通过Quercus数据库得知数据源不

00:44:03.810 --> 00:44:08.670
司机还好

00:44:04.860 --> 00:44:15.320
回去哦，我没有保存文件

00:44:08.670 --> 00:44:17.990
认为实际上还可以

00:44:15.320 --> 00:44:20.680
那没有用或者这实际上是

00:44:17.990 --> 00:44:20.680
很尴尬

00:44:28.510 --> 00:44:43.900
好，我已经保存了属性文件

00:44:33.250 --> 00:44:52.330
返回应该起作用的人列表为什么

00:44:43.900 --> 00:44:54.940
是不是工作得很好的人表

00:44:52.330 --> 00:44:58.800
找不到表人，因此

00:44:54.940 --> 00:44:58.800
表示我忘了在这里做些事

00:44:59.100 --> 00:45:07.000
忘了基本设置放置和创建

00:45:04.740 --> 00:45:07.960
所以没有数据库表，所以我们

00:45:07.000 --> 00:45:09.760
必须删除并创建数据库

00:45:07.960 --> 00:45:13.030
这就是问题所在

00:45:09.760 --> 00:45:14.890
对，所以我们现在就去工作了

00:45:13.030 --> 00:45:16.950
对此感到抱歉，但好事是

00:45:14.890 --> 00:45:20.410
我遇到了所有这些问题

00:45:16.950 --> 00:45:22.900
因为我的编码风格很差，但是我

00:45:20.410 --> 00:45:24.490
永远不需要重新启动，所以我猜

00:45:22.900 --> 00:45:29.680
你可能会说我实际上在失败

00:45:24.490 --> 00:45:31.750
快速，所以现在我们正在与

00:45:29.680 --> 00:45:35.890
数据库让我们做另一件事

00:45:31.750 --> 00:45:37.720
数据库，请确保我们可以

00:45:35.890 --> 00:45:44.200
添加一个人，所以现在我们要

00:45:37.720 --> 00:45:50.130
在后期使用，我们将要进行生产

00:45:44.200 --> 00:45:53.980
并消耗相邻数据类型和

00:45:50.130 --> 00:45:55.270
我们要去找公众人士

00:45:53.980 --> 00:45:58.480
要回报我们的人

00:45:55.270 --> 00:46:02.950
添加edie人，我们将成为

00:45:58.480 --> 00:46:04.360
现在添加一个人的方式

00:46:02.950 --> 00:46:06.700
你加上煎饼

00:46:04.360 --> 00:46:10.540
再次没有命名查询，也没有

00:46:06.700 --> 00:46:12.430
实体经理直接参与

00:46:10.540 --> 00:46:13.420
您编写的代码仅仅是我们的代码

00:46:12.430 --> 00:46:15.220
我们要做的就是打电话

00:46:13.420 --> 00:46:16.480
一个人点坚持方法

00:46:15.220 --> 00:46:18.850
从父类继承

00:46:16.480 --> 00:46:23.490
对，然后我们要返回

00:46:18.850 --> 00:46:25.150
那个人，很酷

00:46:23.490 --> 00:46:27.789
我要去看看

00:46:25.150 --> 00:46:34.510
代码，现在我要尝试的是

00:46:27.789 --> 00:46:36.880
做的实际上是添加一个人方法

00:46:34.510 --> 00:46:40.119
不能正常运行

00:46:36.880 --> 00:46:43.900
另一个错误得到哦，我忘了补充

00:46:40.119 --> 00:46:45.369
事务性的东西

00:46:43.900 --> 00:46:48.970
在交易中完成

00:46:45.369 --> 00:46:54.369
因为我们正在更新数据库， 

00:46:48.970 --> 00:46:54.910
我认为那可能是我的问题

00:46:54.369 --> 00:46:56.920
我们去

00:46:54.910 --> 00:46:58.690
所以您会注意到实际上

00:46:56.920 --> 00:47:01.839
正在为我创建一个ID 

00:46:58.690 --> 00:47:05.020
所以panache实际上提供了自动

00:47:01.839 --> 00:47:06.510
开箱即用生成ID 

00:47:05.020 --> 00:47:08.970
使用自己的策略

00:47:06.510 --> 00:47:13.930
也支持这一点

00:47:08.970 --> 00:47:19.000
好吧，请记住所有这些

00:47:13.930 --> 00:47:21.549
我们要做的是回到我们的代码

00:47:19.000 --> 00:47:23.559
我们将在这里添加另一种方法

00:47:21.549 --> 00:47:26.589
我们要说这一次我们得到了

00:47:23.559 --> 00:47:31.990
要找到一个特定的人，所以我们

00:47:26.589 --> 00:47:36.849
要指定ID，我们要

00:47:31.990 --> 00:47:41.140
播种大众，让我们看看我们要

00:47:36.849 --> 00:47:48.150
使它返回一个字符串，使人在

00:47:41.140 --> 00:47:53.589
每条路径，所以我们每条路径有两条

00:47:48.150 --> 00:47:58.779
 ID long ID我们要走了，所以我们

00:47:53.589 --> 00:48:05.079
然后要做的就是找到那个人

00:47:58.779 --> 00:48:06.309
通过ID进行查询的人

00:48:05.079 --> 00:48:10.660
实际上，使用Panache真的很容易

00:48:06.309 --> 00:48:12.849
只是说通过ID找到人点，我们

00:48:10.660 --> 00:48:14.109
要传递ID，我们将

00:48:12.849 --> 00:48:18.430
在这里返回一些东西，所以我们

00:48:14.109 --> 00:48:20.380
要返回的是一个字符串，但我们

00:48:18.430 --> 00:48:21.670
打算从

00:48:20.380 --> 00:48:24.029
从头开始，所以我们要打个招呼

00:48:21.670 --> 00:48:30.059
方法，所以我要和这个人打招呼

00:48:24.029 --> 00:48:34.390
加号和人名人名

00:48:30.059 --> 00:48:35.859
另外请记住，这是一个公共财产，但是

00:48:34.390 --> 00:48:37.569
如果他们是吸气剂，它将称为

00:48:35.859 --> 00:48:39.180
吸气剂，这真的很不错

00:48:37.569 --> 00:48:49.470
特征

00:48:39.180 --> 00:48:56.290
好吧，您是人点年龄加上

00:48:49.470 --> 00:48:57.940
岁，好，现在可以使用了

00:48:56.290 --> 00:49:00.010
你会发现如果我们真的尝试

00:48:57.940 --> 00:49:03.100
列出所有他们要去的人

00:49:00.010 --> 00:49:04.870
之所以消失是因为

00:49:03.100 --> 00:49:07.150
真的在幕后做

00:49:04.870 --> 00:49:09.820
删除类加载器，基本上

00:49:07.150 --> 00:49:11.710
从重新加载整个应用程序

00:49:09.820 --> 00:49:13.990
从头开始，所以内存中的任何内容都是

00:49:11.710 --> 00:49:15.550
迷失，除非你坚持到某个地方

00:49:13.990 --> 00:49:16.960
像数据库一样，所以我要去

00:49:15.550 --> 00:49:19.690
我要做的是实际发布

00:49:16.960 --> 00:49:21.730
这些人回来创造这些人

00:49:19.690 --> 00:49:26.230
现在，如果我真的想去

00:49:21.730 --> 00:49:27.670
只是列出一个人你会做什么

00:49:26.230 --> 00:49:31.150
看到这是说你好吗杜克

00:49:27.670 --> 00:49:33.730
二十五岁，现在，如果我们

00:49:31.150 --> 00:49:37.210
回到我们的后备逻辑吧

00:49:33.730 --> 00:49:38.770
我们要做的就是基本上要做一个

00:49:37.210 --> 00:49:43.870
如果出现问题，请回退

00:49:38.770 --> 00:49:48.370
拨打此人的电话

00:49:43.870 --> 00:49:51.250
我在找什么我们在这里走

00:49:48.370 --> 00:49:53.800
我们打个招呼吧，那会发生什么

00:49:51.250 --> 00:49:59.890
如果失败了，让我们找出答案，我

00:49:53.800 --> 00:50:02.530
我要回去倒班杀

00:49:59.890 --> 00:50:04.060
全部复制此项目的所有实例

00:50:02.530 --> 00:50:04.510
应用程序，所以现在我们什么都没有了， 

00:50:04.060 --> 00:50:06.850
跑步

00:50:04.510 --> 00:50:10.690
所以希望这次真的

00:50:06.850 --> 00:50:11.380
调用它这样做的后备逻辑

00:50:10.690 --> 00:50:16.810
太酷了

00:50:11.380 --> 00:50:19.750
好吧，如果我们想做些什么

00:50:16.810 --> 00:50:24.010
有关如何计算的其他逻辑

00:50:19.750 --> 00:50:26.080
很多时候此方法失败，然后

00:50:24.010 --> 00:50:28.810
能够查看该图和一个图形

00:50:26.080 --> 00:50:33.850
例如正确的仪表板，所以如果我们去

00:50:28.810 --> 00:50:39.700
回到我们的演示文稿微型

00:50:33.850 --> 00:50:42.550
个人资料也让我们看看我们在哪里

00:50:39.700 --> 00:50:45.390
在这里，微型配置文件指标与微

00:50:42.550 --> 00:50:47.770
我可以实际创建的个人资料指标

00:50:45.390 --> 00:50:50.260
我的应用程序中的自定义指标

00:50:47.770 --> 00:50:52.570
这使您对一些

00:50:50.260 --> 00:50:55.000
可用指标

00:50:52.570 --> 00:50:56.920
我要用的是那个柜台

00:50:55.000 --> 00:50:59.980
其中一些已通过微更改

00:50:56.920 --> 00:51:02.620
个人资料指标2.0，但现在我们

00:50:59.980 --> 00:51:04.060
使用我的个人资料指标1.1对，但是

00:51:02.620 --> 00:51:07.890
您可以从指标中获得什么

00:51:04.060 --> 00:51:10.660
是端点斜线指标，可以是

00:51:07.890 --> 00:51:16.030
例如被四拉

00:51:10.660 --> 00:51:17.530
普罗米修斯与您同在

00:51:16.030 --> 00:51:20.770
获得一些必需的基本指标

00:51:17.530 --> 00:51:23.440
由米卡（Mikah）进行个人资料，例如您知道

00:51:20.770 --> 00:51:25.210
一些供应商提供的CPU和内存

00:51:23.440 --> 00:51:26.980
供应商想要的特定指标

00:51:25.210 --> 00:51:30.130
提供那个，然后当然是你的

00:51:26.980 --> 00:51:34.150
正确的应用程序指标，让我们

00:51:30.130 --> 00:51:38.050
实际上尝试在此处添加指标

00:51:34.150 --> 00:51:40.300
我要做的就是看到这里来

00:51:38.050 --> 00:51:45.850
回到这里，我们将跟踪

00:51:40.300 --> 00:51:47.740
指标，我要在注入

00:51:45.850 --> 00:51:54.460
指标，我们将给出这个

00:51:47.740 --> 00:51:56.130
指标和名称您好号码失败

00:51:54.460 --> 00:52:00.130
有时hello方法失败， 

00:51:56.130 --> 00:52:04.170
我们将使它成为反击，所以

00:52:00.130 --> 00:52:07.240
让我们做一些自动导入

00:52:04.170 --> 00:52:09.070
每次方法我们都去那里

00:52:07.240 --> 00:52:11.050
如果您发现其中一些失败， 

00:52:09.070 --> 00:52:15.060
我们要增加计数器，所以我

00:52:11.050 --> 00:52:18.720
要说计数器增加对

00:52:15.060 --> 00:52:22.150
好吧，让我们再增加几个人

00:52:18.720 --> 00:52:25.060
因为记得我们重新加载了

00:52:22.150 --> 00:52:29.220
现在要再次添加我们的人

00:52:25.060 --> 00:52:29.220
要做的是击中指标端点

00:52:29.580 --> 00:52:39.010
让我们看看指标，这是

00:52:37.150 --> 00:52:41.970
默认为Prometheus格式，但您可以

00:52:39.010 --> 00:52:46.690
看到有一些特定于供应商的指标

00:52:41.970 --> 00:52:50.410
有一些基本指标是

00:52:46.690 --> 00:52:52.630
微型配置文件需要什么，现在又需要什么

00:52:50.410 --> 00:52:54.490
我要做的就是看我是否可以

00:52:52.630 --> 00:52:57.430
我要寻找我们的应用程序

00:52:54.490 --> 00:53:00.310
指标，然后您可以看到到目前为止

00:52:57.430 --> 00:53:01.830
它说它失败了零次，所以让我们

00:53:00.310 --> 00:53:03.650
再试一次

00:53:01.830 --> 00:53:07.940
它应该下降

00:53:03.650 --> 00:53:11.930
回来，只要我们得到这个人，就让我们

00:53:07.940 --> 00:53:13.460
大家好，现在回去数一下

00:53:11.930 --> 00:53:15.350
再次，你会发现它失败了

00:53:13.460 --> 00:53:17.450
三遍，现在我可以继续

00:53:15.350 --> 00:53:18.800
跟踪应用程序指标并创建

00:53:17.450 --> 00:53:21.860
用于在内部运行的动物仪表板

00:53:18.800 --> 00:53:25.280
 kubernetes和其他一切，我认为

00:53:21.860 --> 00:53:27.200
也许在这一点上，我们有几分钟

00:53:25.280 --> 00:53:29.620
离开，我不知道我是否有时间

00:53:27.200 --> 00:53:35.270
将其编译为本地二进制文件

00:53:29.620 --> 00:53:37.840
好吧，也许我会尝试，但是我必须做一个

00:53:35.270 --> 00:53:37.840
首先

00:53:38.740 --> 00:53:43.940
我要在这里更改端点

00:53:41.500 --> 00:53:46.810
因为当我们跑步时我忘了

00:53:43.940 --> 00:53:51.860
使其成为个人资料的一部分

00:53:46.810 --> 00:53:54.080
所以我们要做冒号8080斜线

00:53:51.860 --> 00:53:56.750
你好，当我们在里面跑

00:53:54.080 --> 00:53:57.890
 kubernetes服务的URL是

00:53:56.750 --> 00:54:00.350
会有所不同，因为我们不是

00:53:57.890 --> 00:54:04.670
通过外部网关

00:54:00.350 --> 00:54:05.900
外部代理，所以我们去了，所以我

00:54:04.670 --> 00:54:12.700
尝试将其编译为

00:54:05.900 --> 00:54:12.700
二进制文件，我们应该利用这些

00:54:13.330 --> 00:54:18.320
这样做时的数据库属性

00:54:16.370 --> 00:54:20.150
首先我要去做，也许我会去做

00:54:18.320 --> 00:54:24.740
在我忘记要走之前

00:54:20.150 --> 00:54:28.460
修改我的docker文件以确保

00:54:24.740 --> 00:54:35.860
我指定的和正确的

00:54:28.460 --> 00:54:38.300
配置文件等于产品，我们去了， 

00:54:35.860 --> 00:54:41.270
我们将其编译为本地

00:54:38.300 --> 00:54:43.580
通过指定本地二进制文件，但我们

00:54:41.270 --> 00:54:45.410
希望它在Linux容器中，所以我们

00:54:43.580 --> 00:54:47.750
必须将其编译为Linux二进制文件

00:54:45.410 --> 00:54:50.540
对，所以这条线对

00:54:47.750 --> 00:54:52.160
这基本上就是说将其构建为

00:54:50.540 --> 00:54:55.220
一个将成为Linux的docker镜像

00:54:52.160 --> 00:54:56.960
二进制好吧，这将需要

00:54:55.220 --> 00:55:00.470
也许比我们剩下的时间更多，但是

00:54:56.960 --> 00:55:07.910
我们要给它一个镜头Tanya我是

00:55:00.470 --> 00:55:10.369
不确定到目前为止我们如何处理质量检查

00:55:07.910 --> 00:55:13.609
看来你做的很完美

00:55:10.369 --> 00:55:16.099
白银求职者

00:55:13.609 --> 00:55:21.049
有关微轮廓或夸克的问题

00:55:16.099 --> 00:55:23.420
请输入他们的聊天内容，我

00:55:21.049 --> 00:55:25.430
对某些技术表示歉意

00:55:23.420 --> 00:55:26.539
一路上的困难不是真的

00:55:25.430 --> 00:55:28.779
我的生活编码好一点了

00:55:26.539 --> 00:55:28.779
比起那个来说

00:55:29.019 --> 00:55:33.920
因为声音传得很好

00:55:31.910 --> 00:55:37.789
因为我自己有问题

00:55:33.920 --> 00:55:39.920
但我认为这是一个问题

00:55:37.789 --> 00:55:45.710
仔细检查我的电缆调制解调器

00:55:39.920 --> 00:55:47.559
看起来还可以吧

00:55:45.710 --> 00:55:50.779
让我们看看这里

00:55:47.559 --> 00:55:54.109
也许我会告诉你一点

00:55:50.779 --> 00:55:58.670
如果要开始使用Korkis，如果

00:55:54.109 --> 00:56:01.190
您想开始使用Korkis go 

00:55:58.670 --> 00:56:02.750
夸克SiO有字面上的意思

00:56:01.190 --> 00:56:04.849
开始页面将带您

00:56:02.750 --> 00:56:09.079
通过我已经完成的一些步骤

00:56:04.849 --> 00:56:12.349
向您展示了有关创建您的

00:56:09.079 --> 00:56:13.700
您知道的第一个应用程序使用

00:56:12.349 --> 00:56:15.470
 Maven插件创建项目种类

00:56:13.700 --> 00:56:18.710
就像你看到的，我们在这里如何

00:56:15.470 --> 00:56:20.599
建立本机映像如何使用Maven 

00:56:18.710 --> 00:56:24.049
并且Gradle Gradle也受支持

00:56:20.599 --> 00:56:26.150
 Korkis实际上我会去

00:56:24.049 --> 00:56:28.940
扩展首先有很多很多

00:56:26.150 --> 00:56:30.769
像我提到的扩展

00:56:28.940 --> 00:56:33.410
您可以使用的各种功能

00:56:30.769 --> 00:56:37.549
如果您在JVM中运行，请与Korkis一起使用

00:56:33.410 --> 00:56:40.279
模式，您几乎可以使用任何Java 

00:56:37.549 --> 00:56:41.569
您要发布的库是何时

00:56:40.279 --> 00:56:43.430
如果您想编译成本机

00:56:41.569 --> 00:56:48.650
二进制文件，那么您可能会遇到一些

00:56:43.430 --> 00:56:50.960
问题就在您必须使用的地方

00:56:48.650 --> 00:56:53.990
 Quercus扩展或做一点

00:56:50.960 --> 00:56:56.289
额外的工作或使用框架

00:56:53.990 --> 00:56:58.700
提供本地支持的提供商

00:56:56.289 --> 00:57:01.400
本土发展

00:56:58.700 --> 00:57:03.200
所有这些都有指南

00:57:01.400 --> 00:57:06.289
 Korkis的功能有一个

00:57:03.200 --> 00:57:09.289
有关该特定功能的指南，如果

00:57:06.289 --> 00:57:11.240
您的组织内有代码

00:57:09.289 --> 00:57:14.480
和您自己的自定义框架，我们有一个

00:57:11.240 --> 00:57:16.160
如果你能很好地向你解释的家伙

00:57:14.480 --> 00:57:17.569
它不会编译为本地二进制文件

00:57:16.160 --> 00:57:21.079
开箱即用，您可以创建自己的

00:57:17.569 --> 00:57:21.680
自己的扩展，以便您的框架

00:57:21.079 --> 00:57:24.349
提供者

00:57:21.680 --> 00:57:27.020
在您的组织中可以使他们成为

00:57:24.349 --> 00:57:32.809
其他人可以使用的扩展名

00:57:27.020 --> 00:57:35.450
所以我们有指导您了解

00:57:32.809 --> 00:57:38.750
数据库操作有一个Mongo 

00:57:35.450 --> 00:57:42.800
扩展目前正在全部进行中

00:57:38.750 --> 00:57:44.960
各种网络样式扩展

00:57:42.800 --> 00:57:48.109
他们我向您展示了与Kafka的消息传递

00:57:44.960 --> 00:57:50.660
和微动响应消息

00:57:48.109 --> 00:57:54.290
个人资料反应式消息传递

00:57:50.660 --> 00:57:55.640
一些安全扩展，所以有

00:57:54.290 --> 00:57:56.900
我认为实际上有很多

00:57:55.640 --> 00:58:00.170
有些东西我们有骆驼

00:57:56.900 --> 00:58:02.990
这里的指南也让我们看看我们的

00:58:00.170 --> 00:58:09.319
编译在做哎呀，穿这个

00:58:02.990 --> 00:58:10.790
方式，而且还在建设，是的，我没有

00:58:09.319 --> 00:58:14.510
认为它会及时建立，所以它

00:58:10.790 --> 00:58:16.760
大约需要五分钟，但我要做一件事

00:58:14.510 --> 00:58:21.430
确实做到了，您可能会发现这种

00:58:16.760 --> 00:58:22.750
有趣的是我有点预先运行了

00:58:21.430 --> 00:58:27.230
另一个

00:58:22.750 --> 00:58:29.420
 openshift项目正确，所以如果我们去

00:58:27.230 --> 00:58:31.130
有点像我的备份项目

00:58:29.420 --> 00:58:33.619
看到我正在运行我有

00:58:31.130 --> 00:58:37.609
人员项目正在运行，实际上是什么

00:58:33.619 --> 00:58:40.010
很酷是因为Korkis非常高效

00:58:37.609 --> 00:58:43.970
只能运行大量的副本

00:58:40.010 --> 00:58:49.240
我现在就知道34 

00:58:43.970 --> 00:58:53.420
对于数据库，我将创建

00:58:49.240 --> 00:58:55.700
大概是我实际完成的六份拷贝

00:58:53.420 --> 00:58:58.010
我昨天做了这种测试

00:58:55.700 --> 00:59:01.010
我对此的限制

00:58:58.010 --> 00:59:04.130
我的机器和我有200份问候

00:59:01.010 --> 00:59:06.770
作为本机Java本地运行

00:59:04.130 --> 00:59:09.049
编译的Java应用程序以及25 

00:59:06.770 --> 00:59:10.460
人员项目的副本，以便您

00:59:09.049 --> 00:59:11.569
可以看到它按比例放大，所以

00:59:10.460 --> 00:59:13.760
实际上是从本地开始的

00:59:11.569 --> 00:59:17.599
超级编译的Java应用程序

00:59:13.760 --> 00:59:19.400
快速正确，然后我大约有一半

00:59:17.599 --> 00:59:24.170
分配给该虚拟机的CPU 

00:59:19.400 --> 00:59:26.089
机器，所以它实际上很酷， 

00:59:24.170 --> 00:59:26.569
我想我们处于最重要的位置

00:59:26.089 --> 00:59:28.369
小时

00:59:26.569 --> 00:59:31.730
对于某些技术问题，我深表歉意。 

00:59:28.369 --> 00:59:34.069
我遇到的困难我没有去

00:59:31.730 --> 00:59:35.749
向您展示微观状况

00:59:34.069 --> 00:59:39.200
支票

00:59:35.749 --> 00:59:41.660
等等，通过微型个人资料健康检查

00:59:39.200 --> 00:59:43.969
有能力暴露

00:59:41.660 --> 00:59:46.369
健康，轻松和准备

00:59:43.969 --> 00:59:48.380
您的应用程序到您的

00:59:46.369 --> 00:59:50.210
在这种情况下的环境kubernetes这样

00:59:48.380 --> 00:59:51.950
如果它看到的是不是

00:59:50.210 --> 00:59:54.799
生活会杀死你开始的波特

00:59:51.950 --> 00:59:57.109
对的，如果锅还没准备好，就不会

00:59:54.799 --> 00:59:59.690
将流量引向该站点，因此很快

00:59:57.109 --> 01:00:02.359
再次简要描述微状况健康

00:59:59.690 --> 01:00:03.920
对不起，技术上的困难

01:00:02.359 --> 01:00:06.259
无论练习多少次

01:00:03.920 --> 01:00:09.349
相信我，我一直在那里

01:00:06.259 --> 01:00:11.180
是问题Tanya，我不知道是否有

01:00:09.349 --> 01:00:19.640
你的任何接近的结束语

01:00:11.180 --> 01:00:23.210
我想补充一点好吧，我想我们

01:00:19.640 --> 01:00:27.950
我想我们似乎在这里完成了

01:00:23.210 --> 01:00:29.930
失去了Tanya，我想我们

01:00:27.950 --> 01:00:32.180
还是在录音吗

01:00:29.930 --> 01:00:35.359
谢谢大家的加入，我深表歉意

01:00:32.180 --> 01:00:38.779
你可以在克林贡边缘找到我

01:00:35.359 --> 01:00:40.430
 Twitter，尽管我有点

01:00:38.779 --> 01:00:42.739
为我遇到的一些问题感到尴尬

01:00:40.430 --> 01:00:44.890
碰到了，所以很好，谢谢

01:00:42.739 --> 01:00:44.890
再见

