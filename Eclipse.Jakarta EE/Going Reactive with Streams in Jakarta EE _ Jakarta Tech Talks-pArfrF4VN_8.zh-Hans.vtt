WEBVTT
Kind: captions
Language: zh-Hans

00:00:04.380 --> 00:00:10.980
好吧，我想我们正在开始

00:00:12.389 --> 00:00:15.389
现场直播

00:00:25.140 --> 00:00:31.290
好吧，让我在这里设置一下

00:00:28.210 --> 00:00:37.150
给我一点时间

00:00:31.290 --> 00:00:40.329
好吧，嗯，欢迎没有见到的每个人

00:00:37.150 --> 00:00:43.420
有多少人参加了

00:00:40.329 --> 00:00:48.519
希望你能听到我的声音

00:00:43.420 --> 00:00:52.480
克里奥尔语清楚，我们正在第二次雅加达

00:00:48.519 --> 00:00:57.720
这次与James Rapper进行技术交流

00:00:52.480 --> 00:01:00.460
他将和我们谈谈

00:00:57.720 --> 00:01:05.890
与...反应

00:01:00.460 --> 00:01:08.229
流在雅加达EE中，所以詹姆斯

00:01:05.890 --> 00:01:15.729
想要接管分享您的屏幕

00:01:08.229 --> 00:01:17.650
并且开始现在是完美的

00:01:15.729 --> 00:01:22.380
对于每个人，请随时使用

00:01:17.650 --> 00:01:24.729
詹姆斯讲完后，我们聊聊

00:01:22.380 --> 00:01:28.020
一切都充满疑问和

00:01:24.729 --> 00:01:35.049
答案，我相信我们会很高兴

00:01:28.020 --> 00:01:40.240
回答您的问题好吧，谢谢

00:01:35.049 --> 00:01:42.219
因为我的名字叫詹姆斯·罗塔，如果

00:01:40.240 --> 00:01:43.630
你在东海岸，我了解

00:01:42.219 --> 00:01:46.509
下午，如果你在西边

00:01:43.630 --> 00:01:48.939
如果您在欧洲，请在早晨到海岸

00:01:46.509 --> 00:01:52.960
可能是晚上很晚，如果

00:01:48.939 --> 00:01:54.579
你就是我在澳大利亚的地方

00:01:52.960 --> 00:01:58.840
建议去外面看

00:01:54.579 --> 00:02:01.920
日出，您听到了这次网络研讨会，所以我

00:01:58.840 --> 00:02:04.479
在一家名为Light Bend的公司工作

00:02:01.920 --> 00:02:06.939
学者计划背后的公司

00:02:04.479 --> 00:02:11.890
在我们的克尔戏剧背后的语言之间

00:02:06.939 --> 00:02:15.600
框架和登录，我的角色是

00:02:11.890 --> 00:02:19.209
开源软件架构

00:02:15.600 --> 00:02:22.060
今天我们将要看一些

00:02:19.209 --> 00:02:26.910
即将发布的反应规范

00:02:22.060 --> 00:02:29.620
雅加达AE专门针对一些

00:02:26.910 --> 00:02:33.220
都完成的规格

00:02:29.620 --> 00:02:36.069
以及进行中和我的个人资料

00:02:33.220 --> 00:02:37.600
希望最终将被采纳

00:02:36.069 --> 00:02:43.390
雅加达AE和可以

00:02:37.600 --> 00:02:52.120
在流行的Jakarta AE或Java EE中使用

00:02:43.390 --> 00:02:53.890
今天的应用服务第一

00:02:52.120 --> 00:02:55.690
我们要看的是什么

00:02:53.890 --> 00:02:57.820
真的很活跃，当我们

00:02:55.690 --> 00:03:00.880
说我们要带动反应

00:02:57.820 --> 00:03:03.060
雅加达AE，我们接下来要看

00:03:00.880 --> 00:03:07.000
什么是反应性流

00:03:03.060 --> 00:03:12.100
特定的做事技术

00:03:07.000 --> 00:03:15.180
反应式编程，我们将

00:03:12.100 --> 00:03:18.010
看看到底是怎么使用的

00:03:15.180 --> 00:03:26.100
一些完整的规格和一些

00:03:18.010 --> 00:03:30.940
进度规范，所以现在有什么反应

00:03:26.100 --> 00:03:33.340
当很多人反应过来时

00:03:30.940 --> 00:03:39.870
要记住很多人会

00:03:33.340 --> 00:03:42.990
我想我最终还是这样

00:03:39.870 --> 00:03:45.730
完成阶段和可完成的未来

00:03:42.990 --> 00:03:46.470
如果您听说过反应式的话

00:03:45.730 --> 00:03:49.060
流

00:03:46.470 --> 00:03:52.210
异步处理高级Acing 

00:03:49.060 --> 00:03:54.520
这种背压也许是Java 

00:03:52.210 --> 00:03:55.950
您是IRAP的眼睛， 

00:03:54.520 --> 00:03:59.500
 I / O的异步事件

00:03:55.950 --> 00:04:03.130
能力在那里，你会

00:03:59.500 --> 00:04:08.770
对，如果你认为那是

00:04:03.130 --> 00:04:12.160
反应性的，因为这只是一个问题

00:04:08.770 --> 00:04:16.480
我们今天说的是

00:04:12.160 --> 00:04:20.320
停下来，他们说事件驱动

00:04:16.480 --> 00:04:22.660
 IO都是反应性的，那不是

00:04:20.320 --> 00:04:25.660
真正的反应性在很大程度上

00:04:22.660 --> 00:04:27.940
事实上，如果您只是停止在事件驱动下

00:04:25.660 --> 00:04:29.860
 IO，您实际上并没有获得太多价值

00:04:27.940 --> 00:04:31.690
所有您可能使用的

00:04:29.860 --> 00:04:34.390
硬件更好一些

00:04:31.690 --> 00:04:38.770
反应性报价的潜力如此之大

00:04:34.390 --> 00:04:40.930
更具反应性的是

00:04:38.770 --> 00:04:44.410
建筑的建筑图案

00:04:40.930 --> 00:04:47.590
反应灵敏的系统

00:04:44.410 --> 00:04:50.950
响应式意味着您去

00:04:47.590 --> 00:04:51.430
系统，不管是什么

00:04:50.950 --> 00:04:53.860
发生

00:04:51.430 --> 00:04:57.340
系统应该给你答案

00:04:53.860 --> 00:05:00.570
它应该在合理的范围内工作

00:04:57.340 --> 00:05:03.700
时间框架并为了实现这一目标

00:05:00.570 --> 00:05:05.380
它需要有弹性，所以如果有

00:05:03.700 --> 00:05:06.730
组件中的故障

00:05:05.380 --> 00:05:08.920
系统不应该带来整体

00:05:06.730 --> 00:05:11.230
系统关闭它应该能够

00:05:08.920 --> 00:05:15.460
即使出现故障也可以继续工作

00:05:11.230 --> 00:05:18.430
发生，其次也是

00:05:15.460 --> 00:05:20.980
响应性，它既需要扩展，又需要扩展

00:05:18.430 --> 00:05:25.210
上下，因为我们不想

00:05:20.980 --> 00:05:30.730
能够成为一个人是不好的

00:05:25.210 --> 00:05:32.860
有100100台计算机正在运行一个系统

00:05:30.730 --> 00:05:38.050
一年只需要一天

00:05:32.860 --> 00:05:42.060
这些就是这些的特性

00:05:38.050 --> 00:05:47.040
弹性和可扩展性强调

00:05:42.060 --> 00:05:49.890
什么是反应系统？ 

00:05:47.040 --> 00:05:52.660
缓解那些反应式的租户

00:05:49.890 --> 00:05:57.190
非常适合解决

00:05:52.660 --> 00:05:59.620
云原生系统的挑战

00:05:57.190 --> 00:06:01.920
如果你不知道那里

00:05:59.620 --> 00:06:05.200
所谓的反应性宣言

00:06:01.920 --> 00:06:08.170
非常简洁明了

00:06:05.200 --> 00:06:11.890
总结什么是反应性及其原因

00:06:08.170 --> 00:06:15.130
需要，以便您可以访问该WWWE active 

00:06:11.890 --> 00:06:19.210
您自己的时间里的宣言器官

00:06:15.130 --> 00:06:21.970
您希望如此，让我们看一下其中的一些

00:06:19.210 --> 00:06:24.490
云中的挑战

00:06:21.970 --> 00:06:29.470
反应性寻求的本机计算

00:06:24.490 --> 00:06:34.900
本身就是一个本地人

00:06:29.470 --> 00:06:36.820
机会，当我们

00:06:34.900 --> 00:06:45.520
与仅运行相比，上云

00:06:36.820 --> 00:06:48.250
在我们自己的服务器上是他的非常非常

00:06:45.520 --> 00:06:51.940
广泛，但同时也引入了许多

00:06:48.250 --> 00:06:53.710
挑战，所以我不会说话

00:06:51.940 --> 00:06:56.410
关于所有挑战，但有些挑战

00:06:53.710 --> 00:06:58.210
例子是当你去云端

00:06:56.410 --> 00:07:01.660
并且您正在运行微服务

00:06:58.210 --> 00:07:04.260
没有一个数据库好，并且

00:07:01.660 --> 00:07:06.870
因为你没有一个数据库

00:07:04.260 --> 00:07:09.810
你没有酸交易

00:07:06.870 --> 00:07:12.240
爸爸现在只有你的全球状态

00:07:09.810 --> 00:07:13.470
可能会提供您的每项服务

00:07:12.240 --> 00:07:15.360
你在跑步可能有它自己的

00:07:13.470 --> 00:07:17.100
数据库，在该数据库中，您

00:07:15.360 --> 00:07:20.880
没有酸交易

00:07:17.100 --> 00:07:23.760
更新，但因为您有多个

00:07:20.880 --> 00:07:26.190
需要更新时的数据库

00:07:23.760 --> 00:07:28.680
多种服务是没有办法做的

00:07:26.190 --> 00:07:31.170
以原子的方式，你没有

00:07:28.680 --> 00:07:34.590
您所有的酸交易

00:07:31.170 --> 00:07:39.570
服务，所以一致性不可能

00:07:34.590 --> 00:07:42.270
不再理所当然

00:07:39.570 --> 00:07:44.520
挑战是因为你有

00:07:42.270 --> 00:07:46.800
提供更多服务的更多网络

00:07:44.520 --> 00:07:49.230
和沟通，您将获得更多

00:07:46.800 --> 00:07:52.020
部署配置还有更多

00:07:49.230 --> 00:07:56.300
运动部件，所以还有更多

00:07:52.020 --> 00:07:59.550
您可能会出错，因此

00:07:56.300 --> 00:08:02.130
云原生系统本质上更多

00:07:59.550 --> 00:08:04.050
脆弱，它们本来就更容易

00:08:02.130 --> 00:08:07.770
失败现在人们经常谈论

00:08:04.050 --> 00:08:12.240
去云，因为你已经

00:08:07.770 --> 00:08:14.460
有那么多机器可以建造

00:08:12.240 --> 00:08:16.250
更具弹性的应用程序，但是

00:08:14.460 --> 00:08:20.850
不会自动发生

00:08:16.250 --> 00:08:22.560
如果您不仔细设计和使用

00:08:20.850 --> 00:08:24.600
可以让你采取的模式

00:08:22.560 --> 00:08:26.940
这些机器的优势

00:08:24.600 --> 00:08:28.470
永无止境的更具弹性的系统

00:08:26.940 --> 00:08:30.720
有了更具弹性的系统，您将

00:08:28.470 --> 00:08:35.570
最终导致系统更加脆弱

00:08:30.720 --> 00:08:35.570
比典型的传统巨石

00:08:37.130 --> 00:08:45.090
 clamo确实为

00:08:40.260 --> 00:08:47.010
在最常见的云上扩展

00:08:45.090 --> 00:08:51.690
资源至少与您相比

00:08:47.010 --> 00:08:54.230
通常需要看似无尽的东西，但是这些

00:08:51.690 --> 00:08:56.970
但也不会发生缩放

00:08:54.230 --> 00:09:00.600
自动如何

00:08:56.970 --> 00:09:02.790
如果你只是应用你的水平

00:09:00.600 --> 00:09:05.010
您使用的正常模式

00:09:02.790 --> 00:09:08.060
巨石，你会发现你遇到

00:09:05.010 --> 00:09:08.060
瓶颈很快

00:09:12.400 --> 00:09:17.480
所以我只概述几个

00:09:15.170 --> 00:09:20.570
反应性原理有

00:09:17.480 --> 00:09:25.660
反应性远大于此，但

00:09:20.570 --> 00:09:29.540
反应性的几个原则

00:09:25.660 --> 00:09:31.430
设计我们的反应系统

00:09:29.540 --> 00:09:32.990
在我们构建活动系统时使用

00:09:31.430 --> 00:09:36.410
有助于解决其中一些问题

00:09:32.990 --> 00:09:39.830
挑战最大

00:09:36.410 --> 00:09:43.880
反应原理是隔离

00:09:39.830 --> 00:09:46.640
服务，当我们说孤立时，我们的意思是

00:09:43.880 --> 00:09:50.300
确保这些服务不能

00:09:46.640 --> 00:09:53.290
互相影响，让我们

00:09:50.300 --> 00:09:55.970
看一下HTTP通讯

00:09:53.290 --> 00:10:00.980
在构建微型计算机时非常常见

00:09:55.970 --> 00:10:03.980
云中的服务以使用HTTP G RPC 

00:10:00.980 --> 00:10:07.400
也变得普遍，但是这些

00:10:03.980 --> 00:10:09.340
协议本质上是同步的

00:10:07.400 --> 00:10:13.280
不管你在用

00:10:09.340 --> 00:10:15.860
异步I / O，您仍在执行

00:10:13.280 --> 00:10:17.360
在远程系统上的请求

00:10:15.860 --> 00:10:19.400
响应，如果该系统不是

00:10:17.360 --> 00:10:22.070
在没有的时候运行

00:10:19.400 --> 00:10:23.450
如果没有响应您可用

00:10:22.070 --> 00:10:28.220
将无法继续您的

00:10:23.450 --> 00:10:30.410
操作，因此HTTP取决于两者

00:10:28.220 --> 00:10:34.940
沟通中涉及的服务

00:10:30.410 --> 00:10:37.760
反应灵敏，这提供了一个

00:10:34.940 --> 00:10:40.610
充分脆弱的机会，因为

00:10:37.760 --> 00:10:43.400
其中一项服务发生故障，然后

00:10:40.610 --> 00:10:46.640
有效地两种服务都无法解决

00:10:43.400 --> 00:10:49.220
实现您需要的操作

00:10:46.640 --> 00:10:51.680
如果您使用HTTP进行通讯

00:10:49.220 --> 00:10:54.260
他们之间，如果你

00:10:51.680 --> 00:10:58.130
开始涉及越来越多的服务

00:10:54.260 --> 00:11:00.530
因为每个具有

00:10:58.130 --> 00:11:03.650
完成HTTP调用即可正常工作

00:11:00.530 --> 00:11:08.270
顺序或传递要

00:11:03.650 --> 00:11:12.110
影响整体的可用性

00:11:08.270 --> 00:11:14.060
系统，因此当您将HTTP用于

00:11:12.110 --> 00:11:18.650
您不需要的服务之间的通信

00:11:14.060 --> 00:11:23.230
有隔离好吗HTTP不是

00:11:18.650 --> 00:11:23.230
反应性建筑原理

00:11:24.660 --> 00:11:30.310
所以您可能会认为我们将使用

00:11:27.100 --> 00:11:32.350
消息代理之间进行通信

00:11:30.310 --> 00:11:34.360
服务，那是很好的

00:11:32.350 --> 00:11:36.189
理念

00:11:34.360 --> 00:11:39.189
所以你可能会成为你的一部分

00:11:36.189 --> 00:11:41.560
操作，您可能会更新一些状态

00:11:39.189 --> 00:11:45.759
您的本地数据库，然后发布一个

00:11:41.560 --> 00:11:48.399
给消息经纪人的消息

00:11:45.759 --> 00:11:50.680
这里仍然是一个依赖，因为这意味着

00:11:48.399 --> 00:11:54.730
试图完成的服务

00:11:50.680 --> 00:11:57.730
该操作必须在

00:11:54.730 --> 00:12:00.430
同时是消息代理，如果

00:11:57.730 --> 00:12:02.259
例如服务不

00:12:00.430 --> 00:12:04.449
操作，然后尝试发布

00:12:02.259 --> 00:12:07.149
消息给消息代理和

00:12:04.449 --> 00:12:09.069
然后，消息代理没有响应

00:12:07.149 --> 00:12:11.410
该操作只会

00:12:09.069 --> 00:12:13.660
部分完成您的订单

00:12:11.410 --> 00:12:15.069
碰巧这样做可能是因为您禁用了

00:12:13.660 --> 00:12:17.079
 CalPERS尚未发布消息

00:12:15.069 --> 00:12:19.209
经纪人，然后提交我的

00:12:17.079 --> 00:12:21.490
交易，让我们说这

00:12:19.209 --> 00:12:25.029
发布到消息代理成功

00:12:21.490 --> 00:12:26.829
但是然后你你的数据库事务

00:12:25.029 --> 00:12:30.610
失败了，那么你仍然有一个

00:12:26.829 --> 00:12:33.279
部分完成操作，所以

00:12:30.610 --> 00:12:35.290
更好，因为通常更容易

00:12:33.279 --> 00:12:37.959
保持像

00:12:35.290 --> 00:12:43.720
消息代理可用，但您仍然

00:12:37.959 --> 00:12:45.579
那里没有完全隔离

00:12:43.720 --> 00:12:50.139
我们真正想要尝试做的是

00:12:45.579 --> 00:12:54.250
使所有操作异步进行，并且

00:12:50.139 --> 00:12:57.009
这是使用CQRS完成的，因此，如果可以

00:12:54.250 --> 00:12:59.079
分开您的命令，使事情

00:12:57.009 --> 00:13:01.800
进来并更新您的本地舞台

00:12:59.079 --> 00:13:05.699
从查询中，其中包括

00:13:01.800 --> 00:13:09.370
将消息发布到消息代理

00:13:05.699 --> 00:13:10.809
那你就没有依赖性了

00:13:09.370 --> 00:13:13.389
之间的任何响应

00:13:10.809 --> 00:13:15.160
组件，您完全失败

00:13:13.389 --> 00:13:18.490
孤立地扩展并能够

00:13:15.160 --> 00:13:25.360
充分利用您的云

00:13:18.490 --> 00:13:28.089
本机平台第二个原则

00:13:25.360 --> 00:13:32.429
我想谈的是采用

00:13:28.089 --> 00:13:32.429
管理故障的编程模型

00:13:40.000 --> 00:13:49.520
所以在传统系统中

00:13:43.990 --> 00:13:51.200
也许运行Java aa或不酸

00:13:49.520 --> 00:13:54.620
交易在那里处理失败

00:13:51.200 --> 00:13:56.450
对您来说，开发人员不需要

00:13:54.620 --> 00:13:58.310
明确处理所有失败

00:13:56.450 --> 00:14:00.260
他们不需要预期的条件

00:13:58.310 --> 00:14:02.120
所有的可能性，如果发生

00:14:00.260 --> 00:14:05.570
其他东西试图在更新

00:14:02.120 --> 00:14:07.280
在同一时间，如果我的

00:14:05.570 --> 00:14:12.830
服务或数据库故障

00:14:07.280 --> 00:14:15.260
中途他们不必担心

00:14:12.830 --> 00:14:17.030
关于我需要怎样清洁

00:14:15.260 --> 00:14:20.140
如果出现故障，则向上

00:14:17.030 --> 00:14:25.700
我需要什么补偿措施

00:14:20.140 --> 00:14:28.670
我需要重试交易吗

00:14:25.700 --> 00:14:31.940
为您处理，但正如我们所说

00:14:28.670 --> 00:14:33.740
以前在云原生系统中我们不

00:14:31.940 --> 00:14:36.050
在系统中进行资产交易

00:14:33.740 --> 00:14:37.730
水平，所以我们需要的那一刻

00:14:36.050 --> 00:14:40.940
进行涉及多个的更新

00:14:37.730 --> 00:14:45.110
服务，我们不再拥有任何

00:14:40.940 --> 00:14:46.610
经理对我们失败，但我们确实想要

00:14:45.110 --> 00:14:49.100
对我们来说更重要的事情

00:14:46.610 --> 00:14:51.740
因为我们不想

00:14:49.100 --> 00:14:53.600
手动实施所有

00:14:51.740 --> 00:14:58.550
失效条件的排列

00:14:53.600 --> 00:15:01.370
可能会发生，所以我们需要一个不同的

00:14:58.550 --> 00:15:04.580
管理失败的模式之一

00:15:01.370 --> 00:15:06.920
不是我们可以接受的手册

00:15:04.580 --> 00:15:09.910
理所当然地，我们可以专注于解决

00:15:06.920 --> 00:15:09.910
我们的业务问题

00:15:29.660 --> 00:15:38.520
所以我可能觉得我有一个问题

00:15:32.460 --> 00:15:41.460
我的头在那里，先生流有一个

00:15:38.520 --> 00:15:50.190
云天然酸当量

00:15:41.460 --> 00:15:52.530
流中的交易是

00:15:50.190 --> 00:15:55.830
我们可以用来的建筑模式

00:15:52.530 --> 00:16:01.640
不用担心失败

00:15:55.830 --> 00:16:04.530
不再，所以让我们来看看

00:16:01.640 --> 00:16:07.830
您可能听说过的反应性流

00:16:04.530 --> 00:16:11.430
是一种刮擦

00:16:07.830 --> 00:16:13.050
来自

00:16:11.430 --> 00:16:15.770
编程角度，然后结束

00:16:13.050 --> 00:16:18.320
从系统架构的角度

00:16:15.770 --> 00:16:20.670
在高水平

00:16:18.320 --> 00:16:24.180
反应性流提供了一种声明性方式

00:16:20.670 --> 00:16:26.190
描述要完成的工作，这是一个

00:16:24.180 --> 00:16:28.920
描述性的工作描述方式是

00:16:26.190 --> 00:16:31.800
重要，因为您不想

00:16:28.920 --> 00:16:34.350
这样做是在说我要去

00:16:31.800 --> 00:16:35.730
示例阅读一些消息，然后我

00:16:34.350 --> 00:16:38.790
要处理它，然后我要去

00:16:35.730 --> 00:16:41.850
在这里发送消息，因为如果你

00:16:38.790 --> 00:16:43.740
控制什么的那个

00:16:41.850 --> 00:16:46.830
什么时候做，那么你还必须

00:16:43.740 --> 00:16:48.540
处理失败，而不管你什么

00:16:46.830 --> 00:16:50.490
你只想做的就是在这里声明好

00:16:48.540 --> 00:16:54.800
是我对这些消息的处理， 

00:16:50.490 --> 00:16:57.960
我想放开基础设施

00:16:54.800 --> 00:17:03.570
处理生命周期和失败， 

00:16:57.960 --> 00:17:05.760
重试并分发给我

00:17:03.570 --> 00:17:08.250
因为当我们去云端时

00:17:05.760 --> 00:17:14.850
可能有很多机器，我们

00:17:08.250 --> 00:17:16.350
不想手动传播

00:17:14.850 --> 00:17:21.360
他们机器上的那个词

00:17:16.350 --> 00:17:25.320
我们自己的反应流提供

00:17:21.360 --> 00:17:28.470
异步处理事件，因此

00:17:25.320 --> 00:17:32.130
确保我们的效率

00:17:28.470 --> 00:17:34.500
如果我们可以运行很多资源

00:17:32.130 --> 00:17:36.830
一次流而不消耗很多

00:17:34.500 --> 00:17:36.830
线程数

00:17:37.710 --> 00:17:44.299
反应性流也传播

00:17:39.690 --> 00:17:48.620
背压和背压

00:17:44.299 --> 00:17:52.169
传播非常重要，因为

00:17:48.620 --> 00:17:53.760
没有背传播的背压

00:17:52.169 --> 00:17:55.980
没有下游的方法

00:17:53.760 --> 00:17:58.110
处理者或数据使用者

00:17:55.980 --> 00:18:00.630
推回上游流程，并

00:17:58.110 --> 00:18:04.140
说嘿我还没有准备好接收更多

00:18:00.630 --> 00:18:06.360
数据还可以，请您慢下来

00:18:04.140 --> 00:18:09.840
是在雅加达ae的一些api 

00:18:06.360 --> 00:18:12.360
提供异步处理的时刻

00:18:09.840 --> 00:18:14.370
没有这种压力的事件等等

00:18:12.360 --> 00:18:17.309
例如，websocket api没有

00:18:14.370 --> 00:18:20.399
回到WebSocket并说

00:18:17.309 --> 00:18:22.950
嘿，你真的可以推开

00:18:20.399 --> 00:18:24.419
 TCP连接以阻止客户端从

00:18:22.950 --> 00:18:26.669
给我丹尼，你必须处理

00:18:24.419 --> 00:18:29.480
全部，如果不能，他们会去吗

00:18:26.669 --> 00:18:38.760
耗尽内存，否则您将

00:18:29.480 --> 00:18:44.250
不知何故，或者你只是必须失败，所以在

00:18:38.760 --> 00:18:46.590
实现级别的反应流

00:18:44.250 --> 00:18:48.659
是一项规范工作， 

00:18:46.590 --> 00:18:50.850
由light Bend Netflix和

00:18:48.659 --> 00:18:54.450
关键和其他在2013 

00:18:50.850 --> 00:19:00.059
那是2013年，最初的接触和

00:18:54.450 --> 00:19:02.760
进行了讨论，然后在其中

00:19:00.059 --> 00:19:05.840
一直工作到2014年，最后

00:19:02.760 --> 00:19:11.100
 2015年发布

00:19:05.840 --> 00:19:13.529
它已在Java和JDK 9中采用，因此

00:19:11.100 --> 00:19:19.110
您今天可以在Java util中找到它

00:19:13.529 --> 00:19:22.620
并发流API被认为是

00:19:19.110 --> 00:19:24.960
低级集成API，因此

00:19:22.620 --> 00:19:29.220
 Java util并发中的接口

00:19:24.960 --> 00:19:32.820
流有4个界面发布者

00:19:29.220 --> 00:19:36.419
订户订阅，还有

00:19:32.820 --> 00:19:39.029
只是一个工具的处理器

00:19:36.419 --> 00:19:40.950
发布者和订阅者以及

00:19:39.029 --> 00:19:46.100
我认为只有7种方法

00:19:40.950 --> 00:19:49.559
这些接口，但是这些接口

00:19:46.100 --> 00:19:51.090
用于整合

00:19:49.559 --> 00:19:52.830
不同

00:19:51.090 --> 00:19:54.600
异步流库，所以如果我

00:19:52.830 --> 00:19:57.210
有一个能够

00:19:54.600 --> 00:19:59.870
异步流我行，我有

00:19:57.210 --> 00:20:04.770
一个能够执行以下操作的HTTP客户端

00:19:59.870 --> 00:20:08.040
异步流出，然后我

00:20:04.770 --> 00:20:09.750
有一个流操作库

00:20:08.040 --> 00:20:13.260
能够做一个

00:20:09.750 --> 00:20:17.100
改变那种

00:20:13.260 --> 00:20:18.660
应该将这些行转换为字节我可以

00:20:17.100 --> 00:20:21.180
将所有这些东西连接在一起

00:20:18.660 --> 00:20:24.260
反应流，即使

00:20:21.180 --> 00:20:27.270
这些技术从未听说过

00:20:24.260 --> 00:20:29.490
从未听说过或互相测试过

00:20:27.270 --> 00:20:33.690
互相对抗，就是这样

00:20:29.490 --> 00:20:36.360
反应性流提供确实需要的

00:20:33.690 --> 00:20:39.120
面向用户的高级api是

00:20:36.360 --> 00:20:40.890
重要的一点是，用户

00:20:39.120 --> 00:20:43.680
永远不要实现反应流

00:20:40.890 --> 00:20:45.450
如果您是

00:20:43.680 --> 00:20:47.280
使用反应流，您会发现

00:20:45.450 --> 00:20:49.560
您自己实施发布者，或

00:20:47.280 --> 00:20:54.870
订户，那么您可能正在做

00:20:49.560 --> 00:20:56.760
事情错了，因为这些甚至

00:20:54.870 --> 00:20:59.220
虽然只有几个界面

00:20:56.760 --> 00:21:03.240
规格约有七种方法

00:20:59.220 --> 00:21:06.300
反应性流本身有40或

00:21:03.240 --> 00:21:10.790
五十个人的要求有一个

00:21:06.300 --> 00:21:10.790
保留在那里的TCK可以反对

00:21:11.150 --> 00:21:18.300
对此有一个实现

00:21:15.500 --> 00:21:21.270
其中包括约一百项测试

00:21:18.300 --> 00:21:23.070
让他们通过是很多

00:21:21.270 --> 00:21:25.590
大量的并发

00:21:23.070 --> 00:21:29.760
处理内存的编程优势

00:21:25.590 --> 00:21:31.320
它不适合用户使用的障碍

00:21:29.760 --> 00:21:34.760
直接实施自己是否

00:21:31.320 --> 00:21:36.720
他们需要面向用户的高级API 

00:21:34.760 --> 00:21:39.300
不幸的是，他们有很多

00:21:36.720 --> 00:21:44.910
在那里，所以您有连接器

00:21:39.300 --> 00:21:47.580
数据库到消息代理到HTTP 

00:21:44.910 --> 00:21:51.240
然后实施反应式的客户

00:21:47.580 --> 00:21:53.160
流，你也有流

00:21:51.240 --> 00:21:56.700
操纵库，例如ARCA 

00:21:53.160 --> 00:21:58.440
流Eric的Java和反应堆，所以当

00:21:56.700 --> 00:22:00.840
您可以使用反应流

00:21:58.440 --> 00:22:02.520
您可以引入这些库并执行

00:22:00.840 --> 00:22:04.380
您需要的任何转换

00:22:02.520 --> 00:22:06.630
流

00:22:04.380 --> 00:22:08.690
当然，对于雅加达aaa 

00:22:06.630 --> 00:22:11.190
这里的挑战是这些都是

00:22:08.690 --> 00:22:13.770
供应商库的专有库

00:22:11.190 --> 00:22:15.390
他们可能是开源的，但不是

00:22:13.770 --> 00:22:17.780
标准，他们不是可以

00:22:15.390 --> 00:22:22.590
只包含在雅加达AAA中

00:22:17.780 --> 00:22:25.380
实施，因此在

00:22:22.590 --> 00:22:27.570
微型个人资料我将介绍我们的

00:22:25.380 --> 00:22:32.610
第一个规格，就是迈克

00:22:27.570 --> 00:22:35.190
轮廓反应应变算符

00:22:32.610 --> 00:22:37.650
该规范是高级用户

00:22:35.190 --> 00:22:44.130
面对API来操纵反应式

00:22:37.650 --> 00:22:45.990
流，我们刚刚发布了1.0，所以您

00:22:44.130 --> 00:22:47.580
可以使用它有很多

00:22:45.990 --> 00:22:51.840
你可以在那里实现

00:22:47.580 --> 00:22:54.870
尝试从Java util中汲取灵感

00:22:51.840 --> 00:22:58.980
流，因此，如果您熟悉Java 

00:22:54.870 --> 00:23:00.480
 util流然后有很多方法

00:22:58.980 --> 00:23:02.610
范围是什么方法都一样

00:23:00.480 --> 00:23:06.210
包括在内，什么不是

00:23:02.610 --> 00:23:09.570
同样，我应该指出，即使

00:23:06.210 --> 00:23:12.059
 api的外观类似

00:23:09.570 --> 00:23:16.580
你实际上在做的是非常

00:23:12.059 --> 00:23:20.970
不同，因此Java util流是关于

00:23:16.580 --> 00:23:23.250
操纵事物的集合

00:23:20.970 --> 00:23:25.049
通常在内存中或者

00:23:23.250 --> 00:23:27.110
一些或以某种方式计算

00:23:25.049 --> 00:23:31.669
即时

00:23:27.110 --> 00:23:36.330
潜在地并行它是关于批量

00:23:31.669 --> 00:23:39.539
的处理操作不

00:23:36.330 --> 00:23:42.000
涉及IO反应流

00:23:39.539 --> 00:23:44.909
另一方面从根本上讲

00:23:42.000 --> 00:23:46.710
关于如何处理IO 

00:23:44.909 --> 00:23:50.030
异步处理事物

00:23:46.710 --> 00:23:59.159
能够向后推流

00:23:50.030 --> 00:24:01.679
与背压反应流

00:23:59.159 --> 00:24:04.159
实施结合了ARCA的优势

00:24:01.679 --> 00:24:06.510
流rxjava和反应堆，所以每个

00:24:04.159 --> 00:24:08.190
我们添加的功能我们查看了所有

00:24:06.510 --> 00:24:10.230
这三个受欢迎的

00:24:08.190 --> 00:24:11.970
实现，我们看着还好

00:24:10.230 --> 00:24:15.360
他们使用什么命名约定

00:24:11.970 --> 00:24:17.220
他们的优势是什么？ 

00:24:15.360 --> 00:24:20.610
他们处理不同的事情， 

00:24:17.220 --> 00:24:24.539
并尝试提出曾经是什么

00:24:20.610 --> 00:24:26.970
普通的，似乎合适的东西

00:24:24.539 --> 00:24:30.120
最好根据那些人的经验

00:24:26.970 --> 00:24:33.299
劳工，我们有三个

00:24:30.120 --> 00:24:35.159
到目前为止的实现

00:24:33.299 --> 00:24:38.130
这是我们的习惯，假设是

00:24:35.159 --> 00:24:41.429
我们基于X Java的应用程序

00:24:38.130 --> 00:24:43.559
一个没有任何依赖性的

00:24:41.429 --> 00:24:45.570
所以它是从头开始实现的

00:24:43.559 --> 00:24:48.059
而这个目的是

00:24:45.570 --> 00:24:50.309
这将永远被采纳为

00:24:48.059 --> 00:24:57.840
 jdk本身可能会成为

00:24:50.309 --> 00:25:02.400
参考实施，所以我会

00:24:57.840 --> 00:25:06.419
现在要做的就是看一些PI 

00:25:02.400 --> 00:25:08.580
停靠这些，所以这里是处理器

00:25:06.419 --> 00:25:11.460
这是给处理器建造者的

00:25:08.580 --> 00:25:12.990
用于构建通用转换，因此

00:25:11.460 --> 00:25:15.870
你所拥有的方法是

00:25:12.990 --> 00:25:18.960
像地图这样的东西，你可以看到我们有

00:25:15.870 --> 00:25:20.400
这些图实际上是什么

00:25:18.960 --> 00:25:23.730
看起来像这样你有一个传入

00:25:20.400 --> 00:25:25.530
具有元素1 5和3的流，如果

00:25:23.730 --> 00:25:30.299
地图转换是将其相乘

00:25:25.530 --> 00:25:32.580
乘以10，您得出10、50和30 

00:25:30.299 --> 00:25:35.970
我们可以看到平面图的示例

00:25:32.580 --> 00:25:40.650
这是过滤器，所以过滤器

00:25:35.970 --> 00:25:42.360
所有小于3的东西

00:25:40.650 --> 00:25:44.490
这些是这些的

00:25:42.360 --> 00:25:46.409
我们跳过的操作3个元素

00:25:44.490 --> 00:25:50.309
所以前三个跳过，然后你得到

00:25:46.409 --> 00:25:54.659
现在我可以进行2和4的演示

00:25:50.309 --> 00:25:57.960
这些，但是如果你是

00:25:54.659 --> 00:25:59.490
熟悉Java 8，并去过任何

00:25:57.960 --> 00:26:01.530
 Java周围的会议

00:25:59.490 --> 00:26:07.850
率是您可能见过的最后一个

00:26:01.530 --> 00:26:07.850
 Java util流的大量演示，以及

00:26:08.000 --> 00:26:17.190
这与只是没有太大的不同

00:26:14.100 --> 00:26:20.039
使用微轮廓反应流

00:26:17.190 --> 00:26:21.980
运算符孤立的代码看起来

00:26:20.039 --> 00:26:26.429
与同类方法非常相似

00:26:21.980 --> 00:26:29.460
并使用洗手间操作员

00:26:26.429 --> 00:26:30.930
实际执行异步的上下文

00:26:29.460 --> 00:26:32.310
输入/输出过程

00:26:30.930 --> 00:26:35.760
你真的很有趣

00:26:32.310 --> 00:26:39.140
使用java.util流更好

00:26:35.760 --> 00:26:41.430
在我对此API进行演示之前

00:26:39.140 --> 00:26:42.900
我想继续下一个规格

00:26:41.430 --> 00:26:46.230
这是实际使用的东西

00:26:42.900 --> 00:26:49.670
并为这些人提供用例

00:26:46.230 --> 00:26:54.380
操作员进行一些IO处理

00:26:49.670 --> 00:26:57.750
这是微个人资料反应式消息传递

00:26:54.380 --> 00:26:59.490
所以这是一个基于反应的流

00:26:57.750 --> 00:27:01.170
消息传递API消息传递，如

00:26:59.490 --> 00:27:06.980
通过消息代理进行通信

00:27:01.170 --> 00:27:06.980
或通过对等消息传递

00:27:07.250 --> 00:27:12.420
它本质上提供了两个注释

00:27:10.050 --> 00:27:15.690
传入和传出你把这些

00:27:12.420 --> 00:27:18.510
 CDI梁中的方法并声明

00:27:15.690 --> 00:27:20.310
这种方法提供了一些东西

00:27:18.510 --> 00:27:26.100
这将处理传入或

00:27:20.310 --> 00:27:27.930
我可以连接到的外发邮件

00:27:26.100 --> 00:27:32.420
任何消息传递提供商，所以我们有

00:27:27.930 --> 00:27:38.460
 Kafka a MPP和QT t的实现

00:27:32.420 --> 00:27:41.340
 JM酸的存在的存在

00:27:38.460 --> 00:27:45.510
设计成不与

00:27:41.340 --> 00:27:47.160
规范的任何一个消息传递提供商

00:27:45.510 --> 00:27:52.130
目前正在开发中，我们正在

00:27:47.160 --> 00:27:58.980
针对它的微型配置文件3.0和

00:27:52.130 --> 00:28:03.570
所以我现在继续演示，我已经

00:27:58.980 --> 00:28:06.530
在这里有一个应用程序，所以这是一个

00:28:03.570 --> 00:28:08.940
在线选项有点像eBay，所以

00:28:06.530 --> 00:28:20.280
我要在这里创建一个项目

00:28:08.940 --> 00:28:23.910
想拍卖我的自行车，如果

00:28:20.280 --> 00:28:25.440
任何我们要检查的聊天方式

00:28:23.910 --> 00:28:30.350
很好的一些问题是

00:28:25.440 --> 00:28:35.040
伟大的，也许之后

00:28:30.350 --> 00:28:38.130
演示，之后我会做的完美

00:28:35.040 --> 00:28:40.350
谢谢，所以我创建了一个拍卖

00:28:38.130 --> 00:28:43.890
我在卖我的红色自行车，我将开始

00:28:40.350 --> 00:28:45.029
拍卖，如果现在非常安全

00:28:43.890 --> 00:28:47.249
认证方式

00:28:45.029 --> 00:28:51.690
以其他用户身份登录

00:28:47.249 --> 00:28:54.330
放一副10美元的胡须

00:28:51.690 --> 00:28:59.700
目前已被接受

00:28:54.330 --> 00:29:03.450
 50美分的价格，然后如果我去

00:28:59.700 --> 00:29:06.210
现在以其他人的身份登录

00:29:03.450 --> 00:29:08.460
这个约翰使用者去了，他们真的

00:29:06.210 --> 00:29:13.739
对红色图标感兴趣，因此他们进行搜索

00:29:08.460 --> 00:29:17.669
现在我的黑色出现了，你在这里看到

00:29:13.739 --> 00:29:19.590
当前价格未列出， 

00:29:17.669 --> 00:29:21.149
原因是因为我没有

00:29:19.590 --> 00:29:23.309
在此服务中实现一些东西

00:29:21.149 --> 00:29:26.399
我们有很多服务

00:29:23.309 --> 00:29:29.009
实施此应用程序并在那里

00:29:26.399 --> 00:29:31.619
是一项拍卖服务

00:29:29.009 --> 00:29:33.509
包含以下详细信息的服务

00:29:31.619 --> 00:29:36.809
拍卖项目

00:29:33.509 --> 00:29:38.369
控制出价的服务以及

00:29:36.809 --> 00:29:42.509
有一个实施的搜索服务

00:29:38.369 --> 00:29:45.179
此搜索屏幕以及

00:29:42.509 --> 00:29:49.350
搜索服务获取信息的依据

00:29:45.179 --> 00:29:50.879
订阅来自

00:29:49.350 --> 00:29:53.700
两者都获得服务

00:29:50.879 --> 00:29:56.779
项目的信息以及

00:29:53.700 --> 00:30:00.379
竞价服务以获取当前价格

00:29:56.779 --> 00:30:03.929
所以如果我们去看看代码

00:30:00.379 --> 00:30:06.389
这是订阅的地方

00:30:03.929 --> 00:30:07.879
竞标服务，因此您可以在这里看到

00:30:06.389 --> 00:30:10.830
目前我们已经收到了

00:30:07.879 --> 00:30:14.429
注释，这是说我想要

00:30:10.830 --> 00:30:18.720
出价相关主题正在返回

00:30:14.429 --> 00:30:20.940
订户生成器，所以这是

00:30:18.720 --> 00:30:23.340
微轮廓反应流操作员

00:30:20.940 --> 00:30:30.659
这里的API将建立一个

00:30:23.340 --> 00:30:32.369
投标事件的订户，然后我们

00:30:30.659 --> 00:30:36.239
在这里创建生成器，您可以看到

00:30:32.369 --> 00:30:38.159
我们对每条消息都不做任何事情，所以

00:30:36.239 --> 00:30:41.999
显然我们还没有实施

00:30:38.159 --> 00:30:45.090
但是我们已经在这里实现了

00:30:41.999 --> 00:30:47.009
项目事件处理，这就是为什么

00:30:45.090 --> 00:30:49.109
出现该项目，搜索索引位于

00:30:47.009 --> 00:30:51.149
除了价格以外，其他所有原因都是因为

00:30:49.109 --> 00:30:52.769
我们尚未实施

00:30:51.149 --> 00:30:54.180
包含以下内容的出价事件

00:30:52.769 --> 00:30:56.880
价格在他们

00:30:54.180 --> 00:30:59.940
那么为什么我们不这样做呢？ 

00:30:56.880 --> 00:31:02.100
我们收到时想要做的事情

00:30:59.940 --> 00:31:06.270
这服务有些不好

00:31:02.100 --> 00:31:09.120
实际上将其数据保留在内部

00:31:06.270 --> 00:31:11.720
 elasticsearch和elasticsearch作品

00:31:09.120 --> 00:31:15.090
与文件，所以我们想先

00:31:11.720 --> 00:31:17.790
使用地图转换我们的消息

00:31:15.090 --> 00:31:20.910
功能进入文档，所以我已经

00:31:17.790 --> 00:31:26.970
创建了一种方法来处理重大事件

00:31:20.910 --> 00:31:29.910
现在要记录这个方法

00:31:26.970 --> 00:31:31.830
不想处理所有事件

00:31:29.910 --> 00:31:34.740
有些事件不需要

00:31:31.830 --> 00:31:36.390
结果是坚持一切

00:31:34.740 --> 00:31:39.000
所以它实际上返回一种

00:31:36.390 --> 00:31:41.010
如果事件不是一个可选事件

00:31:39.000 --> 00:31:45.060
有趣的是它将返回一个空

00:31:41.010 --> 00:31:48.900
可选，所以我们接下来要做的是

00:31:45.060 --> 00:31:52.050
过滤掉所有那些空的，所以我们使用

00:31:48.900 --> 00:31:56.400
过滤器做到这一点，我们将使用

00:31:52.050 --> 00:32:00.390
视情况而定，如果存在

00:31:56.400 --> 00:32:02.630
方法返回了文档，然后它将

00:32:00.390 --> 00:32:05.160
仍然在流中，否则

00:32:02.630 --> 00:32:08.510
在执行此过滤器操作之后， 

00:32:05.160 --> 00:32:11.130
成为那个流中的任何元素

00:32:08.510 --> 00:32:14.370
现在下一件事，所以我们的信息仍然

00:32:11.130 --> 00:32:19.710
包裹在一个可选的让我们解开

00:32:14.370 --> 00:32:22.050
它使用可选的，所以现在我们有了

00:32:19.710 --> 00:32:25.230
我们偏爱我们的文件

00:32:22.050 --> 00:32:27.540
流不像可选一样直接

00:32:25.230 --> 00:32:30.510
元素，所以现在我们可以

00:32:27.540 --> 00:32:34.710
处理它们，我们将使用平面图

00:32:30.510 --> 00:32:40.050
完成阶段，所以我们有一个反应

00:32:34.710 --> 00:32:43.200
或异步Elasticsearch存储

00:32:40.050 --> 00:32:47.420
在这里，Sordo索引存储

00:32:43.200 --> 00:32:47.420
我们将传递文件

00:32:49.770 --> 00:32:56.590
在消息中有他们的消息博士。 

00:32:52.990 --> 00:32:59.860
有效负载现在是该存储的结果

00:32:56.590 --> 00:33:03.910
操作是完成的完成阶段

00:32:59.860 --> 00:33:07.990
这只是一个单元操作

00:33:03.910 --> 00:33:10.810
打算将其转换回

00:33:07.990 --> 00:33:13.150
该消息，因为存储后，我们

00:33:10.810 --> 00:33:17.530
想再确认消息

00:33:13.150 --> 00:33:19.360
从卡夫卡队列开始，所以我们现在有了

00:33:17.530 --> 00:33:22.810
我们已经存储了它，但仍然有我们的

00:33:19.360 --> 00:33:25.810
带有消息的字符串，所以我们不能

00:33:22.810 --> 00:33:30.300
完成阶段，我们可以调用

00:33:25.810 --> 00:33:30.300
该法案再次令人惊讶

00:33:35.520 --> 00:33:43.120
这就是为什么我们使用大众平面图

00:33:39.640 --> 00:33:44.620
完成阶段之后，我们已经

00:33:43.120 --> 00:33:47.170
实际上完成了我们需要做的一切

00:33:44.620 --> 00:33:52.510
这样做，我们只需终止流

00:33:47.170 --> 00:33:56.080
在每个专业上都没有涉及

00:33:52.510 --> 00:34:02.290
元素，然后我们可以将其返回为

00:33:56.080 --> 00:34:03.820
消息事件的订阅者，因此具有

00:34:02.290 --> 00:34:05.730
实现我已经有了这个

00:34:03.820 --> 00:34:08.620
然后在后台登录

00:34:05.730 --> 00:34:10.860
自动检测腐蚀变化

00:34:08.620 --> 00:34:14.500
重新编译并重新启动服务

00:34:10.860 --> 00:34:16.450
应该提到这个应用程序是

00:34:14.500 --> 00:34:22.060
用登录方式写的，这是一种反应

00:34:16.450 --> 00:34:23.580
本地服务框架，因此应该

00:34:22.060 --> 00:34:26.890
已重新加载，我们再次进行搜索

00:34:23.580 --> 00:34:28.330
我们看不到当前价格和

00:34:26.890 --> 00:34:31.000
原因是因为还有别的东西

00:34:28.330 --> 00:34:34.750
我们还没有实施，但是

00:34:31.000 --> 00:34:40.300
在我展示我会动之前

00:34:34.750 --> 00:34:42.550
转到下一张幻灯片，另一件事

00:34:40.300 --> 00:34:45.100
这是关于种族竞赛的讨论

00:34:42.550 --> 00:34:48.130
在微观轮廓上是

00:34:45.100 --> 00:34:52.660
 CQRS规范现在说QR S代表

00:34:48.130 --> 00:34:56.230
命令查询责任分离

00:34:52.660 --> 00:34:58.870
这是关于分离

00:34:56.230 --> 00:35:00.700
负责处理来自

00:34:58.870 --> 00:35:01.430
冰雹的责任

00:35:00.700 --> 00:35:03.530
明确

00:35:01.430 --> 00:35:05.030
这样它们就可以在

00:35:03.530 --> 00:35:07.609
可以扩展的不同数据库

00:35:05.030 --> 00:35:09.650
显然，更重要的是

00:35:07.609 --> 00:35:11.150
我们对这里感兴趣，我们不

00:35:09.650 --> 00:35:14.690
希望他们能够影响每个

00:35:11.150 --> 00:35:16.609
其他，如果查询失败-如果查询

00:35:14.690 --> 00:35:18.619
处理由于某种原因而失败

00:35:16.609 --> 00:35:25.309
不应该停止我们的命令

00:35:18.619 --> 00:35:28.300
已处理，您将早于

00:35:25.309 --> 00:35:34.910
我谈到的演示文稿

00:35:28.300 --> 00:35:36.819
关于如何处理您的问题

00:35:34.910 --> 00:35:39.890
直接发布到消息代理

00:35:36.819 --> 00:35:41.569
在执行诸如

00:35:39.890 --> 00:35:43.069
更新数据库，然后您有一个

00:35:41.569 --> 00:35:47.180
与您的消息的耦合程度

00:35:43.069 --> 00:35:52.640
经纪人加热器CQRS可用于

00:35:47.180 --> 00:35:55.040
解耦您的坚持

00:35:52.640 --> 00:35:56.869
从那时起您对命令的处理

00:35:55.040 --> 00:36:02.000
将这些事件发布到消息中

00:35:56.869 --> 00:36:06.339
经纪人，以便他们可以更新查询，以便

00:36:02.000 --> 00:36:08.420
让我们回顾一下我们的服务

00:36:06.339 --> 00:36:09.619
现在我们要进入

00:36:08.420 --> 00:36:12.260
不同的服务进入招标

00:36:09.619 --> 00:36:14.119
服务，这是我所拥有的代码

00:36:12.260 --> 00:36:15.890
实施他们所在的发布商

00:36:14.119 --> 00:36:18.260
现在爱我不会显示

00:36:15.890 --> 00:36:20.480
投标的实际持续时间

00:36:18.260 --> 00:36:22.910
服务，但是竞标服务是什么

00:36:20.480 --> 00:36:25.460
确实是在使用事件时

00:36:22.910 --> 00:36:28.460
采购，而不是存储

00:36:25.460 --> 00:36:30.530
诸如您这样的选项的当前状态

00:36:28.460 --> 00:36:32.200
知道这是当前价格， 

00:36:30.530 --> 00:36:34.880
这是目前的中标者， 

00:36:32.200 --> 00:36:37.819
当前的费用选项仍在运行

00:36:34.880 --> 00:36:39.319
而不是存储在那种状态

00:36:37.819 --> 00:36:42.109
只需存储所有事件

00:36:39.319 --> 00:36:44.599
发生并从中计算状态

00:36:42.109 --> 00:36:46.339
事件，因此氧气开始竞标是

00:36:44.599 --> 00:36:46.970
已放置此出价已放置选项

00:36:46.339 --> 00:36:51.349
完了

00:36:46.970 --> 00:36:54.650
并且因为它在存储时会存储

00:36:51.349 --> 00:36:58.700
这些事件记录在该事件中

00:36:54.650 --> 00:37:00.290
日志可以被异步使用

00:36:58.700 --> 00:37:02.839
在这种情况下的另一个过程

00:37:00.290 --> 00:37:04.910
发布事件日志方法，所以我们有

00:37:02.839 --> 00:37:08.390
这种与持久性的脱钩

00:37:04.910 --> 00:37:11.630
这些事件在哪里

00:37:08.390 --> 00:37:14.569
被坚持，而那件事

00:37:11.630 --> 00:37:15.200
然后在另一个过程中

00:37:14.569 --> 00:37:18.589
潜在地

00:37:15.200 --> 00:37:20.420
在不同时间的另一台机器

00:37:18.589 --> 00:37:24.020
并读取该事件的负载和发布者

00:37:20.420 --> 00:37:26.060
卡夫卡适配器，让您可以再次看到

00:37:24.020 --> 00:37:27.740
这次不是订户

00:37:26.060 --> 00:37:31.250
这是一个处理器，这意味着

00:37:27.740 --> 00:37:33.829
转换我们创建的消息

00:37:31.250 --> 00:37:35.359
生成器，我们将它们过滤为

00:37:33.829 --> 00:37:37.130
发布我们要过滤的内容

00:37:35.359 --> 00:37:39.800
然后我们对

00:37:37.130 --> 00:37:41.900
他们，我们最终转换这些

00:37:39.800 --> 00:37:43.430
拍卖活动的传入消息

00:37:41.900 --> 00:37:46.609
那就是坚持不懈的

00:37:43.430 --> 00:37:49.609
这些出价事件的数据库

00:37:46.609 --> 00:37:51.890
我们没有发布的内容

00:37:49.609 --> 00:37:55.790
我们在这里缺少的是注释

00:37:51.890 --> 00:37:57.859
能够宣布这一点，所以这些

00:37:55.790 --> 00:37:59.839
是反应式消息传递注释

00:37:57.859 --> 00:38:04.910
在这里我说的是提供商

00:37:59.839 --> 00:38:06.320
事件日志，所以这不是

00:38:04.910 --> 00:38:07.550
实际上从

00:38:06.320 --> 00:38:11.390
消息代理在这里越来越

00:38:07.550 --> 00:38:13.820
来自CQRS的数据库消息

00:38:11.390 --> 00:38:15.530
事件流，他们将成为

00:38:13.820 --> 00:38:18.829
用户收到的消息，然后

00:38:15.530 --> 00:38:22.849
即将发布的出价

00:38:18.829 --> 00:38:27.950
卡夫卡的事件队列，所以现在我已经

00:38:22.849 --> 00:38:30.319
进行了这些更改以及何时登录

00:38:27.950 --> 00:38:36.670
在他开始的地方捡起来重新编译

00:38:30.319 --> 00:38:40.550
我可以去的服务我可以点击搜索， 

00:38:36.670 --> 00:38:45.950
希望它应该显示

00:38:40.550 --> 00:38:48.430
目前的价格，我不确定为什么不

00:38:45.950 --> 00:38:48.430
那样做

00:38:54.040 --> 00:38:59.790
我们将尝试仅针对

00:38:57.640 --> 00:38:59.790
好的措施

00:39:07.840 --> 00:39:12.530
所以现在的价格是

00:39:10.820 --> 00:39:15.830
已发表

00:39:12.530 --> 00:39:17.840
现在很不幸，我去过这个演示

00:39:15.830 --> 00:39:19.930
很多次之前和什么

00:39:17.840 --> 00:39:25.010
碰巧有当前价格

00:39:19.930 --> 00:39:26.960
刚来，我必须回去

00:39:25.010 --> 00:39:32.860
并弄清楚为什么我不来

00:39:26.960 --> 00:39:32.860
然后可能有一个

00:39:32.920 --> 00:39:38.240
卡夫卡没有任何联系

00:39:35.890 --> 00:39:44.570
有时在发展优质的卡夫卡

00:39:38.240 --> 00:39:47.870
比有点挑剔，但我是

00:39:44.570 --> 00:39:49.460
重要的是如果演示

00:39:47.870 --> 00:39:51.290
作品或证明的是

00:39:49.460 --> 00:39:58.580
我们实际上有一个自我修复系统

00:39:51.290 --> 00:40:00.320
当我在某个阶段时

00:39:58.580 --> 00:40:03.590
你看到我什至没有实施

00:40:00.320 --> 00:40:06.760
现在发布，我们直接发布到

00:40:03.590 --> 00:40:11.360
咳嗽后做一个小时的手术然后

00:40:06.760 --> 00:40:13.810
我们本来不会有我们的系统

00:40:11.360 --> 00:40:19.490
曾经得到那些当前的价格

00:40:13.810 --> 00:40:21.910
这些位事件，因为如果因为

00:40:19.490 --> 00:40:24.800
迷失了历史

00:40:21.910 --> 00:40:27.290
你不能重新发布你不能重做

00:40:24.800 --> 00:40:29.300
过去的事，但是当你

00:40:27.290 --> 00:40:35.110
串流时使用串流

00:40:29.300 --> 00:40:35.110
面向系统的方法

00:40:39.920 --> 00:40:46.519
你可以恢复你可以恢复

00:40:43.250 --> 00:40:46.880
随时处理，所以您得到

00:40:46.519 --> 00:40:48.170
这个

00:40:46.880 --> 00:40:50.329
这些自我修复的属性

00:40:48.170 --> 00:40:53.140
流本身所在的概率

00:40:50.329 --> 00:40:58.510
什么继续推动您的系统

00:40:53.140 --> 00:40:58.510
保持一致

00:41:04.500 --> 00:41:09.970
这样就结束了

00:41:07.270 --> 00:41:11.470
演示这里有一些链接

00:41:09.970 --> 00:41:13.240
我有你可以看到微

00:41:11.470 --> 00:41:15.910
轮廓反应物流操作员规范

00:41:13.240 --> 00:41:18.880
是运营商的文件

00:41:15.910 --> 00:41:22.270
我之前和麦克展示过

00:41:18.880 --> 00:41:25.470
配置响应式消息传递规范，因此我

00:41:22.270 --> 00:41:29.410
可能会检查我现在是否有问题

00:41:25.470 --> 00:41:29.770
实际上看不到任何问题

00:41:29.410 --> 00:41:33.580
聊天室

00:41:29.770 --> 00:41:42.430
哦，你不，你想写他们

00:41:33.580 --> 00:41:46.300
让我出去，让我看看试图

00:41:42.430 --> 00:41:48.730
弄清楚我能否指向你

00:41:46.300 --> 00:41:52.200
问题，但尽管如此，其中之一

00:41:48.730 --> 00:41:56.980
我们遇到的问题是什么是CQRS 

00:41:52.200 --> 00:42:00.070
然后您知道提供了链接

00:41:56.980 --> 00:42:03.040
为此，但如果你想去

00:42:00.070 --> 00:42:05.500
在那边你有什么意见吗

00:42:03.040 --> 00:42:07.090
是的，我确实在早期提到了CQRS 

00:42:05.500 --> 00:42:09.760
演示而无需解释，然后

00:42:07.090 --> 00:42:14.530
我确实在稍后解释了更多细节

00:42:09.760 --> 00:42:17.350
但是只是要再遍一遍

00:42:14.530 --> 00:42:22.300
命令查询责任分离

00:42:17.350 --> 00:42:24.130
想法是将您的

00:42:22.300 --> 00:42:28.300
您的写操作命令

00:42:24.130 --> 00:42:31.480
从您的查询中读取

00:42:28.300 --> 00:42:35.350
操作，所以你最终会得到什么

00:42:31.480 --> 00:42:36.760
与你做一些逗号处理

00:42:35.350 --> 00:42:40.810
你的写操作，然后你有

00:42:36.760 --> 00:42:42.760
作为输出的事件流

00:42:40.810 --> 00:42:44.710
您的写操作是否

00:42:42.760 --> 00:42:46.840
事件来源

00:42:44.710 --> 00:42:49.780
自己就是你坚持或坚持的东西

00:42:46.840 --> 00:42:51.550
除了对

00:42:49.780 --> 00:42:55.830
 Crud数据库，您可能会坚持一些

00:42:51.550 --> 00:42:58.690
事件到事件表中，然后

00:42:55.830 --> 00:43:00.310
通常会消耗这些事件

00:42:58.690 --> 00:43:01.780
有某种偏移，所以你可以

00:43:00.310 --> 00:43:03.520
跟踪您在两位偏移中的位置

00:43:01.780 --> 00:43:06.280
这意味着您何时失败或何时

00:43:03.520 --> 00:43:11.710
出现问题，您可以从中恢复

00:43:06.280 --> 00:43:14.470
该偏移量，它使您能够

00:43:11.710 --> 00:43:16.150
能够在不同的位置进行处理

00:43:14.470 --> 00:43:17.470
您可以在不同的机器上使用

00:43:16.150 --> 00:43:20.410
不同的数据库技术

00:43:17.470 --> 00:43:22.630
所以这里的例子我正在使用事件或

00:43:20.410 --> 00:43:24.520
使用弹性搜索进行搜索

00:43:22.630 --> 00:43:26.680
服务是一种不同的技术

00:43:24.520 --> 00:43:30.840
给卡桑德拉使用的是

00:43:26.680 --> 00:43:34.300
在项目服务和出价服务中，以及

00:43:30.840 --> 00:43:37.630
而且由于它是基于流的，因此您可以

00:43:34.300 --> 00:43:39.640
利用事实，但你

00:43:37.630 --> 00:43:41.530
可以让基础架构管理您的

00:43:39.640 --> 00:43:45.690
为您管理自己喜欢的视频流

00:43:41.530 --> 00:43:45.690
但故障率上升分布

00:43:46.920 --> 00:43:58.680
对另一个问题是你

00:43:54.070 --> 00:44:03.040
支持还是与顶点一起使用

00:43:58.680 --> 00:44:05.500
是的，所以我是其中之一

00:44:03.040 --> 00:44:09.820
反应流的实现

00:44:05.500 --> 00:44:14.500
运营商是否已实施

00:44:09.820 --> 00:44:20.470
我们还将与Eric的Java一起使用Red Hat 

00:44:14.500 --> 00:44:23.920
在顶点上的支持，的确

00:44:20.470 --> 00:44:30.070
红帽的消息传递实现是

00:44:23.920 --> 00:44:32.440
建立在顶点上，这样工作就可以了

00:44:30.070 --> 00:44:36.190
我正在做的是与阿卡·阿卡

00:44:32.440 --> 00:44:39.839
流并登录，但如果您转到

00:44:36.190 --> 00:44:44.490
红帽的麦克风实现

00:44:39.839 --> 00:44:44.490
您将在顶点上获得支持

00:44:47.060 --> 00:44:52.580
另一个问题是有什么好处

00:44:49.880 --> 00:44:59.300
在飞机上使用这个卡夫卡

00:44:52.580 --> 00:45:04.910
流API是的，所以Kafka流是

00:44:59.300 --> 00:45:06.980
卡夫卡-卡夫卡你可以做卡夫卡连接

00:45:04.910 --> 00:45:09.620
但是非常有限

00:45:06.980 --> 00:45:11.960
他们说他们支持的卡夫卡流

00:45:09.620 --> 00:45:14.090
事件采购，但他们仅支持

00:45:11.960 --> 00:45:16.100
看起来像事件的东西

00:45:14.090 --> 00:45:18.290
采购不支持命令

00:45:16.100 --> 00:45:19.940
这只是必须处理的事件

00:45:18.290 --> 00:45:21.680
并且不能被拒绝，这是一个

00:45:19.940 --> 00:45:22.910
那么采购的根本是

00:45:21.680 --> 00:45:27.680
您可以验证和拒绝

00:45:22.910 --> 00:45:32.360
命令，如果您需要做袖带

00:45:27.680 --> 00:45:34.850
到卡夫卡加工然后是卡夫卡

00:45:32.360 --> 00:45:39.500
流很棒，但是这给了你什么

00:45:34.850 --> 00:45:42.350
你所能看到的是更多

00:45:39.500 --> 00:45:53.780
您可以连接，并在

00:45:42.350 --> 00:45:57.320
数据库到你到你去咳嗽

00:45:53.780 --> 00:45:59.840
像你一样，那里也没有卡夫卡

00:45:57.320 --> 00:46:01.520
那里或那里所有的特定代码

00:45:59.840 --> 00:46:04.190
不一定是任何Kafka特有的

00:46:01.520 --> 00:46:07.700
您的应用程序中的代码，以便您可以

00:46:04.190 --> 00:46:09.380
可以让你做你的兽医卡夫卡

00:46:07.700 --> 00:46:11.630
计算通风口处理而无需

00:46:09.380 --> 00:46:14.480
累了掩盖，并能够移动到

00:46:11.630 --> 00:46:17.900
例如，不同的消息代理

00:46:14.480 --> 00:46:20.380
激酶或其他云技术

00:46:17.900 --> 00:46:23.510
 Azure活动中心是一个非常坚强的女孩，例如

00:46:20.380 --> 00:46:28.130
你可以你的代码将是可移植的

00:46:23.510 --> 00:46:30.410
对那些，所以这使你可以做

00:46:28.130 --> 00:46:37.010
没有供应商锁定的东西

00:46:30.410 --> 00:46:43.520
你与卡夫卡流在一起，好吧，让我

00:46:37.010 --> 00:46:46.490
看到我要感谢微简介

00:46:43.520 --> 00:46:51.850
蚀微轮廓社区

00:46:46.490 --> 00:46:54.260
回答问题以及

00:46:51.850 --> 00:46:59.540
他们是他们在聊天中非常活跃

00:46:54.260 --> 00:47:00.770
也让我看看我想你

00:46:59.540 --> 00:47:02.900
已经说过

00:47:00.770 --> 00:47:06.740
您提供的示例位于

00:47:02.900 --> 00:47:12.530
 github是正确的例子

00:47:06.740 --> 00:47:14.090
发生本身，我想我有一个版本

00:47:12.530 --> 00:47:15.650
其中有点不同于

00:47:14.090 --> 00:47:20.440
另一个演示文稿，但我可以发表

00:47:15.650 --> 00:47:24.140
它到两个到github是的

00:47:20.440 --> 00:47:30.200
我将其发布到这里

00:47:24.140 --> 00:47:33.980
最多发布，但尚不存在

00:47:30.200 --> 00:47:42.050
但是雅加达-嘿-只是反应而已

00:47:33.980 --> 00:47:43.460
流媒体，您将能够在其中

00:47:42.050 --> 00:47:46.790
在此之后五分钟找到它

00:47:43.460 --> 00:47:47.660
演示文稿完成了

00:47:46.790 --> 00:47:49.640
太棒了

00:47:47.660 --> 00:47:54.290
也许如果您不介意把它放在上面

00:47:49.640 --> 00:47:56.570
您的最后一张幻灯片，以便人们查看

00:47:54.290 --> 00:48:00.890
从这个角度来看

00:47:56.570 --> 00:48:04.540
链接那里还有其他问题

00:48:00.890 --> 00:48:04.540
詹姆斯的评论

00:48:14.019 --> 00:48:21.619
我们想让詹姆斯在身边回答

00:48:17.509 --> 00:48:24.589
还有更多问题，如果有，请

00:48:21.619 --> 00:48:27.079
关于任何问题或评论

00:48:24.589 --> 00:48:29.569
谈话请放在聊天中

00:48:27.079 --> 00:48:31.789
我们很高兴见到你

00:48:29.569 --> 00:48:43.789
然后再下来

00:48:31.789 --> 00:48:49.759
聊天活动好吧，如果有

00:48:43.789 --> 00:48:52.519
没什么其他提醒

00:48:49.759 --> 00:48:56.959
一个月，我们将再打一个电话

00:48:52.519 --> 00:49:02.049
即将设置我希望

00:48:56.959 --> 00:49:09.160
有马来西亚人或塞巴斯蒂安人-要

00:49:02.049 --> 00:49:13.939
有他们的谈话话题，请继续关注

00:49:09.160 --> 00:49:17.170
日期和时间的监视器

00:49:13.939 --> 00:49:21.019
同时我要感谢

00:49:17.170 --> 00:49:25.189
詹姆斯非常非常非常

00:49:21.019 --> 00:49:27.650
感谢，是的，我们会保持联系

00:49:25.189 --> 00:49:30.829
如果我们知道我们在哪里可以找到詹姆斯

00:49:27.650 --> 00:49:34.729
需要他知道你提供更多

00:49:30.829 --> 00:49:39.619
有关流的信息或

00:49:34.729 --> 00:49:42.769
反应式流式传输或其他任何方式

00:49:39.619 --> 00:49:45.499
暂时保持温暖

00:49:42.769 --> 00:49:49.609
问北半球在哪里

00:49:45.499 --> 00:49:55.329
太冻结了，谢谢大家

00:49:49.609 --> 00:49:55.329
我们会保持联系，谢谢

00:50:02.400 --> 00:50:04.460
您

