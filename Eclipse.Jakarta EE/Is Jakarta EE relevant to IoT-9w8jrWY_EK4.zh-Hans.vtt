WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.030 --> 00:00:09.570
嘿，我认为法院就在附近

00:00:04.470 --> 00:00:13.740
我开始说的就是雅加达EE 

00:00:09.570 --> 00:00:14.730
与物联网有关，所以我的答案

00:00:13.740 --> 00:00:20.730
意见是

00:00:14.730 --> 00:00:22.109
演讲结束了，所以欢迎您

00:00:20.730 --> 00:00:27.869
描述一个您可以使用的用例

00:00:22.109 --> 00:00:31.619
在和使用Jakarta EE I中用于IOT 

00:00:27.869 --> 00:00:33.660
然后进行演示设置

00:00:31.619 --> 00:00:37.309
设法在最后一分钟开始工作

00:00:33.660 --> 00:00:39.809
忘记我的电源后

00:00:37.309 --> 00:00:45.239
然后我们将基本上通过代码

00:00:39.809 --> 00:00:46.980
建立示范，所以

00:00:45.239 --> 00:00:50.989
查看来自Jakarta EE的代码片段

00:00:46.980 --> 00:00:54.120
并展示这种建造方式

00:00:50.989 --> 00:00:56.010
构建我们要在办公桌上显示的内容

00:00:54.120 --> 00:01:06.900
在当地，这是一个小房间，所以你会

00:00:56.010 --> 00:01:11.010
能够看到，所以这是一个

00:01:06.900 --> 00:01:12.810
我们已经建立的示范

00:01:11.010 --> 00:01:15.210
基本上，我们试图证明使用

00:01:12.810 --> 00:01:19.020
 Jakarta EE实际上可以同时构建

00:01:15.210 --> 00:01:22.890
在设备上并向上扩展到

00:01:19.020 --> 00:01:24.930
云类型的环境，因此使用

00:01:22.890 --> 00:01:27.240
使用完全相同的技术

00:01:24.930 --> 00:01:32.369
完全相同的运行时，并使用

00:01:27.240 --> 00:01:36.210
同样的编码风格，所以我们

00:01:32.369 --> 00:01:39.409
在这里，我们有一个传感器节点

00:01:36.210 --> 00:01:42.990
基本上是因为我们正在

00:01:39.409 --> 00:01:46.770
覆盆子PI，所以有一个循环循环

00:01:42.990 --> 00:01:49.799
感觉这里正在运行的节点有一个

00:01:46.770 --> 00:01:54.030
带有湿度传感器的感应帽

00:01:49.799 --> 00:01:57.210
内置于其中，以便运行

00:01:54.030 --> 00:02:01.290
基本上产生测量

00:01:57.210 --> 00:02:05.040
此刻房间的湿度和

00:02:01.290 --> 00:02:06.750
多数民众赞成通过切换到网络

00:02:05.040 --> 00:02:10.370
这里的另一个树莓派是

00:02:06.750 --> 00:02:12.940
充当网关Nogrady采取

00:02:10.370 --> 00:02:15.100
来自网络的样本

00:02:12.940 --> 00:02:18.720
它具有嵌入式Web应用程序

00:02:15.100 --> 00:02:23.850
您可以查看以测量湿度

00:02:18.720 --> 00:02:29.080
他们使用Tecate II连接在一起

00:02:23.850 --> 00:02:31.240
他们在PI或Micro上运行

00:02:29.080 --> 00:02:35.650
我们将来到一个运行时

00:02:31.240 --> 00:02:38.890
支持两个车载AP Ice或Java EE AP 

00:02:35.650 --> 00:02:42.910
冰和这些东西正在交流

00:02:38.890 --> 00:02:45.940
通过在它们之间发送网络事件

00:02:42.910 --> 00:02:47.710
所以他们使用所谓的CDI和

00:02:45.940 --> 00:02:52.810
他们正在之间发送群集事件

00:02:47.710 --> 00:02:55.360
一个节点，另一个节点，这样

00:02:52.810 --> 00:02:59.140
正在运行的应用程序正在使用

00:02:55.360 --> 00:03:03.570
 WebSockets先生。卡特恩

00:02:59.140 --> 00:03:06.820
您可以获得完整的Web API，并且

00:03:03.570 --> 00:03:08.380
包括Web套接字API，因此

00:03:06.820 --> 00:03:15.040
推动数据和实时下降

00:03:08.380 --> 00:03:17.410
到浏览器，以便更新

00:03:15.040 --> 00:03:19.120
有效地使用html5图形

00:03:17.410 --> 00:03:20.650
一次又一次正在运行

00:03:19.120 --> 00:03:22.900
在Raspberry Pi上，我们应该能够

00:03:20.650 --> 00:03:28.090
也可以在机器上

00:03:22.900 --> 00:03:33.280
笔记本电脑，然后进行此演示

00:03:28.090 --> 00:03:36.520
我们那里也有什么标记

00:03:33.280 --> 00:03:38.800
作为这种情况下的云连接器

00:03:36.520 --> 00:03:40.540
如果我们要扩大云规模的话

00:03:38.800 --> 00:03:41.860
我们将做一个演示， 

00:03:40.540 --> 00:03:46.110
包括Microsoft Azure，但为此

00:03:41.860 --> 00:03:49.540
目的是我们在做什么，我们已经使用了

00:03:46.110 --> 00:03:59.230
 MQTT连接器，我们正在推动MQTT 

00:03:49.540 --> 00:04:01.720
事件，因此在这种情况下，连接器是

00:03:59.230 --> 00:04:06.489
将使用MQTT发送mqtt 

00:04:01.720 --> 00:04:10.780
消息到我的笔记本电脑上，好吧，它使用了

00:04:06.489 --> 00:04:12.550
 Java EE JCA中的标准标准

00:04:10.780 --> 00:04:16.330
听起来Java连接器连接器

00:04:12.550 --> 00:04:21.039
标准的架构或API 

00:04:16.330 --> 00:04:23.979
建立与其他连接器的方式

00:04:21.039 --> 00:04:26.640
并非是固有的或

00:04:23.979 --> 00:04:29.860
不直接支持

00:04:26.640 --> 00:04:31.540
在delray中，例如在这种情况下， 

00:04:29.860 --> 00:04:36.390
与MQTT的联系非常紧密

00:04:31.540 --> 00:04:39.850
消息协议还可以

00:04:36.390 --> 00:04:42.400
我们没有示范的事件是

00:04:39.850 --> 00:04:44.410
除此之外，您可以使用一次

00:04:42.400 --> 00:04:46.990
消息不在您的网关节点上

00:04:44.410 --> 00:04:49.180
显然可以然后将它们推入

00:04:46.990 --> 00:04:52.660
在云方面到任何云

00:04:49.180 --> 00:04:54.280
基础架构建立大数据网格

00:04:52.660 --> 00:04:56.200
并使用所有标准企业

00:04:54.280 --> 00:05:01.180
每个人都可以削减的技术

00:04:56.200 --> 00:05:03.460
很容易以您知道而闻名

00:05:01.180 --> 00:05:11.140
建立数据可视化或数据

00:05:03.460 --> 00:05:14.170
用户捕获系统好吗

00:05:11.140 --> 00:05:17.320
我们显然在这里跑

00:05:14.170 --> 00:05:21.760
人们会认为运行Java EE 

00:05:17.320 --> 00:05:24.400
在物联网上的答案是没有这些东西

00:05:21.760 --> 00:05:27.070
大脂肪重应用

00:05:24.400 --> 00:05:29.410
使用千兆字节内存的服务器

00:05:27.070 --> 00:05:32.920
知道它们的大小为千兆字节

00:05:29.410 --> 00:05:34.870
安装好，这基本上是不正确的我

00:05:32.920 --> 00:05:37.210
就是那大概十

00:05:34.870 --> 00:05:40.150
年前但不是今天

00:05:37.210 --> 00:05:42.340
真的很老化，所以我们正在运行微型电源

00:05:40.150 --> 00:05:46.090
我来自Paora，我叫Steve Millage，所以我

00:05:42.340 --> 00:05:48.520
发现payara和部分微是一个

00:05:46.090 --> 00:05:50.380
运行时间非常短，所以我们放弃了

00:05:48.520 --> 00:05:53.440
设计得非常简单，所以

00:05:50.380 --> 00:05:55.330
无需安装，无需安装

00:05:53.440 --> 00:05:58.900
安装下载千兆字节的

00:05:55.330 --> 00:06:00.130
数据使周围充满混乱

00:05:58.900 --> 00:06:02.220
实际上，您只需在

00:06:00.130 --> 00:06:06.520
命令行，它在引导程序上

00:06:02.220 --> 00:06:09.940
 Jakarta ye Java re'runtime 

00:06:06.520 --> 00:06:13.540
支持标准的Java应用程序，因此

00:06:09.940 --> 00:06:15.580
这是一个很小的jar文件，它说的更少

00:06:13.540 --> 00:06:17.620
超过70兆，我们一直在努力保持

00:06:15.580 --> 00:06:18.000
它在那边，我们非常接近70 

00:06:17.620 --> 00:06:20.680
兆

00:06:18.000 --> 00:06:22.450
我们将继续努力降低它，以便

00:06:20.680 --> 00:06:24.730
每个切片驱动器更改幻灯片和

00:06:22.450 --> 00:06:26.050
它基于完整的PI或服务器

00:06:24.730 --> 00:06:28.720
最终是最初的

00:06:26.050 --> 00:06:32.470
基于草鱼，所以很饱

00:06:28.720 --> 00:06:34.060
应用服务器，我们有用户

00:06:32.470 --> 00:06:37.030
从很小的角度使用它们

00:06:34.060 --> 00:06:39.010
取决于您的设备百无

00:06:37.030 --> 00:06:39.790
在建筑物上建立数据网格的集群

00:06:39.010 --> 00:06:41.950
云让你

00:06:39.790 --> 00:06:43.930
以及堆的用法或设置方式

00:06:41.950 --> 00:06:50.140
热量显然可以扩展到

00:06:43.930 --> 00:06:51.640
大型应用程序以及

00:06:50.140 --> 00:06:53.890
基本上已经做了很多工作

00:06:51.640 --> 00:06:56.550
一些客户为此进行设计

00:06:53.890 --> 00:06:58.780
云环境，使其具有弹性

00:06:56.550 --> 00:07:01.060
并使其成为容器

00:06:58.780 --> 00:07:02.890
环境，所以它有很多

00:07:01.060 --> 00:07:07.570
在那里工作的能力

00:07:02.890 --> 00:07:09.130
包含支持之类的容器

00:07:07.570 --> 00:07:11.140
用于环境变量替换为

00:07:09.130 --> 00:07:12.580
你移动我从一个包含它

00:07:11.140 --> 00:07:15.850
下一个环境可以改变

00:07:12.580 --> 00:07:21.180
诸如数据库URL之类的东西

00:07:15.850 --> 00:07:25.600
东西，但我也说很小

00:07:21.180 --> 00:07:29.860
所以要运行它，基本上是拿罐子

00:07:25.600 --> 00:07:31.180
您运行的文件-罐子馅饼或微型罐子和

00:07:29.860 --> 00:07:34.570
然后部署将是一个标准

00:07:31.180 --> 00:07:37.740
 java ee部署工件，所以这是

00:07:34.570 --> 00:07:42.760
这些设备上发生了什么

00:07:37.740 --> 00:07:46.420
在这一点上，我们只有一个EJB 

00:07:42.760 --> 00:07:48.130
所以你知道人们不认为

00:07:46.420 --> 00:07:51.190
人们仍然使用agb，但是

00:07:48.130 --> 00:07:53.410
报废了强大的技术，这是

00:07:51.190 --> 00:07:56.980
基本上运行一个EJB细光束

00:07:53.410 --> 00:07:58.360
测量传感器，然后将其推出

00:07:56.980 --> 00:08:00.970
这些选择的帧缓冲区

00:07:58.360 --> 00:08:05.080
这些LED相互在前面做

00:08:00.970 --> 00:08:09.100
在时间上它正在使用

00:08:05.080 --> 00:08:12.940
内部来自您的一些代码

00:08:09.100 --> 00:08:15.070
攻击，但GPIO是否可以访问

00:08:12.940 --> 00:08:17.680
 Raspberry Pi上的GPIO，因此

00:08:15.070 --> 00:08:21.160
从koomer那里获取Eurotech代码

00:08:17.680 --> 00:08:22.660
我相信这个项目

00:08:21.160 --> 00:08:27.760
摆脱所有骆驼的东西

00:08:22.660 --> 00:08:34.330
然后直接在GPIO上工作

00:08:27.760 --> 00:08:36.910
从那以后，还有哦，那跑了

00:08:34.330 --> 00:08:43.270
本质上就像帝国的微型罐子

00:08:36.910 --> 00:08:46.870
像这样说所以我们有什么

00:08:43.270 --> 00:08:49.150
这里有一个运行EJB的微型计算机

00:08:46.870 --> 00:08:52.210
从湿度测量传感器

00:08:49.150 --> 00:08:53.360
在这里运行另一个PI R 

00:08:52.210 --> 00:08:58.490
嵌入式浏览器

00:08:53.360 --> 00:09:01.329
在树莓派上，你会

00:08:58.490 --> 00:09:06.620
能够从那里看到，但如果我

00:09:01.329 --> 00:09:08.269
有效地吹一个你可以看到

00:09:06.620 --> 00:09:11.500
显然湿度测量

00:09:08.269 --> 00:09:31.630
已经上升，所以我实际上可以

00:09:11.500 --> 00:09:31.630
在屏幕上，我可以记得恐怖

00:09:36.910 --> 00:10:03.459
我为什么不记得好，那是

00:10:00.380 --> 00:10:06.440
基本上基本上都是一样

00:10:03.459 --> 00:10:11.660
 shakaar te运行时在

00:10:06.440 --> 00:10:16.070
覆盆子pi所以如果我和你又

00:10:11.660 --> 00:10:25.670
可以看到它正在生成

00:10:16.070 --> 00:10:27.079
数据还可以，所以还尝试运行添加一个

00:10:25.670 --> 00:10:35.209
控制台在这里，但没什么

00:10:27.079 --> 00:10:37.220
工作是行不通的，那又怎样

00:10:35.209 --> 00:10:41.120
我想证明的是，实际上这些

00:10:37.220 --> 00:10:43.220
真的很小，所以堆大小，所以我

00:10:41.120 --> 00:10:45.110
试图从我的树莓对面X 

00:10:43.220 --> 00:10:49.880
 pi到4和笔记本电脑上的控制台

00:10:45.110 --> 00:10:51.500
我们不刷新它，所以馅饼

00:10:49.880 --> 00:10:53.240
像说的制造商正在做

00:10:51.500 --> 00:10:55.310
这个传感器运行约四十

00:10:53.240 --> 00:10:57.980
四十兆字节的热量，所以不是

00:10:55.310 --> 00:10:59.990
产生巨大的负载，或者

00:10:57.980 --> 00:11:02.449
我对Raspberry Pi的影响

00:10:59.990 --> 00:11:05.540
它们是物联网中的大型设备

00:11:02.449 --> 00:11:06.660
世界，但足够小

00:11:05.540 --> 00:11:15.260
跑

00:11:06.660 --> 00:11:17.940
在那里，所以任何关于设置的问题

00:11:15.260 --> 00:11:32.690
在我简要介绍一下之前

00:11:17.940 --> 00:11:37.950
一些代码涉及，所以迈克说

00:11:32.690 --> 00:11:40.260
嘿，微本身就是一个运行时

00:11:37.950 --> 00:11:42.720
支持绝大多数

00:11:40.260 --> 00:11:48.030
 java ee api涵盖了它

00:11:42.720 --> 00:11:51.120
所有的网络api都涵盖了GE JB和

00:11:48.030 --> 00:11:54.330
我们在传感器上运行的是

00:11:51.120 --> 00:11:56.960
简单的单例egb计时器，所以代码

00:11:54.330 --> 00:11:56.960
很简单

00:11:57.050 --> 00:12:08.160
所以我们有一个关于EJB的时间表

00:12:04.590 --> 00:12:13.460
那里基本上是跑步

00:12:08.160 --> 00:12:15.420
每一秒都在运行

00:12:13.460 --> 00:12:18.780
基本上是一小段代码

00:12:15.420 --> 00:12:21.420
这正在创建一个新的衡量标准， 

00:12:18.780 --> 00:12:23.070
它正在与传感器本身交谈以获取

00:12:21.420 --> 00:12:26.210
像我说的那样

00:12:23.070 --> 00:12:28.860
该代码是Eurotech的一部分

00:12:26.210 --> 00:12:33.660
树莓派代码以连接到

00:12:28.860 --> 00:12:37.040
感觉帽子做到这一点，然后从

00:12:33.660 --> 00:12:41.160
从网络角度来看， 

00:12:37.040 --> 00:12:45.390
我的PI上较高的特定功能或

00:12:41.160 --> 00:12:49.020
 micro是CDI CDI的扩展

00:12:45.390 --> 00:12:52.920
是组件依赖注入，但它

00:12:49.020 --> 00:12:54.840
支持事件，Perl micro具有

00:12:52.920 --> 00:12:58.910
支持事件的扩展

00:12:54.840 --> 00:13:02.160
跨网络还可以，所以这个出站

00:12:58.910 --> 00:13:05.250
注释告诉PI或运行时

00:13:02.160 --> 00:13:08.990
我可能会触发的这个事件

00:13:05.250 --> 00:13:12.750
需要在网络中传播

00:13:08.990 --> 00:13:14.850
然后你向那里的买家发泄

00:13:12.750 --> 00:13:16.590
那行代码，然后就消失了

00:13:14.850 --> 00:13:17.830
这就是所有代码来衡量

00:13:16.590 --> 00:13:19.510
实际

00:13:17.830 --> 00:13:21.820
 [音乐] 

00:13:19.510 --> 00:13:24.700
湿度，这实际上是

00:13:21.820 --> 00:13:27.400
黑色运行的应用程序

00:13:24.700 --> 00:13:29.320
树莓派只是没有

00:13:27.400 --> 00:13:31.930
多一点的代码只是为了驱动

00:13:29.320 --> 00:13:33.280
出于演示目的而显示，因此

00:13:31.930 --> 00:13:41.650
发送一个基本的字符串到

00:13:33.280 --> 00:13:42.940
然后在此Raspberry上说帧缓冲区

00:13:41.650 --> 00:13:45.700
 Pi，我们有两个应用程序

00:13:42.940 --> 00:13:49.420
运行其中之一是如果是完整的网络

00:13:45.700 --> 00:13:54.130
最近正在推动的应用程序

00:13:49.420 --> 00:13:56.920
图，他们又说，因为它

00:13:54.130 --> 00:13:58.960
因为运行Java EE，我们不必

00:13:56.920 --> 00:14:00.370
你知道使用任何其他特殊的API 

00:13:58.960 --> 00:14:04.860
只是为了产生这些网站

00:14:00.370 --> 00:14:08.320
小型设备上的应用程序

00:14:04.860 --> 00:14:10.780
这是一个WebSocket应用程序，所以它有一个

00:14:08.320 --> 00:14:16.000
特殊注释来声明

00:14:10.780 --> 00:14:18.820
是租金点，是图时

00:14:16.000 --> 00:14:23.760
浏览器连接到网络

00:14:18.820 --> 00:14:26.020
应用程序的打开方法是

00:14:23.760 --> 00:14:27.430
启动，这基本上是

00:14:26.020 --> 00:14:29.860
注册有一个浏览器

00:14:27.430 --> 00:14:34.120
会议，所以当我们有部门的时候

00:14:29.860 --> 00:14:35.860
我们有两个，那就继续

00:14:34.120 --> 00:14:45.490
跟踪有两个连接

00:14:35.860 --> 00:14:50.320
 WebSocket连接，然后我们有

00:14:45.490 --> 00:14:52.900
这种方法在这里你可以看到它怎么办

00:14:50.320 --> 00:14:55.660
这是观察事件

00:14:52.900 --> 00:14:57.640
网络，因此它具有观察

00:14:55.660 --> 00:14:59.170
哀叹，这是标准的Java EE 

00:14:57.640 --> 00:15:01.180
观察到了

00:14:59.170 --> 00:15:04.870
基本上是观察到的事件

00:15:01.180 --> 00:15:06.550
输入湿度测量值，然后

00:15:04.870 --> 00:15:11.500
这个入站基本上就是说

00:15:06.550 --> 00:15:13.770
将那些事件从网络上清除掉

00:15:11.500 --> 00:15:20.020
当她得到一个事件时，基本上

00:15:13.770 --> 00:15:25.170
遍历每个会话并推送

00:15:20.020 --> 00:15:25.170
向下的WebSocket 

00:15:28.560 --> 00:15:33.010
下推WebSocket JSON字符串

00:15:31.240 --> 00:15:37.210
代表来自

00:15:33.010 --> 00:15:39.490
湿度传感器好吧，再说一遍

00:15:37.210 --> 00:15:44.260
所有的api都是标准的

00:15:39.490 --> 00:15:45.460
它们都是标准的标准api 

00:15:44.260 --> 00:15:49.720
 java ee，所以您可以构建这些

00:15:45.460 --> 00:15:51.070
应用程序然后迅速

00:15:49.720 --> 00:15:53.820
显然会生成图形，因此

00:15:51.070 --> 00:15:57.970
图是html5 

00:15:53.820 --> 00:16:01.390
这是一个html5图形组件

00:15:57.970 --> 00:16:05.050
那是很标准的，什么时候得到

00:16:01.390 --> 00:16:07.740
一个JSON字符串，基本上

00:16:05.050 --> 00:16:17.140
本质上变成了你知道的推动

00:16:07.740 --> 00:16:23.950
每天都可以

00:16:17.140 --> 00:16:25.810
关于不的问题-好的，此外

00:16:23.950 --> 00:16:28.000
在此我们称为网关节点

00:16:25.810 --> 00:16:29.710
在另一个应用程序中运行

00:16:28.000 --> 00:16:32.410
单独的PI或微型，所以就像

00:16:29.710 --> 00:16:34.450
小微服务，这正在做

00:16:32.410 --> 00:16:36.400
与云的连接，所以这是

00:16:34.450 --> 00:16:40.740
或者在这种情况下连接到MQTT 

00:16:36.400 --> 00:16:44.110
经纪人正在我的笔记本电脑上运行

00:16:40.740 --> 00:16:47.320
再次使用标准Java 

00:16:44.110 --> 00:16:49.450
 EE，我们在PI Aura中有一个名为

00:16:47.320 --> 00:16:51.280
云连接器已经建立了一堆

00:16:49.450 --> 00:16:52.840
消息系统的连接器

00:16:51.280 --> 00:16:56.230
不是JMS，这将是标准

00:16:52.840 --> 00:16:58.750
 Java EE，所以我们有一个MQTT 

00:16:56.230 --> 00:17:02.980
从一个下水道服务总线Apache 

00:16:58.750 --> 00:17:04.420
小牛小牛车，我是SQ的简单

00:17:02.980 --> 00:17:06.610
队列服务，以便您获取数据

00:17:04.420 --> 00:17:11.290
使用这些工具很容易地进入云

00:17:06.610 --> 00:17:13.540
连接器，所以有一堆

00:17:11.290 --> 00:17:14.920
元数据和注释是

00:17:13.540 --> 00:17:20.320
定义所谓的连接

00:17:14.920 --> 00:17:21.940
工厂，所以这基本上告诉你

00:17:20.320 --> 00:17:24.250
还有改编成什么Weald What 

00:17:21.940 --> 00:17:28.420
我们部署这是一个标准组件

00:17:24.250 --> 00:17:33.520
从payara，您有MQTT连接

00:17:28.420 --> 00:17:37.650
工厂，然后有mqtt 

00:17:33.520 --> 00:17:37.650
属性，所以我有服务器URI 

00:17:38.120 --> 00:17:43.520
好吧，当我们收到其中之一

00:17:42.230 --> 00:17:44.990
消息再次，所以我们没有观察到

00:17:43.520 --> 00:17:46.700
再次入站，所以当我们得到一个

00:17:44.990 --> 00:17:49.640
这些网络事件

00:17:46.700 --> 00:17:56.030
它使用连接的微服务

00:17:49.640 --> 00:17:57.430
工厂，基本上需要

00:17:56.030 --> 00:18:00.320
测量将其写入字节数组

00:17:57.430 --> 00:18:08.440
然后将其推出给mqtt 

00:18:00.320 --> 00:18:14.510
在测试主题上发布测试还可以， 

00:18:08.440 --> 00:18:17.510
然后在这台笔记本电脑上，如果可以的话

00:18:14.510 --> 00:18:19.700
看到它，但我又有另一个微

00:18:17.510 --> 00:18:22.040
正在监听该MQTT的服务

00:18:19.700 --> 00:18:25.600
 Java EE和MQTT主题

00:18:22.040 --> 00:18:34.490
连接器并打印出消息

00:18:25.600 --> 00:18:36.670
就像我不知道为什么要用这个

00:18:34.490 --> 00:18:36.670
对于

00:18:52.309 --> 00:19:02.250
好，这样您就可以看到其中的值51 

00:18:57.650 --> 00:19:08.549
如果我告诉他们希望

00:19:02.250 --> 00:19:10.110
应该上升好吧，这是在64 

00:19:08.549 --> 00:19:12.539
分钟，基本上基本上又是

00:19:10.110 --> 00:19:14.220
微型服务器拉动和mqtt 

00:19:12.539 --> 00:19:19.710
蚊子在我身上运行的消息

00:19:14.220 --> 00:19:21.570
笔记本电脑，这就是再次推动

00:19:19.710 --> 00:19:24.390
出来，所以这个家伙正在推出

00:19:21.570 --> 00:19:35.460
事件进入正在运行的蚊子中介

00:19:24.390 --> 00:19:38.970
我的Linux笔记本电脑还可以，所以说我们

00:19:35.460 --> 00:19:42.830
在Paora上有一个项目

00:19:38.970 --> 00:19:42.830
为Java EE构建这些连接器

00:19:44.179 --> 00:19:51.720
内存让我们说

00:19:46.110 --> 00:19:54.000
 Kafka sqs服务波士顿MQTT，所以这些

00:19:51.720 --> 00:19:55.950
连接器是标准的，我称之为JCA 

00:19:54.000 --> 00:20:00.419
他们应该在其他上工作的连接器

00:19:55.950 --> 00:20:05.370
 Java您像野火一样运行时，它们

00:20:00.419 --> 00:20:08.340
正在推动其基本可用

00:20:05.370 --> 00:20:09.960
从这些设备上获取数据

00:20:08.340 --> 00:20:12.020
直接进入云端，诸如此类

00:20:09.960 --> 00:20:12.020
那

00:20:14.510 --> 00:20:19.320
那只是我们做的一个例子

00:20:17.220 --> 00:20:20.820
过去去公车，但我没有

00:20:19.320 --> 00:20:28.500
想依靠网络来推动它

00:20:20.820 --> 00:20:32.190
迁移到云中，因此一旦获得数据

00:20:28.500 --> 00:20:34.380
在物联网设备上，这些PI是微型的

00:20:32.190 --> 00:20:36.539
在雅加达二世，您实际上可以

00:20:34.380 --> 00:20:38.159
完全相同的API完全相同

00:20:36.539 --> 00:20:40.169
您必须具备的编程知识

00:20:38.159 --> 00:20:43.070
然后也建立服务器端

00:20:40.169 --> 00:20:45.870
因此您可以使用相同的PI R micros 

00:20:43.070 --> 00:20:47.250
这两个聚集在一起

00:20:45.870 --> 00:20:51.179
这就是事件之间发生的方式

00:20:47.250 --> 00:20:54.090
他们甚至在树莓派的

00:20:51.179 --> 00:20:55.590
他们正在聚集和共享数据

00:20:54.090 --> 00:20:58.290
然后您可以在云上

00:20:55.590 --> 00:21:00.210
将其扩展为大规模的Multi multi 

00:20:58.290 --> 00:21:02.360
千兆内存数据存储（如果您） 

00:21:00.210 --> 00:21:07.590
想要但完全一样

00:21:02.360 --> 00:21:09.930
技术相同的api，因此

00:21:07.590 --> 00:21:12.810
可能建立您知道的横向扩展

00:21:09.930 --> 00:21:14.910
其中数百个正在经历

00:21:12.810 --> 00:21:17.010
网关节点，然后将数据推送到

00:21:14.910 --> 00:21:19.200
云环境并使用相同的环境

00:21:17.010 --> 00:21:28.470
功率和微分将其存储在

00:21:19.200 --> 00:21:30.780
内存中的数据网格，所以如果我们这样做

00:21:28.470 --> 00:21:37.410
这是将显示的代码

00:21:30.780 --> 00:21:40.100
在云这边的四个是

00:21:37.410 --> 00:21:43.020
实际将使用的代码

00:21:40.100 --> 00:21:44.580
检索数据并将其推入数据

00:21:43.020 --> 00:21:49.530
网格，因此数据网格是内存中的

00:21:44.580 --> 00:21:51.810
键值存储，所以您可以说集群

00:21:49.530 --> 00:21:53.160
所有的payara micros向上然后存储

00:21:51.810 --> 00:21:57.840
来自数百个的所有测量

00:21:53.160 --> 00:21:59.460
设备存储到任何内存数据中

00:21:57.840 --> 00:22:04.410
在服务器端与

00:21:59.460 --> 00:22:07.410
会在mqtt上，我们有什么

00:22:04.410 --> 00:22:10.020
被称为消息驱动的bean 

00:22:07.410 --> 00:22:13.320
这种情况下将作为您的服务

00:22:10.020 --> 00:22:17.340
价格与MQTT相同，我们有

00:22:13.320 --> 00:22:19.940
所谓的缓存好吧，所以在

00:22:17.340 --> 00:22:24.150
收到消息时的类似方法

00:22:19.940 --> 00:22:28.050
它基本上吸收了湿度信息

00:22:24.150 --> 00:22:30.150
消息中的度量创建一个

00:22:28.050 --> 00:22:31.710
传感器上有钥匙的新系列

00:22:30.150 --> 00:22:33.420
名称，然后将其推入网格

00:22:31.710 --> 00:22:36.150
那就是我们所有的代码

00:22:33.420 --> 00:22:38.300
要求保持该测量

00:22:36.150 --> 00:22:47.150
内存中的传感器名称

00:22:38.300 --> 00:22:50.100
大型云端存储和

00:22:47.150 --> 00:22:53.370
再次找回他们，这可能是

00:22:50.100 --> 00:22:55.320
在设备上使用的以及jakarta ii 

00:22:53.370 --> 00:22:59.550
显然支持完全宁静的网络

00:22:55.320 --> 00:23:01.620
服务以及代码检索

00:22:59.550 --> 00:23:04.040
该数据网格中的内容是

00:23:01.620 --> 00:23:04.040
实质上

00:23:05.130 --> 00:23:10.860
从字面上看，您基本上将其挂接到

00:23:08.250 --> 00:23:14.910
相同的网格，如果有

00:23:10.860 --> 00:23:16.230
要求传递您的传感器名称

00:23:14.910 --> 00:23:19.530
然后可以检索所有数据， 

00:23:16.230 --> 00:23:30.180
将其作为JSON发送到客户端设备

00:23:19.530 --> 00:23:36.060
字符串好吧，那就是一个演示，如果

00:23:30.180 --> 00:23:42.620
您喜欢在真实环境中运行的真实代码

00:23:36.060 --> 00:23:45.210
较小的设备，为什么要使用

00:23:42.620 --> 00:23:47.910
这些设备上的Jakarta EE喜欢说

00:23:45.210 --> 00:23:50.490
 PI R micro很小，因此可以在

00:23:47.910 --> 00:23:52.670
大约30 40 MB的JVM堆

00:23:50.490 --> 00:23:56.790
显然，您将有一个JVM开销

00:23:52.670 --> 00:23:58.050
但是你可以跑步，你知道吗

00:23:56.790 --> 00:24:00.690
可能在未来的将来

00:23:58.050 --> 00:24:02.970
 Java 9j链接和Java 10需要缩减

00:24:00.690 --> 00:24:04.500
恰好满足您的需求

00:24:02.970 --> 00:24:06.870
还附带了一堆标准的api 

00:24:04.500 --> 00:24:08.820
因此您不必学习新手

00:24:06.870 --> 00:24:10.740
约克，你不必学习

00:24:08.820 --> 00:24:17.520
为这些建立任何新技术

00:24:10.740 --> 00:24:19.890
设备，因此para micro本身具有JPA和

00:24:17.520 --> 00:24:25.710
它具有嵌入式数据库，因此

00:24:19.890 --> 00:24:28.200
设备可以使用标准的JPA数据库

00:24:25.710 --> 00:24:30.960
如果它带有嵌入式的h2 

00:24:28.200 --> 00:24:35.430
一个就可以存储和转发数据

00:24:30.960 --> 00:24:39.530
本地设备，以便您可以建立网络

00:24:35.430 --> 00:24:42.870
使用标准api的应用程序

00:24:39.530 --> 00:24:44.100
但是PI或Micro支持您知道JSF 

00:24:42.870 --> 00:24:45.930
有点像

00:24:44.100 --> 00:24:49.170
重量级，但它支持宁静的网络

00:24:45.930 --> 00:24:50.490
将WebSockets HTTP服务到所有

00:24:49.170 --> 00:24:53.370
你需要建造的东西说

00:24:50.490 --> 00:24:58.020
嵌入式嵌入式Web应用程序

00:24:53.370 --> 00:25:00.000
设备上的Web控制台，我们拥有JC 

00:24:58.020 --> 00:25:03.090
这样我们就可以连接到消息传递系统

00:25:00.000 --> 00:25:06.150
要获取数据，所以我再次说

00:25:03.090 --> 00:25:08.580
在包装盒上有一个标准品，然后按一下

00:25:06.150 --> 00:25:14.010
支持，因此您可以通过mqtt发送数据

00:25:08.580 --> 00:25:18.570
关设备有标准

00:25:14.010 --> 00:25:22.410
 Carter EE中的并发API 

00:25:18.570 --> 00:25:24.780
因此我们可以非常简单地构建异步

00:25:22.410 --> 00:25:27.750
反应性多线程应用程序

00:25:24.780 --> 00:25:32.700
使用并发API 

00:25:27.750 --> 00:25:37.050
用Java re'构建嵌入到大约

00:25:32.700 --> 00:25:39.540
 abet嵌入式应用程序的CDI也是

00:25:37.050 --> 00:25:45.420
作为高级依赖的标准

00:25:39.540 --> 00:25:49.500
注入框架，因此您可以使用它

00:25:45.420 --> 00:25:53.190
以及我们也有不懈的支持

00:25:49.500 --> 00:25:55.170
这样您就可以在

00:25:53.190 --> 00:25:58.050
与之通信的设备

00:25:55.170 --> 00:26:02.070
设备应该是jax-rs，我们有JSON 

00:25:58.050 --> 00:26:03.630
支持，所以它也有休息客户

00:26:02.070 --> 00:26:06.000
支持，以便您可以休息

00:26:03.630 --> 00:26:18.210
实际上作为客户端来调用其他

00:26:06.000 --> 00:26:21.240
来自设备的服务也是如此

00:26:18.210 --> 00:26:25.050
雅加达与物联网有关吗

00:26:21.240 --> 00:26:27.630
显然是的，我希望你知道

00:26:25.050 --> 00:26:31.260
我们可以证明这些

00:26:27.630 --> 00:26:33.600
只是我们做的一件事

00:26:31.260 --> 00:26:37.230
关于我们何时建立PI或微型计算机是为了

00:26:33.600 --> 00:26:39.870
带给雅加达一个中风的Java EE 

00:26:37.230 --> 00:26:42.150
新开发者基本上是因为

00:26:39.870 --> 00:26:46.260
没有所有的大型应用服务器

00:26:42.150 --> 00:26:48.810
你过去的重量级人物

00:26:46.260 --> 00:26:51.870
会认为这基本上是一个小

00:26:48.810 --> 00:26:53.520
运行时，这样就可以构建

00:26:51.870 --> 00:26:56.550
您是Java开发人员，可以构建

00:26:53.520 --> 00:27:00.750
运行pi或micro so的物联网应用程序

00:26:56.550 --> 00:27:03.180
您可以在小型平台上构建应用程序

00:27:00.750 --> 00:27:05.100
像树莓派这样的设备，还有

00:27:03.180 --> 00:27:09.270
一些有趣的东西，我们

00:27:05.100 --> 00:27:11.040
知道，我们知道，伙计们是一个遥控器

00:27:09.270 --> 00:27:13.230
控制车叫休息控制

00:27:11.040 --> 00:27:16.070
端点并在ro上运行感到惊讶

00:27:13.230 --> 00:27:20.340
但是从认真的角度来看，你可以

00:27:16.070 --> 00:27:22.110
有很多可能数以百万计的

00:27:20.340 --> 00:27:24.090
世界各地的Java EE开发人员

00:27:22.110 --> 00:27:26.760
也许不想学习新的API 

00:27:24.090 --> 00:27:29.760
对新设备进行物联网或在

00:27:26.760 --> 00:27:32.039
云PI或Micro基本上是设计好的

00:27:29.760 --> 00:27:34.080
把那些人带到某个地方

00:27:32.039 --> 00:27:36.629
你知道构建云应用程序

00:27:34.080 --> 00:27:39.960
使用相同的构建物联网应用程序

00:27:36.629 --> 00:27:45.139
 API xeno，因为相同的代码可以喜欢

00:27:39.960 --> 00:27:53.220
在那上面运行，或者我可以在巨大的云中运行

00:27:45.139 --> 00:27:54.779
多标签和节点集群，所以接下来

00:27:53.220 --> 00:27:57.899
这里的脚步相当小

00:27:54.779 --> 00:28:00.720
所以那里有一个下载链接

00:27:57.899 --> 00:28:06.059
演示代码在github上的链接上

00:28:00.720 --> 00:28:09.599
好吧，走吧，我的意思是我们说

00:28:06.059 --> 00:28:11.279
所有步骤都是开源的，所以这

00:28:09.599 --> 00:28:18.269
该演示的整个代码是开放的

00:28:11.279 --> 00:28:21.450
来源和github上的任何问题

00:28:18.269 --> 00:28:39.509
所以任何人都想在

00:28:21.450 --> 00:28:42.590
传感器之类的秘密是

00:28:39.509 --> 00:28:44.849
其实没有很多不同，好吧

00:28:42.590 --> 00:28:47.759
最大的区别之一是薪酬

00:28:44.849 --> 00:28:52.619
基于微伺服的OSGi运行时

00:28:47.759 --> 00:28:57.269
好的Paora micro下面不使用

00:28:52.619 --> 00:28:59.759
 OSGi，所以开销有点慢

00:28:57.269 --> 00:29:04.950
因此，payara服务器

00:28:59.759 --> 00:29:06.299
支持完整的Java 8 w8 API，因此

00:29:04.950 --> 00:29:07.769
这里有人，我们不

00:29:06.299 --> 00:29:12.659
支持您不支持任何

00:29:07.769 --> 00:29:14.820
旧版旧版Java ee，因此无需成为2.1 

00:29:12.659 --> 00:29:17.879
或任何丰富的旧事物

00:29:14.820 --> 00:29:21.749
服务器没有小屋或其他任何东西

00:29:17.879 --> 00:29:23.999
在这个我微，它没有

00:29:21.749 --> 00:29:25.889
支持没有嵌入式JMS 

00:29:23.999 --> 00:29:28.889
经纪人或任何喙或东西

00:29:25.889 --> 00:29:30.599
完整的服务器会拥有，但是

00:29:28.889 --> 00:29:33.830
与此完全相同的代码

00:29:30.599 --> 00:29:33.830
像它周围的包装纸

00:29:42.390 --> 00:29:57.490
我们做到了，是的，我们曾经有一个微型

00:29:55.750 --> 00:30:00.820
仅配置文件，因此实际上payara micro 

00:29:57.490 --> 00:30:03.910
也可能支持micro profile 1.3 

00:30:00.820 --> 00:30:06.280
从昨天开始，您释放

00:30:03.910 --> 00:30:10.750
昨天我们习惯于保持

00:30:06.280 --> 00:30:11.860
 PI我们的微观概况，实际上

00:30:10.750 --> 00:30:14.560
基本上只有迈克的支持

00:30:11.860 --> 00:30:16.840
个人资料api的操作已停止

00:30:14.560 --> 00:30:17.830
因为资源差异不是

00:30:16.840 --> 00:30:20.440
重大

00:30:17.830 --> 00:30:22.090
好吧，有点PI了

00:30:20.440 --> 00:30:24.370
大小合理的计算机不在

00:30:22.090 --> 00:30:27.370
大概PI会启动几个

00:30:24.370 --> 00:30:30.970
秒，因此IR Mike配置文件启动可能会倾斜

00:30:27.370 --> 00:30:32.440
在半秒内成为第一部分， 

00:30:30.970 --> 00:30:37.570
内存使用情况并没有什么不同

00:30:32.440 --> 00:30:42.010
所以我们实际上专注于

00:30:37.570 --> 00:30:44.350
保留完整的api并制作

00:30:42.010 --> 00:30:47.140
它尽可能的小

00:30:44.350 --> 00:30:48.490
模块化，但这是一个做

00:30:47.140 --> 00:30:58.660
营销功能不是工程

00:30:48.490 --> 00:31:00.910
功能，所以我们不必担心

00:30:58.660 --> 00:31:05.249
非常感谢你

00:31:00.910 --> 00:31:05.249
 [掌声] 

