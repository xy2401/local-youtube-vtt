WEBVTT
Kind: captions
Language: zh-Hans

00:00:06.440 --> 00:00:13.740
好吧，然后嗨，欢迎来到我的

00:00:10.080 --> 00:00:16.170
 Java EE或提花EE上的会话或

00:00:13.740 --> 00:00:18.300
微观概况或也许所有这些

00:00:16.170 --> 00:00:20.160
会议将为您提供帮助

00:00:18.300 --> 00:00:22.710
同时获得更好的概述

00:00:20.160 --> 00:00:25.740
企业Java中有什么

00:00:22.710 --> 00:00:27.539
今天当然要显示一点

00:00:25.740 --> 00:00:31.109
我们可以做的一些很酷的演示和东西

00:00:27.539 --> 00:00:33.510
围绕Enterprise Java做得很好

00:00:31.109 --> 00:00:35.370
您好，我叫塞巴斯蒂安- 

00:00:33.510 --> 00:00:40.290
 nur在德国慕尼黑出生和长大

00:00:35.370 --> 00:00:43.290
因为从字面上讲两个星期，我现在

00:00:40.290 --> 00:00:45.870
在这个叫IBM的公司工作

00:00:43.290 --> 00:00:49.200
从此成为Java开发的主要倡导者

00:00:45.870 --> 00:00:52.530
实际上是14天前，而我的

00:00:49.200 --> 00:00:54.420
当然碰巧继续谈

00:00:52.530 --> 00:00:57.379
企业软件上的企业Java 

00:00:54.420 --> 00:01:00.989
总的来说，很多很棒的东西

00:00:57.379 --> 00:01:03.180
相信，我很高兴来到这里

00:01:00.989 --> 00:01:05.339
 wrox比利时-好告诉你

00:01:03.180 --> 00:01:07.740
我们在一起的一点点

00:01:05.339 --> 00:01:09.689
企业软件，专门用于

00:01:07.740 --> 00:01:12.210
企业项目做得好

00:01:09.689 --> 00:01:16.320
技术，我们可以建立我们的项目

00:01:12.210 --> 00:01:20.790
因此，在快速民意调查中谁拥有你

00:01:16.320 --> 00:01:25.320
至今使用Java EE /-card EE 

00:01:20.790 --> 00:01:28.430
好吧，你们大多数人

00:01:25.320 --> 00:01:32.490
我什至玩过微缩

00:01:28.430 --> 00:01:36.060
好吧，没事的人少，所以我

00:01:32.490 --> 00:01:38.130
会很快向您展示我们为什么要创业

00:01:36.060 --> 00:01:40.560
开发人员Java EE开发人员应注意

00:01:38.130 --> 00:01:44.280
关于或可能关心微观概况

00:01:40.560 --> 00:01:47.220
很好，首先只有几件事

00:01:44.280 --> 00:01:50.970
关于Java EE的好地方

00:01:47.220 --> 00:01:52.950
据这个家伙说，Java EE上市了

00:01:50.970 --> 00:01:54.899
有很多事情，例如，如果我们

00:01:52.950 --> 00:01:57.210
将Java EE修改为当前版本

00:01:54.899 --> 00:02:00.000
例如我们有很多标准

00:01:57.210 --> 00:02:03.390
当然还有很多事情

00:02:00.000 --> 00:02:06.210
运行时支持，我们可能不在乎

00:02:03.390 --> 00:02:09.149
所有这些事情都是正确的，所以我

00:02:06.210 --> 00:02:12.420
意味着谁想反正用肥皂

00:02:09.149 --> 00:02:13.830
或所有类似的东西，但我们有一些

00:02:12.420 --> 00:02:16.050
我们的标准

00:02:13.830 --> 00:02:18.030
我们开发人员通常真的很喜欢

00:02:16.050 --> 00:02:20.520
增加很多价值，而我们通常

00:02:18.030 --> 00:02:22.740
在项目中的使用和需求

00:02:20.520 --> 00:02:24.830
诸如CDI Jax之类的东西可以解决问题

00:02:22.740 --> 00:02:28.320
 JSON处理或绑定的东西

00:02:24.830 --> 00:02:30.990
数据库交易ejbs很好新

00:02:28.320 --> 00:02:33.000
版本实际上是这样的

00:02:30.990 --> 00:02:35.340
对，所以这就是我们通常使用的

00:02:33.000 --> 00:02:37.650
作为企业的日常工作

00:02:35.340 --> 00:02:40.500
开发人员是对的，所以这些都是好的

00:02:37.650 --> 00:02:43.800
这是组成大部分的部分

00:02:40.500 --> 00:02:46.080
今天的标准，但也

00:02:43.800 --> 00:02:49.290
诚然，有几件事

00:02:46.080 --> 00:02:52.230
甚至Java八都失踪了

00:02:49.290 --> 00:02:53.970
如果我们关心现代和企业

00:02:52.230 --> 00:02:58.500
如果我们在乎微应用

00:02:53.970 --> 00:03:01.770
服务以及一切都好，我们

00:02:58.500 --> 00:03:04.080
至少缺少一些东西

00:03:01.770 --> 00:03:07.260
从标准角度来看未涵盖

00:03:04.080 --> 00:03:10.280
像弹性这样的东西，如果

00:03:07.260 --> 00:03:12.720
你想建立像

00:03:10.280 --> 00:03:14.940
具有容错能力或

00:03:12.720 --> 00:03:18.150
诸如断路器或

00:03:14.940 --> 00:03:19.620
隔板当然可以，但是

00:03:18.150 --> 00:03:22.739
您将必须自己实施

00:03:19.620 --> 00:03:24.570
在几行代码中

00:03:22.739 --> 00:03:27.030
课上有很多

00:03:24.570 --> 00:03:30.570
例子和模式如何

00:03:27.030 --> 00:03:33.209
使用Java EAP做到这一点，但是

00:03:30.570 --> 00:03:35.160
至少还有一些工作要做

00:03:33.209 --> 00:03:37.380
截至目前，它并没有开箱即用

00:03:35.160 --> 00:03:39.600
例如今天的监控是另一回事

00:03:37.380 --> 00:03:41.970
当然，您可以忽略所有

00:03:39.600 --> 00:03:44.430
使用JSON格式的一种数据或

00:03:41.970 --> 00:03:46.200
使用Prometheus兼容格式，但

00:03:44.430 --> 00:03:47.940
仍然需要在

00:03:46.200 --> 00:03:50.940
至少一堂课或类似的事情

00:03:47.940 --> 00:03:53.610
正确的配置是另一部分或

00:03:50.940 --> 00:03:55.769
再次进行分布式跟踪

00:03:53.610 --> 00:03:59.400
由一个特定的事物添加，但不是

00:03:55.769 --> 00:04:01.410
从标准来看，这就是我们

00:03:59.400 --> 00:04:04.920
如果您考虑应用Java EE 

00:04:01.410 --> 00:04:07.140
 /-从EE角度看，因此对于

00:04:04.920 --> 00:04:10.410
一直在想的你

00:04:07.140 --> 00:04:13.590
 Java EE和提花EE很小

00:04:10.410 --> 00:04:16.709
甚至实际上提花EE也会开始

00:04:13.590 --> 00:04:18.660
从Java EE中断的地方开始

00:04:16.709 --> 00:04:21.120
现在他们你可以说同样的意思

00:04:18.660 --> 00:04:23.729
事情，所以我只写了Java提花EE 

00:04:21.120 --> 00:04:26.070
我仅使用Java的应用程序

00:04:23.729 --> 00:04:27.650
标准，你没有说谎，所以

00:04:26.070 --> 00:04:30.600
就算是现在

00:04:27.650 --> 00:04:32.940
现在如何建立像这样的权利

00:04:30.600 --> 00:04:36.960
如何填补这些空白

00:04:32.940 --> 00:04:40.020
这就是Mike个人资料加入的地方

00:04:36.960 --> 00:04:43.680
因此，微轮廓始于

00:04:40.020 --> 00:04:45.900
主要是我首先看到两个动机

00:04:43.680 --> 00:04:49.500
所有的一切都始于

00:04:45.900 --> 00:04:52.140
 JCP整个流程以及Java 

00:04:49.500 --> 00:04:56.220
 EE的发展有点慢

00:04:52.140 --> 00:04:57.960
是的，是的，我们无法添加

00:04:56.220 --> 00:05:00.420
全面创新

00:04:57.960 --> 00:05:02.790
虽然我们还有这些东西

00:05:00.420 --> 00:05:05.640
他们从标准中丢失了

00:05:02.790 --> 00:05:09.570
我刚刚展示的东西

00:05:05.640 --> 00:05:12.030
所以微轮廓的目标是针对一些

00:05:09.570 --> 00:05:13.560
供应商走到一起说好吧，我们

00:05:12.030 --> 00:05:17.850
想要填补这些空白，我们想要

00:05:13.560 --> 00:05:20.490
促进整个生态系统发展

00:05:17.850 --> 00:05:22.530
一个标准的观点但是

00:05:20.490 --> 00:05:24.720
就像背叛者标准，其中多个

00:05:22.530 --> 00:05:26.790
供应商不断发展，我们可以建立

00:05:24.720 --> 00:05:30.420
只要您知道技术可以增加一些

00:05:26.790 --> 00:05:32.310
正确地填补这些空白的价值

00:05:30.420 --> 00:05:35.220
我看到的第二个动机是

00:05:32.310 --> 00:05:38.670
至少能够满足需求

00:05:35.220 --> 00:05:40.680
用于微微服务运行时或

00:05:38.670 --> 00:05:43.620
换句话说，您的运行时非常苗条

00:05:40.680 --> 00:05:45.150
可以通过交付运行时来精简

00:05:43.620 --> 00:05:47.070
与应用程序一起

00:05:45.150 --> 00:05:49.500
像一个独立的罐子或肥罐

00:05:47.070 --> 00:05:52.320
并非真正支持的方法

00:05:49.500 --> 00:05:55.980
从至少不是之前

00:05:52.320 --> 00:05:57.660
 Java EE方面的标准化方法

00:05:55.980 --> 00:06:00.600
那是第二个

00:05:57.660 --> 00:06:03.210
背后的动机，所以我们在这里

00:06:00.600 --> 00:06:05.880
微观概况，我们有一些

00:06:03.210 --> 00:06:09.390
里面的东西

00:06:05.880 --> 00:06:13.530
到今天为止的整体保护伞

00:06:09.390 --> 00:06:15.480
而且非常自以为是的清单

00:06:13.530 --> 00:06:18.750
我包含微轮廓的零件

00:06:15.480 --> 00:06:23.330
首先，它始于

00:06:18.750 --> 00:06:25.530
使用CDI jax-rs和JSONP 

00:06:23.330 --> 00:06:28.650
如果你想建造的话就足够了

00:06:25.530 --> 00:06:32.240
非常苗条且独立

00:06:28.650 --> 00:06:36.570
无状态的应用程序

00:06:32.240 --> 00:06:38.690
无状态功能加上我们现在拥有

00:06:36.570 --> 00:06:40.920
还有一些不是

00:06:38.690 --> 00:06:42.810
如此简单的标准技术

00:06:40.920 --> 00:06:45.650
他们三个来自Java 

00:06:42.810 --> 00:06:47.730
已经有雨伞了，现在我们加球

00:06:45.650 --> 00:06:50.690
微型配置文件中的配置

00:06:47.730 --> 00:06:53.640
例如配置或容错

00:06:50.690 --> 00:06:56.400
指标进行监控，所有这些

00:06:53.640 --> 00:07:01.110
事物和微观特征-哦，那是

00:06:56.400 --> 00:07:04.890
基于Java e8，我们有这些

00:07:01.110 --> 00:07:07.530
这些项目以及其他一些项目

00:07:04.890 --> 00:07:10.050
我们可以在其中构建应用程序的地方

00:07:07.530 --> 00:07:14.880
那你为什么这么称呼

00:07:10.050 --> 00:07:17.310
好零件清单，因为如果

00:07:14.880 --> 00:07:20.310
您现在再往前看一点

00:07:17.310 --> 00:07:22.620
其实想结合微轮廓

00:07:20.310 --> 00:07:25.440
使用Java EE，或者至少我们可以

00:07:22.620 --> 00:07:28.140
结合为什么，因为整体

00:07:25.440 --> 00:07:31.110
微观轮廓的思想基础是

00:07:28.140 --> 00:07:32.580
 Java EE和Java EE技术如此

00:07:31.110 --> 00:07:35.430
换句话说，我们可以结合这些

00:07:32.580 --> 00:07:37.380
他们一起工作的技术

00:07:35.430 --> 00:07:40.290
彼此，因为最终他们是

00:07:37.380 --> 00:07:42.630
实际上其中一部分是Java技术

00:07:40.290 --> 00:07:45.720
例如看到右眼或杰克的眼睛

00:07:42.630 --> 00:07:47.550
逮捕Jason P和Jason B，因此

00:07:45.720 --> 00:07:50.340
结合这些技术，我们可以

00:07:47.550 --> 00:07:54.090
实际上填补了Java EE的这些空白

00:07:50.340 --> 00:07:57.690
现在在发展方面仍然如此

00:07:54.090 --> 00:08:00.900
模特基本上喜欢哪个东西

00:07:57.690 --> 00:08:04.740
让我们选择正确的做法

00:08:00.900 --> 00:08:07.230
我们项目的基础

00:08:04.740 --> 00:08:10.800
作为发展的第一选择

00:08:07.230 --> 00:08:13.500
选项是使用纯Java EE / 2卡

00:08:10.800 --> 00:08:16.590
即只正确使用项目

00:08:13.500 --> 00:08:18.600
雨伞里面是什么，我们可以做

00:08:16.590 --> 00:08:20.940
这是很多行之有效的技术

00:08:18.600 --> 00:08:24.210
你知道它包括了大多数东西

00:08:20.940 --> 00:08:26.490
我们将需要的，而且最重要的是

00:08:24.210 --> 00:08:28.770
那里的开发人员知道API 

00:08:26.490 --> 00:08:29.940
已经是正确的了

00:08:28.770 --> 00:08:31.620
一段时间

00:08:29.940 --> 00:08:34.650
我们都知道标准

00:08:31.620 --> 00:08:37.290
注释和东西都很好

00:08:34.650 --> 00:08:39.479
很有道理，但正如我所说

00:08:37.290 --> 00:08:42.990
我们有一些缺失的部分，一些差距

00:08:39.479 --> 00:08:45.570
如果我们从另一方面来看

00:08:42.990 --> 00:08:48.180
微型个人资料，如果我们说确定，我们将

00:08:45.570 --> 00:08:50.640
不同的选项，我们全部跳过Java EE 

00:08:48.180 --> 00:08:53.160
在一起说我们完全建立我们的

00:08:50.640 --> 00:08:54.190
微型轮廓的应用程序-哦，如此

00:08:53.160 --> 00:08:57.100
这样说

00:08:54.190 --> 00:08:59.379
只有这样，我们当然最终会

00:08:57.100 --> 00:09:01.449
可以媲美的东西II 

00:08:59.379 --> 00:09:04.720
苗条而轻巧的权利，我们只有

00:09:01.449 --> 00:09:07.600
一堆与此附带的标准

00:09:04.720 --> 00:09:11.230
或事实上的标准，只有现代

00:09:07.600 --> 00:09:14.699
 api和东西，但实际上几乎没有

00:09:11.230 --> 00:09:17.050
足以在生产时运行

00:09:14.699 --> 00:09:18.370
企业应用程序或至少

00:09:17.050 --> 00:09:19.029
应用程序多一点

00:09:18.370 --> 00:09:21.339
复杂

00:09:19.029 --> 00:09:24.730
例如交易时需要

00:09:21.339 --> 00:09:27.670
或数据库某种持久性

00:09:24.730 --> 00:09:30.699
因为这不包含在micro中

00:09:27.670 --> 00:09:32.709
开箱即用

00:09:30.699 --> 00:09:34.269
微观资料，所以几乎没有

00:09:32.709 --> 00:09:36.550
缺乏而其他人

00:09:34.269 --> 00:09:38.199
并发工具至少仍然存在

00:09:36.550 --> 00:09:40.810
计划在微观档案中添加

00:09:38.199 --> 00:09:44.680
还是定时器和

00:09:40.810 --> 00:09:47.259
异步行为至少达到

00:09:44.680 --> 00:09:50.500
在某种程度上也是微观的

00:09:47.259 --> 00:09:52.689
一个人还不够，但现在我拿走了

00:09:50.500 --> 00:09:56.110
那实际上是使

00:09:52.689 --> 00:09:59.069
将这两件事结合起来的感觉

00:09:56.110 --> 00:10:03.040
使用普通的Java EE构建我们的项目

00:09:59.069 --> 00:10:06.069
加上微轮廓，我们实际上很好

00:10:03.040 --> 00:10:07.990
 Java的他仍然有这些差距，所以

00:10:06.069 --> 00:10:10.209
首先我们得到了证明

00:10:07.990 --> 00:10:12.670
技术，我们拥有的已知api 

00:10:10.209 --> 00:10:15.699
在Java EE中，加上所有这些

00:10:12.670 --> 00:10:17.980
缺少的额外好处

00:10:15.699 --> 00:10:20.470
以Java EE配置为例

00:10:17.980 --> 00:10:23.069
弹性还是我们拥有所有指标

00:10:20.470 --> 00:10:26.560
和监控数据并进行公开跟踪

00:10:23.069 --> 00:10:28.180
在-这很有意义

00:10:26.560 --> 00:10:30.279
结合这些技术而不是说

00:10:28.180 --> 00:10:33.850
哦，我们仅使用微轮廓

00:10:30.279 --> 00:10:36.579
我们也可以使用非常相似的

00:10:33.850 --> 00:10:41.050
开发和部署模型，如果

00:10:36.579 --> 00:10:43.149
我们有一个支持Java EE的应用程序

00:10:41.050 --> 00:10:44.850
服务器，我知道这个词差不多

00:10:43.149 --> 00:10:48.069
这些天是侮辱，但是

00:10:44.850 --> 00:10:50.589
 Java EE的应用程序服务器运行时

00:10:48.069 --> 00:10:52.990
也能够运行micro a 

00:10:50.589 --> 00:10:54.819
微观概况，然后我认为我们得到了

00:10:52.990 --> 00:10:58.029
两全其美的一些，因为

00:10:54.819 --> 00:11:01.209
我们仍然可以使用经过验证的部署

00:10:58.029 --> 00:11:02.920
建模并用于Java应用程序

00:11:01.209 --> 00:11:05.170
微型档案项目来填补这些

00:11:02.920 --> 00:11:07.329
差距，所以这是我要向您展示的

00:11:05.170 --> 00:11:08.140
此时此刻

00:11:07.329 --> 00:11:10.780
滑梯

00:11:08.140 --> 00:11:14.590
现在让我们进行一些现场编码-时间

00:11:10.780 --> 00:11:16.450
唤醒我这里有两个项目

00:11:14.590 --> 00:11:19.360
我想给你看，当然是因为

00:11:16.450 --> 00:11:21.250
我是咖啡爱好者，我称之为第一个

00:11:19.360 --> 00:11:23.470
应用程序称为咖啡店

00:11:21.250 --> 00:11:25.000
第二个叫做咖啡师

00:11:23.470 --> 00:11:27.420
我们在这里有一些咖啡的例子， 

00:11:25.000 --> 00:11:30.060
我现在想告诉你的是

00:11:27.420 --> 00:11:33.340
首先只是标准

00:11:30.060 --> 00:11:35.710
独立的Java EE 8项目

00:11:33.340 --> 00:11:38.320
这个咖啡厅项目

00:11:35.710 --> 00:11:41.050
我现在要增加一些东西

00:11:38.320 --> 00:11:44.910
我们可能要添加，所以这一个

00:11:41.050 --> 00:11:47.800
只是因为我很勇敢地在JDK 11上运行

00:11:44.910 --> 00:11:50.740
他们在JDK 11上运行工作负载的人

00:11:47.800 --> 00:11:53.470
是的，这就是我以为是谁

00:11:50.740 --> 00:11:55.170
至少玩过JDK 11等等

00:11:53.470 --> 00:11:58.840
那更好

00:11:55.170 --> 00:12:01.750
好吧，所以这是建立在JDK和

00:11:58.840 --> 00:12:05.380
实际上也可以在JDK上运行，非常感谢

00:12:01.750 --> 00:12:08.860
天哪，所以我们今天要展示

00:12:05.380 --> 00:12:13.120
好吧，我想简单地告诉你

00:12:08.860 --> 00:12:15.880
该项目包括什么

00:12:13.120 --> 00:12:17.860
现在只有Java 8独立版本， 

00:12:15.880 --> 00:12:20.530
基本上我在使用时所拥有的

00:12:17.860 --> 00:12:23.200
杰克的休息提供一些HTTP端点

00:12:20.530 --> 00:12:26.260
对，人们可以加些感冒

00:12:23.200 --> 00:12:28.090
咖啡订单，然后我们要

00:12:26.260 --> 00:12:29.950
增强一点，所以首先

00:12:28.090 --> 00:12:32.470
我们只有杰克的休息资源

00:12:29.950 --> 00:12:35.410
在这里我们可以喝咖啡

00:12:32.470 --> 00:12:37.720
订购并通过JSON发布，因此

00:12:35.410 --> 00:12:40.780
作为Java EE开发人员通常

00:12:37.720 --> 00:12:43.660
已知技术众所周知api的权利

00:12:40.780 --> 00:12:45.940
我们通常习惯于Jason BP 

00:12:43.660 --> 00:12:48.460
包括它和杰克的休息等等

00:12:45.940 --> 00:12:50.800
等等，最终我们会问

00:12:48.460 --> 00:12:53.380
一些托管豆，请订购一些

00:12:50.800 --> 00:12:56.140
咖啡，然后实际上会在以后

00:12:53.380 --> 00:12:58.900
在以后我会展示一点

00:12:56.140 --> 00:13:01.480
到外部系统并打入

00:12:58.900 --> 00:13:04.990
通过HTTP同步方式，我们将

00:13:01.480 --> 00:13:07.780
正确访问该系统的几件事

00:13:04.990 --> 00:13:11.680
一旦添加，我们可能想要添加

00:13:07.780 --> 00:13:14.050
微观资料，有什么用

00:13:11.680 --> 00:13:18.610
例如会增加一些错误

00:13:14.050 --> 00:13:20.070
宽容是因为

00:13:18.610 --> 00:13:24.710
依赖

00:13:20.070 --> 00:13:28.680
这里，因为现在让我们说HTTP 

00:13:24.710 --> 00:13:30.600
 HTTP查找连接

00:13:28.680 --> 00:13:32.430
到可能会失败的外部系统

00:13:30.600 --> 00:13:34.830
正确的外部系统可能不是

00:13:32.430 --> 00:13:37.770
可用，然后我们例如想要

00:13:34.830 --> 00:13:39.630
重试，或者至少我们想要

00:13:37.770 --> 00:13:45.050
内置一些断路行为

00:13:39.630 --> 00:13:47.250
所以说正确，如你所见

00:13:45.050 --> 00:13:50.370
依赖这里已经有一个

00:13:47.250 --> 00:13:51.630
几种方法来添加它，我可以展示

00:13:50.370 --> 00:13:53.490
您稍后，我们也有

00:13:51.630 --> 00:13:56.040
整体微观的依赖

00:13:53.490 --> 00:13:58.260
轮廓伞，包括所有

00:13:56.040 --> 00:14:01.080
依赖关系，但这已经是

00:13:58.260 --> 00:14:04.380
我相信从为什么开始的好方法

00:14:01.080 --> 00:14:05.970
因为它非常类似于

00:14:04.380 --> 00:14:07.980
开发模型和部署模型

00:14:05.970 --> 00:14:10.740
在Java EE中，我们实际上可以

00:14:07.980 --> 00:14:13.140
添加提供的依赖项并相同

00:14:10.740 --> 00:14:15.720
对于我们的API来说确实如此

00:14:13.140 --> 00:14:19.050
只有api和

00:14:15.720 --> 00:14:20.640
我们在这里也通过指定提供

00:14:19.050 --> 00:14:22.590
这些微型配置文件的依赖性

00:14:20.640 --> 00:14:25.230
项目，所以我们要这个

00:14:22.590 --> 00:14:28.230
容错api，然后一旦我们去

00:14:25.230 --> 00:14:30.870
再次进入这个咖啡厅豆

00:14:28.230 --> 00:14:33.450
开始调查这个咖啡师

00:14:30.870 --> 00:14:35.670
那位咖啡师基本上就是

00:14:33.450 --> 00:14:38.610
是连接到

00:14:35.670 --> 00:14:40.530
外部系统，目前

00:14:38.610 --> 00:14:43.380
并不是真的不是真的有弹性

00:14:40.530 --> 00:14:45.060
所以可以说我们想开始

00:14:43.380 --> 00:14:47.280
咖啡冲泡过程中做些

00:14:45.060 --> 00:14:49.650
东西，但可能会失败，所以让我们

00:14:47.280 --> 00:14:51.990
包括一个断路器

00:14:49.650 --> 00:14:55.950
带有微配置文件的注释

00:14:51.990 --> 00:14:59.370
从该程序包名称空间开始，一旦我们

00:14:55.950 --> 00:15:01.200
注释后，请添加此方法

00:14:59.370 --> 00:15:03.930
用那个断路器的那个方法

00:15:01.200 --> 00:15:05.250
注释很好，现在是电路

00:15:03.930 --> 00:15:07.350
断路器，您可以进一步

00:15:05.250 --> 00:15:10.560
使用注释进行配置，您可以

00:15:07.350 --> 00:15:12.450
看一下项目

00:15:10.560 --> 00:15:15.780
规范它是如何工作的

00:15:12.450 --> 00:15:18.000
内部行为如何，但来自

00:15:15.780 --> 00:15:19.950
编程模型的观点是

00:15:18.000 --> 00:15:22.440
已经足以指定行为

00:15:19.950 --> 00:15:26.400
所以您会看到适合的编程模型

00:15:22.440 --> 00:15:27.960
进入JA VE世界

00:15:26.400 --> 00:15:30.960
我们可能要添加的是

00:15:27.960 --> 00:15:33.690
配置权，这些只是

00:15:30.960 --> 00:15:36.270
当然是这里的例子

00:15:33.690 --> 00:15:40.020
我要补充的是相同的故事

00:15:36.270 --> 00:15:42.900
版本103中的微型配置文件配置为

00:15:40.020 --> 00:15:45.290
包含在所有这些微观配置文件中

00:15:42.900 --> 00:15:47.760
项目，您可以添加此

00:15:45.290 --> 00:15:50.660
就像我们刚才所做的那样

00:15:47.760 --> 00:15:53.940
当然总是在提供的范围内

00:15:50.660 --> 00:15:58.040
为什么我要在几秒钟内告诉你

00:15:53.940 --> 00:16:00.600
现在我们还可以添加一些配置

00:15:58.040 --> 00:16:03.930
例如我们进行健康检查

00:16:00.600 --> 00:16:06.390
这里的资源其实也有

00:16:03.930 --> 00:16:10.320
市场概况中的健康检查项目

00:16:06.390 --> 00:16:11.760
但是虽然不只是你一个人

00:16:10.320 --> 00:16:13.920
如果我们想使用这个有一些问题

00:16:11.760 --> 00:16:16.020
用于准备行为

00:16:13.920 --> 00:16:18.210
应用程序，但假设我们要

00:16:16.020 --> 00:16:21.000
在这里有一些配置， 

00:16:18.210 --> 00:16:22.860
如果您要这样做的方式

00:16:21.000 --> 00:16:25.080
示例要读取一些值

00:16:22.860 --> 00:16:28.890
从属性文件或您的

00:16:25.080 --> 00:16:30.960
环境变量，您可以这样做

00:16:28.890 --> 00:16:34.530
普通Java EE的今天，您可以

00:16:30.960 --> 00:16:36.750
甚至写一个瘦弱的CDI生产者

00:16:34.530 --> 00:16:40.140
能够像我现在一样添加注入

00:16:36.750 --> 00:16:45.720
例如，假设应用服务器

00:16:40.140 --> 00:16:48.090
版本类似这样的权利，但

00:16:45.720 --> 00:16:50.190
那么您还需要添加

00:16:48.090 --> 00:16:53.280
一些配置，或者您定义

00:16:50.190 --> 00:16:56.280
您自己的CDI限定词，或者您使用此

00:16:53.280 --> 00:16:59.190
在冲突属性注释中

00:16:56.280 --> 00:17:01.380
附带了微配置文件配置，那么您

00:16:59.190 --> 00:17:04.199
可以简单地指定位置使用此

00:17:01.380 --> 00:17:06.240
带有某些名称的冲突属性

00:17:04.199 --> 00:17:07.470
默认名称是显示

00:17:06.240 --> 00:17:09.930
第二层是从哪里来的

00:17:07.470 --> 00:17:12.420
取自一些所谓的默认值

00:17:09.930 --> 00:17:15.180
配置源环境变量是

00:17:12.420 --> 00:17:17.550
其中之一，那就是我们可以

00:17:15.180 --> 00:17:19.709
只需将其注入我们的豆子中

00:17:17.550 --> 00:17:21.630
是非常好的开发人员体验

00:17:19.709 --> 00:17:24.569
对，我们不必做任何其他事情

00:17:21.630 --> 00:17:26.250
因为那已经被

00:17:24.569 --> 00:17:28.740
实施我们的微型档案

00:17:26.250 --> 00:17:29.670
规范，所以我们说好

00:17:28.740 --> 00:17:32.820
我们将处理这些信息

00:17:29.670 --> 00:17:36.000
例如，我们可以将其添加到我们的健康中

00:17:32.820 --> 00:17:37.770
检查HTTP标头中的资源，以便

00:17:36.000 --> 00:17:40.230
假设我们要建立一个

00:17:37.770 --> 00:17:42.990
在这里以编程方式回复

00:17:40.230 --> 00:17:44.250
说这就是我的意思

00:17:42.990 --> 00:17:47.200
说好吧

00:17:44.250 --> 00:17:49.600
但我们想包含一些标题

00:17:47.200 --> 00:17:53.080
它实际上是在使用开放自由

00:17:49.600 --> 00:17:55.299
引擎盖打开带有应用程序的Liberty版本

00:17:53.080 --> 00:17:57.909
服务器版本并生成并返回

00:17:55.299 --> 00:18:00.759
写或做任何你喜欢的

00:17:57.909 --> 00:18:03.460
配置的属性，但重点是

00:18:00.759 --> 00:18:05.259
如何注入这个，你只需要

00:18:03.460 --> 00:18:07.450
在这里注入它，您不必

00:18:05.259 --> 00:18:09.909
就像你必须做的那样

00:18:07.450 --> 00:18:12.399
您可以使用纯java ee来做到这一点

00:18:09.909 --> 00:18:15.210
那是一个很好的故事

00:18:12.399 --> 00:18:18.129
你这样做已经足够了

00:18:15.210 --> 00:18:20.169
好了，这只是两个例子

00:18:18.129 --> 00:18:22.629
在许多微型配置文件项目中

00:18:20.169 --> 00:18:25.629
我们有我们可以用来增强我们的

00:18:22.629 --> 00:18:27.609
 Java EE应用程序的发展

00:18:25.629 --> 00:18:29.279
我现在当然要做好所有这些事情

00:18:27.609 --> 00:18:32.039
想构建我的应用程序

00:18:29.279 --> 00:18:34.359
因为我们可以使用现代

00:18:32.039 --> 00:18:36.940
 Docker容器等技术

00:18:34.359 --> 00:18:39.399
然后在kubernetes和sto上

00:18:36.940 --> 00:18:43.059
时刻，并使用

00:18:39.399 --> 00:18:45.129
这个好，我们首先需要做什么

00:18:43.059 --> 00:18:49.330
在这里有项目，当然是

00:18:45.129 --> 00:18:52.570
一个Maven项目，所以我们有点建造了这个

00:18:49.330 --> 00:18:55.899
使用Maven对，我们要打包

00:18:52.570 --> 00:18:59.470
以及薄薄的华夫饼干方法

00:18:55.899 --> 00:19:02.409
我们在这里并且很好地建立了这个

00:18:59.470 --> 00:19:04.570
放入番石榴，所以如果您熟悉

00:19:02.409 --> 00:19:06.700
瘦部署工件方法

00:19:04.570 --> 00:19:10.690
从Java EE中，那么您可能知道

00:19:06.700 --> 00:19:12.700
实际上这些华夫饼很小

00:19:10.690 --> 00:19:16.840
仅有几千字节，因为它们

00:19:12.700 --> 00:19:20.320
实际上只包括那些

00:19:16.840 --> 00:19:21.759
您将自己的业务逻辑写入

00:19:20.320 --> 00:19:23.919
墙基金和其他一切

00:19:21.759 --> 00:19:26.409
只要其他事情都由

00:19:23.919 --> 00:19:28.690
应用服务器和一个不错的故事

00:19:26.409 --> 00:19:30.700
关于那个，特别是关于

00:19:28.690 --> 00:19:32.799
同时支持Java EE和

00:19:30.700 --> 00:19:34.149
微型个人资料可以使用相同的

00:19:32.799 --> 00:19:36.629
即使您将两者结合起来

00:19:34.149 --> 00:19:39.039
技术，这就是为什么写

00:19:36.629 --> 00:19:40.720
在所有这些范围中都提供了这里

00:19:39.039 --> 00:19:42.940
他们实际上并没有最终进入我们的

00:19:40.720 --> 00:19:45.309
部署工件很好

00:19:42.940 --> 00:19:47.619
因为我们要保持运动部件

00:19:45.309 --> 00:19:49.480
小，因为它将被运送到

00:19:47.619 --> 00:19:51.279
每个建立的权利，你

00:19:49.480 --> 00:19:53.739
宁愿只几千字节的船

00:19:51.279 --> 00:19:55.599
而不是兆字节的东西，因为

00:19:53.739 --> 00:19:56.489
稍后将包含在运行时中

00:19:55.599 --> 00:19:59.679
已经

00:19:56.489 --> 00:20:00.850
好吧，那很可爱，但是现在我们

00:19:59.679 --> 00:20:04.390
只需要部门

00:20:00.850 --> 00:20:07.000
事实如此，如果我们想要我们需要做什么

00:20:04.390 --> 00:20:08.440
将其作为docker容器运行

00:20:07.000 --> 00:20:12.310
当然我们需要建立我们的码头工人形象

00:20:08.440 --> 00:20:14.440
现在我们需要做的很好

00:20:12.310 --> 00:20:15.910
需要一些很好的码头工人形象

00:20:14.440 --> 00:20:18.670
课程包括我们需要的一切

00:20:15.910 --> 00:20:20.500
为了像运行时一样运行

00:20:18.670 --> 00:20:22.960
需要Java安装，我们需要一些

00:20:20.500 --> 00:20:25.210
可选配置或其他

00:20:22.960 --> 00:20:27.910
我们还需要一个应用服务器

00:20:25.210 --> 00:20:31.120
能够运行或支持两者

00:20:27.910 --> 00:20:32.950
 Java EE和微型配置文件以及

00:20:31.120 --> 00:20:35.950
几个已经可以做到的

00:20:32.950 --> 00:20:39.010
开放自由是我其中的一员

00:20:35.950 --> 00:20:41.650
在工作中使用我的私人Docker集线器

00:20:39.010 --> 00:20:44.320
包括所有这些，然后我们

00:20:41.650 --> 00:20:47.290
将拥有自己的服务器XML 

00:20:44.320 --> 00:20:49.600
开放的Liberty和

00:20:47.290 --> 00:20:52.570
原因是我只想

00:20:49.600 --> 00:20:55.960
指定我们正在使用哪些功能

00:20:52.570 --> 00:20:59.140
在那里，我们当然要使用

00:20:55.960 --> 00:21:01.450
这是一个开放自由的好故事，我们

00:20:59.140 --> 00:21:04.060
可以完全配置这应该

00:21:01.450 --> 00:21:06.160
被包括在内，所以我们当然要使用

00:21:04.060 --> 00:21:09.700
 Java 8对了，这就是重点

00:21:06.160 --> 00:21:12.070
再加上我们包括的微

00:21:09.700 --> 00:21:14.800
配置文件配置和容错能力以及

00:21:12.070 --> 00:21:17.710
然后我们可以在其中包含指标

00:21:14.800 --> 00:21:19.420
甚至没有在我们的项目中使用

00:21:17.710 --> 00:21:21.790
因为它带有一些不错的默认值

00:21:19.420 --> 00:21:25.210
行为良好，基本上就是这样

00:21:21.790 --> 00:21:27.480
在我们更黑的文件中

00:21:25.210 --> 00:21:29.800
当然，我们包括我们的应用程序和

00:21:27.480 --> 00:21:33.220
所有这些都将内置到我们的

00:21:29.800 --> 00:21:37.120
 docker image没什么好说的

00:21:33.220 --> 00:21:44.650
让我们构建这个docker build称为

00:21:37.120 --> 00:21:46.990
现在有某些版本的咖啡店

00:21:44.650 --> 00:21:50.410
它被内置到docker映像中

00:21:46.990 --> 00:21:52.780
好的，还很无聊，所以现在我们

00:21:50.410 --> 00:21:59.800
可以运行所有这些，所以我

00:21:52.780 --> 00:22:02.410
已经准备好一些脚本来运行

00:21:59.800 --> 00:22:05.770
一堆，因为实际上我们有一个

00:22:02.410 --> 00:22:07.780
很少会一起玩所以我们

00:22:05.770 --> 00:22:10.750
必须去咖啡厅项目和

00:22:07.780 --> 00:22:12.490
咖啡师，我可以给你看一个

00:22:10.750 --> 00:22:14.299
第二，实际上我们现在能做些什么

00:22:12.490 --> 00:22:17.599
终于和我们的贴花说话了

00:22:14.299 --> 00:22:22.940
正确的本地运行，所以我们要

00:22:17.599 --> 00:22:25.999
拥有主机90 80，一旦启动， 

00:22:22.940 --> 00:22:29.719
跑步可以问健康检查

00:22:25.999 --> 00:22:31.909
资源是否所有这些都可以让我们

00:22:29.719 --> 00:22:35.959
好的，好的，让我们看一下

00:22:31.909 --> 00:22:37.969
在HTTP标头上，所以我只使用

00:22:35.959 --> 00:22:38.539
向右卷曲，您可以使用任何HTTP客户端

00:22:37.969 --> 00:22:40.459
你的选择

00:22:38.539 --> 00:22:43.099
健康检查就可以了

00:22:40.459 --> 00:22:46.129
资源哦，它也包括这个

00:22:43.099 --> 00:22:48.259
 HTTP标头信息，在哪里

00:22:46.129 --> 00:22:50.749
来自好，其实这是一个

00:22:48.259 --> 00:22:55.279
已设置的环境变量

00:22:50.749 --> 00:22:57.379
在我的docker映像中，这样我就可以看到

00:22:55.279 --> 00:22:59.629
自由Liberty服务器的版本

00:22:57.379 --> 00:23:01.579
信息运行正常

00:22:59.629 --> 00:23:03.049
无聊不在乎，但这是

00:23:01.579 --> 00:23:04.609
实际上更多的问题在哪里

00:23:03.049 --> 00:23:06.950
信息来自以及我们如何

00:23:04.609 --> 00:23:10.190
在我的代码中使用它是一个很好的故事

00:23:06.950 --> 00:23:12.950
微型配置文件配置包括一个

00:23:10.190 --> 00:23:14.599
开箱即用的几个配置源

00:23:12.950 --> 00:23:16.519
环境变量和

00:23:14.599 --> 00:23:19.039
然后您只需添加注入并添加

00:23:16.519 --> 00:23:21.019
为了获得他们而冲突的财产

00:23:19.039 --> 00:23:22.729
到您的代码中，这是非常好的

00:23:21.019 --> 00:23:25.820
编程模型，您不必

00:23:22.729 --> 00:23:30.109
添加其他内容就可以了

00:23:25.820 --> 00:23:33.279
这个当然可以告诉你

00:23:30.109 --> 00:23:36.139
我们已经有了这个订单资源

00:23:33.279 --> 00:23:39.109
这是一个JSON，现在为空

00:23:36.139 --> 00:23:42.589
在哪里可以点我的咖啡单

00:23:39.109 --> 00:23:44.329
如果您在代码中有点紧张

00:23:42.589 --> 00:23:46.700
您将看到我们如何订购新的

00:23:44.329 --> 00:23:49.190
咖啡好，我们基本上发布一些东西

00:23:46.700 --> 00:23:51.499
将JSON对象发布到此资源，然后

00:23:49.190 --> 00:23:53.299
那么它将经历一个

00:23:51.499 --> 00:23:57.289
业务流程并最终结束

00:23:53.299 --> 00:23:59.349
在另一个系统上以获得我们的

00:23:57.289 --> 00:24:03.099
咖啡加到系统中，让我们这样做

00:23:59.349 --> 00:24:07.299
让我们在此处向资源发布一些JSON 

00:24:03.099 --> 00:24:09.889
加上咖啡，JSON有一种类型

00:24:07.299 --> 00:24:13.039
基本上，饮料的种类表明

00:24:09.889 --> 00:24:14.599
浓缩咖啡或卡布奇诺咖啡，我们可以

00:24:13.039 --> 00:24:17.239
将此发布到系统，然后

00:24:14.599 --> 00:24:17.869
希望能告诉我们一些类似的东西

00:24:17.239 --> 00:24:24.440
谢谢

00:24:17.869 --> 00:24:27.019
 HTTP 201的创建非常好

00:24:24.440 --> 00:24:28.280
表示效果正常，但

00:24:27.019 --> 00:24:31.790
现在还有什么

00:24:28.280 --> 00:24:34.420
一个不错的故事是

00:24:31.790 --> 00:24:38.900
开箱即用地添加了东西

00:24:34.420 --> 00:24:41.540
指标，例如，因为我们将

00:24:38.900 --> 00:24:43.190
微型配置文件指标

00:24:41.540 --> 00:24:45.500
比较应用程序，如果您

00:24:43.190 --> 00:24:48.680
请记住，这将与一些

00:24:45.500 --> 00:24:50.870
默认行为和默认指标

00:24:48.680 --> 00:24:54.440
开箱即用的默认监控数据

00:24:50.870 --> 00:24:56.060
因此它将包括该资源

00:24:54.440 --> 00:24:57.800
如果你看，看起来有点难看

00:24:56.060 --> 00:25:00.020
它是纯文本播放器，但是

00:24:57.800 --> 00:25:02.120
实际上是普罗米修斯格式

00:25:00.020 --> 00:25:04.820
带有微型轮廓的包装箱

00:25:02.120 --> 00:25:06.980
这很好地包含在您的

00:25:04.820 --> 00:25:09.050
服务器的权利，如果你看看

00:25:06.980 --> 00:25:10.730
它显示了一些基本的JVM信息

00:25:09.050 --> 00:25:14.120
例如，这已经很有帮助

00:25:10.730 --> 00:25:16.370
所有威胁和内存使用情况，以及

00:25:14.120 --> 00:25:18.740
您使用市场概况容错

00:25:16.370 --> 00:25:20.630
我们对定制电路做了什么

00:25:18.740 --> 00:25:23.630
断路器，那么它还将包括一些

00:25:20.630 --> 00:25:29.050
开箱即用的指标，因此

00:25:23.630 --> 00:25:32.000
很好，我让你看

00:25:29.050 --> 00:25:34.580
一件事如何设置它，所以我

00:25:32.000 --> 00:25:37.460
我还有两个容器正在运行吗

00:25:34.580 --> 00:25:40.370
在本地一个是CRO Pharma，另一个是

00:25:37.460 --> 00:25:42.860
普罗米修斯为什么很好，因为普罗米修斯

00:25:40.370 --> 00:25:45.260
会削弱这种免疫力的监测

00:25:42.860 --> 00:25:47.870
我刚刚发出的数据并在上面绘制

00:25:45.260 --> 00:25:49.790
好吧，它将很好地显示它，所以我们

00:25:47.870 --> 00:25:52.490
我们在一秒钟内实际上是

00:25:49.790 --> 00:25:56.690
股票图动物区系，我们将建立这个

00:25:52.490 --> 00:26:01.030
从我这里连接，然后

00:25:56.690 --> 00:26:06.760
我们可以实际运送和展示

00:26:01.030 --> 00:26:06.760
普罗米修斯这里的数据

00:26:07.300 --> 00:26:17.930
容错技术，所以有人

00:26:15.230 --> 00:26:20.120
为此已经创建了一个仪表板， 

00:26:17.930 --> 00:26:22.520
我们有什么，这真的很好

00:26:20.120 --> 00:26:24.710
开箱即用，我们得到了一些监控

00:26:22.520 --> 00:26:28.250
微观数据和信息

00:26:24.710 --> 00:26:31.640
概要文件容错标准

00:26:28.250 --> 00:26:33.560
我们拥有它将检测所有的

00:26:31.640 --> 00:26:35.120
方法基本上所有的

00:26:33.560 --> 00:26:37.250
增强功能

00:26:35.120 --> 00:26:39.050
具有微轮廓容错功能

00:26:37.250 --> 00:26:41.420
例如我们开始冲泡咖啡

00:26:39.050 --> 00:26:42.080
处理方法正确，然后它将

00:26:41.420 --> 00:26:44.179
更多

00:26:42.080 --> 00:26:47.330
现在包括一些更多的数据

00:26:44.179 --> 00:26:48.649
很无聊，让我们添加一些订单，让我们

00:26:47.330 --> 00:26:51.380
再多喝点咖啡

00:26:48.649 --> 00:26:53.419
更多咖啡更多咖啡更多咖啡和

00:26:51.380 --> 00:26:55.279
那么最终这将最终在我们

00:26:53.419 --> 00:26:57.740
监视数据并显示

00:26:55.279 --> 00:26:59.840
现在这个功能已经被称为

00:26:57.740 --> 00:27:01.399
很多很多次，然后如果

00:26:59.840 --> 00:27:03.200
发生故障，断路器将跳闸

00:27:01.399 --> 00:27:05.390
你会看到在这里，你会得到一些

00:27:03.200 --> 00:27:07.700
不错的信息，或者

00:27:05.390 --> 00:27:09.620
如果您添加微型，则开箱即用

00:27:07.700 --> 00:27:12.710
剖析指标和容错能力

00:27:09.620 --> 00:27:14.539
我相信这是一个很好的故事

00:27:12.710 --> 00:27:18.409
为了增强我们的Java EE 

00:27:14.539 --> 00:27:20.899
对此提出任何问题

00:27:18.409 --> 00:27:22.309
我忘记提及的方式

00:27:20.899 --> 00:27:26.000
随时有任何疑问

00:27:22.309 --> 00:27:29.559
随便问我

00:27:26.000 --> 00:27:32.870
向您展示一种略有不同的方法

00:27:29.559 --> 00:27:34.309
只是因为那种发展模式

00:27:32.870 --> 00:27:36.740
第二个应用略

00:27:34.309 --> 00:27:39.169
更简单，因为第二个应用程序

00:27:36.740 --> 00:27:42.080
我们的咖啡师应用程序基本上是

00:27:39.169 --> 00:27:44.510
仅接受的无状态应用程序

00:27:42.080 --> 00:27:48.169
这个咖啡订单，然后返回是

00:27:44.510 --> 00:27:51.679
或否，该应用程序实际上可以

00:27:48.169 --> 00:27:56.019
由普通的微轮廓建立，这

00:27:51.679 --> 00:27:58.940
是从那一台泵中抽出来的吗

00:27:56.019 --> 00:28:01.370
我们还有哪些其他依赖项

00:27:58.940 --> 00:28:03.590
这是微观配置文件的依赖关系

00:28:01.370 --> 00:28:06.230
没有指定具体项目

00:28:03.590 --> 00:28:08.899
实际上包括所有

00:28:06.230 --> 00:28:11.240
我们在那里的项目，所以所有的

00:28:08.899 --> 00:28:13.279
微型配置文件项目，因此这一项目将

00:28:11.240 --> 00:28:17.210
仅在微配置文件上运行

00:28:13.279 --> 00:28:21.049
对于这个例子很好

00:28:17.210 --> 00:28:25.100
 Jax逮捕了它实际上将使用JSON P 

00:28:21.049 --> 00:28:27.919
我可以告诉你，然后我们还有一个

00:28:25.100 --> 00:28:31.490
为此它定制了运行时

00:28:27.919 --> 00:28:33.649
这里使用的非常基本的Jax资源

00:28:31.490 --> 00:28:38.029
杰森P还包括微

00:28:33.649 --> 00:28:40.880
配置文件权利，这将是CDI CDI 

00:28:38.029 --> 00:28:43.669
豆，基本上就是这样，我们

00:28:40.880 --> 00:28:46.010
在我们的服务器配置中可以做的是

00:28:43.669 --> 00:28:49.159
说哦，实际上我们甚至不需要Java 

00:28:46.010 --> 00:28:50.779
 8所以如果我们跳过所有这些，那么

00:28:49.159 --> 00:28:52.429
 Stark的应用将是

00:28:50.779 --> 00:28:55.100
快一点，因为我们需要方法

00:28:52.429 --> 00:28:55.970
更少的功能，我们实际上只需要CDI 

00:28:55.100 --> 00:28:59.140
千斤顶剩下的

00:28:55.970 --> 00:29:02.500
看到，我们当然要好

00:28:59.140 --> 00:29:04.940
现在将展示的功能

00:29:02.500 --> 00:29:08.240
那么你已经有一个更苗条的运行时了

00:29:04.940 --> 00:29:10.780
但是只是做这个服务器配置

00:29:08.240 --> 00:29:14.360
以开放自由为例

00:29:10.780 --> 00:29:18.260
那么您可以包含此内容并发送

00:29:14.360 --> 00:29:19.970
这里的独立项目好吗

00:29:18.260 --> 00:29:23.780
否则我想告诉你

00:29:19.970 --> 00:29:25.730
如果跑得好，如果

00:29:23.780 --> 00:29:28.460
您在服务网格环境中运行

00:29:25.730 --> 00:29:31.160
例如ISTE哦，这是整合

00:29:28.460 --> 00:29:33.860
与分布式跟踪，所以这是一个

00:29:31.160 --> 00:29:36.470
我还没告诉你的事情

00:29:33.860 --> 00:29:39.380
进行分发和跟踪工作，以及

00:29:36.470 --> 00:29:44.630
开放式跟踪是一个微型配置文件项目

00:29:39.380 --> 00:29:47.180
包括如果可以包括一个

00:29:44.630 --> 00:29:49.370
同时跟踪信息

00:29:47.180 --> 00:29:51.770
目标终点和沟通水平以及

00:29:49.370 --> 00:29:55.010
同样在代码级别，因此您可以

00:29:51.770 --> 00:29:57.500
实际上包括api并增强它

00:29:55.010 --> 00:29:59.660
甚至从代码级别跟踪上下文

00:29:57.500 --> 00:30:02.630
但已经，我认为那是

00:29:59.660 --> 00:30:04.190
已经非常有用的包括跟踪

00:30:02.630 --> 00:30:07.190
传递的信息

00:30:04.190 --> 00:30:11.030
 HTTP标头中的相关性ID 

00:30:07.190 --> 00:30:13.580
盒子里的东西，所以如果我们

00:30:11.030 --> 00:30:17.030
包含并传递一些跟踪头

00:30:13.580 --> 00:30:19.370
信息化成第一资源

00:30:17.030 --> 00:30:21.410
第一个HTTP边界

00:30:19.370 --> 00:30:23.690
传入流量然后

00:30:21.410 --> 00:30:26.180
申请服务实际上是

00:30:23.690 --> 00:30:29.570
使用开放式跟踪将通过所有

00:30:26.180 --> 00:30:32.750
在整个过程中一直跟踪上下文

00:30:29.570 --> 00:30:35.540
即使我们命中了HTTP客户端

00:30:32.750 --> 00:30:39.140
然后它将传递这些相关性

00:30:35.540 --> 00:30:42.110
该HTTP中的ID作为一个连接

00:30:39.140 --> 00:30:45.860
好，这非常有帮助，因为

00:30:42.110 --> 00:30:48.800
我们不必自己做

00:30:45.860 --> 00:30:50.930
为了让您快速了解我们

00:30:48.800 --> 00:30:53.420
可以使用它，这有什么好处

00:30:50.930 --> 00:30:55.430
我实际上会向您展示一个非常

00:30:53.420 --> 00:30:58.190
运行这两个示例

00:30:55.430 --> 00:31:01.010
 kubernetes和sto中的应用程序

00:30:58.190 --> 00:31:04.570
你曾经使用过的环境

00:31:01.010 --> 00:31:07.700
举起手来之前使用kubernetes或和/或hto 

00:31:04.570 --> 00:31:10.010
好的，你们很少。 

00:31:07.700 --> 00:31:11.990
当然不是真的

00:31:10.010 --> 00:31:14.060
很高兴逮捕您，但我认为这是一个

00:31:11.990 --> 00:31:16.730
如果您熟悉的话，非常好的展示

00:31:14.060 --> 00:31:18.620
有了它的技术

00:31:16.730 --> 00:31:21.920
实际添加这个微型

00:31:18.620 --> 00:31:24.680
配置文件规范，从到到到

00:31:21.920 --> 00:31:27.140
我们的企业应用程序

00:31:24.680 --> 00:31:31.310
在服务网格中运行并更好地工作

00:31:27.140 --> 00:31:33.770
环境，所以我在这里很好

00:31:31.310 --> 00:31:37.970
古巴印度群岛集群或实际上是

00:31:33.770 --> 00:31:41.330
启用ECU的集群在

00:31:37.970 --> 00:31:43.430
云，所以我会说事实上

00:31:41.330 --> 00:31:47.120
服务网格技术的标准

00:31:43.430 --> 00:31:49.610
我用它们托管的kubernetes 

00:31:47.120 --> 00:31:52.370
我用Sto增强的集群

00:31:49.610 --> 00:31:54.020
在云中运行，如果我们

00:31:52.370 --> 00:31:57.010
幸运的话，我们有一个适当的互联网

00:31:54.020 --> 00:32:00.260
连接以及我该怎么做

00:31:57.010 --> 00:32:03.200
基本上，如果您对此感兴趣

00:32:00.260 --> 00:32:05.780
可以看看所有的代码示例

00:32:03.200 --> 00:32:07.990
后来我所有的幻灯片

00:32:05.780 --> 00:32:11.450
不想花太多时间

00:32:07.990 --> 00:32:13.850
在此解释伊斯特拉半岛的kubernetes 

00:32:11.450 --> 00:32:15.650
谈论它实际上是关于

00:32:13.850 --> 00:32:17.810
我将进行的市场概况整合

00:32:15.650 --> 00:32:20.540
一秒钟告诉你，但我在这里做什么

00:32:17.810 --> 00:32:24.080
我有一堆kubernetes和sto 

00:32:20.540 --> 00:32:26.390
运行这两个资源的资源

00:32:24.080 --> 00:32:28.490
 kubernetes环境中的应用程序

00:32:26.390 --> 00:32:31.250
对着咖啡店和咖啡师

00:32:28.490 --> 00:32:34.160
我们拥有的服务又是

00:32:31.250 --> 00:32:36.500
通过微型配置文件开放式跟踪启用

00:32:34.160 --> 00:32:38.390
当然还有监控和指标

00:32:36.500 --> 00:32:38.860
我们之前看过的数据等等

00:32:38.390 --> 00:32:43.600
向前

00:32:38.860 --> 00:32:46.310
现在，如果我们在以下服务网格中运行

00:32:43.600 --> 00:32:48.590
环境然后服务网格

00:32:46.310 --> 00:32:50.870
在这种情况下将做或正在做

00:32:48.590 --> 00:32:52.880
它将添加和此跟踪

00:32:50.870 --> 00:32:56.450
分布式跟踪的信息

00:32:52.880 --> 00:32:59.510
开箱即用，如果我们再开一些

00:32:56.450 --> 00:33:02.150
要求将信息

00:32:59.510 --> 00:33:04.760
那里将可用，它将

00:33:02.150 --> 00:33:07.190
通过，如果我们因为我们使用微型

00:33:04.760 --> 00:33:10.340
 Java EE中的配置文件打开跟踪

00:33:07.190 --> 00:33:12.260
即使我们看看

00:33:10.340 --> 00:33:14.210
集群中正在运行的应用程序

00:33:12.260 --> 00:33:14.450
现在以及我们正在运行的服务

00:33:14.210 --> 00:33:17.690
有

00:33:14.450 --> 00:33:19.280
我们还提供了另外两项服务

00:33:17.690 --> 00:33:21.950
咖啡厅系统和一个

00:33:19.280 --> 00:33:23.390
咖啡师系统，而且我们现在有两个

00:33:21.950 --> 00:33:26.600
运行实例

00:33:23.390 --> 00:33:33.020
然后希望我们可以让我

00:33:26.600 --> 00:33:34.940
必须与Yaga提出联系

00:33:33.020 --> 00:33:38.620
用于追踪技术，因为我

00:33:34.940 --> 00:33:38.620
需要一秒钟告诉你

00:33:38.830 --> 00:33:44.929
让我们看看是否可行

00:33:42.290 --> 00:33:47.390
让我连接到sto集群

00:33:44.929 --> 00:33:49.880
并问好咖啡厅项目是

00:33:47.390 --> 00:33:52.580
你启动并运行正确

00:33:49.880 --> 00:33:53.840
我们以前的例子，它说

00:33:52.580 --> 00:33:56.660
是的，好的

00:33:53.840 --> 00:34:00.080
这是个好消息，如果我们要求

00:33:56.660 --> 00:34:01.669
咖啡店订单，我们现在可以订购一些

00:34:00.080 --> 00:34:03.500
更多的咖啡就像我们一样

00:34:01.669 --> 00:34:05.809
以前做过，但现在它实际上正在运行

00:34:03.500 --> 00:34:10.100
在kubernetes和sto中的云中

00:34:05.809 --> 00:34:13.310
集群正确，然后他就是这个-好

00:34:10.100 --> 00:34:15.919
还点一杯意式浓缩咖啡，然后

00:34:13.310 --> 00:34:20.240
希望我们能得到HTTP 201 

00:34:15.919 --> 00:34:23.119
创造状态好吧，我们可以

00:34:20.240 --> 00:34:25.510
现在做，让我们再订购一些咖啡

00:34:23.119 --> 00:34:29.260
实际使用所有这一切给你

00:34:25.510 --> 00:34:29.260
我们拥有的信息

00:34:31.419 --> 00:34:38.560
让我杀死旧的炸玉米饼容器

00:34:34.070 --> 00:34:42.500
因此我们也可以将端口转发给

00:34:38.560 --> 00:34:46.669
在斧头上画图，因为现在我们实际上

00:34:42.500 --> 00:34:48.710
可以做的就是使用仪表板

00:34:46.669 --> 00:34:50.270
转发本地端口，所以现在

00:34:48.710 --> 00:34:52.669
实际上是一个不同的图

00:34:50.270 --> 00:34:54.679
装运的仪表板是

00:34:52.669 --> 00:34:56.869
包括略有不同

00:34:54.679 --> 00:34:59.780
信息，但您也会看到

00:34:56.869 --> 00:35:02.090
如果您使用它实际上非常相似

00:34:59.780 --> 00:35:04.010
微观配置的想法

00:35:02.090 --> 00:35:07.460
这是默认行为

00:35:04.010 --> 00:35:09.500
盒子，但这完全是技术

00:35:07.460 --> 00:35:16.670
这样它将向您显示一些监控数据

00:35:09.500 --> 00:35:20.000
而且，更重要的是

00:35:16.670 --> 00:35:22.880
 jägerUI这个可爱的家伙与

00:35:20.000 --> 00:35:25.280
分布式的德语名称Yaga 

00:35:22.880 --> 00:35:28.040
跟踪技术，那就是

00:35:25.280 --> 00:35:29.930
技术负责

00:35:28.040 --> 00:35:32.180
包括在

00:35:29.930 --> 00:35:34.520
我们的应用程序基本上增加了一个

00:35:32.180 --> 00:35:35.210
一堆具有相关性的HTTP标头

00:35:34.520 --> 00:35:38.359
编号

00:35:35.210 --> 00:35:42.230
和Tran以及跨度和跟踪ID 

00:35:38.359 --> 00:35:44.480
然后希望这些跟踪ID 

00:35:42.230 --> 00:35:47.210
这些相关ID传递给

00:35:44.480 --> 00:35:48.859
下一个调用上下文，所以一旦我们有了

00:35:47.210 --> 00:35:51.200
一堆在那里运行的微服务

00:35:48.859 --> 00:35:53.570
一个正在呼叫另一个，依此类推

00:35:51.200 --> 00:35:56.210
等等，我们实际上可以很好地追踪

00:35:53.570 --> 00:35:58.220
所有这些传入请求，如果我们

00:35:56.210 --> 00:36:01.970
传递这些信息，以便

00:35:58.220 --> 00:36:04.760
实际上这里的重要背景

00:36:01.970 --> 00:36:06.980
如果我们再找到一些痕迹，那么这些

00:36:04.760 --> 00:36:09.980
是我刚刚解雇的一堆痕迹

00:36:06.980 --> 00:36:12.410
在订购咖啡之前，我可以

00:36:09.980 --> 00:36:14.540
看看这些信息，看看

00:36:12.410 --> 00:36:17.119
那么这里到底发生了什么， 

00:36:14.540 --> 00:36:18.980
通过观察，我们现在看到

00:36:17.119 --> 00:36:21.710
是一个同步请求

00:36:18.980 --> 00:36:23.270
本来很好被调用

00:36:21.710 --> 00:36:24.920
进入所谓的集群

00:36:23.270 --> 00:36:27.500
通过所谓的入口网关

00:36:24.920 --> 00:36:30.230
并最终完成了咖啡厅项目

00:36:27.500 --> 00:36:32.720
很好，但是现在很有趣

00:36:30.230 --> 00:36:35.810
信息是现在咖啡店

00:36:32.720 --> 00:36:39.170
里面的项目。我们在

00:36:35.810 --> 00:36:40.700
代码通过以下方式将此咖啡师称为后端

00:36:39.170 --> 00:36:43.250
同时包含大量信息

00:36:40.700 --> 00:36:46.190
我们可以看看这个你

00:36:43.250 --> 00:36:47.810
知道要查看ex请求ID，所以

00:36:46.190 --> 00:36:51.830
那就是传递的信息

00:36:47.810 --> 00:36:55.880
通过实际上通过HTTP标头

00:36:51.830 --> 00:36:57.619
关联这些请求，因为如果我们

00:36:55.880 --> 00:37:00.380
如果我们不愿意的话

00:36:57.619 --> 00:37:02.660
包括HTTP标头，然后

00:37:00.380 --> 00:37:04.820
拉直技术没有机会

00:37:02.660 --> 00:37:07.310
甚至知道这些东西

00:37:04.820 --> 00:37:10.550
两个HTTP请求甚至相关

00:37:07.310 --> 00:37:13.550
一个成本，另一个成本是

00:37:10.550 --> 00:37:16.000
同步呼叫好呼叫其他

00:37:13.550 --> 00:37:18.650
系统，然后同步返回

00:37:16.000 --> 00:37:21.140
而在这里，因为那时你会

00:37:18.650 --> 00:37:23.869
不知道这种关联，那就是

00:37:21.140 --> 00:37:25.730
开放添加的一件事

00:37:23.869 --> 00:37:27.740
开箱即用，这很好

00:37:25.730 --> 00:37:30.050
关于使用运行时的故事

00:37:27.740 --> 00:37:32.080
已经支持了这一点

00:37:30.050 --> 00:37:34.700
眼睛这是非常有益的

00:37:32.080 --> 00:37:37.880
技术或有益的组合

00:37:34.700 --> 00:37:40.550
如果您在项目环境中

00:37:37.880 --> 00:37:44.000
您从今天开始使用普通的Java EE，并且

00:37:40.550 --> 00:37:45.530
说好吧，您还有很多空白问题

00:37:44.000 --> 00:37:48.710
您想解决的问题

00:37:45.530 --> 00:37:50.540
想要关闭，您可以在

00:37:48.710 --> 00:37:52.940
这些技术这些项目

00:37:50.540 --> 00:37:54.920
从今天开始，如果您使用

00:37:52.940 --> 00:37:57.619
相应的微型档案项目和

00:37:54.920 --> 00:38:01.070
当然，如果您使用

00:37:57.619 --> 00:38:03.980
运行时在以下方面都支持

00:38:01.070 --> 00:38:08.960
运行时和对此的支持

00:38:03.980 --> 00:38:12.080
除其他外，我还会去

00:38:08.960 --> 00:38:14.720
一秒钟进入运行时

00:38:12.080 --> 00:38:19.580
其他也没有的东西

00:38:14.720 --> 00:38:21.680
是否已完全包含在Java EE中

00:38:19.580 --> 00:38:25.339
完全融入了Java EE 

00:38:21.680 --> 00:38:26.930
例如MVC规范，如果您

00:38:25.339 --> 00:38:29.720
知道这实际上是一个非常

00:38:26.930 --> 00:38:32.869
如果你想做一个很好的人

00:38:29.720 --> 00:38:34.940
以及模型视图控制器

00:38:32.869 --> 00:38:38.089
基于动作的模型B控制器

00:38:34.940 --> 00:38:40.640
服务器端或J缓存上的开发

00:38:38.089 --> 00:38:43.339
例如另一个候选人和一些

00:38:40.640 --> 00:38:46.010
其他社区将拥有的

00:38:43.339 --> 00:38:48.430
因为这些差距而被制造出来

00:38:46.010 --> 00:38:51.560
仍然在Java中，例如

00:38:48.430 --> 00:38:55.580
豪猪或破碎机作为补充

00:38:51.560 --> 00:38:58.160
由著名的大师亚当·亚当豆

00:38:55.580 --> 00:39:01.640
可以添加到纯Java EE或

00:38:58.160 --> 00:39:05.359
豪猪指标是我的一个项目

00:39:01.640 --> 00:39:07.820
做出了贡献，但除此之外

00:39:05.359 --> 00:39:10.880
微型配置文件项目可以解决

00:39:07.820 --> 00:39:15.890
在这个方向上非常相似的问题

00:39:10.880 --> 00:39:18.050
一个很早就出现的问题

00:39:15.890 --> 00:39:21.440
整个微观档案计划是

00:39:18.050 --> 00:39:24.320
我们该如何减肥？ 

00:39:21.440 --> 00:39:26.839
就以下方面对运行时进行自定义

00:39:24.320 --> 00:39:27.650
我们是否希望使运行时尽可能小

00:39:26.839 --> 00:39:30.260
尽可能

00:39:27.650 --> 00:39:31.730
当然首先你会

00:39:30.260 --> 00:39:34.520
说是个好主意

00:39:31.730 --> 00:39:36.830
而且我们只想包含必需的

00:39:34.520 --> 00:39:39.349
我们的标准和运行时功能

00:39:36.830 --> 00:39:41.750
有，但这也是你知道的一个问题

00:39:39.349 --> 00:39:44.570
和火车在时间上权衡

00:39:41.750 --> 00:39:47.810
和物质上的花销，要么你

00:39:44.570 --> 00:39:50.270
优化开发人员的开发时间

00:39:47.810 --> 00:39:52.400
和经验或运行时等

00:39:50.270 --> 00:39:54.950
如果我说我参加JA v8 

00:39:52.400 --> 00:39:57.170
雨伞看着它，说好吧

00:39:54.950 --> 00:40:00.230
不需要这个，这个和这个，但是我

00:39:57.170 --> 00:40:02.650
需要CDI和jax-rs等

00:40:00.230 --> 00:40:04.930
来了，现在我当然可以走了

00:40:02.650 --> 00:40:08.349
并缩小我的运行时仅支持

00:40:04.930 --> 00:40:11.019
我需要的是什么，那就是

00:40:08.349 --> 00:40:13.269
这当然是针对

00:40:11.019 --> 00:40:14.980
那，那当然，你马上

00:40:13.269 --> 00:40:17.049
必须问好这个问题是什么

00:40:14.980 --> 00:40:19.150
受益或换句话说多少时间

00:40:17.049 --> 00:40:21.930
你花在这样做上吗？ 

00:40:19.150 --> 00:40:24.519
获得，例如我通常

00:40:21.930 --> 00:40:26.710
实际上并不在乎

00:40:24.519 --> 00:40:29.529
图像的存储大小

00:40:26.710 --> 00:40:32.559
应用程序的最终图像，但是

00:40:29.529 --> 00:40:35.319
我很在乎

00:40:32.559 --> 00:40:37.299
部署工件后移动零件

00:40:35.319 --> 00:40:41.019
您每次运送和建造

00:40:37.299 --> 00:40:44.049
所以实际上如果我们构建一个docker镜像

00:40:41.019 --> 00:40:48.819
我们只是做了，说我们现在

00:40:44.049 --> 00:40:50.740
想推动它，所以我们想推动我们

00:40:48.819 --> 00:40:53.140
说咖啡师或咖啡店

00:40:50.740 --> 00:40:55.630
我们刚刚做得更暗的项目

00:40:53.140 --> 00:40:58.630
推权转让这就像一个

00:40:55.630 --> 00:41:01.420
更少的例子，那么我们将看到

00:40:58.630 --> 00:41:03.640
那就是所谓的提花EE 

00:41:01.420 --> 00:41:05.859
我们使用所谓的复制和写入文件

00:41:03.640 --> 00:41:08.140
系统由码头工人和好故事

00:41:05.859 --> 00:41:10.869
关于它实际上并没有推动

00:41:08.140 --> 00:41:12.400
什么都没有，或者整体不多

00:41:10.869 --> 00:41:15.309
形象是我不知道几百

00:41:12.400 --> 00:41:18.700
兆字节，但它只能推动

00:41:15.309 --> 00:41:21.400
已更改为11 KB 

00:41:18.700 --> 00:41:23.049
我们添加的Wafaa而非全部

00:41:21.400 --> 00:41:25.509
否则因为其他一切都没有

00:41:23.049 --> 00:41:27.670
变化，这就是我所关心的

00:41:25.509 --> 00:41:30.220
很多，因为这实际上可以节省您

00:41:27.670 --> 00:41:33.430
很多时间很多

00:41:30.220 --> 00:41:35.499
实际只运送一个带宽

00:41:33.430 --> 00:41:38.619
改变，为了做到这一点，你有

00:41:35.499 --> 00:41:41.019
基本支持精简部署

00:41:38.619 --> 00:41:43.299
仅运送的工件是您的一部分

00:41:41.019 --> 00:41:45.849
应用程序，其余的由

00:41:43.299 --> 00:41:48.309
运行时已经和码头工人

00:41:45.849 --> 00:41:51.220
通过说出一切来支持该模型

00:41:48.309 --> 00:41:53.920
否则基本上放在较低的图像中

00:41:51.220 --> 00:41:55.779
正确的图层之前，您必须先

00:41:53.920 --> 00:41:57.519
应用服务器的运行时

00:41:55.779 --> 00:41:59.829
那么您可以再添加一堆

00:41:57.519 --> 00:42:01.660
东西，但最后添加的东西

00:41:59.829 --> 00:42:03.819
是您的应用程序，那很小

00:42:01.660 --> 00:42:07.210
那只是您的业务逻辑，因为

00:42:03.819 --> 00:42:09.670
这将改变很多很多次

00:42:07.210 --> 00:42:13.239
一天会发生很大变化，那是

00:42:09.670 --> 00:42:14.920
我首先要优化什么

00:42:13.239 --> 00:42:16.270
说优化您的运动部件

00:42:14.920 --> 00:42:18.340
部署工件

00:42:16.270 --> 00:42:20.350
然后如果您还想要运行时

00:42:18.340 --> 00:42:22.540
一直在说可以，我们可以瘦下来

00:42:20.350 --> 00:42:24.310
基本图像也可以通过保存

00:42:22.540 --> 00:42:27.310
某人的存储空间，也许还有一点

00:42:24.310 --> 00:42:32.320
一点记忆，但是第一个是

00:42:27.310 --> 00:42:34.840
我现在首先要关注的是

00:42:32.320 --> 00:42:38.740
支持的服务器运行时

00:42:34.840 --> 00:42:41.050
微型配置文件按字母顺序排列

00:42:38.740 --> 00:42:44.470
例如，我们有开放自由

00:42:41.050 --> 00:42:48.160
支持良好的Java EE和微型配置文件

00:42:44.470 --> 00:42:51.250
到200，这实际上是为了

00:42:48.160 --> 00:42:54.130
他们所有人，我们有Tommy um 8 I 

00:42:51.250 --> 00:42:57.550
立即考虑测试版或里程碑

00:42:54.130 --> 00:42:59.590
阶段以及为什么飞行，以便您可以使用所有

00:42:57.550 --> 00:43:02.470
这些应用程序服务器运行时

00:42:59.590 --> 00:43:05.800
基本上在您建立模型的地方运行

00:43:02.470 --> 00:43:08.770
 Java EE以及您需要的任何东西

00:43:05.800 --> 00:43:10.720
从微型配置文件项目中

00:43:08.770 --> 00:43:12.580
我向您展示的示例

00:43:10.720 --> 00:43:15.940
微轮廓容错

00:43:12.580 --> 00:43:20.140
和配置例如这样

00:43:15.940 --> 00:43:24.880
我要问你的是什么

00:43:20.140 --> 00:43:27.100
成为关键要点

00:43:24.880 --> 00:43:29.680
一般建议，再说一次

00:43:27.100 --> 00:43:31.870
适用于实字企业

00:43:29.680 --> 00:43:34.000
正确的项目，我们应该怎么做， 

00:43:31.870 --> 00:43:37.180
企业项目采用哪些技术

00:43:34.000 --> 00:43:38.800
我们应该基于这样的应用

00:43:37.180 --> 00:43:41.530
当然这对我来说很有意义

00:43:38.800 --> 00:43:43.030
眼睛使用已知的api来使用

00:43:41.530 --> 00:43:45.970
证明自己的标准

00:43:43.030 --> 00:43:48.700
那么，这些都包含在Java EE 8中

00:43:45.970 --> 00:43:51.820
例如CDI，例如Jack's 

00:43:48.700 --> 00:43:54.910
如果需要，可以在JP JTA上逮捕

00:43:51.820 --> 00:43:57.370
坚持不懈，一切都好

00:43:54.910 --> 00:44:00.490
微观轮廓的扩展

00:43:57.370 --> 00:44:02.500
这就是我或我认为的Java EE 

00:44:00.490 --> 00:44:05.080
拥有市场的最大优势

00:44:02.500 --> 00:44:08.290
配置文件是为了填补这些空白

00:44:05.080 --> 00:44:12.190
截至今天还不属于Jakarta EE的一部分

00:44:08.290 --> 00:44:13.960
有一些很棒的尝试

00:44:12.190 --> 00:44:16.180
像我向你展示的那样

00:44:13.960 --> 00:44:18.790
立即使用微配置文件配置

00:44:16.180 --> 00:44:20.560
 jsr发生冲突了

00:44:18.790 --> 00:44:24.100
实际上成为标准的一部分

00:44:20.560 --> 00:44:26.080
我实际上在那个专家组中，我们

00:44:24.100 --> 00:44:28.090
试图以最快的速度发货

00:44:26.080 --> 00:44:29.509
可能，但我的意思是这无济于事

00:44:28.090 --> 00:44:31.669
如果你感到骄傲

00:44:29.509 --> 00:44:33.709
当然，从今天开始，现在您想要

00:44:31.669 --> 00:44:35.419
立即使用它，如果不使用

00:44:33.709 --> 00:44:37.639
想要很好地实现自己

00:44:35.419 --> 00:44:40.399
可以使用微配置文件配置

00:44:37.639 --> 00:44:42.529
我会说只是尝试

00:44:40.399 --> 00:44:45.799
满足您需求的开发模型

00:44:42.529 --> 00:44:48.889
对于您的应用程序方面，如果您说

00:44:45.799 --> 00:44:50.689
很好，我更简单

00:44:48.889 --> 00:44:52.729
根据您的标准申请

00:44:50.689 --> 00:44:54.439
使用，您会发现所有

00:44:52.729 --> 00:44:56.869
 micro包含的标准

00:44:54.439 --> 00:44:59.630
个人资料已经存在，或者您可能拥有自己的个人资料

00:44:56.869 --> 00:45:02.869
微型个人资料伞说您需要这个

00:44:59.630 --> 00:45:05.809
加上其他Java功能，但仅此而已

00:45:02.869 --> 00:45:08.119
然后使用支持

00:45:05.809 --> 00:45:10.309
这组功能，例如“打开” 

00:45:08.119 --> 00:45:12.409
通过指定功能集来实现自由

00:45:10.309 --> 00:45:15.769
在也可以的配置中

00:45:12.409 --> 00:45:18.169
当然，您可以节省一些空间

00:45:15.769 --> 00:45:20.299
运行时部分，只需选择一个

00:45:18.169 --> 00:45:22.369
模型或一组适合的标准

00:45:20.299 --> 00:45:24.949
您对您的应用程序的需求

00:45:22.369 --> 00:45:27.679
你在做，但总的来说我会

00:45:24.949 --> 00:45:29.839
从经验中建议您进行优化

00:45:27.679 --> 00:45:33.049
部署工件移动

00:45:29.839 --> 00:45:35.869
首先进行零件优化，然后再过度优化

00:45:33.049 --> 00:45:38.599
运行时，这就是我的观点

00:45:35.869 --> 00:45:41.239
那就是为什么建议的原因之一

00:45:38.599 --> 00:45:42.109
在部署中采用的模型

00:45:41.239 --> 00:45:44.509
文物

00:45:42.109 --> 00:45:45.889
是否是Java都是墙文件，但是

00:45:44.509 --> 00:45:48.259
精简的部署工件，仅

00:45:45.889 --> 00:45:50.659
包括您的商务舱和运送

00:45:48.259 --> 00:45:52.729
到有能力的运行时

00:45:50.659 --> 00:45:54.949
在运行时已经存在的地方这样做

00:45:52.729 --> 00:45:56.439
包括去年的一切

00:45:54.949 --> 00:45:58.909
您需要的一切以及所有

00:45:56.439 --> 00:46:01.729
你拥有的实现，然后你

00:45:58.909 --> 00:46:06.289
在此之上添加您的应用程序

00:46:01.729 --> 00:46:08.779
作为我未来的可能方向

00:46:06.289 --> 00:46:11.329
会看到的，如果你看着我的

00:46:08.779 --> 00:46:13.519
块，我写了一堆短

00:46:11.329 --> 00:46:15.679
关于我的个人看法

00:46:13.519 --> 00:46:19.159
我们可以做些什么来移动

00:46:15.679 --> 00:46:22.189
整个事情向前发展，所以我看到很多

00:46:19.159 --> 00:46:25.159
潜力和微观概况以及种子

00:46:22.189 --> 00:46:27.889
作为未来两个人的孵化器

00:46:25.159 --> 00:46:29.599
卡EEE标准，所以微简介

00:46:27.889 --> 00:46:31.189
配置是一个典型的例子

00:46:29.599 --> 00:46:35.899
因为实际上我们已经有一个

00:46:31.189 --> 00:46:38.449
冲突jsr J是我们的382 

00:46:35.899 --> 00:46:41.179
基本上建立在微观轮廓上

00:46:38.449 --> 00:46:42.870
配置，我们使用了很多功能， 

00:46:41.179 --> 00:46:45.270
 api和注解

00:46:42.870 --> 00:46:47.730
在那里，然后尝试使其成为标准

00:46:45.270 --> 00:46:51.150
并把它和未来一起运送到Carly 

00:46:47.730 --> 00:46:53.580
实际上，对于Java SE也是如此

00:46:51.150 --> 00:46:55.830
这个想法并为什么建立了标准

00:46:53.580 --> 00:46:59.700
然后证明自己是

00:46:55.830 --> 00:47:02.640
叛逃者标准项目

00:46:59.700 --> 00:47:05.550
微型配置文件项目基本上

00:47:02.640 --> 00:47:08.070
提供未来所缺少的

00:47:05.550 --> 00:47:13.770
 Carta II规格或至少

00:47:08.070 --> 00:47:16.680
今天我们也看到了很大的好处

00:47:13.770 --> 00:47:19.260
并分享设计原则

00:47:16.680 --> 00:47:21.150
以及整体外观和感觉

00:47:19.260 --> 00:47:23.610
我们拥有的开发者经验和

00:47:21.150 --> 00:47:26.250
实际上，我们喜欢使用Java EE时

00:47:23.610 --> 00:47:29.700
例如，声明式方法

00:47:26.250 --> 00:47:32.580
使用注释，您只有一个

00:47:29.700 --> 00:47:35.400
方法或类，只需指定

00:47:32.580 --> 00:47:37.620
一个注释，您突然将其设为

00:47:35.400 --> 00:47:39.720
 jax-rs资源权利或您添加一些

00:47:37.620 --> 00:47:42.150
断路器行为或其他

00:47:39.720 --> 00:47:44.670
例如拦截器，那是我

00:47:42.150 --> 00:47:47.130
认为一个非常有效的发展模式

00:47:44.670 --> 00:47:48.990
看整个东西和它的MI 

00:47:47.130 --> 00:47:51.120
使用它也很有意义

00:47:48.990 --> 00:47:53.370
实际上，如果您

00:47:51.120 --> 00:47:55.260
看所有的微型档案项目

00:47:53.370 --> 00:47:57.930
在那里使用它的微观轮廓

00:47:55.260 --> 00:47:59.820
规格还因为那时

00:47:57.930 --> 00:48:02.190
知道如果感觉差不多

00:47:59.820 --> 00:48:04.350
您是Java开发人员，但不是

00:48:02.190 --> 00:48:08.880
那么多的新感觉，或者至少感觉到

00:48:04.350 --> 00:48:11.940
熟悉的同时我们可能会认为

00:48:08.880 --> 00:48:14.310
关于定义一个过程

00:48:11.940 --> 00:48:15.780
我指的所有这些事实上的标准

00:48:14.310 --> 00:48:18.960
他们不被称为标准和

00:48:15.780 --> 00:48:21.390
微观概况，但基本上说

00:48:18.960 --> 00:48:23.400
我们可以定义一个流程来从

00:48:21.390 --> 00:48:25.260
微型配置文件倡议，然后是什么

00:48:23.400 --> 00:48:28.080
已经在

00:48:25.260 --> 00:48:30.570
现有的实施方式

00:48:28.080 --> 00:48:33.660
造船未来的潜力

00:48:30.570 --> 00:48:37.470
提花EE标准

00:48:33.660 --> 00:48:40.680
那是我的好印象， 

00:48:37.470 --> 00:48:47.810
关于这个的想法，你还有吗

00:48:40.680 --> 00:48:47.810
关于这个东西的问题还可以

00:48:52.540 --> 00:48:56.960
是的，我提到的问题

00:48:55.310 --> 00:48:59.619
存在一个问题，报价-取消报价

00:48:56.960 --> 00:49:03.410
使用健康检查API基本上

00:48:59.619 --> 00:49:05.599
我的问题是我经常使用

00:49:03.410 --> 00:49:07.520
诸如

00:49:05.599 --> 00:49:09.320
 kubernetes，然后您将使用它

00:49:07.520 --> 00:49:11.300
健康检查资源以判断是否

00:49:09.320 --> 00:49:14.210
您的应用程序已准备好服务一些

00:49:11.300 --> 00:49:16.310
流量，实际上是否使用Ajax 

00:49:14.210 --> 00:49:19.820
基于休息的健康检查资源

00:49:16.310 --> 00:49:22.849
我从经验中展示了

00:49:19.820 --> 00:49:26.060
微型个人资料健康检查项目将

00:49:22.849 --> 00:49:28.460
告诉你准备得太早

00:49:26.060 --> 00:49:30.800
您的应用程序已准备就绪，并且

00:49:28.460 --> 00:49:32.780
准备服务一些流量

00:49:30.800 --> 00:49:34.400
稍早之前，这是原因之一

00:49:32.780 --> 00:49:37.609
为什么我不能在那个用例中使用它

00:49:34.400 --> 00:49:39.230
但实际上这已经很好

00:49:37.609 --> 00:49:41.630
该项目已经存在问题

00:49:39.230 --> 00:49:43.940
我们正在尝试解决该问题

00:49:41.630 --> 00:49:47.359
对于下一个版本，我只是

00:49:43.940 --> 00:49:49.839
这就是为什么它不包含在这里

00:49:47.359 --> 00:49:53.510
是的，谢谢，很好的问题

00:49:49.839 --> 00:49:56.780
除此之外，你可以帮我一个

00:49:53.510 --> 00:50:00.020
以后再告诉我是否

00:49:56.780 --> 00:50:03.470
你喜欢我的会议，所以不要抱怨

00:50:00.020 --> 00:50:05.089
不要大便，但要用盒子投票

00:50:03.470 --> 00:50:08.060
告诉我你是否喜欢的机制

00:50:05.089 --> 00:50:10.670
您的会话，除此之外，如果您

00:50:08.060 --> 00:50:13.460
想今晚加入我们

00:50:10.670 --> 00:50:16.550
很快在7:00在凯利的爱尔兰酒吧

00:50:13.460 --> 00:50:18.950
 IBM派对，你可以吗？ 

00:50:16.550 --> 00:50:22.099
如果您不需要，仍然可以注册

00:50:18.950 --> 00:50:23.420
很好地使用此链接

00:50:22.099 --> 00:50:25.579
除此之外，我希望你喜欢我的

00:50:23.420 --> 00:50:27.080
会议，非常感谢您的光临

00:50:25.579 --> 00:50:30.410
注意

00:50:27.080 --> 00:50:32.470
 [掌声] 

00:50:30.410 --> 00:50:32.470
您

