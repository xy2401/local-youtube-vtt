WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.030 --> 00:00:05.609
欢迎回来，所以回答有兴趣

00:00:02.669 --> 00:00:07.800
这个房间里的人

00:00:05.609 --> 00:00:11.700
两节

00:00:07.800 --> 00:00:13.770
好吧，我猜大概是一半

00:00:11.700 --> 00:00:15.120
每个人的一半

00:00:13.770 --> 00:00:16.439
谁已经在这里你要么已经

00:00:15.120 --> 00:00:18.630
在您来之前知道这一点

00:00:16.439 --> 00:00:21.450
会议，或者您已经听到很多

00:00:18.630 --> 00:00:23.220
相同的材料，我要道歉

00:00:21.450 --> 00:00:25.770
我一直在疯狂地努力锻炼

00:00:23.220 --> 00:00:29.099
这个怎么说你知道吗

00:00:25.770 --> 00:00:31.470
不同和新鲜的方式，我也有

00:00:29.099 --> 00:00:33.630
我当时的很多代码演示

00:00:31.470 --> 00:00:36.180
在艾米丽（Emily）的今天早上重写

00:00:33.630 --> 00:00:39.630
说话，让手指越过一切

00:00:36.180 --> 00:00:45.090
工作，所以我叫冰诺丁汉，我工作

00:00:39.630 --> 00:00:48.989
我为IBM工作了太长时间了

00:00:45.090 --> 00:00:52.320
从2001年开始我已经工作了17年

00:00:48.989 --> 00:00:53.370
在应用程序服务器上，但我不是

00:00:52.320 --> 00:00:54.629
将要讨论的应用程序

00:00:53.370 --> 00:00:59.100
今天大量服务器，因为它

00:00:54.629 --> 00:01:00.839
主要是关于微轮廓，所以在我之前

00:00:59.100 --> 00:01:02.399
进入并开始谈论

00:01:00.839 --> 00:01:06.030
我想要的麦克风APR 

00:01:02.399 --> 00:01:08.670
稍微反思一下过去的那种

00:01:06.030 --> 00:01:11.430
几年，以及我们如何到达

00:01:08.670 --> 00:01:13.220
指出我们真正需要新的地方

00:01:11.430 --> 00:01:16.560
 api是因为我认为一些通讯

00:01:13.220 --> 00:01:18.900
的上下文确实有助于理解

00:01:16.560 --> 00:01:21.230
为什么有些事情是这样的？ 

00:01:18.900 --> 00:01:23.640
为什么它们很重要而不是仅仅

00:01:21.230 --> 00:01:26.940
假设是因为每个人都说

00:01:23.640 --> 00:01:30.570
是，至少从我看来

00:01:26.940 --> 00:01:33.270
我刚开始时都是从敏捷开始的

00:01:30.570 --> 00:01:35.340
加入IBM并在我上大学的时候

00:01:33.270 --> 00:01:36.960
每个人都说瀑布是

00:01:35.340 --> 00:01:39.750
一种开发模型

00:01:36.960 --> 00:01:41.220
仍被认为是时尚和

00:01:39.750 --> 00:01:43.320
当然这些天，如果你出来

00:01:41.220 --> 00:01:44.550
大学，你说瀑布是

00:01:43.320 --> 00:01:46.410
开发软件的方式

00:01:44.550 --> 00:01:50.910
可能在房间外面被笑了

00:01:46.410 --> 00:01:53.370
大多数公司及其原因

00:01:50.910 --> 00:01:56.040
人们想要采用敏捷是为了

00:01:53.370 --> 00:01:57.690
获得更快的交付周期，但

00:01:56.040 --> 00:02:00.120
也要推动决策

00:01:57.690 --> 00:02:02.040
下来，打破那种发展

00:02:00.120 --> 00:02:07.080
他们可能正在发展的团队

00:02:02.040 --> 00:02:10.379
自己提供更多，但这是

00:02:07.080 --> 00:02:14.129
最初真正关心的是如何做

00:02:10.379 --> 00:02:16.110
您开发并交付代码，然后

00:02:14.129 --> 00:02:18.840
 DevOps出现并开发了什么DevOps 

00:02:16.110 --> 00:02:20.230
说是你知道我们知道如何

00:02:18.840 --> 00:02:23.050
做代码，但配置

00:02:20.230 --> 00:02:24.640
机器真的很难，你知道

00:02:23.050 --> 00:02:25.989
排放突然停止工作

00:02:24.640 --> 00:02:27.760
正确地很难得到

00:02:25.989 --> 00:02:29.860
一些新的设置方法

00:02:27.760 --> 00:02:31.989
之前我们为什么不只是编写脚本

00:02:29.860 --> 00:02:34.000
全部编写代码，然后您就会知道

00:02:31.989 --> 00:02:37.150
代码产生的基础架构

00:02:34.000 --> 00:02:39.459
那整个事情就是主意

00:02:37.150 --> 00:02:41.019
让我们将其整合到

00:02:39.459 --> 00:02:43.590
开发团队开发团队

00:02:41.019 --> 00:02:46.480
提供代码和一些

00:02:43.590 --> 00:02:48.160
允许他们的机器运行的脚本

00:02:46.480 --> 00:02:51.989
运行应用程序进行设置

00:02:48.160 --> 00:02:55.090
设置和可复制

00:02:51.989 --> 00:02:57.579
你知道我们是第一次

00:02:55.090 --> 00:03:00.489
讲述了有关DevOps的内容以及需要做的事情

00:02:57.579 --> 00:03:02.799
 IBM中的DevOps，您知道我们还在

00:03:00.489 --> 00:03:04.690
你的世界知道你会去寻求

00:03:02.799 --> 00:03:06.010
建立虚拟机的虚拟机

00:03:04.690 --> 00:03:09.400
机和虚拟机将

00:03:06.010 --> 00:03:12.970
存在并生活在那里，你知道一年

00:03:09.400 --> 00:03:15.220
也许两年，然后云做了什么

00:03:12.970 --> 00:03:17.620
它来了吗？ 

00:03:15.220 --> 00:03:19.569
想法，但是你知道这些东西

00:03:17.620 --> 00:03:22.060
机器，你得到他们相对

00:03:19.569 --> 00:03:23.650
在很短的时间内设置好您

00:03:22.060 --> 00:03:27.370
运行它们，然后将它们丢弃

00:03:23.650 --> 00:03:29.049
我在以下团队之一工作的例子

00:03:27.370 --> 00:03:30.730
它给我们带来的好处不是

00:03:29.049 --> 00:03:32.470
不得不不断担心制作

00:03:30.730 --> 00:03:34.419
确保操作系统或软件

00:03:32.470 --> 00:03:36.190
总是打补丁，你只是把它扔掉

00:03:34.419 --> 00:03:38.200
并从头开始重新配置

00:03:36.190 --> 00:03:39.760
这样您就可以得到基本图像

00:03:38.200 --> 00:03:41.310
更新了所有修复程序，然后

00:03:39.760 --> 00:03:44.950
你是非常临时的机器

00:03:41.310 --> 00:03:46.480
并与您的

00:03:44.950 --> 00:03:50.410
 DevOps流程和您的敏捷开发

00:03:46.480 --> 00:03:52.630
流动，这就是必不可少的

00:03:50.410 --> 00:03:54.609
微型的基本愿望

00:03:52.630 --> 00:03:56.049
服务，因为当你有很多

00:03:54.609 --> 00:03:58.389
很多团队都在努力工作

00:03:56.049 --> 00:04:00.459
我正在独立尝试

00:03:58.389 --> 00:04:02.769
并获取所有这些应用程序代码

00:04:00.459 --> 00:04:04.840
在单个JVM和单个JVM中运行

00:04:02.769 --> 00:04:06.579
应用服务器需要很多

00:04:04.840 --> 00:04:08.980
协调会减慢

00:04:06.579 --> 00:04:11.169
交货周期尽可能快

00:04:08.980 --> 00:04:12.910
与敏捷，DevOps和云

00:04:11.169 --> 00:04:14.470
供应您还需要能够

00:04:12.910 --> 00:04:16.599
让团队能够更多地工作

00:04:14.470 --> 00:04:19.470
彼此独立，那是

00:04:16.599 --> 00:04:22.449
微服务的来源

00:04:19.470 --> 00:04:25.090
的问题是

00:04:22.449 --> 00:04:26.949
通用方法使用一种REST API 

00:04:25.090 --> 00:04:28.630
这样的消息传递API，以便获得

00:04:26.949 --> 00:04:30.700
服务工作之间的交互

00:04:28.630 --> 00:04:32.040
带您进入整个世界

00:04:30.700 --> 00:04:33.600
分布式编程

00:04:32.040 --> 00:04:35.010
你会得到额外的负担

00:04:33.600 --> 00:04:37.290
您不必担心的问题

00:04:35.010 --> 00:04:42.540
关于旧的发展方式

00:04:37.290 --> 00:04:44.250
和交付应用程序，您知道

00:04:42.540 --> 00:04:46.440
所以当你看着你想要的

00:04:44.250 --> 00:04:48.420
来自您自己的云原生和

00:04:46.440 --> 00:04:50.610
您想要api的云环境

00:04:48.420 --> 00:04:52.500
支持您想要的分布式计算

00:04:50.610 --> 00:04:55.560
开始和关闭的东西

00:04:52.500 --> 00:04:57.360
非常快，特别是如果您正在尝试

00:04:55.560 --> 00:04:58.950
做放大你想放大

00:04:57.360 --> 00:05:00.480
因为你的工作量增加了你

00:04:58.950 --> 00:05:01.890
不必等待，您知道二十五岁

00:05:00.480 --> 00:05:06.140
分钟或三十分钟就可以

00:05:01.890 --> 00:05:08.520
应付突然出现的新要求

00:05:06.140 --> 00:05:09.810
您希望它的占地面积很小

00:05:08.520 --> 00:05:11.970
因为很多时候你会得到

00:05:09.810 --> 00:05:14.370
根据内存占用量或

00:05:11.970 --> 00:05:16.260
 CPU占用空间或磁盘占用空间

00:05:14.370 --> 00:05:20.280
在这些环境中，您就是

00:05:16.260 --> 00:05:23.130
那很小，你想拥有

00:05:20.280 --> 00:05:25.320
您想要的开发生产平价

00:05:23.130 --> 00:05:26.910
外部化您想要的配置

00:05:25.320 --> 00:05:29.130
对你来说很容易

00:05:26.910 --> 00:05:31.170
开发人员交付一些东西，然后

00:05:29.130 --> 00:05:32.550
被部署到多个

00:05:31.170 --> 00:05:35.010
您不同的部署环境

00:05:32.550 --> 00:05:37.050
可能具有不同的配置

00:05:35.010 --> 00:05:39.150
因此您的开发人员无权访问

00:05:37.050 --> 00:05:40.560
生产数据库，特别是GDP 

00:05:39.150 --> 00:05:42.030
我们的世界，你不想要你的开发商

00:05:40.560 --> 00:05:45.540
可以访问生产数据库

00:05:42.030 --> 00:05:47.370
越来越多的人想要事物

00:05:45.540 --> 00:05:50.760
被容器容易地集装箱化

00:05:47.370 --> 00:05:52.790
因为码头工人正在迅速成为

00:05:50.760 --> 00:05:59.040
获取您的首选方法

00:05:52.790 --> 00:06:02.280
应用程序部署在Klauss中，因此Java 

00:05:59.040 --> 00:06:05.220
 EE或现在正成为雅加达

00:06:02.280 --> 00:06:08.130
 EE已经存在了一段时间，但

00:06:05.220 --> 00:06:09.540
在其历史上发生了什么事

00:06:08.130 --> 00:06:11.640
历史已经发生了一件事情

00:06:09.540 --> 00:06:13.170
它有很多功能吗

00:06:11.640 --> 00:06:15.630
放入其中以及其中一些东西

00:06:13.170 --> 00:06:17.460
如果您已经不再流行

00:06:15.630 --> 00:06:20.970
编写微服务，您差不多

00:06:17.460 --> 00:06:22.920
当然不使用IOP作为

00:06:20.970 --> 00:06:24.660
您的微电脑之间的通讯层

00:06:22.920 --> 00:06:26.370
服务更有可能

00:06:24.660 --> 00:06:27.960
您正在使用的是

00:06:26.370 --> 00:06:31.470
轻量级消息传递，例如Kafka或

00:06:27.960 --> 00:06:36.270
您正在使用其余的另一个问题

00:06:31.470 --> 00:06:37.830
这个堆栈不是你所拥有的

00:06:36.270 --> 00:06:40.230
大多数人都有很多技术

00:06:37.830 --> 00:06:42.120
没有使用导致Java 

00:06:40.230 --> 00:06:44.910
具有整体声誉的人

00:06:42.120 --> 00:06:45.689
 Java的发布周期肿

00:06:44.910 --> 00:06:48.509
 re'已经很慢

00:06:45.689 --> 00:06:51.659
与行业同时下跌

00:06:48.509 --> 00:06:54.089
一直试图加快速度，所以

00:06:51.659 --> 00:06:57.749
你知道被确定为问题

00:06:54.089 --> 00:07:01.649
几年前，来自Red Hat的人们

00:06:57.749 --> 00:07:03.809
还有汤米部落和IBM等

00:07:01.649 --> 00:07:05.819
人们在开会，他们

00:07:03.809 --> 00:07:08.369
说我们需要为此做些事情

00:07:05.819 --> 00:07:13.529
这就是微观的起源

00:07:08.369 --> 00:07:15.569
个人资料项目，您知道投放

00:07:13.529 --> 00:07:17.429
这些周围存在的问题

00:07:15.569 --> 00:07:18.959
看起来又大又胖你几乎知道

00:07:17.429 --> 00:07:20.309
行业中的每个人都在尝试

00:07:18.959 --> 00:07:21.809
处理这个，你知道我们怎么能

00:07:20.309 --> 00:07:23.129
提供Java re功能

00:07:21.809 --> 00:07:25.829
无需每个人都采取

00:07:23.129 --> 00:07:28.739
一切都是自由的

00:07:25.829 --> 00:07:31.439
我在IBM工作的运行时我们花了一个

00:07:28.739 --> 00:07:34.019
我们分解Java的方法

00:07:31.439 --> 00:07:35.759
规格被称为

00:07:34.019 --> 00:07:37.739
功能，您可以配置混合

00:07:35.759 --> 00:07:40.289
并匹配您想要的功能，如果

00:07:37.739 --> 00:07:42.300
你想拥有jax-rs并且你想要

00:07:40.289 --> 00:07:43.979
打开api可以得到这两件事

00:07:42.300 --> 00:07:46.049
但您不必采用EJB 

00:07:43.979 --> 00:07:48.569
容器Web服务堆栈等

00:07:46.049 --> 00:07:49.800
事实上，我们并不是唯一的人

00:07:48.569 --> 00:07:52.559
谁在按照这些思路思考

00:07:49.800 --> 00:07:54.539
因为刺尾是新名字

00:07:52.559 --> 00:07:57.119
对于野生流群基本上具有

00:07:54.539 --> 00:07:59.399
您可以选择采用相同的模型

00:07:57.119 --> 00:08:01.559
运行时，您需要以下优势

00:07:59.399 --> 00:08:05.069
这意味着您的运行时

00:08:01.559 --> 00:08:07.019
较小的它们开始更快，他们

00:08:05.069 --> 00:08:08.909
为应用程序使用更少的内存

00:08:07.019 --> 00:08:10.949
需要你拥有所有这些东西

00:08:08.909 --> 00:08:12.989
关于Java re'有点大而

00:08:10.949 --> 00:08:15.539
沉重的重量不再是真的

00:08:12.989 --> 00:08:19.100
除非您仍在使用应用程序

00:08:15.539 --> 00:08:24.000
大约10到15年前的服务器

00:08:19.100 --> 00:08:26.310
所以我用Eclipse的微配置文件

00:08:24.000 --> 00:08:27.870
我认为我们开始的Eclipse项目

00:08:26.310 --> 00:08:29.910
一年半也许两年

00:08:27.870 --> 00:08:31.380
现在以前，它实际上已经

00:08:29.910 --> 00:08:33.810
很多参与其中的公司

00:08:31.380 --> 00:08:36.720
对它成功感兴趣

00:08:33.810 --> 00:08:40.700
最近像Bend和Microsoft 

00:08:36.720 --> 00:08:43.229
在联合聚会中

00:08:40.700 --> 00:08:46.470
有趣和有用的一些是

00:08:43.229 --> 00:08:49.940
我认为部分原因是对

00:08:46.470 --> 00:08:52.050
以及Java EE的日蚀

00:08:49.940 --> 00:08:54.300
但是我们在微电子上要做的是

00:08:52.050 --> 00:08:55.920
简介是为了加快交付

00:08:54.300 --> 00:08:59.850
建立在新的编程模型之上

00:08:55.920 --> 00:09:01.530
种Java EE，最初是Java 

00:08:59.850 --> 00:09:03.300
 re'仍在我们认为的JCP中

00:09:01.530 --> 00:09:05.760
我们将在微型文件中开发这些文件， 

00:09:03.300 --> 00:09:07.560
他们更标准化不确定

00:09:05.760 --> 00:09:09.210
到底会发生什么

00:09:07.560 --> 00:09:11.760
关系向前发展，但这是

00:09:09.210 --> 00:09:14.370
它会工作，我们会使其工作

00:09:11.760 --> 00:09:19.290
因为这些杯子大多数都涉及

00:09:14.370 --> 00:09:20.820
就像我说的那样，在雅加达EE中

00:09:19.290 --> 00:09:23.100
你在做微服务，我要

00:09:20.820 --> 00:09:25.410
进入您可能正在使用的演示

00:09:23.100 --> 00:09:28.800
 REST API，我们开始谈论

00:09:25.410 --> 00:09:30.600
我们说过的微观概况的基础

00:09:28.800 --> 00:09:33.390
只是从休息开始，我们需要开始

00:09:30.600 --> 00:09:36.030
某个地区和地区定义的CDI 

00:09:33.390 --> 00:09:38.130
 JSONP和jax-rs是核心

00:09:36.030 --> 00:09:40.340
其余组件以及最近的组件

00:09:38.130 --> 00:09:42.120
我们添加了基于模板的休息

00:09:40.340 --> 00:09:43.860
客户，我想我从来没有

00:09:42.120 --> 00:09:47.820
教导可能是另一回事

00:09:43.860 --> 00:09:49.260
那不行，所以我要去做，我是

00:09:47.820 --> 00:09:51.590
将对所有这些进行快速演示

00:09:49.260 --> 00:09:51.590
和

00:09:53.430 --> 00:09:58.540
所以我在演示中可能有

00:09:56.560 --> 00:10:00.700
最过度设计的Java代码

00:09:58.540 --> 00:10:02.830
我曾经有过写作的不幸

00:10:00.700 --> 00:10:04.540
我写的Java代码几乎

00:10:02.830 --> 00:10:06.970
我写的所有Java代码都结束了

00:10:04.540 --> 00:10:09.010
以某种方式设计的我可以提供服务

00:10:06.970 --> 00:10:12.430
称为服务C，它返回系统

00:10:09.010 --> 00:10:14.620
属性，我有一个服务

00:10:12.430 --> 00:10:16.630
本质上只是返回结果

00:10:14.620 --> 00:10:19.000
来自服务C的原因

00:10:16.630 --> 00:10:20.589
是服务，可以致电服务C， 

00:10:19.000 --> 00:10:23.200
基本上告诉服务C模拟

00:10:20.589 --> 00:10:26.160
几个恶劣的条件，所以我可以问

00:10:23.200 --> 00:10:28.660
服务C做一些不同的事情

00:10:26.160 --> 00:10:30.010
根据输入参数

00:10:28.660 --> 00:10:35.950
演示一些麦克风

00:10:30.010 --> 00:10:40.900
功能，所以我要走了

00:10:35.950 --> 00:10:42.400
并找到代码就可以了

00:10:40.900 --> 00:10:48.960
我已经看到人们可以阅读这篇文章

00:10:42.400 --> 00:10:48.960
基本上这是我的服务C代码， 

00:10:49.020 --> 00:10:57.220
我有一个方法，基本上

00:10:54.400 --> 00:10:59.640
它所做的是它带给您财产

00:10:57.220 --> 00:11:03.430
给它一个模式和一个属性名， 

00:10:59.640 --> 00:11:05.470
它基本上住在这里

00:11:03.430 --> 00:11:07.450
我会告诉你一秒钟吗

00:11:05.470 --> 00:11:09.670
基本上看模式，并根据

00:11:07.450 --> 00:11:13.150
该模式执行一些不同的行为

00:11:09.670 --> 00:11:15.100
所以如果你说你希望它慢一点

00:11:13.150 --> 00:11:18.490
增加睡眠，因此至少需要两个

00:11:15.100 --> 00:11:21.100
秒响应，因此模拟

00:11:18.490 --> 00:11:25.000
具有某种意义的服务

00:11:21.100 --> 00:11:28.660
问题或返回失败或

00:11:25.000 --> 00:11:31.180
有时会在内部返回失败

00:11:28.660 --> 00:11:33.130
可能在代码中只是在做

00:11:31.180 --> 00:11:34.450
系统获取属性，这就是为什么

00:11:33.130 --> 00:11:39.370
我说这是我做过的最精心设计的代码

00:11:34.450 --> 00:11:41.920
曾经写过并且在服役中，我有一个

00:11:39.370 --> 00:11:47.290
 REST API基本上是在调用

00:11:41.920 --> 00:11:50.860
助手和助手在这种情况下是

00:11:47.290 --> 00:11:54.660
只是显然不编译我去过

00:11:50.860 --> 00:11:54.660
 s代码有问题

00:11:55.520 --> 00:12:05.260
它称其等于客户

00:11:58.940 --> 00:12:05.260
使用get prop的界面，并且没有和

00:12:05.410 --> 00:12:09.530
如果你看这里我在做什么

00:12:08.030 --> 00:12:11.990
我反对其他客户吗

00:12:09.530 --> 00:12:15.470
如果我看看其余的客户

00:12:11.990 --> 00:12:19.210
使用基于模板的方法

00:12:15.470 --> 00:12:21.560
用jax-rs注释对其进行注释，然后

00:12:19.210 --> 00:12:23.720
你说这是一个登记逮捕

00:12:21.560 --> 00:12:25.730
很好，然后在方法上我说我

00:12:23.720 --> 00:12:28.460
当有人调用此方法时，我想

00:12:25.730 --> 00:12:30.290
去做这条路

00:12:28.460 --> 00:12:31.760
应用程序Jason和我指定了这个

00:12:30.290 --> 00:12:34.390
将作为查询参数

00:12:31.760 --> 00:12:34.390
和

00:12:37.399 --> 00:12:42.029
这是一个路径参数，所以当您

00:12:40.559 --> 00:12:43.079
称我不必实施

00:12:42.029 --> 00:12:45.179
他们编写新界面的界面

00:12:43.079 --> 00:12:47.339
我只需要的jax-rs客户代码

00:12:45.179 --> 00:12:50.179
给接口加注释，然后就可以得到它

00:12:47.339 --> 00:12:50.179
注入并

00:12:51.680 --> 00:13:00.860
我真的很希望当我跑步时

00:12:54.649 --> 00:13:03.939
通过它可以工作并且编译器

00:13:00.860 --> 00:13:03.939
不必担心前卫

00:13:04.740 --> 00:13:18.410
好吧，显然我不是很幸运

00:13:14.370 --> 00:13:18.410
在我进来之前做过工作

00:13:25.420 --> 00:13:30.360
我做包装让我们看看我的行家

00:13:27.730 --> 00:13:30.360
编译

00:13:32.220 --> 00:13:38.220
是的

00:13:33.930 --> 00:13:41.910
好的，所以希望所有这些都可以编译

00:13:38.220 --> 00:13:46.800
是的，好吧，现在我正在做的是

00:13:41.910 --> 00:13:48.870
如果我放大，您会在这里注意到

00:13:46.800 --> 00:13:51.210
我没什么特别的

00:13:48.870 --> 00:13:53.250
所以我要索取服务名称， 

00:13:51.210 --> 00:13:55.290
告诉你这是服务C，但是如果你

00:13:53.250 --> 00:13:56.820
看URL路径在这里说

00:13:55.290 --> 00:14:00.120
我称服务不是

00:13:56.820 --> 00:14:02.750
服务C，所以这只是钻石而已

00:14:00.120 --> 00:14:05.190
我正在做的是稍后再演示

00:14:02.750 --> 00:14:06.630
这将变成一个不同的值，但是

00:14:05.190 --> 00:14:12.560
这只是表明我有点

00:14:06.630 --> 00:14:12.560
 proc看到一切顺利

00:14:14.139 --> 00:14:21.250
所以如果这仅仅是如何

00:14:17.709 --> 00:14:23.769
样品也在起作用

00:14:21.250 --> 00:14:25.509
试图看看你如何对待你

00:14:23.769 --> 00:14:27.550
提供一个让您管理的地方

00:14:25.509 --> 00:14:30.069
当您有大量的服务时

00:14:27.550 --> 00:14:32.440
他们我在这里说数百

00:14:30.069 --> 00:14:35.740
一些应用程序10可能很大

00:14:32.440 --> 00:14:40.980
数字，所以我们添加了PS4健康检查

00:14:35.740 --> 00:14:40.980
开放的API和指标

00:14:41.540 --> 00:14:51.820
还有15分钟，如果我走

00:14:47.420 --> 00:14:56.510
返回我要出示健康检查

00:14:51.820 --> 00:14:58.250
是的，所以我写了一个

00:14:56.510 --> 00:14:59.870
我的健康终点，我可以做到这一点

00:14:58.250 --> 00:15:08.810
并刷新它，代码是什么

00:14:59.870 --> 00:15:11.350
代码是做什么的

00:15:08.810 --> 00:15:11.350
制造

00:15:12.649 --> 00:15:20.029
好的，那更好，这里的代码

00:15:17.449 --> 00:15:23.079
我们正在做的是让您的L 

00:15:20.029 --> 00:15:28.910
服务C使用配置注入我

00:15:23.079 --> 00:15:30.889
创建jax-rs客户端不一样

00:15:28.910 --> 00:15:33.619
我现在使用代码之前使用过的一种

00:15:30.889 --> 00:15:36.170
我本来会写，然后

00:15:33.619 --> 00:15:38.509
当我向他们提出要求时，我看起来

00:15:36.170 --> 00:15:41.869
状态为200且它们返回false 

00:15:38.509 --> 00:15:45.860
所以如果我要去关闭

00:15:41.869 --> 00:15:49.249
我可以做到的服务C是

00:15:45.860 --> 00:15:51.589
传教士右边是这样

00:15:49.249 --> 00:15:54.819
如果我关闭服务C并返回

00:15:51.589 --> 00:15:57.860
现在刷新，您将看到它已关闭

00:15:54.819 --> 00:15:59.749
所以我不推荐那种写作

00:15:57.860 --> 00:16:00.889
通过这种方式进行健康检查，因为

00:15:59.749 --> 00:16:02.990
你应该写你的代码是

00:16:00.889 --> 00:16:05.209
有弹性地应对服务下降

00:16:02.990 --> 00:16:07.279
能够应付，但这是一种简单的方法

00:16:05.209 --> 00:16:08.959
证明您的医疗保健可以

00:16:07.279 --> 00:16:10.819
编写一些代码并做一些逻辑

00:16:08.959 --> 00:16:13.129
弄清楚它是否启动以及您正在做什么

00:16:10.819 --> 00:16:15.709
健康检查里面可能做的是

00:16:13.129 --> 00:16:17.420
做类似的事情来确保你是否

00:16:15.709 --> 00:16:19.160
调用自己的数据库，确保输入

00:16:17.420 --> 00:16:21.290
数据库启动，您可能正在寻找

00:16:19.160 --> 00:16:24.259
在你可能正在启动，所以你

00:16:21.290 --> 00:16:25.579
确保任何内部缓存和您

00:16:24.259 --> 00:16:27.350
表示你沮丧，直到你

00:16:25.579 --> 00:16:28.579
总缓存已建立，并且

00:16:27.350 --> 00:16:30.410
表示当您在

00:16:28.579 --> 00:16:32.990
云环境中，您可以确保

00:16:30.410 --> 00:16:34.939
前端路透社没有路由

00:16:32.990 --> 00:16:37.279
吸引您，所以如果您在

00:16:34.939 --> 00:16:39.230
 kubernetes环境可以检查一下

00:16:37.279 --> 00:16:42.559
健康点，直到恢复

00:16:39.230 --> 00:16:46.069
它没有路由流量，所以我

00:16:42.559 --> 00:16:48.920
只是要提出另一个

00:16:46.069 --> 00:16:51.620
我们所做的是，我们拥有

00:16:48.920 --> 00:16:53.870
这是您我们可以生成开放API 

00:16:51.620 --> 00:16:57.110
文档基于jax-rs 

00:16:53.870 --> 00:16:59.809
注释也可以提供一个开放的

00:16:57.110 --> 00:17:02.449
 REST API和

00:16:59.809 --> 00:17:05.360
您可以将其他数据注释为

00:17:02.449 --> 00:17:07.789
您的jax-rs和美好的事物

00:17:05.360 --> 00:17:11.539
关于那是你可以然后得到一个用户

00:17:07.789 --> 00:17:14.959
界面，您可以使用此

00:17:11.539 --> 00:17:17.480
打开API浏览应用程序并启动

00:17:14.959 --> 00:17:19.819
与之互动而不与

00:17:17.480 --> 00:17:22.789
使用API​​，所以如果我想说我想要

00:17:19.819 --> 00:17:26.190
做它告诉我，有一个

00:17:22.789 --> 00:17:31.860
模式查询字符串和属性查询

00:17:26.190 --> 00:17:33.210
字符串，我可以尝试一下，但我不是

00:17:31.860 --> 00:17:35.370
会指出什么是模式，但是我

00:17:33.210 --> 00:17:37.290
会说我想要房产所以我

00:17:35.370 --> 00:17:42.450
要说在家工作，如果我

00:17:37.290 --> 00:17:44.850
点击执行加载，它会告诉我

00:17:42.450 --> 00:17:47.610
我的Java的Java主页已安装

00:17:44.850 --> 00:17:50.580
显然我正在使用Java 9 

00:17:47.610 --> 00:17:52.920
不想这样做

00:17:50.580 --> 00:17:58.200
当他看到Java 9时一切正常

00:17:52.920 --> 00:18:02.600
而不是一个点是和

00:17:58.200 --> 00:18:02.600
如果我去的话，我们添加的其他内容

00:18:06.130 --> 00:18:16.720
是的，我们添加的另一件事是指标

00:18:13.180 --> 00:18:18.370
所以乔佛里没有的一件事

00:18:16.720 --> 00:18:20.230
确实是一种应用程序

00:18:18.370 --> 00:18:21.970
为大多数应用贡献指标

00:18:20.230 --> 00:18:24.100
服务器定义了一些指标

00:18:21.970 --> 00:18:25.960
一些规范定义了用于

00:18:24.100 --> 00:18:27.610
指标，但没有任何办法

00:18:25.960 --> 00:18:29.440
应用程序的指标

00:18:27.610 --> 00:18:31.260
对我的应用程序很重要，因为

00:18:29.440 --> 00:18:33.820
与这些相对的是

00:18:31.260 --> 00:18:37.690
应用程序服务器认为您可能

00:18:33.820 --> 00:18:39.700
有兴趣，所以我们在做什么

00:18:37.690 --> 00:18:42.880
微型指标，我们定义了一些

00:18:39.700 --> 00:18:46.110
注释和一些api 

00:18:42.880 --> 00:18:49.210
建立自己的应用程序相关

00:18:46.110 --> 00:18:51.460
事情，例如这种方法

00:18:49.210 --> 00:18:54.160
 CI正在使用哪个

00:18:51.460 --> 00:18:56.140
注释并采取行动而不是在

00:18:54.160 --> 00:18:58.540
时间是不是说时间多久了

00:18:56.140 --> 00:19:00.730
方法执行表格，然后您可以获取

00:18:58.540 --> 00:19:02.740
这些信息输入到类似

00:19:00.730 --> 00:19:05.110
普罗米修斯和你一样

00:19:02.740 --> 00:19:08.170
监视工具和您的监视工具

00:19:05.110 --> 00:19:10.750
然后可以做一些事情，比如告诉你什么时候

00:19:08.170 --> 00:19:11.980
您的方法调用开始

00:19:10.750 --> 00:19:13.630
放慢脚步，那可能是

00:19:11.980 --> 00:19:17.650
表示有问题， 

00:19:13.630 --> 00:19:19.090
您需要采取创造性的行动，您

00:19:17.650 --> 00:19:20.770
可以将其应用于您所使用的方法

00:19:19.090 --> 00:19:22.630
认为重要而不是重要

00:19:20.770 --> 00:19:25.120
说servlet方法或jax-rs 

00:19:22.630 --> 00:19:26.500
方法，因此任何CDI Bean都可以拥有

00:19:25.120 --> 00:19:30.040
你知道有一个CDI Bean 

00:19:26.500 --> 00:19:31.420
昂贵或可能击中此类

00:19:30.040 --> 00:19:33.040
有问题可以放注释

00:19:31.420 --> 00:19:35.350
完全围绕您的代码

00:19:33.040 --> 00:19:36.970
感兴趣，我也用过

00:19:35.350 --> 00:19:39.100
算，这基本上算

00:19:36.970 --> 00:19:41.440
执行某件事的次数，因此

00:19:39.100 --> 00:19:43.470
他们进入Prometheus用户界面

00:19:41.440 --> 00:19:45.940
我只是要刷新一下

00:19:43.470 --> 00:19:48.160
你会发现这里有一种bea 

00:19:45.940 --> 00:19:51.220
我一直在测试的图形

00:19:48.160 --> 00:19:54.100
然后因为我刷新了

00:19:51.220 --> 00:19:56.890
只有一个调用

00:19:54.100 --> 00:20:00.100
希望你可以在那里阅读，如果我去

00:19:56.890 --> 00:20:06.210
返回，我刷新让我刷新

00:20:00.100 --> 00:20:06.210
直接服务c 

00:20:06.409 --> 00:20:09.100
应该

00:20:10.549 --> 00:20:16.080
不应该，你可以看看

00:20:13.350 --> 00:20:17.610
它受两个约束，所以有

00:20:16.080 --> 00:20:19.620
另一个调用，所以当我做一个

00:20:17.610 --> 00:20:22.070
调用在此处显示

00:20:19.620 --> 00:20:22.070
直

00:20:25.910 --> 00:20:36.600
好吧，接下来我想这样

00:20:34.250 --> 00:20:39.540
能够监控不一定

00:20:36.600 --> 00:20:41.130
足够您还希望我们能够

00:20:39.540 --> 00:20:43.260
还需要我们需要提供的思想

00:20:41.130 --> 00:20:44.700
编程的一些其他API 

00:20:43.260 --> 00:20:46.560
处理这些分布式模型

00:20:44.700 --> 00:20:48.540
系统，所以我向您展示了一些

00:20:46.560 --> 00:20:53.580
的配置，我没有，我不会

00:20:48.540 --> 00:20:55.770
向JWT展示，因为我没有时间，但我

00:20:53.580 --> 00:20:57.270
有一些使用示例

00:20:55.770 --> 00:20:59.940
为了宽容，你已经看到了一些

00:20:57.270 --> 00:21:06.060
他们已经，所以我可能要去一些

00:20:59.940 --> 00:21:07.800
新领域，但如果我回去，这就是

00:21:06.060 --> 00:21:09.870
有点让我有点紧张

00:21:07.800 --> 00:21:16.860
因为我今天早上都看过

00:21:09.870 --> 00:21:20.430
所以在服务中不是这样的

00:21:16.860 --> 00:21:22.080
服务休息我是我已经得到了

00:21:20.430 --> 00:21:26.010
服务道具助手和此获取

00:21:22.080 --> 00:21:30.420
服务歌剧，如果我给你看

00:21:26.010 --> 00:21:34.350
只是打电话给客户从得到

00:21:30.420 --> 00:21:35.760
没有模式作为道具，所以我

00:21:34.350 --> 00:21:37.260
想做的是我想模拟一个

00:21:35.760 --> 00:21:39.030
错误情况，所以我要做什么

00:21:37.260 --> 00:21:41.690
我要告诉下游

00:21:39.030 --> 00:21:41.690
服务

00:21:42.080 --> 00:21:46.419
我想要

00:21:49.160 --> 00:22:00.340
等待，那是正确的之一

00:21:57.180 --> 00:22:03.330
限定词被编译

00:22:00.340 --> 00:22:03.330
现在

00:22:07.600 --> 00:22:14.110
好吧，那已经固定了，所以我

00:22:11.620 --> 00:22:15.880
这里有这个光束，基本上

00:22:14.110 --> 00:22:17.680
与香草香草完全一样

00:22:15.880 --> 00:22:19.030
除了我说过几次

00:22:17.680 --> 00:22:20.530
当我说C时会做什么

00:22:19.030 --> 00:22:22.750
有时这会使一切失败

00:22:20.530 --> 00:22:25.600
每隔一段时间，然后我需要

00:22:22.750 --> 00:22:27.790
在我的休息服务中要做的就是告诉

00:22:25.600 --> 00:22:30.430
注入有时的

00:22:27.790 --> 00:22:35.230
相反，所以现在如果我回到这里

00:22:30.430 --> 00:22:37.960
我去刷新它说超过500我不能

00:22:35.230 --> 00:22:43.210
解决，如果我再次刷新它可以工作

00:22:37.960 --> 00:22:45.910
如果我要看普罗米修斯，如果我

00:22:43.210 --> 00:22:48.460
刷新您实际上会注意到的图形

00:22:45.910 --> 00:22:50.290
在这里有四个，因为我

00:22:48.460 --> 00:22:52.590
实际上是模拟失败

00:22:50.290 --> 00:22:56.140
到目标就可以了

00:22:52.590 --> 00:22:57.580
但是你知道没有人想要你知道

00:22:56.140 --> 00:22:59.050
您是Air Air的所有者

00:22:57.580 --> 00:23:01.270
不想在服务时被召唤

00:22:59.050 --> 00:23:04.180
 C开始向您吐出虚假箭头

00:23:01.270 --> 00:23:10.360
所以在这种情况下你可以做的是

00:23:04.180 --> 00:23:14.020
可以使用重试可以使用重试

00:23:10.360 --> 00:23:16.660
注解，所以如果我添加该重试

00:23:14.020 --> 00:23:19.150
这种方法将要问的是

00:23:16.660 --> 00:23:21.430
 CDI拦截器蓝色被配置

00:23:19.150 --> 00:23:25.090
因此，如果失败，它将自动执行

00:23:21.430 --> 00:23:27.430
重试，并且可以配置多少

00:23:25.090 --> 00:23:29.110
我们尝试放置什么时间单位

00:23:27.430 --> 00:23:30.970
但我只是添加一棵树

00:23:29.110 --> 00:23:33.910
这里的简单案例的注释和

00:23:30.970 --> 00:23:37.480
现在，如果我刷新需要一点时间

00:23:33.910 --> 00:23:41.590
更长，但每次都响应

00:23:37.480 --> 00:23:43.960
再一次，如果我去普罗米修斯，你会

00:23:41.590 --> 00:23:45.520
看到它上升了，现在是八点

00:23:43.960 --> 00:23:49.120
我回去刷新的那一刻

00:23:45.520 --> 00:23:52.480
再次，我回到这里刷新

00:23:49.120 --> 00:23:54.520
它应该上升到十，它已经

00:23:52.480 --> 00:23:57.130
这样便可以看到它正在做两个

00:23:54.520 --> 00:23:59.380
请求，因为普罗米修斯在告诉

00:23:57.130 --> 00:24:00.940
我们只有两个请求

00:23:59.380 --> 00:24:03.390
我只刷新了一个事实

00:24:00.940 --> 00:24:03.390
那时

00:24:03.740 --> 00:24:10.230
所以这就是这样做的方法

00:24:07.770 --> 00:24:11.520
使用重试您可能想要的另一件事

00:24:10.230 --> 00:24:13.590
要做的是您可能有服务

00:24:11.520 --> 00:24:15.030
麻烦了

00:24:13.590 --> 00:24:16.890
放慢脚步，也许负载太大

00:24:15.030 --> 00:24:22.650
在它上面，所以每个请求花费更长的时间

00:24:16.890 --> 00:24:25.779
所以我要注入一个不同的

00:24:22.650 --> 00:24:29.700
不同版本

00:24:25.779 --> 00:24:32.830
这是慢版本吗？ 

00:24:29.700 --> 00:24:34.719
如果我看一下便条，我就是帮手

00:24:32.830 --> 00:24:37.960
这就是我说的话

00:24:34.719 --> 00:24:39.789
我已经将慢速模式推入

00:24:37.960 --> 00:24:42.099
慢速告诉你的就是

00:24:39.789 --> 00:24:46.090
只是等待两秒钟，所以如果我走

00:24:42.099 --> 00:24:48.759
回来，我去要求它，现在是

00:24:46.090 --> 00:24:50.769
要花一点时间，这

00:24:48.759 --> 00:24:52.059
这有点沉闷吗

00:24:50.769 --> 00:24:55.479
您会发现它花了更长的时间

00:24:52.059 --> 00:24:57.820
回应，所以这对我来说不是很好

00:24:55.479 --> 00:24:59.649
因为我现在想念老鼠SLA而我

00:24:57.820 --> 00:25:00.879
接到客户的电话

00:24:59.649 --> 00:25:03.399
告诉我为什么你放慢我的速度

00:25:00.879 --> 00:25:05.259
而不是服务C必须是

00:25:03.399 --> 00:25:07.330
在凌晨2:00在床上下床

00:25:05.259 --> 00:25:09.839
早上，在这种情况下，我要去的是

00:25:07.330 --> 00:25:12.219
要做的就是我超时了

00:25:09.839 --> 00:25:14.489
注释，我要告诉我

00:25:12.219 --> 00:25:17.950
要五百分钟后超时

00:25:14.489 --> 00:25:20.710
毫秒，所以如果我现在回去

00:25:17.950 --> 00:25:22.239
刷新大约要执行五次

00:25:20.710 --> 00:25:24.249
一百秒，然后我就讨厌了

00:25:22.239 --> 00:25:25.690
可怕的错误，所以现在我的客户知道

00:25:24.249 --> 00:25:26.739
有一个超时条件

00:25:25.690 --> 00:25:29.379
真的很棒

00:25:26.739 --> 00:25:31.899
但我仍然被叫起床

00:25:29.379 --> 00:25:34.359
我已经满足了我的时间SLA，但还没有满足

00:25:31.899 --> 00:25:35.979
我的API协议，因为我仍然

00:25:34.359 --> 00:25:37.719
返回失败，所以我仍然会得到

00:25:35.979 --> 00:25:40.179
清晨拉出更好

00:25:37.719 --> 00:25:41.289
所以在这种情况下要处理什么

00:25:40.179 --> 00:25:43.119
我要做的就是找到一个

00:25:41.289 --> 00:25:44.589
后备，您可以添加一个

00:25:43.119 --> 00:25:46.719
注释或后备，我要

00:25:44.589 --> 00:25:51.279
在这种情况下，你就可以安全地卫冕

00:25:46.719 --> 00:26:01.839
后卫的方法，然后我的后备

00:25:51.279 --> 00:26:06.669
方法将调用后卫，我

00:26:01.839 --> 00:26:13.899
将要返回的新道具道具名称

00:26:06.669 --> 00:26:15.759
然后我将系统获取属性，以便

00:26:13.899 --> 00:26:18.099
我在这里所做的是方法

00:26:15.759 --> 00:26:20.019
方法参数完全相同

00:26:18.099 --> 00:26:21.099
方法的返回类型恰好是

00:26:20.019 --> 00:26:22.029
一样，只是方法名称而已

00:26:21.099 --> 00:26:25.119
不同，因为它们在同一个地方

00:26:22.029 --> 00:26:26.769
类，当它这次失败后

00:26:25.119 --> 00:26:28.210
 500秒只是在打电话

00:26:26.769 --> 00:26:30.269
一种以及您将能够分辨的方式

00:26:28.210 --> 00:26:35.580
它会开始返回服务吗

00:26:30.269 --> 00:26:35.580
而不是服务C，所以如果我刷新

00:26:35.740 --> 00:26:41.860
它说服务我这是这个

00:26:39.429 --> 00:26:44.230
你怎么知道，但它已经完成了

00:26:41.860 --> 00:26:45.909
后卫的逻辑，如果我回去，我

00:26:44.230 --> 00:26:49.380
改变了我可以得到的模式

00:26:45.909 --> 00:26:49.380
真的再打一次电话

00:26:51.429 --> 00:26:56.739
这就是公司的演示

00:26:54.279 --> 00:26:59.219
还有更多我没有的东西

00:26:56.739 --> 00:27:02.080
有时间我没时间演示

00:26:59.219 --> 00:27:04.149
有断路器的支持

00:27:02.080 --> 00:27:06.509
我认为这是在专利中展示的

00:27:04.149 --> 00:27:09.849
今天早上的第一次谈话基本上

00:27:06.509 --> 00:27:11.440
可以让您进行自我修复

00:27:09.849 --> 00:27:13.989
如果您遇到一定数量的失败

00:27:11.440 --> 00:27:16.149
它将停止呼叫下游

00:27:13.989 --> 00:27:18.669
服务会自动呼叫您

00:27:16.149 --> 00:27:20.919
后备方法（如果您进行一次设置） 

00:27:18.669 --> 00:27:22.690
然后如果目标服务来了

00:27:20.919 --> 00:27:24.159
再次备份会自我修复

00:27:22.690 --> 00:27:27.549
然后一旦目标就开始调用它

00:27:24.159 --> 00:27:30.489
服务处于良好状态

00:27:27.549 --> 00:27:31.989
还有大量的标题，所以如果你有

00:27:30.489 --> 00:27:33.729
如果您有下游服务， 

00:27:31.989 --> 00:27:35.769
对多少有某种限制

00:27:33.729 --> 00:27:37.749
要求它可以处理您可以确保

00:27:35.769 --> 00:27:39.549
您没有通过太多请求

00:27:37.749 --> 00:27:40.960
不能对不起

00:27:39.549 --> 00:27:44.229
例如它只能处理十个

00:27:40.960 --> 00:27:47.529
并发请求，或者您只能说

00:27:44.229 --> 00:27:49.389
一次发出十个并发请求q 

00:27:47.529 --> 00:27:52.989
其他的直到下一个是

00:27:49.389 --> 00:27:54.429
现在完成的问题之一

00:27:52.989 --> 00:27:57.759
经常出现的是连续性

00:27:54.429 --> 00:27:59.109
像Sto这样的服务网格，答案是

00:27:57.759 --> 00:28:01.239
有点

00:27:59.109 --> 00:28:03.039
我说的原因是因为

00:28:01.239 --> 00:28:05.649
关于SDO的好处是

00:28:03.039 --> 00:28:07.509
你有能力加一些毛病

00:28:05.649 --> 00:28:09.909
网络层的容忍行为

00:28:07.509 --> 00:28:12.099
这意味着您不必

00:28:09.909 --> 00:28:13.629
将其全部编码在您的应用程序中

00:28:12.099 --> 00:28:15.099
执行此操作时要注意的是

00:28:13.629 --> 00:28:17.710
灵活性较差，因为

00:28:15.099 --> 00:28:19.269
它仅在网络层，所以如果您

00:28:17.710 --> 00:28:22.899
想做你的容错

00:28:19.269 --> 00:28:25.149
围绕一组网络交互

00:28:22.899 --> 00:28:27.489
喜欢休息电话或宁静的数据库

00:28:25.149 --> 00:28:29.919
打电话，那么你不能，因为那会

00:28:27.489 --> 00:28:31.989
应用于对方的每个拨出电话

00:28:29.919 --> 00:28:35.830
问题是它的地理位置无法处理

00:28:31.989 --> 00:28:38.019
 HTTP，因为如果您希望HTS成为HTT 

00:28:35.830 --> 00:28:41.139
端到端加密，因此如果您想

00:28:38.019 --> 00:28:43.659
用这个你需要HTTP吗

00:28:41.139 --> 00:28:46.809
从您的服务器说到sto，然后

00:28:43.659 --> 00:28:48.039
 HTTP将从那里开始，但是

00:28:46.809 --> 00:28:52.419
你那么你就没有

00:28:48.039 --> 00:28:54.099
端到端的安全性

00:28:52.419 --> 00:28:57.989
今年有一些限制

00:28:54.099 --> 00:28:59.729
对他们俩来说都是一个好地方

00:28:57.989 --> 00:29:03.549
下一步是什么

00:28:59.729 --> 00:29:04.770
 Jovie八，我迫在眉睫

00:29:03.549 --> 00:29:06.990
认为

00:29:04.770 --> 00:29:10.080
在下一版本的麦克风文件中

00:29:06.990 --> 00:29:11.970
我刚刚展示了1.3， 

00:29:10.080 --> 00:29:14.460
积极的工作组，研究如何带来

00:29:11.970 --> 00:29:18.150
反应程序模型到微轮廓

00:29:14.460 --> 00:29:21.480
我不得不说有点伤脑筋

00:29:18.150 --> 00:29:24.210
整个反应性事物，但同时

00:29:21.480 --> 00:29:25.950
我知道的时间足以知道

00:29:24.210 --> 00:29:28.020
这是实际上是

00:29:25.950 --> 00:29:30.600
真的很重要，我正在努力

00:29:28.020 --> 00:29:33.120
我的头上有一个讨论

00:29:30.600 --> 00:29:34.860
目前有关数据访问的原因是

00:29:33.120 --> 00:29:37.080
没有关于如何访问的声明

00:29:34.860 --> 00:29:39.060
数据是您是否默认的一种

00:29:37.080 --> 00:29:42.120
自己做会使用JP a，但是JP是

00:29:39.060 --> 00:29:43.710
没有通过微型个人资料

00:29:42.120 --> 00:29:46.020
有关如何改善

00:29:43.710 --> 00:29:47.250
这样做，因为什么

00:29:46.020 --> 00:29:49.050
你不想做的是

00:29:47.250 --> 00:29:51.750
应用程序注释和存储

00:29:49.050 --> 00:29:53.130
被捕获重试，因为如果

00:29:51.750 --> 00:29:55.230
通过尝试五次

00:29:53.130 --> 00:29:57.360
将要重新尝试25次

00:29:55.230 --> 00:29:59.970
总共在网络层

00:29:57.360 --> 00:30:01.920
有点疯狂，当然我们总是

00:29:59.970 --> 00:30:07.890
更新现有规格以使它们

00:30:01.920 --> 00:30:09.480
更好或基于反馈和最后

00:30:07.890 --> 00:30:12.300
部署方面有一个问题

00:30:09.480 --> 00:30:14.460
从之前的会议中了解了为什么

00:30:12.300 --> 00:30:16.020
将使用一种空心罐

00:30:14.460 --> 00:30:18.330
的方法，有一个暗示

00:30:16.020 --> 00:30:23.070
码头工人，所以我决定将其保留在我的

00:30:18.330 --> 00:30:25.590
甲板，所以春天特别大

00:30:23.070 --> 00:30:28.620
关于超级罐子或脂肪的事情

00:30:25.590 --> 00:30:30.120
罐子取决于您是否

00:30:28.620 --> 00:30:33.150
想要稍微消极或轻微

00:30:30.120 --> 00:30:35.070
对他们积极的旋转，它使它

00:30:33.150 --> 00:30:36.540
非常容易分发您的

00:30:35.070 --> 00:30:40.230
应用程序并运行它，因为你只是

00:30:36.540 --> 00:30:43.350
做Java-jar，但是你那种

00:30:40.230 --> 00:30:45.270
 jar文件很大，这意味着

00:30:43.350 --> 00:30:47.400
每次更改代码时， 

00:30:45.270 --> 00:30:49.110
最终推出了相当大的二进制文件

00:30:47.400 --> 00:30:51.090
因此，如果您看宠物诊所

00:30:49.110 --> 00:30:53.310
春假的例子大约是40 

00:30:51.090 --> 00:30:55.200
兆字节实际应用较少

00:30:53.310 --> 00:30:58.710
超过400 KB，如果您

00:30:55.200 --> 00:30:59.760
为附近分发一个新的鸟罐

00:30:58.710 --> 00:31:02.070
该应用程序

00:30:59.760 --> 00:31:03.510
每次部署时40兆字节

00:31:02.070 --> 00:31:05.160
通过网络传输

00:31:03.510 --> 00:31:06.930
如果您要部署，那不是问题

00:31:05.160 --> 00:31:09.720
例如每周一次，但如果您尝试

00:31:06.930 --> 00:31:11.780
持续交付和每次提交

00:31:09.720 --> 00:31:13.950
导致生产不良

00:31:11.780 --> 00:31:16.440
你可能正在做

00:31:13.950 --> 00:31:18.419
每天有数百次部署

00:31:16.440 --> 00:31:21.269
指出400 K与

00:31:18.419 --> 00:31:24.320
 40兆字节非常重要

00:31:21.269 --> 00:31:26.850
像空罐子这样的东西进来的地方

00:31:24.320 --> 00:31:29.250
因为你能做的是你可以推动

00:31:26.850 --> 00:31:31.080
您可以为您的特定图层

00:31:29.250 --> 00:31:32.850
必不可少的应用平台

00:31:31.080 --> 00:31:34.980
运行时服务器无论您要调用什么

00:31:32.850 --> 00:31:36.929
它与应用程序层分离

00:31:34.980 --> 00:31:38.580
并且由于码头工人的工作方式

00:31:36.929 --> 00:31:40.529
尽管您认为Docker映像是

00:31:38.580 --> 00:31:43.080
一件事实际上是一系列的

00:31:40.529 --> 00:31:46.169
具有指向其他图层的指针的图层

00:31:43.080 --> 00:31:48.389
如果你要推东西，那只会

00:31:46.169 --> 00:31:50.700
发送需要发送的图层

00:31:48.389 --> 00:31:52.980
如果是左手的话

00:31:50.700 --> 00:31:55.139
更改是仅应用程序代码

00:31:52.980 --> 00:31:57.750
将要转移400 KB 

00:31:55.139 --> 00:32:01.710
进行部署的应用程序

00:31:57.750 --> 00:32:06.779
更快，所以我没有时间，所以我只是

00:32:01.710 --> 00:32:07.980
要说的是摘要

00:32:06.779 --> 00:32:10.230
我还没有提到的东西

00:32:07.980 --> 00:32:12.630
无论如何，形状或形式都是

00:32:10.230 --> 00:32:14.909
要了解更多信息，请访问以下网址： 

00:32:12.630 --> 00:32:18.419
开放的自由网站，我们拥有一个整体

00:32:14.909 --> 00:32:22.799
一堆指南，通过每一个

00:32:18.419 --> 00:32:25.080
中的一项技术

00:32:22.799 --> 00:32:26.760
微型个人资料甚至还有

00:32:25.080 --> 00:32:29.279
互动的，所以如果你只得到帮助

00:32:26.760 --> 00:32:30.510
在笔记本电脑上的代码，您可以

00:32:29.279 --> 00:32:32.909
学习和理解一些

00:32:30.510 --> 00:32:38.519
模式直接在网络上使用

00:32:32.909 --> 00:32:41.140
浏览器，谢谢，我想我已经走了

00:32:38.519 --> 00:32:42.500
有时间提问，对不起

00:32:41.140 --> 00:32:49.349
您

00:32:42.500 --> 00:32:49.349
 [掌声] 

