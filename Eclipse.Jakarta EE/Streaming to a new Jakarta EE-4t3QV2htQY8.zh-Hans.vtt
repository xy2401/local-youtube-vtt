WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.000 --> 00:00:08.519
我们都有点累所以我到了

00:00:05.580 --> 00:00:14.070
两天前从这里起飞27小时

00:00:08.519 --> 00:00:16.650
澳大利亚大约现在的时间是11:45 

00:00:14.070 --> 00:00:18.930
 pm大概是两个

00:00:16.650 --> 00:00:21.029
我正常就寝时间之后的几个小时

00:00:18.930 --> 00:00:23.789
希望我的演讲会是

00:00:21.029 --> 00:00:27.289
只是很有趣，因为如果不是，我就是

00:00:23.789 --> 00:00:27.289
成为第一个睡着的人

00:00:28.340 --> 00:00:35.940
所以这个演讲叫做流媒体

00:00:31.679 --> 00:00:37.920
去Anu Jakarta AE，为什么会有我

00:00:35.940 --> 00:00:39.780
我叫詹姆斯·罗珀（James Roper） 

00:00:37.920 --> 00:00:44.579
我一路走来吗

00:00:39.780 --> 00:00:47.370
世界的一面与你交谈，所以我

00:00:44.579 --> 00:00:50.160
我要煮日食卡米尔

00:00:47.370 --> 00:00:54.570
微观轮廓

00:00:50.160 --> 00:00:57.660
我在一家公司工作的被动项目

00:00:54.570 --> 00:01:01.739
叫光弯曲这里的任何人都听说过

00:00:57.660 --> 00:01:04.019
轻弯一些，所以轻弯是

00:01:01.739 --> 00:01:06.350
背后的公司发生发挥框架

00:01:04.019 --> 00:01:11.670
登录和Scala编程语言

00:01:06.350 --> 00:01:14.580
我们也是在

00:01:11.670 --> 00:01:18.770
反应性宣言的创始成员

00:01:14.580 --> 00:01:23.100
反应流倡议和

00:01:18.770 --> 00:01:24.659
通常几乎没有任何反应

00:01:23.100 --> 00:01:25.880
减轻了它的手指

00:01:24.659 --> 00:01:28.770
某处

00:01:25.880 --> 00:01:31.200
所以我的角色是

00:01:28.770 --> 00:01:34.350
 CTO办公室的光弯办公室

00:01:31.200 --> 00:01:37.320
 CTO的团队是

00:01:34.350 --> 00:01:39.420
基本上不同的公司意味着

00:01:37.320 --> 00:01:44.540
 CTO有一个疯狂的主意，我必须

00:01:39.420 --> 00:01:47.939
去让它发生我

00:01:44.540 --> 00:01:53.009
共同创建的登录，因此登录就像Ben的

00:01:47.939 --> 00:01:55.079
反应性-服务框架，我用

00:01:53.009 --> 00:01:57.060
成为骄傲的技术领导

00:01:55.079 --> 00:01:59.070
技术后期播放框架

00:01:57.060 --> 00:02:02.460
高生产率反应网

00:01:59.070 --> 00:02:05.549
我之前的开发框架

00:02:02.460 --> 00:02:07.469
为设置而工作

00:02:05.549 --> 00:02:12.690
房间里的德国人可能在窃笑

00:02:07.469 --> 00:02:14.209
这是一个社交网络，我

00:02:12.690 --> 00:02:18.170
有偿加入

00:02:14.209 --> 00:02:20.480
然后开始下坡，所以我

00:02:18.170 --> 00:02:22.040
需要我可能想回到

00:02:20.480 --> 00:02:23.629
有一天德国会很酷，所以任何

00:02:22.040 --> 00:02:28.340
创业公司要我摧毁他们的

00:02:23.629 --> 00:02:32.299
公司让我知道，我曾在

00:02:28.340 --> 00:02:36.560
 Atlassian之前，我曾经使用

00:02:32.299 --> 00:02:40.040
我在j2ee上的职业生涯很坚定

00:02:36.560 --> 00:02:43.639
 1.4实际上并没有使用Java AE 

00:02:40.040 --> 00:02:49.280
愤怒，因为像吉布2.1和一些

00:02:43.639 --> 00:02:50.629
那些可爱的东西，那么我们是什么

00:02:49.280 --> 00:02:52.280
今天要看

00:02:50.629 --> 00:02:53.720
我们要看的第一件事

00:02:52.280 --> 00:02:55.540
这就是为什么我们需要流媒体，这就是

00:02:53.720 --> 00:02:59.689
演讲的第一部分非常

00:02:55.540 --> 00:03:01.730
与建筑无关

00:02:59.689 --> 00:03:03.680
真正的雅加达aa微型个人资料或

00:03:01.730 --> 00:03:07.629
像那样的东西

00:03:03.680 --> 00:03:12.139
将对比整体

00:03:07.629 --> 00:03:13.579
超细纤维tsa，我们将看到

00:03:12.139 --> 00:03:16.400
差异是什么约束

00:03:13.579 --> 00:03:17.900
约束条件的差异是和

00:03:16.400 --> 00:03:19.459
我们采取的技术挑战

00:03:17.900 --> 00:03:21.949
我们使用的传统方法

00:03:19.459 --> 00:03:24.169
我们尝试时拥有的整体

00:03:21.949 --> 00:03:26.870
将它们应用于整体式微

00:03:24.169 --> 00:03:30.109
服务，我们将看一下如何流式传输

00:03:26.870 --> 00:03:33.859
可以解决其中一些问题，我们将

00:03:30.109 --> 00:03:35.889
也有一个演示，在演示中，我们将

00:03:33.859 --> 00:03:38.959
看看一些开发规范

00:03:35.889 --> 00:03:41.530
对于Mac个人资料，我们将介绍一下

00:03:38.959 --> 00:03:46.419
一些可能的未来规格的想法，以及

00:03:41.530 --> 00:03:46.419
我们将看到流媒体的运行

00:03:47.050 --> 00:03:52.940
所以巨石让我们可以

00:03:49.750 --> 00:03:56.209
您可以想到的一致性

00:03:52.940 --> 00:03:59.090
就像氧气还可以，所以当我说

00:03:56.209 --> 00:04:01.459
从家里上班我不需要

00:03:59.090 --> 00:04:02.959
我一直都非常重要

00:04:01.459 --> 00:04:05.510
呼吸氧气，否则我会

00:04:02.959 --> 00:04:07.370
死了，但我不认为我在哪里

00:04:05.510 --> 00:04:09.319
当我到达时会得到氧气

00:04:07.370 --> 00:04:10.819
工作我该如何呼吸

00:04:09.319 --> 00:04:12.980
工作我不认为我只是为了

00:04:10.819 --> 00:04:16.010
当然，这很重要，但我

00:04:12.980 --> 00:04:19.639
理所当然，一致性是

00:04:16.010 --> 00:04:20.780
整体中有些相同，我们

00:04:19.639 --> 00:04:22.699
认为这是理所当然的，我们什至没有

00:04:20.780 --> 00:04:24.139
意识到这对我们很重要

00:04:22.699 --> 00:04:26.660
因为它非常重要

00:04:24.139 --> 00:04:31.100
很少有业务应用程序能够

00:04:26.660 --> 00:04:33.800
应对不一致的舞台编织

00:04:31.100 --> 00:04:35.240
例如订单服务说

00:04:33.800 --> 00:04:36.560
该订单已提交，并且

00:04:35.240 --> 00:04:38.090
付款服务说这笔订单

00:04:36.560 --> 00:04:41.330
不存在，因为那样你就不会得到

00:04:38.090 --> 00:04:43.100
支付订单，可以保持一致性

00:04:41.330 --> 00:04:46.419
是非常重要的，但独树一帜

00:04:43.100 --> 00:04:48.979
让我们认为这是理所当然的

00:04:46.419 --> 00:04:52.400
所以事实证明，当你只有一个

00:04:48.979 --> 00:04:53.780
数据库世界非常容易， 

00:04:52.400 --> 00:04:55.700
原因是我们可以使用

00:04:53.780 --> 00:04:57.560
我们可以使用资产的交易

00:04:55.700 --> 00:04:59.860
交易我们所有的业务都可以

00:04:57.560 --> 00:05:02.840
在交易内完成

00:04:59.860 --> 00:05:06.320
交易通过给我们这个来做到这一点

00:05:02.840 --> 00:05:08.930
单一持续电流的错觉

00:05:06.320 --> 00:05:11.180
国家有一个概念是什么

00:05:08.930 --> 00:05:12.919
现在系统状态还可以，我该怎么办

00:05:11.180 --> 00:05:17.300
现在就做什么现在看起来像什么

00:05:12.919 --> 00:05:20.360
现在的想法是什么

00:05:17.300 --> 00:05:23.810
所有一致的你不会去

00:05:20.360 --> 00:05:26.300
订单表，并说

00:05:23.810 --> 00:05:28.430
订单处于等待付款状态

00:05:26.300 --> 00:05:30.860
和付款表说

00:05:28.430 --> 00:05:34.419
不存在，你有这个一致

00:05:30.860 --> 00:05:37.130
现在的状态，一切都是一致的

00:05:34.419 --> 00:05:39.349
我们可以将数据视为

00:05:37.130 --> 00:05:42.410
静态的东西坐在那里休息

00:05:39.349 --> 00:05:44.930
等待我们的手术来

00:05:42.410 --> 00:05:47.150
在我们进行操作，然后我们

00:05:44.930 --> 00:05:50.449
承诺，我们走了，就是这样

00:05:47.150 --> 00:05:53.210
对我们来说，很有价值

00:05:50.449 --> 00:05:55.270
我们这样的交易确保了我们

00:05:53.210 --> 00:05:58.490
我们无法拥有原子操作

00:05:55.270 --> 00:05:59.150
如果我更新一个表，则进行部分更新

00:05:58.490 --> 00:06:01.730
和

00:05:59.150 --> 00:06:03.170
另一个表，更新失败

00:06:01.730 --> 00:06:05.810
到第一个表将被回滚

00:06:03.170 --> 00:06:08.530
他无法完成整个手术

00:06:05.810 --> 00:06:12.040
成功或它被回滚并

00:06:08.530 --> 00:06:18.140
一致性也会得到加强，因此如果我的

00:06:12.040 --> 00:06:20.960
付款表引用的订单

00:06:18.140 --> 00:06:22.850
数据库能够保证

00:06:20.960 --> 00:06:25.870
该订单存在于该订单中

00:06:22.850 --> 00:06:29.560
通过外键约束表

00:06:25.870 --> 00:06:31.610
并发也为我们处理

00:06:29.560 --> 00:06:33.710
除其他外，这意味着

00:06:31.610 --> 00:06:36.710
没有没有承诺的读你说你

00:06:33.710 --> 00:06:38.900
不能有东西进来

00:06:36.710 --> 00:06:43.040
看不见的数据，但后来恢复良好

00:06:38.900 --> 00:06:44.600
回来，所以如果我们要想像什么

00:06:43.040 --> 00:06:47.630
看起来我们可以想象

00:06:44.600 --> 00:06:51.770
我们有一个数据库，里面有

00:06:47.630 --> 00:06:54.260
一些表，交易可能

00:06:51.770 --> 00:06:56.660
进来，它说我想做一个

00:06:54.260 --> 00:06:59.510
对表进行数据库操作

00:06:56.660 --> 00:07:01.400
数据库的作用是

00:06:59.510 --> 00:07:03.860
如果实现了这种观点并说

00:07:01.400 --> 00:07:06.080
好吧，这是我的桌子，它们是你的

00:07:03.860 --> 00:07:07.280
与您合作可以做任何您想做的事

00:07:06.080 --> 00:07:08.720
与他们在一起，您不必担心

00:07:07.280 --> 00:07:11.180
当别人做这些的时候

00:07:08.720 --> 00:07:12.920
您的餐桌也一个人

00:07:11.180 --> 00:07:15.620
做你想做的另一笔交易

00:07:12.920 --> 00:07:17.900
可能会进来，它做同样的事情

00:07:15.620 --> 00:07:19.490
在这里进行交易

00:07:17.900 --> 00:07:20.990
可以做任何你想做的事

00:07:19.490 --> 00:07:23.090
不需要你一个人与你一起工作

00:07:20.990 --> 00:07:25.850
担心什么

00:07:23.090 --> 00:07:28.160
交易正在做，所以当那些

00:07:25.850 --> 00:07:31.100
事务都提交数据库

00:07:28.160 --> 00:07:34.400
通过它的魔力，他们

00:07:31.100 --> 00:07:36.410
说透通

00:07:34.400 --> 00:07:40.370
锁和各种事物确保

00:07:36.410 --> 00:07:42.200
那两个更新的状态最终被

00:07:40.370 --> 00:07:43.810
以某种方式合并到数据库中

00:07:42.200 --> 00:07:46.810
有道理，并保持

00:07:43.810 --> 00:07:46.810
一致性

00:07:49.370 --> 00:07:52.440
当我们转向云原生市场时

00:07:51.750 --> 00:07:55.260
服务

00:07:52.440 --> 00:07:56.550
我看不到这个世界

00:07:55.260 --> 00:07:58.830
一致的世界观

00:07:56.550 --> 00:08:01.490
可以分解我们的氧气

00:07:58.830 --> 00:08:04.980
消失了，我们不能再忍受了

00:08:01.490 --> 00:08:07.350
一致性Gravatt等问题

00:08:04.980 --> 00:08:09.900
是您在使用时知道的

00:08:07.350 --> 00:08:12.360
微服务每个微服务应

00:08:09.900 --> 00:08:14.760
有自己的数据库，自己的状态

00:08:12.360 --> 00:08:16.830
有一篇思想发表的文章

00:08:14.760 --> 00:08:20.190
最近基本的作品基本上说

00:08:16.830 --> 00:08:21.960
如果您是共享或数据库之间

00:08:20.190 --> 00:08:23.670
您没有的所有服务

00:08:21.960 --> 00:08:25.650
您不需要的服务之间的脱钩

00:08:23.670 --> 00:08:27.390
你只是更复杂

00:08:25.650 --> 00:08:30.450
没有微服务的部署

00:08:27.390 --> 00:08:32.400
微服务意味着h服务具有

00:08:30.450 --> 00:08:35.900
它自己的数据库，所以您有多个

00:08:32.400 --> 00:08:37.700
数据库，这使世界变得艰难

00:08:35.900 --> 00:08:40.940
因为你有多个数据库

00:08:37.700 --> 00:08:42.890
您现在在每个状态中都有许多状态

00:08:40.940 --> 00:08:44.570
您可以拥有资产的数据库

00:08:42.890 --> 00:08:46.279
交易一致的东西

00:08:44.570 --> 00:08:48.170
但是你有这些的多个版本

00:08:46.279 --> 00:08:49.690
你不可能有一个一致的电流

00:08:48.170 --> 00:08:52.130
世界观

00:08:49.690 --> 00:08:54.800
所以每个不同的服务都有自己的

00:08:52.130 --> 00:08:57.110
数据库对什么有自己的想法

00:08:54.800 --> 00:08:58.900
目前的状态是，他们还不是全部

00:08:57.110 --> 00:09:03.650
匹配，因为他们不能，因为

00:08:58.900 --> 00:09:05.779
交易不能花费服务，因此

00:09:03.650 --> 00:09:07.820
我们不能认为我们目前的状态是

00:09:05.779 --> 00:09:09.350
一直在等待的东西

00:09:07.820 --> 00:09:13.160
让我们提出要求，我们拥有的一切

00:09:09.350 --> 00:09:16.400
承认运动的本质

00:09:13.160 --> 00:09:18.050
系统的数据是我们有一些

00:09:16.400 --> 00:09:19.700
数据库中的数据，但有

00:09:18.050 --> 00:09:21.620
目前正在发生其他事情

00:09:19.700 --> 00:09:25.720
运动，我们必须想到我们的

00:09:21.620 --> 00:09:28.520
数据库中的数据一直在移动

00:09:25.720 --> 00:09:32.690
如果我们不能解决失败的话

00:09:28.520 --> 00:09:35.089
如果我告诉我，请更新一下服务

00:09:32.690 --> 00:09:36.710
它进行更新，然后它是

00:09:35.089 --> 00:09:40.310
我的业务需要

00:09:36.710 --> 00:09:42.410
告诉服务二更新

00:09:40.310 --> 00:09:44.920
服务-如果由于某种原因失败

00:09:42.410 --> 00:09:47.750
也许有网络中断

00:09:44.920 --> 00:09:48.800
那不会成功，但是

00:09:47.750 --> 00:09:50.810
你仍然有更新

00:09:48.800 --> 00:09:53.120
发生在服务一，那么你怎么办

00:09:50.810 --> 00:09:57.110
你会回滚吗？ 

00:09:53.120 --> 00:09:58.490
你自己，没有强制执行

00:09:57.110 --> 00:10:00.020
如果您有两个不同，则保持一致

00:09:58.490 --> 00:10:02.540
您没有外键的数据库

00:10:00.020 --> 00:10:04.980
从一个数据库到

00:10:02.540 --> 00:10:08.389
其他它不是那样的

00:10:04.980 --> 00:10:12.209
并发是固有的

00:10:08.389 --> 00:10:14.160
系统，以便在进行操作时

00:10:12.209 --> 00:10:15.899
在这里进行更新，这需要时间

00:10:14.160 --> 00:10:18.449
为了在这里传播和时间

00:10:15.899 --> 00:10:20.639
适当传播它的东西

00:10:18.449 --> 00:10:22.110
我们在哪里进行原子操作

00:10:20.639 --> 00:10:24.660
就像发生了CH手术

00:10:22.110 --> 00:10:27.029
立刻变成了整体，我们现在有了

00:10:24.660 --> 00:10:29.720
需要花费时间进行传播的操作

00:10:27.029 --> 00:10:29.720
通过我们的系统

00:10:30.790 --> 00:10:34.579
所以这可能是什么样子

00:10:33.230 --> 00:10:38.630
可视化它，我们拥有了所有

00:10:34.579 --> 00:10:40.610
服务和操作进入

00:10:38.630 --> 00:10:42.620
由服务a和另一个处理

00:10:40.610 --> 00:10:45.589
操作由它来处理

00:10:42.620 --> 00:10:48.470
服务F和这些触发操作

00:10:45.589 --> 00:10:52.250
以及其他服务B和a的更新

00:10:48.470 --> 00:10:55.069
得到更新，然后我们实际上得到了

00:10:52.250 --> 00:10:57.769
乱序的操作，所以他是他

00:10:55.069 --> 00:11:00.319
由第二个第一次更新

00:10:57.769 --> 00:11:02.149
 B由第一个先更新，然后

00:11:00.319 --> 00:11:05.120
然后他们扭转了，做另一个

00:11:02.149 --> 00:11:08.329
所以现在这些操作如何

00:11:05.120 --> 00:11:11.089
有效，因为国家改变了什么

00:11:08.329 --> 00:11:15.980
如果我们执行此操作和G＆G会发生

00:11:11.089 --> 00:11:17.630
崩溃也许是我无法处理

00:11:15.980 --> 00:11:19.660
操作，因为它是数据库

00:11:17.630 --> 00:11:23.029
出现故障或内存不足

00:11:19.660 --> 00:11:24.259
网络中断意味着什么

00:11:23.029 --> 00:11:25.459
用于更新的操作

00:11:24.259 --> 00:11:28.310
我们已经在所有其他方面做了

00:11:25.459 --> 00:11:30.470
服务，我的意思是应该滚动

00:11:28.310 --> 00:11:32.120
返回我们应该重新输入尝试J 

00:11:30.470 --> 00:11:34.519
责任是确保

00:11:32.120 --> 00:11:36.470
发生这种情况，也许我们说得好

00:11:34.519 --> 00:11:38.180
首先收到了请求，这是它的

00:11:36.470 --> 00:11:41.089
协调一切的责任

00:11:38.180 --> 00:11:43.490
好的，但是感觉失败的东西

00:11:41.089 --> 00:11:45.920
通常不会孤立地发生

00:11:43.490 --> 00:11:47.569
您知道带有机架的数据中心

00:11:45.920 --> 00:11:49.550
服务器，通常像整个机架一样

00:11:47.569 --> 00:11:52.579
由于网络问题而掉线或

00:11:49.550 --> 00:11:54.980
电源问题，如果开机

00:11:52.579 --> 00:11:56.899
相同的机架，所以现在我们的协调员

00:11:54.980 --> 00:11:58.370
剩下的什么了

00:11:56.899 --> 00:12:01.730
服务现在做，他们甚至知道

00:11:58.370 --> 00:12:03.589
出了点问题，当然

00:12:01.730 --> 00:12:05.720
这里的第二项操作已经完成

00:12:03.589 --> 00:12:08.360
更新取决于

00:12:05.720 --> 00:12:10.759
第一个做了什么意思

00:12:08.360 --> 00:12:13.370
对于它的更新，也许他们现在

00:12:10.759 --> 00:12:15.410
无效所以整个的完整性

00:12:13.370 --> 00:12:18.279
整个系统的一致性是

00:12:15.410 --> 00:12:18.279
现在受到质疑

00:12:19.860 --> 00:12:26.340
当我们用我的巨石时，什么起作用了

00:12:23.910 --> 00:12:29.890
将无法在本机云中工作

00:12:26.340 --> 00:12:32.530
微服务好吧，我们不能依靠

00:12:29.890 --> 00:12:36.090
一致性，就像我们和

00:12:32.530 --> 00:12:38.650
我们不能认为一致性是理所当然的

00:12:36.090 --> 00:12:42.480
所以想一些可行的事例

00:12:38.650 --> 00:12:45.700
在整体堆中工作正常，因为

00:12:42.480 --> 00:12:47.770
关键取决于单一或一致

00:12:45.700 --> 00:12:49.600
声明您在这里进行更新

00:12:47.770 --> 00:12:51.430
在那里，他们可以依靠每个

00:12:49.600 --> 00:12:53.860
其他，但因为你有

00:12:51.430 --> 00:12:56.890
数据库分钟管理

00:12:53.860 --> 00:12:58.630
确保一切正常，我们做到了

00:12:56.890 --> 00:13:00.070
通过依赖交易所以

00:12:58.630 --> 00:13:02.050
您可以依靠交易来

00:13:00.070 --> 00:13:04.240
自己清理并制造东西

00:13:02.050 --> 00:13:09.220
一致，但这取决于

00:13:04.240 --> 00:13:13.440
单个数据库，为此，我们可以

00:13:09.220 --> 00:13:17.050
在整体中休息和休息

00:13:13.440 --> 00:13:19.120
因为数据，因为我们有这个

00:13:17.050 --> 00:13:21.250
它可以处理的单个数据库

00:13:19.120 --> 00:13:23.470
像手腕一样的失败根本没有

00:13:21.250 --> 00:13:24.700
专为管理故障而设计，您可以查看

00:13:23.470 --> 00:13:26.500
休息请求失败，没有任何东西

00:13:24.700 --> 00:13:27.790
现在要为您重试

00:13:26.500 --> 00:13:29.230
这将尝试将其回滚

00:13:27.790 --> 00:13:30.880
你，但是当你有一个

00:13:29.230 --> 00:13:33.720
单个数据库，因为该数据库可以

00:13:30.880 --> 00:13:33.720
为你管理

00:13:33.960 --> 00:13:38.530
当我们迁移到云原生微

00:13:36.310 --> 00:13:43.990
服务我们需要不同的方法

00:13:38.530 --> 00:13:46.860
因此，事件就是对此的答案

00:13:43.990 --> 00:13:46.860
问题

00:13:47.820 --> 00:13:55.180
事件可以传达事实，所以如果我愿意

00:13:52.600 --> 00:13:58.600
说这个订单目前

00:13:55.180 --> 00:14:00.310
提交了，这不是事实，还是我

00:13:58.600 --> 00:14:02.890
说此订单已提交

00:14:00.310 --> 00:14:05.980
声明这不是事实，为什么不是

00:14:02.890 --> 00:14:07.720
一个事实是因为虽然我说

00:14:05.980 --> 00:14:09.490
可能有东西来取消了

00:14:07.720 --> 00:14:10.600
它，这可能是错误的，我不知道

00:14:09.490 --> 00:14:12.279
可以肯定的是

00:14:10.600 --> 00:14:13.300
因为这些服务是

00:14:12.279 --> 00:14:16.870
独立

00:14:13.300 --> 00:14:18.940
好吧，所以目前的状态不是事实

00:14:16.870 --> 00:14:21.880
事实是发生在

00:14:18.940 --> 00:14:24.610
过去，例如，用户提交了

00:14:21.880 --> 00:14:26.560
当用户使用时的事实

00:14:24.610 --> 00:14:28.269
提交订单是事实，他们

00:14:26.560 --> 00:14:30.399
做到这一点永远不会失效

00:14:28.269 --> 00:14:31.420
即使他们去取消它

00:14:30.399 --> 00:14:32.110
并没有改变他们

00:14:31.420 --> 00:14:33.670
提交了

00:14:32.110 --> 00:14:35.140
实际上，如果他们

00:14:33.670 --> 00:14:37.839
一开始没有提交

00:14:35.140 --> 00:14:40.990
提交的事实始终保持真实， 

00:14:37.839 --> 00:14:42.670
因此，如果我收到一个活动，我可以保证

00:14:40.990 --> 00:14:45.220
我可以依靠我可以依靠

00:14:42.670 --> 00:14:48.070
的确，我喜欢独角兽

00:14:45.220 --> 00:14:50.380
如果我可以依靠我目前的状态

00:14:48.070 --> 00:14:57.519
收到一个事件我可以依靠

00:14:50.380 --> 00:15:00.640
这个事实是真的，我们也需要，如果我们

00:14:57.519 --> 00:15:02.680
然后拥抱事件，我们需要某种方式

00:15:00.640 --> 00:15:05.260
在我们的系统中获取这些事件，并

00:15:02.680 --> 00:15:07.720
为此，我们至少需要一个

00:15:05.260 --> 00:15:09.760
消息传递，因此我们可以确保何时

00:15:07.720 --> 00:15:12.190
一个事件发生，我们有一个

00:15:09.760 --> 00:15:13.839
确保该事件将

00:15:12.190 --> 00:15:18.130
传播到一切取决于

00:15:13.839 --> 00:15:21.279
它至少一次，那么我们可以确保

00:15:18.130 --> 00:15:24.519
我们的系统最终将收敛于

00:15:21.279 --> 00:15:27.459
目前的状态是

00:15:24.519 --> 00:15:33.220
我们的服务可以同意订单是

00:15:27.459 --> 00:15:35.170
提交或订单被取消等

00:15:33.220 --> 00:15:37.240
将所有这些整合在一起

00:15:35.170 --> 00:15:40.660
要做的是以河流为中心

00:15:37.240 --> 00:15:42.490
不想只是在那时有事件

00:15:40.660 --> 00:15:44.470
它不只是一种

00:15:42.490 --> 00:15:49.269
在我们需要的任何地方神奇地触发事件

00:15:44.470 --> 00:15:52.240
去控制他们，所以我们需要采取

00:15:49.269 --> 00:15:53.890
考虑我们的数据而不是思考

00:15:52.240 --> 00:15:58.030
我们的真理来源我们的数据

00:15:53.890 --> 00:16:00.250
我们的系统状态是什么Ben 

00:15:58.030 --> 00:16:02.800
我们需要考虑的当前状态

00:16:00.250 --> 00:16:04.990
它是我们的数据是事件，所以如果

00:16:02.800 --> 00:16:07.660
你拥有所有的事件，你知道什么

00:16:04.990 --> 00:16:10.660
您最好的数据系统的数据

00:16:07.660 --> 00:16:12.820
那是系统的状态

00:16:10.660 --> 00:16:15.400
这些事件可能处于静止状态

00:16:12.820 --> 00:16:17.080
存储在数据库中，但其中一些

00:16:15.400 --> 00:16:18.790
可能当前正在传播

00:16:17.080 --> 00:16:20.720
通过系统中的一些

00:16:18.790 --> 00:16:24.950
运动

00:16:20.720 --> 00:16:26.390
所以我们没有单一的状态

00:16:24.950 --> 00:16:29.570
没有这个，我们不再需要

00:16:26.390 --> 00:16:31.880
依靠交易，因为我们已经

00:16:29.570 --> 00:16:33.350
我们没有采取单一状态视图

00:16:31.880 --> 00:16:35.210
我们只是在参加一个活动

00:16:33.350 --> 00:16:39.560
查看我们可以依靠的事实

00:16:35.210 --> 00:16:41.750
我们已经收到，因此

00:16:39.560 --> 00:16:46.610
系统的单一状态是

00:16:41.750 --> 00:16:53.210
更处于不断收敛的状态

00:16:46.610 --> 00:16:56.390
而不是这样思考

00:16:53.210 --> 00:16:59.020
我当前的状态是我们的系统是

00:16:56.390 --> 00:17:02.600
正在走向融合

00:16:59.020 --> 00:17:04.040
传播如果我的意思是如果你

00:17:02.600 --> 00:17:05.630
断开所有输入与

00:17:04.040 --> 00:17:07.640
系统，如果每个人都停止使用

00:17:05.630 --> 00:17:09.350
系统，然后确保它将收敛， 

00:17:07.640 --> 00:17:11.480
所有的服务都会就什么达成共识

00:17:09.350 --> 00:17:12.980
他们目前的状态是

00:17:11.480 --> 00:17:15.650
有人在用它

00:17:12.980 --> 00:17:17.540
输入新事件

00:17:15.650 --> 00:17:19.490
事件正在传播中

00:17:17.540 --> 00:17:21.020
系统将处于这种状态

00:17:19.490 --> 00:17:22.699
不断收敛从未完全

00:17:21.020 --> 00:17:27.230
到达那里，但总是在路上

00:17:22.699 --> 00:17:28.880
在那里，要做到这一点，我们需要控制

00:17:27.230 --> 00:17:31.520
它，我们通过使用流来做到这一点

00:17:28.880 --> 00:17:34.520
在我们事件的下游

00:17:31.520 --> 00:17:37.730
流让我们传播这些

00:17:34.520 --> 00:17:40.790
整个系统中的数据，因此我们可以

00:17:37.730 --> 00:17:42.650
想象一下，我们有服务a和B 

00:17:40.790 --> 00:17:45.620
我们在他们之间放了一条小溪

00:17:42.650 --> 00:17:49.280
流是一个管道，现在服务一个

00:17:45.620 --> 00:17:51.830
东西，它发出一个事件，它

00:17:49.280 --> 00:17:53.990
将其放入管道中

00:17:51.830 --> 00:17:55.580
它在此事件中还有其他作用

00:17:53.990 --> 00:17:58.100
并将其放入流中，这些

00:17:55.580 --> 00:18:00.710
事件正在向

00:17:58.100 --> 00:18:02.510
服务B和其他可能的服务

00:18:00.710 --> 00:18:05.570
它可以扇出多个

00:18:02.510 --> 00:18:08.870
取决于这些事件的服务，但

00:18:05.570 --> 00:18:11.210
如果当时服务B会发生什么

00:18:08.870 --> 00:18:14.570
发出这些事件的服务有

00:18:11.210 --> 00:18:16.730
崩溃了，因为我们正在使用这些废物

00:18:14.570 --> 00:18:20.060
至少一次获得机制

00:18:16.730 --> 00:18:22.550
他们从服务到服务B服务a 

00:18:20.060 --> 00:18:24.830
发射后无需担心

00:18:22.550 --> 00:18:26.330
如果它不在画面中

00:18:24.830 --> 00:18:28.400
不需要重试，不需要

00:18:26.330 --> 00:18:30.260
写回滚，它知道这是

00:18:28.400 --> 00:18:31.550
发出发送事件发送此事实

00:18:30.260 --> 00:18:33.650
这是事实

00:18:31.550 --> 00:18:35.320
它可以完全脱离

00:18:33.650 --> 00:18:37.610
图片

00:18:35.320 --> 00:18:39.800
 servus洗澡可以吗？ 

00:18:37.610 --> 00:18:41.600
修复后重新在线等

00:18:39.800 --> 00:18:43.910
一点，一旦完成就可以了

00:18:41.600 --> 00:18:47.170
可以开始重新处理这些事件并

00:18:43.910 --> 00:18:47.170
进行转化

00:18:48.560 --> 00:18:53.460
所以这是最重要的

00:18:51.180 --> 00:18:56.190
我希望人们从中得到好处

00:18:53.460 --> 00:19:00.930
系统建模的演示

00:18:56.190 --> 00:19:03.180
使用流我们拥抱事件我们没有

00:19:00.930 --> 00:19:05.420
不再需要一个我们不需要的状态

00:19:03.180 --> 00:19:08.490
交易我们不需要这个

00:19:05.420 --> 00:19:10.440
当前的世界观等等

00:19:08.490 --> 00:19:14.100
我们可以采取最终的一致性

00:19:10.440 --> 00:19:16.350
当我们脱离巨石时，这是理所当然的

00:19:14.100 --> 00:19:18.450
微服务，我们失去了

00:19:16.350 --> 00:19:21.000
认为一致性是理所当然的，但是

00:19:18.450 --> 00:19:23.610
溪流给了我们，使我们回到了我们

00:19:21.000 --> 00:19:26.250
让我们再次采取

00:19:23.610 --> 00:19:28.440
理所当然的一致性以及那

00:19:26.250 --> 00:19:30.440
在实践中意味着您没有

00:19:28.440 --> 00:19:32.970
时间更长，您无需担心

00:19:30.440 --> 00:19:34.470
失败，您无需担心

00:19:32.970 --> 00:19:37.470
处理失败，您无需担心

00:19:34.470 --> 00:19:39.210
关于处理您只需要的一致性

00:19:37.470 --> 00:19:40.920
担心您的业务问题

00:19:39.210 --> 00:19:43.740
这就是你要担心的

00:19:40.920 --> 00:19:45.590
作为开发者和

00:19:43.740 --> 00:19:53.520
您采用的架构方法

00:19:45.590 --> 00:19:55.530
我们会担心您的一致性，所以

00:19:53.520 --> 00:19:57.590
这和雅加达有什么关系

00:19:55.530 --> 00:20:01.380
 AAA级

00:19:57.590 --> 00:20:07.380
目前，JMS和MD B是最好的

00:20:01.380 --> 00:20:09.810
雅加达AE必须提供，而所有

00:20:07.380 --> 00:20:14.000
这些事情可以通过使用它们来实现

00:20:09.810 --> 00:20:16.620
他们是很重的毫克蜜蜂

00:20:14.000 --> 00:20:20.760
需要很多种代码

00:20:16.620 --> 00:20:22.920
他们他们设计了一段时间

00:20:20.760 --> 00:20:25.080
你有多个标记，所以你有一个

00:20:22.920 --> 00:20:26.850
这里的巨石和那里的巨石

00:20:25.080 --> 00:20:29.280
你体重很重所以这个

00:20:26.850 --> 00:20:31.020
可能由业务部门维护

00:20:29.280 --> 00:20:33.390
一个非常大的业务部门

00:20:31.020 --> 00:20:35.310
一个又一个非常大的业务部门

00:20:33.390 --> 00:20:38.160
从概念上讲， 

00:20:35.310 --> 00:20:39.810
现在这个过程的重量转移是

00:20:38.160 --> 00:20:46.010
将由该系统处理

00:20:39.810 --> 00:20:50.310
在这里这样做而当您移至

00:20:46.010 --> 00:20:54.030
您知道的具有微服务的流

00:20:50.310 --> 00:20:58.470
一个操作将包括

00:20:54.030 --> 00:21:01.470
许多事件可能数万

00:20:58.470 --> 00:21:03.060
一切都在进行

00:21:01.470 --> 00:21:04.350
通过许多不同的服务等等

00:21:03.060 --> 00:21:07.740
您需要的东西要轻得多

00:21:04.350 --> 00:21:10.350
重量比以前提供的要重

00:21:07.740 --> 00:21:13.380
微观方面有新的努力

00:21:10.350 --> 00:21:15.270
改变这一点，所以第一件事

00:21:13.380 --> 00:21:19.910
我们已经完成了，我们已经创建了一种方法

00:21:15.270 --> 00:21:23.130
指导的反应性文件

00:21:19.910 --> 00:21:27.090
采用反应性功能，所以当我

00:21:23.130 --> 00:21:28.440
谈论流媒体和维护

00:21:27.090 --> 00:21:32.790
我在说的一致性

00:21:28.440 --> 00:21:35.250
反应性原则，使您能够

00:21:32.790 --> 00:21:37.890
建立高度解耦的系统

00:21:35.250 --> 00:21:40.740
这个反应性文件将

00:21:37.890 --> 00:21:44.790
帮助指导将来规格的创建

00:21:40.740 --> 00:21:46.590
并更新此现有规格

00:21:44.790 --> 00:21:48.360
微型配置文件反应项目已经

00:21:46.590 --> 00:21:50.850
开始，这有两个子

00:21:48.360 --> 00:21:54.330
规格第一是实力

00:21:50.850 --> 00:21:56.130
用于操纵流的项目，因此何时

00:21:54.330 --> 00:21:58.800
我想拥有一个数据流，我

00:21:56.130 --> 00:22:01.470
想要在地图上进行操作或

00:21:58.800 --> 00:22:05.700
将内容存储到数据库或过滤器

00:22:01.470 --> 00:22:07.410
这个库装订线会这样做，然后

00:22:05.700 --> 00:22:08.670
那么另一个子项目是

00:22:07.410 --> 00:22:11.130
异步规范

00:22:08.670 --> 00:22:13.260
通信称为反应式消息传递

00:22:11.130 --> 00:22:15.300
所以这是关于交流

00:22:13.260 --> 00:22:20.220
在服务和获取事件之间

00:22:15.300 --> 00:22:21.540
一种服务到另一种，还有一些

00:22:20.220 --> 00:22:23.790
未来的可能性，并且有一个

00:22:21.540 --> 00:22:25.260
关于微观概况的大量讨论

00:22:23.790 --> 00:22:28.470
过去几周的邮件列表

00:22:25.260 --> 00:22:31.740
关于此事件来源实体的支持

00:22:28.470 --> 00:22:36.030
所以实际上而不是存储您的

00:22:31.740 --> 00:22:38.160
您的数据存储在存储事件的表中

00:22:36.030 --> 00:22:41.790
然后从

00:22:38.160 --> 00:22:48.360
事件和发布实体流如此

00:22:41.790 --> 00:22:50.520
 CQRS，您在其中分开

00:22:48.360 --> 00:22:52.680
您的阅读侧模型

00:22:50.520 --> 00:22:54.900
实体能够做的事情

00:22:52.680 --> 00:22:56.370
验证并产生新事件

00:22:54.900 --> 00:22:59.960
然后去查询的东西

00:22:56.370 --> 00:22:59.960
并告知当前状态

00:23:00.460 --> 00:23:07.210
所以现在我们将继续

00:23:02.379 --> 00:23:09.070
演示现在，演示是我要展示的

00:23:07.210 --> 00:23:10.960
示例应用程序称为在线拍卖

00:23:09.070 --> 00:23:12.669
这是eBay的克隆，还不够

00:23:10.960 --> 00:23:15.059
与eBay竞争，但它将获得

00:23:12.669 --> 00:23:15.059
有一天

00:23:16.730 --> 00:23:20.539
这些规范我都没有

00:23:18.379 --> 00:23:26.179
谈到实际上存在但还可以

00:23:20.539 --> 00:23:27.649
我无法运行Java AE服务器，并且

00:23:26.179 --> 00:23:33.350
向您展示，因为

00:23:27.649 --> 00:23:36.350
规格不存在，但正如我在

00:23:33.350 --> 00:23:39.919
登录和登录工具的共同创建者

00:23:36.350 --> 00:23:41.960
这些这些原则，所以我走了

00:23:39.919 --> 00:23:43.999
并在当前实施了规范

00:23:41.960 --> 00:23:45.409
形成很早，一切都会改变

00:23:43.999 --> 00:23:49.629
但以目前的形式

00:23:45.409 --> 00:23:52.669
在登录之上实施它们，并

00:23:49.629 --> 00:23:55.009
那么我已经移植了这个在线拍卖

00:23:52.669 --> 00:23:57.350
实际作为演示存在的演示应用

00:23:55.009 --> 00:24:09.350
该应用程序还有很多其他用途

00:23:57.350 --> 00:24:12.169
这些新规格，所以这是我们的在线

00:24:09.350 --> 00:24:16.820
拍卖应用程序，它非常漂亮

00:24:12.169 --> 00:24:18.889
我可以创建一个我登录时使用的项目

00:24:16.820 --> 00:24:22.549
此刻的玛丽，所以玛丽要

00:24:18.889 --> 00:24:30.259
卖她的自行车，这是一辆红色的自行车

00:24:22.549 --> 00:24:31.879
在欧洲，所以我们用欧元和十

00:24:30.259 --> 00:24:35.960
秒可能太短了

00:24:31.879 --> 00:24:38.419
拍卖并花10个小时创建它

00:24:35.960 --> 00:24:41.379
而一旦我对此感到满意

00:24:38.419 --> 00:24:41.379
我开始拍卖

00:24:41.539 --> 00:24:46.220
现在记录是别人非常安全的

00:24:44.539 --> 00:24:49.009
您只需从

00:24:46.220 --> 00:24:52.999
下拉菜单，我将要搜索

00:24:49.009 --> 00:24:58.399
该项目，所以我现在以John身份登录

00:24:52.999 --> 00:25:01.070
我会搜索，然后在那里看到

00:24:58.399 --> 00:25:04.070
是我的自行车不能提出建议

00:25:01.070 --> 00:25:07.730
价格，所以我可以点击它，我可以

00:25:04.070 --> 00:25:12.590
出价我将是10欧元

00:25:07.730 --> 00:25:16.190
像eBay一样，最低价格是50 

00:25:12.590 --> 00:25:18.139
说你实际上没有出价的50美分

00:25:16.190 --> 00:25:19.909
当前价格自动

00:25:18.139 --> 00:25:23.000
随着其他人竞价，您的收入会增加

00:25:19.909 --> 00:25:28.190
反对你，所以如果我以我自己的身份登录

00:25:23.000 --> 00:25:30.470
我出价5个英雄

00:25:28.190 --> 00:25:32.360
被接受，除了

00:25:30.470 --> 00:25:35.809
约翰自动出价高于

00:25:32.360 --> 00:25:38.539
最高出价是10欧元，所以我将

00:25:35.809 --> 00:25:41.750
 20欧元的一点，这已经被接受

00:25:38.539 --> 00:25:45.529
比约翰的高速多了50美分

00:25:41.750 --> 00:25:50.450
当前的价格是10欧元50所以如果

00:25:45.529 --> 00:25:53.059
我们去寻找黑色再次

00:25:50.450 --> 00:25:54.559
可以看到这里有黑色，我们

00:25:53.059 --> 00:25:56.120
之前看到的当前价格是10 

00:25:54.559 --> 00:25:58.039
 50欧元，但未显示任何

00:25:56.120 --> 00:25:59.960
当前价格这里一定有一个

00:25:58.039 --> 00:26:02.010
问题，让我们去看看

00:25:59.960 --> 00:26:04.890
编码

00:26:02.010 --> 00:26:07.110
所以这是你知道我们有一个号码

00:26:04.890 --> 00:26:08.490
服务一项是一项

00:26:07.110 --> 00:26:10.169
服务就是那个地方

00:26:08.490 --> 00:26:12.059
这就是创建项目的处理方式

00:26:10.169 --> 00:26:12.990
并描述该项目现在服务

00:26:12.059 --> 00:26:15.000
是出价服务

00:26:12.990 --> 00:26:16.919
它负责接受投标和管理

00:26:15.000 --> 00:26:18.770
拍卖和另一项服务是

00:26:16.919 --> 00:26:22.169
搜索服务及其处理

00:26:18.770 --> 00:26:24.330
维护所有事件的搜索索引

00:26:22.169 --> 00:26:28.620
搜索服务通过

00:26:24.330 --> 00:26:30.390
通过订阅订阅主题

00:26:28.620 --> 00:26:34.530
来自该项目的事件和

00:26:30.390 --> 00:26:37.169
出价服务，因为价格不是

00:26:34.530 --> 00:26:39.030
在那里的搜索服务中已更新

00:26:37.169 --> 00:26:40.230
一定是出价事件的问题

00:26:39.030 --> 00:26:42.990
关于那应该是

00:26:40.230 --> 00:26:45.360
从此处的出价服务到达那里

00:26:42.990 --> 00:26:48.630
这些服务可以订阅的地方

00:26:45.360 --> 00:26:50.549
他们的竞标活动，所以我们可以在这里看到

00:26:48.630 --> 00:26:54.690
是应用范围的梁和CDI 

00:26:50.549 --> 00:26:56.460
我们可以看到这个传入的注释

00:26:54.690 --> 00:26:58.860
所以这是消息传递规范的一部分

00:26:56.460 --> 00:27:02.490
就是说主题是BD 

00:26:58.860 --> 00:27:05.640
事件，它得到位事件，它

00:27:02.490 --> 00:27:08.250
确实将其转换为文档

00:27:05.640 --> 00:27:10.260
帮助它是异步的，所以它是

00:27:08.250 --> 00:27:13.490
使用完成阶段来表示

00:27:10.260 --> 00:27:19.320
结果和他们的回报

00:27:13.490 --> 00:27:24.750
现在结果在这里，因为完成

00:27:19.320 --> 00:27:27.240
阶段，因为这段代码看起来几乎

00:27:24.750 --> 00:27:28.919
与代码处理项目相同

00:27:27.240 --> 00:27:30.870
事件，我们知道项目事件

00:27:28.919 --> 00:27:32.910
再次在那里，因为自行车确实来了

00:27:30.870 --> 00:27:34.770
在搜索索引中-在第一个中

00:27:32.910 --> 00:27:37.020
只是价格不是

00:27:34.770 --> 00:27:39.630
已更新，可能不在

00:27:37.020 --> 00:27:41.070
搜索服务，问题是如此

00:27:39.630 --> 00:27:42.570
我们去看看我们的出价

00:27:41.070 --> 00:27:45.330
事件发生的服务

00:27:42.570 --> 00:27:47.490
发表，所以你可以看到我有这个

00:27:45.330 --> 00:27:50.429
这里的方法称为发布事件日志， 

00:27:47.490 --> 00:27:53.970
在这种情况下，它没有参数

00:27:50.429 --> 00:27:57.179
而是要返回一个处理器

00:27:53.970 --> 00:28:00.120
是反应性流事物是活跃的

00:27:57.179 --> 00:28:04.740
它有一个输入和一个流

00:28:00.120 --> 00:28:08.790
输出，输入是动作事件

00:28:04.740 --> 00:28:10.919
现在输出的是位事件

00:28:08.790 --> 00:28:13.470
此处的出价服务正在使用的事件

00:28:10.919 --> 00:28:15.810
事件源，这样事件源

00:28:13.470 --> 00:28:18.870
而不是那么持久

00:28:15.810 --> 00:28:22.470
当前做什么？ 

00:28:18.870 --> 00:28:24.720
获胜是什么，他们的出价是什么

00:28:22.470 --> 00:28:26.430
你只是坚持所有的事情，所以

00:28:24.720 --> 00:28:28.380
这个人把这个人出价

00:28:26.430 --> 00:28:30.570
此人出价的地方

00:28:28.380 --> 00:28:32.520
其他出价，然后在需要时

00:28:30.570 --> 00:28:35.370
看看你现在的价格是多少

00:28:32.520 --> 00:28:39.780
只需加载所有这些事件即可重播它们

00:28:35.370 --> 00:28:42.120
得到你的当前状态，所以因为

00:28:39.780 --> 00:28:44.970
我们将这些存储在事件日志中

00:28:42.120 --> 00:28:49.110
可以将它们作为拍卖流消费

00:28:44.970 --> 00:28:51.960
事件，所以这是我们然后使用此

00:28:49.110 --> 00:28:53.430
是无功强度微

00:28:51.960 --> 00:28:57.180
的配置式反应流规范

00:28:53.430 --> 00:28:59.760
处理这些事件，我们创建了一个

00:28:57.180 --> 00:29:02.550
将要拍卖的建筑商

00:28:59.760 --> 00:29:03.930
事件作为输入，我们对其进行过滤

00:29:02.550 --> 00:29:06.480
因为不是我们所有的事件

00:29:03.930 --> 00:29:09.510
坚持在我们自己的数据库中

00:29:06.480 --> 00:29:11.310
一定要发布到

00:29:09.510 --> 00:29:13.200
在这种情况下，我们的意思是

00:29:11.310 --> 00:29:16.140
发布位偏见并完成

00:29:13.200 --> 00:29:18.650
事件，然后将它们转换为

00:29:16.140 --> 00:29:21.630
事件的外部表示

00:29:18.650 --> 00:29:23.640
就像您不会退还您的JPA 

00:29:21.630 --> 00:29:25.980
直接来自休息服务的实体

00:29:23.640 --> 00:29:28.830
您已经转换为其他对象

00:29:25.980 --> 00:29:30.480
代表您的外部API 

00:29:28.830 --> 00:29:32.070
我们在这里做同样的事情

00:29:30.480 --> 00:29:35.460
转换我们内部持久的

00:29:32.070 --> 00:29:37.440
事件发生在语义上

00:29:35.460 --> 00:29:40.380
代表同一件事，但看起来

00:29:37.440 --> 00:29:43.560
那更适合公众

00:29:40.380 --> 00:29:46.590
 API，现在您可能已经注意到没有

00:29:43.560 --> 00:29:51.290
对此的注释实际上

00:29:46.590 --> 00:29:56.370
这里的问题，所以让我们添加他们

00:29:51.290 --> 00:29:59.610
这个发布者将以

00:29:56.370 --> 00:30:03.180
输入事件作为其传入流

00:29:59.610 --> 00:30:04.710
记录这些氧气事件

00:30:03.180 --> 00:30:09.240
要从事件日志中读取它们

00:30:04.710 --> 00:30:11.100
然后它会上升，所以

00:30:09.240 --> 00:30:12.660
处理器转换的东西

00:30:11.100 --> 00:30:17.730
他们将被发布到

00:30:12.660 --> 00:30:22.139
卡夫卡等竞标活动主题

00:30:17.730 --> 00:30:23.760
所以现在一旦保存的登录支持

00:30:22.139 --> 00:30:25.799
热装，所以我不需要做

00:30:23.760 --> 00:30:30.330
我需要保存的所有内容

00:30:25.799 --> 00:30:31.559
搜索时应该立即重新加载

00:30:30.330 --> 00:30:33.539
这是我可能要做的第一件事

00:30:31.559 --> 00:30:35.940
要做的是基于数据库

00:30:33.539 --> 00:30:38.039
迁移是因为我忘了拥有那些

00:30:35.940 --> 00:30:40.919
之前的注释等等

00:30:38.039 --> 00:30:42.570
当然我的搜索服务有误

00:30:40.919 --> 00:30:44.039
陈述所有未来的事情

00:30:42.570 --> 00:30:45.600
那将起作用，但随后的东西

00:30:44.039 --> 00:30:47.639
过去是因为我有这个

00:30:45.600 --> 00:30:49.769
我必须修复之前的错误

00:30:47.639 --> 00:30:52.049
那个就没有办法

00:30:49.769 --> 00:30:54.029
当前价格可以在此处显示

00:30:52.049 --> 00:30:56.179
我击中搜索，那不是

00:30:54.029 --> 00:30:56.179
可能

00:30:56.299 --> 00:31:04.219
好吧，是的，你看到发生了什么事

00:31:01.429 --> 00:31:05.929
这是因为我的流媒体

00:31:04.219 --> 00:31:07.009
现在在我的系统中获得了该属性

00:31:05.929 --> 00:31:09.979
它可以自我修复

00:31:07.009 --> 00:31:11.869
当然实际沼泽在哪里

00:31:09.979 --> 00:31:14.509
注释是亲自面对的

00:31:11.869 --> 00:31:16.609
系统无法自行修复，但

00:31:14.509 --> 00:31:18.169
一旦我修复了该错误的实际数据

00:31:16.609 --> 00:31:20.629
那是的东西

00:31:18.169 --> 00:31:22.369
由于我的错误导致不一致

00:31:20.629 --> 00:31:24.409
修好自己，我不必走了， 

00:31:22.369 --> 00:31:26.869
写一个数据库迁移工作好了

00:31:24.409 --> 00:31:28.159
哪些事件并没有导致

00:31:26.869 --> 00:31:29.869
搜索服务

00:31:28.159 --> 00:31:31.820
我需要重新发布它们吗

00:31:29.869 --> 00:31:33.499
由于

00:31:31.820 --> 00:31:35.959
我已经采用的这种架构方法

00:31:33.499 --> 00:31:41.119
我能够接受

00:31:35.959 --> 00:31:43.849
一致性是理所当然的，因此使用

00:31:41.119 --> 00:31:46.700
流媒体，您不再需要担心

00:31:43.849 --> 00:31:51.219
关于处理故障不再需要

00:31:46.700 --> 00:31:51.219
担心处理一致性

00:31:54.490 --> 00:31:56.550
您

00:32:03.039 --> 00:32:09.830
所以总的来说，巨石让我们

00:32:07.159 --> 00:32:11.629
采取一致性只是品牌

00:32:09.830 --> 00:32:14.330
我们认为氧气是理所当然的

00:32:11.629 --> 00:32:16.669
我们需要一致性，他们已经做到了

00:32:14.330 --> 00:32:19.009
让我们不用担心，但是当我们

00:32:16.669 --> 00:32:20.570
迁移到云原生微服务

00:32:19.009 --> 00:32:22.999
一致的世界观

00:32:20.570 --> 00:32:25.610
崩溃了，什么对我们有用

00:32:22.999 --> 00:32:29.539
独石将无法在云原生环境中工作

00:32:25.610 --> 00:32:35.389
 mario服务（如果我们为系统建模） 

00:32:29.539 --> 00:32:37.730
使用流，我们接受事件

00:32:35.389 --> 00:32:39.320
数据成为事件不是不是什么

00:32:37.730 --> 00:32:41.059
当前存储在数据库中

00:32:39.320 --> 00:32:42.889
表中的状态，但事件

00:32:41.059 --> 00:32:44.119
自己，他们是我们的数据，是我们的

00:32:42.889 --> 00:32:46.000
真理之源就是我们所能

00:32:44.119 --> 00:32:48.010
信任

00:32:46.000 --> 00:32:50.500
我们不再需要单一状态

00:32:48.010 --> 00:32:51.940
不需要也将交易添加到

00:32:50.500 --> 00:32:53.560
给我们这种错觉， 

00:32:51.940 --> 00:32:57.190
有一个当前状态，我们可以

00:32:53.560 --> 00:32:59.800
依靠并做到这一点，我们可以采取

00:32:57.190 --> 00:33:02.650
最终的一致性理所当然

00:32:59.800 --> 00:33:05.740
一个自我修复的系统，我们不需要

00:33:02.650 --> 00:33:08.640
进行体外逻辑回滚编码

00:33:05.740 --> 00:33:11.920
逻辑就是为我们完成了

00:33:08.640 --> 00:33:13.660
凭借

00:33:11.920 --> 00:33:16.930
使用此流的体系结构

00:33:13.660 --> 00:33:21.760
不断汇聚移动数据

00:33:16.930 --> 00:33:23.560
我希望看到世界的运动

00:33:21.760 --> 00:33:25.960
你已经看到杰克·雅加达

00:33:23.560 --> 00:33:28.620
跟踪帮助营养物质过渡到

00:33:25.960 --> 00:33:28.620
这个新世界

00:33:29.659 --> 00:33:37.230
所以谢谢你的倾听

00:33:32.029 --> 00:33:41.070
规格本身可用

00:33:37.230 --> 00:33:44.879
在github上，所以github冷静地装备了微

00:33:41.070 --> 00:33:46.499
个人资料反应性，请参与

00:33:44.879 --> 00:33:49.169
如果您对此完全感兴趣

00:33:46.499 --> 00:33:51.450
即使您从未做过任何事情

00:33:49.169 --> 00:33:54.179
处理反应性或消息传递或事件

00:33:51.450 --> 00:33:57.029
在我们真正需要的是人们之前

00:33:54.179 --> 00:33:58.889
去问问题是什么

00:33:57.029 --> 00:34:01.529
那意味着它实际上是如何工作的

00:33:58.889 --> 00:34:04.200
因为这对我们很重要

00:34:01.529 --> 00:34:05.730
得到人们的认可

00:34:04.200 --> 00:34:13.399
当它实际是否有效

00:34:05.730 --> 00:34:16.559
进入现实世界，我们有一个

00:34:13.399 --> 00:34:19.109
每周的视讯聚会时间

00:34:16.559 --> 00:34:21.210
即将改变，但如果您订阅

00:34:19.109 --> 00:34:25.679
微型个人资料列表，您会发现什么

00:34:21.210 --> 00:34:27.809
那是实际时间

00:34:25.679 --> 00:34:30.960
我已经做过的示范可以

00:34:27.809 --> 00:34:33.510
在github comm上找到它/ 0 / /流式

00:34:30.960 --> 00:34:38.490
 -新-如果我们只想雅加达AE 

00:34:33.510 --> 00:34:40.409
玩这个演示应用程序，如果

00:34:38.490 --> 00:34:42.809
您对更多内容感兴趣

00:34:40.409 --> 00:34:44.639
反应流可用于雅加达AAA 

00:34:42.809 --> 00:34:49.020
我发表了一篇博客文章

00:34:44.639 --> 00:34:51.750
大约四四个月前-可能

00:34:49.020 --> 00:34:53.909
最好的搜索是James 

00:34:51.750 --> 00:34:55.559
然后把光写到极端

00:34:53.909 --> 00:34:57.900
卡塔尔AAA，除非您可以记住

00:34:55.559 --> 00:35:00.210
地址，但它贯穿整个

00:34:57.900 --> 00:35:02.549
广泛的规格和可能性

00:35:00.210 --> 00:35:05.940
对于如何可以包含流

00:35:02.549 --> 00:35:09.290
雅加达AAA，谢谢您的收听

00:35:05.940 --> 00:35:09.290
任何问题

00:35:12.690 --> 00:35:14.750
您

00:35:17.260 --> 00:35:19.920
是的

00:35:25.990 --> 00:35:30.500
反应应变本身就是一个

00:35:28.400 --> 00:35:31.700
不同流的规范

00:35:30.500 --> 00:35:32.870
与每种技术集成的技术

00:35:31.700 --> 00:35:36.980
其他，那肯定已经

00:35:32.870 --> 00:35:42.020
在这些汞合金中工作的注释

00:35:36.980 --> 00:35:43.700
邮件规范，我的意思是代码

00:35:42.020 --> 00:35:46.310
他们在github上，但不是

00:35:43.700 --> 00:35:48.980
正式发布了

00:35:46.310 --> 00:35:52.340
这些规格会发生变化

00:35:48.980 --> 00:35:53.860
规范正在进行中，并且

00:35:52.340 --> 00:35:57.400
他们的事情将会改变

00:35:53.860 --> 00:36:00.680
甚至还没有真正的方法

00:35:57.400 --> 00:36:05.330
倾诉配置您的消息的位置

00:36:00.680 --> 00:36:08.090
经纪人之类的东西，所以它是嗯

00:36:05.330 --> 00:36:09.950
我希望会有所作为

00:36:08.090 --> 00:36:12.800
到11月能发行100张

00:36:09.950 --> 00:36:14.000
今年的规格和那里

00:36:12.800 --> 00:36:17.290
应该是对应的东西

00:36:14.000 --> 00:36:17.290
然后滞后

00:36:17.620 --> 00:36:20.310
是的

00:36:24.780 --> 00:36:26.840
您

00:36:27.000 --> 00:36:32.280
是的，问题是事件如何

00:36:29.880 --> 00:36:35.610
存储在招标服务中

00:36:32.280 --> 00:36:36.810
与一个，所以他们被存储使用

00:36:35.610 --> 00:36:39.360
被称为

00:36:36.810 --> 00:36:40.590
 ARCA持久性，它支持多个

00:36:39.360 --> 00:36:44.190
在这种情况下，我正在使用后端

00:36:40.590 --> 00:36:48.320
卡桑德拉，基本上是一张桌子

00:36:44.190 --> 00:36:52.350
 Cassandra和所有事件均已存储

00:36:48.320 --> 00:36:54.210
两者均由实体ID编制索引，因此

00:36:52.350 --> 00:36:55.890
拍卖ID，以便您可以重播

00:36:54.210 --> 00:36:57.240
单个氧气获取的事件

00:36:55.890 --> 00:37:01.350
该选项的状态以及

00:36:57.240 --> 00:37:03.780
由的偏移量索引

00:37:01.350 --> 00:37:07.220
活动，然后可以将其发布到

00:37:03.780 --> 00:37:07.220
消息代理

