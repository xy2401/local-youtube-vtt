WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.260 --> 00:00:09.090
好的，你好，脊椎动物，大家好

00:00:07.230 --> 00:00:13.320
欢迎参加会议Java代码

00:00:09.090 --> 00:00:16.320
我是Evgeniy 

00:00:13.320 --> 00:00:19.590
曼·拉科夫（Man Rakov）和马克·霍夫曼（Mark Hofman） 

00:00:16.320 --> 00:00:20.130
我是jacoco的项目负责人之一

00:00:19.590 --> 00:00:22.470
和

00:00:20.130 --> 00:00:26.789
 Eclipse echo我是你的一个项目

00:00:22.470 --> 00:00:28.980
在我们开始之前可能已经知道

00:00:26.789 --> 00:00:32.219
通常的免责声明，无论我打算做什么

00:00:28.980 --> 00:00:34.469
说与公司无关

00:00:32.219 --> 00:00:37.829
我在我们的资料来源上工作的地方

00:00:34.469 --> 00:00:39.960
知道这一点，以及做到这一点

00:00:37.829 --> 00:00:42.180
产品作为声纳静态源代码

00:00:39.960 --> 00:00:43.829
分析器，如果你想聊天

00:00:42.180 --> 00:00:45.450
你以后可以抓到我

00:00:43.829 --> 00:00:52.260
演讲将不会

00:00:45.450 --> 00:00:54.690
也是在一次开始之前

00:00:52.260 --> 00:00:57.750
让我们尝试避免陈词滥调，让我们开始

00:00:54.690 --> 00:01:01.109
从更精确的问题

00:00:57.750 --> 00:01:04.739
来自我的问题我想知道谁

00:01:01.109 --> 00:01:06.780
到那里来了解代码覆盖率

00:01:04.739 --> 00:01:13.290
一般如何使用

00:01:06.780 --> 00:01:15.330
等等等等，好吧，但是有些遗憾

00:01:13.290 --> 00:01:17.159
因为你仍然有机会离开

00:01:15.330 --> 00:01:21.780
这个房间不会是关于

00:01:17.159 --> 00:01:24.780
代码覆盖范围一般谁在那里

00:01:21.780 --> 00:01:26.759
谁已经知道如何使用代码

00:01:24.780 --> 00:01:30.119
覆盖范围并实际使用jacoco 

00:01:26.759 --> 00:01:32.189
图书馆好了谢谢

00:01:30.119 --> 00:01:36.659
谁在那里学习有关

00:01:32.189 --> 00:01:40.200
关于Java的一些新知识可以帮助

00:01:36.659 --> 00:01:43.229
你也说我们要谈

00:01:40.200 --> 00:01:46.770
关于Java的内部机制和

00:01:43.229 --> 00:01:49.829
代码覆盖范围的内部机制不是

00:01:46.770 --> 00:01:53.549
关于实际结果，但关于如何

00:01:49.829 --> 00:01:58.920
我们确实获得了这个结果，在这里对不起

00:01:53.549 --> 00:02:01.979
是另一个免责声明，我们是真正的免责声明

00:01:58.920 --> 00:02:05.909
将研究一些内部

00:02:01.979 --> 00:02:08.489
 GI很抱歉，我们要谈谈

00:02:05.909 --> 00:02:11.930
强大的语言字节码再次对不起

00:02:08.489 --> 00:02:14.060
为此，我将在半小时内尝试

00:02:11.930 --> 00:02:15.829
您的大脑遭受强烈的暴力侵害

00:02:14.060 --> 00:02:20.180
曾经有机会去的表面

00:02:15.829 --> 00:02:22.310
住房间，在那里穿会

00:02:20.180 --> 00:02:28.239
请提供一些实施细节

00:02:22.310 --> 00:02:28.239
不依靠这条龙扎希尔等等等

00:02:28.510 --> 00:02:39.019
让我们开始一些Java的历史

00:02:35.689 --> 00:02:43.060
代码覆盖率以及jacoco和经济

00:02:39.019 --> 00:02:47.480
项目特别是所有开始的项目

00:02:43.060 --> 00:02:50.419
十多年前

00:02:47.480 --> 00:02:54.799
艾玛图书馆如果没有的话

00:02:50.419 --> 00:02:57.439
误解了一个，只有一个发布了

00:02:54.799 --> 00:02:58.280
是一个收集代码覆盖率的图书馆

00:02:57.439 --> 00:03:03.260
对于Java 

00:02:58.280 --> 00:03:05.750
它是在Java 5时代开发的

00:03:03.260 --> 00:03:08.620
是的

00:03:05.750 --> 00:03:11.569
稍后再基于此插件

00:03:08.620 --> 00:03:14.959
马克·奥斯曼（Mark Othman）启动了该项目

00:03:11.569 --> 00:03:19.909
 Emma将代码覆盖率引入Eclipse 

00:03:14.959 --> 00:03:23.299
 ID一些房子甚至很受欢迎

00:03:19.909 --> 00:03:26.150
得到了一些Eclipse社区警报，但是

00:03:23.299 --> 00:03:29.030
时间流逝，很明显， 

00:03:26.150 --> 00:03:33.139
艾玛（Emma）不会进化，而有一个

00:03:29.030 --> 00:03:37.180
需要支持新的Java版本

00:03:33.139 --> 00:03:40.340
 GT案新陪审团等

00:03:37.180 --> 00:03:44.479
马克还开始了另一个新项目

00:03:40.340 --> 00:03:47.620
 Java代码覆盖库

00:03:44.479 --> 00:03:52.099
后来我加入了他的努力

00:03:47.620 --> 00:03:58.280
呼应艾玛的第二版

00:03:52.099 --> 00:04:01.759
基于一个新的图书馆，我们说

00:03:58.280 --> 00:04:04.280
一年前，我们决定移动echo Emma 

00:04:01.759 --> 00:04:09.409
现在进入Eclipse Foundation 

00:04:04.280 --> 00:04:12.319
官方的Eclipse项目，但不是

00:04:09.409 --> 00:04:16.190
这对这次谈话很重要

00:04:12.319 --> 00:04:19.280
有趣的有趣事实，甚至那些艾玛

00:04:16.190 --> 00:04:23.120
插件对不起Emma库是一个库

00:04:19.280 --> 00:04:24.200
代码覆盖率

00:04:23.120 --> 00:04:27.290
测试

00:04:24.200 --> 00:04:33.590
实际上没有单个单元测试

00:04:27.290 --> 00:04:36.350
在这个库中，让我们继续前进

00:04:33.590 --> 00:04:39.200
谈论一些测量

00:04:36.350 --> 00:04:42.050
代码覆盖率，重要的是要提醒

00:04:39.200 --> 00:04:45.080
你是一个观察者，所以这是一个很大的

00:04:42.050 --> 00:04:49.040
 Wikipedia简化通话的报价

00:04:45.080 --> 00:04:51.910
这种观察者效应是

00:04:49.040 --> 00:04:55.160
测量任何一种仪器

00:04:51.910 --> 00:04:58.640
任何方式都会改变状态

00:04:55.160 --> 00:05:01.250
被测量的东西无论如何都存在

00:04:58.640 --> 00:05:06.680
削减的一些副作用

00:05:01.250 --> 00:05:08.660
覆盖范围，这对我们很重要

00:05:06.680 --> 00:05:11.030
用户，了解这一点很重要

00:05:08.660 --> 00:05:13.760
对于我们作为开发人员来说

00:05:11.030 --> 00:05:17.180
了解这一点很重要，以便

00:05:13.760 --> 00:05:22.040
尽量减少这种影响，以便

00:05:17.180 --> 00:05:24.320
尽量减少对性能的影响

00:05:22.040 --> 00:05:27.560
为了不改变行为

00:05:24.320 --> 00:05:29.860
应用程序，否则我们正在衡量

00:05:27.560 --> 00:05:32.180
我们没有测量的奇怪东西

00:05:29.860 --> 00:05:34.370
实际上是您的应用程序但是

00:05:32.180 --> 00:05:39.230
这会改变行为等

00:05:34.370 --> 00:05:45.680
让我们看看我们如何实现所有目标

00:05:39.230 --> 00:05:48.110
这些如何记录执行情况

00:05:45.680 --> 00:05:52.130
在某些应用程序中，有几个

00:05:48.110 --> 00:05:54.260
这种方法之一

00:05:52.130 --> 00:05:59.240
是您可以使用的一些运行时配置文件链接

00:05:54.260 --> 00:05:59.870
一些接口gbmpid gmj etcetera 

00:05:59.240 --> 00:06:02.540
等等

00:05:59.870 --> 00:06:05.540
你可以做的另一种方法

00:06:02.540 --> 00:06:08.450
仪器可以修改什么

00:06:05.540 --> 00:06:11.750
以一套方式执行将使您能够

00:06:08.450 --> 00:06:14.300
记录执行过程，那是

00:06:11.750 --> 00:06:16.820
通常是这样的方法

00:06:14.300 --> 00:06:20.120
被代码覆盖工具和jacoco所采用

00:06:16.820 --> 00:06:21.950
也不例外

00:06:20.120 --> 00:06:23.600
您可以采用的检测方法

00:06:21.950 --> 00:06:26.420
修改源代码

00:06:23.600 --> 00:06:30.230
这种方法是由Atlassian采用的

00:06:26.420 --> 00:06:32.090
三叶草库您可以使用的另一种方法

00:06:30.230 --> 00:06:35.470
修改字节码的结果是

00:06:32.090 --> 00:06:37.720
源码汇编

00:06:35.470 --> 00:06:40.290
咬的修饰会削减你

00:06:37.720 --> 00:06:43.240
也有两个选择，你可以做到这一点

00:06:40.290 --> 00:06:44.950
所谓的飞行模式才知道

00:06:43.240 --> 00:06:48.550
您的应用程序，您准备您的

00:06:44.950 --> 00:06:50.800
您对它们进行测量的班级和另一个

00:06:48.550 --> 00:06:53.310
方法是做完全一样的

00:06:50.800 --> 00:06:56.280
转换，但要在运行时执行

00:06:53.310 --> 00:06:59.560
对您的构建过程如此透明

00:06:56.280 --> 00:07:00.850
无需触摸实际的班级文件

00:06:59.560 --> 00:07:03.070
磁碟

00:07:00.850 --> 00:07:09.250
 Juuko实施了两种方法

00:07:03.070 --> 00:07:12.460
都有利弊等，并作为JUCO 

00:07:09.250 --> 00:07:15.040
在字节码上工作非常重要

00:07:12.460 --> 00:07:16.870
在ZZZ Jaco上加上感叹号

00:07:15.040 --> 00:07:19.570
仅适用于类文件

00:07:16.870 --> 00:07:24.160
它实际上不需要源文件

00:07:19.570 --> 00:07:26.080
所以它是如何工作的，我们有一个类文件

00:07:24.160 --> 00:07:27.850
做仪器，我们做的修改

00:07:26.080 --> 00:07:32.560
此类文件的修改

00:07:27.850 --> 00:07:34.660
字节码，然后我们执行什么

00:07:32.560 --> 00:07:38.440
我们只是修改了

00:07:34.660 --> 00:07:40.450
执行将记录

00:07:38.440 --> 00:07:45.940
有关执行的信息

00:07:40.450 --> 00:07:47.890
二进制格式，我们称为exec和at 

00:07:45.940 --> 00:07:49.930
我们再次进行报告分析的时间

00:07:47.890 --> 00:07:52.210
拿原始的班级文件，这是

00:07:49.930 --> 00:07:54.430
同样重要的原始交火

00:07:52.210 --> 00:07:57.730
其他一些类文件，但实际上

00:07:54.430 --> 00:08:00.490
我们组合的宙斯

00:07:57.730 --> 00:08:04.420
原始类文件与

00:08:00.490 --> 00:08:08.230
执行数据，然后我们进行分析， 

00:08:04.420 --> 00:08:11.680
我们得到一个报告，源代码播放

00:08:08.230 --> 00:08:14.380
角色仅在用户界面中显示

00:08:11.680 --> 00:08:18.190
您不错的亮点并复制源

00:08:14.380 --> 00:08:20.170
编写代码，这是获得源代码的唯一时刻

00:08:18.190 --> 00:08:23.320
如果没有，代码播放错误

00:08:20.170 --> 00:08:25.930
我们无论如何都可以告诉您的源代码

00:08:23.320 --> 00:08:27.700
线的数量已被覆盖

00:08:25.930 --> 00:08:35.979
方法的数量已经涵盖， 

00:08:27.700 --> 00:08:38.020
等等等，是的，关于如何

00:08:35.979 --> 00:08:41.050
将所有这些集成到构建过程中

00:08:38.020 --> 00:08:46.240
这就像为一个参数设置一样简单

00:08:41.050 --> 00:08:48.370
我们需要附加所谓的Java的JVM 

00:08:46.240 --> 00:08:50.620
将执行的代理

00:08:48.370 --> 00:08:55.810
字节的突变和转换

00:08:50.620 --> 00:09:00.490
此Java代理实现的代码

00:08:55.810 --> 00:09:03.370
这样的事情会在

00:09:00.490 --> 00:09:05.740
 JVM启动但启动之前

00:09:03.370 --> 00:09:08.860
您的应用程序此Java代理具有

00:09:05.740 --> 00:09:12.310
可以说任何课程的能力

00:09:08.860 --> 00:09:17.320
 JVM将要加载，我想拥有一个

00:09:12.310 --> 00:09:19.589
有机会转换其字节码

00:09:17.320 --> 00:09:23.410
看看这些字节码是什么

00:09:19.589 --> 00:09:27.190
您可以在幻灯片上进行转换

00:09:23.410 --> 00:09:29.680
看到一些控制流程图

00:09:27.190 --> 00:09:33.339
应用程序有一些顺序

00:09:29.680 --> 00:09:36.970
说明你有条件

00:09:33.339 --> 00:09:40.060
跳，你有入口点，你有出口

00:09:36.970 --> 00:09:43.600
点并为了记录

00:09:40.060 --> 00:09:46.480
只是在某些地方执行过程

00:09:43.600 --> 00:09:52.000
我们需要插入此控制流

00:09:46.480 --> 00:09:54.279
所谓的道具，例如，如果道具

00:09:52.000 --> 00:09:56.980
如果我们知道，底部是刚性的

00:09:54.279 --> 00:10:00.670
这段代码已执行，然后我们

00:09:56.980 --> 00:10:04.330
知道方法的退出是

00:10:00.670 --> 00:10:06.270
理查德（如果左支柱是理查德） 

00:10:04.330 --> 00:10:09.220
那我们知道一个分支

00:10:06.270 --> 00:10:11.950
如果你知道，有条件跳就是理查德

00:10:09.220 --> 00:10:15.700
我们知道正确的道具是理查德

00:10:11.950 --> 00:10:21.640
有条件跳跃的另一个分支

00:10:15.700 --> 00:10:25.420
更精确地到达了

00:10:21.640 --> 00:10:27.220
关于如何插入这些道具，如果您

00:10:25.420 --> 00:10:29.110
有一些不好的结果

00:10:27.220 --> 00:10:32.350
说明，这是非常容易的

00:10:29.110 --> 00:10:35.140
你可以在两者之间插入道具

00:10:32.350 --> 00:10:37.450
两条指令，您将知道

00:10:35.140 --> 00:10:39.790
如果执行了这个道具，那么所有

00:10:37.450 --> 00:10:43.779
进行此探针之前的说明

00:10:39.790 --> 00:10:45.880
如果有方法退出则执行

00:10:43.779 --> 00:10:48.640
这有点棘手，你不能

00:10:45.880 --> 00:10:50.740
离开出口后放好道具

00:10:48.640 --> 00:10:53.410
先放一点，然后放置

00:10:50.740 --> 00:10:58.240
它刚从返回

00:10:53.410 --> 00:11:00.339
方法，如果你有一个跳跃，这很漂亮

00:10:58.240 --> 00:11:02.110
与方法的退出非常相似

00:11:00.339 --> 00:11:04.930
你把道具

00:11:02.110 --> 00:11:08.680
如果执行了道具，则在跳转之前

00:11:04.930 --> 00:11:12.450
知道在以下情况下执行了跳转

00:11:08.680 --> 00:11:16.320
有条件的分支有条件的跳跃

00:11:12.450 --> 00:11:19.180
有点棘手，但是

00:11:16.320 --> 00:11:21.400
基本上你只需要知道事实

00:11:19.180 --> 00:11:24.730
哪个分支覆盖它，所以您插入

00:11:21.400 --> 00:11:26.350
放在那些分支之一上，如果它

00:11:24.730 --> 00:11:31.060
被执行，你知道这个分支

00:11:26.350 --> 00:11:33.820
被执行了，你可以想象

00:11:31.060 --> 00:11:38.140
所有这些只是基本策略

00:11:33.820 --> 00:11:40.930
 Java编译器实际上产生了

00:11:38.140 --> 00:11:45.450
宙斯的更复杂的组合

00:11:40.930 --> 00:11:48.210
所以所有这些都需要测试

00:11:45.450 --> 00:11:51.420
做如此独特的事情

00:11:48.210 --> 00:11:55.750
我们编写的Joko验证测试服

00:11:51.420 --> 00:12:00.760
各种不同的Java代码片段

00:11:55.750 --> 00:12:03.700
验证并清除该记录

00:12:00.760 --> 00:12:08.080
代码覆盖率和报告结果

00:12:03.700 --> 00:12:10.420
是我们期望我们做的

00:12:08.080 --> 00:12:13.120
通过注释源代码

00:12:10.420 --> 00:12:16.390
以后我们可以做特殊标记

00:12:13.120 --> 00:12:19.180
关于宙斯标记的断言相同

00:12:16.390 --> 00:12:28.270
发生什么事了

00:12:19.180 --> 00:12:31.960
有一个while循环等等等，所以我们

00:12:28.270 --> 00:12:35.590
在五个主要的GDK上执行此测试服

00:12:31.960 --> 00:12:38.380
我们支持Java代理的版本是

00:12:35.590 --> 00:12:41.980
在Java 5中介绍了它，所以这是

00:12:38.380 --> 00:12:45.990
我们的最小支持目标最大值

00:12:41.980 --> 00:12:49.540
 Java截至今天的支持数为9 

00:12:45.990 --> 00:12:55.840
我们还进行了抢先测试

00:12:49.540 --> 00:12:57.940
建立，并感谢所有这些测试，我们

00:12:55.840 --> 00:13:00.610
仿射仿射不仅在问题上而且在

00:12:57.940 --> 00:13:06.850
雅各，但实际上也公开

00:13:00.610 --> 00:13:09.460
如果我可以说JDK，甚至可以说我们

00:13:06.850 --> 00:13:14.240
主要发现对癸烷不开放的问题

00:13:09.460 --> 00:13:18.050
享受可可，显然我们在其中

00:13:14.240 --> 00:13:21.110
返回的前五名外部贡献者

00:13:18.050 --> 00:13:23.899
向openjdk报告此类项目

00:13:21.110 --> 00:13:28.490
正如实际看到的IntelliJ etcetera 

00:13:23.899 --> 00:13:33.170
 etcetera，实际上这不是那个

00:13:28.490 --> 00:13:36.110
您在此期间可能会觉得困难

00:13:33.170 --> 00:13:38.829
演示文稿，我们将看到多么容易

00:13:36.110 --> 00:13:41.329
它是在打开的JDK中找到背景并且

00:13:38.829 --> 00:13:47.720
回来并不难， 

00:13:41.329 --> 00:13:54.290
报告此操作，让我们看一下

00:13:47.720 --> 00:13:58.100
更深入地了解什么是道具

00:13:54.290 --> 00:14:00.709
非常快，为什么对为什么没有影响

00:13:58.100 --> 00:14:06.040
它对您的应用程序影响很小

00:14:00.709 --> 00:14:10.189
还有一些道具是什么

00:14:06.040 --> 00:14:12.470
在实施道具之前

00:14:10.189 --> 00:14:16.579
应该规定要求什么

00:14:12.470 --> 00:14:18.230
它应该像我们一样做和支撑

00:14:16.579 --> 00:14:20.600
已经说过了

00:14:18.230 --> 00:14:23.869
运行时开销应该和

00:14:20.600 --> 00:14:25.879
可能没有副作用

00:14:23.869 --> 00:14:27.410
尤其是在应用程序代码上

00:14:25.879 --> 00:14:29.600
你有这个线程安全，应该

00:14:27.410 --> 00:14:33.769
保持国家安全，所以我们不能

00:14:29.600 --> 00:14:36.759
非威胁安全代码是的，所以应该

00:14:33.769 --> 00:14:40.129
是线程安全的，显然应该

00:14:36.759 --> 00:14:43.899
记录下执行的事实

00:14:40.129 --> 00:14:47.059
应该说好，我已经被处决了， 

00:14:43.899 --> 00:14:49.069
如果您只记录执行事实，我们

00:14:47.059 --> 00:14:52.089
无法将其映射回原来的位置

00:14:49.069 --> 00:14:54.230
被执行，所以也应该

00:14:52.089 --> 00:14:57.019
可识别的，因此应该提供一些

00:14:54.230 --> 00:15:01.939
识别实际上是什么的方法

00:14:57.019 --> 00:15:03.529
执行好了，这是另一个

00:15:01.939 --> 00:15:06.679
给你的问题

00:15:03.529 --> 00:15:14.439
也许你有一些想法，这样的道具

00:15:06.679 --> 00:15:14.439
看起来像任何想法

00:15:19.080 --> 00:15:27.320
像公牛一样的东西

00:15:23.450 --> 00:15:31.640
完全满足所有要求

00:15:27.320 --> 00:15:37.350
数组索引为我们提供了识别

00:15:31.640 --> 00:15:40.529
还有什么是相当快的写作

00:15:37.350 --> 00:15:43.920
值放入布尔数组，因此它将

00:15:40.529 --> 00:15:47.040
如果我们写了一个

00:15:43.920 --> 00:15:50.100
布尔数组中的真实值

00:15:47.040 --> 00:15:52.260
一些标识符，我们知道代码

00:15:50.100 --> 00:15:56.910
关联，假设这是标识符

00:15:52.260 --> 00:16:02.760
已经执行了，这是另一个

00:15:56.910 --> 00:16:05.010
问题为什么这是线程安全的，如果

00:16:02.760 --> 00:16:08.480
多次执行同一道具

00:16:05.010 --> 00:16:08.480
从并发线程发送

00:16:19.390 --> 00:16:27.710
好的数组初始化它确实是

00:16:22.520 --> 00:16:31.310
和固体推迟是的，只是

00:16:27.710 --> 00:16:34.130
对，没有读，所以有

00:16:31.310 --> 00:16:35.720
如果没有机会，它就没有交易安全的机会

00:16:34.130 --> 00:16:37.160
两个线程将要写一个真实的

00:16:35.720 --> 00:16:39.860
重视哪一个都不重要

00:16:37.160 --> 00:16:44.030
成功了，那是没有办法的

00:16:39.860 --> 00:16:47.740
我们将了解有关运行时的Valley 

00:16:44.030 --> 00:16:51.280
开销以及对文件大小的影响

00:16:47.740 --> 00:16:55.130
您的课程会记录每个此类探查成本

00:16:51.280 --> 00:16:59.540
从4到7个字节增加了字节

00:16:55.130 --> 00:17:02.870
取决于我们有多少探头

00:16:59.540 --> 00:17:07.069
有成比例的字节进入

00:17:02.870 --> 00:17:11.569
您的课程也很有趣

00:17:07.069 --> 00:17:13.760
方面有些人想知道为什么我们之后

00:17:11.569 --> 00:17:15.860
将代码覆盖范围整合到我们的

00:17:13.760 --> 00:17:18.860
我们开始获得例外的项目

00:17:15.860 --> 00:17:20.720
方法之类的东西太大，因为

00:17:18.860 --> 00:17:23.270
没有免费的午餐，有一个

00:17:20.720 --> 00:17:27.020
 Java虚拟机上的限制

00:17:23.270 --> 00:17:29.060
通常添加的最大大小

00:17:27.020 --> 00:17:31.880
在其中添加一些其他说明

00:17:29.060 --> 00:17:33.650
如果您的方法接近

00:17:31.880 --> 00:17:35.690
我们可以轻松跨越这个边界

00:17:33.650 --> 00:17:42.920
那些添加后的边界

00:17:35.690 --> 00:17:48.260
指示炸弹接下来，好的，这是

00:17:42.920 --> 00:17:51.290
记录一些执行的过程

00:17:48.260 --> 00:17:54.200
指令的顺序，我们已经

00:17:51.290 --> 00:17:58.240
在讨论这个我们也提到

00:17:54.200 --> 00:18:01.220
该数组应归纳为

00:17:58.240 --> 00:18:04.490
现在有一个锯齿状的时间，然后

00:18:01.220 --> 00:18:06.350
比率应用程序以及您的某种方式

00:18:04.490 --> 00:18:08.960
包含访问权限的应用程序

00:18:06.350 --> 00:18:12.020
这个数组应该得到这个数组

00:18:08.960 --> 00:18:14.360
从雅各当前时间开始，那么我们该如何

00:18:12.020 --> 00:18:16.640
准时从Joe Cocker获得此阵列

00:18:14.360 --> 00:18:18.440
为了回答这个问题

00:18:16.640 --> 00:18:21.200
让我们来看看

00:18:18.440 --> 00:18:26.090
断言，假设我有这样一个

00:18:21.200 --> 00:18:28.730
简单的类，它只有一种方法

00:18:26.090 --> 00:18:30.810
我搜索的这种方法显示在

00:18:28.730 --> 00:18:35.740
参数

00:18:30.810 --> 00:18:39.910
有一个不错的-在GDK中叫做java p 

00:18:35.740 --> 00:18:42.730
可以给一个类的java反编译器

00:18:39.910 --> 00:18:45.190
文件可以显示字节码

00:18:42.730 --> 00:18:48.210
该类文件中的说明，因此

00:18:45.190 --> 00:18:53.890
这是编译的结果

00:18:48.210 --> 00:18:56.440
这样简单的程序，在这里我们可以

00:18:53.890 --> 00:18:59.260
在这个地方看到一些奇怪的东西

00:18:56.440 --> 00:19:03.160
编译我们实际上看到那里

00:18:59.260 --> 00:19:05.940
有多个条件有两个

00:19:03.160 --> 00:19:09.640
如果不相等则比较

00:19:05.940 --> 00:19:12.760
也可以访问静态字段

00:19:09.640 --> 00:19:16.030
哪一个叫断言

00:19:12.760 --> 00:19:18.640
残疾人，但我们没有写

00:19:16.030 --> 00:19:23.440
我们的源代码中的北两个条件

00:19:18.640 --> 00:19:27.850
我们也没有这样的领域

00:19:23.440 --> 00:19:30.030
这样可以简化您的生活

00:19:27.850 --> 00:19:30.030
一点

00:19:30.420 --> 00:19:37.060
显然是为了实施

00:19:32.560 --> 00:19:41.020
编译时声明Java编译器

00:19:37.060 --> 00:19:44.340
您的源代码生成了一个相当

00:19:41.020 --> 00:19:47.590
我们看到的有趣的字节码

00:19:44.340 --> 00:19:51.720
为您的班级注入一个特殊的领域

00:19:47.590 --> 00:19:54.910
名称断言被禁用

00:19:51.720 --> 00:19:57.310
然后每个断言都被转换

00:19:54.910 --> 00:20:00.400
进入以下两个条件之一

00:19:57.310 --> 00:20:03.190
条件是检查

00:20:00.400 --> 00:20:09.220
这个领域和另一个条件是

00:20:03.190 --> 00:20:12.490
断言的实际情况以及原因

00:20:09.220 --> 00:20:16.110
编译器这样做的答案是

00:20:12.490 --> 00:20:20.920
很简单，是为了减少

00:20:16.110 --> 00:20:22.630
间接费用，例如，您知道

00:20:20.920 --> 00:20:25.450
你可以禁用断言

00:20:22.630 --> 00:20:26.850
启用断言并针对给定

00:20:25.450 --> 00:20:30.160
为了知道是否上课

00:20:26.850 --> 00:20:32.500
断言的启用或禁用

00:20:30.160 --> 00:20:34.870
此类，您需要询问JVM是否可以

00:20:32.500 --> 00:20:37.180
您可以告诉我...的当前状态

00:20:34.870 --> 00:20:39.580
对于这个类的断言这是相当

00:20:37.180 --> 00:20:42.520
您需要去的昂贵的程序

00:20:39.580 --> 00:20:43.280
一些运行时，此运行时需要检查

00:20:42.520 --> 00:20:46.580
一些财产

00:20:43.280 --> 00:20:50.120
等等等，以减少这一点

00:20:46.580 --> 00:20:53.090
开销很简单

00:20:50.120 --> 00:20:57.530
让我们在初始化期间询问一次

00:20:53.090 --> 00:21:00.020
此静态最终字段，然后再进行

00:20:57.530 --> 00:21:05.060
让我们减少结果， 

00:21:00.020 --> 00:21:07.820
已经知道，重要的是

00:21:05.060 --> 00:21:11.000
注意这里是编译器生成的

00:21:07.820 --> 00:21:14.890
建立合成市场

00:21:11.000 --> 00:21:18.860
稍后会看到为什么这很重要

00:21:14.890 --> 00:21:22.400
这是一个好主意，我们可以使用

00:21:18.860 --> 00:21:25.040
我们实际上在

00:21:22.400 --> 00:21:28.490
为了减少运行时的开销

00:21:25.040 --> 00:21:30.920
得到探针数组，我们做同样的事情

00:21:28.490 --> 00:21:34.460
技巧，我们一次要求这个探针阵列

00:21:30.920 --> 00:21:37.220
我们将其存储到一个合成领域

00:21:34.460 --> 00:21:39.670
非常像启用断言和

00:21:37.220 --> 00:21:42.740
然后我们只需访问该字段

00:21:39.670 --> 00:21:48.560
与我们标记的Java编译器类似

00:21:42.740 --> 00:21:50.690
该领域是合成的，对于

00:21:48.560 --> 00:21:54.400
使用者的追逐这也很重要

00:21:50.690 --> 00:21:57.320
申请后认识一些人

00:21:54.400 --> 00:21:59.680
 jacoco在他们的项目上开始感到奇怪

00:21:57.320 --> 00:22:03.230
为什么使用反射的代码

00:21:59.680 --> 00:22:06.590
显然开始看到一些

00:22:03.230 --> 00:22:09.710
伸展他们从未带来的田野

00:22:06.590 --> 00:22:12.650
答案是代码不是

00:22:09.710 --> 00:22:15.380
忽略合成构造，而

00:22:12.650 --> 00:22:17.030
应该这样，请修正您的屈光度

00:22:15.380 --> 00:22:19.970
忽略合成结构

00:22:17.030 --> 00:22:22.670
即使简单也可以得到宙斯

00:22:19.970 --> 00:22:28.130
愚蠢的java来源不只是这个玩笑

00:22:22.670 --> 00:22:31.130
好吧，让我们继续前进

00:22:28.130 --> 00:22:32.480
向我提问，所以你已经知道了

00:22:31.130 --> 00:22:34.880
有一些合成的

00:22:32.480 --> 00:22:38.540
 Java编译器的构造

00:22:34.880 --> 00:22:43.070
你对其他有什么想法吗

00:22:38.540 --> 00:22:45.410
合成结构正好成为桥梁

00:22:43.070 --> 00:22:48.260
方法如此之一桥梁方法之一

00:22:45.410 --> 00:22:50.720
我们有外部的桥梁方法的例子

00:22:48.260 --> 00:22:54.980
上课我们有内在课

00:22:50.720 --> 00:22:56.120
可以访问

00:22:54.980 --> 00:22:58.090
外层阶级

00:22:56.120 --> 00:22:59.930
根据Java语言

00:22:58.090 --> 00:23:03.830
规格，这是完全有效的

00:22:59.930 --> 00:23:07.160
而这是允许的，但是根据

00:23:03.830 --> 00:23:09.560
 Java虚拟机规范

00:23:07.160 --> 00:23:13.400
这两个类在同一个

00:23:09.560 --> 00:23:16.610
包，在你的课上实际上不能

00:23:13.400 --> 00:23:20.750
访问外部类的私有字段

00:23:16.610 --> 00:23:23.420
所以为了避免这说什么

00:23:20.750 --> 00:23:25.670
 Java之间的少许偏差

00:23:23.420 --> 00:23:28.300
语言规范和虚拟

00:23:25.670 --> 00:23:32.180
机器规格编译器生成

00:23:28.300 --> 00:23:36.260
所谓的桥梁方法

00:23:32.180 --> 00:23:38.900
编译我们的课程，我们可以看到

00:23:36.260 --> 00:23:42.440
外层类编译后具有

00:23:38.900 --> 00:23:48.440
具有一些生成名称的特殊方法

00:23:42.440 --> 00:23:50.840
访问又是市场的东西

00:23:48.440 --> 00:23:56.120
作为合成的，如果我们编译内部

00:23:50.840 --> 00:23:59.830
上课，我们将看到字段的访问

00:23:56.120 --> 00:24:04.420
实际上是通过

00:23:59.830 --> 00:24:04.420
通过生成的合成方法

00:24:04.960 --> 00:24:10.790
你知道的枚举中的方法呢

00:24:08.510 --> 00:24:12.860
如果我们在欧姆中声明一些

00:24:10.790 --> 00:24:15.140
常数，我们将获得两个附加值

00:24:12.860 --> 00:24:23.810
 Java编译器生成的方法

00:24:15.140 --> 00:24:26.500
值和合成的值

00:24:23.810 --> 00:24:29.210
这不是一个普遍的误解， 

00:24:26.500 --> 00:24:31.550
 Java编译器生成的所有内容都是

00:24:29.210 --> 00:24:35.530
合成否此方法不在

00:24:31.550 --> 00:24:35.530
合成的，原因是

00:24:36.310 --> 00:24:45.130
 Java编译器不允许您

00:24:39.710 --> 00:24:48.680
明确地提到一些合成的

00:24:45.130 --> 00:24:53.330
你不能写一个可以编译的代码

00:24:48.680 --> 00:24:56.150
它会使用合成的

00:24:53.330 --> 00:24:58.940
方法合成领域和那些

00:24:56.150 --> 00:25:03.130
枚举值和值的两种方法

00:24:58.940 --> 00:25:05.910
它们旨在被

00:25:03.130 --> 00:25:08.100
开发商他们不是合成的

00:25:05.910 --> 00:25:14.610
这对于代码覆盖率很重要

00:25:08.100 --> 00:25:16.530
工具，因为您不需要测试

00:25:14.610 --> 00:25:19.620
编译器生成的代码

00:25:16.530 --> 00:25:21.900
您将信任编译器，所以这

00:25:19.620 --> 00:25:25.680
方法实际上应该从

00:25:21.900 --> 00:25:29.430
覆盖率分析仪让我们开始前进

00:25:25.680 --> 00:25:32.810
转发另一个有趣的例子

00:25:29.430 --> 00:25:37.190
由...生成的合成结构

00:25:32.810 --> 00:25:41.880
 Java编译器的实现

00:25:37.190 --> 00:25:44.640
 lambda，所以如果您有lambda 

00:25:41.880 --> 00:25:48.360
函数式接口的实现

00:25:44.640 --> 00:25:51.120
如果您D再一次像这样运行

00:25:48.360 --> 00:25:54.540
编译它，在这里您可能会学到一些

00:25:51.120 --> 00:25:58.770
 Java反编译器的新选项-L其中

00:25:54.540 --> 00:26:02.540
将在de中显示您的对齐数字

00:25:58.770 --> 00:26:05.820
在代码中编译，您将看到

00:26:02.540 --> 00:26:08.880
在这堂课中，您将再有一个

00:26:05.820 --> 00:26:12.090
名称以开头的合成方法

00:26:08.880 --> 00:26:15.330
 lambda和产生的某些东西

00:26:12.090 --> 00:26:19.230
实际上这个方法的内容

00:26:15.330 --> 00:26:23.930
在此方法中的线

00:26:19.230 --> 00:26:27.540
一二一二你的lambda 

00:26:23.930 --> 00:26:29.850
这又是坚果之前

00:26:27.540 --> 00:26:31.560
龙在这里这是实现

00:26:29.850 --> 00:26:35.400
 Lambda的详细信息无法保证

00:26:31.560 --> 00:26:37.320
那明天不会改变为什么

00:26:35.400 --> 00:26:41.570
这对于代码覆盖率很重要，因为

00:26:37.320 --> 00:26:44.460
我们说过一些方法之前， 

00:26:41.570 --> 00:26:47.910
特别是那些由

00:26:44.460 --> 00:26:49.290
编译器合成而不是合成我们

00:26:47.910 --> 00:26:52.980
应该忽略代码覆盖率

00:26:49.290 --> 00:26:54.600
而对于lambdas甚至动物园来说，其市场

00:26:52.980 --> 00:26:56.460
合成的，我们不应该忽略它

00:26:54.600 --> 00:26:58.850
因为你想要覆盖你的

00:26:56.460 --> 00:26:58.850
数字

00:27:00.859 --> 00:27:05.639
我们如何进行所有这些操作

00:27:04.470 --> 00:27:09.509
带字节码

00:27:05.639 --> 00:27:11.340
我们依靠如此强大的图书馆

00:27:09.509 --> 00:27:13.830
五十胜

00:27:11.340 --> 00:27:19.259
这使我们可以读取字节码

00:27:13.830 --> 00:27:21.659
写字节码等等等在这里

00:27:19.259 --> 00:27:27.029
这是一个有趣的有趣事实

00:27:21.659 --> 00:27:32.070
连接如何支持我们如何

00:27:27.029 --> 00:27:34.440
确实带来了对Java 9的支持，所以如果我们

00:27:32.070 --> 00:27:38.730
从早期开始将采用Java编译器

00:27:34.440 --> 00:27:42.179
如果我们要编译，请访问gdk9的构建

00:27:38.730 --> 00:27:46.710
一些类到Java 9的字节码中

00:27:42.179 --> 00:27:50.460
如果我们尝试使用某些

00:27:46.710 --> 00:27:52.859
当时在该类文件上的库

00:27:50.460 --> 00:27:55.320
我们实际上会得到非法论点

00:27:52.859 --> 00:27:58.529
例外和我相同的原因

00:27:55.320 --> 00:27:59.039
 Java的库尚未更新

00:27:58.529 --> 00:28:05.609
 9 

00:27:59.039 --> 00:28:08.279
那么我们之前如何支持Java 9 

00:28:05.609 --> 00:28:11.609
 SM的实际发行版

00:28:08.279 --> 00:28:16.889
将在Java 9发布后发生

00:28:11.609 --> 00:28:19.529
对我们来说有点晚了

00:28:16.889 --> 00:28:21.960
是的，如果在

00:28:19.529 --> 00:28:25.379
同一类文件，我们将使用标准

00:28:21.960 --> 00:28:29.820
 java decompiler甚至旧版本

00:28:25.379 --> 00:28:32.100
像1.7版一样，实际上

00:28:29.820 --> 00:28:35.759
没有问题可以反编译此类

00:28:32.100 --> 00:28:40.350
该类文件将显示确定

00:28:35.759 --> 00:28:43.249
我的主要版本号ZZZ 

00:28:40.350 --> 00:28:45.720
可能不是很好的支持，但

00:28:43.249 --> 00:28:48.359
不会有任何非法论点

00:28:45.720 --> 00:28:51.119
例外，编译器可以做什么

00:28:48.359 --> 00:28:55.619
将其编译为已编译的内容

00:28:51.119 --> 00:28:57.989
不能，不能，几乎是

00:28:55.619 --> 00:29:02.460
同样的故事，对不起

00:28:57.989 --> 00:29:06.419
编译器的另一个隐藏的宝石

00:29:02.460 --> 00:29:11.039
是你实际上可以使用一些隐藏的

00:29:06.419 --> 00:29:12.570
像---的标志会标记详细信息，而您

00:29:11.039 --> 00:29:15.059
可以实际

00:29:12.570 --> 00:29:17.639
不仅可以看到白大褂

00:29:15.059 --> 00:29:22.799
也可以看到字节码和

00:29:17.639 --> 00:29:25.409
源代码在同一输出中，因此

00:29:22.799 --> 00:29:27.959
回到项目我们如何解决它

00:29:25.409 --> 00:29:31.099
支持Java 9的问题

00:29:27.959 --> 00:29:35.449
项目的变更版本

00:29:31.099 --> 00:29:39.359
自Java 9以来的字节码

00:29:35.449 --> 00:29:41.879
仅带来没有的模型信息

00:29:39.359 --> 00:29:44.549
包含我们所使用的任何方法

00:29:41.879 --> 00:29:47.729
感兴趣，因为它不包含

00:29:44.549 --> 00:29:50.669
我们可以假装的任何方法

00:29:47.729 --> 00:29:53.729
我们看到Java 9字节码的时间

00:29:50.669 --> 00:29:55.559
实际看到一个Java 8字节代码，所以我

00:29:53.729 --> 00:29:59.159
假设我们将能够阅读此

00:29:55.559 --> 00:30:02.999
字节码，我们将根据需要对其进行转换

00:29:59.159 --> 00:30:07.019
然后为了隐藏这个

00:30:02.999 --> 00:30:09.629
小技巧，我们将升级课程

00:30:07.019 --> 00:30:13.649
文件版本回来，所以外面的每个人

00:30:09.629 --> 00:30:17.099
将会看到确定，它是Java 9，它是giovanna 

00:30:13.649 --> 00:30:23.729
但在内部，我们正在与之打交道

00:30:17.099 --> 00:30:25.349
就像Java 8一样

00:30:23.729 --> 00:30:27.569
这时候请呼吸

00:30:25.349 --> 00:30:32.339
一点点，这只是一点点

00:30:27.569 --> 00:30:34.349
热身，我希望你的大脑现在温暖了

00:30:32.339 --> 00:30:38.339
足够，我们没有那么多时间，所以我们

00:30:34.349 --> 00:30:42.719
会尝试更快一点

00:30:38.339 --> 00:30:45.449
一点硬核的东西，请尝试

00:30:42.719 --> 00:30:47.659
跟我说我有这样的课

00:30:45.449 --> 00:30:51.469
此类有一个静态初始值设定项

00:30:47.659 --> 00:30:53.940
我们在这个静态初始化程序中初始化

00:30:51.469 --> 00:30:56.779
其他一些对象的构造

00:30:53.940 --> 00:30:59.909
一些类，我们在其上调用方法

00:30:56.779 --> 00:31:03.479
其他班级实际上是

00:30:59.909 --> 00:31:06.089
这个基类，它在

00:31:03.479 --> 00:31:10.979
在这种方法中，我们做一个断言是

00:31:06.089 --> 00:31:13.769
等于2，然后我们重新运行所有

00:31:10.979 --> 00:31:16.679
这对你来说是个问题

00:31:13.769 --> 00:31:20.269
如果我执行了这个然后我说

00:31:16.679 --> 00:31:20.269
好的断言邻里

00:31:22.680 --> 00:31:27.270
来吧，你的大脑应该热身

00:31:25.200 --> 00:31:29.400
已经启用断言，我们有一个

00:31:27.270 --> 00:31:31.800
断言一等于二是

00:31:29.400 --> 00:31:34.590
显然是错误的，他们将成为

00:31:31.800 --> 00:31:42.360
例外，这很容易

00:31:34.590 --> 00:31:44.490
那禁用断言呢

00:31:42.360 --> 00:31:49.020
刚跑的人以为会

00:31:44.490 --> 00:31:51.290
是的，它将运行

00:31:49.020 --> 00:31:55.800
不幸的是它将抛出异常

00:31:51.290 --> 00:31:59.070
以及我们再次这样做的原因

00:31:55.800 --> 00:32:01.350
回想一下如何启用断言

00:31:59.070 --> 00:32:03.990
静态最终字段断言已禁用

00:32:01.350 --> 00:32:08.700
它在静态中初始化

00:32:03.990 --> 00:32:13.980
初始化程序，如果您遵循

00:32:08.700 --> 00:32:16.680
执行顺序是什么

00:32:13.980 --> 00:32:20.220
为了发生insulite 

00:32:16.680 --> 00:32:24.150
孩子，我们需要第一个胰岛素基础

00:32:20.220 --> 00:32:26.850
在合并基础期间，我们去

00:32:24.150 --> 00:32:28.710
孩子，实际上导致一种方法

00:32:26.850 --> 00:32:32.060
该方法将在之前被调用

00:32:28.710 --> 00:32:34.590
一个孩子的初始化和

00:32:32.060 --> 00:32:36.720
安装前称为科学

00:32:34.590 --> 00:32:39.330
对于一个孩子，此字段具有默认值

00:32:36.720 --> 00:32:42.150
值和java中的默认值

00:32:39.330 --> 00:32:44.970
布尔值为假，因此禁用断言

00:32:42.150 --> 00:32:47.070
但此方法为假状态

00:32:44.970 --> 00:32:50.100
将被称为，你会得到

00:32:47.070 --> 00:32:53.460
在这里断言为什么这样和这样的

00:32:50.100 --> 00:32:56.940
这种情况我们称其为不良循环

00:32:53.460 --> 00:32:58.890
这很重要，因为我们以此为基础

00:32:56.940 --> 00:33:02.430
实施与

00:32:58.890 --> 00:33:04.650
外科医生的，那么在发生什么

00:33:02.430 --> 00:33:07.860
 jacoco的糟糕周期的情况下，我们

00:33:04.650 --> 00:33:10.340
会遇到完全相同的问题

00:33:07.860 --> 00:33:13.350
字段将具有默认值

00:33:10.340 --> 00:33:14.910
金银阵列的默认值现在是

00:33:13.350 --> 00:33:18.570
所以我们将得到一个空指针

00:33:14.910 --> 00:33:19.770
例外，我们该如何解决呢？ 

00:33:18.570 --> 00:33:22.380
解决这个问题，我们介绍另一个

00:33:19.770 --> 00:33:25.710
合成方法，我们称之为

00:33:22.380 --> 00:33:27.690
联盟而不是进入战场

00:33:25.710 --> 00:33:30.480
直接我们总是去这种方法

00:33:27.690 --> 00:33:33.060
此方法检查是否有一些

00:33:30.480 --> 00:33:35.340
值，然后返回该值

00:33:33.060 --> 00:33:36.300
它没有这样的价值

00:33:35.340 --> 00:33:38.690
盟友和这些

00:33:36.300 --> 00:33:46.320
 Issus是初始化的好命令

00:33:38.690 --> 00:33:47.450
哦，这个有什么问题吗

00:33:46.320 --> 00:33:54.920
解

00:33:47.450 --> 00:33:58.020
任何人都可以这样做

00:33:54.920 --> 00:34:00.390
 Jaco网站上的多重交易

00:33:58.020 --> 00:34:02.220
目前我基本上在这个地方

00:34:00.390 --> 00:34:04.230
我们准时打电话到Jackar 

00:34:02.220 --> 00:34:07.380
得到一个数组，我们有一个同步

00:34:04.230 --> 00:34:10.230
因此，如果-我们将尝试在

00:34:07.380 --> 00:34:13.590
同时不会没事的

00:34:10.230 --> 00:34:16.679
现在要尝试他们，以便

00:34:13.590 --> 00:34:18.140
走得更快，如果有的话，让我加快流程

00:34:16.679 --> 00:34:20.670
您将转到Java虚拟机

00:34:18.140 --> 00:34:23.550
规格转化为看跌规格

00:34:20.670 --> 00:34:29.310
静态的，我们会发现您可以致电

00:34:23.550 --> 00:34:32.130
仅在字段为final时才放静态

00:34:29.310 --> 00:34:35.340
和你：这把考试

00:34:32.130 --> 00:34:37.650
静态指令必须出现在

00:34:35.340 --> 00:34:40.290
称为类初始化方法

00:34:37.650 --> 00:34:43.860
否则这里是非法访问

00:34:40.290 --> 00:34:47.130
坚强，如果我们回头看

00:34:43.860 --> 00:34:50.490
示例实际上这是一个最终字段

00:34:47.130 --> 00:34:53.460
它是静态的，以便于如此

00:34:50.490 --> 00:34:57.000
我们称看跌期权为静态，这是

00:34:53.460 --> 00:34:59.610
工作了很多年，因为

00:34:57.000 --> 00:35:02.340
显然它从未被检查过

00:34:59.610 --> 00:35:05.970
由于gdk9您开始检查

00:35:02.340 --> 00:35:11.570
为Java 9的类文件构建的Lexus 

00:35:05.970 --> 00:35:15.570
版本，是的，所以我们需要一个适当的

00:35:11.570 --> 00:35:17.880
为此解决了很多年

00:35:15.570 --> 00:35:20.780
我们所做的只是在

00:35:17.880 --> 00:35:25.950
现在终于可以了

00:35:20.780 --> 00:35:28.410
那接口呢？ 

00:35:25.950 --> 00:35:33.180
接口没有这种问题

00:35:28.410 --> 00:35:37.470
因为一切都很好

00:35:33.180 --> 00:35:41.010
静态最终，我们可以初始化字段

00:35:37.470 --> 00:35:43.440
他们没有的静态初始化接口

00:35:41.010 --> 00:35:47.610
有方法，但循环不能弯曲

00:35:43.440 --> 00:35:49.980
是接口，但不，关于Java 8 

00:35:47.610 --> 00:35:52.680
在Java中，您确实拥有

00:35:49.980 --> 00:35:56.130
您具有默认接口的方法

00:35:52.680 --> 00:35:59.220
方法，所以可能是坏的

00:35:56.130 --> 00:36:02.190
接口可能会发生循环

00:35:59.220 --> 00:36:04.140
为了确认这一点，让我们开始吧

00:36:02.190 --> 00:36:06.770
 Java语言规范

00:36:04.140 --> 00:36:09.240
让我们阅读隔热课程时

00:36:06.770 --> 00:36:11.490
类或接口和萨拉斯

00:36:09.240 --> 00:36:13.980
紧接该类实例之前

00:36:11.490 --> 00:36:17.580
创建或静态方法声明

00:36:13.980 --> 00:36:19.500
类被调用以及何时在类中为什么

00:36:17.580 --> 00:36:22.140
是否声明了任何超级接口

00:36:19.500 --> 00:36:23.400
任何默认方法也是如此

00:36:22.140 --> 00:36:27.150
这是Java语言规范

00:36:23.400 --> 00:36:29.490
说让我们尝试用

00:36:27.150 --> 00:36:32.900
接口，所以我们将触发

00:36:29.490 --> 00:36:35.700
通过创建实例进行初始化

00:36:32.900 --> 00:36:37.770
与类的示例类似，我们将

00:36:35.700 --> 00:36:39.600
有一些基本接口，以便

00:36:37.770 --> 00:36:43.109
触发其安装，我们将拥有

00:36:39.600 --> 00:36:45.270
为了触发默认方法

00:36:43.109 --> 00:36:48.570
糟糕的周期，我们将再次致电

00:36:45.270 --> 00:36:53.280
入子成子方法

00:36:48.570 --> 00:36:56.550
我们将有一个孩子

00:36:53.280 --> 00:37:00.180
会有一些静态输出

00:36:56.550 --> 00:37:04.680
初始化，我们将有这个

00:37:00.180 --> 00:37:08.270
方法和预期结果

00:37:04.680 --> 00:37:11.369
是要么我们会看到异常等等

00:37:08.270 --> 00:37:13.640
从哪里的堆栈跟踪

00:37:11.369 --> 00:37:15.740
方法被调用或者我们将看到它

00:37:13.640 --> 00:37:19.350
行静态初始化之前

00:37:15.740 --> 00:37:23.869
发生，否则我们会看到它

00:37:19.350 --> 00:37:25.710
在他们面前看到它，然后这是

00:37:23.869 --> 00:37:28.410
这些不良周期的确认

00:37:25.710 --> 00:37:30.930
如果看到的话，接口是可能的

00:37:28.410 --> 00:37:34.619
之后，但cycleways接口是

00:37:30.930 --> 00:37:39.930
不可能，所以你认为是什么

00:37:34.619 --> 00:37:43.320
当我们调用这样的代码时发生的事情是

00:37:39.930 --> 00:37:45.630
在谁为静态之前或之后

00:37:43.320 --> 00:37:52.940
初始化发生在调用之前

00:37:45.630 --> 00:37:52.940
谁想的方法好

00:37:54.490 --> 00:38:02.630
谁认为它会崩溃好吗

00:37:59.680 --> 00:38:05.960
其实认为这取决于，这就是为什么

00:38:02.630 --> 00:38:10.550
我实际上举了三遍

00:38:05.960 --> 00:38:14.900
取决于您之前是否使用了GDK版本

00:38:10.550 --> 00:38:19.700
 JDK 8更新40，那么您将得到

00:38:14.900 --> 00:38:21.590
这几秒钟，如果你和你实际上

00:38:19.700 --> 00:38:23.390
会崩溃，因为你

00:38:21.590 --> 00:38:24.950
拖钓可能会例外，因此目前

00:38:23.390 --> 00:38:30.820
引发异常

00:38:24.950 --> 00:38:35.180
有趣的是，如果你被压碎

00:38:30.820 --> 00:38:37.640
通过静态调用进行初始化

00:38:35.180 --> 00:38:43.150
方法您将要再下一个订单

00:38:37.640 --> 00:38:46.970
如果您检查的话甚至不一致

00:38:43.150 --> 00:38:49.100
我们的GDK内置的Laxus会更新为8 

00:38:46.970 --> 00:38:53.810
你会看到正确的顺序

00:38:49.100 --> 00:38:56.750
它是固定的，这是多么容易

00:38:53.810 --> 00:38:58.760
赶回GDK，这是

00:38:56.750 --> 00:39:04.030
由我们提供，我们报告了

00:38:58.760 --> 00:39:06.620
这就是为什么要修复的原因

00:39:04.030 --> 00:39:10.070
接口我们仍然需要支持

00:39:06.620 --> 00:39:11.680
该顺序的情况如此，对于接口

00:39:10.070 --> 00:39:16.100
有一点更复杂

00:39:11.680 --> 00:39:17.930
策略，我们不能使该字段为非

00:39:16.100 --> 00:39:20.540
最后，因为一切都可以接口

00:39:17.930 --> 00:39:24.680
它应该是最终的，所以我们恢复

00:39:20.540 --> 00:39:30.710
最后，但现在我们需要防止

00:39:24.680 --> 00:39:32.960
写这个领域，所以我们用

00:39:30.710 --> 00:39:35.150
静态初始化，但在

00:39:32.960 --> 00:39:38.180
静态初始化发生，我们仍然

00:39:35.150 --> 00:39:41.450
需要获取数组，所以我们的速度很慢

00:39:38.180 --> 00:39:47.540
通过一些GDK而未分配通过

00:39:41.450 --> 00:39:49.910
版本用完我们很抱歉

00:39:47.540 --> 00:39:53.270
为此，我们将很快

00:39:49.910 --> 00:39:55.850
完成最后一个有趣的问题

00:39:53.270 --> 00:39:58.580
 Java代码覆盖的工作原理是

00:39:55.850 --> 00:40:00.650
您知道的OSGi世界中的运行时访问

00:39:58.580 --> 00:40:02.810
你有一个类装载机铁饼装载机

00:40:00.650 --> 00:40:05.150
他们可以限制访问某些

00:40:02.810 --> 00:40:06.460
类并仅提供一些此类

00:40:05.150 --> 00:40:08.590
那你

00:40:06.460 --> 00:40:10.390
特别要求我们说我们

00:40:08.590 --> 00:40:12.550
有这样的实现

00:40:10.390 --> 00:40:14.800
限制性的类加载器，它为您提供了

00:40:12.550 --> 00:40:17.490
显然可以访问所有

00:40:14.800 --> 00:40:22.540
是基于Java的java.lang和

00:40:17.490 --> 00:40:25.330
也对您的某些应用程序类

00:40:22.540 --> 00:40:27.760
狮子关心包裹，但是限制

00:40:25.330 --> 00:40:33.130
访问所有特别演员

00:40:27.760 --> 00:40:36.340
它限制了访问两个雅各布

00:40:33.130 --> 00:40:38.350
包，所以我们实际上如何称呼我们的

00:40:36.340 --> 00:40:40.260
检测类的运行时

00:40:38.350 --> 00:40:46.780
该类模型已加载

00:40:40.260 --> 00:40:51.070
这是一个问题，什么课上

00:40:46.780 --> 00:40:55.510
 loader是一种我们可以上课的方式

00:40:51.070 --> 00:40:59.530
加载程序可能很棘手，实际上我们

00:40:55.510 --> 00:41:04.540
有一个更简单的解决方案，因为我们有一个

00:40:59.530 --> 00:41:08.560
 Java代理先于一切

00:41:04.540 --> 00:41:11.980
否则我们实际上可以在

00:41:08.560 --> 00:41:14.950
在Java排名和所有类加载器中

00:41:11.980 --> 00:41:16.930
他们确实可以访问Java等级

00:41:14.950 --> 00:41:21.330
不要限制这个，所以我们做什么

00:41:16.930 --> 00:41:25.470
只需在其中一个创建一个特殊字段

00:41:21.330 --> 00:41:29.170
 Java类，我从没告诉过你

00:41:25.470 --> 00:41:31.900
实际上没有这样的领域

00:41:29.170 --> 00:41:34.300
更确切地说，这是我们已经

00:41:31.900 --> 00:41:36.730
更改它的名称，因为它是

00:41:34.300 --> 00:41:42.250
我不会再告诉你这堂课

00:41:36.730 --> 00:41:45.760
现在是哪一个，然后像我们一样

00:41:42.250 --> 00:41:49.270
无法访问Java以外的任何内容

00:41:45.760 --> 00:41:51.490
也没有界面可以调用我们的

00:41:49.270 --> 00:41:55.930
运行时，所以我们需要以某种方式执行此操作

00:41:51.490 --> 00:42:00.940
不同，所以我们推测

00:41:55.930 --> 00:42:04.150
等于此jacoco访问权限的方法

00:42:00.940 --> 00:42:07.450
一个对象，这个对象没有那么多

00:42:04.150 --> 00:42:11.490
方法只有相等方法，所以我们

00:42:07.450 --> 00:42:14.560
通过数组传递参数

00:42:11.490 --> 00:42:17.380
对象和数组只是一个对象，所以

00:42:14.560 --> 00:42:20.030
我们可以通过一个简单的问题

00:42:17.380 --> 00:42:25.640
我们会得到结果吗？ 

00:42:20.030 --> 00:42:30.980
一个prop数组返回equals方法返回

00:42:25.640 --> 00:42:34.460
布尔值，我们需要一个数组，谢天谢地

00:42:30.980 --> 00:42:36.860
在Java数组中是不可变的，所以我们可以

00:42:34.460 --> 00:42:40.640
我们可以简单地推测事实

00:42:36.860 --> 00:42:44.840
该运行时将修改此数组，并

00:42:40.640 --> 00:42:47.390
这就是我们的方式，希望您有一些

00:42:44.840 --> 00:42:49.640
在这个演讲中的乐趣不要

00:42:47.390 --> 00:42:53.090
犹豫参与不要犹豫

00:42:49.640 --> 00:42:54.470
测试GDK的早期访问版本，并

00:42:53.090 --> 00:42:57.200
报告错误

00:42:54.470 --> 00:42:59.270
现在您知道内部结构，请帮助

00:42:57.200 --> 00:43:03.020
我们在哪里回答一些用户问题

00:42:59.270 --> 00:43:06.050
反射不起作用等在堆栈上等

00:43:03.020 --> 00:43:10.280
溢出也不要犹豫

00:43:06.050 --> 00:43:14.210
 Eclipse echo Emma项目的开发

00:43:10.280 --> 00:43:16.840
和jacoco项目，仅此而已

00:43:14.210 --> 00:43:16.840
您的关注

00:43:21.100 --> 00:43:25.350
如果您有任何疑问，我们

00:43:23.380 --> 00:43:29.010
没有时间请抓紧我

00:43:25.350 --> 00:43:29.010
外面的某个地方

