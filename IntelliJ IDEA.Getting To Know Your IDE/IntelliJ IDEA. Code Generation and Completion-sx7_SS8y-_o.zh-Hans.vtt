WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.750 --> 00:00:08.969
 IntelliJ IDEA可以显着减少编码时的输入量， 

00:00:08.969 --> 00:00:10.740
在此截屏视频中，我们将研究如何操作。 

00:00:10.740 --> 00:00:14.060
我们将从简单的Java项目开始， 

00:00:14.060 --> 00:00:19.150
因此我们可以从一开始就看到IntelliJ IDEA可以为我们做多少工作。 

00:00:19.150 --> 00:00:23.110
在另一个截屏视频中，将详细介绍如何开始新项目。 

00:00:23.110 --> 00:00:24.820
我们还将使用键盘进行

00:00:24.820 --> 00:00:29.849
我们的大部分导航，如“导航”截屏中所示。 

00:00:29.849 --> 00:00:31.510
 IntelliJ IDEA已创建源目录

00:00:31.510 --> 00:00:36.480
用于我们的生产Java代码，但是我们需要为我们的测试代码创建一个目录。 

00:00:36.480 --> 00:00:42.940
我们可以在Windows上使用Alt Insert或在Mac上使用Cmd N来创建新内容。 

00:00:42.940 --> 00:00:47.200
在项目窗口中，我们将创建一个新目录。 

00:00:47.200 --> 00:00:51.149
我们需要告诉IntelliJ IDEA这是测试代码，因此我们可以右键单击并标记

00:00:51.149 --> 00:00:52.850
将其作为测试目录。 

00:00:52.850 --> 00:00:54.840
现在我们有了基本目录，我们可以

00:00:54.840 --> 00:00:56.860
创建我们的Java包。 

00:00:56.860 --> 00:01:02.220
输入“新”下拉菜单可让我们将选项缩小到所需的范围。 

00:01:02.220 --> 00:01:06.581
我们可以在此处键入完整的软件包名称，IntelliJ IDEA将创建正确的目录

00:01:06.581 --> 00:01:08.719
该程序包的结构。 

00:01:08.719 --> 00:01:10.560
现在我们有了一个包，我们可以创建一个新的

00:01:10.560 --> 00:01:12.560
 Java类。 

00:01:12.560 --> 00:01:17.350
在第一个示例中，我们将创建一个简单的Main类。 

00:01:17.350 --> 00:01:21.590
您可以看到IntelliJ IDEA使用适当的包和类创建了Main.java文件。 

00:01:21.590 --> 00:01:23.280
声明已填写。 

00:01:23.280 --> 00:01:26.600
接下来，我们可以使用称为实时模板的功能

00:01:26.600 --> 00:01:30.710
创建标准模板代码而无需键入太多内容。 

00:01:30.710 --> 00:01:37.750
我们输入psvm并按tab或Enter，然后IntelliJ IDEA创建一个公共static void main方法

00:01:37.750 --> 00:01:41.130
类，然后将光标放在方法主体中。 

00:01:41.130 --> 00:01:43.759
有很多实时模板可用于生成

00:01:43.759 --> 00:01:44.810
通用代码。 

00:01:44.810 --> 00:01:50.790
如果要打印一些内容到System.out，我们可以输入sout，然后再次输入一个数字

00:01:50.790 --> 00:01:52.190
选项。 

00:01:52.190 --> 00:01:57.190
我们将选择最简单的选项，并打印字符串“ Hello”。 

00:01:57.190 --> 00:02:00.460
运行该类将为我们提供期望的输出。 

00:02:00.460 --> 00:02:01.460
 --- 

00:02:01.460 --> 00:02:02.460
那只是IntelliJ IDEA可以尝到的味道

00:02:02.460 --> 00:02:03.659
在编码时帮助我们。 

00:02:03.659 --> 00:02:06.680
让我们看一个更现实的例子。 

00:02:06.680 --> 00:02:11.599
我们将使用“测试驱动开发”方法来创建一些基本的Shape功能。 

00:02:11.599 --> 00:02:15.660
首先，我们将再次使用Alt + Ins / Cmd + N 

00:02:15.660 --> 00:02:17.459
创建一个新类。 

00:02:17.459 --> 00:02:22.780
当我们有了骨架类时，可以在类名上使用Alt和Enter键，然后选择

00:02:22.780 --> 00:02:26.500
创建测试以为此类创建一个单元测试。 

00:02:26.500 --> 00:02:31.050
 IntelliJ IDEA开箱即用地支持许多标准测试库，我们将

00:02:31.050 --> 00:02:33.830
使用Junit 5进行测试。 

00:02:33.830 --> 00:02:38.879
 IDE告诉我们在类路径上没有JUnit 5 Jar文件，我们可以使用

00:02:38.879 --> 00:02:42.840
修复按钮以从Maven Central下载库并将其放在类路径中

00:02:42.840 --> 00:02:45.629
因此它们可供我们使用。 

00:02:45.629 --> 00:02:49.320
我们可以选择生成测试类的某些结构，但是我们没有

00:02:49.320 --> 00:02:51.900
需要这些例子。 

00:02:51.900 --> 00:02:53.569
 IntelliJ IDEA将断言添加为静态

00:02:53.569 --> 00:02:59.580
 import使其尽可能容易地用于编写直接编译的测试。 

00:02:59.580 --> 00:03:04.510
 IDE已在相应程序包的测试源根目录中创建了此测试文件， 

00:03:04.510 --> 00:03:07.650
为我们创建所有适当的目录结构。 

00:03:07.650 --> 00:03:09.459
我们可以再次使用generate来创建一个新的

00:03:09.459 --> 00:03:11.540
测试方法。 

00:03:11.540 --> 00:03:16.430
这是用Junit 5注释注释的，IntelliJ IDEA希望我们更改

00:03:16.430 --> 00:03:20.860
方法名称更有意义，然后按Enter键

00:03:20.860 --> 00:03:22.870
在方法主体内部。 

00:03:22.870 --> 00:03:24.360
 IntelliJ IDEA提供了许多不同的选择

00:03:24.360 --> 00:03:28.370
可以帮助我们创建测试的代码完成类型。 

00:03:28.370 --> 00:03:32.270
默认情况下，键入时会提供各种选项，我们甚至不需要使用快捷方式

00:03:32.270 --> 00:03:34.591
提出建议。 

00:03:34.591 --> 00:03:39.060
建议不仅针对类型，甚至针对变量名称。 

00:03:39.060 --> 00:03:43.240
我们可以使用Ctrl和Space来提出建议，这使我们有了基本的完成。 

00:03:43.240 --> 00:03:44.290
这通常显示在当前位置可能起作用的各种可能性。 

00:03:44.290 --> 00:03:48.620
使用Shift Ctrl Space可以调用智能完成。 

00:03:48.620 --> 00:03:52.760
这是类型识别的，仅建议与上下文正确类型的选项。 

00:03:52.760 --> 00:03:57.310
在这种情况下，我们只能安装一种类型，因此IntelliJ IDEA会自动选择Square 

00:03:57.310 --> 00:03:59.389
为了我们。 

00:03:59.389 --> 00:04:01.090
键入一个点将弹出可用列表

00:04:01.090 --> 00:04:03.349
符号上的选项。 

00:04:03.349 --> 00:04:07.090
如果我们要在此类上创建一些新功能，则可以选择忽略

00:04:07.090 --> 00:04:10.510
在那里并定义我们的新方法名称。 

00:04:10.510 --> 00:04:14.930
编辑器将警告我们该方法不存在，但是如果我们按Alt并按Enter 

00:04:14.930 --> 00:04:19.080
红色方法，我们可以选择创建此丢失的方法。 

00:04:19.080 --> 00:04:23.310
 IntelliJ IDEA可以使用我们已经提供的信息来创建方法结构。 

00:04:23.310 --> 00:04:28.250
例如，此方法返回一个int，因为在测试中我们分配了调用结果

00:04:28.250 --> 00:04:30.400
此方法为int变量。 

00:04:30.400 --> 00:04:32.340
本着测试驱动开发的精神， 

00:04:32.340 --> 00:04:36.650
我们将其保留为最简单的编译方法，然后返回测试。 

00:04:36.650 --> 00:04:39.030
现在我们可以定义期望的结果。 

00:04:39.030 --> 00:04:43.240
请注意，IntelliJ IDEA的代码完成建议可以对部分方法名称起作用

00:04:43.240 --> 00:04:48.310
和骆驼的情况下，以最少的打字和最少的工作量，更轻松地找到我们所需的方法

00:04:48.310 --> 00:04:49.310
拼写错误的风险。 

00:04:49.310 --> 00:04:52.561
当我们运行测试时，我们看到它失败了，但是

00:04:52.561 --> 00:04:54.270
这是预期的。 

00:04:54.270 --> 00:05:00.080
让我们回到实现并进行最简单的更改以修复测试。 

00:05:00.080 --> 00:05:03.830
现在我们已经通过了测试，可以安全地重构代码。 

00:05:03.830 --> 00:05:08.840
例如，在这里我们可能想要将此硬编码的值移动到字段中。 

00:05:08.840 --> 00:05:14.560
我们可以在当前方法，字段声明中或在

00:05:14.560 --> 00:05:17.110
构造函数。 

00:05:17.110 --> 00:05:21.180
我们还可以使用Alt和Enter键来查看用于更改初始化位置的选项

00:05:21.180 --> 00:05:23.080
想要。 

00:05:23.080 --> 00:05:26.500
还有其他一些截屏视频可以更深入地进行重构，在这里我们已经看到了

00:05:26.500 --> 00:05:30.910
了解如何使用它来自动生成所需的代码。 

00:05:30.910 --> 00:05:32.710
我们可以使用重构来生成新文件

00:05:32.710 --> 00:05:34.630
对我们也一样。 

00:05:34.630 --> 00:05:38.620
例如，现在我们有了Square类，我们可能想创建一个Shape接口

00:05:38.620 --> 00:05:40.919
实施。 

00:05:40.919 --> 00:05:43.960
在这里，我使用“查找操作”来调用“提取接口”。 

00:05:43.960 --> 00:05:50.970
让我们创建一个名为Shape的接口，并向其中添加getNumberOfSides方法。 

00:05:50.970 --> 00:05:57.320
我们不会用Shape替换Square的当前用法，但是如果我们愿意，我们可以

00:05:57.320 --> 00:05:58.350
至。 

00:05:58.350 --> 00:06:02.800
我们可以看到，IntelliJ IDEA已经更新了Square以实现我们的新Shape接口，并且

00:06:02.800 --> 00:06:07.250
在OverNumber注释中添加了getNumberOfSides。 

00:06:07.250 --> 00:06:10.800
我们可以看到Shape界面很简单。 

00:06:10.800 --> 00:06:12.950
让我们创建一种新型的Shape。 

00:06:12.950 --> 00:06:17.560
这次，我们将在创建要测试的类之前先创建测试类。 

00:06:17.560 --> 00:06:23.180
同样，我们可以生成我们的测试方法，并对其进行适当的调用。 

00:06:23.180 --> 00:06:29.940
我们可以定义一个Shape局部变量，这一次我们希望它是一个新的类型Polygon。 

00:06:29.940 --> 00:06:35.280
 IntelliJ IDEA使我们可以使用Alt Enter创建此新类，并将其放入正确的位置。 

00:06:35.280 --> 00:06:37.600
目录。 

00:06:37.600 --> 00:06:41.600
因为我们在Shape变量中使用它，所以IntelliJ IDEA正确地假设我们想要这个

00:06:41.600 --> 00:06:44.480
多边形来实现我们的Shape接口。 

00:06:44.480 --> 00:06:48.930
编辑器显示错误，因为Polygon尚未实现Shape方法，我们

00:06:48.930 --> 00:06:53.949
可以再次使用Alt和Enter并选择“实施方法”来解决此问题。 

00:06:53.949 --> 00:06:58.669
与往常一样，我们可以接受最简单的编译实现以继续编写

00:06:58.669 --> 00:06:59.909
我们的测试。 

00:06:59.909 --> 00:07:03.220
在测试中，我们可以继续编码以创建

00:07:03.220 --> 00:07:07.479
我们想要的API，并使IntelliJ IDEA做出我们需要的更改。 

00:07:07.479 --> 00:07:12.630
 IDE可以为当前未使用的构造函数参数创建字段。 

00:07:12.630 --> 00:07:18.349
再次，现在代码可以编译，我们可以定义我们的测试期望…。 

00:07:18.349 --> 00:07:21.259
并重新运行测试。 

00:07:21.259 --> 00:07:27.990
当然它会失败，因此我们从方法中返回numberOfSides字段值并查看测试

00:07:27.990 --> 00:07:30.300
通过预期。 

00:07:30.300 --> 00:07:32.139
像这样的领域对象通常需要一些

00:07:32.139 --> 00:07:33.990
标准方法。 

00:07:33.990 --> 00:07:37.880
我们可以使IntelliJ IDEA为我们生成这些方法。 

00:07:37.880 --> 00:07:44.139
例如，我们可以生成一个toString方法，定义应包括哪些字段。 

00:07:44.139 --> 00:07:47.690
我们可以使用许多模板来创建方法，具体取决于哪个

00:07:47.690 --> 00:07:51.270
我们要选择的标准方法。 

00:07:51.270 --> 00:07:54.010
生成的方法通常放置在插入符号所在的位置。 

00:07:54.010 --> 00:07:58.300
让我们使用相同的过程来生成equals和hashCode方法。 

00:07:58.300 --> 00:08:03.190
同样，对于希望生成的方法起作用的方式，我们有一些选择。 

00:08:03.190 --> 00:08:08.050
我们可以选择在equals方法中包括哪些字段，以及在hashCode中使用哪些字段。 

00:08:08.050 --> 00:08:09.870
在类中使用这些方法时，以及

00:08:09.870 --> 00:08:14.380
即使生成这样的代码，对于Java程序员来说也是相当标准的，这可能会导致

00:08:14.380 --> 00:08:16.820
域对象中的噪音和混乱。 

00:08:16.820 --> 00:08:17.820
有时候，我们想要清楚地组织代码，以了解例如

00:08:17.820 --> 00:08:18.820
哪些是生成的方法，哪些是业务逻辑。 

00:08:18.820 --> 00:08:22.410
通过自动重新排列代码，我们可以将一致的组织应用于班级。 

00:08:22.410 --> 00:08:27.370
在这里，我将使用“查找动作”来搜索重新排列代码并将其应用于此

00:08:27.370 --> 00:08:28.850
类。 

00:08:28.850 --> 00:08:32.700
在这里，我们使用代码组织的默认设置，该默认设置用于放置构造函数

00:08:32.700 --> 00:08:37.450
在类的顶部，将所有内部类放在文件的底部，并将

00:08:37.450 --> 00:08:41.300
组织字段，例如将静态字段分组在一起。 

00:08:41.300 --> 00:08:43.019
我们可以更改现有设置以适合

00:08:43.019 --> 00:08:46.610
我们的需求，甚至添加我们自己的规则。 

00:08:46.610 --> 00:08:50.930
例如，我希望我的所有getter方法都位于可能包含的任何其他方法之下

00:08:50.930 --> 00:08:54.430
业务逻辑，因为获取者并不那么重要。 

00:08:54.430 --> 00:08:59.940
注意，我们可以使用正则表达式为方法名称定义模式。 

00:08:59.940 --> 00:09:04.221
比生成器更重要的是其他生成的方法，所以让我们创建一个

00:09:04.221 --> 00:09:08.100
将它们置于所有其他类型方法之下的规则。 

00:09:08.100 --> 00:09:12.990
现在，当我们重新排列代码时，将getter置于其他生成的方法之上。 

00:09:12.990 --> 00:09:15.310
现在我们有了基本的领域对象

00:09:15.310 --> 00:09:18.740
让我们创建更多的业务逻辑，看看代码生成和代码完成的方式

00:09:18.740 --> 00:09:21.160
在这里帮助我们。 

00:09:21.160 --> 00:09:23.060
我们继续使用测试来驱动设计

00:09:23.060 --> 00:09:25.200
 API。 

00:09:25.200 --> 00:09:29.830
对于此功能，有意义的是，我们将传递给Polygon构造函数一些

00:09:29.830 --> 00:09:36.940
包含多边形中所有边的长度的一种数组或集合。 

00:09:36.940 --> 00:09:39.959
在这里，我将使用后缀补全来定义变量。 

00:09:39.959 --> 00:09:45.651
 IntelliJ IDEA提供了一系列后缀完成选项来帮助生成通用代码，请按

00:09:45.651 --> 00:09:49.440
完成列表上的向上箭头可查看当前可用的所有

00:09:49.440 --> 00:09:50.470
上下文。 

00:09:50.470 --> 00:09:53.560
我们将使用var为该Polygon创建局部变量。 

00:09:53.560 --> 00:09:57.830
创建变量时，我们不必接受默认类型，可以按Shift键。 

00:09:57.830 --> 00:10:01.670
和Tab键将焦点放在类型上，并查看可用的选项。 

00:10:01.670 --> 00:10:05.620
对于此示例，我不想使用Shape接口定义它，而是使用Polygon定义它

00:10:05.620 --> 00:10:06.620
类本身。 

00:10:06.620 --> 00:10:10.339
此构造函数尚不存在，因此IntelliJ 

00:10:10.339 --> 00:10:15.010
 IDEA为我们提供了修改现有构造函数或创建另一个构造函数的选项

00:10:15.010 --> 00:10:16.560
构造函数。 

00:10:16.560 --> 00:10:20.880
如果选择修改现有的构造函数，则会看到“更改签名”对话框，其中

00:10:20.880 --> 00:10:23.680
让我们根据需要定制方法。 

00:10:23.680 --> 00:10:28.180
我们已经有一个使用现有构造函数的测试，因此现在我们将创建

00:10:28.180 --> 00:10:31.190
满足此测试需求的新构造函数。 

00:10:31.190 --> 00:10:32.500
我们以后总是可以重构。 

00:10:32.500 --> 00:10:35.260
我们应该同时使用两个参数

00:10:35.260 --> 00:10:37.490
到新的构造函数。 

00:10:37.490 --> 00:10:41.870
 IntelliJ IDEA识别出一个字段与第一个构造函数的名称匹配

00:10:41.870 --> 00:10:46.170
参数，因此我们可以获取它来生成代码以将该参数分配给正确的参数

00:10:46.170 --> 00:10:47.170
领域。 

00:10:47.170 --> 00:10:51.000
第二个参数还没有字段，因此我们将使用IntelliJ IDEA创建

00:10:51.000 --> 00:10:53.920
对我们来说。 

00:10:53.920 --> 00:10:57.690
我们已将其创建为最终字段，但尚未在该字段中初始化

00:10:57.690 --> 00:11:00.470
在原始的构造函数中。 

00:11:00.470 --> 00:11:04.950
我们将获得IntelliJ IDEA将该字段初始化为原始数组中的零长度数组

00:11:04.950 --> 00:11:06.130
构造函数。 

00:11:06.130 --> 00:11:08.519
现在代码已编译，我们可以继续

00:11:08.519 --> 00:11:12.010
编写测试的其余逻辑。 

00:11:12.010 --> 00:11:15.980
请注意，代码完成完全不需要我们输入太多，尤其是对于方法

00:11:15.980 --> 00:11:18.000
我们已经在这一堂课中打电话了。 

00:11:18.000 --> 00:11:22.709
同样，我们可以使用智能补全功能来建议返回兼容类型的方法

00:11:22.709 --> 00:11:27.899
使用此方法，但是我们还没有所需的方法，因此让我们在此定义它的名称

00:11:27.899 --> 00:11:31.360
测试并使用Alt和Enter再次创建。 

00:11:31.360 --> 00:11:35.640
现在，我们可以选择方法是属于接口还是实现

00:11:35.640 --> 00:11:39.980
我们将其放在实现上，因为现在我们只需要在Polygon上使用它，我们就可以重构

00:11:39.980 --> 00:11:42.830
如果需要的话，稍后再说。 

00:11:42.830 --> 00:11:47.629
再次，我们想选择最简单的代码，然后看到测试变成红色。 

00:11:47.629 --> 00:11:49.070
现在，我们将执行逻辑以使

00:11:49.070 --> 00:11:51.320
测试通过。 

00:11:51.320 --> 00:11:55.520
我们将要遍历sideLengths字段。 

00:11:55.520 --> 00:11:59.089
迭代是我们可以生成的标准代码的另一个示例。 

00:11:59.089 --> 00:12:04.360
例如，我们可以再次使用后缀完成，在这种情况下，迭代的密钥

00:12:04.360 --> 00:12:06.570
是“ iter”。 

00:12:06.570 --> 00:12:11.130
这将生成一个标准的foreach来遍历数组。 

00:12:11.130 --> 00:12:15.660
或者，有许多不同的实时模板可用于迭代。 

00:12:15.660 --> 00:12:20.720
我们可以选择“ itar”，它创建了一个经典的for循环来遍历数组。 

00:12:20.720 --> 00:12:24.740
或者我们可以使用“ iter”创建一个foreach循环。 

00:12:24.740 --> 00:12:27.210
我们将创建一个简单的检查来分配

00:12:27.210 --> 00:12:34.240
我们找到的最长值为局部变量的最长值。 

00:12:34.240 --> 00:12:38.540
我们可以使用快速修复程序在必要时使我们的代码编译。 

00:12:38.540 --> 00:12:42.889
现在我们有了业务逻辑，我们将重新运行测试以查看其是否通过。 

00:12:42.889 --> 00:12:45.279
现在我们已经通过了测试，我们可以重构

00:12:45.279 --> 00:12:49.389
我们的代码安全地知道我们可以始终运行测试以确保它仍然可以通过。 

00:12:49.389 --> 00:12:54.579
例如，我们可以使用Java 8检查来自动将此for循环转换为

00:12:54.579 --> 00:12:56.709
 Streams API调用。 

00:12:56.709 --> 00:13:01.470
重新运行测试表明，此结果与先前的代码相同。 

00:13:01.470 --> 00:13:03.730
我个人发现Streams通话更容易

00:13:03.730 --> 00:13:06.180
读取每个方法是否在单独的行上。 

00:13:06.180 --> 00:13:11.649
让我们选择此代码，然后使用Alt + Enter调整代码的格式。 

00:13:11.649 --> 00:13:15.980
此设置对话框仅显示适用于所选代码段的设置。 

00:13:15.980 --> 00:13:22.040
我们将选择“始终在链式方法调用上包装”，您可以看到编辑器预览

00:13:22.040 --> 00:13:26.040
格式更改无需我们保存。 

00:13:26.040 --> 00:13:28.920
如果我们对这些设置感到满意，可以选择“保存”。 

00:13:28.920 --> 00:13:30.660
现在以这种方式格式化代码，我可以

00:13:30.660 --> 00:13:32.830
更清楚地查看过滤条件。 

00:13:32.830 --> 00:13:37.430
我有一个理论，我们不需要此过滤器，因为仅max方法会给我们带来什么

00:13:37.430 --> 00:13:38.430
我们需要。 

00:13:38.430 --> 00:13:42.760
让我们删除此行，然后重新运行测试以确保所有功能仍然有效。 

00:13:42.760 --> 00:13:44.259
哪有！ 

00:13:44.259 --> 00:13:46.860
最后，让我们再次调用重新排列代码以

00:13:46.860 --> 00:13:50.889
确保新生成的方法在正确的位置。 

00:13:50.889 --> 00:13:52.820
我们已经使用了IntelliJ IDEA的代码生成

00:13:52.820 --> 00:13:56.870
创建标准的Java代码，因此我们不必键入有时引用的代码

00:13:56.870 --> 00:13:59.420
作为样板。 

00:13:59.420 --> 00:14:03.120
我们还使用了不同类型的代码完成功能来帮助我们编写代码

00:14:03.120 --> 00:14:07.740
需要，再次减少了所需的打字，使我们能够专注于实际问题

00:14:07.740 --> 00:14:08.890
我们正在努力解决。 

00:14:08.890 --> 00:14:10.630
感谢收看！ 

