WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.030 --> 00:00:05.220
好吧，这是幻灯片，这是

00:00:02.850 --> 00:00:06.870
我说的就是这个

00:00:05.220 --> 00:00:10.740
我们想要我们想炮制您的

00:00:06.870 --> 00:00:16.500
正确的外套，这是两个

00:00:10.740 --> 00:00:22.260
我现在只想要你的游戏

00:00:16.500 --> 00:00:24.570
真的想呈现的是Rx而不是

00:00:22.260 --> 00:00:27.990
你知道你是否真的想

00:00:24.570 --> 00:00:30.840
写完整的游戏有很多事情

00:00:27.990 --> 00:00:33.899
这是非常规范的，所以我已经

00:00:30.840 --> 00:00:37.260
保持游戏超级简单突出

00:00:33.899 --> 00:00:40.140
有关方面，如果我们看看

00:00:37.260 --> 00:00:42.780
您在其中看到的游戏的源代码

00:00:40.140 --> 00:00:44.550
 Ellijay和一秒钟前

00:00:42.780 --> 00:00:47.579
但是这些游戏的源代码

00:00:44.550 --> 00:00:51.840
真的好像最多两个屏幕都满了

00:00:47.579 --> 00:00:54.120
这样的代码以及蛇和书

00:00:51.840 --> 00:00:57.420
你看到蛇有一点

00:00:54.120 --> 00:01:01.079
更长的线条，但是一切都超级简单

00:00:57.420 --> 00:01:04.170
代码，所以即使你知道我的

00:01:01.079 --> 00:01:06.990
六岁的儿子能够写游戏

00:01:04.170 --> 00:01:11.840
像这样使用RX，他有一个

00:01:06.990 --> 00:01:16.890
为了给它带来很多乐趣

00:01:11.840 --> 00:01:20.340
现在的RX我想先谈一点

00:01:16.890 --> 00:01:25.040
关于使用M编程的一点知识

00:01:20.340 --> 00:01:29.430
集合或Java的新说法

00:01:25.040 --> 00:01:32.310
使用流进行编程，因为如果您

00:01:29.430 --> 00:01:34.790
看这个游戏，它对

00:01:32.310 --> 00:01:38.850
键盘和鼠标是

00:01:34.790 --> 00:01:41.759
事物的序列及其变化

00:01:38.850 --> 00:01:45.780
将它们分为其他顺序即更新

00:01:41.759 --> 00:01:48.030
到屏幕上，就像我一样真正的游戏

00:01:45.780 --> 00:01:50.970
今天提出的可以看作是

00:01:48.030 --> 00:01:54.180
从流向其他的转化

00:01:50.970 --> 00:01:57.719
流，然后你知道这些

00:01:54.180 --> 00:02:01.619
产生的流在

00:01:57.719 --> 00:02:03.600
屏幕，所以第一件事

00:02:01.619 --> 00:02:07.049
要了解Rx，我们必须

00:02:03.600 --> 00:02:12.420
非常深刻地了解什么流

00:02:07.049 --> 00:02:14.420
所以如果我们去那里看看Java 

00:02:12.420 --> 00:02:18.120
看到有一天

00:02:14.420 --> 00:02:20.490
在这里看到它的界面

00:02:18.120 --> 00:02:23.520
许多实现该目标的类型

00:02:20.490 --> 00:02:26.850
接口，该接口称为

00:02:23.520 --> 00:02:32.060
 E的间隔间隔，我称之为

00:02:26.850 --> 00:02:36.090
 Java 8和

00:02:32.060 --> 00:02:38.930
所有流的母亲一直

00:02:36.090 --> 00:02:42.890
换成新介面， 

00:02:38.930 --> 00:02:47.460
接口称为T流，现在

00:02:42.890 --> 00:02:50.550
 T的这个接口流实际上是

00:02:47.460 --> 00:02:53.150
非常有趣，让我们花点时间

00:02:50.550 --> 00:02:56.580
看看它，所以如果您看一下Java 8 

00:02:53.150 --> 00:02:59.190
 T的文档流定义为

00:02:56.580 --> 00:03:02.900
跟随我们T的梦想

00:02:59.190 --> 00:03:07.440
接口，这很有趣

00:03:02.900 --> 00:03:11.550
继承自T和stream的流

00:03:07.440 --> 00:03:14.700
 T，如果我们看一下T的湾流

00:03:11.550 --> 00:03:17.190
然后我们看到那是一个通用类型

00:03:14.700 --> 00:03:21.330
有两个参数，第二个

00:03:17.190 --> 00:03:25.830
参数在一定程度上受到限制

00:03:21.330 --> 00:03:27.960
现在基于T和s的流

00:03:25.830 --> 00:03:32.490
不了解你，但在这一点上

00:03:27.960 --> 00:03:35.040
我的脑袋飞满了，因为

00:03:32.490 --> 00:03:38.070
如果您展开此类型，您将

00:03:35.040 --> 00:03:40.620
看到它最终进入基本流

00:03:38.070 --> 00:03:45.000
基本3的基本流的基本流

00:03:40.620 --> 00:03:48.420
大约是T，现在一直下降

00:03:45.000 --> 00:03:51.180
我不认识你，但与

00:03:48.420 --> 00:03:55.440
这就是我们今天要做的一切

00:03:51.180 --> 00:03:58.440
太真实了，所以不要担心你

00:03:55.440 --> 00:04:01.890
知道您可以处理Java 8并且可以

00:03:58.440 --> 00:04:04.830
处理T之类的类型以及

00:04:01.890 --> 00:04:10.220
每个jabber程序员都应该

00:04:04.830 --> 00:04:16.200
了解您对rx没问题

00:04:10.220 --> 00:04:19.230
现在，当我说那条小溪取代了

00:04:16.200 --> 00:04:23.070
 TI的间隔认为有一点

00:04:19.230 --> 00:04:26.250
 Java 8中的一点拒绝，因为如果您

00:04:23.070 --> 00:04:27.060
看一下基本流的方法

00:04:26.250 --> 00:04:31.350
看到

00:04:27.060 --> 00:04:35.730
有一个返回的迭代器和方法

00:04:31.350 --> 00:04:38.550
一个迭代器，所以实际上是基本流

00:04:35.730 --> 00:04:42.090
一个间隔，除了Java 8和

00:04:38.550 --> 00:04:45.030
不是像那样被提及

00:04:42.090 --> 00:04:48.720
确实如此，所以我认为Java 

00:04:45.030 --> 00:04:53.370
 8否认它确实支持

00:04:48.720 --> 00:04:57.510
所有联系的母亲，现在

00:04:53.370 --> 00:05:02.300
为什么Java 8拥有良好的流

00:04:57.510 --> 00:05:05.910
因为我们要对

00:05:02.300 --> 00:05:13.229
这些集合，所以这是例子

00:05:05.910 --> 00:05:15.600
取自Java 8文档，因此

00:05:13.229 --> 00:05:17.850
它的作用是说给定一些

00:05:15.600 --> 00:05:20.940
小部件集合将其转换为

00:05:17.850 --> 00:05:23.850
流，这是我首先完成的

00:05:20.940 --> 00:05:26.820
呼叫，然后我们过滤掉所有

00:05:23.850 --> 00:05:32.460
红色的小部件，然后您知道

00:05:26.820 --> 00:05:36.180
我们将所有小部件映射到它们的权重

00:05:32.460 --> 00:05:39.240
然后我们对结果求和，所以在这里

00:05:36.180 --> 00:05:41.880
看到那种典型的转变

00:05:39.240 --> 00:05:44.870
集合到其他集合

00:05:41.880 --> 00:05:50.130
使用过滤折叠映射

00:05:44.870 --> 00:05:52.410
聚集，无论您想要什么，但我

00:05:50.130 --> 00:05:55.650
想指出一个有趣的地方

00:05:52.410 --> 00:06:00.320
 Java 8中的哲学评论

00:05:55.650 --> 00:06:03.090
文档，那就是

00:06:00.320 --> 00:06:07.680
他们区分流

00:06:03.090 --> 00:06:11.840
而且收集是字符串不

00:06:07.680 --> 00:06:15.240
提供访问和操纵的方式

00:06:11.840 --> 00:06:18.510
集合流的元素

00:06:15.240 --> 00:06:21.660
这意味着如果你看

00:06:18.510 --> 00:06:26.820
在像哈希表和

00:06:21.660 --> 00:06:30.090
数组列表等等，这些都有

00:06:26.820 --> 00:06:33.870
您可以直接索引的操作

00:06:30.090 --> 00:06:36.599
进入集合，然后将

00:06:33.870 --> 00:06:38.130
值，而只有流

00:06:36.599 --> 00:06:40.340
你可以做的事就是你可以列举

00:06:38.130 --> 00:06:42.530
价值观，你可以做

00:06:40.340 --> 00:06:46.490
用它可以产生一个

00:06:42.530 --> 00:06:50.930
新的和连接，所以这是一个非常

00:06:46.490 --> 00:06:55.630
提到的重要区别

00:06:50.930 --> 00:07:01.639
在这里，你知道线之间，但

00:06:55.630 --> 00:07:05.810
是的，我认为很重要

00:07:01.639 --> 00:07:09.190
与旧世界相比发生了很大的变化

00:07:05.810 --> 00:07:12.260
会对命令式进行突变

00:07:09.190 --> 00:07:14.270
集合到新世界，再到更多

00:07:12.260 --> 00:07:17.330
面向函数式编程的工作

00:07:14.270 --> 00:07:20.240
我们将要知道的世界

00:07:17.330 --> 00:07:26.840
对集合进行操作

00:07:20.240 --> 00:07:29.300
创建新收藏好，这是一个

00:07:26.840 --> 00:07:33.160
我们在这里所做的操作

00:07:29.300 --> 00:07:37.070
这个小例子过滤器，如果你

00:07:33.160 --> 00:07:40.880
画出您所看到的滤镜图片

00:07:37.070 --> 00:07:43.520
是它需要一个收集

00:07:40.880 --> 00:07:46.550
在这里，这里我们有一个收藏

00:07:43.520 --> 00:07:51.650
然后我们过滤掉所有的值

00:07:46.550 --> 00:07:53.960
在圈子里，你看到的是

00:07:51.650 --> 00:07:58.340
你知道有一个新的收藏

00:07:53.960 --> 00:08:00.530
现在只包含圈子，再一次

00:07:58.340 --> 00:08:03.169
没什么关系

00:08:00.530 --> 00:08:06.139
我应该称其为基础的是

00:08:03.169 --> 00:08:08.510
当然，因为它真的

00:08:06.139 --> 00:08:11.539
无关紧要的是什么

00:08:08.510 --> 00:08:15.289
集合是一个哈希表

00:08:11.539 --> 00:08:17.660
或列表，但我们唯一

00:08:15.289 --> 00:08:20.479
我们关心的是

00:08:17.660 --> 00:08:24.169
基础集合表示为

00:08:20.479 --> 00:08:26.780
流，然后过滤掉较旧的

00:08:24.169 --> 00:08:29.360
圈子，然后我们得到了一个新的流

00:08:26.780 --> 00:08:32.089
只包含圆圈，然后我们

00:08:29.360 --> 00:08:36.610
可以为此添加其他操作

00:08:32.089 --> 00:08:41.060
真正的流编程既涉及

00:08:36.610 --> 00:08:44.420
价值梦想的转变和

00:08:41.060 --> 00:08:47.150
如果你知道续集的话

00:08:44.420 --> 00:08:52.610
数据库人员拥有的东西

00:08:47.150 --> 00:08:54.110
自70年代初开始就在这里

00:08:52.610 --> 00:08:58.490
另一个操作

00:08:54.110 --> 00:09:02.410
嗯，梦想和甲烷，所以绘制

00:08:58.490 --> 00:09:07.220
在这种情况下需要一个流

00:09:02.410 --> 00:09:09.709
圆圈，然后生成另一个

00:09:07.220 --> 00:09:12.589
流，在这种情况下是

00:09:09.709 --> 00:09:16.310
钻石及其操作方式是

00:09:12.589 --> 00:09:18.829
采取转圈的功能

00:09:16.310 --> 00:09:21.350
成钻石，这是这里

00:09:18.829 --> 00:09:24.370
你看到不同的没有编程

00:09:21.350 --> 00:09:28.070
流的性质，用于编程和

00:09:24.370 --> 00:09:30.920
进来是为了转移一个

00:09:28.070 --> 00:09:33.470
字符串到另一个，你必须传递一个

00:09:30.920 --> 00:09:35.589
对每个元素起作用的功能

00:09:33.470 --> 00:09:38.720
您指定如何更改

00:09:35.589 --> 00:09:41.690
泰克尔变成钻石，然后你做

00:09:38.720 --> 00:09:46.190
那一个功能超过三

00:09:41.690 --> 00:09:50.810
将其转换为另一个流

00:09:46.190 --> 00:09:54.790
小例子，我们也看到了操作

00:09:50.810 --> 00:09:58.760
有一些需要一些

00:09:54.790 --> 00:10:03.500
数字值，然后返回

00:09:58.760 --> 00:10:06.649
字符串或值，并且包含此内容

00:10:03.500 --> 00:10:09.829
代表

00:10:06.649 --> 00:10:12.079
现在流，这是一个问题，你知道如何

00:10:09.829 --> 00:10:14.300
你代表一个结果吗

00:10:12.079 --> 00:10:18.579
像一些操作和聚合一样

00:10:14.300 --> 00:10:21.320
一些，如果你在这里看

00:10:18.579 --> 00:10:25.480
原来的例子，你看到一些

00:10:21.320 --> 00:10:28.730
返回一个整数，但实际上不是

00:10:25.480 --> 00:10:32.570
唯一可能的选择

00:10:28.730 --> 00:10:34.850
何时有更多面向数据库的视图

00:10:32.570 --> 00:10:38.300
你做一个集合的集合是

00:10:34.850 --> 00:10:41.690
减少到另一个收藏

00:10:38.300 --> 00:10:47.990
仅包含一个元素

00:10:41.690 --> 00:10:50.480
该集合及其的汇总

00:10:47.990 --> 00:10:51.949
那种价格真的

00:10:50.480 --> 00:10:54.500
没关系，所以我们会有点

00:10:51.949 --> 00:10:56.810
稍微想一下，但再次在这里

00:10:54.500 --> 00:10:59.420
看到这张照片，它不是真的

00:10:56.810 --> 00:11:02.029
再有问题，这三个

00:10:59.420 --> 00:11:04.610
源自我们唯一的事物

00:11:02.029 --> 00:11:07.600
是说我们要对所有

00:11:04.610 --> 00:11:10.930
元素，最后我们得到

00:11:07.600 --> 00:11:14.889
一个元素，是所有元素的总和

00:11:10.930 --> 00:11:21.370
原始流中的元素和

00:11:14.889 --> 00:11:25.750
这确实是最重要的信息

00:11:21.370 --> 00:11:30.850
今天是我们必须开始思考

00:11:25.750 --> 00:11:33.279
流的术语，所以那些就是你

00:11:30.850 --> 00:11:37.060
知道你在哪里值序列

00:11:33.279 --> 00:11:39.370
你不知道访问任何底层

00:11:37.060 --> 00:11:43.959
数据结构唯一可以做的

00:11:39.370 --> 00:11:47.470
是D值吗？ 

00:11:43.959 --> 00:11:50.350
一个你甚至不认识的人，然后你

00:11:47.470 --> 00:11:52.720
将这些流转化为其他流

00:11:50.350 --> 00:11:56.800
通过高阶流

00:11:52.720 --> 00:11:59.170
功能，当我设置为不

00:11:56.800 --> 00:12:02.440
甚至知道你得到这些价值观之一

00:11:59.170 --> 00:12:05.319
一个是因为如果您像

00:12:02.440 --> 00:12:08.769
我们在这里看到的以及潜在的

00:12:05.319 --> 00:12:11.259
地图的限制实际上可能会运行

00:12:08.769 --> 00:12:14.439
您传递的许多Map函数

00:12:11.259 --> 00:12:17.560
如果有的话，在这里并行

00:12:14.439 --> 00:12:21.459
听说过Hadoop或MapReduce 

00:12:17.560 --> 00:12:25.269
到底发生了什么事

00:12:21.459 --> 00:12:29.050
大量处理的抽象

00:12:25.269 --> 00:12:31.689
流以有效地实现

00:12:29.050 --> 00:12:33.939
一大堆机器和

00:12:31.689 --> 00:12:38.410
再次把戏是你抽象了

00:12:33.939 --> 00:12:41.439
和Lurline的任何特性

00:12:38.410 --> 00:12:45.189
集合，因为如果您假设

00:12:41.439 --> 00:12:49.019
你可以很好地索引到数组中

00:12:45.189 --> 00:12:51.670
运气不好的时候

00:12:49.019 --> 00:12:54.459
将该阵列分布在

00:12:51.670 --> 00:12:56.050
机器和索引肯定会

00:12:54.459 --> 00:12:58.810
不再是固定的时间

00:12:56.050 --> 00:13:02.410
好的，所以实际上是通过限制

00:12:58.810 --> 00:13:04.600
自己到一个更简单的界面

00:13:02.410 --> 00:13:07.300
可迭代接口或流接口

00:13:04.600 --> 00:13:11.579
在这种情况下，您将获得更多动力， 

00:13:07.300 --> 00:13:15.100
在编程中通常是这样

00:13:11.579 --> 00:13:18.639
减少假设，我们可以做很多事情

00:13:15.100 --> 00:13:21.180
从某种意义上讲，我们要回去

00:13:18.639 --> 00:13:23.910
基本的东西，所以扔掉所有这些

00:13:21.180 --> 00:13:27.480
巴洛克式的亚洲结构与各种

00:13:23.910 --> 00:13:29.310
特例和高效运营

00:13:27.480 --> 00:13:32.280
如果我们去提高效率

00:13:29.310 --> 00:13:34.410
我们抛弃许多许多不同的方式

00:13:32.280 --> 00:13:42.630
操作和工作超级简单

00:13:34.410 --> 00:13:48.380
到处都是数据结构或流

00:13:42.630 --> 00:13:51.810
并不是真正的新订单，因为

00:13:48.380 --> 00:13:55.230
如果你看看数学家有什么

00:13:51.810 --> 00:13:59.270
完成，他们一直在与

00:13:55.230 --> 00:14:04.820
设置或收集很长时间

00:13:59.270 --> 00:14:08.160
我们的基本定理之一

00:14:04.820 --> 00:14:11.460
道德公理是选择的公理

00:14:08.160 --> 00:14:14.610
一种看待公理的方法

00:14:11.460 --> 00:14:17.610
选择说数学集是

00:14:14.610 --> 00:14:20.690
迭代，所以它是真的，但是你知道

00:14:17.610 --> 00:14:23.670
我们只是在跟随

00:14:20.690 --> 00:14:26.670
你知道像你这样的超级聪明人

00:14:23.670 --> 00:14:30.150
在这里知道相当随机数或Melo 

00:14:26.670 --> 00:14:34.310
图片，只是为了提醒您

00:14:30.150 --> 00:14:37.980
接口再次具有间隔

00:14:34.310 --> 00:14:41.610
一种方法迭代器

00:14:37.980 --> 00:14:44.340
迭代器，并且可以选择

00:14:41.610 --> 00:14:46.710
就像您知道的航空邮件一样

00:14:44.340 --> 00:14:50.100
说，那是下一个功能，所以你

00:14:46.710 --> 00:14:53.640
可以反复要求下一个

00:14:50.100 --> 00:14:56.400
在此流中作用下一个值

00:14:53.640 --> 00:14:59.580
这就是字符串所能做的一切

00:14:56.400 --> 00:15:02.970
因此，再次将自己限制为

00:14:59.580 --> 00:15:07.370
超级简单的界面，当然我们可以

00:15:02.970 --> 00:15:11.330
做奇妙的事情，并结合

00:15:07.370 --> 00:15:17.850
如此简单的高阶函数

00:15:11.330 --> 00:15:20.370
现在是功能强大的收藏之一

00:15:17.850 --> 00:15:24.120
流或在这种情况下

00:15:20.370 --> 00:15:28.290
间隔是没有必要

00:15:24.120 --> 00:15:32.970
必须是一个基础集合

00:15:28.290 --> 00:15:35.089
备份间隔，例如

00:15:32.970 --> 00:15:37.399
我在这里创建

00:15:35.089 --> 00:15:39.800
生成流的简单程序

00:15:37.399 --> 00:15:42.559
你在这里看到随机数，所以我

00:15:39.800 --> 00:15:44.930
创建一个随机数流

00:15:42.559 --> 00:15:47.600
然后我将它们打印出来， 

00:15:44.930 --> 00:15:49.759
实现这个使用间隔，但是你

00:15:47.600 --> 00:15:53.120
看到没有收藏，只有

00:15:49.759 --> 00:15:57.110
就像这是一个状态

00:15:53.120 --> 00:16:00.050
随机数生成器和

00:15:57.110 --> 00:16:03.050
休息那里没有收藏好吗

00:16:00.050 --> 00:16:06.160
树中流元素仅存在

00:16:03.050 --> 00:16:12.189
当你问下一个

00:16:06.160 --> 00:16:16.490
元素，然后它们消失了，如果我们

00:16:12.189 --> 00:16:18.980
采取更哲学的方法

00:16:16.490 --> 00:16:22.160
流是真的，当你

00:16:18.980 --> 00:16:24.829
做编程时你必须专注于

00:16:22.160 --> 00:16:27.499
现在你现在必须集中精力

00:16:24.829 --> 00:16:30.620
没有过去就没有未来

00:16:27.499 --> 00:16:33.740
唯一可以保留在自己的东西

00:16:30.620 --> 00:16:37.389
手是当前的元素

00:16:33.740 --> 00:16:40.610
流，这正是

00:16:37.389 --> 00:16:43.040
可迭代的界面让您拥有

00:16:40.610 --> 00:16:46.399
当前值就是这样

00:16:43.040 --> 00:16:49.100
不知道这是否有间隔

00:16:46.399 --> 00:16:52.309
你知道记得过去，你拥有

00:16:49.100 --> 00:16:54.949
无法知道未来的发展

00:16:52.309 --> 00:16:59.569
间隔，你可以假设的唯一

00:16:54.949 --> 00:17:03.579
是现在，所以这将会

00:16:59.569 --> 00:17:09.399
做我们必须进入的心态

00:17:03.579 --> 00:17:13.610
现在好了，我们已经看到了几个

00:17:09.399 --> 00:17:16.579
流我们已经被哲学抛弃

00:17:13.610 --> 00:17:20.240
关于流，让我们开始寻找

00:17:16.579 --> 00:17:25.010
流无处不在，所以这是一个

00:17:20.240 --> 00:17:27.890
流，当我移动鼠标时，我得到

00:17:25.010 --> 00:17:30.409
鼠标位置流

00:17:27.890 --> 00:17:32.750
有鼠标总是在

00:17:30.409 --> 00:17:34.340
单位置，鼠标不

00:17:32.750 --> 00:17:37.460
记得在哪里

00:17:34.340 --> 00:17:39.620
五个位置之前，鼠标没有

00:17:37.460 --> 00:17:41.929
知道会在哪里，你知道五个

00:17:39.620 --> 00:17:45.530
从现在起的几秒钟内

00:17:41.929 --> 00:17:48.630
鼠标知道这是当前的

00:17:45.530 --> 00:17:52.799
现在的位置

00:17:48.630 --> 00:17:56.520
让我们看看另一个流，它是

00:17:52.799 --> 00:18:00.390
这种股票价格流

00:17:56.520 --> 00:18:02.940
是当前的股价，你知道

00:18:00.390 --> 00:18:04.740
可能有库存历史

00:18:02.940 --> 00:18:07.530
价格，但您必须明确保持

00:18:04.740 --> 00:18:10.590
那，但是你绝对不知道

00:18:07.530 --> 00:18:13.620
未来将摆脱股票符号

00:18:10.590 --> 00:18:17.220
好吧，那么唯一可以做的就是

00:18:13.620 --> 00:18:19.860
真正要做的是有点专注于现在

00:18:17.220 --> 00:18:21.750
当前的股价是多少，然后

00:18:19.860 --> 00:18:23.940
您将被告知下一个是什么

00:18:21.750 --> 00:18:26.220
但您必须知道

00:18:23.940 --> 00:18:33.299
您手中只有的是

00:18:26.220 --> 00:18:36.360
您现在的当前股价

00:18:33.299 --> 00:18:41.580
有孩子，你会超级熟悉

00:18:36.360 --> 00:18:45.419
与另一股流

00:18:41.580 --> 00:18:50.850
尖叫，他们也是，没有

00:18:45.419 --> 00:18:54.690
您知道并可以控制的方式

00:18:50.850 --> 00:18:59.070
你的宝宝，它会尖叫，它会

00:18:54.690 --> 00:19:01.860
有点公正，并发出一连串的

00:18:59.070 --> 00:19:05.820
婴儿不开心时尖叫

00:19:01.860 --> 00:19:08.850
好吧，再次像其中之一

00:19:05.820 --> 00:19:12.419
具有当前状态的流

00:19:08.850 --> 00:19:14.370
和婴儿，然后下一秒钟

00:19:12.419 --> 00:19:17.250
他们突然可能会微笑，然后他们

00:19:14.370 --> 00:19:22.559
再哭一次，很难

00:19:17.250 --> 00:19:26.610
你知道预测他们的行为方式

00:19:22.559 --> 00:19:29.640
嗯，我们已经看到了两种截然不同的类型

00:19:26.610 --> 00:19:32.280
流的第一个字符串

00:19:29.640 --> 00:19:35.010
溪流是梦

00:19:32.280 --> 00:19:37.980
当你问的时候你只会获得价值

00:19:35.010 --> 00:19:39.870
为此，这就像一个抽水机

00:19:37.980 --> 00:19:42.390
你要去抽油的地方

00:19:39.870 --> 00:19:46.380
只有当你抽水时，你才能得到

00:19:42.390 --> 00:19:50.600
一些油，然后第二种

00:19:46.380 --> 00:19:53.909
我们看到的流是

00:19:50.600 --> 00:19:56.340
是否会给您价值

00:19:53.909 --> 00:19:59.120
是否可以处理它们

00:19:56.340 --> 00:20:02.250
他们不会只是炸毁

00:19:59.120 --> 00:20:06.710
通知你某事

00:20:02.250 --> 00:20:09.720
已经发生了，所以让我们看一下

00:20:06.710 --> 00:20:12.120
接口第二种流，并

00:20:09.720 --> 00:20:16.200
我们称这些可观察的流

00:20:12.120 --> 00:20:19.920
夜间流是我们X的核心

00:20:16.200 --> 00:20:22.950
所以什么是可观察的流

00:20:19.920 --> 00:20:25.740
也在两个接口之外，所以

00:20:22.950 --> 00:20:28.530
第一个是可观察到的T 

00:20:25.740 --> 00:20:30.560
一种您订阅的方法

00:20:28.530 --> 00:20:34.890
一个观察者，然后一个观察者是

00:20:30.560 --> 00:20:39.660
真的三个回调将是

00:20:34.890 --> 00:20:41.420
每当事件发生时调用

00:20:39.660 --> 00:20:48.900
基础实施

00:20:41.420 --> 00:20:52.080
可观察到的，所以这里的检查员是

00:20:48.900 --> 00:20:54.660
你知道你给一个事件处理程序

00:20:52.080 --> 00:20:59.160
这个东西，只要有

00:20:54.660 --> 00:21:01.680
有趣的事件发生

00:20:59.160 --> 00:21:03.870
是否可以调用回调

00:21:01.680 --> 00:21:07.290
是否要处理它，但是

00:21:03.870 --> 00:21:09.810
将回调注册到

00:21:07.290 --> 00:21:12.000
一个可观察的集合

00:21:09.810 --> 00:21:15.210
就像婴儿一样被拉

00:21:12.000 --> 00:21:19.530
一旦你有了孩子，它将是

00:21:15.210 --> 00:21:21.270
打电话给你，任何时候都不会

00:21:19.530 --> 00:21:26.840
不管是白天还是晚上

00:21:21.270 --> 00:21:30.930
你在睡觉，你必须知道

00:21:26.840 --> 00:21:35.790
现在让我们说再次在这里显示一些代码

00:21:30.930 --> 00:21:38.850
是同一流的一个例子

00:21:35.790 --> 00:21:41.010
现在可以观察到随机数

00:21:38.850 --> 00:21:44.400
你再次在这里看到的，我只有一个

00:21:41.010 --> 00:21:47.280
单件状态随机然后我

00:21:44.400 --> 00:21:50.400
只是不断推出一个随机数

00:21:47.280 --> 00:21:52.680
然后在这里我拿前五个

00:21:50.400 --> 00:21:55.940
打印出来，所以你看到这是

00:21:52.680 --> 00:21:58.350
表现与原始影片相同

00:21:55.940 --> 00:22:01.140
我随机创建的可迭代流

00:21:58.350 --> 00:22:03.870
数字，但在这种情况下，您

00:22:01.140 --> 00:22:08.820
不要求值，但要交付

00:22:03.870 --> 00:22:11.070
在你身上又一次在这些

00:22:08.820 --> 00:22:14.370
流无关紧要，我们可以做到

00:22:11.070 --> 00:22:15.809
相同的批量操作，例如地图过滤器

00:22:14.370 --> 00:22:21.389
故障

00:22:15.809 --> 00:22:28.440
等等，所以你再次过滤，你看到并让

00:22:21.389 --> 00:22:31.499
我重新强调这件事，如果

00:22:28.440 --> 00:22:34.169
价值之流在你身边飞扬

00:22:31.499 --> 00:22:35.849
您可以过滤掉所有圈子， 

00:22:34.169 --> 00:22:39.749
然后你会得到一个新的流，这将

00:22:35.849 --> 00:22:43.440
在下一个操作上飞

00:22:39.749 --> 00:22:47.279
如果看到

00:22:43.440 --> 00:22:49.320
和的层在

00:22:47.279 --> 00:22:51.979
将圈子转换成

00:22:49.320 --> 00:22:59.879
钻石，您会获得新的流

00:22:51.979 --> 00:23:04.469
只包含优质钻石，所以现在和

00:22:59.879 --> 00:23:08.279
我们正在接近实际游戏

00:23:04.469 --> 00:23:13.320
还有我想要的另一件事

00:23:08.279 --> 00:23:16.349
去谈论是最佳收藏

00:23:13.320 --> 00:23:21.539
如果您是Java程序员，而您

00:23:16.349 --> 00:23:23.460
例如用过X罐子

00:23:21.539 --> 00:23:26.609
注意到那里有人在说话

00:23:23.460 --> 00:23:29.729
关于观察两次选举，如果你是

00:23:26.609 --> 00:23:34.950
一个dotnet程序员，您正在使用

00:23:29.729 --> 00:23:37.649
 Zemel或类似的工作，您将

00:23:34.950 --> 00:23:40.259
也听到人们谈论可观察的

00:23:37.649 --> 00:23:42.979
 JavaScript中的集合有

00:23:40.259 --> 00:23:45.719
数百种数据绑定框架

00:23:42.979 --> 00:23:48.330
都有可观察的框架

00:23:45.719 --> 00:23:52.289
集合和通知等

00:23:48.330 --> 00:23:55.649
那两者之间是什么关系

00:23:52.289 --> 00:24:00.960
 RX可观察物和这些可观察物

00:23:55.649 --> 00:24:04.979
集合，以及连接是

00:24:00.960 --> 00:24:07.649
其实很近，这是

00:24:04.979 --> 00:24:10.139
图片，所以如果你看这张图片

00:24:07.649 --> 00:24:14.159
在这里，您可以看到

00:24:10.139 --> 00:24:16.679
收藏是一个具体的收藏

00:24:14.159 --> 00:24:20.759
 Java 8的意义，所以它不是

00:24:16.679 --> 00:24:23.369
流这是一个集合，它具有一组

00:24:20.759 --> 00:24:27.109
特别是它上的运算符

00:24:23.369 --> 00:24:29.130
改变这些可观察的集合，并

00:24:27.109 --> 00:24:32.870
每当木台

00:24:29.130 --> 00:24:36.390
他们将通知您更改

00:24:32.870 --> 00:24:38.340
对，先生，这是你的观察

00:24:36.390 --> 00:24:41.310
这些是三个特定的集合

00:24:38.340 --> 00:24:43.830
具有变异的数据结构

00:24:41.310 --> 00:24:46.890
在它们以及任何时候定义的操作

00:24:43.830 --> 00:24:51.840
你在可观察的地方做突变

00:24:46.890 --> 00:24:54.720
收藏它将通知您和

00:24:51.840 --> 00:24:57.770
变化，这就是直接

00:24:54.720 --> 00:25:01.230
我们的X观测值与

00:24:57.770 --> 00:25:04.350
现在可以观察到的收藏集

00:25:01.230 --> 00:25:06.270
也可以看一下

00:25:04.350 --> 00:25:08.970
可观察的实际值

00:25:06.270 --> 00:25:12.410
极端或间隔收集

00:25:08.970 --> 00:25:16.050
并通过列举它们来

00:25:12.410 --> 00:25:21.810
而可观察的部分是

00:25:16.050 --> 00:25:25.380
关于通知您更改，好吧airp 

00:25:21.810 --> 00:25:27.630
是的，嗨，我们可以问两个吗

00:25:25.380 --> 00:25:31.380
问题，因为我认为两者都有

00:25:27.630 --> 00:25:33.510
嗯，其中之一就是这样问你

00:25:31.380 --> 00:25:36.870
有机制可以坚持

00:25:33.510 --> 00:25:38.940
价值流，以便我们可以

00:25:36.870 --> 00:25:45.120
回复例如订户

00:25:38.940 --> 00:25:48.930
倒了，是的，绝对可以，所以让

00:25:45.120 --> 00:25:51.420
我再次出现，看我是否可以得到

00:25:48.930 --> 00:25:55.880
如果你让我第二，这可以工作

00:25:51.420 --> 00:26:00.860
因为我的屏幕列表，您看到了

00:25:55.880 --> 00:26:04.830
我们看到纸张显示还可以，所以

00:26:00.860 --> 00:26:08.280
让我们尝试输入酌处权

00:26:04.830 --> 00:26:11.730
说我们有一系列价值

00:26:08.280 --> 00:26:18.290
这个，我称他们不能弹大理石

00:26:11.730 --> 00:26:21.990
图，现在，这是时间

00:26:18.290 --> 00:26:25.380
现在就像我说的，如果你看这件事

00:26:21.990 --> 00:26:28.470
作为流，如果时间在这里

00:26:25.380 --> 00:26:31.140
在此之前发生的值将是

00:26:28.470 --> 00:26:33.240
迷失了，因为你知道时间

00:26:31.140 --> 00:26:37.650
继续前进，所以接下来会有

00:26:33.240 --> 00:26:42.419
值，如果您在此处加入信息流

00:26:37.650 --> 00:26:45.179
您将在此处看不到任何值

00:26:42.419 --> 00:26:49.489
当然还有其他运营商

00:26:45.179 --> 00:26:54.859
你知道你能做的就是

00:26:49.489 --> 00:26:59.009
记住那些价值观，现在当你

00:26:54.859 --> 00:27:02.190
将在这里加入流，它将给

00:26:59.009 --> 00:27:06.179
您发生的这三个价值

00:27:02.190 --> 00:27:09.840
过去，然后你会继续

00:27:06.179 --> 00:27:11.999
接收和新值，这样

00:27:09.840 --> 00:27:16.109
接入码中的内容重播

00:27:11.999 --> 00:27:19.730
主题，这是一个特殊的运算符

00:27:16.109 --> 00:27:23.820
您可以将其应用于将

00:27:19.730 --> 00:27:27.419
记住发生在

00:27:23.820 --> 00:27:31.889
过去，但您已经可以在这里看到

00:27:27.419 --> 00:27:34.379
现在，您知道等待的时间更长

00:27:31.889 --> 00:27:37.529
所以更多的价值出现了

00:27:34.379 --> 00:27:40.859
时间，您必须拥有更多的价值

00:27:37.529 --> 00:27:43.109
记得在这里，所以在

00:27:40.859 --> 00:27:47.519
有些人认为这是危险的操作，因为

00:27:43.109 --> 00:27:49.980
这代表着回忆，所以我们有你

00:27:47.519 --> 00:27:52.710
创建替换对象时，您可以

00:27:49.980 --> 00:27:55.619
伯爵在这里你说你知道我

00:27:52.710 --> 00:27:58.499
只想记住最后的结局

00:27:55.619 --> 00:28:00.600
价值观，或者你在这里有时间

00:27:58.499 --> 00:28:03.629
在这里你可以说你想

00:28:00.600 --> 00:28:08.519
只记得某个特定的值

00:28:03.629 --> 00:28:12.929
期间我希望能回答

00:28:08.519 --> 00:28:14.070
是的，嗯，我想第二个

00:28:12.929 --> 00:28:16.289
一种是与您相关的

00:28:14.070 --> 00:28:17.909
可能已经回答了

00:28:16.289 --> 00:28:19.529
问题是如果发生事件会怎样

00:28:17.909 --> 00:28:22.289
产生得更快

00:28:19.529 --> 00:28:26.249
观察员可以应付，所以我认为你很友善

00:28:22.289 --> 00:28:33.720
的覆盖那好吧，那就是

00:28:26.249 --> 00:28:37.580
我要说的是一个问题

00:28:33.720 --> 00:28:41.940
需要更多时间来解释和

00:28:37.580 --> 00:28:45.059
但是如果你看一个极端的话

00:28:41.940 --> 00:28:48.210
你真的看着去做一个正常的

00:28:45.059 --> 00:28:52.259
那里的事件系统你必须总是

00:28:48.210 --> 00:28:55.320
能够处理

00:28:52.259 --> 00:28:56.230
扔给你，例如让我

00:28:55.320 --> 00:28:59.710
有点给你

00:28:56.230 --> 00:29:02.820
在一个例子中，说你是

00:28:59.710 --> 00:29:05.740
编写股票交易申请，以及

00:29:02.820 --> 00:29:06.580
你因为某种原因认识你

00:29:05.740 --> 00:29:09.520
一个业余

00:29:06.580 --> 00:29:13.840
所以你用Visual Basic和

00:29:09.520 --> 00:29:16.780
您的Visual Basic当然是您

00:29:13.840 --> 00:29:18.250
知道您也可以在其中编写快速代码

00:29:16.780 --> 00:29:20.080
我不应取笑的Visual Basic 

00:29:18.250 --> 00:29:23.559
 Visual Basic和Visual Basic上的工作

00:29:20.080 --> 00:29:25.750
但以您所知为例

00:29:23.559 --> 00:29:30.370
您的应用程序只能处理

00:29:25.750 --> 00:29:33.309
每小时数百笔交易，现在

00:29:30.370 --> 00:29:36.790
你不会告诉新的

00:29:33.309 --> 00:29:38.799
纽约变化嘿嘿嘿你知道我的

00:29:36.790 --> 00:29:41.380
软件无法处理您知道的

00:29:38.799 --> 00:29:41.650
大量交易请放慢速度

00:29:41.380 --> 00:29:45.070
下

00:29:41.650 --> 00:29:47.770
您将不得不继续处理

00:29:45.070 --> 00:29:50.799
另一个极端是可迭代的

00:29:47.770 --> 00:29:55.299
界面，您可以知道他们是否是您

00:29:50.799 --> 00:29:58.960
只问值，所以它真的

00:29:55.299 --> 00:30:01.660
你知道这就像没有新的价值

00:29:58.960 --> 00:30:04.120
除非您要求，否则生成

00:30:01.660 --> 00:30:07.840
我说这个的原因

00:30:04.120 --> 00:30:10.840
问题需要更多时间

00:30:07.840 --> 00:30:12.970
答案是有一个整体设计

00:30:10.840 --> 00:30:17.410
你知道你的中间的空间

00:30:12.970 --> 00:30:21.760
可能会平衡您所处的1x3 

00:30:17.410 --> 00:30:23.980
总是要处理

00:30:21.760 --> 00:30:25.480
值与您可以

00:30:23.980 --> 00:30:29.790
你们有一个混合模型

00:30:25.480 --> 00:30:32.350
你可以问，你知道，但是我

00:30:29.790 --> 00:30:35.650
一直相信你必须得到那个

00:30:32.350 --> 00:30:37.990
最富有成效的方法

00:30:35.650 --> 00:30:40.780
软件要看极端

00:30:37.990 --> 00:30:43.299
如果您无法应对极端情况， 

00:30:40.780 --> 00:30:45.940
知道那你甚至不知道里面有什么

00:30:43.299 --> 00:30:50.770
中间，但又有一个

00:30:45.940 --> 00:30:53.650
整个界面设计空间

00:30:50.770 --> 00:30:57.240
对于中间的收藏

00:30:53.650 --> 00:31:00.309
希望能回答这个问题， 

00:30:57.240 --> 00:31:03.370
好吧，我只是不想保留

00:31:00.309 --> 00:31:05.830
太多了，不，没有上帝，让我们

00:31:03.370 --> 00:31:09.429
这么问问题-你什么都不知道

00:31:05.830 --> 00:31:10.130
对我们有好处，好吧，所以其他

00:31:09.429 --> 00:31:12.140
一个是

00:31:10.130 --> 00:31:15.740
我们有事先订购的东西吗

00:31:12.140 --> 00:31:19.460
可以为订户分配抱歉

00:31:15.740 --> 00:31:22.250
您能重复一遍吗我们有什么

00:31:19.460 --> 00:31:25.280
我们可以分配的优先顺序

00:31:22.250 --> 00:31:28.790
基本上，如果

00:31:25.280 --> 00:31:31.280
订户可以设置优先级

00:31:28.790 --> 00:31:35.120
所以如果你又是那是一个非常

00:31:31.280 --> 00:31:40.190
好问题，让我移动这件事

00:31:35.120 --> 00:31:47.810
再过一秒钟再回到

00:31:40.190 --> 00:31:51.260
和这里的界面，您所看到的

00:31:47.810 --> 00:31:54.230
这是可观察的

00:31:51.260 --> 00:31:58.700
接口本身只有一个方法

00:31:54.230 --> 00:32:01.810
在哪里可以订阅它，所以

00:31:58.700 --> 00:32:05.600
基本界面没有

00:32:01.810 --> 00:32:07.490
订户的优先权，但这

00:32:05.600 --> 00:32:09.680
并不意味着你知道你不能

00:32:07.490 --> 00:32:12.550
有一个可观察到的子类型

00:32:09.680 --> 00:32:16.040
允许您订阅

00:32:12.550 --> 00:32:19.250
如果您再看一遍

00:32:16.040 --> 00:32:21.800
在收藏课上，我不会

00:32:19.250 --> 00:32:24.710
一直滚动回来，但是有

00:32:21.800 --> 00:32:28.780
就像你知道的那样

00:32:24.710 --> 00:32:32.060
标准Java SDK可能有50个

00:32:28.780 --> 00:32:33.050
实现的具体集合

00:32:32.060 --> 00:32:35.930
可迭代的

00:32:33.050 --> 00:32:38.540
所以同样的事情是可以观察到的

00:32:35.930 --> 00:32:39.950
你在那里，如果你没有特别

00:32:38.540 --> 00:32:41.320
像你知道我想要的行为

00:32:39.950 --> 00:32:44.540
区分不同

00:32:41.320 --> 00:32:47.030
订阅者，您必须定义一个

00:32:44.540 --> 00:32:49.540
具有这些的特殊可观察物

00:32:47.030 --> 00:32:54.470
其他属性，这只是一个

00:32:49.540 --> 00:32:56.300
基于常规界面的设计，您可以在其中

00:32:54.470 --> 00:32:59.540
知道你像一个主界面

00:32:56.300 --> 00:33:01.990
具有最新的约束条件，如果您

00:32:59.540 --> 00:33:05.360
需要更多的约束，您可以通过添加

00:33:01.990 --> 00:33:10.310
子类型化并具有派生接口

00:33:05.360 --> 00:33:13.490
拥有更多属性的就好

00:33:10.310 --> 00:33:19.070
是的，我想我们可以继续感谢

00:33:13.490 --> 00:33:21.680
好，现在注意到，即使这是

00:33:19.070 --> 00:33:23.980
有趣的是您知道界面

00:33:21.680 --> 00:33:25.540
订阅者甚至没有

00:33:23.980 --> 00:33:27.549
提到有一个清单

00:33:25.540 --> 00:33:28.929
订户或其他任何对的人， 

00:33:27.549 --> 00:33:31.720
你唯一能做的就是

00:33:28.929 --> 00:33:33.309
订阅，然后您可以取回

00:33:31.720 --> 00:33:36.460
订阅，您可以使用

00:33:33.309 --> 00:33:39.070
取消订阅，因此实际上有很多

00:33:36.460 --> 00:33:41.530
可观察对象的许多实现

00:33:39.070 --> 00:33:45.669
不维护任何订户列表

00:33:41.530 --> 00:33:47.919
这就是为什么我要这个

00:33:45.669 --> 00:33:50.320
优先考虑的事情

00:33:47.919 --> 00:33:57.640
订户不应位于

00:33:50.320 --> 00:34:00.490
面对好的滤镜图我们可以观察到

00:33:57.640 --> 00:34:03.669
收集，所以我们在这里过得去

00:34:00.490 --> 00:34:06.400
在我们提出问题之前， 

00:34:03.669 --> 00:34:09.179
变异的可观察的集合

00:34:06.400 --> 00:34:13.240
操作以及您进行突变和

00:34:09.179 --> 00:34:16.060
您将收到更改通知，因此

00:34:13.240 --> 00:34:18.690
再次在这里，您是否知道

00:34:16.060 --> 00:34:21.850
有人在改变集合， 

00:34:18.690 --> 00:34:25.060
无论我是什么意思，您都会收到通知

00:34:21.850 --> 00:34:27.700
有人在变异，如果你

00:34:25.060 --> 00:34:30.700
跟不上变化和坏处

00:34:27.700 --> 00:34:35.100
如果你看看这个，现在为你带来好运

00:34:30.700 --> 00:34:38.320
这幅画在这里你说嗯我知道

00:34:35.100 --> 00:34:40.899
我以前看过，如果你看过

00:34:38.320 --> 00:34:42.700
您将注意到的数据库课程

00:34:40.899 --> 00:34:45.250
这正是数据库

00:34:42.700 --> 00:34:48.639
是不是你有一把锁，然后你

00:34:45.250 --> 00:34:54.990
每次更改数据库时都知道

00:34:48.639 --> 00:34:54.990
并将新条目添加到锁中， 

00:34:55.139 --> 00:35:01.210
数据库的当前状态是

00:34:57.850 --> 00:35:02.890
只是一个锁记录，那是

00:35:01.210 --> 00:35:05.560
如果我在这里看，我也一样

00:35:02.890 --> 00:35:08.920
会重播所有我可以随时更改的内容

00:35:05.560 --> 00:35:10.720
并重现此状态

00:35:08.920 --> 00:35:13.540
可观察的集合，所以有一种

00:35:10.720 --> 00:35:17.950
那些之间有趣的联系

00:35:13.540 --> 00:35:20.980
第二，另一种查看Rx的方法是

00:35:17.950 --> 00:35:23.260
说出为什么要使用数据库

00:35:20.980 --> 00:35:26.440
一个日志，该日志代表

00:35:23.260 --> 00:35:29.950
存在和数据库表示

00:35:26.440 --> 00:35:33.180
过去和未来会发生变化， 

00:35:29.950 --> 00:35:33.180
现在

00:35:33.940 --> 00:35:42.250
好吧，现在让我们看一些具体的

00:35:38.710 --> 00:35:47.530
流在这里，例如时钟

00:35:42.250 --> 00:35:49.869
时钟老化了可观察的流

00:35:47.530 --> 00:35:53.589
 RX有一种创建时钟的方法

00:35:49.869 --> 00:35:57.010
说在第一次延迟0秒

00:35:53.589 --> 00:35:59.290
然后每隔一秒钟滴答一声，然后

00:35:57.010 --> 00:36:03.130
你在这里看到的是你得到了这个

00:35:59.290 --> 00:36:09.089
每个都会产生价值的流

00:36:03.130 --> 00:36:09.089
第二，我们可以做疯狂的事情，例如

00:36:09.150 --> 00:36:15.040
计算素数或仅

00:36:12.819 --> 00:36:17.260
你知道过滤掉秒

00:36:15.040 --> 00:36:20.680
这个小代码的质数

00:36:17.260 --> 00:36:22.810
我们从计时器开始，然后

00:36:20.680 --> 00:36:25.990
我们过滤掉所有的数字

00:36:22.810 --> 00:36:29.680
当是数字和素数时不是素数

00:36:25.990 --> 00:36:33.220
当它的因素只有一个，所以它

00:36:29.680 --> 00:36:36.490
只被一个人分开怎么办

00:36:33.220 --> 00:36:39.730
我们发现因素的收集很好

00:36:36.490 --> 00:36:42.490
他们使用的是可迭代的，所以在这里您会看到一个

00:36:39.730 --> 00:36:46.060
出现在您很多地方的模式

00:36:42.490 --> 00:36:49.000
结合可观察和间隔

00:36:46.060 --> 00:36:51.069
现在在同一程序中

00:36:49.000 --> 00:36:54.520
程序不是您想要的程序

00:36:51.069 --> 00:36:58.300
在实践中使用，但这只是为了

00:36:54.520 --> 00:37:01.150
说明两个间隔和

00:36:58.300 --> 00:37:04.270
观测值经常用于同一

00:37:01.150 --> 00:37:07.450
代码还可以

00:37:04.270 --> 00:37:10.990
回到我们的游戏，正如我所说的

00:37:07.450 --> 00:37:14.290
游戏在流上做出反应，然后更新

00:37:10.990 --> 00:37:18.460
屏幕，尤其是两个

00:37:14.290 --> 00:37:22.300
他们在键盘上做出反应，所以这本书

00:37:18.460 --> 00:37:27.060
游戏在空格键上做出反应

00:37:22.300 --> 00:37:30.819
我按了空格键，这本书跳了起来，嗯

00:37:27.060 --> 00:37:34.420
只要我能打蛇，蛇就会做出反应

00:37:30.819 --> 00:37:39.760
向上或向下键，然后是

00:37:34.420 --> 00:37:43.599
要四处走动，现在该图

00:37:39.760 --> 00:37:46.359
您如何转换类似

00:37:43.599 --> 00:37:47.530
键盘事件到可观察的集合

00:37:46.359 --> 00:37:52.000
所以有点

00:37:47.530 --> 00:37:54.490
而且我们的一项操作超级好

00:37:52.000 --> 00:37:57.430
重要，因为您必须从

00:37:54.490 --> 00:38:01.510
这个事件的世界变成了

00:37:57.430 --> 00:38:04.600
可观察到的，这是Fernet，所以我

00:38:01.510 --> 00:38:07.450
想要定义一个可观察的集合

00:38:04.600 --> 00:38:08.740
和Observables 3对不起，我不应该说

00:38:07.450 --> 00:38:10.630
可观察的集合，因为

00:38:08.740 --> 00:38:13.180
可观察的集合是另一个

00:38:10.630 --> 00:38:16.570
集合，这是一个可观察的流

00:38:13.180 --> 00:38:20.290
关键事件，以及我该如何做好

00:38:16.570 --> 00:38:23.100
我创建新的事件处理程序，在这里

00:38:20.290 --> 00:38:25.690
使用一种有点隐式

00:38:23.100 --> 00:38:27.880
转换，因为在Java中

00:38:25.690 --> 00:38:29.320
当你有功能时

00:38:27.880 --> 00:38:32.350
界面可以使用更长

00:38:29.320 --> 00:38:35.260
表达你必须要做的一点

00:38:32.350 --> 00:38:38.560
魔术，但无论如何我可以在这里定义我的

00:38:35.260 --> 00:38:42.940
输入事件，现在我添加一个事件

00:38:38.560 --> 00:38:46.390
每个令人毛骨悚然的新闻处理程序到我的java 

00:38:42.940 --> 00:38:49.870
疫苗及其工作方式是

00:38:46.390 --> 00:38:54.880
每当事件处理程序被调用时

00:38:49.870 --> 00:38:57.760
会将钥匙通知给观察者

00:38:54.880 --> 00:38:59.920
按下，它将在此上调用下一步

00:38:57.760 --> 00:39:02.170
观察，所以在这里您看到这是

00:38:59.920 --> 00:39:03.670
事件世界之间的桥梁

00:39:02.170 --> 00:39:05.950
你有一个事件处理程序

00:39:03.670 --> 00:39:08.950
错误和唯一的事件

00:39:05.950 --> 00:39:12.520
处理程序所做的是在此处通知观察者

00:39:08.950 --> 00:39:15.340
发生了一件事情，然后我

00:39:12.520 --> 00:39:19.470
取消订阅我需要删除活动

00:39:15.340 --> 00:39:24.550
输入，所以这是几行代码

00:39:19.470 --> 00:39:28.570
摆脱老式的事件处理程序

00:39:24.550 --> 00:39:31.290
到可观察的流，现在您看是否

00:39:28.570 --> 00:39:34.120
我只想要空格键和

00:39:31.290 --> 00:39:37.300
事件很好，它仍然是可观察的

00:39:34.120 --> 00:39:40.240
关键事件，但我认为所有P流程和

00:39:37.300 --> 00:39:43.990
然后我只是在这个批量操作中使用

00:39:40.240 --> 00:39:46.960
过滤器只给我空间

00:39:43.990 --> 00:39:49.870
酒吧活动，所以在这里你看到我只是写

00:39:46.960 --> 00:39:53.580
一点胶水代码，然后从那里

00:39:49.870 --> 00:39:56.910
在我所有的UI事件上， 

00:39:53.580 --> 00:39:56.910
可观察的流

00:39:57.380 --> 00:40:03.979
现在让我们写一些代码来

00:40:00.819 --> 00:40:06.079
开始玩我们的游戏，所以我想要

00:40:03.979 --> 00:40:08.720
我要做的是显示关键事件

00:40:06.079 --> 00:40:11.059
在这里，所以如果我按AA按一个援助

00:40:08.720 --> 00:40:14.690
我祈祷我应该来

00:40:11.059 --> 00:40:16.220
并在其中显示关键事件

00:40:14.690 --> 00:40:19.190
这样的图形，您已经可以看到

00:40:16.220 --> 00:40:22.400
这就是蛇游戏的发展趋势

00:40:19.190 --> 00:40:22.670
工作，这是代码，那我该怎么办

00:40:22.400 --> 00:40:25.670
做

00:40:22.670 --> 00:40:30.950
好吧，有一点点约束力

00:40:25.670 --> 00:40:33.259
在这里和用户界面之间，所以不用担心

00:40:30.950 --> 00:40:36.170
这是这里显示的行

00:40:33.259 --> 00:40:38.359
在图表上，还有我的键盘和

00:40:36.170 --> 00:40:38.749
现在我的意思是每当您按下

00:40:38.359 --> 00:40:40.999
键

00:40:38.749 --> 00:40:43.489
给我文本，所以现在

00:40:40.999 --> 00:40:46.249
再次在这里观察到字符串

00:40:43.489 --> 00:40:50.589
我正在可观察的批量操作

00:40:46.249 --> 00:40:54.440
字符串，我在这里要做的是

00:40:50.589 --> 00:40:56.960
每当按键时，我都想放它

00:40:54.440 --> 00:40:59.799
在图上，所以我必须配对

00:40:56.960 --> 00:41:02.749
它与索引，所以这是

00:40:59.799 --> 00:41:05.569
第一次击键，第二次击键

00:41:02.749 --> 00:41:09.259
每个按键都与其索引配对

00:41:05.569 --> 00:41:11.210
然后我可以像这样绘制它

00:41:09.259 --> 00:41:14.119
我是否可以将某些东西与索引很好地配对

00:41:11.210 --> 00:41:17.739
有一个带有索引的运算符zip 

00:41:14.119 --> 00:41:20.859
进行观察并搅拌

00:41:17.739 --> 00:41:23.900
将其与数字配对

00:41:20.859 --> 00:41:27.559
问题是它给出的数字为

00:41:23.900 --> 00:41:30.529
这对的第二个值，所以我有

00:41:27.559 --> 00:41:33.410
进行交换地图，所以您在这里看到

00:41:30.529 --> 00:41:37.999
在几行中，所有批量操作

00:41:33.410 --> 00:41:40.099
在这些可观测的流上，然后

00:41:37.999 --> 00:41:44.479
我能做的就是我只订阅

00:41:40.099 --> 00:41:51.700
每当启动时，我添加该字符串

00:41:44.479 --> 00:41:54.529
配对到我的图表，图表将显示

00:41:51.700 --> 00:41:58.009
现在这是一种稍微不同的方式

00:41:54.529 --> 00:41:59.809
就是我正在使用这个概念

00:41:58.009 --> 00:42:02.529
我给你看的可观察的收藏

00:41:59.809 --> 00:42:07.489
所以我创建了一个可观察的集合

00:42:02.529 --> 00:42:09.200
然后在任何时候和迪斯科舞厅

00:42:07.489 --> 00:42:13.280
现在一样

00:42:09.200 --> 00:42:18.410
击键发生在我刚刚创建的索引上

00:42:13.280 --> 00:42:21.680
将此空气添加到此处的可观察列表中

00:42:18.410 --> 00:42:23.060
所以现在我有相同的图片

00:42:21.680 --> 00:42:25.990
我有一个可以观察到的

00:42:23.060 --> 00:42:29.690
收集，我随时随地变异

00:42:25.990 --> 00:42:32.720
发生某事会触发一个事件

00:42:29.690 --> 00:42:35.390
在我身上，这就是

00:42:32.720 --> 00:42:38.060
我们要去的所有游戏

00:42:35.390 --> 00:42:39.770
我们有一个我们可以观察到的

00:42:38.060 --> 00:42:41.780
我们将要变异的集合

00:42:39.770 --> 00:42:45.050
我们正在观察我们正在发生的变化

00:42:41.780 --> 00:42:47.950
计算一个答案，然后我们要去

00:42:45.050 --> 00:42:52.580
改变可观察的集合并

00:42:47.950 --> 00:42:57.020
然后我们绑定那个可观察的集合

00:42:52.580 --> 00:42:59.030
在用户界面和另一种查看方式

00:42:57.020 --> 00:43:02.000
这是这个观点，这是

00:42:59.030 --> 00:43:03.890
模型，这是控制器，所以

00:43:02.000 --> 00:43:07.340
喜欢你想给的名字

00:43:03.890 --> 00:43:09.250
它，但真正有趣的部分

00:43:07.340 --> 00:43:11.930
的代码在这里您观察

00:43:09.250 --> 00:43:15.980
变化，然后你就能知道你

00:43:11.930 --> 00:43:18.950
你能知道你产生并陈述

00:43:15.980 --> 00:43:21.440
您所模型的突变

00:43:18.950 --> 00:43:24.130
那种你正在处理，然后如何

00:43:21.440 --> 00:43:26.750
您想要将其绑定到UI确实

00:43:24.130 --> 00:43:29.000
我们关心的不是很多

00:43:26.750 --> 00:43:31.250
就像我在JavaScript中所说的那样

00:43:29.000 --> 00:43:35.420
特别是有数百万个图书馆

00:43:31.250 --> 00:43:37.310
在这里处理这个网站，但是

00:43:35.420 --> 00:43:40.760
我们要做的是

00:43:37.310 --> 00:43:43.310
专注于那个网站，这是另一个

00:43:40.760 --> 00:43:46.100
例子说我想简单和

00:43:43.310 --> 00:43:48.650
关键，因为在第一个示例中

00:43:46.100 --> 00:43:51.380
每当我按下琴键就显示

00:43:48.650 --> 00:43:54.860
它，但我并不总是打字，所以我只是

00:43:51.380 --> 00:43:58.130
希望仅在按键是

00:43:54.860 --> 00:44:00.410
打我想采样一下，然后

00:43:58.130 --> 00:44:03.080
下一个键是我想要的

00:44:00.410 --> 00:44:05.930
继续，让我们看看

00:44:03.080 --> 00:44:09.590
代码在这里，所以我们创建一个时钟，然后

00:44:05.930 --> 00:44:13.970
我们说只要有键盘就可以

00:44:09.590 --> 00:44:18.980
击键发生，我们对钥匙

00:44:13.970 --> 00:44:21.620
现在的时钟值这个家伙

00:44:18.980 --> 00:44:22.850
没有被观察到，但是我们在地图上绘制了一个

00:44:21.620 --> 00:44:25.160
这是多余的

00:44:22.850 --> 00:44:28.070
结果是可以观察到的

00:44:25.160 --> 00:44:31.400
可观察物以及我们切换时的操作

00:44:28.070 --> 00:44:33.470
在每一个新流之间

00:44:31.400 --> 00:44:37.460
发生中风，所以您在这里看到

00:44:33.470 --> 00:44:40.400
很小的空间是一个相当

00:44:37.460 --> 00:44:43.090
复杂并为每个代码

00:44:40.400 --> 00:44:46.370
按键将其与时钟刻度配对

00:44:43.090 --> 00:44:49.250
给嵌套三个并切换到

00:44:46.370 --> 00:44:53.630
他摔断时最新的弦

00:44:49.250 --> 00:44:57.260
键盘和事件发生，然后我们

00:44:53.630 --> 00:45:00.350
立即订阅此代码

00:44:57.260 --> 00:45:04.160
书，我不知道你是否有

00:45:00.350 --> 00:45:10.070
已经看过了，但是如果我运行这个

00:45:04.160 --> 00:45:12.560
代码的结果将是这个，等等

00:45:10.070 --> 00:45:18.920
你看到的是，每次我打新

00:45:12.560 --> 00:45:22.160
关键时间从零开始，我也

00:45:18.920 --> 00:45:24.740
想在这里给你看这个开关

00:45:22.160 --> 00:45:27.710
所以它要做的是

00:45:24.740 --> 00:45:29.540
流，它变平成一个新的

00:45:27.710 --> 00:45:32.480
流最多的地方

00:45:29.540 --> 00:45:35.090
最近值，因此如果现在是

00:45:32.480 --> 00:45:37.340
全新的流媒体

00:45:35.090 --> 00:45:39.230
开始，没有电流

00:45:37.340 --> 00:45:41.810
流，我要切换到下一个

00:45:39.230 --> 00:45:44.930
只要流中出现在这里，我就是

00:45:41.810 --> 00:45:48.350
切换到这个，你知道

00:45:44.930 --> 00:45:51.770
和我们一样，只要有新玩意儿

00:45:48.350 --> 00:45:54.530
碰巧我会在任何时候想要

00:45:51.770 --> 00:45:57.020
新的小工具出现了，我想要那样，然后

00:45:54.530 --> 00:46:00.440
你知道它总是跟随最新的

00:45:57.020 --> 00:46:05.030
小工具，现在这个问题是

00:46:00.440 --> 00:46:06.980
你知道，时间似乎没有前进

00:46:05.030 --> 00:46:09.710
向前，我们将在这里映射

00:46:06.980 --> 00:46:12.500
时钟，但必须是

00:46:09.710 --> 00:46:16.880
时钟每次都从零开始

00:46:12.500 --> 00:46:20.660
我们在这里看到的问题是

00:46:16.880 --> 00:46:24.680
每当我们全天候在地图下方

00:46:20.660 --> 00:46:27.260
从某种意义上说，这种λ出生

00:46:24.680 --> 00:46:31.490
每次都订阅时钟， 

00:46:27.260 --> 00:46:34.040
从零开始的时间，所以我们有

00:46:31.490 --> 00:46:36.650
要做的是我们必须采取这个时钟

00:46:34.040 --> 00:46:39.200
我们有你

00:46:36.650 --> 00:46:41.210
只是学校的一个订阅

00:46:39.200 --> 00:46:44.119
所以这就是我们在这里所做的

00:46:41.210 --> 00:46:46.730
发布此发布为其提供了副本

00:46:44.119 --> 00:46:48.020
我们可以在哪里使用它的讨论

00:46:46.730 --> 00:46:51.559
我们想要的时代

00:46:48.020 --> 00:46:53.180
我们在这里只订阅一次

00:46:51.559 --> 00:46:56.299
你会发现有一个非常微妙的

00:46:53.180 --> 00:47:00.619
区别在于我要传递

00:46:56.299 --> 00:47:04.789
此时钟通过发布和

00:47:00.619 --> 00:47:06.200
当我们运行该代码时，您会看到它

00:47:04.789 --> 00:47:08.450
按预期工作

00:47:06.200 --> 00:47:11.960
以及您所看到的特别的外观

00:47:08.450 --> 00:47:13.849
如果一段时间不输入

00:47:11.960 --> 00:47:16.940
还在滴答作响，所以这是第一个

00:47:13.849 --> 00:47:20.029
七点以后我有一次按键

00:47:16.940 --> 00:47:22.640
秒，然后你也看到这里

00:47:20.029 --> 00:47:29.119
当我制作截图时

00:47:22.640 --> 00:47:30.740
时钟一直在走，让我

00:47:29.119 --> 00:47:32.119
看着时间，所以我们很友善

00:47:30.740 --> 00:47:36.970
没时间了，所以我要

00:47:32.119 --> 00:47:36.970
有点在这里跳过这个虚拟时间， 

00:47:37.240 --> 00:47:47.480
但主要的是我

00:47:40.609 --> 00:47:49.819
希望时钟是所谓的

00:47:47.480 --> 00:48:00.619
邪教可观察到的

00:47:49.819 --> 00:48:05.140
我将在这里转到我们的以及我们的IDE 

00:48:00.619 --> 00:48:26.960
所以说我想定义和计时

00:48:05.140 --> 00:48:28.970
等于所以这是我们的一个小时时钟

00:48:26.960 --> 00:48:30.859
 lon和我所观察到的

00:48:28.970 --> 00:48:32.930
我要做的就是订阅

00:48:30.859 --> 00:48:36.740
它两次，所以我说的是时钟点

00:48:32.930 --> 00:48:51.470
订阅，然后您知道X箭头

00:48:36.740 --> 00:48:53.960
打印行以订阅，请查看时钟一次

00:48:51.470 --> 00:48:59.260
现在我要订阅

00:48:53.960 --> 00:48:59.260
再次计时，但我要去

00:48:59.380 --> 00:49:05.119
我将等待一切​​就绪

00:49:03.589 --> 00:49:11.410
在这里，你看到的是我要去

00:49:05.119 --> 00:49:15.760
两次订阅时钟，然后和

00:49:11.410 --> 00:49:19.000
并同时打印

00:49:15.760 --> 00:49:21.619
现在您将看到的是

00:49:19.000 --> 00:49:24.500
订阅时钟和这个

00:49:21.619 --> 00:49:27.799
订阅时钟都将有

00:49:24.500 --> 00:49:30.440
这将得到他们自己的滴答声，所以这

00:49:27.799 --> 00:49:32.390
一个得到它0然后我睡觉然后我

00:49:30.440 --> 00:49:36.319
订阅时钟，那个将

00:49:32.390 --> 00:49:42.349
再次从0开始，让我们开始吧

00:49:36.319 --> 00:49:44.559
这个家伙，看看是否可行，我们

00:49:42.349 --> 00:49:44.559
走

00:49:48.190 --> 00:49:56.630
所以确实有两只公鸡在滴答作响

00:49:51.410 --> 00:50:01.370
每个人都都在摘

00:49:56.630 --> 00:50:06.770
独立地以及那是什么

00:50:01.370 --> 00:50:09.050
我们的xpeke是这个时钟是

00:50:06.770 --> 00:50:12.170
这就是我们所说的寒冷

00:50:09.050 --> 00:50:17.180
每个订阅都会得到一个新时钟，如果我

00:50:12.170 --> 00:50:20.480
想让这个时钟变热

00:50:17.180 --> 00:50:25.010
可以做的是我可以发布它，然后

00:50:20.480 --> 00:50:31.670
我在这里是因为我可以连接到它，所以我

00:50:25.010 --> 00:50:35.690
说时钟连接，我应该删除

00:50:31.670 --> 00:50:38.690
这个人在这里，所以现在发生的是

00:50:35.690 --> 00:50:41.090
这个时钟在那里是发布者

00:50:38.690 --> 00:50:44.000
表示只有一个订阅

00:50:41.090 --> 00:50:47.210
订阅此区块的所有人

00:50:44.000 --> 00:50:50.540
将共享基础订阅

00:50:47.210 --> 00:50:55.160
为此，您知道时钟只会

00:50:50.540 --> 00:50:57.470
您只会开始订阅

00:50:55.160 --> 00:51:00.410
通话时转到另一边

00:50:57.470 --> 00:51:02.960
所以在这种情况下，我会立即连接

00:51:00.410 --> 00:51:05.120
订阅等待，我订阅，现在

00:51:02.960 --> 00:51:07.880
您会看到的是，只有

00:51:05.120 --> 00:51:09.170
共享一个时钟，所以保持

00:51:07.880 --> 00:51:11.390
请记住，有两个

00:51:09.170 --> 00:51:13.850
不同的时钟，但现在如果您看到这个

00:51:11.390 --> 00:51:17.990
一个哦，现在另一个，你看到了

00:51:13.850 --> 00:51:21.230
他们所做的和订阅共享

00:51:17.990 --> 00:51:24.200
时钟的值相同，所以

00:51:21.230 --> 00:51:30.560
你在冷热之间移动

00:51:24.200 --> 00:51:39.770
可观察的东西让我们回到幻灯片

00:51:30.560 --> 00:51:42.530
让我们去看看我们的收益

00:51:39.770 --> 00:51:45.590
而且因为你知道这一切都是关于

00:51:42.530 --> 00:51:49.030
玩游戏，我们现在有足够的

00:51:45.590 --> 00:51:51.530
和一般知识要做

00:51:49.030 --> 00:51:55.040
集合了一个男人，但是正如我所说的

00:51:51.530 --> 00:51:58.670
非常简单，我们现在已经看到

00:51:55.040 --> 00:52:00.500
所有需要的运营商

00:51:58.670 --> 00:52:09.110
今天的比赛

00:52:00.500 --> 00:52:11.630
这确实是

00:52:09.110 --> 00:52:12.500
游戏有点作弊，但所有游戏

00:52:11.630 --> 00:52:15.740
这样工作

00:52:12.500 --> 00:52:18.650
发生了什么，当您想到

00:52:15.740 --> 00:52:20.750
这本书在动，真的不是

00:52:18.650 --> 00:52:23.270
戳移动框保持在

00:52:20.750 --> 00:52:25.280
在同一地方，它在移动的草地

00:52:23.270 --> 00:52:28.550
所以如果你看这边

00:52:25.280 --> 00:52:32.330
几钟滴答的草是这个

00:52:28.550 --> 00:52:34.790
一块草和几点钟

00:52:32.330 --> 00:52:37.220
在那儿，那是草

00:52:34.790 --> 00:52:39.140
从左向右移动

00:52:37.220 --> 00:52:43.910
本书留在原处，那么我们如何编码

00:52:39.140 --> 00:52:46.640
好了，我们再次在这里创建旧瓷砖

00:52:43.910 --> 00:52:50.050
我们正在使用批量操作

00:52:46.640 --> 00:52:55.310
创建图块列表的间隔和

00:52:50.050 --> 00:52:58.160
然后我们要做的是

00:52:55.310 --> 00:53:05.210
要说的很好，并且时钟

00:52:58.160 --> 00:53:09.460
以三点速度移动

00:53:05.210 --> 00:53:13.760
每秒，所以每一件事

00:53:09.460 --> 00:53:16.130
草向左移动三个像素

00:53:13.760 --> 00:53:19.640
那会知道在这里做什么

00:53:16.130 --> 00:53:24.050
就像我说的那样，这不是

00:53:19.640 --> 00:53:26.240
总理不在这里，他会转身

00:53:24.050 --> 00:53:29.240
如果他会在他的坟墓里结束

00:53:26.240 --> 00:53:31.910
严重，因为我们做得很差

00:53:29.240 --> 00:53:34.430
男人的滴答声，所以我们只是在说你

00:53:31.910 --> 00:53:37.070
知道我们以速度，而我们

00:53:34.430 --> 00:53:39.860
计算下一个速度，我们做

00:53:37.070 --> 00:53:42.980
与扫描操作员一起开始

00:53:39.860 --> 00:53:45.970
零，然后每次时钟

00:53:42.980 --> 00:53:48.920
滴答声，我们必须填充新

00:53:45.970 --> 00:53:52.400
在这种情况下，草的速度很好

00:53:48.920 --> 00:53:55.130
草恒速，所以好

00:53:52.400 --> 00:53:57.530
您正在复制前一个

00:53:55.130 --> 00:54:00.350
速度是下一个速度

00:53:57.530 --> 00:54:03.140
然后我们订阅，正如我们所说的

00:54:00.350 --> 00:54:05.510
现在知道这就是距离

00:54:03.140 --> 00:54:09.290
我们必须移动草，然后我们

00:54:05.510 --> 00:54:11.600
在此处更新模型以移动草

00:54:09.290 --> 00:54:14.420
然后当然要结束草

00:54:11.600 --> 00:54:17.809
然后转身

00:54:14.420 --> 00:54:20.390
出现在另一边，所以就像

00:54:17.809 --> 00:54:24.230
虽然你是如何让草移动的

00:54:20.390 --> 00:54:28.220
真的只是一行代码而已

00:54:24.230 --> 00:54:31.940
在这里，扫描的运算符的工作方式就像

00:54:28.220 --> 00:54:35.000
这需要操作员，每当

00:54:31.940 --> 00:54:37.549
它需要一个流，并转换

00:54:35.000 --> 00:54:40.250
通过反复申请流

00:54:37.549 --> 00:54:43.220
该运算符，因此在这种情况下它开始

00:54:40.250 --> 00:54:46.400
与第一个元素，然后

00:54:43.220 --> 00:54:48.109
结合这两个到它

00:54:46.400 --> 00:54:50.240
结合埃里克，它结合了这两个

00:54:48.109 --> 00:54:54.079
然后结合这两个

00:54:50.240 --> 00:54:57.109
进入这个等等等等，这就是为什么你看到

00:54:54.079 --> 00:54:59.329
这需要初始速度

00:54:57.109 --> 00:55:02.839
是流中的下一个值，它是

00:54:59.329 --> 00:55:05.119
结合起来，所以这是下一个值

00:55:02.839 --> 00:55:09.770
把它们结合在一起的树

00:55:05.119 --> 00:55:12.349
现在计算下一个

00:55:09.770 --> 00:55:15.829
让书跳起来，所以如果我们想

00:55:12.349 --> 00:55:17.569
这本书跳起来的速度是

00:55:15.829 --> 00:55:20.630
变化，因为你看到这本书

00:55:17.569 --> 00:55:22.910
上升，然后下降，所以我们开始

00:55:20.630 --> 00:55:26.030
初始速度和平均值为

00:55:22.910 --> 00:55:28.579
每个时钟滴答声，我们减去重力

00:55:26.030 --> 00:55:31.819
然后先把船插上去

00:55:28.579 --> 00:55:37.150
然后它下降了，所以再次在这里

00:55:31.819 --> 00:55:41.990
看到您识别出扫描，因为V是

00:55:37.150 --> 00:55:46.280
确定为VI减一，以此类推

00:55:41.990 --> 00:55:51.200
看到这里，下一个速度是基于

00:55:46.280 --> 00:55:56.599
在以前的速度上等等

00:55:51.200 --> 00:56:00.290
您会看到代码和这本书，因此

00:55:56.599 --> 00:56:02.780
让我们先来看这里

00:56:00.290 --> 00:56:06.559
你知道一些初始速度

00:56:02.780 --> 00:56:09.109
那么下一个速度就是上一个

00:56:06.559 --> 00:56:11.540
速度-重力就是你的意思

00:56:09.109 --> 00:56:14.420
看到这里，所以下一个速度是

00:56:11.540 --> 00:56:18.349
以前的速度减去重力，所以

00:56:14.420 --> 00:56:24.589
在这里，您会看到这是

00:56:18.349 --> 00:56:27.060
书的位置，但现在我们做

00:56:24.589 --> 00:56:29.100
每当你这本书跳

00:56:27.060 --> 00:56:32.250
空格键会发生，因此无论何时

00:56:29.100 --> 00:56:36.270
空格键发生了，我们得到了

00:56:32.250 --> 00:56:38.990
是一连串的速度，然后

00:56:36.270 --> 00:56:42.990
每当发生这种情况，我们都会计算并

00:56:38.990 --> 00:56:46.710
树皮的轨迹，然后我们

00:56:42.990 --> 00:56:50.160
下一次工作发生时，我们可以

00:56:46.710 --> 00:56:52.320
停止听这个，然后我们

00:56:50.160 --> 00:56:55.350
只需将位置更新到此处即可

00:56:52.320 --> 00:56:58.950
这本书的跳跃只有四行

00:56:55.350 --> 00:57:01.140
这样，所以每当发生跳跃时，我们

00:56:58.950 --> 00:57:04.800
取由

00:57:01.140 --> 00:57:08.970
跳，那么我们就算这个

00:57:04.800 --> 00:57:11.580
轨迹，当我们更新

00:57:08.970 --> 00:57:13.950
您更新模型时的树皮位置

00:57:11.580 --> 00:57:19.410
将忽略当

00:57:13.950 --> 00:57:21.420
书在地下，然后我们将

00:57:19.410 --> 00:57:24.570
每当有

00:57:21.420 --> 00:57:27.660
新的跳转似乎还可以，因此可以防止

00:57:24.570 --> 00:57:31.260
从地板上掉下来是在

00:57:27.660 --> 00:57:33.510
在那段代码中，好的，这就是

00:57:31.260 --> 00:57:37.020
直到直到需要两个流

00:57:33.510 --> 00:57:38.700
就在第二流

00:57:37.020 --> 00:57:41.820
每当第一件事发生

00:57:38.700 --> 00:57:45.180
字符串，所以这里是职位流

00:57:41.820 --> 00:57:52.200
的错误，每当

00:57:45.180 --> 00:57:53.640
现在出现下一跳我们该怎么办

00:57:52.200 --> 00:57:57.120
我们用空格键做得很好

00:57:53.640 --> 00:58:00.210
空格键，错误以八速跳跃

00:57:57.120 --> 00:58:03.720
我们说只要您知道我们就击中了

00:58:00.210 --> 00:58:07.860
空格键，当我们忽略空格键时

00:58:03.720 --> 00:58:11.010
伯克在空中，然后我们玩

00:58:07.860 --> 00:58:14.460
声音，如果不是这样，那么我们

00:58:11.010 --> 00:58:18.060
你能知道我们跳了吗，这是

00:58:14.460 --> 00:58:21.450
再次将空格键连接到

00:58:18.060 --> 00:58:25.140
让伯克跳起来，让我们看看

00:58:21.450 --> 00:58:31.760
在实际代码中，我们在哪里

00:58:25.140 --> 00:58:31.760
 bug，这是我们的游戏

00:58:37.480 --> 00:58:46.340
所以在这里你看到草，在这里你

00:58:43.730 --> 00:58:48.290
看到那个报价准确的代码

00:58:46.340 --> 00:58:51.350
我向你展示了跳跃的机会

00:58:48.290 --> 00:58:56.359
跳跃发生了，我们正在重新计算一个家伙

00:58:51.350 --> 00:59:06.320
这是空格键Cotto调用并运行

00:58:56.359 --> 00:59:08.210
这个游戏并运行它，所以这是

00:59:06.320 --> 00:59:10.130
行为，所以每当我按下空格键

00:59:08.210 --> 00:59:12.200
但是当我按下空格键

00:59:10.130 --> 00:59:14.570
按钮没有任何反应，所以我希望

00:59:12.200 --> 00:59:17.270
你可以听到我按下空格键

00:59:14.570 --> 00:59:19.520
只有在黑暗中什么也不会发生

00:59:17.270 --> 00:59:25.430
空气，所以现在下一个问题是

00:59:19.520 --> 00:59:30.650
我们如何确定这种背叛

00:59:25.430 --> 00:59:32.600
我们的租车可以打太阳了

00:59:30.650 --> 00:59:35.780
这个错误确实在这里给你一些东西

00:59:32.600 --> 00:59:39.200
射中太阳，所以你怎么做得好

00:59:35.780 --> 00:59:45.950
那也是非常简单的代码，让我们开始吧

00:59:39.200 --> 00:59:49.940
跳舞，为此，我们

00:59:45.950 --> 00:59:51.590
看一下电子表格及其功能

00:59:49.940 --> 00:59:54.109
如果您查看电子表格， 

00:59:51.590 --> 00:59:58.970
你这里有一个公式，所以公式

00:59:54.109 --> 01:00:02.720
是a1加b1现在这意味着

00:59:58.970 --> 01:00:04.790
每当一个

01:00:02.720 --> 01:00:07.430
这些细胞的变化，所以你

01:00:04.790 --> 01:00:10.730
看到这里，当我去改变一个两个

01:00:07.430 --> 01:00:16.250
到八，然后自动将

01:00:10.730 --> 01:00:19.280
 C从7变为13你好结果

01:00:16.250 --> 01:00:23.030
每当输入单元格时，此单元格的

01:00:19.280 --> 01:00:24.830
变化，它将在我们X中发生很好的变化

01:00:23.030 --> 01:00:28.190
也有一个运算符

01:00:24.830 --> 01:00:30.890
在这里进行一系列更改， 

01:00:28.190 --> 01:00:34.100
在这里以及任何时候发生的变化

01:00:30.890 --> 01:00:37.930
事物的变化我们重新计算

01:00:34.100 --> 01:00:41.210
输出，所以这里的这个运算符就是

01:00:37.930 --> 01:00:44.000
从电子表格中被盗，所以这里

01:00:41.210 --> 01:00:46.789
输入单元格，这是输出单元格

01:00:44.000 --> 01:00:49.999
每当输入1 

01:00:46.789 --> 01:00:54.769
重新计算输入单元格的变化

01:00:49.999 --> 01:00:58.219
输出单元格，那里有

01:00:54.769 --> 01:01:01.249
将RX连接到Excel的象牙

01:00:58.219 --> 01:01:03.199
实际上，它一次又一次地与

01:01:01.249 --> 01:01:05.299
这些可观察的集合或Excel 

01:01:03.199 --> 01:01:08.029
好是可观察的集合

01:01:05.299 --> 01:01:12.559
每当发生变化时，它将触发

01:01:08.029 --> 01:01:15.739
相邻的通知，然后我们可以

01:01:12.559 --> 01:01:19.249
挂上它，然后细胞像这样工作

01:01:15.739 --> 01:01:22.849
结合了最新的运算符好吧，怎么

01:01:19.249 --> 01:01:27.339
该代码看起来是否很好，我们接受了

01:01:22.849 --> 01:01:31.189
错误的位置可观察

01:01:27.339 --> 01:01:33.769
流，使我们得到x和y 

01:01:31.189 --> 01:01:36.979
坐标加上边框

01:01:33.769 --> 01:01:42.319
这就是我们在这里看到的，所以我们来看

01:01:36.979 --> 01:01:45.679
可以观察到的错误飞行

01:01:42.319 --> 01:01:48.619
 XY，宽度和高度以及

01:01:45.679 --> 01:01:52.400
太阳的东西，所以太阳也是

01:01:48.619 --> 01:01:54.979
可观察到的XY加梦

01:01:52.400 --> 01:01:58.069
在高度范围内，然后我们要做的是

01:01:54.979 --> 01:02:01.640
我们使用最新的组合，所以每个

01:01:58.069 --> 01:02:04.519
时间这些和改变我们检查

01:02:01.640 --> 01:02:06.859
两者是否发生碰撞， 

01:02:04.519 --> 01:02:09.319
碰撞只是真的看这些

01:02:06.859 --> 01:02:14.359
在这种情况下，事情也结束了

01:02:09.319 --> 01:02:17.569
碰撞，所以在这里我们看到了

01:02:14.359 --> 01:02:20.419
太阳在那里有障碍，这是

01:02:17.569 --> 01:02:23.509
你知道碰撞是红色的

01:02:20.419 --> 01:02:27.439
不要碰撞绿色意味着他们

01:02:23.509 --> 01:02:31.069
承诺，但我们想要的是我们想要的

01:02:27.439 --> 01:02:33.829
你们知道他们什么时候能很好地发现

01:02:31.069 --> 01:02:36.349
当我们必须将太阳改变为

01:02:33.829 --> 01:02:38.959
心和背部，所以我们真的不是

01:02:36.349 --> 01:02:42.409
对我们感兴趣的碰撞

01:02:38.959 --> 01:02:45.259
对X检测感兴趣，所以我们

01:02:42.409 --> 01:02:47.689
想知道什么时候发生

01:02:45.259 --> 01:02:50.269
不负责碰撞，我们

01:02:47.689 --> 01:02:52.969
想知道它何时从碰撞中消失

01:02:50.269 --> 01:02:56.630
消除碰撞，这就是我们的方法

01:02:52.969 --> 01:03:00.120
我们使用这个添加缓冲区到一个

01:02:56.630 --> 01:03:04.080
我们结合这些

01:03:00.120 --> 01:03:06.810
在两个这样的部分中，然后

01:03:04.080 --> 01:03:08.730
我们只是检查第一个是

01:03:06.810 --> 01:03:12.020
与第二个不同，然后我们

01:03:08.730 --> 01:03:15.950
知道何时从艺术转变为某些

01:03:12.020 --> 01:03:20.520
好吧，只是为了证明我不是

01:03:15.950 --> 01:03:25.590
和你开玩笑，这就是

01:03:20.520 --> 01:03:28.860
代码，所以就在那里战斗

01:03:25.590 --> 01:03:31.740
我最新的边界框

01:03:28.860 --> 01:03:34.950
他们是否相交，我有点

01:03:31.740 --> 01:03:37.530
将它们成对绑定两个，我检查

01:03:34.950 --> 01:03:40.620
是否从碰撞变为非

01:03:37.530 --> 01:03:43.500
整理，然后您知道是否

01:03:40.620 --> 01:03:46.200
从如果是碰撞我改变

01:03:43.500 --> 01:03:49.860
表现出心脏，如果它回到非

01:03:46.200 --> 01:03:53.970
系数我再次显示太阳

01:03:49.860 --> 01:03:58.700
播放一点音乐好吧，在这里你

01:03:53.970 --> 01:04:06.270
再看一次，我的意思是进口

01:03:58.700 --> 01:04:13.250
比实际的代码及其

01:04:06.270 --> 01:04:16.260
非常简单的代码很好，这是

01:04:13.250 --> 01:04:19.800
我在这里使用的其他运算符是

01:04:16.260 --> 01:04:22.790
上行链路缓冲区，那么它是做什么的

01:04:19.800 --> 01:04:28.830
让您知道它会破坏流

01:04:22.790 --> 01:04:34.890
像这样，但像我一样

01:04:28.830 --> 01:04:38.690
说代码真的很短， 

01:04:34.890 --> 01:04:43.230
简单且几乎一样短

01:04:38.690 --> 01:04:46.590
进口清单几乎与

01:04:43.230 --> 01:04:50.010
该代码证明了

01:04:46.590 --> 01:04:52.560
结束，我们只是水管工，只有我们垂手

01:04:50.010 --> 01:04:59.460
用代码代替管道

01:04:52.560 --> 01:05:02.480
如果你想拥有一个

01:04:59.460 --> 01:05:06.450
有关于RX的信息RX是

01:05:02.480 --> 01:05:11.960
提供多种语言和Java版本

01:05:06.450 --> 01:05:14.250
 JavaScript C ++ dotnet目标C和

01:05:11.960 --> 01:05:18.630
黑暗的溪流是

01:05:14.250 --> 01:05:23.250
到我们的X，然后Dale也

01:05:18.630 --> 01:05:27.030
这是我们前任使用的一个很好的例子

01:05:23.250 --> 01:05:29.550
游戏和她的照片都是作品

01:05:27.030 --> 01:05:33.540
更漂亮的她使用魔法小马和

01:05:29.550 --> 01:05:39.150
所以在哪里我使用盒装的简单盒子

01:05:33.540 --> 01:05:41.400
蛇，所以是的，我想我有点

01:05:39.150 --> 01:05:43.860
随着时间的流逝，所以我希望

01:05:41.400 --> 01:05:45.210
还有那些想要

01:05:43.860 --> 01:05:48.570
问问题

01:05:45.210 --> 01:05:49.710
哦，是的，我来引用这句话

01:05:48.570 --> 01:05:52.410
几个问题，如果你不介意

01:05:49.710 --> 01:05:54.960
回答第一个音符，对不起

01:05:52.410 --> 01:05:55.290
我有点没事了，我们很好

01:05:54.960 --> 01:05:57.990
接着就，随即

01:05:55.290 --> 01:06:00.300
虽然有一些是

01:05:57.990 --> 01:06:02.280
有点脱离上下文，但其中之一

01:06:00.300 --> 01:06:06.770
他们被称为可观察的和非

01:06:02.280 --> 01:06:09.300
离散事件生成器，好吧

01:06:06.770 --> 01:06:12.210
实际上让我说这没有

01:06:09.300 --> 01:06:14.640
不好的问题，所以我爱一个新生

01:06:12.210 --> 01:06:20.550
这个很有趣所以让我好一点

01:06:14.640 --> 01:06:22.500
回到我的代码在这里，以及什么

01:06:20.550 --> 01:06:25.230
你看这里，然后我可以

01:06:22.500 --> 01:06:28.290
解释一下，这个家伙是做什么的

01:06:25.230 --> 01:06:32.430
发布它变成了柯尔特观察球

01:06:28.290 --> 01:06:36.200
可以观察到热

01:06:32.430 --> 01:06:40.350
与离散和无关

01:06:36.200 --> 01:06:43.860
与非离散的比较

01:06:40.350 --> 01:06:46.380
在RX中只有离散的东西，所以

01:06:43.860 --> 01:06:51.450
他们是时间的概念是

01:06:46.380 --> 01:06:59.130
如此离散，事件触发并

01:06:51.450 --> 01:07:03.630
所以没有连续的东西

01:06:59.130 --> 01:07:06.570
是的，那里就像有一个

01:07:03.630 --> 01:07:10.520
重播非常特别的版本

01:07:06.570 --> 01:07:16.020
记住最后一个值的主题

01:07:10.520 --> 01:07:18.210
所以你知道那是的

01:07:16.020 --> 01:07:20.370
我会说最接近

01:07:18.210 --> 01:07:21.780
一种你不知道离散事件

01:07:20.370 --> 01:07:24.120
流，但实际上仍然是碎片

01:07:21.780 --> 01:07:25.980
因为你知道唯一的一件事

01:07:24.120 --> 01:07:28.279
真的是，它记得最后一个

01:07:25.980 --> 01:07:32.489
值

01:07:28.279 --> 01:07:34.279
好吧，另一个悬而未决的问题

01:07:32.489 --> 01:07:37.619
一段时间以来，它是著名的

01:07:34.279 --> 01:07:39.749
可观察的收藏询问您是否

01:07:37.619 --> 01:07:43.380
准备在Java上使用还是

01:07:39.749 --> 01:07:47.219
为未来做计划好吧，走吧

01:07:43.380 --> 01:07:50.430
在这里，因为我还没有表现出蛇

01:07:47.219 --> 01:07:52.140
但是如果你看着蛇让我

01:07:50.430 --> 01:07:54.509
将其缩小一点，然后

01:07:52.140 --> 01:07:57.900
它会适合在屏幕上，所以

01:07:54.509 --> 01:08:00.959
你看这里是蛇

01:07:57.900 --> 01:08:03.380
在这里，您会看到蛇模型， 

01:08:00.959 --> 01:08:08.009
蛇形是可观察的

01:08:03.380 --> 01:08:10.619
收集一个可观察的清单

01:08:08.009 --> 01:08:15.329
数据号号码真的是一对

01:08:10.619 --> 01:08:17.520
数字就像没有，在Scala中

01:08:15.329 --> 01:08:21.599
真的可以变成一对

01:08:17.520 --> 01:08:23.759
的数量，但是这个可观察到

01:08:21.599 --> 01:08:26.880
事情真的在那里，不是

01:08:23.759 --> 01:08:35.040
那里有什么，我做什么

01:08:26.880 --> 01:08:38.099
这里和B来一点

01:08:35.040 --> 01:08:39.569
空间，所以在这里我创建的是

01:08:38.099 --> 01:08:41.549
模型，这是可观察的

01:08:39.569 --> 01:08:44.989
集合，然后在这里将其绑定到

01:08:41.549 --> 01:08:49.500
视图，所以我要在折线图上说

01:08:44.989 --> 01:08:50.880
只需添加该模型，然后将其绑定

01:08:49.500 --> 01:08:55.969
认为我不需要做任何事情

01:08:50.880 --> 01:08:55.969
然后我说他们在这里做什么

01:08:56.000 --> 01:09:01.109
将模型转换为可观察的

01:08:58.980 --> 01:09:04.139
收藏，我只想种

01:09:01.109 --> 01:09:06.359
聆听添加的内容

01:09:04.139 --> 01:09:11.009
这种情况是因为对于蛇游戏我

01:09:06.359 --> 01:09:16.529
想知道我什么时候

01:09:11.009 --> 01:09:22.409
添加一些东西，然后这样

01:09:16.529 --> 01:09:25.799
给我一个可观察的和可观察的

01:09:22.409 --> 01:09:29.219
职位列表流

01:09:25.799 --> 01:09:31.290
蛇分开了，所以你现在在这里看到

01:09:29.219 --> 01:09:33.380
很清楚，有模型

01:09:31.290 --> 01:09:38.639
这是我可观察的集合

01:09:33.380 --> 01:09:40.859
将其绑定到正在进行的采访中

01:09:38.639 --> 01:09:41.790
这种情况下我不折线图

01:09:40.859 --> 01:09:44.609
认为

01:09:41.790 --> 01:09:47.339
任何人都认为您可以使用

01:09:44.609 --> 01:09:51.960
折线图，以实现蛇和

01:09:47.339 --> 01:09:54.870
然后这条蛇，我应该用

01:09:51.960 --> 01:10:00.530
非常方便的IntelliJ功能在这里添加

01:09:54.870 --> 01:10:04.560
类型是这里的蛇

01:10:00.530 --> 01:10:07.590
现在可观察到的

01:10:04.560 --> 01:10:10.010
蛇的位置还可以

01:10:07.590 --> 01:10:13.320
还有一点点

01:10:10.010 --> 01:10:17.000
这里的样板，但你看到我得到它

01:10:13.320 --> 01:10:20.220
直接从蛇模型和

01:10:17.000 --> 01:10:22.290
那么其余的我们在这里说

01:10:20.220 --> 01:10:23.790
这就是这里发生的事情

01:10:22.290 --> 01:10:26.130
你知道你看到我在听

01:10:23.790 --> 01:10:28.920
键盘在这里，它上下

01:10:26.130 --> 01:10:31.680
然后你看到我在这里

01:10:28.920 --> 01:10:33.930
更新模型，所以这真的

01:10:31.680 --> 01:10:35.850
跟随我在哪里展示的图片

01:10:33.930 --> 01:10:39.240
你知道那里有模型

01:10:35.850 --> 01:10:43.920
查看，我有点更新模型

01:10:39.240 --> 01:10:51.780
根据我进出的事件

01:10:43.920 --> 01:10:54.180
的变化，我可以，是的，我

01:10:51.780 --> 01:10:56.190
会说你知道这是

01:10:54.180 --> 01:10:58.290
可观察的集合，你知道这是

01:10:56.190 --> 01:11:02.060
与RX无关，这些都在

01:10:58.290 --> 01:11:05.190
 .NET SDK中的Java SDK和

01:11:02.060 --> 01:11:08.730
有件事让我去我的

01:11:05.190 --> 01:11:20.150
如果您在互联网世界中，请滑动

01:11:08.730 --> 01:11:24.590
还有反应式用户界面和

01:11:20.150 --> 01:11:28.020
这全都基于

01:11:24.590 --> 01:11:29.700
基于演示的可观察集合，因此

01:11:28.020 --> 01:11:34.770
或我在这里展示给你的东西

01:11:29.700 --> 01:11:38.280
保罗，这家伙好吗

01:11:34.770 --> 01:11:42.330
一个真正的框架，然后他们

01:11:38.280 --> 01:11:44.910
用它来和你一样

01:11:42.330 --> 01:11:50.820
做同样的事情，这实际上是关于

01:11:44.910 --> 01:11:55.550
和可观察到的这种结合

01:11:50.820 --> 01:11:58.920
集合和可观察流

01:11:55.550 --> 01:12:01.470
所以我想这就是我的简短回答

01:11:58.920 --> 01:12:04.230
答案是可以的，我认为它们是真实的， 

01:12:01.470 --> 01:12:06.840
许多框架已经完成，并且

01:12:04.230 --> 01:12:09.810
但要记住的是

01:12:06.840 --> 01:12:12.000
它们是对RX OD的补充

01:12:09.810 --> 01:12:14.450
可观察的集合是

01:12:12.000 --> 01:12:17.580
您可以变异的实际集合

01:12:14.450 --> 01:12:20.220
然后您可以观察他们的变化， 

01:12:17.580 --> 01:12:22.560
您使用rx处理的那些更改和

01:12:20.220 --> 01:12:25.380
然后您可以将它们作为新的

01:12:22.560 --> 01:12:27.410
可观察连接的突变

01:12:25.380 --> 01:12:32.060
这就是你得到这个周期的方式， 

01:12:27.410 --> 01:12:36.420
这使你使你的代码

01:12:32.060 --> 01:12:39.120
好，很好的问题，我认为就是这样

01:12:36.420 --> 01:12:43.950
其他我们可以跟进的我

01:12:39.120 --> 01:12:45.450
认为我们现在可以总结一下，所以

01:12:43.950 --> 01:12:47.100
一些关于一些问题

01:12:45.450 --> 01:12:49.700
链接以及将提供的链接

01:12:47.100 --> 01:12:52.790
好吧，让我偷

01:12:49.700 --> 01:12:56.820
从你的屏幕第二秒钟好吧

01:12:52.790 --> 01:12:59.250
所以我们只是

01:12:56.820 --> 01:13:01.770
首先有

01:12:59.250 --> 01:13:04.050
埃里克非常非常感谢你

01:13:01.770 --> 01:13:05.700
演示文稿，我知道我们参加了

01:13:04.050 --> 01:13:07.260
有点过分，所以我希望你

01:13:05.700 --> 01:13:10.830
不太介意，但确实

01:13:07.260 --> 01:13:14.610
太好了，远不止您想像的

01:13:10.830 --> 01:13:16.980
我不介意的人

01:13:14.610 --> 01:13:19.740
几乎所有人都挂了

01:13:16.980 --> 01:13:22.620
出去，所以我几乎非常感兴趣

01:13:19.740 --> 01:13:24.660
因此，只需注意几个

01:13:22.620 --> 01:13:28.020
 Twitter上的反应式扩展是一个很好的选择

01:13:24.660 --> 01:13:32.040
帐户以跟随RX其他文档的

01:13:28.020 --> 01:13:35.490
虽然它们是Java API，但它们非常

01:13:32.040 --> 01:13:39.600
很好，我认为可以教好狗

01:13:35.490 --> 01:13:42.810
关于反应式扩展和Eric的内容

01:13:39.600 --> 01:13:45.420
网站应用对偶冷静，我认为

01:13:42.810 --> 01:13:46.950
一旦我们提供记录

01:13:45.420 --> 01:13:48.960
将在youtube.com上将其

01:13:46.950 --> 01:13:52.380
大脑电视也将跟进

01:13:48.960 --> 01:13:54.720
博客文章以及这些链接和

01:13:52.380 --> 01:13:58.140
埃里克（Eric）与来源一起发送的

01:13:54.720 --> 01:13:59.760
代码等，所以Eric再次感谢您

01:13:58.140 --> 01:14:03.440
非常感谢大家

01:13:59.760 --> 01:14:08.300
参加并希望下次见

01:14:03.440 --> 01:14:08.300
再见再见再见

