WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.250 --> 00:00:12.800
让我们开始吧，尽管我

00:00:07.910 --> 00:00:15.260
将向您展示有关ARCA的一些基础知识

00:00:12.800 --> 00:00:18.320
演员，我要给你看一些

00:00:15.260 --> 00:00:25.509
我们介绍的新八块冰

00:00:18.320 --> 00:00:31.579
在ARCA for Java 8中

00:00:25.509 --> 00:00:34.970
从介绍自己开始，所以我的

00:00:31.579 --> 00:00:37.640
名字是u1和Riaan，我是一名开发人员

00:00:34.970 --> 00:00:41.530
我在瑞典斯德哥尔摩工作

00:00:37.640 --> 00:00:44.949
 Akka核心团队中的乐队

00:00:41.530 --> 00:00:47.660
在加入Lichtman之前，我曾在

00:00:44.949 --> 00:00:51.949
 Scala的咨询和指导

00:00:47.660 --> 00:00:55.129
和akka和play框架以及之前

00:00:51.949 --> 00:01:00.909
我有很多经验

00:00:55.129 --> 00:01:02.829
 Java平台，这就是关于我的

00:01:00.909 --> 00:01:04.699
在我开始谈论之前

00:01:02.829 --> 00:01:08.620
我特别要说一点

00:01:04.699 --> 00:01:13.070
关于背景或我所看到的

00:01:08.620 --> 00:01:17.330
 Akka的一些很好的理由

00:01:13.070 --> 00:01:24.290
有用的，也许还有一些

00:01:17.330 --> 00:01:29.030
我之所以存在的原因

00:01:24.290 --> 00:01:32.900
电脑处理器的曙光

00:01:29.030 --> 00:01:36.010
时钟速度已基本提高， 

00:01:32.900 --> 00:01:38.690
每年都在增加

00:01:36.010 --> 00:01:43.700
我写的那个单线程程序

00:01:38.690 --> 00:01:48.140
去年更快，这是事实

00:01:43.700 --> 00:01:51.470
直到大约2005年为止

00:01:48.140 --> 00:01:57.950
您可以在此图中看到它完成

00:01:51.470 --> 00:02:03.050
有点变平了，所以发生了什么

00:01:57.950 --> 00:02:06.580
那一点好，我们到了这一点

00:02:03.050 --> 00:02:11.210
能源效率不高的地方

00:02:06.580 --> 00:02:15.940
保持时钟实用

00:02:11.210 --> 00:02:15.940
周期越来越短，所以

00:02:15.980 --> 00:02:25.819
然后，处理器制造商开始

00:02:18.800 --> 00:02:28.280
当然，我们创建具有更多内核的CPU 

00:02:25.819 --> 00:02:30.349
在哪里吃过这个免费的午餐

00:02:28.280 --> 00:02:34.099
我们的程序越来越快

00:02:30.349 --> 00:02:36.080
否则我们可能会变得越来越懒惰

00:02:34.099 --> 00:02:42.170
程序员和我们的程序，但无论如何

00:02:36.080 --> 00:02:46.790
运行非常迅速，但在这一点上，我们

00:02:42.170 --> 00:02:51.200
真的不能达到这样的速度

00:02:46.790 --> 00:02:53.930
免费改进了，所以我们有

00:02:51.200 --> 00:03:02.360
开始使用线程编写程序

00:02:53.930 --> 00:03:06.110
只是这样，我们将不得不结构

00:03:02.360 --> 00:03:09.049
我们的程序有所不同，我们会

00:03:06.110 --> 00:03:14.599
必须开始使用线程原语

00:03:09.049 --> 00:03:19.150
利用整个CPU世界

00:03:14.599 --> 00:03:21.980
使我们的CPU绑定处理更快

00:03:19.150 --> 00:03:25.130
所以这是我发生的一件事

00:03:21.980 --> 00:03:31.010
甚至会说近年来

00:03:25.130 --> 00:03:33.650
虽然不是最近

00:03:31.010 --> 00:03:37.090
改变的是一对夫妇

00:03:33.650 --> 00:03:42.500
几年前，然后是典型的

00:03:37.090 --> 00:03:46.310
服务设置将是一台服务器

00:03:42.500 --> 00:03:51.079
和故障转移也许所以我们可以

00:03:46.310 --> 00:03:56.239
节省甚至继续经营我们的业务

00:03:51.079 --> 00:03:57.950
虽然我们的小学会下降，我们

00:03:56.239 --> 00:04:01.340
可能有几百个

00:03:57.950 --> 00:04:03.410
千名用户，每个用户

00:04:01.340 --> 00:04:05.769
每个设备可能有一台电脑

00:04:03.410 --> 00:04:09.349
他们将通过以下方式访问我们的系统

00:04:05.769 --> 00:04:14.090
所以如果我们快进到今天

00:04:09.349 --> 00:04:16.820
已经有所改变，因此用户将

00:04:14.090 --> 00:04:19.489
更多，您将拥有更多的用户，并且

00:04:16.820 --> 00:04:23.570
每个用户可能有一堆设备

00:04:19.489 --> 00:04:26.650
 XS的维修服务及其

00:04:23.570 --> 00:04:29.180
期望也发生了很大变化

00:04:26.650 --> 00:04:32.990
所以

00:04:29.180 --> 00:04:35.990
他们可能会去竞争对手

00:04:32.990 --> 00:04:38.930
他们不得不等待也许

00:04:35.990 --> 00:04:41.180
五秒钟或他们的期望

00:04:38.930 --> 00:04:47.240
始终可用的服务有

00:04:41.180 --> 00:04:52.490
完全改变了，所以我会有点状态

00:04:47.240 --> 00:04:56.000
我们需要抽象来编写

00:04:52.490 --> 00:04:59.389
同时满足需求的应用程序

00:04:56.000 --> 00:05:01.940
更好地使用一台机器来

00:04:59.389 --> 00:05:05.419
实际利用所有这些课程

00:05:01.940 --> 00:05:09.250
而且能够建立系统

00:05:05.419 --> 00:05:12.440
可以使用多个服务器

00:05:09.250 --> 00:05:19.849
简单的方式或易于实现的方式

00:05:12.440 --> 00:05:23.020
回到学术的原因是

00:05:19.849 --> 00:05:27.500
建立并发和

00:05:23.020 --> 00:05:32.270
分布式应用程序不是

00:05:27.500 --> 00:05:36.020
框架对许多人来说是不同的

00:05:32.270 --> 00:05:38.470
针对的其他技术

00:05:36.020 --> 00:05:44.300
同一群人

00:05:38.470 --> 00:05:46.430
更少的东西告诉你

00:05:44.300 --> 00:05:49.220
如何构建系统以及如何

00:05:46.430 --> 00:05:53.030
建立您的架构以及更多

00:05:49.220 --> 00:05:55.669
拿起非常有用的工具箱

00:05:53.030 --> 00:05:58.520
与您需要时使用的工具不同

00:05:55.669 --> 00:06:03.590
建立一个可以扩展许多规模的系统

00:05:58.520 --> 00:06:06.020
当然还有很多电脑

00:06:03.590 --> 00:06:08.180
我们有演员的工具箱是什么

00:06:06.020 --> 00:06:10.430
我们今天要讲，我们也

00:06:08.180 --> 00:06:16.630
有东西叫做阿卡溪流

00:06:10.430 --> 00:06:24.889
我们有一个HTTP服务器和其他一些

00:06:16.630 --> 00:06:27.500
它是用Scala编写的好工具，但是

00:06:24.889 --> 00:06:31.099
每个功能都有四个

00:06:27.500 --> 00:06:33.169
也是一个作业API，所以即使

00:06:31.099 --> 00:06:36.400
内部构件是用Scala编写的

00:06:33.169 --> 00:06:38.900
可以使用Java的所有部分

00:06:36.400 --> 00:06:41.029
在本次演讲中，我们将专门

00:06:38.900 --> 00:06:42.920
看演员，所以我们不会涉及太多

00:06:41.029 --> 00:06:47.330
其他的

00:06:42.920 --> 00:06:51.110
有趣的是

00:06:47.330 --> 00:06:54.950
还有一个dotnet porta baka，所以如果你在

00:06:51.110 --> 00:06:59.090
 dotnet CLR您还可以使用一个密钥

00:06:54.950 --> 00:07:06.950
来自C Sharp或其他语言

00:06:59.090 --> 00:07:10.760
好的，所以演员介绍了演员

00:07:06.950 --> 00:07:14.030
或由一个叫

00:07:10.760 --> 00:07:17.330
与彼得·毕晓普一起给休伊特打电话

00:07:14.030 --> 00:07:22.030
和1973年的理查德·史特雷格

00:07:17.330 --> 00:07:26.450
关于模型的学术论文

00:07:22.030 --> 00:07:28.730
使用参与者的并发计算

00:07:26.450 --> 00:07:34.340
在并发的通用原语

00:07:28.730 --> 00:07:40.150
预突变抱歉计算这是

00:07:34.340 --> 00:07:42.760
然后在1986年与Erlang一起实施

00:07:40.150 --> 00:07:44.590
认为那是更著名的之一

00:07:42.760 --> 00:07:48.770
角色模型的实现

00:07:44.590 --> 00:07:54.790
除了raka然后akka成立于

00:07:48.770 --> 00:07:58.550
 2009年以来，您一直在这样做

00:07:54.790 --> 00:08:05.240
 2009年到现在已经七年了

00:07:58.550 --> 00:08:07.070
绝不是一个年轻的框架

00:08:05.240 --> 00:08:10.070
有人说我仍然会声称

00:08:07.070 --> 00:08:12.200
我们正在向前迈进

00:08:10.070 --> 00:08:14.510
节奏，所以它也不是根本

00:08:12.200 --> 00:08:19.640
因为

00:08:14.510 --> 00:08:24.860
在我们后面有这几年，那是什么

00:08:19.640 --> 00:08:27.380
演员演员是普通演员

00:08:24.860 --> 00:08:30.890
常规类的实例，因此您可以编写

00:08:27.380 --> 00:08:33.290
 Reg完全是普通班，但是那里

00:08:30.890 --> 00:08:37.850
互动方式有很大不同

00:08:33.290 --> 00:08:42.520
与它以及其他对象如何相互作用

00:08:37.850 --> 00:08:44.780
有了它，所以拥有的唯一方法

00:08:42.520 --> 00:08:48.800
与演员交流和互动

00:08:44.780 --> 00:08:52.310
是通过消息来使演员

00:08:48.800 --> 00:08:54.860
做一些事情，你给它发送一条消息

00:08:52.310 --> 00:08:56.709
信息再次完全是你

00:08:54.860 --> 00:09:02.089
普通班

00:08:56.709 --> 00:09:03.829
但是它必须是不变的，因为我们

00:09:02.089 --> 00:09:06.920
将通过同步发送

00:09:03.829 --> 00:09:09.860
边界，我们一开始就做

00:09:06.920 --> 00:09:13.779
使用可变数据，您将不得不

00:09:09.860 --> 00:09:17.199
同步它们，它将回到此

00:09:13.779 --> 00:09:20.149
威胁原语的复杂世界

00:09:17.199 --> 00:09:24.230
所以当演员收到消息时

00:09:20.149 --> 00:09:28.009
可以做四件事，可以发送消息

00:09:24.230 --> 00:09:31.670
对于其他演员，它可以改变自己的角色

00:09:28.009 --> 00:09:35.959
说明它可以改变其行为方式

00:09:31.670 --> 00:09:41.870
将对以下消息做出反应，它

00:09:35.959 --> 00:09:44.660
可以创造更多的演员，所以我认为

00:09:41.870 --> 00:09:48.290
是我们停止看幻灯片的地方，而我

00:09:44.660 --> 00:09:55.490
将向您显示的一些代码示例

00:09:48.290 --> 00:10:01.029
演员，所以我准备了这个Java 

00:09:55.490 --> 00:10:04.579
项目，所以首先我想告诉你

00:10:01.029 --> 00:10:08.029
因为就像我告诉你的那样

00:10:04.579 --> 00:10:10.639
保持另一个框架存在

00:10:08.029 --> 00:10:12.680
不像微内核或其他任何东西

00:10:10.639 --> 00:10:15.949
您在它之上运行应用程序

00:10:12.680 --> 00:10:20.389
只是一个常规的依赖项，所以您加入

00:10:15.949 --> 00:10:22.850
在您的Maven项目中像这样的演员

00:10:20.389 --> 00:10:26.990
然后您可以决定在

00:10:22.850 --> 00:10:29.360
您的应用程序的一部分或

00:10:26.990 --> 00:10:33.889
在其上构建整个应用程序

00:10:29.360 --> 00:10:39.860
完全取决于你

00:10:33.889 --> 00:10:42.220
让我们简单地看一下我是否可以

00:10:39.860 --> 00:10:42.220
打开这个

00:10:47.980 --> 00:11:00.690
那很奇怪，所以我们要

00:10:56.320 --> 00:11:04.650
首先我告诉你演员可以

00:11:00.690 --> 00:11:06.880
通过更改其状态来响应消息

00:11:04.650 --> 00:11:10.210
所以我们将开始写为

00:11:06.880 --> 00:11:13.540
完全符合我的演员

00:11:10.210 --> 00:11:15.880
会在这里使用一些技巧

00:11:13.540 --> 00:11:17.250
也许你希望看到的

00:11:15.880 --> 00:11:20.590
下面

00:11:17.250 --> 00:11:24.150
部分原因是我没有花所有的钱

00:11:20.590 --> 00:11:26.800
编写Java但也要部分保留它

00:11:24.150 --> 00:11:30.450
简短而简洁，我可以证明

00:11:26.800 --> 00:11:35.170
在一个屏幕上，所以不要感到沮丧

00:11:30.450 --> 00:11:39.390
关于非惯用的Java代码，所以我

00:11:35.170 --> 00:11:43.210
从创建一个新的类开始

00:11:39.390 --> 00:11:48.900
这是我们的柜台，并使其成为

00:11:43.210 --> 00:11:52.060
演员我要扩展抽象演员

00:11:48.900 --> 00:11:54.810
来自街机或望远镜

00:11:52.060 --> 00:11:59.020
包，实际上我要扩展

00:11:54.810 --> 00:12:01.440
通过这样做我们抽象的采伐演员

00:11:59.020 --> 00:12:04.810
将免费获得记录器，因此我们可以

00:12:01.440 --> 00:12:09.370
轻松地从中写入一些输出

00:12:04.810 --> 00:12:12.370
演员，接下来我们要做的是

00:12:09.370 --> 00:12:16.060
就是定义一个协议，所以我告诉你

00:12:12.370 --> 00:12:18.700
我们通过与演员沟通

00:12:16.060 --> 00:12:21.370
通过消息，所以现在我们要

00:12:18.700 --> 00:12:26.080
定义消息或消息

00:12:21.370 --> 00:12:28.900
这个演员会接受，这是

00:12:26.080 --> 00:12:31.810
其实是我那种地方

00:12:28.900 --> 00:12:35.370
怪异的习惯是个好主意，所以

00:12:31.810 --> 00:12:41.980
定义协议的好主意

00:12:35.370 --> 00:12:44.800
演员离他们的阶级太近了

00:12:41.980 --> 00:12:46.600
在这种情况下，哪个协议适用

00:12:44.800 --> 00:12:50.100
我将在内部定义它们

00:12:46.600 --> 00:12:50.100
演员美学课

00:12:52.589 --> 00:12:59.500
所以我要定义班级信息

00:12:55.329 --> 00:13:03.070
我只是我不会让它拥有

00:12:59.500 --> 00:13:05.320
我们里面的任何数据

00:13:03.070 --> 00:13:11.110
会用它来触发一个计数器

00:13:05.320 --> 00:13:13.510
会随着时间的推移增加，然后

00:13:11.110 --> 00:13:15.339
我要定义一个初始化块

00:13:13.510 --> 00:13:18.339
这是您可能会遇到的一个例子

00:13:15.339 --> 00:13:20.230
不是您可能不会做的常规Java 

00:13:18.339 --> 00:13:21.010
代码，但这就像默认值

00:13:20.230 --> 00:13:25.180
建设者

00:13:21.010 --> 00:13:28.630
因此，在此构造函数块中，我们将调用

00:13:25.180 --> 00:13:30.870
接收和接收需要一些东西

00:13:28.630 --> 00:13:35.320
被称为虚函数

00:13:30.870 --> 00:13:37.600
学者构造，但建立之一

00:13:35.320 --> 00:13:39.639
那些我们有一个Java API，所以我们要

00:13:37.600 --> 00:13:44.860
使用一种叫做接收的东西

00:13:39.639 --> 00:13:48.070
就像建造者

00:13:44.860 --> 00:13:52.510
模式，您已经看到了一千

00:13:48.070 --> 00:13:56.339
我猜到Java土地之前的时间和

00:13:52.510 --> 00:13:56.339
有了这个接收器，我们可以定义

00:13:56.940 --> 00:14:03.790
我们将在

00:14:01.120 --> 00:14:06.730
演员，在这种情况下，我们要说

00:14:03.790 --> 00:14:11.069
比赛，然后我们要说每个

00:14:06.730 --> 00:14:15.490
时间有这个班级的消息

00:14:11.069 --> 00:14:18.430
调用此函数或方法

00:14:15.490 --> 00:14:26.170
我们将其定义为方法

00:14:18.430 --> 00:14:29.130
这样处理，然后我要

00:14:26.170 --> 00:14:29.130
定义这个方法

00:14:35.620 --> 00:14:38.800
像那样

00:14:38.899 --> 00:14:44.810
最后我还需要

00:14:42.980 --> 00:14:50.029
我需要实际构建的构建器

00:14:44.810 --> 00:14:52.879
当然是这样，然后我说我们

00:14:50.029 --> 00:14:56.269
要保持一个新的泰特州，所以我要

00:14:52.879 --> 00:15:01.250
添加一个私有整数

00:14:56.269 --> 00:15:03.860
像这样的计数器然后当我们得到一个

00:15:01.250 --> 00:15:09.470
消息，我们将增加

00:15:03.860 --> 00:15:11.620
柜台，我也要登录信息

00:15:09.470 --> 00:15:14.529
消息只是为了使这一点更多

00:15:11.620 --> 00:15:22.370
互动性好看

00:15:14.529 --> 00:15:26.620
所以你增加柜台，然后我

00:15:22.370 --> 00:15:30.379
像这样打印值

00:15:26.620 --> 00:15:34.970
所以现在我们定义了协议

00:15:30.379 --> 00:15:38.689
国家演员的逻辑我们

00:15:34.970 --> 00:15:41.809
现在需要的是实际创建演员

00:15:38.689 --> 00:15:44.120
为此，我们需要做两件事

00:15:41.809 --> 00:15:49.160
第一件事就是所谓的道具

00:15:44.120 --> 00:15:54.470
道具就像一个描述符

00:15:49.160 --> 00:15:58.610
演员将描述哪个班级

00:15:54.470 --> 00:16:00.199
演员已关闭，它将描述其他

00:15:58.610 --> 00:16:03.589
我不会去的属性

00:16:00.199 --> 00:16:08.930
触摸此网络研讨会，但看起来

00:16:03.589 --> 00:16:13.569
我们称之为道具不创造，然后

00:16:08.930 --> 00:16:19.759
我们给它上课，所以在我们的情况下

00:16:13.569 --> 00:16:22.370
反点课一个很好的习惯是

00:16:19.759 --> 00:16:25.040
为此创建一个工厂，因为如果

00:16:22.370 --> 00:16:28.819
我们将构造函数参数添加到我们的

00:16:25.040 --> 00:16:31.610
演员，你看到自己，这是

00:16:28.819 --> 00:16:33.730
使用反射或一些技巧

00:16:31.610 --> 00:16:35.959
实例化，然后我们将有一个

00:16:33.730 --> 00:16:39.620
运行时异常

00:16:35.959 --> 00:16:42.889
可能是编译时异常的权利

00:16:39.620 --> 00:16:45.310
所以如果我添加了一个字符串构造函数

00:16:42.889 --> 00:16:47.260
计数器参数

00:16:45.310 --> 00:16:50.190
我很容易忘记添加它

00:16:47.260 --> 00:16:52.600
我实际在哪里的道具实例

00:16:50.190 --> 00:16:53.680
描述您如何创建演员，以便

00:16:52.600 --> 00:16:57.460
好工厂

00:16:53.680 --> 00:16:59.560
一个好习惯是定义一个道具

00:16:57.460 --> 00:17:02.200
工厂，这是我要做的

00:16:59.560 --> 00:17:07.030
很多次，所以我定义了这个直播

00:17:02.200 --> 00:17:09.579
 IntelliJ 4中的模板就像这样

00:17:07.030 --> 00:17:12.130
这样我将有一个更近的地方

00:17:09.579 --> 00:17:14.079
到实际的构造函数，我在哪里

00:17:12.130 --> 00:17:16.150
我记得最后添加了

00:17:14.079 --> 00:17:19.300
参数，但在我们的情况下，我们没有

00:17:16.150 --> 00:17:23.770
参数好，所以现在我们有办法

00:17:19.300 --> 00:17:26.410
制作演员不喜欢的道具

00:17:23.770 --> 00:17:28.750
只是我们不实例化它

00:17:26.410 --> 00:17:30.940
我们自己就像一个普通的物体，所以这

00:17:28.750 --> 00:17:34.150
与常规相比有很大的不同

00:17:30.940 --> 00:17:37.060
对象，我们使用演员系统，所以

00:17:34.150 --> 00:17:39.790
演员生病的周期必将

00:17:37.060 --> 00:17:41.920
当我们拍摄演员时，这个演员系统

00:17:39.790 --> 00:17:44.620
系统崩溃，所有演员都会停下来

00:17:41.920 --> 00:17:48.610
例子，所以我将开始

00:17:44.620 --> 00:17:55.540
创建为此创建一个实例

00:17:48.610 --> 00:18:00.460
像这样的演员系统演员系统点

00:17:55.540 --> 00:18:04.950
创建我可以给它命名下一个像这样

00:18:00.460 --> 00:18:10.060
然后使用系统

00:18:04.950 --> 00:18:13.150
演员带道具，在那里

00:18:10.060 --> 00:18:14.860
是它的两个两个变体

00:18:13.150 --> 00:18:17.230
只有两个道具，一个需要

00:18:14.860 --> 00:18:19.390
我稍后会回到名字

00:18:17.230 --> 00:18:21.790
但这几乎总是一个好主意

00:18:19.390 --> 00:18:24.310
给它起个名字，所以现在我要

00:18:21.790 --> 00:18:26.140
将此柜台称为道具厂

00:18:24.310 --> 00:18:29.950
方法，然后我要给它一个

00:18:26.140 --> 00:18:34.170
命名计数器，以便我们在创建演员时

00:18:29.950 --> 00:18:38.560
离开这个演员，我们回来了

00:18:34.170 --> 00:18:44.500
与演员互动的单一方式

00:18:38.560 --> 00:18:46.659
叫做女演员好吗

00:18:44.500 --> 00:18:50.260
如果我们看起来可以做些什么

00:18:46.659 --> 00:18:54.280
如果真的没有演员的话

00:18:50.260 --> 00:18:58.210
这么多的方法和最有趣的

00:18:54.280 --> 00:19:02.530
一个是告诉，告诉将发送一个

00:18:58.210 --> 00:19:06.580
给这位演员的信息，我们将创建

00:19:02.530 --> 00:19:09.630
此处有新消息计数器点消息

00:19:06.580 --> 00:19:12.340
像这样创建一个新实例

00:19:09.630 --> 00:19:14.980
然后它用第二个参数

00:19:12.340 --> 00:19:17.679
谁发送了消息但

00:19:14.980 --> 00:19:21.669
在这种情况下，我们实际上并没有

00:19:17.679 --> 00:19:26.620
发送者，我们有一个主线程，那里

00:19:21.669 --> 00:19:30.520
抓住任何答复是没有逻辑的

00:19:26.620 --> 00:19:34.390
在这里，所以我们将使用演员，如果不知道

00:19:30.520 --> 00:19:36.640
发件人的灯像这样好，让我们来

00:19:34.390 --> 00:19:42.429
尝试并四舍五入看看它是超级

00:19:36.640 --> 00:19:44.140
基本示例好，所以我们可以看到我们

00:19:42.429 --> 00:19:48.750
增加了一个日志条目

00:19:44.140 --> 00:19:51.970
柜台，所以这似乎不是很

00:19:48.750 --> 00:19:53.490
惊人或特别，因为你可以

00:19:51.970 --> 00:19:57.460
刚刚提出了一种方法，可以

00:19:53.490 --> 00:20:01.330
增加柜台权，那是什么

00:19:57.460 --> 00:20:05.230
有趣的是，这完全是

00:20:01.330 --> 00:20:08.110
避免并发

00:20:05.230 --> 00:20:14.159
的观点，所以我们实际上可以做一个

00:20:08.110 --> 00:20:14.159
这样循环，我们将创建5个线程

00:20:16.770 --> 00:20:28.900
这样或实际上我可以用一个

00:20:19.750 --> 00:20:37.720
 lambda然后哦，实际上是让我们

00:20:28.900 --> 00:20:42.039
无论如何都要这样做，然后在每个

00:20:37.720 --> 00:20:46.840
线程，我们将做另一个for循环，所以

00:20:42.039 --> 00:20:51.480
从每个线程我们将发送5 

00:20:46.840 --> 00:20:56.110
消息，我们将开始所有这一切

00:20:51.480 --> 00:20:57.780
马上就这样，所以这是一个

00:20:56.110 --> 00:21:01.650
常规方法会

00:20:57.780 --> 00:21:04.760
将不安全，因为增加

00:21:01.650 --> 00:21:07.890
计数器不是原子的，所以实际上

00:21:04.760 --> 00:21:10.530
包括读取

00:21:07.890 --> 00:21:12.240
值，然后将数字添加到

00:21:10.530 --> 00:21:16.650
值，然后写入值和

00:21:12.240 --> 00:21:20.340
还有与之相关的可见性

00:21:16.650 --> 00:21:24.780
 Java内存重构将使

00:21:20.340 --> 00:21:27.120
它可以使我们失去增量

00:21:24.780 --> 00:21:30.720
我们将使用常规方法执行此操作

00:21:27.120 --> 00:21:35.610
和不可变的变量，所以现在如果我运行

00:21:30.720 --> 00:21:42.290
这你应该看到我们得到了

00:21:35.610 --> 00:21:46.790
计数器最终增加到25 

00:21:42.290 --> 00:21:51.200
所以这是一个非常基本的例子

00:21:46.790 --> 00:21:59.010
在演员内部具有可变状态

00:21:51.200 --> 00:22:01.650
让我们继续另一个示例，我

00:21:59.010 --> 00:22:04.380
也说花蜜可以

00:22:01.650 --> 00:22:07.170
对消息做出反应是

00:22:04.380 --> 00:22:09.780
改变它的行为，让我们做一个

00:22:07.170 --> 00:22:15.000
样本就是那个，我

00:22:09.780 --> 00:22:19.200
有这个想法，这是一个警报，所以我们

00:22:15.000 --> 00:22:24.660
要创建一个新的演员

00:22:19.200 --> 00:22:28.230
称为警报，它扩展了抽象

00:22:24.660 --> 00:22:32.780
记录演员，然后获取一些记录

00:22:28.230 --> 00:22:32.780
我们将定义一些协议消息

00:22:33.110 --> 00:22:41.660
首先是活动，所以有

00:22:38.760 --> 00:22:44.540
发生了什么事，有一个传感器

00:22:41.660 --> 00:22:47.940
告诉我们发生了什么事

00:22:44.540 --> 00:22:51.120
该警报所在的房子里

00:22:47.940 --> 00:22:56.120
安装，然后我们有

00:22:51.120 --> 00:22:56.120
禁用警报权限的可能性

00:22:59.270 --> 00:23:05.040
要禁用警报，您将需要一个

00:23:02.520 --> 00:23:07.700
密码，因为如果我们没有

00:23:05.040 --> 00:23:10.679
密码，然后小偷将能够

00:23:07.700 --> 00:23:11.580
只需关闭闹钟，当它响起时

00:23:10.679 --> 00:23:15.900
关

00:23:11.580 --> 00:23:19.530
而且我们还希望有一条消息

00:23:15.900 --> 00:23:21.300
用于启用警报，这将

00:23:19.530 --> 00:23:22.710
也请正确输入密码，因为我们

00:23:21.300 --> 00:23:26.910
不想让一个孩子

00:23:22.710 --> 00:23:34.920
不小心关掉警报器

00:23:26.910 --> 00:23:39.000
这样，现在我们将拥有

00:23:34.920 --> 00:23:44.670
需要为

00:23:39.000 --> 00:23:47.010
报警，所以我要添加某种

00:23:44.670 --> 00:23:55.620
恒定在这里，然后我们将它

00:23:47.010 --> 00:23:58.140
这样给客户，然后我可以

00:23:55.620 --> 00:24:02.040
立即创建道具工厂

00:23:58.140 --> 00:24:05.450
我之前告诉过你，它也会

00:24:02.040 --> 00:24:05.450
取下密码

00:24:05.870 --> 00:24:18.360
将其传递给实际的构造函数

00:24:09.800 --> 00:24:22.860
那么我们将有两种行为，所以

00:24:18.360 --> 00:24:26.430
第一个你不确定管道

00:24:22.860 --> 00:24:30.150
但是第一个是当警报

00:24:26.430 --> 00:24:39.060
已启用，另一个是当

00:24:30.150 --> 00:24:43.200
实际的管道已禁用警报

00:24:39.060 --> 00:24:46.260
就像我以前给你看的一样

00:24:43.200 --> 00:24:50.000
建立了最初的行为

00:24:46.260 --> 00:24:54.420
第一个样本只是部分函数

00:24:50.000 --> 00:24:55.380
从对象到盒子单位

00:24:54.420 --> 00:25:00.860
有点奇怪

00:24:55.380 --> 00:25:00.860
但这就是它的样子

00:25:02.690 --> 00:25:08.060
我把它们定下来，因为我们

00:25:06.320 --> 00:25:09.380
要定义它们，它们永远不会

00:25:08.060 --> 00:25:12.160
会发抖，她只会

00:25:09.380 --> 00:25:16.190
在这两个编辑器之间切换

00:25:12.160 --> 00:25:18.740
然后我可以说

00:25:16.190 --> 00:25:22.190
我们将开始的警报构造函数

00:25:18.740 --> 00:25:27.370
与残疾人权利，我们不想

00:25:22.190 --> 00:25:31.070
警报打开，我们安装警报

00:25:27.370 --> 00:25:35.600
好吧，现在让我们定义一下

00:25:31.070 --> 00:25:41.980
使用接收构造接收

00:25:35.600 --> 00:25:48.250
生成器，我们将匹配活动和

00:25:41.980 --> 00:25:48.250
那么我们将在活动上调用一个方法

00:25:48.520 --> 00:25:58.220
像这样，然后它将得到

00:25:54.620 --> 00:26:02.120
活动作为消息，我做了

00:25:58.220 --> 00:26:05.450
消息为空，不包含任何消息

00:26:02.120 --> 00:26:09.640
状态，因此我们实际上忽略了忽略

00:26:05.450 --> 00:26:13.960
所以我可以称之为忽略它

00:26:09.640 --> 00:26:18.350
让我们看看我是否奇怪地拼写了一些东西

00:26:13.960 --> 00:26:23.140
是的，我很抱歉我无法拼写活动

00:26:18.350 --> 00:26:28.550
像这样，当我们得到脖子的定性

00:26:23.140 --> 00:26:30.140
然后我们会发出警报，所以我

00:26:28.550 --> 00:26:40.910
要为此使用警告，它是

00:26:30.140 --> 00:26:42.710
像这样真的会成为警报

00:26:40.910 --> 00:26:45.830
那么我们还有另一件事可以

00:26:42.710 --> 00:26:49.100
当我们启用警报时发生

00:26:45.830 --> 00:26:54.560
那就是我们得到的信息

00:26:49.100 --> 00:26:58.720
禁用它，所以我要创建

00:26:54.560 --> 00:26:58.720
这样的另一个禁用方法

00:27:03.360 --> 00:27:13.240
这次我们实际上将拥有

00:27:07.090 --> 00:27:15.309
一些我们里面会有一些数据

00:27:13.240 --> 00:27:18.220
禁用消息，因为我们有

00:27:15.309 --> 00:27:24.580
密码正确，所以我们将要检查

00:27:18.220 --> 00:27:28.539
如果我们拥有的密码等于

00:27:24.580 --> 00:27:33.940
消息中的密码是这样的， 

00:27:28.539 --> 00:27:38.110
如果是这样，我们将获得上下文和

00:27:33.940 --> 00:27:43.360
变得如此，我们将变得像

00:27:38.110 --> 00:27:48.240
好吧，如果不是，那绝对是

00:27:43.360 --> 00:27:53.110
希望清楚清楚

00:27:48.240 --> 00:27:58.510
像这样的残疾人，如果没有，我们将有

00:27:53.110 --> 00:28:05.789
此日志警告不认识的人

00:27:58.510 --> 00:28:08.919
密码尝试像这样禁用它

00:28:05.789 --> 00:28:12.399
然后最后我们要

00:28:08.919 --> 00:28:19.870
他们叫倾斜来实际构造

00:28:12.399 --> 00:28:21.760
这个接收接收块，然后

00:28:19.870 --> 00:28:27.399
我们要说的是大胆的

00:28:21.760 --> 00:28:33.330
被接收生成器点匹配，匹配为

00:28:27.399 --> 00:28:33.330
将只启用点类

00:28:34.320 --> 00:28:42.340
这样启用，因为如果有

00:28:38.649 --> 00:28:44.950
闹钟关闭时的活动

00:28:42.340 --> 00:28:47.409
那我们就不在乎

00:28:44.950 --> 00:28:49.840
什么时候都不会发生

00:28:47.409 --> 00:28:53.279
禁用警报时

00:28:49.840 --> 00:28:53.279
当我们尝试启用它

00:28:58.550 --> 00:29:10.660
再次，我们将检查

00:29:01.880 --> 00:29:15.440
密码是正确的，然后我们将

00:29:10.660 --> 00:29:22.040
启用与我联系的方式相同

00:29:15.440 --> 00:29:25.670
启用，如果密码

00:29:22.040 --> 00:29:29.120
是错的，那可能不是

00:29:25.670 --> 00:29:32.180
像试图禁用的人一样认真

00:29:29.120 --> 00:29:34.400
密码错误的警报

00:29:32.180 --> 00:29:38.810
我们只是要向某人提供信息

00:29:34.400 --> 00:29:43.460
无法启用已启用的B警报

00:29:38.810 --> 00:29:46.870
像这样好，然后最后在这里

00:29:43.460 --> 00:29:50.900
我们将调用构建完成

00:29:46.870 --> 00:29:53.960
收到所以现在我们已经创建了一个演员

00:29:50.900 --> 00:29:55.940
有两种不同的行为

00:29:53.960 --> 00:29:58.880
将在这些行为之间切换

00:29:55.940 --> 00:30:05.140
对消息的反应，让我们玩

00:29:58.880 --> 00:30:08.300
大约与它使用系统

00:30:05.140 --> 00:30:15.230
创建actor actor的实例

00:30:08.300 --> 00:30:20.860
用道具，我们有一个

00:30:15.230 --> 00:30:24.530
密码，我们也给它起一个名字

00:30:20.860 --> 00:30:27.200
像这样报警，然后我们抓住

00:30:24.530 --> 00:30:29.420
演员，如果我们回来，那是

00:30:27.200 --> 00:30:34.040
实际上是警报，所以我们称之为

00:30:29.420 --> 00:30:38.930
报警好，然后我们发送一些

00:30:34.040 --> 00:30:46.250
这些消息中，所以我们将从

00:30:38.930 --> 00:30:49.640
活动表明开始

00:30:46.250 --> 00:30:51.140
退出此禁用模式，然后我们

00:30:49.640 --> 00:30:57.230
要启用它，但我们要

00:30:51.140 --> 00:31:02.240
使用错误的密码，然后我们将

00:30:57.230 --> 00:31:05.330
然后使用正确的密码启用它

00:31:02.240 --> 00:31:09.920
报警时我们会做一些活动

00:31:05.330 --> 00:31:11.929
已启用，那么我们将尝试禁用

00:31:09.920 --> 00:31:17.490
闹钟

00:31:11.929 --> 00:31:19.590
使用错误的密码，最后我们

00:31:17.490 --> 00:31:23.570
将禁用带有右侧的警报

00:31:19.590 --> 00:31:31.320
密码，然后触发一些活动

00:31:23.570 --> 00:31:35.580
好吧，让我们运行它，看看

00:31:31.320 --> 00:31:37.920
发生，所以我们可以看到有人

00:31:35.580 --> 00:31:40.710
无法启用警报

00:31:37.920 --> 00:31:42.480
我们收到的第一个日志消息实际上

00:31:40.710 --> 00:31:44.820
在那之前有活动，但是

00:31:42.480 --> 00:31:49.080
由于警报已禁用，我们没有

00:31:44.820 --> 00:31:50.820
 vlog任何东西，然后我们启用

00:31:49.080 --> 00:31:53.400
报警，然后有活动，所以它

00:31:50.820 --> 00:31:55.440
触发警报，然后有人尝试

00:31:53.400 --> 00:31:58.169
使用禁用通过的警报

00:31:55.440 --> 00:31:59.910
错误的密码，我们禁用了Anila 

00:31:58.169 --> 00:32:04.580
然后我们可以看到活动

00:31:59.910 --> 00:32:07.620
最后发送没有触发警报

00:32:04.580 --> 00:32:10.260
好的，再说一次，这就是

00:32:07.620 --> 00:32:12.690
在这种情况下我要做的事情

00:32:10.260 --> 00:32:16.440
从一个线程来看不是很令人印象深刻

00:32:12.690 --> 00:32:18.480
也许但事实是我们可以发送

00:32:16.440 --> 00:32:20.400
这些消息来自

00:32:18.480 --> 00:32:23.490
整个JVM，这将是完全安全的

00:32:20.400 --> 00:32:29.220
我觉得这令人印象深刻

00:32:23.490 --> 00:32:37.950
好的，让我们回到一点

00:32:29.220 --> 00:32:40.620
幻灯片，所以我提到我们创建了

00:32:37.950 --> 00:32:42.660
有名字的演员，但我没有

00:32:40.620 --> 00:32:45.179
提到什么在什么情况下

00:32:42.660 --> 00:32:48.450
那很有用或者这个名字叫什么

00:32:45.179 --> 00:32:51.450
这意味着演员被安排在一个

00:32:48.450 --> 00:32:53.880
创建演员时的等级

00:32:51.450 --> 00:32:56.220
直接从系统将生存

00:32:53.880 --> 00:32:59.700
在用户Guardian下

00:32:56.220 --> 00:33:04.220
永远存在的演员是由

00:32:59.700 --> 00:33:06.960
系统启动时，我们给

00:33:04.220 --> 00:33:09.510
方法参与者的第二个参数

00:33:06.960 --> 00:33:13.230
它将使用该参数作为名称

00:33:09.510 --> 00:33:18.059
演员内部的这个演员层次

00:33:13.230 --> 00:33:19.740
我们可以称呼获取上下文为演员

00:33:18.059 --> 00:33:24.330
在这种情况下，我们正在创建一个演员

00:33:19.740 --> 00:33:25.320
将是我们演员的孩子，所以

00:33:24.330 --> 00:33:28.799
有生命

00:33:25.320 --> 00:33:31.950
周期的种类绑定到今天的部门

00:33:28.799 --> 00:33:34.830
就是说如果我们停止我的演员

00:33:31.950 --> 00:33:37.590
那样也会阻止我的孩子，所以我的

00:33:34.830 --> 00:33:41.789
孩子的生存期永远不会超过

00:33:37.590 --> 00:33:43.559
在此层次结构中的父级

00:33:41.789 --> 00:33:50.850
意味着很特别的东西

00:33:43.559 --> 00:33:53.490
关于失败处理，所以我会

00:33:50.850 --> 00:33:56.659
首先从重要开始

00:33:53.490 --> 00:34:01.610
区别，这个区别是

00:33:56.659 --> 00:34:05.190
错误验证错误与失败

00:34:01.610 --> 00:34:08.069
所以在系统中有验证

00:34:05.190 --> 00:34:12.540
错误，可以验证一些错误

00:34:08.069 --> 00:34:15.929
来自不受信任来源的输入，这是

00:34:12.540 --> 00:34:19.050
将会属于

00:34:15.929 --> 00:34:21.300
错误处理或逻辑

00:34:19.050 --> 00:34:22.859
这个actor中的方法，如果它是一个

00:34:21.300 --> 00:34:25.500
例外，那将是一个尝试

00:34:22.859 --> 00:34:28.290
捕获该非法数字格式

00:34:25.500 --> 00:34:30.139
另一方面，失败的例子

00:34:28.290 --> 00:34:35.190
是演员无法做到的

00:34:30.139 --> 00:34:37.710
实际上对付自己

00:34:35.190 --> 00:34:39.510
可能与数据库有关的示例

00:34:37.710 --> 00:34:43.919
可能是连接超时

00:34:39.510 --> 00:34:46.649
例外，所以在

00:34:43.919 --> 00:34:48.960
常规的Java代码将抛出该错误

00:34:46.649 --> 00:34:50.819
异常向外，你将有

00:34:48.960 --> 00:34:53.069
一些业务逻辑层

00:34:50.819 --> 00:34:54.869
不知道该怎么办

00:34:53.069 --> 00:34:56.700
超时异常，因此将其抛出

00:34:54.869 --> 00:34:59.160
向外，然后你将有一个

00:34:56.700 --> 00:35:01.430
表示层，完全没有

00:34:59.160 --> 00:35:04.859
知道如何处理连接错误

00:35:01.430 --> 00:35:10.710
连接失败，因此它将记录它并

00:35:04.859 --> 00:35:13.260
显示失败页面的用户，因此使用ACTA我们

00:35:10.710 --> 00:35:18.540
有这个想法，我们应该改为

00:35:13.260 --> 00:35:20.280
尝试将故障发送到某处

00:35:18.540 --> 00:35:23.160
在可以的地方很有用

00:35:20.280 --> 00:35:26.790
实际上对它采取行动，所以这叫做

00:35:23.160 --> 00:35:31.349
消息到达时的监督

00:35:26.790 --> 00:35:33.390
演员，并触发异常

00:35:31.349 --> 00:35:35.760
异常未陷入逻辑

00:35:33.390 --> 00:35:37.830
演员会去的父母

00:35:35.760 --> 00:35:39.990
演员和

00:35:37.830 --> 00:35:43.260
演员的父母将有机会

00:35:39.990 --> 00:35:49.800
决定由于

00:35:43.260 --> 00:35:52.890
这种失败及其可能发生的事情

00:35:49.800 --> 00:35:56.220
决定之间是说孩子

00:35:52.890 --> 00:35:58.620
应该恢复，这意味着它

00:35:56.220 --> 00:36:00.750
应该继续处理消息，但是

00:35:58.620 --> 00:36:05.570
忽略这一点，因为当前

00:36:00.750 --> 00:36:05.570
消息是由某些错误引起的

00:36:05.750 --> 00:36:10.830
另一个选择是它可以重新启动

00:36:08.400 --> 00:36:13.650
孩子，所以这对孩子很有用

00:36:10.830 --> 00:36:18.350
具有状态，并且可能

00:36:13.650 --> 00:36:22.230
状态因

00:36:18.350 --> 00:36:26.520
因为失败所以这会

00:36:22.230 --> 00:36:29.850
使儿童演员停止演出并

00:36:26.520 --> 00:36:32.310
一个新实例将启动，并且任何

00:36:29.850 --> 00:36:35.970
演员，如果有人要这个演员

00:36:32.310 --> 00:36:40.470
从外面将导致

00:36:35.970 --> 00:36:42.420
给这个新开始的演员的任何消息

00:36:40.470 --> 00:36:44.100
在邮箱中，除了

00:36:42.420 --> 00:36:47.640
导致失败的将是

00:36:44.100 --> 00:36:50.070
由这个新演员处理，所以这是一个

00:36:47.640 --> 00:36:53.100
真的很整洁的东西，例如

00:36:50.070 --> 00:36:54.990
数据库连接断开，我们可以启动一个

00:36:53.100 --> 00:36:58.200
新演员，这将启动一个新的

00:36:54.990 --> 00:37:02.040
如果可能的话，将使

00:36:58.200 --> 00:37:04.650
系统在某种程度上自我修复

00:37:02.040 --> 00:37:08.730
情况没有真实存在

00:37:04.650 --> 00:37:10.380
没有办法处理失败和

00:37:08.730 --> 00:37:12.990
唯一的选择就是停止，所以这是

00:37:10.380 --> 00:37:16.440
另一种选择

00:37:12.990 --> 00:37:18.180
父母处理这个例外

00:37:16.440 --> 00:37:20.130
例如，如果有

00:37:18.180 --> 00:37:22.680
从中抛出的异常

00:37:20.130 --> 00:37:24.690
默认情况下的构造函数，如果

00:37:22.680 --> 00:37:26.850
无法创建该实例

00:37:24.690 --> 00:37:29.700
演员因为错误而不会

00:37:26.850 --> 00:37:31.350
非常不可能

00:37:29.700 --> 00:37:35.640
创建一个新的实例

00:37:31.350 --> 00:37:38.810
会好的，我有一个选择

00:37:35.640 --> 00:37:41.310
没有在这张幻灯片上显示

00:37:38.810 --> 00:37:43.500
升级意味着我不知道

00:37:41.310 --> 00:37:46.170
为此，我会将其传递给我

00:37:43.500 --> 00:37:49.410
父母和我父母将决定如何

00:37:46.170 --> 00:37:52.490
但是要注意，在这种情况下

00:37:49.410 --> 00:37:57.240
那会影响到整个

00:37:52.490 --> 00:37:59.250
在这里的服装关键是一个或多个

00:37:57.240 --> 00:38:01.350
层次结构的一部分，所以在这种情况下

00:37:59.250 --> 00:38:05.010
当火山爆发在

00:38:01.350 --> 00:38:07.500
孩子，如果我愿意通过那个例外

00:38:05.010 --> 00:38:10.550
随着升级而上升，这意味着

00:38:07.500 --> 00:38:16.380
用户监护节点的决定

00:38:10.550 --> 00:38:18.780
需要四个人进行监督会影响

00:38:16.380 --> 00:38:23.990
演员的整个子树

00:38:18.780 --> 00:38:27.750
层次结构好吧，因此， 

00:38:23.990 --> 00:38:29.670
对于建立深深的耳朵来说很重要

00:38:27.750 --> 00:38:30.870
关键，而不是我们的白色层次结构

00:38:29.670 --> 00:38:33.120
想

00:38:30.870 --> 00:38:34.860
我们系统中可以

00:38:33.120 --> 00:38:37.160
重新启动，然后将工作，如果

00:38:34.860 --> 00:38:39.990
出问题了而不是

00:38:37.160 --> 00:38:45.870
完整的东西与整体的东西

00:38:39.990 --> 00:38:48.030
系统出现故障，好让我们看看

00:38:45.870 --> 00:38:50.850
我在这里错过了一些东西

00:38:48.030 --> 00:38:53.070
如果我们停止反应堆， 

00:38:50.850 --> 00:38:56.130
发送消息的活动点

00:38:53.070 --> 00:38:57.990
去演员那里有这个特别

00:38:56.130 --> 00:39:00.300
目的地innaka，称为

00:38:57.990 --> 00:39:03.060
死信办公室，实际上是

00:39:00.300 --> 00:39:06.030
真正的邮局有的东西

00:39:03.060 --> 00:39:07.770
这是一个你不写字母的地方

00:39:06.030 --> 00:39:09.600
了解收件人或

00:39:07.770 --> 00:39:12.660
收件人不存在了，我们去

00:39:09.600 --> 00:39:16.020
因此，使用ARCA，这意味着他们将

00:39:12.660 --> 00:39:17.700
被记录在系统日志中

00:39:16.020 --> 00:39:23.930
有关他们去向的信息

00:39:17.700 --> 00:39:26.880
但这是很有用的

00:39:23.930 --> 00:39:29.220
当有什么不对劲的时候

00:39:26.880 --> 00:39:30.320
可以看到哪个演员不在

00:39:29.220 --> 00:39:34.470
不再

00:39:30.320 --> 00:39:41.820
好吧，让我们来玩一下

00:39:34.470 --> 00:39:45.180
在代码中实际执行此操作，因此在示例中

00:39:41.820 --> 00:39:48.750
 3我在这里准备了一点

00:39:45.180 --> 00:39:54.570
创造一个不能被信任的孩子

00:39:48.750 --> 00:39:58.230
因此在此示例中它将接受

00:39:54.570 --> 00:40:00.150
类型命令的消息及其何时

00:39:58.230 --> 00:40:03.410
得到命令，它将增加

00:40:00.150 --> 00:40:06.300
柜台，如果那

00:40:03.410 --> 00:40:09.600
消息被四等分

00:40:06.300 --> 00:40:14.220
它将在运行时引发异常

00:40:09.600 --> 00:40:15.720
如果不是设备级别，则为异常

00:40:14.220 --> 00:40:18.420
四，我们只会看到我们有一个

00:40:15.720 --> 00:40:20.160
评论，然后我们有道具

00:40:18.420 --> 00:40:24.600
就像我告诉你的一样

00:40:20.160 --> 00:40:28.040
之前然后我们要创建这个

00:40:24.600 --> 00:40:29.910
演员不是从这个主要方法

00:40:28.040 --> 00:40:33.510
应用程序，但相反，我们要

00:40:29.910 --> 00:40:35.960
从另一个演员那里做，所以我实际上

00:40:33.510 --> 00:40:38.400
要将其变为抽象

00:40:35.960 --> 00:40:43.890
像以前的伐木演员一样得到一些

00:40:38.400 --> 00:40:47.520
用于记录和

00:40:43.890 --> 00:40:57.090
然后当它开始时，我们要做

00:40:47.520 --> 00:41:01.230
让上下文演员脱颖而出

00:40:57.090 --> 00:41:05.010
这样的比喻之子，让我们给它一个

00:41:01.230 --> 00:41:06.830
九个名字的孩子很棒，然后

00:41:05.010 --> 00:41:10.770
我们将继续引用它

00:41:06.830 --> 00:41:13.260
像这样，然后对于任何传入

00:41:10.770 --> 00:41:16.350
我们得到这个主管的信息

00:41:13.260 --> 00:41:20.190
只是要把它传递给孩子，所以

00:41:16.350 --> 00:41:30.750
这意味着我们叫接收然后

00:41:20.190 --> 00:41:37.800
我们使用接收构建器，我们匹配

00:41:30.750 --> 00:41:40.500
在任何消息上，我们只是将其传递给

00:41:37.800 --> 00:41:44.310
给孩子，我们可以做到这一点

00:41:40.500 --> 00:41:47.070
特殊的特殊方法

00:41:44.310 --> 00:41:50.040
用于告诉发送消息给演员和

00:41:47.070 --> 00:41:53.180
我将带一个汇编器，以便

00:41:50.040 --> 00:41:56.730
演员可以回复，但是在此

00:41:53.180 --> 00:41:59.070
如果孩子愿意，我们希望

00:41:56.730 --> 00:42:00.690
选择回覆寄件者，我们会

00:41:59.070 --> 00:42:03.390
像这样成为原始发件人

00:42:00.690 --> 00:42:06.300
而不是父母，那么我们可以

00:42:03.390 --> 00:42:08.850
请改用此前进方法

00:42:06.300 --> 00:42:13.460
只是把这个信息转发给孩子

00:42:08.850 --> 00:42:13.460
然后我们传递这个礼物上下文

00:42:14.230 --> 00:42:24.070
演员的背景，然后我们

00:42:17.170 --> 00:42:26.200
这样建造，所以现在我们有了

00:42:24.070 --> 00:42:29.230
像我一样创造了这个英雄T 

00:42:26.200 --> 00:42:31.930
告诉你我们将拥有这个

00:42:29.230 --> 00:42:34.420
像该用户这样的用户监护人和

00:42:31.930 --> 00:42:36.430
然后我们会有这个演员

00:42:34.420 --> 00:42:39.340
尚未真正创建，但我们会

00:42:36.430 --> 00:42:41.200
从主要方法创建它，我们

00:42:39.340 --> 00:42:45.640
已经创造了一个孩子，所以这个孩子会

00:42:41.200 --> 00:42:51.460
在这方面有完整的路径

00:42:45.640 --> 00:42:53.860
演员在这里好吧好吧，然后其他

00:42:51.460 --> 00:42:56.200
我们需要做的就是定义这个

00:42:53.860 --> 00:42:58.660
监管策略是什么

00:42:56.200 --> 00:43:01.930
当孩子扔一个

00:42:58.660 --> 00:43:07.210
例外，为此，我们将覆盖

00:43:01.930 --> 00:43:11.200
一种称为监督策略的方法

00:43:07.210 --> 00:43:14.680
它应该返回监督

00:43:11.200 --> 00:43:21.940
策略，有两种基本的

00:43:14.680 --> 00:43:26.710
他们有一个，我很抱歉

00:43:21.940 --> 00:43:30.880
一个将决定我们

00:43:26.710 --> 00:43:36.070
我们做出了例外

00:43:30.880 --> 00:43:41.200
我们会将其应用于我们所有

00:43:36.070 --> 00:43:42.970
孩子，这在大多数情况下就像

00:43:41.200 --> 00:43:46.480
这不是我们想要处理的

00:43:42.970 --> 00:43:49.180
每个孩子都有一个孩子

00:43:46.480 --> 00:43:52.270
自己的，但我们可能有某种

00:43:49.180 --> 00:43:55.960
某种共享共享上下文

00:43:52.270 --> 00:43:58.450
一些想法是没有用的

00:43:55.960 --> 00:44:01.660
如果我们必须停下来，孩子们还活着

00:43:58.450 --> 00:44:03.130
例如其中之一，但在这种情况下

00:44:01.660 --> 00:44:07.090
我们将一一使用

00:44:03.130 --> 00:44:11.500
策略，这将需要一些

00:44:07.090 --> 00:44:15.970
参数第一个是多少

00:44:11.500 --> 00:44:19.840
重试将这样做，如果演员

00:44:15.970 --> 00:44:23.610
如果我们再说一次重启按钮， 

00:44:19.840 --> 00:44:27.610
这么多，所以说十倍

00:44:23.610 --> 00:44:30.640
在特定时间内

00:44:27.610 --> 00:44:34.750
那么我们会放弃，因为

00:44:30.640 --> 00:44:35.680
显然没有人习惯尝试

00:44:34.750 --> 00:44:38.680
运行这个

00:44:35.680 --> 00:44:41.970
注意这里的小事

00:44:38.680 --> 00:44:44.860
容易出错的是

00:44:41.970 --> 00:44:46.690
持续时间来自skål关于并发

00:44:44.860 --> 00:44:52.840
持续时间，而不是新工作

00:44:46.690 --> 00:44:57.340
一次ApS好，所以我们要说

00:44:52.840 --> 00:44:59.350
它在十秒钟内十次，所以如果它

00:44:57.340 --> 00:45:01.060
在十秒钟内失败十次以上

00:44:59.350 --> 00:45:05.470
然后它将放弃，只是停止

00:45:01.060 --> 00:45:08.320
孩子，然后我们有最后一件事

00:45:05.470 --> 00:45:10.870
这又是部分函数， 

00:45:08.320 --> 00:45:17.260
同样，我们为此有一个特殊的建造者

00:45:10.870 --> 00:45:21.760
 innaka，所以我们现在在那里

00:45:17.260 --> 00:45:29.230
大脑大脑冻结了我们的大脑

00:45:21.760 --> 00:45:38.140
有战略建设者，我们有

00:45:29.230 --> 00:45:45.310
监管策略构建者现在我们有了

00:45:38.140 --> 00:45:47.290
决策者对不起，决定

00:45:45.310 --> 00:45:50.260
生成器的工作方式与接收完全相同

00:45:47.290 --> 00:45:53.500
生成器，它将与一个类匹配

00:45:50.260 --> 00:45:55.390
这是一个例外，所以在这种情况下，我

00:45:53.500 --> 00:45:57.640
告诉你规范对此不信任

00:45:55.390 --> 00:45:59.200
会抛出运行时的孩子

00:45:57.640 --> 00:46:04.180
例外，因此我们将对此进行匹配

00:45:59.200 --> 00:46:06.460
运行时异常在这里，然后当我们

00:46:04.180 --> 00:46:08.590
得到这个例外，我们有机会

00:46:06.460 --> 00:46:11.230
看起来更近一点，也许看一下

00:46:08.590 --> 00:46:13.780
消息或某些特定标志

00:46:11.230 --> 00:46:17.560
在例外之内，但在这种情况下

00:46:13.780 --> 00:46:20.020
我们只是要返回一些东西

00:46:17.560 --> 00:46:22.060
调用指令说我们想要

00:46:20.020 --> 00:46:25.150
重新启动，或者我们想开始

00:46:22.060 --> 00:46:29.440
很快就可以访问那些我只是

00:46:25.150 --> 00:46:32.040
要在这里使用捷径策略

00:46:29.440 --> 00:46:34.240
我要静态导入

00:46:32.040 --> 00:46:38.680
存在于其中的策略

00:46:34.240 --> 00:46:40.580
主管战略课，现在我们

00:46:38.680 --> 00:46:47.390
将有机会追求

00:46:40.580 --> 00:46:49.910
我像我一样开始停车和凯雷德

00:46:47.390 --> 00:46:52.400
描述，所以让我们开始重新启动

00:46:49.910 --> 00:46:58.660
在这里，看看如何解决，然后

00:46:52.400 --> 00:47:04.850
最后需要实际构建

00:46:58.660 --> 00:47:08.260
是的，在这种情况下，决策者也是如此

00:47:04.850 --> 00:47:10.430
我们实际上不是

00:47:08.260 --> 00:47:12.260
改变任何东西或取决于

00:47:10.430 --> 00:47:16.510
演员里面的任何东西肯定

00:47:12.260 --> 00:47:19.940
我们本可以将此策略定义为

00:47:16.510 --> 00:47:23.570
静态字段以避免创建新字段

00:47:19.940 --> 00:47:31.250
每次，我都会

00:47:23.570 --> 00:47:39.260
要做那并提取常数

00:47:31.250 --> 00:47:41.060
所以现在我们要创建的每个实例

00:47:39.260 --> 00:47:43.250
主管将具有相同的

00:47:41.060 --> 00:47:47.230
战略，但一切都是一成不变的

00:47:43.250 --> 00:47:49.970
在这里，这没问题，所以

00:47:47.230 --> 00:47:52.250
最后的难题是

00:47:49.970 --> 00:47:57.250
创建主管的实例，并

00:47:52.250 --> 00:48:00.830
运行它，所以我们做一个系统参与者

00:47:57.250 --> 00:48:02.740
主管，我没有创造道具

00:48:00.830 --> 00:48:09.940
工厂对不起

00:48:02.740 --> 00:48:09.940
所以我就这样偷偷溜进去

00:48:10.630 --> 00:48:19.420
主管点道具等等然后我会

00:48:17.090 --> 00:48:24.410
捕获到一个称为

00:48:19.420 --> 00:48:29.480
提供者，然后我们将为

00:48:24.410 --> 00:48:33.680
循环发送一堆消息，例如

00:48:29.480 --> 00:48:36.440
所以主管不告诉发送

00:48:33.680 --> 00:48:40.040
消息，现在实际的协议是

00:48:36.440 --> 00:48:44.210
在不信任中定义

00:48:40.040 --> 00:48:47.560
孩子，所以它将是一个新的非

00:48:44.210 --> 00:48:50.300
可信赖的孩子不是这样的命令

00:48:47.560 --> 00:48:53.360
再次，我们在这里没有发件人

00:48:50.300 --> 00:48:55.060
主线程，所以我们只是通过这个行为

00:48:53.360 --> 00:48:57.560
没有儿子的其余部分

00:48:55.060 --> 00:48:59.619
好吧，让我们运行它，看看

00:48:57.560 --> 00:48:59.619
发生

00:49:03.020 --> 00:49:07.849
这样我们可以看到孩子的狗

00:49:05.810 --> 00:49:09.829
学习了一个命令得到了一个命令

00:49:07.849 --> 00:49:12.950
命令，然后我们到达一个号码

00:49:09.829 --> 00:49:16.010
被四等分，所以我会

00:49:12.950 --> 00:49:18.530
引发异常，此错误是

00:49:16.010 --> 00:49:22.730
由最终主管实际记录

00:49:18.530 --> 00:49:24.470
因此，如果我们查看实际的

00:49:22.730 --> 00:49:27.760
不值得信任的孩子，它不会登录

00:49:24.470 --> 00:49:32.599
任何只是抛出异常的东西

00:49:27.760 --> 00:49:34.940
然后发生了什么，我们突然之间

00:49:32.599 --> 00:49:39.020
有一个新的实例在这里运行

00:49:34.940 --> 00:49:41.450
不信任或将登录的孩子

00:49:39.020 --> 00:49:44.869
三个命令，然后均匀地

00:49:41.450 --> 00:49:47.839
设备”由三个人构建，那么我们如何

00:49:44.869 --> 00:49:50.450
让这一点更加清楚，我将添加

00:49:47.839 --> 00:49:53.810
这个柜台在这里，所以我们实际上可以看到

00:49:50.450 --> 00:49:57.470
它将重置好，让我们运行它

00:49:53.810 --> 00:49:59.599
再次，您可以看到我们已经

00:49:57.470 --> 00:50:01.849
命令一来评论三， 

00:49:59.599 --> 00:50:05.119
然后它得到了第四，然后

00:50:01.849 --> 00:50:07.280
它应该重新启动后，我们有一个新的

00:50:05.119 --> 00:50:09.650
为每个孩子建立新的不信任关系

00:50:07.280 --> 00:50:14.900
重新开始，所以状态一直

00:50:09.650 --> 00:50:24.109
重置让我们看看如果我们

00:50:14.900 --> 00:50:29.560
改用简历好吧，所以我们可以看到

00:50:24.109 --> 00:50:32.240
我们得到异常消息

00:50:29.560 --> 00:50:35.780
被记录为磨损而不是错误

00:50:32.240 --> 00:50:37.849
恢复异常是

00:50:35.780 --> 00:50:40.339
然后它将继续，并且它具有

00:50:37.849 --> 00:50:42.170
状态保持不变，所以我们将从五个继续

00:50:40.339 --> 00:50:44.210
还有六个和七个然后是

00:50:42.170 --> 00:50:46.640
再次将圣经平均除以四， 

00:50:44.210 --> 00:50:48.310
然后我们将继续向上

00:50:46.640 --> 00:50:54.579
州

00:50:48.310 --> 00:50:57.829
让我们也尝试停止策略

00:50:54.579 --> 00:51:02.270
这将成为第一个例外

00:50:57.829 --> 00:51:04.250
发生，演员将被停止， 

00:51:02.270 --> 00:51:07.320
再次，我们得到一个错误日志，因为

00:51:04.250 --> 00:51:09.750
相当公平

00:51:07.320 --> 00:51:12.930
认真的，然后我们可以看到

00:51:09.750 --> 00:51:16.670
以下消息，他们将去什么

00:51:12.930 --> 00:51:20.370
我之前说过那封信q 

00:51:16.670 --> 00:51:25.920
所以我们可以看到它原本打算去

00:51:20.370 --> 00:51:27.900
给用户主管孩子，但是有

00:51:25.920 --> 00:51:34.140
没有这样的孩子，是它去了

00:51:27.900 --> 00:51:37.050
死信Q好的，如果我们升级

00:51:34.140 --> 00:51:46.440
这是第四个

00:51:37.050 --> 00:51:50.430
完成，我们可以看到它甚至是

00:51:46.440 --> 00:51:53.550
本来打算对不起我的消息

00:51:50.430 --> 00:51:56.010
没说是有一个

00:51:53.550 --> 00:51:59.520
默认策略已安装，因此如果我们

00:51:56.010 --> 00:52:01.620
不要定义它，基本上

00:51:59.520 --> 00:52:05.390
构造函数中的异常将停止

00:52:01.620 --> 00:52:08.690
演员，孩子和其他任何演员

00:52:05.390 --> 00:52:10.830
当演员是

00:52:08.690 --> 00:52:17.070
处理一条消息将需要

00:52:10.830 --> 00:52:23.460
重新启动，所以在这种情况下，我们将获得

00:52:17.070 --> 00:52:31.320
主管重新启动，让我们回到

00:52:23.460 --> 00:52:36.390
幻灯片这实际上是怎么发生的

00:52:31.320 --> 00:52:38.970
他们很好，每个演员都有一个邮箱

00:52:36.390 --> 00:52:41.490
这有点排队，所以当你

00:52:38.970 --> 00:52:44.910
向其发送将包含的消息

00:52:41.490 --> 00:52:47.430
进入那个队列，这将导致

00:52:44.910 --> 00:52:49.860
演员被安排在某事上

00:52:47.430 --> 00:52:53.870
称为调度员及其调度员

00:52:49.860 --> 00:52:56.640
本质上是一个线程池或

00:52:53.870 --> 00:53:02.430
 Java的执行程序服务

00:52:56.640 --> 00:53:04.980
并发触须库

00:53:02.430 --> 00:53:07.950
实际的演员与

00:53:04.980 --> 00:53:10.320
线程，因此当演员不在

00:53:07.950 --> 00:53:14.370
处理一条不会占用的消息

00:53:10.320 --> 00:53:16.380
当演员收到消息时的线程

00:53:14.370 --> 00:53:19.020
将您自身链接到调度程序上

00:53:16.380 --> 00:53:21.270
在某个时候，执行者会

00:53:19.020 --> 00:53:23.610
有一个免费的线程，那将

00:53:21.270 --> 00:53:26.190
让演员执行的过程

00:53:23.610 --> 00:53:29.670
消息，这意味着演员不是

00:53:26.190 --> 00:53:34.220
绑定到特定线程，但可以运行

00:53:29.670 --> 00:53:38.340
在批处理程序上的任何线程上

00:53:34.220 --> 00:53:44.700
默认调度程序用于排队

00:53:38.340 --> 00:53:47.910
池，这意味着

00:53:44.700 --> 00:53:50.100
为消息或消息优化

00:53:47.910 --> 00:53:51.800
没有阻塞的处理

00:53:50.100 --> 00:53:55.890
真的很重要

00:53:51.800 --> 00:54:01.590
了解阿卡，如果你

00:53:55.890 --> 00:54:08.580
要阻止然后默认

00:54:01.590 --> 00:54:12.690
建立线程池是为了缩短CPU绑定时间

00:54:08.580 --> 00:54:17.420
工作，如果你放一些东西，实际上

00:54:12.690 --> 00:54:21.150
等待网络通话或文件系统

00:54:17.420 --> 00:54:22.890
然后那个线程将是

00:54:21.150 --> 00:54:25.440
即使不是

00:54:22.890 --> 00:54:27.060
实际上做正确的事，所以

00:54:25.440 --> 00:54:29.610
差异的数量级

00:54:27.060 --> 00:54:32.160
在处理内存中的内容之间

00:54:29.610 --> 00:54:36.690
等待着即将来临的事情

00:54:32.160 --> 00:54:40.050
通过网络，如果我们有几个

00:54:36.690 --> 00:54:44.580
线程，我们希望这些工作能够

00:54:40.050 --> 00:54:48.930
很短，我们让这些演员

00:54:44.580 --> 00:54:50.460
然后做很长的事情， 

00:54:48.930 --> 00:54:53.340
阻止然后将导致其他

00:54:50.460 --> 00:54:57.420
演员不被允许运行或处理

00:54:53.340 --> 00:55:00.420
他们的信息非常重要

00:54:57.420 --> 00:55:02.910
如果您使用Akka是为了了解什么

00:55:00.420 --> 00:55:06.240
阻止和不隔离

00:55:02.910 --> 00:55:08.010
阻止自己的调度程序

00:55:06.240 --> 00:55:09.870
这将是我的最终样品

00:55:08.010 --> 00:55:14.970
说我已经有点时间了，但是

00:55:09.870 --> 00:55:16.320
我会很快显示出来，所以这次我

00:55:14.970 --> 00:55:22.950
不打算编码，但我要展示

00:55:16.320 --> 00:55:24.210
你这样的联系在一起

00:55:22.950 --> 00:55:28.140
我一直在谈论不同的事情

00:55:24.210 --> 00:55:31.190
关于，但我只专注于

00:55:28.140 --> 00:55:34.770
这个阻塞的部分，所以我创建了一个

00:55:31.190 --> 00:55:36.720
类模拟我

00:55:34.770 --> 00:55:40.680
同步数据库连接

00:55:36.720 --> 00:55:42.300
像JDBC一样，您发出查询，它将

00:55:40.680 --> 00:55:44.250
阻塞线程直到数据库

00:55:42.300 --> 00:55:46.080
服务器已回复，因此没有

00:55:44.250 --> 00:55:49.560
实际处理它只是

00:55:46.080 --> 00:55:52.710
通过等待数据来阻止

00:55:49.560 --> 00:55:55.230
回到插座，所以这是

00:55:52.710 --> 00:55:57.690
由线程模拟在这里不睡觉

00:55:55.230 --> 00:56:00.780
线程不睡觉是非常它看起来非常

00:55:57.690 --> 00:56:02.940
很像一个阻塞操作，因为

00:56:00.780 --> 00:56:05.130
它实际上不会做任何事情

00:56:02.940 --> 00:56:09.860
与线程，但它将占用

00:56:05.130 --> 00:56:13.220
线程，直到这段时间过去为止

00:56:09.860 --> 00:56:20.250
我们要做的隔离类型是

00:56:13.220 --> 00:56:22.800
在我们的应用程序中

00:56:20.250 --> 00:56:25.680
这个应用程序的配置，所以我

00:56:22.800 --> 00:56:29.340
以前没有介绍过，但是有

00:56:25.680 --> 00:56:31.020
 actor中的内置库

00:56:29.340 --> 00:56:33.660
为您挑选配置

00:56:31.020 --> 00:56:36.330
特定格式的应用程序

00:56:33.660 --> 00:56:40.140
看起来有点像JSON，称为Cho 

00:56:36.330 --> 00:56:42.480
看到我认为在这种配置

00:56:40.140 --> 00:56:45.690
文件我们定义了一个阻止

00:56:42.480 --> 00:56:51.300
调度程序，所以有一个单独的线程池

00:56:45.690 --> 00:56:54.060
本质上，我们将其配置为具有

00:56:51.300 --> 00:56:57.020
具体的线程数，我们

00:56:54.060 --> 00:57:00.630
然后当我们有一个阻碍演员

00:56:57.020 --> 00:57:03.080
通过创建

00:57:00.630 --> 00:57:05.520
道具，然后跟调度员说

00:57:03.080 --> 00:57:08.730
这是调度员的名字

00:57:05.520 --> 00:57:10.470
我们在配置文件中定义了

00:57:08.730 --> 00:57:13.590
这样会有一个单独的线程

00:57:10.470 --> 00:57:16.080
为那些阻碍演员和

00:57:13.590 --> 00:57:18.360
其他演员可以在处理过程中搅动

00:57:16.080 --> 00:57:22.530
即使没有问题的消息

00:57:18.360 --> 00:57:24.390
数据库线程池甚至被阻止

00:57:22.530 --> 00:57:26.880
尽管所有这些线程

00:57:24.390 --> 00:57:29.430
封锁其他演员可以做的

00:57:26.880 --> 00:57:32.520
他们想要的东西，我不去

00:57:29.430 --> 00:57:35.640
看更多，我想最后

00:57:32.520 --> 00:57:37.140
样品，所以我想你可以拿一个

00:57:35.640 --> 00:57:44.450
自己看，会有一个

00:57:37.140 --> 00:57:47.300
链接到底是这样

00:57:44.450 --> 00:57:49.760
一些重复的做与不做

00:57:47.300 --> 00:57:53.060
可能会提到我和一些东西

00:57:49.760 --> 00:57:56.510
没提到就不要放所有东西

00:57:53.060 --> 00:57:58.849
用flat胎的钥匙，但使这种

00:57:56.510 --> 00:58:03.170
在这里更深的钥匙，推动危险的工作

00:57:58.849 --> 00:58:05.839
向下，因为那是你可以的

00:58:03.170 --> 00:58:09.710
使较小的零件独立失效

00:58:05.839 --> 00:58:12.230
让他们从失败中恢复过来

00:58:09.710 --> 00:58:15.290
确保隔离阻塞，以便

00:58:12.230 --> 00:58:17.089
你不会影响那些不会的演员

00:58:15.290 --> 00:58:21.140
确实与他们的封锁

00:58:17.089 --> 00:58:23.770
阻止演员，这样一个很好的例子

00:58:21.140 --> 00:58:27.079
是您正在编写Web应用程序，并且

00:58:23.770 --> 00:58:29.300
你有一些演员会称之为

00:58:27.079 --> 00:58:30.980
关系数据库，然后

00:58:29.300 --> 00:58:33.040
实际上拥有所有演员的一些演员

00:58:30.980 --> 00:58:36.770
数据已经在内存中，他们可以

00:58:33.040 --> 00:58:38.599
很快回复请求，所以如果

00:58:36.770 --> 00:58:40.730
您将在所有这些部门

00:58:38.599 --> 00:58:42.650
相同的线程池然后阻塞

00:58:40.730 --> 00:58:45.290
会阻止第一个

00:58:42.650 --> 00:58:47.210
同样执行，但如果您隔离

00:58:45.290 --> 00:58:49.069
他们然后第一个将能够

00:58:47.210 --> 00:58:54.920
服务请求，即使速度较慢

00:58:49.069 --> 00:58:57.050
被缓慢的请求所淹没

00:58:54.920 --> 00:58:59.750
将所有逻辑记录在演员中

00:58:57.050 --> 00:59:02.420
并且不要建立不要写所有的

00:58:59.750 --> 00:59:05.089
 Lambda内部的逻辑

00:59:02.420 --> 00:59:08.720
可以给这个接收建造者和

00:59:05.089 --> 00:59:12.140
决策者，但推它

00:59:08.720 --> 00:59:14.150
向外的最好的情况使它

00:59:12.140 --> 00:59:17.569
像往常一样的常规逻辑

00:59:14.150 --> 00:59:20.569
用Java编写然后在内部使用

00:59:17.569 --> 00:59:22.490
演员来组织他们

00:59:20.569 --> 00:59:26.000
同步边界，并允许他们

00:59:22.490 --> 00:59:28.730
同时运行，确保所有

00:59:26.000 --> 00:59:30.980
消息是不可变的，否则您将拥有

00:59:28.730 --> 00:59:34.099
不同演员的问题不是

00:59:30.980 --> 00:59:36.560
看到您在

00:59:34.099 --> 00:59:38.569
消息，因为它们的Java内存如何

00:59:36.560 --> 00:59:41.869
有效的模型，演员可以

00:59:38.569 --> 00:59:43.760
在您运行的任何这些线程上运行

00:59:41.869 --> 00:59:48.230
在执行者的调度员上

00:59:43.760 --> 00:59:51.200
虽然调度员的服务

00:59:48.230 --> 00:59:53.329
与演员在一起的一切，因为它

00:59:51.200 --> 00:59:56.420
一直都没有意义

00:59:53.329 --> 00:59:58.520
招募异步边界

00:59:56.420 --> 01:00:00.380
事物之间

00:59:58.520 --> 01:00:02.270
只是在实际有用的地方做

01:00:00.380 --> 01:00:05.060
这是你可能可以做到的

01:00:02.270 --> 01:00:06.830
现在画在白板上，想一想

01:00:05.060 --> 01:00:09.080
关于什么事情可以并行发生

01:00:06.830 --> 01:00:14.420
以及什么事情不可能发生

01:00:09.080 --> 01:00:16.720
并行，例如作为企业

01:00:14.420 --> 01:00:19.070
 Java开发人员的第一种

01:00:16.720 --> 01:00:21.950
建筑工具可能是

01:00:19.070 --> 01:00:25.040
您拥有的三层架构

01:00:21.950 --> 01:00:28.400
演示文稿，然后是业务

01:00:25.040 --> 01:00:32.450
逻辑，然后是数据库， 

01:00:28.400 --> 01:00:34.820
也许用这些眼泪没那么有用

01:00:32.450 --> 01:00:38.350
作为抽象或您所在的地方

01:00:34.820 --> 01:00:40.700
将异步边界

01:00:38.350 --> 01:00:43.340
也许围绕数据库，因为您

01:00:40.700 --> 01:00:46.460
将有10个数据库连接

01:00:43.340 --> 01:00:49.490
你需要在不同之间分享

01:00:46.460 --> 01:00:53.990
系统的某些部分，但可能是实际的

01:00:49.490 --> 01:00:56.480
呈现响应解析的逻辑

01:00:53.990 --> 01:00:58.340
请求和处理业务

01:00:56.480 --> 01:01:01.550
逻辑属于同一种

01:00:58.340 --> 01:01:08.270
异步岛同一演员谁

01:01:01.550 --> 01:01:12.170
知道，所以除了我拥有的

01:01:08.270 --> 01:01:14.690
告诉你里面有两件事

01:01:12.170 --> 01:01:16.520
我认为需要服务的kadai 

01:01:14.690 --> 01:01:21.650
提到，第一件事就像

01:01:16.520 --> 01:01:23.750
群集，并考虑到演员生病了

01:01:21.650 --> 01:01:26.890
只是通过交流的东西

01:01:23.750 --> 01:01:30.800
消息，它是一个完美的抽象

01:01:26.890 --> 01:01:33.200
也可以向外扩展，这样您就可以了

01:01:30.800 --> 01:01:34.850
能够将那些演员放在不同的位置

01:01:33.200 --> 01:01:37.820
节点，它们仍然可以通信

01:01:34.850 --> 01:01:39.260
通过消息，所以他们的方式

01:01:37.820 --> 01:01:40.880
沟通将是相同的

01:01:39.260 --> 01:01:42.440
当然，抽象将是相同的

01:01:40.880 --> 01:01:44.350
例如会有差异

01:01:42.440 --> 01:01:47.840
您需要处理延迟和

01:01:44.350 --> 01:01:50.750
响应时间在一个

01:01:47.840 --> 01:01:53.890
本地节点与远程节点的比较

01:01:50.750 --> 01:01:56.330
但这是一种非常好的

01:01:53.890 --> 01:01:57.250
我几乎会说

01:01:56.330 --> 01:02:00.200
阿卡

01:01:57.250 --> 01:02:03.230
另一件事是极端，这是

01:02:00.200 --> 01:02:05.870
同步和背压流

01:02:03.230 --> 01:02:08.410
构建流图的框架

01:02:05.870 --> 01:02:11.810
用于处理各种数据

01:02:08.410 --> 01:02:15.770
这也是

01:02:11.810 --> 01:02:21.950
 HTTP服务器的核心是

01:02:15.770 --> 01:02:25.310
是为阿卡写的好吧，如果你

01:02:21.950 --> 01:02:27.950
经过漫长而乏味的

01:02:25.310 --> 01:02:30.740
从我那里感觉到这是你的事

01:02:27.950 --> 01:02:33.080
想要仔细看看，然后我们

01:02:30.740 --> 01:02:35.450
有一些相当广泛的谈话

01:02:33.080 --> 01:02:38.210
从开始可能会很有趣

01:02:35.450 --> 01:02:40.880
那就是你可以发现我用斜杠

01:02:38.210 --> 01:02:43.070
狗，我们有一个非常友好的社区

01:02:40.880 --> 01:02:47.600
带有杀手级频道和邮件

01:02:43.070 --> 01:02:51.890
列出真正要问的好地方

01:02:47.600 --> 01:02:55.760
问题并获得帮助，此活动

01:02:51.890 --> 01:03:00.190
编码源将很快可用

01:02:55.760 --> 01:03:08.080
在这个github上的网络研讨会之后

01:03:00.190 --> 01:03:08.080
仓库列出的好，所以我认为

01:03:08.560 --> 01:03:15.830
是时候解决问题了

01:03:11.960 --> 01:03:19.430
是的，谢谢您的全面参与

01:03:15.830 --> 01:03:23.180
介绍真的很有趣

01:03:19.430 --> 01:03:25.940
是的，我们时间有点用光了

01:03:23.180 --> 01:03:30.110
但仍然有足够的时间

01:03:25.940 --> 01:03:33.740
我会读一些问题，是的

01:03:30.110 --> 01:03:36.200
所以你可以回答的第一个问题是

01:03:33.740 --> 01:03:42.380
没有一种方法可以创建一个演员

01:03:36.200 --> 01:03:44.840
不必扩展抽象演员

01:03:42.380 --> 01:03:48.170
所以这就是为什么我提到你

01:03:44.840 --> 01:03:49.970
应该为您的领域建模

01:03:48.170 --> 01:03:53.600
与你常规的

01:03:49.970 --> 01:03:56.660
面向对象的工具箱并将其包装

01:03:53.600 --> 01:04:00.740
与演员在一起而不是紧紧地

01:03:56.660 --> 01:04:06.200
将逻辑与演员耦合好

01:04:00.740 --> 01:04:09.260
谢谢，我尝试下一个问题

01:04:06.200 --> 01:04:11.960
在Scala中实现一个演员，我发现

01:04:09.260 --> 01:04:17.240
只需重写接收方法即可，并且

01:04:11.960 --> 01:04:20.180
通过使用方法将方法传递给多维数据集

01:04:17.240 --> 01:04:21.860
感叹号，但是在Java中

01:04:20.180 --> 01:04:24.140
有点复杂写和

01:04:21.860 --> 01:04:25.600
了解请告诉我们您的看法

01:04:24.140 --> 01:04:31.030
在那

01:04:25.600 --> 01:04:34.280
是的，Scala还给了我们更多

01:04:31.030 --> 01:04:37.820
使API进行交互的工具

01:04:34.280 --> 01:04:41.360
与演员在一起非常简洁

01:04:37.820 --> 01:04:43.460
这在Java上是不可能的

01:04:41.360 --> 01:04:46.910
另一方面，Java的一切都非常

01:04:43.460 --> 01:04:49.430
明确的，可能更容易

01:04:46.910 --> 01:04:55.580
跟着，我的意思是这是一个问题

01:04:49.430 --> 01:04:57.980
语言的品味，所以我认为

01:04:55.580 --> 01:05:01.730
很难使它最小化

01:04:57.980 --> 01:05:03.800
 api的工作，然后他们目前

01:05:01.730 --> 01:05:06.680
当然有案例

01:05:03.800 --> 01:05:10.400
情况下有些边缘，但在

01:05:06.680 --> 01:05:13.310
一般我只是有点冗长

01:05:10.400 --> 01:05:15.080
在Java中，那可能就是你

01:05:13.310 --> 01:05:17.360
喜欢或它可能是你的东西

01:05:15.080 --> 01:05:21.350
不喜欢，所以您可以选择

01:05:17.360 --> 01:05:24.410
 Java与Scala和Watauga之间的关系还可以

01:05:21.350 --> 01:05:28.430
下一个问题是什么范围

01:05:24.410 --> 01:05:30.980
系统的访问方法

01:05:28.430 --> 01:05:35.210
来自另一个演员系统的演员

01:05:30.980 --> 01:05:38.570
 Jairam流程，所以如果您想

01:05:35.210 --> 01:05:43.250
不同系统之间的交互

01:05:38.570 --> 01:05:45.230
 JVM有几种选择，因此一种

01:05:43.250 --> 01:05:47.870
选项是当您想要构建一个

01:05:45.230 --> 01:05:50.180
您想要的分布式系统权限

01:05:47.870 --> 01:05:53.720
构建一个应用程序

01:05:50.180 --> 01:05:55.910
涵盖了不止一个JVM 

01:05:53.720 --> 01:05:58.760
在这种情况下，我正在聚类

01:05:55.910 --> 01:06:00.640
提到聚类，就像我可以

01:05:58.760 --> 01:06:03.890
远程的东西肯定是聚集的

01:06:00.640 --> 01:06:05.890
在其他情况下，这只是两个系统

01:06:03.890 --> 01:06:08.450
通过一些互动

01:06:05.890 --> 01:06:10.760
您想要的任何协议

01:06:08.450 --> 01:06:13.460
例如，您可能会写一封邮件

01:06:10.760 --> 01:06:14.990
客户端和邮件服务器，那么您将

01:06:13.460 --> 01:06:16.850
通过沟通

01:06:14.990 --> 01:06:20.540
特定于应用程序的协议

01:06:16.850 --> 01:06:22.760
比做些客气的事

01:06:20.540 --> 01:06:25.310
具体的，即使你可能写

01:06:22.760 --> 01:06:29.200
双方沟通的一部分

01:06:25.310 --> 01:06:29.200
在那个演员系统中

01:06:30.340 --> 01:06:36.530
好的

01:06:32.240 --> 01:06:38.540
转到下一个问题，问题是

01:06:36.530 --> 01:06:42.050
关于第一个样本

01:06:38.540 --> 01:06:44.630
所以基本上示例应用程序显示

01:06:42.050 --> 01:06:45.800
邮件将在某些情况下进行处理

01:06:44.630 --> 01:06:48.020
排队的权利

01:06:45.800 --> 01:06:52.430
意味着每条消息都会

01:06:48.020 --> 01:06:54.860
处理直到完成，然后

01:06:52.430 --> 01:06:58.310
演员将处理下一条消息是

01:06:54.860 --> 01:06:59.450
它正确的理解是的，这是

01:06:58.310 --> 01:07:02.390
完全正确

01:06:59.450 --> 01:07:04.670
所以有一个单线错觉

01:07:02.390 --> 01:07:08.390
演员内部，即使可能

01:07:04.670 --> 01:07:11.690
在的线程之间移动

01:07:08.390 --> 01:07:15.110
调度员，当你看着它

01:07:11.690 --> 01:07:19.810
似乎会一次运行

01:07:15.110 --> 01:07:25.190
一次处理一条消息，是的， 

01:07:19.810 --> 01:07:28.310
下一个问题是建议

01:07:25.190 --> 01:07:30.380
建议您访问

01:07:28.310 --> 01:07:33.110
演员的数据库不应该吗

01:07:30.380 --> 01:07:38.510
不应由

01:07:33.110 --> 01:07:40.820
演员是同步演员，所以这是

01:07:38.510 --> 01:07:44.120
正是我在讲的

01:07:40.820 --> 01:07:46.130
最后你可以阻止演员中的东西

01:07:44.120 --> 01:07:49.610
但您需要确保自己

01:07:46.130 --> 01:07:51.680
将它们隔离到特定的线程池中

01:07:49.610 --> 01:07:54.710
基于调度程序，这样他们就不会

01:07:51.680 --> 01:07:56.750
影响系统的其余部分，但我的意思是

01:07:54.710 --> 01:08:01.070
如果允许您有8个连接

01:07:56.750 --> 01:08:04.220
到您的数据库，那么它就不会

01:08:01.070 --> 01:08:06.200
不管你是否知道你可以

01:08:04.220 --> 01:08:08.450
代表8位演员，它将

01:08:06.200 --> 01:08:14.660
完全符合您的实际需求

01:08:08.450 --> 01:08:17.089
在您的系统中做好，下一个问题

01:08:14.660 --> 01:08:19.640
我们有一个内置的演员系统，可以玩

01:08:17.089 --> 01:08:22.279
框架我的问题是在创建时

01:08:19.640 --> 01:08:25.040
演员，我们应该使用默认值之一还是

01:08:22.279 --> 01:08:27.230
创建我们自己的演员系统

01:08:25.040 --> 01:08:33.259
有助于创建多个演员

01:08:27.230 --> 01:08:36.680
系统好，所以我是我目前的知识

01:08:33.259 --> 01:08:41.180
游戏有点生锈，但过去

01:08:36.680 --> 01:08:43.220
成为一种独立的参与者系统

01:08:41.180 --> 01:08:44.960
玩和一种用户

01:08:43.220 --> 01:08:49.009
应用程序我不确定是否喜欢

01:08:44.960 --> 01:08:51.920
这样了，所以这可能是

01:08:49.009 --> 01:08:52.310
因为在某些时候他们想

01:08:51.920 --> 01:08:55.090
使

01:08:52.310 --> 01:08:58.430
它们与用户逻辑隔离

01:08:55.090 --> 01:09:01.070
非常不确定它是否仍然像这样

01:08:58.430 --> 01:09:03.500
在某些情况下，创建可能会有用

01:09:01.070 --> 01:09:06.170
多个，但总体正常

01:09:03.500 --> 01:09:08.060
应用程序不需要

01:09:06.170 --> 01:09:10.940
不止一个，原因是

01:09:08.060 --> 01:09:12.950
每个参与者系统将占据的位置

01:09:10.940 --> 01:09:16.780
资源，它们将创建线程

01:09:12.950 --> 01:09:19.190
游泳池，所以这是一个相对沉重的

01:09:16.780 --> 01:09:24.200
构造你不想要很多东西

01:09:19.190 --> 01:09:30.650
很多和下一个问题

01:09:24.200 --> 01:09:35.570
是否有可能在g：w中使用akka 

01:09:30.650 --> 01:09:38.540
我听说过的应用服务器

01:09:35.570 --> 01:09:43.790
人们这样做，所以棘手的部分是

01:09:38.540 --> 01:09:46.790
由akka管理的线程池

01:09:43.790 --> 01:09:50.090
 Java EE怎么样

01:09:46.790 --> 01:09:53.570
应用服务器允许事物具有

01:09:50.090 --> 01:09:57.200
他们自己的线程，我认为这有点

01:09:53.570 --> 01:09:58.520
一般来说，取决于供应商

01:09:57.200 --> 01:10:02.120
是不允许您开始的方式

01:09:58.520 --> 01:10:04.310
线程，但你可能可以

01:10:02.120 --> 01:10:07.430
供应商特定的扩展创建

01:10:04.310 --> 01:10:08.990
可以创造演员的东西

01:10:07.430 --> 01:10:10.250
您可以将其用作

01:10:08.990 --> 01:10:17.150
应用程序内部的资源

01:10:10.250 --> 01:10:21.530
服务器，所以这取决于好的，现在

01:10:17.150 --> 01:10:25.340
质疑是否有可能注入

01:10:21.530 --> 01:10:28.700
春豆给演员，是的，它需要

01:10:25.340 --> 01:10:31.100
一些特殊的一些特殊的箍，但

01:10:28.700 --> 01:10:35.530
文档中有示例

01:10:31.100 --> 01:10:43.130
甚至我认为与春天融为一体

01:10:35.530 --> 01:10:46.040
好吧，如果您有大量的

01:10:43.130 --> 01:10:49.430
影响角色系统创建方式的因素

01:10:46.040 --> 01:10:52.490
他们并行何时知道何时

01:10:49.430 --> 01:10:58.270
当系统准备好处理时

01:10:52.490 --> 01:11:01.570
演员是否依赖的消息

01:10:58.270 --> 01:11:01.570
彼此

01:11:02.410 --> 01:11:10.670
好的，所以您可以看到您可以想到的

01:11:07.430 --> 01:11:12.770
这个问题以不同的方式

01:11:10.670 --> 01:11:16.610
那是如果你有演员的话

01:11:12.770 --> 01:11:19.130
完全有效，甚至可以向其发送消息

01:11:16.610 --> 01:11:21.950
虽然还没有准备好，所以那些会

01:11:19.130 --> 01:11:23.810
排队，然后当演员

01:11:21.950 --> 01:11:25.700
实际上开始，所以发生

01:11:23.810 --> 01:11:27.410
同步，然后将其关闭

01:11:25.700 --> 01:11:29.300
过去，它返回并不意味着

01:11:27.410 --> 01:11:31.580
演员已经开始了

01:11:29.300 --> 01:11:35.719
意味着，但你会得到花蜜

01:11:31.580 --> 01:11:38.180
您可以向其中发送消息，如果

01:11:35.719 --> 01:11:41.150
你有一个巨大而复杂的

01:11:38.180 --> 01:11:45.110
您需要进入的图表

01:11:41.150 --> 01:11:47.750
开始之前的特定状态

01:11:45.110 --> 01:11:50.300
它开始处理消息，然后您

01:11:47.750 --> 01:11:52.460
需要以某种方式告知您

01:11:50.300 --> 01:11:55.640
您必须拥有的入口点

01:11:52.460 --> 01:11:57.500
您从中获得的某种协议

01:11:55.640 --> 01:12:04.760
所有这些都需要

01:11:57.500 --> 01:12:08.360
开始并初始化，所以一般来说我

01:12:04.760 --> 01:12:10.940
会说尝试使用像依赖

01:12:08.360 --> 01:12:12.680
注射形式不是

01:12:10.940 --> 01:12:14.960
框架形式，但形式为

01:12:12.680 --> 01:12:19.520
如果演员需要和另一个人说话

01:12:14.960 --> 01:12:21.530
演员以这种方式将演员引用传递给它

01:12:19.520 --> 01:12:24.440
您基本上必须创建

01:12:21.530 --> 01:12:27.200
演员的顺序与

01:12:24.440 --> 01:12:29.840
依赖关系，您将不必

01:12:27.200 --> 01:12:31.370
保持某种协议以

01:12:29.840 --> 01:12:33.080
同步这个，你会的

01:12:31.370 --> 01:12:40.900
基本上能够尽快启动

01:12:33.080 --> 01:12:46.730
您已经创建了所有演员

01:12:40.900 --> 01:12:52.969
移动把它你可以推荐任何

01:12:46.730 --> 01:12:55.640
关于akka的书不是来自我的

01:12:52.969 --> 01:13:00.770
头，但有一束，有一个

01:12:55.640 --> 01:13:07.489
在文档中列出我会

01:13:00.770 --> 01:13:11.570
建议你看看好吗

01:13:07.489 --> 01:13:15.500
问题是有办法告诉和

01:13:11.570 --> 01:13:22.620
演员筏时的前进方法

01:13:15.500 --> 01:13:24.929
是类型安全的，旁边有一个评论

01:13:22.620 --> 01:13:27.510
问题可能不是因为他们

01:13:24.929 --> 01:13:33.510
接受的邮件类型

01:13:27.510 --> 01:13:35.699
演员可以随时间改变是的，所以这

01:13:33.510 --> 01:13:38.010
绝对是其中的一部分

01:13:35.699 --> 01:13:42.719
问题，为什么真的很难

01:13:38.010 --> 01:13:44.340
行为可以改变，但也可以像

01:13:42.719 --> 01:13:46.380
女星真正整洁的事情

01:13:44.340 --> 01:13:49.020
你可以放一个演员

01:13:46.380 --> 01:13:50.400
你之间保持协议，你是

01:13:49.020 --> 01:13:51.120
派演员一无所知

01:13:50.400 --> 01:13:53.550
关于它

01:13:51.120 --> 01:13:55.830
但是你只是偷偷换了这个赚钱的演员

01:13:53.550 --> 01:13:58.410
在这两者之间会回应一些

01:13:55.830 --> 01:14:00.300
消息，但没有其他，这也是

01:13:58.410 --> 01:14:06.179
很难代表你的东西

01:14:00.300 --> 01:14:10.020
知道类型安全问题，但是有一个

01:14:06.179 --> 01:14:11.820
演员的子模块

01:14:10.020 --> 01:14:17.400
正在开发中，称为akka 

01:14:11.820 --> 01:14:21.989
键入如果不是的话

01:14:17.400 --> 01:14:26.489
随时准备，但有工作

01:14:21.989 --> 01:14:29.610
在一年的时间里做

01:14:26.489 --> 01:14:33.179
类型安全演员，我不确定这是否

01:14:29.610 --> 01:14:36.030
将有可能用

01:14:33.179 --> 01:14:40.890
 Java API，因此将来我们会看到

01:14:36.030 --> 01:14:42.840
它在什么地方着陆

01:14:40.890 --> 01:14:47.810
调查您是否有兴趣

01:14:42.840 --> 01:14:51.660
这个话题是的，接下来知道

01:14:47.810 --> 01:14:54.300
问题不是很确定我得到了

01:14:51.660 --> 01:14:57.060
问题的含义我仍然会读

01:14:54.300 --> 01:15:02.370
任何阻塞程序必须

01:14:57.060 --> 01:15:04.860
放置在不同的线程池中，以便

01:15:02.370 --> 01:15:08.699
总是与软件有关，但这取决于

01:15:04.860 --> 01:15:11.969
一个好的经验法则，你应该尝试

01:15:08.699 --> 01:15:14.130
将阻塞物隔离到

01:15:11.969 --> 01:15:16.679
当然可以使用单独的线程池

01:15:14.130 --> 01:15:18.449
有一个单独的线程池

01:15:16.679 --> 01:15:20.280
 I / O，例如所有阻塞的I / O 

01:15:18.449 --> 01:15:22.650
即使你有不同的演员

01:15:20.280 --> 01:15:24.780
做不同的阻塞I / O，所以这是

01:15:22.650 --> 01:15:26.640
有点你必须要思考的东西

01:15:24.780 --> 01:15:29.369
关于您自己的系统

01:15:26.640 --> 01:15:31.500
影响它哪些部分将停止其他

01:15:29.369 --> 01:15:37.460
从处理，如果这是明智的

01:15:31.500 --> 01:15:40.770
还是不，现在你提到更好的深

01:15:37.460 --> 01:15:42.989
这是我们的吻，然后是白发，是我们的钥匙

01:15:40.770 --> 01:15:47.449
只是因为有监督

01:15:42.989 --> 01:15:51.420
或其他绝对有关的东西

01:15:47.449 --> 01:15:53.429
监督您可以分开零件

01:15:51.420 --> 01:15:55.230
您的系统中不应

01:15:53.429 --> 01:15:59.070
断裂时影响其他部分

01:15:55.230 --> 01:16:01.349
而你推动了危险的工作

01:15:59.070 --> 01:16:03.929
向下层次结构权利，因为

01:16:01.349 --> 01:16:06.590
因为错误上升，并且

01:16:03.929 --> 01:16:09.599
您拥有的较小零件将失败

01:16:06.590 --> 01:16:11.130
您可以重新启动的较小零件

01:16:09.599 --> 01:16:14.369
而不影响其他部分

01:16:11.130 --> 01:16:16.800
系统还可以

01:16:14.369 --> 01:16:19.080
在我们的骗局的当前版本中

01:16:16.800 --> 01:16:22.969
考虑使用我们的良好做法

01:16:19.080 --> 01:16:28.500
核心期货和格局问

01:16:22.969 --> 01:16:33.989
育儿还可以，所以在当前版本中

01:16:28.500 --> 01:16:38.400
从Java到4.10的伏特加

01:16:33.989 --> 01:16:40.560
你可能不会用太多的未来

01:16:38.400 --> 01:16:43.219
而是完成阶段课程

01:16:40.560 --> 01:16:46.469
这基本上与

01:16:43.219 --> 01:16:52.380
期货期货是一种来自

01:16:46.469 --> 01:16:54.510
来自Scala，完成阶段是

01:16:52.380 --> 01:16:58.650
在Java上做同样的事情

01:16:54.510 --> 01:17:00.900
我不是真正的询问模式

01:16:58.650 --> 01:17:05.909
在谈话中提到，但这是一个

01:17:00.900 --> 01:17:08.520
封装查询的方式，如果您

01:17:05.909 --> 01:17:10.739
有一个包含查询的协议

01:17:08.520 --> 01:17:12.150
消息，然后是响应消息，以及

01:17:10.739 --> 01:17:15.360
你想把那些绑在一起

01:17:12.150 --> 01:17:17.639
由于某种原因超时

01:17:15.360 --> 01:17:19.739
想无限地等待响应， 

01:17:17.639 --> 01:17:23.699
那么您想对

01:17:19.739 --> 01:17:26.610
如果您不在演员中，我会回应

01:17:23.699 --> 01:17:28.469
需要查询然后肯定在那里

01:17:26.610 --> 01:17:33.000
这真的不是另一种选择吗

01:17:28.469 --> 01:17:34.860
询问您是否在演员里面

01:17:33.000 --> 01:17:37.860
有几个不同的选择，但父母

01:17:34.860 --> 01:17:43.230
这项任务是非常好的笔记

01:17:37.860 --> 01:17:47.489
这是一个特殊的特殊模式

01:17:43.230 --> 01:17:51.510
不要要求称为CS的Java 8 

01:17:47.489 --> 01:17:53.520
模式不问我想哪个会

01:17:51.510 --> 01:17:56.310
回到完成阶段，您

01:17:53.520 --> 01:18:03.270
不必在Scala中输入12 

01:17:56.310 --> 01:18:07.070
可以做Java的东西了

01:18:03.270 --> 01:18:10.710
问题演员如何表现

01:18:07.070 --> 01:18:17.420
与消息和提示集成

01:18:10.710 --> 01:18:22.010
 RabbitMQ与这个建议，所以有

01:18:17.420 --> 01:18:25.590
开源项目连接器

01:18:22.010 --> 01:18:28.550
与演员连接到rabbitmq，因此

01:18:25.590 --> 01:18:30.960
您将收到来自MQ的消息，例如

01:18:28.550 --> 01:18:33.300
 actor系统内部的消息

01:18:30.960 --> 01:18:38.219
很好，我之前用过

01:18:33.300 --> 01:18:39.900
参加我的聚光灯乐队

01:18:38.219 --> 01:18:43.320
可能更适合看

01:18:39.900 --> 01:18:46.980
带极端连接器的极端

01:18:43.320 --> 01:18:51.510
因为他们匹配一条消息

01:18:46.980 --> 01:18:53.340
排队工作更好一点，让您有点

01:18:51.510 --> 01:18:57.060
背压，不要消耗太多

01:18:53.340 --> 01:18:58.830
比较消息队列中的消息

01:18:57.060 --> 01:19:09.300
可以处理多少，您的

01:18:58.830 --> 01:19:11.130
吞吐量确定并写下下一个问题

01:19:09.300 --> 01:19:13.980
我将研究自定义akka 

01:19:11.130 --> 01:19:19.410
现在有一些未知的人的系统

01:19:13.980 --> 01:19:22.230
流动我们可以观察到的是

01:19:19.410 --> 01:19:25.530
一些演员坠毁，我们失去了他们的

01:19:22.230 --> 01:19:30.690
陈述我们应该做的第一部分

01:19:25.530 --> 01:19:34.469
检查确定，以便确定是否有演员

01:19:30.690 --> 01:19:36.600
崩溃，然后它们将重新启动

01:19:34.469 --> 01:19:39.930
因为这是默认的监管

01:19:36.600 --> 01:19:44.219
策略，那就是看他们的父母

01:19:39.930 --> 01:19:47.820
演员及其监督方式

01:19:44.219 --> 01:19:52.949
孩子们想想你是否应该

01:19:47.820 --> 01:19:54.660
不同的行为或是否可以推动

01:19:52.949 --> 01:19:56.609
导致他们死亡的危险

01:19:54.660 --> 01:20:03.059
崩溃向下

01:19:56.609 --> 01:20:05.729
在层次结构中，好吗？ 

01:20:03.059 --> 01:20:10.739
可以跨VM通信或

01:20:05.729 --> 01:20:12.119
主持人，这又取决于什么

01:20:10.739 --> 01:20:15.300
如果你想建立一个你想做的

01:20:12.119 --> 01:20:17.429
您将使用akka的分布式系统新

01:20:15.300 --> 01:20:22.050
我会说群集或准确的模拟

01:20:17.429 --> 01:20:24.539
 akka集群，如果您要构建

01:20:22.050 --> 01:20:26.729
某些示例客户端-服务器系统

01:20:24.539 --> 01:20:31.169
善良的话，那就只是定义

01:20:26.729 --> 01:20:34.050
例如在TCP上使用的协议

01:20:31.169 --> 01:20:36.119
所以任何一方都不会真正知道

01:20:34.050 --> 01:20:39.749
另一面是演员

01:20:36.119 --> 01:20:46.669
系统，但它将像一个单独的

01:20:39.749 --> 01:20:49.769
客户端和服务器实施是的

01:20:46.669 --> 01:20:56.280
您打算创建下一个问题

01:20:49.769 --> 01:20:59.039
关于ARCA教室的网络研讨会，我想

01:20:56.280 --> 01:21:08.010
这可能是您的一个问题

01:20:59.039 --> 01:21:11.639
也许是的，为什么不呢？ 

01:21:08.010 --> 01:21:15.809
演员支持的反应式规格又回来了

01:21:11.639 --> 01:21:20.699
启用压力，所以我会猜测

01:21:15.809 --> 01:21:25.050
使用反应式规范这是什么意思

01:21:20.699 --> 01:21:27.119
反应流规格因此

01:21:25.050 --> 01:21:29.969
这是我们的主观建议是

01:21:27.119 --> 01:21:32.609
反应流的实现

01:21:29.969 --> 01:21:34.469
规范参与者本身

01:21:32.609 --> 01:21:38.729
不会背压，所以您会

01:21:34.469 --> 01:21:43.010
必须定义定义演员系统

01:21:38.729 --> 01:21:45.239
如果你慢一点要处理

01:21:43.010 --> 01:21:47.189
吞吐速度较慢，那么您有

01:21:45.239 --> 01:21:48.809
消息流入，例如，您将

01:21:47.189 --> 01:21:56.699
设计时必须考虑一下

01:21:48.809 --> 01:22:00.749
您的演员是，何时以及为何去

01:21:56.699 --> 01:22:06.449
弧线路由可以详细说明吗

01:22:00.749 --> 01:22:10.109
它的意义很简单，是的，所以

01:22:06.449 --> 01:22:12.719
我没仔细看过的东西

01:22:10.109 --> 01:22:14.760
 LiveCode或

01:22:12.719 --> 01:22:17.129
救生衣的准备好的样品是

01:22:14.760 --> 01:22:20.519
我实际上是在使用路由

01:22:17.129 --> 01:22:23.219
什么路由是你所需要的东西

01:22:20.519 --> 01:22:26.070
可以创建一个actor的四个实例

01:22:23.219 --> 01:22:28.589
例如，您将本质上

01:22:26.070 --> 01:22:31.199
让演员F向您发送消息

01:22:28.589 --> 01:22:34.439
难道你有点推迟

01:22:31.199 --> 01:22:38.629
消息在那些之间分配

01:22:34.439 --> 01:22:42.539
四个演员，所以有不同

01:22:38.629 --> 01:22:44.249
例如，不同类型的路由

01:22:42.539 --> 01:22:47.129
你本可以做一个循环赛

01:22:44.249 --> 01:22:49.439
路由器将为每个新消息

01:22:47.129 --> 01:22:51.539
进来的只是选择下一个

01:22:49.439 --> 01:22:52.889
演员，然后当它到达时

01:22:51.539 --> 01:22:55.530
列表的结尾，他们将从头开始

01:22:52.889 --> 01:22:57.499
从第一个开始，所以这是

01:22:55.530 --> 01:23:00.300
例如一种分配方式

01:22:57.499 --> 01:23:01.949
处理您所有的课程

01:23:00.300 --> 01:23:04.679
根据您的课程创建尽可能多的演员

01:23:01.949 --> 01:23:06.449
然后您只需使用此路由器即可

01:23:04.679 --> 01:23:11.189
在菜单之间分配工作

01:23:06.449 --> 01:23:13.949
而且消息还可以，我认为

01:23:11.189 --> 01:23:20.429
就是这样，我们没有了

01:23:13.949 --> 01:23:22.829
问题，但如果有人有更多

01:23:20.429 --> 01:23:26.729
问题随便问

01:23:22.829 --> 01:23:29.070
 Twitter是我们发布

01:23:26.729 --> 01:23:33.839
录制您可以将其发布为评论

01:23:29.070 --> 01:23:37.019
所以我们将尝试回答所有问题，谢谢

01:23:33.839 --> 01:23:39.869
您的时间和问题，以及

01:23:37.019 --> 01:23:44.999
约翰当然感谢您

01:23:39.869 --> 01:23:47.849
演示文稿，谢谢，好吧，大家见

01:23:44.999 --> 01:23:50.719
保重，祝你有美好的一天再见

01:23:47.849 --> 01:23:50.719
再见

