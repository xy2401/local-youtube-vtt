WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.180 --> 00:00:07.960
很好，很好，大家早上好

00:00:05.380 --> 00:00:09.550
你好吗，我不希望得到回应

00:00:07.960 --> 00:00:11.559
我只是希望你注册我

00:00:09.550 --> 00:00:12.009
关心我很高兴能在这里我希望你

00:00:11.559 --> 00:00:13.509
也是

00:00:12.009 --> 00:00:15.459
对，所以我们要经历很多

00:00:13.509 --> 00:00:17.110
今天的事情，我们将涵盖很多

00:00:15.459 --> 00:00:19.570
反应性弹簧的世界里的东西

00:00:17.110 --> 00:00:21.670
我总是喜欢与

00:00:19.570 --> 00:00:22.960
我们要去的小序言

00:00:21.670 --> 00:00:25.660
经历了很多事情

00:00:22.960 --> 00:00:28.599
这次演讲的重点不在一个小时内

00:00:25.660 --> 00:00:30.970
像所有大师一样造币厂

00:00:28.599 --> 00:00:32.920
春季有反应，但更多

00:00:30.970 --> 00:00:35.260
排序注册什么是可能的，以及

00:00:32.920 --> 00:00:37.410
看看有什么可能，我知道

00:00:35.260 --> 00:00:39.760
因为你们都很勇敢

00:00:37.410 --> 00:00:41.289
有创业精神的你就可以出去

00:00:39.760 --> 00:00:42.640
在那里找到细节，我想

00:00:41.289 --> 00:00:44.559
给你这个github存储库作为一个

00:00:42.640 --> 00:00:46.960
第一步，所以就在那里

00:00:44.559 --> 00:00:48.550
在github上起床冷静长通量快速

00:00:46.960 --> 00:00:49.989
服务，然后有课程指南

00:00:48.550 --> 00:00:51.300
它会为此类指南提供I / O 

00:00:49.989 --> 00:00:53.800
您会发现各种不同的方式

00:00:51.300 --> 00:00:56.559
春天和万物的介绍

00:00:53.800 --> 00:00:58.390
和反应性，当然如果你有

00:00:56.559 --> 00:01:00.399
问题永不犹豫

00:00:58.390 --> 00:01:01.989
我很高兴回答问题

00:01:00.399 --> 00:01:03.730
我在Twitter上可以看到我的

00:01:01.989 --> 00:01:06.130
在星巴克男人那里协调

00:01:03.730 --> 00:01:08.500
我很高兴参与，请在那里找到我

00:01:06.130 --> 00:01:09.850
我们可以聊天，当然您也可以

00:01:08.500 --> 00:01:11.890
有电子邮件不要犹豫，找到我

00:01:09.850 --> 00:01:13.180
还有，所以无论哪种方式我

00:01:11.890 --> 00:01:16.270
乐意效劳

00:01:13.180 --> 00:01:17.520
我很久很久

00:01:16.270 --> 00:01:19.780
解释

00:01:17.520 --> 00:01:21.430
我是春季开发者的倡导者

00:01:19.780 --> 00:01:24.070
春季团队，我是一个开放的巡回工程师

00:01:21.430 --> 00:01:26.500
 Java冠军，作家和培训师

00:01:24.070 --> 00:01:28.960
众多不同的视频和书籍

00:01:26.500 --> 00:01:31.899
然后最近刚完成我的

00:01:28.960 --> 00:01:33.310
第七个视频，其中一个是建筑物

00:01:31.899 --> 00:01:35.259
 Spring Moot Live提供微服务

00:01:33.310 --> 00:01:38.369
这些课程在Safari在线上

00:01:35.259 --> 00:01:40.659
技术市场，当然我

00:01:38.369 --> 00:01:42.189
刚读完我的第五本书，这个

00:01:40.659 --> 00:01:44.220
这本书叫做云原生Java 

00:01:42.189 --> 00:01:47.790
关于如何构建应用程序的所有内容

00:01:44.220 --> 00:01:50.020
在云中生存并壮成长

00:01:47.790 --> 00:01:51.430
这本书是奥赖利的书，所以如果你

00:01:50.020 --> 00:01:53.409
如果您曾经读过莱利书， 

00:01:51.430 --> 00:01:54.969
你知道最重要的部分

00:01:53.409 --> 00:01:57.340
这本书不是真的介于两者之间

00:01:54.969 --> 00:01:58.840
掩盖的更多是动物

00:01:57.340 --> 00:02:00.009
在那个动物的封面上

00:01:58.840 --> 00:02:04.659
改变世界

00:02:00.009 --> 00:02:06.159
因为你知道人们看什么

00:02:04.659 --> 00:02:08.649
他们期望在里面找到什么

00:02:06.159 --> 00:02:12.910
本书，所以这种动物是一个很难的

00:02:08.649 --> 00:02:15.730
艰苦奋斗或选择的鸟，但我们

00:02:12.910 --> 00:02:18.330
经过多年的寻找才发现

00:02:15.730 --> 00:02:21.340
为此，这只鸟是蓝耳的

00:02:18.330 --> 00:02:23.500
翠鸟就是那只鸟

00:02:21.340 --> 00:02:26.950
土著的，或者我们当然会说的

00:02:23.500 --> 00:02:31.120
印尼爪哇语的英语母语

00:02:26.950 --> 00:02:35.260
岛上是只鸟，它是土生土长的鸟

00:02:31.120 --> 00:02:37.130
 Java或Java和鸟本身的本机

00:02:35.260 --> 00:02:39.650
飞

00:02:37.130 --> 00:02:41.990
经常飞过云层，所以这是

00:02:39.650 --> 00:02:44.090
 Java特有的飞鸟

00:02:41.990 --> 00:02:46.940
穿过云层，这是云原生

00:02:44.090 --> 00:02:48.680
 Java鸟，这是鸟，没关系

00:02:46.940 --> 00:02:50.780
无论如何，你会得到它的到来

00:02:48.680 --> 00:02:53.600
那是蓝耳翠鸟

00:02:50.780 --> 00:02:55.190
对，那是一只很酷的鸟， 

00:02:53.600 --> 00:02:56.210
当然，我在关键和关键工作

00:02:55.190 --> 00:02:58.430
我们有很多很好的开源

00:02:56.210 --> 00:02:59.680
我们非常关心开放的软件

00:02:58.430 --> 00:03:02.450
消息来源让我们非常清楚

00:02:59.680 --> 00:03:05.000
但这不是驱动因素

00:03:02.450 --> 00:03:07.460
像我这样的人从床上蹦出来

00:03:05.000 --> 00:03:09.050
我们最关心的是

00:03:07.460 --> 00:03:10.430
帮助组织客户社区

00:03:09.050 --> 00:03:12.590
成员，这是一辆卡车制造更好

00:03:10.430 --> 00:03:14.690
软件更快，更安全，并且作为

00:03:12.590 --> 00:03:16.940
我们与组织讨论如何

00:03:14.690 --> 00:03:20.300
增加他们的敏捷性

00:03:16.940 --> 00:03:22.910
这种进展的副作用是

00:03:20.300 --> 00:03:25.130
将该优化移至

00:03:22.910 --> 00:03:26.870
组织敏捷性是此举

00:03:25.130 --> 00:03:29.540
微服务权微服务

00:03:26.870 --> 00:03:31.580
允许组织分解大量

00:03:29.540 --> 00:03:33.880
整体应用变成更小的

00:03:31.580 --> 00:03:36.800
一小批工作

00:03:33.880 --> 00:03:39.620
一个小团队可以在其上迭代并

00:03:36.800 --> 00:03:41.420
然后部署到生产中

00:03:39.620 --> 00:03:43.250
您看到的实际好处

00:03:41.420 --> 00:03:46.480
将您的软件分解成小块

00:03:43.250 --> 00:03:48.170
专注于内部一致

00:03:46.480 --> 00:03:53.500
可重用，可独立部署

00:03:48.170 --> 00:03:56.870
分批工作允许小团队

00:03:53.500 --> 00:03:58.550
使小团队说你

00:03:56.870 --> 00:04:00.710
不需要大团队一起工作

00:03:58.550 --> 00:04:03.410
您可以拥有的大型整体代码库

00:04:00.710 --> 00:04:06.410
很多小团队都专注于一个

00:04:03.410 --> 00:04:07.760
交付和那个小团队

00:04:06.410 --> 00:04:09.350
由于它一直存在

00:04:07.760 --> 00:04:11.360
在其自己的组件边界内具有

00:04:09.350 --> 00:04:12.950
能够一直走得更快的能力

00:04:11.360 --> 00:04:14.660
作为表面积成分边界

00:04:12.950 --> 00:04:16.250
的分量保持稳定，则

00:04:14.660 --> 00:04:17.359
组织的其余部分只需要

00:04:16.250 --> 00:04:21.200
了解他们不需要的API 

00:04:17.359 --> 00:04:24.350
沟通时间长而乏味

00:04:21.200 --> 00:04:25.520
互动式的对话

00:04:24.350 --> 00:04:28.430
电子邮件线程那种东西

00:04:25.520 --> 00:04:30.500
控制我们更快走的能力

00:04:28.430 --> 00:04:32.420
留在我们自己众所周知的游泳中

00:04:30.500 --> 00:04:34.430
我认为这可以让敏捷

00:04:32.420 --> 00:04:35.870
很多人面对的问题

00:04:34.430 --> 00:04:39.110
他们当然会迁移到这种架构

00:04:35.870 --> 00:04:40.760
拥有所有的好处和能力

00:04:39.110 --> 00:04:43.370
帮助组织走得更快是

00:04:40.760 --> 00:04:45.169
当然，当您转向这种方法时

00:04:43.370 --> 00:04:46.490
您正在介绍您知道

00:04:45.169 --> 00:04:48.590
构建分布式系统的复杂性

00:04:46.490 --> 00:04:49.940
系统中的许多小型服务与之交谈

00:04:48.590 --> 00:04:51.169
通过网络和

00:04:49.940 --> 00:04:52.940
当然有

00:04:51.169 --> 00:04:56.330
您需要了解的模式和

00:04:52.940 --> 00:04:58.340
该地址，我们将可靠性

00:04:56.330 --> 00:05:00.860
您需要注意的事情

00:04:58.340 --> 00:05:02.330
向外扩展的能力

00:05:00.860 --> 00:05:03.590
还有两件事你需要注意

00:05:02.330 --> 00:05:05.180
关于那不一定是问题

00:05:03.590 --> 00:05:06.680
在巨石世界里一件事

00:05:05.180 --> 00:05:08.419
我们看到很多人

00:05:06.680 --> 00:05:10.550
挣扎的是如何获得最大收益

00:05:08.419 --> 00:05:12.560
个人效率

00:05:10.550 --> 00:05:15.229
服务对，我们要做的就是

00:05:12.560 --> 00:05:17.900
能够在整个

00:05:15.229 --> 00:05:20.389
尽可能高效地接线

00:05:17.900 --> 00:05:22.520
我尽可能可靠地做到这一点

00:05:20.389 --> 00:05:26.120
是一个你知道这是两个方面的

00:05:22.520 --> 00:05:27.979
问题是我认为最难的部分

00:05:26.120 --> 00:05:32.060
是正确的效率

00:05:27.979 --> 00:05:33.740
效率是我们可以做到的

00:05:32.060 --> 00:05:35.479
我们可以在某个时候理所当然

00:05:33.740 --> 00:05:37.130
因为我们可以扩大规模，但在某些方面

00:05:35.479 --> 00:05:39.350
要提高效率

00:05:37.130 --> 00:05:41.240
以我们处理个人的方式

00:05:39.350 --> 00:05:43.820
互动，尤其是当我们开始

00:05:41.240 --> 00:05:45.979
每个请求移动越来越多的数据， 

00:05:43.820 --> 00:05:47.600
这个要求寄了很多

00:05:45.979 --> 00:05:49.310
数据可能无限量

00:05:47.600 --> 00:05:52.490
线上的数据变得更多， 

00:05:49.310 --> 00:05:53.960
当我们扩大规模时会更加明显

00:05:52.490 --> 00:05:55.700
我们面临的是非常根本的

00:05:53.960 --> 00:05:57.110
问题我如何移动大量

00:05:55.700 --> 00:05:59.960
从一个节点到另一个节点的数据

00:05:57.110 --> 00:06:03.310
我如何为大多数人提供便利

00:05:59.960 --> 00:06:05.870
服务与

00:06:03.310 --> 00:06:08.000
这不是一个特别新的问题

00:06:05.870 --> 00:06:09.620
对，我们已经在Java中拥有了

00:06:08.000 --> 00:06:12.050
在计算机行业有一个

00:06:09.620 --> 00:06:14.570
我们有过的计算机科学家

00:06:12.050 --> 00:06:16.550
很多不同的支持很多

00:06:14.570 --> 00:06:19.160
此处用于管理的不同选项

00:06:16.550 --> 00:06:21.710
这种复杂性

00:06:19.160 --> 00:06:24.860
我们拥有的Java世界

00:06:21.710 --> 00:06:27.349
从第一天开始，jdk inputstream和

00:06:24.860 --> 00:06:28.910
现在这些输入的输出流抽象

00:06:27.349 --> 00:06:31.910
流和输出流抽象

00:06:28.910 --> 00:06:36.130
曾经担任过，但他们是一个非常

00:06:31.910 --> 00:06:39.440
他们非常简化的抽象

00:06:36.130 --> 00:06:41.090
隐藏一些内在力量

00:06:39.440 --> 00:06:44.349
足够复杂，但他们也

00:06:41.090 --> 00:06:46.970
雇用他们底层的力量

00:06:44.349 --> 00:06:48.860
输入种类输出流输出

00:06:46.970 --> 00:06:51.050
大多数操作系统中的模型

00:06:48.860 --> 00:06:52.729
操作系统的网络IO和

00:06:51.050 --> 00:06:56.060
大多数操作系统是异步的

00:06:52.729 --> 00:06:58.190
对，而输入流和

00:06:56.060 --> 00:07:01.840
输出流呈现同步

00:06:58.190 --> 00:07:04.340
门面如此快速地前进到jdk 1.4和

00:07:01.840 --> 00:07:06.500
你得到一些Java 

00:07:04.340 --> 00:07:07.450
哟，你有渠道，你找到了你

00:07:06.500 --> 00:07:09.860
知道谈论的能力

00:07:07.450 --> 00:07:11.930
最终将异步数据

00:07:09.860 --> 00:07:13.190
到达，这给了我们他们相信

00:07:11.930 --> 00:07:15.470
开始考虑这个，你知道

00:07:13.190 --> 00:07:18.290
开始说我有那个数据

00:07:15.470 --> 00:07:20.630
进入插座，我需要

00:07:18.290 --> 00:07:23.120
能够回应

00:07:20.630 --> 00:07:24.500
该数据可用，所以这与

00:07:23.120 --> 00:07:26.990
你有能力说我的频道

00:07:24.500 --> 00:07:28.520
给了我一个通知，并在

00:07:26.990 --> 00:07:30.890
同时，您不再被封锁了

00:07:28.520 --> 00:07:32.120
那那个无论什么线程

00:07:30.890 --> 00:07:34.190
即使只是

00:07:32.120 --> 00:07:35.750
我可以做的其他任何事情

00:07:34.190 --> 00:07:37.250
等待时需要做的

00:07:35.750 --> 00:07:39.680
该频道向其发送通知

00:07:37.250 --> 00:07:40.910
这就是我们想要的

00:07:39.680 --> 00:07:42.230
我们想要的是一种功能

00:07:40.910 --> 00:07:45.020
谈论事实的能力

00:07:42.230 --> 00:07:46.460
数据传入，但我们还有其他

00:07:45.020 --> 00:07:48.380
做对的事情给了我们

00:07:46.460 --> 00:07:50.300
解除阻碍我们互动的能力

00:07:48.380 --> 00:07:52.880
从而提高效率，我们可以做

00:07:50.300 --> 00:07:55.370
使用与上述相同的资源

00:07:52.880 --> 00:07:58.400
这是一个很底层的程序

00:07:55.370 --> 00:08:01.160
模范我们没有，我们仍然不

00:07:58.400 --> 00:08:03.020
在我们的大多数业务逻辑中

00:08:01.160 --> 00:08:04.610
输入流方面的功能

00:08:03.020 --> 00:08:07.610
和输出流，为什么我们要

00:08:04.610 --> 00:08:09.500
更快地迁移到JDK，I / O和新闻

00:08:07.610 --> 00:08:11.450
渠道等等，所以这是一个

00:08:09.500 --> 00:08:13.910
这不太合适，所以我们已经

00:08:11.450 --> 00:08:17.300
在过去的十年里一直在寻找

00:08:13.910 --> 00:08:20.690
知道一些范式建模的方法

00:08:17.300 --> 00:08:23.750
这种互动的想法

00:08:20.690 --> 00:08:26.060
我们有将要完成的工作

00:08:23.750 --> 00:08:26.990
发生，它将异步发生

00:08:26.060 --> 00:08:30.350
未来的某个时刻

00:08:26.990 --> 00:08:32.000
我们不知道何时，这可能意味着

00:08:30.350 --> 00:08:34.040
大量数据或少量数据，但是

00:08:32.000 --> 00:08:35.500
关键是我们不能被束缚， 

00:08:34.040 --> 00:08:38.150
该程序不必更改

00:08:35.500 --> 00:08:39.830
根据您知道的大小

00:08:38.150 --> 00:08:41.570
数据，所以我们寻找了某种

00:08:39.830 --> 00:08:43.370
范式来解决这个问题，我认为

00:08:41.570 --> 00:08:45.700
你已经看到了很多真正的创新

00:08:43.370 --> 00:08:48.110
在这个空间工作，我认为

00:08:45.700 --> 00:08:50.630
 900磅的大猩猩当然是

00:08:48.110 --> 00:08:53.420
微软的研究工作完成了

00:08:50.630 --> 00:08:55.730
 dotnet的反应性扩展

00:08:53.420 --> 00:09:01.100
当然，然后在

00:08:55.730 --> 00:09:02.420
打造我们的Ixtapa的Netflix和您

00:09:01.100 --> 00:09:05.030
不久之后您就会知道

00:09:02.420 --> 00:09:06.920
大量的不同选择

00:09:05.030 --> 00:09:09.500
生态系统，因此您拥有了

00:09:06.920 --> 00:09:12.680
在添加光的弯曲本尼的人

00:09:09.500 --> 00:09:14.600
当然typesafe谁建立了naka和

00:09:12.680 --> 00:09:17.250
这是一种解决地址的方法

00:09:14.600 --> 00:09:19.530
这种类型的

00:09:17.250 --> 00:09:21.630
需要，然后你有一个像

00:09:19.530 --> 00:09:24.120
有技术的红帽

00:09:21.630 --> 00:09:27.060
叫做顶点，当然我们在这个

00:09:24.120 --> 00:09:31.430
在VMware和Spring团队中

00:09:27.060 --> 00:09:34.800
现在当然今天在这里

00:09:31.430 --> 00:09:37.470
一个叫做反应堆的项目，反应堆是一个

00:09:34.800 --> 00:09:39.980
建模这种框架

00:09:37.470 --> 00:09:42.810
失物招领失物招领

00:09:39.980 --> 00:09:44.730
象限类型的四分之一

00:09:42.810 --> 00:09:46.800
您可以取回的价值，所以请思考

00:09:44.730 --> 00:09:50.070
关于如何在JDK中建模

00:09:46.800 --> 00:09:52.260
今天的服务正在返回

00:09:50.070 --> 00:09:54.630
单值类型的单值

00:09:52.260 --> 00:09:56.760
字符串，假设您会说我有一个

00:09:54.630 --> 00:09:58.710
方法，返回值为字符串

00:09:56.760 --> 00:10:01.680
如果您有返回的方法

00:09:58.710 --> 00:10:04.830
字符串T向右的多个值

00:10:01.680 --> 00:10:07.110
你会说收集力量的权利

00:10:04.830 --> 00:10:09.690
集合通用类型字符串，如果您

00:10:07.110 --> 00:10:12.900
对不起打扰你了吗

00:10:09.690 --> 00:10:15.870
关于幻灯片有一些问题

00:10:12.900 --> 00:10:18.740
所以现在现在我们只看到白色

00:10:15.870 --> 00:10:22.350
它说枢纽um springing 500 

00:10:18.740 --> 00:10:24.390
对，那会没事的

00:10:22.350 --> 00:10:26.760
我不认为我必须通过

00:10:24.390 --> 00:10:28.470
好的，我只想确认一下

00:10:26.760 --> 00:10:29.610
它没有提出，然后对不起

00:10:28.470 --> 00:10:32.810
麻烦没问题

00:10:29.610 --> 00:10:35.550
所以我们是我们然后有一个我们有

00:10:32.810 --> 00:10:36.780
多个值，我们有一个方法

00:10:35.550 --> 00:10:38.850
返回多个值，我们说这是一个

00:10:36.780 --> 00:10:39.950
字符串的收集我们有一个方法

00:10:38.850 --> 00:10:43.410
返回一个单一的浆果

00:10:39.950 --> 00:10:45.600
字符串，如果我们想返回每个人的

00:10:43.410 --> 00:10:48.510
有一个返回一个单一的方法

00:10:45.600 --> 00:10:50.700
异步价值我们会说你知道

00:10:48.510 --> 00:10:53.640
使用JDK 8，我们会说这是一个

00:10:50.700 --> 00:10:56.190
字符串的可完成未来

00:10:53.640 --> 00:10:57.930
这是一种使我们能够

00:10:56.190 --> 00:10:59.490
当值是

00:10:57.930 --> 00:11:01.500
即使不是现在也可以使用

00:10:59.490 --> 00:11:02.610
好吧，这不是未来，而是

00:11:01.500 --> 00:11:05.010
比未来更好，我不必

00:11:02.610 --> 00:11:07.350
民意测验，我不必不断地要求

00:11:05.010 --> 00:11:08.820
可以通知我的价值，您

00:11:07.350 --> 00:11:10.530
知道什么时候可用，这给了

00:11:08.820 --> 00:11:12.060
我们四分之三

00:11:10.530 --> 00:11:14.130
我们想要建模什么的东西

00:11:12.060 --> 00:11:15.570
这种范式中缺少的是我们如何

00:11:14.130 --> 00:11:17.250
模拟我们如何描述我们如何交谈

00:11:15.570 --> 00:11:20.400
关于它可能无限量的

00:11:17.250 --> 00:11:21.240
可能稍后可用的数据

00:11:20.400 --> 00:11:22.920
在未来

00:11:21.240 --> 00:11:24.390
一个同步的权利，这是什么

00:11:22.920 --> 00:11:25.890
失踪了，我想我们很多人

00:11:24.390 --> 00:11:27.089
这些在不同的角落

00:11:25.890 --> 00:11:29.250
的生态系统一直在寻找

00:11:27.089 --> 00:11:30.720
解决这个问题的方法，在这里您可以

00:11:29.250 --> 00:11:31.089
看到有很多不同

00:11:30.720 --> 00:11:34.569
理念

00:11:31.089 --> 00:11:37.120
我们都汇聚在

00:11:34.569 --> 00:11:38.709
我们将其整合在一起的想法

00:11:37.120 --> 00:11:40.689
反应堆主动行动

00:11:38.709 --> 00:11:43.629
反应流倡议是一种

00:11:40.689 --> 00:11:45.399
描述这一点的事实标准

00:11:43.629 --> 00:11:46.800
这是这件遗失的东西

00:11:45.399 --> 00:11:49.389
你有反应性的主动行动

00:11:46.800 --> 00:11:53.139
这基本上是一个规范

00:11:49.389 --> 00:11:55.870
非常小的规格，我们描述了四个

00:11:53.139 --> 00:11:58.089
接口的类型，第一个和大多数

00:11:55.870 --> 00:12:01.180
我认为重要的是发布商

00:11:58.089 --> 00:12:03.550
发布者是如果

00:12:01.180 --> 00:12:05.230
产生订户所依赖的价值

00:12:03.550 --> 00:12:08.259
那是另一个界面可能会订阅

00:12:05.230 --> 00:12:09.550
因此，订阅是

00:12:08.259 --> 00:12:12.189
已创建，因此您具有三个界面

00:12:09.550 --> 00:12:14.100
到目前为止，有一个发布者和一个订阅者

00:12:12.189 --> 00:12:16.569
订阅，如果您有

00:12:14.100 --> 00:12:18.759
产生值的组件

00:12:16.569 --> 00:12:20.589
说一个出版商，然后

00:12:18.759 --> 00:12:22.240
从其他订阅

00:12:20.589 --> 00:12:24.220
发布者，那么你有一个叫做

00:12:22.240 --> 00:12:25.660
一个处理器，一个处理器就是我们

00:12:24.220 --> 00:12:27.009
第四界面就是这样

00:12:25.660 --> 00:12:29.319
这就是反应堆的全部

00:12:27.009 --> 00:12:31.600
流规范，现在看来

00:12:29.319 --> 00:12:33.670
诱人，您可能会想

00:12:31.600 --> 00:12:35.199
冲出去并尝试改善这些

00:12:33.670 --> 00:12:37.660
界面，让自己反应

00:12:35.199 --> 00:12:41.860
但我向你保证这是一个非常糟糕的主意

00:12:37.660 --> 00:12:43.870
正确的工作很多

00:12:41.860 --> 00:12:45.429
必须在较低的级别上完成

00:12:43.870 --> 00:12:49.329
为了做到这一点，所以我们有

00:12:45.429 --> 00:12:51.550
幸运的是，您幸运地知道我们有一个

00:12:49.329 --> 00:12:53.670
这里有很多选择

00:12:51.550 --> 00:12:56.290
生态系统对反应堆流的影响

00:12:53.670 --> 00:12:59.769
规范已由实施

00:12:56.290 --> 00:13:01.629
当然我们自己的项目反应堆akka 

00:12:59.769 --> 00:13:04.569
流项目，我的图钉可以将其用作

00:13:01.629 --> 00:13:07.600
良好的顶点也影响了它

00:13:04.569 --> 00:13:09.670
课程RX Java-Dino，所以我们现在有了

00:13:07.600 --> 00:13:11.920
这里是互操作性的机制

00:13:09.670 --> 00:13:15.429
当然，然后工作启发了

00:13:11.920 --> 00:13:17.110
像这样的JDK 9流模块

00:13:15.429 --> 00:13:20.920
这是我们可以通过的另一个渠道

00:13:17.110 --> 00:13:24.459
看到这件遗失的东西

00:13:20.920 --> 00:13:27.160
现在解决了它提供的反应流

00:13:24.459 --> 00:13:29.529
我们对知识的了解非常低

00:13:27.160 --> 00:13:31.120
单一类型或单一类型集合

00:13:29.529 --> 00:13:33.429
我们遵循的类型非常少

00:13:31.120 --> 00:13:35.620
可以同意mmm，但是我认为

00:13:33.429 --> 00:13:37.839
本身并不是所有有用的

00:13:35.620 --> 00:13:39.670
数组作为

00:13:37.839 --> 00:13:41.470
共同的运输机制

00:13:39.670 --> 00:13:43.449
来回携带数据的方式

00:13:41.470 --> 00:13:44.680
一个组件到另一个组件仍然非常

00:13:43.449 --> 00:13:46.060
我们倾向于低水平

00:13:44.680 --> 00:13:48.040
用我们的数据做更多有趣的事情

00:13:46.060 --> 00:13:50.350
不仅仅是存储正确，我们需要

00:13:48.040 --> 00:13:53.890
能够对其进行处理以将其转换为

00:13:50.350 --> 00:13:55.540
过滤等，所以我们寻找

00:13:53.890 --> 00:13:57.220
高阶经营者dia出售东西

00:13:55.540 --> 00:13:59.410
这样的服务在那里

00:13:57.220 --> 00:14:02.290
在这里，反应堆变成了自己的权利

00:13:59.410 --> 00:14:04.570
有非常丰富的API集

00:14:02.290 --> 00:14:08.200
丰富的功能和反应堆

00:14:04.570 --> 00:14:10.839
现在的项目就足够了，我仍然会说

00:14:08.200 --> 00:14:14.890
本身没有反应器

00:14:10.839 --> 00:14:16.480
有趣的是专注于成为

00:14:14.890 --> 00:14:19.750
反应性运行时，不一定

00:14:16.480 --> 00:14:21.700
解决您所关心的问题

00:14:19.750 --> 00:14:24.070
订购功能，例如建立网站

00:14:21.700 --> 00:14:26.649
服务以及数据访问和安全性

00:14:24.070 --> 00:14:27.220
等等，这就是我们的故事

00:14:26.649 --> 00:14:29.020
开始

00:14:27.220 --> 00:14:32.290
你看我们上周才发布

00:14:29.020 --> 00:14:34.839
 spring文件和spring 5有一个数字

00:14:32.290 --> 00:14:37.600
特色，包括犬

00:14:34.839 --> 00:14:40.180
在拥有jk8基线时提供支持

00:14:37.600 --> 00:14:42.970
不包括对Java EE 7和

00:14:40.180 --> 00:14:44.860
 Java 8充满了强大的功能

00:14:42.970 --> 00:14:46.680
功能，但我最喜欢的功能是

00:14:44.860 --> 00:14:49.420
支持建立反应式

00:14:46.680 --> 00:14:51.700
应用程序，并且从网络开始

00:14:49.420 --> 00:14:54.700
 Spring Framework 5中的层

00:14:51.700 --> 00:14:56.290
引入了一个新的新运行时，所以我

00:14:54.700 --> 00:14:59.770
今天要谈论所有这些东西

00:14:56.290 --> 00:15:01.959
现在回到这个想法

00:14:59.770 --> 00:15:04.959
对于项目反应堆，重要的是

00:15:01.959 --> 00:15:08.100
了解反应堆的基础是两个

00:15:04.959 --> 00:15:10.510
反应流的主要类型

00:15:08.100 --> 00:15:14.260
发布者类型，因此我们有两种类型

00:15:10.510 --> 00:15:17.020
反应堆称为单声道单声道为

00:15:14.260 --> 00:15:20.020
受限制的发布者为0 

00:15:17.020 --> 00:15:22.200
或1个正确的值，所以您没有任何价值或

00:15:20.020 --> 00:15:25.000
您有1 by odes，它仍然是发布者

00:15:22.200 --> 00:15:26.200
只是一个发行商

00:15:25.000 --> 00:15:27.940
当然现在可以生产一个或另一个

00:15:26.200 --> 00:15:29.440
您仍然可以按照

00:15:27.940 --> 00:15:31.209
发行人合同，在所有情况下

00:15:29.440 --> 00:15:31.510
您的消费代码将不是

00:15:31.209 --> 00:15:32.680
明智的

00:15:31.510 --> 00:15:35.770
只是他们只会得到一个

00:15:32.680 --> 00:15:38.740
重视我们拥有的另一种类型是

00:15:35.770 --> 00:15:42.070
被称为flux FL UX，它是发布者

00:15:38.740 --> 00:15:43.779
产生0到n的值，并且

00:15:42.070 --> 00:15:45.220
你知道这些的原因

00:15:43.779 --> 00:15:47.399
区分类型是有用的

00:15:45.220 --> 00:15:50.589
主要用于文档，主要用于

00:15:47.399 --> 00:15:52.690
给消费者一个提示

00:15:50.589 --> 00:15:55.390
关于意图是什么，想像你是

00:15:52.690 --> 00:15:58.279
试图渲染一个屏幕和

00:15:55.390 --> 00:16:00.800
屏幕上有一个可能是

00:15:58.279 --> 00:16:02.569
天野右与网格在这种情况下

00:16:00.800 --> 00:16:04.370
你可以期望使用助焊剂吧

00:16:02.569 --> 00:16:06.920
否则你不会有任何想法

00:16:04.370 --> 00:16:12.110
关于如何设置外观

00:16:06.920 --> 00:16:14.629
因为现在这给了我们沃土

00:16:12.110 --> 00:16:16.279
为一些你知道的有趣的事情打下基础

00:16:14.629 --> 00:16:18.589
应用，我们可以构建任何

00:16:16.279 --> 00:16:20.209
我可以想到的应用数量

00:16:18.589 --> 00:16:22.370
希望保持我们的域名简单易用

00:16:20.209 --> 00:16:23.660
琐碎的，所以我喜欢

00:16:22.370 --> 00:16:25.519
想着我在想这个

00:16:23.660 --> 00:16:27.620
与我和我的朋友马克·赫克特

00:16:25.519 --> 00:16:29.449
前几天我们在考虑

00:16:27.620 --> 00:16:32.209
某种示例应用程序某种类型的应用程序

00:16:29.449 --> 00:16:34.069
我们可以在互联网上使用的权利

00:16:32.209 --> 00:16:35.689
如果我们有某种应用程序

00:16:34.069 --> 00:16:37.730
允许我们谈论和互动

00:16:35.689 --> 00:16:40.459
例如现在有英文电影

00:16:37.730 --> 00:16:42.259
口语化是说

00:16:40.459 --> 00:16:43.910
你有一部电影，如果你有一部电影

00:16:42.259 --> 00:16:45.499
如果您想使用语，可以

00:16:43.910 --> 00:16:47.329
说如果你有多个，那是轻弹

00:16:45.499 --> 00:16:49.610
我们所谓的电影我们称之为的电影

00:16:47.329 --> 00:16:51.860
那些轻弹，所以我们在考虑

00:16:49.610 --> 00:16:53.240
如果我们提供某种服务怎么办？ 

00:16:51.860 --> 00:16:55.160
再次听到我的声音可能有点

00:16:53.240 --> 00:16:57.079
疯了，但是如果我们有某种

00:16:55.160 --> 00:16:59.870
我们可以轻弹的服务

00:16:57.079 --> 00:17:02.269
并通过网络与电影互动

00:16:59.870 --> 00:17:03.980
再一次，我知道这很荒谬

00:17:02.269 --> 00:17:05.419
但还是要听我说我们想

00:17:03.980 --> 00:17:08.299
有某种服务可以使用

00:17:05.419 --> 00:17:09.890
在网上轻弹，我当时

00:17:08.299 --> 00:17:11.120
以为我们以为可以打电话

00:17:09.890 --> 00:17:13.579
它是Netflix 

00:17:11.120 --> 00:17:17.659
您对反应堆的看法如何？ 

00:17:13.579 --> 00:17:18.770
弹性和不好，反正我们要

00:17:17.659 --> 00:17:21.740
这样做，我们需要建立一个新的

00:17:18.770 --> 00:17:23.360
服务，当然我要用我的

00:17:21.740 --> 00:17:26.480
最喜欢的工具来完成我将要使用的工作

00:17:23.360 --> 00:17:28.940
 IntelliJ对，所以我这里有IntelliJ 

00:17:26.480 --> 00:17:31.120
现在通常在这一点上，我带我们去

00:17:28.940 --> 00:17:33.590
从那个春天开始IO，那是一个

00:17:31.120 --> 00:17:34.940
一个很好的起点，但是如果你

00:17:33.590 --> 00:17:36.649
我期望使用IntelliJ 

00:17:34.940 --> 00:17:38.179
然后，这些观众中的人

00:17:36.649 --> 00:17:41.000
这里有一个非常方便的小选择

00:17:38.179 --> 00:17:44.120
创建新项目并创建新

00:17:41.000 --> 00:17:46.490
项目会打开一个向导，当您

00:17:44.120 --> 00:17:48.530
进入向导，您将有机会

00:17:46.490 --> 00:17:51.830
指向一个特定的开始

00:17:48.530 --> 00:17:54.110
春天的格雷罗排列，我们在那里

00:17:51.830 --> 00:17:56.990
可以指定工件的名称，以便助焊剂

00:17:54.110 --> 00:17:58.970
轻弹服务，我们将做这个

00:17:56.990 --> 00:18:00.590
一个complan项目，只是因为

00:17:58.970 --> 00:18:03.770
如果您了解Java，则非常简单

00:18:00.590 --> 00:18:06.830
我认为这是一个很好的机会

00:18:03.770 --> 00:18:09.020
演示它，然后我们将击中

00:18:06.830 --> 00:18:10.580
接下来，这将向我们展示所有选项

00:18:09.020 --> 00:18:12.169
现在在这里，我要选择 spring boot 

00:18:10.580 --> 00:18:14.779
自动快照

00:18:12.169 --> 00:18:16.999
春季靴中的isten平地机

00:18:14.779 --> 00:18:20.029
弹簧靴是完全集成的

00:18:16.999 --> 00:18:22.460
反应性的框架

00:18:20.029 --> 00:18:25.190
我们在今年12月发布

00:18:22.460 --> 00:18:26.539
期待，然后你会知道所有

00:18:25.190 --> 00:18:27.980
其他的东西，我们所有其他的东西

00:18:26.539 --> 00:18:30.470
我们在生态系统泡沫中所做的

00:18:27.980 --> 00:18:32.419
直到这个版本，所以Spring框架

00:18:30.470 --> 00:18:36.789
 5当然是上周发布的

00:18:32.419 --> 00:18:39.109
弹簧安全5弹簧数据K弹簧

00:18:36.789 --> 00:18:41.389
 Spring和QP所有其他的事情

00:18:39.109 --> 00:18:44.600
有反应性的支持会冒泡

00:18:41.389 --> 00:18:47.690
到 spring boot ，我不是这样

00:18:44.600 --> 00:18:50.929
我们将在这里使用反应性网络

00:18:47.690 --> 00:18:55.100
支持将使用反应式MongoDB将

00:18:50.929 --> 00:18:57.019
现在使用反应式安全

00:18:55.100 --> 00:18:58.519
是的，你知道我看到了一种选择的反应

00:18:57.019 --> 00:19:00.139
 MongoDB让我们来看看那些

00:18:58.519 --> 00:19:01.879
再次选择这里我们有反应性不

00:19:00.139 --> 00:19:03.739
将是反应性的Cassandra反应性

00:19:01.879 --> 00:19:04.970
网络和反应式所有Redis现在都有

00:19:03.739 --> 00:19:06.919
一些不同的好数目

00:19:04.970 --> 00:19:09.649
不同的和非常好的选择，在这里和

00:19:06.919 --> 00:19:11.299
但到目前为止，这些是

00:19:09.649 --> 00:19:15.019
定义它们是

00:19:11.299 --> 00:19:16.489
 spring data 优先支持的选项

00:19:15.019 --> 00:19:18.889
所以春天当然是雨伞

00:19:16.489 --> 00:19:20.539
我们曾经解决过的项目

00:19:18.889 --> 00:19:23.389
交互和数据的续集

00:19:20.539 --> 00:19:24.859
处理功能，以及

00:19:23.389 --> 00:19:26.450
即使在 spring data 中，我们还有一个

00:19:24.859 --> 00:19:27.739
我们在这里没有的选择浮出水面

00:19:26.450 --> 00:19:30.799
在我们的 spring boot 自动配置中

00:19:27.739 --> 00:19:32.389
那是反应性的Couchbase对，所以

00:19:30.799 --> 00:19:36.320
那还没到这里，但是会

00:19:32.389 --> 00:19:38.960
 be and然后甚至是那的子集

00:19:36.320 --> 00:19:41.179
当然有哪些 spring data 

00:19:38.960 --> 00:19:42.769
本身支持您，您可能知道

00:19:41.179 --> 00:19:44.559
 spring数据支持任意数量的

00:19:42.769 --> 00:19:50.090
其他不同的技术，包括

00:19:44.559 --> 00:19:51.889
最明显的是kpa，现在JPA是a ORM 

00:19:50.090 --> 00:19:53.869
框架这是一种规范技术，这是一种

00:19:51.889 --> 00:19:55.700
它通常是基于事物的

00:19:53.869 --> 00:19:59.840
像Kochs链接，然后休眠

00:19:55.700 --> 00:20:03.859
好吧，我们没有最低的水平

00:19:59.840 --> 00:20:08.299
 JPA的反应能力

00:20:03.859 --> 00:20:11.840
正确的编程JBC是一个阻止api 

00:20:08.299 --> 00:20:13.730
现在我们可以在

00:20:11.840 --> 00:20:15.830
根本阻止的事情的顶部

00:20:13.730 --> 00:20:18.679
但我们认为我们的想法是

00:20:15.830 --> 00:20:20.779
从根本上说不是很

00:20:18.679 --> 00:20:24.349
有用的对于

00:20:20.779 --> 00:20:26.060
就像我阻塞API一样

00:20:24.349 --> 00:20:27.980
当你知道的时候

00:20:26.060 --> 00:20:29.780
我们必须改变一些东西才能得到

00:20:27.980 --> 00:20:31.700
什么也没有得到任何好处，所以

00:20:29.780 --> 00:20:33.950
我们不会尝试去做到这一点

00:20:31.700 --> 00:20:36.680
现在不打算扭转这些事情

00:20:33.950 --> 00:20:38.630
我们受到鼓舞，我认为我们都充满希望

00:20:36.680 --> 00:20:41.720
关于最近发布的

00:20:38.630 --> 00:20:45.710
最近真正宣布的JB反应式

00:20:41.720 --> 00:20:47.780
您知道Oracle正在完成JDBC工作

00:20:45.710 --> 00:20:50.300
他们开始的细节

00:20:47.780 --> 00:20:52.580
在最近几天宣布

00:20:50.300 --> 00:20:54.980
 Java之一，这很有趣，我们将看到

00:20:52.580 --> 00:20:56.360
哪里去了，但现在我们要去

00:20:54.980 --> 00:20:58.310
使用的技术是

00:20:56.360 --> 00:20:59.750
适当而充分地反应，所以我们

00:20:58.310 --> 00:21:01.190
现在会坚持使用反应性MongoDB 

00:20:59.750 --> 00:21:03.380
再次有许多不同的选择

00:21:01.190 --> 00:21:06.410
但是反应性MongoDB可以正常工作，所以

00:21:03.380 --> 00:21:09.760
我们接下来要打，我们自己

00:21:06.410 --> 00:21:09.760
新项目开始

00:21:10.130 --> 00:21:17.000
好的，所以我们有一项新服务， 

00:21:15.590 --> 00:21:19.429
我想做的第一件事就是我想

00:21:17.000 --> 00:21:20.990
我想在这里禁用安全性

00:21:19.429 --> 00:21:22.610
因为那不会做任何事情

00:21:20.990 --> 00:21:26.630
我们还没有，所以让我们回到我们的

00:21:22.610 --> 00:21:28.370
构建，我们将构建一个新服务，因此

00:21:26.630 --> 00:21:30.470
这是我们的 spring boot 首发

00:21:28.370 --> 00:21:31.880
安全反应其他一切都一样

00:21:30.470 --> 00:21:34.610
我们希望您会注意到

00:21:31.880 --> 00:21:35.960
弹簧弹簧自动空气尺

00:21:34.610 --> 00:21:38.450
支持科特曼，所以我们有康克林

00:21:35.960 --> 00:21:41.350
支持那里，我们有棉花SD 

00:21:38.450 --> 00:21:44.409
您知道我们有一个标准库

00:21:41.350 --> 00:21:46.429
运行时等我们有一个共同点

00:21:44.409 --> 00:21:47.270
编译器插件全部插入并且

00:21:46.429 --> 00:21:48.830
我所有的一切都只是

00:21:47.270 --> 00:21:50.240
已免费设置，因此我们不必

00:21:48.830 --> 00:21:51.620
担心别的事情，现在我们可以去了

00:21:50.240 --> 00:21:53.059
代码，然后开始构建

00:21:51.620 --> 00:21:54.350
应用程序，所以第一件事

00:21:53.059 --> 00:21:56.179
我们要在这里做我们要建立

00:21:54.350 --> 00:21:58.730
约会的权利，我们将建立一个

00:21:56.179 --> 00:22:00.559
模特谈论电影，现在这是一个

00:21:58.730 --> 00:22:01.850
定期春季良好的应用程序，如果

00:22:00.559 --> 00:22:02.960
你还没看过Kotlin 

00:22:01.850 --> 00:22:05.659
基本上公共静态无效主体

00:22:02.960 --> 00:22:07.429
进入应用程序的入口

00:22:05.659 --> 00:22:08.750
 Kotlin上女孩的名字

00:22:07.429 --> 00:22:11.809
左边和右边的类型，所以

00:22:08.750 --> 00:22:13.280
 args冒号或字符串，否则

00:22:11.809 --> 00:22:15.799
我认为这应该看起来非常

00:22:13.280 --> 00:22:17.960
如果您曾经使用过弹簧，请熟悉

00:22:15.799 --> 00:22:20.480
靴子，让我们看看我们要打造

00:22:17.960 --> 00:22:22.669
现在是电影建模的一种类型

00:22:20.480 --> 00:22:24.440
将会是一部有几部电影的电影

00:22:22.669 --> 00:22:27.710
我可以说我可以做到这一点

00:22:24.440 --> 00:22:29.360
我可以说酒吧ID等于字符串，所以

00:22:27.710 --> 00:22:30.710
字符串的类型，我希望该类型为

00:22:29.360 --> 00:22:32.299
博学，所以我想成为

00:22:30.710 --> 00:22:34.970
那我想要一个默认值

00:22:32.299 --> 00:22:37.880
空值的正确值，因此在这种情况下为VAR 

00:22:34.970 --> 00:22:40.220
告诉科特林，这很容易变

00:22:37.880 --> 00:22:41.900
变量并说我可以更改它，所以我

00:22:40.220 --> 00:22:44.059
可以做到，我可以辞职

00:22:41.900 --> 00:22:45.650
吸气剂和二传手如果我想但是

00:22:44.059 --> 00:22:47.570
这是我真正想要的很多工作

00:22:45.650 --> 00:22:48.919
我只想让科特林做

00:22:47.570 --> 00:22:52.280
该工作，因为我试图做到这一点

00:22:48.919 --> 00:22:55.039
从根本上得到一份工作

00:22:52.280 --> 00:22:57.110
我将保存我们的ID字符串问号

00:22:55.039 --> 00:23:00.470
等于null 

00:22:57.110 --> 00:23:02.870
好的，我将保存标题字符串

00:23:00.470 --> 00:23:05.600
问号等于否否这是我的

00:23:02.870 --> 00:23:07.190
基本的javabean，我想做一个

00:23:05.600 --> 00:23:09.980
文档，所以我将使用spring数据

00:23:07.190 --> 00:23:14.180
文档注释在这里，我会说

00:23:09.980 --> 00:23:15.710
在这里添加ID，这就是我的

00:23:14.180 --> 00:23:17.450
实体权利将成为春天

00:23:15.710 --> 00:23:19.850
数据将成为文档

00:23:17.450 --> 00:23:22.940
我将拥有主键之类的东西

00:23:19.850 --> 00:23:25.640
名为ID的键，默认值为

00:23:22.940 --> 00:23:27.080
不是，他们是众所周知的

00:23:25.640 --> 00:23:28.840
它会有吸气剂我会有吸气剂

00:23:27.080 --> 00:23:31.010
现在所有的东西我都想做

00:23:28.840 --> 00:23:33.080
数据类我完全走了一步

00:23:31.010 --> 00:23:34.840
进一步给我平等，我上学

00:23:33.080 --> 00:23:37.640
诸如此类，我可以用来

00:23:34.840 --> 00:23:39.470
支持平等权利好吧，现在

00:23:37.640 --> 00:23:40.790
我有电影，我想做什么

00:23:39.470 --> 00:23:43.310
希望能够坚持或互动

00:23:40.790 --> 00:23:44.840
与该实体的实例

00:23:43.310 --> 00:23:46.340
在这种情况下，基础数据层

00:23:44.840 --> 00:23:48.410
 MongoDB，所以我需要写一个仓库

00:23:46.340 --> 00:23:50.720
仓库设计的设计模式

00:23:48.410 --> 00:23:52.370
支持您知道过时的数据

00:23:50.720 --> 00:23:55.040
最小化数据管理生命周期，因此

00:23:52.370 --> 00:23:59.380
我会说电影资料库还可以

00:23:55.040 --> 00:24:02.720
我们将扩大反应性

00:23:59.380 --> 00:24:03.800
 Mongo仓库现在是反应漫画

00:24:02.720 --> 00:24:06.200
仓库与其他仓库一样

00:24:03.800 --> 00:24:07.190
存储库期望两种类型

00:24:06.200 --> 00:24:09.260
期望我们想要的类型

00:24:07.190 --> 00:24:11.090
与此互动是在电影中， 

00:24:09.260 --> 00:24:12.710
现在是主键的类型

00:24:11.090 --> 00:24:14.720
不必我什至不必做

00:24:12.710 --> 00:24:16.460
没错，这足以让我得到

00:24:14.720 --> 00:24:17.750
现在要这个反应性漫画库

00:24:16.460 --> 00:24:19.190
与任何其他存储库相同

00:24:17.750 --> 00:24:21.080
您可能已经在 spring data 中看到了

00:24:19.190 --> 00:24:23.270
除了返回类型是这些

00:24:21.080 --> 00:24:25.190
发布者子类型或单声道和流量

00:24:23.270 --> 00:24:26.660
等等，他们进一步接受

00:24:25.190 --> 00:24:28.460
出版商权利，所以我们可以接受

00:24:26.660 --> 00:24:30.740
发布商并返回特定类型的

00:24:28.460 --> 00:24:32.330
发布商，所以我们将免费获得所有这些

00:24:30.740 --> 00:24:36.440
现在我们可以在其中保存一些示例数据

00:24:32.330 --> 00:24:40.820
现在我要数据库

00:24:36.440 --> 00:24:42.860
这是您知道类型的豆

00:24:40.820 --> 00:24:44.030
这将是一个应用程序

00:24:42.860 --> 00:24:46.280
跑步者，所以我要创建一个lambda 

00:24:44.030 --> 00:24:50.150
再次，这是一个很棒的回调接口

00:24:46.280 --> 00:24:53.300
弹簧靴提供的

00:24:50.150 --> 00:24:55.880
回调接口有一种方法无效

00:24:53.300 --> 00:24:57.080
现在当然可以在Kotlin运行

00:24:55.880 --> 00:25:00.230
创建一个lambda，然后输入该地址

00:24:57.080 --> 00:25:02.809
现在像这样空运行方法

00:25:00.230 --> 00:25:04.669
这里有论点，我们可以，我们可以

00:25:02.809 --> 00:25:06.530
选择，因为我们只有一个

00:25:04.669 --> 00:25:08.870
我们无法选择创建一个参数

00:25:06.530 --> 00:25:10.190
这样的参数，否则我们可以离开

00:25:08.870 --> 00:25:11.690
一个人，我们不必指定

00:25:10.190 --> 00:25:13.340
它可以通过隐式使用

00:25:11.690 --> 00:25:15.080
这里的参数还好吧

00:25:13.340 --> 00:25:16.400
存在变量，因为

00:25:15.080 --> 00:25:17.840
我们甚至都不会在这种情况下使用它

00:25:16.400 --> 00:25:19.669
真的没有任何意义

00:25:17.840 --> 00:25:21.410
关心它，所以让我们现在写一些

00:25:19.669 --> 00:25:23.030
将数据采样到数据库，以便电影

00:25:21.410 --> 00:25:25.070
等于当我们在这里创建通量时

00:25:23.030 --> 00:25:28.059
一些示例数据，我喜欢使用

00:25:25.070 --> 00:25:30.549
以主题为基础的数据

00:25:28.059 --> 00:25:32.660
反应式编程和主题

00:25:30.549 --> 00:25:34.549
你知道函数式反应式编程

00:25:32.660 --> 00:25:36.530
所以我要拍一些电影

00:25:34.549 --> 00:25:38.120
根据这些主题在这里如何

00:25:36.530 --> 00:25:40.040
这是我们朋友送来的

00:25:38.120 --> 00:25:42.020
唯一令人惊奇的菲尔·韦伯

00:25:40.040 --> 00:25:45.049
 Spring boo的共同创始人

00:25:42.020 --> 00:25:46.549
沉默的羔羊是不错的选择

00:25:45.049 --> 00:25:47.690
一个，我们要用那部电影

00:25:46.549 --> 00:25:49.809
有一个动漫这个词

00:25:47.690 --> 00:25:52.760
不断变化，所以我们可以说Aeon Flux 

00:25:49.809 --> 00:25:54.049
有一部电影，他们

00:25:52.760 --> 00:25:56.990
谈论磁通电容器

00:25:54.049 --> 00:25:58.549
回到未来吧

00:25:56.990 --> 00:25:59.780
如果您在此处选择不同的数量

00:25:58.549 --> 00:26:03.320
想到别人，请不要

00:25:59.780 --> 00:26:05.179
犹豫要在Twitter上将它们发送出去

00:26:03.320 --> 00:26:08.270
很想听听他们的声音，所以我们在这里

00:26:05.179 --> 00:26:10.160
一个我要出版的三弦琴

00:26:08.270 --> 00:26:12.770
把那三根弦变成电影

00:26:10.160 --> 00:26:14.059
所以我要说我想保存

00:26:12.770 --> 00:26:16.970
现在的数据我当然想保存数据

00:26:14.059 --> 00:26:18.350
在这里使用电影资料库

00:26:16.970 --> 00:26:21.710
盐注入作为合作

00:26:18.350 --> 00:26:23.330
我会说点先生保存电影标题的对象

00:26:21.710 --> 00:26:25.640
等于它记得那是隐含的

00:26:23.330 --> 00:26:26.929
此参数的参数，因为

00:26:25.640 --> 00:26:29.030
这是一个参数，它是一个lambda 

00:26:26.929 --> 00:26:30.950
不必实际封装

00:26:29.030 --> 00:26:33.169
虽然我带括号的方法调用

00:26:30.950 --> 00:26:35.000
可以写的只是语法快捷方式

00:26:33.169 --> 00:26:38.470
在这里，他们完成了保存每个

00:26:35.000 --> 00:26:40.910
现在记录下来，这使我成为

00:26:38.470 --> 00:26:43.700
电影版权，我可以看到

00:26:40.910 --> 00:26:45.500
通过分配来尽可能多地确认

00:26:43.700 --> 00:26:47.150
这是一条紧线，它是可选的

00:26:45.500 --> 00:26:49.100
在这种情况下，它将是类型推断，但是

00:26:47.150 --> 00:26:50.900
就我们的目的而言，这只是一个

00:26:49.100 --> 00:26:52.910
知道现在我们要保存很有用

00:26:50.900 --> 00:26:54.380
所有这些数据，但在保存之前

00:26:52.910 --> 00:26:55.429
我要删除所有现有的

00:26:54.380 --> 00:26:57.770
数据，所以我要做的就是

00:26:55.429 --> 00:27:00.350
说我现在要删除所有

00:26:57.770 --> 00:27:02.179
在其他所有事情发生之前

00:27:00.350 --> 00:27:04.100
所以我可以做到的一种方法是说

00:27:02.179 --> 00:27:06.049
现在阻止，这是一个可怕的想法

00:27:04.100 --> 00:27:07.340
我向我展示了此代码

00:27:06.049 --> 00:27:10.370
重要的另一个，她看着我

00:27:07.340 --> 00:27:11.630
就像我不是很聪明所以不要

00:27:10.370 --> 00:27:13.340
这是一件可怕的事

00:27:11.630 --> 00:27:14.100
你有这个很棒的反应式API 

00:27:13.340 --> 00:27:15.330
我们在这里

00:27:14.100 --> 00:27:18.630
好的，我们要做的是

00:27:15.330 --> 00:27:20.789
说删除所有内容然后处理

00:27:18.630 --> 00:27:25.260
电影发行商的权利，所以我们有

00:27:20.789 --> 00:27:27.650
电影，然后我们想看看我们

00:27:25.260 --> 00:27:27.650
想说

00:27:28.310 --> 00:27:32.360
我们想说我们想回来

00:27:31.160 --> 00:27:33.350
从...回来的一切

00:27:32.360 --> 00:27:34.520
数据库，所以当我们打开一切

00:27:33.350 --> 00:27:38.810
我们在那里

00:27:34.520 --> 00:27:40.100
然后我们要订阅

00:27:38.810 --> 00:27:43.010
最后一种方法最重要

00:27:40.100 --> 00:27:44.600
我们正在做的是我们在说什么时候

00:27:43.010 --> 00:27:46.240
完成了图的建立

00:27:44.600 --> 00:27:48.410
我正在建立一个

00:27:46.240 --> 00:27:50.360
反应性管道，如果您能做到这些

00:27:48.410 --> 00:27:53.120
前三个操作是管道

00:27:50.360 --> 00:27:55.940
我是说先做这个然后

00:27:53.120 --> 00:27:58.130
这什么都不会发生

00:27:55.940 --> 00:27:59.900
订阅或阻止它，这样

00:27:58.130 --> 00:28:02.540
并最终阻止只是订阅

00:27:59.900 --> 00:28:05.030
所以我在做的是我在开始

00:28:02.540 --> 00:28:07.160
我正在执行的管道

00:28:05.030 --> 00:28:08.900
定义在这里，我在卖我

00:28:07.160 --> 00:28:10.610
告诉发布者我

00:28:08.900 --> 00:28:12.140
有兴趣获取它的价值

00:28:10.610 --> 00:28:14.480
可以发射，所以在这里我们要

00:28:12.140 --> 00:28:15.920
打印打开时返回的所有内容

00:28:14.480 --> 00:28:18.040
控制台好了，现在让我们运行

00:28:15.920 --> 00:28:18.040
应用

00:28:23.410 --> 00:28:25.470
您

00:28:27.690 --> 00:28:29.750
您

00:28:47.740 --> 00:28:51.669
好吧，所以我们在那里

00:28:49.899 --> 00:28:53.110
具有三个记录的应用程序

00:28:51.669 --> 00:28:57.090
控制台，团队将拥有

00:28:53.110 --> 00:28:59.620
如此有效，现在我们可以创建商品了

00:28:57.090 --> 00:29:01.390
让我们现在创建一个服务

00:28:59.620 --> 00:29:03.490
最终最终想做的是善良的

00:29:01.390 --> 00:29:05.559
 Web应用程序Web终结点，但为了

00:29:03.490 --> 00:29:06.730
让我们建立一项服务

00:29:05.559 --> 00:29:09.700
我们的业务逻辑，所以我想创建一个

00:29:06.730 --> 00:29:12.600
像这样的电影服务和服务

00:29:09.700 --> 00:29:14.770
反过来将注入或与

00:29:12.600 --> 00:29:18.720
电影资料库，所以我要说

00:29:14.770 --> 00:29:21.070
私人Val M我们的电影资料库和

00:29:18.720 --> 00:29:23.289
该服务将服务于

00:29:21.070 --> 00:29:24.880
表面高阶业务逻辑

00:29:23.289 --> 00:29:27.549
对，所以我们要说我们有一个

00:29:24.880 --> 00:29:30.070
这里的端点返回所有

00:29:27.549 --> 00:29:33.490
记录，我要说点先生找到所有

00:29:30.070 --> 00:29:35.260
我们会再说一个

00:29:33.490 --> 00:29:38.620
我们要返回一个特定的

00:29:35.260 --> 00:29:43.360
通过其ID，因此找到了这个先生点

00:29:38.620 --> 00:29:44.559
 ID ID和最后一个端点我

00:29:43.360 --> 00:29:46.899
想要我有一个终点

00:29:44.559 --> 00:29:48.370
可以在事件中说

00:29:46.899 --> 00:29:50.950
我想我有机会

00:29:48.370 --> 00:29:52.750
以某种方式登录服务和故事

00:29:50.950 --> 00:29:54.250
反映所有输出的所有日志

00:29:52.750 --> 00:29:56.350
从所有的服务中

00:29:54.250 --> 00:29:58.330
有趣的是我想我不

00:29:56.350 --> 00:30:00.159
如果我是

00:29:58.330 --> 00:30:01.480
你知道没有没有

00:30:00.159 --> 00:30:03.760
陈述和正确的语言，所以

00:30:01.480 --> 00:30:05.559
这就是一切，所以在这里

00:30:03.760 --> 00:30:07.320
我有一个方法，它返回一个

00:30:05.559 --> 00:30:09.039
单一值，无需创建

00:30:07.320 --> 00:30:11.320
括号括号等

00:30:09.039 --> 00:30:13.450
我可以并且我可以说的东西

00:30:11.320 --> 00:30:17.140
调用时此方法的结果

00:30:13.450 --> 00:30:18.159
这是这里的陈述

00:30:17.140 --> 00:30:19.990
当然，您可以互动的世界

00:30:18.159 --> 00:30:23.049
很好地更改这些方法，以便您

00:30:19.990 --> 00:30:24.220
得到一份长声明或一项对不起的声明

00:30:23.049 --> 00:30:25.840
长长的表情要回头

00:30:24.220 --> 00:30:27.760
这最后很方便

00:30:25.840 --> 00:30:30.640
终点在这里就像我说的那样

00:30:27.760 --> 00:30:32.620
并终结一项服务，使我能够

00:30:30.640 --> 00:30:34.960
查看所有活动

00:30:32.620 --> 00:30:37.480
给定电影，那么我可以看谁

00:30:34.960 --> 00:30:38.470
流的视频，我可以流

00:30:37.480 --> 00:30:40.090
有关人的信息

00:30:38.470 --> 00:30:42.970
当然，现在流式传输所有视频

00:30:40.090 --> 00:30:45.070
实际上还没有八兆

00:30:42.970 --> 00:30:47.380
用户登录系统

00:30:45.070 --> 00:30:49.000
看着你知道的输出

00:30:47.380 --> 00:30:50.710
看所有不同的电影等等

00:30:49.000 --> 00:30:52.149
我们没有真正的样本数据，所以让我们

00:30:50.710 --> 00:30:54.159
只是想想，直到我们做到这一点

00:30:52.149 --> 00:30:56.139
流我们将要穿越的所有流

00:30:54.159 --> 00:30:57.970
向捉鬼敢死队借来的小溪

00:30:56.139 --> 00:30:59.860
对，所以我要说有趣的事件， 

00:30:57.970 --> 00:31:01.420
我们将寻找所有的活动

00:30:59.860 --> 00:31:02.230
一部特定的电影以及我们

00:31:01.420 --> 00:31:04.560
我们要做的是当我

00:31:02.230 --> 00:31:09.430
产生，我们将合成一个新的

00:31:04.560 --> 00:31:11.440
一个新的新记录好了，电影是

00:31:09.430 --> 00:31:13.480
将会成为唱片

00:31:11.440 --> 00:31:16.510
电影事件类型正确的，所以这是

00:31:13.480 --> 00:31:18.190
将会是另一个数据类

00:31:16.510 --> 00:31:22.720
它会包含两件事

00:31:18.190 --> 00:31:26.050
电影ID字符串问号等于

00:31:22.720 --> 00:31:28.390
为null，它将包含正确的日期

00:31:26.050 --> 00:31:30.130
现在我们可以使用名称，但是

00:31:28.390 --> 00:31:32.050
实际上是保留字，如果他

00:31:30.130 --> 00:31:33.520
如果找到一个变量就进入这个

00:31:32.050 --> 00:31:35.800
现在是保留字的名称

00:31:33.520 --> 00:31:37.930
常见的是向后打勾，但对于

00:31:35.800 --> 00:31:39.520
我们的目的就是让它保持最新

00:31:37.930 --> 00:31:41.800
因为我们不想进入

00:31:39.520 --> 00:31:45.160
我们正在做的事情

00:31:41.800 --> 00:31:46.960
编译器想要为我们做

00:31:45.160 --> 00:31:48.640
否则，我们将其称为

00:31:46.960 --> 00:31:50.500
电影ID，我们要给它

00:31:48.640 --> 00:31:52.090
太俊，他们都将是著名的

00:31:50.500 --> 00:31:54.070
默认为null好吧，这是我们的

00:31:52.090 --> 00:31:55.660
包装类型将描述两个

00:31:54.070 --> 00:31:57.250
洗什么电影以及何时洗

00:31:55.660 --> 00:31:59.530
正在被观看，所以我们现在不播放

00:31:57.250 --> 00:32:02.110
我们将要使用的一系列数据

00:31:59.530 --> 00:32:05.940
在这里回呼，期望会下沉， 

00:32:02.110 --> 00:32:05.940
接收器是异步的

00:32:06.290 --> 00:32:13.040
电影事件和中的Cronus Sink 

00:32:11.510 --> 00:32:14.980
我们要生成新的接收器

00:32:13.040 --> 00:32:18.830
值，所以我接下来要说一个点

00:32:14.980 --> 00:32:21.530
创建电影活动我是过去的事

00:32:18.830 --> 00:32:23.450
当然是电影ID和新日期

00:32:21.530 --> 00:32:24.380
现在会产生的是

00:32:23.450 --> 00:32:26.810
要创建一个发布商

00:32:24.380 --> 00:32:29.750
持续不断

00:32:26.810 --> 00:32:31.610
电影事件的顺序只要

00:32:29.750 --> 00:32:33.380
宇宙中有热量

00:32:31.610 --> 00:32:34.760
电影事件，这不完全是

00:32:33.380 --> 00:32:36.890
我们想要，因为我希望能够

00:32:34.760 --> 00:32:40.010
意思是我们你知道我们不会有

00:32:36.890 --> 00:32:41.750
每万亿用户观看电影

00:32:40.010 --> 00:32:44.960
我们将拥有的每一微秒

00:32:41.750 --> 00:32:47.900
数据流，假设我们

00:32:44.960 --> 00:32:49.700
有一个监视器使加载的服务和

00:32:47.900 --> 00:32:51.020
所以我们得到了一个新的流

00:32:49.700 --> 00:32:53.480
第二，因为我实际上没有全部

00:32:51.020 --> 00:32:54.920
这些用户登录系统后， 

00:32:53.480 --> 00:32:56.450
利用以下事实

00:32:54.920 --> 00:33:00.380
这个奇妙的幕后花絮

00:32:56.450 --> 00:33:02.210
反应堆API我们有一个调度程序

00:33:00.380 --> 00:33:04.550
对，所以我们实际上要告诉

00:33:02.210 --> 00:33:07.040
调度程序延迟元素

00:33:04.550 --> 00:33:08.630
由该出版商发行

00:33:07.040 --> 00:33:13.460
一定的秒数，好吧

00:33:08.630 --> 00:33:15.020
那些是我们的延迟出版商，我

00:33:13.460 --> 00:33:17.390
认为就是这样，我认为这会给我们

00:33:15.020 --> 00:33:19.010
我们非常简单的服务，我们可以

00:33:17.390 --> 00:33:22.250
用它来建立逮捕点

00:33:19.010 --> 00:33:23.900
所以去这里我们可以说想建立

00:33:22.250 --> 00:33:26.120
一个春季MVC风格的休息控制器

00:33:23.900 --> 00:33:27.680
这将是非常提交非常

00:33:26.120 --> 00:33:29.930
相似且非常熟悉的人

00:33:27.680 --> 00:33:32.240
谁曾经使用过Spring MVC，但这是

00:33:29.930 --> 00:33:34.520
让我们非常清楚不是Spring MVC这个

00:33:32.240 --> 00:33:37.100
实际上是一个新的

00:33:34.520 --> 00:33:41.240
称为弹簧腹板挠性弹簧腹板通量

00:33:37.100 --> 00:33:42.920
是一个全新的Web运行时

00:33:41.240 --> 00:33:44.870
类似的支持，它具有注释

00:33:42.920 --> 00:33:46.520
与Spring MVC相似，除了

00:33:44.870 --> 00:33:49.280
从头到脚都充分装备

00:33:46.520 --> 00:33:50.990
反应是支持反应

00:33:49.280 --> 00:33:53.110
处理，所以有些事情会发生

00:33:50.990 --> 00:33:55.460
非常不同，这不是

00:33:53.110 --> 00:33:59.540
基于或不需要，不需要

00:33:55.460 --> 00:34:00.980
 servlet API，它使用全新的网络

00:33:59.540 --> 00:34:05.510
运行时基于任何我们调用的

00:34:00.980 --> 00:34:08.179
现在建造，你可以运行弹簧

00:34:05.510 --> 00:34:10.669
通过servlet之上的webflix api 

00:34:08.179 --> 00:34:14.260
一个或更佳的环境

00:34:10.669 --> 00:34:14.260
就是那样哦

00:34:14.639 --> 00:34:17.849
在某些情况下，当然

00:34:16.679 --> 00:34:19.530
 Servlet API的某些部分

00:34:17.849 --> 00:34:20.550
本质上是阻塞的， 

00:34:19.530 --> 00:34:22.260
我们对此无能为力

00:34:20.550 --> 00:34:24.389
而你会在

00:34:22.260 --> 00:34:26.460
它，虽然它确实适用于

00:34:24.389 --> 00:34:28.560
在这种情况下的请求和响应

00:34:26.460 --> 00:34:30.810
 API的某些部分，一些角落API将会

00:34:28.560 --> 00:34:32.490
即使，即使

00:34:30.810 --> 00:34:34.109
我们的顶层是我们的抽象

00:34:32.490 --> 00:34:35.250
但这是一个不错的功能

00:34:34.109 --> 00:34:36.480
字符串好flex这是你得到

00:34:35.250 --> 00:34:38.669
您可以在其上运行的可移植性

00:34:36.480 --> 00:34:40.050
现在像WebSphere这样的东西我

00:34:38.669 --> 00:34:41.339
不一定建议您这样做

00:34:40.050 --> 00:34:43.889
那，当然，但是重点是你

00:34:41.339 --> 00:34:45.839
可以，如果您需要，但您会发现

00:34:43.889 --> 00:34:47.369
我们实际上使用的是

00:34:45.839 --> 00:34:49.530
有一个漩涡，但是走在任何地方

00:34:47.369 --> 00:34:51.179
这里的上下文被拆分为

00:34:49.530 --> 00:34:54.899
您默认情况下，让我们放置一个端点

00:34:51.179 --> 00:34:57.720
在这里，我们要通过ID和

00:34:54.899 --> 00:34:59.550
这是我要带的电影ID， 

00:34:57.720 --> 00:35:01.589
我们只是委托给服务

00:34:59.550 --> 00:35:03.380
在那里，当然有这个

00:35:01.589 --> 00:35:07.710
是我要映射的网络端点

00:35:03.380 --> 00:35:14.250
电影卷曲刹车ID，这变成

00:35:07.710 --> 00:35:15.810
好的路径变量，所以我们想

00:35:14.250 --> 00:35:17.190
在那有一个终点

00:35:15.810 --> 00:35:20.819
返回就是所有电影的权利

00:35:17.190 --> 00:35:23.099
有那么有趣，都等于MS全部

00:35:20.819 --> 00:35:25.260
好，我们希望再有一个

00:35:23.099 --> 00:35:28.140
返回数据的端点

00:35:25.260 --> 00:35:29.550
从比赛进行中返回

00:35:28.140 --> 00:35:33.510
来自活动服务，所以我们要

00:35:29.550 --> 00:35:35.930
说电影ID事件，现在看来

00:35:33.510 --> 00:35:37.859
我认为很简单

00:35:35.930 --> 00:35:40.500
这个有点问题

00:35:37.859 --> 00:35:41.880
代码不像我想象的那样存在

00:35:40.500 --> 00:35:43.440
这段代码想象我运行这段代码是什么

00:35:41.880 --> 00:35:45.060
会写这段代码，但在

00:35:43.440 --> 00:35:46.500
错，我们会得到你知道的JSON 

00:35:45.060 --> 00:35:48.690
客户要去的内容

00:35:46.500 --> 00:35:50.460
发送一个例外标头，指出

00:35:48.690 --> 00:35:52.020
我们想要一些应用程序JSON 

00:35:50.460 --> 00:35:54.839
各种服务将尽职尽责

00:35:52.020 --> 00:35:57.869
回应，它将把我们送回杰森，但

00:35:54.839 --> 00:35:59.609
当然在这里您知道客户不是

00:35:57.869 --> 00:36:02.700
为从未使用过的JSON文档做准备

00:35:59.609 --> 00:36:03.930
 sto脚，这个JSON结构是

00:36:02.700 --> 00:36:05.490
将永远继续下去， 

00:36:03.930 --> 00:36:07.260
因此，我们需要做的是

00:36:05.490 --> 00:36:09.660
向客户端发出信号，现在这是数据

00:36:07.260 --> 00:36:11.930
那将永远不会

00:36:09.660 --> 00:36:14.880
永远不要终止，如果它是一个客户

00:36:11.930 --> 00:36:16.230
知道的协议

00:36:14.880 --> 00:36:18.270
您知道的内容类型将正确处理

00:36:16.230 --> 00:36:20.130
东西，所以我们需要给它一个线索

00:36:18.270 --> 00:36:21.569
它会发生什么，我们会发生什么

00:36:20.130 --> 00:36:22.710
我们需要适合的东西吗

00:36:21.569 --> 00:36:24.359
为此，我们可以使用许多

00:36:22.710 --> 00:36:25.589
我们可以使用WebSockets的宝石

00:36:24.359 --> 00:36:27.330
 WebSockets当然是

00:36:25.589 --> 00:36:29.490
双向的

00:36:27.330 --> 00:36:30.990
协议允许下推日期

00:36:29.490 --> 00:36:32.820
下到客户，所以只要

00:36:30.990 --> 00:36:34.950
客户端打开了一个套接字，它将期望

00:36:32.820 --> 00:36:36.120
接收新数据，它将循环

00:36:34.950 --> 00:36:38.100
回到客户飞得很快

00:36:36.120 --> 00:36:41.040
可能，那当然很容易

00:36:38.100 --> 00:36:42.750
足以做一个春天的提示

00:36:41.040 --> 00:36:44.910
安装我刚刚录制的分钟录像

00:36:42.750 --> 00:36:47.070
几周前关于

00:36:44.910 --> 00:36:49.680
使用反应式WebSocket支持

00:36:47.070 --> 00:36:52.980
从五点开始，但出于我们的目的

00:36:49.680 --> 00:36:55.410
这很简单，只需发出信号

00:36:52.980 --> 00:36:57.180
我们将要产生的数据

00:36:55.410 --> 00:36:58.440
支持服务和事件，所以我

00:36:57.180 --> 00:37:02.010
我要做的是在这里说

00:36:58.440 --> 00:37:04.130
发回文本事件的媒体类型

00:37:02.010 --> 00:37:07.800
流值好，所以我们的

00:37:04.130 --> 00:37:09.360
其余端点，再加上一种

00:37:07.800 --> 00:37:11.100
支持服务器的端点已发送

00:37:09.360 --> 00:37:13.310
事件，让我们继续并重新启动

00:37:11.100 --> 00:37:13.310
服务

00:37:13.530 --> 00:37:21.380
现在在这里打开浏览器

00:37:18.470 --> 00:37:24.030
一件事是什么奇特的

00:37:21.380 --> 00:37:27.570
发生在这里是因为我是因为

00:37:24.030 --> 00:37:34.170
我正在记录这台计算机的爬网

00:37:27.570 --> 00:37:37.440
只是呆滞所以卷曲HTTP本地主机

00:37:34.170 --> 00:37:39.210
 8080前斜线电影好吗

00:37:37.440 --> 00:37:41.340
我们的记录正确，我们可以看到它们是

00:37:39.210 --> 00:37:42.869
现在所有的我们都可以寻找

00:37:41.340 --> 00:37:47.970
这里的特定记录让我们来抓

00:37:42.869 --> 00:37:51.320
这个ID副本卷曲让我们抓住那个

00:37:47.970 --> 00:37:51.320
那里我们可以

00:37:51.589 --> 00:37:57.910
那个唱片很棒

00:37:54.229 --> 00:37:57.910
似乎还可以，并且有

00:37:58.120 --> 00:38:02.010
让我们看看有什么问题

00:38:03.660 --> 00:38:05.720
您

00:38:07.010 --> 00:38:09.070
您

00:38:09.300 --> 00:38:14.790
 oops忘记指定路径变量

00:38:11.610 --> 00:38:16.970
对于事件端点，让我们尝试

00:38:14.790 --> 00:38:16.970
再次

00:38:19.910 --> 00:38:24.390
现在您看到的错误是

00:38:22.380 --> 00:38:26.670
参数指定为非null和

00:38:24.390 --> 00:38:29.060
当然它是作为null发送给我们的， 

00:38:26.670 --> 00:38:29.060
我当时

00:38:30.190 --> 00:38:34.450
语言本身的信号很好

00:38:33.549 --> 00:38:35.740
它应该不为空，所以我们

00:38:34.450 --> 00:38:39.630
有了NEX epsilon，所以我们

00:38:35.740 --> 00:38:45.369
电影，这是参数

00:38:39.630 --> 00:38:46.630
有事件，我们在那里

00:38:45.369 --> 00:38:48.609
我们将不同的数据发送回

00:38:46.630 --> 00:38:50.500
客户端现在正在使用消息

00:38:48.609 --> 00:38:53.230
可以看到每个新

00:38:50.500 --> 00:38:55.000
记录由数据冒号删除

00:38:53.230 --> 00:38:57.400
目的，然后再换一条新线

00:38:55.000 --> 00:39:00.490
行作为主题，所以我们现在有

00:38:57.400 --> 00:39:02.079
我们的终点现在肯定是一个

00:39:00.490 --> 00:39:04.000
编写端点的方法，如果

00:39:02.079 --> 00:39:05.799
您来自春季WebM，您会看到

00:39:04.000 --> 00:39:08.079
这会感觉很熟悉，但是在那里

00:39:05.799 --> 00:39:09.339
是我们可以在此处使用的新端点

00:39:08.079 --> 00:39:10.359
以及，所以我要建立一个新的

00:39:09.339 --> 00:39:12.309
使用功能性反应的端点

00:39:10.359 --> 00:39:14.950
我会说Spring Web Flex的支持

00:39:12.309 --> 00:39:19.059
网络配置，我们将

00:39:14.950 --> 00:39:21.390
我想在这里注入电影服务

00:39:19.059 --> 00:39:24.579
不需要酒吧里的文件

00:39:21.390 --> 00:39:27.099
好吧，我进入，所以这是一个

00:39:24.579 --> 00:39:28.930
配置类是春天，是春天

00:39:27.099 --> 00:39:30.309
会产生豆子的类

00:39:28.930 --> 00:39:33.180
 bean提供者，如果你愿意，我要去

00:39:30.309 --> 00:39:37.029
包括产生一个

00:39:33.180 --> 00:39:40.740
一组路线，所以在这里我们可以使用

00:39:37.029 --> 00:39:40.740
路由器功能

00:39:42.380 --> 00:39:48.800
从spring webflix输入

00:39:47.150 --> 00:39:52.690
我们可以做的所有事情并创造

00:39:48.800 --> 00:39:54.530
一个请求谓词，依此类推，但是

00:39:52.690 --> 00:39:55.940
我们真的不需要做所有这一切

00:39:54.530 --> 00:39:57.320
其实有一个你知道的

00:39:55.940 --> 00:39:58.700
最后的参数是一个处理程序

00:39:57.320 --> 00:40:01.610
功能，如果您提供的话，我有

00:39:58.700 --> 00:40:03.620
一个功能就足够了，但这

00:40:01.610 --> 00:40:06.200
是Java API，实际上

00:40:03.620 --> 00:40:07.400
春季框架中的Kotlin原生DSL 

00:40:06.200 --> 00:40:09.140
本身是正确的，所以它已经在

00:40:07.400 --> 00:40:12.920
类图，我们要做的就是使用

00:40:09.140 --> 00:40:15.620
这里是路由器DSL，所以我们说路由器和

00:40:12.920 --> 00:40:18.140
我们可以描述一些相互作用，所以

00:40:15.620 --> 00:40:20.750
第一个端点叫做电影，它是

00:40:18.140 --> 00:40:22.280
在这里期待和lambda 

00:40:20.750 --> 00:40:25.370
另一面，所以我们可以有lambda 

00:40:22.280 --> 00:40:27.500
然后我可以创建一个lambda 

00:40:25.370 --> 00:40:29.300
具有我可以确认的参数

00:40:27.500 --> 00:40:30.500
那但是我不需要那个参数所以

00:40:29.300 --> 00:40:32.060
没有意义，它将给予

00:40:30.500 --> 00:40:33.460
我仍然有一个隐式参数

00:40:32.060 --> 00:40:35.930
所以我要说的是

00:40:33.460 --> 00:40:38.090
当有人要所有的电影

00:40:35.930 --> 00:40:39.620
我将使用路由器服务

00:40:38.090 --> 00:40:42.170
对不起，我得到的电影服务

00:40:39.620 --> 00:40:46.220
在那里我要说服务器响应

00:40:42.170 --> 00:40:48.500
没关系，点体等于全部MS点

00:40:46.220 --> 00:40:50.540
我必须在这里指定

00:40:48.500 --> 00:40:51.770
第二个参数的数据类型

00:40:50.540 --> 00:40:55.280
我们正在发回客户，所以

00:40:51.770 --> 00:40:57.050
经典的Java是我们的一个处理程序

00:40:55.280 --> 00:40:58.460
对，我们可以复制

00:40:57.050 --> 00:41:03.950
其他三个端点，让我们来看一下

00:40:58.460 --> 00:41:09.260
电影ID，在这里我们要说给

00:41:03.950 --> 00:41:11.210
给我一个ID记录，我可以说

00:41:09.260 --> 00:41:12.830
得到路径变量在哪里

00:41:11.210 --> 00:41:15.800
当然是这种情况

00:41:12.830 --> 00:41:17.210
请求，在这里我想看电影

00:41:15.800 --> 00:41:19.480
事件，我将其更改为电影

00:41:17.210 --> 00:41:19.480
事件

00:41:19.589 --> 00:41:28.279
这将是事件，我们会说

00:41:23.999 --> 00:41:28.279
现在得到的路径变量等于想法

00:41:28.400 --> 00:41:34.609
我们有一个第二个参数是

00:41:31.460 --> 00:41:36.410
告诉合适的Web运行时什么类型

00:41:34.609 --> 00:41:37.130
我们要发回的数据，因此请考虑

00:41:36.410 --> 00:41:39.770
这里发生了什么事

00:41:37.130 --> 00:41:42.920
我们正在发回数据

00:41:39.770 --> 00:41:45.349
可能是您非常了解

00:41:42.920 --> 00:41:47.599
在最后的情况下，它永远不会结束

00:41:45.349 --> 00:41:48.950
前两个可能是数十亿

00:41:47.599 --> 00:41:50.930
的电影不是没有帐单

00:41:48.950 --> 00:41:53.539
我猜现在有十亿部电影

00:41:50.930 --> 00:41:55.220
但这可能是我的观点

00:41:53.539 --> 00:41:57.410
运行时不知道，所以需要

00:41:55.220 --> 00:41:59.299
知道何时将消息框起来

00:41:57.410 --> 00:42:02.720
然后将其发送回客户端

00:41:59.299 --> 00:42:04.789
对，所以它需要吃掉很多

00:42:02.720 --> 00:42:07.819
计数并发出尽可能多的值

00:42:04.789 --> 00:42:08.960
不管机会如何

00:42:07.819 --> 00:42:10.760
我们需要做的就是给它

00:42:08.960 --> 00:42:13.730
关于何时正确执行操作的线索，所以我

00:42:10.760 --> 00:42:15.529
忘了给那个内容类型，所以我们

00:42:13.730 --> 00:42:17.359
需要提供有关何时执行的线索

00:42:15.529 --> 00:42:19.250
我们告诉它做到这一点

00:42:17.359 --> 00:42:21.079
找到记录的时间

00:42:19.250 --> 00:42:23.270
被视为电影或电影事件

00:42:21.079 --> 00:42:24.770
实验室情况下的最后一个终点

00:42:23.270 --> 00:42:26.450
在那里，我们正在明确地这样做

00:42:24.770 --> 00:42:28.369
在这里，因为它没有办法

00:42:26.450 --> 00:42:31.039
从回应中

00:42:28.369 --> 00:42:33.799
从服务发送来的值

00:42:31.039 --> 00:42:36.440
正确的MS完成的事件MS点按ID 

00:42:33.799 --> 00:42:40.369
等不知道，因为在运行时

00:42:36.440 --> 00:42:43.910
您知道在JDK中的JVM遗传

00:42:40.369 --> 00:42:45.319
规划师迷路了，所以我们需要

00:42:43.910 --> 00:42:48.410
明确的权利，所以我们

00:42:45.319 --> 00:42:50.390
告诉它这是类型的发布商

00:42:48.410 --> 00:42:54.049
电影，因此您可以发送的每部电影

00:42:50.390 --> 00:42:59.170
返回数据，现在让我们返回

00:42:54.049 --> 00:43:04.470
到我们的控制台，我可以说curl HTTP 

00:42:59.170 --> 00:43:06.330
本地主机8080正斜杠电影好

00:43:04.470 --> 00:43:09.300
您

00:43:06.330 --> 00:43:11.610
然后粘贴，然后我们去

00:43:09.300 --> 00:43:12.900
我们那里有10点相同

00:43:11.610 --> 00:43:14.670
我们使用

00:43:12.900 --> 00:43:16.140
现在功能反应性端点

00:43:14.670 --> 00:43:18.060
你应该很好地使用它的一个互联网

00:43:16.140 --> 00:43:19.550
对你我想很多人

00:43:18.060 --> 00:43:21.510
喜欢这种风格，如果您曾经使用过

00:43:19.550 --> 00:43:22.980
 Sinatra担任Ruby on Rails角色或

00:43:21.510 --> 00:43:25.080
苏格兰威士忌或火花

00:43:22.980 --> 00:43:27.360
如果您对此更熟悉

00:43:25.080 --> 00:43:28.500
您来自春季MVC，这可能

00:43:27.360 --> 00:43:29.970
对你更熟悉

00:43:28.500 --> 00:43:31.920
无论您喜欢哪种风格，我们都不是

00:43:29.970 --> 00:43:35.400
知道我们对此没有强烈的意见

00:43:31.920 --> 00:43:36.510
似乎是一件非常有用的事情

00:43:35.400 --> 00:43:38.160
有这种反应

00:43:36.510 --> 00:43:39.690
功能性反应世界还不错，所以我们

00:43:38.160 --> 00:43:40.110
现在有一个Web应用程序正在与

00:43:39.690 --> 00:43:41.280
互联网

00:43:40.110 --> 00:43:43.980
我们有数据，我们正在与数据对话

00:43:41.280 --> 00:43:45.750
直到今天结束

00:43:43.980 --> 00:43:47.460
我认为只是一个玩具，因为我们

00:43:45.750 --> 00:43:48.750
有点忽略了一些非常真实的

00:43:47.460 --> 00:43:50.670
人们必须关心的问题

00:43:48.750 --> 00:43:52.380
当他们转向这种方法时， 

00:43:50.670 --> 00:43:54.270
我们搬到这里时关心的事情

00:43:52.380 --> 00:43:56.360
当我们移动一个

00:43:54.270 --> 00:43:57.840
应用于生产是

00:43:56.360 --> 00:43:58.950
可观察性我想

00:43:57.840 --> 00:44:00.570
了解应用程序在做什么

00:43:58.950 --> 00:44:03.350
我想能够提供信息

00:44:00.570 --> 00:44:05.550
关于应用程序，以便我可以

00:44:03.350 --> 00:44:09.150
监视它，我可以一次检查它

00:44:05.550 --> 00:44:12.090
所以我在这种情况下忽略了

00:44:09.150 --> 00:44:14.010
从 spring boot 带进图书馆

00:44:12.090 --> 00:44:15.270
称为弹簧启动启动器执行器

00:44:14.010 --> 00:44:17.730
所以我带一个执行器

00:44:15.270 --> 00:44:19.230
执行器不是新事物

00:44:17.730 --> 00:44:22.500
没有什么没有什么新的或者

00:44:19.230 --> 00:44:25.170
特定于反应性支持物，除了

00:44:22.500 --> 00:44:28.220
它以前是用术语写的

00:44:25.170 --> 00:44:28.220
春季MVC的

00:44:28.910 --> 00:44:35.540
 Web运行时正确，这样

00:44:32.420 --> 00:44:37.070
现在支持Spring Web 

00:44:35.540 --> 00:44:38.900
通量，实际上它也可用于

00:44:37.070 --> 00:44:40.790
 jax-rs，所以您会看到它是一个

00:44:38.900 --> 00:44:44.420
执行器端的一个不错的功能

00:44:40.790 --> 00:44:45.950
点已与

00:44:44.420 --> 00:44:47.150
 Web运行时在这里发挥作用

00:44:45.950 --> 00:44:49.520
游戏可能是春季亩C 

00:44:47.150 --> 00:44:51.200
弹簧一弯曲或它可能是jax-rs 

00:44:49.520 --> 00:44:52.580
好吧，我们的弹簧启动器

00:44:51.200 --> 00:44:54.170
我们将通过以下方式激活它

00:44:52.580 --> 00:44:55.700
使用此属性端点禁用

00:44:54.170 --> 00:44:57.590
或我们拥有的重要性默认值

00:44:55.700 --> 00:44:59.690
能够实现，我们可以运行

00:44:57.590 --> 00:45:01.070
代码在这里，但在我这样做之前，我也想

00:44:59.690 --> 00:45:02.050
解决安全问题，这是另一个

00:45:01.070 --> 00:45:04.160
我们必须关心的问题

00:45:02.050 --> 00:45:06.320
生产环境，所以我要去

00:45:04.160 --> 00:45:09.220
回到我的建筑，我将带来

00:45:06.320 --> 00:45:14.560
具有安全性的Spring Boot Starter 

00:45:09.220 --> 00:45:14.560
反应性好，所以有这个

00:45:15.069 --> 00:45:19.660
而且我们不会做太多的事情

00:45:18.219 --> 00:45:21.069
使这项工作可以做各种事情

00:45:19.660 --> 00:45:23.140
你知道春天的安全

00:45:21.069 --> 00:45:26.170
心认证的概念

00:45:23.140 --> 00:45:28.630
经理，然后在另一边

00:45:26.170 --> 00:45:31.089
它有一个授权管理器

00:45:28.630 --> 00:45:33.729
基本上是这样的

00:45:31.089 --> 00:45:37.359
两个接口处理身份验证和

00:45:33.729 --> 00:45:41.190
如果我们成立，分别授权

00:45:37.359 --> 00:45:44.829
如果我们设置类型的对象，则为默认值

00:45:41.190 --> 00:45:46.329
用户详细信息存储库Spring Security 

00:45:44.829 --> 00:45:48.539
我们假设我们想和

00:45:46.329 --> 00:45:51.130
基于任何数据访问层

00:45:48.539 --> 00:45:53.019
我们给它的存储库对象

00:45:51.130 --> 00:45:54.729
回答有关用户的问题

00:45:53.019 --> 00:45:56.739
进入并向其中提出要求

00:45:54.729 --> 00:45:58.660
系统，它将自动锁定

00:45:56.739 --> 00:46:00.400
一切都使用HTTP基本，所以

00:45:58.660 --> 00:46:01.839
授权将自动完成

00:46:00.400 --> 00:46:03.849
如果是，您知道它是否已通过身份验证

00:46:01.839 --> 00:46:05.920
它经历了否则，不是

00:46:03.849 --> 00:46:07.449
基本可以配置为H 

00:46:05.920 --> 00:46:09.430
更详细地说，但由于我们

00:46:07.449 --> 00:46:12.089
时间短，我会留给你

00:46:09.430 --> 00:46:14.890
想像力，让我们做一些基本的

00:46:12.089 --> 00:46:16.989
基本的弹簧安全在这里基本的弹簧

00:46:14.890 --> 00:46:20.559
安全五，我们要说的很好

00:46:16.989 --> 00:46:21.940
我们要启用Web Flex安全性

00:46:20.559 --> 00:46:25.599
要创建光束端点

00:46:21.940 --> 00:46:28.479
是描述我们的定义

00:46:25.599 --> 00:46:30.099
用户，我们将再次使用您

00:46:28.479 --> 00:46:32.589
知道用户详细信息存储库

00:46:30.099 --> 00:46:35.079
春季安全五是的抽象

00:46:32.589 --> 00:46:36.789
在这里寻找，这是Maps more 

00:46:35.079 --> 00:46:38.680
或更少的用户详细信息服务

00:46:36.789 --> 00:46:39.999
同步中的经典Spring Security 

00:46:38.680 --> 00:46:42.130
阻止春季安全，所以我们已经

00:46:39.999 --> 00:46:44.140
重做了反应堆中的很多东西

00:46:42.130 --> 00:46:45.339
春季安全支持，使其能够

00:46:44.140 --> 00:46:46.329
在这个世界上工作是因为思考

00:46:45.339 --> 00:46:47.949
它，但这就是你想要的

00:46:46.329 --> 00:46:51.339
要做的就是让所有这些美丽的反应

00:46:47.949 --> 00:46:53.890
代码只能在a处死锁

00:46:51.339 --> 00:46:55.719
线程本地权限阻塞同步

00:46:53.890 --> 00:46:56.979
本地线程当然使

00:46:55.719 --> 00:46:58.599
在反应堆世界上几乎没有意义

00:46:56.979 --> 00:47:01.569
所以我们要说用户名是

00:46:58.599 --> 00:47:03.819
我们的绞车当然是唯一的

00:47:01.569 --> 00:47:06.369
 Rob Winch需要弹簧保护

00:47:03.819 --> 00:47:11.529
我们要给他一个角色

00:47:06.369 --> 00:47:14.049
管理员和用户当然会更好

00:47:11.529 --> 00:47:17.440
现在我也可以在这里建立另一个用户

00:47:14.049 --> 00:47:20.319
他的名字J和点密码

00:47:17.440 --> 00:47:22.810
等于角色等于用户的PW 

00:47:20.319 --> 00:47:24.100
还有什么

00:47:22.810 --> 00:47:26.170
那一个还好吧

00:47:24.100 --> 00:47:28.690
我们有两个硬编码用户

00:47:26.170 --> 00:47:31.150
用户详细信息存储库合同

00:47:28.690 --> 00:47:33.310
很简单，就是你知道

00:47:31.150 --> 00:47:35.400
用户名返回了类型的发布者

00:47:33.310 --> 00:47:38.320
正确的用户详细信息，所以我们有

00:47:35.400 --> 00:47:40.000
简单的用户详细信息存储库

00:47:38.320 --> 00:47:41.920
我们将在春季安全保护期回来

00:47:40.000 --> 00:47:43.000
已激活，将用于锁定

00:47:41.920 --> 00:47:45.540
系统，让我们继续运行

00:47:43.000 --> 00:47:45.540
再次输入此代码

00:47:56.540 --> 00:48:06.200
现在我们可以在任何时候

00:48:03.010 --> 00:48:10.130
配置另一个返回

00:48:06.200 --> 00:48:11.780
惠普安全过滤器的基本原理

00:48:10.130 --> 00:48:13.820
将使我们能够进行配置

00:48:11.780 --> 00:48:15.950
授权，但出于我们的目的， 

00:48:13.820 --> 00:48:20.090
可以按我说的那样保留它

00:48:15.950 --> 00:48:25.760
贝壳很好，我们会说

00:48:20.090 --> 00:48:27.800
 curl HTTP本地主机8080四个斜杠

00:48:25.760 --> 00:48:31.400
电影现在我要去做

00:48:27.800 --> 00:48:33.170
我要去这里开始

00:48:31.400 --> 00:48:35.570
说我想看到两个结果

00:48:33.170 --> 00:48:36.830
好的，所以你去那里说401 

00:48:35.570 --> 00:48:37.970
未经授权的权利，我们需要

00:48:36.830 --> 00:48:40.190
验证那是公平的

00:48:37.970 --> 00:48:43.130
所以从头开始，我们要

00:48:40.190 --> 00:48:46.210
指定-您的用户名和

00:48:43.130 --> 00:48:49.490
 curl命令的密码和

00:48:46.210 --> 00:48:51.860
用户将为J long，密码为

00:48:49.490 --> 00:48:54.140
将是PW，如果存在，我们就在那

00:48:51.860 --> 00:48:55.610
然后将其发送给Jason PP，我们

00:48:54.140 --> 00:48:57.260
可以看到谁正确地获得了JSON数据

00:48:55.610 --> 00:48:59.030
所以没有错误也没有

00:48:57.260 --> 00:48:59.960
所以现在可以工作

00:48:59.030 --> 00:49:01.670
我们刚刚添加的内容

00:48:59.960 --> 00:49:03.890
现在是那些执行器端点

00:49:01.670 --> 00:49:04.940
说执行器有一个很共同的目标

00:49:03.890 --> 00:49:06.380
你看哪一个都没关系

00:49:04.940 --> 00:49:07.520
组织你是什么都没关系

00:49:06.380 --> 00:49:08.900
您使用的技术堆栈没有

00:49:07.520 --> 00:49:10.190
无论您身在何处， 

00:49:08.900 --> 00:49:11.330
您属于哪个行业

00:49:10.190 --> 00:49:13.250
事情似乎很惊讶， 

00:49:11.330 --> 00:49:14.600
传呼机关闭时保持一致

00:49:13.250 --> 00:49:16.070
有人被计算机唤醒

00:49:14.600 --> 00:49:17.930
必须弄清楚他们的情况

00:49:16.070 --> 00:49:20.810
工作不失根源分析

00:49:17.930 --> 00:49:22.670
他们的工作是分类

00:49:20.810 --> 00:49:24.590
发生并阻止出血，所以

00:49:22.670 --> 00:49:26.720
我们在衰落中能做的一切

00:49:24.590 --> 00:49:28.880
秒和早晨的死帮助

00:49:26.720 --> 00:49:30.620
那个过程很有价值，先生

00:49:28.880 --> 00:49:32.630
执行器达到了目标

00:49:30.620 --> 00:49:34.310
表面有关的信息

00:49:32.630 --> 00:49:35.660
应用程序，虽然你会好起来

00:49:34.310 --> 00:49:37.730
还有很多其他的

00:49:35.660 --> 00:49:39.350
您可以了解的资源

00:49:37.730 --> 00:49:41.060
您的应用程序没有比这更好的了

00:49:39.350 --> 00:49:44.060
比您的应用程序本身要

00:49:41.060 --> 00:49:47.390
阐明该状态，以便在这里您可以

00:49:44.060 --> 00:49:49.040
看到我们有一个执行器，您知道

00:49:47.390 --> 00:49:52.160
健康检查，让我们写出来

00:49:49.040 --> 00:49:54.320
 JSON以及运行状况检查

00:49:52.160 --> 00:49:56.480
我，我与电视的连接告诉我

00:49:54.320 --> 00:49:57.950
关于我的文件系统连接及其相关信息

00:49:56.480 --> 00:49:59.300
它告诉我这些事情已经发生， 

00:49:57.950 --> 00:50:00.860
如果他们没有起来，当然

00:49:59.300 --> 00:50:02.450
我的应用程式本身的状态或

00:50:00.860 --> 00:50:04.250
陷入困境，我们会看到这一点

00:50:02.450 --> 00:50:05.870
这里会说地位等于我

00:50:04.250 --> 00:50:07.610
不会花太长时间在执行器上

00:50:05.870 --> 00:50:08.660
点，但惊讶地说有一个

00:50:07.610 --> 00:50:10.160
他们的总数，他们都工作

00:50:08.660 --> 00:50:12.859
现在在反应良好的世界中

00:50:10.160 --> 00:50:15.289
好的，所以我们有一个安全的反应

00:50:12.859 --> 00:50:17.119
具有Web的可观察应用程序

00:50:15.289 --> 00:50:19.069
 API我们研究了两种编写方法

00:50:17.119 --> 00:50:20.119
 API，它正在与数据层和

00:50:19.069 --> 00:50:21.559
我们还看了反应堆，但这

00:50:20.119 --> 00:50:23.559
没有一个服务就不会有太多服务

00:50:21.559 --> 00:50:29.630
客户，让我们回到IntelliJ和

00:50:23.559 --> 00:50:33.140
让我们建立一个新的客户端模块

00:50:29.630 --> 00:50:38.200
接下来要创建一个新项目

00:50:33.140 --> 00:50:40.670
我们将使用的这个flux flix客户端

00:50:38.200 --> 00:50:42.920
这次使用Java 

00:50:40.670 --> 00:50:44.450
不这样做的原因你们俩​​都不知道吗

00:50:42.920 --> 00:50:47.720
是好的语言，那么两者都会

00:50:44.450 --> 00:50:49.339
当然工作正常，所以接下来点击

00:50:47.720 --> 00:50:51.369
我们只是要使用反应式网络

00:50:49.339 --> 00:50:54.369
对，所以我们在这里

00:50:51.369 --> 00:50:54.369
哎呀

00:50:55.109 --> 00:51:01.040
用于反应性网

00:50:58.560 --> 00:51:10.850
接下来

00:51:01.040 --> 00:51:11.780
完成新窗口好，所以第一个

00:51:10.850 --> 00:51:13.340
我们当然需要做的事情

00:51:11.780 --> 00:51:15.320
将其移动到单独的端口，所以我们

00:51:13.340 --> 00:51:17.390
要说送达端口等于80 81 

00:51:15.320 --> 00:51:19.490
我将使用Flex修复客户端

00:51:17.390 --> 00:51:23.150
应用Java，这就是我们

00:51:19.490 --> 00:51:25.220
要做的就是创建一个客户，这样

00:51:23.150 --> 00:51:28.010
我们将创建一个网络客户端以进行交谈

00:51:25.220 --> 00:51:29.690
服务，我们可以使用

00:51:28.010 --> 00:51:31.780
弹簧框架平等休息模板写

00:51:29.690 --> 00:51:34.010
其余模板肯定是

00:51:31.780 --> 00:51:35.570
有趣的选择，但是问题

00:51:34.010 --> 00:51:37.160
是其余的是同步的

00:51:35.570 --> 00:51:38.570
是的，它阻止了，不是

00:51:37.160 --> 00:51:39.590
特别适合无限

00:51:38.570 --> 00:51:41.570
大量的数据，这将是一个非常

00:51:39.590 --> 00:51:44.000
我们很难打电话来管理

00:51:41.570 --> 00:51:46.550
你的前两个武器要点

00:51:44.000 --> 00:51:47.840
知道没有太多麻烦

00:51:46.550 --> 00:51:50.450
没有太多的数据，但我们有

00:51:47.840 --> 00:51:51.950
我们打电话给我们时会遇到麻烦

00:51:50.450 --> 00:51:54.260
最后一项是的服务和活动

00:51:51.950 --> 00:51:55.730
终结点，所以让我们创建一个耶

00:51:54.260 --> 00:51:57.530
使用引入的新的Web客户端

00:51:55.730 --> 00:51:59.870
春季网络点击，我将创建一个网络

00:51:57.530 --> 00:52:02.840
客户，我会知道所有前缀

00:51:59.870 --> 00:52:04.970
拨打了80 84部斜线电影， 

00:52:02.840 --> 00:52:07.700
我们想要变异它我们想要变异

00:52:04.970 --> 00:52:10.310
因为我们要配置一个过滤器

00:52:07.700 --> 00:52:16.100
对，所以我要说交换

00:52:10.310 --> 00:52:18.160
过滤功能，但是

00:52:16.100 --> 00:52:18.160
您

00:52:18.920 --> 00:52:21.490
好

00:52:22.500 --> 00:52:34.500
过滤网

00:52:43.640 --> 00:52:45.700
您

00:52:46.310 --> 00:52:59.690
我做了点事

00:52:50.140 --> 00:53:09.080
让我们在这里看到Lux上的猫桌面面具

00:52:59.690 --> 00:53:09.829
勒克斯客户端源主要专栏我只是

00:53:09.080 --> 00:53:11.630
写下这段代码

00:53:09.829 --> 00:53:13.009
或者我知道那个交换过滤器

00:53:11.630 --> 00:53:14.239
具有基本身份验证功能

00:53:13.009 --> 00:53:26.450
应该是我们所需要的

00:53:14.239 --> 00:53:30.349
让我们看看好啊，我们去了

00:53:26.450 --> 00:53:32.779
我应该先创建好吧

00:53:30.349 --> 00:53:33.890
摆脱那里，我们现在我们在

00:53:32.779 --> 00:53:37.249
做饭，所以我们正在做的是

00:53:33.890 --> 00:53:38.989
说我们要创建一个新的网站

00:53:37.249 --> 00:53:41.029
客户我们将为所有客户做序

00:53:38.989 --> 00:53:43.519
对本地主机8080电影的请求

00:53:41.029 --> 00:53:45.650
并赢得了

00:53:43.519 --> 00:53:47.509
 Geelong和PW的基本身份验证

00:53:45.650 --> 00:53:49.670
现在我们要在这里使用该客户端

00:53:47.509 --> 00:53:51.650
我们要说的应用程序赛跑者

00:53:49.670 --> 00:53:53.420
我要去的应用程序赛跑者

00:53:51.650 --> 00:53:55.549
将Web客户端作为参数注入

00:53:53.420 --> 00:53:57.739
在这里，所以我们要做的是

00:53:55.549 --> 00:53:59.779
我们要说网络客户点git dot 

00:53:57.739 --> 00:54:01.099
你我等于，当然有

00:53:59.779 --> 00:54:03.170
没有什么是正确的，我们只是要

00:54:01.099 --> 00:54:04.549
打电话给我们所有的记录

00:54:03.170 --> 00:54:07.729
检索我们将要翻转的数据

00:54:04.549 --> 00:54:11.150
变成一部电影，所以我要说

00:54:07.729 --> 00:54:13.339
私人电影课，当然在这里

00:54:11.150 --> 00:54:15.410
对我们有利，对我们有益

00:54:13.339 --> 00:54:16.910
龙目岛对，所以我应该补充一点

00:54:15.410 --> 00:54:19.160
上课的道路幸好我们已经

00:54:16.910 --> 00:54:20.420
卖了龙目岛插件，所以我

00:54:19.160 --> 00:54:25.390
需要做的是将其添加到类中

00:54:20.420 --> 00:54:25.390
路径，我可以说添加数据

00:54:25.420 --> 00:54:32.110
我会说说私人字符串ID 

00:54:28.710 --> 00:54:34.240
私有字符串标题，这将

00:54:32.110 --> 00:54:36.880
创建一个全参数构造函数和一个

00:54:34.240 --> 00:54:38.530
没有参数构造函数，所以

00:54:36.880 --> 00:54:40.480
这是我们的基本类型，我们也

00:54:38.530 --> 00:54:43.300
想要一种类型来描述电影事件

00:54:40.480 --> 00:54:46.030
对，所以我要说我们有电影活动

00:54:43.300 --> 00:54:49.630
这将是一个它将有一个字符串

00:54:46.030 --> 00:54:52.020
称为电影ID，日期称为

00:54:49.630 --> 00:54:52.020
日期

00:54:54.350 --> 00:54:59.040
我们在那里，这是我们的基本

00:54:57.080 --> 00:55:00.600
该服务方面的结构

00:54:59.040 --> 00:55:02.490
实施，我们只是

00:55:00.600 --> 00:55:04.380
在此处创建详细信息和客户

00:55:02.490 --> 00:55:06.750
这样我们就可以

00:55:04.380 --> 00:55:08.460
工作，我要说我想要身体

00:55:06.750 --> 00:55:11.070
所有要求返回电影的请求

00:55:08.460 --> 00:55:13.140
类，我们将在过滤器中

00:55:11.070 --> 00:55:17.400
我想说的电影给我标题

00:55:13.140 --> 00:55:20.270
如果标题包含以下内容之一

00:55:17.400 --> 00:55:20.270
看电影

00:55:20.840 --> 00:55:26.480
我们可以说我想要那个然后我们想要

00:55:24.290 --> 00:55:29.780
一张平面图，结果是一个

00:55:26.480 --> 00:55:34.160
把它变成另一个呼叫

00:55:29.780 --> 00:55:38.240
点事件，因此ID事件

00:55:34.160 --> 00:55:41.660
当然传入ID本身

00:55:38.240 --> 00:55:44.150
电影，然后我们想把它

00:55:41.660 --> 00:55:46.070
变成一个要求，然后我们变成一个

00:55:44.150 --> 00:55:49.510
助焊剂的主体，所以键入电影事件

00:55:46.070 --> 00:55:49.510
类和

00:55:51.400 --> 00:55:58.410
让我们看看这是怎么回事

00:55:55.150 --> 00:56:14.369
我们要卖的是今年

00:55:58.410 --> 00:56:17.289
你我的身体乱搞我变成一个args 

00:56:14.369 --> 00:56:19.269
好吧，最后当然我们

00:56:17.289 --> 00:56:21.789
想订阅，所以当我说致电

00:56:19.269 --> 00:56:23.109
每次使用system.out.print行方法

00:56:21.789 --> 00:56:25.710
有一条新记录被退回

00:56:23.109 --> 00:56:36.940
从那开始，让我们现在运行这段代码

00:56:25.710 --> 00:56:38.319
现在，当这运行时，我们应该

00:56:36.940 --> 00:56:39.730
希望看到它正在发出请求

00:56:38.319 --> 00:56:40.720
并验证它应该是基本的

00:56:39.730 --> 00:56:43.059
认证请求

00:56:40.720 --> 00:56:44.680
 localhost：8080电影端点，然后

00:56:43.059 --> 00:56:45.759
它会得到数据找到

00:56:44.680 --> 00:56:47.980
感兴趣的特定记录

00:56:45.759 --> 00:56:49.359
然后播放电影事件

00:56:47.980 --> 00:56:51.069
因为我们将它们放在服务器端

00:56:49.359 --> 00:56:53.529
在那里我们和我的朋友们在一起

00:56:51.069 --> 00:56:54.789
我们只有几秒钟，也许是六秒钟

00:56:53.529 --> 00:56:56.739
秒，所以我们位于顶部

00:56:54.789 --> 00:56:58.119
一个小时，我们看了反应堆河

00:56:56.739 --> 00:56:59.970
春季韦伯助焊剂，我们已经看过

00:56:58.119 --> 00:57:02.230
我们研究的功能反应性端点

00:56:59.970 --> 00:57:03.549
这些春季NEC风格的终结点

00:57:02.230 --> 00:57:05.650
看了我们看过的 spring data 

00:57:03.549 --> 00:57:07.089
春季安全我们看了

00:57:05.650 --> 00:57:08.559
执行器支持，我们研究了如何

00:57:07.089 --> 00:57:10.239
建立一个网络客户端

00:57:08.559 --> 00:57:12.460
还有完全集成的测试

00:57:10.239 --> 00:57:15.489
支持，让我重申一下

00:57:12.460 --> 00:57:17.619
仅仅是发布的开始

00:57:15.489 --> 00:57:19.599
春季框架已经设定了五个

00:57:17.619 --> 00:57:22.509
一系列新发行的多米诺骨牌

00:57:19.599 --> 00:57:24.339
全部整合他们的官方

00:57:22.509 --> 00:57:25.869
 Spring Framework五种支持，因此我们已经

00:57:24.339 --> 00:57:28.480
一直在为此工作

00:57:25.869 --> 00:57:30.519
对于大多数人来说，工作超过一年

00:57:28.480 --> 00:57:31.539
这些项目，所以我们你知道

00:57:30.519 --> 00:57:33.039
你会看到很多新版本

00:57:31.539 --> 00:57:34.839
在和几周内

00:57:33.039 --> 00:57:37.180
未来数月，当然还有春天的心情

00:57:34.839 --> 00:57:39.220
到dyno将反过来使我们能够

00:57:37.180 --> 00:57:41.410
发行Spring Cloud的新版​​本

00:57:39.220 --> 00:57:43.450
春季云Finchley和

00:57:41.410 --> 00:57:45.549
我们想到的第一季度2018 

00:57:43.450 --> 00:57:47.440
春云有一项新技术叫做

00:57:45.549 --> 00:57:49.239
 spring弹簧卡网关

00:57:47.440 --> 00:57:51.190
建立在这里的反应性支持上

00:57:49.239 --> 00:57:52.390
我们现在可以做很多很棒的事情

00:57:51.190 --> 00:57:54.670
我们有一个Java 8， 

00:57:52.390 --> 00:57:56.259
现在，lambda是一个友好的基准

00:57:54.670 --> 00:57:57.640
在春季获得反应性支持

00:57:56.259 --> 00:58:00.759
将Spring Framework打破5 

00:57:57.640 --> 00:58:03.220
基金会，我们希望您能

00:58:00.759 --> 00:58:05.140
利用它，我要谢谢你

00:58:03.220 --> 00:58:07.690
这么多的时间

00:58:05.140 --> 00:58:09.069
并回答问题，你知道不

00:58:07.690 --> 00:58:11.440
毫不犹豫地与我联系

00:58:09.069 --> 00:58:14.079
 Twitter领先星巴克，如果有的话

00:58:11.440 --> 00:58:16.779
问题评论或反馈

00:58:14.079 --> 00:58:18.089
安德里亚，我想把它还给我

00:58:16.779 --> 00:58:20.920
朋友

00:58:18.089 --> 00:58:24.069
谢谢你，乔治如此出色

00:58:20.920 --> 00:58:27.099
令人印象深刻，我什至没想到你会

00:58:24.069 --> 00:58:31.029
赶上他们，所以我很高兴

00:58:27.099 --> 00:58:35.319
我们有几个问题请

00:58:31.029 --> 00:58:39.519
太好了，所以首先很多

00:58:35.319 --> 00:58:43.180
问题是什么使反应性

00:58:39.519 --> 00:58:44.349
安全反应性是的，所以这是一个

00:58:43.180 --> 00:58:46.960
被动安全问题

00:58:44.349 --> 00:58:48.220
我们有接触传播的东西

00:58:46.960 --> 00:58:51.069
改变背景的方式

00:58:48.220 --> 00:58:53.349
传播，所以这是主要部分

00:58:51.069 --> 00:58:54.519
返工，然后基本上

00:58:53.349 --> 00:58:56.529
我们重新设计了一些核心

00:58:54.519 --> 00:58:58.960
现在可以使用的界面

00:58:56.529 --> 00:59:02.400
出版商，所以我们可以在哪里

00:58:58.960 --> 00:59:04.359
向作者出示认证

00:59:02.400 --> 00:59:06.819
经理，基本上我们生产

00:59:04.359 --> 00:59:09.339
异步地我们产生像

00:59:06.819 --> 00:59:11.170
用户详细信息存储库为

00:59:09.339 --> 00:59:13.599
发布者这些东西是这些价值观

00:59:11.170 --> 00:59:15.849
是我们不需要的价值观

00:59:13.599 --> 00:59:17.470
我们第一次初始化时的需求

00:59:15.849 --> 00:59:19.059
不必一定要偶

00:59:17.470 --> 00:59:20.589
直到以后处理

00:59:19.059 --> 00:59:22.210
流水线，所以我们推迟到最后一刻

00:59:20.589 --> 00:59:24.250
当此信息可用时

00:59:22.210 --> 00:59:26.769
所以有很多不同的事情

00:59:24.250 --> 00:59:28.569
那里我并不是想了解所有

00:59:26.769 --> 00:59:30.910
我知道那里发生的一切

00:59:28.569 --> 00:59:33.549
有很多工作要做

00:59:30.910 --> 00:59:35.289
完成一些默认设置

00:59:33.549 --> 00:59:37.930
阻碍假设，当然

00:59:35.289 --> 00:59:42.009
这适用于字符串web flex世界

00:59:37.930 --> 00:59:43.420
我们将弹簧安全性重新设计为

00:59:42.009 --> 00:59:46.869
与新的过滤器模型一起工作

00:59:43.420 --> 00:59:48.279
与处理生命周期

00:59:46.869 --> 00:59:51.099
春天一号继续运行，因为记住

00:59:48.279 --> 00:59:53.619
这不是基于servlet的应用程序

00:59:51.099 --> 00:59:54.970
而许多现有的

00:59:53.619 --> 00:59:56.849
您刚刚工作过的基本内容

00:59:54.970 --> 00:59:59.170
并在之前非常安全

00:59:56.849 --> 01:00:04.150
你不会知道的

00:59:59.170 --> 01:00:06.220
下一步需要服务器API 

01:00:04.150 --> 01:00:09.519
问题我们可以用削减鼓励

01:00:06.220 --> 01:00:13.210
避免避免意大利面代码，所以在您之前

01:00:09.519 --> 01:00:14.829
命令有第三方

01:00:13.210 --> 01:00:18.660
春季拥抱项目

01:00:14.829 --> 01:00:25.059
协程生物笔记Kaminsky 

01:00:18.660 --> 01:00:27.069
用于Allegro和很好，但用于

01:00:25.059 --> 01:00:30.999
官方评论是的，我认为是

01:00:27.069 --> 01:00:33.039
最好问乔希好吧，所以我们没有

01:00:30.999 --> 01:00:34.869
现在有什么，但我想我看到了

01:00:33.039 --> 01:00:37.900
关于的讨论隆隆

01:00:34.869 --> 01:00:41.049
在反应堆本身中支持

01:00:37.900 --> 01:00:42.670
对，这样作为研究的东西

01:00:41.049 --> 01:00:45.160
那肯定是我见过你的东西

01:00:42.670 --> 01:00:46.749
谈到最近还没有

01:00:45.160 --> 01:00:51.819
但也许第三方可能

01:00:46.749 --> 01:00:54.369
有趣的是，我不知道很酷

01:00:51.819 --> 01:00:55.749
关于IDE支持的评论

01:00:54.369 --> 01:00:59.079
额外的插件

01:00:55.749 --> 01:01:01.869
乔希用我找不到 spring 5 

01:00:59.079 --> 01:01:04.749
首先，春天这么好支持5 

01:01:01.869 --> 01:01:08.470
在最新版本中支持以色列，并

01:01:04.749 --> 01:01:13.890
当然还有新的

01:01:08.470 --> 01:01:17.829
是一个预览，但由于乔希是苏格兰

01:01:13.890 --> 01:01:20.650
好吧，这个主意取决于

01:01:17.829 --> 01:01:23.019
支持编码以及spring和

01:01:20.650 --> 01:01:25.539
这已经部分可用

01:01:23.019 --> 01:01:29.650
 Latsis最新版本，但更多

01:01:25.539 --> 01:01:31.269
进入第三点

01:01:29.650 --> 01:01:35.339
一个月后发布

01:01:31.269 --> 01:01:37.210
是的，我不必使用我爱的

01:01:35.339 --> 01:01:39.339
智能伟大的工具，但让我们成为

01:01:37.210 --> 01:01:41.170
坦率地说，这只是基本

01:01:39.339 --> 01:01:43.480
 Java，您知道public static void 

01:01:41.170 --> 01:01:44.950
主要，我几乎什么也没用

01:01:43.480 --> 01:01:46.779
 Lombok插件int很棒

01:01:44.950 --> 01:01:49.269
 Java代码的插件

01:01:46.779 --> 01:01:52.650
卡特兰方面我印象深刻

01:01:49.269 --> 01:01:55.749
支持IntelliJ中内置的Cartland 

01:01:52.650 --> 01:01:56.890
虽然你知道我给我给

01:01:55.749 --> 01:01:59.140
乡亲们下雨了很多功劳

01:01:56.890 --> 01:02:05.380
还构建了一个非常不错的kauffman插件

01:01:59.140 --> 01:02:08.890
对于Eclipse来说不是很正确，所以

01:02:05.380 --> 01:02:11.489
这很多，它只是工作而已

01:02:08.890 --> 01:02:11.489
工作完美

01:02:11.890 --> 01:02:16.960
下一个关于春天云的问题

01:02:14.349 --> 01:02:21.130
 Spring数据云做得很好

01:02:16.960 --> 01:02:24.009
因此为他们或那些额定弹簧

01:02:21.130 --> 01:02:26.170
不同的概念，所以春天的云是

01:02:24.009 --> 01:02:29.289
重新设计以支持任何地方

01:02:26.170 --> 01:02:30.400
可能是我们所做的反应性工作

01:02:29.289 --> 01:02:32.349
刚刚展示了最后一个小时，所以

01:02:30.400 --> 01:02:35.079
弹簧卡将支持我们

01:02:32.349 --> 01:02:37.210
确实有一些支持，例如

01:02:35.079 --> 01:02:40.150
你已经可以返回我们的工作了吗

01:02:37.210 --> 01:02:41.589
例如可以观察到的

01:02:40.150 --> 01:02:44.380
那是我们的外部，我认为我不是

01:02:41.589 --> 01:02:46.210
确保指标是Java-有初步的

01:02:44.380 --> 01:02:48.460
初步的支持可以看一下

01:02:46.210 --> 01:02:50.140
列出春季云Finchley的票据

01:02:48.460 --> 01:02:52.390
智利的春季俱乐部并不普遍

01:02:50.140 --> 01:02:55.059
可用性，但它会和我一样

01:02:52.390 --> 01:02:56.140
说明年第一季度，我们甚至

01:02:55.059 --> 01:02:57.759
有一个叫做

01:02:56.140 --> 01:03:00.190
作为门户的春季云游戏

01:02:57.759 --> 01:03:03.279
看起来很实用的技术

01:03:00.190 --> 01:03:05.890
与Zul网关相同或

01:03:03.279 --> 01:03:08.380
来自Netflix的微代理，但它是内置的

01:03:05.890 --> 01:03:10.720
使用弹簧网从头开始

01:03:08.380 --> 01:03:13.569
 flex运行时，所以它是反应性的

01:03:10.720 --> 01:03:15.039
将提供弹簧中心和弹簧

01:03:13.569 --> 01:03:17.140
友好的组件和处理模型

01:03:15.039 --> 01:03:18.700
所以有很多值得佩服的地方

01:03:17.140 --> 01:03:20.890
那，我建议你采取一个

01:03:18.700 --> 01:03:22.569
看看那个，是的，它确实支持

01:03:20.890 --> 01:03:24.869
反应式支持确实支持我

01:03:22.569 --> 01:03:26.710
主动编程，并尽可能

01:03:24.869 --> 01:03:30.880
那是其中很大一部分

01:03:26.710 --> 01:03:32.920
使 spring boot 纳米工作很酷

01:03:30.880 --> 01:03:34.779
我可以使用稍微相关的问题

01:03:32.920 --> 01:03:38.049
弹簧云的反应弹簧和

01:03:34.779 --> 01:03:41.609
动物园要建立一个API网关吗

01:03:38.049 --> 01:03:44.529
推荐所有可以使用的东西，所以祖尔

01:03:41.609 --> 01:03:48.670
现在，这样一个永远不会

01:03:44.529 --> 01:03:52.989
具有反应式API的过滤器模型是

01:03:48.670 --> 01:03:55.930
没有反应性，所以我认为我认为

01:03:52.989 --> 01:03:57.849
也要努力一点

01:03:55.930 --> 01:04:00.729
我知道那还不够

01:03:57.849 --> 01:04:03.609
可能是我不知道我不知道

01:04:00.729 --> 01:04:08.099
如果他愿意那样做，但是我知道你

01:04:03.609 --> 01:04:08.099
无论如何都可以做到这一点

01:04:08.190 --> 01:04:12.069
好的

01:04:09.880 --> 01:04:16.299
另外，如果我想使用数据库

01:04:12.069 --> 01:04:19.329
没有结冰的驱动程序

01:04:16.299 --> 01:04:21.819
我可以使用

01:04:19.329 --> 01:04:24.130
封锁并在

01:04:21.819 --> 01:04:27.700
数据库真的是精华河

01:04:24.130 --> 01:04:29.739
是的，我的意思是你可以和你一起工作

01:04:27.700 --> 01:04:30.670
任何您想要的，但取决于您

01:04:29.739 --> 01:04:33.430
现在管理

01:04:30.670 --> 01:04:36.039
将工作移出处理

01:04:33.430 --> 01:04:37.359
循环，到目前为止，我有点

01:04:36.039 --> 01:04:38.469
查看默认值，但值得

01:04:37.359 --> 01:04:39.849
了解它实际上有一个

01:04:38.469 --> 01:04:41.619
安排我，所以我们曾经谈论过

01:04:39.849 --> 01:04:42.789
所以这里有一个调度程序

01:04:41.619 --> 01:04:45.940
在幕后，这是其中之一

01:04:42.789 --> 01:04:48.190
可以的旋钮和杠杆

01:04:45.940 --> 01:04:50.710
设法改变事物，所以在这里

01:04:48.190 --> 01:04:57.270
是出版商，然后我看到它了

01:04:50.710 --> 01:04:57.270
就是所有这些都安排好了

01:04:57.990 --> 01:05:06.190
订阅订阅

01:05:03.490 --> 01:05:07.780
哦，看到那个订阅一个

01:05:06.190 --> 01:05:10.270
表示订阅的方法，我可以

01:05:07.780 --> 01:05:13.660
传递调度程序可以执行的调度程序

01:05:10.270 --> 01:05:15.370
您是否知道调度程序会散布这些

01:05:13.660 --> 01:05:16.780
我可以打印这些都是线程

01:05:15.370 --> 01:05:20.530
池基本上是执行者之类的东西

01:05:16.780 --> 01:05:23.470
您可以用来管理

01:05:20.530 --> 01:05:24.700
该管道的这种并发性

01:05:23.470 --> 01:05:27.390
这个定义在这个管道上

01:05:24.700 --> 01:05:31.030
对的，所以您可以更好地控制

01:05:27.390 --> 01:05:32.680
调度程序如何跨工作

01:05:31.030 --> 01:05:33.910
不同的线程等等，这就是

01:05:32.680 --> 01:05:35.620
这样做的好处是，因为

01:05:33.910 --> 01:05:37.150
我们正在编写这个API我们正在使用这个

01:05:35.620 --> 01:05:38.290
代码，对不起，它看起来很声明性

01:05:37.150 --> 01:05:40.270
非常重要，我们要说的是删除

01:05:38.290 --> 01:05:42.700
然后做这个然后做那个然后做这个

01:05:40.270 --> 01:05:44.620
但是没有你知道这不是

01:05:42.700 --> 01:05:46.290
必须是连续的，你知道有

01:05:44.620 --> 01:05:48.130
对此没有任何暗示

01:05:46.290 --> 01:05:50.140
好，除了这些是

01:05:48.130 --> 01:05:51.570
然后，但是你可以建立

01:05:50.140 --> 01:05:54.970
做各种各样的管道

01:05:51.570 --> 01:05:56.950
处理您知道的工作可以

01:05:54.970 --> 01:06:04.090
如果您愿意，可以并行完成

01:05:56.950 --> 01:06:06.880
它是必需的还是必要的，好的

01:06:04.090 --> 01:06:10.450
问题我们如何在线退出弹簧是

01:06:06.880 --> 01:06:13.780
符合Johanna的春季反应

01:06:10.450 --> 01:06:15.940
现在我们Java那个Spring框架

01:06:13.780 --> 01:06:18.610
 Java的五部作品九篇

01:06:15.940 --> 01:06:21.610
 Spring Framework中的功能

01:06:18.610 --> 01:06:23.380
 Java的五个是九个模块

01:06:21.610 --> 01:06:25.150
拼图对，所以没有

01:06:23.380 --> 01:06:27.010
没有关于反应性的具体说明

01:06:25.150 --> 01:06:31.030
我们需要知道的支持

01:06:27.010 --> 01:06:33.280
关于Java，我春天

01:06:31.030 --> 01:06:35.260
五个作品就很好了

01:06:33.280 --> 01:06:38.110
在模块路径和类路径上

01:06:35.260 --> 01:06:40.060
在双子座那是其中之一

01:06:38.110 --> 01:06:42.970
主要功能我们也让您知道

01:06:40.060 --> 01:06:45.220
那里和那里几乎没有更新

01:06:42.970 --> 01:06:46.630
在JDK中为您提供一些小项目

01:06:45.220 --> 01:06:48.460
我们已经看到更新了

01:06:46.630 --> 01:06:50.170
反映在春天四五

01:06:48.460 --> 01:06:52.780
您将看到的主要内容是

01:06:50.170 --> 01:06:54.730
我们现在不支持模块系统

01:06:52.780 --> 01:06:58.920
要求您介意，但我们会支持

01:06:54.730 --> 01:06:58.920
你想要它很酷

01:06:59.109 --> 01:07:04.880
嗯，关于IntelliJ的问题

01:07:01.760 --> 01:07:07.280
 IDEA是否支持生成测试

01:07:04.880 --> 01:07:11.510
 Kotlin的方法，就像我的工作一样

01:07:07.280 --> 01:07:14.270
相信我相信它做得很好，但是

01:07:11.510 --> 01:07:16.490
是的，我必须确认是否在

01:07:14.270 --> 01:07:17.390
情况不好的话我什么都没有

01:07:16.490 --> 01:07:22.780
不要以为

01:07:17.390 --> 01:07:24.500
我只是不能让我与众不同

01:07:22.780 --> 01:07:27.140
服务在那里，我有这个新

01:07:24.500 --> 01:07:28.730
创建测试方法窗口对话框的东西

01:07:27.140 --> 01:07:32.180
它说我可以创建这些

01:07:28.730 --> 01:07:32.390
方法，我可以确定那里还可以

01:07:32.180 --> 01:07:41.089
我们去

01:07:32.390 --> 01:07:43.970
那很酷，是的，它有一个

01:07:41.089 --> 01:07:47.060
好吧，我们有一些问题

01:07:43.970 --> 01:07:49.910
可以跟进电子邮件，所以我

01:07:47.060 --> 01:07:52.520
寻找更多的兴趣一次

01:07:49.910 --> 01:07:55.670
向仍在工作的人们暗示

01:07:52.520 --> 01:07:59.359
与我的续集，也许不确定我们是否

01:07:55.670 --> 01:08:02.480
有点进来，我是的

01:07:59.359 --> 01:08:05.660
这是很好，我的意思是如果你不

01:08:02.480 --> 01:08:06.740
必须使用支持的反应，但是如果您

01:08:05.660 --> 01:08:10.310
有一个用例，您在做很多事情

01:08:06.740 --> 01:08:11.540
 I / O绑定交互，然后

01:08:10.310 --> 01:08:13.460
反应堆支持可能对

01:08:11.540 --> 01:08:14.570
你说如果你正在使用的东西

01:08:13.460 --> 01:08:16.130
那是续集的驱动程序，那是

01:08:14.570 --> 01:08:17.299
从根本上阻止，你还好

01:08:16.130 --> 01:08:20.239
这样也很好

01:08:17.299 --> 01:08:22.310
我们不试图不强迫

01:08:20.239 --> 01:08:25.130
人们将人们强行转移到一个

01:08:22.310 --> 01:08:26.270
一个进口或另一个有一段时间

01:08:25.130 --> 01:08:28.160
在这些不同的地方

01:08:26.270 --> 01:08:30.560
我说没有技术

01:08:28.160 --> 01:08:34.930
现在支持JDBC和JPA 

01:08:30.560 --> 01:08:36.920
反应堆世界，但正如我们作为甲骨文一样

01:08:34.930 --> 01:08:40.130
宣布本周他们有工作

01:08:36.920 --> 01:08:42.620
反应性JDBC驱动程序正在进行中，因此

01:08:40.130 --> 01:08:45.799
希望你假装

01:08:42.620 --> 01:08:49.420
未来会有更好的情况

01:08:45.799 --> 01:08:51.290
 JDBC访问需要三个月的时间

01:08:49.420 --> 01:08:55.190
是的

01:08:51.290 --> 01:08:56.690
也许是最后一个问题，因为

01:08:55.190 --> 01:08:59.299
我们现在没时间了

01:08:56.690 --> 01:09:02.839
你在比较什么

01:08:59.299 --> 01:09:05.299
和卡夫卡在一起，那春天的雷克斯怎么样

01:09:02.839 --> 01:09:09.520
祈祷并与之相交或相交

01:09:05.299 --> 01:09:11.230
与卡夫卡，这是这些都不是

01:09:09.520 --> 01:09:13.510
你知道卡夫卡是一个消息队列

01:09:11.230 --> 01:09:15.730
我们有一个名为spring的项目

01:09:13.510 --> 01:09:17.230
 apache'Kafka，得到了很好的支持

01:09:15.730 --> 01:09:20.710
在春季前Patrick Kafka级别

01:09:17.230 --> 01:09:22.720
以及在你所知道的

01:09:20.710 --> 01:09:23.920
通过春季整合

01:09:22.720 --> 01:09:26.440
整合，所以我要入站

01:09:23.920 --> 01:09:27.400
出站适配器，然后我们

01:09:26.440 --> 01:09:29.920
当然我们有春季云流

01:09:27.400 --> 01:09:32.319
帕特里克·卡夫卡的粘合剂

01:09:29.920 --> 01:09:34.810
卡夫卡是一个神话，它是一个消息队列

01:09:32.319 --> 01:09:36.370
消息代理，而反应式

01:09:34.810 --> 01:09:39.279
我在这里展示的支持只是

01:09:36.370 --> 01:09:42.549
一种在内部组成管道的方式

01:09:39.279 --> 01:09:44.799
您的单个过程中，您可能会猜到

01:09:42.549 --> 01:09:47.230
流向其他节点的流程

01:09:44.799 --> 01:09:48.779
是通过使用某些东西来使用注册

01:09:47.230 --> 01:09:51.880
那样，但是什么都没有

01:09:48.779 --> 01:09:53.650
他们不一定

01:09:51.880 --> 01:09:57.790
他们不一定连接或

01:09:53.650 --> 01:10:00.160
相交得到了，所以我认为这就是全部

01:09:57.790 --> 01:10:03.010
时间我们今天有问题，我们

01:10:00.160 --> 01:10:04.420
应该包好，谢谢乔治

01:10:03.010 --> 01:10:07.780
你的时间

01:10:04.420 --> 01:10:09.070
是的，真的很感激，谢谢

01:10:07.780 --> 01:10:10.540
对我来说非常非常

01:10:09.070 --> 01:10:13.120
非常有趣，我想再次

01:10:10.540 --> 01:10:15.220
鼓励人们在乔希伸出援手

01:10:13.120 --> 01:10:18.040
和Josh Lancome或星巴克

01:10:15.220 --> 01:10:19.480
 Manistee RBX一个男人，如果你有更多

01:10:18.040 --> 01:10:23.050
问题评论或反馈谢谢

01:10:19.480 --> 01:10:25.060
太棒了，谢谢，谢谢

01:10:23.050 --> 01:10:27.780
每个加入我们的人都过得愉快

01:10:25.060 --> 01:10:27.780
还有，注意安全

