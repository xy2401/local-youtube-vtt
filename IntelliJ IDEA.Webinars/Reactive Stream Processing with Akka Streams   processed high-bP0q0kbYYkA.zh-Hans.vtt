WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.080 --> 00:00:10.670
好的，是我的骇客介绍的

00:00:08.750 --> 00:00:13.490
类型安全，这意味着我在

00:00:10.670 --> 00:00:16.099
神秘兰花，我也参加过

00:00:13.490 --> 00:00:19.070
反应性流我们称之为

00:00:16.099 --> 00:00:21.800
运动或委员会

00:00:19.070 --> 00:00:25.220
制定规范并进行测试

00:00:21.800 --> 00:00:27.980
用于中断不同流的套件

00:00:25.220 --> 00:00:29.660
除此之外的实现

00:00:27.980 --> 00:00:32.629
一堆其他开源的东西，例如

00:00:29.660 --> 00:00:36.949
 aj MH性能基准测试插件

00:00:32.629 --> 00:00:39.080
现在sbd是的，另一个是

00:00:36.949 --> 00:00:41.750
一堆社区的东西和

00:00:39.080 --> 00:00:43.699
我可能已经听过罗恩的会议

00:00:41.750 --> 00:00:45.530
见过他们，但这不是很

00:00:43.699 --> 00:00:50.269
今天很重要今天让我们专注于

00:00:45.530 --> 00:00:52.839
代码，因此今天的计划是第一个

00:00:50.269 --> 00:00:55.309
如果有梦想，实际上会引入水

00:00:52.839 --> 00:00:58.010
也许不是每个人都熟悉

00:00:55.309 --> 00:01:00.260
与他们，所以我们将谈论

00:00:58.010 --> 00:01:02.170
概念和规格

00:01:00.260 --> 00:01:04.280
实际上意味着，为什么我们需要它，以及

00:01:02.170 --> 00:01:08.050
然后一点点它实际上是如何工作的

00:01:04.280 --> 00:01:11.180
所以它在幕后的真正运作方式

00:01:08.050 --> 00:01:13.280
范跳进来发生流是

00:01:11.180 --> 00:01:16.030
此的实现之一

00:01:13.280 --> 00:01:19.430
规范，但实际上提供了

00:01:16.030 --> 00:01:22.040
您可以真正使用的有用的API 

00:01:19.430 --> 00:01:24.800
新事物，因为直肌梦想着API 

00:01:22.040 --> 00:01:26.630
是一个非常非常非常低的水平，你

00:01:24.800 --> 00:01:29.210
不会为您做很多事情

00:01:26.630 --> 00:01:30.890
现在就限制vcp冰吧

00:01:29.210 --> 00:01:33.890
会有很多概念

00:01:30.890 --> 00:01:35.870
的ARCA流的一些示例以及何时

00:01:33.890 --> 00:01:38.510
我准备了很多代码， 

00:01:35.870 --> 00:01:42.140
我可以，所以我们可以跳入一些

00:01:38.510 --> 00:01:44.930
最终入侵，是的，我之前说过

00:01:42.140 --> 00:01:46.790
所有问题和答案将其键入

00:01:44.930 --> 00:01:50.210
问题窗格，然后我们去

00:01:46.790 --> 00:01:52.790
首先是一些问题

00:01:50.210 --> 00:01:56.659
杰出的，我很乐意跟进

00:01:52.790 --> 00:02:00.920
电子邮件，所以我们将看看情况如何

00:01:56.659 --> 00:02:02.840
是一个流，所以一般来说这是第一个

00:02:00.920 --> 00:02:05.540
您无法输入的好定义

00:02:02.840 --> 00:02:08.149
同一条河两次让我们打招呼

00:02:05.540 --> 00:02:10.519
 Cletus那么古希腊么

00:02:08.149 --> 00:02:15.470
实际上非常合适，所以一般

00:02:10.519 --> 00:02:17.570
想法是嗯，但是如果您使用流

00:02:15.470 --> 00:02:20.420
如果您两次看相同的视频， 

00:02:17.570 --> 00:02:22.580
可能会获得正确的数据，因为

00:02:20.420 --> 00:02:26.150
就是这种流动的数据流， 

00:02:22.580 --> 00:02:28.630
你只是在观察其中的一部分

00:02:26.150 --> 00:02:31.130
当然取决于流的类型

00:02:28.630 --> 00:02:34.340
因为可能有一些流

00:02:31.130 --> 00:02:37.220
有收藏权的支持，如果您

00:02:34.340 --> 00:02:39.230
观察您收藏中的信息流

00:02:37.220 --> 00:02:41.300
可能总是正确地获得相同的元素

00:02:39.230 --> 00:02:43.820
因为流总是总是

00:02:41.300 --> 00:02:46.370
从一开始就实现

00:02:43.820 --> 00:02:48.170
集合的最后一个元素，但是你

00:02:46.370 --> 00:02:50.780
如果您阅读不总是能做到这一点

00:02:48.170 --> 00:02:54.770
从插座，例如，或者我不

00:02:50.780 --> 00:02:56.540
知道观看直播视频流，您

00:02:54.770 --> 00:02:58.640
不要缓冲您可能无法使用的内容

00:02:56.540 --> 00:03:01.070
去时间的开始看

00:02:58.640 --> 00:03:04.490
大部分时间都是直播

00:03:01.070 --> 00:03:07.340
时间，让我们谈谈反应式

00:03:04.490 --> 00:03:10.010
溪流反应堆当然是一个好词

00:03:07.340 --> 00:03:12.860
最近遍及媒体和互联网

00:03:10.010 --> 00:03:14.540
但是当我们说时我们实际上是什么意思

00:03:12.860 --> 00:03:16.550
工作直播，因为这是一个非常

00:03:14.540 --> 00:03:19.100
至少在

00:03:16.550 --> 00:03:21.920
我们当然是这样的规格

00:03:19.100 --> 00:03:24.380
谈论流处理

00:03:21.920 --> 00:03:27.050
元素数量将超过

00:03:24.380 --> 00:03:31.820
一堆转换步骤以及何时

00:03:27.050 --> 00:03:33.769
您得到最终结果，但是现在关键

00:03:31.820 --> 00:03:37.250
功能来了，所以必须回来

00:03:33.769 --> 00:03:40.760
受背压的压力

00:03:37.250 --> 00:03:45.019
例如，如果您正在处理或

00:03:40.760 --> 00:03:48.019
生成大量数据

00:03:45.019 --> 00:03:50.890
有人必须非常数一个

00:03:48.019 --> 00:03:53.930
数据之上的复杂算法

00:03:50.890 --> 00:03:56.269
也许是您数据的使用者

00:03:53.930 --> 00:03:57.920
容易生产不能保持

00:03:56.269 --> 00:04:00.980
处理这个复杂的问题

00:03:57.920 --> 00:04:04.280
算法，这就是背压的地方

00:04:00.980 --> 00:04:06.170
进来的是一个订户

00:04:04.280 --> 00:04:09.080
该数据的接收者能够发出信号

00:04:06.170 --> 00:04:11.959
给发布者，所以他的生成者

00:04:09.080 --> 00:04:14.900
数据，但跟不上我们可以做的

00:04:11.959 --> 00:04:17.720
关于它的不同的东西，它必须

00:04:14.900 --> 00:04:19.760
成为同步井，并没有真正

00:04:17.720 --> 00:04:21.530
必须因为规范是

00:04:19.760 --> 00:04:24.260
足够宽以允许同步

00:04:21.530 --> 00:04:26.300
执行，但实际上是针对

00:04:24.260 --> 00:04:28.430
同步甚至可能

00:04:26.300 --> 00:04:29.930
分布是因为

00:04:28.430 --> 00:04:35.300
可以通过

00:04:29.930 --> 00:04:37.430
网络和处理是这样的

00:04:35.300 --> 00:04:40.340
意味着例如在汽车中我们有他的

00:04:37.430 --> 00:04:41.900
永远不会阻止的著名和咒语

00:04:40.340 --> 00:04:43.430
这当然与

00:04:41.900 --> 00:04:46.430
反应性流，因为您从不

00:04:43.430 --> 00:04:48.979
真的要封锁我不知道

00:04:46.430 --> 00:04:52.220
一些核心，因为有人将您

00:04:48.979 --> 00:04:54.470
有自己的时间去处理，并坚持

00:04:52.220 --> 00:04:56.900
你可能会被迫退缩

00:04:54.470 --> 00:04:59.090
停止生产东西，但这不是

00:04:56.900 --> 00:05:02.509
就像被某些人封锁一样

00:04:59.090 --> 00:05:04.310
阻塞io核心，然后是关键

00:05:02.509 --> 00:05:06.919
这东西的特点

00:05:04.310 --> 00:05:09.860
按照我们的意思标准化

00:05:06.919 --> 00:05:13.639
具有多种实现方式和

00:05:09.860 --> 00:05:15.110
每个人都使用相同的协议

00:05:13.639 --> 00:05:16.910
这是在

00:05:15.110 --> 00:05:21.259
同步流处理

00:05:16.910 --> 00:05:22.699
标准，如果你想阅读

00:05:21.259 --> 00:05:24.530
标准与技术

00:05:22.699 --> 00:05:26.509
我实现的兼容性套件

00:05:24.530 --> 00:05:29.150
最担心的活动流网页

00:05:26.509 --> 00:05:32.630
反之亦然，所有背后的背景

00:05:29.150 --> 00:05:34.400
因此，请继续进行检查，但是谁

00:05:32.630 --> 00:05:37.159
实际上现在正在运行此

00:05:34.400 --> 00:05:39.110
首先，我们键入安全，但其他类型

00:05:37.159 --> 00:05:41.810
支持它的公司

00:05:39.110 --> 00:05:44.090
 Netflix，带有4rx库并显示

00:05:41.810 --> 00:05:47.150
您的照片和其他公司，例如

00:05:44.090 --> 00:05:48.530
关键和红猫与他们

00:05:47.150 --> 00:05:53.479
相同的实现

00:05:48.530 --> 00:05:56.780
规格，现在到关键

00:05:53.479 --> 00:05:59.180
该规范为我们提供了什么

00:05:56.780 --> 00:06:01.099
例如，如果您有此管道， 

00:05:59.180 --> 00:06:04.370
竖立不同的元素流

00:06:01.099 --> 00:06:06.169
 X是我们的汽车还是反应堆，这要归功于

00:06:04.370 --> 00:06:09.139
每个人都遵循相同的协议

00:06:06.169 --> 00:06:12.530
您无需任何费用就能连接费用

00:06:09.139 --> 00:06:14.419
辛苦的世界让我们说吧

00:06:12.530 --> 00:06:16.159
这样，因为我们都遵守

00:06:14.419 --> 00:06:19.520
他们能够背压的协议

00:06:16.159 --> 00:06:21.620
从头到尾，所以在此图示例中

00:06:19.520 --> 00:06:24.020
反应堆纸背压

00:06:21.620 --> 00:06:27.860
生态系统生态系统对流瑞克

00:06:24.020 --> 00:06:31.159
 RX + RX可以反压一些反应性

00:06:27.860 --> 00:06:36.380
流发布，所以这真的

00:06:31.159 --> 00:06:38.389
巨大的一件事要注意的是

00:06:36.380 --> 00:06:41.790
我要销毁API的描述很多

00:06:38.389 --> 00:06:43.610
现在可能不是最容易实现的

00:06:41.790 --> 00:06:45.600
实际上，那不是真的

00:06:43.610 --> 00:06:48.480
每个人都实现自己的

00:06:45.600 --> 00:06:53.700
反应流越来越多，我是爸爸

00:06:48.480 --> 00:06:55.860
如果是数据库驱动程序，或者我不知道

00:06:53.700 --> 00:06:59.700
视频处理库能够

00:06:55.860 --> 00:07:02.850
暴露大多数用户会这样的界面

00:06:59.700 --> 00:07:04.470
只是使用乡亲，所以这个互操作

00:07:02.850 --> 00:07:06.990
但是大多数时候你不会

00:07:04.470 --> 00:07:08.430
实施这些，直接你

00:07:06.990 --> 00:07:12.900
可能使用的酒精与

00:07:08.430 --> 00:07:15.030
我们的曼联在这里反应无缝

00:07:12.900 --> 00:07:19.260
我有个例子

00:07:15.030 --> 00:07:20.880
在一起，所以每一行你都可以在这里看到

00:07:19.260 --> 00:07:23.940
实际上是不同的反应流

00:07:20.880 --> 00:07:26.460
实现全部嵌入红色

00:07:23.940 --> 00:07:29.160
向后Web服务器，以便您可以看到我们

00:07:26.460 --> 00:07:33.390
从可观察到的RX开始，然后我们开始

00:07:29.160 --> 00:07:35.790
在反应流中变成水酱

00:07:33.390 --> 00:07:38.370
哪个映射在这堆数字中

00:07:35.790 --> 00:07:40.470
到一个字符串，当我们转到

00:07:38.370 --> 00:07:42.300
反应器做不同的事情和

00:07:40.470 --> 00:07:44.070
他们都在一起工作

00:07:42.300 --> 00:07:47.070
一起生产将有助于

00:07:44.070 --> 00:07:51.240
结果，从本质上讲，我们试图

00:07:47.070 --> 00:07:53.730
反击登录，因为我的意思是如果你

00:07:51.240 --> 00:07:56.340
无法将一个API连接到另一个API 

00:07:53.730 --> 00:07:59.010
这种形式的锁定动作直立

00:07:56.340 --> 00:08:03.440
极端的API，我们能够打开

00:07:59.010 --> 00:08:06.570
并使用每个人的最佳功能

00:08:03.440 --> 00:08:08.910
让我们大致概述一下

00:08:06.570 --> 00:08:13.020
其实是，但是这又是什么

00:08:08.910 --> 00:08:14.880
压力的东西，就像我说的，我们有一个

00:08:13.020 --> 00:08:17.340
我们有一个出版商的情况

00:08:14.880 --> 00:08:20.010
订户，他们互相交谈

00:08:17.340 --> 00:08:22.260
当然，这就是我们要做的事情之一

00:08:20.010 --> 00:08:25.260
要注意的事情很严格

00:08:22.260 --> 00:08:28.500
在此发布者中输入

00:08:25.260 --> 00:08:31.680
可以很好地生产T型物品

00:08:28.500 --> 00:08:33.060
产生T型靴子的亚型并获得

00:08:31.680 --> 00:08:35.479
与我们不同的想法

00:08:33.060 --> 00:08:39.090
当前未键入的校正器

00:08:35.479 --> 00:08:41.010
但我们正在改变，但也如此

00:08:39.090 --> 00:08:43.979
斋戒时出现问题

00:08:41.010 --> 00:08:47.520
这样就在此流订阅者上发布

00:08:43.979 --> 00:08:48.570
两者都有一定的处理速度

00:08:47.520 --> 00:08:50.730
这种情况下，当你第一次

00:08:48.570 --> 00:08:52.110
发布者，它将淹没船只

00:08:50.730 --> 00:08:56.050
划线员

00:08:52.110 --> 00:08:58.750
所以在我需要的时候，让我们

00:08:56.050 --> 00:09:01.380
看典型的例子

00:08:58.750 --> 00:09:03.760
发布商尝试稍后发送

00:09:01.380 --> 00:09:05.710
当然会以一种或另一种方式

00:09:03.760 --> 00:09:10.030
成为接收方的一些缓冲空间

00:09:05.710 --> 00:09:12.370
即使只是元素列表也要结束

00:09:10.030 --> 00:09:15.040
只是某种缓冲，甚至

00:09:12.370 --> 00:09:19.600
那里的其他系统上的TCP缓冲区

00:09:15.040 --> 00:09:22.270
总是某种缓冲，而我们

00:09:19.600 --> 00:09:24.430
填写脚缓冲器，这样会发生什么

00:09:22.270 --> 00:09:26.560
接下来的订户不是真的能够

00:09:24.430 --> 00:09:29.230
以相同的速度处理

00:09:26.560 --> 00:09:30.910
被提供数据，那将如何

00:09:29.230 --> 00:09:34.930
发生的是我们将要溢出

00:09:30.910 --> 00:09:38.040
缓冲，所以我们该怎么办

00:09:34.930 --> 00:09:41.560
大部分时间缓冲区溢出

00:09:38.040 --> 00:09:43.960
您将删除邮件，因为

00:09:41.560 --> 00:09:46.510
您没有任何空间可容纳

00:09:43.960 --> 00:09:49.000
消息，然后发布者会

00:09:46.510 --> 00:09:52.360
必须重新发送或只留下

00:09:49.000 --> 00:09:55.020
事实上，您丢失了数据，但让我们

00:09:52.360 --> 00:09:57.400
说我们很讨厌，这似乎有点

00:09:55.020 --> 00:09:59.530
仅删除数据并

00:09:57.400 --> 00:10:02.410
然后您重新发送，但请继续

00:09:59.530 --> 00:10:06.130
介意按钮我的意思是每个基于TCP的

00:10:02.410 --> 00:10:09.190
如果我使用TCP，系统便会执行此操作

00:10:06.130 --> 00:10:11.140
消息或数据包的缓冲区

00:10:09.190 --> 00:10:16.270
案件将被丢弃在地板上， 

00:10:11.140 --> 00:10:18.450
必须是最新的，这才是有效的

00:10:16.270 --> 00:10:23.380
策略，但我们可以做得更好

00:10:18.450 --> 00:10:28.000
所以典型的答案是，我可以发送

00:10:23.380 --> 00:10:30.310
诀窍，因此当您发送诀窍时

00:10:28.000 --> 00:10:33.270
注意，天哪，我要结束了

00:10:30.310 --> 00:10:35.620
从我的缓冲区空间中，所以您注意到了这一点

00:10:33.270 --> 00:10:38.080
而你想避免提早退出

00:10:35.620 --> 00:10:41.320
内存错误，例如，您可以发送

00:10:38.080 --> 00:10:44.020
 Mac，所以下回负面

00:10:41.320 --> 00:10:46.180
确认，它像这样工作

00:10:44.020 --> 00:10:49.510
然后我们要讨论的是

00:10:46.180 --> 00:10:51.880
是否足够，所以订户

00:10:49.510 --> 00:10:56.230
注意，但剩余空间不多

00:10:51.880 --> 00:10:58.720
在它的缓冲区中，也许它在

00:10:56.230 --> 00:11:01.000
缓冲区溢出的危险

00:10:58.720 --> 00:11:03.550
关注他的橙色箭头向下

00:11:01.000 --> 00:11:07.069
可以在此处发送给发布者

00:11:03.550 --> 00:11:10.889
同步否定

00:11:07.069 --> 00:11:13.739
这意味着但嘿亲爱的出版商

00:11:10.889 --> 00:11:16.829
您介意停止发送数据

00:11:13.739 --> 00:11:18.659
而是的，一种行为方式

00:11:16.829 --> 00:11:21.539
发布者将停止发送数据

00:11:18.659 --> 00:11:26.189
计划唯一的问题是

00:11:21.539 --> 00:11:28.649
时间可能不公平，所以我注意到

00:11:26.189 --> 00:11:31.169
我发送的缓冲区空间用完了

00:11:28.649 --> 00:11:32.789
否定承认，但在

00:11:31.169 --> 00:11:34.979
同时，因为这是一个

00:11:32.789 --> 00:11:37.439
进入系统有一些

00:11:34.979 --> 00:11:40.319
飞行中的消息最终以

00:11:37.439 --> 00:11:46.139
反正缓冲区溢出，所以这是

00:11:40.319 --> 00:11:48.869
不好，这显然不安全，但是

00:11:46.139 --> 00:11:52.319
如果发布商的速度慢，并且

00:11:48.869 --> 00:11:56.029
快速订阅者，我们来谈谈

00:11:52.319 --> 00:11:58.409
反方向做背压所以

00:11:56.029 --> 00:12:01.919
前一个是负数

00:11:58.409 --> 00:12:04.709
致谢，如果我们跟不上

00:12:01.919 --> 00:12:07.829
我们说“嘿，我无法理解

00:12:04.709 --> 00:12:10.559
拉，所以每次我准备

00:12:07.829 --> 00:12:13.049
消耗一个我告诉订户的元素

00:12:10.559 --> 00:12:14.939
给了我一个元素，但是那没有

00:12:13.049 --> 00:12:17.639
真正在我们遇到的情况下扩展

00:12:14.939 --> 00:12:20.279
快速订阅者错过率低

00:12:17.639 --> 00:12:22.919
发布商，因为将会有很多

00:12:20.279 --> 00:12:25.199
垃圾邮件反过来

00:12:22.919 --> 00:12:27.509
方向，以便订户将保持

00:12:25.199 --> 00:12:29.909
告诉发布者已经准备好

00:12:27.509 --> 00:12:32.759
以一百的速度消耗数据

00:12:29.909 --> 00:12:35.909
有时是数千倍

00:12:32.759 --> 00:12:39.419
能够发出数据

00:12:35.909 --> 00:12:42.749
让我们不好，所以反应流

00:12:39.419 --> 00:12:45.629
背压模型是

00:12:42.749 --> 00:12:49.679
这两个模型，所以我们有时称之为

00:12:45.629 --> 00:12:52.259
动态推动力差，但我们有效

00:12:49.679 --> 00:12:55.549
如果我们只是在这里有两个观察

00:12:52.259 --> 00:12:59.999
使用推母，所以诀窍模型

00:12:55.549 --> 00:13:03.239
这是不安全的权利，我们希望我们的

00:12:59.999 --> 00:13:04.470
如果我们只使用极点和

00:13:03.239 --> 00:13:06.209
它会太慢

00:13:04.470 --> 00:13:09.869
订户时情况相反

00:13:06.209 --> 00:13:12.000
实际上很快，所以解决方案是

00:13:09.869 --> 00:13:15.290
在V味之间切换

00:13:12.000 --> 00:13:17.940
但是切换不能真的是

00:13:15.290 --> 00:13:20.790
像现在一样明确，现在我处于推送模式

00:13:17.940 --> 00:13:23.430
哦，现在只是一个非正式的投票

00:13:20.790 --> 00:13:25.110
进入浪子，这里是菲尔

00:13:23.430 --> 00:13:29.220
反应流解决方案返回

00:13:25.110 --> 00:13:32.580
压力是什么，当你有一个

00:13:29.220 --> 00:13:34.650
世界上缓慢的订户，你有

00:13:32.580 --> 00:13:39.030
任何类型的订户都会告诉它

00:13:34.650 --> 00:13:42.480
给出版商给我一些数据， 

00:13:39.030 --> 00:13:45.300
总和是一个具体数字

00:13:42.480 --> 00:13:48.060
给了请求消息，所以我可以说

00:13:45.300 --> 00:13:51.570
请求免费，这意味着我准备好了

00:13:48.060 --> 00:13:54.090
消耗免费消息，这似乎非常

00:13:51.570 --> 00:13:56.820
类似于可怜的模型，它在

00:13:54.090 --> 00:13:59.040
方式是因为我们只提取数据

00:13:56.820 --> 00:14:01.290
并且发布者不可以发信号

00:13:59.040 --> 00:14:04.500
比我们要求他发送的数据更多

00:14:01.290 --> 00:14:07.290
我们，但在这里我们能够打补丁

00:14:04.500 --> 00:14:09.570
将这些请求放在一起，而不是

00:14:07.290 --> 00:14:12.360
拉三下我只能说

00:14:09.570 --> 00:14:15.780
请求三个元素并等待

00:14:12.360 --> 00:14:19.140
出版商这样做，也是因为我

00:14:15.780 --> 00:14:21.330
知道我能够缓冲的空间

00:14:19.140 --> 00:14:25.700
看看我的缓冲区空间并估算

00:14:21.330 --> 00:14:25.700
我可以安全食用的许多元素

00:14:25.850 --> 00:14:32.700
所以这是我的缓冲区能够

00:14:30.060 --> 00:14:35.640
来仍然保留自由元素，所以我

00:14:32.700 --> 00:14:37.589
告诉发布者免费请求，他

00:14:35.640 --> 00:14:39.600
最终会向我发出自由元素的信号

00:14:37.589 --> 00:14:42.120
他们都有这个预先分配的空间

00:14:39.600 --> 00:14:46.620
在缓冲区中，所以我不会炸毁

00:14:42.120 --> 00:14:49.170
我在其他情况下的记忆

00:14:46.620 --> 00:14:51.450
我们有快速的订户协议

00:14:49.170 --> 00:14:54.420
不会改变，是一样的，但是

00:14:51.450 --> 00:14:57.960
我能够修补v3任务

00:14:54.420 --> 00:15:01.290
发出信号并说出要求6或每次

00:14:57.960 --> 00:15:03.990
我把缓冲区空了说请求时间

00:15:01.290 --> 00:15:06.960
因为我的缓冲区大小在哪里

00:15:03.990 --> 00:15:10.230
更适合聪明的领域

00:15:06.960 --> 00:15:12.960
查找人的请求的算法

00:15:10.230 --> 00:15:15.510
策略，因为我知道系统

00:15:12.960 --> 00:15:17.550
表现出我可以调整的数量

00:15:15.510 --> 00:15:21.269
要素和前线要求

00:15:17.550 --> 00:15:23.829
基于协助执行

00:15:21.269 --> 00:15:26.110
当然，因为这是一个

00:15:23.829 --> 00:15:29.050
同步，我们可以发送这些请求

00:15:26.110 --> 00:15:35.019
只要我们想要正确就发出信号，我们

00:15:29.050 --> 00:15:37.120
仍然可以保证安全吗

00:15:35.019 --> 00:15:39.550
出版商当然可以做的其他事情

00:15:37.120 --> 00:15:42.129
积累需求，所以如果我告诉

00:15:39.550 --> 00:15:44.560
发布者要求免费，但他不会发出

00:15:42.129 --> 00:15:48.850
任何数据，然后我再说一遍

00:15:44.560 --> 00:15:52.389
当他要有一个自由的时候

00:15:48.850 --> 00:15:54.040
九个人的总需求也许他也是

00:15:52.389 --> 00:15:56.949
等待其他数据

00:15:54.040 --> 00:15:58.930
当他得到正确的环境时

00:15:56.949 --> 00:16:01.350
数据，他可以开始发送它， 

00:15:58.930 --> 00:16:04.319
消耗了他的累计总需求

00:16:01.350 --> 00:16:07.870
因为我们永远不会发出更多的信号

00:16:04.319 --> 00:16:10.870
只是被告知我们仍然安全

00:16:07.870 --> 00:16:14.050
这种情况发生在订阅事件上，因为

00:16:10.870 --> 00:16:16.240
我们不会再发出更多请求

00:16:14.050 --> 00:16:19.709
我们准备消费，所以一旦

00:16:16.240 --> 00:16:23.019
发送的请求我的整个缓冲区文件大小

00:16:19.709 --> 00:16:27.480
我们只是等到收到一些信号

00:16:23.019 --> 00:16:32.170
从上游开始，所以我们将第二块饼干

00:16:27.480 --> 00:16:35.230
 um非常特殊的情况，在某些情况下

00:16:32.170 --> 00:16:37.360
你现在也许真的是

00:16:35.230 --> 00:16:39.240
订户会更快

00:16:37.360 --> 00:16:42.879
比发布商和

00:16:39.240 --> 00:16:46.420
我们允许的无功三种规格

00:16:42.879 --> 00:16:48.430
请求长maxvill，所以这是一个

00:16:46.420 --> 00:16:52.809
数量庞大，但实际上并不能成为

00:16:48.430 --> 00:16:56.860
饱和，这将使

00:16:52.809 --> 00:16:59.529
发布商以最大的速度和一些

00:16:56.860 --> 00:17:02.680
可能有用的各种系统

00:16:59.529 --> 00:17:05.230
规范不禁止适合它仍然

00:17:02.680 --> 00:17:07.750
很好，您真的选择了我们

00:17:05.230 --> 00:17:10.600
在这种情况下的背压是正确的

00:17:07.750 --> 00:17:13.390
你必须了解自己在做什么

00:17:10.600 --> 00:17:16.740
一旦您请求最大值，是因为

00:17:13.390 --> 00:17:20.260
这之后没有出路了

00:17:16.740 --> 00:17:23.939
让我们看一下反应式管道

00:17:20.260 --> 00:17:27.370
字符串，所以想象你有三个阶段

00:17:23.939 --> 00:17:29.590
因为它的流是由

00:17:27.370 --> 00:17:31.390
不同的阶段，每个阶段都有自己的特点

00:17:29.590 --> 00:17:32.540
东西来处理

00:17:31.390 --> 00:17:35.360
元件

00:17:32.540 --> 00:17:37.880
假设左侧有

00:17:35.360 --> 00:17:40.730
填充右侧的发布者数据

00:17:37.880 --> 00:17:42.290
我们首先想到的是

00:17:40.730 --> 00:17:44.660
一些数据，中间有

00:17:42.290 --> 00:17:46.340
两者都非常活跃的东西

00:17:44.660 --> 00:17:48.920
三个规范，我们称之为

00:17:46.340 --> 00:17:53.120
处理器，因此它既是发布者又是

00:17:48.920 --> 00:17:56.540
冰柱和订阅者，让我们11微米

00:17:53.120 --> 00:17:59.480
我即将开始的典型用例

00:17:56.540 --> 00:18:03.320
处理数据流，但我

00:17:59.480 --> 00:18:06.170
尚未产生需求，因为也许

00:18:03.320 --> 00:18:08.240
如果我有订户启动它

00:18:06.170 --> 00:18:10.970
需要分配一些东西，但是

00:18:08.240 --> 00:18:13.490
发布者可能已经准备好了

00:18:10.970 --> 00:18:16.370
可以预取一些数据以能够

00:18:13.490 --> 00:18:19.460
对第一个反应甚至更快

00:18:16.370 --> 00:18:23.150
请求得到，所以这是渴望

00:18:19.460 --> 00:18:26.150
渴望发布它开始启动

00:18:23.150 --> 00:18:28.700
加载数据，然后等待

00:18:26.150 --> 00:18:31.910
请求，以便它可以再次加载数据

00:18:28.700 --> 00:18:36.110
进入缓冲区准备发信号

00:18:31.910 --> 00:18:38.690
只要有一些需求，那就是

00:18:36.110 --> 00:18:41.330
在这个缓冲区中生长一些东西， 

00:18:38.690 --> 00:18:45.770
当下游终于准备好

00:18:41.330 --> 00:18:49.100
消耗掉我们可以燃烧的信号是的Rico 5 

00:18:45.770 --> 00:18:51.500
到中间的处理器

00:18:49.100 --> 00:18:56.060
不必传播相同的

00:18:51.500 --> 00:18:58.880
需求，这取决于权利

00:18:56.060 --> 00:19:02.420
关于处理器的实现方式

00:18:58.880 --> 00:19:06.890
取决于它的逻辑，但是是的

00:19:02.420 --> 00:19:10.790
传播他们，然后我们能够

00:19:06.890 --> 00:19:13.400
发出四个或所有元素的信号

00:19:10.790 --> 00:19:15.500
在这种情况下，我们已经预装了信号

00:19:13.400 --> 00:19:17.450
四个要素，因为这是

00:19:15.500 --> 00:19:20.360
元素数量释放对它的爱

00:19:17.450 --> 00:19:23.110
发布者，所以我们有两个需求

00:19:20.360 --> 00:19:27.050
仍然可用，您收到了六个信号

00:19:23.110 --> 00:19:29.600
星期二离开了，出版商现在会

00:19:27.050 --> 00:19:32.240
不断获取新数据到他的缓冲区

00:19:29.600 --> 00:19:36.380
一个人坐着准备好了

00:19:32.240 --> 00:19:38.800
再次向下游发出信号，然后

00:19:36.380 --> 00:19:41.810
因为所有这些都是异步发生的

00:19:38.800 --> 00:19:44.270
我们将以这张照片结束

00:19:41.810 --> 00:19:45.480
每个人都有一定数量的

00:19:44.270 --> 00:19:48.600
需求

00:19:45.480 --> 00:19:51.929
和下游的同步信令

00:19:48.600 --> 00:19:54.830
但同时，每个元素

00:19:51.929 --> 00:19:58.049
处理管道将能够

00:19:54.830 --> 00:20:01.470
保留一些缓冲空间和信号

00:19:58.049 --> 00:20:06.000
一直要求上游，所以

00:20:01.470 --> 00:20:08.850
总体思路是，但缓冲区空间是

00:20:06.000 --> 00:20:10.830
两种方式都使用它是保留的

00:20:08.850 --> 00:20:13.860
因为我们在传达需求，我们

00:20:10.830 --> 00:20:15.660
保留空间，我们期待

00:20:13.860 --> 00:20:19.230
一堆要评论的元素

00:20:15.660 --> 00:20:21.210
绿色和蓝色保留空间

00:20:19.230 --> 00:20:23.480
传入元素的缓冲区

00:20:21.210 --> 00:20:28.110
我希望很快能收到通知

00:20:23.480 --> 00:20:32.880
并全力以赴或直接

00:20:28.110 --> 00:20:35.190
数据来源现在很重要

00:20:32.880 --> 00:20:38.990
东西，没有人必须等待

00:20:35.190 --> 00:20:42.419
系统，除非有流量元件

00:20:38.990 --> 00:20:44.720
这并不意味着上游需求

00:20:42.419 --> 00:20:48.630
那我们在等那个家伙

00:20:44.720 --> 00:20:50.970
最终发出需求信号，如果是

00:20:48.630 --> 00:20:55.230
能够以稳定的速度前进

00:20:50.970 --> 00:20:58.500
不必等待任何人都可以

00:20:55.230 --> 00:21:00.630
 SPI，看起来像这样，所以我们有一个

00:20:58.500 --> 00:21:03.660
发布者，直到他们订阅方法

00:21:00.630 --> 00:21:08.400
订户可以订阅

00:21:03.660 --> 00:21:13.500
发布者网站发布者将其提供给

00:21:08.400 --> 00:21:16.320
被订阅订阅，是的

00:21:13.500 --> 00:21:18.570
那里有订户，所以

00:21:16.320 --> 00:21:20.309
总体思路是，对于订阅j 

00:21:18.570 --> 00:21:22.860
是一个共享的秘密和一种

00:21:20.309 --> 00:21:25.740
在发布者之间进行沟通

00:21:22.860 --> 00:21:28.770
在订阅上，所以每当我说您

00:21:25.740 --> 00:21:30.630
这里的信号需求是指

00:21:28.770 --> 00:21:32.910
订户，因为它具有

00:21:30.630 --> 00:21:36.990
订阅可以调用请求方法

00:21:32.910 --> 00:21:39.780
向发布商发出信号的要求

00:21:36.990 --> 00:21:43.200
如我所说，咳嗽如何改变

00:21:39.780 --> 00:21:46.559
正如我一开始所说的那样

00:21:43.200 --> 00:21:48.120
当然，这不是一个非常好的API 

00:21:46.559 --> 00:21:51.450
您可以用任何东西来实现

00:21:48.120 --> 00:21:53.280
它，但是有点困难，我是说

00:21:51.450 --> 00:21:55.740
通常你想要

00:21:53.280 --> 00:21:57.549
处理步骤类似于过滤器

00:21:55.740 --> 00:22:00.399
或数学或

00:21:57.549 --> 00:22:02.320
或在这里进行这种操作

00:22:00.399 --> 00:22:04.419
我们真的没有，我们有

00:22:02.320 --> 00:22:05.830
低级别的构建基块

00:22:04.419 --> 00:22:09.429
背压护理由此

00:22:05.830 --> 00:22:10.989
行为，所以恰如其分

00:22:09.429 --> 00:22:14.409
提供这些高级

00:22:10.989 --> 00:22:16.960
对于那些没有抽象的人

00:22:14.409 --> 00:22:19.600
看过或听说过发生在阿差之前

00:22:16.960 --> 00:22:22.889
有很多我们倾向于认为的模块

00:22:19.600 --> 00:22:27.519
作为工具箱在框架中移动

00:22:22.889 --> 00:22:30.220
是的，它的目标是高性能

00:22:27.519 --> 00:22:32.669
并发以及集群和

00:22:30.220 --> 00:22:37.359
分布式系统，这就是我们的目标

00:22:32.669 --> 00:22:41.950
主要模块是什么

00:22:37.359 --> 00:22:45.340
演员是演员，是抽象

00:22:41.950 --> 00:22:48.340
这为您提供了非常有限的

00:22:45.340 --> 00:22:50.679
功能集，演员可以

00:22:48.340 --> 00:22:53.139
仅发送或接收消息创建

00:22:50.679 --> 00:22:55.960
其他参与者或改变其行为

00:22:53.139 --> 00:22:59.139
这在某种程度上是受限制的，但在另一方面

00:22:55.960 --> 00:23:01.419
方式，您可以建模任何您想要的

00:22:59.139 --> 00:23:04.090
在它的钉子里，这是一个很棒的抽象

00:23:01.419 --> 00:23:07.600
对于并发系统，您基本上

00:23:04.090 --> 00:23:09.879
从许多种族中解脱出来

00:23:07.600 --> 00:23:12.789
在演员里面，你不必担心

00:23:09.879 --> 00:23:16.029
关于并发访问可变数据

00:23:12.789 --> 00:23:19.869
结构说，这就是

00:23:16.029 --> 00:23:21.879
我们所拥有的就是演员的模样

00:23:19.869 --> 00:23:24.279
因此您可以通过扩展来实现演员

00:23:21.879 --> 00:23:26.830
演员你有收到方法

00:23:24.279 --> 00:23:29.440
下一回合你会发红

00:23:26.830 --> 00:23:31.119
由某人给予，然后您可以回复

00:23:29.440 --> 00:23:33.639
发送给该邮件的发件人

00:23:31.119 --> 00:23:36.700
收费阅读器，让您为我们服务

00:23:33.639 --> 00:23:38.769
发件人告诉决定移动好决定移动

00:23:36.700 --> 00:23:42.309
是决定你下一步行动的东西

00:23:38.769 --> 00:23:43.869
例如在某些游戏中，这是

00:23:42.309 --> 00:23:45.850
核心与其他模块

00:23:43.869 --> 00:23:48.789
例如集群和持久性

00:23:45.850 --> 00:23:51.429
 securus甚至进行采购，但让我们谈谈

00:23:48.789 --> 00:23:56.440
关于极端的话题

00:23:51.429 --> 00:24:01.299
大约是正确的，设计目标是

00:23:56.440 --> 00:24:06.070
在可重用性能方面表现出色

00:24:01.299 --> 00:24:09.129
是的，特别是我们真的很在乎

00:24:06.070 --> 00:24:10.250
关于这些绑定的缓冲区空间

00:24:09.129 --> 00:24:12.950
你听过我

00:24:10.250 --> 00:24:15.290
哦，你有几秒钟前在抱怨

00:24:12.950 --> 00:24:17.750
布菲空间这是因为我们真的

00:24:15.290 --> 00:24:21.530
关心这个好吧，现在的问题是

00:24:17.750 --> 00:24:25.250
为什么我们要关心缓冲区空间

00:24:21.530 --> 00:24:28.430
想象你遇到了mmhmm是的

00:24:25.250 --> 00:24:30.440
网络服务器，甚至是聊天室， 

00:24:28.430 --> 00:24:34.850
然后想象你知道你有能力

00:24:30.440 --> 00:24:36.890
使用流处理此请求

00:24:34.850 --> 00:24:40.100
管道，因为这实际上是我们

00:24:36.890 --> 00:24:43.550
在我们的HTTP和即将发布的模块中公开

00:24:40.100 --> 00:24:46.940
您如何处理TCP连接和HTTP 

00:24:43.550 --> 00:24:49.700
连接正确，所以想象你是

00:24:46.940 --> 00:24:51.650
能够建模并确切说明

00:24:49.700 --> 00:24:55.640
缓冲区空间将由

00:24:51.650 --> 00:24:58.910
您系统中的每个流

00:24:55.640 --> 00:25:01.780
如果我有一个连接，那是

00:24:58.910 --> 00:25:06.380
从来没有使用更多的日期更多的空间乐趣

00:25:01.780 --> 00:25:08.210
比正常情况下的图表所示

00:25:06.380 --> 00:25:10.250
也许会更古怪

00:25:08.210 --> 00:25:12.920
上下跳跃并导致大量GC 

00:25:10.250 --> 00:25:15.320
在我们的情况下，我们已经预先分配了

00:25:12.920 --> 00:25:17.960
缓冲空间，我们只是重复使用它们

00:25:15.320 --> 00:25:20.240
本来会更稳定的记忆

00:25:17.960 --> 00:25:23.750
明智的表现，你可以估计

00:25:20.240 --> 00:25:26.990
我能连接多少个

00:25:23.750 --> 00:25:34.580
在此服务器上消耗（如果它有800） 

00:25:26.990 --> 00:25:37.490
好的ram，但没有tuve API，所以

00:25:34.580 --> 00:25:40.430
 API使用略有不同的措辞范

00:25:37.490 --> 00:25:43.490
 Vere活动流一个，这也是

00:25:40.430 --> 00:25:45.800
通过选择，因为我们正在建模

00:25:43.490 --> 00:25:49.850
更高层次的抽象

00:25:45.800 --> 00:25:51.950
所以我们需要更好的语言，如果

00:25:49.850 --> 00:25:54.970
是只有一个输入的东西

00:25:51.950 --> 00:25:58.580
恰好有一个输出，所以可以认为是

00:25:54.970 --> 00:26:00.740
地图map是一个很好的例子，如果您

00:25:58.580 --> 00:26:02.750
有一个收藏可以映射

00:26:00.740 --> 00:26:04.910
从目的出发，您可以

00:26:02.750 --> 00:26:07.760
今天可以将其纳入

00:26:04.910 --> 00:26:11.930
考试的力量，这将是一个缺陷

00:26:07.760 --> 00:26:13.640
夫人女士，有资源，来源在哪里

00:26:11.930 --> 00:26:17.210
数据来自，他们有

00:26:13.640 --> 00:26:19.850
恰好一个不绑定和输出

00:26:17.210 --> 00:26:23.760
港口，他们沉没，其中有一个

00:26:19.850 --> 00:26:27.250
没有绑定的端口，这是它的目的

00:26:23.760 --> 00:26:29.470
是的，转型明智，您可以

00:26:27.250 --> 00:26:32.620
只是将变换放入地图

00:26:29.470 --> 00:26:35.710
代码中的一步巫婆巫婆看起来像

00:26:32.620 --> 00:26:39.760
所以有一个浮点双，我们做

00:26:35.710 --> 00:26:42.730
这是另一种思考方式

00:26:39.760 --> 00:26:45.940
关于这些只是在想

00:26:42.730 --> 00:26:51.700
这是一个管道，你可以管道的东西

00:26:45.940 --> 00:26:54.190
水果，嗯，也值得一提

00:26:51.700 --> 00:26:57.100
说它还没有附上

00:26:54.190 --> 00:26:59.460
来源权，所以当我们出售它时

00:26:57.100 --> 00:27:02.170
流过你只是在说这个

00:26:59.460 --> 00:27:06.190
流已准备好进行双打

00:27:02.170 --> 00:27:09.220
还没有附加源

00:27:06.190 --> 00:27:11.740
对于那些谁是一些水的基础知识

00:27:09.220 --> 00:27:14.440
我们不熟悉anaka 

00:27:11.740 --> 00:27:16.570
称为主动系统的东西

00:27:14.440 --> 00:27:20.140
演员系统是包含

00:27:16.570 --> 00:27:22.690
您应用程序中的所有参与者

00:27:20.140 --> 00:27:25.270
它基本上是一组水池

00:27:22.690 --> 00:27:27.480
配置和注册表

00:27:25.270 --> 00:27:30.850
与演员定位并做事

00:27:27.480 --> 00:27:33.340
然后我们需要实现的流程

00:27:30.850 --> 00:27:35.560
所以我们流物质化是为一个谁

00:27:33.340 --> 00:27:37.780
负责流

00:27:35.560 --> 00:27:40.630
他的描述和图形描述

00:27:37.780 --> 00:27:43.870
处理管道并将其变成

00:27:40.630 --> 00:27:47.080
运行我实际上正在运行的东西

00:27:43.870 --> 00:27:49.270
用他的数据做事，因此确定

00:27:47.080 --> 00:27:51.760
有趣的是什么路

00:27:49.270 --> 00:27:54.010
因为我们让你举起

00:27:51.760 --> 00:27:58.360
此流程处理的表示

00:27:54.010 --> 00:28:00.190
当什么时候表示，任何人都可以

00:27:58.360 --> 00:28:02.470
在此处写一个流物化器

00:28:00.190 --> 00:28:05.080
将其实现为不同的处理

00:28:02.470 --> 00:28:08.380
管道，但描述确实

00:28:05.080 --> 00:28:10.780
同样的权利，您可以运行地图

00:28:08.380 --> 00:28:12.970
您可以在其中运行计算火花

00:28:10.780 --> 00:28:14.770
在acha上进行计算，但您也可以

00:28:12.970 --> 00:28:17.880
如果您真的想在Hadoop上运行它

00:28:14.770 --> 00:28:21.940
对，所以这是一个有趣的功能

00:28:17.880 --> 00:28:24.910
尚未利用，但我们希望如此

00:28:21.940 --> 00:28:27.040
嗯，我们的工作流实现了当前的演员

00:28:24.910 --> 00:28:29.020
基于服务器的操作将得到支持

00:28:27.040 --> 00:28:31.420
由演员和他们交流

00:28:29.020 --> 00:28:34.440
通过使用消息传递进行同步

00:28:31.420 --> 00:28:39.010
当然您可以配置它

00:28:34.440 --> 00:28:41.890
现在是我们第一次看到水槽

00:28:39.010 --> 00:28:44.380
在行动中，所以在这里我们有一个沉

00:28:41.890 --> 00:28:46.330
每个目的，我们都会做

00:28:44.380 --> 00:28:48.640
东西，当你放置一个

00:28:46.330 --> 00:28:53.260
我们得到每个元素的功能

00:28:48.640 --> 00:28:55.570
对，然后是最简单的方法

00:28:53.260 --> 00:28:58.770
您的合作流的世界是

00:28:55.570 --> 00:29:01.480
源一二三将产生

00:28:58.770 --> 00:29:04.120
在这些元素一二和三

00:29:01.480 --> 00:29:08.320
然后将其运行到水槽

00:29:04.120 --> 00:29:11.350
有效地只是打印它，我会说

00:29:08.320 --> 00:29:15.010
再往下走一点

00:29:11.350 --> 00:29:17.620
为什么这样，我们有分开

00:29:15.010 --> 00:29:20.710
现在的事情有些图书馆

00:29:17.620 --> 00:29:22.600
选择只有一种抽象

00:29:20.710 --> 00:29:24.730
选择了这些不同的

00:29:22.600 --> 00:29:26.440
并认为建模和建模更容易

00:29:24.730 --> 00:29:29.800
如果我知道这些事情的原因

00:29:26.440 --> 00:29:31.840
它的来源或下沉以及如何

00:29:29.800 --> 00:29:35.080
实际上实现它使用ventas 

00:29:31.840 --> 00:29:38.350
非斯嘉丽流化剂

00:29:35.080 --> 00:29:40.450
人和实际的解释，所以

00:29:38.350 --> 00:29:43.870
隐式意味着当您看到隐式

00:29:40.450 --> 00:29:46.270
从Liza意味着管中的病毒NAT 

00:29:43.870 --> 00:29:49.270
我们可以跳过写括号

00:29:46.270 --> 00:29:52.540
马特（Matt） 

00:29:49.270 --> 00:29:54.520
对于每个水槽，这意味着更少的通过

00:29:52.540 --> 00:29:57.190
围绕参数，我们总是有

00:29:54.520 --> 00:29:59.980
一些燃料实现范围，因此

00:29:57.190 --> 00:30:02.230
编译器为我们做他的工作Java 

00:29:59.980 --> 00:30:05.650
 API是因为它也完全可用

00:30:02.230 --> 00:30:08.500
来自Java实际上与此非常相似

00:30:05.650 --> 00:30:10.900
特别是在Java 8中

00:30:08.500 --> 00:30:14.410
现在已经完成，看起来非常相似

00:30:10.900 --> 00:30:16.030
在大多数情况下，除了

00:30:14.410 --> 00:30:18.220
物化器必须是例如

00:30:16.030 --> 00:30:22.300
明确地按

00:30:18.220 --> 00:30:24.690
小小的化妆品变化，所以如果你是一个

00:30:22.300 --> 00:30:28.810
 Java家伙，您可以从整体上使用它

00:30:24.690 --> 00:30:31.750
是的，典型的问题是为什么

00:30:28.810 --> 00:30:35.230
与运行，所以与我们一起运行

00:30:31.750 --> 00:30:37.060
某种东西，但是对于某种

00:30:35.230 --> 00:30:41.080
像前进和前进一样的行动

00:30:37.060 --> 00:30:43.600
已经预建了什么是糖

00:30:41.080 --> 00:30:45.030
因此您可以将其明确地称为

00:30:43.600 --> 00:30:47.430
每条印刷线

00:30:45.030 --> 00:30:50.220
这是终端操作的想法

00:30:47.430 --> 00:30:53.190
终端操作我的意思是

00:30:50.220 --> 00:30:55.290
实际上与您实现

00:30:53.190 --> 00:30:59.070
我们将在此时开始运行

00:30:55.290 --> 00:31:02.030
你为每一个都写

00:30:59.070 --> 00:31:04.170
带有名称的方法

00:31:02.030 --> 00:31:06.750
我们目前正在

00:31:04.170 --> 00:31:09.090
重命名这些，以便每个

00:31:06.750 --> 00:31:11.550
称为每个运行，福特将运行

00:31:09.090 --> 00:31:13.800
叫运行福特，所以每当你看到一个

00:31:11.550 --> 00:31:17.880
开头的方法

00:31:13.800 --> 00:31:20.760
不会意识到引用，所以一堆

00:31:17.880 --> 00:31:23.730
输入我们在NACO中拥有的安全物品

00:31:20.760 --> 00:31:28.770
流，所以我说，但流不是

00:31:23.730 --> 00:31:31.260
仍附加到来源，但我做到了

00:31:28.770 --> 00:31:33.630
它也没有连接到水槽，所以你

00:31:31.260 --> 00:31:36.000
不能只是将它附加到交换

00:31:33.630 --> 00:31:42.770
下沉并期望它运行不会

00:31:36.000 --> 00:31:46.080
编译是因为它既需要

00:31:42.770 --> 00:31:51.510
在这里，在这个例子中，我向我展示

00:31:46.080 --> 00:31:54.570
流量未连接到um 

00:31:51.510 --> 00:31:57.540
一切我都无法运行，但是如果

00:31:54.570 --> 00:32:02.970
你采取流程，然后连接到

00:31:57.540 --> 00:32:06.270
它的来源啊，对不起，我有一个

00:32:02.970 --> 00:32:08.730
这基本上是什么意思

00:32:06.270 --> 00:32:10.230
是你必须两面都依附吗

00:32:08.730 --> 00:32:15.420
可以在

00:32:10.230 --> 00:32:17.550
真空哦，那是一个更好的

00:32:15.420 --> 00:32:20.250
例如，当您有流程时，您可以

00:32:17.550 --> 00:32:23.940
将它们映射成字符串，然后就可以

00:32:20.250 --> 00:32:26.730
给它处理程序的两端

00:32:23.940 --> 00:32:28.590
所以水槽中的酱料1到10 

00:32:26.730 --> 00:32:31.460
只是在黑色主机它将忽略

00:32:28.590 --> 00:32:34.110
即将到来的数据

00:32:31.460 --> 00:32:37.680
有趣的事情是流量

00:32:34.110 --> 00:32:39.990
可重复使用，这意味着您可以

00:32:37.680 --> 00:32:42.810
一次构造这个管道并值

00:32:39.990 --> 00:32:44.400
它有多个来源，这也是

00:32:42.810 --> 00:32:47.190
有趣，因为您可以构建

00:32:44.400 --> 00:32:49.530
这个复杂的处理管道

00:32:47.190 --> 00:32:52.350
一旦保持它缓存另一个值

00:32:49.530 --> 00:32:54.750
然后多次使用

00:32:52.350 --> 00:32:56.919
每周运行一次，喂饱了

00:32:54.750 --> 00:32:59.330
例如您的系统

00:32:56.919 --> 00:33:03.620
这里我们稍微复杂一点

00:32:59.330 --> 00:33:05.450
案例，这也是偷看幻灯片

00:33:03.620 --> 00:33:07.730
如何与我的合作者融合

00:33:05.450 --> 00:33:09.679
所以你只有演员订阅者

00:33:07.730 --> 00:33:11.630
然后将获得所有这些元素

00:33:09.679 --> 00:33:14.360
上游发出信号

00:33:11.630 --> 00:33:16.639
处理管道，您拥有了所有

00:33:14.360 --> 00:33:18.679
疯狂过滤器掉落组之类的平常事物

00:33:16.639 --> 00:33:20.929
通过和按特定分组

00:33:18.679 --> 00:33:24.940
有趣，因为它产生了一个流

00:33:20.929 --> 00:33:27.980
的流让我们看一下它的外观

00:33:24.940 --> 00:33:33.230
所以因为我得到某种

00:33:27.980 --> 00:33:39.019
数字和13 12 11以及当我分组时

00:33:33.230 --> 00:33:42.440
我会得到的最后一个虹吸号码

00:33:39.019 --> 00:33:45.259
嗯，可能是

00:33:42.440 --> 00:33:49.789
表征为终结的事物

00:33:45.259 --> 00:33:53.029
与一个人，你会得到范

00:33:49.789 --> 00:33:56.000
按操作员分组信号流

00:33:53.029 --> 00:33:59.480
一对我的案子的钥匙

00:33:56.000 --> 00:34:03.019
是20和3之一，并且每个

00:33:59.480 --> 00:34:04.730
这些给你这个的子流

00:34:03.019 --> 00:34:06.740
当您可以使用子流或

00:34:04.730 --> 00:34:09.230
如果您不感兴趣，请取消

00:34:06.740 --> 00:34:11.889
以第二个结尾的第二个

00:34:09.230 --> 00:34:14.379
您可以取消子流，然后

00:34:11.889 --> 00:34:18.369
只吃那些你想进来的

00:34:14.379 --> 00:34:20.569
这很有趣，因为

00:34:18.369 --> 00:34:22.399
通常你会期望收集

00:34:20.569 --> 00:34:23.869
在这里，但是在溪流中

00:34:22.399 --> 00:34:26.419
真的必须停止思考

00:34:23.869 --> 00:34:29.030
集合和只是流，因为

00:34:26.419 --> 00:34:32.260
流可能是无限的权利

00:34:29.030 --> 00:34:35.000
你不能轻易适应无限

00:34:32.260 --> 00:34:37.490
元素至少不能进入内存

00:34:35.000 --> 00:34:39.740
当前的计算机正确，所以这是

00:34:37.490 --> 00:34:41.899
一切都是流，您可以申请

00:34:39.740 --> 00:34:44.240
彼此进行流操作以进行子操作

00:34:41.899 --> 00:34:48.919
流和再次分组或做

00:34:44.240 --> 00:34:51.889
是的，不同的事情好吗

00:34:48.919 --> 00:34:55.550
消耗子流和不同

00:34:51.889 --> 00:34:57.250
流动的不同事物，但

00:34:55.550 --> 00:35:00.589
我今天要谈的是

00:34:57.250 --> 00:35:04.099
图形处理，所以这是一个相当

00:35:00.589 --> 00:35:06.470
我们服装的独特之处

00:35:04.099 --> 00:35:09.440
其他图书馆不是那么专注

00:35:06.470 --> 00:35:12.319
我们认为复杂的草稿处理

00:35:09.440 --> 00:35:17.720
所以阿南卡溪流的面孔覆盖了流

00:35:12.319 --> 00:35:21.319
图，所以每当您看到这些f1 f2 f3 

00:35:17.720 --> 00:35:26.720
 f4想象这是一个流程，但这仅仅是

00:35:21.319 --> 00:35:29.750
线性字符串对，但是那又怎么样

00:35:26.720 --> 00:35:31.760
这些广播和合并这些东西

00:35:29.750 --> 00:35:37.599
这就是我们所说的“扇出” 

00:35:31.760 --> 00:35:40.730
操作也只是交界处

00:35:37.599 --> 00:35:42.950
让我们看看这个例子中最简单的

00:35:40.730 --> 00:35:46.940
不是最简单但非常简单的图形

00:35:42.950 --> 00:35:49.760
然后尝试建模，然后我们看一下

00:35:46.940 --> 00:35:54.170
进入图表的极限DSL 

00:35:49.760 --> 00:35:57.170
实际上有效，因此设计目标

00:35:54.170 --> 00:35:59.240
当您拥有自己的dsl时

00:35:57.170 --> 00:36:02.510
在设计会议上您要画些东西

00:35:59.240 --> 00:36:04.790
白板，基本上它将结束

00:36:02.510 --> 00:36:07.190
这样或多或少地上升

00:36:04.790 --> 00:36:09.349
变成圆圈，它将变成箭头，所以

00:36:07.190 --> 00:36:12.200
这里的设计目标是使

00:36:09.349 --> 00:36:15.440
圆周图元素，使四个

00:36:12.200 --> 00:36:17.750
线条正常的流动元素，所以让我

00:36:15.440 --> 00:36:21.380
在这有一些颜色的院子

00:36:17.750 --> 00:36:24.680
每个F的情况，每个线性Porton 

00:36:21.380 --> 00:36:26.060
处理映射到流程和价值

00:36:24.680 --> 00:36:28.970
不同类型的东西

00:36:26.060 --> 00:36:31.849
示例f1将接受输入并转到

00:36:28.970 --> 00:36:34.400
上调到中间值然后f2 

00:36:31.849 --> 00:36:36.829
而四个将使这些

00:36:34.400 --> 00:36:39.530
中间值变成一些丰富的

00:36:36.829 --> 00:36:45.740
值，然后我们可以过滤它们

00:36:39.530 --> 00:36:48.530
在F free中，这是

00:36:45.740 --> 00:36:53.089
现在新闻的线性运算

00:36:48.530 --> 00:36:55.880
看图方程，所以我们开始

00:36:53.089 --> 00:36:57.859
通过制作流程图，当我们

00:36:55.880 --> 00:37:00.310
导入隐式生成的流程图

00:36:57.859 --> 00:37:05.690
快速面对箭头运算符可用

00:37:00.310 --> 00:37:07.640
然后我们简单地连接这些，这样当

00:37:05.690 --> 00:37:11.240
您会注意到，因为这是

00:37:07.640 --> 00:37:13.880
广播和更糟糕的事情，我们只是第一

00:37:11.240 --> 00:37:15.500
定义它们，所以您要付出很高的代价

00:37:13.880 --> 00:37:18.560
这是一个中间的广播

00:37:15.500 --> 00:37:20.359
价值观广播意味着每个订户

00:37:18.560 --> 00:37:22.400
将获得相同的价值不会

00:37:20.359 --> 00:37:23.360
进入这个广播，然后我们有

00:37:22.400 --> 00:37:26.860
出现了我们

00:37:23.360 --> 00:37:29.840
我们只是从一个或另一个

00:37:26.860 --> 00:37:35.360
流入并产生流出

00:37:29.840 --> 00:37:37.190
大多数流，所以我们声明这些，然后

00:37:35.360 --> 00:37:39.860
我们使用它们，所以当您查看

00:37:37.190 --> 00:37:42.350
顶部的图是否会出现f1 

00:37:39.860 --> 00:37:45.410
广播和广播

00:37:42.350 --> 00:37:47.540
到和四，然后博士说你

00:37:45.410 --> 00:37:49.910
可以看到它与

00:37:47.540 --> 00:37:52.040
图看起来像白板上的

00:37:49.910 --> 00:37:55.850
那是一个明确的设计目标，我

00:37:52.040 --> 00:37:57.620
以为是我很好奇

00:37:55.850 --> 00:38:00.980
随时听听您的意见

00:37:57.620 --> 00:38:02.800
沙龙，所以我之前先说

00:38:00.980 --> 00:38:05.660
关于冻结，但让我重申

00:38:02.800 --> 00:38:08.240
一旦有了流程图，它就是

00:38:05.660 --> 00:38:11.150
一成不变，可以安全地共享

00:38:08.240 --> 00:38:13.490
线程，实际上我们要去

00:38:11.150 --> 00:38:16.850
旨在使其成为可能

00:38:13.490 --> 00:38:20.090
在正义的节点之间共享，因为

00:38:16.850 --> 00:38:22.190
这只是我们运作方式的描述

00:38:20.090 --> 00:38:26.060
运行事物，因此从理论上讲

00:38:22.190 --> 00:38:30.170
在集群之间自由共享，但我们

00:38:26.060 --> 00:38:32.600
没有变化，这是一个未来的计划，所以我们

00:38:30.170 --> 00:38:38.900
有20分钟的时间准时所以我

00:38:32.600 --> 00:38:42.950
要跳入一些例子，让我们这样

00:38:38.900 --> 00:38:51.860
让我在这里打开IntelliJ 

00:38:42.950 --> 00:38:53.690
一个不是这个一个是这个这个嗯

00:38:51.860 --> 00:38:56.300
准备了一些示例，让我们看看

00:38:53.690 --> 00:38:58.340
我们有多少时间没有离开过

00:38:56.300 --> 00:39:00.890
一些，然后我们决定去

00:38:58.340 --> 00:39:04.910
正确地进入并跳入问答环节，哦，如果

00:39:00.890 --> 00:39:06.500
我们将再做一个例子，这样

00:39:04.910 --> 00:39:10.220
读者并重申如何无用

00:39:06.500 --> 00:39:12.530
你有一个活跃的系统地板

00:39:10.220 --> 00:39:14.210
实现我导入系统

00:39:12.530 --> 00:39:17.210
分散只是为了要

00:39:14.210 --> 00:39:18.950
在不是很好的情况下执行期货

00:39:17.210 --> 00:39:23.810
真的是汽车特有的东西

00:39:18.950 --> 00:39:26.450
一位学者未来的具体事情如此

00:39:23.810 --> 00:39:29.210
但是，您想这样做，让我们

00:39:26.450 --> 00:39:31.100
来源，让我们看看是哪种

00:39:29.210 --> 00:39:34.400
我们可以拥有的资源，因此可以是

00:39:31.100 --> 00:39:36.950
来自演员的适合道具的来源可以

00:39:34.400 --> 00:39:38.900
实际上是由图制成的

00:39:36.950 --> 00:39:42.109
它可以是一个计时器酱，这是非常

00:39:38.900 --> 00:39:43.970
很好的读取延迟到ver并打勾好

00:39:42.109 --> 00:39:47.119
那么我们可以从

00:39:43.970 --> 00:39:50.060
未来，它是橡胶或

00:39:47.119 --> 00:39:53.480
迭代，否则我们可以简单地消耗一个

00:39:50.060 --> 00:39:56.770
在我们的案例中反应流发布者

00:39:53.480 --> 00:40:04.400
让我们做点好事，我们打个招呼

00:39:56.770 --> 00:40:05.630
看到她的话和另外两个这样

00:40:04.400 --> 00:40:11.349
现在将是

00:40:05.630 --> 00:40:14.210
角色我们该怎么办

00:40:11.349 --> 00:40:17.630
有很多不同的事情，所以

00:40:14.210 --> 00:40:23.810
例如，我们可以放一堆

00:40:17.630 --> 00:40:26.320
元素过滤器组由新苏维埃一

00:40:23.810 --> 00:40:29.750
准备好了，但我们要照常做

00:40:26.320 --> 00:40:34.040
传统的东西子车所以

00:40:29.750 --> 00:40:40.490
进来的东西是一辆车，是的，好的

00:40:34.040 --> 00:40:43.640
然后我们可以对上壁说C 

00:40:40.490 --> 00:40:48.950
 Scarlett语法为何可以做到这一点

00:40:43.640 --> 00:40:51.079
是的，是的，如果我

00:40:48.950 --> 00:40:53.390
想要在添加一些感叹号

00:40:51.079 --> 00:40:56.180
最后，我们有一个运算符

00:40:53.390 --> 00:40:58.730
它在一致中被称为concat意味着

00:40:56.180 --> 00:41:01.130
拿走第一个来源并将其排干

00:40:58.730 --> 00:41:04.460
然后，一旦您耗尽了第一个

00:41:01.130 --> 00:41:09.980
源开始排第二个

00:41:04.460 --> 00:41:17.359
在我们的情况下，我们可以开始排水

00:41:09.980 --> 00:41:20.980
事情不是最令人惊讶的，例如例子

00:41:17.359 --> 00:41:24.200
在这里，但是很有趣，因为你

00:41:20.980 --> 00:41:26.540
可以合并不同的数据源

00:41:24.200 --> 00:41:29.030
然后这个和解基本上

00:41:26.540 --> 00:41:31.520
提供数据的第一个来源是

00:41:29.030 --> 00:41:33.770
耗尽继续第二个来源

00:41:31.520 --> 00:41:37.310
数据到底是什么

00:41:33.770 --> 00:41:40.430
发生在这里，然后我们也许

00:41:37.310 --> 00:41:46.490
首先从通常的

00:41:40.430 --> 00:41:49.670
两种方式，所以我们有一个下沉对象Anaka 

00:41:46.490 --> 00:41:51.860
这个水槽还剩下一帮手

00:41:49.670 --> 00:41:57.050
所以在这里您可以看到各种各样的

00:41:51.860 --> 00:41:59.240
认为我们提供了，例如下沉

00:41:57.050 --> 00:42:01.070
头是指第一个元素

00:41:59.240 --> 00:42:03.110
在整个案例中

00:42:01.070 --> 00:42:08.630
将是一个年龄，所以不是很有趣

00:42:03.110 --> 00:42:11.690
所以让我们为每个实际使用IE 

00:42:08.630 --> 00:42:14.090
会很有趣，所以需要40分钟

00:42:11.690 --> 00:42:16.460
一些安定的，而流是

00:42:14.090 --> 00:42:28.030
给您新的价值积累

00:42:16.460 --> 00:42:28.030
迈入新步伐福特零

00:42:29.020 --> 00:42:40.780
蓄能器和汽车很好，所以

00:42:37.460 --> 00:42:48.640
汽车作为蓄能器，我们可以说X 

00:42:40.780 --> 00:42:48.640
加C那么cos到底吃了什么

00:42:48.910 --> 00:42:55.880
所以因为这是一次

00:42:51.890 --> 00:42:58.340
实现流程并在此处运行

00:42:55.880 --> 00:43:03.800
从913隐含实现

00:42:58.340 --> 00:43:12.680
对，值实际上将是

00:43:03.800 --> 00:43:17.500
字符串的未来字符串的未来

00:43:12.680 --> 00:43:19.609
我对当前的未来感到恐惧

00:43:17.500 --> 00:43:21.200
因为因为我们真的不知道

00:43:19.609 --> 00:43:25.310
当流将要结束时

00:43:21.200 --> 00:43:29.330
将永远正确完成，然后我们可以

00:43:25.310 --> 00:43:42.040
在值上执行地图可能是

00:43:29.330 --> 00:43:45.430
完整的标签和文本

00:43:42.040 --> 00:43:52.990
我们可以移动关闭代码

00:43:45.430 --> 00:44:01.090
在这家伙之下

00:43:52.990 --> 00:44:09.790
得出结论，现在我有一个编译

00:44:01.090 --> 00:44:33.610
错误，现在尝试

00:44:09.790 --> 00:44:36.250
经营这个家伙，现在怎么办

00:44:33.610 --> 00:44:38.560
配置并不能帮助IntelliJ 

00:44:36.250 --> 00:44:47.340
我领事很好，让我们跳到

00:44:38.560 --> 00:44:47.340
控制台在这里，我们有一个控制台

00:44:48.450 --> 00:44:56.260
你可以看到我开火了

00:44:52.230 --> 00:44:58.780
并写了成功的话，这是

00:44:56.260 --> 00:45:02.850
因为一个夜晚的完整代表

00:44:58.780 --> 00:45:07.270
对，所以它可以是成功或失败

00:45:02.850 --> 00:45:11.350
好吧，让我们在这里谈谈图表

00:45:07.270 --> 00:45:15.370
一个简单的图，基本上是

00:45:11.350 --> 00:45:20.350
与我们以前完全一样的事情

00:45:15.370 --> 00:45:25.780
如此及时的幻灯片实际上让我们

00:45:20.350 --> 00:45:28.810
跳到或只是显示您如何

00:45:25.780 --> 00:45:34.060
可以轻松地写这个，所以我们

00:45:28.810 --> 00:45:40.690
计算一个棒的最小成本是

00:45:34.060 --> 00:45:44.680
广播中间值和

00:45:40.690 --> 00:45:46.090
那么我需要出现好吧，让我们使用

00:45:44.680 --> 00:45:48.490
不同的元素使它变得更多

00:45:46.090 --> 00:45:50.710
有趣，所以这将是

00:45:48.490 --> 00:45:54.010
拉链，因为它需要一些东西

00:45:50.710 --> 00:45:55.180
恰好两个两个流并压缩到它们

00:45:54.010 --> 00:45:58.359
在一起在一起

00:45:55.180 --> 00:46:01.180
的事情，还请注意，我们有一个

00:45:58.359 --> 00:46:04.059
疤痕的DSL和Java的D，所以这是

00:46:01.180 --> 00:46:06.790
因为当然，我们尝试使

00:46:04.059 --> 00:46:09.430
每种语言最好的DSL 

00:46:06.790 --> 00:46:11.650
猩红色看起来不错的东西

00:46:09.430 --> 00:46:15.400
一定看起来不错，在

00:46:11.650 --> 00:46:18.040
重量也相反，所以当我从

00:46:15.400 --> 00:46:19.869
学者先生，先生，我会得到一个

00:46:18.040 --> 00:46:21.400
猩红色歌剧，我们有一些东西是

00:46:19.869 --> 00:46:25.990
叫顶真的考了两个要素

00:46:21.400 --> 00:46:29.140
当我们用Java压缩亲爱的先生时，我们得到

00:46:25.990 --> 00:46:31.720
一个Java对，我们有一个辅助类

00:46:29.140 --> 00:46:36.490
这样对我们来说更有用

00:46:31.720 --> 00:46:40.720
倾向于只使用工作的用户

00:46:36.490 --> 00:46:44.859
是一流的公民，所以我

00:46:40.720 --> 00:46:49.050
压缩丰富的东西吧

00:46:44.859 --> 00:46:57.490
让我们准备，现在从输入

00:46:49.050 --> 00:47:00.760
通过f1通过广播和

00:46:57.490 --> 00:47:07.260
重视小尺寸手机， 

00:47:00.760 --> 00:47:10.140
通过f2冒起者离开，所以请注意并

00:47:07.260 --> 00:47:13.420
而广播只是馈送给它

00:47:10.140 --> 00:47:20.260
 gzip实际上已经为

00:47:13.420 --> 00:47:23.950
它的输入，所以在这里我们想找到一个

00:47:20.260 --> 00:47:27.240
通过我相信的广播

00:47:23.950 --> 00:47:30.760
不穿左输入但右穿

00:47:27.240 --> 00:47:32.799
这也是60型

00:47:30.760 --> 00:47:37.380
是左手的第二种类型

00:47:32.799 --> 00:47:44.570
是正确的输入，当我要

00:47:37.380 --> 00:47:49.280
墨菲的拉杰

00:47:44.570 --> 00:47:58.310
哦，对不起，一旦显示抱歉，对不起

00:47:49.280 --> 00:48:02.390
我的意思是说要压缩拉链，所以我们有

00:47:58.310 --> 00:48:05.630
此visit元素的输出和

00:48:02.390 --> 00:48:08.480
必须沉入一些东西，所以

00:48:05.630 --> 00:48:10.760
在这里我有一个出版商的东西

00:48:08.480 --> 00:48:12.800
公开一个反应式流发布者

00:48:10.760 --> 00:48:15.940
任何人的消费都将继续

00:48:12.800 --> 00:48:18.530
但是，是的，这只是一个丰富的

00:48:15.940 --> 00:48:23.270
而现在我有一双

00:48:18.530 --> 00:48:27.470
好吧，那已经是一个要素

00:48:23.270 --> 00:48:29.320
还有更多的事情要知道，而同时我们

00:48:27.470 --> 00:48:33.140
在这里让我们谈谈净额结算

00:48:29.320 --> 00:48:35.120
因为许多其他欢迎磁带

00:48:33.140 --> 00:48:37.670
我们与您一起工作的人暴露

00:48:35.120 --> 00:48:41.840
期货对，所以他们暴露了未来

00:48:37.670 --> 00:48:44.150
结果不只是为了价值，所以在这里

00:48:41.840 --> 00:48:48.290
我们有丰富的中间贸易

00:48:44.150 --> 00:48:52.730
或丰富ASIC，这是为了年轻的行为

00:48:48.290 --> 00:48:54.200
例如海军HTTP通话或其他

00:48:52.730 --> 00:48:57.440
必须出去做点什么

00:48:54.200 --> 00:49:00.380
最终会给您结果

00:48:57.440 --> 00:49:02.840
在这里我正在使用一个小睡异步

00:49:00.380 --> 00:49:07.430
完全类似于地图的运算符

00:49:02.840 --> 00:49:13.010
但能够从中提取价值

00:49:07.430 --> 00:49:14.630
未来并通过它，所以我们过去

00:49:13.010 --> 00:49:17.240
在元素上一旦未来

00:49:14.630 --> 00:49:20.210
成功并成功竞争

00:49:17.240 --> 00:49:23.270
失败，我们通过失败，并为

00:49:20.210 --> 00:49:24.830
流，是的，这就是全部

00:49:23.270 --> 00:49:27.590
如果您想知道还有一个

00:49:24.830 --> 00:49:30.170
无序的情况，因为如果你在做

00:49:27.590 --> 00:49:32.870
每个人都在打多个电话

00:49:30.170 --> 00:49:35.000
在他们完成之前

00:49:32.870 --> 00:49:37.610
未来也许你不在乎所有

00:49:35.000 --> 00:49:39.560
您只想以最快的速度进行

00:49:37.610 --> 00:49:41.720
您可以，因此您想生成

00:49:39.560 --> 00:49:43.940
尽可能快地满足山区需求

00:49:41.720 --> 00:49:46.730
产生需求的方法是清除

00:49:43.940 --> 00:49:48.770
处理只是保持处理的东西，所以

00:49:46.730 --> 00:49:51.770
您要处理的不是水中的，而是

00:49:48.770 --> 00:49:53.810
尽可能快地无序，但是

00:49:51.770 --> 00:49:56.530
小小的琐事可能会有所帮助

00:49:53.810 --> 00:49:58.790
在您的处理管道中

00:49:56.530 --> 00:50:03.250
所以我要告诉你的下一个是

00:49:58.790 --> 00:50:05.930
实际上，嗯，我不同意

00:50:03.250 --> 00:50:10.910
改善我们现在所看到的

00:50:05.930 --> 00:50:12.650
这会很好，没关系，我

00:50:10.910 --> 00:50:15.110
有这个左边右边这是一种

00:50:12.650 --> 00:50:17.570
有意义，特别是对于排行榜，但

00:50:15.110 --> 00:50:22.190
当我有一个人要映射到

00:50:17.570 --> 00:50:24.170
拉一个人，我该怎么做

00:50:22.190 --> 00:50:30.110
有很多方法可以做到

00:50:24.170 --> 00:50:37.040
首先让我们看一个简单的案例

00:50:30.110 --> 00:50:39.830
可以准备我的拉链来准备我的拉链

00:50:37.040 --> 00:50:44.810
在这里上课，这将是一个简单的

00:50:39.830 --> 00:50:46.520
现在我的zip可以是和的zip 

00:50:44.810 --> 00:50:56.950
妻子是有功能的

00:50:46.520 --> 00:50:56.950
我们没有拉链的拉链

00:50:59.740 --> 00:51:10.640
是的，好的，然后我们可以输入一个名字

00:51:05.830 --> 00:51:18.200
字符串和将要映射的边

00:51:10.640 --> 00:51:19.760
对这个人来说不痒

00:51:18.200 --> 00:51:24.020
这是一种非常强大的表达方式

00:51:19.760 --> 00:51:27.470
因为现在我们可以使用左和

00:51:24.020 --> 00:51:33.130
压缩人的权利，因此

00:51:27.470 --> 00:51:37.610
您重新学习的zip输出错过了一点

00:51:33.130 --> 00:51:40.730
现在观察到的是一个人，所以

00:51:37.610 --> 00:51:45.350
这更好，但我正在了解如何

00:51:40.730 --> 00:51:47.000
我们怎样才能使它变得更好

00:51:45.350 --> 00:51:50.800
首先，让我们使用一些学者

00:51:47.000 --> 00:51:54.850
善良，所以我们可以使整个崩溃

00:51:50.800 --> 00:51:57.620
没事，要加下划线

00:51:54.850 --> 00:51:59.510
现在可以推断出正确的类型

00:51:57.620 --> 00:52:03.290
 zip，您会看到它需要一个字符串

00:51:59.510 --> 00:52:05.810
结束中间人，所以这

00:52:03.290 --> 00:52:06.910
很好，但这仍然不是我们最好的东西

00:52:05.810 --> 00:52:09.290
可以做

00:52:06.910 --> 00:52:12.980
所以现在我要显示最后一个

00:52:09.290 --> 00:52:16.310
今天的例子将是弹性

00:52:12.980 --> 00:52:21.140
可以让我们写名字的图片

00:52:16.310 --> 00:52:22.880
和H，这样我们就可以拥有一个不错的

00:52:21.140 --> 00:52:26.030
处理增长实际上告诉我们

00:52:22.880 --> 00:52:32.619
我们正在做的事情在这里，我们将不得不

00:52:26.030 --> 00:52:39.140
说新的可能称其为安全人

00:52:32.619 --> 00:52:45.160
与开始不符会延长payflex 

00:52:39.140 --> 00:52:47.869
图像将发出一个光标， 

00:52:45.160 --> 00:52:49.970
然后我们必须创建此鼠标逻辑

00:52:47.869 --> 00:52:52.790
足够的逻辑将负责

00:52:49.970 --> 00:52:55.670
读取此数据，因为它将决定

00:52:52.790 --> 00:52:58.220
来自丰富输入的元素

00:52:55.670 --> 00:53:03.190
流我们做什么，首先我们需要

00:52:58.220 --> 00:53:07.330
定义名称并创建输入端口，并

00:53:03.190 --> 00:53:14.000
一个名字是一个字符串，然后我们需要H 

00:53:07.330 --> 00:53:16.940
 H在其中，所以现在您可以看到

00:53:14.000 --> 00:53:21.589
第36 37行会编译，但不会

00:53:16.940 --> 00:53:27.170
真正做到我们想要的，所以我们想要

00:53:21.589 --> 00:53:29.780
具有众多逻辑远程逻辑

00:53:27.170 --> 00:53:35.869
人，我们可以跳过这种类型的

00:53:29.780 --> 00:53:37.910
符号，我宁愿实现它

00:53:35.869 --> 00:53:45.740
迅速，所以我们并没有完全摆脱

00:53:37.910 --> 00:53:47.780
时间，所以首先我们必须全力以赴

00:53:45.740 --> 00:53:51.710
处理之间，我将要使用

00:53:47.780 --> 00:53:55.099
在这场比赛中，所以现在我们的情况是

00:53:51.710 --> 00:53:58.040
被命名为年龄，然后我们将使用

00:53:55.099 --> 00:54:03.109
我应该说，这将是

00:53:58.040 --> 00:54:06.530
小麦状态或您可以阅读的输入

00:54:03.109 --> 00:54:09.080
关于视觉，并深深地打了狗，但

00:54:06.530 --> 00:54:12.140
它确实意味着我将发出一个

00:54:09.080 --> 00:54:16.089
每当我想成为所有输入的元素

00:54:12.140 --> 00:54:16.089
读对不起

00:54:16.270 --> 00:54:25.220
阅读或姓名和年龄，这意味着

00:54:21.530 --> 00:54:27.860
每当两个元素上的元素

00:54:25.220 --> 00:54:30.560
这些读过的或自己的名字，以及我的年龄

00:54:27.860 --> 00:54:34.370
想触发这个功能

00:54:30.560 --> 00:54:38.560
在我们的上下文中这并不有趣

00:54:34.370 --> 00:54:41.350
这种情况通常包含

00:54:38.560 --> 00:54:44.330
输入被触发，但在我们的情况下， 

00:54:41.350 --> 00:54:50.290
触发所有级别，所以我们不在乎

00:54:44.330 --> 00:55:06.830
然后我们可以联系给一个人

00:54:50.290 --> 00:55:11.530
从n加9到h，你必须

00:55:06.830 --> 00:55:14.930
返回相同状态，因为此状态

00:55:11.530 --> 00:55:17.270
助手实际上是一个状态机

00:55:14.930 --> 00:55:19.580
每当你发出一个元素时

00:55:17.270 --> 00:55:21.740
可以成为另一个状态，例如我

00:55:19.580 --> 00:55:24.350
现在完成了，我将完成

00:55:21.740 --> 00:55:27.290
在我们的情况下，这条流我们留在

00:55:24.350 --> 00:55:30.260
同样研究，所以这是你多么容易

00:55:27.290 --> 00:55:34.220
可以定义自己的合并， 

00:55:30.260 --> 00:55:38.030
也是扇出元素的助手

00:55:34.220 --> 00:55:41.990
现在被称为弹性路线

00:55:38.030 --> 00:55:44.930
让我们跳回幻灯片并结束

00:55:41.990 --> 00:55:48.740
有问题，以便总结我们所做的事情

00:55:44.930 --> 00:55:51.050
我们谈到了非非

00:55:48.740 --> 00:55:53.750
阻止背压我们如何做复杂

00:55:51.050 --> 00:55:56.870
粗加工管道和一堆

00:55:53.750 --> 00:55:59.210
自定义元素现在我们没有

00:55:56.870 --> 00:56:01.670
探索，但实际上是

00:55:59.210 --> 00:56:03.500
有趣的东西在这里看到是如何

00:56:01.670 --> 00:56:05.270
放置一个显式缓冲如何

00:56:03.500 --> 00:56:07.790
如果有的话，整合我们的校正器

00:56:05.270 --> 00:56:11.200
现有系统或只需要完整的

00:56:07.790 --> 00:56:14.900
控制演员给你的东西，以及

00:56:11.200 --> 00:56:17.800
基于时间的操作，因此需要两个

00:56:14.900 --> 00:56:22.790
秒的操作和

00:56:17.800 --> 00:56:25.040
我们还有什么未来的计划，所以

00:56:22.790 --> 00:56:27.560
我们流的当前状态是

00:56:25.040 --> 00:56:28.549
正在稳定API，我们

00:56:27.560 --> 00:56:32.049
旨在释放

00:56:28.549 --> 00:56:38.209
你已经想要了，可能是下一个早

00:56:32.049 --> 00:56:39.890
下个月，当然不是下个月

00:56:38.209 --> 00:56:42.829
我们正在处理文档

00:56:39.890 --> 00:56:45.170
现在得到一个Java版本，那么我们是

00:56:42.829 --> 00:56:47.479
改善我们想要的可测试性

00:56:45.170 --> 00:56:51.259
提供与您类似的测试套件

00:56:47.479 --> 00:56:55.849
有针对汽车的测试探针

00:56:51.259 --> 00:56:58.369
演员和最重要的事情

00:56:55.849 --> 00:57:01.189
记住acha流还没有

00:56:58.369 --> 00:57:02.989
表演学生，所以你可以期待

00:57:01.189 --> 00:57:05.469
性能更好，因为我们有一个

00:57:02.989 --> 00:57:10.849
一堆，现在在瓶颈上， 

00:57:05.469 --> 00:57:13.789
已知可以解决的瓶颈

00:57:10.849 --> 00:57:16.369
必须解决它们，我们知道如何解决

00:57:13.789 --> 00:57:18.049
它将变得更快，当您

00:57:16.369 --> 00:57:19.969
随便玩吧

00:57:18.049 --> 00:57:23.390
其实以为已经快了

00:57:19.969 --> 00:57:26.299
足够一些最近的博客文章

00:57:23.390 --> 00:57:29.779
在互联网上的表演很

00:57:26.299 --> 00:57:31.429
有趣的是，除此之外

00:57:29.779 --> 00:57:33.019
太好了，我们正计划这样做

00:57:31.429 --> 00:57:34.849
在某个时候提供一些

00:57:33.019 --> 00:57:37.489
这两个流的可视化

00:57:34.849 --> 00:57:39.709
处理图，他们会说

00:57:37.489 --> 00:57:42.109
蒂姆的有趣的社区项目

00:57:39.709 --> 00:57:44.439
希望你可以看看它II发现

00:57:42.109 --> 00:57:47.259
真的很棒，所以你可以看看

00:57:44.439 --> 00:57:50.630
这是一堆链接，我想

00:57:47.259 --> 00:57:52.489
将您定向到我们的主页，我们可以

00:57:50.630 --> 00:57:55.999
获得一堆免费的电子书，如果

00:57:52.489 --> 00:57:57.619
您对此感兴趣，我认为我们

00:57:55.999 --> 00:58:02.929
有一点时间来提问

00:57:57.619 --> 00:58:04.569
所以我不确定我们要如何

00:58:02.929 --> 00:58:07.969
问题是，等等，谢谢奎因·富

00:58:04.569 --> 00:58:11.630
好的，是的，谢谢。 

00:58:07.969 --> 00:58:17.539
精彩的网络研讨会，到目前为止，我看到了

00:58:11.630 --> 00:58:22.880
只有几个问题，所以我尝试

00:58:17.539 --> 00:58:25.819
从托马斯读第一本书

00:58:22.880 --> 00:58:28.519
正确理解而你却不明白

00:58:25.819 --> 00:58:34.729
必须手动指定

00:58:28.519 --> 00:58:37.459
 n返回发布者，是的，是的

00:58:34.729 --> 00:58:39.930
表示执行或反应

00:58:37.459 --> 00:58:46.330
流API 

00:58:39.930 --> 00:58:49.960
现在这样做，对吧，答案

00:58:46.330 --> 00:58:52.840
取决于哪个API是反应式的

00:58:49.960 --> 00:58:55.480
流，如果您不手动请求

00:58:52.840 --> 00:58:57.340
你不会有任何元素，所以你会

00:58:55.480 --> 00:58:59.470
与手动反应有关

00:58:57.340 --> 00:59:00.970
流，这就是为什么我们

00:58:59.470 --> 00:59:03.460
服装和其他实现是

00:59:00.970 --> 00:59:05.110
非常有用，因为我们提供了这些Rico 

00:59:03.460 --> 00:59:07.390
策略，您不必在意

00:59:05.110 --> 00:59:09.790
关于这一切只是提供缓冲

00:59:07.390 --> 00:59:12.790
空间，如果是帐户，您可以

00:59:09.790 --> 00:59:16.330
提供一个请求策略，例如

00:59:12.790 --> 00:59:18.790
高低水好人好人

00:59:16.330 --> 00:59:22.060
标记，以便您知道缓冲区大小

00:59:18.790 --> 00:59:25.030
你给我们高低的水

00:59:22.060 --> 00:59:29.740
要开始请求时标记

00:59:25.030 --> 00:59:32.350
并停止请求，如果

00:59:29.740 --> 00:59:35.230
您达到了高水准的元素

00:59:32.350 --> 00:59:37.390
所以你的缓冲区是10我高

00:59:35.230 --> 00:59:39.100
水印是例如8 

00:59:37.390 --> 00:59:41.110
停止请求，这样您就可以耗尽

00:59:39.100 --> 00:59:42.340
一点点，当你达到低点

00:59:41.110 --> 00:59:44.440
您将开始的水印

00:59:42.340 --> 00:59:49.690
再次请求，但已完成

00:59:44.440 --> 00:59:52.780
透明，然后再购买就可以了

00:59:49.690 --> 00:59:54.610
谢谢独木舟和另一个问题我

00:59:52.780 --> 00:59:58.090
与史蒂夫不知道什么正确

00:59:54.610 --> 01:00:00.550
我读过它，我是这个程序设计的新手

00:59:58.090 --> 01:00:05.050
我想知道程序是否有

01:00:00.550 --> 01:00:09.210
作为Java的能力，我相信

01:00:05.050 --> 01:00:13.690
问题是关于表现啊，好耶

01:00:09.210 --> 01:00:16.720
所以性能方面的最后一个数字

01:00:13.690 --> 01:00:18.340
我看过他们，或者我可能会说

01:00:16.720 --> 01:00:21.340
出问题了一段时间了

01:00:18.340 --> 01:00:24.070
但是akka通常可以执行

01:00:21.340 --> 01:00:26.710
每秒5百万次操作

01:00:24.070 --> 01:00:29.320
消息分每秒，是的

01:00:26.710 --> 01:00:31.870
流如此基础，所以我们的目标是

01:00:29.320 --> 01:00:34.600
至少每秒达到几百万

01:00:31.870 --> 01:00:37.060
所以这通常不是瓶颈

01:00:34.600 --> 01:00:39.220
您的应用程序，我们往往是

01:00:37.060 --> 01:00:42.310
在事情的更快方面快，所以我

01:00:39.220 --> 01:00:45.820
不用担心性能还可以

01:00:42.310 --> 01:00:49.010
很好啊，下一个问题我在哪里可以

01:00:45.820 --> 01:00:51.650
找到您显示的此源代码

01:00:49.010 --> 01:00:55.310
好吧，那是一条简单的手臂

01:00:51.650 --> 01:00:57.650
在github上，您要去acha acha和verse 

01:00:55.310 --> 01:00:59.900
 arca流的来源是

01:00:57.650 --> 01:01:03.400
目前居住在分公司发布

01:00:59.900 --> 01:01:08.810
为了释放破折号死亡，我可以写在

01:01:03.400 --> 01:01:11.330
回应是的，我想

01:01:08.810 --> 01:01:14.500
太好了，如果我们可以分享这个白色

01:01:11.330 --> 01:01:20.780
在网络研讨会之后，那不是李

01:01:14.500 --> 01:01:24.440
好的，很好，嗯，下一个问题

01:01:20.780 --> 01:01:27.350
哦，我喜欢，因为我也曾经

01:01:24.440 --> 01:01:30.830
这个问题哦，最好的用途是什么

01:01:27.350 --> 01:01:35.650
使用我们的协同流的案例以及现在

01:01:30.830 --> 01:01:42.140
您现在什么时候建议不要使用它

01:01:35.650 --> 01:01:47.230
好吧嗯嗯，所以我很抱歉我只是

01:01:42.140 --> 01:01:49.970
相信童话不是每个人都知道的

01:01:47.230 --> 01:01:53.420
阿查，可能会很棒

01:01:49.970 --> 01:01:56.240
封面现在给她一些例子

01:01:53.420 --> 01:01:59.930
使用流足球的用例

01:01:56.240 --> 01:02:03.440
有用，是的，很高兴，所以让我们开始吧

01:01:59.930 --> 01:02:05.720
也许不会与一般发生

01:02:03.440 --> 01:02:08.570
一般用于需要高

01:02:05.720 --> 01:02:12.260
可扩展性，因为例如

01:02:08.570 --> 01:02:14.000
真空团簇，这意味着

01:02:12.260 --> 01:02:17.270
演员如何工作，他们只交流

01:02:14.000 --> 01:02:20.330
通过消息传递对它是透明的

01:02:17.270 --> 01:02:22.550
用户，如果此演员位于远程

01:02:20.330 --> 01:02:24.800
该集群或其他本地系统

01:02:22.550 --> 01:02:27.590
跟我一起意味着你可以扩展

01:02:24.800 --> 01:02:30.130
只需添加群集和注释即可

01:02:27.590 --> 01:02:33.410
集群和应用程序不

01:02:30.130 --> 01:02:36.520
真的必须做出很多改变，因为

01:02:33.410 --> 01:02:39.140
它只会发送静止消息， 

01:02:36.520 --> 01:02:41.960
因为如果代码不变

01:02:39.140 --> 01:02:44.180
您可以考虑的本地或远程

01:02:41.960 --> 01:02:46.790
系统中的并发

01:02:44.180 --> 01:02:49.730
关于哦，但现在我必须向外扩展

01:02:46.790 --> 01:02:51.920
这将是麻烦，Annika，我们

01:02:49.730 --> 01:02:54.800
为您提供此位置的透明度，因此

01:02:51.920 --> 01:02:56.720
滑冰很容易，甚至

01:02:54.800 --> 01:02:58.280
在本地，我们往往很高

01:02:56.720 --> 01:03:01.310
 500万的绩效实践

01:02:58.280 --> 01:03:02.900
每秒的消息数通常是这样

01:03:01.310 --> 01:03:07.819
比大多数高

01:03:02.900 --> 01:03:10.640
然后出现流，这样

01:03:07.819 --> 01:03:14.000
总的来说，Actavis的缺点是

01:03:10.640 --> 01:03:16.730
他们非常可以做任何正确的事

01:03:14.000 --> 01:03:19.339
如果我们能做任何事情，它就会

01:03:16.730 --> 01:03:22.039
涉及复杂性的代价

01:03:19.339 --> 01:03:24.829
遵循代码路径并带有

01:03:22.039 --> 01:03:27.140
诅咒梦想，你有这条精确的道路

01:03:24.829 --> 01:03:29.630
元素如何流过

01:03:27.140 --> 01:03:33.010
这个流以及什么操作是

01:03:29.630 --> 01:03:35.329
在一个上完成，所以非常适合

01:03:33.010 --> 01:03:38.089
这类系统

01:03:35.329 --> 01:03:40.609
一些输入需要将其转换为

01:03:38.089 --> 01:03:43.520
一堆方法，然后发出信号

01:03:40.609 --> 01:03:47.210
一堆其他系统，或者仅仅是

01:03:43.520 --> 01:03:49.099
一个文件，所以像一个迷你MapReduce 

01:03:47.210 --> 01:03:52.700
您可以完全在内存中完成的操作

01:03:49.099 --> 01:03:57.079
带着车，我希望这能回答你

01:03:52.700 --> 01:04:01.430
问题哦，什么时候不使用

01:03:57.079 --> 01:04:03.829
是的，我想住在这里，也是

01:04:01.430 --> 01:04:07.670
问题的一部分，让我们看看何时

01:04:03.829 --> 01:04:10.660
你不像我说的那样很好地使用我们的汽车

01:04:07.670 --> 01:04:13.700
总会带来性能成本

01:04:10.660 --> 01:04:16.099
复杂性方面的性能成本

01:04:13.700 --> 01:04:18.740
有点，所以如果你有问题

01:04:16.099 --> 01:04:21.470
一品就可以轻松解决

01:04:18.740 --> 01:04:24.410
而处理将需要五个

01:04:21.470 --> 01:04:26.450
几分钟，也许您不需要

01:04:24.410 --> 01:04:29.569
另一方面，我们确实有

01:04:26.450 --> 01:04:37.039
不错的AP冰，所以您必须看一下

01:04:29.569 --> 01:04:39.890
并进行比较交易是的，好吧

01:04:37.039 --> 01:04:42.020
伟大的下一个问题，如果我需要

01:04:39.890 --> 01:04:44.839
更改资源状态

01:04:42.020 --> 01:04:47.480
来自接收器示例Kafka的反馈

01:04:44.839 --> 01:04:54.619
更糟，取决于接收器输出rizzett 

01:04:47.480 --> 01:04:56.809
卡夫卡偏移到我之前的偏移量

01:04:54.619 --> 01:05:00.710
试图找到问题，以便我可以

01:04:56.809 --> 01:05:06.230
阅读它，因为它有点复杂

01:05:00.710 --> 01:05:09.710
来自埃文ah hi Evan 

01:05:06.230 --> 01:05:11.510
我让我慢慢读一遍，如果我

01:05:09.710 --> 01:05:14.060
需要改变条带状态

01:05:11.510 --> 01:05:18.560
使用来自同步咳嗽的反馈

01:05:14.060 --> 01:05:22.820
宇宙取决于我们设置的同步输出

01:05:18.560 --> 01:05:28.100
卡夫卡偏移到更早，所以

01:05:22.820 --> 01:05:29.630
听起来像是重播或

01:05:28.100 --> 01:05:31.820
需要的东西

01:05:29.630 --> 01:05:34.270
消除它的偏移量

01:05:31.820 --> 01:05:38.090
前两个重播这些值

01:05:34.270 --> 01:05:41.720
对我来说听起来很像

01:05:38.090 --> 01:05:46.780
会模型这是，我没有显示

01:05:41.720 --> 01:05:49.880
今天，但我们可以做一个图

01:05:46.780 --> 01:05:53.240
肤色图，您的图会

01:05:49.880 --> 01:05:55.880
有一些反馈输入，这将

01:05:53.240 --> 01:05:57.950
作为反馈，您可以发出信号，嘿，我的

01:05:55.880 --> 01:06:02.690
酱汁，请你再回一点

01:05:57.950 --> 01:06:06.350
这样的来源，我可以

01:06:02.690 --> 01:06:08.060
在图里面，然后这个图可以

01:06:06.350 --> 01:06:10.790
尽可能地复杂

01:06:08.060 --> 01:06:14.080
多个反馈输入，但随后您

01:06:10.790 --> 01:06:18.740
可以将其暴露于

01:06:14.080 --> 01:06:21.800
只是作为来源，所以我想我只是

01:06:18.740 --> 01:06:25.130
将其建模为图形并放入反馈

01:06:21.800 --> 01:06:30.290
作为明确的输入，它不必

01:06:25.130 --> 01:06:36.650
回到现在例如希望这个

01:06:30.290 --> 01:06:40.700
可以，所以下一个问题很好

01:06:36.650 --> 01:06:43.730
短信传递保证和我

01:06:40.700 --> 01:06:46.040
相信它，直到他们的下一个

01:06:43.730 --> 01:06:49.250
质疑所有错误处理方式

01:06:46.040 --> 01:06:52.460
如果一个流在ARCA流中实现

01:06:49.250 --> 01:06:55.070
节点失败，我们将最终添加新的

01:06:52.460 --> 01:06:58.340
知道了，嗯，让我们开始吧

01:06:55.070 --> 01:07:00.800
也同时去，所以我发消息

01:06:58.340 --> 01:07:04.190
交付目前很好保证

01:07:00.800 --> 01:07:07.100
本地，所以它不是同一台JVM 

01:07:04.190 --> 01:07:09.980
没有那么强大的消息丢失

01:07:07.100 --> 01:07:12.680
回答这个问题，所以是一个镭

01:07:09.980 --> 01:07:14.960
所以另一方面没有网络问题

01:07:12.680 --> 01:07:18.530
我说过要散发这2 

01:07:14.960 --> 01:07:19.970
集群最终正确，所以公平地说

01:07:18.530 --> 01:07:21.770
实际上将不得不阅读

01:07:19.970 --> 01:07:26.300
实施与

01:07:21.770 --> 01:07:29.540
内部确认

01:07:26.300 --> 01:07:31.940
 Arco中的一些系统消息，所以不是

01:07:29.540 --> 01:07:33.890
一个全新的概念，但是

01:07:31.940 --> 01:07:35.869
我们必须向流公开的东西

01:07:33.890 --> 01:07:38.990
让他们能够阅读传递

01:07:35.869 --> 01:07:43.040
消息及以后如何出错

01:07:38.990 --> 01:07:45.109
实现了处理方式

01:07:43.040 --> 01:07:49.250
反应性流发出信号错误是

01:07:45.109 --> 01:07:52.400
通过取消事物或通过什么

01:07:49.250 --> 01:07:55.099
这实际上是关键方法

01:07:52.400 --> 01:07:57.619
发信号通知错误，因此当您遇到

01:07:55.099 --> 01:08:00.320
订户有很多方法

01:07:57.619 --> 01:08:02.480
就像在下一个，我们有了新的

01:08:00.320 --> 01:08:05.510
流完成时元素

01:08:02.480 --> 01:08:08.869
完成，最后出现错误

01:08:05.510 --> 01:08:13.130
错误弄皱了眉头，这是怎么回事

01:08:08.869 --> 01:08:16.219
你绕过失败的

01:08:13.130 --> 01:08:18.380
流见只会告诉你告诉你

01:08:16.219 --> 01:08:20.480
因为错误而订阅它是的

01:08:18.380 --> 01:08:23.950
什么东西，如果有下游

01:08:20.480 --> 01:08:27.290
那么它可以传播这个错误，所以

01:08:23.950 --> 01:08:30.259
这样的指令流明智，我们

01:08:27.290 --> 01:08:31.910
还在思考，因为我们

01:08:30.259 --> 01:08:34.549
在正确的地球上运行

01:08:31.910 --> 01:08:38.120
在我们的收藏家中，我们有一件事

01:08:34.549 --> 01:08:41.239
称为监督等级制度， 

01:08:38.120 --> 01:08:44.509
监督他如何让你拥有

01:08:41.239 --> 01:08:48.440
点东西失败恢复如果有的话

01:08:44.509 --> 01:08:50.690
弯曲的整个东西都失败了，所以我们有

01:08:48.440 --> 01:08:53.540
关于如何进行的持续讨论

01:08:50.690 --> 01:08:56.239
整合能够移动流

01:08:53.540 --> 01:08:58.910
只是指出您合适的方法

01:08:56.239 --> 01:09:00.049
如果您有兴趣，请在github上找到它

01:08:58.910 --> 01:09:06.739
绝对在考虑做

01:09:00.049 --> 01:09:09.950
更花哨的东西好谢谢

01:09:06.739 --> 01:09:12.890
下一个问题来了

01:09:09.950 --> 01:09:16.670
计划更多基于预定义的基于推的

01:09:12.890 --> 01:09:19.299
例如时间源

01:09:16.670 --> 01:09:24.859
我们在定制外部提供低价

01:09:19.299 --> 01:09:27.380
虽然杀手注入元素

01:09:24.859 --> 01:09:29.600
尽管他们可能不太符合

01:09:27.380 --> 01:09:33.410
与相对流

01:09:29.600 --> 01:09:35.830
太酷了-嗯，实际上他们非常

01:09:33.410 --> 01:09:39.109
安静地遵守协议，只是

01:09:35.830 --> 01:09:41.180
电影科尔沃的所谓来源

01:09:39.109 --> 01:09:43.460
不能真正背压时间

01:09:41.180 --> 01:09:45.350
基本上这意味着你不能

01:09:43.460 --> 01:09:49.670
真的背了一个男人点击的压力

01:09:45.350 --> 01:09:51.859
男人的嘴像疯了似的，我们

01:09:49.670 --> 01:09:55.990
协议为什么还适合，因为您

01:09:51.859 --> 01:09:59.060
允许删除元素正确和

01:09:55.990 --> 01:10:02.210
因此，例如，可能是元素

01:09:59.060 --> 01:10:07.250
在伊拉克的这个被称为

01:10:02.210 --> 01:10:10.970
去抖动，这意味着如果我得到一个

01:10:07.250 --> 01:10:13.220
每秒千次点击是的

01:10:10.970 --> 01:10:18.200
不要将所有这些都发送到下游，但是

01:10:13.220 --> 01:10:20.540
只需在此一秒钟内发送一个

01:10:18.200 --> 01:10:23.210
绝对是对此的支持，但我们

01:10:20.540 --> 01:10:26.810
除了时间没有任何内置

01:10:23.210 --> 01:10:29.290
目前我认为重点是

01:10:26.810 --> 01:10:32.690
目前在后端多一点

01:10:29.290 --> 01:10:35.660
我们这样的来源是可以避免的

01:10:32.690 --> 01:10:38.570
 tcp并没有真正算出我们有一个

01:10:35.660 --> 01:10:43.280
我们当然使用的tcp来源

01:10:38.570 --> 01:10:45.200
我们的HTTP和我的简历，但这有点

01:10:43.280 --> 01:10:48.800
不同，因为操作系统

01:10:45.200 --> 01:10:52.160
也有一个TCP缓冲区，我们有点

01:10:48.800 --> 01:10:56.870
额外依赖于TCP缓冲区

01:10:52.160 --> 01:11:00.290
在操作系统中，所以

01:10:56.870 --> 01:11:01.730
快速的其他计划，是的，我

01:11:00.290 --> 01:11:04.250
认为这回答了我们的问题

01:11:01.730 --> 01:11:06.230
研究我们可以提供什么样的资源

01:11:04.250 --> 01:11:13.790
提供，我们真的没有太多

01:11:06.230 --> 01:11:16.550
基于推送的，还不错，可能

01:11:13.790 --> 01:11:18.980
最后一个问题存档的效果如何

01:11:16.550 --> 01:11:21.500
溪流与现有的水相融合

01:11:18.980 --> 01:11:24.760
据我了解，集群应用程序

01:11:21.500 --> 01:11:28.610
当前创建一个已知的演员系统

01:11:24.760 --> 01:11:30.560
好吧，让我们首先开始

01:11:28.610 --> 01:11:33.470
误解这里的误解是

01:11:30.560 --> 01:11:35.420
审核在系统完成后创建

01:11:33.470 --> 01:11:37.010
真的不必创建一个通宵

01:11:35.420 --> 01:11:40.480
系统，如果您已有

01:11:37.010 --> 01:11:43.670
您可以使用现有的应用程序

01:11:40.480 --> 01:11:46.610
演员系统您将需要什么

01:11:43.670 --> 01:11:49.040
创建流物化器，但这

01:11:46.610 --> 01:11:51.590
只是一个照顾一个对象

01:11:49.040 --> 01:11:53.270
实现不是额外的

01:11:51.590 --> 01:11:56.600
威胁启动，因此当重用现有设备时

01:11:53.270 --> 01:11:59.800
实验室的基础设施以及性能如何

01:11:56.600 --> 01:12:03.080
一体化集群集群

01:11:59.800 --> 01:12:05.810
但是它将与演员整合

01:12:03.080 --> 01:12:08.150
我会问的远程节点，因为

01:12:05.810 --> 01:12:12.500
第4节要解决的关键问题我们不是

01:12:08.150 --> 01:12:14.420
非常，所以我真的不会被吸引

01:12:12.500 --> 01:12:16.810
兔子从我的头上跳出来怎么回事

01:12:14.420 --> 01:12:26.330
看起来，但我们真的很想

01:12:16.810 --> 01:12:28.340
实现这个好吧好吧酷我认为

01:12:26.330 --> 01:12:31.429
这就是我们所拥有的，我们涵盖了

01:12:28.340 --> 01:12:33.219
几乎一切都很好

01:12:31.429 --> 01:12:38.480
谢谢你可以等你的伟大

01:12:33.219 --> 01:12:43.699
演示文稿，我们将共享幻灯片

01:12:38.480 --> 01:12:47.989
在博客中，我认为就是这样

01:12:43.699 --> 01:12:52.030
每13次更新一次，请注意再见

01:12:47.989 --> 01:12:52.030
祝你有美好的一天

