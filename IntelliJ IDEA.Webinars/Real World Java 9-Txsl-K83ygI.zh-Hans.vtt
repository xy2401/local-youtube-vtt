WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.870 --> 00:00:07.380
今天我们要谈论Java 9 

00:00:05.550 --> 00:00:10.080
显然，这项工作的时机

00:00:07.380 --> 00:00:11.340
自从Java 9诞生以来

00:00:10.080 --> 00:00:14.610
前一周的最后一周

00:00:11.340 --> 00:00:15.809
最近，我正在使用Java 1 

00:00:14.610 --> 00:00:18.359
这周也有很多

00:00:15.809 --> 00:00:19.830
 Java 9周围的噪音是什么

00:00:18.359 --> 00:00:22.650
以及它将如何影响我们

00:00:19.830 --> 00:00:24.179
开发人员，因此在此网络研讨会中

00:00:22.650 --> 00:00:27.570
这就是我们要涵盖的内容

00:00:24.179 --> 00:00:29.460
安德里亚（Andrea）说，所以我一直喜欢做的事

00:00:27.570 --> 00:00:31.349
我的演讲是我喜欢的

00:00:29.460 --> 00:00:33.390
与我们相关的功能

00:00:31.349 --> 00:00:35.940
开发人员，并展示我们将如何

00:00:33.390 --> 00:00:37.140
在我们实际的日常工作中使用它们，以便

00:00:35.940 --> 00:00:39.140
这就是为什么我称它为真实世界

00:00:37.140 --> 00:00:41.520
 Java 9我们来看看

00:00:39.140 --> 00:00:44.280
拼图当然是大事了

00:00:41.520 --> 00:00:46.710
 Java 9的项目，我们将有一个

00:00:44.280 --> 00:00:48.990
快速查看Java 9中的反应式API 

00:00:46.710 --> 00:00:49.610
然后我们将涵盖所有内容

00:00:48.990 --> 00:00:52.200
其他

00:00:49.610 --> 00:00:54.210
不幸的是，对于Java 9和Java 

00:00:52.200 --> 00:00:56.760
九分品牌的事实是

00:00:54.210 --> 00:00:58.650
德国专线有很多不同的类型

00:00:56.760 --> 00:01:00.690
小变化使它成为

00:00:58.650 --> 00:01:03.210
作为开发人员对我们来说是不同的，但他们

00:01:00.690 --> 00:01:04.799
不要落入一个好转的伞下

00:01:03.210 --> 00:01:07.229
所以基本上我们将涵盖

00:01:04.799 --> 00:01:08.909
其他一切，我们

00:01:07.229 --> 00:01:10.920
没有很多时间，例如安德鲁

00:01:08.909 --> 00:01:13.200
说请随便放所有

00:01:10.920 --> 00:01:15.240
问题放入网络研讨会问题框中

00:01:13.200 --> 00:01:16.770
我们将尝试在

00:01:15.240 --> 00:01:18.359
结束但是我想做的就是尝试

00:01:16.770 --> 00:01:20.249
并涵盖尽可能多的这些功能

00:01:18.359 --> 00:01:22.079
在演示过程中可能

00:01:20.249 --> 00:01:25.469
然后他们，然后离开很多

00:01:22.079 --> 00:01:27.719
当然首先要问的问题

00:01:25.469 --> 00:01:29.280
问题是为什么Java 9除了

00:01:27.719 --> 00:01:30.929
这是最新最伟大的事实

00:01:29.280 --> 00:01:31.710
事情，我们一直在等待它

00:01:30.929 --> 00:01:33.689
三年

00:01:31.710 --> 00:01:36.539
为什么要将代码升级到

00:01:33.689 --> 00:01:38.549
像往常一样正常使用Java 9 

00:01:36.539 --> 00:01:41.039
在诸如此类的事情上真的很努力

00:01:38.549 --> 00:01:43.170
性能，即使您不使用任何

00:01:41.039 --> 00:01:46.439
新功能中的任何新功能

00:01:43.170 --> 00:01:48.869
语法任何你应该免费的

00:01:46.439 --> 00:01:50.579
更好的表现，尤其是周围

00:01:48.869 --> 00:01:53.700
使用内存，他们改变了方式

00:01:50.579 --> 00:01:55.560
字符串起作用，因此可能占用最多

00:01:53.700 --> 00:01:57.060
过去一半的内存是

00:01:55.560 --> 00:01:59.639
您可以获得更好的锁定性能

00:01:57.060 --> 00:02:01.469
保护应用程序图形，这是

00:01:59.639 --> 00:02:02.999
确实对

00:02:01.469 --> 00:02:04.259
 IntelliJ IDEA也一样

00:02:02.999 --> 00:02:05.969
我们已经能够使用一些Java 

00:02:04.259 --> 00:02:08.580
 9个功能可以改善

00:02:05.969 --> 00:02:10.560
应用程序本身的图形

00:02:08.580 --> 00:02:12.360
更好的文档，更好的使用

00:02:10.560 --> 00:02:14.700
在CPU操作方面的硬件

00:02:12.360 --> 00:02:16.049
更快的编译，因此即使不使用

00:02:14.700 --> 00:02:16.970
我们要讨论的任何功能

00:02:16.049 --> 00:02:19.520
关于使用

00:02:16.970 --> 00:02:21.200
 Java 9可能会加快您的速度

00:02:19.520 --> 00:02:22.820
应用程序或您的编译

00:02:21.200 --> 00:02:25.130
应用程序，所以有点有趣

00:02:22.820 --> 00:02:27.590
从那个角度来看

00:02:25.130 --> 00:02:30.290
当我们想到Java 9时，我们倾向于

00:02:27.590 --> 00:02:32.270
听说拼图，我们当然可以

00:02:30.290 --> 00:02:34.010
听到一些关于乳头J的信息

00:02:32.270 --> 00:02:36.650
稍后我们将介绍的外壳

00:02:34.010 --> 00:02:38.090
然后我们不确定是否

00:02:36.650 --> 00:02:39.860
还有其他有趣的事情

00:02:38.090 --> 00:02:40.400
在Java 9中，似乎我们已经

00:02:39.860 --> 00:02:42.050
已采取

00:02:40.400 --> 00:02:44.720
我不知道生产将近十年

00:02:42.050 --> 00:02:45.550
拼图和还有什么

00:02:44.720 --> 00:02:48.230
 Java 9 

00:02:45.550 --> 00:02:50.810
好吧，有一两件事

00:02:48.230 --> 00:02:52.730
就像我说的那样进入Java 9 

00:02:50.810 --> 00:02:53.930
很多功能不一定

00:02:52.730 --> 00:02:56.270
都归于同一个

00:02:53.930 --> 00:02:57.950
雨伞之类的东西很多

00:02:56.270 --> 00:03:00.170
他们在后端所做的

00:02:57.950 --> 00:03:03.020
他们如何改善方式的条款

00:03:00.170 --> 00:03:04.730
他们开发了JDK本身

00:03:03.020 --> 00:03:07.580
不一定是可见的东西

00:03:04.730 --> 00:03:11.450
作为开发人员给我们，但将允许我们

00:03:07.580 --> 00:03:14.090
例如获得更好的质量

00:03:11.450 --> 00:03:15.740
更快的事情，所以我们会

00:03:14.090 --> 00:03:18.770
看看其中的一些功能

00:03:15.740 --> 00:03:20.780
这个演示我们的案例研究

00:03:18.770 --> 00:03:22.130
看看我喜欢使用真实代码

00:03:20.780 --> 00:03:24.140
对于这些事情，我们可以使用

00:03:22.130 --> 00:03:26.570
代码片段（如果您喜欢，但我喜欢） 

00:03:24.140 --> 00:03:28.610
用真实的真实例子

00:03:26.570 --> 00:03:30.050
应用程序，使您对

00:03:28.610 --> 00:03:32.660
真正与之合作的感觉

00:03:30.050 --> 00:03:35.870
世界上有些人可能还记得一对

00:03:32.660 --> 00:03:38.380
几年前，我使用了Java演示

00:03:35.870 --> 00:03:41.180
 FX UI正在听Twitter 

00:03:38.380 --> 00:03:43.430
实时响应数据，然后

00:03:41.180 --> 00:03:45.680
更新以听到Java FX 

00:03:43.430 --> 00:03:47.180
实时设计的仪表板

00:03:45.680 --> 00:03:50.060
演示很多Java 8 

00:03:47.180 --> 00:03:51.650
像lambdas和streams这样的功能

00:03:50.060 --> 00:03:54.530
我想做的就是吃这个

00:03:51.650 --> 00:03:56.390
应用程序，看看会发生什么

00:03:54.530 --> 00:03:58.430
使用Java 9可能会带来的好处

00:03:56.390 --> 00:04:00.920
特别是有趣的是

00:03:58.430 --> 00:04:03.140
这是它被设计成一系列的

00:04:00.920 --> 00:04:04.610
小服务，所以其中一些可能是

00:04:03.140 --> 00:04:07.160
在诸如

00:04:04.610 --> 00:04:09.410
如果您对

00:04:07.160 --> 00:04:12.290
您可以看到的原始应用程序

00:04:09.410 --> 00:04:14.299
例如我在

00:04:12.290 --> 00:04:15.560
该网址加载了更多信息，因此我

00:04:14.299 --> 00:04:17.510
不会详细介绍

00:04:15.560 --> 00:04:21.410
因为那已经包含在

00:04:17.510 --> 00:04:23.360
上一个演示文稿，所以让我们潜入

00:04:21.410 --> 00:04:26.300
直说我们有点

00:04:23.360 --> 00:04:28.130
最害怕的是有多难

00:04:26.300 --> 00:04:30.350
拿走我现有的

00:04:28.130 --> 00:04:32.300
应用程序并针对您进行编译

00:04:30.350 --> 00:04:34.940
 9让我们直接解决

00:04:32.300 --> 00:04:38.330
现在就直接解决这个问题

00:04:34.940 --> 00:04:40.670
在我们继续之前，这是我的

00:04:38.330 --> 00:04:42.410
应用程序，这是这

00:04:40.670 --> 00:04:44.930
像我之前所做的那样申请

00:04:42.410 --> 00:04:47.740
迁移，所以如果我重建这个项目

00:04:44.930 --> 00:04:47.740
让我们看看发生了什么

00:04:58.200 --> 00:05:00.260
您

00:05:02.230 --> 00:05:05.810
首先，它要做的是

00:05:04.400 --> 00:05:08.600
一点时间建造，以便我听起来

00:05:05.810 --> 00:05:10.400
网络研讨会上非常安静

00:05:08.600 --> 00:05:13.700
建立它应该能够给我

00:05:10.400 --> 00:05:16.190
一些错误，所以第一个

00:05:13.700 --> 00:05:19.880
可能会破坏您的代码的事情，如果您

00:05:16.190 --> 00:05:22.490
这样做显然是强调

00:05:19.880 --> 00:05:24.890
在Java中是完全有效的标识符

00:05:22.490 --> 00:05:26.630
 8和岗前8我想很多人

00:05:24.890 --> 00:05:28.190
并没有真正意识到这一点，现在他们

00:05:26.630 --> 00:05:30.770
看到这个，他们认为哦，这很酷

00:05:28.190 --> 00:05:34.220
我可以用它来做各种讨厌的事

00:05:30.770 --> 00:05:37.220
小技巧，但是从Java 9开始

00:05:34.220 --> 00:05:39.110
不再是有效的标识符

00:05:37.220 --> 00:05:40.970
可能会在以后使用

00:05:39.110 --> 00:05:42.920
 Java版本，例如

00:05:40.970 --> 00:05:44.900
使lambda表达式更易于使用

00:05:42.920 --> 00:05:46.220
当然可以解决所有问题

00:05:44.900 --> 00:05:50.570
需要做的就是你只需要做一个

00:05:46.220 --> 00:05:52.130
重命名，让我们检查一下，我们去重命名，以便

00:05:50.570 --> 00:05:55.760
你想再称呼它

00:05:52.130 --> 00:05:57.620
当我使用键盘时很有用

00:05:55.760 --> 00:06:00.020
您应该使用IntelliJ IDEA的快捷方式

00:05:57.620 --> 00:06:02.360
看到它们在底部弹出

00:06:00.020 --> 00:06:03.920
演示助手，所以你当然

00:06:02.360 --> 00:06:07.400
只需将其重命名即可

00:06:03.920 --> 00:06:09.470
编译只是为了澄清

00:06:07.400 --> 00:06:11.660
下划线在内部仍然有效

00:06:09.470 --> 00:06:13.940
名称，如果您希望它们仍然有效

00:06:11.660 --> 00:06:17.210
如果需要的话，名称的前面

00:06:13.940 --> 00:06:20.120
真的很希望你仍然可以做

00:06:17.210 --> 00:06:22.280
双下划线，但这有点

00:06:20.120 --> 00:06:24.850
讨厌，所以我不建议您

00:06:22.280 --> 00:06:34.970
想称它为有用的东西

00:06:24.850 --> 00:06:36.770
重建它，看看现在发生了什么

00:06:34.970 --> 00:06:37.970
将开始看到一些错误

00:06:36.770 --> 00:06:39.590
我们被告知我们已经

00:06:37.970 --> 00:06:42.800
警告人们，因为这已经

00:06:39.590 --> 00:06:44.960
谈论Java 9的要点之一

00:06:42.800 --> 00:06:47.980
关于拼图和

00:06:44.960 --> 00:06:50.780
模块化是更好的能力

00:06:47.980 --> 00:06:52.970
更好地封装您的代码

00:06:50.780 --> 00:06:56.330
在两者之间增加保护等级

00:06:52.970 --> 00:06:57.800
打包私人和公共物品，以及

00:06:56.330 --> 00:07:01.040
即将消失的一件事是

00:06:57.800 --> 00:07:03.530
内部API位于JVM本身内部，因此

00:07:01.040 --> 00:07:04.940
任何以杂项开头的东西

00:07:03.530 --> 00:07:07.520
不应该在

00:07:04.940 --> 00:07:09.530
第一名，但我们当中有些人是

00:07:07.520 --> 00:07:12.050
我以前使用的真实代码

00:07:09.530 --> 00:07:13.790
应用程序，我正在使用此base64 

00:07:12.050 --> 00:07:14.880
编码er，因为它做了我想要的

00:07:13.790 --> 00:07:16.230
它要做，我

00:07:14.880 --> 00:07:18.360
懒得找出我应该拥有的东西

00:07:16.230 --> 00:07:19.950
一直在使用Java 8 

00:07:18.360 --> 00:07:22.080
警告您不应该使用此

00:07:19.950 --> 00:07:23.990
因为这是一个内部API 

00:07:22.080 --> 00:07:27.330
在以后的版本中将会消失

00:07:23.990 --> 00:07:29.370
所以让我们摆脱它，因为我们

00:07:27.330 --> 00:07:31.770
不想使用它，让我们

00:07:29.370 --> 00:07:33.900
用我们应该使用的替换它

00:07:31.770 --> 00:07:38.640
相反，在这种情况下，我们应该

00:07:33.900 --> 00:07:44.190
使用基本上是针对Java dot util get 

00:07:38.640 --> 00:07:46.140
编码器编码为字符串，然后

00:07:44.190 --> 00:07:50.150
都能像以前一样工作

00:07:46.140 --> 00:07:50.150
如果我重新编译

00:07:53.879 --> 00:07:59.110
我的整个项目应该编译

00:07:56.050 --> 00:08:00.699
现在正确，所以我只需要做两个

00:07:59.110 --> 00:08:03.189
尝试让我的东西很小

00:08:00.699 --> 00:08:04.599
项目编译以及两者

00:08:03.189 --> 00:08:06.069
事情会在警告您时

00:08:04.599 --> 00:08:08.349
您正在使用Java 8进行编译，您将看到

00:08:06.069 --> 00:08:10.719
无论如何都会发出警告，因此您可以迁移自己的

00:08:08.349 --> 00:08:13.719
您可以在Java 9中准备好代码

00:08:10.719 --> 00:08:15.939
仍然使用Java 8，正如我所说的

00:08:13.719 --> 00:08:18.099
像Sun杂项包一样，您不应该

00:08:15.939 --> 00:08:21.129
一直在使用那个

00:08:18.099 --> 00:08:26.289
您可能听说过Sun 

00:08:21.129 --> 00:08:28.719
不安全的杂点

00:08:26.289 --> 00:08:31.599
不一定是这样，因为

00:08:28.719 --> 00:08:34.959
所以我不是先生不安全的没有

00:08:31.599 --> 00:08:38.289
 JDK 9中的一对一替换

00:08:34.959 --> 00:08:40.449
无法删除JDK 9中的不安全原因，因为

00:08:38.289 --> 00:08:42.250
没有什么可以替换为和

00:08:40.449 --> 00:08:43.990
然后，尽管您可能不使用它

00:08:42.250 --> 00:08:46.660
您的代码一些库和框架

00:08:43.990 --> 00:08:49.029
我们正在使用它，但是您需要做什么

00:08:46.660 --> 00:08:51.040
你需要做的是，我真的是

00:08:49.029 --> 00:08:52.870
要使用不安全的设备，我知道我在做什么

00:08:51.040 --> 00:08:55.720
这就是为什么它说它在

00:08:52.870 --> 00:08:58.029
 JDK门模块不受支持，但是

00:08:55.720 --> 00:09:01.509
仍然存在，但是库和框架

00:08:58.029 --> 00:09:03.430
将不再使用它，所以

00:09:01.509 --> 00:09:05.259
现在我们的代码可以编译了

00:09:03.430 --> 00:09:09.069
不像我们那么具有挑战性

00:09:05.259 --> 00:09:11.649
以为会的，所以让我们直走

00:09:09.069 --> 00:09:15.009
到拼图上，这是大门票项目

00:09:11.649 --> 00:09:17.800
 Java 9拼图的名称实际上是

00:09:15.009 --> 00:09:19.600
一个包含一个

00:09:17.800 --> 00:09:21.339
许多不同的功能

00:09:19.600 --> 00:09:24.730
功能各不相同

00:09:21.339 --> 00:09:27.040
拼图包括破坏JDK本身

00:09:24.730 --> 00:09:30.149
分成不同的模块

00:09:27.040 --> 00:09:32.589
包括诸如

00:09:30.149 --> 00:09:33.970
封装这些内部API就是这样

00:09:32.589 --> 00:09:36.100
这样就可以将它们隐藏起来

00:09:33.970 --> 00:09:38.500
所以不仅将JDK分为

00:09:36.100 --> 00:09:42.009
模块，但也需要

00:09:38.500 --> 00:09:44.259
 Sun misc API良好的代码并将其隐藏

00:09:42.009 --> 00:09:45.610
走开，所以你看不到它了， 

00:09:44.259 --> 00:09:47.769
然后当然有模块系统

00:09:45.610 --> 00:09:52.019
本身，所以他们使用了模块系统

00:09:47.769 --> 00:09:54.370
自己来创建模块化的JDK和

00:09:52.019 --> 00:09:56.860
这也是我们要做的事情

00:09:54.370 --> 00:09:59.410
使用为了mod为了添加

00:09:56.860 --> 00:10:01.029
模块化我们自己的代码

00:09:59.410 --> 00:10:03.610
我的项目拼图下的东西是

00:10:01.029 --> 00:10:06.030
 j-link的能力是

00:10:03.610 --> 00:10:08.370
他们必须申请部署所有

00:10:06.030 --> 00:10:10.320
这整个巨大的东西，一切

00:10:08.370 --> 00:10:11.850
包括眼镜蛇和AWT等

00:10:10.320 --> 00:10:13.830
否则你不会和你的一起使用

00:10:11.850 --> 00:10:15.570
应用程序J链接将允许您

00:10:13.830 --> 00:10:19.350
拿起你想要的模块

00:10:15.570 --> 00:10:21.180
并部署较小的配置文件

00:10:19.350 --> 00:10:23.460
 Java，供您在以下位置运行应用程序

00:10:21.180 --> 00:10:25.680
这对于保持超级有用

00:10:23.460 --> 00:10:28.440
降低部署成本

00:10:25.680 --> 00:10:29.790
时代之类的东西，但主要是

00:10:28.440 --> 00:10:31.200
人们在想什么的时候

00:10:29.790 --> 00:10:33.570
谈论拼图，他们在谈论

00:10:31.200 --> 00:10:35.790
关于Java平台模块系统JP 

00:10:33.570 --> 00:10:39.060
 m / s本身，所以这就是

00:10:35.790 --> 00:10:41.940
已添加到Java中以允许我们创建

00:10:39.060 --> 00:10:44.940
我们代码本身中的模块

00:10:41.940 --> 00:10:48.210
所以我想逐步了解

00:10:44.940 --> 00:10:51.690
我以前的Java 8代码变成了Java 

00:10:48.210 --> 00:10:54.420
九个模块化代码，这是我的原始代码

00:10:51.690 --> 00:10:57.030
您可以看到我的项目结构

00:10:54.420 --> 00:11:00.450
 IntelliJ IDEA模块将这些大胆的事情

00:10:57.030 --> 00:11:03.360
是IntelliJ IDEA模块，一个为空

00:11:00.450 --> 00:11:06.380
是的，对不起

00:11:03.360 --> 00:11:10.290
似乎此屏幕共享已冻结

00:11:06.380 --> 00:11:14.880
你能检查一下你是什么吗

00:11:10.290 --> 00:11:18.660
眼下眼前不景气

00:11:14.880 --> 00:11:21.870
担心包裹不安全好吗

00:11:18.660 --> 00:11:26.640
哦那是一段时间了

00:11:21.870 --> 00:11:29.970
好的，让我，让我尝试解决该问题

00:11:26.640 --> 00:11:32.660
请稍等一下，您可以看到幻灯片吗

00:11:29.970 --> 00:11:35.550
上面写着拼图

00:11:32.660 --> 00:11:39.450
很好，这样您就不会错过

00:11:35.550 --> 00:11:41.370
那很好，我所拥有的

00:11:39.450 --> 00:11:42.450
希望你看不到我的GoToWebinar 

00:11:41.370 --> 00:11:45.900
控制面板

00:11:42.450 --> 00:11:47.700
我假设这是隐藏的，何时

00:11:45.900 --> 00:11:50.610
我当时在谈论项目拼图

00:11:47.700 --> 00:11:52.620
是不同的个体项目

00:11:50.610 --> 00:11:55.320
就像我说的那样编项目拼图

00:11:52.620 --> 00:11:59.400
模块化JDK本身并捕获

00:11:55.320 --> 00:12:02.250
大多数内部API是J链接，允许您

00:11:59.400 --> 00:12:04.680
创建一个小得多的Java版本

00:12:02.250 --> 00:12:06.750
部署和模块系统

00:12:04.680 --> 00:12:08.579
本身，所以我们要看一下

00:12:06.750 --> 00:12:11.610
模块系统本身

00:12:08.579 --> 00:12:15.449
这是包装的包装结构

00:12:11.610 --> 00:12:16.679
我以前的应用程序的

00:12:15.449 --> 00:12:19.230
是我在Java下运行它的时候

00:12:16.679 --> 00:12:21.920
八个，你会看到我有IntelliJ 

00:12:19.230 --> 00:12:25.889
我这里有一个IDEA模块仪表板

00:12:21.920 --> 00:12:27.720
我有一个服务模块

00:12:25.889 --> 00:12:29.639
可重用的基础架构代码

00:12:27.720 --> 00:12:33.689
我所有的服务都应该使用

00:12:29.639 --> 00:12:35.309
然后我拥有其他一切

00:12:33.689 --> 00:12:37.499
这对我来说很有意义

00:12:35.309 --> 00:12:39.749
创建此应用程序，但实际上

00:12:37.499 --> 00:12:41.220
事实上，这并不能使

00:12:39.749 --> 00:12:43.350
就像我想的那样，因为我

00:12:41.220 --> 00:12:45.360
实际上有三个后端服务

00:12:43.350 --> 00:12:46.980
这意味着我应该有三个

00:12:45.360 --> 00:12:49.019
这三个独立的模块

00:12:46.980 --> 00:12:51.059
如果我将它们全部放入一个

00:12:49.019 --> 00:12:53.489
他们可以依赖的单个模块

00:12:51.059 --> 00:12:56.899
彼此在代码方面，他们

00:12:53.489 --> 00:13:01.170
当我决定申请时不应该这样

00:12:56.899 --> 00:13:04.139
我现有的代码的J PMS我打破了它

00:13:01.170 --> 00:13:06.540
变成更多的

00:13:04.139 --> 00:13:08.339
模块，所以我仍然有我的UI模块

00:13:06.540 --> 00:13:10.559
仍然有我的服务模块

00:13:08.339 --> 00:13:13.529
基础结构代码我有一个新模块

00:13:10.559 --> 00:13:16.199
与我的反应式API有关的一些东西

00:13:13.529 --> 00:13:18.329
然后我有三个单独的模块

00:13:16.199 --> 00:13:21.600
为我的三个个人服务

00:13:18.329 --> 00:13:23.519
使另一件事更有意义

00:13:21.600 --> 00:13:26.249
您可能会注意到，我的每一个

00:13:23.519 --> 00:13:28.499
模块有一个模块-信息Java文件

00:13:26.249 --> 00:13:31.889
这就是我们告诉JVM的方式

00:13:28.499 --> 00:13:33.569
这将使用Java 

00:13:31.889 --> 00:13:35.459
平台模块系统

00:13:33.569 --> 00:13:37.769
这基本上是我们的模块描述符

00:13:35.459 --> 00:13:40.350
这就是我们的模块所需要的

00:13:37.769 --> 00:13:43.739
以及它暴露给其余的

00:13:40.350 --> 00:13:45.509
如果您观看演示和样本，就会发现世界

00:13:43.739 --> 00:13:47.129
还有一些您可能会看到的教程

00:13:45.509 --> 00:13:48.779
建议你有一个结构

00:13:47.129 --> 00:13:51.839
看起来像这样有一个来源

00:13:48.779 --> 00:13:54.239
在顶部，然后是一系列模块

00:13:51.839 --> 00:13:56.489
内部，然后在顶部进行测试， 

00:13:54.239 --> 00:13:59.759
里面的一系列模块

00:13:56.489 --> 00:14:01.860
打开JDK结构，我们不必

00:13:59.759 --> 00:14:03.899
这样做，我们可以使用更灰色的翠绿

00:14:01.860 --> 00:14:06.269
有一个很棒的小斜杠行家风格

00:14:03.899 --> 00:14:07.980
我们在顶部的模块

00:14:06.269 --> 00:14:09.959
包含测试中的源目录

00:14:07.980 --> 00:14:11.790
目录并不重要

00:14:09.959 --> 00:14:14.610
只要你

00:14:11.790 --> 00:14:16.709
模块信息文件位于您的源代码中

00:14:14.610 --> 00:14:19.259
目录或您所在的目录

00:14:16.709 --> 00:14:21.399
声明为您的源根目录，然后它将

00:14:19.259 --> 00:14:23.569
工作就好了

00:14:21.399 --> 00:14:26.389
让我们来看看这个模块

00:14:23.569 --> 00:14:29.750
 -信息博士Java文件是一种

00:14:26.389 --> 00:14:31.670
 Java文件名的奇数结构

00:14:29.750 --> 00:14:35.380
通常我们有骆驼案

00:14:31.670 --> 00:14:35.380
大写，并且我们没有连字符

00:14:38.170 --> 00:14:42.759
更改为正确的分支

00:15:00.490 --> 00:15:04.610
好吧，所以你可以在这里看到我所有的模块

00:15:02.899 --> 00:15:06.769
我有我的UI模块，我有我的

00:15:04.610 --> 00:15:09.019
服务模块和其他一些

00:15:06.769 --> 00:15:11.180
其中一些或已经

00:15:09.019 --> 00:15:12.769
变成了我要使用的Java 9模块

00:15:11.180 --> 00:15:16.790
经过这个过程

00:15:12.769 --> 00:15:19.699
如果我将模块流到Java 9模块

00:15:16.790 --> 00:15:22.220
在理论上建立这个

00:15:19.699 --> 00:15:24.829
一切都应该正确编译

00:15:22.220 --> 00:15:28.009
虽然我有一些Java 9模块

00:15:24.829 --> 00:15:30.699
模块信息和一些智能

00:15:28.009 --> 00:15:32.870
尚未定义模块信息的混乱

00:15:30.699 --> 00:15:36.160
一切都应该正常工作

00:15:32.870 --> 00:15:36.160
不管在一起很好

00:15:38.510 --> 00:15:44.160
这是个好消息

00:15:41.130 --> 00:15:46.260
有点担心在那里，所以我们可以

00:15:44.160 --> 00:15:50.610
使用IntelliJ创建新的模块信息

00:15:46.260 --> 00:15:53.310
 IntelliJ wolf文件将默认使用

00:15:50.610 --> 00:15:57.690
智能的名称并使用

00:15:53.310 --> 00:15:59.850
作为您的Java 9模块的名称

00:15:57.690 --> 00:16:01.950
不做任何其他事情

00:15:59.850 --> 00:16:04.530
文件，让我们重建它，看看

00:16:01.950 --> 00:16:08.570
影响来自重建项目

00:16:04.530 --> 00:16:08.570
现在我有一个模块化文件

00:16:18.030 --> 00:16:21.660
现在发生了什么

00:16:19.470 --> 00:16:23.970
编译器错误，这似乎有点

00:16:21.660 --> 00:16:27.000
之所以怪异，是因为我们有一个项目

00:16:23.970 --> 00:16:28.680
工作完全可以接受，现在

00:16:27.000 --> 00:16:30.480
我们要做的就是添加一个文件

00:16:28.680 --> 00:16:32.310
突然间事情没有编译

00:16:30.480 --> 00:16:33.990
适当，但有一个相当合理的

00:16:32.310 --> 00:16:36.750
您当然会对此进行解释

00:16:33.990 --> 00:16:41.190
期待他们，让我们回到我们的

00:16:36.750 --> 00:16:44.130
默认情况下，模块信息文件模块信息

00:16:41.190 --> 00:16:48.420
文件具有导入的概念

00:16:44.130 --> 00:16:50.250
 Java基础好，所以这说了什么

00:16:48.420 --> 00:16:52.530
 Java最基础的我可以免费使用

00:16:50.250 --> 00:16:54.330
其实我不必这么说

00:16:52.530 --> 00:16:56.220
模块信息文件，我将可以访问

00:16:54.330 --> 00:16:59.730
那是免费的，里面的东西

00:16:56.220 --> 00:17:01.590
有些东西像Java dot util Java 

00:16:59.730 --> 00:17:03.480
杨和我们喜欢的东西是

00:17:01.590 --> 00:17:05.280
一定要使用诸如字符串之类的东西

00:17:03.480 --> 00:17:06.569
所有这些真的是

00:17:05.280 --> 00:17:09.569
对于我们日常使用很重要

00:17:06.569 --> 00:17:12.209
编程，但这仅仅是

00:17:09.569 --> 00:17:14.850
我们需要的非常基本的东西

00:17:12.209 --> 00:17:16.709
 JDK，所以如果我们想使用其他任何东西

00:17:14.850 --> 00:17:18.420
比我们要说的要好

00:17:16.709 --> 00:17:20.970
包含这些内容的模块

00:17:18.420 --> 00:17:23.670
在这种情况下，我正在使用日志记录，所以我需要

00:17:20.970 --> 00:17:25.650
按顺序使用模块Java点记录

00:17:23.670 --> 00:17:28.439
为了能够使用记录仪

00:17:25.650 --> 00:17:31.890
所以我用IntelliJ快速修复

00:17:28.439 --> 00:17:34.620
如果我回到我的模块信息我

00:17:31.890 --> 00:17:38.390
获取需要Java日志记录，如果我们看

00:17:34.620 --> 00:17:38.390
在此让我们深入研究

00:17:41.059 --> 00:17:48.150
我们现在可以看到Java 9 JDK 

00:17:45.930 --> 00:17:50.550
刚分解成包装是

00:17:48.150 --> 00:17:53.610
分为模块，每个

00:17:50.550 --> 00:17:55.530
这些模块内部都有软件包，因此

00:17:53.610 --> 00:17:56.610
我们基于Javadoc的基础

00:17:55.530 --> 00:17:58.800
显然我们得到的东西

00:17:56.610 --> 00:18:00.300
默认，我只是说我也想要

00:17:58.800 --> 00:18:05.100
能够使用Javadoc日志记录

00:18:00.300 --> 00:18:07.050
使我可以访问Java util日志，因此

00:18:05.100 --> 00:18:10.140
这是一个已解决的错误，让我们去

00:18:07.050 --> 00:18:12.750
另一个错误还有另外一件事

00:18:10.140 --> 00:18:14.760
这里说对象反应流

00:18:12.750 --> 00:18:18.230
在模块反应性点中声明

00:18:14.760 --> 00:18:20.429
流，但流量不使用它，所以我

00:18:18.230 --> 00:18:22.410
外部也需要这样做

00:18:20.429 --> 00:18:24.210
图书馆显然我也只是

00:18:22.410 --> 00:18:27.480
让IntelliJ为我修复它，因为

00:18:24.210 --> 00:18:29.970
我很懒，如果我们进入

00:18:27.480 --> 00:18:32.190
现在说模块信息要求

00:18:29.970 --> 00:18:33.750
反应性点流，这似乎

00:18:32.190 --> 00:18:35.820
有点奇怪，因为问题是

00:18:33.750 --> 00:18:38.640
这是从哪里来的？ 

00:18:35.820 --> 00:18:41.220
不在JDK中，因为它没有启动

00:18:38.640 --> 00:18:43.770
与Java或Java一起开始

00:18:41.220 --> 00:18:46.410
这个模块是从哪里来的，如果我

00:18:43.770 --> 00:18:49.380
钻进去，这是一个外部罐子

00:18:46.410 --> 00:18:53.970
文件反应-流-1点0点0 

00:18:49.380 --> 00:18:56.490
 dot jar Java 9要做的是

00:18:53.970 --> 00:18:58.679
外部的jar文件会剥离任何

00:18:56.490 --> 00:19:00.600
最终版本号变成事情

00:18:58.679 --> 00:19:03.200
像连字号强调点和

00:19:00.600 --> 00:19:05.400
然后将其用作模块名称， 

00:19:03.200 --> 00:19:07.679
那就是所谓的

00:19:05.400 --> 00:19:09.870
自动模块，例如外部

00:19:07.679 --> 00:19:11.880
 jar文件就像对待它们一样

00:19:09.870 --> 00:19:13.890
是模块，即使它们不使用Java 

00:19:11.880 --> 00:19:16.470
 9即使他们没有模块- 

00:19:13.890 --> 00:19:18.780
信息文件，即使它们不是真正的

00:19:16.470 --> 00:19:20.760
模块化，它们被视为自动

00:19:18.780 --> 00:19:23.850
允许我们迁移我们的模块

00:19:20.760 --> 00:19:26.309
代码-使用Java模块系统

00:19:23.850 --> 00:19:28.990
不依赖所有人

00:19:26.309 --> 00:19:30.700
否则也做同样的事情

00:19:28.990 --> 00:19:33.130
一件不错的事情

00:19:30.700 --> 00:19:36.669
在Java 9后期引入

00:19:33.130 --> 00:19:41.440
这些模块名称需要唯一吗

00:19:36.669 --> 00:19:43.179
库开发人员可以在

00:19:41.440 --> 00:19:45.279
他们的清单，他们可以宣布什么

00:19:43.179 --> 00:19:47.710
他们的模块名称将是

00:19:45.279 --> 00:19:49.960
使用Java 9，因此可能是

00:19:47.710 --> 00:19:51.760
不是那里的Java好

00:19:49.960 --> 00:19:55.630
因为我们有时知道贾法尔的名字

00:19:51.760 --> 00:19:58.750
可以创意一些图书馆

00:19:55.630 --> 00:20:01.899
开发人员可以选择标记他们的罐子

00:19:58.750 --> 00:20:03.730
具有模块名称的文件，就是这样

00:20:01.899 --> 00:20:06.370
让我们逐渐迁移

00:20:03.730 --> 00:20:10.350
使用Java 9模块，所以现在如果我

00:20:06.370 --> 00:20:10.350
重建这个让我们看看会发生什么

00:20:20.720 --> 00:20:25.950
一切正常，但是如果发生

00:20:23.880 --> 00:20:28.770
我想使用我内部的任何代码

00:20:25.950 --> 00:20:34.140
流模块，让我们尝试从中使用它

00:20:28.770 --> 00:20:36.410
在我的用户模块中，让我们做同样的事情

00:20:34.140 --> 00:20:41.340
让我们创建我们的模块信息

00:20:36.410 --> 00:20:47.250
让我们修复我所遇到的错误

00:20:41.340 --> 00:20:55.170
只是将这些东西添加到

00:20:47.250 --> 00:20:56.970
模块信息，那么您将看到

00:20:55.170 --> 00:20:59.520
一个具有非常相似的设置

00:20:56.970 --> 00:21:02.340
我们刚创建的另一个

00:20:59.520 --> 00:21:04.320
然后这个说包裹然后停止

00:21:02.340 --> 00:21:06.480
流程在模块发送停止中声明

00:21:04.320 --> 00:21:08.760
不会将其导出到模块的流程

00:21:06.480 --> 00:21:11.520
敏感的用户，我想看看是否有

00:21:08.760 --> 00:21:14.310
快速解决这个问题

00:21:11.520 --> 00:21:15.780
这意味着我知道这在哪里

00:21:14.310 --> 00:21:17.790
包是我知道我在哪里

00:21:15.780 --> 00:21:20.100
知道它所在的模块，但是

00:21:17.790 --> 00:21:23.370
模块不允许我访问该模块

00:21:20.100 --> 00:21:26.550
类，所以你不能使用它，所以我需要

00:21:23.370 --> 00:21:29.700
我要做的是在这里说

00:21:26.550 --> 00:21:33.840
我允许人们使用的软件包，所以我

00:21:29.700 --> 00:21:35.550
要出口流量我希望人们成为

00:21:33.840 --> 00:21:38.430
能够使用我内心的一切

00:21:35.550 --> 00:21:40.830
这是我的公共API的流程包

00:21:38.430 --> 00:21:43.080
对于我的模块，请注意，如果我有一个

00:21:40.830 --> 00:21:44.910
输入包，然后我可以保留

00:21:43.080 --> 00:21:46.890
秘密和私人的，没有其他人可以

00:21:44.910 --> 00:21:49.470
在导入包中使用导入探针

00:21:46.890 --> 00:21:51.150
这也让思考感到惊讶

00:21:49.470 --> 00:21:53.190
这样人们甚至无法反省我

00:21:51.150 --> 00:21:57.660
代码他们根本无法使用

00:21:53.190 --> 00:21:59.490
还没有暴露出来，所以我可以说我出口了

00:21:57.660 --> 00:22:01.170
这个包，我什至可以更多

00:21:59.490 --> 00:22:05.940
比那具体，我可以说我

00:22:01.170 --> 00:22:11.100
将其导出到特定模块，所以我

00:22:05.940 --> 00:22:13.590
仅将其导出给用户

00:22:11.100 --> 00:22:15.090
模块可以将我的流量模块用于

00:22:13.590 --> 00:22:18.360
例如，如果这就是我想要做的

00:22:15.090 --> 00:22:21.120
如果我想让人们反思

00:22:18.360 --> 00:22:26.340
在我的代码上然后我必须打开它，所以我

00:22:21.120 --> 00:22:28.440
可以再次打开我的编辑器的包装级别

00:22:26.340 --> 00:22:30.299
我可以向所有人开放

00:22:28.440 --> 00:22:33.450
能够使用反射，或者我可以说我

00:22:30.299 --> 00:22:35.820
再次将其打开到某个模块即可

00:22:33.450 --> 00:22:38.190
反思它，这就是力量

00:22:35.820 --> 00:22:40.470
的拼图不仅可以

00:22:38.190 --> 00:22:42.240
可以将您的代码分成

00:22:40.470 --> 00:22:44.370
单个模块和单个零件

00:22:42.240 --> 00:22:46.470
但是你对什么有很多控制

00:22:44.370 --> 00:22:48.510
可见和不可见的

00:22:46.470 --> 00:22:51.809
给您明显更好的设计，但

00:22:48.510 --> 00:22:55.010
更好的安全性，所以让我们

00:22:51.809 --> 00:22:55.010
重建它，看看会发生什么

00:22:56.539 --> 00:23:02.760
让我们回到我们的用户服务

00:23:00.659 --> 00:23:04.130
我使用的服务就是

00:23:02.760 --> 00:23:11.909
说我们将使用流程

00:23:04.130 --> 00:23:13.799
模块，然后一切都会正常工作

00:23:11.909 --> 00:23:16.380
这是申请的快速介绍

00:23:13.799 --> 00:23:18.890
模块化Java 9对您的模块化

00:23:16.380 --> 00:23:22.140
现有代码，您需要模块信息

00:23:18.890 --> 00:23:24.750
文件，您需要声明哪些模块

00:23:22.140 --> 00:23:28.590
您取决于他们是否为JDK 

00:23:24.750 --> 00:23:30.960
模块是否是我们的自动模块

00:23:28.590 --> 00:23:33.419
模块，即这些外部jar文件或

00:23:30.960 --> 00:23:35.250
对于用户服务，您

00:23:33.419 --> 00:23:37.649
可能是，但您可能需要一个

00:23:35.250 --> 00:23:40.529
自己的模块，还需要

00:23:37.649 --> 00:23:44.220
能够声明您使用哪些软件包

00:23:40.529 --> 00:23:46.740
让人们看到我的情况

00:23:44.220 --> 00:23:47.970
用户服务，例如，我不让

00:23:46.740 --> 00:23:49.620
其他人在那里看到任何东西

00:23:47.970 --> 00:23:51.600
因为那只是一个独立的服务

00:23:49.620 --> 00:23:55.950
没有任何我想要的代码

00:23:51.600 --> 00:23:58.110
其他的可以稍微谈一下

00:23:55.950 --> 00:23:59.760
更复杂的例子，或者我会

00:23:58.110 --> 00:24:01.289
请稍后再说

00:23:59.760 --> 00:24:13.830
切换分支，以便我向您展示更多

00:24:01.289 --> 00:24:16.440
复杂的例子，所以稍微多一点

00:24:13.830 --> 00:24:19.440
复杂的例子是这个吗

00:24:16.440 --> 00:24:23.520
这是我的用户界面代码，所以我的用户界面代码

00:24:19.440 --> 00:24:25.770
显然我需要从

00:24:23.520 --> 00:24:28.590
 JDK本身以及我实际需要的

00:24:25.770 --> 00:24:31.049
要做的是我需要打开我的代码

00:24:28.590 --> 00:24:34.049
反射，因为FX毫升

00:24:31.049 --> 00:24:37.200
功能使用反射来

00:24:34.049 --> 00:24:40.610
基本上在我之间工作

00:24:37.200 --> 00:24:43.260
 Java类和我的FX ml类如此

00:24:40.610 --> 00:24:44.940
这是一个稍微复杂的模块

00:24:43.260 --> 00:24:46.830
但您可以在这里看到

00:24:44.940 --> 00:24:50.640
您期望的功能

00:24:46.830 --> 00:24:51.659
用于创建此特定模块

00:24:50.640 --> 00:24:54.210
信息文件

00:24:51.659 --> 00:24:57.200
我使用蛮力试验和错误使用

00:24:54.210 --> 00:25:00.480
 IntelliJ IDEA中出现的错误

00:24:57.200 --> 00:25:02.549
 IDE以及发生的运行时错误

00:25:00.480 --> 00:25:05.130
当我尝试运行事物时，我不会

00:25:02.549 --> 00:25:07.649
建议使用蛮力试用版， 

00:25:05.130 --> 00:25:08.680
创建模块信息文件时出错

00:25:07.649 --> 00:25:11.320
花了我几天

00:25:08.680 --> 00:25:13.930
即使那样，它也不是ID，也不是

00:25:11.320 --> 00:25:15.670
最好的事情是

00:25:13.930 --> 00:25:17.920
了解称为Jade的工具

00:25:15.670 --> 00:25:19.960
 EPS将使您能够进行分析

00:25:17.920 --> 00:25:22.090
您代码中的依赖项，并将

00:25:19.960 --> 00:25:25.390
告诉您正在使用的模块，以及

00:25:22.090 --> 00:25:27.400
因此，它将允许您创建

00:25:25.390 --> 00:25:31.510
该模块信息文件更容易

00:25:27.400 --> 00:25:33.010
在链接中更整洁地

00:25:31.510 --> 00:25:35.350
我将在演示文稿的末尾发布

00:25:33.010 --> 00:25:36.400
如果您有一些文档

00:25:35.350 --> 00:25:37.780
跟随那个链接，会有一些

00:25:36.400 --> 00:25:44.679
 Jade EPS之类的文档以及如何使用

00:25:37.780 --> 00:25:47.800
可以使您快速浏览

00:25:44.679 --> 00:25:52.360
如何将模块化应用于现有的Java 

00:25:47.800 --> 00:25:54.490
根据您可能会遭受的痛苦编写代码

00:25:52.360 --> 00:25:57.160
重新组织您的结构

00:25:54.490 --> 00:25:58.690
代码拼图不需要，但是您

00:25:57.160 --> 00:26:00.490
在思考时可能会发现

00:25:58.690 --> 00:26:02.410
这些模块的条款这些独立

00:26:00.490 --> 00:26:04.510
您可能想要的几段代码

00:26:02.410 --> 00:26:06.070
像我一样分离您的代码

00:26:04.510 --> 00:26:07.900
我想创建三个单独的

00:26:06.070 --> 00:26:09.580
我的三个独立服务的模块

00:26:07.900 --> 00:26:14.020
显然是结构重组

00:26:09.580 --> 00:26:15.610
的应用程序是不平凡的

00:26:14.020 --> 00:26:17.230
 IDE支持显然已经实现

00:26:15.610 --> 00:26:19.330
的最后四个或五个版本

00:26:17.230 --> 00:26:21.640
 IntelliJ IDEA已增量添加

00:26:19.330 --> 00:26:23.770
进一步支持Java 9功能

00:26:21.640 --> 00:26:26.170
一般和拼图功能

00:26:23.770 --> 00:26:28.150
但是显然这种事情需要

00:26:26.170 --> 00:26:30.190
时间，所以您不会快速解决

00:26:28.150 --> 00:26:32.170
绝对是您所做的一切

00:26:30.190 --> 00:26:34.270
看到我可以创建我的模块信息

00:26:32.170 --> 00:26:36.820
我可以快速修复的文件

00:26:34.270 --> 00:26:39.520
在其中添加所需的语句

00:26:36.820 --> 00:26:41.350
我有代码补全和

00:26:39.520 --> 00:26:43.120
突出显示的很多东西

00:26:41.350 --> 00:26:45.250
我希望能够在使用时得到

00:26:43.120 --> 00:26:49.450
在处理任何类型的Java文件时

00:26:45.250 --> 00:26:51.520
所以是的，所以它可以工作，但是不是

00:26:49.450 --> 00:26:53.470
不像你可以说要创建IntelliJ 

00:26:51.520 --> 00:26:57.070
我的模块信息，一切正常

00:26:53.470 --> 00:26:59.530
如果您要使用的话

00:26:57.070 --> 00:27:02.080
模块化确实去阅读

00:26:59.530 --> 00:27:04.420
文档去看看它是什么

00:27:02.080 --> 00:27:06.250
意味着发现了什么含义

00:27:04.420 --> 00:27:08.860
关于Jade EPS及其工作原理，因为

00:27:06.250 --> 00:27:10.510
这是对我的很大改变

00:27:08.860 --> 00:27:14.380
语言，这是为什么它的原因之一

00:27:10.510 --> 00:27:17.920
创建和发布花了很长时间

00:27:14.380 --> 00:27:19.480
 Java 9以及其他

00:27:17.920 --> 00:27:22.120
我们还没有真正的含义

00:27:19.480 --> 00:27:23.860
像拼图一样覆盖

00:27:22.120 --> 00:27:26.529
当您使用Java平台时

00:27:23.860 --> 00:27:29.320
您实际使用的模块系统

00:27:26.529 --> 00:27:32.049
模块路径不是类路径，所以

00:27:29.320 --> 00:27:33.580
您上课的路径有很大的改变

00:27:32.049 --> 00:27:35.500
只需将Java文件放在类路径中

00:27:33.580 --> 00:27:37.690
而你最终得到了一大桶

00:27:35.500 --> 00:27:40.210
在某些课程中暂停的课程

00:27:37.690 --> 00:27:41.980
任意顺序，您最终可以

00:27:40.210 --> 00:27:43.750
各种奇怪的问题

00:27:41.980 --> 00:27:46.630
在以下方面有重复的课程

00:27:43.750 --> 00:27:48.520
版本类在以下方面崩溃

00:27:46.630 --> 00:27:51.880
试图通过这个的表现

00:27:48.520 --> 00:27:54.399
课堂路径和其中的一件事

00:27:51.880 --> 00:27:55.840
拼图应该解决的是

00:27:54.399 --> 00:27:58.600
摆脱类路径并使用

00:27:55.840 --> 00:28:01.090
模块路径，在术语上要严格得多

00:27:58.600 --> 00:28:03.309
被允许依赖的东西

00:28:01.090 --> 00:28:05.140
可以对你有一些分析

00:28:03.309 --> 00:28:06.250
您是同一班的两个版本

00:28:05.140 --> 00:28:08.830
不允许这样做

00:28:06.250 --> 00:28:10.510
你有出现在

00:28:08.830 --> 00:28:11.470
不允许使用多个模块

00:28:10.510 --> 00:28:13.690
拥有

00:28:11.470 --> 00:28:15.399
你有非唯一的模块吗

00:28:13.690 --> 00:28:17.470
这些东西都是名字

00:28:15.399 --> 00:28:19.690
受限制，但这意味着您可以

00:28:17.470 --> 00:28:21.520
找到一些常见的错误，例如

00:28:19.690 --> 00:28:23.740
方法未发现问题

00:28:21.520 --> 00:28:25.419
您会发现常见错误， 

00:28:23.740 --> 00:28:28.210
导致当你开始你的

00:28:25.419 --> 00:28:30.640
申请没有一次，所以

00:28:28.210 --> 00:28:32.710
你懂的把戏会让你失败

00:28:30.640 --> 00:28:34.960
更快地给您带来错误

00:28:32.710 --> 00:28:36.580
而不是运行时错误

00:28:34.960 --> 00:28:39.039
了解这一点非常重要

00:28:36.580 --> 00:28:41.409
使用的全部含义

00:28:39.039 --> 00:28:43.149
作业模块系统，这意味着

00:28:41.409 --> 00:28:44.470
你有兴趣使用它去

00:28:43.149 --> 00:28:46.710
阅读所有文档，然后

00:28:44.470 --> 00:28:49.330
大量的精彩书籍中也有

00:28:46.710 --> 00:28:51.880
游戏显然会变得更清洁

00:28:49.330 --> 00:28:53.620
设计我的意思是我们可能会引用

00:28:51.880 --> 00:28:55.590
无论如何都可以使用模块帮助

00:28:53.620 --> 00:28:58.179
 IntelliJ想法模块显然或

00:28:55.590 --> 00:29:00.250
 Gradle或Maven创建模块化设计

00:28:58.179 --> 00:29:02.260
 OSGi有很多不同

00:29:00.250 --> 00:29:04.510
解决方案，但思考

00:29:02.260 --> 00:29:06.610
作为一流公民的模块

00:29:04.510 --> 00:29:08.409
语言的引导您进入我的

00:29:06.610 --> 00:29:10.809
体验它会使你变得更好

00:29:08.409 --> 00:29:13.029
包封更好的分离

00:29:10.809 --> 00:29:15.340
关注更好的面向对象设计

00:29:13.029 --> 00:29:18.309
这是一件可靠的好事

00:29:15.340 --> 00:29:20.110
像我说的删除配置

00:29:18.309 --> 00:29:22.120
上课的道路并走向模块

00:29:20.110 --> 00:29:24.100
路径意味着您可以得到一些

00:29:22.120 --> 00:29:26.289
这些常见错误可以使您提前

00:29:24.100 --> 00:29:27.850
这样您就可以在结束之前修复好它们

00:29:26.289 --> 00:29:28.730
在生产中肯定是一个

00:29:27.850 --> 00:29:30.980
好东西

00:29:28.730 --> 00:29:33.380
和较小的可部署项目，所以我提到

00:29:30.980 --> 00:29:35.360
当我谈论j-link时

00:29:33.380 --> 00:29:37.040
这里的意思是，现在我们在

00:29:35.360 --> 00:29:39.140
我们可以选择的模块化世界

00:29:37.040 --> 00:29:41.000
谁想部署哪些模块，我们

00:29:39.140 --> 00:29:42.950
可以将所有这些捆绑在一起

00:29:41.000 --> 00:29:45.170
我们想要的模块并将其部署到

00:29:42.950 --> 00:29:47.900
云或回答互联网的事情

00:29:45.170 --> 00:29:49.400
设备或我们想要的任何地方，我们可以

00:29:47.900 --> 00:29:50.930
在我们的足迹较小

00:29:49.400 --> 00:29:54.320
应用程序绝对是一个很好的

00:29:50.930 --> 00:29:56.240
好吧，让我们继续前进， 

00:29:54.320 --> 00:29:58.970
真的很快涵盖了反应式API 

00:29:56.240 --> 00:30:00.890
因为这现在是Java 9和我的一部分

00:29:58.970 --> 00:30:03.800
认为这是一件有趣的事情

00:30:00.890 --> 00:30:06.980
至少要注意有一个成熟的

00:30:03.800 --> 00:30:09.500
稳定的反应器物流API 

00:30:06.980 --> 00:30:12.560
在组织点反应流下，它有一个

00:30:09.500 --> 00:30:13.940
向订户发布处理器

00:30:12.560 --> 00:30:16.010
结合了出版商和

00:30:13.940 --> 00:30:17.810
订户和订阅以及此

00:30:16.010 --> 00:30:19.340
是核心的基础建筑

00:30:17.810 --> 00:30:21.680
很多反应堆

00:30:19.340 --> 00:30:25.100
库并由事物实现

00:30:21.680 --> 00:30:27.680
就像发生了很多Java顶点反应器一样

00:30:25.100 --> 00:30:30.050
常见的反应库

00:30:27.680 --> 00:30:32.120
有趣的是

00:30:30.050 --> 00:30:34.550
足够稳定并足够接受

00:30:32.120 --> 00:30:37.100
现在它已成为Java 9层的一部分

00:30:34.550 --> 00:30:39.380
 Java 9语言本身

00:30:37.100 --> 00:30:41.960
 Java dot util并发并且在

00:30:39.380 --> 00:30:45.050
流，它看起来与

00:30:41.960 --> 00:30:46.850
反应流API对

00:30:45.050 --> 00:30:49.150
注意，虽然这不完全是

00:30:46.850 --> 00:30:52.510
相同，因为它在不同的包装中

00:30:49.150 --> 00:30:54.740
它具有不同的结构，所以

00:30:52.510 --> 00:30:57.620
开箱即用的rxjava 

00:30:54.740 --> 00:31:01.580
例如不会被曝光

00:30:57.620 --> 00:31:04.670
 Java 9 Flow api，因为它正在使用

00:31:01.580 --> 00:31:06.890
组织反应流1但是您

00:31:04.670 --> 00:31:09.140
可以使用适配器在两个之间移动

00:31:06.890 --> 00:31:11.390
在此期间的两个，但我也

00:31:09.140 --> 00:31:13.370
看到了一些图书馆， 

00:31:11.390 --> 00:31:16.220
实施反应式流，例如akka和

00:31:13.370 --> 00:31:19.370
像反应堆一样，并开始移动

00:31:16.220 --> 00:31:21.080
对使用Java 9 API的想法

00:31:19.370 --> 00:31:22.880
这真的很有趣，因为它

00:31:21.080 --> 00:31:25.010
意味着反应式编程具有

00:31:22.880 --> 00:31:27.140
如果真的变得很被接受

00:31:25.010 --> 00:31:30.050
实际上是Java语言的一部分

00:31:27.140 --> 00:31:31.910
意味着这些反应性库可以

00:31:30.050 --> 00:31:34.850
用相同的方式互相交谈

00:31:31.910 --> 00:31:38.270
 API是核心jdk的一部分

00:31:34.850 --> 00:31:41.250
本身和我确实有很多例子

00:31:38.270 --> 00:31:43.530
使用它的方式及其影响

00:31:41.250 --> 00:31:45.150
应用程序的架构，但是

00:31:43.530 --> 00:31:46.890
我不会在这方面

00:31:45.150 --> 00:31:49.860
特定的演示文稿，但您可以看到

00:31:46.890 --> 00:31:51.720
该链接的副本再次位于

00:31:49.860 --> 00:31:53.820
在本演讲结束时，有一些

00:31:51.720 --> 00:31:55.500
这些东西的视频，如果你是

00:31:53.820 --> 00:31:58.560
对反应性特别感兴趣

00:31:55.500 --> 00:32:00.810
编程方面还可以

00:31:58.560 --> 00:32:01.920
意味着我们有半个小时甚至可能

00:32:00.810 --> 00:32:03.990
如果我们想花点时间

00:32:01.920 --> 00:32:05.910
其他所有问题

00:32:03.990 --> 00:32:07.770
 Java 9中的功能可能听起来不错

00:32:05.910 --> 00:32:09.960
喜欢很多时间，但是

00:32:07.770 --> 00:32:12.330
经常没有很多

00:32:09.960 --> 00:32:14.160
哦，实际上让我们

00:32:12.330 --> 00:32:15.900
现在暂停，看看是否有任何

00:32:14.160 --> 00:32:19.320
燃烧需要回答的问题

00:32:15.900 --> 00:32:23.100
在我们继续这个Andray之前，好吧

00:32:19.320 --> 00:32:25.920
打电话，所以我们有几个问题，所以

00:32:23.100 --> 00:32:28.350
第一个问题是是否有Maven支持

00:32:25.920 --> 00:32:32.430
对于使用标准Maven的模块

00:32:28.350 --> 00:32:35.970
类似于源主Java的文件夹结构

00:32:32.430 --> 00:32:37.830
所以土壤等等，所以有

00:32:35.970 --> 00:32:39.870
如果您有两个这样的问题

00:32:37.830 --> 00:32:41.520
使用经典的Maven斜杠Gradle 

00:32:39.870 --> 00:32:43.380
源主Java的结构将表明

00:32:41.520 --> 00:32:46.320
使用模块是的，我已经用过了

00:32:43.380 --> 00:32:48.810
也可以正常工作的行家

00:32:46.320 --> 00:32:50.880
 Java 9是，Maven已使用Java 9 

00:32:48.810 --> 00:32:52.500
现在已经有一段时间了

00:32:50.880 --> 00:32:55.470
绝对有效，我自己使用过， 

00:32:52.500 --> 00:33:00.390
它工作正常，Gradle也可以使用

00:32:55.470 --> 00:33:02.220
 Java 9自Gradle 4.1以来的构建

00:33:00.390 --> 00:33:04.950
系统现在正在使用Java 9 

00:33:02.220 --> 00:33:07.320
包括完全拥抱

00:33:04.950 --> 00:33:10.080
模块化，因此如果您有模块信息

00:33:07.320 --> 00:33:16.320
您可以使用Gradle或

00:33:10.080 --> 00:33:17.760
下一个问题可以用吗

00:33:16.320 --> 00:33:21.770
用于创建的新模型系统

00:33:17.760 --> 00:33:25.800
未来的Android应用程序

00:33:21.770 --> 00:33:30.900
从理论上讲，是的，但Android 

00:33:25.800 --> 00:33:32.550
仍然是Java 6，但它是androids 

00:33:30.900 --> 00:33:35.010
转移到开放的JDK，所以没有

00:33:32.550 --> 00:33:36.540
为什么不能采用所有

00:33:35.010 --> 00:33:38.760
 Java 9中即将出现的相同功能

00:33:36.540 --> 00:33:41.310
进入开放的JDK可以

00:33:38.760 --> 00:33:44.790
最终也进入了Android 

00:33:41.310 --> 00:33:45.930
是的，所以基本上我们还不知道

00:33:44.790 --> 00:33:46.470
不知道是的，但是没有理由

00:33:45.930 --> 00:33:52.050
为什么不

00:33:46.470 --> 00:33:54.240
是的，所以你打算

00:33:52.050 --> 00:33:56.280
澄清使用情况

00:33:54.240 --> 00:34:00.230
没有模块信息的库

00:33:56.280 --> 00:34:02.400
有关使用Google AdWords API的示例

00:34:00.230 --> 00:34:04.620
实际上没有太多使用图书馆

00:34:02.400 --> 00:34:07.650
所以这基本上是自动模块

00:34:04.620 --> 00:34:09.510
据我了解自动

00:34:07.650 --> 00:34:12.480
模块哦，我实际上想做什么

00:34:09.510 --> 00:34:17.790
我想展示让我展示给你吗

00:34:12.480 --> 00:34:22.740
快速的模块图和

00:34:17.790 --> 00:34:23.940
我希望IntelliJ IDEA 

00:34:22.740 --> 00:34:27.480
这将回答这个问题

00:34:23.940 --> 00:34:30.450
如果没有，我会再试一次

00:34:27.480 --> 00:34:32.820
这是模块的可视化

00:34:30.450 --> 00:34:36.570
您正在使用，所以我正在使用的是

00:34:32.820 --> 00:34:39.060
我的客户端模块我正在使用我的后端

00:34:36.570 --> 00:34:41.790
客户端模块使用的服务模块

00:34:39.060 --> 00:34:44.909
一堆JDK模块全部显示为黄色

00:34:41.790 --> 00:34:49.110
服务模块使用了很多

00:34:44.909 --> 00:34:51.630
蓝色的外部库，所以这些不是

00:34:49.110 --> 00:34:54.179
这些没有模块信息

00:34:51.630 --> 00:34:56.480
不是正确的模块，它们是自动的

00:34:54.179 --> 00:35:01.080
模块只是外部jar文件

00:34:56.480 --> 00:35:03.030
所以这行得通，关键是你的

00:35:01.080 --> 00:35:04.790
应用程序可以使用相同的

00:35:03.030 --> 00:35:07.680
之前和之前使用的jar文件

00:35:04.790 --> 00:35:09.240
假装它们是模块，即使

00:35:07.680 --> 00:35:12.660
你把自己变成了一个完全

00:35:09.240 --> 00:35:15.060
模块化项目存在一定风险

00:35:12.660 --> 00:35:17.700
围绕这个但是因为有我

00:35:15.060 --> 00:35:19.440
就像我提到Java之类的意思

00:35:17.700 --> 00:35:21.090
平台模块系统不允许您

00:35:19.440 --> 00:35:22.680
具有类似的包装

00:35:21.090 --> 00:35:25.200
有多个jar文件

00:35:22.680 --> 00:35:27.480
对您的结构方式的限制

00:35:25.200 --> 00:35:30.870
您的代码不是，不是

00:35:27.480 --> 00:35:34.050
 Java的早期版本中没有

00:35:30.870 --> 00:35:36.270
的所有早期版本的jar文件

00:35:34.050 --> 00:35:40.650
例子会很好玩

00:35:36.270 --> 00:35:42.450
与模块系统一起

00:35:40.650 --> 00:35:44.520
常见的库例如

00:35:42.450 --> 00:35:46.770
一直在阅读休眠状态很好

00:35:44.520 --> 00:35:49.710
就像我说的Maven和Gradle 

00:35:46.770 --> 00:35:51.270
春季很好，作品很好

00:35:49.710 --> 00:35:52.539
一堆很好用的东西

00:35:51.270 --> 00:35:54.880
工作，我不用你

00:35:52.539 --> 00:35:57.579
除了一些图书馆以外什么都不做

00:35:54.880 --> 00:36:00.279
可能不会，所以我想我的简短答案是

00:35:57.579 --> 00:36:03.369
如果您使用的是自动模块， 

00:36:00.279 --> 00:36:06.249
这些图表上的这些锐利的蓝色

00:36:03.369 --> 00:36:09.459
应该与Java 9正常工作

00:36:06.249 --> 00:36:12.449
设计了自动模块

00:36:09.459 --> 00:36:15.309
从Java的九个角度来看非常

00:36:12.449 --> 00:36:17.589
围绕代码的工作方式灵活

00:36:15.309 --> 00:36:19.269
因为我们了解其中的代码

00:36:17.589 --> 00:36:21.849
那些库不是Java九就绪的

00:36:19.269 --> 00:36:25.239
但您可能会发现一些图书馆

00:36:21.849 --> 00:36:26.739
表现不好，因为

00:36:25.239 --> 00:36:29.499
对他们施加的新限制

00:36:26.739 --> 00:36:31.410
 Java 9可以回答

00:36:29.499 --> 00:36:37.419
题

00:36:31.410 --> 00:36:39.489
是的，我认为接下来的问题是

00:36:37.419 --> 00:36:42.819
我们可以找到所有不受支持的软件包吗

00:36:39.489 --> 00:36:45.189
就像你一样，你正在展示

00:36:42.819 --> 00:36:47.919
警告关于不安全的想法

00:36:45.189 --> 00:36:50.709
包导入语句，以便您使用此

00:36:47.919 --> 00:36:53.109
我叫Jade EPS的工具

00:36:50.709 --> 00:36:55.539
有很多时间来解决它，但是

00:36:53.109 --> 00:36:59.669
让我们来看看Jade F Sharp 

00:36:55.539 --> 00:36:59.669
九和

00:37:01.290 --> 00:37:07.350
实际上，Oracle博客做得很好

00:37:04.110 --> 00:37:09.090
无论如何，这是在

00:37:07.350 --> 00:37:11.280
那里有一个教程的链接

00:37:09.090 --> 00:37:13.890
但是如果我看参考

00:37:11.280 --> 00:37:15.890
 Java 8和Java中的文档

00:37:13.890 --> 00:37:22.910
晚

00:37:15.890 --> 00:37:22.910
那不是你的杰伊德夫我们在那里

00:37:23.630 --> 00:37:29.370
在结尾处有一个与此相关的链接

00:37:26.310 --> 00:37:31.440
无论如何，所以你要做的是

00:37:29.370 --> 00:37:33.780
可以做很多不同的事情

00:37:31.440 --> 00:37:35.760
在Java 8中对Java使用Jade EPS 

00:37:33.780 --> 00:37:37.380
 8个代码，它将告诉您它将警告

00:37:35.760 --> 00:37:39.330
关于您所依赖的任何内容

00:37:37.380 --> 00:37:41.820
不应该像Sun磁盘那样使用

00:37:39.330 --> 00:37:44.100
您可以在Java 9代码中使用Jade EPS 

00:37:41.820 --> 00:37:46.800
看看你的模块依赖是什么

00:37:44.100 --> 00:37:48.510
帮助您建立模块信息，以便

00:37:46.800 --> 00:37:49.830
值得了解什么

00:37:48.510 --> 00:37:51.750
该工具会这样做，因为它将使您

00:37:49.830 --> 00:37:54.330
如果您能理解，生活就会轻松很多

00:37:51.750 --> 00:37:55.740
如何使用它是不平凡的

00:37:54.330 --> 00:38:00.750
使用它，但有很多

00:37:55.740 --> 00:38:06.210
如何在那里使用它的例子好

00:38:00.750 --> 00:38:10.320
很酷，那么模块需要命名

00:38:06.210 --> 00:38:13.770
与不需要的包名称相同

00:38:10.320 --> 00:38:16.290
的建议是，它将

00:38:13.770 --> 00:38:18.510
按照反向DNS与软件包相同

00:38:16.290 --> 00:38:19.440
名字也就是建议

00:38:18.510 --> 00:38:21.180
不必被称为同一件事

00:38:19.440 --> 00:38:24.660
作为包装，但可以称为

00:38:21.180 --> 00:38:26.550
和你的神器一样

00:38:24.660 --> 00:38:28.410
如果您喜欢，您可以看到这并不

00:38:26.550 --> 00:38:32.070
适用于自动模块，因为它们

00:38:28.410 --> 00:38:35.190
使用的是jar文件名，但是

00:38:32.070 --> 00:38:37.740
建议一直使用反向DNS 

00:38:35.190 --> 00:38:41.670
您的包裹名称，我认为这

00:38:37.740 --> 00:38:42.930
是为了帮助您创建一个独特的模块

00:38:41.670 --> 00:38:44.990
名字

00:38:42.930 --> 00:38:44.990
您

00:38:45.569 --> 00:38:52.960
好的，所以我们继续讨论问题

00:38:49.259 --> 00:38:55.720
在Java 9中利用拼图是

00:38:52.960 --> 00:39:01.299
它建议要求该软件包

00:38:55.720 --> 00:39:02.589
包含在单个模块上

00:39:01.299 --> 00:39:08.049
你对不起

00:39:02.589 --> 00:39:11.390
是的拼图模块，是否需要

00:39:08.049 --> 00:39:12.800
包在一个模块中

00:39:11.390 --> 00:39:18.950
不太明白这个问题

00:39:12.800 --> 00:39:22.880
对不起，但也许我们可以发表评论

00:39:18.950 --> 00:39:24.890
在一个模块中您可能拥有的

00:39:22.880 --> 00:39:28.250
几个包，只有一个

00:39:24.890 --> 00:39:30.860
约束权利，例如我的

00:39:28.250 --> 00:39:33.260
客户端模块具有多个软件包，并且

00:39:30.860 --> 00:39:36.800
我可以选择少曝光或少曝光

00:39:33.260 --> 00:39:39.140
许多我想要的情绪模块

00:39:36.800 --> 00:39:43.400
只有一个被感知的包裹

00:39:39.140 --> 00:39:45.890
心情，我可以再次选择暴露为

00:39:43.400 --> 00:39:48.680
我想要的只有很少的我不能做的是

00:39:45.890 --> 00:39:51.530
我不能在流程中说

00:39:48.680 --> 00:39:53.660
模块我不能有一个叫做

00:39:51.530 --> 00:39:56.510
感觉最好的心情，因为感觉到那种心情

00:39:53.660 --> 00:40:02.000
在我的心情中，所以我可以拥有更多

00:39:56.510 --> 00:40:04.360
我的模块中的一个包裹

00:40:02.000 --> 00:40:07.460
案例看，我实际上只导出一个我

00:40:04.360 --> 00:40:09.620
导出我不导出的客户程序包

00:40:07.460 --> 00:40:11.810
我的任何内部软件包，但我可以

00:40:09.620 --> 00:40:13.400
有内部包装，我可以

00:40:11.810 --> 00:40:17.600
选择暴露一个或多个

00:40:13.400 --> 00:40:19.340
他们，我可以让Erica有模块

00:40:17.600 --> 00:40:21.670
只是其中之一

00:40:19.340 --> 00:40:21.670
包

00:40:22.960 --> 00:40:31.070
好吧，那是正确的

00:40:28.490 --> 00:40:35.270
我必须输入两次包装的模块

00:40:31.070 --> 00:40:39.650
一旦模块需要部分名称

00:40:35.270 --> 00:40:42.410
其他作为进口有效一部分

00:40:39.650 --> 00:40:44.060
所以让我们来看一下

00:40:42.410 --> 00:40:45.590
例如仪表板我仍然拥有所有

00:40:44.060 --> 00:40:47.990
我没有改变的标准进口

00:40:45.590 --> 00:40:50.570
任何一个，我都有进口，我

00:40:47.990 --> 00:40:52.190
宁愿将我的进口商品作为个人使用

00:40:50.570 --> 00:40:54.560
我没有将其分组的课程

00:40:52.190 --> 00:40:58.070
水平，然后我当然也必须

00:40:54.560 --> 00:41:00.920
说出我需要JavaFX的模块信息

00:40:58.070 --> 00:41:04.280
库存控件的X点FF XML罐

00:41:00.920 --> 00:41:05.660
这样的例子很有效，但是是的

00:41:04.280 --> 00:41:07.280
键入两次，但如您所知

00:41:05.660 --> 00:41:11.780
 IntelliJ意味着您不必做

00:41:07.280 --> 00:41:14.270
一次又一次的打字

00:41:11.780 --> 00:41:15.920
重要的是要了解这里

00:41:14.270 --> 00:41:20.630
再次转到仪表板，我们正在谈论

00:41:15.920 --> 00:41:24.800
关于将JavaFX打包为F XML JavaFX到

00:41:20.630 --> 00:41:27.890
应用程序JavaFX Docs的场景，但是

00:41:24.800 --> 00:41:30.310
在这里，我们正在谈论模块和

00:41:27.890 --> 00:41:32.420
模块实际上有多个

00:41:30.310 --> 00:41:35.960
包装，所以如果我们看看这个

00:41:32.420 --> 00:41:40.700
例如有效果

00:41:35.960 --> 00:41:43.660
控制好哦，刚刚在

00:41:40.700 --> 00:41:43.660
然后让我们看一下基础

00:41:50.210 --> 00:41:56.390
具有JavaFX Doc Bienstock集合以

00:41:53.810 --> 00:41:59.150
事件直到你，所以我只需要

00:41:56.390 --> 00:42:01.849
在我的模块信息中包括我只需要

00:41:59.150 --> 00:42:03.619
包括模块级别，然后在我的

00:42:01.849 --> 00:42:15.730
仪表板，我必须包括包装

00:42:03.619 --> 00:42:19.970
一如既往地保持水平

00:42:15.730 --> 00:42:23.930
下一个问题，如果有两个

00:42:19.970 --> 00:42:26.599
软件包java.lang阻塞了java.util 

00:42:23.930 --> 00:42:30.080
记录我怎么知道我哪一个

00:42:26.599 --> 00:42:38.330
通过按要求登录Java 

00:42:30.080 --> 00:42:42.460
模块信息Java，因此，如果您使用的是Java 

00:42:38.330 --> 00:42:45.589
日志让我们看一看

00:42:42.460 --> 00:42:47.869
仅包含Java点util点记录

00:42:45.589 --> 00:42:51.609
所以里面只有一个包裹

00:42:47.869 --> 00:42:54.220
我假设太阳在那里

00:42:51.609 --> 00:42:57.740
我们应该关注的内部内容

00:42:54.220 --> 00:43:00.770
所以如果我使用Java dot util dot 

00:42:57.740 --> 00:43:04.070
记录然后我需要Java点

00:43:00.770 --> 00:43:06.859
记录模块，所以如果还有另一个

00:43:04.070 --> 00:43:08.900
如果有

00:43:06.859 --> 00:43:10.849
另一个日志，如log4j然后我

00:43:08.900 --> 00:43:12.380
不会使用Java日志记录

00:43:10.849 --> 00:43:18.470
使用博客的约翰模块

00:43:12.380 --> 00:43:19.849
相反，好吧，所以已经有一些

00:43:18.470 --> 00:43:22.820
人们抱怨太多

00:43:19.849 --> 00:43:25.400
问题，让我知道你是否愿意

00:43:22.820 --> 00:43:27.710
要知道，然后如果是的话

00:43:25.400 --> 00:43:31.670
可能我们会尝试解决问题

00:43:27.710 --> 00:43:33.410
与后续电子邮件是的，让我们做

00:43:31.670 --> 00:43:36.530
让我们做一个博客文章

00:43:33.410 --> 00:43:39.740
问题，所以我们只有15分钟

00:43:36.530 --> 00:43:42.080
离开所以继续问问题

00:43:39.740 --> 00:43:43.609
通过GoToWebinar 

00:43:42.080 --> 00:43:44.960
如果我们没有时间去

00:43:43.609 --> 00:43:46.280
问题，我们将在博客上回答

00:43:44.960 --> 00:43:49.820
因为这些问题很多

00:43:46.280 --> 00:43:51.470
真的很好的问题很酷谢谢大家

00:43:49.820 --> 00:43:53.200
好的，让我们继续其他一切

00:43:51.470 --> 00:43:55.030
在Chavan I 

00:43:53.200 --> 00:43:56.890
便利工厂方法

00:43:55.030 --> 00:43:59.829
收藏这是我最喜欢的功能

00:43:56.890 --> 00:44:01.150
 Java 9的代码，Mike可能看起来像

00:43:59.829 --> 00:44:02.799
像一个非常愚蠢的东西，但它确实

00:44:01.150 --> 00:44:04.540
使生活变得更加轻松，而我

00:44:02.799 --> 00:44:06.400
认为这是开发商

00:44:04.540 --> 00:44:16.089
将一直使用，让我们

00:44:06.400 --> 00:44:18.730
看看这是怎么回事

00:44:16.089 --> 00:44:20.980
我们会在很多代码中找到什么

00:44:18.730 --> 00:44:22.540
当我们试图创建一个

00:44:20.980 --> 00:44:24.040
静态列表，我们可能会将其用于

00:44:22.540 --> 00:44:26.559
测试我们可能正在使用的产品

00:44:24.040 --> 00:44:28.750
数据，因为我们可能使用数组作为列表

00:44:26.559 --> 00:44:30.730
和数组作为列表给我们一个数组

00:44:28.750 --> 00:44:33.849
我们给我们一个清单，我们不能

00:44:30.730 --> 00:44:35.500
增加价值，但我们并非总是如此

00:44:33.849 --> 00:44:37.059
意识到你实际上仍然可以

00:44:35.500 --> 00:44:38.710
如果您想更改这些值

00:44:37.059 --> 00:44:41.230
可能我们想要的是

00:44:38.710 --> 00:44:47.349
不可修改的列表，但数组为

00:44:41.230 --> 00:44:49.839
我可以说列表得到一个然后设置

00:44:47.349 --> 00:44:51.520
通常不同

00:44:49.839 --> 00:44:54.520
我们真正想要的是

00:44:51.520 --> 00:44:55.930
无法修改的清单，但我们倾向于不这样做

00:44:54.520 --> 00:44:59.530
那是因为那很多

00:44:55.930 --> 00:45:02.020
键入，但在Java 9中，如您所见

00:44:59.530 --> 00:45:04.109
 IntelliJ告诉我我可以用这个

00:45:02.020 --> 00:45:08.140
现在可以替换为更小的

00:45:04.109 --> 00:45:10.390
核心全部可以替换为

00:45:08.140 --> 00:45:13.270
的列表，这给了我一个不变的东西

00:45:10.390 --> 00:45:16.569
列出，因此不仅种类不附加值

00:45:13.270 --> 00:45:18.549
对此我也无法更改任何内容

00:45:16.569 --> 00:45:20.049
实施与

00:45:18.549 --> 00:45:21.730
不可修改的清单，但

00:45:20.049 --> 00:45:23.980
含义是相同的，它给了我一个

00:45:21.730 --> 00:45:25.630
列出我对此无能为力

00:45:23.980 --> 00:45:27.549
很好，因为这意味着我们有控制权

00:45:25.630 --> 00:45:30.369
对我们的数据也很好，因为

00:45:27.549 --> 00:45:32.890
 JVM可以更容易地进行推理

00:45:30.369 --> 00:45:36.490
并可能进行优化，这是

00:45:32.890 --> 00:45:38.410
就列表而言，这很有用

00:45:36.490 --> 00:45:41.790
这真的很有用

00:45:38.410 --> 00:45:41.790
例如其他数据结构

00:45:42.309 --> 00:45:49.489
现在的游戏机从未真正拥有过

00:45:46.579 --> 00:45:51.739
创建集合的好方法，所以我必须

00:45:49.489 --> 00:45:53.209
我想放入设定中的值

00:45:51.739 --> 00:45:56.059
我必须把这一切都给

00:45:53.209 --> 00:45:58.009
样板只是为了创建那个我

00:45:56.059 --> 00:45:59.630
必须将其转换为清单

00:45:58.009 --> 00:46:03.729
放入哈希集以及如何将其包装

00:45:59.630 --> 00:46:07.309
不可修改的集，或者我可以使用

00:46:03.729 --> 00:46:09.440
这一套会容易得多

00:46:07.309 --> 00:46:11.180
对我们来说这可能有助于我们开始使用

00:46:09.440 --> 00:46:12.829
正确的数据结构

00:46:11.180 --> 00:46:14.180
事情，因为我们经常使用列表

00:46:12.829 --> 00:46:16.609
因为这只是最简单的事情

00:46:14.180 --> 00:46:19.039
创建，所以我认为这超级有用

00:46:16.609 --> 00:46:25.219
你也可以做同样的事情

00:46:19.039 --> 00:46:27.890
地图上也有类似的东西，所以这段代码

00:46:25.219 --> 00:46:29.779
再次是我在我的真实编码之夜

00:46:27.890 --> 00:46:33.440
我确实需要创建的应用程序

00:46:29.779 --> 00:46:35.869
映射字符串的静态映射

00:46:33.440 --> 00:46:38.150
某种情绪的价值

00:46:35.869 --> 00:46:41.089
某种类型的，我必须把它放进去

00:46:38.150 --> 00:46:42.739
静态的外观，有点丑陋， 

00:46:41.089 --> 00:46:44.930
我从未对此感到非常高兴，但

00:46:42.739 --> 00:46:50.119
那是您在Java中所做的，除了

00:46:44.930 --> 00:46:52.549
现在您可以说地图或我可以输入的条目

00:46:50.119 --> 00:46:58.459
使用我最喜欢的IntelliJ功能

00:46:52.549 --> 00:47:04.029
是列选择模式，让我们把它

00:46:58.459 --> 00:47:06.680
在这里，我们说我们使用的地图条目

00:47:04.029 --> 00:47:10.849
 IntelliJ是最常用的功能

00:47:06.680 --> 00:47:13.089
是查找并替换让我们替换所有

00:47:10.849 --> 00:47:13.089
那些

00:47:15.190 --> 00:47:26.330
摆脱列选择，现在我们有了

00:47:22.970 --> 00:47:29.990
我们的带有字符串到情绪的条目映射

00:47:26.330 --> 00:47:32.060
少了一些样板，我们摆脱了

00:47:29.990 --> 00:47:32.420
在这里我们讨厌的静态块

00:47:32.060 --> 00:47:35.900
大

00:47:32.420 --> 00:47:38.510
显然，如果我们使用静态导入

00:47:35.900 --> 00:47:42.980
我们可以使它更加整洁

00:47:38.510 --> 00:47:44.870
所以让我们做到这一点，那就是相当

00:47:42.980 --> 00:47:47.270
很好，这是对什么的很大改进

00:47:44.870 --> 00:47:50.930
我们曾经有过更好的选择是

00:47:47.270 --> 00:47:53.890
我们可以完成的条目少于十个

00:47:50.930 --> 00:48:02.960
我们可以说更简单的地图

00:47:53.890 --> 00:48:12.020
然后我们可以摆脱它，我们可以

00:48:02.960 --> 00:48:17.300
摆脱这个，我们可以有一个

00:48:12.020 --> 00:48:26.660
编译错误我做错了什么

00:48:17.300 --> 00:48:28.850
我有太多，是的，我有太多

00:48:26.660 --> 00:48:30.890
你必须至少有一个

00:48:28.850 --> 00:48:33.290
然后最多可以这样做十个

00:48:30.890 --> 00:48:35.930
我要做的就是放关键值

00:48:33.290 --> 00:48:37.130
在这里将键值对值配对

00:48:35.930 --> 00:48:38.960
我刚刚摆脱了很多

00:48:37.130 --> 00:48:40.940
样板，这真的可以

00:48:38.960 --> 00:48:42.200
特别适用于测试数据，但

00:48:40.940 --> 00:48:45.620
在生产中可能真的有用

00:48:42.200 --> 00:48:48.500
代码也很明显，您会得到编译器

00:48:45.620 --> 00:48:51.590
错误，如果您不填写

00:48:48.500 --> 00:48:54.650
右键键值键值组合吗

00:48:51.590 --> 00:48:57.950
如果您的身体变得蓬松一点

00:48:54.650 --> 00:48:59.540
键和值是相同的类型

00:48:57.950 --> 00:49:02.000
的情况下，我建议可能使用

00:48:59.540 --> 00:49:03.860
条目版本的，因此您可以进行分组

00:49:02.000 --> 00:49:06.290
一起将您的钥匙变成您的价值，以便

00:49:03.860 --> 00:49:08.870
你知道你没有你没有

00:49:06.290 --> 00:49:11.000
不小心做了我不知道的事

00:49:08.870 --> 00:49:12.850
像这样，其中之一是

00:49:11.000 --> 00:49:14.810
应该是一个瑞士人的关键

00:49:12.850 --> 00:49:16.910
所以

00:49:14.810 --> 00:49:19.250
这将使我们的代码很多

00:49:16.910 --> 00:49:22.970
更好，不如说的好

00:49:19.250 --> 00:49:24.020
以一种时髦的方式，但是

00:49:22.970 --> 00:49:25.730
绝对是朝正确方向迈出的一步

00:49:24.020 --> 00:49:29.150
我认为这将使我们的代码成为

00:49:25.730 --> 00:49:30.290
以后我要轻松得多

00:49:29.150 --> 00:49:35.090
滚回去，所以我不明白我的意思

00:49:30.290 --> 00:49:37.520
编译器错误，是的，这很方便

00:49:35.090 --> 00:49:39.200
我只是我的工厂收集方法

00:49:37.520 --> 00:49:41.840
真的很想通过这些

00:49:39.200 --> 00:49:43.100
尽可能快，所以我会尝试展示

00:49:41.840 --> 00:49:45.290
他们尽快

00:49:43.100 --> 00:49:47.510
私有方法和接口

00:49:45.290 --> 00:49:49.100
可能看起来很傻，因为您的

00:49:47.510 --> 00:49:50.960
接口应该是您的公共

00:49:49.100 --> 00:49:53.390
 API，为什么要放一个

00:49:50.960 --> 00:49:58.250
我的公共API上的私有方法

00:49:53.390 --> 00:50:01.250
将以Java八个界面向您展示

00:49:58.250 --> 00:50:03.170
在Java 8中拥有神奇的超能力

00:50:01.250 --> 00:50:05.900
现在可以有静态方法和默认值

00:50:03.170 --> 00:50:07.700
方法，所以接口上的方法

00:50:05.900 --> 00:50:10.550
可能实际上有行为而没有

00:50:07.700 --> 00:50:11.960
只是他们对您API的定义

00:50:10.550 --> 00:50:13.520
表示您可以在这种情况下结束

00:50:11.960 --> 00:50:16.010
我之间有重复的代码

00:50:13.520 --> 00:50:17.630
这两种方法我真的做不到

00:50:16.010 --> 00:50:19.670
关于那件事，因为如果我提取

00:50:17.630 --> 00:50:25.180
把它变成自己的方法，我们称之为

00:50:19.670 --> 00:50:25.180
获得领域的价值，我们称之为

00:50:25.390 --> 00:50:28.660
栏位名称

00:50:30.619 --> 00:50:35.960
然后我有一个新的

00:50:32.769 --> 00:50:39.109
我接口上的公共方法是

00:50:35.960 --> 00:50:41.210
不是我想要的是

00:50:39.109 --> 00:50:44.480
在这两个之间共享代码

00:50:41.210 --> 00:50:47.029
事情实际上没有暴露

00:50:44.480 --> 00:50:49.789
现在在Java 9中将其提供给最终用户

00:50:47.029 --> 00:50:52.849
就像现在私有方法一样简单

00:50:49.789 --> 00:50:54.200
所以Java 9有很多这些小功能

00:50:52.849 --> 00:50:55.730
即将制作的功能

00:50:54.200 --> 00:50:57.170
生活对我们来说稍微容易一些

00:50:55.730 --> 00:50:58.819
开发人员可能会做的事情

00:50:57.170 --> 00:51:01.039
想放入较早的版本

00:50:58.819 --> 00:51:06.559
 Java，但没有时间做

00:51:01.039 --> 00:51:07.579
再次在流API上使用新方法

00:51:06.559 --> 00:51:09.680
这本来是

00:51:07.579 --> 00:51:13.809
在Java 8中很不错，但是很高兴

00:51:09.680 --> 00:51:15.650
在Java 9中获取它让我们看一下哦

00:51:13.809 --> 00:51:17.180
当我们在这里，让我们来看看

00:51:15.650 --> 00:51:19.549
你可以做的一件事情

00:51:17.180 --> 00:51:22.549
现在就可以使用了

00:51:19.549 --> 00:51:24.440
尝试有效的最终值或最终值

00:51:22.549 --> 00:51:26.210
有你可能没有的资源

00:51:24.440 --> 00:51:28.430
意识到您可以做到这一点，但是

00:51:26.210 --> 00:51:30.880
您现在可以在Java 9中进行操作了

00:51:28.430 --> 00:51:34.039
只是一个很小的改进，这是非常好的

00:51:30.880 --> 00:51:35.720
现在，Java 8流使您可以工作

00:51:34.039 --> 00:51:37.970
与无限的流，这很酷

00:51:35.720 --> 00:51:39.680
在理论上很棒，很棒

00:51:37.970 --> 00:51:42.769
除了如果您正在使用

00:51:39.680 --> 00:51:44.660
 Java 8中的真正无限流是

00:51:42.769 --> 00:51:46.309
实际上很难终止

00:51:44.660 --> 00:51:49.309
那无限的溪流，除非你把

00:51:46.309 --> 00:51:52.880
限制或其中之一

00:51:49.309 --> 00:51:55.640
终止Java 8中的功能

00:51:52.880 --> 00:51:58.069
 Java 9现在流

00:51:55.640 --> 00:52:00.410
现在一点点容易什么这段代码

00:51:58.069 --> 00:52:02.299
它是从一个读取所有行吗

00:52:00.410 --> 00:52:05.200
文件，因此文件包含Twitter 

00:52:02.299 --> 00:52:08.869
信息，这给了我一个信息流

00:52:05.200 --> 00:52:11.029
其中每个值每个字符串每个值

00:52:08.869 --> 00:52:13.640
流中是文件中的一行

00:52:11.029 --> 00:52:16.730
我可能想做的不是

00:52:13.640 --> 00:52:18.410
无限，直到你，它不会停止

00:52:16.730 --> 00:52:24.499
到达我可能想要的文件末尾

00:52:18.410 --> 00:52:27.920
说拿，而说s不是

00:52:24.499 --> 00:52:29.779
等于一些价值，假设有

00:52:27.920 --> 00:52:33.140
那里有一些秘密的超级大国

00:52:29.779 --> 00:52:36.259
说我已经到达文件末尾，所以

00:52:33.140 --> 00:52:39.609
让我们处理此流，直到您点击

00:52:36.259 --> 00:52:41.839
一些值，或者假设这个文件

00:52:39.609 --> 00:52:42.890
我们假设其中的字符串

00:52:41.839 --> 00:52:45.380
文件

00:52:42.890 --> 00:52:47.180
有一个数字，他们被订购以便

00:52:45.380 --> 00:52:49.760
例如你有一个一二三四

00:52:47.180 --> 00:52:52.120
你有一百个开始一二十

00:52:49.760 --> 00:52:58.700
从两个开始，所以我可能想说

00:52:52.120 --> 00:53:01.340
处理此流，而s不处理

00:52:58.700 --> 00:53:04.070
首先我不知道说多少

00:53:01.340 --> 00:53:05.630
三个，所以我想处理一切

00:53:04.070 --> 00:53:07.640
从一切开始

00:53:05.630 --> 00:53:10.190
从两个开始，然后在我得到时停止

00:53:07.640 --> 00:53:12.140
以三个开始的东西

00:53:10.190 --> 00:53:14.390
反面这是另一种方法

00:53:12.140 --> 00:53:17.180
叫滴而我可以

00:53:14.390 --> 00:53:18.890
在某种程度上忽略一切

00:53:17.180 --> 00:53:24.830
可能想忽略一切

00:53:18.890 --> 00:53:26.900
例如以一个开始，所以忽略

00:53:24.830 --> 00:53:29.960
一切始于一个过程

00:53:26.900 --> 00:53:31.130
接下来的很多东西，然后停下来

00:53:29.960 --> 00:53:34.370
您会发现始于三点的东西

00:53:31.130 --> 00:53:35.420
例如，有很多

00:53:34.370 --> 00:53:37.280
不同的使用方式，但是

00:53:35.420 --> 00:53:39.470
基本上需要片刻，而片刻

00:53:37.280 --> 00:53:41.960
允许您处理无限

00:53:39.470 --> 00:53:43.820
无限流，直到某个值是

00:53:41.960 --> 00:53:47.420
到达，所以我可能想说

00:53:43.820 --> 00:53:53.360
跑步时是真的，我可以创造

00:53:47.420 --> 00:53:56.630
字段运行为真，然后停止

00:53:53.360 --> 00:54:00.980
被称为我可以说等于

00:53:56.630 --> 00:54:02.900
错误，因此在处理流的同时

00:54:00.980 --> 00:54:04.310
你当然在现实生活中奔跑

00:54:02.900 --> 00:54:07.310
应该有一个原子布尔而不是

00:54:04.310 --> 00:54:09.230
布尔值等，但这是另一个

00:54:07.310 --> 00:54:10.820
你现在可以做的事情无限流

00:54:09.230 --> 00:54:14.590
在Java 9中更加可控

00:54:10.820 --> 00:54:14.590
用一会儿而一会儿

00:54:15.400 --> 00:54:19.370
同样，有新方法

00:54:17.180 --> 00:54:20.990
可选，这使得可选一些

00:54:19.370 --> 00:54:22.520
也会更容易使用，所以如果

00:54:20.990 --> 00:54:24.110
您已经在阅读IntelliJ 

00:54:22.520 --> 00:54:26.240
博客，您会发现我在努力

00:54:24.110 --> 00:54:28.760
一点如何使可选

00:54:26.240 --> 00:54:30.680
在旧版代码中有效，因为

00:54:28.760 --> 00:54:32.420
旧代码，我们用空值填充

00:54:30.680 --> 00:54:34.910
我们可能永远不应该做

00:54:32.420 --> 00:54:36.920
首先，这很容易，所以我们

00:54:34.910 --> 00:54:43.330
做到了，所以让我们来看看

00:54:36.920 --> 00:54:46.260
一些可选的例子

00:54:43.330 --> 00:54:49.000
如果您一直在Java 8中使用可选

00:54:46.260 --> 00:54:51.360
您会知道我们将其提取出来，所以我们

00:54:49.000 --> 00:54:54.730
可以看一下，我们将此称为可选

00:54:51.360 --> 00:54:56.350
如果您一直在Java 8中使用可选

00:54:54.730 --> 00:55:01.450
你会知道你可以做类似的事情

00:54:56.350 --> 00:55:05.970
我想说我想要的价值

00:55:01.450 --> 00:55:08.550
可选或其他一些默认值或

00:55:05.970 --> 00:55:11.920
去这种方法，给我一些

00:55:08.550 --> 00:55:14.800
默认值，或者您可以说否则

00:55:11.920 --> 00:55:17.110
抛出异常，例如那些是

00:55:14.800 --> 00:55:19.210
你的三个主要方面是什么

00:55:17.110 --> 00:55:21.400
他们做的是，他们将打开可选的

00:55:19.210 --> 00:55:24.010
并在此返回一个心情对象

00:55:21.400 --> 00:55:27.190
这种情况是Java模式的可选

00:55:24.010 --> 00:55:30.160
 9你可以说或者你会说

00:55:27.190 --> 00:55:33.730
返回给您一种可选的心情，而不是

00:55:30.160 --> 00:55:38.490
解开情绪，让我说出

00:55:33.730 --> 00:55:48.610
你一个这样的例子

00:55:38.490 --> 00:55:49.960
我将输入另一个可选值

00:55:48.610 --> 00:55:53.620
那里的结构，所以你可以看到

00:55:49.960 --> 00:55:55.150
看看这种情况有什么意义

00:55:53.620 --> 00:55:57.160
如果您有两种方法可以

00:55:55.150 --> 00:56:00.070
返回可选值，所以第一个

00:55:57.160 --> 00:56:03.010
如果可选值最终被

00:56:00.070 --> 00:56:04.960
空去另一种方法来获得

00:56:03.010 --> 00:56:06.340
另一个可选值，然后

00:56:04.960 --> 00:56:08.320
当然你可以进行链接

00:56:06.340 --> 00:56:10.150
并做其他你想做的事

00:56:08.320 --> 00:56:12.040
做一个可选的，所以它不只是

00:56:10.150 --> 00:56:13.570
以解包后的可选内容终止，因此

00:56:12.040 --> 00:56:14.980
这对于某些人可能非常有用

00:56:13.570 --> 00:56:19.080
我一直在寻找的用例

00:56:14.980 --> 00:56:22.390
在，另一种新方法是

00:56:19.080 --> 00:56:24.160
以前很好，所以天真的方法

00:56:22.390 --> 00:56:29.190
使用可选的让我们来看看

00:56:24.160 --> 00:56:33.850
我们说这是可选的

00:56:29.190 --> 00:56:43.090
让我们说做一些可选的事情

00:56:33.850 --> 00:56:45.820
让我们创建该方法，这是

00:56:43.090 --> 00:56:47.290
最初的方式

00:56:45.820 --> 00:56:48.610
如果可选是，则开始使用可选

00:56:47.290 --> 00:56:51.160
然后用

00:56:48.610 --> 00:56:52.780
可选值IntelliJ告诉你很好

00:56:51.160 --> 00:56:55.710
这不是Java的八种方法

00:56:52.780 --> 00:56:57.700
东西，那就是复制的东西

00:56:55.710 --> 00:56:59.590
 IntelliJ告诉您不是Java 

00:56:57.700 --> 00:57:03.910
八种做事的方式，为什么不呢

00:56:59.590 --> 00:57:05.740
把它变成一个如果存在的那种

00:57:03.910 --> 00:57:10.980
很好，这很合理

00:57:05.740 --> 00:57:17.820
好，除了你想做的时候

00:57:10.980 --> 00:57:17.820
让我们创建那个方法

00:57:18.090 --> 00:57:23.050
那么您将无法再使用功能

00:57:20.830 --> 00:57:27.100
风格表达，你必须使用

00:57:23.050 --> 00:57:30.160
在Java中目前还存在

00:57:27.100 --> 00:57:32.410
九，你可以使用更多的东西

00:57:30.160 --> 00:57:34.840
功能让我们把它变成我们的

00:57:32.410 --> 00:57:36.550
功能样式表达，我们使用

00:57:34.840 --> 00:57:39.460
 Java 9上的新方法是

00:57:36.550 --> 00:57:42.490
礼物，否则你给它你的

00:57:39.460 --> 00:57:45.100
其他条件，所以如果存在的话

00:57:42.490 --> 00:57:46.540
如果不存在，请这样做，而我

00:57:45.100 --> 00:57:47.830
认为这真的很好，因为

00:57:46.540 --> 00:57:50.560
真的可以崩溃

00:57:47.830 --> 00:57:52.450
那里复杂的if-else条件

00:57:50.560 --> 00:57:55.690
我看过很多现有的代码

00:57:52.450 --> 00:57:57.510
使用我们用完的空值

00:57:55.690 --> 00:58:01.240
时间，我只想看看

00:57:57.510 --> 00:58:03.790
几个功能，还有另一个

00:58:01.240 --> 00:58:05.290
值，这是可选流

00:58:03.790 --> 00:58:07.510
让您更多地使用可选

00:58:05.290 --> 00:58:10.030
有效地出乎意料地极端

00:58:07.510 --> 00:58:16.270
如果我给你，我就给你

00:58:10.030 --> 00:58:17.350
一个例子可能会有所帮助，所以我不

00:58:16.270 --> 00:58:19.300
需要您了解这一点，我们会

00:58:17.350 --> 00:58:22.600
稍后再回到此代码， 

00:58:19.300 --> 00:58:28.180
我在这里的是论点使我返回

00:58:22.600 --> 00:58:29.830
作为字符串数组和in的可选

00:58:28.180 --> 00:58:31.990
为了在内部有效地使用

00:58:29.830 --> 00:58:33.970
流我最终叫流

00:58:31.990 --> 00:58:35.620
方法，我确定还有更多

00:58:33.970 --> 00:58:38.620
有效的方式做到这一点，但这

00:58:35.620 --> 00:58:41.050
比Java 8 Wave文本更好，所以

00:58:38.620 --> 00:58:44.290
有三种在线播放方法

00:58:41.050 --> 00:58:46.030
我们的可选面团，如果有的话

00:58:44.290 --> 00:58:47.290
可选的鸭子梦，他们只是

00:58:46.030 --> 00:58:48.670
意味着将会很多

00:58:47.290 --> 00:58:50.140
更容易使用可选选项而无需

00:58:48.670 --> 00:58:54.760
不得不拆开它们，看看

00:58:50.140 --> 00:58:56.980
值首先是可以的

00:58:54.760 --> 00:58:58.960
 API，因此我们有了一个非常快速的提示

00:58:56.980 --> 00:59:04.920
我知道我们在看

00:58:58.960 --> 00:59:04.920
监控，让我们看一下

00:59:05.040 --> 00:59:09.790
我们知道处理堆栈跟踪

00:59:07.780 --> 00:59:11.380
如果你想看看是昂贵的

00:59:09.790 --> 00:59:12.880
整个堆栈跟踪它必须建立

00:59:11.380 --> 00:59:14.410
整个堆栈跟踪，这很昂贵

00:59:12.880 --> 00:59:16.420
有时候你想做的就是你

00:59:14.410 --> 00:59:18.790
想看一下堆栈的某些部分

00:59:16.420 --> 00:59:20.830
跟踪并找到第一个实例

00:59:18.790 --> 00:59:23.080
堆中的东西，或者可能只是

00:59:20.830 --> 00:59:24.910
找到谁打给我的，所以现在有这个

00:59:23.080 --> 00:59:28.270
新的东西称为堆栈沃克

00:59:24.910 --> 00:59:30.490
让您懒洋洋地看着里面的东西

00:59:28.270 --> 00:59:33.370
堆栈我强烈建议您看

00:59:30.490 --> 00:59:35.500
在文档和一些博客上

00:59:33.370 --> 00:59:37.600
围绕这个东西发帖，因为再次

00:59:35.500 --> 00:59:40.030
这是一个很大的很大的功能，但是

00:59:37.600 --> 00:59:41.890
值得一提的是，现在在Java 9中

00:59:40.030 --> 00:59:43.840
你可以懒洋洋地走栈，所以你

00:59:41.890 --> 00:59:45.340
不必你也不必招致

00:59:43.840 --> 00:59:50.470
建立整个堆栈的成本

00:59:45.340 --> 00:59:53.050
跟踪流程API更新，我们将返回

00:59:50.470 --> 00:59:57.310
我们刚刚在这里看到的这段代码

00:59:53.050 --> 01:00:00.520
这里有一堆新的

00:59:57.310 --> 01:00:01.930
内处理流程的功能

01:00:00.520 --> 01:00:04.630
 Java 9但有一个叫做

01:00:01.930 --> 01:00:08.530
 Java 9中引入的处理句柄

01:00:04.630 --> 01:00:11.170
这可以使我们真正

01:00:08.530 --> 01:00:13.750
有用的强大高级抽象

01:00:11.170 --> 01:00:15.970
对正在运行的进程

01:00:13.750 --> 01:00:17.560
我们的系统对于

01:00:15.970 --> 01:00:20.140
诸如监控之类的东西，但我可以想象

01:00:17.560 --> 01:00:22.030
一堆用例，所以我在这里

01:00:20.140 --> 01:00:24.070
可以获得我所有的流程，然后我可以

01:00:22.030 --> 01:00:25.930
为它做流式操作

01:00:24.070 --> 01:00:30.100
例子让我们运行它，看看

01:00:25.930 --> 01:00:32.440
发生了，我得到了所有的过程

01:00:30.100 --> 01:00:34.390
想找到我想要的所有过程

01:00:32.440 --> 01:00:37.090
找到我所有的Java进程

01:00:34.390 --> 01:00:39.400
流程，我想找到我所有的

01:00:37.090 --> 01:00:42.100
哪些Java进程是

01:00:39.400 --> 01:00:44.050
我的代码，所以如果我正在运行超过

01:00:42.100 --> 01:00:47.380
一项可以显示的服务

01:00:44.050 --> 01:00:50.680
我哪些服务正在运行超级

01:00:47.380 --> 01:00:52.270
在微观方面很有用

01:00:50.680 --> 01:00:54.070
我可能想要的服务架构

01:00:52.270 --> 01:00:57.940
看看我的微软有多少

01:00:54.070 --> 01:00:59.110
在我的系统上运行，所以这里

01:00:57.940 --> 01:01:02.140
我正在运行一个

01:00:59.110 --> 01:01:03.880
监视，但您也可以执行操作

01:01:02.140 --> 01:01:06.460
就像你可以为此而坑

01:01:03.880 --> 01:01:08.380
然后您可以处理

01:01:06.460 --> 01:01:11.020
过程中你可以做的事情

01:01:08.380 --> 01:01:13.510
过程，所以另一个非常好的功能

01:01:11.020 --> 01:01:16.390
这是我当前的流程，我

01:01:13.510 --> 01:01:18.670
可以获得我当前的进程ID 

01:01:16.390 --> 01:01:20.350
这个过程真的很难

01:01:18.670 --> 01:01:21.670
 Java之前特别是因为您

01:01:20.350 --> 01:01:23.380
不知道哪个操作系统

01:01:21.670 --> 01:01:25.420
你在跑，你不知道

01:01:23.380 --> 01:01:28.060
如何一定要操纵

01:01:25.420 --> 01:01:29.920
操作系统，因此新的流程API 

01:01:28.060 --> 01:01:32.920
给您更高层次的方式

01:01:29.920 --> 01:01:34.510
做某种操作系统的东西

01:01:32.920 --> 01:01:38.530
这对于诸如

01:01:34.510 --> 01:01:40.780
监视我知道我们会用光

01:01:38.530 --> 01:01:42.550
我要去的时间

01:01:40.780 --> 01:01:44.560
一些用户想要下车

01:01:42.550 --> 01:01:46.000
因为我们没时间了，但是

01:01:44.560 --> 01:01:47.410
我将尝试完成

01:01:46.000 --> 01:01:48.970
当然会被记录下来，所以如果你

01:01:47.410 --> 01:01:53.290
必须下车你可以回来

01:01:48.970 --> 01:01:54.580
稍后再看录音，我只是

01:01:53.290 --> 01:01:56.410
试图看看还有多少东西

01:01:54.580 --> 01:02:01.240
还有一些事情，然后我们去

01:01:56.410 --> 01:02:03.460
摘要Matsu发布了jar文件um let 

01:02:01.240 --> 01:02:08.530
我打开一个应用程序

01:02:03.460 --> 01:02:10.510
演示了这一点，所以马丁释放了罐子

01:02:08.530 --> 01:02:11.860
文件是Java 9中的一项新功能

01:02:10.510 --> 01:02:13.780
我认为这真的很酷，我希望

01:02:11.860 --> 01:02:15.940
我们早就拥有了

01:02:13.780 --> 01:02:18.940
库发布内容的能力

01:02:15.940 --> 01:02:20.770
包含不同内容的单个jar文件

01:02:18.940 --> 01:02:25.120
不同版本的实现

01:02:20.770 --> 01:02:28.360
的JVM，例如

01:02:25.120 --> 01:02:31.690
使用Java而不是Java 9基本上是Java 8 

01:02:28.360 --> 01:02:34.900
在下面，他们将运行jar文件， 

01:02:31.690 --> 01:02:37.510
他们将获得Java 8或Java 9之前的版本

01:02:34.900 --> 01:02:39.850
功能以及您是否正在运行

01:02:37.510 --> 01:02:42.010
 Java 9然后当您运行相同的jar时

01:02:39.850 --> 01:02:45.520
文件，您将获得Java 9功能

01:02:42.010 --> 01:02:47.560
现在从理论上讲这只是假设

01:02:45.520 --> 01:02:49.750
为内部人员工作

01:02:47.560 --> 01:02:52.000
该实施对您有效

01:02:49.750 --> 01:02:54.580
如果您正在使用，则不应获取其他API 

01:02:52.000 --> 01:02:57.100
我相信可以在Java 8或Java 9上运行

01:02:54.580 --> 01:03:00.900
可能不符合标准

01:02:57.100 --> 01:03:00.900
比实际的实现

01:03:01.020 --> 01:03:05.290
限制，所以我会很感兴趣

01:03:03.130 --> 01:03:07.060
看看这些东西是如何实现的

01:03:05.290 --> 01:03:07.869
根据图书馆的发展，但我只是

01:03:07.060 --> 01:03:10.450
真的很快

01:03:07.869 --> 01:03:14.470
向您展示其原理，因为

01:03:10.450 --> 01:03:15.759
这是相当简单的，所以我有

01:03:14.470 --> 01:03:17.140
一个我要写博客文章的项目

01:03:15.759 --> 01:03:18.549
关于如何做到这一点

01:03:17.140 --> 01:03:20.920
 IntelliJ，因为它很有趣

01:03:18.549 --> 01:03:24.009
所以我有一个项目，这是我的代码

01:03:20.920 --> 01:03:28.329
碰巧是在Java中编译并运行的

01:03:24.009 --> 01:03:31.329
有一个主班我有一个

01:03:28.329 --> 01:03:33.819
接口堆栈信息，然后是我的堆栈

01:03:31.329 --> 01:03:36.430
解析器，用于运行任何内容

01:03:33.819 --> 01:03:37.390
 Java 8用户获取当前线程以获取

01:03:36.430 --> 01:03:39.329
堆栈跟踪是

01:03:37.390 --> 01:03:41.769
我在那里选择的实现

01:03:39.329 --> 01:03:44.259
我在这里有一个

01:03:41.769 --> 01:03:46.390
 Java的实现和堆栈解析器

01:03:44.259 --> 01:03:46.960
 9这就是我刚刚所走的堆栈Walker 

01:03:46.390 --> 01:03:48.430
给你看

01:03:46.960 --> 01:03:50.859
所以很明显堆栈Walker将

01:03:48.430 --> 01:03:52.990
效率更高，因此如果您正在运行Java 

01:03:50.859 --> 01:03:56.170
 9我希望您能够运行此程序

01:03:52.990 --> 01:03:59.380
使用Java 9实现和

01:03:56.170 --> 01:04:02.220
完成的方式是我的课程

01:03:59.380 --> 01:04:04.329
普通代码以普通形式出现

01:04:02.220 --> 01:04:07.329
路由您的正常结构

01:04:04.329 --> 01:04:09.190
根据特定的代码对我的工作进行分类

01:04:07.329 --> 01:04:11.349
不必编译整个项目

01:04:09.190 --> 01:04:13.299
应用程序降到Java 9只是我的Java 9 

01:04:11.349 --> 01:04:16.239
具体的东西，它进入

01:04:13.299 --> 01:04:18.099
元化学版本9，可能还有您

01:04:16.239 --> 01:04:19.869
如果你有10 11 12 

01:04:18.099 --> 01:04:21.970
想拥有你所不能拥有的

01:04:19.869 --> 01:04:25.180
有8 7和6，因为这仅适用

01:04:21.970 --> 01:04:27.940
从9开始，这是非常可悲的，但是

01:04:25.180 --> 01:04:30.130
你可以看到所以我继父是

01:04:27.940 --> 01:04:32.980
用Java 8编译的是我的Java 8 

01:04:30.130 --> 01:04:36.940
类，这个堆栈解析器是我的工作

01:04:32.980 --> 01:04:38.940
 9课，然后在我的清单中我说

01:04:36.940 --> 01:04:43.569
这是一个多版本的jar文件， 

01:04:38.940 --> 01:04:49.260
然后我建立我的jar文件，当我运行

01:04:43.569 --> 01:04:53.340
如果我在Java 8中运行它

01:04:49.260 --> 01:04:55.400
我得到了Java 8实现

01:04:53.340 --> 01:04:58.080
您使用的是Java点线程

01:04:55.400 --> 01:05:02.400
如果我在Java 9中运行它

01:04:58.080 --> 01:05:03.840
我得到了这份工作，我正在实施

01:05:02.400 --> 01:05:05.040
那只是使用相同的jar文件

01:05:03.840 --> 01:05:06.780
所以我觉得这真的很有趣

01:05:05.040 --> 01:05:08.160
 9的功能，我真的会

01:05:06.780 --> 01:05:10.200
有兴趣看看是否有帮助

01:05:08.160 --> 01:05:12.300
库已迁移为使用Java 9 

01:05:10.200 --> 01:05:15.530
功能比它们更快

01:05:12.300 --> 01:05:15.530
本来可以做到的

01:05:19.070 --> 01:05:28.890
更新弃用，这将是

01:05:23.850 --> 01:05:30.180
帮助我们作为开发人员尝试

01:05:28.890 --> 01:05:31.560
找出我们应该使用的功能

01:05:30.180 --> 01:05:34.619
并且不应该使用，所以让我们

01:05:31.560 --> 01:05:44.040
看当前线程点

01:05:34.619 --> 01:05:45.930
停止说，然后您可以看到

01:05:44.040 --> 01:05:48.210
也许你可以看到我们自己的颜色

01:05:45.930 --> 01:05:50.670
这实际上是用红色划掉的

01:05:48.210 --> 01:05:53.700
反对用黑色，它说这是

01:05:50.670 --> 01:05:59.070
如果我们不赞成使用，则将其标记为删除

01:05:53.700 --> 01:06:01.650
看看这个不推荐使用的注解

01:05:59.070 --> 01:06:03.780
有两个新属性的人

01:06:01.650 --> 01:06:06.210
不赞成的人不赞成的人

01:06:03.780 --> 01:06:08.940
它可以选择说出它的版本

01:06:06.210 --> 01:06:11.520
已不赞成使用，此代码是否正在运行

01:06:08.940 --> 01:06:13.230
从理论上讲，您可以弃用

01:06:11.520 --> 01:06:14.850
某种东西不是真的

01:06:13.230 --> 01:06:18.540
用这个，但我不会摆脱

01:06:14.850 --> 01:06:20.340
它，而现在您可以为此标记它

01:06:18.540 --> 01:06:22.650
方法正在消失，所以如果您使用

01:06:20.340 --> 01:06:24.930
您确实需要停止使用它

01:06:22.650 --> 01:06:27.420
现在，这将是真正的

01:06:24.930 --> 01:06:29.490
有助于我们摆脱困境

01:06:27.420 --> 01:06:31.530
使用旧代码并弄清楚如何

01:06:29.490 --> 01:06:33.780
重要的是我们做到这一点

01:06:31.530 --> 01:06:35.400
例如，如果我们使用其他版本

01:06:33.780 --> 01:06:39.029
这个的

01:06:35.400 --> 01:06:41.210
我们看它说已弃用，但

01:06:39.029 --> 01:06:43.529
它不会消失

01:06:41.210 --> 01:06:47.609
这是一个小小的解决办法，但它会使生活变得有点

01:06:43.529 --> 01:06:49.319
更轻松的html5 Javadoc拖动Javadoc 

01:06:47.609 --> 01:06:52.200
踢到21世纪

01:06:49.319 --> 01:06:56.069
世纪，这使我们能够产生

01:06:52.200 --> 01:06:59.119
 html5中的Javadoc，因此您最终获得了

01:06:56.069 --> 01:07:02.999
看起来更像这样的东西

01:06:59.119 --> 01:07:05.430
很好，你知道

01:07:02.999 --> 01:07:12.140
很酷，但是最有趣的是

01:07:05.430 --> 01:07:14.940
正是此功能Java Docs搜索和

01:07:12.140 --> 01:07:18.089
我可以像过去一样进行驼峰式搜索

01:07:14.940 --> 01:07:20.970
拥有IntelliJ IDEA和我

01:07:18.089 --> 01:07:24.089
可以搜索我实际所在的课程

01:07:20.970 --> 01:07:25.769
对Java doc感兴趣的是

01:07:24.089 --> 01:07:27.869
比必须打开它要好得多

01:07:25.769 --> 01:07:30.180
进入框架，然后在

01:07:27.869 --> 01:07:31.980
页面只是为了找到我知道的东西

01:07:30.180 --> 01:07:34.049
可能在那里，我真的很想要

01:07:31.980 --> 01:07:36.180
能够做到这一点，所以这是一个

01:07:34.049 --> 01:07:37.499
真的真的很不错的功能之一

01:07:36.180 --> 01:07:38.970
我们刚遇到的那些小事

01:07:37.499 --> 01:07:44.900
 Java现在将使生活变得更加美好

01:07:38.970 --> 01:07:44.900
对我们来说要容易得多，是的，那就是

01:07:47.930 --> 01:07:53.309
 JTL我们随着时间流逝，所以我没有

01:07:51.509 --> 01:07:55.049
是时候演示Jojo了

01:07:53.309 --> 01:07:57.989
悲伤，因为我没有时间去

01:07:55.049 --> 01:08:01.049
演示Jason J shell，但这

01:07:57.989 --> 01:08:03.569
是乳头，您将能够看到

01:08:01.049 --> 01:08:07.680
这些链接，当我们把

01:08:03.569 --> 01:08:11.549
稍后滑出，周杰伦允许您

01:08:07.680 --> 01:08:12.989
从命令行运行，所以我可以

01:08:11.549 --> 01:08:14.489
从命令行运行J tail 

01:08:12.989 --> 01:08:16.290
这是它的一部分吗

01:08:14.489 --> 01:08:21.500
 Java 9很明显，所以我要运行它

01:08:16.290 --> 01:08:21.500
从这里，我可以说我可以说

01:08:22.159 --> 01:08:28.020
 system.out.print学习我会听到的声音

01:08:26.549 --> 01:08:30.259
制表符补全，很好

01:08:28.020 --> 01:08:34.799
因为我很懒，我可以打个招呼

01:08:30.259 --> 01:08:37.920
而且我不需要分号

01:08:34.799 --> 01:08:39.330
很棒，但是还有很多其他的东西

01:08:37.920 --> 01:08:41.279
享受，所以我认为真的

01:08:39.330 --> 01:08:44.549
从聪明的角度来看很有趣

01:08:41.279 --> 01:08:48.690
是我们有使用该工具的工具吗

01:08:44.549 --> 01:08:51.270
我们有J Shell控制台，它允许我们

01:08:48.690 --> 01:08:58.380
做类似的事情，所以我们得到系统

01:08:51.270 --> 01:09:00.480
点出点println你好，我们可以做

01:08:58.380 --> 01:09:03.270
同样的事情，所以这允许我们玩

01:09:00.480 --> 01:09:04.830
在我们使用功能之前

01:09:03.270 --> 01:09:06.630
实际上必须将其放入我们的

01:09:04.830 --> 01:09:08.609
生产代码，以便我们可以运行摘要

01:09:06.630 --> 01:09:11.130
我们可以潜在地创造

01:09:08.609 --> 01:09:12.690
脚本等等，这真的是

01:09:11.130 --> 01:09:15.449
我们没有的有趣功能

01:09:12.690 --> 01:09:15.659
在我们之前和之后的Java中

01:09:15.449 --> 01:09:17.639
视图

01:09:15.659 --> 01:09:19.710
如果你用这个的话真的很有用

01:09:17.639 --> 01:09:21.929
对您反馈给我们非常有用

01:09:19.710 --> 01:09:23.460
告诉我们很明显是否

01:09:21.929 --> 01:09:25.319
任何错误，但更有趣的是

01:09:23.460 --> 01:09:27.420
您想看到什么样的功能

01:09:25.319 --> 01:09:30.620
什么样的东西以及如何使用

01:09:27.420 --> 01:09:33.620
它如何使您的工作流程更轻松

01:09:30.620 --> 01:09:38.900
好的，随着时间的流逝

01:09:33.620 --> 01:09:41.120
现在让我们总结一下Java 9人

01:09:38.900 --> 01:09:43.280
害怕Java 9，因为他们一直

01:09:41.120 --> 01:09:45.560
意味着多年的代码将

01:09:43.280 --> 01:09:47.180
休息，所以人们害怕

01:09:45.560 --> 01:09:49.640
您的代码将被破坏

01:09:47.180 --> 01:09:50.960
因为内部封装

01:09:49.640 --> 01:09:53.330
 api是因为许多不同

01:09:50.960 --> 01:09:55.400
现在的事情当然是关键

01:09:53.330 --> 01:09:57.530
要做的就是尝试一下，找出是否

01:09:55.400 --> 01:09:59.840
您的代码将被破坏，不要

01:09:57.530 --> 01:10:01.190
只是拭目以待，因为没有人去

01:09:59.840 --> 01:10:03.470
能够告诉您您的代码是

01:10:01.190 --> 01:10:04.910
坏了，用什么方式坏了， 

01:10:03.470 --> 01:10:06.650
现在值得尝试

01:10:04.910 --> 01:10:08.450
特别是在Java 9发布之后

01:10:06.650 --> 01:10:10.790
正式的，这不是早期的尝试

01:10:08.450 --> 01:10:12.230
发行将在那里改变

01:10:10.790 --> 01:10:14.120
有很多事情可以

01:10:12.230 --> 01:10:16.730
有助于破坏您的代码

01:10:14.120 --> 01:10:19.220
很多东西要消失了，所以

01:10:16.730 --> 01:10:21.320
删除过时的GC组合

01:10:19.220 --> 01:10:24.490
例如删除各种工具

01:10:21.320 --> 01:10:27.260
删除各种启动时间标志

01:10:24.490 --> 01:10:29.060
弃用applet API，这些是

01:10:27.260 --> 01:10:31.430
他们要离开的事情，所以他们

01:10:29.060 --> 01:10:33.710
封装的大多数内部api是

01:10:31.430 --> 01:10:35.690
基本上可以制造某些东西的东西

01:10:33.710 --> 01:10:38.480
你正在使用的潜在外观

01:10:35.690 --> 01:10:40.790
就像他们已经消失了一样

01:10:38.480 --> 01:10:44.120
可能会导致意外的有趣

01:10:40.790 --> 01:10:46.250
破损是其中的一些特征

01:10:44.120 --> 01:10:48.050
这可能会改变行为

01:10:46.250 --> 01:10:50.090
您的应用程序没有意识到

01:10:48.050 --> 01:10:52.570
所以他们在JVM上做了很多工作

01:10:50.090 --> 01:10:55.640
记录，所以如果你有类似的东西

01:10:52.570 --> 01:10:58.340
报告运行纠正各种

01:10:55.640 --> 01:11:00.830
日志语句或类似的内容

01:10:58.340 --> 01:11:03.470
那些在Java中可能不再存在

01:11:00.830 --> 01:11:05.450
 9和默认值g1之类的东西

01:11:03.470 --> 01:11:06.890
垃圾收集器，我不认为那是

01:11:05.450 --> 01:11:09.020
真的会影响很多人

01:11:06.890 --> 01:11:10.610
因为如果你不在乎

01:11:09.020 --> 01:11:11.660
关于你的垃圾收集器，所以你

01:11:10.610 --> 01:11:13.430
使用默认

01:11:11.660 --> 01:11:15.440
我认为更改默认设置不会

01:11:13.430 --> 01:11:16.610
有很大的不同，如果你在乎

01:11:15.440 --> 01:11:18.320
关于你的垃圾收集器

01:11:16.610 --> 01:11:19.880
可能在不到一英寸的范围内对其进行了调整

01:11:18.320 --> 01:11:21.380
生活，所以你真的不在乎什么

01:11:19.880 --> 01:11:24.440
默认是因为您不使用它

01:11:21.380 --> 01:11:27.470
但是值得我注意

01:11:24.440 --> 01:11:29.120
肯定有一个陷阱

01:11:27.470 --> 01:11:30.920
很多工具和框架，以及

01:11:29.120 --> 01:11:34.820
库是新版本的字符串

01:11:30.920 --> 01:11:37.790
方案，因此Java 9不是Java 1.9 Java 9 

01:11:34.820 --> 01:11:39.710
是Java 9，所以如果您要进行任何解析

01:11:37.790 --> 01:11:42.500
版本字符串并取1 

01:11:39.710 --> 01:11:43.600
指出起点并找出答案

01:11:42.500 --> 01:11:45.640
它是什么版本

01:11:43.600 --> 01:11:47.680
那将无法在Java 9中使用

01:11:45.640 --> 01:11:49.780
像索引一样

01:11:47.680 --> 01:11:51.520
界限异常或某事是你

01:11:49.780 --> 01:11:54.220
一开始就无法摆脱1.9 

01:11:51.520 --> 01:11:55.150
因为它不存在，当然

01:11:54.220 --> 01:11:57.640
这将更加

01:11:55.150 --> 01:11:59.140
有趣的是，Java 10发布以来

01:11:57.640 --> 01:12:03.400
他们正在谈论称其为Java 

01:11:59.140 --> 01:12:05.560
 18.3工具库

01:12:03.400 --> 01:12:07.240
框架继续交付东西

01:12:05.560 --> 01:12:09.310
我们所依赖的东西还在不断发展

01:12:07.240 --> 01:12:11.290
对于Java 9来说，流失很多

01:12:09.310 --> 01:12:13.750
仅在去年的Java 9中

01:12:11.290 --> 01:12:15.340
它不是中国的超级稳定

01:12:13.750 --> 01:12:17.980
很好，因为它是Java 9 

01:12:15.340 --> 01:12:19.660
更好，更强大，但是

01:12:17.980 --> 01:12:21.430
一些工具和框架是

01:12:19.660 --> 01:12:25.060
等待它安定下来之前

01:12:21.430 --> 01:12:26.800
兼容Java 9，请尝试一下

01:12:25.060 --> 01:12:28.960
特别是在你连续不断

01:12:26.800 --> 01:12:32.080
集成环境确保

01:12:28.960 --> 01:12:33.760
 CI仍然有效，请确保

01:12:32.080 --> 01:12:36.640
库以您期望的方式工作

01:12:33.760 --> 01:12:38.290
他们如此，然后您可能需要

01:12:36.640 --> 01:12:40.290
升级到一些最新版本

01:12:38.290 --> 01:12:43.120
您正在使用的东西

01:12:40.290 --> 01:12:46.210
您不需要模块化代码

01:12:43.120 --> 01:12:48.220
为了使用Java 9，这很常见

01:12:46.210 --> 01:12:50.950
误解，你不需要放

01:12:48.220 --> 01:12:53.710
模块-信息Java到您的代码中

01:12:50.950 --> 01:12:55.960
为了使用收藏工厂

01:12:53.710 --> 01:12:58.750
例如，您不需要的方法

01:12:55.960 --> 01:13:00.760
使用任何机动化的东西，如果你

01:12:58.750 --> 01:13:03.880
只想使用Java 9中的功能

01:13:00.760 --> 01:13:06.820
像新方法上的可选新方法

01:13:03.880 --> 01:13:08.770
串起来，所以如果不动力化

01:13:06.820 --> 01:13:10.540
给您带来新的好处

01:13:08.770 --> 01:13:12.880
模块系统不会给你

01:13:10.540 --> 01:13:14.950
任何好处都不要使用它，因为它是

01:13:12.880 --> 01:13:17.650
大量的工作，其中之一

01:13:14.950 --> 01:13:19.960
为什么Java 9很好为什么模块

01:13:17.650 --> 01:13:22.480
系统从推出到Java 9 

01:13:19.960 --> 01:13:25.000
 Java 7是他们花了很长时间

01:13:22.480 --> 01:13:26.800
模块化jdk本身，所以很多

01:13:25.000 --> 01:13:30.520
工作，但您不必如此

01:13:26.800 --> 01:13:32.440
如果您不需要玩游戏，那就去做吧

01:13:30.520 --> 01:13:35.470
现在可以使用Java获得良好的设计

01:13:32.440 --> 01:13:37.300
确实鼓励封装分离

01:13:35.470 --> 01:13:40.000
关注良好的面向对象设计

01:13:37.300 --> 01:13:41.110
你得到一些，你得到一个更清洁的设计

01:13:40.000 --> 01:13:42.640
通过使用它，你也会变得更好

01:13:41.110 --> 01:13:45.100
安全性也是如此

01:13:42.640 --> 01:13:46.900
绝对是一件好事，它鼓励

01:13:45.100 --> 01:13:48.760
使用乳头的新工作方式

01:13:46.900 --> 01:13:49.450
使用正确的两个流API和

01:13:48.760 --> 01:13:52.600
像这样的东西

01:13:49.450 --> 01:13:55.090
但我认为Java 9只是一点点

01:13:52.600 --> 01:13:57.280
更好地编写代码不是最性感的

01:13:55.090 --> 01:13:58.900
 Java版本的带状线，但是

01:13:57.280 --> 01:14:00.849
就是这些东西

01:13:58.900 --> 01:14:03.840
新方法（可选）和流

01:14:00.849 --> 01:14:05.920
收藏工厂的方法

01:14:03.840 --> 01:14:08.020
减少样板的各个位

01:14:05.920 --> 01:14:09.760
能够有效地使用final 

01:14:08.020 --> 01:14:11.949
尝试使用资源变量

01:14:09.760 --> 01:14:13.449
可以将Diamond运算符与

01:14:11.949 --> 01:14:16.239
匿名内部类都是这些

01:14:13.449 --> 01:14:18.250
小事，但它们才开始席卷

01:14:16.239 --> 01:14:20.980
删除一些样板和一些

01:14:18.250 --> 01:14:22.900
使用Java产生的噪音

01:14:20.980 --> 01:14:25.960
是转移到

01:14:22.900 --> 01:14:27.940
从我的角度来看Java 9 

01:14:25.960 --> 01:14:30.369
当然，迁移到Java是一个好主意

01:14:27.940 --> 01:14:31.659
 9，因为据称Java 10将

01:14:30.369 --> 01:14:34.840
三月出来

01:14:31.659 --> 01:14:37.809
今年三月到来，所以我们需要

01:14:34.840 --> 01:14:40.239
已经采用Java 9并获得了成功

01:14:37.809 --> 01:14:42.099
都看我们所有升级的图书馆

01:14:40.239 --> 01:14:43.389
所以一切都可以在Java 9中使用

01:14:42.099 --> 01:14:46.570
我们可以使用所有很酷的功能

01:14:43.389 --> 01:14:48.579
 Java 10即将推出，就像本地类型一样

01:14:46.570 --> 01:14:51.420
推论和其他一些很酷的

01:14:48.579 --> 01:14:55.119
 Java 10中的东西

01:14:51.420 --> 01:14:58.510
好吧，所以像往常一样，我走的太远了

01:14:55.119 --> 01:15:00.460
该链接指向的时间将指向

01:14:58.510 --> 01:15:02.619
这个视频在这个视频中在线

01:15:00.460 --> 01:15:04.869
该链接指向一堆东西

01:15:02.619 --> 01:15:06.429
像Jade EPS监狱的文档

01:15:04.869 --> 01:15:08.500
我提到的所有这些工具

01:15:06.429 --> 01:15:11.889
和提到的链接

01:15:08.500 --> 01:15:15.429
关于J的教程

01:15:11.889 --> 01:15:16.690
外壳以及本次演讲的其他视频

01:15:15.429 --> 01:15:18.639
我能够深入了解的地方

01:15:16.690 --> 01:15:22.329
反应式编程深度更深

01:15:18.639 --> 01:15:25.139
在J shell上，也许也可以这样做

01:15:22.329 --> 01:15:28.270
链接并在那里找到更多资源

01:15:25.139 --> 01:15:29.980
会提出问题，但我完全期望

01:15:28.270 --> 01:15:31.360
人们已经消失了

01:15:29.980 --> 01:15:35.070
因为我随着时间的流逝

01:15:31.360 --> 01:15:35.070
安德拉亚任何问题

01:15:35.120 --> 01:15:40.110
是的，我希望我们有更多时间

01:15:37.650 --> 01:15:43.500
我们能做的就是尝试

01:15:40.110 --> 01:15:45.660
解决最有趣的问题

01:15:43.500 --> 01:15:49.530
该博客文章将随

01:15:45.660 --> 01:15:53.160
视频，是的，还有每个人

01:15:49.530 --> 01:15:56.610
注册将收到该电子邮件，是的

01:15:53.160 --> 01:16:01.830
就是这样，毫无疑问是

01:15:56.610 --> 01:16:04.500
要解释的非常具有挑战性的任务

01:16:01.830 --> 01:16:05.219
现在和仅使用Java的所有功能

01:16:04.500 --> 01:16:08.040
一小时

01:16:05.219 --> 01:16:12.060
所以你以为我们告诉你你是的

01:16:08.040 --> 01:16:13.679
做得很好，谢谢

01:16:12.060 --> 01:16:17.610
当拼图真的应该采取的时候很难

01:16:13.679 --> 01:16:20.880
大概三个小时

01:16:17.610 --> 01:16:23.330
非常感谢您的宝贵时间

01:16:20.880 --> 01:16:26.730
并感谢大家加入我们

01:16:23.330 --> 01:16:29.510
非常感谢，好吧，保重

01:16:26.730 --> 01:16:29.510
祝你有美好的一天

01:16:29.710 --> 01:16:31.770
您

