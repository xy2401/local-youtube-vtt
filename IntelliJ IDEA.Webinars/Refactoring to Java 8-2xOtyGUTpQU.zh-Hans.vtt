WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.010 --> 00:00:08.220
我将谈论尊重

00:00:05.680 --> 00:00:10.780
 Java 8这真是令人惊讶

00:00:08.220 --> 00:00:13.900
过去一年左右的热门话题

00:00:10.780 --> 00:00:17.109
因为我们看过关于

00:00:13.900 --> 00:00:18.820
 Java 8如何引入新的

00:00:17.109 --> 00:00:20.470
诸如lambda和流等功能

00:00:18.820 --> 00:00:22.780
第四，我们已经看到了有关

00:00:20.470 --> 00:00:24.910
如何在新代码中使用它们，但是

00:00:22.780 --> 00:00:27.130
更适合我们大多数人

00:00:24.910 --> 00:00:29.500
日常开发人员是我们的方式

00:00:27.130 --> 00:00:31.150
现有的代码库，也许会搬家

00:00:29.500 --> 00:00:33.370
朝Java 8的方向发展

00:00:31.150 --> 00:00:34.960
也许也了解一些

00:00:33.370 --> 00:00:36.999
这样做的利弊

00:00:34.960 --> 00:00:39.879
权衡，这就是这个话题

00:00:36.999 --> 00:00:41.679
旨在回答，但首先

00:00:39.879 --> 00:00:45.370
我们这样做让我们快速看一下

00:00:41.679 --> 00:00:48.549
为什么我们要向Java 8迁移呢？ 

00:00:45.370 --> 00:00:50.019
现在已经快三岁了，所以我

00:00:48.549 --> 00:00:52.089
猜大概很多人

00:00:50.019 --> 00:00:53.469
已经在使用Java 8或正在考虑使用它

00:00:52.089 --> 00:00:56.019
可能是最引人注目的之一

00:00:53.469 --> 00:00:58.030
原因是Java 6和7 

00:00:56.019 --> 00:01:00.100
寿命终止，不再正式

00:00:58.030 --> 00:01:02.499
支持，因此移至

00:01:00.100 --> 00:01:04.150
 Java 8正是出于这些原因，但是在那里

00:01:02.499 --> 00:01:05.650
是一些令人信服的理由

00:01:04.150 --> 00:01:07.750
当你试图推动自己的时候争论

00:01:05.650 --> 00:01:09.310
管理层或支持者的情况

00:01:07.750 --> 00:01:11.800
团队或组织内部

00:01:09.310 --> 00:01:13.450
在乎这些事情，为什么你

00:01:11.800 --> 00:01:16.930
应该采用一些工作8 

00:01:13.450 --> 00:01:18.580
首先是Java 8的特性

00:01:16.930 --> 00:01:20.560
比以前的Java版本更快

00:01:18.580 --> 00:01:22.120
您甚至不需要做任何事情，或者

00:01:20.560 --> 00:01:23.950
使用任何新功能来获得一些

00:01:22.120 --> 00:01:25.270
这些速度改善中

00:01:23.950 --> 00:01:27.520
一些常见的数据结构是

00:01:25.270 --> 00:01:29.470
更快，速度有所提高

00:01:27.520 --> 00:01:30.940
并发等等

00:01:29.470 --> 00:01:32.230
有关此点击的更多信息

00:01:30.940 --> 00:01:35.140
该链接，因为有一些链接

00:01:32.230 --> 00:01:37.480
有关以下内容的其他文档

00:01:35.140 --> 00:01:38.950
当然很容易瘫痪

00:01:37.480 --> 00:01:40.780
关于一些流

00:01:38.950 --> 00:01:42.670
您可以运行的事实

00:01:40.780 --> 00:01:44.590
流并行操作，无需

00:01:42.670 --> 00:01:47.500
必须管理诸如线程之类的东西

00:01:44.590 --> 00:01:49.240
池或执行服务等

00:01:47.500 --> 00:01:53.350
只是很容易做到

00:01:49.240 --> 00:01:55.870
为您编写更少的代码行

00:01:53.350 --> 00:01:57.490
一个铁杆长期的Java人

00:01:55.870 --> 00:01:59.680
这不是最引人注目的原因

00:01:57.490 --> 00:02:01.540
对我来说，但实际上一旦你

00:01:59.680 --> 00:02:03.640
习惯于使用Java 8风格开始

00:02:01.540 --> 00:02:05.890
看看你在写什么

00:02:03.640 --> 00:02:08.140
你想实现不怎么做， 

00:02:05.890 --> 00:02:09.489
很好，但是可以带走很多东西

00:02:08.140 --> 00:02:11.650
样板和东西

00:02:09.489 --> 00:02:13.209
眼睛有点无视，让你

00:02:11.650 --> 00:02:15.400
专注于真正重要的是

00:02:13.209 --> 00:02:16.780
代码，他们一直

00:02:15.400 --> 00:02:19.269
做类似lambda传递的事情

00:02:16.780 --> 00:02:20.920
表达式或使用API​​提供的流

00:02:19.269 --> 00:02:22.269
您为问题提供了新的解决方案， 

00:02:20.920 --> 00:02:25.360
也许可以让您解决自己的问题

00:02:22.269 --> 00:02:28.329
在其中之一无法解决之前

00:02:25.360 --> 00:02:30.099
我认为正在宣传的领域是

00:02:28.329 --> 00:02:32.349
 Java 8的某些功能可以让您

00:02:30.099 --> 00:02:34.239
最小化错误，我们将看到一些示例

00:02:32.349 --> 00:02:35.680
我们可以最大限度地减少诸如

00:02:34.239 --> 00:02:37.299
使用lambda复制和粘贴错误

00:02:35.680 --> 00:02:38.950
表达，但还有其他事情

00:02:37.299 --> 00:02:41.019
如可选功能和其他功能

00:02:38.950 --> 00:02:42.609
让您最小化错误数量

00:02:41.019 --> 00:02:45.099
意外地潜入您的代码

00:02:42.609 --> 00:02:47.049
还有流API和

00:02:45.099 --> 00:02:48.849
增加了可读性

00:02:47.049 --> 00:02:51.510
样板可以让您看到更多

00:02:48.849 --> 00:02:54.099
容易在您犯了一个愚蠢的错误的地方

00:02:51.510 --> 00:02:57.010
所以我们直接进入

00:02:54.099 --> 00:02:59.019
重构事物的一面，但是在我们之前

00:02:57.010 --> 00:03:00.730
做我们真正做的任何形式的重构

00:02:59.019 --> 00:03:02.379
需要进行安全检查以确保

00:03:00.730 --> 00:03:04.629
我们来对地方了

00:03:02.379 --> 00:03:06.370
首先重构是真的

00:03:04.629 --> 00:03:07.840
具有自动接受能力很重要

00:03:06.370 --> 00:03:09.909
测试您是否要执行任何操作

00:03:07.840 --> 00:03:11.019
重构是因为尽管很多

00:03:09.909 --> 00:03:13.659
我要展示的研究内容

00:03:11.019 --> 00:03:15.159
你的想法是功能

00:03:13.659 --> 00:03:16.720
将保持不变

00:03:15.159 --> 00:03:18.459
您不能确定自己没有

00:03:16.720 --> 00:03:20.349
不小心更改了某些功能

00:03:18.459 --> 00:03:22.389
如果您没有自动测试

00:03:20.349 --> 00:03:25.209
向您证明您的代码仍然可以

00:03:22.389 --> 00:03:26.680
用来表现的东西

00:03:25.209 --> 00:03:28.569
测试对于同一种

00:03:26.680 --> 00:03:29.769
事情，实际上我们会谈论很多

00:03:28.569 --> 00:03:31.569
关于其中一些的性能

00:03:29.769 --> 00:03:35.019
在本次演讲中进行重构

00:03:31.569 --> 00:03:37.329
所以您可能会想到

00:03:35.019 --> 00:03:39.519
使用Java 8习惯用法会影响

00:03:37.329 --> 00:03:41.319
您的代码的性能，如果性能

00:03:39.519 --> 00:03:43.120
对您来说很重要

00:03:41.319 --> 00:03:44.680
有测试来证明您没有

00:03:43.120 --> 00:03:46.299
做一些奇怪的事情来影响

00:03:44.680 --> 00:03:48.579
性能和我说的涉及

00:03:46.299 --> 00:03:50.829
性能很重要，我不认为

00:03:48.579 --> 00:03:53.079
一定只是意味着纳秒级

00:03:50.829 --> 00:03:54.750
高频交易的等待时间或

00:03:53.079 --> 00:03:57.250
不管我有时候是什么意思

00:03:54.750 --> 00:03:59.530
对用户的响应能力小于

00:03:57.250 --> 00:04:01.120
半秒或类似的时间

00:03:59.530 --> 00:04:02.949
是否需要Android应用来制作

00:04:01.120 --> 00:04:05.049
打电话给后端，所以这些不是

00:04:02.949 --> 00:04:06.699
一定我不是在说高

00:04:05.049 --> 00:04:08.769
我正在谈论的表现

00:04:06.699 --> 00:04:10.060
确保您进行了性能测试

00:04:08.769 --> 00:04:13.659
对您真正重要的事情

00:04:10.060 --> 00:04:15.370
在进行任何形式的操作之前都要明智地执行

00:04:13.659 --> 00:04:18.669
重构，您真的需要决定

00:04:15.370 --> 00:04:20.440
作为一个团队作为一个组织，为什么你

00:04:18.669 --> 00:04:21.729
要做这个重构，在那里

00:04:20.440 --> 00:04:23.229
我们有许多不同的原因

00:04:21.729 --> 00:04:25.360
谈到诸如性能和

00:04:23.229 --> 00:04:28.729
可读性删除样板和

00:04:25.360 --> 00:04:31.249
消除您也可以尊重的错误

00:04:28.729 --> 00:04:34.460
学习，您可能想升级

00:04:31.249 --> 00:04:37.009
团队基于域的代码

00:04:34.460 --> 00:04:39.199
他们很熟悉，所以让他们习惯

00:04:37.009 --> 00:04:40.789
在环境中使用Java习惯用法

00:04:39.199 --> 00:04:42.710
对他们来说舒适而不是

00:04:40.789 --> 00:04:44.930
试图使他们掌握新技能

00:04:42.710 --> 00:04:48.499
在新域上具有新习语的语言

00:04:44.930 --> 00:04:50.449
在一个新项目上，这样的想法

00:04:48.499 --> 00:04:52.939
重构以使团队难以理解

00:04:50.449 --> 00:04:54.199
选择它也是一件有效的事情

00:04:52.939 --> 00:04:57.110
真正重要的是您要实现这些目标

00:04:54.199 --> 00:04:58.520
选择，但想法是要有

00:04:57.110 --> 00:04:59.960
你想要达到的目标

00:04:58.520 --> 00:05:03.050
通过这样做，您可以分解并坚持

00:04:59.960 --> 00:05:04.759
您应该限制范围

00:05:03.050 --> 00:05:06.469
您在这些中所做的任何重构

00:05:04.759 --> 00:05:07.759
例子主要是看

00:05:06.469 --> 00:05:10.580
方法级别，因此它们将是

00:05:07.759 --> 00:05:12.169
重构的一小部分

00:05:10.580 --> 00:05:14.629
我们这样做的范围非常有限

00:05:12.169 --> 00:05:16.279
范围，您可能想限制

00:05:14.629 --> 00:05:17.960
方法级别或类的东西

00:05:16.279 --> 00:05:19.819
水平，我们当然不应该去

00:05:17.960 --> 00:05:22.069
直接进入并尝试重构

00:05:19.819 --> 00:05:24.199
整个代码库使用可选的

00:05:22.069 --> 00:05:25.430
例子，你真的想带朋友

00:05:24.199 --> 00:05:29.719
您正在做这些的区域

00:05:25.430 --> 00:05:31.159
在代码库中进行重构

00:05:29.719 --> 00:05:33.050
要看的是一个名为

00:05:31.159 --> 00:05:35.149
 morphia这是一个对象文档

00:05:33.050 --> 00:05:37.370
 MongoDB的映射器，有一些

00:05:35.149 --> 00:05:39.080
我首先选择这个的原因

00:05:37.370 --> 00:05:40.879
因为我当时在做这件事

00:05:39.080 --> 00:05:42.560
在MongoDB工作，所以这是我的代码库

00:05:40.879 --> 00:05:44.930
非常了解，但更有趣

00:05:42.560 --> 00:05:46.459
这是一个开放源代码库，因此

00:05:44.930 --> 00:05:47.899
你可以自己看看

00:05:46.459 --> 00:05:51.020
看他们之前和之后

00:05:47.899 --> 00:05:54.020
重构也相当成熟

00:05:51.020 --> 00:05:55.129
一段代码，所以它有很多

00:05:54.020 --> 00:05:57.229
您可能会拥有的相同特征

00:05:55.129 --> 00:06:01.099
在很多自己的代码库中找到

00:05:57.229 --> 00:06:04.610
可能有的一些代码

00:06:01.099 --> 00:06:07.069
随着时间的推移以次优的方式进化

00:06:04.610 --> 00:06:08.930
或不再存在的一些代码

00:06:07.069 --> 00:06:11.569
遵循这些方式的一种时尚

00:06:08.930 --> 00:06:13.370
做事情，所以这是一个很好的代码

00:06:11.569 --> 00:06:15.469
重构的基础是您可以查看

00:06:13.370 --> 00:06:17.569
其中一些并使用代码块和

00:06:15.469 --> 00:06:22.520
想出更好的方法来做这些事情

00:06:17.569 --> 00:06:24.499
特别是在使用Java 8的情况下

00:06:22.520 --> 00:06:26.839
事不宜迟，让我们直接深入探讨

00:06:24.499 --> 00:06:28.490
开始做一些重构

00:06:26.839 --> 00:06:30.529
我想看的是重构

00:06:28.490 --> 00:06:31.930
使用lambda表达式，因为

00:06:30.529 --> 00:06:36.020
可能是最简单，最

00:06:31.930 --> 00:06:39.829
自动重构，我们可以做到

00:06:36.020 --> 00:06:40.560
我们可以做的最简单的事情

00:06:39.829 --> 00:06:43.410
最简单的事情

00:06:40.560 --> 00:06:45.870
可以做的是随身携带

00:06:43.410 --> 00:06:49.350
实现的匿名内部类

00:06:45.870 --> 00:06:51.720
比较器可运行可调用

00:06:49.350 --> 00:06:53.790
断言所有这些接口

00:06:51.720 --> 00:06:57.030
总是只有一个摘要

00:06:53.790 --> 00:07:02.040
方法和使用给定lambda表达式

00:06:57.030 --> 00:07:04.889
而不是使用匿名内部类型

00:07:02.040 --> 00:07:07.740
让我们直接进入我们的代码

00:07:04.889 --> 00:07:10.230
我已经完成了对

00:07:07.740 --> 00:07:11.940
 morphia代码库，我将快速浏览

00:07:10.230 --> 00:07:14.190
因为我很幸运

00:07:11.940 --> 00:07:17.430
我可以实际显示一些情况

00:07:14.190 --> 00:07:19.470
中的IntelliJ特定功能

00:07:17.430 --> 00:07:21.150
这次网络研讨会，所以我有一个

00:07:19.470 --> 00:07:23.880
视察档案称为Java八

00:07:21.150 --> 00:07:25.740
并且我选择了

00:07:23.880 --> 00:07:29.820
检查我大部分的人

00:07:25.740 --> 00:07:33.240
对我们感兴趣的是找到它

00:07:29.820 --> 00:07:39.350
所以我大部分时间都在Java中

00:07:33.240 --> 00:07:48.770
大约在哪里

00:07:39.350 --> 00:07:48.770
我已经超过了语言水平

00:07:49.070 --> 00:07:55.350
迁移艾滋病，所以我们这里有东西

00:07:52.140 --> 00:07:56.520
就像我们选择寻找匿名者一样

00:07:55.350 --> 00:07:58.470
可以替换为inter的类型

00:07:56.520 --> 00:08:00.150
 lambda表达式有很多

00:07:58.470 --> 00:08:02.520
我们如何可以代替嘴唇

00:08:00.150 --> 00:08:04.320
到流API以及许多其他

00:08:02.520 --> 00:08:05.850
这里的功能，这是那种

00:08:04.320 --> 00:08:07.440
我们要进行的主要检查

00:08:05.850 --> 00:08:09.060
正在运行，我正在运行一些， 

00:08:07.440 --> 00:08:10.380
我们会看到这些，但是

00:08:09.060 --> 00:08:13.169
这是您要配置它们的地方

00:08:10.380 --> 00:08:14.639
所以在语言水平的检查中

00:08:13.169 --> 00:08:17.400
您可能想转向的艾滋病

00:08:14.639 --> 00:08:19.800
我现在已经跑了一些

00:08:17.400 --> 00:08:22.590
那些让我们快速看一下

00:08:19.800 --> 00:08:24.630
首先设置这是匿名类型可以

00:08:22.590 --> 00:08:27.539
用lambda代替，如果我们看一下

00:08:24.630 --> 00:08:30.810
这个例子我们可以看到这是一个

00:08:27.539 --> 00:08:34.349
谓词番石榴谓词，我们有

00:08:30.810 --> 00:08:36.240
我们以自己的类型匿名

00:08:34.349 --> 00:08:38.400
方法和IntelliJ可以

00:08:36.240 --> 00:08:41.400
自动将其变成一个

00:08:38.400 --> 00:08:43.140
 lambda表达式，所以这是一个相当

00:08:41.400 --> 00:08:45.029
直截了当的魔法

00:08:43.140 --> 00:08:47.670
我们将删除所有

00:08:45.029 --> 00:08:50.250
我们班级声明的样板

00:08:47.670 --> 00:08:52.050
方法我们的类型信息，只是

00:08:50.250 --> 00:08:53.760
保持业务逻辑

00:08:52.050 --> 00:08:56.220
我们关心的东西

00:08:53.760 --> 00:08:58.010
变成lambda表情让我

00:08:56.220 --> 00:09:02.070
再给我看几个例子

00:08:58.010 --> 00:09:03.750
用Java的成熟思考八

00:09:02.070 --> 00:09:05.670
可能是大多数人

00:09:03.750 --> 00:09:06.930
网络研讨会已经遇到了这些

00:09:05.670 --> 00:09:08.430
事情，所以我要去浏览一下

00:09:06.930 --> 00:09:11.670
快速入门

00:09:08.430 --> 00:09:13.170
东西，所以这是另一个例子

00:09:11.670 --> 00:09:15.780
一个例子，其中我们有一个可运行的

00:09:13.170 --> 00:09:20.520
再次可以将亚军球转换

00:09:15.780 --> 00:09:23.610
变成lambda表达式，在这里我们

00:09:20.520 --> 00:09:27.000
只是得到我们就保持核心

00:09:23.610 --> 00:09:28.740
运行方法是什么

00:09:27.000 --> 00:09:31.380
一个有趣的例子是

00:09:28.740 --> 00:09:32.580
这个可调用在这里有两行，所以当

00:09:31.380 --> 00:09:36.510
我们将其缩小为lambda 

00:09:32.580 --> 00:09:38.370
表达式中您可以看到两行

00:09:36.510 --> 00:09:40.350
 lambda表达式中的lambda和

00:09:38.370 --> 00:09:42.060
我喜欢亲自做的是我喜欢

00:09:40.350 --> 00:09:45.770
将它们提取为一种方法并给出

00:09:42.060 --> 00:09:50.910
这是一个描述，直到十点

00:09:45.770 --> 00:09:53.100
找到项目，因为这给了我一个

00:09:50.910 --> 00:09:56.490
几个好处之一，我可以缩小我的

00:09:53.100 --> 00:09:58.470
 Lambda表达向下，我可以

00:09:56.490 --> 00:10:00.660
甚至可能把它变成

00:09:58.470 --> 00:10:03.720
方法参考，如果调用是

00:10:00.660 --> 00:10:05.490
是正确的形状，但主要是

00:10:03.720 --> 00:10:07.710
更具描述性，所以现在我可以说

00:10:05.490 --> 00:10:09.450
直到找到十个物品，所以很多

00:10:07.710 --> 00:10:13.020
我更清楚这两行

00:10:09.450 --> 00:10:14.880
如果有的话，代码是最重要的

00:10:13.020 --> 00:10:16.860
我想调试的任何错误是

00:10:14.880 --> 00:10:18.900
调试lambda表达式要容易一些

00:10:16.860 --> 00:10:21.000
如果它们实际上在方法内部，那么

00:10:18.900 --> 00:10:24.530
那是我制作的主要原因

00:10:21.000 --> 00:10:28.220
我的lambda表达式单行锁定

00:10:24.530 --> 00:10:28.220
所以这很简单

00:10:29.870 --> 00:10:37.620
更有趣的是我们

00:10:33.480 --> 00:10:39.540
那些例子可以匿名吗

00:10:37.620 --> 00:10:42.030
正在实施

00:10:39.540 --> 00:10:44.460
界面，我们可以做同样的事情

00:10:42.030 --> 00:10:48.180
抽象类，但我们必须走一个

00:10:44.460 --> 00:10:51.210
再往前走，让我们快点走

00:10:48.180 --> 00:10:56.010
看着可运行的哦，那不对

00:10:51.210 --> 00:10:57.510
捷径，所以跑个球

00:10:56.010 --> 00:11:00.270
接口中的功能接口

00:10:57.510 --> 00:11:07.470
一个单一的抽象方法，如果我

00:11:00.270 --> 00:11:10.140
看我的代码，我可以找到摘要

00:11:07.470 --> 00:11:11.820
看起来很相似的方法，所以我

00:11:10.140 --> 00:11:14.520
有一个单一的抽象方法

00:11:11.820 --> 00:11:16.460
抽象与抽象类

00:11:14.520 --> 00:11:18.570
单一的抽象方法就可以了

00:11:16.460 --> 00:11:20.310
 IntelliJ建议您可以转换

00:11:18.570 --> 00:11:22.830
这到我要去的界面

00:11:20.310 --> 00:11:25.160
然后将其转换为

00:11:22.830 --> 00:11:28.830
我可以用它标记的界面

00:11:25.160 --> 00:11:31.050
功能界面，然后我可以

00:11:28.830 --> 00:11:33.750
我可以四处看看

00:11:31.050 --> 00:11:36.630
实现者，现在我可以转向

00:11:33.750 --> 00:11:38.010
现在我可以将它们转换为lambda表达式

00:11:36.630 --> 00:11:39.390
这样做是因为lambda 

00:11:38.010 --> 00:11:41.820
表达式不是抽象的

00:11:39.390 --> 00:11:45.290
类仅具有接口，因此

00:11:41.820 --> 00:11:45.290
只是我们可以做的一个额外步骤

00:11:49.040 --> 00:11:54.360
所以这两件事只是把你的

00:11:51.630 --> 00:11:56.640
现有代码并基本上应用新的

00:11:54.360 --> 00:11:59.730
现有功能的语法

00:11:56.640 --> 00:12:02.880
你有，所以让我们来看看

00:11:59.730 --> 00:12:04.560
在这里的表演，我们有一个

00:12:02.880 --> 00:12:07.770
那些在课堂上如此匿名的例子

00:12:04.560 --> 00:12:09.270
和我们的lambda表达式，这些

00:12:07.770 --> 00:12:12.030
我们将要比较的两件事

00:12:09.270 --> 00:12:13.590
性能测试，因此在我们的性能中

00:12:12.030 --> 00:12:16.410
测试正在测量操作

00:12:13.590 --> 00:12:18.210
毫秒，所以更多的操作更好

00:12:16.410 --> 00:12:20.930
所以我的笑脸在顶部

00:12:18.210 --> 00:12:23.640
提醒我哪个更好

00:12:20.930 --> 00:12:25.620
性能，所以在这里我们可以看到

00:12:23.640 --> 00:12:28.050
 lambda表达式在

00:12:25.620 --> 00:12:30.750
匿名内部类不是很多

00:12:28.050 --> 00:12:32.700
相当相当，但lambda 

00:12:30.750 --> 00:12:35.220
表情现在表现更好

00:12:32.700 --> 00:12:37.860
显然，Oracle具有很多性能

00:12:35.220 --> 00:12:39.030
测试lambda表达式，并

00:12:37.860 --> 00:12:41.130
有很多不同类型的

00:12:39.030 --> 00:12:43.110
匿名内部类和lambda 

00:12:41.130 --> 00:12:45.510
表达式，所以它们的表现

00:12:43.110 --> 00:12:46.830
根据您的操作而变化

00:12:45.510 --> 00:12:48.990
如果您对ins和

00:12:46.830 --> 00:12:51.000
您可以点击此链接

00:12:48.990 --> 00:12:53.250
在这里，那将带您到很多地方

00:12:51.000 --> 00:12:54.810
关于性能的更深入的文档

00:12:53.250 --> 00:12:56.910
测试新事物

00:12:54.810 --> 00:12:58.500
示例，您有时会看到lambda 

00:12:56.910 --> 00:13:01.410
这是一个表达

00:12:58.500 --> 00:13:03.420
略带红色的颜色比

00:13:01.410 --> 00:13:06.270
匿名攻击，有时是

00:13:03.420 --> 00:13:07.980
不太好，所以答案通常是

00:13:06.270 --> 00:13:11.210
性能相当相似，但

00:13:07.980 --> 00:13:11.210
不完全一样

00:13:12.620 --> 00:13:17.730
在性能分析方面

00:13:15.300 --> 00:13:19.860
 Lambda表达式快于或慢于

00:13:17.730 --> 00:13:21.810
比匿名内部类型好

00:13:19.860 --> 00:13:23.760
大致相同，这意味着

00:13:21.810 --> 00:13:25.620
您可以继续进行重构

00:13:23.760 --> 00:13:28.350
自动运行而不必担心太多

00:13:25.620 --> 00:13:30.020
关于它，但是如果真的很重要

00:13:28.350 --> 00:13:32.010
那么显然你想衡量每个

00:13:30.020 --> 00:13:33.720
个别实例以确保

00:13:32.010 --> 00:13:37.050
它没有增加一些性能

00:13:33.720 --> 00:13:39.360
开销，这是直的

00:13:37.050 --> 00:13:41.430
将匿名类型替换为

00:13:39.360 --> 00:13:42.990
 lambda表达式，还有更多

00:13:41.430 --> 00:13:45.060
有趣的是我们的一些模式

00:13:42.990 --> 00:13:47.310
现在可以跟随，因为我们有能力

00:13:45.060 --> 00:13:49.230
绕过行为而不仅仅是

00:13:47.310 --> 00:13:50.760
对象，所以我们要找到一些

00:13:49.230 --> 00:13:54.030
我们代码中可以开始的地方

00:13:50.760 --> 00:13:56.430
传递lambda表达式我所拥有的

00:13:54.030 --> 00:13:58.560
完成是我创建了结构搜索

00:13:56.430 --> 00:14:12.150
让我们看一下结构

00:13:58.560 --> 00:14:15.600
搜索，所以我创建了一个搜索

00:14:12.150 --> 00:14:18.390
要寻找任何日志的呼叫

00:14:15.600 --> 00:14:19.770
与任何消息和我想要的水平

00:14:18.390 --> 00:14:21.390
我要做的是用

00:14:19.770 --> 00:14:23.250
需要lambda的东西

00:14:21.390 --> 00:14:25.320
表达，我会告诉你为什么

00:14:23.250 --> 00:14:28.470
分钟，如果我们看一个例子

00:14:25.320 --> 00:14:30.300
这些我们现在正在进行日志调试

00:14:28.470 --> 00:14:32.210
通常在大多数代码库中

00:14:30.300 --> 00:14:38.490
你会看起来像这样

00:14:32.210 --> 00:14:40.290
看看是否启用了调试，然后执行该操作

00:14:38.490 --> 00:14:44.250
原因是为什么

00:14:40.290 --> 00:14:46.290
因为很明显的检查

00:14:44.250 --> 00:14:48.150
它可能在debug方法中， 

00:14:46.290 --> 00:14:49.470
实际上可能也是，但是

00:14:48.150 --> 00:14:52.530
将其包装在if语句中的原因

00:14:49.470 --> 00:14:54.420
这就是你在这里

00:14:52.530 --> 00:14:57.650
建立一个字符串，您正在创建一个

00:14:54.420 --> 00:15:01.500
在这种情况下，这是新字符串

00:14:57.650 --> 00:15:04.320
字段是一个列表，所以它就可以了

00:15:01.500 --> 00:15:05.880
列出并建立一个字符串

00:15:04.320 --> 00:15:08.280
这是所有

00:15:05.880 --> 00:15:11.220
该列表中的项目，然后将其附加到

00:15:08.280 --> 00:15:13.320
我要调试的阶段事物

00:15:11.220 --> 00:15:15.540
现在，使用该字符串的方法

00:15:13.320 --> 00:15:17.100
您可能不希望生产

00:15:15.540 --> 00:15:18.900
在调试级别，因此您已经产生了

00:15:17.100 --> 00:15:19.950
何时建立该字符串的成本

00:15:18.900 --> 00:15:22.260
您不需要它，因为您不需要

00:15:19.950 --> 00:15:23.170
实际以该级别进行记录

00:15:22.260 --> 00:15:25.690
我去谈谈

00:15:23.170 --> 00:15:27.610
我们这样做是为了如果我们通过

00:15:25.690 --> 00:15:29.860
在lambda表达式中，我们在做什么

00:15:27.610 --> 00:15:31.540
这是我们传递的食谱

00:15:29.860 --> 00:15:33.639
如何创建该字符串，但我们不是

00:15:31.540 --> 00:15:35.649
创建那个字符串，我们

00:15:33.639 --> 00:15:38.589
懒惰地去做，所以让我删除

00:15:35.649 --> 00:15:40.540
如果您想知道的话，这里

00:15:38.589 --> 00:15:41.860
我正在使用什么快捷方式

00:15:40.540 --> 00:15:43.329
向下闪烁

00:15:41.860 --> 00:15:48.070
屏幕上可以看到我使用的快捷方式

00:15:43.329 --> 00:15:50.040
习惯于尝试快速导航，因此

00:15:48.070 --> 00:15:55.139
在这里，我将创建此方法

00:15:50.040 --> 00:15:59.050
这将需要一个字符串供应商

00:15:55.139 --> 00:16:01.899
我们称它为字符串供应商

00:15:59.050 --> 00:16:03.850
记录器界面由

00:16:01.899 --> 00:16:05.649
现在的不同实现数量

00:16:03.850 --> 00:16:06.940
我不想做的是我不想

00:16:05.649 --> 00:16:09.300
进入其中的每一个

00:16:06.940 --> 00:16:11.320
实现并创建相同的

00:16:09.300 --> 00:16:12.970
此调试方法的实现

00:16:11.320 --> 00:16:14.920
因为我实际上知道这个调试

00:16:12.970 --> 00:16:17.019
消息应该这样做，让我们创建

00:16:14.920 --> 00:16:19.500
 Java 8中的另一项新功能

00:16:17.019 --> 00:16:23.199
我界面上的默认方法

00:16:19.500 --> 00:16:31.449
我不小心跟了

00:16:23.199 --> 00:16:32.890
那然后这个默认方法是

00:16:31.449 --> 00:16:34.930
要检查是否

00:16:32.890 --> 00:16:39.420
调试在那里启用，然后我

00:16:34.930 --> 00:16:42.190
要去调试字符串供应商呢

00:16:39.420 --> 00:16:44.199
现在的区别是

00:16:42.190 --> 00:16:46.060
只有在这一点上，我们建立

00:16:44.199 --> 00:16:47.890
字符串，所以仅在这一点上

00:16:46.060 --> 00:16:51.010
产生创建该字符串的成本

00:16:47.890 --> 00:16:53.079
而将其作为

00:16:51.010 --> 00:16:55.269
默认方法是现在

00:16:53.079 --> 00:16:57.370
由所有实现继承

00:16:55.269 --> 00:16:58.630
我不必放这个接口

00:16:57.370 --> 00:17:03.670
在所有的实施

00:16:58.630 --> 00:17:04.870
个体实例的实现

00:17:03.670 --> 00:17:06.370
出于性能考虑，这很好

00:17:04.870 --> 00:17:07.329
我们来看看性能

00:17:06.370 --> 00:17:09.880
一会儿你会看到

00:17:07.329 --> 00:17:12.490
但它的好处是减少

00:17:09.880 --> 00:17:15.660
复制和粘贴错误之类的东西让我

00:17:12.490 --> 00:17:15.660
给你看一个例子

00:17:24.520 --> 00:17:30.350
所以这是一个调试的例子

00:17:28.310 --> 00:17:32.540
代码中的语句，它说

00:17:30.350 --> 00:17:34.580
日志点已启用跟踪，但实际上

00:17:32.540 --> 00:17:36.650
记录的信息级别不是

00:17:34.580 --> 00:17:38.120
就复制粘贴错误而言并不常见

00:17:36.650 --> 00:17:39.350
我们要复制这个事实

00:17:38.120 --> 00:17:41.510
从其他地方开始

00:17:39.350 --> 00:17:44.300
改变外观水平，现在

00:17:41.510 --> 00:17:46.190
我们实际上可以像现在这样传递

00:17:44.300 --> 00:17:48.680
我们正在内部的if语句

00:17:46.190 --> 00:17:51.230
例如信息法院，那么我不需要

00:17:48.680 --> 00:17:52.910
这个，我知道我做对了

00:17:51.230 --> 00:17:53.810
方法内部的东西，所以我减少了

00:17:52.910 --> 00:17:55.190
这些复制/粘贴

00:17:53.810 --> 00:17:57.440
通过传递这些lambda错误

00:17:55.190 --> 00:17:59.270
周围的表情，所以我们不仅

00:17:57.440 --> 00:18:01.580
对性能有影响，但我们

00:17:59.270 --> 00:18:06.800
也有可能减少

00:18:01.580 --> 00:18:08.360
错误也是如此，让我们看一下

00:18:06.800 --> 00:18:10.010
我在这里的表现

00:18:08.360 --> 00:18:12.860
性能测试

00:18:10.010 --> 00:18:15.830
我在不同的情况下

00:18:12.860 --> 00:18:18.080
用一个常量字符串记录

00:18:15.830 --> 00:18:19.970
总是一样的东西-当我登录时

00:18:18.080 --> 00:18:22.400
带有lambda表达式

00:18:19.970 --> 00:18:24.350
第三个字符串之前的常量字符串

00:18:22.400 --> 00:18:26.330
我们使用的字符串是

00:18:24.350 --> 00:18:27.590
改变我将要追加一些

00:18:26.330 --> 00:18:29.150
新价值到此为止，您可以

00:18:27.590 --> 00:18:32.180
看到这只是一个非常简单的更改， 

00:18:29.150 --> 00:18:33.800
第三个人我第四个人

00:18:32.180 --> 00:18:36.350
与传递lambda表达式

00:18:33.800 --> 00:18:38.720
同样的事情，但这个会很懒

00:18:36.350 --> 00:18:41.360
评估外观，以便我们

00:18:38.720 --> 00:18:44.210
没有记录我们没有的字符串

00:18:41.360 --> 00:18:45.710
产生创建它的成本，我们可以

00:18:44.210 --> 00:18:48.350
看到这里的表现是

00:18:45.710 --> 00:18:50.030
当我们

00:18:48.350 --> 00:18:51.680
实际上必须创建一个字符串

00:18:50.030 --> 00:18:53.720
我们不需要我们变得很贫穷

00:18:51.680 --> 00:18:55.880
该特定测试的性能

00:18:53.720 --> 00:18:57.530
通过引入相关评估

00:18:55.880 --> 00:18:59.570
使用lambda表达式

00:18:57.530 --> 00:19:06.170
在我们的表现中赢得了相当快的胜利

00:18:59.570 --> 00:19:07.520
代码，所以这是一件好事

00:19:06.170 --> 00:19:09.170
绝对应该考虑一下

00:19:07.520 --> 00:19:14.330
我们可以在其中使用lambda表达式

00:19:09.170 --> 00:19:16.130
我所有的那种懒惰的评价

00:19:14.330 --> 00:19:18.740
我真的很想明确地谈论

00:19:16.130 --> 00:19:20.480
关于lambda表达式，我有办法

00:19:18.740 --> 00:19:22.010
更多关于收藏的话题

00:19:20.480 --> 00:19:23.690
和流，因为有很多

00:19:22.010 --> 00:19:26.090
重构的机会

00:19:23.690 --> 00:19:29.840
在集合上使用新方法

00:19:26.090 --> 00:19:31.880
流API文件

00:19:29.840 --> 00:19:33.590
最简单的事情基本上是

00:19:31.880 --> 00:19:36.020
随处找到您正在使用的

00:19:33.590 --> 00:19:38.450
之前的for循环并将其替换为

00:19:36.020 --> 00:19:41.059
现在每种方法的集合

00:19:38.450 --> 00:19:42.409
自己每个都有一个，所以你

00:19:41.059 --> 00:19:44.480
不一定必须使用

00:19:42.409 --> 00:19:46.190
流API，所以有时它是点流

00:19:44.480 --> 00:19:48.590
每个点，有时会是

00:19:46.190 --> 00:19:50.150
只是每个集合上的一个点

00:19:48.590 --> 00:19:59.570
我们将看到不同的例子

00:19:50.150 --> 00:20:03.549
这些让我们回到这里的代码

00:19:59.570 --> 00:20:05.809
我们所要寻找的是

00:20:03.549 --> 00:20:12.580
循环可以与流折叠

00:20:05.809 --> 00:20:12.580
 API，如果我们看这里的第一个示例

00:20:12.850 --> 00:20:18.370
它说可以用for折叠

00:20:15.649 --> 00:20:22.039
每一个，如果我这样做

00:20:18.370 --> 00:20:25.880
输入，然后用分别替换

00:20:22.039 --> 00:20:27.980
我已经完全删除了for循环

00:20:25.880 --> 00:20:30.740
完全替换为

00:20:27.980 --> 00:20:34.730
每个都有我想要的方法的名称

00:20:30.740 --> 00:20:36.350
立即召集该集合中的每个实体

00:20:34.730 --> 00:20:38.659
我现在可以再走一步，因为我

00:20:36.350 --> 00:20:40.429
意识到这个实体的变量是

00:20:38.659 --> 00:20:44.600
仅在这里使用，所以我要内联

00:20:40.429 --> 00:20:46.190
这个，然后再这个，我们的

00:20:44.600 --> 00:20:47.480
变量将在这里使用，所以我

00:20:46.190 --> 00:20:50.570
也要内联

00:20:47.480 --> 00:20:52.370
所以我实际上已经删除了很多

00:20:50.570 --> 00:20:55.549
样板，我真的

00:20:52.370 --> 00:20:58.190
这样做是推断此for循环，我使用for 

00:20:55.549 --> 00:21:02.390
每个，我将称之为这张地图

00:20:58.190 --> 00:21:03.980
这里的方法非常简单

00:21:02.390 --> 00:21:10.340
例子让我们看一下

00:21:03.980 --> 00:21:12.080
更复杂的例子在这里，我们有一个

00:21:10.340 --> 00:21:14.690
 for循环后跟for循环

00:21:12.080 --> 00:21:16.490
在if语句中，在if中

00:21:14.690 --> 00:21:20.360
声明我们将要添加的东西

00:21:16.490 --> 00:21:23.380
另一个收藏，让我们看看

00:21:20.360 --> 00:21:26.890
 IntelliJ建议我们可以更换

00:21:23.380 --> 00:21:30.970
现在，每个人都用脚

00:21:26.890 --> 00:21:33.940
剖析一下我们的坠落者

00:21:30.970 --> 00:21:36.880
如果有的话，用脚代替

00:21:33.940 --> 00:21:39.550
发现进入过滤器的方式

00:21:36.880 --> 00:21:42.940
在流上调用它，我们

00:21:39.550 --> 00:21:45.550
实际使用地图来创建这个新的

00:21:42.940 --> 00:21:47.530
约束违反的东西是

00:21:45.550 --> 00:21:52.510
需要添加到我们的东西

00:21:47.530 --> 00:21:56.530
设置为如果我们崩溃了，则为

00:21:52.510 --> 00:21:57.970
进入过滤器地图，并针对每个呼叫

00:21:56.530 --> 00:22:01.150
我很想简化一下

00:21:57.970 --> 00:22:07.060
只是为了提高可读性，我可能

00:22:01.150 --> 00:22:09.550
称为违反创建行为，但这就是

00:22:07.060 --> 00:22:10.840
完全取决于您，所以我们

00:22:09.550 --> 00:22:12.700
设法简化了代码

00:22:10.840 --> 00:22:15.400
一点，但我们仍然有这个外循环

00:22:12.700 --> 00:22:16.360
在这里，对我来说，我会看这个

00:22:15.400 --> 00:22:18.340
想得好，也许有些事

00:22:16.360 --> 00:22:20.020
周围的设计不是很好

00:22:18.340 --> 00:22:22.570
因为我们在这里做的是

00:22:20.020 --> 00:22:24.430
传入另一个集合，然后

00:22:22.570 --> 00:22:26.140
做多次迭代

00:22:24.430 --> 00:22:28.360
迭代，因为我们在这里迭代

00:22:26.140 --> 00:22:29.530
这实际上是一个迭代， 

00:22:28.360 --> 00:22:31.240
然后我们将东西添加到另一个

00:22:29.530 --> 00:22:32.770
收集，所以我会看看这个和

00:22:31.240 --> 00:22:35.050
我会很好想，也许很好

00:22:32.770 --> 00:22:37.630
重构需要加强

00:22:35.050 --> 00:22:39.070
退后一步，看看

00:22:37.630 --> 00:22:41.020
调用此方法的方法

00:22:39.070 --> 00:22:42.370
看看事情是否可以重组为

00:22:41.020 --> 00:22:44.890
能够在单个流中做到这一点

00:22:42.370 --> 00:22:51.700
操作让我们看另一个例子

00:22:44.890 --> 00:22:53.890
这里我们有一个if语句

00:22:51.700 --> 00:22:56.110
循环另一个if语句进行循环和

00:22:53.890 --> 00:22:58.570
然后，如果和其他，这是一个相当

00:22:56.110 --> 00:23:00.340
现在，逻辑很复杂，因为我们

00:22:58.570 --> 00:23:02.050
有一个if和else我们有两个代码

00:23:00.340 --> 00:23:03.700
设置了路径，所以我们知道这不可能

00:23:02.050 --> 00:23:07.120
崩溃成一条小溪

00:23:03.700 --> 00:23:15.580
在这里进行操作，但我们将看到

00:23:07.120 --> 00:23:16.310
我们现在可以在这里做IntelliJ已经采取了

00:23:15.580 --> 00:23:18.080
看着

00:23:16.310 --> 00:23:19.970
决定可以做更多一点

00:23:18.080 --> 00:23:22.100
复杂的事情，因为我们有两个

00:23:19.970 --> 00:23:24.710
我们已经有效地结束了四个循环

00:23:22.100 --> 00:23:26.810
每个有四个，还有一个平面图， 

00:23:24.710 --> 00:23:30.710
平面图是由于

00:23:26.810 --> 00:23:33.320
第二个第二个秋天在那里， 

00:23:30.710 --> 00:23:35.960
如果陈述已经反映到

00:23:33.320 --> 00:23:38.920
过滤器，所以我们实际上有相同的

00:23:35.960 --> 00:23:46.310
功能相同的功能就在

00:23:38.920 --> 00:23:48.170
使用流API，这是什么

00:23:46.310 --> 00:23:50.090
有趣的是性能测试

00:23:48.170 --> 00:23:52.820
我与古典之间的区别

00:23:50.090 --> 00:23:54.560
 for循环和每个是否新

00:23:52.820 --> 00:23:55.910
您是否在使用流，所以这是

00:23:54.560 --> 00:23:58.970
我们的第一个例子我们的简单例子

00:23:55.910 --> 00:24:01.490
我们用一个简单的替换它

00:23:58.970 --> 00:24:02.930
打电话给草料，在这里我们找到

00:24:01.490 --> 00:24:04.700
性能几乎就是

00:24:02.930 --> 00:24:06.740
一样，所以我们真的不需要担心

00:24:04.700 --> 00:24:09.920
关于我们是否决定做太多

00:24:06.740 --> 00:24:12.980
这个或没有一个更复杂的例子

00:24:09.920 --> 00:24:16.250
使用平面地图以及

00:24:12.980 --> 00:24:17.420
再次过滤性能是一种

00:24:16.250 --> 00:24:19.340
更多更少相同，所以我们可以使

00:24:17.420 --> 00:24:21.110
关于我们是否要做的决定

00:24:19.340 --> 00:24:22.430
这种基于性能的压裂

00:24:21.110 --> 00:24:23.810
我们可以说这并不重要，我们

00:24:22.430 --> 00:24:25.850
如果需要，可以应用此重构

00:24:23.810 --> 00:24:27.260
到，但我们仍然要看这个

00:24:25.850 --> 00:24:29.000
决定我们是否认为这还更多

00:24:27.260 --> 00:24:31.370
可读，因为我们仍然有

00:24:29.000 --> 00:24:33.920
另一个if语句在这里，我们

00:24:31.370 --> 00:24:36.500
里面确实有这个丑陋的if-else 

00:24:33.920 --> 00:24:38.240
所以对我来说，有空间

00:24:36.500 --> 00:24:40.250
可读性还有余地

00:24:38.240 --> 00:24:41.990
在那里重构，我们可以期待IDE 

00:24:40.250 --> 00:24:47.210
应该为我们神奇地做到这一点

00:24:41.990 --> 00:24:49.490
还有第三个例子，我们删除了这个

00:24:47.210 --> 00:24:52.730
完全开放的if语句进入过滤器

00:24:49.490 --> 00:24:55.190
并在这里映射性能相当

00:24:52.730 --> 00:24:57.650
反映的代码更糟，但这是

00:24:55.190 --> 00:25:00.050
不开心大约占一半

00:24:57.650 --> 00:25:02.420
每毫秒的操作数

00:25:00.050 --> 00:25:03.860
十分之一，但这不是

00:25:02.420 --> 00:25:06.380
理想的地方不完全一样

00:25:03.860 --> 00:25:08.120
性能，这似乎很不错

00:25:06.380 --> 00:25:09.530
令人困惑，因为它仍然在做

00:25:08.120 --> 00:25:11.420
和其他一些例子一样

00:25:09.530 --> 00:25:13.790
实际上可以说它在做些微

00:25:11.420 --> 00:25:16.280
更少，因为没有平面图

00:25:13.790 --> 00:25:18.140
这不是一个如此复杂的例子

00:25:16.280 --> 00:25:20.600
如果你看看这些的表现

00:25:18.140 --> 00:25:21.980
举例来说，我们正在

00:25:20.600 --> 00:25:23.420
零点每操作六个

00:25:21.980 --> 00:25:26.330
毫秒不是很多

00:25:23.420 --> 00:25:27.920
操作，所以可能是那件事

00:25:26.330 --> 00:25:29.410
发生的循环是相当

00:25:27.920 --> 00:25:31.750
昂贵和

00:25:29.410 --> 00:25:33.610
遍历循环不是最

00:25:31.750 --> 00:25:35.830
因此，这段代码中昂贵的东西

00:25:33.610 --> 00:25:37.150
无论您使用for循环还是每个

00:25:35.830 --> 00:25:39.550
并不会真正影响您的整体

00:25:37.150 --> 00:25:41.530
性能，而在这里

00:25:39.550 --> 00:25:43.990
每秒近一千次操作

00:25:41.530 --> 00:25:46.120
在这种情况下，可能是使用

00:25:43.990 --> 00:25:49.300
流API已添加了其他功能

00:25:46.120 --> 00:25:55.330
为此的开销

00:25:49.300 --> 00:25:57.490
这些特别是它

00:25:55.330 --> 00:26:00.100
鉴于您将重构任何

00:25:57.490 --> 00:26:01.630
 for循环为每个孔使用a 

00:26:00.100 --> 00:26:03.520
有时候会很外国

00:26:01.630 --> 00:26:04.960
明智的表现，有时你

00:26:03.520 --> 00:26:06.130
不得不考虑是否

00:26:04.960 --> 00:26:11.200
给你任何东西

00:26:06.130 --> 00:26:13.360
可读性或性能下

00:26:11.200 --> 00:26:15.700
很简单的事情

00:26:13.360 --> 00:26:22.060
重构将for循环变成了

00:26:15.700 --> 00:26:26.950
收款，所以如果我们看看

00:26:22.060 --> 00:26:30.160
这个例子现在我们在这里

00:26:26.950 --> 00:26:31.990
复杂之处在于我们

00:26:30.160 --> 00:26:34.300
我们要做的是遍历

00:26:31.990 --> 00:26:36.340
键，我们将IDS添加到

00:26:34.300 --> 00:26:37.870
 ID的列表，所以听起来像是

00:26:36.340 --> 00:26:39.610
收集的经典问题

00:26:37.870 --> 00:26:41.080
但是这个ArrayList正在

00:26:39.610 --> 00:26:43.750
用初始容量初始化

00:26:41.080 --> 00:26:45.850
这不能意味着鼓励

00:26:43.750 --> 00:26:47.980
不能自动将其变成

00:26:45.850 --> 00:26:51.640
收集陈述，所以我要假设

00:26:47.980 --> 00:26:53.290
可以用红色测试以查看

00:26:51.640 --> 00:26:54.910
这是否对性能有影响

00:26:53.290 --> 00:26:57.130
所以首先我要删除

00:26:54.910 --> 00:26:59.410
初始容量，以便我可以

00:26:57.130 --> 00:27:00.880
现在我可以更轻松地重构它了

00:26:59.410 --> 00:27:04.570
用collect语句代替

00:27:00.880 --> 00:27:08.980
最后我得到了一种经典

00:27:04.570 --> 00:27:11.410
收集我要从中映射的位置

00:27:08.980 --> 00:27:15.520
键只是获取ID并返回列表

00:27:11.410 --> 00:27:18.000
此键列表中的ID让我们来看一下

00:27:15.520 --> 00:27:18.000
在另一个例子

00:27:25.970 --> 00:27:29.220
所以在这个例子中，我们正在做一些事情

00:27:28.380 --> 00:27:32.460
相当相似

00:27:29.220 --> 00:27:37.260
我们正在填充有效字段的列表

00:27:32.460 --> 00:27:40.409
与此相关的一些字段子集

00:27:37.260 --> 00:27:41.519
字段列表，我们实际上可以看到

00:27:40.409 --> 00:27:47.370
我们正在尝试做，我们将忽略

00:27:41.519 --> 00:27:49.470
静态字段和最终字段，让我们开始吧

00:27:47.370 --> 00:27:51.659
 IntelliJ将场所替换为

00:27:49.470 --> 00:27:53.549
现在收集我想要的陈述

00:27:51.659 --> 00:27:55.590
我要做的就是摆脱这个

00:27:53.549 --> 00:27:57.929
发表评论，因为评论说

00:27:55.590 --> 00:28:01.620
代码不是很清楚，所以实际上

00:27:57.929 --> 00:28:03.960
我们可以做的就是通过

00:28:01.620 --> 00:28:13.200
提取方法间的调用

00:28:03.960 --> 00:28:15.440
这不是静态的还是最终的，然后我们

00:28:13.200 --> 00:28:19.830
可以完全摆脱此评论我

00:28:15.440 --> 00:28:21.570
会认为在这种情况下，这是

00:28:19.830 --> 00:28:23.850
更具可读性，因此我们正在过滤掉

00:28:21.570 --> 00:28:26.130
只有我们想要的东西

00:28:23.850 --> 00:28:27.419
不是静态的还是最终的，我们是

00:28:26.130 --> 00:28:29.100
将新闻收集到新列表中，以及

00:28:27.419 --> 00:28:31.470
返回该列表，所以还有更多

00:28:29.100 --> 00:28:32.760
可读性比以前还高

00:28:31.470 --> 00:28:40.139
从样板中取出并

00:28:32.760 --> 00:28:40.580
显然有评论，让我们来看

00:28:40.139 --> 00:28:43.580
在

00:28:40.580 --> 00:28:44.990
对于这个第一个例子我想要什么

00:28:43.580 --> 00:28:46.850
正如我提到的那样要做

00:28:44.990 --> 00:28:49.100
性能测试是否初始

00:28:46.850 --> 00:28:51.200
数组分配对

00:28:49.100 --> 00:28:53.659
性能，所以我正在用

00:28:51.200 --> 00:28:55.880
数组分配，没有它，然后

00:28:53.659 --> 00:28:59.899
我正在使用

00:28:55.880 --> 00:29:01.789
地图和游戏以及我们在此发现的内容

00:28:59.899 --> 00:29:03.860
十个清单的特殊情况

00:29:01.789 --> 00:29:06.200
不是很多的元素

00:29:03.860 --> 00:29:08.779
预先分配的原始代码

00:29:06.200 --> 00:29:10.100
 ArrayList大小的更大

00:29:08.779 --> 00:29:12.049
表现比其他任何一个

00:29:10.100 --> 00:29:14.600
比它表现更好的例子

00:29:12.049 --> 00:29:16.639
没有数组大小的简化代码

00:29:14.600 --> 00:29:18.649
它的性能比重构的要好

00:29:16.639 --> 00:29:21.950
代码并与十项并行

00:29:18.649 --> 00:29:24.679
基本上我们甚至不谈论它

00:29:21.950 --> 00:29:27.679
如果我们甚至没有出现在图表上

00:29:24.679 --> 00:29:29.419
在列表中添加更多元素

00:29:27.679 --> 00:29:32.120
我们正在迭代中

00:29:29.419 --> 00:29:33.799
案例10,000个元素，那么我们看到

00:29:32.120 --> 00:29:35.210
列表大小的初始分配

00:29:33.799 --> 00:29:37.370
真的开始变得很少

00:29:35.210 --> 00:29:40.700
差异和并行开始成为

00:29:37.370 --> 00:29:42.470
性能更高，但我们的重构

00:29:40.700 --> 00:29:45.440
代码仍然不能像

00:29:42.470 --> 00:29:47.480
以及其他例子，当我

00:29:45.440 --> 00:29:51.159
把我的数量级，但就是

00:29:47.480 --> 00:29:53.510
是它的确性能稍差

00:29:51.159 --> 00:29:54.980
我们在这里看到的另一个例子

00:29:53.510 --> 00:29:58.399
不能摆脱这个

00:29:54.980 --> 00:30:02.649
用过滤器替换评论

00:29:58.399 --> 00:30:05.149
现在在这里智能化重构代码

00:30:02.649 --> 00:30:07.370
表现比原始代码差

00:30:05.149 --> 00:30:09.559
在这种情况下，我认为是因为

00:30:07.370 --> 00:30:12.889
你在凸起的点流中做

00:30:09.559 --> 00:30:16.460
您正在使用的代码是

00:30:12.889 --> 00:30:19.190
数组，现在您必须要做

00:30:16.460 --> 00:30:20.870
上游的数组，所以可能不是

00:30:19.190 --> 00:30:22.519
成为一种高效的我们将谈论

00:30:20.870 --> 00:30:24.399
关于这一点

00:30:22.519 --> 00:30:28.490
稍后的

00:30:24.399 --> 00:30:30.760
所以自动从

00:30:28.490 --> 00:30:32.960
 for循环到collect语句中， 

00:30:30.760 --> 00:30:34.399
您将必须小心a 

00:30:32.960 --> 00:30:37.580
关于那个性能的一点点

00:30:34.399 --> 00:30:38.600
代码，如果您愿意的话

00:30:37.580 --> 00:30:41.120
关于你可能要表现的

00:30:38.600 --> 00:30:43.309
现在要写一些测试

00:30:41.120 --> 00:30:45.889
是时候聊一点或有

00:30:43.309 --> 00:30:47.809
一点小小的警告

00:30:45.889 --> 00:30:50.179
这些事情中的一些

00:30:47.809 --> 00:30:51.889
性能影响可能是相当大的

00:30:50.179 --> 00:30:53.990
没什么像我说的那样

00:30:51.889 --> 00:30:55.910
大概速度的一半

00:30:53.990 --> 00:30:59.870
但是我们谈论的是微基准测试

00:30:55.910 --> 00:31:02.630
只是在这种方法中进行基准测试

00:30:59.870 --> 00:31:04.640
特定情况下，此代码实际上是

00:31:02.630 --> 00:31:06.770
关于代码的

00:31:04.640 --> 00:31:08.630
数据库，因此与某人交谈的成本

00:31:06.770 --> 00:31:11.870
数据库可能更多

00:31:08.630 --> 00:31:14.300
而不是添加成本，然后

00:31:11.870 --> 00:31:17.690
加上的额外费用

00:31:14.300 --> 00:31:19.550
使用Java 8功能如此微

00:31:17.690 --> 00:31:21.350
基准测试很有用，但您必须

00:31:19.550 --> 00:31:23.840
考虑一下这个东西

00:31:21.350 --> 00:31:25.010
整个应用的方案是

00:31:23.840 --> 00:31:26.750
为什么对你来说很重要

00:31:25.010 --> 00:31:29.120
性能测试自动化性能

00:31:26.750 --> 00:31:31.660
测试重要的代码包

00:31:29.120 --> 00:31:31.660
最给你的

00:31:31.990 --> 00:31:36.200
现在这是一个我认为溪流的区域

00:31:34.520 --> 00:31:39.050
我们可以看的地方很有趣

00:31:36.200 --> 00:31:40.880
在以前的一系列代码中

00:31:39.050 --> 00:31:49.309
操作并将其分解为

00:31:40.880 --> 00:31:55.450
单流操作，这是我们的第一个

00:31:49.309 --> 00:31:57.410
例如，我们在这里有一个集合子集

00:31:55.450 --> 00:31:59.390
约束违规，无论它们是什么

00:31:57.410 --> 00:32:02.330
我们将迭代这些添加

00:31:59.390 --> 00:32:04.790
他们进入一个新列表，然后我们进行排序

00:32:02.330 --> 00:32:07.429
该列表，然后我们遍历该列表

00:32:04.790 --> 00:32:09.020
列出并做一些事情，所以我们

00:32:07.429 --> 00:32:12.110
应该能够将其分解为

00:32:09.020 --> 00:32:13.880
单个流操作，因此IntelliJ 

00:32:12.110 --> 00:32:17.350
说我们可以用

00:32:13.880 --> 00:32:19.520
收集有

00:32:17.350 --> 00:32:23.030
弄清楚，因为你有一个排序

00:32:19.520 --> 00:32:25.880
调用这里它可以添加在这里排序

00:32:23.030 --> 00:32:28.520
这是一个相当新的

00:32:25.880 --> 00:32:30.380
 IntelliJ中的智能

00:32:28.520 --> 00:32:31.970
较旧的版本不会飞跃

00:32:30.380 --> 00:32:33.410
值得牢记的是，如果您

00:32:31.970 --> 00:32:35.630
有您要确保的分类线

00:32:33.410 --> 00:32:38.480
你的流操作也是

00:32:35.630 --> 00:32:40.190
排序，然后我们该怎么做，然后我们

00:32:38.480 --> 00:32:42.470
拿这个清单，然后我们迭代

00:32:40.190 --> 00:32:43.730
并做点什么让我觉得

00:32:42.470 --> 00:32:44.630
就像我们可以取代

00:32:43.730 --> 00:32:50.179
直接地

00:32:44.630 --> 00:32:52.010
每个都有一个，我们将做同样的事情

00:32:50.179 --> 00:32:57.050
 for循环正在执行，因此我们进行记录

00:32:52.010 --> 00:32:58.250
行点日志，当然我们不需要

00:32:57.050 --> 00:33:01.040
分配给任何东西，因为

00:32:58.250 --> 00:33:05.820
它不再做任何事情，然后

00:33:01.040 --> 00:33:08.940
我们只是消除风险，所以

00:33:05.820 --> 00:33:11.100
我们最初在这里进行了迭代

00:33:08.940 --> 00:33:13.259
在某种程度上发生的迭代

00:33:11.100 --> 00:33:15.809
可能排序和另一个迭代

00:33:13.259 --> 00:33:17.399
通过这里的列表，我们已经

00:33:15.809 --> 00:33:19.529
崩溃成一条小溪

00:33:17.399 --> 00:33:21.809
操作，所以它有点整洁

00:33:19.529 --> 00:33:23.159
更容易理解，希望我们

00:33:21.809 --> 00:33:27.450
应该会看到对

00:33:23.159 --> 00:33:33.629
性能第二个例子是

00:33:27.450 --> 00:33:35.369
在查询中拉现在可能看起来不像

00:33:33.629 --> 00:33:39.119
喜欢多种操作，所以您

00:33:35.369 --> 00:33:42.269
要做的是您正在对此进行迭代

00:33:39.119 --> 00:33:45.509
您要分配的收藏集

00:33:42.269 --> 00:33:48.389
他们到另一个字段列表，然后

00:33:45.509 --> 00:33:51.330
你正在做字段数组和传递

00:33:48.389 --> 00:33:53.820
变成另一种方法，所以你在做

00:33:51.330 --> 00:33:55.769
至少有两个操作

00:33:53.820 --> 00:33:57.749
在创建新列表时遍历列表

00:33:55.769 --> 00:34:01.440
清单，然后你就把那个

00:33:57.749 --> 00:34:03.539
列出一个我们可以实际看到的数组

00:34:01.440 --> 00:34:06.269
我们可以做些什么来再次改善我们

00:34:03.539 --> 00:34:08.609
在此列表上具有初始容量，因此

00:34:06.269 --> 00:34:10.470
把它变成不是一件容易的事

00:34:08.609 --> 00:34:14.250
我要去的一条收集路

00:34:10.470 --> 00:34:15.809
删除该初始容量，然后

00:34:14.250 --> 00:34:19.679
我要替换它说替换

00:34:15.809 --> 00:34:21.839
现在有两个阵列，这是一些魔术

00:34:19.679 --> 00:34:24.329
我认为，这个特殊的

00:34:21.839 --> 00:34:27.240
重构确实改善了IntelliJ 

00:34:24.329 --> 00:34:29.909
二十六点三，我认为

00:34:27.240 --> 00:34:32.220
它在2017年变得更加智能

00:34:29.909 --> 00:34:34.079
因为当我最后一次演示时

00:34:32.220 --> 00:34:36.089
仍然需要做一些手动步骤

00:34:34.079 --> 00:34:39.629
现在我不必做任何手动操作

00:34:36.089 --> 00:34:41.099
它完成了所有的工作

00:34:39.629 --> 00:34:43.139
我原来的代码，差不多

00:34:41.099 --> 00:34:46.020
完全重写了它，现在我删除了

00:34:43.139 --> 00:34:48.990
这个大小分配是

00:34:46.020 --> 00:34:51.409
 ArrayList使用获取名称

00:34:48.990 --> 00:34:53.730
存储只是将其放入地图中， 

00:34:51.409 --> 00:34:56.010
然后算出我所做的

00:34:53.730 --> 00:34:59.309
这是我已将内容添加到列表中

00:34:56.010 --> 00:35:01.140
然后我打电话给数组

00:34:59.309 --> 00:35:04.170
倒塌成一个

00:35:01.140 --> 00:35:06.089
数组调用并将其排入

00:35:04.170 --> 00:35:08.250
检索字段方法也称为

00:35:06.089 --> 00:35:10.020
所以有很多事情要做

00:35:08.250 --> 00:35:11.579
现在您可能想要处理一些

00:35:10.020 --> 00:35:13.589
这些操作中，您可能想执行

00:35:11.579 --> 00:35:16.250
他们以逐步的步骤看什么

00:35:13.589 --> 00:35:16.250
实际发生

00:35:18.970 --> 00:35:23.230
这个例子，我们有三个

00:35:20.440 --> 00:35:25.420
行动合而为一

00:35:23.230 --> 00:35:27.609
这里的表现不足为奇

00:35:25.420 --> 00:35:30.310
重构的代码比

00:35:27.609 --> 00:35:31.720
原始代码不是通过数百万个订单

00:35:30.310 --> 00:35:33.400
数量级，但确实表现更好

00:35:31.720 --> 00:35:38.530
这很好，它更具可读性， 

00:35:33.400 --> 00:35:42.130
现在可以提高性能

00:35:38.530 --> 00:35:44.349
第二个例子，就像我说的那样

00:35:42.130 --> 00:35:46.060
次幼稚的中间步骤

00:35:44.349 --> 00:35:49.270
重构这个地方，你可能会说我

00:35:46.060 --> 00:35:52.840
要将所有内容收集到列表中

00:35:49.270 --> 00:35:54.790
然后调用它的数组，所以我

00:35:52.840 --> 00:35:56.740
想测试一下性能

00:35:54.790 --> 00:35:58.300
这是什么影响，因为这是

00:35:56.740 --> 00:36:00.340
基本上我们要进行两个操作

00:35:58.300 --> 00:36:02.349
收集然后一个to数组是

00:36:00.340 --> 00:36:04.140
与原始代码相同，然后我

00:36:02.349 --> 00:36:06.490
想要将其与新产品进行比较

00:36:04.140 --> 00:36:11.260
完全重构我们要去的地方

00:36:06.490 --> 00:36:13.960
直接到两个数组，在这里我们可以

00:36:11.260 --> 00:36:15.910
看到与

00:36:13.960 --> 00:36:18.430
两步效果不如

00:36:15.910 --> 00:36:20.109
其他操作和全部

00:36:18.430 --> 00:36:22.330
重构的人几乎表现良好

00:36:20.109 --> 00:36:24.070
作为原始的，这是一个相当

00:36:22.330 --> 00:36:25.750
每秒的操作数很高，因此

00:36:24.070 --> 00:36:30.460
这是一个很好的重构

00:36:25.750 --> 00:36:32.890
逃脱我不得不说的表现

00:36:30.460 --> 00:36:34.510
分析是不确定的，即使我

00:36:32.890 --> 00:36:37.119
这些结果比

00:36:34.510 --> 00:36:38.440
其他人，因为我们再次不是

00:36:37.119 --> 00:36:42.010
更好地谈论数量级

00:36:38.440 --> 00:36:43.570
但是这里的发现是

00:36:42.010 --> 00:36:45.010
对...没有负面影响

00:36:43.570 --> 00:36:49.599
通过做这些特别的表现

00:36:45.010 --> 00:36:51.520
现在重构，我只剩下两个

00:36:49.599 --> 00:36:53.170
研究要展示的东西，然后我们

00:36:51.520 --> 00:36:54.849
会分解一些

00:36:53.170 --> 00:37:00.400
我们发现的一些东西

00:36:54.849 --> 00:37:02.560
得出一些结论

00:37:00.400 --> 00:37:04.270
任何匹配都是一种新的重构

00:37:02.560 --> 00:37:08.790
进来二十三点三

00:37:04.270 --> 00:37:08.790
我举个例子

00:37:15.610 --> 00:37:20.590
如果您如此匹配，我会输掉它

00:37:19.060 --> 00:37:22.720
相当简单的操作

00:37:20.590 --> 00:37:25.060
你要行的地方

00:37:22.720 --> 00:37:26.590
通过一些列表，并尽快

00:37:25.060 --> 00:37:29.770
找到一些匹配的东西

00:37:26.590 --> 00:37:32.140
条件，然后您返回true或false 

00:37:29.770 --> 00:37:37.180
所以可以自动变成

00:37:32.140 --> 00:37:38.770
以及这里的任何匹配操作

00:37:37.180 --> 00:37:40.750
再次，我们只是摆脱了

00:37:38.770 --> 00:37:49.570
迭代代码并保留主

00:37:40.750 --> 00:37:51.460
 if语句中的核心代码

00:37:49.570 --> 00:37:53.230
在这里，我要进行性能测试

00:37:51.460 --> 00:37:55.840
原始代码之间的区别

00:37:53.230 --> 00:37:57.700
新代码更具可读性

00:37:55.840 --> 00:37:59.830
但当然有趣的一点

00:37:57.700 --> 00:38:02.050
这些Java八流中的很多

00:37:59.830 --> 00:38:03.850
操作是瘫痪的能力

00:38:02.050 --> 00:38:06.400
他们，所以我要去性能测试

00:38:03.850 --> 00:38:08.430
这与并行版本相反

00:38:06.400 --> 00:38:08.430
好

00:38:08.520 --> 00:38:13.540
现在原始代码执行得很漂亮

00:38:11.530 --> 00:38:15.190
好吧，反映出来的库尔蒂斯十个人

00:38:13.540 --> 00:38:16.840
列表中的值原始代码

00:38:15.190 --> 00:38:20.710
执行很好的折射代码是

00:38:16.840 --> 00:38:22.930
甚至没有一半的速度和并行

00:38:20.710 --> 00:38:25.120
十个值无处可寻，因为

00:38:22.930 --> 00:38:27.220
成本分摊了十个值

00:38:25.120 --> 00:38:29.380
列出运行在多个内核上的列表

00:38:27.220 --> 00:38:31.120
然后把结果带回来

00:38:29.380 --> 00:38:33.040
对于该数目的而言，开销太大了

00:38:31.120 --> 00:38:34.810
值开始变小

00:38:33.040 --> 00:38:36.670
更有趣的是你在哪里

00:38:34.810 --> 00:38:40.000
一万个值

00:38:36.670 --> 00:38:42.190
清单，但是我们再也看不到

00:38:40.000 --> 00:38:44.590
此处的性能大幅提升，并且

00:38:42.190 --> 00:38:47.350
我认为在这种情况下，我认为

00:38:44.590 --> 00:38:50.950
这是因为我们使用了凸起的圆点

00:38:47.350 --> 00:38:53.710
流和数组迭代是一个

00:38:50.950 --> 00:38:56.500
更重要的是，这是一件好事

00:38:53.710 --> 00:38:58.360
为编译器和CPU做的

00:38:56.500 --> 00:39:00.730
做一件非常可预测的事情

00:38:58.360 --> 00:39:02.590
任何带有直数组类的东西

00:39:00.730 --> 00:39:04.150
因此，当您承担转弯的费用时

00:39:02.590 --> 00:39:05.890
变成流开始与

00:39:04.150 --> 00:39:07.870
你最终会遇到的对象

00:39:05.890 --> 00:39:09.730
相当多的额外费用，您

00:39:07.870 --> 00:39:11.980
可以在这里的表演中看到

00:39:09.730 --> 00:39:13.540
使用确实会影响性能

00:39:11.980 --> 00:39:16.510
流而不是使用直线

00:39:13.540 --> 00:39:18.130
数组，当我们达到一百

00:39:16.510 --> 00:39:19.750
一千个值在这里然后

00:39:18.130 --> 00:39:21.490
并行开始表现优于我们

00:39:19.750 --> 00:39:22.780
两者都有很多因素

00:39:21.490 --> 00:39:25.000
仍然没有真正看到

00:39:22.780 --> 00:39:29.180
使用原始数组的性能

00:39:25.000 --> 00:39:31.999
操作，所以我说的任何匹配

00:39:29.180 --> 00:39:33.769
但这不是任何比赛的错

00:39:31.999 --> 00:39:36.319
实际上是使用加注的问题

00:39:33.769 --> 00:39:38.480
点流执行任何类型的操作

00:39:36.319 --> 00:39:40.519
在凸起的点流上可能正在

00:39:38.480 --> 00:39:41.930
比做的要贵得多

00:39:40.519 --> 00:39:49.640
两种方式直接操作

00:39:41.930 --> 00:39:52.160
特别是对于较小的方法和查找

00:39:49.640 --> 00:40:00.049
首先，这是非常相似的事情

00:39:52.160 --> 00:40:01.519
任何匹配，如果我找到我的例子，这是

00:40:00.049 --> 00:40:04.220
再一次，我们要迭代

00:40:01.519 --> 00:40:06.319
一些列表，一旦我们找到第一个

00:40:04.220 --> 00:40:08.480
然后符合某些条件的东西

00:40:06.319 --> 00:40:12.130
我们要归还那东西，所以我们

00:40:08.480 --> 00:40:17.410
可以先将其替换为

00:40:12.130 --> 00:40:17.410
在这种情况下， 

00:40:18.099 --> 00:40:23.779
我们在凸起的点流中进行

00:40:21.230 --> 00:40:33.349
也可以通过

00:40:23.779 --> 00:40:35.480
说它的流确实一样

00:40:33.349 --> 00:40:37.249
事情只是减少了

00:40:35.480 --> 00:40:41.769
屏幕上的代码量是

00:40:37.249 --> 00:40:41.769
为什么我喜欢那个特定的例子

00:40:42.309 --> 00:40:46.160
所以在这里，我们再次删除了

00:40:44.839 --> 00:40:48.739
一切从if语句放

00:40:46.160 --> 00:40:57.470
它进入过滤器的另一个例子

00:40:48.739 --> 00:40:59.869
这是在我要使用的转换器中

00:40:57.470 --> 00:41:02.390
我们在这里做的同样的事情

00:40:59.869 --> 00:41:07.489
前面的例子我们必须创建我们的

00:41:02.390 --> 00:41:12.009
自己的有效课程流

00:41:07.489 --> 00:41:12.009
我经常

00:41:16.300 --> 00:41:20.709
在这个例子中

00:41:18.309 --> 00:41:22.569
我们正在做一个流，我们正在

00:41:20.709 --> 00:41:27.779
来自此收藏集的流

00:41:22.569 --> 00:41:31.359
列表，在这里我们可以看到我们

00:41:27.779 --> 00:41:33.189
明确说明如果我们返回什么

00:41:31.359 --> 00:41:40.329
什么都没找到所以有一些

00:41:33.189 --> 00:41:41.859
那里的可读性也有所提高，所以让我们

00:41:40.329 --> 00:41:46.269
快速检查性能

00:41:41.859 --> 00:41:48.219
这个很好的第一又没有表现

00:41:46.269 --> 00:41:49.390
与原始版本一样快

00:41:48.219 --> 00:41:51.880
特别是在这里，因为我们正在做一个

00:41:49.390 --> 00:41:53.380
提高了流，我想测试

00:41:51.880 --> 00:41:55.660
凸起点之间的区别

00:41:53.380 --> 00:41:57.160
流和流，然后

00:41:55.660 --> 00:41:59.979
这里的表现是完全一样的

00:41:57.160 --> 00:42:01.839
选择适合我的人

00:41:59.979 --> 00:42:05.559
第二个例子，我们使用

00:42:01.839 --> 00:42:07.029
流API，我们再次没有得到

00:42:05.559 --> 00:42:08.829
与我们一样的表现

00:42:07.029 --> 00:42:11.949
从数组的原始代码中获得

00:42:08.829 --> 00:42:14.109
十个元素的数量，因为我们开始获得很多

00:42:11.949 --> 00:42:15.989
我们开始看到的更大数据

00:42:14.109 --> 00:42:19.809
并行和并行的好处

00:42:15.989 --> 00:42:22.359
也许再次使用重构代码

00:42:19.809 --> 00:42:23.920
在性能方面找到第一

00:42:22.359 --> 00:42:25.569
值得测试，看看是否有

00:42:23.920 --> 00:42:29.170
任何对您的绩效有影响的领域

00:42:25.569 --> 00:42:32.349
特别是对于小阵列

00:42:29.170 --> 00:42:33.609
最后一个例子是删除，如果这是一个

00:42:32.349 --> 00:42:43.239
我最喜欢的例子，我希望

00:42:33.609 --> 00:42:46.269
您将可以在这里看到我所拥有的

00:42:43.239 --> 00:42:48.579
我有一些帮助

00:42:46.269 --> 00:42:51.759
我正在迭代的称为s 

00:42:48.579 --> 00:42:53.229
然后我就从使用

00:42:51.759 --> 00:42:57.009
发生一段时间的while循环

00:42:53.229 --> 00:42:59.799
从迭代器中删除所有内容

00:42:57.009 --> 00:43:02.459
符合某些条件，我可以

00:42:59.799 --> 00:43:05.259
直接将其替换为

00:43:02.459 --> 00:43:07.179
如果我们通过了，则简单删除

00:43:05.259 --> 00:43:09.579
我真正关心的东西的参数

00:43:07.179 --> 00:43:12.459
在这里，我们只是摆脱了所有

00:43:09.579 --> 00:43:15.519
这种如何遍历的废话

00:43:12.459 --> 00:43:17.019
扭转如何获得的集合

00:43:15.519 --> 00:43:19.269
下一个我们不在乎的项目

00:43:17.019 --> 00:43:21.429
我们只是通过lambda 

00:43:19.269 --> 00:43:25.059
表达删除一切

00:43:21.429 --> 00:43:27.459
匹配此特定模式，如果

00:43:25.059 --> 00:43:28.449
我们也来看看，所以在这里你可以

00:43:27.459 --> 00:43:29.769
看到我已经摆脱了所有这些

00:43:28.449 --> 00:43:31.150
样板，如果你看

00:43:29.769 --> 00:43:31.569
性能实际上表现更好

00:43:31.150 --> 00:43:34.150
以及

00:43:31.569 --> 00:43:36.009
所以在这里所有的重构中

00:43:34.150 --> 00:43:37.569
是我最喜欢的一个

00:43:36.009 --> 00:43:40.569
更好的性能，您可以获得更多

00:43:37.569 --> 00:43:42.699
我也不得不说可读性

00:43:40.569 --> 00:43:45.039
没有定论，因为表现是

00:43:42.699 --> 00:43:46.509
不那么好一个数量级

00:43:45.039 --> 00:43:49.599
在这方面稍微好一点

00:43:46.509 --> 00:43:51.279
特殊情况下，我们来看一下

00:43:49.599 --> 00:43:52.660
总结每个-因为我是一种基金

00:43:51.279 --> 00:43:54.459
您有许多不同的重构

00:43:52.660 --> 00:43:55.900
还有很多性能数据，所以我

00:43:54.459 --> 00:43:57.999
真的想总结一下这些东西

00:43:55.900 --> 00:43:59.589
在给予某种东西之前

00:43:57.999 --> 00:44:01.209
关于重构为Java的结论

00:43:59.589 --> 00:44:05.380
八点之后

00:44:01.209 --> 00:44:06.940
是时候提问了，以便重构

00:44:05.380 --> 00:44:08.979
 Lambda表达式代替

00:44:06.940 --> 00:44:11.949
示例匿名内部管道非常

00:44:08.979 --> 00:44:13.119
易于自动化，非常安全

00:44:11.949 --> 00:44:14.109
性能上的明智之举

00:44:13.119 --> 00:44:16.239
差不多一样

00:44:14.109 --> 00:44:17.949
性能，因此您可以根据

00:44:16.239 --> 00:44:20.430
在大多数情况下，请继续

00:44:17.949 --> 00:44:23.109
而且不用担心太多

00:44:20.430 --> 00:44:24.969
为lambda表达式设计

00:44:23.109 --> 00:44:27.400
使用lambda表达式的示例

00:44:24.969 --> 00:44:29.799
懒惰的评估可以给你很大的帮助

00:44:27.400 --> 00:44:33.849
以性能为例

00:44:29.799 --> 00:44:35.769
记录示例，如果您不需要

00:44:33.849 --> 00:44:37.749
产生建立琴弦的费用

00:44:35.769 --> 00:44:40.119
因为那你不打算记录它

00:44:37.749 --> 00:44:41.019
将其包装在lambda表达式中，然后

00:44:40.119 --> 00:44:44.829
你会变得更好

00:44:41.019 --> 00:44:46.630
性能通常

00:44:44.829 --> 00:44:48.910
新习语上的新方法

00:44:46.630 --> 00:44:50.769
收集流API lambda 

00:44:48.910 --> 00:44:52.449
表情等等确实增加了

00:44:50.769 --> 00:44:55.269
可读性我这里有一些例子

00:44:52.449 --> 00:44:57.459
例如，很明显，显而易见的是

00:44:55.269 --> 00:44:59.380
 Lambda表达式与匿名

00:44:57.459 --> 00:45:00.729
内部类只删除所有类型

00:44:59.380 --> 00:45:04.119
您真正不需要的信息

00:45:00.729 --> 00:45:06.459
我正在使用收集而不是使用

00:45:04.119 --> 00:45:10.239
 for循环和添加东西有点

00:45:06.459 --> 00:45:12.640
更具描述性的任何匹配是

00:45:10.239 --> 00:45:14.349
再次多一些描述性，少一些

00:45:12.640 --> 00:45:16.089
代码，但与a无关

00:45:14.349 --> 00:45:17.799
更少的代码，更多的是关于什么

00:45:16.089 --> 00:45:19.509
这件事做得很好，这只是在说

00:45:17.799 --> 00:45:22.959
你，如果有什么与此特定

00:45:19.509 --> 00:45:25.749
标准和相同的东西很好

00:45:22.959 --> 00:45:27.219
第一好第一只是让你

00:45:25.749 --> 00:45:30.130
声明这是我们正在寻找的东西

00:45:27.219 --> 00:45:32.559
对于带有此注释的东西

00:45:30.130 --> 00:45:34.839
当然，如果您丢失了

00:45:32.559 --> 00:45:36.940
整个样板，你就离开了

00:45:34.839 --> 00:45:40.709
只关心你的事

00:45:36.940 --> 00:45:43.559
仅您要删除的模式

00:45:40.709 --> 00:45:46.079
然后当你

00:45:43.559 --> 00:45:47.400
进行多项操作和跟踪

00:45:46.079 --> 00:45:49.650
那些陷入单一的极端

00:45:47.400 --> 00:45:52.019
操作，您将获得很多胜利，因此

00:45:49.650 --> 00:45:53.880
不必有两个四个循环

00:45:52.019 --> 00:45:56.279
与您只有一个流的排序

00:45:53.880 --> 00:45:59.130
对地图进行排序的操作和

00:45:56.279 --> 00:46:00.779
每一个，所以它更容易

00:45:59.130 --> 00:46:04.109
周围的原因，可能更好

00:46:00.779 --> 00:46:06.329
性能，这又是这里

00:46:04.109 --> 00:46:07.920
我们有做过多次

00:46:06.329 --> 00:46:09.689
没有真正意识到它的操作

00:46:07.920 --> 00:46:11.640
因为我们正在收集卡在

00:46:09.689 --> 00:46:13.499
列出，然后对其执行-数组，并

00:46:11.640 --> 00:46:17.009
在这里，我们将其变成一个

00:46:13.499 --> 00:46:18.749
操作，但您确实需要注意

00:46:17.009 --> 00:46:20.999
现在的表现我不是在说你

00:46:18.749 --> 00:46:23.099
必须对每个人进行微基准测试

00:46:20.999 --> 00:46:24.479
这些重构的实例

00:46:23.099 --> 00:46:27.420
但您确实需要了解

00:46:24.479 --> 00:46:28.619
他们当中哪个可能拥有哪个

00:46:27.420 --> 00:46:30.660
它们可能会对性能产生影响

00:46:28.619 --> 00:46:33.209
以及您可能需要离开的

00:46:30.660 --> 00:46:34.920
并检查和测试例如

00:46:33.209 --> 00:46:37.259
我们将要使用的任何地方

00:46:34.920 --> 00:46:39.329
提出极端

00:46:37.259 --> 00:46:42.599
比我说的要慢

00:46:39.329 --> 00:46:44.489
数组上的操作非常有效

00:46:42.599 --> 00:46:46.529
对于计算机，他们很容易推理

00:46:44.489 --> 00:46:48.749
对于编译器来说很容易

00:46:46.529 --> 00:46:50.640
让CPU来回推理

00:46:48.749 --> 00:46:52.739
存储所有这些数组对象

00:46:50.640 --> 00:46:54.989
彼此-数组操作

00:46:52.739 --> 00:46:57.569
遍历数组是非常有效的

00:46:54.989 --> 00:47:01.920
操作，以便数组点流可能是

00:46:57.569 --> 00:47:04.559
失去效率，所以这

00:47:01.920 --> 00:47:06.599
是其中一个使用示例

00:47:04.559 --> 00:47:09.779
数组让你更糟

00:47:06.599 --> 00:47:11.549
使用原始代码的性能

00:47:09.779 --> 00:47:13.049
对于每个或收集可能是

00:47:11.549 --> 00:47:15.239
比遍历集合慢

00:47:13.049 --> 00:47:17.519
这就是答案所在

00:47:15.239 --> 00:47:19.979
因此在某些情况下

00:47:17.519 --> 00:47:22.529
每个给你一半的

00:47:19.979 --> 00:47:24.239
某些速度

00:47:22.529 --> 00:47:25.410
过去很遗憾的情况

00:47:24.239 --> 00:47:27.630
你会得到相同的

00:47:25.410 --> 00:47:29.160
性能才是真正的表现

00:47:27.630 --> 00:47:30.869
取决于你在做什么

00:47:29.160 --> 00:47:34.499
里面的手术费用是多少

00:47:30.869 --> 00:47:36.599
迭代和并行不会进行

00:47:34.499 --> 00:47:38.160
神奇地提高您的速度

00:47:36.599 --> 00:47:40.859
平行不是魔咒

00:47:38.160 --> 00:47:43.019
这将完成所有艰苦的工作

00:47:40.859 --> 00:47:45.029
对你来说，它将给你速度

00:47:43.019 --> 00:47:47.219
如果您的数据很大，则可以进行改进

00:47:45.029 --> 00:47:48.900
例如，这里有10,000 

00:47:47.219 --> 00:47:51.239
我们开始看到元素

00:47:48.900 --> 00:47:53.759
并行化给我们带来了一些好处

00:47:51.239 --> 00:47:56.099
如果您的手术非常昂贵

00:47:53.759 --> 00:47:56.940
那么您可能想要使用多个CPU 

00:47:56.099 --> 00:47:59.430
和格式

00:47:56.940 --> 00:48:02.780
在多个CPU上的情况下

00:47:59.430 --> 00:48:05.550
并行将对您有用

00:48:02.780 --> 00:48:07.230
有时使用这些Java 8功能

00:48:05.550 --> 00:48:10.770
获得更好的可读性和更好的

00:48:07.230 --> 00:48:13.650
性能，例如

00:48:10.770 --> 00:48:17.069
如果可读性更好，请删除

00:48:13.650 --> 00:48:21.150
而且我们也有更好的表现

00:48:17.069 --> 00:48:23.970
让我们总结一下这些是否应该迁移

00:48:21.150 --> 00:48:25.680
您的Java 8代码当然很好

00:48:23.970 --> 00:48:28.589
取决于从来没有一个简单的方法

00:48:25.680 --> 00:48:31.410
回答任何技术问题

00:48:28.589 --> 00:48:33.990
这取决于您必须记住

00:48:31.410 --> 00:48:36.450
您重构的目标是

00:48:33.990 --> 00:48:37.619
目标以获得更好的性能，其中

00:48:36.450 --> 00:48:39.510
情况显然，您将需要

00:48:37.619 --> 00:48:42.750
如果您的目标是测试该性能

00:48:39.510 --> 00:48:44.400
可读性或学习性，那么您需要

00:48:42.750 --> 00:48:46.230
检查重构是否已经给出

00:48:44.400 --> 00:48:47.310
更好的可读性或是否

00:48:46.230 --> 00:48:49.619
实际上从中学到了什么

00:48:47.310 --> 00:48:51.510
使用重构，因此您应该

00:48:49.619 --> 00:48:53.910
比较研究结果

00:48:51.510 --> 00:48:56.819
达到最初的初始目标

00:48:53.910 --> 00:48:58.349
你需要记住的是

00:48:56.819 --> 00:49:00.300
了解哪些事情可能会影响

00:48:58.349 --> 00:49:01.950
性能像使用凸起的点

00:49:00.300 --> 00:49:03.690
流，如果您不确定

00:49:01.950 --> 00:49:05.359
哪些事情会影响

00:49:03.690 --> 00:49:07.950
您需要衡量的性能

00:49:05.359 --> 00:49:09.810
您的工具，例如IntelliJ 

00:49:07.950 --> 00:49:11.520
 IDEA可以真正帮助您实现很多自动化

00:49:09.810 --> 00:49:12.740
这个过程，可以提出建议

00:49:11.520 --> 00:49:15.060
给你，你不知道有可能

00:49:12.740 --> 00:49:17.250
但您确实需要能够看

00:49:15.060 --> 00:49:19.020
它在做什么，如果练习

00:49:17.250 --> 00:49:21.030
您需要查看的性能影响

00:49:19.020 --> 00:49:22.470
看看是否真的有帮助

00:49:21.030 --> 00:49:24.990
在可读性方面

00:49:22.470 --> 00:49:27.599
没有，其中一些例子

00:49:24.990 --> 00:49:29.310
我们向他们展示了重构

00:49:27.599 --> 00:49:32.790
真的表明也许是

00:49:29.310 --> 00:49:37.079
在我们面前解决更大的设计问题

00:49:32.790 --> 00:49:39.569
做这些底层的重构，所以所有的

00:49:37.079 --> 00:49:41.069
参考资料可在以下网址获得

00:49:39.569 --> 00:49:42.900
这个链接还有很多

00:49:41.069 --> 00:49:44.700
有关Java 8的信息，有一个链接

00:49:42.900 --> 00:49:46.470
到此视频的链接

00:49:44.700 --> 00:49:49.619
那里有幻灯片的链接

00:49:46.470 --> 00:49:51.150
链接到代码基本上是所有

00:49:49.619 --> 00:49:54.869
此演讲的资源可用

00:49:51.150 --> 00:49:56.490
现在是停止的好时机， 

00:49:54.869 --> 00:50:03.120
回答所有未曾提出的问题

00:49:56.490 --> 00:50:05.640
回答还可以，谢谢

00:50:03.120 --> 00:50:10.620
介绍，不包括

00:50:05.640 --> 00:50:13.320
我有一个问题，我看到一个问题，为什么

00:50:10.620 --> 00:50:16.170
匿名内部类会是任何

00:50:13.320 --> 00:50:21.090
与卢旺达不同的表现是

00:50:16.170 --> 00:50:22.830
他们不平等的被迫和正确

00:50:21.090 --> 00:50:25.140
好吧，简短的答案是不，他们不是

00:50:22.830 --> 00:50:27.810
它确实看起来像lambda表达式

00:50:25.140 --> 00:50:29.700
匿名内部语法糖

00:50:27.810 --> 00:50:32.010
类型，但实际上不是

00:50:29.700 --> 00:50:33.900
不同的掩护下寻找

00:50:32.010 --> 00:50:36.870
布莱恩参加演讲，因为他

00:50:33.900 --> 00:50:39.060
喜欢整整一个小时，为什么他们不

00:50:36.870 --> 00:50:40.920
甲骨文真的很努力

00:50:39.060 --> 00:50:44.610
确保lambda表达式是

00:50:40.920 --> 00:50:46.710
表现不比匿名者差

00:50:44.610 --> 00:50:48.660
内在类型，但在幕后

00:50:46.710 --> 00:50:50.340
是不一样的，因为基本上

00:50:48.660 --> 00:50:52.470
 Lambda表达式不是完整的类

00:50:50.340 --> 00:50:55.290
匿名内部类型是完整类

00:50:52.470 --> 00:50:57.510
具有相似的标题和内存分配

00:50:55.290 --> 00:51:03.030
而且你知道这是一个成熟的物体

00:50:57.510 --> 00:51:07.920
但是lambda表达式不好

00:51:03.030 --> 00:51:11.880
下一个问题等待等待我们在哪里

00:51:07.920 --> 00:51:16.290
需要更改我们的代码，为什么不是

00:51:11.880 --> 00:51:21.660
如果可能的话，由come编译器处理

00:51:16.290 --> 00:51:24.540
由JIT处理，那么我们就不需要任何

00:51:21.660 --> 00:51:29.630
如果可以通过工厂重构

00:51:24.540 --> 00:51:32.310
它可以由JIT处理的ID 

00:51:29.630 --> 00:51:35.880
这是一个非常有趣的问题， 

00:51:32.310 --> 00:51:38.010
我想大概是短版

00:51:35.880 --> 00:51:40.500
当IntelliJ建议我们

00:51:38.010 --> 00:51:43.500
向您重构并不是说

00:51:40.500 --> 00:51:45.750
新代码与

00:51:43.500 --> 00:51:48.990
泰卢固文掩盖下的旧代码

00:51:45.750 --> 00:51:51.030
建议和要使用的新语法，或

00:51:48.990 --> 00:51:53.670
使用不同的替代语法

00:51:51.030 --> 00:51:55.260
将达到相同的目标，但根据

00:51:53.670 --> 00:51:57.450
涵盖了它没有被编译成

00:51:55.260 --> 00:52:00.990
相同的字节码，尤其是某些

00:51:57.450 --> 00:52:06.150
那些重构和两个数组

00:52:00.990 --> 00:52:09.170
 lon让我们看看是否可以找到它

00:52:06.150 --> 00:52:09.170
幻灯片更好地抓住他们

00:52:14.089 --> 00:52:20.400
是的，这一点在此不鼓励

00:52:18.180 --> 00:52:22.200
对，它与此做相同的事情

00:52:20.400 --> 00:52:24.390
左侧的代码，但不是相同的代码

00:52:22.200 --> 00:52:25.979
但这不是缺少一步

00:52:24.390 --> 00:52:28.259
我们将直接从地图游览到

00:52:25.979 --> 00:52:32.130
一个比率，因此编译后的代码不是

00:52:28.259 --> 00:52:34.529
同样的事情，那是因为

00:52:32.130 --> 00:52:37.289
 IntelliJ可以向您建议

00:52:34.529 --> 00:52:41.160
开发人员这是我认为的事情

00:52:37.289 --> 00:52:42.630
在行为方面做同样的事情

00:52:41.160 --> 00:52:45.029
提供与

00:52:42.630 --> 00:52:46.920
原始代码，但我需要你

00:52:45.029 --> 00:52:48.719
开发人员来决定是否

00:52:46.920 --> 00:52:50.969
是您真正想要的东西

00:52:48.719 --> 00:52:52.890
适用，因为如您所见

00:52:50.969 --> 00:52:54.420
这些表现表明

00:52:52.890 --> 00:52:54.960
这些不是相同的操作

00:52:54.420 --> 00:52:56.910
封面

00:52:54.960 --> 00:52:58.559
所以你需要能够

00:52:56.910 --> 00:53:00.769
做出那些决定的人

00:52:58.559 --> 00:53:03.180
套件可能可以为某些人做出决定

00:53:00.769 --> 00:53:05.430
不是从我给的例子中，而是为了

00:53:03.180 --> 00:53:07.170
有些事情，但提示不会

00:53:05.430 --> 00:53:08.609
走开，说好吧，我认为

00:53:07.170 --> 00:53:10.710
这应该在上游

00:53:08.609 --> 00:53:12.809
操作，因为显然不多了

00:53:10.710 --> 00:53:15.029
高效的一些重构是

00:53:12.809 --> 00:53:18.420
我建议是为了帮助

00:53:15.029 --> 00:53:21.089
开发人员阅读事物并给予

00:53:18.420 --> 00:53:31.229
更高的代码可读性

00:53:21.089 --> 00:53:34.650
帮助JVM更快地运行，好一个

00:53:31.229 --> 00:53:38.039
我们应该执行下一个问题吗

00:53:34.650 --> 00:53:40.619
引用而不是lambda语法哦

00:53:38.039 --> 00:53:42.719
喜欢那个问题，当我第一次

00:53:40.619 --> 00:53:44.489
我真的不喜欢Java 8 

00:53:42.719 --> 00:53:46.109
方法引用我认为这很奇怪

00:53:44.489 --> 00:53:49.349
双冒号的东西有点

00:53:46.109 --> 00:53:54.839
难以理解和难以理解

00:53:49.349 --> 00:53:57.690
圆，但我通常随着时间的流逝

00:53:54.839 --> 00:54:00.420
比起首选方法引用

00:53:57.690 --> 00:54:02.069
 IntelliJ的lambda表达式

00:54:00.420 --> 00:54:04.920
建议我使用方法参考

00:54:02.069 --> 00:54:08.039
这里有一些例子

00:54:04.920 --> 00:54:11.160
不论哪个网站，在此示例中

00:54:08.039 --> 00:54:14.700
地图不是很有用，但让我看看是否

00:54:11.160 --> 00:54:21.619
可以找到一个过滤器的例子

00:54:14.700 --> 00:54:21.619
我们有一个过滤器找到了一些东西

00:54:21.799 --> 00:54:25.920
所以说

00:54:23.220 --> 00:54:30.300
过滤器我可能会说我们得到了什么

00:54:25.920 --> 00:54:33.599
再说一遍我可能会说Tiki不是的钥匙

00:54:30.300 --> 00:54:36.810
等于null并且那是

00:54:33.599 --> 00:54:38.820
很好，但是IntelliJ建议我

00:54:36.810 --> 00:54:42.480
可以用方法参考代替

00:54:38.820 --> 00:54:44.280
表示对象现在非null 

00:54:42.480 --> 00:54:45.869
案例我更喜欢方法参考

00:54:44.280 --> 00:54:49.410
因为我觉得它对我说的非常

00:54:45.869 --> 00:54:53.099
显然，我要您过滤所有

00:54:49.410 --> 00:54:54.540
非null和对象，所以我知道

00:54:53.099 --> 00:54:57.060
我在这张地图上得到的唯一对象

00:54:54.540 --> 00:55:00.270
操作不为null，而在

00:54:57.060 --> 00:55:01.440
以前的版本我必须从字面上看

00:55:00.270 --> 00:55:03.150
不需要很长时间，但我必须

00:55:01.440 --> 00:55:05.160
这意味着什么的原因

00:55:03.150 --> 00:55:07.260
就像不等于null或等于null 

00:55:05.160 --> 00:55:08.580
这意味着不等于是

00:55:07.260 --> 00:55:09.990
当我不走时给予通过

00:55:08.580 --> 00:55:12.390
通过，还有另一个例子

00:55:09.990 --> 00:55:21.020
我真的很喜欢这个

00:55:12.390 --> 00:55:21.020
让我看看我是否可以排序

00:55:21.170 --> 00:55:34.260
比较器点比较，然后我可以

00:55:27.330 --> 00:55:40.410
如果有的话，做得很好

00:55:34.260 --> 00:55:42.540
在T键上，我很好地获得了ID 

00:55:40.410 --> 00:55:45.359
很好的例子，因为我只是把它拔出来

00:55:42.540 --> 00:55:47.700
一年过时，但比较器最多

00:55:45.359 --> 00:55:50.070
比较可以使用方法参考

00:55:47.700 --> 00:55:51.540
说这是我要你的方法

00:55:50.070 --> 00:55:55.800
比较，而不是必须做

00:55:51.540 --> 00:55:58.230
比较就像哦，获得ID-哦获得

00:55:55.800 --> 00:56:00.510
 ID还是哦，两个-哦，一个我不是

00:55:58.230 --> 00:56:02.070
真的确定与

00:56:00.510 --> 00:56:04.109
对我的方法引用确实使

00:56:02.070 --> 00:56:06.349
清楚这就是我想要的

00:56:04.109 --> 00:56:09.030
比较我正在比较它们的ID和

00:56:06.349 --> 00:56:11.609
我也可以做相反的事情

00:56:09.030 --> 00:56:13.619
好吧，我真的可以很容易地对这些进行排序

00:56:11.609 --> 00:56:16.470
中心或思想下降或思想

00:56:13.619 --> 00:56:17.700
上升，所以这是一些

00:56:16.470 --> 00:56:19.740
我真正喜欢方法的地方

00:56:17.700 --> 00:56:21.720
我个人更喜欢引用的方法

00:56:19.740 --> 00:56:24.270
参考Overlander表达式

00:56:21.720 --> 00:56:25.740
大多数时候，但基本上是

00:56:24.270 --> 00:56:32.580
将成为似乎是什么

00:56:25.740 --> 00:56:36.120
对您最可读的内容

00:56:32.580 --> 00:56:38.190
谢谢，脖子压伤你能提供

00:56:36.120 --> 00:56:40.860
有关搬迁好处的更多详细信息

00:56:38.190 --> 00:56:45.420
 Java 8结果性能和

00:56:40.860 --> 00:56:47.820
重构，所以我将假设

00:56:45.420 --> 00:56:49.800
这个问题就像你是否

00:56:47.820 --> 00:56:51.690
您已有一个现有的代码库，并且

00:56:49.800 --> 00:56:53.220
你要跑了你要跑了

00:56:51.690 --> 00:56:55.260
在Java 8上无需进行任何更改

00:56:53.220 --> 00:56:57.420
所以不用拉姆达

00:56:55.260 --> 00:56:58.620
表达式不适用不

00:56:57.420 --> 00:57:01.320
使用流API 

00:56:58.620 --> 00:57:05.160
所以基本上Java 6代码在

00:57:01.320 --> 00:57:10.380
很好的Java 8编译器和VM 

00:57:05.160 --> 00:57:21.990
现在我展示的好处让我们

00:57:10.380 --> 00:57:23.940
回到起点或后退是

00:57:21.990 --> 00:57:26.970
这里我们去像第三张幻灯片

00:57:23.940 --> 00:57:28.530
这些变化很多

00:57:26.970 --> 00:57:30.090
通用数据的性能改进

00:57:28.530 --> 00:57:32.730
结构变化以支持

00:57:30.090 --> 00:57:34.850
并发这些东西

00:57:32.730 --> 00:57:39.000
再次有更多信息的链接

00:57:34.850 --> 00:57:41.460
从链接到他们的页面

00:57:39.000 --> 00:57:43.590
尤其是提高速度

00:57:41.460 --> 00:57:45.180
不用做任何事情就能得到那些

00:57:43.590 --> 00:57:47.430
特别是因为像哈希这样的东西

00:57:45.180 --> 00:57:49.080
地图的效果更好，大概是

00:57:47.430 --> 00:57:51.960
已经在Java中使用哈希映射

00:57:49.080 --> 00:57:53.730
 6种样式代码并转移到Java 8哈希

00:57:51.960 --> 00:57:57.650
地图将执行一般

00:57:53.730 --> 00:57:57.650
无需做任何事情就能更快

00:58:00.800 --> 00:58:09.540
好的下一个问题，您将如何处理

00:58:06.990 --> 00:58:12.360
您需要迭代的情况

00:58:09.540 --> 00:58:17.520
一个字符串多次执行

00:58:12.360 --> 00:58:19.680
对其执行不同的操作

00:58:17.520 --> 00:58:22.710
首先到您的收藏

00:58:19.680 --> 00:58:29.280
执行他们的处理还是有

00:58:22.710 --> 00:58:32.010
更好的方法，我不确定我会

00:58:29.280 --> 00:58:35.280
喜欢看实际的代码示例，但是

00:58:32.010 --> 00:58:37.830
我认为其中一些研究

00:58:35.280 --> 00:58:39.270
我们在这里看到的一些东西是

00:58:37.830 --> 00:58:41.700
有点魔术，你只是有点

00:58:39.270 --> 00:58:42.330
三个步骤合而为一

00:58:41.700 --> 00:58:44.070
为了你

00:58:42.330 --> 00:58:46.200
我认为随着您的发展

00:58:44.070 --> 00:58:48.270
掌握了Java 8的某些功能

00:58:46.200 --> 00:58:51.960
做事情很重要

00:58:48.270 --> 00:58:55.680
增量II，所以如果我在想的话

00:58:51.960 --> 00:58:57.900
在集合或某些对象方面

00:58:55.680 --> 00:59:00.119
需要多个操作

00:58:57.900 --> 00:59:02.730
执行它，我可能会写在

00:59:00.119 --> 00:59:05.670
假设三个独立的代码

00:59:02.730 --> 00:59:07.260
操作，然后我将进行测试

00:59:05.670 --> 00:59:09.390
确保它正常工作，然后我

00:59:07.260 --> 00:59:13.109
可能会看看我是否可以将其纳入

00:59:09.390 --> 00:59:14.460
是单流操作还是

00:59:13.109 --> 00:59:16.320
我会看看是否可以将其研究为

00:59:14.460 --> 00:59:18.720
单流操作，您应该

00:59:16.320 --> 00:59:20.849
能够推理出周围的事物

00:59:18.720 --> 00:59:29.520
禁止这样做，所以如果我看一些

00:59:20.849 --> 00:59:31.859
我的例子就像这个例子

00:59:29.520 --> 00:59:33.480
在这里还有另一个for循环，所以我

00:59:31.859 --> 00:59:37.109
感觉应该这样

00:59:33.480 --> 00:59:39.359
折射为单流操作

00:59:37.109 --> 00:59:40.859
但我知道这是

00:59:39.359 --> 00:59:43.920
现在结构化，我不能那样做

00:59:40.859 --> 00:59:46.560
因为这是这个地图字段

00:59:43.920 --> 00:59:49.290
我需要访问这里和这里

00:59:46.560 --> 00:59:52.380
这使我无法对此进行内联

00:59:49.290 --> 00:59:54.930
循环，类似地，我必须每个

00:59:52.380 --> 00:59:58.470
而不是做些流线型

00:59:54.930 --> 01:00:00.119
因为我要传递这组，所以

00:59:58.470 --> 01:00:04.410
这种特定方法的问题是

01:00:00.119 --> 01:00:06.119
我有很多收藏

01:00:04.410 --> 01:00:09.089
我正在做东西，所以我已经有了

01:00:06.119 --> 01:00:12.690
找到名字的东西，我有这套

01:00:09.089 --> 01:00:15.030
这里我有这个映射的领域的东西

01:00:12.690 --> 01:00:16.530
其中也有列表，所以我已经

01:00:15.030 --> 01:00:18.630
有很多不同的收藏

01:00:16.530 --> 01:00:20.010
彼此相互作用，所以

01:00:18.630 --> 01:00:23.700
我必须遍历所有这些

01:00:20.010 --> 01:00:25.290
在这种情况下，我知道为了

01:00:23.700 --> 01:00:28.260
作为一个流执行

01:00:25.290 --> 01:00:30.750
操作我需要摆脱一些

01:00:28.260 --> 01:00:33.510
这些集合或将其折叠

01:00:30.750 --> 01:00:35.400
在一起，所以答案是

01:00:33.510 --> 01:00:37.200
当然，这取决于我是否会受到诱惑

01:00:35.400 --> 01:00:39.660
第一次把东西写成

01:00:37.200 --> 01:00:41.160
一系列的个人操作，然后

01:00:39.660 --> 01:00:43.710
看看我能不能找出那些

01:00:41.160 --> 01:00:45.050
会崩溃成一个单一的

01:00:43.710 --> 01:00:49.430
运作

01:00:45.050 --> 01:00:51.599
好的，先生，我再问一个问题

01:00:49.430 --> 01:00:53.490
比较方法参考工具和

01:00:51.599 --> 01:00:58.540
现在观看性能的表情

01:00:53.490 --> 01:01:00.250
哦，我不好

01:00:58.540 --> 01:01:03.670
我想他们是一样的，我不知道我

01:01:00.250 --> 01:01:07.170
认为有一些我认为有一些

01:01:03.670 --> 01:01:10.450
来自Oracle的文献，但我

01:01:07.170 --> 01:01:11.770
认为他们的表现与我不一样

01:01:10.450 --> 01:01:13.720
知道我不应该说什么，因为我

01:01:11.770 --> 01:01:18.430
难道我没有查过吗

01:01:13.720 --> 01:01:20.740
记得好吧，所以有几个

01:01:18.430 --> 01:01:25.300
有关其绩效问题的问题

01:01:20.740 --> 01:01:28.240
提到的问题第一个问题是

01:01:25.300 --> 01:01:32.020
较低的性能归因于

01:01:28.240 --> 01:01:37.090
只擦除流

01:01:32.020 --> 01:01:40.000
收集不正确，所以最坏的情况

01:01:37.090 --> 01:01:42.310
我们获得的绩效结果是

01:01:40.000 --> 01:01:43.630
绝对是在高潮中

01:01:42.310 --> 01:01:50.200
只是尝试去看看我是否能找到

01:01:43.630 --> 01:01:52.680
这些例子中的一些，现在我发现

01:01:50.200 --> 01:01:52.680
有趣一词

01:02:01.530 --> 01:02:04.940
最糟糕的例子之一是

01:02:03.270 --> 01:02:07.230
我们在上游使用凸起的

01:02:04.940 --> 01:02:10.740
不管我们是否要去

01:02:07.230 --> 01:02:12.990
平行与否，我们只是无法得到

01:02:10.740 --> 01:02:15.870
性能接近

01:02:12.990 --> 01:02:18.720
原始数组，在这种情况下，我

01:02:15.870 --> 01:02:20.160
相信，因为迭代

01:02:18.720 --> 01:02:22.740
像我说的那样排列得非常非常

01:02:20.160 --> 01:02:25.110
高效，这很难

01:02:22.740 --> 01:02:29.430
匹配的表现，但有

01:02:25.110 --> 01:02:33.360
您指出的其他情况

01:02:29.430 --> 01:02:35.970
上游也没有浪费，所以这

01:02:33.360 --> 01:02:37.440
是地图和收藏，不是

01:02:35.970 --> 01:02:39.630
使用凸起的上游，这是

01:02:37.440 --> 01:02:42.240
上游收集，仍然不是

01:02:39.630 --> 01:02:44.460
作为良好的性能明智的看

01:02:42.240 --> 01:02:50.070
代码在这里，我们只是键点

01:02:44.460 --> 01:02:52.110
流，因此使用流确实

01:02:50.070 --> 01:02:54.330
对对象有影响

01:02:52.110 --> 01:02:57.480
创造确实会产生影响

01:02:54.330 --> 01:02:59.340
性能的问题，不是，不仅仅是

01:02:57.480 --> 01:03:01.550
如果没有免费的午餐当然

01:02:59.340 --> 01:03:04.620
是的，使用流会产生成本，并且

01:03:01.550 --> 01:03:06.750
直接不仅是数组流，而且

01:03:04.620 --> 01:03:10.770
数组点流特别糟糕

01:03:06.750 --> 01:03:14.220
这就是为什么我称其为好， 

01:03:10.770 --> 01:03:16.320
另一个问题，这就是全部

01:03:14.220 --> 01:03:18.720
这些性能问题可能

01:03:16.320 --> 01:03:22.800
在将来的Java版本中解决，或者

01:03:18.720 --> 01:03:25.560
 x9好的，是的，所以Java 8的性能

01:03:22.800 --> 01:03:27.090
甚至已经变得越来越好

01:03:25.560 --> 01:03:29.100
 Java 8，所以您知道所有这些

01:03:27.090 --> 01:03:32.190
作业8的不同更新

01:03:29.100 --> 01:03:32.490
非运行版本112 

01:03:32.190 --> 01:03:35.280
手段

01:03:32.490 --> 01:03:37.020
因此，即使不必使用Java 9 

01:03:35.280 --> 01:03:38.040
我们正在改善性能

01:03:37.020 --> 01:03:39.360
改进的盖子

01:03:38.040 --> 01:03:41.430
 Lambda之类的性能

01:03:39.360 --> 01:03:43.200
表达式等等这些流

01:03:41.430 --> 01:03:45.840
 API的好处之一

01:03:43.200 --> 01:03:48.360
流API是因为它的

01:03:45.840 --> 01:03:50.130
实施隐藏在你身边

01:03:48.360 --> 01:03:52.860
你只是与你想要的互动

01:03:50.130 --> 01:03:54.660
实现他们可以继续迭代

01:03:52.860 --> 01:03:57.930
过度提高性能

01:03:54.660 --> 01:03:59.400
流API，而不会影响您使用

01:03:57.930 --> 01:04:01.530
流API，他们可以在

01:03:59.400 --> 01:04:03.120
颜色，所以肯定会继续

01:04:01.530 --> 01:04:04.950
还有各种各样的其他东西

01:04:03.120 --> 01:04:07.260
进入Java 9和Java 10 

01:04:04.950 --> 01:04:09.570
提高性能-其中之一

01:04:07.260 --> 01:04:12.090
我想强调的是

01:04:09.570 --> 01:04:13.710
即使在这样的情况下

01:04:12.090 --> 01:04:14.710
看起来这个重构的代码是

01:04:13.710 --> 01:04:16.570
真的很恐怖

01:04:14.710 --> 01:04:19.450
与原始性能相比

01:04:16.570 --> 01:04:22.150
我之前说过的代码，但值得

01:04:19.450 --> 01:04:24.070
重申像这样的微观基准

01:04:22.150 --> 01:04:26.290
不一定代表您

01:04:24.070 --> 01:04:28.690
应用程序的执行速度会变慢

01:04:26.290 --> 01:04:29.859
如果您执行此重构，因为

01:04:28.690 --> 01:04:31.390
事物的宏伟计划

01:04:29.859 --> 01:04:33.099
应用程序还有很多其他功能

01:04:31.390 --> 01:04:35.080
它与其他服务和网络对话

01:04:33.099 --> 01:04:38.339
电线很贵，你知道它会说话

01:04:35.080 --> 01:04:40.210
它必须响应用户的数据库

01:04:38.339 --> 01:04:41.710
还有各种各样的其他东西

01:04:40.210 --> 01:04:44.560
发生大量互动

01:04:41.710 --> 01:04:46.450
事情之间的事实，这些

01:04:44.560 --> 01:04:48.490
三行代码或其他代码

01:04:46.450 --> 01:04:51.670
表现与原版一样快

01:04:48.490 --> 01:04:52.900
几行代码可能不会对

01:04:51.670 --> 01:04:54.849
您的整体表现

01:04:52.900 --> 01:04:56.140
应用程序，您可能会发现

01:04:54.849 --> 01:04:58.359
周围的一些改进

01:04:56.140 --> 01:05:00.730
诸如垃圾收集之类的东西

01:04:58.359 --> 01:05:01.990
围绕争议者的改进

01:05:00.730 --> 01:05:05.380
您正在使用的收藏集

01:05:01.990 --> 01:05:07.869
他们可能会抵消其中的一些

01:05:05.380 --> 01:05:09.700
性能测试表明

01:05:07.869 --> 01:05:11.260
性能不是很好，所以你

01:05:09.700 --> 01:05:13.089
需要整体衡量

01:05:11.260 --> 01:05:17.920
您整个应用程序的范围而不仅仅是

01:05:13.089 --> 01:05:20.500
这些微型基准还可以

01:05:17.920 --> 01:05:24.040
质疑如何表现

01:05:20.500 --> 01:05:26.080
法兰德斯和普罗斯小姐的孤岛是

01:05:24.040 --> 01:05:28.089
对性能不好或好

01:05:26.080 --> 01:05:30.160
取决于我们如何实施它们

01:05:28.089 --> 01:05:33.580
似乎都是关于可读代码的

01:05:30.160 --> 01:05:36.280
与更好的性能相比，确实感觉

01:05:33.580 --> 01:05:38.710
有点像我会说

01:05:36.280 --> 01:05:41.920
世界，所以我的例子是

01:05:38.710 --> 01:05:46.599
使用lambda表达式开始

01:05:41.920 --> 01:05:50.500
返回我执行的lambda表达式

01:05:46.599 --> 01:05:53.080
更好，所以在很多情况下

01:05:50.500 --> 01:05:55.089
这个报告这里有一大堆

01:05:53.080 --> 01:05:57.609
 lambda表达式的情况

01:05:55.089 --> 01:05:59.680
比匿名类型表现更好

01:05:57.609 --> 01:06:01.660
这样您可以提高可读性， 

01:05:59.680 --> 01:06:03.700
我实际上不得不改善性能

01:06:01.660 --> 01:06:05.349
搜索此文档以找到一个

01:06:03.700 --> 01:06:06.910
 lambda表达式的示例

01:06:05.349 --> 01:06:09.280
表现不如以下之一

01:06:06.910 --> 01:06:11.619
匿名内部类型，所以对于lambda 

01:06:09.280 --> 01:06:13.359
特别是它们是一个

01:06:11.619 --> 01:06:15.460
甲骨文真的很难确保

01:06:13.359 --> 01:06:17.500
他们的表现并不差

01:06:15.460 --> 01:06:19.420
比匿名类型更常见

01:06:17.500 --> 01:06:21.130
更好，正如我所说的

01:06:19.420 --> 01:06:26.830
这些也越来越好，因为

01:06:21.130 --> 01:06:27.670
对JVM本身的优化是的

01:06:26.830 --> 01:06:33.940
谢谢

01:06:27.670 --> 01:06:36.490
嗯，当问题提示出现时，或

01:06:33.940 --> 01:06:40.210
并行计算

01:06:36.490 --> 01:06:43.330
如果我们这样做会有所作为吗

01:06:40.210 --> 01:06:46.260
我猜应用程序中的并行

01:06:43.330 --> 01:06:49.240
然后平行我可能会开始

01:06:46.260 --> 01:06:54.130
消耗或使用可能

01:06:49.240 --> 01:07:00.100
已经用于其他操作

01:06:54.130 --> 01:07:02.410
不知道那是什么我能注意到我

01:07:00.100 --> 01:07:04.990
很明白，因为如果问题

01:07:02.410 --> 01:07:07.900
在生产中并行运行

01:07:04.990 --> 01:07:16.980
与这些并行运行不同

01:07:07.900 --> 01:07:21.220
根据我的理解测试

01:07:16.980 --> 01:07:28.720
假设我们使用并行，因此我们需要

01:07:21.220 --> 01:07:32.290
利用其他线程，所以我们

01:07:28.720 --> 01:07:36.270
想知道我们是否会影响

01:07:32.290 --> 01:07:40.780
通过这样做的应用程序

01:07:36.270 --> 01:07:46.660
考虑到我们消耗了线程

01:07:40.780 --> 01:07:50.800
可用于位操作II 

01:07:46.660 --> 01:07:55.140
不要以为这样就行了

01:07:50.800 --> 01:07:58.240
误解了问题，但是什么

01:07:55.140 --> 01:08:00.940
并行在做什么

01:07:58.240 --> 01:08:03.100
它使用fork / join框架，因此

01:08:00.940 --> 01:08:06.490
如果您喜欢它自己，它将旋转

01:08:03.100 --> 01:08:08.550
线程并运行整个过程

01:08:06.490 --> 01:08:12.460
该并行是要继续进行工作

01:08:08.550 --> 01:08:15.070
单个CPU或原因以及一些

01:08:12.460 --> 01:08:17.410
物理CPU，例如

01:08:15.070 --> 01:08:20.880
 Macbook我可以并行使用四个

01:08:17.410 --> 01:08:23.740
核心很容易，而且基本上

01:08:20.880 --> 01:08:24.940
充分利用硬件

01:08:23.740 --> 01:08:26.920
关于平行点

01:08:24.940 --> 01:08:29.650
当然，现在大多数硬件

01:08:26.920 --> 01:08:32.290
你有并行线程使

01:08:29.650 --> 01:08:34.900
大多数的CPU可能是

01:08:32.290 --> 01:08:36.430
将其他线程推离CPU，这样

01:08:34.900 --> 01:08:38.020
他们没有时间我不是真的

01:08:36.430 --> 01:08:41.250
知道如何安排下面的工作

01:08:38.020 --> 01:08:44.920
封面，但你不会

01:08:41.250 --> 01:08:46.779
它不会干扰

01:08:44.920 --> 01:08:49.380
其他线程上的数据，所以它不会

01:08:46.779 --> 01:08:51.969
重用其他线程

01:08:49.380 --> 01:08:53.770
从数据点干扰他们

01:08:51.969 --> 01:08:55.660
看来可能感觉CPU不在了

01:08:53.770 --> 01:08:57.100
从他们那里，但我不相信

01:08:55.660 --> 01:09:03.759
你不必担心

01:08:57.100 --> 01:09:08.400
关于线程安全的事情

01:09:03.759 --> 01:09:14.140
传统上我们不得不接受的方式

01:09:08.400 --> 01:09:18.160
认为你就在这里，还可以

01:09:14.140 --> 01:09:21.250
让我们靠近一点哦，还有很多

01:09:18.160 --> 01:09:23.469
 IntelliJ IDEA提供的问题吗

01:09:21.250 --> 01:09:27.310
从附近重构的建议

01:09:23.469 --> 01:09:30.460
时间到一个时间API，所以我可以尝试

01:09:27.310 --> 01:09:33.609
回答问题，享受Delia不会

01:09:30.460 --> 01:09:38.890
建议它，但是有一个问题

01:09:33.609 --> 01:09:41.940
问题跟踪器，我们仍然跟踪道路

01:09:38.890 --> 01:09:45.609
并随时通过它

01:09:41.940 --> 01:09:46.960
绝对可以实现，是的，我

01:09:45.609 --> 01:09:48.310
真的想有一天给你看

01:09:46.960 --> 01:09:51.250
时间的东西，因为我真的很喜欢新

01:09:48.310 --> 01:09:53.440
日期和时间以及API，但我没有

01:09:51.250 --> 01:09:56.590
我确实看到的任何非常好的例子

01:09:53.440 --> 01:09:58.690
有过时的使用

01:09:56.590 --> 01:10:01.510
过时的日期/时间API，但这不是

01:09:58.690 --> 01:10:06.250
另一个时间是java.util日期

01:10:01.510 --> 01:10:10.650
和Java util日历，是的，我认为

01:10:06.250 --> 01:10:14.469
一切都没有正常的问题

01:10:10.650 --> 01:10:18.910
您还有其他疑问

01:10:14.469 --> 01:10:22.480
在Twitter上询问他们或实施我们

01:10:18.910 --> 01:10:26.590
即将发布录音，如果

01:10:22.480 --> 01:10:30.010
您会发现一些未解决的问题

01:10:26.590 --> 01:10:32.670
请实际上与我们分享

01:10:30.010 --> 01:10:38.400
总是通过Twitter与我联系

01:10:32.670 --> 01:10:41.880
太酷了，谢谢您为我度过的时光

01:10:38.400 --> 01:10:41.880
谢谢你，再见

