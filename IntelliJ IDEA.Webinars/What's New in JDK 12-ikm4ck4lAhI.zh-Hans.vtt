WEBVTT
Kind: captions
Language: zh-Hans

00:00:06.190 --> 00:00:12.459
感谢您加入我们在此网络研讨会中

00:00:08.710 --> 00:00:15.580
今天的Java 12，所以在我开始之前

00:00:12.459 --> 00:00:18.700
解决主要问题你为什么要

00:00:15.580 --> 00:00:23.350
参加会议以及为什么需要

00:00:18.700 --> 00:00:25.570
了解Java 12的新功能，如果可以的话

00:00:23.350 --> 00:00:28.750
在其中之一中识别自己

00:00:25.570 --> 00:00:32.309
我认为你很适合

00:00:28.750 --> 00:00:35.680
在会议上，所以第一个是这个

00:00:32.309 --> 00:00:40.030
会议标题使

00:00:35.680 --> 00:00:43.680
您，也许您认为真的是Java 12 

00:00:40.030 --> 00:00:47.440
已经出来了，这是第二个

00:00:43.680 --> 00:00:52.570
你知道Java 12已经发布了

00:00:47.440 --> 00:00:55.809
好奇地发现里面有什么

00:00:52.570 --> 00:00:58.899
情况可能是因为您在

00:00:55.809 --> 00:01:02.890
 Java您周围的每个人都希望您能够

00:00:58.899 --> 00:01:05.050
知道Java 12的新功能，但是自从您

00:01:02.890 --> 00:01:07.630
正在使用旧版本的

00:01:05.050 --> 00:01:12.310
 Java，您实际上没有时间

00:01:07.630 --> 00:01:15.729
探索最新版本，这里是

00:01:12.310 --> 00:01:18.429
也许有人来找你， 

00:01:15.729 --> 00:01:22.810
就他们是否应该征询您的意见

00:01:18.429 --> 00:01:25.119
迁移到Java 12还是不迁移到Java 12 

00:01:22.810 --> 00:01:28.360
您可以在其中之一中看到自己

00:01:25.119 --> 00:01:34.030
情况或类似的情况

00:01:28.360 --> 00:01:36.880
在正确的地方，这样就可以了

00:01:34.030 --> 00:01:40.780
关于在聊天窗口中输入是

00:01:36.880 --> 00:01:43.209
如果您认为自己可以看到自己

00:01:40.780 --> 00:01:48.250
以前的任何情况或

00:01:43.209 --> 00:01:52.599
类似，只是您知道

00:01:48.250 --> 00:01:56.410
你参加正确的会议好吗

00:01:52.599 --> 00:01:59.709
所以这是今天会议的议程

00:01:56.410 --> 00:02:02.590
所以我们对Java 12表示欢迎

00:01:59.709 --> 00:02:06.069
我将介绍发布的影响

00:02:02.590 --> 00:02:08.020
我将通过Java 12的指南

00:02:06.069 --> 00:02:10.509
带您通过链接进行操作

00:02:08.020 --> 00:02:15.550
访问Java中的更改列表

00:02:10.509 --> 00:02:18.970
 12，因为这是JetBrains网络研讨会，我将

00:02:15.550 --> 00:02:19.720
不能涵盖每一个变化

00:02:18.970 --> 00:02:23.710
在Java中

00:02:19.720 --> 00:02:27.010
好吧，我将其限制为某些更改

00:02:23.710 --> 00:02:30.850
 Java试用包括多个小

00:02:27.010 --> 00:02:33.370
变化，我已经列出了清单

00:02:30.850 --> 00:02:37.540
故意因为这些链接将

00:02:33.370 --> 00:02:40.390
帮助您找到可能的方式

00:02:37.540 --> 00:02:42.820
发现详尽的变更清单

00:02:40.390 --> 00:02:46.390
在Java 12中，我将带您完成

00:02:42.820 --> 00:02:49.900
 Java 12中的语言变化是

00:02:46.390 --> 00:02:52.720
新的开关表达式alka也涵盖了

00:02:49.900 --> 00:02:56.350
如何再次遍历API更改

00:02:52.720 --> 00:03:00.450
那是一个列表，并不是每个列表的真正含义

00:02:56.350 --> 00:03:02.830
 Java 12中每个已更改的API 

00:03:00.450 --> 00:03:07.860
很快，我会带您通过GC 

00:03:02.830 --> 00:03:12.100
变化，我们有一个新的GC和两个主要

00:03:07.860 --> 00:03:15.360
对现有Jeevan GC的修改

00:03:12.100 --> 00:03:17.740
这是垃圾第一收集器

00:03:15.360 --> 00:03:21.100
也将讨论您是否应该

00:03:17.740 --> 00:03:24.010
迁移到Java 12，最后以

00:03:21.100 --> 00:03:29.530
特丽莎（Trisha）说会以问题结尾

00:03:24.010 --> 00:03:32.410
和答案，因此Oracle介绍了六个

00:03:29.530 --> 00:03:35.350
 Java 9个月发布节奏

00:03:32.410 --> 00:03:40.360
 Java 9之后的所有版本

00:03:35.350 --> 00:03:42.880
每6个月发布一次， 

00:03:40.360 --> 00:03:45.310
六个月发布节奏Java 

00:03:42.880 --> 00:03:49.019
版本是长期支持

00:03:45.310 --> 00:03:52.540
发布或短期支持发布

00:03:49.019 --> 00:03:55.180
所以我昨天进行了一项民意调查

00:03:52.540 --> 00:03:58.510
开发人员分享经验

00:03:55.180 --> 00:04:02.890
 Java 12的百分比很高

00:03:58.510 --> 00:04:06.400
这是38％的人不是

00:04:02.890 --> 00:04:08.380
知道Java 12已经发布，是的

00:04:06.400 --> 00:04:09.790
您发布的信息

00:04:08.380 --> 00:04:12.640
 3月19日

00:04:09.790 --> 00:04:15.280
今年的另一高百分比

00:04:12.640 --> 00:04:19.120
人们想知道其中的新内容

00:04:15.280 --> 00:04:22.060
正如我们所期望的

00:04:19.120 --> 00:04:25.120
极少数计划迁移到Java 12 

00:04:22.060 --> 00:04:28.510
也怀疑他们是否应该这样做

00:04:25.120 --> 00:04:31.390
所以最少的票是开发商

00:04:28.510 --> 00:04:33.550
很好奇Java 12 

00:04:31.390 --> 00:04:37.690
与其他框架一起工作

00:04:33.550 --> 00:04:41.170
或者Jules也不是较新的版本

00:04:37.690 --> 00:04:43.390
现在发布了很多炒作

00:04:41.170 --> 00:04:46.030
他们早些时候被释放的方式

00:04:43.390 --> 00:04:48.520
甲骨文有定期的三年

00:04:46.030 --> 00:04:51.700
释放节奏，这解释了为什么

00:04:48.520 --> 00:04:56.530
人们不知道什么时候有新版本

00:04:51.700 --> 00:04:59.910
发布，所以这是另一个民意调查

00:04:56.530 --> 00:05:03.760
反映上一次民意调查的第一名

00:04:59.910 --> 00:05:06.360
为什么人们不了解新

00:05:03.760 --> 00:05:10.810
发行新版本的Java和

00:05:06.360 --> 00:05:13.390
在Java的发布节奏上排名第二

00:05:10.810 --> 00:05:15.460
它影响更新的采用

00:05:13.390 --> 00:05:18.520
版本，因为有很多

00:05:15.460 --> 00:05:20.920
民意调查显示大多数

00:05:18.520 --> 00:05:22.200
生产代码仍在Java 8和

00:05:20.920 --> 00:05:25.330
我们都同意这一点

00:05:22.200 --> 00:05:27.730
但这并不能阻止

00:05:25.330 --> 00:05:35.470
开发人员尝试新产品

00:05:27.730 --> 00:05:38.740
 Java 9的版本于2017年发布

00:05:35.470 --> 00:05:43.270
 Java 8及其之后的三年

00:05:38.740 --> 00:05:49.390
采用率很慢，因为我们有

00:05:43.270 --> 00:05:52.930
模块系统

00:05:49.390 --> 00:05:56.500
当我们在谈论时

00:05:52.930 --> 00:06:00.580
 Java 9的采用也是一个展示

00:05:56.500 --> 00:06:03.940
短期支持发布Java 11 

00:06:00.580 --> 00:06:05.500
去年9月发行的是

00:06:03.940 --> 00:06:08.620
长期支持发布和

00:06:05.500 --> 00:06:10.210
组织倾向于从一个迁移

00:06:08.620 --> 00:06:14.320
 LTS版本到另一个

00:06:10.210 --> 00:06:17.920
 LTS版本，因此之前的最新版本

00:06:14.320 --> 00:06:23.550
 Java 11是Java 8，因此人们不断前进

00:06:17.920 --> 00:06:23.550
迁移到Java 11而不是迁移到Java 12 

00:06:23.610 --> 00:06:31.060
因此，随着Java的新发行节奏

00:06:26.970 --> 00:06:34.120
创新率是相同的，因为

00:06:31.060 --> 00:06:36.100
我们正在谈论释放

00:06:34.120 --> 00:06:40.420
可以使用的功能

00:06:36.100 --> 00:06:43.330
开发人员，因此Oracle正在开发

00:06:40.420 --> 00:06:45.850
步调一致，改变的是

00:06:43.330 --> 00:06:47.270
现在每六个交货率

00:06:45.850 --> 00:06:49.940
开发人员获得的几个月

00:06:47.270 --> 00:06:52.430
使用较新的功能

00:06:49.940 --> 00:06:54.860
 Java当然具有的功能

00:06:52.430 --> 00:06:57.560
还谈到了可预测的日期

00:06:54.860 --> 00:07:00.710
现在我们不必等待功能

00:06:57.560 --> 00:07:03.650
完成一项明星功能

00:07:00.710 --> 00:07:06.110
我们知道Java的更新版本

00:07:03.650 --> 00:07:09.350
六个月后，我们将获得一个新版本

00:07:06.110 --> 00:07:11.330
功能是否能够

00:07:09.350 --> 00:07:13.580
它不是特定的Java版本

00:07:11.330 --> 00:07:17.030
所以功能没有那么多

00:07:13.580 --> 00:07:20.060
像以前一样重要

00:07:17.030 --> 00:07:22.940
当然新功能不是

00:07:20.060 --> 00:07:27.110
因及时而受到惩罚

00:07:22.940 --> 00:07:29.720
你们中的一个人

00:07:27.110 --> 00:07:33.320
首席客人没有及时到达

00:07:29.720 --> 00:07:36.440
所有其余的人

00:07:33.320 --> 00:07:39.830
实际去过那里都受到惩罚

00:07:36.440 --> 00:07:42.260
因为及时，所以这就是Java 

00:07:39.830 --> 00:07:44.570
发行节奏现在正在工作

00:07:42.260 --> 00:07:46.880
准备好了的功能

00:07:44.570 --> 00:07:50.810
与下一个Java版本一起发布，并且

00:07:46.880 --> 00:07:56.720
不是Java版本的

00:07:50.810 --> 00:08:00.890
这些功能不会延迟，因此我们

00:07:56.720 --> 00:08:03.980
进入今天的下一个

00:08:00.890 --> 00:08:10.760
会议，他们在议程上是

00:08:03.980 --> 00:08:13.940
如何访问Java 12中的新功能

00:08:10.760 --> 00:08:18.500
如果您转到提到的链接

00:08:13.940 --> 00:08:26.810
在这里，我可以打开这个，我们

00:08:18.500 --> 00:08:29.450
会看到G EPS的列表

00:08:26.810 --> 00:08:36.140
如您所见，它包含在Java 12中

00:08:29.450 --> 00:08:38.690
我们在这里有功能列表，所以我们

00:08:36.140 --> 00:08:41.210
可以看到我们可以访问新功能

00:08:38.690 --> 00:08:44.450
 Java 12使用多种方式

00:08:41.210 --> 00:08:47.060
我可以访问GE PS 

00:08:44.450 --> 00:08:49.460
 jdk增强建议是

00:08:47.060 --> 00:08:55.970
 Java 12和我所拥有的功能

00:08:49.460 --> 00:08:59.930
也可以访问的完整列表

00:08:55.970 --> 00:09:01.010
 Java中包含的API更改

00:08:59.930 --> 00:09:05.830
 12 

00:09:01.010 --> 00:09:09.980
因此通常无法访问此链接

00:09:05.830 --> 00:09:12.680
由很多开发人员提供，因为很多

00:09:09.980 --> 00:09:15.770
开发人员对此列表一无所知

00:09:12.680 --> 00:09:18.680
这个会给你API 

00:09:15.770 --> 00:09:23.830
 Java SE中Java s 11之间的区别

00:09:18.680 --> 00:09:27.650
 2升，如您所见

00:09:23.830 --> 00:09:30.320
红色字体突出显示添加项

00:09:27.650 --> 00:09:33.320
绿色背景和清除

00:09:30.320 --> 00:09:36.170
是粉红色的背景，让我们

00:09:33.320 --> 00:09:40.180
单击此链接，我们实际上可以

00:09:36.170 --> 00:09:45.320
访问Java API中发生的事情

00:09:40.180 --> 00:09:51.740
让我们滚动到我们最喜欢的Java点

00:09:45.320 --> 00:09:57.350
郎，你可以看到，然后去

00:09:51.740 --> 00:09:59.930
类字符串，这是类字符串， 

00:09:57.350 --> 00:10:02.240
我们可以看到有一个修改

00:09:59.930 --> 00:10:08.480
增加，总共有五个

00:10:02.240 --> 00:10:11.480
变化，让我们点击Java字符串

00:10:08.480 --> 00:10:14.000
正如我们前面所看到的

00:10:11.480 --> 00:10:16.840
以前的窗口中添加的是

00:10:14.000 --> 00:10:20.420
以绿色背景突出显示，并

00:10:16.840 --> 00:10:22.280
在左窗格中，您也可以滚动

00:10:20.420 --> 00:10:26.030
再次下来找出什么

00:10:22.280 --> 00:10:27.890
如此描述的稳定是

00:10:26.030 --> 00:10:30.860
 Java的新方法之一

00:10:27.890 --> 00:10:35.420
 Java 12中类字符串的新功能

00:10:30.860 --> 00:10:40.580
你有方法缩进和其他

00:10:35.420 --> 00:10:43.970
好吧，这个链接会给你一个列表

00:10:40.580 --> 00:10:45.530
所有附加修改中

00:10:43.970 --> 00:10:51.140
 Java删除

00:10:45.530 --> 00:10:54.370
 ac-12好的，现在让我们开始吧

00:10:51.140 --> 00:10:57.320
 Java 12中的语言功能

00:10:54.370 --> 00:11:04.710
本质上我们只有一个

00:10:57.320 --> 00:11:11.640
开关表达式如此

00:11:04.710 --> 00:11:15.900
我现在去演示，好吧

00:11:11.640 --> 00:11:18.750
我们将切换表达式，我们有一个

00:11:15.900 --> 00:11:21.180
使用switch语句作为

00:11:18.750 --> 00:11:23.310
开关表达式和我们所知道的开关

00:11:21.180 --> 00:11:25.260
表达是表达

00:11:23.310 --> 00:11:29.310
是会返回值的东西

00:11:25.260 --> 00:11:32.790
回到您的手中，使用Java 12，我们可以

00:11:29.310 --> 00:11:35.610
使用switch语句作为

00:11:32.790 --> 00:11:38.280
表达式和声明中一样，让我们

00:11:35.610 --> 00:11:43.800
从这里的一些代码开始，让我定义

00:11:38.280 --> 00:11:46.940
一个用过的塑料枚举， 

00:11:43.800 --> 00:11:54.090
我在这里创建了两个常数

00:11:46.940 --> 00:12:03.570
常数是勺子，我有稻草

00:11:54.090 --> 00:12:07.500
我有酒杯和杯子让我

00:12:03.570 --> 00:12:16.650
创建一个返回值为的方法

00:12:07.500 --> 00:12:19.230
类型，我说是损坏，所以这有点

00:12:16.650 --> 00:12:23.370
试图计算您的伤害

00:12:19.230 --> 00:12:30.480
通过使用对你的星球做

00:12:23.370 --> 00:12:35.790
一次性塑料制品好吧，我通过了

00:12:30.480 --> 00:12:40.910
在类型的方法参数的值中

00:12:35.790 --> 00:12:51.740
一次性使用塑料的方法和

00:12:40.910 --> 00:12:57.960
好吧，我在这里有局部变量

00:12:51.740 --> 00:13:05.730
从这种方法返回让我

00:12:57.960 --> 00:13:11.370
打开方法参数，我说

00:13:05.730 --> 00:13:14.970
如果是汤匙的话

00:13:11.370 --> 00:13:18.000
对环境做的比方说10 

00:13:14.970 --> 00:13:21.630
点我有休息状态

00:13:18.000 --> 00:13:24.150
 Minn，以便控件不会掉落

00:13:21.630 --> 00:13:28.950
通过案例标签第二种情况

00:13:24.150 --> 00:13:33.960
标签是稻草我说这是损害

00:13:28.950 --> 00:13:39.300
案例又是11分我用了休息时间

00:13:33.960 --> 00:13:42.440
下一个案例标签的说明

00:13:39.300 --> 00:13:45.180
是瓶子，我要说的是

00:13:42.440 --> 00:13:47.280
大家20分，如果您正在使用

00:13:45.180 --> 00:13:53.190
一次性塑料瓶中的损坏

00:13:47.280 --> 00:13:56.730
我认为最可以吗？ 

00:13:53.190 --> 00:14:02.760
另一个中断声明和最后一个案例

00:13:56.730 --> 00:14:10.610
标签是顶部，现在是

00:14:02.760 --> 00:14:14.910
伤害还是11点还可以，所以让我

00:14:10.610 --> 00:14:18.410
使用快捷方式重新格式化所有代码

00:14:14.910 --> 00:14:22.140
如您所见，它是控制Alt L 

00:14:18.410 --> 00:14:28.580
该代码看起来更好

00:14:22.140 --> 00:14:28.580
现在格式化好了，我们该怎么办

00:14:29.900 --> 00:14:38.490
好吧，在我继续之前，我会

00:14:34.530 --> 00:14:43.620
想说明项目设置

00:14:38.490 --> 00:14:48.540
您必须在IntelliJ IDEA中包含

00:14:43.620 --> 00:14:54.600
您可以使用JDK 12功能

00:14:48.540 --> 00:14:57.720
我们可以使用ctrl alt shift打开

00:14:54.600 --> 00:15:00.780
项目结构，我已经有了我的

00:14:57.720 --> 00:15:03.720
项目设置也不错，但是如果你

00:15:00.780 --> 00:15:08.600
然后将其用于先前版本

00:15:03.720 --> 00:15:08.600
您必须将其更改为12 

00:15:08.630 --> 00:15:16.890
请问项目语言水平

00:15:12.810 --> 00:15:19.589
 12，如您所见，有多个

00:15:16.890 --> 00:15:22.860
可用的选项，所以我可以

00:15:19.589 --> 00:15:25.800
在特定的地方有我的项目SDK 

00:15:22.860 --> 00:15:28.790
数字让我们说2好，但这是

00:15:25.800 --> 00:15:31.590
我用于我的语言水平

00:15:28.790 --> 00:15:34.560
 IntelliJ IDEA项目是

00:15:31.590 --> 00:15:37.320
假设我实际上可以编译十个

00:15:34.560 --> 00:15:40.410
我的项目到以前的版本，所以我

00:15:37.320 --> 00:15:43.560
会很好，因为我想要

00:15:40.410 --> 00:15:48.029
在Java 12中使用switch表达式

00:15:43.560 --> 00:15:53.010
当然，如果您没有这个

00:15:48.029 --> 00:15:56.730
可以去项目SDK创建添加一个新的

00:15:53.010 --> 00:16:00.210
 SDK，因为我已经有J了

00:15:56.730 --> 00:16:02.279
 L在我的系统上，因此我可以使用它

00:16:00.210 --> 00:16:04.830
但如果您还没有judicata 

00:16:02.279 --> 00:16:08.520
在您的系统上安装阀门

00:16:04.830 --> 00:16:11.190
需要下载并安装它

00:16:08.520 --> 00:16:13.589
首先，然后去项目

00:16:11.190 --> 00:16:15.990
结构设置并将其添加到您的

00:16:13.589 --> 00:16:20.190
 IntelliJ IDEA设置，以便您可以

00:16:15.990 --> 00:16:23.880
在继续前进之前使用它，好吧，我

00:16:20.190 --> 00:16:28.110
单击确定，所以设置很好， 

00:16:23.880 --> 00:16:30.210
我单击确定，这样您就可以看到

00:16:28.110 --> 00:16:35.460
 switch语句是

00:16:30.210 --> 00:16:38.780
传统的switch语句是一种

00:16:35.460 --> 00:16:42.030
我是多个if-else语句

00:16:38.780 --> 00:16:44.280
打开方法参数并

00:16:42.030 --> 00:16:48.030
根据情况，我要分配一个

00:16:44.280 --> 00:16:51.240
值给一个变量，让我们说说我如何

00:16:48.030 --> 00:16:54.780
可以转换switch语句

00:16:51.240 --> 00:17:00.420
到一个开关表达式，所以如果我按alt 

00:16:54.780 --> 00:17:02.820
输入我可以使用的switch关键字

00:17:00.420 --> 00:17:10.530
用开关替换的选项

00:17:02.820 --> 00:17:15.089
现在的表达不是那么简洁

00:17:10.530 --> 00:17:21.110
因为我让我回到代码

00:17:15.089 --> 00:17:25.260
我以前有哇，所以我要走了

00:17:21.110 --> 00:17:28.290
让我再放很多行代码

00:17:25.260 --> 00:17:30.210
将按alt输入并替换为

00:17:28.290 --> 00:17:33.090
开关X使用替换选项

00:17:30.210 --> 00:17:37.170
与开关表达式，这是什么

00:17:33.090 --> 00:17:39.450
我再一次看到柠檬是

00:17:37.170 --> 00:17:42.630
带下划线的，让我看看IntelliJ是什么

00:17:39.450 --> 00:17:45.630
 IDEA建议在这里说，我可以

00:17:42.630 --> 00:17:48.720
与合并杯子

00:17:45.630 --> 00:17:52.190
稻草，因为因为它回来了

00:17:48.720 --> 00:17:55.730
相同的价值，让我现在就做

00:17:52.190 --> 00:17:59.159
让我们将其与开关进行比较

00:17:55.730 --> 00:18:01.380
我们之前拥有的声明

00:17:59.159 --> 00:18:04.230
之前的switch语句不是

00:18:01.380 --> 00:18:07.980
可以在多个案例标签中使用

00:18:04.230 --> 00:18:10.620
相同的开关分支和

00:18:07.980 --> 00:18:13.620
以前的陈述我不得不

00:18:10.620 --> 00:18:16.140
分开使用

00:18:13.620 --> 00:18:18.539
分支，但现在有了开关

00:18:16.140 --> 00:18:26.789
表达式我可以用在同一

00:18:18.539 --> 00:18:30.090
语法当然是简洁的

00:18:26.789 --> 00:18:33.299
您定义必须返回的内容

00:18:30.090 --> 00:18:42.110
箭头键的右侧

00:18:33.299 --> 00:18:46.950
箭头阵列现在让我们看看是否

00:18:42.110 --> 00:18:52.980
可以内联变量，以便您可以

00:18:46.950 --> 00:18:59.070
目前注意此代码块

00:18:52.980 --> 00:19:00.779
只是给开关分配一个值

00:18:59.070 --> 00:19:03.570
表达式将值分配给

00:19:00.779 --> 00:19:05.700
可变的损害，只是退还所以

00:19:03.570 --> 00:19:08.370
我们可以通过内联

00:19:05.700 --> 00:19:10.590
可变的是我们可以走，我们可以走

00:19:08.370 --> 00:19:13.500
受到局部变量的损害

00:19:10.590 --> 00:19:18.649
使用switch表达式返回

00:19:13.500 --> 00:19:23.279
价值哇，这就像现在的魅力

00:19:18.649 --> 00:19:26.549
好吧，所以我们谈到了

00:19:23.279 --> 00:19:32.250
切换语句简明扼要

00:19:26.549 --> 00:19:34.830
关于使用多个常量

00:19:32.250 --> 00:19:37.919
我们讨论过的单个分支中的案例标签

00:19:34.830 --> 00:19:41.610
关于衬里变量，所以让我们

00:19:37.919 --> 00:19:44.419
谈论默认的假秀，所以

00:19:41.610 --> 00:19:47.700
让我们回到原始代码

00:19:44.419 --> 00:19:50.850
只需使用Ctrl Z即可返回到此

00:19:47.700 --> 00:19:55.559
所以，如果我只是删除

00:19:50.850 --> 00:19:58.350
如果我在这种情况下在这里中断声明

00:19:55.559 --> 00:20:01.380
将价值秸秆传递给

00:19:58.350 --> 00:20:07.140
控件将失败的方法

00:20:01.380 --> 00:20:10.289
案例标签秸秆到瓶子和价值

00:20:07.140 --> 00:20:13.980
 20个将分配给瓶子，但

00:20:10.289 --> 00:20:17.220
如果您使用开关表达式，则不会

00:20:13.980 --> 00:20:20.179
那是使用开关的另一个优势

00:20:17.220 --> 00:20:23.610
表达式，我们还谈到了

00:20:20.179 --> 00:20:29.240
详尽的案例还可以

00:20:23.610 --> 00:20:36.380
让我们再次用switch替换它

00:20:29.240 --> 00:20:43.610
表达式，我在此变量中

00:20:36.380 --> 00:20:46.440
现在，如果我删除此值会发生什么

00:20:43.610 --> 00:20:48.900
所以IntelliJ IDEA告诉我该开关

00:20:46.440 --> 00:20:51.140
表达式不能涵盖所有

00:20:48.900 --> 00:20:56.039
正所有可能的输入值

00:20:51.140 --> 00:21:00.030
因为我们在谈论一个枚举

00:20:56.039 --> 00:21:03.270
这里我们有完整的枚举常量

00:21:00.030 --> 00:21:06.360
可以传递给此方法， 

00:21:03.270 --> 00:21:09.960
如果我不管理其中之一

00:21:06.360 --> 00:21:12.390
常量我在这里有两个选择，所以让

00:21:09.960 --> 00:21:16.440
我看看我有什么选择

00:21:12.390 --> 00:21:19.049
要么创建丢失的分支交换机

00:21:16.440 --> 00:21:21.750
分支是瓶或我可以插入

00:21:19.049 --> 00:21:24.990
默认分支，所以让我插入一个

00:21:21.750 --> 00:21:27.210
默认分支在这里，所以这是

00:21:24.990 --> 00:21:31.940
我当然可以使用默认代码

00:21:27.210 --> 00:21:38.480
将其更改为我想要的，这样会发生什么

00:21:31.940 --> 00:21:38.480
好吧，让我尝试其他选择

00:21:38.750 --> 00:21:46.610
现在我选择创造一个失踪者

00:21:42.929 --> 00:21:51.179
切换分支访问是瓶

00:21:46.610 --> 00:21:55.020
再次，我可以定义我的价值

00:21:51.179 --> 00:21:59.309
现在想要这是一个我们知道的枚举

00:21:55.020 --> 00:22:01.980
有哪些可能的价值

00:21:59.309 --> 00:22:06.419
被传递给变量，但是

00:22:01.980 --> 00:22:08.580
如果我们谈论案件或

00:22:06.419 --> 00:22:11.290
我们没有的类型

00:22:08.580 --> 00:22:15.130
详尽的值列表让我们

00:22:11.290 --> 00:22:19.630
确实你还好，所以让我合并一下

00:22:15.130 --> 00:22:26.050
并让我定义另一种方法

00:22:19.630 --> 00:22:32.760
再说一次静电和损坏，在此

00:22:26.050 --> 00:22:40.090
假设我将值传递为

00:22:32.760 --> 00:22:52.140
字符串，我打开方法

00:22:40.090 --> 00:23:00.340
参数，我说如果是汤匙

00:22:52.140 --> 00:23:04.570
伤害让我定义变量

00:23:00.340 --> 00:23:09.370
再一次我想念它的定义，所以我

00:23:04.570 --> 00:23:12.760
将变量定义为局部变量

00:23:09.370 --> 00:23:18.700
变量作为损害，我退还这个

00:23:12.760 --> 00:23:26.470
变量YI为其分配值10，并且

00:23:18.700 --> 00:23:31.600
我打破了switch语句，所以

00:23:26.470 --> 00:23:38.110
另一个价值可能是稻草，我说

00:23:31.600 --> 00:23:43.470
伤害是11现在我再说一次

00:23:38.110 --> 00:23:51.540
在这种情况下不在switch语句中

00:23:43.470 --> 00:24:00.760
好吧，让我插入一个switch语句

00:23:51.540 --> 00:24:03.400
好吧，我正在衬砌变量

00:24:00.760 --> 00:24:08.020
再一次，现在在这种情况下，如果您看到

00:24:03.400 --> 00:24:14.080
 IntelliJ IDEA已插入以下行

00:24:08.020 --> 00:24:19.540
它说如果我不通过任何一个的代码

00:24:14.080 --> 00:24:23.080
这些值0将被返回，但是如果

00:24:19.540 --> 00:24:24.690
我现在删除该特定行

00:24:23.080 --> 00:24:28.070
说开关表达

00:24:24.690 --> 00:24:31.740
不涵盖所有可能的输入值

00:24:28.070 --> 00:24:36.120
因此，当您使用返回值时

00:24:31.740 --> 00:24:38.850
切换表达式，您必须确保

00:24:36.120 --> 00:24:42.690
您在其中涵盖的值

00:24:38.850 --> 00:24:46.620
开关盒的标签用

00:24:42.690 --> 00:24:49.710
枚举，您可以定义所有

00:24:46.620 --> 00:24:53.670
常数，但对于其他值，例如

00:24:49.710 --> 00:24:56.280
短整数或其他整数

00:24:53.670 --> 00:24:59.340
开关表达式接受的值

00:24:56.280 --> 00:25:02.580
由于值的详尽清单

00:24:59.340 --> 00:25:07.170
您将无法输入

00:25:02.580 --> 00:25:11.940
您将需要一个默认的案例标签，以便

00:25:07.170 --> 00:25:20.820
让我在这里插入默认分支

00:25:11.940 --> 00:25:27.350
当然我可以根据需要进行修改，确定

00:25:20.820 --> 00:25:30.360
然后我们来讨论另一种格式

00:25:27.350 --> 00:25:33.030
好，所以返回的方式之一

00:25:30.360 --> 00:25:35.100
开关表达式中的值是

00:25:33.030 --> 00:25:38.850
只需输入我们想要的值

00:25:35.100 --> 00:25:44.190
返回但是如果我想定义怎么办

00:25:38.850 --> 00:25:49.380
假设我说一个局部变量

00:25:44.190 --> 00:25:53.430
是100，然后我想做点什么

00:25:49.380 --> 00:25:59.250
用这个数字我可以说

00:25:53.430 --> 00:26:04.410
一些操纵这个值的代码

00:25:59.250 --> 00:26:07.530
也可以连接到数据库或

00:26:04.410 --> 00:26:11.280
什么，然后我想返回一个

00:26:07.530 --> 00:26:15.060
值，因此在这种情况下，我可以使用

00:26:11.280 --> 00:26:19.470
中断语句，我可以返回一个

00:26:15.060 --> 00:26:23.880
值，这就是我可以使用块的方式

00:26:19.470 --> 00:26:26.460
我可以在switch分支中编写代码

00:26:23.880 --> 00:26:30.600
定义一个局部变量，我可以使用

00:26:26.460 --> 00:26:32.370
 break关键字的break语句

00:26:30.600 --> 00:26:37.130
返回一个值

00:26:32.370 --> 00:26:37.130
我还可以

00:26:37.890 --> 00:26:52.620
是的，所以让我删除这一个，看看

00:26:42.270 --> 00:26:55.830
我所能拥有的，如你所见

00:26:52.620 --> 00:27:01.580
默认我也可以抛出异常

00:26:55.830 --> 00:27:01.580
从案件标签中，所以我们正在谈论

00:27:02.420 --> 00:27:10.650
所以我们刚才谈到使用本地

00:27:06.510 --> 00:27:16.049
开关中的局部变量

00:27:10.650 --> 00:27:20.669
我们讨论过的使用砖头的分支

00:27:16.049 --> 00:27:25.950
返回值的语句，这是

00:27:20.669 --> 00:27:29.070
在这里我们正在使用一个块

00:27:25.950 --> 00:27:38.210
声明，否则我们只能使用

00:27:29.070 --> 00:27:38.210
箭头键可以返回一个值，这样

00:27:38.600 --> 00:27:47.700
我们已经涵盖了很多方面

00:27:42.240 --> 00:27:50.840
到switch语句，是的，我有一个

00:27:47.700 --> 00:27:55.230
你的问题好吗

00:27:50.840 --> 00:27:58.559
好吧，这是一种快速的图像

00:27:55.230 --> 00:28:01.260
突出显示正在更改的内容

00:27:58.559 --> 00:28:04.890
当我离开switch语句时

00:28:01.260 --> 00:28:06.840
如您所见，切换表达式

00:28:04.890 --> 00:28:09.330
开关中使用的冒号

00:28:06.840 --> 00:28:13.799
语句现在被箭头替换

00:28:09.330 --> 00:28:16.890
而不是使用

00:28:13.799 --> 00:28:19.350
您可以使用一个变量来

00:28:16.890 --> 00:28:23.120
返回我们也谈到了逗号

00:28:19.350 --> 00:28:31.200
分隔多个案例标签，您和

00:28:23.120 --> 00:28:34.140
好的，所以我再次使用了

00:28:31.200 --> 00:28:38.549
 break语句返回一个值，因此

00:28:34.140 --> 00:28:40.679
好的，所以这个使用另一种格式

00:28:38.549 --> 00:28:46.650
这是我想念的一个例子

00:28:40.679 --> 00:28:49.890
我的演示，所以如果您使用一个节点，它将使用

00:28:46.650 --> 00:28:51.330
冒号开始代码并使用break 

00:28:49.890 --> 00:28:53.340
返回一个值

00:28:51.330 --> 00:28:57.720
在前面的所有例子中

00:28:53.340 --> 00:28:59.610
在我的演示中显示，它使用箭头

00:28:57.720 --> 00:29:02.520
指定您想要的值

00:28:59.610 --> 00:29:04.710
返回，但在您还可以使用

00:29:02.520 --> 00:29:07.400
冒号后面跟着break语句

00:29:04.710 --> 00:29:10.290
以及您要返回的值

00:29:07.400 --> 00:29:13.440
好的，我们已经涵盖了详尽的内容

00:29:10.290 --> 00:29:18.120
案例，正如我提到的，您会得到一个

00:29:13.440 --> 00:29:21.630
如果您尝试使用编译错误

00:29:18.120 --> 00:29:23.640
切换表达式而不覆盖

00:29:21.630 --> 00:29:29.910
详尽案例试图返回

00:29:23.640 --> 00:29:31.860
从它的价值好吧，是的，所以这个

00:29:29.910 --> 00:29:36.030
让您回答参加者

00:29:31.860 --> 00:29:42.660
回答，所以你必须告诉我

00:29:36.030 --> 00:29:47.700
输入哪一行代码

00:29:42.660 --> 00:29:51.570
使代码编译只是一个

00:29:47.700 --> 00:29:55.080
还是第二行好吗

00:29:51.570 --> 00:29:58.260
让我解释一下，想象你有

00:29:55.080 --> 00:30:01.140
一个阶级的星球，我们正在谈论

00:29:58.260 --> 00:30:03.540
一个私有的静态变量

00:30:01.140 --> 00:30:08.640
静态的长期伤害，然后我有一个

00:30:03.540 --> 00:30:11.610
使用的方法，我正在切换

00:30:08.640 --> 00:30:15.590
在塑性方法参数上

00:30:11.610 --> 00:30:19.800
传递给它并不能涵盖所有

00:30:15.590 --> 00:30:24.690
此枚举和其余的情况

00:30:19.800 --> 00:30:29.100
情况是盘子，所以我们只有一个

00:30:24.690 --> 00:30:32.700
剩下的那是什么

00:30:29.100 --> 00:30:36.030
如果添加第一行，则正确答案

00:30:32.700 --> 00:30:38.940
可以帮助此代码进行编译或

00:30:36.030 --> 00:30:43.140
如果添加第二行，它将

00:30:38.940 --> 00:30:47.610
启用代码进行编译还是您应该

00:30:43.140 --> 00:30:53.580
只需几分钟即可将它们都添加

00:30:47.610 --> 00:30:56.120
让您回答问题，然后

00:30:53.580 --> 00:30:58.860
我将前进到下一张幻灯片，以便

00:30:56.120 --> 00:30:59.930
也许我要数五个

00:30:58.860 --> 00:31:05.380
转到下一张幻灯片

00:30:59.930 --> 00:31:09.640
采取一种策略采取三种

00:31:05.380 --> 00:31:12.490
他们采取了四手战术五，我会

00:31:09.640 --> 00:31:18.720
在末尾讨论问题

00:31:12.490 --> 00:31:22.090
会议是是其他有趣

00:31:18.720 --> 00:31:25.110
关于开关表达式的部分是

00:31:22.090 --> 00:31:28.929
这是一种预览语言功能， 

00:31:25.110 --> 00:31:31.390
这实际上意味着什么，所以这是一个

00:31:28.929 --> 00:31:35.830
 Java中引入的新概念

00:31:31.390 --> 00:31:41.010
在2018年，这实际上意味着什么

00:31:35.830 --> 00:31:46.330
是新的语言功能还是

00:31:41.010 --> 00:31:50.440
虚拟机功能，功能全面

00:31:46.330 --> 00:31:55.120
指定它已经完全实施

00:31:50.440 --> 00:31:58.620
它不是永久的，因此

00:31:55.120 --> 00:32:03.400
作为预览语言功能

00:31:58.620 --> 00:32:06.460
 Oracle提供了该功能，可以尝试

00:32:03.400 --> 00:32:09.760
开发人员，如果有的话

00:32:06.460 --> 00:32:12.820
然后该功能的主要问题

00:32:09.760 --> 00:32:17.400
也许该功能可以删除

00:32:12.820 --> 00:32:21.490
完全或者如果问题可能是

00:32:17.400 --> 00:32:25.230
纠正的马，那么未来它将

00:32:21.490 --> 00:32:27.490
被添加到平台

00:32:25.230 --> 00:32:31.300
修改以及您为什么认为

00:32:27.490 --> 00:32:34.809
这很重要，因为Java几乎

00:32:31.300 --> 00:32:37.510
现在二十岁了，这并不容易

00:32:34.809 --> 00:32:39.760
引入新功能，无论是

00:32:37.510 --> 00:32:44.740
语言功能或平台功能

00:32:39.760 --> 00:32:46.300
如果它破坏了现有代码，因为

00:32:44.740 --> 00:32:49.240
我们正在谈论落后

00:32:46.300 --> 00:32:53.320
兼容性，因此任何新功能

00:32:49.240 --> 00:33:00.010
被添加到平台语言

00:32:53.320 --> 00:33:02.320
这样做应该是安全的，当然我们

00:33:00.010 --> 00:33:05.290
在谈论高质量的功能

00:33:02.320 --> 00:33:08.920
因此，实验或预览

00:33:05.290 --> 00:33:11.650
功能不是不完整的功能，并且

00:33:08.920 --> 00:33:14.410
他们不是实验性的

00:33:11.650 --> 00:33:18.660
完全实现的功能

00:33:14.410 --> 00:33:18.660
只是Oracle正在寻求

00:33:19.040 --> 00:33:24.740
开发人员的反馈，以便它

00:33:21.110 --> 00:33:33.380
知道是的，这是我以前想的

00:33:24.740 --> 00:33:36.950
它包含在语言中，所以

00:33:33.380 --> 00:33:38.780
这是Brian的推文， 

00:33:36.950 --> 00:33:41.930
 Oracle的首席架构师，所以我

00:33:38.780 --> 00:33:46.130
故意在我的会议中加入

00:33:41.930 --> 00:33:50.840
只是为了强调这一事实

00:33:46.130 --> 00:33:53.150
 Oracle未标记Java表达式

00:33:50.840 --> 00:33:55.520
作为预览语言功能

00:33:53.150 --> 00:33:59.150
实际从

00:33:55.520 --> 00:34:01.520
开发人员，以便您可以看到

00:33:59.150 --> 00:34:04.100
当然，布莱恩的官方频道是

00:34:01.520 --> 00:34:05.990
寻找有关开发人员的反馈

00:34:04.100 --> 00:34:10.400
最新的Java未来即将到来

00:34:05.990 --> 00:34:14.540
表达式，然后退出

00:34:10.400 --> 00:34:17.630
以前的状态，所以我问Brian 

00:34:14.540 --> 00:34:20.919
我四处寻找最后的约会

00:34:17.630 --> 00:34:24.470
当然有一些反馈

00:34:20.919 --> 00:34:26.900
没有具体日期提交反馈

00:34:24.470 --> 00:34:29.750
但是，如果您正在考虑

00:34:26.900 --> 00:34:34.100
现在提交您的反馈

00:34:29.750 --> 00:34:37.570
不接受，火车已经完成了

00:34:34.100 --> 00:34:39.050
运行它已经离开了站台

00:34:37.570 --> 00:34:43.450
好的

00:34:39.050 --> 00:34:48.380
所以这是您可以使用的另一个链接

00:34:43.450 --> 00:34:50.510
所以这是此页面显示的

00:34:48.380 --> 00:34:53.840
更改Java语言

00:34:50.510 --> 00:34:57.650
规格，如您所见

00:34:53.840 --> 00:35:00.950
 5月20日一天前修改

00:34:57.650 --> 00:35:06.160
 2019，这是您可以的链接

00:35:00.950 --> 00:35:09.410
用于访问此页面，实际上

00:35:06.160 --> 00:35:11.990
好的，我这里没有链接，所以这是

00:35:09.410 --> 00:35:15.160
只是一张图片，所以我很抱歉

00:35:11.990 --> 00:35:18.920
不能在行动中证明这一点

00:35:15.160 --> 00:35:21.620
给您，但如果您可以访问此链接

00:35:18.920 --> 00:35:24.410
 Yasir只需输入您的地址

00:35:21.620 --> 00:35:28.970
在地址栏中看到这里，你

00:35:24.410 --> 00:35:32.000
就能看到文档

00:35:28.970 --> 00:35:34.970
关于switch语句的用法

00:35:32.000 --> 00:35:38.510
开关表达式已添加到Java 

00:35:34.970 --> 00:35:41.450
语言规范，我重复一遍

00:35:38.510 --> 00:35:47.510
还没有被添加，所以直到现在

00:35:41.450 --> 00:35:50.840
它已经添加，在这里14.51 

00:35:47.510 --> 00:35:54.560
 -您也可以看到与

00:35:50.840 --> 00:35:56.740
声明当然是这样收集后

00:35:54.560 --> 00:36:01.250
来自开发人员的反馈

00:35:56.740 --> 00:36:05.090
 Oracle还包括开关表达式

00:36:01.250 --> 00:36:07.970
另一个带连字符的关键字-Java 

00:36:05.090 --> 00:36:11.150
如此与之融为一体的语言

00:36:07.970 --> 00:36:14.570
我会让我回头的例子

00:36:11.150 --> 00:36:17.630
这个例子好吧，所以在这种情况下，我

00:36:14.570 --> 00:36:20.720
使用break语句返回一个

00:36:17.630 --> 00:36:22.940
值，但我想当然是

00:36:20.720 --> 00:36:25.910
听起来有点困惑

00:36:22.940 --> 00:36:28.099
开发人员，因为我们不习惯

00:36:25.910 --> 00:36:28.550
使用break语句返回一个

00:36:28.099 --> 00:36:32.510
值

00:36:28.550 --> 00:36:36.320
因此，Oracle引入了一个新关键字

00:36:32.510 --> 00:36:39.589
正如您所看到的那样

00:36:36.320 --> 00:36:42.650
在这里与声明的突破和感动

00:36:39.589 --> 00:36:44.990
转发您将是一个严重的Java 12 

00:36:42.650 --> 00:36:47.869
您可以使用break语句返回一个

00:36:44.990 --> 00:36:50.750
价值，但向前迈进

00:36:47.869 --> 00:36:53.030
能够使用break with语句来

00:36:50.750 --> 00:36:56.510
从开关表达式返回一个值

00:36:53.030 --> 00:37:01.250
 Oracle计划将Java和Java包括在内

00:36:56.510 --> 00:37:04.820
许多其他带连字符的关键字

00:37:01.250 --> 00:37:08.170
新关键字的介绍

00:37:04.820 --> 00:37:11.410
不会破坏很多以前的代码

00:37:08.170 --> 00:37:16.369
好，那对你来说是个好问题

00:37:11.410 --> 00:37:18.680
在Java 10中引入var时

00:37:16.369 --> 00:37:22.790
你必须在这里说实话

00:37:18.680 --> 00:37:30.980
您使用定义变量

00:37:22.790 --> 00:37:34.310
名称var right是的，哦，那是

00:37:30.980 --> 00:37:37.250
引入新关键字时出现问题

00:37:34.310 --> 00:37:42.550
在语言中，所以使用连字符

00:37:37.250 --> 00:37:42.550
关键字会有更多

00:37:43.510 --> 00:37:48.500
甲骨文会有更多

00:37:45.880 --> 00:37:54.530
变量名称以添加到语言

00:37:48.500 --> 00:38:00.290
不破坏现有代码就可以了

00:37:54.530 --> 00:38:04.910
现在让我们去更改API吧

00:38:00.290 --> 00:38:07.700
现在我再次回到列表

00:38:04.910 --> 00:38:12.200
我展示的API更改

00:38:07.700 --> 00:38:16.550
较早，所以您可以再次单击

00:38:12.200 --> 00:38:20.150
一个，你实际上可以像我展示的那样

00:38:16.550 --> 00:38:25.160
您可以更早地访问所有更改

00:38:20.150 --> 00:38:29.180
它们包含在Java 12和

00:38:25.160 --> 00:38:34.010
我没有提供任何具体示例

00:38:29.180 --> 00:38:38.450
故意这样做是因为它很容易

00:38:34.010 --> 00:38:41.030
只是坐下来观察

00:38:38.450 --> 00:38:45.980
示例代码，我真的会

00:38:41.030 --> 00:38:48.950
像你这样首先找出

00:38:45.980 --> 00:38:52.820
是修改还是添加

00:38:48.950 --> 00:38:59.810
甚至对Java的删除也是如此

00:38:52.820 --> 00:39:08.780
我不知道请问这个窗口

00:38:59.810 --> 00:39:12.680
抱歉，然后尝试新的语言

00:39:08.780 --> 00:39:22.160
可以自己编辑，让我们回去

00:39:12.680 --> 00:39:26.090
可以，所以Java 12还添加了一个

00:39:22.160 --> 00:39:29.930
新的API，它是一个新的包java.lang 

00:39:26.090 --> 00:39:32.590
点常量和所有这些类

00:39:29.930 --> 00:39:34.250
现在包括一个解析常数

00:39:32.590 --> 00:39:39.410
描述方法

00:39:34.250 --> 00:39:43.100
短短的耳聋，再一次我没有

00:39:39.410 --> 00:39:49.580
包括故意在

00:39:43.100 --> 00:39:52.910
 JDK 12的目的也是

00:39:49.580 --> 00:39:55.880
支持很多新角色

00:39:52.910 --> 00:39:58.470
在这里谈论国际象棋符号

00:39:55.880 --> 00:40:00.990
谈论我自己的无数

00:39:58.470 --> 00:40:03.329
这是一个有趣的基础20新

00:40:00.990 --> 00:40:10.339
医疗系统和许多其他

00:40:03.329 --> 00:40:14.730
语言也好，所以现在我们是

00:40:10.339 --> 00:40:22.880
谈论JVM的变化，所以我将

00:40:14.730 --> 00:40:25.290
快速谈论Neo实验

00:40:22.880 --> 00:40:30.270
实验性垃圾收集器

00:40:25.290 --> 00:40:32.940
 shenandoah这个垃圾收集器是

00:40:30.270 --> 00:40:33.900
由工程师在

00:40:32.940 --> 00:40:37.430
红色的帽子

00:40:33.900 --> 00:40:40.500
它保证了极低的停顿

00:40:37.430 --> 00:40:42.960
这是一个基于区域的垃圾收集器

00:40:40.500 --> 00:40:46.200
并行收集垃圾

00:40:42.960 --> 00:40:48.569
并发方式很有趣

00:40:46.200 --> 00:40:51.720
请注意，暂停时间为

00:40:48.569 --> 00:40:54.720
独立于应用程序实时数据

00:40:51.720 --> 00:40:57.630
与之前的垃圾不同

00:40:54.720 --> 00:40:59.930
收藏家的Java头和

00:40:57.630 --> 00:41:02.730
硬件工程和较低的成本

00:40:59.930 --> 00:41:05.609
服务器有更多的内存和处理能力

00:41:02.730 --> 00:41:07.800
力量比以往任何时候都现代

00:41:05.609 --> 00:41:11.040
应用程序要求越来越高

00:41:07.800 --> 00:41:12.960
通过服务水平缩短发布时间

00:41:11.040 --> 00:41:16.460
协议申请保证

00:41:12.960 --> 00:41:20.180
响应时间为10到500毫秒

00:41:16.460 --> 00:41:25.290
所以要满足范围的低端

00:41:20.180 --> 00:41:28.680
 shenandoah GC能够满足较低的要求

00:41:25.290 --> 00:41:31.079
最后，它使用的算法可以

00:41:28.680 --> 00:41:35.609
给定要执行的程序

00:41:31.079 --> 00:41:40.050
记忆的另一点是，它可以

00:41:35.609 --> 00:41:45.440
保持暂停时间低至如下

00:41:40.050 --> 00:41:48.680
如果您说10毫秒

00:41:45.440 --> 00:41:50.720
其他不是的垃圾收集器

00:41:48.680 --> 00:41:54.050
用Java可以达到

00:41:50.720 --> 00:41:56.930
使用200 GB内存的应用程序

00:41:54.050 --> 00:41:59.960
紧凑型是不可能的

00:41:56.930 --> 00:42:02.540
压缩算法将超过

00:41:59.960 --> 00:42:06.430
限制为10毫秒，因为

00:42:02.540 --> 00:42:10.880
即使压缩10％的内存

00:42:06.430 --> 00:42:13.640
那将超过雪兰多的时间

00:42:10.880 --> 00:42:17.000
使用压缩的庭内算法

00:42:13.640 --> 00:42:19.450
 Java并发存储

00:42:17.000 --> 00:42:22.790
线程正在运行，在这种情况下

00:42:19.450 --> 00:42:26.240
对象在并发GC期间移动

00:42:22.790 --> 00:42:32.050
循环及其所有参考

00:42:26.240 --> 00:42:37.850
访问新的副本其他

00:42:32.050 --> 00:42:42.860
修改GC空间是一个机器人能够

00:42:37.850 --> 00:42:48.040
垃圾优先GC的混合收集

00:42:42.860 --> 00:42:50.530
我们称之为1 GC，那么什么时候发生

00:42:48.040 --> 00:42:54.260
垃圾第一

00:42:50.530 --> 00:42:57.320
 GC尝试从

00:42:54.260 --> 00:43:00.200
年轻地区，所以年轻地区是

00:42:57.320 --> 00:43:03.740
那些是对象所在的地方

00:43:00.200 --> 00:43:07.610
经常使用和丢弃，我们

00:43:03.740 --> 00:43:10.340
有我们有的旧地区

00:43:07.610 --> 00:43:13.220
寿命很长的物体

00:43:10.340 --> 00:43:20.090
时间比年轻人长得多

00:43:13.220 --> 00:43:24.650
集合，那么当g1会发生什么

00:43:20.090 --> 00:43:27.470
 GC首先用尽了内存不足

00:43:24.650 --> 00:43:30.790
释放年轻的大学青年空间，并

00:43:27.470 --> 00:43:33.650
那么如果它跟不上

00:43:30.790 --> 00:43:36.140
通过清理年轻人来分配

00:43:33.650 --> 00:43:39.350
收集然后清理

00:43:36.140 --> 00:43:43.190
混合集合，其中包括

00:43:39.350 --> 00:43:47.360
老一辈和新一代，但在那

00:43:43.190 --> 00:43:51.080
如果我想中止该怎么办

00:43:47.360 --> 00:43:55.190
 JDK 12之前的集合不是

00:43:51.080 --> 00:43:58.220
可能，但是使用JDK 12可以

00:43:55.190 --> 00:43:58.470
我中止了

00:43:58.220 --> 00:44:03.330
的

00:43:58.470 --> 00:44:07.070
当然，即使是垃圾收集器

00:44:03.330 --> 00:44:12.170
说我可以中止我的收藏

00:44:07.070 --> 00:44:15.570
减少时间，那么会发生什么

00:44:12.170 --> 00:44:18.420
现在大多数应用程序

00:44:15.570 --> 00:44:21.560
在容器空间中运行

00:44:18.420 --> 00:44:24.690
如果您有多个会发生

00:44:21.560 --> 00:44:30.240
应用程序，或者您有多个gbm 

00:44:24.690 --> 00:44:32.550
他们正在使用的内存

00:44:30.240 --> 00:44:37.200
一个已经分配给他们，但

00:44:32.550 --> 00:44:38.910
在这种情况下，他们不使用它

00:44:37.200 --> 00:44:41.750
运行这些的组织

00:44:38.910 --> 00:44:44.400
申请将不得不为

00:44:41.750 --> 00:44:47.180
运行应用程序，因为我们

00:44:44.400 --> 00:44:51.570
谈论支付资源

00:44:47.180 --> 00:44:54.300
如果应用程序正在使用

00:44:51.570 --> 00:44:57.420
未被使用的资源

00:44:54.300 --> 00:45:02.070
作为记忆，那就是

00:44:57.420 --> 00:45:04.920
需要更正，因此使用Java 12 

00:45:02.070 --> 00:45:08.359
 G 1垃圾收集器可以迅速

00:45:04.920 --> 00:45:13.410
返回未使用的已提交内存

00:45:08.359 --> 00:45:15.599
绞索承诺的记忆，因为那里

00:45:13.410 --> 00:45:18.480
当垃圾只有两次

00:45:15.599 --> 00:45:22.109
收集器返回内存，所以一个

00:45:18.480 --> 00:45:24.480
是完整的GC，是完整的垃圾

00:45:22.109 --> 00:45:28.470
收集，只有这样

00:45:24.480 --> 00:45:32.220
真的发生了，所以一个人会全力以赴

00:45:28.470 --> 00:45:34.380
可以避免完全的垃圾

00:45:32.220 --> 00:45:37.710
收集它会尝试释放

00:45:34.380 --> 00:45:42.270
年轻的空间，如果没有

00:45:37.710 --> 00:45:45.150
设法分配更多

00:45:42.270 --> 00:45:47.760
对象，那么它将去完整的

00:45:45.150 --> 00:45:50.190
母狗收集，那是一次

00:45:47.760 --> 00:45:52.950
垃圾收集器何时返回

00:45:50.190 --> 00:45:59.070
未使用的提交给主机的内存

00:45:52.950 --> 00:46:01.830
但是使用JDK 12，您可以终止

00:45:59.070 --> 00:46:09.230
返回未提交的内存

00:46:01.830 --> 00:46:12.529
特定的时间或事件可以

00:46:09.230 --> 00:46:16.039
这是最后一张幻灯片，我会

00:46:12.529 --> 00:46:20.240
喜欢留下一条推文

00:46:16.039 --> 00:46:22.549
我收到的其中一个

00:46:20.240 --> 00:46:26.539
我最初提到的民意调查

00:46:22.549 --> 00:46:30.710
说升级到Java 9似乎是

00:46:26.539 --> 00:46:33.109
迈出了一大步，直到很明显，如果我

00:46:30.710 --> 00:46:38.029
我真的不需要拼图，我可以漂亮

00:46:33.109 --> 00:46:41.000
从Java 9到12忽略它不是一个

00:46:38.029 --> 00:46:43.640
从7变到8的确很重要

00:46:41.000 --> 00:46:47.690
这实质上意味着我们可以

00:46:43.640 --> 00:46:51.289
考虑步骤ABC迁移到

00:46:47.690 --> 00:46:54.529
一定水平，但我们也可以意识到

00:46:51.289 --> 00:47:01.789
我们可能不需要这些步骤

00:46:54.529 --> 00:47:05.359
迁移到新版本，例如Java 

00:47:01.789 --> 00:47:08.869
我们需要的开发人员，建筑师，经理

00:47:05.359 --> 00:47:12.410
知道存在哪些选择

00:47:08.869 --> 00:47:15.849
当我们更新技术时

00:47:12.410 --> 00:47:20.299
衣柜，因为要做出正确的决定

00:47:15.849 --> 00:47:23.210
我们必须意识到选择

00:47:20.299 --> 00:47:25.940
我们有，而且只有一个好的工具

00:47:23.210 --> 00:47:27.759
我们可以做出好的选择

00:47:25.940 --> 00:47:31.670
决定

00:47:27.759 --> 00:47:36.470
所以我的建议，如果您正在考虑

00:47:31.670 --> 00:47:40.130
转向Java 12我建议

00:47:36.470 --> 00:47:42.529
即使您是Java 12， 

00:47:40.130 --> 00:47:45.140
短期支持发布，以及由于我们

00:47:42.529 --> 00:47:47.750
 Java 11是长期的

00:47:45.140 --> 00:47:51.559
支持发布仅六个月前

00:47:47.750 --> 00:47:56.769
会建议您转到Java 11，但是

00:47:51.559 --> 00:47:59.359
作为开发人员，我希望您使用

00:47:56.769 --> 00:48:02.509
像IntelliJ IDEA这样的平台

00:47:59.359 --> 00:48:05.900
你可以编译代码并

00:48:02.509 --> 00:48:09.500
针对多个版本运行它，看看

00:48:05.900 --> 00:48:11.720
如果您说问题出在哪里

00:48:09.500 --> 00:48:15.380
如果要将代码迁移到Java 11 

00:48:11.720 --> 00:48:18.890
如果您尝试将其移至

00:48:15.380 --> 00:48:22.099
一个更高版本的某个时间以后会很好

00:48:18.890 --> 00:48:23.090
来测试现有代码

00:48:22.099 --> 00:48:27.560
较新的版本

00:48:23.090 --> 00:48:30.890
因为Java 9 Oracle中的Java具有

00:48:27.560 --> 00:48:33.470
开始删除已弃用的API 

00:48:30.890 --> 00:48:35.510
更严重的是，他们不只是

00:48:33.470 --> 00:48:38.690
让您进行编译

00:48:35.510 --> 00:48:41.240
错误，他们正在删除API的

00:48:38.690 --> 00:48:45.470
这是一个很小的迁移，我会

00:48:41.240 --> 00:48:47.720
说要在Java 11上运行，但要测试您的代码

00:48:45.470 --> 00:48:51.230
在Java 12上，这样您现在就知道了

00:48:47.720 --> 00:48:53.810
没有主要的热门节目或

00:48:51.230 --> 00:48:58.120
障碍，以便当您移至

00:48:53.810 --> 00:49:04.100
较新的版本，您会看到很多

00:48:58.120 --> 00:49:07.300
问题非常感谢你，我很好

00:49:04.100 --> 00:49:09.710
现在就提问

00:49:07.300 --> 00:49:12.620
非常感谢，很棒， 

00:49:09.710 --> 00:49:14.330
我有很多问题

00:49:12.620 --> 00:49:16.670
在后端回答了其中的一些

00:49:14.330 --> 00:49:20.450
根据我的特别理解

00:49:16.670 --> 00:49:21.890
开关表达式周围有一个

00:49:20.450 --> 00:49:24.770
我有点感兴趣的问题

00:49:21.890 --> 00:49:27.290
知道答案是什么

00:49:24.770 --> 00:49:29.180
是我们可以加入默认部分吗

00:49:27.290 --> 00:49:32.000
如果返回其他案例部分

00:49:29.180 --> 00:49:35.960
值相同或默认

00:49:32.000 --> 00:49:38.140
总是必须分开是的，我猜

00:49:35.960 --> 00:49:43.730
它总是必须分开我们不能

00:49:38.140 --> 00:49:46.820
有我真的会喜欢我的

00:49:43.730 --> 00:49:49.370
朋友，是啊，因为不是这样

00:49:46.820 --> 00:49:52.070
不是从大小写正确开始

00:49:49.370 --> 00:49:55.130
对，所以只有D点，所以我没有

00:49:52.070 --> 00:49:56.510
认为有可能我同意

00:49:55.130 --> 00:49:58.690
你可以试试看，但我想是你

00:49:56.510 --> 00:50:00.140
会得到某种编译器错误

00:49:58.690 --> 00:50:04.460
好吧

00:50:00.140 --> 00:50:06.350
是的，所以如果您的默认设置很好

00:50:04.460 --> 00:50:09.380
实际上，所以尝试尝试将

00:50:06.350 --> 00:50:11.570
默认票价为11，看看IntelliJ是什么

00:50:09.380 --> 00:50:15.560
 IDEA建议，因为我认为这样会

00:50:11.570 --> 00:50:17.870
想要您删除吸管和杯子，因为

00:50:15.560 --> 00:50:20.800
默认情况下处理

00:50:17.870 --> 00:50:20.800
你去那里看看

00:50:22.619 --> 00:50:26.880
万一说删除冗余开关

00:50:25.950 --> 00:50:29.670
科

00:50:26.880 --> 00:50:32.130
好的，所以它可以，所以你不能

00:50:29.670 --> 00:50:35.730
实际具有默认情况

00:50:32.130 --> 00:50:38.940
其他情况下，在这种情况下，IntelliJ 

00:50:35.730 --> 00:50:41.519
 IDEA表示，好的，因为您是

00:50:38.940 --> 00:50:43.289
使用相同的返回值

00:50:41.519 --> 00:50:47.039
默认分支和其他标签

00:50:43.289 --> 00:50:50.779
所以那些标签是多余的，它

00:50:47.039 --> 00:50:58.799
刚刚删除了那些有意义的

00:50:50.779 --> 00:51:00.509
好吧，让我看看那里也是如此

00:50:58.799 --> 00:51:03.859
您问问题的幻灯片

00:51:00.509 --> 00:51:07.470
关于哪个代码可以解决问题

00:51:03.859 --> 00:51:08.789
对，我们有很多现在

00:51:07.470 --> 00:51:12.930
希望我们有一个号码，我们有一个

00:51:08.789 --> 00:51:16.589
为什么会有不同的答案

00:51:12.930 --> 00:51:19.890
是吗，是的，所以有一个

00:51:16.589 --> 00:51:23.190
添加另一个的可能性

00:51:19.890 --> 00:51:26.309
枚举值或添加默认值

00:51:23.190 --> 00:51:28.140
所以有人说我们需要

00:51:26.309 --> 00:51:31.109
默认有人说两个

00:51:28.140 --> 00:51:34.319
人们说有些人

00:51:31.109 --> 00:51:36.960
说好吧，所以正确

00:51:34.319 --> 00:51:38.880
答案是因为我们在说话

00:51:36.960 --> 00:51:42.210
关于开关表达式

00:51:38.880 --> 00:51:44.009
返回一个值，因为像我

00:51:42.210 --> 00:51:48.210
提到板是唯一的

00:51:44.009 --> 00:51:50.999
从案例标签进行评估，以便

00:51:48.210 --> 00:51:53.999
您可以添加行号1或

00:51:50.999 --> 00:51:56.359
第2行，当然，如果您要添加

00:51:53.999 --> 00:51:59.700
他们两个都是正确的

00:51:56.359 --> 00:52:04.349
但答案是其中之一

00:51:59.700 --> 00:52:14.369
应该吗，是的，我想答案

00:52:04.349 --> 00:52:15.140
会是一两个还是两个都可以

00:52:14.369 --> 00:52:18.420
大

00:52:15.140 --> 00:52:21.630
周围也有些混乱

00:52:18.420 --> 00:52:22.710
就我而言，打破和打破宽度

00:52:21.630 --> 00:52:24.569
了解它是因为人们很友善

00:52:22.710 --> 00:52:26.849
说如何使用break来

00:52:24.569 --> 00:52:29.009
返回值并中断跳转

00:52:26.849 --> 00:52:31.440
标签以及它如何与

00:52:29.009 --> 00:52:32.999
向后兼容，所以我相信

00:52:31.440 --> 00:52:35.810
你的意思是说他们

00:52:32.999 --> 00:52:38.180
从Java 13开始

00:52:35.810 --> 00:52:42.530
你不会用break你会用break 

00:52:38.180 --> 00:52:44.330
是这样吗，就像我一样

00:52:42.530 --> 00:52:46.820
提到所以这是一种预览语言

00:52:44.330 --> 00:52:48.470
功能和甲骨文试图

00:52:46.820 --> 00:52:51.440
收集反馈和很多

00:52:48.470 --> 00:52:54.170
开发人员提出了同样的建议

00:52:51.440 --> 00:52:56.750
使用时有很多困惑

00:52:54.170 --> 00:52:59.600
没有价值的突破以及何时使用

00:52:56.750 --> 00:53:01.760
打破一个值，所以他们已经修改

00:52:59.600 --> 00:53:04.940
开关表达式，所以代替

00:53:01.760 --> 00:53:07.130
使用带有值的break语句

00:53:04.940 --> 00:53:10.550
返回一个值，他们将是

00:53:07.130 --> 00:53:14.000
现在使用的中断宽度是break- 

00:53:10.550 --> 00:53:18.260
与，但将适用于下一个

00:53:14.000 --> 00:53:20.450
版本或是下一个版本，但不是

00:53:18.260 --> 00:53:22.940
 Java的这个版本，所以您可以

00:53:20.450 --> 00:53:26.750
仍然使用break然后将值

00:53:22.940 --> 00:53:28.250
从那里返回一个值

00:53:26.750 --> 00:53:30.380
新发行节奏有一点点

00:53:28.250 --> 00:53:32.720
混淆的权利，因为和事实

00:53:30.380 --> 00:53:34.010
我们具有预览功能，因为

00:53:32.720 --> 00:53:36.260
您是在开始预览时说的

00:53:34.010 --> 00:53:39.320
特征是可塑的

00:53:36.260 --> 00:53:41.750
可能会改变，所以我们不应该真的

00:53:39.320 --> 00:53:43.400
一直在使用Java 12进行预览

00:53:41.750 --> 00:53:45.500
生产中的功能，因为有一个

00:53:43.400 --> 00:53:49.010
开关表达式将很有可能

00:53:45.500 --> 00:53:51.770
改变前进没事吧

00:53:49.010 --> 00:53:53.750
你是对的，因为那和

00:53:51.770 --> 00:53:56.030
说他们有测试版功能

00:53:53.750 --> 00:53:58.670
他们正在分发给

00:53:56.030 --> 00:54:01.040
开发人员以及每个beta 

00:53:58.670 --> 00:54:03.830
我们知道的功能是，我们有一个

00:54:01.040 --> 00:54:07.240
在那里改变的可能性很好

00:54:03.830 --> 00:54:10.790
给开发人员尝试帮助

00:54:07.240 --> 00:54:13.250
决定他们希望Java如何

00:54:10.790 --> 00:54:14.960
会存在，但当然存在风险

00:54:13.250 --> 00:54:16.940
在那里，因为如果我们使用

00:54:14.960 --> 00:54:19.220
介绍，那么我们将不得不

00:54:16.940 --> 00:54:21.590
完全改变它，我认为

00:54:19.220 --> 00:54:23.960
重要的是要注意我们

00:54:21.590 --> 00:54:26.270
应该使用预览功能

00:54:23.960 --> 00:54:28.010
当你说帮助塑造语言给

00:54:26.270 --> 00:54:31.880
反馈并说出什么在起作用， 

00:54:28.010 --> 00:54:34.460
什么不对，因为很容易

00:54:31.880 --> 00:54:37.490
婴儿床一些功能很容易

00:54:34.460 --> 00:54:40.700
说哦JA tha没做让我们说

00:54:37.490 --> 00:54:43.250
是B还是C，但重要的是

00:54:40.700 --> 00:54:46.910
参与并提供您的反馈意见， 

00:54:43.250 --> 00:54:49.770
只使用它，所以我们不是Oracle 

00:54:46.910 --> 00:54:52.050
并不需要很多投入

00:54:49.770 --> 00:54:54.060
他们并没有要求每个人都

00:54:52.050 --> 00:54:56.400
去贡献API或

00:54:54.060 --> 00:55:00.150
只是通过测试而已

00:54:56.400 --> 00:55:03.150
开发人员可以帮助他们塑造Java 

00:55:00.150 --> 00:55:05.370
想成为，所以有一个相关的

00:55:03.150 --> 00:55:07.920
问题在这里，有一种方法可以禁止

00:55:05.370 --> 00:55:10.020
有没有办法禁止预览

00:55:07.920 --> 00:55:12.030
构建配置中的功能，例如通过

00:55:10.020 --> 00:55:14.100
向编译器提供参数

00:55:12.030 --> 00:55:17.010
答案实际上是默认情况下的

00:55:14.100 --> 00:55:20.010
没有正确的预览功能

00:55:17.010 --> 00:55:22.830
没有像默认一样学习

00:55:20.010 --> 00:55:25.110
对，但实验功能和

00:55:22.830 --> 00:55:28.380
预览功能已关闭

00:55:25.110 --> 00:55:31.290
默认情况下，要使用它们，您必须

00:55:28.380 --> 00:55:34.980
通过提供将它们打开

00:55:31.290 --> 00:55:37.500
相关的命令行参数和

00:55:34.980 --> 00:55:39.720
当然，当我们在IntelliJ中配置它时

00:55:37.500 --> 00:55:42.390
将其添加到配置的IDEA 

00:55:39.720 --> 00:55:46.080
将其添加到编译工具中

00:55:42.390 --> 00:55:49.730
处理正确，我在这里有一个问题

00:55:46.080 --> 00:55:52.260
 Java 12是否可以与Spring Boot一起使用

00:55:49.730 --> 00:55:57.690
春天进入框架并在 spring 5 

00:55:52.260 --> 00:56:00.090
加框架，我没有

00:55:57.690 --> 00:56:04.830
回答一天，也许我们可以带

00:56:00.090 --> 00:56:06.330
 Josh关于那个我正在使用Java 12的文章

00:56:04.830 --> 00:56:08.400
一点点的天气

00:56:06.330 --> 00:56:09.990
似乎只是无缝地工作，但我

00:56:08.400 --> 00:56:12.810
再想一次，就像你刚才说的那样

00:56:09.990 --> 00:56:16.440
从11到12相当轻松

00:56:12.810 --> 00:56:19.050
但是从8到12可能是一个

00:56:16.440 --> 00:56:21.780
据我所知，跳远了一点

00:56:19.050 --> 00:56:25.800
所有常见的库似乎都可以工作

00:56:21.780 --> 00:56:27.000
使用Java 12，但我们可以找出并

00:56:25.800 --> 00:56:29.490
我要做的实际上是问题

00:56:27.000 --> 00:56:30.750
我们无法完全回答，我们会做什么

00:56:29.490 --> 00:56:32.850
是我们会记下它们，然后我们

00:56:30.750 --> 00:56:35.010
可以在最后将它们添加到博客文章中

00:56:32.850 --> 00:56:37.350
当我们发布记录的地方

00:56:35.010 --> 00:56:39.870
网络研讨会中，我们还可以发布答案

00:56:37.350 --> 00:56:42.410
我们无法回答的问题

00:56:39.870 --> 00:56:46.200
是的，那太好了， 

00:56:42.410 --> 00:56:53.160
还有一个关于你的问题

00:56:46.200 --> 00:56:56.940
提早提到一个常量类型

00:56:53.160 --> 00:56:59.400
我再一次提到了I型

00:56:56.940 --> 00:57:02.010
认为这是它的输入

00:56:59.400 --> 00:57:03.090
我认为是琥珀色但我不喜欢

00:57:02.010 --> 00:57:03.540
记得你提到它可能有

00:57:03.090 --> 00:57:08.960
曾经是

00:57:03.540 --> 00:57:08.960
抱歉之一让我找到它

00:57:12.800 --> 00:57:19.320
对不起，只是试图滚动过去

00:57:14.670 --> 00:57:20.730
其他问题和字符串更改

00:57:19.320 --> 00:57:22.080
当你看时有提及

00:57:20.730 --> 00:57:23.990
当您查看字符串API时

00:57:22.080 --> 00:57:27.450
第一部分的变化

00:57:23.990 --> 00:57:31.980
常量类型好

00:57:27.450 --> 00:57:35.090
是的，哦，我们走了，是的，那是一个

00:57:31.980 --> 00:57:39.720
我们拥有的neocon界面

00:57:35.090 --> 00:57:43.290
 java.lang包，我们也有

00:57:39.720 --> 00:57:48.090
另一个接口是常数de 

00:57:43.290 --> 00:57:50.310
 SE和我真的会鼓励

00:57:48.090 --> 00:57:52.770
要求通过的人

00:57:50.310 --> 00:57:54.720
文档，因为我看到的是

00:57:52.770 --> 00:57:56.730
很多开发人员是他们不

00:57:54.720 --> 00:58:00.840
通读大量文档，然后

00:57:56.730 --> 00:58:04.620
然后他们错过了很多点，所以是的

00:58:00.840 --> 00:58:08.820
他们可以在此处访问此网址， 

00:58:04.620 --> 00:58:10.740
可以通过它我也会

00:58:08.820 --> 00:58:12.930
当我们在博客文章中发布该网址时

00:58:10.740 --> 00:58:16.050
以后有录音，因为我

00:58:12.930 --> 00:58:17.340
有人问这个网址，好吧

00:58:16.050 --> 00:58:18.810
周围还有另一个问题

00:58:17.340 --> 00:58:20.610
他们是因为周围有混乱

00:58:18.810 --> 00:58:22.410
什么是混合收藏，什么是

00:58:20.610 --> 00:58:24.600
随身携带垃圾的意思

00:58:22.410 --> 00:58:25.800
收集，我再想一想

00:58:24.600 --> 00:58:27.390
我们要做的就是进一步发布

00:58:25.800 --> 00:58:29.190
有关一些垃圾的信息

00:58:27.390 --> 00:58:30.870
集合更改的具体更改

00:58:29.190 --> 00:58:32.730
你经历了，然后如果人们想要

00:58:30.870 --> 00:58:34.020
找出更多细节

00:58:32.730 --> 00:58:36.840
他们也许可以跟随这些链接

00:58:34.020 --> 00:58:41.850
然后阅读该文档

00:58:36.840 --> 00:58:43.380
感觉很好，很好，我相信

00:58:41.850 --> 00:58:47.610
我们已经回答了所有问题

00:58:43.380 --> 00:58:49.770
在网络研讨会窗口中

00:58:47.610 --> 00:58:52.290
谢谢大家这么好

00:58:49.770 --> 00:58:54.750
您曾经是极富吸引力的观众

00:58:52.290 --> 00:58:57.210
我说的问题非常活跃

00:58:54.750 --> 00:59:00.120
我们要做的是发布博客

00:58:57.210 --> 00:59:01.290
包含打开视频的帖子

00:59:00.120 --> 00:59:03.180
请在此链接到视频

00:59:01.290 --> 00:59:05.760
有录音，我们会回答

00:59:03.180 --> 00:59:07.050
任何未回答的问题

00:59:05.760 --> 00:59:09.000
表示如果您没有机会

00:59:07.050 --> 00:59:11.760
立即回答您的问题

00:59:09.000 --> 00:59:15.180
请随时通过Twitter对我们进行ping操作

00:59:11.760 --> 00:59:16.320
或者也许给我们发电子邮件等等

00:59:15.180 --> 00:59:19.800
 Twitter你

00:59:16.320 --> 00:59:23.610
你在第一张幻灯片上有我们的手柄

00:59:19.800 --> 00:59:30.270
我们的Twitter处理我不

00:59:23.610 --> 00:59:32.400
这么想，所以给它发了一封电子邮件， 

00:59:30.270 --> 00:59:34.530
 Trisha在Twitter上强调了G，所以感觉

00:59:32.400 --> 00:59:37.410
即使在

00:59:34.530 --> 00:59:41.160
网络研讨会，我们可以回答这些问题

00:59:37.410 --> 00:59:42.150
在博客文章中，非常感谢

00:59:41.160 --> 00:59:43.620
你真是一个了不起的听众

00:59:42.150 --> 00:59:47.990
谢谢你，这真的很棒

00:59:43.620 --> 00:59:47.990
 JDK 12新增功能的演示文稿

00:59:53.860 --> 00:59:55.920
您

