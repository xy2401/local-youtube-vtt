WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.790 --> 00:00:02.810
 [音乐] 

00:00:12.879 --> 00:00:15.099
您好，欢迎来到如此庞大的规模

00:00:15.099 --> 00:00:18.320
打开有关JDK 8的在线课程。 

00:00:18.320 --> 00:00:22.800
在本课程中，我们将研究一些新功能

00:00:22.800 --> 00:00:23.390
包括在内

00:00:23.390 --> 00:00:26.810
在JDK 8和Java编程语言中

00:00:26.810 --> 00:00:31.290
和Java库，这些库使您可以采用更实用的方法

00:00:31.290 --> 00:00:34.489
在开发应用程序时。这将使用

00:00:34.489 --> 00:00:39.350
 Lambda表达式 stream API。我叫西蒙·里特（Simon Ritter）， 

00:00:39.350 --> 00:00:43.010
 Java技术推广员， 

00:00:43.010 --> 00:00:47.150
我将指导您完成我们的三个每周课程

00:00:47.150 --> 00:00:55.460
本课程。本课程的目的

00:00:55.460 --> 00:00:59.100
是给你一个关于如何使用的想法

00:00:59.100 --> 00:01:03.040
 Lambda表达式，所以我们将讨论这些表达式的各个方面

00:01:03.040 --> 00:01:07.630
 Lambda表达式的语法；您可以在哪里使用它们；如何使用等。 

00:01:07.979 --> 00:01:11.520
然后，我们将讨论Streams API以及如何

00:01:11.520 --> 00:01:15.100
他们可以广泛使用Lambda表达式为您提供更多

00:01:15.100 --> 00:01:16.030
的函数式风格

00:01:16.030 --> 00:01:20.049
使用JDK 8进行编程

00:01:20.049 --> 00:01:23.180
当您了解如何正确使用它们时， 

00:01:23.180 --> 00:01:26.549
解决很多常见问题的更好方法

00:01:26.549 --> 00:01:30.140
在我们如何处理数据方面， 

00:01:30.140 --> 00:01:34.570
我们如何处理收集数据。它使您更加简洁

00:01:34.570 --> 00:01:38.229
更灵活的方式，因此代码变为

00:01:38.229 --> 00:01:42.220
更易于阅读，更易于理解和维护。 

00:01:42.220 --> 00:01:45.680
另一个很大的优势是

00:01:45.680 --> 00:01:49.189
您现在可以轻松得多的事实

00:01:49.189 --> 00:01:52.280
利用多个核心处理器，并且

00:01:52.280 --> 00:01:55.770
如果您的计算机具有更多的多个处理器，则

00:01:55.770 --> 00:01:59.750
并行执行代码可以变得非常简单

00:01:59.750 --> 00:02:07.219
使用这种类型的语法。 

00:02:07.219 --> 00:02:10.410
让我们从第1课开始，在本课中

00:02:10.410 --> 00:02:17.569
我们将看一下Lambda表达式。本课程的议程

00:02:17.569 --> 00:02:21.040
首先，我们将开始谈论为什么

00:02:21.040 --> 00:02:24.720
我们需要向Java添加Lambda表达式。 Java是

00:02:24.720 --> 00:02:29.080
二十岁的时候，我们为过去20年的编程非常愉快

00:02:29.080 --> 00:02:29.530
岁月

00:02:29.530 --> 00:02:32.819
自JDK 8至今已有19年了

00:02:32.819 --> 00:02:36.650
自发布以来，我们一直在使用Java 

00:02:36.650 --> 00:02:40.519
没有Lambda表达式的很好的19年，为什么我们需要添加

00:02:40.519 --> 00:02:41.690
在这个时间点？ 

00:02:41.690 --> 00:02:45.150
我们需要了解的语法

00:02:45.150 --> 00:02:48.579
 Lambda表达式，因此我们将对其进行详细介绍，然后

00:02:48.579 --> 00:02:52.299
我们将研究可以实际使用Lambda表达式的地方

00:02:52.299 --> 00:02:55.329
从本质上讲，这是您可以在哪里使用

00:02:55.329 --> 00:02:59.329
函数式接口。因此，我们将描述什么是函数式接口， 

00:02:59.329 --> 00:03:02.540
它们的定义，使用方式等。 

00:03:02.540 --> 00:03:05.560
我们将从那里出发

00:03:05.560 --> 00:03:08.590
看一些新的函数式接口

00:03:08.590 --> 00:03:09.450
包括在内

00:03:09.450 --> 00:03:13.090
在java.util.function包中，以及这些

00:03:13.090 --> 00:03:16.090
当我们开始谈论流时，这是非常相关的

00:03:16.090 --> 00:03:19.790
在第二课中，因为它们被广泛使用

00:03:19.790 --> 00:03:25.650
与流结合。 JDK 8中包含的另一件事

00:03:25.650 --> 00:03:27.750
 Lambda表达式周围

00:03:27.750 --> 00:03:31.170
是创建某些类型的Lambda的简便方法

00:03:31.170 --> 00:03:35.069
表达式，您只使用对特定方法的调用

00:03:35.069 --> 00:03:39.500
或使用构造函数，所以这些是方法和构造函数的引用

00:03:39.500 --> 00:03:43.489
我们将说明三种可以使用的不同情况

00:03:43.489 --> 00:03:48.639
再次说明语法和工作方式。有一些

00:03:48.639 --> 00:03:52.470
相当复杂的规则，但是您需要一些规则

00:03:52.470 --> 00:03:53.500
了解

00:03:53.500 --> 00:03:57.700
关于如何从周围的范围引用变量

00:03:57.700 --> 00:04:01.410
在Lambda表达式中。我们将对此进行详细介绍， 

00:04:01.410 --> 00:04:04.840
我们将讨论规则是什么，如何使用事物以及

00:04:04.840 --> 00:04:10.290
编译器如何实际帮助您解决某些情况。 

00:04:10.290 --> 00:04:13.840
在本课程的最后一部分，我们将介绍一些新方法

00:04:13.840 --> 00:04:15.360
已经添加到现有的

00:04:15.360 --> 00:04:18.959
流API之外的JDK 8库

00:04:18.959 --> 00:04:22.950
您可以在其中使用Lambda表达式；一些您真正有用的东西

00:04:22.950 --> 00:04:23.630
可以做

00:04:23.630 --> 00:04:33.080
用于收集，也用于日志记录。 

00:04:33.080 --> 00:04:36.770
然后，我们从第一课的第一部分开始

00:04:36.770 --> 00:04:43.690
 Java为什么需要Lambda表达式？现在我提到

00:04:43.690 --> 00:04:47.450
这允许您做的是简化

00:04:47.450 --> 00:04:50.700
如何利用多核

00:04:50.700 --> 00:04:53.750
处理器和多个处理器。 

00:04:53.750 --> 00:04:58.410
如果您看一下Java的历史，您会发现从一开始就是这样

00:04:58.410 --> 00:04:59.250
开始

00:04:59.250 --> 00:05:02.660
 Java的概念是

00:05:02.660 --> 00:05:06.380
能够支持多个执行流， 

00:05:06.380 --> 00:05:10.350
多执行线程。 

00:05:10.350 --> 00:05:14.920
在JDK 1.0中，您有一个java.lang.thread类， 

00:05:14.920 --> 00:05:18.970
它允许您创建一个单独的线程。您可以定义

00:05:18.970 --> 00:05:22.600
通过使用类似可运行的代码

00:05:22.600 --> 00:05:26.270
您想在该线程中执行。那很棒，因为那意味着

00:05:26.270 --> 00:05:27.320
很简单

00:05:27.320 --> 00:05:31.410
创建多个可以并行执行操作的线程。 

00:05:31.410 --> 00:05:35.390
我们遇到的问题

00:05:35.390 --> 00:05:39.370
是当您有多个线程想要一起工作时

00:05:39.370 --> 00:05:43.600
如果它们是分开工作的，一旦您希望线程工作就没问题了

00:05:43.600 --> 00:05:44.290
一起

00:05:44.290 --> 00:05:47.530
共享数据并能够协调

00:05:47.530 --> 00:05:50.770
他们的活动，在某些时间点

00:05:50.770 --> 00:05:54.970
那么您在使用该线程时会受到很大的限制。 

00:05:54.970 --> 00:05:58.900
线程类中基本上有四个方法

00:05:58.900 --> 00:06:02.640
可以做到的，有睡眠，打扰， 

00:06:02.640 --> 00:06:06.320
等待并通知。 

00:06:06.320 --> 00:06:09.890
编写具有多个线程协同工作的代码

00:06:09.890 --> 00:06:14.240
仅使用这些API实际上非常困难。 

00:06:14.240 --> 00:06:17.910
我们想要做的就是简化它。 

00:06:17.910 --> 00:06:21.050
在JDK 5.0中，我们介绍了

00:06:21.050 --> 00:06:25.140
并发实用程序（这是JSR 166， 

00:06:25.140 --> 00:06:28.860
 Java规范要求166）。 

00:06:28.860 --> 00:06:32.250
这为您提供了很大的帮助

00:06:32.250 --> 00:06:35.580
新类工具箱

00:06:35.580 --> 00:06:39.069
和API进行了这种协调

00:06:39.069 --> 00:06:43.330
多个线程更简单。我们介绍了

00:06:43.330 --> 00:06:46.960
进行过多线程编程的人所喜欢的那种概念

00:06:46.960 --> 00:06:50.470
已经在其他平台上使用的其他语言。 

00:06:50.470 --> 00:06:54.479
信号量类，新互斥量等

00:06:54.479 --> 00:06:58.039
读/写锁，原子操作；所有的

00:06:58.039 --> 00:07:02.539
人们熟悉并习惯的那些类型的事物

00:07:02.539 --> 00:07:06.139
在多线程方面创建更好的代码。 

00:07:06.139 --> 00:07:09.289
在JDK 6中

00:07:09.289 --> 00:07:14.150
我们有一些更高级的函数，例如相位器

00:07:14.150 --> 00:07:15.289
另一种拥有

00:07:15.289 --> 00:07:18.580
多个线程似乎同时工作

00:07:18.580 --> 00:07:22.479
然后到达特定的时间点，以便他们可以提供一组特定的

00:07:22.479 --> 00:07:23.180
结果。 

00:07:23.180 --> 00:07:26.680
在JDK 7中

00:07:26.680 --> 00:07:30.550
我们还尝试过使写作更轻松的生活

00:07:30.550 --> 00:07:35.280
多线程代码和并行运行的代码。我们介绍了

00:07:35.280 --> 00:07:38.310
 fork-join框架。这给你什么

00:07:38.310 --> 00:07:42.340
是执行一项任务的能力，可以分解为

00:07:42.340 --> 00:07:46.090
多个子任务，并以递归方式进行

00:07:46.090 --> 00:07:50.509
直到您完成可以由单线程处理的足够小的任务。 

00:07:50.509 --> 00:07:55.550
该框架负责所有创建要使用的线程池， 

00:07:55.550 --> 00:07:59.740
照顾所有分配各种任务

00:07:59.740 --> 00:08:02.770
与那些相关的不同队列

00:08:02.770 --> 00:08:07.009
线程，然后将所有结果收集在一起一次

00:08:07.009 --> 00:08:07.569
的

00:08:07.569 --> 00:08:12.139
队列已处理完毕并提供最终结果。这样很好

00:08:12.139 --> 00:08:15.789
但是它仍然有缺点，它需要很多

00:08:15.789 --> 00:08:19.099
样板代码可以有效地使用它。 

00:08:19.099 --> 00:08:22.740
对于JDK 8 

00:08:22.740 --> 00:08:27.940
我们坐下来想，好吧，我们想添加更多函数，但我们想让它更容易

00:08:27.940 --> 00:08:28.590
仍然

00:08:28.590 --> 00:08:32.760
为人们编写并行代码。至此，我们意识到

00:08:32.760 --> 00:08:37.860
我们不能只是在标准的类中添加更多的API 

00:08:37.860 --> 00:08:41.550
类库。为了使开发人员的生活更轻松， 

00:08:41.550 --> 00:08:45.730
我们必须对语言语法进行一些更改

00:08:45.730 --> 00:08:49.350
然后，我们可以与新的API结合使用

00:08:49.350 --> 00:08:52.390
使它更简单。这是什么

00:08:52.390 --> 00:08:56.180
 Lambda表达式语法和项目Lambdas 

00:08:56.180 --> 00:08:59.930
关于一切。这就是为什么我们要添加Lambda。 

00:08:59.930 --> 00:09:03.890
主要是为了使开发人员的生活更轻松

00:09:03.890 --> 00:09:07.019
编写可能有效的并行代码

00:09:07.019 --> 00:09:12.730
以简单的方式。 

00:09:12.730 --> 00:09:16.910
让我们看一下示例代码

00:09:16.910 --> 00:09:20.700
这是我们写的那种代码

00:09:20.700 --> 00:09:24.180
在Java中。我们在这里是

00:09:24.180 --> 00:09:28.210
数据的集合，在这种情况下，它是一个集合

00:09:28.210 --> 00:09:31.240
关于参加考试的学生的记录

00:09:31.240 --> 00:09:36.370
多年。我们要从这些信息中提取什么

00:09:36.370 --> 00:09:39.620
最高分数是多少

00:09:39.620 --> 00:09:42.860
任何毕业的学生

00:09:42.860 --> 00:09:46.900
在2011年。我们可以在这里看到

00:09:46.900 --> 00:09:50.260
我们有一段相当简单的代码吗？我做了什么

00:09:50.260 --> 00:09:53.620
是我收集了学生，然后

00:09:53.620 --> 00:09:59.430
我创建一个变量称为最高分。我已将初始值指定为零， 

00:09:59.430 --> 00:10:02.760
这样我们可以在找到更高分数时进行更新。 

00:10:02.760 --> 00:10:06.590
然后我们使用

00:10:06.590 --> 00:10:11.010
我们在Java中做事的一种非常普遍的方式是迭代。 

00:10:11.010 --> 00:10:14.030
 Java是命令式语言， 

00:10:14.030 --> 00:10:17.280
这意味着我们有一系列命令， 

00:10:17.280 --> 00:10:20.390
可以操纵变量

00:10:20.390 --> 00:10:23.850
更新事物和处理数据， 

00:10:23.850 --> 00:10:27.310
如我们所愿。在这种情况下，我们要迭代

00:10:27.310 --> 00:10:30.870
收集学生的资料，因此我们依次查看每个学生

00:10:30.870 --> 00:10:34.440
看他们的毕业年份，看他们的分数。 

00:10:34.440 --> 00:10:39.390
对于此循环，我们使用更现代的foreach语法。 

00:10:39.390 --> 00:10:42.780
这本身隐藏了一些细节

00:10:42.780 --> 00:10:46.080
因为在这种情况下，我们实际上必须要做的是

00:10:46.080 --> 00:10:49.620
是从集合学生中提取迭代器

00:10:49.620 --> 00:10:52.740
然后我们将不得不反复获得

00:10:52.740 --> 00:10:57.560
该迭代器中的元素，因此我们实际上遍历了集合

00:10:57.560 --> 00:11:00.890
直到没有更多的元素了。 

00:11:00.890 --> 00:11:04.500
 for语句的语法实际上有点复杂

00:11:04.500 --> 00:11:07.730
我们只是使用速记来简化我们的操作

00:11:07.730 --> 00:11:10.019
码。 

00:11:10.019 --> 00:11:13.509
当我们浏览学生的集合时，我们会查看每条记录

00:11:13.509 --> 00:11:16.889
我们可以比较毕业年份

00:11:16.889 --> 00:11:21.809
的学生到2011年的百分比。如果他们当年毕业， 

00:11:21.809 --> 00:11:25.419
我们感兴趣的年份，然后看看他们的得分。 

00:11:25.419 --> 00:11:30.970
我们将该学生的分数与当前的最高分数进行比较。 

00:11:30.970 --> 00:11:33.980
如果学生的分数高于

00:11:33.980 --> 00:11:37.529
该数字，然后我们分配

00:11:37.529 --> 00:11:41.829
我们最高分的价值，我们正在记录的价值

00:11:41.829 --> 00:11:44.899
不管那个学生参加考试。 

00:11:44.899 --> 00:11:48.410
最后，我们将要拥有的

00:11:48.410 --> 00:11:52.879
是所有学生在2011年获得的最高分。 

00:11:52.879 --> 00:11:56.350
我们已经解决了问题。绝对没有错

00:11:56.350 --> 00:11:59.429
在函数上与我们在这段代码中所做的一样。 

00:11:59.429 --> 00:12:04.220
该函数运行完美。问题

00:12:04.220 --> 00:12:07.769
就我们想如何

00:12:07.769 --> 00:12:11.999
如果我们想利用多个核心和多个优势

00:12:11.999 --> 00:12:12.989
处理器。 

00:12:12.989 --> 00:12:17.160
通过循环

00:12:17.160 --> 00:12:20.539
在这里，我们正在控制迭代。 

00:12:20.539 --> 00:12:23.739
我们通过循环定义顺序

00:12:23.739 --> 00:12:27.649
其中将处理该集合的元素。 

00:12:27.649 --> 00:12:31.369
这意味着我们实际上在

00:12:31.369 --> 00:12:35.869
我们的代码，编译器以及说明它们顺序的运行时

00:12:35.869 --> 00:12:36.489
处理。 

00:12:36.489 --> 00:12:40.970
虽然在这种情况下实际上并不重要

00:12:40.970 --> 00:12:44.619
如果我们在做其他需要做的事情

00:12:44.619 --> 00:12:50.109
保持秩序，我们无法将其分解为并行操作

00:12:50.109 --> 00:12:54.619
因为将其分解和并行操作，我们将介绍

00:12:54.619 --> 00:12:57.759
非确定性行为，因为不同的线程可以在不同的位置执行

00:12:57.759 --> 00:13:01.819
有时，他们可能正在查看不同的碎片数据，因此我们可能不会总是得到

00:13:01.819 --> 00:13:02.859
同样的结果。 

00:13:02.859 --> 00:13:07.119
我们可以控制局势

00:13:07.119 --> 00:13:11.829
这意味着输出代码本质上是串行的。我们从

00:13:11.829 --> 00:13:12.480
收集和

00:13:12.480 --> 00:13:15.320
我们移到集合的末尾。 

00:13:15.320 --> 00:13:17.710
我们面临的另一个问题是，即使我们要

00:13:17.710 --> 00:13:21.290
重写我们的循环，并尝试避免显式使用循环

00:13:21.290 --> 00:13:24.680
我们还有一个变量highScore 

00:13:24.680 --> 00:13:28.250
这是可变状态。 

00:13:28.250 --> 00:13:32.470
拥有一个可以更改的变量以及是否有多个线程

00:13:32.470 --> 00:13:36.060
我们仍然会遇到问题，因为它不是线程安全的

00:13:36.060 --> 00:13:39.210
多个线程可能会同时更新该变量

00:13:39.210 --> 00:13:44.310
时间并覆盖其他线程所做的更改。 

00:13:44.310 --> 00:13:48.470
我们将需要引入锁定以防止多个线程访问

00:13:48.470 --> 00:13:48.800
它

00:13:48.800 --> 00:13:52.120
同时，这将为我们增加更多的工作

00:13:52.120 --> 00:13:57.610
应用程序代码。现在我们有很好的作品，但是还没有

00:13:57.610 --> 00:14:01.510
在多线程和并行执行方面表现出色。 

00:14:01.510 --> 00:14:05.110
让我们采用相同的代码

00:14:05.110 --> 00:14:09.240
并使用更实用的方法重写它。 

00:14:09.240 --> 00:14:12.490
现在我们要讨论函数式编程

00:14:12.490 --> 00:14:16.850
在第二课中，在该课的开始，还有很多很多，但是现在您可以考虑

00:14:16.850 --> 00:14:17.290
的

00:14:17.290 --> 00:14:21.740
一种更实用的方法，就是简单地链接在一起的能力

00:14:21.740 --> 00:14:25.020
方法调用使事情一个接一个地执行。 

00:14:25.020 --> 00:14:29.490
现在我们正在做的是招收一批学生

00:14:29.490 --> 00:14:34.750
而不使用显式循环。现在我们传递学生的集合

00:14:34.750 --> 00:14:39.190
记录到过滤方法。过滤方式

00:14:39.190 --> 00:14:42.340
被告知如何进行过滤

00:14:42.340 --> 00:14:46.180
使用 Predicate 接口。 Predicate 接口

00:14:46.180 --> 00:14:49.700
有一个方法，我们使用一个匿名内部类

00:14:49.700 --> 00:14:52.700
定义该方法将要执行的操作。 

00:14:52.700 --> 00:14:57.070
在这种情况下，这是一个称为op的方法，该方法将一个学生作为参数， 

00:14:57.070 --> 00:15:00.380
返回布尔值。我们比较毕业年份

00:15:00.380 --> 00:15:04.730
的学生到2011年。 

00:15:04.730 --> 00:15:08.530
过滤器方法的输出将是

00:15:08.530 --> 00:15:12.550
我们必须开始的所有学生

00:15:12.550 --> 00:15:16.710
仅是2011年毕业的学生。 

00:15:16.710 --> 00:15:21.360
我们采用该数据子集并将其传递给另一种方法， 

00:15:21.360 --> 00:15:24.540
这种情况称为 map ，它使用另一个

00:15:24.540 --> 00:15:26.060
匿名内部类

00:15:26.060 --> 00:15:29.110
叫Mapper确定

00:15:29.110 --> 00:15:32.440
如何实际执行该映射，在这种情况下

00:15:32.440 --> 00:15:35.850
它有一个称为提取的单一方法，需要一个学生s， 

00:15:35.850 --> 00:15:39.490
作为参数并返回一个double。为了这

00:15:39.490 --> 00:15:43.400
我们收集了2011年毕业的学生

00:15:43.400 --> 00:15:46.870
然后将其转换为记录集合

00:15:46.870 --> 00:15:50.960
这些学生的分数。在 map 的尽头

00:15:50.960 --> 00:15:56.040
我们拥有2011年毕业学生的所有分数。 

00:15:56.040 --> 00:15:59.230
我们通过数据收集

00:15:59.230 --> 00:16:03.870
归结为实际上的归约运算，但这是一种特殊形式

00:16:03.870 --> 00:16:07.200
的减少，最大值所有这些

00:16:07.200 --> 00:16:10.490
将 double 值并查看它们并确定

00:16:10.490 --> 00:16:14.200
是最高值，我们将结果返回为

00:16:14.200 --> 00:16:18.510
我们的最终结果。很好

00:16:18.510 --> 00:16:22.490
就我们如何并行执行而言，这要好得多

00:16:22.490 --> 00:16:23.370
处理

00:16:23.370 --> 00:16:26.660
我们如何使用这些多核，多CPU机器。 

00:16:26.660 --> 00:16:29.960
我们没有明确的迭代，也没有

00:16:29.960 --> 00:16:33.670
在那里循环，因此可以处理迭代

00:16:33.670 --> 00:16:37.450
在内部使用max方法在过滤器或 map 中。 

00:16:37.450 --> 00:16:41.820
这意味着如果库代码想要并行执行此操作

00:16:41.820 --> 00:16:46.390
通过定义过滤器和映射方法，我们并没有强迫， 

00:16:46.390 --> 00:16:49.540
我们并没有为此强制执行命令。 

00:16:49.540 --> 00:16:52.800
现在我们不是天生就按顺序进行， 

00:16:52.800 --> 00:16:57.080
如果需要，我们可以并行进行。我们也可以

00:16:57.080 --> 00:17:01.780
应用一些其他优化，以便我们愿意的话

00:17:01.780 --> 00:17:02.990
评估， 

00:17:02.990 --> 00:17:06.600
我们可以将过滤和映射合并在一起， 

00:17:06.600 --> 00:17:10.440
因此，当它们通过

00:17:10.440 --> 00:17:15.130
方法调用集。因为我们没有

00:17:15.130 --> 00:17:18.920
我们将在此处明确更新的变量

00:17:18.920 --> 00:17:23.810
我们也是线程安全的。客户逻辑，我们在这里看

00:17:23.810 --> 00:17:28.140
是无状态的。结果是在内部生成的

00:17:28.140 --> 00:17:31.370
所以我们不必担心状态被修改

00:17:31.370 --> 00:17:31.970
在我们的

00:17:31.970 --> 00:17:35.150
码。那很棒。那是什么

00:17:35.150 --> 00:17:38.220
缺点？不好的是

00:17:38.220 --> 00:17:41.780
很简单它只是丑陋的。 

00:17:41.780 --> 00:17:46.190
为了说明这一点，我将一些代码标记为红色

00:17:46.190 --> 00:17:51.480
和大多数黑色代码。红色代码

00:17:51.480 --> 00:17:56.290
实际上是我们真正感兴趣的。我们有很多学生，我们追求

00:17:56.290 --> 00:17:57.179
最高分

00:17:57.179 --> 00:18:00.980
我们要过滤，我们要针对毕业年份进行测试

00:18:00.980 --> 00:18:04.419
 2011。我们想作图，我们要获得比分，我们要达到最高。 

00:18:04.419 --> 00:18:07.440
所有其他情况，我们使用的是predicate

00:18:07.440 --> 00:18:11.080
类型的学生，有一种称为op的方法， 

00:18:11.080 --> 00:18:15.280
返回布尔值，依此类推，是锅炉代码。我们刚刚

00:18:15.280 --> 00:18:19.059
真的不想拥有那个。那是什么

00:18:19.059 --> 00:18:23.049
 Lambda表达式是关于；我们如何简化

00:18:23.049 --> 00:18:26.549
这种代码以使其成为

00:18:26.549 --> 00:18:31.030
更容易理解。如果我们重写

00:18:31.030 --> 00:18:34.950
使用Lambda表达式的代码

00:18:34.950 --> 00:18:38.120
我们可以看到突然之间

00:18:38.120 --> 00:18:42.640
更简单。现在我们要说的是过滤器

00:18:42.640 --> 00:18:46.320
我们需要定义一个称为op的单一方法

00:18:46.320 --> 00:18:51.080
我们在predicate中。您可以在此考虑Lambda表达式

00:18:51.080 --> 00:18:52.020
时间点

00:18:52.020 --> 00:18:55.790
就像是一种方法，但实际上并不是一种方法。 

00:18:55.790 --> 00:19:00.799
在本课程的其他部分中，我将对此进行解释。现在想想就像

00:19:00.799 --> 00:19:05.280
一个方法。就像我们在匿名内部类中看到的方法

00:19:05.280 --> 00:19:08.730
在上一张幻灯片中。对于过滤器，我们有

00:19:08.730 --> 00:19:12.140
方法，在这种情况下，谁是学生的参数； 

00:19:12.140 --> 00:19:15.940
那是箭头的左侧。方法的主体

00:19:15.940 --> 00:19:18.410
是否返回毕业年份

00:19:18.410 --> 00:19:22.090
是不是2011年。立刻，您可以看到

00:19:22.090 --> 00:19:25.200
这不像我们以前使用的方法

00:19:25.200 --> 00:19:29.930
因为没有明确的return语句。编译器

00:19:29.930 --> 00:19:33.200
将从我们正在比较毕业年份的事实中推断出来

00:19:33.200 --> 00:19:38.310
到2011年，结果将是布尔值。同样， 

00:19:38.310 --> 00:19:42.350
当我们查看map方法时，我们传入的是Lambda表达式。 

00:19:42.350 --> 00:19:45.740
箭头的左侧是参数s， 

00:19:45.740 --> 00:19:49.150
右侧是身体，只是返回

00:19:49.150 --> 00:19:52.900
该学生和编译器的分数将推断出这是一个

00:19:52.900 --> 00:19:56.510
基于getScore签名的事实double

00:19:56.510 --> 00:19:59.840
是要返回double。最高不需要

00:19:59.840 --> 00:20:03.400
 Lambda表达式，因此它只是变成最大值。 

00:20:03.400 --> 00:20:06.540
这给了我们一些东西

00:20:06.540 --> 00:20:11.390
更具可读性，因此我们采用的方法更加抽象， 

00:20:11.390 --> 00:20:14.640
而且因为它在代码方面要简单得多， 

00:20:14.640 --> 00:20:18.720
我们所要查看的代码少得多，错误也少得多。 

00:20:18.720 --> 00:20:22.850
我们不必担心我们将类型正确设置为方法，是否会获得

00:20:22.850 --> 00:20:23.250
类型

00:20:23.250 --> 00:20:26.750
通用参数权限。所有这些东西

00:20:26.750 --> 00:20:31.080
由编译器为我们完成，所以我们有一种更简单的方法

00:20:31.080 --> 00:20:37.140
当我们想做这种事情的时候看一下代码。 

00:20:37.140 --> 00:20:39.930
总结本课的第一节， 

00:20:39.930 --> 00:20:45.300
我们需要对Java语言进行更改，而不仅仅是对API进行更改， 

00:20:45.300 --> 00:20:48.480
这样我们就可以简化交易方式

00:20:48.480 --> 00:20:52.470
与并行编码。什么

00:20:52.470 --> 00:20:55.780
 Lambda表达式真正给我们的是

00:20:55.780 --> 00:20:59.200
现在可以通过的非常简单的方法

00:20:59.200 --> 00:21:02.740
行为作为方法的参数。 

00:21:02.740 --> 00:21:07.260
过去在匿名内部类方面有过

00:21:07.260 --> 00:21:10.560
由于这种相当冗长的语法

00:21:10.560 --> 00:21:14.080
一直很难有效地使用它。现在我们有了一个的简单方法

00:21:15.010 --> 00:21:18.950
将过去的行为作为参数和值， 

00:21:18.950 --> 00:21:22.420
因为大多数时候我们将值作为参数传递。 

00:21:22.420 --> 00:21:26.940
现在我们也可以传递行为，也可以对行为进行签名

00:21:26.940 --> 00:21:31.180
如果需要的话，将其设置为变量。那

00:21:31.180 --> 00:21:34.300
是第1部分的结尾

00:21:34.300 --> 00:21:34.800
课。 

