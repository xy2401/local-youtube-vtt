WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.790 --> 00:00:02.810
 [音乐] 

00:00:12.730 --> 00:00:14.420
您好，欢迎来到第二部分

00:00:14.420 --> 00:00:19.550
第一课在本节中，我们将研究使用的语法

00:00:19.550 --> 00:00:19.980
对于

00:00:19.980 --> 00:00:24.810
 Java中的Lambda表达式。我提到

00:00:24.810 --> 00:00:28.070
在本课程的第一部分中，Lambda表达式是

00:00:28.070 --> 00:00:32.060
就像方法，但它们并不是真正的方法，所以让我们

00:00:32.060 --> 00:00:35.910
详细介绍为什么会这样。重要的事情

00:00:35.910 --> 00:00:36.450
这里

00:00:36.450 --> 00:00:40.210
是Lambda表达式，尽管它表示

00:00:40.210 --> 00:00:43.760
关于我们将如何使用的方法

00:00:43.760 --> 00:00:47.449
特定的接口，它没有关联

00:00:47.449 --> 00:00:51.789
与一堂课。这是非常重要的事情，我们将回到为什么

00:00:51.789 --> 00:00:55.670
与本课程的其余部分非常相关。 

00:00:55.670 --> 00:00:59.399
但是最重​​要的是Lambda表达式

00:00:59.399 --> 00:01:02.980
表示方法，但不与类相关联， 

00:01:02.980 --> 00:01:06.540
因此我们不称其为方法。我们称之为

00:01:06.540 --> 00:01:10.890
是匿名函数。我们可以在这里看到

00:01:10.890 --> 00:01:14.650
 Lambda表达式的语法

00:01:14.650 --> 00:01:19.110
是使用Lambda运算符。 Lambda运算符就像一个小箭头

00:01:19.110 --> 00:01:24.020
由负号“大于”和“大于”组成。在左手侧

00:01:24.020 --> 00:01:28.290
 Lambda运算符的参数是

00:01:28.290 --> 00:01:32.730
在匿名函数中， 

00:01:32.730 --> 00:01:36.280
 Lambda表达式，如果

00:01:36.280 --> 00:01:39.380
你只有一个参数

00:01:39.380 --> 00:01:42.910
您不需要括号。如果没有参数

00:01:42.910 --> 00:01:46.370
那么您必须有一组空括号。如果您有多个

00:01:46.370 --> 00:01:50.440
参数，则必须用逗号分隔参数

00:01:50.440 --> 00:01:53.740
周围的括号与您的括号完全相同

00:01:53.740 --> 00:01:58.710
用您正在调用的方法。但是在一个参数的情况下， 

00:01:58.710 --> 00:02:02.360
括号是可选的；您可以放他们，但不必放。 

00:02:02.360 --> 00:02:05.440
右手边

00:02:05.440 --> 00:02:09.399
所有Lambda运算符都是Lambda表达式的主体

00:02:09.399 --> 00:02:12.610
这本质上就是该方法的主体， 

00:02:12.610 --> 00:02:15.920
匿名函数的主体。 

00:02:15.920 --> 00:02:18.940
同样，如果您只有一行

00:02:18.940 --> 00:02:23.320
 Lambda表达式则不需要包含花括号。 

00:02:23.320 --> 00:02:26.390
 Uou可以做到（它们是可选的），但您不必这样做。 

00:02:26.390 --> 00:02:30.060
如果您有多行Lambda表达式

00:02:30.060 --> 00:02:34.300
那么您将需要大括号，并且每行都需要用分号分隔

00:02:34.300 --> 00:02:39.520
与我们使用Java的方式完全相同。对于

00:02:39.520 --> 00:02:42.910
单行方法

00:02:42.910 --> 00:02:46.390
您已经看到的一些示例不需要显式

00:02:46.390 --> 00:02:49.900
返回声明。同样，如果您愿意，可以放

00:02:49.900 --> 00:02:53.840
返回语句，但是

00:02:53.840 --> 00:02:57.390
非常简单的Lambda表达式，其中只有一个语句

00:02:57.390 --> 00:03:01.030
您不需要明确的return语句。 

00:03:01.030 --> 00:03:05.380
稍后我们将看到一些示例。那就是

00:03:05.380 --> 00:03:08.390
本质上是Lambda表达。另一件事

00:03:08.390 --> 00:03:11.980
就像方法一样，Lambda表达式可以抛出

00:03:11.980 --> 00:03:16.030
例外情况。所以Lambda表达式的主体

00:03:16.030 --> 00:03:19.150
可以有会抛出异常的语句， 

00:03:19.150 --> 00:03:22.700
那么这些必须在

00:03:22.700 --> 00:03:25.910
 Lambda表达式，必须按原样捕获和处理它们

00:03:25.910 --> 00:03:29.909
与任何其他代码。 

00:03:29.909 --> 00:03:32.540
这里我们有一些例子

00:03:32.540 --> 00:03:35.730
 Lambda表达式。第一个使用

00:03:35.730 --> 00:03:39.140
没有参数的Lambda表达式

00:03:39.140 --> 00:03:43.269
所以我们有空括号。在右侧，我们有一段非常简单的代码。 

00:03:43.840 --> 00:03:47.379
一行，所以我们不需要大括号， 

00:03:47.379 --> 00:03:51.920
我们只打印“ hello Lambda”。第二个是更多的数学

00:03:51.920 --> 00:03:55.590
功能。我们有一个

00:03:55.590 --> 00:03:59.040
参数x，因此我们不需要在该参数之间加上方括号

00:03:59.040 --> 00:04:02.049
然后我们只是返回值x加

00:04:02.049 --> 00:04:06.950
 10.第三个例子有点复杂， 

00:04:06.950 --> 00:04:10.269
我这里有两个参数， 

00:04:10.269 --> 00:04:14.170
 int x和int y，因此我们必须再次将其括在方括号中

00:04:14.170 --> 00:04:18.329
在这种情况下，我选择使用花括号， 

00:04:18.329 --> 00:04:21.560
即使我只有一条语句。 

00:04:21.560 --> 00:04:25.660
有趣或与此相关的另一件事是， 

00:04:25.660 --> 00:04:29.229
如果我确实有一条单行语句，并且将大括号括起来

00:04:29.229 --> 00:04:32.860
我必须用分号终止单行。 

00:04:32.860 --> 00:04:35.860
如果没有牙套，则不需要分号。 

00:04:35.860 --> 00:04:40.840
如果我确实把牙套放在那里，我确实需要用分号。 

00:04:40.840 --> 00:04:44.599
下一个示例将两个字符串作为参数， 

00:04:44.599 --> 00:04:48.690
字符串x和y并返回长度的差， 

00:04:48.690 --> 00:04:52.260
所以编译器会从我们正在做的事情中找出来

00:04:52.260 --> 00:04:55.400
显然，我们传入了两个字符串， 

00:04:55.400 --> 00:04:57.060
长度差将返回一个int或long。 

00:04:57.060 --> 00:05:02.550
然后我们可以稍微复杂一点

00:05:02.550 --> 00:05:06.470
 Lambda表达式的主体，我们在其中传递单个变量， 

00:05:06.470 --> 00:05:10.520
字符串x，同样，我选择将括号放在不必要的位置

00:05:10.520 --> 00:05:14.550
我们确实需要大括号，并且我们有三个陈述， 

00:05:14.550 --> 00:05:19.170
 listA点添加，listB点删除，然后返回大小

00:05:19.170 --> 00:05:22.600
处理完listB之后，我们有一个明确的return语句。 

00:05:22.600 --> 00:05:25.750
因为这是多行

00:05:25.750 --> 00:05:29.560
在这种情况下，Lambda主体必须具有明确的return语句。 

00:05:29.560 --> 00:05:33.040
因此，这些都是不同Lambda表达式的良好示例。 

00:05:33.040 --> 00:05:37.000
在本课程的其余部分中，我们将看到更多这些内容。 

00:05:37.000 --> 00:05:40.810
现在来讲

00:05:40.810 --> 00:05:44.230
编译器可以执行的操作，现在实际上可以执行

00:05:44.230 --> 00:05:47.940
更好的类型推断。我们在JDK 8中所做的一件事

00:05:47.940 --> 00:05:51.300
是我们重写了编译器的很大一部分

00:05:51.300 --> 00:05:57.610
以更好的方式处理类型推断。我们这里遇到的情况是

00:05:57.610 --> 00:06:01.750
我已经定义了特定的方法，因此在这种情况下称为过程

00:06:01.750 --> 00:06:05.190
具有通用类型参数T和

00:06:05.190 --> 00:06:09.370
我要做的是将两个参数传递给它，一个将是一个列表

00:06:09.370 --> 00:06:13.210
类型T的比较器，另一个是类型T的比较器。 

00:06:13.210 --> 00:06:18.040
如果我想使用该方法 ，则可以执行以下操作：我可以创建

00:06:21.190 --> 00:06:24.880
字符串类型列表，并从中获取

00:06:24.880 --> 00:06:28.390
某处。当我想要调用 process

00:06:28.390 --> 00:06:32.080
我可以调用 process，通过清单

00:06:32.080 --> 00:06:36.210
我从getList检索到的第一个参数

00:06:36.210 --> 00:06:39.660
然后我可以使用Lambda表达式

00:06:39.660 --> 00:06:44.590
代表比较器，我们将使用与在上面看到的示例相同的比较器

00:06:44.590 --> 00:06:47.990
上一张幻灯片，我们传入两个字符串x和y 

00:06:47.990 --> 00:06:51.460
然后我们返回这些字符串的长度差。 

00:06:51.460 --> 00:06:55.490
要做的是处理一些东西

00:06:55.490 --> 00:07:00.520
基于字符串长度的差异。 

00:07:00.520 --> 00:07:03.229
编译器现在更智能

00:07:03.229 --> 00:07:07.720
这样我们就可以省去一些通常需要做的工作

00:07:08.069 --> 00:07:11.770
这样做是因为在这种情况下，编译器知道

00:07:11.770 --> 00:07:15.090
我们正在处理的那个清单

00:07:15.090 --> 00:07:19.139
是字符串类型，来自流程定义

00:07:19.139 --> 00:07:22.940
我们知道比较器必须是同一类型

00:07:22.940 --> 00:07:26.110
作为列表，因为它使用相同的type参数。 

00:07:26.110 --> 00:07:30.560
现在我们可以做的是，我们可以简单地说

00:07:30.560 --> 00:07:34.139
处理呼叫传递列表和

00:07:34.139 --> 00:07:39.449
当我们定义Lambda表达式时，我们不再需要明确声明

00:07:39.449 --> 00:07:40.250
类型

00:07:40.250 --> 00:07:44.810
 x和y的值，因为编译器知道它们必须是字符串

00:07:44.810 --> 00:07:48.490
因为比较器必须是字符串类型。 

00:07:48.490 --> 00:07:53.360
在这种情况下，我们不必显式地输入类型。 

00:07:53.360 --> 00:07:56.870
因此，如果您愿意的话，我们可以完全自由地输入它， 

00:07:56.870 --> 00:08:01.009
但是如果编译器能够为我们推断出类型，在这种情况下， 

00:08:01.009 --> 00:08:05.250
那么我们实际上不必这样做。 

00:08:05.250 --> 00:08:08.250
这很好，因为它使我们编写的代码更少， 

00:08:08.250 --> 00:08:11.680
它为我们提供了更清晰的语法，并且更容易理解正在发生的事情。 

00:08:11.680 --> 00:08:15.930
不要为此感到震惊，我们绝不会引入任何形式的

00:08:15.930 --> 00:08:19.789
动态类型到 Java。 

00:08:19.789 --> 00:08:23.210
 X和Y仍然非常静态地类型为类型字符串。 

00:08:23.210 --> 00:08:26.430
我们给您的是更多类型(typing)

00:08:26.430 --> 00:08:29.740
更少的打字(typing)，恐怕这是一个可怕的双关语。 

00:08:29.740 --> 00:08:34.010
总结第二部分， 

00:08:34.010 --> 00:08:37.610
我们用于Lambda表达式的语法

00:08:37.610 --> 00:08:40.719
非常简单，非常简单。所有你要记住的

00:08:40.719 --> 00:08:44.149
就像是一种方法，而您拥有Lambda 

00:08:44.149 --> 00:08:47.839
运算符是箭头。左手边

00:08:47.839 --> 00:08:52.190
 Lambda运算符的代表正在传递给

00:08:52.190 --> 00:08:52.720
方法

00:08:52.720 --> 00:08:57.660
右手边代表身体。如果你有一个

00:08:57.660 --> 00:09:01.459
参数参数周围的括号是可选的。 

00:09:01.459 --> 00:09:04.430
如果您对Lambda的正文只有一个陈述

00:09:04.430 --> 00:09:08.680
大括号是可选的，如果您确实将大括号放在单个

00:09:08.680 --> 00:09:09.279
声明

00:09:09.279 --> 00:09:12.300
您必须在代码行的末尾加上分号。 

00:09:12.300 --> 00:09:15.760
类型推断

00:09:15.760 --> 00:09:19.360
意味着我们不必总是明确声明

00:09:19.360 --> 00:09:23.380
 Lambda表达式中使用的参数类型。 

00:09:23.380 --> 00:09:27.070
通常，编译器能够为我们推断

00:09:27.070 --> 00:09:31.690
基于Lambda表达式的类型以及使用位置。 

00:09:31.690 --> 00:09:35.050
 Java仍然很强大， 

00:09:35.050 --> 00:09:39.060
静态类型语言，因此无需担心动态类型。 

00:09:39.060 --> 00:09:42.480
到此为止

00:09:42.480 --> 00:09:44.120
本课的第二部分。 

