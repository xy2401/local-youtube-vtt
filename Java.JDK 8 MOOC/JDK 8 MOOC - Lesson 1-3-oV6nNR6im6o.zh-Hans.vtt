WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.790 --> 00:00:12.390
 [音乐] 

00:00:12.390 --> 00:00:14.790
您好，欢迎来到第3节

00:00:14.790 --> 00:00:16.770
第一课

00:00:16.770 --> 00:00:20.080
在本课的这一部分中，我们将讨论函数式接口和

00:00:20.080 --> 00:00:20.860
他们的定义。 

00:00:20.860 --> 00:00:23.990
这些是您可以使用Lambda表达式的地方

00:00:23.990 --> 00:00:29.689
在您的代码中。在本课程的前一部分

00:00:29.689 --> 00:00:33.680
我描述了Lambda表达式如何是匿名函数

00:00:33.680 --> 00:00:36.699
我的意思是，这就像一种方法， 

00:00:36.699 --> 00:00:40.260
但与类无关的人。 

00:00:40.260 --> 00:00:43.550
没关系;我们有一种方法

00:00:43.550 --> 00:00:48.210
匿名函数，但不与类关联。这里的问题是

00:00:48.210 --> 00:00:53.750
 Java是一种强类型语言，因此我们必须确保无论使用什么

00:00:53.750 --> 00:00:58.150
具有与之关联的类型。对于Lambda表达式， 

00:00:58.150 --> 00:01:01.720
虽然它代表一个方法，并且是一个匿名函数

00:01:01.720 --> 00:01:04.970
 Lambda表达式必须有一个类型， 

00:01:04.970 --> 00:01:08.010
并简化这个

00:01:08.010 --> 00:01:11.350
我们在JDK 8中所说的是

00:01:11.350 --> 00:01:14.380
您可以在任何地方使用Lambda表达式

00:01:14.380 --> 00:01:17.770
使用的类型是

00:01:17.770 --> 00:01:20.789
函数式接口。 

00:01:20.789 --> 00:01:24.210
一个函数式接口就是一个有一个

00:01:24.210 --> 00:01:28.799
抽象方法。因为它有一个

00:01:28.799 --> 00:01:32.299
我们可以轻松映射的抽象方法

00:01:32.299 --> 00:01:36.179
 Lambda表达式作为实现

00:01:36.179 --> 00:01:39.390
这种抽象方法， 

00:01:39.390 --> 00:01:42.609
实际上，编译器

00:01:42.609 --> 00:01:45.740
并且运行时正在生成一个对象

00:01:45.740 --> 00:01:50.140
使用Lambda表达式表示该方法的类型。 

00:01:50.140 --> 00:01:53.179
但是，这非常重要，即使

00:01:53.179 --> 00:01:56.289
有这种类型的想法

00:01:56.289 --> 00:02:00.359
没有类，所以没有对象

00:02:00.359 --> 00:02:04.679
直接使用Lambda表达式。这是一种奇怪的情况

00:02:04.679 --> 00:02:08.990
它有一个类型但没有对象，我们将进一步讨论

00:02:08.990 --> 00:02:14.450
当我们完成本节课的其余部分时。 

00:02:14.450 --> 00:02:16.500
让我们来看看真实的

00:02:16.500 --> 00:02:19.640
函数式接口的定义，并确保我们

00:02:19.640 --> 00:02:24.430
确切了解这意味着什么。第一件事是必须

00:02:24.430 --> 00:02:27.770
接口。这似乎有点

00:02:27.770 --> 00:02:31.080
当我说它是函数式接口时，这是显而易见的事情

00:02:31.080 --> 00:02:35.300
但我也说过，它只有一个抽象方法。 

00:02:35.300 --> 00:02:39.350
有人建议，如果只需要一个

00:02:39.350 --> 00:02:42.890
抽象方法，我不能创建一个抽象

00:02:42.890 --> 00:02:46.630
类，其中仅定义了一个抽象方法。 

00:02:46.630 --> 00:02:49.770
从理论上讲，您可以选择JDK 8 

00:02:49.770 --> 00:02:54.320
我们不支持。所以函数式接口，您可以在其中使用Lambda 

00:02:54.320 --> 00:02:54.980
表达， 

00:02:54.980 --> 00:02:59.530
必须是一个接口。它也必须有

00:02:59.530 --> 00:03:03.480
一种也是唯一的一种抽象方法，因为请记住

00:03:03.480 --> 00:03:07.570
 Lambda表达式提供了该抽象方法的实现。 

00:03:07.570 --> 00:03:10.580
如果我们有多个抽象方法，我们将不知道

00:03:10.580 --> 00:03:14.160
 Lambda表达式与哪种特定方法有关

00:03:14.160 --> 00:03:18.980
我们将剩下一个或多个没有实现的方法。 

00:03:18.980 --> 00:03:22.160
因此，一种抽象方法Lambda表达式

00:03:22.160 --> 00:03:26.340
映射到该方法的实现。现在

00:03:26.340 --> 00:03:30.030
在JDK 8之前，如果您看过一种方法

00:03:30.030 --> 00:03:34.280
接口定义，很容易看出它是否将成为

00:03:34.280 --> 00:03:35.370
函数式接口。 

00:03:35.370 --> 00:03:38.410
那是只有一种方法的方法。 

00:03:38.410 --> 00:03:41.510
在JDK 8中

00:03:41.510 --> 00:03:46.090
我们还引入了其他一些新功能，并对

00:03:46.090 --> 00:03:46.870
句法

00:03:46.870 --> 00:03:52.090
语言。其中之一是为了使我们能够

00:03:52.090 --> 00:03:56.570
使扩展现有Collections API更加容易

00:03:56.570 --> 00:04:01.530
它在很大程度上依赖于接口而不会破坏向后兼容性。 

00:04:01.530 --> 00:04:05.890
为此，我们引入了默认方法的思想， 

00:04:05.890 --> 00:04:09.090
默认方法只是可以放置的方法

00:04:09.090 --> 00:04:12.370
在一个抽象的界面中

00:04:12.370 --> 00:04:16.380
因为它具有与之关联的实现。 

00:04:16.380 --> 00:04:20.220
这个想法是，如果您使用的是旧版本

00:04:20.220 --> 00:04:23.440
在实现这些方法之前实现接口的类

00:04:23.440 --> 00:04:28.590
添加了，当编译器尝试解析这些方法之一时， 

00:04:28.590 --> 00:04:32.350
而不是去上课的旧版本然后说，哦

00:04:32.350 --> 00:04:35.830
该方法不存在，我无法编译，它转到

00:04:35.830 --> 00:04:40.000
类并说，哦，该方法不存在，请返回接口

00:04:40.000 --> 00:04:43.130
并找到用于此目的的默认实现。 

00:04:43.130 --> 00:04:47.920
这样，我们就将行为的多重继承添加到了

00:04:47.920 --> 00:04:48.630
爪哇

00:04:48.630 --> 00:04:51.990
以同样的方式，我们将拥有多个类型的继承。 

00:04:51.990 --> 00:04:55.060
现在，因为我们现在可以拥有

00:04:55.060 --> 00:04:59.190
界面中的行为，这也很有意义

00:04:59.190 --> 00:05:02.520
也允许将静态方法添加到接口。 

00:05:02.520 --> 00:05:05.640
这些是我们需要了解的两个变化。 

00:05:05.640 --> 00:05:08.640
并且，为了

00:05:08.640 --> 00:05:12.970
让编译器检查我们认为是否功能正常

00:05:12.970 --> 00:05:13.510
接口

00:05:13.510 --> 00:05:17.430
确实是，可以添加一个注释， 

00:05:17.430 --> 00:05:20.900
 @FunctionalInterface，然后编译器将检查是否只有

00:05:20.900 --> 00:05:24.130
该特定接口中的一种抽象方法。 

00:05:24.130 --> 00:05:28.740
让我们看一些例子

00:05:28.740 --> 00:05:31.960
 JDK 8之前我们在Java中已经拥有的接口

00:05:31.960 --> 00:05:35.330
可以使用Lambda表达式

00:05:35.330 --> 00:05:40.200
代表他们。 FileFilter是一个很好的例子，因为它只有一个方法， 

00:05:40.200 --> 00:05:43.490
 accept，它返回一个布尔值，并接收一个文件。 

00:05:43.490 --> 00:05:46.700
同样，ActionListener具有单个方法

00:05:46.700 --> 00:05:50.610
可执行且可调用的动作只有一个

00:05:50.610 --> 00:05:54.130
呼叫。所有这些都在JDK 8之前存在于Java中

00:05:54.130 --> 00:05:57.860
如果需要，我们可以对这些使用Lambda表达式

00:05:57.860 --> 00:06:02.110
因为它们是函数式接口。 

00:06:02.110 --> 00:06:06.200
让我们看看其他一些接口，并确定是否

00:06:06.200 --> 00:06:07.690
它们实际上是否起作用。 

00:06:07.690 --> 00:06:11.760
这里我们有可运行的接口，并且有一个方法： 

00:06:11.760 --> 00:06:16.340
公共抽象无效运行。问题是， 

00:06:16.340 --> 00:06:20.220
这实际上是函数式接口吗？答案是

00:06:20.220 --> 00:06:23.970
非常简单，因为是的，我们只有一个

00:06:23.970 --> 00:06:28.110
抽象方法。我试图使它在这里尽可能明显，实际上定义为

00:06:28.110 --> 00:06:28.830
抽象。 

00:06:28.830 --> 00:06:32.730
这个介面中只有一种抽象方法，因此

00:06:32.730 --> 00:06:37.910
它是一个函数式接口。让我们来看看

00:06:37.910 --> 00:06:41.960
稍微复杂一点。这是 Predicate 接口， 

00:06:41.960 --> 00:06:45.210
这是新的java.util.function之一

00:06:45.210 --> 00:06:49.900
介面，我们稍后会详细讨论。这有

00:06:49.900 --> 00:06:53.790
五种方法。其中三种方法

00:06:53.790 --> 00:06:57.540
是默认方法，然后有一个静态方法

00:06:57.540 --> 00:07:00.630
然后我们还有一种叫做test的方法

00:07:00.630 --> 00:07:05.610
返回一个布尔值。如果我们要确定这是否是功能

00:07:05.610 --> 00:07:06.870
是否界面

00:07:06.870 --> 00:07:10.690
显然，我们需要决定所有这些方法是否有价值

00:07:10.690 --> 00:07:14.980
就抽象方法而言不是。我说了， 

00:07:14.980 --> 00:07:18.270
就默认方法而言，这些不算在内。 

00:07:18.270 --> 00:07:21.780
由于这些具有与之相关的实现， 

00:07:21.780 --> 00:07:26.450
根据定义，它们不是抽象的。同样， 

00:07:26.450 --> 00:07:29.730
静态方法isEquals具有

00:07:29.730 --> 00:07:32.920
与之相关的实现；因此默认

00:07:32.920 --> 00:07:37.470
它不是抽象方法。剩下的只是

00:07:37.470 --> 00:07:40.770
一种方法，布尔测试， 

00:07:40.770 --> 00:07:44.820
是抽象的，因此我们有一种抽象方法

00:07:44.820 --> 00:07:48.300
在我们的界面中，因此它是一个功能

00:07:48.300 --> 00:07:53.360
接口。我们要看的最后一种方法，因为

00:07:53.360 --> 00:07:56.410
这个比较棘手。比较器。 

00:07:56.410 --> 00:08:01.000
比较器有一些静态方法。有一些默认方法

00:08:01.000 --> 00:08:04.650
我之所以忽略了这一点，是因为我们同意这些都不算在内。 

00:08:04.650 --> 00:08:08.460
此界面中仍然有两种方法： 

00:08:08.460 --> 00:08:10.629
有一个比较方法， 

00:08:10.629 --> 00:08:14.259
有一个平等的方法。你会想， 

00:08:14.259 --> 00:08:18.250
基于此，这不是函数式接口。 

00:08:18.250 --> 00:08:21.270
但是有一条我没有告诉过你的规则

00:08:21.270 --> 00:08:24.430
在条款上仍然适用

00:08:24.430 --> 00:08:28.270
确定这是否是一个函数式接口。在这种情况下

00:08:28.270 --> 00:08:28.870
一

00:08:28.870 --> 00:08:31.979
 equals方法实际上是

00:08:31.979 --> 00:08:35.610
从对象类隐式继承。 

00:08:35.610 --> 00:08:40.060
记住对象是所有类的超类，我们实际上是

00:08:40.060 --> 00:08:43.610
从对象类继承equals类。 

00:08:43.610 --> 00:08:46.910
因此，它不计入

00:08:46.910 --> 00:08:50.130
此特定接口的抽象方法

00:08:50.130 --> 00:08:55.130
因此，我们仍然只有一种抽象方法，即比较方法

00:08:55.130 --> 00:09:00.430
因此这实际上是一个函数式接口。顺便说一句， 

00:09:00.430 --> 00:09:04.040
我确实看过为什么equals方法是

00:09:04.040 --> 00:09:07.370
包含在此特定界面中，因为

00:09:07.370 --> 00:09:11.640
其他接口不包括此接口，我需要了解为什么这是

00:09:11.640 --> 00:09:12.100
案件。 

00:09:12.100 --> 00:09:16.209
事实证明，定义了equals方法的唯一原因

00:09:16.209 --> 00:09:19.420
在这个界面中是因为它是从

00:09:19.420 --> 00:09:23.230
对象类是一些不同的文档

00:09:23.230 --> 00:09:26.519
可以包含在该特定方法上方的javadoc中

00:09:26.519 --> 00:09:30.140
用于比较时。那只是

00:09:30.140 --> 00:09:35.540
有趣的一面。当我们想使用Lambda表达式时

00:09:35.540 --> 00:09:38.820
我们可以使用它将其分配给

00:09:38.820 --> 00:09:41.990
变量，或者我们可以将其用作方法的参数。 

00:09:41.990 --> 00:09:45.860
在这里的第一个示例中，我有一个可调用的c 

00:09:45.860 --> 00:09:49.459
 （记住callable有一个抽象方法，因此

00:09:49.459 --> 00:09:52.800
我们可以用Lambda表达式表示它） 

00:09:52.800 --> 00:09:56.540
 Lambda表达式只是调用过程。的

00:09:56.540 --> 00:10:00.149
可调用对象的调用方法没有任何参数

00:10:00.149 --> 00:10:02.570
因此我们使用空括号。 

00:10:02.570 --> 00:10:05.450
方法参数同样适用

00:10:05.450 --> 00:10:09.270
所以在这个例子中，我创建了一个新的线程对象， 

00:10:09.270 --> 00:10:13.600
我将Lambda表达式作为参数传递给构造函数。 

00:10:13.600 --> 00:10:17.080
同样，我们希望使用相同的方法，因此我们有一个

00:10:17.080 --> 00:10:20.430
代表run方法的Lambda表达式

00:10:20.430 --> 00:10:23.900
将是过程，它不需要任何参数

00:10:23.900 --> 00:10:27.680
作为参数，因此我们使用空括号。那只是

00:10:27.680 --> 00:10:31.050
一种如何将它们都用作变量分配的方式

00:10:31.050 --> 00:10:37.460
以及当我们将参数传递给方法时。总结第3节， 

00:10:37.460 --> 00:10:41.580
我们可以在任何类型的地方使用Lambda表达式

00:10:41.580 --> 00:10:44.880
我们要使用它的地方是

00:10:44.880 --> 00:10:48.500
函数式接口。记住函数式接口

00:10:48.500 --> 00:10:52.740
是只有一种抽象方法的一种。对于JDK 8 

00:10:52.740 --> 00:10:57.020
并不意味着它只有一种方法。如果具有默认方法， 

00:10:57.020 --> 00:11:00.770
如果具有静态方法，如果具有从其继承的方法

00:11:00.770 --> 00:11:06.350
对象类，则它们不计算在内。关于Lambda的表达方式

00:11:06.350 --> 00:11:07.500
代表， 

00:11:07.500 --> 00:11:11.070
是那单的实现吗

00:11:11.070 --> 00:11:14.130
该函数式接口的抽象方法，因此

00:11:14.130 --> 00:11:17.280
我们将使用抽象方法

00:11:17.280 --> 00:11:20.380
 Lambda表达式表示该实现。 

00:11:20.380 --> 00:11:23.590
到此为止

00:11:23.590 --> 00:11:25.870
本课程第3部分

