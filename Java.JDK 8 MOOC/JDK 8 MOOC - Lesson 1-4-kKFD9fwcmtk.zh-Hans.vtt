WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.790 --> 00:00:12.280
 [音乐] 

00:00:12.280 --> 00:00:14.840
您好，欢迎阅读第4节

00:00:14.840 --> 00:00:18.000
第一课。在这一部分中，我们将研究一些

00:00:18.000 --> 00:00:21.150
已添加的新接口

00:00:21.150 --> 00:00:25.540
在JDK 8中，特别是在java.util.function包中

00:00:25.540 --> 00:00:30.119
这非常有用，尤其是当我们要执行流API之类的事情时。 

00:00:30.119 --> 00:00:33.440
的

00:00:33.440 --> 00:00:37.040
 java.util.function包为我们提供了

00:00:37.040 --> 00:00:40.460
一组定义明确的通用

00:00:40.460 --> 00:00:44.879
函数式接口。这些是我们可以使用Lambda表达式的地方， 

00:00:44.879 --> 00:00:48.840
因为它们只有一种抽象方法。我们在上一节中介绍了这一点

00:00:48.840 --> 00:00:52.250
关于我们只需要一种抽象方法的想法。 

00:00:52.250 --> 00:00:56.399
所有这些接口都是函数式接口，它们具有

00:00:56.399 --> 00:01:00.300
一种抽象方法。我们发现的是

00:01:00.300 --> 00:01:03.429
它们在许多Java类库中得到了广泛使用， 

00:01:03.429 --> 00:01:07.890
因此您会发现它们在我们将在其中讨论的流API中使用了很多

00:01:07.890 --> 00:01:10.990
第二课，但在其他许多地方

00:01:10.990 --> 00:01:14.150
作为参数添加到不同的方法

00:01:14.150 --> 00:01:17.780
我们在JDK 8中包含了新内容

00:01:17.780 --> 00:01:21.420
类库。我们将在此谈论什么

00:01:21.420 --> 00:01:25.380
部分是这些接口的通用形式。 

00:01:25.380 --> 00:01:29.600
如果您看一下包装本身，就会发现有

00:01:29.600 --> 00:01:33.250
我要谈论的众多版本

00:01:33.250 --> 00:01:37.970
是特定于类型的。它们将是双重版本，整数版本，长版本和

00:01:37.970 --> 00:01:41.460
对象版本。一旦你

00:01:41.460 --> 00:01:45.829
回顾了本节的这一节，然后去看看实际的

00:01:45.829 --> 00:01:49.159
打包信息，看看所有不同的类型，您会看到我

00:01:49.159 --> 00:01:50.229
意思是

00:01:50.229 --> 00:01:55.600
各种类型的特定版本。我们第一个

00:01:55.600 --> 00:02:00.740
要看的叫做消费者，这本质上是一个操作， 

00:02:00.740 --> 00:02:04.539
取一个值，就像名字一样

00:02:04.539 --> 00:02:08.220
暗示，消耗它。它不回来

00:02:08.220 --> 00:02:13.230
结果。我们采用传递给它的价值，我们用它做一些事情，但是我们不这样做

00:02:13.230 --> 00:02:14.480
产生结果。 

00:02:14.480 --> 00:02:17.500
这里的例子很简单；的

00:02:17.500 --> 00:02:21.720
传递的参数是字符串s，我们正在使用

00:02:21.720 --> 00:02:25.320
通过使用system.out.println将其打印出来

00:02:25.320 --> 00:02:28.540
我们没有使用任何返回值， 

00:02:28.540 --> 00:02:32.780
我们什么也不退货，这将是一个空白。有

00:02:32.780 --> 00:02:36.770
也称为BiConsumer的第二种形式

00:02:36.770 --> 00:02:40.280
要做的是将两个值作为参数

00:02:40.280 --> 00:02:47.100
再次，没有结果。就界面本身而言，还有一些

00:02:47.100 --> 00:02:51.180
默认方法，使您可以撰写

00:02:51.180 --> 00:02:54.540
消费者。这意味着您可以将它们放在一起

00:02:54.540 --> 00:02:57.860
建立更复杂的消费者版本

00:02:57.860 --> 00:03:01.470
所以你可以做一些像消耗一些东西然后

00:03:01.470 --> 00:03:05.320
让另一个消费者去消费相同的变量

00:03:05.320 --> 00:03:06.360
过去了

00:03:06.360 --> 00:03:09.400
以不同的方式。如果我们看

00:03:09.400 --> 00:03:13.770
 BiConsumer的一个例子我们在这里做的是传递

00:03:13.770 --> 00:03:17.910
两个值，一个键和某个映射中的值， 

00:03:17.910 --> 00:03:21.650
然后我们再次通过打印出

00:03:21.650 --> 00:03:25.500
键的值作为键，然后是值

00:03:25.500 --> 00:03:29.769
作为价值。的

00:03:29.769 --> 00:03:33.630
我们要看的下一个是供应商。这是做什么的

00:03:33.630 --> 00:03:37.160
顾名思义，这再次是供应结果。 

00:03:37.160 --> 00:03:41.200
确实与消费者相反。消费者

00:03:41.200 --> 00:03:45.360
接受传递给它的值，并且不生成结果； 

00:03:45.360 --> 00:03:48.950
供应商不带参数

00:03:48.950 --> 00:03:52.090
传递给它，没有参数，它返回

00:03:52.090 --> 00:03:55.260
某种价值。在这种情况下，我们有

00:03:55.260 --> 00:03:58.769
一个非常简单的示例，其中我们没有传递任何值

00:03:58.769 --> 00:04:02.880
因为我们不需要任何值，它将返回

00:04:02.880 --> 00:04:06.350
任何createLogMessage：都会为我们生成。 

00:04:06.350 --> 00:04:10.090
继续， 

00:04:10.090 --> 00:04:13.290
然后我们有了一个功能的想法， 

00:04:13.290 --> 00:04:17.239
您可以像数学函数一样来思考这个问题。 

00:04:17.239 --> 00:04:20.930
函数是需要一个参数的事物， 

00:04:20.930 --> 00:04:23.940
做某事，并返回结果。 

00:04:23.940 --> 00:04:26.069
这是一对一的

00:04:26.069 --> 00:04:29.139
功能。输入，用它做点什么， 

00:04:29.139 --> 00:04:33.379
返回结果。在功能的情况下

00:04:33.379 --> 00:04:36.699
它有两个类型参数，通用类型参数T和R， 

00:04:36.699 --> 00:04:40.020
这意味着参数的类型和结果

00:04:40.020 --> 00:04:44.750
可以不同，可以相同，但可以不同。还有， 

00:04:44.750 --> 00:04:48.300
与我们拥有BiConsumer的方式一样，还有另一个

00:04:48.300 --> 00:04:52.759
此版本称为BiFunction。这是需要的

00:04:52.759 --> 00:04:56.970
两个参数并返回结果。再次

00:04:56.970 --> 00:05:00.090
在这种情况下，所有这些类型都可以不同， 

00:05:00.090 --> 00:05:04.900
因此两个参数的类型和返回类型可以不同。再次， 

00:05:04.900 --> 00:05:09.099
这有一些有用的默认方法，您可以用来编写

00:05:09.099 --> 00:05:13.409
职能。有两个。一个是组成，一个是

00:05:13.409 --> 00:05:17.210
接着。确定您使用哪个

00:05:17.210 --> 00:05:20.389
取决于您是否想要

00:05:20.389 --> 00:05:24.659
在此之前应用的功能的第二种形式

00:05:24.659 --> 00:05:28.400
主要功能或之后的功能。compose将应用

00:05:28.400 --> 00:05:31.759
新功能，然后再应用已定义的功能， 

00:05:31.759 --> 00:05:35.150
然后将应用已定义的功能

00:05:35.150 --> 00:05:39.330
然后对其应用另一个功能。这里的例子

00:05:39.330 --> 00:05:42.560
函数的作用仅仅是让我们的学生

00:05:42.560 --> 00:05:46.479
并获取名称，以便输入参数为学生s， 

00:05:46.479 --> 00:05:50.509
输出是那个学生的名字

00:05:50.509 --> 00:05:54.150
作为字符串。就BiFunction而言

00:05:54.150 --> 00:05:57.830
我们可以接受两个参数，在这种情况下是一个字符串

00:05:57.830 --> 00:06:01.259
和一个学生的，我们将返回

00:06:01.259 --> 00:06:04.870
一个教师类型的新对象，它同时使用

00:06:04.870 --> 00:06:08.219
名字和学生为

00:06:08.219 --> 00:06:14.430
我们将用于构造函数的值。 

00:06:14.430 --> 00:06:17.490
 UnaryOperator。这真的是

00:06:17.490 --> 00:06:20.550
就像一个函数，但这是一种特定的类型

00:06:20.550 --> 00:06:24.599
功能。在这种情况下，它与函数相同

00:06:24.599 --> 00:06:28.020
其中两个参数

00:06:28.020 --> 00:06:31.210
和返回类型相同。它的

00:06:31.210 --> 00:06:34.440
在某种程度上类似于函数的子类。 

00:06:34.440 --> 00:06:39.229
在这里，我们有一个传递字符串s的示例， 

00:06:39.229 --> 00:06:42.599
然后我们返回字符串的小写版本， 

00:06:42.599 --> 00:06:46.830
所以我们传入一个字符串并返回一个字符串。两者是同一类型。 

00:06:46.830 --> 00:06:50.409
以我们拥有的相同方式

00:06:50.409 --> 00:06:54.930
 UnaryOperator，它是

00:06:54.930 --> 00:06:58.870
函数，还有一个二进制运算符，它是一种特殊形式

00:06:58.870 --> 00:07:01.930
 BiFunction。再说一次

00:07:01.930 --> 00:07:06.060
在这种情况下，可能存在不同类型的参数和结果

00:07:06.060 --> 00:07:09.699
我们传递给apply方法的两个参数

00:07:09.699 --> 00:07:13.229
与返回类型相同，因此使用T 

00:07:13.229 --> 00:07:18.009
贯穿所有三个不同的变量。我们可以看到一个例子

00:07:18.009 --> 00:07:18.530
这里， 

00:07:18.530 --> 00:07:22.889
我们在传递两个字符串作为参数

00:07:22.889 --> 00:07:26.020
然后我们有一个Lambda表达式主体

00:07:26.020 --> 00:07:29.770
这是比较字符串的长度并返回两者中的任意一个

00:07:29.770 --> 00:07:30.469
最长， 

00:07:30.469 --> 00:07:34.180
 x或y的

00:07:34.180 --> 00:07:38.069
返回的类型是一个字符串，两个参数的类型是一个字符串， 

00:07:38.069 --> 00:07:42.509
因此它是BinaryOperator，谓词。 

00:07:42.509 --> 00:07:46.110
当我们看函数式接口时，我们已经看过谓词

00:07:46.110 --> 00:07:49.800
再次，这是发布专门的表格

00:07:49.800 --> 00:07:53.560
的功能，因为在这种情况下， 

00:07:53.560 --> 00:07:57.580
总是返回一个布尔值。有一个论点，但是

00:07:57.580 --> 00:08:00.900
始终返回一个布尔值以指示是否

00:08:00.900 --> 00:08:03.979
谓词为真，为假。 

00:08:03.979 --> 00:08:07.039
同样，有两个参数

00:08:07.039 --> 00:08:10.159
 BiPredicate的形式，它需要两个

00:08:10.159 --> 00:08:14.740
参数并返回一个布尔值，就像您具有BiFunction一样， 

00:08:14.740 --> 00:08:18.969
因此，您可以对BiPredicate执行相同的操作。再次， 

00:08:18.969 --> 00:08:23.020
有一些有用的默认方法和静态方法可以组合使用

00:08:23.020 --> 00:08:23.919
这些东西， 

00:08:23.919 --> 00:08:27.169
所以你可以做典型的二进制

00:08:27.169 --> 00:08:31.349
您可以执行的操作，可以执行的操作或可以进行取反的操作。 

00:08:31.349 --> 00:08:36.209
然后，您也可以说isEqual。 

00:08:36.209 --> 00:08:40.110
我们已经看到的例子就是一个例子

00:08:40.110 --> 00:08:43.919
在我们传递参数s的地方，我们返回

00:08:43.919 --> 00:08:46.920
毕业年份是2011年，那是

00:08:46.920 --> 00:08:52.709
谓词Lambda表达式，我们将毕业年份与2011年进行比较

00:08:52.709 --> 00:08:56.100
并返回一个布尔值。作为一个例子

00:08:56.100 --> 00:08:59.579
在这种情况下，BiPredicate 

00:08:59.579 --> 00:09:02.980
一种在文件中查找方法的情况

00:09:02.980 --> 00:09:06.240
我们传递路径和属性

00:09:06.240 --> 00:09:10.040
然后我们可以定义如何使用这些

00:09:10.040 --> 00:09:13.839
确定是否将使用文件

00:09:13.839 --> 00:09:18.209
就我们的结果而言。在这种情况下，我们正在做的是

00:09:18.209 --> 00:09:18.829
服用

00:09:18.829 --> 00:09:22.320
路径的字符串值，名称

00:09:22.320 --> 00:09:27.250
我们的路径，测试是否以点JS结尾，以查看是否

00:09:27.250 --> 00:09:28.380
一个JavaScript文件

00:09:28.380 --> 00:09:32.320
然后还要测试以查看文件的大小

00:09:32.320 --> 00:09:36.240
超过一千字节。我们同时使用了两个参数

00:09:36.240 --> 00:09:42.620
根据该BiPredicate传递。总结部分

00:09:42.620 --> 00:09:46.860
四，功能包，这是JDK 8中的新增功能

00:09:46.860 --> 00:09:50.390
为我们提供了非常有用的函数式接口。 

00:09:50.390 --> 00:09:53.600
我们将在第二课中看到这些

00:09:53.600 --> 00:09:57.149
在流API中广泛使用

00:09:57.149 --> 00:10:00.449
但是我们在其他许多地方也使用它们

00:10:00.449 --> 00:10:05.180
我们将在本课程的稍后部分看到这些内容。虽然可以

00:10:05.180 --> 00:10:09.709
为功能包定义自己的扩展，可能非常

00:10:09.709 --> 00:10:11.570
您不太可能需要。 

00:10:11.570 --> 00:10:15.199
您会发现已定义的内容将涵盖

00:10:15.199 --> 00:10:19.410
基本而言，您几乎需要的任何情况

00:10:19.410 --> 00:10:23.589
这些类型的事物的函数式接口。 

00:10:23.589 --> 00:10:26.059
至此，本节的结尾。 

