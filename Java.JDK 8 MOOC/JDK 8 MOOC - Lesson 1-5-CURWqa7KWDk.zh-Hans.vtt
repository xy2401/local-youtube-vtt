WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.790 --> 00:00:12.379
 [音乐] 

00:00:12.379 --> 00:00:14.809
您好，欢迎来到第五节

00:00:14.809 --> 00:00:16.430
第一课

00:00:16.430 --> 00:00:20.019
在这里，我们将讨论方法和构造函数引用， 

00:00:20.019 --> 00:00:23.439
这是定义的简写形式

00:00:23.439 --> 00:00:30.230
某些类型的Lambda表达式。经常

00:00:30.230 --> 00:00:33.739
我们最终得到的那种Lambda表达式非常简单

00:00:33.739 --> 00:00:38.150
一种表达式，我们要做的就是传递一个参数，在这种情况下， 

00:00:38.150 --> 00:00:43.750
文件f和Lambda表达式的主体只是调用一个方法

00:00:43.750 --> 00:00:47.159
在该参数上。在这种情况下，我们称为canRead 

00:00:47.159 --> 00:00:50.160
在f。因此，我们提供了一个

00:00:50.160 --> 00:00:53.449
表示是的简写方式

00:00:53.449 --> 00:00:56.719
方法参考。我们可以通过说同样的事情

00:00:56.719 --> 00:00:59.920
文件，它只是参数f的类型， 

00:00:59.920 --> 00:01:02.960
冒号，可以读取， 

00:01:02.960 --> 00:01:06.619
我们要在特定位置调用的方法

00:01:06.619 --> 00:01:10.149
参数，所以我们要调用f.canRead。 

00:01:10.149 --> 00:01:13.580
编译器将简单地获取该消息参考

00:01:13.580 --> 00:01:17.590
并将其扩展为上述Lambda表达式

00:01:17.590 --> 00:01:23.369
然后以相同的方式进行编译。现在

00:01:23.369 --> 00:01:26.689
我们需要一些有关方法引用的细节

00:01:26.689 --> 00:01:30.700
了解，因为实际上有三种类型， 

00:01:30.700 --> 00:01:35.170
或三个可以使用方法引用的地方，它们会有所不同

00:01:35.170 --> 00:01:35.759
略

00:01:35.759 --> 00:01:39.770
就语法的工作方式而言。 

00:01:39.770 --> 00:01:43.720
这三种类型是静态方法， 

00:01:43.720 --> 00:01:47.219
你有一个实例方法

00:01:47.219 --> 00:01:51.990
任意类型，因此您不是要使用的变量类型

00:01:51.990 --> 00:01:55.250
您已经在代码中，然后第三种形式是

00:01:55.250 --> 00:01:58.890
现有对象上的实例方法

00:01:58.890 --> 00:02:02.210
这是您在代码中要调用的变量

00:02:02.210 --> 00:02:02.710
方法

00:02:02.710 --> 00:02:05.840
在那。格式

00:02:05.840 --> 00:02:10.250
此处显示的方法参考是您拥有目标参考， 

00:02:10.250 --> 00:02:11.150
那是你的参考

00:02:11.150 --> 00:02:15.140
键入冒号冒号，然后输入方法的名称

00:02:15.140 --> 00:02:21.189
将通过该方法引用进行调用。 

00:02:21.189 --> 00:02:24.049
关于我们如何构造它们， 

00:02:24.049 --> 00:02:28.900
规则略有不同，主要取决于您何时拥有

00:02:28.900 --> 00:02:29.760
的实例

00:02:29.760 --> 00:02:33.079
任意类型。对于静态方法

00:02:33.079 --> 00:02:37.430
这很简单。如果Lambda表达式是您拥有一组

00:02:37.430 --> 00:02:39.620
左手边的参数

00:02:39.620 --> 00:02:44.209
 Lambda运算符，然后您在特定对象上调用静态方法

00:02:44.209 --> 00:02:47.889
然后用这些参数上课

00:02:47.889 --> 00:02:51.209
等效的方法引用只是名称

00:02:51.209 --> 00:02:55.040
该类的名称以及静态方法的名称。 

00:02:55.040 --> 00:02:59.120
如果要拨打电话，这非常简单，例如integer.parseint 

00:02:59.120 --> 00:03:02.939
在字符串上，那么它只是整数冒号冒号parseint 

00:03:02.939 --> 00:03:06.909
因为那是您在特定类上调用的方法。 

00:03:06.909 --> 00:03:10.730
您在哪里使用实例

00:03:10.730 --> 00:03:14.540
是您还没有引用的任意类型的

00:03:14.540 --> 00:03:17.790
它在方式上略有不同

00:03:17.790 --> 00:03:21.129
使用参数

00:03:21.129 --> 00:03:24.159
在转换为方法参考方面。 

00:03:24.159 --> 00:03:28.199
在此示例中，我们得到的参数为零

00:03:28.199 --> 00:03:33.530
然后我们还有其他一些争论。在Lambda表达式中，我们要做的是使用

00:03:33.530 --> 00:03:35.079
第一个论点

00:03:35.079 --> 00:03:38.500
作为我们要调用方法的参数

00:03:38.500 --> 00:03:42.269
然后我们调用实例方法

00:03:42.269 --> 00:03:46.159
在该参数上，我们传递其余参数

00:03:46.159 --> 00:03:50.269
作为该方法的参数。对于那种情况

00:03:50.269 --> 00:03:53.859
我们要做的就是使用参数零的类型

00:03:53.859 --> 00:03:57.379
作为类名冒号冒号，然后

00:03:57.379 --> 00:04:00.659
与我们调用该方法相同的实例方法名称

00:04:00.659 --> 00:04:04.959
在我们的方法参考中。对于

00:04:04.959 --> 00:04:08.379
我们参考的Lambda 

00:04:08.379 --> 00:04:11.699
现有变量，我们希望在我们的变量中使用它

00:04:11.699 --> 00:04:15.379
再次编写代码，我们将在左侧有一组参数， 

00:04:15.379 --> 00:04:18.870
 Lambda表达式的右侧将作为参考

00:04:18.870 --> 00:04:24.000
到我们在代码中具有的变量以及要在其上调用的方法。 

00:04:24.000 --> 00:04:28.550
然后，我们将参数作为参数传递给该方法。 

00:04:28.550 --> 00:04:32.550
等效的方法引用不是使用类型

00:04:32.550 --> 00:04:35.759
类的类型

00:04:35.759 --> 00:04:38.889
表达式我们使用表达式本身

00:04:38.889 --> 00:04:43.990
编译器将了解该类型对我们而言

00:04:43.990 --> 00:04:47.710
并将其转换为上面合适的Lambda表达式。 

00:04:47.710 --> 00:04:51.050
如果我们看一些例子， 

00:04:51.050 --> 00:04:55.150
对于这种情况下的静态方法，我们正在通过

00:04:55.150 --> 00:04:59.110
 string，我们想打印该字符串，所以我们有

00:04:59.110 --> 00:05:03.960
的System.out.println等效方法参考

00:05:03.960 --> 00:05:07.050
只是说System.out 

00:05:07.050 --> 00:05:10.080
这是班

00:05:10.080 --> 00:05:14.009
我们要使用的方法和println是静态方法

00:05:14.009 --> 00:05:17.159
该类的。在这种情况下

00:05:17.159 --> 00:05:21.009
 s将作为参数传递。我们在哪里

00:05:21.009 --> 00:05:26.610
对我们没有的类型的引用

00:05:26.610 --> 00:05:29.949
在我们的课上，所以这是一个任意类型。 

00:05:29.949 --> 00:05:33.030
在这种情况下，我们拥有的是字符串s 

00:05:33.030 --> 00:05:36.780
和诠释我，我们在

00:05:36.780 --> 00:05:39.800
变量s 

00:05:39.800 --> 00:05:43.400
参数i。那里的转换， 

00:05:43.400 --> 00:05:46.460
正如我在上一张幻灯片中说的那样，我们使用

00:05:46.460 --> 00:05:50.409
的s，字符串，不需要使用s，我们只使用类型

00:05:50.409 --> 00:05:55.070
字符串以及对我们要调用子字符串的方法的引用。 

00:05:55.070 --> 00:05:58.219
再次，编译器会发现， 

00:05:58.219 --> 00:06:01.889
在这种情况下，我们不需要

00:06:01.889 --> 00:06:05.729
将s作为参数传递，我们仅使用

00:06:05.729 --> 00:06:11.930
我将参数作为子字符串的参数。然后是我们指的最后一个表格

00:06:11.930 --> 00:06:15.960
我们已经参考过的东西

00:06:15.960 --> 00:06:19.000
在这种情况下，我们得到的是轴a 

00:06:19.000 --> 00:06:22.120
作为参数，然后我们调用getLength 

00:06:22.120 --> 00:06:25.759
在a上，其中getLength是存在的方法

00:06:25.759 --> 00:06:29.919
在我们实际执行代码的类中。 

00:06:29.919 --> 00:06:34.089
在这种情况下，而不是引用类的类型

00:06:34.089 --> 00:06:38.319
我们使用对此的引用，因为这引用了我们所在的对象

00:06:38.319 --> 00:06:42.449
然后我们就调用getLength，因为getLength是方法

00:06:42.449 --> 00:06:45.509
在当前对象中，参数为

00:06:45.509 --> 00:06:52.020
 a，它将自动传递给getLength。我们可以使用相同的

00:06:52.020 --> 00:06:55.029
构造函数参考的想法，因为

00:06:55.029 --> 00:06:58.229
构造函数非常像方法需要参数

00:06:58.229 --> 00:07:03.019
并创建一个新对象。我们这里有一个例子

00:07:03.019 --> 00:07:06.939
我们有一家工厂想要创建字符串类型的列表。 

00:07:06.939 --> 00:07:10.559
我们有一个lambda表达式，实际上

00:07:10.559 --> 00:07:14.240
供应商，这不会引起任何争论

00:07:14.240 --> 00:07:18.339
并将返回字符串类型的新ArrayList。我们可以

00:07:18.339 --> 00:07:22.679
使用我们为方法参考使用的等效快捷方式， 

00:07:22.679 --> 00:07:27.339
但作为构造函数参考。而不是调用特定方法

00:07:27.339 --> 00:07:30.629
我们想实例化一个新对象，所以我们只使用

00:07:30.629 --> 00:07:34.249
新。我们有ArrayList &lt;String&gt;冒号

00:07:34.249 --> 00:07:37.849
 new表示我们将创建一个新实例ArrayList 

00:07:37.849 --> 00:07:42.879
字符串类型。总结部分

00:07:42.879 --> 00:07:46.219
五方法引用做什么

00:07:46.219 --> 00:07:49.439
给我们很多的简写

00:07:49.439 --> 00:07:53.089
常见的简单Lambda。 

00:07:53.089 --> 00:07:56.369
当您开始越来越多地使用它们时，您会发现， 

00:07:56.369 --> 00:08:01.269
它们将变得更容易阅读，您将了解实际情况

00:08:01.269 --> 00:08:02.759
在代码中更容易。 

00:08:02.759 --> 00:08:06.089
有三种不同的类型和

00:08:06.089 --> 00:08:10.209
我们如何使用它们取决于格式，请记住

00:08:10.209 --> 00:08:14.889
如果您使用的是任意类型，则参数的处理方式是： 

00:08:14.889 --> 00:08:15.899
使用参数

00:08:15.899 --> 00:08:19.649
作为您要在其上调用方法的事物的类型

00:08:19.649 --> 00:08:25.500
其余参数作为参数传递给该方法。 

00:08:25.500 --> 00:08:29.310
我们可以对构造函数使用相同的东西，所以我们可以有一个构造函数引用

00:08:29.310 --> 00:08:32.779
而不是调用特定方法

00:08:32.779 --> 00:08:36.399
我们使用对new的引用而不是方法名

00:08:36.399 --> 00:08:40.080
到此为止

00:08:40.080 --> 00:08:42.729
本课。 

