WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.790 --> 00:00:02.810
 [音乐] 

00:00:12.440 --> 00:00:14.820
您好，欢迎来到第六部分

00:00:14.820 --> 00:00:17.890
第一课这里我们要谈的是

00:00:17.890 --> 00:00:21.140
如何引用外部变量

00:00:21.140 --> 00:00:24.710
当您处理Lambda表达式以及如何使用时

00:00:24.710 --> 00:00:30.360
来自周围范围的变量数据。如果你看

00:00:30.360 --> 00:00:33.920
匿名内部类对

00:00:33.920 --> 00:00:37.250
如何在周围的范围内引用变量。 

00:00:37.250 --> 00:00:40.340
本质上，您引用的任何变量

00:00:40.340 --> 00:00:44.580
必须标记为最终值，这意味着它的值设置一次

00:00:44.580 --> 00:00:47.870
并且未修改。这是因为

00:00:47.870 --> 00:00:51.559
就匿名内部类提供的内容而言， 

00:00:51.559 --> 00:00:54.780
实际上是对

00:00:54.780 --> 00:00:59.409
一个值，而不是变量的闭包。不同的编程语言需要

00:00:59.409 --> 00:01:00.589
不同的方法

00:01:00.589 --> 00:01:05.210
在关闭方面。 Java的想法是封闭值， 

00:01:05.210 --> 00:01:09.280
 Haskell等语言也是如此。一些语言

00:01:09.280 --> 00:01:13.299
例如Scala，允许您检查变量的闭包， 

00:01:13.299 --> 00:01:16.780
这意味着您可以修改变量

00:01:16.780 --> 00:01:20.350
从周围的范围。就......而言

00:01:20.350 --> 00:01:25.689
之所以如此重要，是因为对于多线程代码， 

00:01:25.689 --> 00:01:29.469
您实际上想要做的是避免修改状态。 

00:01:29.469 --> 00:01:33.109
在本课程的前面，我们对此进行了一些讨论，但

00:01:33.109 --> 00:01:37.219
可能出现的问题是，如果您使用Lambda表达式， 

00:01:37.219 --> 00:01:38.350
修改状态

00:01:38.350 --> 00:01:42.869
周围范围内的变量可能是Lambda表达式用于

00:01:42.869 --> 00:01:44.359
几个不同的线程

00:01:44.359 --> 00:01:48.159
并且您可能会获得比赛条件，可能会获得不一致的数据。 

00:01:48.159 --> 00:01:53.600
对于Lambda表达式，因为它们可以在任何地方使用

00:01:53.600 --> 00:01:57.499
您可以拥有等效的匿名内部类，但我们仍然有相同的限制。 

00:01:57.820 --> 00:02:02.659
我们仍然有封闭价值的想法，但是我们已经做了

00:02:02.659 --> 00:02:06.579
是放宽规则。 

00:02:06.579 --> 00:02:09.940
在访问范围内的变量方面

00:02:09.940 --> 00:02:14.960
它必须有效地是最终的。这意味着不必标记

00:02:14.960 --> 00:02:19.400
最终，但它的行为方式必须完全相同

00:02:19.400 --> 00:02:21.959
好像标记为最终的一样。 

00:02:21.959 --> 00:02:25.480
我在这里有一个示例，其中有一个名为expire的方法

00:02:25.480 --> 00:02:28.549
我传递了一个叫做before的变量

00:02:28.549 --> 00:02:33.109
进入那个方法。然后我想用那个

00:02:33.109 --> 00:02:37.200
变量，即Lambda表达式中的before值。 

00:02:37.200 --> 00:02:41.599
在这里，我正在测试上次修改日期是否早于该日期。 

00:02:41.599 --> 00:02:45.310
即使之前未标记为最终， 

00:02:45.310 --> 00:02:49.099
仅在代码中未对其修改的情况下才设置其值

00:02:49.099 --> 00:02:53.359
因此它的行为与标记为final的行为完全相同。 

00:02:53.359 --> 00:02:57.209
如果我在参数的定义中添加了final 

00:02:57.209 --> 00:03:01.569
代码的工作方式不会改变，所以我可以使用它

00:03:01.569 --> 00:03:07.409
在我的Lambda表情中。我们需要了解

00:03:07.409 --> 00:03:10.450
这意味着什么

00:03:10.450 --> 00:03:13.489
表达式。现在我们用这个

00:03:13.489 --> 00:03:17.989
用Java表示我们实际使用的对象的实例

00:03:17.989 --> 00:03:22.430
那时候。对于Lambda表达式

00:03:22.430 --> 00:03:26.129
记得我已经说过Lambda表达式不是

00:03:26.129 --> 00:03:29.530
与班级相关，因此没有

00:03:29.530 --> 00:03:35.150
 Lambda表达式直接与之关联的对象。这不像

00:03:35.150 --> 00:03:36.459
匿名内部类

00:03:36.459 --> 00:03:40.510
编译器将在其中为您创建综合类

00:03:40.510 --> 00:03:44.569
然后在运行时实例化该类并创建一个对象

00:03:44.569 --> 00:03:47.609
您可以将其称为

00:03:47.609 --> 00:03:50.669
在匿名内部类中。 Lambda表达式

00:03:50.669 --> 00:03:53.739
没有课程；没有对象

00:03:53.739 --> 00:03:57.699
因此，这不能引用lambda表达式本身。 

00:03:57.699 --> 00:04:01.519
如果您在Lambda表达式中使用它， 

00:04:01.519 --> 00:04:04.650
您将要指的是对象

00:04:04.650 --> 00:04:09.479
周围的范围。那是两者之间的区别

00:04:09.479 --> 00:04:13.780
 Lambda表达式和匿名内部类，这是需要注意的

00:04:13.780 --> 00:04:16.720
意识到。 

00:04:16.720 --> 00:04:20.760
这可能会产生一些奇怪的影响。 

00:04:20.760 --> 00:04:23.970
这是我写的一些代码， 

00:04:23.970 --> 00:04:27.730
就我正在处理的一些实际代码而言，非常像这样。 

00:04:27.730 --> 00:04:31.060
我所做的是我有一个叫做过程的方法， 

00:04:31.060 --> 00:04:34.220
从某处得到一些数据

00:04:34.220 --> 00:04:37.520
然后我增加了currentValue 

00:04:37.520 --> 00:04:42.330
这是周围范围中的变量，编译器没有抱怨， 

00:04:42.330 --> 00:04:45.460
它很高兴地编译了代码。我运行了代码，它起作用了。 

00:04:45.460 --> 00:04:48.890
我看着它，我以为那不行

00:04:48.890 --> 00:04:52.530
因为我正在修改周围范围的变量， 

00:04:52.530 --> 00:04:55.750
这不是最终的，也不是有效的最终

00:04:55.750 --> 00:05:00.500
那为什么行得通呢？我花了一段时间才找到答案，但是

00:05:00.500 --> 00:05:04.150
在这种情况下，编译器有一些技巧

00:05:04.150 --> 00:05:08.240
代表你。它所做的实际上是插入

00:05:08.240 --> 00:05:11.900
对此的参考，请记住， 

00:05:11.900 --> 00:05:14.919
指周围范围的对象， 

00:05:14.919 --> 00:05:18.260
在这种情况下，DataProcessor对象和

00:05:18.260 --> 00:05:22.570
这实际上是最终的。如果不修改，则设置其值。 

00:05:22.570 --> 00:05:27.530
我们可以使用对此的引用作为有效的最终变量

00:05:27.530 --> 00:05:30.890
然后通过以下方式引用currentValue 

00:05:30.890 --> 00:05:34.040
这个。我们不用担心

00:05:34.040 --> 00:05:37.710
修改currentValue，它是非最终变量。 

00:05:37.710 --> 00:05:41.600
我个人认为这有点危险，因为， 

00:05:41.600 --> 00:05:45.510
如我所说，如果您具有多线程环境，则可能会遇到

00:05:45.510 --> 00:05:46.700
你得到的情况

00:05:46.700 --> 00:05:50.970
数据不一致，由编译器为您插入

00:05:50.970 --> 00:05:54.220
默默地没有

00:05:54.220 --> 00:05:58.100
弄清楚实际情况。 

00:05:58.100 --> 00:06:01.790
就像我说的那样，我必须深入研究才能发现实际发生的情况

00:06:01.790 --> 00:06:02.360
这里， 

00:06:02.360 --> 00:06:05.370
所以要意识到这是一种潜力， 

00:06:05.370 --> 00:06:09.020
在某些方面可能是有用的功能，但也可能有问题

00:06:09.020 --> 00:06:10.000
特征

00:06:10.000 --> 00:06:13.780
当您使用多个线程时。 

00:06:13.780 --> 00:06:16.780
总结第六部分，您可以

00:06:16.780 --> 00:06:20.360
访问Lambda周围范围内的变量

00:06:20.360 --> 00:06:23.680
只要他们有效地成为决赛， 

00:06:23.680 --> 00:06:28.090
表示它们是最终的，或者它们的行为完全相同

00:06:28.090 --> 00:06:32.539
作为最终变量。如果你用这个

00:06:32.539 --> 00:06:36.379
用Lambda表示对象

00:06:36.379 --> 00:06:39.740
周围的范围，并且正如我所说，要注意

00:06:39.740 --> 00:06:43.860
在我向您展示的情况下，编译器将插入一个

00:06:43.860 --> 00:06:48.949
静默引用，使您能够在

00:06:48.949 --> 00:06:49.460
周边范围

00:06:49.460 --> 00:06:52.729
没有问题的不是

00:06:52.729 --> 00:06:56.680
有效地最终。到此为止

00:06:56.680 --> 00:06:58.300
本节内容。 

