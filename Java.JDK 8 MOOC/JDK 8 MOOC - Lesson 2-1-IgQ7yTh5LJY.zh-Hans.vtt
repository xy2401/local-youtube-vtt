WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.790 --> 00:00:03.340
 [音乐] 

00:00:13.679 --> 00:00:15.599
您好，欢迎上课

00:00:15.599 --> 00:00:18.860
大规模的公开和在线课程中的两个

00:00:18.860 --> 00:00:23.070
关于JDK 8函数式编程。的

00:00:23.070 --> 00:00:26.820
本课的目的是向您介绍流

00:00:26.820 --> 00:00:31.300
 API。我又叫西蒙·里特， 

00:00:31.300 --> 00:00:38.750
 Java技术推广员。就本课的议程而言， 

00:00:38.750 --> 00:00:43.000
我们将从函数式编程的介绍开始

00:00:43.000 --> 00:00:43.920
概念

00:00:43.920 --> 00:00:48.500
了解一些明显的差异非常重要

00:00:48.500 --> 00:00:51.839
我们习惯于编程Java之间

00:00:51.839 --> 00:00:57.229
 JDK 8以及我们如何从函数角度考虑事物

00:00:57.229 --> 00:01:01.220
当我们开始使用带有lambda表达式的streams API时。 

00:01:01.220 --> 00:01:05.650
我们将从那里转到我们真正的意思

00:01:05.650 --> 00:01:09.590
一个流，我们将看一下流API的元素

00:01:09.590 --> 00:01:13.010
在如何组合使用方面。 

00:01:13.010 --> 00:01:16.100
然后我们将讨论一些

00:01:16.100 --> 00:01:19.630
当我们处理流之间的差异

00:01:19.630 --> 00:01:24.609
对象流以及当我们处理原始类型流时。 

00:01:24.609 --> 00:01:27.840
这是关于Java的事情之一，不是

00:01:27.840 --> 00:01:31.759
完全面向对象，它没有将所有内容都表示为对象。 

00:01:31.759 --> 00:01:35.770
有时我们确实需要考虑原始类型，对于流，有

00:01:35.770 --> 00:01:38.090
我们需要注意的某些问题。 

00:01:38.090 --> 00:01:43.030
然后，我们将讨论可以从何处获取流源

00:01:43.030 --> 00:01:47.810
在JDK 8中。可以在许多地方从中创建流源

00:01:47.810 --> 00:01:51.679
在课程的这一部分中，我们将讨论这些内容。 

00:01:51.679 --> 00:01:55.490
然后我们将讨论流接口本身

00:01:55.490 --> 00:01:59.069
以及所谓的中间操作。不用担心现在的情况

00:01:59.069 --> 00:02:00.219
我们将谈论那些

00:02:00.219 --> 00:02:04.200
当我们浏览流中的元素时。下一部分也一样

00:02:04.200 --> 00:02:05.439
终端操作

00:02:05.439 --> 00:02:08.890
因为当我们谈论流的元素时，我们将再次讨论那些内容。 

00:02:08.890 --> 00:02:12.060
本课的最后一部分是

00:02:12.060 --> 00:02:15.440
关于另一个称为Optional类的类

00:02:15.440 --> 00:02:18.760
这对

00:02:18.760 --> 00:02:22.770
在某些方面，我们如何使用流，但它也非常有用

00:02:22.770 --> 00:02:24.459
在其他方面

00:02:24.459 --> 00:02:27.930
各种代码，我们将说明您可以实际使用的内容

00:02:27.930 --> 00:02:31.189
的可选方式以及可以应用它们的不同方式

00:02:31.189 --> 00:02:36.319
针对不同的情况。 

00:02:36.319 --> 00:02:40.170
让我们从第二课的第一部分开始

00:02:40.170 --> 00:02:44.639
函数式编程概念。现在， 

00:02:44.639 --> 00:02:48.200
 Java是命令式编程语言

00:02:48.200 --> 00:02:51.450
而且，如果我们看看使用Java的方式， 

00:02:51.450 --> 00:02:54.939
特别是在所有变量方面， 

00:02:54.939 --> 00:02:59.650
我们需要了解某些事物的名称和值。 

00:02:59.650 --> 00:03:03.200
在Java中，我们使用一个变量

00:03:03.200 --> 00:03:07.750
提供关联。它的作用是提供

00:03:07.750 --> 00:03:12.019
我们可以识别的名称，可以在代码中使用

00:03:12.019 --> 00:03:16.590
和与该变量名关联存储的值。 

00:03:16.590 --> 00:03:19.870
然后我们要做的是

00:03:19.870 --> 00:03:23.329
通过将值与变量关联

00:03:23.329 --> 00:03:26.849
我们可以在一系列命令中使用它们。 

00:03:26.849 --> 00:03:31.650
有效地，尽管当您查看代码时可能没有意识到

00:03:31.650 --> 00:03:35.959
因为看到了循环，所以看到了条件语句，例如if 

00:03:35.959 --> 00:03:39.419
其他等等，你实际上在做什么

00:03:39.419 --> 00:03:42.739
正在创建一系列命令， 

00:03:42.739 --> 00:03:46.540
这是作业。你改变

00:03:46.540 --> 00:03:51.689
基于某些因素的变量值。我们这样做的方法是

00:03:51.689 --> 00:03:55.310
 equal语句，所以我们说变量名等于expression。 

00:03:55.310 --> 00:03:59.269
该表达式可能很简单，例如X = X + 10， 

00:03:59.269 --> 00:04:03.139
因此我们将X加10。 

00:04:03.139 --> 00:04:06.519
 X = X ++，那不是一个很好的例子

00:04:06.519 --> 00:04:10.579
 X ++是更好的例子，因为那只是增加了

00:04:10.579 --> 00:04:13.930
变量，等效于X = X + 1。 

00:04:13.930 --> 00:04:17.870
 X等于通话结果

00:04:17.870 --> 00:04:22.070
在X上处理一个值，所以我们可以调用一个方法

00:04:22.070 --> 00:04:25.220
这是另一种形式

00:04:25.220 --> 00:04:28.389
表达式。表达式可以引用其他变量， 

00:04:28.389 --> 00:04:32.150
所以如果我想处理X，我也可以传递y 

00:04:32.150 --> 00:04:34.000
作为我想要的方式的另一部分

00:04:34.000 --> 00:04:37.699
处理它。我们可以通过许多不同的方式来做到这一点， 

00:04:37.699 --> 00:04:41.889
但它使我们在使用方式上具有完全的灵活性

00:04:41.889 --> 00:04:45.599
其他变量。我们可以做的是实际上

00:04:45.599 --> 00:04:50.490
根据过去所做的更改使用该值。 

00:04:50.490 --> 00:04:54.340
通过命令序列，我们可以逐渐更改不同的值

00:04:54.340 --> 00:04:57.830
当我们到达某个点时， 

00:04:57.830 --> 00:05:02.669
基于先前发生的事情的新价值。所以我们得到的价值

00:05:02.669 --> 00:05:05.669
实际上可以从命令传递到命令

00:05:05.669 --> 00:05:08.970
通过使用变量来表示它们。 

00:05:08.970 --> 00:05:12.830
如果我们要重复特定的命令

00:05:12.830 --> 00:05:16.500
我们可以通过简单地说清楚地做到这一点

00:05:16.500 --> 00:05:20.330
 X = X + 10，下一行X = X + 10，下一行X = X + 10，依此类推。 

00:05:20.330 --> 00:05:23.410
或者我们可以使用循环，我们可以使用for循环， 

00:05:23.410 --> 00:05:26.900
 while循环，我们可以使用do循环，然后我们可以重复

00:05:26.900 --> 00:05:30.020
基于某种命令

00:05:30.020 --> 00:05:34.099
表达式的求值以确定我们何时要完成该表达式

00:05:34.099 --> 00:05:38.820
环。从函数的角度

00:05:38.820 --> 00:05:42.830
这是我们目前在Java中直到JDK 8才开始做的事情。 

00:05:42.830 --> 00:05:45.889
我们做的是我们的基础

00:05:45.889 --> 00:05:50.909
根据结构化函数调用上的代码的名称和值

00:05:50.909 --> 00:05:54.590
如果您回想起我在谈论时使用的第一个示例

00:05:54.590 --> 00:05:56.610
为什么我们需要lambda表达式

00:05:56.610 --> 00:06:00.070
我说过我们可以将显式循环重写为

00:06:00.070 --> 00:06:04.219
一系列链接在一​​起的方法调用，这是有效的

00:06:04.219 --> 00:06:05.969
我们对函数式编程所做的工作： 

00:06:05.969 --> 00:06:09.669
我们采用一个函数，然后根据该结果调用另一个函数， 

00:06:09.669 --> 00:06:13.669
我们根据结果调用另一个函数，依此类推。我们在一起

00:06:13.669 --> 00:06:14.669
这些函数

00:06:14.669 --> 00:06:19.469
给我们一组结果。所以每个函数都接收值

00:06:19.469 --> 00:06:22.909
从上一个函数作为输入，然后是

00:06:22.909 --> 00:06:26.490
生成的结果将其传递回

00:06:26.490 --> 00:06:29.630
调用函数并最终通过

00:06:29.630 --> 00:06:33.139
回到您要的作业

00:06:33.139 --> 00:06:39.699
结果。根据我们用于函数式编程的名称

00:06:39.699 --> 00:06:43.000
它与Java不同，与命令式编程不同

00:06:43.000 --> 00:06:46.760
因为我们仅将名称用于形式参数 我们的函数，并且我们只能分配

00:06:50.470 --> 00:06:54.270
该值一次。因此，我们将传递的值分配为参数

00:06:54.270 --> 00:06:57.540
就是这样；它没有改变，没有被修改。 

00:06:57.540 --> 00:07:01.820
变量设置一次，其值设置一次

00:07:01.820 --> 00:07:06.040
就是这样。没有命令的概念

00:07:06.040 --> 00:07:09.810
在函数式编程中，因为我们习惯于命令式代码。 

00:07:09.810 --> 00:07:12.979
没有分配值的想法

00:07:12.979 --> 00:07:16.010
因为您只需执行一个即可更改值

00:07:16.010 --> 00:07:20.380
函数并反复调用该函数或其他函数

00:07:20.380 --> 00:07:25.120
从该函数。没有重复的概念

00:07:25.120 --> 00:07:28.479
从一定意义上讲， 

00:07:28.479 --> 00:07:32.370
 Java代码，因为我们没有for循环，所以没有while循环；我们

00:07:32.370 --> 00:07:38.320
没有做循环。如果我们看一下名称和值之间的区别

00:07:38.320 --> 00:07:42.110
当涉及命令式代码与函数性代码时。 在命令代码中，相同的名称可以与不同的值关联； 

00:07:47.090 --> 00:07:50.830
这就是变量的全部概念。在函数代码中

00:07:50.830 --> 00:07:54.130
一个名字永远都没有关联

00:07:54.130 --> 00:07:59.450
具有一个价值。执行顺序

00:07:59.450 --> 00:08:03.389
从角度来看这也很重要

00:08:03.389 --> 00:08:06.510
命令式与函数式的关系。 

00:08:06.510 --> 00:08:10.139
如果我们看一下命令式代码以及我们如何处理

00:08:10.139 --> 00:08:13.330
在JDK 8之前的Java中

00:08:13.330 --> 00:08:17.760
将值与变量名以及要更改的值相关联。 

00:08:17.760 --> 00:08:21.770
我们执行命令的顺序

00:08:21.770 --> 00:08:24.860
签订合同，这又回到了

00:08:24.860 --> 00:08:28.590
第一课中使用的第一个示例。通过for循环

00:08:28.590 --> 00:08:32.110
我们在一个集合上迭代，迭代

00:08:32.110 --> 00:08:36.430
该集合的迭代器根据迭代器的工作方式以定义的顺序进行。 

00:08:36.430 --> 00:08:39.650
这样就与编译器签订了合同

00:08:39.650 --> 00:08:43.649
在运行时遇到了有关如何处理数据的问题。 

00:08:43.649 --> 00:08:48.990
我们可以更改它，而不必更改应用程序的行为

00:08:48.990 --> 00:08:52.839
除非我们知道我们是

00:08:52.839 --> 00:08:56.639
在可能会破坏应用程序代码的情况下。 

00:08:56.639 --> 00:09:00.499
因此编译器无法重新排序，因为它无法告诉

00:09:00.499 --> 00:09:03.870
这是否真的会对

00:09:03.870 --> 00:09:07.399
产生的结果。函数代码

00:09:07.399 --> 00:09:11.009
记住，现在我们没有名字

00:09:11.009 --> 00:09:15.470
与可以更改的值相关联，因此在这种情况下

00:09:15.470 --> 00:09:18.779
执行顺序不影响结果。 

00:09:18.779 --> 00:09:23.620
我们从另一个方法中调用一个方法，然后将一个函数传递给另一个函数

00:09:23.620 --> 00:09:26.689
该函数的实际处理方式无关紧要。 

00:09:26.689 --> 00:09:30.499
我们返回的结果将来自该函数，并且

00:09:30.499 --> 00:09:33.899
发生顺序无关紧要。所以没有

00:09:33.899 --> 00:09:37.980
固定的执行顺序，根据下面发生的情况

00:09:37.980 --> 00:09:42.309
以处理方法的方式处理方法。 

00:09:42.309 --> 00:09:46.249
这导致我们重复。 

00:09:46.249 --> 00:09:50.430
在我们的Java代码中，在命令性代码中， 

00:09:50.430 --> 00:09:53.889
同样，我们有与名称相关的值

00:09:53.889 --> 00:09:57.379
并且可以通过命令更改它们。所以我们可以

00:09:57.379 --> 00:10:00.480
使用我们的命令重复这些命令

00:10:00.480 --> 00:10:06.339
 for循环，do循环的想法，我们可以反复更改

00:10:06.339 --> 00:10:10.110
变量。如果我们从X等于0循环到X等于10 

00:10:10.110 --> 00:10:13.189
我们在0到10之间反复更改X。 

00:10:13.189 --> 00:10:17.370
因此，新值与相同名称相关联

00:10:17.370 --> 00:10:22.480
通过重复循环。在函数上

00:10:22.480 --> 00:10:26.029
编程与名称关联的值

00:10:26.029 --> 00:10:30.240
可能不会更改，因此再次回到我们之前所说的。 

00:10:30.240 --> 00:10:33.629
现在通过嵌套实现了重复的更改

00:10:33.629 --> 00:10:37.839
函数调用，因此，如果我们想调用同一函数三次，则应回调

00:10:37.839 --> 00:10:39.870
从第一个函数开始

00:10:39.870 --> 00:10:44.709
然后我们再次调用该函数，以便为我们提供

00:10:44.709 --> 00:10:48.679
一种重复的方式，但不是受控方式

00:10:48.679 --> 00:10:51.000
我们将有循环，您可以在其中指定多少

00:10:51.000 --> 00:10:55.410
次完成。所以在这种情况下使用函数式编程

00:10:55.410 --> 00:10:59.880
我们为关联新价值所做的实际工作

00:10:59.880 --> 00:11:04.380
具有相同名称的是通过递归。我们正在使用递归

00:11:04.380 --> 00:11:08.910
提供修改事物并将状态传回的函数。 

00:11:08.910 --> 00:11:12.230
我们将在第3课中进一步讨论这一点， 

00:11:12.230 --> 00:11:15.800
当我们看一些如何解决问题的例子

00:11:15.800 --> 00:11:20.100
特定类型的问题以及为什么需要以更递归的方式进行思考。 

00:11:20.100 --> 00:11:23.750
作为价值的函数

00:11:23.750 --> 00:11:27.870
这确实是我们必须包括在内的原因

00:11:27.870 --> 00:11:30.960
 JDK 8中的lambda表达式，因为

00:11:30.960 --> 00:11:35.700
我们在第1课中看到的lambda表达式可以通过

00:11:35.700 --> 00:11:39.440
行为与我们相同

00:11:39.440 --> 00:11:42.590
一个值。有效， 

00:11:42.590 --> 00:11:46.740
因为函数式编程允许将函数视为值， 

00:11:46.740 --> 00:11:50.920
这意味着我们可以将其作为参数传递给方法

00:11:50.920 --> 00:11:55.480
或函数，那么我们需要Java中的这种函数。 

00:11:55.480 --> 00:11:59.250
因此我们可以使用匿名内部类来实现，但是语法也是如此

00:11:59.250 --> 00:12:00.120
复杂， 

00:12:00.120 --> 00:12:03.810
语法太冗长，我们需要一种简单的方法

00:12:03.810 --> 00:12:07.580
这就是lambda表达式给我们的。现在我们有能力

00:12:07.580 --> 00:12:08.250
至

00:12:08.250 --> 00:12:11.250
通过行为作为参数

00:12:11.250 --> 00:12:14.339
因此，我们可以采用更实用的方法

00:12:14.339 --> 00:12:17.540
因为我们可以使用lambda表达式

00:12:17.540 --> 00:12:20.820
告诉方法我们要怎么做

00:12:20.820 --> 00:12:25.430
通过使用该lambda表达式表示实现。 

00:12:25.430 --> 00:12:28.960
总结一下

00:12:28.960 --> 00:12:32.920
如果您比较必要的话，第2课的第1节

00:12:32.920 --> 00:12:36.570
代码节对他们的方法起作用

00:12:36.570 --> 00:12:40.190
有很大的不同，我们需要意识到

00:12:40.190 --> 00:12:44.140
当我们开始使用streams API时，当我们开始解决

00:12:44.140 --> 00:12:48.450
我们可以解决的问题。如果我们必须认真思考

00:12:48.450 --> 00:12:52.000
那么我们正在做的就是关联价值

00:12:52.000 --> 00:12:55.550
带有要更改的名称。这就是我们的变量

00:12:55.550 --> 00:12:58.630
我们可以更改变量的值

00:12:58.630 --> 00:13:02.390
只要不是最终代码，我们代码中的任何一点。 

00:13:02.390 --> 00:13:05.900
就执行顺序而言，我们实际上在做什么

00:13:05.900 --> 00:13:09.010
用命令性代码定义合同

00:13:09.010 --> 00:13:12.540
编译器和运行时，以便执行顺序

00:13:12.540 --> 00:13:16.500
很重要如果我们想重复

00:13:16.500 --> 00:13:19.670
在命令式代码中则是显式的。 

00:13:19.670 --> 00:13:22.779
我们使用一个外部循环来定义

00:13:22.779 --> 00:13:26.180
具有特定结构的for循环，我们有一个while循环，我们有一个

00:13:26.180 --> 00:13:26.720
做循环。 

00:13:26.720 --> 00:13:30.220
这些都是明确的，我们

00:13:30.220 --> 00:13:33.520
说明我们的代码如何处理

00:13:33.520 --> 00:13:37.790
函数式编程与名称关联的值

00:13:37.790 --> 00:13:41.220
用作参数。它们的值设置一次

00:13:41.220 --> 00:13:45.260
并且无法更改；这与当务之急有很大的不同。 

00:13:45.260 --> 00:13:49.279
函数实际如何处理

00:13:49.279 --> 00:13:52.790
其信息即数据中的参数

00:13:52.790 --> 00:13:56.680
执行顺序没有定义，所以

00:13:56.680 --> 00:13:59.890
这是并行应用的能力

00:13:59.890 --> 00:14:03.130
处理这些事情变得更加简单，因为

00:14:03.130 --> 00:14:06.420
我们不必担心非确定性行为

00:14:06.420 --> 00:14:10.670
开始使用多个线程并将工作分解为两个时的代码片段

00:14:10.670 --> 00:14:11.270
不同

00:14:11.270 --> 00:14:14.640
有潜在任务的任务

00:14:14.640 --> 00:14:19.170
以不同的顺序处理。我们重复的方式

00:14:19.170 --> 00:14:22.180
通过函数式编程正在使用

00:14:22.180 --> 00:14:25.270
递归。您在处理时需要思考

00:14:25.270 --> 00:14:28.300
关于函数式编程

00:14:28.300 --> 00:14:33.020
您如何递归执行操作而不是使用显式循环。 

00:14:33.020 --> 00:14:36.440
至此第一节结束

00:14:36.440 --> 00:14:37.330
第二课

