WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.790 --> 00:00:02.810
 [音乐] 

00:00:13.280 --> 00:00:14.700
您好，欢迎来到第2节

00:00:14.700 --> 00:00:17.750
第二课

00:00:17.750 --> 00:00:20.650
在这一部分中，我们将讨论什么是流

00:00:20.650 --> 00:00:24.020
实际上是流的各个元素

00:00:24.020 --> 00:00:30.289
创造了它的结构。 

00:00:30.289 --> 00:00:33.380
如果您从较高的角度看待流的概述， 

00:00:33.380 --> 00:00:37.020
本质上，我们正在处理的是一种抽象

00:00:37.020 --> 00:00:40.600
用于指定聚合计算。 

00:00:40.600 --> 00:00:44.260
这种声音听起来很复杂，但这实质上是我们已经看到的

00:00:44.260 --> 00:00:49.340
在课程的较早部分，我们收集数据

00:00:49.340 --> 00:00:54.970
并且我们要指定如何处理该收集数据。 

00:00:54.970 --> 00:00:58.140
我们使用我们正在寻找的示例

00:00:58.140 --> 00:01:02.059
得分最高的学生，或学生得分最高的学生

00:01:02.059 --> 00:01:07.330
是在2011年。那是一个汇总计算，因为我们采用了

00:01:07.330 --> 00:01:10.399
收集数据并在那里寻找一个特定的值。 

00:01:10.399 --> 00:01:13.850
关于重要的事情

00:01:13.850 --> 00:01:17.119
一个流是，虽然你可能

00:01:17.119 --> 00:01:20.200
倾向于将其视为数据结构

00:01:20.200 --> 00:01:24.250
当然，当我们谈论这些要素时，必须保持这种方式

00:01:24.250 --> 00:01:24.960
作品

00:01:24.960 --> 00:01:28.660
它看起来确实很像数据结构，不是。 

00:01:28.660 --> 00:01:32.899
数据结构只是包含在内， 

00:01:32.899 --> 00:01:36.610
如果我们有一个集合，是一个列表，是一个集合，是一个

00:01:36.610 --> 00:01:41.450
哈希图，或其他。那就是数据结构。流本身

00:01:41.450 --> 00:01:45.049
只是定义我们如何处理的方式

00:01:45.049 --> 00:01:50.070
顺序元素和一件非常重要的事情

00:01:50.070 --> 00:01:53.610
关于流的是它们可以是无限的。 

00:01:53.610 --> 00:01:58.200
因此，对多少元素没有限制

00:01:58.200 --> 00:02:01.770
流可以有，它可以是无限流

00:02:01.770 --> 00:02:06.369
永远进行下去，以及我们如何终止该流，如何摆脱该流

00:02:06.369 --> 00:02:07.180
流

00:02:07.180 --> 00:02:11.160
与我们处理循环的方式有些不同。 

00:02:11.160 --> 00:02:14.209
我们习惯于在Java中使用无限循环， 

00:02:14.209 --> 00:02:17.829
我们不知道循环需要执行多少次。 

00:02:17.829 --> 00:02:21.519
我们要做的是创建一个循环，其内容为true 

00:02:21.519 --> 00:02:25.430
做某事，然后我们测试X是否为

00:02:25.430 --> 00:02:28.769
 10分，我们可以跳出循环。 

00:02:28.769 --> 00:02:33.100
我们不能在流中做到这一点；没有任何概念可以突破

00:02:33.100 --> 00:02:34.360
因为没有概念

00:02:34.360 --> 00:02:37.280
环。还记得我们在第1节中谈到的

00:02:37.280 --> 00:02:40.430
函数式编程与命令式编程相比，但我们会来

00:02:40.430 --> 00:02:42.569
回到我们如何使用无限流

00:02:42.569 --> 00:02:47.240
以及我们如何以与我们几乎相同的方式终止该无限流

00:02:47.240 --> 00:02:52.530
无限循环流允许我们做的是

00:02:52.530 --> 00:02:55.690
创建一个关于我们想要如何的简单描述

00:02:55.690 --> 00:02:58.819
执行这些计算并

00:02:58.819 --> 00:03:02.190
代码，并制作库代码。 

00:03:02.190 --> 00:03:05.860
这非常有用，因为它使我们能够

00:03:05.860 --> 00:03:09.700
有机会优化该代码的工作方式。 

00:03:09.700 --> 00:03:13.680
我们要做的是可以进行复杂的操作

00:03:13.680 --> 00:03:18.220
我们可以将某些操作融合在一起，以便它们一起发生

00:03:18.220 --> 00:03:22.050
而不是必须单独进行。这样就可以了

00:03:22.050 --> 00:03:25.250
更高效。我们可以用

00:03:25.250 --> 00:03:28.980
懒惰的评估，这样我们就不必评估一个

00:03:28.980 --> 00:03:30.569
如果我们不需要收集

00:03:30.569 --> 00:03:33.850
正如我们已经看到的，我们可以申请

00:03:33.850 --> 00:03:36.870
与我们如何做这些事情平行

00:03:36.870 --> 00:03:39.989
因为使用函数式编程时请记住没有

00:03:39.989 --> 00:03:44.340
依靠订单执行，这意味着我们可以

00:03:44.340 --> 00:03:47.410
使用与以下完全相同的方式进行并行处理

00:03:47.410 --> 00:03:50.900
顺序处理而不会改变结果。 

00:03:50.900 --> 00:03:54.620
现在来讲

00:03:54.620 --> 00:03:57.890
流，您可以考虑一下

00:03:57.890 --> 00:04:01.950
代表我们正在处理数据的管道。 

00:04:01.950 --> 00:04:05.350
该管道的一端

00:04:05.350 --> 00:04:09.570
是我们所说的来源，所以在左侧我们有一个来源

00:04:09.570 --> 00:04:12.920
的流，这将是一组

00:04:12.920 --> 00:04:16.400
我们要处理的东西的元素。 

00:04:16.400 --> 00:04:20.430
它可能来自集合，可能来自网络连接，也可能来自

00:04:20.430 --> 00:04:21.700
无论我们在哪里

00:04:21.700 --> 00:04:25.120
但这是我们要处理的元素的来源

00:04:25.120 --> 00:04:28.690
那就是它的流。这将是一系列元素

00:04:28.690 --> 00:04:29.460
处理。 

00:04:29.460 --> 00:04:33.560
我们要做的是获取流源， 

00:04:33.560 --> 00:04:37.979
该流，然后将其传递到零或更多

00:04:37.979 --> 00:04:42.340
中间作业。中间操作

00:04:42.340 --> 00:04:46.210
是作为输入流并生成的一个

00:04:46.210 --> 00:04:48.990
作为输出流。 

00:04:48.990 --> 00:04:51.530
这样我们就可以获取一个中间产品的输出

00:04:51.530 --> 00:04:54.710
操作并将其输入到

00:04:54.710 --> 00:04:58.120
另一个中间操作。如您在图中所见

00:04:58.120 --> 00:05:01.430
代表中间操作的蓝色框。 

00:05:01.430 --> 00:05:05.890
流入，流出。连接第一个操作的流输出

00:05:05.890 --> 00:05:10.850
到第二个中间操作的输入。一旦我们

00:05:10.850 --> 00:05:13.980
完成了我们想要的所有中间处理， 

00:05:13.980 --> 00:05:17.070
我们需要终止该流

00:05:17.070 --> 00:05:20.800
我们需要管道的另一端

00:05:20.800 --> 00:05:25.020
为此，我们进行了终端操作。 

00:05:25.020 --> 00:05:28.380
终端操作将流作为输入

00:05:28.380 --> 00:05:31.610
并且不会生成流作为输出。 

00:05:31.610 --> 00:05:35.430
它产生的是明确的结果

00:05:35.430 --> 00:05:38.940
以价值或collections之类的形式， 

00:05:38.940 --> 00:05:43.440
或产生副作用，而副作用可能像

00:05:43.440 --> 00:05:44.960
打印一条消息说

00:05:44.960 --> 00:05:49.190
找到了东西。所以这是三个

00:05:49.190 --> 00:05:54.190
我们信息流的主要组成部分：来源， 

00:05:54.190 --> 00:05:59.010
中间操作，终端操作。这是一个例子

00:05:59.010 --> 00:06:03.240
流以及我们将如何使用它。他的情况

00:06:03.240 --> 00:06:07.140
我有交易集。从那组交易中， 

00:06:07.140 --> 00:06:11.630
我需要创建一个流源，因此我要在其上调用stream方法， 

00:06:11.630 --> 00:06:14.960
然后返回流。 

00:06:14.960 --> 00:06:18.280
我们将该流传递到

00:06:18.280 --> 00:06:22.600
在这种情况下的中间操作是过滤器

00:06:22.600 --> 00:06:26.729
只选择那些在伦敦的买家

00:06:26.729 --> 00:06:31.850
从我们所有的交易中。然后我们通过

00:06:31.850 --> 00:06:36.190
到另一个名为mapToInt的中间操作，它将创建一个

00:06:36.190 --> 00:06:36.780
的流

00:06:36.780 --> 00:06:40.669
整数或整数，即价格

00:06:40.669 --> 00:06:44.419
这些交易中。我们将更多地讨论原始

00:06:44.419 --> 00:06:50.530
在本课后面的章节中介绍对象表示。一旦我们有了所有的流

00:06:50.530 --> 00:06:54.070
交易价格，价格，我们通过

00:06:54.070 --> 00:06:56.149
进入终端操作

00:06:56.149 --> 00:06:59.349
将所有这些值相加

00:06:59.349 --> 00:07:02.739
然后将返回到总计

00:07:02.739 --> 00:07:06.789
全部交易

00:07:06.789 --> 00:07:12.929
对于在伦敦的买家。现在

00:07:12.929 --> 00:07:17.089
在终端操作方面，我们需要了解的是

00:07:17.089 --> 00:07:20.829
尽管当我们谈论流时，我们说，嗯，您从

00:07:20.829 --> 00:07:22.449
您传递给中间人的来源

00:07:22.449 --> 00:07:25.869
创建新流并将其传递的操作

00:07:25.869 --> 00:07:29.159
等等。那是理解的好方法

00:07:29.159 --> 00:07:32.699
本质上是如何运作的，但不是

00:07:32.699 --> 00:07:36.519
实际在库代码中实现的方式

00:07:36.519 --> 00:07:40.219
这样就只能评估管道本身

00:07:40.219 --> 00:07:43.809
当终端操作被调用时

00:07:43.809 --> 00:07:47.539
该管道中的所有操作

00:07:47.539 --> 00:07:50.800
要么顺序执行，要么

00:07:50.800 --> 00:07:53.809
并行执行，然后返回

00:07:53.809 --> 00:07:57.529
在第3课中讨论这一点，当我们在更多内容中讨论并行流时

00:07:57.529 --> 00:07:58.149
详情。 

00:07:58.149 --> 00:08:02.039
但实质上是按顺序执行

00:08:02.039 --> 00:08:07.860
还是并行执行，因为直到到达终端我们什么都不做

00:08:07.860 --> 00:08:08.719
运作

00:08:08.719 --> 00:08:12.139
确实意味着我们可以将一些中间产品合并在一起

00:08:12.139 --> 00:08:15.949
操作。这样我们就可以避免多余的通行证

00:08:15.949 --> 00:08:19.719
根据数据，我们还可以做短路之类的事情

00:08:19.719 --> 00:08:23.019
就像它的名字一样，所以如果我们想找到140 00：08：23,019-&gt; 00：08：26,199第一个元素大于10 

00:08:26.199 --> 00:08:29.709
在输入流中有1000个元素

00:08:29.709 --> 00:08:33.189
那么您不必担心处理所有这些

00:08:33.189 --> 00:08:37.329
一旦找到一个实际上大于10的

00:08:37.329 --> 00:08:41.430
短路时，您可以进行懒惰评估，实际将结果通过

00:08:41.430 --> 00:08:44.540
因为您需要他们，而不是提前处理所有事情。 

00:08:44.540 --> 00:08:49.620
在内部，有许多特征可供使用

00:08:49.620 --> 00:08:54.100
流。作为开发人员，您不必担心这一点，但这就是事实

00:08:54.100 --> 00:08:58.029
可以在库代码内部用于优化事物。 

00:08:58.029 --> 00:09:01.160
因此，例如，流的特征之一是

00:09:01.160 --> 00:09:02.059
其独特之处。 

00:09:02.059 --> 00:09:05.100
因此，如果我们知道没有

00:09:05.100 --> 00:09:06.380
重复元素

00:09:06.380 --> 00:09:09.700
在那流中。如果您通过流

00:09:09.700 --> 00:09:13.140
方法，与众不同

00:09:13.140 --> 00:09:16.370
stream已经不同了，那么我们就不需要做任何事情，因为我们知道

00:09:16.370 --> 00:09:17.910
它与众不同

00:09:17.910 --> 00:09:22.030
额外的工作要做。一旦知道它是与众不同的，我们将不再对其进行处理。 

00:09:22.030 --> 00:09:25.860
所以总结一下第二节

00:09:25.860 --> 00:09:29.300
您可以像我说的那样想到一条流，就像一条管道。 

00:09:29.300 --> 00:09:33.600
一端是数据通过的源

00:09:33.600 --> 00:09:37.300
 0个或更多中间操作。我的意思是当你想

00:09:37.300 --> 00:09:42.690
终止该流，您可以执行终端操作。处理数据的方式， 

00:09:42.690 --> 00:09:46.780
即使它正在处理数据集也不使用显式

00:09:46.780 --> 00:09:50.650
循环，所以这非常重要，然后回到

00:09:50.650 --> 00:09:54.230
命令式行为与函数式行为之间的差异。没有

00:09:54.230 --> 00:09:55.490
显式循环

00:09:55.490 --> 00:09:58.560
循环是隐式的

00:09:58.560 --> 00:10:02.120
您正在使用的所有库代码。这是什么意思

00:10:02.120 --> 00:10:06.230
是它确实使我们很容易将流变为顺序流

00:10:06.230 --> 00:10:07.940
流到并行流

00:10:07.940 --> 00:10:11.980
不用担心会改变代码的工作方式，是否会改变结果

00:10:11.980 --> 00:10:12.810
正在生成。 

00:10:12.810 --> 00:10:15.970
到第二节结束。 

