WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.790 --> 00:00:02.810
 [音乐] 

00:00:13.730 --> 00:00:15.780
您好，欢迎来到第3节

00:00:15.780 --> 00:00:20.070
在第2课中，我们将讨论

00:00:20.070 --> 00:00:24.349
如何使用对象流以及流

00:00:24.349 --> 00:00:29.219
 Java中的基本类型。 

00:00:29.219 --> 00:00:33.160
如果我们看看Java语言，那不是

00:00:33.160 --> 00:00:36.440
真正的面向对象。为了

00:00:36.440 --> 00:00:39.780
提高性能，而不是绝对对待一切

00:00:39.780 --> 00:00:43.550
在Java中，作为对象，我们有基本类型。 

00:00:43.550 --> 00:00:46.900
所以它们是字节，短裤，整数，多头

00:00:46.900 --> 00:00:50.250
双打，浮点数和我们可以使用的字符

00:00:50.250 --> 00:00:53.570
还有布尔值，我们可以使用

00:00:53.570 --> 00:00:57.850
代表原始值

00:00:57.850 --> 00:01:02.660
如果我们想在某些类型的类中使用这些原始值， 

00:01:02.660 --> 00:01:07.140
特别是收藏，那么我们需要将它们转换为

00:01:07.140 --> 00:01:10.509
对象而不是原始表示。 

00:01:10.509 --> 00:01:15.500
因此，我们有等效的类，即所谓的包装器类， 

00:01:15.500 --> 00:01:20.190
对于每个原始类型。因此，有一个Byte类，一个Short类，一个

00:01:20.190 --> 00:01:21.479
整数类等。 

00:01:21.479 --> 00:01:27.090
在使用方式方面，我们可以明确创建

00:01:27.090 --> 00:01:31.350
代码中那些类型的对象，我们可以显式检索值

00:01:31.350 --> 00:01:32.090
从那些

00:01:32.090 --> 00:01:35.680
对象，如果我们想要，但是

00:01:35.680 --> 00:01:39.909
之前有一些关于Java的改进

00:01:39.909 --> 00:01:43.479
因此我们添加了自动装箱和拆箱功能。 

00:01:43.479 --> 00:01:46.549
这意味着如果编译器可以确定

00:01:46.549 --> 00:01:49.560
您实际上正在使用原始值

00:01:49.560 --> 00:01:52.580
需要使用对象表示的地方

00:01:52.580 --> 00:01:56.180
然后它将为您创建一个对象实例

00:01:56.180 --> 00:02:00.520
包装类的类，将值作为参数传递给构造函数。 

00:02:00.520 --> 00:02:03.570
如果它可以告诉您您需要什么

00:02:03.570 --> 00:02:06.920
作为原始值，实际上您有一个对象表示形式

00:02:06.920 --> 00:02:07.770
自动地

00:02:07.770 --> 00:02:12.989
取消装箱并为您提取价值。这导致我们

00:02:12.989 --> 00:02:16.879
需要了解有关流如何工作的一些知识。 

00:02:16.879 --> 00:02:20.530
因为如果我们有一个流， 

00:02:20.530 --> 00:02:24.909
默认情况下，所有内容都是对象。所以我们有一个流

00:02:24.909 --> 00:02:28.629
我们从一个源创建，该源将是一个对象流，比如说从

00:02:28.629 --> 00:02:29.200
采集。 

00:02:29.200 --> 00:02:32.260
因此，在此示例中，我们正在做的是

00:02:32.260 --> 00:02:37.150
收集学生，我们创建了一个流。然后，我们将其传递给

00:02:37.150 --> 00:02:41.010
筛选以查看毕业年份是否为2015 

00:02:41.010 --> 00:02:45.010
然后我们传递对象集合

00:02:45.010 --> 00:02:48.440
进入地图。在那时候

00:02:48.440 --> 00:02:51.950
我们要做的是检索分数

00:02:51.950 --> 00:02:55.940
那个学生的名字，但是这里有一个问题，因为

00:02:55.940 --> 00:03:00.650
我们从学生那里获得的分数实际上是

00:03:00.650 --> 00:03:04.569
一个int，所以它是一个原始值。 getScore 

00:03:04.569 --> 00:03:08.239
被定义为返回一个整数，而不是一个整数的签名

00:03:08.239 --> 00:03:11.260
包装对象。因此它返回一个整数。 

00:03:11.260 --> 00:03:15.560
这给美国带来了一点问题，因为当我们绘制地图时

00:03:15.560 --> 00:03:19.370
将会发生的是，我们返回一个整数

00:03:19.370 --> 00:03:22.879
从getScore并为了使其成为

00:03:22.879 --> 00:03:26.609
流必须具有的对象

00:03:26.609 --> 00:03:29.620
自动将这些int装箱为Integer 

00:03:29.620 --> 00:03:35.500
对象来创建整数流。当我们通过整数流时

00:03:35.500 --> 00:03:39.459
最大对象，最大实际需要查看值， 

00:03:39.459 --> 00:03:42.569
因此max必须做相反的事情。一定要

00:03:42.569 --> 00:03:45.810
解开每个这些Integer对象的框，以获取

00:03:45.810 --> 00:03:50.069
价值，这是一项艰巨的工作，因此我们创建了不需要的对象。 

00:03:50.069 --> 00:03:53.919
将它们传递给然后无法采用值的方法

00:03:53.919 --> 00:03:58.859
并使用这些值来解决该问题。 

00:03:58.859 --> 00:04:02.900
我们对流所做的是提供

00:04:02.900 --> 00:04:07.500
 3种特定于类型的特定信息， 

00:04:07.500 --> 00:04:11.150
或特定于原始类型的流。 

00:04:11.150 --> 00:04:14.739
因此有一个IntStream，一个DoubleStream和一个LongStream。 

00:04:14.739 --> 00:04:18.720
我们没有为ByteStream或ShortStream或类似的东西而烦恼

00:04:18.720 --> 00:04:20.260
那些可以代表

00:04:20.260 --> 00:04:24.130
通过IntStream或LongStream。 

00:04:24.130 --> 00:04:29.020
我们可以做的就是改变工作方式

00:04:29.020 --> 00:04:32.730
根据我们的代码。如果我们现在回到一个例子

00:04:32.730 --> 00:04:36.140
我们通过了当年毕业的学生

00:04:36.140 --> 00:04:39.680
 2015年纳入mapToInt。 

00:04:39.680 --> 00:04:43.150
那将是实际要做的，而不是创造

00:04:43.150 --> 00:04:46.610
对象流，它们是整数值

00:04:46.610 --> 00:04:49.770
装在整数对象中

00:04:49.770 --> 00:04:53.550
它将创建整数流。它将创建

00:04:53.550 --> 00:04:58.710
基本值流。因此，我们不需要做

00:04:58.710 --> 00:05:02.290
任何装箱或拆箱，因为当传递给最大

00:05:02.290 --> 00:05:06.060
将会发生的事情是

00:05:06.060 --> 00:05:10.240
原始值，因此可以简单地评估那些值以找到最大值。 

00:05:10.240 --> 00:05:13.370
不必为了获得值而拆箱

00:05:13.370 --> 00:05:18.169
当他们经历。总结第3节， 

00:05:18.169 --> 00:05:21.570
因为Java具有两种原始类型

00:05:21.570 --> 00:05:25.410
以及对象类型，当我们处理流时

00:05:25.410 --> 00:05:29.120
我们需要有能力代表某些

00:05:29.120 --> 00:05:34.360
流的原始类型。正如我所说，其中有三个：IntStream， 

00:05:34.360 --> 00:05:38.520
 DoubleStream和LongStream。当你想使用那些

00:05:38.520 --> 00:05:41.650
您可以使用诸如mapToInt之类的方法， 

00:05:41.650 --> 00:05:45.210
 mapToDouble或mapToLong。还有其他

00:05:45.210 --> 00:05:48.960
方法，如果您有一个流，假设您有一个IntStream 

00:05:48.960 --> 00:05:52.830
并且无论出于何种原因，您都希望将其转换为流对象

00:05:52.830 --> 00:05:57.440
在集合中，您可以执行mapToObj，这样您就可以双向进行。 

00:05:57.440 --> 00:06:01.260
有很有效的方法

00:06:01.260 --> 00:06:04.350
处理对象表示和

00:06:04.350 --> 00:06:08.700
流API中的原始流，到此为止

00:06:08.700 --> 00:06:09.479
第3节。 

