WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.790 --> 00:00:02.810
 [音乐] 

00:00:13.200 --> 00:00:16.040
您好，欢迎来到第2课的第4节。 

00:00:16.040 --> 00:00:19.340
在这一部分中，我们将研究

00:00:19.340 --> 00:00:22.670
您可以在其中创建流的各个不同地方

00:00:22.670 --> 00:00:26.140
源于可用的类和方法

00:00:26.140 --> 00:00:29.800
在JDK 8中。 

00:00:29.800 --> 00:00:33.600
您会发现对JDK 8库的完整分析

00:00:33.600 --> 00:00:38.580
实际上，有23个类中的95个方法返回了流， 

00:00:38.580 --> 00:00:42.800
但并非所有这些实际上都是流源，因为很多

00:00:42.800 --> 00:00:46.260
它们实际上是Stream接口中的中间操作。 

00:00:46.260 --> 00:00:49.440
您还记得流中间操作是

00:00:49.440 --> 00:00:53.129
将流作为输入，并将流作为输出返回。 

00:00:53.129 --> 00:00:56.379
因此，我们实际上并不将其用作流源。 

00:00:56.379 --> 00:01:00.629
对于可用作实际流源的那些

00:01:00.629 --> 00:01:04.839
您可以使用15个类中的71种方法。 

00:01:04.839 --> 00:01:08.130
在本节课中，我们要做的是

00:01:08.130 --> 00:01:11.400
但实际上一周中的大多数日子我们都会与他们一起经历大部分。 

00:01:11.400 --> 00:01:15.130
关于收集界面，我们已经

00:01:15.130 --> 00:01:18.350
已经看到了这个用过的，我们有一个Collection 

00:01:18.350 --> 00:01:22.030
我们要创建一个流源，我们称其为Stream。 

00:01:22.030 --> 00:01:25.259
而这将提供一个连续的

00:01:25.259 --> 00:01:29.829
该集合中的所有元素。如果我们要创建

00:01:29.829 --> 00:01:34.310
并行流，然后我们使用并行流

00:01:34.310 --> 00:01:37.560
方法。所以这很简单，如果我们想要一个顺序流，我们

00:01:37.560 --> 00:01:38.250
呼叫流，如果我们

00:01:38.250 --> 00:01:42.840
想要并行流，我们称为并行流，它将创建并行流

00:01:42.840 --> 00:01:47.049
集合中的元素及其在下面的实际工作方式

00:01:47.049 --> 00:01:52.289
正在使用前连接框架。我们将进一步讨论这一点， 

00:01:52.289 --> 00:01:54.210
查看有关此的更多详细信息

00:01:54.210 --> 00:01:57.600
在第3课中，当我们谈论并行流时

00:01:57.600 --> 00:02:00.800
具体来说，所以我们稍后再讲

00:02:00.800 --> 00:02:03.880
第三课

00:02:03.880 --> 00:02:07.360
 arrays类有一个称为Stream的方法，因为

00:02:07.360 --> 00:02:11.380
如果您考虑一下，数组就是数据的集合，那么逻辑上

00:02:11.380 --> 00:02:13.650
我们希望能够从中创建一个流， 

00:02:13.650 --> 00:02:17.140
但是因为它不是集合API的集合

00:02:17.140 --> 00:02:20.490
我们不能只是在此调用流。所以在这种情况下

00:02:20.490 --> 00:02:23.900
我们需要做的是在数组中使用静态方法

00:02:23.900 --> 00:02:27.000
我们通过的课程和通话流

00:02:27.000 --> 00:02:30.810
数组作为参数，我们回到流中， 

00:02:30.810 --> 00:02:34.370
这是该数组中的流元素。 

00:02:34.370 --> 00:02:38.330
这将提供一个顺序流；没有对等的东西

00:02:38.330 --> 00:02:42.310
并行流，尽管正如我们在第3课中看到的那样， 

00:02:42.310 --> 00:02:43.060
兑换

00:02:43.060 --> 00:02:46.280
从串行流到并行流没有任何问题。 

00:02:46.280 --> 00:02:49.600
有一些重载的方法

00:02:49.600 --> 00:02:53.310
如果您想针对特定类型使用不同的类型，则有两种类型， 

00:02:53.310 --> 00:02:56.390
 int，long和可用于此的对象， 

00:02:56.390 --> 00:03:00.740
取决于要创建流的数组中存储的值

00:03:00.740 --> 00:03:05.060
从。文件类具有

00:03:05.060 --> 00:03:09.080
可以用来创建几种有用的新方法

00:03:09.080 --> 00:03:12.590
流源，我们看到了一个示例

00:03:12.590 --> 00:03:16.350
我们谈论BiPredicate时的第一个

00:03:16.350 --> 00:03:20.350
在新功能接口方面以及

00:03:20.350 --> 00:03:24.410
查找将要做的是，它将采用路径，这是文件系统中的一个点

00:03:24.410 --> 00:03:26.510
您正在寻找的地方

00:03:26.510 --> 00:03:29.570
文件它需要一个BiPredicate， 

00:03:29.570 --> 00:03:33.570
这将使您能够定义使用Lambda表达式

00:03:33.570 --> 00:03:37.269
您如何识别感兴趣的文件

00:03:37.269 --> 00:03:40.920
可以基于名称的大小等

00:03:40.920 --> 00:03:44.769
以及FileVisitOption表示我们是否遵循链接。 

00:03:44.769 --> 00:03:48.580
有创建列表的能力

00:03:48.580 --> 00:03:52.519
来自文件系统中特定点的所有文件，因此您将

00:03:52.519 --> 00:03:56.239
路径作为要列出的参数，这将为您提供

00:03:56.239 --> 00:03:59.260
给定目录中的条目。 

00:03:59.260 --> 00:04:03.180
线条是一种非常有用的方法，同样要做的是

00:04:03.180 --> 00:04:06.799
取一点，这是路径的参数

00:04:06.799 --> 00:04:10.620
进入文件系统，它是一个文件，然后

00:04:10.620 --> 00:04:13.939
行将返回一个流，这是

00:04:13.939 --> 00:04:18.840
该文件中的文本。您可以将它们作为流处理

00:04:18.840 --> 00:04:22.019
各种各样的东西，最后有一个

00:04:22.019 --> 00:04:26.139
 walk方法，它需要一个Path然后

00:04:26.139 --> 00:04:30.419
根据该路径进行文件遍历并返回文件流

00:04:30.419 --> 00:04:33.509
步行参考

00:04:33.509 --> 00:04:36.889
方法，然后是否要

00:04:36.889 --> 00:04:42.620
跟随链接与否。随机数。 

00:04:42.620 --> 00:04:46.770
有三类密切相关： 

00:04:46.770 --> 00:04:50.440
根据您的方式，有Random，ThreadLocalRandom和SplittableRandom 

00:04:50.440 --> 00:04:51.750
实际想使用

00:04:51.750 --> 00:04:54.970
您代码中的随机数生成。 

00:04:54.970 --> 00:04:58.639
在这里我不会详细介绍，但是值得一看

00:04:58.639 --> 00:05:02.280
类文档，以了解它们之间的区别。 

00:05:02.280 --> 00:05:06.389
从流的角度来看，它们都是完全相同的。 

00:05:06.389 --> 00:05:09.919
我们可以产生无限的

00:05:09.919 --> 00:05:14.060
随机数，或者我们可以产生有限的流，我们可以在其中指定

00:05:14.060 --> 00:05:15.360
我们想要很多数字

00:05:15.360 --> 00:05:19.099
在那流中。有一些版本

00:05:19.099 --> 00:05:22.340
 int，它们的版本为double，longs的版本。所以我们可以

00:05:22.340 --> 00:05:26.580
将随机数创建为整数，双精度或长整型，然后有四个版本的

00:05:26.580 --> 00:05:29.870
每个我们可以指定是否

00:05:29.870 --> 00:05:33.389
我们想要有限或无限的整数流

00:05:33.389 --> 00:05:37.039
然后我们还可以指定是否要使用种子

00:05:37.039 --> 00:05:40.270
初始化该随机数流。 

00:05:40.270 --> 00:05:44.440
因此，我们最终得到了四个不同的版本

00:05:44.440 --> 00:05:48.169
每个int，double和long都使我们

00:05:48.169 --> 00:05:51.380
 12个流源

00:05:51.380 --> 00:05:55.009
每个随机数类别，因为有3个随机数类别

00:05:55.009 --> 00:05:58.009
创建流源的36种不同方式

00:05:58.009 --> 00:06:01.280
只是随机数，所以当我在一开始谈论数字时

00:06:01.280 --> 00:06:05.440
流的36种可能来源

00:06:05.440 --> 00:06:08.830
来自随机数生成。 

00:06:08.830 --> 00:06:13.270
一些杂类和方法。 

00:06:13.270 --> 00:06:16.860
对于压缩文件，JarFile和Zipfile 

00:06:16.860 --> 00:06:20.830
现在有一个stream方法，它返回一个流， 

00:06:20.830 --> 00:06:24.420
与文件相关的文件对象

00:06:24.420 --> 00:06:27.980
压缩档案的内容。这样就可以提取

00:06:27.980 --> 00:06:31.310
单个文件，并为您提供文件引用作为流中的元素

00:06:31.310 --> 00:06:34.970
然后可以将其映射为任意值，依此类推。 

00:06:34.970 --> 00:06:40.720
但是BufferedReader有lines方法；这与files类非常相似。 

00:06:40.720 --> 00:06:44.760
因此，如果您将BufferedReader与某个源关联，则无论它是

00:06:44.760 --> 00:06:46.090
网络连接或

00:06:46.090 --> 00:06:49.250
串口或类似的东西，那么你可以

00:06:49.250 --> 00:06:53.020
具有由提供的行文本流

00:06:53.020 --> 00:06:56.910
无论BufferedReader连接到什么。 

00:06:56.910 --> 00:07:00.600
在模式中，有一个称为splitAsStream的新方法。 

00:07:00.600 --> 00:07:04.680
这实际上在split方法上做同样的事情。 

00:07:04.680 --> 00:07:07.680
 split方法返回一个数组

00:07:07.680 --> 00:07:11.150
字符串，与我们感兴趣的特定模式匹配。 

00:07:11.150 --> 00:07:14.540
在splitAsStream而不是返回数组的情况下，它

00:07:14.540 --> 00:07:17.800
返回一个流，以便我们可以处理

00:07:17.800 --> 00:07:22.169
以我们想做的任何方式。几个

00:07:22.169 --> 00:07:26.180
我们拥有的其他杂类。这个CharSequence有

00:07:26.180 --> 00:07:30.820
其中有两种方法：一种是chars，它将返回一个流

00:07:30.820 --> 00:07:34.490
这是该charSequence的char值

00:07:34.490 --> 00:07:38.500
作为整数，作为原始流，然后还有

00:07:38.500 --> 00:07:41.500
代码点将返回流

00:07:41.500 --> 00:07:45.010
这是该序列的代码点值。 

00:07:45.010 --> 00:07:49.260
最后，BitSet有一个称为stream的方法， 

00:07:49.260 --> 00:07:52.680
它将返回给您该位集中的131 00：07：52,680-&gt; 00：07：58,600不同位的索引流。 

00:07:58.600 --> 00:08:01.800
流上有很多静态方法

00:08:01.800 --> 00:08:05.420
接口本身。正如我所说

00:08:05.420 --> 00:08:09.240
在JDK 8中，我们现在可以在接口中包含静态方法，因此

00:08:09.240 --> 00:08:12.980
这是我们使用它的一个很好的例子。你可以采取

00:08:12.980 --> 00:08:17.460
两个流，您可以将它们串联起来。而且没有合并的方法

00:08:17.460 --> 00:08:19.440
流，从某种意义上讲

00:08:19.440 --> 00:08:22.930
一个流中的一个元素，然后是不同流中的另一个元素

00:08:22.930 --> 00:08:26.780
并交替进行。您可以连接两个流

00:08:26.780 --> 00:08:31.880
使用concat并提供2个流。也可以提供空白

00:08:31.880 --> 00:08:32.450
流。 

00:08:32.450 --> 00:08:35.789
我必须承认我真的不知道这样做的目的是什么， 

00:08:35.789 --> 00:08:38.810
因为我不知道为什么你会想要一个空的流，因为没有什么可

00:08:38.810 --> 00:08:40.400
过程，但是无论如何，它在那里

00:08:40.400 --> 00:08:43.500
你应该找到它的用途吗？有

00:08:43.500 --> 00:08:47.570
 of方法，将创建一个流

00:08:47.570 --> 00:08:51.300
从一组值和问题来看是varargs语法， 

00:08:51.300 --> 00:08:54.330
因此您可以传递一个值，也可以传递一个

00:08:54.330 --> 00:08:59.400
一组用逗号分隔的值，或者，因为varargs语法将转换

00:08:59.400 --> 00:09:02.600
将逗号分隔的值放入数组

00:09:02.600 --> 00:09:06.140
您也可以通过的价值观

00:09:06.140 --> 00:09:09.980
生成数组值的东西，然后将创建一个

00:09:09.980 --> 00:09:13.780
从那流。您可以创建

00:09:13.780 --> 00:09:17.380
的值范围

00:09:17.380 --> 00:09:21.580
整数。如果您想要创建（实际上就像一个循环）， 

00:09:21.580 --> 00:09:25.530
但显然这不是循环，因为我们没有针对流进行显式循环， 

00:09:25.530 --> 00:09:30.270
但是如果您想从中获取价值

00:09:30.270 --> 00:09:34.300
 1比方说10，那么您可以使用范围

00:09:34.300 --> 00:09:37.400
和范围关闭。如果使用范围

00:09:37.400 --> 00:09:40.830
并指定1和10，您将获得数字1到9， 

00:09:40.830 --> 00:09:46.300
因为它不包括最终值。如果您使用范围从1到

00:09:46.300 --> 00:09:46.850
 10 

00:09:46.850 --> 00:09:50.000
您会得到1到10之间的值，因为它是包含在内的

00:09:50.000 --> 00:09:52.429
最终值。 

00:09:52.429 --> 00:09:55.579
也可以创建一个

00:09:55.579 --> 00:09:58.619
使用generate的无限流

00:09:58.619 --> 00:10:01.980
您可以在其中简单地将供应商指定为Lambda 

00:10:01.980 --> 00:10:05.019
关于如何创造价值的表达

00:10:05.019 --> 00:10:08.579
然后该流将仅填充基于

00:10:08.579 --> 00:10:11.959
 IntSupplier的功能。你也可以

00:10:11.959 --> 00:10:15.230
迭代，所以如果要应用函数，可以说

00:10:15.230 --> 00:10:18.540
你想创建正方形

00:10:18.540 --> 00:10:21.829
那么您可以从1或2开始

00:10:21.829 --> 00:10:25.369
并使用一个IntUnaryOperator来将数字平方

00:10:25.369 --> 00:10:28.769
因此，每次您调用它时，它将提供序列中的下一个正方形

00:10:28.769 --> 00:10:33.730
等等。总结第4节

00:10:33.730 --> 00:10:38.040
在很多地方都可以从中获取流源。 

00:10:38.040 --> 00:10:41.860
现在添加了许多非常有用的方法。 

00:10:41.860 --> 00:10:45.529
能够从文件中检索行，从压缩文件中检索文件

00:10:45.529 --> 00:10:46.769
档案等。 

00:10:46.769 --> 00:10:50.429
直接创建的唯一方法

00:10:50.429 --> 00:10:54.059
 parallelStream来自集合类，但正如我所说， 

00:10:54.059 --> 00:10:59.230
在第3课中，我们将讨论如何从顺序流转换为

00:10:59.230 --> 00:11:02.569
并行流，并讨论与此有关的问题。但

00:11:02.569 --> 00:11:06.369
就创建流源而言，只有集合可以

00:11:06.369 --> 00:11:11.199
直接创建一个parallelStream。这就是结局

00:11:11.199 --> 00:11:12.309
第4节。 

