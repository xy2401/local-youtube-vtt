WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.790 --> 00:00:02.810
 [音乐] 

00:00:13.120 --> 00:00:15.700
您好，欢迎来到第5节

00:00:15.700 --> 00:00:19.200
第2课的内容

00:00:19.200 --> 00:00:24.250
处理流时可以使用的不同中间操作。如

00:00:24.250 --> 00:00:25.869
你记得我们谈论过这个

00:00:25.869 --> 00:00:29.480
在本课程的前面，如何进行中间操作

00:00:29.480 --> 00:00:32.759
将流作为输入并生成一个输出

00:00:32.759 --> 00:00:36.730
 re流， 

00:00:36.730 --> 00:00:40.700
因为我们已经发现提供了一系列

00:00:40.700 --> 00:00:44.699
元素，我们既不能顺序处理

00:00:44.699 --> 00:00:47.809
或并行。很多

00:00:47.809 --> 00:00:51.249
我们将需要在该流上执行的操作

00:00:51.249 --> 00:00:54.249
使用函数式接口的参数

00:00:54.249 --> 00:00:58.010
这意味着我们可以使用Lambda表达式来定义

00:00:58.010 --> 00:01:02.949
我们要进行处理。该方法本身告诉我们我们想要做什么

00:01:02.949 --> 00:01:06.750
 Lambda表达式告诉方法

00:01:06.750 --> 00:01:11.650
正如我们将在示例中看到的那样，它使我们分离了

00:01:11.650 --> 00:01:16.140
关于我们如何实际处理所拥有元素的关注

00:01:16.140 --> 00:01:19.470
在我们的流中。一件非常重要的事情是

00:01:19.470 --> 00:01:24.280
处理流中创建的对象的方式

00:01:24.280 --> 00:01:28.650
并在流中使用的是我们不得修改它们。这样我们就可以创建新元素

00:01:28.650 --> 00:01:32.680
对于输出流来说这不是问题，但您不得修改元素

00:01:32.680 --> 00:01:36.250
流，否则我们将获得ConcurrentModificationException。 

00:01:36.250 --> 00:01:39.900
通常，这些东西通常是无状态的

00:01:39.900 --> 00:01:43.780
就采取的方法而言，因为这是函数式编程， 

00:01:43.780 --> 00:01:47.340
我们不想引入任何状态，因为那样会

00:01:47.340 --> 00:01:51.450
打破函数编程的规则。我们可以

00:01:51.450 --> 00:01:55.740
将流从顺序更改为并行，我们也可以采用其他方法，所以我们

00:01:55.740 --> 00:01:59.770
可以创建并行流并使其按顺序进行，也可以按顺序进行

00:01:59.770 --> 00:02:03.520
并使其平行。管道中的所有处理

00:02:03.520 --> 00:02:06.660
按顺序或并行进行。 

00:02:06.660 --> 00:02:10.289
因此，无论哪个更改了

00:02:10.289 --> 00:02:14.990
流是顺序的还是并行的将是用来确定

00:02:14.990 --> 00:02:20.640
流中的所有处理。让我们开始

00:02:20.640 --> 00:02:24.430
过滤和映射，因为我们已经看到其中一些

00:02:24.430 --> 00:02:26.370
到目前为止我们看到的例子。 

00:02:26.370 --> 00:02:31.800
第一个是不同的。要做的是我们将返回流

00:02:31.800 --> 00:02:36.190
其中没有重复的元素，因此我们将确保其中没有

00:02:36.190 --> 00:02:40.360
没有相等的元素。我们可以用

00:02:40.360 --> 00:02:44.000
过滤器，它将接受一个作为predicate的参数； 

00:02:44.000 --> 00:02:47.410
我们已经看到它已经用于我们想要做的事情

00:02:47.410 --> 00:02:51.450
是仅识别输入流中的元素

00:02:51.450 --> 00:02:55.140
我们想要传递到输出流。predicate

00:02:55.140 --> 00:02:58.880
将提供一个返回布尔值的方法

00:02:58.880 --> 00:03:02.070
如果传递给那个元素

00:03:02.070 --> 00:03:05.090
方法返回true，则将其添加到输出流

00:03:05.090 --> 00:03:10.170
返回false它被忽略。再次使用前面的示例

00:03:10.170 --> 00:03:13.450
 2011年毕业的所有学生；那是一个

00:03:13.450 --> 00:03:17.150
使用带有predicate的过滤器，该predicate将毕业年份与

00:03:17.150 --> 00:03:20.690
 2011年。 

00:03:20.690 --> 00:03:23.799
一个函数，它将要做的是每个函数

00:03:23.799 --> 00:03:27.380
输入流上的元素将其用作

00:03:27.380 --> 00:03:31.209
函数的参数，然后将

00:03:31.209 --> 00:03:34.630
该函数的结果到输出流上。 

00:03:34.630 --> 00:03:37.769
因此，这是从

00:03:37.769 --> 00:03:41.420
输入流上的值到输出流上的值。 

00:03:41.420 --> 00:03:44.280
正如我们已经看到的那样

00:03:44.280 --> 00:03:49.180
处理基本类型和对象表示的要求。 

00:03:49.180 --> 00:03:52.400
因此，该map方法有三种版本： 

00:03:52.400 --> 00:03:56.510
 mapToInt，mapToDouble，mapToLong会创建

00:03:56.510 --> 00:04:03.000
原始值而不是对象。平面地图。 

00:04:03.000 --> 00:04:07.630
所以我谈到了地图，我说

00:04:07.630 --> 00:04:11.420
地图的工作是我们有一个函数，那个函数

00:04:11.420 --> 00:04:14.570
将采用单个值作为输入

00:04:14.570 --> 00:04:18.459
并生成一个值作为输出，所以这个想法是

00:04:18.459 --> 00:04:22.390
输入流上的每个元素都用作

00:04:22.390 --> 00:04:27.160
函数并将结果放置在输出流上。所以我们一对一

00:04:27.160 --> 00:04:30.840
映射。在某些情况下

00:04:30.840 --> 00:04:34.480
输入流上的每个元素都会创建

00:04:34.480 --> 00:04:39.440
自己的结果流。在那种情况下我们得到什么

00:04:39.440 --> 00:04:42.590
是

00:04:42.590 --> 00:04:47.250
流，每个元素创建自己的流，最后得到一个流

00:04:47.250 --> 00:04:51.040
流。那不是我们所需要的； 

00:04:51.040 --> 00:04:55.110
我们需要一个流作为输出。所以在那种情况下

00:04:55.110 --> 00:04:59.110
我们使用flapMap。 flatMap将要做的是

00:04:59.110 --> 00:05:02.690
输入流，一对多应用

00:05:02.690 --> 00:05:07.750
需要映射，以便输入流中的每个元素都可以创建多个

00:05:07.750 --> 00:05:10.760
元素，然后将它们放在输出上

00:05:10.760 --> 00:05:14.340
流，它们将被连接在一起，以便我们拥有

00:05:14.340 --> 00:05:18.230
单个输出流。但是输出流的大小

00:05:18.230 --> 00:05:24.330
可能与输入流的大小不同。 

00:05:24.330 --> 00:05:28.080
这里有一个示例，说明如何使用flatMap。 

00:05:28.080 --> 00:05:32.240
在这种情况下，我们要尝试提取单词

00:05:32.240 --> 00:05:35.280
来自包含文本行的文件。 

00:05:35.280 --> 00:05:38.400
为此，我在这里得到的是

00:05:38.400 --> 00:05:41.880
 BufferedReader，它们先连接到文件，然后

00:05:41.880 --> 00:05:45.750
使用该方法的lines方法，该方法现在可以记住一个新方法

00:05:45.750 --> 00:05:49.220
返回字符串流， 

00:05:49.220 --> 00:05:53.530
这是BufferedReader中的文本行。我们通过了

00:05:53.530 --> 00:05:57.520
进入flatMap和flatMap使用Lambda表达式

00:05:57.520 --> 00:06:01.360
确定我们将如何创建此流流， 

00:06:01.360 --> 00:06:05.659
它将串联成一个流。我们在这里做什么

00:06:05.659 --> 00:06:09.060
我们是否传递了一个参数，即line？那就是

00:06:09.060 --> 00:06:12.639
来自文件的文本，然后我们创建一个新的流

00:06:12.639 --> 00:06:16.539
使用of方法，这是流上的静态方法

00:06:16.539 --> 00:06:22.220
然后使用正则表达式拆分文本行

00:06:22.220 --> 00:06:26.490
变成个别单词。所以我们根据空格和制表符将其分解

00:06:26.490 --> 00:06:30.500
我们为每一行创建一个新的流

00:06:30.500 --> 00:06:35.030
该行中的单词。然后，flatMap将连接这些流

00:06:35.030 --> 00:06:35.669
一起

00:06:35.669 --> 00:06:39.400
因此，flatMap的输出流将为

00:06:39.400 --> 00:06:42.479
所有来自个人的信息流

00:06:42.479 --> 00:06:46.370
组成输入流的行。我们可能

00:06:46.370 --> 00:06:51.570
过滤器以消除零长度的单词，然后将其传递以收集以创建列表。 

00:06:51.570 --> 00:07:00.080
在第3课中谈论收藏家时，我们将详细讨论。 

00:07:00.080 --> 00:07:01.860
是的，我们要限制

00:07:01.860 --> 00:07:05.000
流的大小是多少

00:07:05.000 --> 00:07:09.190
我们实际上要做的是使用一种或两种方法。我们可以跳过吗

00:07:09.190 --> 00:07:14.550
这将返回流，它接受输入流但跳过

00:07:14.550 --> 00:07:17.850
或忽略前n个

00:07:17.850 --> 00:07:21.240
输入流的元素。限制

00:07:21.240 --> 00:07:25.360
这也需要一个长返回流的参数， 

00:07:25.360 --> 00:07:29.200
仅包含输入流的前n个元素。 

00:07:29.200 --> 00:07:32.860
所以它们有点相反。跳过将返回所有内容

00:07:32.860 --> 00:07:36.300
但是流中的前n个元素，限制返回

00:07:36.300 --> 00:07:41.830
流的前n个元素。再说一次，如果我们看一个例子

00:07:41.830 --> 00:07:45.310
我们有了BufferedReader，我们创建了一个

00:07:45.310 --> 00:07:48.690
来自该BufferedReader的行的流源

00:07:48.690 --> 00:07:52.550
然后将其传递给具有值2的skip。 

00:07:52.550 --> 00:07:55.830
所以要做的是跳过第一个

00:07:55.830 --> 00:07:59.700
文件的两行，然后传递其余的行

00:07:59.700 --> 00:08:03.920
文件到下一个中​​间操作。在这种情况下

00:08:03.920 --> 00:08:07.780
那是极限，只会返回前两个

00:08:07.780 --> 00:08:12.660
该输入流的元素。的效果是

00:08:12.660 --> 00:08:16.100
我们将得到第3行和第4行

00:08:16.100 --> 00:08:20.040
传递给终端操作，在这种情况下是收集操作。 

00:08:20.040 --> 00:08:23.380
现在，这是一个很好的例子

00:08:23.380 --> 00:08:26.820
内部处理的方式

00:08:26.820 --> 00:08:29.980
已优化，因为，如果

00:08:29.980 --> 00:08:34.210
我们的文件中有一千行不会发生

00:08:34.210 --> 00:08:37.950
是线流源方法

00:08:37.950 --> 00:08:41.640
将读取文件中的所有一千行并通过

00:08:41.640 --> 00:08:45.520
全部跳过一千行。跳过然后会说

00:08:45.520 --> 00:08:49.980
跳过前两个并返回998行

00:08:49.980 --> 00:08:53.320
限制。限制内说我只需要

00:08:53.320 --> 00:08:57.250
前两个并返回前两个。那将非常有效

00:08:57.250 --> 00:09:00.910
因此下面的代码将合并这些操作

00:09:00.910 --> 00:09:06.390
并确定实际上只需要读取文件的前4行

00:09:06.390 --> 00:09:08.830
然后它将停止读取

00:09:08.830 --> 00:09:13.020
文件，因为跳过后它将达到两个限制

00:09:13.020 --> 00:09:16.420
输入流中的前两个。所以那是

00:09:16.420 --> 00:09:21.530
一个如何优化的好例子。排序和未排序。 

00:09:21.530 --> 00:09:25.330
排序有一个版本需要

00:09:25.330 --> 00:09:29.330
比较器及其作用是将

00:09:29.330 --> 00:09:33.140
元素，然后它将根据比较器对它们进行排序。 

00:09:33.140 --> 00:09:36.350
因此，如果我们想使用我们拥有的比较器

00:09:36.350 --> 00:09:39.790
在Lambda部分的前面，我们可以使用

00:09:39.790 --> 00:09:43.220
返回长度差，这将对

00:09:43.220 --> 00:09:47.950
输入流中按长度排列的字符串。还有一个

00:09:47.950 --> 00:09:51.630
不带参数的排序方法，因此它不会

00:09:51.630 --> 00:09:54.640
带一个比较器，在这种情况下会排序

00:09:54.640 --> 00:09:57.820
根据自然顺序。如果有数字流，它将

00:09:57.820 --> 00:10:01.630
根据数字顺序，如果有字符串流将对其进行排序

00:10:01.630 --> 00:10:06.900
根据字符串的顺序。还有一个

00:10:06.900 --> 00:10:10.860
无序方法，这是什么

00:10:10.860 --> 00:10:14.300
可能似乎并不是特别有用，因为您实际上是在说什么

00:10:14.300 --> 00:10:14.740
是

00:10:14.740 --> 00:10:17.780
摆脱该流中的任何排序。 

00:10:17.780 --> 00:10:21.130
这实际上更有用的是

00:10:21.130 --> 00:10:24.610
如果您要执行某些操作

00:10:24.610 --> 00:10:29.620
然后诸如distinct和groupingBy之类的东西将在以后处理

00:10:29.620 --> 00:10:33.760
在本课中，这些实际上更有效地工作

00:10:33.760 --> 00:10:37.700
如果您的视频流无序

00:10:37.700 --> 00:10:41.380
跟...共事。真的，这实际上并没有改变顺序， 

00:10:41.380 --> 00:10:44.660
只是改变了

00:10:44.660 --> 00:10:47.810
信息流说它是无序的，所以我们不需要

00:10:47.810 --> 00:10:50.970
在内部做很多工作。那就是那个

00:10:50.970 --> 00:10:54.840
您通常不会使用它来更改代码的函数

00:10:54.840 --> 00:10:58.610
您将使用它来提高效率。就像我说的，如果您正在使用

00:10:58.610 --> 00:10:59.280
不同

00:10:59.280 --> 00:11:02.700
或使用分组通过对大量数据进行处理

00:11:02.700 --> 00:11:08.490
无序可能会改善其工作方式。窥视

00:11:08.490 --> 00:11:11.280
观察流元素经过时的情况。 

00:11:11.280 --> 00:11:14.670
这是在做输入流

00:11:14.670 --> 00:11:18.990
并将其直接传递到输出流。所以它创建了相同的

00:11:18.990 --> 00:11:23.350
输出流作为输入流。那样做

00:11:23.350 --> 00:11:27.320
输入流的每个元素都传递给accept方法

00:11:27.320 --> 00:11:31.930
作为参数传递给peek方法的使用者数量。 

00:11:31.930 --> 00:11:36.600
正如我之前说过的，消费者不要修改是非常重要的

00:11:36.600 --> 00:11:41.200
流中的元素，因此它可以查看它们，可以看到发生了什么， 

00:11:41.200 --> 00:11:45.630
但它不能改变它们。这是一种非常有用的东西

00:11:45.630 --> 00:11:46.380
调试

00:11:46.380 --> 00:11:50.630
我们将在第3课中进行讨论，但是如果您想

00:11:50.630 --> 00:11:52.070
多做一件事

00:11:52.070 --> 00:11:56.350
与流，因此，如果您说要打印出所有

00:11:56.350 --> 00:11:57.460
流元素

00:11:57.460 --> 00:12:01.630
您可以使用窥视函数进行此操作，然后再进行其他处理

00:12:01.630 --> 00:12:08.900
查找名称值或使用流中其他部分的名称。总结第5节

00:12:08.900 --> 00:12:09.470
的

00:12:09.470 --> 00:12:12.700
流接口为您提供

00:12:12.700 --> 00:12:15.920
元素的合计运算

00:12:15.920 --> 00:12:19.810
流，以及大多数您拥有的方法， 

00:12:19.810 --> 00:12:23.290
具有使用定义的行为

00:12:23.290 --> 00:12:28.060
函数式接口，以及Lambda表达式。这是分开的

00:12:28.060 --> 00:12:31.500
怎样才能做到

00:12:31.500 --> 00:12:35.950
这是作为参数传递的Lambda表达式，表示您想要的方式

00:12:35.950 --> 00:12:39.390
过滤器，您要如何映射等。 

00:12:39.390 --> 00:12:42.720
这是一个非常强大的中间操作范围

00:12:42.720 --> 00:12:46.580
允许您以各种不同的方式来操纵流， 

00:12:46.580 --> 00:12:49.660
而且您从地图，flatMap， 

00:12:49.660 --> 00:12:53.500
整理所有这些东西，你就可以建立起来

00:12:53.500 --> 00:12:56.660
真的很复杂的处理

00:12:56.660 --> 00:13:01.030
这些更简单的构建基块，但仍使其非常易读

00:13:01.030 --> 00:13:04.600
非常容易理解和

00:13:04.600 --> 00:13:06.570
这是第5节的结尾。 

