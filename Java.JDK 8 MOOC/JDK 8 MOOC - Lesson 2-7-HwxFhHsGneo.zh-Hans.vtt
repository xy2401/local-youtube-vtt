WEBVTT
Kind: captions
Language: zh-Hans

00:00:13.459 --> 00:00:15.839
您好，欢迎来到第7节

00:00:15.839 --> 00:00:19.390
第2课的内容。在这里，我们将讨论

00:00:19.390 --> 00:00:23.360
可选类，它是JDK 8中引入的新类

00:00:23.360 --> 00:00:28.689
这很大程度上与我们处理流的方式有关

00:00:28.689 --> 00:00:30.060
但这也很有用

00:00:30.060 --> 00:00:35.790
在许多其他地方以及我们将看到的地方。 

00:00:35.790 --> 00:00:39.519
我们遇到的问题是发生了什么

00:00:39.519 --> 00:00:45.149
当我们没有价值并且因为我们正在处理对象时

00:00:45.149 --> 00:00:48.230
如果没有值，则为空引用。 

00:00:48.230 --> 00:00:52.000
因此它实际上是对未初始化对象的引用。 

00:00:52.000 --> 00:00:55.899
因此，我们过去处理过null。我们知道空值是什么，我们知道如何得到它们。 

00:00:55.900 --> 00:01:00.930
他是我们必须面对的问题： 

00:01:00.930 --> 00:01:04.309
假设我有一段代码

00:01:04.339 --> 00:01:08.490
我有一些从GPS接收器拨打的数据

00:01:08.490 --> 00:01:12.009
而我想要得到的是方向

00:01:12.009 --> 00:01:15.280
与我正在读取的位置相关的纬度。 

00:01:15.280 --> 00:01:19.690
我通常会将一些方法调用链接在一起

00:01:19.690 --> 00:01:22.929
说我想要的是纬度方向， 

00:01:22.929 --> 00:01:26.660
来自位置，来自GPS数据。一切都很好。 

00:01:26.660 --> 00:01:30.130
问题在于这将起作用

00:01:30.130 --> 00:01:33.630
只要没有gpsData 

00:01:33.630 --> 00:01:37.830
 getPosition或getLatitude返回null。 

00:01:37.830 --> 00:01:41.140
因为如果这三件事中的任何一个返回null 

00:01:41.140 --> 00:01:45.770
那我得到一个nullPointException因为要尝试调用一个方法

00:01:45.770 --> 00:01:49.610
通过空引用。我不能那样做- 

00:01:49.610 --> 00:01:52.720
给我nullPointerException。所以这

00:01:52.720 --> 00:01:58.239
如果我不能保证GPSdata是最健壮的代码编写方式

00:01:58.239 --> 00:02:01.739
不为null，getPosition和getLatitude不会

00:02:01.740 --> 00:02:05.610
返回一个空值。让我们重写相同的代码

00:02:05.610 --> 00:02:09.810
并从nullPointerExceptions的角度使其完全安全。 

00:02:09.810 --> 00:02:14.160
这就是我们最终得到的结果。我们从分配开始

00:02:14.160 --> 00:02:18.510
一个未知的方向，因此我们有一个确定的值。 

00:02:18.510 --> 00:02:22.120
然后我们看一下gpsData，我们测试一下是否为空， 

00:02:22.120 --> 00:02:24.240
如果不为空，我们得到位置

00:02:24.240 --> 00:02:29.260
来自gpsData.getPosition。然后我们测试一下是否为空。如果不为空

00:02:29.440 --> 00:02:32.440
我们从p.getLatitude获得纬度。 

00:02:32.440 --> 00:02:35.740
然后我们测试纬度不为空。如果纬度不为空，那么我们可以调用

00:02:35.740 --> 00:02:39.760
方向，并获得我们的结果。所以这一切都很好。 

00:02:39.760 --> 00:02:44.050
问题是，我们需要一种更好的方法来做到这一点。 

00:02:44.050 --> 00:02:48.150
当我们看流API时

00:02:48.150 --> 00:02:52.790
在谈论终端操作时，我们经常会发现这一点， 

00:02:52.790 --> 00:02:57.110
是像最小和最大这样的东西，它们... 

00:02:57.110 --> 00:03:00.540
如果我们在InputStream上没有元素

00:03:00.540 --> 00:03:05.290
结果返回什么？我的意思是，我们可以返回0作为最小值

00:03:05.290 --> 00:03:09.150
或最大为0但这实际上没有任何意义，因为我们可能没有进行比较

00:03:09.150 --> 00:03:12.770
基于数值。和

00:03:12.770 --> 00:03:16.570
因此，我们通常会返回null。 

00:03:16.570 --> 00:03:19.780
但这变得困难，因为如果我们要处理

00:03:19.780 --> 00:03:23.860
此外，我们遇到了问题，然后我们进行了测试以查看它是否为null，是否为null。 

00:03:23.860 --> 00:03:26.070
然后我们去做各种事情，等等。 

00:03:26.070 --> 00:03:30.090
为了解决这个问题，我们引入了这个新类

00:03:30.090 --> 00:03:33.830
称为可选。并且Optional具有类型参数

00:03:33.830 --> 00:03:37.530
 T.实际上是什么可选

00:03:37.530 --> 00:03:40.960
是...它包含另一个

00:03:40.960 --> 00:03:44.120
对象引用和那个引用

00:03:44.120 --> 00:03:47.340
可以为null或可以指向实数

00:03:47.340 --> 00:03:50.510
宾语。所以你可以考虑一下

00:03:50.510 --> 00:03:54.110
就像流的其中一个为0 

00:03:54.110 --> 00:03:58.520
或其中的1个元素。 0个元素（如果引用对象为null） 

00:03:58.520 --> 00:04:01.940
如果对象是一个元素

00:04:01.940 --> 00:04:05.270
参考有效。将有1个元素

00:04:05.270 --> 00:04:10.000
在该流中将是对对象的引用。关于使用

00:04:10.000 --> 00:04:10.690
可选的

00:04:10.690 --> 00:04:14.350
是如果我们从最小或最大返回可选值， 

00:04:14.350 --> 00:04:18.170
或任何其他方法，我们知道这将是

00:04:18.170 --> 00:04:21.540
有效参考。因此，它不会为空。 

00:04:21.540 --> 00:04:25.600
因此我们无论如何都返回Optional。然后它包含的内容

00:04:25.600 --> 00:04:30.640
为null或有效的引用。 

00:04:30.640 --> 00:04:34.120
现在我们可以以不同的方式使用选项。所以这是

00:04:34.120 --> 00:04:37.550
我们将在普通Java代码中执行的操作

00:04:37.550 --> 00:04:40.800
如果我们要测试是否设置了某些东西

00:04:40.800 --> 00:04:44.690
如果是的话，我们想做点什么。所以我在说

00:04:44.690 --> 00:04:49.900
如果x不等于null，则打印x。好吧，我可以选择一个

00:04:49.900 --> 00:04:54.280
只需说出可选点（如果存在），然后通过

00:04:54.280 --> 00:04:59.230
一个lambda表达式来代表我想要做什么。所以在这里我要说

00:04:59.230 --> 00:05:02.700
我想打印x。我可以将其替换为方法参考。 

00:05:02.700 --> 00:05:05.850
或者我可以引用此方法-sorry-方法

00:05:05.850 --> 00:05:09.060
 print在这个对象中，只说this :: print。 

00:05:09.060 --> 00:05:13.090
同样的事情也是如此。好吧，那是

00:05:13.090 --> 00:05:17.150
这是Optional的一种用法。这并不令人兴奋， 

00:05:17.150 --> 00:05:20.300
但这可以消除我们的问题。 

00:05:20.300 --> 00:05:24.060
但我们可能还会遇到一种情况， 

00:05:24.060 --> 00:05:27.100
测试x是否有效， 

00:05:27.100 --> 00:05:31.700
而且x是否满足某些条件我在这里说的是

00:05:31.700 --> 00:05:35.270
如果x不等于null并且x包含一个

00:05:35.270 --> 00:05:38.490
然后我们要打印x。现在

00:05:38.490 --> 00:05:41.810
因为我们在那里有一个and语句，并且因为

00:05:41.810 --> 00:05:45.410
测试开始null是第一个，我们不必担心

00:05:45.410 --> 00:05:49.210
 nullPointerException因为如果x等于null 

00:05:49.210 --> 00:05:52.580
我们不必理会and语句的后半部分。 

00:05:52.580 --> 00:05:56.050
所以没关系。但是我们可以做同样的事情

00:05:56.050 --> 00:05:59.370
与我们的可选。现在我们可以使用过滤器。 

00:05:59.370 --> 00:06:02.370
再说一次，这与我们的想法相同

00:06:02.370 --> 00:06:06.550
与流。记住一个选项就像一个0流

00:06:06.550 --> 00:06:10.479
或1个元素。因此，在这种情况下，我们将采用Optional 

00:06:10.479 --> 00:06:14.090
然后我们将其传递给过滤器，然后使用

00:06:14.090 --> 00:06:17.880
predicate，代表数学的lambda表达式，说

00:06:17.880 --> 00:06:21.950
 “ x是否包含a？”。那样， 

00:06:21.950 --> 00:06:25.860
如果Optional包含空引用，则我们有一个

00:06:25.860 --> 00:06:26.630
 0个元素。 

00:06:26.630 --> 00:06:31.030
它不会被粘贴过滤。我们什么都不做。如果

00:06:31.030 --> 00:06:34.360
它确实包含无效的引用，我们暂停x进行过滤。 

00:06:34.360 --> 00:06:37.550
然后处理X，看它是否包含一个

00:06:37.550 --> 00:06:39.969
这将创建一个新的Optional， 

00:06:39.969 --> 00:06:44.079
要么包含空值（因为x不包含a），要么， 

00:06:44.079 --> 00:06:49.189
它包含x，因为它确实包含a。如果确实包含a， 

00:06:49.189 --> 00:06:53.619
我们将其传递给ifPresent并打印出来。所以我们有

00:06:53.619 --> 00:06:58.039
一种更简单的代码思考方式。我们可以走得更远。 

00:06:58.039 --> 00:07:01.489
我们可以使用地图进行翻译。 

00:07:01.489 --> 00:07:05.479
我们可能会遇到一种情况，我们需要测试x是否为

00:07:05.479 --> 00:07:08.909
不为空。如果不为null，我们将

00:07:08.909 --> 00:07:11.939
以某种方式操纵x。所以会做

00:07:11.939 --> 00:07:15.229
修剪x以删除任何空白

00:07:15.229 --> 00:07:20.829
字符并将其分配给t。然后，我们将测试t是否大于0。 

00:07:20.829 --> 00:07:21.909
我们将把它打印出来。 

00:07:21.909 --> 00:07:24.989
同样，我们可以使用Optional做同样的事情。 

00:07:24.989 --> 00:07:28.629
在这种情况下，我们将使用地图。 

00:07:28.629 --> 00:07:31.829
所以我们要在这里做的是说采取“可选”（如果有的话）， 

00:07:31.829 --> 00:07:35.279
作为参考。将其传递给地图。在这种情况下

00:07:35.279 --> 00:07:38.889
我们将使用的功能进行映射

00:07:38.889 --> 00:07:43.649
从字符串中修剪（再次引用方法）。然后我们通过

00:07:43.649 --> 00:07:47.069
过滤以确定长度

00:07:47.069 --> 00:07:50.379
的字符串大于0。这会产生一个新的

00:07:50.379 --> 00:07:53.629
可选，为null 

00:07:53.629 --> 00:07:56.759
或有效参考。取决于是否predicate

00:07:56.759 --> 00:08:00.699
返回true或false。所以如果我们返回一个

00:08:00.699 --> 00:08:04.719
有效的引用，我们将其放在Optional中。如果有的话我们去打印

00:08:04.719 --> 00:08:10.349
不管是什么然后我们可以走得更远。 

00:08:10.349 --> 00:08:13.639
所以说我有一个方法

00:08:13.639 --> 00:08:16.949
称为findSimilar的字符串

00:08:16.949 --> 00:08:21.729
作为参数并返回一个字符串。但潜在地findSimilar可能会返回

00:08:21.729 --> 00:08:22.409
空值。 

00:08:22.409 --> 00:08:26.769
因此，为了更好，我们将改变

00:08:26.769 --> 00:08:30.039
该方法，我们将其称为tryFindSimilar。 

00:08:30.039 --> 00:08:34.149
在此基础上，它将直接返回而不是直接返回字符串

00:08:34.149 --> 00:08:37.779
字符串类型的可选。记住可选

00:08:37.779 --> 00:08:40.899
将包含对任何tryFindSimilar的引用

00:08:40.899 --> 00:08:44.899
确实有。可以为null。 

00:08:44.899 --> 00:08:47.450
或者可以是实际的字符串。 

00:08:47.450 --> 00:08:50.430
因此，如果您想在Optional中使用它， 

00:08:50.430 --> 00:08:53.840
然后我们遇到了一个问题。因为如果我们想做一个to映射

00:08:53.840 --> 00:08:56.860
然后使用这种新方法

00:08:56.860 --> 00:09:01.310
地图将创建一个新的Optional 

00:09:01.310 --> 00:09:05.260
并把他用作

00:09:05.260 --> 00:09:10.550
可选参数。但是tryFindSimilar已经返回了Optional 

00:09:10.550 --> 00:09:13.550
所以现在我们有一个包含String类型的可选

00:09:13.550 --> 00:09:17.060
在可选。因此，这是太多可选项。 

00:09:17.060 --> 00:09:20.360
为了缓解这个问题

00:09:20.360 --> 00:09:23.450
我们可以使用flatMap。和flatMap 

00:09:23.450 --> 00:09:26.700
将假设我们正在使用的功能

00:09:26.700 --> 00:09:30.650
不需要放置Optional，因为它已经

00:09:30.650 --> 00:09:35.920
返回Optional。这样，我们只使用tryFindSimilar的结果

00:09:35.920 --> 00:09:39.280
这是String类型的Optional。然后我们可以使用

00:09:39.280 --> 00:09:42.440
直。我们不必担心成为可选的包含

00:09:42.440 --> 00:09:48.070
在另一个Optional中。如果我们回到我们的

00:09:48.070 --> 00:09:52.800
 GPS代码，我们也会更新为正确使用Optionals， 

00:09:52.800 --> 00:09:56.460
现在我们可以在GPSData类中看到

00:09:56.460 --> 00:09:59.730
我们的getPosition方法将返回Optional 

00:09:59.730 --> 00:10:02.740
位置类型。位置类

00:10:02.740 --> 00:10:06.190
将具有一个名为getLatitude的方法，该方法将返回Optional 

00:10:06.190 --> 00:10:09.300
的类型。然后是Latitude类

00:10:09.300 --> 00:10:12.360
只会有一个叫做getDirection的方法

00:10:12.360 --> 00:10:17.230
这将返回字符串。使用那个

00:10:17.230 --> 00:10:21.280
我们现在要做的是说方向将是

00:10:21.280 --> 00:10:25.140
可选，我们首先必须创建一个可选

00:10:25.140 --> 00:10:28.740
从GPS数据中

00:10:28.740 --> 00:10:32.380
我们使用ofNullable表示

00:10:32.380 --> 00:10:36.230
 GPSData可以为null，也可以为有效参考。 

00:10:36.230 --> 00:10:39.560
如果我们知道GPS数据是有效参考

00:10:39.560 --> 00:10:43.520
我们可以只使用可选的点。但是因为我们不知道

00:10:43.520 --> 00:10:46.750
无论它是否为null，我们都使用Optional点ofNullable。 

00:10:46.750 --> 00:10:50.510
这样，您就不会有任何问题。 

00:10:50.510 --> 00:10:53.320
我们将其传递给flatMap。 

00:10:53.320 --> 00:10:57.000
与flatMap一起使用的功能

00:10:57.000 --> 00:11:00.830
这是获取位置的方法参考，我们再次将其平面映射

00:11:00.830 --> 00:11:05.570
从那个位置获得自由度。请记住，getPosition和

00:11:05.570 --> 00:11:06.459
 getLatitude 

00:11:06.459 --> 00:11:10.120
返回一个可选的。所以我们不想包括那些

00:11:10.120 --> 00:11:13.850
在另一个Optional中。我们只是想把它带到下一个

00:11:13.850 --> 00:11:17.500
方法调用链的一部分。所以我们使用flatMap 

00:11:17.500 --> 00:11:21.170
这样我们知道getPosition和getLatitude将返回可选的。 

00:11:21.170 --> 00:11:24.420
然后我们将其传递给地图。 

00:11:24.420 --> 00:11:27.810
地图使用Latitude的getDirection方法， 

00:11:27.810 --> 00:11:31.050
确实返回sSring，所以我们需要

00:11:31.050 --> 00:11:35.589
将其放在Optional中。因此地图将采用getDirection的结果， 

00:11:35.589 --> 00:11:39.380
将其放在字符串中，并放入一些Optional中， 

00:11:39.380 --> 00:11:42.700
然后将其传递给orElse。因此，如果

00:11:42.700 --> 00:11:46.410
 getDirection返回null 

00:11:46.410 --> 00:11:49.800
则orElse将返回无。 

00:11:49.800 --> 00:11:53.160
否则我们会得到

00:11:53.160 --> 00:11:56.959
我们从GPS读取的特定纬度。 

00:11:56.959 --> 00:12:00.450
如果getDirection返回null，则返回None。除此以外

00:12:00.450 --> 00:12:05.000
返回实际方向。这就解决了我们的问题。 

00:12:05.000 --> 00:12:10.100
所以总结一下第7节：您可以看到Optional类可以帮助我们消除

00:12:10.100 --> 00:12:13.680
 nullPointerExceptions问题。我们可以在

00:12:13.680 --> 00:12:17.640
如果您想使用flatMaps地图和

00:12:17.640 --> 00:12:18.550
过滤器和

00:12:18.550 --> 00:12:22.520
和类似的事情，以便让您

00:12:22.520 --> 00:12:25.540
流的结果可选， 

00:12:25.540 --> 00:12:28.680
然后处理它

00:12:28.680 --> 00:12:33.220
并用它做事。因此，这不仅是及时流媒体，而且是非常有用的事情

00:12:33.220 --> 00:12:34.140
但是也

00:12:34.140 --> 00:12:40.070
外流也是如此。这使我们到了第二课的结尾

00:12:40.070 --> 00:12:43.610
再说一遍，我想简要介绍一下

00:12:43.610 --> 00:12:47.120
第二课中我们处理的内容

00:12:47.120 --> 00:12:50.600
意识到。 

00:12:50.600 --> 00:12:53.380
因此，流API为我们提供了

00:12:53.380 --> 00:12:57.870
具有一种简单易懂的函数式风格

00:12:57.870 --> 00:13:01.540
用Java编程。记住函数式编程

00:13:01.540 --> 00:13:04.709
关于将函数调用链接在一起。 

00:13:04.709 --> 00:13:09.180
流API允许我们将方法调用链接在一起

00:13:09.180 --> 00:13:12.459
这样我们就可以有效地用Java做同样的事情。 

00:13:12.459 --> 00:13:16.240
就我们创建的流而言

00:13:16.240 --> 00:13:19.240
我们可以创建流对象

00:13:19.240 --> 00:13:23.740
或者在适当的地方我们可以创建流原始类型： 

00:13:23.740 --> 00:13:27.540
 int, long, double。这样我们可以避免问题

00:13:27.540 --> 00:13:30.790
装箱与拆箱如何提高效率

00:13:30.790 --> 00:13:34.610
该流有效。上游结构

00:13:34.610 --> 00:13:38.350
就像一条管道。您获得源代码的管道的一端

00:13:38.350 --> 00:13:41.910
您在中间进行了一些可能的中间操作， 

00:13:41.910 --> 00:13:45.470
然后管道的另一端是终端操作

00:13:45.470 --> 00:13:49.620
这会产生明显的结果或某种副作用。 

00:13:49.620 --> 00:13:52.959
很多终端操作

00:13:52.959 --> 00:13:57.500
返回一个Optional，所以如果我们在InputStream上没有任何数据

00:13:57.500 --> 00:14:01.620
我们不必担心空指针引用，我们可以注意

00:14:01.620 --> 00:14:02.470
通过

00:14:02.470 --> 00:14:06.700
适当使用所有Optional。记住ofOptionals可以使用

00:14:06.700 --> 00:14:10.130
用于许多不同情况的外部流API 

00:14:10.130 --> 00:14:15.209
您想避免空指针异常的地方。 

00:14:15.209 --> 00:14:17.110
至此，第二课结束了。 

