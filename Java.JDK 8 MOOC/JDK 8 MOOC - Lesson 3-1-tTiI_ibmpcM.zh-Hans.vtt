WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.919 --> 00:00:03.450
 [音乐] 

00:00:13.849 --> 00:00:15.410
您好，欢迎来到

00:00:15.410 --> 00:00:18.779
大规模在线公开课程的第3课

00:00:18.779 --> 00:00:23.160
在Lambda和流JDK 8上。 

00:00:23.160 --> 00:00:26.720
我们将围绕Lambda研究一些更高级的概念

00:00:26.720 --> 00:00:28.240
表达式和流API。 

00:00:28.240 --> 00:00:32.360
我叫Simon Ritter，我是Java技术的传播者

00:00:32.360 --> 00:00:35.780
就议程而言

00:00:35.780 --> 00:00:40.050
在本节课中，我们将从

00:00:40.050 --> 00:00:43.380
减少，因为减少

00:00:43.380 --> 00:00:46.489
是从一组结果创建结果的方法

00:00:46.489 --> 00:00:50.660
数据是流，我们需要了解

00:00:50.660 --> 00:00:53.870
如何正确使用那些以得到那种

00:00:53.880 --> 00:00:57.580
我们正在寻找的结果，尤其是当我们尝试采用函数

00:00:57.580 --> 00:00:58.171
方法。 

00:00:58.171 --> 00:01:01.880
作为Java程序员，这是其中的一件事， 

00:01:01.880 --> 00:01:04.890
我们需要有所不同，所以我们将对此进行讨论。 

00:01:04.890 --> 00:01:08.590
然后，我们将讨论有限和

00:01:08.600 --> 00:01:13.500
无限流，因为再次，作为Java程序员，我们倾向于思考

00:01:13.500 --> 00:01:14.249
循环

00:01:14.249 --> 00:01:17.740
当我们必须处理无限流时

00:01:17.740 --> 00:01:20.741
倾向于思考，我们如何突围

00:01:20.760 --> 00:01:24.140
实际上，我们并没有真正摆脱这种情况， 

00:01:24.140 --> 00:01:28.160
但我们可以终止无限流。所以我们将讨论差异

00:01:28.160 --> 00:01:31.579
以及两种类型的信息流以及您可以采用的方法。 

00:01:31.579 --> 00:01:36.411
然后，我们看一下您应该在哪里使用forEach方法， 

00:01:36.411 --> 00:01:40.579
而且您不应该使用forEach方法。有一些

00:01:40.579 --> 00:01:43.751
您可以使用该特定方法的非常有效的地方， 

00:01:43.760 --> 00:01:47.690
但是在很多地方您都可以陷入

00:01:47.690 --> 00:01:50.899
还在思考的陷阱，因为它

00:01:50.899 --> 00:01:54.650
仍然在思考循环，就像您在Java和

00:01:54.650 --> 00:01:57.681
然后尝试通过思考来应用，我将使用forEach 

00:01:57.681 --> 00:02:03.670
为此，并且没有正确执行。我们将研究一些可以避免这种情况的事情。 

00:02:03.680 --> 00:02:06.690
我们将谈论collectors，这是一个很大的话题， 

00:02:06.690 --> 00:02:10.280
因此，我在此上创建了特别的部分。所以我们可以看看不同种类的

00:02:10.280 --> 00:02:11.430
collectors

00:02:11.440 --> 00:02:14.880
您可以采用不同的方法来收集数据，并且

00:02:14.880 --> 00:02:19.620
从结果中形成一个集合。我们将要看

00:02:19.620 --> 00:02:23.680
并行流，因为这是伟大的之一

00:02:23.680 --> 00:02:28.650
使用流API的优势在于您可以从

00:02:28.650 --> 00:02:32.060
从顺序处理到并行处理

00:02:32.060 --> 00:02:35.469
无需更改您的代码实际工作方式。 

00:02:35.480 --> 00:02:40.121
但是您可能会陷入的陷阱是： 

00:02:40.121 --> 00:02:43.130
嗯，嗯，我总是可以使用并行流， 

00:02:43.130 --> 00:02:46.390
总是会更快地做事。但这不是

00:02:46.400 --> 00:02:50.960
必然是这样，所以我们需要了解您应该在哪里使用并行

00:02:50.960 --> 00:02:53.120
流以及实际上效率较低的地方

00:02:53.120 --> 00:02:58.140
使用并行流而不是顺序流。好

00:02:58.140 --> 00:03:02.459
看一下如何调试流和Lambda，因为

00:03:02.459 --> 00:03:07.481
关于流API的一件事是，它的确掩盖了很多工作

00:03:07.481 --> 00:03:07.800
您。 

00:03:07.800 --> 00:03:12.790
因此，它使代码看起来非常简单，但是当您要开始研究如何

00:03:12.800 --> 00:03:15.780
分析有时需要使用的代码实际发生的情况

00:03:15.780 --> 00:03:17.210
一些略有不同的方法

00:03:17.210 --> 00:03:21.140
所以我们来看一下。因为这是最后一课

00:03:21.140 --> 00:03:25.320
在课程中，我们将总结所有的结论

00:03:25.320 --> 00:03:29.550
关于事物和流API的整个Lambdas方面

00:03:29.550 --> 00:03:33.670
以及在学习如何使用它们方面下一步可以做什么。 

00:03:33.680 --> 00:03:37.510
开始吧

00:03:37.520 --> 00:03:41.149
与第1节：了解和使用

00:03:41.149 --> 00:03:44.491
减少。 

00:03:44.491 --> 00:03:47.500
我们首先要解决一个简单的问题

00:03:47.520 --> 00:03:51.080
这是我们用于培训课程的

00:03:51.080 --> 00:03:54.910
当它们初次出现时，我们在Lambda和stream上提供的

00:03:54.910 --> 00:03:58.510
问题是，如何找到长度

00:03:58.510 --> 00:04:01.840
文件中最长行的长度。这是解决方案

00:04:01.840 --> 00:04:06.090
我们提供了。您首先要找到该路径

00:04:06.090 --> 00:04:09.570
您要从中读取文本行的文件。 

00:04:09.600 --> 00:04:12.630
然后用那个

00:04:12.640 --> 00:04:16.550
您可以在Files类上使用静态方法， 

00:04:16.560 --> 00:04:19.610
我们在第2课中看到了

00:04:19.610 --> 00:04:22.760
这允许我们做的是提取

00:04:22.760 --> 00:04:27.340
文件中的文本，并将其作为流提供。 

00:04:27.360 --> 00:04:30.710
所以我们的输出流，我们的流源是一组

00:04:30.720 --> 00:04:35.480
从文件中读取的文本行。我们通过了

00:04:35.480 --> 00:04:38.820
到mapToInt，这将创建一个

00:04:38.820 --> 00:04:43.030
在这里使用Lambda表达式的整数值流， 

00:04:43.040 --> 00:04:46.760
这是方法参考，只是说给我们

00:04:46.760 --> 00:04:49.990
输入流中每个字符串的长度。 

00:04:50.000 --> 00:04:53.830
我们将其传递给max 

00:04:53.840 --> 00:04:58.270
然后显然会将其减小为单个值，这是最大的

00:04:58.270 --> 00:05:01.730
输入流中的整数。长度

00:05:01.730 --> 00:05:06.790
文件中最长行的长度。由于那将返回一个

00:05:06.790 --> 00:05:07.060
可选的， 

00:05:07.060 --> 00:05:10.630
因为我们的文件中可能没有任何行，所以我们

00:05:10.630 --> 00:05:13.880
使用getAsInt提取结果。所以我们假设

00:05:13.880 --> 00:05:17.130
那里有一些数据，我们将得到一个整数值

00:05:17.130 --> 00:05:20.590
这样就解决了问题。这样你就可以看到

00:05:20.590 --> 00:05:23.950
这非常简单，不需要很多代码

00:05:23.950 --> 00:05:29.620
并且具有非常实用的方法

00:05:30.020 --> 00:05:33.840
然后有人对我说，很好，但是我们如何改变问题

00:05:33.840 --> 00:05:34.370
略。 

00:05:34.370 --> 00:05:38.089
如果我们说而不是找到最长的长度怎么办

00:05:38.089 --> 00:05:41.800
文件中的行如果要在

00:05:41.800 --> 00:05:45.820
文件，这是一个非常明智的问题。 

00:05:45.840 --> 00:05:49.250
所以，我不得不考虑这一点，然后我想， 

00:05:49.280 --> 00:05:52.981
我们如何处理这个问题以获得结果？ 

00:05:52.981 --> 00:05:56.139
问题确实是因为作为Java程序员

00:05:56.160 --> 00:06:00.201
我倾向于以循环的方式思考，而倾向于以状态的方式思考。 

00:06:00.240 --> 00:06:04.810
所以我想我自己需要记录我最长的记录

00:06:04.810 --> 00:06:06.610
到目前为止从文件中读取

00:06:06.640 --> 00:06:10.279
然后使用它，直到我阅读了文件中的所有行。 

00:06:10.279 --> 00:06:14.201
但是我做不到，所以我需要一种实用的方法。 

00:06:14.240 --> 00:06:18.649
这就是我所说的天真

00:06:18.649 --> 00:06:22.200
流解决方案。我们在这里做什么

00:06:22.200 --> 00:06:25.670
再次创建输入流

00:06:25.680 --> 00:06:29.150
从文件中读取的行。但是这次

00:06:29.150 --> 00:06:32.490
因为我们正在寻找我认为可以的文件中的最长行， 

00:06:32.490 --> 00:06:35.661
让我们对所有行进行排序

00:06:35.680 --> 00:06:39.620
在文件中按长度排列。我们使用一个简单的Lambda表达式

00:06:39.620 --> 00:06:43.789
代表比较器，所以x和y是字符串

00:06:43.789 --> 00:06:47.420
我们只是返回之间的长度差

00:06:47.440 --> 00:06:50.611
 x和y。通过这种方式，我们可以基于

00:06:50.640 --> 00:06:54.860
最长的行将是排序列表中的第一行。 

00:06:54.880 --> 00:06:59.089
然后我们可以将其传递给findFirst 

00:06:59.120 --> 00:07:02.471
这将简单地返回第一个元素

00:07:02.480 --> 00:07:05.749
输入流的长度，它将是文件中的最长行。 

00:07:05.760 --> 00:07:10.030
再说一次，因为这返回了Optional，我们使用get 

00:07:10.030 --> 00:07:15.751
从中提取值并将其作为字符串返回。 

00:07:15.760 --> 00:07:18.100
很好，所以我们已经解决了这个问题， 

00:07:18.100 --> 00:07:21.550
我们使用了函数性方法

00:07:21.550 --> 00:07:26.970
我们已经解决了这个问题。没有国家维持一切都很好。好， 

00:07:26.970 --> 00:07:30.710
是的，不是真的。问题是通过排序

00:07:30.720 --> 00:07:34.250
如果文件很大，文件中的所有行

00:07:34.250 --> 00:07:37.930
那么这将需要很长时间，并且将需要大量资源， 

00:07:37.930 --> 00:07:40.970
因为这样做的开销会相当大

00:07:40.970 --> 00:07:41.830
实质性的。 

00:07:41.840 --> 00:07:46.670
我认为必须有一种更好的方法；一种

00:07:46.670 --> 00:07:50.270
更好的函数方法，让我们看看我们如何找到它。 

00:07:50.270 --> 00:07:54.320
我做的第一件事是回去说，好的， 

00:07:54.320 --> 00:07:58.440
如果我只是要使用Java，我该如何解决

00:07:58.440 --> 00:08:02.960
没有函数？这是我们将要使用的方法。 

00:08:02.960 --> 00:08:06.460
我们有一个叫做longest的变量

00:08:06.480 --> 00:08:11.360
初始化为空字符串。然后我们反复读取文件中的行

00:08:11.360 --> 00:08:14.580
使用while循环，直到没有更多的行

00:08:14.580 --> 00:08:18.460
读书。从文件中读取的每一行， 

00:08:18.480 --> 00:08:22.790
比较该字符串的长度为

00:08:22.800 --> 00:08:26.160
我们目前的最长线，如果更长

00:08:26.160 --> 00:08:29.620
然后我们简单地记录下来。在末尾

00:08:29.620 --> 00:08:34.220
我们将在文件中保留最长的行。当你看着那个

00:08:34.240 --> 00:08:38.320
您认为，那是四行代码，非常棒，一个非常简单的解决方案。 

00:08:38.320 --> 00:08:41.460
为什么需要函数性方法？答案是

00:08:41.460 --> 00:08:45.170
是的，它很简单，但是它本质上是串行的。 

00:08:45.200 --> 00:08:48.370
这可以回到第一课的开始

00:08:48.400 --> 00:08:52.030
当我们谈论为什么需要Lambda表达式时，因为我们需要一个

00:08:52.030 --> 00:08:52.890
更简单的方法

00:08:52.890 --> 00:08:58.100
 Java中进行函数式编程的概念。问题是

00:08:58.100 --> 00:09:01.450
这是连续的。是的，我们正在从文件中读取行， 

00:09:01.450 --> 00:09:05.200
我们在列表中有大量数据，即ArrayList 

00:09:05.200 --> 00:09:09.200
那么我们可能希望并行处理它以提高效率，但是

00:09:09.200 --> 00:09:12.250
我们无法在代码中使用这种方法来做到这一点。 

00:09:12.250 --> 00:09:15.370
同样，因为我们有一个变量

00:09:15.370 --> 00:09:18.500
我们现在不再线程安全；我们变了

00:09:18.500 --> 00:09:21.980
州。所以我们需要一种不同的方法

00:09:22.000 --> 00:09:28.330
一种实用的方法，但没有做类似的事情。 

00:09:28.330 --> 00:09:29.580
再说一次，如果你还记得

00:09:29.600 --> 00:09:32.979
第2课的开始，我们讨论了函数之间的差异

00:09:32.979 --> 00:09:34.981
编程和命令式编程

00:09:34.981 --> 00:09:38.629
以及函数式编程的方式

00:09:38.640 --> 00:09:43.211
处理重复操作不是通过使用显式循环。 

00:09:43.211 --> 00:09:48.080
我们使用函数式编程的方式是反复调用

00:09:48.080 --> 00:09:51.300
函数对其他函数传递的结果。 

00:09:51.300 --> 00:09:54.789
因此，它更像是一种递归方法。 

00:09:55.760 --> 00:09:59.491
我们可以在代码方面使用该方法。什么

00:09:59.520 --> 00:10:03.880
我到这里是一种将递归的方法

00:10:03.880 --> 00:10:09.120
解决了找到最长字符串的问题。想法是我们传递一个

00:10:09.120 --> 00:10:12.859
字符串，这是我们当前拥有的最长字符串， 

00:10:12.880 --> 00:10:17.101
我们将索引传递给字符串列表，所以我们知道在什么时候

00:10:17.120 --> 00:10:20.469
我们在搜索方面，然后传递列表。 

00:10:20.480 --> 00:10:24.321
递归方法会分解事物，所以我们采取

00:10:24.321 --> 00:10:27.430
列表中的第一个字符串

00:10:27.440 --> 00:10:30.479
根据索引的位置，我们将其与

00:10:30.480 --> 00:10:33.521
列表其余部分中最长的字符串。 

00:10:33.521 --> 00:10:39.979
这将递归调用该方法，我们可以解决问题。如果你

00:10:40.000 --> 00:10:41.371
想用那个

00:10:41.371 --> 00:10:45.910
直接从文件中进行操作会有些棘手；我们可能

00:10:45.920 --> 00:10:49.080
使用内存映射来做到这一点，但这会涉及到很多。 

00:10:49.080 --> 00:10:53.130
一种更简单的方法是将所有行读入ArrayList 

00:10:53.130 --> 00:10:56.260
然后用它作为我们的

00:10:56.260 --> 00:11:00.140
列表，我们将其传递给我们的方法。我们从一个空字符串开始， 

00:11:00.160 --> 00:11:03.310
从列表中的位置0开始，然后

00:11:03.310 --> 00:11:06.360
该方法将被递归调用，我们将发现

00:11:06.360 --> 00:11:09.699
最长的字符串。很好

00:11:09.699 --> 00:11:13.511
这样就没有显式循环，我们没有可变状态， 

00:11:13.520 --> 00:11:17.379
所以我们有一个函数解决方案。理论上， 

00:11:17.379 --> 00:11:21.922
好吧，不幸的是，这并不是一个真正可用的问题

00:11:21.922 --> 00:11:25.147
因为如果我们首先拥有大量数据， 

00:11:25.147 --> 00:11:29.180
将从文件中读取所有数据

00:11:29.200 --> 00:11:32.270
一个ArrayList，所以我们需要确保拥有尽可能多的内存

00:11:32.270 --> 00:11:33.721
文件大小。 

00:11:33.760 --> 00:11:37.450
但是接下来我们还要创建一个新的堆栈框架

00:11:37.450 --> 00:11:41.250
文件中的每一行。我们将递归调用

00:11:41.280 --> 00:11:46.070
为每一行生成新的堆栈框架。如果我们有一个

00:11:46.080 --> 00:11:49.490
任何大小的文件都会生成OutOfMemoryException。 

00:11:49.520 --> 00:11:52.930
在实际处理所有内容之前，我们将耗尽内存。 

00:11:52.960 --> 00:11:57.900
让我们回到流API， 

00:11:57.920 --> 00:12:01.010
这确实是我们正在尝试做的。我们正在尝试找出使用方法

00:12:01.040 --> 00:12:04.620
流API解决此问题，并且

00:12:04.640 --> 00:12:08.530
如果您看一下流API，我们倾向于使用这种众所周知的模式

00:12:08.560 --> 00:12:13.830
过滤，映射，减少。在这种特殊情况下

00:12:13.840 --> 00:12:17.500
我们不需要进行任何过滤，因为我们正在寻找最长的过滤器

00:12:17.500 --> 00:12:18.150
线

00:12:18.160 --> 00:12:21.360
在文件中，因此我们不尝试

00:12:21.360 --> 00:12:25.130
根据我们不试图消除任何数据的观点来减少这种情况

00:12:25.130 --> 00:12:28.640
创建子集。我们也不需要使用地图， 

00:12:28.640 --> 00:12:32.390
因为我们不尝试从任何东西转换，我们只是对

00:12:32.400 --> 00:12:37.230
每条线，以最长的一条为准。所以我们对这里感兴趣

00:12:37.230 --> 00:12:41.050
是减少和

00:12:41.050 --> 00:12:45.200
如果我们回想起reduce方法的实际定义， 

00:12:45.200 --> 00:12:48.260
在课程的早期，我们将看到

00:12:48.260 --> 00:12:51.330
 reduce方法需要累加器

00:12:51.360 --> 00:12:54.550
作为参数，累加器是

00:12:54.560 --> 00:12:58.370
一个二元运算符，再一次，当我们谈到

00:12:58.400 --> 00:13:01.580
包含在

00:13:01.600 --> 00:13:04.900
 java.util.function软件包，BinaryOperator 

00:13:04.900 --> 00:13:08.390
实际上是BiFunction，其中

00:13:08.400 --> 00:13:12.760
您有两个输入和一个输出，其中所有类型

00:13:12.760 --> 00:13:16.240
是相同的，所以我们将接受两个输入

00:13:16.240 --> 00:13:19.540
并生成相同类型的输出。的

00:13:19.540 --> 00:13:24.990
 final reduce的输出是可选的。 

00:13:24.990 --> 00:13:28.350
我们需要做的就是解决这个问题

00:13:28.350 --> 00:13:32.390
正确的蓄能器，所以我们需要确定什么是正确的

00:13:32.400 --> 00:13:35.850
 BinaryOperator，我们接受两个输入并生成一个

00:13:35.850 --> 00:13:41.430
输出以解决问题。再说一次，如果我们回到看减少

00:13:41.440 --> 00:13:45.040
我们发现的方法定义是

00:13:45.040 --> 00:13:49.540
累加器被描述为需要部分结果的东西

00:13:49.540 --> 00:13:53.290
和下一个元素，并返回新的部分结果。 

00:13:53.290 --> 00:13:58.370
实际上，它的作用与递归解决方案相同。 

00:13:58.400 --> 00:14:01.420
所以说要

00:14:01.440 --> 00:14:05.020
流的第一个元素，并与之进行比较

00:14:05.040 --> 00:14:08.950
并确定哪一条是最长的。 

00:14:08.960 --> 00:14:12.470
显然这是第一个，然后我们将与其余的进行比较。 

00:14:12.480 --> 00:14:16.300
因此，我们再次应用该函数， 

00:14:16.320 --> 00:14:19.400
我们说要接受下一个元素并进行比较

00:14:19.400 --> 00:14:23.050
相对于我们的部分结果，这是我们到目前为止找到的最长的线。 

00:14:23.050 --> 00:14:28.430
我们可以多次有效地应用这种减少操作，或者

00:14:28.430 --> 00:14:31.780
每行多次执行累加器操作。 

00:14:31.780 --> 00:14:35.340
我们正在针对

00:14:35.360 --> 00:14:40.620
输入流中的下一个字符串。我们没有全部

00:14:40.640 --> 00:14:44.210
堆栈帧，因为在内部这不是通过

00:14:44.240 --> 00:14:47.540
实际的递归，所以我们不必担心

00:14:47.540 --> 00:14:51.490
对性能的影响。我们最终得到了什么

00:14:51.520 --> 00:14:55.980
是解决方案。相同的想法，我们在排队

00:14:56.000 --> 00:14:59.490
从文件读取，这次我们将其传递给

00:14:59.520 --> 00:15:03.480
减少方法。这是终端操作，所以

00:15:03.480 --> 00:15:07.030
不会返回其他流，并且

00:15:07.040 --> 00:15:10.570
我们将要使用的函数

00:15:10.570 --> 00:15:13.630
接受两个输入：x和y 

00:15:13.630 --> 00:15:17.180
是字符串，然后比较这些字符串的长度和

00:15:17.200 --> 00:15:22.350
返回最长的那个。这里的关键

00:15:22.350 --> 00:15:25.770
是X，因为在这种情况下

00:15:25.770 --> 00:15:30.120
 X有效地维持着我们的状态

00:15:30.120 --> 00:15:34.210
但始终保留到目前为止我们发现的最长的字符串。 

00:15:34.240 --> 00:15:36.460
这是我们的部分结果。 

00:15:36.480 --> 00:15:40.110
因此，当我们读取输入流上的元素时， 

00:15:40.110 --> 00:15:44.900
 X总是代表我们到目前为止找到的最长的字符串

00:15:44.900 --> 00:15:48.340
在输入流中，y将是

00:15:48.340 --> 00:15:51.520
输入流中的下一个元素。所以我们只是比较

00:15:51.520 --> 00:15:54.750
到目前为止，我们发现的时间最长

00:15:54.750 --> 00:15:59.030
下一个元素并确定新的部分结果是否

00:15:59.040 --> 00:16:02.150
是当前的还是

00:16:02.160 --> 00:16:06.180
我们刚刚读取的字符串。现在

00:16:06.180 --> 00:16:10.300
我向团队中的工程师展示了这一点，他说，是的，非常好， 

00:16:10.320 --> 00:16:14.660
但实际上有一个更简单的解决方案，因为您可以使用

00:16:14.660 --> 00:16:18.520
最高请记住，max只是一种特殊形式

00:16:18.520 --> 00:16:22.110
过度减少，但我们还有另一种形式的max 

00:16:22.110 --> 00:16:25.170
您可以在其中传递比较器作为参数。 

00:16:25.200 --> 00:16:29.000
我们最终得到了简单的解决方案，我们可以简单地说

00:16:29.000 --> 00:16:32.470
将文件中的行作为流源

00:16:32.480 --> 00:16:35.800
并将其传递给使用

00:16:35.800 --> 00:16:39.060
一个函数，在这种情况下是ToIntFunction 

00:16:39.060 --> 00:16:42.310
这样会生成整数作为结果

00:16:42.320 --> 00:16:46.570
根据我们在这种情况下想要做的

00:16:46.570 --> 00:16:49.590
使用字符串的长度。所以ComparingInt是一个

00:16:49.600 --> 00:16:54.520
比较器上的静态方法，我们可以简单地将字符串转换为长度

00:16:54.520 --> 00:16:57.870
然后我们将比较字符串

00:16:57.870 --> 00:17:01.140
根据长度返回最大的那些。 

00:17:01.140 --> 00:17:04.220
然后再次返回一个Optional，所以

00:17:04.240 --> 00:17:07.639
我们可以从中得到结果。但是重要的是

00:17:07.639 --> 00:17:11.791
是要了解我们正在做的是

00:17:11.791 --> 00:17:14.880
使用减少。顺流而下

00:17:14.880 --> 00:17:19.150
将其减少为单个值，然后

00:17:19.150 --> 00:17:22.929
定义减少工作的方式

00:17:22.960 --> 00:17:26.051
由累加器。蓄能器

00:17:26.080 --> 00:17:29.800
是BinaryOperator，所以它需要两个输入

00:17:29.800 --> 00:17:33.430
并返回所有相同类型的输出。 

00:17:33.440 --> 00:17:37.070
然后将累加器依次应用于流元素， 

00:17:37.070 --> 00:17:40.070
所以它给我们有效的递归

00:17:40.080 --> 00:17:44.700
我们过去看到的操作。减少方法

00:17:44.720 --> 00:17:48.440
保持部分结果为状态， 

00:17:48.440 --> 00:17:52.130
但是我们没有明确看到它，因此我们不必担心。 

00:17:52.160 --> 00:17:56.860
从本节课中摘取的重要内容是

00:17:56.880 --> 00:18:00.820
需要换个角度思考。您需要停止思考循环， 

00:18:00.820 --> 00:18:04.330
显式循环，您需要停止对显式循环的思考

00:18:04.330 --> 00:18:07.600
陈述并转向

00:18:07.600 --> 00:18:11.000
将方法调用链接在一起， 

00:18:11.000 --> 00:18:15.410
实际上，我们可以实现递归处理，以便为您提供

00:18:15.440 --> 00:18:18.560
的方法

00:18:18.560 --> 00:18:23.780
您如何重复处理数据。到此为止

00:18:23.780 --> 00:18:25.600
本节第1部分的内容。 

