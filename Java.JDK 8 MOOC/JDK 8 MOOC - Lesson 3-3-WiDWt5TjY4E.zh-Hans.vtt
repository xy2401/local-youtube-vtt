WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.750 --> 00:00:03.290
 [音乐] 

00:00:13.290 --> 00:00:15.540
您好，欢迎来到第3节

00:00:15.540 --> 00:00:17.140
第三课

00:00:17.140 --> 00:00:20.250
在这一部分中，我们将讨论如何避免， 

00:00:20.250 --> 00:00:23.560
尽可能使用forEach方法。 

00:00:23.560 --> 00:00:26.900
现在

00:00:26.900 --> 00:00:30.840
我们面临的问题是，作为Java程序员， 

00:00:30.840 --> 00:00:35.300
我们必须思考。这意味着我们倾向于思考

00:00:35.300 --> 00:00:39.900
就重复行为的循环而言。那就是我们过去的习惯： 

00:00:39.900 --> 00:00:41.350
 while循环，我们使用for循环， 

00:00:41.350 --> 00:00:45.090
等等。我们也很习惯使用变量

00:00:45.090 --> 00:00:49.260
保持状态。这就是我们习惯的事情

00:00:49.260 --> 00:00:54.020
但问题是有时我们可以尝试仍然应用此行为

00:00:54.020 --> 00:00:58.340
使用流时，因为有些事情我们可以做， 

00:00:58.340 --> 00:01:01.770
使我们能够使用这种方法，但是

00:01:01.770 --> 00:01:05.820
不是正确的做事方式。这是错误的，我们需要避免

00:01:05.820 --> 00:01:10.610
为了正确使用流。让我们

00:01:10.610 --> 00:01:14.580
看一个例子，然后我写了一些代码，我仍然

00:01:14.580 --> 00:01:18.080
认真思考。我还在想

00:01:18.080 --> 00:01:21.409
我以前会写Java。我有的

00:01:21.409 --> 00:01:24.790
是交易的集合，并且

00:01:24.790 --> 00:01:27.970
从那我想把所有的值加起来

00:01:27.970 --> 00:01:32.540
这些交易并创建总计。要做到这一点

00:01:32.540 --> 00:01:36.260
我以为我会使用forEach方法

00:01:36.260 --> 00:01:40.869
因为我要收集交易记录，所以创建一个流源

00:01:40.869 --> 00:01:44.979
然后对于每个要获取的值

00:01:44.979 --> 00:01:49.360
并将其添加到我的总数中要做到这一点

00:01:49.360 --> 00:01:52.720
我以为很聪明，我将使用此LongAdder类， 

00:01:52.720 --> 00:01:56.260
这是JDK 8中的新增函数，旨在

00:01:56.260 --> 00:02:00.430
用于流。它还设计用于多线程

00:02:00.430 --> 00:02:04.840
正在执行以更新值。它是设计的

00:02:04.840 --> 00:02:09.530
用于频繁更新和不频繁读取。 

00:02:09.530 --> 00:02:13.240
那么，我在这里使用的是Lambda表达式

00:02:13.240 --> 00:02:16.330
添加的当前值

00:02:16.330 --> 00:02:21.220
交易总额。这是有问题的，因为当

00:02:21.220 --> 00:02:22.790
修改状态

00:02:22.790 --> 00:02:26.200
用函数方法做事是错误的方法。 

00:02:26.200 --> 00:02:29.900
然后我们有

00:02:29.900 --> 00:02:33.900
总和。如果您想采取正确的函数方法

00:02:33.900 --> 00:02:37.020
那么我们需要做这种事情。 

00:02:37.020 --> 00:02:40.450
我们接受交易收集

00:02:40.450 --> 00:02:44.640
然后我们从中生成流源。然后我们解析

00:02:44.640 --> 00:02:48.190
来mapToLong。 mapToLong 

00:02:48.190 --> 00:02:51.570
使用Lambda表达式，在这种情况下

00:02:51.570 --> 00:02:54.580
将转换交易

00:02:54.580 --> 00:02:57.739
输入流上的对象变成一个long值， 

00:02:57.739 --> 00:03:01.080
这是交易的价值。所以我们

00:03:01.080 --> 00:03:06.459
输出流将是长值流。我们通过了总结

00:03:06.459 --> 00:03:11.500
总和实际上是减少，将产生一个单一结果，即

00:03:11.500 --> 00:03:12.180
总

00:03:12.180 --> 00:03:16.440
我们集合中的所有交易。这个

00:03:16.440 --> 00:03:20.450
是一种实用的方法。我们不修改状态，甚至不尝试

00:03:20.450 --> 00:03:23.730
对它应用命令式的编码样式

00:03:23.730 --> 00:03:29.000
或创建显式循环。有

00:03:29.000 --> 00:03:32.549
每个地方都可以使用的合法场所。我们最后看到了

00:03:32.549 --> 00:03:36.360
本课的一部分，我们讨论无限流。但

00:03:36.360 --> 00:03:40.570
如果我们想做这样的事情；我们想接受我们的交易

00:03:40.570 --> 00:03:43.700
在这种情况下，我们要打印出所有客户端的行。 

00:03:43.700 --> 00:03:47.420
这是对forEach的完全合法使用。我们把我们的

00:03:47.420 --> 00:03:50.840
流源，将每个元素传递给forEach和

00:03:50.840 --> 00:03:54.900
我们通过打印客户端名称来使用它。 

00:03:54.900 --> 00:03:58.360
我们可以根据需要进行并行处理，因此可以创建并行流， 

00:03:58.360 --> 00:04:03.240
但是显然，在那种情况下，我们不会为订单感到担心。 

00:04:03.240 --> 00:04:06.670
因为使用并行流，我们将获得

00:04:06.670 --> 00:04:09.790
由于线程的方式而导致的不确定行为

00:04:09.790 --> 00:04:13.240
执行。但这是很合法的

00:04:13.240 --> 00:04:17.890
 forEach在某些情况下。总结一下第3节， 

00:04:17.890 --> 00:04:21.829
如果您正在考虑使用forEach方法

00:04:21.829 --> 00:04:25.520
当您构建流代码段时

00:04:25.520 --> 00:04:29.330
停。您需要考虑的是

00:04:29.330 --> 00:04:33.160
在实际使用forEach之前，可以将其替换吗

00:04:33.160 --> 00:04:36.330
通过地图和

00:04:36.330 --> 00:04:39.460
减少？如果你可以的话， 

00:04:39.460 --> 00:04:42.720
那么您应该因为它更有可能， 

00:04:42.720 --> 00:04:46.020
为了发挥作用，您需要使用该地图

00:04:46.020 --> 00:04:49.500
其次是减少而不是每次减少。但， 

00:04:49.500 --> 00:04:52.919
如果您正在执行类似从流中打印值的操作

00:04:52.919 --> 00:04:56.780
那么它就不能被map和归约替换，所以它相当

00:04:56.780 --> 00:05:00.270
有效。如果您只是在使用输入流中的值， 

00:05:00.270 --> 00:05:05.610
那么forEach可能是非常有效的，到此为止

00:05:05.610 --> 00:05:06.500
这部分课程的内容

