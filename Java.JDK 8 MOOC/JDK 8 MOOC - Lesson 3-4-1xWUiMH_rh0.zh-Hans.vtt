WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.789 --> 00:00:13.400
 [音乐] 

00:00:13.400 --> 00:00:14.940
您好，欢迎来到本节

00:00:14.940 --> 00:00:17.810
第三课的第四课

00:00:17.810 --> 00:00:20.740
在本节中，我们将讨论如何使用收集器

00:00:20.740 --> 00:00:25.950
作为流上的终端操作。如果我们看一下

00:00:25.950 --> 00:00:29.140
收集器的基础知识，收集器的实际功能

00:00:29.140 --> 00:00:34.550
对流执行可变还原。因此，这意味着需要

00:00:34.550 --> 00:00:36.309
输入流的元素

00:00:36.309 --> 00:00:39.670
并将它们放入某种容器中

00:00:39.670 --> 00:00:44.120
存储结果。这个容器可以是什么

00:00:44.120 --> 00:00:48.500
是我们实际上可以更改的任何东西。我的意思是

00:00:48.500 --> 00:00:51.870
像收藏这样的东西，所以我们可以有一个列表，我们可以有一个地图，我们可以

00:00:51.870 --> 00:00:55.650
添加元素。但是我们可以轻松地使用

00:00:55.650 --> 00:00:59.309
诸如字符串之类的东西，我们可以将数据连接在一起

00:00:59.309 --> 00:01:03.620
形成一个单一的结果。在使用方面

00:01:03.620 --> 00:01:07.050
收集我们做的是使用收集

00:01:07.050 --> 00:01:10.260
终止流的方法。我们通过了

00:01:10.260 --> 00:01:14.530
收集器确定收集方法，以确定情况如何

00:01:14.530 --> 00:01:15.180
集。 

00:01:15.180 --> 00:01:18.580
您会发现在收藏家中（带有一个

00:01:18.580 --> 00:01:22.520
 s）实用程序类有很多方法

00:01:22.520 --> 00:01:26.190
可以用来创建收集器。还有很多不同的例子

00:01:26.190 --> 00:01:28.400
那，我们将在本部分的其余部分中讨论

00:01:28.400 --> 00:01:34.210
课。您可以与收藏家一起做的另一件事是，您实际上可以

00:01:34.210 --> 00:01:35.320
组成他们， 

00:01:35.320 --> 00:01:39.670
因此您可以从中创建更复杂的收集器

00:01:39.670 --> 00:01:43.310
 Collectors类中可用的基本的。 

00:01:43.310 --> 00:01:47.540
有许多示例可以做到这一点。 

00:01:47.540 --> 00:01:50.760
有方法collectingAndThen， 

00:01:50.760 --> 00:01:55.120
这样您就可以将一个收集器放置到另一个收集器上。 

00:01:55.120 --> 00:01:58.190
有groupingBy或groupingByConcurrent方法

00:01:58.190 --> 00:02:02.360
我们将看到如何将它们与所谓的下游收集器一起使用

00:02:02.360 --> 00:02:02.540
一种

00:02:02.540 --> 00:02:05.840
使用第二个收集器。类似的映射

00:02:05.840 --> 00:02:10.099
在这里我们可以描述我们如何应用不同的收集器来生成

00:02:10.099 --> 00:02:12.060
实际创建地图时的事情

00:02:12.060 --> 00:02:16.550
以及在进行分区时如何使用辅助收集器。 

00:02:16.550 --> 00:02:22.730
但是正如我说的，我们将通过示例进行介绍。 

00:02:22.730 --> 00:02:25.739
如果您想收藏到收藏中

00:02:25.739 --> 00:02:30.440
那么我们可以使用许多方法来做到这一点。最通用的，如果您

00:02:30.440 --> 00:02:30.879
喜欢， 

00:02:30.879 --> 00:02:34.450
是toCollection。那是什么需要

00:02:34.450 --> 00:02:38.099
一个方法，该方法的参数是供应商

00:02:38.099 --> 00:02:41.230
而供应商实质上是一家工厂

00:02:41.230 --> 00:02:44.760
创建某种形式的集合，供toCollection使用

00:02:44.760 --> 00:02:48.280
收集以收集该收集。 

00:02:48.280 --> 00:02:52.890
说很多不同的收藏集的时间相当长。所以我们

00:02:52.890 --> 00:02:56.329
创建一个集合，然后收集器将

00:02:56.329 --> 00:03:01.109
将元素添加到该集合的输入流中。就......而言

00:03:01.109 --> 00:03:05.280
它使用所谓的遭遇顺序的命令，这基本上意味着

00:03:05.280 --> 00:03:08.670
来自输入流的元素

00:03:08.670 --> 00:03:13.579
将按照可用的顺序替换到集合中。 

00:03:13.579 --> 00:03:16.900
如果我们想更具体一点

00:03:16.900 --> 00:03:20.340
然后我们要使用的集合

00:03:20.340 --> 00:03:25.060
有更简单的方法版本，我们可以对List说， 

00:03:25.060 --> 00:03:28.690
它将简单地将流的所有元素收集到一个列表中。 

00:03:28.690 --> 00:03:33.569
我们可以使用toSet，它将添加输入流的所有元素进行设置。 

00:03:33.569 --> 00:03:37.410
关于集合的事情是它消除了重复项。 

00:03:37.410 --> 00:03:44.560
这是将自动执行的一件事。我们也可以收集到地图， 

00:03:44.560 --> 00:03:48.220
它的工作方式是

00:03:48.220 --> 00:03:52.400
我们提供两种不同的功能。密钥映射器

00:03:52.400 --> 00:03:55.739
和一个valueMapper。本质上是什么

00:03:55.739 --> 00:03:59.190
这样做会允许所有收集器

00:03:59.190 --> 00:04:04.379
接受输入元素，然后使用keyMapper函数确定

00:04:04.379 --> 00:04:08.419
地图的键将成为然后使用

00:04:08.419 --> 00:04:11.750
 valueMapper函数确定哪些值

00:04:11.750 --> 00:04:17.120
如果您只想使用

00:04:17.120 --> 00:04:20.949
如果您不想进行任何特定的映射，则可以自行传输元素

00:04:20.949 --> 00:04:24.370
那么你可以使用function.identity方法

00:04:24.370 --> 00:04:28.349
这只是返回返回传递给它的值的函数。它

00:04:28.349 --> 00:04:30.140
不会改变它。 

00:04:30.140 --> 00:04:34.530
这里有一个例子，我在这里收集学生。 

00:04:34.530 --> 00:04:38.040
然后创建流源，然后通过

00:04:38.040 --> 00:04:42.800
收集，我说我想收集的方式是使用toMap 

00:04:42.800 --> 00:04:46.650
方法。 keyMapper是

00:04:46.650 --> 00:04:50.820
将使用functions.identity方法，这意味着我们将使用

00:04:50.820 --> 00:04:55.890
学生记录为键，然后为valueMapper 

00:04:55.890 --> 00:04:59.370
是一个函数，在这种情况下将使用分数

00:04:59.370 --> 00:05:03.220
的学生。我们将获得一张学生记录图

00:05:03.220 --> 00:05:09.540
以及他们在特定考试中获得的分数。要是我们

00:05:09.540 --> 00:05:14.100
要处理地图中的重复键，那么还有另一个版本

00:05:14.100 --> 00:05:17.330
 toMap方法。这个也一样

00:05:17.330 --> 00:05:20.410
前两个参数，keyMapper和valueMapper， 

00:05:20.410 --> 00:05:24.130
但它也有一个binaryOperator， 

00:05:24.130 --> 00:05:27.350
是合并功能。如果我们看

00:05:27.350 --> 00:05:30.510
我们可以做的工作方式

00:05:30.510 --> 00:05:35.190
可以说，好的，我有很多人。 

00:05:35.190 --> 00:05:39.360
我要做的是将这些收集到地图中

00:05:39.360 --> 00:05:43.770
对于键，我将使用地址

00:05:43.770 --> 00:05:48.350
输入流中特定人的身分和值

00:05:48.350 --> 00:05:52.640
将是那个人的名字。明显， 

00:05:52.640 --> 00:05:55.980
我可能最终有几个人住在同一地址。 

00:05:55.980 --> 00:06:00.690
如果是这种情况，我们将有重复的密钥，因为它们将是相同的地址， 

00:06:00.690 --> 00:06:03.950
然后我们使用合并功能， 

00:06:03.950 --> 00:06:07.680
由Lambda表达式定义。在这种情况下

00:06:07.680 --> 00:06:10.900
我们正在做的是串联字符串

00:06:10.900 --> 00:06:13.960
在人们的名字之间加上逗号

00:06:13.960 --> 00:06:17.770
这样我们以逗号分隔的值字符串结尾

00:06:17.770 --> 00:06:23.230
居住在特定地址的人口中。 

00:06:23.230 --> 00:06:25.570
我们可以做的另一件事是我们可以分组

00:06:25.570 --> 00:06:28.800
结果，并且有两种不同形式的

00:06:28.800 --> 00:06:33.100
 groupingBy方法。其中第一个仅需一个功能

00:06:33.100 --> 00:06:36.740
作为参数。这里的想法是，它使用

00:06:36.740 --> 00:06:39.800
函数确定什么键

00:06:39.800 --> 00:06:45.140
的地图将是，然后对于每个键

00:06:45.140 --> 00:06:48.210
它将使用输入流中的元素

00:06:48.210 --> 00:06:52.110
创建映射到的列表

00:06:52.110 --> 00:06:56.500
该特定的密钥。最简单的理解方法是使用

00:06:56.500 --> 00:07:00.220
例。我在这里得到的是文字的集合， 

00:07:00.220 --> 00:07:05.140
所以我从中创建一个流源并将其传递给groupingBy 

00:07:05.140 --> 00:07:09.140
然后将使用这些单词的长度

00:07:09.140 --> 00:07:12.420
作为地图的关键

00:07:12.420 --> 00:07:15.600
以及与该长度匹配的其他单词

00:07:15.600 --> 00:07:19.020
将被添加到列表中

00:07:19.020 --> 00:07:22.960
与该键关联的值。然后有一个

00:07:22.960 --> 00:07:26.930
第二种形式，它有第二个收集器， 

00:07:26.930 --> 00:07:30.700
这是我们如何组成收藏家的例子之一

00:07:30.700 --> 00:07:34.710
并使用下游收集器。在这种情况下， 

00:07:34.710 --> 00:07:38.200
如果我们看这个例子，我们会说一些话

00:07:38.200 --> 00:07:41.660
这次我们将再次按长度分组， 

00:07:41.660 --> 00:07:44.990
因此地图的键将是

00:07:44.990 --> 00:07:48.440
单词，而不是创建列表

00:07:48.440 --> 00:07:52.140
匹配该长度的单词。我们实际上想做什么

00:07:52.140 --> 00:07:55.480
是创造价值，这是

00:07:55.480 --> 00:07:58.590
该集合中有多少个单词

00:07:58.590 --> 00:08:01.770
匹配该长度。所以我们用计数

00:08:01.770 --> 00:08:05.600
生成多少字数的方法

00:08:05.600 --> 00:08:09.190
将具有该长度，并且将是与

00:08:09.190 --> 00:08:13.570
地图中的键。 

00:08:13.570 --> 00:08:16.580
如果我们想加入字符串，我们可以做到。 

00:08:16.580 --> 00:08:21.430
有几种形式。我们可以单独使用加入， 

00:08:21.430 --> 00:08:23.500
没有参数就没有方法

00:08:23.500 --> 00:08:27.570
这将简单地将输入字符串连接在一起以形成一个

00:08:27.570 --> 00:08:31.090
结果是字符串。我们也可以使用

00:08:31.090 --> 00:08:34.440
一个定界符，我们可以将其作为字符串传递。 

00:08:34.440 --> 00:08:38.419
有一个很好的例子，我们可以在这里使用Collectors.joining 

00:08:38.419 --> 00:08:42.370
用逗号分隔，将创建一个用逗号分隔的值列表。 

00:08:42.370 --> 00:08:45.520
如果我们愿意，甚至可以使用更多

00:08:45.520 --> 00:08:48.610
复杂的形式，除了

00:08:48.610 --> 00:08:52.540
定界符，我们还可以提供前缀和后缀字符串

00:08:52.540 --> 00:08:56.470
它将被附加在字符串的开头和结尾

00:08:56.470 --> 00:09:01.040
前缀开头，结尾后缀，使用定界符

00:09:01.040 --> 00:09:04.740
在各个值之间。有范围

00:09:04.740 --> 00:09:07.910
的数字收集器和

00:09:07.910 --> 00:09:11.680
我为简化此特定幻灯片所做的只是为了给您

00:09:11.680 --> 00:09:16.540
我们可以讨论的收集器方法的整数版本， 

00:09:16.540 --> 00:09:20.490
但也有双重和长期版本。 

00:09:20.490 --> 00:09:23.830
首先是给你一个平均值。 

00:09:23.830 --> 00:09:27.490
这将生成一个收集器，该收集器将使用

00:09:27.490 --> 00:09:31.050
您提供的转换输入流的功能

00:09:31.050 --> 00:09:34.240
进入它的一组整数值，然后

00:09:34.240 --> 00:09:39.060
创建的收集器将平均这些结果。有个

00:09:39.060 --> 00:09:43.270
汇总收集器，我们可以使用此方法创建收集器。 

00:09:43.270 --> 00:09:47.240
同样，这使用您传递的函数作为参数

00:09:47.240 --> 00:09:50.730
确定如何将输入流转换为

00:09:50.730 --> 00:09:54.010
一组数值。您得到的摘要是

00:09:54.010 --> 00:09:57.750
输入流中数字元素的数量， 

00:09:57.750 --> 00:10:01.980
您得到的总数是所创建值的总和； 

00:10:01.980 --> 00:10:05.290
你得到最小值，得到最大值，然后得到平均值

00:10:05.290 --> 00:10:07.530
一起。 

00:10:07.530 --> 00:10:10.530
有一个summingInt收集器， 

00:10:10.530 --> 00:10:13.700
我们可以再次使用函数生成

00:10:13.700 --> 00:10:18.180
这实际上等同于在地图上加上总和。 

00:10:18.180 --> 00:10:22.550
与其使用收集器操作，不如使用地图

00:10:22.550 --> 00:10:26.360
使用该函数将其转换为数值，然后可以求和

00:10:26.360 --> 00:10:27.530
这些数值。 

00:10:27.530 --> 00:10:32.380
这只是一种简便的方法。还有两个：maxBy和

00:10:32.380 --> 00:10:36.190
 minBy，使用比较器生成

00:10:36.190 --> 00:10:39.340
收藏家将给你最大的收获

00:10:39.340 --> 00:10:43.840
或基于比较器工作方式的输入流的最小值。 

00:10:43.840 --> 00:10:47.310
很少有

00:10:47.310 --> 00:10:51.090
其他收藏家，创建收藏家的方式。 

00:10:51.090 --> 00:10:55.270
其中之一是归约化，需要二元运算符

00:10:55.270 --> 00:10:58.770
解释如何创建收集器。 

00:10:58.770 --> 00:11:01.780
这真的等于减少

00:11:01.780 --> 00:11:06.120
终端操作，当然，问题是，您为什么要使用它呢？ 

00:11:06.120 --> 00:11:07.310
而不是使用

00:11:07.310 --> 00:11:12.310
减少操作，实际上，如果您使用的是

00:11:12.310 --> 00:11:13.680
下游收集器

00:11:13.680 --> 00:11:17.160
因此，如果您使用的是辅助收集器，则可以使用它

00:11:17.160 --> 00:11:20.160
以确定您要如何进行特定还原。 

00:11:20.160 --> 00:11:23.470
有分手

00:11:23.470 --> 00:11:26.700
这将创建一个收集器

00:11:26.700 --> 00:11:30.280
这将生成一张地图。地图

00:11:30.280 --> 00:11:33.780
有两个键：true和false，然后

00:11:33.780 --> 00:11:37.300
每个值都是

00:11:37.300 --> 00:11:41.610
值，根据您获得的谓词匹配true或false。 

00:11:41.610 --> 00:11:45.180
例如，如果我们收集了

00:11:45.180 --> 00:11:48.940
人们，我们想对它进行分区

00:11:48.940 --> 00:11:52.810
这样我们就可以根据性别将其分为两组。您可以使用谓词

00:11:52.810 --> 00:11:56.610
测试他们是男性还是女性，然后

00:11:56.610 --> 00:11:59.860
 partitioningBy收集器将创建

00:11:59.860 --> 00:12:03.010
两个列表：一个为true，一个为false，具体取决于

00:12:03.010 --> 00:12:05.350
无论他们是男性还是非男性。 195 00：12：05,350-&gt; 00：12：08,570还有一个映射功能

00:12:08.570 --> 00:12:11.750
收藏家，这将是创造

00:12:11.750 --> 00:12:15.620
一个可以接受不同类型元素的新收集器

00:12:15.620 --> 00:12:19.040
根据您提供的功能。 

00:12:19.040 --> 00:12:22.490
最好的解释方式是使用示例，例如

00:12:22.490 --> 00:12:26.380
我们这里有什么。我们在说的是，好吧，我们想

00:12:26.380 --> 00:12:30.050
根据城市的姓氏收集

00:12:30.050 --> 00:12:34.430
因此我们收集了一群人，并再次根据该名称创建了一个信息流。 

00:12:34.430 --> 00:12:37.750
我们收集它以便我们将那些人分组

00:12:37.750 --> 00:12:41.150
由他们的城市，但然后我们

00:12:41.150 --> 00:12:44.520
想做的实际收藏

00:12:44.520 --> 00:12:48.140
是根据该姓氏创建一个映射到集合中。 

00:12:48.140 --> 00:12:51.350
这样您就可以得到某人的所有姓氏

00:12:51.350 --> 00:12:56.310
市。然后总结第4节， 

00:12:56.310 --> 00:12:59.710
收藏家为我们提供了一种非常强大的方式

00:12:59.710 --> 00:13:02.870
收集输入流的元素

00:13:02.870 --> 00:13:06.210
当我们想在我们寻找的地方产生某种结果时， 

00:13:06.210 --> 00:13:09.380
不一定只是为了一个结果，尽管

00:13:09.380 --> 00:13:13.890
收集器可用于此目的。我们能做的是，如果我们想收集

00:13:13.890 --> 00:13:18.740
收集，或者我们可以用数字方式收集，可以得出平均值， 

00:13:18.740 --> 00:13:19.660
我们可以求和

00:13:19.660 --> 00:13:23.460
等等。我们可以组成收藏家， 

00:13:23.460 --> 00:13:26.800
这样我们就可以从基本的基础上构建更复杂的基础

00:13:26.800 --> 00:13:30.510
如果您愿意，可以创建自己的收藏家

00:13:30.510 --> 00:13:34.200
但是我们没有时间探索如何在这个特定的位置

00:13:34.200 --> 00:13:37.230
课程的一部分

00:13:37.230 --> 00:13:40.070
这节课到此结束。 

