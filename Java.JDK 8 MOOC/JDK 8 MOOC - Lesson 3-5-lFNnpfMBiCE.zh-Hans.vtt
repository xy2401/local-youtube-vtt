WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.750 --> 00:00:03.320
 [音乐] 

00:00:13.510 --> 00:00:15.950
您好，欢迎阅读第5部分

00:00:15.950 --> 00:00:20.730
第3课，在本节中，我们将讨论并行流

00:00:20.730 --> 00:00:24.130
我们真正想了解的一件事是

00:00:24.130 --> 00:00:27.320
什么时候使用它们，什么时候不使用它们。 

00:00:27.320 --> 00:00:31.520
要是我们

00:00:31.520 --> 00:00:35.340
回头看看我们如何创建流源

00:00:35.340 --> 00:00:39.640
您会从第2课中记得我们在collections中看到的

00:00:39.640 --> 00:00:43.420
您可以通过调用流来顺序创建流

00:00:43.420 --> 00:00:44.140
方法

00:00:44.140 --> 00:00:48.320
或者您可以创建并行流。现在这是

00:00:48.320 --> 00:00:52.850
您可以直接创建并行流的唯一方法

00:00:52.850 --> 00:00:57.020
作为来源。创建流源的其他方式

00:00:57.020 --> 00:01:01.790
不允许您直接创建并行之一。这为我们提供了什么

00:01:01.790 --> 00:01:02.370
是

00:01:02.370 --> 00:01:05.619
一种情况，如果我们想要并行流

00:01:05.619 --> 00:01:09.750
但是我们是用数组而不是集合创建的， 

00:01:09.750 --> 00:01:13.539
我们如何使并行？在这种情况下，有一种方法

00:01:13.539 --> 00:01:18.179
在称为parallel的流接口中，该接口允许转换

00:01:18.179 --> 00:01:23.170
顺序流转换为并行流。与此相反， 

00:01:23.170 --> 00:01:26.890
在已经有并行流的地方，我们可以将其转换为顺序流

00:01:26.890 --> 00:01:27.590
流。 

00:01:27.590 --> 00:01:33.440
因此，我们可以使用顺序方法来做到这一点。如果我们有多个电话

00:01:33.440 --> 00:01:34.319
我们的代码

00:01:34.319 --> 00:01:37.729
在并行流和顺序流之间进行切换的地方

00:01:37.729 --> 00:01:41.289
很有可能那么最后一个

00:01:41.289 --> 00:01:45.220
通话将是真正获胜的电话，因为

00:01:45.220 --> 00:01:48.470
所有与流将被处理

00:01:48.470 --> 00:01:53.590
顺序或并行。不是这种情况，我们将处理前几个

00:01:53.590 --> 00:01:54.970
并联零件

00:01:54.970 --> 00:01:58.410
然后我们将切换到顺序，然后再切换回并行。它不像

00:01:58.410 --> 00:01:58.759
那。 

00:01:58.759 --> 00:02:02.310
一切都是顺序的，或者一切都是并行的。 

00:02:02.310 --> 00:02:05.700
您最后所做的更改是哪一个

00:02:05.700 --> 00:02:09.459
流的处理方式将是

00:02:09.459 --> 00:02:13.450
所有流将被处理为。 

00:02:13.450 --> 00:02:16.500
如果合并两个流

00:02:16.500 --> 00:02:19.640
然后，如果您有其中之一

00:02:19.640 --> 00:02:23.310
顺序和其中之一并行，结果

00:02:23.310 --> 00:02:29.230
将是并行流。在条款上

00:02:29.230 --> 00:02:32.599
如何实现并行流

00:02:32.599 --> 00:02:35.730
他们在下面使用fork-join框架。 

00:02:35.730 --> 00:02:39.269
库代码将使用fork-join框架来

00:02:39.269 --> 00:02:42.290
分解正在处理的任务

00:02:42.290 --> 00:02:45.519
分成多个子任务，分配那些

00:02:45.519 --> 00:02:49.180
到队列中的线程池，处理那些

00:02:49.180 --> 00:02:52.379
并行，准备好所有结果

00:02:52.379 --> 00:02:57.750
并创建一个输出。工作方式

00:02:57.750 --> 00:03:00.910
是线程数， 

00:03:00.910 --> 00:03:04.000
分配在池中的纯基于

00:03:04.000 --> 00:03:07.769
操作系统报告的处理器数量。 

00:03:07.769 --> 00:03:11.040
如果您有双核计算机， 

00:03:11.040 --> 00:03:14.099
也会做超线程，实际上

00:03:14.099 --> 00:03:17.720
报告了四个处理器，因此池大小为

00:03:17.720 --> 00:03:21.609
四个线程。那可能不是您想要的。 

00:03:21.609 --> 00:03:24.650
如果您在大型计算机上运行， 

00:03:24.650 --> 00:03:28.440
许多处理器和许多核心，您可能不希望全部使用

00:03:28.440 --> 00:03:32.180
致力于一个应用程序中的一项任务。 

00:03:32.180 --> 00:03:35.660
这不是特别容易

00:03:35.660 --> 00:03:40.190
改变这个；因此，如果有一个简单的方法可以做到这一点，但是有一个

00:03:40.190 --> 00:03:41.489
周围的工作

00:03:41.489 --> 00:03:44.540
您可以使用的。您可以设置系统

00:03:44.540 --> 00:03:50.410
属性使用System.setProperty，如您所见，您可以在此处进行更改

00:03:50.410 --> 00:03:53.620
通用并行数

00:03:53.620 --> 00:03:58.430
与fork-join池相关联。你可以改变

00:03:58.430 --> 00:04:03.180
从0到32767之间的任何数字

00:04:03.180 --> 00:04:07.160
您可以将其设置为所需的任何值。如果您有16个核心， 

00:04:07.160 --> 00:04:10.699
机器中有16个处理器，则可以设置

00:04:10.699 --> 00:04:13.049
设置为4或将其设置为8，具体取决于

00:04:13.049 --> 00:04:18.120
你想做什么。并行流最重要的事情之一

00:04:18.120 --> 00:04:21.919
不要被思想误导

00:04:21.919 --> 00:04:24.960
并行流将始终为您提供更好的性能。 

00:04:24.960 --> 00:04:29.039
如果您的机器具有多个核心和多个处理器

00:04:29.039 --> 00:04:32.340
你可能很想去，好吧，我总是可以并行做事

00:04:32.340 --> 00:04:36.139
那会给我更好的结果。不一定是这样。 

00:04:36.139 --> 00:04:39.240
因为你要记住

00:04:39.240 --> 00:04:42.910
不管并行流发生什么

00:04:42.910 --> 00:04:46.680
总是会做更多的工作，因为， 

00:04:46.680 --> 00:04:50.539
在使用fork-join框架的情况下，所有这些

00:04:50.539 --> 00:04:53.849
有开销。您必须设置框架，设置所有

00:04:53.849 --> 00:04:56.900
池中的线程，以将作业分配给

00:04:56.900 --> 00:05:01.220
不同的队列等等。关于使用的事情

00:05:01.220 --> 00:05:05.320
并行流是，尽管它总是涉及更多工作

00:05:05.320 --> 00:05:09.479
有时，如果您依次执行，它会更快地完成。 

00:05:09.479 --> 00:05:13.590
注意事项

00:05:13.590 --> 00:05:17.789
使用并行流，这里需要做几件事。 

00:05:17.789 --> 00:05:20.900
我们已经讨论过findFirst和findAny 

00:05:20.900 --> 00:05:24.130
作为终端方法

00:05:24.130 --> 00:05:28.740
在流中。当我们谈论那个发现时我提到过

00:05:28.740 --> 00:05:33.520
是不确定的；这意味着您有多个线程， 

00:05:33.520 --> 00:05:37.909
所有人都在寻找结果。这些线程中的任何一个

00:05:37.909 --> 00:05:42.050
可以立即找到结果。那意味着

00:05:42.050 --> 00:05:47.870
如果您使用相同的输入数据，并且使用相同的数据运行几次

00:05:47.870 --> 00:05:53.289
如果使用findFirst，不一定会得到相同的结果

00:05:53.289 --> 00:05:57.419
即使使用并行流，您也将获得确定的结果。 

00:05:57.419 --> 00:06:01.060
同一输入流数据集的结果将始终相同。 

00:06:01.060 --> 00:06:05.180
这是要记住的事，在设计流时要考虑的事

00:06:05.180 --> 00:06:05.720
码。 

00:06:05.720 --> 00:06:08.780
与forEach同样

00:06:08.780 --> 00:06:12.050
并且有一个等效的方法称为forEachOrdered。 

00:06:12.050 --> 00:06:16.180
如果使用forEach和并行流

00:06:16.180 --> 00:06:19.570
您已经订购了数据，您将获得

00:06:19.570 --> 00:06:23.340
非确定性结果。如果您列出清单

00:06:23.340 --> 00:06:26.430
然后您从该列表中调用forEach 

00:06:26.430 --> 00:06:30.139
如果使用并行线程，则不一定

00:06:30.139 --> 00:06:33.600
如果打印出结果，则得到相同的顺序。 

00:06:33.600 --> 00:06:37.350
如果您愿意，可以使用forEachOrdered， 

00:06:37.350 --> 00:06:41.300
这又是确定性的。如果您列出清单

00:06:41.300 --> 00:06:44.979
并从中创建并行流并将其传递给forEachOrdered 

00:06:44.979 --> 00:06:48.560
并以相同的顺序打印出您总是可以超越的元素

00:06:48.560 --> 00:06:54.680
对于相同的输入集。什么时候使用并行流？ 

00:06:54.680 --> 00:06:58.240
不幸的是，对此没有真正简单的答案。 

00:06:58.240 --> 00:07:01.479
您需要做的是考虑几件事

00:07:01.479 --> 00:07:04.490
您需要考虑什么类型的

00:07:04.490 --> 00:07:07.610
您正在使用的数据结构。如果你有

00:07:07.610 --> 00:07:11.940
像ArrayList这样的流源很好

00:07:11.940 --> 00:07:15.860
用于并行流，因为很容易提取数据

00:07:15.860 --> 00:07:19.380
以并行方式。哈希集和树集

00:07:19.380 --> 00:07:23.940
虽然不如ArrayList好，但是还可以。像LinkedList这样的东西

00:07:23.940 --> 00:07:28.860
不好是因为我们必须遵循所有链接

00:07:28.860 --> 00:07:32.240
数据结构以便获得特定值。 

00:07:32.240 --> 00:07:35.650
这在并行环境中无法很好地工作。 

00:07:35.650 --> 00:07:39.960
就流中的操作而言，您要做的是

00:07:39.960 --> 00:07:43.060
也将影响到

00:07:43.060 --> 00:07:47.270
并行流与顺序流比较有效。如果您正在使用类似

00:07:47.270 --> 00:07:48.020
过滤

00:07:48.020 --> 00:07:51.080
如果您正在使用诸如映射之类的东西，这些是

00:07:51.080 --> 00:07:55.060
非常适合并行流。您可以执行这些操作， 

00:07:55.060 --> 00:07:59.010
您可以将它们完全分解为单独的操作。的

00:07:59.010 --> 00:08:02.800
原因是当您进行映射时， 

00:08:02.800 --> 00:08:07.669
您正在映射每个单独的元素；一个要素之间没有依赖

00:08:07.669 --> 00:08:08.460
在流中

00:08:08.460 --> 00:08:11.950
还有一个。如果您使用排序

00:08:11.950 --> 00:08:15.810
和那些分解得不太好的人

00:08:15.810 --> 00:08:19.090
因为对其他元素的依赖

00:08:19.090 --> 00:08:23.720
输入集以构造结果。如果您正在寻找与众不同的产品

00:08:23.720 --> 00:08:24.330
数据

00:08:24.330 --> 00:08:27.570
那么您必须确保已将每个元素与所有元素进行了比较

00:08:27.570 --> 00:08:31.300
到目前为止，您需要确定其他元素

00:08:31.300 --> 00:08:35.510
是否重复。 

00:08:35.510 --> 00:08:37.159
我们还需要考虑

00:08:37.159 --> 00:08:41.690
我们正在使用多少数据以及处理每个元素需要多少时间。 

00:08:41.690 --> 00:08:45.090
如果您认为数据集的大小

00:08:45.090 --> 00:08:50.190
 n和为流处理一个元素的成本

00:08:50.190 --> 00:08:53.980
管道是q，那么总成本

00:08:53.980 --> 00:08:58.779
处理该过程的工作量将为n * q。 

00:08:58.779 --> 00:09:01.839
 n * q越大

00:09:01.839 --> 00:09:06.140
是要执行的更好的并行流。举个例子

00:09:06.140 --> 00:09:09.430
如果您有一个包含10个元素的列表

00:09:09.430 --> 00:09:13.310
它和它只是做一个映射，一个简单的映射

00:09:13.310 --> 00:09:16.900
然后将其转换为并行流不会

00:09:16.900 --> 00:09:21.050
提高效率。如果你有一百万个元素

00:09:21.050 --> 00:09:24.850
在您的输入集中，您得到了一些相当重的东西

00:09:24.850 --> 00:09:25.860
你在做什么

00:09:25.860 --> 00:09:29.610
那么您将从并行流中获得更好的性能

00:09:29.610 --> 00:09:32.690
而且更容易

00:09:32.690 --> 00:09:35.940
确定n，因为您可以找出数据集的大小

00:09:35.940 --> 00:09:39.830
很容易，但是q可能很难。 

00:09:39.830 --> 00:09:44.050
您倾向于最终估计它。你真正需要做的

00:09:44.050 --> 00:09:48.339
以确保您正确决定在哪里使用并行流

00:09:48.339 --> 00:09:49.040
或不是

00:09:49.040 --> 00:09:52.839
轮廓。与顺序流一起尝试，与并行流一起尝试

00:09:52.839 --> 00:09:58.950
并使用效率更高的一种。总结第5节

00:09:58.950 --> 00:10:03.660
如我们所见，流可以按顺序处理，也可以

00:10:03.660 --> 00:10:04.620
并行处理。 

00:10:04.620 --> 00:10:08.920
当我们说可以在顺序之间切换时

00:10:08.920 --> 00:10:14.250
或在流中间平行，但将对流进行处理

00:10:14.250 --> 00:10:17.390
完全顺序或完全并行。 

00:10:17.390 --> 00:10:21.140
大多数情况下，我们使用流

00:10:21.140 --> 00:10:25.830
您如何定义它不会影响结果；依次执行还是并行执行都不会影响

00:10:25.830 --> 00:10:26.300
结果。 

00:10:26.300 --> 00:10:29.720
对于findFirst，findAny，forEach和

00:10:29.720 --> 00:10:34.020
 forEachOrdered它们将影响结果的顺序。 

00:10:34.020 --> 00:10:37.540
而这里的大事情并不假设

00:10:37.540 --> 00:10:40.580
并行流将始终返回更快的结果。 

00:10:40.580 --> 00:10:43.139
如我们所见，许多因素会影响到

00:10:43.139 --> 00:10:46.910
并谨慎选择

00:10:46.910 --> 00:10:50.209
以确保您使用的是最有效的。 

00:10:50.209 --> 00:10:53.629
到此为止，这部分课程结束了。 

