WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.750 --> 00:00:03.310
 [音乐] 

00:00:13.490 --> 00:00:15.940
您好，欢迎来到第6节

00:00:15.940 --> 00:00:19.890
第3课的内容。在本节中，我们将讨论一些

00:00:19.890 --> 00:00:23.689
如何调试Lambda表达式

00:00:23.689 --> 00:00:27.369
和溪流。我们看

00:00:27.369 --> 00:00:32.400
流如何工作。他们真正所做的是为我们提供了高水平的抽象

00:00:32.400 --> 00:00:35.480
围绕我们要解决的问题。现在就是

00:00:35.480 --> 00:00:39.129
从我们如何观察代码的角度来看，这确实非常好， 

00:00:39.129 --> 00:00:42.379
因为它使我们的代码更加清晰，使代码很多

00:00:42.379 --> 00:00:47.420
更容易理解。但是，如果代码没有完全按照我们想要的去做

00:00:47.420 --> 00:00:51.610
我们需要开始调试它确实变成的代码

00:00:51.610 --> 00:00:55.269
当我们使用Lambda和流时，还有更多的问题。 

00:00:55.269 --> 00:00:59.790
库代码下发生了很多事情

00:00:59.790 --> 00:01:04.180
流API所使用的资源代表我们做了很多工作， 

00:01:04.180 --> 00:01:08.590
我们在代码中看不到这并不容易

00:01:08.590 --> 00:01:11.720
当我们想设置一个断点时，因为我们只能设置它

00:01:11.720 --> 00:01:15.030
在每个粗略的方面来讲，流在做什么。 

00:01:15.030 --> 00:01:19.910
而且由于事情发生的方式与实际情况有关

00:01:19.910 --> 00:01:24.500
流代码的执行，我们根据合并来优化事物

00:01:24.500 --> 00:01:28.360
操作-这种类型的东西-它也

00:01:28.360 --> 00:01:31.710
使我们更难确定实际发生的事情

00:01:31.710 --> 00:01:36.840
在处理上。让我们来看看

00:01:36.840 --> 00:01:40.840
我们如何进行一些简单的调试。发生了什么

00:01:40.840 --> 00:01:44.730
流中的方法之间？去做这个

00:01:44.730 --> 00:01:48.810
我们可以使用第2课中的peek方法。 

00:01:48.810 --> 00:01:52.360
请记住，peek方法采用输入流元素

00:01:52.360 --> 00:01:56.270
并将它们直接传递到输出流，因此输出流是

00:01:56.270 --> 00:01:57.970
与输入流完全相同。 

00:01:57.970 --> 00:02:01.810
它也使我们能够做的是查看这些元素

00:02:01.810 --> 00:02:05.570
当他们过去时。我们可以使用类似打印声明的内容

00:02:05.570 --> 00:02:09.989
找出该流中正在处理的数据

00:02:09.989 --> 00:02:13.049
实际上是。如果我们看这个例子

00:02:13.049 --> 00:02:17.049
我们从公共档案中收集了一些文字， 

00:02:17.049 --> 00:02:19.409
读那些线

00:02:19.409 --> 00:02:23.150
然后我们传递了flatMap并使用了

00:02:23.150 --> 00:02:27.569
使用正则表达式调用stream.of方法以拆分行

00:02:27.569 --> 00:02:33.780
成词组。然后将这些单词流传递到地图中

00:02:33.780 --> 00:02:38.180
我们将它们转换为小写。然后将其传递给别的，以便我们可以删除

00:02:38.180 --> 00:02:39.209
复制品

00:02:39.209 --> 00:02:44.450
然后传递给排序。因此，我们按长度排序，最后将其收集到列表中。 

00:02:44.450 --> 00:02:47.799
显然，如果某件事不太有效

00:02:47.799 --> 00:02:50.819
在代码处理方式方面

00:02:50.819 --> 00:02:54.879
从我们的角度来看，我们需要尝试找出正在发生的事情。 

00:02:54.879 --> 00:02:58.310
我们可以使用peek来做到这一点。所以我们可以放一个

00:02:58.310 --> 00:03:02.189
看线之间的偷看电话

00:03:02.189 --> 00:03:05.200
和flatMap。这样我们就可以打印出来

00:03:05.200 --> 00:03:08.680
来自文件的行要在我们正在检查的行中进行检查

00:03:08.680 --> 00:03:09.299
看到

00:03:09.299 --> 00:03:12.299
流中是我们希望从文件中获得的行。 

00:03:12.299 --> 00:03:16.609
如果正则表达式无法正常工作

00:03:16.609 --> 00:03:19.689
然后我们可以做的就是移动窥视

00:03:19.689 --> 00:03:23.060
到flatMap之后。这样我们可以

00:03:23.060 --> 00:03:26.760
然后看看从flatMap出来的单词

00:03:26.760 --> 00:03:29.849
确保正则表达式正在处理文本行

00:03:29.849 --> 00:03:34.220
以我们想要的方式。您可以在这里看到我们可以逐步移动

00:03:34.220 --> 00:03:34.609
偷看和

00:03:34.609 --> 00:03:37.620
我们可以看到流的不同部分为

00:03:37.620 --> 00:03:42.290
我们正在处理它。如果要设置断点， 

00:03:42.290 --> 00:03:46.609
我们也可以使用peek来设置一个点

00:03:46.609 --> 00:03:49.729
在我们想要实际检查发生了什么的流中。 

00:03:49.729 --> 00:03:53.040
就......而言

00:03:53.040 --> 00:03:56.609
实现我们实际上可以使用空操作，所以

00:03:56.609 --> 00:04:00.729
没有任何作用的东西。偷看只会通过

00:04:00.729 --> 00:04:02.919
将元素直接输入到输出流并输出

00:04:02.919 --> 00:04:06.919
他们过去时，对他们做任何事情。但是它允许我们设置一个

00:04:06.919 --> 00:04:07.900
断点

00:04:07.900 --> 00:04:11.879
在flatMap和map之间，因此，如果我们愿意，我们可以

00:04:11.879 --> 00:04:16.549
用户IDE，然后检查各种情况。 

00:04:16.549 --> 00:04:21.250
要记住的一件事是，某些调试工具不喜欢空主体，因此您需要

00:04:21.250 --> 00:04:21.699
至

00:04:21.699 --> 00:04:26.349
可能在那里做些事情。 

00:04:26.349 --> 00:04:29.580
我们可以做的另一件事是使用方法参考。 

00:04:29.580 --> 00:04:33.160
而不是拥有Lambda表达式

00:04:33.160 --> 00:04:37.310
保留我们实际执行的所有代码，我们可以

00:04:37.310 --> 00:04:40.759
之所以将其转移出去，是因为内部发生了什么

00:04:40.759 --> 00:04:44.849
是Lambda表达式未编译为等效表达式

00:04:44.849 --> 00:04:48.629
匿名内部类。我们使用invokedynamic调用

00:04:48.629 --> 00:04:53.400
然后在运行时决定实现。缺点很明显

00:04:53.400 --> 00:04:53.949
那

00:04:53.949 --> 00:04:57.190
 IDE将要查看的代码将具有一个invokedynamicbytecode 

00:04:57.190 --> 00:05:01.280
这使我们很难实际设置断点。 

00:05:01.280 --> 00:05:05.909
与其那样做，不如说我们可以实际获取Lambda中的代码

00:05:05.909 --> 00:05:06.659
表达

00:05:06.659 --> 00:05:10.460
并将其放在单独的方法中。把方法放进去

00:05:10.460 --> 00:05:14.190
我们的课，然后替换Lambda表达式

00:05:14.190 --> 00:05:17.729
该方法的代码引用了我们的新方法。 

00:05:17.729 --> 00:05:20.889
完成后，我们可以设置断点

00:05:20.889 --> 00:05:24.360
在新方法中的语句上，因为这些将正常编译

00:05:24.360 --> 00:05:27.780
我们可以确切地看到发生了什么，并且可以使用调试器

00:05:27.780 --> 00:05:33.560
检查程序状态。总结一下6 

00:05:33.560 --> 00:05:37.479
使用Lambda和流进行调试更加困难。 

00:05:37.479 --> 00:05:41.090
由于代码合并的方式，因为存在

00:05:41.090 --> 00:05:41.690
发生了很多

00:05:41.690 --> 00:05:45.069
就库代码而言，这确实使工作变得更加艰难。 

00:05:45.069 --> 00:05:49.259
我们编译以调用动态字节码和

00:05:49.259 --> 00:05:52.990
直到运行时使生活变得更艰难之前，才决定实现方式

00:05:52.990 --> 00:05:53.319
的观点

00:05:53.319 --> 00:05:57.800
断点。使用窥视，使用方法参考

00:05:57.800 --> 00:06:01.630
可以简化事情并使生活更轻松

00:06:01.630 --> 00:06:05.020
确定流或Lambda代码中实际发生的情况。 

00:06:05.020 --> 00:06:08.949
至此第6节结束。 

