WEBVTT
Kind: captions
Language: zh-Hans

00:00:04.760 --> 00:00:07.849
 [音乐] 

00:00:13.410 --> 00:00:19.810
大家好，谢谢你

00:00:15.700 --> 00:00:21.640
介绍你已经正式做到了

00:00:19.810 --> 00:00:24.430
到一天的最后一个环节

00:00:21.640 --> 00:00:26.470
恭喜你谢谢你

00:00:24.430 --> 00:00:29.050
勤于学习的兴趣

00:00:26.470 --> 00:00:33.730
来听我们的谈话

00:00:29.050 --> 00:00:35.170
就像劳拉说我是乔治·萨博

00:00:33.730 --> 00:00:37.710
成为的独特乐趣

00:00:35.170 --> 00:00:40.600
在oracle上运行Java组的人

00:00:37.710 --> 00:00:44.290
我也是开放JDK的主席

00:00:40.600 --> 00:00:45.940
董事会，我必须证明

00:00:44.290 --> 00:00:47.379
你这说如果你要

00:00:45.940 --> 00:00:48.280
做出购买我们所要买东西的决定

00:00:47.379 --> 00:00:49.180
会谈论的是

00:00:48.280 --> 00:00:51.909
将来发生

00:00:49.180 --> 00:00:55.290
所以请记住，您知道一些事情

00:00:51.909 --> 00:00:55.290
更改此幻灯片的内容

00:00:55.320 --> 00:00:59.650
好，所以我们要做的方式是

00:00:58.390 --> 00:01:01.689
只是谈一点

00:00:59.650 --> 00:01:03.760
 Java的总体情况和发展趋势

00:01:01.689 --> 00:01:05.199
然后迈克尔要谈一个

00:01:03.760 --> 00:01:08.740
关于一些项目的整堆

00:01:05.199 --> 00:01:11.500
我目前正在研究

00:01:08.740 --> 00:01:13.600
我怀疑这个房间里有很多东西

00:01:11.500 --> 00:01:16.060
很多使用Java的人，所以我

00:01:13.600 --> 00:01:19.450
可能不知道需要扭动手臂

00:01:16.060 --> 00:01:22.359
或说服您为什么选择Java SE 

00:01:19.450 --> 00:01:24.909
很明显，我们认为这很重要

00:01:22.359 --> 00:01:28.090
伟大的技术，你知道我的团队是

00:01:24.909 --> 00:01:30.579
一个来自Sun Microsystems， 

00:01:28.090 --> 00:01:33.399
已经为许多人开发了Java 

00:01:30.579 --> 00:01:34.780
很多年，所以这是

00:01:33.399 --> 00:01:36.609
我们充满热情，我们热爱

00:01:34.780 --> 00:01:38.619
与使用

00:01:36.609 --> 00:01:40.569
技术，你知道我们喜欢听

00:01:38.619 --> 00:01:42.249
成功故事，我们都是真实的

00:01:40.569 --> 00:01:45.490
有兴趣了解挑战

00:01:42.249 --> 00:01:47.079
你有，所以我们总是很高兴在

00:01:45.490 --> 00:01:50.590
这样的会议，我希望你会

00:01:47.079 --> 00:01:54.310
利用我想你知道

00:01:50.590 --> 00:01:56.109
当我们考虑Java及其如何

00:01:54.310 --> 00:01:59.310
进化了我们永远的一件事

00:01:56.109 --> 00:02:02.829
尝试意识到有一个

00:01:59.310 --> 00:02:06.130
进化是非常周到的

00:02:02.829 --> 00:02:08.470
并非偶然Java从来都不是

00:02:06.130 --> 00:02:10.090
一直在追逐的技术

00:02:08.470 --> 00:02:13.330
最新的功能，只是

00:02:10.090 --> 00:02:15.250
在我们真正尝试的一面解决问题

00:02:13.330 --> 00:02:18.610
确保当我们添加一些

00:02:15.250 --> 00:02:20.910
我们了解为什么对您有好处

00:02:18.610 --> 00:02:23.160
可能想要我们走

00:02:20.910 --> 00:02:25.290
通过很多工作基本上可以做到

00:02:23.160 --> 00:02:29.610
我们现在在开发新功能

00:02:25.290 --> 00:02:31.350
在开放的JDK中打开，所以这是

00:02:29.610 --> 00:02:33.270
你可以利用你的东西

00:02:31.350 --> 00:02:35.580
可以实际去打开可以签名的JDK 

00:02:33.270 --> 00:02:37.380
到邮件列表，您可以看到

00:02:35.580 --> 00:02:40.260
我们进行的设计讨论

00:02:37.380 --> 00:02:43.140
我们致力于新功能以及您将要做什么

00:02:40.260 --> 00:02:45.590
找到你是否这样做

00:02:43.140 --> 00:02:48.060
认为真的很简单，就像你知道的

00:02:45.590 --> 00:02:49.620
他们正在向Java添加闭包多长时间

00:02:48.060 --> 00:02:53.040
那可以吗

00:02:49.620 --> 00:02:55.380
很明显你知道事实上

00:02:53.040 --> 00:02:58.710
你看着像lambdas这样的东西

00:02:55.380 --> 00:03:00.600
 Java 8，看起来很明显

00:02:58.710 --> 00:03:03.380
因为很多时间和很多努力

00:03:00.600 --> 00:03:05.490
工作变得很明显我

00:03:03.380 --> 00:03:07.380
向您保证，如果我们采取了第一个

00:03:05.490 --> 00:03:09.180
我们为lambda设计的设计

00:03:07.380 --> 00:03:11.430
用我们本来可以的

00:03:09.180 --> 00:03:13.620
东西很快就出来了

00:03:11.430 --> 00:03:15.330
不会觉得那么自然， 

00:03:13.620 --> 00:03:18.420
会有很多挑战

00:03:15.330 --> 00:03:20.700
问题很多挫败感和

00:03:18.420 --> 00:03:24.540
其实那些是那种

00:03:20.700 --> 00:03:26.190
往往会在你

00:03:24.540 --> 00:03:27.900
进行技术开发，而不仅仅是

00:03:26.190 --> 00:03:29.370
想着你就知道我怎么得到

00:03:27.900 --> 00:03:31.440
在六个月内就想到了

00:03:29.370 --> 00:03:33.420
你知道这将如何持续

00:03:31.440 --> 00:03:35.730
你知道怎么看

00:03:33.420 --> 00:03:37.110
五年或十年后， 

00:03:35.730 --> 00:03:39.360
我在此功能中所做的事情是

00:03:37.110 --> 00:03:42.930
使我们能够做新事物

00:03:39.360 --> 00:03:45.300
前进或阻止我们做

00:03:42.930 --> 00:03:47.880
我们想要做的一些事情

00:03:45.300 --> 00:03:51.270
知道那些是深层的东西

00:03:47.880 --> 00:03:52.650
我们想到的我会说你

00:03:51.270 --> 00:03:54.600
知道我何时提到邮件列表

00:03:52.650 --> 00:03:58.170
我们也正在尝试做这些项目

00:03:54.600 --> 00:04:00.600
与早期访问二进制文件，所以迈克尔

00:03:58.170 --> 00:04:02.040
稍后会提供一些链接

00:04:00.600 --> 00:04:04.680
实际去下载二进制文件

00:04:02.040 --> 00:04:05.850
您是否知道的早期访问版本

00:04:04.680 --> 00:04:08.880
我们正在开发的一些功能

00:04:05.850 --> 00:04:10.980
现在尝试一下，直到告诉我们

00:04:08.880 --> 00:04:13.200
您的想法，因为最终您

00:04:10.980 --> 00:04:14.520
知道我们要做的事情我们不做

00:04:13.200 --> 00:04:16.859
只是因为他们很有趣

00:04:14.520 --> 00:04:18.989
您知道Java的学术练习

00:04:16.859 --> 00:04:21.090
是一种非常存在的技术

00:04:18.989 --> 00:04:23.250
被使用并希望人们使用它

00:04:21.090 --> 00:04:25.320
如果你愿意的话，我们只能把它做好

00:04:23.250 --> 00:04:30.330
告诉我们它如何真正为您工作

00:04:25.320 --> 00:04:32.159
生活还不错，让我们看看我想你知道

00:04:30.330 --> 00:04:35.279
这里也

00:04:32.159 --> 00:04:37.289
距离你二十五年半

00:04:35.279 --> 00:04:39.929
知道我们认为Java是一种

00:04:37.289 --> 00:04:42.179
与您非常相关且充满活力

00:04:39.929 --> 00:04:44.489
知道这在我们的行业中往往很难

00:04:42.179 --> 00:04:48.360
使技术得以持久并保持

00:04:44.489 --> 00:04:50.969
流行，但您知道我们将Java视为

00:04:48.360 --> 00:04:53.129
今天与之相关的技术

00:04:50.969 --> 00:04:53.489
那是10年前，因为是20年

00:04:53.129 --> 00:04:55.559
前

00:04:53.489 --> 00:04:58.019
部分原因是我们

00:04:55.559 --> 00:05:01.189
不断投资于继续

00:04:58.019 --> 00:05:03.419
解决问题，让生活更轻松

00:05:01.189 --> 00:05:06.659
你可以看到就知道了一点

00:05:03.419 --> 00:05:08.490
那里的路线图和一点点

00:05:06.659 --> 00:05:11.129
你的小图知道一个地方

00:05:08.490 --> 00:05:15.509
可以测量这些东西

00:05:11.129 --> 00:05:17.099
您知道Java的普及程度， 

00:05:15.509 --> 00:05:18.779
我们经常考虑的领域

00:05:17.099 --> 00:05:21.869
现在，我确定你也这样做

00:05:18.779 --> 00:05:23.939
是javo对云的准备， 

00:05:21.869 --> 00:05:25.919
那里的技术有多适合

00:05:23.939 --> 00:05:28.800
这是你知道的我们

00:05:25.919 --> 00:05:30.509
我们非常有热情并且有

00:05:28.800 --> 00:05:32.610
一直积极投入功能

00:05:30.509 --> 00:05:34.409
考虑如何才能使

00:05:32.610 --> 00:05:37.079
在云中使用Java的经验

00:05:34.409 --> 00:05:38.639
工作真的很好，有一些

00:05:37.079 --> 00:05:40.829
这项权利的有趣方面

00:05:38.639 --> 00:05:43.469
以为你知道我们其中的一件事

00:05:40.829 --> 00:05:44.909
倾向于看到我你知道去问人

00:05:43.469 --> 00:05:48.029
你知道这很重要还是

00:05:44.909 --> 00:05:50.399
这个重要的例子有多少

00:05:48.029 --> 00:05:54.240
认为占地面积小且速度快

00:05:50.399 --> 00:05:56.249
启动时间很重要，我当然知道

00:05:54.240 --> 00:05:59.490
是的，几乎每个人都有多少人

00:05:56.249 --> 00:06:04.559
认为大量的堆和低延迟

00:05:59.490 --> 00:06:08.579
是很重要的，所以如果你在做

00:06:04.559 --> 00:06:10.319
像ml或您知道AI的东西

00:06:08.579 --> 00:06:11.999
知道你想要能够处理

00:06:10.319 --> 00:06:13.619
以及，所以你知道这是一种

00:06:11.999 --> 00:06:15.899
有趣的权利，我们有这些你

00:06:13.619 --> 00:06:17.009
知道很多的两种问题

00:06:15.899 --> 00:06:19.379
方式是不同的

00:06:17.009 --> 00:06:21.029
方向，如果你问别人

00:06:19.379 --> 00:06:23.429
他们走是很重要的

00:06:21.029 --> 00:06:26.039
那些很好，我们会尽力做到的

00:06:23.429 --> 00:06:27.419
您所知道的一切我们想做的一切

00:06:26.039 --> 00:06:28.559
这些东西很好，我希望

00:06:27.419 --> 00:06:30.449
我们将要讨论的一些项目

00:06:28.559 --> 00:06:32.490
今天大约会给你一些见识

00:06:30.449 --> 00:06:38.849
进入我们正在做的一些事情

00:06:32.490 --> 00:06:41.579
好的，所以Java作为一种技术是

00:06:38.849 --> 00:06:44.340
受欢迎的东西

00:06:41.579 --> 00:06:47.310
今天，因为有许多供应商参与

00:06:44.340 --> 00:06:49.980
在发展中，这是事实

00:06:47.310 --> 00:06:52.740
自从我们开始以来

00:06:49.980 --> 00:06:56.270
在Sun的Java上开始，这是事实

00:06:52.740 --> 00:07:00.030
今天，我们在开放式JDK中进行开发

00:06:56.270 --> 00:07:02.310
一件好事是你可以

00:07:00.030 --> 00:07:04.950
实际看到签到发生，您可以

00:07:02.310 --> 00:07:09.090
看到发生的评论，您基本上可以

00:07:04.950 --> 00:07:10.590
去看看谁在做什么，我认为

00:07:09.090 --> 00:07:12.660
你知道这是一种很好的方法

00:07:10.590 --> 00:07:15.720
深入了解

00:07:12.660 --> 00:07:18.120
投资正朝着工作方向发展

00:07:15.720 --> 00:07:19.980
今天和未来

00:07:18.120 --> 00:07:22.700
 Java的基础，如您所见

00:07:19.980 --> 00:07:25.260
有很多人参加

00:07:22.700 --> 00:07:27.930
现实是大部分投资

00:07:25.260 --> 00:07:31.340
今天发生的事情来自

00:07:27.930 --> 00:07:33.480
 Oracle，这就是很好的了解

00:07:31.340 --> 00:07:36.150
这些是我们要进行的项目

00:07:33.480 --> 00:07:38.880
在这里经历一点

00:07:36.150 --> 00:07:41.970
想首先提一下，我知道我的一个

00:07:38.880 --> 00:07:43.740
同事们在展厅里

00:07:41.970 --> 00:07:45.720
说他得到很多

00:07:43.740 --> 00:07:48.840
人们对发布的疑问

00:07:45.720 --> 00:07:50.490
节奏和支持模型，所以我

00:07:48.840 --> 00:07:52.440
很高兴回答有关您的问题

00:07:50.490 --> 00:07:54.990
可能稍后在

00:07:52.440 --> 00:07:58.380
会议或明天，我认为

00:07:54.990 --> 00:08:01.940
要了解的重要一点是

00:07:58.380 --> 00:08:06.060
过去我们有一个非常非常

00:08:01.940 --> 00:08:07.920
两次发布之间的时间较长

00:08:06.060 --> 00:08:10.020
基本上会发生的是我们会

00:08:07.920 --> 00:08:11.520
去吧，有点你知道坐在伊拉克下

00:08:10.020 --> 00:08:13.320
并长期从事研究工作， 

00:08:11.520 --> 00:08:15.090
那我们就出来

00:08:13.320 --> 00:08:17.580
你知道的东西很大

00:08:15.090 --> 00:08:21.120
通常你知道发生了很大的变化

00:08:17.580 --> 00:08:23.460
并且经常是破坏性的

00:08:21.120 --> 00:08:25.740
其结果是，通常需要一个

00:08:23.460 --> 00:08:28.830
人们需要长时间适应

00:08:25.740 --> 00:08:30.120
破坏，你要知道

00:08:28.830 --> 00:08:32.220
应用程序并将其移至

00:08:30.120 --> 00:08:33.750
下一个版本或开始写新的

00:08:32.220 --> 00:08:36.420
利用的东西

00:08:33.750 --> 00:08:39.690
这些新版本中的内容

00:08:36.420 --> 00:08:42.420
已经做了，实际上我们从两个开始

00:08:39.690 --> 00:08:45.000
多年前是我们已经转向模特

00:08:42.420 --> 00:08:46.200
我们经常释放，所以我们

00:08:45.000 --> 00:08:49.020
每个都有新版本

00:08:46.200 --> 00:08:50.970
六个月，当然我们不是

00:08:49.020 --> 00:08:52.590
我们还没有挥动魔杖

00:08:50.970 --> 00:08:55.650
突然之间我们可以知道

00:08:52.590 --> 00:08:57.570
六个月内工作两三年

00:08:55.650 --> 00:09:00.330
相反，我们正在做的是

00:08:57.570 --> 00:09:04.320
有很多增量版本

00:09:00.330 --> 00:09:06.500
他们少了，我们仍然有相同的

00:09:04.320 --> 00:09:09.839
我们一直必须付出的奉献

00:09:06.500 --> 00:09:12.210
兼容性和能够上升

00:09:09.839 --> 00:09:14.970
到新版本，但有了这些

00:09:12.210 --> 00:09:16.830
较小的增量将变得更容易

00:09:14.970 --> 00:09:18.990
您与您的应用程序一起移动

00:09:16.830 --> 00:09:21.839
前进权，所以我们的目标是

00:09:18.990 --> 00:09:23.300
真的从来没有什么大破坏力

00:09:21.839 --> 00:09:26.310
发行需要多年

00:09:23.300 --> 00:09:28.350
取而代之的是我们

00:09:26.310 --> 00:09:30.810
做并掌握在手中

00:09:28.350 --> 00:09:34.860
很快，基本上就是这样

00:09:30.810 --> 00:09:37.080
这个模型工作的是最新的

00:09:34.860 --> 00:09:40.320
发布永远是免费的

00:09:37.080 --> 00:09:44.160
所以我们直接产生的二进制文件

00:09:40.320 --> 00:09:47.370
从开放的JDK中可以找到

00:09:44.160 --> 00:09:49.470
 GPL v2下的开源许可证

00:09:47.370 --> 00:09:53.279
类路径，然后基本上

00:09:49.470 --> 00:09:55.710
总是对那些

00:09:53.279 --> 00:09:57.900
想要住在一个豪华的

00:09:55.710 --> 00:10:00.630
你知道的旧版本

00:09:57.900 --> 00:10:04.589
和你所知道的很多年

00:10:00.630 --> 00:10:06.209
公司，您知道我们提供LTS吗

00:10:04.589 --> 00:10:07.890
发布或长期支持发布

00:10:06.209 --> 00:10:11.580
非常类似于你知道你在做什么

00:10:07.890 --> 00:10:14.670
在Linux社区中看到

00:10:11.580 --> 00:10:17.670
基本上你会得到更新

00:10:14.670 --> 00:10:21.000
没有没有的新功能

00:10:17.670 --> 00:10:23.220
更改语言或api 

00:10:21.000 --> 00:10:25.950
基本上具有稳定性

00:10:23.220 --> 00:10:28.470
性能和安全修复等

00:10:25.950 --> 00:10:30.330
目的是那些是你

00:10:28.470 --> 00:10:32.459
如果有的话，对你来说很容易

00:10:30.330 --> 00:10:33.959
跑步的事情你知道很多

00:10:32.459 --> 00:10:35.130
人们有他们编写的应用程序

00:10:33.959 --> 00:10:36.330
几年前，他们正在运行

00:10:35.130 --> 00:10:39.330
他们只是想保持生产

00:10:36.330 --> 00:10:42.120
他们可能没有做正确的事

00:10:39.330 --> 00:10:43.470
一堆积极的发展

00:10:42.120 --> 00:10:44.900
这是非常适合的

00:10:43.470 --> 00:10:48.420
实际上，这是一个具有

00:10:44.900 --> 00:10:50.100
自从

00:10:48.420 --> 00:10:52.980
从一开始就完全一样

00:10:50.100 --> 00:10:56.160
适用于Java 6和Java 7，现在

00:10:52.980 --> 00:10:58.110
 Java 8和11的情况

00:10:56.160 --> 00:11:00.209
六个月后发布

00:10:58.110 --> 00:11:02.910
将会有一个有效的

00:11:00.209 --> 00:11:04.589
每三年就可以

00:11:02.910 --> 00:11:07.540
您可以选择拿走您的

00:11:04.589 --> 00:11:11.079
申请并像新一样前进

00:11:07.540 --> 00:11:13.480
出来，或者你可以选择做

00:11:11.079 --> 00:11:15.339
与我们或长期合作的支持

00:11:13.480 --> 00:11:17.050
另一个供应商有很多

00:11:15.339 --> 00:11:19.630
正如我所提到的，人们在那里

00:11:17.050 --> 00:11:22.209
你较早知道你想做什么

00:11:19.630 --> 00:11:24.180
积极支持Java我想做的一件事

00:11:22.209 --> 00:11:27.100
说要记住，如果你是

00:11:24.180 --> 00:11:29.709
考虑要去哪里买Java 

00:11:27.100 --> 00:11:31.959
是我向您显示的图表的更新

00:11:29.709 --> 00:11:35.319
在谁做正确的工作之前

00:11:31.959 --> 00:11:37.089
所以主要的是你，如果你是

00:11:35.319 --> 00:11:38.949
会从你的人那里获得更新

00:11:37.089 --> 00:11:42.420
想知道他们是谁

00:11:38.949 --> 00:11:46.290
非常了解这项技术

00:11:42.420 --> 00:11:48.730
这个模型已经收到很好

00:11:46.290 --> 00:11:51.940
你可以在这里看到詹姆斯的报价

00:11:48.730 --> 00:11:53.920
州长，我认为有很多

00:11:51.940 --> 00:11:56.709
那些谈论这个但

00:11:53.920 --> 00:11:58.959
不要谈论实际的价格，所以我

00:11:56.709 --> 00:12:00.490
以为你知道有人来了

00:11:58.959 --> 00:12:02.560
我说很好，他们有印象

00:12:00.490 --> 00:12:04.750
甲骨文很贵

00:12:02.560 --> 00:12:06.550
我们实际上基于此定价

00:12:04.750 --> 00:12:08.829
尝试使其变得简单和容易

00:12:06.550 --> 00:12:12.579
价格便宜，但与您的规模

00:12:08.829 --> 00:12:14.470
用法，所以我们看了其他种类的

00:12:12.579 --> 00:12:16.209
人们在类似情况下使用的软件

00:12:14.470 --> 00:12:18.490
用Java的方式来了解什么

00:12:16.209 --> 00:12:21.190
合理的模型是你可以看到

00:12:18.490 --> 00:12:24.279
这里的价格每月$ 25 

00:12:21.190 --> 00:12:27.130
服务器和2美元和50美分，用于

00:12:24.279 --> 00:12:29.110
台式机，它与

00:12:27.130 --> 00:12:30.519
音量合适，所以如果您知道

00:12:29.110 --> 00:12:32.800
成千上万的服务器，这不是价格

00:12:30.519 --> 00:12:35.199
您将要付款，实际上

00:12:32.800 --> 00:12:36.910
价格在网站上，如果

00:12:35.199 --> 00:12:40.750
如果您对什么感兴趣

00:12:36.910 --> 00:12:43.449
折扣还可以，然后

00:12:40.750 --> 00:12:44.740
当然你知道你得到所有

00:12:43.449 --> 00:12:46.540
你期望你知道几年的事情

00:12:44.740 --> 00:12:48.639
有能力的支持

00:12:46.540 --> 00:12:50.470
知道打电话给我们，有人在我身上

00:12:48.639 --> 00:12:53.230
团队的权利，这样你就可以找到

00:12:50.470 --> 00:12:54.790
写你知道一种特定的语言

00:12:53.230 --> 00:12:59.800
能够成为

00:12:54.790 --> 00:13:01.360
谁为你做固定的

00:12:59.800 --> 00:13:03.490
我要交给迈克尔

00:13:01.360 --> 00:13:05.920
他将要谈论这个

00:13:03.490 --> 00:13:12.269
我前面提到的项目我们正在做

00:13:05.920 --> 00:13:12.269
正在进行的开发，谢谢乔治

00:13:12.730 --> 00:13:16.179
哦，我也应该说我是迈克尔

00:13:14.499 --> 00:13:18.819
我曾在JBM团队工作

00:13:16.179 --> 00:13:20.499
甲骨文，我要谈一点

00:13:18.819 --> 00:13:22.389
我们正在研究的产品不是

00:13:20.499 --> 00:13:24.160
我想我会覆盖所有的人

00:13:22.389 --> 00:13:26.019
好像有40个不同的项目在公开

00:13:24.160 --> 00:13:27.639
 JDK告诉并非所有事情都在

00:13:26.019 --> 00:13:29.139
积极发展，但我会谈谈

00:13:27.639 --> 00:13:31.379
最重要的几个

00:13:29.139 --> 00:13:33.429
基本上是气泡中的那些

00:13:31.379 --> 00:13:35.649
所以我首先要说的是

00:13:33.429 --> 00:13:37.749
就像乔治前面提到的

00:13:35.649 --> 00:13:39.639
产品正在公开开发中

00:13:37.749 --> 00:13:41.709
如果您想知道发生了什么

00:13:39.639 --> 00:13:43.600
如果您想查看代码或播放

00:13:41.709 --> 00:13:45.519
围绕它，您可以访问

00:13:43.600 --> 00:13:47.980
邮件列表，您可以获取我们执行的代码

00:13:45.519 --> 00:13:49.989
发布早期访问二进制文件，我有

00:13:47.980 --> 00:13:52.569
最后有一些链接的幻灯片

00:13:49.989 --> 00:13:54.189
我们确实需要您的帮助测试

00:13:52.569 --> 00:13:55.899
事情并给我们反馈

00:13:54.189 --> 00:13:59.049
我们知道我们所拥有的功能

00:13:55.899 --> 00:14:00.669
实际上与您相关

00:13:59.049 --> 00:14:03.220
这个项目就像过去

00:14:00.669 --> 00:14:05.879
这些就像每两个两个发布和一个

00:14:03.220 --> 00:14:08.829
三年半我们非常

00:14:05.879 --> 00:14:11.109
功能驱动的发布，所以我们尽早

00:14:08.829 --> 00:14:12.749
在早期我们选择了哪些功能

00:14:11.109 --> 00:14:15.069
进入某个版本，然后

00:14:12.749 --> 00:14:16.689
经理我们经理我们到处跑

00:14:15.069 --> 00:14:18.040
积极主动地表达

00:14:16.689 --> 00:14:19.149
两个半会发生什么

00:14:18.040 --> 00:14:22.660
或从现在起三年后

00:14:19.149 --> 00:14:24.100
在一定时间内无法正常工作

00:14:22.660 --> 00:14:26.379
发布我们现在拥有的模型

00:14:24.100 --> 00:14:28.329
我们每六个月发布一次

00:14:26.379 --> 00:14:29.709
就像是在特定的日子，所以我们

00:14:28.329 --> 00:14:31.989
需要改变我们的整体方式

00:14:29.709 --> 00:14:33.459
开发更多的东西

00:14:31.989 --> 00:14:35.049
现在正在进行内部开发

00:14:33.459 --> 00:14:37.419
项目，那些是那些

00:14:35.049 --> 00:14:39.730
我将经历，我们将尝试做的事情

00:14:37.419 --> 00:14:41.319
虽然我确定了一些子集

00:14:39.730 --> 00:14:43.089
可以独立存在的功能

00:14:41.319 --> 00:14:45.040
并逐步提供更多

00:14:43.089 --> 00:14:46.929
很快我们就不会实施

00:14:45.040 --> 00:14:49.959
整个项目，然后才实际投入

00:14:46.929 --> 00:14:51.610
在主线上，所以再次

00:14:49.959 --> 00:14:53.410
这些产品正在开发中

00:14:51.610 --> 00:14:55.089
一边，但像它的一部分，我们

00:14:53.410 --> 00:14:57.220
试图吸收实际融入

00:14:55.089 --> 00:15:00.309
主线，即使产品然后

00:14:57.220 --> 00:15:02.259
继续过着正确的生活，特别是

00:15:00.309 --> 00:15:06.220
对于琥珀色的产品，我将展示几个

00:15:02.259 --> 00:15:07.869
迄今为止最大的例子

00:15:06.220 --> 00:15:10.569
还有我们最复杂的产品

00:15:07.869 --> 00:15:12.759
现在要去瓦尔哈拉，所以

00:15:10.569 --> 00:15:15.999
该产品正在考虑添加什么

00:15:12.759 --> 00:15:17.949
以前直到上周才知道

00:15:15.999 --> 00:15:20.319
不应该说过去会用什么

00:15:17.949 --> 00:15:23.829
叫我现在就来新学期

00:15:20.319 --> 00:15:24.449
在线型或线类中

00:15:23.829 --> 00:15:29.549
什么

00:15:24.449 --> 00:15:32.519
第一个测验是这种类型的

00:15:29.549 --> 00:15:34.230
无状态，就像我创建时一样

00:15:32.519 --> 00:15:36.149
我实际上进去改变了一些

00:15:34.230 --> 00:15:37.259
那里有东西吗

00:15:36.149 --> 00:15:40.679
我可以做的人会提到

00:15:37.259 --> 00:15:42.480
反射中忽略反射好吗

00:15:40.679 --> 00:15:44.040
答案是确实应该

00:15:42.480 --> 00:15:45.839
写一切都应该是最终的

00:15:44.040 --> 00:15:47.970
只读，您无法影响

00:15:45.839 --> 00:15:51.480
一旦创建，这仅仅是

00:15:47.970 --> 00:15:53.429
几乎正确的问题是

00:15:51.480 --> 00:15:55.439
 Java中的实例可以同步

00:15:53.429 --> 00:15:57.209
您可能不会认为这说明

00:15:55.439 --> 00:15:59.790
生活在实例中但在那里

00:15:57.209 --> 00:16:01.499
任何物体中的任何物体都可以

00:15:59.790 --> 00:16:03.720
可以同步，就像

00:16:01.499 --> 00:16:05.730
隐藏状态JVM的状态

00:16:03.720 --> 00:16:07.889
需要牢记，这使得

00:16:05.730 --> 00:16:09.449
这个物体以某种方式携带状态

00:16:07.889 --> 00:16:11.699
尽管在Java级别

00:16:09.449 --> 00:16:14.309
有点不对，是的

00:16:11.699 --> 00:16:17.040
关于状态的其他细微之处

00:16:14.309 --> 00:16:19.439
在这种情况下的身份

00:16:17.040 --> 00:16:21.269
实例我们实际上保证这是

00:16:19.439 --> 00:16:22.889
就像规范中的说，如果您有

00:16:21.269 --> 00:16:24.419
一个实例，您可以将其与

00:16:22.889 --> 00:16:25.739
另一个瞬间，同一实例

00:16:24.419 --> 00:16:27.839
可以用两个不同的实例

00:16:25.739 --> 00:16:31.139
我们将向您保证的方式，如果您

00:16:27.839 --> 00:16:32.819
对它做双重等于，你会成真， 

00:16:31.139 --> 00:16:35.069
具体而言是

00:16:32.819 --> 00:16:37.589
 JVM确实需要保持很多

00:16:35.069 --> 00:16:39.660
有关此实例的信息

00:16:37.589 --> 00:16:41.220
如果我这样说的话，一个唯一的地方

00:16:39.660 --> 00:16:45.480
在那个地方通常在Java上

00:16:41.220 --> 00:16:47.279
堆我也有身份哈希码

00:16:45.480 --> 00:16:50.339
他们不要与对象混淆

00:16:47.279 --> 00:16:53.279
哈希码，但相同的概念相同的身份

00:16:50.339 --> 00:16:55.649
所以JVM通常会做什么

00:16:53.279 --> 00:16:57.449
显然，这可能取决于您的JVM 

00:16:55.649 --> 00:16:59.039
实现但是JVM是什么

00:16:57.449 --> 00:17:01.230
通常所做的是

00:16:59.039 --> 00:17:03.749
就像每个实例的开始

00:17:01.230 --> 00:17:05.909
 Java堆中有一个标头，我们

00:17:03.749 --> 00:17:08.039
在那里存储各种信息

00:17:05.909 --> 00:17:10.110
显然实例的类型但是

00:17:08.039 --> 00:17:11.760
也像这个对象被锁定

00:17:10.110 --> 00:17:13.679
在那种情况下，实际上哪个线程

00:17:11.760 --> 00:17:16.319
锁定它和类似的东西现在

00:17:13.679 --> 00:17:18.059
问题是我们像我一样

00:17:16.319 --> 00:17:19.620
提到需要保持单一

00:17:18.059 --> 00:17:22.350
我们需要确切知道的独特实例

00:17:19.620 --> 00:17:25.769
它在哪里，在哪

00:17:22.350 --> 00:17:27.600
陈述它的存在并减少数量

00:17:25.769 --> 00:17:32.100
我们可以在内部进行的优化

00:17:27.600 --> 00:17:35.370
 JVM，例如，如果您有

00:17:32.100 --> 00:17:38.790
一个JDK，然后下载并创建

00:17:35.370 --> 00:17:41.820
此用户定义的点类型

00:17:38.790 --> 00:17:43.860
然后创建一个数组

00:17:41.820 --> 00:17:46.110
点，所以我们现在有一堆

00:17:43.860 --> 00:17:47.640
 Java堆上的不同点

00:17:46.110 --> 00:17:49.500
会看起来像这样，所以你会有一个

00:17:47.640 --> 00:17:51.240
所有小实例的数量

00:17:49.500 --> 00:17:53.070
他们分散的不同点

00:17:51.240 --> 00:17:55.380
跨堆，然后你有一个

00:17:53.070 --> 00:17:58.140
存储指向那些指针的数组

00:17:55.380 --> 00:18:00.000
个体实例，所以有很多

00:17:58.140 --> 00:18:01.770
第一个问题是

00:18:00.000 --> 00:18:03.480
如果您实际上想说要

00:18:01.770 --> 00:18:05.070
遍历您现在的所有要点

00:18:03.480 --> 00:18:06.650
指针追逐整个youb，所以你

00:18:05.070 --> 00:18:08.610
不要得到这个的缓存位置

00:18:06.650 --> 00:18:10.740
第二件事是你拥有所有

00:18:08.610 --> 00:18:12.840
标头，所以现在您正在使用很多

00:18:10.740 --> 00:18:14.520
更多的内存可以有效地存储

00:18:12.840 --> 00:18:18.270
最后的信息

00:18:14.520 --> 00:18:20.190
 x和y坐标，那么汉拿又如何

00:18:18.270 --> 00:18:23.040
该产品正在努力实现

00:18:20.190 --> 00:18:25.230
其他事情是这个，我想你们大多数人

00:18:23.040 --> 00:18:27.030
也许你知道这是如此明显

00:18:25.230 --> 00:18:29.160
对，为什么我们还没有做

00:18:27.030 --> 00:18:31.290
这在这里你有一个紧凑

00:18:29.160 --> 00:18:32.940
表示没有开销

00:18:31.290 --> 00:18:34.560
单独的标题，如果您迭代

00:18:32.940 --> 00:18:36.480
该数组，您拥有所有缓存

00:18:34.560 --> 00:18:39.330
在本地，CPU将预取

00:18:36.480 --> 00:18:42.030
你们所有那些美好的事物，为什么这是

00:18:39.330 --> 00:18:44.790
复杂的事实证明，这

00:18:42.030 --> 00:18:46.890
概念是否需要改变

00:18:44.790 --> 00:18:49.860
 Java语言级别的所有内容

00:18:46.890 --> 00:18:54.000
一直到最深处

00:18:49.860 --> 00:18:57.000
复杂的，比方说复杂的部分

00:18:54.000 --> 00:18:58.500
虚拟机的数量非常大

00:18:57.000 --> 00:19:01.080
项目，因为它涵盖了所有这些

00:18:58.500 --> 00:19:03.000
级别并返回您的弹壳

00:19:01.080 --> 00:19:05.520
真的很兼容

00:19:03.000 --> 00:19:07.050
认真，所以如果我们能进去

00:19:05.520 --> 00:19:08.430
改变它就像放在第一个

00:19:07.050 --> 00:19:10.350
 Java规范版本或类似

00:19:08.430 --> 00:19:11.640
一夜之间，我们只是把它放在那里

00:19:10.350 --> 00:19:14.010
像我们删除所有东西

00:19:11.640 --> 00:19:16.500
否则那已经是正确的事情

00:19:14.010 --> 00:19:18.360
会很容易，但是问题就变成了

00:19:16.500 --> 00:19:21.030
如果您有旧代码会怎样？ 

00:19:18.360 --> 00:19:23.490
假设已经编译了库代码

00:19:21.030 --> 00:19:25.560
你知道这是完美的

00:19:23.490 --> 00:19:27.870
有人完成的最佳哈希图

00:19:25.560 --> 00:19:31.410
为你，你传递这些新的

00:19:27.870 --> 00:19:33.060
正确的对象或相反的对象

00:19:31.410 --> 00:19:34.680
我们需要非常仔细地考虑

00:19:33.060 --> 00:19:36.270
并有个故事

00:19:34.680 --> 00:19:39.150
在所有这些情况下，因为最后

00:19:36.270 --> 00:19:40.320
我们想要的是让Java演变成

00:19:39.150 --> 00:19:42.270
看起来和感觉都没有的东西

00:19:40.320 --> 00:19:45.840
像Java了，那是行不通的

00:19:42.270 --> 00:19:48.450
语法看起来像这样

00:19:45.840 --> 00:19:50.490
可能会像

00:19:48.450 --> 00:19:50.850
下划线应使其明显，但它

00:19:50.490 --> 00:19:54.060
可能

00:19:50.850 --> 00:19:56.550
 ECS基本上是在课堂上说

00:19:54.060 --> 00:19:58.350
你得到这个，就像vm和

00:19:56.550 --> 00:20:01.410
图书馆弄清楚该怎么做

00:19:58.350 --> 00:20:03.270
对您而言，我们对该项目的口号是

00:20:01.410 --> 00:20:05.970
像一类的代码一样长

00:20:03.270 --> 00:20:08.100
像int一样工作，意味着您得到了所有

00:20:05.970 --> 00:20:10.410
 Java的灵活性和强大功能

00:20:08.100 --> 00:20:12.000
您可以添加方法的类

00:20:10.410 --> 00:20:15.300
计算可以传递给他们

00:20:12.000 --> 00:20:16.770
但您获得了

00:20:15.300 --> 00:20:18.540
简单的原始，因为我们都知道

00:20:16.770 --> 00:20:22.590
将它传递到圆上

00:20:18.540 --> 00:20:25.200
非常有效而又快速

00:20:22.590 --> 00:20:27.510
在大多数方面都喜欢用户角度

00:20:25.200 --> 00:20:31.230
这里唯一可见的变化是

00:20:27.510 --> 00:20:33.090
快得多，所以我们如何激励

00:20:31.230 --> 00:20:34.980
对的是这样快多少

00:20:33.090 --> 00:20:37.440
我们已经花了超过五个

00:20:34.980 --> 00:20:38.790
十年现在很容易许多人

00:20:37.440 --> 00:20:40.920
这个项目已经存在，我们仍然

00:20:38.790 --> 00:20:43.800
还没有交付任何东西，我们怎么能

00:20:40.920 --> 00:20:47.430
激励这个项目，让我们来看一个

00:20:43.800 --> 00:20:50.280
例子，所以我们在这里矩阵

00:20:47.430 --> 00:20:52.380
乘法，所以它是一个简单的复数

00:20:50.280 --> 00:20:54.620
类，所以它是一个复数，存储在

00:20:52.380 --> 00:20:57.240
矩阵，有几个

00:20:54.620 --> 00:20:59.310
在这种情况下，运算加法和乘法

00:20:57.240 --> 00:21:00.450
他们做了你所期望的

00:20:59.310 --> 00:21:03.660
做正确的事，所以他们创造了一个新的

00:21:00.450 --> 00:21:05.400
实例取值multiplay 

00:21:03.660 --> 00:21:10.350
还有什么其他的东西，并返回一个新的

00:21:05.400 --> 00:21:14.460
因此，基本上，如果我们想做一个

00:21:10.350 --> 00:21:15.810
再次乘以这个，我从

00:21:14.460 --> 00:21:17.160
某个地方，所以我确定有人

00:21:15.810 --> 00:21:20.040
验证代码是否确实

00:21:17.160 --> 00:21:22.830
正确的一点是，为了

00:21:20.040 --> 00:21:24.840
为此，您正在创建一个新

00:21:22.830 --> 00:21:27.870
复杂一个新的矩阵，基本上是

00:21:24.840 --> 00:21:30.480
您正在使用现有矩阵

00:21:27.870 --> 00:21:32.610
您正在创建一个新的权利， 

00:21:30.480 --> 00:21:34.530
有很多指针在此追逐

00:21:32.610 --> 00:21:39.090
里面有很多分配

00:21:34.530 --> 00:21:41.490
这段代码，所以今天在JDK上运行

00:21:39.090 --> 00:21:43.080
与使用新值来运行

00:21:41.490 --> 00:21:45.690
类型功能看起来会有些变化

00:21:43.080 --> 00:21:47.310
像这样，它说那里写

00:21:45.690 --> 00:21:51.000
您的里程可能会有所不同，所有这些

00:21:47.310 --> 00:21:53.430
但重点是这里的盒装版本

00:21:51.000 --> 00:21:55.410
现有的，可以说是正常的吗

00:21:53.430 --> 00:21:57.810
实例，其值版本为

00:21:55.410 --> 00:21:59.640
当你自由的时候

00:21:57.810 --> 00:22:01.650
一定把它放在堆上，但把

00:21:59.640 --> 00:22:03.420
它在堆栈本地的寄存器中

00:22:01.650 --> 00:22:03.900
无需进行所有优化

00:22:03.420 --> 00:22:05.370
照顾

00:22:03.900 --> 00:22:07.830
但是那个身份和所有东西

00:22:05.370 --> 00:22:11.460
对，这样您就可以在此处看到因素

00:22:07.830 --> 00:22:14.550
时间减少了十二倍

00:22:11.460 --> 00:22:17.430
少一千倍的记忆

00:22:14.550 --> 00:22:19.290
分配它是三好，然后

00:22:17.430 --> 00:22:21.480
获得更多的特定于CPU，但更少

00:22:19.290 --> 00:22:23.460
指令正在执行

00:22:21.480 --> 00:22:24.960
每条指令实际上都更快

00:22:23.460 --> 00:22:27.630
因为等待的机会少了很多

00:22:24.960 --> 00:22:29.220
记忆之类的东西，所以选择你的

00:22:27.630 --> 00:22:30.810
最喜欢的指标，但这很漂亮

00:22:29.220 --> 00:22:33.870
重大权利，如果您可以加快速度

00:22:30.810 --> 00:22:35.760
 Java介于两个六点之间

00:22:33.870 --> 00:22:38.130
一千次，我们做得很好

00:22:35.760 --> 00:22:41.900
对，所以这就是为什么我们认为

00:22:38.130 --> 00:22:44.790
该项目仍然值得投资，并且

00:22:41.900 --> 00:22:46.680
发生了很多很酷的事情

00:22:44.790 --> 00:22:48.930
在这里，我们已经到了这一点

00:22:46.680 --> 00:22:51.210
现在投射我们实际所在的位置

00:22:48.930 --> 00:22:53.820
不只是看现有的像

00:22:51.210 --> 00:22:55.560
下一个里程碑或可交付成果，但

00:22:53.820 --> 00:22:57.450
不仅如此，我们该如何做

00:22:55.560 --> 00:22:59.190
确保无论我们最终以

00:22:57.450 --> 00:23:01.590
最少有某种可能性

00:22:59.190 --> 00:23:04.920
为了将来的安全，我们希望

00:23:01.590 --> 00:23:06.570
在此基础上构建其他内容

00:23:04.920 --> 00:23:08.070
例如，它变得更加有趣

00:23:06.570 --> 00:23:09.720
当您将泛型添加到整个

00:23:08.070 --> 00:23:12.210
故事，如果你想拥有会发生什么

00:23:09.720 --> 00:23:16.410
一个通用的原始图让我们留下

00:23:12.210 --> 00:23:20.370
就像一个很酷的项目

00:23:16.410 --> 00:23:22.410
关于它，我要说的第二个产品

00:23:20.370 --> 00:23:24.930
关于这个琥珀色的琥珀色是

00:23:22.410 --> 00:23:29.040
有效地制成的产品

00:23:24.930 --> 00:23:30.720
小语言改进，所以

00:23:29.040 --> 00:23:34.470
标语是正确的尺寸

00:23:30.720 --> 00:23:37.710
语言仪式的正确尺寸在这里

00:23:34.470 --> 00:23:39.210
并不意味着剥离Java语法

00:23:37.710 --> 00:23:41.370
直到你知道的地方

00:23:39.210 --> 00:23:44.070
神秘的我们仍然希望它可读

00:23:41.370 --> 00:23:46.890
您阅读的代码远胜于编写的代码

00:23:44.070 --> 00:23:49.590
没错，但它正在尝试确定

00:23:46.890 --> 00:23:51.330
常见的模式，并使其更容易

00:23:49.590 --> 00:23:53.010
实现代码并且更容易实现

00:23:51.330 --> 00:23:55.500
最后还要阅读代码，所以我去了

00:23:53.010 --> 00:23:57.870
通过其中一些子功能

00:23:55.500 --> 00:24:00.630
让我们说这个项目的第一个

00:23:57.870 --> 00:24:04.010
是局部变量类型推断，因此

00:24:00.630 --> 00:24:13.460
首先是民意调查这里有多少人

00:24:04.010 --> 00:24:13.460
使用Java 8 Java 9 10 11 12 

00:24:14.170 --> 00:24:22.250
 13好了，有多少人玩过

00:24:18.260 --> 00:24:24.440
大约10点或更晚的时间还可以

00:24:22.250 --> 00:24:25.850
很多人专门尝试了var 

00:24:24.440 --> 00:24:30.800
或局部变量类型推断

00:24:25.850 --> 00:24:32.510
好的，你们几个，这是其中之一

00:24:30.800 --> 00:24:35.480
那些喜欢很多东西的小东西

00:24:32.510 --> 00:24:37.100
语言已经有了，如果你有代码

00:24:35.480 --> 00:24:39.740
看起来像这样，所以你

00:24:37.100 --> 00:24:41.240
知道正常打开一些输入尖叫， 

00:24:39.740 --> 00:24:42.830
获取流读取器和缓冲区

00:24:41.240 --> 00:24:44.480
阅读器以及您可能拥有的所有内容

00:24:42.830 --> 00:24:47.750
认识这种模式，这很漂亮

00:24:44.480 --> 00:24:49.130
在Java中到处都有

00:24:47.750 --> 00:24:50.690
可以看到这里显然是有一个

00:24:49.130 --> 00:24:52.790
我们说的是很多重复

00:24:50.690 --> 00:24:54.980
两者都重复相同的类型

00:24:52.790 --> 00:24:58.520
双方，你知道

00:24:54.980 --> 00:25:01.220
多余的你可以争论，所以我们做了什么

00:24:58.520 --> 00:25:03.590
是要实现一项称为本地的功能

00:25:01.220 --> 00:25:05.900
变量类型推断

00:25:03.590 --> 00:25:08.660
而不是说类型

00:25:05.900 --> 00:25:11.990
左手边，你现在可以说更多

00:25:08.660 --> 00:25:14.540
这不是使Java动态

00:25:11.990 --> 00:25:16.580
输入的唯一内容是

00:25:14.540 --> 00:25:19.790
具有Java C e或任何已编译的

00:25:16.580 --> 00:25:21.860
你用来找出类型

00:25:19.790 --> 00:25:23.870
它自己的像我们可以推断出我们一样

00:25:21.860 --> 00:25:25.370
知道它在这里说inputstreamreader 

00:25:23.870 --> 00:25:27.320
那为什么我们要再说一遍

00:25:25.370 --> 00:25:28.970
 Java c也是一样

00:25:27.320 --> 00:25:31.070
编译器就可以看看

00:25:28.970 --> 00:25:32.690
右边，你知道确定

00:25:31.070 --> 00:25:35.950
这是一个输入流阅读器，所以我会

00:25:32.690 --> 00:25:39.230
有点放在那里你以后不能

00:25:35.950 --> 00:25:40.790
在这里为读者分配其他类型

00:25:39.230 --> 00:25:42.230
除非很明显，它就像是

00:25:40.790 --> 00:25:44.240
输入流阅读器

00:25:42.230 --> 00:25:46.280
你不喜欢突然有它存储

00:25:44.240 --> 00:25:48.320
整数，所以在后台

00:25:46.280 --> 00:25:51.440
在这里，这个酒吧实际上做了

00:25:48.320 --> 00:25:55.550
扩展到这个权利，你可以不是

00:25:51.440 --> 00:25:57.260
它仍然是静态输入的，所以这是

00:25:55.550 --> 00:25:58.730
如果你有更多的玩具例子

00:25:57.260 --> 00:26:00.950
如果我们再看一些有趣的话

00:25:58.730 --> 00:26:02.360
复杂，所以这不是绝对的

00:26:00.950 --> 00:26:06.950
需要了解这段代码的作用

00:26:02.360 --> 00:26:09.170
但至少要指出的是

00:26:06.950 --> 00:26:10.250
这条线，尤其是这条线

00:26:09.170 --> 00:26:11.780
我要说很久了

00:26:10.250 --> 00:26:14.870
甚至无法将其放在一行上

00:26:11.780 --> 00:26:17.600
而且您有点需要它

00:26:14.870 --> 00:26:19.910
知道服务类型信息和

00:26:17.600 --> 00:26:21.590
你知道得到类型安全但是

00:26:19.910 --> 00:26:23.450
再次，这是你喜欢的人之一

00:26:21.590 --> 00:26:25.190
可能不写，如果你

00:26:23.450 --> 00:26:27.320
可以避免它实际上并没有给

00:26:25.190 --> 00:26:29.750
更多信息，为什么不拥有

00:26:27.320 --> 00:26:31.790
 Java C编译器还是有人

00:26:29.750 --> 00:26:33.590
否则为你找出正确的办法

00:26:31.790 --> 00:26:36.230
之后的版本也一样

00:26:33.590 --> 00:26:38.360
使用局部变量类型推断

00:26:36.230 --> 00:26:42.260
希望功能更多

00:26:38.360 --> 00:26:44.150
至少我认为是可读的

00:26:42.260 --> 00:26:46.490
你你没有像你没有迷路

00:26:44.150 --> 00:26:47.900
失去了类型安全性，希望再次

00:26:46.490 --> 00:26:49.550
这更有意义，你没有

00:26:47.900 --> 00:26:53.450
弄清楚你知道如何

00:26:49.550 --> 00:26:56.330
在那里拼写那个长类型的名字

00:26:53.450 --> 00:26:58.910
这是琥珀色的另一特性

00:26:56.330 --> 00:27:00.290
当前处于预览模式的一个

00:26:58.910 --> 00:27:01.760
所以这是我们要做的

00:27:00.290 --> 00:27:03.290
最近也介绍了

00:27:01.760 --> 00:27:05.840
预览功能或预览

00:27:03.290 --> 00:27:08.480
默认情况下未启用的功能

00:27:05.840 --> 00:27:10.490
他们还没有在Java规范中，但是

00:27:08.480 --> 00:27:13.610
他们把他们带到了重点

00:27:10.490 --> 00:27:16.160
我们要在哪里前进

00:27:13.610 --> 00:27:17.990
和他们在一起，但在我们锁定它们之前

00:27:16.160 --> 00:27:21.020
并把它们放在规格中

00:27:17.990 --> 00:27:22.730
需要一些反馈，以便使用

00:27:21.020 --> 00:27:24.440
这些我们介绍了几个

00:27:22.730 --> 00:27:27.050
您需要选择的选项

00:27:24.440 --> 00:27:30.050
在你不能不小心使用这个

00:27:27.050 --> 00:27:32.240
功能，所以您需要说启用

00:27:30.050 --> 00:27:34.790
预览并指定发布

00:27:32.240 --> 00:27:37.730
只是为了清楚地表明你是

00:27:34.790 --> 00:27:39.920
现在使用的是预览

00:27:37.730 --> 00:27:42.860
而且在运行时，您需要说是

00:27:39.920 --> 00:27:44.870
通过预览功能启用

00:27:42.860 --> 00:27:47.510
这个功能叫做开关表达式吧

00:27:44.870 --> 00:27:51.200
在12的预览中，我们希望

00:27:47.510 --> 00:27:54.800
放入13保存为支持

00:27:51.200 --> 00:27:57.500
那个说我们只知道什么的功能

00:27:54.800 --> 00:27:59.270
实际上是在13艘船上时

00:27:57.500 --> 00:28:01.370
这就是现在的世界新状况

00:27:59.270 --> 00:28:04.730
在GA之前，我们不会承诺任何事情

00:28:01.370 --> 00:28:07.490
那你知道，但是我们希望

00:28:04.730 --> 00:28:10.670
它变成13，所以我要告诉你

00:28:07.490 --> 00:28:13.280
这里有安娜的例子

00:28:10.670 --> 00:28:15.230
纽曼有几天，他们很好

00:28:13.280 --> 00:28:18.170
我希望有一个地方

00:28:15.230 --> 00:28:20.720
知道是里约热内卢

00:28:18.170 --> 00:28:23.360
是一种玩具示例，这是一种方法

00:28:20.720 --> 00:28:27.830
计算字符数

00:28:23.360 --> 00:28:30.860
以当天的名义，如果

00:28:27.830 --> 00:28:32.300
使用switch语句做到这一点

00:28:30.860 --> 00:28:34.400
这是显而易见的

00:28:32.300 --> 00:28:36.260
如果一天是星期一星期五或

00:28:34.400 --> 00:28:37.490
星期天他们都有六个字母，所以

00:28:36.260 --> 00:28:38.690
太棒了，我们将其放在

00:28:37.490 --> 00:28:40.580
变量和

00:28:38.690 --> 00:28:42.740
其他工作日也一样

00:28:40.580 --> 00:28:44.450
如果我们发现意外的一天，则为例外

00:28:42.740 --> 00:28:47.080
然后最后返回本地

00:28:44.450 --> 00:28:49.400
可变好吧，所以有几个

00:28:47.080 --> 00:28:50.960
首先有问题

00:28:49.400 --> 00:28:54.920
你可以争论的长面也

00:28:50.960 --> 00:28:56.480
你怎么知道像这里的模式是

00:28:54.920 --> 00:28:58.640
显然，您适合任何情况

00:28:56.480 --> 00:29:01.970
您想要设置局部变量定义

00:28:58.640 --> 00:29:03.290
一个局部变量，肯定在那里

00:29:01.970 --> 00:29:04.820
更好地做到这一点，因为

00:29:03.290 --> 00:29:07.100
现在有一种风险是

00:29:04.820 --> 00:29:09.110
如果您实际上忘记设置它，或者

00:29:07.100 --> 00:29:09.560
你知道你忘了休息或其他

00:29:09.110 --> 00:29:12.650
它是

00:29:09.560 --> 00:29:15.470
所以开关表达式为您服务的是

00:29:12.650 --> 00:29:17.720
让你来对待开关

00:29:15.470 --> 00:29:20.690
好像他们实际上返回的声明

00:29:17.720 --> 00:29:23.360
价值也是如此，在这种情况下， 

00:29:20.690 --> 00:29:25.490
更紧凑，有一种新语法

00:29:23.360 --> 00:29:28.040
讨论过，我应该说你在哪里

00:29:25.490 --> 00:29:30.890
可以说这三种情况

00:29:28.040 --> 00:29:33.500
有一个箭头语法，它返回

00:29:30.890 --> 00:29:35.690
六，特别是会发生什么

00:29:33.500 --> 00:29:38.090
然后是我提到的开关

00:29:35.690 --> 00:29:39.650
实际上我们把价值变成了，所以看这里

00:29:38.090 --> 00:29:42.410
在左边和今天

00:29:39.650 --> 00:29:43.880
你不能指定回报的种类

00:29:42.410 --> 00:29:45.440
开关右边的值是

00:29:43.880 --> 00:29:47.630
声明它不返回值

00:29:45.440 --> 00:29:51.710
但在新世界中，您实际上可以做到

00:29:47.630 --> 00:29:54.350
这样它就返回的值是

00:29:51.710 --> 00:29:55.790
正如我提到的在12中预览，然后

00:29:54.350 --> 00:29:58.130
为了完整起见，我会提到几个

00:29:55.790 --> 00:29:59.090
更多，未来更多

00:29:58.130 --> 00:30:01.130
有一种叫做模式

00:29:59.090 --> 00:30:03.140
匹配这是一个例子

00:30:01.130 --> 00:30:05.120
在这里得到的愿景是我们可以

00:30:03.140 --> 00:30:06.050
在开关中做同样的事情

00:30:05.120 --> 00:30:09.200
以及前进

00:30:06.050 --> 00:30:11.330
你们当中有多少人做到了

00:30:09.200 --> 00:30:12.710
检查您得到的一些实例并

00:30:11.330 --> 00:30:14.210
您正在根据类型检查

00:30:12.710 --> 00:30:16.010
接下来需要做的是

00:30:14.210 --> 00:30:18.650
正确地投放它，超级烦人

00:30:16.010 --> 00:30:20.450
重复明显的事情吧

00:30:18.650 --> 00:30:22.310
基本上你可以做的第一件事

00:30:20.450 --> 00:30:23.960
显然只是不重复类型

00:30:22.310 --> 00:30:25.760
两次使用局部变量类型

00:30:23.960 --> 00:30:27.620
推断，但接下来的内容

00:30:25.760 --> 00:30:30.110
模式匹配的一面是

00:30:27.620 --> 00:30:32.240
这些行，所以你有你的实例

00:30:30.110 --> 00:30:35.000
而不是像实例那样

00:30:32.240 --> 00:30:36.950
所有加上演员，你只是做

00:30:35.000 --> 00:30:39.260
编译器会帮您解决这个问题，所以您

00:30:36.950 --> 00:30:42.500
获取定义的变量，您可以使用

00:30:39.260 --> 00:30:46.970
在您的if语句中

00:30:42.500 --> 00:30:49.250
未来不好，我们正在研究它，但是

00:30:46.970 --> 00:30:51.140
绝对不会赚十三

00:30:49.250 --> 00:30:52.500
我要说的最后一件事

00:30:51.140 --> 00:30:55.170
提及是记录

00:30:52.500 --> 00:30:57.660
所以我要说另一个常见的例子

00:30:55.170 --> 00:30:59.690
所以简单的对象数据排序

00:30:57.660 --> 00:31:02.340
运营商，您有几个领域， 

00:30:59.690 --> 00:31:04.260
为了完成此任务，您需要

00:31:02.340 --> 00:31:06.300
让构造函数收集

00:31:04.260 --> 00:31:08.220
如果您想哈希码等于比较

00:31:06.300 --> 00:31:10.010
存储在某种类型的集合中

00:31:08.220 --> 00:31:12.930
显然，这只是全部

00:31:10.010 --> 00:31:14.970
手动添加容易出错的工作

00:31:12.930 --> 00:31:16.650
以及所有的权利，所以我们

00:31:14.970 --> 00:31:18.360
看着这里提供了一些东西

00:31:16.650 --> 00:31:20.430
再次拼写可能不是

00:31:18.360 --> 00:31:23.010
最终的拼写记录，但有些东西

00:31:20.430 --> 00:31:26.040
看起来像这样，如果你

00:31:23.010 --> 00:31:28.020
想要默认值，那么不需要

00:31:26.040 --> 00:31:29.970
不仅如此，但如果您确实想

00:31:28.020 --> 00:31:32.190
覆盖一些东西，例如

00:31:29.970 --> 00:31:35.370
等于具有某种魔法属性

00:31:32.190 --> 00:31:39.750
然后您可以在其中添加是的

00:31:35.370 --> 00:31:44.370
符合您的记录，所以我认为

00:31:39.750 --> 00:31:49.650
答案是肯定的，但事实并非如此

00:31:44.370 --> 00:31:51.480
设计好了，所以是琥珀色哦，我

00:31:49.650 --> 00:31:54.900
还应提及

00:31:51.480 --> 00:31:57.090
 JEP是JDK的缩写

00:31:54.900 --> 00:32:00.900
增强建议，这是我们的方式

00:31:57.090 --> 00:32:03.090
文档功能特点高

00:32:00.900 --> 00:32:05.600
我要说的水平提供一些

00:32:03.090 --> 00:32:07.740
替代品，你知道细节，但

00:32:05.600 --> 00:32:09.120
只是一个文件，你可以去看看

00:32:07.740 --> 00:32:17.640
这些都是开放的JDK 

00:32:09.120 --> 00:32:19.260
网站以及Loum是我们的产品

00:32:17.640 --> 00:32:24.600
看我们在哪里改善

00:32:19.260 --> 00:32:26.760
或简化并发性，所以今天

00:32:24.600 --> 00:32:28.170
基本上我有点简化你

00:32:26.760 --> 00:32:30.180
有两种不同的处理方式

00:32:28.170 --> 00:32:34.560
并发第一个正在使用

00:32:30.180 --> 00:32:37.260
同步代码，所以你有一个线程

00:32:34.560 --> 00:32:39.840
接受请求，尽其所能

00:32:37.260 --> 00:32:41.580
调出数据库或执行任何操作

00:32:39.840 --> 00:32:43.800
它被阻止了，它仍然在那里等待

00:32:41.580 --> 00:32:45.930
耐心等待数据库返回

00:32:43.800 --> 00:32:48.230
结果，然后在某个时候返回

00:32:45.930 --> 00:32:50.970
整个交易的结果

00:32:48.230 --> 00:32:53.790
超级简单，实际上是

00:32:50.970 --> 00:32:56.100
我们经常在其中工作的可扩展性

00:32:53.790 --> 00:32:58.860
 Java确保即使如此简单

00:32:56.100 --> 00:33:01.590
用例工作得很好，但是

00:32:58.860 --> 00:33:03.929
有挑战，所以如果你

00:33:01.590 --> 00:33:05.610
想要扩展到极限并

00:33:03.929 --> 00:33:06.210
这些线程，即使它们是

00:33:05.610 --> 00:33:08.430
相对的

00:33:06.210 --> 00:33:10.800
重量轻，他们确实倾向于加起来

00:33:08.430 --> 00:33:12.390
因此，如果您有上千个请求

00:33:10.800 --> 00:33:14.340
同时运行一千个线程

00:33:12.390 --> 00:33:15.840
那就是如果没有其他需要

00:33:14.340 --> 00:33:19.560
线程堆栈中的大量内存

00:33:15.840 --> 00:33:21.660
本身就是您可以使用的替代方法

00:33:19.560 --> 00:33:24.570
是同步I / O和同步

00:33:21.660 --> 00:33:27.720
例如在JDK中构造

00:33:24.570 --> 00:33:30.900
提供确实实现的单独方法

00:33:27.720 --> 00:33:33.090
 I / O和

00:33:30.900 --> 00:33:36.300
他们在那里，它们具有极高的可扩展性

00:33:33.090 --> 00:33:38.580
但是它们使用起来有点复杂

00:33:36.300 --> 00:33:40.170
您需要正确处理，假设

00:33:38.580 --> 00:33:42.030
你现在有一个像

00:33:40.170 --> 00:33:44.700
通过不同的连接进行多路复用

00:33:42.030 --> 00:33:46.650
或什么都对，它也是如此

00:33:44.700 --> 00:33:48.870
最后很难在配置文件中调试

00:33:46.650 --> 00:33:52.200
所以我们要用织机做什么

00:33:48.870 --> 00:33:55.080
这是使它异步

00:33:52.200 --> 00:33:57.990
为您作为开发人员的案例工作

00:33:55.080 --> 00:33:59.510
如果是的话，那是同步的

00:33:57.990 --> 00:34:01.800
从一开始就同步代码

00:33:59.510 --> 00:34:04.980
基本上标签线是开的

00:34:01.800 --> 00:34:07.770
在阻止块之间的某个地方

00:34:04.980 --> 00:34:09.990
几乎免费通话，或为此而致电

00:34:07.770 --> 00:34:12.990
像同步这样的代码，但像接收器一样工作

00:34:09.990 --> 00:34:15.000
正确执行性能核心并发

00:34:12.990 --> 00:34:16.440
很简单，所以我们的方式

00:34:15.000 --> 00:34:17.880
实施这一目标

00:34:16.440 --> 00:34:20.790
通过提供实现

00:34:17.880 --> 00:34:22.830
我们可以称之为纤维的东西

00:34:20.790 --> 00:34:26.100
其中的线程非常轻巧

00:34:22.830 --> 00:34:27.660
你就像你创造了数百万

00:34:26.100 --> 00:34:30.150
这些都在同一个JVM中，甚至数十亿

00:34:27.660 --> 00:34:34.200
他们是他们非常非常非常

00:34:30.150 --> 00:34:37.220
轻便的，这里的其他组件

00:34:34.200 --> 00:34:41.610
这是定界的延续吗

00:34:37.220 --> 00:34:43.260
满嘴，但想像处死你

00:34:41.610 --> 00:34:45.060
调用一个方法，假设您有一个小

00:34:43.260 --> 00:34:46.680
方法，它陷入了while循环中

00:34:45.060 --> 00:34:49.590
它正在做它正在计算的事情

00:34:46.680 --> 00:34:51.810
我们做什么的

00:34:49.590 --> 00:34:54.090
这里的延续是，我们允许

00:34:51.810 --> 00:34:57.120
在其中间产生的方法

00:34:54.090 --> 00:34:57.510
我们可以冻结的地方执行

00:34:57.120 --> 00:34:59.700
那

00:34:57.510 --> 00:35:01.350
哦，抱歉，将其冻结并保存

00:34:59.700 --> 00:35:03.060
在侧面的某个地方

00:35:01.350 --> 00:35:04.800
它在线程上运行的位置，但是我们

00:35:03.060 --> 00:35:06.930
只能冻结该执行副本

00:35:04.800 --> 00:35:08.550
要决定的那些框架， 

00:35:06.930 --> 00:35:11.460
然后让那个线程继续执行

00:35:08.550 --> 00:35:12.840
其他的东西，这意味着什么

00:35:11.460 --> 00:35:15.930
你是你可以实现这些

00:35:12.840 --> 00:35:17.610
好像他们阻塞正确的方法，但是

00:35:15.930 --> 00:35:19.650
而不是阻止他们实际上让步

00:35:17.610 --> 00:35:19.980
在后台，我们再次采取

00:35:19.650 --> 00:35:21.510
那

00:35:19.980 --> 00:35:23.730
很小的状态

00:35:21.510 --> 00:35:25.410
在这个大恐龙线程上运行

00:35:23.730 --> 00:35:26.940
我们将其复制并让线程执行

00:35:25.410 --> 00:35:29.040
还有其他事情，所以我们为

00:35:26.940 --> 00:35:31.050
基本上就像一切都是编码

00:35:29.040 --> 00:35:32.700
现在同步另一个好的部分

00:35:31.050 --> 00:35:35.160
关于这一点，而不是必须

00:35:32.700 --> 00:35:37.050
提供两个不同的版本，所以我再次

00:35:35.160 --> 00:35:39.150
说在JDK方面我们有同步

00:35:37.050 --> 00:35:41.670
 I / O，我们还有一个同步I / O 

00:35:39.150 --> 00:35:43.260
所以我们需要同时交付

00:35:41.670 --> 00:35:45.300
如果您正在实现一个库

00:35:43.260 --> 00:35:46.740
框架的机会是你将

00:35:45.300 --> 00:35:48.359
轮到同时提供

00:35:46.740 --> 00:35:50.580
通话的同步版本

00:35:48.359 --> 00:35:52.140
同步版本和那个

00:35:50.580 --> 00:35:53.510
显然是一件麻烦事，所以这是什么

00:35:52.140 --> 00:35:56.010
允许您做的基本上只是

00:35:53.510 --> 00:35:57.240
即兴创作一个看起来像

00:35:56.010 --> 00:35:59.369
它是同步的，在后台

00:35:57.240 --> 00:36:01.980
 JVM和其余的运行时

00:35:59.369 --> 00:36:04.470
照顾你，有一个

00:36:01.980 --> 00:36:07.410
这个的原型玩弄它

00:36:04.470 --> 00:36:08.820
我们正在研究替代方法

00:36:07.410 --> 00:36:10.470
同时实现此功能

00:36:08.820 --> 00:36:14.790
所以这是什么状态

00:36:10.470 --> 00:36:18.450
该产品现在是巴拿马

00:36:14.790 --> 00:36:20.160
我们正在研究的产品

00:36:18.450 --> 00:36:21.930
 Java本身不是的东西

00:36:20.160 --> 00:36:24.060
巴拿马是一个像

00:36:21.930 --> 00:36:25.710
连接海洋一个海洋被

00:36:24.060 --> 00:36:30.140
 Java和另一个是C ++ 

00:36:25.710 --> 00:36:32.220
我猜是本土或大洲

00:36:30.140 --> 00:36:33.720
里面是一堆

00:36:32.220 --> 00:36:36.390
未实现的库

00:36:33.720 --> 00:36:38.130
 Java或出于某些原因， 

00:36:36.390 --> 00:36:39.810
想伸出手并实际访问

00:36:38.130 --> 00:36:42.240
本机数据，但不在

00:36:39.810 --> 00:36:44.760
 Java堆以更有效的方式

00:36:42.240 --> 00:36:47.910
巴拿马正在探索这是一个

00:36:44.760 --> 00:36:49.950
安全快捷的访问方式

00:36:47.910 --> 00:36:53.430
呼吁反对

00:36:49.950 --> 00:36:57.180
考虑C ++，并访问数据

00:36:53.430 --> 00:36:59.850
不在Java堆上，而没有

00:36:57.180 --> 00:37:01.980
只需写一行本机

00:36:59.850 --> 00:37:03.600
代码，因为您今天可以在此处进行操作

00:37:01.980 --> 00:37:06.930
 J＆I界面有多少人

00:37:03.600 --> 00:37:09.230
这里写过J＆I或正在做Jana 

00:37:06.930 --> 00:37:12.540
我们为你感到抱歉

00:37:09.230 --> 00:37:14.580
贾娜（Jana）很难做到正确，所以

00:37:12.540 --> 00:37:16.170
基本上是为那些还没有

00:37:14.580 --> 00:37:17.940
如果您有一个

00:37:16.170 --> 00:37:20.100
您要调用的收藏夹库

00:37:17.940 --> 00:37:21.720
基本上这是第一个工作流程

00:37:20.100 --> 00:37:23.340
你需要做的是研究

00:37:21.720 --> 00:37:25.410
图书馆，并确切地了解它

00:37:23.340 --> 00:37:27.060
之所以有效，是因为接下来您需要

00:37:25.410 --> 00:37:30.540
要做的是在

00:37:27.060 --> 00:37:32.130
完成Java级别的工作后

00:37:30.540 --> 00:37:33.910
实现你需要实现一些

00:37:32.130 --> 00:37:35.530
不仅是

00:37:33.910 --> 00:37:38.110
方法的皇家存根，但喜欢

00:37:35.530 --> 00:37:40.180
实际调用本地代码

00:37:38.110 --> 00:37:41.950
然后您添加了一堆方法

00:37:40.180 --> 00:37:44.650
用本地关键字修饰

00:37:41.950 --> 00:37:47.170
然后在下一步中使用工具

00:37:44.650 --> 00:37:49.510
在这种情况下，Java C或Java时代

00:37:47.170 --> 00:37:53.500
作为生成标题的名称

00:37:49.510 --> 00:37:55.180
文件C C ++头文件，然后您

00:37:53.500 --> 00:37:57.130
需要实际实现Jana代码

00:37:55.180 --> 00:37:59.290
在我和周杰伦之间架起桥梁

00:37:57.130 --> 00:38:01.420
带领JAVA沙到您的最爱

00:37:59.290 --> 00:38:03.100
库，然后您需要构建

00:38:01.420 --> 00:38:04.450
共享库查找工具链

00:38:03.100 --> 00:38:06.100
这将有所不同，具体取决于

00:38:04.450 --> 00:38:07.720
您在哪个平台上，然后

00:38:06.100 --> 00:38:09.670
最后，您实际上可以开始使用

00:38:07.720 --> 00:38:11.530
代码正确，上帝禁止某人去

00:38:09.670 --> 00:38:13.060
并实际上更改该库

00:38:11.530 --> 00:38:14.350
你想妈妈做模特，因为现在

00:38:13.060 --> 00:38:17.650
你需要去改变一切

00:38:14.350 --> 00:38:19.930
对，那一直很不幸，那又怎样

00:38:17.650 --> 00:38:22.390
我们试图做的是基本上削减

00:38:19.930 --> 00:38:23.680
像第一件事一样切掉

00:38:22.390 --> 00:38:25.540
那些容易出错的原因是

00:38:23.680 --> 00:38:27.250
每一步都可能出错

00:38:25.540 --> 00:38:30.070
在J和我特别是分支

00:38:27.250 --> 00:38:31.960
层非常容易出错

00:38:30.070 --> 00:38:33.910
忘记释放资源或

00:38:31.960 --> 00:38:36.160
像这样的东西，基本上这是

00:38:33.910 --> 00:38:39.010
我们设想您的新模式

00:38:36.160 --> 00:38:40.990
使用工具生成事物

00:38:39.010 --> 00:38:43.180
这里的东西实际上是Java类或

00:38:40.990 --> 00:38:44.980
界面更具体如此

00:38:43.180 --> 00:38:47.530
基本上这都是自动化的

00:38:44.980 --> 00:38:49.930
指出一个库或标题

00:38:47.530 --> 00:38:51.130
文件，它会为您生成Java代码

00:38:49.930 --> 00:38:53.500
然后你就可以开始打电话了

00:38:51.130 --> 00:38:55.450
你不喜欢的那些Java方法

00:38:53.500 --> 00:38:57.370
编写了一行本地代码，然后

00:38:55.450 --> 00:38:59.320
您现在可以使用该库

00:38:57.370 --> 00:39:00.730
显然，您仍然必须了解

00:38:59.320 --> 00:39:02.650
该库即将使用，但至少

00:39:00.730 --> 00:39:09.790
可以说您会减少

00:39:02.650 --> 00:39:12.670
做到正确的大都会也是一个

00:39:09.790 --> 00:39:16.360
正在探索的那些大型项目中

00:39:12.670 --> 00:39:19.000
我们如何更多地使用Java来实现

00:39:16.360 --> 00:39:20.110
 Java Runtime本身很大一部分

00:39:19.000 --> 00:39:21.520
 Java特别是核心

00:39:20.110 --> 00:39:24.030
库显然是在

00:39:21.520 --> 00:39:26.860
 Java，但JVM仍是本机代码

00:39:24.030 --> 00:39:30.460
而我们正在研究的第一件事

00:39:26.860 --> 00:39:32.770
这就是我们如何将JIT移交给工作

00:39:30.460 --> 00:39:34.630
驻留在JVM内部的编译器

00:39:32.770 --> 00:39:36.520
需要字节码Java的编译器

00:39:34.630 --> 00:39:38.920
字节码并将其转换为有效的

00:39:36.520 --> 00:39:40.180
机器代码，如果您愿意，那是

00:39:38.920 --> 00:39:41.830
我们正在研究的第一件事

00:39:40.180 --> 00:39:44.560
今天我们有两个不同的准时制

00:39:41.830 --> 00:39:46.610
 JVM中的编译器也有C语言

00:39:44.560 --> 00:39:48.830
被称为客户端编译器和座位

00:39:46.610 --> 00:39:52.580
完全优化的服务器

00:39:48.830 --> 00:39:55.340
我们拥有的编译器因此c2有点

00:39:52.580 --> 00:39:57.530
达到其复杂性，但我们

00:39:55.340 --> 00:40:00.080
在c2中放了很多好东西，但是

00:39:57.530 --> 00:40:01.730
有点时间去看它像什么

00:40:00.080 --> 00:40:05.390
未来会是什么样

00:40:01.730 --> 00:40:07.280
 10 15年或20年，事实证明

00:40:05.390 --> 00:40:09.560
这些产品很多都很大

00:40:07.280 --> 00:40:11.210
对我们所做的编译器有重大影响

00:40:09.560 --> 00:40:12.620
需要在编译器中做很多工作

00:40:11.210 --> 00:40:14.390
编译器是个秘密

00:40:12.620 --> 00:40:16.460
我们在DM中拥有的武器

00:40:14.390 --> 00:40:18.710
需要让所有人真正工作得很好

00:40:16.460 --> 00:40:21.230
各种各样的圆锥形

00:40:18.710 --> 00:40:24.140
我们确实需要在JIT中工作的产品

00:40:21.230 --> 00:40:26.180
使我们更容易改善死亡

00:40:24.140 --> 00:40:27.710
前进很重要，所以该怎么办

00:40:26.180 --> 00:40:30.830
当你有两个东西时你会做

00:40:27.710 --> 00:40:34.790
而您想下降到一个添加

00:40:30.830 --> 00:40:37.250
在这种情况下，我们要添加三分之一

00:40:34.790 --> 00:40:40.820
所谓的咆哮咆哮是准时制

00:40:37.250 --> 00:40:43.220
用Java实现的编译器，我们喜欢

00:40:40.820 --> 00:40:45.020
再次认为Java是一个好习惯

00:40:43.220 --> 00:40:47.660
实现事物的语言

00:40:45.020 --> 00:40:49.850
一般，为什么不编译专家

00:40:47.660 --> 00:40:51.800
包括类似的东西

00:40:49.850 --> 00:40:54.530
做发展，这也是

00:40:51.800 --> 00:40:56.630
很容易，如果

00:40:54.530 --> 00:40:58.610
你想尝试一些你喜欢的东西

00:40:56.630 --> 00:41:00.200
不必构建重新构建JVM 

00:40:58.610 --> 00:41:02.330
实际上可以在Java级别上工作，并且

00:41:00.200 --> 00:41:07.130
获得所有Idid支持和代码

00:41:02.330 --> 00:41:09.050
浏览，所有这些都有

00:41:07.130 --> 00:41:11.030
自然界中新颖的产品

00:41:09.050 --> 00:41:13.100
他们很快就接触到它们

00:41:11.030 --> 00:41:15.290
这个产品叫SCARA 

00:41:13.100 --> 00:41:18.290
现代化的开发人员体验

00:41:15.290 --> 00:41:20.240
我们在jdk本身上工作，以便

00:41:18.290 --> 00:41:23.960
该代码开发目前

00:41:20.240 --> 00:41:27.200
发生在我要称之为老化和

00:41:23.960 --> 00:41:28.370
不一定年龄与尊严代码

00:41:27.200 --> 00:41:31.760
基础设施，所以这是

00:41:28.370 --> 00:41:34.310
特别是围绕代码审查和SEM 

00:41:31.760 --> 00:41:36.860
就像是照顾代码本身

00:41:34.310 --> 00:41:38.570
所以我们要在这里投资什么

00:41:36.860 --> 00:41:40.610
应该从我们目前的位置移开

00:41:38.570 --> 00:41:42.890
如果我们应该走过去的话

00:41:40.610 --> 00:41:44.720
也许得到它确实好像有

00:41:42.890 --> 00:41:47.510
更多支持的工具

00:41:44.720 --> 00:41:49.640
装甲q4材料以及

00:41:47.510 --> 00:41:51.560
利用现有的托管服务提供商

00:41:49.640 --> 00:41:54.860
像是实验室或github之类的东西

00:41:51.560 --> 00:41:58.370
这里发生了很多令人兴奋的事情

00:41:54.860 --> 00:41:59.690
乔治·波托拉在幻灯片中提到

00:41:58.370 --> 00:42:00.150
也是我们正在寻找的地方

00:41:59.690 --> 00:42:01.650
在

00:42:00.150 --> 00:42:03.779
确保其他作品真的

00:42:01.650 --> 00:42:05.490
容器中真的很好

00:42:03.779 --> 00:42:07.920
这里的头发人都听说过

00:42:05.490 --> 00:42:10.619
高山Linux哦

00:42:07.920 --> 00:42:13.950
令人惊讶的是，有多少人

00:42:10.619 --> 00:42:17.400
这里想看看JDK的端口

00:42:13.950 --> 00:42:18.930
 -Alpine Linux好的几个答案几个

00:42:17.400 --> 00:42:24.299
人们想帮助维持的是

00:42:18.930 --> 00:42:25.770
进口确实让我们知道我们正在努力

00:42:24.299 --> 00:42:27.029
衡量兴趣并弄清楚是否

00:42:25.770 --> 00:42:29.520
值得继续前进

00:42:27.029 --> 00:42:31.950
有像JDK这样的产品

00:42:29.520 --> 00:42:33.450
实际上，它可以构建并运行东西，但是我们

00:42:31.950 --> 00:42:34.950
尚未完成我们知道的所有测试

00:42:33.450 --> 00:42:40.260
当我们确实证明它可能是

00:42:34.950 --> 00:42:41.819
功能正确的CGC是产品

00:42:40.260 --> 00:42:44.670
我们在看垃圾

00:42:41.819 --> 00:42:46.650
像软的收藏家

00:42:44.670 --> 00:42:49.529
但还是可以说

00:42:46.650 --> 00:42:51.809
确保环绕声暂停时间，因此

00:42:49.529 --> 00:42:53.970
该项目的目标是非常支持

00:42:51.809 --> 00:42:57.359
非常大的堆，所以我认为我们只是

00:42:53.970 --> 00:42:59.970
我现在不记得了

00:42:57.359 --> 00:43:02.700
将其提高到16 TB，或者也许

00:42:59.970 --> 00:43:04.890
更多，但在我们的情况下

00:43:02.700 --> 00:43:07.289
就像在保持发布时间一样

00:43:04.890 --> 00:43:08.609
真的很低，所以目标是10 

00:43:07.289 --> 00:43:11.940
毫秒，我们实际上低于

00:43:08.609 --> 00:43:13.200
现在，但与此同时

00:43:11.940 --> 00:43:15.180
我们引以为傲的其他事情

00:43:13.200 --> 00:43:16.829
在这里，您不必调整

00:43:15.180 --> 00:43:19.799
它应该可以解决的问题

00:43:16.829 --> 00:43:21.210
没有该要求的盒子，以及

00:43:19.799 --> 00:43:23.609
我们正在努力做到这一点，同时保持

00:43:21.210 --> 00:43:25.500
吞吐量开销低，因此目标

00:43:23.609 --> 00:43:27.240
是15％似乎是一个不错的整数

00:43:25.500 --> 00:43:28.890
大多数人可以接受的地方

00:43:27.240 --> 00:43:32.130
权衡，我们做得很好

00:43:28.890 --> 00:43:36.210
在那里，然后最后我只是

00:43:32.130 --> 00:43:40.289
提到我大概叫jf或JDK 

00:43:36.210 --> 00:43:42.420
飞行记录仪，让您想象自己

00:43:40.289 --> 00:43:44.150
在一个项目中工作，你曾经

00:43:42.420 --> 00:43:47.220
实际上以某种方式待命

00:43:44.150 --> 00:43:49.349
通常你知道你可以打赌它是

00:43:47.220 --> 00:43:52.170
例如周日或周六晚上或

00:43:49.349 --> 00:43:53.880
发生类似SLA的事情是

00:43:52.170 --> 00:43:55.349
突破某处，问题是

00:43:53.880 --> 00:43:56.910
你不知道发生了什么事

00:43:55.349 --> 00:43:58.349
所以你要做的第一件事

00:43:56.910 --> 00:44:00.809
第一件事，但就像在某个时候

00:43:58.349 --> 00:44:01.460
添加一些日志记录，您尝试获得更多

00:44:00.809 --> 00:44:03.329
信息

00:44:01.460 --> 00:44:06.049
不幸的是，日志附带

00:44:03.329 --> 00:44:08.430
性能开销，所以过了一会儿

00:44:06.049 --> 00:44:10.109
没有发现您需要删除的内容

00:44:08.430 --> 00:44:12.090
记录，因为你不想

00:44:10.109 --> 00:44:13.440
支付额外的服务器和

00:44:12.090 --> 00:44:16.020
删除日志显然下一步

00:44:13.440 --> 00:44:19.560
星期六晚上7点再次发生同样的事情

00:44:16.020 --> 00:44:22.860
发生正确的j4试图解决

00:44:19.560 --> 00:44:24.780
 piggy带上正是这个问题

00:44:22.860 --> 00:44:27.300
 JVM已经做的很多事情

00:44:24.780 --> 00:44:29.790
所以它收集了很多细粒度的

00:44:27.300 --> 00:44:31.800
有关系统本身的信息

00:44:29.790 --> 00:44:34.710
在VM内，但也有一个API 

00:44:31.800 --> 00:44:37.530
您可以用来放置用户定义的事件

00:44:34.710 --> 00:44:41.090
进入同一流，它正在

00:44:37.530 --> 00:44:43.740
就像我应该怎么把这个

00:44:41.090 --> 00:44:46.230
我们正在尝试确保它的设计

00:44:43.740 --> 00:44:47.310
完全是在生产中

00:44:46.230 --> 00:44:48.780
首先要记住的是

00:44:47.310 --> 00:44:50.760
在开发过程中显然使用它

00:44:48.780 --> 00:44:54.420
但它被设计用于生产中

00:44:50.760 --> 00:44:56.850
它可以帮助您收集几乎

00:44:54.420 --> 00:44:58.830
太多的信息是

00:44:56.850 --> 00:45:01.620
默认设置将收集您知道的信息

00:44:58.830 --> 00:45:05.610
在大多数情况下，信息足够，但是

00:45:01.620 --> 00:45:06.720
但是我不知道怎么把它放进去

00:45:05.610 --> 00:45:09.600
还有其他方法吗

00:45:06.720 --> 00:45:11.580
非常强大，所以您知道

00:45:09.600 --> 00:45:15.840
看看并告诉我们您想要什么

00:45:11.580 --> 00:45:18.480
看到前进，所以我最后一张幻灯片

00:45:15.840 --> 00:45:20.970
答应给您一些早期链接

00:45:18.480 --> 00:45:23.160
访问二进制文件，所以我们再次数

00:45:20.970 --> 00:45:25.320
根据您的反馈意见，我们需要您的帮助

00:45:23.160 --> 00:45:27.750
确保我们开发的

00:45:25.320 --> 00:45:30.990
您实际制造的未来产品

00:45:27.750 --> 00:45:33.660
感觉自己知道自己对

00:45:30.990 --> 00:45:35.850
与之合作，并致力于

00:45:33.660 --> 00:45:38.040
确保帮助确保项目

00:45:35.850 --> 00:45:40.110
希腊的我们实际上是在做

00:45:38.040 --> 00:45:44.010
工作正常，没有问题，所以

00:45:40.110 --> 00:45:47.880
适用于GA 9月的jdk 13 

00:45:44.010 --> 00:45:49.140
有些东西实际上是

00:45:47.880 --> 00:45:50.850
现在相当不错的地方

00:45:49.140 --> 00:45:53.970
因为像这六个月的发行版一样

00:45:50.850 --> 00:45:55.470
就像我们发现需要的地方

00:45:53.970 --> 00:45:58.020
要做的是确保质量

00:45:55.470 --> 00:46:00.120
我们所做的每一次推动都保持高水平

00:45:58.020 --> 00:46:02.040
基本上就是

00:46:00.120 --> 00:46:03.840
当发布时，就像

00:46:02.040 --> 00:46:05.460
非事件就像我们画一条线， 

00:46:03.840 --> 00:46:07.380
在这里说这是什么

00:46:05.460 --> 00:46:08.910
此版本，然后接下来的三个月

00:46:07.380 --> 00:46:10.620
我们或多或少地坐在他们周围

00:46:08.910 --> 00:46:12.030
旧的重击，然后像DGA 

00:46:10.620 --> 00:46:13.650
马上就来了，就像是

00:46:12.030 --> 00:46:15.270
足够公平，我们几乎忘记了

00:46:13.650 --> 00:46:18.870
 JDK十二周前发布

00:46:15.270 --> 00:46:21.480
所以在9月我们将发布13个

00:46:18.870 --> 00:46:24.330
每周提前出版一次

00:46:21.480 --> 00:46:25.730
访问二进制文件为13，所以请拿起

00:46:24.330 --> 00:46:27.619
试试看，让我们知道

00:46:25.730 --> 00:46:29.420
如果您发现任何问题或为此

00:46:27.619 --> 00:46:31.010
即使你喜欢里面的东西

00:46:29.420 --> 00:46:33.859
对，它的正面反馈也

00:46:31.010 --> 00:46:36.680
很高兴不时得到一些

00:46:33.859 --> 00:46:38.030
那么对于项目来说， 

00:46:36.680 --> 00:46:40.580
我们也在发布的项目

00:46:38.030 --> 00:46:43.100
早期访问二进制文件，如果再次

00:46:40.580 --> 00:46:45.770
您很好奇尝试Valhalla或

00:46:43.100 --> 00:46:50.170
巴拿马，或者我们有J包装产品

00:46:45.770 --> 00:46:50.170
好吧，现在您可以在其中找到它们

00:46:51.730 --> 00:46:58.190
好的，谢谢迈克尔，希望如此

00:46:55.609 --> 00:47:00.500
让您同时了解两个

00:46:58.190 --> 00:47:01.820
有点概述

00:47:00.500 --> 00:47:05.180
状态以及Java的状况

00:47:01.820 --> 00:47:07.460
我们如何发展它，以及

00:47:05.180 --> 00:47:08.780
最后深入一堆

00:47:07.460 --> 00:47:11.380
我们正在从事的项目

00:47:08.780 --> 00:47:14.359
试图让它变得更好

00:47:11.380 --> 00:47:15.340
所以我认为我们有时间可能

00:47:14.359 --> 00:47:21.379
几个问题

00:47:15.340 --> 00:47:21.379
 [掌声] 

