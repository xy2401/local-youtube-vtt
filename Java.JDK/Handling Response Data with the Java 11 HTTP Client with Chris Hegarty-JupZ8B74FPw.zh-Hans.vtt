WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.460 --> 00:00:07.620
 [音乐] 

00:00:04.310 --> 00:00:09.990
嗨，我叫克里斯·哈格蒂（Chris Haggerty），我在这里工作

00:00:07.620 --> 00:00:11.070
 Oracle的Java平台小组和

00:00:09.990 --> 00:00:13.530
今天我要说的是

00:00:11.070 --> 00:00:19.199
使用Java 11处理响应数据

00:00:13.530 --> 00:00:20.789
在此会话中的HTTP客户端

00:00:19.199 --> 00:00:22.560
从高层次看三个

00:00:20.789 --> 00:00:25.439
 Java中的活动流接口

00:00:22.560 --> 00:00:27.930
平台及其使用方式

00:00:25.439 --> 00:00:30.599
知识之后，我们将了解HTTP 

00:00:27.930 --> 00:00:33.809
客户利用这些接口来

00:00:30.599 --> 00:00:35.399
处理请求和响应机构

00:00:33.809 --> 00:00:37.800
通过一个如何写作的例子

00:00:35.399 --> 00:00:40.320
定制响应主体订户，以及

00:00:37.800 --> 00:00:44.640
如何与现有流程互操作

00:00:40.320 --> 00:00:46.500
之前的发布者和订阅者

00:00:44.640 --> 00:00:48.180
看着反应流

00:00:46.500 --> 00:00:50.280
有助于提醒自己

00:00:48.180 --> 00:00:52.710
经典的生产者/消费者范例和

00:00:50.280 --> 00:00:55.680
一些潜在的问题和

00:00:52.710 --> 00:00:58.379
通常是生产者的问题

00:00:55.680 --> 00:01:00.960
生成项目或数据将其放入

00:00:58.379 --> 00:01:03.539
相同的队列或缓冲区

00:01:00.960 --> 00:01:05.580
消费者消耗数据的时间

00:01:03.539 --> 00:01:08.700
一次从

00:01:05.580 --> 00:01:10.470
缓冲问题是如何确保

00:01:08.700 --> 00:01:12.450
当生产者没有被阻止时

00:01:10.470 --> 00:01:14.970
缓冲区已满或

00:01:12.450 --> 00:01:16.770
消费者在以下情况下不尝试获取数据

00:01:14.970 --> 00:01:18.900
缓冲区为空，并且有一个

00:01:16.770 --> 00:01:21.750
通知机制来实现

00:01:18.900 --> 00:01:24.830
如果发生以及尝试

00:01:21.750 --> 00:01:28.619
确定合理的缓冲区大小

00:01:24.830 --> 00:01:30.720
转向反应性生产者

00:01:28.619 --> 00:01:34.380
被称为发布者

00:01:30.720 --> 00:01:37.890
被消费者称为

00:01:34.380 --> 00:01:39.750
接收项目的订户

00:01:37.890 --> 00:01:42.869
发布者订阅了一个方法

00:01:39.750 --> 00:01:46.200
需要一个订阅者

00:01:42.869 --> 00:01:49.290
有四种取消订阅的方法

00:01:46.200 --> 00:01:52.770
错误和不完整，我们来看一下

00:01:49.290 --> 00:01:54.810
现在，这些用户可以是

00:01:52.770 --> 00:01:57.210
通过调用

00:01:54.810 --> 00:02:00.570
发布者订阅的方法和传递

00:01:57.210 --> 00:02:02.820
订户发布我们的电话

00:02:00.570 --> 00:02:05.610
订户的退订方法

00:02:02.820 --> 00:02:08.129
两次握手之间的订阅

00:02:05.610 --> 00:02:09.599
订阅者和发布者结果

00:02:08.129 --> 00:02:11.390
在发布者中引用

00:02:09.599 --> 00:02:12.800
订户

00:02:11.390 --> 00:02:14.870
拥有发布者的订户

00:02:12.800 --> 00:02:18.140
所提供的订阅

00:02:14.870 --> 00:02:19.970
取消订阅是订阅

00:02:18.140 --> 00:02:21.680
作为一种机制

00:02:19.970 --> 00:02:26.030
订户向

00:02:21.680 --> 00:02:27.950
发布者例如使用此

00:02:26.030 --> 00:02:30.490
订阅者可以请求的订阅

00:02:27.950 --> 00:02:34.010
出版商的一些物品

00:02:30.490 --> 00:02:35.990
然后，发布者最多可以发布

00:02:34.010 --> 00:02:38.810
通过调用

00:02:35.990 --> 00:02:42.350
订户了解下一种方法和编号

00:02:38.810 --> 00:02:44.150
每次都有一个项目的次数

00:02:42.350 --> 00:02:46.610
请求机制提供了

00:02:44.150 --> 00:02:48.530
订户具有背压，因为它

00:02:46.610 --> 00:02:52.430
控制最大数量

00:02:48.530 --> 00:02:55.120
如果

00:02:52.430 --> 00:02:58.040
发布者没有其他要发布的项目

00:02:55.120 --> 00:03:00.860
然后呼叫订户

00:02:58.040 --> 00:03:03.230
通知订户的方法

00:03:00.860 --> 00:03:06.019
发行人，无论需求如何

00:03:03.230 --> 00:03:09.860
更多项目将不会发布更多项目给

00:03:06.019 --> 00:03:12.140
 Dis订阅者（如果发布者） 

00:03:09.860 --> 00:03:14.750
遇到错误，请说从

00:03:12.140 --> 00:03:17.209
文件或网络，然后通知

00:03:14.750 --> 00:03:19.459
的订户，请致电

00:03:17.209 --> 00:03:23.739
订户使用错误方法

00:03:19.459 --> 00:03:23.739
适当的故障指示问题

00:03:23.829 --> 00:03:28.190
 Java平台提供了对

00:03:26.660 --> 00:03:30.709
反应流到许多

00:03:28.190 --> 00:03:33.380
 java.util中的并发接口

00:03:30.709 --> 00:03:35.870
流类有一个发布者

00:03:33.380 --> 00:03:38.900
发布订户的项目

00:03:35.870 --> 00:03:41.480
接收订户订阅的项目

00:03:38.900 --> 00:03:46.130
给发布者，可以发出请求

00:03:41.480 --> 00:03:48.980
用于HTTP客户端所需的项目

00:03:46.130 --> 00:03:51.880
模型使用以下类型的子类型请求正文

00:03:48.980 --> 00:03:54.890
流发布者请求主体发布者

00:03:51.880 --> 00:03:57.410
 HTTP客户端订阅此

00:03:54.890 --> 00:04:00.950
发布商发送请求到

00:03:57.410 --> 00:04:02.720
身体在接收方时

00:04:00.950 --> 00:04:05.920
收到响应代码和标头

00:04:02.720 --> 00:04:08.480
 HTTP客户端称呼身体饥饿

00:04:05.920 --> 00:04:11.000
人体饥饿可以检查这些

00:04:08.480 --> 00:04:14.120
如果愿意，可以在创建一个

00:04:11.000 --> 00:04:16.700
该订阅者返回的正文订阅者

00:04:14.120 --> 00:04:18.560
由身体猎人会习惯

00:04:16.700 --> 00:04:22.760
接收并处理实际响应

00:04:18.560 --> 00:04:24.680
正文字节，HTTP正文订阅者是

00:04:22.760 --> 00:04:27.830
流订阅者的子类型

00:04:24.680 --> 00:04:30.979
并且httpclient充当以下内容的发布者： 

00:04:27.830 --> 00:04:32.600
响应伙伴字节中有一个数字

00:04:30.979 --> 00:04:34.940
制造身体的工厂

00:04:32.600 --> 00:04:37.729
大多数的出版商和团体订阅者

00:04:34.940 --> 00:04:39.580
常见用例，例如发布请求

00:04:37.729 --> 00:04:41.930
字符串或文件中的主体

00:04:39.580 --> 00:04:46.610
将响应主体字节转换为

00:04:41.930 --> 00:04:48.320
字符串或将它们流式传输到文件中

00:04:46.610 --> 00:04:51.740
本届会议我们将重点关注

00:04:48.320 --> 00:04:53.419
响应主体处理程序具有功能

00:04:51.740 --> 00:04:55.759
具有单一方法的接口

00:04:53.419 --> 00:04:58.780
应用需要回复信息

00:04:55.759 --> 00:05:01.340
包含状态码和标题

00:04:58.780 --> 00:05:02.840
当

00:05:01.340 --> 00:05:05.599
响应状态代码和标头为

00:05:02.840 --> 00:05:08.419
可用，但在实际回复之前

00:05:05.599 --> 00:05:10.759
正文字节已收到正文

00:05:08.419 --> 00:05:12.680
处理程序可以检查响应代码

00:05:10.759 --> 00:05:15.710
和标题，然后再返回正文

00:05:12.680 --> 00:05:17.599
然后，主体订阅者将

00:05:15.710 --> 00:05:22.610
用于接收实际的响应

00:05:17.599 --> 00:05:24.949
主体字节主体订户是流

00:05:22.610 --> 00:05:27.410
字节总数的订户

00:05:24.949 --> 00:05:30.590
缓冲包含的字节缓冲区

00:05:27.410 --> 00:05:32.870
订户的响应正文字节

00:05:30.590 --> 00:05:35.750
有一个抽象方法get'body 

00:05:32.870 --> 00:05:38.930
返回完成阶段

00:05:35.750 --> 00:05:41.000
用更高级别的类型完成

00:05:38.930 --> 00:05:44.479
主体订户实施将

00:05:41.000 --> 00:05:46.250
将响应主体字节转换为

00:05:44.479 --> 00:05:49.250
主体订户类仅包含

00:05:46.250 --> 00:05:51.440
研究静态工厂方法以及这些

00:05:49.250 --> 00:05:53.599
方法是制造身体的工厂

00:05:51.440 --> 00:05:56.870
可以用于大多数用户

00:05:53.599 --> 00:05:58.460
常见用例通过转换

00:05:56.870 --> 00:06:00.919
响应主体转换为字节数组或

00:05:58.460 --> 00:06:04.940
字符串或将其流式传输到文件或

00:06:00.919 --> 00:06:06.919
输入流让我们看一下

00:06:04.940 --> 00:06:12.320
为...编写自定义主体订户

00:06:06.919 --> 00:06:13.849
处理响应数据好吧，让我们

00:06:12.320 --> 00:06:16.699
看看如何编写自定义

00:06:13.849 --> 00:06:18.770
身体饥饿和身体订户之前

00:06:16.699 --> 00:06:23.050
这样做，让我们来看看如何

00:06:18.770 --> 00:06:26.630
便利车身搬运工的工作

00:06:23.050 --> 00:06:30.229
所以这里我们有一个实用的get方法

00:06:26.630 --> 00:06:33.529
它检索给定的URI并返回

00:06:30.229 --> 00:06:36.889
响应主体为字符串，因此首先

00:06:33.529 --> 00:06:37.470
创建一个新的HTTP客户端，通过该客户端

00:06:36.889 --> 00:06:41.310
请求

00:06:37.470 --> 00:06:44.640
我们发送了，它从

00:06:41.310 --> 00:06:47.970
给定URI，然后调用发送异步

00:06:44.640 --> 00:06:50.520
发送他使用的请求的方法

00:06:47.970 --> 00:06:52.980
静态字符串的主体处理程序

00:06:50.520 --> 00:06:55.920
创建身体处理程序的工厂方法

00:06:52.980 --> 00:06:58.980
将响应主体字节转换为

00:06:55.920 --> 00:07:01.890
一个字符串，然后是可完成的未来

00:06:58.980 --> 00:07:05.010
然后apply方法映射HTTP响应

00:07:01.890 --> 00:07:07.530
在我们的案例中，字符串与其主体类型有关

00:07:05.010 --> 00:07:11.010
字符串和一个可完成的未来

00:07:07.530 --> 00:07:12.990
返回字符串，所以我们可以看到示例

00:07:11.010 --> 00:07:16.200
 get方法中的新开关

00:07:12.990 --> 00:07:20.190
主要方法，所以在这里我们可以看到

00:07:16.200 --> 00:07:21.570
方法正在传递URI，然后加入

00:07:20.190 --> 00:07:24.500
在计算机上被称为

00:07:21.570 --> 00:07:27.300
返回的未来

00:07:24.500 --> 00:07:30.060
执行直到字符串响应主体

00:07:27.300 --> 00:07:39.090
是可用的，然后该程序只需

00:07:30.060 --> 00:07:40.950
打印出身体，让我们运行

00:07:39.090 --> 00:07:44.240
在这里我们可以看到响应正文字符串

00:07:40.950 --> 00:07:46.620
被打印出来，它只是一些XML 

00:07:44.240 --> 00:07:50.720
在这一点上，看到

00:07:46.620 --> 00:07:50.720
响应状态代码，让我们打印出来

00:07:59.520 --> 00:08:05.110
所以在这里我们用在可完成的未来

00:08:02.050 --> 00:08:07.270
当完整的方法打印出来

00:08:05.110 --> 00:08:10.870
状态码我们应该检查一下

00:08:07.270 --> 00:08:13.930
响应值为none no in 

00:08:10.870 --> 00:08:17.530
为了简单起见，发生错误

00:08:13.930 --> 00:08:20.979
暂时将其打印出来，这样运行

00:08:17.530 --> 00:08:23.319
再次好吧，我们可以看到响应

00:08:20.979 --> 00:08:27.039
代码是200，所以一切正常

00:08:23.319 --> 00:08:29.620
再次将响应主体全部打印

00:08:27.039 --> 00:08:32.070
正确，这就是所有正在使用的东西

00:08:29.620 --> 00:08:44.980
方便身体处理者之一

00:08:32.070 --> 00:08:46.930
让我们来看看自己写的

00:08:44.980 --> 00:08:50.860
我们需要实现主体订户

00:08:46.930 --> 00:09:00.550
接口，在这种情况下，我们的类型是

00:08:50.860 --> 00:09:02.560
字符串好，因此主体订阅者有一个

00:09:00.550 --> 00:09:05.170
称为get body和a的单一方法

00:09:02.560 --> 00:09:07.540
返回TT的完成阶段是

00:09:05.170 --> 00:09:10.660
在我们的情况下，我们还必须

00:09:07.540 --> 00:09:13.709
从流程实现四种方法

00:09:10.660 --> 00:09:16.959
订阅者，让我们来看看他们

00:09:13.709 --> 00:09:18.399
我们将从get body方法开始

00:09:16.959 --> 00:09:21.760
他们得到身体方法需要返回一个

00:09:18.399 --> 00:09:23.560
字符串的完成阶段，让我们使用

00:09:21.760 --> 00:09:27.480
一个具体的未来的完成

00:09:23.560 --> 00:09:27.480
完成阶段的实施

00:09:36.470 --> 00:09:42.269
所以叫我们兼容的老师

00:09:39.600 --> 00:09:45.269
嘿哥们CF，因为它拥有

00:09:42.269 --> 00:09:48.329
响应主体以及可以返回的位置

00:09:45.269 --> 00:09:54.480
从猫的身体方法，我现在

00:09:48.329 --> 00:09:56.459
继续取消订阅，以便HTTP 

00:09:54.480 --> 00:10:00.149
客户是发布者和响应机构

00:09:56.459 --> 00:10:02.790
这个字符串订阅者订阅

00:10:00.149 --> 00:10:05.790
该发行商，因此首先它将拥有其

00:10:02.790 --> 00:10:10.440
用调用的取消订阅方法

00:10:05.790 --> 00:10:13.610
来自HTTP客户端的订阅，因此

00:10:10.440 --> 00:10:13.610
让我们存储该订阅

00:10:23.190 --> 00:10:28.870
好吧，现在我们可以订阅了

00:10:26.800 --> 00:10:30.250
请求其他响应主体

00:10:28.870 --> 00:10:33.370
客户，或者我们可以取消订阅

00:10:30.250 --> 00:10:36.960
如果我们不再感兴趣，让我们

00:10:33.370 --> 00:10:39.400
要求更多，只要求一个

00:10:36.960 --> 00:10:42.100
在这一点上，我们可以查找挂钩

00:10:39.400 --> 00:10:47.790
错误处理，所以我们完成了正文

00:10:42.100 --> 00:10:47.790
错误发生后异常

00:10:48.870 --> 00:10:54.730
在这个简单的实现中

00:10:52.300 --> 00:10:58.060
只是积累所有的响应数据

00:10:54.730 --> 00:11:01.270
列表中的管道缓冲区，然后我们

00:10:58.060 --> 00:11:07.590
会将响应主体转换为

00:11:01.270 --> 00:11:07.590
末尾的字符串，让我们创建一个列表

00:11:26.650 --> 00:11:31.710
好的，所以每次响应数据是

00:11:29.560 --> 00:11:37.540
收到，我们将其添加到列表中

00:11:31.710 --> 00:11:39.130
让我们保留一个更好的名字好吧

00:11:37.540 --> 00:11:42.310
所以我们只剩下不完整的

00:11:39.130 --> 00:11:45.550
方法如此简单

00:11:42.310 --> 00:11:47.350
实施，我们将确定

00:11:45.550 --> 00:11:49.450
我们放入它们的字节数

00:11:47.350 --> 00:11:52.230
字节数组，然后转换该字节

00:11:49.450 --> 00:11:52.230
排列成字符串

00:12:02.750 --> 00:12:07.250
所以一旦我们知道字节数是

00:12:05.629 --> 00:12:09.019
每个字节缓冲区中剩余的空间我们可以求和

00:12:07.250 --> 00:12:12.410
那就是总数

00:12:09.019 --> 00:12:15.850
我们字节数组中需要的字节

00:12:12.410 --> 00:12:15.850
让我们创建一个这样大小的战斗阵列

00:12:18.370 --> 00:12:26.529
好吧，现在我们可以遍历缓冲区了

00:12:31.950 --> 00:12:41.670
并且它们到字节数组哎呀

00:12:37.800 --> 00:12:45.060
呼叫缓冲区显示人员结束

00:12:41.670 --> 00:12:52.139
 doc此时获取字节数组，我们

00:12:45.060 --> 00:12:54.420
需要补偿，所以很棒

00:12:52.139 --> 00:12:56.639
应该为零，我们需要一个

00:12:54.420 --> 00:12:59.750
长度，长度将是

00:12:56.639 --> 00:12:59.750
剩余字节数

00:13:07.830 --> 00:13:22.410
这是抵消，您将需要

00:13:14.899 --> 00:13:25.470
随着我们迭代好，增加偏移量

00:13:22.410 --> 00:13:27.269
现在我们有一个回应，但他在

00:13:25.470 --> 00:13:33.779
字节数组让我们将其转换为

00:13:27.269 --> 00:13:35.930
为了简单起见，我们将使用字符串

00:13:33.779 --> 00:13:38.850
现在暂时忽略转化时的费用

00:13:35.930 --> 00:13:43.910
好的，我们有字符串让我们

00:13:38.850 --> 00:13:43.910
用那根弦完成身体CF 

00:13:45.560 --> 00:13:52.320
好的，此时一切看起来

00:13:47.640 --> 00:13:54.390
好吧，我们忘记了一件事，因为

00:13:52.320 --> 00:13:56.490
退订我们只要求一个

00:13:54.390 --> 00:13:58.740
每次我们收到更多回电

00:13:56.490 --> 00:14:03.570
回电我们想再要求一个

00:13:58.740 --> 00:14:05.880
所以现在一次一步就可以了

00:14:03.570 --> 00:14:09.570
让我们的字符串订阅者挂上它

00:14:05.880 --> 00:14:12.720
 HTTP客户端，所以我们需要一个

00:14:09.570 --> 00:14:16.079
回应抱歉回应正文处理程序

00:14:12.720 --> 00:14:17.670
这里响应主体处理程序是

00:14:16.079 --> 00:14:21.930
功能接口

00:14:17.670 --> 00:14:23.820
响应信息返回订户

00:14:21.930 --> 00:14:29.630
我们的情况下，我们将无条件返回

00:14:23.820 --> 00:14:29.630
字符串订阅者好吧，让我们运行它

00:14:35.880 --> 00:14:40.920
好的，我们已经回复了代码200 

00:14:38.040 --> 00:14:43.889
再次，我们有我们的反应伙伴

00:14:40.920 --> 00:14:46.019
一个字符串，让我们看看

00:14:43.889 --> 00:14:50.029
这里发生了什么，让我们添加一个

00:14:46.019 --> 00:14:50.029
下次通话的调试语句

00:14:52.160 --> 00:14:55.160
哎呀

00:14:55.430 --> 00:15:02.639
接下来，它被称为缓冲区和

00:14:58.730 --> 00:15:07.290
我们将更改URI，以便获得一些

00:15:02.639 --> 00:15:16.529
更多的响应数据好吧，让我们运行

00:15:07.290 --> 00:15:17.819
再次好吧，我们可以在Nexus上看到

00:15:16.529 --> 00:15:20.250
叫过几次

00:15:17.819 --> 00:15:22.500
我们是包含以下内容的T PI缓冲区

00:15:20.250 --> 00:15:25.230
它们都获得的响应主体字节

00:15:22.500 --> 00:15:27.810
积累，然后不完整

00:15:25.230 --> 00:15:30.389
转换为字符串及其

00:15:27.810 --> 00:15:36.240
在这种情况下，字符串是一些XML 

00:15:30.389 --> 00:15:39.180
非常长的线好吧，现在我们已经

00:15:36.240 --> 00:15:42.060
看过如何编写自定义正文

00:15:39.180 --> 00:15:45.300
转换响应的订户

00:15:42.060 --> 00:15:48.870
正文字节转换成字符串如果我们有

00:15:45.300 --> 00:15:51.470
现有流的流订户

00:15:48.870 --> 00:15:51.470
订户

00:15:58.150 --> 00:16:03.800
我们想将其与HTTP一起使用

00:16:00.680 --> 00:16:07.280
客户端HTTP客户端仅与

00:16:03.800 --> 00:16:10.730
好友订阅者，让我们看看我们如何

00:16:07.280 --> 00:16:12.200
可以做到这一点，所以首先

00:16:10.730 --> 00:16:15.290
流订户没有好友

00:16:12.200 --> 00:16:19.190
方法，它也没有伙伴

00:16:15.290 --> 00:16:25.460
 CF为简单起见，我们只打印一下

00:16:19.190 --> 00:16:30.170
如果发生错误，我可以

00:16:25.460 --> 00:16:32.900
在此处删除此流订阅者

00:16:30.170 --> 00:16:38.350
仍然需要某种方式来暴露它

00:16:32.900 --> 00:16:45.700
数据，所以我们给它一个私有字段

00:16:38.350 --> 00:16:45.700
字符串以保持其主体和访问器

00:16:49.510 --> 00:17:00.980
让身体恢复身体正常， 

00:16:57.560 --> 00:17:08.630
现在还不完整，我们需要设置身体

00:17:00.980 --> 00:17:10.850
好的，所以现在我们是字符串订阅者

00:17:08.630 --> 00:17:13.070
这是流程的实现

00:17:10.850 --> 00:17:16.790
订户如何将其与

00:17:13.070 --> 00:17:20.180
 HTTP客户端很好HTTP客户端

00:17:16.790 --> 00:17:22.370
提供便利的静态工厂

00:17:20.180 --> 00:17:25.130
流之间适应的方法

00:17:22.370 --> 00:17:27.730
订户和正文订户，所以让我们

00:17:25.130 --> 00:17:27.730
用其中之一

00:17:38.530 --> 00:17:44.470
因此，有两种来自的变体

00:17:40.930 --> 00:17:47.800
用户适配器首先需要

00:17:44.470 --> 00:17:50.190
订户和订单需要一个

00:17:47.800 --> 00:17:52.690
具有装订器功能的订户

00:17:50.190 --> 00:17:55.390
我们将使用后者，因为我们

00:17:52.690 --> 00:17:59.200
需要从字符串中提取数据

00:17:55.390 --> 00:18:04.210
订户并完成HTTP 

00:17:59.200 --> 00:18:07.210
具有该价值的可计算的未来，因此

00:18:04.210 --> 00:18:10.600
新的字符串订阅者将使用

00:18:07.210 --> 00:18:11.800
字符串订阅者获取正文方法

00:18:10.600 --> 00:18:17.110
从流中提取数据

00:18:11.800 --> 00:18:20.130
订户，所以不要使用新的

00:18:17.110 --> 00:18:25.740
字符串订阅者，我们可以使用

00:18:20.130 --> 00:18:25.740
主体订阅者好吧，让我们运行

00:18:31.470 --> 00:18:37.080
再一次，我们可以看到所有的一切

00:18:33.240 --> 00:18:40.590
暗示，我们有回应

00:18:37.080 --> 00:18:43.259
主体再次作为字符串我们可以简化

00:18:40.590 --> 00:18:45.299
这甚至可以代替使用

00:18:43.259 --> 00:18:49.440
主体订阅者直接将主体

00:18:45.299 --> 00:18:51.690
处理程序和主体处理程序类公开

00:18:49.440 --> 00:18:54.830
相似名称的工厂方法

00:18:51.690 --> 00:18:54.830
让我们使用其中之一

00:19:05.320 --> 00:19:10.040
好吧，所以我们不需要在这里lambda 

00:19:07.490 --> 00:19:12.830
我应该使用身体处理程序吗

00:19:10.040 --> 00:19:19.910
直接运行，以便确保

00:19:12.830 --> 00:19:23.720
很好，很好

00:19:19.910 --> 00:19:26.750
相同的输出，所以我们已经看到了如何编写一个

00:19:23.720 --> 00:19:32.930
自定义主体处理程序以及如何

00:19:26.750 --> 00:19:38.330
使流订阅者适应HTTP正文

00:19:32.930 --> 00:19:40.430
处理程序或正文订阅者

00:19:38.330 --> 00:19:42.350
支持的适配器方法数量

00:19:40.430 --> 00:19:44.570
规则流之间的互操作

00:19:42.350 --> 00:19:47.390
流发布器和流等类型

00:19:44.570 --> 00:19:50.300
订户及其HTTP客户端

00:19:47.390 --> 00:19:52.820
相当于我们刚刚看到的

00:19:50.300 --> 00:19:55.880
订户演示中使用的有两个

00:19:52.820 --> 00:19:58.190
第一个只是接受流程

00:19:55.880 --> 00:20:01.430
订户并返回正文订户

00:19:58.190 --> 00:20:03.230
在这种情况下，避免响应主体为

00:20:01.430 --> 00:20:06.020
无法通过

00:20:03.230 --> 00:20:08.240
 HTTP响应，但通过一些

00:20:06.020 --> 00:20:11.270
其他机制，例如

00:20:08.240 --> 00:20:13.100
数据库第二种变体支持

00:20:11.270 --> 00:20:15.760
将应用的装订器功能

00:20:13.100 --> 00:20:18.700
死亡订户完成后， 

00:20:15.760 --> 00:20:21.500
我们在演示中看到了一个例子

00:20:18.700 --> 00:20:24.320
还有一对类似的方法

00:20:21.500 --> 00:20:27.440
来自可互操作的Lion用户

00:20:24.320 --> 00:20:30.080
带有字符串的流订阅者，其中

00:20:27.440 --> 00:20:32.990
响应正文数据转换为

00:20:30.080 --> 00:20:36.410
串线流并发送到

00:20:32.990 --> 00:20:38.030
流订户流这是

00:20:36.410 --> 00:20:41.210
有点类似于bufferedreader 

00:20:38.030 --> 00:20:43.850
读取行或niño文件Lyons 

00:20:41.210 --> 00:20:44.710
返回行流的方法

00:20:43.850 --> 00:20:47.300
一份文件

00:20:44.710 --> 00:20:52.280
也有等效的适配器

00:20:47.300 --> 00:20:55.580
请求正文的发送方

00:20:52.280 --> 00:20:57.530
总结HTTP客户端对待船

00:20:55.580 --> 00:21:00.020
请求和响应主体为反应性

00:20:57.530 --> 00:21:01.760
流因此获得的好处

00:21:00.020 --> 00:21:04.730
异步编程

00:21:01.760 --> 00:21:07.000
无阻塞背压我们看到了如何

00:21:04.730 --> 00:21:09.740
编写自定义正文订阅者

00:21:07.000 --> 00:21:11.540
行为类似于

00:21:09.740 --> 00:21:15.740
便利机构订户返回

00:21:11.540 --> 00:21:17.510
通过正文订阅者关闭HTTP字符串

00:21:15.740 --> 00:21:19.340
客户端提供了许多适配器

00:21:17.510 --> 00:21:21.230
与现有的互操作

00:21:19.340 --> 00:21:26.240
反应流发布商和

00:21:21.230 --> 00:21:29.270
订阅者，您可以立即下载Java 11 

00:21:26.240 --> 00:21:32.390
在此URL上，请在开放的JDK中加入我们

00:21:29.270 --> 00:21:35.810
或通过开放的JDK在Twitter上关注我们，或

00:21:32.390 --> 00:21:43.070
我自己的Twitter句柄是Java 11 

00:21:35.810 --> 00:21:45.020
在检查器999甲骨文是

00:21:43.070 --> 00:21:46.880
 java提供了大量的

00:21:45.020 --> 00:21:50.990
开发工程资金

00:21:46.880 --> 00:21:53.000
 Java SE平台和开放的JDK Oracle 

00:21:50.990 --> 00:21:55.910
提供一流的总理支持

00:21:53.000 --> 00:21:58.490
易于购买的低成本

00:21:55.910 --> 00:22:00.050
具有简单的定价等级谢谢

00:21:58.490 --> 00:22:04.200
观看

00:22:00.050 --> 00:22:04.200
 [音乐] 

