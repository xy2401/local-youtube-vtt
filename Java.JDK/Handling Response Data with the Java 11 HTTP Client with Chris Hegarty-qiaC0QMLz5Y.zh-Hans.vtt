WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.450 --> 00:00:07.589
 [音乐] 

00:00:04.310 --> 00:00:09.929
嗨，我叫克里斯·哈格蒂（Chris Haggerty），我在这里工作

00:00:07.589 --> 00:00:11.070
 Oracle的Java平台小组和

00:00:09.929 --> 00:00:13.530
今天我要说的是

00:00:11.070 --> 00:00:19.199
用Java 11处理响应数据

00:00:13.530 --> 00:00:20.699
在此会话中的HTTP客户端

00:00:19.199 --> 00:00:22.529
从高层次看

00:00:20.699 --> 00:00:25.470
 Java中的反应流接口

00:00:22.529 --> 00:00:27.900
平台及其使用方式

00:00:25.470 --> 00:00:30.599
知识之后，我们将了解HTTP 

00:00:27.900 --> 00:00:33.780
客户利用这些接口来

00:00:30.599 --> 00:00:35.399
处理请求和响应机构

00:00:33.780 --> 00:00:37.800
通过一个如何写作的例子

00:00:35.399 --> 00:00:40.290
定制响应主体订户，以及

00:00:37.800 --> 00:00:44.430
如何与现有流程互操作

00:00:40.290 --> 00:00:46.500
之前的发布者和订阅者

00:00:44.430 --> 00:00:48.149
看着反应流

00:00:46.500 --> 00:00:50.280
有助于提醒自己

00:00:48.149 --> 00:00:52.710
经典的生产者/消费者范例和

00:00:50.280 --> 00:00:55.680
一些潜在的问题和

00:00:52.710 --> 00:00:58.350
通常是生产者的问题

00:00:55.680 --> 00:01:00.930
生成项目或数据将其放入

00:00:58.350 --> 00:01:03.570
相同的队列或缓冲区

00:01:00.930 --> 00:01:05.610
消费者消耗数据的时间

00:01:03.570 --> 00:01:08.670
一次从

00:01:05.610 --> 00:01:10.470
缓冲问题是如何确保

00:01:08.670 --> 00:01:12.420
当生产者没有被阻止时

00:01:10.470 --> 00:01:14.939
缓冲区已满或

00:01:12.420 --> 00:01:16.770
消费者在以下情况下不尝试获取数据

00:01:14.939 --> 00:01:18.869
缓冲区为空，并且有一个

00:01:16.770 --> 00:01:21.750
通知机制来实现

00:01:18.869 --> 00:01:24.830
如果发生以及尝试

00:01:21.750 --> 00:01:28.590
确定合理的缓冲区大小

00:01:24.830 --> 00:01:30.720
转向反应性生产者

00:01:28.590 --> 00:01:34.380
被称为发布者

00:01:30.720 --> 00:01:37.890
被消费者称为

00:01:34.380 --> 00:01:39.720
接收项目的订户

00:01:37.890 --> 00:01:42.840
发布者订阅了一个方法

00:01:39.720 --> 00:01:46.200
需要一个订阅者

00:01:42.840 --> 00:01:49.290
有四种取消订阅的方法

00:01:46.200 --> 00:01:52.740
错误，完整的我们来看一下

00:01:49.290 --> 00:01:54.780
现在，这些用户可以

00:01:52.740 --> 00:01:57.180
通过调用

00:01:54.780 --> 00:02:00.570
发布者订阅的方法和传递

00:01:57.180 --> 00:02:02.790
订阅者，发布者拒绝致电

00:02:00.570 --> 00:02:05.790
订户的退订方法

00:02:02.790 --> 00:02:08.129
两次握手之间的订阅

00:02:05.790 --> 00:02:09.599
订阅者和发布者结果

00:02:08.129 --> 00:02:12.270
在发布者中引用

00:02:09.599 --> 00:02:13.650
订户和订户具有

00:02:12.270 --> 00:02:17.370
发布者订阅

00:02:13.650 --> 00:02:18.900
它是在取消订阅时给出的

00:02:17.370 --> 00:02:20.849
充当

00:02:18.900 --> 00:02:24.620
订户发送的机制

00:02:20.849 --> 00:02:27.329
例如向发布者发出信号

00:02:24.620 --> 00:02:29.280
使用订阅订阅者

00:02:27.329 --> 00:02:32.609
可以从

00:02:29.280 --> 00:02:35.849
发布者然后可以发布

00:02:32.609 --> 00:02:37.980
最多可以致电

00:02:35.849 --> 00:02:41.359
订户我们的下一个方法

00:02:37.980 --> 00:02:44.129
单个项目的次数

00:02:41.359 --> 00:02:46.620
该请求机制提供了

00:02:44.129 --> 00:02:48.510
订户具有背压，因为它

00:02:46.620 --> 00:02:52.409
控制最大数量

00:02:48.510 --> 00:02:55.099
如果

00:02:52.409 --> 00:02:58.019
发布者没有其他要发布的项目

00:02:55.099 --> 00:03:00.840
然后呼叫订户

00:02:58.019 --> 00:03:03.239
通知订户的方法

00:03:00.840 --> 00:03:06.000
发行人，无论需求如何

00:03:03.239 --> 00:03:09.840
更多项目将不会发布更多项目给

00:03:06.000 --> 00:03:12.150
 Dis订阅者（如果发布者） 

00:03:09.840 --> 00:03:14.730
遇到错误，请说从

00:03:12.150 --> 00:03:17.220
文件或网络，然后通知

00:03:14.730 --> 00:03:19.440
的订户，请致电

00:03:17.220 --> 00:03:23.720
订户使用错误方法

00:03:19.440 --> 00:03:23.720
适当的故障指示问题

00:03:23.810 --> 00:03:28.230
 Java平台提供支持

00:03:26.489 --> 00:03:30.720
反应流到许多

00:03:28.230 --> 00:03:33.329
 java.util中的并发接口

00:03:30.720 --> 00:03:35.879
流类有一个发布者

00:03:33.329 --> 00:03:38.909
发布订户的项目

00:03:35.879 --> 00:03:41.459
接收订户订阅的项目

00:03:38.909 --> 00:03:46.109
给发布者，可以发出请求

00:03:41.459 --> 00:03:48.959
用于HTTP客户端所需的项目

00:03:46.109 --> 00:03:51.859
模型使用以下类型的子类型请求正文

00:03:48.959 --> 00:03:54.870
流发布者请求主体发布者

00:03:51.859 --> 00:03:57.269
 HTTP客户端订阅此

00:03:54.870 --> 00:04:00.959
发布者在发送请求时

00:03:57.269 --> 00:04:02.699
当一个

00:04:00.959 --> 00:04:05.900
收到响应代码和标头

00:04:02.699 --> 00:04:08.489
 HTTP客户端调用主体处理程序

00:04:05.900 --> 00:04:10.979
然后，车身搬运工可以检查这些

00:04:08.489 --> 00:04:14.099
如果愿意，可以在创建一个

00:04:10.979 --> 00:04:16.680
该订阅者返回的正文订阅者

00:04:14.099 --> 00:04:18.539
由身体猎人会习惯

00:04:16.680 --> 00:04:22.740
接收并处理实际响应

00:04:18.539 --> 00:04:24.850
正文字节，HTTP正文订阅者是

00:04:22.740 --> 00:04:27.820
流订阅者的子类型

00:04:24.850 --> 00:04:30.970
并且httpclient充当以下内容的发布者： 

00:04:27.820 --> 00:04:32.590
响应伙伴字节中有一个数字

00:04:30.970 --> 00:04:34.930
制造身体的工厂

00:04:32.590 --> 00:04:37.720
大多数的出版商和团体订阅者

00:04:34.930 --> 00:04:40.000
常见用例，例如发布请求

00:04:37.720 --> 00:04:41.920
字符串或文件中的主体

00:04:40.000 --> 00:04:46.600
将响应主体字节转换为

00:04:41.920 --> 00:04:48.310
字符串或将它们流式传输到文件中

00:04:46.600 --> 00:04:51.730
本届会议我们将重点关注

00:04:48.310 --> 00:04:53.410
响应主体处理程序具有功能

00:04:51.730 --> 00:04:55.750
具有单一方法的接口

00:04:53.410 --> 00:04:58.770
应用需要回复信息

00:04:55.750 --> 00:05:01.330
包含状态码和标题

00:04:58.770 --> 00:05:02.830
当

00:05:01.330 --> 00:05:05.590
响应状态代码和标头为

00:05:02.830 --> 00:05:08.410
可用，但在实际回复之前

00:05:05.590 --> 00:05:10.930
正文字节已收到正文

00:05:08.410 --> 00:05:12.670
处理程序可以检查响应代码并

00:05:10.930 --> 00:05:15.700
返回正文之前的标题

00:05:12.670 --> 00:05:17.590
然后，主体订阅者将

00:05:15.700 --> 00:05:22.600
用于接收实际的响应

00:05:17.590 --> 00:05:24.940
主体字节主体订户是流

00:05:22.600 --> 00:05:27.400
字节总数的订户

00:05:24.940 --> 00:05:30.580
缓冲包含的字节缓冲区

00:05:27.400 --> 00:05:32.860
订户的响应正文字节

00:05:30.580 --> 00:05:35.710
有一个抽象方法get'body 

00:05:32.860 --> 00:05:37.350
返回完成阶段

00:05:35.710 --> 00:05:39.760
上级完成

00:05:37.350 --> 00:05:41.800
输入正文订阅者

00:05:39.760 --> 00:05:45.160
实施将转换为响应

00:05:41.800 --> 00:05:47.830
正文字节进入正文订阅者

00:05:45.160 --> 00:05:50.470
该类仅包含学习静态工厂

00:05:47.830 --> 00:05:52.960
方法，这些方法是工厂

00:05:50.470 --> 00:05:56.230
用于创建可以

00:05:52.960 --> 00:05:58.030
通过以下方式用于最常见的用例

00:05:56.230 --> 00:06:00.220
将响应主体转换为字节

00:05:58.030 --> 00:06:04.480
数组或字符串或将其流式传输到

00:06:00.220 --> 00:06:06.520
文件或输入流，让我们

00:06:04.480 --> 00:06:12.310
看写一个自定义主体订户

00:06:06.520 --> 00:06:13.840
用于处理响应数据，所以让我们

00:06:12.310 --> 00:06:16.690
看看如何编写自定义

00:06:13.840 --> 00:06:18.760
身体饥饿和身体订户之前

00:06:16.690 --> 00:06:23.040
这样做，让我们来看看如何

00:06:18.760 --> 00:06:26.620
便利车身搬运工的工作

00:06:23.040 --> 00:06:30.220
所以这里我们有一个实用的get方法

00:06:26.620 --> 00:06:33.520
它检索给定的URI并返回

00:06:30.220 --> 00:06:36.880
响应主体为字符串，因此首先

00:06:33.520 --> 00:06:37.510
创建一个新的HTTP客户端，通过该客户端

00:06:36.880 --> 00:06:41.110
请求正在进行

00:06:37.510 --> 00:06:44.650
他发送了，然后建立了一个请求

00:06:41.110 --> 00:06:47.950
给定的URI，然后调用发送异步

00:06:44.650 --> 00:06:50.500
发送他使用的请求的方法

00:06:47.950 --> 00:06:52.960
字符串静态的身体猎人

00:06:50.500 --> 00:06:55.930
创建身体猎人的工厂方法

00:06:52.960 --> 00:06:58.990
将响应主体字节转换为

00:06:55.930 --> 00:07:01.870
一个字符串，然后是可完成的未来

00:06:58.990 --> 00:07:05.140
然后应用方法映射HTTP响应

00:07:01.870 --> 00:07:07.510
在我们的案例中，字符串与其主体类型有关

00:07:05.140 --> 00:07:10.990
字符串和一个可完成的未来

00:07:07.510 --> 00:07:13.120
返回字符串，所以我们可以看到示例

00:07:10.990 --> 00:07:16.390
新的此类艺术家主要获得方法

00:07:13.120 --> 00:07:20.380
方法，所以在这里我们可以看到get方法

00:07:16.390 --> 00:07:21.880
被传递URI，然后加入是

00:07:20.380 --> 00:07:25.480
被称为未来的完成

00:07:21.880 --> 00:07:27.790
返回这将阻止执行

00:07:25.480 --> 00:07:30.070
直到字符串响应主体为

00:07:27.790 --> 00:07:39.070
可用，然后程序简单

00:07:30.070 --> 00:07:40.930
打印出身体，让我们运行

00:07:39.070 --> 00:07:44.220
在这里我们可以看到响应正文字符串

00:07:40.930 --> 00:07:46.600
被打印出来，它只是一些XML 

00:07:44.220 --> 00:07:50.700
在这一点上，看到

00:07:46.600 --> 00:07:50.700
响应状态代码，让我们打印出来

00:07:59.500 --> 00:08:05.090
所以在这里我们用在可完成的未来

00:08:02.030 --> 00:08:07.250
当完整的方法打印出来

00:08:05.090 --> 00:08:10.880
状态码我们应该检查一下

00:08:07.250 --> 00:08:12.970
响应值为none no in 

00:08:10.880 --> 00:08:17.300
为了简单起见发生错误

00:08:12.970 --> 00:08:20.660
然后暂时打印它以便运行

00:08:17.300 --> 00:08:22.790
再次好吧，我们可以看到

00:08:20.660 --> 00:08:25.250
响应码是200，所以一切

00:08:22.790 --> 00:08:28.000
好的，响应主体是

00:08:25.250 --> 00:08:30.500
好了，就这样

00:08:28.000 --> 00:08:33.589
使用便利之一工作

00:08:30.500 --> 00:08:45.680
身体处理者让我们看一下

00:08:33.589 --> 00:08:49.160
编写我们自己的，所以我们需要实施

00:08:45.680 --> 00:08:53.230
主体用户界面和

00:08:49.160 --> 00:08:53.230
在这种情况下，我们的类型是字符串

00:08:59.490 --> 00:09:02.940
主体订户只有一种方法

00:09:01.200 --> 00:09:05.580
叫得到身体在返回

00:09:02.940 --> 00:09:09.180
 TT的完成阶段是

00:09:05.580 --> 00:09:12.810
我们的案例，我们还必须执行

00:09:09.180 --> 00:09:14.970
流订户的四种方法

00:09:12.810 --> 00:09:17.190
让我们看看他们，我们将开始

00:09:14.970 --> 00:09:18.990
用get body方法，这样他们就可以

00:09:17.190 --> 00:09:22.230
 body方法需要返回完成

00:09:18.990 --> 00:09:23.399
字符串的阶段，让我们使用completable 

00:09:22.230 --> 00:09:27.440
具体的未来

00:09:23.399 --> 00:09:27.440
完成阶段的实施

00:09:36.480 --> 00:09:42.280
所以我们称之为兼容的未来

00:09:39.610 --> 00:09:45.280
嘿哥们CF，因为它拥有

00:09:42.280 --> 00:09:48.310
响应主体以及可以返回的位置

00:09:45.280 --> 00:09:54.490
从猫的身体方法，现在我们将

00:09:48.310 --> 00:09:56.440
继续取消订阅，以便HTTP 

00:09:54.490 --> 00:10:00.130
客户是响应机构的发布者

00:09:56.440 --> 00:10:02.770
这个字符串订阅者订阅

00:10:00.130 --> 00:10:05.770
该发行商，因此首先它将拥有其

00:10:02.770 --> 00:10:10.420
用调用的取消订阅方法

00:10:05.770 --> 00:10:13.410
来自HTTP客户端的订阅，因此

00:10:10.420 --> 00:10:13.410
让我们存储该订阅

00:10:23.190 --> 00:10:28.840
好吧，现在我们可以订阅了

00:10:26.800 --> 00:10:30.220
请求其他响应主体

00:10:28.840 --> 00:10:33.370
客户，或者我们可以取消订阅

00:10:30.220 --> 00:10:36.960
如果我们不再感兴趣，让我们

00:10:33.370 --> 00:10:39.400
要求更多，只要求一个

00:10:36.960 --> 00:10:42.070
在这一点上，我们可以查找挂钩

00:10:39.400 --> 00:10:47.790
错误处理，所以我们完成了正文

00:10:42.070 --> 00:10:47.790
错误发生后异常

00:10:48.840 --> 00:10:54.730
在这个简单的实现中

00:10:52.300 --> 00:10:56.290
只是积累所有的响应数据

00:10:54.730 --> 00:10:59.650
列表中的管道缓冲区

00:10:56.290 --> 00:11:04.480
然后我们将转换响应

00:10:59.650 --> 00:11:07.560
主体最后变成字符串，让我们

00:11:04.480 --> 00:11:07.560
建立清单

00:11:26.930 --> 00:11:31.690
好的，所以每次响应日期都是

00:11:29.540 --> 00:11:37.520
收到，我们将其添加到列表中

00:11:31.690 --> 00:11:39.110
让我们保留一个更好的名字好吧

00:11:37.520 --> 00:11:42.290
所以我们只剩下不完整的

00:11:39.110 --> 00:11:45.560
方法再次在此工具中

00:11:42.290 --> 00:11:47.330
实施，我们将确定

00:11:45.560 --> 00:11:49.220
我们放入它们的字节数

00:11:47.330 --> 00:11:52.210
字节数组，然后将其转换

00:11:49.220 --> 00:11:52.210
字节数组转换成字符串

00:12:02.760 --> 00:12:07.230
所以一旦我们知道打架次数

00:12:05.610 --> 00:12:09.000
每个字节缓冲区中剩余的空间我们可以求和

00:12:07.230 --> 00:12:12.420
那就是总数

00:12:09.000 --> 00:12:15.829
我们字节数组中需要的字节

00:12:12.420 --> 00:12:15.829
让我们创建一个这样大小的战斗阵列

00:12:18.380 --> 00:12:26.510
好吧，现在我们可以遍历缓冲区了

00:12:31.930 --> 00:12:41.650
字节数组什么也没有

00:12:37.780 --> 00:12:45.070
调用缓冲区应该优先于

00:12:41.650 --> 00:12:52.150
 doc此时获取字节数组，我们

00:12:45.070 --> 00:12:54.370
需要补偿，所以很棒

00:12:52.150 --> 00:12:56.650
应该为零，我们需要一个

00:12:54.370 --> 00:13:09.070
长度，长度将是

00:12:56.650 --> 00:13:16.860
剩余的字节数，这是

00:13:09.070 --> 00:13:23.200
偏移量，我们需要增加偏移量

00:13:16.860 --> 00:13:25.660
因为我们迭代好了，现在我们有一个

00:13:23.200 --> 00:13:31.930
字节数组中的响应正文字节

00:13:25.660 --> 00:13:34.180
让我们将其转换为字符串

00:13:31.930 --> 00:13:37.180
简单的目的，我们将忽略

00:13:34.180 --> 00:13:39.430
现在可以在转换时充电很好

00:13:37.180 --> 00:13:46.750
我们有我们的字符串，让我们完成

00:13:39.430 --> 00:13:49.330
那个绳子的身体CF可以

00:13:46.750 --> 00:13:50.460
一切看起来都很好，我们忘记了

00:13:49.330 --> 00:13:53.440
一样东西

00:13:50.460 --> 00:13:55.960
因为我们只有退订

00:13:53.440 --> 00:13:57.760
每次要求再打一次电话

00:13:55.960 --> 00:14:00.520
我们收到回电，我们想

00:13:57.760 --> 00:14:04.180
请求另一个，这样一个步骤

00:14:00.520 --> 00:14:06.940
好的，现在我们有了琴弦

00:14:04.180 --> 00:14:11.380
订阅者让我们通过HTTP进行连接

00:14:06.940 --> 00:14:15.130
客户，所以我们需要回应

00:14:11.380 --> 00:14:16.960
您的赞助人身体处理者在这里回应

00:14:15.130 --> 00:14:20.410
派对处理程序是一个接口函数

00:14:16.960 --> 00:14:22.540
响应信息需要返回一个

00:14:20.410 --> 00:14:24.040
在我们的情况下，我们将

00:14:22.540 --> 00:14:29.640
无条件返回字符串

00:14:24.040 --> 00:14:29.640
订阅者好吧，让我们运行它

00:14:35.379 --> 00:14:40.939
好的，我们已经回复了代码200 

00:14:38.029 --> 00:14:43.879
再次，我们有我们的反应伙伴

00:14:40.939 --> 00:14:45.980
一个字符串，让我们看看

00:14:43.879 --> 00:14:50.019
这里发生了什么，让我们添加一个

00:14:45.980 --> 00:14:50.019
下次通话的调试语句

00:14:52.149 --> 00:14:55.149
哎呀

00:14:55.420 --> 00:15:02.629
接下来，它被称为缓冲区和

00:14:58.720 --> 00:15:07.279
我们将更改URI，以便获得一些

00:15:02.629 --> 00:15:16.519
更多的响应数据好吧，让我们运行

00:15:07.279 --> 00:15:19.069
再次好吧，我们可以在Nexus上看到

00:15:16.519 --> 00:15:20.839
叫我们吃饭的次数

00:15:19.069 --> 00:15:23.689
包含响应主体的缓冲区

00:15:20.839 --> 00:15:24.410
他们都积累的字节，然后

00:15:23.689 --> 00:15:27.799
在不完整的

00:15:24.410 --> 00:15:30.379
他们被转换成字符串，他们

00:15:27.799 --> 00:15:36.230
在这种情况下，字符串是一些XML 

00:15:30.379 --> 00:15:39.169
非常长的线好吧，现在我们已经

00:15:36.230 --> 00:15:42.049
看过如何编写自定义正文

00:15:39.169 --> 00:15:45.290
转换响应的订户

00:15:42.049 --> 00:15:48.860
正文字节转换成字符串如果我们有

00:15:45.290 --> 00:15:51.459
现有低点的流订户

00:15:48.860 --> 00:15:51.459
订户

00:15:58.150 --> 00:16:03.800
我们想将其与HTTP一起使用

00:16:00.650 --> 00:16:07.340
客户端HTTP客户端仅适用于

00:16:03.800 --> 00:16:10.730
好友订阅者，让我们看看我们如何

00:16:07.340 --> 00:16:12.200
可以做到这一点，所以首先

00:16:10.730 --> 00:16:15.290
流订户没有好友

00:16:12.200 --> 00:16:19.190
方法，它也没有伙伴

00:16:15.290 --> 00:16:25.460
 CF为简单起见，我们只打印一下

00:16:19.190 --> 00:16:28.150
如果发生错误，我可以

00:16:25.460 --> 00:16:31.250
在这里删除

00:16:28.150 --> 00:16:36.770
因此流订阅者仍然需要一些

00:16:31.250 --> 00:16:41.780
公开其数据的方式，让我们给

00:16:36.770 --> 00:16:51.410
它是一个专用字段字符串来保存其

00:16:41.780 --> 00:16:59.450
主体和访问器使主体返回

00:16:51.410 --> 00:17:07.490
身体还不错，现在我们还不完整

00:16:59.450 --> 00:17:09.740
需要设置好身体区域，所以现在

00:17:07.490 --> 00:17:12.260
我们是字符串订户，这是一个

00:17:09.740 --> 00:17:14.500
流订户的实现方式

00:17:12.260 --> 00:17:18.370
我们可以将其与HTTP客户端一起使用吗

00:17:14.500 --> 00:17:21.230
 HTTP客户端提供的很好

00:17:18.370 --> 00:17:23.450
方便的静态工厂方法

00:17:21.230 --> 00:17:27.700
在流量使用者和身体之间适应

00:17:23.450 --> 00:17:27.700
订户，所以我们使用其中之一

00:17:38.170 --> 00:17:44.450
因此，有两种来自的变体

00:17:40.910 --> 00:17:47.780
用户适配器首先需要

00:17:44.450 --> 00:17:50.170
一个订户，另一个订一个

00:17:47.780 --> 00:17:52.670
具有装订器功能的订户

00:17:50.170 --> 00:17:55.400
我们将使用后者，因为我们

00:17:52.670 --> 00:17:59.180
需要从字符串中提取数据

00:17:55.400 --> 00:18:04.010
订户并完成HTTP 

00:17:59.180 --> 00:18:07.220
具有这种价值的可计算未来

00:18:04.010 --> 00:18:10.610
您的新字符串订阅者或使用

00:18:07.220 --> 00:18:11.810
字符串订阅者获取正文方法

00:18:10.610 --> 00:18:17.450
从流中提取数据

00:18:11.810 --> 00:18:21.140
订户，而不是使用新字符串

00:18:17.450 --> 00:18:25.750
用户可以在这里使用主体

00:18:21.140 --> 00:18:25.750
订阅者好吧，让我们运行

00:18:31.550 --> 00:18:37.070
再一次，我们可以看到所有的一切

00:18:33.350 --> 00:18:40.580
暗示，我们有回应

00:18:37.070 --> 00:18:43.250
主体再次作为字符串我们可以简化

00:18:40.580 --> 00:18:45.290
这甚至可以代替使用

00:18:43.250 --> 00:18:49.400
主体订阅者直接将主体

00:18:45.290 --> 00:18:51.680
处理程序和主体处理程序类公开

00:18:49.400 --> 00:18:54.820
相似名称的工厂方法

00:18:51.680 --> 00:18:54.820
让我们使用其中之一

00:19:05.320 --> 00:19:09.620
好，所以我们不需要在这里降落

00:19:07.460 --> 00:19:12.649
我们应该只是一个伙伴吗

00:19:09.620 --> 00:19:19.909
直接处理程序，所以实际上不是

00:19:12.649 --> 00:19:23.690
确保它可以正常工作

00:19:19.909 --> 00:19:26.720
相同的输出，所以我们已经看到了如何编写一个

00:19:23.690 --> 00:19:32.929
自定义主体处理程序以及如何

00:19:26.720 --> 00:19:38.330
使流订阅者适应HTTP正文

00:19:32.929 --> 00:19:40.399
处理程序或正文订阅者

00:19:38.330 --> 00:19:42.350
支持的适配器方法数量

00:19:40.399 --> 00:19:44.539
规则流之间的互操作

00:19:42.350 --> 00:19:47.360
缓慢的发布者和缓慢的类型

00:19:44.539 --> 00:19:50.270
订户及其HTTP客户端

00:19:47.360 --> 00:19:52.820
相当于我们刚刚看到的

00:19:50.270 --> 00:19:55.880
订户演示中使用的有两个

00:19:52.820 --> 00:19:58.159
第一个只是接受流程

00:19:55.880 --> 00:20:01.429
订户并返回正文订户

00:19:58.159 --> 00:20:03.200
在这种情况下，避免响应主体为

00:20:01.429 --> 00:20:05.990
无法通过

00:20:03.200 --> 00:20:08.210
 HTTP响应，但通过一些

00:20:05.990 --> 00:20:11.240
其他机制，例如

00:20:08.210 --> 00:20:13.130
数据库第二种变体支持

00:20:11.240 --> 00:20:15.169
将应用的装订器功能

00:20:13.130 --> 00:20:18.020
死亡订户完成后

00:20:15.169 --> 00:20:21.110
我们在

00:20:18.020 --> 00:20:23.600
演示中也有类似的一对

00:20:21.110 --> 00:20:26.000
来自Lion订户的方法

00:20:23.600 --> 00:20:29.179
与以下用户交互： 

00:20:26.000 --> 00:20:31.630
响应正文数据所在的字符串

00:20:29.179 --> 00:20:35.200
转换为字符串流并

00:20:31.630 --> 00:20:37.279
逐行发送到流订户

00:20:35.200 --> 00:20:40.159
这有点类似于

00:20:37.279 --> 00:20:43.010
 bufferedreader读取行或行

00:20:40.159 --> 00:20:44.679
返回流的Lions文件方法

00:20:43.010 --> 00:20:47.299
文件中的行数

00:20:44.679 --> 00:20:52.250
也有等效的适配器

00:20:47.299 --> 00:20:55.549
请求正文的发送方

00:20:52.250 --> 00:20:57.529
总结HTTP客户端对待船

00:20:55.549 --> 00:20:59.960
请求和响应主体为反应性

00:20:57.529 --> 00:21:01.730
流因此获得的好处

00:20:59.960 --> 00:21:03.279
异步编程

00:21:01.730 --> 00:21:05.929
无阻塞背压

00:21:03.279 --> 00:21:08.659
我们看到了如何编写自定义正文

00:21:05.929 --> 00:21:10.520
行为良好的订户实现

00:21:08.659 --> 00:21:12.649
与便利机构相似

00:21:10.520 --> 00:21:15.159
正文订阅者返回的订阅者

00:21:12.649 --> 00:21:15.159
字符串

00:21:15.360 --> 00:21:19.350
 ttp客户端提供了许多适配器

00:21:17.370 --> 00:21:21.210
与现有的互操作

00:21:19.350 --> 00:21:26.220
反应流发布商和

00:21:21.210 --> 00:21:29.250
订阅者，您可以立即下载java 11 

00:21:26.220 --> 00:21:32.370
在此URL上，请在开放的JDK中加入我们

00:21:29.250 --> 00:21:35.790
或在openjdk的Twitter上关注我们，或

00:21:32.370 --> 00:21:43.080
我自己的Twitter句柄是Java 11 

00:21:35.790 --> 00:21:45.000
在检查器999甲骨文是

00:21:43.080 --> 00:21:46.860
 java提供了大量的

00:21:45.000 --> 00:21:50.970
开发工程资金

00:21:46.860 --> 00:21:53.040
 Java SE平台并打开JDK oracle 

00:21:50.970 --> 00:21:55.890
提供一流的总理支持

00:21:53.040 --> 00:21:58.500
易于购买的低成本

00:21:55.890 --> 00:22:00.040
具有简单的定价等级谢谢

00:21:58.500 --> 00:22:04.190
观看

00:22:00.040 --> 00:22:04.190
 [音乐] 

