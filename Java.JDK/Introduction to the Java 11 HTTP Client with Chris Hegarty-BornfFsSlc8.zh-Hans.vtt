WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.980 --> 00:00:09.960
嗨，我叫克里斯·哈格蒂（Chris Haggerty） 

00:00:07.319 --> 00:00:11.429
 Oracle和当今的Java平台小组

00:00:09.960 --> 00:00:17.670
我将向您介绍

00:00:11.429 --> 00:00:19.230
此会话中的Java 11th HTTP客户端

00:00:17.670 --> 00:00:20.670
我们将主要看一下

00:00:19.230 --> 00:00:22.650
 API的类型

00:00:20.670 --> 00:00:24.900
它们可以是什么模块和包装

00:00:22.650 --> 00:00:27.720
发现必须执行一些基本的

00:00:24.900 --> 00:00:31.489
发送请求和

00:00:27.720 --> 00:00:33.930
响应方如何建模

00:00:31.489 --> 00:00:37.940
 JDK中的增强功能通过以下方式完成

00:00:33.930 --> 00:00:40.710
 JDK增强建议JEB 321 

00:00:37.940 --> 00:00:44.610
标准化正在孵化的API 

00:00:40.710 --> 00:00:46.829
在先前的JDK版本中，HTTP客户端

00:00:44.610 --> 00:00:49.649
由Java net HTTP模块提供

00:00:46.829 --> 00:00:52.469
该模块将导出一个包

00:00:49.649 --> 00:00:55.110
与以前的名字不同

00:00:52.469 --> 00:00:58.289
孵化版本此模块现在

00:00:55.110 --> 00:01:00.480
 Java SE平台的一部分

00:00:58.289 --> 00:01:03.530
是默认情况下解决的

00:01:00.480 --> 00:01:06.689
编译正在运行的非模块化代码

00:01:03.530 --> 00:01:09.150
模块化代码可以在其模块信息中

00:01:06.689 --> 00:01:12.510
源文件需要Java网络

00:01:09.150 --> 00:01:17.880
直接使用HTTP模块或需要Java 

00:01:12.510 --> 00:01:20.939
 SE聚合器模块HTTP客户端

00:01:17.880 --> 00:01:23.009
 class是HTTP的顶级类型

00:01:20.939 --> 00:01:26.670
客户可以用来发送请求和

00:01:23.009 --> 00:01:29.310
检索他们的响应HTTP客户端是

00:01:26.670 --> 00:01:32.430
为建造者创建的建造者可以是

00:01:29.310 --> 00:01:34.680
用于配置每个客户端状态，例如

00:01:32.430 --> 00:01:38.640
首选协议版本

00:01:34.680 --> 00:01:42.390
是否遵循HTTP 1 1或HTTP 2 

00:01:38.640 --> 00:01:46.920
重定向我连接时间为的代理

00:01:42.390 --> 00:01:48.720
一旦建立了HTTP客户， 

00:01:46.920 --> 00:01:53.430
不变的，可以用来发送

00:01:48.720 --> 00:01:55.430
多个请求HTTP客户端API 

00:01:53.430 --> 00:01:58.049
遵循熟悉的构建器模式

00:01:55.430 --> 00:02:01.469
有工厂供贸易商

00:01:58.049 --> 00:02:05.340
用于顶级HTTP客户端和

00:02:01.469 --> 00:02:07.619
本例中的HTTP请求类型

00:02:05.340 --> 00:02:10.440
 HTTP客户端新构建器静态工厂

00:02:07.619 --> 00:02:11.599
方法返回HTTP的新生成器

00:02:10.440 --> 00:02:14.269
客户

00:02:11.599 --> 00:02:17.989
首选协议版本HTTP到

00:02:14.269 --> 00:02:20.900
设置哪个是默认的正常

00:02:17.989 --> 00:02:23.540
设置了重定向策略，这意味着

00:02:20.900 --> 00:02:27.109
除非遵循以下指示，否则始终遵循重定向

00:02:23.540 --> 00:02:30.500
从更安全的HTTPS重定向到

00:02:27.109 --> 00:02:33.469
 HTTP的安全性越差

00:02:30.500 --> 00:02:36.200
给定的地址和端口设置了一个系统

00:02:33.469 --> 00:02:38.560
默认情况下，在

00:02:36.200 --> 00:02:40.849
网站需要身份验证的情况

00:02:38.560 --> 00:02:43.010
连接新超时

00:02:40.849 --> 00:02:46.459
连接设置为20秒， 

00:02:43.010 --> 00:02:49.989
然后客户端建立多个

00:02:46.459 --> 00:02:54.680
请求可以由单个客户端发送

00:02:49.989 --> 00:02:57.980
建立了HTTP请求实例

00:02:54.680 --> 00:03:00.139
通过HTTP请求构建器

00:02:57.980 --> 00:03:03.799
可以设置请求URI 

00:03:00.139 --> 00:03:07.099
将标头标为e和a的方法

00:03:03.799 --> 00:03:12.349
建立后请求特定的超时时间

00:03:07.099 --> 00:03:15.769
 HTTP请求是不变的，类似于

00:03:12.349 --> 00:03:17.870
 HTTP客户端HTTP请求有一个新的

00:03:15.769 --> 00:03:21.049
生成一个

00:03:17.870 --> 00:03:24.229
新的HTTP请求构建器

00:03:21.049 --> 00:03:27.709
可用于设置每个请求状态

00:03:24.229 --> 00:03:30.829
在此示例中，设置了请求URI 

00:03:27.709 --> 00:03:33.189
打开我要求的JDK da java.net 

00:03:30.829 --> 00:03:36.530
一分钟内的特定时间设置

00:03:33.189 --> 00:03:39.560
标头，指示内容类型，因为

00:03:36.530 --> 00:03:42.199
这将是一个职位要求的身体

00:03:39.560 --> 00:03:44.780
文件工厂方法的发布者是

00:03:42.199 --> 00:03:47.419
用于返回请求正文发布者

00:03:44.780 --> 00:03:52.400
发布给定内容的

00:03:47.419 --> 00:03:54.530
在这种情况下，JSON请求中的文件路径

00:03:52.400 --> 00:03:59.810
是不可变的，可以多次发送

00:03:54.530 --> 00:04:02.209
不创建HTTP响应的时间

00:03:59.810 --> 00:04:05.750
直接但作为结果返回

00:04:02.209 --> 00:04:08.299
发送HTTP请求HTTP 

00:04:05.750 --> 00:04:10.129
当

00:04:08.299 --> 00:04:12.829
响应状态代码和标头具有

00:04:10.129 --> 00:04:14.509
已收到，通常在

00:04:12.829 --> 00:04:17.719
反应体也已经完全

00:04:14.509 --> 00:04:19.549
是否收到HTTP 

00:04:17.719 --> 00:04:21.049
响应在

00:04:19.549 --> 00:04:24.050
反应体已经完全

00:04:21.049 --> 00:04:26.800
收到取决于身体处理者

00:04:24.050 --> 00:04:29.210
发送HTTP请求时提供

00:04:26.800 --> 00:04:31.099
我们来看看身体的饥饿感

00:04:29.210 --> 00:04:33.219
稍后在车床上更紧密地

00:04:31.099 --> 00:04:35.960
介绍

00:04:33.219 --> 00:04:38.960
 HTTP响应提供了以下方法

00:04:35.960 --> 00:04:42.349
访问响应状态代码

00:04:38.960 --> 00:04:46.810
响应主体和HTTP的标头

00:04:42.349 --> 00:04:46.810
与此响应相对应的请求

00:04:46.900 --> 00:04:53.419
 HTTP客户端支持同步和

00:04:50.300 --> 00:04:56.599
操作请求的异步模式

00:04:53.419 --> 00:04:58.490
使用同步发送方法发送

00:04:56.599 --> 00:05:02.240
阻止当前执行率

00:04:58.490 --> 00:05:04.460
直到发送了可用的响应请求

00:05:02.240 --> 00:05:07.449
使用send async方法返回一个

00:05:04.460 --> 00:05:09.740
 HTTP响应的可完成功能

00:05:07.449 --> 00:05:11.449
 Java 8中添加了可计算的未来

00:05:09.740 --> 00:05:13.460
提供了多种方法

00:05:11.449 --> 00:05:15.620
建立依存行为链

00:05:13.460 --> 00:05:20.719
可以同步运行或

00:05:15.620 --> 00:05:23.029
在此示例中异步

00:05:20.719 --> 00:05:25.550
客户端发送方法被请求

00:05:23.029 --> 00:05:27.860
与身体处理者一并发送

00:05:25.550 --> 00:05:31.490
将响应主体字节转换为

00:05:27.860 --> 00:05:34.610
字符串招标债券状态代码和

00:05:31.490 --> 00:05:36.800
正文打印发送方法块

00:05:34.610 --> 00:05:41.449
调用线程直到响应

00:05:36.800 --> 00:05:43.760
下一个示例可用的是相同的

00:05:41.449 --> 00:05:47.630
仅使用异步编写的代码

00:05:43.760 --> 00:05:50.120
样式发送异步方法被赋予

00:05:47.630 --> 00:05:51.830
请求发送，还有一个尸体

00:05:50.120 --> 00:05:55.190
转换响应主体的猎人

00:05:51.830 --> 00:05:58.159
字节到可完成的字符串

00:05:55.190 --> 00:06:00.589
剧院然后申请方法被使用

00:05:58.159 --> 00:06:04.659
创建打印的依赖动作

00:06:00.589 --> 00:06:07.250
响应代码并返回响应

00:06:04.659 --> 00:06:09.650
另一种向下应用方法是

00:06:07.250 --> 00:06:12.190
创建另一个依赖动作

00:06:09.650 --> 00:06:16.099
映射其主体类型的HTTP响应

00:06:12.190 --> 00:06:18.320
在这种情况下是一个字符串，则

00:06:16.099 --> 00:06:24.770
 accept方法使用该字符串，并且

00:06:18.320 --> 00:06:28.010
刚打印出java.util并发

00:06:24.770 --> 00:06:30.140
流是在Java 9中添加的，它提供了

00:06:28.010 --> 00:06:34.099
反应性流的接口

00:06:30.140 --> 00:06:35.639
 java平台的HTTP客户端模型

00:06:34.099 --> 00:06:38.520
请求主体

00:06:35.639 --> 00:06:42.300
我请求正文的流发布者的子类型

00:06:38.520 --> 00:06:43.979
 httpclient订阅的发布者

00:06:42.300 --> 00:06:47.810
发送请求者时，此发布者

00:06:43.979 --> 00:06:50.909
在接收方下有人

00:06:47.810 --> 00:06:53.909
当响应代码和标题是

00:06:50.909 --> 00:06:56.879
收到HTTP客户端调用的正文

00:06:53.909 --> 00:06:59.639
然后，身体猎人可以检查

00:06:56.879 --> 00:07:03.389
状态码和标题（如果需要） 

00:06:59.639 --> 00:07:05.490
在创建订户之前

00:07:03.389 --> 00:07:08.729
身体猎人返回的订户

00:07:05.490 --> 00:07:12.689
将用于接收和处理

00:07:08.729 --> 00:07:15.029
实际响应主体字节，HTTP主体

00:07:12.689 --> 00:07:18.479
订户是流的子类型

00:07:15.029 --> 00:07:23.250
订户和HTTP客户端充当

00:07:18.479 --> 00:07:24.870
响应主体字节发布者查找

00:07:23.250 --> 00:07:28.319
靠近请求主体

00:07:24.870 --> 00:07:31.169
发布者，它是字节流的发布者

00:07:28.319 --> 00:07:34.680
缓冲区字节缓冲区包含

00:07:31.169 --> 00:07:37.620
请求正文字节，它还会添加一个

00:07:34.680 --> 00:07:40.020
抽象方法的内容长度为this 

00:07:37.620 --> 00:07:43.650
方法可以选择返回长度

00:07:40.020 --> 00:07:45.360
请求体的名称（如果知道请求） 

00:07:43.650 --> 00:07:47.939
主体发布者实现为

00:07:45.360 --> 00:07:50.819
负责转换高级

00:07:47.939 --> 00:07:53.430
 Java对象像字符串一样流入

00:07:50.819 --> 00:07:58.229
字节缓冲区，然后可以将其发送为

00:07:53.430 --> 00:08:00.870
请求正文请求正文

00:07:58.229 --> 00:08:03.300
 Publishers类仅包含静态

00:08:00.870 --> 00:08:05.729
方法，这些方法是工厂

00:08:03.300 --> 00:08:09.149
用于创建可以

00:08:05.729 --> 00:08:10.680
用于最常见的用例

00:08:09.149 --> 00:08:12.539
可以看到一些工厂

00:08:10.680 --> 00:08:15.870
策划创造身体的芽

00:08:12.539 --> 00:08:18.629
字节数组或

00:08:15.870 --> 00:08:21.060
文件路径中字节数组的间隔

00:08:18.629 --> 00:08:25.979
或字符串以及来自输入

00:08:21.060 --> 00:08:28.649
流主体处理程序是一个功能

00:08:25.979 --> 00:08:31.800
具有单一方法的接口

00:08:28.649 --> 00:08:34.620
需要包含以下内容的响应信息

00:08:31.800 --> 00:08:37.500
状态代码和标头正文

00:08:34.620 --> 00:08:39.510
有响应时调用处理程序

00:08:37.500 --> 00:08:41.789
状态码和标题可用

00:08:39.510 --> 00:08:44.579
但在实际回应机构之前

00:08:41.789 --> 00:08:47.069
正文已收到字节

00:08:44.579 --> 00:08:48.990
处理程序可以检查是否有响应

00:08:47.069 --> 00:08:50.700
代码和标题

00:08:48.990 --> 00:08:52.920
返回正文订阅者之前

00:08:50.700 --> 00:08:57.089
然后将用于接收

00:08:52.920 --> 00:08:59.700
实际响应正文字节正文

00:08:57.089 --> 00:09:02.339
订户是流的订户

00:08:59.700 --> 00:09:04.880
字节缓冲区的总和

00:09:02.339 --> 00:09:07.589
缓冲区包含响应主体字节

00:09:04.880 --> 00:09:09.720
正文订阅者添加一个摘要

00:09:07.589 --> 00:09:12.060
方法get'的主体返回一个

00:09:09.720 --> 00:09:14.130
完成阶段

00:09:12.060 --> 00:09:16.230
上级类型的身体

00:09:14.130 --> 00:09:20.730
订户实现将转换

00:09:16.230 --> 00:09:22.980
响应主体字节数很多

00:09:20.730 --> 00:09:25.230
在没有必要的情况下

00:09:22.980 --> 00:09:28.920
身体订户直接而是

00:09:25.230 --> 00:09:32.220
身体饥饿者

00:09:28.920 --> 00:09:34.170
仅包含静态方法，而这些

00:09:32.220 --> 00:09:36.390
方法是压裂工厂

00:09:34.170 --> 00:09:40.709
创建可以使用的身体处理程序

00:09:36.390 --> 00:09:42.480
对于这两种常见新闻案例，我们可以

00:09:40.709 --> 00:09:45.180
看到一些工厂创造

00:09:42.480 --> 00:09:48.540
身体猎人转换为反应身体

00:09:45.180 --> 00:09:51.600
到字节数组或字符串以流式传输

00:09:48.540 --> 00:09:53.490
也可以将其保存到文件或输入流中

00:09:51.600 --> 00:09:55.970
作为替换和丢弃磅

00:09:53.490 --> 00:10:00.000
当实际响应主体位于

00:09:55.970 --> 00:10:02.130
没意思，还有更多的异国情调

00:10:00.000 --> 00:10:04.920
充当组合器的处理程序和

00:10:02.130 --> 00:10:08.970
用于缓冲和交互的适配器

00:10:04.920 --> 00:10:14.160
现在使用常规流量订阅者

00:10:08.970 --> 00:10:17.940
看一些例子，这是一个

00:10:14.160 --> 00:10:20.610
同步获取新HTTP的示例

00:10:17.940 --> 00:10:24.750
创建请求的客户端

00:10:20.610 --> 00:10:27.870
将发送一个请求，其中包含

00:10:24.750 --> 00:10:29.760
给定URI get是默认方法，因此

00:10:27.870 --> 00:10:33.000
无需显式设置

00:10:29.760 --> 00:10:36.390
客户提升方法是

00:10:33.000 --> 00:10:38.339
然后随请求调用身体

00:10:36.390 --> 00:10:40.560
字符串工厂方法的处理程序

00:10:38.339 --> 00:10:43.770
返回转换为的主体处理程序

00:10:40.560 --> 00:10:45.839
响应主体字节转换为字符串

00:10:43.770 --> 00:10:48.649
发送方法块，直到响应为

00:10:45.839 --> 00:10:51.990
完全收到，然后返回

00:10:48.649 --> 00:10:56.940
 HTTP响应字符串的响应

00:10:51.990 --> 00:10:59.520
然后将字符串打印在下一个示例中

00:10:56.940 --> 00:11:02.070
与上一个类似，只有

00:10:59.520 --> 00:11:05.130
代码使用异步样式

00:11:02.070 --> 00:11:07.740
给send发送异步方法一个请求

00:11:05.130 --> 00:11:10.190
被发送，也是一个身体处理程序

00:11:07.740 --> 00:11:12.720
将响应正文字节转换为字符串

00:11:10.190 --> 00:11:16.620
 send async方法返回一个

00:11:12.720 --> 00:11:19.050
 HTTP响应的可完成功能

00:11:16.620 --> 00:11:21.660
未来可申请的替代方法是

00:11:19.050 --> 00:11:24.680
用于创建一个依赖动作

00:11:21.660 --> 00:11:28.620
映射其主体类型的HTTP响应

00:11:24.680 --> 00:11:30.750
在这种情况下是一个字符串

00:11:28.620 --> 00:11:34.110
然后是这种依赖动作

00:11:30.750 --> 00:11:35.209
由get返回的返回没有

00:11:34.110 --> 00:11:37.800
此处阻止的代码

00:11:35.209 --> 00:11:39.569
 get方法的调用者可以

00:11:37.800 --> 00:11:41.579
创建其他依赖动作

00:11:39.569 --> 00:11:45.990
束缚以返回可计算的未来

00:11:41.579 --> 00:11:50.089
或称为连接显式阻止，直到

00:11:45.990 --> 00:11:50.089
响应正文字符串可用

00:11:50.180 --> 00:11:54.899
再次移至下一个示例

00:11:53.310 --> 00:11:57.300
 get方法类似于

00:11:54.899 --> 00:12:00.990
以前的例子只是这一次腐烂

00:11:57.300 --> 00:12:03.060
将响应主体写入文件

00:12:00.990 --> 00:12:05.399
文件工厂方法的主体处理程序

00:12:03.060 --> 00:12:07.910
造成身体上的饥饿感

00:12:05.399 --> 00:12:09.120
给定文件路径的响应主体

00:12:07.910 --> 00:12:11.550
再次

00:12:09.120 --> 00:12:13.829
这种方法是异步的，我注意到

00:12:11.550 --> 00:12:16.110
这里没有代码阻止

00:12:13.829 --> 00:12:17.790
返回的可完成未来完成

00:12:16.110 --> 00:12:19.560
与文件路径响应时

00:12:17.790 --> 00:12:24.300
尸体已经被完全接收并且

00:12:19.560 --> 00:12:27.300
写入文件接下来，我们有一个

00:12:24.300 --> 00:12:29.459
这次发布请求的示例

00:12:27.300 --> 00:12:32.699
 HTTP请求构建器具有显式

00:12:29.459 --> 00:12:36.930
称为setter的方法将post设置为

00:12:32.699 --> 00:12:39.750
 HTTP方法实际的post方法

00:12:36.930 --> 00:12:44.899
被赋予一个身体出版者，以便它

00:12:39.750 --> 00:12:47.730
知道如何通过请求身体

00:12:44.899 --> 00:12:50.069
这是字符串的正文发布者

00:12:47.730 --> 00:12:52.199
工厂方法用于创建实体

00:12:50.069 --> 00:12:56.100
发布给定的发布者

00:12:52.199 --> 00:12:59.790
字符串请求同步发送

00:12:56.100 --> 00:13:03.089
这次丢掉身体处理者

00:12:59.790 --> 00:13:05.790
丢弃响应主体，因此使用HTTP 

00:13:03.089 --> 00:13:11.210
油卡响应不明

00:13:05.790 --> 00:13:13.580
输入这是更高级的

00:13:11.210 --> 00:13:16.550
并演示如何结合Java 

00:13:13.580 --> 00:13:18.080
流和兼容的未来发送

00:13:16.550 --> 00:13:22.700
请求数和收集器

00:13:18.080 --> 00:13:24.710
他们得到你的眼睛的反应方法

00:13:22.700 --> 00:13:28.460
列出您的眼睛

00:13:24.710 --> 00:13:31.220
然后检索到您的眼睛列表

00:13:28.460 --> 00:13:34.430
转换为HTTP请求列表

00:13:31.220 --> 00:13:37.490
通过串流原始

00:13:34.430 --> 00:13:40.010
将每个条目映射到请求的列表

00:13:37.490 --> 00:13:43.270
建造者，然后建造

00:13:40.010 --> 00:13:46.340
请求并收集到新列表

00:13:43.270 --> 00:13:48.950
接下来每个请求都是异步发送的

00:13:46.340 --> 00:13:51.530
以及HTTP的完整功能

00:13:48.950 --> 00:13:56.210
响应收集到另一个列表中

00:13:51.530 --> 00:13:58.280
并且该列表是返回的调用者

00:13:56.210 --> 00:14:00.860
让您的眼睛可以检查的方法

00:13:58.280 --> 00:14:03.680
返回列表中的元素

00:14:00.860 --> 00:14:08.990
链相关动作或查询

00:14:03.680 --> 00:14:12.020
完成总结标准

00:14:08.990 --> 00:14:14.600
 Java 11中添加的HTTP客户端是

00:14:12.020 --> 00:14:17.450
替代执行HTTP访问

00:14:14.600 --> 00:14:21.080
到现在的URL连接API 

00:14:17.450 --> 00:14:22.700
 HTTP已有二十多年的历史

00:14:21.080 --> 00:14:25.990
客户在以前被孵化

00:14:22.700 --> 00:14:28.580
 Java 11发布和标准化

00:14:25.990 --> 00:14:30.940
代码的孵化版本

00:14:28.580 --> 00:14:33.080
 API需要针对Java 11更新

00:14:30.940 --> 00:14:35.690
最少的导入语句将

00:14:33.080 --> 00:14:41.330
需要反映一个新的Java包名称

00:14:35.690 --> 00:14:43.580
净HTTP HTTP客户端API使用更多

00:14:41.330 --> 00:14:45.800
通用语言等现代语言功能

00:14:43.580 --> 00:14:48.530
和lambda以及更现代的

00:14:45.800 --> 00:14:52.850
平台API就像可以完成的未来

00:14:48.530 --> 00:14:58.160
反应流与API接口

00:14:52.850 --> 00:15:00.610
故意小巧紧凑

00:14:58.160 --> 00:15:04.640
现在可以通过此URL下载Java 11 

00:15:00.610 --> 00:15:07.640
请在开放的JDK中加入我们或关注我们

00:15:04.640 --> 00:15:11.540
在Twitter上打开JDK或Java的主题标签

00:15:07.640 --> 00:15:17.100
 11我自己的推特手柄已连接

00:15:11.540 --> 00:15:19.650
琼脂999甲骨文是

00:15:17.100 --> 00:15:21.540
 Java提供了大量的

00:15:19.650 --> 00:15:25.500
开发工程资金

00:15:21.540 --> 00:15:27.360
 Java SE平台和开放的JDK Oracle 

00:15:25.500 --> 00:15:30.120
提供一流的首映礼

00:15:27.360 --> 00:15:34.530
支持容易实现的低成本

00:15:30.120 --> 00:15:35.880
以简单的定价等级购买谢谢

00:15:34.530 --> 00:15:40.029
你看

00:15:35.880 --> 00:15:40.029
 [音乐] 

