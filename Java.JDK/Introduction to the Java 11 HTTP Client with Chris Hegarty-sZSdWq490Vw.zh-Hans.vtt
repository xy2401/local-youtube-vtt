WEBVTT
Kind: captions
Language: zh-Hans

00:00:04.009 --> 00:00:08.960
嗨，我叫克里斯·哈格蒂

00:00:07.259 --> 00:00:10.950
 Oracle的Java平台小组和

00:00:08.960 --> 00:00:17.400
今天我将作一个介绍

00:00:10.950 --> 00:00:18.930
到Java 11 HTTP客户端中

00:00:17.400 --> 00:00:20.699
会议，我们将看一看

00:00:18.930 --> 00:00:23.269
 API的主要类型

00:00:20.699 --> 00:00:25.519
在哪个模块和包装中找到我

00:00:23.269 --> 00:00:28.980
必须执行一些基本操作

00:00:25.519 --> 00:00:33.180
例如发送请求以及如何响应

00:00:28.980 --> 00:00:35.100
主体是在JDK中建模的增强功能

00:00:33.180 --> 00:00:39.360
通过jdk增强来完成

00:00:35.100 --> 00:00:41.670
建议jeb 321标准化API 

00:00:39.360 --> 00:00:45.329
在以前的JDK中孵化的

00:00:41.670 --> 00:00:48.120
释放HTTP客户端提供的

00:00:45.329 --> 00:00:50.129
 Java net HTTP模块和该模块

00:00:48.120 --> 00:00:53.280
出口相同的单个包装

00:00:50.129 --> 00:00:55.770
名称与以前的孵化不同

00:00:53.280 --> 00:00:59.129
版本，此模块现在是

00:00:55.770 --> 00:01:01.199
 Java SE平台本身就是这样

00:00:59.129 --> 00:01:04.769
编译时默认解决

00:01:01.199 --> 00:01:07.950
运行非模块化代码模块化代码

00:01:04.769 --> 00:01:10.080
可以在其模块信息源文件中需要

00:01:07.950 --> 00:01:12.900
需要Java net HTTP模块

00:01:10.080 --> 00:01:18.150
直接或需要Java SE 

00:01:12.900 --> 00:01:21.630
聚合模块HTTP客户端类

00:01:18.150 --> 00:01:23.640
是HTTP客户端可以使用的顶级类型

00:01:21.630 --> 00:01:27.090
用于发送请求和检索

00:01:23.640 --> 00:01:30.060
他们的响应HTTP客户端被创建

00:01:27.090 --> 00:01:32.579
对于建造者来说，建造者可以用来

00:01:30.060 --> 00:01:35.610
完成每个客户的状态，例如

00:01:32.579 --> 00:01:39.240
首选协议版本HTTP 1 

00:01:35.610 --> 00:01:43.850
 1还是HTTP 2是否遵循重定向

00:01:39.240 --> 00:01:47.759
代理iConnect超时等等

00:01:43.850 --> 00:01:50.960
一旦建立的HTTP客户端是不可变的， 

00:01:47.759 --> 00:01:54.720
可用于发送多个请求

00:01:50.960 --> 00:01:57.240
 HTTP客户端API遵循熟悉的

00:01:54.720 --> 00:01:59.969
建设者模式有工厂

00:01:57.240 --> 00:02:04.049
顶级HTTP的交易构建者

00:01:59.969 --> 00:02:07.020
客户端和HTTP请求类型

00:02:04.049 --> 00:02:09.270
此示例HTTP客户端新构建器

00:02:07.020 --> 00:02:12.440
静态工厂方法返回新的

00:02:09.270 --> 00:02:15.620
 HTTP客户端的构建者首选

00:02:12.440 --> 00:02:18.890
协议版本HTTP到一组

00:02:15.620 --> 00:02:21.650
默认为正常重定向策略

00:02:18.890 --> 00:02:25.010
已设置，这意味着要遵循重定向

00:02:21.650 --> 00:02:27.740
始终，除非已从

00:02:25.010 --> 00:02:30.890
 HTTPS越安全，安全性越差

00:02:27.740 --> 00:02:34.430
 HTTP给定地址的代理

00:02:30.890 --> 00:02:36.860
导入已设置系统范围的默认值

00:02:34.430 --> 00:02:39.950
设置身份验证器以防站点

00:02:36.860 --> 00:02:42.410
需要验证连接

00:02:39.950 --> 00:02:45.460
新连接的超时设置为20 

00:02:42.410 --> 00:02:48.590
秒，然后建立客户端

00:02:45.460 --> 00:02:53.900
一个请求可以发送多个请求

00:02:48.590 --> 00:02:56.890
单客户端HTTP请求实例

00:02:53.900 --> 00:02:59.810
通过HTTP请求构建器构建

00:02:56.890 --> 00:03:02.960
可以在其中设置请求URI的位置

00:02:59.810 --> 00:03:06.470
请求方法，标头为正文（如果有） 

00:03:02.960 --> 00:03:10.870
和一次请求特定的超时

00:03:06.470 --> 00:03:10.870
内置的HTTP请求是不可变的

00:03:11.230 --> 00:03:17.480
类似于HTTP客户端的HTTP请求

00:03:14.990 --> 00:03:20.660
有一个新的生成器工厂方法

00:03:17.480 --> 00:03:23.000
创建一个新的HTTP请求构建器

00:03:20.660 --> 00:03:26.540
建造者可以用来设定祈祷

00:03:23.000 --> 00:03:28.760
在此示例中的请求状态

00:03:26.540 --> 00:03:31.850
请求URI设置为打开JDK点

00:03:28.760 --> 00:03:34.910
 java.net请求的特定时间超出

00:03:31.850 --> 00:03:37.070
一分钟设置一个标题，指示

00:03:34.910 --> 00:03:40.820
内容类型，因为这将是

00:03:37.070 --> 00:03:43.340
发布请求文件的正文发布者

00:03:40.820 --> 00:03:45.860
工厂方法用于返回一个

00:03:43.340 --> 00:03:48.790
请求发布的正文发布者

00:03:45.860 --> 00:03:52.820
给定文件路径中的内容

00:03:48.790 --> 00:03:58.370
这种情况在JSON请求中是不可变的

00:03:52.820 --> 00:04:00.860
并可以通过HTTP多次发送

00:03:58.370 --> 00:04:02.690
响应不是直接创建的，而是

00:04:00.860 --> 00:04:07.340
而是由于发送而返回

00:04:02.690 --> 00:04:09.320
一个HTTP请求一个HTTP响应

00:04:07.340 --> 00:04:11.300
响应状态代码可用

00:04:09.320 --> 00:04:13.610
和头已收到和

00:04:11.300 --> 00:04:16.609
通常在响应主体具有

00:04:13.610 --> 00:04:18.770
还是完全收到了

00:04:16.609 --> 00:04:20.690
没有HTTP响应可用

00:04:18.770 --> 00:04:23.900
在响应主体之前

00:04:20.690 --> 00:04:26.030
完全接受取决于身体

00:04:23.900 --> 00:04:28.790
发送HTTP时提供了它们

00:04:26.030 --> 00:04:31.010
要求他们看一下伙伴

00:04:28.790 --> 00:04:35.150
在晚些时候更紧密地处理

00:04:31.010 --> 00:04:37.729
演示HTTP响应提供

00:04:35.150 --> 00:04:40.780
访问响应状态的方法

00:04:37.729 --> 00:04:44.540
将标头编码到响应主体并

00:04:40.780 --> 00:04:49.520
与此对应的HTTP请求

00:04:44.540 --> 00:04:51.530
响应HTTP客户端支持

00:04:49.520 --> 00:04:54.110
的同步和异步模式

00:04:51.530 --> 00:04:57.229
与一起发送的操作请求

00:04:54.110 --> 00:04:59.180
同步发送方法阻止了

00:04:57.229 --> 00:05:02.510
直到当前执行率

00:04:59.180 --> 00:05:04.490
响应可用的请求发送

00:05:02.510 --> 00:05:07.510
发送异步方法，我们将

00:05:04.490 --> 00:05:09.740
 HTTP响应的可完成功能

00:05:07.510 --> 00:05:11.389
 Java 8中添加了兼容的Future 

00:05:09.740 --> 00:05:13.460
提供了多种方法

00:05:11.389 --> 00:05:15.650
建立依存行为链

00:05:13.460 --> 00:05:20.750
可以同步运行或

00:05:15.650 --> 00:05:23.030
在此示例中异步

00:05:20.750 --> 00:05:25.550
客户发送方法被给予要求

00:05:23.030 --> 00:05:27.860
与身体处理者一并发送

00:05:25.550 --> 00:05:31.490
将响应主体字节转换为

00:05:27.860 --> 00:05:34.610
字符串招标债券状态代码和

00:05:31.490 --> 00:05:36.830
正文打印发送方法块

00:05:34.610 --> 00:05:41.479
调用线程直到响应

00:05:36.830 --> 00:05:43.760
下一个示例可用的是相同的

00:05:41.479 --> 00:05:47.630
仅使用异步编写的代码

00:05:43.760 --> 00:05:50.090
样式发送异步方法被赋予

00:05:47.630 --> 00:05:51.860
请求发送，还有一个尸体

00:05:50.090 --> 00:05:55.190
转换响应主体的猎人

00:05:51.860 --> 00:05:58.190
字节到可完成的字符串

00:05:55.190 --> 00:06:00.590
剧院然后申请方法被使用

00:05:58.190 --> 00:06:04.660
创建打印的依赖动作

00:06:00.590 --> 00:06:07.250
响应代码并返回响应

00:06:04.660 --> 00:06:09.620
另一种向下应用方法是

00:06:07.250 --> 00:06:12.220
创建另一个依赖动作

00:06:09.620 --> 00:06:16.099
映射其主体类型的HTTP响应

00:06:12.220 --> 00:06:18.380
在这种情况下是字符串den 

00:06:16.099 --> 00:06:24.450
 accept方法使用该字符串，并且

00:06:18.380 --> 00:06:27.390
刚刚打印出Java util 

00:06:24.450 --> 00:06:28.920
 Java 9中添加了当前流程

00:06:27.390 --> 00:06:32.220
它提供反应流

00:06:28.920 --> 00:06:35.880
 Java平台的接口

00:06:32.220 --> 00:06:38.520
 HTTP客户端模型使用

00:06:35.880 --> 00:06:42.330
流发布者的子类型请求主体

00:06:38.520 --> 00:06:44.010
 HTTP客户端订阅的发布者

00:06:42.330 --> 00:06:47.840
发送请求者时，此发布者

00:06:44.010 --> 00:06:50.910
在接收方有人

00:06:47.840 --> 00:06:53.940
当响应代码和标题是

00:06:50.910 --> 00:06:56.940
收到HTTP客户端调用的正文

00:06:53.940 --> 00:06:59.670
然后，身体猎人可以检查

00:06:56.940 --> 00:07:03.390
状态码和标题（如果需要） 

00:06:59.670 --> 00:07:05.490
在创建订户之前

00:07:03.390 --> 00:07:08.730
身体猎人返回的订户

00:07:05.490 --> 00:07:12.690
将用于接收和处理

00:07:08.730 --> 00:07:13.410
实际响应主体字节，HTTP主体

00:07:12.690 --> 00:07:17.250
订户

00:07:13.410 --> 00:07:19.770
是流订阅者和HTTP的子类型

00:07:17.250 --> 00:07:24.180
客户充当回应的发布者

00:07:19.770 --> 00:07:27.180
身体字节看起来更近一点

00:07:24.180 --> 00:07:30.060
请求主体发布者是流程

00:07:27.180 --> 00:07:32.420
字节的发布者缓冲字节

00:07:30.060 --> 00:07:35.520
缓冲区包含请求主体字节

00:07:32.420 --> 00:07:38.370
它还添加了一个抽象方法

00:07:35.520 --> 00:07:40.320
此方法可以的内容长度

00:07:38.370 --> 00:07:43.890
 （可选）返回

00:07:40.320 --> 00:07:46.290
请求体（如果知道） 

00:07:43.890 --> 00:07:48.840
发布者的实施负责

00:07:46.290 --> 00:07:51.210
用于转换高级Java对象

00:07:48.840 --> 00:07:53.760
像一个字符串变成字节流

00:07:51.210 --> 00:07:58.830
然后可以作为

00:07:53.760 --> 00:08:01.560
请求正文请求正文发布者

00:07:58.830 --> 00:08:03.990
类仅包含静态方法，并且

00:08:01.560 --> 00:08:06.210
这些方法是用于创建的工厂

00:08:03.990 --> 00:08:09.510
可以用于

00:08:06.210 --> 00:08:11.610
我们可以在这里看到最常见的用例

00:08:09.510 --> 00:08:14.970
一些用来策画芽的工厂

00:08:11.610 --> 00:08:17.010
用于从

00:08:14.970 --> 00:08:20.550
字节数组或字节数组的间隔

00:08:17.010 --> 00:08:25.440
从文件路径或字符串以及

00:08:20.550 --> 00:08:27.630
来自输入流主体Condor是一个

00:08:25.440 --> 00:08:30.800
具有单个功能接口

00:08:27.630 --> 00:08:33.440
应用方法以获取响应信息

00:08:30.800 --> 00:08:36.599
包含状态码和标题

00:08:33.440 --> 00:08:38.220
当

00:08:36.599 --> 00:08:40.740
回应状态

00:08:38.220 --> 00:08:42.479
和标头可用，但在

00:08:40.740 --> 00:08:45.600
实际的响应主体字节为

00:08:42.479 --> 00:08:49.380
收到身体处理者可以检查

00:08:45.600 --> 00:08:51.570
之前有响应代码和标头

00:08:49.380 --> 00:08:53.310
返回正文订阅者

00:08:51.570 --> 00:08:57.960
然后用来接收实际

00:08:53.310 --> 00:09:00.540
响应正文字节正文订阅者是一个

00:08:57.960 --> 00:09:03.450
字节流的流订阅者

00:09:00.540 --> 00:09:06.630
缓冲区字节缓冲区包含

00:09:03.450 --> 00:09:09.210
响应正文字节正文订阅者添加

00:09:06.630 --> 00:09:11.400
一个单一的抽象方法得到的身体

00:09:09.210 --> 00:09:13.830
返回完成阶段

00:09:11.400 --> 00:09:15.840
用更高级别的类型完成

00:09:13.830 --> 00:09:19.760
主体订户实施将

00:09:15.840 --> 00:09:22.980
将响应主体字节转换为in 

00:09:19.760 --> 00:09:25.200
很多情况下没有必要处理

00:09:22.980 --> 00:09:28.470
直接与主体订户联系，但

00:09:25.200 --> 00:09:31.260
宁可全身锤击身体，垂下神经

00:09:28.470 --> 00:09:34.140
类仅包含静态方法，并且

00:09:31.260 --> 00:09:36.390
这些方法对于

00:09:34.140 --> 00:09:40.710
创建可以使用的身体处理程序

00:09:36.390 --> 00:09:42.480
对于这两种常见新闻案例，我们可以

00:09:40.710 --> 00:09:44.940
看到一些工厂创造

00:09:42.480 --> 00:09:48.270
身体猎人转换反应

00:09:44.940 --> 00:09:50.130
正文转换为字节数组或字符串

00:09:48.270 --> 00:09:53.100
将其流式传输到文件或输入流

00:09:50.130 --> 00:09:55.320
以及替换和丢弃

00:09:53.100 --> 00:09:59.460
处理程序何时实际响应主体

00:09:55.320 --> 00:10:01.470
没意思，有

00:09:59.460 --> 00:10:04.290
更多的异国处理程序充当

00:10:01.470 --> 00:10:05.820
组合器和适配器，用于缓冲和

00:10:04.290 --> 00:10:09.630
与常规流程互动

00:10:05.820 --> 00:10:14.880
订阅者现在让我们来看看

00:10:09.630 --> 00:10:18.480
一些例子，这是一个例子

00:10:14.880 --> 00:10:20.940
同步获取一个新的HTTP客户端是

00:10:18.480 --> 00:10:25.610
创建请求所依据的

00:10:20.940 --> 00:10:28.230
发送的请求是使用给定的URI构建的

00:10:25.610 --> 00:10:30.530
仍然是默认方法，所以没有

00:10:28.230 --> 00:10:33.690
需要在这里明确设置方法

00:10:30.530 --> 00:10:37.050
然后调用客户端的升序方法

00:10:33.690 --> 00:10:39.030
与请求的身体处理

00:10:37.050 --> 00:10:41.160
字符串工厂方法返回一个主体

00:10:39.030 --> 00:10:44.250
转换为响应主体的处理程序

00:10:41.160 --> 00:10:46.290
字节转换为字符串的send方法

00:10:44.250 --> 00:10:49.650
阻塞直到完全响应

00:10:46.290 --> 00:10:51.040
收到它然后返回一个HTTP 

00:10:49.650 --> 00:10:56.260
字符串的响应

00:10:51.040 --> 00:10:58.120
他们赞助，然后打印此

00:10:56.260 --> 00:11:00.880
下一个示例与上一个类似

00:10:58.120 --> 00:11:04.780
一个只有代码使用异步

00:11:00.880 --> 00:11:07.270
样式发送异步方法被赋予

00:11:04.780 --> 00:11:09.340
请求发送，还有一个尸体

00:11:07.270 --> 00:11:12.730
处理程序将响应正文字节转换为

00:11:09.340 --> 00:11:16.630
发送异步方法返回的字符串

00:11:12.730 --> 00:11:19.060
 HTTP响应的可完成功能

00:11:16.630 --> 00:11:21.670
将来可申请的报名方法是

00:11:19.060 --> 00:11:24.690
用于创建一个依赖动作

00:11:21.670 --> 00:11:28.750
映射其主体类型的HTTP响应

00:11:24.690 --> 00:11:30.760
在这种情况下，它在字符串中是

00:11:28.750 --> 00:11:34.120
然后是这种依赖动作

00:11:30.760 --> 00:11:36.640
由get edit返回，没有

00:11:34.120 --> 00:11:38.440
此处的代码阻止了get的调用者

00:11:36.640 --> 00:11:40.720
方法可以创建其他

00:11:38.440 --> 00:11:44.320
依赖的动作被束缚起来以返回

00:11:40.720 --> 00:11:46.870
可计算的未来或称为加入

00:11:44.320 --> 00:11:51.640
明确阻止，直到响应主体

00:11:46.870 --> 00:11:54.370
字符串可移动到下一个

00:11:51.640 --> 00:11:56.500
例子又是软盘方法类似

00:11:54.370 --> 00:11:58.180
仅与前面的示例相同

00:11:56.500 --> 00:12:02.290
这次它烂了写响应

00:11:58.180 --> 00:12:04.600
正文到文件的正文处理程序

00:12:02.290 --> 00:12:06.460
工厂方法创建一个身体处理程序

00:12:04.600 --> 00:12:09.970
将响应主体发送到

00:12:06.460 --> 00:12:12.040
再次给定文件路径，此方法是

00:12:09.970 --> 00:12:14.200
异步，请注意， 

00:12:12.040 --> 00:12:16.390
这里的代码阻止返回

00:12:14.200 --> 00:12:18.280
可完成的未来与

00:12:16.390 --> 00:12:20.320
响应主体具有的文件路径

00:12:18.280 --> 00:12:24.910
已被完全接收并写入

00:12:20.320 --> 00:12:28.390
接下来的文件我们有一个例子

00:12:24.910 --> 00:12:30.760
这次发布请求HTTP请求

00:12:28.390 --> 00:12:34.770
构建器具有显式的setter方法

00:12:30.760 --> 00:12:38.410
称为将post设置为HTTP方法的调用

00:12:34.770 --> 00:12:40.900
实际的发布方法被赋予主体

00:12:38.410 --> 00:12:46.240
发布商，以便它知道如何到达

00:12:40.900 --> 00:12:48.880
它要求身体在这里

00:12:46.240 --> 00:12:50.920
字符串工厂的发布者方法是

00:12:48.880 --> 00:12:54.520
用来创建一个正文发布者

00:12:50.920 --> 00:12:58.170
发布给定的字符串请求

00:12:54.520 --> 00:13:00.820
同步发送，这次

00:12:58.170 --> 00:13:02.240
丢弃尸体猎人丢弃响应

00:13:00.820 --> 00:13:05.420
身体

00:13:02.240 --> 00:13:11.000
 HTTP响应通配符

00:13:05.420 --> 00:13:13.040
未知类型，这是更高级的

00:13:11.000 --> 00:13:16.279
示例并演示如何结合

00:13:13.040 --> 00:13:17.510
 Java流和兼容的未来

00:13:16.279 --> 00:13:22.220
发送请求数量并

00:13:17.510 --> 00:13:24.440
收集者的回应他们吸引了你

00:13:22.220 --> 00:13:28.040
方法需要你的眼睛列表

00:13:24.440 --> 00:13:30.830
将检索到您的此列表

00:13:28.040 --> 00:13:33.649
然后转换为HTTP列表

00:13:30.830 --> 00:13:37.190
通过在

00:13:33.649 --> 00:13:39.470
将每个条目映射到一个原始列表

00:13:37.190 --> 00:13:41.630
请求建造者，随后

00:13:39.470 --> 00:13:45.529
建立请求并收集到

00:13:41.630 --> 00:13:47.720
每个请求发送之后的新列表

00:13:45.529 --> 00:13:50.600
异步且可完成

00:13:47.720 --> 00:13:53.000
收集HTTP响应的功能

00:13:50.600 --> 00:13:56.930
进入另一个列表，该列表是

00:13:53.000 --> 00:13:59.270
返回您的眼睛的颜色

00:13:56.930 --> 00:14:01.760
方法可以检查元素

00:13:59.270 --> 00:14:06.920
返回列表到任一链依赖

00:14:01.760 --> 00:14:10.579
动作或查询完成情况

00:14:06.920 --> 00:14:12.950
总结添加的标准HTTP客户端

00:14:10.579 --> 00:14:15.470
 Java 11中的替代品

00:14:12.950 --> 00:14:17.839
对URL执行HTTP访问

00:14:15.470 --> 00:14:21.649
连接API，现在已超过

00:14:17.839 --> 00:14:23.470
二十岁的HTTP客户

00:14:21.649 --> 00:14:27.410
在以前的版本中孵育

00:14:23.470 --> 00:14:29.209
 Java 11代码标准化使用

00:14:27.410 --> 00:14:31.970
 API的孵化版本将

00:14:29.209 --> 00:14:33.620
最少需要为Java 11更新

00:14:31.970 --> 00:14:39.200
导入声明将需要

00:14:33.620 --> 00:14:41.779
反映新的程序包名称Java HTTP 

00:14:39.200 --> 00:14:43.760
 HTTP客户端API使用更现代

00:14:41.779 --> 00:14:46.700
语言特性，例如泛型和

00:14:43.760 --> 00:14:48.740
 lambda以及更现代的平台

00:14:46.700 --> 00:14:52.970
 API就像可以完成的未来， 

00:14:48.740 --> 00:14:58.339
反应流接口的API是

00:14:52.970 --> 00:15:01.610
故意小巧紧凑

00:14:58.339 --> 00:15:04.760
请立即通过此URL下载Java 11 

00:15:01.610 --> 00:15:08.470
加入我们的开放式JDK或关注我们

00:15:04.760 --> 00:15:11.810
公开JDK或Java 11主题标签上的Twitter 

00:15:08.470 --> 00:15:14.709
我自己的推特句柄在检查器上

00:15:11.810 --> 00:15:14.709
 $ 9.99 

00:15:15.720 --> 00:15:19.899
 Oracle是Java提供的管理员

00:15:18.850 --> 00:15:22.180
大量发展

00:15:19.899 --> 00:15:26.050
 Java SE的工程资金

00:15:22.180 --> 00:15:28.269
平台和开放的JDK Oracle提供了

00:15:26.050 --> 00:15:31.689
一流的总理支持低

00:15:28.269 --> 00:15:35.890
易于购买的成本

00:15:31.689 --> 00:15:40.039
定价层感谢您的观看

00:15:35.890 --> 00:15:40.039
 [音乐] 

