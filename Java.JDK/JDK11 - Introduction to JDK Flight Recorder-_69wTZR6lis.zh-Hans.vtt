WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.180 --> 00:00:07.870
嗨，我是Marcus gremlin，我是其中之一

00:00:06.190 --> 00:00:10.150
 JDK的架构师和开发人员

00:00:07.870 --> 00:00:12.670
飞行记录器中包含的功能

00:00:10.150 --> 00:00:15.220
 JDK 11我要给你个快速

00:00:12.670 --> 00:00:17.439
此功能是什么的概述

00:00:15.220 --> 00:00:19.060
决定去做，给你一些帮助

00:00:17.439 --> 00:00:22.320
以演示如何

00:00:19.060 --> 00:00:26.140
协助我们解决问题

00:00:22.320 --> 00:00:28.240
什么是JDK飞行记录仪？ 

00:00:26.140 --> 00:00:30.279
理解它的直观方法是使用

00:00:28.240 --> 00:00:32.680
记录设备的类比

00:00:30.279 --> 00:00:34.690
一架飞机，就像这些设备

00:00:32.680 --> 00:00:37.300
记录与空气有关的有趣事件

00:00:34.690 --> 00:00:40.180
打算记录的旅行航班记录

00:00:37.300 --> 00:00:42.280
与我们的计划有关的事件是什么

00:00:40.180 --> 00:00:44.140
记录我们的事件，我们可以

00:00:42.280 --> 00:00:46.589
将事件视为某些数据

00:00:44.140 --> 00:00:48.970
在特定的时间

00:00:46.589 --> 00:00:51.970
使用飞行记录器记录事件

00:00:48.970 --> 00:00:54.369
使我们能够坚持

00:00:51.970 --> 00:00:57.070
时间段内的执行国

00:00:54.369 --> 00:00:59.409
就在问题之前和期间

00:00:57.070 --> 00:01:01.180
需要我们稍后再回溯

00:00:59.409 --> 00:01:02.949
您将了解导致什么的

00:01:01.180 --> 00:01:05.310
发生在一些之前

00:01:02.949 --> 00:01:07.719
问题或低于最佳情况

00:01:05.310 --> 00:01:09.430
飞行记录的关键已经能够

00:01:07.719 --> 00:01:11.590
记录大量信息

00:01:09.430 --> 00:01:14.079
同时保持

00:01:11.590 --> 00:01:15.640
录音过程低系统

00:01:14.079 --> 00:01:18.250
设计为始终在线运行

00:01:15.640 --> 00:01:20.049
关键任务环境另一个

00:01:18.250 --> 00:01:22.600
非常重要的设计目标是

00:01:20.049 --> 00:01:25.329
帮助加快启动时间

00:01:22.600 --> 00:01:26.979
问题分析过程

00:01:25.329 --> 00:01:30.219
缩短发布时间

00:01:26.979 --> 00:01:31.929
分辨率飞行记录仪试图

00:01:30.219 --> 00:01:33.999
通过记录信息来完成此任务

00:01:31.929 --> 00:01:36.609
这将从以下方面突出我们的系统

00:01:33.999 --> 00:01:38.920
许多不同的观点

00:01:36.609 --> 00:01:41.229
信息概述，例如命令

00:01:38.920 --> 00:01:43.780
线路参数加载模块和

00:01:41.229 --> 00:01:46.840
系统属性要非常详细一些

00:01:43.780 --> 00:01:49.749
关于时间的信息

00:01:46.840 --> 00:01:52.719
等待获取监视器或时间

00:01:49.749 --> 00:01:54.969
在执行期间花了一段代码

00:01:52.719 --> 00:01:56.619
因此，我们可以进行后续分析

00:01:54.969 --> 00:01:59.229
从整体角度出发

00:01:56.619 --> 00:02:02.409
并深入研究相关

00:01:59.229 --> 00:02:04.960
详细信息JFR特别适合

00:02:02.409 --> 00:02:07.929
记录传统的延迟

00:02:04.960 --> 00:02:09.550
分析器报告执行j4的时间

00:02:07.929 --> 00:02:12.010
记录报告情况，其中

00:02:09.550 --> 00:02:15.250
应用程序未执行或至少

00:02:12.010 --> 00:02:16.240
不如另一个有效

00:02:15.250 --> 00:02:18.730
设计目标

00:02:16.240 --> 00:02:20.860
深入了解程序

00:02:18.730 --> 00:02:23.170
与执行环境互动

00:02:20.860 --> 00:02:26.170
总体上来说，您肯定是

00:02:23.170 --> 00:02:29.650
已经意识到我们遇到的许多问题

00:02:26.170 --> 00:02:31.900
不直接归因于逻辑

00:02:29.650 --> 00:02:33.250
我们程序中的错误，但它们出现了

00:02:31.900 --> 00:02:36.400
因为我们的融合

00:02:33.250 --> 00:02:38.800
与飞行有关的产品

00:02:36.400 --> 00:02:40.630
记录器，我们有一种捕获方法

00:02:38.800 --> 00:02:43.270
这些通常很难复制

00:02:40.630 --> 00:02:45.040
只有很大一部分的情况

00:02:43.270 --> 00:02:45.780
似乎在生产中浮出水面

00:02:45.040 --> 00:02:48.820
环境

00:02:45.780 --> 00:02:51.160
最常见的用例是使用JFR 

00:02:48.820 --> 00:02:53.620
作为类似于

00:02:51.160 --> 00:02:54.880
飞机上的录音设备

00:02:53.620 --> 00:02:56.830
同时查看飞行记录仪

00:02:54.880 --> 00:02:59.590
基础设施为我们提供了

00:02:56.830 --> 00:03:01.450
随时可用的探查器

00:02:59.590 --> 00:03:03.520
记录更多信息，如果

00:03:01.450 --> 00:03:05.620
需要，也许只是短期的

00:03:03.520 --> 00:03:07.870
与时间的实际互动

00:03:05.620 --> 00:03:10.600
飞行记录仪非常简单

00:03:07.870 --> 00:03:12.610
我们投资的工作在完成之前和

00:03:10.600 --> 00:03:15.610
获得录音系统后

00:03:12.610 --> 00:03:18.580
在我们设计的前一种情况下运行

00:03:15.610 --> 00:03:21.010
使用api的事件和元数据

00:03:18.580 --> 00:03:23.440
在后者中，我们利用

00:03:21.010 --> 00:03:25.240
记录信息以改善

00:03:23.440 --> 00:03:26.860
我们对系统的理解

00:03:25.240 --> 00:03:29.260
特定时间或特定时间

00:03:26.860 --> 00:03:31.870
情况，这可能尤其

00:03:29.260 --> 00:03:34.210
在生产环境中有助于

00:03:31.870 --> 00:03:35.950
从飞行记录仪中获取数据

00:03:34.210 --> 00:03:38.230
指示它转储该信息

00:03:35.950 --> 00:03:40.660
已经录制了，这会产生一个

00:03:38.230 --> 00:03:43.810
二进制文件，我们可以将其视为

00:03:40.660 --> 00:03:46.390
我们可以使用压缩格式的数据库

00:03:43.810 --> 00:03:48.250
与之交互的程序化api 

00:03:46.390 --> 00:03:49.720
此文件，如果您

00:03:48.250 --> 00:03:53.320
已经对我们有一些了解

00:03:49.720 --> 00:03:55.420
寻找，但大多数时候你不喜欢

00:03:53.320 --> 00:03:57.430
您投入使用的任何好的配置文件都会

00:03:55.420 --> 00:03:59.440
几乎总是将您指向某个地方

00:03:57.430 --> 00:04:01.720
当你连开始都不知道的时候

00:03:59.440 --> 00:04:04.210
在这些情况下，我们可以

00:04:01.720 --> 00:04:06.970
寻求GUI的帮助来协助我们

00:04:04.210 --> 00:04:11.170
管理并更好地了解大

00:04:06.970 --> 00:04:15.340
数据集和关系，让我们使用

00:04:11.170 --> 00:04:19.299
雅各布，我们将使用雅各布和皮特

00:04:15.340 --> 00:04:23.980
帮助，我们可以看到五个命令

00:04:19.299 --> 00:04:28.110
与JFR交互的命令

00:04:23.980 --> 00:04:28.110
开始录音称为j4开始

00:04:29.040 --> 00:04:34.300
在这里，我给了这首录音

00:04:31.630 --> 00:04:36.160
之所以叫连续，是因为

00:04:34.300 --> 00:04:39.550
是我们将要运行的录音

00:04:36.160 --> 00:04:42.280
通过录制此背景

00:04:39.550 --> 00:04:44.440
运行中，我们可以发送请求以转储

00:04:42.280 --> 00:04:46.660
随时记录信息，并且

00:04:44.440 --> 00:04:49.259
这正是我们在这里要做的

00:04:46.660 --> 00:04:52.270
让它记录一段时间

00:04:49.259 --> 00:04:54.940
我们使用j4 dump命令获取

00:04:52.270 --> 00:04:57.940
来自飞行记录仪的信息

00:04:54.940 --> 00:05:01.630
让我们在这里使用它j4转储名称

00:04:57.940 --> 00:05:08.169
继续文件名，我们称之为

00:05:01.630 --> 00:05:11.289
再次发布的一个发现文档j4 

00:05:08.169 --> 00:05:13.780
 j4检查命令注意这里

00:05:11.289 --> 00:05:15.550
我们刚刚完成的转储操作是

00:05:13.780 --> 00:05:16.960
在我们无损的意义上

00:05:15.550 --> 00:05:19.570
仍有背景录音

00:05:16.960 --> 00:05:23.349
现在运行，只是在

00:05:19.570 --> 00:05:26.500
文件我们刚刚转储了一个录音文件

00:05:23.349 --> 00:05:29.680
在这个例子中包含很多结构

00:05:26.500 --> 00:05:33.760
这里我们有大约五个样本文件

00:05:29.680 --> 00:05:36.340
梅格大小我用过API sin JDK 

00:05:33.760 --> 00:05:38.979
 J供消费者重建

00:05:36.340 --> 00:05:42.940
关系信息分为两个标准

00:05:38.979 --> 00:05:45.460
文件格式JSON和XML文件大小

00:05:42.940 --> 00:05:48.190
清单证明了以下事实： 

00:05:45.460 --> 00:05:50.260
虽然文件可以转换

00:05:48.190 --> 00:05:54.099
这些是您需要的格式

00:05:50.260 --> 00:05:55.990
现在要注意大小开销

00:05:54.099 --> 00:05:57.760
将开始我们的分析，并为了

00:05:55.990 --> 00:05:59.889
正确理解大量

00:05:57.760 --> 00:06:01.599
我们掌握的信息

00:05:59.889 --> 00:06:04.510
宁愿使用GUI工具

00:06:01.599 --> 00:06:06.490
协助我们进行分析

00:06:04.510 --> 00:06:08.940
将使用JDK Mission Control 

00:06:06.490 --> 00:06:11.979
做到这一点的优秀工具

00:06:08.940 --> 00:06:14.800
只是我们有四个飞行记录仪

00:06:11.979 --> 00:06:16.599
 JDK 11 JDK Mission Control已打开

00:06:14.800 --> 00:06:19.630
源并由Oracle公开捐赠

00:06:16.599 --> 00:06:21.960
 JDK社区，我们将尽早使用

00:06:19.630 --> 00:06:25.840
访问版本的任务控制

00:06:21.960 --> 00:06:27.639
让我们单击此处的“线程”选项卡

00:06:25.840 --> 00:06:30.400
离开我们可以看到线程正在

00:06:27.639 --> 00:06:31.720
表示为表格中的每一行

00:06:30.400 --> 00:06:34.000
投影到图上

00:06:31.720 --> 00:06:37.180
代表执行状态

00:06:34.000 --> 00:06:39.070
图本身中的特定线程

00:06:37.180 --> 00:06:41.950
可以看到沿x轴绘制的时间

00:06:39.070 --> 00:06:43.960
这些图让我想起了声纳图

00:06:41.950 --> 00:06:47.050
你知道他们在水下使用的那种

00:06:43.960 --> 00:06:49.000
海底探险，就像索纳（Sona） 

00:06:47.050 --> 00:06:51.340
嫁接有助于挑选轮廓

00:06:49.000 --> 00:06:53.890
我们无法直接观察到的东西

00:06:51.340 --> 00:06:56.970
 jf4可以帮助我们看到很难

00:06:53.890 --> 00:06:59.940
观察有问题的执行模式

00:06:56.970 --> 00:07:03.310
我们还看到了很多红点

00:06:59.940 --> 00:07:07.810
这些红点是让我们检查的事件

00:07:03.310 --> 00:07:11.290
 Java监视器是什么样的事件

00:07:07.810 --> 00:07:14.200
除了向我们提供信息外

00:07:11.290 --> 00:07:16.480
关于该线程被阻塞多长时间

00:07:14.200 --> 00:07:18.160
在监视器上获取之前

00:07:16.480 --> 00:07:20.260
向我们提供有关显示器的信息

00:07:18.160 --> 00:07:22.330
本身例如它给我们

00:07:20.260 --> 00:07:24.850
监视器的实例是

00:07:22.330 --> 00:07:26.200
由监视器地址代表它

00:07:24.850 --> 00:07:29.110
也给我们上了这个课

00:07:26.200 --> 00:07:32.140
实例，这是一个Java util哈希

00:07:29.110 --> 00:07:34.030
桌子还给我们

00:07:32.140 --> 00:07:36.930
有关什么线程是的信息

00:07:34.030 --> 00:07:40.330
监视器的先前所有者

00:07:36.930 --> 00:07:43.120
监视被阻止的事件像这样排队

00:07:40.330 --> 00:07:46.330
在垂直方向上，这是一个明显的指示

00:07:43.120 --> 00:07:48.160
瓶颈看起来像大多数线程

00:07:46.330 --> 00:07:50.980
需要购买此特定的监视器

00:07:48.160 --> 00:07:54.270
为了继续执行下去

00:07:50.980 --> 00:07:59.140
沿时间轴的右边

00:07:54.270 --> 00:08:00.820
让我们在这里选择这些事件之一

00:07:59.140 --> 00:08:02.860
堆栈跟踪视图为我们提供了

00:08:00.820 --> 00:08:04.750
我们提供的重要上下文信息

00:08:02.860 --> 00:08:06.490
立刻看到这个线程是

00:08:04.750 --> 00:08:09.580
在执行此特定操作时被阻止

00:08:06.490 --> 00:08:12.040
提供路径任务控制

00:08:09.580 --> 00:08:14.580
锁的另一个视图，让我们检查一下

00:08:12.040 --> 00:08:14.580
那一个

00:08:15.810 --> 00:08:21.450
现在让我们检查与

00:08:19.270 --> 00:08:21.450
这个

00:08:24.800 --> 00:08:29.750
为什么确实看起来像我们在使用

00:08:27.560 --> 00:08:32.570
普通的旧哈希表来存储我们的日志

00:08:29.750 --> 00:08:34.729
哈希表为

00:08:32.570 --> 00:08:37.250
同步，我们立即看到我们的

00:08:34.729 --> 00:08:40.190
错误，我们将其更改为并发

00:08:37.250 --> 00:08:42.500
哈希地图，相反，我们只是要

00:08:40.190 --> 00:08:44.570
记住我们的新代码

00:08:42.500 --> 00:08:49.940
我们可能想从打开j4 

00:08:44.570 --> 00:08:51.770
首先，我们为此做另一个转储

00:08:49.940 --> 00:08:54.080
新部署的代码，我不是

00:08:51.770 --> 00:08:59.000
显示在这里，我们再次检查

00:08:54.080 --> 00:09:01.579
线程选项卡看起来没有任何点

00:08:59.000 --> 00:09:05.180
我当然知道从哪里开始的例子

00:09:01.579 --> 00:09:06.920
看起来，但有时你不好

00:09:05.180 --> 00:09:08.720
问题是任务控制可以

00:09:06.920 --> 00:09:12.140
实际上可以帮助我们

00:09:08.720 --> 00:09:14.839
分析，我们将重做相同的场景

00:09:12.140 --> 00:09:17.540
我们刚刚做过，但此时我们

00:09:14.839 --> 00:09:21.890
将检查自动分析

00:09:17.540 --> 00:09:25.459
结果页的一条规则在这里说

00:09:21.890 --> 00:09:27.680
实例Java阻塞，看起来

00:09:25.459 --> 00:09:29.510
像它一样自动找到了nn 

00:09:27.680 --> 00:09:33.680
被阻塞的线程数

00:09:29.510 --> 00:09:35.450
特定的显示器让我们在这里暂停

00:09:33.680 --> 00:09:37.880
在生产之前我们看不到吗

00:09:35.450 --> 00:09:39.500
要么我们没有引起足够的压力

00:09:37.880 --> 00:09:41.480
在测试中增加

00:09:39.500 --> 00:09:43.970
并发级别到有问题的级别

00:09:41.480 --> 00:09:45.980
或者也许我们做到了，但是我们没有

00:09:43.970 --> 00:09:49.790
使用在此期间报告此问题的工具

00:09:45.980 --> 00:09:52.100
在这种情况下的测试周期

00:09:49.790 --> 00:09:54.800
我们参与的代码是一个

00:09:52.100 --> 00:09:56.120
错误的，所以我们可以轻松地更改它，但是

00:09:54.800 --> 00:09:57.740
它可能和大代码一样好

00:09:56.120 --> 00:10:00.589
位于我们的图书馆

00:09:57.740 --> 00:10:02.660
使用我们认为JFR可以

00:10:00.589 --> 00:10:05.360
这里的帮助可以帮助我们扩展规模

00:10:02.660 --> 00:10:07.760
值说我们想报告这个

00:10:05.360 --> 00:10:09.560
向图书馆开发商寻找我们

00:10:07.760 --> 00:10:12.829
可以轻松地将此录音附加到

00:10:09.560 --> 00:10:15.200
他们的错误报告系统现在是错误

00:10:12.829 --> 00:10:17.690
报告只是加强了我们的论点

00:10:15.200 --> 00:10:19.970
得到经验证据的支持

00:10:17.690 --> 00:10:22.370
图书馆开发者也

00:10:19.970 --> 00:10:24.589
他们处于更好的位置

00:10:22.370 --> 00:10:26.329
收到了关于

00:10:24.589 --> 00:10:28.630
如何使用他们的图书馆，以及

00:10:26.329 --> 00:10:31.760
再次从生产环境

00:10:28.630 --> 00:10:35.510
另一个哲学思考是

00:10:31.760 --> 00:10:36.770
这里没有真正的错误，我们

00:10:35.510 --> 00:10:40.060
最终陷入困境

00:10:36.770 --> 00:10:41.960
因为我们错过了一些

00:10:40.060 --> 00:10:44.450
让我们看看是否可以得到一些额外的东西

00:10:41.960 --> 00:10:46.550
单击此文件中的信息

00:10:44.450 --> 00:10:49.370
内存选项卡，而我们在这里看到的是

00:10:46.550 --> 00:10:53.240
表示堆内存的锯齿图

00:10:49.370 --> 00:10:55.820
此VM在每个周期中的使用情况包括

00:10:53.240 --> 00:10:58.420
代表一个

00:10:55.820 --> 00:11:00.920
堆内存分配期

00:10:58.420 --> 00:11:04.250
随后是子序列的急剧下降

00:11:00.920 --> 00:11:08.330
代表GC，然后是循环

00:11:04.250 --> 00:11:11.990
从该图的频率开始

00:11:08.330 --> 00:11:15.740
似乎在2赫兹左右

00:11:11.990 --> 00:11:17.300
如果我们期望每秒有两个周期

00:11:15.740 --> 00:11:19.340
这一点我们可以在

00:11:17.300 --> 00:11:23.740
一个周期的开始，我们的堆使用情况是

00:11:19.340 --> 00:11:26.780
周期结束时约有570兆欧

00:11:23.740 --> 00:11:30.310
现在我们的堆使用量已增长到

00:11:26.780 --> 00:11:33.020
约2.4 GB 

00:11:30.310 --> 00:11:35.870
这给我们分配率是

00:11:33.020 --> 00:11:38.150
大约每秒4演出另一个有效

00:11:35.870 --> 00:11:39.470
我们可以推断的是，大多数

00:11:38.150 --> 00:11:42.650
这些分配是短暂的

00:11:39.470 --> 00:11:44.810
反对此主张的原因是

00:11:42.650 --> 00:11:46.880
 GC能够降低

00:11:44.810 --> 00:11:49.490
堆回到起始位置

00:11:46.880 --> 00:11:51.620
每个周期我们可以得到另一个

00:11:49.490 --> 00:11:54.260
重要信息，如果我们单击

00:11:51.620 --> 00:11:55.640
现在的垃圾收集复选框

00:11:54.260 --> 00:11:59.150
关于GC的信息

00:11:55.640 --> 00:12:02.570
暂停时间，我们看到的是GC具有

00:11:59.150 --> 00:12:04.520
发布时间约20毫秒

00:12:02.570 --> 00:12:06.560
对我们而言，这意味着

00:12:04.520 --> 00:12:10.220
 GC停止了我们的申请

00:12:06.560 --> 00:12:12.380
大约需要20毫秒才能完成工作，但是

00:12:10.220 --> 00:12:14.690
因为我们每个G C有两个

00:12:12.380 --> 00:12:16.610
第二，我们实际上有一个发布时间

00:12:14.690 --> 00:12:19.130
每秒40毫秒

00:12:16.610 --> 00:12:21.050
此时我们想要的应用程序

00:12:19.130 --> 00:12:24.350
了解什么物体

00:12:21.050 --> 00:12:25.940
分配和杰夫我们从哪里

00:12:24.350 --> 00:12:27.920
为我们提供了

00:12:25.940 --> 00:12:31.850
不进行对象分配抽样

00:12:27.920 --> 00:12:34.010
字节码检测，但是为了

00:12:31.850 --> 00:12:36.440
获取此信息，我们将需要

00:12:34.010 --> 00:12:39.680
征集

00:12:36.440 --> 00:12:41.930
 j4引擎自采样机制

00:12:39.680 --> 00:12:44.540
开销很小，会产生

00:12:41.930 --> 00:12:47.450
无法打开的大量数据

00:12:44.540 --> 00:12:49.520
默认而是包含在我们的

00:12:47.450 --> 00:12:51.540
我们进行个人资料的设置

00:12:49.520 --> 00:12:53.400
记录

00:12:51.540 --> 00:12:56.820
我们将开始其他录制

00:12:53.400 --> 00:13:00.900
我们将明确通过设置

00:12:56.820 --> 00:13:02.820
用...将档案记录到JFR 

00:13:00.900 --> 00:13:05.130
如此高的分配率，尽管我们

00:13:02.820 --> 00:13:07.740
只需要一个非常短的样本即可

00:13:05.130 --> 00:13:10.080
了解可能会分配什么

00:13:07.740 --> 00:13:13.260
我们也将除非有其他选择

00:13:10.080 --> 00:13:15.810
被称为持续时间，让我们每个人

00:13:13.260 --> 00:13:19.320
安排基于时间的录制并

00:13:15.810 --> 00:13:21.540
让我们在它上运行一分钟

00:13:19.320 --> 00:13:23.520
此分钟结束时，JFR将停止， 

00:13:21.540 --> 00:13:25.230
将录音转储到我们的文件名

00:13:23.520 --> 00:13:28.650
指定并在这里命名

00:13:25.230 --> 00:13:31.290
分配GFR，我们打开分配j4 

00:13:28.650 --> 00:13:33.390
在JMC中，我们可以看到

00:13:31.290 --> 00:13:37.200
部分已由填充

00:13:33.390 --> 00:13:39.510
所有有关分配的信息

00:13:37.200 --> 00:13:42.780
样本实例已分组

00:13:39.510 --> 00:13:45.750
根据班级，我们可以看到

00:13:42.780 --> 00:13:49.860
最佳候选人似乎是布尔值

00:13:45.750 --> 00:13:52.860
数组技巧将这个布尔数组标记为

00:13:49.860 --> 00:13:55.920
可以在下面的堆栈跟踪中看到

00:13:52.860 --> 00:13:59.550
实际分配地点汇总到

00:13:55.920 --> 00:14:02.390
这些分配，这里似乎

00:13:59.550 --> 00:14:05.640
只有一个分配站点

00:14:02.390 --> 00:14:07.020
让我们在本节中检查此代码

00:14:05.640 --> 00:14:09.690
该应用程序涉及

00:14:07.020 --> 00:14:11.940
计算素数，我们看到

00:14:09.690 --> 00:14:13.710
 j4查明了分配站点

00:14:11.940 --> 00:14:17.190
从布尔值到种族

00:14:13.710 --> 00:14:20.130
 Eratosthenes算法的数字35 

00:14:17.190 --> 00:14:22.530
这里使用了布尔数组

00:14:20.130 --> 00:14:24.960
作为具有此的筛选数组

00:14:22.530 --> 00:14:28.010
该网站指向我们，但j4已经

00:14:24.960 --> 00:14:31.590
与GCS的高频率有关

00:14:28.010 --> 00:14:33.390
因此，以GZ脉冲时间我们可以

00:14:31.590 --> 00:14:36.450
现在开始思考它如何使

00:14:33.390 --> 00:14:39.060
此应用程序可能更有效

00:14:36.450 --> 00:14:43.230
重新设计这段代码

00:14:39.060 --> 00:14:45.090
经常通过使用

00:14:43.230 --> 00:14:48.570
缓存技术或某种

00:14:45.090 --> 00:14:50.910
记住，我们将能够

00:14:48.570 --> 00:14:52.710
我们参与其中更有效

00:14:50.910 --> 00:14:54.300
这个级别的分析非常

00:14:52.710 --> 00:14:56.490
容易迷失大局

00:14:54.300 --> 00:14:58.950
我们可能会想好40 

00:14:56.490 --> 00:15:00.930
毫秒应尽量提醒

00:14:58.950 --> 00:15:02.490
我们自己的规模概念

00:15:00.930 --> 00:15:05.380
让我们尝试回答这个问题

00:15:02.490 --> 00:15:09.460
什么是40毫秒40毫秒

00:15:05.380 --> 00:15:10.660
是4％4％的时间是我们的应用程序

00:15:09.460 --> 00:15:14.020
什么也没做

00:15:10.660 --> 00:15:17.470
由于GC活动的4％，因此暂停

00:15:14.020 --> 00:15:20.440
 24小时几乎是每周一小时的4％ 

00:15:17.470 --> 00:15:22.390
将近7个小时，所以每周7个小时

00:15:20.440 --> 00:15:25.390
该应用程序没有任何用处

00:15:22.390 --> 00:15:28.270
假设我们已经部署了数百个

00:15:25.390 --> 00:15:31.740
这些实例，所以每周700小时

00:15:28.270 --> 00:15:34.330
我们的应用程序同级闲置

00:15:31.740 --> 00:15:36.610
现在，如果您还有某种商业模式

00:15:34.330 --> 00:15:39.850
我们可以扩展这个思想实验

00:15:36.610 --> 00:15:44.710
通过考虑每个货币的价值

00:15:39.850 --> 00:15:47.890
计算小时数，以便我们能算出

00:15:44.710 --> 00:15:50.290
可能只有一个GC的方法

00:15:47.890 --> 00:15:51.820
每秒发生一次，或者我们可以得到

00:15:50.290 --> 00:15:54.370
停顿时间降至10 

00:15:51.820 --> 00:15:58.140
毫秒，我们会改善我们的

00:15:54.370 --> 00:15:59.950
每周350小时有效

00:15:58.140 --> 00:16:02.080
结束这个简短的示范

00:15:59.950 --> 00:16:04.740
还有一件我想要的

00:16:02.080 --> 00:16:08.350
告诉你我搜索了十年

00:16:04.740 --> 00:16:10.330
我们提供Java API，可让您

00:16:08.350 --> 00:16:13.450
创建自己的特定于应用程序

00:16:10.330 --> 00:16:15.190
事件进入JFR，尽管我没有

00:16:13.450 --> 00:16:17.560
在这里演示如何

00:16:15.190 --> 00:16:19.750
我想使用API​​的程序

00:16:17.560 --> 00:16:23.110
向您展示一个自定义事件的示例

00:16:19.750 --> 00:16:24.790
可能就像您记得我的

00:16:23.110 --> 00:16:27.160
应用程序的一部分涉及

00:16:24.790 --> 00:16:29.650
计算素数，在这里我们

00:16:27.160 --> 00:16:32.320
可以看到我添加了两个JFR的自定义事件

00:16:29.650 --> 00:16:34.750
代表这些计算，有

00:16:32.320 --> 00:16:36.700
这里有很多细节可能需要

00:16:34.750 --> 00:16:38.680
涵盖其他时间，但主要

00:16:36.700 --> 00:16:40.930
外卖消息是没有

00:16:38.680 --> 00:16:43.450
这之间的绝对区别

00:16:40.930 --> 00:16:46.330
自定义事件和我们去过的事件

00:16:43.450 --> 00:16:48.670
到目前为止检查当然可以

00:16:46.330 --> 00:16:50.680
看起来像那样，但这是因为JMC 

00:16:48.670 --> 00:16:53.650
有一些最预定义的视图

00:16:50.680 --> 00:16:55.480
一般事件类型此视图也

00:16:53.650 --> 00:16:57.280
展示了

00:16:55.480 --> 00:17:00.970
 JFR，这是自我的概念

00:16:57.280 --> 00:17:03.010
 James在这里描述数据没有

00:17:00.970 --> 00:17:05.770
需要任何特殊的更改以

00:17:03.010 --> 00:17:08.710
显示我的自定义事件，而不是

00:17:05.770 --> 00:17:10.440
自定义事件包含的元数据

00:17:08.710 --> 00:17:13.810
消费者代表此信息

00:17:10.440 --> 00:17:16.540
作为一个具体的例子，我们可以期待

00:17:13.810 --> 00:17:18.800
比率字段，如您所见

00:17:16.540 --> 00:17:21.380
工具能够将此值呈现为

00:17:18.800 --> 00:17:23.600
之所以可以做到这一点，是因为

00:17:21.380 --> 00:17:26.600
自定义事件已装饰有

00:17:23.600 --> 00:17:30.520
有效说明语义元数据

00:17:26.600 --> 00:17:34.580
对消费者来说，这是一个百分比

00:17:30.520 --> 00:17:36.860
让我们总结一下您的操作

00:17:34.580 --> 00:17:38.780
看到我演示了如何使用J命令J 

00:17:36.860 --> 00:17:40.390
抛弃完全机械的东西

00:17:38.780 --> 00:17:42.920
理想情况下应由监控工具处理

00:17:40.390 --> 00:17:44.750
这样的监视工具可能引起转储

00:17:42.920 --> 00:17:46.730
因某事而进行的操作

00:17:44.750 --> 00:17:49.670
发生在更高层次上可能是

00:17:46.730 --> 00:17:51.470
如果可以的话，进行分布式交易

00:17:49.670 --> 00:17:53.300
加快分析过程

00:17:51.470 --> 00:17:55.130
最有可能通过某种方式开始

00:17:53.300 --> 00:17:58.550
自动化的速度越快

00:17:55.130 --> 00:18:02.420
从JDK开始理解和解决问题

00:17:58.550 --> 00:18:06.080
 9 Java API和JDK j4允许程序

00:18:02.420 --> 00:18:10.130
创建和整合自己的活动，我们

00:18:06.080 --> 00:18:12.700
真的希望你喜欢JDK 11谢谢

00:18:10.130 --> 00:18:12.700
观看

