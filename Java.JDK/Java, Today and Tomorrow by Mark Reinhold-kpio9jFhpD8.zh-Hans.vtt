WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.550 --> 00:00:08.220
 [音乐] 

00:00:04.970 --> 00:00:10.110
好的，早上好，谢谢你的光临

00:00:08.220 --> 00:00:12.300
谢谢您在我们期间的耐心配合

00:00:10.110 --> 00:00:14.429
处理各种技术

00:00:12.300 --> 00:00:16.830
困难永远是永远

00:00:14.429 --> 00:00:18.660
有趣，至少在娱乐性方面

00:00:16.830 --> 00:00:21.029
进行涉及三个方面的演讲

00:00:18.660 --> 00:00:26.400
笔记本电脑到我已经数不清的笔记本电脑

00:00:21.029 --> 00:00:30.150
我自己很好，所以这个话题有点

00:00:26.400 --> 00:00:32.279
关于Java的今天，但这也是

00:00:30.150 --> 00:00:34.890
尝试凝视未来

00:00:32.279 --> 00:00:37.649
看看接下来会发生什么

00:00:34.890 --> 00:00:40.829
会做很多好几个

00:00:37.649 --> 00:00:42.450
演示，我可能会错过键入内容

00:00:40.829 --> 00:00:46.050
如果你看到我做错了，请

00:00:42.450 --> 00:00:49.350
请大喊大叫来纠正我并提供帮助

00:00:46.050 --> 00:00:52.140
我在这里，问题还可以

00:00:49.350 --> 00:00:54.030
演示，但这不是，不是

00:00:52.140 --> 00:00:55.469
至少要进行质量检查

00:00:54.030 --> 00:00:58.710
我们有时间，这是个好时机

00:00:55.469 --> 00:01:01.469
我很乐意在那里提问

00:00:58.710 --> 00:01:05.400
喜欢从规范的一组开始

00:01:01.469 --> 00:01:08.760
调查多少人正在使用Java 8 

00:01:05.400 --> 00:01:13.740
生产中有多少人

00:01:08.760 --> 00:01:17.850
在生产中使用Java 11是的，很好

00:01:13.740 --> 00:01:20.030
至少有多少人正在使用

00:01:17.850 --> 00:01:22.799
开发中的版本晚于8 

00:01:20.030 --> 00:01:24.479
尝试踢轮胎多少

00:01:22.799 --> 00:01:27.509
人们已经下载了Java 12，并且

00:01:24.479 --> 00:01:29.430
用它做某事，那是

00:01:27.509 --> 00:01:30.860
到年底，那是相当不错的

00:01:29.430 --> 00:01:33.540
我希望这能说服更多的人

00:01:30.860 --> 00:01:36.290
即使不使用也去做

00:01:33.540 --> 00:01:40.079
在生产中你至少知道

00:01:36.290 --> 00:01:42.659
下载12甚至下载13并尝试

00:01:40.079 --> 00:01:46.259
并发送有关一些反馈

00:01:42.659 --> 00:01:47.909
新功能好在我们看之前

00:01:46.259 --> 00:01:50.640
在特定功能

00:01:47.909 --> 00:01:52.500
让我们先提醒一下

00:01:50.640 --> 00:01:55.439
我们自己怎么决定

00:01:52.500 --> 00:01:57.450
向Java添加东西我们只是添加

00:01:55.439 --> 00:02:00.000
跟酷孩子在一起的东西

00:01:57.450 --> 00:02:01.979
你知道添加东西以保持它

00:02:00.000 --> 00:02:06.030
无论什么都不吸引

00:02:01.979 --> 00:02:09.509
当然不是什么推动Java向前发展

00:02:06.030 --> 00:02:11.849
 Java已经被驱动了将近24年

00:02:09.509 --> 00:02:13.560
通过两个24岁的大目标，他们将

00:02:11.849 --> 00:02:15.360
 20年的24年

00:02:13.560 --> 00:02:17.430
顺便说一句本月三号

00:02:15.360 --> 00:02:20.459
目标第一是开发者

00:02:17.430 --> 00:02:23.160
生产力Java旨在帮助

00:02:20.459 --> 00:02:25.380
开发人员建立并维护大型和

00:02:23.160 --> 00:02:26.670
可靠的程序是有时人们

00:02:25.380 --> 00:02:29.130
抱怨语言有点

00:02:26.670 --> 00:02:31.050
冗长但一定程度的冗长

00:02:29.130 --> 00:02:33.300
有一个优势，因为这意味着

00:02:31.050 --> 00:02:35.190
您今天编写的代码将是

00:02:33.300 --> 00:02:36.930
一年后就能了解你

00:02:35.190 --> 00:02:38.910
知道你从未见过的人会

00:02:36.930 --> 00:02:41.459
能够理解十点二十

00:02:38.910 --> 00:02:43.110
从现在开始Java不再是关于编写

00:02:41.459 --> 00:02:44.340
永无止境的一次性脚本

00:02:43.110 --> 00:02:46.049
一直在为建造东西

00:02:44.340 --> 00:02:48.590
长期维持他们的能力

00:02:46.049 --> 00:02:51.620
从长远来看，另一个大目标是

00:02:48.590 --> 00:02:53.850
已设定24年的性能

00:02:51.620 --> 00:02:56.010
我们当然会在许多方面衡量绩效

00:02:53.850 --> 00:02:57.870
我们测量时间的不同方式

00:02:56.010 --> 00:03:00.239
启动时间和延迟的形式以及

00:02:57.870 --> 00:03:03.959
吞吐量我们测量空间既是静态的

00:03:00.239 --> 00:03:06.569
系统的存储空间

00:03:03.959 --> 00:03:09.060
就记忆而言的动态空间

00:03:06.569 --> 00:03:11.099
我们可能测量的消费

00:03:09.060 --> 00:03:12.780
我们为您提供多种扩展性

00:03:11.099 --> 00:03:15.150
知道我们喜欢谈论你知道Java 

00:03:12.780 --> 00:03:17.220
在iPhone上工作是很大的麻烦

00:03:15.150 --> 00:03:21.299
真正使那个成为现实

00:03:17.220 --> 00:03:25.530
差不多有24年了

00:03:21.299 --> 00:03:28.320
我们已经在

00:03:25.530 --> 00:03:29.790
面对不断变化的因素

00:03:28.320 --> 00:03:31.950
这是使工作得以进行的一部分

00:03:29.790 --> 00:03:34.799
 Java本身的有趣之处

00:03:31.950 --> 00:03:37.410
使它成为一个真正的挑战

00:03:34.799 --> 00:03:39.660
不时的事物

00:03:37.410 --> 00:03:41.489
总是在改变编程范例

00:03:39.660 --> 00:03:43.019
正在改变的人更感兴趣

00:03:41.489 --> 00:03:44.760
现在混合功能和

00:03:43.019 --> 00:03:47.690
面向对象的编程数据

00:03:44.760 --> 00:03:51.450
面向程序设计正在成为一件事

00:03:47.690 --> 00:03:53.540
应用领域正在发生变化

00:03:51.450 --> 00:03:56.400
你知道大数据和机器学习

00:03:53.540 --> 00:03:59.160
很多人想用Java做的事情

00:03:56.400 --> 00:04:01.410
但是Java对他们来说不如

00:03:59.160 --> 00:04:02.180
可以，所以我们正在研究

00:04:01.410 --> 00:04:05.010
使它变得更好

00:04:02.180 --> 00:04:07.109
部署样式正在改变，您知道

00:04:05.010 --> 00:04:09.000
我们曾经谈论过jar文件

00:04:07.109 --> 00:04:11.069
你知道最近它加载到网络

00:04:09.000 --> 00:04:14.340
浏览器和安全管理器以及

00:04:11.069 --> 00:04:16.799
所有其他的东西，但猜猜做什么

00:04:14.340 --> 00:04:20.659
 Java应用程序和Web浏览器不是

00:04:16.799 --> 00:04:23.640
在这个世纪的这个十年中的事情

00:04:20.659 --> 00:04:26.430
但是Java被用来部署

00:04:23.640 --> 00:04:27.389
云中的应用程序和您

00:04:26.430 --> 00:04:29.370
发布包

00:04:27.389 --> 00:04:30.810
在打包的应用程序中结束

00:04:29.370 --> 00:04:34.860
在应用商店中

00:04:30.810 --> 00:04:37.139
那当然是硬件

00:04:34.860 --> 00:04:40.169
不断发展，我们现在拥有机器

00:04:37.139 --> 00:04:42.360
拥有TB级的记忆，我们可以更深入地了解

00:04:40.169 --> 00:04:44.159
内存层次结构

00:04:42.360 --> 00:04:46.229
在您的处理器核心和

00:04:44.159 --> 00:04:49.680
您的存储系统，我们有更深

00:04:46.229 --> 00:04:52.229
更多的处理器管线，我们

00:04:49.680 --> 00:04:54.180
具有向量和cyndi指令集

00:04:52.229 --> 00:04:55.979
两者都在考虑什么

00:04:54.180 --> 00:04:57.960
普通处理器，然后

00:04:55.979 --> 00:05:02.219
真的让你在里面找到了

00:04:57.960 --> 00:05:04.620
 GPU，因此我们追求这两个

00:05:02.219 --> 00:05:06.659
鉴于所有这些大目标

00:05:04.620 --> 00:05:08.939
一些主要活跃因素

00:05:06.659 --> 00:05:11.250
 JDK开放社区中的项目以及

00:05:08.939 --> 00:05:21.740
这就是我想谈的

00:05:11.250 --> 00:05:25.439
一天，所以我要讨论的是

00:05:21.740 --> 00:05:27.509
琥珀色，这是正确尺寸的

00:05:25.439 --> 00:05:30.749
语言仪式减少了一些

00:05:27.509 --> 00:05:33.990
您实际上知道的样板

00:05:30.749 --> 00:05:36.270
由布莱恩领导带织机带来

00:05:33.990 --> 00:05:38.490
 Java的延续和纤维

00:05:36.270 --> 00:05:42.000
由Ron领导的平台

00:05:38.490 --> 00:05:44.610
 Pressler Panama具有新的对外功能

00:05:42.000 --> 00:05:45.899
和外部数据接口由

00:05:44.610 --> 00:05:49.620
毛里西奥·贾马特·爱茉莉

00:05:45.899 --> 00:05:51.659
最后是瓦尔哈拉最大的价值

00:05:49.620 --> 00:05:53.939
的类型和专用泛型

00:05:51.659 --> 00:05:58.879
 Java平台由John Rose共同领导

00:05:53.939 --> 00:06:02.009
和Brian胆量，所以让我们从琥珀开始

00:05:58.879 --> 00:06:04.199
所以琥珀的目的是针对疼痛

00:06:02.009 --> 00:06:06.689
指出Java需要太多

00:06:04.199 --> 00:06:08.250
仪式那里也有

00:06:06.689 --> 00:06:10.909
多少样板

00:06:08.250 --> 00:06:14.729
就像Java中的样板数量

00:06:10.909 --> 00:06:21.000
一两个好看你的幽默

00:06:14.729 --> 00:06:22.979
当然你知道的家伙，这只是

00:06:21.000 --> 00:06:25.139
当你变得特别痛苦

00:06:22.979 --> 00:06:26.849
试图让你知道微服务

00:06:25.139 --> 00:06:28.080
他们只是要交换数据

00:06:26.849 --> 00:06:30.089
出来，你必须处理所有

00:06:28.080 --> 00:06:31.710
这些用于那些课程，大约

00:06:30.089 --> 00:06:34.080
只是为什么让我们变得更好

00:06:31.710 --> 00:06:36.240
所以琥珀色的解决方案实际上是

00:06:34.080 --> 00:06:37.649
不，我们不是在攻击样板

00:06:36.240 --> 00:06:39.389
就可以攻击

00:06:37.649 --> 00:06:40.810
通过转移

00:06:39.389 --> 00:06:42.820
 Java语法变成类似

00:06:40.810 --> 00:06:44.620
请然后所有程序

00:06:42.820 --> 00:06:46.480
真的很紧凑

00:06:44.620 --> 00:06:48.400
没有样板，但他们也将

00:06:46.480 --> 00:06:50.800
难以维持，而是我们所采用的方法

00:06:48.400 --> 00:06:53.050
接受正在创造一系列语言

00:06:50.800 --> 00:06:54.790
随着时间的推移，它们交付的功能

00:06:53.050 --> 00:06:57.100
他们在一起的时间让你

00:06:54.790 --> 00:06:58.570
更清楚地表达你的意思， 

00:06:57.100 --> 00:07:01.900
如果你能更清楚地表达你的意思

00:06:58.570 --> 00:07:02.470
这意味着样板会注意

00:07:01.900 --> 00:07:03.730
本身

00:07:02.470 --> 00:07:04.990
那里会更少

00:07:03.730 --> 00:07:09.330
仍然有点可能是因为

00:07:04.990 --> 00:07:11.860
这就是Java没问题的方式

00:07:09.330 --> 00:07:15.010
有多少人对特里西娅的感兴趣

00:07:11.860 --> 00:07:16.900
在此之前就聊了

00:07:15.010 --> 00:07:18.610
不可能在这里，所以我会问你， 

00:07:16.900 --> 00:07:20.680
我将动态优化此讨论

00:07:18.610 --> 00:07:25.870
我们去找她谈论局部变量了吗

00:07:20.680 --> 00:07:28.690
类型推断是一点我应该

00:07:25.870 --> 00:07:31.240
说说吧，好的，我再说

00:07:28.690 --> 00:07:35.650
关于它可以推断类型

00:07:31.240 --> 00:07:40.450
 Java是否具有类型推断？ 

00:07:35.650 --> 00:07:42.760
总是可以的，所以很多人认为

00:07:40.450 --> 00:07:45.190
认为Java没有类型推断

00:07:42.760 --> 00:07:47.169
或从未真正拥有它，直到

00:07:45.190 --> 00:07:49.390
最近或某事，但实际上

00:07:47.169 --> 00:07:54.010
很久以前就有类型推断

00:07:49.390 --> 00:07:56.410
在Java 5中，当我们做泛型时

00:07:54.010 --> 00:07:59.890
添加了仿制药，我们本可以使您

00:07:56.410 --> 00:08:02.770
编写退货的通用类型

00:07:59.890 --> 00:08:04.330
每个方法调用的类型，因此如果

00:08:02.770 --> 00:08:06.250
您想将集合调用为空

00:08:04.330 --> 00:08:08.740
列出您必须在其中输入字符串

00:08:06.250 --> 00:08:11.620
尖括号指示返回

00:08:08.740 --> 00:08:12.820
打字，但那样做就可以了，所以我们

00:08:11.620 --> 00:08:14.380
并没有让您知道

00:08:12.820 --> 00:08:16.900
编译器拥有所有的信息

00:08:14.380 --> 00:08:20.139
需要确定你知道

00:08:16.900 --> 00:08:22.330
字符串是一个字符串，是否存在

00:08:20.139 --> 00:08:23.440
在这种情况下返回类型，这样您就不会

00:08:22.330 --> 00:08:26.620
必须写你可以的话

00:08:23.440 --> 00:08:30.490
但我从未真正见过任何人

00:08:26.620 --> 00:08:34.060
在Java 7中我们引入了一个东西

00:08:30.490 --> 00:08:36.250
称为“钻石运营商列表” 

00:08:34.060 --> 00:08:37.539
字符串列表等于新的ArrayList字符串

00:08:36.250 --> 00:08:40.539
在这里，你很紧张，你正在输入字符串

00:08:37.539 --> 00:08:42.940
在尖括号中两次

00:08:40.539 --> 00:08:44.560
编译器从左侧知道

00:08:42.940 --> 00:08:46.360
这将是一个ArrayList 

00:08:44.560 --> 00:08:47.620
字符串列表，因此您可以

00:08:46.360 --> 00:08:50.410
在右边代替你

00:08:47.620 --> 00:08:52.570
手边，所以你可以绑它就可以

00:08:50.410 --> 00:08:54.160
只需输入钻石空钻石空

00:08:52.570 --> 00:08:54.470
空的尖尖的括号，所以

00:08:54.160 --> 00:08:56.570
已编译

00:08:54.470 --> 00:08:58.450
我们会为您填写，我们无法

00:08:56.570 --> 00:09:00.800
推断尖括号本身

00:08:58.450 --> 00:09:02.150
因为没有尖括号

00:09:00.800 --> 00:09:04.190
实际上与

00:09:02.150 --> 00:09:05.960
被称为原始类型的东西，所以我们

00:09:04.190 --> 00:09:09.260
那种坚持，但至少在

00:09:05.960 --> 00:09:13.520
至少它的冗长程度降低了7 

00:09:09.260 --> 00:09:15.020
 8当我们引入lambda时，您可以

00:09:13.520 --> 00:09:17.420
这样写一个lambda，你可以写

00:09:15.020 --> 00:09:19.550
每个lambda的类型

00:09:17.420 --> 00:09:21.830
在这种情况下，参数变量为字符串s 

00:09:19.550 --> 00:09:23.810
但您不必编译器就可以

00:09:21.830 --> 00:09:25.760
推断出您只需输入s箭头即可

00:09:23.810 --> 00:09:27.380
点长度现在有时很有用

00:09:25.760 --> 00:09:29.630
开始写出lambda的类型

00:09:27.380 --> 00:09:33.170
参数变量，但您不必

00:09:29.630 --> 00:09:35.840
 Java 10中的更多类型推断

00:09:33.170 --> 00:09:38.270
引入局部变量类型推断

00:09:35.840 --> 00:09:41.420
局部变量类型推断适用于

00:09:38.270 --> 00:09:43.940
这样的情况我们都写了

00:09:41.420 --> 00:09:47.660
代码bufferedreader reader等于new 

00:09:43.940 --> 00:09:49.850
缓冲的读者好吧，是的

00:09:47.660 --> 00:09:53.000
您的身份证可以部分为您写

00:09:49.850 --> 00:09:58.040
但是但是来吧，我真的需要

00:09:53.000 --> 00:10:02.750
甚至两次读取缓冲的读取器，所以10 

00:09:58.040 --> 00:10:04.280
我们有VAR关键字sudo，它是一个

00:10:02.750 --> 00:10:07.130
从技术上讲，这是一个伪关键字

00:10:04.280 --> 00:10:08.840
告诉任何人，以便您可以设置您可以

00:10:07.130 --> 00:10:11.180
类型var reader等于新缓冲

00:10:08.840 --> 00:10:12.620
读者编译器已经足够

00:10:11.180 --> 00:10:14.480
信息在右侧

00:10:12.620 --> 00:10:16.730
作业要了解哦，是的

00:10:14.480 --> 00:10:19.430
这是一个缓冲的读取器，因此将其插入

00:10:16.730 --> 00:10:23.150
有效地将其插入

00:10:19.430 --> 00:10:24.860
左侧，所以这是一个

00:10:23.150 --> 00:10:26.000
限于局部变量，这就是为什么

00:10:24.860 --> 00:10:27.710
它称为局部变量类型

00:10:26.000 --> 00:10:29.630
推论

00:10:27.710 --> 00:10:31.880
您不能在无法使用的字段上使用

00:10:29.630 --> 00:10:35.780
在方法参数或lambda上使用它

00:10:31.880 --> 00:10:37.580
参数，不是我们不是

00:10:35.780 --> 00:10:39.200
把Java变成JavaScript这不是

00:10:37.580 --> 00:10:42.020
动态打字这不是说

00:10:39.200 --> 00:10:43.730
读者可以是读者所在的任何人

00:10:42.020 --> 00:10:45.680
这里的范围将是一个

00:10:43.730 --> 00:10:47.750
其余的缓冲阅读器

00:10:45.680 --> 00:10:49.760
局部变量范围毫无疑问

00:10:47.750 --> 00:10:51.020
关于它不是动态输入

00:10:49.760 --> 00:10:52.910
就像在JavaScript中一样

00:10:51.020 --> 00:10:54.260
站立静态打字，少得多

00:10:52.910 --> 00:10:55.880
键盘打字，所以这是一件好事

00:10:54.260 --> 00:10:57.140
而且尽管它要少得多

00:10:55.880 --> 00:11:01.250
读你的眼睛，甚至

00:10:57.140 --> 00:11:03.620
如果你在

00:11:01.250 --> 00:11:05.600
所有人都承认我有养成的习惯

00:11:03.620 --> 00:11:07.790
使用您可能想要的短变量名

00:11:05.600 --> 00:11:08.210
考虑使用更长的

00:11:07.790 --> 00:11:10.250
有一个

00:11:08.210 --> 00:11:12.500
这样的扩展示例，其中

00:11:10.250 --> 00:11:13.670
您有一个网址，正在打开一个

00:11:12.500 --> 00:11:17.380
连接将其包裹在扫描仪中

00:11:13.670 --> 00:11:20.420
周围它与var看起来更好

00:11:17.380 --> 00:11:23.180
但是如果我只是用你的变量

00:11:20.420 --> 00:11:25.899
您会看到一个S听到，并且您知道20行

00:11:23.180 --> 00:11:28.910
稍后您的代码可能还不清楚

00:11:25.899 --> 00:11:31.700
所以局部变量类型推断VAR 

00:11:28.910 --> 00:11:33.800
 Java 10中的关键字，详细信息在

00:11:31.700 --> 00:11:39.110
危险6如果您要检查

00:11:33.800 --> 00:11:42.620
好的，让我们继续前进，是的

00:11:39.110 --> 00:11:46.520
旅途286让我们动起来让我们动起来

00:11:42.620 --> 00:11:47.930
在另一件事上，这是一个Trish 

00:11:46.520 --> 00:11:50.750
告诉我她是否谈论开关

00:11:47.930 --> 00:11:52.130
每个人都记得的表情

00:11:50.750 --> 00:12:02.420
有人要我谈论开关

00:11:52.130 --> 00:12:03.770
表情没有跳过显示她已经

00:12:02.420 --> 00:12:06.920
听起来像同一个人

00:12:03.770 --> 00:12:10.720
说是，不是，我走了

00:12:06.920 --> 00:12:15.770
那我很快就讲完

00:12:10.720 --> 00:12:19.040
没多久，好吧，假设

00:12:15.770 --> 00:12:21.050
我们有这是

00:12:19.040 --> 00:12:23.779
星期一，星期二，等等等等

00:12:21.050 --> 00:12:25.370
为了这个小练习

00:12:23.779 --> 00:12:30.440
在这里我们要计算的长度

00:12:25.370 --> 00:12:32.510
现在，您每天的名字

00:12:30.440 --> 00:12:34.250
聪明的你会知道聪明的方法

00:12:32.510 --> 00:12:37.190
这样做当然是为了

00:12:34.250 --> 00:12:39.230
星期几对象上的字符串和

00:12:37.190 --> 00:12:40.640
计算其长度正确但可以

00:12:39.230 --> 00:12:42.200
为了说明的目的

00:12:40.640 --> 00:12:45.290
假设我们不会那样做

00:12:42.200 --> 00:12:46.730
相反，我们要写一个开关，这样

00:12:45.290 --> 00:12:49.640
我们有一个无字母的变量

00:12:46.730 --> 00:12:51.470
打开我们有一个添加一周的对象

00:12:49.640 --> 00:12:53.829
案件星期一星期五星期日麻木的信件

00:12:51.470 --> 00:12:56.270
星期二星期三星期三休息六点

00:12:53.829 --> 00:12:57.529
等星期三在办公室，我认为是

00:12:56.270 --> 00:13:02.870
有时是真正晦涩的来源

00:12:57.529 --> 00:13:04.100
臭虫，因为它是最长的名字

00:13:02.870 --> 00:13:07.220
各种各样的东西可能会在这里出错

00:13:04.100 --> 00:13:08.899
你可以忘记休息等等

00:13:07.220 --> 00:13:11.600
会跌倒你可以忘记

00:13:08.899 --> 00:13:13.399
分配数字字母你可以

00:13:11.600 --> 00:13:15.230
可能会忘记您的默认值，或者也许是您

00:13:13.399 --> 00:13:17.570
落入默认值，因为您忘记了

00:13:15.230 --> 00:13:19.040
布莱恩变得像以前一样突破

00:13:17.570 --> 00:13:20.180
只是想说这不是

00:13:19.040 --> 00:13:21.620
帮助您的语言是

00:13:20.180 --> 00:13:25.130
语言使你胆怯

00:13:21.620 --> 00:13:27.130
错误，如果您考虑一下

00:13:25.130 --> 00:13:30.950
我们只是在计算一个表达式，所以

00:13:27.130 --> 00:13:34.460
让我们这样写，然后Java 12 

00:13:30.950 --> 00:13:36.680
你可以，你只要写你的权利

00:13:34.460 --> 00:13:37.640
您可以将其作为一种表达方式

00:13:36.680 --> 00:13:39.950
作业的右侧

00:13:37.640 --> 00:13:41.630
声明，您可以将其嵌入

00:13:39.950 --> 00:13:43.250
如果您真的以更大的表情表达

00:13:41.630 --> 00:13:45.529
要我们借用箭头语法

00:13:43.250 --> 00:13:48.980
来自lambda，所以这就是你

00:13:45.529 --> 00:13:52.970
表示表达式的值，并

00:13:48.980 --> 00:13:57.070
作为额外的特殊奖励，编译器

00:13:52.970 --> 00:13:59.420
在某些情况下可以看到可以推断

00:13:57.070 --> 00:14:01.279
可以推断出您已经涵盖了所有

00:13:59.420 --> 00:14:02.960
案例，因此您无需提供

00:14:01.279 --> 00:14:04.820
默认，如果您需要提供默认值

00:14:02.960 --> 00:14:06.170
编译器的柳树会告诉你

00:14:04.820 --> 00:14:08.660
并会坚持要求您这样做，但您

00:14:06.170 --> 00:14:13.450
不必这样切换表达式

00:14:08.660 --> 00:14:16.820
在Java 12中，详细信息在JEP 325中

00:14:13.450 --> 00:14:20.240
开关表达式是预览功能

00:14:16.820 --> 00:14:21.980
这意味着什么，他们

00:14:20.240 --> 00:14:24.529
在规范中，它们是由

00:14:21.980 --> 00:14:26.089
编译器，以便VM将运行它们

00:14:24.529 --> 00:14:29.990
和其他一切，但他们不是

00:14:26.089 --> 00:14:32.209
默认情况下启用99％烘焙，但

00:14:29.990 --> 00:14:34.640
我们想利用这六种之一

00:14:32.209 --> 00:14:37.279
数月的发布周期以获取最后的生命

00:14:34.640 --> 00:14:39.620
我们可以提供反馈，因为一旦添加了一些

00:14:37.279 --> 00:14:42.620
某种语言所需要的

00:14:39.620 --> 00:14:44.240
永远拿出来，你知道我们可以

00:14:42.620 --> 00:14:46.880
清扫几乎考虑任何东西

00:14:44.240 --> 00:14:48.950
每块锡石的语言，如果

00:14:46.880 --> 00:14:51.589
想玩中的开关表达式

00:14:48.950 --> 00:14:54.110
 12您需要使用此命令行

00:14:51.589 --> 00:14:56.720
在编译时和

00:14:54.110 --> 00:14:58.850
在命令行或

00:14:56.720 --> 00:15:00.890
在您的手掌xml中

00:14:58.850 --> 00:15:04.730
无论您的构建系统用来

00:15:00.890 --> 00:15:07.430
启用它，如果您看到有趣的东西

00:15:04.730 --> 00:15:10.370
如果我支持，请给我们您的反馈

00:15:07.430 --> 00:15:13.370
我们请发送它，因为我们想

00:15:10.370 --> 00:15:16.279
使这些最终在Java 13中到期

00:15:13.370 --> 00:15:18.320
在9月中旬，这意味着我们需要

00:15:16.279 --> 00:15:21.170
即将做出最后的决定

00:15:18.320 --> 00:15:25.390
现在好了，让我们继续介绍

00:15:21.170 --> 00:15:27.500
尚未进行任何早期访问构建

00:15:25.390 --> 00:15:32.150
我们可能已经编写的另一种代码

00:15:27.500 --> 00:15:34.430
都写了你有一个应用程序

00:15:32.150 --> 00:15:35.030
您需要喷洒一些HTML，以便您

00:15:34.430 --> 00:15:36.500
有

00:15:35.030 --> 00:15:39.590
你有一些你有一个字符串常量

00:15:36.500 --> 00:15:41.600
基本上就是一些HTML， 

00:15:39.590 --> 00:15:43.520
写了一堆双引号和

00:15:41.600 --> 00:15:45.320
用加号和引号结尾的行

00:15:43.520 --> 00:15:47.660
东西，是的，你已经嵌入了

00:15:45.320 --> 00:15:49.280
字符串常量内的引号

00:15:47.660 --> 00:15:53.650
常量，所以不要忘记引用那些

00:15:49.280 --> 00:15:55.910
带有反斜杠等等

00:15:53.650 --> 00:15:58.630
是的，这有点烦人

00:15:55.910 --> 00:16:01.490
只有多行字符串，是的

00:15:58.630 --> 00:16:03.920
所以我们正在研究多行字符串

00:16:01.490 --> 00:16:05.990
字面量实际上是

00:16:03.920 --> 00:16:08.390
令人惊讶的复杂功能

00:16:05.990 --> 00:16:10.610
设计我们实际上几乎把它们放在12 

00:16:08.390 --> 00:16:12.590
作为预览功能，但将其拉到

00:16:10.610 --> 00:16:14.840
由于有价值而在最后一刻

00:16:12.590 --> 00:16:16.580
我们收到的反馈是

00:16:14.840 --> 00:16:19.370
目前的提议不是早

00:16:16.580 --> 00:16:21.140
访问版本，但我们要借用

00:16:19.370 --> 00:16:23.000
语法可能看起来很像

00:16:21.140 --> 00:16:24.260
 Python和其他语言的三重

00:16:23.000 --> 00:16:27.020
开头三引号

00:16:24.260 --> 00:16:29.660
如果您在末尾加双引号

00:16:27.020 --> 00:16:31.850
需要in中的三重双引号

00:16:29.660 --> 00:16:33.380
在中间，那么您将不得不使用

00:16:31.850 --> 00:16:37.910
一堆反斜杠，但有机会

00:16:33.380 --> 00:16:40.310
现在在实践中，如果

00:16:37.910 --> 00:16:41.480
你仔细看这个

00:16:40.310 --> 00:16:43.700
字符串常量的值将

00:16:41.480 --> 00:16:45.560
包括一堆空白

00:16:43.700 --> 00:16:48.860
您包括在这里以便拥有

00:16:45.560 --> 00:16:50.390
您的Java代码正确缩进

00:16:48.860 --> 00:16:51.830
您可能实际上并不想要

00:16:50.390 --> 00:16:53.750
您的字符串常量，所以我们要添加

00:16:51.830 --> 00:16:58.040
字符串类的便捷方法

00:16:53.750 --> 00:17:00.320
叫了一条线，将找出

00:16:58.040 --> 00:17:02.120
白领的共同子序列

00:17:00.320 --> 00:17:04.970
空格和剥离，所以你就得到

00:17:02.120 --> 00:17:07.880
 HTML并自然缩进

00:17:04.970 --> 00:17:11.329
您期望如此，因此我们的目标是针对Java 

00:17:07.880 --> 00:17:13.370
尚未在JEP中写成13 

00:17:11.329 --> 00:17:17.209
还将在13中成为预览功能

00:17:13.370 --> 00:17:20.660
也许我们会看看那里发生了什么代码

00:17:17.209 --> 00:17:25.120
关闭代码13大约一个月

00:17:20.660 --> 00:17:28.069
所以我们看看会发生什么

00:17:25.120 --> 00:17:31.820
我们很多人都喜欢的另一种代码

00:17:28.069 --> 00:17:34.850
一直写，说我们有一点

00:17:31.820 --> 00:17:38.180
点有一个X和ay值，我们有一个

00:17:34.850 --> 00:17:42.950
我们有访问器的构造函数在那里

00:17:38.180 --> 00:17:47.300
这里缺少任何东西

00:17:42.950 --> 00:17:50.480
把等号哈希码说成字符串

00:17:47.300 --> 00:17:52.460
哦，是的，我必须写那两个

00:17:50.480 --> 00:17:55.040
你可以做到这一点或你的ID 

00:17:52.460 --> 00:17:58.040
为你做，然后你去

00:17:55.040 --> 00:17:59.720
改变一点，也许然后

00:17:58.040 --> 00:18:01.450
两年后，你来维护

00:17:59.720 --> 00:18:03.920
这些东西，那么你必须去读

00:18:01.450 --> 00:18:06.610
再次将相等的哈希码读入字符串

00:18:03.920 --> 00:18:09.710
确保他们在那里实际写

00:18:06.610 --> 00:18:11.480
所有这些代码意味着很容易

00:18:09.710 --> 00:18:13.760
偷工减料导致

00:18:11.480 --> 00:18:17.690
虫子和虫子导致不快乐，我们

00:18:13.760 --> 00:18:19.400
知道其余的，如果你看着它

00:18:17.690 --> 00:18:23.510
这里的封装量实际上是

00:18:19.400 --> 00:18:25.570
我的意思是极端，我们不需要嫉妒

00:18:23.510 --> 00:18:28.070
封装此类

00:18:25.570 --> 00:18:31.580
为我们提供了X到y 

00:18:28.070 --> 00:18:34.100
他们是完全可见的，没有

00:18:31.580 --> 00:18:36.140
去四处躲藏的理由

00:18:34.100 --> 00:18:37.670
这里没有秘密，我们只是

00:18:36.140 --> 00:18:40.400
需要一种方法来说这堂课是

00:18:37.670 --> 00:18:42.290
一些数据的透明容器，所以

00:18:40.400 --> 00:18:43.970
我们可以用另一个功能做到这一点

00:18:42.290 --> 00:18:46.760
我们正在处理被叫记录

00:18:43.970 --> 00:18:50.140
您只需输入记录点双倍X 

00:18:46.760 --> 00:18:55.550
双Y分号就完成了

00:18:50.140 --> 00:18:58.100
这代表了所有这些代码

00:18:55.550 --> 00:19:01.820
那就是现在那就是现在

00:18:58.100 --> 00:19:05.090
变暗的记录可以替换所有

00:19:01.820 --> 00:19:07.130
该POJO代码，因为有时数据是

00:19:05.090 --> 00:19:09.740
只是数据，所以我有一个要求

00:19:07.130 --> 00:19:11.050
听一些对话，如果你想

00:19:09.740 --> 00:19:13.700
分享你可以上台

00:19:11.050 --> 00:19:17.380
否则，请保密或

00:19:13.700 --> 00:19:17.380
带领房间谢谢

00:19:21.530 --> 00:19:26.960
您可以根据需要自定义记录

00:19:24.350 --> 00:19:28.880
通过添加例如一些东西

00:19:26.960 --> 00:19:30.620
如果您想要其他哈希，则可以

00:19:28.880 --> 00:19:32.510
代码算法比那个

00:19:30.620 --> 00:19:34.430
只要你可以自己写

00:19:32.510 --> 00:19:35.990
您想要计算标准

00:19:34.430 --> 00:19:39.260
点的价值，因此您可以添加

00:19:35.990 --> 00:19:40.880
您甚至可以提供一种规范方法

00:19:39.260 --> 00:19:44.630
自己的构造函数，因此您可以做事

00:19:40.880 --> 00:19:47.960
像确保数据不变

00:19:44.630 --> 00:19:50.300
进入您无法做的事情就是增加更多

00:19:47.960 --> 00:19:53.390
指出您无法添加更多数据，因为

00:19:50.300 --> 00:19:55.760
那会违反不变式

00:19:53.390 --> 00:19:58.220
记录是数据的透明持有者

00:19:55.760 --> 00:20:00.170
因此必须声明所有数据

00:19:58.220 --> 00:20:02.150
预先在顶部

00:20:00.170 --> 00:20:05.420
关于记录的另一件事是，它们

00:20:02.150 --> 00:20:07.520
是一成不变的，你不能修改

00:20:05.420 --> 00:20:11.090
记录对象的价值

00:20:07.520 --> 00:20:13.550
创建的，但是如果您真的需要可以

00:20:11.090 --> 00:20:15.020
一个不变的人，你可以很好地修改

00:20:13.550 --> 00:20:17.000
只是去写一个有你的身份证的课程

00:20:15.020 --> 00:20:18.590
像往常一样写课

00:20:17.000 --> 00:20:20.420
我们有原型吗

00:20:18.590 --> 00:20:27.080
的实现，但它不在

00:20:20.420 --> 00:20:29.900
任何早期访问版本，但还可以

00:20:27.080 --> 00:20:39.890
琥珀色的最后一个项目，然后我们将移动

00:20:29.900 --> 00:20:42.470
假设你有一个物体，它是

00:20:39.890 --> 00:20:44.930
就是说它将是一个整数或一个

00:20:42.470 --> 00:20:48.260
我们只是把事情加倍或一点

00:20:44.930 --> 00:20:50.330
看到，你想创造一个很好的整洁

00:20:48.260 --> 00:20:51.680
小东西格式化字符串

00:20:50.330 --> 00:20:55.610
描述其价值

00:20:51.680 --> 00:20:57.530
你可以写这种格式的代码

00:20:55.610 --> 00:20:59.780
方法接受一个它初始化的对象

00:20:57.530 --> 00:21:02.660
我们的字符串到未知，我们去

00:20:59.780 --> 00:21:08.030
通过aab是的一个实例

00:21:02.660 --> 00:21:12.140
整数不好意思

00:21:08.030 --> 00:21:12.680
如果我ABBA的整数实例，那么我们

00:21:12.140 --> 00:21:15.020
投

00:21:12.680 --> 00:21:16.670
 AAB到一个整数，我们坚持一个变量

00:21:15.020 --> 00:21:17.900
我，然后我们按这种格式

00:21:16.670 --> 00:21:19.820
我们的小消息，我们做类似的事情

00:21:17.900 --> 00:21:22.150
如果是double的实例，则为

00:21:19.820 --> 00:21:24.410
到你知道的地步，然后我们提取

00:21:22.150 --> 00:21:26.480
 pxpy我们使我们的小字符串和

00:21:24.410 --> 00:21:29.090
最后，我们返回s 

00:21:26.480 --> 00:21:32.660
好像我忘了一个大括号哦

00:21:29.090 --> 00:21:37.370
不奇怪

00:21:32.660 --> 00:21:39.230
好的模式匹配让我们做到这一点

00:21:37.370 --> 00:21:43.160
更紧凑，让您表达更多

00:21:39.230 --> 00:21:45.890
这样做显然意味着您的意思

00:21:43.160 --> 00:21:47.630
橙色突出显示的是

00:21:45.890 --> 00:21:51.140
我们称之为模式的东西

00:21:47.630 --> 00:21:54.140
结合结合两件事

00:21:51.140 --> 00:21:56.720
具有绑定的类型和前提条件测试

00:21:54.140 --> 00:21:58.940
如果测试成功，则进行操作

00:21:56.720 --> 00:22:02.450
绑定一个变量，该变量位于

00:21:58.940 --> 00:22:05.990
 if的下一位的范围

00:22:02.450 --> 00:22:09.380
在这种情况下的声明，所以这是

00:22:05.990 --> 00:22:12.290
您的整数I的AAB实例（如果存在） 

00:22:09.380 --> 00:22:15.680
 AAB是一个整数，则将其强制转换

00:22:12.290 --> 00:22:17.720
为您绑定到I和的整数

00:22:15.680 --> 00:22:19.910
那你就可以用我

00:22:17.720 --> 00:22:21.590
自然的if语句，您

00:22:19.910 --> 00:22:23.330
不必自己铸造，因为

00:22:21.590 --> 00:22:25.550
编译器可以很好地解决这一切

00:22:23.330 --> 00:22:27.500
为您服务真正酷的是您

00:22:25.550 --> 00:22:29.570
也可以使用模式来解构

00:22:27.500 --> 00:22:31.220
东西，所以一个点有一个X，我们

00:22:29.570 --> 00:22:34.010
在记录声明中看到了

00:22:31.220 --> 00:22:37.790
以前，如果AB是以下对象的实例

00:22:34.010 --> 00:22:39.890
点然后X然后这将提取其

00:22:37.790 --> 00:22:41.840
 x和y值将它们分配给

00:22:39.890 --> 00:22:44.450
变量x和y，然后在

00:22:41.840 --> 00:22:49.660
此表达式的其余部分o标记mark 

00:22:44.450 --> 00:22:49.660
马克假装那些不在那里

00:22:50.430 --> 00:22:55.920
我爱Apple Keynote，除了一个

00:22:53.100 --> 00:22:59.970
你无法提取代码并运行的东西

00:22:55.920 --> 00:23:03.590
并以自然的方式进行测试，所以我

00:22:59.970 --> 00:23:05.700
对幻灯片上的错误表示歉意

00:23:03.590 --> 00:23:09.990
模式与开关配合使用

00:23:05.700 --> 00:23:12.720
表达式，所以我们可以将所有这些捆绑在一起

00:23:09.990 --> 00:23:15.300
到一个开关表达式，这是

00:23:12.720 --> 00:23:17.840
你比它短得多

00:23:15.300 --> 00:23:20.520
更清晰，更少

00:23:17.840 --> 00:23:24.120
样板好，所以这是一个选择

00:23:20.520 --> 00:23:26.280
琥珀色的功能现在让我们继续

00:23:24.120 --> 00:23:29.370
完全不同的东西

00:23:26.280 --> 00:23:37.770
织机的延续和纤维

00:23:29.370 --> 00:23:42.180
切换到这台机器，这是

00:23:37.770 --> 00:23:46.620
同样的幻灯片，所以对不起牛奶可能还可以

00:23:42.180 --> 00:23:54.960
好，我们都有合适的机器

00:23:46.620 --> 00:23:57.650
对，那么织机到底是什么呢？ 

00:23:54.960 --> 00:23:57.650
只是看一些代码

00:24:01.100 --> 00:24:09.470
 [音乐] 

00:24:03.870 --> 00:24:14.309
所以在这里我有两天大的建筑

00:24:09.470 --> 00:24:15.720
从OpenJDK构建的Loom存储库

00:24:14.309 --> 00:24:19.580
几天前的地区

00:24:15.720 --> 00:24:19.580
弹出J shell并戳一下

00:24:19.730 --> 00:24:29.309
因此纤维在

00:24:25.919 --> 00:24:30.929
以线程为代价的开销

00:24:29.309 --> 00:24:32.490
太好了，他们知道你去过

00:24:30.929 --> 00:24:34.200
对Java来说很重要，其中之一

00:24:32.490 --> 00:24:37.049
 Java那种卑鄙的东西

00:24:34.200 --> 00:24:39.210
成为更流行的风格

00:24:37.049 --> 00:24:41.429
计算是线程很多

00:24:39.210 --> 00:24:43.049
人们需要两条线，不是

00:24:41.429 --> 00:24:45.480
不一定知道他们需要他们

00:24:43.049 --> 00:24:48.510
但他们却做到了，Java带来了

00:24:45.480 --> 00:24:50.039
与许多人互动的方式

00:24:48.510 --> 00:24:53.460
那很容易

00:24:50.039 --> 00:24:56.210
了解，所以我们可以做一个线程

00:24:53.460 --> 00:24:56.210
新线程

00:24:56.779 --> 00:25:06.899
我会在这里使用一点lambda 

00:25:04.260 --> 00:25:10.289
我们有一个线程，我们可以运行它

00:25:06.899 --> 00:25:11.940
发生打印嗨，你知道吗

00:25:10.289 --> 00:25:13.080
你知道真正的线程对象

00:25:11.940 --> 00:25:15.090
简单，当然你可以拥有

00:25:13.080 --> 00:25:17.820
成千上万的这些和

00:25:15.090 --> 00:25:21.390
各种各样的作品，但线程来了

00:25:17.820 --> 00:25:23.039
带着很多行李我们问了J壳

00:25:21.390 --> 00:25:25.110
好，它有多少行李

00:25:23.039 --> 00:25:26.580
正是一个线程对象拥有所有这些

00:25:25.110 --> 00:25:27.899
方法现在是

00:25:26.580 --> 00:25:30.990
其中一些是从

00:25:27.899 --> 00:25:33.990
你被那些卡住的java.lang对象

00:25:30.990 --> 00:25:35.909
但是这里有很多东西

00:25:33.990 --> 00:25:37.830
有一些可疑的性质

00:25:35.909 --> 00:25:39.750
他们的线程优先级在大多数情况下

00:25:37.830 --> 00:25:42.080
实现没有任何意义

00:25:39.750 --> 00:25:47.039
有些线程组具有

00:25:42.080 --> 00:25:49.320
几乎没有用，是一个

00:25:47.039 --> 00:25:50.610
不幸的是，无关的抽象

00:25:49.320 --> 00:25:52.500
在我们早期介绍的

00:25:50.610 --> 00:25:54.120
不能真正摆脱线程有一个

00:25:52.500 --> 00:25:57.240
所谓的上下文类加载器

00:25:54.120 --> 00:25:58.799
万神殿中是否存在疑问

00:25:57.240 --> 00:26:01.730
从早期开始就做出不错的设计决策

00:25:58.799 --> 00:26:03.960
 Java上下文类加载器的日子是

00:26:01.730 --> 00:26:05.909
在该列表上的位置低于

00:26:03.960 --> 00:26:08.279
序列化，它降低了

00:26:05.909 --> 00:26:10.559
定案，但它位于

00:26:08.279 --> 00:26:14.250
我们希望我们没有的事情

00:26:10.559 --> 00:26:15.450
完成了大部分Java线程

00:26:14.250 --> 00:26:18.120
对应于操作系统

00:26:15.450 --> 00:26:20.010
正在召集的主题

00:26:18.120 --> 00:26:23.640
因为这意味着操作系统

00:26:20.010 --> 00:26:26.370
完成所有工作，但这意味着Java 

00:26:23.640 --> 00:26:28.080
创建线程很昂贵，这意味着

00:26:26.370 --> 00:26:29.580
从一个切换到昂贵

00:26:28.080 --> 00:26:31.409
将一个Java线程处理到另一个

00:26:29.580 --> 00:26:33.840
操作系统线程到另一个

00:26:31.409 --> 00:26:35.730
通常有数千条指令

00:26:33.840 --> 00:26:38.669
从一个线程切换到另一个

00:26:35.730 --> 00:26:41.490
可能会很长一段时间，因为他们是如此

00:26:38.669 --> 00:26:43.020
重量级的便宜以获得

00:26:41.490 --> 00:26:45.299
高绩效的人写东西

00:26:43.020 --> 00:26:47.070
就像网络服务器倾向于

00:26:45.299 --> 00:26:50.360
非阻塞I / O技术或

00:26:47.070 --> 00:26:53.360
异步I / O技术是

00:26:50.360 --> 00:26:55.679
很难正确使用的技巧

00:26:53.360 --> 00:26:57.450
所以你会发现正在写作的专家

00:26:55.679 --> 00:26:58.649
网络服务器这样做，但随后

00:26:57.450 --> 00:27:00.779
他们正在服务的应用程序

00:26:58.649 --> 00:27:02.370
通常不会使用非阻塞或

00:27:00.779 --> 00:27:05.340
异步I / O，它们只是被写入

00:27:02.370 --> 00:27:07.380
正常的顺序方式等等

00:27:05.340 --> 00:27:08.789
您知道的服务器服务器硬件风

00:27:07.380 --> 00:27:10.590
被你利用之下

00:27:08.789 --> 00:27:12.510
因为你拥有所有这些东西

00:27:10.590 --> 00:27:15.870
发生在线程中，没有办法

00:27:12.510 --> 00:27:19.230
使它们更有效率，所以纤维

00:27:15.870 --> 00:27:24.380
顾名思义是轻巧的

00:27:19.230 --> 00:27:24.380
线让我们自己成为纤维

00:27:24.980 --> 00:27:29.929
周说纤维点计划我会做

00:27:29.990 --> 00:27:33.200
打印一个

00:27:36.539 --> 00:27:40.889
因此，API的一个区别是

00:27:38.879 --> 00:27:43.709
用纤维创建它们，它们是

00:27:40.889 --> 00:27:44.879
计划立即运行，因此

00:27:43.709 --> 00:27:47.489
打印高，然后又回来

00:27:44.879 --> 00:27:50.279
打印纤维对象的值

00:27:47.489 --> 00:27:52.529
而且它的字符串注释没有载体

00:27:50.279 --> 00:27:54.239
威胁这意味着什么现在

00:27:52.529 --> 00:27:56.399
光纤与载体无关

00:27:54.239 --> 00:27:58.139
线程，你可以有一个光纤

00:27:56.399 --> 00:27:59.489
一些计算比你一些

00:27:58.139 --> 00:28:00.869
计算它绑定到一个线程

00:27:59.489 --> 00:28:02.639
那时，它会产生，如果你

00:28:00.869 --> 00:28:04.440
检查了它，这是问它的问题

00:28:02.639 --> 00:28:05.639
对于它的字符串会说不

00:28:04.440 --> 00:28:06.959
载体线程，然后在什么时候

00:28:05.639 --> 00:28:10.339
再次运行它会说载体

00:28:06.959 --> 00:28:15.629
线程并给您线程ID 

00:28:10.339 --> 00:28:17.909
因此光纤允许Java Runtime 

00:28:15.629 --> 00:28:20.249
动态地动态映射您的

00:28:17.909 --> 00:28:22.589
操作系统线程的工作负载为

00:28:20.249 --> 00:28:25.529
你去，因为之间的切换

00:28:22.589 --> 00:28:27.059
纤维全部由Java Runtime完成

00:28:25.529 --> 00:28:28.409
光纤之间的系统切换可以

00:28:27.059 --> 00:28:30.659
在一百或200完成

00:28:28.409 --> 00:28:32.729
指示，它真的非常快， 

00:28:30.659 --> 00:28:37.109
纤维本身要小得多

00:28:32.729 --> 00:28:39.029
 Java线程不仅具有对象

00:28:37.109 --> 00:28:40.649
一个最大的Java堆对象

00:28:39.029 --> 00:28:43.019
但也有一个线程堆栈

00:28:40.649 --> 00:28:44.369
我认为你是从堆中分配出来的

00:28:43.019 --> 00:28:47.879
默认情况下知道是兆字节还是

00:28:44.369 --> 00:28:49.440
因此，这是一个很大的纤维， 

00:28:47.879 --> 00:28:50.940
原型实现在

00:28:49.440 --> 00:28:52.769
几百个字节的顺序，所以如果您

00:28:50.940 --> 00:28:55.159
想要拥有一百万根纤维

00:28:52.769 --> 00:28:57.449
 Java堆不是问题

00:28:55.159 --> 00:28:59.609
纤维也比线还简单

00:28:57.449 --> 00:29:01.829
这里所有的方法都在我们的小

00:28:59.609 --> 00:29:03.539
除了那些

00:29:01.829 --> 00:29:05.459
你从java.lang对象键中得到它

00:29:03.539 --> 00:29:07.199
你能做好什么就可以

00:29:05.459 --> 00:29:09.359
你不能取消你可以问的光纤吗

00:29:07.199 --> 00:29:10.859
活着的纤维中，您可以询问是否

00:29:09.359 --> 00:29:16.319
被取消，您可以等待推迟

00:29:10.859 --> 00:29:21.599
终止，没有什么其他的

00:29:16.319 --> 00:29:25.559
让我们看一个更真实的例子

00:29:21.599 --> 00:29:34.079
进入我最喜欢的IDE，即Emacs工作

00:29:25.559 --> 00:29:37.440
我确实做了一些基准测试

00:29:34.079 --> 00:29:40.919
这里有一个假设的休息服务

00:29:37.440 --> 00:29:43.289
这是使用jax-rs并回答

00:29:40.919 --> 00:29:46.679
剩下的路我们有一点方法

00:29:43.289 --> 00:29:48.359
称为sleep，它需要一个参数编号

00:29:46.679 --> 00:29:50.220
几毫秒，你就给它一些

00:29:48.359 --> 00:29:52.559
毫秒或默认为100 

00:29:50.220 --> 00:29:55.080
睡得好吗400 

00:29:52.559 --> 00:29:57.720
毫秒，这就是一个

00:29:55.080 --> 00:29:59.429
 Web服务的非常简单的模拟

00:29:57.720 --> 00:30:00.690
那是顺序写的

00:29:59.429 --> 00:30:02.190
一百毫秒

00:30:00.690 --> 00:30:06.000
没有非阻塞区域同步

00:30:02.190 --> 00:30:10.740
我在这里继续，所以我们用

00:30:06.000 --> 00:30:17.730
线程使线程捆绑成一个

00:30:10.740 --> 00:30:18.779
制作文件，我们当然会运行Maven 

00:30:17.730 --> 00:30:23.309
码头里面跑来跑去

00:30:18.779 --> 00:30:26.070
嵌入式Web服务器，我正在使用

00:30:23.309 --> 00:30:28.470
 Vegeta加载生成工具以点击

00:30:26.070 --> 00:30:30.419
该Web服务器收到一千个请求

00:30:28.470 --> 00:30:32.220
每秒第一天持续五秒钟

00:30:30.419 --> 00:30:36.710
预热，然后运行十秒钟，然后

00:30:32.220 --> 00:30:36.710
我们看完后的图表

00:30:36.950 --> 00:30:42.570
我们去

00:30:38.519 --> 00:30:52.980
哦，是的Firefox很难解决

00:30:42.570 --> 00:30:56.850
非常感谢您的演示，好吧，我们的

00:30:52.980 --> 00:30:59.639
该睡眠服务的响应时间

00:30:56.850 --> 00:31:01.590
与线程开始很好，也许不是

00:30:59.639 --> 00:31:03.690
太差了，好吗300毫秒

00:31:01.590 --> 00:31:06.269
延迟400毫秒服务未

00:31:03.690 --> 00:31:08.070
很好，但是您会在系统的

00:31:06.269 --> 00:31:10.019
已经运行了一段时间了

00:31:08.070 --> 00:31:12.929
真的很糟糕，你知道

00:31:10.019 --> 00:31:14.879
响应时间南一秒一秒

00:31:12.929 --> 00:31:18.269
在某些情况下这不是

00:31:14.879 --> 00:31:22.830
您想在生产中看到什么

00:31:18.269 --> 00:31:26.039
让我们重置关于码头的酷事

00:31:22.830 --> 00:31:28.019
你配置它不是一堆

00:31:26.039 --> 00:31:30.629
 XML或JSON或您配置的任何内容

00:31:28.019 --> 00:31:32.549
通过编写Java代码，我们可以

00:31:30.629 --> 00:31:35.820
配置它以简单地使用线程

00:31:32.549 --> 00:31:37.139
给它一个自定义的线程池，所以它有

00:31:35.820 --> 00:31:39.750
自己的小线程池

00:31:37.139 --> 00:31:43.080
抽象，我们要做的就是走

00:31:39.750 --> 00:31:45.240
在这里并覆盖执行

00:31:43.080 --> 00:31:46.919
默认情况下将创建一个方法

00:31:45.240 --> 00:31:48.269
新线程并运行它，相反，我们是

00:31:46.919 --> 00:31:50.909
只是要执行任何需要执行的操作

00:31:48.269 --> 00:31:53.210
在光纤上执行，让我们看看如何

00:31:50.909 --> 00:31:53.210
这些都不在了

00:31:57.420 --> 00:32:02.980
所以对代码没有实际的改变

00:32:00.130 --> 00:32:19.180
刚刚对命令行进行了一次更改

00:32:02.980 --> 00:32:27.370
选项，好吧，它没有崩溃

00:32:19.180 --> 00:32:28.540
很好，让我们重新加载它，您会看到

00:32:27.370 --> 00:32:30.130
纤维实际上做得很漂亮

00:32:28.540 --> 00:32:31.620
好，所以有一个初步的热身

00:32:30.130 --> 00:32:34.300
期间，我将放大此部分

00:32:31.620 --> 00:32:36.040
有一个初步的预热期

00:32:34.300 --> 00:32:37.900
您知道代码已被编译， 

00:32:36.040 --> 00:32:39.760
你知道热点是动态的吗

00:32:37.900 --> 00:32:41.710
编译的东西，但是之后

00:32:39.760 --> 00:32:43.900
延迟了一段时间

00:32:41.710 --> 00:32:46.240
下降到通常刚刚结束

00:32:43.900 --> 00:32:47.950
 100毫秒，因此几乎所有

00:32:46.240 --> 00:32:50.620
延迟由该睡眠占用， 

00:32:47.950 --> 00:32:53.530
从一个切换到另一个的开销

00:32:50.620 --> 00:32:55.390
光纤到另一个很难测量

00:32:53.530 --> 00:32:58.480
我的意思是它在那里出现，但是

00:32:55.390 --> 00:33:01.950
它比以前要不确定得多

00:32:58.480 --> 00:33:04.870
使用线程，因此有很大的改进

00:33:01.950 --> 00:33:07.150
纤维不只是为了避免

00:33:04.870 --> 00:33:08.980
非阻塞的I / O，尽管他们是你

00:33:07.150 --> 00:33:10.630
知道显然很明显

00:33:08.980 --> 00:33:12.700
他们打开了通往

00:33:10.630 --> 00:33:14.320
发to一堆新技术， 

00:33:12.700 --> 00:33:16.480
诸如渠道和数据流之类的东西

00:33:14.320 --> 00:33:17.980
演员，最酷的是

00:33:16.480 --> 00:33:20.200
所有这些你都可以

00:33:17.980 --> 00:33:21.460
可作为库实现

00:33:20.200 --> 00:33:22.660
您知道它们不是Java平台

00:33:21.460 --> 00:33:25.500
我们实际需要设计的东西

00:33:22.660 --> 00:33:28.390
进入JVM进入语言

00:33:25.500 --> 00:33:31.630
过去我确实提到

00:33:28.390 --> 00:33:34.300
延续是

00:33:31.630 --> 00:33:36.820
较低级别的JVM机制

00:33:34.300 --> 00:33:38.470
纤维是建立的延续

00:33:36.820 --> 00:33:40.180
对于很多其他事情有用

00:33:38.470 --> 00:33:43.210
发电机的产量等等

00:33:40.180 --> 00:33:44.860
我们将来可能会利用，但

00:33:43.210 --> 00:33:46.210
但我们会看到并且现在继续

00:33:44.860 --> 00:33:48.370
可能不会暴露在

00:33:46.210 --> 00:33:50.140
公共API，但它们是另一个

00:33:48.370 --> 00:33:53.080
 Java借用示例

00:33:50.140 --> 00:34:00.750
公认的概念

00:33:53.080 --> 00:34:03.160
语言确定，让我们继续前往巴拿马， 

00:34:00.750 --> 00:34:06.450
用Java调用本机代码

00:34:03.160 --> 00:34:09.850
我实际上写过的人，好吧， 

00:34:06.450 --> 00:34:14.210
公平的数字有多少人喜欢

00:34:09.850 --> 00:34:14.980
好吧，我也不是，这是一种

00:34:14.210 --> 00:34:17.180
痛苦的

00:34:14.980 --> 00:34:19.670
调用与之交互的本机代码

00:34:17.180 --> 00:34:23.780
本机数据是一件很笨拙的事情

00:34:19.670 --> 00:34:25.940
用Java编写J＆I很难

00:34:23.780 --> 00:34:28.160
开机很慢

00:34:25.940 --> 00:34:30.020
我的意思是慢跑慢

00:34:28.160 --> 00:34:31.850
另外，您必须编写C代码

00:34:30.020 --> 00:34:33.830
编译成本地库负载

00:34:31.850 --> 00:34:35.720
库以及用于本机数据的所有内容

00:34:33.830 --> 00:34:37.760
您可以使用j'ni或直接使用

00:34:35.720 --> 00:34:39.170
字节缓冲区，但您知道它们会变种

00:34:37.760 --> 00:34:42.410
有点笨拙

00:34:39.170 --> 00:34:45.520
巴拿马的复杂数据格式是

00:34:42.410 --> 00:34:47.570
一种全新的Java方法

00:34:45.520 --> 00:34:49.040
与外部功能进行交互

00:34:47.570 --> 00:34:52.340
再次国外数据，你知道这不是

00:34:49.040 --> 00:34:53.660
高层次这不是一个新主意

00:34:52.340 --> 00:34:55.100
平台当然做到了这种

00:34:53.660 --> 00:34:55.610
的事情，但现在我们正在尝试

00:34:55.100 --> 00:34:57.950
去做吧

00:34:55.610 --> 00:35:00.520
 for Java，让我们看一下

00:34:57.950 --> 00:35:00.520
一些代码

00:35:08.530 --> 00:35:14.780
在这里，我还有另外两天的时间

00:35:11.660 --> 00:35:18.950
巴拿马回购交易的典范演示

00:35:14.780 --> 00:35:22.940
让我们来看看本地交互

00:35:18.950 --> 00:35:25.340
在标准UNIX库调用getpid get 

00:35:22.940 --> 00:35:27.800
您的进程标识符真的很简单

00:35:25.340 --> 00:35:29.720
不带不带参数，它

00:35:27.800 --> 00:35:31.910
返回实际上是在的出价T 

00:35:29.720 --> 00:35:34.580
只是一个整数，那就是你的

00:35:31.910 --> 00:35:36.290
进程ID有多难

00:35:34.580 --> 00:35:38.330
用J＆I从Java很好地做到这一点

00:35:36.290 --> 00:35:40.340
必须写一堆东西，这是

00:35:38.330 --> 00:35:42.650
所有样板都很丑陋，易于

00:35:40.340 --> 00:35:44.600
弄错了，让我告诉你你将如何做

00:35:42.650 --> 00:35:48.350
告诉你如何在巴拿马做

00:35:44.600 --> 00:35:53.390
巴拿马有三个组成部分，一个是

00:35:48.350 --> 00:35:55.100
称为J的内存提取工具

00:35:53.390 --> 00:35:56.750
从主页上的我们

00:35:55.100 --> 00:35:58.520
得知要使用此功能，您需要

00:35:56.750 --> 00:36:02.030
看你知道标准H那个头

00:35:58.520 --> 00:36:03.920
文件和一些东西在sis 

00:36:02.030 --> 00:36:07.010
键入点H，这实际上是

00:36:03.920 --> 00:36:12.440
 API的定义在这里是什么

00:36:07.010 --> 00:36:15.530
我们可以做的就是我们可以输入J提取用户

00:36:12.440 --> 00:36:19.910
包括您知道的标准数据

00:36:15.530 --> 00:36:20.360
年龄，因为这是我必须要做的原型

00:36:19.910 --> 00:36:22.190
这个

00:36:20.360 --> 00:36:26.390
不关心背后的人

00:36:22.190 --> 00:36:27.950
这里的选项，我将生成

00:36:26.390 --> 00:36:31.460
从中有些课，所以你知道

00:36:27.950 --> 00:36:35.780
标准年龄，我们将得到一堆

00:36:31.460 --> 00:36:39.710
实际上是所有的Java类

00:36:35.780 --> 00:36:41.870
这些是我们使用的编译接口

00:36:39.710 --> 00:36:43.460
 IV LLVM前端这些是

00:36:41.870 --> 00:36:46.600
这些是从应用程序编译的

00:36:43.460 --> 00:36:49.400
实际的c头文件转换为aa java 

00:36:46.600 --> 00:36:50.720
里面是什么的表示，如果

00:36:49.400 --> 00:36:52.760
我们在其中之一中寻找

00:36:50.720 --> 00:36:58.330
特别是如果我们看里面

00:36:52.760 --> 00:37:00.680
标准下划线年龄段我们看哦

00:36:58.330 --> 00:37:02.720
所有这些看起来很熟悉的东西

00:37:00.680 --> 00:37:05.390
您定义的这些int常量

00:37:02.720 --> 00:37:07.280
知道标准H是它的接口

00:37:05.390 --> 00:37:09.740
这些真的是常量和抽象

00:37:07.280 --> 00:37:12.950
出现是因为Java P被当作

00:37:09.740 --> 00:37:15.760
我们尽可能地正确

00:37:12.950 --> 00:37:18.950
通过这里，看看，我们找到了哦

00:37:15.760 --> 00:37:20.390
看起来有点子，所以我们有一个

00:37:18.950 --> 00:37:22.029
从此处生成的界面

00:37:20.390 --> 00:37:25.099
 C头

00:37:22.029 --> 00:37:30.130
我们该如何做好呢

00:37:25.099 --> 00:37:30.130
运行时我们要做的是

00:37:35.410 --> 00:37:41.390
导入它，我们要去

00:37:37.819 --> 00:37:44.420
导入巴拿马API，这是大多数

00:37:41.390 --> 00:37:46.220
它是一个Java API，模型可以查看数据

00:37:44.420 --> 00:37:47.809
类型，以便广告您知道有一个指针

00:37:46.220 --> 00:37:49.640
在那里输入并进行参数化， 

00:37:47.809 --> 00:37:53.390
其他记忆看记忆看

00:37:49.640 --> 00:37:56.210
获得流程ID的事情

00:37:53.390 --> 00:37:58.190
将调用调用静态方法

00:37:56.210 --> 00:38:01.339
巴拿马图书馆上课

00:37:58.190 --> 00:38:03.619
绑定所做的绑定是你

00:38:01.339 --> 00:38:06.200
说好，我已经有了这个单位的标准

00:38:03.619 --> 00:38:07.910
下划线代表的H接口

00:38:06.200 --> 00:38:10.789
我去过的UNIX库

00:38:07.910 --> 00:38:12.589
调用我将其传递给方法句柄

00:38:10.789 --> 00:38:16.670
我当前执行的查找对象

00:38:12.589 --> 00:38:18.109
上下文，我得到的是一个对象

00:38:16.670 --> 00:38:21.619
实施该单元标准H 

00:38:18.109 --> 00:38:23.829
接口，在该对象内部是一个

00:38:21.619 --> 00:38:26.569
我可以调用的getpid方法

00:38:23.829 --> 00:38:28.489
为了理智我也会

00:38:26.569 --> 00:38:32.660
调用我们已经拥有的Java API 

00:38:28.489 --> 00:38:40.339
获得报酬方法的回报，让我

00:38:32.660 --> 00:38:42.049
只需运行此类即可隐藏Java否

00:38:40.339 --> 00:38:44.509
我没有编译这个，因为我们可以

00:38:42.049 --> 00:38:47.630
现在启动单个文件源代码

00:38:44.509 --> 00:38:49.849
我直接需要的程序

00:38:47.630 --> 00:38:51.170
运行时与运行时我们运行它

00:38:49.849 --> 00:38:54.229
尽其所能

00:38:51.170 --> 00:38:55.910
它获取进程ID，而我从不

00:38:54.229 --> 00:38:57.440
实际上不得不看我的任何C代码

00:38:55.910 --> 00:38:58.969
从来没有写任何我没有的C代码

00:38:57.440 --> 00:39:00.950
需要编译一个点iso文件，然后

00:38:58.969 --> 00:39:03.440
记住它在哪里，并告诉java如何

00:39:00.950 --> 00:39:04.880
找到它，就是这样

00:39:03.440 --> 00:39:07.519
巴拿马的快速演示示范

00:39:04.880 --> 00:39:09.650
关于巴拿马，是每个人都会

00:39:07.519 --> 00:39:11.420
从中受益，但大多数人会

00:39:09.650 --> 00:39:14.390
间接受益于它

00:39:11.420 --> 00:39:16.039
的意思是真的

00:39:14.390 --> 00:39:18.079
由维护本地语言的人使用

00:39:16.039 --> 00:39:19.400
图书馆，例如

00:39:18.079 --> 00:39:20.150
维护诸如OpenGL或

00:39:19.400 --> 00:39:21.710
张量流

00:39:20.150 --> 00:39:24.769
你知道他们是那些专家

00:39:21.710 --> 00:39:27.469
图书馆可以使用巴拿马的工作-您

00:39:24.769 --> 00:39:31.309
知道摘要自己的c c ++头文件

00:39:27.469 --> 00:39:34.369
并为您提供易于使用的

00:39:31.309 --> 00:39:35.000
并非源自的Java API 

00:39:34.369 --> 00:39:36.470
那些

00:39:35.000 --> 00:39:42.260
文件，但他们可以使用的事实

00:39:36.470 --> 00:39:44.750
这一步使他们的工作变得更加轻松

00:39:42.260 --> 00:39:46.610
任务绩效巴拿马目前

00:39:44.750 --> 00:39:48.860
比j和i快一点，但是我们有

00:39:46.610 --> 00:39:50.180
一些代码仍在工作中

00:39:48.860 --> 00:39:53.020
实际上看起来不错，可能会

00:39:50.180 --> 00:39:57.160
最后快四倍

00:39:53.020 --> 00:40:00.490
好吧，让我们继续最后一项

00:39:57.160 --> 00:40:03.800
 valhalla值类型和专用

00:40:00.490 --> 00:40:05.390
泛型为何与我们合作

00:40:03.800 --> 00:40:07.520
在瓦尔哈拉（Valhalla）工作，我们一直在

00:40:05.390 --> 00:40:10.460
现在在瓦尔哈拉工作了一段时间

00:40:07.520 --> 00:40:12.800
这是一个非常深远的大项目

00:40:10.460 --> 00:40:19.010
切入但在语言和语言上

00:40:12.800 --> 00:40:23.890
虚拟机将答案合而为一

00:40:19.010 --> 00:40:26.650
图像是今天的处理器

00:40:23.890 --> 00:40:29.420
与我们所经历的大不相同

00:40:26.650 --> 00:40:32.270
 1995年，Java 1下降是新事物

00:40:29.420 --> 00:40:34.880
 CASP缓存未命中的代价是

00:40:32.270 --> 00:40:38.570
从200倍增加

00:40:34.880 --> 00:40:44.090
现在可以达到一千倍

00:40:38.570 --> 00:40:47.390
如果-如果我记忆访问，请永远使用

00:40:44.090 --> 00:40:49.010
错过缓存中的错过原因

00:40:47.390 --> 00:40:51.380
与Java健康相关

00:40:49.010 --> 00:40:53.090
面向对象的语言，我们有很多

00:40:51.380 --> 00:40:55.340
不是原始对象的对象

00:40:53.090 --> 00:40:56.810
如果有的话，那就是一个对象

00:40:55.340 --> 00:40:58.730
对象，那么你有指针和

00:40:56.810 --> 00:41:00.890
物体指向其他物体

00:40:58.730 --> 00:41:02.960
每次您追逐一个指针

00:41:00.890 --> 00:41:04.930
抓住机会错过小姐

00:41:02.960 --> 00:41:08.120
并让您的处理器坐在那里

00:41:04.930 --> 00:41:10.790
等待数十万个周期

00:41:08.120 --> 00:41:12.910
缓慢的pokey记忆系统返回

00:41:10.790 --> 00:41:14.840
一些数据

00:41:12.910 --> 00:41:17.780
关于对象的另一件事是

00:41:14.840 --> 00:41:19.610
每个明显的物体都很重

00:41:17.780 --> 00:41:22.090
对象具有具有标识的效果

00:41:19.610 --> 00:41:25.310
您可以在任何对象上同步

00:41:22.090 --> 00:41:27.560
人们这样做我知道你已经知道

00:41:25.310 --> 00:41:29.450
工业应用在哪里

00:41:27.560 --> 00:41:33.170
人们在弦上同步

00:41:29.450 --> 00:41:34.940
常数Y资本y并且他们有

00:41:33.170 --> 00:41:38.890
这些字符串常数Y的兆亿

00:41:34.940 --> 00:41:38.890
他们真的在同步他们

00:41:39.430 --> 00:41:42.680
无论如何，所以这真的很痛苦

00:41:41.450 --> 00:41:44.210
特别是当您处理

00:41:42.680 --> 00:41:44.770
您可能会在其中存储大量数据

00:41:44.210 --> 00:41:46.360
机

00:41:44.770 --> 00:41:49.990
你正在尝试做形象

00:41:46.360 --> 00:41:51.910
处理之类的，所以我们正在尝试

00:41:49.990 --> 00:41:54.730
解决这个问题，我们认为

00:41:51.910 --> 00:41:56.710
缺少抽象是价值

00:41:54.730 --> 00:41:59.110
 Java中的类型无法声明

00:41:56.710 --> 00:42:01.150
我确定我是一个纯粹的数据聚合器

00:41:59.110 --> 00:42:02.680
显示您的记录是纯记录

00:42:01.150 --> 00:42:05.110
从某种意义上讲，但他们仍然被

00:42:02.680 --> 00:42:07.630
正确的对象是我们想要的一种方法

00:42:05.110 --> 00:42:10.150
说这是这件事，是

00:42:07.630 --> 00:42:11.560
只是数据，就没有状态

00:42:10.150 --> 00:42:13.120
它永远不会改变，不需要

00:42:11.560 --> 00:42:14.380
你永远不会同步它

00:42:13.120 --> 00:42:15.820
如果您不需要在堆中

00:42:14.380 --> 00:42:18.760
可以分配它并为其注册

00:42:15.820 --> 00:42:19.810
整个一生都在做，现在我们

00:42:18.760 --> 00:42:21.640
我们不能那样做

00:42:19.810 --> 00:42:23.680
就像约翰·罗斯（John Rose）喜欢说如果我们这样做

00:42:21.640 --> 00:42:25.300
对你，你将能够

00:42:23.680 --> 00:42:28.180
像一个类一样编码，但它将像

00:42:25.300 --> 00:42:32.260
一个整数，那就是我们所在的地方

00:42:28.180 --> 00:42:40.150
尝试和瓦尔哈拉一起去让我们切换

00:42:32.260 --> 00:42:42.420
到Baja演示这里是版本

00:42:40.150 --> 00:42:45.460
那是正确的

00:42:42.420 --> 00:42:50.830
再一次让我们看一些代码

00:42:45.460 --> 00:42:53.380
这里复数有点像点

00:42:50.830 --> 00:42:55.540
同样的想法对，这可能很好

00:42:53.380 --> 00:42:57.220
被记录在将来的版本中

00:42:55.540 --> 00:43:00.100
你有真实的公共课堂复合体

00:42:57.220 --> 00:43:04.890
想象中你有一个构造函数

00:43:00.100 --> 00:43:04.890
你有访问者，你有

00:43:05.460 --> 00:43:11.140
如果可以的话，添加倍数

00:43:09.850 --> 00:43:15.460
基准模式，您有复数

00:43:11.140 --> 00:43:17.970
你怎样对他们进行基准测试

00:43:15.460 --> 00:43:22.300
乘矩阵当然是

00:43:17.970 --> 00:43:24.010
完全自然的操作，所以我们

00:43:22.300 --> 00:43:25.990
要在这里做一些矩阵乘法

00:43:24.010 --> 00:43:28.360
我已经说过将它设置为

00:43:25.990 --> 00:43:30.580
使用Lexi船的基准生活非常

00:43:28.360 --> 00:43:32.440
在微基准测试线束上做得很好

00:43:30.580 --> 00:43:37.170
这里有一些注释

00:43:32.440 --> 00:43:39.670
它如何运行我们有两个复杂

00:43:37.170 --> 00:43:42.580
表示为数组数组的矩阵

00:43:39.670 --> 00:43:45.700
复杂对象的填充

00:43:42.580 --> 00:43:48.310
一些我们设定事物的随机数

00:43:45.700 --> 00:43:50.320
然后我们当然有他们

00:43:48.310 --> 00:43:52.000
矩阵乘法本身的标准

00:43:50.320 --> 00:43:53.710
的三次算法沃克穿越

00:43:52.000 --> 00:43:55.480
一个矩阵列的行另一列

00:43:53.710 --> 00:43:59.360
明智的

00:43:55.480 --> 00:44:09.260
应用程序和总和和繁荣你会得到一个

00:43:59.360 --> 00:44:13.250
结果好吧，让我们运行它甚至可以混合

00:44:09.260 --> 00:44:14.810
另一个客人的样子还可以，所以我

00:44:13.250 --> 00:44:17.720
要做三三个热身

00:44:14.810 --> 00:44:19.780
预热，然后再预热

00:44:17.720 --> 00:44:24.140
一些实际的测试运行，这正在

00:44:19.780 --> 00:44:29.480
每个矩阵约四秒钟

00:44:24.140 --> 00:44:31.660
而且我的笔记本电脑没有蠕虫或

00:44:29.480 --> 00:44:39.770
真的很努力

00:44:31.660 --> 00:44:41.780
迭代一是的大约四

00:44:39.770 --> 00:44:44.470
每个矩阵的秒数乘以

00:44:41.780 --> 00:44:46.880
在GC alec率标准下，这是多少

00:44:44.470 --> 00:44:49.850
 Alec正在分配多少内存

00:44:46.880 --> 00:44:52.310
每个乘法，几乎

00:44:49.850 --> 00:44:57.080
四兆字节乘以一对

00:44:52.310 --> 00:45:01.880
 500 x 500矩阵，那不是

00:44:57.080 --> 00:45:05.710
非常令人印象深刻的是

00:45:01.880 --> 00:45:08.750
小毛茸茸的让我们看看它和Emax 

00:45:05.710 --> 00:45:10.430
好吧，今天早上我们有Alexi pay 

00:45:08.750 --> 00:45:13.790
注意那个建议非常好

00:45:10.430 --> 00:45:17.660
建议乘以几乎四

00:45:13.790 --> 00:45:21.490
我们每圈标记秒数

00:45:17.660 --> 00:45:24.320
我们分配了大约四个

00:45:21.490 --> 00:45:25.730
每个千兆字节然后另一个

00:45:24.320 --> 00:45:28.070
这里所有的有趣指标

00:45:25.730 --> 00:45:31.010
重点是每个周期的指令

00:45:28.070 --> 00:45:32.930
所以这台笔记本电脑的处理器是

00:45:31.010 --> 00:45:34.420
问我问，直到Skylake处理器

00:45:32.930 --> 00:45:37.070
它有能力退休四个

00:45:34.420 --> 00:45:39.710
每个CPU周期的指令是

00:45:37.070 --> 00:45:41.630
退休我几乎不止一个

00:45:39.710 --> 00:45:43.700
就是这个数字告诉我们

00:45:41.630 --> 00:45:45.260
处理器通常只是坐着

00:45:43.700 --> 00:45:46.880
左右摇动拇指等待

00:45:45.260 --> 00:45:49.850
内存系统，因为它正在追逐

00:45:46.880 --> 00:45:51.650
来自那些数组的指针

00:45:49.850 --> 00:45:53.000
和所有复杂的矩阵

00:45:51.650 --> 00:45:54.350
数字对象，当然我必须

00:45:53.000 --> 00:45:56.270
分配一堆复数

00:45:54.350 --> 00:45:57.800
对象，因为每个复数都是

00:45:56.270 --> 00:45:59.570
一个对象，因为它是面向对象的

00:45:57.800 --> 00:46:02.210
一切都很好，不是

00:45:59.570 --> 00:46:05.690
就像我们现在看到的那样

00:46:02.210 --> 00:46:07.580
我要做的是进入这个综合体

00:46:05.690 --> 00:46:08.840
课，我要添加一个关键词

00:46:07.580 --> 00:46:13.070
我们

00:46:08.840 --> 00:46:15.650
我将把它作为一个价值类

00:46:13.070 --> 00:46:20.860
看起来像一堂课，但更像

00:46:15.650 --> 00:46:20.860
一个int，让我们再次运行基准

00:46:22.660 --> 00:46:33.050
他们重新编译它，因为我改变了

00:46:25.010 --> 00:46:37.430
来源，尽管我们做一些热身

00:46:33.050 --> 00:46:41.770
每次操作需要366毫秒

00:46:37.430 --> 00:46:41.770
那是相当快的酷我

00:46:42.370 --> 00:46:46.280
这是六个星期前的演讲，当时

00:46:44.660 --> 00:46:48.080
比那快，所以艾米就像

00:46:46.280 --> 00:46:51.290
这是它的实时原型代码

00:46:48.080 --> 00:46:53.870
每天，我们只分配

00:46:51.290 --> 00:46:55.700
四兆字节而不是千兆字节

00:46:53.870 --> 00:46:57.950
矩阵乘以兆字节是因为

00:46:55.700 --> 00:47:00.200
我们是唯一正在发生的分配是

00:46:57.950 --> 00:47:01.370
对于结果矩阵，我们不是

00:47:00.200 --> 00:47:04.640
不得不分配一堆

00:47:01.370 --> 00:47:07.460
中间复数对象为

00:47:04.640 --> 00:47:11.120
我们走了，让我们回到Emacs 

00:47:07.460 --> 00:47:18.520
比较，我将旧数字放在

00:47:11.120 --> 00:47:21.380
顶部并在底部加载

00:47:18.520 --> 00:47:26.660
好的底部338个新结果

00:47:21.380 --> 00:47:28.550
如果执行一次操作，则每个操作的毫秒数

00:47:26.660 --> 00:47:30.620
小小的快速划分就是这样

00:47:28.550 --> 00:47:33.290
比其他快11倍

00:47:30.620 --> 00:47:37.190
版本分配的少很多

00:47:33.290 --> 00:47:38.810
和每个周期的退役说明

00:47:37.190 --> 00:47:41.900
差不多三个，所以做得更好

00:47:38.810 --> 00:47:43.490
使用您知道的四个处理器

00:47:41.900 --> 00:47:45.380
几乎可以做到的理想

00:47:43.490 --> 00:47:50.270
三当然比

00:47:45.380 --> 00:47:52.340
几乎不止一个，所以很快

00:47:50.270 --> 00:47:54.830
看瓦尔哈拉和价值类，甚至

00:47:52.340 --> 00:47:57.380
一旦瓦尔哈拉完成，即使你从来没有

00:47:54.830 --> 00:47:59.270
使用它，您会从中受益，因为

00:47:57.380 --> 00:48:01.400
瓦尔哈拉将使写作的人

00:47:59.270 --> 00:48:02.780
图书馆不只是像

00:48:01.400 --> 00:48:04.760
 JDK中的库，但是您

00:48:02.780 --> 00:48:06.710
人们到处写库

00:48:04.760 --> 00:48:08.540
重做它们的数据结构以使它们

00:48:06.710 --> 00:48:11.270
效率更高，所以每个人都会

00:48:08.540 --> 00:48:17.110
受益，即使不是每个人都使用它

00:48:11.270 --> 00:48:20.210
好吧，那是瓦尔哈拉

00:48:17.110 --> 00:48:22.100
琥珀色的织机Panama Mahalo这是一个

00:48:20.210 --> 00:48:25.640
 Java真正令人兴奋的时刻

00:48:22.100 --> 00:48:27.560
我们的rnd管道比它丰富

00:48:25.640 --> 00:48:29.180
你已经有很多年了

00:48:27.560 --> 00:48:31.640
以lambda开头，以

00:48:29.180 --> 00:48:33.590
与拼图一起，现在与这些

00:48:31.640 --> 00:48:35.390
项目前途一片光明

00:48:33.590 --> 00:48:37.730
在这里，我希望你会

00:48:35.390 --> 00:48:41.120
看看一些抢先体验

00:48:37.730 --> 00:48:42.740
发布给我们反馈和帮助

00:48:41.120 --> 00:48:44.630
如果您愿意，我们可以帮助我们推动Java向前发展

00:48:42.740 --> 00:48:47.990
喜欢看一下抢先体验

00:48:44.630 --> 00:48:52.550
东西都在JDK java.net上了

00:48:47.990 --> 00:48:54.470
我们有EA为巴拿马建造了4:13的EA 

00:48:52.550 --> 00:48:56.390
瓦尔哈拉（Valhalla）首先要做其他事情

00:48:54.470 --> 00:48:59.390
有人告诉我会早

00:48:56.390 --> 00:49:02.540
可能在

00:48:59.390 --> 00:49:04.970
下个月也许一个月或两个月

00:49:02.540 --> 00:49:07.040
还剩两分钟

00:49:04.970 --> 00:49:09.680
问题，否则你可以抓住我

00:49:07.040 --> 00:49:10.970
甲骨文展位之后或之后

00:49:09.680 --> 00:49:18.170
每当我今天在这里和

00:49:10.970 --> 00:49:20.500
明天是先生三年

00:49:18.170 --> 00:49:25.270
支持版本每三年发布一次

00:49:20.500 --> 00:49:25.270
先生，还有其他问题要问

00:49:26.560 --> 00:49:30.530
是的，值和记录将起作用

00:49:28.609 --> 00:49:36.050
一起您将能够输入值

00:49:30.530 --> 00:49:45.170
记录复杂的真实虚构就可以了

00:49:36.050 --> 00:49:47.740
一分钟的比赛即将结束，先生， 

00:49:45.170 --> 00:49:51.260
对不起，我听不到您的未来

00:49:47.740 --> 00:49:52.849
线程的未来以及未来如何

00:49:51.260 --> 00:49:54.440
类路径，否则我们将永远

00:49:52.849 --> 00:49:56.650
拿起拿走它当然不会

00:49:54.440 --> 00:49:59.510
没有线程，他们将永远在那里

00:49:56.650 --> 00:50:00.920
但是你知道我认为我们会逐渐

00:49:59.510 --> 00:50:02.810
鼓励人们从他们那里迁移

00:50:00.920 --> 00:50:04.550
会有一些大的表现

00:50:02.810 --> 00:50:07.160
通过经历获得的好处

00:50:04.550 --> 00:50:09.829
迁移工作，所以您知道

00:50:07.160 --> 00:50:11.660
希望将来人们不会

00:50:09.829 --> 00:50:13.700
默认情况下通过

00:50:11.660 --> 00:50:15.770
用纤维猎户座的方式

00:50:13.700 --> 00:50:19.160
计算模型对这些的需求

00:50:15.770 --> 00:50:21.260
复杂的反应式框架

00:50:19.160 --> 00:50:22.609
离开，所以这里的小屏幕是

00:50:21.260 --> 00:50:22.970
告诉你时间到了，非常感谢

00:50:22.609 --> 00:50:29.510
许多

00:50:22.970 --> 00:50:29.690
哦，还有，我什么都不相信

00:50:29.510 --> 00:50:33.219
说过

00:50:29.690 --> 00:50:33.219
 [掌声] 

00:50:34.470 --> 00:50:39.619
 [音乐] 

