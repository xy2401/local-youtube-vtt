WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.240 --> 00:00:03.750
所以现在您的代码正在执行，但是

00:00:01.920 --> 00:00:06.359
没有所有的框架

00:00:03.750 --> 00:00:09.090
堆栈上的颜色会产生

00:00:06.359 --> 00:00:12.530
回到C方法，他将

00:00:09.090 --> 00:00:16.680
运行，假设C现在想返回

00:00:12.530 --> 00:00:19.199
 C的呼叫者是谁C的呼叫者是B但

00:00:16.680 --> 00:00:22.220
它不在套接字中，但是当C返回时

00:00:19.199 --> 00:00:24.689
将会达到回报壁垒， 

00:00:22.220 --> 00:00:28.349
那个返回障碍会叫锯

00:00:24.689 --> 00:00:33.239
再次，这将复制下一个

00:00:28.349 --> 00:00:35.460
框架并完成整个操作

00:00:33.239 --> 00:00:38.670
再次将变成B 

00:00:35.460 --> 00:00:40.170
再次安装回流挡板，但是

00:00:38.670 --> 00:00:41.670
那么B可能不想要

00:00:40.170 --> 00:00:43.590
回到一个说可能是一个

00:00:41.670 --> 00:00:47.879
一百种方法，而你只是

00:00:43.590 --> 00:00:49.950
在最上面的几帧循环播放，因此B 

00:00:47.879 --> 00:00:53.120
会打电话给我们，假设D和D是

00:00:49.950 --> 00:00:58.379
要屈服，所以我们只有那些

00:00:53.120 --> 00:01:00.930
这些框架要复制，因此

00:00:58.379 --> 00:01:03.239
现在的操作是线性的，并且数量

00:01:00.930 --> 00:01:04.799
您上次使用的堆栈数量

00:01:03.239 --> 00:01:09.150
您已经继续，所以基本上

00:01:04.799 --> 00:01:10.710
开销是恒定的，这个问题

00:01:09.150 --> 00:01:14.250
是我们是否可以使其快速发展

00:01:10.710 --> 00:01:16.970
足够，所以实际上整个复制

00:01:14.250 --> 00:01:16.970
事情很快

00:01:17.210 --> 00:01:23.880
你几乎不知道那是什么

00:01:21.030 --> 00:01:26.430
担心我们付出的代价是正确的

00:01:23.880 --> 00:01:27.869
现在实际上是

00:01:26.430 --> 00:01:29.159
走帧，那就是

00:01:27.869 --> 00:01:31.650
我们正在努力做的事情

00:01:29.159 --> 00:01:33.990
更快，但更有趣的是

00:01:31.650 --> 00:01:35.610
提取循环查找结果

00:01:33.990 --> 00:01:38.970
引用和堆栈并提取

00:01:35.610 --> 00:01:41.520
他们，这是有关的东西

00:01:38.970 --> 00:01:43.920
来自Sock'em办公室的

00:01:41.520 --> 00:01:46.439
尝试通过产生更快的速度

00:01:43.920 --> 00:01:49.369
一些本地代码而不是生成

00:01:46.439 --> 00:01:53.009
机器代码而不是坐在座位上

00:01:49.369 --> 00:01:57.780
退路是如果我们无法做到这一点

00:01:53.009 --> 00:02:00.240
足够快是要更改编译器

00:01:57.780 --> 00:02:01.439
以及编译器发出代码的方式

00:02:00.240 --> 00:02:05.250
那可能是很多

00:02:01.439 --> 00:02:07.890
工作，我们正在努力使它工作

00:02:05.250 --> 00:02:11.060
首先，然后使其快速

00:02:07.890 --> 00:02:14.000
现在我想我们认为

00:02:11.060 --> 00:02:21.290
我们可以使它和我们一样快

00:02:14.000 --> 00:02:23.390
需要这张幻灯片给你看

00:02:21.290 --> 00:02:25.190
最后一个系列说的东西

00:02:23.390 --> 00:02:27.560
将需要进行改造

00:02:25.190 --> 00:02:29.180
或I / O，所以当您执行任何I / O时

00:02:27.560 --> 00:02:33.200
操作将需要不知道

00:02:29.180 --> 00:02:35.209
调用所有阻塞的I / O操作

00:02:33.200 --> 00:02:37.820
 YouTube同意这份工作，如果您

00:02:35.209 --> 00:02:40.610
锁定，并且您必须处于光纤内部

00:02:37.820 --> 00:02:44.930
阻止纤维而不是底层

00:02:40.610 --> 00:02:47.800
内核线程，我也提到了我

00:02:44.930 --> 00:02:53.630
我想也有人问过这个

00:02:47.800 --> 00:02:57.770
还提到如果您运行线程

00:02:53.630 --> 00:03:01.580
大多数时候在操作系统中

00:02:57.770 --> 00:03:03.230
操作系统的方式

00:03:01.580 --> 00:03:04.910
去D安排线程并运行

00:03:03.230 --> 00:03:07.130
当您在同一CPU中的另一个线程

00:03:04.910 --> 00:03:10.190
实际上阻​​止了一个正常的I / O 

00:03:07.130 --> 00:03:12.170
情况下，但偶尔你有一个线程

00:03:10.190 --> 00:03:16.670
那只是做大量的计算

00:03:12.170 --> 00:03:19.250
在很长一段时间内

00:03:16.670 --> 00:03:21.440
当操作系统将要

00:03:19.250 --> 00:03:24.500
抢占它并说运行了足够长的时间

00:03:21.440 --> 00:03:27.110
让别人跑去看我

00:03:24.500 --> 00:03:30.700
认为有人问我们是否可以

00:03:27.110 --> 00:03:32.989
用纤维做，他们说也许

00:03:30.700 --> 00:03:37.580
如果我们这样做，我们可以依靠

00:03:32.989 --> 00:03:40.970
安全点机制，实际上我们

00:03:37.580 --> 00:03:43.160
最终只是说我们不是

00:03:40.970 --> 00:03:45.560
完全确定我们是否

00:03:43.160 --> 00:03:49.790
实际上会需要它，原因是

00:03:45.560 --> 00:03:54.560
如果你有八个

00:03:49.790 --> 00:03:57.140
核心，并说20个线程和一些

00:03:54.560 --> 00:04:00.260
做IO，其中一些做很多CP 

00:03:57.140 --> 00:04:01.489
大量的CPU操作肯定是

00:04:00.260 --> 00:04:03.799
其中一些人可能需要

00:04:01.489 --> 00:04:05.690
被抢占，因为他们也占用

00:04:03.799 --> 00:04:09.160
很多CPU，但是如果您有一百万

00:04:05.690 --> 00:04:11.510
这些线程，说一千

00:04:09.160 --> 00:04:14.420
使用太多的CPU，您需要

00:04:11.510 --> 00:04:16.310
强行抢占他们，那么你就是

00:04:14.420 --> 00:04:19.849
供应不足，我的意思是没有

00:04:16.310 --> 00:04:23.490
任何类型的调度都可以帮助您

00:04:19.849 --> 00:04:24.960
所以这不像你有那么多

00:04:23.490 --> 00:04:27.500
他们都非常需要的线程

00:04:24.960 --> 00:04:30.000
需要抢占的CPU 

00:04:27.500 --> 00:04:31.650
然后你用任何一种方式拧

00:04:30.000 --> 00:04:37.440
但是我们决定添加这个的原因

00:04:31.650 --> 00:04:38.940
无论如何，有些人可能会

00:04:37.440 --> 00:04:41.550
他们可能想做的是不要尝试

00:04:38.940 --> 00:04:47.569
通过安排光纤解决问题

00:04:41.550 --> 00:04:50.970
聪明地但是如果他们看到纤维

00:04:47.569 --> 00:04:52.979
他们会说占用过多的CPU 

00:04:50.970 --> 00:04:57.599
光纤行为异常，他们想

00:04:52.979 --> 00:05:00.990
脱掉它，也许运行它，你知道

00:04:57.599 --> 00:05:05.400
一小时后，当有更多房间时

00:05:00.990 --> 00:05:07.860
在机器上，这就是我们所拥有的

00:05:05.400 --> 00:05:10.080
现在我告诉你我们参与了

00:05:07.860 --> 00:05:12.960
在原型中，我们有nessa 

00:05:10.080 --> 00:05:16.550
继续，我会告诉你什么零食

00:05:12.960 --> 00:05:18.240
走路是我们现在没有的东西

00:05:16.550 --> 00:05:22.949
延续性很低

00:05:18.240 --> 00:05:25.139
机制有些语言的人

00:05:22.949 --> 00:05:27.030
直接使用延续，所以他们有

00:05:25.139 --> 00:05:29.880
像更高层次的抽象

00:05:27.030 --> 00:05:32.159
允许您从运行中传递值

00:05:29.880 --> 00:05:33.449
指向屈服点，所以下一个

00:05:32.159 --> 00:05:35.969
当你继续延续时

00:05:33.449 --> 00:05:37.409
可以在参数中传递它，这就是

00:05:35.969 --> 00:05:39.360
将要从中返回的参数

00:05:37.409 --> 00:05:41.219
产生它很容易实现

00:05:39.360 --> 00:05:44.009
 Java是我们拥有的延续

00:05:41.219 --> 00:05:47.279
只是我们还没有做到

00:05:44.009 --> 00:05:50.250
能够克隆延续

00:05:47.279 --> 00:05:53.370
延续记得自己的回忆

00:05:50.250 --> 00:05:55.259
当前状态和下次运行

00:05:53.370 --> 00:05:56.729
它可以记住它的当前状态

00:05:55.259 --> 00:05:58.560
说明它放到一边

00:05:56.729 --> 00:06:02.219
下次您运行它时， 

00:05:58.560 --> 00:06:03.870
声明正确，但在某些情况下您

00:06:02.219 --> 00:06:07.110
想回到过去并运行相同的

00:06:03.870 --> 00:06:09.659
从同一点再次计算

00:06:07.110 --> 00:06:11.219
你可以做的就是克隆它

00:06:09.659 --> 00:06:14.250
如果克隆延续，则可以

00:06:11.219 --> 00:06:16.380
连续多次序列化

00:06:14.250 --> 00:06:18.440
是我们另一个非常有趣的事情

00:06:16.380 --> 00:06:20.370
都还没有开始工作

00:06:18.440 --> 00:06:21.990
所以您可能想阻止

00:06:20.370 --> 00:06:24.960
继续做延续

00:06:21.990 --> 00:06:26.849
也许在另一台机器上继续

00:06:24.960 --> 00:06:29.849
序列化到磁盘，然后继续

00:06:26.849 --> 00:06:31.440
从现在开始一个月，一个严重的

00:06:29.849 --> 00:06:33.159
我现在提到的限制是

00:06:31.440 --> 00:06:37.479
如果你有一个八

00:06:33.159 --> 00:06:39.759
框架在堆栈上的延续是

00:06:37.479 --> 00:06:41.740
固定它不能产生可能是

00:06:39.759 --> 00:06:43.930
将永远停留，但潮流

00:06:41.740 --> 00:06:46.240
我们的限制是你也是

00:06:43.930 --> 00:06:48.969
固定，如果当前是延续

00:06:46.240 --> 00:06:50.800
抱着一个本机监视器，所以如果你是

00:06:48.969 --> 00:06:54.909
当前在同步方法中

00:06:50.800 --> 00:06:56.830
或同步块，您尝试

00:06:54.909 --> 00:06:58.900
当你在里面的时候屈服

00:06:56.830 --> 00:07:04.509
同步块，您将被固定为

00:06:58.900 --> 00:07:08.319
并发锁工作很好，但是

00:07:04.509 --> 00:07:11.199
本机监视器将固定您，那就是

00:07:08.319 --> 00:07:15.279
我们可能想要的限制

00:07:11.199 --> 00:07:18.580
摆脱以后，所以或多或少

00:07:15.279 --> 00:07:22.240
 API我们现在拥有的API 

00:07:18.580 --> 00:07:24.879
您的前几种方法

00:07:22.240 --> 00:07:26.139
开始，我们有一些东西要让

00:07:24.879 --> 00:07:28.900
你走栈时

00:07:26.139 --> 00:07:32.409
连续被卸载，这是

00:07:28.900 --> 00:07:34.719
可以尝试的强制抢先

00:07:32.409 --> 00:07:38.349
询问正在运行的延续

00:07:34.719 --> 00:07:40.539
不同的线程请让自己

00:07:38.349 --> 00:07:44.319
而工作方式是在热点内

00:07:40.539 --> 00:07:47.740
我们有一个线程本地握手

00:07:44.319 --> 00:07:50.560
基本上需要一个小封闭，然后问

00:07:47.740 --> 00:07:54.399
 VM在下一次运行该关闭

00:07:50.560 --> 00:07:55.839
安全点，如果我们下次再这样做

00:07:54.399 --> 00:07:58.149
安全点，将其称为

00:07:55.839 --> 00:08:00.250
当然它可能不会成功，因为也许

00:07:58.149 --> 00:08:03.599
您已固定，因此您可能需要尝试

00:08:00.250 --> 00:08:06.430
到目前为止还好几次

00:08:03.599 --> 00:08:08.169
继续任何问题，然后

00:08:06.430 --> 00:08:09.819
那是主要的，所以只有延续

00:08:08.169 --> 00:08:13.509
在VM中实现

00:08:09.819 --> 00:08:15.099
主要部分，现在我将展示如何

00:08:13.509 --> 00:08:20.099
纤维是工具停止，但任何

00:08:15.099 --> 00:08:20.099
到目前为止的问题还可以

00:08:20.169 --> 00:08:23.790
一旦有了延续，就可以

00:08:21.940 --> 00:08:28.690
在它们之上构建轻量级线程

00:08:23.790 --> 00:08:30.580
那么什么是线程线程需要一个

00:08:28.690 --> 00:08:33.099
延续，这是一段代码

00:08:30.580 --> 00:08:35.500
可以停止并在以后恢复

00:08:33.099 --> 00:08:37.150
时间点和一个调度程序是

00:08:35.500 --> 00:08:39.669
需要很多这样的东西

00:08:37.150 --> 00:08:44.770
继续并决定何时运行

00:08:39.669 --> 00:08:46.390
他们每个人都这样一个线程可以说我

00:08:44.770 --> 00:08:50.020
准备运行或现在我要阻止

00:08:46.390 --> 00:08:51.790
请让我离开CPU，它可以

00:08:50.020 --> 00:08:53.200
现在收到信号，我已经准备好运行了

00:08:51.790 --> 00:08:54.430
必须告诉调度程序我已经准备好

00:08:53.200 --> 00:08:56.140
运行，当调度程序找到

00:08:54.430 --> 00:08:57.640
在正确的时间将其分配给CPU，因此

00:08:56.140 --> 00:08:59.740
基本上这是相同的方式

00:08:57.640 --> 00:09:02.770
在内核中，任何类型的线程都是

00:08:59.740 --> 00:09:06.720
实际上，线程具有延续性， 

00:09:02.770 --> 00:09:08.980
它有一个调度程序，所以当我们这样做

00:09:06.720 --> 00:09:11.410
轻量级线程和运行时光纤

00:09:08.980 --> 00:09:14.709
我们以相同的方式继续

00:09:11.410 --> 00:09:18.610
虚拟机和

00:09:14.709 --> 00:09:20.020
调度程序，我们使用任何Java执行程序

00:09:18.610 --> 00:09:22.300
默认我们使用fork / join池

00:09:20.020 --> 00:09:26.529
因为它非常适合这种情况

00:09:22.300 --> 00:09:28.690
工作量，因此每根光纤都有一个

00:09:26.529 --> 00:09:31.270
只是调度程序中的延续

00:09:28.690 --> 00:09:34.300
两者相关，所以如果您知道Java芯片

00:09:31.270 --> 00:09:39.790
并发，我希望你们大多数人都这样做， 

00:09:34.300 --> 00:09:42.279
您尝试获取锁，或者有一个

00:09:39.790 --> 00:09:45.250
移相器或所有旧版Java le流

00:09:42.279 --> 00:09:47.080
当前的课程，由于某种原因

00:09:45.250 --> 00:09:49.570
锁不可用，由它持有

00:09:47.080 --> 00:09:53.980
别人，现在你需要阻止

00:09:49.570 --> 00:09:55.720
就是阻塞操作

00:09:53.980 --> 00:09:57.850
当前阻止当前内核

00:09:55.720 --> 00:09:59.820
线程，我们想要它，以便如果您

00:09:57.850 --> 00:10:02.770
在光纤中只会阻塞光纤

00:09:59.820 --> 00:10:06.850
所以所有的Java代码直到

00:10:02.770 --> 00:10:09.850
阻塞内核线程的并发

00:10:06.850 --> 00:10:12.010
今天通过这种方法Java 

00:10:09.850 --> 00:10:16.029
并发锁锁支持园区

00:10:12.010 --> 00:10:17.140
那是方法，所以这不是太

00:10:16.029 --> 00:10:18.580
与我们的代码不同

00:10:17.140 --> 00:10:21.000
今天的原型只占了一些位

00:10:18.580 --> 00:10:23.620
关于你知道簿记有一个

00:10:21.000 --> 00:10:27.370
封锁者的电话，我们跟踪谁

00:10:23.620 --> 00:10:30.670
想阻止你，但基本上

00:10:27.370 --> 00:10:32.920
我们首先要问我们是否

00:10:30.670 --> 00:10:33.730
我们问我们是否在平凡中跑步

00:10:32.920 --> 00:10:40.269
线

00:10:33.730 --> 00:10:42.699
或者我们有或者我们在纤维内部，所以我们

00:10:40.269 --> 00:10:44.859
称这个概念为一股股线

00:10:42.699 --> 00:10:47.350
是内核线程还是lightwei 

00:10:44.859 --> 00:10:51.549
光纤上的线我谈到了

00:10:47.350 --> 00:10:54.009
去年以来，我说他们

00:10:51.549 --> 00:10:56.980
也许我们会为它添加一个超级类型

00:10:54.009 --> 00:10:58.989
线和纤维称为股线我们

00:10:56.980 --> 00:11:01.299
在我们早期的原型中

00:10:58.989 --> 00:11:04.269
出来，因为几乎没有

00:11:01.299 --> 00:11:07.029
在一堆里做，所以现在

00:11:04.269 --> 00:11:10.119
基本上只是一个对象，但我会

00:11:07.029 --> 00:11:13.149
进行一些设计，如果它

00:11:10.119 --> 00:11:15.579
是我们称为不安全锁Park的线程

00:11:13.149 --> 00:11:18.730
要求内核挂起

00:11:15.579 --> 00:11:22.929
当前线程，但如果是光纤，则

00:11:18.730 --> 00:11:25.179
只是产生纤维的延续，所以

00:11:22.929 --> 00:11:27.339
这就是朴会说的

00:11:25.179 --> 00:11:29.350
如果您无法获得锁，它将只是

00:11:27.339 --> 00:11:33.119
被翻译成连续产量

00:11:29.350 --> 00:11:36.189
在纤维上的纤维延续

00:11:33.119 --> 00:11:38.319
如果您已经持有锁

00:11:36.189 --> 00:11:43.049
现在您想释放它

00:11:38.319 --> 00:11:46.059
是否有一个队列列表

00:11:43.049 --> 00:11:47.829
线程正在等待，你把

00:11:46.059 --> 00:11:50.049
第一个，你叫醒他们，这个

00:11:47.829 --> 00:11:53.319
用Java完成总是需要电流

00:11:50.049 --> 00:11:56.230
通过这种方法在公园，如果是

00:11:53.319 --> 00:11:58.389
一个线程，它将去不安全并询问

00:11:56.230 --> 00:12:00.819
内核为您做到这一点，但如果它

00:11:58.389 --> 00:12:03.459
是一种纤维，它将带走纤维

00:12:00.819 --> 00:12:07.059
调度程序，它只是要提交

00:12:03.459 --> 00:12:09.600
光纤连续，因此调度程序

00:12:07.059 --> 00:12:11.739
将要提交任务， 

00:12:09.600 --> 00:12:12.999
当调度程序处理它时

00:12:11.739 --> 00:12:14.919
它要运行该任务，并且

00:12:12.999 --> 00:12:18.039
要在任务上调用run方法

00:12:14.919 --> 00:12:20.230
但为了继续运行，从

00:12:18.039 --> 00:12:22.209
屈服点，所以这给你

00:12:20.230 --> 00:12:23.350
完全相同的行为正在阻止

00:12:22.209 --> 00:12:24.939
你将从上一个继续

00:12:23.350 --> 00:12:29.559
从您阻止的点开始

00:12:24.939 --> 00:12:32.559
这就是纤维和延续

00:12:29.559 --> 00:12:37.589
因此，将光纤作为调度程序和

00:12:32.559 --> 00:12:37.589
如此延续

00:12:37.790 --> 00:12:47.699
现在的纤维非常细

00:12:45.209 --> 00:12:52.980
最小的API，它也会像

00:12:47.699 --> 00:12:54.540
每周解释一下为什么，但是如果

00:12:52.980 --> 00:12:56.509
您想创建一个新的光纤

00:12:54.540 --> 00:12:58.860
你怎么做

00:12:56.509 --> 00:13:01.139
目前纤维可以返回结果

00:12:58.860 --> 00:13:05.100
不像线程，所以这就是你加入一个

00:13:01.139 --> 00:13:06.779
纤维，您将获得所有结果

00:13:05.100 --> 00:13:09.629
 javi库中的代码并发

00:13:06.779 --> 00:13:12.660
所有的I / O都进行了改装

00:13:09.629 --> 00:13:15.149
使用纤维一件事

00:13:12.660 --> 00:13:17.610
说他们是尼尼奥人之一

00:13:15.149 --> 00:13:19.800
改装后可与光纤配合使用一段时间

00:13:17.610 --> 00:13:22.829
以前，但是在

00:13:19.800 --> 00:13:26.129
最近几周是所有旧的

00:13:22.829 --> 00:13:27.809
 I / O旧网络挂api旧

00:13:26.129 --> 00:13:29.249
套接字API也进行了改进

00:13:27.809 --> 00:13:31.800
以现在完成的方式实际上是

00:13:29.249 --> 00:13:36.480
至少对我们来说很令人兴奋

00:13:31.800 --> 00:13:38.309
 VM的维护者是所有中提琴

00:13:36.480 --> 00:13:41.759
 I / O是20年的旧代码

00:13:38.309 --> 00:13:44.160
用C语言写的，艾伦做了什么

00:13:41.759 --> 00:13:47.490
确实实现了旧的I / O 

00:13:44.160 --> 00:13:50.490
 nao的顶部，因此现在已实现了旧的I / O 

00:13:47.490 --> 00:13:54.089
完全用Java，他成功了

00:13:50.490 --> 00:13:55.589
所有的测试也许仍然存在

00:13:54.089 --> 00:13:58.800
一些极端的情况，因为它很旧

00:13:55.589 --> 00:14:00.809
代码，所以我们期望

00:13:58.800 --> 00:14:02.730
版本或两个人将有

00:14:00.809 --> 00:14:05.519
使用旧C代码或

00:14:02.730 --> 00:14:08.100
旧I / O的新实现

00:14:05.519 --> 00:14:12.379
 Java，但最终C代码正在发展

00:14:08.100 --> 00:14:18.209
走开，它将只是Java 

00:14:12.379 --> 00:14:20.069
也容易将纤维与期货

00:14:18.209 --> 00:14:21.959
事情在这里，只是让您看到那种

00:14:20.069 --> 00:14:23.579
出现的困难以及何时

00:14:21.959 --> 00:14:31.559
你尝试像这样放一些新东西

00:14:23.579 --> 00:14:33.269
到旧的JDK中，您可以将光纤

00:14:31.559 --> 00:14:36.509
进入未来，但光纤不会

00:14:33.269 --> 00:14:37.850
实施未来的原因是因为

00:14:36.509 --> 00:14:40.309
未来有一些很有趣

00:14:37.850 --> 00:14:43.829
规范中定义的语义

00:14:40.309 --> 00:14:46.889
例如，如果你有未来，而你

00:14:43.829 --> 00:14:49.379
取消呼叫是原子的

00:14:46.889 --> 00:14:50.370
下次如果你问未来

00:14:49.379 --> 00:14:52.890
你完成了

00:14:50.370 --> 00:14:54.590
即使尚未完成执行

00:14:52.890 --> 00:14:58.410
但它会说是

00:14:54.590 --> 00:15:00.090
这是纤维期货的API，如果

00:14:58.410 --> 00:15:01.530
你想问你是否完成了

00:15:00.090 --> 00:15:03.740
真的想知道你是否被解雇了

00:15:01.530 --> 00:15:06.540
所以即使方法是一样的

00:15:03.740 --> 00:15:09.630
语义是不同的，所以

00:15:06.540 --> 00:15:11.430
纤维实现期货的方法

00:15:09.630 --> 00:15:14.220
我们可以要求将它们转换为

00:15:11.430 --> 00:15:16.440
未来我们会在

00:15:14.220 --> 00:15:19.830
调试器已经存在，因此您可以逐步完成

00:15:16.440 --> 00:15:21.810
纤维，你可以得到一个列表，看到一点

00:15:19.830 --> 00:15:24.030
看到纤维的清单，但这是

00:15:21.810 --> 00:15:26.790
另一个问题，所以你必须

00:15:24.030 --> 00:15:28.500
考虑调试和与线程不同

00:15:26.790 --> 00:15:30.300
你可能有几千

00:15:28.500 --> 00:15:31.710
他们这里可以有数百万

00:15:30.300 --> 00:15:34.530
显然只是发送清单

00:15:31.710 --> 00:15:36.600
到调试器的光纤正在运行

00:15:34.530 --> 00:15:39.240
花一点时间，所以你必须考虑如何

00:15:36.600 --> 00:15:40.980
做到这一点，所以也许只是某些纤维

00:15:39.240 --> 00:15:43.770
在您身上标记的可能只是

00:15:40.980 --> 00:15:47.550
您在其中设置了一个断点

00:15:43.770 --> 00:15:51.230
管理方面的东西

00:15:47.550 --> 00:15:54.300
和JFR，我们还没有开始

00:15:51.230 --> 00:15:58.170
我很as愧，我几乎没事了

00:15:54.300 --> 00:16:02.430
所以我要跳过那个

00:15:58.170 --> 00:16:07.260
我们所完成的工作的条件

00:16:02.430 --> 00:16:09.780
使它们轻巧

00:16:07.260 --> 00:16:12.570
 Java有2 KB的元数据， 

00:16:09.780 --> 00:16:15.510
默认情况下，一兆字节的堆栈用于

00:16:12.570 --> 00:16:17.660
纤维是两百三百

00:16:15.510 --> 00:16:20.610
元数据字节将下降

00:16:17.660 --> 00:16:22.230
栈随着您的成长而增长和缩小

00:16:20.610 --> 00:16:24.000
因为它在堆里，我们分配

00:16:22.230 --> 00:16:26.150
根据需要可以是几个字节

00:16:24.000 --> 00:16:28.320
几千字节，我几兆字节

00:16:26.150 --> 00:16:30.090
切换线程的任务是

00:16:28.320 --> 00:16:32.370
大约一到十微秒

00:16:30.090 --> 00:16:34.230
可能还会更多，我们仍在努力

00:16:32.370 --> 00:16:37.560
性能，所以我们不知道

00:16:34.230 --> 00:16:44.190
 SAS希望有光纤需求，但这是

00:16:37.560 --> 00:16:45.510
会大大小于

00:16:44.190 --> 00:16:52.100
五分钟好

00:16:45.510 --> 00:16:54.060
到目前为止，我的希望是你知道

00:16:52.100 --> 00:16:56.250
光纤只是实现

00:16:54.060 --> 00:16:58.200
线程让我们仅采用线程API 

00:16:56.250 --> 00:17:00.660
我们也许添加了一个新的构造函数

00:16:58.200 --> 00:17:03.300
是我的梦想，只是我不喜欢上来

00:17:00.660 --> 00:17:04.549
用新的api，所以我想

00:17:03.300 --> 00:17:07.740
 [音乐] 

00:17:04.549 --> 00:17:10.079
我们已经有一个线程的API，如果

00:17:07.740 --> 00:17:11.610
我们可以得到另一个构造函数

00:17:10.079 --> 00:17:13.679
对于可能需要调度程序的线程

00:17:11.610 --> 00:17:15.630
参数，然后得到光纤

00:17:13.679 --> 00:17:17.549
就是要做很多工作

00:17:15.630 --> 00:17:19.019
在VM中一些工作库，但在

00:17:17.549 --> 00:17:22.649
 API设计条款，我们将使用任何

00:17:19.019 --> 00:17:25.529
我们有，但随后我们与

00:17:22.649 --> 00:17:29.070
建筑师纪念约翰和布莱恩，他们

00:17:25.529 --> 00:17:32.669
说听你在和谁一起工作

00:17:29.070 --> 00:17:35.159
并发，20年后

00:17:32.669 --> 00:17:38.220
进行一些更改的好机会

00:17:35.159 --> 00:17:40.649
也许从头开始，所以这是

00:17:38.220 --> 00:17:42.059
我认为Java和

00:17:40.649 --> 00:17:45.269
也许其他语言其他语言

00:17:42.059 --> 00:17:48.659
想要获得许多用户，他们尝试

00:17:45.269 --> 00:17:51.840
获得吸引人的功能

00:17:48.659 --> 00:17:53.340
对我们来说，尽快知道我们已经

00:17:51.840 --> 00:17:54.269
已经存在很长时间了

00:17:53.340 --> 00:17:57.299
点，我们确定我们会成为

00:17:54.269 --> 00:17:59.639
周围很长一段时间，所以我们需要

00:17:57.299 --> 00:18:00.990
当我们做某事时，我们试图思考

00:17:59.639 --> 00:18:03.360
那是否正确

00:18:00.990 --> 00:18:04.470
接下来的20年，所以你说好

00:18:03.360 --> 00:18:06.960
您触及线程的概念

00:18:04.470 --> 00:18:08.610
也许尝试从零开始，看看

00:18:06.960 --> 00:18:10.529
他实际需要的是

00:18:08.610 --> 00:18:12.630
使用线程API的某些东西

00:18:10.529 --> 00:18:14.760
那里什么都没有，重新思考

00:18:12.630 --> 00:18:16.500
线程，所以我认为这可能

00:18:14.760 --> 00:18:18.330
以同样的事情结束，所以我没有

00:18:16.500 --> 00:18:21.149
真的知道会有什么结果

00:18:18.330 --> 00:18:23.880
但是不久之后，我遇到了一个博客

00:18:21.149 --> 00:18:26.429
帖子实际上是两个博客帖子

00:18:23.880 --> 00:18:28.049
其中一个是纳撒尼尔·J·史密斯（Nathaniel J Smith） 

00:18:26.429 --> 00:18:29.220
写关于Python的现场崇拜

00:18:28.049 --> 00:18:31.289
所谓的结构化

00:18:29.220 --> 00:18:33.419
并发他实际上并没有出现

00:18:31.289 --> 00:18:36.260
这个主意是他是

00:18:33.419 --> 00:18:39.360
归因于马丁酱招和

00:18:36.260 --> 00:18:43.370
当我至少阅读它时的结构是

00:18:39.360 --> 00:18:45.720
这些罕见的情况之一，当您

00:18:43.370 --> 00:18:47.970
阅读技术博客文章，您说

00:18:45.720 --> 00:18:50.909
是的，显然那是正确的

00:18:47.970 --> 00:18:52.679
做到这一点，这从来没有发生在我身上

00:18:50.909 --> 00:18:56.659
在我的职业生涯中很多次，但这是

00:18:52.679 --> 00:19:00.480
其中之一，我们过去了， 

00:18:56.659 --> 00:19:02.159
几乎每个人都喜欢它，所以

00:19:00.480 --> 00:19:05.309
结构化并发的思想是

00:19:02.159 --> 00:19:08.039
而不是采取线程而已

00:19:05.309 --> 00:19:10.500
启动它们并让它们运行

00:19:08.039 --> 00:19:14.940
只要他们想要我们完成， 

00:19:10.500 --> 00:19:16.049
他们的生活时间更紧密，所以我们有

00:19:14.940 --> 00:19:17.370
目前被称为

00:19:16.049 --> 00:19:18.570
光纤范围我们已经

00:19:17.370 --> 00:19:20.940
有延续范围，但我们有

00:19:18.570 --> 00:19:24.210
另一种范围，因此名称将

00:19:20.940 --> 00:19:26.760
可能会改变，所以您有一个范围， 

00:19:24.210 --> 00:19:28.590
尝试使用资源块和

00:19:26.760 --> 00:19:31.710
您在其中安排的纤维

00:19:28.590 --> 00:19:33.990
封锁，直到您不能离开封锁

00:19:31.710 --> 00:19:36.090
它们被终止，所以当您尝试

00:19:33.990 --> 00:19:38.400
因此，当您退出此街区时， 

00:19:36.090 --> 00:19:41.400
不管什么都调用close方法

00:19:38.400 --> 00:19:43.080
返回它将一​​直阻塞直到运气好

00:19:41.400 --> 00:19:45.180
当他们说不一定封锁

00:19:43.080 --> 00:19:47.280
上校内核线程，所以V 

00:19:45.180 --> 00:19:49.710
阻止，我们可以阻止纤维，但是

00:19:47.280 --> 00:19:52.920
阻塞直到所有的纤维在那里

00:19:49.710 --> 00:19:54.990
已经终止了，所以我们知道

00:19:52.920 --> 00:19:56.760
即使他们安排其他纤维

00:19:54.990 --> 00:20:00.120
整个纤维树都是

00:19:56.760 --> 00:20:04.559
当我们退出时将终止

00:20:00.120 --> 00:20:07.860
 esos范围，是的，您可以取消

00:20:04.559 --> 00:20:10.470
整个范围，如果它们是

00:20:07.860 --> 00:20:12.270
目前正在做眼科手术

00:20:10.470 --> 00:20:16.490
 I / O操作将返回， 

00:20:12.270 --> 00:20:19.620
以某种方式表明它已被取消

00:20:16.490 --> 00:20:21.120
这样可以做到，你可以做一些聪明的事

00:20:19.620 --> 00:20:22.710
例如，如果需要的话

00:20:21.120 --> 00:20:27.210
并行运行多件事

00:20:22.710 --> 00:20:30.300
只等第一个就开始

00:20:27.210 --> 00:20:32.070
每个任务的光纤，然后

00:20:30.300 --> 00:20:35.120
如果我们只是在这里结束，它将等待

00:20:32.070 --> 00:20:39.179
他们全部终止，但相反

00:20:35.120 --> 00:20:42.140
他们得到他们都被放在一个

00:20:39.179 --> 00:20:45.570
终止顺序排序的队列

00:20:42.140 --> 00:20:53.040
你等到第一个终止

00:20:45.570 --> 00:20:55.679
然后您取消所有其他

00:20:53.040 --> 00:20:58.980
你也可以给他们一个截止日期

00:20:55.679 --> 00:21:02.250
如果它们都没有终止，那么全部

00:20:58.980 --> 00:21:06.090
不会被取消，最后一件事

00:21:02.250 --> 00:21:07.559
在最后几分钟，最重要的是线程

00:21:06.090 --> 00:21:09.210
我们也想取代他们的当地人

00:21:07.559 --> 00:21:10.920
因为它们也是

00:21:09.210 --> 00:21:14.880
一劳永逸地设置一个值，然后

00:21:10.920 --> 00:21:16.020
也许记得重置它，也许不是

00:21:14.880 --> 00:21:18.670
我们正在尝试做的是

00:21:16.020 --> 00:21:23.500
也许更像

00:21:18.670 --> 00:21:25.660
动态变量和方案，其中

00:21:23.500 --> 00:21:30.520
线程加载称为

00:21:25.660 --> 00:21:32.380
嘲笑当地人有范围，您已经设定

00:21:30.520 --> 00:21:35.770
该范围内的值将

00:21:32.380 --> 00:21:37.960
是那个价值，不一定是

00:21:35.770 --> 00:21:39.940
在员工深处对，就是这样

00:21:37.960 --> 00:21:42.040
像三个当地人一样，您可以访问它们

00:21:39.940 --> 00:21:44.740
任何地方，但一旦退出示波器

00:21:42.040 --> 00:21:48.880
他们重置为原来的值， 

00:21:44.740 --> 00:21:50.650
因为我们有纤维，我们也控制

00:21:48.880 --> 00:21:54.030
如果您开始使用新纤维，则使用寿命

00:21:50.650 --> 00:21:56.710
在这里，也许他们也会

00:21:54.030 --> 00:21:58.360
继承这个值，但是这些仅仅是

00:21:56.710 --> 00:22:00.520
我们实际上没有的早期想法

00:21:58.360 --> 00:22:16.540
这在原型中呢，那是

00:22:00.520 --> 00:22:18.340
我只想说对不起

00:22:16.540 --> 00:22:20.590
关于罗恩的任何问题，我将从

00:22:18.340 --> 00:22:22.780
实际上告诉我你的最

00:22:20.590 --> 00:22:26.400
有趣而令人印象深刻的基准测试

00:22:22.780 --> 00:22:26.400
到目前为止的结果，如果有的话

