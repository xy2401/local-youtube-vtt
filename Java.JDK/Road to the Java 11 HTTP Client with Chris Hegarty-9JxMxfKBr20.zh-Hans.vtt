WEBVTT
Kind: captions
Language: zh-Hans

00:00:04.400 --> 00:00:09.269
嗨，我叫克里斯·哈格蒂（Chris Haggerty），我在这里工作

00:00:07.649 --> 00:00:10.889
 Oracle的Java平台小组和

00:00:09.269 --> 00:00:17.010
今天我要谈论的是

00:00:10.889 --> 00:00:18.720
 Java 11 HTTP客户端之路

00:00:17.010 --> 00:00:21.750
会议将要回答三个

00:00:18.720 --> 00:00:24.510
问题，为什么我们要添加一个新的HTTP 

00:00:21.750 --> 00:00:26.880
客户需要多长时间以及什么

00:00:24.510 --> 00:00:28.710
发展的角色以及

00:00:26.880 --> 00:00:30.779
作为您，您有什么好处？ 

00:00:28.710 --> 00:00:36.719
应用程序开发人员可以从

00:00:30.779 --> 00:00:39.480
 Java 11中的新HTTP客户端增强功能

00:00:36.719 --> 00:00:41.360
 JDK是通过jdk增强完成的

00:00:39.480 --> 00:00:44.190
杰夫的建议

00:00:41.360 --> 00:00:47.579
杰布堡10号车站是第一站

00:00:44.190 --> 00:00:49.379
在HTTP客户端上发布，它是

00:00:47.579 --> 00:00:52.530
有用的动机部分

00:00:49.379 --> 00:00:54.660
在这个宝石中，它包含许多

00:00:52.530 --> 00:00:57.449
讨论URL连接API的要点

00:00:54.660 --> 00:01:01.620
这是当前用于执行的API 

00:00:57.449 --> 00:01:05.549
 HTTP交流URL连接已添加

00:01:01.620 --> 00:01:08.280
在JDK $ 1上，是1996年的协议

00:01:05.549 --> 00:01:12.180
不可知论它支持多种协议

00:01:08.280 --> 00:01:16.979
像FTP邮件一样可以一次访问文件

00:01:12.180 --> 00:01:21.470
点地鼠以及HTTP URL 

00:01:16.979 --> 00:01:24.750
实际上，连接早于HTTP 1 1 

00:01:21.470 --> 00:01:27.930
查看HTTP时间轴，我们可以看到

00:01:24.750 --> 00:01:32.850
 HTTP 1 0的RFC已发布

00:01:27.930 --> 00:01:38.939
 1996年为1：1，1999年为最近

00:01:32.850 --> 00:01:41.670
 HTTP 2进入2015年

00:01:38.939 --> 00:01:44.149
 HTTP协议中的无数错误修复

00:01:41.670 --> 00:01:47.070
实施和大量增强

00:01:44.149 --> 00:01:49.590
例如大于2 GB的内容

00:01:47.070 --> 00:01:52.200
长度，他们希望继续100 

00:01:49.590 --> 00:01:54.060
标头，但一些

00:01:52.200 --> 00:01:56.280
实施已达到极限

00:01:54.060 --> 00:02:00.090
经过更多的复杂性

00:01:56.280 --> 00:02:02.759
超过20年，因为你是

00:02:00.090 --> 00:02:04.229
然后与连接协议无关

00:02:02.759 --> 00:02:07.409
可能有点麻烦

00:02:04.229 --> 00:02:11.220
 HTTP，因为它受到限制

00:02:07.409 --> 00:02:13.650
成为通用协议API的同时

00:02:11.220 --> 00:02:16.980
有一个具体的HTTP URL连接

00:02:13.650 --> 00:02:18.900
在许多情况下，子类型仍然不是

00:02:16.980 --> 00:02:23.819
任何自然的地方来记录一些

00:02:18.900 --> 00:02:25.769
 HTTP特定行为神经

00:02:23.819 --> 00:02:29.099
连接基于Java io流

00:02:25.769 --> 00:02:30.720
固有地阻止了这种情况

00:02:29.099 --> 00:02:35.370
并没有成为这样的限制

00:02:30.720 --> 00:02:37.500
 1996年，但今天是胎面

00:02:35.370 --> 00:02:39.140
宝贵的昂贵资源，我们不会

00:02:37.500 --> 00:02:41.159
想要不必要地捆绑他们

00:02:39.140 --> 00:02:45.239
特别是等待数据

00:02:41.159 --> 00:02:49.470
从网络收到再次查看

00:02:45.239 --> 00:02:54.060
在HTTP时间轴上，HTTP到RFC是

00:02:49.470 --> 00:02:57.030
 2015年5月发布了该应用程序

00:02:54.060 --> 00:03:00.329
 HDTV 2的语义基本相同

00:02:57.030 --> 00:03:04.200
与HTTP 1 1一样，所有核心

00:03:00.329 --> 00:03:07.319
请求，响应，HTTP等概念

00:03:04.200 --> 00:03:11.370
方法状态代码URI和标头是

00:03:07.319 --> 00:03:14.430
主要与HTTP 2修饰符相同

00:03:11.370 --> 00:03:17.790
如何格式化和传输数据

00:03:14.430 --> 00:03:20.190
客户端和服务器之间的HTTP 2 

00:03:17.790 --> 00:03:22.230
但是确实带来了一些新概念

00:03:20.190 --> 00:03:24.329
那将是非常困难的，或者

00:03:22.230 --> 00:03:27.510
几乎不可能在URL中建模

00:03:24.329 --> 00:03:30.840
连接API，例如服务器推送

00:03:27.510 --> 00:03:33.030
我们稍后会看一下HTTP 2 

00:03:30.840 --> 00:03:39.030
实现与

00:03:33.030 --> 00:03:41.669
 HTTP 1 1的定义新HTTP 

00:03:39.030 --> 00:03:44.190
 Java SE平台的客户端API是

00:03:41.669 --> 00:03:47.669
这并不容易，特别是如果我们期望

00:03:44.190 --> 00:03:51.209
在接下来的20年里，杰克110 

00:03:47.669 --> 00:03:54.329
几乎是2014年5月创建的

00:03:51.209 --> 00:03:57.150
在HTTP 2或C发布之前一年

00:03:54.329 --> 00:03:59.190
出版的工作实际上进展顺利

00:03:57.150 --> 00:04:01.650
实际上在各州之前

00:03:59.190 --> 00:04:04.650
早期的产品类型有几种

00:04:01.650 --> 00:04:07.379
围绕Java 7进行了迭代

00:04:04.650 --> 00:04:10.260
一个开源项目中的时间框架

00:04:07.379 --> 00:04:12.930
现在已经不存在的java.net网站

00:04:10.260 --> 00:04:15.449
仍可在档案中使用，因此

00:04:12.930 --> 00:04:17.430
该项目已经由几个人进行

00:04:15.449 --> 00:04:23.120
工程师和跨越许多

00:04:17.430 --> 00:04:27.190
年Jeff内容被集成到JDK中

00:04:23.120 --> 00:04:30.220
 9nj tk9于2017年9月发货

00:04:27.190 --> 00:04:32.170
如您所知Java 9带来了

00:04:30.220 --> 00:04:34.870
语言的变化形式

00:04:32.170 --> 00:04:37.230
模块系统和Java运行时映像

00:04:34.870 --> 00:04:39.820
包含在一组模块中

00:04:37.230 --> 00:04:42.090
与模块系统一起，新的

00:04:39.820 --> 00:04:44.650
孵化功能的概念已添加

00:04:42.090 --> 00:04:46.930
我们将更深入地探讨孵化

00:04:44.650 --> 00:04:49.360
目前的功能，但目前所有

00:04:46.930 --> 00:04:52.030
我们需要知道的是HTTP客户端

00:04:49.360 --> 00:04:55.840
是在jdk 9中添加的

00:04:52.030 --> 00:05:00.010
配备了一个新的孵化器模块，名为jdk 

00:04:55.840 --> 00:05:02.680
孵化器HTTP客户端添加了

00:05:00.010 --> 00:05:05.350
模块导出单个包jdk 

00:05:02.680 --> 00:05:11.500
孵化器HTTP包含两个

00:05:05.350 --> 00:05:13.420
完整的HTTP api jeff 11是

00:05:11.500 --> 00:05:16.150
描述什么的信息喷射

00:05:13.420 --> 00:05:18.310
孵化功能是他们的目的

00:05:16.150 --> 00:05:19.770
及其传递机制

00:05:18.310 --> 00:05:23.590
孵化器模块

00:05:19.770 --> 00:05:26.350
简单地将孵化器模块放到一个位置

00:05:23.590 --> 00:05:28.450
将非最终api放在手中

00:05:26.350 --> 00:05:30.310
 API是

00:05:28.450 --> 00:05:35.620
进行定稿或

00:05:30.310 --> 00:05:37.919
在将来的版本中删除

00:05:35.620 --> 00:05:40.840
 API是可取的，因为它允许

00:05:37.919 --> 00:05:43.840
 API的标准化要推迟

00:05:40.840 --> 00:05:46.540
在短时间内，API 

00:05:43.840 --> 00:05:48.340
仍然是JDK下载的一部分，因此

00:05:46.540 --> 00:05:51.820
可供大量Java使用

00:05:48.340 --> 00:05:53.530
开发人员的潜伏时间允许

00:05:51.820 --> 00:05:56.110
为这些开发人员提供反馈

00:05:53.530 --> 00:05:58.180
 API的功能以及

00:05:56.110 --> 00:06:01.600
 API整合其反馈

00:05:58.180 --> 00:06:03.610
在标准化孵化之前

00:06:01.600 --> 00:06:06.520
 API预计会相对

00:06:03.610 --> 00:06:08.680
在所有情况下都是短暂的

00:06:06.520 --> 00:06:11.169
在将来的版本中删除

00:06:08.680 --> 00:06:12.580
因为在这种情况下它是标准化的

00:06:11.169 --> 00:06:15.550
其模块和软件包名称将更改

00:06:12.580 --> 00:06:19.350
或者如果某些致命的设计缺陷是

00:06:15.550 --> 00:06:19.350
发现然后将其删除

00:06:19.680 --> 00:06:27.430
从看HTTP客户端类

00:06:22.930 --> 00:06:29.110
 JDK Nayanar JDK 10您将看到它的

00:06:27.430 --> 00:06:32.800
模块和软件包名称清楚

00:06:29.110 --> 00:06:35.080
被确定为正在孵化

00:06:32.800 --> 00:06:37.600
还有一个更可怕的警告

00:06:35.080 --> 00:06:40.249
 API是一个孵化功能， 

00:06:37.600 --> 00:06:42.469
此类将在以后的版本中删除

00:06:40.249 --> 00:06:45.199
所有这些都有助于通知开发人员

00:06:42.469 --> 00:06:47.209
如果他们正在使用此API， 

00:06:45.199 --> 00:06:51.849
他们将需要采取一些行动，当

00:06:47.209 --> 00:06:51.849
将其更新到将来的JDK版本

00:06:51.969 --> 00:06:56.839
孵化器孵化器模块不是

00:06:54.379 --> 00:06:58.819
在编译时解决，所以

00:06:56.839 --> 00:07:01.849
其他命令行选项需要

00:06:58.819 --> 00:07:04.009
指定告诉编译器添加

00:07:01.849 --> 00:07:07.759
孵化器模块及其类型

00:07:04.009 --> 00:07:11.089
在这里我们正在制作HTTP 

00:07:07.759 --> 00:07:13.309
客户端模块可用，因此添加

00:07:11.089 --> 00:07:15.439
指定了模块命令行选项

00:07:13.309 --> 00:07:19.909
 HTTP客户端的名称

00:07:15.439 --> 00:07:22.879
孵化器模块类似的孵化器

00:07:19.909 --> 00:07:24.919
在运行时无法解析模块，因此

00:07:22.879 --> 00:07:27.860
添加模块命令行选项是

00:07:24.919 --> 00:07:31.749
再次以相同的值加热

00:07:27.860 --> 00:07:34.819
 HTTP客户端孵化器模块的名称

00:07:31.749 --> 00:07:36.709
或者，模块化应用程序可以

00:07:34.819 --> 00:07:39.289
包含一个明确的require指令

00:07:36.709 --> 00:07:43.389
在其模块信息源文件命名中

00:07:39.289 --> 00:07:45.769
 HTTP客户端孵化器模块

00:07:43.389 --> 00:07:48.439
不管孵化器模块如何

00:07:45.769 --> 00:07:50.149
解决了真正的显式要求

00:07:48.439 --> 00:07:52.279
模块信息源中的指令

00:07:50.149 --> 00:07:54.649
文件或真正的命令行选项

00:07:52.279 --> 00:07:57.409
双方都发出警告

00:07:54.649 --> 00:08:00.069
编译时和运行时指示

00:07:57.409 --> 00:08:02.899
正在使用孵化功能

00:08:00.069 --> 00:08:05.239
警告中包括

00:08:02.899 --> 00:08:07.879
特定的孵化模块

00:08:05.239 --> 00:08:11.179
在这种情况下使用只是孵化

00:08:07.879 --> 00:08:13.969
 HTTP客户端模块已再次使用

00:08:11.179 --> 00:08:16.159
此警告旨在帮助通知

00:08:13.969 --> 00:08:18.949
开发人员具有孵化功能

00:08:16.159 --> 00:08:21.110
正在使用中，需要采取措施

00:08:18.949 --> 00:08:26.619
更新到将来时要采取的措施

00:08:21.110 --> 00:08:29.509
发布，这就是我们在JDK 9中所做的

00:08:26.619 --> 00:08:32.360
 JDK 10的实现是完全

00:08:29.509 --> 00:08:35.449
大修以提高可靠性并

00:08:32.360 --> 00:08:37.459
使API更健壮

00:08:35.449 --> 00:08:39.439
更新以纳入反馈

00:08:37.459 --> 00:08:44.000
在孵化的JDK 9中收到

00:08:39.439 --> 00:08:46.880
 Java 4版

00:08:44.000 --> 00:08:51.560
提交了新的JDK增强建议

00:08:46.880 --> 00:08:53.720
 jeb 321来标准化API 

00:08:51.560 --> 00:08:56.330
需要给HTTP客户端一个

00:08:53.720 --> 00:09:00.110
标准模块名为davon F的软件包

00:08:56.330 --> 00:09:02.720
这个标准包现在包含HTTP 

00:09:00.110 --> 00:09:05.750
完整的API和孵化

00:09:02.720 --> 00:09:08.570
版本已被完全删除任何

00:09:05.750 --> 00:09:11.570
在JD k 9r JDK 10和

00:09:08.570 --> 00:09:14.510
使用孵化API将需要

00:09:11.570 --> 00:09:16.280
至少更新了导入

00:09:14.510 --> 00:09:19.490
陈述将需要更改为

00:09:16.280 --> 00:09:21.680
反映新的软件包名称以及任何

00:09:19.490 --> 00:09:24.740
包含以下信息的模块信息源文件

00:09:21.680 --> 00:09:27.320
需要命名HTTP的指令

00:09:24.740 --> 00:09:30.100
客户端孵化器模块现在需要

00:09:27.320 --> 00:09:32.690
使用新的标准模块名称

00:09:30.100 --> 00:09:35.180
类似地，任何命令行选项

00:09:32.690 --> 00:09:38.540
指定培养模块名称

00:09:35.180 --> 00:09:41.660
将需要更新，甚至可能不需要更新

00:09:38.540 --> 00:09:44.090
有必要，因为所有标准模块

00:09:41.660 --> 00:09:46.670
是Java SE平台的一部分

00:09:44.090 --> 00:09:50.839
运行时默认解决

00:09:46.670 --> 00:09:57.650
类路径上的应用程序

00:09:50.839 --> 00:10:00.530
看看如何做到这一点，所以在这里我们

00:09:57.650 --> 00:10:02.990
有一个实用程序来宾方法检索

00:10:00.530 --> 00:10:07.190
给你我并返回响应主体

00:10:02.990 --> 00:10:08.750
作为字符串，它首先创建一个新的HTTP 

00:10:07.190 --> 00:10:13.070
请求的客户

00:10:08.750 --> 00:10:16.400
发送，然后使用

00:10:13.070 --> 00:10:19.550
给定的URI然后发送异步方法

00:10:16.400 --> 00:10:22.010
被调用以发送请求和正文

00:10:19.550 --> 00:10:24.890
字符串工厂方法返回的处理程序

00:10:22.010 --> 00:10:28.010
转换反应的身体饥饿

00:10:24.890 --> 00:10:31.960
正文字节发送到字符串发送异步

00:10:28.010 --> 00:10:35.000
方法返回字符串的HTTP响应

00:10:31.960 --> 00:10:37.010
可以与

00:10:35.000 --> 00:10:40.910
然后从completable中应用方法

00:10:37.010 --> 00:10:43.160
将来映射的HTTP响应

00:10:40.910 --> 00:10:45.620
字符串为其主体类型，即字符串

00:10:43.160 --> 00:10:50.240
就我们而言，以及

00:10:45.620 --> 00:10:52.790
字符串返回的主要方法

00:10:50.240 --> 00:10:55.490
只需使用给定的URI进行调用即可， 

00:10:52.790 --> 00:10:57.220
然后加入阻止直到完成

00:10:55.490 --> 00:11:03.110
未来完成

00:10:57.220 --> 00:11:05.209
然后将响应主体打印出来

00:11:03.110 --> 00:11:12.920
正在使用的孵化版本

00:11:05.209 --> 00:11:15.470
 JDK 9中的API，因此让我们运行

00:11:12.920 --> 00:11:17.300
看到正在孵化的警告

00:11:15.470 --> 00:11:19.670
模块已被使用，其名称

00:11:17.300 --> 00:11:21.950
模块，然后程序执行

00:11:19.670 --> 00:11:28.010
一些公主反应身体是一个弦

00:11:21.950 --> 00:11:30.399
这只是一些XML，还有一个

00:11:28.010 --> 00:11:33.380
相同代码的模块化版本

00:11:30.399 --> 00:11:36.709
它的模块信息需要JDK 

00:11:33.380 --> 00:11:39.110
孵化器HTTP客户端模块和导出

00:11:36.709 --> 00:11:45.380
包含

00:11:39.110 --> 00:11:48.589
代码代码几乎相同

00:11:45.380 --> 00:11:49.970
先前的代码仅打印ed模块化

00:11:48.589 --> 00:11:52.810
测试，所以我们知道这段代码是

00:11:49.970 --> 00:11:58.430
实际执行，让我们运行

00:11:52.810 --> 00:12:01.100
再次发出警告

00:11:58.430 --> 00:12:04.550
编译器以及运行时

00:12:01.100 --> 00:12:08.540
已使用孵化HTTP客户端，并且

00:12:04.550 --> 00:12:12.140
再次打印出响应正文，这样

00:12:08.540 --> 00:12:13.970
让我们先为jdk 11更新此代码

00:12:12.140 --> 00:12:18.050
为此，我们可以更新STK 

00:12:13.970 --> 00:12:20.209
被IDE使用，现在我们有了一个

00:12:18.050 --> 00:12:24.079
许多错误，因为孵化API 

00:12:20.209 --> 00:12:26.510
不再存在于JDK 11中，所以让我们

00:12:24.079 --> 00:12:30.019
更新导入语句以反映

00:12:26.510 --> 00:12:38.120
新的标准软件包名称是

00:12:30.019 --> 00:12:39.970
 Java net HTTP我们仍然可以看到

00:12:38.120 --> 00:12:42.709
有红线，这是因为

00:12:39.970 --> 00:12:46.390
 require语句不正确，所以

00:12:42.709 --> 00:12:46.390
让我们先在那里更新模块名称

00:12:48.550 --> 00:12:54.850
好吧，我们的导入语句似乎是

00:12:52.190 --> 00:12:54.850
现在接受

00:12:58.329 --> 00:13:09.199
哎呀，工厂方法已经

00:13:03.529 --> 00:13:09.799
在JDK 11中重命名，它们都带有前缀

00:13:09.199 --> 00:13:13.999
哎呀

00:13:09.799 --> 00:13:18.079
有了爱，他们已经移到身体了

00:13:13.999 --> 00:13:22.220
 handlers class，所以body handlers有

00:13:18.079 --> 00:13:29.779
字符串，让我们现在运行它，看看

00:13:22.220 --> 00:13:32.329
发生什么了好吧，我们有一个错误

00:13:29.779 --> 00:13:36.619
编译时间，因为JDK孵化器

00:13:32.329 --> 00:13:38.470
在我的IDE中找不到HTTP客户端模块

00:13:36.619 --> 00:13:42.829
在其首选项中配置

00:13:38.470 --> 00:13:44.659
您添加孵化器模块，这是一个命令

00:13:42.829 --> 00:13:47.869
行选项，让我们删除您不

00:13:44.659 --> 00:13:50.679
不再需要它并运行模块化

00:13:47.869 --> 00:13:50.679
再次申请

00:13:56.440 --> 00:14:04.779
好的，它可以在此应用程序中工作

00:14:02.019 --> 00:14:07.600
仅使用HTTP模块，因此仅

00:14:04.779 --> 00:14:10.899
需要使用Java net HTTP 

00:14:07.600 --> 00:14:18.759
当然需要Java SE 

00:14:10.899 --> 00:14:20.350
为您提供完整的SC平台，并

00:14:18.759 --> 00:14:23.439
再次运行并打印出响应

00:14:20.350 --> 00:14:28.769
主体，所以让我们更新非模块化

00:14:23.439 --> 00:14:28.769
同样的方式

00:14:47.920 --> 00:14:54.790
再次，工厂方法已经

00:14:51.699 --> 00:14:56.679
移动并重命名，所以我毁了一个

00:14:54.790 --> 00:14:58.929
非模块化配置

00:14:56.679 --> 00:15:03.100
有一个应用程序

00:14:58.929 --> 00:15:05.079
在课本上运行，然后再次

00:15:03.100 --> 00:15:07.720
提到孵化器的事实

00:15:05.079 --> 00:15:10.359
找不到模块，所以我们需要编辑

00:15:07.720 --> 00:15:14.259
这不是配置

00:15:10.359 --> 00:15:17.019
编辑配置并删除

00:15:14.259 --> 00:15:20.009
显式添加模块，用作

00:15:17.019 --> 00:15:27.249
使用JDK 9时的运行时参数

00:15:20.009 --> 00:15:27.699
因此，让我们再次运行它

00:15:27.249 --> 00:15:30.730
作品

00:15:27.699 --> 00:15:32.769
公主回应身体，所以我们已经看到了

00:15:30.730 --> 00:15:34.869
更新模块化和非模块化

00:15:32.769 --> 00:15:37.480
应用程序更新导入

00:15:34.869 --> 00:15:39.939
反映新包装的声明

00:15:37.480 --> 00:15:43.089
 jdk 11以及新模块中的名称

00:15:39.939 --> 00:15:45.609
模块信息中的名称以及一些

00:15:43.089 --> 00:15:47.619
重命名周围的其他细微变化

00:15:45.609 --> 00:15:51.999
和一些工厂的搬迁

00:15:47.619 --> 00:15:54.189
方法有很多好处

00:15:51.999 --> 00:15:56.919
应用程序开发人员可以从中获得

00:15:54.189 --> 00:15:58.360
使用新的HTTP客户端，我们将采取

00:15:56.919 --> 00:16:02.199
看看其中最重要的

00:15:58.360 --> 00:16:03.910
在接下来的幻灯片数是

00:16:02.199 --> 00:16:08.319
列出的一些目标

00:16:03.910 --> 00:16:11.739
 Japan 10对HTTP 2的支持当然是

00:16:08.319 --> 00:16:14.499
和HTTP 1 1提供异步

00:16:11.739 --> 00:16:17.009
 API，以摆脱阻塞

00:16:14.499 --> 00:16:20.290
现有URL连接的语义

00:16:17.009 --> 00:16:22.389
使用更多现代语言功能，例如

00:16:20.290 --> 00:16:24.819
泛型和lambda以及更多

00:16:22.389 --> 00:16:26.319
现代平台api就像是可完成的

00:16:24.819 --> 00:16:30.009
未来和反应流

00:16:26.319 --> 00:16:31.480
接口另外有支持

00:16:30.009 --> 00:16:35.549
用于处理WebSocket 

00:16:31.480 --> 00:16:38.499
升级和低级Web套接字API 

00:16:35.549 --> 00:16:41.439
正如我之前所说的

00:16:38.499 --> 00:16:42.910
 HTTP 2的语义类似于

00:16:41.439 --> 00:16:45.129
的HTTP 1 1 

00:16:42.910 --> 00:16:46.959
但是有重大意义

00:16:45.129 --> 00:16:51.009
两种协议的差异

00:16:46.959 --> 00:16:52.809
版本操作HTTP 2仅使用

00:16:51.009 --> 00:16:55.239
客户端与

00:16:52.809 --> 00:16:57.610
服务器，减少了

00:16:55.239 --> 00:17:00.790
建立新的连接

00:16:57.610 --> 00:17:03.880
用于TLS握手可以进行的HTTP 

00:17:00.790 --> 00:17:05.230
花一些时间来完成这首单曲

00:17:03.880 --> 00:17:07.870
客户端和服务器之间的连接

00:17:05.230 --> 00:17:12.549
可以有多个HTTP请求

00:17:07.870 --> 00:17:14.740
同时在HTTP上多路复用

00:17:12.549 --> 00:17:19.540
 2提供了一种称为服务器的新机制

00:17:14.740 --> 00:17:22.780
将收到的邮件推送到服务器

00:17:19.540 --> 00:17:25.150
如果可以，请求可以

00:17:22.780 --> 00:17:27.280
适当的句法要求

00:17:25.150 --> 00:17:29.320
它认为的客户资源

00:17:27.280 --> 00:17:31.870
客户可能需要

00:17:29.320 --> 00:17:34.000
原始请求可以用来

00:17:31.870 --> 00:17:36.640
加快资源检索

00:17:34.000 --> 00:17:38.770
大量的嵌入式链接

00:17:36.640 --> 00:17:43.840
取消连线格式已更新

00:17:38.770 --> 00:17:46.299
明显来自数据HTTP 1 1 HTTP 2 

00:17:43.840 --> 00:17:48.520
使用更紧凑的二进制格式， 

00:17:46.299 --> 00:17:53.080
标头使用H PAC压缩

00:17:48.520 --> 00:17:56.890
压缩HTTP客户端支持

00:17:53.080 --> 00:18:01.480
同时使用HTTP 1 1和HTTP 2，但更喜欢

00:17:56.890 --> 00:18:03.700
默认情况下，HTTP 2用于新的清除非TLS 

00:18:01.480 --> 00:18:05.919
自动连接客户端

00:18:03.700 --> 00:18:08.470
添加了合适的协议

00:18:05.919 --> 00:18:11.470
标头，让我们的服务器知道

00:18:08.470 --> 00:18:14.710
客户端支持HTTP 2（如果服务器） 

00:18:11.470 --> 00:18:16.360
也支持HTTP 2然后可以回复

00:18:14.710 --> 00:18:20.919
视情况而定，连接将

00:18:16.360 --> 00:18:23.080
客户端通过TLS通过HTTP升级

00:18:20.919 --> 00:18:26.169
使用应用层协议

00:18:23.080 --> 00:18:29.650
协商TLS扩展以尝试

00:18:26.169 --> 00:18:33.360
如果证书与服务器协商h2 

00:18:29.650 --> 00:18:36.640
服务器支持H 2，然后将H 2用于

00:18:33.360 --> 00:18:39.520
服务器不支持的所有情况

00:18:36.640 --> 00:18:44.620
 HTTP 2，然后连接回退到

00:18:39.520 --> 00:18:47.950
从JDK 11 TLS 1.3开始的HTTP 1 1 

00:18:44.620 --> 00:18:49.809
 HTTP客户端支持该协议

00:18:47.950 --> 00:18:57.370
利用这一点并尝试进行谈判

00:18:49.809 --> 00:18:59.559
所有新的TLS连接的TLS 1.3 

00:18:57.370 --> 00:19:02.740
 HTTP客户端支持异步

00:18:59.559 --> 00:19:05.350
与一起发送的操作模式请求

00:19:02.740 --> 00:19:08.679
发送异步方法返回兼容

00:19:05.350 --> 00:19:10.630
 HTTP响应兼容的未来

00:19:08.679 --> 00:19:11.929
未来提供了许多方法

00:19:10.630 --> 00:19:14.210
建筑链

00:19:11.929 --> 00:19:17.899
可以运行的相关操作

00:19:14.210 --> 00:19:20.659
在此同步或异步

00:19:17.899 --> 00:19:22.999
范例提供当日同步

00:19:20.659 --> 00:19:24.830
请求发送，还有一个尸体

00:19:22.999 --> 00:19:29.059
转换响应主体的处理程序

00:19:24.830 --> 00:19:32.869
字节到字符串可比较的未来

00:19:29.059 --> 00:19:35.269
 denne apply方法映射到HTTP响应

00:19:32.869 --> 00:19:39.080
它的身体类型，在这种情况下是

00:19:35.269 --> 00:19:42.249
 den accept方法消耗的字符串

00:19:39.080 --> 00:19:45.019
字符串，然后将其打印出来

00:19:42.249 --> 00:19:49.490
最后join方法阻塞，直到

00:19:45.019 --> 00:19:51.409
 HTTP响应字符串

00:19:49.490 --> 00:19:54.139
客户遵循熟悉的生成器

00:19:51.409 --> 00:19:57.230
模式有工厂创建

00:19:54.139 --> 00:20:01.279
顶级HTTP的两个构建器

00:19:57.230 --> 00:20:04.999
客户端和HTTP请求类型

00:20:01.279 --> 00:20:07.429
 HTTP客户端新构建器示例

00:20:04.999 --> 00:20:10.730
静态工厂方法返回新的

00:20:07.429 --> 00:20:13.129
我连接的HTTP客户端的生成器

00:20:10.730 --> 00:20:18.379
新连接的超时设置为20 

00:20:13.129 --> 00:20:20.600
秒，客户端建立了HTTP 

00:20:18.379 --> 00:20:24.610
请求具有类似的新生成器

00:20:20.600 --> 00:20:28.999
然后工厂要求Uriah设置一个

00:20:24.610 --> 00:20:31.399
请求特定超时报头

00:20:28.999 --> 00:20:34.639
从此指示内容类型

00:20:31.399 --> 00:20:37.730
将是职位要求的身体

00:20:34.639 --> 00:20:39.980
文件工厂方法的发布者是

00:20:37.730 --> 00:20:42.590
用于返回请求正文发布者

00:20:39.980 --> 00:20:48.529
发布给定内容的

00:20:42.590 --> 00:20:50.450
然后将请求发送到文件路径

00:20:48.529 --> 00:20:51.889
 Java平台为

00:20:50.450 --> 00:20:54.080
通过许多反应性流

00:20:51.889 --> 00:20:56.749
 Java util并发中的接口

00:20:54.080 --> 00:20:59.330
流类有一个发布者

00:20:56.749 --> 00:21:02.869
为订户生产商品

00:20:59.330 --> 00:21:05.509
订户消费的商品

00:21:02.869 --> 00:21:06.850
给发布者，并可以发出请求

00:21:05.509 --> 00:21:09.889
用于所需的物品

00:21:06.850 --> 00:21:12.470
该请求机制提供了

00:21:09.889 --> 00:21:14.269
订户具有背压，因为它

00:21:12.470 --> 00:21:18.769
控制最大数量

00:21:14.269 --> 00:21:20.440
可能像我们刚发送给它的项目

00:21:18.769 --> 00:21:23.149
在上一张幻灯片中看到

00:21:20.440 --> 00:21:25.610
 HTTP请求主体是通过

00:21:23.149 --> 00:21:27.830
正文发布者

00:21:25.610 --> 00:21:31.690
发布者是流发布者的子类型

00:21:27.830 --> 00:21:34.940
将httprequest主体发布为字节

00:21:31.690 --> 00:21:37.280
发布者的HTTP请求

00:21:34.940 --> 00:21:39.710
类提供了分解的集合

00:21:37.280 --> 00:21:43.490
大多数创建发布者的方法

00:21:39.710 --> 00:21:45.040
常见用例，例如发布

00:21:43.490 --> 00:21:47.330
来自字符串的请求正文是

00:21:45.040 --> 00:21:51.559
从文件发布请求正文

00:21:47.330 --> 00:21:54.799
还有更多类似的情况

00:21:51.559 --> 00:21:57.500
接收方HTTP响应主体

00:21:54.799 --> 00:22:00.230
 Subscriber是java.util的子类型

00:21:57.500 --> 00:22:03.650
并发流订阅者

00:22:00.230 --> 00:22:05.990
响应主体字节的订阅者再次

00:22:03.650 --> 00:22:07.700
有一个班级订户

00:22:05.990 --> 00:22:09.470
提供了许多工厂方法

00:22:07.700 --> 00:22:13.429
为大多数人创建机构订户

00:22:09.470 --> 00:22:16.429
常见用例，例如转换

00:22:13.429 --> 00:22:19.520
响应正文字节转换为字符串或

00:22:16.429 --> 00:22:21.290
将字节流传输到文件自定义

00:22:19.520 --> 00:22:23.059
发布者和订阅者可以是

00:22:21.290 --> 00:22:27.460
通过执行身体写

00:22:23.059 --> 00:22:31.669
发布者和主体订户接口

00:22:27.460 --> 00:22:34.630
总结标准的HTTP客户端

00:22:31.669 --> 00:22:37.610
 Java 11中添加的是对

00:22:34.630 --> 00:22:40.700
通过URL执行HTTP访问

00:22:37.610 --> 00:22:44.390
我们已经看到的连接API 

00:22:40.700 --> 00:22:47.020
现在已有二十多年的HTTP 

00:22:44.390 --> 00:22:49.850
客户api在jdk 9中孵育

00:22:47.020 --> 00:22:53.840
在jdk 10中刷新，最后

00:22:49.850 --> 00:22:56.480
使用Java 11代码标准化

00:22:53.840 --> 00:22:59.630
需要孵化版本的API 

00:22:56.480 --> 00:23:01.460
至少要针对Java 11进行更新

00:22:59.630 --> 00:23:04.760
导入声明将需要反映

00:23:01.460 --> 00:23:07.250
新的标准包名称HTTP 

00:23:04.760 --> 00:23:09.530
客户端API使用更现代的语言

00:23:07.250 --> 00:23:12.200
像泛型和lambda这样的功能

00:23:09.530 --> 00:23:14.330
以及更现代的平台api就像

00:23:12.200 --> 00:23:19.160
兼容未来和反应性

00:23:14.330 --> 00:23:22.730
您可以下载Java的流接口

00:23:19.160 --> 00:23:26.120
现在11现在在此URL处，请加入我们

00:23:22.730 --> 00:23:30.140
打开JDK在Twitter上关注我们

00:23:26.120 --> 00:23:36.920
 JDK或主题标签Java 11我自己的Twitter 

00:23:30.140 --> 00:23:39.080
句柄在检查器999 oracle是

00:23:36.920 --> 00:23:41.120
 Java的stuartt提供了大量

00:23:39.080 --> 00:23:44.810
的开发工程资金

00:23:41.120 --> 00:23:47.270
 Java SE平台并打开Oracle JDK 

00:23:44.810 --> 00:23:49.820
提供一流的总理支持

00:23:47.270 --> 00:23:53.150
易于购买的低成本

00:23:49.820 --> 00:23:54.170
具有简单的定价等级谢谢

00:23:53.150 --> 00:23:58.319
观看

00:23:54.170 --> 00:23:58.319
 [音乐] 

