WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.140 --> 00:00:06.180
 OpenJDK的性能主要是因为

00:00:05.069 --> 00:00:10.880
在过去做了一点

00:00:06.180 --> 00:00:16.160
几年来我们的一些调整

00:00:10.880 --> 00:00:18.000
低音openjdk体验的启动

00:00:16.160 --> 00:00:20.340
在我开始撒谎之前

00:00:18.000 --> 00:00:21.869
我要给你看一下

00:00:20.340 --> 00:00:25.760
让我们走吧

00:00:21.869 --> 00:00:30.660
因此，创业挑战了我们

00:00:25.760 --> 00:00:35.520
具有Java用户和JVM的经验

00:00:30.660 --> 00:00:39.629
开发商是多方面的，露天的

00:00:35.520 --> 00:00:43.530
衰减针对峰值性能进行了优化

00:00:39.629 --> 00:00:48.600
最近我们说GC和其他人

00:00:43.530 --> 00:00:51.210
知道低延迟和启动

00:00:48.600 --> 00:00:56.820
足迹一直是这类的

00:00:51.210 --> 00:00:59.399
很高兴拥有您喜欢的东西

00:00:56.820 --> 00:01:04.019
期望在客户端设置中，但是客户端

00:00:59.399 --> 00:01:06.170
虚拟机一直在远离开放

00:01:04.019 --> 00:01:06.170
 JDK 

00:01:06.740 --> 00:01:11.700
感兴趣了一段时间，所以启动是

00:01:09.570 --> 00:01:13.470
经常画画的东西

00:01:11.700 --> 00:01:16.350
画最短的稻草

00:01:13.470 --> 00:01:20.189
谈到如何优化修复

00:01:16.350 --> 00:01:21.810
对于兽的本质

00:01:20.189 --> 00:01:24.840
您正在添加功能

00:01:21.810 --> 00:01:27.570
添加可以优化的新功能

00:01:24.840 --> 00:01:28.979
您使您进行优化以查看

00:01:27.570 --> 00:01:30.659
你知道要优化一些

00:01:28.979 --> 00:01:32.810
库增加膨胀

00:01:30.659 --> 00:01:38.070
它增加了你知道死亡减少一千

00:01:32.810 --> 00:01:40.409
到开放式JDK体验到此为止

00:01:38.070 --> 00:01:43.200
六七八，尤其是也许

00:01:40.409 --> 00:01:45.810
九，你已经看到了小小的补充

00:01:43.200 --> 00:01:47.729
里面的小东西

00:01:45.810 --> 00:01:50.490
在启动时或每次您运行时

00:01:47.729 --> 00:01:52.920
靴带和一些可以增加你的东西

00:01:50.490 --> 00:01:56.549
知道你通常看不到他们

00:01:52.920 --> 00:01:59.700
但随着时间的推移，它们的确会累加

00:01:56.549 --> 00:02:02.280
最近我差不多要说几十年了，但是

00:01:59.700 --> 00:02:05.820
几年来我们一直在增加

00:02:02.280 --> 00:02:08.910
动态设置东西唐躲我

00:02:05.820 --> 00:02:11.129
早些时候在这里谈论印度喜剧

00:02:08.910 --> 00:02:13.410
这就是我们的趋势

00:02:11.129 --> 00:02:14.940
继续使用

00:02:13.410 --> 00:02:17.880
动态引导程序越来越多

00:02:14.940 --> 00:02:20.430
东西和那些东西好，他们不是

00:02:17.880 --> 00:02:23.850
是免费的，特别是不是从

00:02:20.430 --> 00:02:27.840
初学者的观点也从

00:02:23.850 --> 00:02:30.660
足迹的观点，所以我们

00:02:27.840 --> 00:02:33.840
要增加更多的可能是这样

00:02:30.660 --> 00:02:37.020
我们如何应对这个难题

00:02:33.840 --> 00:02:40.040
尝试至少保持启动稳定

00:02:37.020 --> 00:02:44.460
或改善我们的时间而不受阻碍

00:02:40.040 --> 00:02:48.570
使用Indy和

00:02:44.460 --> 00:02:50.100
其他功能在您之前

00:02:48.570 --> 00:02:54.330
您可以优化您需要问的任何问题

00:02:50.100 --> 00:02:57.180
你自己，为什么要打扰那里

00:02:54.330 --> 00:03:01.050
有一个兴趣范围

00:02:57.180 --> 00:03:03.450
使Java更快地启动以及

00:03:01.050 --> 00:03:05.550
你认识的人的任何东西

00:03:03.450 --> 00:03:08.900
语言，只需编写一些CLI工具

00:03:05.550 --> 00:03:12.380
或您的服务职能

00:03:08.900 --> 00:03:16.140
供应商想削减一些麦克风

00:03:12.380 --> 00:03:18.030
您的服务时间减少了毫秒

00:03:16.140 --> 00:03:19.890
当您每次引导一个新的VM时

00:03:18.030 --> 00:03:23.490
您为请求服务的时间

00:03:19.890 --> 00:03:27.870
开销似乎有点高

00:03:23.490 --> 00:03:30.030
方面，当然你知道

00:03:27.870 --> 00:03:33.630
 UDK开放社区中的传统工作

00:03:30.030 --> 00:03:35.250
您已经嵌入了客户端虚拟机等

00:03:33.630 --> 00:03:39.470
我们主要专注于服务器

00:03:35.250 --> 00:03:42.180
今天的虚拟机，那么我们如何使服务器虚拟机

00:03:39.470 --> 00:03:43.830
包围，你知道容纳一些

00:03:42.180 --> 00:03:47.790
先前在

00:03:43.830 --> 00:03:51.959
不同的优化不同

00:03:47.790 --> 00:03:56.910
仓库很好，你知道另一个

00:03:51.959 --> 00:03:59.880
原因可能更多是我喜欢的个人原因

00:03:56.910 --> 00:04:02.280
继续对抗误解

00:03:59.880 --> 00:04:03.800
 Java很慢，我想改善

00:04:02.280 --> 00:04:07.050
我自己的生活质量

00:04:03.800 --> 00:04:08.730
你们都知道的开发经验

00:04:07.050 --> 00:04:10.739
每隔10毫秒我们就可以消除

00:04:08.730 --> 00:04:14.580
通过启动组合，您知道我们的测试

00:04:10.739 --> 00:04:15.330
环境要快半个小时，所以

00:04:14.580 --> 00:04:18.180
有那个

00:04:15.330 --> 00:04:20.280
关于启动技术

00:04:18.180 --> 00:04:22.080
有很多高级的东西

00:04:20.280 --> 00:04:26.760
一直以来你都知道功能冰

00:04:22.080 --> 00:04:29.880
几年过去了

00:04:26.760 --> 00:04:33.210
 Stata分享Sidious被接受

00:04:29.880 --> 00:04:35.400
回到客户端虚拟机首先

00:04:33.210 --> 00:04:38.790
为Windows 2实现

00:04:35.400 --> 00:04:40.530
小程序启动更快，为什么它仍然是

00:04:38.790 --> 00:04:42.420
事情很好，有人意识到

00:04:40.530 --> 00:04:47.310
我们可以适应并在

00:04:42.420 --> 00:04:50.750
服务器类VM已扩展为包括

00:04:47.310 --> 00:04:52.980
应用程序将自己分类

00:04:50.750 --> 00:04:57.630
所以它有点像商业广告

00:04:52.980 --> 00:04:59.550
 Oracle VM支持的功能

00:04:57.630 --> 00:05:01.560
具有应用程序类的逻辑服务器

00:04:59.550 --> 00:05:06.660
数据共享和此商业功能

00:05:01.560 --> 00:05:08.850
在11中完全开源，所以现在我们可以

00:05:06.660 --> 00:05:13.230
使用应用程序类数据共享和

00:05:08.850 --> 00:05:15.120
你让它运行起来很酷

00:05:13.230 --> 00:05:17.850
为您的应用程序，它可以削减

00:05:15.120 --> 00:05:23.670
如果是

00:05:17.850 --> 00:05:29.060
幸运的是，您的里程可能会有所不同

00:05:23.670 --> 00:05:32.300
 Java 9中的努力增加了实验性

00:05:29.060 --> 00:05:36.360
实验性的提前编译器

00:05:32.300 --> 00:05:38.610
从平局努力中出来的

00:05:36.360 --> 00:05:41.160
基于女孩的编译器附带开放

00:05:38.610 --> 00:05:43.920
表明它允许您预编译

00:05:41.160 --> 00:05:48.240
您的瑜伽课要共享880 

00:05:43.920 --> 00:05:53.400
有一点点的图书馆

00:05:48.240 --> 00:05:56.130
混合结果混合袋，但

00:05:53.400 --> 00:05:58.110
好处是您的80个档案已加载

00:05:56.130 --> 00:06:02.790
并不会真正影响您

00:05:58.110 --> 00:06:05.640
除了它添加的应用程序和

00:06:02.790 --> 00:06:06.030
消息发送到代码缓存中的任何内容

00:06:05.640 --> 00:06:11.610
纽扣

00:06:06.030 --> 00:06:13.200
最好的表现不会

00:06:11.610 --> 00:06:17.340
太多了，但我不想多说

00:06:13.200 --> 00:06:20.730
关于äôt，然后还有其他

00:06:17.340 --> 00:06:23.820
侵入性和实验性功能，例如

00:06:20.730 --> 00:06:26.460
那么你可以通过监狱来做

00:06:23.820 --> 00:06:29.690
从运行时映像中删除内容

00:06:26.460 --> 00:06:34.290
或压缩它们或做其他事情

00:06:29.690 --> 00:06:37.020
基本上可以编写插件

00:06:34.290 --> 00:06:38.550
从理论上讲可以做到

00:06:37.020 --> 00:06:39.980
您正在做的很多事情

00:06:38.550 --> 00:06:42.050
今天与

00:06:39.980 --> 00:06:44.740
代理商，但您可以提前完成

00:06:42.050 --> 00:06:49.120
作为J链接

00:06:44.740 --> 00:06:52.610
管道，所以它可以链接

00:06:49.120 --> 00:06:55.160
提前显示您的图像，如果

00:06:52.610 --> 00:07:00.590
运送图片，您可以提前完成

00:06:55.160 --> 00:07:02.630
时间原生图像也是

00:07:00.590 --> 00:07:06.680
在雷达上，但不包含在其中

00:07:02.630 --> 00:07:10.520
这个演讲是女孩VM的努力

00:07:06.680 --> 00:07:12.850
编译您的Java应用程序

00:07:10.520 --> 00:07:15.830
接近世界的假设

00:07:12.850 --> 00:07:18.080
下降到一个二进制文件，所以有点

00:07:15.830 --> 00:07:22.070
图片后切掉大部分的禽蛋

00:07:18.080 --> 00:07:24.310
并为您提供了运行时映像，因此

00:07:22.070 --> 00:07:27.740
这方面的努力超出了

00:07:24.310 --> 00:07:29.480
对于这个演讲，但是很有趣

00:07:27.740 --> 00:07:31.820
看看你是否真的在看

00:07:29.480 --> 00:07:35.860
对于快速启动的东西

00:07:31.820 --> 00:07:38.720
最小的二进制大小，但我

00:07:35.860 --> 00:07:40.970
好吧，不要看那些东西对

00:07:38.720 --> 00:07:45.640
现在我更多地是从

00:07:40.970 --> 00:07:47.600
你知道OpenJDK我们如何使java有

00:07:45.640 --> 00:07:51.260
大家都知道它开始了一点

00:07:47.600 --> 00:07:55.700
更快，因为原因，所以我通常

00:07:51.260 --> 00:07:58.970
从你好世界开始

00:07:55.700 --> 00:08:02.600
是每个人最喜欢的创业公司

00:07:58.970 --> 00:08:05.210
自至少95岁以来

00:08:02.600 --> 00:08:07.670
说到你是什么意思

00:08:05.210 --> 00:08:10.310
我们会开始一点

00:08:07.670 --> 00:08:13.310
定义不明确，但大多数人都这样

00:08:10.310 --> 00:08:15.380
他们跑世界，他们计时

00:08:13.310 --> 00:08:18.470
与您共度时光或其他

00:08:15.380 --> 00:08:21.320
像哦，我的JVM从100开始

00:08:18.470 --> 00:08:25.130
毫秒好，我不仅开始了

00:08:21.320 --> 00:08:28.540
它也跑了，然后关闭了

00:08:25.130 --> 00:08:31.400
一切都下来，所有你知道的

00:08:28.540 --> 00:08:34.700
操作系统的切换和同步

00:08:31.400 --> 00:08:36.890
会增加很多时间，具体取决于

00:08:34.700 --> 00:08:39.349
如果您的并发GC周期具有

00:08:36.890 --> 00:08:41.180
已经开始，一个或任何一个

00:08:39.349 --> 00:08:44.660
您正在运行的收集器可能是

00:08:41.180 --> 00:08:47.990
某种程度的阻塞

00:08:44.660 --> 00:08:50.570
时间量，所以如果你真的想要你

00:08:47.990 --> 00:08:53.900
衡量启动的条件

00:08:50.570 --> 00:08:57.440
某种方式可能会很好

00:08:53.900 --> 00:08:59.029
识别您的应用程序何时

00:08:57.440 --> 00:09:01.310
实际启动并运行，例如

00:08:59.029 --> 00:09:03.890
当您好打印世界

00:09:01.310 --> 00:09:06.500
无论何时何地，唯一的航站楼

00:09:03.890 --> 00:09:08.480
该部分，但让我们忽略让我们

00:09:06.500 --> 00:09:10.670
忽略它，然后免费运行所有内容

00:09:08.480 --> 00:09:11.900
从这里开始

00:09:10.670 --> 00:09:13.760
从头到尾的一切，如果

00:09:11.900 --> 00:09:17.330
你正在做更大的事情可能是

00:09:13.760 --> 00:09:22.970
将启动定义为

00:09:17.330 --> 00:09:30.910
最初的面孔，所以我真的开始寻找

00:09:22.970 --> 00:09:30.910
在启动之前，一直到JDK 9和

00:09:31.690 --> 00:09:41.150
好每个人的模块系统

00:09:37.100 --> 00:09:44.839
喜欢这些天来的一些地方

00:09:41.150 --> 00:09:48.650
一定程度的初始间接费用德语

00:09:44.839 --> 00:09:51.140
尼宁回归得还不错

00:09:48.650 --> 00:09:53.990
我的工作站，但也许是从我看到的

00:09:51.140 --> 00:09:57.470
启动时90毫秒的启动时间

00:09:53.990 --> 00:10:00.380
在Java 8上的时代我可以看到它们成长为

00:09:57.470 --> 00:10:02.180
 Java在Java 9到110毫秒之间

00:10:00.380 --> 00:10:04.640
您不想看到抢先体验

00:10:02.180 --> 00:10:06.200
我开始执行任务的拼图游戏

00:10:04.640 --> 00:10:09.950
当我开始测量它们时

00:10:06.200 --> 00:10:14.510
大概在250300毫秒内

00:10:09.950 --> 00:10:18.140
范围，但模块系统本身种类

00:10:14.510 --> 00:10:20.570
项目的展开和折叠

00:10:18.140 --> 00:10:23.570
将各种东西放入链接的插件中

00:10:20.570 --> 00:10:26.959
做了很多事情要切掉

00:10:23.570 --> 00:10:29.779
我们发布之前的大量开销

00:10:26.959 --> 00:10:31.760
伽玛9，但我们也看到了

00:10:29.779 --> 00:10:34.400
我是由于你知道

00:10:31.760 --> 00:10:39.529
 VM中的功能积累和

00:10:34.400 --> 00:10:41.990
在其他地方超过三年，这

00:10:39.529 --> 00:10:44.089
比较会增加几毫秒

00:10:41.990 --> 00:10:47.630
仅仅因为我们制造了g1 

00:10:44.089 --> 00:10:54.410
默认，我们添加了支持细分

00:10:47.630 --> 00:10:58.810
代码缓存基本上将c1和

00:10:54.410 --> 00:11:01.940
 c2将代码生成到不同的区域

00:10:58.810 --> 00:11:04.160
而以前它们是混合在一起的

00:11:01.940 --> 00:11:05.720
但是分离本身增加了一个

00:11:04.160 --> 00:11:06.950
一点点间接哪九

00:11:05.720 --> 00:11:09.230
花费一些

00:11:06.950 --> 00:11:12.200
成为虚拟方法的方法，以及

00:11:09.230 --> 00:11:15.340
那边有一点开销

00:11:12.200 --> 00:11:20.030
各种小事加起来

00:11:15.340 --> 00:11:22.370
 JVM CI支持将咆哮作为

00:11:20.030 --> 00:11:24.200
 JAMA中的实验性编译器九个新增

00:11:22.370 --> 00:11:26.270
每个人的开销

00:11:24.200 --> 00:11:29.540
还有其他类似的事情

00:11:26.270 --> 00:11:31.490
我最喜欢的回归是由于虚拟机

00:11:29.540 --> 00:11:35.270
标志约束检查已添加

00:11:31.490 --> 00:11:37.550
在Java 9中，其顺序为

00:11:35.270 --> 00:11:42.320
就像一千五百万条指令

00:11:37.550 --> 00:11:45.170
在每个VN开始时退役只是为了检查

00:11:42.320 --> 00:11:47.410
如果您的命令行参数

00:11:45.170 --> 00:11:50.360
在允许的数字范围内

00:11:47.410 --> 00:11:55.310
所以当没有

00:11:50.360 --> 00:12:01.250
命令行标志都没有，所以我

00:11:55.310 --> 00:12:02.990
开始在那里修理那个，我们

00:12:01.250 --> 00:12:04.130
开始看着你知道我们一直

00:12:02.990 --> 00:12:07.190
看，我一直在看

00:12:04.130 --> 00:12:09.640
优化独特性，因此

00:12:07.190 --> 00:12:12.470
一年，但为您保留了十多年

00:12:09.640 --> 00:12:19.060
争取技术深度，我们

00:12:12.470 --> 00:12:21.680
在德国的nein ja建立了我们

00:12:19.060 --> 00:12:23.300
修复了许多小型图书馆

00:12:21.680 --> 00:12:26.630
和其他运行时优化，例如

00:12:23.300 --> 00:12:30.740
 VM标志检查猫，这样可以割舍您

00:12:26.630 --> 00:12:33.940
知道我的毫秒数

00:12:30.740 --> 00:12:37.760
每个这样的违反

00:12:33.940 --> 00:12:39.590
其他其他其他优化

00:12:37.760 --> 00:12:41.300
来自你认识像托马斯这样的人

00:12:39.590 --> 00:12:43.550
 Quetzal做g1并启动和

00:12:41.300 --> 00:12:46.550
某些产品的占地面积改善

00:12:43.550 --> 00:12:49.220
我们的大客户也有帮助

00:12:46.550 --> 00:12:53.630
标称的，你知道早起

00:12:49.220 --> 00:12:55.820
适用于所有人的Java语言

00:12:53.630 --> 00:12:58.570
知道CD的改进开始

00:12:55.820 --> 00:13:01.730
添加对先前或具有的支持

00:12:58.570 --> 00:13:02.360
组成部分或JDK告诉10 

00:13:01.730 --> 00:13:07.100
在我的机器上

00:13:02.360 --> 00:13:13.670
我们实际上能够回到

00:13:07.100 --> 00:13:17.420
与Java达到收支平衡Java 8我不是

00:13:13.670 --> 00:13:18.890
确定有小的增量

00:13:17.420 --> 00:13:21.080
回归

00:13:18.890 --> 00:13:23.600
在某些措施上，但不是没有

00:13:21.080 --> 00:13:25.220
世界上大多数时候

00:13:23.600 --> 00:13:29.270
有回归

00:13:25.220 --> 00:13:31.870
看到更大的东西，但大多数

00:13:29.270 --> 00:13:35.690
他们在八年中得到解决

00:13:31.870 --> 00:13:44.240
更新，所以开始了八种更新

00:13:35.690 --> 00:13:46.880
以及改善趋势

00:13:44.240 --> 00:13:50.540
不断改进创业项目的项目

00:13:46.880 --> 00:13:53.570
之所以陷入JDK 11中，是因为

00:13:50.540 --> 00:13:55.430
预计将是长期的

00:13:53.570 --> 00:13:58.820
尽早提供支持，所以仍然

00:13:55.430 --> 00:14:03.130
保持这些东西很有趣

00:13:58.820 --> 00:14:05.750
滚动，我们有一点你知道

00:14:03.130 --> 00:14:07.600
意想不到的帮助

00:14:05.750 --> 00:14:10.550
删除一些模块有助于

00:14:07.600 --> 00:14:14.360
至少在

00:14:10.550 --> 00:14:17.750
框架或在11的上下文中

00:14:14.360 --> 00:14:20.180
摆脱Java xml绑定和其他

00:14:17.750 --> 00:14:24.590
其他两个模块

00:14:20.180 --> 00:14:28.340
带入并没有激发出尤里

00:14:24.590 --> 00:14:32.390
保留在jdk中，因为它们可以

00:14:28.340 --> 00:14:34.580
你知道作为依赖项拉入

00:14:32.390 --> 00:14:37.390
通常你应该想要

00:14:34.580 --> 00:14:39.560
你知道我不知道有多少

00:14:37.390 --> 00:14:42.500
我去过的企业系统

00:14:39.560 --> 00:14:46.270
你对杰克的依赖

00:14:42.500 --> 00:14:48.860
是2.1，但您选择的jdk附带

00:14:46.270 --> 00:14:52.010
别人依赖的2.0 

00:14:48.860 --> 00:14:54.920
继续，您有此lib固定路径

00:14:52.010 --> 00:14:58.100
知道所有的乐趣享受

00:14:54.920 --> 00:14:59.870
模块系统想要让您知道获得

00:14:58.100 --> 00:15:03.620
归根到底

00:14:59.870 --> 00:15:07.700
而是很多的悲伤和恩膏

00:15:03.620 --> 00:15:09.950
部署程序库

00:15:07.700 --> 00:15:14.330
优化也在继续，但

00:15:09.950 --> 00:15:17.630
你不知道我们保持良好的下降

00:15:14.330 --> 00:15:22.840
我会说的轨迹，我们继续

00:15:17.630 --> 00:15:25.640
为Java 12挖掘这些是

00:15:22.840 --> 00:15:28.340
幻灯片稍旧，所以我应该

00:15:25.640 --> 00:15:31.010
删除标题中的问号

00:15:28.340 --> 00:15:35.329
在这里，我们继续

00:15:31.010 --> 00:15:38.480
不断改进CD现在可以

00:15:35.329 --> 00:15:41.810
消毒默认模型图，所以我们

00:15:38.480 --> 00:15:44.240
我们在这里拥有设施

00:15:41.810 --> 00:15:45.769
不运行Java代码的地方

00:15:44.240 --> 00:15:49.490
做很多我们要做的事情

00:15:45.769 --> 00:15:52.940
在模块设置过程中，我们只是

00:15:49.490 --> 00:15:54.949
从CD加载结果

00:15:52.940 --> 00:15:57.500
存档，因此我们不必运行您

00:15:54.949 --> 00:15:59.870
知道很多Java 

00:15:57.500 --> 00:16:02.690
引导过程中的代码以进行设置

00:15:59.870 --> 00:16:04.639
我们现在有一个工具箱可以继续

00:16:02.690 --> 00:16:07.070
为我们所有的事情做

00:16:04.639 --> 00:16:08.959
你知道我们每次都在做吗

00:16:07.070 --> 00:16:11.029
开始像创建语言环境和

00:16:08.959 --> 00:16:13.160
这样的字符数据集

00:16:11.029 --> 00:16:15.560
可能会继续这样做，我们有一个

00:16:13.160 --> 00:16:18.290
不错的新工具集，即使我们不是

00:16:15.560 --> 00:16:22.370
尽可能广泛地使用它，但是

00:16:18.290 --> 00:16:25.670
好保持继续的好地方

00:16:22.370 --> 00:16:28.970
用C挖掘所有这些数字

00:16:25.670 --> 00:16:32.389
 CD已启用，还有新东西

00:16:28.970 --> 00:16:34.639
可能会帮助人们进行测试

00:16:32.389 --> 00:16:36.829
在CD上十二岁以上的是CD本质

00:16:34.639 --> 00:16:40.069
默认情况下启用，您不必走

00:16:36.829 --> 00:16:42.649
通过倾销或任何其他形式

00:16:40.069 --> 00:16:45.230
您将准备好基本存档吗

00:16:42.649 --> 00:16:47.420
那将永远有效，并且已经

00:16:45.230 --> 00:16:49.279
进行改进以确保即使

00:16:47.420 --> 00:16:52.790
 CD历史记录不是吗

00:16:49.279 --> 00:16:55.790
为确切的堆大小生成等

00:16:52.790 --> 00:16:58.399
因为它调制了一点

00:16:55.790 --> 00:17:01.519
它允许的一些事情

00:16:58.399 --> 00:17:04.520
对于非常非常快速的修补

00:17:01.519 --> 00:17:07.669
这些档案存储到内存中，所以

00:17:04.520 --> 00:17:12.589
应该永远是一个重要的开始

00:17:07.669 --> 00:17:14.360
是的，当然， 

00:17:12.589 --> 00:17:20.799
未发布我们的局部回归

00:17:14.360 --> 00:17:24.110
正在调查，但你知道，是的，所以

00:17:20.799 --> 00:17:26.350
另一个观点是衡量

00:17:24.110 --> 00:17:30.890
我们执行的字节码数量

00:17:26.350 --> 00:17:33.230
启动过程中的字节数

00:17:30.890 --> 00:17:36.410
我们执行某种转换的代码

00:17:33.230 --> 00:17:40.179
取决于我们是哪种机器

00:17:36.410 --> 00:17:40.179
如果您有一台机器

00:17:41.270 --> 00:17:47.880
好吧，对不起

00:17:44.549 --> 00:17:51.809
如果您运行

00:17:47.880 --> 00:17:55.230
开箱即用的口译员

00:17:51.809 --> 00:17:59.400
经验，所以你会看到玉

00:17:55.230 --> 00:18:01.200
线程快速获取所有其他代码

00:17:59.400 --> 00:18:03.419
您在引导过程中正在运行

00:18:01.200 --> 00:18:08.220
通过尚未优化的系统运行它们

00:18:03.419 --> 00:18:11.330
走开，所以我们看到字节数

00:18:08.220 --> 00:18:14.760
代码执行的移位

00:18:11.330 --> 00:18:20.940
每个人都充满活力

00:18:14.760 --> 00:18:24.960
释放，但是是的，让我们做得很好

00:18:20.940 --> 00:18:27.169
要点是，在Java 9中

00:18:24.960 --> 00:18:32.970
有关引导程序所需代码的数量

00:18:27.169 --> 00:18:35.130
 JVM增加了9倍，然后我们开始

00:18:32.970 --> 00:18:38.370
你知道减少了

00:18:35.130 --> 00:18:42.659
每个机器人都需要执行的机器人代码

00:18:38.370 --> 00:18:45.659
后续版本，但线程

00:18:42.659 --> 00:18:49.230
你知道开始更快还是开始

00:18:45.659 --> 00:18:54.029
在引导周期中更快

00:18:49.230 --> 00:18:57.390
这样很好，最后我们减少执行

00:18:54.029 --> 00:19:00.360
字节码，即使我们在

00:18:57.390 --> 00:19:04.260
在引导中比以前

00:19:00.360 --> 00:19:06.210
无论如何你都会迟到

00:19:04.260 --> 00:19:08.970
可能略有不同的数字

00:19:06.210 --> 00:19:11.279
系统取决于我的课程数

00:19:08.970 --> 00:19:16.370
意味着它可以把你扔的东西

00:19:11.279 --> 00:19:19.289
你的问题知道优化

00:19:16.370 --> 00:19:21.390
否则解释为

00:19:19.289 --> 00:19:24.380
例如，这里的顶部是我的

00:19:21.390 --> 00:19:30.750
双插座工作站

00:19:24.380 --> 00:19:36.120
工作站，它很快就会看到您知道

00:19:30.750 --> 00:19:39.539
从9改进为12 

00:19:36.120 --> 00:19:41.850
导致，你知道我们是我们现在

00:19:39.539 --> 00:19:45.690
比Java 8更快地启动和运行

00:19:41.850 --> 00:19:49.200
但我不，我看不到我有休息

00:19:45.690 --> 00:19:53.320
即使在我的笔记本电脑上，因为它的数量更少

00:19:49.200 --> 00:19:56.710
但仍想利用

00:19:53.320 --> 00:20:02.519
我们所做的改进，但是

00:19:56.710 --> 00:20:13.230
他们现在在Java 13上都非常非常

00:20:02.519 --> 00:20:18.730
无论如何，让我们继续讨论lambdas 

00:20:13.230 --> 00:20:21.580
自从你有八个之后

00:20:18.730 --> 00:20:24.070
引入了lambdas，我们已经

00:20:21.580 --> 00:20:28.539
意识到以下事实： 

00:20:24.070 --> 00:20:33.899
引导lambdas很重

00:20:28.539 --> 00:20:41.950
首次或初始费用

00:20:33.899 --> 00:20:46.950
最初使用Java 8，如果您使用

00:20:41.950 --> 00:20:50.080
最简单的Java Java lambda 

00:20:46.950 --> 00:20:52.509
进行基准测试并运行它，您将看到

00:20:50.080 --> 00:20:58.870
它会有相当的开销

00:20:52.509 --> 00:21:00.580
您知道Java代码中的传统

00:20:58.870 --> 00:21:02.679
一点沉重的一面我

00:21:00.580 --> 00:21:06.429
我可以看到大约90台工作站

00:21:02.679 --> 00:21:10.169
毫秒，我们开始查看

00:21:06.429 --> 00:21:13.529
在Java 9中-很多

00:21:10.169 --> 00:21:18.429
这些调用动态的开销

00:21:13.529 --> 00:21:21.129
拉姆达表厂的事情

00:21:18.429 --> 00:21:25.960
我们清理了很多实施

00:21:21.129 --> 00:21:28.480
在开头的衰变中，我们写了一篇jail 

00:21:25.960 --> 00:21:30.549
允许预生成的插件

00:21:28.480 --> 00:21:34.059
一些甲基手柄或方法

00:21:30.549 --> 00:21:35.980
是的，方法处理的形式像链接

00:21:34.059 --> 00:21:40.240
 lambda形式etcetera有像

00:21:35.980 --> 00:21:42.309
三大要素的构成要素

00:21:40.240 --> 00:21:45.549
金属手柄框架的

00:21:42.309 --> 00:21:48.940
用于实现java.lang的调用

00:21:45.549 --> 00:21:54.519
 d，我们可以削减50％的

00:21:48.940 --> 00:21:57.009
即使如此，lambda的开销也是如此

00:21:54.519 --> 00:22:00.519
然后一般开始回归

00:21:57.009 --> 00:22:01.659
 jama 9好像您的应用程序是一只

00:22:00.519 --> 00:22:05.230
或你实际上是几个lambda 

00:22:01.659 --> 00:22:07.870
即使在九点上也有所改善

00:22:05.230 --> 00:22:11.140
而且我们在九点和十点不断改进

00:22:07.870 --> 00:22:13.690
我也意识到

00:22:11.140 --> 00:22:17.380
该方法处理自适应适配器的东西

00:22:13.690 --> 00:22:20.169
我们在建立第一个

00:22:17.380 --> 00:22:21.820
最初调用lambda是

00:22:20.169 --> 00:22:24.909
实际上是不必要的和人工的

00:22:21.820 --> 00:22:27.159
我们没有使用静态类型

00:22:24.909 --> 00:22:28.990
代码中的信息称为

00:22:27.159 --> 00:22:33.600
引导方法，所以我们修复了

00:22:28.990 --> 00:22:33.600
摆脱了另外75％的哦

