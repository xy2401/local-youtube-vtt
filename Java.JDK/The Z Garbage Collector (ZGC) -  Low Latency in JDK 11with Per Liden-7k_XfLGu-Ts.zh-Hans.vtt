WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.410 --> 00:00:07.890
嗨，欢迎来到

00:00:06.690 --> 00:00:10.559
说垃圾收集器

00:00:07.890 --> 00:00:13.410
我是小馅饼，我是工程师

00:00:10.559 --> 00:00:16.280
 Oracle的Java平台小组致力于

00:00:13.410 --> 00:00:16.280
垃圾收集

00:00:18.970 --> 00:00:24.289
因此，我将首先概述

00:00:21.770 --> 00:00:26.060
 UC是什么以及它如何工作，我们将

00:00:24.289 --> 00:00:28.700
看看一些性能数字

00:00:26.060 --> 00:00:31.990
最后，我将向您展示如何获得

00:00:28.700 --> 00:00:31.990
开始使用CGC 

00:00:33.430 --> 00:00:39.649
所以说你看到是一个新的垃圾

00:00:37.160 --> 00:00:41.360
可用的收集器有一个

00:00:39.649 --> 00:00:46.839
开始的实验功能

00:00:41.360 --> 00:00:49.579
我们描述的JDK 11表示您认为

00:00:46.839 --> 00:00:52.250
可扩展的低延迟垃圾收集器

00:00:49.579 --> 00:00:54.290
并变得更好一点

00:00:52.250 --> 00:00:56.300
了解我们的意思

00:00:54.290 --> 00:01:00.320
让我们来看看我们的目标

00:00:56.300 --> 00:01:03.620
在设计时要牢记，所以当我们

00:01:00.320 --> 00:01:06.619
说这是一个低延迟的GC，我们的意思是

00:01:03.620 --> 00:01:09.380
 GC发布时间永远不会超过10 

00:01:06.619 --> 00:01:12.679
毫秒，当我们说这是

00:01:09.380 --> 00:01:15.020
可扩展性是指该GC可以处理

00:01:12.679 --> 00:01:19.720
从小到大的堆

00:01:15.020 --> 00:01:19.720
其中很大意味着数兆兆字节

00:01:20.140 --> 00:01:26.090
以下是一些主要功能

00:01:22.909 --> 00:01:28.190
说你看到的是核心

00:01:26.090 --> 00:01:31.759
并发垃圾收集器

00:01:28.190 --> 00:01:35.210
意味着所有沉重的重担

00:01:31.759 --> 00:01:37.909
当您的线程继续时，GC已完成

00:01:35.210 --> 00:01:40.490
执行这样的标记

00:01:37.909 --> 00:01:42.770
压实和所有其他昂贵的

00:01:40.490 --> 00:01:45.829
操作不停地处理

00:01:42.770 --> 00:01:48.680
 Java线程说您当前看到

00:01:45.829 --> 00:01:50.719
在引擎盖下只有一代

00:01:48.680 --> 00:01:53.479
它使用负载屏障和呼叫者

00:01:50.719 --> 00:01:56.960
指针作为主要技术

00:01:53.479 --> 00:02:00.079
实现基于区域的并发

00:01:56.960 --> 00:02:02.420
这意味着堆被分割了

00:02:00.079 --> 00:02:05.180
进入许多较小的地区，并说你

00:02:02.420 --> 00:02:07.159
看到可以选择只压缩一个子集

00:02:05.180 --> 00:02:10.340
在那些通常包含

00:02:07.159 --> 00:02:15.519
最垃圾，也是努玛的衣服

00:02:10.340 --> 00:02:19.579
所以当一个作业对象或javathread 

00:02:15.519 --> 00:02:21.980
分配一个对象，该对象将是

00:02:19.579 --> 00:02:26.590
分配给本地内存

00:02:21.980 --> 00:02:29.319
 CPU钥匙道具

00:02:26.590 --> 00:02:32.590
你说过你看到的是发布时间

00:02:29.319 --> 00:02:35.770
不随堆大小增加或

00:02:32.590 --> 00:02:37.810
保持其大小，因此无论是否

00:02:35.770 --> 00:02:40.599
你有一堆或一堆

00:02:37.810 --> 00:02:43.240
 TB级的发布时间将不会

00:02:40.599 --> 00:02:45.680
受此影响

00:02:43.240 --> 00:02:48.890
让我们快速看一下

00:02:45.680 --> 00:02:51.560
当你说你正在收集时发生

00:02:48.890 --> 00:02:54.470
垃圾，这张照片告诉你什么

00:02:51.560 --> 00:02:57.130
 GC周期看起来像您看到的内部

00:02:54.470 --> 00:03:00.080
它经历的不同地方

00:02:57.130 --> 00:03:03.740
这里的蓝色箭头指向下方

00:03:00.080 --> 00:03:05.960
代表这些力量和灰色箭头

00:03:03.740 --> 00:03:09.050
指向侧面表示并发

00:03:05.960 --> 00:03:11.870
阶段，让我引导您完成GC 

00:03:09.050 --> 00:03:14.799
循环并简要描述正在发生的事情

00:03:11.870 --> 00:03:18.019
在每个阶段中

00:03:14.799 --> 00:03:20.659
所以循环从标记开始

00:03:18.019 --> 00:03:23.209
暂停，这是线程堆栈所在的位置

00:03:20.659 --> 00:03:27.219
扫描以找到这些对象的指针

00:03:23.209 --> 00:03:29.870
对象指针也称为路由

00:03:27.219 --> 00:03:33.439
然后，我们继续并发标记

00:03:29.870 --> 00:03:36.680
阶段，这是一个

00:03:33.439 --> 00:03:39.079
 GC运行的昂贵操作

00:03:36.680 --> 00:03:44.209
整个对象图并标记

00:03:39.079 --> 00:03:45.700
它发现的物体是真实的，然后我们来到

00:03:44.209 --> 00:03:48.319
标记和暂停这是一个

00:03:45.700 --> 00:03:51.019
同步点以协调

00:03:48.319 --> 00:03:54.379
标记阶段结束，一旦完成

00:03:51.019 --> 00:03:56.359
已经到达GC现在已经完成

00:03:54.379 --> 00:03:58.040
母狮信息，因此它知道哪个

00:03:56.359 --> 00:04:01.099
对象是活动的，是垃圾

00:03:58.040 --> 00:04:03.880
现在我们过渡到并发

00:04:01.099 --> 00:04:06.250
准备搬迁阶段

00:04:03.880 --> 00:04:08.860
在这个阶段发生了很多事情

00:04:06.250 --> 00:04:10.960
但我只强调其中两个

00:04:08.860 --> 00:04:13.330
这里有趣的部分是

00:04:10.960 --> 00:04:17.080
参考处理和重定位集

00:04:13.330 --> 00:04:19.750
选择，因此参考处理是

00:04:17.080 --> 00:04:23.100
 GC负责软周的工作， 

00:04:19.750 --> 00:04:25.870
幻像引用和定稿以及

00:04:23.100 --> 00:04:28.330
重定位集选择在哪里

00:04:25.870 --> 00:04:31.540
 GC会找出

00:04:28.330 --> 00:04:36.100
堆需要压缩以释放

00:04:31.540 --> 00:04:38.770
记忆，然后我们过渡到

00:04:36.100 --> 00:04:41.740
搬迁阶段始于

00:04:38.770 --> 00:04:44.320
在线程堆栈处重新定位开始暂停

00:04:41.740 --> 00:04:49.150
进行扫描以处理根源指向

00:04:44.320 --> 00:04:51.220
进入位置集，然后我们来

00:04:49.150 --> 00:04:54.130
到并发搬迁的面孔，这

00:04:51.220 --> 00:04:56.830
是压实的繁重工作

00:04:54.130 --> 00:04:59.260
堆发生并通过压缩

00:04:56.830 --> 00:05:02.080
堆GC将释放大空间

00:04:59.260 --> 00:05:04.210
连续的内存块和

00:05:02.080 --> 00:05:06.050
该内存可用于新

00:05:04.210 --> 00:05:11.360
分配

00:05:06.050 --> 00:05:14.479
这样就完成了我想要的耶稣圣像

00:05:11.360 --> 00:05:18.050
在这里指出耶稣循环

00:05:14.479 --> 00:05:19.849
我们在这里会很短

00:05:18.050 --> 00:05:22.129
我之前提到我为什么说

00:05:19.849 --> 00:05:24.020
你看可以将这些力量保持在10以下

00:05:22.129 --> 00:05:26.960
毫秒是因为没有沉重的负担

00:05:24.020 --> 00:05:29.599
在下颚威胁时完成

00:05:26.960 --> 00:05:31.250
停止了这里所有的一切

00:05:29.599 --> 00:05:35.060
本质上是扫描或威胁堆栈

00:05:31.250 --> 00:05:38.790
这通常可以很好地完成

00:05:35.060 --> 00:05:41.320
在10毫秒内

00:05:38.790 --> 00:05:44.470
好吧，让我们来看一些

00:05:41.320 --> 00:05:47.770
性能数字可以向您显示

00:05:44.470 --> 00:05:50.190
从观众那里给我们打分，进行比较

00:05:47.770 --> 00:05:53.530
说你用并行GC和g1看到

00:05:50.190 --> 00:05:56.140
 spec jb b是著名的java基准

00:05:53.530 --> 00:05:59.260
最多产生两个得分j ups和

00:05:56.140 --> 00:06:01.480
关键jups max yelps是原始的

00:05:59.260 --> 00:06:03.760
吞吐率得分，而关键因素是

00:06:01.480 --> 00:06:07.780
潜伏期敏感分数显示

00:06:03.760 --> 00:06:10.000
根据SLA和

00:06:07.780 --> 00:06:12.460
我们可以在这个基准上看到你说的

00:06:10.000 --> 00:06:15.220
您看到的与并行GC相当，并且

00:06:12.460 --> 00:06:17.680
原始吞吐量为g1 

00:06:15.220 --> 00:06:19.300
说你看到了

00:06:17.680 --> 00:06:22.480
其他收藏家

00:06:19.300 --> 00:06:24.520
延迟敏感分数，这是

00:06:22.480 --> 00:06:29.470
当然要感谢小成本

00:06:24.520 --> 00:06:31.900
在这里，我们有GC的发布时间

00:06:29.470 --> 00:06:34.900
基准相同的浅蓝色条

00:06:31.900 --> 00:06:37.360
这里显示每个的平均发布时间

00:06:34.900 --> 00:06:40.180
 GC和黑色部分显示最差

00:06:37.360 --> 00:06:43.900
发布时间，然后我们有一些

00:06:40.180 --> 00:06:46.990
职位之间的百分比更高

00:06:43.900 --> 00:06:49.210
 cdc的时间几乎不在这里注册

00:06:46.990 --> 00:06:53.620
更好地了解正在发生的事情

00:06:49.210 --> 00:06:56.220
让我切换时间轴以使用

00:06:53.620 --> 00:06:56.220
对数刻度

00:06:57.600 --> 00:07:04.000
这样，现在我们可以看到

00:07:01.150 --> 00:07:06.940
 CDC的平均发布时间约为1 

00:07:04.000 --> 00:07:09.790
毫秒，最差的发布时间

00:07:06.940 --> 00:07:12.340
大约两毫秒，这很好

00:07:09.790 --> 00:07:15.670
低于萨杜迪的目标

00:07:12.340 --> 00:07:17.860
暂停时间超过10毫秒

00:07:15.670 --> 00:07:21.850
对比我们可以看到另一个

00:07:17.860 --> 00:07:24.340
收藏家的平均发帖时间

00:07:21.850 --> 00:07:26.830
在150到200毫秒之间

00:07:24.340 --> 00:07:29.510
最差的发布时间约为300 

00:07:26.830 --> 00:07:31.570
到500毫秒

00:07:29.510 --> 00:07:31.570
您

00:07:32.200 --> 00:07:36.540
让我们来看看你需要

00:07:33.160 --> 00:07:39.580
知道开始使用说你明白

00:07:36.540 --> 00:07:42.010
首先有一个新的JVM选项

00:07:39.580 --> 00:07:46.270
使说你看到，这叫做

00:07:42.010 --> 00:07:47.830
您说您看到了，因为这仍然是

00:07:46.270 --> 00:07:50.080
实验功能，您还需要

00:07:47.830 --> 00:07:55.030
提供解锁实验性选项

00:07:50.080 --> 00:07:57.910
功能和关于调整的几句话

00:07:55.030 --> 00:08:00.670
首先我们一直在努力

00:07:57.910 --> 00:08:02.770
说你觉得容易做

00:08:00.670 --> 00:08:04.050
避免暴露很多GC调整

00:08:02.770 --> 00:08:07.090
选项

00:08:04.050 --> 00:08:09.790
主要的调整选项是设置

00:08:07.090 --> 00:08:11.800
最大堆大小，并且由于所说的UC是一个

00:08:09.790 --> 00:08:15.730
您需要选择的并发收集器

00:08:11.800 --> 00:08:17.860
首先最大的最大堆大小

00:08:15.730 --> 00:08:20.290
可以容纳您的现场演出

00:08:17.860 --> 00:08:22.860
应用程序，但您还需要

00:08:20.290 --> 00:08:24.850
堆中有足够的净空以允许

00:08:22.860 --> 00:08:27.280
要分配的分配

00:08:24.850 --> 00:08:29.290
 G跑了多少

00:08:27.280 --> 00:08:31.960
您需要的净空高度取决于

00:08:29.290 --> 00:08:35.860
分配率和现场布置

00:08:31.960 --> 00:08:38.140
您的应用程序大小和一般

00:08:35.860 --> 00:08:40.600
你给更多的记忆说你看到

00:08:38.140 --> 00:08:43.450
更好，但同时您却没有

00:08:40.600 --> 00:08:46.030
想浪费内存，所以一切都在这里

00:08:43.450 --> 00:08:49.870
在内存使用之间找到平衡

00:08:46.030 --> 00:08:52.480
以及GC需要多久运行一次

00:08:49.870 --> 00:08:54.250
您可能想要的第二个调谐器选项

00:08:52.480 --> 00:08:57.310
要看的是设置

00:08:54.250 --> 00:08:59.920
并发GC线程表示UC具有

00:08:57.310 --> 00:09:03.160
启发式选择此数字，然后

00:08:59.920 --> 00:09:05.050
这通常效果很好，但是取决于

00:09:03.160 --> 00:09:08.050
您正在运行哪种类型的工作负载

00:09:05.050 --> 00:09:10.840
可能要调整此选项

00:09:08.050 --> 00:09:13.780
基本上说多少CPU时间

00:09:10.840 --> 00:09:15.970
你愿意给GC，如果

00:09:13.780 --> 00:09:18.100
你给它太多，那么GC会

00:09:15.970 --> 00:09:20.620
从您的服务器上窃取过多的CPU时间

00:09:18.100 --> 00:09:23.590
申请，但另一方面

00:09:20.620 --> 00:09:26.860
此数字太低，则GC可能

00:09:23.590 --> 00:09:29.490
无法跟上，那就是

00:09:26.860 --> 00:09:32.290
基本上是调音

00:09:29.490 --> 00:09:34.210
还有其他一些选择，但是这些

00:09:32.290 --> 00:09:37.620
是您要选择的两个主要选项

00:09:34.210 --> 00:09:37.620
看一下调音台

00:09:38.339 --> 00:09:43.680
启用日志记录，我建议您使用

00:09:41.100 --> 00:09:46.319
以下两个选项之一X日志

00:09:43.680 --> 00:09:49.439
 GC将为您提供基本的日志记录

00:09:46.319 --> 00:09:51.509
每行GC每行打印一行

00:09:49.439 --> 00:09:54.899
仅提供高级信息

00:09:51.509 --> 00:09:57.600
例如触发GC的原因，以及

00:09:54.899 --> 00:10:01.559
堆大小或堆使用量是多少

00:09:57.600 --> 00:10:04.249
 GC X log GC星号之前和之后

00:10:01.559 --> 00:10:07.649
将为您提供更详细的日志记录

00:10:04.249 --> 00:10:09.689
这在调优或如果您

00:10:07.649 --> 00:10:12.499
只想了解更多信息

00:10:09.689 --> 00:10:12.499
引擎盖下继续

00:10:12.610 --> 00:10:18.980
 Sadducees目前仅在

00:10:15.200 --> 00:10:21.290
 Linux x86 64位其他平台

00:10:18.980 --> 00:10:24.940
如果将来可能会支持

00:10:21.290 --> 00:10:24.940
对他们有足够的需求

00:10:25.060 --> 00:10:30.680
综上所述，UC提供了低

00:10:28.340 --> 00:10:33.680
延迟时间低于发布时间

00:10:30.680 --> 00:10:36.200
 10毫秒可扩展，因此您可以

00:10:33.680 --> 00:10:40.240
有一大堆而不影响

00:10:36.200 --> 00:10:46.250
 GC暂停时间很容易调整和

00:10:40.240 --> 00:10:47.990
您可以在JDK 11中找到它

00:10:46.250 --> 00:10:52.240
您看到的其他信息

00:10:47.990 --> 00:10:52.240
在开放的JDK Wiki上

00:10:53.570 --> 00:11:00.110
立即从Oracle comm下载JDK 11 / 

00:10:57.380 --> 00:11:02.660
 Java下载，如果您有兴趣

00:11:00.110 --> 00:11:06.320
参与开放的JDK开发

00:11:02.660 --> 00:11:08.360
打开JDK java.net或可以

00:11:06.320 --> 00:11:11.890
在Twitter上关注我们以获取新闻和

00:11:08.360 --> 00:11:16.029
更新感谢您的观看

00:11:11.890 --> 00:11:16.029
 [音乐] 

