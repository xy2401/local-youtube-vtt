WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.470 --> 00:00:06.960
 [音乐] 

00:00:03.410 --> 00:00:09.660
嗨，欢迎来到现场的这个截屏视频

00:00:06.960 --> 00:00:11.790
垃圾收集器，我是苍白球，我是

00:00:09.660 --> 00:00:16.280
工程师在Java平台组

00:00:11.790 --> 00:00:16.280
甲骨文致力于垃圾收集

00:00:19.000 --> 00:00:24.290
因此，我将首先概述

00:00:21.770 --> 00:00:26.060
 UC是什么以及它如何工作，我们将

00:00:24.290 --> 00:00:28.700
看看一些性能数字

00:00:26.060 --> 00:00:32.020
最后，我将向您展示如何获得

00:00:28.700 --> 00:00:32.020
开始使用CGC 

00:00:33.420 --> 00:00:39.640
所以说你看到是一个新的垃圾

00:00:37.180 --> 00:00:41.379
可用的收集器有一个

00:00:39.640 --> 00:00:46.860
开始的实验功能

00:00:41.379 --> 00:00:49.600
我们描述的JDK 11表示您认为

00:00:46.860 --> 00:00:52.239
可扩展的低延迟垃圾收集器

00:00:49.600 --> 00:00:54.309
并变得更好一点

00:00:52.239 --> 00:00:56.440
了解我们的意思

00:00:54.309 --> 00:01:00.670
让我们来看看我们的目标

00:00:56.440 --> 00:01:04.449
在设计时要注意，所以当我们说

00:01:00.670 --> 00:01:07.330
这是一个低延迟的GC，我们的意思是GC 

00:01:04.449 --> 00:01:10.539
后次不会超过10毫秒

00:01:07.330 --> 00:01:13.660
当我们说它是可扩展的时，我们的意思是

00:01:10.539 --> 00:01:16.149
该GC可以处理堆范围

00:01:13.660 --> 00:01:21.340
从小到大，我们非常

00:01:16.149 --> 00:01:23.530
大意味着这里有数TB 

00:01:21.340 --> 00:01:26.649
您说的一些主要特征

00:01:23.530 --> 00:01:29.350
从本质上说，UC是并发的

00:01:26.649 --> 00:01:33.130
垃圾收集器意味着所有

00:01:29.350 --> 00:01:35.910
 GC完成了繁重的工作

00:01:33.130 --> 00:01:39.130
当您的线程继续执行时

00:01:35.910 --> 00:01:41.349
所以像标记压实

00:01:39.130 --> 00:01:43.149
所有其他昂贵的操作

00:01:41.349 --> 00:01:46.539
处理不停止Java 

00:01:43.149 --> 00:01:49.720
线程说UC目前只有一个

00:01:46.539 --> 00:01:52.450
在引擎盖下产生负荷

00:01:49.720 --> 00:01:55.840
障碍和呼叫者指针为主要对象

00:01:52.450 --> 00:01:59.319
实现并发的技术

00:01:55.840 --> 00:02:01.869
基于区域的表示堆

00:01:59.319 --> 00:02:04.539
分为许多更小的区域和

00:02:01.869 --> 00:02:06.700
说你看到只能选择紧凑

00:02:04.539 --> 00:02:09.759
通常是那些

00:02:06.700 --> 00:02:14.800
包含最多的垃圾，而且

00:02:09.759 --> 00:02:18.730
 Numa穿着，所以当工作对象或

00:02:14.800 --> 00:02:21.069
 javathread分配一个对象

00:02:18.730 --> 00:02:24.360
对象将在内存中分配的

00:02:21.069 --> 00:02:24.360
对于CPU是本地的

00:02:25.050 --> 00:02:31.930
保持财产的说，你看到的是

00:02:28.090 --> 00:02:35.320
大多数时候不随堆增加

00:02:31.930 --> 00:02:37.540
大小或实际大小，因此不会

00:02:35.320 --> 00:02:40.600
无论您有一个演出堆还是一个

00:02:37.540 --> 00:02:43.270
 1 TB II发布时间将不会

00:02:40.600 --> 00:02:45.680
受此影响

00:02:43.270 --> 00:02:48.890
让我们快速看一下

00:02:45.680 --> 00:02:51.590
当你说你正在收集时发生

00:02:48.890 --> 00:02:54.470
垃圾，这张照片告诉你什么

00:02:51.590 --> 00:02:57.130
 GC周期看起来像您看到的内部

00:02:54.470 --> 00:03:00.080
它经历的不同地方

00:02:57.130 --> 00:03:03.290
这里的蓝色箭头指向下方

00:03:00.080 --> 00:03:05.510
代表这些力量和灰色

00:03:03.290 --> 00:03:08.270
指向侧面的箭头表示

00:03:05.510 --> 00:03:11.540
并行阶段，所以让我带你

00:03:08.270 --> 00:03:14.860
通过GC周期和简要说明

00:03:11.540 --> 00:03:18.019
这些阶段的每个阶段都发生了什么

00:03:14.860 --> 00:03:20.689
所以循环从标记开始

00:03:18.019 --> 00:03:23.209
暂停，这是线程堆栈所在的位置

00:03:20.689 --> 00:03:27.250
扫描以找到这些对象的指针

00:03:23.209 --> 00:03:29.659
对象指针也称为路由

00:03:27.250 --> 00:03:33.470
然后我们继续并发

00:03:29.659 --> 00:03:36.680
标记阶段，这是一个

00:03:33.470 --> 00:03:39.109
 GC运行的昂贵操作

00:03:36.680 --> 00:03:44.209
整个对象图并标记

00:03:39.109 --> 00:03:45.730
它发现的物体是真实的，然后我们来到

00:03:44.209 --> 00:03:48.319
市场和暂停，这是一个

00:03:45.730 --> 00:03:51.019
同步点以协调

00:03:48.319 --> 00:03:54.379
标记阶段结束，一旦完成

00:03:51.019 --> 00:03:56.389
已经到达GC现在已经完成

00:03:54.379 --> 00:03:58.069
母狮信息，因此它知道哪个

00:03:56.389 --> 00:04:01.129
对象是活动的，是垃圾

00:03:58.069 --> 00:04:03.890
现在我们过渡到并发

00:04:01.129 --> 00:04:06.260
准备搬迁阶段

00:04:03.890 --> 00:04:08.870
在这个阶段发生了很多事情

00:04:06.260 --> 00:04:10.970
但我只强调其中两个

00:04:08.870 --> 00:04:13.340
这里有趣的部分是

00:04:10.970 --> 00:04:17.090
参考处理和重定位集

00:04:13.340 --> 00:04:19.760
选择，因此参考处理是

00:04:17.090 --> 00:04:23.110
 GC负责软周的工作， 

00:04:19.760 --> 00:04:25.880
幻像引用和定稿以及

00:04:23.110 --> 00:04:28.340
重定位集选择在哪里

00:04:25.880 --> 00:04:31.550
 GC会找出

00:04:28.340 --> 00:04:36.110
堆需要压缩以释放

00:04:31.550 --> 00:04:38.780
记忆，然后我们过渡到

00:04:36.110 --> 00:04:41.780
搬迁阶段始于

00:04:38.780 --> 00:04:44.330
将启动池移至线程堆栈所在的位置

00:04:41.780 --> 00:04:49.160
进行扫描以处理根源指向

00:04:44.330 --> 00:04:51.260
进入位置集，然后我们来

00:04:49.160 --> 00:04:54.140
到并发搬迁的面孔，这

00:04:51.260 --> 00:04:56.840
是压实的繁重工作

00:04:54.140 --> 00:04:59.270
堆发生并通过压缩

00:04:56.840 --> 00:05:02.090
堆GC将释放大空间

00:04:59.270 --> 00:05:04.220
连续的内存块和

00:05:02.090 --> 00:05:06.080
该内存可用于新

00:05:04.220 --> 00:05:11.389
分配

00:05:06.080 --> 00:05:14.479
这样就完成了我想要的耶稣圣像

00:05:11.389 --> 00:05:18.050
在这里指出耶稣的偶像

00:05:14.479 --> 00:05:19.970
我们在这里会很短

00:05:18.050 --> 00:05:22.129
我之前提到我为什么说

00:05:19.970 --> 00:05:24.020
你可以把这些力量低于10 

00:05:22.129 --> 00:05:26.960
毫秒是因为没有沉重的负担

00:05:24.020 --> 00:05:29.599
在下颚威胁时完成

00:05:26.960 --> 00:05:31.280
停止了这里所有的一切

00:05:29.599 --> 00:05:35.060
本质上是扫描或威胁堆栈

00:05:31.280 --> 00:05:38.800
这通常可以很好地完成

00:05:35.060 --> 00:05:38.800
在10毫秒内

00:05:38.820 --> 00:05:44.470
好吧，让我们来看一些

00:05:41.320 --> 00:05:47.770
性能数字可以向您显示

00:05:44.470 --> 00:05:49.810
从观众那里给我们打分，进行比较

00:05:47.770 --> 00:05:53.020
说你看到用并行GC和G 

00:05:49.810 --> 00:05:55.540
一个规范jb b是著名的java 

00:05:53.020 --> 00:05:57.190
产生最大两个分数的基准

00:05:55.540 --> 00:06:00.010
暴跌和关键暴跌

00:05:57.190 --> 00:06:01.510
最大j UPS是行吞吐量得分

00:06:00.010 --> 00:06:03.760
而关键的起伏是

00:06:01.510 --> 00:06:07.810
潜伏期敏感分数显示

00:06:03.760 --> 00:06:10.000
根据SLA和

00:06:07.810 --> 00:06:12.490
我们可以在这个基准上看到你说的

00:06:10.000 --> 00:06:14.950
您看到的与并行GC相当，并且

00:06:12.490 --> 00:06:17.830
行吞吐量为G一

00:06:14.950 --> 00:06:19.600
说你看到了

00:06:17.830 --> 00:06:22.630
其他收藏家

00:06:19.600 --> 00:06:27.520
潜伏期敏感分数，这是

00:06:22.630 --> 00:06:29.590
当然要感谢这里的低成本时间

00:06:27.520 --> 00:06:32.620
我们有相同的GC发布时间

00:06:29.590 --> 00:06:35.650
基准显示此处显示的浅蓝色条

00:06:32.620 --> 00:06:37.930
每个GC的平均发布时间，以及

00:06:35.650 --> 00:06:40.419
黑色部分显示最差的发布时间

00:06:37.930 --> 00:06:44.140
然后我们有一些较高

00:06:40.419 --> 00:06:47.710
发布时间之间的百分位

00:06:44.140 --> 00:06:49.600
 CDC几乎没有在这里注册，因此

00:06:47.710 --> 00:06:53.500
更好地了解正在发生的事情

00:06:49.600 --> 00:06:56.250
我切换时间轴以使用

00:06:53.500 --> 00:06:56.250
对数刻度

00:06:57.610 --> 00:07:04.009
这样，现在我们可以看到

00:07:01.159 --> 00:07:06.740
 CDC的平均发布时间约为1 

00:07:04.009 --> 00:07:09.319
最差的强制时间毫秒

00:07:06.740 --> 00:07:12.050
大约两毫秒，这是

00:07:09.319 --> 00:07:14.330
远低于萨杜迪的永不实现目标

00:07:12.050 --> 00:07:17.870
具有停顿超过10毫秒

00:07:14.330 --> 00:07:21.860
相反，我们可以看到另一个

00:07:17.870 --> 00:07:24.349
收藏家的平均发帖时间

00:07:21.860 --> 00:07:26.840
在150到200毫秒之间

00:07:24.349 --> 00:07:30.250
最差的发布时间约为300 

00:07:26.840 --> 00:07:30.250
到500毫秒

00:07:31.000 --> 00:07:36.550
让我们来看看您需要

00:07:33.170 --> 00:07:39.620
知道开始使用说你明白

00:07:36.550 --> 00:07:42.020
首先有一个新的JVM选项

00:07:39.620 --> 00:07:46.280
使说你看到，这叫做

00:07:42.020 --> 00:07:47.930
您说您看到了，因为这仍然是

00:07:46.280 --> 00:07:50.090
实验功能，您还需要

00:07:47.930 --> 00:07:55.040
提供解锁额外的租赁选项

00:07:50.090 --> 00:07:58.040
功能和关于调整的几句话

00:07:55.040 --> 00:08:00.680
首先我们一直在努力

00:07:58.040 --> 00:08:02.780
说你觉得容易做

00:08:00.680 --> 00:08:04.060
避免暴露很多GC调整

00:08:02.780 --> 00:08:07.100
选项

00:08:04.060 --> 00:08:09.770
主要的调整选项是设置

00:08:07.100 --> 00:08:11.630
最大堆大小，因为说你看到的是

00:08:09.770 --> 00:08:15.440
您需要的并发收集器

00:08:11.630 --> 00:08:17.690
选择最合适的最大堆大小

00:08:15.440 --> 00:08:20.270
所有可以容纳现场的

00:08:17.690 --> 00:08:21.950
你的应用程序，但你还需要

00:08:20.270 --> 00:08:24.860
堆中有足够的空间

00:08:21.950 --> 00:08:27.290
允许分配服务

00:08:24.860 --> 00:08:29.300
 G跑了多少

00:08:27.290 --> 00:08:31.970
您需要的净空高度取决于

00:08:29.300 --> 00:08:35.360
分配率和现场布置

00:08:31.970 --> 00:08:37.910
您的应用程序和一般大小

00:08:35.360 --> 00:08:40.460
你给我的记忆越多，你看到的

00:08:37.910 --> 00:08:43.220
更好，但同时

00:08:40.460 --> 00:08:45.500
不想浪费内存，仅此而已

00:08:43.220 --> 00:08:48.880
关于在记忆之间找到平衡

00:08:45.500 --> 00:08:51.860
使用情况以及GC需要运行的频率

00:08:48.880 --> 00:08:54.260
您可能会选择的第二个调谐器选项

00:08:51.860 --> 00:08:57.320
想看的是设置数量

00:08:54.260 --> 00:08:59.900
并发GC线程表示UC具有

00:08:57.320 --> 00:09:03.170
启发式选择此数字，然后

00:08:59.900 --> 00:09:05.060
这通常效果很好，但是取决于

00:09:03.170 --> 00:09:08.060
您正在运行哪种类型的工作负载

00:09:05.060 --> 00:09:10.850
可能要调整此选项

00:09:08.060 --> 00:09:13.790
基本上说多少CPU时间

00:09:10.850 --> 00:09:15.980
你愿意给GC，如果

00:09:13.790 --> 00:09:18.140
你给它太多，那么GC会

00:09:15.980 --> 00:09:20.630
从您的服务器上窃取过多的CPU时间

00:09:18.140 --> 00:09:23.600
申请，但另一方面

00:09:20.630 --> 00:09:26.870
此数字太低，则GC可能

00:09:23.600 --> 00:09:29.500
无法跟上，那就是

00:09:26.870 --> 00:09:32.300
基本上是调音

00:09:29.500 --> 00:09:34.220
还有其他一些选择，但是这些

00:09:32.300 --> 00:09:37.630
是您要选择的两个主要选项

00:09:34.220 --> 00:09:37.630
看一下调音台

00:09:38.140 --> 00:09:43.690
启用日志记录，我建议您使用

00:09:41.110 --> 00:09:46.300
以下两个选项之一X日志

00:09:43.690 --> 00:09:49.450
 GC将为您提供基本的日志记录

00:09:46.300 --> 00:09:51.520
每行GC每行打印一行

00:09:49.450 --> 00:09:54.850
仅提供高级信息

00:09:51.520 --> 00:09:57.610
例如触发GC的原因，以及

00:09:54.850 --> 00:10:01.570
堆大小或堆使用量是多少

00:09:57.610 --> 00:10:04.290
 GC X log GC星号之前和之后

00:10:01.570 --> 00:10:07.660
将为您提供更详细的日志记录

00:10:04.290 --> 00:10:09.700
这在调优或如果您

00:10:07.660 --> 00:10:12.600
只想了解更多信息

00:10:09.700 --> 00:10:12.600
引擎盖下继续

00:10:12.640 --> 00:10:19.010
目前仅在

00:10:15.230 --> 00:10:21.320
 linux x86 64位其他平台

00:10:19.010 --> 00:10:24.940
如果将来可能会支持

00:10:21.320 --> 00:10:24.940
对他们有足够的需求

00:10:25.060 --> 00:10:30.710
所以总结说你看到报价低

00:10:28.370 --> 00:10:33.680
延迟时间低于发布时间

00:10:30.710 --> 00:10:36.230
 10毫秒的可扩展性，因此您可以

00:10:33.680 --> 00:10:41.270
有一大堆而不影响

00:10:36.230 --> 00:10:46.280
 GC发布时间很容易调整，而且

00:10:41.270 --> 00:10:47.990
您可以在JDK 11中找到

00:10:46.280 --> 00:10:52.240
您看到的其他信息

00:10:47.990 --> 00:10:52.240
在开放的JDK Wiki上

00:10:53.580 --> 00:11:00.330
立即从Oracle comm下载JDK 11 / 

00:10:57.390 --> 00:11:02.670
 Java下载，如果您有兴趣

00:11:00.330 --> 00:11:06.330
参与开放的JDK开发

00:11:02.670 --> 00:11:08.400
打开JDK java.net或可以

00:11:06.330 --> 00:11:11.900
在Twitter上关注我们以获取新闻和

00:11:08.400 --> 00:11:16.039
更新感谢您的观看

00:11:11.900 --> 00:11:16.039
 [音乐] 

