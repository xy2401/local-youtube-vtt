WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.030 --> 00:00:17.400
是的，没事，我希望我希望

00:00:11.849 --> 00:00:20.430
我没跟静音说话

00:00:17.400 --> 00:00:24.199
我希望我也不要讲静音

00:00:20.430 --> 00:00:28.170
我可以通过任何方式找出

00:00:24.199 --> 00:00:31.619
好吧，我很好，谢谢

00:00:28.170 --> 00:00:33.660
欢迎大家，我想我不是

00:00:31.619 --> 00:00:37.230
要做现在的礼物

00:00:33.660 --> 00:00:40.640
我自己搬家，现在我是Eric，我要

00:00:37.230 --> 00:00:43.469
讨论并发类加载和

00:00:40.640 --> 00:00:47.489
在我们开始之前，我必须提供

00:00:43.469 --> 00:00:48.989
这个有趣的安全港声明

00:00:47.489 --> 00:00:52.739
基本上说你什么都不信任

00:00:48.989 --> 00:00:54.809
我说，但是幸运的是所有开源

00:00:52.739 --> 00:00:57.149
如果您有疑问，可以随时去

00:00:54.809 --> 00:01:02.250
查看代码，看看它是否确实在做

00:00:57.149 --> 00:01:04.140
我要说的是今天的议程

00:01:02.250 --> 00:01:06.689
接下来是我们要谈的第一件事

00:01:04.140 --> 00:01:10.710
关于什么是DC什么是类

00:01:06.689 --> 00:01:14.810
卸载并获得概述

00:01:10.710 --> 00:01:17.580
涉及不同的阶段，我要

00:01:14.810 --> 00:01:20.750
深入研究代码缓存

00:01:17.580 --> 00:01:22.500
以及加载和元数据卸载以及

00:01:20.750 --> 00:01:28.229
最终陷入某种

00:01:22.500 --> 00:01:32.700
评估和未来计划正确

00:01:28.229 --> 00:01:35.640
什么是GC这是一个新的并发

00:01:32.700 --> 00:01:37.799
 JDK 11中引入的垃圾收集器

00:01:35.640 --> 00:01:42.259
这是一个实验性的

00:01:37.799 --> 00:01:44.460
功能，仅适用于x86 64 

00:01:42.259 --> 00:01:49.820
目前使用Linux，但我们正在寻找

00:01:44.460 --> 00:01:52.170
扩展平台支持

00:01:49.820 --> 00:01:54.630
对此有更好的了解

00:01:52.170 --> 00:01:58.350
你看到最好看一下目标

00:01:54.630 --> 00:02:02.430
我们有这个项目，到目前为止

00:01:58.350 --> 00:02:04.200
广告目标是按比例缩放以及何时

00:02:02.430 --> 00:02:06.299
谈论规模，我是说我们想成为

00:02:04.200 --> 00:02:09.390
能够运行多次字节堆，并且

00:02:06.299 --> 00:02:13.069
仍然保持最大的DC安全或存在

00:02:09.390 --> 00:02:15.469
 10毫秒内的消遣

00:02:13.069 --> 00:02:17.840
为此，我们愿意支付一定的限额

00:02:15.469 --> 00:02:20.389
吞吐量不超过15％ 

00:02:17.840 --> 00:02:22.999
减少吞吐量的另一个目标是

00:02:20.389 --> 00:02:25.730
我们非常重视我们想要它

00:02:22.999 --> 00:02:27.590
尽可能容易地调整我们不

00:02:25.730 --> 00:02:30.049
想要一百个没有人的JVM标志

00:02:27.590 --> 00:02:31.819
知道他们在做什么，我们想

00:02:30.049 --> 00:02:34.189
开箱即用

00:02:31.819 --> 00:02:36.019
可能，我发现它有助于

00:02:34.189 --> 00:02:41.060
使所有事情并发实现

00:02:36.019 --> 00:02:42.530
没错，所以我说这是并发的

00:02:41.060 --> 00:02:44.480
垃圾收集器好，我的意思是

00:02:42.530 --> 00:02:48.799
 g1是并发垃圾

00:02:44.480 --> 00:02:50.389
收藏家让我们看一些细节

00:02:48.799 --> 00:02:53.269
不同操作的垃圾

00:02:50.389 --> 00:02:55.639
收藏家必须执行例如

00:02:53.269 --> 00:02:57.590
必须标记堆中的所有对象

00:02:55.639 --> 00:02:59.959
遍历堆并标记所有

00:02:57.590 --> 00:03:02.780
对象，我们必须执行

00:02:59.959 --> 00:03:05.900
压缩我们必须整理内存碎片

00:03:02.780 --> 00:03:07.909
并清理大的连续内存

00:03:05.900 --> 00:03:11.569
空间，所以我们可以有城市指针

00:03:07.909 --> 00:03:15.409
我们还需要执行的分配

00:03:11.569 --> 00:03:17.540
参考处理，我们需要

00:03:15.409 --> 00:03:19.340
重定位集选择以找出

00:03:17.540 --> 00:03:22.819
最好的地方在哪里

00:03:19.340 --> 00:03:24.199
执行压缩，我们需要做一个

00:03:22.819 --> 00:03:27.500
一大堆其他东西，例如字符串

00:03:24.199 --> 00:03:30.769
在字符串表清洗和全局引用中

00:03:27.500 --> 00:03:33.470
扫描，尤其是班级

00:03:30.769 --> 00:03:37.489
卸载我们需要做类卸载

00:03:33.470 --> 00:03:41.030
而且我们还需要扫描线程

00:03:37.489 --> 00:03:43.220
堆栈，所以如果您看臭名昭著的

00:03:41.030 --> 00:03:47.509
世界上大多数收藏家都不喜欢

00:03:43.220 --> 00:03:50.000
串行GC和风险GC令人惊讶

00:03:47.509 --> 00:03:52.009
一切都在安全的点完成， 

00:03:50.000 --> 00:03:55.939
这就是它的工作方式，如果我们看一下

00:03:52.009 --> 00:03:58.549
 g1标记中的CMS是并发的，何时

00:03:55.939 --> 00:04:01.269
我说标记它是专门

00:03:58.549 --> 00:04:06.500
在上一代人中有很强的参考

00:04:01.269 --> 00:04:09.979
其余部分同时遍历

00:04:06.500 --> 00:04:12.109
例如扩大最终错误和

00:04:09.979 --> 00:04:15.650
传递闭包从

00:04:12.109 --> 00:04:19.430
他们以及年轻一代已经完成

00:04:15.650 --> 00:04:21.500
在一个安全的点上，有了GC，我们

00:04:19.430 --> 00:04:23.779
检查所有绿色框，除了

00:04:21.500 --> 00:04:26.930
线程堆栈扫描无效

00:04:23.779 --> 00:04:29.210
那一个出来了，剩下的就是

00:04:26.930 --> 00:04:31.100
目前，我已突出显示课程

00:04:29.210 --> 00:04:33.530
在这里大量卸载，因为那是

00:04:31.100 --> 00:04:35.840
最后一次安全的抢劫行动

00:04:33.530 --> 00:04:41.240
现在已经尘埃落定

00:04:35.840 --> 00:04:43.130
现在没有人在做，所以我们

00:04:41.240 --> 00:04:46.280
释放并发类的卸载

00:04:43.130 --> 00:04:48.590
 12我说的是过去时

00:04:46.280 --> 00:04:51.169
已经发生了12次了

00:04:48.590 --> 00:04:53.419
但基本上是十二点

00:04:51.169 --> 00:05:03.080
签入12并在发布中

00:04:53.419 --> 00:05:04.580
训练与传统阶段

00:05:03.080 --> 00:05:07.250
我们必须经过上课

00:05:04.580 --> 00:05:09.800
在下面卸载可以将其拆分

00:05:07.250 --> 00:05:13.039
首先是我们的标记

00:05:09.800 --> 00:05:14.750
必须标记对象以及何时标记

00:05:13.039 --> 00:05:17.840
军队还将标记元数据

00:05:14.750 --> 00:05:20.449
可从这些物体到达

00:05:17.840 --> 00:05:22.550
知道生活是什么，最终需要

00:05:20.449 --> 00:05:24.349
在执行参考处理

00:05:22.550 --> 00:05:26.449
参考处理通常会

00:05:24.349 --> 00:05:28.430
从完成中扩展可达到的范围

00:05:26.449 --> 00:05:30.080
错误，这是另外一个

00:05:28.430 --> 00:05:33.440
标记通常是安全的

00:05:30.080 --> 00:05:35.570
点，最终您将到达

00:05:33.440 --> 00:05:38.840
我们走的地方是卸货部分

00:05:35.570 --> 00:05:43.280
所有失效的数据结构并摆脱

00:05:38.840 --> 00:05:45.800
所有所有无效数据中，所以这

00:05:43.280 --> 00:05:51.409
既是代码缓存又是元数据

00:05:45.800 --> 00:05:53.780
需要使用GC清除

00:05:51.409 --> 00:05:56.919
正在同时做更多的事情，所以它

00:05:53.780 --> 00:05:59.900
看起来很相似但不太完全

00:05:56.919 --> 00:06:03.139
特别是在标记过程中

00:05:59.900 --> 00:06:06.919
我们正在标记的元数据和对象

00:06:03.139 --> 00:06:11.300
两者都是强者可以达到的

00:06:06.919 --> 00:06:13.610
引用和显而易见的都是可以达到的

00:06:11.300 --> 00:06:16.159
通过最终的错误，以便当我们

00:06:13.610 --> 00:06:18.800
标记终止，我们需要知道

00:06:16.159 --> 00:06:21.530
最终的生命力

00:06:18.800 --> 00:06:23.960
对象和高度可达的对象

00:06:21.530 --> 00:06:26.090
以便后续参考

00:06:23.960 --> 00:06:29.539
在某种意义上简化了处理

00:06:26.090 --> 00:06:31.909
它将永远不会改变

00:06:29.539 --> 00:06:34.120
改变了生命力

00:06:31.909 --> 00:06:39.320
并发标记期间的计算

00:06:34.120 --> 00:06:40.460
这样我们就可以继续

00:06:39.320 --> 00:06:43.550
并发类

00:06:40.460 --> 00:06:45.020
以及加载，我们将再次

00:06:43.550 --> 00:06:46.639
走了我们一分钟的代码缓存

00:06:45.020 --> 00:06:49.240
数据并清除所有

00:06:46.639 --> 00:06:49.240
死了

00:06:49.360 --> 00:06:58.789
所以zgc的脸看起来有些东西

00:06:53.060 --> 00:07:00.979
像这样的大面朝下

00:06:58.789 --> 00:07:04.310
箭头或安全点操作

00:07:00.979 --> 00:07:08.120
其中三个周期中的第一个

00:07:04.310 --> 00:07:11.780
商标是一个安全的起点吗？ 

00:07:08.120 --> 00:07:14.120
我们基本上是走堆然后踢

00:07:11.780 --> 00:07:16.699
并发遍历是

00:07:14.120 --> 00:07:20.870
运行良好的工作应用程序是

00:07:16.699 --> 00:07:23.960
运行，最终我们终止了

00:07:20.870 --> 00:07:26.300
在标记末端和之后标记

00:07:23.960 --> 00:07:27.800
那就是事物的轻盈

00:07:26.300 --> 00:07:31.400
信息是完整的，我们知道

00:07:27.800 --> 00:07:33.409
已经死了，我们开始另一个并发

00:07:31.400 --> 00:07:36.710
在这个并发阶段

00:07:33.409 --> 00:07:38.720
这是我们进行并发引用的地方

00:07:36.710 --> 00:07:41.900
处理和并发类

00:07:38.720 --> 00:07:45.889
最终我们卸载到

00:07:41.900 --> 00:07:49.220
并发搬迁面孔，但我们有一个

00:07:45.889 --> 00:07:52.130
安全的一点，在那之前，我们稍微翻转一下

00:07:49.220 --> 00:07:53.750
在全球的全球范围内，然后我们

00:07:52.130 --> 00:07:58.340
开始运行，我们基本上进行评估

00:07:53.750 --> 00:08:03.770
整个堆并执行重定位

00:07:58.340 --> 00:08:07.539
同时进行，所以第一步

00:08:03.770 --> 00:08:13.789
在该标记中看起来更深一点

00:08:07.539 --> 00:08:15.949
所以我们有彩色的指针

00:08:13.789 --> 00:08:18.020
表示GC阶段与

00:08:15.949 --> 00:08:20.060
指针的具体颜色以及何时

00:08:18.020 --> 00:08:22.099
我们标记的东西是奇特的颜色

00:08:20.060 --> 00:08:26.690
我们希望指针必须

00:08:22.099 --> 00:08:29.630
将它们标记为高度可达，我们也

00:08:26.690 --> 00:08:31.759
有一种特殊的颜色

00:08:29.630 --> 00:08:33.950
通过最终的错误可以到达，因此

00:08:31.759 --> 00:08:36.680
最终可达对象的指针

00:08:33.950 --> 00:08:37.669
具有检测到的特定颜色

00:08:36.680 --> 00:08:41.000
在我们的负载条中

00:08:37.669 --> 00:08:42.890
因此，在我们的负载障碍中，我们可以促进

00:08:41.000 --> 00:08:47.450
最终成为的对象

00:08:42.890 --> 00:08:49.370
高度可达，这在一个

00:08:47.450 --> 00:08:52.339
元数据也是如此

00:08:49.370 --> 00:08:54.410
元数据可以访问

00:08:52.339 --> 00:08:56.149
通过完成或

00:08:54.410 --> 00:08:58.310
强烈，我们需要跟踪

00:08:56.149 --> 00:09:03.259
是其中之一，以便我们可以

00:08:58.310 --> 00:09:05.509
做所有魔术并发的事情，如果我们

00:09:03.259 --> 00:09:08.300
看看什么藏在

00:09:05.509 --> 00:09:08.899
对象看起来像元数据的对象

00:09:08.300 --> 00:09:11.060
像这样

00:09:08.899 --> 00:09:13.639
所以我们有一堆东西，你

00:09:11.060 --> 00:09:16.759
可以从它直接链接Java 

00:09:13.639 --> 00:09:21.250
反对将保持的类加载器

00:09:16.759 --> 00:09:23.750
它还活着，但是在这种情况下

00:09:21.250 --> 00:09:26.569
我们在标题中有一个类指针

00:09:23.750 --> 00:09:28.250
每个对象和这个类的词

00:09:26.569 --> 00:09:30.290
也必须标记，以便当我们

00:09:28.250 --> 00:09:33.019
遍历对象

00:09:30.290 --> 00:09:35.779
遍历全班

00:09:33.019 --> 00:09:37.370
全班有一些参考资料

00:09:35.779 --> 00:09:40.639
它的类加载数据和该类

00:09:37.370 --> 00:09:43.970
加载程序数据中包含一堆句柄

00:09:40.639 --> 00:09:47.329
在最终指向的手柄区域

00:09:43.970 --> 00:09:49.189
退出类加载器和一些镜像

00:09:47.329 --> 00:09:51.500
诸如此类的东西

00:09:49.189 --> 00:09:54.079
标记课程，我们必须保留所有

00:09:51.500 --> 00:09:56.300
这些东西基本上还活着，但是如果

00:09:54.079 --> 00:09:59.569
没有人在那里，我们还没有找到

00:09:56.300 --> 00:10:01.160
类的对象是我们

00:09:59.569 --> 00:10:03.170
已经标记，我们还没有明显

00:10:01.160 --> 00:10:07.540
指向我们的班级字母，我们可以

00:10:03.170 --> 00:10:10.189
摆脱一切，我们会做到的

00:10:07.540 --> 00:10:12.680
所以下一步就是参考处理

00:10:10.189 --> 00:10:14.149
这个我有很多

00:10:12.680 --> 00:10:16.339
会尽量哑巴

00:10:14.149 --> 00:10:21.079
为了简单起见

00:10:16.339 --> 00:10:23.529
演示，所以基本上有它

00:10:21.079 --> 00:10:27.709
要点是我们有两个不同

00:10:23.529 --> 00:10:33.079
星期类型参考正常

00:10:27.709 --> 00:10:38.839
正常的一周参考，如果

00:10:33.079 --> 00:10:40.040
参考不是很容易获得

00:10:38.839 --> 00:10:41.420
但仍然可以通过以下方式访问

00:10:40.040 --> 00:10:45.439
最后确定他们不清楚

00:10:41.420 --> 00:10:47.540
但是，幻象引用

00:10:45.439 --> 00:10:49.550
另一方面，当它们被清除时

00:10:47.540 --> 00:10:52.610
在以下位置根本无法获得参考

00:10:49.550 --> 00:10:54.199
甚至通过最后的错误，为什么

00:10:52.610 --> 00:10:58.550
这重要吗

00:10:54.199 --> 00:11:02.569
我们，因为VM弱引用了我们

00:10:58.550 --> 00:11:05.120
包括持有人--或班级

00:11:02.569 --> 00:11:08.150
加载的数据使类保持活动状态

00:11:05.120 --> 00:11:11.330
它具有幻影达到能力，所以

00:11:08.150 --> 00:11:14.390
必须能够懒惰地计算

00:11:11.330 --> 00:11:17.570
这些东西的可读性，我们可以

00:11:14.390 --> 00:11:20.360
而我们这样做，如果班级的持有人

00:11:17.570 --> 00:11:25.070
通过幻像知道加载的数据

00:11:20.360 --> 00:11:26.510
轴然后基本上是死的，除非

00:11:25.070 --> 00:11:27.800
有一些愚蠢的参考

00:11:26.510 --> 00:11:32.120
柜台也是，但这是一个整体

00:11:27.800 --> 00:11:36.200
最终会得到不同种类的蠕虫

00:11:32.120 --> 00:11:36.890
下载有趣的部分

00:11:36.200 --> 00:11:38.600
东西

00:11:36.890 --> 00:11:40.430
因此在参考处理之后

00:11:38.600 --> 00:11:43.340
一大堆不同的数据结构

00:11:40.430 --> 00:11:47.990
现在已经过时并包含

00:11:43.340 --> 00:11:52.490
死的东西，是的，有一个子类

00:11:47.990 --> 00:11:55.220
层次结构与子链接同级

00:11:52.490 --> 00:11:57.740
实施者列出了一些

00:11:55.220 --> 00:12:01.460
用于分析数据的元数据对象

00:11:57.740 --> 00:12:03.980
我们有即时类依赖上下文

00:12:01.460 --> 00:12:05.660
用于优化java.lang 

00:12:03.980 --> 00:12:09.080
调用呼号也有一些

00:12:05.660 --> 00:12:11.210
依赖关系上下文也用于

00:12:09.080 --> 00:12:13.040
优化结束了

00:12:11.210 --> 00:12:15.080
数据图，我们有一堆

00:12:13.040 --> 00:12:16.910
桌子我们有很多桌子

00:12:15.080 --> 00:12:19.100
保护域缓存表模块

00:12:16.910 --> 00:12:21.230
表字符串表包表符号

00:12:19.100 --> 00:12:26.000
他们都有很多桌子

00:12:21.230 --> 00:12:29.480
现在有这些东西，是的清单

00:12:26.000 --> 00:12:31.430
桌子继续下去，最终我们

00:12:29.480 --> 00:12:32.690
也有元空间

00:12:31.430 --> 00:12:34.520
重要的是我们有一堆

00:12:32.690 --> 00:12:37.580
类方法等，它们都需要

00:12:34.520 --> 00:12:39.410
变得裸体，我们在其中有一个代码缓存

00:12:37.580 --> 00:12:43.370
我们及时编译的代码缓存

00:12:39.410 --> 00:12:44.930
将此代码部分编码是因为

00:12:43.370 --> 00:12:46.820
死了的东西，因为对象

00:12:44.930 --> 00:12:50.480
引用内联到

00:12:46.820 --> 00:12:54.170
代码或指向随机废话

00:12:50.480 --> 00:12:55.910
堆里不再住了

00:12:54.170 --> 00:12:58.970
另外我们有内联缓存

00:12:55.910 --> 00:13:01.010
优化方法调用

00:12:58.970 --> 00:13:03.110
他们也指着现在的事物

00:13:01.010 --> 00:13:06.770
死亡，因为对象引用死亡

00:13:03.110 --> 00:13:09.200
是的，这是最好的方式

00:13:06.770 --> 00:13:12.590
描述这种情况是

00:13:09.200 --> 00:13:16.730
跟随一切都是一团糟

00:13:12.590 --> 00:13:18.650
但是我们还是继续运行

00:13:16.730 --> 00:13:22.210
看看那辆Jukka和摩托车

00:13:18.650 --> 00:13:22.210
他绝对疯了

00:13:23.220 --> 00:13:28.770
对，所以我们想要某种结构

00:13:26.160 --> 00:13:31.770
为了这种疯狂，我们做了一个

00:13:28.770 --> 00:13:34.529
解除链接与链接之间的纪律性划分

00:13:31.770 --> 00:13:36.330
购买，因此在上课时我们

00:13:34.529 --> 00:13:38.040
将所有内容拆分为实习链接

00:13:36.330 --> 00:13:40.800
和清除，并用

00:13:38.040 --> 00:13:43.740
与线程本地握手操作

00:13:40.800 --> 00:13:46.380
所有这些线程和重要性

00:13:43.740 --> 00:13:49.080
这是我们要确保

00:13:46.380 --> 00:13:52.320
我们没有民主的途径

00:13:49.080 --> 00:13:54.690
链接，当我们断开链接时， 

00:13:52.320 --> 00:13:57.149
删除它，以便当我们清除

00:13:54.690 --> 00:13:59.120
数据并开始删除我们不喜欢的东西

00:13:57.149 --> 00:14:02.520
希望任何人都可以触摸这个东西

00:13:59.120 --> 00:14:05.870
因为我们会炸毁，所以

00:14:02.520 --> 00:14:11.880
我们已经做到了，所以

00:14:05.870 --> 00:14:14.940
元数据取消链接握手清除及其

00:14:11.880 --> 00:14:19.890
用于代码缓存以及链接

00:14:14.940 --> 00:14:22.230
握手清除是关键，所以

00:14:19.890 --> 00:14:25.020
让我们多谈一点

00:14:22.230 --> 00:14:30.360
代码缓存和加载是最重要的

00:14:25.020 --> 00:14:33.120
我认为有趣的东西，所以我想我

00:14:30.360 --> 00:14:36.329
需要解释一下这两个

00:14:33.120 --> 00:14:39.600
我们这里的主要问题之一是

00:14:36.329 --> 00:14:41.160
因为我们有彩色的指针

00:14:39.600 --> 00:14:43.290
这个不变的所有指针

00:14:41.160 --> 00:14:46.490
当我们跑步时有相同的

00:14:43.290 --> 00:14:48.839
相同的颜色，但是当我们标记开始时

00:14:46.490 --> 00:14:53.070
我们开始标记我们还没有开始

00:14:48.839 --> 00:14:55.850
标记对象图，但我们需要

00:14:53.070 --> 00:14:58.470
将某种颜色分配给

00:14:55.850 --> 00:15:01.770
立即值符合

00:14:58.470 --> 00:15:04.670
我们及时的本机代码

00:15:01.770 --> 00:15:08.029
编译那将是什么颜色

00:15:04.670 --> 00:15:10.740
好吧，我们不必标记为

00:15:08.029 --> 00:15:14.700
被标记，因为那是我们所在的面孔

00:15:10.740 --> 00:15:17.190
但是如果这样做，我们还必须

00:15:14.700 --> 00:15:18.990
实际标记对象，如果我们

00:15:17.190 --> 00:15:21.779
标记对象，我们有一个记忆

00:15:18.990 --> 00:15:23.610
泄漏，因为我们无法卸载东西

00:15:21.779 --> 00:15:26.820
我们将如何处理

00:15:23.610 --> 00:15:30.810
我们需要以某种方式推迟应用

00:15:26.820 --> 00:15:33.600
向对象加载障碍

00:15:30.810 --> 00:15:34.950
以某种方式在本机代码中引用

00:15:33.600 --> 00:15:39.269
还不会变质

00:15:34.950 --> 00:15:41.070
如何做到的，我们也有内联

00:15:39.269 --> 00:15:43.649
缓存也很成问题

00:15:41.070 --> 00:15:48.600
因为内联缓存被编译成

00:15:43.649 --> 00:15:50.880
本机代码具有快速缓存

00:15:48.600 --> 00:15:53.459
访问他们认为我存在的任何地方

00:15:50.880 --> 00:15:58.079
通话将进行，它可能知道

00:15:53.459 --> 00:15:59.910
现在指向死机代码，我们不

00:15:58.079 --> 00:16:02.880
真的很想接那个电话，因为

00:15:59.910 --> 00:16:04.920
我们会炸毁，所以我们需要某种

00:16:02.880 --> 00:16:08.990
停止或预防的方式

00:16:04.920 --> 00:16:11.970
调用此机器代码

00:16:08.990 --> 00:16:15.540
绝对爆炸性的东西如何

00:16:11.970 --> 00:16:18.750
我们要做好那件事的关键

00:16:15.540 --> 00:16:22.139
是最终方法的进入障碍，而这些

00:16:18.750 --> 00:16:25.800
进入壁垒基本上有一种方法

00:16:22.139 --> 00:16:27.449
武装代码中的所有本机代码

00:16:25.800 --> 00:16:30.380
缓存，除了栈上的东西

00:16:27.449 --> 00:16:34.680
因为我没有任何意义

00:16:30.380 --> 00:16:39.930
将下一个调用捕获到该本地代码中

00:16:34.680 --> 00:16:42.839
在那个小陷阱里，我们接到了电话

00:16:39.930 --> 00:16:45.540
每个蹦床都进入虚拟机

00:16:42.839 --> 00:16:49.709
在那里我们可以弄清楚该怎么办

00:16:45.540 --> 00:16:54.630
这个可能过时的本机代码

00:16:49.709 --> 00:16:56.399
我们已经进入了，如果我们要做的话

00:16:54.630 --> 00:16:58.949
是我们遍历对象

00:16:56.399 --> 00:17:01.380
在本机代码中看到的引用是

00:16:58.949 --> 00:17:05.579
这个东西死了还是没有，因为

00:17:01.380 --> 00:17:09.240
对我们来说很重要，如果它已经死了，那么我们将

00:17:05.579 --> 00:17:13.319
做mais，基本上回到

00:17:09.240 --> 00:17:15.990
蹦床并调用方法句柄或

00:17:13.319 --> 00:17:21.089
方法Handler和该处理器中的方法

00:17:15.990 --> 00:17:25.470
我们将解决呼叫问题

00:17:21.089 --> 00:17:27.990
更有意义并重做通话

00:17:25.470 --> 00:17:32.640
无论我们最终进入翻译

00:17:27.990 --> 00:17:35.760
这是有意义的，对于mn方法

00:17:32.640 --> 00:17:39.360
很好，他们拥有所有

00:17:35.760 --> 00:17:40.980
轨道参考可能还活着

00:17:39.360 --> 00:17:43.460
仍然是他们的颜色错误

00:17:40.980 --> 00:17:46.140
可能是他们需要

00:17:43.460 --> 00:17:48.540
迁移或重新映射，因为它们

00:17:46.140 --> 00:17:52.890
具有一些过时的指针值

00:17:48.540 --> 00:17:55.650
然后我们要做的是重新映射

00:17:52.890 --> 00:17:58.670
在我们想要的右衣领上绘画

00:17:55.650 --> 00:18:01.980
通过修补机器代码来拥有

00:17:58.670 --> 00:18:05.610
最终我们通过解除武装

00:18:01.980 --> 00:18:07.620
再次修补一些机器代码

00:18:05.610 --> 00:18:11.760
我们在

00:18:07.620 --> 00:18:14.940
比较指令并为其分配

00:18:11.760 --> 00:18:16.040
全局正确值，当

00:18:14.940 --> 00:18:22.020
我们再次开始跑步

00:18:16.040 --> 00:18:23.280
一切都会有意义，所以我有

00:18:22.020 --> 00:18:26.370
这里有一些例子

00:18:23.280 --> 00:18:29.210
我认为第一个例子是

00:18:26.370 --> 00:18:34.230
死代码可能会出错

00:18:29.210 --> 00:18:37.410
所以假设我们在本机方法中

00:18:34.230 --> 00:18:40.980
我们有一个红色的内联缓存

00:18:37.410 --> 00:18:46.200
红色箭头可能会下降

00:18:40.980 --> 00:18:49.310
爆炸性的本地方法B，我们称之为

00:18:46.200 --> 00:18:53.070
那好吧，我们要做的是

00:18:49.310 --> 00:18:55.680
在这里浏览环境参考和

00:18:53.070 --> 00:18:57.390
找出哦，这真的很糟糕

00:18:55.680 --> 00:19:01.680
这个家伙死了，我们不应该

00:18:57.390 --> 00:19:05.810
调用此代码，然后我们重新

00:19:01.680 --> 00:19:10.110
解决了呼叫并将其修补到

00:19:05.810 --> 00:19:13.800
内联缓存在机器代码中跳转

00:19:10.110 --> 00:19:15.990
在这个例子中

00:19:13.800 --> 00:19:19.200
解释器适配器将使我们

00:19:15.990 --> 00:19:21.210
将执行移交给

00:19:19.200 --> 00:19:23.670
解释器，这一切都说得通

00:19:21.210 --> 00:19:28.110
我们可能会编译新的代码和东西

00:19:23.670 --> 00:19:30.570
就像下一个例子

00:19:28.110 --> 00:19:33.390
没死的东西在这

00:19:30.570 --> 00:19:38.070
我们在本机方法中的类似情况

00:19:33.390 --> 00:19:39.750
我们正在调用本机方法B 

00:19:38.070 --> 00:19:41.940
我们进入，我们称我们的小

00:19:39.750 --> 00:19:45.300
 Barry功能，我们在那里走管

00:19:41.940 --> 00:19:47.250
我们发现好吧，看起来像

00:19:45.300 --> 00:19:49.140
陆军的参考文献还活着，但

00:19:47.250 --> 00:19:52.520
他们有点不同步

00:19:49.140 --> 00:19:58.970
现实，所以没问题，我们修补了他

00:19:52.520 --> 00:20:02.400
修补机器码并撤防

00:19:58.970 --> 00:20:04.620
障碍，我们很乐意去

00:20:02.400 --> 00:20:08.940
通过此方法的后续调用

00:20:04.620 --> 00:20:17.280
内联缓存，我们将到达那里

00:20:08.940 --> 00:20:20.490
没有称这个障碍为正确

00:20:17.280 --> 00:20:22.290
从GC的角度来看， 

00:20:20.490 --> 00:20:25.080
这两个独特的面孔，我们

00:20:22.290 --> 00:20:29.520
谈到一个链接式握手鲈鱼

00:20:25.080 --> 00:20:31.470
是的，在取消链接期间

00:20:29.520 --> 00:20:35.250
同时运行垃圾回收

00:20:31.470 --> 00:20:37.320
线程将清除所有陈旧的

00:20:35.250 --> 00:20:42.990
通过修补计算机来内联缓存

00:20:37.320 --> 00:20:45.840
代码，它将解决一些问题

00:20:42.990 --> 00:20:47.280
将解决的年度解析处理程序

00:20:45.840 --> 00:20:49.410
这进入机器代码，以便

00:20:47.280 --> 00:20:54.030
将解决呼叫而不是呼叫

00:20:49.410 --> 00:20:56.610
这个非常糟糕的代码，我们修复了

00:20:54.030 --> 00:21:00.270
托比（Toby）也同时引用

00:20:56.610 --> 00:21:04.380
 GC线程正在运行，我们也撤防了

00:21:00.270 --> 00:21:08.160
 GC线程的障碍

00:21:04.380 --> 00:21:11.040
遇到，我们也取消链接

00:21:08.160 --> 00:21:15.000
依赖上下文，这有点

00:21:11.040 --> 00:21:19.020
在那儿进行无锁舞蹈

00:21:15.000 --> 00:21:21.110
 GC线程正在取消链接

00:21:19.020 --> 00:21:24.150
 Java线程是潜在的

00:21:21.110 --> 00:21:27.390
也将其变异，但这一切都会使

00:21:24.150 --> 00:21:29.490
感觉我讨厌诺言和类似的故事

00:21:27.390 --> 00:21:32.640
对于异常缓存，有一点

00:21:29.490 --> 00:21:36.140
无锁代码，因此取消链接

00:21:32.640 --> 00:21:36.140
运行时异常缓存

