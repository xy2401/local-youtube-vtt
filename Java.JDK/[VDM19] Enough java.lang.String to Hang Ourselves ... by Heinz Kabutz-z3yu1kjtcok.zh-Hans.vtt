WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.030 --> 00:00:07.350
所以我长大了，继续靠近

00:00:03.959 --> 00:00:10.080
意大利家庭，所以我们是德国人

00:00:07.350 --> 00:00:12.000
家庭混在意大利家庭，我们

00:00:10.080 --> 00:00:15.859
相处得很好，除了有一个

00:00:12.000 --> 00:00:20.789
那天我们不是很喜欢他们

00:00:15.859 --> 00:00:25.230
没有1982年7月的直播，但除此之外

00:00:20.789 --> 00:00:32.969
我们相处得很好，让我们来看一下

00:00:25.230 --> 00:00:34.829
在Java的名字字符串哦导弹在这里

00:00:32.969 --> 00:00:38.219
我们有一些方法

00:00:34.829 --> 00:00:46.230
将int转换为字符串，然后

00:00:38.219 --> 00:00:54.840
问题是最好的方法是什么

00:00:46.230 --> 00:00:58.859
 jdk这是一个好问题，是什么

00:00:54.840 --> 00:01:01.039
泰迪K好问题节在哪里

00:00:58.859 --> 00:01:01.039
原为

00:01:01.110 --> 00:01:16.220
好的，一种方法是您可以

00:01:13.320 --> 00:01:18.150
懒惰的方式双引号加井号

00:01:16.220 --> 00:01:19.620
你当然不应该做

00:01:18.150 --> 00:01:21.870
因为你不应该像一个人一样懒惰

00:01:19.620 --> 00:01:24.690
程序员另一个是如果你要

00:01:21.870 --> 00:01:26.490
串连他人的价值利益

00:01:24.690 --> 00:01:29.160
在字符串中，整数值为

00:01:26.490 --> 00:01:32.460
凯特整数，所以谁看到第一个是

00:01:29.160 --> 00:01:34.080
最快的方法比方说Java 12 

00:01:32.460 --> 00:01:38.430
为什么不骑自行车

00:01:34.080 --> 00:01:43.560
你是否使用过其他12个人， 

00:01:38.430 --> 00:01:45.270
一秒钟更快，谁看到它是

00:01:43.560 --> 00:01:48.119
第三，这是最快的方法

00:01:45.270 --> 00:01:49.770
有人说第三点好

00:01:48.119 --> 00:01:53.280
非常感谢你

00:01:49.770 --> 00:01:55.560
这是第四快，好吧，我们

00:01:53.280 --> 00:02:01.649
变得有点优雅，而

00:01:55.560 --> 00:02:04.350
第五个，第一个，很好

00:02:01.649 --> 00:02:05.670
还有另一个城市的问题

00:02:04.350 --> 00:02:10.739
这些都是愚蠢的问题

00:02:05.670 --> 00:02:12.720
让我们思考，但这是

00:02:10.739 --> 00:02:16.019
将字符串附加在一起的最快方法

00:02:12.720 --> 00:02:18.180
所以我正在使用的第一个

00:02:16.019 --> 00:02:21.810
当然哪个不能最快

00:02:18.180 --> 00:02:24.870
因为它是最短的错误代码

00:02:21.810 --> 00:02:26.790
我第二辆公交车很长

00:02:24.870 --> 00:02:28.260
做一个字符串生成器，我确定

00:02:26.790 --> 00:02:31.799
您已经使用了足够长的代码

00:02:28.260 --> 00:02:33.810
您已经看到了类似的代码

00:02:31.799 --> 00:02:35.580
一串就看到了

00:02:33.810 --> 00:02:38.880
生成器，您正在制作新字符

00:02:35.580 --> 00:02:40.739
所有的时间，所以我们有第三个

00:02:38.880 --> 00:02:43.380
首先算出数组有多大

00:02:40.739 --> 00:02:45.750
应该是然后我们添加所有

00:02:43.380 --> 00:02:50.670
弦在一起，谁说

00:02:45.750 --> 00:02:52.290
首先是最快的行吗

00:02:50.670 --> 00:02:54.390
好吧好吧

00:02:52.290 --> 00:02:55.860
 Java 7之后的所有内容Java 7和

00:02:54.390 --> 00:03:00.570
后来谁说第一个是

00:02:55.860 --> 00:03:03.720
最快的好，谁说第二个是

00:03:00.570 --> 00:03:05.700
最快还可以很好很好

00:03:03.720 --> 00:03:09.090
你说谁是三分之一

00:03:05.700 --> 00:03:10.530
现在最快，没放他们的

00:03:09.090 --> 00:03:11.900
手有人没有编程请

00:03:10.530 --> 00:03:14.670
格兰达

00:03:11.900 --> 00:03:16.349
好吧，你是对的，尽管如此

00:03:14.670 --> 00:03:17.819
都是一样的

00:03:16.349 --> 00:03:19.170
他们一样的原因是因为我

00:03:17.819 --> 00:03:23.189
不会告诉你，我稍后再告诉你

00:03:19.170 --> 00:03:25.110
好吧，现在我想回到历史

00:03:23.189 --> 00:03:28.920
恐龙在地上漫游时

00:03:25.110 --> 00:03:31.879
几百个世纪还可以

00:03:28.920 --> 00:03:34.230
其实从说私人查鲁开始

00:03:31.879 --> 00:03:38.250
方括号，你知道这些是C 

00:03:34.230 --> 00:03:40.079
程序员，在那个时候

00:03:38.250 --> 00:03:43.049
大于16的哈希码

00:03:40.079 --> 00:03:46.019
他们制作了角色的样本

00:03:43.049 --> 00:03:47.760
基本上看着每X个

00:03:46.019 --> 00:03:49.230
字符，所以不后悔

00:03:47.760 --> 00:03:51.180
那是它看起来很小的一种方式

00:03:49.230 --> 00:03:54.060
我认为他们偏离了30个字符

00:03:51.180 --> 00:03:55.950
采样所有的字符串，这是

00:03:54.060 --> 00:03:59.220
显然不是很好，不是很好

00:03:55.950 --> 00:04:01.290
末尾的哈​​希码，因为如果

00:03:59.220 --> 00:04:03.209
他们将拥有几个大弦

00:04:01.290 --> 00:04:05.609
几乎非常相似的哈希曲线或

00:04:03.209 --> 00:04:07.049
相同的哈希码和其他一些

00:04:05.609 --> 00:04:08.599
等于等的东西没有检查

00:04:07.049 --> 00:04:11.400
我们实际上是相同的对象

00:04:08.599 --> 00:04:14.970
互联网美学哈希表

00:04:11.400 --> 00:04:18.870
碰巧是一个记忆和一个字符串

00:04:14.970 --> 00:04:20.870
缓冲区基本上是可修改的字符串

00:04:18.870 --> 00:04:24.150
您可以使用的安全版本

00:04:20.870 --> 00:04:26.280
一旦构造好就改变

00:04:24.150 --> 00:04:27.690
当您在图表上调用字符串时

00:04:26.280 --> 00:04:30.090
字符串缓冲区真的很棒

00:04:27.690 --> 00:04:33.330
就是因为她是一样的

00:04:30.090 --> 00:04:35.460
基本的慈善组织，所以我们没有

00:04:33.330 --> 00:04:37.560
每次调用都会产生新的字符

00:04:35.460 --> 00:04:39.449
串起来，所以这是一些魔术

00:04:37.560 --> 00:04:41.070
那真是太好了，我的意思是如果你

00:04:39.449 --> 00:04:42.300
看一下源代码的方式

00:04:41.070 --> 00:04:44.970
您看一下Java源代码

00:04:42.300 --> 00:04:46.710
如今，您将在Java中看到这一点

00:04:44.970 --> 00:04:49.190
您说要串起来的原始码

00:04:46.710 --> 00:04:51.710
每次调用它都会创建一个新数组

00:04:49.190 --> 00:04:53.760
我们待会儿再讲

00:04:51.710 --> 00:04:56.610
这是哈希代码的样子

00:04:53.760 --> 00:05:00.210
已经流了11.0，您可以看到，如果

00:04:56.610 --> 00:05:03.270
长度小于16并且

00:05:00.210 --> 00:05:05.940
实际上将这些数字加起来

00:05:03.270 --> 00:05:07.440
乘数，否则它只看

00:05:05.940 --> 00:05:10.020
八个字符

00:05:07.440 --> 00:05:11.550
它说船长除以

00:05:10.020 --> 00:05:13.770
在代码的八个索引处是八个

00:05:11.550 --> 00:05:15.030
所以如果你有1000个字符

00:05:13.770 --> 00:05:18.810
看着他们八个来解决

00:05:15.030 --> 00:05:22.880
哈希码，这是不好的方式

00:05:18.810 --> 00:05:25.300
 demetri demetri是一个

00:05:22.880 --> 00:05:29.480
软工程师，他是我们的负责人

00:05:25.300 --> 00:05:31.970
麻烦制造者杂乱无章的@j爬行他

00:05:29.480 --> 00:05:35.810
试图不来他试图

00:05:31.970 --> 00:05:38.450
告诉我他伤了腿

00:05:35.810 --> 00:05:39.950
滑雪，但实际上昨晚他

00:05:38.450 --> 00:05:44.000
殴打，因为他要夏威夷

00:05:39.950 --> 00:05:46.130
披萨是的，这是滑雪靴的高度

00:05:44.000 --> 00:05:48.070
麻烦制造者的克里特岛

00:05:46.130 --> 00:05:50.240
 Java专家通讯和

00:05:48.070 --> 00:05:55.730
会尝试以此来招待你

00:05:50.240 --> 00:05:57.620
弦，他是三个，是的，只是

00:05:55.730 --> 00:05:59.930
如果你不在那儿请

00:05:57.620 --> 00:06:03.110
加入也有惊喜

00:05:59.930 --> 00:06:04.940
礼物在以后将不起作用

00:06:03.110 --> 00:06:06.950
今晚7:00，所以如果你看看

00:06:04.940 --> 00:06:09.110
 7:00之后，您将获得不那么大的收益

00:06:06.950 --> 00:06:10.310
如果您在7:00之前做过惊喜礼物

00:06:09.110 --> 00:06:11.840
你会得到一个很大的惊喜礼物，但是

00:06:10.310 --> 00:06:14.930
办公室永远不会像以前那么伟大

00:06:11.840 --> 00:06:17.780
以便小巧的老Vox会把ROM改为19 

00:06:14.930 --> 00:06:20.570
看一下，如果你想

00:06:17.780 --> 00:06:24.080
如果您也做链接，也可以得到一些东西

00:06:20.570 --> 00:06:25.550
我说的这边是

00:06:24.080 --> 00:06:27.250
改变以保存他们今晚你

00:06:25.550 --> 00:06:32.330
知道一旦啤酒开始礼物

00:06:27.250 --> 00:06:33.680
大幅减少，因此云端硬盘

00:06:32.330 --> 00:06:36.380
想知道奇迹改变了它的事情

00:06:33.680 --> 00:06:39.590
首先，该领域保持不变

00:06:36.380 --> 00:06:41.840
但是哈希码仍在采样

00:06:39.590 --> 00:06:45.440
他们将实习生转移到一些本地人

00:06:41.840 --> 00:06:46.660
不一定要去的代码

00:06:45.440 --> 00:06:49.850
比Java更好

00:06:46.660 --> 00:06:52.880
是的，所以各种各样的怪异事物

00:06:49.850 --> 00:06:57.230
像菜刀案有一些奇怪的边缘

00:06:52.880 --> 00:07:01.820
德国SF之类的案件变得太大了

00:06:57.230 --> 00:07:04.100
大屁股，所以致命的流可以

00:07:01.820 --> 00:07:07.010
改变我们需要大写和亲切

00:07:04.100 --> 00:07:08.750
旅行者奇怪的领域

00:07:07.010 --> 00:07:09.440
保持不变，但他们改变了

00:07:08.750 --> 00:07:11.540
哈希码

00:07:09.440 --> 00:07:13.370
那是那里最后一次胆敢

00:07:11.540 --> 00:07:15.920
这样做是因为你的强烈反对

00:07:13.370 --> 00:07:17.510
无法想象他们曾经是一两个

00:07:15.920 --> 00:07:19.580
在那里读了很多旧代码

00:07:17.510 --> 00:07:21.530
像我的使用者囊肿这样的人不是

00:07:19.580 --> 00:07:23.750
工作了，你知道你应得的

00:07:21.530 --> 00:07:26.060
马丁在谈论哭泣婴儿

00:07:23.750 --> 00:07:27.980
那时有很多婴儿

00:07:26.060 --> 00:07:30.200
他们是做什么的，而不是数数

00:07:27.980 --> 00:07:33.320
他们只将八个字符加起来

00:07:30.200 --> 00:07:35.270
人物，它打破了一堆

00:07:33.320 --> 00:07:36.160
测试可能还不错

00:07:35.270 --> 00:07:38.170
事情

00:07:36.160 --> 00:07:40.090
他们还添加了可比的界面

00:07:38.170 --> 00:07:42.670
我们会回到一点

00:07:40.090 --> 00:07:45.010
后来这意味着现在

00:07:42.670 --> 00:07:47.080
过去的表现是不变的

00:07:45.010 --> 00:07:49.930
时间表现，所以没关系

00:07:47.080 --> 00:07:53.290
大的字符串是花了

00:07:49.930 --> 00:07:55.690
在恒定时间内的相同时间量不是

00:07:53.290 --> 00:07:58.450
相同但不变的计算

00:07:55.690 --> 00:08:00.310
那里的哈希码戴着一个庇护

00:07:58.450 --> 00:08:02.260
当然，现在更改为线性时间

00:08:00.310 --> 00:08:05.140
所有人都知道这意味着它会变成

00:08:02.260 --> 00:08:07.990
显着性计算速度较慢

00:08:05.140 --> 00:08:10.270
哈希，所以这本书是写的， 

00:08:07.990 --> 00:08:16.090
称驾驶员表现为白痴

00:08:10.270 --> 00:08:17.680
引导了解成语引导成语

00:08:16.090 --> 00:08:20.020
成语指南就在这里，你知道这是一个

00:08:17.680 --> 00:08:22.420
他们写的好书是

00:08:20.020 --> 00:08:24.340
他们有一个表演书

00:08:22.420 --> 00:08:26.260
保质期约三个月吧

00:08:24.340 --> 00:08:28.480
直到出现下一个作业版本

00:08:26.260 --> 00:08:32.229
然后在那里你可以扔他们

00:08:28.480 --> 00:08:34.990
他们写的很好是一个问题

00:08:32.229 --> 00:08:36.520
书，但有点像最大的书

00:08:34.990 --> 00:08:38.950
书中的论点是你应该

00:08:36.520 --> 00:08:40.930
总是兑现您的哈希码，所以您必须

00:08:38.950 --> 00:08:42.400
绝不能使用字符串作为哈希码

00:08:40.930 --> 00:08:45.880
不得不在对象中放入字符串

00:08:42.400 --> 00:08:47.290
然后赶上哈希码，不久

00:08:45.880 --> 00:08:50.760
在写了《 Java 3》这本书之后

00:08:47.290 --> 00:08:53.710
他们现在兑现了哈希码

00:08:50.760 --> 00:08:56.650
事实是这个想法在缓存

00:08:53.710 --> 00:08:59.950
哈希码实际上并没有帮助我们

00:08:56.650 --> 00:09:01.840
在许多情况下通常是因为

00:08:59.950 --> 00:09:04.870
地图的整个重点是将事物放入

00:09:01.840 --> 00:09:06.820
你可以稍后再回来，所以你把

00:09:04.870 --> 00:09:07.840
在价值中，您丢掉了钥匙， 

00:09:06.820 --> 00:09:09.850
以后当你知道对象是什么

00:09:07.840 --> 00:09:11.230
再次返回，您重新生成密钥并

00:09:09.850 --> 00:09:14.650
您会再次发现该值

00:09:11.230 --> 00:09:16.330
硬地图可以使用um，如果

00:09:14.650 --> 00:09:17.380
你在这里看这个，我是哈希

00:09:16.330 --> 00:09:20.650
花费一百毫秒的表

00:09:17.380 --> 00:09:22.510
只是让它变得缓慢而实际上

00:09:20.650 --> 00:09:24.430
投入的时间

00:09:22.510 --> 00:09:26.110
三十个元素，让它们在那里

00:09:24.430 --> 00:09:29.020
与您完全一样的现金不会

00:09:26.110 --> 00:09:30.910
兑现三位董事兑现的钥匙

00:09:29.020 --> 00:09:32.800
确实有所作为，因为里面

00:09:30.910 --> 00:09:34.930
井号将抓住任何人

00:09:32.800 --> 00:09:37.150
操作哈希码值，所以它真的

00:09:34.930 --> 00:09:38.710
没有证明那么多，但无论如何他们

00:09:37.150 --> 00:09:41.730
添加了这个叫做哈希的东西

00:09:38.710 --> 00:09:46.780
当时有趣的是

00:09:41.730 --> 00:09:49.650
该哈希的内存是免费的

00:09:46.780 --> 00:09:53.530
至少在32位计算机上还可以

00:09:49.650 --> 00:09:57.400
因为该值是一个char数组

00:09:53.530 --> 00:09:59.860
这是四个字节，指向第二点

00:09:57.400 --> 00:10:02.380
 Troy是四个字节，然后int是四个

00:09:59.860 --> 00:10:04.990
对方会计师具有的字节偏移

00:10:02.380 --> 00:10:07.660
使用四个字节，它指示

00:10:04.990 --> 00:10:12.190
因此无论如何以八的倍数

00:10:07.660 --> 00:10:15.520
基本上是免费的

00:10:12.190 --> 00:10:17.500
在那一天，当然取决于

00:10:15.520 --> 00:10:20.830
在您的32位元上执行

00:10:17.500 --> 00:10:22.390
眼镜蛇的64位副本会失败

00:10:20.830 --> 00:10:28.900
有所作为，但在那些日子里

00:10:22.390 --> 00:10:30.400
免费发行，您知道我们希望我们

00:10:28.900 --> 00:10:33.010
都知道字符串在

00:10:30.400 --> 00:10:34.240
事实上甚至说文件

00:10:33.010 --> 00:10:36.730
实际上改变了哈希

00:10:34.240 --> 00:10:38.890
内部，当您调用哈希时

00:10:36.730 --> 00:10:40.600
代码将其更改为您的状态

00:10:38.890 --> 00:10:43.300
从外面看不到，这是一个

00:10:40.600 --> 00:10:46.810
数据竞赛，这是一个良性的竞赛

00:10:43.300 --> 00:10:49.540
因为罗斯会是一样的

00:10:46.810 --> 00:10:52.000
不管多少次，所以

00:10:49.540 --> 00:10:54.310
是比赛的一天，但没关系

00:10:52.000 --> 00:10:56.590
因为最终价值仍然是

00:10:54.310 --> 00:10:59.470
将会是42，所以没关系

00:10:56.590 --> 00:11:02.890
现在用哪种方式来看这些

00:10:59.470 --> 00:11:05.320
串这是一些乌克兰人

00:11:02.890 --> 00:11:07.120
我发现一些是它是

00:11:05.320 --> 00:11:16.570
这是乌克兰的10-4目录

00:11:07.120 --> 00:11:19.210
对，所以饥饿的大块头单位太短了

00:11:16.570 --> 00:11:24.360
名字太短了，这些怎么办

00:11:19.210 --> 00:11:28.270
哈希码的共同点是

00:11:24.360 --> 00:11:30.760
右为零，因此哈希码始终为

00:11:28.270 --> 00:11:33.640
将这些字符串中的每个字符串归零

00:11:30.760 --> 00:11:36.940
是零，如果我不知道如何找到

00:11:33.640 --> 00:11:40.180
他们很好，没有算法

00:11:36.940 --> 00:11:42.850
有人写了相反的话

00:11:40.180 --> 00:11:44.820
食物真的很出名，我

00:11:42.850 --> 00:11:48.130
现在不要删除他的名字，所以

00:11:44.820 --> 00:11:49.120
不，那是更多的回味，我想

00:11:48.130 --> 00:11:50.950
那是马克·莱因霍尔德

00:11:49.120 --> 00:11:54.460
真正有名的人写了

00:11:50.950 --> 00:11:56.890
他反转哈希的算法

00:11:54.460 --> 00:11:59.680
代码，所以如果您想使用哈希代码

00:11:56.890 --> 00:12:00.410
 25个你说我想要一分钱的父亲

00:11:59.680 --> 00:12:02.420
然后

00:12:00.410 --> 00:12:04.820
为您生成一个字符串

00:12:02.420 --> 00:12:08.720
哈希码25，只需反向执行

00:12:04.820 --> 00:12:11.240
进入哈希码，所以我尝试了

00:12:08.720 --> 00:12:13.550
使用算法生成字符串

00:12:11.240 --> 00:12:16.790
但问题是它会给你一个

00:12:13.550 --> 00:12:18.830
与那些带数字的弦，但我

00:12:16.790 --> 00:12:20.660
想用

00:12:18.830 --> 00:12:22.640
哈希码为零，所以我只是站在

00:12:20.660 --> 00:12:25.280
蛮力道歉，但确实如此

00:12:22.640 --> 00:12:27.110
尽力消除暴力，等等

00:12:25.280 --> 00:12:30.080
在这里和四肢顺利

00:12:27.110 --> 00:12:32.740
这些字符串都是散列代码

00:12:30.080 --> 00:12:35.360
零，如果我将它们加在一起

00:12:32.740 --> 00:12:38.260
任何人到任何两个在一起，甚至相同

00:12:35.360 --> 00:12:40.820
哈希码为1，则ginn为零

00:12:38.260 --> 00:12:42.650
因为一旦你得到0，你就可以

00:12:40.820 --> 00:12:44.870
从头开始回到

00:12:42.650 --> 00:12:47.060
零，所以有趣的是

00:12:44.870 --> 00:12:50.180
是因为他们认为

00:12:47.060 --> 00:12:52.570
将这些字符串的任何组合归零

00:12:50.180 --> 00:12:54.920
还可以让您将哈希值归零

00:12:52.570 --> 00:12:56.210
让我们来看看为什么这么糟糕

00:12:54.920 --> 00:12:59.960
我要看不同的版本

00:12:56.210 --> 00:13:04.850
 Java，让我们回到如何做

00:12:59.960 --> 00:13:08.000
你吃饭所以我在南非的邻居

00:13:04.850 --> 00:13:10.670
比...短一点

00:13:08.000 --> 00:13:13.490
德国邻居，所以我明白了为什么

00:13:10.670 --> 00:13:16.790
在这里太低了，它试图

00:13:13.490 --> 00:13:20.450
这很好，所以这是代码

00:13:16.790 --> 00:13:23.210
那是以前，基本上是我

00:13:20.450 --> 00:13:25.400
得到零散列码和零

00:13:23.210 --> 00:13:27.890
哈希码只是为了感觉字符串和

00:13:25.400 --> 00:13:29.150
然后我简单地将它们组合在一起

00:13:27.890 --> 00:13:31.220
你可以拥有无​​限个

00:13:29.150 --> 00:13:33.320
实际上产生的几乎交换

00:13:31.220 --> 00:13:35.900
实际上是用的哈希码生成的

00:13:33.320 --> 00:13:37.460
零，所以我要做的是

00:13:35.900 --> 00:13:42.680
我将首先使用

00:13:37.460 --> 00:13:46.190
 Java 6好的，这是我看到的

00:13:42.680 --> 00:13:49.130
关闭字符串的数量加倍，并且

00:13:46.190 --> 00:13:52.160
实际上并不是那么多

00:13:49.130 --> 00:13:54.830
时间我使它的两倍

00:13:52.160 --> 00:13:59.150
速度也大约是

00:13:54.830 --> 00:14:01.790
慢，所以您可以看到哈希

00:13:59.150 --> 00:14:04.520
哈希码查找，所以我们从

00:14:01.790 --> 00:14:07.430
一秒到两秒左右

00:14:04.520 --> 00:14:09.950
大概是这样的哦棒

00:14:07.430 --> 00:14:11.370
所以你可以说的是

00:14:09.950 --> 00:14:14.190
实际上是哈希

00:14:11.370 --> 00:14:15.930
查找哈希码，以便找到

00:14:14.190 --> 00:14:20.130
该值，即使哈希码是

00:14:15.930 --> 00:14:22.620
缓存最终是线性的

00:14:20.130 --> 00:14:24.510
现在的问题不是

00:14:22.620 --> 00:14:26.160
哈希码以现金丢失的形式兑现

00:14:24.510 --> 00:14:27.750
问题是所有字符串都结束了

00:14:26.160 --> 00:14:30.060
在哈希内的同一存储桶中

00:14:27.750 --> 00:14:34.890
地图，但这就是为什么我们最终得到一个

00:14:30.060 --> 00:14:37.080
线性查找，它是从

00:14:34.890 --> 00:14:39.510
哈希图会降低链表的权限

00:14:37.080 --> 00:14:42.150
在Java 6中现在出了点问题

00:14:39.510 --> 00:14:44.250
可能我们超出了某个尺寸

00:14:42.150 --> 00:14:48.240
事情不再快乐了，但是

00:14:44.250 --> 00:14:50.970
现在通常会是线性的

00:14:48.240 --> 00:14:55.470
在Java 7中，他们实际上做了一些事情

00:14:50.970 --> 00:14:58.280
这很有趣，他们

00:14:55.470 --> 00:15:01.560
他们想阻止这种情况的发生

00:14:58.280 --> 00:15:03.690
他们想阻止它的人

00:15:01.560 --> 00:15:05.940
通过发送攻击网络服务器

00:15:03.690 --> 00:15:07.290
感官倍数相同的字符串

00:15:05.940 --> 00:15:09.270
字符串全部为零的哈希码

00:15:07.290 --> 00:15:10.860
然后夏天变得惊讶

00:15:09.270 --> 00:15:15.210
当我们做饼干更大的哈希布朗

00:15:10.860 --> 00:15:22.140
正如我们所看到的

00:15:15.210 --> 00:15:25.290
 Java 6成为现在的一个问题

00:15:22.140 --> 00:15:26.970
现在我当然没有Java 3 

00:15:25.290 --> 00:15:30.270
为现场武装我们的机器和Java 

00:15:26.970 --> 00:15:32.550
等于2超过3，他们

00:15:30.270 --> 00:15:34.230
并介绍了这样的序列接口

00:15:32.550 --> 00:15:36.840
这样您就可以讲话画一个

00:15:34.230 --> 00:15:40.200
序列或字符串，也有

00:15:36.840 --> 00:15:41.760
不是全部的正则表达式

00:15:40.200 --> 00:15:43.380
你说得最快的那种

00:15:41.760 --> 00:15:48.840
关于这一点，我认为当我们到达

00:15:43.380 --> 00:15:50.310
格式可能现在提到

00:15:48.840 --> 00:15:52.830
在过去，当他添加字符串

00:15:50.310 --> 00:15:55.410
就像你好类Arg 0一样

00:15:52.830 --> 00:15:57.810
产生一个字符串缓冲区，他们拉

00:15:55.410 --> 00:16:00.450
我们的狗狗便条上的油漆警报得到了

00:15:57.810 --> 00:16:02.430
到字符串和这个新的字符串缓冲区

00:16:00.450 --> 00:16:07.440
将在Java代码中使

00:16:02.430 --> 00:16:09.060
 Java 5中16个字符的数组

00:16:07.440 --> 00:16:10.380
圣诞老人的工作领域与否3但

00:16:09.060 --> 00:16:12.030
将其标记为最终值（散列除外） 

00:16:10.380 --> 00:16:14.580
您知道应该始终尝试并

00:16:12.030 --> 00:16:16.440
将字段标记为最终位置，它们会

00:16:14.580 --> 00:16:18.270
有代码点，所以角色可以

00:16:16.440 --> 00:16:20.730
实际上是两者的结合

00:16:18.270 --> 00:16:21.690
字符，我们也有点

00:16:20.730 --> 00:16:23.329
字符串生成器

00:16:21.690 --> 00:16:26.689
非同步版本

00:16:23.329 --> 00:16:28.699
关闭字符串缓冲区和char 

00:16:26.689 --> 00:16:31.489
数组将不再与之共享

00:16:28.699 --> 00:16:33.649
现在有了创建的街道

00:16:31.489 --> 00:16:35.629
当我们从Java传授

00:16:33.649 --> 00:16:38.239
实际重新编译Java Java的人

00:16:35.629 --> 00:16:42.290
代码来利用这个

00:16:38.239 --> 00:16:45.860
我实际上有一个新的新功能

00:16:42.290 --> 00:16:48.709
我当时在图书馆工作，并且

00:16:45.860 --> 00:16:51.230
我改变了字符串加上

00:16:48.709 --> 00:16:54.110
普通加附加使用字符串

00:16:51.230 --> 00:16:56.480
具有预设大小的缓冲区，因为它

00:16:54.110 --> 00:16:58.670
确实在

00:16:56.480 --> 00:16:59.389
表演，所以我分享了

00:16:58.670 --> 00:17:02.420
 10％ 

00:16:59.389 --> 00:17:04.819
我的速度快了10％ 

00:17:02.420 --> 00:17:07.100
回到我们的优化

00:17:04.819 --> 00:17:09.409
之前的问题是

00:17:07.100 --> 00:17:11.269
优化实际上是行不通的

00:17:09.409 --> 00:17:12.949
JAVA五百，因为北没有

00:17:11.269 --> 00:17:14.899
更长的字符串缓冲区正在做子弹

00:17:12.949 --> 00:17:16.100
所以你实际上不得不回去

00:17:14.899 --> 00:17:20.709
更改字符串流缓冲区

00:17:16.100 --> 00:17:24.019
建设者并重新编译，否则就没事了

00:17:20.709 --> 00:17:26.600
 Java 6没什么大变化

00:17:24.019 --> 00:17:29.510
结构，但这确实增加了

00:17:26.600 --> 00:17:31.010
压缩的弦我们有时会刺痛

00:17:29.510 --> 00:17:33.950
将使用char数组和其他时间

00:17:31.010 --> 00:17:35.600
以字节数组为基础

00:17:33.950 --> 00:17:37.730
为了保持角色

00:17:35.600 --> 00:17:39.769
如果和你一起工作，那有点奇怪

00:17:37.730 --> 00:17:41.179
反射，你看着琴弦

00:17:39.769 --> 00:17:44.690
有时是比特率，我是

00:17:41.179 --> 00:17:46.880
字符数组东西变得时髦

00:17:44.690 --> 00:17:49.850
还添加了优化的臭猫

00:17:46.880 --> 00:17:52.909
一些Java 6版本，这意味着

00:17:49.850 --> 00:17:55.370
你的字符可以在那

00:17:52.909 --> 00:17:57.110
也将在您的字符串之间共享

00:17:55.370 --> 00:17:58.789
缓冲字符串构建和字符串等

00:17:57.110 --> 00:18:01.070
记得我们第一次表演的时候

00:17:58.789 --> 00:18:02.389
我想要他们分享的零

00:18:01.070 --> 00:18:04.250
字符串之间的char数组，但是

00:18:02.389 --> 00:18:07.070
从发生的字符串

00:18:04.250 --> 00:18:08.539
从Java 6开始自动

00:18:07.070 --> 00:18:10.220
你看看它的Java代码

00:18:08.539 --> 00:18:13.399
发生，但在现实世界中确实如此

00:18:10.220 --> 00:18:16.429
发生，所以这很酷

00:18:13.399 --> 00:18:18.559
有些是我们的第一个基准

00:18:16.429 --> 00:18:20.720
我只将字符串加在一起

00:18:18.559 --> 00:18:22.309
你只是把弦加在一起

00:18:20.720 --> 00:18:25.580
不管采用哪种方式都可以

00:18:22.309 --> 00:18:29.720
速度完全一样所以当你

00:18:25.580 --> 00:18:32.149
看这些价值观的痛苦基本

00:18:29.720 --> 00:18:33.330
就是这样加上痛苦

00:18:32.149 --> 00:18:35.430
字符串与

00:18:33.330 --> 00:18:38.100
一个stringbuilder和一个pin stringbuilder 

00:18:35.430 --> 00:18:41.040
您注意到它们创建的大小

00:18:38.100 --> 00:18:43.830
相同数量的字节一百八十八

00:18:41.040 --> 00:18:46.380
字节Java七百字节Java 

00:18:43.830 --> 00:18:48.390
 800字节12 11 100 20字节

00:18:46.380 --> 00:18:50.370
我们将讨论更多，但Java级别与

00:18:48.390 --> 00:18:54.600
 Java 18 moment，其中包括驱动程序

00:18:50.370 --> 00:18:56.430
 9以及为什么这很好Java 7我

00:18:54.600 --> 00:18:58.350
在那天提到他们

00:18:56.430 --> 00:19:01.110
关注这些加号

00:18:58.350 --> 00:19:03.420
通过大量攻击服务器

00:19:01.110 --> 00:19:06.270
哈希码为零的字符串，因此它们

00:19:03.420 --> 00:19:09.900
通过拥有但通过拥有

00:19:06.270 --> 00:19:11.760
另一个哈希码int这就是所谓的哈希

00:19:09.900 --> 00:19:13.740
 32现在当我看到我真的

00:19:11.760 --> 00:19:17.010
兴奋，我现在觉得很棒

00:19:13.740 --> 00:19:19.410
系统将变得更快，而我

00:19:17.010 --> 00:19:22.470
使用了很多年却没有意识到

00:19:19.410 --> 00:19:26.640
直到新的它才起作用

00:19:22.470 --> 00:19:29.220
明确地将其打开

00:19:26.640 --> 00:19:32.100
至高无上的谈话就像是不是

00:19:29.220 --> 00:19:33.780
从来没有用过，所以好的

00:19:32.100 --> 00:19:37.080
具有哈希值32的东西仍然是

00:19:33.780 --> 00:19:39.030
线性成本，但他们使用一些

00:19:37.080 --> 00:19:41.040
随机化阻止你成为

00:19:39.030 --> 00:19:44.310
能够使总是相同的哈希码

00:19:41.040 --> 00:19:46.590
并且它们默认为一个不的哈希

00:19:44.310 --> 00:19:48.540
零的哈希值，如果不是最初的哈希值

00:19:46.590 --> 00:19:51.270
这将是一个哈希的哈希

00:19:48.540 --> 00:19:54.840
它跳得很多，所以如果你运行这个

00:19:51.270 --> 00:19:57.080
使用Java 7，他们必须快速复制

00:19:54.840 --> 00:19:57.080
服务器

00:19:57.710 --> 00:20:03.200
所以如果我们回到这里进行测试

00:20:01.050 --> 00:20:06.000
运行Java 7 

00:20:03.200 --> 00:20:08.130
第一个版本将完全是

00:20:06.000 --> 00:20:11.160
与Java 6一样也是线性的

00:20:08.130 --> 00:20:14.420
退化，因为我们将int的大小加倍

00:20:11.160 --> 00:20:16.170
接近速度慢一倍

00:20:14.420 --> 00:20:19.650
显然道路上有一些颠簸

00:20:16.170 --> 00:20:22.830
但这就是发生的事情，然后

00:20:19.650 --> 00:20:27.630
如果我添加字段，对不起

00:20:22.830 --> 00:20:30.540
环境变量，然后我们放

00:20:27.630 --> 00:20:33.990
现在在这里看舞会

00:20:30.540 --> 00:20:36.750
因为一旦我们可以，它首先变得更糟

00:20:33.990 --> 00:20:40.470
超过阈值则开始

00:20:36.750 --> 00:20:44.670
在32中使用它，所以一旦它过去

00:20:40.470 --> 00:20:46.140
 256它在32中使用它，然后得到

00:20:44.670 --> 00:20:49.440
我希望更快一点

00:20:46.140 --> 00:20:54.840
我知道我做错了

00:20:49.440 --> 00:20:58.170
现在，有些仍在使用Java 6 

00:20:54.840 --> 00:20:59.760
我确定的东西编译器

00:20:58.170 --> 00:21:06.270
但我可能会永远使用6 

00:20:59.760 --> 00:21:08.429
我可能出了点问题， 

00:21:06.270 --> 00:21:09.290
我觉得不太对劲

00:21:08.429 --> 00:21:13.170
确定什么

00:21:09.290 --> 00:21:15.000
这是DMS第一人称的工作，我

00:21:13.170 --> 00:21:17.610
几乎不必重新编译

00:21:15.000 --> 00:21:22.830
当然不是，我要重新编译它

00:21:17.610 --> 00:21:23.429
只是为了确保不，那我不是

00:21:22.830 --> 00:21:27.990
要做那个

00:21:23.429 --> 00:21:29.340
门槛哦，是的，我当然有

00:21:27.990 --> 00:21:32.480
我在那里的外观与众不同

00:21:29.340 --> 00:21:35.760
标记错误的位置，这很简单

00:21:32.480 --> 00:21:39.660
愚蠢，所以它应该意味着

00:21:35.760 --> 00:21:42.179
开始，所以你看到它最初

00:21:39.660 --> 00:21:45.270
它运行，然后一旦它得到

00:21:42.179 --> 00:21:49.679
超过阈值，它确实加快了速度

00:21:45.270 --> 00:21:52.410
对，所以哈希表查找为否

00:21:49.679 --> 00:21:55.860
更长的线性，因为您没有

00:21:52.410 --> 00:21:57.960
 as的元素的很少链接列表

00:21:55.860 --> 00:21:59.370
键，但您必须打开

00:21:57.960 --> 00:22:00.780
明确没有做那没有

00:21:59.370 --> 00:22:03.360
这些好处中的任何一个，以及

00:22:00.780 --> 00:22:04.890
再次是他们不想的原因

00:22:03.360 --> 00:22:06.690
自动执行是因为还有两个

00:22:04.890 --> 00:22:07.530
人们会抱怨他们的测试

00:22:06.690 --> 00:22:11.880
不再工作了

00:22:07.530 --> 00:22:15.750
嗯，还有另一个

00:22:11.880 --> 00:22:19.010
我们可能滥用的构造函数

00:22:15.750 --> 00:22:23.160
使我们通过数组并

00:22:19.010 --> 00:22:26.340
布尔值和阴影现在这是一个

00:22:23.160 --> 00:22:28.230
此类是因为方法是

00:22:26.340 --> 00:22:31.230
是软件包访问权限，但您可以访问

00:22:28.230 --> 00:22:34.440
带有阴影的秘密得到java.lang 

00:22:31.230 --> 00:22:37.049
使用char访问不安全的新字符串

00:22:34.440 --> 00:22:39.840
数组，然后会讨厌

00:22:37.049 --> 00:22:41.850
是不是和你经过的是同一托盘

00:22:39.840 --> 00:22:44.160
在字符串中，所以如果您想

00:22:41.850 --> 00:22:45.450
尽量减少您可以使用的内存使用量

00:22:44.160 --> 00:22:47.520
现在他们已经将其移出

00:22:45.450 --> 00:22:48.840
 Java 9有害的方式，而且不会

00:22:47.520 --> 00:22:50.460
在任何地方都可以正常使用戏剧，因为

00:22:48.840 --> 00:22:53.160
现在他们被追查到

00:22:50.460 --> 00:22:57.300
旅游业改变的另一件事

00:22:53.160 --> 00:22:58.850
是过去使用的子字符串

00:22:57.300 --> 00:23:00.380
至

00:22:58.850 --> 00:23:02.330
指向相同的新字符串

00:23:00.380 --> 00:23:05.090
字符数组，但与它不同

00:23:02.330 --> 00:23:07.400
和长度，并将其更改为

00:23:05.090 --> 00:23:09.320
新轮胎每次哪个哪个

00:23:07.400 --> 00:23:12.770
导致这是为很多公司

00:23:09.320 --> 00:23:14.780
在这里您可以轻松解决

00:23:12.770 --> 00:23:21.140
制作自己的小写字符串，但这是

00:23:14.780 --> 00:23:22.730
有点混乱，那只是整个

00:23:21.140 --> 00:23:24.500
删除那个的原因是要记什么

00:23:22.730 --> 00:23:26.630
如果获取大的XML文档，则泄漏

00:23:24.500 --> 00:23:28.760
这是一千兆字节，您需要用户

00:23:26.630 --> 00:23:30.350
身份证或其他东西

00:23:28.760 --> 00:23:31.430
指向原始数组的指针

00:23:30.350 --> 00:23:33.590
舔记忆，即使你只是

00:23:31.430 --> 00:23:35.450
认为您只有用户ID 

00:23:33.590 --> 00:23:37.490
删除jar Java的原因

00:23:35.450 --> 00:23:40.550
并非只有一次

00:23:37.490 --> 00:23:42.230
因此，例如来自Google的v8 

00:23:40.550 --> 00:23:43.490
他们进行了优化，然后

00:23:42.230 --> 00:23:50.360
删除它，他们把它放回去，因为

00:23:43.490 --> 00:23:54.110
用户抱怨很好JavaScript是的

00:23:50.360 --> 00:23:56.180
是的，是的，你知道没人能

00:23:54.110 --> 00:23:57.620
对两种选择都满意

00:23:56.180 --> 00:24:00.530
总是会抱怨的事

00:23:57.620 --> 00:24:04.310
不管你做什么

00:24:00.530 --> 00:24:07.670
 Java 8他们拥有的价值

00:24:04.310 --> 00:24:11.060
值作为char数组，并且在- 

00:24:07.670 --> 00:24:14.090
再次肾上腺素哈希32，因为他们

00:24:11.060 --> 00:24:16.010
解决了出生者的问题

00:24:14.090 --> 00:24:19.150
与线性链接

00:24:16.010 --> 00:24:22.580
一般地图的性能

00:24:19.150 --> 00:24:24.170
以及自哈希表以来的操作

00:24:22.580 --> 00:24:26.510
 Java尽您所能

00:24:24.170 --> 00:24:29.240
碰撞实际上创建了一个二进制文件

00:24:26.510 --> 00:24:31.970
为了使它正常工作

00:24:29.240 --> 00:24:35.420
您的钥匙必须是应该的

00:24:31.970 --> 00:24:38.180
可比这是为什么从Java 8开始

00:24:35.420 --> 00:24:40.760
应该始终进行所有键操作-代码

00:24:38.180 --> 00:24:42.890
相等且可比，以便您可以

00:24:40.760 --> 00:24:44.660
发挥出色的性能

00:24:42.890 --> 00:24:47.570
彼此改善8 

00:24:44.660 --> 00:24:49.760
向前也有一些顶尖

00:24:47.570 --> 00:24:51.350
 char数组的重复数据删除，所以我将展示

00:24:49.760 --> 00:24:56.420
你一秒钟，但我想跑

00:24:51.350 --> 00:24:58.990
再次使用Java 8进行测试，让我们开始吧

00:24:56.420 --> 00:24:58.990
到Java头

00:25:00.360 --> 00:25:07.380
提供，这次没有任何形式

00:25:03.990 --> 00:25:09.960
有趣的设置直接在盒子里

00:25:07.380 --> 00:25:11.970
可以看到随着我们增加

00:25:09.960 --> 00:25:15.630
地图尺寸性能不

00:25:11.970 --> 00:25:17.640
像以前一样严重退化

00:25:15.630 --> 00:25:20.220
这里所有的元素仍然在

00:25:17.640 --> 00:25:22.140
同一个桶，但是不是二叉树

00:25:20.220 --> 00:25:24.620
所以它是声明式评分

00:25:22.140 --> 00:25:29.610
与订单登录或任何意味着

00:25:24.620 --> 00:25:34.760
是的，您会看到此行为或

00:25:29.610 --> 00:25:37.740
一些Java 11以及同样重要的事情

00:25:34.760 --> 00:25:39.929
现在你当然在DC漫画了

00:25:37.740 --> 00:25:41.220
你失去的沙漠可能正是

00:25:39.929 --> 00:25:43.620
一样，但是你可以看到表现

00:25:41.220 --> 00:25:47.010
表现不如第六名

00:25:43.620 --> 00:25:49.500
因此，例如对于65,000 

00:25:47.010 --> 00:25:52.200
将地图合二为一的元素

00:25:49.500 --> 00:25:53.909
仍然意味着我正在做很多事情

00:25:52.200 --> 00:25:58.500
查找不仅是查找，还是

00:25:53.909 --> 00:25:59.880
现在性能足够

00:25:58.500 --> 00:26:02.700
重复数据删除相当不错

00:25:59.880 --> 00:26:03.600
功能，您可以在g1中获得此功能，而不是在

00:26:02.700 --> 00:26:05.970
其他三个C 

00:26:03.600 --> 00:26:07.980
我不知道为什么可能

00:26:05.970 --> 00:26:11.010
再添加一个水疗中心，但想法是

00:26:07.980 --> 00:26:13.260
是他们，如果你有多个

00:26:11.010 --> 00:26:14.669
具有相同内容的字符串或

00:26:13.260 --> 00:26:17.159
他们知道他们是不同的弦

00:26:14.669 --> 00:26:19.220
但他们让您知道

00:26:17.159 --> 00:26:22.350
兴趣不是创造者分开

00:26:19.220 --> 00:26:25.799
然后在对象移动到

00:26:22.350 --> 00:26:27.929
旧空间是Quattro Reigate 

00:26:25.799 --> 00:26:30.539
具有其他优势的阴影

00:26:27.929 --> 00:26:32.220
相同的值，所以这里是

00:26:30.539 --> 00:26:34.260
用牙做两根弦

00:26:32.220 --> 00:26:37.320
同一两个是一个，所以它将是两个

00:26:34.260 --> 00:26:39.179
与不同的撒拉的你的字符串

00:26:37.320 --> 00:26:41.340
可以在这里看到它的反射和

00:26:39.179 --> 00:26:42.929
打印出一个鼻息，并得到这个

00:26:41.340 --> 00:26:46.139
一个，你可以看到摩西五经

00:26:42.929 --> 00:26:48.690
 GC运行后，炬力有所不同

00:26:46.139 --> 00:26:50.159
现在我明确引用GC，它将

00:26:48.690 --> 00:26:52.860
即使你不这样做也会发生

00:26:50.159 --> 00:26:54.870
仍然可以删除重复数据删除

00:26:52.860 --> 00:26:57.419
第四诅咒旧空间会做到这一点

00:26:54.870 --> 00:27:00.870
然后您会看到现在

00:26:57.419 --> 00:27:03.630
有一个相同的字符，所以可以节省

00:27:00.870 --> 00:27:07.919
没有任何实际努力的记忆

00:27:03.630 --> 00:27:10.950
好吧，它应该通常吗

00:27:07.919 --> 00:27:11.310
从我们的C中得到的东西使事情有点

00:27:10.950 --> 00:27:13.980
慢

00:27:11.310 --> 00:27:15.630
因此性能可能会受到影响，但

00:27:13.980 --> 00:27:16.950
而且默认情况下您不会赢

00:27:15.630 --> 00:27:20.190
明确地转身，它只能工作

00:27:16.950 --> 00:27:25.800
与g1，但除此之外，我认为这是

00:27:20.190 --> 00:27:27.980
就我们而言，现在很酷

00:27:25.800 --> 00:27:30.690
长期以来，反过来是

00:27:27.980 --> 00:27:35.730
它从阴影中带给您力量

00:27:30.690 --> 00:27:41.940
字符串表，我们Dimitra现在我给了

00:27:35.730 --> 00:27:45.450
在JavaOne上的演讲Ostia削减了一个代码

00:27:41.940 --> 00:27:48.870
叫做冷一，我们给的代码一

00:27:45.450 --> 00:27:52.470
谈话，我们对人民撒谎，但我们

00:27:48.870 --> 00:27:54.450
你不是故意的，因为

00:27:52.470 --> 00:27:58.080
他们用Java livin改变了一些东西

00:27:54.450 --> 00:27:59.790
不告诉任何人我们还没有

00:27:58.080 --> 00:28:03.060
想出了他们实际做到的方式

00:27:59.790 --> 00:28:06.030
或他们记录下来的方式

00:28:03.060 --> 00:28:07.950
在做，但那是什么

00:28:06.030 --> 00:28:11.280
司机住了，他们改变了是否

00:28:07.950 --> 00:28:17.040
直到Java为止，构造实习表

00:28:11.280 --> 00:28:19.890
蒂姆实习生的桌子是固定的

00:28:17.040 --> 00:28:22.110
大小的桌子，总是素数

00:28:19.890 --> 00:28:26.100
你知道所有典型的数字

00:28:22.110 --> 00:28:29.130
哈希魔术他们和他们改变了

00:28:26.100 --> 00:28:31.500
在Java 11中要更改7 

00:28:29.130 --> 00:28:34.230
也是二的幂，所以它开始于

00:28:31.500 --> 00:28:36.720
您知道65,000，然后持续下去

00:28:34.230 --> 00:28:40.770
随着您添加更多字符串而增长

00:28:36.720 --> 00:28:42.750
为了减少数量

00:28:40.770 --> 00:28:43.530
您拥有的缓存之上的山脉

00:28:42.750 --> 00:28:45.540
在哈希图中

00:28:43.530 --> 00:28:48.240
在字符串表中，所以

00:28:45.540 --> 00:28:51.270
性能仍然不是很好

00:28:48.240 --> 00:28:53.940
实习表是你可以获得很多

00:28:51.270 --> 00:28:55.980
如果您做得更好的性能

00:28:53.940 --> 00:28:59.610
您自己的并发哈希图

00:28:55.980 --> 00:29:04.620
并用它来阻止重复的

00:28:59.610 --> 00:29:05.190
字符串，但这不是那么糟糕

00:29:04.620 --> 00:29:07.560
以前是

00:29:05.190 --> 00:29:09.570
 Java旅行之前，如果它是java java 

00:29:07.560 --> 00:29:13.140
水平这不是改变它，而是下降

00:29:09.570 --> 00:29:17.490
 12与12 11相同，这是什么

00:29:13.140 --> 00:29:20.450
改好了，因为识别

00:29:17.490 --> 00:29:22.920
将节省一些内存，因为您不在

00:29:20.450 --> 00:29:25.180
在torah中进行重复数据删除，但当然

00:29:22.920 --> 00:29:28.870
如果你有一个

00:29:25.180 --> 00:29:30.730
完整的，如果您是实习生或并发

00:29:28.870 --> 00:29:37.230
它将实际使用的哈希图

00:29:30.730 --> 00:29:37.230
为您节省更多的内存

00:29:42.600 --> 00:29:46.540
我会说说结构美

00:29:44.590 --> 00:29:48.820
我们将讨论结果或

00:29:46.540 --> 00:29:50.140
这项工作的影响，我是

00:29:48.820 --> 00:29:52.090
换了电池，我确定你已经

00:29:50.140 --> 00:29:54.520
听说他们也有一个

00:29:52.090 --> 00:29:57.700
柯达咬一口说什么是编码

00:29:54.520 --> 00:30:01.090
它的YouTube您知道它是否是YouTube 

00:29:57.700 --> 00:30:03.880
十六或utf-16或latin-1 

00:30:01.090 --> 00:30:07.720
对，他们不喜欢希腊人

00:30:03.880 --> 00:30:09.730
勒顿一嗯，他们也改变了

00:30:07.720 --> 00:30:11.380
他们做事的方式

00:30:09.730 --> 00:30:13.540
记住字符串串联

00:30:11.380 --> 00:30:17.350
我们在四到五个的前面

00:30:13.540 --> 00:30:18.970
重新编译我们所有的代码，这意味着

00:30:17.350 --> 00:30:21.429
以及构建事物的方式

00:30:18.970 --> 00:30:23.770
过去他们无法优化窗帘

00:30:21.429 --> 00:30:24.940
已经通过更改而被编译

00:30:23.770 --> 00:30:36.940
算法，我想现在是

00:30:24.940 --> 00:30:40.000
绝对是Dimitri，所以我们做了一个

00:30:36.940 --> 00:30:42.580
很少写一点基准来显示

00:30:40.000 --> 00:30:44.380
这些东西如何影响代码呢？ 

00:30:42.580 --> 00:30:46.570
您在屏幕上看到的是

00:30:44.380 --> 00:30:49.390
我们将字符串加在一起的基准

00:30:46.570 --> 00:30:52.870
 Java中带有字符串构建器的加号

00:30:49.390 --> 00:30:55.420
 5起，使用由串联的字符串

00:30:52.870 --> 00:30:57.520
存在和流向的方式

00:30:55.420 --> 00:31:01.929
格式以及整个画面

00:30:57.520 --> 00:31:04.470
版本6 7和8或多或少总是

00:31:01.929 --> 00:31:08.559
字符串生成器获胜还是宁可

00:31:04.470 --> 00:31:09.940
加和stringbuilder大小的磁带

00:31:08.559 --> 00:31:11.200
再加上一个字符串生成器是一样的

00:31:09.940 --> 00:31:14.590
因为那正是java c 

00:31:11.200 --> 00:31:16.420
发射，所以如果您要编写加号5 

00:31:14.590 --> 00:31:20.140
我们生成新的字符串生成器的代码

00:31:16.420 --> 00:31:22.630
追加一个追加5，这就是为什么加号是

00:31:20.140 --> 00:31:24.340
做比利一样，如果你知道

00:31:22.630 --> 00:31:27.550
前期字符串的大小，因此输入

00:31:24.340 --> 00:31:29.980
尺寸现在总是更快

00:31:27.550 --> 00:31:32.830
切换，然后您查看Java 11，然后

00:31:29.980 --> 00:31:35.440
加上实际获胜会赢得大笔交易， 

00:31:32.830 --> 00:31:37.350
特别是当你看的时候

00:31:35.440 --> 00:31:40.710
分配的字节

00:31:37.350 --> 00:31:42.840
所以恰恰在这里，您会看到

00:31:40.710 --> 00:31:44.970
两个特点之一是紧凑的琴弦

00:31:42.840 --> 00:31:46.950
记得在Java中，六位他们增加了字节

00:31:44.970 --> 00:31:49.140
数组字符擦除了一个

00:31:46.950 --> 00:31:51.120
特别标志，它在某处退休了

00:31:49.140 --> 00:31:53.910
在七到八点之间，因为他们

00:31:51.120 --> 00:31:56.160
意识到那不是很好

00:31:53.910 --> 00:31:58.950
想法，但他们也意识到的是

00:31:56.160 --> 00:32:03.390
如果您一般分析堆舞

00:31:58.950 --> 00:32:06.539
大约有25％的新事物

00:32:03.390 --> 00:32:08.370
 Java命中字符串和大多数

00:32:06.539 --> 00:32:11.240
字符串让一个编码，所以

00:32:08.370 --> 00:32:14.820
基本上是ASCII加加让一个

00:32:11.240 --> 00:32:16.350
几个更多的字符，但事情

00:32:14.820 --> 00:32:18.990
与拉丁语一路走来

00:32:16.350 --> 00:32:21.030
角色说它适合一口食

00:32:18.990 --> 00:32:22.710
以前总是有字符串utf-16 

00:32:21.030 --> 00:32:25.350
编码，这意味着需要两个字节

00:32:22.710 --> 00:32:28.200
这就是为什么我们要使用字符数组

00:32:25.350 --> 00:32:30.179
与Java九加，所以被替换

00:32:28.200 --> 00:32:31.970
即使在Java源代码上也没有更多

00:32:30.179 --> 00:32:34.650
字符数组总是三

00:32:31.970 --> 00:32:38.130
这带来了一些有趣的

00:32:34.650 --> 00:32:40.409
如果我们只是进行测验而没有

00:32:38.130 --> 00:32:41.820
一开始问我我们有点

00:32:40.409 --> 00:32:43.770
不同于此基准，因为

00:32:41.820 --> 00:32:46.890
在测验中，我们只附加了

00:32:43.770 --> 00:32:49.080
在这个基准中串在一起

00:32:46.890 --> 00:32:51.960
我们混合了一些参数

00:32:49.080 --> 00:32:54.059
我认为我的植入物长两倍

00:32:51.960 --> 00:32:55.470
不要加倍，但至少我们有

00:32:54.059 --> 00:32:57.240
一些数字和一些串在一起

00:32:55.470 --> 00:32:58.380
当你让你

00:32:57.240 --> 00:33:00.110
参数然后它确实使

00:32:58.380 --> 00:33:02.429
使用加号或加号的区别

00:33:00.110 --> 00:33:04.220
然后将stringbuilder大小或字符串加粗

00:33:02.429 --> 00:33:06.360
实际上确实有所作为

00:33:04.220 --> 00:33:08.549
只想再说一件事，如果

00:33:06.360 --> 00:33:12.809
你看那里的字符串格式

00:33:08.549 --> 00:33:16.830
简直太可怕了15次

00:33:12.809 --> 00:33:18.659
 15 X加2赔全是

00:33:16.830 --> 00:33:20.610
不输有一个日本三四八

00:33:18.659 --> 00:33:23.039
目前处于候选状态

00:33:20.610 --> 00:33:24.450
计划发布任何职位，但是

00:33:23.039 --> 00:33:26.610
你想做他们想输入吗

00:33:24.450 --> 00:33:28.320
 safai如此本质上的字符串格式

00:33:26.610 --> 00:33:29.669
将字符串格式调用转换为

00:33:28.320 --> 00:33:31.530
类似于字符串连接

00:33:29.669 --> 00:33:32.610
因为问题字符串格式是

00:33:31.530 --> 00:33:34.980
首先获取格式字符串

00:33:32.610 --> 00:33:37.020
您需要解析以查看

00:33:34.980 --> 00:33:39.120
军队是你传递的论点

00:33:37.020 --> 00:33:41.280
字符串格式需要装箱

00:33:39.120 --> 00:33:43.950
需要分配数组的对象

00:33:41.280 --> 00:33:45.750
而且有很多开销， 

00:33:43.950 --> 00:33:47.100
现在可以使用示例臭味卡

00:33:45.750 --> 00:33:48.570
优势，做事没有

00:33:47.100 --> 00:33:52.679
分配对象

00:33:48.570 --> 00:33:54.779
你能不能这么晚谈一谈

00:33:52.679 --> 00:33:58.289
从JDK九开始串联

00:33:54.779 --> 00:34:00.209
杰夫280（Heinz）提到了问题

00:33:58.289 --> 00:34:02.999
字符串连接，这是一个Java C 

00:34:00.209 --> 00:34:05.549
功能，因此每次您编译代码时

00:34:02.999 --> 00:34:07.109
 Java C将发出字节码，而Jade 

00:34:05.549 --> 00:34:08.730
将不得不使用该字节码

00:34:07.109 --> 00:34:10.589
错误，因此他们尝试优化

00:34:08.730 --> 00:34:12.149
他们做了很多事情

00:34:10.589 --> 00:34:15.029
然后他们意识到太多了

00:34:12.149 --> 00:34:17.639
努力支持JIT进行优化

00:34:15.029 --> 00:34:18.029
字符串，如果我们做某事怎么办

00:34:17.639 --> 00:34:19.889
不同

00:34:18.029 --> 00:34:24.599
如果将字符串编译到某一点怎么办

00:34:19.889 --> 00:34:27.450
我们制作了不同的字节码，然后让

00:34:24.599 --> 00:34:30.299
 VM对其进行了优化，因此从JDK开始

00:34:27.450 --> 00:34:34.609
如果您确实有一个站点，那么九点

00:34:30.299 --> 00:34:34.609
关于Java P输出以及如何编译

00:34:34.669 --> 00:34:40.440
好吧，那么发生了什么

00:34:38.429 --> 00:34:42.029
字节码级别，所以如果您这样编译

00:34:40.440 --> 00:34:44.279
首先，您必须重新编译

00:34:42.029 --> 00:34:45.899
您将无法使用的代码

00:34:44.279 --> 00:34:48.809
新字符串连接的优点

00:34:45.899 --> 00:34:51.299
除非您与一起编译

00:34:48.809 --> 00:34:53.009
 Java 11所以会发生的是你

00:34:51.299 --> 00:34:55.950
本来会调用动态指令

00:34:53.009 --> 00:34:58.950
在代码中发出并调用invoke 

00:34:55.950 --> 00:35:01.200
对于那些没有动力的人

00:34:58.950 --> 00:35:03.750
知道基本上是两个阶段

00:35:01.200 --> 00:35:05.279
过程，所以当它变冷时

00:35:03.750 --> 00:35:07.049
首先需要调用bootstrap方法

00:35:05.279 --> 00:35:08.640
知道我需要做些什么

00:35:07.049 --> 00:35:10.349
身材娇小的人在召唤侧返回， 

00:35:08.640 --> 00:35:12.210
从现在开始，它将始终称为

00:35:10.349 --> 00:35:13.650
通话方，因此他们基本上使用

00:35:12.210 --> 00:35:15.930
最初为以下功能添加的功能

00:35:13.650 --> 00:35:18.569
后来使用的动态语言

00:35:15.930 --> 00:35:20.279
从Java 8 for lambdas到现在

00:35:18.569 --> 00:35:21.720
一般9我们也将它用于学生

00:35:20.279 --> 00:35:24.000
串联，所以这个东西越来越多

00:35:21.720 --> 00:35:26.099
在整个vm中使用得更多，她

00:35:24.000 --> 00:35:29.009
实际上带来了两个超级大国

00:35:26.099 --> 00:35:30.240
看看实际的引导程序

00:35:29.009 --> 00:35:34.500
实现中有一个字符串叫做

00:35:30.240 --> 00:35:35.970
在jdk天使卡厂上有

00:35:34.500 --> 00:35:38.940
实际上有六种不同的策略

00:35:35.970 --> 00:35:41.609
连接字符串，以便大约两个

00:35:38.940 --> 00:35:44.009
第一组是生成的字节码

00:35:41.609 --> 00:35:46.529
基于字符串生成器，因此

00:35:44.009 --> 00:35:48.720
基本上是字节码来生成字符串

00:35:46.529 --> 00:35:50.250
像以前一样构建或使用

00:35:48.720 --> 00:35:52.109
方法一直向下处理

00:35:50.250 --> 00:35:54.269
有不同的变化

00:35:52.109 --> 00:35:56.130
他们都使用字符串生成器，但是

00:35:54.269 --> 00:35:59.009
默认值不同，因此默认值

00:35:56.130 --> 00:35:59.700
一个未分配的字符串生成器位于

00:35:59.009 --> 00:36:01.170
所有

00:35:59.700 --> 00:36:02.640
所以他们做什么，他们说没关系

00:36:01.170 --> 00:36:04.680
你被串联在什么东西

00:36:02.640 --> 00:36:06.720
最后你要创建一个字符串

00:36:04.680 --> 00:36:08.280
我有一个字节数组，所以为什么不

00:36:06.720 --> 00:36:10.500
只是分配字节数组并写入

00:36:08.280 --> 00:36:12.089
个字节放入右后数组以及何时

00:36:10.500 --> 00:36:13.650
他们创建一个字符串，他们将共享

00:36:12.089 --> 00:36:15.839
具有字符串的字节数组，因此将

00:36:13.650 --> 00:36:17.880
没什么特别的目的

00:36:15.839 --> 00:36:19.680
您在那里看到的数字大约为150个字节

00:36:17.880 --> 00:36:21.450
无论是多少字节

00:36:19.680 --> 00:36:23.940
 Pankot需要执行此操作不是

00:36:21.450 --> 00:36:27.599
当我觉得漂亮的时候浪费了一个字节

00:36:23.940 --> 00:36:29.820
太棒了，我们现在有

00:36:27.599 --> 00:36:31.800
基准二显示差异

00:36:29.820 --> 00:36:34.859
您看到的默认值之间

00:36:31.800 --> 00:36:40.200
一个是最快的，然后我们有

00:36:34.859 --> 00:36:42.050
胜利的不同变化，但我没有

00:36:40.200 --> 00:36:44.339
知道谁会改变

00:36:42.050 --> 00:36:46.950
串联结构

00:36:44.339 --> 00:36:49.230
就像一个消灭开关，所以你可以

00:36:46.950 --> 00:36:51.329
有一个错误，所以您可以选择

00:36:49.230 --> 00:36:55.829
知道修复错误，而无需安装

00:36:51.329 --> 00:36:57.500
新权利，现在回到鸿沟

00:36:55.829 --> 00:37:00.420
正如我所解释的

00:36:57.500 --> 00:37:02.849
将char压缩为图例一

00:37:00.420 --> 00:37:06.599
是一个扼杀开关紧凑的弦， 

00:37:02.849 --> 00:37:08.369
您可以禁用它，应该

00:37:06.599 --> 00:37:12.450
在开发过程中他们很有趣

00:37:08.369 --> 00:37:15.089
有点catch-22问题，因为紧凑

00:37:12.450 --> 00:37:18.240
字符串是常见的行标志，并且很常见

00:37:15.089 --> 00:37:19.800
行标志是字符串，现在你是

00:37:18.240 --> 00:37:22.680
在字符串类中，您需要

00:37:19.800 --> 00:37:25.290
看起来要查找公共线标志，因此

00:37:22.680 --> 00:37:27.240
那行不通，所以他们不得不做

00:37:25.290 --> 00:37:29.369
真的很奇怪

00:37:27.240 --> 00:37:30.810
解决他们有一个问题

00:37:29.369 --> 00:37:32.730
常数，不是常数

00:37:30.810 --> 00:37:34.410
被VM取代，因为没有其他

00:37:32.730 --> 00:37:36.480
他们尝试使用不安全的方式

00:37:34.410 --> 00:37:38.430
除字符串外，其他所有内容都是如此

00:37:36.480 --> 00:37:40.200
对于JVM启动很重要，如果我们只是

00:37:38.430 --> 00:37:41.940
暗恋我们每次他们尝试

00:37:40.200 --> 00:37:43.200
如果您了解更多，就会有所不同

00:37:41.940 --> 00:37:45.450
抬头

00:37:43.200 --> 00:37:47.640
亚历克斯的船让我们谈谈他的去向

00:37:45.450 --> 00:37:51.660
详细说明他们如何与虚拟机抗争

00:37:47.640 --> 00:37:54.329
有这样的愚蠢的标志，所以

00:37:51.660 --> 00:37:57.030
现在又回到了我们的基准

00:37:54.329 --> 00:37:59.490
有或没有的事实

00:37:57.030 --> 00:38:02.099
紧凑的字符串，如果您看到和

00:37:59.490 --> 00:38:03.900
再加上那里，我们看到了区别

00:38:02.099 --> 00:38:06.210
如果字符串是

00:38:03.900 --> 00:38:08.670
压缩或压缩不完全是2倍

00:38:06.210 --> 00:38:10.260
你会认为因为字符串对象

00:38:08.670 --> 00:38:11.270
你知道数组的指针吗？ 

00:38:10.260 --> 00:38:15.020
哈希码和其他东西

00:38:11.270 --> 00:38:21.230
它周围的其他东西，以及更多

00:38:15.020 --> 00:38:26.000
记忆分配给我，我想快速

00:38:21.230 --> 00:38:30.650
按钮并说有这个对我来说

00:38:26.000 --> 00:38:33.380
但福尔克人讨价还价是因为有些情况

00:38:30.650 --> 00:38:35.780
我让我觉得自己完成了

00:38:33.380 --> 00:38:38.390
表明它确实使

00:38:35.780 --> 00:38:41.119
性能差异

00:38:38.390 --> 00:38:43.369
最少，而Java 8 2009与

00:38:41.119 --> 00:38:46.760
这些紧凑的琴弦记录着

00:38:43.369 --> 00:38:48.170
优化很多，但到目前为止我们还没有

00:38:46.760 --> 00:38:50.660
能够写出基准

00:38:48.170 --> 00:38:54.200
尽力编写基准测试二

00:38:50.660 --> 00:38:57.560
证明这是Java 9中的问题

00:38:54.200 --> 00:38:59.420
但几乎就像你知道

00:38:57.560 --> 00:39:01.100
发生了什么事

00:38:59.420 --> 00:39:02.560
弄清楚我们正在测试它，我没有

00:39:01.100 --> 00:39:06.430
知道

00:39:02.560 --> 00:39:08.780
你知道入学考试正在进行中

00:39:06.430 --> 00:39:11.480
有一些有趣的边缘情况

00:39:08.780 --> 00:39:15.369
第一种情况是最大尺寸

00:39:11.480 --> 00:39:17.690
字符串，因此如果在JDK 8中分配

00:39:15.369 --> 00:39:20.960
基本上你可以说一个新角色

00:39:17.690 --> 00:39:22.910
数组整数最大值-2，即

00:39:20.960 --> 00:39:25.250
您可以使用Java中的最大数组大小

00:39:22.910 --> 00:39:28.220
创建一个大小为2的字符串

00:39:25.250 --> 00:39:30.740
 gdk9 plus中的十亿个元素排列良好

00:39:28.220 --> 00:39:33.580
你不能，因为你有一个字节数组

00:39:30.740 --> 00:39:36.830
所以它仍然是20亿个元素

00:39:33.580 --> 00:39:39.470
个字节，如果您的

00:39:36.830 --> 00:39:41.440
字符串是可压缩的，你可以这样做

00:39:39.470 --> 00:39:44.240
如果您的字符串是

00:39:41.440 --> 00:39:45.830
 utf-16字符串，您需要两次两次

00:39:44.240 --> 00:39:47.600
数组的大小是数组的一半

00:39:45.830 --> 00:39:50.300
你会得到，最终内存不足

00:39:47.600 --> 00:39:51.740
错误，说你不能分配

00:39:50.300 --> 00:39:53.690
大串，它给你1 

00:39:51.740 --> 00:39:55.400
最大值可以是十亿

00:39:53.690 --> 00:39:58.430
那是第一件事，第二件事， 

00:39:55.400 --> 00:40:01.160
某些操作，例如子串和

00:39:58.430 --> 00:40:05.780
其他东西可能会惹上麻烦

00:40:01.160 --> 00:40:09.380
因为当你走路时就像

00:40:05.780 --> 00:40:12.290
例如从压缩和

00:40:09.380 --> 00:40:20.300
未压缩的东西，但我也越来越

00:40:12.290 --> 00:40:22.480
让我们来谈谈内在的确定

00:40:20.300 --> 00:40:24.760
是

00:40:22.480 --> 00:40:27.010
还有另一件事，如果你看着琴弦

00:40:24.760 --> 00:40:28.270
和Java编码一般都有这个

00:40:27.010 --> 00:40:30.490
所谓内在的东西肯定

00:40:28.270 --> 00:40:32.319
 Java中的操作，您会看到

00:40:30.490 --> 00:40:34.299
他们有一个Java代码，但是

00:40:32.319 --> 00:40:36.940
实际上不是JVM在执行什么

00:40:34.299 --> 00:40:39.130
您运行它们，这只是一些列表

00:40:36.940 --> 00:40:44.770
与春天有关的内在罪过和JDK 

00:40:39.130 --> 00:40:47.710
 8，而如果看11，则远远不止这些

00:40:44.770 --> 00:40:49.930
好吧，我们基本上翻了一番的原因

00:40:47.710 --> 00:40:52.089
字符串工作之前的开销

00:40:49.930 --> 00:40:54.520
我们现在只在内部设置一个字符串类

00:40:52.089 --> 00:40:56.440
在utf-16中有拉丁语，所以我们

00:40:54.520 --> 00:40:59.559
加倍，有片刻

00:40:56.440 --> 00:41:01.450
这个编辑器现在还有另一个

00:40:59.559 --> 00:41:03.160
如果您看一下JDK 9，将会很有趣

00:41:01.450 --> 00:41:07.150
加上如何实现平等

00:41:03.160 --> 00:41:09.099
例如，此检查在

00:41:07.150 --> 00:41:10.569
开始，然后是字符串

00:41:09.099 --> 00:41:12.190
他们做的事情他们比较尾声

00:41:10.569 --> 00:41:14.020
所以这是一个特殊的情况

00:41:12.190 --> 00:41:16.450
他们编码不同的两个字符串

00:41:14.020 --> 00:41:18.160
根据定义不能相等，所以这是

00:41:16.450 --> 00:41:19.750
如果您比较，内部短路

00:41:18.160 --> 00:41:22.329
不相同的字符串

00:41:19.750 --> 00:41:24.280
编码我们可以跳过那件事，然后

00:41:22.329 --> 00:41:28.089
他们检查什么是通用编码

00:41:24.280 --> 00:41:30.130
称为这些方法之一，以便使

00:41:28.089 --> 00:41:31.960
关于内在的观点让我们看一下如何

00:41:30.130 --> 00:41:34.299
这种方法之一是像

00:41:31.960 --> 00:41:36.339
让1等于所以基本上我们只是

00:41:34.299 --> 00:41:37.900
如果您逐个数组元素

00:41:36.339 --> 00:41:39.460
发现任何不平等都会停止

00:41:37.900 --> 00:41:41.500
否则我们必须全部走

00:41:39.460 --> 00:41:43.599
到尽头的区域看到这一点

00:41:41.500 --> 00:41:47.079
注解热点内在候选

00:41:43.599 --> 00:41:49.900
它告诉VM该代码应为

00:41:47.079 --> 00:41:52.420
可能被其他东西取代

00:41:49.900 --> 00:41:53.920
如果其他东西可以解决这个问题

00:41:52.420 --> 00:41:56.859
特定的平台，所以这是平台

00:41:53.920 --> 00:42:03.910
依赖和其他一些事情来了

00:41:56.859 --> 00:42:05.740
发挥作用，是的，我们展示我们的理由

00:42:03.910 --> 00:42:07.980
 RS不匹配，就像这样

00:42:05.740 --> 00:42:11.250
从jdk开始的另一种方法

00:42:07.980 --> 00:42:14.890
 9让我们评估一下性能

00:42:11.250 --> 00:42:17.770
所以如果我们用

00:42:14.890 --> 00:42:21.309
字符串的不同长度

00:42:17.770 --> 00:42:24.160
基本上很快就快到了

00:42:21.309 --> 00:42:26.410
线性是如此字符串，但如果

00:42:24.160 --> 00:42:28.720
我们像他们那样手动进行

00:42:26.410 --> 00:42:31.869
他们喜欢手动操作阵列

00:42:28.720 --> 00:42:33.970
看到它降解的速度更快，所以我们

00:42:31.869 --> 00:42:37.080
有一些性能问题，如果您

00:42:33.970 --> 00:42:39.870
使用一些新的数组不匹配的东西

00:42:37.080 --> 00:42:41.520
它几乎等于字符串等于

00:42:39.870 --> 00:42:43.710
他们，所以我们在剧中看到的是

00:42:41.520 --> 00:42:45.930
实际上是内在的，所以代码

00:42:43.710 --> 00:42:48.090
我们在屏幕上看到了我们复制的内容， 

00:42:45.930 --> 00:42:49.440
尝试运行它，但不能确定

00:42:48.090 --> 00:42:51.660
不是最冷的东西正在使用

00:42:49.440 --> 00:42:53.460
代码被替换为矢量化

00:42:51.660 --> 00:42:56.220
循环而不是步行

00:42:53.460 --> 00:42:57.720
每个元素一次一个字节

00:42:56.220 --> 00:43:00.030
大步走八个字节

00:42:57.720 --> 00:43:04.140
字节，因此您基本上可以获得块

00:43:00.030 --> 00:43:05.580
而你他从记忆中成长

00:43:04.140 --> 00:43:07.170
所以有趣的一件事是

00:43:05.580 --> 00:43:11.490
他们实际上不带你不能

00:43:07.170 --> 00:43:13.560
对于重复数据删除权，所以在

00:43:11.490 --> 00:43:15.480
等于他们有道理

00:43:13.560 --> 00:43:17.580
所有其他区域都一样

00:43:15.480 --> 00:43:20.280
您可以看到相同的实例返回

00:43:17.580 --> 00:43:22.410
在当前字符串结构中为true 

00:43:20.280 --> 00:43:26.610
如果您是

00:43:22.410 --> 00:43:29.610
比较相等的字符串有一些

00:43:26.610 --> 00:43:31.170
今天的教训um使用plus和set 

00:43:29.610 --> 00:43:33.330
尽可能使用字符串生成器

00:43:31.170 --> 00:43:36.480
您必须重新编译代码以

00:43:33.330 --> 00:43:38.940
把握机会Chazz 

00:43:36.480 --> 00:43:40.380
如果您要使用我们也可以到达那里

00:43:38.940 --> 00:43:42.030
如果你不把你的代码，我已经

00:43:40.380 --> 00:43:44.610
看到了相同的代码库

00:43:42.030 --> 00:43:46.200
反过来广泛使用而不是看看

00:43:44.610 --> 00:43:48.900
您使用自己的缓存，因为它可以

00:43:46.200 --> 00:43:51.360
即使使用

00:43:48.900 --> 00:43:53.430
我们找到了改进的Java Devon版本

00:43:51.360 --> 00:43:56.010
更快地进入许多因素

00:43:53.430 --> 00:43:57.450
使用您自己的并发哈希图

00:43:56.010 --> 00:44:00.510
特别是太多的回报

00:43:57.450 --> 00:44:01.970
字符串可以有很大的不同

00:44:00.510 --> 00:44:04.500
她的琴弦可能很贵

00:44:01.970 --> 00:44:06.480
特别是如果哈希解析为零

00:44:04.500 --> 00:44:06.960
而且他们无能为力

00:44:06.480 --> 00:44:08.430
那

00:44:06.960 --> 00:44:10.290
你知道他们不能改变默认值

00:44:08.430 --> 00:44:13.200
哈希值，因为这会产生

00:44:10.290 --> 00:44:15.450
字符串本身的数据竞争

00:44:13.200 --> 00:44:18.090
我们这样做很危险

00:44:15.450 --> 00:44:21.360
绝对不能有危险数据

00:44:18.090 --> 00:44:23.460
发生率也超过了九

00:44:21.360 --> 00:44:25.230
我们没有字符串的字节数组

00:44:23.460 --> 00:44:28.620
查理只是记得你什么时候

00:44:25.230 --> 00:44:30.360
看着你的个人资料

00:44:28.620 --> 00:44:32.280
您正在寻找字节数组

00:44:30.360 --> 00:44:35.400
自Java九以来字符串不查尔斯

00:44:32.280 --> 00:44:38.760
以后我们就已经有了基准

00:44:35.400 --> 00:44:41.730
我们在我的github地毯上

00:44:38.760 --> 00:44:43.830
表演，你妈妈欢迎参加

00:44:41.730 --> 00:44:46.130
发表评论并尝试一下

00:44:43.830 --> 00:44:48.820
并尽力打破

00:44:46.130 --> 00:44:51.220
总是很高兴获得反馈

00:44:48.820 --> 00:44:53.130
最后一件事是什么

00:44:51.220 --> 00:44:58.030
有趣的内在函数

00:44:53.130 --> 00:45:02.260
只是一个奇怪的难题，所以英特尔有一个

00:44:58.030 --> 00:45:04.000
除其他性能外的机器

00:45:02.260 --> 00:45:07.930
当然结束，通常被认为是

00:45:04.000 --> 00:45:10.810
机器方法有时等于

00:45:07.930 --> 00:45:13.660
方法现在有时与

00:45:10.810 --> 00:45:17.260
方法将以零打开

00:45:13.660 --> 00:45:19.660
两个不同的字符串，所以两个不同

00:45:17.260 --> 00:45:21.790
一台机器上的字符串会

00:45:19.660 --> 00:45:26.140
有时在两岁时还给0 

00:45:21.790 --> 00:45:28.420
不同的字符串还可以，我们

00:45:26.140 --> 00:45:31.870
实际上是将其归结为比赛条件

00:45:28.420 --> 00:45:34.960
内在和与和与之间

00:45:31.870 --> 00:45:37.120
通常你知道解释代码的方式

00:45:34.960 --> 00:45:39.160
当他们关闭内在函数时

00:45:37.120 --> 00:45:41.200
这是Java的非常特定的版本

00:45:39.160 --> 00:45:43.390
八个非常具体地运行

00:45:41.200 --> 00:45:45.610
机器，所以本来很难

00:45:43.390 --> 00:45:46.810
回到很可能是因为

00:45:45.610 --> 00:45:48.190
他们已经艰难地升级了

00:45:46.810 --> 00:45:49.990
错误消失了，所以我们永远都无法繁殖

00:45:48.190 --> 00:45:52.990
再次有一个相当有趣的

00:45:49.990 --> 00:45:55.030
种族限制少，就这样

00:45:52.990 --> 00:45:57.790
来自我们，非常感谢您的收听谢谢

00:45:55.030 --> 00:46:00.880
迪米特里（Dimitri）和其他惊喜

00:45:57.790 --> 00:46:02.110
如果你以后不舒服就去那里

00:46:00.880 --> 00:46:03.820
在这上会有另一个惊喜

00:46:02.110 --> 00:46:05.740
谢谢我们有任何疑问

00:46:03.820 --> 00:46:06.220
大约在那里四分钟

00:46:05.740 --> 00:46:11.850
问题

00:46:06.220 --> 00:46:11.850
很多时间，是的，先生

00:46:12.650 --> 00:46:18.090
 Java-我们在Java 12中有了

00:46:15.870 --> 00:46:20.010
没有足够的变化，我们可以

00:46:18.090 --> 00:46:23.040
参加，所以司机12是同一家商店

00:46:20.010 --> 00:46:30.800
不管他们有这些这些

00:46:23.040 --> 00:46:33.230
所谓的字符串之一是

00:46:30.800 --> 00:46:36.750
您知道的字符串文字

00:46:33.230 --> 00:46:38.850
像打开三个引号，然后

00:46:36.750 --> 00:46:40.590
写自由浮动的东西

00:46:38.850 --> 00:46:42.870
发生和一系列相关的方法

00:46:40.590 --> 00:46:44.490
当我们不知道也许13 

00:46:42.870 --> 00:46:48.420
也许不是他们将其从12中推出

00:46:44.490 --> 00:46:50.700
可能是另一个字符串

00:46:48.420 --> 00:46:54.510
格式和原始对象对象

00:46:50.700 --> 00:46:56.040
哈希代码是琥珀色的东西

00:46:54.510 --> 00:46:57.630
我说有刺戳三四八

00:46:56.040 --> 00:46:59.970
候选国家（未定） 

00:46:57.630 --> 00:47:02.340
发布，这是另一件事

00:46:59.970 --> 00:47:04.830
将会发生，但除此之外

00:47:02.340 --> 00:47:07.680
字符串特定的家伙，我不知道

00:47:04.830 --> 00:47:09.180
我指的是两件事

00:47:07.680 --> 00:47:11.340
你知道从Java公墓

00:47:09.180 --> 00:47:12.720
戏剧性和下降八十九个棚户区

00:47:11.340 --> 00:47:14.250
如今相遇，就像你知道每一个

00:47:12.720 --> 00:47:17.700
半年，但变化不是

00:47:14.250 --> 00:47:19.770
不再有那么大的影响，所以我不

00:47:17.700 --> 00:47:23.780
不知道他们会做什么

00:47:19.770 --> 00:47:23.780
使用八点以外的东西

00:47:27.350 --> 00:47:35.250
这显然是卡通Java 8 

00:47:33.450 --> 00:47:37.340
不再安全地介绍我

00:47:35.250 --> 00:47:37.340
认为

00:47:42.680 --> 00:47:48.100
 [掌声] 

