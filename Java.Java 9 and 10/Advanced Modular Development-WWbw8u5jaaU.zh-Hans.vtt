WEBVTT
Kind: captions
Language: zh-Hans

00:00:05.050 --> 00:00:11.420
欢迎大家参加最后的拼图游戏

00:00:09.139 --> 00:00:14.750
今天是先进的模块化

00:00:11.420 --> 00:00:16.670
我的名字叫亚历克斯·巴克利

00:00:14.750 --> 00:00:18.860
在Oracle I的Java平台组中

00:00:16.670 --> 00:00:21.199
做这个演讲的前半部分，然后

00:00:18.860 --> 00:00:25.490
我的同事艾伦·贝特曼（Alan Bateman） 

00:00:21.199 --> 00:00:27.669
下半场是激动的时刻

00:00:25.490 --> 00:00:27.669
支持

00:00:29.529 --> 00:00:33.260
这是相信与否，即使

00:00:32.119 --> 00:00:37.820
这是一天的结束

00:00:33.260 --> 00:00:40.090
艾伦将进行的五次七巧板讲座中的三分之一

00:00:37.820 --> 00:00:43.399
有这些时间的日期和时间

00:00:40.090 --> 00:00:45.260
在演示的结尾，但是

00:00:43.399 --> 00:00:47.180
模块，服务和项目是

00:00:45.260 --> 00:00:49.940
引擎盖下的是明天在这个房间里

00:00:47.180 --> 00:00:52.370
然后我们也开始重复

00:00:49.940 --> 00:00:53.660
为JDK 9做准备的整个周期

00:00:52.370 --> 00:00:55.940
我认为那是星期三

00:00:53.660 --> 00:01:04.010
那就是不再重复

00:00:55.940 --> 00:01:07.490
明天，无论如何，这次谈话是在两个

00:01:04.010 --> 00:01:11.300
零件，它们实际上都是关于

00:01:07.490 --> 00:01:13.310
迁移，因为那里有一个

00:01:11.300 --> 00:01:15.590
您可以查看整个模块系统API 

00:01:13.310 --> 00:01:18.490
 Javadoc，但第一个

00:01:15.590 --> 00:01:21.560
最存在的问题是什么时候

00:01:18.490 --> 00:01:23.540
模块化jdk 9的应用程序是

00:01:21.560 --> 00:01:25.430
模块是从哪里来的？ 

00:01:23.540 --> 00:01:28.630
这才是真正的话题

00:01:25.430 --> 00:01:33.080
我要谈谈迁移您的

00:01:28.630 --> 00:01:36.500
应用程序自上而下，然后艾伦将

00:01:33.080 --> 00:01:38.750
谈论迁移坐的图书馆

00:01:36.500 --> 00:01:43.130
比您的应用程序更接近JDK 

00:01:38.750 --> 00:01:47.510
所以这是自下而上的迁移

00:01:43.130 --> 00:01:51.380
从本质上讲，应用程序迁移

00:01:47.510 --> 00:01:54.770
应用程序在顶部有三层

00:01:51.380 --> 00:01:57.650
您的jar文件在底部是

00:01:54.770 --> 00:02:00.460
 JDK和这个三明治的中间

00:01:57.650 --> 00:02:02.960
是装满一罐子

00:02:00.460 --> 00:02:06.020
从互联网上下载的

00:02:02.960 --> 00:02:11.030
最好的方法，扔给你

00:02:06.020 --> 00:02:14.629
项目拼图中的类路径

00:02:11.030 --> 00:02:17.870
将JDK转换为Java之类的模块

00:02:14.629 --> 00:02:20.599
基本Java日志记录Java续集和

00:02:17.870 --> 00:02:22.819
或XML模块是好东西

00:02:20.599 --> 00:02:25.370
总是问候他们的好处是

00:02:22.819 --> 00:02:27.590
强大的封装，让没人

00:02:25.370 --> 00:02:31.970
模块外部可以访问其

00:02:27.590 --> 00:02:34.489
内部和可靠的配置，因此

00:02:31.970 --> 00:02:38.239
模块知道他们需要什么， 

00:02:34.489 --> 00:02:40.790
如果这不需要设置类路径

00:02:38.239 --> 00:02:43.480
听起来不错，您可能想知道如何

00:02:40.790 --> 00:02:46.970
将您的应用程序变成模块

00:02:43.480 --> 00:02:49.970
让我们在罐子上放一些名字

00:02:46.970 --> 00:02:52.640
首先，让我们假设

00:02:49.970 --> 00:02:55.400
主要应用是我的应用jar 

00:02:52.640 --> 00:02:56.930
我的Lib jar中有一些帮助程序代码， 

00:02:55.400 --> 00:02:58.790
让我们假设

00:02:56.930 --> 00:03:00.590
第三方罐子

00:02:58.790 --> 00:03:03.220
三明治可以简化为

00:03:00.590 --> 00:03:06.680
 Jackson JSON处理库

00:03:03.220 --> 00:03:13.040
杰克逊来了三个罐子的核心数据

00:03:06.680 --> 00:03:15.049
绑定和注释当然要运行

00:03:13.040 --> 00:03:16.640
今天的应用程序，您必须确保

00:03:15.049 --> 00:03:18.440
类路径是这样设置的

00:03:16.640 --> 00:03:20.599
一切都在我的Lib目录中

00:03:18.440 --> 00:03:22.700
首先要有我的东西，然后

00:03:20.599 --> 00:03:29.120
杰克逊罐子，然后是我的主班

00:03:22.700 --> 00:03:31.549
问题JDK AIDS现在您不再需要

00:03:29.120 --> 00:03:33.709
长时间的打扰

00:03:31.549 --> 00:03:37.730
将类路径设置为此和

00:03:33.709 --> 00:03:42.109
另一个是我的APR和我的lib车

00:03:37.730 --> 00:03:44.810
变成模块，现在转动每个罐子

00:03:42.109 --> 00:03:47.480
一对一地讲是相当公平的

00:03:44.810 --> 00:03:50.389
自然的前进方式并不总是

00:03:47.480 --> 00:03:53.299
可能尤其在罐子具有循环性的情况下

00:03:50.389 --> 00:03:58.430
他们的班级之间的依赖关系

00:03:53.299 --> 00:04:00.620
现在就让我们一起去吧

00:03:58.430 --> 00:04:02.780
看到一个模块，你应该问两个

00:04:00.620 --> 00:04:07.069
质疑它需要什么以及什么

00:04:02.780 --> 00:04:09.949
它是否出口，让我们问每个

00:04:07.069 --> 00:04:12.160
我们的预期模块我的应用程序和我的

00:04:09.949 --> 00:04:12.160
解放

00:04:13.920 --> 00:04:20.459
找出模块可能的一种方法

00:04:16.769 --> 00:04:24.180
要求是在罐子上运行Jade EPS 

00:04:20.459 --> 00:04:29.370
您拥有Jade EPS的文件是其中的工具

00:04:24.180 --> 00:04:32.669
分析jar文件中的类的JDK 8 

00:04:29.370 --> 00:04:35.760
并找到他们所引用的任何类

00:04:32.669 --> 00:04:36.840
在其他jar文件中，这是结果

00:04:35.760 --> 00:04:40.620
 Jade EPS的运行

00:04:36.840 --> 00:04:43.560
我的下巴和我的利比在上课

00:04:40.620 --> 00:04:45.840
我的apt jar使用了

00:04:43.560 --> 00:04:49.080
杰克逊核心和杰克逊数据绑定罐

00:04:45.840 --> 00:04:52.830
当然在我的活罐子里

00:04:49.080 --> 00:04:55.169
助手加上我的应用程序点罐使用类

00:04:52.830 --> 00:04:57.419
从Java基本模块中我很漂亮

00:04:55.169 --> 00:05:00.030
确保java.lang对象在其中

00:04:57.419 --> 00:05:03.690
因为这是在基础和字符串

00:05:00.030 --> 00:05:05.870
厄尔曼人，为了论证它

00:05:03.690 --> 00:05:10.680
也使用Java续集

00:05:05.870 --> 00:05:14.310
我的lib jar只能使用类

00:05:10.680 --> 00:05:17.790
来自Java基本模块，所以很好

00:05:14.310 --> 00:05:19.860
和简单的箭头是我的应用程序取决于

00:05:17.790 --> 00:05:21.900
在各种各样的事情上，我的lib和

00:05:19.860 --> 00:05:27.090
那我的lib只是为了争辩

00:05:21.900 --> 00:05:29.250
取决于JDK本身，因此

00:05:27.090 --> 00:05:32.760
这些知识我们可以编写模块

00:05:29.250 --> 00:05:36.990
声明是模块信息Java 

00:05:32.760 --> 00:05:40.169
我的助手库中的所有文件

00:05:36.990 --> 00:05:42.570
现在需要的是Java点库

00:05:40.169 --> 00:05:44.820
从未真正需要编写Java基础

00:05:42.570 --> 00:05:47.760
因为实际上是不可能写的

00:05:44.820 --> 00:05:50.190
没有间接的Java程序

00:05:47.760 --> 00:05:53.729
依靠java.lang对象，所以我们总是

00:05:50.190 --> 00:05:55.200
给你对Java基础的依赖

00:05:53.729 --> 00:05:57.530
免费，即使您不写

00:05:55.200 --> 00:06:00.900
来源，但将其放在此处清楚

00:05:57.530 --> 00:06:02.460
现在这里有出口

00:06:00.900 --> 00:06:05.850
我亲手写的

00:06:02.460 --> 00:06:10.320
 Jade EPS无法切实帮助您

00:06:05.850 --> 00:06:13.070
确定您的罐子的出口，我们

00:06:10.320 --> 00:06:15.180
可以说它出口了所有东西， 

00:06:13.070 --> 00:06:17.370
在编写模块时

00:06:15.180 --> 00:06:19.830
声明您仍然必须选择

00:06:17.370 --> 00:06:23.220
假设我的lib导出了一个包

00:06:19.830 --> 00:06:26.099
将我的apt Lib util通讯到我的应用

00:06:23.220 --> 00:06:27.569
现在我们要制作的模块是

00:06:26.099 --> 00:06:30.179
合格的X 

00:06:27.569 --> 00:06:32.929
但是因为它具体说明了

00:06:30.179 --> 00:06:36.539
其他模块，即我的应用程序可以访问

00:06:32.929 --> 00:06:40.939
这个导出的包，特别是

00:06:36.539 --> 00:06:40.939
该导出包的公共类型

00:06:41.479 --> 00:06:48.360
现在转到模块信息点

00:06:44.129 --> 00:06:52.319
我的应用程序的Java文件需要我的Lib 

00:06:48.360 --> 00:06:55.860
我们新创建的模块，它需要

00:06:52.319 --> 00:06:58.589
 Java基础和Java续集，当然

00:06:55.860 --> 00:07:02.009
我们知道它将使用杰克逊

00:06:58.589 --> 00:07:04.919
所以我们要写要求杰克逊

00:07:02.009 --> 00:07:07.110
核心，并要求Jackson数据绑定

00:07:04.919 --> 00:07:09.539
表示我是

00:07:07.110 --> 00:07:12.479
我的应用程序必须编写模块信息点

00:07:09.539 --> 00:07:14.309
杰克逊的Java文件

00:07:12.479 --> 00:07:20.550
我无法控制那些会很痛苦

00:07:14.309 --> 00:07:24.419
如果只有某种方式可以保存jar文件

00:07:20.550 --> 00:07:31.949
 Jackson jar文件成为模块

00:07:24.419 --> 00:07:34.439
在这种情况下，我们可以自动

00:07:31.949 --> 00:07:36.869
编写我的应用程序的声明

00:07:34.439 --> 00:07:40.199
这样的Java模块的模块工作量

00:07:36.869 --> 00:07:44.819
我们只需要像那些罐子一样

00:07:40.199 --> 00:07:47.879
其他模块，我们将有一个美丽的

00:07:44.819 --> 00:07:50.219
我的应用程序的模块增长取决于

00:07:47.879 --> 00:07:52.169
我的库，这是两个显式模块

00:07:50.219 --> 00:07:54.769
和我的应用，具体取决于

00:07:52.169 --> 00:08:01.439
杰克逊模块，然后也下降

00:07:54.769 --> 00:08:05.089
您可以执行JDK模块

00:08:01.439 --> 00:08:09.180
解决方案是自动模块

00:08:05.089 --> 00:08:12.209
自动模块是您的jar文件

00:08:09.180 --> 00:08:15.389
放在模块路径上，而不是放在

00:08:12.209 --> 00:08:20.430
一旦完成，就可以上课

00:08:15.389 --> 00:08:22.169
一个真正的模块，您无需更改任何人

00:08:20.430 --> 00:08:23.399
其他的jar文件，你不要放，你不要

00:08:22.169 --> 00:08:26.729
改变它的清单，你不要放任何

00:08:23.399 --> 00:08:30.329
类文件到它的名称

00:08:26.729 --> 00:08:32.069
模块是从jar文件名派生的

00:08:30.329 --> 00:08:33.500
以相当明显的方式剥离

00:08:32.069 --> 00:08:37.170
版本结束另一件事

00:08:33.500 --> 00:08:38.880
该自动模块会导出所有

00:08:37.170 --> 00:08:40.950
包，就像肯定有

00:08:38.880 --> 00:08:42.570
你别无他法

00:08:40.950 --> 00:08:44.910
从中导出所有软件包

00:08:42.570 --> 00:08:48.000
自动模块和自动

00:08:44.910 --> 00:08:50.240
模块需要所有其他模块

00:08:48.000 --> 00:08:54.930
在系统中

00:08:50.240 --> 00:08:57.510
因此，实际上，自动模块意味着

00:08:54.930 --> 00:08:59.460
今天的jar文件确实可以在JDK上运行

00:08:57.510 --> 00:09:02.670
八个是明天可以使用的模块

00:08:59.460 --> 00:09:07.770
经常在JDK 9中充当模块

00:09:02.670 --> 00:09:10.680
没有你就做什么

00:09:07.770 --> 00:09:13.010
一次对他们做任何事情

00:09:10.680 --> 00:09:16.110
自动模块应运而生

00:09:13.010 --> 00:09:18.090
用于杰克逊核心jax和数据绑定，以及

00:09:16.110 --> 00:09:19.170
杰克逊注释模块图

00:09:18.090 --> 00:09:22.170
看起来很不一样

00:09:19.170 --> 00:09:24.800
自动模块基本上需要

00:09:22.170 --> 00:09:27.270
一切都是功能而不是错误

00:09:24.800 --> 00:09:29.640
他们需要彼此，他们需要所有

00:09:27.270 --> 00:09:31.200
 JDK映像中的模块以及所有

00:09:29.640 --> 00:09:34.350
您的模块错误正在发生

00:09:31.200 --> 00:09:36.690
现在还可以提供

00:09:34.350 --> 00:09:40.080
最大可能

00:09:36.690 --> 00:09:43.770
所有代码的兼容面

00:09:40.080 --> 00:09:46.560
 jar文件，您可能会认为

00:09:43.770 --> 00:09:50.010
模块系统可以在

00:09:46.560 --> 00:09:51.660
 jar文件中的这三个jar文件

00:09:50.010 --> 00:09:54.090
启动并尝试找出什么

00:09:51.660 --> 00:09:56.520
他们需要的模块，但是不需要

00:09:54.090 --> 00:09:57.690
真的有帮助，它使我们保持的原因

00:09:56.520 --> 00:10:00.480
它无济于事的原因有点微妙

00:09:57.690 --> 00:10:02.910
事情是，你的图书馆

00:10:00.480 --> 00:10:05.790
通常在填充

00:10:02.910 --> 00:10:08.280
三明治经常利用芯

00:10:05.790 --> 00:10:12.150
反射即java.lang反映

00:10:08.280 --> 00:10:16.320
 api，他们使用它来检查类

00:10:12.150 --> 00:10:18.920
动态，现在Jade EPS可以看到

00:10:16.320 --> 00:10:22.760
核心反射API的调用

00:10:18.920 --> 00:10:25.620
但它不能很好地预测

00:10:22.760 --> 00:10:30.090
从美学上讲，什么班级是

00:10:25.620 --> 00:10:32.220
动态检查，实际上

00:10:30.090 --> 00:10:33.990
 Jackson数据绑定模块确实正确

00:10:32.220 --> 00:10:36.630
正是利用了Cora屈曲

00:10:33.990 --> 00:10:40.410
当我的应用程序中的代码在这里执行

00:10:36.630 --> 00:10:43.440
导入杰克逊api，然后调用

00:10:40.410 --> 00:10:46.279
它通过的杰克逊api对象映射器

00:10:43.440 --> 00:10:49.160
那里是它传递的最后一个论点

00:10:46.279 --> 00:10:52.009
它是自己的类对象，目的是

00:10:49.160 --> 00:10:54.829
 Jackson数据绑定可以创建一个

00:10:52.009 --> 00:10:57.680
我的值类的实例是

00:10:54.829 --> 00:10:59.480
一个应用程序类为什么可以

00:10:57.680 --> 00:11:01.399
然后将字段名称分配给Bob和

00:10:59.480 --> 00:11:05.420
年龄为13岁，因为这是JSON 

00:11:01.399 --> 00:11:08.389
对象映射现在在珍娜键九上

00:11:05.420 --> 00:11:10.939
这段代码不会成功，因为我们从来没有

00:11:08.389 --> 00:11:16.189
实际上是想说什么

00:11:10.939 --> 00:11:19.249
模块我的应用程序导出我的应用程序不

00:11:16.189 --> 00:11:23.449
真的有一个API，它是顶级节点

00:11:19.249 --> 00:11:26.509
这是应用程序，但需要

00:11:23.449 --> 00:11:28.999
无论如何导出一些包，您可能

00:11:26.509 --> 00:11:29.480
查找您是否在使用任何框架

00:11:28.999 --> 00:11:31.100
所有

00:11:29.480 --> 00:11:32.509
即使你不认为

00:11:31.100 --> 00:11:34.579
您拥有一个API的应用程序

00:11:32.509 --> 00:11:37.939
别人称你有这个隐性

00:11:34.579 --> 00:11:41.300
无论如何，您都可以在API右侧添加API或

00:11:37.939 --> 00:11:44.509
在实体上或在路径上，或者您通过

00:11:41.300 --> 00:11:50.600
您自己的任何类对象，直至

00:11:44.509 --> 00:11:56.050
库的解决方案是声明我的

00:11:50.600 --> 00:11:59.509
应用作为每周弱模块

00:11:56.050 --> 00:12:01.610
以某种方式导出其所有包装

00:11:59.509 --> 00:12:04.750
允许像杰克逊这样的框架

00:12:01.610 --> 00:12:08.240
数据绑定以反映其内部

00:12:04.750 --> 00:12:10.699
您无需手动导出

00:12:08.240 --> 00:12:12.709
一个接一个地打包，然后保留这个

00:12:10.699 --> 00:12:16.550
模块声明是最新的

00:12:12.709 --> 00:12:18.470
具有弱模块的我的应用程序的源代码树

00:12:16.550 --> 00:12:22.009
实际上，您从中受益

00:12:18.470 --> 00:12:24.350
可靠的依赖关系，但没有

00:12:22.009 --> 00:12:26.870
的全部力量或全部力量

00:12:24.350 --> 00:12:29.870
强大的封装框架

00:12:26.870 --> 00:12:31.910
反映应用程序代码是

00:12:29.870 --> 00:12:33.800
日常Java开发中的现实

00:12:31.910 --> 00:12:36.079
他们并不会因此消失

00:12:33.800 --> 00:12:39.679
像我的应用程序一样的应用程序代码

00:12:36.079 --> 00:12:41.360
总是被强烈封装

00:12:39.679 --> 00:12:44.059
框架中的业务价值

00:12:41.360 --> 00:12:48.319
反省地给您回电，以便我们

00:12:44.059 --> 00:12:50.809
认为这个弱修正

00:12:48.319 --> 00:12:53.240
模块声明的开始是

00:12:50.809 --> 00:12:56.329
关于此性质的明确声明

00:12:53.240 --> 00:12:58.500
它是开放的反思，但

00:12:56.329 --> 00:13:01.870
它没有API 

00:12:58.500 --> 00:13:05.470
没有弱修饰符的模块

00:13:01.870 --> 00:13:12.160
它通过以下方式明确定义了API： 

00:13:05.470 --> 00:13:16.750
导出语句，让我们回到

00:13:12.160 --> 00:13:19.210
模块图很杂乱，但是

00:13:16.750 --> 00:13:21.970
比一切都还好

00:13:19.210 --> 00:13:23.290
罐子在类路径上的方式是因为

00:13:21.970 --> 00:13:25.030
我应该说我的应用，因为我的应用是

00:13:23.290 --> 00:13:28.930
现在导出它需要执行的操作

00:13:25.030 --> 00:13:32.920
表示数据绑定的箭头会

00:13:28.930 --> 00:13:34.570
隐式地要求我的应用程序是

00:13:32.920 --> 00:13:36.280
然后从我的应用程序导出

00:13:34.570 --> 00:13:38.160
因为这是一周的课程， 

00:13:36.280 --> 00:13:40.810
数据绑定的反射将起作用

00:13:38.160 --> 00:13:43.090
但是总体图还是不错的

00:13:40.810 --> 00:13:45.310
凌乱但比班级要好

00:13:43.090 --> 00:13:50.110
因为例如没有箭头

00:13:45.310 --> 00:13:53.560
从我的库到我的应用程序，所以没有

00:13:50.110 --> 00:13:57.460
 Lib中意外存在代码危险

00:13:53.560 --> 00:13:59.530
深入了解我的应用内部

00:13:57.460 --> 00:14:02.020
我的活动jar中的类路径代码可以

00:13:59.530 --> 00:14:03.820
轻松访问我的应用程序罐中的代码

00:14:02.020 --> 00:14:05.860
它只是在扫描类路径，直到

00:14:03.820 --> 00:14:07.480
你会发现课程和那种

00:14:05.860 --> 00:14:10.990
混乱是导致维护的原因

00:14:07.480 --> 00:14:13.090
实际上，如果您头痛， 

00:14:10.990 --> 00:14:16.540
想一想最后的课堂路径

00:14:13.090 --> 00:14:20.550
请上课之路

00:14:16.540 --> 00:14:24.250
 10罐，您有100种可能的方式

00:14:20.550 --> 00:14:26.400
这些罐子中的类来交互

00:14:24.250 --> 00:14:28.780
班级路线是亚航的终极目标

00:14:26.400 --> 00:14:30.940
无论你知道什么结构

00:14:28.780 --> 00:14:33.550
您的系统的类路径将其抛出

00:14:30.940 --> 00:14:36.490
走开，将一切都连接到每个人

00:14:33.550 --> 00:14:38.920
否则，这意味着班级冲突

00:14:36.490 --> 00:14:41.380
和缺少类和重复

00:14:38.920 --> 00:14:43.750
通常放在不同的罐子里

00:14:41.380 --> 00:14:47.470
每次缓慢进行顺序查找

00:14:43.750 --> 00:14:49.510
 VM需要经常使用的类

00:14:47.470 --> 00:14:52.690
您要告诉编译器的模块

00:14:49.510 --> 00:14:54.640
 VM关于您的系统结构

00:14:52.690 --> 00:14:56.050
和你知道的自动模块

00:14:54.640 --> 00:14:58.150
清洁与

00:14:56.050 --> 00:15:01.300
可用性，但一切都可行

00:14:58.150 --> 00:15:03.100
您正在告诉编译器ovm关于

00:15:01.300 --> 00:15:07.170
系统的结构，最后

00:15:03.100 --> 00:15:07.170
他们利用这些信息

00:15:07.660 --> 00:15:12.860
说到编译器，让我们看看

00:15:11.089 --> 00:15:14.839
您为这些模块声明运行它

00:15:12.860 --> 00:15:16.839
我一直在谈论我们已经

00:15:14.839 --> 00:15:19.700
 Lib目录中的Jax和jar文件

00:15:16.839 --> 00:15:21.680
他们一直在哪里，我们要去

00:15:19.700 --> 00:15:24.440
在编译时将它们视为

00:15:21.680 --> 00:15:27.920
自动模块，方法是将它们放在

00:15:24.440 --> 00:15:30.290
编译器的模块路径，然后

00:15:27.920 --> 00:15:32.959
在我的应用程序和我的嘴唇来源

00:15:30.290 --> 00:15:34.370
源目录，我们告诉Java C 

00:15:32.959 --> 00:15:37.760
关于这个目录与这个新

00:15:34.370 --> 00:15:39.740
模块源路径选项，那就是

00:15:37.760 --> 00:15:42.740
必要的，因为那里有一个

00:15:39.740 --> 00:15:45.980
目录层次结构中的新级别

00:15:42.740 --> 00:15:47.899
这些模块，让我们开始吧，您可以看到对我的排序

00:15:45.980 --> 00:15:51.860
 app和我的lib在

00:15:47.899 --> 00:15:54.050
传统的编译时间层次结构

00:15:51.860 --> 00:15:56.600
我们可以输入源模块名称

00:15:54.050 --> 00:15:58.550
然后模块信息点Java，然后

00:15:56.600 --> 00:16:02.360
同一级别的程序包层次结构

00:15:58.550 --> 00:16:05.209
作为在Java上推断结果的模块

00:16:02.360 --> 00:16:10.339
然后是类文件减去mod中的D 

00:16:05.209 --> 00:16:12.890
我们可以运行jar来建立我的目录

00:16:10.339 --> 00:16:15.950
 Libby基于mod中的类

00:16:12.890 --> 00:16:20.470
我的嘴唇，我们可以运行罐子来建立我的应用程序

00:16:15.950 --> 00:16:22.250
从我的应用程序中的类的罐子里

00:16:20.470 --> 00:16:25.390
因为它将成为主要课程

00:16:22.250 --> 00:16:31.670
我们在命令行上指定

00:16:25.390 --> 00:16:33.920
然后因为这些jar文件

00:16:31.670 --> 00:16:36.649
其中的模块信息点类文件

00:16:33.920 --> 00:16:39.550
从照片中的to模块编译

00:16:36.649 --> 00:16:42.890
我们称其为模块化jar的Java文件

00:16:39.550 --> 00:16:45.829
模块化罐子是一个术语，您会听到

00:16:42.890 --> 00:16:52.459
在接下来的会谈中

00:16:45.829 --> 00:16:55.370
按此顺序进行操作，这样您就可以

00:16:52.459 --> 00:16:59.170
使用以下命令运行模块Erised应用程序

00:16:55.370 --> 00:17:03.260
这个简单的命令行所有的东西

00:16:59.170 --> 00:17:05.179
过去传给负CP的现在

00:17:03.260 --> 00:17:08.720
包装在推断的模块中

00:17:05.179 --> 00:17:10.400
显式模块所在的类文件

00:17:08.720 --> 00:17:13.250
艾米丽（Emily），但我想我正从那里搬到那里

00:17:10.400 --> 00:17:15.770
国防部和自动杰克和

00:17:13.250 --> 00:17:20.100
模块始终位于Lib中

00:17:15.770 --> 00:17:23.789
曾经就是这样

00:17:20.100 --> 00:17:27.360
所以我们模块化提出了一个应用程序

00:17:23.789 --> 00:17:30.179
首先我们建立了两种技术

00:17:27.360 --> 00:17:32.760
我们自己的应用程序代码的jar文件

00:17:30.179 --> 00:17:36.360
通过在照片中编写和编译模块

00:17:32.760 --> 00:17:38.970
 Java文件，我们还创建了自动文件

00:17:36.360 --> 00:17:41.490
库的第三方代码模块

00:17:38.970 --> 00:17:45.030
只需将其jar文件放入代码

00:17:41.490 --> 00:17:47.010
在通过该Lib的模块路径上

00:17:45.030 --> 00:17:49.980
目录到模块路径，而不是

00:17:47.010 --> 00:17:52.380
上课的路径，所以如果您愿意可以考虑

00:17:49.980 --> 00:17:53.520
作为自上而下的迁移，我写道

00:17:52.380 --> 00:17:55.350
的模块声明

00:17:53.520 --> 00:17:58.049
申请，然后有点担心

00:17:55.350 --> 00:17:59.490
关于它下面的内容，如果

00:17:58.049 --> 00:18:01.980
我说自上而下你应该怎么想

00:17:59.490 --> 00:18:06.080
自下而上的迁移看起来像和

00:18:01.980 --> 00:18:06.080
为此，我将交给艾伦

00:18:11.460 --> 00:18:19.360
库迁移，这是第二次

00:18:13.960 --> 00:18:20.140
部分，所以我们将回滚到我们

00:18:19.360 --> 00:18:24.430
在开始时

00:18:20.140 --> 00:18:26.530
介绍我们进行模块化的地方

00:18:24.430 --> 00:18:27.790
平台在底部或三明治

00:18:26.530 --> 00:18:30.640
中间和我们的jar文件

00:18:27.790 --> 00:18:33.550
应用程序附带的任何库

00:18:30.640 --> 00:18:34.900
与顶部，所以我们要去

00:18:33.550 --> 00:18:39.340
要做的是我们将从底部开始

00:18:34.900 --> 00:18:41.590
现在尝试移动这些de Jackson 

00:18:39.340 --> 00:18:44.620
我们要移动的jar文件

00:18:41.590 --> 00:18:48.660
并迁移这两个模块，以便我们

00:18:44.620 --> 00:18:53.020
最终得到这张照片绿色是模块

00:18:48.660 --> 00:18:56.920
玛雅对不起，橙色是

00:18:53.020 --> 00:18:59.470
类路径与Alex在

00:18:56.920 --> 00:19:01.660
演示的第一部分

00:18:59.470 --> 00:19:04.120
你在移民的时候

00:19:01.660 --> 00:19:06.820
你看到一个模块，你必须问我们

00:19:04.120 --> 00:19:08.950
问题他们需要什么

00:19:06.820 --> 00:19:12.160
他们是否说他们要出口什么

00:19:08.950 --> 00:19:13.600
我们三个杰克逊jar文件中的每个文件，如果

00:19:12.160 --> 00:19:15.130
我们将把它们视为模块

00:19:13.600 --> 00:19:19.420
我们需要考虑一下他们是做什么的

00:19:15.130 --> 00:19:23.980
要求以及他们出口了什么

00:19:19.420 --> 00:19:25.690
从报表开始

00:19:23.980 --> 00:19:27.280
运行我们所谓的Jade EPS工具

00:19:25.690 --> 00:19:28.780
因此，如果您在较早的演讲中

00:19:27.280 --> 00:19:30.430
会看到我们使用了Jade EPS音调

00:19:28.780 --> 00:19:32.650
实际上对

00:19:30.430 --> 00:19:34.540
亚历克斯现有的图书馆在他的书中看到了

00:19:32.650 --> 00:19:37.120
演示的一部分，以查看

00:19:34.540 --> 00:19:39.160
 Maya Pande我的嘴唇，我们也做同样的事情

00:19:37.120 --> 00:19:42.970
与杰克逊罐子文件在这里

00:19:39.160 --> 00:19:45.940
了解他们的需求，所以我们看到

00:19:42.970 --> 00:19:48.910
杰克逊的注解和罐子

00:19:45.940 --> 00:19:52.060
文件中包含可以利用的代码

00:19:48.910 --> 00:19:55.300
以Java为基础的类型

00:19:52.060 --> 00:19:56.830
感觉java杰克逊核心也有一些

00:19:55.300 --> 00:19:59.650
那里的代码利用了一些

00:19:56.830 --> 00:20:02.080
 Java基本杰克逊数据绑定中的类型是

00:19:59.650 --> 00:20:03.850
更有趣的是，其中有代码

00:20:02.080 --> 00:20:06.070
具有引用的jar文件

00:20:03.850 --> 00:20:07.990
注入和注释的类型

00:20:06.070 --> 00:20:10.480
也有引用类型

00:20:07.990 --> 00:20:13.630
在杰克逊核心受伤，还有一个

00:20:10.480 --> 00:20:15.910
其他两种对两种类型的引用

00:20:13.630 --> 00:20:19.890
在java基础上当然是java 

00:20:15.910 --> 00:20:19.890
续集和Java X XML 

00:20:20.730 --> 00:20:25.890
我应该说的是，当你在

00:20:23.910 --> 00:20:28.230
您正在尝试了解什么

00:20:25.890 --> 00:20:31.049
模块取决于您不需要的

00:20:28.230 --> 00:20:33.059
当然使用J技巧-全部

00:20:31.049 --> 00:20:34.350
如果这是一个Maven项目， 

00:20:33.059 --> 00:20:36.330
你已经有了手掌，那可以

00:20:34.350 --> 00:20:38.059
让您知道它的含义

00:20:36.330 --> 00:20:42.679
上

00:20:38.059 --> 00:20:47.730
所以这是来自

00:20:42.679 --> 00:20:49.380
从J技巧输出中，并保持

00:20:47.730 --> 00:20:53.270
请记住这一点，因为我们会

00:20:49.380 --> 00:20:53.270
在后面的幻灯片中回到我们身边

00:20:53.780 --> 00:21:02.040
而且这次我想再次运行J技巧

00:20:58.200 --> 00:21:04.410
带有新的选项生成模块信息

00:21:02.040 --> 00:21:06.660
基本上是一种开始的方式

00:21:04.410 --> 00:21:10.140
指向您的起始模块信息点

00:21:06.660 --> 00:21:12.990
现在，在Java的早期讨论中，我们有了J 

00:21:10.140 --> 00:21:14.250
 Depp可在JDK 8上使用

00:21:12.990 --> 00:21:16.260
看你的jar文件

00:21:14.250 --> 00:21:16.740
与jdk age和

00:21:16.260 --> 00:21:19.980
年长的

00:21:16.740 --> 00:21:22.260
 jdk 9中j技巧的转移

00:21:19.980 --> 00:21:24.270
还有很多其他选择

00:21:22.260 --> 00:21:25.530
第八种没有的

00:21:24.270 --> 00:21:27.419
版本，这是其中之一

00:21:25.530 --> 00:21:31.559
这是新的命令行选项

00:21:27.419 --> 00:21:31.950
在jdk 9版本中运行j 

00:21:31.559 --> 00:21:34.080
德普的

00:21:31.950 --> 00:21:36.480
与一堆jar文件一起

00:21:34.080 --> 00:21:41.340
模块信息，它将为您生成

00:21:36.480 --> 00:21:42.960
启动Java信息对不起模块信息所以

00:21:41.340 --> 00:21:45.720
我已经在这三个jar文件上运行了

00:21:42.960 --> 00:21:48.000
它给我创造了3个模块信息

00:21:45.720 --> 00:21:52.169
对于每个jar文件，我们来看

00:21:48.000 --> 00:21:53.549
在下一张幻灯片中，对于杰克逊

00:21:52.169 --> 00:21:55.610
可能是最多的数据

00:21:53.549 --> 00:21:58.710
这组jar文件中有趣的一个

00:21:55.610 --> 00:22:01.830
这是J提示的模块信息

00:21:58.710 --> 00:22:04.620
为我创建的工具做了很多

00:22:01.830 --> 00:22:07.020
要求在顶部

00:22:04.620 --> 00:22:10.830
对其中的内容进行静态分析

00:22:07.020 --> 00:22:15.990
 jar文件和J depths不知道哪个

00:22:10.830 --> 00:22:18.390
 jar文件的哪M个部分是

00:22:15.990 --> 00:22:22.919
在导出的API中，哪些是

00:22:18.390 --> 00:22:24.990
内部的，因此它假定每种类型

00:22:22.919 --> 00:22:27.240
是API的一部分，因此每个

00:22:24.990 --> 00:22:28.950
包被导出，因此它生成一个

00:22:27.240 --> 00:22:32.130
小出口总监的错误

00:22:28.950 --> 00:22:35.160
每一个

00:22:32.130 --> 00:22:38.520
如果您看，jar文件中的软件包

00:22:35.160 --> 00:22:40.200
密切关注需求，同时也关注

00:22:38.520 --> 00:22:42.870
这些方法的签名

00:22:40.200 --> 00:22:44.940
这样就可以确定是否

00:22:42.870 --> 00:22:46.710
您是否需要发电机或

00:22:44.940 --> 00:22:48.690
需要传递，因此在前面

00:22:46.710 --> 00:22:51.090
我们谈论的谈话需要改进

00:22:48.690 --> 00:22:52.620
可传递的，所以在这里您看到

00:22:51.090 --> 00:22:56.100
在生成模块中的示例

00:22:52.620 --> 00:22:57.570
讨论的这一部分的信息假定

00:22:56.100 --> 00:22:59.910
我们是这个的维护者

00:22:57.570 --> 00:23:02.190
图书馆，所以我们有更多的知识

00:22:59.910 --> 00:23:06.720
关于这个库，然后比J提示

00:23:02.190 --> 00:23:08.520
这样做并作为维护者的z' 

00:23:06.720 --> 00:23:10.830
这个图书馆，我们要做的一件事

00:23:08.520 --> 00:23:12.960
想做的就是不想做的是我们

00:23:10.830 --> 00:23:15.090
不想导出我们的输入

00:23:12.960 --> 00:23:18.030
包，这就是我们成为奥运选手的地方

00:23:15.090 --> 00:23:22.050
实施不是它的一部分

00:23:18.030 --> 00:23:23.730
 API，对于这个库，我们假设

00:23:22.050 --> 00:23:26.190
我可能会做的是编辑此内容

00:23:23.730 --> 00:23:30.900
此生成模块信息并删除

00:23:26.190 --> 00:23:33.330
出口没有意义，所以J 

00:23:30.900 --> 00:23:35.010
提示会为我生成一个模块信息

00:23:33.330 --> 00:23:37.020
一切都被宣布为

00:23:35.010 --> 00:23:39.570
导出但假定为维持

00:23:37.020 --> 00:23:42.750
我们更了解的错误，这些

00:23:39.570 --> 00:23:44.850
简单的包装没有意义，所以我们

00:23:42.750 --> 00:23:47.250
将删除这些作为创建的一部分

00:23:44.850 --> 00:23:49.800
正确的模块描述符右边距

00:23:47.250 --> 00:23:56.130
此Jackson数据绑定的声明

00:23:49.800 --> 00:23:58.050
模块现在我们做的类似于

00:23:56.130 --> 00:24:01.050
亚历克斯做到了，并将开始对此进行编译

00:23:58.050 --> 00:24:03.060
所以我要做的就是生成

00:24:01.050 --> 00:24:05.850
这些模块信息进入源代码树

00:24:03.060 --> 00:24:10.230
我要去的这三个模块

00:24:05.850 --> 00:24:13.050
与我们一起编译记忆

00:24:10.230 --> 00:24:14.970
模块，我们有一个附加目录

00:24:13.050 --> 00:24:17.850
现在在文件路径中

00:24:14.970 --> 00:24:20.580
模块名称，因此我的所有源代码

00:24:17.850 --> 00:24:22.920
这三个模块是有组织的SRC 

00:24:20.580 --> 00:24:25.080
斜杠模块名称，然后是我的

00:24:22.920 --> 00:24:28.290
传统的阶级阶层和

00:24:25.080 --> 00:24:29.790
在那棵树上按包裹组织

00:24:28.290 --> 00:24:33.240
模块信息在顶层

00:24:29.790 --> 00:24:35.820
每个模块的目录，因此

00:24:33.240 --> 00:24:38.220
对于杰克逊核心的位置

00:24:35.820 --> 00:24:41.190
模块信息是名为SRC的斜杠模块

00:24:38.220 --> 00:24:43.950
 Jackson核心斜线模块信息Java 

00:24:41.190 --> 00:24:44.980
其他三个相同

00:24:43.950 --> 00:24:47.440
模组

00:24:44.980 --> 00:24:48.970
我现在要编译所有这些

00:24:47.440 --> 00:24:51.040
三个模块在一起，所以我

00:24:48.970 --> 00:24:53.530
在这种情况下重新编译所有Jackson 

00:24:51.040 --> 00:24:55.570
他们三个都在做

00:24:53.530 --> 00:24:58.600
模块编译是什么，一个Java C 

00:24:55.570 --> 00:25:01.929
我正在编译的命令和所有三个

00:24:58.600 --> 00:25:03.520
模块在一起，我给它一个

00:25:01.929 --> 00:25:04.720
 mods的输出目录

00:25:03.520 --> 00:25:06.940
所有的类文件都将是

00:25:04.720 --> 00:25:09.190
生成的和它的输入，我只是

00:25:06.940 --> 00:25:14.620
给它一个很好的命令在哪里找到

00:25:09.190 --> 00:25:16.960
所有的Java源代码，这样

00:25:14.620 --> 00:25:18.700
将会编译，我现在有一个马自达

00:25:16.960 --> 00:25:21.250
带有三个目录的目录

00:25:18.700 --> 00:25:24.850
我要运行的所有类文件

00:25:21.250 --> 00:25:27.100
 jar命令3次，因为

00:25:24.850 --> 00:25:29.710
我将为每个创建一个jar文件

00:25:27.100 --> 00:25:31.600
我的模块之一是

00:25:29.710 --> 00:25:33.929
这些是模块化的罐子

00:25:31.600 --> 00:25:37.900
你在这里看到的是不是

00:25:33.929 --> 00:25:41.380
他在jdk 9 so和jar中的新选项

00:25:37.900 --> 00:25:43.630
该工具历史悠久， 

00:25:41.380 --> 00:25:46.150
晦涩难懂的Java 

00:25:43.630 --> 00:25:48.910
选项和有点像zip工具

00:25:46.150 --> 00:25:51.669
其中一些是现代化的

00:25:48.910 --> 00:25:54.190
 JDK 9特别是使用独木舟

00:25:51.669 --> 00:25:55.660
样式格式至少与您接近

00:25:54.190 --> 00:25:57.010
看到了，也许在介绍中

00:25:55.660 --> 00:26:00.700
之前和其他人谈过

00:25:57.010 --> 00:26:03.429
工具，因此jar工具具有--选项，因此

00:26:00.700 --> 00:26:05.559
 --创建--文件，因此我正在创建

00:26:03.429 --> 00:26:07.360
我要告诉的jar文件是什么

00:26:05.559 --> 00:26:09.130
创建这是一个模块化的罐子

00:26:07.360 --> 00:26:11.559
在信封目录中创建

00:26:09.130 --> 00:26:15.970
我将其命名为Jackson核心和一个版本

00:26:11.559 --> 00:26:18.370
数字，并告诉它的污垢

00:26:15.970 --> 00:26:19.540
我要去的课程文件的位置

00:26:18.370 --> 00:26:21.190
打包进去，我要创建三个

00:26:19.540 --> 00:26:23.049
模块化的罐子，所以真的

00:26:21.190 --> 00:26:24.429
就像Alex对我的应用所做的一样， 

00:26:23.049 --> 00:26:28.990
我的盖子在第一部分

00:26:24.429 --> 00:26:29.910
现在的演示文稿，这就是我们所拥有的

00:26:28.990 --> 00:26:34.929
现在

00:26:29.910 --> 00:26:37.150
所以我们重新编译了Jackson的核心Jackson 

00:26:34.929 --> 00:26:40.000
批注和JAXA数据绑定

00:26:37.150 --> 00:26:42.580
包装成模块化的罐子，这是

00:26:40.000 --> 00:26:44.919
我们有一些模块图

00:26:42.580 --> 00:26:48.160
底部的平台模块，然后

00:26:44.919 --> 00:26:50.230
我们的三个Jackson模块是明确的

00:26:48.160 --> 00:26:52.360
模块的依赖关系很明确

00:26:50.230 --> 00:26:55.049
他们很清楚这是一个很好的出口

00:26:52.360 --> 00:26:55.049
模块图

00:26:57.300 --> 00:27:02.500
只是我们如何在这些上运行这些的回顾

00:27:00.820 --> 00:27:05.890
类路径就在

00:27:02.500 --> 00:27:08.260
我们现在要更改的演示文稿

00:27:05.890 --> 00:27:12.190
该命令，以便我们与

00:27:08.260 --> 00:27:14.230
这三个库作为模块

00:27:12.190 --> 00:27:19.270
所以这是旧命令，现在我们有了

00:27:14.230 --> 00:27:20.770
新命令，如果有的话

00:27:19.270 --> 00:27:22.870
参加介绍的人之前谈到

00:27:20.770 --> 00:27:26.620
在上面我谈到了如何混合模块

00:27:22.870 --> 00:27:29.230
路径和类路径一起是

00:27:26.620 --> 00:27:31.630
正是您必须要做的一个场景

00:27:29.230 --> 00:27:34.540
这是因为我的应用程序和我的lib已打开

00:27:31.630 --> 00:27:37.780
类路径r3 Jackson库是

00:27:34.540 --> 00:27:40.630
现在模块在模块路径上，所以这

00:27:37.780 --> 00:27:44.680
既是模块路径又是类路径

00:27:40.630 --> 00:27:46.720
在这里指定给Java命令my 

00:27:44.680 --> 00:27:49.420
 MU库中有三个Jackson模块

00:27:46.720 --> 00:27:52.210
目录，然后指定EM Lib 

00:27:49.420 --> 00:27:54.520
目录到模块路径选项my 

00:27:52.210 --> 00:27:57.310
上课的路已经有了Maya和我的Lib 

00:27:54.520 --> 00:28:02.440
所以我要指定这些-CP 

00:27:57.310 --> 00:28:05.200
或-类路径，但与

00:28:02.440 --> 00:28:08.830
之前介绍过的介绍没什么

00:28:05.200 --> 00:28:11.680
在Maya或我的lib中说

00:28:08.830 --> 00:28:13.620
他们依赖杰克逊数据绑定

00:28:11.680 --> 00:28:16.360
没有依赖项信息

00:28:13.620 --> 00:28:18.310
在课程路径上可用，所以我

00:28:16.360 --> 00:28:20.920
不得不帮助错误的时间

00:28:18.310 --> 00:28:24.030
添加模块，我们可以选择告诉它

00:28:20.920 --> 00:28:26.290
解决Jackson数据购买模块

00:28:24.030 --> 00:28:28.150
这是当

00:28:26.290 --> 00:28:29.980
您正在尝试混合类路径

00:28:28.150 --> 00:28:32.200
和模块路径在一起

00:28:29.980 --> 00:28:35.050
上课路上没有什么可以告诉你的

00:28:32.200 --> 00:28:36.670
它里面有什么依赖性

00:28:35.050 --> 00:28:40.210
我正在通过添加帮助运行时

00:28:36.670 --> 00:28:43.900
模块选项告诉我我都是V 

00:28:40.210 --> 00:28:45.370
杰克逊数据绑定，所以这是一个

00:28:43.900 --> 00:28:50.140
我最终得到的命令行

00:28:45.370 --> 00:28:53.170
与模块路径和我的模块

00:28:50.140 --> 00:28:56.470
上课路径问题的应用

00:28:53.170 --> 00:28:58.900
在最后，所以现在我们要

00:28:56.470 --> 00:28:59.980
放在一起，所以我有模块

00:28:58.900 --> 00:29:02.710
在底部，我将采取

00:28:59.980 --> 00:29:04.450
 Alex在第一个生成的模块

00:29:02.710 --> 00:29:07.510
谈话的一部分，我要去

00:29:04.450 --> 00:29:08.290
结合一切，这就是

00:29:07.510 --> 00:29:10.930
我们有第二个

00:29:08.290 --> 00:29:13.180
 TAF现在我们有了Alex的模块

00:29:10.930 --> 00:29:15.370
应用程序和我的嘴唇，我们有这个好

00:29:13.180 --> 00:29:18.190
模块图一切都是绿色的

00:29:15.370 --> 00:29:19.690
一切都是模块，这非常非常

00:29:18.190 --> 00:29:27.670
清除其中的依赖项

00:29:19.690 --> 00:29:31.290
图，现在让我们开始运行它

00:29:27.670 --> 00:29:34.150
我们把一切都作为模块

00:29:31.290 --> 00:29:36.340
只是回顾一下一切都是模块，所以

00:29:34.150 --> 00:29:39.970
如果我在我的M Lib目录中查找

00:29:36.340 --> 00:29:46.330
我的应用程序，我的Lib和我的五个模块化罐子

00:29:39.970 --> 00:29:48.700
三个杰克逊和我的命令模块

00:29:46.330 --> 00:29:51.790
运行它缩小了，因为我只是

00:29:48.700 --> 00:29:54.730
告诉它模块路径和

00:29:51.790 --> 00:29:57.820
初始模块，然后初始模块

00:29:54.730 --> 00:30:02.110
我们的主要模块是我的应用程序，所以我要去

00:29:57.820 --> 00:30:03.850
要求它运行来运行我的应用

00:30:02.110 --> 00:30:05.830
将解决我的应用程序依赖什么

00:30:03.850 --> 00:30:07.750
生活取决于我的实验室

00:30:05.830 --> 00:30:09.460
杰克逊数据字节我们将生成

00:30:07.750 --> 00:30:12.370
所有这些模块的传递闭包

00:30:09.460 --> 00:30:18.460
将被加载以便运行，我的

00:30:12.370 --> 00:30:22.530
应用程序，我们可以走得更远，所以如果我们结合起来

00:30:18.460 --> 00:30:25.780
在介绍性谈话中，我们做了一些简单的

00:30:22.530 --> 00:30:29.170
选项是使用J的一些简单示例

00:30:25.780 --> 00:30:33.040
链接以创建运行时映像，现在我们

00:30:29.170 --> 00:30:35.170
有我们的应用程序和杰克逊

00:30:33.040 --> 00:30:39.040
库实际上是我们可以做的模块

00:30:35.170 --> 00:30:40.270
同样的事情是

00:30:39.040 --> 00:30:43.060
高级谈话，所以我有几个

00:30:40.270 --> 00:30:44.950
 J链接选项上的高级选项，因此

00:30:43.060 --> 00:30:48.760
我在这里产生的是运行时

00:30:44.950 --> 00:30:51.550
将会包含我的应用和所有

00:30:48.760 --> 00:30:53.680
在运行时中的传递依赖

00:30:51.550 --> 00:30:55.900
图片，所以这就是

00:30:53.680 --> 00:30:58.840
可以与坐骑一起分发

00:30:55.900 --> 00:31:01.510
它需要的模块，所以选项是

00:30:58.840 --> 00:31:03.610
给两个J链接，就像Java C 

00:31:01.510 --> 00:31:05.290
就像Java启动器一样

00:31:03.610 --> 00:31:08.170
关于在哪里找到的模块路径

00:31:05.290 --> 00:31:11.380
我正在使用添加的模块

00:31:08.170 --> 00:31:15.700
模块选项告诉J链接

00:31:11.380 --> 00:31:16.990
我在运行时映像J中想要的模块

00:31:15.700 --> 00:31:19.420
链接将生成可传递的

00:31:16.990 --> 00:31:20.660
关闭所有这些模块并将其链接到

00:31:19.420 --> 00:31:24.170
创建运行时映像

00:31:20.660 --> 00:31:27.410
我想要一个相对较小的图像，所以我

00:31:24.170 --> 00:31:29.960
提供一些压缩选项

00:31:27.410 --> 00:31:32.060
做一些剥离像

00:31:29.960 --> 00:31:35.570
链接器要复杂得多

00:31:32.060 --> 00:31:37.430
我可以给它做其他事情的选择

00:31:35.570 --> 00:31:39.110
自定义运行时映像，但是

00:31:37.430 --> 00:31:41.870
我现在只是坚持大小

00:31:39.110 --> 00:31:43.970
我最终得到的是运行时间

00:31:41.870 --> 00:31:46.340
在这种情况下是帽子的图像

00:31:43.970 --> 00:31:47.710
是2.66万，所以

00:31:46.340 --> 00:31:50.840
大约25个半兆字节

00:31:47.710 --> 00:31:54.230
如果我在bin目录中看到

00:31:50.840 --> 00:31:56.810
那里只有一小部分工具， 

00:31:54.230 --> 00:31:58.850
 Java启动器我已将CCC用于

00:31:56.810 --> 00:32:01.940
我的应用已由

00:31:58.850 --> 00:32:04.520
链接器，如果我运行列表mod列表

00:32:01.940 --> 00:32:07.190
是列表模块选项

00:32:04.520 --> 00:32:09.140
生成的运行时，那么我们看到它

00:32:07.190 --> 00:32:11.360
有这是模块的列表

00:32:09.140 --> 00:32:13.940
在该运行时映像中，我的应用程序和我的

00:32:11.360 --> 00:32:16.340
打开Jackson图书馆，然后进入

00:32:13.940 --> 00:32:20.270
这个案例有四个平台模块

00:32:16.340 --> 00:32:21.890
被M链接的，所以这是

00:32:20.270 --> 00:32:24.320
非常好，要么我最终得到了

00:32:21.890 --> 00:32:29.600
适用于我的应用程序的运行时间短

00:32:24.320 --> 00:32:31.220
我可以用它来运行它

00:32:29.600 --> 00:32:33.260
未指定模块包，因为它们是

00:32:31.220 --> 00:32:35.990
我都可以链接到运行时映像中

00:32:33.260 --> 00:32:39.230
只是做Java-我的应用和我的

00:32:35.990 --> 00:32:41.330
应用程序将在

00:32:39.230 --> 00:32:43.670
此外，链接器将生成一个

00:32:41.330 --> 00:32:45.530
我的小启动脚本

00:32:43.670 --> 00:32:48.560
基于模块的应用程序

00:32:45.530 --> 00:32:51.620
名字，所以我可以做命令行

00:32:48.560 --> 00:32:54.980
如果我愿意，甚至更短，那是一个

00:32:51.620 --> 00:32:57.650
快速浏览事物

00:32:54.980 --> 00:33:00.380
自下而上，然后组合模块

00:32:57.650 --> 00:33:01.760
是由上而下产生的

00:33:00.380 --> 00:33:03.170
一切都是模块，然后我们

00:33:01.760 --> 00:33:07.220
走得更远，实际上创建一个自定义

00:33:03.170 --> 00:33:09.770
运行时映像，所以我们要做的主要事情

00:33:07.220 --> 00:33:12.020
在这次演讲中获得成功的是我

00:33:09.770 --> 00:33:14.780
希望我们实际展示的是

00:33:12.020 --> 00:33:18.560
您可以自由采用

00:33:14.780 --> 00:33:20.630
以自己的步调迁移到模块alex 

00:33:18.560 --> 00:33:24.020
已经展示了如何迁移以及

00:33:20.630 --> 00:33:27.290
在申请之前将申请边缘化

00:33:24.020 --> 00:33:29.780
图书馆已经迁移了

00:33:27.290 --> 00:33:31.880
正如我们在下半年看到的那样

00:33:29.780 --> 00:33:34.600
边缘化的演示

00:33:31.880 --> 00:33:37.430
图书馆完全独立

00:33:34.600 --> 00:33:40.550
此外，您还对

00:33:37.430 --> 00:33:44.330
因此，不同种类的模块

00:33:40.550 --> 00:33:46.820
从我的显式模块开始

00:33:44.330 --> 00:33:49.460
和我的lib，然后利用

00:33:46.820 --> 00:33:51.110
杰克逊图书馆作为自动模块

00:33:49.460 --> 00:33:53.840
给你一种明显的感觉

00:33:51.110 --> 00:33:56.930
与自动模块以及

00:33:53.840 --> 00:33:58.700
向您展示了当前的建议

00:33:56.930 --> 00:34:01.220
哪个表是弱模块以及如何

00:33:58.700 --> 00:34:03.320
他们也可以实际使用

00:34:01.220 --> 00:34:05.990
特别适用于

00:34:03.320 --> 00:34:07.310
不要在api中导出任何内容

00:34:05.990 --> 00:34:10.880
希望那能给你一种味道

00:34:07.310 --> 00:34:14.300
什么只是支持和

00:34:10.880 --> 00:34:17.750
迁移到模块，所以我们只是

00:34:14.300 --> 00:34:22.580
以一条不错的接球线结束并走

00:34:17.750 --> 00:34:25.040
并经过调制，所以我们有几个

00:34:22.580 --> 00:34:27.020
其他会议，我们大部分时间都在

00:34:25.040 --> 00:34:29.030
这个房间，所以我们这样做是我们的

00:34:27.020 --> 00:34:32.750
今天第三，我们开始

00:34:29.030 --> 00:34:33.980
明天2:30重复此步骤，但是

00:34:32.750 --> 00:34:36.290
尚未完成的重要对话

00:34:33.980 --> 00:34:38.480
尚未提供模块和服务

00:34:36.290 --> 00:34:40.400
明天11:00，然后亚历克斯要去

00:34:38.480 --> 00:34:43.820
做项目在引擎盖下的小鸡锯

00:34:40.400 --> 00:34:47.030
明天下午4:00，还有一个

00:34:43.820 --> 00:34:48.770
 hack session，我认为这带来了

00:34:47.030 --> 00:34:50.600
带着问题带上笔记本电脑

00:34:48.770 --> 00:34:54.980
如果你想尝试一下

00:34:50.600 --> 00:34:57.140
星期三8:30这里的其中一个房间

00:34:54.980 --> 00:35:01.640
我不确定是哪个

00:34:57.140 --> 00:35:03.650
这就是两个，更多信息

00:35:01.640 --> 00:35:05.150
所以这是项目的链接

00:35:03.650 --> 00:35:08.570
我们正在研究的拼图页面

00:35:05.150 --> 00:35:09.920
实施项目拼图

00:35:08.570 --> 00:35:11.710
也是他们那里邮件的链接

00:35:09.920 --> 00:35:15.560
清单以及提早使用帐单的位置

00:35:11.710 --> 00:35:18.260
就像我在

00:35:15.560 --> 00:35:20.780
 JDK 9仍然是早期的讨论

00:35:18.260 --> 00:35:22.130
在开发中，它不发货， 

00:35:20.780 --> 00:35:24.020
不会等到下一个

00:35:22.130 --> 00:35:25.280
一年中有很多事情

00:35:24.020 --> 00:35:28.220
实际上在这里显示的东西

00:35:25.280 --> 00:35:29.870
只是最后还没有，什么都没有

00:35:28.220 --> 00:35:31.430
最后，但他们仍然只是我们的

00:35:29.870 --> 00:35:33.650
还在讨论他们还很早

00:35:31.430 --> 00:35:37.520
访问一切仍在

00:35:33.650 --> 00:35:40.870
进步，所以我们在这里显示的可能是

00:35:37.520 --> 00:35:44.240
最终的JDK 9并非完全一样

00:35:40.870 --> 00:35:46.430
所以我想我们大约有十个

00:35:44.240 --> 00:35:49.280
分钟，如果没有问题

00:35:46.430 --> 00:35:53.240
如果有人有，我们走15分钟

00:35:49.280 --> 00:35:56.720
问题，所以协议将

00:35:53.240 --> 00:35:59.030
如果你能做到的

00:35:56.720 --> 00:36:01.579
然后打电话给麦克风

00:35:59.030 --> 00:36:06.890
人们会听到否则我们会

00:36:01.579 --> 00:36:19.520
必须重复这些问题，所以马克

00:36:06.890 --> 00:36:20.990
也可以提出问题

00:36:19.520 --> 00:36:23.260
真的听不到什么时候不会

00:36:20.990 --> 00:36:23.260
是的

00:36:31.099 --> 00:36:38.059
在第一个与自动

00:36:33.770 --> 00:36:41.000
模块Jackson自动依赖

00:36:38.059 --> 00:36:42.650
我的允许它执行的应用

00:36:41.000 --> 00:36:53.480
在第二个反思如何

00:36:42.650 --> 00:36:54.980
杰克逊依靠或参考这是一个很好的

00:36:53.480 --> 00:36:56.809
问题，所以问题是我当时

00:36:54.980 --> 00:36:59.480
想知道是否有人会发现这个

00:36:56.809 --> 00:37:01.490
 Jax和数据绑定的第一部分

00:36:59.480 --> 00:37:04.369
是一个自动模块列表

00:37:01.490 --> 00:37:07.369
实际上隐式要求Maya和

00:37:04.369 --> 00:37:11.589
我的lib，因为它需要一切

00:37:07.369 --> 00:37:11.589
但是当艾伦模块化时

00:37:13.549 --> 00:37:20.369
箭头全都向下了

00:37:17.609 --> 00:37:23.519
所以事情就是这样，数据绑定正在使用

00:37:20.369 --> 00:37:27.839
访问类的核心思考

00:37:23.519 --> 00:37:31.410
从我的应用程序导出的类

00:37:27.839 --> 00:37:32.940
将类对象传递给数据绑定

00:37:31.410 --> 00:37:36.960
在八岁那年

00:37:32.940 --> 00:37:40.140
数据绑定API，这意味着代码

00:37:36.960 --> 00:37:42.299
数据绑定几乎可以访问所有对象

00:37:40.140 --> 00:37:45.299
从X导出该类的类

00:37:42.299 --> 00:37:47.940
我的应用程序数据绑定可以反映出来

00:37:45.299 --> 00:37:51.109
不需要它实际上得到了

00:37:47.940 --> 00:37:53.880
免费箭头返回到我的应用程序

00:37:51.109 --> 00:37:55.410
即使数据绑定是

00:37:53.880 --> 00:37:58.319
显式模块与模块

00:37:55.410 --> 00:38:00.420
声明，但显然它不知道

00:37:58.319 --> 00:38:02.069
什么模块将是什么类

00:38:00.420 --> 00:38:03.749
它将反映哪些模块

00:38:02.069 --> 00:38:06.989
所以不可能说需要他们

00:38:03.749 --> 00:38:10.019
只要它反映在他们身上

00:38:06.989 --> 00:38:12.479
该类被导出到

00:38:10.019 --> 00:38:13.799
反射就可以了，如果你

00:38:12.479 --> 00:38:16.799
密切关注是一个改变

00:38:13.799 --> 00:38:19.430
从去年开始，但假装我没有说

00:38:16.799 --> 00:38:19.430
它只是有效

00:38:24.019 --> 00:38:28.979
林肯显然意味着他说

00:38:27.029 --> 00:38:30.839
升级其中一个罐子

00:38:28.979 --> 00:38:33.420
我需要从头开始吗

00:38:30.839 --> 00:38:35.430
椅子或用于该模块的重建

00:38:33.420 --> 00:38:40.019
图片主要的版本

00:38:35.430 --> 00:38:41.519
一群人对，所以我认为

00:38:40.019 --> 00:38:45.900
您要问的是您需要重新运行

00:38:41.519 --> 00:38:46.799
 j-link命令的后期

00:38:45.900 --> 00:38:49.440
是啊

00:38:46.799 --> 00:38:50.729
和J链接实际上将记录所有

00:38:49.440 --> 00:38:52.319
实际使用的选项

00:38:50.729 --> 00:38:55.849
可以很容易地重新运行呃，如果有的话

00:38:52.319 --> 00:38:55.849
模块的新版本

00:38:57.410 --> 00:39:01.640
我想知道你能不能快点走

00:38:59.750 --> 00:39:07.760
再次需要什么传递

00:39:01.640 --> 00:39:09.440
暴露关于没有说好，所以这是

00:39:07.760 --> 00:39:10.670
所以问题是什么

00:39:09.440 --> 00:39:12.560
不同之处在于需要传递

00:39:10.670 --> 00:39:14.000
与要求Java记录完整

00:39:12.560 --> 00:39:15.680
答案是在幕后的拼图中，但是

00:39:14.000 --> 00:39:17.450
这不是一个复杂的功能

00:39:15.680 --> 00:39:20.510
不是高级功能，如此公平的问题

00:39:17.450 --> 00:39:23.930
所以您会看到Jackson数据绑定要求

00:39:20.510 --> 00:39:26.390
 java记录它是一个表情符号是一个

00:39:23.930 --> 00:39:28.370
数据绑定的实现细节

00:39:26.390 --> 00:39:30.770
只是调用Logging的方法

00:39:28.370 --> 00:39:35.150
它不会以任何方式公开数据

00:39:30.770 --> 00:39:38.600
绑定现在需要传递Java XML 

00:39:35.150 --> 00:39:40.610
没看过数据绑定Java doc 

00:39:38.600 --> 00:39:43.940
详细，但需要什么

00:39:40.610 --> 00:39:45.890
传递Java xml告诉我的是

00:39:43.940 --> 00:39:48.440
数据绑定的方式取决于java xml 

00:39:45.890 --> 00:39:51.650
不只是为了实现目的

00:39:48.440 --> 00:39:55.010
这是因为杰克逊数据的api 

00:39:51.650 --> 00:39:57.860
绑定所有这些出口中的某处

00:39:55.010 --> 00:40:08.660
在公共签名中来自Java的类型

00:39:57.860 --> 00:40:10.010
 xml是的，我怎么写，所以如果你写

00:40:08.660 --> 00:40:11.870
需要检查和数据的模块

00:40:10.010 --> 00:40:13.850
绑定数据绑定说我

00:40:11.870 --> 00:40:16.400
依赖于XML的可传递性意味着您的

00:40:13.850 --> 00:40:17.980
您可以说需要Java XML的模块

00:40:16.400 --> 00:40:21.290
如果你不这样做，那是没有错的

00:40:17.980 --> 00:40:23.830
就像您说过的要求

00:40:21.290 --> 00:40:29.270
 java xml你从java xml得到什么

00:40:23.830 --> 00:40:31.040
无论出口什么，它都是如何

00:40:29.270 --> 00:40:34.310
您将获得模块级别的模块化

00:40:31.040 --> 00:40:37.970
粒度依赖性

00:40:34.310 --> 00:40:39.650
允许通过以下方式进行重构

00:40:37.970 --> 00:40:41.630
与此有关的几张幻灯片

00:40:39.650 --> 00:40:43.310
之前介绍过的介绍，您可能有

00:40:41.630 --> 00:40:45.340
错过了，但是你想抓住

00:40:43.310 --> 00:40:45.340
上

00:40:46.860 --> 00:40:52.260
两个问题，一个一保存，三个

00:40:50.280 --> 00:40:54.210
第三方库，它们都是

00:40:52.260 --> 00:40:56.330
内置略有不同的版本

00:40:54.210 --> 00:40:59.610
杰克逊

00:40:56.330 --> 00:41:01.260
 3/3好的，也许如此，如此不同

00:40:59.610 --> 00:41:02.730
您的应用程序的某些部分甚至可以

00:41:01.260 --> 00:41:05.130
使用不同版本的杰克逊

00:41:02.730 --> 00:41:13.050
他们是兼容的，他们只是略

00:41:05.130 --> 00:41:17.460
不同的错误修复程序可以做到这一点

00:41:13.050 --> 00:41:18.390
意味着其他一切仍然会让我

00:41:17.460 --> 00:41:21.000
问第一个让我问另一个

00:41:18.390 --> 00:41:22.380
质疑您的应用程序

00:41:21.000 --> 00:41:25.820
不一定是您的代码

00:41:22.380 --> 00:41:28.740
传递使用不同版本的

00:41:25.820 --> 00:41:33.270
杰克逊是的，你怎么放那些罐子

00:41:28.740 --> 00:41:35.760
在课堂上享受数十年，但如果

00:41:33.270 --> 00:41:37.740
您指定一些版本之一

00:41:35.760 --> 00:41:45.020
第三方jar，稍后

00:41:37.740 --> 00:41:45.020
然后我们完成了classpath版本2 

00:41:45.740 --> 00:41:52.800
如果你只是这样，那么你不在

00:41:50.820 --> 00:41:54.810
不管你以前穿什么

00:41:52.800 --> 00:41:56.280
你现在是完全相同的classpath 

00:41:54.810 --> 00:41:58.760
您选择放入的罐子

00:41:56.280 --> 00:42:01.980
 classpath只是将其放在模块路径上

00:41:58.760 --> 00:42:03.060
是的，然后神奇的是我的意思是真的

00:42:01.980 --> 00:42:05.730
魔术变成自动

00:42:03.060 --> 00:42:10.020
具有名称的模块，然后删除

00:42:05.730 --> 00:42:12.840
根据一些版本限定符

00:42:10.020 --> 00:42:14.550
启发式在Javadoc中是这样的

00:42:12.840 --> 00:42:23.280
这些是真实的模块名称吗

00:42:14.550 --> 00:42:26.160
可以从真正的罐子中得到

00:42:23.280 --> 00:42:30.020
梅文先生她主要是你在后面

00:42:26.160 --> 00:42:30.020
你，并有一个完整的谈论

00:42:33.020 --> 00:42:42.030
升级现有库后

00:42:37.790 --> 00:42:44.220
系统仍然可以编译

00:42:42.030 --> 00:42:49.020
它使用类路径而不是

00:42:44.220 --> 00:42:50.190
新模块，如果您愿意，让我们带来

00:42:49.020 --> 00:42:53.880
申请人让我们提出来

00:42:50.190 --> 00:42:54.860
将Java C带入假期吧

00:42:53.880 --> 00:42:59.490
我们来了

00:42:54.860 --> 00:43:01.380
为jdk 9重新编译该库

00:42:59.490 --> 00:43:04.140
所以这就是这个的来源

00:43:01.380 --> 00:43:07.860
是我要编译的库资源

00:43:04.140 --> 00:43:09.660
它将其放入mods目录中

00:43:07.860 --> 00:43:12.600
由此产生的类文件将

00:43:09.660 --> 00:43:14.270
是版本53的类文件Java SE 9 

00:43:12.600 --> 00:43:24.300
类文件显然不会运行

00:43:14.270 --> 00:43:29.910
早于gdk9您可以做什么

00:43:24.300 --> 00:43:33.560
所以你可以做的是

00:43:29.910 --> 00:43:38.040
使用-release一次编译源代码

00:43:33.560 --> 00:43:40.500
例如七个，然后再次编译

00:43:38.040 --> 00:43:43.500
只是未来Java文件文件中的模块

00:43:40.500 --> 00:43:45.810
在这种情况下，请不要指定-释放

00:43:43.500 --> 00:43:47.040
默认值为9，这样

00:43:45.810 --> 00:43:49.950
将为您提供类文件，其中模块

00:43:47.040 --> 00:43:53.100
在课堂上是版本53，必须

00:43:49.950 --> 00:43:56.510
是来自的其余课程

00:43:53.100 --> 00:44:00.300
这三个源树将是51 

00:43:56.510 --> 00:44:17.580
通过jar运行它们生成的文件

00:44:00.300 --> 00:44:20.460
如果您正在跑步，它将在ya上运行

00:44:17.580 --> 00:44:23.580
码头q9班级路径将

00:44:20.460 --> 00:44:25.260
还是拿模块化的罐子

00:44:23.580 --> 00:44:30.060
将在页脚类中读取模块

00:44:25.260 --> 00:44:34.430
文件与所有

00:44:30.060 --> 00:44:38.460
依赖于N阶乘

00:44:34.430 --> 00:44:40.200
依赖关系只是为了澄清亚历克斯

00:44:38.460 --> 00:44:41.550
这是你可以拿一个更大的罐子

00:44:40.200 --> 00:44:43.140
可以将其放在课程路径上

00:44:41.550 --> 00:44:45.380
只是作为类路径中的库

00:44:43.140 --> 00:44:48.240
一如既往，是的，我

00:44:45.380 --> 00:44:50.280
会以最好的方式

00:44:48.240 --> 00:44:51.210
问题，为什么要这样做

00:44:50.280 --> 00:44:54.690
如果已经在果冻上跑了

00:44:51.210 --> 00:44:56.869
狗，你已经做了一个模块

00:44:54.690 --> 00:44:59.269
 Java或您的书面模块

00:44:56.869 --> 00:45:02.450
找到了一个为什么要放的原因

00:44:59.269 --> 00:45:05.210
它在JDK上的classpath上

00:45:02.450 --> 00:45:07.279
在JDK 9上清楚地安装

00:45:05.210 --> 00:45:22.460
安装我试图找出什么

00:45:07.279 --> 00:45:25.279
你虽然想及时做

00:45:22.460 --> 00:45:29.049
认为您会期望工具会

00:45:25.279 --> 00:45:29.049
最终获得了对模块的支持

00:45:34.430 --> 00:45:41.450
从他的后续行动开始

00:45:38.509 --> 00:45:44.900
看来，如果您将模块放在

00:45:41.450 --> 00:45:47.329
普通班，但在JDK 9中

00:45:44.900 --> 00:45:50.900
实际上打破了保护

00:45:47.329 --> 00:45:52.430
访问保护是的，是的，所以

00:45:50.900 --> 00:45:54.859
访问保护实际上不是

00:45:52.430 --> 00:45:57.319
紧，否则可能会出现

00:45:54.859 --> 00:45:59.059
课堂上没有这样的东西

00:45:57.319 --> 00:46:02.390
他们在课程路径上的模块化jar 

00:45:59.059 --> 00:46:04.279
只是罐子，因为它们不是

00:46:02.390 --> 00:46:06.109
模块化罐子，我们忽略了模块化

00:46:04.279 --> 00:46:08.779
富裕阶层我们忽略了出口

00:46:06.109 --> 00:46:13.069
因此，发布商无法

00:46:08.779 --> 00:46:15.289
开始保护它

00:46:13.069 --> 00:46:18.019
只保护真正的运行时

00:46:15.289 --> 00:46:19.609
按照您的配置，但发布者

00:46:18.019 --> 00:46:19.940
他们真的不能保护那是

00:46:19.609 --> 00:46:21.980
正确

00:46:19.940 --> 00:46:25.489
不，那是真的，如果你在

00:46:21.980 --> 00:46:28.670
控制磁盘上的布局

00:46:25.489 --> 00:46:30.589
您所在的jar文件的置换

00:46:28.670 --> 00:46:32.480
控制一切，即使

00:46:30.589 --> 00:46:35.390
模块化的jar文件放在模块上

00:46:32.480 --> 00:46:37.369
路径（如果您正在控制命令） 

00:46:35.390 --> 00:46:41.029
离开或控制环境

00:46:37.369 --> 00:46:43.609
只能说--在出口并决定

00:46:41.029 --> 00:46:46.910
您希望作为系统

00:46:43.609 --> 00:46:54.680
配置程序否决了

00:46:46.910 --> 00:47:00.410
模块化的罐子好吧，你可以做一个新的

00:46:54.680 --> 00:47:05.890
如果我愿意，第一个示例是传统的Charles 

00:47:00.410 --> 00:47:05.890
保护我的应用程序不被弱者

00:47:06.340 --> 00:47:12.790
我实际上可以进行合格的出口

00:47:08.680 --> 00:47:13.960
对杰克逊是的，所以你知道

00:47:12.790 --> 00:47:15.100
你不说周默认是

00:47:13.960 --> 00:47:17.110
模块很坚固

00:47:15.100 --> 00:47:19.330
然后，您必须枚举您的出口

00:47:17.110 --> 00:47:22.420
你可以选择让他们

00:47:19.330 --> 00:47:23.890
出口合格不仅限于

00:47:22.420 --> 00:47:28.630
杰克逊但对杰克逊的数据绑定

00:47:23.890 --> 00:47:31.060
是的，特别是

00:47:28.630 --> 00:47:33.130
反思和定期访问这些

00:47:31.060 --> 00:47:35.140
信号还好，他们也是

00:47:33.130 --> 00:47:36.730
以不出口的产品为主

00:47:35.140 --> 00:47:50.920
这张幻灯片，因为他们是他们

00:47:36.730 --> 00:47:54.300
隐式但那些提供者

00:47:50.920 --> 00:47:56.650
我们希望的模块或工作

00:47:54.300 --> 00:48:00.280
像Jackson一样的框架开发人员

00:47:56.650 --> 00:48:06.090
开发人员将编写模块信息点

00:48:00.280 --> 00:48:08.950
 Java文件及其代码和产生

00:48:06.090 --> 00:48:11.170
他们仍然是模块化的jar文件

00:48:08.950 --> 00:48:14.040
文件，但它们具有此模块信息点

00:48:11.170 --> 00:48:17.650
它们中的类文件，以便在jdk九

00:48:14.040 --> 00:48:27.550
运行时知道做强

00:48:17.650 --> 00:48:33.550
封装和公众不

00:48:27.550 --> 00:48:36.640
意味着他们将公开，所以公开

00:48:33.550 --> 00:48:40.000
没错，所以如果你看看

00:48:36.640 --> 00:48:43.060
交叉的轮廓使XML更加冷静

00:48:40.000 --> 00:48:45.040
杰克逊数据绑定DISA拉

00:48:43.060 --> 00:48:49.720
我很确定包有公共类型

00:48:45.040 --> 00:48:54.570
在这些公共类型中，只有

00:48:49.720 --> 00:48:54.570
在数据绑定模块中可访问

00:48:59.369 --> 00:49:08.009
应该暴露出来，但是什么时候

00:49:04.920 --> 00:49:10.140
当另一个提供商

00:49:08.009 --> 00:49:12.509
主要使用这项工作，但他们定义

00:49:10.140 --> 00:49:14.999
他们自己的模块，然后他们公开

00:49:12.509 --> 00:49:17.190
一个，当你使用它，即使他们是你

00:49:14.999 --> 00:49:20.069
相同的版本，但您不知道

00:49:17.190 --> 00:49:22.589
到底是什么，我很抱歉

00:49:20.069 --> 00:49:25.529
从某些方面来说，它总是如此令人惊奇

00:49:22.589 --> 00:49:32.309
当您查看工件时很简单

00:49:25.529 --> 00:49:33.720
但他做到了，她做得很好

00:49:32.309 --> 00:49:35.039
因此，但不要将其还原为

00:49:33.720 --> 00:49:37.109
这是你通过他的数据说的

00:49:35.039 --> 00:49:40.289
选择导出的绑定

00:49:37.109 --> 00:49:42.509
特定的API对作者

00:49:40.289 --> 00:49:44.039
数据绑定的作者说要导出

00:49:42.509 --> 00:49:44.430
前四个包，然后是

00:49:44.039 --> 00:49:47.009
另一个

00:49:44.430 --> 00:49:57.180
等等，你说你说另一个模块

00:49:47.009 --> 00:50:02.309
当他们定义另一个

00:49:57.180 --> 00:50:05.279
 Jackson批注模型推断文件

00:50:02.309 --> 00:50:08.190
说他们公开这堂课好，所以这

00:50:05.279 --> 00:50:11.190
由定义使用，但另一个类

00:50:08.190 --> 00:50:15.269
也许我的应用程序中我也使用了

00:50:11.190 --> 00:50:20.069
杰克逊（Jackson）一种记法，但我决定使用

00:50:15.269 --> 00:50:22.140
另一个相同版本的注释

00:50:20.069 --> 00:50:25.470
但IP表示我不公开

00:50:22.140 --> 00:50:28.859
上课再用他们一个

00:50:25.470 --> 00:50:32.999
他们还使用了杰克逊的应用程序

00:50:28.859 --> 00:50:35.430
他们查看模块时的数据禁止

00:50:32.999 --> 00:50:37.380
他们将看到相同的信息

00:50:35.430 --> 00:50:40.589
信息，因为他们使用相同的

00:50:37.380 --> 00:50:43.619
版本，然后他们向我学习选一个

00:50:40.589 --> 00:50:45.809
那么他们就不会期望

00:50:43.619 --> 00:50:48.720
真正的结果，我明白你在说

00:50:45.809 --> 00:50:51.809
杰克逊注释模块之一

00:50:48.720 --> 00:50:54.059
版本导出包和另一个

00:50:51.809 --> 00:50:56.730
版本的Jackson注释不

00:50:54.059 --> 00:50:59.759
导出与您相同的包

00:50:56.730 --> 00:51:02.460
我认为这有点不寻常

00:50:59.759 --> 00:51:06.799
你可以想象得到

00:51:02.460 --> 00:51:06.799
发生了，但让我们假设它发生了

00:51:06.859 --> 00:51:12.089
杰克逊（Jackson）选择版本的人

00:51:09.960 --> 00:51:12.660
杰克逊数据绑定继续

00:51:12.089 --> 00:51:15.030
系统

00:51:12.660 --> 00:51:17.339
因为我的应用要求它还必须

00:51:15.030 --> 00:51:20.549
选择杰克逊注释的版本

00:51:17.339 --> 00:51:23.130
那首记录

00:51:20.549 --> 00:51:25.319
 require子句将针对

00:51:23.130 --> 00:51:27.450
上只有一种版本

00:51:25.319 --> 00:51:30.630
系统是否有两个版本

00:51:27.450 --> 00:51:34.490
杰克逊注解选了一个，因为我

00:51:30.630 --> 00:51:44.309
认为拥有这些是一个很好的功能

00:51:34.490 --> 00:51:46.859
决定公开你的包

00:51:44.309 --> 00:51:48.690
今天你不能在类路径上做到这一点

00:51:46.859 --> 00:51:50.130
如果不能在类路径上做版本

00:51:48.690 --> 00:51:52.910
接下来的五个问题是关于

00:51:50.130 --> 00:52:00.510
版本仍然是一个

00:51:52.910 --> 00:52:02.789
抱歉，谢谢，好的，您已经展示了

00:52:00.510 --> 00:52:04.500
做自上而下的耶

00:52:02.789 --> 00:52:06.450
应用程序所有者，是的，您知道吗

00:52:04.500 --> 00:52:09.510
是的，当你是图书馆的时候

00:52:06.450 --> 00:52:10.680
仅有Java模块的开发人员

00:52:09.510 --> 00:52:13.680
依赖mm-hmm 

00:52:10.680 --> 00:52:15.839
你中间是怎么回事

00:52:13.680 --> 00:52:18.869
您有图书馆要移动

00:52:15.839 --> 00:52:20.819
成为模块，但不幸的是你的一些

00:52:18.869 --> 00:52:24.089
依赖还不是模块应该

00:52:20.819 --> 00:52:27.779
您应该这样做还是应该等到

00:52:24.089 --> 00:52:30.029
你下面的图很干净

00:52:27.779 --> 00:52:32.190
应该去做，好吧，你应该去做

00:52:30.029 --> 00:52:36.690
你应该记录下来，什么时候做

00:52:32.190 --> 00:52:40.950
它让我带起涡轮机，如果

00:52:36.690 --> 00:52:45.049
数据绑定所需的番石榴

00:52:40.950 --> 00:52:47.599
番石榴还不是一个明确的模块

00:52:45.049 --> 00:52:51.750
您大概正在测试您的库

00:52:47.599 --> 00:52:56.220
针对某些版本的番石榴，您可以

00:52:51.750 --> 00:52:57.960
写在这里我需要假设番石榴

00:52:56.220 --> 00:53:01.049
这是没有暴露番石榴类型和

00:52:57.960 --> 00:53:04.160
签名，您需要输入

00:53:01.049 --> 00:53:06.270
请放入番石榴的文件

00:53:04.160 --> 00:53:09.539
下载某些版本的番石榴并放入

00:53:06.270 --> 00:53:12.329
它在模块路径上，因为

00:53:09.539 --> 00:53:16.559
作为一个好公民，但是你这个

00:53:12.329 --> 00:53:18.390
问题的问题是如果

00:53:16.559 --> 00:53:22.260
您等待模块化

00:53:18.390 --> 00:53:24.010
然后其他一些库正确

00:53:22.260 --> 00:53:26.480
下议院的悲剧

00:53:24.010 --> 00:53:27.760
重要的是

00:53:26.480 --> 00:53:31.010
库实际上可以迁移

00:53:27.760 --> 00:53:32.930
独立地那才是真正的

00:53:31.010 --> 00:53:35.210
公园的第一部分是

00:53:32.930 --> 00:53:37.880
在里面只有一种

00:53:35.210 --> 00:53:40.040
您和模块最终的方式是

00:53:37.880 --> 00:53:42.140
命名，所以你需要注意我

00:53:40.040 --> 00:53:44.600
要说下一个问题

00:53:42.140 --> 00:53:47.420
然后问是好的我是数据绑定我是

00:53:44.600 --> 00:53:48.830
希望成为的好模范公民

00:53:47.420 --> 00:53:52.580
链接到一天的图像

00:53:48.830 --> 00:53:54.410
很好，但我需要番石榴，番石榴是

00:53:52.580 --> 00:53:56.360
作为我的自动模块

00:53:54.410 --> 00:53:59.540
系统在那里每个人都

00:53:56.360 --> 00:54:02.320
关于何时该模块的供应商

00:53:59.540 --> 00:54:05.030
那个罐子变成一个模块化的罐子

00:54:02.320 --> 00:54:08.150
当他们声明一个模块，他们

00:54:05.030 --> 00:54:10.400
决定称它为其他东西

00:54:08.150 --> 00:54:15.020
那将是对他们的不礼貌

00:54:10.400 --> 00:54:17.900
好吧，以某种方式

00:54:15.020 --> 00:54:20.300
像今天一样是你的罐子，你的方式

00:54:17.900 --> 00:54:22.520
有自动命名是

00:54:20.300 --> 00:54:37.160
受到公共API的尊重

00:54:22.520 --> 00:54:39.890
我们第二个问题应该很多

00:54:37.160 --> 00:54:42.260
比较简单，所以我错过了介绍表，所以

00:54:39.890 --> 00:54:45.380
我从这里了解的是

00:54:42.260 --> 00:54:47.180
你只是普通人而已

00:54:45.380 --> 00:54:51.380
他们将适用的应用程序取决于

00:54:47.180 --> 00:54:52.970
在像杰克逊这样的图书馆上

00:54:51.380 --> 00:54:55.430
那也许你应该就应该

00:54:52.970 --> 00:54:59.390
自上而下，这似乎少得多

00:54:55.430 --> 00:55:00.680
工作毫米-毫米，这就像您的应用程序是

00:54:59.390 --> 00:55:04.190
在那里，您将其设置为Eclair 

00:55:00.680 --> 00:55:05.690
周，所以联系，但是如果

00:55:04.190 --> 00:55:07.580
你只要自上而下站起来

00:55:05.690 --> 00:55:09.590
至少为您的模块准备好了

00:55:07.580 --> 00:55:12.200
您的应用程序将被模块化， 

00:55:09.590 --> 00:55:14.450
应该足够好去了，这是非常

00:55:12.200 --> 00:55:17.510
能够从中下载jar的常见功能

00:55:14.450 --> 00:55:20.420
像杰克逊这样的互联网

00:55:17.510 --> 00:55:23.060
他们可能是JDK六五或六零

00:55:20.420 --> 00:55:26.090
这些罐子中的类文件将罐子放在

00:55:23.060 --> 00:55:28.480
它将经常工作的模块路径

00:55:26.090 --> 00:55:30.609
作为自动模块

00:55:28.480 --> 00:55:32.619
这就是它本身的名字

00:55:30.609 --> 00:55:34.660
涌现出来，以便您

00:55:32.619 --> 00:55:37.839
应用程序中的模块信息点Java 

00:55:34.660 --> 00:55:41.349
可能会要求它出奇的效果

00:55:37.839 --> 00:55:41.829
通常，如果它不起作用，请不要打电话

00:55:41.349 --> 00:55:46.750
我们

00:55:41.829 --> 00:55:50.109
给作者打电话，我可以告诉你

00:55:46.750 --> 00:55:52.390
原因是他们要么

00:55:50.109 --> 00:55:53.560
要么正在访问JDK内部

00:55:52.390 --> 00:55:55.240
与...无关

00:55:53.560 --> 00:55:56.859
模块不是真正的模块

00:55:55.240 --> 00:55:58.270
系统不是自动模块

00:55:56.859 --> 00:56:00.520
是他们正在访问一些问题

00:55:58.270 --> 00:56:03.310
内部的东西和他们的罐子不起作用

00:56:00.520 --> 00:56:06.190
如果不是，则在类路径上

00:56:03.310 --> 00:56:09.550
偶尔访问您的JDK内部

00:56:06.190 --> 00:56:13.960
查找包含以下内容的传统jar文件

00:56:09.550 --> 00:56:18.220
 Java X批注中的类

00:56:13.960 --> 00:56:20.349
 Java X XML注册表中的名称空间

00:56:18.220 --> 00:56:21.700
命名空间等等

00:56:20.349 --> 00:56:26.380
他们不应该包括那些

00:56:21.700 --> 00:56:29.710
类，但它们确实和模块

00:56:26.380 --> 00:56:32.140
系统在启动时检测到

00:56:29.710 --> 00:56:35.109
一些在jdk中具有类的包

00:56:32.140 --> 00:56:37.540
此自动模块中的图像类

00:56:35.109 --> 00:56:42.520
这是一件坏事，有趣的是

00:56:37.540 --> 00:56:45.369
进行下去，系统将停止，如果

00:56:42.520 --> 00:56:47.410
发生这种情况不要打电话给我们

00:56:45.369 --> 00:56:49.869
传统罐子的创造者说

00:56:47.410 --> 00:56:53.290
为什么在您的Java SE类型中

00:56:49.869 --> 00:56:59.410
从未有过的随机jar文件

00:56:53.290 --> 00:57:02.170
支持的东西可能是它实际上

00:56:59.410 --> 00:57:04.359
相对罕见，但是一旦发生，您

00:57:02.170 --> 00:57:07.990
遇到麻烦别人帮了你

00:57:04.359 --> 00:57:10.030
有麻烦了谢谢谢谢你

00:57:07.990 --> 00:57:11.890
是的，我想说我们会

00:57:10.030 --> 00:57:17.319
最后要把它们包起来

00:57:11.890 --> 00:57:22.210
像平滑以外的问题

00:57:17.319 --> 00:57:23.980
有些班级问题

00:57:22.210 --> 00:57:27.640
这些模块的任何其他好处

00:57:23.980 --> 00:57:30.220
会给你你正在发展

00:57:27.640 --> 00:57:33.069
您的jar是一个没有人的应用程序jar 

00:57:30.220 --> 00:57:35.470
调用还是您的代码是一个库， 

00:57:33.069 --> 00:57:37.119
很多其他人都没事

00:57:35.470 --> 00:57:39.150
你有多少个罐子

00:57:37.119 --> 00:57:43.230
应用

00:57:39.150 --> 00:57:46.150
大概有30 50 

00:57:43.230 --> 00:57:49.200
 50刚在我们的应用程序中您如何

00:57:46.150 --> 00:57:53.799
跟踪代码之间的依赖关系

00:57:49.200 --> 00:57:56.740
这些罐子里的课程是一个大球

00:57:53.799 --> 00:57:59.559
是的，JDK曾经

00:57:56.740 --> 00:58:04.029
看起来不仅有能力

00:57:59.559 --> 00:58:06.519
在模块中表达表达能力

00:58:04.029 --> 00:58:09.519
不仅取决于它，而且

00:58:06.519 --> 00:58:11.890
它的API现在有一些罐子

00:58:09.519 --> 00:58:13.359
在图的最上方

00:58:11.890 --> 00:58:18.220
有一个API，他们得到了主要

00:58:13.359 --> 00:58:20.349
课，但对于其他所有人

00:58:18.220 --> 00:58:23.349
值得声明的API 

00:58:20.349 --> 00:58:25.420
明确地，您可以声明这些出口

00:58:23.349 --> 00:58:28.109
如果每个人都有巢穴

00:58:25.420 --> 00:58:30.099
您可以导出给朋友的jar文件

00:58:28.109 --> 00:58:31.690
那意味着你永远不会

00:58:30.099 --> 00:58:34.029
再次，这是您一次的投资

00:58:31.690 --> 00:58:37.630
一旦成功，您将永远不会

00:58:34.029 --> 00:58:39.460
倒进他为什么是你的

00:58:37.630 --> 00:58:42.519
商业伙伴为什么是他为什么

00:58:39.460 --> 00:58:48.670
在我的包裹中称这种类型是

00:58:42.519 --> 00:58:52.390
旨在作为一个内部保护

00:58:48.670 --> 00:58:54.180
混乱的访问控制复杂性

00:58:52.390 --> 00:58:56.109
为了在之间共享任何东西

00:58:54.180 --> 00:58:58.150
有时候你想分享

00:58:56.109 --> 00:59:00.250
与公众愿意的软件包

00:58:58.150 --> 00:59:02.619
与他分享其他时间

00:59:00.250 --> 00:59:05.529
类型会影响您的包装

00:59:02.619 --> 00:59:07.569
你不想去罐子外面

00:59:05.529 --> 00:59:10.180
我很确定你在某个时候说

00:59:07.569 --> 00:59:13.240
这个包只适合其他包

00:59:10.180 --> 00:59:14.710
在同一个jar文件中

00:59:13.240 --> 00:59:17.079
模块系统能给您带来什么

00:59:14.710 --> 00:59:19.720
谢谢，顺便说一句

00:59:17.079 --> 00:59:22.509
我们有一张幻灯片显示了介绍

00:59:19.720 --> 00:59:27.450
刚才讲得好，泥球是

00:59:22.509 --> 00:59:27.450
有点像泥泞的球

00:59:31.240 --> 00:59:37.270
非常对称，好吧，我认为我们已经完成了

00:59:34.099 --> 00:59:37.270
我们结束了，谢谢

