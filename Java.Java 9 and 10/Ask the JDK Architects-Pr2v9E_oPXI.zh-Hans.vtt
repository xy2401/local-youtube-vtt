WEBVTT
Kind: captions
Language: zh-Hans

00:00:02.790 --> 00:00:08.920
下午好，欢迎问一下JDK 

00:00:06.309 --> 00:00:12.250
建筑师在这里，我们再次成为我的标志

00:00:08.920 --> 00:00:15.400
 Reinhold我和John Rose Bryan一起加入

00:00:12.250 --> 00:00:18.189
让亚历克斯·巴克利我做所有的事情

00:00:15.400 --> 00:00:21.369
约翰主要从事VM Bryan和

00:00:18.189 --> 00:00:24.309
亚历克斯致力于语言及其发展

00:00:21.369 --> 00:00:26.020
照顾规格，所以这

00:00:24.309 --> 00:00:28.390
几乎没有介绍

00:00:26.020 --> 00:00:30.430
在这里您会注意到这是从2016年开始的

00:00:28.390 --> 00:00:31.809
因为对不起，我正忙于其他一些事情

00:00:30.430 --> 00:00:36.129
今天幻灯片，没有时间

00:00:31.809 --> 00:00:38.949
更新它们只是他们只有两个

00:00:36.129 --> 00:00:43.210
这个甲板上的其他幻灯片之一是

00:00:38.949 --> 00:00:46.570
一个是，我们仍然为工作而工作

00:00:43.210 --> 00:00:49.239
很好，这是质量检查，所以我们有麦克风了

00:00:46.570 --> 00:00:52.780
这里我们有麦克风，你可以来

00:00:49.239 --> 00:00:56.019
如果您害羞，请使用

00:00:52.780 --> 00:00:57.969
向我发推文，也许我会重复你的

00:00:56.019 --> 00:01:00.789
问题也许我不会拥有

00:00:57.969 --> 00:01:04.600
行使编辑控制权

00:01:00.789 --> 00:01:06.610
我们有44分钟左右的质量检查时间

00:01:04.600 --> 00:01:08.970
大家问的问题并不意味着

00:01:06.610 --> 00:01:12.070
我们一定会回答他们

00:01:08.970 --> 00:01:14.320
迈克在这里或有人

00:01:12.070 --> 00:01:16.890
想跑来跑去掉

00:01:14.320 --> 00:01:16.890
你也能做到

00:01:19.840 --> 00:01:27.140
所以如果我有一个正在运行的程序

00:01:23.900 --> 00:01:28.820
我的JVM，我知道什么元空间

00:01:27.140 --> 00:01:30.860
我想知道什么设定

00:01:28.820 --> 00:01:33.440
我想我已经找到了

00:01:30.860 --> 00:01:35.900
很难找出多少内存

00:01:33.440 --> 00:01:39.200
在机器上或虚拟机将

00:01:35.900 --> 00:01:41.270
需要，我想知道我已经看到了

00:01:39.200 --> 00:01:44.140
关于某种支持的一点点

00:01:41.270 --> 00:01:46.250
为此，使用Java 9和

00:01:44.140 --> 00:01:48.560
可用内存，但是有一个好方法

00:01:46.250 --> 00:01:51.380
弄清楚还是真的

00:01:48.560 --> 00:01:53.869
只是大量运行并测量直到

00:01:51.380 --> 00:02:00.050
下来但复杂的本质

00:01:53.869 --> 00:02:05.060
动态系统我爱约翰的鬼脸

00:02:00.050 --> 00:02:06.800
有人得到一张照片，我们做到了我们

00:02:05.060 --> 00:02:07.820
我们给您控件，因为我们

00:02:06.800 --> 00:02:11.000
不知道怎么开车

00:02:07.820 --> 00:02:11.420
我认为这很短

00:02:11.000 --> 00:02:14.450
回答

00:02:11.420 --> 00:02:16.520
更长的答案是我们有一些非常

00:02:14.450 --> 00:02:18.920
聪明的人在存储管理中

00:02:16.520 --> 00:02:24.709
那些担心这些东西的小组

00:02:18.920 --> 00:02:26.209
时间，你知道他们他们是

00:02:24.709 --> 00:02:29.390
试图他们试图弄清楚这一点

00:02:26.209 --> 00:02:31.430
并随着时间的推移变得更好

00:02:29.390 --> 00:02:35.209
最近几年的问题

00:02:31.430 --> 00:02:39.380
来过雷顿（Layton）的人看到最大延迟

00:02:35.209 --> 00:02:41.390
我们已经很好地处理了你

00:02:39.380 --> 00:02:43.070
如果你挤一个就知道你

00:02:41.390 --> 00:02:45.799
参数或其他参数弹出

00:02:43.070 --> 00:02:50.090
控制，我想现在我们

00:02:45.799 --> 00:02:52.850
进入群集和堆叠

00:02:50.090 --> 00:02:54.860
在您身上运行的容器很小

00:02:52.850 --> 00:02:59.900
空间限制我们需要的空间

00:02:54.860 --> 00:03:02.959
再看一下内存限制和

00:02:59.900 --> 00:03:04.940
你知道与快速

00:03:02.959 --> 00:03:07.690
建立云基础架构Java 

00:03:04.940 --> 00:03:10.390
在那艘大船上航行

00:03:07.690 --> 00:03:12.640
我们正在寻找制作虚拟机的方法

00:03:10.390 --> 00:03:15.190
有更多可预测的记忆

00:03:12.640 --> 00:03:18.580
要求，但我会说还早

00:03:15.190 --> 00:03:23.440
天，最好的事情是

00:03:18.580 --> 00:03:25.420
让社区告诉我们什么

00:03:23.440 --> 00:03:27.730
他们的最佳做法是

00:03:25.420 --> 00:03:30.280
告诉我们是否很简单

00:03:27.730 --> 00:03:31.960
即使是机器甚至是机器人都可以

00:03:30.280 --> 00:03:35.080
然后做，也许我们希望我们的机器人去做

00:03:31.960 --> 00:03:37.780
它给你，但我们有我们特别

00:03:35.080 --> 00:03:41.220
深入了解如何

00:03:37.780 --> 00:03:44.590
管理内存并保留它

00:03:41.220 --> 00:03:47.170
大小有限，但特殊

00:03:44.590 --> 00:03:48.880
知识不能给我们最好的

00:03:47.170 --> 00:03:50.410
实际最佳做法的想法

00:03:48.880 --> 00:03:51.970
野外的应用程序，所以

00:03:50.410 --> 00:03:54.670
恐怕我不得不提出这个问题

00:03:51.970 --> 00:03:57.270
回到这个听众足够公平

00:03:54.670 --> 00:03:57.270
谢谢

00:03:58.030 --> 00:04:10.660
我有一个版本问题

00:04:04.570 --> 00:04:16.829
下一个版本将不会更好

00:04:10.660 --> 00:04:20.530
一些伟大功能的标记，例如

00:04:16.829 --> 00:04:26.710
当我们添加值类型时， 

00:04:20.530 --> 00:04:32.950
假设10.20点3，现在我们将有

00:04:26.710 --> 00:04:34.450
九点18 3我可以问这个问题吗

00:04:32.950 --> 00:04:39.120
返回谁想花下40 

00:04:34.450 --> 00:04:40.960
会议纪要谈论版本方案

00:04:39.120 --> 00:04:42.940
是的，我不这么认为

00:04:40.960 --> 00:04:45.160
我的意思是抱歉，这是一辆巨大的自行车

00:04:42.940 --> 00:04:46.960
棚子，我们可以在那里呆一整天

00:04:45.160 --> 00:04:49.960
有很多因素要成为

00:04:46.960 --> 00:04:52.020
认为我们毫无疑问

00:04:49.960 --> 00:04:54.850
内部对此进行了激烈的讨论

00:04:52.020 --> 00:04:57.010
 openjdk当JT新建JDK项目时

00:04:54.850 --> 00:04:58.480
被批准，所以如果您很在意

00:04:57.010 --> 00:05:04.180
我鼓励你参加

00:04:58.480 --> 00:05:06.610
那样，但我只是不诚实

00:05:04.180 --> 00:05:09.130
认为这将对

00:05:06.610 --> 00:05:12.490
这个房间里所有人的时间是

00:05:09.130 --> 00:05:19.120
我的意思是那不公平没关系

00:05:12.490 --> 00:05:23.919
对于$ 1的响应否否否我是0.1 

00:05:19.120 --> 00:05:27.760
 beta 1 John好，我有一个问题，所以

00:05:23.919 --> 00:05:30.790
就像我将从VM语言报告一样

00:05:27.760 --> 00:05:35.979
规格，因此它是Java内存的未来

00:05:30.790 --> 00:05:38.440
模特，所以也许你可以说

00:05:35.979 --> 00:05:41.020
关于它的一些事情，吉姆吉姆，我9岁

00:05:38.440 --> 00:05:45.060
可能是它的未来

00:05:41.020 --> 00:05:45.060
所以计划要实施什么

00:05:45.390 --> 00:05:49.180
需要未来，有些人

00:05:47.410 --> 00:05:50.410
考虑了一下，但我不知道

00:05:49.180 --> 00:05:53.979
他们最近才想到

00:05:50.410 --> 00:05:55.960
知道那里是什么

00:05:53.979 --> 00:05:57.289
发生的事，也许你见过他

00:05:55.960 --> 00:06:00.139
它的暗示

00:05:57.289 --> 00:06:04.610
道格·李（Doug Lee）领导的JMM工作组

00:06:00.139 --> 00:06:07.639
我会给几个

00:06:04.610 --> 00:06:09.199
记得律师的幻灯片，但有几个

00:06:07.639 --> 00:06:15.710
我们正在谈论的事情

00:06:09.199 --> 00:06:20.149
在公共场合是，谢谢

00:06:15.710 --> 00:06:22.460
哦，是越来越与

00:06:20.149 --> 00:06:23.749
 C ++内存模型

00:06:22.460 --> 00:06:26.899
 Java内存的小兄弟

00:06:23.749 --> 00:06:28.789
 Java模型具有强大的功能

00:06:26.899 --> 00:06:31.969
严格的规格，谢谢亚历克斯

00:06:28.789 --> 00:06:33.740
 Buckley和其他人以及记忆模型

00:06:31.969 --> 00:06:36.319
是Java拥有

00:06:33.740 --> 00:06:39.740
比其他任何产品都更好的规格

00:06:36.319 --> 00:06:41.539
部署的语言，但现在C ++是

00:06:39.740 --> 00:06:42.740
我们要确保成长

00:06:41.539 --> 00:06:44.029
他们有一些连贯性

00:06:42.740 --> 00:06:47.990
相对于彼此，所以我们要添加

00:06:44.029 --> 00:06:50.539
诸如获取和释放的概念， 

00:06:47.990 --> 00:06:53.389
它仍然无法替代基础

00:06:50.539 --> 00:06:55.279
我们已经获得的记忆模型

00:06:53.389 --> 00:06:57.589
发布我们的行为指示

00:06:55.279 --> 00:07:01.099
发生了什么事

00:06:57.589 --> 00:07:02.300
在基金会之前，那是

00:07:01.099 --> 00:07:03.620
不会很快改变

00:07:02.300 --> 00:07:06.769
将不得不极端改变

00:07:03.620 --> 00:07:08.240
虽然特别照顾另一个项目

00:07:06.769 --> 00:07:10.580
我会对Java内存感兴趣

00:07:08.240 --> 00:07:14.659
模式是我们有特殊的规则

00:07:10.580 --> 00:07:16.819
对象中的final-final字段

00:07:14.659 --> 00:07:18.889
意味着有一个特殊的

00:07:16.819 --> 00:07:21.319
保证安全出版

00:07:18.889 --> 00:07:23.389
对象中的最终最终字段值，以及

00:07:21.319 --> 00:07:25.219
道格认为我们可以做到的一件事

00:07:23.389 --> 00:07:27.259
拉下来，如果真的很棒

00:07:25.219 --> 00:07:31.069
可能，对我来说也可能

00:07:27.259 --> 00:07:32.599
将保证范围扩大到两个

00:07:31.069 --> 00:07:35.059
不一定需要的稳定字段

00:07:32.599 --> 00:07:36.619
在所有对象中标记为最终，以便

00:07:35.059 --> 00:07:38.269
意味着那意味着你可以

00:07:36.619 --> 00:07:40.490
有一个对象，如果是我，如果

00:07:38.269 --> 00:07:41.779
字段在其他字段中实际上是最终的

00:07:40.490 --> 00:07:44.569
话，如果你实际上不去拥有

00:07:41.779 --> 00:07:47.959
竞赛权或田径权

00:07:44.569 --> 00:07:49.729
在构造函数退出之后，对于所有

00:07:47.959 --> 00:07:51.110
您的数据的意图和目的

00:07:49.729 --> 00:07:55.909
免费比赛，就好像您已经标记了

00:07:51.110 --> 00:07:58.660
场决赛说我可能是

00:07:55.909 --> 00:08:01.090
很难正确使用它

00:07:58.660 --> 00:08:03.880
再次，这是内存模型

00:08:01.090 --> 00:08:06.220
是图书馆作者的关注点

00:08:03.880 --> 00:08:07.420
我要说的不仅仅是最终用户

00:08:06.220 --> 00:08:09.490
我敢打赌，您要添加一些内容

00:08:07.420 --> 00:08:10.690
所以有一些

00:08:09.490 --> 00:08:12.970
有一点进步

00:08:10.690 --> 00:08:15.130
你在工作组中知道

00:08:12.970 --> 00:08:16.960
知道当唐提到它不是

00:08:15.130 --> 00:08:18.910
真正令人印象深刻的专家小组和

00:08:16.960 --> 00:08:20.740
他们一直在抨击他们的集体

00:08:18.910 --> 00:08:24.490
对抗它的时间比

00:08:20.740 --> 00:08:25.750
他们计划这样做，但他们仍然没有

00:08:24.490 --> 00:08:27.160
满意他们有东西

00:08:25.750 --> 00:08:28.180
这比我们现在拥有的要好，但是

00:08:27.160 --> 00:08:30.160
他们仍然在b头

00:08:28.180 --> 00:08:32.620
反对，所以你知道是

00:08:30.160 --> 00:08:36.039
继续，但也有一些

00:08:32.620 --> 00:08:37.690
我确实找到了一些进步

00:08:36.039 --> 00:08:39.430
更新内存模型的要求

00:08:37.690 --> 00:08:42.010
除了与

00:08:39.430 --> 00:08:45.730
 C ++建模艺术负责处理

00:08:42.010 --> 00:08:48.360
进入Java Ngayon暴露了更多

00:08:45.730 --> 00:08:52.140
控制内存一致性

00:08:48.360 --> 00:08:54.790
要求，因此var处理支持

00:08:52.140 --> 00:08:56.830
所有的内存访问

00:08:54.790 --> 00:09:00.810
您知道玩过的不同访问模式

00:08:56.830 --> 00:09:03.460
一个合唱团，你知道一个完整的栅栏等

00:09:00.810 --> 00:09:06.820
适用于

00:09:03.460 --> 00:09:09.160
希望建立最快的库

00:09:06.820 --> 00:09:11.370
他们可以有一些新工具

00:09:09.160 --> 00:09:13.540
他们在那里玩吗

00:09:11.370 --> 00:09:16.690
感谢您带来are句柄

00:09:13.540 --> 00:09:20.040
这些是向前迈出的一大步，但他们

00:09:16.690 --> 00:09:24.240
他们也很难正确使用是的

00:09:20.040 --> 00:09:24.240
谢谢，我在这里有一个问题

00:09:25.350 --> 00:09:31.570
是的，所以我刚刚看到了您的幻灯片

00:09:29.530 --> 00:09:33.430
新出现的切换语句等

00:09:31.570 --> 00:09:35.590
我只是想了解如何

00:09:33.430 --> 00:09:37.390
六个月发布一个如何发展

00:09:35.590 --> 00:09:40.840
这样的功能，所以我一看到

00:09:37.390 --> 00:09:43.180
我正在考虑的那个陈述

00:09:40.840 --> 00:09:45.240
在Scala中，您所处的皇家混乱

00:09:43.180 --> 00:09:48.130
知道有15种不同的方式

00:09:45.240 --> 00:09:50.080
选择，他们都略

00:09:48.130 --> 00:09:51.610
彼此不兼容且明显

00:09:50.080 --> 00:09:52.870
那东西已经有机地生长了

00:09:51.610 --> 00:09:56.050
还是另一个研究生

00:09:52.870 --> 00:09:58.240
添加了另一个子功能，所以

00:09:56.050 --> 00:10:00.070
你们会说好吗

00:09:58.240 --> 00:10:02.740
我们将逐步推出，但

00:10:00.070 --> 00:10:04.930
我们要先计划一下

00:10:02.740 --> 00:10:07.460
过程是，以及如何

00:10:04.930 --> 00:10:09.380
整个过程都涉及公众

00:10:07.460 --> 00:10:10.970
现在我们有了这些小伙子和乔·苏亚雷斯

00:10:09.380 --> 00:10:14.600
一切都令人困惑，那是怎么回事

00:10:10.970 --> 00:10:15.950
将在六个月后发布

00:10:14.600 --> 00:10:19.279
我设法塞满了很多东西

00:10:15.950 --> 00:10:20.839
问题是的，所以这有点

00:10:19.279 --> 00:10:22.730
这两个方面，所以第一个

00:10:20.839 --> 00:10:24.830
问题是我们如何处理

00:10:22.730 --> 00:10:26.390
释放频率非常

00:10:24.830 --> 00:10:27.800
与时标不同

00:10:26.390 --> 00:10:30.260
我们以前一直在开发， 

00:10:27.800 --> 00:10:31.610
那么另一个问题是我们如何

00:10:30.260 --> 00:10:33.110
设计功能逐步增加

00:10:31.610 --> 00:10:34.580
所以这是两个独立的问题

00:10:33.110 --> 00:10:35.810
有关发布的第一个问题

00:10:34.580 --> 00:10:38.450
频率实际上真的很容易

00:10:35.810 --> 00:10:40.070
没有什么可以说我们只有

00:10:38.450 --> 00:10:41.750
六个月开发一个功能不是

00:10:40.070 --> 00:10:44.360
就像有一些起跑枪

00:10:41.750 --> 00:10:45.589
像“好吧”一样开始输入然后

00:10:44.360 --> 00:10:47.240
你有什么你在结束时

00:10:45.589 --> 00:10:49.220
六个月的出货时间不正常

00:10:47.240 --> 00:10:53.209
对，所以功能在

00:10:49.220 --> 00:10:55.250
分支机构有长期运行的项目

00:10:53.209 --> 00:10:58.279
他们周围有专家小组

00:10:55.250 --> 00:11:00.440
劝告劝告

00:10:58.279 --> 00:11:03.140
要求有人在尝试

00:11:00.440 --> 00:11:05.690
抢先体验版，因此我们正在使用

00:11:03.140 --> 00:11:09.709
与我们以前使用的过程完全相同

00:11:05.690 --> 00:11:12.650
开发类似lambda的东西，但是你

00:11:09.709 --> 00:11:17.000
知道我们，只是你知道这是一场自由奔跑

00:11:12.650 --> 00:11:18.830
进程和OpenJDK，您知道您

00:11:17.000 --> 00:11:21.050
知道现在正在探索空间

00:11:18.830 --> 00:11:23.800
如何分解复杂功能

00:11:21.050 --> 00:11:26.180
进入许多更简单的子功能

00:11:23.800 --> 00:11:28.970
答案很简单

00:11:26.180 --> 00:11:31.400
必须提前设计好，所以

00:11:28.970 --> 00:11:32.630
如果我们能很好地期望

00:11:31.400 --> 00:11:34.339
成为这样的功能，然后

00:11:32.630 --> 00:11:36.050
这样的功能建立在

00:11:34.339 --> 00:11:38.750
它，然后这个功能没有

00:11:36.050 --> 00:11:40.360
准备好发货，准备好发货

00:11:38.750 --> 00:11:42.350
我只有一个扎实的设计

00:11:40.360 --> 00:11:45.200
规范实施和测试

00:11:42.350 --> 00:11:47.720
未来的一周，但我有一个明确的

00:11:45.200 --> 00:11:48.980
如何适应的想法

00:11:47.720 --> 00:11:51.020
接下来的三四五层

00:11:48.980 --> 00:11:53.870
在其之上构建的功能

00:11:51.020 --> 00:11:55.610
需要这些功能让您知道

00:11:53.870 --> 00:11:57.589
至少达到了我的水平

00:11:55.610 --> 00:11:59.930
有一个设计和一个原型，所有的

00:11:57.589 --> 00:12:01.790
这样就不像我们要扔

00:11:59.930 --> 00:12:03.950
每六个我们在那里

00:12:01.790 --> 00:12:05.990
铃响了几个月

00:12:03.950 --> 00:12:08.120
我们觉得这是

00:12:05.990 --> 00:12:10.070
足够坚固和清洁

00:12:08.120 --> 00:12:12.290
可以在逻辑上与教师脱钩

00:12:10.070 --> 00:12:14.089
这将取决于它，我们已经

00:12:12.290 --> 00:12:15.730
我觉得很合理

00:12:14.089 --> 00:12:18.339
感

00:12:15.730 --> 00:12:21.070
或者你知道什么时候是什么时候

00:12:18.339 --> 00:12:22.570
到达那个阶段，你知道

00:12:21.070 --> 00:12:24.670
是的，我们可能会做一些

00:12:22.570 --> 00:12:27.040
错误，但仍然是同一个人

00:12:24.670 --> 00:12:28.839
一直在移动平台

00:12:27.040 --> 00:12:31.180
这些年来，这些人

00:12:28.839 --> 00:12:33.310
深入了解需要花费什么

00:12:31.180 --> 00:12:34.839
维持20年，以及如何

00:12:33.310 --> 00:12:37.000
功能相互影响，并且

00:12:34.839 --> 00:12:39.820
兼容性的重要性，所以我

00:12:37.000 --> 00:12:42.449
其实并不认为它像

00:12:39.820 --> 00:12:44.800
听起来好像我还有麦克风

00:12:42.449 --> 00:12:46.300
也许开关侧把我扔了

00:12:44.800 --> 00:12:48.550
因为我看到你在说话

00:12:46.300 --> 00:12:49.930
我所说的破坏性活动有很多

00:12:48.550 --> 00:12:51.820
可能会出错的东西

00:12:49.930 --> 00:12:53.800
你知道的特定方面

00:12:51.820 --> 00:12:56.050
你什么时候觉得舒服

00:12:53.800 --> 00:12:59.589
实际上会看到这不会

00:12:56.050 --> 00:13:01.389
当我们是18点O 3对

00:12:59.589 --> 00:13:02.589
舒适是答案，对，是的

00:13:01.389 --> 00:13:03.970
说，所以我们展示的第一个功能

00:13:02.589 --> 00:13:05.709
今天本地持久类型推断

00:13:03.970 --> 00:13:08.829
已经检查过了

00:13:05.709 --> 00:13:14.500
坐在火车上，正要去

00:13:08.829 --> 00:13:15.760
其他功能将随着时间的流逝而出现

00:13:14.500 --> 00:13:17.709
在某些方面这很难，但在某些方面

00:13:15.760 --> 00:13:19.930
它也坦率地解放了权利

00:13:17.709 --> 00:13:21.819
因为你可以做一些事情直到

00:13:19.930 --> 00:13:24.100
完成，然后好了，什么版本

00:13:21.819 --> 00:13:27.550
准备好，一切顺利，我能想到

00:13:24.100 --> 00:13:30.010
 se 7和8中的许多语言功能，其中

00:13:27.550 --> 00:13:32.050
他们一上班就不是

00:13:30.010 --> 00:13:34.899
然后我们意识到一些东西

00:13:32.050 --> 00:13:36.250
应该已经增加了

00:13:34.899 --> 00:13:39.040
用户可见的东西，但有点像

00:13:36.250 --> 00:13:42.940
进行细微调整以输入8 

00:13:39.040 --> 00:13:46.899
例子在哪里

00:13:42.940 --> 00:13:49.240
完全相加只是一个

00:13:46.899 --> 00:13:51.430
额外

00:13:49.240 --> 00:13:54.610
它使语言更加开放

00:13:51.430 --> 00:13:57.040
支持它，现在就拥有，如果您仅

00:13:54.610 --> 00:13:58.720
如果您在3年之前

00:13:57.040 --> 00:14:02.709
接下来的事情我是说你不可能

00:13:58.720 --> 00:14:04.750
甚至告诉人们会发生什么

00:14:02.709 --> 00:14:08.769
可能会进入

00:14:04.750 --> 00:14:09.910
 JDK 9对，但是你不能告诉别人

00:14:08.769 --> 00:14:11.680
关于它，还有很多这些

00:14:09.910 --> 00:14:14.709
小东西很多小角落

00:14:11.680 --> 00:14:16.690
基本上可以添加的案例

00:14:14.709 --> 00:14:18.790
完全安全，我不是在说

00:14:16.690 --> 00:14:20.290
常数之间的差异

00:14:18.790 --> 00:14:23.190
模式和

00:14:20.290 --> 00:14:25.329
嵌套模式并谈论

00:14:23.190 --> 00:14:27.339
角落案例，但角落案例是

00:14:25.329 --> 00:14:29.290
推理可以使您的生活变得更好

00:14:27.339 --> 00:14:31.029
他们得到了支持，所以我认为

00:14:29.290 --> 00:14:33.639
很多，我为此感到非常兴奋

00:14:31.029 --> 00:14:39.069
能够发布um的语言

00:14:33.639 --> 00:14:42.660
规格更频繁Alex说了什么

00:14:39.069 --> 00:14:42.660
有关虚拟机的语言

00:14:42.779 --> 00:14:49.149
您认为VM拥有很多VM 

00:14:46.410 --> 00:14:52.149
改善的机会很小， 

00:14:49.149 --> 00:14:54.190
如果我们这样做的话，其中一些很小

00:14:52.149 --> 00:14:56.440
一切都拥有巨大的银河规模

00:14:54.190 --> 00:14:58.779
大爆炸功能驱动的工程

00:14:56.440 --> 00:15:02.079
那花了两年的时间

00:14:58.779 --> 00:15:04.029
改善永远不会实现，但是如果

00:15:02.079 --> 00:15:05.800
如果我们在做某件事

00:15:04.029 --> 00:15:08.079
被解放的

00:15:05.800 --> 00:15:10.029
六个月的节奏不仅是出货

00:15:08.079 --> 00:15:11.920
当你准备好但也能够

00:15:10.029 --> 00:15:16.839
运送正确的东西

00:15:11.920 --> 00:15:19.060
尺寸缩小到其他人是的

00:15:16.839 --> 00:15:21.370
您提到了一些已弃用的

00:15:19.060 --> 00:15:25.060
将在支持中删除的类

00:15:21.370 --> 00:15:26.589
整个模块的模块，所以在那里

00:15:25.060 --> 00:15:28.120
在那里徘徊的任何其他人

00:15:26.589 --> 00:15:29.649
多年来艰难而公正

00:15:28.120 --> 00:15:33.610
永不消失，我们应该开始

00:15:29.649 --> 00:15:36.550
好担心，是的，我知道

00:15:33.610 --> 00:15:40.060
在9中为您提供更多细节

00:15:36.550 --> 00:15:42.430
我们已经弃用了所有模块

00:15:40.060 --> 00:15:47.019
包含与重叠的api 

00:15:42.430 --> 00:15:49.060
 Java EE加上Corbyn模块，因此

00:15:47.019 --> 00:15:51.790
他们在那里是9他们实际上是

00:15:49.060 --> 00:15:53.230
默认情况下，由于

00:15:51.790 --> 00:15:56.620
多毛的兼容性问题，但它们是

00:15:53.230 --> 00:15:59.350
在那里你可以要求他们工作

00:15:56.620 --> 00:16:01.899
没问题，他们会的

00:15:59.350 --> 00:16:04.779
现在删除，这是一个长期存在的问题

00:16:01.899 --> 00:16:06.459
你为什么不删除，你知道那些

00:16:04.779 --> 00:16:08.680
三种不推荐使用的方法

00:16:06.459 --> 00:16:10.689
 java.awt组件或那十二

00:16:08.680 --> 00:16:14.290
不推荐使用的方法

00:16:10.689 --> 00:16:16.420
的地方，答案是不是真的

00:16:14.290 --> 00:16:19.089
在大多数情况下值得付出的代价

00:16:16.420 --> 00:16:21.399
节省很多，这就是原因之一

00:16:19.089 --> 00:16:23.800
为什么我们宁愿医生弃用

00:16:21.399 --> 00:16:25.930
 er在博士的领导下博士

00:16:23.800 --> 00:16:29.210
黛布拉迎合

00:16:25.930 --> 00:16:31.400
增强9中的弃用注释

00:16:29.210 --> 00:16:33.620
这样就可以指出什么时候

00:16:31.400 --> 00:16:35.990
已弃用，是否有表达

00:16:33.620 --> 00:16:37.940
打算删除它，所以所有这些

00:16:35.990 --> 00:16:40.250
 WT中的烦人方法

00:16:37.940 --> 00:16:41.750
现在删除它们可能不是什么

00:16:40.250 --> 00:16:44.000
你知道有什么好处

00:16:41.750 --> 00:16:45.830
其中大多数只是从重定向

00:16:44.000 --> 00:16:47.570
从旧方法名称到新方法

00:16:45.830 --> 00:16:50.270
方法名不是很大

00:16:47.570 --> 00:16:51.830
维护负担或其他任何我们

00:16:50.270 --> 00:16:53.600
可能会比较自由

00:16:51.830 --> 00:16:57.080
零碎的东西在这里零碎

00:16:53.600 --> 00:16:59.030
在那里，但你知道我会

00:16:57.080 --> 00:17:01.220
提醒您不要希望所有人

00:16:59.030 --> 00:17:02.930
不推荐使用的方法将被删除，但

00:17:01.220 --> 00:17:04.730
那可能永远不会发生， 

00:17:02.930 --> 00:17:06.830
因为每次有人提到

00:17:04.730 --> 00:17:09.500
弃用我喜欢提到孵化

00:17:06.830 --> 00:17:11.990
是的，这是双重的，因为

00:17:09.500 --> 00:17:13.760
孵化，因此JEP 11是孵化器

00:17:11.990 --> 00:17:15.410
模块和孵化器模块是一种方式

00:17:13.760 --> 00:17:17.780
提供了一个孵化功能

00:17:15.410 --> 00:17:20.390
基本上是一个正在开发的API 

00:17:17.780 --> 00:17:21.890
它的软件包名称将会更改

00:17:20.390 --> 00:17:25.370
曾经被标准化，但可能在

00:17:21.890 --> 00:17:27.560
事实上被删除，然后那也

00:17:25.370 --> 00:17:29.330
正在更改其软件包名称，因为您

00:17:27.560 --> 00:17:32.420
再也无法导入它了

00:17:29.330 --> 00:17:33.920
是孵化的概念

00:17:32.420 --> 00:17:35.090
特点是

00:17:33.920 --> 00:17:38.900
这些事情之一，我们说

00:17:35.090 --> 00:17:43.190
 JDK 9示例JDK。孵化器或HTTP 

00:17:38.900 --> 00:17:44.900
客户，然后有矢量的JDK 

00:17:43.190 --> 00:17:46.340
我相信如果点孵化器点矢量

00:17:44.900 --> 00:17:50.120
你要密切注意，尽管那是

00:17:46.340 --> 00:17:52.880
未来可能不会有九个

00:17:50.120 --> 00:17:54.770
释放谁知道哪个

00:17:52.880 --> 00:17:56.660
这些孵化功能的概念

00:17:54.770 --> 00:17:58.640
他们全力以赴

00:17:56.660 --> 00:18:00.260
 3年发布，人们积累了经验

00:17:58.640 --> 00:18:03.080
用它，或者它得到

00:18:00.260 --> 00:18:06.860
标准化或结果很好

00:18:03.080 --> 00:18:09.530
现在也需要六个月的节奏

00:18:06.860 --> 00:18:11.990
您今天看到的是httpclient，除非

00:18:09.530 --> 00:18:14.780
你我看到很多样本和问题

00:18:11.990 --> 00:18:18.040
在网络上有关该API的不是

00:18:14.780 --> 00:18:21.920
它一定要完成或由

00:18:18.040 --> 00:18:24.560
 18.3可以晚于18.3，但是

00:18:21.920 --> 00:18:26.860
可能要不到三年才能换一个新的

00:18:24.560 --> 00:18:26.860
 API 

00:18:27.540 --> 00:18:35.980
有没有人考虑过使用

00:18:30.780 --> 00:18:38.170
容器隐喻，用于描述

00:18:35.980 --> 00:18:41.050
 JVM的初始化不是

00:18:38.170 --> 00:18:45.100
仅加载类，但对象

00:18:41.050 --> 00:18:47.050
已经实例化，所以我的意思是

00:18:45.100 --> 00:18:49.660
就像我们对docker light所做的那样

00:18:47.050 --> 00:18:52.030
彼此切成薄片我

00:18:49.660 --> 00:18:54.490
是指图像正确，以便当我

00:18:52.030 --> 00:18:56.080
然后根据那个调出JVM 

00:18:54.490 --> 00:18:58.570
说明它已经拥有了所有

00:18:56.080 --> 00:19:02.680
类可能是更容易的部分

00:18:58.570 --> 00:19:07.540
但是如果

00:19:02.680 --> 00:19:11.400
我已经手动完成了

00:19:07.540 --> 00:19:14.770
知道容器是的，我们有各种各样的

00:19:11.400 --> 00:19:16.810
有点技术

00:19:14.770 --> 00:19:18.670
朝着那个，而不是在里

00:19:16.810 --> 00:19:20.890
博士的那种巧妙的方式那

00:19:18.670 --> 00:19:23.140
泊坞窗罐将图像分层放置在

00:19:20.890 --> 00:19:25.810
彼此，我是说我们已经有一段时间了

00:19:23.140 --> 00:19:27.910
现在称为类数据共享的事物

00:19:25.810 --> 00:19:29.320
封闭功能之一

00:19:27.910 --> 00:19:31.150
 Oracle将为此开源

00:19:29.320 --> 00:19:34.240
在哪里共享应用程序类数据

00:19:31.150 --> 00:19:35.620
您可以将VM指向您的

00:19:34.240 --> 00:19:38.440
拥有应用程序类，他们将

00:19:35.620 --> 00:19:40.030
创建一个预烘焙的存档

00:19:38.440 --> 00:19:42.700
但是它可以更快地加载那些

00:19:40.030 --> 00:19:44.800
四年内在运行时上课

00:19:42.700 --> 00:19:46.540
我们已经为JDK类做到了

00:19:44.800 --> 00:19:48.490
自己可以使用此功能

00:19:46.540 --> 00:19:50.500
它为您自己的应用程序类，但

00:19:48.490 --> 00:19:52.900
那里，但是还没有一个概念

00:19:50.500 --> 00:19:54.220
分层另一个棘手的部分

00:19:52.900 --> 00:19:58.210
关于分层，尤其是与

00:19:54.220 --> 00:20:00.730
九个其他的变化是

00:19:58.210 --> 00:20:03.580
我们的ter走对了，这是新的

00:20:00.730 --> 00:20:05.350
文件，您知道它在Lib斜杠中

00:20:03.580 --> 00:20:06.850
模块的格式，我们不会

00:20:05.350 --> 00:20:09.820
指定，因为它将改变

00:20:06.850 --> 00:20:11.980
经常完全在该文件内部

00:20:09.820 --> 00:20:13.450
并非旨在分层

00:20:11.980 --> 00:20:15.670
现在没有其他任何意思

00:20:13.450 --> 00:20:17.230
不可能只是那个成语

00:20:15.670 --> 00:20:19.030
拥有不是我们拥有的

00:20:17.230 --> 00:20:21.580
深思熟虑，我认为这是一个

00:20:19.030 --> 00:20:23.620
有趣的问题也要问

00:20:21.580 --> 00:20:27.430
还不清楚这真的是

00:20:23.620 --> 00:20:29.910
有用的或在docker世界中是

00:20:27.430 --> 00:20:32.200
 JDK或JDK的子集是

00:20:29.910 --> 00:20:34.630
足够细的颗粒真的吗

00:20:32.200 --> 00:20:36.429
需要能够分层JDK S 

00:20:34.630 --> 00:20:36.909
在彼此之上我不是吗

00:20:36.429 --> 00:20:51.970
不知道

00:20:36.909 --> 00:20:55.599
啊，即使是闲聊或轻率保存

00:20:51.970 --> 00:21:00.369
世界上要困难得多

00:20:55.599 --> 00:21:03.070
问题，很荣幸，这是我们的愿望

00:21:00.369 --> 00:21:04.809
清单，但是非常远

00:21:03.070 --> 00:21:06.549
不远但很远，因为

00:21:04.809 --> 00:21:08.340
我们要实现的几个愿望

00:21:06.549 --> 00:21:14.679
真正做到第一

00:21:08.340 --> 00:21:17.019
所以我们用模块解决了类路径地狱

00:21:14.679 --> 00:21:20.289
我认为我们最终将需要

00:21:17.019 --> 00:21:21.759
解决静态问题

00:21:20.289 --> 00:21:25.029
就像你在说什么

00:21:21.759 --> 00:21:27.820
所以我们有一些早期的想法

00:21:25.029 --> 00:21:33.700
关于这个，但我们必须抓取

00:21:27.820 --> 00:21:35.919
在我们可以飞之前，如果我能问我们可以

00:21:33.700 --> 00:21:37.509
麦克风传回后

00:21:35.919 --> 00:21:40.419
您的问题已完成，因为否则

00:21:37.509 --> 00:21:41.919
只有本节中的人会

00:21:40.419 --> 00:21:44.649
真正开始问任何问题， 

00:21:41.919 --> 00:21:47.349
这似乎不公平，所以这是一个

00:21:44.649 --> 00:21:49.210
来自Twitter的问题um有

00:21:47.349 --> 00:21:52.690
我们四个人考虑组成一个

00:21:49.210 --> 00:21:58.960
理发店四重奏，你不想

00:21:52.690 --> 00:22:00.820
听到可能不是及时

00:21:58.960 --> 00:22:03.340
您提出了模块，因为那是

00:22:00.820 --> 00:22:07.330
我的问题范围

00:22:03.340 --> 00:22:10.090
 G锯和模块与jsr一起使用

00:22:07.330 --> 00:22:11.729
到77至12年左右

00:22:10.090 --> 00:22:14.080
年纪大到可以升入初中

00:22:11.729 --> 00:22:17.649
不对，模块的概念消失了

00:22:14.080 --> 00:22:22.720
回到经典的1971或72 

00:22:17.649 --> 00:22:23.590
 David Lords Parnas我的道歉是不是

00:22:22.720 --> 00:22:26.349
不是一个新主意

00:22:23.590 --> 00:22:28.599
我的意思是关于Java 

00:22:26.349 --> 00:22:32.649
如果采取了正确的放置在我的位置

00:22:28.599 --> 00:22:36.789
专家组花费的时间

00:22:32.649 --> 00:22:38.289
和Oracle做到了这一希望

00:22:36.789 --> 00:22:42.250
在我们其余的人那里

00:22:38.289 --> 00:22:45.910
模块化我们的旧代码库

00:22:42.250 --> 00:22:50.510
放弃所有希望你们进入这里的人

00:22:45.910 --> 00:22:52.760
是的，不是那么糟糕，所以这

00:22:50.510 --> 00:22:55.010
对于许多人来说，这是一个长期运行的项目

00:22:52.760 --> 00:22:56.900
许多不同的原因，你猜怎么着

00:22:55.010 --> 00:22:59.720
其中很多不是技术性的

00:22:56.900 --> 00:23:01.730
从技术上讲这很艰难

00:22:59.720 --> 00:23:03.950
您毫无疑问地尝试适合

00:23:01.730 --> 00:23:06.200
将模块系统集成到现有平台中

00:23:03.950 --> 00:23:08.690
同时保持尽可能多的兼容性

00:23:06.200 --> 00:23:11.480
尽可能不降级

00:23:08.690 --> 00:23:14.030
性能是相当

00:23:11.480 --> 00:23:15.380
困难，但也有政治

00:23:14.030 --> 00:23:18.230
甚至是您可能遇到的业务问题

00:23:15.380 --> 00:23:20.810
记得当我第一次开始说话

00:23:18.230 --> 00:23:25.220
关于模块在模型上公开工作

00:23:20.810 --> 00:23:28.460
那是在2009年，我的雇主是

00:23:25.220 --> 00:23:31.580
你知道不同的公司儿子儿子儿子

00:23:28.460 --> 00:23:32.990
被获取的时间浪费了，那是什么

00:23:31.580 --> 00:23:33.980
发生在企业收购和

00:23:32.990 --> 00:23:35.780
一切，没有其他人在

00:23:33.980 --> 00:23:38.240
在工作时，更广阔的世界

00:23:35.780 --> 00:23:41.540
那个特别设置了一个问题，所以事情

00:23:38.240 --> 00:23:44.630
抱歉让整个摊子停了一会儿

00:23:41.540 --> 00:23:48.080
模块系统的空间也是

00:23:44.630 --> 00:23:51.680
政治上的挑战，因为那里

00:23:48.080 --> 00:23:53.690
是与什么重叠的解决方案

00:23:51.680 --> 00:23:56.480
拼图做和做很多鸽友

00:23:53.690 --> 00:23:58.520
你也知道很多事情

00:23:56.480 --> 00:24:01.370
人们认为哦，你知道你

00:23:58.520 --> 00:24:03.200
认为削减可能是最频繁的

00:24:01.370 --> 00:24:06.140
问的问题哦，只使用OSGi对吧

00:24:03.200 --> 00:24:08.420
好吧，就用吧，就用吧

00:24:06.140 --> 00:24:10.100
知道你知道，我不再重复

00:24:08.420 --> 00:24:12.170
在这里，但他们在玩，有很多

00:24:10.100 --> 00:24:14.980
有力的技术原因

00:24:12.170 --> 00:24:14.980
不正确的答案

00:24:15.970 --> 00:24:20.810
尽管如此，它创造了政治上的

00:24:18.350 --> 00:24:22.790
您所了解的环境更广泛

00:24:20.810 --> 00:24:25.220
 Java社区，那里有很多

00:24:22.790 --> 00:24:27.020
紧张，你知道我们当中的那些人

00:24:25.220 --> 00:24:29.840
在拼图上，我不得不努力尝试

00:24:27.020 --> 00:24:31.490
化解那些紧张局势，你知道一些

00:24:29.840 --> 00:24:34.010
其他模块系统中的人员

00:24:31.490 --> 00:24:35.480
新社区也帮助

00:24:34.010 --> 00:24:36.800
了解好，有共同点

00:24:35.480 --> 00:24:39.020
但也有不同的问题

00:24:36.800 --> 00:24:41.300
在这里解决就可以了

00:24:39.020 --> 00:24:44.270
成为一种以上的模块化解决方案

00:24:41.300 --> 00:24:46.400
在Java技术生态圈中

00:24:44.270 --> 00:24:50.300
那实际上并不是一件坏事

00:24:46.400 --> 00:24:52.190
是的，所以我花了很长时间

00:24:50.300 --> 00:24:53.140
知道有时候我会反思

00:24:52.190 --> 00:24:56.270
和

00:24:53.140 --> 00:24:59.240
我有点嫉妒我的同事

00:24:56.270 --> 00:25:01.880
因为通常他们做的不是

00:24:59.240 --> 00:25:04.700
几乎充满了政治知识

00:25:01.880 --> 00:25:07.670
你知道java中的模式匹配

00:25:04.700 --> 00:25:09.980
编程语言会有人

00:25:07.670 --> 00:25:11.210
跪求哭泣，哦，我写了一个图书馆

00:25:09.980 --> 00:25:12.559
五年前那做某事

00:25:11.210 --> 00:25:13.510
像这样模糊地应该使用

00:25:12.559 --> 00:25:17.150
那好

00:25:13.510 --> 00:25:18.590
不太可能，所以无论如何对不起

00:25:17.150 --> 00:25:22.670
 answer不休的答案，这是正确的标记

00:25:18.590 --> 00:25:25.940
一直站在那里，请

00:25:22.670 --> 00:25:31.130
关于荒谬的评论

00:25:25.940 --> 00:25:34.220
 Java SE ap的表面是真的

00:25:31.130 --> 00:25:37.730
的jsr 277开始并没有勾勒出来

00:25:34.220 --> 00:25:39.890
在2005年，但是那不是模块化的

00:25:37.730 --> 00:25:41.780
不是Java的模块化

00:25:39.890 --> 00:25:44.120
一个抽象模块的平台

00:25:41.780 --> 00:25:45.470
系统，你说的很好，哦，2008年， 

00:25:44.120 --> 00:25:47.510
那么你会因为

00:25:45.470 --> 00:25:50.000
 Sun Oracle 2010还可以吗

00:25:47.510 --> 00:25:52.100
仍年复一年

00:25:50.000 --> 00:25:55.160
模块抢你知道产生你知道

00:25:52.100 --> 00:25:57.620
首先可视化

00:25:55.160 --> 00:25:59.570
您的应用程序中的模块是一个相当

00:25:57.620 --> 00:26:01.160
直截了当的东西

00:25:59.570 --> 00:26:04.340
可以帮助您素描的工具

00:26:01.160 --> 00:26:05.840
出一个基本图嘿放放每个

00:26:04.340 --> 00:26:08.679
将Jar放入一个模块中，然后将

00:26:05.840 --> 00:26:12.830
依赖关系，你做完了

00:26:08.679 --> 00:26:15.470
这是关于JDK的第一件事

00:26:12.830 --> 00:26:18.290
我们一直在发现小小的表面

00:26:15.470 --> 00:26:21.290
那不是SE API的一部分，但是

00:26:18.290 --> 00:26:24.890
就好像它们是SE的一部分一样

00:26:21.290 --> 00:26:26.390
 XML中的AWT中的API，然后您必须

00:26:24.890 --> 00:26:29.120
坐着说，所以挂这个有

00:26:26.390 --> 00:26:31.850
从未被记录为SE的一部分，但

00:26:29.120 --> 00:26:34.160
它已经被暴露出来

00:26:31.850 --> 00:26:35.780
我们应该怎么做，就是这样

00:26:34.160 --> 00:26:37.580
既不是技术问题，也不是

00:26:35.780 --> 00:26:39.710
真正的政治或商业，但这是一个

00:26:37.580 --> 00:26:42.500
政策问题，然后是整个

00:26:39.710 --> 00:26:46.250
封装的故事，它已经死了

00:26:42.500 --> 00:26:47.990
显而易见的是， 

00:26:46.250 --> 00:26:50.590
基于Java的模块是java.lang 

00:26:47.990 --> 00:26:53.840
封装在java io包等中

00:26:50.590 --> 00:26:55.309
一些杂子被扔到一边，所以

00:26:53.840 --> 00:26:57.559
那是整个政策的决定

00:26:55.309 --> 00:26:59.300
本身就是没阳光的枪支保险柜

00:26:57.559 --> 00:27:01.490
仍然在那里，它在自己的模块中

00:26:59.300 --> 00:27:03.080
我记得它被称为JDK不支持

00:27:01.490 --> 00:27:03.630
关于命名的整个会议

00:27:03.080 --> 00:27:06.330
模组

00:27:03.630 --> 00:27:08.280
我记得有多次关于

00:27:06.330 --> 00:27:11.280
命名方式最终将

00:27:08.280 --> 00:27:13.020
大约消失，所以这是

00:27:11.280 --> 00:27:15.210
朱迪不受支持，听起来像是

00:27:13.020 --> 00:27:17.400
企业供应商的危险术语

00:27:15.210 --> 00:27:20.039
投入到每个人的运行时中

00:27:17.400 --> 00:27:21.539
我们出售支持时的图片

00:27:20.039 --> 00:27:23.789
 JDK，但是有一个不受支持的

00:27:21.539 --> 00:27:25.320
模块在那里

00:27:23.789 --> 00:27:26.940
好吧，所以你最终会好起来的

00:27:25.320 --> 00:27:29.309
您已经从Java获得了所有这些导出

00:27:26.940 --> 00:27:32.400
基地你有一些遗产

00:27:29.309 --> 00:27:34.470
在Suraj中它支持帐户哦

00:27:32.400 --> 00:27:36.990
但事实证明，所有

00:27:34.470 --> 00:27:39.059
图书馆正在使用受保护的资产

00:27:36.990 --> 00:27:42.059
可通过以下受保护的方法访问

00:27:39.059 --> 00:27:44.220
换句话说，它们是官方API 

00:27:42.059 --> 00:27:45.750
在a in in中调用它们

00:27:44.220 --> 00:27:47.750
不适当的方式

00:27:45.750 --> 00:27:51.480
我认为您通常已经定义了课程

00:27:47.750 --> 00:27:52.950
定案，所以你坦白地说

00:27:51.480 --> 00:27:55.169
那不是你要解决的问题

00:27:52.950 --> 00:27:57.240
用于您的库或代码库

00:27:55.169 --> 00:28:02.130
现在您必须提出一个

00:27:57.240 --> 00:28:04.260
我们应该允许什么的政策，然后

00:28:02.130 --> 00:28:09.299
我的意思是，仅此一项就占了大部分

00:28:04.260 --> 00:28:10.919
关于我们想要多开放的一年

00:28:09.299 --> 00:28:13.470
在不建议移除之前

00:28:10.919 --> 00:28:17.250
 EE的东西，并弄清楚

00:28:13.470 --> 00:28:20.039
所有这些都是它的管理

00:28:17.250 --> 00:28:22.620
这就是为什么当我们说话时

00:28:20.039 --> 00:28:25.590
关于模块，这似乎是

00:28:22.620 --> 00:28:27.690
好吧，有一张图是成绩，但

00:28:25.590 --> 00:28:29.970
这些东西正在输出与

00:28:27.690 --> 00:28:32.309
不出口，即我们想要什么

00:28:29.970 --> 00:28:37.080
在乎与你真正的相处

00:28:32.309 --> 00:28:39.030
不必在意它是因为

00:28:37.080 --> 00:28:41.789
很奇怪，这不是编程，不是

00:28:39.030 --> 00:28:44.250
建筑，但这是某种东西

00:28:41.789 --> 00:28:47.130
只有JDK才需要

00:28:44.250 --> 00:28:49.740
通过正确的经验

00:28:47.130 --> 00:28:52.320
是的，是的，我们除草遇到了很多

00:28:49.740 --> 00:28:53.610
分析像人造粪堆

00:28:52.320 --> 00:28:56.220
解决问题的中心

00:28:53.610 --> 00:28:58.049
是的，现有代码是否使用此代码

00:28:56.220 --> 00:28:59.820
您在钥匙中实际提到的内容

00:28:58.049 --> 00:29:03.299
建议命名的节点

00:28:59.820 --> 00:29:05.070
模块的约定是反向DNS 

00:29:03.299 --> 00:29:07.350
基于，或者你没有说这个，但是我

00:29:05.070 --> 00:29:10.080
很确定这是我们基于

00:29:07.350 --> 00:29:12.570
关于模块中的基本包装

00:29:10.080 --> 00:29:14.710
主要主要是反向DNS 

00:29:12.570 --> 00:29:17.200
主体包什么时候有意义

00:29:14.710 --> 00:29:18.970
所以我会自己就这样

00:29:17.200 --> 00:29:22.450
一场激烈的辩论

00:29:18.970 --> 00:29:23.919
基于我认为Brian Fox是

00:29:22.450 --> 00:29:24.370
 Brian Fox在这里，我不知道他是什么

00:29:23.919 --> 00:29:27.429
看起来像

00:29:24.370 --> 00:29:31.720
来源OCT的首席执行官哦，如果SonoSite 

00:29:27.429 --> 00:29:35.890
提供了大量有关名称的输入

00:29:31.720 --> 00:29:37.299
专家文物和我们

00:29:35.890 --> 00:29:40.870
甚至都没有提到自动模块

00:29:37.299 --> 00:29:42.909
通过事物本身，但要记住一个

00:29:40.870 --> 00:29:46.480
模块系统的最大特点是

00:29:42.909 --> 00:29:47.950
它支持不在模块中的代码

00:29:46.480 --> 00:29:50.230
挑战您寻找另一个模块

00:29:47.950 --> 00:29:53.320
支持您不会的系统

00:29:50.230 --> 00:29:55.240
找到一个可以采用非模块化代码的代码

00:29:53.320 --> 00:29:57.399
并视其为模块将

00:29:55.240 --> 00:29:59.470
得到一个名字，它将在那里解决

00:29:57.399 --> 00:30:01.630
将是您可以使用的API 

00:29:59.470 --> 00:30:05.049
反思他们不断

00:30:01.630 --> 00:30:07.600
并不断在任何地方都看不到

00:30:05.049 --> 00:30:12.340
否则在jboss模块中看不到

00:30:07.600 --> 00:30:16.230
在OSGi中看到它，以便进行迁移

00:30:12.340 --> 00:30:16.230
故事也花了很长时间

00:30:25.150 --> 00:30:29.590
很快

00:30:26.630 --> 00:30:32.990
是的，非常快，所以有很多

00:30:29.590 --> 00:30:41.780
 Oracle仍然存在32位系统

00:30:32.990 --> 00:30:44.299
从长远来看，那只能

00:30:41.780 --> 00:30:48.980
一次做很多事情好吗

00:30:44.299 --> 00:30:50.179
我问了20年后，对不起

00:30:48.980 --> 00:30:54.010
我本来想回答这个

00:30:50.179 --> 00:30:56.240
先生的问题首先对不起

00:30:54.010 --> 00:30:58.760
是的，所以我们做到了，我们确实做了船的形状

00:30:56.240 --> 00:31:01.040
 JDK的32位构建九个早期

00:30:58.760 --> 00:31:03.980
访问版本以及我们运送GA的时间

00:31:01.040 --> 00:31:07.580
我们在这种情况下是Oracle我们

00:31:03.980 --> 00:31:10.640
没有交付32位版本，这是一个

00:31:07.580 --> 00:31:12.890
你知道的决定，但你知道

00:31:10.640 --> 00:31:14.740
基本上是资源问题

00:31:12.890 --> 00:31:19.580
我们只能做的只有这么多

00:31:14.740 --> 00:31:21.290
针对那种类型的开发商

00:31:19.580 --> 00:31:25.190
甲骨文最感兴趣的

00:31:21.290 --> 00:31:26.929
启用32位不是那么有趣

00:31:25.190 --> 00:31:28.309
但是你知道所有的源代码是

00:31:26.929 --> 00:31:31.220
仍然在那里，你知道你可以

00:31:28.309 --> 00:31:34.160
建立它，我相信其他供应商会

00:31:31.220 --> 00:31:36.080
交付32位版本，这是其中的一部分

00:31:34.160 --> 00:31:41.150
关于Oracle的JDK开放

00:31:36.080 --> 00:31:42.919
不必做所有的事情，是的，你

00:31:41.150 --> 00:31:44.809
知道我们谈论过更快地前进

00:31:42.919 --> 00:31:47.870
你知道，加快步伐的一部分是

00:31:44.809 --> 00:31:49.970
没做正确的事情，所以运输

00:31:47.870 --> 00:31:51.919
二进制是在五十六个平台上

00:31:49.970 --> 00:31:55.460
很难移动的东西

00:31:51.919 --> 00:31:57.320
更快，所以也许您知道这是一个

00:31:55.460 --> 00:32:00.860
更好地权衡以运输二进制文件和

00:31:57.320 --> 00:32:02.390
并支持覆盖您的平台

00:32:00.860 --> 00:32:04.880
知道百分之九十八的用户

00:32:02.390 --> 00:32:08.290
基础，以便可以使用这些资源

00:32:04.880 --> 00:32:10.920
在你身上知道更多前瞻性的东西

00:32:08.290 --> 00:32:13.170
而只是

00:32:10.920 --> 00:32:14.880
我要去那里扔东西

00:32:13.170 --> 00:32:16.290
与您有关的娱乐

00:32:14.880 --> 00:32:17.610
旧平台，因为这是那种

00:32:16.290 --> 00:32:20.160
想跑的人

00:32:17.610 --> 00:32:22.320
在X上较年长的人不愿意

00:32:20.160 --> 00:32:25.620
一个人尚未注意到Java C 

00:32:22.320 --> 00:32:27.690
吉达k9，当您指定时-源

00:32:25.620 --> 00:32:30.020
以及-谁指定来源和

00:32:27.690 --> 00:32:33.000
他们调用编译器时的目标

00:32:30.020 --> 00:32:34.920
坦率地说，有些人不是很多，但是

00:32:33.000 --> 00:32:36.990
有人做了ek9你可以做到九

00:32:34.920 --> 00:32:38.670
八七六，你什么也做不了

00:32:36.990 --> 00:32:41.340
早于此，这就是NetBeans的原因

00:32:38.670 --> 00:32:43.110
无法在JDK 9上编译，因为如果

00:32:41.340 --> 00:32:45.120
你有一个遗留系统

00:32:43.110 --> 00:32:47.640
所有蚂蚁的内置源

00:32:45.120 --> 00:32:49.560
文件，因为那正是您的位置

00:32:47.640 --> 00:32:52.020
您正在环境中使用X钢琴家

00:32:49.560 --> 00:32:55.320
他们没有升级的地方

00:32:52.020 --> 00:32:57.240
另一个兼容性表面

00:32:55.320 --> 00:32:59.010
您将受到JDK 9的影响，但是

00:32:57.240 --> 00:33:02.700
显然对所有人都有好处

00:32:59.010 --> 00:33:07.470
 Java C内部不必

00:33:02.700 --> 00:33:09.960
拖延支持的1997年时代代码

00:33:07.470 --> 00:33:11.970
例如1：1的假设能力

00:33:09.960 --> 00:33:14.790
所有正在编译的代码

00:33:11.970 --> 00:33:17.220
这来自仿制药时代

00:33:14.790 --> 00:33:19.290
会将类型名称解释为原始

00:33:17.220 --> 00:33:20.610
类型而不是既不是行类型

00:33:19.290 --> 00:33:29.700
也没有泛型，因为这就是

00:33:20.610 --> 00:33:32.550
 20点后第三次不是一两个还好

00:33:29.700 --> 00:33:33.720
多年在JVM中进行优化的过程

00:33:32.550 --> 00:33:35.940
你认为剩下的一切

00:33:33.720 --> 00:33:37.530
是微优化还是您真的

00:33:35.940 --> 00:33:41.190
相信9会穿上

00:33:37.530 --> 00:33:47.520
可能会有很大机会的坚实基础

00:33:41.190 --> 00:33:49.830
您正在谈论优化JVM 

00:33:47.520 --> 00:33:57.930
关于优化代码质量的信息

00:33:49.830 --> 00:34:00.540
 JIT是的，好的，我们有一个不错的选择

00:33:57.930 --> 00:34:03.540
一小组工作的JIT工程师

00:34:00.540 --> 00:34:08.040
在这样的东西上，他们是

00:34:03.540 --> 00:34:09.750
由新事物驱动

00:34:08.040 --> 00:34:13.620
倡议正在做诸如价值

00:34:09.750 --> 00:34:16.280
他们也受我们的意识驱动

00:34:13.620 --> 00:34:19.320
根据我们的最佳信息

00:34:16.280 --> 00:34:21.720
客户的经验以及什么

00:34:19.320 --> 00:34:22.649
他们失败了什么循环

00:34:21.720 --> 00:34:25.559
优化和

00:34:22.649 --> 00:34:27.990
你知道吗，如果

00:34:25.559 --> 00:34:30.539
您可以查看上的更新日志

00:34:27.990 --> 00:34:33.059
热点的JIT部分，您会看到很多

00:34:30.539 --> 00:34:34.470
临时优化更改的数量

00:34:33.059 --> 00:34:37.619
虽然这里有内在的需要

00:34:34.470 --> 00:34:40.319
或可能是最戏剧性的东西

00:34:37.619 --> 00:34:42.960
九个时代会是新的吗

00:34:40.319 --> 00:34:45.869
将支持较新的英特尔

00:34:42.960 --> 00:34:47.460
硬件以及其他

00:34:45.869 --> 00:34:48.809
我们也支持那里的筹码，但

00:34:47.460 --> 00:34:51.359
你知道英特尔就是我们

00:34:48.809 --> 00:34:54.419
专心，但是你会看到你会

00:34:51.359 --> 00:34:57.119
看到更频繁的成功

00:34:54.419 --> 00:34:59.190
矢量化，尽管出于某些原因

00:34:57.119 --> 00:35:01.140
在上一届会议上我们已经解释过了

00:34:59.190 --> 00:35:03.599
不要把我们所有的鸡蛋都放在汽车上

00:35:01.140 --> 00:35:08.579
我们要明确的向量化篮

00:35:03.599 --> 00:35:11.099
向量化也可以

00:35:08.579 --> 00:35:12.839
一张大型幻灯片，上面印有所有

00:35:11.099 --> 00:35:14.700
我们对编译器进行的小更改是

00:35:12.839 --> 00:35:16.619
那能回答你的问题吗

00:35:14.700 --> 00:35:18.500
认为约翰在这里有点谦虚

00:35:16.619 --> 00:35:21.720
所以我可以解释一下这个问题

00:35:18.500 --> 00:35:23.520
男孩，您知道JVM做得很棒

00:35:21.720 --> 00:35:25.020
最近20年的优化是

00:35:23.520 --> 00:35:26.760
我还有什么要做的

00:35:25.020 --> 00:35:29.579
是您问题的实质，哦

00:35:26.760 --> 00:35:30.990
我的上帝是的，所以是的，我们已经完成了

00:35:29.579 --> 00:35:33.180
最后令人惊奇的事情是

00:35:30.990 --> 00:35:35.880
最近20年，还有很多

00:35:33.180 --> 00:35:37.349
你知道那里有很多

00:35:35.880 --> 00:35:39.589
你知道约翰在说什么

00:35:37.349 --> 00:35:43.079
关于但自动向量化和

00:35:39.589 --> 00:35:45.240
你知道有手动矢量化

00:35:43.079 --> 00:35:48.240
更好的多线程性能

00:35:45.240 --> 00:35:50.640
内存延迟优化对象布局

00:35:48.240 --> 00:35:52.619
您知道的记忆特征

00:35:50.640 --> 00:35:54.680
今天的系统硬件是

00:35:52.619 --> 00:35:56.940
不断发展的软件必须

00:35:54.680 --> 00:35:58.200
你知道必须有一些意识

00:35:56.940 --> 00:36:00.720
硬件将要做什么，以便我们

00:35:58.200 --> 00:36:03.180
可以生成最佳代码，所以没有

00:36:00.720 --> 00:36:06.450
缺乏真正酷的工作

00:36:03.180 --> 00:36:11.099
关于这一点，我将在此处写下有关

00:36:06.450 --> 00:36:13.200
大都市项目的增加

00:36:11.099 --> 00:36:16.770
我们从中得到的敏捷

00:36:13.200 --> 00:36:19.410
更快的节奏将被反映

00:36:16.770 --> 00:36:22.049
希望在不久的将来

00:36:19.410 --> 00:36:25.200
技术的继承

00:36:22.049 --> 00:36:28.559
服务器编译器C喷射

00:36:25.200 --> 00:36:30.850
用C ++编写，已有15年历史

00:36:28.559 --> 00:36:33.820
和

00:36:30.850 --> 00:36:37.050
和一架新的新飞机可能基于

00:36:33.820 --> 00:36:39.160
 Gras技术已经在

00:36:37.050 --> 00:36:41.350
许多人的持续发展

00:36:39.160 --> 00:36:45.550
多年，并开始在

00:36:41.350 --> 00:36:47.920
一些指标C2喷气机，所以下一步

00:36:45.550 --> 00:36:51.610
在与äôt一起玩过之后

00:36:47.920 --> 00:36:54.280
 JDK 9时间表将开始应用

00:36:51.610 --> 00:36:57.580
对两个Graul本身，然后

00:36:54.280 --> 00:37:00.850
将其捆绑到热点VM中

00:36:57.580 --> 00:37:03.940
尝试该代码，看看它如何进行

00:37:00.850 --> 00:37:05.710
那不是为什么你不只是使用Gras 

00:37:03.940 --> 00:37:07.210
而不是c2就是其中之一

00:37:05.710 --> 00:37:09.610
这是一个多年的问题

00:37:07.210 --> 00:37:13.690
十年接班的大部分时间

00:37:09.610 --> 00:37:15.660
问题有点像模块，是的

00:37:13.690 --> 00:37:18.280
我们可以用六个月的节奏来做到这一点

00:37:15.660 --> 00:37:20.590
一点一点地与

00:37:18.280 --> 00:37:22.390
长期运行的项目，但在任何情况下

00:37:20.590 --> 00:37:25.990
案例我希望能到达那里

00:37:22.390 --> 00:37:28.570
回答问题更灵活

00:37:25.990 --> 00:37:30.790
流畅的代码库，更易于使用

00:37:28.570 --> 00:37:36.540
越小越轻

00:37:30.790 --> 00:37:39.700
比当前的C ++ C节点更现代

00:37:36.540 --> 00:37:41.680
我们现在拥有的编译器数字

00:37:39.700 --> 00:37:45.250
这将是基于Java的C节点

00:37:41.680 --> 00:37:47.260
具有刷新的设计和

00:37:45.250 --> 00:37:49.570
我们发现，如果您

00:37:47.260 --> 00:37:52.030
使用基于Java的Gras 

00:37:49.570 --> 00:37:53.500
您知道带有注释的Java程序

00:37:52.030 --> 00:37:55.480
和其中的现代东西

00:37:53.500 --> 00:37:58.480
特别是当Brian添加新的现代和

00:37:55.480 --> 00:38:00.880
语言的东西会更多

00:37:58.480 --> 00:38:03.760
令人愉快的，因此更快更安全

00:38:00.880 --> 00:38:05.920
来添加新的优化

00:38:03.760 --> 00:38:08.320
 Java on Java策略就是这样

00:38:05.920 --> 00:38:10.240
大都市即将来临

00:38:08.320 --> 00:38:13.990
从邮件列表中知道我们只是

00:38:10.240 --> 00:38:15.730
开始启动它好了

00:38:13.990 --> 00:38:19.980
没有问过任何问题的人

00:38:15.730 --> 00:38:19.980
麦克风正在缓慢移动，抱歉

00:38:20.380 --> 00:38:28.880
因为因为Java 9使用G 

00:38:25.600 --> 00:38:32.270
内存和处理器直接是

00:38:28.880 --> 00:38:37.460
程序员可能会破解或

00:38:32.270 --> 00:38:40.460
抱歉，在GDK 9中读取了哪些病毒

00:38:37.460 --> 00:38:41.480
我不能讲那个话

00:38:40.460 --> 00:38:45.610
可能慢一点哦

00:38:41.480 --> 00:38:48.920
因为JDK 1989我们可以使用内存

00:38:45.610 --> 00:38:51.830
直接访问或访问处理器，以及

00:38:48.920 --> 00:38:53.720
意外的记忆是这样

00:38:51.830 --> 00:38:58.670
程序员可以创建的

00:38:53.720 --> 00:39:01.670
病毒或此类物品，您可以

00:38:58.670 --> 00:39:05.060
创建病毒9，因为它正在使用

00:39:01.670 --> 00:39:06.950
通过直接内存直接访问内存

00:39:05.060 --> 00:39:08.600
您如何看待这个过程

00:39:06.950 --> 00:39:10.190
您的美国操作系统的边界不起作用我

00:39:08.600 --> 00:39:11.480
假设你可以对不起你

00:39:10.190 --> 00:39:15.890
认为您将与直接内存访问抗争

00:39:11.480 --> 00:39:19.690
那是因为我学到了

00:39:15.890 --> 00:39:25.190
听着它正在使用处理

00:39:19.690 --> 00:39:26.630
 CPU直接在以前的讲座中有什么

00:39:25.190 --> 00:39:30.800
那堂课的名字是你吗

00:39:26.630 --> 00:39:37.910
想着向量的句柄和

00:39:30.800 --> 00:39:40.310
向量正确，所以做旧的方法

00:39:37.910 --> 00:39:43.010
向量正在编写汇编代码

00:39:40.310 --> 00:39:46.070
在原子陈述或你知道的

00:39:43.010 --> 00:39:49.220
点的文件，或者是否有GCC 

00:39:46.070 --> 00:39:51.680
您可以使用的工具有一些

00:39:49.220 --> 00:39:53.900
内在的罪过

00:39:51.680 --> 00:39:55.400
 CC编译器，可让您进行编程

00:39:53.900 --> 00:39:56.930
一些矢量说明和加号

00:39:55.400 --> 00:40:00.620
有一个完整的头文件

00:39:56.930 --> 00:40:03.050
内部函数，所以我们正在做类似的事情

00:40:00.620 --> 00:40:05.930
那但它具有Java属性

00:40:03.050 --> 00:40:08.750
安全性和完整性兼容性等

00:40:05.930 --> 00:40:11.410
忘记了你的一个标记，然后但是

00:40:08.750 --> 00:40:14.480
 Java vector API可以让您

00:40:11.410 --> 00:40:16.910
编写矢量添加指令的代码，就像

00:40:14.480 --> 00:40:19.040
今天，您可以使用Java编写代码

00:40:16.910 --> 00:40:22.100
整数加法指令是加号

00:40:19.040 --> 00:40:25.660
签署什么Java不会让你做什么

00:40:22.100 --> 00:40:28.420
要做的是检查边界

00:40:25.660 --> 00:40:30.790
使您可以缓冲的省略

00:40:28.420 --> 00:40:32.980
溢出它不会让你跳入

00:40:30.790 --> 00:40:35.490
数据缓冲区有一大堆

00:40:32.980 --> 00:40:38.500
您可以轻松进行的安全操作

00:40:35.490 --> 00:40:40.720
在Java中，您可以轻松覆盖

00:40:38.500 --> 00:40:42.430
即使在偶然的情况下，它们也会以C语言出现

00:40:40.720 --> 00:40:47.920
永远无法在Java中覆盖它们

00:40:42.430 --> 00:40:49.660
除非你使用不安全的东西

00:40:47.920 --> 00:40:50.800
除非你是一个实施者，除非

00:40:49.660 --> 00:40:52.600
你是下层的实施者

00:40:50.800 --> 00:40:54.220
栈的每一层，你愿意

00:40:52.600 --> 00:40:56.350
采取他们的采取

00:40:54.220 --> 00:40:56.860
承担责任，但大多数人不承担责任

00:40:56.350 --> 00:40:59.680
需要它

00:40:56.860 --> 00:41:01.000
而在C语言中，即使是写作

00:40:59.680 --> 00:41:03.550
你好，世界承担责任

00:41:01.000 --> 00:41:05.170
避免缓冲区溢出或代码

00:41:03.550 --> 00:41:08.890
在缓冲区之类的地方执行

00:41:05.170 --> 00:41:11.970
像那样好，还有另一个

00:41:08.890 --> 00:41:11.970
在这里提问

00:41:15.589 --> 00:41:23.779
我可以问我一个问题还是我应该感到

00:41:21.859 --> 00:41:25.549
有空的话可以随意向我扔东西

00:41:23.779 --> 00:41:29.329
愚蠢的问题，但你支持

00:41:25.549 --> 00:41:32.930
模块模块的模块化版本控制

00:41:29.329 --> 00:41:39.259
看着那是一个标记

00:41:32.930 --> 00:41:42.469
不用了，谢谢，没有模块

00:41:39.259 --> 00:41:44.209
模块是我们已知的构造

00:41:42.469 --> 00:41:45.410
 VM中的语言不是工件

00:41:44.209 --> 00:41:48.380
保持区别很重要

00:41:45.410 --> 00:41:49.880
直接在一个你知道罐子的模块上

00:41:48.380 --> 00:41:53.839
文件是一个工件，它可以定义一个

00:41:49.880 --> 00:41:55.699
是否使用模块，但模块是一种

00:41:53.839 --> 00:41:58.249
更高层次的抽象事物

00:41:55.699 --> 00:42:01.279
不是版本号，这是

00:41:58.249 --> 00:42:04.099
我意识到的一个故意的设计决定

00:42:01.279 --> 00:42:05.329
是的，我们知道，我们非常了解

00:42:04.099 --> 00:42:07.819
好吧，这有点违反直觉

00:42:05.329 --> 00:42:09.559
因为人们希望所有模块都消失

00:42:07.819 --> 00:42:11.660
版本号并不意味着有一天

00:42:09.559 --> 00:42:13.819
他们不会，但我认为他们是一群

00:42:11.660 --> 00:42:15.890
技术原因的原因

00:42:13.819 --> 00:42:23.569
可能永远不会是一个好主意

00:42:15.890 --> 00:42:25.459
认为我们首先简单是好的，所以我

00:42:23.569 --> 00:42:27.709
在Twitter上问了这个，但我可以问

00:42:25.459 --> 00:42:29.179
现在面对面，所以有很多

00:42:27.709 --> 00:42:31.609
语言和许多语言功能

00:42:29.179 --> 00:42:33.140
在那里，你可以从我那里汲取灵感

00:42:31.609 --> 00:42:35.630
显然无法吸收一切

00:42:33.140 --> 00:42:37.819
在厨房的水槽里，你如何决定

00:42:35.630 --> 00:42:38.989
什么适合Java并拥有

00:42:37.819 --> 00:42:40.429
曾经有过任何想法

00:42:38.989 --> 00:42:44.569
在思想上认为很好

00:42:40.429 --> 00:42:46.729
不适合Java 

00:42:44.569 --> 00:42:48.469
一个答案很容易，默认

00:42:46.729 --> 00:42:54.799
为什么不添加的答案

00:42:48.469 --> 00:42:58.130
问题是不是很好，这不是

00:42:54.799 --> 00:42:59.869
广泛的答案，但我的意思是

00:42:58.130 --> 00:43:02.749
确实不是从来没有一个目标

00:42:59.869 --> 00:43:04.309
这是一种反抗的对比

00:43:02.749 --> 00:43:05.779
添加所有酷炫的目标不是目标

00:43:04.309 --> 00:43:07.789
语言，如果您尝试不，那不是

00:43:05.779 --> 00:43:09.469
你在问什么，但你知道

00:43:07.789 --> 00:43:11.779
我们经常收到以下形式的反馈

00:43:09.469 --> 00:43:13.339
哦，你知道X语言很酷

00:43:11.779 --> 00:43:16.279
精选为什么为什么不为什么不只是

00:43:13.339 --> 00:43:18.349
加进去，答案是布莱恩

00:43:16.279 --> 00:43:20.150
将能够发泄的能力

00:43:18.349 --> 00:43:21.380
比我知道的要长得多

00:43:20.150 --> 00:43:22.789
答案是他是你知道为什么不

00:43:21.380 --> 00:43:25.279
你就是

00:43:22.789 --> 00:43:26.779
开始长期调查

00:43:25.279 --> 00:43:28.099
它如何与其他一切相适应

00:43:26.779 --> 00:43:30.890
实际上是真正需要的东西

00:43:28.099 --> 00:43:33.410
每个人都需要的，如果我们这样做

00:43:30.890 --> 00:43:35.239
现在它将阻止我们什么功能

00:43:33.410 --> 00:43:38.959
以后因为

00:43:35.239 --> 00:43:41.329
兼容性，所以Brian您想知道为什么

00:43:38.959 --> 00:43:44.029
我们不是真的有选择吗

00:43:41.329 --> 00:43:46.489
我们慢慢地逐一沉淀特征

00:43:44.029 --> 00:43:48.439
进入我们的系统

00:43:46.489 --> 00:43:49.819
我们有韦勒特，我们学不到很多

00:43:48.439 --> 00:43:52.549
从别人那里我是说Scala 

00:43:49.819 --> 00:43:53.689
真实的信息字体，是的

00:43:52.549 --> 00:43:54.109
那是个好主意

00:43:53.689 --> 00:43:57.619
出来吧

00:43:54.109 --> 00:44:00.589
是的，这里还有另一个

00:43:57.619 --> 00:44:02.719
所以他们你知道我们不可能做

00:44:00.589 --> 00:44:04.009
所有的语言功能，甚至

00:44:02.719 --> 00:44:05.359
那些看起来不错的主意

00:44:04.009 --> 00:44:07.609
对，所以他们很多看起来就像

00:44:05.359 --> 00:44:09.890
坏主意或好主意

00:44:07.609 --> 00:44:12.229
首先，直到您对它们进行挖掘

00:44:09.890 --> 00:44:15.380
然后剩下一个列表， 

00:44:12.229 --> 00:44:17.449
没什么可怕的想法，我们

00:44:15.380 --> 00:44:19.819
只会实施其中的1％ 

00:44:17.449 --> 00:44:22.759
也许，所以我们必须选择

00:44:19.819 --> 00:44:25.369
非常小心，这不像我们有

00:44:22.759 --> 00:44:27.409
详细的科学过程是

00:44:25.369 --> 00:44:28.880
我们看起来很主观的东西

00:44:27.409 --> 00:44:31.429
你知道我们看着候选人，我们

00:44:28.880 --> 00:44:34.729
说什么是什么

00:44:31.429 --> 00:44:36.709
这里的推重比正确

00:44:34.729 --> 00:44:39.559
这是什么，它阻止了什么

00:44:36.709 --> 00:44:41.269
它启用了它鼓励什么以及如何

00:44:39.559 --> 00:44:44.150
与我们相比，这值得多少

00:44:41.269 --> 00:44:46.939
有限的预算增加了复杂性

00:44:44.150 --> 00:44:50.630
语言，再一次

00:44:46.939 --> 00:44:53.119
主观你知道，但我们尝试我们尝试

00:44:50.630 --> 00:44:54.650
添加有基础的东西

00:44:53.119 --> 00:44:58.819
现有概念，而不是添加新概念

00:44:54.650 --> 00:45:00.919
我们尝试让您知道的概念会增加一些东西

00:44:58.819 --> 00:45:02.449
具有明显的杠杆作用

00:45:00.919 --> 00:45:04.459
诸如lambda之类的东西数量巨大

00:45:02.449 --> 00:45:06.019
的杠杆作用远不止您所知道的

00:45:04.459 --> 00:45:08.479
许多其他候选语言功能

00:45:06.019 --> 00:45:11.659
但最后这是一个相当主观的

00:45:08.479 --> 00:45:13.819
涉及说gee的过程

00:45:11.659 --> 00:45:15.079
听起来不错，但绝大部分都没有

00:45:13.819 --> 00:45:16.610
事情，这样当真正

00:45:15.079 --> 00:45:18.440
好的伴随着我们

00:45:16.610 --> 00:45:20.120
我有很长一段时间做这项工作的能力

00:45:18.440 --> 00:45:21.530
认为收集字面量有点

00:45:20.120 --> 00:45:24.260
毫无疑问，但最终我还是

00:45:21.530 --> 00:45:25.430
确信它是另外一个

00:45:24.260 --> 00:45:27.050
语言也许是个好主意

00:45:25.430 --> 00:45:29.210
有这么多的功能

00:45:27.050 --> 00:45:30.830
比这复杂得多

00:45:29.210 --> 00:45:32.600
他们看起来，然后就变成了

00:45:30.830 --> 00:45:33.860
我们有多复杂

00:45:32.600 --> 00:45:39.110
我们想在这方面花费预算吗

00:45:33.860 --> 00:45:40.670
与其他东西没关系我认为

00:45:39.110 --> 00:45:42.010
我们没时间了，非常感谢

00:45:40.670 --> 00:45:47.099
您的问题

00:45:42.010 --> 00:45:47.099
 [掌声] 

