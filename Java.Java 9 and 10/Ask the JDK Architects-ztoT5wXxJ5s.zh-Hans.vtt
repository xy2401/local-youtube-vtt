WEBVTT
Kind: captions
Language: zh-Hans

00:00:05.319 --> 00:00:10.920
下午好，欢迎问一下JDK 

00:00:10.219 --> 00:00:13.559
是

00:00:10.920 --> 00:00:16.080
我们在这里回答问题

00:00:13.559 --> 00:00:21.400
希望你在这里问问题

00:00:16.080 --> 00:00:23.200
如果不是，我们都可以离开，这是其中之一

00:00:21.400 --> 00:00:30.160
我所见过的最短的滑板

00:00:23.200 --> 00:00:33.579
创造了不相信我们说的一个字问

00:00:30.160 --> 00:00:35.320
询问您是害羞还是外出

00:00:33.579 --> 00:00:37.899
在互联网上观看

00:00:35.320 --> 00:00:41.020
您可以向我发送问题， 

00:00:37.899 --> 00:00:44.410
我将选择并阅读有限的数量

00:00:41.020 --> 00:00:46.060
他们中的谁，谁想先走，我知道

00:00:44.410 --> 00:00:47.290
顺便说一句，如果你在房间里

00:00:46.060 --> 00:00:48.850
为什么我们需要另一个麦克风

00:00:47.290 --> 00:00:50.440
如果你在房间里，请来

00:00:48.850 --> 00:00:53.050
在这里问你的问题，因为如果我们

00:00:50.440 --> 00:00:54.430
重复一遍，我们会扭曲它，那

00:00:53.050 --> 00:00:55.930
每个人都能听到你的声音的方式

00:00:54.430 --> 00:01:00.000
说我喜欢扭曲问题

00:00:55.930 --> 00:01:00.000
你能摧毁它好吗

00:01:06.250 --> 00:01:09.820
不，请过来这里

00:01:13.420 --> 00:01:19.040
所以我会参加会议

00:01:16.820 --> 00:01:20.750
在此之前有关拼图的会议

00:01:19.040 --> 00:01:23.450
我想知道我是否在做

00:01:20.750 --> 00:01:26.000
我要建立的客户的开发

00:01:23.450 --> 00:01:28.399
一些图书馆，我有你

00:01:26.000 --> 00:01:30.350
您的XML文件公开-私有

00:01:28.399 --> 00:01:33.830
现在他有拼图来了

00:01:30.350 --> 00:01:35.630
您实际上可以屏蔽掉

00:01:33.830 --> 00:01:39.710
实际上只是暴露了你的零件

00:01:35.630 --> 00:01:41.990
希望其他图书馆使用，如果我

00:01:39.710 --> 00:01:43.420
只是做我自己的图书馆或创建一个

00:01:41.990 --> 00:01:45.350
模块为什么我仍然想做

00:01:43.420 --> 00:01:46.880
私人的东西，而不仅仅是

00:01:45.350 --> 00:01:51.950
一切公开，然后将其屏蔽

00:01:46.880 --> 00:01:54.890
通过模块信息我很抱歉我没有

00:01:51.950 --> 00:01:56.929
跟随那个，如果我有图书馆的话

00:01:54.890 --> 00:01:58.909
我正在正确地创建一个模块

00:01:56.929 --> 00:02:00.350
有旧代码由我自己控制

00:01:58.909 --> 00:02:03.080
我为什么还要做东西

00:02:00.350 --> 00:02:04.850
私人的，因为我可以屏蔽包裹

00:02:03.080 --> 00:02:06.830
我不希望其他人使用

00:02:04.850 --> 00:02:10.429
您是唯一可以工作的开发人员

00:02:06.830 --> 00:02:13.790
在此代码上，您是否相信自己两个

00:02:10.429 --> 00:02:15.739
从现在开始的几年以后

00:02:13.790 --> 00:02:17.690
不要相信两年前的自己

00:02:15.739 --> 00:02:20.720
从现在起两年后

00:02:17.690 --> 00:02:22.190
如果您控制所有代码，那么

00:02:20.720 --> 00:02:25.519
是的，也许您不需要做任何事情

00:02:22.190 --> 00:02:27.620
好的，但是你知道的越多越好

00:02:25.519 --> 00:02:30.320
开发人员是否参与其中

00:02:27.620 --> 00:02:33.200
在欧洲有人自己的组织

00:02:30.320 --> 00:02:36.620
或有人维护一些开源

00:02:33.200 --> 00:02:38.900
你赖以生存的东西

00:02:36.620 --> 00:02:40.970
风险更大，好吧，我有一个反问

00:02:38.900 --> 00:02:43.579
这个房间有多少人

00:02:40.970 --> 00:02:46.130
 Java程序员已经使用了

00:02:43.579 --> 00:02:52.220
私钥保护代码免受

00:02:46.130 --> 00:02:53.989
你自己，你明白了吗

00:02:52.220 --> 00:02:56.299
辅助功能修改器发送信号

00:02:53.989 --> 00:02:59.150
对，你知道他们发出一个关于

00:02:56.299 --> 00:03:00.920
这是否你知道服务

00:02:59.150 --> 00:03:02.600
与之紧邻的代码

00:03:00.920 --> 00:03:04.040
在稍大的圆圈内，或

00:03:02.600 --> 00:03:05.570
整个世界，很难保持

00:03:04.040 --> 00:03:09.890
那些在你的头上，这就是为什么我们把

00:03:05.570 --> 00:03:12.440
我忽略的代码中有它们

00:03:09.890 --> 00:03:15.950
我们自我介绍，但这可能是

00:03:12.440 --> 00:03:20.569
无论如何，我都会标记Reinhold 

00:03:15.950 --> 00:03:23.030
子弹枪并标记首长

00:03:20.569 --> 00:03:25.760
工程师，我是jvm架构师John rose 

00:03:23.030 --> 00:03:31.190
布莱恩（Brian）成为语言设计师，我们所有人

00:03:25.760 --> 00:03:35.120
为Oracle工作，在大多数情况下，我们

00:03:31.190 --> 00:03:38.000
信不信由你喜欢它哦民意调查

00:03:35.120 --> 00:03:41.300
询问有多少人下载了

00:03:38.000 --> 00:03:46.480
并与早期访问jdk一起玩

00:03:41.300 --> 00:03:46.480
九个已建立，您现有的代码是否起作用

00:03:46.540 --> 00:03:54.530
打破了吗打破了吗

00:03:49.850 --> 00:03:56.660
你猛烈地弄清楚了为什么问他

00:03:54.530 --> 00:03:58.760
是的，他们在那里，他们正在追赶

00:03:56.660 --> 00:04:00.260
瑞米（Remmy）已经建好了，但是

00:03:58.760 --> 00:04:02.180
赶上了多少人

00:04:00.260 --> 00:04:06.260
下载并玩拼图游戏

00:04:02.180 --> 00:04:09.110
抢先体验做了您现有的代码

00:04:06.260 --> 00:04:10.850
休息一下，您已经下载了

00:04:09.110 --> 00:04:13.430
最后两个内的拼图EA 

00:04:10.850 --> 00:04:19.040
个星期，因为可能更多

00:04:13.430 --> 00:04:23.479
您的代码不好意思，它正在转移

00:04:19.040 --> 00:04:25.820
地面出血边缘还有其他问题

00:04:23.479 --> 00:04:26.930
我们应该问我们不等我们

00:04:25.820 --> 00:04:28.190
应该回答他们，是的，我们只是

00:04:26.930 --> 00:04:29.540
在这里回答我们可以问的问题

00:04:28.190 --> 00:04:33.250
问题也是我的意思是如果没人去

00:04:29.540 --> 00:04:33.250
请问这里

00:04:37.980 --> 00:04:42.640
所以这意味着之前有一些讨论

00:04:40.630 --> 00:04:44.380
关于提前编译是一个

00:04:42.640 --> 00:04:46.360
吉利安性交的一部分是什么

00:04:44.380 --> 00:04:48.040
过去就像犯了老路

00:04:46.360 --> 00:04:51.610
他们处于什么样的状态

00:04:48.040 --> 00:04:54.100
时间编译现在我们有一个

00:04:51.610 --> 00:04:56.860
最后一对夫妇的项目

00:04:54.100 --> 00:05:00.160
提前几年编译我们

00:04:56.860 --> 00:05:03.280
使用Grall Gras核心

00:05:00.160 --> 00:05:07.840
开源产品作为项目

00:05:03.280 --> 00:05:13.420
基础，我们能够提前进行编译

00:05:07.840 --> 00:05:16.150
 Java基本模块的时间，您可能

00:05:13.420 --> 00:05:18.610
询问有什么好处，我们已经了解到

00:05:16.150 --> 00:05:20.020
在过去的几个月中， 

00:05:18.610 --> 00:05:22.090
重要的经验法则

00:05:20.020 --> 00:05:24.670
尝试过aot的人

00:05:22.090 --> 00:05:27.430
也发现了我的想法，那就是

00:05:24.670 --> 00:05:29.980
 OT给您几乎所有的好处

00:05:27.430 --> 00:05:33.880
在程序的前100毫秒

00:05:29.980 --> 00:05:37.180
执行，所以事实证明是

00:05:33.880 --> 00:05:39.160
很难找到

00:05:37.180 --> 00:05:42.670
击败在线准时的方法

00:05:39.160 --> 00:05:44.250
我认为可能有事情

00:05:42.670 --> 00:05:47.560
我们可以在那里做更多的事情，但是

00:05:44.250 --> 00:05:50.620
简单的aot基本上会刮胡子

00:05:47.560 --> 00:05:52.510
大约下降三分之一

00:05:50.620 --> 00:05:54.160
百分之一到三分之一

00:05:52.510 --> 00:05:57.190
执行的一百毫秒

00:05:54.160 --> 00:05:59.380
听起来很苍白，微弱， 

00:05:57.190 --> 00:06:01.180
也许那就是为什么你知道也许那是为什么

00:05:59.380 --> 00:06:04.480
为什么Java没有那样相处

00:06:01.180 --> 00:06:07.390
很久了，但我们认为它有一些

00:06:04.480 --> 00:06:08.980
未来的特殊用途

00:06:07.390 --> 00:06:11.560
我们所处的Java实现

00:06:08.980 --> 00:06:13.920
实际上是从旧技术

00:06:11.560 --> 00:06:17.110
自我引导系统的实验室

00:06:13.920 --> 00:06:19.480
在Java和Java之上实现Java 

00:06:17.110 --> 00:06:21.520
他们是一个要求，而不是

00:06:19.480 --> 00:06:23.050
很高兴有，这就是我们的

00:06:21.520 --> 00:06:24.910
这就是我们现在做OT的原因

00:06:23.050 --> 00:06:29.260
我们期待着一个

00:06:24.910 --> 00:06:32.710
最终要替换的项目

00:06:29.260 --> 00:06:35.920
合资公司J SJ的组件

00:06:32.710 --> 00:06:37.930
 jdk堆栈上使用java作为

00:06:35.920 --> 00:06:41.500
实现语言而不是c ++ 

00:06:37.930 --> 00:06:43.600
或汇编代码John说j2se他

00:06:41.500 --> 00:06:44.470
真的是Java SE的意思，谢谢，对不起

00:06:43.600 --> 00:06:47.170
和

00:06:44.470 --> 00:06:49.570
而且您知道将静态与

00:06:47.170 --> 00:06:52.060
动态编译的人很多

00:06:49.570 --> 00:06:53.470
假设提前做好编译是

00:06:52.060 --> 00:06:55.360
更好，因为您没有这样做

00:06:53.470 --> 00:06:57.090
在运行时进行额外的工作，但实际上

00:06:55.360 --> 00:07:00.250
像其他一切一样，这是一个权衡

00:06:57.090 --> 00:07:02.920
所以你在权衡编译

00:07:00.250 --> 00:07:05.320
相对于编译时间的质量

00:07:02.920 --> 00:07:07.420
运行时，因此动态编译器将始终

00:07:05.320 --> 00:07:08.500
在静态方面胜过静态编译器

00:07:07.420 --> 00:07:10.210
他们生成的代码的质量

00:07:08.500 --> 00:07:11.260
因为他们有更多的信息

00:07:10.210 --> 00:07:15.520
可以进行更好的优化

00:07:11.260 --> 00:07:18.300
决定，所以您了解很多

00:07:15.520 --> 00:07:20.620
以前的ot编译尝试

00:07:18.300 --> 00:07:22.750
人们总是失望的

00:07:20.620 --> 00:07:25.000
 aot编译的代码比

00:07:22.750 --> 00:07:27.340
动态生成的代码就在您身上

00:07:25.000 --> 00:07:30.040
更快达到最佳性能，因此

00:07:27.340 --> 00:07:33.580
 OT实际上主要是初创公司， 

00:07:30.040 --> 00:07:36.970
您知道运行的程序

00:07:33.580 --> 00:07:40.240
只要几秒钟，你就知道不是

00:07:36.970 --> 00:07:43.210
实际上相关，如果你想

00:07:40.240 --> 00:07:45.669
编写一个启动的小程序

00:07:43.210 --> 00:07:48.130
触发一些数据包然后关闭

00:07:45.669 --> 00:07:50.200
下来，您今天可能会使用其他语言

00:07:48.130 --> 00:07:52.660
为此，但我们希望最终

00:07:50.200 --> 00:07:54.960
随着OT变得成熟，我们将

00:07:52.660 --> 00:07:58.540
能够在其中编写类似的组件

00:07:54.960 --> 00:07:59.860
你知道在Java中有

00:07:58.540 --> 00:08:02.380
早期迹象表明那是相当

00:07:59.860 --> 00:08:04.900
实用，因为你们中有些人可能

00:08:02.380 --> 00:08:08.080
看了一些人的演讲

00:08:04.900 --> 00:08:10.570
在诸如

00:08:08.080 --> 00:08:12.580
能够收缩的基材vm 

00:08:10.570 --> 00:08:15.880
你好世界级的工作程序

00:08:12.580 --> 00:08:17.530
像海一样小成一捆

00:08:15.880 --> 00:08:19.690
程序可以启动到

00:08:17.530 --> 00:08:21.669
像海上程序一样快，所以没有

00:08:19.690 --> 00:08:23.140
有一种极端的

00:08:21.669 --> 00:08:27.070
您可以在数百中完成的工作

00:08:23.140 --> 00:08:28.330
毫秒x时间刻度，所以我认为

00:08:27.070 --> 00:08:29.890
我们最终将到达那里

00:08:28.330 --> 00:08:31.840
但是我们你知道我们只是在服用

00:08:29.890 --> 00:08:33.280
宝宝现在就走到

00:08:31.840 --> 00:08:35.229
产品有关，但实验室

00:08:33.280 --> 00:08:37.300
实验看起来很有希望，我们

00:08:35.229 --> 00:08:39.370
期望在明年内有一些

00:08:37.300 --> 00:08:41.610
一些开源活动

00:08:39.370 --> 00:08:41.610
线

00:08:44.060 --> 00:08:48.050
对于不安全的API，例如我们不

00:08:46.640 --> 00:08:49.760
想要使用了，通常会很好

00:08:48.050 --> 00:08:51.560
替代那些没有的

00:08:49.760 --> 00:08:54.320
计划进行任何替换，直到哦

00:08:51.560 --> 00:08:57.200
像儿子一样发信号，为什么不让

00:08:54.320 --> 00:08:59.480
那些进入api并祝福他们

00:08:57.200 --> 00:09:02.480
可以使用或者我们可以

00:08:59.480 --> 00:09:04.520
更换它们的时间表

00:09:02.480 --> 00:09:10.339
奠定了这一一般哲学

00:09:04.520 --> 00:09:11.779
在JEP 260中，您知道我们是我们

00:09:10.339 --> 00:09:13.610
逐步提供标准

00:09:11.779 --> 00:09:15.650
大部分功能

00:09:13.610 --> 00:09:18.080
 Sun杂项软件包和其他不支持的软件包

00:09:15.650 --> 00:09:19.640
保罗正确处理的事情

00:09:18.080 --> 00:09:22.850
山德士正坐在后面

00:09:19.640 --> 00:09:24.860
处理并处理许多这样的事情

00:09:22.850 --> 00:09:27.470
情况，但我们知道有很多

00:09:24.860 --> 00:09:29.779
关键api之类的东西已经消失了

00:09:27.470 --> 00:09:31.370
如果很多人甚至依靠

00:09:29.779 --> 00:09:33.500
尽管他们在技术上不支持

00:09:31.370 --> 00:09:35.000
所以他们会一直在那里直到

00:09:33.500 --> 00:09:37.700
替换，然后他们会坚持

00:09:35.000 --> 00:09:41.440
直到至少一个主要版本

00:09:37.700 --> 00:09:41.440
这些替换存在之后

00:09:41.740 --> 00:09:46.640
我认为来自Twitter的问题

00:09:45.080 --> 00:09:49.850
这对布莱恩来说是什么机会

00:09:46.640 --> 00:09:52.850
的Jeff 286是局部变量类型

00:09:49.850 --> 00:09:59.930
推断使其进入我附近的JVM 

00:09:52.850 --> 00:10:04.220
很快，这很快意味着是的，这是我的

00:09:59.930 --> 00:10:09.500
问题，如果这是JD犬的代码

00:10:04.220 --> 00:10:11.330
机会永远是零

00:10:09.500 --> 00:10:14.780
奈计划的一部分，尽管

00:10:11.330 --> 00:10:17.510
今天在服务器端的文章

00:10:14.780 --> 00:10:19.370
声称是这样，尽管事实

00:10:17.510 --> 00:10:23.510
我们在主题演讲中说

00:10:19.370 --> 00:10:26.390
时代不是49，但不是

00:10:23.510 --> 00:10:28.220
世界上最大的功能，因此使用

00:10:26.390 --> 00:10:30.020
判断结果不是九点

00:10:28.220 --> 00:10:32.030
但是你可以考虑的并不多

00:10:30.020 --> 00:10:33.709
这可能意味着什么

00:10:32.030 --> 00:10:35.209
很少会发布

00:10:33.709 --> 00:10:41.740
下午与它与救济

00:10:35.209 --> 00:10:41.740
数字可能大于九

00:10:42.549 --> 00:10:48.619
如果您可以将答案限制在

00:10:45.739 --> 00:10:50.660
 Java或Oracle业务和技术

00:10:48.619 --> 00:10:54.129
这个问题的空间，但保持不变

00:10:50.660 --> 00:10:54.129
你们现在晚上都醒着

00:10:55.600 --> 00:11:03.339
我不会对任何评论

00:10:58.129 --> 00:11:03.339
可能让我醒着的商业事物

00:11:05.949 --> 00:11:13.160
是什么让我上班

00:11:09.079 --> 00:11:17.179
那事实是我们有

00:11:13.160 --> 00:11:21.730
一个极其活跃的生态系统

00:11:17.179 --> 00:11:25.129
它是由像我们这样的书呆子建造的

00:11:21.730 --> 00:11:27.439
那占了很大一部分

00:11:25.129 --> 00:11:30.739
世界的计算，而宁愿这样做

00:11:27.439 --> 00:11:33.350
好，还有改进的空间

00:11:30.739 --> 00:11:35.329
和改进看起来像他们

00:11:33.350 --> 00:11:36.920
不仅会很漂亮

00:11:35.329 --> 00:11:40.429
满意的工作，但也

00:11:36.920 --> 00:11:43.569
令人难以置信的生产力，是什么让我

00:11:40.429 --> 00:11:46.939
 Java的未来20年

00:11:43.569 --> 00:11:48.739
花花公子哦，是的，然后放大我

00:11:46.939 --> 00:11:52.009
会说长期的道路

00:11:48.739 --> 00:11:53.600
集合的集合的地图

00:11:52.009 --> 00:11:55.850
明智的改进和增强

00:11:53.600 --> 00:11:57.649
我们现在可以预见并有一个

00:11:55.850 --> 00:12:00.679
如何做的很好的主意

00:11:57.649 --> 00:12:03.489
只是引用一个工程问题是

00:12:00.679 --> 00:12:03.489
比以往任何时候都更好

00:12:08.530 --> 00:12:15.110
这是一个特定的问题，但是

00:12:12.740 --> 00:12:19.210
减慢我们速度的事情之一

00:12:15.110 --> 00:12:23.360
充满活力的Java生态系统是数字

00:12:19.210 --> 00:12:29.240
称为RSASS和PSS的签名算法

00:12:23.360 --> 00:12:32.240
因此在Java 8中，我们最近升级到了

00:12:29.240 --> 00:12:35.990
我认为最新最好的Java 8 

00:12:32.240 --> 00:12:41.540
更新66，我认为这需要

00:12:35.990 --> 00:12:43.820
使用TLS 12时需要验证

00:12:41.540 --> 00:12:46.490
没有验证，我想知道是否

00:12:43.820 --> 00:12:49.940
有任何支持的计划

00:12:46.490 --> 00:12:55.130
算法，这是微软的默认pki 

00:12:49.940 --> 00:12:58.130
证书算法哦，这是一个很好的你

00:12:55.130 --> 00:12:59.450
绊倒了面板先生，哇，是

00:12:58.130 --> 00:13:02.450
这是一个算法

00:12:59.450 --> 00:13:04.850
已经支持不支持添加

00:13:02.450 --> 00:13:06.620
在这八次更新中， 

00:13:04.850 --> 00:13:11.300
在某些Java中被提及

00:13:06.620 --> 00:13:15.980
文档中有一个openjdk 

00:13:11.300 --> 00:13:22.820
那里有一张票80丹麦克朗

00:13:15.980 --> 00:13:26.930
 146293哦，是的，但是为什么

00:13:22.820 --> 00:13:28.460
你不是说不是

00:13:26.930 --> 00:13:30.560
意味着除非有一些

00:13:28.460 --> 00:13:34.820
这些谷歌搜索那里额外

00:13:30.560 --> 00:13:38.150
信息，但还不清楚

00:13:34.820 --> 00:13:40.490
 jdk 9是否会提供支持

00:13:38.150 --> 00:13:46.370
或曾经有来自

00:13:40.490 --> 00:13:48.260
安全小组在这里Jeanette Sean yeah 

00:13:46.370 --> 00:13:50.030
您想要找到Sean Mullan或Joe或

00:13:48.260 --> 00:13:52.850
珍妮特·洪（Jeanette hun）可能会回答

00:13:50.030 --> 00:13:56.410
这个问题或安全开发人员的安全性

00:13:52.850 --> 00:13:56.410
德文郡好的好的谢谢

00:13:59.110 --> 00:14:04.390
奇怪的连接但不是

00:14:01.970 --> 00:14:08.829
因为安全，但是因为

00:14:04.390 --> 00:14:14.120
现在发布的功能

00:14:08.829 --> 00:14:17.300
拼图和更模块化的JDK 

00:14:14.120 --> 00:14:22.790
释放频率更高的可能性

00:14:17.300 --> 00:14:27.800
模块中功能的周期

00:14:22.790 --> 00:14:30.680
很有意思的问题

00:14:27.800 --> 00:14:34.640
所以我们的主要原因之一

00:14:30.680 --> 00:14:37.670
模块化JDK所在的平台

00:14:34.640 --> 00:14:40.760
事实使它更容易发展，但是

00:14:37.670 --> 00:14:44.290
保持不断向前发展

00:14:40.760 --> 00:14:47.089
可能再也想不到

00:14:44.290 --> 00:14:49.160
我们不会在附近预见到任何时间

00:14:47.089 --> 00:14:51.470
未来会有某种混搭

00:14:49.160 --> 00:14:55.519
可以作为基础的模块

00:14:51.470 --> 00:14:59.690
 JDK 9.1中的模块并将其与您的

00:14:55.519 --> 00:15:02.750
 JDK 9.4和更高版本的HTTP客户端模块

00:14:59.690 --> 00:15:06.260
从jdk投入几个10个模块

00:15:02.750 --> 00:15:08.089
 10变成了噩梦，但

00:15:06.260 --> 00:15:09.709
绝对模块化平台

00:15:08.089 --> 00:15:13.339
如果要从那碗意大利面去

00:15:09.709 --> 00:15:15.980
您已经看到了丑陋的图表

00:15:13.339 --> 00:15:17.930
完全相同的模型图使得

00:15:15.980 --> 00:15:19.430
我们可以进一步发展的平台

00:15:17.930 --> 00:15:21.620
快速，因为组件是

00:15:19.430 --> 00:15:25.420
实际确定和独立

00:15:21.620 --> 00:15:25.420
互相保护

00:15:30.579 --> 00:15:34.910
嗨，我的公司可能是

00:15:33.440 --> 00:15:39.829
刻在我的背上

00:15:34.910 --> 00:15:43.660
 T恤当然有Java代理了

00:15:39.829 --> 00:15:47.870
我们的Java业务所依赖的

00:15:43.660 --> 00:15:49.430
出现可靠性问题是因为

00:15:47.870 --> 00:15:51.829
我们转变的时间点

00:15:49.430 --> 00:15:54.019
我们真的只想转换的类

00:15:51.829 --> 00:15:57.889
字节码，但我们发现自己很纠结

00:15:54.019 --> 00:16:00.139
在上课的中间，因为

00:15:57.889 --> 00:16:01.759
这就是检测API的方式

00:16:00.139 --> 00:16:05.149
目前已实施

00:16:01.759 --> 00:16:08.209
拦截类负载还有另一个

00:16:05.149 --> 00:16:10.130
做类似的框架

00:16:08.209 --> 00:16:11.690
东西，但仪器接口

00:16:10.130 --> 00:16:15.889
实际上是即时的

00:16:11.690 --> 00:16:18.079
所以它实际上不是

00:16:15.889 --> 00:16:19.550
字节码转换实际上不是

00:16:18.079 --> 00:16:21.500
在别人的中间做

00:16:19.550 --> 00:16:24.170
已经解决的类负载

00:16:21.500 --> 00:16:27.560
在稍后之前完成

00:16:24.170 --> 00:16:29.000
准时实际执行可以吗

00:16:27.560 --> 00:16:31.699
命名其他框架工人是

00:16:29.000 --> 00:16:32.959
 Lucille是的，他们得到的积分

00:16:31.699 --> 00:16:35.569
超出框架的范围

00:16:32.959 --> 00:16:36.829
不同的黑色作品好，所以谢谢

00:16:35.569 --> 00:16:39.410
你说得对，所以你的意思是

00:16:36.829 --> 00:16:42.170
以我还没有的方式运行

00:16:39.410 --> 00:16:44.930
看着我不是故意

00:16:42.170 --> 00:16:46.670
无论如何，在某些情况下它要简单一些

00:16:44.930 --> 00:16:48.199
尊重，因为他们不在中间

00:16:46.670 --> 00:16:50.240
他们做的时候

00:16:48.199 --> 00:16:51.560
字节码转换，所以他们

00:16:50.240 --> 00:16:53.569
无法陷入僵局

00:16:51.560 --> 00:16:55.339
客户写得不好的情况

00:16:53.569 --> 00:16:57.860
定制类加载器等等

00:16:55.339 --> 00:17:00.170
来了，我的问题是

00:16:57.860 --> 00:17:03.019
有可能发展

00:17:00.170 --> 00:17:06.169
工具API 

00:17:03.019 --> 00:17:08.539
减少这种可能性

00:17:06.169 --> 00:17:10.959
非常偶然的非常专业的问题

00:17:08.539 --> 00:17:17.179
我们看到可靠性的长尾巴

00:17:10.959 --> 00:17:19.610
问题，嗯，好问题，嗯，我不

00:17:17.179 --> 00:17:21.650
认为任何人都有

00:17:19.610 --> 00:17:24.500
关于改进该API的深入思考

00:17:21.650 --> 00:17:28.220
最近我在想

00:17:24.500 --> 00:17:30.860
 j-link是第11个答案

00:17:28.220 --> 00:17:35.210
出现的工具之一

00:17:30.860 --> 00:17:38.179
 JD canine和模块化是一个链接

00:17:35.210 --> 00:17:40.309
时间步长，从历史上看，您可以编译

00:17:38.179 --> 00:17:42.070
 Java源代码转换为Java字节码和

00:17:40.309 --> 00:17:45.200
然后所有链接都在运行时发生

00:17:42.070 --> 00:17:46.610
而且有很多操作

00:17:45.200 --> 00:17:48.380
也有一些优化

00:17:46.610 --> 00:17:50.180
尽早在编译时和

00:17:48.380 --> 00:17:53.510
你指出或有点晚

00:17:50.180 --> 00:17:55.190
因为Java 

00:17:53.510 --> 00:17:57.470
历史上没有链接时间

00:17:55.190 --> 00:18:00.470
那让你有点了解

00:17:57.470 --> 00:18:03.530
边缘局势，所以Jay Link是一个工具

00:18:00.470 --> 00:18:06.920
处理类文件，jar文件等

00:18:03.530 --> 00:18:10.070
构建后，您知道但运行时之前

00:18:06.920 --> 00:18:11.990
我们使用J链接来做各种

00:18:10.070 --> 00:18:14.720
产生自定义图像以剥离的东西

00:18:11.990 --> 00:18:17.540
调试符号以执行字节码

00:18:14.720 --> 00:18:20.080
优化让您知道反思

00:18:17.540 --> 00:18:24.520
抬头看着你知道静态你知道

00:18:20.080 --> 00:18:26.780
静态引用和

00:18:24.520 --> 00:18:29.590
咬你想要的好仪器

00:18:26.780 --> 00:18:31.850
这样做似乎很理想

00:18:29.590 --> 00:18:33.530
监狱公司的应用程序具有

00:18:31.850 --> 00:18:36.800
插件架构，因此您可以定义

00:18:33.530 --> 00:18:39.680
您知道的j-link转换以及

00:18:36.800 --> 00:18:41.780
这样一来，一旦离线

00:18:39.680 --> 00:18:43.880
建立时间，然后当自行车代码

00:18:41.780 --> 00:18:48.530
被加载到vm中就完成了

00:18:43.880 --> 00:18:51.020
准备好了，是的，好吧，有一个

00:18:48.530 --> 00:18:54.530
尽管杰伊链接仅适用于

00:18:51.020 --> 00:18:57.260
显式模块（如果您有一堆） 

00:18:54.530 --> 00:18:58.910
今天你在类路径上的jar文件

00:18:57.260 --> 00:19:00.200
可能会应用类似的策略

00:18:58.910 --> 00:19:03.680
也许并且也许提前重写它们

00:19:00.200 --> 00:19:06.020
时间，但周杰伦链接不能做不到

00:19:03.680 --> 00:19:13.340
链接只是随机的jar文件，因为

00:19:06.020 --> 00:19:15.410
是的，是的，但是你知道

00:19:13.340 --> 00:19:18.350
 5-10年的时间可能适用于很多

00:19:15.410 --> 00:19:21.620
代码，因此大量遗留代码可以运行

00:19:18.350 --> 00:19:25.310
在大型递归类加载器中

00:19:21.620 --> 00:19:27.890
在假期里，你的部分问题是

00:19:25.310 --> 00:19:29.840
它的遗产，但当然是

00:19:27.890 --> 00:19:33.710
您的增值之处在于您在工作

00:19:29.840 --> 00:19:36.350
传统，所以没有简单的答案，我会

00:19:33.710 --> 00:19:38.690
说Java确实没有

00:19:36.350 --> 00:19:41.620
 clr的即时方式

00:19:38.690 --> 00:19:44.300
因为他们有一个热身期

00:19:41.620 --> 00:19:45.680
可能在口译员中，所以您已经

00:19:44.300 --> 00:19:49.900
必须捕获字节码

00:19:45.680 --> 00:19:52.160
提早但我认为正确的答案

00:19:49.900 --> 00:19:54.470
长期来看

00:19:52.160 --> 00:19:55.580
建筑的正确答案是要做

00:19:54.470 --> 00:19:58.520
这些转移

00:19:55.580 --> 00:20:01.100
早些而不是晚些再做

00:19:58.520 --> 00:20:02.960
他们在一个静态的设置，那就是

00:20:01.100 --> 00:20:04.880
为什么我们是那的好处之一

00:20:02.960 --> 00:20:07.310
使用杰伊·林肯模块和

00:20:04.880 --> 00:20:09.650
甚至还有其他一些功能

00:20:07.310 --> 00:20:13.340
就像班级数据共享旨在

00:20:09.650 --> 00:20:16.730
能够移动更多种类的Java 

00:20:13.340 --> 00:20:20.360
将应用程序代码供应到

00:20:16.730 --> 00:20:23.870
在启动之前，那就是

00:20:20.360 --> 00:20:25.580
那是我们看到改进的地方

00:20:23.870 --> 00:20:28.370
而不是调整

00:20:25.580 --> 00:20:30.710
仪器或代理商的东西

00:20:28.370 --> 00:20:32.360
添加更多功能来执行此类操作

00:20:30.710 --> 00:20:34.550
监狱angkat中的静态事物

00:20:32.360 --> 00:20:39.860
我们现在甚至在九丹麦克朗就做到了

00:20:34.550 --> 00:20:41.540
这是一个富有成果的工作领域

00:20:39.860 --> 00:20:42.650
谢谢，当我说我们正在做

00:20:41.540 --> 00:20:44.660
晚上，我的意思是我们正在

00:20:42.650 --> 00:20:46.430
示例方法的实现

00:20:44.660 --> 00:20:47.840
手柄是静态旋转的

00:20:46.430 --> 00:20:49.430
他们曾经是动态旋转的东西

00:20:47.840 --> 00:20:51.200
像那样，我们当然使用j-link 

00:20:49.430 --> 00:20:54.980
构建JDK本身，是的

00:20:51.200 --> 00:20:58.610
是的，它确实需要工作

00:20:54.980 --> 00:21:00.260
确实有效，很好

00:20:58.610 --> 00:21:03.470
来自Twitter的问题，我们可能每个人

00:21:00.260 --> 00:21:08.840
有自己不同的答案

00:21:03.470 --> 00:21:10.820
如果您能给您一个Java遗憾

00:21:08.840 --> 00:21:13.160
你知道很多选择

00:21:10.820 --> 00:21:19.340
时光倒流你会做一件事

00:21:13.160 --> 00:21:21.140
我已经在记录中

00:21:19.340 --> 00:21:23.660
回答，所以我想我不得不说

00:21:21.140 --> 00:21:25.370
序列化，而不是概念

00:21:23.660 --> 00:21:27.560
序列化的方法

00:21:25.370 --> 00:21:30.680
序列化是一种神奇的刮法

00:21:27.560 --> 00:21:33.590
允许d的字段

00:21:30.680 --> 00:21:43.400
序列化绕过构造函数

00:21:33.590 --> 00:21:45.410
礼物不断给我那么多

00:21:43.400 --> 00:21:47.840
可能会后悔的事情只是

00:21:45.410 --> 00:21:49.370
对我来说也是如此

00:21:47.840 --> 00:21:51.050
当时的样子，我们发现了

00:21:49.370 --> 00:21:53.810
穿越的最佳方式

00:21:51.050 --> 00:21:56.630
情况并获得最好的机会

00:21:53.810 --> 00:21:58.400
失去了机会，但我

00:21:56.630 --> 00:22:00.590
会说一件事我后悔

00:21:58.400 --> 00:22:03.710
特别是今年看得如何

00:22:00.590 --> 00:22:07.010
巴拿马项目证明是

00:22:03.710 --> 00:22:08.860
当我在2005年提出它时

00:22:07.010 --> 00:22:12.360
严重否决了

00:22:08.860 --> 00:22:12.360
然后那些正在运行东西的人

00:22:13.200 --> 00:22:18.280
是的，那是一个可悲的项目巴拿马

00:22:16.570 --> 00:22:24.400
真的很酷，非常面板

00:22:18.280 --> 00:22:27.280
非常酷，所以Brian的遗憾是

00:22:24.400 --> 00:22:33.280
在我的名单上很高，但是我会说我的

00:22:27.280 --> 00:22:35.650
最遗憾的是12点或一个点3 

00:22:33.280 --> 00:22:41.110
最迟我们应该做一个

00:22:35.650 --> 00:22:42.760
你知道每个人的生活的模块系统

00:22:41.110 --> 00:22:45.640
但是我们这些从事JDK和

00:22:42.760 --> 00:22:48.730
每个人都用它会是这样

00:22:45.640 --> 00:22:50.860
现在好多了，因为DH是

00:22:48.730 --> 00:22:53.470
这个我不知道要多少年

00:22:50.860 --> 00:22:55.230
我没有设计模块的数目

00:22:53.470 --> 00:22:58.480
可以改装到的系统

00:22:55.230 --> 00:23:00.160
 JDK和偶数中的所有代码

00:22:58.480 --> 00:23:02.350
更大的范围内，您知道我没代码了

00:23:00.160 --> 00:23:04.330
世界以一种明智的方式

00:23:02.350 --> 00:23:06.070
艰难的是充满乐趣和挑战，但

00:23:04.330 --> 00:23:13.270
如果我们去过，我们会更早完成

00:23:06.070 --> 00:23:15.610
先生，对每个人都更好

00:23:13.270 --> 00:23:18.280
这个问题比我的问题更重要

00:23:15.610 --> 00:23:21.070
但是我做了一点修改

00:23:18.280 --> 00:23:22.540
放一个问答幻灯片，我只是

00:23:21.070 --> 00:23:26.290
说这是问我们什么

00:23:22.540 --> 00:23:28.540
关于jdk，好吧，你可以问

00:23:26.290 --> 00:23:31.330
 JDK艺术设计师，无论您有什么问题

00:23:28.540 --> 00:23:33.820
没事做，所以我们可能不会回答

00:23:31.330 --> 00:23:37.000
是的，否则您可能不喜欢

00:23:33.820 --> 00:23:42.460
回答这是那个解药

00:23:37.000 --> 00:23:47.850
 iPhone风格的问题

00:23:42.460 --> 00:23:52.169
是自Java以来​​Java的最佳发行版

00:23:47.850 --> 00:23:52.169
但是10以来的最佳发行

00:23:54.550 --> 00:24:01.780
我认为最好的答案很简单

00:23:58.900 --> 00:24:03.700
发布我们将要全部出货的那一款

00:24:01.780 --> 00:24:08.830
任何给定的弗兰妮都是如此

00:24:03.700 --> 00:24:17.560
我是88的忠实粉丝

00:24:08.830 --> 00:24:20.110
很好，哦，我会做82次

00:24:17.560 --> 00:24:22.060
旁注，我们当时对我们感到惊讶

00:24:20.110 --> 00:24:24.970
八口的采用率是的

00:24:22.060 --> 00:24:27.430
比我们长期以来的速度更快

00:24:24.970 --> 00:24:29.850
很长一段时间我们也知道收养

00:24:27.430 --> 00:24:32.770
九的速度不会那么快

00:24:29.850 --> 00:24:36.450
哦，没关系，我们很好

00:24:32.770 --> 00:24:36.450
我们与之和平相处

00:24:43.490 --> 00:24:47.929
在课堂上有Java的功能

00:24:46.070 --> 00:24:52.130
加载程序加载类是否有

00:24:47.929 --> 00:24:54.170
我可以卸载课程的方式是的，你可以

00:24:52.130 --> 00:24:55.970
删除所有对其的引用以及对

00:24:54.170 --> 00:24:58.220
类加载器以及所有

00:24:55.970 --> 00:25:00.290
手动有关本地号码的实例

00:24:58.220 --> 00:25:02.690
我在我的应用程序中做到这一点

00:25:00.290 --> 00:25:05.960
产品有其他版本

00:25:02.690 --> 00:25:08.120
所以我产生了一个新的类加载器

00:25:05.960 --> 00:25:09.470
新版本的工作，但同时

00:25:08.120 --> 00:25:11.870
时间，因为内存占用量是

00:25:09.470 --> 00:25:14.300
越来越多，我不得不说我坐下了

00:25:11.870 --> 00:25:16.130
上一个那么快

00:25:14.300 --> 00:25:18.140
从中关闭URI类加载器

00:25:16.130 --> 00:25:21.020
前一个会清除内存

00:25:18.140 --> 00:25:22.940
嘿，你不能明确释放

00:25:21.020 --> 00:25:25.429
就像您不能显式地

00:25:22.940 --> 00:25:27.050
释放物体是的，但是你知道

00:25:25.429 --> 00:25:29.059
因为如果你要上课

00:25:27.050 --> 00:25:30.559
你知道尝试卸载课程

00:25:29.059 --> 00:25:31.910
而且仍然有这种情况

00:25:30.559 --> 00:25:35.240
围绕坏事上课

00:25:31.910 --> 00:25:36.860
对的，所以你必须确保没有

00:25:35.240 --> 00:25:38.210
该类的实例周围和

00:25:36.860 --> 00:25:39.500
这就是垃圾收集器的工作

00:25:38.210 --> 00:25:40.850
那个垃圾收集器最终会

00:25:39.500 --> 00:25:43.550
发现没有这种情况

00:25:40.850 --> 00:25:45.440
上课，没有你的实例

00:25:43.550 --> 00:25:47.150
不知道对类加载器的引用

00:25:45.440 --> 00:25:49.309
然后类加载器周垃圾

00:25:47.150 --> 00:25:51.050
是的，但是有PIV提供

00:25:49.309 --> 00:25:52.670
做垃圾收集权

00:25:51.050 --> 00:25:54.650
乔治看到了你不知道的东西

00:25:52.670 --> 00:25:58.760
曾经想称那不永远

00:25:54.650 --> 00:26:00.559
叫，是的，这个系统DC是一个

00:25:58.760 --> 00:26:06.110
那些看起来不错的东西

00:26:00.559 --> 00:26:08.240
 Java 10中的想法，但实际上在

00:26:06.110 --> 00:26:11.720
在大多数情况下，这是灾难

00:26:08.240 --> 00:26:14.120
因为它做一个你知道一个完整的完整

00:26:11.720 --> 00:26:15.530
垃圾收集可能非常

00:26:14.120 --> 00:26:16.850
事实上，您不花时间

00:26:15.530 --> 00:26:21.350
需要做一个完整的垃圾收集和

00:26:16.850 --> 00:26:23.840
那里有很多，你知道哪里

00:26:21.350 --> 00:26:27.650
人们在做系统的许多实例

00:26:23.840 --> 00:26:28.850
关闭GC和库，您就知道了

00:26:27.650 --> 00:26:30.290
知道这就像我只是一颗定时炸弹

00:26:28.850 --> 00:26:32.600
隐藏在代码和人中

00:26:30.290 --> 00:26:33.800
发现几年后， 

00:26:32.600 --> 00:26:35.270
他们的表现问题是

00:26:33.800 --> 00:26:37.670
使用这个XML库

00:26:35.270 --> 00:26:40.790
经常把系统GC愚蠢地称为

00:26:37.670 --> 00:26:42.530
还有一个API点

00:26:40.790 --> 00:26:44.840
释放所有所谓的系统

00:26:42.530 --> 00:26:46.880
退出否，我也不只是在开玩笑

00:26:44.840 --> 00:26:48.860
那就是真正的方法

00:26:46.880 --> 00:26:50.840
发布像热升级一样的一切

00:26:48.860 --> 00:26:53.150
正在这样做，我们需要替换旧的

00:26:50.840 --> 00:26:55.340
新的assoc类的版本

00:26:53.150 --> 00:26:56.550
你做不到，你可以假冒

00:26:55.340 --> 00:26:58.080
通过使用一些

00:26:56.550 --> 00:27:01.470
像我是GI这样的高级框架

00:26:58.080 --> 00:27:02.880
你知道他们喜欢的看跌期权

00:27:01.470 --> 00:27:05.940
你看到的所有其他东西都有一个水平

00:27:02.880 --> 00:27:08.760
是间接的，所以有一种

00:27:05.940 --> 00:27:10.110
捆绑的抽象概念，如果你

00:27:08.760 --> 00:27:12.600
更新包，然后是旧类

00:27:10.110 --> 00:27:14.550
装载机是放开，新的是

00:27:12.600 --> 00:27:16.110
旋转，然后其他捆绑将

00:27:14.550 --> 00:27:18.510
最终参考了新的类加载器

00:27:16.110 --> 00:27:20.670
而且一切正常，但是很多

00:27:18.510 --> 00:27:22.530
的机制，您知道是否需要

00:27:20.670 --> 00:27:24.690
可以使用它，但是你知道那就是

00:27:22.530 --> 00:27:30.000
不是原始阶级选民的工作方式

00:27:24.690 --> 00:27:32.490
该平台谢谢你，嗯，让我们看看

00:27:30.000 --> 00:27:36.960
 Twitter布赖恩有任何冒犯的机会

00:27:32.490 --> 00:27:38.820
论点和lambdas没什么

00:27:36.960 --> 00:27:40.170
我们现在正在努力

00:27:38.820 --> 00:27:43.700
我们正在做的其他事情

00:27:40.170 --> 00:27:48.120
现在我们认为具有更大的价值

00:27:43.700 --> 00:27:50.730
这样的外交官好吧好主意，或者

00:27:48.120 --> 00:27:53.850
好主意，这是真的

00:27:50.730 --> 00:27:56.310
真的真的很远离50 

00:27:53.850 --> 00:27:58.410
我们最能提高生产力的事情

00:27:56.310 --> 00:28:00.390
可能正在研究我肯定

00:27:58.410 --> 00:28:03.120
这更多是哲学上的要求

00:28:00.390 --> 00:28:04.230
比真正使

00:28:03.120 --> 00:28:05.910
每天的差异

00:28:04.230 --> 00:28:07.560
生产力，他们是如此之多

00:28:05.910 --> 00:28:10.590
其他东西会有更多的

00:28:07.560 --> 00:28:12.030
影响是什么，什么杀手级API 

00:28:10.590 --> 00:28:14.370
还没有写，将需要

00:28:12.030 --> 00:28:16.830
最重要的是我不认为

00:28:14.370 --> 00:28:18.930
有一种语言是杀手languages 

00:28:16.830 --> 00:28:21.240
使用currying但Java有足够的能力

00:28:18.930 --> 00:28:23.640
它不是真的解决方法

00:28:21.240 --> 00:28:25.680
需要他们显然需要在

00:28:23.640 --> 00:28:27.150
 Scala可以帮助您做得更好

00:28:25.680 --> 00:28:29.370
也许所以我错了

00:28:27.150 --> 00:28:31.170
 Scala有一个杀手级应用

00:28:29.370 --> 00:28:34.260
一些杀手级的API可以移入

00:28:31.170 --> 00:28:35.640
 Java，只要我们顺应一切， 

00:28:34.260 --> 00:28:38.550
你看不到，甚至要均匀

00:28:35.640 --> 00:28:42.390
比较明显的例子有多少人

00:28:38.550 --> 00:28:45.930
这里已经注意到Java lambdas 

00:28:42.390 --> 00:28:47.730
不能自称我看不见

00:28:45.930 --> 00:28:51.540
把手放在上升的房间里有两个

00:28:47.730 --> 00:28:53.940
是的，所以你知道第一个羊羔之一

00:28:51.540 --> 00:28:56.850
破解我曾经知道的日子， 

00:28:53.940 --> 00:28:58.620
和那边的伦敦水罐一起

00:28:56.850 --> 00:29:01.170
一堆学术

00:28:58.620 --> 00:29:04.080
出现了，他们喜欢变嘶哑

00:29:01.170 --> 00:29:05.780
非常适合您打电话吗

00:29:04.080 --> 00:29:10.190
这个lambda，它甚至不能自称

00:29:05.780 --> 00:29:12.980
你知道你们是鸡巴点

00:29:10.190 --> 00:29:14.629
这是工程上的权衡

00:29:12.980 --> 00:29:17.240
你知道我们能够简化

00:29:14.629 --> 00:29:19.490
语义明显不是你

00:29:17.240 --> 00:29:21.889
知道并且不必容纳这个

00:29:19.490 --> 00:29:25.309
并没有证明它太大

00:29:21.889 --> 00:29:27.769
交易权是的，这将是很好

00:29:25.309 --> 00:29:29.059
能够像你一样写阶乘

00:29:27.769 --> 00:29:31.639
计算机科学教科书

00:29:29.059 --> 00:29:34.009
递归lambda，但实际上

00:29:31.639 --> 00:29:35.929
妨碍日常工作

00:29:34.009 --> 00:29:38.360
 Java程序员的工作很完整

00:29:35.929 --> 00:29:39.980
没有问题，所以你知道在一个完美的世界

00:29:38.360 --> 00:29:43.639
是的，我们当然会拥有所有这些东西

00:29:39.980 --> 00:29:45.129
但事实证明，一个人可以得到

00:29:43.639 --> 00:29:48.039
没有他们，很多工作就完成了， 

00:29:45.129 --> 00:29:51.980
你知道房间里只有两个人

00:29:48.039 --> 00:30:00.440
没注意到，所以有时很务实

00:29:51.980 --> 00:30:03.230
您知道的权衡是很好的

00:30:00.440 --> 00:30:06.559
使我们成为Java最流行的工具之一

00:30:03.230 --> 00:30:08.539
世界上最公开的语言

00:30:06.559 --> 00:30:11.960
 Java不是Java中最受欢迎的语言

00:30:08.539 --> 00:30:14.419
世界是的，我知道我是否认为

00:30:11.960 --> 00:30:19.539
他在问为什么这是为什么之一

00:30:14.419 --> 00:30:21.980
是因为我知道我在什么时候

00:30:19.539 --> 00:30:25.039
白色工作在战争中是如此受欢迎哦

00:30:21.980 --> 00:30:28.090
为什么成功使成功

00:30:25.039 --> 00:30:31.399
成功是关键

00:30:28.090 --> 00:30:33.080
平台的核心价值来自

00:30:31.399 --> 00:30:34.850
一开始就证明非常

00:30:33.080 --> 00:30:38.120
吸引大量

00:30:34.850 --> 00:30:39.919
人们的可读性兼容性

00:30:38.120 --> 00:30:43.690
当然，我的意思是我要在其他方面空白

00:30:39.919 --> 00:30:46.480
三权可读性兼容性

00:30:43.690 --> 00:30:50.690
生产力绩效透明度

00:30:46.480 --> 00:30:55.100
透明兼容性肯定是

00:30:50.690 --> 00:30:57.049
一个非常你可能知道最大的你

00:30:55.100 --> 00:31:00.350
知道事实，代码来自

00:30:57.049 --> 00:31:02.059
许多年前仍以二进制形式运行

00:31:00.350 --> 00:31:04.970
正如我在主题演讲中所展示的， 

00:31:02.059 --> 00:31:08.240
从jdk 5设置为jar并运行

00:31:04.970 --> 00:31:09.919
在拼图EA上建立起来就很好了

00:31:08.240 --> 00:31:11.360
这是很强大的事情， 

00:31:09.919 --> 00:31:13.039
不是你在所有中找到的东西

00:31:11.360 --> 00:31:16.700
您在某些生态系统中了解的平台

00:31:13.039 --> 00:31:19.039
例如，您知道这个

00:31:16.700 --> 00:31:20.539
他们的本质是这样的

00:31:19.039 --> 00:31:22.879
生态系统中的主导力量可以

00:31:20.539 --> 00:31:23.440
迫使人们经历以下阶段

00:31:22.879 --> 00:31:25.659
收入

00:31:23.440 --> 00:31:27.940
的变化，实际上是可行的

00:31:25.659 --> 00:31:30.309
 Java Java生态系统无法正常工作

00:31:27.940 --> 00:31:34.929
这样，我们一直试图成为

00:31:30.309 --> 00:31:37.299
对它的发展非常负责

00:31:34.929 --> 00:31:39.399
也与另一种有关

00:31:37.299 --> 00:31:40.750
在Twitter上提问，您认为

00:31:39.399 --> 00:31:43.029
在某个时候Java会崩溃

00:31:40.750 --> 00:31:48.250
兼容性，支持更快和

00:31:43.029 --> 00:31:52.659
更容易的创新是，我认为我们是

00:31:48.250 --> 00:31:54.340
我们很抢，我们知道你是谁

00:31:52.659 --> 00:31:56.830
我和我怀疑喜欢叫鸡蛋

00:31:54.340 --> 00:32:00.429
同意我们正在经历一个缓慢的过程

00:31:56.830 --> 00:32:02.799
我们准备就绪的阶段变化

00:32:00.429 --> 00:32:06.519
认识到有些事情只是不

00:32:02.799 --> 00:32:08.379
属于那里，我们已经准备好在需要时

00:32:06.519 --> 00:32:11.740
取得进步，以消除旧

00:32:08.379 --> 00:32:14.620
我们提出了Java SE 9中的东西

00:32:11.740 --> 00:32:19.269
第一次移除我们

00:32:14.620 --> 00:32:21.429
删除6种我知道的方法

00:32:19.269 --> 00:32:23.950
但是你却只有那六个

00:32:21.429 --> 00:32:26.830
我们防止清洁的方法

00:32:23.950 --> 00:32:29.259
如果我们将平台模块化

00:32:26.830 --> 00:32:31.179
保留这六个方法

00:32:29.259 --> 00:32:32.529
想要在java.util中使用任何东西

00:32:31.179 --> 00:32:34.509
你们都必须携带的包裹

00:32:32.529 --> 00:32:37.929
围绕所有秋千和awt，这不是

00:32:34.509 --> 00:32:39.850
一个好的解决方案，你认识的律师

00:32:37.929 --> 00:32:41.620
我们对此研究非常谨慎

00:32:39.850 --> 00:32:43.299
就像我们在行家中可以找到的所有罐子一样

00:32:41.620 --> 00:32:45.730
中央和其他地方，发现

00:32:43.299 --> 00:32:47.889
这些方法实际上很少

00:32:45.730 --> 00:32:49.389
用过，所以你知道低风险的东西

00:32:47.889 --> 00:32:51.669
我们甚至对此非常清楚

00:32:49.389 --> 00:32:52.870
作业何时发货时发出通知

00:32:51.669 --> 00:32:55.350
考虑这六种方法

00:32:52.870 --> 00:33:00.190
历史我们删除了其他一些

00:32:55.350 --> 00:33:03.460
在JDK 9中的机制是

00:33:00.190 --> 00:33:06.279
要么是标准的，而不是，很少使用

00:33:03.460 --> 00:33:08.289
或非标准且很少使用

00:33:06.279 --> 00:33:10.809
这些都记录在

00:33:08.289 --> 00:33:14.169
各种吉普车，当然还有九个

00:33:10.809 --> 00:33:17.649
我们也正在封装

00:33:14.169 --> 00:33:19.600
现在大多数jdk内部api来自

00:33:17.649 --> 00:33:21.789
纯粹的立场不是

00:33:19.600 --> 00:33:23.649
不兼容，因为毕竟你

00:33:21.789 --> 00:33:26.200
应该只使用标准API 

00:33:23.649 --> 00:33:31.090
流失，这里没有人使用非标准

00:33:26.200 --> 00:33:34.360
一个PSP，对不起，您知道吗

00:33:31.090 --> 00:33:35.779
是的，这是实用的

00:33:34.360 --> 00:33:37.190
兼容性

00:33:35.779 --> 00:33:38.840
但是我们已经尽力了

00:33:37.190 --> 00:33:41.269
交流所有内容并提供工具

00:33:38.840 --> 00:33:43.039
帮助人们超越它

00:33:41.269 --> 00:33:45.590
解释原因，因为我们

00:33:43.039 --> 00:33:49.129
知道在某些情况下

00:33:45.590 --> 00:33:52.389
你知道会更痛苦

00:33:49.129 --> 00:33:55.749
我可以想象整个

00:33:52.389 --> 00:33:59.149
子系统可能被抛弃

00:33:55.749 --> 00:34:01.809
 Java SE我们真的需要携带吗

00:33:59.149 --> 00:34:05.389
围绕jax-ws和jack的b和korba 

00:34:01.809 --> 00:34:07.849
对某些人非常有用，但是他们

00:34:05.389 --> 00:34:10.190
实际上必须是SE mmm的一部分

00:34:07.849 --> 00:34:12.020
不是，你们想退款

00:34:10.190 --> 00:34:13.309
兼容好，我想回到

00:34:12.020 --> 00:34:15.919
前一个问题一秒钟，然后

00:34:13.309 --> 00:34:17.720
已经发现兼容性，所以我

00:34:15.919 --> 00:34:19.039
认为你知道其中之一

00:34:17.720 --> 00:34:20.599
 Java的基本要素

00:34:19.039 --> 00:34:22.700
成功是其对

00:34:20.599 --> 00:34:25.309
不打扰的安全性，所以如果您

00:34:22.700 --> 00:34:27.740
比较Java与之前的情况

00:34:25.309 --> 00:34:30.200
然后大部分看到的是

00:34:27.740 --> 00:34:31.639
很多很多方面

00:34:30.200 --> 00:34:33.169
你必须自己管理安全

00:34:31.639 --> 00:34:34.819
必须管理指针安全

00:34:33.169 --> 00:34:38.720
管理您必须管理的类型安全

00:34:34.819 --> 00:34:40.700
内存安全和Java设法采取

00:34:38.720 --> 00:34:42.710
这些责任从

00:34:40.700 --> 00:34:45.649
以一种您并不真正喜欢的方式进行编程

00:34:42.710 --> 00:34:47.809
想念他们，你有运行时

00:34:45.649 --> 00:34:50.779
你知道我在做垃圾收集

00:34:47.809 --> 00:34:52.250
因为你，你知道一些

00:34:50.779 --> 00:34:56.629
更强大的类型系统

00:34:52.250 --> 00:35:00.170
随着时间的流逝，您会更加了解

00:34:56.629 --> 00:35:02.329
无法将指针插入int中

00:35:00.170 --> 00:35:04.640
知道你知道平台保持

00:35:02.329 --> 00:35:07.250
你这样做，所以整个

00:35:04.640 --> 00:35:10.069
您无法做到的错误类别

00:35:07.250 --> 00:35:12.170
用java制作，如果你没有浪费

00:35:10.069 --> 00:35:14.059
避免我们追逐那些精力的人

00:35:12.170 --> 00:35:16.099
您可以将精力集中在更多的错误

00:35:14.059 --> 00:35:18.140
有价值的活动，我认为

00:35:16.099 --> 00:35:19.940
发现平衡的安全性

00:35:18.140 --> 00:35:22.460
我认为这是一种秘密的调味料

00:35:19.940 --> 00:35:23.750
他们就像其他任何成功一样

00:35:22.460 --> 00:35:26.779
也有点运气是

00:35:23.750 --> 00:35:29.569
在正确的时间正确的事情，我们有

00:35:26.779 --> 00:35:32.720
另一个秘诀就是我

00:35:29.569 --> 00:35:35.299
变得更加有价值

00:35:32.720 --> 00:35:37.510
岁月是原始的质量

00:35:35.299 --> 00:35:41.240
保持的规格

00:35:37.510 --> 00:35:44.900
但是如果你看看

00:35:41.240 --> 00:35:46.970
 Java语言规范您和您以及您

00:35:44.900 --> 00:35:50.060
学会依靠它并

00:35:46.970 --> 00:35:53.420
实施并寻找所有角落

00:35:50.060 --> 00:35:55.369
案例及其记录方式是我

00:35:53.420 --> 00:35:57.349
认为这是我认为可能是

00:35:55.369 --> 00:35:59.390
最佳编程规范编程

00:35:57.349 --> 00:36:01.700
语言规范肯定写过

00:35:59.390 --> 00:36:04.369
在它的前十名中

00:36:01.700 --> 00:36:07.060
在前五名中

00:36:04.369 --> 00:36:09.320
看看作者高斯林的喜悦

00:36:07.060 --> 00:36:11.660
他们投入了大量时间和精力

00:36:09.320 --> 00:36:13.700
这样做，这是一个

00:36:11.660 --> 00:36:15.830
给数百万人的礼物

00:36:13.700 --> 00:36:17.240
接班人的火炬传递很好

00:36:15.830 --> 00:36:19.520
因为他们非常关心

00:36:17.240 --> 00:36:21.050
 Alex的工作非常艰巨，他是其中之一

00:36:19.520 --> 00:36:23.690
继任者，但他在隔壁

00:36:21.050 --> 00:36:27.109
谈论模块，同样

00:36:23.690 --> 00:36:29.840
与JVM规范是

00:36:27.109 --> 00:36:33.080
由蒂姆·林德霍尔姆（Tim Lindholm）发起美丽的工作

00:36:29.840 --> 00:36:34.730
和and and and work不是

00:36:33.080 --> 00:36:37.790
完美无所不能

00:36:34.730 --> 00:36:39.380
完美，但作为一个非常强大

00:36:37.790 --> 00:36:40.580
建立东西的基础

00:36:39.380 --> 00:36:42.380
会兼容的东西，所以

00:36:40.580 --> 00:36:47.570
兼容，你可以做洁净室

00:36:42.380 --> 00:36:49.520
 iBM已在其中实施

00:36:47.570 --> 00:36:52.190
一家公司，甲骨文做了一家公司

00:36:49.520 --> 00:36:53.780
除了用J火箭做的医院

00:36:52.190 --> 00:36:56.240
基于

00:36:53.780 --> 00:36:59.000
规格很难找到

00:36:56.240 --> 00:37:01.210
类似的规范取得了类似的成功

00:36:59.000 --> 00:37:01.210
那

00:37:05.359 --> 00:37:09.000
所以在几年前的会议上

00:37:07.619 --> 00:37:11.580
有很多问题之一

00:37:09.000 --> 00:37:13.260
感兴趣的是使用utf-8的前景

00:37:11.580 --> 00:37:15.480
是默认的平台编码是

00:37:13.260 --> 00:37:17.010
在那个或新的上有任何进展

00:37:15.480 --> 00:37:21.900
您在移动中发现的障碍

00:37:17.010 --> 00:37:24.590
走向光荣的未来，谢谢

00:37:21.900 --> 00:37:29.190
提醒一下，我不确定有人

00:37:24.590 --> 00:37:31.170
是的，不，我非常同情我

00:37:29.190 --> 00:37:32.700
不要以为有人看过

00:37:31.170 --> 00:37:35.190
最近你知道什么可以

00:37:32.700 --> 00:37:36.960
说如果我们要去做那个九

00:37:35.190 --> 00:37:40.190
发布是因为我们

00:37:36.960 --> 00:37:45.810
反正一切都打破了

00:37:40.190 --> 00:37:47.430
是的，谢谢你的提醒

00:37:45.810 --> 00:37:49.290
世界上utf-8文本的数量是

00:37:47.430 --> 00:37:50.910
只是随着表情符号而增加

00:37:49.290 --> 00:37:55.560
和涂料的默认平台

00:37:50.910 --> 00:37:56.820
特别是在Windows或88 51上

00:37:55.560 --> 00:37:59.910
只是不正​​确的选择，因为

00:37:56.820 --> 00:38:02.420
 utf-8 Texas几乎是整个德克萨斯州

00:37:59.910 --> 00:38:05.580
在这个世界上，是的，不是，我是说，嘿，我是

00:38:02.420 --> 00:38:08.310
 nus utf-8一直有多少人

00:38:05.580 --> 00:38:10.320
在这个房间里有意识地避免使用utf-8，因为

00:38:08.310 --> 00:38:17.580
当他们何时他们平台编码

00:38:10.320 --> 00:38:21.020
启动Java等待Craig 0好的

00:38:17.580 --> 00:38:21.020
好吧，这是一个数据点

00:38:25.060 --> 00:38:30.290
你可以再问一个问题

00:38:27.230 --> 00:38:32.840
所以你回来排队，好吧，怎么

00:38:30.290 --> 00:38:34.850
您了解最新技术吗

00:38:32.840 --> 00:38:46.460
继续学习像你一样

00:38:34.850 --> 00:38:49.100
做到这一点与

00:38:46.460 --> 00:38:51.110
我们可以的很多人

00:38:49.100 --> 00:38:53.600
参与我们自己的小泡沫

00:38:51.110 --> 00:38:57.470
生态系统读取了我们可以观看的所有内容

00:38:53.600 --> 00:38:59.510
会议视频，这是很多

00:38:57.470 --> 00:39:02.180
要处理的信息，但您只有

00:38:59.510 --> 00:39:04.970
决定对它开放，因为

00:39:02.180 --> 00:39:07.160
很容易专注于您

00:39:04.970 --> 00:39:08.690
专家，错过一切

00:39:07.160 --> 00:39:10.550
在外面，所以你真的有

00:39:08.690 --> 00:39:12.440
有意识地努力扩大

00:39:10.550 --> 00:39:15.830
您的输入源并腾出时间

00:39:12.440 --> 00:39:17.000
他们在多个层面上，所以学习什么

00:39:15.830 --> 00:39:20.120
你的同事正在做

00:39:17.000 --> 00:39:22.520
走廊了解您的同事在

00:39:20.120 --> 00:39:25.070
他们遍布整个生态系统

00:39:22.520 --> 00:39:27.260
了解竞争对手在做什么

00:39:25.070 --> 00:39:29.660
与您的竞争对手成为朋友，然后

00:39:27.260 --> 00:39:31.640
了解你不认识的人

00:39:29.660 --> 00:39:34.340
他们通常会越过路径

00:39:31.640 --> 00:39:37.550
然后既然我们从事计算

00:39:34.340 --> 00:39:39.620
阅读一些数学和一些科学知识等等

00:39:37.550 --> 00:39:42.410
今年我读了几本书

00:39:39.620 --> 00:39:44.450
 Raymond Smolyan谈数学逻辑

00:39:42.410 --> 00:39:46.940
只是对这些东西的精彩更新

00:39:44.450 --> 00:39:50.330
它给了我新鲜，你知道新鲜

00:39:46.940 --> 00:39:54.350
盯着我所做的事情

00:39:50.330 --> 00:39:56.450
多个音阶，是的，二常梅

00:39:54.350 --> 00:39:58.280
 II尽力尝试

00:39:56.450 --> 00:40:01.670
跟上编程语言

00:39:58.280 --> 00:40:03.200
我的学术研究

00:40:01.670 --> 00:40:04.940
来自很难有很多

00:40:03.200 --> 00:40:07.880
读到很多

00:40:04.940 --> 00:40:10.040
我只是不明白了，但是

00:40:07.880 --> 00:40:12.470
但是它在那里，还有另一件事

00:40:10.040 --> 00:40:17.000
我发现有帮助是我偶尔去

00:40:12.470 --> 00:40:21.560
返回并重读我读过的论文30 

00:40:17.000 --> 00:40:23.480
多年前被重新激发

00:40:21.560 --> 00:40:26.030
你知道什么美丽， 

00:40:23.480 --> 00:40:28.580
我当时发现的清晰度

00:40:26.030 --> 00:40:30.410
大概每五六年一次

00:40:28.580 --> 00:40:33.680
回去读萨斯曼的钢铁

00:40:30.410 --> 00:40:37.090
 lambda文件在那里，他们就是你

00:40:33.680 --> 00:40:37.090
知道很多事情的金钥匙

00:40:40.910 --> 00:40:46.080
类型推断的机会是什么

00:40:43.530 --> 00:40:51.360
用于方法返回的本地方法

00:40:46.080 --> 00:40:56.400
价值观，也许是为了减轻我们的负担

00:40:51.360 --> 00:40:58.140
分号是两个问题，所以

00:40:56.400 --> 00:41:01.820
您必须回到生产线

00:40:58.140 --> 00:41:04.800
第二个问题类型推断

00:41:01.820 --> 00:41:07.500
方法的返回值极高

00:41:04.800 --> 00:41:10.230
不太可能，原因是

00:41:07.500 --> 00:41:12.420
私有方法的例外

00:41:10.230 --> 00:41:14.460
知道方法是您的API的一部分，并且

00:41:12.420 --> 00:41:17.130
有二进制兼容性

00:41:14.460 --> 00:41:20.070
考虑你不想退货

00:41:17.130 --> 00:41:21.960
键入仅因您而微妙的更改

00:41:20.070 --> 00:41:23.700
更改实施主体

00:41:21.960 --> 00:41:25.650
现在突然之间

00:41:23.700 --> 00:41:27.119
编程/不再链接，因为

00:41:25.650 --> 00:41:29.550
其他一些打电话给您的客户

00:41:27.119 --> 00:41:31.710
方法以为返回类型是这个

00:41:29.550 --> 00:41:33.480
将该签名嵌入到类文件中

00:41:31.710 --> 00:41:36.330
现在您知道签名了

00:41:33.480 --> 00:41:38.340
可以改变，这不是问题

00:41:36.330 --> 00:41:40.530
私有方法，但这意味着

00:41:38.340 --> 00:41:44.010
将方法从私有重构为

00:41:40.530 --> 00:41:45.869
非私有，你知道吗，你知道是一个

00:41:44.010 --> 00:41:48.150
重构简短答案不太容易

00:41:45.869 --> 00:41:51.480
现在永远不会发生

00:41:48.150 --> 00:41:54.380
哲学原因和分号

00:41:51.480 --> 00:41:54.380
所以要认真

00:41:58.790 --> 00:42:05.910
这既是短期的，也是长期的

00:42:00.600 --> 00:42:07.380
答案是有的列表

00:42:05.910 --> 00:42:10.500
对工作更重要的事情

00:42:07.380 --> 00:42:12.180
在垫子上实际上是无限的

00:42:10.500 --> 00:42:29.460
是结肠缓解的领域

00:42:12.180 --> 00:42:33.380
很重要，但是医学上

00:42:29.460 --> 00:42:36.210
您最大的遗憾和

00:42:33.380 --> 00:42:38.640
 Java可能崩溃的可能性

00:42:36.210 --> 00:42:41.340
事物的兼容性，我们永远可以

00:42:38.640 --> 00:42:46.790
看到一个新的序列化机制， 

00:42:41.340 --> 00:42:52.260
当前快乐的消除

00:42:46.790 --> 00:42:55.050
序列化，是的，肯定是

00:42:52.260 --> 00:42:57.600
序列化很有可能

00:42:55.050 --> 00:42:58.830
改善似乎不太可能

00:42:57.600 --> 00:43:01.710
完全摆脱现有

00:42:58.830 --> 00:43:05.430
序列化机制，因为那里

00:43:01.710 --> 00:43:07.680
基本上是不会的情况

00:43:05.430 --> 00:43:11.640
除了当前以外的任何东西序列化

00:43:07.680 --> 00:43:14.370
情况，所以我们不一定要采取

00:43:11.640 --> 00:43:16.260
如果我们不能解决现有的机制

00:43:14.370 --> 00:43:18.240
用你那东西代替

00:43:16.260 --> 00:43:21.150
知道全面兼容

00:43:18.240 --> 00:43:23.070
说你知道我们一直在让你知道

00:43:21.150 --> 00:43:25.530
在一定程度上的进步

00:43:23.070 --> 00:43:29.180
识别序列化机制

00:43:25.530 --> 00:43:32.100
这样更容易推理

00:43:29.180 --> 00:43:34.440
导致较小的对象流

00:43:32.100 --> 00:43:36.120
哪些代码可以迁移，我们

00:43:34.440 --> 00:43:37.110
认为这可能是我们最好的

00:43:36.120 --> 00:43:39.750
可以做到，但这绝对是

00:43:37.110 --> 00:43:41.490
我们想做的我会更加积极

00:43:39.750 --> 00:43:43.980
比我想要拿出来的

00:43:41.490 --> 00:43:45.990
有一天，有一天就要拍摄一次

00:43:43.980 --> 00:43:47.520
你知道可行的替代品

00:43:45.990 --> 00:43:50.220
我只用了8％的用例

00:43:47.520 --> 00:43:52.110
这只是安全性的数字

00:43:50.220 --> 00:43:56.220
我们必须修复的漏洞

00:43:52.110 --> 00:43:58.980
这种机制太痛苦了，如果

00:43:56.220 --> 00:44:01.920
你看序列化到底是什么

00:43:58.980 --> 00:44:04.290
等于是一种秘密的扭曲方式

00:44:01.920 --> 00:44:08.300
向两个类添加新的构造函数

00:44:04.290 --> 00:44:08.300
有时未声明， 

00:44:08.780 --> 00:44:13.609
那只是不能很好地工作

00:44:11.280 --> 00:44:16.710
与Java工作流程的任何其他部分

00:44:13.609 --> 00:44:21.630
所以我们需要的是某种方式

00:44:16.710 --> 00:44:24.839
在更多的方面声明构造函数

00:44:21.630 --> 00:44:27.330
纪律严明和可审核的审核方式

00:44:24.839 --> 00:44:29.760
然后在另一端

00:44:27.330 --> 00:44:32.190
等式可乐教练，可以

00:44:29.760 --> 00:44:35.369
将对象分解为操作数

00:44:32.190 --> 00:44:37.260
给建设者，这样你

00:44:35.369 --> 00:44:40.619
知道有办法做

00:44:37.260 --> 00:44:42.990
这就是我们现在拥有的方式

00:44:40.619 --> 00:44:46.140
令人难以置信的扭曲和低级

00:44:42.990 --> 00:44:48.450
无法理解，但你知道

00:44:46.140 --> 00:44:49.800
每个试图做这个鼻子的人

00:44:48.450 --> 00:44:51.810
当然，他们希望能够接受

00:44:49.800 --> 00:44:54.240
将对象分解成其内容，然后

00:44:51.810 --> 00:44:57.690
放回去，但这是一个

00:44:54.240 --> 00:44:59.880
这是一个握手和一个过程， 

00:44:57.690 --> 00:45:01.290
班级的作者需要更多

00:44:59.880 --> 00:45:09.000
控制或永远不会

00:45:01.290 --> 00:45:10.830
是的，我想提醒一下

00:45:09.000 --> 00:45:13.050
每个人，为什么Java的另一个原因

00:45:10.830 --> 00:45:14.490
如此疯狂地受欢迎

00:45:13.050 --> 00:45:17.490
一直是它的高品质

00:45:14.490 --> 00:45:19.380
从一开始我就图书馆

00:45:17.490 --> 00:45:21.690
出任应用程序程序员

00:45:19.380 --> 00:45:22.710
那是吸引人的事情之一

00:45:21.690 --> 00:45:24.690
我，那仍然吸引着人们

00:45:22.710 --> 00:45:28.109
来自其他经常使用的语言

00:45:24.690 --> 00:45:30.900
很难找到深层次的

00:45:28.109 --> 00:45:33.210
标准库，例如C ++中的

00:45:30.900 --> 00:45:36.300
例子或那里有很多

00:45:33.210 --> 00:45:39.000
库供您选择

00:45:36.300 --> 00:45:40.560
执行质量和语言

00:45:39.000 --> 00:45:43.890
诸如以下名字的孩子

00:45:40.560 --> 00:45:45.960
 JavaScript，这就是

00:45:43.890 --> 00:45:48.089
 Java确实擅长，所以我想

00:45:45.960 --> 00:45:49.800
提出来的utf-8言论， 

00:45:48.089 --> 00:45:52.740
把那变成了事实

00:45:49.800 --> 00:45:54.869
时下java.lang.string javed erlanger 

00:45:52.740 --> 00:45:57.000
从Java 9开始的字符串不再是

00:45:54.869 --> 00:45:59.640
 16位核心值的序列

00:45:57.000 --> 00:46:01.619
内部图书馆，但仍然

00:45:59.640 --> 00:46:03.869
揭露了这个小说，它是超级的

00:46:01.619 --> 00:46:06.240
给更多的开发人员带来不便

00:46:03.869 --> 00:46:08.609
更多遇到需要的字符

00:46:06.240 --> 00:46:10.740
要表示的两个16位核心值

00:46:08.609 --> 00:46:13.349
现在唯一可以做的

00:46:10.740 --> 00:46:15.780
这样就可以将字符串转换为流

00:46:13.349 --> 00:46:17.670
 Unicode代码点，这很好

00:46:15.780 --> 00:46:19.380
如果可以的话也更好

00:46:17.670 --> 00:46:21.490
轻松地放回去，这不是很正确

00:46:19.380 --> 00:46:24.010
现在如果API更好了

00:46:21.490 --> 00:46:27.490
清理以将字符串显示为

00:46:24.010 --> 00:46:29.140
实际存在的顺序

00:46:27.490 --> 00:46:31.810
是的，有人在

00:46:29.140 --> 00:46:37.690
看着所以回到那个遗憾

00:46:31.810 --> 00:46:40.660
问题使用utf-16 ucs-2作为

00:46:37.690 --> 00:46:42.310
本机编码就是我的前十名

00:46:40.660 --> 00:46:43.330
我认为这不是我的前五名，但

00:46:42.310 --> 00:46:45.340
这绝对是其中之一

00:46:43.330 --> 00:46:47.800
你知道那是一个事实

00:46:45.340 --> 00:46:49.920
当时有争议的决定

00:46:47.800 --> 00:46:53.050
被认为是非常前瞻的

00:46:49.920 --> 00:46:55.210
虔诚的16位会足够

00:46:53.050 --> 00:46:58.020
现在我们听说过

00:46:55.210 --> 00:47:04.150
在其他许多方面之前

00:46:58.020 --> 00:47:06.010
钱是600点我不知道

00:47:04.150 --> 00:47:08.200
引入另一个字符串抽象

00:47:06.010 --> 00:47:10.900
我已经看到这种情况发生在其他语言中

00:47:08.200 --> 00:47:12.700
我觉得这非常痛苦

00:47:10.900 --> 00:47:15.369
在哈森哈斯克尔，有两个不同的地方

00:47:12.700 --> 00:47:19.000
两种或三种不同的字符串类型

00:47:15.369 --> 00:47:20.140
常用和对抗Python 

00:47:19.000 --> 00:47:23.310
是那一直有这个怪异

00:47:20.140 --> 00:47:26.680
你知道字符串和

00:47:23.310 --> 00:47:28.150
我想要的字符序列

00:47:26.680 --> 00:47:31.090
爱潜入了爱，看到了更好的弦

00:47:28.150 --> 00:47:34.450
内部允许的抽象

00:47:31.090 --> 00:47:37.570
 utf-8为您提供了能力

00:47:34.450 --> 00:47:39.670
做任意索引但在某些情况下

00:47:37.570 --> 00:47:44.950
您知道日志成本的情况下可能会发生

00:47:39.670 --> 00:47:48.580
而不是不变的成本，不是

00:47:44.950 --> 00:47:55.359
实际上很好的模块化代码点

00:47:48.580 --> 00:47:57.700
但无论如何，就是你的工作

00:47:55.359 --> 00:47:59.170
曾经有过价值类型，那么可能会有

00:47:57.700 --> 00:48:00.730
代码点的数据类型，如果

00:47:59.170 --> 00:48:05.200
假设说过

00:48:00.730 --> 00:48:06.700
这将是添加的基础

00:48:05.200 --> 00:48:08.020
到字符串API，如果更多的话

00:48:06.700 --> 00:48:11.619
方便程序员使用

00:48:08.020 --> 00:48:13.030
没有拳击费用，因此

00:48:11.619 --> 00:48:15.240
假设未来的事情可能是

00:48:13.030 --> 00:48:15.240
更好

00:48:16.750 --> 00:48:24.710
嗯，问题的一部分是我们

00:48:20.240 --> 00:48:30.890
要求人们使用索引行为护理

00:48:24.710 --> 00:48:33.230
在访问者被视为加薪

00:48:30.890 --> 00:48:35.830
但stringz确实可以连接

00:48:33.230 --> 00:48:39.470
很多在逻辑上将可连接符号连接

00:48:35.830 --> 00:48:40.850
符号序列等等，如果您

00:48:39.470 --> 00:48:43.400
愿意退缩并将其视为

00:48:40.850 --> 00:48:44.810
像你观察到的那样流，那么你有

00:48:43.400 --> 00:48:47.120
一种更自然的代码获取方式

00:48:44.810 --> 00:48:50.300
指出他们，但只要我们

00:48:47.120 --> 00:48:53.030
提供经典的C风格的循环和

00:48:50.300 --> 00:48:56.630
使用i和i plus的迭代

00:48:53.030 --> 00:48:58.670
而且你知道在我那里得到get元素

00:48:56.630 --> 00:49:02.330
将会有严重的表现

00:48:58.670 --> 00:49:04.160
字符串允许的问题

00:49:02.330 --> 00:49:10.010
包含我认为其他任何东西

00:49:04.160 --> 00:49:12.290
而不是固定大小的元素，所以我们

00:49:10.010 --> 00:49:15.290
远离旧的for循环，但

00:49:12.290 --> 00:49:16.760
它仍然倾向于保持住

00:49:15.290 --> 00:49:18.500
我们回到可以做的决定上

00:49:16.760 --> 00:49:21.140
关于数据结构，尤其是

00:49:18.500 --> 00:49:22.790
像字符串一样居中的那个

00:49:21.140 --> 00:49:24.530
 Verity中心的任何数据结构

00:49:22.790 --> 00:49:31.580
像纵梁数组，很难

00:49:24.530 --> 00:49:34.610
发展您的看法

00:49:31.580 --> 00:49:37.040
春天的框架，特别是喜欢

00:49:34.610 --> 00:49:39.380
您是否觉得不需要，因为

00:49:37.040 --> 00:49:41.000
 Java可以做到所有这些事情，或者可以做到

00:49:39.380 --> 00:49:42.530
你觉得这是对你的好方法

00:49:41.000 --> 00:49:44.630
知道简化事情和那种

00:49:42.530 --> 00:49:51.500
改进了Java语言的框架

00:49:44.630 --> 00:49:55.700
春天的鱼鹰蓝这是一些框架

00:49:51.500 --> 00:49:57.350
人们发现它很有用Brian I 

00:49:55.700 --> 00:50:00.170
我以为你对它了解更多，是的，我

00:49:57.350 --> 00:50:01.940
均值II认为应用程序级别

00:50:00.170 --> 00:50:03.350
框架的工作方式截然不同

00:50:01.940 --> 00:50:05.180
比语言水平高是正确的

00:50:03.350 --> 00:50:07.660
你知道我们的语言工作

00:50:05.180 --> 00:50:09.440
平台设计者将提供

00:50:07.660 --> 00:50:10.850
明智的原语集和

00:50:09.440 --> 00:50:12.200
您可以在其中编程的模型

00:50:10.850 --> 00:50:14.060
表达你对你的了解

00:50:12.200 --> 00:50:16.850
想要同时表达申请和

00:50:14.060 --> 00:50:18.680
框架，但您知道框架

00:50:16.850 --> 00:50:23.060
框架的作用是抽象

00:50:18.680 --> 00:50:25.340
您知道的常见应用程序任务

00:50:23.060 --> 00:50:27.620
您知道我们消除了冗余， 

00:50:25.340 --> 00:50:28.730
改善可靠性应用，您

00:50:27.620 --> 00:50:31.190
知道那完全是因为

00:50:28.730 --> 00:50:34.010
在那个级别上要做的事情，但是你

00:50:31.190 --> 00:50:36.350
知道我们的水平，就是

00:50:34.010 --> 00:50:38.510
都是从那里开始的应用程序

00:50:36.350 --> 00:50:41.030
我们的观点非常重要

00:50:38.510 --> 00:50:43.700
但是你知道我们坐在哪里

00:50:41.030 --> 00:50:46.970
是否是春天，您知道Java EE吗

00:50:43.700 --> 00:50:48.290
知道时间汤米，无论我是什么

00:50:46.970 --> 00:50:51.560
那里的东西，然后我们必须

00:50:48.290 --> 00:50:54.830
它运作良好，但有时您必须

00:50:51.560 --> 00:50:56.960
挂上钩以使框架正常工作

00:50:54.830 --> 00:50:58.970
换句话说，框架可以是

00:50:56.960 --> 00:51:00.770
首先写在Java之上

00:50:58.970 --> 00:51:02.900
未修改，但偶尔会发现

00:51:00.770 --> 00:51:04.640
像钩子一样的地方

00:51:02.900 --> 00:51:06.860
冬眠之类的

00:51:04.640 --> 00:51:08.360
我们知道那时您需要做什么

00:51:06.860 --> 00:51:10.220
发生的是人们需要的框架

00:51:08.360 --> 00:51:12.230
吸引我们，说您知道您是否

00:51:10.220 --> 00:51:14.030
能够在这里给我们这些钩子

00:51:12.230 --> 00:51:16.280
然后我们可以一起生活

00:51:14.030 --> 00:51:19.460
他们的确好得多，他们

00:51:16.280 --> 00:51:20.720
这样做只是在这里超时，所以有点

00:51:19.460 --> 00:51:23.890
一个前瞻性的例子

00:51:20.720 --> 00:51:26.630
是我们想要能够编码

00:51:23.890 --> 00:51:28.730
没有这么多我称之为恐龙的恐龙

00:51:26.630 --> 00:51:30.350
恐龙线程在我们的应用中我们

00:51:28.730 --> 00:51:32.120
想要一个反应式编程模型

00:51:30.350 --> 00:51:33.520
如果有事件触发其他

00:51:32.120 --> 00:51:35.960
活动，而您不必

00:51:33.520 --> 00:51:39.380
多兆字节线程

00:51:35.960 --> 00:51:42.110
在你身后，所以为了做到这一点

00:51:39.380 --> 00:51:45.830
您可以使用Java线程

00:51:42.110 --> 00:51:48.770
模拟演员和反应点，但

00:51:45.830 --> 00:51:51.470
他们有成本，所以也许在那里

00:51:48.770 --> 00:51:53.740
我们可以在

00:51:51.470 --> 00:51:55.700
在将来的Java中

00:51:53.740 --> 00:51:57.250
反应性框架可以运行得更多

00:51:55.700 --> 00:51:59.750
有效地在Java之上，所以有

00:51:57.250 --> 00:52:02.510
我会说有很多

00:51:59.750 --> 00:52:05.900
潜在的削减点下降到

00:52:02.510 --> 00:52:08.480
您所需要的系统

00:52:05.900 --> 00:52:11.050
与我们的朋友一起发展

00:52:08.480 --> 00:52:11.050
建立在顶层

00:52:13.030 --> 00:52:18.230
我想问你一个人

00:52:15.620 --> 00:52:22.520
用于编辑Java的de工具编辑器

00:52:18.230 --> 00:52:24.830
以及为什么选择这些，所以我很大

00:52:22.520 --> 00:52:28.130
我一直在使用IntelliJ的IntelliJ风扇

00:52:24.830 --> 00:52:30.590
从他们产品的第二版开始

00:52:28.130 --> 00:52:34.670
大概是16 17年前

00:52:30.590 --> 00:52:38.960
在这一点上，它是迄今为止最好的Java 

00:52:34.670 --> 00:52:40.310
 ID我的意思是我尝试了我都哭了

00:52:38.960 --> 00:52:45.590
包括其中许多

00:52:40.310 --> 00:52:52.270
业务，没有可比之处

00:52:45.590 --> 00:52:55.820
订购emacs IntelliJ和netbeans以及

00:52:52.270 --> 00:52:57.260
你知道你是否想要正确的位

00:52:55.820 --> 00:52:59.750
你的手指在那里，你想

00:52:57.260 --> 00:53:02.780
建立可在

00:52:59.750 --> 00:53:04.900
位和emacs是您的朋友，是的

00:53:02.780 --> 00:53:08.030
这是黑客的多功能工具

00:53:04.900 --> 00:53:12.280
 emacs它已连接到我的手指中

00:53:08.030 --> 00:53:17.930
从后期开始一直在使用它

00:53:12.280 --> 00:53:20.120
 1970年代，您偶尔会知道NetBeans是否

00:53:17.930 --> 00:53:21.980
我需要您知道制作GUI或

00:53:20.120 --> 00:53:31.190
有些东西，但是由于我缺乏工作

00:53:21.980 --> 00:53:33.470
这是很公平的机会

00:53:31.190 --> 00:53:36.170
较短发布周期的未来或

00:53:33.470 --> 00:53:40.340
未成年人和专业或做某事

00:53:36.170 --> 00:53:46.250
可以带来更大的敏捷性哦

00:53:40.340 --> 00:53:48.230
有机会那应该是什么

00:53:46.250 --> 00:53:51.290
这实际上是一个有趣的问题

00:53:48.230 --> 00:53:53.750
所以我们花很多时间思考

00:53:51.290 --> 00:53:56.270
关于您的发布周期是多长时间

00:53:53.750 --> 00:53:58.070
应该是我们历史上看

00:53:56.270 --> 00:53:59.270
过去和过去

00:53:58.070 --> 00:54:01.760
当然变化很大

00:53:59.270 --> 00:54:03.590
有时是因为不是

00:54:01.760 --> 00:54:05.360
工程问题，但根本没有问题

00:54:03.590 --> 00:54:09.590
你知道公司合并和东西

00:54:05.360 --> 00:54:13.730
那样的最佳周期是多少

00:54:09.590 --> 00:54:16.160
想一些我们绝对想要的东西

00:54:13.730 --> 00:54:18.500
尤其考虑到

00:54:16.160 --> 00:54:22.670
九经验是这个功能

00:54:18.500 --> 00:54:24.980
驱动驱动发布是您知道吗

00:54:22.670 --> 00:54:28.640
将平台与更广泛

00:54:24.980 --> 00:54:31.190
更快地为社区服务最好

00:54:28.640 --> 00:54:33.200
您知道严格的发布周期

00:54:31.190 --> 00:54:34.970
一个非常严格的火车模型

00:54:33.200 --> 00:54:38.450
每年我们都可以运送

00:54:34.970 --> 00:54:40.580
目前，如果您的功能已经准备就绪， 

00:54:38.450 --> 00:54:43.130
知道六个七个月，然后你去

00:54:40.580 --> 00:54:46.880
进去，如果还没准备好，那你就

00:54:43.130 --> 00:54:48.500
等一下，这就是你知道的

00:54:46.880 --> 00:54:50.600
已经做了一些思考，我们会

00:54:48.500 --> 00:54:52.820
切换到它我不知道我会成为

00:54:50.600 --> 00:54:55.430
好奇地知道你怎么一直知道

00:54:52.820 --> 00:55:00.850
我们的感觉是每年的节奏

00:54:55.430 --> 00:55:03.680
对于相当数量的人来说太快了

00:55:00.850 --> 00:55:06.770
生态系统中的用户很多您知道很多

00:55:03.680 --> 00:55:08.510
我们在这里我们直接在这里和

00:55:06.770 --> 00:55:09.860
有趣地点燃了许多公司

00:55:08.510 --> 00:55:11.270
他们只知道自己变得很大

00:55:09.860 --> 00:55:13.070
他们只需要部署

00:55:11.270 --> 00:55:15.140
一次测试并验证所有内容

00:55:13.070 --> 00:55:17.510
两三年，如果你要

00:55:15.140 --> 00:55:19.880
每年都会发布新版本的Java SE 

00:55:17.510 --> 00:55:23.060
他们只是跳过你知道跳过

00:55:19.880 --> 00:55:24.650
版本，那将是不好的，所以我

00:55:23.060 --> 00:55:26.450
不知道，所以我的意思是有多少人

00:55:24.650 --> 00:55:29.150
想要每年一次的节奏

00:55:26.450 --> 00:55:30.290
严格严格严格火车模型喜欢

00:55:29.150 --> 00:55:34.789
你知道像日食和数字

00:55:30.290 --> 00:55:38.869
其他项目数量做六七

00:55:34.789 --> 00:55:41.269
有多少人喜欢功能驱动型

00:55:38.869 --> 00:55:43.009
模型中有一个或一个

00:55:41.269 --> 00:55:46.419
少数重要功能

00:55:43.009 --> 00:55:46.419
在完成这些操作之前不发货

00:55:47.140 --> 00:55:54.769
有趣的一天，百分之五十

00:55:50.019 --> 00:56:00.529
有趣的数据，谢谢，我不会

00:55:54.769 --> 00:56:02.269
预测未来是什么

00:56:00.529 --> 00:56:06.410
您想从Java中删除的东西

00:56:02.269 --> 00:56:10.459
就像您的头号商标已经命名

00:56:06.410 --> 00:56:11.509
是的，我想我们已经到了

00:56:10.459 --> 00:56:27.880
回答了这个最大的问题

00:56:11.509 --> 00:56:30.229
很遗憾，二世想我，我们是如此

00:56:27.880 --> 00:56:31.579
关注兼容性，因为我们

00:56:30.229 --> 00:56:33.679
不想破坏整体信任

00:56:31.579 --> 00:56:36.049
生态系统是正确的，所以删除东西是

00:56:33.679 --> 00:56:37.219
真的很难，所以如果你问做什么

00:56:36.049 --> 00:56:39.979
我们想删除那就像一个偶像

00:56:37.219 --> 00:56:42.799
偶像梦，但我们想要一些东西

00:56:39.979 --> 00:56:45.079
也要取代我们我们希望有人

00:56:42.799 --> 00:56:47.319
我们希望人们停止使用的物品

00:56:45.079 --> 00:56:49.369
这么多，用更好的东西

00:56:47.319 --> 00:56:52.159
已经提到了序列化

00:56:49.369 --> 00:56:54.979
我会说我提到了旧的

00:56:52.159 --> 00:56:58.909
老式的循环我想少看

00:56:54.979 --> 00:57:01.849
使用它不能将其删除，但我想

00:56:58.909 --> 00:57:04.099
看到它的流或新样式

00:57:01.849 --> 00:57:06.259
循环或新的for循环

00:57:04.099 --> 00:57:07.549
那样的尖叫会是

00:57:06.259 --> 00:57:10.369
更好的是我想要的东西

00:57:07.549 --> 00:57:13.279
用于取代旧的for循环和

00:57:10.369 --> 00:57:16.729
甚至更重要，但类似

00:57:13.279 --> 00:57:19.659
成为另一个程序杀手

00:57:16.729 --> 00:57:22.880
抽象和平行说谎的能力是

00:57:19.659 --> 00:57:25.400
可变性默认情况下，可变性i 

00:57:22.880 --> 00:57:27.799
可能想删除但

00:57:25.400 --> 00:57:30.919
取代使其更容易

00:57:27.799 --> 00:57:33.259
程序员与不可变的非

00:57:30.919 --> 00:57:35.089
可变的持久常数数据

00:57:33.259 --> 00:57:36.799
结构，并具有

00:57:35.089 --> 00:57:38.509
注释性的最佳点，而不是

00:57:36.799 --> 00:57:40.489
目前这一切都是可变的

00:57:38.509 --> 00:57:42.679
一切都有种族条件

00:57:40.489 --> 00:57:44.419
我将第二个我认为关闭

00:57:42.679 --> 00:57:45.390
找到了一个非常好的平衡

00:57:44.419 --> 00:57:47.280
易变的

00:57:45.390 --> 00:57:49.170
永恒的，是的，他们是，他们是

00:57:47.280 --> 00:57:50.610
绝对是个好主意

00:57:49.170 --> 00:57:52.680
研究那里可变性是

00:57:50.610 --> 00:57:54.450
例外应该为每一件事付出代价

00:57:52.680 --> 00:57:58.670
使用赋值运算符和

00:57:54.450 --> 00:57:58.670
价格随每个版本而增加

00:57:59.000 --> 00:58:07.080
嘿，收入机会，新业务

00:58:02.100 --> 00:58:08.160
 Manu哦，是的，所以拼图，我们知道我确定

00:58:07.080 --> 00:58:09.240
你们从一开始就知道

00:58:08.160 --> 00:58:11.040
很难拉

00:58:09.240 --> 00:58:12.750
并被证明有多长时间了

00:58:11.040 --> 00:58:14.880
采取它必须有甚至

00:58:12.750 --> 00:58:16.770
挖东西时更难

00:58:14.880 --> 00:58:18.600
你就像是怎么了

00:58:16.770 --> 00:58:20.280
甚至是工作，我的意思是您尝试挖掘

00:58:18.600 --> 00:58:22.170
即使进行了所有准备工作

00:58:20.280 --> 00:58:24.090
让你完全惊讶的事情

00:58:22.170 --> 00:58:27.960
您尝试使用我们的产品时

00:58:24.090 --> 00:58:29.400
给我JDK里面的东西是的

00:58:27.960 --> 00:58:32.730
一些像这样的交叉连接

00:58:29.400 --> 00:58:38.250
我们要删除的六种方法

00:58:32.730 --> 00:58:44.010
九点，所以我实际上很有趣

00:58:38.250 --> 00:58:49.140
在这里，约翰为什么要为什么打包

00:58:44.010 --> 00:58:52.890
由于以下原因，需要200个API的事件监听器

00:58:49.140 --> 00:58:55.080
我道歉的进度条看起来像一个

00:58:52.890 --> 00:58:56.850
当时的好主意是

00:58:55.080 --> 00:58:58.230
正当理由，但其中

00:58:56.850 --> 00:59:03.170
我们为事件删除的方法

00:58:58.230 --> 00:59:06.360
侦听器方法解压缩后的nadra哦，抱歉

00:59:03.170 --> 00:59:08.580
对不起，他们走了，是的，我在那里

00:59:06.360 --> 00:59:12.900
上有很多令人惊讶的事情

00:59:08.580 --> 00:59:15.960
你知道那边的好处

00:59:12.900 --> 00:59:18.150
幸运的是，相当数量的非正式

00:59:15.960 --> 00:59:20.400
你甚至知道多年来的纪律

00:59:18.150 --> 00:59:22.500
回到最开始尝试

00:59:20.400 --> 00:59:24.630
保持东西干净，尽量不要

00:59:22.500 --> 00:59:27.060
无缘无故的依赖，我是说确定

00:59:24.630 --> 00:59:28.590
在你知道一些东西的地方找到了东西

00:59:27.060 --> 00:59:31.350
公司实施中的代码是

00:59:28.590 --> 00:59:35.730
深入了解XML解析器

00:59:31.350 --> 00:59:38.250
真的喜欢，但是我知道我记得

00:59:35.730 --> 00:59:41.880
回到那天与11 

00:59:38.250 --> 00:59:43.980
我开发的第一个版本发生了

00:59:41.880 --> 00:59:46.350
注意到你知道一个善意的人

00:59:43.980 --> 00:59:49.070
工程师和AWT团队投入了一些

00:59:46.350 --> 00:59:52.380
将图标方法放入java.lang系统

00:59:49.070 --> 00:59:54.690
这似乎是个好主意，我的意思是新

00:59:52.380 --> 00:59:57.000
您可能希望系统中的方法

00:59:54.690 --> 00:59:58.230
获取正在运行的Java程序的图标

00:59:57.000 --> 01:00:00.390
管他呢

00:59:58.230 --> 01:00:04.410
我去找林德美吃饭

01:00:00.390 --> 01:00:06.150
关于它，他说什么，因为那是

01:00:04.410 --> 01:00:07.470
尽管我们知道

01:00:06.150 --> 01:00:10.500
没有模块，那只是一个

01:00:07.470 --> 01:00:13.410
明显违反非正式

01:00:10.500 --> 01:00:15.420
我们拥有的物质系统，所以您知道

01:00:13.410 --> 01:00:17.820
我很感激我们至少有

01:00:15.420 --> 01:00:19.890
多年来的非正式纪律

01:00:17.820 --> 01:00:22.770
并没有那么痛苦，只花了

01:00:19.890 --> 01:00:28.380
像五年来更多地纠缠JDK 

01:00:22.770 --> 01:00:32.570
比我们在2008年开始的数字530 

01:00:28.380 --> 01:00:35.160
最后一个问题带来的机会

01:00:32.570 --> 01:00:37.710
 Alec Project Home Park的功能

01:00:35.160 --> 01:00:40.980
进入GDK或任何旨在减少

01:00:37.710 --> 01:00:43.200
相信船上的船数量

01:00:40.980 --> 01:00:45.030
功能的机会为零

01:00:43.200 --> 01:00:49.470
特别是来自 lombok 项目

01:00:45.030 --> 01:00:53.609
你同意Brian进入JDK 

01:00:49.470 --> 01:00:56.250
有人错过了主题演讲，所以

01:00:53.609 --> 01:00:57.750
在周日的主题演讲中，我们确实做了讨论

01:00:56.250 --> 01:01:00.119
关于样板减少功能

01:00:57.750 --> 01:01:04.470
他们不是专门的项目

01:01:00.119 --> 01:01:06.480
 lombok ，但我们确实很在乎

01:01:04.470 --> 01:01:08.119
样板，我们确实知道您

01:01:06.480 --> 01:01:10.260
甲板上的功能数量

01:01:08.119 --> 01:01:12.270
消除每天的样板

01:01:10.260 --> 01:01:15.060
显示了局部变量类型推断

01:01:12.270 --> 01:01:18.240
显示了编译器的能力

01:01:15.060 --> 01:01:20.430
生成默认的构造函数等于哈希

01:01:18.240 --> 01:01:25.290
字符串，您知道类型操作的代码

01:01:20.430 --> 01:01:27.540
所以是的，但是你确切知道什么

01:01:25.290 --> 01:01:28.830
这些功能是什么时候

01:01:27.540 --> 01:01:32.820
他们来确定的版本

01:01:28.830 --> 01:01:37.530
也许它们使编程变得更容易

01:01:32.820 --> 01:01:39.869
没有可变性就可以了

01:01:37.530 --> 01:01:43.520
刚刚来自肖恩·穆兰的商品

01:01:39.869 --> 01:01:48.420
我们的安全负责人Microsoft RSS 

01:01:43.520 --> 01:01:49.830
 RSASS问题为其他人所熟知

01:01:48.420 --> 01:01:52.230
报告说我们会调查一下

01:01:49.830 --> 01:01:55.580
在约翰·托林之后

01:01:52.230 --> 01:01:55.580
非常感谢你，谢谢

