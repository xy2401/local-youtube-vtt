WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.200 --> 00:00:03.990
 [音乐] 

00:00:02.870 --> 00:00:06.120
未来

00:00:03.990 --> 00:00:09.240
我的名字是两句话要在

00:00:06.120 --> 00:00:11.880
 Java平台中的核心库团队

00:00:09.240 --> 00:00:14.610
 Oracle的一个小组，我从事Java和

00:00:11.880 --> 00:00:17.820
 JDK和我从事的工作之一是

00:00:14.610 --> 00:00:21.270
收集框架，所以谈论

00:00:17.820 --> 00:00:23.010
今天收集了很多东西，所以

00:00:21.270 --> 00:00:25.189
我要去的收藏历史悠久

00:00:23.010 --> 00:00:27.660
做一个非常非常简短的历史，我

00:00:25.189 --> 00:00:28.890
要花一些时间说话

00:00:27.660 --> 00:00:30.300
关于Java 8 

00:00:28.890 --> 00:00:34.370
即使Java 8已经推出

00:00:30.300 --> 00:00:36.899
现在快三年了

00:00:34.370 --> 00:00:38.790
添加到的有趣功能

00:00:36.899 --> 00:00:40.050
似乎没有的Java 8集合

00:00:38.790 --> 00:00:41.850
得到足够的宣传，所以我要

00:00:40.050 --> 00:00:44.539
谈一些，然后

00:00:41.850 --> 00:00:47.910
继续介绍Java 9中的一些新功能

00:00:44.539 --> 00:00:49.289
所以有一个Twitter标签集合

00:00:47.910 --> 00:00:53.309
透露你可以在那看到

00:00:49.289 --> 00:00:55.350
右上角，所以如果你想发推

00:00:53.309 --> 00:00:59.010
在演讲过程中或演讲后我

00:00:55.350 --> 00:01:01.079
将查看该标签并响应

00:00:59.010 --> 00:01:02.969
那里有任何问题，或者很小

00:01:01.079 --> 00:01:05.369
一小群人，如果我有时间我们可以带走

00:01:02.969 --> 00:01:06.299
最后的问题，我会在附近

00:01:05.369 --> 00:01:11.369
剩下的会议

00:01:06.299 --> 00:01:15.600
下午还好，所以历史

00:01:11.369 --> 00:01:24.540
 Java集合已经有20多年了

00:01:15.600 --> 00:01:27.780
旧的收藏夹框架不是

00:01:24.540 --> 00:01:32.329
与Java差不多古老

00:01:27.780 --> 00:01:34.290
 Java 1.0已有近二十年的历史了

00:01:32.329 --> 00:01:35.880
介绍了我们现在所说的

00:01:34.290 --> 00:01:37.320
旧版收藏，所以没有

00:01:35.880 --> 00:01:40.530
收集框架

00:01:37.320 --> 00:01:43.049
开始旧事物矢量和哈希

00:01:40.530 --> 00:01:46.229
表或哈希表，就像我们中的一些人所说的那样

00:01:43.049 --> 00:01:48.149
它，但那些已在jdk 1.2中替换

00:01:46.229 --> 00:01:49.799
这就是收集框架

00:01:48.149 --> 00:01:52.710
我们都熟悉

00:01:49.799 --> 00:01:55.020
接口集合列表集映射和

00:01:52.710 --> 00:01:58.890
等等，以及具体的课程

00:01:55.020 --> 00:02:02.520
支持他们通常的犯罪嫌疑人

00:01:58.890 --> 00:02:05.250
 ArrayList哈希图哈希集等等

00:02:02.520 --> 00:02:08.099
所以这些是在1998年推出的

00:02:05.250 --> 00:02:12.959
那是19年前，所以那些

00:02:08.099 --> 00:02:13.569
实际上每天都在使用

00:02:12.959 --> 00:02:16.239
刚出来

00:02:13.569 --> 00:02:17.260
几周前或实际发布

00:02:16.239 --> 00:02:19.980
它将会在

00:02:17.260 --> 00:02:22.540
我认为今年夏天的发布会

00:02:19.980 --> 00:02:24.189
基本上对

00:02:22.540 --> 00:02:26.079
集合的使用结果

00:02:24.189 --> 00:02:28.659
 ArrayList惊喜最大

00:02:26.079 --> 00:02:30.879
 Java中使用过的集合

00:02:28.659 --> 00:02:32.579
很大一部分甚至可能是

00:02:30.879 --> 00:02:37.750
收藏品的大部分用途

00:02:32.579 --> 00:02:41.079
 ArrayList，以便在Java 5中快速进行

00:02:37.750 --> 00:02:43.719
 2004年，将仿制药添加到

00:02:41.079 --> 00:02:45.790
语言，这对

00:02:43.719 --> 00:02:47.409
集合api的，所以现在我

00:02:45.790 --> 00:02:50.349
希望大家都转化为

00:02:47.409 --> 00:02:52.389
使用通用集合而不是

00:02:50.349 --> 00:02:57.579
而不是原始的原始收藏

00:02:52.389 --> 00:02:59.109
 Java 5中的另一个重要补充是

00:02:57.579 --> 00:03:01.389
并发的加法

00:02:59.109 --> 00:03:02.769
我不会谈论的收藏

00:03:01.389 --> 00:03:05.799
关于今天的那些，但这是一个整体

00:03:02.769 --> 00:03:07.150
完整的相关框架

00:03:05.799 --> 00:03:10.090
与集合有些重叠

00:03:07.150 --> 00:03:13.120
框架，然后沿途各种各样

00:03:10.090 --> 00:03:14.980
个别实现已添加

00:03:13.120 --> 00:03:17.409
各种版本，如射线甲板

00:03:14.980 --> 00:03:19.540
您知道新映射室的优先级

00:03:17.409 --> 00:03:20.949
设置等等，所以那些非常

00:03:19.540 --> 00:03:22.689
他们没有得到的专业收藏

00:03:20.949 --> 00:03:24.870
一般用途，但在需要时使用

00:03:22.689 --> 00:03:28.449
他们在那里，他们真的很有用

00:03:24.870 --> 00:03:32.409
好的，所以Java 8集合

00:03:28.449 --> 00:03:35.349
增强功能，所以我认为大多数人

00:03:32.409 --> 00:03:37.900
意识到Java 8的主要功能

00:03:35.349 --> 00:03:39.879
将lambda添加到

00:03:37.900 --> 00:03:43.840
编程语言和流API 

00:03:39.879 --> 00:03:46.389
被添加到核心库中

00:03:43.840 --> 00:03:48.549
你知道真正有趣的功能

00:03:46.389 --> 00:03:53.169
真的有用，我希望每个人都在使用

00:03:48.549 --> 00:03:55.120
他们，但支持他们一些

00:03:53.169 --> 00:03:57.790
中的其他语言功能

00:03:55.120 --> 00:04:00.699
特定接口现在可以具有

00:03:57.790 --> 00:04:02.199
默认方法和静态方法

00:04:00.699 --> 00:04:04.150
那是一种有趣的语言

00:04:02.199 --> 00:04:07.299
功能我不会谈论

00:04:04.150 --> 00:04:10.329
语言增强本身就是我

00:04:07.299 --> 00:04:13.629
想说的是我们使用的方式

00:04:10.329 --> 00:04:16.449
 JDK中的那些语言功能

00:04:13.629 --> 00:04:19.989
增强JDK中的收集框架

00:04:16.449 --> 00:04:22.389
 8，所以我们要做的是第一次

00:04:19.989 --> 00:04:24.729
我说15年来第一次

00:04:22.389 --> 00:04:26.930
几年来，我想我们第一次

00:04:24.729 --> 00:04:29.449
实际添加

00:04:26.930 --> 00:04:31.370
集合接口的方法

00:04:29.449 --> 00:04:33.590
因此，这与违约大不相同

00:04:31.370 --> 00:04:36.410
默认方法之前的方法

00:04:33.590 --> 00:04:38.690
无法兼容地将方法添加到

00:04:36.410 --> 00:04:39.860
界面否则会Budhia吗

00:04:38.690 --> 00:04:41.840
将是不兼容的

00:04:39.860 --> 00:04:43.970
所以在Java 8中

00:04:41.840 --> 00:04:48.320
默认方法，现在可以添加

00:04:43.970 --> 00:04:51.410
接口的方法，我们继续

00:04:48.320 --> 00:04:53.449
它做到了，所以收集让我们得到

00:04:51.410 --> 00:04:56.210
能雅可迭代的收藏列表有一个

00:04:53.449 --> 00:04:57.740
几个新方法map映射和比较器

00:04:56.210 --> 00:04:59.539
多花点时间在

00:04:57.740 --> 00:05:02.479
他们有了很多新方法

00:04:59.539 --> 00:05:03.919
关于这口井的有趣之处

00:05:02.479 --> 00:05:08.479
一对夫妇有趣的一堆

00:05:03.919 --> 00:05:10.729
那些新方法是我的意思

00:05:08.479 --> 00:05:12.710
并不需要新方法

00:05:10.729 --> 00:05:15.110
必须使用lambda，但其中很多

00:05:12.710 --> 00:05:16.699
从中添加了新方法

00:05:15.110 --> 00:05:21.229
哦，现在我们有了这个

00:05:16.699 --> 00:05:23.510
当我们使用新方法时

00:05:21.229 --> 00:05:25.160
可以接受lambda，它可以做更多的事情

00:05:23.510 --> 00:05:28.430
强大的东西，所以我有一堆

00:05:25.160 --> 00:05:32.060
对

00:05:28.430 --> 00:05:35.630
下一张幻灯片，因此可迭代的界面具有

00:05:32.060 --> 00:05:37.370
自Java 5以来就在那里

00:05:35.630 --> 00:05:40.460
允许您使用增强的for循环

00:05:37.370 --> 00:05:42.800
所以在Java 7中，我对

00:05:40.460 --> 00:05:44.750
顶部的代码段是Java 7 

00:05:42.800 --> 00:05:47.690
然后在下面重写

00:05:44.750 --> 00:05:49.690
 Java 8以及Java 7，如果您想

00:05:47.690 --> 00:05:51.500
遍历列表，您可以使用

00:05:49.690 --> 00:05:53.330
正式称为增强型

00:05:51.500 --> 00:05:55.370
 for-loop有些人称其为

00:05:53.330 --> 00:05:56.930
每个循环我倾向于避免调用

00:05:55.370 --> 00:05:59.960
那是因为现在有一个叫做

00:05:56.930 --> 00:06:00.889
对于每个Java 7，您都可以编写

00:05:59.960 --> 00:06:03.139
增强for循环

00:06:00.889 --> 00:06:05.060
但是在Java 8中，您可以做的是调用

00:06:03.139 --> 00:06:06.770
对于每种方法，并将其传递给lambda 

00:06:05.060 --> 00:06:11.270
它执行的是执行

00:06:06.770 --> 00:06:13.460
该列表中每个元素的lambda和

00:06:11.270 --> 00:06:18.080
这就是一点句法

00:06:13.460 --> 00:06:21.169
不错，但间隔是由继承的

00:06:18.080 --> 00:06:23.150
每个集合的实现

00:06:21.169 --> 00:06:25.550
现在通过以下方式增强了收藏

00:06:23.150 --> 00:06:27.949
每个方法都有这个

00:06:25.550 --> 00:06:29.510
实际上所有其他方法

00:06:27.949 --> 00:06:31.760
其他默认方法是继承的

00:06:29.510 --> 00:06:34.370
一直到层次结构

00:06:31.760 --> 00:06:36.710
我们所做的是通过添加默认方法

00:06:34.370 --> 00:06:39.139
我们已经增强了每个现有的

00:06:36.710 --> 00:06:40.270
收集甚至不是

00:06:39.139 --> 00:06:43.780
引进

00:06:40.270 --> 00:06:46.330
在Java 8中继续

00:06:43.780 --> 00:06:49.810
可迭代，实际上这不是迭代器

00:06:46.330 --> 00:06:52.840
迭代，但如果您曾经写过

00:06:49.810 --> 00:06:56.020
您必须编写的迭代器具有下一个

00:06:52.840 --> 00:06:57.730
方法和下一个方法，哦，那是

00:06:56.020 --> 00:06:58.690
对，你还必须写删除

00:06:57.730 --> 00:07:01.360
方法很好，我不想支持

00:06:58.690 --> 00:07:03.400
删除，所以你总是写抛出新的

00:07:01.360 --> 00:07:08.100
不支持的操作异常等

00:07:03.400 --> 00:07:09.220
现在在迭代器上有一个默认方法

00:07:08.100 --> 00:07:10.780
叫

00:07:09.220 --> 00:07:13.300
删除有一个默认实现

00:07:10.780 --> 00:07:15.130
只是抛出不受支持的

00:07:13.300 --> 00:07:17.170
操作异常，所以这真的

00:07:15.130 --> 00:07:19.660
无非就是方便

00:07:17.170 --> 00:07:22.650
编写自己的迭代器

00:07:19.660 --> 00:07:24.730
如果您不覆盖您，则将您删除

00:07:22.650 --> 00:07:26.320
好吧，您不必覆盖删除

00:07:24.730 --> 00:07:28.300
不再，如果你不明白

00:07:26.320 --> 00:07:30.640
默认行为是抛出一个

00:07:28.300 --> 00:07:32.380
你经常遇到的例外

00:07:30.640 --> 00:07:35.530
想要，因为他们相对较少

00:07:32.380 --> 00:07:37.270
迭代器支持删除，但如果您这样做

00:07:35.530 --> 00:07:39.250
想支持迭代器中的删除

00:07:37.270 --> 00:07:41.730
你只要继续并覆盖它像

00:07:39.250 --> 00:07:43.840
你总是那样

00:07:41.730 --> 00:07:45.820
好吧，他现在觉得有点

00:07:43.840 --> 00:07:47.590
这里更有趣，因为

00:07:45.820 --> 00:07:49.870
只是一种语法上的细微差别

00:07:47.590 --> 00:07:51.550
进行一些批量操作

00:07:49.870 --> 00:07:53.020
假设你有一个想要的情况

00:07:51.550 --> 00:07:56.200
遍历列表并删除

00:07:53.020 --> 00:07:59.680
符合某些条件的元素

00:07:56.200 --> 00:08:01.450
 Java 7，您可能必须编写

00:07:59.680 --> 00:08:03.880
对于循环，您必须将其写出来

00:08:01.450 --> 00:08:07.630
使用迭代器的旧方法

00:08:03.880 --> 00:08:11.710
这里的关键是您不能使用

00:08:07.630 --> 00:08:13.570
增强的for循环，因为您不能

00:08:11.710 --> 00:08:15.700
从循环中删除事物

00:08:13.570 --> 00:08:17.680
否则你会得到一个并发

00:08:15.700 --> 00:08:20.140
修改异常等等你

00:08:17.680 --> 00:08:23.140
要做的是回到原始状态

00:08:20.140 --> 00:08:25.000
循环使用迭代器，然后如果

00:08:23.140 --> 00:08:27.310
与您匹配的东西称为“删除” 

00:08:25.000 --> 00:08:30.370
迭代器，所以是Java 7代码

00:08:27.310 --> 00:08:32.790
有点笨重

00:08:30.370 --> 00:08:36.400
特别是与

00:08:32.790 --> 00:08:38.560
到增强的Fork 

00:08:36.400 --> 00:08:40.720
您将编写的for循环代码

00:08:38.560 --> 00:08:43.030
如果您现在不删除任何东西

00:08:40.720 --> 00:08:46.450
 Java 8中有一个新方法删除

00:08:43.030 --> 00:08:49.000
需要一个predicate和语义

00:08:46.450 --> 00:08:52.390
predicate是否应用于每个predicate

00:08:49.000 --> 00:08:53.779
该集合的元素，如果

00:08:52.390 --> 00:08:55.790
predicate返回true 

00:08:53.779 --> 00:08:58.249
然后将其从集合中删除

00:08:55.790 --> 00:09:00.139
这就是我的意思。 

00:08:58.249 --> 00:09:01.879
所以你看起来知道四或

00:09:00.139 --> 00:09:05.319
五线四环那里倒塌了

00:09:01.879 --> 00:09:10.370
一行可以使事情变得更好

00:09:05.319 --> 00:09:12.050
不仅是语法上的优势

00:09:10.370 --> 00:09:14.509
这实际上是性能优势

00:09:12.050 --> 00:09:16.639
因此，如果您考虑迭代一个

00:09:14.509 --> 00:09:19.040
 ArrayList，如果您从中删除某些内容

00:09:16.639 --> 00:09:22.069
一个ArrayList它必须将所有

00:09:19.040 --> 00:09:23.990
元素就位，所以如果您

00:09:22.069 --> 00:09:26.860
在ArrayList中重复做一次

00:09:23.990 --> 00:09:29.059
那么你得到一个n平方的订单

00:09:26.860 --> 00:09:31.579
性能，因为它反复出现

00:09:29.059 --> 00:09:34.059
向后移ArrayList的尾部

00:09:31.579 --> 00:09:37.699
就像删除元素一样

00:09:34.059 --> 00:09:40.309
如果在Java中针对八项进行了优化，则删除

00:09:37.699 --> 00:09:43.040
 ArrayList的作用是保持

00:09:40.309 --> 00:09:45.949
跟踪哪些内容被删除以及

00:09:43.040 --> 00:09:48.110
然后在所有位置进行复制和操作

00:09:45.949 --> 00:09:51.829
一次，所以我们减少了算法

00:09:48.110 --> 00:09:53.720
从N平方到n阶

00:09:51.829 --> 00:09:56.269
时候我们编写了更多代码

00:09:53.720 --> 00:09:58.550
简洁，所以这里的好处是

00:09:56.269 --> 00:10:02.300
该删除如果操作是它的

00:09:58.550 --> 00:10:04.579
内部迭代，它提出了

00:10:02.300 --> 00:10:05.750
 API的语义级别，因此代替

00:10:04.579 --> 00:10:07.670
从

00:10:05.750 --> 00:10:10.790
在外面，一挑一拣

00:10:07.670 --> 00:10:12.589
现在我们说好的时间删除所有

00:10:10.790 --> 00:10:14.240
元素删除所有匹配项

00:10:12.589 --> 00:10:16.490
基本上就是这样的元素

00:10:14.240 --> 00:10:20.089
因此实施利用了

00:10:16.490 --> 00:10:23.709
有了更好的算法

00:10:20.089 --> 00:10:27.350
继续使用更多新的默认方法

00:10:23.709 --> 00:10:29.480
列表界面有几个新功能

00:10:27.350 --> 00:10:34.000
方法之一，就是全部替换

00:10:29.480 --> 00:10:36.920
所以它能代替它

00:10:34.000 --> 00:10:39.860
列表中的每个元素都有

00:10:36.920 --> 00:10:43.279
否则，假设您想在

00:10:39.860 --> 00:10:45.559
在Java 7中，您可以再次使用

00:10:43.279 --> 00:10:48.129
老式的或原始的

00:10:45.559 --> 00:10:50.569
使用列表迭代器进行循环，然后

00:10:48.129 --> 00:10:51.829
这个例子是假设你

00:10:50.569 --> 00:10:54.980
想遍历字符串列表

00:10:51.829 --> 00:10:57.199
并将它们全部转换为大写

00:10:54.980 --> 00:11:00.499
可以在列表上运行列表迭代器

00:10:57.199 --> 00:11:02.629
并将每个元素设置为

00:11:00.499 --> 00:11:05.839
转换后的大写字母，所以这是顶部

00:11:02.629 --> 00:11:07.610
那里的代码段，但大多数人没有

00:11:05.839 --> 00:11:09.890
做到那我从来没有做过任何人

00:11:07.610 --> 00:11:13.100
您列出迭代器的任何举手

00:11:09.890 --> 00:11:14.690
在这里不，我想我的意思是Lissa diretor 

00:11:13.100 --> 00:11:18.470
这是有趣而强大的，但我

00:11:14.690 --> 00:11:23.480
认为没有人很好地使用它， 

00:11:18.470 --> 00:11:24.800
原因是如果您有不同

00:11:23.480 --> 00:11:28.190
种类的清单，那么您想要

00:11:24.800 --> 00:11:29.630
使用抽象的方式遍历它们

00:11:28.190 --> 00:11:31.760
使用列表迭代器，但由于

00:11:29.630 --> 00:11:33.410
每个人都在使用ArrayList 

00:11:31.760 --> 00:11:34.970
最好只是索引进去等等

00:11:33.410 --> 00:11:36.769
那是这里的第二个代码块

00:11:34.970 --> 00:11:38.870
认为每个人都可能会写

00:11:36.769 --> 00:11:42.140
这样或者你只是从零索引到

00:11:38.870 --> 00:11:44.690
大小，然后设置您知道只是设置

00:11:42.140 --> 00:11:46.459
并使用索引操作

00:11:44.690 --> 00:11:48.980
如果你知道那很好

00:11:46.459 --> 00:11:50.660
您正在对ArrayList进行操作，如果

00:11:48.980 --> 00:11:52.880
您正在操作一个链表，然后

00:11:50.660 --> 00:11:54.649
会大大减慢速度，但是你应该

00:11:52.880 --> 00:11:59.029
无论如何使用链接列表，那就是

00:11:54.649 --> 00:12:01.310
那是另一回事，所以无论如何

00:11:59.029 --> 00:12:03.019
 Java 8变得更好，所以我们

00:12:01.310 --> 00:12:05.120
只是称为全部替换方法而

00:12:03.019 --> 00:12:08.720
给它一个lambda函数或方法

00:12:05.120 --> 00:12:11.959
这种情况下的参考

00:12:08.720 --> 00:12:13.519
这个元素，所以我们说字符串冒号冒号

00:12:11.959 --> 00:12:16.430
大写，所以需要一个字符串

00:12:13.519 --> 00:12:18.800
将其转换为大写并替换所有

00:12:16.430 --> 00:12:20.990
贯穿于每个元素

00:12:18.800 --> 00:12:24.110
用大写字母替换它

00:12:20.990 --> 00:12:26.149
等价的，所以在一行中

00:12:24.110 --> 00:12:28.699
取代了那种做的循环

00:12:26.149 --> 00:12:30.290
一次只发生一件事情

00:12:28.699 --> 00:12:32.120
人们看到这个，他们经常说哦，我想要

00:12:30.290 --> 00:12:36.019
更改我想更改此列表，以便

00:12:32.120 --> 00:12:37.730
每个元素都被转化了

00:12:36.019 --> 00:12:40.490
变成不同的东西

00:12:37.730 --> 00:12:42.230
键入，而替换则无法做到

00:12:40.490 --> 00:12:44.870
您需要使用流的全部

00:12:42.230 --> 00:12:46.160
流出元素来转换它们

00:12:44.870 --> 00:12:49.870
变成不同类型的东西

00:12:46.160 --> 00:12:49.870
然后将它们收集到新列表中

00:12:49.990 --> 00:12:57.410
好了，所以添加了另一种方法

00:12:53.930 --> 00:13:00.199
到列表界面的排序很好

00:12:57.410 --> 00:13:02.240
大笔交易而不是催款

00:13:00.199 --> 00:13:04.279
在仅称为列表点的列表上进行排序

00:13:02.240 --> 00:13:13.160
排序是什么让你买得好

00:13:04.279 --> 00:13:18.560
几件事情，所以收集点

00:13:13.160 --> 00:13:21.050
排序方法必须对列表进行操作

00:13:18.560 --> 00:13:23.869
任何实施

00:13:21.050 --> 00:13:27.740
所以最通用的方式

00:13:23.869 --> 00:13:31.220
即复制出列表元素

00:13:27.740 --> 00:13:33.889
到一个数组中排序将是一个

00:13:31.220 --> 00:13:35.300
临时数组

00:13:33.889 --> 00:13:37.970
仅出于以下目的分配

00:13:35.300 --> 00:13:43.579
对数组进行排序，然后

00:13:37.970 --> 00:13:45.379
复制所有这些元素，所以

00:13:43.579 --> 00:13:48.800
列表点排序的默认实现

00:13:45.379 --> 00:13:50.990
这样做是因为它没有

00:13:48.800 --> 00:13:53.600
知道它是谁继承的

00:13:50.990 --> 00:13:55.059
 ArrayList点再次排序ArrayList正在

00:13:53.600 --> 00:13:57.860
最常用的收藏

00:13:55.059 --> 00:14:01.610
 ArrayList点排序将覆盖默认值

00:13:57.860 --> 00:14:03.709
实施，并说我是

00:14:01.610 --> 00:14:06.139
 ArrayList我知道我拥有所有元素

00:14:03.709 --> 00:14:08.300
存储在内部数组中

00:14:06.139 --> 00:14:09.470
我只是将它们排序到位

00:14:08.300 --> 00:14:12.290
有一种叫做数组点排序的东西

00:14:09.470 --> 00:14:15.769
所以它要做的就是转身并呼叫

00:14:12.290 --> 00:14:19.189
凸起的点在其内部数组上排序

00:14:15.769 --> 00:14:20.990
所以我们已经保存了一堆

00:14:19.189 --> 00:14:24.050
内存分配，我们保存了副本

00:14:20.990 --> 00:14:26.600
出并复制回来，以便覆盖

00:14:24.050 --> 00:14:30.649
商店的人实际上正在购买我们

00:14:26.600 --> 00:14:32.360
这里有很多，反过来又是收藏

00:14:30.649 --> 00:14:36.319
那种转身就叫

00:14:32.360 --> 00:14:37.519
在提供的列表上排序

00:14:36.319 --> 00:14:39.379
所以你甚至不需要改变你的

00:14:37.519 --> 00:14:40.879
代码，如果您的代码使用数组

00:14:39.379 --> 00:14:46.850
列表，然后调用集合点排序

00:14:40.879 --> 00:14:52.730
您将免费获得所有这种新行为

00:14:46.850 --> 00:14:54.259
现在我要去地图上

00:14:52.730 --> 00:14:56.059
一大堆方法添加到地图

00:14:54.259 --> 00:14:57.860
但是我要经历

00:14:56.059 --> 00:14:59.779
大多数更有趣的

00:14:57.860 --> 00:15:03.529
在这里，但是他们远远超出了我的能力

00:14:59.779 --> 00:15:06.350
在本次演讲中介绍，因此在Java 7中

00:15:03.529 --> 00:15:08.600
想为每个元素做点什么

00:15:06.350 --> 00:15:11.059
像打印出来的地图一样，您知道打印

00:15:08.600 --> 00:15:15.189
找出您要打印的键值

00:15:11.059 --> 00:15:19.069
列出您会使用的每个键值

00:15:15.189 --> 00:15:20.929
通常会在

00:15:19.069 --> 00:15:23.179
地图，然后做一些有用的事情

00:15:20.929 --> 00:15:25.910
在for循环中，所以在java 8中

00:15:23.179 --> 00:15:27.799
在地图上每个都有一个

00:15:25.910 --> 00:15:31.670
有点像每个间隔

00:15:27.799 --> 00:15:32.959
除了不取而代之

00:15:31.670 --> 00:15:34.430
采取一项需要一项的职能

00:15:32.959 --> 00:15:37.470
论点

00:15:34.430 --> 00:15:38.700
通过带有两个参数的函数

00:15:37.470 --> 00:15:39.960
关键和价值

00:15:38.700 --> 00:15:44.310
所以你可以写一个lambda表达式

00:15:39.960 --> 00:15:46.110
那做到了，你知道那是

00:15:44.310 --> 00:15:47.700
主要是句法技巧，但它又是什么

00:15:46.110 --> 00:15:49.860
就是这样，而不是您不必

00:15:47.700 --> 00:15:52.050
遍历地图条目，然后执行

00:15:49.860 --> 00:15:54.600
获得关键并获得价值，这一切就交给您

00:15:52.050 --> 00:15:58.980
键和值分别是

00:15:54.600 --> 00:16:01.230
这样更方便

00:15:58.980 --> 00:16:05.340
列出还有一个替换所有

00:16:01.230 --> 00:16:08.400
地图，因此您可以再次使用Java 

00:16:05.340 --> 00:16:12.630
 7你必须在每个上面写一个for循环

00:16:08.400 --> 00:16:15.810
条目映射条目具有设置值方法

00:16:12.630 --> 00:16:18.660
因此您实际上可以修改

00:16:15.810 --> 00:16:20.280
基础条目到位，但替换

00:16:18.660 --> 00:16:21.930
一切都是为了你，所以

00:16:20.280 --> 00:16:24.660
这里的语义是lambda 

00:16:21.930 --> 00:16:27.150
它需要两个参数键和

00:16:24.660 --> 00:16:30.690
值，返回值为

00:16:27.150 --> 00:16:33.210
重置价值，所以如果我们想

00:16:30.690 --> 00:16:36.120
更改所有地图中的值

00:16:33.210 --> 00:16:38.840
大写我们只是在这里写

00:16:36.120 --> 00:16:41.370
箭头，然后将v点调用为大写

00:16:38.840 --> 00:16:42.750
所以这是有限的，我的意思是如果你

00:16:41.370 --> 00:16:45.900
想要做到这一点真是太好了

00:16:42.750 --> 00:16:48.060
但它只能更改

00:16:45.900 --> 00:16:50.100
地图，您不能更改键，也不能

00:16:48.060 --> 00:16:51.990
将任一键的类型更改为

00:16:50.100 --> 00:16:53.490
值，所以那里有限制

00:16:51.990 --> 00:16:55.770
如果你想做那些事

00:16:53.490 --> 00:16:57.660
越过溪流越过

00:16:55.770 --> 00:17:01.350
地图条目并进行转换

00:16:57.660 --> 00:17:03.810
这样一来，现在这里有点

00:17:01.350 --> 00:17:05.970
一个扩展的例子，我要设置

00:17:03.810 --> 00:17:08.640
通过谈论多张地图

00:17:05.970 --> 00:17:12.050
许多人都熟悉但

00:17:08.640 --> 00:17:16.440
如果您有一个关于

00:17:12.050 --> 00:17:19.050
内置地图需要一个具有键值对的

00:17:16.440 --> 00:17:22.080
但最重要的是，它们适合每个人

00:17:19.050 --> 00:17:24.120
键中只有一个值

00:17:22.080 --> 00:17:26.040
很多情况下，您可能需要数据

00:17:24.120 --> 00:17:29.730
您具有映射键的结构

00:17:26.040 --> 00:17:31.590
多个值等等

00:17:29.730 --> 00:17:34.620
 eclipse集合之类的库

00:17:31.590 --> 00:17:37.770
番石榴有多套请问多地图

00:17:34.620 --> 00:17:41.970
 JDK中内置的数据结构不

00:17:37.770 --> 00:17:43.410
有一个，有时如果你不能使用

00:17:41.970 --> 00:17:45.900
这些库之一，您必须

00:17:43.410 --> 00:17:48.150
就是说我不能使用多地图

00:17:45.900 --> 00:17:52.740
所以我会写一张地图

00:17:48.150 --> 00:17:55.680
从说如果我想从字符串映射

00:17:52.740 --> 00:17:58.530
到多个整数我将有映射

00:17:55.680 --> 00:18:01.170
从字符串到整数集，仅

00:17:58.530 --> 00:18:04.050
将其存储在常规哈希图和

00:18:01.170 --> 00:18:06.540
 Java 7和更早版本中的七个

00:18:04.050 --> 00:18:09.750
实际上变得非常痛苦，所以这是

00:18:06.540 --> 00:18:13.320
一些代码，如果我想放一个

00:18:09.750 --> 00:18:19.670
值字符串字符串和一个整数

00:18:13.320 --> 00:18:19.670
我的多张地图，那么我首先要说好

00:18:20.090 --> 00:18:24.120
获取密钥的值以查看是否

00:18:22.320 --> 00:18:25.590
那里已经有一套了

00:18:24.120 --> 00:18:28.500
不是，那么我必须创建一个集合

00:18:25.590 --> 00:18:31.320
把它放进地图，然后最后

00:18:28.500 --> 00:18:34.260
之后，我必须添加新的整数

00:18:31.320 --> 00:18:36.210
值中有一个相似的

00:18:34.260 --> 00:18:40.020
规则以外的东西

00:18:36.210 --> 00:18:43.320
我问你得到对应的值

00:18:40.020 --> 00:18:45.360
这个键，如果它不是非null，那么我去

00:18:43.320 --> 00:18:47.550
提前将其从集合中删除哦，但是

00:18:45.360 --> 00:18:49.290
另外，如果现在变得空了，我想要

00:18:47.550 --> 00:18:51.480
去掉整个东西，实际上

00:18:49.290 --> 00:18:53.850
好吧，我不在幻灯片上了

00:18:51.480 --> 00:18:57.990
所以已经是代码了

00:18:53.850 --> 00:18:59.970
已经太庞大了，所以事实证明

00:18:57.990 --> 00:19:01.980
 Java 8中有很多新方法

00:18:59.970 --> 00:19:05.090
使事情像做某事一样

00:19:01.980 --> 00:19:08.220
这真的很容易，所以其中之一是

00:19:05.090 --> 00:19:11.160
计算是否缺少有趣的是

00:19:08.220 --> 00:19:13.710
并发哈希映射之前

00:19:11.160 --> 00:19:16.710
 Java 8之所以拥有这些功能，是因为您

00:19:13.710 --> 00:19:19.860
确实需要原子复合操作

00:19:16.710 --> 00:19:21.930
在并发映射上并发

00:19:19.860 --> 00:19:26.580
这些中的一些已经被提升

00:19:21.930 --> 00:19:28.860
 Java 8中的主地图界面

00:19:26.580 --> 00:19:30.930
无论如何，请计算是否缺少

00:19:28.860 --> 00:19:33.630
有趣的是，它的作用是

00:19:30.930 --> 00:19:38.580
它评估lambda表达式

00:19:33.630 --> 00:19:40.800
如果没有密钥，则通过它

00:19:38.580 --> 00:19:44.450
然后它的结果和

00:19:40.800 --> 00:19:46.620
将其存储在地图中，有趣的是

00:19:44.450 --> 00:19:49.800
不管它是否真的

00:19:46.620 --> 00:19:53.610
该计算是否返回

00:19:49.800 --> 00:19:54.870
对应于键的值，这样您

00:19:53.610 --> 00:19:56.850
必须通过一点点

00:19:54.870 --> 00:20:00.299
仔细但基本上这样做

00:19:56.850 --> 00:20:03.419
添加新的哈希集（如果不存在） 

00:20:00.299 --> 00:20:05.700
然后，使我们有一个设定值

00:20:03.419 --> 00:20:07.499
多图等等从中得到什么

00:20:05.700 --> 00:20:09.809
缺席的计算是整数集

00:20:07.499 --> 00:20:11.519
然后我们继续进行添加

00:20:09.809 --> 00:20:13.169
所以我不会经历所有的

00:20:11.519 --> 00:20:15.509
这些详细，但您可以看到

00:20:13.169 --> 00:20:16.859
他们有相同的味道

00:20:15.509 --> 00:20:18.989
以同样的方式

00:20:16.859 --> 00:20:22.709
那里的表情很复杂，但是

00:20:18.989 --> 00:20:25.019
删除可以做的实际上是这样的

00:20:22.709 --> 00:20:29.239
有一个对偶要计算，如果

00:20:25.019 --> 00:20:32.639
如果存在则不计算

00:20:29.239 --> 00:20:34.200
这些可以做什么是如果返回值

00:20:32.639 --> 00:20:37.729
为null，实际上具有

00:20:34.200 --> 00:20:40.379
从地图上删除地图，如此

00:20:37.729 --> 00:20:44.219
如果您使用多地图样式

00:20:40.379 --> 00:20:46.769
收集他们通常的地图种类

00:20:44.219 --> 00:20:48.450
像我显示的操作删除

00:20:46.769 --> 00:20:51.179
包含大小值等等

00:20:48.450 --> 00:20:53.639
基本上使用新的默认方法

00:20:51.179 --> 00:20:56.129
在地图上所有这些都变成了单线

00:20:53.639 --> 00:20:58.379
所以如果你不需要一个完整的

00:20:56.129 --> 00:20:59.940
多地图实施和大多数

00:20:58.379 --> 00:21:01.799
应用程序也许你不只是放一个

00:20:59.940 --> 00:21:04.049
一堆东​​西然后说好吧我

00:21:01.799 --> 00:21:06.239
想要你知道我想要我想要

00:21:04.049 --> 00:21:08.399
处理这些特殊情况，您可以

00:21:06.239 --> 00:21:10.950
你可以得到你的效果

00:21:08.399 --> 00:21:14.609
通过实施一些自己的多地图

00:21:10.950 --> 00:21:16.200
这些单线的，所以实际上

00:21:14.609 --> 00:21:18.209
还不到一半，所以我展示

00:21:16.200 --> 00:21:20.369
计算机（如果没有），并且

00:21:18.209 --> 00:21:23.549
得到我们的默认值是新方法

00:21:20.369 --> 00:21:25.049
地图上有新的默认方法

00:21:23.549 --> 00:21:26.279
认为我什至不去

00:21:25.049 --> 00:21:28.469
经历他们，他们都是一堆

00:21:26.279 --> 00:21:31.019
而你要做的就是经历

00:21:28.469 --> 00:21:32.399
 Java文档并查找事物

00:21:31.019 --> 00:21:36.629
在地图界面上

00:21:32.399 --> 00:21:39.659
从1.8开始，但无论如何我认为这些是

00:21:36.629 --> 00:21:41.159
这里最有趣的

00:21:39.659 --> 00:21:43.859
所以我们还有另一个界面

00:21:41.159 --> 00:21:52.049
在Java 8上花了很多时间

00:21:43.859 --> 00:21:54.359
是比较器，现在比较器在

00:21:52.049 --> 00:21:55.649
他们最简单的形式很容易，但是

00:21:54.359 --> 00:21:58.589
当他们变得复杂时，他们会得到

00:21:55.649 --> 00:21:59.999
我真的很复杂而且容易出错

00:21:58.589 --> 00:22:02.279
认为那里还有其他话题

00:21:59.999 --> 00:22:05.789
关于比较器本身

00:22:02.279 --> 00:22:07.979
但是我们在Java 8中所做的是添加了一个

00:22:05.789 --> 00:22:11.099
一堆辅助方法或组合器

00:22:07.979 --> 00:22:14.330
哪个结构简单

00:22:11.099 --> 00:22:18.780
比较器，然后你也来

00:22:14.330 --> 00:22:21.540
比较器返回以创建新的

00:22:18.780 --> 00:22:24.480
比较器提供更复杂的

00:22:21.540 --> 00:22:26.100
有趣的行为等等

00:22:24.480 --> 00:22:28.770
应该让你做，不是

00:22:26.100 --> 00:22:31.440
在那里，但可能很大

00:22:28.770 --> 00:22:33.720
这些新方法所占的比例很小

00:22:31.440 --> 00:22:37.910
允许你做的就是牵一手

00:22:33.720 --> 00:22:41.309
编码开放逻辑并将其压缩成

00:22:37.910 --> 00:22:44.309
功能基本上是连续调用

00:22:41.309 --> 00:22:48.780
这些比较器方法提供

00:22:44.309 --> 00:22:51.210
提供复合功能

00:22:48.780 --> 00:22:52.740
让事情变得更加整洁，所以我

00:22:51.210 --> 00:22:55.470
通过一个简单的例子

00:22:52.740 --> 00:22:58.440
这里是两级排序

00:22:55.470 --> 00:22:59.760
假设你有一个人班

00:22:58.440 --> 00:23:02.280
学生课之类的

00:22:59.760 --> 00:23:04.290
只是说学生有姓， 

00:23:02.280 --> 00:23:06.690
名，所以我想做第一个

00:23:04.290 --> 00:23:09.420
对学生的姓氏进行等级排序，然后

00:23:06.690 --> 00:23:11.340
然后对于那些具有相同

00:23:09.420 --> 00:23:13.740
我想做第二个名字

00:23:11.340 --> 00:23:15.720
按名字排序，但也有

00:23:13.740 --> 00:23:18.210
一个渔获物，因为也许我们没有

00:23:15.720 --> 00:23:19.770
也许我们没有所有人的名字

00:23:18.210 --> 00:23:22.320
学生和名字可能是

00:23:19.770 --> 00:23:25.880
 null，因此，如果学生的名字是

00:23:22.320 --> 00:23:28.950
 null，那么这些应该在之前排序

00:23:25.880 --> 00:23:31.860
在所有其他具有

00:23:28.950 --> 00:23:34.440
非null名可以，所以让我们

00:23:31.860 --> 00:23:35.940
看看您在Java 7中要做的

00:23:34.440 --> 00:23:37.200
这样做我不会接手

00:23:35.940 --> 00:23:39.000
所有这些代码，但您可以

00:23:37.200 --> 00:23:40.980
盯着它说好吧，我们得到了最后一个

00:23:39.000 --> 00:23:43.530
给你起个名字，然后比较

00:23:40.980 --> 00:23:45.059
因此，如果姓氏相等，则和

00:23:43.530 --> 00:23:46.260
得到名字然后我们做空测试

00:23:45.059 --> 00:23:48.690
然后你知道有一点

00:23:46.260 --> 00:23:51.300
在这里跳舞的感觉，我很漂亮

00:23:48.690 --> 00:23:52.679
确保此代码正确，但我不正确

00:23:51.300 --> 00:23:55.400
完全确定您可以选择

00:23:52.679 --> 00:23:58.050
实际上，如果我介绍了该错误， 

00:23:55.400 --> 00:23:59.850
真的很难看到

00:23:58.050 --> 00:24:01.950
实际上有一个错误，因为有

00:23:59.850 --> 00:24:04.200
很多很多小条件

00:24:01.950 --> 00:24:05.910
如果您交换，这里有很多小细节

00:24:04.200 --> 00:24:11.400
一个错误的地方和一个错误的地方

00:24:05.910 --> 00:24:12.600
你知道男孩真的很难

00:24:11.400 --> 00:24:13.230
真的很难确定

00:24:12.600 --> 00:24:15.809
检查

00:24:13.230 --> 00:24:17.520
除非你做的就是你出去得到

00:24:15.809 --> 00:24:19.050
一些样本数据并进行选择或

00:24:17.520 --> 00:24:22.140
逐步解决任何错误或其他问题

00:24:19.050 --> 00:24:24.620
这样的东西写这个

00:24:22.140 --> 00:24:26.600
东西真的很容易出错

00:24:24.620 --> 00:24:28.400
我在Stack上看到很多问题

00:24:26.600 --> 00:24:30.500
溢出和论坛出了什么问题

00:24:28.400 --> 00:24:32.059
和我的比较器等等

00:24:30.500 --> 00:24:34.430
不足为奇，因为这真的

00:24:32.059 --> 00:24:35.990
它真的很详细，如果您不

00:24:34.430 --> 00:24:40.370
完全正确，你有一个微妙的地方

00:24:35.990 --> 00:24:42.950
可以蔓延的错误

00:24:40.370 --> 00:24:44.630
 Java 8好的，这是一个

00:24:42.950 --> 00:24:47.480
一点重构，所以

00:24:44.630 --> 00:24:49.370
呼叫收集停止排序的过程

00:24:47.480 --> 00:24:51.140
学生认为排序而不是

00:24:49.370 --> 00:24:54.320
使用匿名内部类，我们

00:24:51.140 --> 00:24:57.140
转换成lambda，你知道

00:24:54.320 --> 00:24:58.970
可以帮助您知道10％正确，所以我们得到了

00:24:57.140 --> 00:25:02.720
摆脱线条或样板代码

00:24:58.970 --> 00:25:05.690
但基本上是大量的自定义逻辑

00:25:02.720 --> 00:25:07.040
比较器内部本身是相同的

00:25:05.690 --> 00:25:11.750
而且遭受同样的痛苦

00:25:07.040 --> 00:25:14.320
问题，不幸的是我没有

00:25:11.750 --> 00:25:16.820
是时候详细介绍了，但是

00:25:14.320 --> 00:25:20.090
您必须相信我，这段代码

00:25:16.820 --> 00:25:22.580
是等价于

00:25:20.090 --> 00:25:24.290
上一张幻灯片，所以我们要做的是

00:25:22.580 --> 00:25:27.920
有一种叫做

00:25:24.290 --> 00:25:29.960
比较器点比较，它需要

00:25:27.920 --> 00:25:31.790
我们称之为密钥提取器

00:25:29.960 --> 00:25:33.980
如果是姓氏，那只是一个

00:25:31.790 --> 00:25:36.260
函数或只是获得

00:25:33.980 --> 00:25:39.410
超出你的目标

00:25:36.260 --> 00:25:42.110
有趣的是典型的Parador 

00:25:39.410 --> 00:25:44.540
是我想要获得的高度程式化的代码

00:25:42.110 --> 00:25:46.160
我要获取的对象的字段

00:25:44.540 --> 00:25:48.140
该对象的字段，然后

00:25:46.160 --> 00:25:51.260
比较它们，所以不用写

00:25:48.140 --> 00:25:54.710
手工比较出来的

00:25:51.260 --> 00:25:56.360
点比较为您做到了，所以

00:25:54.710 --> 00:25:58.730
你只说我想要哪个领域

00:25:56.360 --> 00:26:00.670
要获得好名字，可以有一个

00:25:58.730 --> 00:26:04.880
比较姓氏的比较器

00:26:00.670 --> 00:26:05.750
比较器上还有另一种方法

00:26:04.880 --> 00:26:09.650
叫

00:26:05.750 --> 00:26:13.760
然后比较，所以如果我有五个

00:26:09.650 --> 00:26:14.929
比较器和第一个比较器

00:26:13.760 --> 00:26:18.130
第一次调用的结果

00:26:14.929 --> 00:26:21.320
比较器是值相等

00:26:18.130 --> 00:26:23.390
然后我想应用二级排序

00:26:21.320 --> 00:26:25.760
那就是比较的结果

00:26:23.390 --> 00:26:27.679
它需要两个比较器并粉碎

00:26:25.760 --> 00:26:30.200
他们以这种特殊的方式在一起

00:26:27.679 --> 00:26:31.820
给您一个两级排序，而不是

00:26:30.200 --> 00:26:33.950
有很多条件逻辑

00:26:31.820 --> 00:26:36.410
为您做到这一点，它可以让您

00:26:33.950 --> 00:26:37.600
从中建立这个复合比较器

00:26:36.410 --> 00:26:40.180
较小的比较器

00:26:37.600 --> 00:26:43.720
然后Noel首先是

00:26:40.180 --> 00:26:46.690
同样的事情，所以通常我们想做一个

00:26:43.720 --> 00:26:48.100
字符串比较，但是如果字符串

00:26:46.690 --> 00:26:49.030
为null，那么您将获得null 

00:26:48.100 --> 00:26:51.040
指针异常

00:26:49.030 --> 00:26:53.320
那么null首先是另一个实用程序

00:26:51.040 --> 00:26:55.300
好的方法，我要去做

00:26:53.320 --> 00:26:57.640
比较，我想对null进行排序

00:26:55.300 --> 00:26:59.410
首先将其放在一边，然后

00:26:57.640 --> 00:27:01.690
对于非null的东西，它只是调用

00:26:59.410 --> 00:27:03.760
再次调用常规比较器

00:27:01.690 --> 00:27:06.910
这里的味道是我们正在建立

00:27:03.760 --> 00:27:08.530
建立一个复杂的比较器

00:27:06.910 --> 00:27:11.200
奇怪的条件和东西，你

00:27:08.530 --> 00:27:13.300
在上一张幻灯片上看到了

00:27:11.200 --> 00:27:17.320
一点点的碎片，所以我们从一个

00:27:13.300 --> 00:27:21.940
自然顺序，我们首先对空值进行排序

00:27:17.320 --> 00:27:23.620
然后我们对结果进行排序

00:27:21.940 --> 00:27:25.570
关于这个的名字就是

00:27:23.620 --> 00:27:27.940
二级比较

00:27:25.570 --> 00:27:29.860
获得姓氏的第一级比较

00:27:27.940 --> 00:27:35.620
所以里面有很多东西

00:27:29.860 --> 00:27:37.660
节省您精力的这段代码

00:27:35.620 --> 00:27:39.520
写所有复杂的

00:27:37.660 --> 00:27:41.200
上一张幻灯片中的条件逻辑

00:27:39.520 --> 00:27:44.230
我应该放这张幻灯片，因为

00:27:41.200 --> 00:27:46.270
这种解释在这里，但无论如何

00:27:44.230 --> 00:27:48.640
那基本上就是说我在说什么

00:27:46.270 --> 00:27:50.260
只是试图解释，所以我会做

00:27:48.640 --> 00:27:51.970
确保这张幻灯片被张贴等等

00:27:50.260 --> 00:27:59.470
你可以仔细看看

00:27:51.970 --> 00:28:01.930
之后没事了，所以在此之后

00:27:59.470 --> 00:28:06.370
到Java 8段的结尾， 

00:28:01.930 --> 00:28:07.200
我现在可以开始谈论Java 9 

00:28:06.370 --> 00:28:12.490
对

00:28:07.200 --> 00:28:16.840
好吧，那一点点的历史

00:28:12.490 --> 00:28:18.700
 Java 9中有

00:28:16.840 --> 00:28:21.640
这些年来，我们付出了很多努力

00:28:18.700 --> 00:28:24.490
 Java添加集合文字

00:28:21.640 --> 00:28:27.340
一直被提议为语言

00:28:24.490 --> 00:28:29.320
 Java 7中的增强功能有一个项目

00:28:27.340 --> 00:28:31.060
硬币和其中一项提案

00:28:29.320 --> 00:28:33.370
招待是要添加收藏

00:28:31.060 --> 00:28:35.580
文字和一些建议被提出

00:28:33.370 --> 00:28:39.640
周围，​​但那从未到过

00:28:35.580 --> 00:28:42.280
 Java 8之后，有了一个JEP JDK 

00:28:39.640 --> 00:28:44.410
增强建议有点奇怪

00:28:42.280 --> 00:28:46.930
这是一架研究喷气机，但基本上

00:28:44.410 --> 00:28:49.810
想法是要确定什么是

00:28:46.930 --> 00:28:51.070
需要将集合文字添加到

00:28:49.810 --> 00:28:54.340
语言和

00:28:51.070 --> 00:28:56.350
结果是我们的决定

00:28:54.340 --> 00:29:02.559
不会将集合文字添加到

00:28:56.350 --> 00:29:05.889
语言，这是我认为

00:29:02.559 --> 00:29:09.669
最简洁的解释方式

00:29:05.889 --> 00:29:13.480
决定是要观察到

00:29:09.669 --> 00:29:16.240
 Java拥有的其他语言和系统

00:29:13.480 --> 00:29:18.519
明确定义的架构

00:29:16.240 --> 00:29:20.590
 JVM与Java分开

00:29:18.519 --> 00:29:22.509
编程语言和编程

00:29:20.590 --> 00:29:25.029
语言又与

00:29:22.509 --> 00:29:29.919
图书馆和馆藏是图书馆

00:29:25.029 --> 00:29:32.139
构建，所以如果您混合考虑

00:29:29.919 --> 00:29:35.679
收集太紧密了

00:29:32.139 --> 00:29:38.110
编程语言本身然后是事物

00:29:35.679 --> 00:29:40.710
变得非常不舒服，所以

00:29:38.110 --> 00:29:42.820
问题是假设的，因为我们有一个

00:29:40.710 --> 00:29:45.850
创建的编程语言语法

00:29:42.820 --> 00:29:47.710
列表好吧，什么列出了您的

00:29:45.850 --> 00:29:50.289
那海滩应该是ArrayList好

00:29:47.710 --> 00:29:52.419
 ArrayList对于很多事情都可以，但是

00:29:50.289 --> 00:29:54.159
假设我希望它是可变的假设我

00:29:52.419 --> 00:29:58.870
希望它稀疏或假设我想要

00:29:54.159 --> 00:29:59.980
变成别的东西，所以

00:29:58.870 --> 00:30:01.870
不会太难做

00:29:59.980 --> 00:30:03.879
语言上有些简单化，但

00:30:01.870 --> 00:30:05.679
那会太紧密地绑定到

00:30:03.879 --> 00:30:08.649
中的特定实现

00:30:05.679 --> 00:30:10.750
图书馆，所以如果我们不想那样

00:30:08.649 --> 00:30:13.559
紧密绑定，那么我们必须设计一个

00:30:10.750 --> 00:30:17.080
以某种方式编程的语言

00:30:13.559 --> 00:30:20.049
与图书馆的联系更加宽松

00:30:17.080 --> 00:30:21.970
也许最终打电话给收藏

00:30:20.049 --> 00:30:24.190
建设者之类的东西，但基本上

00:30:21.970 --> 00:30:28.059
因为语言和图书馆是

00:30:24.190 --> 00:30:29.320
是二号建筑

00:30:28.059 --> 00:30:32.710
像集合文字

00:30:29.320 --> 00:30:34.870
事实证明这是一个很大的数目

00:30:32.710 --> 00:30:38.409
如果我们想保留

00:30:34.870 --> 00:30:40.690
保存收藏的灵活性

00:30:38.409 --> 00:30:43.480
框架距离

00:30:40.690 --> 00:30:45.759
所以无论如何编程语言

00:30:43.480 --> 00:30:47.830
结果是我们决定不添加

00:30:45.759 --> 00:30:50.590
语言的集合文字和

00:30:47.830 --> 00:30:53.110
相反，我们说的是让我们添加一些

00:30:50.590 --> 00:30:55.659
现有的便捷api 

00:30:53.110 --> 00:31:00.179
收藏框架，这将得到

00:30:55.659 --> 00:31:00.179
我们大概有80％的收益

00:31:00.990 --> 00:31:06.420
集合字面量，但很多

00:31:04.350 --> 00:31:09.000
做起来要简单得多，这是一个图书馆

00:31:06.420 --> 00:31:10.620
唯一的构造，所以只有AP是我们

00:31:09.000 --> 00:31:13.410
不必我们不必做

00:31:10.620 --> 00:31:14.850
对JVM或

00:31:13.410 --> 00:31:16.140
编程语言或编译器或

00:31:14.850 --> 00:31:19.260
他们只是他们的新事物

00:31:16.140 --> 00:31:21.270
库API，它们非常有用

00:31:19.260 --> 00:31:23.250
在某些情况下

00:31:21.270 --> 00:31:27.600
很高兴为此提供语言支持，但

00:31:23.250 --> 00:31:29.250
我一会儿再谈

00:31:27.600 --> 00:31:31.200
否则我觉得它挺漂亮的

00:31:29.250 --> 00:31:32.429
好，它们非常有用，我

00:31:31.200 --> 00:31:36.470
想你会喜欢他们

00:31:32.429 --> 00:31:39.059
好了，所以设计目标

00:31:36.470 --> 00:31:40.710
基本上，所以他们的便捷API和

00:31:39.059 --> 00:31:44.640
基本上都是静态工厂

00:31:40.710 --> 00:31:46.860
方法，所以我们要添加方法

00:31:44.640 --> 00:31:50.000
接口的静态方法

00:31:46.860 --> 00:31:53.370
产生收藏

00:31:50.000 --> 00:31:56.760
实例，所以这些新的主要目标

00:31:53.370 --> 00:31:58.800
 api既方便又简洁

00:31:56.760 --> 00:32:01.890
尽可能接近收藏

00:31:58.800 --> 00:32:04.200
尽可能多的文字，但我们想要它们

00:32:01.890 --> 00:32:06.270
为了节省空间，您可以获得一些

00:32:04.200 --> 00:32:09.390
如果您有空间效率

00:32:06.270 --> 00:32:10.890
不可变的集合，因为它不会

00:32:09.390 --> 00:32:13.770
需要修改就可以打包东西

00:32:10.890 --> 00:32:18.240
以不同的方式保存很多

00:32:13.770 --> 00:32:20.280
空间以及收藏

00:32:18.240 --> 00:32:22.350
返回的实例实际上是

00:32:20.280 --> 00:32:28.950
不变的，这是新事物

00:32:22.350 --> 00:32:30.240
在JDK中可以正常使用，所以JDK 

00:32:28.950 --> 00:32:32.040
 9正在进行中

00:32:30.240 --> 00:32:34.500
这项工作已经整合了很长时间

00:32:32.040 --> 00:32:37.320
以前是这样，所以任何最近的JDK 9构建

00:32:34.500 --> 00:32:40.130
里面有这些，所以我鼓励

00:32:37.320 --> 00:32:42.420
您下载JDK 9并试用

00:32:40.130 --> 00:32:44.880
但是有趣的是

00:32:42.420 --> 00:32:47.220
在其表面上添加这些

00:32:44.880 --> 00:32:48.510
 API就像您知道的

00:32:47.220 --> 00:32:50.130
一个小时的思想，你可以写出一个

00:32:48.510 --> 00:32:52.860
一堆写出的api和

00:32:50.130 --> 00:32:55.620
实现，我想我是这样做的

00:32:52.860 --> 00:32:57.090
事实上我做了几次，但是

00:32:55.620 --> 00:32:58.830
有趣的是

00:32:57.090 --> 00:33:00.720
潜伏的问题数量惊人

00:32:58.830 --> 00:33:02.610
根据表面和设计决策

00:33:00.720 --> 00:33:04.350
我们必须经历的是

00:33:02.610 --> 00:33:08.040
这就是剩下的话题

00:33:04.350 --> 00:33:12.720
大约这么快，这里是

00:33:08.040 --> 00:33:14.770
新的API在JDK 9中，因此

00:33:12.720 --> 00:33:18.190
清单

00:33:14.770 --> 00:33:20.350
取零一二实际上最多十

00:33:18.190 --> 00:33:22.630
参数然后列出来

00:33:20.350 --> 00:33:24.550
 varargs，以便使用

00:33:22.630 --> 00:33:27.840
无论您传递多少元素

00:33:24.550 --> 00:33:31.210
这是一组相同的东西

00:33:27.840 --> 00:33:35.230
还有地图的思想和数学是

00:33:31.210 --> 00:33:37.570
不同，因为它没有

00:33:35.230 --> 00:33:40.660
取一个单一类型的元素代替

00:33:37.570 --> 00:33:42.520
它必须采用键值对，因此对于

00:33:40.660 --> 00:33:45.190
固定数量的小钥匙

00:33:42.520 --> 00:33:48.670
值对，我们传递交替键和

00:33:45.190 --> 00:33:50.860
值，但如果您想要的不只是

00:33:48.670 --> 00:33:52.420
而且没有办法为

00:33:50.860 --> 00:33:55.170
所以，如果您想要更多我们

00:33:52.420 --> 00:33:58.870
添加了新的方法映射条目点

00:33:55.170 --> 00:34:01.270
好吧，出于效率考虑，所以

00:33:58.870 --> 00:34:03.550
这是Javadoc的快照

00:34:01.270 --> 00:34:06.810
地图界面，以便提高效率

00:34:03.550 --> 00:34:09.429
我们提供零到十的原因

00:34:06.810 --> 00:34:13.210
超过六个

00:34:09.429 --> 00:34:15.640
因为varargs不可避免地具有

00:34:13.210 --> 00:34:17.710
构建和复制的开销

00:34:15.640 --> 00:34:19.810
元素排列成一个数组

00:34:17.710 --> 00:34:24.850
为了避免避免我们提供六只狗

00:34:19.810 --> 00:34:26.169
超载，所以我不知道有多少

00:34:24.850 --> 00:34:28.540
你们中的一些人在开幕式上

00:34:26.169 --> 00:34:30.640
切特·海瑟给他你知道的时候

00:34:28.540 --> 00:34:31.330
我以为他谈技术生意

00:34:30.640 --> 00:34:35.220
很有趣

00:34:31.330 --> 00:34:37.630
我想像聊天一样有趣

00:34:35.220 --> 00:34:39.909
但我仍在努力，但我认为

00:34:37.630 --> 00:34:41.800
我有潜力，因为当我发布

00:34:39.909 --> 00:34:48.640
有人说的这个API是

00:34:41.800 --> 00:34:51.520
这是个玩笑，反正这是一些

00:34:48.640 --> 00:34:54.010
新API的示例正在

00:34:51.520 --> 00:34:55.360
 Java 8实际上这是三种

00:34:54.010 --> 00:34:58.900
例子在一起

00:34:55.360 --> 00:35:00.640
有列表集和地图，所以如果您

00:34:58.900 --> 00:35:03.250
需要创建一个列表数组作为

00:35:00.640 --> 00:35:05.530
如果您需要创建列表，还不错

00:35:03.250 --> 00:35:07.090
包含特定内容的哈希集

00:35:05.530 --> 00:35:08.920
最简单的事情是创建一个

00:35:07.090 --> 00:35:10.960
列表，然后将其放入哈希集，然后

00:35:08.920 --> 00:35:13.600
那我认为地图是最糟糕的

00:35:10.960 --> 00:35:16.000
创建地图，然后调用put 

00:35:13.600 --> 00:35:18.700
先后进入它并在底部

00:35:16.000 --> 00:35:22.000
您可以看到Java，我的意思是说

00:35:18.700 --> 00:35:27.250
套和数学汽车，这没关系

00:35:22.000 --> 00:35:29.350
那里很好，所以

00:35:27.250 --> 00:35:32.560
现在，这里有一个变化是

00:35:29.350 --> 00:35:35.110
如果您想使用

00:35:32.560 --> 00:35:36.880
任意数量的对，那么你有

00:35:35.110 --> 00:35:40.680
切换到该地图的

00:35:36.880 --> 00:35:44.520
带可变参数的entrys方法

00:35:40.680 --> 00:35:48.130
映射条目的varargs参数等等

00:35:44.520 --> 00:35:50.500
创建一个地图条目是可以的

00:35:48.130 --> 00:35:52.870
有点复杂，因为

00:35:50.500 --> 00:35:55.840
有一张最常见的地图

00:35:52.870 --> 00:35:57.550
地图条目的实现是抽象的

00:35:55.840 --> 00:36:00.160
地图寻求简单的不可变条目， 

00:35:57.550 --> 00:36:02.530
足够一口，所以其中之一

00:36:00.160 --> 00:36:05.410
这增加的其他内容是静态的

00:36:02.530 --> 00:36:08.080
工厂方法称为数学点输入

00:36:05.410 --> 00:36:09.850
只需要两个的小写条目

00:36:08.080 --> 00:36:13.210
给一个键和一个值做参数并返回

00:36:09.850 --> 00:36:15.430
地图条目实例，所以这是一个

00:36:13.210 --> 00:36:17.620
的例子，因为这超出了

00:36:15.430 --> 00:36:20.530
编号六个加星标的变体

00:36:17.620 --> 00:36:22.150
修复了映射的arg超载，因此我们

00:36:20.530 --> 00:36:25.390
必须要使用的地图点

00:36:22.150 --> 00:36:34.330
条目，然后通过它，您知道一个

00:36:25.390 --> 00:36:36.550
入口对象的继承可以

00:36:34.330 --> 00:36:38.710
他们是一堆设计， 

00:36:36.550 --> 00:36:40.450
我提到的实施问题

00:36:38.710 --> 00:36:42.430
较早，所以我要逐步

00:36:40.450 --> 00:36:45.400
这些在这里和时间都很快

00:36:42.430 --> 00:36:47.440
剩下的，所以处理

00:36:45.400 --> 00:36:50.200
我是任意数量的映射

00:36:47.440 --> 00:36:53.080
我刚才所说的我们就结束了

00:36:50.200 --> 00:36:55.120
在考虑了该解决方案之后

00:36:53.080 --> 00:36:57.130
我约有十五种其他选择

00:36:55.120 --> 00:36:58.720
我应该在某个时候写下来吗

00:36:57.130 --> 00:37:02.260
这些都是有趣的

00:36:58.720 --> 00:37:03.490
有优点和缺点，但是当你有

00:37:02.260 --> 00:37:05.500
当您面临很多选择时

00:37:03.490 --> 00:37:07.090
你不能只是看着说我喜欢

00:37:05.500 --> 00:37:08.230
这个比那个更好，所以我

00:37:07.090 --> 00:37:10.120
实际上确实提出了一套

00:37:08.230 --> 00:37:13.120
我想要什么的标准

00:37:10.120 --> 00:37:16.390
这个API，因此显然更简单的是

00:37:13.120 --> 00:37:20.320
最好少样板，但

00:37:16.390 --> 00:37:22.570
有趣的是，API应该是

00:37:20.320 --> 00:37:24.130
编译时间类型安全，因此一些

00:37:22.570 --> 00:37:26.200
替代品和一些

00:37:24.130 --> 00:37:28.360
人们提出的替代方案，如果您

00:37:26.200 --> 00:37:30.460
具有不同的键和值

00:37:28.360 --> 00:37:33.190
然后是最常见的超紧类型

00:37:30.460 --> 00:37:35.320
可能是对象，所以您和

00:37:33.190 --> 00:37:37.240
而且你不能有一个VAR参数

00:37:35.320 --> 00:37:38.950
有不同的类型，所以有些人

00:37:37.240 --> 00:37:40.780
说哦，只需要对象的VAR参数

00:37:38.950 --> 00:37:41.050
你知道的，我们会处理类型

00:37:40.780 --> 00:37:43.120
的

00:37:41.050 --> 00:37:45.940
安全没关系，就像哇，我不知道

00:37:43.120 --> 00:37:49.090
认为工作非常非常非常

00:37:45.940 --> 00:37:51.070
专注于静态静态类型检查

00:37:49.090 --> 00:37:53.440
并编译时间，以便有参数

00:37:51.070 --> 00:37:58.150
在编译时未检查的是

00:37:53.440 --> 00:38:00.130
这样做是一种狡猾的事情

00:37:58.150 --> 00:38:02.680
另一件事是我们想要的数量

00:38:00.130 --> 00:38:04.030
在编译时已知的元素，以及

00:38:02.680 --> 00:38:05.650
所以你可以拥有一个你知道的

00:38:04.030 --> 00:38:07.420
替代方案是有一个建筑商，所以你

00:38:05.650 --> 00:38:09.370
只是调用构建，您知道添加添加添加添加

00:38:07.420 --> 00:38:12.280
添加或类似的东西和

00:38:09.370 --> 00:38:13.630
问题是你必须在

00:38:12.280 --> 00:38:16.060
建立过程中，您必须

00:38:13.630 --> 00:38:20.410
积累那些可能涉及

00:38:16.060 --> 00:38:22.030
连续重新分配和副本

00:38:20.410 --> 00:38:25.810
因为你不知道多少次

00:38:22.030 --> 00:38:27.940
这个家伙要在之前添加条目

00:38:25.810 --> 00:38:30.060
建立最终的地图，等等

00:38:27.940 --> 00:38:34.420
想做的还是在编译时

00:38:30.060 --> 00:38:37.380
具有静态已知的大小或

00:38:34.420 --> 00:38:40.630
至少不是静态已知的，但已知于

00:38:37.380 --> 00:38:42.700
初始条目，所以varargs这样做

00:38:40.630 --> 00:38:44.800
之所以这样，是因为当您收到VAR时

00:38:42.700 --> 00:38:46.690
 x参数得到一个固定的数组

00:38:44.800 --> 00:38:50.470
大小，所以你知道那是

00:38:46.690 --> 00:38:52.000
你拥有的元素数量

00:38:50.470 --> 00:38:54.250
另一个普通人说哦

00:38:52.000 --> 00:38:56.800
只有两个两个数组

00:38:54.250 --> 00:38:58.870
不同的东西，那就是

00:38:56.800 --> 00:39:01.150
对不同类型的两个数组进行精细处理

00:38:58.870 --> 00:39:02.740
键数组值数组和

00:39:01.150 --> 00:39:04.090
没关系没关系

00:39:02.740 --> 00:39:06.010
工作，你必须做一些交叉检查

00:39:04.090 --> 00:39:08.530
确保数组是

00:39:06.010 --> 00:39:10.270
大小相同，但写出代码时

00:39:08.530 --> 00:39:12.550
那然后是键和

00:39:10.270 --> 00:39:14.530
值，除非您扭曲来源

00:39:12.550 --> 00:39:16.510
以非常奇怪的方式编写代码

00:39:14.530 --> 00:39:19.090
会离你的很远

00:39:16.510 --> 00:39:21.370
相应的值，就像

00:39:19.090 --> 00:39:24.760
是的，您可以在功能上

00:39:21.370 --> 00:39:29.080
 API，但我们需要编写源代码

00:39:24.760 --> 00:39:31.060
只是不去上班所以反正

00:39:29.080 --> 00:39:33.940
那么理想情况下，我们希望避免

00:39:31.060 --> 00:39:35.680
尽可能地装箱，结果

00:39:33.940 --> 00:39:39.610
我们能够满足所有

00:39:35.680 --> 00:39:40.720
那些接受拳击所以我去了

00:39:39.610 --> 00:39:43.270
在这已经有一个新的

00:39:40.720 --> 00:39:45.160
方便的方法称为进入

00:39:43.270 --> 00:39:47.860
需要一个键和一个值，您可以传递一个

00:39:45.160 --> 00:39:50.140
那些到的地图点的继承

00:39:47.860 --> 00:39:53.290
条目方法，这就是我们

00:39:50.140 --> 00:39:54.460
最终不完美，这是一个

00:39:53.290 --> 00:39:54.789
比我更冗长

00:39:54.460 --> 00:39:56.650
喜欢

00:39:54.789 --> 00:40:00.549
但我认为它确实满足了大多数

00:39:56.650 --> 00:40:02.049
标准，并且效果很好，所以

00:40:00.549 --> 00:40:04.479
这是一些东西

00:40:02.049 --> 00:40:10.479
 Java世界中的新特性是不可变的

00:40:04.479 --> 00:40:12.009
数据结构以及实例

00:40:10.479 --> 00:40:14.199
这些新方法返回的是

00:40:12.009 --> 00:40:16.179
一成不变的，这意味着你不能

00:40:14.199 --> 00:40:18.099
修改它们，以便我强调

00:40:16.179 --> 00:40:20.109
我想这就是我们所说的

00:40:18.099 --> 00:40:22.119
传统的不变性

00:40:20.109 --> 00:40:24.369
就像常规的Java集合一样

00:40:22.119 --> 00:40:27.640
如果您调用类似mutator的方法

00:40:24.369 --> 00:40:30.400
加或放然后被拒绝

00:40:27.640 --> 00:40:31.839
我想要的不受支持的操作异常

00:40:30.400 --> 00:40:34.499
与其他图书馆形成对比

00:40:31.839 --> 00:40:37.150
和其他具有

00:40:34.499 --> 00:40:40.269
持久或不变的持久数据

00:40:37.150 --> 00:40:41.619
您可以在其中进行修改的结构

00:40:40.269 --> 00:40:43.390
数据结构，但您得到的是

00:40:41.619 --> 00:40:45.489
与之共享的新数据结构

00:40:43.390 --> 00:40:46.989
你那不是这个的老

00:40:45.489 --> 00:40:52.380
这是一种常规

00:40:46.989 --> 00:40:55.239
无论如何，这是好的，因为

00:40:52.380 --> 00:40:57.130
在很多情况下，人们

00:40:55.239 --> 00:40:59.380
如果可以使用不可变的数据结构

00:40:57.130 --> 00:41:01.179
他们有Java语言的

00:40:59.380 --> 00:41:04.029
初始化表的常见情况

00:41:01.179 --> 00:41:05.619
事物或清单或事物在

00:41:04.029 --> 00:41:06.819
程序的开始，永不

00:41:05.619 --> 00:41:09.249
在整个生命周期内进行更改

00:41:06.819 --> 00:41:11.709
程序，所以你不想要那些

00:41:09.249 --> 00:41:13.209
意外更改，如果

00:41:11.709 --> 00:41:15.269
有一种节省空间的方式来存储

00:41:13.209 --> 00:41:18.219
他们那么你想这样做，因为

00:41:15.269 --> 00:41:20.380
你知道你是否知道破坏者

00:41:18.219 --> 00:41:22.329
永远不会改变，那为什么

00:41:20.380 --> 00:41:26.019
为灵活性付出空间代价

00:41:22.329 --> 00:41:32.259
修改数据的可能性

00:41:26.019 --> 00:41:34.599
你永远不会那样做，所以那里

00:41:32.259 --> 00:41:38.019
他们在历史上有吗

00:41:34.599 --> 00:41:39.279
被包装中不可修改的包装

00:41:38.019 --> 00:41:41.559
收藏框架，这有点

00:41:39.279 --> 00:41:43.900
最接近通用的东西

00:41:41.559 --> 00:41:45.640
到现在为止的不变性

00:41:43.900 --> 00:41:47.799
所以你要做的就是创建一个

00:41:45.640 --> 00:41:52.289
可变数据结构填充其中， 

00:41:47.799 --> 00:41:52.289
然后将其包裹在未修改的区域中

00:41:52.329 --> 00:41:56.619
哦，然后扔掉对

00:41:54.579 --> 00:41:59.259
底层的那种

00:41:56.619 --> 00:42:00.489
只要您具有免疫变异性

00:41:59.259 --> 00:42:03.909
你记得扔掉

00:42:00.489 --> 00:42:07.059
基本参考但不可修改的是

00:42:03.909 --> 00:42:08.590
实际上是一个不同的概念

00:42:07.059 --> 00:42:11.530
想到不可修改的包装

00:42:08.590 --> 00:42:14.280
是他们对另一个的看法

00:42:11.530 --> 00:42:16.660
不允许的集合

00:42:14.280 --> 00:42:18.850
修改，但如果您仍有

00:42:16.660 --> 00:42:24.070
然后处理基础集合

00:42:18.850 --> 00:42:25.540
您可以进行修改，即使您

00:42:24.070 --> 00:42:28.150
如果你打电话到某个地方，它给

00:42:25.540 --> 00:42:30.520
您一个修女可修改的观点，这意味着您

00:42:28.150 --> 00:42:32.470
无法修改，但您无法信任

00:42:30.520 --> 00:42:34.660
它将永远不会改变

00:42:32.470 --> 00:42:36.220
所以因为其他人可能是

00:42:34.660 --> 00:42:38.790
修改它，这样的想法

00:42:36.220 --> 00:42:40.720
不可修改的

00:42:38.790 --> 00:42:44.290
收藏框架真的是

00:42:40.720 --> 00:42:47.020
与不变性不同，因此这些

00:42:44.290 --> 00:42:48.970
除非修改集合，否则除非

00:42:47.020 --> 00:42:50.290
你像反射或不安全地进入

00:42:48.970 --> 00:42:54.030
或类似的东西

00:42:50.290 --> 00:42:56.680
修改这些集合的api 

00:42:54.030 --> 00:43:01.690
好吧，这是一个有趣的地方

00:42:56.680 --> 00:43:05.320
皱纹有一些解释

00:43:01.690 --> 00:43:07.990
哈希集的迭代顺序和

00:43:05.320 --> 00:43:09.820
映射的实现是

00:43:07.990 --> 00:43:12.340
新的回收工厂返回

00:43:09.820 --> 00:43:16.060
迭代顺序是随机的，它

00:43:12.340 --> 00:43:18.730
如果您看一下，现在字面上是随机的

00:43:16.060 --> 00:43:21.160
在现有的布景和地图上

00:43:18.730 --> 00:43:22.870
收集框架，然后有一些

00:43:21.160 --> 00:43:25.570
关于迭代顺序的单词

00:43:22.870 --> 00:43:27.840
未指定，但历史上

00:43:25.570 --> 00:43:32.380
迭代顺序非常稳定

00:43:27.840 --> 00:43:33.760
所以从如果您遍历

00:43:32.380 --> 00:43:34.750
同一集合将多次

00:43:33.760 --> 00:43:38.050
顺序相同

00:43:34.750 --> 00:43:40.810
甚至从运行到运行，甚至从JDK运行

00:43:38.050 --> 00:43:43.060
如果您将

00:43:40.810 --> 00:43:45.250
将相同的元素放入哈希映射或哈希

00:43:43.060 --> 00:43:47.680
设置他们可能会出现在

00:43:45.250 --> 00:43:50.230
相同的顺序，问题是很多

00:43:47.680 --> 00:43:52.530
的代码越来越依赖非常稳定的

00:43:50.230 --> 00:43:54.490
迭代顺序和时间

00:43:52.530 --> 00:43:56.620
将会发生改变的事情

00:43:54.490 --> 00:43:59.530
迭代顺序就像您的程序一样

00:43:56.620 --> 00:44:02.020
获得不同的输入，可能会导致

00:43:59.530 --> 00:44:04.720
散列集为散列集的一半，或

00:44:02.020 --> 00:44:05.860
哈希映射以重新哈希所有内容，然后

00:44:04.720 --> 00:44:09.310
事情会以不同的方式出现

00:44:05.860 --> 00:44:11.290
订单，您的程序将中断或进入

00:44:09.310 --> 00:44:13.360
 JDK有时我们不得不做一些

00:44:11.290 --> 00:44:15.310
性能增强或某些

00:44:13.360 --> 00:44:17.590
安全漏洞或其他

00:44:15.310 --> 00:44:19.810
我们将在哪里更改迭代

00:44:17.590 --> 00:44:21.100
哈希图的顺序和人们大吼

00:44:19.810 --> 00:44:22.360
我们这样做的时候很多，因为

00:44:21.100 --> 00:44:24.790
破坏了我们的代码就像

00:44:22.360 --> 00:44:26.740
好吧，你知道我们用手指回来

00:44:24.790 --> 00:44:28.630
是的，你不应该只是

00:44:26.740 --> 00:44:30.550
进行迭代或，但是我们

00:44:28.630 --> 00:44:32.200
难道我们不能太过分

00:44:30.550 --> 00:44:36.550
因为当我们改变迭代

00:44:32.200 --> 00:44:39.490
哈希图，我们自己的代码正确，所以

00:44:36.550 --> 00:44:41.590
发生什么了，就像在哪里

00:44:39.490 --> 00:44:43.060
相依相依在哪里

00:44:41.590 --> 00:44:44.920
我没有在此代码中命令下垂

00:44:43.060 --> 00:44:46.420
知道它在哪里，只是将其更改为

00:44:44.920 --> 00:44:48.010
一个链接的哈希图，这将给我们

00:44:46.420 --> 00:44:51.250
稳定迭代顺序，然后

00:44:48.010 --> 00:44:52.960
问题消失了，就像啊，所以

00:44:51.250 --> 00:44:56.980
那真的很不舒服，但是

00:44:52.960 --> 00:44:58.900
事实是我们有最坏的经历

00:44:56.980 --> 00:45:01.780
到Java 9，我们两者都有

00:44:58.900 --> 00:45:04.750
世界，我们有迭代顺序是

00:45:01.780 --> 00:45:07.840
未指定，但足够稳定

00:45:04.750 --> 00:45:09.580
低级的人认为

00:45:07.840 --> 00:45:10.120
实际上是稳定的，然后当它

00:45:09.580 --> 00:45:13.540
变化

00:45:10.120 --> 00:45:15.730
很多东西中断了，所以解决方案

00:45:13.540 --> 00:45:18.340
对于新的收藏是

00:45:15.730 --> 00:45:21.540
迭代顺序是随机的

00:45:18.340 --> 00:45:24.640
所以发生的是@vm启动

00:45:21.540 --> 00:45:27.130
基本上得到一个随机的随机数

00:45:24.640 --> 00:45:30.310
将它异或到互联网哈希中

00:45:27.130 --> 00:45:33.610
代码，所以效果是

00:45:30.310 --> 00:45:37.120
 JVM运行到下一个迭代

00:45:33.610 --> 00:45:40.000
集的顺序和返回的地图

00:45:37.120 --> 00:45:42.490
新工厂的迭代顺序

00:45:40.000 --> 00:45:45.280
将从一个JVM运行更改为另一个

00:45:42.490 --> 00:45:48.430
所以希望这会冲洗

00:45:45.280 --> 00:45:50.800
排除任何潜在的代码

00:45:48.430 --> 00:45:52.660
对迭代顺序的依赖以及

00:45:50.800 --> 00:45:54.670
这些问题将被清除

00:45:52.660 --> 00:45:57.340
在开发和测试期间等等

00:45:54.670 --> 00:46:00.370
他们他们不会出来

00:45:57.340 --> 00:46:02.170
生产，但实际上它也是

00:46:00.370 --> 00:46:04.330
在这里购买一些灵活性

00:46:02.170 --> 00:46:08.020
我们可能想要进入

00:46:04.330 --> 00:46:10.390
重组内部方式

00:46:08.020 --> 00:46:12.280
条目存储在这些映射中，或者

00:46:10.390 --> 00:46:14.650
设置，我们希望自由能够

00:46:12.280 --> 00:46:16.660
做到这一点，让您更了解

00:46:14.650 --> 00:46:18.610
你知道更好的性能更好的空间

00:46:16.660 --> 00:46:20.290
效率等

00:46:18.610 --> 00:46:21.790
担心保留迭代

00:46:20.290 --> 00:46:24.220
订单，这是最难的一项

00:46:21.790 --> 00:46:26.470
如果必须保存的话

00:46:24.220 --> 00:46:29.500
迭代顺序是需要的成本

00:46:26.470 --> 00:46:32.280
即使不是实际要支付

00:46:29.500 --> 00:46:34.690
指定，所以我们想避免这种情况

00:46:32.280 --> 00:46:35.740
再次，这仅适用于新

00:46:34.690 --> 00:46:37.570
馆藏

00:46:35.740 --> 00:46:40.270
新馆工厂归还

00:46:37.570 --> 00:46:41.619
方法现有的集合

00:46:40.270 --> 00:46:43.420
知道那些将保持不变我

00:46:41.619 --> 00:46:46.360
认为添加随机迭代

00:46:43.420 --> 00:46:49.119
那些对

00:46:46.360 --> 00:46:51.130
现有的收藏不是什么

00:46:49.119 --> 00:46:53.350
当然不是我们要去的东西

00:46:51.130 --> 00:46:56.710
默认情况下可能会

00:46:53.350 --> 00:46:59.550
出于调试目的选择加入的东西

00:46:56.710 --> 00:47:01.990
但仅此而已

00:46:59.550 --> 00:47:04.770
好吧，新的另一个特点

00:47:01.990 --> 00:47:11.260
集合是不允许空值

00:47:04.770 --> 00:47:13.300
所以我回想一下新的

00:47:11.260 --> 00:47:14.950
收藏集介绍很抱歉，但是当

00:47:13.300 --> 00:47:17.080
收集框架最初是

00:47:14.950 --> 00:47:19.869
一站式介绍到主要

00:47:17.080 --> 00:47:21.670
集合确实允许null和in 

00:47:19.869 --> 00:47:24.400
回顾那已经被认为

00:47:21.670 --> 00:47:27.430
作为错误，最近没有允许

00:47:24.400 --> 00:47:29.050
允许null尤其是同意

00:47:27.430 --> 00:47:32.290
并发集合均不允许

00:47:29.050 --> 00:47:34.450
空条目及其原因

00:47:32.290 --> 00:47:36.640
显示为null的几个原因

00:47:34.450 --> 00:47:40.960
在特殊套件中的特殊位置

00:47:36.640 --> 00:47:43.390
 api的，所以有数学的情况下，如果

00:47:40.960 --> 00:47:46.240
返回null意味着

00:47:43.390 --> 00:47:47.890
条目不存在或是否意味着

00:47:46.240 --> 00:47:49.630
条目存在，但其值为空

00:47:47.890 --> 00:47:51.640
所以你必须要做些什么

00:47:49.630 --> 00:47:54.040
其他要消除歧义，但也有一些

00:47:51.640 --> 00:47:58.810
特别是在并发中

00:47:54.040 --> 00:48:00.820
收集类似地图点计算

00:47:58.810 --> 00:48:02.680
就像我之前提到的，如果

00:48:00.820 --> 00:48:04.359
 lambda表达式返回具有以下内容的null 

00:48:02.680 --> 00:48:07.450
删除条目的效果为

00:48:04.359 --> 00:48:11.380
反对将空值存储到地图中

00:48:07.450 --> 00:48:14.340
所以null是非常重要的特殊

00:48:11.380 --> 00:48:17.680
对AP有用的情况就是这样

00:48:14.340 --> 00:48:19.600
还有null真的很有用

00:48:17.680 --> 00:48:23.380
里面的收藏很特别

00:48:19.600 --> 00:48:25.090
哨兵，所以它让你知道

00:48:23.380 --> 00:48:28.780
你实际上在看什么

00:48:25.090 --> 00:48:30.400
像哈希映射之类的东西

00:48:28.780 --> 00:48:33.070
 java.util哈希映射必须有一堆

00:48:30.400 --> 00:48:34.600
万一有人想要的特殊情况

00:48:33.070 --> 00:48:36.580
在哈希图中存储null 

00:48:34.600 --> 00:48:39.550
默认情况下，null表示没有任何内容

00:48:36.580 --> 00:48:40.720
在那里，所以有特殊情况

00:48:39.550 --> 00:48:43.330
散布在整个代码中

00:48:40.720 --> 00:48:46.840
只是使事情变得更复杂

00:48:43.330 --> 00:48:49.700
容易出错，所以另一个

00:48:46.840 --> 00:48:53.609
这里的另一个皱纹是

00:48:49.700 --> 00:48:56.069
当您填充手臂图时

00:48:53.609 --> 00:48:57.839
对重复的条目抛出异常

00:48:56.069 --> 00:48:59.579
我这里有些道理

00:48:57.839 --> 00:49:02.130
认为我需要继续前进

00:48:59.579 --> 00:49:03.779
很快，但是如果您有一张大桌子

00:49:02.130 --> 00:49:06.140
这是一个例子，那里有一个

00:49:03.779 --> 00:49:09.690
我在这里有一个重复的条目

00:49:06.140 --> 00:49:12.539
要么您知道大多数系统都在使用

00:49:09.690 --> 00:49:14.369
最后一个获胜，这意味着如果您

00:49:12.539 --> 00:49:16.140
如果您将其编译到您的

00:49:14.369 --> 00:49:18.089
程序你实际上会有一个

00:49:16.140 --> 00:49:20.430
少于您预期的条目，并且您会

00:49:18.089 --> 00:49:22.980
有一些奇怪的行为运行时，但是如果

00:49:20.430 --> 00:49:23.880
您实际上将其放入Java 9中

00:49:22.980 --> 00:49:26.130
我们将提出法律依据

00:49:23.880 --> 00:49:29.099
例外，说好吧，这是

00:49:26.130 --> 00:49:31.799
重复的条目，所以这里的重点

00:49:29.099 --> 00:49:37.369
这是一个库API 

00:49:31.799 --> 00:49:39.750
这是建模集合文字和

00:49:37.369 --> 00:49:41.250
因此，如果您有一个集合文字

00:49:39.750 --> 00:49:42.930
表示您正在写出所有值

00:49:41.250 --> 00:49:49.769
因此，如果您重复输入

00:49:42.930 --> 00:49:51.599
可能是一个错误，我很抱歉

00:49:49.769 --> 00:49:53.130
我时间不多了，所以我有

00:49:51.599 --> 00:49:57.349
一堆关于空间的东西

00:49:53.130 --> 00:49:59.940
效率，但实际上是现有的我

00:49:57.349 --> 00:50:02.250
只想很简单地说

00:49:59.940 --> 00:50:04.619
现有的收藏，特别是东西

00:50:02.250 --> 00:50:06.630
像哈希一样漂亮的空间

00:50:04.619 --> 00:50:08.400
效率低下，他们使用很多对象， 

00:50:06.630 --> 00:50:10.559
很多指向不同对象的指针

00:50:08.400 --> 00:50:14.700
因此，如果您将几个条目

00:50:10.559 --> 00:50:17.369
散列集需要152个字节

00:50:14.700 --> 00:50:20.789
代表具有两个条目的哈希集，因此

00:50:17.369 --> 00:50:25.259
新设置的实现要多得多

00:50:20.789 --> 00:50:27.660
紧凑，所以如果您有一个新的不变性

00:50:25.259 --> 00:50:33.269
设置两个条目只需要20 

00:50:27.660 --> 00:50:38.039
字节而不是152个字节，所以再次

00:50:33.269 --> 00:50:39.450
我将不得不跳过这里

00:50:38.039 --> 00:50:42.059
情侣设计

00:50:39.450 --> 00:50:45.440
基本原理，我将这些幻灯片发布到

00:50:42.059 --> 00:50:49.170
在网络上，以便您可以看到它们， 

00:50:45.440 --> 00:50:51.390
我也可以提问

00:50:49.170 --> 00:50:54.029
之后，但我将直接移动

00:50:51.390 --> 00:50:57.390
在这里查看我的摘要，以便收集

00:50:54.029 --> 00:50:59.220
框架已有19年的历史了

00:50:57.390 --> 00:51:00.750
旧的，但我们仍在努力

00:50:59.220 --> 00:51:02.519
有很多新的增强功能

00:51:00.750 --> 00:51:02.940
 Java 8我们看到了所有这些新的默认值

00:51:02.519 --> 00:51:05.490
方法

00:51:02.940 --> 00:51:07.349
为所有

00:51:05.490 --> 00:51:09.930
现有集合，然后用Java 

00:51:07.349 --> 00:51:13.910
九，我们的收藏方便

00:51:09.930 --> 00:51:16.410
提供新契约的工厂

00:51:13.910 --> 00:51:18.990
不变的收藏，它们很多

00:51:16.410 --> 00:51:21.480
写起来更方便，我

00:51:18.990 --> 00:51:24.599
鼓励您使用JDK 9 

00:51:21.480 --> 00:51:26.359
下载页面并下载JDK 9 it 

00:51:24.599 --> 00:51:29.250
应该在任何最近的版本中

00:51:26.359 --> 00:51:30.810
鼓励您尝试一下，谢谢

00:51:29.250 --> 00:51:31.950
你对不起，我认为我没有时间

00:51:30.810 --> 00:51:34.820
提出问题，但我可以联系

00:51:31.950 --> 00:51:41.349
之后进行对话谢谢

00:51:34.820 --> 00:51:41.349
 [音乐] 

