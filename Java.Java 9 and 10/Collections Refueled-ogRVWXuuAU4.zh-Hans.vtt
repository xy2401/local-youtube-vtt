WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.189 --> 00:00:08.759
早上好，谢谢你来这个

00:00:05.470 --> 00:00:10.570
早上我知道这是一个开始，但是

00:00:08.759 --> 00:00:13.210
谢谢你今天来

00:00:10.570 --> 00:00:16.449
我叫Stewart Marx我在甲骨文工作

00:00:13.210 --> 00:00:17.980
 JDK在核心库中的工作

00:00:16.449 --> 00:00:19.630
团队，我要做的事情之一是

00:00:17.980 --> 00:00:21.820
维护馆藏框架并

00:00:19.630 --> 00:00:24.970
所以这个演讲的题目是收藏

00:00:21.820 --> 00:00:29.289
加油，所以我将覆盖

00:00:24.970 --> 00:00:31.210
 JDK 9和

00:00:29.289 --> 00:00:34.620
一瞥我们可能会遇到的情况

00:00:31.210 --> 00:00:37.390
将来会继续工作，让我们看看

00:00:34.620 --> 00:00:39.070
这只是一个45分钟的课程，因此

00:00:37.390 --> 00:00:40.600
我不得不从一个小时的时间里把它剪下来

00:00:39.070 --> 00:00:43.330
可能或可能没有时间

00:00:40.600 --> 00:00:45.040
最后的问题，但如果有

00:00:43.330 --> 00:00:46.480
问题，你有没有

00:00:45.040 --> 00:00:48.990
有机会在会议上问我

00:00:46.480 --> 00:00:52.360
然后请在这个标签上发推文

00:00:48.990 --> 00:00:56.700
收藏加油，我会尽力

00:00:52.360 --> 00:01:00.520
会议结束后到达

00:00:56.700 --> 00:01:03.100
好吧，那么一张关于历史的幻灯片

00:01:00.520 --> 00:01:05.320
集合框架，所以在JDK 1.0中

00:01:03.100 --> 00:01:06.939
 1996那里什么都没有

00:01:05.320 --> 00:01:08.979
在那里称为收藏集标记

00:01:06.939 --> 00:01:11.679
我们那里有一些藏品

00:01:08.979 --> 00:01:13.299
现在回想起旧版

00:01:11.679 --> 00:01:15.460
这些是类似的集合

00:01:13.299 --> 00:01:17.789
向量和哈希表，您可能会

00:01:15.460 --> 00:01:20.170
记得我希望你不要用那些

00:01:17.789 --> 00:01:24.909
虽然我确实在堆栈跟踪中看到了它们

00:01:20.170 --> 00:01:27.310
在昨天的主题演讲中，嗯

00:01:24.909 --> 00:01:29.200
所以在jdk 1.2中，现在是

00:01:27.310 --> 00:01:31.749
收集框架实际上是

00:01:29.200 --> 00:01:33.340
介绍了约书亚布洛赫

00:01:31.749 --> 00:01:34.959
发展那些并将其整合到

00:01:33.340 --> 00:01:37.569
 1998年的JDK 

00:01:34.959 --> 00:01:39.369
所以收藏框架有点

00:01:37.569 --> 00:01:41.679
比Java小一点，所以大约19岁

00:01:39.369 --> 00:01:43.780
此时已经几岁了，所以

00:01:41.679 --> 00:01:45.779
什么介绍了接口集

00:01:43.780 --> 00:01:48.939
如此熟悉的我们

00:01:45.779 --> 00:01:52.149
集合列表设置数学等

00:01:48.939 --> 00:01:54.579
还有那个

00:01:52.149 --> 00:01:58.299
可能每个人都使用像ArrayList 

00:01:54.579 --> 00:01:59.829
和哈希图，所以我没有

00:01:58.299 --> 00:02:01.599
指尖上的参考，但有

00:01:59.829 --> 00:02:05.709
一些进行实证研究的论文

00:02:01.599 --> 00:02:07.719
集合用法和ArrayList的集合，以及

00:02:05.709 --> 00:02:09.670
哈希图是迄今为止最多的两个

00:02:07.719 --> 00:02:11.530
 Java中的常用集合

00:02:09.670 --> 00:02:12.520
程序，所以现在非常神奇

00:02:11.530 --> 00:02:13.610
这些课程是

00:02:12.520 --> 00:02:16.640
重新实现

00:02:13.610 --> 00:02:18.140
但是这些课程的基础是

00:02:16.640 --> 00:02:19.670
介绍于19年前， 

00:02:18.140 --> 00:02:22.690
仍然是其中最多的

00:02:19.670 --> 00:02:25.940
当今使用的流行收藏类

00:02:22.690 --> 00:02:29.180
现在下一步是2004年

00:02:25.940 --> 00:02:31.970
当泛型为Java SE 5时

00:02:29.180 --> 00:02:33.740
作为介绍的一部分

00:02:31.970 --> 00:02:36.650
将泛型介绍给

00:02:33.740 --> 00:02:38.990
编程语言集合

00:02:36.650 --> 00:02:41.240
图书馆升格为属

00:02:38.990 --> 00:02:43.940
善意，所以您有更好的类型检查

00:02:41.240 --> 00:02:48.340
当您将元素放入或移除时

00:02:43.940 --> 00:02:51.320
集合和Java 8中的元素

00:02:48.340 --> 00:02:53.270
语言再次大受欢迎

00:02:51.320 --> 00:02:55.430
升级以在流中添加lambda 

00:02:53.270 --> 00:02:57.050
库，现在流库很友好

00:02:55.430 --> 00:02:59.030
不是官方的一部分

00:02:57.050 --> 00:03:02.480
收藏框架，但基本上

00:02:59.030 --> 00:03:04.459
它是最频繁的流源

00:03:02.480 --> 00:03:06.650
和流目标是集合

00:03:04.459 --> 00:03:08.380
因此流库非常有效

00:03:06.650 --> 00:03:10.670
与馆藏框架紧密联系

00:03:08.380 --> 00:03:13.700
但是其中还有另一种语言功能

00:03:10.670 --> 00:03:16.340
 Java 8是默认方法

00:03:13.700 --> 00:03:17.630
接口，所以溜进去了

00:03:16.340 --> 00:03:19.700
那里你可能很熟悉

00:03:17.630 --> 00:03:22.610
那不过是做的一件事是

00:03:19.700 --> 00:03:24.950
给那些旧的添加一堆方法

00:03:22.610 --> 00:03:27.680
收集接口，如收集

00:03:24.950 --> 00:03:29.180
列表集数学等等，等等

00:03:27.680 --> 00:03:31.190
那确实是有

00:03:29.180 --> 00:03:32.959
增强每一个现有的

00:03:31.190 --> 00:03:35.450
即使该收藏

00:03:32.959 --> 00:03:37.670
没有明确升级到Java 

00:03:35.450 --> 00:03:38.870
 8默认方法真的增加了很多

00:03:37.670 --> 00:03:40.670
收集框架的权力

00:03:38.870 --> 00:03:42.890
无需更改收藏

00:03:40.670 --> 00:03:45.590
框架，所以实际上

00:03:42.890 --> 00:03:47.930
现在有趣的增强

00:03:45.590 --> 00:03:50.750
方式还有其他一些课程

00:03:47.930 --> 00:03:52.820
添加了集合实现

00:03:50.750 --> 00:03:55.549
在这里和那里，例如优先队列

00:03:52.820 --> 00:03:57.650
和阵列甲板等等，但实际上

00:03:55.549 --> 00:04:00.110
这些是历史的亮点

00:03:57.650 --> 00:04:03.500
的收集框架直到

00:04:00.110 --> 00:04:04.910
现在好了，所以在Java 9中

00:04:03.500 --> 00:04:07.360
馆藏框架的增强

00:04:04.910 --> 00:04:09.680
被称为便利集合

00:04:07.360 --> 00:04:12.019
集合便利工厂方法

00:04:09.680 --> 00:04:15.049
因此它们是工厂创建的方法

00:04:12.019 --> 00:04:16.579
新集合的实例等等

00:04:15.049 --> 00:04:19.459
这是这里的三个主要目标

00:04:16.579 --> 00:04:22.220
便捷空间效率

00:04:19.459 --> 00:04:25.610
和不可修改的'ti，所以我要去

00:04:22.220 --> 00:04:28.889
通过那些细节

00:04:25.610 --> 00:04:33.389
好吧，这里有一些历史

00:04:28.889 --> 00:04:35.100
是仅库API，因此请注意

00:04:33.389 --> 00:04:38.580
这是不是，这实际上是在问

00:04:35.100 --> 00:04:40.259
昨天的建筑师会议是如此

00:04:38.580 --> 00:04:42.300
其他语言之一

00:04:40.259 --> 00:04:46.440
有一个叫做收集的东西

00:04:42.300 --> 00:04:48.419
文字，所以一直在努力

00:04:46.440 --> 00:04:51.300
将集合文字添加到java 

00:04:48.419 --> 00:04:52.740
编程语言，但有一些

00:04:51.300 --> 00:04:56.430
问题，Java的方式

00:04:52.740 --> 00:04:58.410
设计是核心汇总

00:04:56.430 --> 00:05:00.389
想要汇总某些数据

00:04:58.410 --> 00:05:02.099
您拥有的Java编程语言

00:05:00.389 --> 00:05:04.800
语言内置的数组

00:05:02.099 --> 00:05:07.470
你有内置的类

00:05:04.800 --> 00:05:09.389
您可以在课程中添加字段的语言

00:05:07.470 --> 00:05:11.970
那就是你的方式那就是你的分组方式

00:05:09.389 --> 00:05:13.889
不相关的数据进入更高层次

00:05:11.970 --> 00:05:16.470
创建一个

00:05:13.889 --> 00:05:18.720
他们之间的关系，但那种

00:05:16.470 --> 00:05:21.810
更高层次的抽象，例如集合或

00:05:18.720 --> 00:05:24.690
或更高级的数据结构是

00:05:21.810 --> 00:05:27.479
真正委托给了图书馆

00:05:24.690 --> 00:05:31.130
 Java的设置方式，如果您

00:05:27.479 --> 00:05:36.030
创建了一个语言功能调用

00:05:31.130 --> 00:05:38.159
允许你写一个允许的

00:05:36.030 --> 00:05:41.340
您在其中声明一个集合

00:05:38.159 --> 00:05:43.590
可以与

00:05:41.340 --> 00:05:46.500
编程语言也到库

00:05:43.590 --> 00:05:48.150
紧密地，它们是一堆设计

00:05:46.500 --> 00:05:50.280
这样的问题，但我没有

00:05:48.150 --> 00:05:51.510
有时间详细介绍，所以您可以

00:05:50.280 --> 00:05:54.330
一些简单的事情，但这将是

00:05:51.510 --> 00:05:56.820
如果您想避免，那就不能令人满意

00:05:54.330 --> 00:05:58.949
那解决了那个问题

00:05:56.820 --> 00:06:01.380
因为事实证明它将得到一个

00:05:58.949 --> 00:06:04.080
更加复杂，因此我们将

00:06:01.380 --> 00:06:05.849
将集合文字添加到的概念

00:06:04.080 --> 00:06:07.830
编程语言，并决定

00:06:05.849 --> 00:06:15.300
专注于使收藏更容易

00:06:07.830 --> 00:06:17.009
仅使用库API构造所有

00:06:15.300 --> 00:06:19.560
对，所以这是一个快速的过程

00:06:17.009 --> 00:06:23.099
新API的摘要

00:06:19.560 --> 00:06:26.820
是在JDK 9中添加的，因此

00:06:23.099 --> 00:06:29.159
名为的方法已添加到

00:06:26.820 --> 00:06:32.190
列表方法是静态方法

00:06:29.159 --> 00:06:36.200
在列表界面上，所以列出

00:06:32.190 --> 00:06:38.630
一直到0 1 2 

00:06:36.200 --> 00:06:41.090
十个参数，或者还有一个可变参数

00:06:38.630 --> 00:06:43.130
版本，因此您可以传递任意

00:06:41.090 --> 00:06:46.870
列表点的元素数

00:06:43.130 --> 00:06:49.760
方法没有正式他们实际上是

00:06:46.870 --> 00:06:50.840
让我们看一下零到十加VAR弧

00:06:49.760 --> 00:06:53.600
所以实际上有12个

00:06:50.840 --> 00:06:54.620
但是列表点的不同重载

00:06:53.600 --> 00:06:56.630
当您编写代码时，它不会

00:06:54.620 --> 00:06:58.790
其实你只说列表的点

00:06:56.630 --> 00:07:01.640
只是逗号分隔的一组

00:06:58.790 --> 00:07:04.730
元素，并将这些元素添加到新

00:07:01.640 --> 00:07:06.500
用设置点创建列表相同的东西

00:07:04.730 --> 00:07:09.950
啊，有一堆固定的参数

00:07:06.500 --> 00:07:12.080
重载和VAR arg重载，但

00:07:09.950 --> 00:07:13.970
主要只是说定想而已

00:07:12.080 --> 00:07:16.940
提供以逗号分隔的列表

00:07:13.970 --> 00:07:19.700
现在考虑的集合元素映射

00:07:16.940 --> 00:07:23.270
有点不同，因为与众不同

00:07:19.700 --> 00:07:25.880
设置和列表映射具有不同的类型

00:07:23.270 --> 00:07:27.680
关键和价值，所以我们做了什么

00:07:25.880 --> 00:07:31.550
而不是他说和的数学点

00:07:27.680 --> 00:07:34.460
然后交替键和值元素

00:07:31.550 --> 00:07:36.590
现在的问题是，如果你

00:07:34.460 --> 00:07:39.710
你有不同类型的东西

00:07:36.590 --> 00:07:41.810
真的不能有varargs重载

00:07:39.710 --> 00:07:44.360
并以相同的方式进行工作

00:07:41.810 --> 00:07:46.400
相反，我们要做的就是如果您想要

00:07:44.360 --> 00:07:49.550
用任意数字创建地图

00:07:46.400 --> 00:07:51.980
首先需要对元素进行装箱

00:07:49.550 --> 00:07:54.200
将值键入地图条目，以便我们

00:07:51.980 --> 00:07:58.100
添加了另一个，我们添加了一个静态

00:07:54.200 --> 00:08:00.740
称为地图输入的方法

00:07:58.100 --> 00:08:04.340
与类型安装点大写字母不同

00:08:00.740 --> 00:08:06.680
条目，并且需要输入密钥

00:08:04.340 --> 00:08:09.860
值并将其放入

00:08:06.680 --> 00:08:13.280
数学点输入，然后您有另一个

00:08:09.860 --> 00:08:14.030
方法安装条目的点

00:08:13.280 --> 00:08:15.890
可变参数

00:08:14.030 --> 00:08:18.610
这些列表，以便您可以创建地图

00:08:15.890 --> 00:08:20.690
有任意数量的对

00:08:18.610 --> 00:08:22.790
好吧，这就是它的样子

00:08:20.690 --> 00:08:25.040
 Javadoc，因此您可以看到所有

00:08:22.790 --> 00:08:28.130
超载在那里，令人惊讶的是

00:08:25.040 --> 00:08:30.020
人们对此有何反应

00:08:28.130 --> 00:08:31.520
这个第一次被张贴有一个

00:08:30.020 --> 00:08:35.750
关于这个的讨论在reddit上

00:08:31.520 --> 00:08:38.120
有人说这是个玩笑，但不是这个

00:08:35.750 --> 00:08:40.400
不是开玩笑，但我认为要点

00:08:38.120 --> 00:08:43.130
这是这个，这是一定的

00:08:40.400 --> 00:08:45.380
 api中的丑陋程度，但您确实

00:08:43.130 --> 00:08:47.460
编程时看不到这种丑陋

00:08:45.380 --> 00:08:49.350
因为你只在源代码中看到

00:08:47.460 --> 00:08:51.420
我在这里用了什么数学点

00:08:49.350 --> 00:08:53.550
的映射出或列表出或

00:08:51.420 --> 00:08:55.440
无论您列出的参数是什么， 

00:08:53.550 --> 00:08:57.570
他们是固定的Arg的事实

00:08:55.440 --> 00:09:00.570
重载和变量参数

00:08:57.570 --> 00:09:02.850
重载对您而言并不重要，除了

00:09:00.570 --> 00:09:06.630
在数学案例中，我将显示一个

00:09:02.850 --> 00:09:10.050
后面的地图案例示例，但

00:09:06.630 --> 00:09:11.670
这里的意思是在图书馆里

00:09:10.050 --> 00:09:13.050
当我们开发核心

00:09:11.670 --> 00:09:14.970
图书馆和馆藏框架

00:09:13.050 --> 00:09:17.010
我们愿意承担一些

00:09:14.970 --> 00:09:18.600
丑陋，所以您不必如此

00:09:17.010 --> 00:09:20.520
确实使您的代码更多

00:09:18.600 --> 00:09:24.480
方便，让我告诉你一些

00:09:20.520 --> 00:09:25.860
这样的例子在行动，所以我认为

00:09:24.480 --> 00:09:27.110
马克·莱因霍尔德（Mark Reinhold）可能已经证明

00:09:25.860 --> 00:09:30.060
昨天主题演讲中的一些内容

00:09:27.110 --> 00:09:32.220
但是如果您想拥有一个

00:09:30.060 --> 00:09:34.800
不可修改的清单，包含一些元素

00:09:32.220 --> 00:09:37.110
你可以把那些包起来

00:09:34.800 --> 00:09:39.600
数组中的元素不是列表，然后

00:09:37.110 --> 00:09:42.270
包裹包裹然后转到里面

00:09:39.600 --> 00:09:45.240
不可修改清单上的集合等

00:09:42.270 --> 00:09:47.270
在Java点9中，它只是ABC的列表点

00:09:45.240 --> 00:09:49.950
这真的很不错，使您的代码

00:09:47.270 --> 00:09:52.890
非常紧凑，对不起，我不必

00:09:49.950 --> 00:09:54.090
我没有时间提问，但是如果

00:09:52.890 --> 00:09:58.080
你在推特上发推文，我会

00:09:54.090 --> 00:10:00.090
回到你身边，所以

00:09:58.080 --> 00:10:01.920
再次设置界面

00:10:00.090 --> 00:10:04.170
非常相似，现在更糟

00:10:01.920 --> 00:10:07.820
因为你必须

00:10:04.170 --> 00:10:10.890
元素进入一组，你必须

00:10:07.820 --> 00:10:12.660
采取这些要素和唯一途径

00:10:10.890 --> 00:10:15.630
传递多个元素以初始化

00:10:12.660 --> 00:10:17.310
帽子是将它们放置在数组中

00:10:15.630 --> 00:10:19.350
数组点作为列表，然后将那些

00:10:17.310 --> 00:10:22.350
在哈希集内，然后将其放入

00:10:19.350 --> 00:10:24.570
不可修改的集合，因此再次

00:10:22.350 --> 00:10:29.430
它在JDK 9中变得更加简单

00:10:24.570 --> 00:10:31.080
只是说ABC的设定点好

00:10:29.430 --> 00:10:33.330
这是我在这里稍微

00:10:31.080 --> 00:10:36.060
与马克所做的例子不同

00:10:33.330 --> 00:10:37.770
昨天的主题演讲有点像

00:10:36.060 --> 00:10:39.750
幻灯片顶部的常规方式

00:10:37.770 --> 00:10:42.420
初始化地图的常规方法

00:10:39.750 --> 00:10:44.010
只需将地图创建为空，然后调用

00:10:42.420 --> 00:10:45.480
穿上几次

00:10:44.010 --> 00:10:47.870
我想每个人都写了这段代码

00:10:45.480 --> 00:10:50.460
他们是如何做到这一点的变体

00:10:47.870 --> 00:10:51.690
这个管理的好处

00:10:50.460 --> 00:10:53.730
这是最直接的方法

00:10:51.690 --> 00:10:55.329
完成添加内容后

00:10:53.730 --> 00:10:57.429
地图，然后您可以将其包装在

00:10:55.329 --> 00:10:59.230
不可修改的包装器，因此

00:10:57.429 --> 00:11:04.449
非常乏味，所以这是

00:10:59.230 --> 00:11:07.689
 Java 9是我最大的胜利，我只是说数学

00:11:04.449 --> 00:11:10.410
逗号的点数一个B逗号两个C逗号

00:11:07.689 --> 00:11:15.489
三个，你可以看到这里我们正在混合

00:11:10.410 --> 00:11:19.059
的字符串和整数类型

00:11:15.489 --> 00:11:22.929
键和现在的值，所以这仅适用

00:11:19.059 --> 00:11:26.350
最多十个键值对，所以如果您

00:11:22.929 --> 00:11:27.730
有十多个键值对

00:11:26.350 --> 00:11:29.379
您想要这里是我们必须使用的地方

00:11:27.730 --> 00:11:29.889
我在说的那件事

00:11:29.379 --> 00:11:33.779
关于

00:11:29.889 --> 00:11:36.879
所以数学点输入静态方法

00:11:33.779 --> 00:11:39.279
我在这里把这种类型称为

00:11:36.879 --> 00:11:41.439
令牌类型，我们有一个从字符串到

00:11:39.279 --> 00:11:43.509
令牌类型，我们希望拥有更多

00:11:41.439 --> 00:11:46.629
那里有十个条目

00:11:43.509 --> 00:11:49.299
仅具有字符串和令牌类型

00:11:46.629 --> 00:11:53.709
并排，我们必须先包装每个

00:11:49.299 --> 00:11:57.489
那些进入地图条目，然后

00:11:53.709 --> 00:12:04.540
将所有这些作为varargs传递给新

00:11:57.489 --> 00:12:06.850
方法映射点的条目可以这样

00:12:04.540 --> 00:12:09.549
所以我刚刚谈到了API，但是我

00:12:06.850 --> 00:12:11.980
并没有告诉你太多

00:12:09.549 --> 00:12:14.739
从这些api现在返回这些

00:12:11.980 --> 00:12:17.290
返回的实现

00:12:14.739 --> 00:12:19.209
这些符合列表集和映射

00:12:17.290 --> 00:12:21.129
接口，但有不同

00:12:19.209 --> 00:12:22.749
我们从中看到的实现

00:12:21.129 --> 00:12:26.139
过去，所以你不定期

00:12:22.749 --> 00:12:27.910
其中的数组列表或哈希映射

00:12:26.139 --> 00:12:30.009
他们有很多

00:12:27.910 --> 00:12:32.410
从不同的特点

00:12:30.009 --> 00:12:34.749
现有的集合实现

00:12:32.410 --> 00:12:38.019
特别是它们是不可修改的， 

00:12:34.749 --> 00:12:40.749
好吧，我会介绍所有这些

00:12:38.019 --> 00:12:42.309
详细地说，我们不允许将null随机化

00:12:40.749 --> 00:12:45.459
迭代，否则我会尝试的

00:12:42.309 --> 00:12:47.919
花一些时间来禁止我们

00:12:45.459 --> 00:12:49.929
在列表中重复，所以可能是

00:12:47.919 --> 00:12:51.339
如果你把编程错误

00:12:49.929 --> 00:12:52.600
如果您列出一堆，则重复

00:12:51.339 --> 00:12:56.079
元素的明确内容

00:12:52.600 --> 00:12:58.779
我认为集合和地图重复

00:12:56.079 --> 00:13:00.629
非常有趣的一点是，他们

00:12:58.779 --> 00:13:04.820
空间效率比

00:13:00.629 --> 00:13:07.550
现有的收藏，尤其是hasha 

00:13:04.820 --> 00:13:16.160
而且有一些皱纹

00:13:07.550 --> 00:13:18.290
序列化，我会介绍

00:13:16.160 --> 00:13:20.240
所以所有新的静态工厂方法

00:13:18.290 --> 00:13:24.410
返回的集合实例是

00:13:20.240 --> 00:13:26.330
不可修改，因此我们的意思是

00:13:24.410 --> 00:13:28.790
相同的旧界面，但是等等

00:13:26.330 --> 00:13:30.740
可以说得到或您可以遍历

00:13:28.790 --> 00:13:31.940
收藏品或其他日常用品

00:13:30.740 --> 00:13:34.370
从收集工作中读取

00:13:31.940 --> 00:13:37.130
与他们做的完全一样

00:13:34.370 --> 00:13:40.430
常规常规时钟或

00:13:37.130 --> 00:13:44.720
现有的收藏，但是如果您

00:13:40.430 --> 00:13:47.750
尝试添加或删除或设置

00:13:44.720 --> 00:13:50.660
这些集合之一中的元素

00:13:47.750 --> 00:13:52.760
将抛出未经修改的不受支持

00:13:50.660 --> 00:13:55.850
操作异常，然后非常

00:13:52.760 --> 00:13:57.350
类似于

00:13:55.850 --> 00:13:58.790
包裹时获得的收藏

00:13:57.350 --> 00:14:01.310
有收藏点的东西

00:13:58.790 --> 00:14:03.350
不可修改的列表或地图或其他内容

00:14:01.310 --> 00:14:05.840
这样，所以我谈论了很多

00:14:03.350 --> 00:14:08.360
不变能力不变能力有什么好处

00:14:05.840 --> 00:14:10.400
是因为G难道你不想

00:14:08.360 --> 00:14:12.470
创建一个数据结构，以便您可以

00:14:10.400 --> 00:14:13.790
经常添加和删除内容

00:14:12.470 --> 00:14:15.770
你这样做，在这种情况下，你可能

00:14:13.790 --> 00:14:19.190
应该继续想使用其中一种

00:14:15.770 --> 00:14:22.430
现有的集合实现，但

00:14:19.190 --> 00:14:24.380
实际上，这是非常常见的情况

00:14:22.430 --> 00:14:28.310
要初始化一个集合

00:14:24.380 --> 00:14:32.180
一组已知的常数值，然后

00:14:28.310 --> 00:14:33.740
以后再也不要触摸它，因此您可以

00:14:32.180 --> 00:14:36.350
只要确保在您的程序中

00:14:33.740 --> 00:14:37.850
以后再也没有修改

00:14:36.350 --> 00:14:39.710
那，那会很好，但是如果

00:14:37.850 --> 00:14:41.840
然后偶然地修改了某些东西

00:14:39.710 --> 00:14:44.060
这可能是一些细微错误的来源，因此

00:14:41.840 --> 00:14:46.010
您可能会采取额外的包装步骤

00:14:44.060 --> 00:14:47.300
它在未经修改的情况下会包裹您和

00:14:46.010 --> 00:14:49.100
那会有所帮助

00:14:47.300 --> 00:14:52.190
可能是我们推荐的一件事

00:14:49.100 --> 00:14:54.170
在Java 8和更早版本中所做的

00:14:52.190 --> 00:14:55.550
这些新的便利

00:14:54.170 --> 00:14:58.220
无因式分解的方法

00:14:55.550 --> 00:15:01.340
现在，如果您可以自动修改列表

00:14:58.220 --> 00:15:03.320
要预初始化AA集合

00:15:01.340 --> 00:15:06.830
与您可能会使用的一组元素

00:15:03.320 --> 00:15:08.570
以后想修改或添加到这些

00:15:06.830 --> 00:15:12.050
收集因子仍然有用

00:15:08.570 --> 00:15:14.450
作为现有的初始化程序

00:15:12.050 --> 00:15:16.370
所以如果有的话

00:15:14.450 --> 00:15:17.889
预初始化类似

00:15:16.370 --> 00:15:21.609
哈希集，你可以说新

00:15:17.889 --> 00:15:24.129
设置ABC列表或类似内容

00:15:21.609 --> 00:15:25.509
即使您要修改

00:15:24.129 --> 00:15:27.730
这些以后的东西仍然

00:15:25.509 --> 00:15:31.540
用于初始化常规

00:15:27.730 --> 00:15:33.369
有其他收藏

00:15:31.540 --> 00:15:36.160
其他原因也使用不可修改的

00:15:33.369 --> 00:15:37.540
设置是否有一个具有

00:15:36.160 --> 00:15:39.669
内部数据结构是

00:15:37.540 --> 00:15:42.639
以收藏集为代表我有一个清单

00:15:39.669 --> 00:15:44.619
的东西，你有一个吸气剂

00:15:42.639 --> 00:15:48.790
这样可以很好地列出清单

00:15:44.619 --> 00:15:51.519
您可以分发清单，但是

00:15:48.790 --> 00:15:52.959
这将使呼叫者修改您的

00:15:51.519 --> 00:15:55.089
内部数据结构是

00:15:52.959 --> 00:15:56.649
可能不是您想做的，所以

00:15:55.089 --> 00:15:58.029
再次，你可能会非常小心，使

00:15:56.649 --> 00:16:01.029
确保没有任何来电者

00:15:58.029 --> 00:16:03.339
修改了它，但是如果是偶然或

00:16:01.029 --> 00:16:05.559
不幸的是，我们不得不

00:16:03.339 --> 00:16:07.749
考虑到呼叫者决定

00:16:05.559 --> 00:16:09.759
修改然后返回的列表

00:16:07.749 --> 00:16:12.339
会产生一些细微的错误或

00:16:09.759 --> 00:16:17.739
甚至安全漏洞，所以一堂课可以

00:16:12.339 --> 00:16:20.079
如果未修改，请保护自己

00:16:17.739 --> 00:16:22.749
有一个在内部使用的收藏

00:16:20.079 --> 00:16:25.600
可以将其包装在未修改的小包装中

00:16:22.749 --> 00:16:27.939
包装器，然后将其传递给调用方

00:16:25.600 --> 00:16:31.799
然后禁止修改

00:16:27.939 --> 00:16:34.749
新的收藏工厂也是如此

00:16:31.799 --> 00:16:36.790
您可以免费获得，所以如果您

00:16:34.749 --> 00:16:39.009
预初始化一个数据结构

00:16:36.790 --> 00:16:42.819
已经无法修改，因此您可以

00:16:39.009 --> 00:16:44.829
有罪不罚地分发出去，你知道

00:16:42.819 --> 00:16:49.089
没有其他人可以修改它， 

00:16:44.829 --> 00:16:50.889
破坏您的内部数据结构，因此

00:16:49.089 --> 00:16:54.399
还有另一个方面

00:16:50.889 --> 00:16:56.499
不可修改的是

00:16:54.399 --> 00:17:00.149
像hash这样的常规集合

00:16:56.499 --> 00:17:03.100
地图面向通用

00:17:00.149 --> 00:17:04.539
操作，包括更新，所以他们

00:17:03.100 --> 00:17:07.510
必须处理一堆不同的东西

00:17:04.539 --> 00:17:10.659
不可修改集合的情况

00:17:07.510 --> 00:17:12.760
并没有执行

00:17:10.659 --> 00:17:14.860
不可修改的收藏实际上是可以的

00:17:12.760 --> 00:17:16.899
实际上比一个简单得多

00:17:14.860 --> 00:17:19.329
的传统，因为它从来没有

00:17:16.899 --> 00:17:21.490
必须进行修改，因此特别是

00:17:19.329 --> 00:17:24.339
我们在JDK 9中的实现是

00:17:21.490 --> 00:17:26.289
打包得更紧密，因为等待

00:17:24.339 --> 00:17:28.480
一旦某物降落在某个地方

00:17:26.289 --> 00:17:30.279
放置它永远不需要移动的地方

00:17:28.480 --> 00:17:31.040
永远不需要更换，所以我们只是

00:17:30.279 --> 00:17:33.080
没有

00:17:31.040 --> 00:17:34.400
担心这种情况，所以我们可以采取

00:17:33.080 --> 00:17:37.370
的优势，使数据

00:17:34.400 --> 00:17:42.550
结构更加紧凑，而且

00:17:37.370 --> 00:17:42.550
代码复杂度大大降低

00:17:43.120 --> 00:17:49.310
所以这里有一个区别

00:17:46.280 --> 00:17:52.450
在不可修改的包装之间

00:17:49.310 --> 00:17:55.670
集合点不可修改的列表和

00:17:52.450 --> 00:18:00.020
您无法获得的收藏

00:17:55.670 --> 00:18:01.580
在第一个实际上列出so的点

00:18:00.020 --> 00:18:04.580
其实我会在下一个介绍

00:18:01.580 --> 00:18:08.510
滑动所以在这里所以我在说

00:18:04.580 --> 00:18:11.240
不可修改的列表包装器与

00:18:08.510 --> 00:18:14.600
列出了想法，所以让我们来考虑一下

00:18:11.240 --> 00:18:16.610
真正的简单代码示例在这里，我们有

00:18:14.600 --> 00:18:19.970
有一个内部列表，包含

00:18:16.610 --> 00:18:23.810
整数1 2＆3现在我们创建1个列表

00:18:19.970 --> 00:18:26.390
这是一个不可修改的列表包装器

00:18:23.810 --> 00:18:30.770
围绕该列表，然后创建一个

00:18:26.390 --> 00:18:32.450
第二个列表，即1 2 3的列表点

00:18:30.770 --> 00:18:34.310
现在那些之间有什么区别

00:18:32.450 --> 00:18:36.770
好吧，首先让我们谈谈什么是

00:18:34.310 --> 00:18:38.420
一样，所以您当然可以从两者中读取

00:18:36.770 --> 00:18:40.820
这些你可以做到的甚至可以做到的

00:18:38.420 --> 00:18:43.550
您可以为它们的每个循环做

00:18:40.820 --> 00:18:48.260
依此类推，如果您尝试致电

00:18:43.550 --> 00:18:50.480
添加或调用set方法都将

00:18:48.260 --> 00:18:52.070
抛出不受支持的操作异常，因此

00:18:50.480 --> 00:18:53.630
从这个意义上说，它们都是不可修改的

00:18:52.070 --> 00:18:56.990
这就是为什么我使用相同的词

00:18:53.630 --> 00:18:59.330
不能描述两个

00:18:56.990 --> 00:19:04.460
但有一个区别是

00:18:59.330 --> 00:19:06.830
清单1是

00:19:04.460 --> 00:19:09.500
我在这里称为内部的其他列表

00:19:06.830 --> 00:19:12.500
现在，所以实际上有点微妙

00:19:09.500 --> 00:19:17.960
名为inner的列表实际上是可修改的

00:19:12.500 --> 00:19:21.230
你可以说内点集内点集

00:19:17.960 --> 00:19:23.210
 0 17实际上它将实际上

00:19:21.230 --> 00:19:25.220
在那里改变那个值就是

00:19:23.210 --> 00:19:27.350
实际上，一个常见的混淆点是

00:19:25.220 --> 00:19:29.840
人们常常认为

00:19:27.350 --> 00:19:32.930
列表从数组点返回，列表为

00:19:29.840 --> 00:19:34.670
无法修改，甚至我都听不到

00:19:32.930 --> 00:19:36.640
它称为不可变是不正确的

00:19:34.670 --> 00:19:40.309
你实际上可以改变

00:19:36.640 --> 00:19:42.590
虽然你在那个集合中的元素

00:19:40.309 --> 00:19:45.860
无法更改其大小，这给了

00:19:42.590 --> 00:19:48.559
我认为导致这种情况的人

00:19:45.860 --> 00:19:50.570
混乱，但无论如何还是回到了

00:19:48.559 --> 00:19:53.059
包装器，但如果您列出一个作为

00:19:50.570 --> 00:19:55.610
内部列表周围的包装器，如果

00:19:53.059 --> 00:19:59.360
你改变内在的内容

00:19:55.610 --> 00:20:01.669
列出然后列出一个可以看到那些更改

00:19:59.360 --> 00:20:03.650
因此，如果您有参考列出一个

00:20:01.669 --> 00:20:05.570
您可以遍历它并查看

00:20:03.650 --> 00:20:07.580
那些，然后是其他一些

00:20:05.570 --> 00:20:10.520
您的代码会更改内部列表，如果

00:20:07.580 --> 00:20:13.010
您再次遍历列表

00:20:10.520 --> 00:20:14.809
内容有所不同，您现在可以致电

00:20:13.010 --> 00:20:16.789
列出一个方法，您将无法

00:20:14.809 --> 00:20:19.250
修改它，这就是为什么我们称其为

00:20:16.789 --> 00:20:20.870
无法修改的视图，因此它具有

00:20:19.250 --> 00:20:23.270
其他一些可能是

00:20:20.870 --> 00:20:26.179
可修改的，但是你不能修改

00:20:23.270 --> 00:20:29.029
通过这种观点等等

00:20:26.179 --> 00:20:32.059
存在不可修改的观点

00:20:29.029 --> 00:20:33.799
我在JDK中工作了很长时间

00:20:32.059 --> 00:20:37.789
想一路回到也许

00:20:33.799 --> 00:20:40.250
到现在有一​​点是新的

00:20:37.789 --> 00:20:42.620
 JDK 9中有这些新集合

00:20:40.250 --> 00:20:45.010
本身是不可修改的，它们不是

00:20:42.620 --> 00:20:47.840
其他观点，请列出2 

00:20:45.010 --> 00:20:49.880
包含元素本身，它是

00:20:47.840 --> 00:20:52.039
无法修改，因此没有其他

00:20:49.880 --> 00:20:54.230
集合漂浮在某个地方

00:20:52.039 --> 00:20:56.720
可以修改为这是一个

00:20:54.230 --> 00:21:02.600
 Solus点2的视图是列表本身

00:20:56.720 --> 00:21:04.220
它是不可修改的，所以如果您

00:21:02.600 --> 00:21:06.409
看网上的其他资料

00:21:04.220 --> 00:21:10.100
我已经做过以前的演讲

00:21:06.409 --> 00:21:12.260
说我用了不可变

00:21:10.100 --> 00:21:14.299
描述这些收藏，我已经

00:21:12.260 --> 00:21:16.010
离开了我认为我应该得到的

00:21:14.299 --> 00:21:18.320
给你一点

00:21:16.010 --> 00:21:19.520
解释你有很多

00:21:18.320 --> 00:21:21.169
网上的资料

00:21:19.520 --> 00:21:22.909
别人写了我们刚刚抄写的

00:21:21.169 --> 00:21:26.770
称这些不变的我

00:21:22.909 --> 00:21:30.110
集合和list2实际上

00:21:26.770 --> 00:21:32.980
不可变，但仅因为其内容

00:21:30.110 --> 00:21:36.409
是不可变的，所以将它们装箱

00:21:32.980 --> 00:21:39.529
 java.lang整数类是

00:21:36.409 --> 00:21:41.600
一成不变，所以如果你有一成不变

00:21:39.529 --> 00:21:44.120
不可修改的对象

00:21:41.600 --> 00:21:46.669
收集整个事情是一成不变的

00:21:44.120 --> 00:21:49.220
但是想像一下你是否带了一些弦

00:21:46.669 --> 00:21:51.169
缓冲区实例和表示出来的列表

00:21:49.220 --> 00:21:53.720
环形缓冲区一个字符串缓冲区两个字符串

00:21:51.169 --> 00:21:57.289
缓冲区三可以修改那些字符串

00:21:53.720 --> 00:21:58.970
缓冲，所以在任何情况下列表都不是

00:21:57.289 --> 00:22:01.130
返回一个不可变的集合

00:21:58.970 --> 00:22:03.590
因为其中的所有内容都是可修改的

00:22:01.130 --> 00:22:06.020
所以真的，这就是对

00:22:03.590 --> 00:22:08.570
为什么我开始转向

00:22:06.020 --> 00:22:10.340
术语变得无法修改，因此我们

00:22:08.570 --> 00:22:12.799
说收藏是不可修改的

00:22:10.340 --> 00:22:14.929
那是完全分开的

00:22:12.799 --> 00:22:16.669
您可能会发表的任何陈述中的陈述

00:22:14.929 --> 00:22:22.490
弄清楚

00:22:16.669 --> 00:22:26.570
收集还可以，所以继续前进一个

00:22:22.490 --> 00:22:27.320
我们所做的设计决定是不允许

00:22:26.570 --> 00:22:30.320
空值

00:22:27.320 --> 00:22:31.909
在新的集合实例中，如果

00:22:30.320 --> 00:22:34.370
你试图说出一个清单

00:22:31.909 --> 00:22:36.309
常见的全逗号三或类似的东西

00:22:34.370 --> 00:22:43.280
它会抛出一个nullpointerexception 

00:22:36.309 --> 00:22:44.500
所以我回想一下，如果你看

00:22:43.280 --> 00:22:48.409
引进的收藏

00:22:44.500 --> 00:22:50.870
最初在JDK 1.2中，他们确实允许

00:22:48.409 --> 00:22:53.570
空值，因此您可以将空值放在ArrayList中

00:22:50.870 --> 00:22:54.980
您可以将null放入hashmap中，但是

00:22:53.570 --> 00:22:57.200
原来没有其他收藏

00:22:54.980 --> 00:23:00.200
支持得很好

00:22:57.200 --> 00:23:01.669
实际上，大多数收藏

00:23:00.200 --> 00:23:05.870
之后介绍的收藏

00:23:01.669 --> 00:23:07.669
一分二不支持空无

00:23:05.870 --> 00:23:10.370
 java.util中的集合

00:23:07.669 --> 00:23:11.780
并发支持为空，并且

00:23:10.370 --> 00:23:14.270
有一个原因是

00:23:11.780 --> 00:23:15.650
 null为坏，我们可能应该

00:23:14.270 --> 00:23:16.370
可能会完整地谈论null 

00:23:15.650 --> 00:23:17.330
在某一点

00:23:16.370 --> 00:23:19.850
虽然我们必须谈论

00:23:17.330 --> 00:23:24.590
周四是可选的

00:23:19.850 --> 00:23:27.080
相关，但有另一个

00:23:24.590 --> 00:23:28.669
原因是空使事情

00:23:27.080 --> 00:23:32.510
很难编程，所以如果你看

00:23:28.669 --> 00:23:34.789
映射点的get方法，您将其传递给密钥， 

00:23:32.510 --> 00:23:38.150
它返回对应于的值

00:23:34.789 --> 00:23:40.340
那把钥匙好吧，如果那把钥匙会发生什么

00:23:38.150 --> 00:23:44.330
不在地图上很好吗

00:23:40.340 --> 00:23:46.610
返回null好吧，如果在那

00:23:44.330 --> 00:23:50.659
在哈希图中映射该键实际上是

00:23:46.610 --> 00:23:53.150
映射到null值，它也会返回

00:23:50.659 --> 00:23:55.820
 null，所以如果您说map get并且您得到一个

00:23:53.150 --> 00:23:57.620
返回null，你不知道键是否

00:23:55.820 --> 00:23:59.659
存在或不存在，那是一个

00:23:57.620 --> 00:24:01.500
产生的根本歧义

00:23:59.659 --> 00:24:04.200
允许null和

00:24:01.500 --> 00:24:07.410
作为实际值而不是使用它

00:24:04.200 --> 00:24:09.210
作为一个哨兵，实际上是如此

00:24:07.410 --> 00:24:12.030
在API中的多个位置发生

00:24:09.210 --> 00:24:15.450
很难分辨是否没有办法

00:24:12.030 --> 00:24:17.880
实际值是null还是那里

00:24:15.450 --> 00:24:21.990
没有价值，所以这是一个根本

00:24:17.880 --> 00:24:24.300
否否的语义问题是

00:24:21.990 --> 00:24:26.940
内部非常非常有用

00:24:24.300 --> 00:24:29.040
实现作为定点值，因此

00:24:26.940 --> 00:24:31.200
我们的集合实现

00:24:29.040 --> 00:24:34.260
使用null表示没有

00:24:31.200 --> 00:24:36.120
元素在这里，所以如果你看

00:24:34.260 --> 00:24:37.830
设置它使用封闭的实现

00:24:36.120 --> 00:24:40.290
散列在单个数组中，因此非常

00:24:37.830 --> 00:24:42.420
紧凑但为null表示不存在

00:24:40.290 --> 00:24:42.840
条目，因此搜索可以从此停止

00:24:42.420 --> 00:24:45.660
点

00:24:42.840 --> 00:24:49.590
所以我们不可能

00:24:45.660 --> 00:24:52.380
只有在我们不允许任何情况下才这样做

00:24:49.590 --> 00:24:56.850
可以存在于

00:24:52.380 --> 00:24:58.980
设置或在地图上可以继续到两个

00:24:56.850 --> 00:25:00.450
其他问题随机化迭代

00:24:58.980 --> 00:25:01.950
订单，所以这是一个这有点

00:25:00.450 --> 00:25:06.740
争议，所以如果你看

00:25:01.950 --> 00:25:09.180
大多数收藏的历史

00:25:06.740 --> 00:25:10.980
特别是基本上基于哈希

00:25:09.180 --> 00:25:13.710
因此，如果您查看哈希图

00:25:10.980 --> 00:25:17.730
实例，如果您阅读规范

00:25:13.710 --> 00:25:21.230
仔细地说，如果你

00:25:17.730 --> 00:25:23.910
遍历哈希映射的条目

00:25:21.230 --> 00:25:27.930
你会得到没有的元素

00:25:23.910 --> 00:25:30.990
特定的顺序，问题是

00:25:27.930 --> 00:25:34.400
订单实际上是可以预见的

00:25:30.990 --> 00:25:38.580
即使未指定

00:25:34.400 --> 00:25:42.630
更糟糕的是，在哈希图中

00:25:38.580 --> 00:25:45.660
哈希映射中经常使用的键类型是字符串

00:25:42.630 --> 00:25:48.030
和字符串有一个众所周知的坏哈希

00:25:45.660 --> 00:25:50.520
代码，如果您在其中放入一串字符串

00:25:48.030 --> 00:25:52.440
他们实际上会，如果您放一个

00:25:50.520 --> 00:25:54.750
一串字符串变成一个哈希集或哈希

00:25:52.440 --> 00:25:58.080
映射，然后遍历它们，他们将

00:25:54.750 --> 00:26:00.870
实际上是按排序顺序出来的，所以

00:25:58.080 --> 00:26:03.620
问题是，如果您开始依赖

00:26:00.870 --> 00:26:05.670
该命令，然后有人添加

00:26:03.620 --> 00:26:08.970
你不是的另一个价值

00:26:05.670 --> 00:26:10.860
期望并导致哈希映射

00:26:08.970 --> 00:26:12.540
重新整理自己并将其放入

00:26:10.860 --> 00:26:14.840
那个顺序就不同了

00:26:12.540 --> 00:26:18.830
更改，可能会破坏您的代码

00:26:14.840 --> 00:26:20.840
现在也许你有你可能有

00:26:18.830 --> 00:26:23.509
将代码设计得更具弹性

00:26:20.840 --> 00:26:25.580
为此，但实际上在实践中

00:26:23.509 --> 00:26:26.960
发生的是，一旦加载了哈希图

00:26:25.580 --> 00:26:28.999
有些东西往往不会改变

00:26:26.960 --> 00:26:32.029
如此多的是代码

00:26:28.999 --> 00:26:35.299
倾向于建立隐式依赖

00:26:32.029 --> 00:26:39.110
在一个键的迭代顺序上

00:26:35.299 --> 00:26:42.289
哈希图现在另一个问题是

00:26:39.110 --> 00:26:44.360
在JDK中，我们有时会更改

00:26:42.289 --> 00:26:45.769
哈希图的迭代顺序正确

00:26:44.360 --> 00:26:47.990
规范说他们不是

00:26:45.769 --> 00:26:49.909
以任何特定顺序返回，因此我们

00:26:47.990 --> 00:26:52.369
可能会更改

00:26:49.909 --> 00:26:54.080
哈希图以优化事物或

00:26:52.369 --> 00:26:55.970
为了防止安全

00:26:54.080 --> 00:26:58.399
漏洞等等

00:26:55.970 --> 00:27:01.100
确实会不时发生

00:26:58.399 --> 00:27:03.710
 JDK发布的频率相当

00:27:01.100 --> 00:27:05.720
低，这种情况并不经常发生

00:27:03.710 --> 00:27:09.440
事实上发生的最糟糕

00:27:05.720 --> 00:27:11.570
可能发生的频率，所以我们

00:27:09.440 --> 00:27:14.690
发布了JDK，一堆代码将是

00:27:11.570 --> 00:27:18.590
取决于哈希图的书面内容

00:27:14.690 --> 00:27:20.899
订购此版本的JDK 

00:27:18.590 --> 00:27:23.809
稍后，我们将更改

00:27:20.899 --> 00:27:25.850
哈希图，然后它将打破

00:27:23.809 --> 00:27:28.220
一切，所以会有一堆

00:27:25.850 --> 00:27:30.470
关于它的投诉，你知道

00:27:28.220 --> 00:27:32.419
也许对，你知道你只能得到

00:27:30.470 --> 00:27:34.220
到目前为止，对不起，如果您阅读

00:27:32.419 --> 00:27:35.090
您的代码规范错误

00:27:34.220 --> 00:27:36.980
去纠正它

00:27:35.090 --> 00:27:39.230
一段时间后变得很累

00:27:36.980 --> 00:27:41.389
大家都很累，所以

00:27:39.230 --> 00:27:42.769
问题是and和and而且渗入

00:27:41.389 --> 00:27:44.269
很难说你们需要

00:27:42.769 --> 00:27:46.399
修复您的代码，所以我不想说

00:27:44.269 --> 00:27:48.350
因为我们的代码具有相同的

00:27:46.399 --> 00:27:50.299
我们有一个问题，我们有一个错误

00:27:48.350 --> 00:27:53.269
完全相同的编译器

00:27:50.299 --> 00:27:55.009
事情，这是令人迷惑的，所以我们

00:27:53.269 --> 00:27:56.480
说你知道让我们将其更改为

00:27:55.009 --> 00:27:59.749
链接的哈希图和问题去了

00:27:56.480 --> 00:28:02.629
走了，所以很明显有一个

00:27:59.749 --> 00:28:06.350
非常严重的问题是全部代码

00:28:02.629 --> 00:28:10.639
太容易依赖于隐式排序

00:28:06.350 --> 00:28:12.769
在哈希图中，这就是所有介绍

00:28:10.639 --> 00:28:14.840
我们在这里用新的

00:28:12.769 --> 00:28:18.259
 set和set的collection实现

00:28:14.840 --> 00:28:21.799
在JDK 9中，数学的迭代顺序为

00:28:18.259 --> 00:28:23.869
随机，所以在开始的时候

00:28:21.799 --> 00:28:26.059
它在JVM启动时启动

00:28:23.869 --> 00:28:27.130
哈希种子并将其用作一部分

00:28:26.059 --> 00:28:29.650
哈希计算的

00:28:27.130 --> 00:28:32.200
所以从一个运行到下一个

00:28:29.650 --> 00:28:35.320
您所设置的集合或映射的迭代顺序

00:28:32.200 --> 00:28:38.590
从这些新的api获取将

00:28:35.320 --> 00:28:40.690
不一样，所以你可能会说哦，哦，我的

00:28:38.590 --> 00:28:44.200
天哪，这将是这将是

00:28:40.690 --> 00:28:45.610
要破坏我的代码，是的，我想

00:28:44.200 --> 00:28:48.970
在开发时破坏代码

00:28:45.610 --> 00:28:50.890
并测试它，以便您

00:28:48.970 --> 00:28:53.799
升级到

00:28:50.890 --> 00:28:58.480
下一个版本的JDK，我认为

00:28:53.799 --> 00:29:01.299
这里的原理是

00:28:58.480 --> 00:29:03.190
规范允许实施

00:29:01.299 --> 00:29:05.020
改变，但我们做了这样的

00:29:03.190 --> 00:29:07.059
带有哈希图的隐式承诺不会

00:29:05.020 --> 00:29:07.659
经常更改它，我认为

00:29:07.059 --> 00:29:10.059
是个错误

00:29:07.659 --> 00:29:12.789
所以我们在这里要做的是

00:29:10.059 --> 00:29:15.070
相同的承诺是要素

00:29:12.789 --> 00:29:16.299
没有特别的顺序返回，但是

00:29:15.070 --> 00:29:18.490
我们将要对其进行漂亮的更改

00:29:16.299 --> 00:29:22.990
经常确保该代码

00:29:18.490 --> 00:29:25.030
使用它可以适应变化

00:29:22.990 --> 00:29:26.890
迭代顺序，我希望

00:29:25.030 --> 00:29:28.809
每个人都在不断融合

00:29:26.890 --> 00:29:31.440
经常运行测试的系统

00:29:28.809 --> 00:29:35.110
会先清除这些错误

00:29:31.440 --> 00:29:36.909
在他们投入生产之前， 

00:29:35.110 --> 00:29:39.909
这里也有投资

00:29:36.909 --> 00:29:42.789
这就是我们可能想要更改

00:29:39.909 --> 00:29:45.520
这些新场景和地图的组织

00:29:42.789 --> 00:29:47.669
实施，所以现在，如果我们相信

00:29:45.520 --> 00:29:49.960
使用这些的代码是

00:29:47.669 --> 00:29:51.880
适应迭代顺序的变化

00:29:49.960 --> 00:29:53.620
我们可以完全重写此数据

00:29:51.880 --> 00:29:55.659
结构使其更加紧凑

00:29:53.620 --> 00:29:59.130
或更有效的或类似的东西

00:29:55.659 --> 00:30:02.049
如果这改变了迭代顺序

00:29:59.130 --> 00:30:04.390
没关系，因为所有代码都出来了

00:30:02.049 --> 00:30:07.960
已经有适应任何事物的能力

00:30:04.390 --> 00:30:11.190
呈现的迭代顺序

00:30:07.960 --> 00:30:15.789
现在，如果您仍然担心

00:30:11.190 --> 00:30:18.070
迭代顺序，然后先存在

00:30:15.789 --> 00:30:21.130
哈希映射和哈希之类的实现

00:30:18.070 --> 00:30:22.210
并没有改变，但是有

00:30:21.130 --> 00:30:24.789
将来仍有可能

00:30:22.210 --> 00:30:27.429
我们可能需要发布JDK 

00:30:24.789 --> 00:30:29.530
确实改变了

00:30:27.429 --> 00:30:31.840
迭代顺序（如果有问题） 

00:30:29.530 --> 00:30:34.210
那么你应该使用链接的哈希图

00:30:31.840 --> 00:30:36.280
因为那保证了特殊

00:30:34.210 --> 00:30:37.650
迭代顺序，或者您可以使用某些东西

00:30:36.280 --> 00:30:39.420
就像一张排序的地图

00:30:37.650 --> 00:30:40.740
那也保证了特别

00:30:39.420 --> 00:30:42.900
点菜，但还有一些其他

00:30:40.740 --> 00:30:44.730
与此相关的费用，但是

00:30:42.900 --> 00:30:47.850
那是要考虑的东西

00:30:44.730 --> 00:30:51.750
一直是一个问题

00:30:47.850 --> 00:30:54.510
还没有引起足够的重视

00:30:51.750 --> 00:30:56.880
我已经覆盖了我想要的大部分内容

00:30:54.510 --> 00:31:00.360
说Java在这方面不是唯一的

00:30:56.880 --> 00:31:02.700
认为其他系统已经进行

00:31:00.360 --> 00:31:06.540
遵循相同的原则，特别是

00:31:02.700 --> 00:31:09.450
语言已经有了math.random实际上

00:31:06.540 --> 00:31:10.860
从第一天开始随机迭代

00:31:09.450 --> 00:31:13.290
我相信或至少从一点开始

00:31:10.860 --> 00:31:16.230
现在python很有趣，它已经过去了

00:31:13.290 --> 00:31:19.200
在Python 2x中有一个

00:31:16.230 --> 00:31:20.820
字典及其的单一实现

00:31:19.200 --> 00:31:24.780
有一些可预测的迭代顺序

00:31:20.820 --> 00:31:28.290
在版本3.0和3.5之间

00:31:24.780 --> 00:31:29.610
实际上是随机的3.6他们得到了一个新的

00:31:28.290 --> 00:31:32.220
实施情况要好得多，但是

00:31:29.610 --> 00:31:33.660
实际上提供了可预测的迭代

00:31:32.220 --> 00:31:35.370
点餐，所以他们有一些你知道的

00:31:33.660 --> 00:31:37.920
像我们一样，他们经历了很长时间

00:31:35.370 --> 00:31:39.750
关于是否随机化的讨论

00:31:37.920 --> 00:31:43.350
是好的或可预测的迭代顺序

00:31:39.750 --> 00:31:46.320
很好，实际上很有趣

00:31:43.350 --> 00:31:48.600
看那些，因为我你知道

00:31:46.320 --> 00:31:53.370
与Java完全不同的系统

00:31:48.600 --> 00:31:55.200
但他们有相同的论据

00:31:53.370 --> 00:31:57.120
我再次重申

00:31:55.200 --> 00:31:59.700
随机迭代顺序仅适用

00:31:57.120 --> 00:32:01.770
到您从中获得的新收藏

00:31:59.700 --> 00:32:03.750
设置思想和数学思想

00:32:01.770 --> 00:32:07.860
现有的哈希图实现是

00:32:03.750 --> 00:32:12.960
没有改变，这可以

00:32:07.860 --> 00:32:16.170
所以继续前进，如果您考虑一下

00:32:12.960 --> 00:32:19.350
该功能的起源是

00:32:16.170 --> 00:32:21.600
在集合文字中，所以那里的想法

00:32:19.350 --> 00:32:24.180
您是否要声明一个集合

00:32:21.600 --> 00:32:26.430
某种类型并明确列出

00:32:24.180 --> 00:32:31.200
其中的元素如此确定

00:32:26.430 --> 00:32:32.850
设置得好的东西，然后再映射一下

00:32:31.200 --> 00:32:38.180
如果您列出了应该是行为

00:32:32.850 --> 00:32:38.180
多次相同同一元素

00:32:38.900 --> 00:32:43.970
因此，如果您要写出其中的元素

00:32:42.200 --> 00:32:46.610
集合文字可能是

00:32:43.970 --> 00:32:48.740
编程错误现在有多少

00:32:46.610 --> 00:32:53.360
其他系统所做的就是他们应用了一些

00:32:48.740 --> 00:32:58.010
像上一个规则一样获胜，我认为

00:32:53.360 --> 00:33:01.040
倾向于做的是让它微妙

00:32:58.010 --> 00:33:05.059
虫子进入生产，所以如果您

00:33:01.040 --> 00:33:06.590
有，如果你有地图，是的

00:33:05.059 --> 00:33:09.080
还有其他几个系统

00:33:06.590 --> 00:33:11.809
实际检测到重复的获胜

00:33:09.080 --> 00:33:13.790
在初始化时，但让我展示

00:33:11.809 --> 00:33:15.170
你这里的一个例子，这是一个非常

00:33:13.790 --> 00:33:17.929
与我之前显示的例子类似

00:33:15.170 --> 00:33:20.480
您要在其中初始化地图的位置

00:33:17.929 --> 00:33:23.059
现在发现了一堆数学条目

00:33:20.480 --> 00:33:24.260
这里有一个重复的，如果你

00:33:23.059 --> 00:33:26.150
眼睛锐利，您将能够发现

00:33:24.260 --> 00:33:31.880
它很快，但是有很多

00:33:26.150 --> 00:33:34.880
他们，如果你只是在初始化

00:33:31.880 --> 00:33:38.720
使用put调用的地图，然后

00:33:34.880 --> 00:33:40.520
后来有人会取代

00:33:38.720 --> 00:33:42.500
前一个，所以你可能我实际上

00:33:40.520 --> 00:33:43.610
不知道有多少元素

00:33:42.500 --> 00:33:45.980
那里有很多条目

00:33:43.610 --> 00:33:47.240
他们是十二岁，所以你可能会

00:33:45.980 --> 00:33:48.679
可能会数一下这里的行数并说

00:33:47.240 --> 00:33:50.570
有十二个条目，然后

00:33:48.679 --> 00:33:52.300
生产中有一些奇怪的问题

00:33:50.570 --> 00:33:56.360
你去调试了，就像

00:33:52.300 --> 00:33:58.670
这张地图只有11个条目

00:33:56.360 --> 00:34:00.590
这是为什么，然后你回去

00:33:58.670 --> 00:34:02.600
你盯着这个，你可能会发现

00:34:00.590 --> 00:34:04.970
可能会立即发现问题

00:34:02.600 --> 00:34:06.710
还是早上1点30分

00:34:04.970 --> 00:34:08.570
因为你被下床了

00:34:06.710 --> 00:34:11.450
通过寻呼机呼叫可能会花费您很长时间

00:34:08.570 --> 00:34:13.790
是时候看到这个了，所以我们该怎么做

00:34:11.450 --> 00:34:15.710
相反，如果您要列出

00:34:13.790 --> 00:34:19.340
像这样的元素可能是

00:34:15.710 --> 00:34:20.899
如果您有重复的元素，则会出错

00:34:19.340 --> 00:34:21.919
因为这意味着你放

00:34:20.899 --> 00:34:24.590
里面的东西实际上是

00:34:21.919 --> 00:34:26.440
被忽略，所以我们不能做

00:34:24.590 --> 00:34:29.480
不幸的是在编译时发现了

00:34:26.440 --> 00:34:32.600
理想情况是这样，但我们确实抓住了它

00:34:29.480 --> 00:34:35.690
在运行时，只要

00:34:32.600 --> 00:34:40.280
试图进入的条目或地图

00:34:35.690 --> 00:34:42.800
使用重复键初始化地图

00:34:40.280 --> 00:34:46.050
将抛出运行时异常，并且

00:34:42.800 --> 00:34:47.800
同样的情况也适用于关闭点

00:34:46.050 --> 00:34:50.800
好吧，让我谈谈太空

00:34:47.800 --> 00:34:52.929
现在提高效率，所以您可能会做一件事

00:34:50.800 --> 00:34:56.409
注意，这是与

00:34:52.929 --> 00:34:58.000
来自先前的API 

00:34:56.409 --> 00:35:02.200
收集框架的方式

00:34:58.000 --> 00:35:04.660
现有的收集框架

00:35:02.200 --> 00:35:07.960
上课的工作是他们会暴露出

00:35:04.660 --> 00:35:10.510
实现的公共类

00:35:07.960 --> 00:35:12.369
那里会有各种各样

00:35:10.510 --> 00:35:14.050
的建设者，所以如果你想

00:35:12.369 --> 00:35:16.030
如果您想要一个哈希图，您会说新的

00:35:14.050 --> 00:35:17.980
哈希图，然后您可以初始化

00:35:16.030 --> 00:35:19.630
具有大小或您可以初始化的

00:35:17.980 --> 00:35:23.260
来自另一张将复制的地图

00:35:19.630 --> 00:35:24.430
里面没有公开的要素

00:35:23.260 --> 00:35:26.320
这些新的类名

00:35:24.430 --> 00:35:27.430
实现，然后就是

00:35:26.320 --> 00:35:28.960
有点困难，因为这使他们

00:35:27.430 --> 00:35:30.550
很难谈论，所以我总是不得不

00:35:28.960 --> 00:35:32.530
说集合执行

00:35:30.550 --> 00:35:34.180
被这个螺母掉了，因为

00:35:32.530 --> 00:35:35.530
他们现在显然没有名字，如果你

00:35:34.180 --> 00:35:38.410
查看他们确实拥有的源代码

00:35:35.530 --> 00:35:40.900
名称，但这些名称不是公开的

00:35:38.410 --> 00:35:43.869
这是有原因的

00:35:40.900 --> 00:35:46.119
保留了

00:35:43.869 --> 00:35:48.550
实施者即我完全

00:35:46.119 --> 00:35:52.359
将来重新组织事情

00:35:48.550 --> 00:35:53.680
完全二进制兼容的方式

00:35:52.359 --> 00:35:55.330
特别是我会告诉你

00:35:53.680 --> 00:35:59.710
我们今天已经到位的实施

00:35:55.330 --> 00:36:01.300
这是四组，实际上是地图

00:35:59.710 --> 00:36:03.190
四个四个列表和集合，还有一个

00:36:01.300 --> 00:36:06.900
这对于地图略有变化，但

00:36:03.190 --> 00:36:09.250
聆听设置选择

00:36:06.900 --> 00:36:11.050
根本没有数组，所以如果你

00:36:09.250 --> 00:36:12.640
看一个ArrayList存储的ArrayList 

00:36:11.050 --> 00:36:16.240
数组中的此元素是

00:36:12.640 --> 00:36:18.070
甚至将物体完全分开

00:36:16.240 --> 00:36:19.450
如果您有一个元素，它将创建一个

00:36:18.070 --> 00:36:24.250
整个数组并存储其中一个

00:36:19.450 --> 00:36:26.230
因为我们知道这些

00:36:24.250 --> 00:36:28.270
连锁这些收藏永远不会走

00:36:26.230 --> 00:36:31.030
要修改的话

00:36:28.270 --> 00:36:32.830
包含一个元素，那么我们只有一个

00:36:31.030 --> 00:36:34.540
特定的实现

00:36:32.830 --> 00:36:37.390
恰好包含一个元素

00:36:34.540 --> 00:36:39.190
字段，因此对于特殊情况为零

00:36:37.390 --> 00:36:41.440
和两个我们存储的元素

00:36:39.190 --> 00:36:43.330
在一个领域中收集实际上

00:36:41.440 --> 00:36:45.550
实现这些的不同类

00:36:43.330 --> 00:36:47.140
现在对于两个以上的要素

00:36:45.550 --> 00:36:50.369
并创建一个数组和

00:36:47.140 --> 00:36:53.020
正确的大小并填充它

00:36:50.369 --> 00:36:54.760
但是0 1并没有什么神奇的

00:36:53.020 --> 00:36:57.099
 2您无法通过查看

00:36:54.760 --> 00:36:59.740
您只能通过以下方式判断API： 

00:36:57.099 --> 00:37:03.160
反射或其他东西，但

00:36:59.740 --> 00:37:05.770
好处当然是金额

00:37:03.160 --> 00:37:08.380
存储这些空间所需的空间

00:37:05.770 --> 00:37:10.869
与

00:37:08.380 --> 00:37:13.299
常规收藏，它们是

00:37:10.869 --> 00:37:15.180
较少分散在内存中，因此

00:37:13.299 --> 00:37:17.589
参考的地方应该改善

00:37:15.180 --> 00:37:19.960
所以让我们来看一个例子

00:37:17.589 --> 00:37:21.609
快速在这里，所以我们说我们想要

00:37:19.960 --> 00:37:26.200
有一个包含两个元素的集合

00:37:21.609 --> 00:37:29.680
并将其存储在未修改的地图中

00:37:26.200 --> 00:37:31.780
常规Java Java 8的流行方式

00:37:29.680 --> 00:37:33.069
我们创建一个新的哈希集，其中包含三个

00:37:31.780 --> 00:37:35.230
桶，因为我们不希望它

00:37:33.069 --> 00:37:37.420
调整大小，因此必须有三个水桶

00:37:35.230 --> 00:37:39.520
为了存储两个元素，我们添加了

00:37:37.420 --> 00:37:42.280
这两个元素，然后我们包装

00:37:39.520 --> 00:37:44.950
在未经修改的包装纸中

00:37:42.280 --> 00:37:45.280
好吧，让我们计算一下

00:37:44.950 --> 00:37:47.589
那里

00:37:45.280 --> 00:37:49.750
有不可修改的包装

00:37:47.589 --> 00:37:51.880
哈希集现在证明了

00:37:49.750 --> 00:37:54.700
哈希集是根据

00:37:51.880 --> 00:37:57.250
哈希图，所以哈希图对不起哈希集

00:37:54.700 --> 00:37:59.319
包含哈希映射的实例，因此

00:37:57.250 --> 00:38:01.839
那是我们的第三个对象，现在是哈希图

00:37:59.319 --> 00:38:03.819
有一个数组是

00:38:01.839 --> 00:38:06.750
条目和另一个对象的数组

00:38:03.819 --> 00:38:10.180
这是四个对象，然后每个

00:38:06.750 --> 00:38:13.799
哈希图的条目存储在

00:38:10.180 --> 00:38:17.500
节点对象，所以现在我们有六个对象

00:38:13.799 --> 00:38:19.180
所以这是一个图

00:38:17.500 --> 00:38:20.530
看起来我们有我们有一套

00:38:19.180 --> 00:38:22.930
指向不可修改的参考

00:38:20.530 --> 00:38:24.970
哈希处的包装器设置哈希图

00:38:22.930 --> 00:38:27.400
表是一个数组，然后是两个

00:38:24.970 --> 00:38:29.410
节点元素，那就是您的六个

00:38:27.400 --> 00:38:32.829
那是你的六个物体，不，我不是

00:38:29.410 --> 00:38:34.690
谈论内容或

00:38:32.829 --> 00:38:36.730
有效载荷本身正确，所以我不是

00:38:34.690 --> 00:38:40.480
数弦，有一个

00:38:36.730 --> 00:38:43.270
特别那里有一个特别的价值

00:38:40.480 --> 00:38:44.950
当您获取哈希图时

00:38:43.270 --> 00:38:47.020
作为哈希集的一部分实现

00:38:44.950 --> 00:38:49.059
只数事物的对象

00:38:47.020 --> 00:38:51.160
被创建为

00:38:49.059 --> 00:38:54.520
收集本身，所以有六个对象

00:38:51.160 --> 00:38:57.549
好吧，那么有多少内存

00:38:54.520 --> 00:39:00.490
每个对象都在典型的JVM中使用

00:38:57.549 --> 00:39:03.310
每个对象都有一个十二字节的对象

00:39:00.490 --> 00:39:06.880
标头加上大约四个

00:39:03.310 --> 00:39:10.060
对于每个对象引用或int字段

00:39:06.880 --> 00:39:11.440
或更小的较小的原始字段，以及

00:39:10.060 --> 00:39:13.570
所以这些不完全取决于

00:39:11.440 --> 00:39:15.520
正是您在使用什么

00:39:13.570 --> 00:39:17.920
 JVM配置是，但这是一个

00:39:15.520 --> 00:39:21.190
球场估计，所以事实证明

00:39:17.920 --> 00:39:24.370
六个对象一起所有

00:39:21.190 --> 00:39:27.030
其他领域，等等

00:39:24.370 --> 00:39:31.090
具有两个元素的不可修改集合

00:39:27.030 --> 00:39:32.500
 152个字节，令人惊讶地大，但是

00:39:31.090 --> 00:39:36.460
我们已经住了很长时间

00:39:32.500 --> 00:39:38.170
而且令人惊讶的是，它实际上并没有

00:39:36.460 --> 00:39:39.970
直到最近我还是一个问题

00:39:38.170 --> 00:39:41.710
确定为什么，但是这就是越来越多

00:39:39.970 --> 00:39:43.360
我认为人们的货币

00:39:41.710 --> 00:39:44.620
正在尝试收拾更多他们正在尝试的东西

00:39:43.360 --> 00:39:46.770
以提高他们的效率

00:39:44.620 --> 00:39:49.660
系统，如果您正在运行

00:39:46.770 --> 00:39:52.390
然后在云中成千上万个实例

00:39:49.660 --> 00:39:54.910
如果堆太大，那

00:39:52.390 --> 00:39:57.820
表示您可以执行的实例数

00:39:54.910 --> 00:39:59.550
在云中的每个物理节点上运行

00:39:57.820 --> 00:40:01.840
减少，所以人们

00:39:59.550 --> 00:40:03.400
专注于减少他们的堆

00:40:01.840 --> 00:40:05.760
大小等等，这就是这个

00:40:03.400 --> 00:40:08.200
这个问题开始出现了很多

00:40:05.760 --> 00:40:09.940
好吧，让我们将其与

00:40:08.200 --> 00:40:12.550
到新的实现

00:40:09.940 --> 00:40:14.680
由设置点返回，所以代码在这里

00:40:12.550 --> 00:40:17.590
是说设置foo bar的点，所以

00:40:14.680 --> 00:40:19.210
源代码很好，更简单，但是如果

00:40:17.590 --> 00:40:21.040
您查看创建的对象

00:40:19.210 --> 00:40:24.070
有一个内部实现

00:40:21.040 --> 00:40:26.320
称为第二集

00:40:24.070 --> 00:40:30.370
正好存储在两个元素中

00:40:26.320 --> 00:40:34.870
该领域，所以只需要20 

00:40:30.370 --> 00:40:36.580
字节，如果有的话

00:40:34.870 --> 00:40:38.440
这样的结构可以减少您的

00:40:36.580 --> 00:40:39.970
再次消耗空间

00:40:38.440 --> 00:40:43.570
这是开销，您可以减少

00:40:39.970 --> 00:40:47.260
存储这些数据的开销

00:40:43.570 --> 00:40:50.760
项目从152字节到20字节，所以我们

00:40:47.260 --> 00:40:55.090
认为这真的非常有用

00:40:50.760 --> 00:40:56.620
空间优化，尤其是JDK 

00:40:55.090 --> 00:40:58.420
本身已经开始使用这些

00:40:56.620 --> 00:41:00.400
作为其内部一部分的实现

00:40:58.420 --> 00:41:03.280
启动并作为内部数据的一部分

00:41:00.400 --> 00:41:05.230
例如模块系统的结构和

00:41:03.280 --> 00:41:06.760
那些家伙很高兴与

00:41:05.230 --> 00:41:08.770
这不仅使其来源

00:41:06.760 --> 00:41:11.770
代码更好，但实际上减少了

00:41:08.770 --> 00:41:15.059
占用的空间，所以我们可以

00:41:11.770 --> 00:41:17.849
提供一个具有

00:41:15.059 --> 00:41:20.490
降低了

00:41:17.849 --> 00:41:22.890
从缅因州开始

00:41:20.490 --> 00:41:24.660
实际上使用得很好，它可以做更多的工作

00:41:22.890 --> 00:41:27.210
因为模块系统，但是

00:41:24.660 --> 00:41:30.260
越少越少，它本来就有

00:41:27.210 --> 00:41:32.789
如果我们使用传统收藏

00:41:30.260 --> 00:41:35.640
好吧，关于序列化的简短介绍

00:41:32.789 --> 00:41:38.369
是的，元素是集合

00:41:35.640 --> 00:41:41.309
从这些返回的实现

00:41:38.369 --> 00:41:45.240
方法真的可以序列化

00:41:41.309 --> 00:41:48.420
使用序列化，但我们使用

00:41:45.240 --> 00:41:50.640
保留序列化代理机制

00:41:48.420 --> 00:41:53.819
那些内部实现隐藏了

00:41:50.640 --> 00:41:56.789
我们可以重新实现

00:41:53.819 --> 00:41:59.099
与我自己兼容的主要

00:41:56.789 --> 00:42:01.589
要点是如果你是

00:41:59.099 --> 00:42:06.529
序列化现有集合，例如

00:42:01.589 --> 00:42:09.390
 ArrayList或hashmap那些将

00:42:06.529 --> 00:42:10.770
这些将继续，我的意思是那些是

00:42:09.390 --> 00:42:13.319
可序列化，他们将继续工作

00:42:10.770 --> 00:42:16.260
在JDK 8和JDK 9之间

00:42:13.319 --> 00:42:18.690
但是，如果您创建这些实例

00:42:16.260 --> 00:42:21.960
新收藏并对其进行序列化

00:42:18.690 --> 00:42:24.270
不能在JDK 8和

00:42:21.960 --> 00:42:26.099
较早，所以您考虑得很好

00:42:24.270 --> 00:42:28.170
这些类不存在

00:42:26.099 --> 00:42:29.849
早期版本，但如果您有

00:42:28.170 --> 00:42:31.950
您进行序列化的环境

00:42:29.849 --> 00:42:34.650
事情和跨不同的JVM 

00:42:31.950 --> 00:42:36.599
版本或您可能的JDK版本

00:42:34.650 --> 00:42:40.849
应该远离这些，直到每个

00:42:36.599 --> 00:42:44.520
直到每个实例都在JDK 9上启动

00:42:40.849 --> 00:42:47.039
在某些事情上可以简单地说一下

00:42:44.520 --> 00:42:49.559
我正在为下一个版本的JDK进行开发

00:42:47.039 --> 00:42:54.180
 10不，我猜它实际上叫做JDK 

00:42:49.559 --> 00:42:57.660
 18.3现在很漂亮

00:42:54.180 --> 00:42:59.910
很难创建这些实例

00:42:57.660 --> 00:43:02.339
具有任意元素的集合

00:42:59.910 --> 00:43:04.140
如果你把它们列出来的话

00:43:02.339 --> 00:43:05.910
向您展示了API就是这样做的，但是

00:43:04.140 --> 00:43:07.500
有时候你想做的就是阅读

00:43:05.910 --> 00:43:10.980
从某个地方或从他们计算

00:43:07.500 --> 00:43:13.079
某个地方，得到一堆

00:43:10.980 --> 00:43:16.770
元素，然后将它们加载到

00:43:13.079 --> 00:43:18.839
无法修改的收藏，所以我

00:43:16.770 --> 00:43:20.819
建议添加新的方法副本

00:43:18.839 --> 00:43:21.470
将从现有馆藏中复制或

00:43:20.819 --> 00:43:25.280
地图

00:43:21.470 --> 00:43:26.900
然后在视频流的结尾

00:43:25.280 --> 00:43:28.790
可能想做梦的计算

00:43:26.900 --> 00:43:30.170
然后转储出来的元素

00:43:28.790 --> 00:43:32.840
在流的末尾

00:43:30.170 --> 00:43:35.630
无法修改的收藏，所以我建议

00:43:32.840 --> 00:43:37.970
一个新的收藏家家族

00:43:35.630 --> 00:43:40.310
不幸的是，这些都不在Java 9中

00:43:37.970 --> 00:43:42.770
但建议在下一个

00:43:40.310 --> 00:43:44.180
发布将会有

00:43:42.770 --> 00:43:47.720
一些讨论，但是我们

00:43:44.180 --> 00:43:51.619
工作编号是18点3，所以JDK 18.3 

00:43:47.720 --> 00:43:54.320
这些建议很快就好了

00:43:51.619 --> 00:43:56.720
总结，然后我们可能有时间

00:43:54.320 --> 00:43:58.609
一两个问题收集

00:43:56.720 --> 00:44:00.590
收藏框架已经19岁了

00:43:58.609 --> 00:44:03.320
所以它几乎和其余的一样古老

00:44:00.590 --> 00:44:05.599
 Java，但我仍然有很多地方

00:44:03.320 --> 00:44:07.640
我认为这非常有用

00:44:05.599 --> 00:44:09.740
今天每个人都在使用它，所以我们

00:44:07.640 --> 00:44:13.190
继续增强并使其

00:44:09.740 --> 00:44:14.810
 JDK Nine的亮点更加有用

00:44:13.190 --> 00:44:16.430
集合是新集合

00:44:14.810 --> 00:44:18.980
我刚刚遇到的工厂方法

00:44:16.430 --> 00:44:21.020
过去45分钟内谈论和JDK 9 

00:44:18.980 --> 00:44:22.910
现在发货了

00:44:21.020 --> 00:44:25.099
很高兴更新我一直给的

00:44:22.910 --> 00:44:28.310
这个演讲一年左右，现在我可以

00:44:25.099 --> 00:44:30.530
说JDK 9真的在那里

00:44:28.310 --> 00:44:35.210
可以从任一打开的GT下载

00:44:30.530 --> 00:44:37.790
 JDK或来自Oracle的Java网站，因此您

00:44:35.210 --> 00:44:39.619
可以在Twitter上与我联系，或者您可以使用

00:44:37.790 --> 00:44:43.160
右上角的hash标签

00:44:39.619 --> 00:44:44.869
你可能有时间一两个

00:44:43.160 --> 00:44:49.900
在我们出去之前快速提问

00:44:44.869 --> 00:44:49.900
有人在那里有吗

00:44:57.810 --> 00:45:16.780
好吧，那我可以

00:45:15.369 --> 00:45:18.430
听到您的声音，但我们快用完了

00:45:16.780 --> 00:45:19.690
时间，让我让我让我尝试

00:45:18.430 --> 00:45:21.280
回应，然后我可以和你谈谈

00:45:19.690 --> 00:45:23.830
之后，但问题是关于

00:45:21.280 --> 00:45:25.720
关于重复的重复密钥

00:45:23.830 --> 00:45:28.500
不适用于哈希的行为

00:45:25.720 --> 00:45:31.450
数学哈希图java.util hashmaps 

00:45:28.500 --> 00:45:34.660
行为不变，因此

00:45:31.450 --> 00:45:38.440
重复密钥仅适用于新api 

00:45:34.660 --> 00:45:39.760
数学点的数学点和是的

00:45:38.440 --> 00:45:42.640
那里有一些争议

00:45:39.760 --> 00:45:44.500
那但是为什么我们不谈论这个

00:45:42.640 --> 00:45:45.359
之后，我也许可以提供帮助

00:45:44.500 --> 00:45:48.660
你与它

00:45:45.359 --> 00:45:48.660
还有一个问题

00:45:57.360 --> 00:46:01.810
好吧，这个问题是关于

00:45:59.860 --> 00:46:05.260
内部实现我为什么停下来

00:46:01.810 --> 00:46:06.640
在两个字段而不是十个字段中

00:46:05.260 --> 00:46:08.470
感觉是任意的

00:46:06.640 --> 00:46:11.650
我相信这里有指数

00:46:08.470 --> 00:46:13.810
一组元素数量的衰减

00:46:11.650 --> 00:46:17.680
因此您从中获得的空间优势

00:46:13.810 --> 00:46:20.020
有五个田地或十英尺长，是的，你

00:46:17.680 --> 00:46:23.710
知道专门的集合实现

00:46:20.020 --> 00:46:26.620
具有五个元素的字段

00:46:23.710 --> 00:46:29.230
比说的有用得多

00:46:26.620 --> 00:46:31.630
零一个和两个元素，因为你

00:46:29.230 --> 00:46:35.140
知道出现更多元素的集合

00:46:31.630 --> 00:46:37.720
不太频繁，但您知道我们

00:46:35.140 --> 00:46:39.550
收集更多的数据，我们可能会遇到一些

00:46:37.720 --> 00:46:41.320
有人说你知道我用的情况

00:46:39.550 --> 00:46:43.420
始终设置三个元素

00:46:41.320 --> 00:46:45.070
我们为此支付了额外的存储费用

00:46:43.420 --> 00:46:47.290
那些在数组中，所以我们可以添加一个

00:46:45.070 --> 00:46:49.240
第三，第三套实现

00:46:47.290 --> 00:46:50.770
那或者实际上我们甚至可能去

00:46:49.240 --> 00:46:52.150
换句话说，还有其他一些原因

00:46:50.770 --> 00:46:53.860
可能希望减少数量

00:46:52.150 --> 00:46:55.300
类，因为它会影响JIT 

00:46:53.860 --> 00:46:58.120
特别是汇编

00:46:55.300 --> 00:46:59.590
晦涩的时尚，所以重点是我们可以

00:46:58.120 --> 00:47:02.680
完全改变实现

00:46:59.590 --> 00:47:04.120
透明，兼容等

00:47:02.680 --> 00:47:05.860
您的代码不必更改您

00:47:04.120 --> 00:47:08.230
无需重新编译，API是

00:47:05.860 --> 00:47:09.670
不必更改任何一个都可以

00:47:08.230 --> 00:47:10.970
那时我们没时间了，谢谢

00:47:09.670 --> 00:47:16.150
非常喜欢复制

00:47:10.970 --> 00:47:16.150
 [掌声] 

