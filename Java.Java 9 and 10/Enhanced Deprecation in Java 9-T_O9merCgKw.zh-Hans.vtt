WEBVTT
Kind: captions
Language: zh-Hans

00:00:04.850 --> 00:00:09.469
你好，下午好，欢迎感谢

00:00:07.819 --> 00:00:13.879
来我的谈话我叫斯图尔特

00:00:09.469 --> 00:00:17.060
我也被称为博士。不推荐使用

00:00:13.879 --> 00:00:20.359
我在JDK核心库团队中工作

00:00:17.060 --> 00:00:22.840
在Oracle，所以今天的话题是

00:00:20.359 --> 00:00:25.690
我将给予更高的折旧费

00:00:22.840 --> 00:00:29.119
该概念的简要历史，以及

00:00:25.690 --> 00:00:31.460
弃用的历史，但有

00:00:29.119 --> 00:00:35.260
关于折旧的很多工作，我已经

00:00:31.460 --> 00:00:40.780
完成了我在jdk中完成的大部分工作

00:00:35.260 --> 00:00:45.760
 9v正在进行很多工作， 

00:00:40.780 --> 00:00:48.199
大部分工作是了解

00:00:45.760 --> 00:00:50.089
通知和警告发生以及什么

00:00:48.199 --> 00:00:51.499
他们服务的目的和政策

00:00:50.089 --> 00:00:53.449
虽然，所以我会说支出

00:00:51.499 --> 00:00:57.620
有一段时间谈论的细节

00:00:53.449 --> 00:01:00.530
那然后有点奇怪我

00:00:57.620 --> 00:01:02.659
最后的子弹应该是未来的工作

00:01:00.530 --> 00:01:04.820
所以有很多工作要做

00:01:02.659 --> 00:01:07.820
 jdk 9，然后有一些

00:01:04.820 --> 00:01:10.250
以后的工作，因此有一个

00:01:07.820 --> 00:01:12.200
此演讲的twitter标签

00:01:10.250 --> 00:01:15.079
如果您需要跟进，则弃用

00:01:12.200 --> 00:01:19.460
问题或意见，请

00:01:15.079 --> 00:01:21.490
与该标签一起发推，好吧，让我们

00:01:19.460 --> 00:01:24.259
退后一点，看看

00:01:21.490 --> 00:01:25.880
系统开发生命周期

00:01:24.259 --> 00:01:27.320
这是这些之一

00:01:25.880 --> 00:01:29.390
所有这些不同阶段的图表

00:01:27.320 --> 00:01:31.189
我从维基百科上摘下来的是

00:01:29.390 --> 00:01:32.960
很传统，你开始做某事

00:01:31.189 --> 00:01:35.090
你开发它，你知道它得到

00:01:32.960 --> 00:01:36.649
审查它得到它得到通过

00:01:35.090 --> 00:01:40.280
迭代投入生产

00:01:36.649 --> 00:01:43.100
等等，然后是什么

00:01:40.280 --> 00:01:47.600
发生到最后，他们打电话

00:01:43.100 --> 00:01:50.689
这个阶段的性格和极端

00:01:47.600 --> 00:01:52.850
很少注意到结尾

00:01:50.689 --> 00:01:55.249
系统生命周期，这就是事实

00:01:52.850 --> 00:01:57.350
弃用即将发生，在Java中， 

00:01:55.249 --> 00:01:59.030
在JDK小组中，我们确实

00:01:57.350 --> 00:02:01.579
长期来看Java平台

00:01:59.030 --> 00:02:03.219
学期，所以我们开始支付更多

00:02:01.579 --> 00:02:05.539
注意生命周期的结束

00:02:03.219 --> 00:02:07.369
您可能参加过的大多数谈话

00:02:05.539 --> 00:02:09.050
到这里在javaone或关于什么

00:02:07.369 --> 00:02:11.390
新的东西是新的，令人兴奋的， 

00:02:09.050 --> 00:02:14.090
不同，那太好了，我认为我们

00:02:11.390 --> 00:02:16.250
所有人都喜欢那东西，但必须

00:02:14.090 --> 00:02:18.290
用旧的东西完成，所以

00:02:16.250 --> 00:02:21.060
这个话题是关于什么

00:02:18.290 --> 00:02:23.760
所以我来谈谈生命周期

00:02:21.060 --> 00:02:25.950
与生命周期截然不同的API 

00:02:23.760 --> 00:02:27.750
一种产品也许你们中的许多人

00:02:25.950 --> 00:02:31.469
熟悉您对产品的想法

00:02:27.750 --> 00:02:34.230
你把它投入生产

00:02:31.469 --> 00:02:36.709
通过一些支持，那里有错误修复和

00:02:34.230 --> 00:02:39.269
然后随着时间的推移，错误修复的数量

00:02:36.709 --> 00:02:41.310
落后，只有关键或

00:02:39.269 --> 00:02:43.889
 showstopper错误得到修复，然后也许

00:02:41.310 --> 00:02:46.010
的仅安全漏洞

00:02:43.889 --> 00:02:49.230
最大的紧迫性，但在某些时候

00:02:46.010 --> 00:02:51.659
那就是如果你退休了

00:02:49.230 --> 00:02:53.329
运送商业软件产品

00:02:51.659 --> 00:02:56.700
发生了什么事

00:02:53.329 --> 00:02:59.129
寿命终止过程（如支持终止） 

00:02:56.700 --> 00:03:01.019
生命过后， 

00:02:59.129 --> 00:03:02.730
在此之后，较少的错误修复版本

00:03:01.019 --> 00:03:05.430
没有完全的支持，不是

00:03:02.730 --> 00:03:07.620
现在支持了生命周期

00:03:05.430 --> 00:03:09.810
 API有点不同

00:03:07.620 --> 00:03:12.540
事情会随着时间的推移发生

00:03:09.810 --> 00:03:16.379
它发生在

00:03:12.540 --> 00:03:19.349
 Java平台，所以如果您看一下

00:03:16.379 --> 00:03:22.199
您知道的Java平台版本

00:03:19.349 --> 00:03:25.109
 JDK 1 2 3 4 5及更高版本，我们正在开发JD 

00:03:22.199 --> 00:03:28.409
 k9现在生活在API的生命周期中

00:03:25.109 --> 00:03:30.540
可能会在一处被介绍

00:03:28.409 --> 00:03:33.959
 JDK实时发布了多个版本

00:03:30.540 --> 00:03:36.569
然后退休，但jdk 

00:03:33.959 --> 00:03:38.459
本身和Java平台继续

00:03:36.569 --> 00:03:41.340
连续发行，所以实际上

00:03:38.459 --> 00:03:43.500
 api的介绍，然后是其

00:03:41.340 --> 00:03:45.599
生活和支持以及错误修复

00:03:43.500 --> 00:03:47.879
然后从中删除该功能

00:03:45.599 --> 00:03:54.560
 java平台虽然平台

00:03:47.879 --> 00:03:57.750
本身继续确定的关键概念

00:03:54.560 --> 00:04:01.109
弃用的是设计师和

00:03:57.750 --> 00:04:03.780
与API通信的维护者

00:04:01.109 --> 00:04:06.180
您是开发商或消费者

00:04:03.780 --> 00:04:09.060
有关正在发生的事情的API信息

00:04:06.180 --> 00:04:11.699
使用该API，尤其是当

00:04:09.060 --> 00:04:14.099
该API开始到达末尾

00:04:11.699 --> 00:04:17.099
它的生命周期弃用是

00:04:14.099 --> 00:04:19.859
维护者说好，你应该

00:04:17.099 --> 00:04:23.370
开始对此有所不同的思考

00:04:19.859 --> 00:04:25.289
 API及其使用情况，其中之一

00:04:23.370 --> 00:04:27.870
你应该采取的方式之一

00:04:25.289 --> 00:04:29.190
如果您使用的API已弃用，则该操作是

00:04:27.870 --> 00:04:31.370
你应该开始考虑吗

00:04:29.190 --> 00:04:34.260
从那里迁移

00:04:31.370 --> 00:04:40.170
可能有几个原因

00:04:34.260 --> 00:04:42.260
我们可能为什么我们可能决定增加

00:04:40.170 --> 00:04:46.080
向下支持甚至最终删除

00:04:42.260 --> 00:04:48.540
 ap来自JDK，一个来自

00:04:46.080 --> 00:04:51.330
这有什么问题，所以

00:04:48.540 --> 00:04:53.610
如果您正在使用该API，则应该

00:04:51.330 --> 00:04:55.530
应该被告知发生了什么事情

00:04:53.610 --> 00:04:57.060
你应该明白什么是什么

00:04:55.530 --> 00:05:00.360
错误或有什么风险

00:04:57.060 --> 00:05:04.260
使用它有时我们引入了

00:05:00.360 --> 00:05:06.780
新的或更好的API，您的程序将

00:05:04.260 --> 00:05:09.210
运行更好更快质量更高

00:05:06.780 --> 00:05:12.480
生动活泼或使用此新API的任何东西

00:05:09.210 --> 00:05:14.400
而不是这个较旧的那个

00:05:12.480 --> 00:05:18.180
另一种形式的通知，然后

00:05:14.400 --> 00:05:21.510
最后，如果我们打算删除

00:05:18.180 --> 00:05:23.700
完全来自JDK的API，那么

00:05:21.510 --> 00:05:27.240
非常认真的一步，实际上

00:05:23.700 --> 00:05:29.040
中断程序，所以有一个偶数

00:05:27.240 --> 00:05:31.260
需要的更强大的通知形式

00:05:29.040 --> 00:05:34.410
在那里发生，因为我们不想

00:05:31.260 --> 00:05:37.770
人们对该程序的惊讶

00:05:34.410 --> 00:05:40.350
打破所有权利，让我们开始吧

00:05:37.770 --> 00:05:42.510
远离这里的基本概念， 

00:05:40.350 --> 00:05:45.240
说说一些历史

00:05:42.510 --> 00:05:48.840
 JDK 1.1中引入了弃用

00:05:45.240 --> 00:05:50.790
而且没有注释

00:05:48.840 --> 00:05:53.310
时间注释没有来了好几次

00:05:50.790 --> 00:05:56.930
几年后，所以这是

00:05:53.310 --> 00:06:02.420
引入是作为javadoc标签在

00:05:56.930 --> 00:06:04.410
不推荐使用带有较小首字母d的a 

00:06:02.420 --> 00:06:07.010
现在有趣的是

00:06:04.410 --> 00:06:10.290
关于这个的很多口述历史

00:06:07.010 --> 00:06:13.500
原来的折旧工作已经完成

00:06:10.290 --> 00:06:15.600
现在是JVM的John Rose 

00:06:13.500 --> 00:06:18.000
建筑师，他可能看过讲座

00:06:15.600 --> 00:06:20.850
关于他的这次会议或材料

00:06:18.000 --> 00:06:24.480
他在做Valhalla项目， 

00:06:20.850 --> 00:06:25.620
现在无论如何要计划巴拿马，所以我当时在

00:06:24.480 --> 00:06:27.090
昨晚和他共进晚餐，我们

00:06:25.620 --> 00:06:28.260
谈论你知道所以你怎么样

00:06:27.090 --> 00:06:30.900
会谈，我说哦，我有一个

00:06:28.260 --> 00:06:32.700
弃用话题，我当然知道他

00:06:30.900 --> 00:06:34.950
我认识他已有几年了

00:06:32.700 --> 00:06:36.570
说哦，是的，是的，我记得他

00:06:34.950 --> 00:06:39.120
说我记得过时了

00:06:36.570 --> 00:06:40.980
他是他的新人

00:06:39.120 --> 00:06:44.250
当时的Java及其原因

00:06:40.980 --> 00:06:45.030
詹姆斯·高斯林（James Gosling）被弃用了

00:06:44.250 --> 00:06:47.910
原始

00:06:45.030 --> 00:06:50.340
 Java语言对api有一些疑虑

00:06:47.910 --> 00:06:52.260
在平台上，他是

00:06:50.340 --> 00:06:54.150
担心要对此做些什么

00:06:52.260 --> 00:06:55.200
所以他们想出了这个主意

00:06:54.150 --> 00:06:58.080
好吧，如果有的话

00:06:55.200 --> 00:06:59.400
关注此API，那么我们需要

00:06:58.080 --> 00:07:00.990
说些什么

00:06:59.400 --> 00:07:07.470
不赞成使用，那就是这个地方

00:07:00.990 --> 00:07:09.060
起源，所以无论如何在1.1中

00:07:07.470 --> 00:07:11.310
引入了弃用机制

00:07:09.060 --> 00:07:14.760
这是Javadoc标签，然后

00:07:11.310 --> 00:07:18.300
最初的排便浪潮如此

00:07:14.760 --> 00:07:20.640
一些API，例如线程破坏

00:07:18.300 --> 00:07:22.380
使用线程破坏是不可能的

00:07:20.640 --> 00:07:24.660
现在安全地不是真的

00:07:22.380 --> 00:07:27.030
已实施，但目的是

00:07:24.660 --> 00:07:28.430
如果线程正在运行

00:07:27.030 --> 00:07:34.880
只是停在自己的轨道上

00:07:28.430 --> 00:07:37.470
反正不好，所以不可能

00:07:34.880 --> 00:07:39.800
忘记是否曾经实施过

00:07:37.470 --> 00:07:42.210
忘记它实际上做了什么，但是

00:07:39.800 --> 00:07:45.060
安全地使用它是不可能的， 

00:07:42.210 --> 00:07:46.380
因此，该标记已被弃用， 

00:07:45.060 --> 00:07:48.540
然后有一个很长的解释

00:07:46.380 --> 00:07:50.610
我想约翰·罗斯（John Rose）写的是他们的

00:07:48.540 --> 00:07:52.380
您仍然可以在Javadoc yr中找到它

00:07:50.610 --> 00:07:56.850
破坏停止，暂停并继续

00:07:52.380 --> 00:07:59.100
弃用，但随后使用弃用

00:07:56.850 --> 00:08:02.970
由于完全不同的原因，所以

00:07:59.100 --> 00:08:05.340
在桌面上工作的家伙

00:08:02.970 --> 00:08:08.760
当时是TBT那些台式机

00:08:05.340 --> 00:08:11.550
 api他们决定好吧，我们有

00:08:08.760 --> 00:08:12.870
我们有一个组件类，您可以

00:08:11.550 --> 00:08:14.640
显示一个组件，您可以隐藏一个

00:08:12.870 --> 00:08:17.310
组件，但为了使它

00:08:14.640 --> 00:08:19.500
与netbeans兼容对不起

00:08:17.310 --> 00:08:23.010
意思是为了使它成为javabeans 

00:08:19.500 --> 00:08:26.550
与javabeans兼容的想法是

00:08:23.010 --> 00:08:28.820
设置财产，所以他们说还可以

00:08:26.550 --> 00:08:31.950
而不是显示隐藏，让我们改变

00:08:28.820 --> 00:08:34.800
更改这两个setvisible true或

00:08:31.950 --> 00:08:36.480
错误，因此他们弃用了show和

00:08:34.800 --> 00:08:38.730
现在隐藏，没有任何错误

00:08:36.480 --> 00:08:42.090
向大家打招呼并不危险

00:08:38.730 --> 00:08:44.250
根本上，实际上是那些自定义的人

00:08:42.090 --> 00:08:47.790
组件/路演和隐藏等

00:08:44.250 --> 00:08:48.960
那些方法最终导致了

00:08:47.790 --> 00:08:51.600
没有他就无法删除他

00:08:48.960 --> 00:08:54.180
破坏兼容性的问题

00:08:51.600 --> 00:08:56.610
在JDK中有很多东西

00:08:54.180 --> 00:08:58.070
很快就弃用了，这导致了

00:08:56.610 --> 00:09:00.500
很多破坏

00:08:58.070 --> 00:09:02.060
和过时引起的介绍

00:09:00.500 --> 00:09:03.410
编译器警告，所以有

00:09:02.060 --> 00:09:05.240
引起广泛关注，因为人们

00:09:03.410 --> 00:09:06.500
重新编译该程序的很多

00:09:05.240 --> 00:09:08.900
警告，他们说哦，不，这是什么

00:09:06.500 --> 00:09:10.820
继续下去，所以我们刹车了

00:09:08.900 --> 00:09:13.100
一切都不要过时

00:09:10.820 --> 00:09:15.350
在那之后的任何其他事情

00:09:13.100 --> 00:09:17.210
弃用率减慢了

00:09:15.350 --> 00:09:18.890
相当多，实际上什么也没有

00:09:17.210 --> 00:09:20.930
由于最初被删除

00:09:18.890 --> 00:09:25.520
你的反应知道你不会摆脱

00:09:20.930 --> 00:09:27.500
所有这些东西，以便保持现状

00:09:25.520 --> 00:09:32.030
直到Java一直保持一致

00:09:27.500 --> 00:09:34.130
五现在的一些机制

00:09:32.030 --> 00:09:36.440
 Java 5中弃用已更改

00:09:34.130 --> 00:09:39.920
因为注释机制是

00:09:36.440 --> 00:09:43.610
介绍，所以而不是有一个

00:09:39.920 --> 00:09:45.590
注释中的javadoc标记会影响

00:09:43.610 --> 00:09:47.240
您认为程序的汇编

00:09:45.590 --> 00:09:49.250
关于是一件很奇怪的事情

00:09:47.240 --> 00:09:52.610
注释是一种更正式的方式

00:09:49.250 --> 00:09:54.650
允许使用的语言的一部分

00:09:52.610 --> 00:09:57.170
您提供有关

00:09:54.650 --> 00:09:59.960
 API，从这个角度来看，好吧

00:09:57.170 --> 00:10:02.120
这是提供的一种方式

00:09:59.960 --> 00:10:06.980
有关说明以下内容的API的元信息

00:10:02.120 --> 00:10:10.010
不推荐使用，因此不推荐使用

00:10:06.980 --> 00:10:13.100
注释，因为注释是

00:10:10.010 --> 00:10:16.010
他们以大写D开头的类

00:10:13.100 --> 00:10:19.880
我们已经使用了小写的Javadoc 

00:10:16.010 --> 00:10:23.230
标签和大写注解，因此

00:10:19.880 --> 00:10:26.660
这些都存在并且注释是

00:10:23.230 --> 00:10:31.130
是声明API的正式方法

00:10:26.660 --> 00:10:33.920
已弃用，但实际上没有

00:10:31.130 --> 00:10:35.060
关于此业务的澄清

00:10:33.920 --> 00:10:36.800
那么这些将会发生什么

00:10:35.060 --> 00:10:38.330
不推荐使用的api是

00:10:36.800 --> 00:10:40.910
删除了我们如何处理这些

00:10:38.330 --> 00:10:42.620
编译器警告和其他东西

00:10:40.910 --> 00:10:44.600
禁止添加警告注释

00:10:42.620 --> 00:10:48.860
好让程序员

00:10:44.600 --> 00:10:50.840
控制编译器警告，所以我想

00:10:48.860 --> 00:10:54.470
快速分享给您

00:10:50.840 --> 00:10:56.900
一些弃用琐事

00:10:54.470 --> 00:10:59.630
至少我觉得有趣

00:10:56.900 --> 00:11:01.490
哪里遇到了麻烦

00:10:59.630 --> 00:11:03.050
有一种方法叫做system get end 

00:11:01.490 --> 00:11:08.860
受到特别折磨

00:11:03.050 --> 00:11:08.860
 JDK中的历史

00:11:09.690 --> 00:11:14.010
实际上除了丢球什么也没做

00:11:11.940 --> 00:11:16.890
并无条件抛出异常

00:11:14.010 --> 00:11:17.820
而且正如Java文档所说的过时一样， 

00:11:16.890 --> 00:11:19.590
有一些有趣的事

00:11:17.820 --> 00:11:24.150
一口气出现并被记录在案

00:11:19.590 --> 00:11:25.710
过时了，我的信念是

00:11:24.150 --> 00:11:27.090
尚未确认，但我的信念是

00:11:25.710 --> 00:11:30.810
当时的人

00:11:27.090 --> 00:11:32.940
在Java上工作的人想要实现它

00:11:30.810 --> 00:11:35.010
不可能写一个程序是

00:11:32.940 --> 00:11:38.070
具体平台和环境

00:11:35.010 --> 00:11:40.020
非常特定于操作系统，但我认为

00:11:38.070 --> 00:11:44.130
多年的实践现实介入并

00:11:40.020 --> 00:11:46.200
通过Java五实际结束

00:11:44.130 --> 00:11:48.510
实施，着眼于

00:11:46.200 --> 00:11:50.880
各自的平台环境

00:11:48.510 --> 00:11:53.550
变量并返回它们被介绍

00:11:50.880 --> 00:11:55.320
而这种方法实际上没有得到满足

00:11:53.550 --> 00:12:00.750
所以现在它是一个完全受支持的部分

00:11:55.320 --> 00:12:03.030
 API的现在不引入Gannon 

00:12:00.750 --> 00:12:04.770
之所以弃用，是因为弃用

00:12:03.030 --> 00:12:06.090
一站式不存在哦

00:12:04.770 --> 00:12:08.100
曾经介绍过的任何东西

00:12:06.090 --> 00:12:11.070
引入时已弃用答案

00:12:08.100 --> 00:12:14.010
是的，因此Java X中有一个mbean服务器

00:12:11.070 --> 00:12:17.370
最初出现在

00:12:14.010 --> 00:12:19.470
 Java SE 5，它最早在

00:12:17.370 --> 00:12:21.330
 Java SE 5就是这样

00:12:19.470 --> 00:12:24.230
奇怪，但是原因是

00:12:21.330 --> 00:12:27.000
 jmx的东西是一个单独的

00:12:24.230 --> 00:12:30.210
 jsr，所以它有一个独立的

00:12:27.000 --> 00:12:32.100
通过它们的演变形成的一组api 

00:12:30.210 --> 00:12:34.980
处理已弃用的东西， 

00:12:32.100 --> 00:12:38.580
然后将它们迁移到Java SE 

00:12:34.980 --> 00:12:40.230
 SE 5的代码，但从

00:12:38.580 --> 00:12:42.060
 Java SE的观点是因为

00:12:40.230 --> 00:12:46.350
在引入和弃用

00:12:42.060 --> 00:12:47.580
同时还好，所以我想去

00:12:46.350 --> 00:12:49.500
回到我所说的

00:12:47.580 --> 00:12:52.589
究竟是什么贬值感到困惑

00:12:49.500 --> 00:12:55.830
的意思，我认为那是存在的

00:12:52.589 --> 00:12:57.870
存在多年，直到

00:12:55.830 --> 00:13:00.030
包括Java 8我仍然会看到

00:12:57.870 --> 00:13:02.460
人们何时会对此发表评论

00:13:00.030 --> 00:13:04.860
互联网论坛等等

00:13:02.460 --> 00:13:06.240
会说嘿，我用这个，我

00:13:04.860 --> 00:13:08.190
得到此折旧警告是什么

00:13:06.240 --> 00:13:09.540
这是否意味着有两种口味

00:13:08.190 --> 00:13:11.820
蚂蚁，我的意思是一堆答案

00:13:09.540 --> 00:13:13.589
当然，但是它们是两种

00:13:11.820 --> 00:13:16.320
答案有人会说所有

00:13:13.589 --> 00:13:17.520
弃用的东西只是忽略它

00:13:16.320 --> 00:13:19.290
他们不会有任何不同

00:13:17.520 --> 00:13:21.000
从不删除任何东西，但其他

00:13:19.290 --> 00:13:22.170
人们会说没有否决手段

00:13:21.000 --> 00:13:22.940
他们将要删除它，所以不要使用

00:13:22.170 --> 00:13:24.410
那

00:13:22.940 --> 00:13:27.110
然后人们会争论

00:13:24.410 --> 00:13:30.170
弃用是什么意思和问题

00:13:27.110 --> 00:13:33.200
是你知道你不能说

00:13:30.170 --> 00:13:35.450
是否这些

00:13:33.200 --> 00:13:37.160
陈述是对还是错，因为我们

00:13:35.450 --> 00:13:39.650
作为平台的维护者

00:13:37.160 --> 00:13:41.150
弄清楚了，这就是我的工作，所以

00:13:39.650 --> 00:13:45.290
这就是我们在Java 9中所做的

00:13:41.150 --> 00:13:46.730
这里特别是11我想要你

00:13:45.290 --> 00:13:48.590
知道最后我们到了重点

00:13:46.730 --> 00:13:50.390
我们正在关注这一点

00:13:48.590 --> 00:13:52.430
的陈述是已经

00:13:50.390 --> 00:13:54.620
哦，太阳和

00:13:52.430 --> 00:13:57.580
 Oracle从未删除过任何内容

00:13:54.620 --> 00:14:00.320
平台，他们永远不会错

00:13:57.580 --> 00:14:09.080
在Java 9中，我们实际上开始

00:14:00.320 --> 00:14:11.960
删除东西，所以好吧好吧

00:14:09.080 --> 00:14:18.470
一阵热烈的掌声

00:14:11.960 --> 00:14:20.300
没想到我会非常感谢你

00:14:18.470 --> 00:14:23.270
这些清除的动机

00:14:20.300 --> 00:14:25.340
被删除依赖

00:14:23.270 --> 00:14:27.230
模块，所以您可能听到很多

00:14:25.340 --> 00:14:30.020
关于模块化和

00:14:27.230 --> 00:14:31.880
项目拼图，你可以谈谈

00:14:30.020 --> 00:14:36.950
模块和相互依存关系

00:14:31.880 --> 00:14:38.810
这些ap被创建了新的依赖项

00:14:36.950 --> 00:14:40.670
在我们不想使用的模块之间

00:14:38.810 --> 00:14:41.810
有，我认为Mark Ryan持有人可能

00:14:40.670 --> 00:14:43.550
实际上在

00:14:41.810 --> 00:14:46.250
所以无论如何主题演讲都是

00:14:43.550 --> 00:14:47.780
在Java 94中为

00:14:46.250 --> 00:14:51.160
这个目的还有其他

00:14:47.780 --> 00:14:55.580
我们也在awt中更正了错误

00:14:51.160 --> 00:14:58.130
 API中有一个对等的概念

00:14:55.580 --> 00:15:01.340
实际上这些API的某些类型

00:14:58.130 --> 00:15:03.980
使用的是不是

00:15:01.340 --> 00:15:05.540
实际上是Java SE的一部分，那么您怎么能

00:15:03.980 --> 00:15:07.280
如果有便携式应用程序，请编写

00:15:05.540 --> 00:15:09.220
实际上没有定义为一部分的类型

00:15:07.280 --> 00:15:11.960
 SE SE的代码，所以实际上

00:15:09.220 --> 00:15:15.020
规范中的长期错误

00:15:11.960 --> 00:15:16.760
因为规格不是

00:15:15.020 --> 00:15:20.300
完全完成是指

00:15:16.760 --> 00:15:22.670
自身之外的东西

00:15:20.300 --> 00:15:24.680
不受控制的方式，所以我们实际上和

00:15:22.670 --> 00:15:26.900
实际上，我们从来都不应该成为同龄人

00:15:24.680 --> 00:15:30.230
无论如何，我们还是要删除公共API 

00:15:26.900 --> 00:15:33.200
 Java 9的人现在可以了

00:15:30.230 --> 00:15:35.680
起床到现在

00:15:33.200 --> 00:15:38.930
我认为做了什么

00:15:35.680 --> 00:15:42.650
这个软件比较少

00:15:38.930 --> 00:15:44.330
工程是弃用的一部分

00:15:42.650 --> 00:15:46.190
不像我写了数千行

00:15:44.330 --> 00:15:48.350
为此的代码我确实写了一些代码

00:15:46.190 --> 00:15:52.190
这个但相对不那么多

00:15:48.350 --> 00:15:53.780
这里的主要工作是澄清

00:15:52.190 --> 00:15:57.770
语义和弃用是什么

00:15:53.780 --> 00:16:01.610
意思是，最重要的是，我认为

00:15:57.770 --> 00:16:04.880
开发人员发现后应该怎么做

00:16:01.610 --> 00:16:08.530
他们使用的API已弃用，并且

00:16:04.880 --> 00:16:11.530
所以那是大部分工作的地方

00:16:08.530 --> 00:16:14.600
有一些增强

00:16:11.530 --> 00:16:16.610
不推荐使用的注释本身

00:16:14.600 --> 00:16:19.070
两个他们有点像参数

00:16:16.610 --> 00:16:21.020
它们被正式称为元素，但是

00:16:19.070 --> 00:16:24.020
有一个since元素，它是一个

00:16:21.020 --> 00:16:28.040
记录的字符串值

00:16:24.020 --> 00:16:30.740
在哪个版本中

00:16:28.040 --> 00:16:34.010
 API已弃用，但更重要

00:16:30.740 --> 00:16:39.370
我认为这是新的布尔元素

00:16:34.010 --> 00:16:41.750
删除，这是说，如果

00:16:39.370 --> 00:16:43.520
实际在下一张幻灯片中介绍

00:16:41.750 --> 00:16:45.470
好，所以有一些增强

00:16:43.520 --> 00:16:47.690
到不赞成使用的注释

00:16:45.470 --> 00:16:50.000
那些更多的细节，我们也

00:16:47.690 --> 00:16:53.120
引入新的静态分析工具

00:16:50.000 --> 00:16:55.400
叫JD钱包，我可以涵盖什么

00:16:53.120 --> 00:16:56.930
稍后再做

00:16:55.400 --> 00:16:58.940
是对Java的一些调整

00:16:56.930 --> 00:17:01.760
语言规范Java C和Java 

00:16:58.940 --> 00:17:06.070
 doc为了以完善自己

00:17:01.760 --> 00:17:06.070
不推荐使用的注释的处理

00:17:08.260 --> 00:17:13.550
好吧，这就是这里的

00:17:10.280 --> 00:17:15.650
有关新折旧的详细信息

00:17:13.550 --> 00:17:18.380
元素，所以我想删除

00:17:15.650 --> 00:17:19.760
真的是最主要的

00:17:18.380 --> 00:17:21.170
我的意思是，这就是布尔值

00:17:19.760 --> 00:17:23.540
但令人惊讶的是

00:17:21.170 --> 00:17:26.540
讨论在后台进行

00:17:23.540 --> 00:17:27.710
而所有添加的是布尔值， 

00:17:26.540 --> 00:17:29.870
这很重要，因为

00:17:27.710 --> 00:17:31.510
讨论改善了每个人的

00:17:29.870 --> 00:17:35.000
了解什么是弃用

00:17:31.510 --> 00:17:37.100
但基本上那个

00:17:35.000 --> 00:17:39.140
假想的艺术而不是假想的

00:17:37.100 --> 00:17:40.640
但是我的原型论证

00:17:39.140 --> 00:17:42.410
在谈论他们永远不会

00:17:40.640 --> 00:17:44.330
删除任何不赞成使用的东西

00:17:42.410 --> 00:17:47.390
意思是我应该担心

00:17:44.330 --> 00:17:48.410
删除它，否则我应该担心

00:17:47.390 --> 00:17:50.360
我正在使用

00:17:48.410 --> 00:17:53.540
不推荐使用的API是否将其删除

00:17:50.360 --> 00:17:57.920
这就是这个意思，所以如果要移除

00:17:53.540 --> 00:18:01.490
是真的，那就意味着无论是谁

00:17:57.920 --> 00:18:03.440
维持这个API就是说这个

00:18:01.490 --> 00:18:05.420
将被删除，它没有说

00:18:03.440 --> 00:18:07.610
当它要被删除，但在

00:18:05.420 --> 00:18:10.810
 JDK我们要说的是

00:18:07.610 --> 00:18:15.470
不建议将某些东西移除

00:18:10.810 --> 00:18:18.410
此版本，然后它将被删除

00:18:15.470 --> 00:18:19.910
从下一个版本开始就是这样

00:18:18.410 --> 00:18:21.950
我们试图说，所以我们给一个

00:18:19.910 --> 00:18:32.840
在移除之前发布警告

00:18:21.950 --> 00:18:35.770
抱歉，对不起，是的

00:18:32.840 --> 00:18:38.840
是的，主要发行版本是这样，谢谢

00:18:35.770 --> 00:18:41.300
是的，所以如果某些东西不推荐使用

00:18:38.840 --> 00:18:43.700
在此版本中删除它将是

00:18:41.300 --> 00:18:46.430
在下一个主要版本中删除，或

00:18:43.700 --> 00:18:48.800
至少在JDK中

00:18:46.430 --> 00:18:51.830
版本是我们唯一的版本

00:18:48.800 --> 00:18:54.140
实际上可以进行规格更改

00:18:51.830 --> 00:18:56.060
所以添加弃用是一个

00:18:54.140 --> 00:18:57.980
规格变更，当然

00:18:56.060 --> 00:19:02.900
删除API也是一个规范

00:18:57.980 --> 00:19:04.910
更改确定，以便删除错误以及什么

00:19:02.900 --> 00:19:06.110
你知道为什么有些东西不赞成

00:19:04.910 --> 00:19:09.260
你不会在那里很好地删除它

00:19:06.110 --> 00:19:11.960
很多东西不是

00:19:09.260 --> 00:19:15.230
有必要删除它们，但仍然在那里

00:19:11.960 --> 00:19:18.920
人们知道它仍然有用吗

00:19:15.230 --> 00:19:20.480
该API有问题

00:19:18.920 --> 00:19:22.430
有了它，或者有东西

00:19:20.480 --> 00:19:24.440
其他要用的，所以实际上有

00:19:22.430 --> 00:19:27.350
他弃用了更多

00:19:24.440 --> 00:19:30.290
去除假然后有四个

00:19:27.350 --> 00:19:32.360
去除真，所以有一些旧

00:19:30.290 --> 00:19:34.160
 AP是您最好使用

00:19:32.360 --> 00:19:36.200
其他的东西，但我们留给他们

00:19:34.160 --> 00:19:39.380
该平台只是因为我们不想

00:19:36.200 --> 00:19:40.820
破坏人们的密码，所以

00:19:39.380 --> 00:19:43.310
有点笨拙听到

00:19:40.820 --> 00:19:45.410
措辞，所以我们煮了一些

00:19:43.310 --> 00:19:48.740
这里有些术语，如果有的话

00:19:45.410 --> 00:19:51.470
不建议使用，以将false删除

00:19:48.740 --> 00:19:53.150
普通的折旧，但如果

00:19:51.470 --> 00:19:55.250
删除是真的，我们称之为

00:19:53.150 --> 00:19:57.440
最终弃用，因为这意味着

00:19:55.250 --> 00:19:59.810
你知道某事正在发生

00:19:57.440 --> 00:20:02.230
结束，这使得它更容易

00:19:59.810 --> 00:20:07.309
说说它

00:20:02.230 --> 00:20:09.649
所以基本上，如果某些东西被弃用

00:20:07.309 --> 00:20:11.690
如果它有一个

00:20:09.649 --> 00:20:14.510
普通的贬值意味着

00:20:11.690 --> 00:20:16.820
目前没有删除它的意图

00:20:14.510 --> 00:20:19.940
意味着它将永远存在，但是如果

00:20:16.820 --> 00:20:23.179
我们确实决定将其删除

00:20:19.940 --> 00:20:27.649
未来，那么将被删除

00:20:23.179 --> 00:20:31.580
从错误升级，这是真的，继续

00:20:27.649 --> 00:20:34.100
问题ah是，默认值为

00:20:31.580 --> 00:20:37.309
错误，因此所有先前存在的折旧

00:20:34.100 --> 00:20:39.320
默认情况下会删除false 

00:20:37.309 --> 00:20:41.450
普通的弃用，所以我们已经做了

00:20:39.320 --> 00:20:43.760
是我们带走了我所做的就是我去了

00:20:41.450 --> 00:20:45.260
通过所有旧的过时不

00:20:43.760 --> 00:20:47.240
我经历过的所有旧事

00:20:45.260 --> 00:20:48.830
旧的已弃用的api并重新检查

00:20:47.240 --> 00:20:50.539
他们说，好的，这些是我们

00:20:48.830 --> 00:20:54.440
真的要删除，然后我

00:20:50.539 --> 00:20:56.450
剩下的旧的不推荐使用的API是

00:20:54.440 --> 00:20:59.960
无意删除我离开那些作为

00:20:56.450 --> 00:21:02.450
假好吧，然后我也提到了

00:20:59.960 --> 00:21:04.159
因为有一个字符串值是

00:21:02.450 --> 00:21:07.010
释放其中变成了某种东西

00:21:04.159 --> 00:21:09.909
不赞成使用，我想我要接受

00:21:07.010 --> 00:21:13.399
最后提问，谢谢

00:21:09.909 --> 00:21:15.830
大部分这是信息性的，没有

00:21:13.399 --> 00:21:18.049
据我所知，没有语义

00:21:15.830 --> 00:21:19.460
附着在什么弦上

00:21:18.049 --> 00:21:23.480
但是看什么时候很有用

00:21:19.460 --> 00:21:25.370
现在已弃用

00:21:23.480 --> 00:21:28.639
你们中有些人可能以前见过

00:21:25.370 --> 00:21:32.000
关于弃用的建议

00:21:28.639 --> 00:21:34.639
有一个原因标签， 

00:21:32.000 --> 00:21:35.990
新价值，特别是

00:21:34.639 --> 00:21:37.970
引起最多关注的是

00:21:35.990 --> 00:21:39.799
谴责还有其他价值

00:21:37.970 --> 00:21:42.049
取代过时的危险等等

00:21:39.799 --> 00:21:45.260
来了，所以这是一个较早的版本

00:21:42.049 --> 00:21:47.090
提案的结果，结果

00:21:45.260 --> 00:21:49.580
有一个原因码很好

00:21:47.090 --> 00:21:54.799
我认为这引起了很多讨论

00:21:49.580 --> 00:21:58.100
语义很好，但是它们

00:21:54.799 --> 00:21:59.899
定义不是很好，所以它

00:21:58.100 --> 00:22:04.580
没有意义的是

00:21:59.899 --> 00:22:06.320
 API中的特定原因说明原因

00:22:04.580 --> 00:22:08.840
这已被弃用或将会发生什么

00:22:06.320 --> 00:22:11.480
为此，实际上问题是我们知道

00:22:08.840 --> 00:22:13.190
我们想弃用我们

00:22:11.480 --> 00:22:14.640
实际上花了一些时间尝试

00:22:13.190 --> 00:22:17.880
分配原因码

00:22:14.640 --> 00:22:18.990
基本上是不可能的，所以也许

00:22:17.880 --> 00:22:21.240
告诉我们出了点问题

00:22:18.990 --> 00:22:23.220
与API，因此真正受到谴责的是

00:22:21.240 --> 00:22:24.810
只有一个是严格可行的

00:22:23.220 --> 00:22:26.820
具有明确的语义，所以我们只是

00:22:24.810 --> 00:22:29.610
转换成如此谴责的

00:22:26.820 --> 00:22:33.030
转换为for移除布尔值

00:22:29.610 --> 00:22:35.220
然后剩下的那些概念是

00:22:33.030 --> 00:22:37.800
有效概念，它们根本不在

00:22:35.220 --> 00:22:40.560
 API，如果您有的话，我们说的很好

00:22:37.800 --> 00:22:42.540
然后是危险的东西

00:22:40.560 --> 00:22:43.710
将其标记为危险并具有

00:22:42.540 --> 00:22:46.770
人们说的好是什么意思

00:22:43.710 --> 00:22:49.050
属于文档，如果

00:22:46.770 --> 00:22:51.720
有危险或危险的东西

00:22:49.050 --> 00:22:53.340
 API设计师您或我们，我是说我们

00:22:51.720 --> 00:22:56.360
设计很多的api，但是任何人

00:22:53.340 --> 00:22:58.680
谁使用了已弃用的注释，并且

00:22:56.360 --> 00:23:00.870
你知道那里可能有风险

00:22:58.680 --> 00:23:02.100
与此API相关联，因为它

00:23:00.870 --> 00:23:04.290
在某些情况下可能会给出错误的答案

00:23:02.100 --> 00:23:05.850
案件或类似的东西

00:23:04.290 --> 00:23:07.830
那不应该是真的吗

00:23:05.850 --> 00:23:10.340
文档的一部分，而不是

00:23:07.830 --> 00:23:12.960
注释中包含的内容

00:23:10.340 --> 00:23:15.210
好吧，如果我们有什么

00:23:12.960 --> 00:23:18.290
到目前为止，用Java九完成了这些

00:23:15.210 --> 00:23:23.340
普通的过时去除假

00:23:18.290 --> 00:23:25.920
盒装的基本构造函数new 

00:23:23.340 --> 00:23:27.990
整数new boolean new short new new 

00:23:25.920 --> 00:23:30.870
双重新的莎拉所有这些

00:23:27.990 --> 00:23:32.220
在大多数情况下已被弃用

00:23:30.870 --> 00:23:36.770
可以简单地用

00:23:32.220 --> 00:23:38.880
方法的对应值

00:23:36.770 --> 00:23:41.160
特别是对于布尔值

00:23:38.880 --> 00:23:42.780
只有两个布尔值框

00:23:41.160 --> 00:23:46.770
布尔值，因此永远不会

00:23:42.780 --> 00:23:48.600
创建一个新实例的理由

00:23:46.770 --> 00:23:51.990
布尔值，但人们这样做

00:23:48.600 --> 00:23:53.700
为了锁定它或

00:23:51.990 --> 00:23:57.510
这样的事情真的很糟糕

00:23:53.700 --> 00:24:00.290
我们在JDK中确实有一个案例

00:23:57.510 --> 00:24:04.830
使用布尔字段作为三态的

00:24:00.290 --> 00:24:07.740
没有对与错，所以我认为我们摆脱了

00:24:04.830 --> 00:24:10.620
其中也有一个很长的故事

00:24:07.740 --> 00:24:12.390
 Java applet（如果您一直关注） 

00:24:10.620 --> 00:24:13.710
浏览器插件中的小程序

00:24:12.390 --> 00:24:15.660
已经走了很长时间

00:24:13.710 --> 00:24:18.750
很长一段时间，但事实证明这是

00:24:15.660 --> 00:24:20.220
进化非常缓慢，如此之多

00:24:18.750 --> 00:24:24.120
我认为人们并不感到惊讶

00:24:20.220 --> 00:24:27.390
小应用程序已被弃用，但

00:24:24.120 --> 00:24:28.320
他们惊讶的是小程序

00:24:27.390 --> 00:24:31.500
是

00:24:28.320 --> 00:24:33.720
标记为删除，我有一个

00:24:31.500 --> 00:24:36.750
与桌面团队讨论

00:24:33.720 --> 00:24:38.130
关于这就像你所知道的

00:24:36.750 --> 00:24:39.509
你应该弃用什么

00:24:38.130 --> 00:24:41.009
打算搬家，他们也知道

00:24:39.509 --> 00:24:42.840
我们将摆脱它，好吧

00:24:41.009 --> 00:24:46.110
我说好的，你要摆脱

00:24:42.840 --> 00:24:47.460
在下一个版本中，嗯，也许

00:24:46.110 --> 00:24:48.809
其实还有其他人哦，我们

00:24:47.460 --> 00:24:50.580
有这个还在使用的客户

00:24:48.809 --> 00:24:51.990
他们他们要起床，所以有一个

00:24:50.580 --> 00:24:53.909
一堆关于它的折边

00:24:51.990 --> 00:24:55.649
对，所以你知道一分钟，然后

00:24:53.909 --> 00:24:57.240
他们开始让你感到不舒服耶

00:24:55.649 --> 00:24:59.220
我认为我们无法将其移除

00:24:57.240 --> 00:25:02.419
下一个版本，这就是

00:24:59.220 --> 00:25:05.279
事情如此继续，所以事实是

00:25:02.419 --> 00:25:07.379
小程序正在出路，但它们

00:25:05.279 --> 00:25:09.870
还在附近，因为他们仍然习惯

00:25:07.379 --> 00:25:13.679
所以小程序被弃用了，但是

00:25:09.870 --> 00:25:17.399
去除假有一个

00:25:13.679 --> 00:25:19.559
一个非常古老的事件观察的痕迹

00:25:17.399 --> 00:25:21.659
 Java util观察器中的模型和

00:25:19.559 --> 00:25:26.299
可观察的，我不知道是否有人使用

00:25:21.659 --> 00:25:28.830
这些原来是我忘记了

00:25:26.299 --> 00:25:31.700
没关系，我确实听说过一些

00:25:28.830 --> 00:25:34.799
一些这些用途，因为他

00:25:31.700 --> 00:25:37.409
创建了一堆编译器警告

00:25:34.799 --> 00:25:40.529
当它被弃用，但实际上

00:25:37.409 --> 00:25:42.149
这些这些都好多了

00:25:40.529 --> 00:25:45.240
使用观察者的替代方法和

00:25:42.149 --> 00:25:46.830
事实上，当我提到

00:25:45.240 --> 00:25:48.860
这个你认识的人

00:25:46.830 --> 00:25:53.490
大多数人从未听说过这些

00:25:48.860 --> 00:25:56.190
好吧，我们正在贬低什么东西

00:25:53.490 --> 00:25:58.950
为了去除所以现在这些东西

00:25:56.190 --> 00:26:00.720
在Java九中，它们仍将是

00:25:58.950 --> 00:26:03.480
那里将要被注释

00:26:00.720 --> 00:26:07.950
不推荐使用的at等于

00:26:03.480 --> 00:26:10.830
 true，表示该计划在Java 10中

00:26:07.950 --> 00:26:14.070
这些将消失，所以线程

00:26:10.830 --> 00:26:16.919
消灭那就是那消逝

00:26:14.070 --> 00:26:18.899
现在有两个重载

00:26:16.919 --> 00:26:23.340
线程点停止其中之一需要一个

00:26:18.899 --> 00:26:25.049
引发该问题的可抛出参数

00:26:23.340 --> 00:26:27.870
导致线程在其中停止

00:26:25.049 --> 00:26:30.139
轨道和一掷一掷

00:26:27.870 --> 00:26:32.940
投掷者的选择和

00:26:30.139 --> 00:26:36.450
事实上，实际上是在

00:26:32.940 --> 00:26:37.649
 Java 8，使其不再起作用，并且

00:26:36.450 --> 00:26:39.000
所以我们实际上没有听到

00:26:37.649 --> 00:26:40.919
据我所知

00:26:39.000 --> 00:26:41.789
所以我们现在要摆脱它

00:26:40.919 --> 00:26:45.570
的

00:26:41.789 --> 00:26:48.600
线程点停止过载，没有

00:26:45.570 --> 00:26:50.399
争论仍然不赞成，但我们

00:26:48.600 --> 00:26:53.609
不会删除它，以便保持

00:26:50.399 --> 00:26:55.739
那里有一个有趣的故事

00:26:53.609 --> 00:26:58.679
有了这个这另一种方法

00:26:55.739 --> 00:27:01.229
系统点运行在退出时终结错误，然后

00:26:58.679 --> 00:27:03.720
所以你认识的人我不知道

00:27:01.229 --> 00:27:05.489
如果您熟悉定稿，则为您

00:27:03.720 --> 00:27:07.350
而所有的事情就是

00:27:05.489 --> 00:27:10.049
那是过去的设施

00:27:07.350 --> 00:27:12.859
平台多年有人

00:27:10.049 --> 00:27:15.450
认为这是一个好主意，所以

00:27:12.859 --> 00:27:17.009
有一个标志，说当系统

00:27:15.450 --> 00:27:18.330
顺利退出，我们想做一些

00:27:17.009 --> 00:27:20.519
清理，所以运行所有终结器

00:27:18.330 --> 00:27:22.859
不幸的是，这意味着

00:27:20.519 --> 00:27:26.609
最终确定错误将实时运行

00:27:22.859 --> 00:27:28.590
对象，如果有生命的对象有一些

00:27:26.609 --> 00:27:30.929
然后与之关联的本地资源

00:27:28.590 --> 00:27:32.809
没错，finalizar会说哦

00:27:30.929 --> 00:27:34.590
好吧，我可以释放这些本机资源

00:27:32.809 --> 00:27:38.149
不幸的是，无法控制

00:27:34.590 --> 00:27:40.440
终结器调用的顺序等

00:27:38.149 --> 00:27:42.869
其他一些终结器

00:27:40.440 --> 00:27:44.700
可能会说回

00:27:42.869 --> 00:27:46.529
具有本地资源的头等舱

00:27:44.700 --> 00:27:48.059
已经被释放了，所以它

00:27:46.529 --> 00:27:49.710
拨打本地电话后发现

00:27:48.059 --> 00:27:53.330
已被释放并导致虚拟机

00:27:49.710 --> 00:27:58.049
崩溃，所以我认为什么时候是

00:27:53.330 --> 00:28:00.359
 1999年人们发现了这个，所以在那里

00:27:58.049 --> 00:28:02.159
是一致性失败，因为

00:28:00.359 --> 00:28:04.019
系统崩溃时我们称之为

00:28:02.159 --> 00:28:07.049
我们有一个会崩溃的测试程序

00:28:04.019 --> 00:28:09.539
 JVM每次如何修复

00:28:07.049 --> 00:28:12.090
修复它的唯一方法是

00:28:09.539 --> 00:28:15.029
好好摆脱它终于要

00:28:12.090 --> 00:28:16.799
通过删除API并修复此错误

00:28:15.029 --> 00:28:19.710
实际上，run最终错误的语义

00:28:16.799 --> 00:28:22.979
退出时根本不正确，因为

00:28:19.710 --> 00:28:25.919
终结器只能在

00:28:22.979 --> 00:28:27.119
无法访问的对象，但这说

00:28:25.919 --> 00:28:30.239
哦，顺便说一句，我们要运行

00:28:27.119 --> 00:28:32.429
 finalizer zon活动对象，所以无论如何

00:28:30.239 --> 00:28:35.279
那就是要走了，然后终于

00:28:32.429 --> 00:28:37.859
有很多方法

00:28:35.279 --> 00:28:40.529
安全经理将

00:28:37.859 --> 00:28:44.399
删除了那些是前

00:28:40.529 --> 00:28:47.279
 1.2安全性模型等等在jdk 1.2中

00:28:44.399 --> 00:28:48.960
基于权限的安全模型

00:28:47.279 --> 00:28:51.090
但是所有这些旧支票

00:28:48.960 --> 00:28:52.769
权限问题留给安全性

00:28:51.090 --> 00:28:54.980
经理，我们终于摆脱了

00:28:52.769 --> 00:28:54.980
那些

00:28:58.430 --> 00:29:05.060
好吧，我想花点时间

00:29:00.390 --> 00:29:07.530
关于通知和警告，因为我们

00:29:05.060 --> 00:29:10.400
实际上有相当数量

00:29:07.530 --> 00:29:13.460
这里出现的细微问题

00:29:10.400 --> 00:29:15.900
但正如我在一开始所说的

00:29:13.460 --> 00:29:19.170
弃用的目的是传达

00:29:15.900 --> 00:29:21.960
是为了提供

00:29:19.170 --> 00:29:24.390
维护者zuv API和使用者

00:29:21.960 --> 00:29:27.630
 API的版本以及是否在

00:29:24.390 --> 00:29:30.360
然后用户的状态

00:29:27.630 --> 00:29:35.190
 API开发人员需要

00:29:30.360 --> 00:29:36.660
知道这一点，所以你知道他们是否

00:29:35.190 --> 00:29:39.450
 API出现问题或运行不正常

00:29:36.660 --> 00:29:41.370
走开，但这就是

00:29:39.450 --> 00:29:43.800
这里的一般要点是如何交流

00:29:41.370 --> 00:29:45.420
这些信息是通过API实现的

00:29:43.800 --> 00:29:46.890
问题是我们说很好

00:29:45.420 --> 00:29:48.690
在规范中写一些话

00:29:46.890 --> 00:29:49.740
说哦，这有问题

00:29:48.690 --> 00:29:53.520
因此，我们要接受它

00:29:49.740 --> 00:29:54.840
很好，我不应该说没人读

00:29:53.520 --> 00:29:56.640
文档，但是有很多

00:29:54.840 --> 00:29:58.470
那些不读

00:29:56.640 --> 00:29:59.970
文档，但事实是

00:29:58.470 --> 00:30:02.130
像这样的音符被埋在

00:29:59.970 --> 00:30:03.360
你知道的文件我知道那是什么

00:30:02.130 --> 00:30:05.430
方法可以，我不需要

00:30:03.360 --> 00:30:07.710
我去年不读文档

00:30:05.430 --> 00:30:09.300
我不知道我不会去的

00:30:07.710 --> 00:30:11.310
期望开发人员去不合理

00:30:09.300 --> 00:30:13.110
用细齿梳子说哦

00:30:11.310 --> 00:30:14.970
此条款在此处添加，内容为

00:30:13.110 --> 00:30:16.470
这个你知道这个方法是

00:30:14.970 --> 00:30:18.990
将被弃用，所以我们需要一些

00:30:16.470 --> 00:30:20.850
一些更强大更可靠的形式

00:30:18.990 --> 00:30:23.430
将此信息传达给

00:30:20.850 --> 00:30:26.490
开发人员，所以有几种不同的

00:30:23.430 --> 00:30:28.590
这样的方式，所以第一个是

00:30:26.490 --> 00:30:30.450
编译时间通知，这是

00:30:28.590 --> 00:30:32.760
我们应该熟悉的一种

00:30:30.450 --> 00:30:35.700
如果您编写程序已经

00:30:32.760 --> 00:30:37.230
使用不推荐使用的API，然后

00:30:35.700 --> 00:30:39.120
编译器将发出警告

00:30:37.230 --> 00:30:40.530
有各种各样的东西

00:30:39.120 --> 00:30:42.000
皱纹的严重程度

00:30:40.530 --> 00:30:43.710
早上是开还是关

00:30:42.000 --> 00:30:45.810
默认以及如何抑制

00:30:43.710 --> 00:30:47.640
警告你，你知道你

00:30:45.810 --> 00:30:50.820
知道但您不想

00:30:47.640 --> 00:30:53.790
现在处理，但随后有

00:30:50.820 --> 00:30:56.640
还有两种新的通知

00:30:53.790 --> 00:30:59.100
我们正在进行静态分析

00:30:56.640 --> 00:31:01.440
有用，因为事实是您得到了

00:30:59.100 --> 00:31:03.450
仅当您使用编译器警告时

00:31:01.440 --> 00:31:06.169
重新编译一切，实际上我们

00:31:03.450 --> 00:31:08.419
不要期望人们重新编译

00:31:06.169 --> 00:31:10.369
重点是重点之一

00:31:08.419 --> 00:31:11.960
 Java的要点是二进制兼容性

00:31:10.369 --> 00:31:14.090
您可以使用旧的二进制文件

00:31:11.960 --> 00:31:15.950
继续运行它们，所以这是

00:31:14.090 --> 00:31:19.100
通知中的最大漏洞

00:31:15.950 --> 00:31:21.019
弃用，因为到目前为止

00:31:19.100 --> 00:31:23.749
通知的类型是编译时间

00:31:21.019 --> 00:31:28.879
警告，如果您有旧的二进制文件

00:31:23.749 --> 00:31:32.029
使用从未使用过的API 

00:31:28.879 --> 00:31:33.649
听说，除非你除非

00:31:32.029 --> 00:31:35.389
有一些替代途径，所以

00:31:33.649 --> 00:31:37.190
我们正在介绍一个静态分析工具

00:31:35.389 --> 00:31:40.309
我将提供有关的更多详细信息

00:31:37.190 --> 00:31:42.169
以后再帮忙

00:31:40.309 --> 00:31:45.830
这个想法还没有实现

00:31:42.169 --> 00:31:48.440
时间是跟踪已弃用的用法

00:31:45.830 --> 00:31:50.480
 api在运行时，然后提供

00:31:48.440 --> 00:31:52.730
其中之一是运行时警告

00:31:50.480 --> 00:31:55.009
实际打电话给你，例如

00:31:52.730 --> 00:31:57.080
可能具有引用一个

00:31:55.009 --> 00:32:00.499
不推荐使用的API，但实际上可能是

00:31:57.080 --> 00:32:03.259
死代码，所以如果它从不叫它，谁

00:32:00.499 --> 00:32:06.139
在乎，但另一方面，您可能

00:32:03.259 --> 00:32:08.330
有一些叫的东西

00:32:06.139 --> 00:32:10.970
 api反光的，那将被错过

00:32:08.330 --> 00:32:12.619
通过静态分析，但这可能是

00:32:10.970 --> 00:32:14.989
有可能被动态拾取

00:32:12.619 --> 00:32:18.070
分析，因此具有动态分析功能

00:32:14.989 --> 00:32:20.509
 Java 9不会做的工作

00:32:18.070 --> 00:32:23.289
好的编译器快速示例

00:32:20.509 --> 00:32:25.879
如果使用不推荐使用的API，则会发出警告

00:32:23.289 --> 00:32:27.739
如果不这样做，你会得到的第一件事

00:32:25.879 --> 00:32:31.489
提供除

00:32:27.739 --> 00:32:33.289
默认是一条便条，上面写着您可以阅读

00:32:31.489 --> 00:32:35.509
它在那里重新编译-非常好

00:32:33.289 --> 00:32:37.609
弃用以获得更多详细信息，等等

00:32:35.509 --> 00:32:39.499
如果您确实重新编译-非常好

00:32:37.609 --> 00:32:42.259
弃用可实现详细信息

00:32:39.499 --> 00:32:44.210
警告，您会得到确切的清单

00:32:42.259 --> 00:32:49.399
确切的位置

00:32:44.210 --> 00:32:51.080
我使用了不赞成使用的API 

00:32:49.399 --> 00:32:52.429
认为我已经解释了这个，但是

00:32:51.080 --> 00:32:54.710
问题是，如果你有一个老

00:32:52.429 --> 00:32:56.629
二进制文件，您只用它，不用

00:32:54.710 --> 00:32:59.710
重新编译它，以便这个旧的二进制文件可能

00:32:56.629 --> 00:33:02.749
在其中使用了已弃用的api，并且

00:32:59.710 --> 00:33:05.389
您可能想知道这一点

00:33:02.749 --> 00:33:07.999
如果那些不赞成使用的api将

00:33:05.389 --> 00:33:10.399
被删除，所以如果您继续使用

00:33:07.999 --> 00:33:12.710
那旧的二进制文件，然后您继续

00:33:10.399 --> 00:33:14.389
下一个JDK版本可能会

00:33:12.710 --> 00:33:16.039
已弃用

00:33:14.389 --> 00:33:17.840
去除然后再最后

00:33:16.039 --> 00:33:19.770
如果您使用的是旧版本，则将其删除

00:33:17.840 --> 00:33:22.590
二进制文件只会破坏，您可能

00:33:19.770 --> 00:33:23.880
为什么这样的方法没有错误呢？ 

00:33:22.590 --> 00:33:26.190
发生了，然后您可能需要做

00:33:23.880 --> 00:33:27.900
一些，您可能需要做一些

00:33:26.190 --> 00:33:29.430
研究或调查以及东西和

00:33:27.900 --> 00:33:31.440
所以我认为那是一个讨厌的

00:33:29.430 --> 00:33:33.630
惊喜，我们想要，我们想要得到

00:33:31.440 --> 00:33:35.610
有关此信息的信息提供给开发人员

00:33:33.630 --> 00:33:37.530
在此之前，而不是

00:33:35.610 --> 00:33:40.500
让人们尝试一下，然后

00:33:37.530 --> 00:33:45.360
揭露诸如此类的问题

00:33:40.500 --> 00:33:47.550
特别是发生错误

00:33:45.360 --> 00:33:49.380
生态系统的发展方式是

00:33:47.550 --> 00:33:51.690
如果我有申请，我可能会去

00:33:49.380 --> 00:33:54.240
可能会使用Maven并拉低

00:33:51.690 --> 00:33:56.550
一堆依赖库，所以不仅

00:33:54.240 --> 00:33:59.400
就像我是应用程序开发人员一样

00:33:56.550 --> 00:34:01.680
我要担心我的

00:33:59.400 --> 00:34:03.090
应用程序正在使用，但

00:34:01.680 --> 00:34:05.130
依赖库，它们是

00:34:03.090 --> 00:34:07.650
依赖库也是如此，如果

00:34:05.130 --> 00:34:09.000
那些使用过时的AP的人就是

00:34:07.650 --> 00:34:11.940
想知道这一点，因为

00:34:09.000 --> 00:34:14.100
要么我可以让那些家伙修复

00:34:11.940 --> 00:34:16.200
修复上游或我可以删除我的

00:34:14.100 --> 00:34:17.790
对这些库的依赖

00:34:16.200 --> 00:34:19.860
这是为了让开发人员可以

00:34:17.790 --> 00:34:21.659
更好地管理他们的情况

00:34:19.860 --> 00:34:26.520
依赖库，而不必

00:34:21.659 --> 00:34:28.020
实际重新编译，这是到目前为止

00:34:26.520 --> 00:34:31.290
我刚刚经历了太多细节

00:34:28.020 --> 00:34:33.720
在这里素描，但我想

00:34:31.290 --> 00:34:36.649
有一些老阶级，以便

00:34:33.720 --> 00:34:40.320
这里的中心问题是发生了什么

00:34:36.649 --> 00:34:43.230
程序随着API的发展而发展

00:34:40.320 --> 00:34:46.320
您的api不断发展，所以假设我有一个

00:34:43.230 --> 00:34:48.750
应用程序，我将其编译为一个

00:34:46.320 --> 00:34:50.399
 JDK版本，它使用了一些

00:34:48.750 --> 00:34:52.530
 api和那里一切正常

00:34:50.399 --> 00:34:56.210
在下一个Java中现在没有警告

00:34:52.530 --> 00:34:59.250
发布我使用的东西被弃用

00:34:56.210 --> 00:35:01.260
但是如果我不重新编译，我永远找不到

00:34:59.250 --> 00:35:04.470
关于这一点，然后在下面

00:35:01.260 --> 00:35:07.050
 JDK发布将其更改为终端

00:35:04.470 --> 00:35:09.120
弃用不建议移除

00:35:07.050 --> 00:35:12.600
如果我还在运行旧的

00:35:09.120 --> 00:35:16.800
我从未听说过二进制文件，所以

00:35:12.600 --> 00:35:18.990
当我升级到

00:35:16.800 --> 00:35:20.640
在那之后的后续JDK版本

00:35:18.990 --> 00:35:22.680
实际上被删除，我运行我的

00:35:20.640 --> 00:35:24.720
应用程序，它说没有类定义

00:35:22.680 --> 00:35:26.340
发现错误或没有此类方法错误或

00:35:24.720 --> 00:35:28.230
像这样的东西，这真的是

00:35:26.340 --> 00:35:31.230
我们正在尝试令人不愉快的惊喜

00:35:28.230 --> 00:35:33.510
避免在这里好吧，所以我谈到

00:35:31.230 --> 00:35:35.970
静态分析，有一个叫做j的工具

00:35:33.510 --> 00:35:40.500
我开发的胡椒扫描是

00:35:35.970 --> 00:35:42.900
在jdk 9中引入，它也是

00:35:40.500 --> 00:35:44.520
可在任何我有一个链接在

00:35:42.900 --> 00:35:48.230
链接到早期的结尾

00:35:44.520 --> 00:35:48.230
访问构建，以便您可以尝试

00:35:49.100 --> 00:35:54.090
好了，这是一个示例程序

00:35:52.050 --> 00:35:56.700
它没有任何有趣的事情

00:35:54.090 --> 00:35:59.850
它确实是使用ap是

00:35:56.700 --> 00:36:04.970
在各种jdk版本中已弃用，并且

00:35:59.850 --> 00:36:07.560
所以这个列表jlist获得选定的值

00:36:04.970 --> 00:36:11.610
还可以，所以这些都不是

00:36:07.560 --> 00:36:14.460
不推荐使用所有存在于这些API中的API 

00:36:11.610 --> 00:36:16.910
 Java 6和更早版本，并且都不是

00:36:14.460 --> 00:36:19.680
在Java 7中的Java 6中已弃用

00:36:16.910 --> 00:36:24.660
 jlist获取选择的值已弃用

00:36:19.680 --> 00:36:27.330
在Java 8中，rmi安全管理器是

00:36:24.660 --> 00:36:29.940
不推荐使用，并且在我提到的Java 9中

00:36:27.330 --> 00:36:32.520
较早的布尔构造函数是

00:36:29.940 --> 00:36:33.810
过时了，有趣的是什么

00:36:32.520 --> 00:36:35.400
关于这个例子的重点是

00:36:33.810 --> 00:36:37.160
不同的API是不同的

00:36:35.400 --> 00:36:40.260
弃用了不同的时间点

00:36:37.160 --> 00:36:43.980
 JDK在什么时间测量

00:36:40.260 --> 00:36:46.770
发布，所以如果我拿这个样本

00:36:43.980 --> 00:36:48.510
程序并使用jdk 6 i对其进行编译

00:36:46.770 --> 00:36:50.970
将得到一个具有

00:36:48.510 --> 00:36:53.040
引用这些方法，但是

00:36:50.970 --> 00:36:55.590
当然，我在jdk六上编译了它， 

00:36:53.040 --> 00:36:57.480
可以很好地编译所有这些api的存在，并且

00:36:55.590 --> 00:36:59.850
没有警告，因为没有

00:36:57.480 --> 00:37:02.450
他们在JDK 6中已弃用，所以

00:36:59.850 --> 00:37:07.020
我们能找到答案吗？ 

00:37:02.450 --> 00:37:10.260
每次扫描来自最近的jdk 9的jada 

00:37:07.020 --> 00:37:12.180
建立然后告诉我哦上课的例子

00:37:10.260 --> 00:37:14.070
弃用在我的类型上使用java 

00:37:12.180 --> 00:37:16.080
已弃用的安全管理器， 

00:37:14.070 --> 00:37:18.870
所以它遍历了类文件

00:37:16.080 --> 00:37:22.170
一些分析，找出什么

00:37:18.870 --> 00:37:23.990
被弃用的是

00:37:22.170 --> 00:37:28.460
从此类文件引用，并且

00:37:23.990 --> 00:37:31.950
从那里发出消息

00:37:28.460 --> 00:37:34.740
每次扫描JD的功能是它可以

00:37:31.950 --> 00:37:39.120
分析相对于

00:37:34.740 --> 00:37:41.010
特定的JDK版本，因此我可以添加

00:37:39.120 --> 00:37:43.350
减号减号释放选项，所以我减号

00:37:41.010 --> 00:37:45.330
减去版本9，这是默认值，因为

00:37:43.350 --> 00:37:46.599
它在九个版本中被引入

00:37:45.330 --> 00:37:50.349
给出相同的输出

00:37:46.599 --> 00:37:53.400
但是如果我说Jade更深的扫描减去

00:37:50.349 --> 00:37:57.640
减去释放八则仅

00:37:53.400 --> 00:38:00.670
分析AP的二进制文件是

00:37:57.640 --> 00:38:02.109
在Java 8和更早版本中已弃用，因此

00:38:00.670 --> 00:38:05.529
如果您注意到之间的区别

00:38:02.109 --> 00:38:08.829
这些是布尔构造函数是

00:38:05.529 --> 00:38:12.190
减号8中未标记

00:38:08.829 --> 00:38:15.789
输出，实际上我们可以这样做

00:38:12.190 --> 00:38:18.670
不仅是真正的JD Kane，这是

00:38:15.789 --> 00:38:21.220
 JDK 9中的新功能

00:38:18.670 --> 00:38:23.710
有关AP的信息存在于

00:38:21.220 --> 00:38:26.589
三个先前的版本，所以我们都可以

00:38:23.710 --> 00:38:28.960
我们可以一路回八七

00:38:26.589 --> 00:38:30.819
还有六个，我们可以说我们基本上是

00:38:28.960 --> 00:38:35.650
问这个问题什么不赞成使用AP 

00:38:30.819 --> 00:38:38.079
相对于jdk，此二进制文件是否使用

00:38:35.650 --> 00:38:39.640
版本n，所以我们可以说减号

00:38:38.079 --> 00:38:41.680
释放七，事实上，如果你全力以赴

00:38:39.640 --> 00:38:43.569
未成年人的方式释放了六个没有

00:38:41.680 --> 00:38:46.539
这些api的使用时间为6， 

00:38:43.569 --> 00:38:48.009
所以没有输出，所以新的

00:38:46.539 --> 00:38:50.200
这里的特点是

00:38:48.009 --> 00:38:52.809
信息内置到jdk中， 

00:38:50.200 --> 00:38:54.700
你不必带老

00:38:52.809 --> 00:39:18.009
版本的GDK为了做到这一点

00:38:54.700 --> 00:39:19.450
是的，这里有个快速的问题，所以

00:39:18.009 --> 00:39:21.969
问题是关于

00:39:19.450 --> 00:39:23.650
携带三个版本，所以没有这个

00:39:21.969 --> 00:39:26.109
这个工具真的是建立在相同的基础上

00:39:23.650 --> 00:39:29.410
编译器工具链，因此如下

00:39:26.109 --> 00:39:32.619
相同的政策，因此在jdk 10中这三个

00:39:29.410 --> 00:39:35.650
后面将是九点八点和七点等等

00:39:32.619 --> 00:39:37.269
当jdk 10出现时

00:39:35.650 --> 00:39:38.680
我们试图表示的是，这是

00:39:37.269 --> 00:39:42.809
生命周期结束，我想我们是说

00:39:38.680 --> 00:39:46.269
好的，在十个时间间隔内，六个

00:39:42.809 --> 00:39:49.749
我们不，我们不期望大多数人

00:39:46.269 --> 00:39:51.430
即将迁移至六

00:39:49.749 --> 00:39:54.130
所以背着这个旧的意义

00:39:51.430 --> 00:39:56.049
周围的信息是jdk 10何时到来

00:39:54.130 --> 00:39:57.640
人们仍然会从

00:39:56.049 --> 00:40:00.180
较旧的版本，但它们不会

00:39:57.640 --> 00:40:02.849
一定要迁移到很晚

00:40:00.180 --> 00:40:04.980
只有一个，所以当十个出来的时候

00:40:02.849 --> 00:40:07.260
想使用最新的工具链，但是

00:40:04.980 --> 00:40:09.030
您可能要迁移到八个或九个

00:40:07.260 --> 00:40:11.670
所以这就是为什么我们保留那个

00:40:09.030 --> 00:40:13.380
信息可供使用，但何时

00:40:11.670 --> 00:40:18.780
东西太旧了，我们只是掉线

00:40:13.380 --> 00:40:20.339
现在我想事情从头到尾

00:40:18.780 --> 00:40:24.540
我们只是在移动事物

00:40:20.339 --> 00:40:28.559
通过每个版本都可以

00:40:24.540 --> 00:40:30.900
所以其中一件事是另外一件事

00:40:28.559 --> 00:40:33.240
这里还有另一个皱纹

00:40:30.900 --> 00:40:34.980
我们实际上发现得很好

00:40:33.240 --> 00:40:36.839
最近在这是一种

00:40:34.980 --> 00:40:38.940
 API中的新状态转换

00:40:36.839 --> 00:40:40.980
进化，所以大的国家过渡

00:40:38.940 --> 00:40:44.640
已经有一段时间了

00:40:40.980 --> 00:40:48.059
不建议弃用，但有

00:40:44.640 --> 00:40:51.599
潜在的潜在附加问题

00:40:48.059 --> 00:40:53.940
从普通的弃用到

00:40:51.599 --> 00:40:57.650
最终弃用，那是什么时候

00:40:53.940 --> 00:41:00.930
用于将更改从false更改为true 

00:40:57.650 --> 00:41:03.720
所以问题出在

00:41:00.930 --> 00:41:07.079
与压抑的互动

00:41:03.720 --> 00:41:09.480
警告，所以我有一个方案

00:41:07.079 --> 00:41:12.210
这在下一张幻灯片上可以

00:41:09.480 --> 00:41:14.160
假设我想这是这个

00:41:12.210 --> 00:41:16.319
相对于编译器警告，所以假设

00:41:14.160 --> 00:41:18.599
我有一个应用程序，它可以编译

00:41:16.319 --> 00:41:21.599
罚款没有警告，它使用一些AP是

00:41:18.599 --> 00:41:23.579
现在不被淘汰

00:41:21.599 --> 00:41:26.490
下一个JDK版本的API 

00:41:23.579 --> 00:41:29.010
不赞成使用，我重新编译它， 

00:41:26.490 --> 00:41:31.470
我收到了弃用警告，我非常

00:41:29.010 --> 00:41:34.049
认真的所以我说我要走了

00:41:31.470 --> 00:41:36.329
将抑制警告注释添加到

00:41:34.049 --> 00:41:40.440
压制那个警告

00:41:36.329 --> 00:41:44.190
因为我使用的API已弃用，但

00:41:40.440 --> 00:41:46.950
它没有标记为删除，但我想要

00:41:44.190 --> 00:41:48.960
继续使用它，所以我添加

00:41:46.950 --> 00:41:52.020
抑制警告，然后在下一个

00:41:48.960 --> 00:41:54.240
 JDK版本弃用升级

00:41:52.020 --> 00:41:56.520
 to表示移除等于true，这意味着

00:41:54.240 --> 00:41:58.619
该API将被删除，但是当

00:41:56.520 --> 00:42:00.990
我重新编译我已经被抑制了

00:41:58.619 --> 00:42:03.720
警告在那里，所以我什么也没收到

00:42:00.990 --> 00:42:05.579
警告何时发生，然后何时

00:42:03.720 --> 00:42:07.500
我在以下JDK版本上重新编译

00:42:05.579 --> 00:42:09.809
当事情不见了，它说符号

00:42:07.500 --> 00:42:12.119
没找到好，这很讨厌

00:42:09.809 --> 00:42:13.650
惊喜，因为我们的通知系统

00:42:12.119 --> 00:42:16.500
使我们失败了

00:42:13.650 --> 00:42:18.240
所以这实际上是在

00:42:16.500 --> 00:42:20.730
进展，现在还没有集成

00:42:18.240 --> 00:42:22.980
它的九丹麦克朗，但如果你看看

00:42:20.730 --> 00:42:27.299
抑制警告注释

00:42:22.980 --> 00:42:29.700
实际上是一个标签，您可以放等等

00:42:27.299 --> 00:42:31.650
它基本上是一个字符串，所以现在

00:42:29.700 --> 00:42:35.910
抑制弃用警告的方法是

00:42:31.650 --> 00:42:38.160
在禁止警告弃用时，那么

00:42:35.910 --> 00:42:41.369
我们是说如果您使用的是

00:42:38.160 --> 00:42:43.230
已弃用的api，用于删除等于

00:42:41.369 --> 00:42:45.720
是的，如果您使用的是

00:42:43.230 --> 00:42:47.420
即将弃用的API 

00:42:45.720 --> 00:42:49.859
属于不同的类别

00:42:47.420 --> 00:42:54.150
警告，我们称这些移除

00:42:49.859 --> 00:42:55.950
警告，所以这意味着如果您已经

00:42:54.150 --> 00:42:58.500
已经取消警告

00:42:55.950 --> 00:43:01.650
如果那东西普通贬值

00:42:58.500 --> 00:43:02.880
最终被弃用

00:43:01.650 --> 00:43:04.319
反正会得到警告

00:43:02.880 --> 00:43:06.420
尽管有禁止显示的警告

00:43:04.319 --> 00:43:09.270
已经在那里，我们希望做到这一点

00:43:06.420 --> 00:43:12.839
因为既然没有发生，那你

00:43:09.270 --> 00:43:15.270
错过了该通知，所以如果您

00:43:12.839 --> 00:43:17.579
您正在使用的是

00:43:15.270 --> 00:43:20.190
最终弃用，您仍然想要

00:43:17.579 --> 00:43:22.619
继续使用，后果自负

00:43:20.190 --> 00:43:24.180
因为它将要被删除

00:43:22.619 --> 00:43:27.270
您可以使用以下方式禁止显示该警告

00:43:24.180 --> 00:43:28.950
禁止删除警告，因此

00:43:27.270 --> 00:43:30.990
不幸的是，那是正在进行的

00:43:28.950 --> 00:43:36.299
不是，这不在当前的EA版本中

00:43:30.990 --> 00:43:38.539
但是，我认为我们也在努力

00:43:36.299 --> 00:43:42.750
我想这会变成这样

00:43:38.539 --> 00:43:44.369
如果你还记得我之前说过

00:43:42.750 --> 00:43:45.980
您使用的是刚刚弃用的API 

00:43:44.369 --> 00:43:48.029
一张纸条，你不得不说很棒

00:43:45.980 --> 00:43:51.569
出色的弃用功能使

00:43:48.029 --> 00:43:53.609
详细信息，如果您使用终端

00:43:51.569 --> 00:43:56.460
不推荐使用的api，您将获得

00:43:53.609 --> 00:43:58.109
默认情况下显示详细警告，而不是

00:43:56.460 --> 00:44:00.390
必须经过第二遍

00:43:58.109 --> 00:44:03.089
重新启用它们，所以我们正在尝试做

00:44:00.390 --> 00:44:04.890
对事物有更强烈的警告

00:44:03.089 --> 00:44:07.140
不建议将其删除，因为

00:44:04.890 --> 00:44:09.119
不仅如此，还有更多

00:44:07.140 --> 00:44:12.960
严重的情况，因为我们确实

00:44:09.119 --> 00:44:15.390
打算删除那些没事的，这是

00:44:12.960 --> 00:44:18.980
这是这个的一点

00:44:15.390 --> 00:44:18.980
旧的旧清理工作的一点点

00:44:19.069 --> 00:44:24.960
记得我之前说过

00:44:22.289 --> 00:44:27.120
最初的弃用是javadoc标签

00:44:24.960 --> 00:44:30.150
但是注释没有

00:44:27.120 --> 00:44:32.490
直到Java 5才怎么样

00:44:30.150 --> 00:44:35.670
一直记录在类文件中

00:44:32.490 --> 00:44:37.590
回到1.1至1.4 

00:44:35.670 --> 00:44:40.140
是否有记录是

00:44:37.590 --> 00:44:41.280
弃用，所以注释方式

00:44:40.140 --> 00:44:43.770
工作是当他们被编译时

00:44:41.280 --> 00:44:47.880
实际上是在类文件中结束的，所以

00:44:43.770 --> 00:44:50.340
今天已弃用的api已弃用

00:44:47.880 --> 00:44:52.590
最终以

00:44:50.340 --> 00:44:54.840
类文件，编译器看起来

00:44:52.590 --> 00:44:56.550
文件管理器和ID查找该注释

00:44:54.840 --> 00:45:00.060
并可能在他们发出警告时发出警告

00:44:56.550 --> 00:45:02.460
发现用途，但在注释之前

00:45:00.060 --> 00:45:04.950
这在注释存在之前

00:45:02.460 --> 00:45:10.470
信息在哪里记录得很好

00:45:04.950 --> 00:45:12.900
事实证明，如果您看着

00:45:10.470 --> 00:45:14.990
在JVM规范中

00:45:12.900 --> 00:45:18.300
所谓的过时的东西

00:45:14.990 --> 00:45:19.620
该属性与

00:45:18.300 --> 00:45:21.450
不推荐使用的javadoc标记，那就是

00:45:19.620 --> 00:45:23.430
与不建议使用的注释不同

00:45:21.450 --> 00:45:24.990
这就是那里的小东西

00:45:23.430 --> 00:45:27.390
实际上它没有任何信息

00:45:24.990 --> 00:45:29.400
本质上说此API的布尔值

00:45:27.390 --> 00:45:30.900
已弃用，因此仍然

00:45:29.400 --> 00:45:33.030
周围，​​因为那是原始的

00:45:30.900 --> 00:45:35.700
弃用机制适用于所有约会

00:45:33.030 --> 00:45:37.410
一路回到1.1好吧

00:45:35.700 --> 00:45:38.880
这里我们介绍Java 5 

00:45:37.410 --> 00:45:42.300
注释注释现在是

00:45:38.880 --> 00:45:44.940
标记事物的首选方式

00:45:42.300 --> 00:45:47.070
弃用了，我们该怎么办

00:45:44.940 --> 00:45:51.740
具有不推荐使用的类文件属性

00:45:47.070 --> 00:45:54.210
我认为我们将弃用

00:45:51.740 --> 00:45:56.280
所以这是长期的

00:45:54.210 --> 00:45:57.720
我在这里进化实际上没有

00:45:56.280 --> 00:45:59.100
从类中弃用事物的方法

00:45:57.720 --> 00:46:01.380
我认为可能是这些文件之一

00:45:59.100 --> 00:46:03.750
在下一个版本中

00:46:01.380 --> 00:46:05.520
它将使用的JVM类文件格式

00:46:03.750 --> 00:46:07.800
实际上从

00:46:05.520 --> 00:46:09.690
规范和类的语义

00:46:07.800 --> 00:46:12.330
文件属性是

00:46:09.690 --> 00:46:15.270
处理一个类文件，然后忽略

00:46:12.330 --> 00:46:19.980
你一无所知的属性

00:46:15.270 --> 00:46:22.260
关于，所以我认为我们没有工作

00:46:19.980 --> 00:46:24.300
完全是这样，可能不是

00:46:22.260 --> 00:46:27.420
将会在jdk 9中发生，所以将来

00:46:24.300 --> 00:46:29.220
 JDK释放他们我会怀疑我们

00:46:27.420 --> 00:46:32.460
最终可能会遇到以下情况： 

00:46:29.220 --> 00:46:35.400
将来的课程文件版本将不再

00:46:32.460 --> 00:46:37.020
具有已弃用的属性，并且

00:46:35.400 --> 00:46:41.360
因此，弃用信息将

00:46:37.020 --> 00:46:41.360
仅驻留在注释中

00:46:41.990 --> 00:46:46.800
好吧，我提到的未来工作

00:46:44.670 --> 00:46:48.270
早些时候，我们想要的一件事

00:46:46.800 --> 00:46:51.000
要做的就是发展

00:46:48.270 --> 00:46:52.290
我认为主要是运行时分析工具

00:46:51.000 --> 00:46:54.570
事情是，有很多

00:46:52.290 --> 00:46:56.250
反射出来的东西

00:46:54.570 --> 00:47:00.330
访问事物，那些将是

00:46:56.250 --> 00:47:03.270
静态分析仪错过了

00:47:00.330 --> 00:47:05.760
大量的AP正在排队

00:47:03.270 --> 00:47:08.280
在特定遗产中不推荐使用

00:47:05.760 --> 00:47:12.270
像矢量哈希表和

00:47:08.280 --> 00:47:13.710
枚举可选点得到

00:47:12.270 --> 00:47:16.410
当我引起很多惊ster 

00:47:13.710 --> 00:47:17.940
建议我相信有一些

00:47:16.410 --> 00:47:19.740
问题是，实际上

00:47:17.940 --> 00:47:22.200
容易出错，实际上我对

00:47:19.740 --> 00:47:24.930
 JDK代码，发现大多数用途

00:47:22.200 --> 00:47:27.810
可选的get最好重写为

00:47:24.930 --> 00:47:30.210
避免使用它有一些旧东西

00:47:27.810 --> 00:47:32.010
例如计时器和计时器任务

00:47:30.210 --> 00:47:33.660
被预定的威胁取代

00:47:32.010 --> 00:47:36.060
线程执行器，有点像

00:47:33.660 --> 00:47:37.590
一口，然后代顿日历是

00:47:36.060 --> 00:47:39.630
现在已经过时，因为我们有了新的

00:47:37.590 --> 00:47:42.480
 Java Time API的八点介绍

00:47:39.630 --> 00:47:46.980
现在是时候加强

00:47:42.480 --> 00:47:49.170
弃用日期和日历之一

00:47:46.980 --> 00:47:50.370
问题其实不是我

00:47:49.170 --> 00:47:54.270
在下一张幻灯片中讨论了警告

00:47:50.370 --> 00:47:55.440
所以对不起目前的工作java korba模块

00:47:54.270 --> 00:47:58.650
这里有一个问号，因为

00:47:55.440 --> 00:48:02.700
它还没有发生

00:47:58.650 --> 00:48:05.220
就像我们想弃用科巴，但

00:48:02.700 --> 00:48:10.320
这是对曲线锯的一个相当近期的变化

00:48:05.220 --> 00:48:12.750
在那模块信息Java语法上

00:48:10.320 --> 00:48:15.210
直到最近还不支持

00:48:12.750 --> 00:48:17.100
注释，如果您要怎么办

00:48:15.210 --> 00:48:18.450
想要弃用模块，因此

00:48:17.100 --> 00:48:20.880
拼图团队一直在努力

00:48:18.450 --> 00:48:23.240
的东西，他们最近决定

00:48:20.880 --> 00:48:27.870
进行语法更改以允许

00:48:23.240 --> 00:48:30.600
在模块声明中的注释

00:48:27.870 --> 00:48:34.200
 Java模块信息

00:48:30.600 --> 00:48:38.550
使用不推荐使用的注释的原因

00:48:34.200 --> 00:48:40.380
那让我很开心，所以一个

00:48:38.550 --> 00:48:42.450
弃用的绊脚石

00:48:40.380 --> 00:48:45.900
所有这些api其实是

00:48:42.450 --> 00:48:47.880
广泛使用，然后添加

00:48:45.900 --> 00:48:48.680
弃用他将创建编译器

00:48:47.880 --> 00:48:51.440
警告

00:48:48.680 --> 00:48:53.059
这实际上是一个问题

00:48:51.440 --> 00:48:55.579
 JDK本身，因为有很多

00:48:53.059 --> 00:48:57.470
在JDK中使用诸如vector之类的东西

00:48:55.579 --> 00:49:00.050
所以我们将不得不做更多的事情

00:48:57.470 --> 00:49:02.000
如果我们不推荐使用，警告会清除

00:49:00.050 --> 00:49:05.809
向量，一方面，我们想要

00:49:02.000 --> 00:49:07.970
弃用旧东西，而你

00:49:05.809 --> 00:49:09.650
知道将其标记为旧且已过时

00:49:07.970 --> 00:49:11.059
同时它将创造很多

00:49:09.650 --> 00:49:14.750
我们有很多工作，因为我们有很多

00:49:11.059 --> 00:49:17.059
清除警告，然后再执行

00:49:14.750 --> 00:49:18.650
很多人在打开JDK邮件

00:49:17.059 --> 00:49:20.150
清单也对此抱怨

00:49:18.650 --> 00:49:22.040
没错，因为你知道他们

00:49:20.150 --> 00:49:25.849
不喜欢有人时不喜欢

00:49:22.040 --> 00:49:27.200
其他为他们创造工作，所以但是

00:49:25.849 --> 00:49:28.970
我从中得到的是，我们

00:49:27.200 --> 00:49:30.800
需要提供更好的机制

00:49:28.970 --> 00:49:32.599
管理警告，所以有各种各样的

00:49:30.800 --> 00:49:34.430
抑制警告减去

00:49:32.599 --> 00:49:36.440
优秀的选择等等可以

00:49:34.430 --> 00:49:38.540
对此有所帮助，但它们并不强大

00:49:36.440 --> 00:49:41.030
足够，所以我们对

00:49:38.540 --> 00:49:42.530
执行API特定的警告管理

00:49:41.030 --> 00:49:44.990
或类似的东西就足够了

00:49:42.530 --> 00:49:51.109
所有的想法都没有实现

00:49:44.990 --> 00:49:54.640
还好，所以这里的结论是

00:49:51.109 --> 00:49:57.829
哦，有一个JEP要弃用

00:49:54.640 --> 00:50:01.460
 Jeff是JDK的增强建议，因此Jeff 

00:49:57.829 --> 00:50:05.569
 277基本就完成了

00:50:01.460 --> 00:50:08.480
包括升级到

00:50:05.569 --> 00:50:11.540
不推荐使用的注解本身是新的

00:50:08.480 --> 00:50:15.290
 AP的折旧，然后是JD 

00:50:11.540 --> 00:50:22.220
每个扫描工具，所以我们要慢慢清洁

00:50:15.290 --> 00:50:24.770
 JDK中的API，我们也在

00:50:22.220 --> 00:50:27.260
进展是这个新的警告

00:50:24.770 --> 00:50:30.140
类别禁止删除警告

00:50:27.260 --> 00:50:33.559
一对夫妇在那里链接到

00:50:30.140 --> 00:50:36.200
 JEP和最近的JDK 9版本全部构建

00:50:33.559 --> 00:50:39.619
其中有J尿布扫描工具

00:50:36.200 --> 00:50:42.260
他们，所以我鼓励你去下载

00:50:39.619 --> 00:50:44.000
并尝试一下，所以我在推特上我

00:50:42.260 --> 00:50:46.190
我在这里有几个推特手柄

00:50:44.000 --> 00:50:48.380
博士在Twitter和我的真实网站上弃用了ur 

00:50:46.190 --> 00:50:51.319
名字是斯图尔特商标，所以你可以和

00:50:48.380 --> 00:50:53.089
我直接这样跟我说话，谢谢

00:50:51.319 --> 00:50:54.920
你和我还有几分钟的时间

00:50:53.089 --> 00:50:56.110
问题这里有一个问题

00:50:54.920 --> 00:51:10.210
这个绅士

00:50:56.110 --> 00:51:11.650
哦，谢谢，嗯，是的，所以

00:51:10.210 --> 00:51:13.360
问题是关于第三方库

00:51:11.650 --> 00:51:15.010
我实际上忘记了一个很好的问题

00:51:13.360 --> 00:51:16.480
打算把像

00:51:15.010 --> 00:51:19.090
这在我的演讲中，但我忘了

00:51:16.480 --> 00:51:21.910
关于它，所以现在就弃用

00:51:19.090 --> 00:51:23.350
东西是一种以JDK为中心的

00:51:21.910 --> 00:51:30.700
也许你在想什么

00:51:23.350 --> 00:51:36.370
在任何第三方库中都差不多

00:51:30.700 --> 00:51:38.650
可以使用不推荐使用的注释，但是

00:51:36.370 --> 00:51:43.600
扫描仪工具仅支持扫描

00:51:38.650 --> 00:51:46.510
对于jdk AP是，所以我的设想是

00:51:43.600 --> 00:51:49.660
拥有更复杂的模式

00:51:46.510 --> 00:51:51.820
工具可以收集弃用信息

00:51:49.660 --> 00:51:55.710
从这个库中，然后

00:51:51.820 --> 00:52:00.490
信息在这里分析此二进制文件

00:51:55.710 --> 00:52:02.500
 api的使用已过时

00:52:00.490 --> 00:52:05.220
该图书馆，是的，我的意思是在

00:52:02.500 --> 00:52:08.670
计划，但那是未来的工作

00:52:05.220 --> 00:52:08.670
在这里提问

00:52:16.210 --> 00:52:23.810
标准

00:52:19.120 --> 00:52:29.920
它会执行该库是

00:52:23.810 --> 00:52:29.920
因为弃用而使用它

00:52:31.000 --> 00:52:36.080
好的，好的问题是

00:52:34.160 --> 00:52:39.170
如果已删除API 

00:52:36.080 --> 00:52:41.810
扫描仪工具会做扫描仪吗

00:52:39.170 --> 00:52:43.880
工具报告，因为那件事是

00:52:41.810 --> 00:52:45.500
现在已经从API中消失了， 

00:52:43.880 --> 00:52:47.780
这是一个很好的问题，我必须

00:52:45.500 --> 00:52:49.550
想更多有关该案例的信息，因为

00:52:47.780 --> 00:52:53.120
我实际上没有考虑过这种情况

00:52:49.550 --> 00:52:54.290
很好，因为我是你，我们知道

00:52:53.120 --> 00:52:56.270
没有过往的记录

00:52:54.290 --> 00:52:58.400
删除了东西，所以我们没有

00:52:56.270 --> 00:53:00.650
如何应付某事的经验

00:52:58.400 --> 00:53:28.070
已经被删除了，很好

00:53:00.650 --> 00:53:32.240
问题好吧好吧好吧好吧好吧

00:53:28.070 --> 00:53:36.320
好，所以那里有一些

00:53:32.240 --> 00:53:39.650
我在这里有一个部分答案是

00:53:36.320 --> 00:53:41.420
每次扫描的JD释放选项读取

00:53:39.650 --> 00:53:43.880
编译器的内部表

00:53:41.420 --> 00:53:46.670
已记录的工具链

00:53:43.880 --> 00:53:50.480
一切都通过得很好

00:53:46.670 --> 00:53:52.310
过去的API信息的发布，因此

00:53:50.480 --> 00:53:53.870
我设想的J depre扫描工作方式

00:53:52.310 --> 00:53:55.400
第三方库肯定是

00:53:53.870 --> 00:53:56.630
我们不会在JDK中发货

00:53:55.400 --> 00:53:59.150
对，我们不会维持

00:53:56.630 --> 00:54:02.810
有关过去的折旧的信息

00:53:59.150 --> 00:54:04.370
第三方库，但其中之一

00:54:02.810 --> 00:54:06.440
模式实际上有点

00:54:04.370 --> 00:54:09.470
现在那里有痕迹

00:54:06.440 --> 00:54:11.660
实验目的是扫描

00:54:09.470 --> 00:54:15.080
记录并记录折旧

00:54:11.660 --> 00:54:17.840
信息，如果您的开发人员

00:54:15.080 --> 00:54:19.610
谁在使用第三方库

00:54:17.840 --> 00:54:21.590
您可以扫描该库并简单地

00:54:19.610 --> 00:54:23.450
记录其过时的信息，以便

00:54:21.590 --> 00:54:25.100
你有多个版本

00:54:23.450 --> 00:54:27.260
您可以单独记录的库

00:54:25.100 --> 00:54:29.060
数据库，然后当你

00:54:27.260 --> 00:54:31.550
想做分析你可以说我

00:54:29.060 --> 00:54:33.140
我想使用版本3 4 

00:54:31.550 --> 00:54:35.630
在这里看到什么不推荐使用

00:54:33.140 --> 00:54:37.670
在版本3与版本4和版本5中

00:54:35.630 --> 00:54:40.100
不管你用什么版本

00:54:37.670 --> 00:54:42.170
从第三方库记录

00:54:40.100 --> 00:54:42.710
现在实际上这很有趣

00:54:42.170 --> 00:54:44.180
您

00:54:42.710 --> 00:54:45.530
如果您已经考虑过

00:54:44.180 --> 00:54:47.630
之后我想和你谈谈

00:54:45.530 --> 00:54:49.099
看看是否可行

00:54:47.630 --> 00:54:51.800
是否有替代方法

00:54:49.099 --> 00:54:54.250
必要或类似的东西

00:54:51.800 --> 00:54:54.250
让我们继续

00:55:33.950 --> 00:55:40.020
这样工具现在就输出

00:55:37.560 --> 00:55:41.130
我想你一定是读过

00:55:40.020 --> 00:55:43.380
文档或其他原因

00:55:41.130 --> 00:55:44.820
因为因为他们以为有一个

00:55:43.380 --> 00:55:46.500
我写的那行说

00:55:44.820 --> 00:55:47.970
输出仅供参考

00:55:46.500 --> 00:55:49.830
只是目的，但我指的是

00:55:47.970 --> 00:55:52.500
之前是这种实验

00:55:49.830 --> 00:55:54.450
 API或实验功能在哪里

00:55:52.500 --> 00:55:56.790
扫描结果将是

00:55:54.450 --> 00:56:00.420
以明确定义的格式记录

00:55:56.790 --> 00:56:02.760
可以保留下来，我认为

00:56:00.420 --> 00:56:04.740
这个想法是，而不是

00:56:02.760 --> 00:56:08.310
仅供参考

00:56:04.740 --> 00:56:10.320
以机器形式的aa格式

00:56:08.310 --> 00:56:12.690
可读且可能因此弃用

00:56:10.320 --> 00:56:17.070
一些旧图书馆的信息可以

00:56:12.690 --> 00:56:19.770
现在无限期地徘徊

00:56:17.070 --> 00:56:22.290
您不赞成使用的旧图书馆

00:56:19.770 --> 00:56:24.510
去除是真的，我想你需要一些

00:56:22.290 --> 00:56:26.190
种类的项目管理工作流程或

00:56:24.510 --> 00:56:28.170
以便下次发布时

00:56:26.190 --> 00:56:29.730
到处走，你不得不说

00:56:28.170 --> 00:56:32.100
好吧，看一下我们列出的东西

00:56:29.730 --> 00:56:34.380
说我们设置要删除的位置为true和

00:56:32.100 --> 00:56:37.500
确保将其删除，如此

00:56:34.380 --> 00:56:39.030
所以还不是全部，这是

00:56:37.500 --> 00:56:41.130
像该工具的第一个版本一样， 

00:56:39.030 --> 00:56:43.830
原则上是应该有可能

00:56:41.130 --> 00:56:46.380
记录该信息，然后

00:56:43.830 --> 00:56:48.990
启用自己的未来版本或

00:56:46.380 --> 00:56:50.220
你的继任者看看那个并说

00:56:48.990 --> 00:56:51.750
好的，这些就是我们现在所要做的

00:56:50.220 --> 00:56:55.140
需要删除，因为它们是

00:56:51.750 --> 00:56:57.830
我认为这位先生已经过时了

00:56:55.140 --> 00:56:57.830
已经等了很久了

00:57:03.749 --> 00:57:10.329
强迫良好的程序实践做什么

00:57:07.450 --> 00:57:14.279
你认为效果很好

00:57:10.329 --> 00:57:14.279
现在的实践是

00:57:17.980 --> 00:57:23.530
嗯，所以问题最初是

00:57:21.369 --> 00:57:25.690
歧义性很好，因为

00:57:23.530 --> 00:57:30.760
它有助于进一步更好地编程

00:57:25.690 --> 00:57:33.010
习俗和III不知道我的意思是我

00:57:30.760 --> 00:57:34.960
我不喜欢含糊不清

00:57:33.010 --> 00:57:36.880
这是因为这真的是

00:57:34.960 --> 00:57:39.550
这真的是桥接

00:57:36.880 --> 00:57:41.650
进入非技术方面

00:57:39.550 --> 00:57:44.080
我的意思是这就是维护

00:57:41.650 --> 00:57:45.520
这是生命周期的东西，这不是你

00:57:44.080 --> 00:57:47.830
知道该程序中存在错误或

00:57:45.520 --> 00:57:49.570
该程序没有错误，因此

00:57:47.830 --> 00:57:53.050
很难把它煮成二进制

00:57:49.570 --> 00:57:54.670
同时很难出现

00:57:53.050 --> 00:57:56.859
具有更好的渐变或类似的东西

00:57:54.670 --> 00:57:59.920
那仍然有用，什么效果

00:57:56.859 --> 00:58:02.950
这将在工程上继续吗

00:57:59.920 --> 00:58:05.350
我不知道的最佳实践是

00:58:02.950 --> 00:58:10.900
它将改善我认为的事情

00:58:05.350 --> 00:58:14.530
我的观点是模棱两可是

00:58:10.900 --> 00:58:15.760
之所以破坏是因为你知道我要走了

00:58:14.530 --> 00:58:17.170
回到这个对话上

00:58:15.760 --> 00:58:18.550
人们在说互联网论坛

00:58:17.170 --> 00:58:20.200
 de贬不算什么

00:58:18.550 --> 00:58:21.580
他们永远不会删除任何人

00:58:20.200 --> 00:58:23.500
否则，他们可能会

00:58:21.580 --> 00:58:26.830
如果他们做对了，该怎么办？ 

00:58:23.500 --> 00:58:30.490
所以我认为不确定性正在发生

00:58:26.830 --> 00:58:32.800
那里有些损坏，所以我想

00:58:30.490 --> 00:58:35.280
澄清这个我的意思是即使

00:58:32.800 --> 00:58:40.450
它只是一个布尔值，但是通过添加

00:58:35.280 --> 00:58:42.310
字面上的澄清然后

00:58:40.450 --> 00:58:43.660
会删除一些你吗

00:58:42.310 --> 00:58:44.740
知道你知道互联网的争论

00:58:43.660 --> 00:58:46.210
好，你永远不会赢得互联网

00:58:44.740 --> 00:58:49.480
他们只是继续争论直到他们

00:58:46.210 --> 00:58:51.220
直到他们决定不这样做，所以我

00:58:49.480 --> 00:58:53.650
希望这将这将

00:58:51.220 --> 00:58:56.170
将采取其中的某些子集

00:58:53.650 --> 00:58:58.420
互联网争论，并说这是

00:58:56.170 --> 00:58:59.530
答案将被删除， 

00:58:58.420 --> 00:59:00.970
那么将会有一个不同的

00:58:59.530 --> 00:59:04.600
关于什么时候去的争论

00:59:00.970 --> 00:59:06.630
好吧，我那位先生回来了

00:59:04.600 --> 00:59:06.630
那里

00:59:12.630 --> 00:59:16.299
是的，关于

00:59:15.069 --> 00:59:18.339
警告是否会有所不同

00:59:16.299 --> 00:59:20.680
去除真假的东西

00:59:18.339 --> 00:59:23.410
我们正在努力，是的，我想

00:59:20.680 --> 00:59:25.180
我们需要做的就是确保它

00:59:23.410 --> 00:59:29.079
绝对清楚，如果您使用

00:59:25.180 --> 00:59:31.839
不推荐使用的API，无论是普通的还是

00:59:29.079 --> 00:59:34.210
终端弃用该文本

00:59:31.839 --> 00:59:36.160
您获得的输出的

00:59:34.210 --> 00:59:37.869
绝对清楚你知道什么

00:59:36.160 --> 00:59:40.839
那东西的处置是这样的

00:59:37.869 --> 00:59:42.730
是的，那就是我们需要的东西

00:59:40.839 --> 00:59:44.680
要继续工作，我仍然需要一个I 

00:59:42.730 --> 00:59:47.500
我需要修复一个错误

00:59:44.680 --> 00:59:49.569
基本上，你知道看看

00:59:47.500 --> 00:59:51.520
玉皮钱包可以输出并确保

00:59:49.569 --> 00:59:53.049
确保这些消息正确

00:59:51.520 --> 00:59:54.900
我正在与一个编译器团队合作

00:59:53.049 --> 00:59:58.780
确保他们的警告是

00:59:54.900 --> 01:00:00.250
也合适，所以我想我出去了

00:59:58.780 --> 01:00:02.140
在这一点上的时间，所以谢谢

01:00:00.250 --> 01:00:03.430
您的关注和关注，我会

01:00:02.140 --> 01:00:05.890
徘徊一点所以有

01:00:03.430 --> 01:00:07.950
还好几个问题，非常感谢

01:00:05.890 --> 01:00:07.950
许多

