WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.149 --> 00:00:07.709
大家好，我叫米尔斯

00:00:05.850 --> 00:00:09.360
 oopah我是DNA的软件开发人员

00:00:07.709 --> 00:00:11.969
堆栈，我们在其中建立了一个

00:00:09.360 --> 00:00:13.410
基因组学平台，我们的平台是

00:00:11.969 --> 00:00:14.639
主要是用Java编写的，所以我们已经

00:00:13.410 --> 00:00:16.080
开始研究Java的新功能

00:00:14.639 --> 00:00:19.050
 9，我认为这很有趣

00:00:16.080 --> 00:00:21.630
分享这些信息，因此目标

00:00:19.050 --> 00:00:24.090
这个演讲是要经历几个

00:00:21.630 --> 00:00:25.619
我最喜欢的Java 9 API，不是

00:00:24.090 --> 00:00:27.360
要谈论模块化或

00:00:25.619 --> 00:00:28.910
我感觉语言得到了改善

00:00:27.360 --> 00:00:31.169
在其他地方已被充分覆盖

00:00:28.910 --> 00:00:34.140
好吧，您将专注于我们

00:00:31.169 --> 00:00:36.750
库api，尤其小

00:00:34.140 --> 00:00:38.640
 api api不会得到那么多

00:00:36.750 --> 00:00:40.559
强调或我认为被低估了

00:00:38.640 --> 00:00:42.899
或只是API使得它更容易

00:00:40.559 --> 00:00:45.480
编写更干净的代码，所以我们要

00:00:42.899 --> 00:00:48.359
看一下现有的API 

00:00:45.480 --> 00:00:51.269
这就是集合API流API 

00:00:48.359 --> 00:00:52.530
以及可完成的未来api和

00:00:51.269 --> 00:00:54.539
他们最新的改进

00:00:52.530 --> 00:00:57.059
 Java平台以及

00:00:54.539 --> 00:00:59.909
新的api已发布，那就是

00:00:57.059 --> 00:01:03.719
堆栈Volker进程句柄和HTTP 

00:00:59.909 --> 00:01:05.790
给客户，这就是我要的

00:01:03.719 --> 00:01:08.550
和幻灯片一起去，我觉得更小

00:01:05.790 --> 00:01:11.510
最好用示例解释api 

00:01:08.550 --> 00:01:14.160
所以我们要做一个现场演示， 

00:01:11.510 --> 00:01:17.550
我们将在其中编写所有示例

00:01:14.160 --> 00:01:19.050
 J shell和基本上每个API 

00:01:17.550 --> 00:01:21.030
想展示这是怎么回事

00:01:19.050 --> 00:01:22.740
在Java 9之前会采用API 

00:01:21.030 --> 00:01:25.350
我们当时有空，如何可以

00:01:22.740 --> 00:01:27.450
在7月9日做得更好，所以我希望你

00:01:25.350 --> 00:01:32.960
都可以看到这里的内容

00:01:27.450 --> 00:01:32.960
是J shell，真的是工具哦

00:01:35.240 --> 00:01:40.160
是的，我们可以做些什么

00:01:37.680 --> 00:01:40.160
灯在这里

00:01:47.350 --> 00:01:54.390
有这个不确定如何诚实

00:02:07.720 --> 00:02:17.500
是的，我想我们被困在了这里

00:02:09.910 --> 00:02:20.440
这是可读性吗很好很好所以

00:02:17.500 --> 00:02:24.730
 J Shell是JDK附带的工具

00:02:20.440 --> 00:02:26.680
它本质上是Java实现

00:02:24.730 --> 00:02:28.960
成熟的旧读取eval打印循环的原因是

00:02:26.680 --> 00:02:30.670
不断循环读取的工具

00:02:28.960 --> 00:02:33.180
您的输入评估它会打印出

00:02:30.670 --> 00:02:35.440
输出，所以它基本上类似于

00:02:33.180 --> 00:02:37.000
常用的线路接口

00:02:35.440 --> 00:02:39.670
到其他语言，例如groovy 

00:02:37.000 --> 00:02:41.910
 Scala Python他们以前都有过

00:02:39.670 --> 00:02:44.170
最后Java也得到了

00:02:41.910 --> 00:02:46.480
这是一个非常好的工具，当您

00:02:44.170 --> 00:02:48.190
需要很快尝试一些东西

00:02:46.480 --> 00:02:50.980
这只是探索原型的好方法

00:02:48.190 --> 00:02:54.160
您的api或学习语言，如果

00:02:50.980 --> 00:02:56.140
您是Java的新手， 

00:02:54.160 --> 00:02:59.080
您需要了解的J Shell是

00:02:56.140 --> 00:02:59.710
它接受两种类型的输入

00:02:59.080 --> 00:03:01.300
片段

00:02:59.710 --> 00:03:04.210
所以您想要的实际Java代码

00:03:01.300 --> 00:03:05.830
评估，并有命令

00:03:04.210 --> 00:03:07.240
总是启动的实现工具

00:03:05.830 --> 00:03:10.180
带有斜线，我们将显示一个

00:03:07.240 --> 00:03:12.280
在本次演讲中，我们将其中几个

00:03:10.180 --> 00:03:15.430
从一个非常简单的事情开始

00:03:12.280 --> 00:03:17.830
只要在这里做一加一就可以

00:03:15.430 --> 00:03:20.010
首先在这里看到两个有趣的东西

00:03:17.830 --> 00:03:22.510
一加一是二

00:03:20.010 --> 00:03:24.640
两者中的第二个被分配给

00:03:22.510 --> 00:03:26.140
这里叫做一美元的东西

00:03:24.640 --> 00:03:27.820
另一个是隐式变量

00:03:26.140 --> 00:03:29.080
 J都是为我创造的，它做到了

00:03:27.820 --> 00:03:31.270
每当你有一个表达，你

00:03:29.080 --> 00:03:33.160
不要分配任何我可以拥有的

00:03:31.270 --> 00:03:34.510
当然创建了我自己的变量

00:03:33.160 --> 00:03:36.670
她刚刚做某事

00:03:34.510 --> 00:03:38.980
像这样，这就是

00:03:36.670 --> 00:03:41.290
变量X，您已经看到了第一个

00:03:38.980 --> 00:03:43.510
我在这里使用Michelle的快捷方式

00:03:41.290 --> 00:03:45.640
几个这样的形状标签，我们

00:03:43.510 --> 00:03:47.470
从中推断出变量的类型

00:03:45.640 --> 00:03:49.420
表达式，然后引入一个新的

00:03:47.470 --> 00:03:52.239
我将要使用的那种类型的变量

00:03:49.420 --> 00:03:54.519
这广泛用于谈论jeschill 

00:03:52.239 --> 00:03:56.739
还具有标准的制表符完成功能

00:03:54.519 --> 00:03:58.810
你习惯从其他壳

00:03:56.739 --> 00:04:02.700
我可以在这里利用我的优势

00:03:58.810 --> 00:04:07.870
会说打印出我的变量

00:04:02.700 --> 00:04:09.640
这样的事情就是这样

00:04:07.870 --> 00:04:12.200
有几个语法捷径

00:04:09.640 --> 00:04:14.230
还有你

00:04:12.200 --> 00:04:14.230
哦

00:04:21.050 --> 00:04:29.040
很好，很好，所以这些是

00:04:27.030 --> 00:04:31.320
您已经注意到的语法快捷方式

00:04:29.040 --> 00:04:33.210
我不需要阅读我的表情

00:04:31.320 --> 00:04:35.880
任何只是一加一的东西

00:04:33.210 --> 00:04:37.710
这我也不需要放一个

00:04:35.880 --> 00:04:38.670
我发言结束时的分号

00:04:37.710 --> 00:04:40.080
不用担心赶上

00:04:38.670 --> 00:04:42.960
检查异常和几个

00:04:40.080 --> 00:04:45.600
这样的事情，所以这使我们

00:04:42.960 --> 00:04:47.250
第一个命令，更糟的是

00:04:45.600 --> 00:04:50.130
只需列出我拥有的所有变量

00:04:47.250 --> 00:04:51.900
声明与我可以输入的日期类似

00:04:50.130 --> 00:04:53.430
 J Shell中的方法和类以及

00:04:51.900 --> 00:04:55.770
有相应的命令

00:04:53.430 --> 00:04:57.230
这就是超级类型，但是我当然

00:04:55.770 --> 00:05:01.410
目前没有任何东西

00:04:57.230 --> 00:05:03.690
还有一个列表列出了我所有的

00:05:01.410 --> 00:05:04.950
片段和Rochelle具有此前缀

00:05:03.690 --> 00:05:07.320
提到只要你

00:05:04.950 --> 00:05:08.580
指定命令的唯一前缀

00:05:07.320 --> 00:05:09.810
可以实际找到命令并

00:05:08.580 --> 00:05:13.230
执行它，这样我就可以完成

00:05:09.810 --> 00:05:16.320
这样的东西和最后的意思

00:05:13.230 --> 00:05:17.940
这是只是给您的命令帮助

00:05:16.320 --> 00:05:20.190
有关其他所有信息

00:05:17.940 --> 00:05:21.990
您可以使用自己的频道

00:05:20.190 --> 00:05:23.820
您几乎所有需要知道的J 

00:05:21.990 --> 00:05:26.630
是一个非常容易理解的工具

00:05:23.820 --> 00:05:29.430
出来，让我们继续第一个API 

00:05:26.630 --> 00:05:31.160
清单上的第一个方便

00:05:29.430 --> 00:05:33.240
集合的保理方法和

00:05:31.160 --> 00:05:35.220
 Java 9使创建起来非常容易

00:05:33.240 --> 00:05:36.930
小规模的不可变集合

00:05:35.220 --> 00:05:38.910
这是相对的

00:05:36.930 --> 00:05:40.710
在Java 9之前做起来很乏味，而我

00:05:38.910 --> 00:05:43.080
确保每个人都知道以色列，如果我想

00:05:40.710 --> 00:05:45.840
例如创建一个集

00:05:43.080 --> 00:05:49.670
做这样的事情，让我们说一个

00:05:45.840 --> 00:05:54.140
一组字符串，我们称之为一组

00:05:49.670 --> 00:05:54.140
然后我要添加几个元素

00:05:55.280 --> 00:06:01.320
让我们说这样，然后使它

00:05:58.320 --> 00:06:07.690
一成不变，我会把它包装在

00:06:01.320 --> 00:06:09.790
像这样的可修改集

00:06:07.690 --> 00:06:11.590
而且有几个问题

00:06:09.790 --> 00:06:13.480
这种方法首先很漂亮

00:06:11.590 --> 00:06:14.860
详细，所以您有静态变量

00:06:13.480 --> 00:06:16.240
需要做一个静态的初始化块

00:06:14.860 --> 00:06:19.990
那不是很方便

00:06:16.240 --> 00:06:21.550
还有性能开销

00:06:19.990 --> 00:06:23.200
真的不是一个不变的集合

00:06:21.550 --> 00:06:25.240
它更像是一个不变的观点

00:06:23.200 --> 00:06:26.710
现有的收藏，所以如果我保留

00:06:25.240 --> 00:06:28.480
参考我会的原始设置

00:06:26.710 --> 00:06:29.980
仍然能够修改它，并且

00:06:28.480 --> 00:06:32.200
与之相关的性能开销

00:06:29.980 --> 00:06:33.370
支持可变性，更不用说全部了

00:06:32.200 --> 00:06:34.570
我必须创建的额外对象

00:06:33.370 --> 00:06:36.820
在过程中只是为了

00:06:34.570 --> 00:06:39.310
一成不变的收藏，但很多

00:06:36.820 --> 00:06:41.110
在Java 9的Gemini上更容易拥有静态

00:06:39.310 --> 00:06:44.590
许多工厂方法

00:06:41.110 --> 00:06:46.600
我可以轻松地在地图上列出的界面

00:06:44.590 --> 00:06:48.850
创建这样的集合

00:06:46.600 --> 00:06:51.700
总的来说是12倍

00:06:48.850 --> 00:06:53.230
确切的，因此它始终是0到10个参数

00:06:51.700 --> 00:06:55.320
最后一个是电弧

00:06:53.230 --> 00:06:57.520
这样做的原因是

00:06:55.320 --> 00:06:59.440
因为有性能开销

00:06:57.520 --> 00:07:01.510
与创建数组相关联

00:06:59.440 --> 00:07:02.890
备份电弧，如果你是

00:07:01.510 --> 00:07:04.360
创建合理的小馆藏

00:07:02.890 --> 00:07:06.490
大概会满足

00:07:04.360 --> 00:07:08.650
您想要的绝大多数用例

00:07:06.490 --> 00:07:11.770
避免这种面板的事情，所以我可以创建一个

00:07:08.650 --> 00:07:14.470
像这样轻松地列出

00:07:11.770 --> 00:07:17.110
这是一个列表，然后如果我尝试添加

00:07:14.470 --> 00:07:18.340
在此列表中，您可以看到

00:07:17.110 --> 00:07:19.440
真的是一成不变的

00:07:18.340 --> 00:07:21.550
一个例外

00:07:19.440 --> 00:07:23.860
同样，您喜欢尝试获取

00:07:21.550 --> 00:07:25.720
上课会告诉我

00:07:23.860 --> 00:07:30.610
不变但有趣的东西

00:07:25.720 --> 00:07:32.260
这里要注意的是这些一成不变的

00:07:30.610 --> 00:07:34.390
类不是真正的一部分

00:07:32.260 --> 00:07:36.550
公共API，因此我们只能依靠

00:07:34.390 --> 00:07:38.500
在这里和工厂相似的界面

00:07:36.550 --> 00:07:39.790
方法是接口上的方法，因此

00:07:38.500 --> 00:07:41.710
他们不是继承的，你不能调用

00:07:39.790 --> 00:07:42.880
他们为实施类，所以这

00:07:41.710 --> 00:07:45.400
是几乎唯一的创建方法

00:07:42.880 --> 00:07:49.360
这个列表，那只是一个不错的设计

00:07:45.400 --> 00:07:51.790
要指出的模式，因此首先设置

00:07:49.360 --> 00:07:56.740
地图几乎是一样的

00:07:51.790 --> 00:07:58.840
虽然对于地图我们有点不同

00:07:56.740 --> 00:08:01.930
这里有11种方法，所以总是

00:07:58.840 --> 00:08:03.880
零到十个元素，或者在这种情况下

00:08:01.930 --> 00:08:06.970
二十，因为您总是指定密钥

00:08:03.880 --> 00:08:08.680
和价值可互换，没有VAR 

00:08:06.970 --> 00:08:10.150
这种方法的弧形版本，那就是

00:08:08.680 --> 00:08:11.650
因为键和值可以有

00:08:10.150 --> 00:08:13.960
不同的类型，你不能有两个

00:08:11.650 --> 00:08:15.280
参数相同的方法又是什么

00:08:13.960 --> 00:08:17.860
他们已经完成了这实际上是

00:08:15.280 --> 00:08:21.060
创建了一个单独的方法

00:08:17.860 --> 00:08:22.889
我输入的内容只有一个

00:08:21.060 --> 00:08:26.780
利用这一点，我可以

00:08:22.889 --> 00:08:29.430
创建一个像这样的地图

00:08:26.780 --> 00:08:32.250
我有一张地图，其中键是整数

00:08:29.430 --> 00:08:35.729
和值是一个字符串，这很漂亮

00:08:32.250 --> 00:08:37.260
关于这些，有很多了解

00:08:35.729 --> 00:08:40.620
工厂方法，所以这只是一个真正的

00:08:37.260 --> 00:08:42.539
便利功能集

00:08:40.620 --> 00:08:44.990
串流API时播放效果非常好

00:08:42.539 --> 00:08:46.980
在Java 8中引入

00:08:44.990 --> 00:08:49.230
流学习了一些新技巧

00:08:46.980 --> 00:08:50.220
在Java之夜也是如此

00:08:49.230 --> 00:08:52.800
我想谈谈的功能

00:08:50.220 --> 00:08:55.850
这是一会儿的工作，要做好

00:08:52.800 --> 00:08:59.040
方法，让我们回过头来

00:08:55.850 --> 00:08:59.370
看看我们可以做什么

00:08:59.040 --> 00:09:01.830
爪哇

00:08:59.370 --> 00:09:06.240
八个它创建了一个ins流

00:09:01.830 --> 00:09:11.339
像这样说零

00:09:06.240 --> 00:09:13.670
九，然后只是打印，我只是

00:09:11.339 --> 00:09:18.510
将在这里使用快速方法参考

00:09:13.670 --> 00:09:20.250
我有0到9的数字

00:09:18.510 --> 00:09:22.380
在Java 8中可用的方法

00:09:20.250 --> 00:09:25.170
莉娜（Lina）跳过了，所以我可以做点什么

00:09:22.380 --> 00:09:27.360
就像这个极限5，这给了我

00:09:25.170 --> 00:09:30.210
流的前5个元素和一个

00:09:27.360 --> 00:09:34.770
免费方法scape给了我

00:09:30.210 --> 00:09:36.570
其余的字符串，所以很好，但是

00:09:34.770 --> 00:09:39.089
问题是

00:09:36.570 --> 00:09:40.950
在某些情况下你不知道

00:09:39.089 --> 00:09:42.450
事先号码，你只知道你

00:09:40.950 --> 00:09:44.460
想要继续吸收元素的同时

00:09:42.450 --> 00:09:45.900
满足一定条件

00:09:44.460 --> 00:09:47.310
有一点你有足够的，但那里

00:09:45.900 --> 00:09:50.190
并不是真正简单的表达方式

00:09:47.310 --> 00:09:52.140
这在Java时代一般9，但是我们

00:09:50.190 --> 00:09:54.990
有很好的工作方法，所以我

00:09:52.140 --> 00:10:00.810
可以指定类似这样的内容

00:09:54.990 --> 00:10:07.680
说X小于5并且是免费的

00:10:00.810 --> 00:10:09.089
操作作业，而这些都是

00:10:07.680 --> 00:10:10.440
像有限逃生的版本

00:10:09.089 --> 00:10:12.780
采取谓词而不是固定式

00:10:10.440 --> 00:10:15.959
价值，拥有它真的很棒

00:10:12.780 --> 00:10:20.330
这是这里的另一种新方法是

00:10:15.959 --> 00:10:22.470
方法迭代让我们看一下

00:10:20.330 --> 00:10:24.839
您可以看到我们的两个版本

00:10:22.470 --> 00:10:27.209
这种方法第一个可用

00:10:24.839 --> 00:10:28.950
在Java时代，第二个在

00:10:27.209 --> 00:10:30.900
 Java 9和不同之处在于

00:10:28.950 --> 00:10:33.540
谓词在这里，让我们举一个例子

00:10:30.900 --> 00:10:34.620
假设我想列出所有

00:10:33.540 --> 00:10:37.050
偶数

00:10:34.620 --> 00:10:39.300
少于100现在非常幼稚

00:10:37.050 --> 00:10:41.160
在Java时代做到这一点的方法是

00:10:39.300 --> 00:10:44.640
做这样的事情，我要

00:10:41.160 --> 00:10:49.080
从零开始迭代，让我们加一

00:10:44.640 --> 00:10:57.530
两点，然后我将打印所有

00:10:49.080 --> 00:11:00.920
这些和方法参考这里

00:10:57.530 --> 00:11:05.940
就像这样，你可以看到它

00:11:00.920 --> 00:11:09.450
有点工作不是因为我

00:11:05.940 --> 00:11:16.140
忘记过滤器，所以我要过滤这个

00:11:09.450 --> 00:11:19.770
假设我说我可以做到100 

00:11:16.140 --> 00:11:21.360
这和这几乎有效，并且

00:11:19.770 --> 00:11:23.280
即使它无法工作的原因

00:11:21.360 --> 00:11:25.110
似乎很简单的例子是

00:11:23.280 --> 00:11:27.900
我确实在这里过滤了前100个元素

00:11:25.110 --> 00:11:29.640
但是我创建了一个无限流

00:11:27.900 --> 00:11:31.200
过了一会儿，溪流不断

00:11:29.640 --> 00:11:33.780
有些时候它过去了，突然之间

00:11:31.200 --> 00:11:35.580
我的整数小于100 

00:11:33.780 --> 00:11:38.040
并不是真正表达的好方法

00:11:35.580 --> 00:11:38.730
这个边界条件是在7月8日，但在

00:11:38.040 --> 00:11:40.500
 Java 9 

00:11:38.730 --> 00:11:43.080
我实际上可以轻松做到这一点

00:11:40.500 --> 00:11:47.100
要在这里删除过滤器，我可以添加

00:11:43.080 --> 00:11:51.390
这里的另一个条件是

00:11:47.100 --> 00:11:53.820
这将正常工作，所以

00:11:51.390 --> 00:11:55.530
如果你看它本质上读

00:11:53.820 --> 00:11:56.970
像四个周期，基本上

00:11:55.530 --> 00:11:59.760
就像流e5版本一样

00:11:56.970 --> 00:12:03.690
之4，所以真的非常好用

00:11:59.760 --> 00:12:05.760
现在在这里介绍我的最后一种方法

00:12:03.690 --> 00:12:06.420
想在这里提到的是

00:12:05.760 --> 00:12:09.350
知识

00:12:06.420 --> 00:12:11.460
所以在Java 8中，我可以创建

00:12:09.350 --> 00:12:13.080
某些特定元素使用

00:12:11.460 --> 00:12:15.240
工厂方法我可以做类似的事情

00:12:13.080 --> 00:12:16.680
这会让我流

00:12:15.240 --> 00:12:19.320
包含一个元素和一个

00:12:16.680 --> 00:12:21.630
元素是我不能做的一个

00:12:19.320 --> 00:12:22.800
这样的事情很有意义

00:12:21.630 --> 00:12:23.930
因为你不想有知识

00:12:22.800 --> 00:12:28.430
在你的流中

00:12:23.930 --> 00:12:31.410
但是用德语我可以取消可为空

00:12:28.430 --> 00:12:33.780
现在通过它实际上会给我一个

00:12:31.410 --> 00:12:35.400
流，如果我看看它， 

00:12:33.780 --> 00:12:37.590
调用方法计数，它告诉我

00:12:35.400 --> 00:12:40.050
它实际上是一条空河，所以双子座

00:12:37.590 --> 00:12:43.290
足够聪明，现在可以将其视为

00:12:40.050 --> 00:12:45.270
空流，它在哪里有用

00:12:43.290 --> 00:12:46.620
基本上使集成更好

00:12:45.270 --> 00:12:46.960
你正在沿着流写作，你

00:12:46.620 --> 00:12:49.120
有一个

00:12:46.960 --> 00:12:50.440
连锁经营，尤其是地图

00:12:49.120 --> 00:12:52.270
有些事情你会最终

00:12:50.440 --> 00:12:53.230
 null，您将需要过滤结果

00:12:52.270 --> 00:12:54.340
因为你不想让他们进来

00:12:53.230 --> 00:12:56.050
你不想拥有梅尔

00:12:54.340 --> 00:12:57.340
在您的例外情况下，在某些时候

00:12:56.050 --> 00:12:59.380
你将有一个带有e的方块

00:12:57.340 --> 00:13:02.230
语句或三元运算符

00:12:59.380 --> 00:13:04.090
摆脱这些指甲，那仅仅是

00:13:02.230 --> 00:13:05.320
你的外套不是很漂亮

00:13:04.090 --> 00:13:07.900
允许您摆脱那些空值

00:13:05.320 --> 00:13:11.620
检查只是一个很好的便利功能

00:13:07.900 --> 00:13:13.900
还有另一个戏剧

00:13:11.620 --> 00:13:17.770
与流很好地是可完成的

00:13:13.900 --> 00:13:19.600
未来api可完成的期货

00:13:17.770 --> 00:13:21.700
提供同步框架

00:13:19.600 --> 00:13:23.770
 Java编程介绍

00:13:21.700 --> 00:13:25.840
在Java 8中，它们是一种构建

00:13:23.770 --> 00:13:30.040
围绕类称为完成

00:13:25.840 --> 00:13:31.750
未来，顾名思义

00:13:30.040 --> 00:13:34.150
这本质上是可以

00:13:31.750 --> 00:13:36.580
明确完成，所以这是什么

00:13:34.150 --> 00:13:39.160
用于的是您通常使用它来

00:13:36.580 --> 00:13:40.990
建模任务，尤其是同步任务

00:13:39.160 --> 00:13:43.720
在更大的计算中完成任务

00:13:40.990 --> 00:13:45.070
包含许多任务，因此您可以更改

00:13:43.720 --> 00:13:46.990
未来的地位和价值

00:13:45.070 --> 00:13:48.700
而且您还有IP用于创建

00:13:46.990 --> 00:13:50.740
期货之间的依赖性，因此我们可以

00:13:48.700 --> 00:13:54.220
使用此功能时表示可以

00:13:50.740 --> 00:13:55.870
完成触发了此操作，所以让我们

00:13:54.220 --> 00:13:58.480
看看真正的基础

00:13:55.870 --> 00:14:03.070
功能，您可以在此处创建新

00:13:58.480 --> 00:14:06.640
未来，说字符串的未来，所以

00:14:03.070 --> 00:14:08.560
我们称之为CF，然后我就可以完成

00:14:06.640 --> 00:14:13.000
具有价值的未来可能会得到

00:14:08.560 --> 00:14:15.190
字符串，您现在可以看到

00:14:13.000 --> 00:14:18.940
功能正常完成，如果我

00:14:15.190 --> 00:14:21.760
尝试提取实际的价值

00:14:18.940 --> 00:14:23.560
会给我那种价值，那又如何

00:14:21.760 --> 00:14:27.700
如果我不完成未来会发生

00:14:23.560 --> 00:14:29.230
让我们在这里重新初始化，我

00:14:27.700 --> 00:14:31.510
只是直接调用get方法

00:14:29.230 --> 00:14:33.670
事情，你可以看到在这种情况下

00:14:31.510 --> 00:14:35.020
它只是一直在阻塞，所以

00:14:33.670 --> 00:14:36.220
本质上是在等别人

00:14:35.020 --> 00:14:38.700
完成不同功能

00:14:36.220 --> 00:14:42.790
线程，这基本上就是你

00:14:38.700 --> 00:14:44.110
使用此构造函数进行同步

00:14:42.790 --> 00:14:46.930
也可以完成未来

00:14:44.110 --> 00:14:50.110
可以让您付出

00:14:46.930 --> 00:14:53.350
在这种情况下它是一个文件

00:14:50.110 --> 00:14:56.890
通过任何合法的州例外

00:14:53.350 --> 00:14:57.930
示例，现在，如果我尝试获取

00:14:56.890 --> 00:14:59.910
未来的价值

00:14:57.930 --> 00:15:02.670
这实际上会失败

00:14:59.910 --> 00:15:03.690
他们给的例外，所以有点

00:15:02.670 --> 00:15:07.830
基本功能

00:15:03.690 --> 00:15:10.520
可完成的期货Java 9引入了

00:15:07.830 --> 00:15:12.780
一堆东​​西实际上很多

00:15:10.520 --> 00:15:14.250
可完成的未来是一个很大的类

00:15:12.780 --> 00:15:15.900
近三千行代码和

00:15:14.250 --> 00:15:17.850
它有一堆方法和一堆

00:15:15.900 --> 00:15:20.160
公共方法也很多

00:15:17.850 --> 00:15:22.290
其中大多数是在Java 9中添加的

00:15:20.160 --> 00:15:24.960
他们不是很兴奋，主要是

00:15:22.290 --> 00:15:26.730
常规方法工厂方法

00:15:24.960 --> 00:15:28.410
使您更轻松的方法

00:15:26.730 --> 00:15:30.570
子类可计算的未来和东西

00:15:28.410 --> 00:15:33.300
像这样，三个

00:15:30.570 --> 00:15:34.860
真的很兴奋，双子座和

00:15:33.300 --> 00:15:37.590
基本上提供了一种新的方式

00:15:34.860 --> 00:15:40.610
根据超时完成期货

00:15:37.590 --> 00:15:43.740
所以在Java 9中我可以做点什么

00:15:40.610 --> 00:15:47.280
这样的事情让我们重新初始化

00:15:43.740 --> 00:15:51.840
在这里，可以按时致电完成

00:15:47.280 --> 00:15:54.990
拿出一个值，然后

00:15:51.840 --> 00:16:01.740
然后是实际时间，所以我说

00:15:54.990 --> 00:16:03.750
要给它五秒钟，所以现在如果

00:16:01.740 --> 00:16:07.560
我看看这个未来

00:16:03.750 --> 00:16:11.040
完成但仍未完成， 

00:16:07.560 --> 00:16:14.460
现在它完全正常了，价值

00:16:11.040 --> 00:16:16.380
实际上是超时的，所以这真的

00:16:14.460 --> 00:16:17.550
当您有一些分布式时很有用

00:16:16.380 --> 00:16:19.710
计算，假设您有一个

00:16:17.550 --> 00:16:22.050
涉及交谈的计算

00:16:19.710 --> 00:16:23.070
几个微服务，每个微服务

00:16:22.050 --> 00:16:24.840
那些你想要表达的东西

00:16:23.070 --> 00:16:26.910
就像好吧，等待这个结果

00:16:24.840 --> 00:16:28.680
微服务五秒钟

00:16:26.910 --> 00:16:30.720
如果没有的话，可以完成

00:16:28.680 --> 00:16:32.580
完成，我将加载默认值

00:16:30.720 --> 00:16:34.800
值或从缓存中加载值或

00:16:32.580 --> 00:16:36.360
这样的事情你也可能​​失败

00:16:34.800 --> 00:16:38.520
未完成的未来

00:16:36.360 --> 00:16:42.480
及时我将要重新初始化

00:16:38.520 --> 00:16:45.740
这是通过完成

00:16:42.480 --> 00:16:49.260
只是需要的方法或超时

00:16:45.740 --> 00:16:54.030
时间，所以我会再给它五秒钟

00:16:49.260 --> 00:16:55.670
现在，如果我尝试获得价值，那就是

00:16:54.030 --> 00:16:57.720
等五秒钟然后

00:16:55.670 --> 00:17:00.030
它将因超时而失败

00:16:57.720 --> 00:17:02.130
例外，所以这是两个

00:17:00.030 --> 00:17:04.700
表示时间的方法

00:17:02.130 --> 00:17:04.700
依存关系

00:17:05.610 --> 00:17:10.970
我想谈的最后一种方法

00:17:07.500 --> 00:17:12.870
关于这里是方法复制和复制

00:17:10.970 --> 00:17:15.270
本质上允许您创建一个

00:17:12.870 --> 00:17:16.559
未来的防御副本，所以这是

00:17:15.270 --> 00:17:18.000
当您设计一个

00:17:16.559 --> 00:17:20.160
同步api的实际位置

00:17:18.000 --> 00:17:21.510
返回您想要的可完成期货

00:17:20.160 --> 00:17:23.250
客户能够接受这些

00:17:21.510 --> 00:17:24.870
期货和应对变化

00:17:23.250 --> 00:17:26.130
这些期货，但您不希望它们

00:17:24.870 --> 00:17:27.720
能够回信你不想

00:17:26.130 --> 00:17:29.580
他们能够完成未来

00:17:27.720 --> 00:17:30.809
您在内部使用的那是

00:17:29.580 --> 00:17:33.270
复制什么，所以有点像

00:17:30.809 --> 00:17:35.580
单向同步，让我们

00:17:33.270 --> 00:17:38.450
看看这个，让我们重新初始化

00:17:35.580 --> 00:17:42.000
在这里，我要创建一个副本

00:17:38.450 --> 00:17:44.990
我们称它为副本，然后您可以

00:17:42.000 --> 00:17:52.590
看到他们还没有完成

00:17:44.990 --> 00:17:55.890
显然，如果我完成了原始的

00:17:52.590 --> 00:17:57.780
原件现已完成，副本

00:17:55.890 --> 00:17:59.789
也完成了，所以更改是

00:17:57.780 --> 00:18:02.419
传播给客户做出反应

00:17:59.789 --> 00:18:05.669
如果我增加一轮会怎样？ 

00:18:02.419 --> 00:18:09.690
让我们重新初始化CF重新初始化

00:18:05.669 --> 00:18:18.350
复制，现在我要完成

00:18:09.690 --> 00:18:20.700
复制到此处并完成原始复制

00:18:18.350 --> 00:18:23.220
没有改变，所以就像单向

00:18:20.700 --> 00:18:25.440
同步的东西，那就是

00:18:23.220 --> 00:18:28.650
一个非常好的功能，所以我认为

00:18:25.440 --> 00:18:31.020
这将非常有用，所以我

00:18:28.650 --> 00:18:33.000
认为这些小东西就足够了

00:18:31.020 --> 00:18:34.530
现有api的新增功能

00:18:33.000 --> 00:18:36.620
看看Java 9和

00:18:34.530 --> 00:18:40.530
列表上的第一个是堆栈扑克

00:18:36.620 --> 00:18:42.360
卡住的扑克让我们容易懒惰， 

00:18:40.530 --> 00:18:44.880
流友好访问堆栈跟踪

00:18:42.360 --> 00:18:47.549
所以在Java 9之前我可以做点什么

00:18:44.880 --> 00:18:50.640
像这样可能有一个fröbel和电话

00:18:47.549 --> 00:18:52.650
获取堆栈跟踪方法和这个

00:18:50.640 --> 00:18:55.950
给我一个堆栈跟踪数组

00:18:52.650 --> 00:19:00.929
元素，所以我在这里打印这是我的

00:18:55.950 --> 00:19:03.179
此时的堆栈跟踪

00:19:00.929 --> 00:19:05.580
这个问题编号有几个问题

00:19:03.179 --> 00:19:07.200
一个，这是相当昂贵的，不是

00:19:05.580 --> 00:19:09.480
不管我是否只有前几个

00:19:07.200 --> 00:19:12.450
框架或

00:19:09.480 --> 00:19:15.780
 JVM一直需要的堆栈跟踪

00:19:12.450 --> 00:19:17.250
急切地捕获整个堆栈

00:19:15.780 --> 00:19:18.220
也没有方便的方法帐号

00:19:17.250 --> 00:19:20.620
轻松过滤

00:19:18.220 --> 00:19:22.450
我可以轻松访问

00:19:20.620 --> 00:19:25.269
类的实际类实例

00:19:22.450 --> 00:19:26.710
声明了方法并在

00:19:25.269 --> 00:19:28.090
我什至不能依靠这个堆栈

00:19:26.710 --> 00:19:30.490
跟踪以完成规格

00:19:28.090 --> 00:19:33.340
说JVM可以省略某些元素

00:19:30.490 --> 00:19:35.169
如果它能帮助提高性能

00:19:33.340 --> 00:19:37.419
这些缺点在

00:19:35.169 --> 00:19:41.470
 Java 9通过称为堆栈的类

00:19:37.419 --> 00:19:43.330
沃克如此卡住沃克实际上是

00:19:41.470 --> 00:19:45.700
相当容易使用，您可以获得

00:19:43.330 --> 00:19:48.820
这里的实例和主要方法

00:19:45.700 --> 00:19:51.360
这是允许我进入的步行

00:19:48.820 --> 00:19:55.350
甲板痕迹作为溪流，所以我可以做

00:19:51.360 --> 00:20:01.350
这样的东西我可以收集

00:19:55.350 --> 00:20:04.450
流并仅使用收集器到列表

00:20:01.350 --> 00:20:05.769
这给了我完整的结构是

00:20:04.450 --> 00:20:08.379
与我们从中获得的非常相似

00:20:05.769 --> 00:20:09.940
 get sectaries方法，但是在此

00:20:08.379 --> 00:20:12.159
情况下，我可以利用所有

00:20:09.940 --> 00:20:13.779
流操作，所以如果我只是

00:20:12.159 --> 00:20:17.610
对那棵树的堆栈跟踪感兴趣

00:20:13.779 --> 00:20:19.450
例如我可以做一个极限树

00:20:17.610 --> 00:20:21.970
这只给了我前三名

00:20:19.450 --> 00:20:25.149
堆栈的元素我也可以轻松地

00:20:21.970 --> 00:20:28.269
可以访问您的类实例

00:20:25.149 --> 00:20:32.529
可以安装堆栈驱动程序以保留

00:20:28.269 --> 00:20:35.440
参考，然后我就去

00:20:32.529 --> 00:20:38.289
在这里删除这个限制

00:20:35.440 --> 00:20:40.330
地图以提取此信息，因此

00:20:38.289 --> 00:20:45.309
我会为每一帧做

00:20:40.330 --> 00:20:47.259
给我宣讲课，这些

00:20:45.309 --> 00:20:50.950
所有涉及堆栈的类

00:20:47.259 --> 00:20:54.090
跟踪，所以真的很好，它是一个

00:20:50.950 --> 00:20:57.340
 Java中非常方便的API 

00:20:54.090 --> 00:20:58.779
我真的很兴奋的另一个API 

00:20:57.340 --> 00:21:00.340
我认为这实际上可能是最

00:20:58.779 --> 00:21:03.490
对我而言Java 9中的功能被低估了

00:21:00.340 --> 00:21:05.830
个人是流程处理API，所以

00:21:03.490 --> 00:21:07.720
新的流程句柄API使我能够

00:21:05.830 --> 00:21:10.330
轻松获取有关流程的信息

00:21:07.720 --> 00:21:12.970
所以我们以前在Java中可用的东西

00:21:10.330 --> 00:21:14.649
 Java 9，因为先生5实际上是

00:21:12.970 --> 00:21:16.360
实现它的流程构建器API 

00:21:14.649 --> 00:21:18.539
非常容易启动外部流程

00:21:16.360 --> 00:21:21.720
所以我可以做这样的事情

00:21:18.539 --> 00:21:25.740
流程建设者

00:21:21.720 --> 00:21:27.179
我忘了关闭这个命令

00:21:25.740 --> 00:21:29.940
说我要列出所有Java 

00:21:27.179 --> 00:21:34.289
我系统中的流程

00:21:29.940 --> 00:21:38.039
 JPS启动，这将启动一个外部

00:21:34.289 --> 00:21:39.840
现在处理JPS的主要限制是

00:21:38.039 --> 00:21:41.100
这个API是我什么也得不到

00:21:39.840 --> 00:21:42.600
关于过程的信息甚至

00:21:41.100 --> 00:21:44.460
非常简单的东西，例如PID 

00:21:42.600 --> 00:21:46.889
在Java 9中可用，但不是

00:21:44.460 --> 00:21:49.049
容易在菜之前进入

00:21:46.889 --> 00:21:51.120
人们最终做的是要么使用

00:21:49.049 --> 00:21:52.889
 jmx真的很hacky，否则他们会

00:21:51.120 --> 00:21:54.570
写他们自己的工具，所以通常你

00:21:52.889 --> 00:21:55.919
会叫PS之类的东西抢

00:21:54.570 --> 00:21:57.509
它实际上将获得

00:21:55.919 --> 00:22:00.029
有关该过程的信息

00:21:57.509 --> 00:22:02.820
外面真的没有必要

00:22:00.029 --> 00:22:04.860
写作乏味，更何况

00:22:02.820 --> 00:22:07.259
可移植性问题，所以真的很棒

00:22:04.860 --> 00:22:11.279
看到这最终解决了

00:22:07.259 --> 00:22:13.649
 JDK，因此JDK 9提供了一个接口

00:22:11.279 --> 00:22:17.460
称为过程句柄，它使我能够

00:22:13.649 --> 00:22:19.019
获得有关

00:22:17.460 --> 00:22:22.470
实际的过程，所以我可以获得一个句柄

00:22:19.019 --> 00:22:26.539
到我当前的流程，在那里我可以

00:22:22.470 --> 00:22:29.070
像这样我很容易提取PID 

00:22:26.539 --> 00:22:30.539
还可以访问各种

00:22:29.070 --> 00:22:33.330
通过信息的其他信息

00:22:30.539 --> 00:22:36.179
界面，您可以看到这给了我

00:22:33.330 --> 00:22:38.159
相当多的东西，还有一种

00:22:36.179 --> 00:22:40.019
一切方便的方法，所以我

00:22:38.159 --> 00:22:43.320
一旦考虑将要使用

00:22:40.019 --> 00:22:45.059
这是很常见的

00:22:43.320 --> 00:22:46.889
本质上告诉您您的Java 

00:22:45.059 --> 00:22:48.659
应用程序已启动，因此

00:22:46.889 --> 00:22:52.309
完整的完整Java命令的所有参数

00:22:48.659 --> 00:22:55.710
一切，这对您真的很有用

00:22:52.309 --> 00:23:01.649
也可以获取有关其他信息

00:22:55.710 --> 00:23:04.679
系统中的进程，因此我可以

00:23:01.649 --> 00:23:06.870
做类似处理所有事情

00:23:04.679 --> 00:23:09.389
给我一个流的过程

00:23:06.870 --> 00:23:14.330
然后我可以从中提取一些信息

00:23:09.389 --> 00:23:18.029
假设每个过程都给我

00:23:14.330 --> 00:23:21.080
信息，然后命令，然后我

00:23:18.029 --> 00:23:21.080
只是要收集这个

00:23:24.270 --> 00:23:30.460
这给了我所有的命令

00:23:27.100 --> 00:23:32.320
在我的系统中运行另一个

00:23:30.460 --> 00:23:35.650
这个API的新功能

00:23:32.320 --> 00:23:37.990
 Java 9是退出方法，它允许

00:23:35.650 --> 00:23:40.540
您本质上触发动作

00:23:37.990 --> 00:23:42.490
当外部流程完成时， 

00:23:40.540 --> 00:23:45.760
那真的很有用，所以让我们尝试

00:23:42.490 --> 00:23:49.710
我将在这里创建一些东西

00:23:45.760 --> 00:23:54.460
运行时间可预测的过程

00:23:49.710 --> 00:23:58.200
例如，让我们打电话入睡

00:23:54.460 --> 00:24:00.610
我要告诉它睡觉三秒钟

00:23:58.200 --> 00:24:03.090
我可以开始这个过程

00:24:00.610 --> 00:24:05.530
立即获得它的句柄

00:24:03.090 --> 00:24:08.080
然后我可以在退出时调用该方法

00:24:05.530 --> 00:24:10.600
这给了我无限的未来

00:24:08.080 --> 00:24:13.030
我们已经看到了可计算的API 

00:24:10.600 --> 00:24:16.720
期货我可以轻松地做点什么

00:24:13.030 --> 00:24:20.800
就像然后接受，我在那里

00:24:16.720 --> 00:24:22.450
打印我可以打印整个过程

00:24:20.800 --> 00:24:24.880
实际上处理两个字符串

00:24:22.450 --> 00:24:26.320
他们实质上是打印PID，因此

00:24:24.880 --> 00:24:28.810
只是概括我的期望

00:24:26.320 --> 00:24:30.790
发生在这里是一个过程开始

00:24:28.810 --> 00:24:33.220
同步然后三秒钟

00:24:30.790 --> 00:24:36.640
稍后，我将看到

00:24:33.220 --> 00:24:40.450
现在已经死了的流程就在这里

00:24:36.640 --> 00:24:43.450
过程开始了，现在我可以看到

00:24:40.450 --> 00:24:45.790
 PID，这真的很有用，我也

00:24:43.450 --> 00:24:48.640
不需要将自己局限于管理

00:24:45.790 --> 00:24:50.770
我可以建立的个别流程

00:24:48.640 --> 00:24:52.650
 UNIX上的整个管道

00:24:50.770 --> 00:24:55.000
管道，这样我就可以表达

00:24:52.650 --> 00:24:56.320
获取第一个过程的输出

00:24:55.000 --> 00:24:58.300
并将其连接到下一个的输入

00:24:56.320 --> 00:25:01.480
过程让我们来演示一下

00:24:58.300 --> 00:25:04.630
很快我就说我要走了

00:25:01.480 --> 00:25:07.060
我所有的Java进程，然后包装

00:25:04.630 --> 00:25:09.370
对于J shell，显然应该是

00:25:07.060 --> 00:25:13.750
在这一点上运行，所以我可以得到我们

00:25:09.370 --> 00:25:17.550
在此处创建流程生成器并使用

00:25:13.750 --> 00:25:20.810
我最喜欢的JPS 

00:25:17.550 --> 00:25:26.040
我会叫它杰克是的， 

00:25:20.810 --> 00:25:33.450
那我就给Collagraph打电话给J 

00:25:26.040 --> 00:25:36.090
外壳，我们称这个grep然后

00:25:33.450 --> 00:25:38.700
我可以将它们作为管道丢弃，这样

00:25:36.090 --> 00:25:40.770
我只是开始做管道，你可以

00:25:38.700 --> 00:25:42.960
看到这需要过程列表

00:25:40.770 --> 00:25:44.340
建设者，所以我可以利用

00:25:42.960 --> 00:25:46.800
这里的便利工厂方法

00:25:44.340 --> 00:25:52.710
我将列出一份JPS， 

00:25:46.800 --> 00:25:57.360
抢，让我们现在叫这个管道

00:25:52.710 --> 00:25:59.640
如果我尝试，这将同步启动

00:25:57.360 --> 00:26:01.410
现在访问它应该完成

00:25:59.640 --> 00:26:05.130
你会看到一切都完成了

00:26:01.410 --> 00:26:07.170
正确地与零返回值，所以

00:26:05.130 --> 00:26:11.010
现在让我们尝试看看我的

00:26:07.170 --> 00:26:13.380
实际上结束了处理，所以我

00:26:11.010 --> 00:26:15.300
将在这里采取管道并获得

00:26:13.380 --> 00:26:18.690
访问列表中的最后一个进程

00:26:15.300 --> 00:26:21.060
这是索引1，然后我将获得

00:26:18.690 --> 00:26:21.390
入口流到

00:26:21.060 --> 00:26:24.260
处理

00:26:21.390 --> 00:26:26.970
我需要做整个Java样板

00:26:24.260 --> 00:26:33.410
循环在这里，所以我就让它

00:26:26.970 --> 00:26:33.410
输入流阅读器，我打错了字

00:26:35.270 --> 00:26:44.010
这样，然后在一个

00:26:38.910 --> 00:26:47.060
 bufferedreader，最后我可以

00:26:44.010 --> 00:26:47.060
使用方法读取行

00:26:48.200 --> 00:26:51.500
到处都是错字

00:26:52.360 --> 00:27:02.470
哦，是的，谢谢，我可以看到

00:27:01.090 --> 00:27:04.570
它使用此PID找到了进程

00:27:02.470 --> 00:27:06.340
称为外壳工具提供程序

00:27:04.570 --> 00:27:09.400
这是实际运行的过程

00:27:06.340 --> 00:27:10.510
通过外壳，这非常好， 

00:27:09.400 --> 00:27:12.190
您可以看到这是多么强大

00:27:10.510 --> 00:27:14.290
 API，这是您不会想要的

00:27:12.190 --> 00:27:15.250
想要实现自己，尤其是在

00:27:14.290 --> 00:27:17.590
一种适用于所有不同方式的方式

00:27:15.250 --> 00:27:21.910
平台，所以真的很高兴看到

00:27:17.590 --> 00:27:23.590
这是JDK的一部分，现在是最后一个

00:27:21.910 --> 00:27:31.059
我想在这里谈论的功能

00:27:23.590 --> 00:27:31.960
是新的客户端和HTTP协议

00:27:31.059 --> 00:27:36.100
最后的问题

00:27:31.960 --> 00:27:37.720
谢谢，所以新的HTTP客户端不仅

00:27:36.100 --> 00:27:40.570
提供了比旧版本更干净的API 

00:27:37.720 --> 00:27:41.890
 HTTP URL连接，但它也支持

00:27:40.570 --> 00:27:44.880
所有很棒的新事物

00:27:41.890 --> 00:27:47.020
它支持HTTP到WebSockets TLS和

00:27:44.880 --> 00:27:50.110
期望服务器推送的一切

00:27:47.020 --> 00:27:54.070
 Cookies代理同步请求

00:27:50.110 --> 00:27:56.169
那种新的HTTP客户端API 

00:27:54.070 --> 00:27:58.480
作为孵化器模块交付

00:27:56.169 --> 00:28:00.280
双子座意味着不是

00:27:58.480 --> 00:28:01.600
完全敲定，不是

00:28:00.280 --> 00:28:03.549
默认情况下已解决，并位于

00:28:01.600 --> 00:28:05.470
特殊名称空间，但我已预先导入

00:28:03.549 --> 00:28:08.530
在这里进入J shell，以便我们可以玩

00:28:05.470 --> 00:28:10.419
现在围绕它来演示

00:28:08.530 --> 00:28:12.429
客户端功能，我需要一个

00:28:10.419 --> 00:28:14.020
服务器，如果有什么

00:28:12.429 --> 00:28:15.460
我们从以前的演示中学到了

00:28:14.020 --> 00:28:17.590
这个会议是你不能依靠

00:28:15.460 --> 00:28:19.210
在这里的互联网上，所以我就去

00:28:17.590 --> 00:28:21.160
用Java在这里写一个非常快速的

00:28:19.210 --> 00:28:22.450
真的很喜欢这个例子

00:28:21.160 --> 00:28:24.910
因为我认为这是

00:28:22.450 --> 00:28:26.260
人们通常认为很难做或

00:28:24.910 --> 00:28:28.809
他们认为这将需要一个

00:28:26.260 --> 00:28:30.280
 Java中的很多代码，但实际上您可以

00:28:28.809 --> 00:28:31.840
轻松创建一个非常简单的服务器

00:28:30.280 --> 00:28:34.030
仅使用

00:28:31.840 --> 00:28:37.120
 JDK及其所有的API 

00:28:34.030 --> 00:28:38.740
周围很长一段时间，所以我会

00:28:37.120 --> 00:28:40.660
只需创建最简单的服务器

00:28:38.740 --> 00:28:43.900
会有一个端点

00:28:40.660 --> 00:28:47.140
只是返回一个固定的字符串，所以让我们

00:28:43.900 --> 00:28:49.840
首先为创建HTTP处理程序

00:28:47.140 --> 00:28:52.450
这个端点，我将其称为

00:28:49.840 --> 00:28:57.070
将采用HTTP的处理程序

00:28:52.450 --> 00:28:58.660
在这里交换为快速lambda，所以我

00:28:57.070 --> 00:29:02.200
将定义我想要的字符串

00:28:58.660 --> 00:29:07.239
用它来称呼它的身体

00:29:02.200 --> 00:29:09.009
您好Java 1，现在我将设置

00:29:07.239 --> 00:29:11.889
我总是去响应头

00:29:09.009 --> 00:29:15.159
以200回应，一切正常

00:29:11.889 --> 00:29:18.879
要附加我的弦的长度

00:29:15.159 --> 00:29:22.059
在这里，最后我会骑弦

00:29:18.879 --> 00:29:26.230
到输出，所以我将打开一个输出

00:29:22.059 --> 00:29:34.330
流在这里，让我们分配响应

00:29:26.230 --> 00:29:37.570
身体在这里，括号太多了

00:29:34.330 --> 00:29:40.480
看起来不错，我将在那里提供

00:29:37.570 --> 00:29:42.399
到这个输出流，我必须做

00:29:40.480 --> 00:29:45.720
通过获取字节，因为这是一个

00:29:42.399 --> 00:29:49.259
旧的API，但可以进行演示

00:29:45.720 --> 00:29:53.409
现在我将关闭所有内容

00:29:49.259 --> 00:29:57.129
太好了，所以如果您在这里看看

00:29:53.409 --> 00:30:00.369
我们的新处理程序看起来还不错，所以我们可以继续

00:29:57.129 --> 00:30:05.109
并尝试启动服务器，所以我要

00:30:00.369 --> 00:30:09.249
在这里创建服务器，这需要一个

00:30:05.109 --> 00:30:12.929
端口，所以我给它说8,000 

00:30:09.249 --> 00:30:17.549
不需要积压，我们称之为

00:30:12.929 --> 00:30:21.580
 HS，然后我将创建终点

00:30:17.549 --> 00:30:24.549
比方说，您好，我会碰

00:30:21.580 --> 00:30:27.220
我现在最喜欢的处理程序

00:30:24.549 --> 00:30:29.590
终于我可以启动服务器了

00:30:27.220 --> 00:30:32.710
希望服务器正在运行并

00:30:29.590 --> 00:30:35.769
测试一下，让我们使用旧的HTTP URL 

00:30:32.710 --> 00:30:38.320
只是看连接API怎么丑

00:30:35.769 --> 00:30:41.109
那是什么，新客户看起来如何

00:30:38.320 --> 00:30:43.570
相比之下，我将从

00:30:41.109 --> 00:30:46.989
在这里定义一个URI 

00:30:43.570 --> 00:30:57.340
到我的本地服务器，所以它是HTTP 

00:30:46.989 --> 00:30:59.350
本地主机8080 RI然后我将转换

00:30:57.340 --> 00:31:02.470
这到一个URL，以便我可以打开一个

00:30:59.350 --> 00:31:04.690
连接在这里，这实际上

00:31:02.470 --> 00:31:06.519
返回您的自动连接，否

00:31:04.690 --> 00:31:08.320
好，我实际上想要HTTP Royal 

00:31:06.519 --> 00:31:09.970
连接，整个API是

00:31:08.320 --> 00:31:12.249
设计时考虑了多种协议

00:31:09.970 --> 00:31:13.929
即使HTTP实际上是

00:31:12.249 --> 00:31:15.620
您只会使用一个

00:31:13.929 --> 00:31:19.970
不幸的是我需要

00:31:15.620 --> 00:31:24.110
这个在这里，所以我只是要做HTTP 

00:31:19.970 --> 00:31:25.370
 URL连接我们称之为C 

00:31:24.110 --> 00:31:28.760
可以看到我才刚开始

00:31:25.370 --> 00:31:31.580
我现在这个API已经很丑了

00:31:28.760 --> 00:31:34.309
可以指定只是请求方法

00:31:31.580 --> 00:31:36.470
将是一个简单的削减，这需要

00:31:34.309 --> 00:31:39.800
再次像字符串一样快地传递

00:31:36.470 --> 00:31:40.720
不太好，不，我们来测试一下

00:31:39.800 --> 00:31:45.260
作品

00:31:40.720 --> 00:31:47.000
那你得到响应码，我可以

00:31:45.260 --> 00:31:49.250
说200看起来很有希望

00:31:47.000 --> 00:31:52.640
因此，让我们尝试读取实际输出

00:31:49.250 --> 00:31:57.140
再一次，我们需要做标准

00:31:52.640 --> 00:32:00.230
 Java样板资料，我将打开我们

00:31:57.140 --> 00:32:02.780
将从我的输入流

00:32:00.230 --> 00:32:07.280
连接在输入流中摩擦

00:32:02.780 --> 00:32:11.530
读者我把这个带进了

00:32:07.280 --> 00:32:15.410
缓冲的阅读器在这里很多样板

00:32:11.530 --> 00:32:19.370
我终于可以读到

00:32:15.410 --> 00:32:20.990
说我想要多少，所以现在很棒

00:32:19.370 --> 00:32:24.080
让我们尝试使用新的HTTP执行此操作

00:32:20.990 --> 00:32:26.090
给客户，所以尽管新的API是

00:32:24.080 --> 00:32:28.460
围绕三个主要类别构建

00:32:26.090 --> 00:32:32.090
有一个HTTP客户端HTTP请求， 

00:32:28.460 --> 00:32:34.600
 HTTP响应相当不言自明，因此

00:32:32.090 --> 00:32:37.880
只是从这里创建客户端开始

00:32:34.600 --> 00:32:41.470
在HTTP客户端中，我们称其为

00:32:37.880 --> 00:32:45.679
客户，然后我将构建请求

00:32:41.470 --> 00:32:48.470
在这里使用构建器模式

00:32:45.679 --> 00:32:52.309
我会请一位建筑商给你

00:32:48.470 --> 00:32:54.260
我之前来自的URI指定

00:32:52.309 --> 00:32:57.429
 get方法作为一种方法，这真的

00:32:54.260 --> 00:33:02.510
好，然后建立它，我们称之为

00:32:57.429 --> 00:33:08.000
请求，然后我最终可以发送

00:33:02.510 --> 00:33:11.179
请求到我的服务器，所以这需要一个

00:33:08.000 --> 00:33:13.730
请求和所谓的身体

00:33:11.179 --> 00:33:15.230
处理程序在这里，我只想告诉它

00:33:13.730 --> 00:33:17.000
在这种情况下，将一切视为

00:33:15.230 --> 00:33:20.450
字符串，并感谢有一个建筑物

00:33:17.000 --> 00:33:22.850
这个的处理程序，所以我会做身体

00:33:20.450 --> 00:33:29.450
处理程序

00:33:22.850 --> 00:33:31.520
一个字符串，我们称这个响应为

00:33:29.450 --> 00:33:33.620
现在我可以轻松地从

00:33:31.520 --> 00:33:39.230
这个回应我就可以回应

00:33:33.620 --> 00:33:39.890
状态码200响应主体您好

00:33:39.230 --> 00:33:42.170
先生们

00:33:39.890 --> 00:33:43.880
真的很好很干净

00:33:42.170 --> 00:33:45.680
如果我想要的话，它也非常灵活

00:33:43.880 --> 00:33:49.400
使这个同步所有我需要的

00:33:45.680 --> 00:33:53.780
要做的就是更改此发送接收器和

00:33:49.400 --> 00:34:02.410
这将返回可完成的未来

00:33:53.780 --> 00:34:06.760
在这里，让我们使用这个等待

00:34:02.410 --> 00:34:06.760
好，再等一次

00:34:08.940 --> 00:34:17.589
我们称之为回应，是的， 

00:34:14.319 --> 00:34:19.059
实际上看起来不错，现在这给

00:34:17.589 --> 00:34:22.270
我有一个可计算的功能，我们已经看到了

00:34:19.059 --> 00:34:26.679
之前的API，所以我可以将其称为cat和

00:34:22.270 --> 00:34:30.579
然后身体就在这里

00:34:26.679 --> 00:34:32.919
所有这一切真的很好，他们也

00:34:30.579 --> 00:34:34.659
对TLS的处理非常好

00:34:32.919 --> 00:34:36.819
这超出了本演讲的范围

00:34:34.659 --> 00:34:40.210
但您可以做各种各样的事情，例如

00:34:36.819 --> 00:34:42.970
管理证书以及您的全部

00:34:40.210 --> 00:34:44.980
知道非常好的方法，基本上

00:34:42.970 --> 00:34:47.980
这是我最喜欢的概述

00:34:44.980 --> 00:34:48.760
 API是Java 9中的API，所以希望您能找到

00:34:47.980 --> 00:34:50.919
这个有趣

00:34:48.760 --> 00:34:52.929
我们走之前，因为我没有任何东西

00:34:50.919 --> 00:34:55.450
幻灯片，我将只保存此会话

00:34:52.929 --> 00:35:01.540
将此会话的历史记录保存到

00:34:55.450 --> 00:35:02.859
文件说备份J Shell，我可以

00:35:01.540 --> 00:35:05.589
如果您想稍后发布此视频

00:35:02.859 --> 00:35:10.150
回到这些例子中， 

00:35:05.589 --> 00:35:11.619
差不多了，所以我们接近

00:35:10.150 --> 00:35:13.480
时间用完了，但我们有一些

00:35:11.619 --> 00:35:15.760
是时候提问了，但无论如何

00:35:13.480 --> 00:35:19.170
一直待到下一个谈话开始，所以

00:35:15.760 --> 00:35:23.769
谢谢你，喜欢台湾其他地区

00:35:19.170 --> 00:35:23.769
 [掌声] 

