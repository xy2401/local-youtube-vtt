WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.149 --> 00:00:08.549
非常感谢您参加

00:00:06.059 --> 00:00:10.260
演讲还不及早

00:00:08.549 --> 00:00:11.730
斯图尔特的演讲实际上早些时候

00:00:10.260 --> 00:00:13.589
奇怪的是有多少人

00:00:11.730 --> 00:00:16.169
斯图尔特今天早些时候的演讲

00:00:13.589 --> 00:00:20.610
好吧，所以我们可以比较笔记

00:00:16.169 --> 00:00:23.700
之后好吧，所以有

00:00:20.610 --> 00:00:25.529
强制性法律声明，我是什么

00:00:23.700 --> 00:00:28.050
今天要谈论今天，所以我

00:00:25.529 --> 00:00:30.750
要回顾一下

00:00:28.050 --> 00:00:32.570
 JDK中无法修改的集合

00:00:30.750 --> 00:00:35.899
说我们现在有什么

00:00:32.570 --> 00:00:38.760
我将简要概述

00:00:35.899 --> 00:00:43.170
外部Java中的不可变集合

00:00:38.760 --> 00:00:44.730
库和基于JVM的平台以及

00:00:43.170 --> 00:00:46.679
那我要谈一谈不可变

00:00:44.730 --> 00:00:48.600
利用持久数据进行收集

00:00:46.679 --> 00:00:51.570
结构，所以当我指的是

00:00:48.600 --> 00:00:54.269
持久性我不是说数据库在

00:00:51.570 --> 00:00:55.890
任何方式或坚持

00:00:54.269 --> 00:00:58.079
非易失性存储器或任何这些

00:00:55.890 --> 00:00:59.940
事情这是一个非常令人困惑的术语，但是

00:00:58.079 --> 00:01:02.339
持久性有时更容易

00:00:59.940 --> 00:01:04.650
当人们理解时，了解比不改变

00:01:02.339 --> 00:01:06.450
听到易变和一成不变，他们

00:01:04.650 --> 00:01:07.920
不能区分两者，所以

00:01:06.450 --> 00:01:09.630
有时人们称这些为

00:01:07.920 --> 00:01:14.790
持久性集合而不是持久性集合

00:01:09.630 --> 00:01:16.410
不可变的集合，所以当我提到

00:01:14.790 --> 00:01:18.540
我正在做的这些不可变的收藏

00:01:16.410 --> 00:01:20.730
没有任何关于

00:01:18.540 --> 00:01:23.100
集合元素的不变性

00:01:20.730 --> 00:01:26.100
所以我不是在谈论不可变性

00:01:23.100 --> 00:01:27.990
语言或强迫的大

00:01:26.100 --> 00:01:29.580
永恒不变

00:01:27.990 --> 00:01:30.930
这些结构我只是在说

00:01:29.580 --> 00:01:33.630
关于收集结构

00:01:30.930 --> 00:01:35.730
本身，这是一个巨大的自行车棚

00:01:33.630 --> 00:01:37.740
你可以谈论这个几个月

00:01:35.730 --> 00:01:40.230
几个月又几个月，所以我只是

00:01:37.740 --> 00:01:42.210
试图安排一些封闭

00:01:40.230 --> 00:01:47.550
为此仅在两个集合中

00:01:42.210 --> 00:01:50.670
这个演讲有很多

00:01:47.550 --> 00:01:53.430
我认为优势是一成不变的

00:01:50.670 --> 00:01:55.290
最适合我的是如果我不这样做

00:01:53.430 --> 00:01:57.300
必须考虑数据竞赛者，我是

00:01:55.290 --> 00:02:00.600
快乐的人，如果我必须考虑

00:01:57.300 --> 00:02:02.670
数据赛车手我很头疼

00:02:00.600 --> 00:02:04.620
你正在处理并发的东西

00:02:02.670 --> 00:02:07.290
你知道你在处理什么

00:02:04.620 --> 00:02:09.239
是一成不变的，您可以放心地相信

00:02:07.290 --> 00:02:11.069
你可以理解，那是一个

00:02:09.239 --> 00:02:12.540
更清晰，但必须处理

00:02:11.069 --> 00:02:14.330
有时是数据竞赛和

00:02:12.540 --> 00:02:17.210
头痛和调试实际上

00:02:14.330 --> 00:02:19.340
那是一个巨大的优势

00:02:17.210 --> 00:02:22.940
如果你有他们一成不变的东西

00:02:19.340 --> 00:02:24.680
并且相信你一成不变

00:02:22.940 --> 00:02:27.230
别无他物

00:02:24.680 --> 00:02:29.960
故意或恶意

00:02:27.230 --> 00:02:32.890
意外，这是一个很好的财产

00:02:29.960 --> 00:02:35.990
好吧，如果您正在使用的图书馆

00:02:32.890 --> 00:02:40.400
使用您知道的这些数据结构

00:02:35.990 --> 00:02:41.840
可以信任这个图书馆，他们有一个

00:02:40.400 --> 00:02:43.640
一堆属性

00:02:41.840 --> 00:02:46.100
优化它们是有效的

00:02:43.640 --> 00:02:48.080
常数，因此

00:02:46.100 --> 00:02:50.900
拉贾运行时间的机会

00:02:48.080 --> 00:02:53.000
热点来优化这些东西

00:02:50.900 --> 00:02:56.150
将它们视为符合常量的常量，我们

00:02:53.000 --> 00:02:59.330
当生成时不断折叠它们

00:02:56.150 --> 00:03:02.030
热点会产生热点

00:02:59.330 --> 00:03:03.380
经过优化的代码，它们也是

00:03:02.030 --> 00:03:06.020
具有可以优化的属性

00:03:03.380 --> 00:03:07.790
 Java实现中的这些东西

00:03:06.020 --> 00:03:09.170
如果你有一个小的空间和时间

00:03:07.790 --> 00:03:11.390
您可以选择使用

00:03:09.170 --> 00:03:14.750
不同的数据结构，如果有

00:03:11.390 --> 00:03:16.610
大量收藏，斯图尔特·马克思做了

00:03:14.750 --> 00:03:20.930
这些优化中的一些

00:03:16.610 --> 00:03:23.000
他的收藏列出了地图集

00:03:20.930 --> 00:03:25.550
较小收藏的桌子更多

00:03:23.000 --> 00:03:28.280
优化它们节省了权衡

00:03:25.550 --> 00:03:30.350
一些空间和时间，你可以做

00:03:28.280 --> 00:03:34.390
这些技巧，即使你

00:03:30.350 --> 00:03:37.610
具有不变性和您的收藏

00:03:34.390 --> 00:03:39.080
所以这是我一成不变的愿望清单

00:03:37.610 --> 00:03:41.540
收藏，如果我要这样做

00:03:39.080 --> 00:03:44.239
在JDK中，这不是吗？ 

00:03:41.540 --> 00:03:45.739
致力于在JDK中做到这一点，但

00:03:44.239 --> 00:03:48.380
如果我要去做的话

00:03:45.739 --> 00:03:50.780
这就是我的愿望清单，所以我

00:03:48.380 --> 00:03:52.580
认为我的第一个是

00:03:50.780 --> 00:03:54.920
使用不可变的集合进行编码

00:03:52.580 --> 00:03:56.630
希望看到我输入的类型名称

00:03:54.920 --> 00:03:59.720
想在API中看到它，所以当我

00:03:56.630 --> 00:04:01.060
阅读代码，我知道这件事是

00:03:59.720 --> 00:04:04.700
不变的，我必须区别对待

00:04:01.060 --> 00:04:06.980
说出列表或地图是否可变

00:04:04.700 --> 00:04:08.570
列表或可变的地图我可以治疗

00:04:06.980 --> 00:04:11.780
我知道它有不同的地方

00:04:08.570 --> 00:04:13.190
我知道我必须考虑这个API 

00:04:11.780 --> 00:04:14.900
我使用的方式略有不同

00:04:13.190 --> 00:04:16.910
我的算法或我开发我的算法

00:04:14.900 --> 00:04:21.380
算法顺带有人

00:04:16.910 --> 00:04:24.770
完全关闭编程

00:04:21.380 --> 00:04:26.870
这有点弯腰，因为它

00:04:24.770 --> 00:04:27.520
在大多数情况下完全是一张新桌子

00:04:26.870 --> 00:04:29.169
和

00:04:27.520 --> 00:04:32.710
首先，如果

00:04:29.169 --> 00:04:35.530
你习惯了静音可变的方式

00:04:32.710 --> 00:04:38.500
以一种优美的方式编码您的

00:04:35.530 --> 00:04:40.360
算法趋于改变，我认为

00:04:38.500 --> 00:04:42.160
这是值得实际尝试的

00:04:40.360 --> 00:04:44.740
使用Clojure和Haskell等语言

00:04:42.160 --> 00:04:48.460
看看如何在不可变的代码

00:04:44.740 --> 00:04:50.229
方式，而不是不变的方式或pyth 

00:04:48.460 --> 00:04:55.870
它确实改变了您的思维方式

00:04:50.229 --> 00:04:58.330
我认为有时候这些收藏

00:04:55.870 --> 00:05:01.810
应该被密封，我的意思是

00:04:58.330 --> 00:05:04.720
只有受信任的各方才能真正

00:05:01.810 --> 00:05:06.520
扩展这些集合，这样我就不会

00:05:04.720 --> 00:05:08.050
想让其他人扩展我的阿努

00:05:06.520 --> 00:05:09.880
元组列表，因为我不信任他们

00:05:08.050 --> 00:05:11.979
我不相信他们做得很好

00:05:09.880 --> 00:05:14.229
也不要相信他们，因为他们是

00:05:11.979 --> 00:05:16.660
有黑帽子或白帽子

00:05:14.229 --> 00:05:18.039
根据他们的动机是

00:05:16.660 --> 00:05:19.960
因为他们犯了我们的错误

00:05:18.039 --> 00:05:21.970
这与我们在JDK中的收藏

00:05:19.960 --> 00:05:24.280
他们是开放的，我们必须写

00:05:21.970 --> 00:05:26.229
防御代码不正确

00:05:24.280 --> 00:05:28.389
扩展了收藏的人

00:05:26.229 --> 00:05:30.069
 ArrayList人们扩展了hashmap 

00:05:28.389 --> 00:05:32.050
诸如此类，我们不

00:05:30.069 --> 00:05:33.849
一定做我想做的正确的事

00:05:32.050 --> 00:05:36.430
需要关闭，只有我们可以

00:05:33.849 --> 00:05:39.970
实施它们，然后我们可以保证

00:05:36.430 --> 00:05:41.830
这些东西的永恒性

00:05:39.970 --> 00:05:43.900
像他们一样为

00:05:41.830 --> 00:05:47.050
可变集合，因此您必须选择

00:05:43.900 --> 00:05:50.830
在列表或可变列表中说

00:05:47.050 --> 00:05:52.750
而不是从列表扩展

00:05:50.830 --> 00:05:54.610
从列表扩展，然后您可以轻松地

00:05:52.750 --> 00:05:56.590
将其传递给可以接受的东西

00:05:54.610 --> 00:05:58.599
列表，然后它变成了旧的

00:05:56.590 --> 00:06:00.520
可变收藏品世界

00:05:58.599 --> 00:06:02.409
您可以在其中进行操作并执行

00:06:00.520 --> 00:06:03.580
变异操作异常

00:06:02.409 --> 00:06:05.949
不想我想明确

00:06:03.580 --> 00:06:07.780
代码中的某些内容

00:06:05.949 --> 00:06:09.039
可变列表或类似的东西

00:06:07.780 --> 00:06:12.520
真正知道您何时过渡

00:06:09.039 --> 00:06:14.650
从不变到可变

00:06:12.520 --> 00:06:17.349
我想要高效的建筑

00:06:14.650 --> 00:06:19.870
更新和复制，所以如果我有一个新的

00:06:17.349 --> 00:06:21.729
到列表中，然后向其中添加元素

00:06:19.870 --> 00:06:24.070
想要一个新的可变列表，但不知何故

00:06:21.729 --> 00:06:26.469
它的下面有一些结构

00:06:24.070 --> 00:06:28.479
在上一个集合和

00:06:26.469 --> 00:06:30.909
新的收藏，所以我们可以节省一些空间

00:06:28.479 --> 00:06:32.620
也许要权衡一些时间并节省一些

00:06:30.909 --> 00:06:34.659
空间，但我们得到结构共享

00:06:32.620 --> 00:06:36.849
在下面，我们可以做高效的表格

00:06:34.659 --> 00:06:39.610
复制我想要一种构建这些的方法

00:06:36.849 --> 00:06:40.330
以有限的可变方式收集

00:06:39.610 --> 00:06:44.710
接着

00:06:40.330 --> 00:06:46.449
冻结，然后说你一成不变的我可能

00:06:44.710 --> 00:06:48.340
忘记时间给你看一些东西

00:06:46.449 --> 00:06:50.110
我们在那里做，那是我的

00:06:48.340 --> 00:06:52.090
愿望清单，我想你可以形容

00:06:50.110 --> 00:06:56.979
如果我们将其正式化，将它们作为目标

00:06:52.090 --> 00:06:58.930
还有更多，我们在JDK中得到了什么

00:06:56.979 --> 00:07:00.819
 JDK有一个不可修改的概念

00:06:58.930 --> 00:07:04.210
每个人都知道它们是什么

00:07:00.819 --> 00:07:06.370
你以前用过这些东西

00:07:04.210 --> 00:07:09.099
不可修改的是

00:07:06.370 --> 00:07:11.590
集合，所以如果你有一个

00:07:09.099 --> 00:07:15.219
不可修改的集合

00:07:11.590 --> 00:07:17.379
诸如add put remove throw之类的方法

00:07:15.219 --> 00:07:19.750
不支持的操作异常和

00:07:17.379 --> 00:07:21.639
没有办法直接查询这个

00:07:19.750 --> 00:07:23.469
你可能会问为什么要

00:07:21.639 --> 00:07:24.879
直接查询它，您可能想要

00:07:23.469 --> 00:07:26.710
知道是否需要复印

00:07:24.879 --> 00:07:29.379
如果您有清单，您怎么知道

00:07:26.710 --> 00:07:31.360
这是无法修改的，你可以做一个

00:07:29.379 --> 00:07:33.099
的实例，然后看一些

00:07:31.360 --> 00:07:35.289
内部JDK更正，但我不会

00:07:33.099 --> 00:07:37.300
建议，如果我们想添加一个

00:07:35.289 --> 00:07:39.159
高效的复制方法到我们的JDK 

00:07:37.300 --> 00:07:40.810
不能真正做到这一点，让第三

00:07:39.159 --> 00:07:41.289
各方选择是否要加入

00:07:40.810 --> 00:07:43.629
进入那个

00:07:41.289 --> 00:07:48.310
例如，不可修改的视图

00:07:43.629 --> 00:07:51.159
番石榴，我稍后再讲

00:07:48.310 --> 00:07:53.169
非修饰符，您的包装器本质上是

00:07:51.159 --> 00:07:55.150
支持集合的来源，因此您

00:07:53.169 --> 00:07:57.789
你们都已经完成了这个收藏

00:07:55.150 --> 00:08:00.580
修改列表来源列表，以便

00:07:57.789 --> 00:08:02.560
源列表被修改，它将是

00:08:00.580 --> 00:08:04.479
也反映在您的包装中

00:08:02.560 --> 00:08:06.909
它们并不是真正不变的东西

00:08:04.479 --> 00:08:09.969
这就是你所得到的

00:08:06.909 --> 00:08:11.860
背面是您无法修改的视图

00:08:09.969 --> 00:08:14.889
来源，您可以直接拥有

00:08:11.860 --> 00:08:17.319
列表也无法修改

00:08:14.889 --> 00:08:19.810
如果你那里没有资料

00:08:17.319 --> 00:08:21.969
你可以观察或看到你只是

00:08:19.810 --> 00:08:23.620
创建一个像

00:08:21.969 --> 00:08:25.150
语言集合文字和

00:08:23.620 --> 00:08:29.349
您将获得一个无法修改的列表

00:08:25.150 --> 00:08:31.449
回来，那么你如何获得不变性

00:08:29.349 --> 00:08:35.770
这些事情通常你要做的是

00:08:31.449 --> 00:08:37.120
你做了你无法修改的清单

00:08:35.770 --> 00:08:39.159
因为你不知道在哪里

00:08:37.120 --> 00:08:41.320
来源无法修改，或者您没有

00:08:39.159 --> 00:08:43.209
克隆一个副本然后包裹

00:08:41.320 --> 00:08:45.339
它，然后你扔掉我的来源

00:08:43.209 --> 00:08:47.260
不想提及，因为我

00:08:45.339 --> 00:08:50.889
不，我不想知道那是什么

00:08:47.260 --> 00:08:54.999
我不想在

00:08:50.889 --> 00:08:57.459
或另一种方法是使用

00:08:54.999 --> 00:09:00.609
流，因此您可以使用颜色收集

00:08:57.459 --> 00:09:02.049
然后收集少于两个的包裹

00:09:00.609 --> 00:09:04.329
它在列表中，我扔掉了

00:09:02.049 --> 00:09:05.679
源隐含在这里，所以不是

00:09:04.329 --> 00:09:06.369
将会被外界参考

00:09:05.679 --> 00:09:08.769
不再

00:09:06.369 --> 00:09:11.049
当然还有和的列表是

00:09:08.769 --> 00:09:12.519
如果源永远无法访问，那么

00:09:11.049 --> 00:09:14.319
我就是这样描述一个

00:09:12.519 --> 00:09:16.089
可修改的收藏给我自己和你

00:09:14.319 --> 00:09:17.919
如果你想的话，必须跳过篮球

00:09:16.089 --> 00:09:18.970
得到一些不变的东西

00:09:17.919 --> 00:09:20.619
你知道一成不变，但事实并非如此

00:09:18.970 --> 00:09:23.949
反映在类型系统中等等

00:09:20.619 --> 00:09:25.899
这样的话，所以如果我回到我的

00:09:23.949 --> 00:09:27.639
愿望清单，看看JDK 

00:09:25.899 --> 00:09:31.209
集合，但他们做得并不好

00:09:27.639 --> 00:09:33.639
好吧，这里没有类型来表示

00:09:31.209 --> 00:09:36.449
你有一个不变的东西

00:09:33.639 --> 00:09:38.499
没有密封就可以打开

00:09:36.449 --> 00:09:40.329
在重言式上，它为

00:09:38.499 --> 00:09:41.859
本身，实际上没有任何东西

00:09:40.329 --> 00:09:43.899
高效的施工更新和

00:09:41.859 --> 00:09:45.249
复制，如果你有一个列表，你想

00:09:43.899 --> 00:09:47.769
确保没有人在上面涂鸦

00:09:45.249 --> 00:09:49.359
你必须要复印，如果你想

00:09:47.769 --> 00:09:50.919
确保没有人在上面涂鸦

00:09:49.359 --> 00:09:52.569
当您退还它时，您甚至会复制一份

00:09:50.919 --> 00:09:54.129
你把它包裹起来并把源保存到

00:09:52.569 --> 00:09:58.389
紧紧地绑住自己，这样没人能得到

00:09:54.129 --> 00:10:00.399
所以我认为没有修改

00:09:58.389 --> 00:10:03.339
合理的提取抽象

00:10:00.399 --> 00:10:05.860
可变的集合，但不是真的

00:10:03.339 --> 00:10:07.480
有益于一成不变，对不起，我说

00:10:05.860 --> 00:10:09.249
可变或不变的，我要解决

00:10:07.480 --> 00:10:11.410
很好的可变性抽象

00:10:09.249 --> 00:10:14.019
集合，但并非一成不变

00:10:11.410 --> 00:10:15.399
那里的收藏将是我的

00:10:14.019 --> 00:10:18.429
论据并不意味着我们不应该

00:10:15.399 --> 00:10:19.869
在JDK中改进了这个概念，但是我

00:10:18.429 --> 00:10:21.639
想想如果你想真正地

00:10:19.869 --> 00:10:25.089
我们必须拥有的不可变集合

00:10:21.639 --> 00:10:26.860
别的东西，番石榴怎么办

00:10:25.089 --> 00:10:29.290
任何人都可以使用不可变的集合

00:10:26.860 --> 00:10:30.959
番石榴的收藏，他们真的很

00:10:29.290 --> 00:10:33.879
流行的精心设计

00:10:30.959 --> 00:10:35.769
所以番石榴有很多密封类型

00:10:33.879 --> 00:10:38.049
例如可变列表和可变映射

00:10:35.769 --> 00:10:41.110
这些实现了我们相应的

00:10:38.049 --> 00:10:44.470
 JDK可变集合类型是可变的

00:10:41.110 --> 00:10:48.519
 list实现列表，复制是

00:10:44.470 --> 00:10:50.049
有点聪明，它知道副本是否

00:10:48.519 --> 00:10:51.879
带您去收集，它将

00:10:50.049 --> 00:10:54.009
知道这是否是一成不变的清单

00:10:51.879 --> 00:10:56.889
是否自己的，决定退货

00:10:54.009 --> 00:10:57.959
退回或复印，从某种意义上讲

00:10:56.889 --> 00:10:59.529
有点聪明

00:10:57.959 --> 00:11:01.720
而当我们在做

00:10:59.529 --> 00:11:02.860
无法修改的案例，或者我们在JDK中

00:11:01.720 --> 00:11:06.029
没有这些东西，我们必须编程

00:11:02.860 --> 00:11:06.029
防守并起飞

00:11:06.690 --> 00:11:11.740
所以我会说这是不变的

00:11:09.550 --> 00:11:14.980
它是密封的，没有提供桥梁

00:11:11.740 --> 00:11:17.110
所以你不会明确选择加入酱汁

00:11:14.980 --> 00:11:18.730
因为它扩展了您可以通过的列表

00:11:17.110 --> 00:11:21.820
它周围的东西可以接受清单

00:11:18.730 --> 00:11:23.290
我不喜欢我更喜欢露骨

00:11:21.820 --> 00:11:25.779
选择加入以了解您正在过渡

00:11:23.290 --> 00:11:27.070
在两者之间，所以有点像

00:11:25.779 --> 00:11:30.190
当您弹出列表时，您在

00:11:27.070 --> 00:11:32.560
不可修改的世界再次

00:11:30.190 --> 00:11:34.330
提供有效的完成复制

00:11:32.560 --> 00:11:38.140
通过一些有效的建设

00:11:34.330 --> 00:11:41.950
建筑商，但这不是我想要的

00:11:38.140 --> 00:11:43.779
他们是一个很好的折衷他们

00:11:41.950 --> 00:11:46.410
与他们有一些好的特性，但

00:11:43.779 --> 00:11:48.730
对我来说还远远不够

00:11:46.410 --> 00:11:50.260
有日食收藏有多少

00:11:48.730 --> 00:11:53.740
以前用过这些

00:11:50.260 --> 00:11:56.020
高盛收藏这是我

00:11:53.740 --> 00:11:58.720
被描述为每个人的东西

00:11:56.020 --> 00:12:01.690
各种的聚宝盆

00:11:58.720 --> 00:12:03.279
那里的收藏，你可能会发现

00:12:01.690 --> 00:12:05.860
在这种情况下非常有用的东西

00:12:03.279 --> 00:12:07.779
进行这些类型的收藏

00:12:05.860 --> 00:12:09.279
我在这里看过的我不是

00:12:07.779 --> 00:12:11.320
这些收藏的专家

00:12:09.279 --> 00:12:13.779
表现出不可变性

00:12:11.320 --> 00:12:15.610
密封，他们确实提供了一座桥梁

00:12:13.779 --> 00:12:17.830
据我所知，他们有相似的

00:12:15.610 --> 00:12:19.420
番石榴的问题

00:12:17.830 --> 00:12:24.250
高效的建筑更新

00:12:19.420 --> 00:12:25.990
复制，所以如果我以前看过Vava 

00:12:24.250 --> 00:12:30.630
有人叫Java lang语

00:12:25.990 --> 00:12:34.360
不错的功能库关闭

00:12:30.630 --> 00:12:37.330
斯卡拉也可能是科特林，但我不是

00:12:34.360 --> 00:12:39.850
熟悉加泰罗尼亚语，我认为这些勾

00:12:37.330 --> 00:12:41.770
所有方框所有目标或愿望清单

00:12:39.850 --> 00:12:43.959
我经常看到他们

00:12:41.770 --> 00:12:46.150
他们被密封的可变性提供了

00:12:43.959 --> 00:12:48.190
桥梁，他们还提供其他

00:12:46.150 --> 00:12:50.170
施工更新和复制我

00:12:48.190 --> 00:12:52.329
尚未完全验证，但这是

00:12:50.170 --> 00:12:56.860
我的直觉在这里以及这些

00:12:52.329 --> 00:12:58.750
提供，让我们仔细看看

00:12:56.860 --> 00:12:59.380
高效的更新，这是怎么回事

00:12:58.750 --> 00:13:02.440
在这

00:12:59.380 --> 00:13:04.810
所有这些收藏中的一些

00:13:02.440 --> 00:13:06.790
集合v的库或平台

00:13:04.810 --> 00:13:09.760
提供杠杆作用

00:13:06.790 --> 00:13:12.520
持久性数据结构

00:13:09.760 --> 00:13:14.230
对于地图集和向量，向量不是

00:13:12.520 --> 00:13:17.120
链接列表，它们不是Java util 

00:13:14.230 --> 00:13:19.730
应弃用的向量

00:13:17.120 --> 00:13:22.600
可能永远不会删除

00:13:19.730 --> 00:13:26.540
已弃用Stewart no no yeah 

00:13:22.600 --> 00:13:28.490
哈希表也一样，所以他们

00:13:26.540 --> 00:13:31.160
他们利用所谓的东西，我们

00:13:28.490 --> 00:13:34.610
调用持久性数据结构

00:13:31.160 --> 00:13:35.660
是一个持久的数据结构，所以不存在

00:13:34.610 --> 00:13:37.550
数据结构是

00:13:35.660 --> 00:13:39.740
保留自身的先前版本

00:13:37.550 --> 00:13:41.240
现在修改的地方，您可以轻松编写

00:13:39.740 --> 00:13:42.790
您自己的持久性直接数据

00:13:41.240 --> 00:13:45.080
通过写时复制结构

00:13:42.790 --> 00:13:46.550
那将是非常低效的， 

00:13:45.080 --> 00:13:49.279
这就是我们今天要做的代码

00:13:46.550 --> 00:13:51.050
在JDK中进行防御，但是这些

00:13:49.279 --> 00:13:54.050
持久数据结构是否全部

00:13:51.050 --> 00:13:56.480
在下面有一个共同的主题

00:13:54.050 --> 00:13:58.850
这就是所谓的哈希数组映射尝试或

00:13:56.480 --> 00:14:01.670
火腿短时间戏弄，他们是

00:13:58.850 --> 00:14:04.670
有效持久不变的基础

00:14:01.670 --> 00:14:09.920
地图集和向量，所以我认为它们使用

00:14:04.670 --> 00:14:13.160
由菲尔·巴格韦（Philip Bagwell）率先开发

00:14:09.920 --> 00:14:16.430
在Scala工作并在

00:14:13.160 --> 00:14:18.020
 Typesafe和我认为像Bend和

00:14:16.430 --> 00:14:19.970
她现在去世了，但我想

00:14:18.020 --> 00:14:22.160
他他开创了其中一些

00:14:19.970 --> 00:14:25.940
 Scala中的实现和设计

00:14:22.160 --> 00:14:28.220
首先，这些的好处是

00:14:25.940 --> 00:14:30.080
这些使您能够提供结构

00:14:28.220 --> 00:14:32.209
新旧共享

00:14:30.080 --> 00:14:33.589
集合的版本，因此他们改为

00:14:32.209 --> 00:14:36.080
拿东西的整个副本

00:14:33.589 --> 00:14:37.730
您只复制了

00:14:36.080 --> 00:14:39.560
您需要进行更改，然后就可以

00:14:37.730 --> 00:14:41.209
共享其他位，因为

00:14:39.560 --> 00:14:44.270
不可变，你知道那些其他的位

00:14:41.209 --> 00:14:46.730
不会被修改，他们是

00:14:44.270 --> 00:14:48.440
有效地恒定时间

00:14:46.730 --> 00:14:51.020
恒定时间的摆动空间

00:14:48.440 --> 00:14:52.370
对于许多操作，他们可以

00:14:51.020 --> 00:14:54.170
缓存友好，所以如果你是

00:14:52.370 --> 00:14:57.709
遍历他们，你经常

00:14:54.170 --> 00:15:00.589
从缓存中预取东西等等

00:14:57.709 --> 00:15:02.810
你会得到很好的表现，他们不会

00:15:00.589 --> 00:15:05.630
击败诸如射线列表ArrayList之类的东西

00:15:02.810 --> 00:15:07.970
该死的很难击败，但他们要权衡

00:15:05.630 --> 00:15:12.560
一些结构的性能

00:15:07.970 --> 00:15:15.529
分享，那么这的基础是什么

00:15:12.560 --> 00:15:17.779
你知道我复制了三棵树吗

00:15:15.529 --> 00:15:20.270
这个来自维基百科，所以你可以去

00:15:17.779 --> 00:15:22.010
如果您愿意的话，可以使用维基百科页面

00:15:20.270 --> 00:15:24.380
这是一个三叉树的例子

00:15:22.010 --> 00:15:26.180
三叉树基本上存储了

00:15:24.380 --> 00:15:28.490
按键（如果正在制作地图） 

00:15:26.180 --> 00:15:31.190
在每个节点中存储一些密钥

00:15:28.490 --> 00:15:34.399
你下去，所以如果在这里的例子

00:15:31.190 --> 00:15:36.830
您已经尝试过琴键Tedti 10 

00:15:34.399 --> 00:15:39.589
我在里面然后在数字

00:15:36.830 --> 00:15:41.959
值，因此您基本上遍历了

00:15:39.589 --> 00:15:44.360
树说好吧，我去这个节点

00:15:41.959 --> 00:15:46.190
哦，我去了两个等等

00:15:44.360 --> 00:15:48.170
那，你需要存储一个前缀

00:15:46.190 --> 00:15:50.480
您的树中所有钥匙的钥匙

00:15:48.170 --> 00:15:51.770
您实际拥有的条目

00:15:50.480 --> 00:15:54.529
相当可以

00:15:51.770 --> 00:15:56.540
高效的机制和数据结构

00:15:54.529 --> 00:15:57.860
通常是这类数据结构

00:15:56.540 --> 00:15:59.930
键入时使用

00:15:57.860 --> 00:16:02.420
里面有东西，你做单词补全

00:15:59.930 --> 00:16:04.910
您可能在下面尝试

00:16:02.420 --> 00:16:07.459
做选择您可能的单词

00:16:04.910 --> 00:16:09.260
可能想完成反对

00:16:07.459 --> 00:16:11.060
本质上是一个尝试，你有一个你

00:16:09.260 --> 00:16:15.370
这里有一个字母，我们有

00:16:11.060 --> 00:16:17.899
字母A到Z小写和大写

00:16:15.370 --> 00:16:19.550
你有一个字符串和一个字符串

00:16:17.899 --> 00:16:22.399
案件将不受限制，因为它将

00:16:19.550 --> 00:16:25.190
只是一个字，但我们可以使用相同的

00:16:22.399 --> 00:16:27.529
哈希数组映射中的技术尝试这样

00:16:25.190 --> 00:16:29.149
哈希或地图尝试本质上是

00:16:27.529 --> 00:16:30.740
用符号代替字母

00:16:29.149 --> 00:16:33.170
字母，你可以说这是一个符号

00:16:30.740 --> 00:16:35.930
五位序列只是一个数字

00:16:33.170 --> 00:16:38.690
从零到31，你可以说

00:16:35.930 --> 00:16:40.730
字符串的长度固定为32 

00:16:38.690 --> 00:16:43.130
由七个符号和

00:16:40.730 --> 00:16:45.709
只是最后一个符号被截断了

00:16:43.130 --> 00:16:47.570
到两位，所以字符串在哈希中

00:16:45.709 --> 00:16:50.089
数组映射tri本质上是哈希

00:16:47.570 --> 00:16:52.160
对象的代码是关键

00:16:50.089 --> 00:16:55.579
我们正在横向转换一个

00:16:52.160 --> 00:16:57.350
域为32位字符串并切碎

00:16:55.579 --> 00:17:00.770
它变成了一些符号， 

00:16:57.350 --> 00:17:03.670
这是我们字母表中的一种符号

00:17:00.770 --> 00:17:07.400
字符串长度固定

00:17:03.670 --> 00:17:12.470
如果这里有一个例子，那么说我们

00:17:07.400 --> 00:17:15.079
这里有一个咖啡馆婴儿的哈希码等等

00:17:12.470 --> 00:17:18.140
我们的符号将从右到右

00:17:15.079 --> 00:17:20.420
左符号将是前五个

00:17:18.140 --> 00:17:22.670
位符号二将是下一个五

00:17:20.420 --> 00:17:24.400
等等等等，所以我们

00:17:22.670 --> 00:17:27.559
最多七个符号

00:17:24.400 --> 00:17:29.450
本质上是六棵树

00:17:27.559 --> 00:17:33.380
知道你在做什么

00:17:29.450 --> 00:17:36.180
从每个哈希码中减去五位

00:17:33.380 --> 00:17:38.850
所以本质上我们有广泛的分支

00:17:36.180 --> 00:17:42.600
这里的因素，所以我们每个节点

00:17:38.850 --> 00:17:44.610
树，而不是如果我们回到这里

00:17:42.600 --> 00:17:47.580
树每个节点没有分支

00:17:44.610 --> 00:17:49.980
因数32 

00:17:47.580 --> 00:17:51.480
 6的深度，因此实际上可以控制

00:17:49.980 --> 00:17:53.850
你不会像深度一样沉下去

00:17:51.480 --> 00:17:58.650
 64或32这很漂亮

00:17:53.850 --> 00:18:00.300
受约束，并且有效

00:17:58.650 --> 00:18:01.860
不断地看我的意思

00:18:00.300 --> 00:18:05.760
有效地固定时间，如果你

00:18:01.860 --> 00:18:09.360
将要查找一个键和一个

00:18:05.760 --> 00:18:14.810
值本质上是5的log 2n 

00:18:09.360 --> 00:18:14.810
在大多数情况下，您几乎可以说1 

00:18:15.560 --> 00:18:21.390
所以这些东西提供了良好的结构

00:18:17.880 --> 00:18:23.070
分享，稍后我会在视觉上显示

00:18:21.390 --> 00:18:24.660
显示一些可视化

00:18:23.070 --> 00:18:27.330
通过结构共享来解决这个问题

00:18:24.660 --> 00:18:28.530
我希望更多，但正因为如此，他们

00:18:27.330 --> 00:18:30.090
很好的更新他们也

00:18:28.530 --> 00:18:33.030
潜在地有利于合并和

00:18:30.090 --> 00:18:35.970
在我们的收藏中分裂

00:18:33.030 --> 00:18:39.210
我们进行并行收集时流

00:18:35.970 --> 00:18:41.430
说可能列出或映射我们

00:18:39.210 --> 00:18:43.110
可以在下面使用这些结构

00:18:41.430 --> 00:18:44.910
比我们目前更有效的合并

00:18:43.110 --> 00:18:46.800
今天就做，因为我们有一个代码

00:18:44.910 --> 00:18:48.870
实际上有点低效

00:18:46.800 --> 00:18:51.240
我们在收集两个清单时会做

00:18:48.870 --> 00:18:52.890
与这些平行或分组

00:18:51.240 --> 00:18:54.390
结构可能非常有趣

00:18:52.890 --> 00:18:56.070
允许您收集的条款

00:18:54.390 --> 00:18:58.170
并行然后有效地合并它们

00:18:56.070 --> 00:19:00.360
在一起，因为我们知道一些结构

00:18:58.170 --> 00:19:01.590
每个部分都有所不同

00:19:00.360 --> 00:19:03.030
结构是共享的，我们可以做一个

00:19:01.590 --> 00:19:06.930
只是在共享上进行一点点合并

00:19:03.030 --> 00:19:08.520
它们提供了良好的内存使用

00:19:06.930 --> 00:19:10.440
我希望能很好地解释

00:19:08.520 --> 00:19:11.970
我说好的缓存一致性，这是

00:19:10.440 --> 00:19:15.450
丰富的Hickey载体的基础

00:19:11.970 --> 00:19:18.630
封闭式编码，装满袋的地方

00:19:15.450 --> 00:19:20.940
还扩大了他的研究范围

00:19:18.630 --> 00:19:23.100
向量的松弛基数平衡树

00:19:20.940 --> 00:19:26.820
它也可以用于多张地图

00:19:23.100 --> 00:19:28.170
在今年的JVM LS上，主持人谈到了

00:19:26.820 --> 00:19:29.640
关于他如何使用这些结构

00:19:28.170 --> 00:19:32.670
对于多张地图也是如此

00:19:29.640 --> 00:19:34.380
用途广泛，也可以应用

00:19:32.670 --> 00:19:35.820
以及可变的收藏

00:19:34.380 --> 00:19:37.620
我感兴趣的是高效

00:19:35.820 --> 00:19:39.870
在你转身之前建造东西

00:19:37.620 --> 00:19:41.340
变成一成不变的东西，我认为

00:19:39.870 --> 00:19:43.500
它们可以在

00:19:41.340 --> 00:19:45.970
 Java它们可以有效地实现

00:19:43.500 --> 00:19:46.960
在Scala中，但实际上我相信Java 

00:19:45.970 --> 00:19:50.110
闭包实际上是Java 

00:19:46.960 --> 00:19:52.360
实现和Vava是另一个

00:19:50.110 --> 00:19:55.510
这些集合的例子

00:19:52.360 --> 00:19:58.150
被实施，所以这是一个真正的天真

00:19:55.510 --> 00:20:01.120
实现您可能的工作方式

00:19:58.150 --> 00:20:03.400
这个CP图是一个持久图，所以我

00:20:01.120 --> 00:20:06.280
有三十二分枝因子

00:20:03.400 --> 00:20:07.990
我将拥有一个关键的价值

00:20:06.280 --> 00:20:09.130
将我的键和值存储为条目，以便

00:20:07.990 --> 00:20:13.560
我正在做的是他们有一个节点

00:20:09.130 --> 00:20:16.840
这是对象数组，我要存储64 

00:20:13.560 --> 00:20:18.850
网站长度为64个键值键

00:20:16.840 --> 00:20:21.300
值键值键值和一些

00:20:18.850 --> 00:20:24.220
这些条目可能为空，因为

00:20:21.300 --> 00:20:26.620
值可能没有条目

00:20:24.220 --> 00:20:29.590
实际上在那里，可能是一个子

00:20:26.620 --> 00:20:32.950
在那里分层，所以如果我看一下

00:20:29.590 --> 00:20:36.430
这里找到一个值的方法

00:20:32.950 --> 00:20:39.580
给定密钥，我可能想问一下

00:20:36.430 --> 00:20:41.710
我目前的深度

00:20:39.580 --> 00:20:43.570
记住五位的符号

00:20:41.710 --> 00:20:45.730
在这里浏览哈希代码，所以我已经

00:20:43.570 --> 00:20:48.040
得说好我该如何索引

00:20:45.730 --> 00:20:49.900
首先我要完成一系列的节点

00:20:48.040 --> 00:20:52.240
必须获得我的哈希码的符号

00:20:49.900 --> 00:20:54.040
本质上是方法符号

00:20:52.240 --> 00:20:57.220
深度就是向下移动的全部

00:20:54.040 --> 00:20:59.980
深度乘以五并砍掉

00:20:57.220 --> 00:21:03.820
并得到前五位

00:20:59.980 --> 00:21:06.190
这就是我对数组的索引

00:21:03.820 --> 00:21:09.040
我看看它是否是子层节点

00:21:06.190 --> 00:21:11.790
往下走，否则我看到

00:21:09.040 --> 00:21:15.070
如果存在，我返回一个可选

00:21:11.790 --> 00:21:16.600
说出它是否存在

00:21:15.070 --> 00:21:19.900
那很简单，但那是

00:21:16.600 --> 00:21:20.860
像64个条目，我可能没有全部64个条目

00:21:19.900 --> 00:21:23.260
里面的条目很漂亮

00:21:20.860 --> 00:21:25.150
那里的代表效率很低，所以你

00:21:23.260 --> 00:21:27.100
可以做得更好，什么可以做

00:21:25.150 --> 00:21:30.220
你可以用位图来表达

00:21:27.100 --> 00:21:33.520
在我的级别中存在哪些条目

00:21:30.220 --> 00:21:36.970
我的树，我可以有一个数字数组

00:21:33.520 --> 00:21:40.030
包含的鼻子的对象数组是

00:21:36.970 --> 00:21:43.000
我设置的位数的长度

00:21:40.030 --> 00:21:44.950
位图，这样可以更压缩

00:21:43.000 --> 00:21:46.960
表示，这是一种技术

00:21:44.950 --> 00:21:49.180
所有这些持久的收藏

00:21:46.960 --> 00:21:51.730
实现，所以如果你看

00:21:49.180 --> 00:21:54.250
这个实现你会有相同的

00:21:51.730 --> 00:21:56.260
深度与您检查之前一样

00:21:54.250 --> 00:21:57.790
该位是否设置，如果没有设置

00:21:56.260 --> 00:21:59.980
设置然后将可选空

00:21:57.790 --> 00:22:01.899
不存在但是你有一个

00:21:59.980 --> 00:22:04.179
表示我如何编制索引的操作

00:22:01.899 --> 00:22:07.389
进入这个数组，但是你所要做的就是你

00:22:04.179 --> 00:22:09.250
从本质上来说，将位图砍掉

00:22:07.389 --> 00:22:10.600
对于符号之前的所有位

00:22:09.250 --> 00:22:12.370
您有兴趣算数

00:22:10.600 --> 00:22:15.090
使用位数计算的位数，然后

00:22:12.370 --> 00:22:18.639
您对数组的索引非常好

00:22:15.090 --> 00:22:20.500
以及为什么可以这样

00:22:18.639 --> 00:22:22.269
用Java有效实现的是

00:22:20.500 --> 00:22:24.940
因为整数位数是

00:22:22.269 --> 00:22:27.220
内在的，然后编译成

00:22:24.940 --> 00:22:30.460
 x86上的弹出计数指令

00:22:27.220 --> 00:22:31.899
之前是jdk中的固有ID 

00:22:30.460 --> 00:22:33.220
这些收集速度要慢得多

00:22:31.899 --> 00:22:36.370
因为他们不得不做很多事情

00:22:33.220 --> 00:22:38.649
我继续说下去

00:22:36.370 --> 00:22:41.429
希望以后有很多

00:22:38.649 --> 00:22:43.690
我们可以做更多的事情来优化这些东西

00:22:41.429 --> 00:22:45.159
所以我觉得这样比较好

00:22:43.690 --> 00:22:47.139
正如我所说的，空间是

00:22:45.159 --> 00:22:48.549
仅对于使用

00:22:47.139 --> 00:22:50.049
位图，这使得它成为可能

00:22:48.549 --> 00:22:51.549
热点优化还有更多

00:22:50.049 --> 00:22:53.679
您可以在这里进行细化

00:22:51.549 --> 00:22:55.389
权衡子节点和条目可以

00:22:53.679 --> 00:22:57.549
分开以提高缓存友好性

00:22:55.389 --> 00:23:00.429
遍历染色或谈论毛皮

00:22:57.549 --> 00:23:02.019
这在他的冠军作品和哈希码中

00:23:00.429 --> 00:23:04.330
也可以缓存，我没有缓存

00:23:02.019 --> 00:23:06.010
哈希码在这里是各种各样的

00:23:04.330 --> 00:23:08.769
我们可以尝试的权衡和实验

00:23:06.010 --> 00:23:10.570
和API略有不同，所以如果

00:23:08.769 --> 00:23:12.820
我有一个永久的地图API，可能

00:23:10.570 --> 00:23:14.889
每个人都有一个熟悉的地方

00:23:12.820 --> 00:23:17.230
得到返回null或可选的

00:23:14.889 --> 00:23:19.419
由您决定，但是put方法而不是

00:23:17.230 --> 00:23:21.789
返回null的前一个值

00:23:19.419 --> 00:23:23.440
它可能必须返回新地图

00:23:21.789 --> 00:23:25.120
因为我不是在修改

00:23:23.440 --> 00:23:27.159
现有地图我要返回新地图

00:23:25.120 --> 00:23:29.200
与上一个相同

00:23:27.159 --> 00:23:30.519
但是里面的新条目和相同

00:23:29.200 --> 00:23:31.870
就删除而言

00:23:30.519 --> 00:23:33.669
因此，API实际上是

00:23:31.870 --> 00:23:36.630
这里和你有些不同

00:23:33.669 --> 00:23:36.630
可能带有哈希图

00:23:38.270 --> 00:23:42.050
所以虽然有修改方法

00:23:40.940 --> 00:23:44.660
返回一个新的收藏

00:23:42.050 --> 00:23:48.590
实施将实际共享

00:23:44.660 --> 00:23:50.059
下面的结构并执行此操作

00:23:48.590 --> 00:23:52.309
我们在建设时高效地需要

00:23:50.059 --> 00:23:54.470
我们需要可变的构建器来构建

00:23:52.309 --> 00:23:56.390
受限的方式，所以我们想要的是

00:23:54.470 --> 00:23:58.610
真的，当你建立东西时

00:23:56.390 --> 00:24:01.460
您想将其限制为闭包或

00:23:58.610 --> 00:24:02.870
一个弗雷德，所以它不会逃脱，然后

00:24:01.460 --> 00:24:04.280
完成后，您就可以构建它们

00:24:02.870 --> 00:24:06.080
冻结，你有一个不变的东西

00:24:04.280 --> 00:24:08.120
和关闭有这个海洋

00:24:06.080 --> 00:24:11.990
大厦我不确定Scala可能

00:24:08.120 --> 00:24:17.809
做得好，所以我要展示

00:24:11.990 --> 00:24:19.970
现在进行一些演示让我们看看如何

00:24:17.809 --> 00:24:21.350
成功，这实际上是之前

00:24:19.970 --> 00:24:25.190
我去了，有人快吗

00:24:21.350 --> 00:24:30.620
关于解释的问题不好

00:24:25.190 --> 00:24:34.490
很好，我要加一点翅膀

00:24:30.620 --> 00:24:36.320
在这里，让我们先来看一下

00:24:34.490 --> 00:24:42.200
我要去的一切我要去办J 

00:24:36.320 --> 00:24:45.650
壳启动这个好吧，这是

00:24:42.200 --> 00:24:47.570
实际上是运行Java 10或18的J shell 

00:24:45.650 --> 00:24:50.059
如今我们喜欢称它为无点

00:24:47.570 --> 00:24:56.410
我不打算讨论

00:24:50.059 --> 00:24:56.410
版本号，因此我们可以使用var 

00:25:00.260 --> 00:25:05.550
所以我这里有一个github项目

00:25:03.510 --> 00:25:07.260
发送了一个链接到这是所有在线

00:25:05.550 --> 00:25:09.360
 github，你可以检查出来玩

00:25:07.260 --> 00:25:10.530
自己动手，并了解如何

00:25:09.360 --> 00:25:13.440
这些结构可以像我写的那样工作

00:25:10.530 --> 00:25:15.000
是越野车，它不是高性能的，但它的

00:25:13.440 --> 00:25:17.100
功能足以尝试

00:25:15.000 --> 00:25:19.320
您终于发现其中的错误，这给了我很大的推动力

00:25:17.100 --> 00:25:22.110
请求拉请求，我将

00:25:19.320 --> 00:25:25.890
会接受它并修复其中的内容

00:25:22.110 --> 00:25:28.890
公开公开JDK说许可证公开

00:25:25.890 --> 00:25:33.330
 JDK所以如果我只是创建一个非常简单的

00:25:28.890 --> 00:25:40.200
像VAR m等于P映射阀

00:25:33.330 --> 00:25:42.600
这样我可以像这样想象

00:25:40.200 --> 00:25:45.030
这将要做什么

00:25:42.600 --> 00:25:47.160
看看它要去的结构

00:25:45.030 --> 00:25:51.780
创建一个点文件转换该点文件

00:25:47.160 --> 00:25:54.990
 SVG并将其加载到浏览器中

00:25:51.780 --> 00:25:57.030
我可以没事的，所以我们在这里是

00:25:54.990 --> 00:25:58.170
我们对地图的第一次可视化

00:25:57.030 --> 00:26:00.210
不太有趣

00:25:58.170 --> 00:26:02.100
但是解释发生的事情很有用

00:26:00.210 --> 00:26:04.460
我在地图上有一个条目

00:26:02.100 --> 00:26:09.270
一的关键和一的价值

00:26:04.460 --> 00:26:12.660
这里的顶部没有一个节点

00:26:09.270 --> 00:26:14.550
位图表示32个值，所以这是

00:26:12.660 --> 00:26:17.160
这是我之前显示的位图

00:26:14.550 --> 00:26:20.640
 int int位图，它是和

00:26:17.160 --> 00:26:25.340
基本上设置了一个大小

00:26:20.640 --> 00:26:29.640
一个，这里有一个前缀

00:26:25.340 --> 00:26:32.580
键为任意整数值之一

00:26:29.640 --> 00:26:35.490
在2到16之间实际上是哈希

00:26:32.580 --> 00:26:37.080
代码本身就是这样

00:26:35.490 --> 00:26:41.310
这就是您需要在这里知道的

00:26:37.080 --> 00:26:43.290
 1的哈希码是1，所以我有一个

00:26:41.310 --> 00:26:46.350
在此处为1的第一个应用位添加前缀

00:26:43.290 --> 00:26:48.120
总哈希是从

00:26:46.350 --> 00:26:51.510
最低至最高

00:26:48.120 --> 00:26:52.190
重要的是，这也使

00:26:51.510 --> 00:26:57.710
感

00:26:52.190 --> 00:26:57.710
所以我可以在这里添加更多

00:26:58.280 --> 00:27:05.530
可视化两件事，所以我们可以

00:27:01.080 --> 00:27:08.210
我们可以像这样放置另一个值

00:27:05.530 --> 00:27:11.510
我们可以想象两件事，所以现在

00:27:08.210 --> 00:27:16.400
现在我们得到以前的地图， 

00:27:11.510 --> 00:27:19.550
这样的新地图，所以我们仍然有一个

00:27:16.400 --> 00:27:21.470
节点1节点深度

00:27:19.550 --> 00:27:27.950
用1到1的键映射，我们有一个

00:27:21.470 --> 00:27:29.660
 1＆1＆2＆2的新地图，所以

00:27:27.950 --> 00:27:31.250
 Muta书没有结构性分享

00:27:29.660 --> 00:27:33.500
在这里，因为我们在同一深度

00:27:31.250 --> 00:27:35.780
在这里，我们基本上得到了

00:27:33.500 --> 00:27:37.970
两个数组无法共享，所以我们不得不

00:27:35.780 --> 00:27:40.580
当我们走时在结构上分享

00:27:37.970 --> 00:27:42.020
现在节点数量下降，但是您

00:27:40.580 --> 00:27:45.410
可以看到这里的前缀是

00:27:42.020 --> 00:27:47.510
不同的哈希值是不同的

00:27:45.410 --> 00:27:48.860
这样很容易可视化

00:27:47.510 --> 00:27:53.740
玩这些东西，所以我可以

00:27:48.860 --> 00:27:53.740
在这里显示一些更复杂的例子

00:27:55.510 --> 00:28:01.970
好吧，这是一个很好的例子

00:27:58.580 --> 00:28:07.550
我认为您会看到的，所以我

00:28:01.970 --> 00:28:09.770
放大这里是建立示例

00:28:07.550 --> 00:28:13.010
永久地图，这是常见的

00:28:09.770 --> 00:28:17.840
你可能会做的事情至少是jdk代码

00:28:13.010 --> 00:28:21.950
可能有您的符号

00:28:17.840 --> 00:28:24.860
字节码BD fi和的原始类型

00:28:21.950 --> 00:28:27.590
依此类推映射到框类型

00:28:24.860 --> 00:28:29.120
你可以为此创建一个地图

00:28:27.590 --> 00:28:32.870
我在这里正在做的是

00:28:29.120 --> 00:28:35.030
空的地图，而不是把我的第一

00:28:32.870 --> 00:28:36.470
在我的第二个条目中输入身份

00:28:35.030 --> 00:28:37.880
都是素食，所以我在创造

00:28:36.470 --> 00:28:39.110
所有这些结构并扔给他们

00:28:37.880 --> 00:28:40.340
走开，扔掉创造一切

00:28:39.110 --> 00:28:41.960
这些结构，直到我得到一个

00:28:40.340 --> 00:28:43.280
希望那不是特别的

00:28:41.960 --> 00:28:45.320
有效的方法，但是我们可以

00:28:43.280 --> 00:28:47.590
想像一下，看看会看到什么

00:28:45.320 --> 00:28:50.510
发生了，所以我将在这里运行此测试

00:28:47.590 --> 00:28:52.660
它应该做与

00:28:50.510 --> 00:28:52.660
之前

00:28:54.310 --> 00:29:00.460
好吧，这变得越来越难看

00:28:57.420 --> 00:29:02.110
你能看到不是真的吗

00:29:00.460 --> 00:29:03.520
关键是，这实际上

00:29:02.110 --> 00:29:08.520
这里没有碰撞，那里没有碰撞

00:29:03.520 --> 00:29:11.500
潜艇知道所有这些地图都深一层

00:29:08.520 --> 00:29:13.450
在这里，我们可以看到各种前缀

00:29:11.500 --> 00:29:15.250
和哈希码在这里，我们可以看到

00:29:13.450 --> 00:29:18.130
顶部节点，因为有九个条目

00:29:15.250 --> 00:29:20.290
我的位图中设置了九位

00:29:18.130 --> 00:29:22.390
这样，没有就没有

00:29:20.290 --> 00:29:25.030
此处的前缀冲突，因此我们不会

00:29:22.390 --> 00:29:26.500
深入到任何水平

00:29:25.030 --> 00:29:29.800
这实际上是一个很好的财产

00:29:26.500 --> 00:29:31.780
基本上只包装了十八个

00:29:29.800 --> 00:29:33.550
我的对象数组中有18个条目

00:29:31.780 --> 00:29:35.710
如果您使用的是

00:29:33.550 --> 00:29:37.600
您可能需要获取的哈希图

00:29:35.710 --> 00:29:40.570
必须有一个散列表大小的哈希表

00:29:37.600 --> 00:29:42.430
大约三十二停止碰撞

00:29:40.570 --> 00:29:44.950
所以你已经在这里节省了一些空间

00:29:42.430 --> 00:29:46.450
这一切都很好地缓存了一致性

00:29:44.950 --> 00:29:48.310
因为它们都在一个数组中

00:29:46.450 --> 00:29:50.890
当我穿越时我会得到

00:29:48.310 --> 00:29:52.330
预取工作以及唯一的

00:29:50.890 --> 00:29:54.700
我在这里没有的东西是我不是

00:29:52.330 --> 00:29:56.590
分享而不是存储我不是

00:29:54.700 --> 00:29:59.200
缓存哈希码，所以我要

00:29:56.590 --> 00:30:01.720
当我什么时候受到时间的打击

00:29:59.200 --> 00:30:04.660
我比较我的哈希码，但是有办法

00:30:01.720 --> 00:30:07.150
也有现金流，这就是一个例子

00:30:04.660 --> 00:30:12.310
在那里让我向您展示

00:30:07.150 --> 00:30:13.930
建筑，所以我展示了它

00:30:12.310 --> 00:30:17.620
结构上一成不变，我抛出

00:30:13.930 --> 00:30:20.080
每次我放在这里作为

00:30:17.620 --> 00:30:21.880
他们创造了一个新的，所以创造了一些

00:30:20.080 --> 00:30:25.150
垃圾收集在这里，但我可以做

00:30:21.880 --> 00:30:27.700
而不是说和的P图

00:30:25.150 --> 00:30:31.330
相反，我基本上得到了我所说的

00:30:27.700 --> 00:30:33.550
一个P的地图生成器，以及所有P 

00:30:31.330 --> 00:30:35.650
地图构建器所做的是在put方法上

00:30:33.550 --> 00:30:39.910
我所能做的就是向地图添加内容

00:30:35.650 --> 00:30:42.610
我在这里封闭地做着

00:30:39.910 --> 00:30:44.620
只想限制这个生成器

00:30:42.610 --> 00:30:47.080
在此闭包内和内部运行

00:30:44.620 --> 00:30:48.670
如果我在同一线程操作

00:30:47.080 --> 00:30:50.830
另一个线程将抛出一个合法的

00:30:48.670 --> 00:30:52.780
状态异常，如果我以某种方式缓存它

00:30:50.830 --> 00:30:54.220
通过将其存储在一个封闭的外部

00:30:52.780 --> 00:30:56.080
数组或字段或类似的东西

00:30:54.220 --> 00:30:57.550
并在外面时对其进行操作

00:30:56.080 --> 00:30:59.290
关闭它将浮动合法状态

00:30:57.550 --> 00:31:01.500
搜索和我会很好地限制的东西

00:30:59.290 --> 00:31:03.730
这个东西，然后我可以静音

00:31:01.500 --> 00:31:05.860
安全地更新此内容，因为我不知道

00:31:03.730 --> 00:31:07.370
弗雷德的遗嘱将打开它，我知道

00:31:05.860 --> 00:31:08.900
那如果我

00:31:07.370 --> 00:31:11.090
所以不会发生坏事

00:31:08.900 --> 00:31:12.560
到后来，这是一个相当

00:31:11.090 --> 00:31:14.960
强大的概念，我们做了同样的事情

00:31:12.560 --> 00:31:17.300
如果您曾经使用过堆栈Walker API 

00:31:14.960 --> 00:31:19.610
用它来获取栈和遍历

00:31:17.300 --> 00:31:21.860
在框架中使用流API的帧

00:31:19.610 --> 00:31:23.120
封闭并以密闭方式使用

00:31:21.860 --> 00:31:24.830
这样的封闭，我认为这是一个

00:31:23.120 --> 00:31:27.560
非常有趣的模式，因为我可以

00:31:24.830 --> 00:31:29.750
建立一些可变的东西而不扔

00:31:27.560 --> 00:31:32.210
离开并制造一堆垃圾， 

00:31:29.750 --> 00:31:34.010
一旦关闭完成我冻结

00:31:32.210 --> 00:31:37.970
集合，它变得不可变

00:31:34.010 --> 00:31:43.100
我又在做一些有趣的把戏

00:31:37.970 --> 00:31:45.820
与JD在这里有些杂项不安全，如果您

00:31:43.100 --> 00:31:49.900
想看看我实际上的代码

00:31:45.820 --> 00:31:52.310
而不是复制我的数据

00:31:49.900 --> 00:31:54.680
从转换头

00:31:52.310 --> 00:31:57.080
我可以用术语写的东西

00:31:54.680 --> 00:31:59.300
到相同的领域

00:31:57.080 --> 00:32:00.560
如果稍后有最终字段的结构

00:31:59.300 --> 00:32:03.170
你想看看你的代码

00:32:00.560 --> 00:32:05.210
不应该在家里做这个

00:32:03.170 --> 00:32:09.230
这些是我们可以运用的技巧吗

00:32:05.210 --> 00:32:11.300
在JDK中做，只要我们可以

00:32:09.230 --> 00:32:14.240
测试它，我们相信我们的代码，我们可以

00:32:11.300 --> 00:32:15.860
可以做这些技巧，并且和

00:32:14.240 --> 00:32:17.960
没有其他人可以做这些类型的把戏

00:32:15.860 --> 00:32:19.670
外面对我们有利

00:32:17.960 --> 00:32:21.650
这就是为什么这些东西是

00:32:19.670 --> 00:32:24.250
对我来说，其他好处是我们可以

00:32:21.650 --> 00:32:26.480
优化这些东西

00:32:24.250 --> 00:32:28.460
任何人都可以在上面写这些东西

00:32:26.480 --> 00:32:31.010
我认为JD获得合理的效率

00:32:28.460 --> 00:32:34.190
如果在JDK中，我们可以做得更好

00:32:31.010 --> 00:32:35.930
本身就是一个优势，所以我

00:32:34.190 --> 00:32:38.660
表明我可以运行

00:32:35.930 --> 00:32:45.800
两个只是为了表明它将建立一个

00:32:38.660 --> 00:32:49.250
地图像以前一样好

00:32:45.800 --> 00:32:51.620
没什么两样

00:32:49.250 --> 00:32:54.860
我得到不变的相同结构

00:32:51.620 --> 00:32:59.090
那里的结构好吧，让我们展示一下

00:32:54.860 --> 00:33:00.980
让我们更复杂一点

00:32:59.090 --> 00:33:02.870
一个在这里，所以我不在

00:33:00.980 --> 00:33:06.530
有效地在这里，但我只是在创建一个

00:33:02.870 --> 00:33:08.420
一堆水果要变色

00:33:06.530 --> 00:33:10.010
这，我将可视化地图

00:33:08.420 --> 00:33:13.400
我建好了，但我也要形象化

00:33:10.010 --> 00:33:16.640
蓝色的蓝莓入口

00:33:13.400 --> 00:33:20.660
删除让我们看看会发生什么

00:33:16.640 --> 00:33:27.440
是的，所以这将创造一个

00:33:20.660 --> 00:33:34.220
大地图在这里，所以如果我们只是是相当

00:33:27.440 --> 00:33:36.080
很大，但是如果您注意到这里，我们将会

00:33:34.220 --> 00:33:38.510
两者之间的一些结构性共享

00:33:36.080 --> 00:33:42.320
映射，因为我们有一个子节点

00:33:38.510 --> 00:33:44.630
第一个PI位前缀存在冲突，因此

00:33:42.320 --> 00:33:48.380
第一个战斗位前缀都在这里

00:33:44.630 --> 00:33:52.310
香蕉和李子一点点地渴

00:33:48.380 --> 00:33:53.930
 0 0 0 0 0的前缀，所以我们可以

00:33:52.310 --> 00:33:58.430
在结构上在两者之间分享

00:33:53.930 --> 00:34:02.210
我们修改过的地图，因此此地图将

00:33:58.430 --> 00:34:03.710
有，所以里面有蓝莓，但是有

00:34:02.210 --> 00:34:05.720
这里只有一个蓝莓没有

00:34:03.710 --> 00:34:09.950
其他地图我们将其删除，但我们可以

00:34:05.720 --> 00:34:13.010
在结构上共享此子模式层

00:34:09.950 --> 00:34:15.230
这样，当您获得更复杂的图层时

00:34:13.010 --> 00:34:16.490
您可以进行更多结构性分享

00:34:15.230 --> 00:34:18.620
实际上在这里做，这很有趣

00:34:16.490 --> 00:34:20.149
这不仅使它更容易

00:34:18.620 --> 00:34:22.340
分裂是因为自然分裂

00:34:20.149 --> 00:34:25.730
既指向数组又指向这个

00:34:22.340 --> 00:34:28.190
这里也是如此希望得到它

00:34:25.730 --> 00:34:31.100
穿过一点，我们可以看到

00:34:28.190 --> 00:34:33.020
前缀这里我们现在有2 5位

00:34:31.100 --> 00:34:35.600
这里的前5位和第二位

00:34:33.020 --> 00:34:37.850
五位或两个符号，我们可以看到

00:34:35.600 --> 00:34:39.409
它始终是总数的前缀

00:34:37.850 --> 00:34:42.760
比较时在这里哈希代码

00:34:39.409 --> 00:34:42.760
这些这些价值

00:34:44.080 --> 00:34:51.190
所以我们可以做一些更复杂的事情

00:34:47.679 --> 00:34:54.490
让我们来看看，这是他的系统

00:34:51.190 --> 00:34:57.220
属性，是系统属性吗

00:34:54.490 --> 00:34:59.770
本质上是所有系统的地图

00:34:57.220 --> 00:35:01.930
 JDK maybach中的属性，让我们

00:34:59.770 --> 00:35:05.280
形象地看这看

00:35:01.930 --> 00:35:09.490
这样会更复杂

00:35:05.280 --> 00:35:12.160
好，这样您就可以了解结构

00:35:09.490 --> 00:35:21.700
这里有更多的子节点

00:35:12.160 --> 00:35:25.300
在这里让我们一直向下滚动

00:35:21.700 --> 00:35:27.520
所以我们在这里看到一个前缀共享前缀

00:35:25.300 --> 00:35:29.590
和其他符号向下等等

00:35:27.520 --> 00:35:32.830
它只能下降到大约

00:35:29.590 --> 00:35:35.740
最后两个，也许三个

00:35:32.830 --> 00:35:36.940
还很浅所以如果你要

00:35:35.740 --> 00:35:38.440
查找它要去的东西

00:35:36.940 --> 00:35:40.210
横穿一点，但是没有走

00:35:38.440 --> 00:35:42.610
穿越得太深，这就是为什么

00:35:40.210 --> 00:35:43.840
这几乎是恒定的时间

00:35:42.610 --> 00:35:45.340
这样做有一个很好的结构

00:35:43.840 --> 00:35:49.060
在这里分享和合理的效率

00:35:45.340 --> 00:35:50.770
在访问方面，您可能不是

00:35:49.060 --> 00:35:53.800
这里将是一个大小合适的哈希图

00:35:50.770 --> 00:35:56.260
但我认为潜在的哈希图

00:35:53.800 --> 00:35:57.940
将占用更多内存，可能会出现

00:35:56.260 --> 00:35:59.860
在这里交换空间和时间

00:35:57.940 --> 00:36:01.390
有点，但实际上是非常好的妥协

00:35:59.860 --> 00:36:03.580
不要以为你在用这些东西

00:36:01.390 --> 00:36:07.120
大多数人不会注意到或不需要

00:36:03.580 --> 00:36:08.470
这是我的理论的额外表现

00:36:07.120 --> 00:36:10.480
无论如何，我不知道这是否完全是

00:36:08.470 --> 00:36:12.250
 true将必须验证我们是否拥有

00:36:10.480 --> 00:36:15.640
对这些进行良好的性能测试

00:36:12.250 --> 00:36:17.170
事情也一样，但它们只是表达为

00:36:15.640 --> 00:36:21.430
表现出很好的一套

00:36:17.170 --> 00:36:23.470
这里的属性我们可以看看更多

00:36:21.430 --> 00:36:26.070
在这里退化案例，如果发生什么情况

00:36:23.470 --> 00:36:29.350
你有冲突，所以两个哈希码

00:36:26.070 --> 00:36:33.580
到两个条目，两个键共享相同的

00:36:29.350 --> 00:36:39.040
哈希码你怎么办所以我有

00:36:33.580 --> 00:36:40.840
在这里一个int键

00:36:39.040 --> 00:36:43.150
设置这两件事的哈希码

00:36:40.840 --> 00:36:45.190
零，所以我有一个实体，其键是

00:36:43.150 --> 00:36:47.020
一个和一个int键是键，但是两个

00:36:45.190 --> 00:36:51.600
他们的哈希码和我一样

00:36:47.020 --> 00:36:51.600
用一和二炮制

00:36:54.530 --> 00:37:02.610
所以在这种情况下，我们在这里发生碰撞

00:36:58.770 --> 00:37:03.810
用红色框表示，那么我们该怎么办

00:37:02.610 --> 00:37:06.270
当我们发生碰撞时，我们可以使用

00:37:03.810 --> 00:37:09.030
链表，我们可以使用红色黑色

00:37:06.270 --> 00:37:11.070
就像我们今天在哈希图中所做的树，还是我们

00:37:09.030 --> 00:37:12.870
可以更改为哈希算法，并且

00:37:11.070 --> 00:37:15.000
去和使用相同的火腿T结构

00:37:12.870 --> 00:37:16.530
和的哈希码算法不同

00:37:15.000 --> 00:37:23.700
尽可能多的选择

00:37:16.530 --> 00:37:25.500
尝试一下，让我们看看另一个

00:37:23.700 --> 00:37:28.650
让我们看看如何

00:37:25.500 --> 00:37:32.300
我们可以深入到树上

00:37:28.650 --> 00:37:35.280
我在这里做我在炮制

00:37:32.300 --> 00:37:37.920
整数就是这样，但我知道

00:37:35.280 --> 00:37:39.630
内部的哈希码算法

00:37:37.920 --> 00:37:42.060
创建帽子以创建实际的哈希

00:37:39.630 --> 00:37:45.750
我在地图中使用的代码值，所以我

00:37:42.060 --> 00:37:46.230
创建我想设置两个顶级

00:37:45.750 --> 00:37:48.840
位

00:37:46.230 --> 00:37:51.900
记住它是战斗，这是六个符号

00:37:48.840 --> 00:37:55.200
最多两个两个顶级位

00:37:51.900 --> 00:37:56.550
有效位仅在结束设置时

00:37:55.200 --> 00:38:00.180
他们的价值观，我也在设定

00:37:56.550 --> 00:38:02.910
值，因为哈希码是

00:38:00.180 --> 00:38:04.380
稍微移动了一点，所以我只是

00:38:02.910 --> 00:38:06.660
我会计算哈希码是这样

00:38:04.380 --> 00:38:09.150
你在哈希图中完成，你转移哈希

00:38:06.660 --> 00:38:11.430
通过六十码进行编码，然后对其进行异或运算

00:38:09.150 --> 00:38:13.260
我想我想取消那些

00:38:11.430 --> 00:38:16.920
然后将哈希码放在顶部

00:38:13.260 --> 00:38:22.230
这两个重要位只是为了

00:38:16.920 --> 00:38:26.070
显示退化的情况，那又如何

00:38:22.230 --> 00:38:28.920
发生在这里我们得到一二三四

00:38:26.070 --> 00:38:30.390
当我们得到四个时，射击深度为六个

00:38:28.920 --> 00:38:31.710
值直接在底部，所以如果

00:38:30.390 --> 00:38:33.870
您正在遍历此结构

00:38:31.710 --> 00:38:36.270
必须一直坐下去

00:38:33.870 --> 00:38:38.220
下降的方式不是非常快缓存连贯

00:38:36.270 --> 00:38:40.770
效率非常低下

00:38:38.220 --> 00:38:41.910
但是你被限制在60级

00:38:40.770 --> 00:38:43.860
你不会走得更远， 

00:38:41.910 --> 00:38:45.960
更进一步，如果您正在写作， 

00:38:43.860 --> 00:38:47.910
为此添加算法，您不会

00:38:45.960 --> 00:38:50.880
要使用递归，您可以分配一个

00:38:47.910 --> 00:38:54.210
堆在只有六个的堆上

00:38:50.880 --> 00:38:55.560
非常好的属性，我的意思是我们看到了

00:38:54.210 --> 00:38:57.300
那里的价值，所以这是最糟糕的

00:38:55.560 --> 00:39:01.130
如果你可能得到我想要的

00:38:57.300 --> 00:39:01.130
争论不是很普遍

00:39:02.420 --> 00:39:06.690
好的，我想就是这样

00:39:05.070 --> 00:39:08.369
签出代码，玩得开心

00:39:06.690 --> 00:39:13.170
与此相关或向我发送修复程序，而我

00:39:08.369 --> 00:39:19.230
对这些东西很感兴趣

00:39:13.170 --> 00:39:21.390
总结一下，所以我认为无法修改

00:39:19.230 --> 00:39:23.670
是可变的合理抽象

00:39:21.390 --> 00:39:27.390
但不是一成不变的，我希望我能说服你

00:39:23.670 --> 00:39:29.700
高效的不可变集合

00:39:27.390 --> 00:39:32.010
我们需要持久的收集而没有

00:39:29.700 --> 00:39:34.619
有点争吵番石榴让你走到现在

00:39:32.010 --> 00:39:36.420
这是合理的，但我认为我们可以做到

00:39:34.619 --> 00:39:39.660
更好的语言和其他平台

00:39:36.420 --> 00:39:42.060
实际做得更好并设置地图

00:39:39.660 --> 00:39:43.800
使用火腿茶的载体已被证明

00:39:42.060 --> 00:39:45.930
在这些库中有效

00:39:43.800 --> 00:39:51.810
我认为平台已经证明了

00:39:45.930 --> 00:39:53.339
他们的价值，那么Java是什么

00:39:51.810 --> 00:39:55.890
有点投机性

00:39:53.339 --> 00:39:58.140
我的看法更多，我认为我们一定会

00:39:55.890 --> 00:40:00.000
继续证明不可修改

00:39:58.140 --> 00:40:01.619
 JDK和Stewart标记已经

00:40:00.000 --> 00:40:03.930
他在做这样的事情

00:40:01.619 --> 00:40:05.970
已经对核心进行了一件事的审查

00:40:03.930 --> 00:40:07.560
 libs dev并打开JDK，其中有一些

00:40:05.970 --> 00:40:10.800
管子里的其他东西

00:40:07.560 --> 00:40:14.490
这里有很好的改进，但是呢

00:40:10.800 --> 00:40:17.640
说选择性沉淀我爱那个

00:40:14.490 --> 00:40:20.369
这个词是一个标记Reinhold这个词，但是他

00:40:17.640 --> 00:40:22.440
使用我们有豪华的外观

00:40:20.369 --> 00:40:24.270
外面还有其他语言和

00:40:22.440 --> 00:40:26.910
平台，看看他们在做什么

00:40:24.270 --> 00:40:30.569
退后一步思考他们，并采取最好的

00:40:26.910 --> 00:40:32.069
每个人都可以用

00:40:30.569 --> 00:40:32.700
 Java中的持久性集合

00:40:32.069 --> 00:40:35.700
平台

00:40:32.700 --> 00:40:37.470
也许我们可以说我说是

00:40:35.700 --> 00:40:40.200
可以优化这些集合

00:40:37.470 --> 00:40:42.359
非常非常积极地与内部

00:40:40.200 --> 00:40:44.819
 api的热点并被安全地包含

00:40:42.359 --> 00:40:47.130
不安全的机制，但我谈到了

00:40:44.819 --> 00:40:49.470
当我做建筑的时候

00:40:47.130 --> 00:40:51.270
有很多方法可以

00:40:49.470 --> 00:40:53.810
正如我向您展示的那样，更充分地利用

00:40:51.270 --> 00:40:56.970
关于JVM的弹出计数的讨论较少

00:40:53.810 --> 00:41:00.660
 Stein dauther讲了多

00:40:56.970 --> 00:41:02.910
地图，他使用的是AVX样式

00:41:00.660 --> 00:41:04.530
指令进行位操作

00:41:02.910 --> 00:41:06.359
这些多张地图，使它们高效

00:41:04.530 --> 00:41:08.250
以及我们在那里也可以做的事情

00:41:06.359 --> 00:41:10.020
这里有很多研究，但是我的

00:41:08.250 --> 00:41:11.970
声称是我们可以优化这些

00:41:10.020 --> 00:41:12.970
像其他人一样的事情

00:41:11.970 --> 00:41:17.770
 JDK可以优化

00:41:12.970 --> 00:41:19.810
今天，到此为止

00:41:17.770 --> 00:41:20.920
演示，还有一些参考

00:41:19.810 --> 00:41:23.349
在这里的后面，我将上传

00:41:20.920 --> 00:41:25.900
演示文稿和关于它的推文

00:41:23.349 --> 00:41:28.200
有一些参考

00:41:25.900 --> 00:41:30.910
论文写了这些数据结构

00:41:28.200 --> 00:41:33.099
特别喜欢推荐斯坦

00:41:30.910 --> 00:41:34.990
女儿的论文，我想他做了一些

00:41:33.099 --> 00:41:37.900
有趣的工作建立了枪支禁令

00:41:34.990 --> 00:41:40.540
 Bagwell，如果您有兴趣的话，请看

00:41:37.900 --> 00:41:43.119
闭包向量，然后看

00:41:40.540 --> 00:41:45.040
 Scala中有关VR实现的内容

00:41:43.119 --> 00:41:46.960
 BB向量也有

00:41:45.040 --> 00:41:50.320
最后有趣的是

00:41:46.960 --> 00:41:54.090
使用这些哈希将哈希数组映射为哈希

00:41:50.320 --> 00:41:58.050
大米用于同时收集和

00:41:54.090 --> 00:42:00.880
 Pro kopeck的作品非常有趣

00:41:58.050 --> 00:42:01.990
利用这些东西并发

00:42:00.880 --> 00:42:04.920
具有相似的收藏

00:42:01.990 --> 00:42:12.190
并发跳过列表的特征

00:42:04.920 --> 00:42:14.220
好吧，我想我已经完成了任何问题，否

00:42:12.190 --> 00:42:14.220
问题

00:42:15.090 --> 00:42:20.620
你们都知道，好的，谢谢

00:42:19.690 --> 00:42:24.000
您

00:42:20.620 --> 00:42:24.000
 [掌声] 

