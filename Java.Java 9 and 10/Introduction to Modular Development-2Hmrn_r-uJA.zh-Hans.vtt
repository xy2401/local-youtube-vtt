WEBVTT
Kind: captions
Language: zh-Hans

00:00:05.330 --> 00:00:10.059
下午好，欢迎参加本届会议

00:00:07.580 --> 00:00:11.960
介绍模块化开发

00:00:10.059 --> 00:00:17.570
我是Alan Bateman 

00:00:11.960 --> 00:00:18.890
我是JDK，这是第二五

00:00:17.570 --> 00:00:23.500
我们正在做一个Java会议

00:00:18.890 --> 00:00:26.210
今年将介绍模块和JDK九

00:00:23.500 --> 00:00:28.130
你在这之前做了第一个

00:00:26.210 --> 00:00:30.980
午餐我为JDK九准备了

00:00:28.130 --> 00:00:33.530
其他会谈的明天重复

00:00:30.980 --> 00:00:38.110
这也是重复的，我会显示一个

00:00:33.530 --> 00:00:40.520
滑动到最后并带有提醒

00:00:38.110 --> 00:00:42.260
只是一些

00:00:40.520 --> 00:00:45.590
我们所谓的背景

00:00:42.260 --> 00:00:50.239
模块化景观，让您

00:00:45.590 --> 00:00:54.440
了解一下Java发生了什么

00:00:50.239 --> 00:00:56.780
 C 9所以模块系统本身

00:00:54.440 --> 00:01:01.730
通过Java社区开发的

00:00:56.780 --> 00:01:04.610
通过jsr 376处理，这是

00:01:01.730 --> 00:01:07.820
针对Java C 9标志Reinhold 

00:01:04.610 --> 00:01:12.409
坐在桌子旁，他带领着这个

00:01:07.820 --> 00:01:16.880
 GSR Java C 9本身也有它自己的

00:01:12.409 --> 00:01:19.990
伞式GSR，它将拥有

00:01:16.880 --> 00:01:23.119
 Java C 9发行版的全部内容

00:01:19.990 --> 00:01:25.039
它还将拥有

00:01:23.119 --> 00:01:26.389
平台的第一部分

00:01:25.039 --> 00:01:28.429
我只想花一些时间

00:01:26.389 --> 00:01:31.249
分钟，并谈论这意味着什么

00:01:28.429 --> 00:01:32.990
在模块化平台上，所以这个余量

00:01:31.249 --> 00:01:36.740
我要告诉你的图表本质上是

00:01:32.990 --> 00:01:41.270
 Java C 9和我们将拥有的东西

00:01:36.740 --> 00:01:43.490
在开放的JDK中标准化

00:01:41.270 --> 00:01:45.709
从事项目实施

00:01:43.490 --> 00:01:47.469
可以作为参考的拼图

00:01:45.709 --> 00:01:50.060
模块系统的实现

00:01:47.469 --> 00:01:51.529
有许多喷气机或JAVA

00:01:50.060 --> 00:01:53.569
都是增强建议

00:01:51.529 --> 00:01:57.139
如果您为他们谷歌编号，你会

00:01:53.569 --> 00:01:59.079
找到他们只是那个文件

00:01:57.139 --> 00:02:01.969
所有详细的实施

00:01:59.079 --> 00:02:02.929
选择和命令行标志以及

00:02:01.969 --> 00:02:05.119
其他所有与

00:02:02.929 --> 00:02:07.219
实施，您会发现所有这些都已列出

00:02:05.119 --> 00:02:10.580
在这些喷气机中未记录的

00:02:07.219 --> 00:02:14.510
在进行重要更新时进行更新

00:02:10.580 --> 00:02:17.120
要了解的是，JDK 9不是

00:02:14.510 --> 00:02:18.500
完成但不打算发货

00:02:17.120 --> 00:02:20.300
直到2017年

00:02:18.500 --> 00:02:22.910
那是很多东西

00:02:20.300 --> 00:02:24.410
进行设计讨论等

00:02:22.910 --> 00:02:27.560
会有改变

00:02:24.410 --> 00:02:29.600
毫无疑问，所以请记住

00:02:27.560 --> 00:02:34.300
当我们经历一些

00:02:29.600 --> 00:02:38.209
例子，在这个演讲中

00:02:34.300 --> 00:02:40.490
分成两部分我要去

00:02:38.209 --> 00:02:42.230
在第二部分中真正介绍了模块

00:02:40.490 --> 00:02:45.650
部分，但我想从谈话开始

00:02:42.230 --> 00:02:49.340
关于并说模块开发

00:02:45.650 --> 00:02:51.290
从模块化平台开始，所以我

00:02:49.340 --> 00:02:56.480
要谈论成为什么意味着

00:02:51.290 --> 00:03:01.070
在模块化平台上运行此图

00:02:56.480 --> 00:03:03.970
用引号括起来就是我们使用JDK的地方

00:03:01.070 --> 00:03:06.500
回到JDK的七个时间范围

00:03:03.970 --> 00:03:08.810
这看起来很可怕，没有

00:03:06.500 --> 00:03:11.209
关于我们的很多话，这就是我们

00:03:08.810 --> 00:03:13.250
是几年前，我们把

00:03:11.209 --> 00:03:17.510
为了真正地分手

00:03:13.250 --> 00:03:19.250
 JDK分为一组内聚模块和一个

00:03:17.510 --> 00:03:21.980
在这方面已经取得了很多进展

00:03:19.250 --> 00:03:25.130
对此唯一要指出的是

00:03:21.980 --> 00:03:26.540
这个可怕的幻灯片与

00:03:25.130 --> 00:03:29.720
周期和各种各样的怪异

00:03:26.540 --> 00:03:31.850
依赖关系甚至可以追溯到

00:03:29.720 --> 00:03:33.500
边缘化JDK的早期，我们

00:03:31.850 --> 00:03:35.870
确实确定必须有一些

00:03:33.500 --> 00:03:38.239
当时我们称为基本模块的核心模块

00:03:35.870 --> 00:03:42.620
现在被称为Java Basin 

00:03:38.239 --> 00:03:45.230
当前模块图，这是

00:03:42.620 --> 00:03:48.410
现在为标准提供的图形

00:03:45.230 --> 00:03:51.769
模块是java c模块，这些是

00:03:48.410 --> 00:03:54.590
以名称命名的模块

00:03:51.769 --> 00:03:57.049
以Java点开头的东西正确

00:03:54.590 --> 00:03:59.660
在底部，您将看到Java点库

00:03:57.049 --> 00:04:02.950
这是系统的核心

00:03:59.660 --> 00:04:04.820
对象所在的Java数据Lang所在的位置

00:04:02.950 --> 00:04:07.850
有几件事要说

00:04:04.820 --> 00:04:09.890
这个图是你学习的时候

00:04:07.850 --> 00:04:12.709
几分钟，你会看到

00:04:09.890 --> 00:04:14.600
在大多数情况下，只有一个

00:04:12.709 --> 00:04:17.570
每个模块中的技术

00:04:14.600 --> 00:04:19.669
有几个地方不是

00:04:17.570 --> 00:04:22.520
完全干净，但大部分

00:04:19.669 --> 00:04:26.270
每个模块一种技术的图表是

00:04:22.520 --> 00:04:28.220
极度分层，这部分是

00:04:26.270 --> 00:04:29.610
因为我们有用于的聚合器模块

00:04:28.220 --> 00:04:31.710
那里的个人资料

00:04:29.610 --> 00:04:34.199
而且它也是分层的，因为

00:04:31.710 --> 00:04:37.680
我们Mabel要做一个干净的分离

00:04:34.199 --> 00:04:39.569
头头和无头，你实际上可以

00:04:37.680 --> 00:04:41.599
采取这些我的模块的子集， 

00:04:39.569 --> 00:04:44.009
具有完全无头的系统

00:04:41.599 --> 00:04:47.759
与此有关的另一个重要的事情

00:04:44.009 --> 00:04:50.189
图是没有周期，并且

00:04:47.759 --> 00:04:51.509
这是这很重要

00:04:50.189 --> 00:04:53.879
你以后去一些

00:04:51.509 --> 00:04:56.969
我在模块系统上的演示

00:04:53.879 --> 00:05:00.689
和亚历克斯明天的演讲

00:04:56.969 --> 00:05:02.430
您将获得更多有关此的信息

00:05:00.689 --> 00:05:05.099
仅在这里向您显示了

00:05:02.430 --> 00:05:07.199
标准模块图如

00:05:05.099 --> 00:05:09.900
 Java点星模块也有一套

00:05:07.199 --> 00:05:14.069
 JDK的模块名称特定

00:05:09.900 --> 00:05:15.300
是从JDK点开始，而我

00:05:14.069 --> 00:05:20.250
不要在这里显示它们只是为了保持

00:05:15.300 --> 00:05:24.500
图上可读的玻璃杯现在让我们

00:05:20.250 --> 00:05:27.210
采用JDK 9构建，这是上周的

00:05:24.500 --> 00:05:30.120
升级版，所以每周都有

00:05:27.210 --> 00:05:34.080
 JDK 9的早期访问版本

00:05:30.120 --> 00:05:36.240
是建一三六，所以我只是在做

00:05:34.080 --> 00:05:39.889
 Java破折号版本只是为了显示

00:05:36.240 --> 00:05:39.889
那是真的

00:05:42.460 --> 00:05:49.060
那不是出于这个我

00:05:45.840 --> 00:05:51.340
只需执行Java-即可运行现有的Java 

00:05:49.060 --> 00:05:53.889
应用程序我随机选择了J 

00:05:51.340 --> 00:05:56.319
编辑器文本编辑器是文本

00:05:53.889 --> 00:05:57.970
已经写过的编辑器

00:05:56.319 --> 00:06:00.099
 Java语言已经存在了

00:05:57.970 --> 00:06:02.680
很长时间我完全不知道

00:06:00.099 --> 00:06:05.860
 J的维护者zuv是否编辑

00:06:02.680 --> 00:06:08.919
必须尝试过JDK 9账单，或者

00:06:05.860 --> 00:06:12.280
不是我尝试过的，它只是作为

00:06:08.919 --> 00:06:14.319
就像在ddk时代所做的那样， 

00:06:12.280 --> 00:06:16.389
在某些平台上的问题，但它只是

00:06:14.319 --> 00:06:18.550
至少在Mac上可以正常运行

00:06:16.389 --> 00:06:21.099
发布重要的观点

00:06:18.550 --> 00:06:22.630
这是一个应用程序

00:06:21.099 --> 00:06:25.690
也许正在使用一堆

00:06:22.630 --> 00:06:28.180
库，如果使用支持的API 

00:06:25.690 --> 00:06:31.090
应该完全像他一样工作

00:06:28.180 --> 00:06:33.400
在jdk时代，存在一些问题， 

00:06:31.090 --> 00:06:35.050
 JDK 9的准备工作涵盖了这些内容

00:06:33.400 --> 00:06:39.099
当我刚才说话时

00:06:35.050 --> 00:06:40.630
午餐时间，所以我在这里找

00:06:39.099 --> 00:06:43.000
现在大部分看起来就像

00:06:40.630 --> 00:06:46.330
普通的JDK让我们看一下

00:06:43.000 --> 00:06:49.060
我还叫通勤者

00:06:46.330 --> 00:06:52.810
命令行选项--列表

00:06:49.060 --> 00:06:55.720
 -模块此选项对Java的作用- 

00:06:52.810 --> 00:06:58.389
列出模块是否列出了

00:06:55.720 --> 00:07:01.060
运行时映像I中的模块

00:06:58.389 --> 00:07:02.710
在几分钟前显示了一个图表

00:07:01.060 --> 00:07:05.020
在此处右侧重复

00:07:02.710 --> 00:07:07.780
幻灯片以及您要在这里得到的

00:07:05.020 --> 00:07:10.750
只是所有模块的列表

00:07:07.780 --> 00:07:12.550
在运行时映像中

00:07:10.750 --> 00:07:14.590
只是为了证明这是

00:07:12.550 --> 00:07:18.340
系统实际上是由这些组成的

00:07:14.590 --> 00:07:21.250
模块，我可以走得更远，我可以给

00:07:18.340 --> 00:07:22.900
列出模块的模块名称，它将

00:07:21.250 --> 00:07:26.409
给我更多信息来描述

00:07:22.900 --> 00:07:28.150
我提到的那些基于Java的模块

00:07:26.409 --> 00:07:32.650
分钟前，它是系统的核心

00:07:28.150 --> 00:07:35.440
因此，如果您可以阅读其中的内容， 

00:07:32.650 --> 00:07:38.830
顶级Java-列出Java模块空间

00:07:35.440 --> 00:07:41.440
点基，所以我问这个问题

00:07:38.830 --> 00:07:43.960
列出基于Java点的运行时

00:07:41.440 --> 00:07:47.680
模块，您在这里看到的是一堆

00:07:43.960 --> 00:07:48.969
出口，这些都用

00:07:47.680 --> 00:07:53.080
软件包名称的条款

00:07:48.969 --> 00:07:53.289
核心模块导出java.lang Java 

00:07:53.080 --> 00:07:55.870
哦

00:07:53.289 --> 00:07:58.360
 Java Net和所有其他核心

00:07:55.870 --> 00:08:01.030
系统的软件包就是

00:07:58.360 --> 00:08:03.580
基于Java的是否明确定义了这些

00:08:01.030 --> 00:08:05.860
是受支持的软件包和api的

00:08:03.580 --> 00:08:13.720
类型在那些包中

00:08:05.860 --> 00:08:15.700
您可以使用我正在接受的基础

00:08:13.720 --> 00:08:18.700
 Java桌面的另一个模块

00:08:15.700 --> 00:08:20.830
 Java桌面模块是

00:08:18.700 --> 00:08:23.500
我们将所有分组的模块

00:08:20.830 --> 00:08:26.080
 headful api是图形用户

00:08:23.500 --> 00:08:30.760
接口不是JavaFX的更多

00:08:26.080 --> 00:08:32.950
 WT和swing API的传统

00:08:30.760 --> 00:08:36.790
当您查看出口清单时

00:08:32.950 --> 00:08:38.530
 Java桌面上您将看到java.awt 

00:08:36.790 --> 00:08:40.960
其他还有一大堆其他子

00:08:38.530 --> 00:08:43.560
 AWT或java.awt中的软件包

00:08:40.960 --> 00:08:47.110
命名空间，您还将看到javax.swing 

00:08:43.560 --> 00:08:50.200
还有很多其他的Ruy，所以

00:08:47.110 --> 00:08:52.720
完全按照Java基础进行了导出，并且

00:08:50.200 --> 00:08:56.560
只是一套不同的包装

00:08:52.720 --> 00:08:59.710
底部是每个

00:08:56.560 --> 00:09:02.350
运行时中的模块描述

00:08:59.710 --> 00:09:05.020
它的依赖性是Java 

00:09:02.350 --> 00:09:07.060
桌面模块需要Java基础

00:09:05.020 --> 00:09:09.070
一切都需要Java基础，我们将看到

00:09:07.060 --> 00:09:13.360
在我们通过演示文稿时

00:09:09.070 --> 00:09:16.330
它需要java xml，有一些

00:09:13.360 --> 00:09:19.690
的API和持久存在

00:09:16.330 --> 00:09:22.870
还有基于XML的东西

00:09:19.690 --> 00:09:26.500
 Java偏好是因为喷气式飞机

00:09:22.870 --> 00:09:29.080
 API可以存储的部分使用

00:09:26.500 --> 00:09:31.090
偏好，有数据

00:09:29.080 --> 00:09:35.220
传输API就是那个

00:09:31.090 --> 00:09:37.420
导出DWTS数据传输API 

00:09:35.220 --> 00:09:38.530
所以重要的是

00:09:37.420 --> 00:09:40.390
可以经历每个

00:09:38.530 --> 00:09:43.420
该图中的模块，我可以得到

00:09:40.390 --> 00:09:45.520
这个被指定给他们列出

00:09:43.420 --> 00:09:48.580
模块，我可以确切地看到

00:09:45.520 --> 00:09:53.740
 api他们出口了吗

00:09:48.580 --> 00:09:54.760
它们是否依赖其他模块

00:09:53.740 --> 00:09:56.260
作为这件事的一部分

00:09:54.760 --> 00:09:58.480
简介我只想提及

00:09:56.260 --> 00:10:00.730
 Java链接器标记在

00:09:58.480 --> 00:10:02.560
主题演讲以及他使用Java的地方

00:10:00.730 --> 00:10:05.050
链接器以创建一个小的运行时

00:10:02.560 --> 00:10:07.660
我认为只有Java基本模块

00:10:05.050 --> 00:10:08.819
这是一个64位的图像，我认为

00:10:07.660 --> 00:10:12.029
原为

00:10:08.819 --> 00:10:15.660
压缩到17兆字节

00:10:12.029 --> 00:10:19.919
 Java链接器是链接的工具

00:10:15.660 --> 00:10:23.189
一组模块并创建运行时

00:10:19.919 --> 00:10:27.149
在今天的早些时候的演讲中，我

00:10:23.189 --> 00:10:29.339
谈到模块完全模糊

00:10:27.149 --> 00:10:31.519
两者之间的历史区别

00:10:29.339 --> 00:10:33.869
我们知道是杰里和JDK 

00:10:31.519 --> 00:10:35.819
杰瑞只是过去的运行时间

00:10:33.869 --> 00:10:38.189
 JDK是运行时加上工具

00:10:35.819 --> 00:10:39.959
过去现在我们现在一切都在

00:10:38.189 --> 00:10:41.759
分为模块，您可以将它们组合

00:10:39.959 --> 00:10:43.709
您甚至可以用不同的方式链接您的

00:10:41.759 --> 00:10:44.639
拥有自己的模块，我将在稍后显示

00:10:43.709 --> 00:10:47.729
在演讲中

00:10:44.639 --> 00:10:50.999
创建自己的运行时图像

00:10:47.729 --> 00:10:54.119
您可以实际分发

00:10:50.999 --> 00:10:56.309
运行时映像，并具有一个bin 

00:10:54.119 --> 00:10:58.289
您将在其中找到类似工具的目录

00:10:56.309 --> 00:11:00.839
 Java启动器，它很舒适

00:10:58.289 --> 00:11:03.269
具有以下配置的直肠

00:11:00.839 --> 00:11:05.220
是用户可编辑的配置，然后

00:11:03.269 --> 00:11:08.869
运行时还有其他部分

00:11:05.220 --> 00:11:11.549
不应编辑的图像

00:11:08.869 --> 00:11:13.109
所以我们只运行链接器命令

00:11:11.549 --> 00:11:15.059
就算你没看到这个

00:11:13.109 --> 00:11:17.429
在主题演讲中只是为了展示

00:11:15.059 --> 00:11:18.839
真的发生了，所以在这个舔盖伦

00:11:17.429 --> 00:11:21.089
命令+ J链接是名称

00:11:18.839 --> 00:11:23.639
链接器我给它一个模块路径是

00:11:21.089 --> 00:11:25.470
只是将其视为目录

00:11:23.639 --> 00:11:28.709
将在其中找到文件系统

00:11:25.470 --> 00:11:31.470
我告诉模块添加

00:11:28.709 --> 00:11:32.970
我命名为Java桌面的模块

00:11:31.470 --> 00:11:35.429
幻灯片中的模块几分钟

00:11:32.970 --> 00:11:39.419
以前，我将使我们成为一个

00:11:35.429 --> 00:11:41.489
目录称为我的图像，然后一次

00:11:39.419 --> 00:11:43.829
转动了几秒钟

00:11:41.489 --> 00:11:46.229
然后输入列出的Java 

00:11:43.829 --> 00:11:48.839
该生成的运行时映像上的模块

00:11:46.229 --> 00:11:51.989
我在那里看到它产生了一个

00:11:48.839 --> 00:11:53.519
如果只有五个模块，则运行时映像

00:11:51.989 --> 00:11:55.589
你记得几分钟前我展示了

00:11:53.519 --> 00:11:57.600
 Java桌面模块以及最后

00:11:55.589 --> 00:12:00.299
有这需要Java基础吗

00:11:57.600 --> 00:12:02.309
 XML所需的数据传输等

00:12:00.299 --> 00:12:04.559
这些是已经

00:12:02.309 --> 00:12:08.339
链接在一起以产生此运行时

00:12:04.559 --> 00:12:10.319
现在我们回到小J 

00:12:08.339 --> 00:12:13.470
我在其中之一中使用的编辑器示例

00:12:10.319 --> 00:12:17.159
我将使用Java的第一张幻灯片-gr 

00:12:13.470 --> 00:12:19.879
 j编辑，我将运行J编辑器

00:12:17.159 --> 00:12:22.769
有了这个小的运行时间

00:12:19.879 --> 00:12:25.319
生产，所以如果我只有平台

00:12:22.769 --> 00:12:27.989
在这个图像中， 

00:12:25.319 --> 00:12:30.329
创建的，我可以用它来运行我的

00:12:27.989 --> 00:12:32.639
现有的应用程序，因此

00:12:30.329 --> 00:12:34.199
是分销的一大进步

00:12:32.639 --> 00:12:37.589
因为你可以分发一个小

00:12:34.199 --> 00:12:41.759
应用程序的运行时，因此

00:12:37.589 --> 00:12:44.489
第一部分的简要概述是

00:12:41.759 --> 00:12:47.339
我们已经离开了这个巨大的整体

00:12:44.489 --> 00:12:50.429
那可怕的大量依赖

00:12:47.339 --> 00:12:55.439
和图中的周期，我们已经移至

00:12:50.429 --> 00:12:57.989
每个主要是内聚模块的集合，每个

00:12:55.439 --> 00:13:02.610
这些模块具有清晰的导出集

00:12:57.989 --> 00:13:05.279
我们看到两个例子和依赖关系，如果

00:13:02.610 --> 00:13:08.549
你，如果你继续上课

00:13:05.279 --> 00:13:10.649
永远退休，直到退休

00:13:08.549 --> 00:13:14.009
使用模块，无论您是否知道

00:13:10.649 --> 00:13:17.639
不是因为平台本身就是

00:13:14.009 --> 00:13:21.059
是模块化的，我很快就展示了

00:13:17.639 --> 00:13:23.549
您是创建您的

00:13:21.059 --> 00:13:26.639
自己的运行时映像，并带有一个小的

00:13:23.549 --> 00:13:28.259
平台模块的子集，以便

00:13:26.639 --> 00:13:30.119
标签线是模块化的

00:13:28.259 --> 00:13:33.179
开发从模块化开始

00:13:30.119 --> 00:13:36.600
平台的一部分

00:13:33.179 --> 00:13:40.019
我现在要从头开始

00:13:36.600 --> 00:13:42.119
开始并介绍什么是模块

00:13:40.019 --> 00:13:43.949
特别是你实际去的样子

00:13:42.119 --> 00:13:45.749
并自己编写一个模块，我们开始

00:13:43.949 --> 00:13:48.059
与概念，并开始建立

00:13:45.749 --> 00:13:50.459
并编写我们自己的模块，所以这是一个

00:13:48.059 --> 00:13:53.279
非常专心地介绍模块

00:13:50.459 --> 00:13:57.089
假设你从未见过

00:13:53.279 --> 00:14:00.149
他们先从基础开始

00:13:57.089 --> 00:14:02.009
每个模块在前面都有一个名称

00:14:00.149 --> 00:14:03.959
在Java上以Java为基础滑动

00:14:02.009 --> 00:14:07.649
在桌面上，我们看到了更多的Java点

00:14:03.959 --> 00:14:09.179
在此示例中，星形模块为我的模块

00:14:07.649 --> 00:14:12.029
走了，那么我要开始的是

00:14:09.179 --> 00:14:14.069
所谓的统计点核心假设它是一个

00:14:12.029 --> 00:14:18.419
我要去的粉丝统计数据库

00:14:14.069 --> 00:14:22.709
将模块中的代码制作成一个模块

00:14:18.419 --> 00:14:25.230
这个模块是由软件包组织的

00:14:22.709 --> 00:14:28.319
示例假设我的模块有两个

00:14:25.230 --> 00:14:31.499
软件包comm Acme统计核心集群

00:14:28.319 --> 00:14:33.809
群集一个遗憾的群集和通信

00:14:31.499 --> 00:14:35.669
 Acme stats的核心回归是

00:14:33.809 --> 00:14:36.570
我的代码所在的软件包

00:14:35.669 --> 00:14:38.550
这个模块我

00:14:36.570 --> 00:14:41.910
刚刚列出样本类型名称

00:14:38.550 --> 00:14:44.850
在那里给你一个类型的想法

00:14:41.910 --> 00:14:47.460
可能在此模块中

00:14:44.850 --> 00:14:49.470
 Java代码我的模块可能有资源

00:14:47.460 --> 00:14:50.310
它可能有本机代码

00:14:49.470 --> 00:14:52.530
组态

00:14:50.310 --> 00:14:53.970
它可能包含我们不打算使用的命令

00:14:52.530 --> 00:14:57.090
在介绍中了解所有这些

00:14:53.970 --> 00:15:02.870
但它你的模块可能有那些

00:14:57.090 --> 00:15:06.750
模块的自我描述是

00:15:02.870 --> 00:15:10.290
用称为模块的源文件表示

00:15:06.750 --> 00:15:15.360
 -作为模块的信息Java 

00:15:10.290 --> 00:15:19.440
按照惯例声明此来源

00:15:15.360 --> 00:15:22.500
文件放置在的根目录中

00:15:19.440 --> 00:15:25.890
您的模块源代码，因此

00:15:22.500 --> 00:15:28.290
就像在顶部

00:15:25.890 --> 00:15:30.690
模块声明的语法是

00:15:28.290 --> 00:15:32.760
模块空间，然后是模块名称

00:15:30.690 --> 00:15:35.760
然后我们打开大括号关闭

00:15:32.760 --> 00:15:39.390
大括号，我们将其充实

00:15:35.760 --> 00:15:43.140
接下来的几张幻灯片，我们将

00:15:39.390 --> 00:15:46.710
假设我们的统计核心模块

00:15:43.140 --> 00:15:49.370
对此有番石榴的依赖

00:15:46.710 --> 00:15:52.140
演示文稿假设番石榴是我的模块

00:15:49.370 --> 00:15:56.580
用需求表达这种依赖

00:15:52.140 --> 00:15:59.190
因此，在我的模块声明中

00:15:56.580 --> 00:16:00.750
说如果我开始建造需要番石榴

00:15:59.190 --> 00:16:03.540
在右侧的模块图

00:16:00.750 --> 00:16:06.060
幻灯片所在的办公室

00:16:03.540 --> 00:16:09.600
我们看到了对番石榴的依赖

00:16:06.060 --> 00:16:11.700
模块将添加第二个依赖项

00:16:09.600 --> 00:16:14.010
将假定它取决于Java 

00:16:11.700 --> 00:16:15.990
续集模块，所以这是一个平台

00:16:14.010 --> 00:16:19.440
模块，如果您查看了模块图

00:16:15.990 --> 00:16:21.450
我之前在Java续集上展示的冰是

00:16:19.440 --> 00:16:22.950
实际上在那儿，你只是我们去了

00:16:21.450 --> 00:16:25.350
通过它，我们没有看到所有

00:16:22.950 --> 00:16:27.930
的模块假定Java 

00:16:25.350 --> 00:16:31.680
续集模块是导出的模块

00:16:27.930 --> 00:16:36.570
 Java续集API或JDBC API是

00:16:31.680 --> 00:16:37.920
有时我们现在知道开始构建

00:16:36.570 --> 00:16:40.140
在这里的模块图，我们有

00:16:37.920 --> 00:16:42.210
我们有三个，三个模块

00:16:40.140 --> 00:16:43.920
所以我们有了统计

00:16:42.210 --> 00:16:47.010
分数，我们要加番石榴

00:16:43.920 --> 00:16:49.939
向该模块中添加另一个模块

00:16:47.010 --> 00:16:51.859
该图假设我们有一个统计数据

00:16:49.939 --> 00:16:54.439
请参见盟军模块命令行界面

00:16:51.859 --> 00:16:57.470
假设这是某种

00:16:54.439 --> 00:17:03.199
命令行工具

00:16:57.470 --> 00:17:05.990
统计核心模块，我们对此感到抱歉

00:17:03.199 --> 00:17:07.759
可能在最后介绍了

00:17:05.990 --> 00:17:11.269
幻灯片这是具有

00:17:07.759 --> 00:17:13.399
对Java SQL的依赖，所以我们走了

00:17:11.269 --> 00:17:15.620
称为附加模块的数量

00:17:13.399 --> 00:17:18.259
 CLI取决于统计信息的服务

00:17:15.620 --> 00:17:21.470
核心和Java续集统计核心

00:17:18.259 --> 00:17:23.480
在番石榴上每个模块都取决于Java 

00:17:21.470 --> 00:17:26.089
根据他们是否在自己的声明

00:17:23.480 --> 00:17:29.149
模块声明不是因为

00:17:26.089 --> 00:17:33.440
最终的一切都是

00:17:29.149 --> 00:17:35.539
现在让我们开始java.lang对象

00:17:33.440 --> 00:17:37.429
充实一点

00:17:35.539 --> 00:17:40.039
然后我们开始看Java续集

00:17:37.429 --> 00:17:41.840
模块，如果我要列出模块

00:17:40.039 --> 00:17:44.570
 Java续集我实际上会看到它

00:17:41.840 --> 00:17:47.179
取决于java xml和jet取决于

00:17:44.570 --> 00:17:48.830
 java记录对Java xml的依赖

00:17:47.179 --> 00:17:51.169
可能会令人惊讶，但如果您看

00:17:48.830 --> 00:17:54.559
在Java续集包中

00:17:51.169 --> 00:17:58.519
您实际上会发现有

00:17:54.559 --> 00:18:01.429
端口和存储以及xml in 

00:17:58.519 --> 00:18:06.919
数据库，因此它取决于

00:18:01.429 --> 00:18:09.830
一个模块依赖时的XML API 

00:18:06.919 --> 00:18:12.740
然后我们说另一个模块

00:18:09.830 --> 00:18:17.509
模块读取第二个模块，因此

00:18:12.740 --> 00:18:20.179
重要的是统计核心模块

00:18:17.509 --> 00:18:24.379
取决于番石榴，我们说统计核心

00:18:20.179 --> 00:18:28.389
读取guava统计信息CLI取决于统计信息

00:18:24.379 --> 00:18:32.450
得分，我们说stat c-like读m 

00:18:28.389 --> 00:18:34.039
统计得分这种可读性关系

00:18:32.450 --> 00:18:36.259
我们在接下来的几个中建立

00:18:34.039 --> 00:18:38.269
幻灯片实际上是

00:18:36.259 --> 00:18:42.590
标明的可靠配置

00:18:38.269 --> 00:18:45.740
现在在主题演讲中提到了

00:18:42.590 --> 00:18:49.070
让我们来看一下模块的一小部分

00:18:45.740 --> 00:18:52.250
图，我们只看stat CLI 

00:18:49.070 --> 00:18:56.539
取决于最终的Java续集

00:18:52.250 --> 00:18:58.399
取决于Java日志，我们添加一点

00:18:56.539 --> 00:19:02.090
一点代码，这样您就可以

00:18:58.399 --> 00:19:04.050
关于那些代码可能是什么的想法

00:19:02.090 --> 00:19:09.250
模组

00:19:04.050 --> 00:19:13.480
让我们看看吧，让我们开始吧

00:19:09.250 --> 00:19:16.660
首先使用Java续集，以便导出

00:19:13.480 --> 00:19:18.940
 Java SQL包中有一种类型

00:19:16.660 --> 00:19:21.790
看到驱动程序的软件包

00:19:18.940 --> 00:19:24.520
 JDBC可能听说过Java SQL 

00:19:21.790 --> 00:19:26.980
驱动程序中有一种方法

00:19:24.520 --> 00:19:29.470
一个公共方法公共类， 

00:19:26.980 --> 00:19:34.420
返回一个称为的记录器实例

00:19:29.470 --> 00:19:38.400
让父记录器让我们假设

00:19:34.420 --> 00:19:41.350
 stat CLI，我们有一些代码

00:19:38.400 --> 00:19:44.710
创建一个Java续集驱动程序，然后

00:19:41.350 --> 00:19:46.270
调用其获取父记录器，然后调用

00:19:44.710 --> 00:19:47.680
加载方法，所以您有一些方法

00:19:46.270 --> 00:19:50.530
调用链实际上正在进行

00:19:47.680 --> 00:19:55.660
这到底是怎么回事

00:19:50.530 --> 00:19:58.050
工作状态CLI仅取决于Java 

00:19:55.660 --> 00:20:00.670
因此，续集仅读取Java续集

00:19:58.050 --> 00:20:04.890
这些类型在发生了什么

00:20:00.670 --> 00:20:07.420
在stat CLI的日志模块中

00:20:04.890 --> 00:20:08.980
一无所知

00:20:07.420 --> 00:20:11.760
没有什么在代码中什么都没有

00:20:08.980 --> 00:20:15.580
立即告诉您它正在使用

00:20:11.760 --> 00:20:18.670
日志记录模块现在是我们可以使用的一种方法

00:20:15.580 --> 00:20:21.970
这样做是因为我们可以改变

00:20:18.670 --> 00:20:24.970
 stats eli的模块声明有一个

00:20:21.970 --> 00:20:28.060
对Java的直接依赖

00:20:24.970 --> 00:20:31.210
日志记录将起作用，但这将是一个

00:20:28.060 --> 00:20:33.550
有点令人失望的用户

00:20:31.210 --> 00:20:36.130
 Java的续集我不知道全部

00:20:33.550 --> 00:20:37.750
我们是Java续集的用户，我不是

00:20:36.130 --> 00:20:40.720
对它的内容一无所知

00:20:37.750 --> 00:20:43.750
依赖关系可能是模块

00:20:40.720 --> 00:20:47.410
系统通过引入

00:20:43.750 --> 00:20:49.510
和修饰符称为可传递的，因此在

00:20:47.410 --> 00:20:50.980
 jdk 9公共账单这实际上是

00:20:49.510 --> 00:20:52.420
在早期访问版本中称为public 

00:20:50.980 --> 00:20:54.400
因为拼图被称为传递我

00:20:52.420 --> 00:20:56.110
前面提到的关于JDK 9的不是

00:20:54.400 --> 00:20:59.020
是最终的，但这是当前的

00:20:56.110 --> 00:21:02.410
提案是什么，拼图中有什么

00:20:59.020 --> 00:21:05.770
早期访问费用，因此在Java续集中

00:21:02.410 --> 00:21:09.400
模块及其模块声明说

00:21:05.770 --> 00:21:12.880
需要传递Java日志记录

00:21:09.400 --> 00:21:16.250
这意味着任何依赖

00:21:12.880 --> 00:21:21.440
在Java续集里亚尔将阅读

00:21:16.250 --> 00:21:23.000
 Java日志记录又如何构建

00:21:21.440 --> 00:21:28.760
现在只需几秒钟的可读性

00:21:23.000 --> 00:21:31.910
 graph我是stat CLI我需要Java续集

00:21:28.760 --> 00:21:33.380
因此，我阅读了Java续集Java续集

00:21:31.910 --> 00:21:38.360
不需要传递和Java 

00:21:33.380 --> 00:21:43.520
记录日志，因此stat CLI读取Java 

00:21:38.360 --> 00:21:45.590
登录alex是在他们的幕后

00:21:43.520 --> 00:21:47.660
明天他会经历很多

00:21:45.590 --> 00:21:49.880
更多关于这个，但这就是

00:21:47.660 --> 00:21:51.830
可读性图是这样，所以我开始

00:21:49.880 --> 00:21:53.960
仅使图形中的黑色边缘变黑

00:21:51.830 --> 00:21:56.150
当我将其视为依赖图时

00:21:53.960 --> 00:21:58.520
开始添加我已经建立的手臂边缘

00:21:56.150 --> 00:22:00.260
这里的可读性图

00:21:58.520 --> 00:22:02.990
考虑到需求

00:22:00.260 --> 00:22:10.910
传递或暗示可读性为

00:22:02.990 --> 00:22:12.470
我们称之为确定，那就是

00:22:10.910 --> 00:22:16.010
可读性我想做的下一件事

00:22:12.470 --> 00:22:18.410
看是出口然后结合

00:22:16.010 --> 00:22:24.470
一起展示如何支持

00:22:18.410 --> 00:22:27.560
和可访问性，因此除了

00:22:24.470 --> 00:22:29.960
具有require子句的模块可以

00:22:27.560 --> 00:22:31.660
也有出口条款，我们看到

00:22:29.960 --> 00:22:38.270
在Java基础上，我们看到了Java 

00:22:31.660 --> 00:22:41.240
 Java桌面，我们的模块统计信息核心将

00:22:38.270 --> 00:22:43.190
导出到假定的软件包

00:22:41.240 --> 00:22:44.900
导出聚类和

00:22:43.190 --> 00:22:48.050
我在其中展示的回归软件包

00:22:44.900 --> 00:22:49.790
第一张幻灯片中的一张让我们

00:22:48.050 --> 00:22:53.690
假设还有一个内部

00:22:49.790 --> 00:22:58.190
包，它不是统计核心

00:22:53.690 --> 00:23:02.180
该程序包是平静痤疮统计数据核心的API 

00:22:58.190 --> 00:23:05.000
内部基本上我们要做的是

00:23:02.180 --> 00:23:08.090
我们已经划分了类型和包装

00:23:05.000 --> 00:23:10.250
在这个库中分为两个

00:23:08.090 --> 00:23:12.350
是其公共API的一部分， 

00:23:10.250 --> 00:23:14.480
该模块之外的内部内容

00:23:12.350 --> 00:23:19.060
旨在直接使用

00:23:14.480 --> 00:23:23.020
他们选择他们超过了

00:23:19.060 --> 00:23:25.310
 comm Acme stats核心内部实现了

00:23:23.020 --> 00:23:28.340
这是对此的视觉指示

00:23:25.310 --> 00:23:31.010
滑动以说不出任何类型

00:23:28.340 --> 00:23:34.010
包可以在

00:23:31.010 --> 00:23:35.420
现在，我们将其与

00:23:34.010 --> 00:23:42.560
我们看了几分钟的可读性

00:23:35.420 --> 00:23:46.420
之前stat CLI读取stat核心记住了

00:23:42.560 --> 00:23:46.420
不需要，因此它会读取它

00:23:47.050 --> 00:23:54.170
如果那是氯，抱歉，如果stat CLI 

00:23:50.330 --> 00:23:58.430
读取统计信息分数，然后它可以访问任何

00:23:54.170 --> 00:24:02.180
导出包中的公共类型

00:23:58.430 --> 00:24:04.970
根据统计得分，它无法读取任何内容

00:24:02.180 --> 00:24:07.430
无法访问内部的任何类型

00:24:04.970 --> 00:24:08.870
软件包，因为它们没有被导出

00:24:07.430 --> 00:24:11.900
这是两条路

00:24:08.870 --> 00:24:14.210
我阅读了该模块和其他模块

00:24:11.900 --> 00:24:15.860
出口一些包裹，这让我

00:24:14.210 --> 00:24:22.130
访问那些公共类型

00:24:15.860 --> 00:24:25.370
如果if stat CLI没有，则打包

00:24:22.130 --> 00:24:26.600
在该模块中读取统计信息得分没有

00:24:25.370 --> 00:24:28.610
可以访问

00:24:26.600 --> 00:24:33.290
没有一个公共类型，甚至在

00:24:28.610 --> 00:24:36.590
导出的软件包是可访问的，因此

00:24:33.290 --> 00:24:38.300
读取它很重要

00:24:36.590 --> 00:24:40.790
公共类型和导出的包

00:24:38.300 --> 00:24:44.840
如果不读就可以访问

00:24:40.790 --> 00:24:50.420
他们无法访问，所以很大

00:24:44.840 --> 00:24:53.300
从这个设计，那个公众没有

00:24:50.420 --> 00:24:57.200
不再意味着可访问，这是一个

00:24:53.300 --> 00:24:59.990
的重大变化

00:24:57.200 --> 00:25:03.140
平台，但这是因为我们

00:24:59.990 --> 00:25:06.410
改造模块并走向成熟

00:25:03.140 --> 00:25:08.690
平台，这是这个，这是

00:25:06.410 --> 00:25:11.360
这就是我们最少要做的

00:25:08.690 --> 00:25:13.760
破坏好了，有基本的

00:25:11.360 --> 00:25:15.830
我现在想通过一些概念

00:25:13.760 --> 00:25:18.650
命令或在

00:25:15.830 --> 00:25:21.020
结束以及关于我们的实际走向

00:25:18.650 --> 00:25:22.370
编译模块以及我们将如何进行

00:25:21.020 --> 00:25:23.570
打包它们，我们将如何运行

00:25:22.370 --> 00:25:26.390
他们我想经历一些

00:25:23.570 --> 00:25:30.350
命令来做所有这些事情，我们将

00:25:26.390 --> 00:25:34.250
从我们的统计核心模块开始，我们

00:25:30.350 --> 00:25:35.720
将要编译它，所以我已经

00:25:34.250 --> 00:25:39.440
有很多源代码

00:25:35.720 --> 00:25:41.539
组织在名为SRC的目录中

00:25:39.440 --> 00:25:43.129
统计核心

00:25:41.539 --> 00:25:45.019
此目录中的重要内容

00:25:43.129 --> 00:25:49.129
要理解的结构是我已经把

00:25:45.019 --> 00:25:51.619
模块名称插入文件路径

00:25:49.129 --> 00:25:55.629
模块源的顶级目录

00:25:51.619 --> 00:25:55.629
代码我有模块声明和

00:25:56.049 --> 00:26:00.919
在统计核心下，我已经拥有了所有

00:25:58.369 --> 00:26:03.200
适用于所有

00:26:00.919 --> 00:26:06.529
当我在这个模块中的类型

00:26:03.200 --> 00:26:09.139
编译它，我得到每个的类文件

00:26:06.529 --> 00:26:12.259
熟悉的Java文件之一

00:26:09.139 --> 00:26:15.950
我们看到输出的东西

00:26:12.259 --> 00:26:17.840
写的目录反映相同

00:26:15.950 --> 00:26:19.720
结构和与之相同的类文件

00:26:17.840 --> 00:26:22.009
您在源目录中看到的

00:26:19.720 --> 00:26:23.869
忽略可能

00:26:22.009 --> 00:26:27.139
为内部类生成等等

00:26:23.869 --> 00:26:29.029
在我正在使用的Java C命令上

00:26:27.139 --> 00:26:31.759
这里有几个选择

00:26:29.029 --> 00:26:36.950
可能在第一个之前没有看过

00:26:31.759 --> 00:26:39.499
是--模块路径是

00:26:36.950 --> 00:26:42.229
编译器告诉它的选项

00:26:39.499 --> 00:26:44.779
在哪里找到依赖项，请记住我们

00:26:42.229 --> 00:26:46.309
统计得分取决于番石榴在哪里

00:26:44.779 --> 00:26:48.799
将要找到的番石榴模块

00:26:46.309 --> 00:26:50.659
要在模块路径上找到它

00:26:48.799 --> 00:26:52.279
对于我们在这里建立的示例

00:26:50.659 --> 00:26:55.580
假设我们有一个目录

00:26:52.279 --> 00:26:57.080
名为EM的目录中的模块

00:26:55.580 --> 00:26:59.929
唇，我们将通过所有这些工作

00:26:57.080 --> 00:27:02.269
随着我们的前进，我就在跑步

00:26:59.929 --> 00:27:03.889
一个Java C命令，我正在全部编译

00:27:02.269 --> 00:27:06.950
此模块的源代码

00:27:03.889 --> 00:27:09.229
到输出目录中，所以

00:27:06.950 --> 00:27:11.269
关于模块路径仅需说的是

00:27:09.229 --> 00:27:13.700
当我解决依赖关系时

00:27:11.269 --> 00:27:16.940
将要找到这些依赖

00:27:13.700 --> 00:27:20.690
模块路径模块路径不是

00:27:16.940 --> 00:27:23.570
等于它没有的类路径

00:27:20.690 --> 00:27:25.519
遭受所有的问题

00:27:23.570 --> 00:27:27.529
没有分裂的课程路径

00:27:25.519 --> 00:27:29.479
包里有很多问题

00:27:27.529 --> 00:27:31.190
我们已经学会了上课的路

00:27:29.479 --> 00:27:33.320
从所有这些，并提出了

00:27:31.190 --> 00:27:37.039
一个更可靠的机制是

00:27:33.320 --> 00:27:38.869
模块路径，所以当您发现

00:27:37.039 --> 00:27:41.989
您搜索的模块下载模块

00:27:38.869 --> 00:27:43.669
与以前一样的路径，可以将它们打包

00:27:41.989 --> 00:27:46.249
它们可以以不同的形式爆炸

00:27:43.669 --> 00:27:49.050
如果同一模块中有两个模块

00:27:46.249 --> 00:27:51.059
然后目录

00:27:49.050 --> 00:27:52.800
模块系统将放弃它不是

00:27:51.059 --> 00:27:54.450
选择哪个

00:27:52.800 --> 00:27:56.370
您要寻找的模块

00:27:54.450 --> 00:27:58.770
解决这类问题，所以不是

00:27:56.370 --> 00:28:00.450
这实际上是非常简单的

00:27:58.770 --> 00:28:02.309
不会在

00:28:00.450 --> 00:28:04.050
我将在星期三的黑客会议上

00:28:02.309 --> 00:28:06.290
稍后的链接以显示

00:28:04.050 --> 00:28:08.580
模块路径是及其工作方式

00:28:06.290 --> 00:28:10.440
重要的是要了解的是

00:28:08.580 --> 00:28:12.270
那就是找到模块的地方

00:28:10.440 --> 00:28:16.110
它不会像

00:28:12.270 --> 00:28:18.480
上课的路径，所以现在我们要

00:28:16.110 --> 00:28:20.429
这次去编译另一个模块

00:28:18.480 --> 00:28:25.920
我们将编译stat CLI，因此我们已经

00:28:20.429 --> 00:28:27.780
编译和统计核心模块

00:28:25.920 --> 00:28:29.760
编译到mods目录中

00:28:27.780 --> 00:28:33.330
我们现在要编译统计数据Eli 

00:28:29.760 --> 00:28:34.710
统计Eli需要统计得分，我们

00:28:33.330 --> 00:28:37.110
这次给出两个模块路径

00:28:34.710 --> 00:28:38.880
目录，因为这次我们

00:28:37.110 --> 00:28:40.050
希望能够找到统计得分

00:28:38.880 --> 00:28:43.070
我们已经编译到mod中

00:28:40.050 --> 00:28:46.080
目录与以前一样，已从

00:28:43.070 --> 00:28:48.690
 Java文件树，您已经生成了

00:28:46.080 --> 00:28:50.520
与编译器一起使用一类类文件

00:28:48.690 --> 00:28:53.850
所以模块信息被编译为

00:28:50.520 --> 00:28:59.520
从源到二进制之前

00:28:53.850 --> 00:29:01.020
现在是模块信息点类的表单

00:28:59.520 --> 00:29:05.100
我们已经编译了两个模块

00:29:01.020 --> 00:29:11.040
核心和统计信息CLI，让我们来看一下

00:29:05.100 --> 00:29:12.600
 stat CLI代码作为模块，所以这是我们的

00:29:11.040 --> 00:29:14.370
现在运行它的命令第一件事是

00:29:12.600 --> 00:29:16.700
我在这里把戏，我们有一个

00:29:14.370 --> 00:29:18.690
模块路径的简称--P 

00:29:16.700 --> 00:29:20.640
如此广泛，长久以来

00:29:18.690 --> 00:29:22.470
我已替换的命令行选项-- 

00:29:20.640 --> 00:29:25.170
模块-带有-P的路径，因为那是

00:29:22.470 --> 00:29:27.330
在JDK 9中找到的简短形式是

00:29:25.170 --> 00:29:29.490
新弧很多新的选择

00:29:27.330 --> 00:29:31.440
我有一个长格式和一个短格式

00:29:29.490 --> 00:29:34.559
切换为简写形式

00:29:31.440 --> 00:29:36.960
幻灯片，我也在用另一个短片

00:29:34.559 --> 00:29:39.870
选项-M我告诉它主要的

00:29:36.960 --> 00:29:41.760
模块是这个最初看起来

00:29:39.870 --> 00:29:43.320
两者的一点都会缩短

00:29:41.760 --> 00:29:48.780
我们通过下一个

00:29:43.320 --> 00:29:51.840
几张幻灯片-M告诉我告诉告诉

00:29:48.780 --> 00:29:53.790
运行时什么初始模块

00:29:51.840 --> 00:29:56.220
是什么，主要是什么，所以有

00:29:53.790 --> 00:29:58.380
它的两个部分将在哪里找到

00:29:56.220 --> 00:30:00.690
 stat CLI模块，它将在

00:29:58.380 --> 00:30:02.429
模块路径，它将加载该模块并

00:30:00.690 --> 00:30:06.809
它会找到入口点

00:30:02.429 --> 00:30:08.759
这里是平静痤疮统计CLI主要所以

00:30:06.809 --> 00:30:11.460
我们实际上是在

00:30:08.759 --> 00:30:13.259
该命令和那个模块

00:30:11.460 --> 00:30:15.360
提示及时，欢迎使用stat CLI 

00:30:13.259 --> 00:30:20.159
只是假设这就是这些

00:30:15.360 --> 00:30:22.139
现在重新启动时运行两次，让我们看看

00:30:20.159 --> 00:30:24.529
这里到底发生了什么，所以当我

00:30:22.139 --> 00:30:26.879
键入该命令实际发生了什么

00:30:24.529 --> 00:30:28.759
所以记住这是我们的

00:30:26.879 --> 00:30:31.710
几分钟前的依赖图

00:30:28.759 --> 00:30:34.950
统计依赖CLI的统计课程

00:30:31.710 --> 00:30:36.809
如我所说，取决于统计SQL 

00:30:34.950 --> 00:30:39.779
早先每个模块都依赖Java 

00:30:36.809 --> 00:30:45.210
基础，因此您有优势

00:30:39.779 --> 00:30:47.159
从stat CLI到Java base，这是

00:30:45.210 --> 00:30:48.659
当我计算可及性时已满

00:30:47.159 --> 00:30:51.419
关闭，这是完全依赖

00:30:48.659 --> 00:30:54.269
像以前一样实际发生在

00:30:51.419 --> 00:30:56.909
键入Java时启动-M因为

00:30:54.269 --> 00:30:59.129
发生的是什么时候尝试

00:30:56.909 --> 00:31:00.960
解决stat CLI模块的问题，就像哦

00:30:59.129 --> 00:31:02.279
这取决于统计得分，因此

00:31:00.960 --> 00:31:04.679
我必须解决那个模块

00:31:02.279 --> 00:31:06.840
取决于番石榴等等

00:31:04.679 --> 00:31:08.940
您实际上是在启动时计算的

00:31:06.840 --> 00:31:10.980
我输入Java-我实际上是M 

00:31:08.940 --> 00:31:12.389
实际上计算了传递闭包

00:31:10.980 --> 00:31:14.009
实际上已经走得更远了

00:31:12.389 --> 00:31:15.419
计算到可读性图

00:31:14.009 --> 00:31:17.129
记住我的可读性图

00:31:15.419 --> 00:31:18.450
添加了这些其他引擎，因为

00:31:17.129 --> 00:31:22.080
的需求传递

00:31:18.450 --> 00:31:24.389
所以在启动时我做了Java-Ian 

00:31:22.080 --> 00:31:26.190
运行时产生了这个运行时

00:31:24.389 --> 00:31:29.070
绘制并解析所有这些模块

00:31:26.190 --> 00:31:31.409
确保他们在那里

00:31:29.070 --> 00:31:33.419
都可以位于模块路径上

00:31:31.409 --> 00:31:37.320
在运行时映像中，所以实际上

00:31:33.419 --> 00:31:38.490
启动时会发生什么，所以我无法

00:31:37.320 --> 00:31:41.009
如果某事真的开始

00:31:38.490 --> 00:31:42.929
如果我尝试启动时缺少

00:31:41.009 --> 00:31:46.230
番石榴丢失，然后我会得到一个错误

00:31:42.929 --> 00:31:47.519
在启动时，如果您想了解更多有关

00:31:46.230 --> 00:31:51.029
在启动时会发生什么

00:31:47.519 --> 00:31:52.440
 Java上有一个诊断选项

00:31:51.029 --> 00:31:53.669
启动器会打印一点

00:31:52.440 --> 00:31:55.860
跟踪我们将不得不在

00:31:53.669 --> 00:31:57.169
在jdk 9中追踪得更好，但这是

00:31:55.860 --> 00:32:00.059
您实际看到的内容的一部分

00:31:57.169 --> 00:32:03.720
当您尝试执行该命令时，我

00:32:00.059 --> 00:32:05.669
在上一张幻灯片中做了

00:32:03.720 --> 00:32:08.249
您将获得跟踪信息，就好像找到了一样

00:32:05.669 --> 00:32:11.680
它在哪里定位它们的模块

00:32:08.249 --> 00:32:14.990
 y也是

00:32:11.680 --> 00:32:18.050
是的，到目前为止，我编写的所有内容

00:32:14.990 --> 00:32:18.500
我已经跑了，但是当我想编译的时候

00:32:18.050 --> 00:32:20.120
东西

00:32:18.500 --> 00:32:22.250
一切都在文件系统上爆炸了

00:32:20.120 --> 00:32:24.230
如果我在mods目录中看到

00:32:22.250 --> 00:32:28.900
统计成绩，我看到很多课程文件

00:32:24.230 --> 00:32:31.220
这是非常不方便的方式

00:32:28.900 --> 00:32:33.590
分发应用程序或库

00:32:31.220 --> 00:32:36.650
作为一堆我想要的类文件

00:32:33.590 --> 00:32:40.120
将其打包成一个jar文件，我们

00:32:36.650 --> 00:32:43.850
具有模块化罐子的概念

00:32:40.120 --> 00:32:46.940
模块化jar只是常规的jar文件

00:32:43.850 --> 00:32:49.700
但是它在其中有一个模块

00:32:46.940 --> 00:32:55.160
顶层目录顶层目录

00:32:49.700 --> 00:32:56.540
这样就可以使用它

00:32:55.160 --> 00:32:58.550
以其他方式我将在

00:32:56.540 --> 00:33:00.410
几分钟，但是如果您看到一个jar文件

00:32:58.550 --> 00:33:04.010
有一个模块介绍顶层

00:33:00.410 --> 00:33:05.450
目录是一个模块化的jar文件，因此

00:33:04.010 --> 00:33:08.270
我要在这辆车上做的是

00:33:05.450 --> 00:33:12.010
在其中使用一些较新的选项

00:33:08.270 --> 00:33:16.070
 jar工具，用于从中创建模块化jar 

00:33:12.010 --> 00:33:17.930
我之前编译过的内容，所以我

00:33:16.070 --> 00:33:22.370
用这个来打包

00:33:17.930 --> 00:33:24.620
 stat CLI我要去的模块化jar 

00:33:22.370 --> 00:33:26.120
创建是我要创建到

00:33:24.620 --> 00:33:30.860
 EM Lib目录，我将转到

00:33:26.120 --> 00:33:33.620
将jar文件统计信息命名为CLI dot jar作为

00:33:30.860 --> 00:33:36.470
我要打包stat CLI的一部分

00:33:33.620 --> 00:33:38.210
指定主类是什么

00:33:36.470 --> 00:33:40.130
你习惯于制作一个

00:33:38.210 --> 00:33:42.050
应用jar，然后您曾经能够

00:33:40.130 --> 00:33:43.940
对您可能熟悉的

00:33:42.050 --> 00:33:45.710
主类属性这是

00:33:43.940 --> 00:33:47.870
等价于模块，我可以

00:33:45.710 --> 00:33:50.450
与主要配置

00:33:47.870 --> 00:33:53.330
 jar工具的类选项

00:33:50.450 --> 00:33:55.520
这是所有的课程

00:33:53.330 --> 00:33:57.110
我在CLI所在的mod中的文件

00:33:55.520 --> 00:33:59.480
将它们打包在一起创建一个

00:33:57.110 --> 00:34:05.330
 jar文件状态CLI，该文件位于

00:33:59.480 --> 00:34:07.580
正确的jar工具有很多

00:34:05.330 --> 00:34:09.140
 JDK 9中的新选项

00:34:07.580 --> 00:34:12.920
如果你在这里给你看一个

00:34:09.140 --> 00:34:15.890
找到一个罐子文件，您实际上可以

00:34:12.920 --> 00:34:18.250
您可以提供jar文件的名称

00:34:15.890 --> 00:34:20.360
对于我们的jar工具文件补丁

00:34:18.250 --> 00:34:23.929
给它选择打印模块

00:34:20.360 --> 00:34:25.520
描述符的作用是

00:34:23.929 --> 00:34:27.889
它会给你它将描述

00:34:25.520 --> 00:34:30.559
这个jar文件中的模块

00:34:27.889 --> 00:34:34.040
这是我们的stat CLI模块，我们可以看到

00:34:30.559 --> 00:34:36.710
它取决于什么以及统计数据

00:34:34.040 --> 00:34:38.750
 Eli没有出口，只是一种工具

00:34:36.710 --> 00:34:41.149
它没有出口，而且有一个主要

00:34:38.750 --> 00:34:44.059
类，因此jar工具能够打印

00:34:41.149 --> 00:34:45.679
那是有用的， 

00:34:44.059 --> 00:34:47.240
当您得到一堆jar文件时， 

00:34:45.679 --> 00:34:54.889
想弄清楚什么是模块

00:34:47.240 --> 00:34:57.079
在他们里面好吧，现在我们有了我们的统计数据

00:34:54.889 --> 00:34:59.510
 CLI已打包在EM中

00:34:57.079 --> 00:35:03.650
库目录我现在开始缩小

00:34:59.510 --> 00:35:06.589
像我的Java命令一样

00:35:03.650 --> 00:35:09.710
只是给它一个名字

00:35:06.589 --> 00:35:15.619
几分钟前的初始模块

00:35:09.710 --> 00:35:18.380
我指定的--m2值

00:35:15.619 --> 00:35:19.819
现在的主要模块和主要类别

00:35:18.380 --> 00:35:22.160
我已经打包了我已经打包的模块

00:35:19.819 --> 00:35:24.170
该模块现在知道其名称类别是什么

00:35:22.160 --> 00:35:26.059
是我不需要再指定了吗

00:35:24.170 --> 00:35:28.369
所以我的命令缩小了

00:35:26.059 --> 00:35:32.960
告诉它主要模块是什么-M 

00:35:28.369 --> 00:35:34.609
该CLI及其加载的统计信息

00:35:32.960 --> 00:35:36.710
该模块的主要类别，以及

00:35:34.609 --> 00:35:39.490
一切都会像

00:35:36.710 --> 00:35:39.490
之前

00:35:43.500 --> 00:35:48.430
好吧，我还没有谈过一点

00:35:45.880 --> 00:35:51.460
关于模块路径，我们习惯于

00:35:48.430 --> 00:35:57.040
上课的路径和一件事要注意

00:35:51.460 --> 00:36:00.970
的是您可以将它们混合在一起

00:35:57.040 --> 00:36:04.750
必须启动或编译器才能运行

00:36:00.970 --> 00:36:06.400
一些代码已经作为模块，另外一些

00:36:04.750 --> 00:36:08.410
您可以在类路径上的代码

00:36:06.400 --> 00:36:09.850
现在将它们组合在一起，代码和

00:36:08.410 --> 00:36:11.800
模块当然不能依赖

00:36:09.850 --> 00:36:13.660
任何在课程路径上的东西

00:36:11.800 --> 00:36:17.470
您可能想做什么

00:36:13.660 --> 00:36:19.090
特别是对于迁移是运行

00:36:17.470 --> 00:36:21.190
类路径上的代码，但您正在

00:36:19.090 --> 00:36:24.040
使用已经存在的库

00:36:21.190 --> 00:36:25.690
迁移到模块，因此您可以在这里

00:36:24.040 --> 00:36:28.180
可以从哪里来

00:36:25.690 --> 00:36:31.320
想要结合模块路径和

00:36:28.180 --> 00:36:31.320
一起上课

00:36:31.590 --> 00:36:39.970
所以这里的橙色小盒子是

00:36:35.650 --> 00:36:42.520
 GUI认为那是那是那

00:36:39.970 --> 00:36:45.480
图形工具，使您自已

00:36:42.520 --> 00:36:47.890
那就是我正在使用的核心API 

00:36:45.480 --> 00:36:49.900
那个的维护者还没有

00:36:47.890 --> 00:36:51.580
到处将代码迁移到

00:36:49.900 --> 00:36:54.160
您想要将其保留在课程上的模块

00:36:51.580 --> 00:36:56.770
暂时填充，因为还没到

00:36:54.160 --> 00:36:58.780
这是所有其他图书馆

00:36:56.770 --> 00:37:02.110
在这个系统中已经使用

00:36:58.780 --> 00:37:04.270
模组统计资料核心已由

00:37:02.110 --> 00:37:06.010
我们在本届会议上利用了番石榴

00:37:04.270 --> 00:37:08.050
我们一直以为那已经是

00:37:06.010 --> 00:37:09.850
在此会议之前迁移

00:37:08.050 --> 00:37:11.950
开始，我们有几个平台

00:37:09.850 --> 00:37:15.820
模块，我将如何运行这些

00:37:11.950 --> 00:37:19.900
两个在一起，这是一个示例命令

00:37:15.820 --> 00:37:22.720
所以我在用-M对不起-P short 

00:37:19.900 --> 00:37:23.950
再次形成我给的模块路径

00:37:22.720 --> 00:37:25.480
我的信封目录

00:37:23.950 --> 00:37:26.920
我们所有的模块都在那里

00:37:25.480 --> 00:37:29.980
得到了番石榴，得到了统计数据

00:37:26.920 --> 00:37:34.780
我们还有其他模块，我

00:37:29.980 --> 00:37:36.580
使用-jar stats GUI jar，所以这是

00:37:34.780 --> 00:37:40.140
统计资料的主要类别

00:37:36.580 --> 00:37:40.140
 UIE应用程序是

00:37:41.319 --> 00:37:48.500
没什么可统计的

00:37:45.349 --> 00:37:51.440
就是说这取决于模块

00:37:48.500 --> 00:37:54.559
 stat成绩这只是一个jar文件而已

00:37:51.440 --> 00:37:58.069
没有我必须的依赖信息

00:37:54.559 --> 00:38:00.309
我必须告诉系统，那就是

00:37:58.069 --> 00:38:02.869
这个添加模块的选项在这里

00:38:00.309 --> 00:38:06.920
这个我要运行的应用程序

00:38:02.869 --> 00:38:08.839
正在利用模块统计信息核心

00:38:06.920 --> 00:38:11.420
通过将这两个结合在一起

00:38:08.839 --> 00:38:13.490
类在类路径上没有依赖性

00:38:11.420 --> 00:38:17.450
我必须告诉系统的信息

00:38:13.490 --> 00:38:20.000
我需要统计核心模块是

00:38:17.450 --> 00:38:24.710
解决，所以这是

00:38:20.000 --> 00:38:27.260
统计添加模块统计得分，如果统计

00:38:24.710 --> 00:38:30.470
 Gy迁移到一个模块，然后将其

00:38:27.260 --> 00:38:32.210
依赖信息意味着

00:38:30.470 --> 00:38:34.279
系统将知道能够解决

00:38:32.210 --> 00:38:38.960
统计分数，但我什么也没有

00:38:34.279 --> 00:38:42.289
现在将该代码保留在命令行中

00:38:38.960 --> 00:38:45.740
让我们回到链接，所以忽略什么

00:38:42.289 --> 00:38:47.539
我们使用了stats GUI库

00:38:45.740 --> 00:38:50.599
现在我要开始制作一个

00:38:47.539 --> 00:38:52.579
具有统计信息CLI的运行时映像

00:38:50.599 --> 00:38:55.760
模块，所以这是我们拥有的模块

00:38:52.579 --> 00:38:57.500
编译打包，现在我要去

00:38:55.760 --> 00:38:59.779
并创建一个运行时映像

00:38:57.500 --> 00:39:02.450
分发我可以分发它

00:38:59.779 --> 00:39:03.859
作为模块化的罐子，但假设我想要

00:39:02.450 --> 00:39:05.539
能够分发完整的

00:39:03.859 --> 00:39:06.740
我没有依赖的运行时

00:39:05.539 --> 00:39:08.839
不想不得不单独发货

00:39:06.740 --> 00:39:11.690
 JDK我只是想能够减少一个

00:39:08.839 --> 00:39:13.490
用jailing命令分发

00:39:11.690 --> 00:39:15.829
我在命令中运行监狱

00:39:13.490 --> 00:39:20.240
模块路径，并告诉它在哪里

00:39:15.829 --> 00:39:22.220
找到模块有两个

00:39:20.240 --> 00:39:23.299
位置给出模块路径

00:39:22.220 --> 00:39:26.690
一个是您在哪里找到平台

00:39:23.299 --> 00:39:29.359
模块，它们实际上在JDK中

00:39:26.690 --> 00:39:31.579
下载我在哪里可以找到其他

00:39:29.359 --> 00:39:33.829
我所在的EM Lib目录中的模块

00:39:31.579 --> 00:39:36.470
给一个添加添加模块来告诉哪个

00:39:33.829 --> 00:39:40.069
要包含在运行时映像中的模块

00:39:36.470 --> 00:39:42.170
我想包含统计信息CLI，然后我

00:39:40.069 --> 00:39:45.859
给它一个输出目录是

00:39:42.170 --> 00:39:48.460
运行时映像的位置

00:39:45.859 --> 00:39:50.960
我想创造的

00:39:48.460 --> 00:39:54.020
转动了几秒钟，我

00:39:50.960 --> 00:39:58.040
获得具有一两个的运行时映像

00:39:54.020 --> 00:40:00.320
其中的四个七个模块

00:39:58.040 --> 00:40:02.900
像我使用的演示文稿的开头

00:40:00.320 --> 00:40:06.320
 J链接使用创建一个运行时映像

00:40:02.900 --> 00:40:08.660
现在只有平台模块，我正在使用

00:40:06.320 --> 00:40:11.270
 jail工具创建运行时

00:40:08.660 --> 00:40:14.960
混合了平台模块的映像

00:40:11.270 --> 00:40:17.810
还有我自己的一些模块

00:40:14.960 --> 00:40:21.260
我在这里写过，所以当我运行Java时- 

00:40:17.810 --> 00:40:24.470
列出我得到的模块我看到的名字

00:40:21.260 --> 00:40:25.910
基于Java的日志记录续集XML（如果您

00:40:24.470 --> 00:40:27.710
记得我有依赖图

00:40:25.910 --> 00:40:29.900
这些平台上较早的是那些平台

00:40:27.710 --> 00:40:32.420
你在那里看到的模块，我说看到我的

00:40:29.900 --> 00:40:35.630
我自己的三个我自己的模块stat CLI 

00:40:32.420 --> 00:40:37.840
统计信息和统计信息得分，因此

00:40:35.630 --> 00:40:37.840
样品

00:40:37.900 --> 00:40:42.500
进阶插槽中的jaelyn命令

00:40:41.060 --> 00:40:43.940
今天晚些时候，我们实际上会去

00:40:42.500 --> 00:40:45.920
通过实际上将有几个

00:40:43.940 --> 00:40:48.050
更加复杂的例子

00:40:45.920 --> 00:40:49.250
有趣的jaail命令，我们可以

00:40:48.050 --> 00:40:50.810
在hack上谈论它

00:40:49.250 --> 00:40:54.800
会议，如果有人想站起来， 

00:40:50.810 --> 00:40:57.590
谈论那个，那就是那个

00:40:54.800 --> 00:41:00.860
所以在本节中，我们已经

00:40:57.590 --> 00:41:03.410
通过基本的

00:41:00.860 --> 00:41:05.810
模块的基本概念为其命名

00:41:03.410 --> 00:41:08.540
表达它可能具有的依赖性

00:41:05.810 --> 00:41:11.030
一些它可能有一些出口

00:41:08.540 --> 00:41:12.620
看到我们如何变成依赖图

00:41:11.030 --> 00:41:15.170
到您看到的可读性图中

00:41:12.620 --> 00:41:18.530
隐含可读性的概念，或

00:41:15.170 --> 00:41:20.390
需要传递和希望

00:41:18.530 --> 00:41:22.700
快速介绍，您已经看到了一些

00:41:20.390 --> 00:41:25.220
工具，图像和

00:41:22.700 --> 00:41:27.680
更新到java c命令的jar 

00:41:25.220 --> 00:41:31.190
命令Java启动器能够

00:41:27.680 --> 00:41:33.200
给它一个模块的位置，所以你

00:41:31.190 --> 00:41:40.850
可以看到如何编译包并运行

00:41:33.200 --> 00:41:42.350
与模块，就是这样，所以我说

00:41:40.850 --> 00:41:45.470
一开始我们有五个五个

00:41:42.350 --> 00:41:48.800
会议，因此为JDK 9做准备是

00:41:45.470 --> 00:41:51.200
我们在午餐前做的事情

00:41:48.800 --> 00:41:53.210
在明天， 

00:41:51.200 --> 00:41:55.310
我和Alex和我谈过高级模块化

00:41:53.210 --> 00:41:59.360
我正在这个房间里做

00:41:55.310 --> 00:42:01.780
今天晚些时候在5：30，Alex在做

00:41:59.360 --> 00:42:04.390
服务和秘密谈话

00:42:01.780 --> 00:42:07.480
明天，我们有一个关于

00:42:04.390 --> 00:42:09.550
如果您想携带，周三8:30 

00:42:07.480 --> 00:42:12.369
沿着笔记本电脑尝试尝试

00:42:09.550 --> 00:42:16.119
只是伴随着问题所以

00:42:12.369 --> 00:42:17.140
如我在

00:42:16.119 --> 00:42:18.730
开始我们正在努力

00:42:17.140 --> 00:42:21.190
在项目拼图中的实现

00:42:18.730 --> 00:42:23.200
这是项目页面的链接

00:42:21.190 --> 00:42:26.740
邮件列表以及我们拥有的

00:42:23.200 --> 00:42:30.400
抢先下载，如果有人

00:42:26.740 --> 00:42:32.470
有问题请拜托

00:42:30.400 --> 00:42:35.200
由马克·犀牛·利兹（Marc Rhino Liz）主持

00:42:32.470 --> 00:42:37.440
在这里，我希望会有所帮助

00:42:35.200 --> 00:42:37.440
问题

00:43:00.050 --> 00:43:03.620
你好

00:43:04.540 --> 00:43:12.320
好吧，我很好奇JDK 9s模块如何

00:43:09.349 --> 00:43:14.780
方法与OSGi相比会是什么

00:43:12.320 --> 00:43:26.930
使用JD Ches模块的优势

00:43:14.780 --> 00:43:30.320
接近我-我可能会在此黎明

00:43:26.930 --> 00:43:34.250
一个你好

00:43:30.320 --> 00:43:38.510
对不，他离开了，好吧，别管我哦

00:43:34.250 --> 00:43:40.520
你在这里，所以OSGi就是更多

00:43:38.510 --> 00:43:42.560
而不是模块，所以我给你一个简短的

00:43:40.520 --> 00:43:43.880
回答这是一个很深的话题Oster有很多

00:43:42.560 --> 00:43:45.710
不仅仅是模块系统

00:43:43.880 --> 00:43:47.240
安全层和服务层，以及

00:43:45.710 --> 00:43:48.650
一堆其他的东西，我不是

00:43:47.240 --> 00:43:51.200
永不重装很多奇特的东西

00:43:48.650 --> 00:43:54.440
有些应用程序需要但许多

00:43:51.200 --> 00:43:57.080
不是我们正在设计的模型系统

00:43:54.440 --> 00:43:59.599
因为你知道是标准型号

00:43:57.080 --> 00:44:01.250
 Java系统没有全部

00:43:59.599 --> 00:44:03.290
这些功能，但它有一堆

00:44:01.250 --> 00:44:05.030
其他功能，即您可以

00:44:03.290 --> 00:44:06.710
实际使用它来模块化

00:44:05.030 --> 00:44:09.080
平台本身，你做不到

00:44:06.710 --> 00:44:11.390
与那些基于Java构建的GIS专家一起

00:44:09.080 --> 00:44:13.250
正确，我们需要将所有

00:44:11.390 --> 00:44:15.950
深入其中，这就是为什么模块

00:44:13.250 --> 00:44:18.109
是基本的新程序组件

00:44:15.950 --> 00:44:19.820
在这个设计中而不是加载您

00:44:18.109 --> 00:44:24.230
熟悉类装载机

00:44:19.820 --> 00:44:26.750
他们周围的东西，所以SGI完美地工作

00:44:24.230 --> 00:44:28.130
九点就可以了，那就是

00:44:26.750 --> 00:44:30.080
打算永远保持工作，如果你

00:44:28.130 --> 00:44:31.910
需要使用它，您知道继续使用

00:44:30.080 --> 00:44:34.700
对于某些人来说这是一个很好的解决方案

00:44:31.910 --> 00:44:39.290
问题，但不是每个人都

00:44:34.700 --> 00:44:40.849
那是我可以开除的答案

00:44:39.290 --> 00:44:42.109
 JVM并自己进行测试，但这是

00:44:40.849 --> 00:44:46.630
更容易问专家

00:44:42.109 --> 00:44:51.140
偷懒发生了什么

00:44:46.630 --> 00:44:53.690
导出的类尝试在

00:44:51.140 --> 00:44:56.349
 API和内部类不是

00:44:53.690 --> 00:44:59.650
通过模块暴露出来很有意义

00:44:56.349 --> 00:45:03.200
是的，您的用户会很不高兴

00:44:59.650 --> 00:45:04.790
我们会在编译时出现错误吗

00:45:03.200 --> 00:45:11.359
时间还是只是在运行时

00:45:04.790 --> 00:45:12.900
当应用程序陷入困境时， 

00:45:11.359 --> 00:45:14.850
这些情况可以弹出来检测

00:45:12.900 --> 00:45:18.590
如果不是，在编译时他们会

00:45:14.850 --> 00:45:18.590
肯定在他们周围被发现还可以

00:45:20.510 --> 00:45:26.310
要记住的一件事是

00:45:23.130 --> 00:45:28.920
有一个API是很正常的

00:45:26.310 --> 00:45:30.690
返回一些内部

00:45:28.920 --> 00:45:34.320
实现某些东西的实现

00:45:30.690 --> 00:45:37.530
就是出口了，就是这样

00:45:34.320 --> 00:45:39.960
对我来说很正常，我正在使用

00:45:37.530 --> 00:45:41.520
 Java续集驱动程序在那里，您可以

00:45:39.960 --> 00:45:44.820
有一个驱动程序的参考，但这是

00:45:41.520 --> 00:45:47.430
这是内部的，我不知道Oracle 

00:45:44.820 --> 00:45:49.050
非数据库驱动程序类型

00:45:47.430 --> 00:45:50.790
出口商打包那种东西

00:45:49.050 --> 00:45:52.650
很正常，我认为您的情况是

00:45:50.790 --> 00:45:54.690
就是马克要去的地方

00:45:52.650 --> 00:45:56.570
你犯错了

00:45:54.690 --> 00:46:00.210
方法的签名，最终

00:45:56.570 --> 00:46:01.170
有公共驾驶员拉动驾驶员

00:46:00.210 --> 00:46:02.730
或类似的东西，那是

00:46:01.170 --> 00:46:14.190
可以在

00:46:02.730 --> 00:46:16.140
编译时间只要期限长

00:46:14.190 --> 00:46:18.060
因为返回类型可用于

00:46:16.140 --> 00:46:19.050
谁在使用您的模块方式返回

00:46:18.060 --> 00:46:23.010
类型可以用其他方式定义

00:46:19.050 --> 00:46:24.560
模块很好，谢谢，我只是

00:46:23.010 --> 00:46:27.150
对可及性感到好奇

00:46:24.560 --> 00:46:30.660
要求您如何确定

00:46:27.150 --> 00:46:32.100
声明为可传递而不是不传递

00:46:30.660 --> 00:46:36.690
你知道人们会需要什么

00:46:32.100 --> 00:46:38.430
访问，所以简单的答案是

00:46:36.690 --> 00:46:41.520
这实际上与

00:46:38.430 --> 00:46:43.550
以前的问题，如果你是我们，如果你

00:46:41.520 --> 00:46:46.470
有一个正在使用的API 

00:46:43.550 --> 00:46:48.810
基本上是来自其他模块的类型

00:46:46.470 --> 00:46:50.820
在其API中，您有一个

00:46:48.810 --> 00:46:52.560
返回您知道食物类型的方法

00:46:50.820 --> 00:46:54.930
从某些到完全

00:46:52.560 --> 00:46:56.670
其他模块，那么可能会有所帮助

00:46:54.930 --> 00:46:58.680
给您的用户

00:46:56.670 --> 00:47:02.220
如果不是，则传递该模块

00:46:58.680 --> 00:47:04.020
必须自己做对

00:47:02.220 --> 00:47:07.260
感

00:47:04.020 --> 00:47:09.690
我有问题，所以我们知道

00:47:07.260 --> 00:47:11.700
使用Gradle 2过多管理

00:47:09.690 --> 00:47:14.580
版本现在看起来像模块

00:47:11.700 --> 00:47:18.270
公司必须更换他们的Gradle，所以

00:47:14.580 --> 00:47:20.520
我的问题是我现在可以看到

00:47:18.270 --> 00:47:23.040
一切都放在模块的罐子里

00:47:20.520 --> 00:47:25.050
当我们应该

00:47:23.040 --> 00:47:29.910
使用该模块，因为我们不

00:47:25.050 --> 00:47:31.830
管理罐子，我们中的一个人是否足够了解

00:47:29.910 --> 00:47:33.570
关于Gradle回答我的问题

00:47:31.830 --> 00:47:35.790
认为实际上有一两个Gradle 

00:47:33.570 --> 00:47:39.480
实际谈论的会议

00:47:35.790 --> 00:47:41.690
 JDK和JDK 9支持Java 1，因此

00:47:39.480 --> 00:47:45.480
模块系统不能取代Gradle和

00:47:41.690 --> 00:47:46.710
我认为最好提起

00:47:45.480 --> 00:47:50.250
摇篮中的一些问题

00:47:46.710 --> 00:47:52.740
会议好，总体上感谢我们

00:47:50.250 --> 00:47:54.090
整个方法就是工作

00:47:52.740 --> 00:47:56.850
设计一些效果很好的东西

00:47:54.090 --> 00:47:59.160
使用现有工具的目的是

00:47:56.850 --> 00:48:00.150
与maven和Gradle以及

00:47:59.160 --> 00:48:02.640
我们没有尝试的所有其他事情

00:48:00.150 --> 00:48:06.780
替换那些现有的系统，谢谢

00:48:02.640 --> 00:48:10.830
谢谢你做j-link的工作

00:48:06.780 --> 00:48:13.470
跨平台我可以创建一个吗

00:48:10.830 --> 00:48:16.950
是的是的，我们遇到了一些问题

00:48:13.470 --> 00:48:19.140
他们相信的一切

00:48:16.950 --> 00:48:21.720
解决，这是否意味着

00:48:19.140 --> 00:48:23.640
我做的最终产品

00:48:21.720 --> 00:48:25.350
生产的产品可以在任何平台上运行

00:48:23.640 --> 00:48:28.920
这是否意味着我必须指定我

00:48:25.350 --> 00:48:30.720
想出口以产生火花或装甲好

00:48:28.920 --> 00:48:32.790
杰琳找出了你的目标

00:48:30.720 --> 00:48:34.140
平台是基于平台

00:48:32.790 --> 00:48:36.090
您要链接的模块，如果

00:48:34.140 --> 00:48:38.520
你在Mac上，而你又给它

00:48:36.090 --> 00:48:40.350
 Windows发行版的模块路径

00:48:38.520 --> 00:48:43.800
那么它实际上将链接到

00:48:40.350 --> 00:48:45.750
这些模块的Windows版本和

00:48:43.800 --> 00:48:48.359
为您提供Windows运行时

00:48:45.750 --> 00:48:51.240
只能在一个Windows上运行就可以了

00:48:48.359 --> 00:48:53.130
归结为您指出的Java基础

00:48:51.240 --> 00:48:58.530
正确的就是这样

00:48:53.130 --> 00:49:00.060
好的，鲍勃实际上是曼迪在

00:48:58.530 --> 00:49:02.580
前排只是指出鲍勃

00:49:00.060 --> 00:49:03.960
从事嵌入式工作的Vendetta给了

00:49:02.580 --> 00:49:05.910
说话，但实际上他的说话是这样的

00:49:03.960 --> 00:49:07.890
他实际上所在的早晨

00:49:05.910 --> 00:49:09.510
做一些交叉演示

00:49:07.890 --> 00:49:11.850
编译是如此交叉链接到

00:49:09.510 --> 00:49:15.560
嵌入式平台

00:49:11.850 --> 00:49:19.740
我正在学习如何破解牙刷

00:49:15.560 --> 00:49:20.820
谢谢，所以我有一个相关的问题

00:49:19.740 --> 00:49:24.000
移民

00:49:20.820 --> 00:49:27.180
所以你说是出于移民目的

00:49:24.000 --> 00:49:31.080
可以选择使用模块化路径

00:49:27.180 --> 00:49:33.540
同时交叉路径和模型

00:49:31.080 --> 00:49:36.300
将无法使用来自

00:49:33.540 --> 00:49:38.820
类总线，但类总线中的库

00:49:36.300 --> 00:49:43.440
将能够使用模型中的类

00:49:38.820 --> 00:49:46.380
对，所以如果这取决于我

00:49:43.440 --> 00:49:50.210
无法开始在我的模型中使用模型

00:49:46.380 --> 00:49:54.270
项目，直到高中生们

00:49:50.210 --> 00:49:56.040
这些库将正确迁移它们

00:49:54.270 --> 00:49:59.550
这是一个非常好的问题

00:49:56.040 --> 00:50:02.040
在我们的谈话中

00:49:59.550 --> 00:50:03.930
 5:30我们将讨论迁移

00:50:02.040 --> 00:50:05.730
特别是布朗自动模块

00:50:03.930 --> 00:50:07.740
允许您迁移到模块

00:50:05.730 --> 00:50:09.150
不依赖不等待

00:50:07.740 --> 00:50:11.430
其他人先移至模块

00:50:09.150 --> 00:50:13.560
所以来5:30我们有很多

00:50:11.430 --> 00:50:22.140
会议上有很多与此有关的幻灯片

00:50:13.560 --> 00:50:27.900
模块系统解决问题

00:50:22.140 --> 00:50:30.570
地狱我们希望如此

00:50:27.900 --> 00:50:32.270
主要目标及其作用

00:50:30.570 --> 00:50:34.560
那

00:50:32.270 --> 00:50:37.080
你在房间的右边

00:50:34.560 --> 00:50:39.690
但是除了其他版本没有其他版本

00:50:37.080 --> 00:50:42.600
也许在9:00建议

00:50:39.690 --> 00:50:45.630
如果解决方案可以版本化哦

00:50:42.600 --> 00:50:47.670
对于罐地狱，您正在寻找的是

00:50:45.630 --> 00:50:49.950
涉及版本号，那么不，我们是

00:50:47.670 --> 00:50:51.210
没有解决那个问题，那是和

00:50:49.950 --> 00:50:53.370
这与他给出的答案有关

00:50:51.210 --> 00:50:58.310
分钟前关于

00:50:53.370 --> 00:51:00.480
现有的工具让混蛋罐混蛋

00:50:58.310 --> 00:51:02.490
像任何贬义词一样

00:51:00.480 --> 00:51:04.050
罐子山楂有不同的意思

00:51:02.490 --> 00:51:06.950
问题在于我们要

00:51:04.050 --> 00:51:09.570
解决是好的，你有一个

00:51:06.950 --> 00:51:10.650
我在类路径上的zillion jar文件

00:51:09.570 --> 00:51:12.420
意味着您知道我们已经看到了新的Oracle 

00:51:10.650 --> 00:51:14.070
内部产品具有超过

00:51:12.420 --> 00:51:16.680
一千个罐子，就像哇，是他

00:51:14.070 --> 00:51:17.940
怎么还算不出来

00:51:16.680 --> 00:51:19.080
告诉你什么时候你不知道

00:51:17.940 --> 00:51:20.430
有冲突你不能告诉他们

00:51:19.080 --> 00:51:21.630
说东西不见了，你不能告诉

00:51:20.430 --> 00:51:24.120
什么时候可以安全更换

00:51:21.630 --> 00:51:24.400
那就是罐子的特殊形式

00:51:24.120 --> 00:51:28.390
地狱

00:51:24.400 --> 00:51:30.760
我们正试图从和

00:51:28.390 --> 00:51:33.370
一旦你一旦你一次，你可以去一个

00:51:30.760 --> 00:51:34.930
相同的模块图，那么你就有

00:51:33.370 --> 00:51:36.190
所有这些问题的答案，以及

00:51:34.930 --> 00:51:40.090
你没有班上的混乱

00:51:36.190 --> 00:51:42.760
现在有两个版本的路径

00:51:40.090 --> 00:51:44.530
有很多原因为什么我们不是为什么

00:51:42.760 --> 00:51:46.540
这个模块系统没有

00:51:44.530 --> 00:51:48.250
就它而言没有版本

00:51:46.540 --> 00:51:50.830
版本限制，您可以坚持

00:51:48.250 --> 00:51:52.810
基本上在模块上的版本

00:51:50.830 --> 00:51:55.480
文档，随身携带

00:51:52.810 --> 00:51:57.490
将在堆栈堆栈跟踪中报告

00:51:55.480 --> 00:51:59.500
和类似的事情，因为它是

00:51:57.490 --> 00:52:01.000
知道很好的代码来自非常有用

00:51:59.500 --> 00:52:03.400
你知道什么模块的版本

00:52:01.000 --> 00:52:06.370
但是没有办法，这是

00:52:03.400 --> 00:52:09.070
有意在模块声明中

00:52:06.370 --> 00:52:12.070
说你知道这个模块的行为

00:52:09.070 --> 00:52:15.220
需要一个版本，你知道一些

00:52:12.070 --> 00:52:18.820
为什么在1.2和3.9之间的版本

00:52:15.220 --> 00:52:19.690
但不知道但永远不会加点4.1 

00:52:18.820 --> 00:52:23.170
因为我知道因为我知道

00:52:19.690 --> 00:52:25.300
到底是什么被打破了

00:52:23.170 --> 00:52:26.710
拼图的早期原型我们

00:52:25.300 --> 00:52:28.480
实际上已经解决了，我们试图

00:52:26.710 --> 00:52:30.900
解决了这个问题，我们意识到等待

00:52:28.480 --> 00:52:33.460
一分钟的专家解决了这个问题

00:52:30.900 --> 00:52:35.050
 Gradle用其他系统解决了这个问题

00:52:33.460 --> 00:52:36.790
解决它现在解决这个问题也许

00:52:35.050 --> 00:52:39.490
他们不是那些现有的系统

00:52:36.790 --> 00:52:41.950
从理论上解决问题

00:52:39.490 --> 00:52:44.410
最佳方式，但你知道几百万

00:52:41.950 --> 00:52:46.780
的人们已经在使用这些工具，并且

00:52:44.410 --> 00:52:51.100
并试图取代那将

00:52:46.780 --> 00:52:52.540
只是一个傻瓜的差事，所以这个模块

00:52:51.100 --> 00:52:54.010
系统符合以下概念

00:52:52.540 --> 00:52:56.980
模块路径，这是一种查找方法

00:52:54.010 --> 00:52:59.470
模块，我们将依靠您的构建

00:52:56.980 --> 00:53:01.960
系统是否是行家

00:52:59.470 --> 00:53:04.510
或Gradle或制作文件，或者你知道

00:53:01.960 --> 00:53:06.700
您的选择，以确保正确

00:53:04.510 --> 00:53:11.500
你所拥有的东西的版本

00:53:06.700 --> 00:53:14.020
路径，只是添加甚至

00:53:11.500 --> 00:53:15.340
假设一些非常实用的东西

00:53:14.020 --> 00:53:16.960
你身上有一堆jar文件

00:53:15.340 --> 00:53:18.700
今天的内裤路径是

00:53:16.960 --> 00:53:20.590
同一库的不同版本

00:53:18.700 --> 00:53:22.210
或或恰好使用相同的

00:53:20.590 --> 00:53:25.030
包装或任何可能

00:53:22.210 --> 00:53:28.030
尝试与模块系统和

00:53:25.030 --> 00:53:29.650
模块路径上的模块，它将

00:53:28.030 --> 00:53:31.630
不允许这些它将检测到这些

00:53:29.650 --> 00:53:33.750
那种分包问题就是你

00:53:31.630 --> 00:53:36.460
甚至不会启动，如果

00:53:33.750 --> 00:53:37.930
你有问题，如果你有

00:53:36.460 --> 00:53:40.960
有两个版本的同一国防部

00:53:37.930 --> 00:53:44.290
然后它会选择第一个

00:53:40.960 --> 00:53:46.270
一个是在模块路径上

00:53:44.290 --> 00:53:47.770
永远不会完全忽略所有

00:53:46.270 --> 00:53:49.720
您可能会有的其他版本

00:53:47.770 --> 00:53:52.420
有一个你没有方案

00:53:49.720 --> 00:53:54.670
试图加载quani的某些部分

00:53:52.420 --> 00:53:57.340
或例子来这里Acme统计核心

00:53:54.670 --> 00:53:58.630
从这个jar文件中获得更多

00:53:57.340 --> 00:54:06.580
这个其他的jar文件

00:53:58.630 --> 00:54:08.320
发生与有关的模块，如果

00:54:06.580 --> 00:54:09.970
您正在将班级Pat和班级混在一起

00:54:08.320 --> 00:54:10.810
模块化应用程序，因此在您的示例中

00:54:09.970 --> 00:54:12.910
拉番石榴

00:54:10.810 --> 00:54:16.120
所以如果我在课程路径上有番石榴

00:54:12.910 --> 00:54:24.130
以及嵌入到模块中就可以了

00:54:16.120 --> 00:54:26.590
我的模块赢了，所以如果我的应用是班级

00:54:24.130 --> 00:54:29.230
路径应用程序就在其中，它需要番石榴

00:54:26.590 --> 00:54:33.040
那就拉番石榴的版本

00:54:29.230 --> 00:54:34.000
来自模块，因此我的应用程序位于

00:54:33.040 --> 00:54:36.010
类路径，因此不需要

00:54:34.000 --> 00:54:38.500
如果你什么都没有的话

00:54:36.010 --> 00:54:41.770
玛雅人只是这么说

00:54:38.500 --> 00:54:43.060
我们开箱即用，我们假设

00:54:41.770 --> 00:54:45.460
你在类路径上运行东西

00:54:43.060 --> 00:54:49.210
您只需要任何模块

00:54:45.460 --> 00:54:52.090
在导出的运行时映像中

00:54:49.210 --> 00:54:53.800
 API可以，但我也可以

00:54:52.090 --> 00:54:55.750
对本地jar文件的依赖

00:54:53.800 --> 00:54:57.190
可能是番石榴版本的类路径

00:54:55.750 --> 00:55:00.010
是的，可以

00:54:57.190 --> 00:55:03.040
所以如果我这样做，那么番石榴也是

00:55:00.010 --> 00:55:05.710
然后打包在其中一个模块中

00:55:03.040 --> 00:55:09.220
在那种情况下会发生什么

00:55:05.710 --> 00:55:11.050
没有人需要番石榴，因为有

00:55:09.220 --> 00:55:15.280
没有需要的模块

00:55:11.050 --> 00:55:16.810
番石榴在这里和您的模块路径

00:55:15.280 --> 00:55:18.730
甚至不在这里看，除非

00:55:16.810 --> 00:55:20.230
你给它一个ADD模块来告诉它

00:55:18.730 --> 00:55:23.560
您想要的番石榴模块是

00:55:20.230 --> 00:55:25.780
解决了，所以您可能还记得

00:55:23.560 --> 00:55:28.270
幻灯片中的我们必须制定

00:55:25.780 --> 00:55:30.430
核心模块，以确保

00:55:28.270 --> 00:55:33.760
如果您执行该模块，则该模块已解决

00:55:30.430 --> 00:55:36.160
该模块番石榴然后番石榴模块

00:55:33.760 --> 00:55:39.270
将使用番石榴dejar和

00:55:36.160 --> 00:55:39.270
类路径将被忽略

00:55:41.210 --> 00:55:48.539
回去一点只是为了清楚

00:55:45.390 --> 00:55:50.309
如果我必须有一个模块取决于

00:55:48.539 --> 00:55:52.170
两个不同的模块，每个模块

00:55:50.309 --> 00:55:55.710
模块取决于不同的

00:55:52.170 --> 00:55:58.380
相同模块的版本

00:55:55.710 --> 00:56:03.599
杀死它，把它敲出来，说嘿

00:55:58.380 --> 00:56:05.849
甚至不允许，如果他们是

00:56:03.599 --> 00:56:07.410
你知道你是否在做

00:56:05.849 --> 00:56:08.819
像唱片一样复杂的东西

00:56:07.410 --> 00:56:10.170
写一个应用服务器，有一些

00:56:08.819 --> 00:56:11.519
模块系统的高级功能

00:56:10.170 --> 00:56:15.960
让你支持那种

00:56:11.519 --> 00:56:18.960
场景，但在实际使用中，您知道

00:56:15.960 --> 00:56:21.869
用于较小的较不复杂的

00:56:18.960 --> 00:56:23.670
他们中大多数都击中的应用程序

00:56:21.869 --> 00:56:25.079
更好的是，您不需要知道

00:56:23.670 --> 00:56:26.700
通常如果今天你有两个

00:56:25.079 --> 00:56:28.410
您的不同版本的库

00:56:26.700 --> 00:56:31.279
班级路径，您已经遇到麻烦了

00:56:28.410 --> 00:56:31.279
可能还不知道

00:56:33.800 --> 00:56:37.580
所以我有一个问题

00:56:35.540 --> 00:56:40.460
关于您制作幻灯片的地方

00:56:37.580 --> 00:56:44.690
公众强烈要求的声明

00:56:40.460 --> 00:56:46.760
并不意味着可以访问什么

00:56:44.690 --> 00:56:48.890
反思，所以反思仍然可以偷看

00:56:46.760 --> 00:56:52.210
在引擎盖下侵犯您的一切

00:56:48.890 --> 00:56:54.620
试图干净地隐藏东西的系统

00:56:52.210 --> 00:56:56.840
所以已经指定了核心反射

00:56:54.620 --> 00:56:58.520
 20年做完全一样的

00:56:56.840 --> 00:57:02.440
与语言相同的访问技巧

00:56:58.520 --> 00:57:05.030
虚拟机，并继续如此

00:57:02.440 --> 00:57:08.930
有强大的警察在封装

00:57:05.030 --> 00:57:11.840
然后甚至您的公众也输入了您的非

00:57:08.930 --> 00:57:14.840
导出的软件包不能被分成

00:57:11.840 --> 00:57:17.810
具有良好的核心反射率，因此您必须

00:57:14.840 --> 00:57:19.400
明确将其导出为克莱尔

00:57:17.810 --> 00:57:21.830
租约，如果他们支持他们

00:57:19.400 --> 00:57:23.810
他们恰好反映正确，并且

00:57:21.830 --> 00:57:24.770
桌上的另一个概念

00:57:23.810 --> 00:57:27.140
在介绍中没有经历

00:57:24.770 --> 00:57:30.410
说话，但亚历克斯今天会谈到

00:57:27.140 --> 00:57:33.410
在预先的谈话中，这有点

00:57:30.410 --> 00:57:38.900
专为应用而设计

00:57:33.410 --> 00:57:42.560
还有其他的图书馆

00:57:38.900 --> 00:57:44.210
旨在由

00:57:42.560 --> 00:57:46.990
其他库，以便亚历克斯将接触

00:57:44.210 --> 00:57:49.670
今天下午和预告片

00:57:46.990 --> 00:57:51.410
快速的预告片是有办法的

00:57:49.670 --> 00:57:53.360
基本上有一种出口方式

00:57:51.410 --> 00:57:55.730
您可以导出软件包，也可以

00:57:53.360 --> 00:57:57.380
还说不仅要导出包裹

00:57:55.730 --> 00:57:59.540
但让反射进入我的内心

00:57:57.380 --> 00:58:00.920
也因为我你不好

00:57:59.540 --> 00:58:06.370
您期望这个模块是

00:58:00.920 --> 00:58:06.370
您知道的JPA或其他支持

00:58:07.250 --> 00:58:12.980
是的，我想我们已经完成了，谢谢

00:58:09.990 --> 00:58:12.980
参加谢谢

