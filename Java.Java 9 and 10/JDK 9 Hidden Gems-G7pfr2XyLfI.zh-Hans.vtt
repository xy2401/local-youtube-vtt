WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.170 --> 00:00:09.890
好的，你好，欢迎大家，这是JDK 

00:00:08.600 --> 00:00:12.320
 9隐藏的宝石

00:00:09.890 --> 00:00:14.330
我是Michael vid stet，直到最近我

00:00:12.320 --> 00:00:16.100
曾经是JVM技术人员，然后我

00:00:14.330 --> 00:00:18.410
搬到黑暗的一面，我现在不在

00:00:16.100 --> 00:00:19.970
管理DBM，但希望我会

00:00:18.410 --> 00:00:20.919
保持足够的技术性

00:00:19.970 --> 00:00:24.230
有趣

00:00:20.919 --> 00:00:27.740
您好，我是Sandy Sonatine高级软件

00:00:24.230 --> 00:00:29.320
工程师和技术上与我们

00:00:27.740 --> 00:00:32.090
与Oracle和开放式JDK合作

00:00:29.320 --> 00:00:36.260
社区为英特尔优化Java 

00:00:32.090 --> 00:00:39.199
平台很酷，所以我们将讨论

00:00:36.260 --> 00:00:40.550
数据k9中的隐藏宝石是

00:00:39.199 --> 00:00:42.230
幻灯片的Oracle版本说

00:00:40.550 --> 00:00:44.449
我要说的都是

00:00:42.230 --> 00:00:46.160
撒谎，我相信索尼娅会拥有她

00:00:44.449 --> 00:00:48.910
末尾的相应幻灯片

00:00:46.160 --> 00:00:53.570
滑盖，敬请期待

00:00:48.910 --> 00:00:55.699
这是在JDK 9上的演示

00:00:53.570 --> 00:00:57.620
我们推出不久后的JavaOne 

00:00:55.699 --> 00:00:59.239
镀锌明显是二维的

00:00:57.620 --> 00:01:00.859
拼图没有办法解决这个问题

00:00:59.239 --> 00:01:02.719
所以从理论上讲，这可能是

00:01:00.859 --> 00:01:04.309
拼图上的数据展示

00:01:02.719 --> 00:01:06.980
特别是所有很棒的东西

00:01:04.309 --> 00:01:09.470
我们已经完成了对JDK的模块化

00:01:06.980 --> 00:01:11.420
我们为改善这一点而打造的出色工具

00:01:09.470 --> 00:01:13.610
因此您可以创建自定义理论

00:01:11.420 --> 00:01:15.590
您可以从此模块图开始

00:01:13.610 --> 00:01:17.479
我们在JDK中可以

00:01:15.590 --> 00:01:19.070
精简并仅包括

00:01:17.479 --> 00:01:21.710
您实际需要的模块

00:01:19.070 --> 00:01:24.049
我可以谈论工作申请

00:01:21.710 --> 00:01:25.490
您最终会遇到运行时

00:01:24.049 --> 00:01:27.530
小多了

00:01:25.490 --> 00:01:30.740
我也可以谈谈我们的支持

00:01:27.530 --> 00:01:33.079
添加有多个版本的jar文件

00:01:30.740 --> 00:01:35.270
并以某种方式确保您可以运行

00:01:33.079 --> 00:01:37.700
您的工作申请，无论使用哪个JDK 

00:01:35.270 --> 00:01:39.950
您正在运行并无缝播放

00:01:37.700 --> 00:01:42.140
很多人这样做，我可以

00:01:39.950 --> 00:01:44.420
也可以参考我们添加到的支持

00:01:42.140 --> 00:01:46.759
 Java C使之更加容易

00:01:44.420 --> 00:01:48.920
您可以为某些JDK版本进行编译

00:01:46.759 --> 00:01:50.210
这些都是拼图相关的东西

00:01:48.920 --> 00:01:53.570
我们不会谈论这个

00:01:50.210 --> 00:01:55.549
是我们要去的JDK 9的隐藏宝石

00:01:53.570 --> 00:01:58.189
尝试去探讨其他东西

00:01:55.549 --> 00:01:59.840
已经进入数据k9，所以所有小

00:01:58.189 --> 00:02:02.329
往往倾向于最终的事情

00:01:59.840 --> 00:02:05.750
 dat后面阴影中的阴影

00:02:02.329 --> 00:02:07.609
犬拼图，我要开始黎明

00:02:05.750 --> 00:02:09.289
快速接触工具和库

00:02:07.609 --> 00:02:11.629
我要谈谈热点

00:02:09.289 --> 00:02:13.220
 JVM和Sanjay将会碰到很多

00:02:11.629 --> 00:02:14.659
关于我们的性能改进

00:02:13.220 --> 00:02:17.330
完成

00:02:14.659 --> 00:02:18.739
如果转到JDK 9页面，您将看到

00:02:17.330 --> 00:02:20.989
发生了什么事

00:02:18.739 --> 00:02:23.090
右边在这里，所以我们有你

00:02:20.989 --> 00:02:25.340
知道一些时间表和一堆

00:02:23.090 --> 00:02:27.560
我们添加的功能可以正常工作

00:02:25.340 --> 00:02:29.150
继续，直到我们

00:02:27.560 --> 00:02:30.860
意识到页面很重要

00:02:29.150 --> 00:02:32.120
比那更长的时间谢谢你很少哦

00:02:30.860 --> 00:02:34.459
顺便说一下这张幻灯片和

00:02:32.120 --> 00:02:37.849
我没有管理的动画

00:02:34.459 --> 00:02:39.440
自己创造技能的技能，但是

00:02:37.849 --> 00:02:41.659
如果您想看一下JDK中的内容

00:02:39.440 --> 00:02:44.060
 9您可以完全做到这一点，可以去

00:02:41.659 --> 00:02:46.340
 JDK 9页面，并希望有一个外观

00:02:44.060 --> 00:02:49.609
你会从中得到一些启发

00:02:46.340 --> 00:02:51.049
演讲以及我计算深度时

00:02:49.609 --> 00:02:53.409
我们在此页面上最终得到了

00:02:51.049 --> 00:02:53.409
某事

00:02:53.840 --> 00:03:00.799
 jep是我们的JDK增强建议

00:02:57.340 --> 00:03:03.920
因此相对较大的功能是

00:03:00.799 --> 00:03:05.930
非常明显或很大的东西

00:03:03.920 --> 00:03:09.230
影响或大型功能

00:03:05.930 --> 00:03:12.109
它具有很大的功能，因此在JDK 9中我们

00:03:09.230 --> 00:03:14.900
有90个真正的大功能，这仅仅是

00:03:12.109 --> 00:03:16.760
最重要的是， 

00:03:14.900 --> 00:03:18.859
所有其他改进，所以这是一个

00:03:16.760 --> 00:03:20.209
对我们来说是一个很大的发布，它包含很多

00:03:18.859 --> 00:03:21.980
不同的事情，如果我们是

00:03:20.209 --> 00:03:27.010
在这方面要涉及其中的一些

00:03:21.980 --> 00:03:29.900
演示，所以从

00:03:27.010 --> 00:03:31.849
工具和库我们一件事

00:03:29.900 --> 00:03:33.859
添加了，我不认为这不是

00:03:31.849 --> 00:03:35.239
就像没有介绍

00:03:33.859 --> 00:03:37.099
另一个在这里完整，没有

00:03:35.239 --> 00:03:40.579
至少它碰到杰伊壳，因为

00:03:37.099 --> 00:03:43.970
这是一个很酷的工具，所以其他运行时

00:03:40.579 --> 00:03:46.129
曾经支持基于叛乱的游戏

00:03:43.970 --> 00:03:48.410
在很长一段时间内都使用代码

00:03:46.129 --> 00:03:51.019
现在轮到Java了，所以

00:03:48.410 --> 00:03:53.870
周杰伦壳牌是一个读评估打印循环工具

00:03:51.019 --> 00:03:56.659
你可以用来尝试的东西尝试

00:03:53.870 --> 00:03:58.849
出代码并尝试一些东西

00:03:56.659 --> 00:04:00.709
无需创建Java类

00:03:58.849 --> 00:04:03.919
文件并使用Java C进行编译并

00:04:00.709 --> 00:04:05.889
部署它以及所有这些，以便我运行

00:04:03.919 --> 00:04:08.959
周杰伦壳牌希望你能看到

00:04:05.889 --> 00:04:11.989
好吧，也许不是最左边的几个

00:04:08.959 --> 00:04:13.790
像素，但至少可以做到GHL 

00:04:11.989 --> 00:04:17.120
显然很简单的事情，例如添加

00:04:13.790 --> 00:04:20.359
几个数字为什么不分配一个

00:04:17.120 --> 00:04:21.829
变量，为什么不说你知道

00:04:20.359 --> 00:04:24.080
该变量并加上四个，这些都是

00:04:21.829 --> 00:04:25.770
某种标准的简单事物

00:04:24.080 --> 00:04:28.300
应该认识其中的大多数

00:04:25.770 --> 00:04:30.430
那是J Shell本身，但J Shell 

00:04:28.300 --> 00:04:32.169
还有其他很酷的功能

00:04:30.430 --> 00:04:34.930
实际上会演示另一件事

00:04:32.169 --> 00:04:36.969
我们在jdk 9中添加了第一件事

00:04:34.930 --> 00:04:40.060
我要说的是ov，然后

00:04:36.969 --> 00:04:43.419
我要标签和J Shell实际上有

00:04:40.060 --> 00:04:45.849
支持打印Java文档

00:04:43.419 --> 00:04:48.550
对于方法，它具有制表符补全和

00:04:45.849 --> 00:04:50.919
并且还可以打印出您的Java文档

00:04:48.550 --> 00:04:53.349
可以在J Shell工具本身中获得帮助

00:04:50.919 --> 00:04:56.259
如果您不确定什么参数

00:04:53.349 --> 00:05:00.189
功能需要方法我应该

00:04:56.259 --> 00:05:01.810
说在这种情况下可能会有点

00:05:00.189 --> 00:05:04.090
看着这个就知道神秘

00:05:01.810 --> 00:05:05.379
但是我接下来要说的是

00:05:04.090 --> 00:05:07.689
我们在其中添加了一个func 

00:05:05.379 --> 00:05:11.889
称为便捷方法的功能

00:05:07.689 --> 00:05:15.819
用于收集的便利方法

00:05:11.889 --> 00:05:17.680
我有什么收藏工厂

00:05:15.819 --> 00:05:19.900
一组使其成为函数的方法

00:05:17.680 --> 00:05:22.120
轻松创建收藏集

00:05:19.900 --> 00:05:23.620
元素数量少，所以您不能

00:05:22.120 --> 00:05:25.240
使用它来创建带有

00:05:23.620 --> 00:05:28.120
一百个元素，但您可以将其用于

00:05:25.240 --> 00:05:31.509
单个元素或最多八个或十个

00:05:28.120 --> 00:05:33.159
在这种情况下，我猜也是不错的部分

00:05:31.509 --> 00:05:34.870
这些事情显然是需要的

00:05:33.159 --> 00:05:36.610
减少通常需要输入的内容

00:05:34.870 --> 00:05:38.500
首先要做的是创建您的列表，然后

00:05:36.610 --> 00:05:41.800
去添加并添加，然后您可以开始

00:05:38.500 --> 00:05:43.659
使用这个集合耶

00:05:41.800 --> 00:05:45.279
可以创建一个清单，例如

00:05:43.659 --> 00:05:47.139
我要有三个要素

00:05:45.279 --> 00:05:50.229
清单，突然间我有了清单

00:05:47.139 --> 00:05:53.110
看不见的三个要素

00:05:50.229 --> 00:05:55.000
在这里我想我可以强迫它，但是

00:05:53.110 --> 00:05:58.240
这里的收藏实际上是一成不变的

00:05:55.000 --> 00:06:00.129
这是不可修改的，所以你回来了

00:05:58.240 --> 00:06:01.569
只读的东西你不能

00:06:00.129 --> 00:06:03.520
实际向其中添加元素

00:06:01.569 --> 00:06:06.189
删除它的元素，有一些

00:06:03.520 --> 00:06:09.550
我们可以利用的好地方

00:06:06.189 --> 00:06:12.310
在JVM中的JDK内部进行优化

00:06:09.550 --> 00:06:15.610
该集合的实现如此

00:06:12.310 --> 00:06:17.199
例如，如果我们找到更好的方法

00:06:15.610 --> 00:06:19.330
代表这里的数据

00:06:17.199 --> 00:06:20.889
没有成熟的背景

00:06:19.330 --> 00:06:24.370
否则我们必须收集的

00:06:20.889 --> 00:06:26.080
分配以潜在地支持您

00:06:24.370 --> 00:06:28.029
以后添加元素或删除

00:06:26.080 --> 00:06:29.860
元素ATAR我们可以优化一些东西

00:06:28.029 --> 00:06:32.229
仅针对一种元素

00:06:29.860 --> 00:06:35.349
对此没有任何修改

00:06:32.229 --> 00:06:38.039
确实可以在足迹方面有很大帮助

00:06:35.349 --> 00:06:40.129
还有表现

00:06:38.039 --> 00:06:43.860
那是另一个例子，我想我可以

00:06:40.129 --> 00:06:52.800
创建一些我们都喜欢我的弦

00:06:43.860 --> 00:06:56.580
要在这里创建一个hello world列表， 

00:06:52.800 --> 00:07:01.939
只是因为我喜欢来自

00:06:56.580 --> 00:07:04.889
 Java 8我要针对每个系统说

00:07:01.939 --> 00:07:07.080
打印线，您将拥有自己的

00:07:04.889 --> 00:07:10.939
弦片顶部或显然我什么我

00:07:07.080 --> 00:07:10.939
也可以做到这一点

00:07:12.319 --> 00:07:20.039
收藏家的意思，你将有

00:07:16.860 --> 00:07:21.449
你的食物你好世界串起另一个

00:07:20.039 --> 00:07:22.739
附加功能

00:07:21.449 --> 00:07:27.719
当我希望我们关注这个话题时

00:07:22.739 --> 00:07:30.300
是一个疯狂的运算符，所以你可以说

00:07:27.719 --> 00:07:34.259
例如从中挑选元素

00:07:30.300 --> 00:07:36.569
做梦，而这件事是正确的

00:07:34.259 --> 00:07:39.869
我猜这不是真的，所以我

00:07:36.569 --> 00:07:42.629
要说的是这里的组件

00:07:39.869 --> 00:07:45.319
不等于逗号，我要

00:07:42.629 --> 00:07:45.319
再次收集

00:07:47.340 --> 00:07:53.430
你会得到你好

00:07:49.290 --> 00:07:55.950
也下降一滴，所以两个新

00:07:53.430 --> 00:07:58.350
方法武装的流我们喜欢流我们

00:07:55.950 --> 00:08:00.210
例如优化流，我们已经

00:07:58.350 --> 00:08:02.280
 Arden JDK的优化流九为

00:08:00.210 --> 00:08:04.790
好，所以改进进来了

00:08:02.280 --> 00:08:07.320
那个一般区域

00:08:04.790 --> 00:08:09.660
谈到串联字符串，我

00:08:07.320 --> 00:08:11.700
找不到显示此内容的好方法

00:08:09.660 --> 00:08:15.000
因为这是一个很低的水平

00:08:11.700 --> 00:08:16.890
后端ish本质上是其中之一

00:08:15.000 --> 00:08:19.530
我们要做的事情就是改变方式

00:08:16.890 --> 00:08:21.380
我们生成用于连接的字节码

00:08:19.530 --> 00:08:24.210
字符串，以便将字符串拼接在一起

00:08:21.380 --> 00:08:26.310
在路径上，所以首先有一个

00:08:24.210 --> 00:08:28.260
 Java中的很多字符串操作

00:08:26.310 --> 00:08:30.510
这对于我们来说非常重要

00:08:28.260 --> 00:08:32.660
正确并对其进行优化

00:08:30.510 --> 00:08:35.670
过去我们拥有一系列

00:08:32.660 --> 00:08:37.860
串联附加操作

00:08:35.670 --> 00:08:41.010
 JVM和JIT编译器必须排序

00:08:37.860 --> 00:08:43.440
尝试图案匹配和刮擦

00:08:41.010 --> 00:08:44.970
拼凑在一起，使

00:08:43.440 --> 00:08:48.000
最终的事实是

00:08:44.970 --> 00:08:50.700
只是连接两个字符串什么Java 

00:08:48.000 --> 00:08:52.980
 C确实从九开始就是输出一个

00:08:50.700 --> 00:08:54.870
字节码序列，还有更多

00:08:52.980 --> 00:08:56.730
对我们来说显而易见的是

00:08:54.870 --> 00:08:58.500
使用invokedynamic指令

00:08:56.730 --> 00:09:00.420
这是我们增加的一条指令

00:08:58.500 --> 00:09:02.300
最近在第一个也是唯一的

00:09:00.420 --> 00:09:05.160
已添加到Java中的指令

00:09:02.300 --> 00:09:07.050
它正在使用此指令来

00:09:05.160 --> 00:09:09.030
使JVM更容易检测

00:09:07.050 --> 00:09:12.480
这另一个好的部分是

00:09:09.030 --> 00:09:13.800
那个相同的模式可以一周或

00:09:12.480 --> 00:09:15.600
更多的实施和

00:09:13.800 --> 00:09:18.180
优化机会，然后搬家

00:09:15.600 --> 00:09:20.850
进入图书馆，以便将来

00:09:18.180 --> 00:09:22.890
 JDK发行，我们找到了更好的方法

00:09:20.850 --> 00:09:25.140
优化这一点，我们有相同的

00:09:22.890 --> 00:09:26.820
模式，我们可以检测到它，然后再次

00:09:25.140 --> 00:09:28.140
更新执行

00:09:26.820 --> 00:09:30.330
连接字符串中的

00:09:28.140 --> 00:09:31.800
背景，你们都会

00:09:30.330 --> 00:09:36.600
的好处而不必

00:09:31.800 --> 00:09:39.180
更改您的代码，然后回到

00:09:36.600 --> 00:09:41.520
我经历了J Shell的演示文稿

00:09:39.180 --> 00:09:42.990
我碰到了便利工厂

00:09:41.520 --> 00:09:45.120
收集方法是

00:09:42.990 --> 00:09:46.680
我要寻找的单词的顺序

00:09:45.120 --> 00:09:49.190
在五个字符串的连接中

00:09:46.680 --> 00:09:51.810
再次是字符串的串联

00:09:49.190 --> 00:09:53.980
有备用幻灯片，以防演示

00:09:51.810 --> 00:09:56.930
没有解决

00:09:53.980 --> 00:09:58.880
如果您想进一步了解J shell 

00:09:56.930 --> 00:10:00.649
 Java期间有很多会议

00:09:58.880 --> 00:10:02.540
我建议你至少去

00:10:00.649 --> 00:10:06.019
一是因为J shell非常

00:10:02.540 --> 00:10:09.320
功能强大，我在末尾有一张幻灯片

00:10:06.019 --> 00:10:10.420
如果您忘记了发生了什么

00:10:09.320 --> 00:10:14.720
那张幻灯片

00:10:10.420 --> 00:10:16.579
进入虚拟机的关键之一

00:10:14.720 --> 00:10:19.430
我们在JVM端所做的是切换

00:10:16.579 --> 00:10:21.860
过去的默认垃圾收集器

00:10:19.430 --> 00:10:24.079
成为并行垃圾收集器，但是我们

00:10:21.860 --> 00:10:26.269
现在已经切换为使用g1 

00:10:24.079 --> 00:10:30.140
垃圾首先作为垃圾收集器

00:10:26.269 --> 00:10:32.959
默认情况下，g1垃圾收集器具有

00:10:30.140 --> 00:10:37.100
其目标是提供良好的吞吐量

00:10:32.959 --> 00:10:39.440
低延迟或低成本时间

00:10:37.100 --> 00:10:40.910
基于区域，因此它的工作方式

00:10:39.440 --> 00:10:43.670
背景是整个堆都是

00:10:40.910 --> 00:10:46.339
分成各个区域

00:10:43.670 --> 00:10:48.200
那是g1收藏家选择的

00:10:46.339 --> 00:10:51.260
小心要去哪个地区

00:10:48.200 --> 00:10:52.790
尽量疏散到空旷而干净的地方

00:10:51.260 --> 00:10:56.209
以便我们以后可以重用

00:10:52.790 --> 00:10:57.649
新分配及其基本方式

00:10:56.209 --> 00:10:59.449
起作用的是，它选择了那些

00:10:57.649 --> 00:11:01.579
首先拥有最多的垃圾

00:10:59.449 --> 00:11:03.589
最少的物体实际上仍然静止

00:11:01.579 --> 00:11:06.199
然后将所有直播者删除

00:11:03.589 --> 00:11:07.790
反对其他地方，什么

00:11:06.199 --> 00:11:09.470
你在那之后显然是一个

00:11:07.790 --> 00:11:11.899
清理可以开始的空白区域

00:11:09.470 --> 00:11:13.250
分配，以便他们的名字来自

00:11:11.899 --> 00:11:15.290
垃圾的事实

00:11:13.250 --> 00:11:18.800
首先，好像您知道

00:11:15.290 --> 00:11:21.410
最垃圾优先默认帖子

00:11:18.800 --> 00:11:24.050
 g1的时间目标是200毫秒

00:11:21.410 --> 00:11:25.459
但这可以耕种，所以如果你想

00:11:24.050 --> 00:11:27.250
例如更高的吞吐量，并且可以

00:11:25.459 --> 00:11:29.839
容忍更多的发布时间

00:11:27.250 --> 00:11:31.670
那么您可以以一种方式继续

00:11:29.839 --> 00:11:33.230
您希望缩短发布时间，但可以

00:11:31.670 --> 00:11:36.470
容忍和吞吐量开销

00:11:33.230 --> 00:11:39.320
我认为这是另一种方式，就像我一样

00:11:36.470 --> 00:11:42.410
提到的g1已经在JDK中

00:11:39.320 --> 00:11:44.930
虽然它是在现在之前制成的，但我们

00:11:42.410 --> 00:11:46.670
已经对

00:11:44.930 --> 00:11:49.220
你想实现的实现

00:11:46.670 --> 00:11:50.839
性能更高，这是一个持续的过程

00:11:49.220 --> 00:11:54.560
实际上，如果您

00:11:50.839 --> 00:11:56.779
会拿起JDK 10今天的代码

00:11:54.560 --> 00:11:59.149
编译它，您会发现我们

00:11:56.779 --> 00:12:00.649
已经改进了9中的功能

00:11:59.149 --> 00:12:02.000
有很多很多

00:12:00.649 --> 00:12:04.730
活动在这里进行

00:12:02.000 --> 00:12:08.180
的改进，但最终目标是

00:12:04.730 --> 00:12:10.420
真的在默认DC中有AGC 

00:12:08.180 --> 00:12:12.830
一个不仅仅在乎的

00:12:10.420 --> 00:12:14.990
吞吐量，但延迟时间短

00:12:12.830 --> 00:12:16.790
考虑到这一点，我们相信很多

00:12:14.990 --> 00:12:18.020
的应用程序将在

00:12:16.790 --> 00:12:23.090
一种方式或另一种时延敏感的

00:12:18.020 --> 00:12:24.250
不只是批量处理数据，如果

00:12:23.090 --> 00:12:26.540
您想了解更多有关

00:12:24.250 --> 00:12:27.980
 jg1至少有几个

00:12:26.540 --> 00:12:31.850
会议将涉及到

00:12:27.980 --> 00:12:34.370
再次推荐你去那些

00:12:31.850 --> 00:12:36.200
 GCS的主题之一是其他

00:12:34.370 --> 00:12:38.890
我们要做的是弃用并删除

00:12:36.200 --> 00:12:41.270
我们在JVM中拥有的一些代码

00:12:38.890 --> 00:12:44.030
具体来说，我们已弃用

00:12:41.270 --> 00:12:47.750
并发标记扫描收集器

00:12:44.030 --> 00:12:49.910
 CMS是CMS收集器CMS的简称

00:12:47.750 --> 00:12:52.340
传统上用于低延迟

00:12:49.910 --> 00:12:55.370
用例你没有非常

00:12:52.340 --> 00:12:57.320
大堆以及您的应用程序在哪里

00:12:55.370 --> 00:12:59.900
如果我把它表现得比较好

00:12:57.320 --> 00:13:01.700
这样，对我们在JVM上的挑战

00:12:59.900 --> 00:13:03.410
方面一直是代码库

00:13:01.700 --> 00:13:05.480
收集器的实施已经

00:13:03.410 --> 00:13:07.430
非常非常难以维护，它具有

00:13:05.480 --> 00:13:09.589
很难发展另一个

00:13:07.430 --> 00:13:12.800
收藏家同时还要确保

00:13:09.589 --> 00:13:15.589
 CMS的工作方式与我们所做的一样

00:13:12.800 --> 00:13:18.080
现在要做的就是弃用它，目标是

00:13:15.589 --> 00:13:21.260
在将来的版本中删除它

00:13:18.080 --> 00:13:23.210
还没有决定哪一个

00:13:21.260 --> 00:13:25.700
希望和目标是要有另一个

00:13:23.210 --> 00:13:28.280
收集器会填充空白设备，如果您

00:13:25.700 --> 00:13:29.750
所以在某些情况下

00:13:28.280 --> 00:13:31.370
可能需要针对不同情况进行调整

00:13:29.750 --> 00:13:34.460
示例以及所有这些，如果您使用的是

00:13:31.370 --> 00:13:37.130
 CMS再次意识到以下事实： 

00:13:34.460 --> 00:13:39.560
正在消失，我们非常

00:13:37.130 --> 00:13:42.410
感谢有关d1和其他方面的反馈

00:13:39.560 --> 00:13:44.500
收藏家可以帮助我们改善那些

00:13:42.410 --> 00:13:46.730
那就是我们要去的未来

00:13:44.500 --> 00:13:50.000
我认为我们所做的另一件事

00:13:46.730 --> 00:13:52.880
影响更少的人是，实际上

00:13:50.000 --> 00:13:56.150
删除一些GC组合

00:13:52.880 --> 00:13:59.060
在早期的JD案例中，这是

00:13:56.150 --> 00:14:01.430
我们在JDK 8中弃用了

00:13:59.060 --> 00:14:03.800
现在我们已经在9中完全删除了

00:14:01.430 --> 00:14:07.400
曾经有一个叫做ICMS的东西

00:14:03.800 --> 00:14:09.530
而且还有一组不同的

00:14:07.400 --> 00:14:13.030
各种DC的组合似乎

00:14:09.530 --> 00:14:15.340
说不是很好用

00:14:13.030 --> 00:14:21.370
再次让我们难以维持

00:14:15.340 --> 00:14:24.100
现在已经走了我们做过的其他事情

00:14:21.370 --> 00:14:26.710
改善双方共享的足迹

00:14:24.100 --> 00:14:30.430
性能是我们工作的基础

00:14:26.710 --> 00:14:32.560
呼叫CD的CD是类数据的缩写

00:14:30.430 --> 00:14:34.810
共享此功能已在

00:14:32.560 --> 00:14:37.930
 JDK也要花相当长的时间

00:14:34.810 --> 00:14:41.710
您过去仅限于Java基础

00:14:37.930 --> 00:14:43.420
自己对JRE进行分类，但是

00:14:41.710 --> 00:14:46.060
截至目前，我认为您八个

00:14:43.420 --> 00:14:49.300
更新或八个更新，我应该说或

00:14:46.060 --> 00:14:51.040
九，我们现在也支持

00:14:49.300 --> 00:14:53.500
应用程序类也是如此

00:14:51.040 --> 00:14:55.810
不仅限于GRE， 

00:14:53.500 --> 00:14:58.150
可以用于您的东西的东西

00:14:55.810 --> 00:14:59.800
应用程序类以及方法

00:14:58.150 --> 00:15:02.230
这有效地工作是，你有

00:14:59.800 --> 00:15:04.210
一种跑步训练

00:15:02.230 --> 00:15:06.090
您的应用程序一次以及什么VM 

00:15:04.210 --> 00:15:08.200
要做的就是阅读所有课程

00:15:06.090 --> 00:15:10.450
格式化它们并以某种方式

00:15:08.200 --> 00:15:13.060
 JVM内部更喜欢

00:15:10.450 --> 00:15:14.830
针对JVM的优化格式，然后

00:15:13.060 --> 00:15:17.230
将其存储到我们所谓的

00:15:14.830 --> 00:15:20.050
 CVS存档的应用程序类

00:15:17.230 --> 00:15:21.490
简而言之，这实际上是一种共享

00:15:20.050 --> 00:15:24.520
库非常像您在

00:15:21.490 --> 00:15:26.680
操作系统级别，但它是

00:15:24.520 --> 00:15:28.330
不是小精灵，它不是本机格式

00:15:26.680 --> 00:15:32.380
现在的操作系统

00:15:28.330 --> 00:15:34.180
至少那是你的

00:15:32.380 --> 00:15:36.460
训练跑步，然后每次跑步

00:15:34.180 --> 00:15:38.680
随后运行JVM之后

00:15:36.460 --> 00:15:40.720
那会指出你可以指出的地方

00:15:38.680 --> 00:15:42.370
这些档案，它将使

00:15:40.720 --> 00:15:45.700
使用

00:15:42.370 --> 00:15:47.740
存档并利用其中的关键之一

00:15:45.700 --> 00:15:50.170
我们在89年中所做的事情是

00:15:47.740 --> 00:15:51.820
改善所涉内容

00:15:50.170 --> 00:15:54.550
存档，所以它曾经是

00:15:51.820 --> 00:15:57.100
基本上只是类数据本身

00:15:54.550 --> 00:15:59.860
字节码和侧面结构，但现在

00:15:57.100 --> 00:16:01.360
我们还可以依次存储字符串和

00:15:59.860 --> 00:16:03.070
这也在不断发展

00:16:01.360 --> 00:16:06.400
是我们正在考虑添加甚至

00:16:03.070 --> 00:16:09.280
展望未来，您还有两个

00:16:06.400 --> 00:16:12.430
主要的改进类型

00:16:09.280 --> 00:16:15.070
第一个是启动时间，所​​以四个

00:16:12.430 --> 00:16:17.200
由于VM不再需要读取

00:16:15.070 --> 00:16:19.690
来自jar文件中文件的类数据

00:16:17.200 --> 00:16:20.980
对于班级文件，并按摩和

00:16:19.690 --> 00:16:23.110
确保格式正确

00:16:20.980 --> 00:16:24.760
再一次所有这些，现在我们可以

00:16:23.110 --> 00:16:26.600
只需拿起这个共享档案， 

00:16:24.760 --> 00:16:29.269
它已经在右边

00:16:26.600 --> 00:16:30.680
您可以改善启动时间并

00:16:29.269 --> 00:16:35.630
我们正在研究的这种特定情况

00:16:30.680 --> 00:16:37.519
基于WebLogic服务器的域，我们可以

00:16:35.630 --> 00:16:39.889
看到改进是球场

00:16:37.519 --> 00:16:41.329
像这样的百分之25-30 

00:16:39.889 --> 00:16:42.860
显然会对您有所不同

00:16:41.329 --> 00:16:45.170
应用程序，但我认为我们已经看到了

00:16:42.860 --> 00:16:48.529
通常你会看到这个球场

00:16:45.170 --> 00:16:51.170
 25 30％和启动时间，所​​以

00:16:48.529 --> 00:16:52.910
非常重要，另一方面

00:16:51.170 --> 00:16:54.350
这是足迹，所以事实

00:16:52.910 --> 00:16:56.569
现在可以共享更多数据

00:16:54.350 --> 00:16:59.779
跨实例意味着您拥有

00:16:56.569 --> 00:17:01.910
减少浪费，减少占地面积

00:16:59.779 --> 00:17:04.370
个别实例，显然

00:17:01.910 --> 00:17:05.959
您运行的实例越多，效果越好

00:17:04.370 --> 00:17:08.809
确实在某种程度上假设您是

00:17:05.959 --> 00:17:11.929
运行类似的应用程序

00:17:08.809 --> 00:17:13.760
这可能是相同的确切堆栈

00:17:11.929 --> 00:17:16.370
软件或至少它们共享

00:17:13.760 --> 00:17:18.350
一些常见的框架和库，但是

00:17:16.370 --> 00:17:20.809
我认为从我们所看到的

00:17:18.350 --> 00:17:22.480
一个非常典型的部署环境

00:17:20.809 --> 00:17:25.100
我认为这种情况在

00:17:22.480 --> 00:17:26.929
像医生这样的环境

00:17:25.100 --> 00:17:28.189
实际上具有完全相同的图像

00:17:26.929 --> 00:17:31.280
您将多个不同

00:17:28.189 --> 00:17:33.289
来自那个的容器，所以很棒的部分

00:17:31.280 --> 00:17:35.120
这是与

00:17:33.289 --> 00:17:37.220
医生以及事实是否

00:17:35.120 --> 00:17:39.110
您将共享档案放在

00:17:37.220 --> 00:17:41.120
在医生之间共享的层

00:17:39.110 --> 00:17:43.299
容器，那么它将非常有用

00:17:41.120 --> 00:17:45.919
像操作系统共享库

00:17:43.299 --> 00:17:48.049
而且看起来好像我们没有保存

00:17:45.919 --> 00:17:50.360
很多，所以这里的酒吧是独一无二的

00:17:48.049 --> 00:17:54.080
包含和不包含应用程序的每个实例的数据

00:17:50.360 --> 00:17:57.289
严重的是与和

00:17:54.080 --> 00:17:59.929
没有绝对的利亚，这是

00:17:57.289 --> 00:18:02.090
有和没有的总占地面积

00:17:59.929 --> 00:18:04.070
绝对是的，它看起来像

00:18:02.090 --> 00:18:08.630
酒吧是相似的，你应该注意

00:18:04.070 --> 00:18:11.090
 y轴是对数的，但最后

00:18:08.630 --> 00:18:12.590
这实际上会随着时间的推移加起来，所以

00:18:11.090 --> 00:18:15.110
在这种情况下，这是10种不同

00:18:12.590 --> 00:18:17.120
实例，如果您运行更多，您将获得

00:18:15.110 --> 00:18:19.400
更多分享以及我们在这里看到的内容

00:18:17.120 --> 00:18:21.950
大约是10％，可能听不到

00:18:19.400 --> 00:18:23.720
非常喜欢我的笔记本电脑，但如果您

00:18:21.950 --> 00:18:25.429
如果您将其标记在数据中

00:18:23.720 --> 00:18:26.809
拥有数十万个中心

00:18:25.429 --> 00:18:29.130
实例然后突然开始

00:18:26.809 --> 00:18:34.350
变成真实的美元

00:18:29.130 --> 00:18:36.390
我想说的是，应用程序CD将是

00:18:34.350 --> 00:18:38.610
开源这是功能

00:18:36.390 --> 00:18:40.680
 CD的方面一直是开放的，但是

00:18:38.610 --> 00:18:43.140
应用CD的外观已关闭，但

00:18:40.680 --> 00:18:45.630
我们正在对此进行开源

00:18:43.140 --> 00:18:49.080
无法保证将其完全释放

00:18:45.630 --> 00:18:51.420
将进入，但足以说我们

00:18:49.080 --> 00:18:54.170
非常渴望得到这个

00:18:51.420 --> 00:18:54.170
尽快

00:18:55.410 --> 00:19:02.730
在类似的主题上，我们有AB CD 

00:18:59.760 --> 00:19:04.650
负责处理Java类数据和

00:19:02.730 --> 00:19:07.110
我们在最后工作的另一件事

00:19:04.650 --> 00:19:10.200
几年被称为功能

00:19:07.110 --> 00:19:13.020
 alt或提前编译，因此

00:19:10.200 --> 00:19:15.300
正在用AB CD和JIT编译

00:19:13.020 --> 00:19:17.610
数据有Serge它的编译代码

00:19:15.300 --> 00:19:19.590
 AB CD所做的相同的事情

00:19:17.610 --> 00:19:21.390
班级数据，所以您通常会知道

00:19:19.590 --> 00:19:22.770
您拥有的操作系​​统共享库

00:19:21.390 --> 00:19:26.220
数据方面，那么你有代码

00:19:22.770 --> 00:19:28.590
方面，您将它们打包为

00:19:26.220 --> 00:19:31.740
住别的东西可能是

00:19:28.590 --> 00:19:34.890
用代码做同样的事情

00:19:31.740 --> 00:19:36.360
有一个叫做J OTC的工具

00:19:34.890 --> 00:19:38.130
一个类文件，它将吐出一个

00:19:36.360 --> 00:19:41.940
在这种情况下，共享库实际上

00:19:38.130 --> 00:19:43.770
是一个小精灵，你不能在里面使用它

00:19:41.940 --> 00:19:47.820
 VM很明显，但是它仍然被存储

00:19:43.770 --> 00:19:49.680
以完全相同的格式，所以您

00:19:47.820 --> 00:19:51.270
基本上再做一次训练

00:19:49.680 --> 00:19:54.510
运行，但在这种情况下，它是一个工具

00:19:51.270 --> 00:19:56.670
您运行，然后用于后续的JVM运行

00:19:54.510 --> 00:19:59.520
您将其指向该共享库， 

00:19:56.670 --> 00:20:02.790
共享库将被重用

00:19:59.520 --> 00:20:05.070
代码本身效率不高

00:20:02.790 --> 00:20:07.500
像您一样表现出色

00:20:05.070 --> 00:20:09.630
您将拥有在线上的一切

00:20:07.500 --> 00:20:12.480
喷射我们拥有的宫颈飞行员

00:20:09.630 --> 00:20:15.330
在虚拟机内部，但是这里很棒

00:20:12.480 --> 00:20:17.430
是实际存储的代码

00:20:15.330 --> 00:20:20.070
包含很多信息

00:20:17.430 --> 00:20:22.260
驱动所需的性能分析代码

00:20:20.070 --> 00:20:24.540
稍后在运行时进行优化

00:20:22.260 --> 00:20:26.520
服务器编译器实际上

00:20:24.540 --> 00:20:28.680
加入并改进此代码

00:20:26.520 --> 00:20:31.110
存档中的内容基本上

00:20:28.680 --> 00:20:33.510
你会像第一层

00:20:31.110 --> 00:20:35.850
使用äôt代码然后

00:20:33.510 --> 00:20:39.450
在运行时将优化

00:20:35.850 --> 00:20:42.390
该功能是实验性的

00:20:39.450 --> 00:20:45.540
在9中，并且仅在

00:20:42.390 --> 00:20:50.160
 x64表示我们正在添加平台

00:20:45.540 --> 00:20:53.340
随着时间的推移以及类似类型的支持

00:20:50.160 --> 00:20:55.890
可以从我的旧约中看到好处

00:20:53.340 --> 00:20:59.040
在它上面滑动实际上不是下一张幻灯片

00:20:55.890 --> 00:21:00.480
那我等一下，但是你有

00:20:59.040 --> 00:21:02.520
启动您有时间达到顶峰

00:21:00.480 --> 00:21:04.470
性能而不用去

00:21:02.520 --> 00:21:06.150
贯穿整个第一周期

00:21:04.470 --> 00:21:09.690
解释代码然后探查

00:21:06.150 --> 00:21:11.820
使用性能分析捕获来编译代码

00:21:09.690 --> 00:21:14.820
代码，然后优化代码

00:21:11.820 --> 00:21:16.770
最终我们已经完全

00:21:14.820 --> 00:21:19.920
捷径的第一部分，所以你

00:21:16.770 --> 00:21:21.570
有更快的时间北岸时间更短

00:21:19.920 --> 00:21:23.970
达到最佳性能或减少时间

00:21:21.570 --> 00:21:25.310
峰值性能和代码可以

00:21:23.970 --> 00:21:27.270
显然也可以共享

00:21:25.310 --> 00:21:30.360
实例，您也会涉足

00:21:27.270 --> 00:21:32.400
除了成为东西之外还节省

00:21:30.360 --> 00:21:33.720
对最终用户有用，这也是

00:21:32.400 --> 00:21:36.750
我们正在计划使用的东西

00:21:33.720 --> 00:21:40.200
在JDK内部可以移动

00:21:36.750 --> 00:21:42.840
我们的JIT编译器转换为Java 

00:21:40.200 --> 00:21:44.610
仍然用Java实现

00:21:42.840 --> 00:21:45.630
工作进度，但这是

00:21:44.610 --> 00:21:49.220
有点像

00:21:45.630 --> 00:21:51.780
我不会进入的先决条件

00:21:49.220 --> 00:21:54.600
这张幻灯片的所有细节

00:21:51.780 --> 00:21:56.580
但我会说它正在显示

00:21:54.600 --> 00:21:58.500
基本上你有默认情况

00:21:56.580 --> 00:22:00.480
你有这样的情况，你只有一个

00:21:58.500 --> 00:22:01.770
 OT，您有CD的情况

00:22:00.480 --> 00:22:03.840
你有情况

00:22:01.770 --> 00:22:05.070
两者，基本上是什么

00:22:03.840 --> 00:22:08.070
突出的事实是，他们

00:22:05.070 --> 00:22:09.810
既可以改善自身状况，又可以

00:22:08.070 --> 00:22:11.430
在一起是我们最大的收获

00:22:09.810 --> 00:22:14.100
从中受益

00:22:11.430 --> 00:22:18.030
所以CD和ALT一起是一个

00:22:14.100 --> 00:22:19.680
如果你想的话，很快乐的组合

00:22:18.030 --> 00:22:21.090
知道更多关于OT的事实

00:22:19.680 --> 00:22:23.370
我们至少有两次会议

00:22:21.090 --> 00:22:26.100
好吧，我将再次对此进行幻灯片

00:22:23.370 --> 00:22:29.220
演讲结束后

00:22:26.100 --> 00:22:30.870
万一你想看看，我会

00:22:29.220 --> 00:22:34.230
仔细浏览其余的幻灯片

00:22:30.870 --> 00:22:36.270
很快，我为那趟Java飞行感到抱歉

00:22:34.230 --> 00:22:38.880
录音机，我想强调一点

00:22:36.270 --> 00:22:40.740
工具帮助我们找到了很多东西

00:22:38.880 --> 00:22:42.930
瓶颈是功能

00:22:40.740 --> 00:22:45.300
捕获信息非常

00:22:42.930 --> 00:22:47.520
细粒度的方式，但是速度非常快

00:22:45.300 --> 00:22:49.470
有效的方法，所以基本上目标是

00:22:47.520 --> 00:22:51.930
使其默认打开并始终收集

00:22:49.470 --> 00:22:54.990
所有这些数据，我们也有一些

00:22:51.930 --> 00:22:55.260
可视化帮助表明这一点，我们

00:22:54.990 --> 00:22:56.760
能够

00:22:55.260 --> 00:23:00.300
我们在内部使用它来驱动

00:22:56.760 --> 00:23:02.790
开发JFR也正在开放

00:23:00.300 --> 00:23:04.290
再次在我们想尝试的地方采购

00:23:02.790 --> 00:23:07.200
尽快，但没有

00:23:04.290 --> 00:23:09.090
更快，如果您想了解

00:23:07.200 --> 00:23:10.350
有关飞行记录器的更多信息

00:23:09.090 --> 00:23:13.110
清酒任务控制是

00:23:10.350 --> 00:23:16.350
可视化工具上有会议

00:23:13.110 --> 00:23:18.480
同样，我将跳过这些

00:23:16.350 --> 00:23:21.360
幻灯片，我确实想说我们

00:23:18.480 --> 00:23:23.550
统一我们的登录框架，我们有一个

00:23:21.360 --> 00:23:26.100
现在，JVM中的统一日志记录框架

00:23:23.550 --> 00:23:27.660
过去大约是四，十或

00:23:26.100 --> 00:23:30.660
二十岁左右

00:23:27.660 --> 00:23:32.490
您在JVM中拥有的子系统现在我们有一个

00:23:30.660 --> 00:23:34.590
这样您就可以使用

00:23:32.490 --> 00:23:37.860
这个框架，我个人

00:23:34.590 --> 00:23:41.160
很高兴看到这是一个非常

00:23:37.860 --> 00:23:43.230
功能的快速快照如下

00:23:41.160 --> 00:23:46.800
 JDK 9中的其他内容

00:23:43.230 --> 00:23:48.060
和整个星期在一起

00:23:46.800 --> 00:23:49.620
显然，您将有机会

00:23:48.060 --> 00:23:51.720
赶上这些不同的这些

00:23:49.620 --> 00:23:53.790
不同方面，但希望

00:23:51.720 --> 00:23:55.260
让您快速了解了

00:23:53.790 --> 00:23:56.460
功能方面，我

00:23:55.260 --> 00:24:03.180
交给桑迪亚

00:23:56.460 --> 00:24:05.280
表演部分感谢迈克尔，最后

00:24:03.180 --> 00:24:08.130
几年来我们为

00:24:05.280 --> 00:24:12.810
并合作进行了许多优化

00:24:08.130 --> 00:24:15.510
在开放的JDK中，朝向Gerry犬

00:24:12.810 --> 00:24:19.170
关键的优化包括

00:24:15.510 --> 00:24:21.540
向量化，并已疯狂加密

00:24:19.170 --> 00:24:24.930
和压缩加速紧凑

00:24:21.540 --> 00:24:27.600
字符串和新的API支持以及

00:24:24.930 --> 00:24:36.270
为英特尔优化新的API 

00:24:27.600 --> 00:24:39.750
平台，所以英特尔最近发布了

00:24:36.270 --> 00:24:42.660
 7月的Skylake平台，除非

00:24:39.750 --> 00:24:45.000
除非另有说明

00:24:42.660 --> 00:24:47.640
运行在顶针Skylake 

00:24:45.000 --> 00:24:53.040
平台即英特尔至强白金

00:24:47.640 --> 00:24:58.200
 8180的2.5千兆赫兹和3.8的涡轮增压

00:24:53.040 --> 00:25:00.210
千兆赫兹，所以有384 gb的ram，我们

00:24:58.200 --> 00:25:04.110
正在比较最新的JDK 8版本

00:25:00.210 --> 00:25:06.450
使用JDK 9的JDK 8更新144 

00:25:04.110 --> 00:25:08.419
刚刚于9月22日发布

00:25:06.450 --> 00:25:13.970
所有的运行都在进行中

00:25:08.419 --> 00:25:18.200
在下一个平台上

00:25:13.970 --> 00:25:24.559
我们扩展了矢量化功能

00:25:18.200 --> 00:25:27.440
向量化到JVM的512位

00:25:24.559 --> 00:25:29.509
 38岁的Jade已经支持

00:25:27.440 --> 00:25:32.090
矢量化他们确实监督我们

00:25:29.509 --> 00:25:36.080
向量化，到现在

00:25:32.090 --> 00:25:38.210
扩展到512位以受益于

00:25:36.080 --> 00:25:42.559
 Skydeck支持的avx-512 

00:25:38.210 --> 00:25:46.600
我们超级展开的平台

00:25:42.559 --> 00:25:49.629
向量化的主循环有减少

00:25:46.600 --> 00:25:52.909
支持添加了矢量循环

00:25:49.629 --> 00:25:55.820
他们的减少是新星基督和

00:25:52.909 --> 00:25:58.159
还支持其他

00:25:55.820 --> 00:26:00.889
现在可以向量化的操作

00:25:58.159 --> 00:26:01.309
我接下来的几个细节

00:26:00.889 --> 00:26:06.830
打架

00:26:01.309 --> 00:26:09.019
因此avx-512在Intel中引入

00:26:06.830 --> 00:26:12.940
至强融核处理器，可用于

00:26:09.019 --> 00:26:14.359
英特尔Skylake处理器

00:26:12.940 --> 00:26:20.649
延伸

00:26:14.359 --> 00:26:23.359
只需宽到512位，即64 

00:26:20.649 --> 00:26:27.769
字节操作可以一次完成

00:26:23.359 --> 00:26:29.629
指令或30到简短的16塔

00:26:27.769 --> 00:26:31.100
 16单位置和8 

00:26:29.629 --> 00:26:33.559
双精度浮点

00:26:31.100 --> 00:26:37.909
操作可以一次完成

00:26:33.559 --> 00:26:41.179
指令有32个CMM寄存器

00:26:37.909 --> 00:26:46.070
有500个叫位宽，所以我们

00:26:41.179 --> 00:26:47.960
已经做的就是增加对

00:26:46.070 --> 00:26:52.220
热电联产艾米克，所以我去了

00:26:47.960 --> 00:26:55.179
在JVM jet中进行热电联产并扩展

00:26:52.220 --> 00:26:57.559
我们也有类似的向量化

00:26:55.179 --> 00:27:03.139
优化数组字符串固有

00:26:57.559 --> 00:27:06.259
受益于AVX-512的方法

00:27:03.139 --> 00:27:08.539
是一个小的Java示例

00:27:06.259 --> 00:27:11.389
表明我们曾经展示过

00:27:08.539 --> 00:27:16.669
格里笼之间的好处

00:27:11.389 --> 00:27:18.769
九这个循环上校确实自动

00:27:16.669 --> 00:27:22.849
向量化这里有操作

00:27:18.769 --> 00:27:26.599
在两个数组的元素上完成

00:27:22.849 --> 00:27:28.639
结果存储在第三个数组中

00:27:26.599 --> 00:27:31.820
这个特殊的例子与众不同

00:27:28.639 --> 00:27:35.359
数据类型和不同的操作是

00:27:31.820 --> 00:27:37.700
我们为确保收益而展示的

00:27:35.359 --> 00:27:40.519
我们基本上是比较32 

00:27:37.700 --> 00:27:44.450
字节向量化

00:27:40.519 --> 00:27:47.809
以前的平台要64字节

00:27:44.450 --> 00:27:50.959
现在是512位Elektra 

00:27:47.809 --> 00:27:54.259
在geni k9中可用，您需要使用

00:27:50.959 --> 00:27:57.669
使用X等于3个JVM命令行

00:27:54.259 --> 00:28:02.179
选择获得512位Twitter认证

00:27:57.669 --> 00:28:05.509
而且我们也展示了

00:28:02.179 --> 00:28:07.779
对齐JVM有一个称为Optical的选项

00:28:05.509 --> 00:28:13.849
可以在管道中对齐

00:28:07.779 --> 00:28:18.349
对齐数据类型，因此此图表在此处

00:28:13.849 --> 00:28:20.959
显示了的性能提升

00:28:18.349 --> 00:28:24.289
从32字节开始的浮点运算

00:28:20.959 --> 00:28:30.099
向量到64字节向量和

00:28:24.289 --> 00:28:33.320
性能提升高达30％ 

00:28:30.099 --> 00:28:39.529
没有对齐并且上升到70 

00:28:33.320 --> 00:28:42.829
对齐的百分比，这里我们显示

00:28:39.529 --> 00:28:46.039
整数运算的性能

00:28:42.829 --> 00:28:49.519
和逻辑运算在这里

00:28:46.039 --> 00:28:52.369
性能提升高达40％ 

00:28:49.519 --> 00:28:58.849
没有对齐和80％ 

00:28:52.369 --> 00:29:00.979
对齐，因此自动矢量化不会

00:28:58.849 --> 00:29:02.839
仅有益于经典Java代码，但

00:29:00.979 --> 00:29:06.589
它也可以帮助

00:29:02.839 --> 00:29:10.029
在G十年中引入，所以还可以

00:29:06.589 --> 00:29:13.110
一个更复杂的lambda 

00:29:10.029 --> 00:29:16.470
表达式比上一个示例

00:29:13.110 --> 00:29:18.270
这个lambda会自动矢量化

00:29:16.470 --> 00:29:22.920
如果您会使用平行

00:29:18.270 --> 00:29:25.350
有了这个lambda，那么你会看到

00:29:22.920 --> 00:29:28.260
再次跨多核以及

00:29:25.350 --> 00:29:30.780
您将受益于

00:29:28.260 --> 00:29:34.950
处理器，所以这里运行完成

00:29:30.780 --> 00:29:40.080
在单个代码上，您会看到有一个

00:29:34.950 --> 00:29:45.860
对准和64可获得高达60％的增益

00:29:40.080 --> 00:29:49.680
字节向量，就像我之前提到的

00:29:45.860 --> 00:29:53.490
果冻犬具有矢量化功能并具有

00:29:49.680 --> 00:29:55.800
通过JDK 8制作，因此专用于

00:29:53.490 --> 00:30:01.590
就像我在

00:29:55.800 --> 00:30:04.200
前面的例子有一个前循环

00:30:01.590 --> 00:30:06.690
主循环和后循环生成

00:30:04.200 --> 00:30:09.630
前循环执行目标

00:30:06.690 --> 00:30:12.180
对齐和主循环是一个

00:30:09.630 --> 00:30:15.750
自动矢量化和标量

00:30:12.180 --> 00:30:19.710
后循环用于尾部处理，因此

00:30:15.750 --> 00:30:22.290
 jdk 9我们现在超级展开向量

00:30:19.710 --> 00:30:24.750
自向量主循环以来的主循环

00:30:22.290 --> 00:30:28.050
超级展开有一个向量单

00:30:24.750 --> 00:30:30.240
迭代后循环可以做很多事情

00:30:28.050 --> 00:30:34.130
操作剩余操作使用

00:30:30.240 --> 00:30:39.110
尽可能的矢量指令

00:30:34.130 --> 00:30:42.169
所以这是减少的一个例子

00:30:39.110 --> 00:30:45.850
代码的突出显示部分是

00:30:42.169 --> 00:30:49.330
进行总和减少

00:30:45.850 --> 00:30:53.539
面积元素的乘积和

00:30:49.330 --> 00:30:55.730
减少JDK 9之前

00:30:53.539 --> 00:30:58.429
基本支持如果有这样的

00:30:55.730 --> 00:31:00.679
减少经典的Java代码

00:30:58.429 --> 00:31:04.039
循环不会被矢量化，您也不会

00:31:00.679 --> 00:31:08.360
受益于矢量化当归

00:31:04.039 --> 00:31:13.669
 9并且支持减少，您

00:31:08.360 --> 00:31:18.760
可以看到，最高可获得2倍的增益

00:31:13.669 --> 00:31:22.580
这个特定的代码我在这里显示

00:31:18.760 --> 00:31:25.760
向量后循环生成的代码和我

00:31:22.580 --> 00:31:28.280
可以看到乘法VP ml LD 

00:31:25.760 --> 00:31:31.130
这是向量指令， 

00:31:28.280 --> 00:31:34.970
其余代码用于求和

00:31:31.130 --> 00:31:38.750
归约运算和求和为

00:31:34.970 --> 00:31:40.940
广泛用于例如

00:31:38.750 --> 00:31:44.390
卷积进行图像处理或

00:31:40.940 --> 00:31:48.880
 k-均值算法矩阵乘法

00:31:44.390 --> 00:31:48.880
这样所有的人都可以从封闭中走出来

00:31:49.059 --> 00:31:56.299
所以我们也认识到

00:31:53.830 --> 00:31:59.000
向量循环中的表达式和

00:31:56.299 --> 00:32:02.900
例如，基本上将循环向量化

00:31:59.000 --> 00:32:05.090
数学点平方根（如果有） 

00:32:02.900 --> 00:32:07.520
对每个元素执行平方根

00:32:05.090 --> 00:32:11.299
现在被识别的阵列

00:32:07.520 --> 00:32:13.460
然后生成向量平方根

00:32:11.299 --> 00:32:16.549
那里的说明，我们平方根PV和

00:32:13.460 --> 00:32:21.049
您可以看到从专用转向JDK 9 

00:32:16.549 --> 00:32:23.919
我们看到性能提高了5倍以上

00:32:21.049 --> 00:32:23.919
对于这个循环

00:32:25.850 --> 00:32:33.860
所以在切诺基9中还有另一个功能

00:32:30.290 --> 00:32:36.050
引入了所谓的紧凑型琴弦

00:32:33.860 --> 00:32:40.340
我们与甲骨文合作

00:32:36.050 --> 00:32:44.380
查理·亨特维度Tobias Hartman 

00:32:40.340 --> 00:32:49.930
还有很多其他的东西

00:32:44.380 --> 00:32:53.270
紧凑的字符串会尝试使用吗

00:32:49.930 --> 00:32:58.580
一个字节存储一个字符

00:32:53.270 --> 00:33:01.220
 Java默认支持的字符串

00:32:58.580 --> 00:33:05.330
那里的Unicode字符

00:33:01.220 --> 00:33:08.630
每个字符两个字节，但s键和

00:33:05.330 --> 00:33:12.620
英语上半身总是零

00:33:08.630 --> 00:33:15.590
您可以使用单字节字符

00:33:12.620 --> 00:33:20.570
因此，无需更改可见内容

00:33:15.590 --> 00:33:22.250
用户内部存储

00:33:20.570 --> 00:33:26.060
从字符数组更改为

00:33:22.250 --> 00:33:30.740
字节数组，如果所有元素

00:33:26.060 --> 00:33:32.900
字符串适合一个字节，然后

00:33:30.740 --> 00:33:35.780
字符串元素存储在单个

00:33:32.900 --> 00:33:39.610
字节，如果不是，则字符串被夸大

00:33:35.780 --> 00:33:41.990
和两个管道用于元素所以

00:33:39.610 --> 00:33:43.700
这是字符串

00:33:41.990 --> 00:33:46.460
广泛用于任何Java 

00:33:43.700 --> 00:33:49.190
程序，这样可以减少底层

00:33:46.460 --> 00:33:52.910
该程序使用的存储和

00:33:49.190 --> 00:33:57.830
不仅最有趣

00:33:52.910 --> 00:34:00.590
操作在后面使用

00:33:57.830 --> 00:34:03.260
矢量指令，所以现在因为

00:34:00.590 --> 00:34:04.490
字符串是字符串元素的一半

00:34:03.260 --> 00:34:07.340
你可以做一倍的大小

00:34:04.490 --> 00:34:10.960
操作背后，所以有一个

00:34:07.340 --> 00:34:15.140
性能改善也是可能的

00:34:10.960 --> 00:34:17.420
有一些开销来检查每个

00:34:15.140 --> 00:34:20.870
元素，并在字符串增加时

00:34:17.420 --> 00:34:22.370
可能，所以这两个内存

00:34:20.870 --> 00:34:25.520
改善垃圾的大小

00:34:22.370 --> 00:34:29.000
收集性能和能力

00:34:25.520 --> 00:34:31.070
做两倍的手术对

00:34:29.000 --> 00:34:35.360
应用程序

00:34:31.070 --> 00:34:38.170
这是我们运行的一个例子

00:34:35.360 --> 00:34:41.630
分别在2005年完成了

00:34:38.170 --> 00:34:46.400
 on'y的桌面非常好，这是一个

00:34:41.630 --> 00:34:48.290
高峰运行，所以我们看到了大约5％的效果

00:34:46.400 --> 00:34:51.950
首先提高峰值吞吐量

00:34:48.290 --> 00:34:57.740
图片宝贝2005，这是一个堆

00:34:51.950 --> 00:35:00.350
转储，这样您就可以看到总数

00:34:57.740 --> 00:35:03.860
实例数量约

00:35:00.350 --> 00:35:07.910
 JDK 8和JDK 9之间的相似之处

00:35:03.860 --> 00:35:11.680
减少了使用的字节数

00:35:07.910 --> 00:35:13.880
减少20％，如果您看到突出显示的内容

00:35:11.680 --> 00:35:16.580
显示数字的部分

00:35:13.880 --> 00:35:18.470
字符数组和

00:35:16.580 --> 00:35:20.180
字节数组的实例数，因此

00:35:18.470 --> 00:35:30.320
以前的字符数组是

00:35:20.180 --> 00:35:33.320
现在通过JDK 9到今天，当归9我们

00:35:30.320 --> 00:35:36.590
还致力于优化数学

00:35:33.320 --> 00:35:39.890
库一些关键的三角函数

00:35:36.590 --> 00:35:45.020
正弦等先验方法

00:35:39.890 --> 00:35:48.550
花费了指数并记录了

00:35:45.020 --> 00:35:51.800
优化，您可以看到高达5倍的增益

00:35:48.550 --> 00:35:55.130
对于这个数学库，这些数学

00:35:51.800 --> 00:35:58.490
图书馆广泛用于大型

00:35:55.130 --> 00:36:02.120
数据机器学习的财务

00:35:58.490 --> 00:36:08.210
期权定价算法和HPC以及

00:36:02.120 --> 00:36:10.850
这里我们展示了金融的三个微观指标

00:36:08.210 --> 00:36:13.880
期权定价的蒙特卡洛盒式电表

00:36:10.850 --> 00:36:19.100
和黑人斯科尔斯，他们看到了收获

00:36:13.880 --> 00:36:23.570
到5倍，例如，这些是

00:36:19.100 --> 00:36:29.800
哥谭看到使用cos正弦对数平方根

00:36:23.570 --> 00:36:29.800
 power exp等，这就是游戏的原因

00:36:30.560 --> 00:36:36.960
 JDK九

00:36:32.070 --> 00:36:40.610
我们还致力于优化密钥

00:36:36.960 --> 00:36:43.170
加密算法可从中受益

00:36:40.610 --> 00:36:46.370
内部架构说明

00:36:43.170 --> 00:36:51.560
英特尔架构提供了是和我

00:36:46.370 --> 00:36:54.720
催化剂倍增，您知道avx2 

00:36:51.560 --> 00:36:56.280
你也可以做64位乘法

00:36:54.720 --> 00:37:01.650
获得128位结果

00:36:56.280 --> 00:37:05.550
所以所有在后面的东西

00:37:01.650 --> 00:37:10.230
优化的配音有益于

00:37:05.550 --> 00:37:13.620
加密Java提供所有加密

00:37:10.230 --> 00:37:16.650
通过提供程序框架Java 

00:37:13.620 --> 00:37:18.900
密码体系结构和Sunjai C 

00:37:16.650 --> 00:37:23.040
是默认提供程序，所以我们有

00:37:18.900 --> 00:37:27.810
优化了Sun JC提供程序方法

00:37:23.040 --> 00:37:36.050
通过优化的ups，您可以看到

00:37:27.810 --> 00:37:42.150
计数器的收益是10倍

00:37:36.050 --> 00:37:45.330
 GCM解码，因此SHA优化

00:37:42.150 --> 00:37:50.390
这是通过AVX指令

00:37:45.330 --> 00:37:53.130
 AES计数器和AES GCM 

00:37:50.390 --> 00:37:54.810
表达式是三个，是的，我是GCM 

00:37:53.130 --> 00:37:56.670
也有一个G哈希组件

00:37:54.810 --> 00:38:01.350
催化剂的好处成倍增加

00:37:56.670 --> 00:38:05.250
加密RSA通过64位

00:38:01.350 --> 00:38:11.460
乘以给出128位结果

00:38:05.250 --> 00:38:15.320
 ADC X 80或附件，因此JDK 9 

00:38:11.460 --> 00:38:19.340
压缩加速JDK九还

00:38:15.320 --> 00:38:23.910
在切诺基九之前添加了功能

00:38:19.340 --> 00:38:27.180
审讯被捆绑的大海

00:38:23.910 --> 00:38:31.620
很多作为嘴唇的一部分拉链左右

00:38:27.180 --> 00:38:33.780
现在在jdk九使用Celebi系统

00:38:31.620 --> 00:38:37.980
而不是选择束，这样

00:38:33.780 --> 00:38:40.110
使用户有能力

00:38:37.980 --> 00:38:41.850
用

00:38:40.110 --> 00:38:42.600
加速的软件不是硬件

00:38:41.850 --> 00:38:47.130
加速的

00:38:42.600 --> 00:38:48.810
一个，在这里我给了两个链接

00:38:47.130 --> 00:38:51.080
可以进行软件加速

00:38:48.810 --> 00:38:54.150
通过英特尔性能原语

00:38:51.080 --> 00:38:56.610
或者有一个github项目是

00:38:54.150 --> 00:38:59.460
在此处列出的文件中

00:38:56.610 --> 00:39:02.970
用于硬件加速

00:38:59.460 --> 00:39:06.180
英特尔推出了快速协助，将其作为

00:39:02.970 --> 00:39:09.020
天际芯片组路易斯堡

00:39:06.180 --> 00:39:12.270
芯片组，因此快速协助也有

00:39:09.020 --> 00:39:14.130
压缩加速能力

00:39:12.270 --> 00:39:18.230
通过驱动程序和库支持

00:39:14.130 --> 00:39:22.740
可以在给他的链接中找到

00:39:18.230 --> 00:39:24.330
所以这个这个显示了性能

00:39:22.740 --> 00:39:28.440
通过软件改进

00:39:24.330 --> 00:39:31.980
我用开源加速了飞跃

00:39:28.440 --> 00:39:34.680
从这里给出的链接和

00:39:31.980 --> 00:39:38.670
显示的性能是针对卡尔加里的

00:39:34.680 --> 00:39:42.540
语料库数据设置压缩部分

00:39:38.670 --> 00:39:44.700
我唯一要做的就是

00:39:42.540 --> 00:39:48.270
获取源代码，构建一个库，然后

00:39:44.700 --> 00:39:52.500
将LD库路径设置为已构建

00:39:48.270 --> 00:39:56.280
库，我们可以看到您知道1.5 X 

00:39:52.500 --> 00:40:02.400
 2高达3倍的压缩增益，因此

00:39:56.280 --> 00:40:10.670
在Freebird上非常令人鼓舞的东西

00:40:02.400 --> 00:40:14.490
在Java 9和Intel中添加了crc32 C 

00:40:10.670 --> 00:40:19.560
的指令称为crc32 C 

00:40:14.490 --> 00:40:23.640
可用于实现crc32 C的

00:40:19.560 --> 00:40:28.830
 Java 9 API，这基本上是

00:40:23.640 --> 00:40:32.340
我对CRC多项式模糊不清

00:40:28.830 --> 00:40:34.800
 JDK 9以及专用

00:40:32.340 --> 00:40:37.830
切诺基9都有乔伊告诉

00:40:34.800 --> 00:40:43.170
 crc32与CRC不同

00:40:37.830 --> 00:40:45.720
多项式，那就是JIT 

00:40:43.170 --> 00:40:49.740
 zip crc32使用

00:40:45.720 --> 00:40:52.440
催化剂成倍增加，因此crc32参见

00:40:49.740 --> 00:40:54.780
新的API增加了2倍

00:40:52.440 --> 00:40:58.770
性能改善

00:40:54.780 --> 00:41:00.420
以前的优化版本，所以我们

00:40:58.770 --> 00:41:04.740
知道校验和是广泛的

00:41:00.420 --> 00:41:07.830
用于有大量数据的地方

00:41:04.740 --> 00:41:15.600
示例Cassandra HBase，它们都使用

00:41:07.830 --> 00:41:18.780
字典数组中的校验和API 

00:41:15.600 --> 00:41:22.290
比较由保罗介绍

00:41:18.780 --> 00:41:24.990
桑德斯，我们与保罗紧密合作

00:41:22.290 --> 00:41:27.300
桑德斯优化面积比较

00:41:24.990 --> 00:41:32.430
使用相同的D指令

00:41:27.300 --> 00:41:36.210
返回和数组比较用于

00:41:32.430 --> 00:41:40.710
 Cassandra和HBase进行关键比较

00:41:36.210 --> 00:41:49.740
例如，Cassandra使用

00:41:40.710 --> 00:41:51.510
大小为8 K或64 K，所以您知道那里

00:41:49.740 --> 00:41:57.180
是为每个块计算的校验和

00:41:51.510 --> 00:42:00.840
所以这将使我们受益

00:41:57.180 --> 00:42:04.940
有一个团队的基础算法

00:42:00.840 --> 00:42:04.940
使用类似的指示

00:42:06.450 --> 00:42:15.030
最后但并非最不重要的一点是

00:42:10.230 --> 00:42:19.579
由Joe Darcy添加的MMA API 

00:42:15.030 --> 00:42:19.579
乘法和加法以及

00:42:21.650 --> 00:42:28.349
添加后，截断部分具有

00:42:24.809 --> 00:42:32.130
加法后打开，因此Java规范会

00:42:28.349 --> 00:42:34.339
不允许我们知道优化

00:42:32.130 --> 00:42:37.980
有一个乘法和加法

00:42:34.339 --> 00:42:41.460
我们无法使用FME对其进行优化，因为

00:42:37.980 --> 00:42:44.569
它希望我们进行四舍五入或

00:42:41.460 --> 00:42:48.020
每次操作后的截断部分

00:42:44.569 --> 00:42:51.599
所以现在有了这个新的API，我们可以优化

00:42:48.020 --> 00:42:58.579
 FME使用基础架构作为

00:42:51.599 --> 00:43:02.280
确认说明和FMA用于

00:42:58.579 --> 00:43:07.349
卷积的图像处理是

00:43:02.280 --> 00:43:12.569
用于类的矩阵乘法

00:43:07.349 --> 00:43:17.220
算法，因此对HPC有利

00:43:12.569 --> 00:43:22.410
和机器学习，是的，我认为

00:43:17.220 --> 00:43:26.040
其他人展示了很多新东西

00:43:22.410 --> 00:43:28.290
在j9中可用的功能

00:43:26.040 --> 00:43:29.819
请下载并试用并给出

00:43:28.290 --> 00:43:33.119
我们的反馈，这是合法的

00:43:29.819 --> 00:43:35.200
的免责声明和优化通知

00:43:33.119 --> 00:43:40.430
英特尔

00:43:35.200 --> 00:43:40.430
 [掌声] 

