WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.200 --> 00:00:05.670
 [音乐] 

00:00:03.170 --> 00:00:08.910
你好，谢谢你来到这里

00:00:05.670 --> 00:00:11.429
早上我叫乔·达西，我在这里工作

00:00:08.910 --> 00:00:13.740
 Oracle的Java平台小组，我将成为

00:00:11.429 --> 00:00:16.619
今天谈到JDK 9语言

00:00:13.740 --> 00:00:18.600
工具和库功能有一个

00:00:16.619 --> 00:00:20.070
如果我们今天在谈话中有很多材料

00:00:18.600 --> 00:00:22.680
最后没有时间提问

00:00:20.070 --> 00:00:25.320
您可以将您的问题发布到

00:00:22.680 --> 00:00:28.980
标签显示在第一张幻灯片上

00:00:25.320 --> 00:00:32.640
我还将在Twitter上发布以下内容的PDF链接： 

00:00:28.980 --> 00:00:35.160
谈话后的幻灯片，这是一个非常

00:00:32.640 --> 00:00:37.440
 Oracle法律团队的重要幻灯片

00:00:35.160 --> 00:00:39.840
他们想让你知道不要非常信任

00:00:37.440 --> 00:00:41.790
今天我在这里不得不说很多

00:00:39.840 --> 00:00:43.920
将此称为安全港声明

00:00:41.790 --> 00:00:45.480
但是如果一个开发者是另一个

00:00:43.920 --> 00:00:47.489
您对那里的安全港感兴趣

00:00:45.480 --> 00:00:48.960
该地区还有许多其他安全港

00:00:47.489 --> 00:00:51.829
我们可以谈谈，所以我很高兴

00:00:48.960 --> 00:00:54.239
在演讲后分享一些提示

00:00:51.829 --> 00:00:56.600
快速调查其中的受众

00:00:54.239 --> 00:01:00.239
 JDK培训您在生产中使用的培训

00:00:56.600 --> 00:01:04.170
 JDK 9拼图切割的早期访问

00:01:00.239 --> 00:01:06.360
在拼图中，关于

00:01:04.170 --> 00:01:07.770
其他JDK 9早期访问版本

00:01:06.360 --> 00:01:09.450
人们下载了它们，很好

00:01:07.770 --> 00:01:14.880
也许还会下载更多

00:01:09.450 --> 00:01:17.280
谈话结束后，这大部分

00:01:14.880 --> 00:01:21.229
使用JDK 8的观众非常好

00:01:17.280 --> 00:01:23.909
如果你回来了，人们仍然在7 

00:01:21.229 --> 00:01:28.320
也许1/4的观众仍然是7 

00:01:23.909 --> 00:01:31.170
停滞释放6多了几手

00:01:28.320 --> 00:01:31.530
并承认没关系，我们都是朋友

00:01:31.170 --> 00:01:34.829
这里

00:01:31.530 --> 00:01:37.650
 KD K 5或更早的版本

00:01:34.829 --> 00:01:39.390
人们确实承认有很多新

00:01:37.650 --> 00:01:41.310
从那时起也许就是这样

00:01:39.390 --> 00:01:45.270
您将有动力去

00:01:41.310 --> 00:01:48.479
谈话快结束时升级

00:01:45.270 --> 00:01:49.710
 JDK 9 JD犬齿概述

00:01:48.479 --> 00:01:53.460
已经开发了许多

00:01:49.710 --> 00:01:54.869
年和船期早于

00:01:53.460 --> 00:01:57.659
一般可用性即将出现

00:01:54.869 --> 00:01:59.640
正如我提到的，在七月的几个月

00:01:57.659 --> 00:02:01.829
有两个的早期访问二进制文件

00:01:59.640 --> 00:02:04.649
发展线既是主线

00:02:01.829 --> 00:02:07.590
一个和一个具有拼图功能的

00:02:04.649 --> 00:02:09.390
先进的JDK九点

00:02:07.590 --> 00:02:12.330
在...的主持下发展

00:02:09.390 --> 00:02:13.920
打开JDK，因此有一个项目

00:02:12.330 --> 00:02:15.209
他们的各种邮件列表

00:02:13.920 --> 00:02:18.300
源代码（如果您有兴趣） 

00:02:15.209 --> 00:02:20.370
还有各种各样的收养小组

00:02:18.300 --> 00:02:23.220
我们为JDK 9扩展的计划中的一些

00:02:20.370 --> 00:02:25.319
是为了接触各种开源

00:02:23.220 --> 00:02:27.209
项目尽早使用JDK 9 

00:02:25.319 --> 00:02:28.800
访问方式一路走来，我们可以

00:02:27.209 --> 00:02:30.350
获得有关工作原理的更多反馈

00:02:28.800 --> 00:02:32.640
好，什么工作不好

00:02:30.350 --> 00:02:35.250
在接下来的演讲中，我将

00:02:32.640 --> 00:02:37.170
使用术语Jeff这些是JDK 

00:02:35.250 --> 00:02:39.540
增强建议，它们是

00:02:37.170 --> 00:02:43.290
我们用于管理要素工作的过程

00:02:39.540 --> 00:02:45.150
现在在JDK和Duke中需要您

00:02:43.290 --> 00:02:47.459
您下载这些抢先体验

00:02:45.150 --> 00:02:49.200
在您的CI系统中进行尝试

00:02:47.459 --> 00:02:53.370
让我们知道什么在起作用

00:02:49.200 --> 00:02:55.170
不是我们在周期中走得很远

00:02:53.370 --> 00:02:57.420
对于JDK 9，我们是其中之一

00:02:55.170 --> 00:02:58.650
阶段，但仍有时间发送给我们

00:02:57.420 --> 00:03:02.700
一些反馈，让我们知道如何

00:02:58.650 --> 00:03:05.040
关于JDK 9的总结

00:03:02.700 --> 00:03:07.350
 JDK 9的最大功能是模块化

00:03:05.040 --> 00:03:08.989
这已经进行了许多

00:03:07.350 --> 00:03:11.700
项目拼图的年限和

00:03:08.989 --> 00:03:13.350
多个模块捆绑在一起

00:03:11.700 --> 00:03:15.870
包装并提供更强大的

00:03:13.350 --> 00:03:16.950
比jar文件更早的封装

00:03:15.870 --> 00:03:18.540
这周已经有一个

00:03:16.950 --> 00:03:20.370
关于的DevOps会话数

00:03:18.540 --> 00:03:24.510
您可能已经拥有的模块化

00:03:20.370 --> 00:03:26.579
看到这是一个很大的变化，这是一个

00:03:24.510 --> 00:03:28.590
语言转换成更大的

00:03:26.579 --> 00:03:31.230
平台的变化有一个新的

00:03:28.590 --> 00:03:32.640
一种Java文件模块信息文件

00:03:31.230 --> 00:03:35.970
允许之间的依赖

00:03:32.640 --> 00:03:40.019
声明为Java C的模块编译

00:03:35.970 --> 00:03:42.690
这些文件，然后在运行时Java 

00:03:40.019 --> 00:03:44.130
命令也已更新以强制执行

00:03:42.690 --> 00:03:46.530
相同的依赖项限制

00:03:44.130 --> 00:03:48.180
在模块信息文件中声明有

00:03:46.530 --> 00:03:50.540
其他各种支持更改

00:03:48.180 --> 00:03:54.390
例如在Co反射和

00:03:50.540 --> 00:03:56.700
语言模型API作为一种大语言

00:03:54.390 --> 00:03:59.280
变化确实影响了

00:03:56.700 --> 00:04:01.650
平台项目lambda和JDK 8是

00:03:59.280 --> 00:04:04.170
语言变化也很大

00:04:01.650 --> 00:04:06.989
 JDK 9中的模块性变化有些

00:04:04.170 --> 00:04:08.790
他们解决的意义更大

00:04:06.989 --> 00:04:10.889
更根本地编程模型

00:04:08.790 --> 00:04:12.660
使用您可以编程的模块

00:04:10.889 --> 00:04:14.340
大的以不同的粒度

00:04:12.660 --> 00:04:15.810
你有不同的问题要考虑

00:04:14.340 --> 00:04:17.700
在设计应用程序时

00:04:15.810 --> 00:04:19.560
关于什么模块的库

00:04:17.700 --> 00:04:23.400
边界不仅是什么

00:04:19.560 --> 00:04:25.470
您可能拥有的JDK类型

00:04:23.400 --> 00:04:28.020
在devoxx的9个相关讲座中有一些

00:04:25.470 --> 00:04:30.210
一周前我的同事

00:04:28.020 --> 00:04:32.879
我昨天讲了关于

00:04:30.210 --> 00:04:34.650
 JDK 9的优势，我想这个

00:04:32.879 --> 00:04:36.419
今天的谈话不仅涵盖了

00:04:34.650 --> 00:04:38.729
锋利的边缘，但也有一些倒圆角

00:04:36.419 --> 00:04:41.759
我个人比较喜欢经典

00:04:38.729 --> 00:04:43.770
 og配置文件，如此处所示，有一个

00:04:41.759 --> 00:04:45.870
与k9相关的其他数据的讨论次数

00:04:43.770 --> 00:04:47.310
今天晚些时候，我也将重点介绍

00:04:45.870 --> 00:04:49.199
现在两个

00:04:47.310 --> 00:04:51.300
特里莎（Trisha）钥匙今天早上要去

00:04:49.199 --> 00:04:53.789
在谈论工具支持

00:04:51.300 --> 00:04:55.620
 IntelliJ for JDK 9和今天下午

00:04:53.789 --> 00:04:59.039
 Minaj剧情也将在谈论

00:04:55.620 --> 00:05:00.810
关于Eclipse对JDK 9的支持

00:04:59.039 --> 00:05:03.240
当然不是现代发展

00:05:00.810 --> 00:05:05.370
只是语言的支持

00:05:03.240 --> 00:05:08.759
 JDK中附带的功能

00:05:05.370 --> 00:05:12.900
希望在诸如此类的工具中获得良好的支持

00:05:08.759 --> 00:05:15.449
正如艾格斯在接下来的演讲中概述的那样

00:05:12.900 --> 00:05:19.080
我将简要讨论

00:05:15.449 --> 00:05:21.740
我们在

00:05:19.080 --> 00:05:24.389
 Java平台组朝着不断发展的Java迈进

00:05:21.740 --> 00:05:26.729
只是对JDK的大小有所了解

00:05:24.389 --> 00:05:28.800
 9 JD 9是

00:05:26.729 --> 00:05:32.520
错误修复数量，这是一个

00:05:28.800 --> 00:05:35.699
比较每个JDK 9错误修复的图形

00:05:32.520 --> 00:05:37.710
建立到JDK 8，我们有一个更高的

00:05:35.699 --> 00:05:40.110
修复率9，发布继续进行

00:05:37.710 --> 00:05:42.360
更长的时间，我们开始趋于平稳

00:05:40.110 --> 00:05:43.889
现在这是一两个星期前的

00:05:42.360 --> 00:05:47.250
有很多好的变化

00:05:43.889 --> 00:05:49.159
 JDK 9这些更改跨越了许多

00:05:47.250 --> 00:05:51.599
在工具方面有所改进

00:05:49.159 --> 00:05:54.270
语言更改和库更新

00:05:51.599 --> 00:05:56.069
有时候功能很好

00:05:54.270 --> 00:05:58.199
有时划出这些水桶

00:05:56.069 --> 00:05:59.969
他们越过所以这只是一个粗糙

00:05:58.199 --> 00:06:01.740
其余谈话的大纲，如果我们

00:05:59.969 --> 00:06:05.610
最后我会花一些时间

00:06:01.740 --> 00:06:08.789
问答管理

00:06:05.610 --> 00:06:10.620
我们用来管理Java的方法

00:06:08.789 --> 00:06:13.620
与我们所说的方法不同

00:06:10.620 --> 00:06:16.229
戴涅索在《指环王》中

00:06:13.620 --> 00:06:19.279
电影，我们在

00:06:16.229 --> 00:06:22.289
 Java管理的支持者视图

00:06:19.279 --> 00:06:24.449
在甲骨文的最近七年

00:06:22.289 --> 00:06:26.039
有一个始终如一的首要任务

00:06:24.449 --> 00:06:28.949
对于Java平台组

00:06:26.039 --> 00:06:31.050
保持Java充满活力是保持Java的一部分

00:06:28.949 --> 00:06:33.870
朝气蓬勃的东西正在保持工作

00:06:31.050 --> 00:06:36.029
今天工作明天

00:06:33.870 --> 00:06:39.210
我们来讨论兼容性和

00:06:36.029 --> 00:06:41.940
我们使用的一般进化政策

00:06:39.210 --> 00:06:43.800
 Java与一般进化论Paul 

00:06:41.940 --> 00:06:46.010
为了兼容性，我们不想要

00:06:43.800 --> 00:06:47.760
破坏二进制兼容性为

00:06:46.010 --> 00:06:50.220
定义Java语言规范

00:06:47.760 --> 00:06:52.380
那意味着我们要保持

00:06:50.220 --> 00:06:55.110
今天链接的程序

00:06:52.380 --> 00:06:57.420
明天我们要避免介绍

00:06:55.110 --> 00:06:59.880
源不兼容，我们希望

00:06:57.420 --> 00:07:02.220
管理行为兼容性

00:06:59.880 --> 00:07:04.170
这扩展到语言进化

00:07:02.220 --> 00:07:06.420
好吧，这意味着我们要继续

00:07:04.170 --> 00:07:09.600
识别所有旧文件

00:07:06.420 --> 00:07:12.450
回到那些1440 5.3班级的方式

00:07:09.600 --> 00:07:14.490
来自jdk 102的文件，我们希望限制

00:07:12.450 --> 00:07:17.070
当前法律法规停止的情况

00:07:14.490 --> 00:07:18.990
编译，我们希望避免更改

00:07:17.070 --> 00:07:24.420
在引入的代码生成中

00:07:18.990 --> 00:07:26.070
行为改变令人惊讶，我们

00:07:24.420 --> 00:07:28.320
不只是想保留一切

00:07:26.070 --> 00:07:29.700
一样，因为那样就没有进展

00:07:28.320 --> 00:07:32.010
因此，在

00:07:29.700 --> 00:07:33.510
进行中的稳定性

00:07:32.010 --> 00:07:36.090
认识到有很多价值

00:07:33.510 --> 00:07:39.150
保持良好的兼容性并保持良好状态

00:07:36.090 --> 00:07:40.620
工作，所以我们谈到了

00:07:39.150 --> 00:07:42.840
兼容性的三个方面

00:07:40.620 --> 00:07:46.260
我们从事间谍活动和行为举止，因此我们可以

00:07:42.840 --> 00:07:49.370
认为那些定义了一个小向量

00:07:46.260 --> 00:07:52.200
您可能会想起的空间

00:07:49.370 --> 00:07:53.910
物理课，我们有不同

00:07:52.200 --> 00:07:56.040
有关兼容性的政策

00:07:53.910 --> 00:07:57.750
我们有不同的发行版本

00:07:56.040 --> 00:08:00.990
例如，如果我们有季度报告

00:07:57.750 --> 00:08:03.870
安全更新的那些很小

00:08:00.990 --> 00:08:06.900
他们可能使之不兼容的区域

00:08:03.870 --> 00:08:09.090
变化，因此您可以通过此框识别

00:08:06.900 --> 00:08:10.830
在这里我们想要一些行为

00:08:09.090 --> 00:08:12.930
毕竟如果有一些不好的地方就改变

00:08:10.830 --> 00:08:14.820
我们想要停止工作的代码

00:08:12.930 --> 00:08:16.710
希望那停止工作，这样

00:08:14.820 --> 00:08:18.360
对于X点不兼容

00:08:16.710 --> 00:08:21.390
例子，也许有一点

00:08:18.360 --> 00:08:25.140
源编码能力，我们允许

00:08:21.390 --> 00:08:27.060
较大的更新版本，例如8u 20或au 40 

00:08:25.140 --> 00:08:29.340
还有更多的修复程序

00:08:27.060 --> 00:08:33.240
功能，所以我们会有更大的区域

00:08:29.340 --> 00:08:35.250
允许在那里，但在两种情况下，我们都留在

00:08:33.240 --> 00:08:37.320
源行为朴素的意义

00:08:35.250 --> 00:08:39.240
没有二进制兼容性更改

00:08:37.320 --> 00:08:41.909
之所以允许，是因为我们希望人们

00:08:39.240 --> 00:08:43.770
能够轻松更新到更新

00:08:41.909 --> 00:08:46.830
发布而不必担心

00:08:43.770 --> 00:08:48.570
他们的程序停止链接

00:08:46.830 --> 00:08:51.720
情况有些不同

00:08:48.570 --> 00:08:55.160
平台版本，例如JDK 8 GA和现在

00:08:51.720 --> 00:08:56.779
特别是JDK 9，我们有一个更大的

00:08:55.160 --> 00:08:59.060
玩更多的能力区域

00:08:56.779 --> 00:09:01.129
行为改变更多源代码

00:08:59.060 --> 00:09:03.709
变化并有充分的理由

00:09:01.129 --> 00:09:05.899
甚至一些二进制和兼容的更改

00:09:03.709 --> 00:09:09.139
我们将看到一个或两个例子

00:09:05.899 --> 00:09:12.560
在谈话的后面，这是一个很好的例子

00:09:09.139 --> 00:09:15.170
帮助说明不同的种类

00:09:12.560 --> 00:09:16.670
我们可以看一下行为改变政策

00:09:15.170 --> 00:09:19.490
在哈希集的规范中

00:09:16.670 --> 00:09:20.990
迭代器说，这里你回来了

00:09:19.490 --> 00:09:23.269
迭代器和元素被返回

00:09:20.990 --> 00:09:25.100
没有特定顺序意味着

00:09:23.269 --> 00:09:27.110
您的程序取决于您的订单

00:09:25.100 --> 00:09:28.730
程序有点bug，也意味着

00:09:27.110 --> 00:09:31.430
规范允许的

00:09:28.730 --> 00:09:35.689
更改顺序，但这并没有

00:09:31.430 --> 00:09:38.300
意味着我们总是会更改它，那么什么是

00:09:35.689 --> 00:09:41.269
如果我们进行了更改，将对兼容性产生影响

00:09:38.300 --> 00:09:43.129
迭代顺序良好的哈希

00:09:41.269 --> 00:09:45.230
它的二进制兼容方法集

00:09:43.129 --> 00:09:47.269
没有改变，所以不用担心

00:09:45.230 --> 00:09:48.470
那里也有源兼容

00:09:47.269 --> 00:09:50.930
同样的原因，它不会改变

00:09:48.470 --> 00:09:52.310
您的代码如何编译

00:09:50.930 --> 00:09:54.649
这第三种变化是

00:09:52.310 --> 00:09:56.569
行为改变，我们知道人们可以

00:09:54.649 --> 00:09:58.490
设施中的实际情况取决于迭代

00:09:56.569 --> 00:10:00.709
为了我们甚至有一些这样的例子

00:09:58.490 --> 00:10:03.709
在我们自己的jdk代码库中

00:10:00.709 --> 00:10:05.269
现在又是这种变化

00:10:03.709 --> 00:10:07.339
改变演员的迭代顺序

00:10:05.269 --> 00:10:10.009
通常会超出范围

00:10:07.339 --> 00:10:12.560
更新版本，但这将是

00:10:10.009 --> 00:10:14.449
我们可以在一个平台上做，也可以做

00:10:12.560 --> 00:10:16.639
发布，我们今天就这样做

00:10:14.449 --> 00:10:20.569
更好的哈希算法的优势

00:10:16.639 --> 00:10:21.500
随着时间的推移发展，所以如果你想

00:10:20.569 --> 00:10:23.660
进一步了解这一点

00:10:21.500 --> 00:10:25.220
特定版本，您可以查看

00:10:23.660 --> 00:10:26.930
发行说明和兼容性指南

00:10:25.220 --> 00:10:29.959
他们确实使用新的来源

00:10:26.930 --> 00:10:31.730
行为分类

00:10:29.959 --> 00:10:33.949
文件是按照这些思路制作的

00:10:31.730 --> 00:10:35.300
适用于JDK 8，并在接下来的几个月内

00:10:33.949 --> 00:10:39.980
也会有类似的指南

00:10:35.300 --> 00:10:41.839
为JDK 9生产的，数据犬如何

00:10:39.980 --> 00:10:44.029
正如我之前提到的不同

00:10:41.839 --> 00:10:46.959
允许更大范围

00:10:44.029 --> 00:10:49.430
不兼容的更改，这是为了

00:10:46.959 --> 00:10:51.860
进一步的长期发展

00:10:49.430 --> 00:10:54.199
平台上有些事情我们

00:10:51.860 --> 00:10:55.490
以前没有这样做过，例如，如果

00:10:54.199 --> 00:10:57.470
你会躺下我们的存在

00:10:55.490 --> 00:11:01.040
 char由于某种原因文件不存在

00:10:57.470 --> 00:11:03.800
在这种情况下，更长的时间之一

00:11:01.040 --> 00:11:06.430
破坏了二进制兼容性，涉及到一些

00:11:03.800 --> 00:11:08.960
不幸的是在

00:11:06.430 --> 00:11:11.870
 J平台的远侧部分

00:11:08.960 --> 00:11:13.310
属于java.util的java.util jar 

00:11:11.870 --> 00:11:15.590
我们希望能够掌握的基础知识

00:11:13.310 --> 00:11:18.410
保持基本模块的美观和小巧，但

00:11:15.590 --> 00:11:19.940
在某些情况下，它使用了部分豆子

00:11:18.410 --> 00:11:21.800
引入所有桌面的API 

00:11:19.940 --> 00:11:23.330
模块，所以我们不想拥有

00:11:21.800 --> 00:11:26.360
基本模型，将所有跃点都包括在内

00:11:23.330 --> 00:11:28.070
好吧，这是第一个解决方案

00:11:26.360 --> 00:11:29.720
用八种方法淘汰这些方法

00:11:28.070 --> 00:11:31.580
警告，他们将在九点之内被删除， 

00:11:29.720 --> 00:11:34.310
现在我们已经完成并删除了它们

00:11:31.580 --> 00:11:35.840
一个九，所以是二进制不兼容

00:11:34.310 --> 00:11:38.030
如果您依赖这些方法，请更改

00:11:35.840 --> 00:11:39.860
他们不在那里了，但是我们

00:11:38.030 --> 00:11:42.260
认为拥有足够重要

00:11:39.860 --> 00:11:44.690
更好的bod pob模块D竞争

00:11:42.260 --> 00:11:47.300
进行更改的平台，如果

00:11:44.690 --> 00:11:48.680
您对排便感兴趣

00:11:47.300 --> 00:11:50.420
我们稍后会讲更多

00:11:48.680 --> 00:11:53.060
演讲，我鼓励您关注

00:11:50.420 --> 00:11:55.700
不赞成使用er的医生

00:11:53.060 --> 00:11:59.330
 Java弃用的微妙Pat功能

00:11:55.700 --> 00:12:03.530
在推特上介绍一些工具

00:11:59.330 --> 00:12:04.850
改进首先是J shell 

00:12:03.530 --> 00:12:07.640
列表社区已经有很长一段时间了

00:12:04.850 --> 00:12:09.620
提供阅读评估的传统

00:12:07.640 --> 00:12:12.310
打印循环称为repple作为一种方式

00:12:09.620 --> 00:12:14.870
如果您与语言互动

00:12:12.310 --> 00:12:16.970
来自Ruby或Python社区

00:12:14.870 --> 00:12:19.490
你在那里有类似的功能， 

00:12:16.970 --> 00:12:22.100
在VM端，如果您使用Scala a 

00:12:19.490 --> 00:12:24.560
红宝石外壳，也有这种

00:12:22.100 --> 00:12:27.020
 reprep你已经习惯了，那么Java呢？ 

00:12:24.560 --> 00:12:29.840
对于Java来说，什么都不是很好

00:12:27.020 --> 00:12:32.420
我们也这么认为，导致

00:12:29.840 --> 00:12:35.840
到添加J shell的JDK 9项目

00:12:32.420 --> 00:12:43.250
我将快速演示一下

00:12:35.840 --> 00:12:45.460
在这里，那不是窗户

00:12:43.250 --> 00:12:45.460
想

00:12:53.020 --> 00:12:58.520
好的，这是Jay shell的新命令

00:12:55.640 --> 00:13:01.880
在JDK中，这是从

00:12:58.520 --> 00:13:05.540
最近在这里进行了早期访问，所以我们将

00:13:01.880 --> 00:13:06.890
等待它开始在这里，那是什么

00:13:05.540 --> 00:13:13.340
您在任何情况下编写的第一个程序

00:13:06.890 --> 00:13:15.770
语言你好世界，所以我们可以原谅我

00:13:13.340 --> 00:13:16.400
现在在这里键入，我们看到它回来了

00:13:15.770 --> 00:13:18.530
马上

00:13:16.400 --> 00:13:20.630
所以我们执行了第一个Jake Shell 

00:13:18.530 --> 00:13:22.100
程序，所以这实际上是新的

00:13:20.630 --> 00:13:23.420
回到我们身边，但你注意到我们

00:13:22.100 --> 00:13:26.180
不必说公共静态无效

00:13:23.420 --> 00:13:27.590
主字符串参数等等，所以

00:13:26.180 --> 00:13:30.170
更少的仪式开始

00:13:27.590 --> 00:13:32.570
我们可以开始玩耍，我们可以

00:13:30.170 --> 00:13:34.160
也说声明变量，所以说

00:13:32.570 --> 00:13:36.710
我们想要一个双变量tau 

00:13:34.160 --> 00:13:40.010
我们希望那等于二

00:13:36.710 --> 00:13:41.870
圆周率，所以我们知道有圆周率

00:13:40.010 --> 00:13:45.980
在数学课上找到的常数

00:13:41.870 --> 00:13:48.050
可以在此处点击完成数学，然后

00:13:45.980 --> 00:13:49.850
我们知道pi常数在那里

00:13:48.050 --> 00:13:52.550
自动完成，然后我们取回

00:13:49.850 --> 00:13:54.620
对我们来说，我们当然不只是

00:13:52.550 --> 00:13:57.410
我们也需要方法的字段，所以说

00:13:54.620 --> 00:14:01.930
我们想找到一个方法平方

00:13:57.410 --> 00:14:01.930
取双并平方

00:14:08.250 --> 00:14:12.640
现在这种方法在我们的环境中

00:14:10.720 --> 00:14:15.130
我们可以做到这一点，我们可以

00:14:12.640 --> 00:14:18.070
摆一条毛巾，我们得到一些东西

00:14:15.130 --> 00:14:18.900
大小合适，所以

00:14:18.070 --> 00:14:22.180
好

00:14:18.900 --> 00:14:27.630
还有命令行编辑，所以如果

00:14:22.180 --> 00:14:32.170
我们想说的是

00:14:27.630 --> 00:14:34.060
值的符号并将其添加到

00:14:32.170 --> 00:14:38.230
我们应该得到的符号的平方

00:14:34.060 --> 00:14:42.010
接近一个的东西就是

00:14:38.230 --> 00:14:53.740
的确，我们得到的回溯到

00:14:42.010 --> 00:14:56.710
幻灯片，就像我提到的那样

00:14:53.740 --> 00:14:57.820
学生入门仪式

00:14:56.710 --> 00:14:59.920
和Java，您不必担心

00:14:57.820 --> 00:15:02.680
公共静态无效对

00:14:59.920 --> 00:15:04.660
第一天，但​​这不只是功能

00:15:02.680 --> 00:15:06.880
对于Java新手来说， 

00:15:04.660 --> 00:15:08.890
经验丰富的开发人员的有用工具

00:15:06.880 --> 00:15:10.780
例如，这可能是一个好方法

00:15:08.890 --> 00:15:14.950
开始尝试那些新的和

00:15:10.780 --> 00:15:17.290
九个JDK九个库的功能

00:15:14.950 --> 00:15:20.770
 JCL的实现利用了许多

00:15:17.290 --> 00:15:22.810
现有的JDK技术和领先者

00:15:20.770 --> 00:15:24.670
我的同事Jade Shell的工程师

00:15:22.810 --> 00:15:26.320
罗伯特·菲尔德将发表演讲

00:15:24.670 --> 00:15:30.640
今天晚些时候，如果您有兴趣

00:15:26.320 --> 00:15:35.500
接下来，我们会听到更多的信息

00:15:30.640 --> 00:15:38.350
谈论Java多年的Java文档

00:15:35.500 --> 00:15:40.450
 doc输出已完成到4.01 HTML 

00:15:38.350 --> 00:15:43.210
几年前的标准

00:15:40.450 --> 00:15:45.610
 HTML标准html5，因此您现在可以选择

00:15:43.210 --> 00:15:48.130
在您的Java文档输出中为html5 

00:15:45.610 --> 00:15:52.270
而不是HTML 401，尽管我们没有

00:15:48.130 --> 00:15:54.250
默认情况下启用了任何视频

00:15:52.270 --> 00:15:58.089
许多人使用了

00:15:54.250 --> 00:16:02.800
 JDK 8不好用，如果您

00:15:58.089 --> 00:16:05.170
关注语义和

00:16:02.800 --> 00:16:07.780
 Java文档的语法正确性

00:16:05.170 --> 00:16:10.660
您现在可以使用码头区进行检查

00:16:07.780 --> 00:16:13.930
作为Java C的一部分或作为

00:16:10.660 --> 00:16:15.370
 Java doc命令的更改之一

00:16:13.930 --> 00:16:18.370
记录我们的一项改进

00:16:15.370 --> 00:16:20.410
 JDK 9中添加的内容已打包过滤，因此

00:16:18.370 --> 00:16:21.850
例如在JDK构建中，我们仅

00:16:20.410 --> 00:16:24.759
码头

00:16:21.850 --> 00:16:26.889
 Java和Java ex软件包，不要

00:16:24.759 --> 00:16:28.690
担心Javadoc 

00:16:26.889 --> 00:16:31.600
相同程度的正确性

00:16:28.690 --> 00:16:35.579
实施类专门讲

00:16:31.600 --> 00:16:38.709
给Java文档加星标或不加星标

00:16:35.579 --> 00:16:40.990
检查您是否可以启用或禁用这些

00:16:38.709 --> 00:16:43.750
个别地，它们的范围从

00:16:40.990 --> 00:16:45.730
 HTML的语法良好公式

00:16:43.750 --> 00:16:50.829
语义检查以确保您的FC 

00:16:45.730 --> 00:16:53.079
和链接标记具有有效的目标，如果您

00:16:50.829 --> 00:16:55.930
编写doclet我们已经更新了doclet 

00:16:53.079 --> 00:16:58.449
 api有更好的基础

00:16:55.930 --> 00:17:00.339
 doclet api是在

00:16:58.449 --> 00:17:03.160
我认为Java平台很公平

00:17:00.339 --> 00:17:05.500
不是不是没有遵循现在

00:17:03.160 --> 00:17:07.689
被认为是API设计的最佳实践

00:17:05.500 --> 00:17:11.589
并且我们能够重新实现

00:17:07.689 --> 00:17:14.520
更新的语言模型和重用

00:17:11.589 --> 00:17:17.589
来自平台另一部分的

00:17:14.520 --> 00:17:19.510
我们添加到Java文档的另一个功能是

00:17:17.589 --> 00:17:26.110
一个Java文档搜索框，我们将拥有

00:17:19.510 --> 00:17:30.880
另一个好的快速演示，所以这

00:17:26.110 --> 00:17:33.789
是最新JDK的Java文档输出

00:17:30.880 --> 00:17:36.010
 9版本您会注意到框架视图是

00:17:33.789 --> 00:17:38.049
不再是那些的默认值

00:17:36.010 --> 00:17:40.000
三个面板，如果您仍然喜欢的话

00:17:38.049 --> 00:17:42.370
可以从这里得到四个帧

00:17:40.000 --> 00:17:44.860
现在在右上角

00:17:42.370 --> 00:17:49.030
有一个搜索框，所以我们说

00:17:44.860 --> 00:17:50.260
想搜索数学，我们在这里看到

00:17:49.030 --> 00:17:53.169
搜索返回不同的结果

00:17:50.260 --> 00:17:55.539
它搜索的区域名称

00:17:53.169 --> 00:17:57.789
将类型名称打包

00:17:55.539 --> 00:18:00.700
字段和方法的签名，我们

00:17:57.789 --> 00:18:01.960
看到所有出现在这里的人

00:18:00.700 --> 00:18:06.370
搜索输出，然后您就可以

00:18:01.960 --> 00:18:09.610
选择直接去那里，我们添加了

00:18:06.370 --> 00:18:11.710
 JDK 9中的模块，因此这也可以解决

00:18:09.610 --> 00:18:14.950
例如，如果我们寻找

00:18:11.710 --> 00:18:16.179
基本模块显示为一个模块

00:18:14.950 --> 00:18:22.059
结果，我们还可以查看

00:18:16.179 --> 00:18:24.159
该模块中的软件包，我们通常会丢失

00:18:22.059 --> 00:18:25.929
 Java和Java中的camelcase命名约定

00:18:24.159 --> 00:18:27.880
有时方法名称有点

00:18:25.929 --> 00:18:31.330
很久以来，我们想找出答案

00:18:27.880 --> 00:18:32.470
 Javadoc for equals忽略大小写

00:18:31.330 --> 00:18:33.850
可以把整个东西都打出来

00:18:32.470 --> 00:18:34.429
这有点不方便，所以我们

00:18:33.850 --> 00:18:37.039
可以使用凸轮

00:18:34.429 --> 00:18:39.740
好吧，搜索，所以我们去平等， 

00:18:37.039 --> 00:18:41.659
然后是ID即可忽略，现在我们可以选择

00:18:39.740 --> 00:18:44.119
我们想要那里两种方法中的哪一种

00:18:41.659 --> 00:18:47.149
所以这是一种很好的快速查找方法

00:18:44.119 --> 00:18:48.769
 Javadoc中的信息，现在您可以

00:18:47.149 --> 00:18:50.570
较少地，您会倾向于使用

00:18:48.769 --> 00:18:59.690
搜索引擎来查找Javadoc中的内容

00:18:50.570 --> 00:19:01.700
您可以只使用Javadoc本身

00:18:59.690 --> 00:19:03.139
搜索功能在侧面实现

00:19:01.700 --> 00:19:04.340
 JavaScript，因此您可以在本地运行

00:19:03.139 --> 00:19:06.889
不需要服务器即可执行此操作

00:19:04.340 --> 00:19:10.580
正如我提到的那样，它可以对各种索引进行索引

00:19:06.889 --> 00:19:13.519
存在的名称和签名

00:19:10.580 --> 00:19:16.039
 Javadoc从类型名称到模块

00:19:13.519 --> 00:19:17.389
您也可以使用新标签来命名

00:19:16.039 --> 00:19:21.259
找到您自己的索引字词，以显示

00:19:17.389 --> 00:19:22.789
搜索以下两个功能

00:19:21.259 --> 00:19:25.159
我将谈论有关

00:19:22.789 --> 00:19:27.440
从一个JDK版本过渡到

00:19:25.159 --> 00:19:31.249
另一个多版本的jar文件和

00:19:27.440 --> 00:19:32.840
 Java C破折号释放标志，所以先

00:19:31.249 --> 00:19:35.480
将与此交叉编译

00:19:32.840 --> 00:19:37.610
新-喘息释放标志，以便Java看到

00:19:35.480 --> 00:19:40.369
一直跨编译器，您一直

00:19:37.610 --> 00:19:43.279
能够使用Java C从

00:19:40.369 --> 00:19:44.929
今天的J回到我以前的

00:19:43.279 --> 00:19:47.179
写了一篇关于如何做的博客文章

00:19:44.929 --> 00:19:49.340
这也在Java C手册页中

00:19:47.179 --> 00:19:52.309
还有三件事

00:19:49.340 --> 00:19:54.320
为您的Java C命令设置此功能

00:19:52.309 --> 00:19:56.450
工作正常，您必须设置源

00:19:54.320 --> 00:19:58.940
您使用的版本必须设置

00:19:56.450 --> 00:20:01.039
目标版本，最后您必须

00:19:58.940 --> 00:20:02.509
将bloop类路径设置为引导

00:20:01.039 --> 00:20:07.429
早期JDK的类路径

00:20:02.509 --> 00:20:10.009
与此相关的版本已更改

00:20:07.429 --> 00:20:11.929
关于有多少来源和

00:20:10.009 --> 00:20:13.070
我们支持的目标版本，而不是

00:20:11.929 --> 00:20:15.169
一直回到起点

00:20:13.070 --> 00:20:15.649
我们现在有一个一加三的版本

00:20:15.169 --> 00:20:18.679
背部

00:20:15.649 --> 00:20:20.690
我们是从JDK 8开始的，所以如果是JDK 9 

00:20:18.679 --> 00:20:23.690
这意味着对于源和目标，我们

00:20:20.690 --> 00:20:25.490
支持九八七七

00:20:23.690 --> 00:20:28.279
已弃用六个，警告为

00:20:25.490 --> 00:20:31.009
当我们使用它时发出

00:20:28.279 --> 00:20:32.840
策略和JDK 10的六个选项不是

00:20:31.009 --> 00:20:34.700
支持了，但过去有十个

00:20:32.840 --> 00:20:38.360
九八，七，七是

00:20:34.700 --> 00:20:40.369
弃用等等，为什么您需要

00:20:38.360 --> 00:20:43.190
设置好引导类路径，让我们

00:20:40.369 --> 00:20:45.350
在这里以JK库为例

00:20:43.190 --> 00:20:48.049
 JDK版本10中只有一种方法foo 

00:20:45.350 --> 00:20:48.320
需要两倍的Letton来说

00:20:48.049 --> 00:20:51.289
日本电信

00:20:48.320 --> 00:20:53.630
再加上一个超载的食物

00:20:51.289 --> 00:20:55.279
需要一个INT，让我们假设

00:20:53.630 --> 00:20:58.070
这些在语义上是等效的，但是

00:20:55.279 --> 00:20:59.840
这只是炉子的快速通行证

00:20:58.070 --> 00:21:02.269
会遵循所有通常的行为

00:20:59.840 --> 00:21:06.919
我们关心的兼容性规则

00:21:02.269 --> 00:21:09.980
这是一个非常合理的图书馆

00:21:06.919 --> 00:21:13.730
现在更改JDK 

00:21:09.980 --> 00:21:16.070
客户端库调用两个，所以如果我们

00:21:13.730 --> 00:21:19.279
将客户端库放在这里并进行编译

00:21:16.070 --> 00:21:22.309
它针对JDK n加一

00:21:19.279 --> 00:21:23.960
 foo的调用意味着Fouchier需要一个

00:21:22.309 --> 00:21:27.620
整数参数，所以如果我们过去

00:21:23.960 --> 00:21:29.539
到JDK n加两个foo中的哪一个

00:21:27.620 --> 00:21:31.610
方法将被投入

00:21:29.539 --> 00:21:33.200
类文件，这将是

00:21:31.610 --> 00:21:35.629
方法是方法的两倍

00:21:33.200 --> 00:21:36.799
这需要一个int，它将是

00:21:35.629 --> 00:21:38.330
正确的方法就是

00:21:36.799 --> 00:21:40.340
关于最具体的方法

00:21:38.330 --> 00:21:42.769
规范说的是什么，假设我们

00:21:40.340 --> 00:21:47.019
即使该类文件具有

00:21:42.769 --> 00:21:49.450
旧版JDK的class Hall版本

00:21:47.019 --> 00:21:51.950
版本，现在我们针对JDK运行它

00:21:49.450 --> 00:21:53.240
将会发生什么，我们将要

00:21:51.950 --> 00:21:56.720
出现错误或类似的东西

00:21:53.240 --> 00:21:59.450
如果我们现在运行时没有这样的方法错误

00:21:56.720 --> 00:22:02.570
解码错误消息在这里说什么

00:21:59.450 --> 00:22:06.110
它基本上说我正在寻找一个

00:22:02.570 --> 00:22:08.029
库类中的foo方法

00:22:06.110 --> 00:22:10.039
它需要一个整数，即

00:22:08.029 --> 00:22:12.710
眼睛和括号意味着，当然

00:22:10.039 --> 00:22:14.419
在JDK n中没有这样的方法，因为

00:22:12.710 --> 00:22:16.250
我们只有方法foo需要一个

00:22:14.419 --> 00:22:18.049
现在加倍以避免这种情况

00:22:16.250 --> 00:22:20.360
不匹配，这就是为什么您需要使用

00:22:18.049 --> 00:22:22.759
旧版本的boob类路径

00:22:20.360 --> 00:22:24.289
当您交叉编译时，我们

00:22:22.759 --> 00:22:26.360
知道这个问题一段时间

00:22:24.289 --> 00:22:27.889
人们可以不断报告有关的错误

00:22:26.360 --> 00:22:31.820
好吧，我们会提供食物

00:22:27.889 --> 00:22:32.960
如果您使用的是JDK 7中的一些帮助

00:22:31.820 --> 00:22:34.909
目标的旧来源，而您没有

00:22:32.960 --> 00:22:36.710
设置展位的班级路径将发出

00:22:34.909 --> 00:22:39.470
警告您可以取消警告，如果

00:22:36.710 --> 00:22:42.139
你想要所以很好，我们认为

00:22:39.470 --> 00:22:44.590
会阻止人们跑来跑去

00:22:42.139 --> 00:22:47.600
这个问题，但我们也很少

00:22:44.590 --> 00:22:49.970
乐观地说我们仍然有错误

00:22:47.600 --> 00:22:51.529
进来这个，所以我们想到了

00:22:49.970 --> 00:22:53.029
还有更多关于jdk 9的内容，我们认为您

00:22:51.529 --> 00:22:55.159
知道我们知道人们想做什么

00:22:53.029 --> 00:22:57.049
在这里，他们只是想交叉编译为

00:22:55.159 --> 00:22:58.820
旧版本，所以我们为什么不

00:22:57.049 --> 00:23:01.370
直接提供该功能

00:22:58.820 --> 00:23:02.120
而不是让人们去近似

00:23:01.370 --> 00:23:04.220
他们自己

00:23:02.120 --> 00:23:06.890
所以这正是我们对- 

00:23:04.220 --> 00:23:08.720
 -语义上的发布和选项

00:23:06.890 --> 00:23:11.419
等同于指定来源

00:23:08.720 --> 00:23:13.789
目标在启动类路径中，现在

00:23:11.419 --> 00:23:17.409
提供了引导类路径信息

00:23:13.789 --> 00:23:22.460
以Java C压缩格式存储

00:23:17.409 --> 00:23:24.770
作为额外的奖励信息

00:23:22.460 --> 00:23:28.460
可用并发布版本-之后

00:23:24.770 --> 00:23:30.559
丽莎和只有api的我们认为您

00:23:28.460 --> 00:23:32.809
应该打电话，所以那些是Java 

00:23:30.559 --> 00:23:36.200
 SE e api和导出的api 

00:23:32.809 --> 00:23:38.480
 jdk这样的东西很诱人

00:23:36.200 --> 00:23:41.630
 Son Nhut星型api不在以下内容中

00:23:38.480 --> 00:23:43.130
现在和你-问题后

00:23:41.630 --> 00:23:46.190
与来源和

00:23:43.130 --> 00:23:47.840
目标，如果你在这里优势，如果你

00:23:46.190 --> 00:23:49.159
正在设置引导类路径

00:23:47.840 --> 00:23:50.870
以前您不必担心

00:23:49.159 --> 00:23:54.080
不再管理该工件

00:23:50.870 --> 00:23:56.120
你从一些引导类传递

00:23:54.080 --> 00:23:59.179
人们使用Maven插件动物

00:23:56.120 --> 00:24:01.159
嗅探器，他将使用该插件之一

00:23:59.179 --> 00:24:02.779
或两只手，做同样的事情

00:24:01.159 --> 00:24:04.100
检查不应该

00:24:02.779 --> 00:24:06.409
不再需要，因为它是内置的

00:24:04.100 --> 00:24:09.980
直接上Java说用Java写

00:24:06.409 --> 00:24:11.299
 C也意味着如果您使用Java C 

00:24:09.980 --> 00:24:13.130
可以从粪便中释放

00:24:11.299 --> 00:24:14.990
错误修复的优势和一些可能的方法

00:24:13.130 --> 00:24:18.039
可能会提高性能

00:24:14.990 --> 00:24:20.690
从早期的jdk开始

00:24:18.039 --> 00:24:22.700
我们添加的另一个功能可以帮助每个人

00:24:20.690 --> 00:24:26.870
过渡到较新的jdk是多版本

00:24:22.700 --> 00:24:28.850
 jar文件，所以如果您有一个库

00:24:26.870 --> 00:24:32.000
应用它会给您带来不便

00:24:28.850 --> 00:24:35.090
必须分发一个jar文件

00:24:32.000 --> 00:24:37.549
 jdk n和另一个Ek Tha n加一个

00:24:35.090 --> 00:24:39.350
人们会分配一个

00:24:37.549 --> 00:24:41.960
针对最旧的jar文件进行编译

00:24:39.350 --> 00:24:43.760
他们要在上面运行的jdk有一些

00:24:41.960 --> 00:24:45.380
结果确实减慢了

00:24:43.760 --> 00:24:48.020
采用和新功能，因为它是

00:24:45.380 --> 00:24:50.240
尴尬地使用新功能

00:24:48.020 --> 00:24:53.299
或jdk有时您可以解决

00:24:50.240 --> 00:24:55.309
使用反射，但这很慢， 

00:24:53.299 --> 00:24:58.309
有点尴尬和模块化

00:24:55.309 --> 00:24:59.600
 jdk 9的功能使其中一些功能

00:24:58.309 --> 00:25:02.539
不应该使用它们api更难

00:24:59.600 --> 00:25:04.520
访问，所以这将无法正常工作

00:25:02.539 --> 00:25:06.980
好，所以您现在要重写它

00:25:04.520 --> 00:25:08.840
是多版本绘图文件的想法是

00:25:06.980 --> 00:25:12.620
很简单，有一个共同的共享

00:25:08.840 --> 00:25:15.200
所有版本的区域，然后在

00:25:12.620 --> 00:25:15.800
该区域中的meta有jdk平台

00:25:15.200 --> 00:25:17.780
具体

00:25:15.800 --> 00:25:19.250
覆盖您可能会骑一会儿

00:25:17.780 --> 00:25:21.140
源八九十

00:25:19.250 --> 00:25:23.330
九点和十点的优势

00:25:21.140 --> 00:25:25.310
多功能释放罐的功能

00:25:23.330 --> 00:25:28.580
使用新选项创建文件

00:25:25.310 --> 00:25:30.350
 jar命令和部分

00:25:28.580 --> 00:25:32.510
平台使用的jar文件

00:25:30.350 --> 00:25:34.550
 jar API Java Java命令

00:25:32.510 --> 00:25:37.850
 Java C已更新为多

00:25:34.550 --> 00:25:40.460
接下来我会讲一些释放

00:25:37.850 --> 00:25:42.800
语言的变化非模块化

00:25:40.460 --> 00:25:46.130
 JDK中已进行的语言更改

00:25:42.800 --> 00:25:49.580
 9首先是铣削

00:25:46.130 --> 00:25:51.020
投射硬币，因此术语“碾磨硬币” 

00:25:49.580 --> 00:25:53.570
指把那些小山脊

00:25:51.020 --> 00:25:56.000
如图所示，围绕硬币的边缘

00:25:53.570 --> 00:25:58.340
银币在这里的动机

00:25:56.000 --> 00:26:00.170
这是一般制作硬币的时候

00:25:58.340 --> 00:26:02.210
贵金属，如银或金

00:26:00.170 --> 00:26:04.220
人们倾向于剃光

00:26:02.210 --> 00:26:07.220
硬币，然后单独出售

00:26:04.220 --> 00:26:08.480
一种贬低硬币和

00:26:07.220 --> 00:26:10.670
将山脊放在制作的硬币上

00:26:08.480 --> 00:26:13.070
更明显的是， 

00:26:10.670 --> 00:26:15.200
在相同的想法中防止这种情况

00:26:13.070 --> 00:26:16.940
您维护的铣削项目硬币

00:26:15.200 --> 00:26:19.070
随着时间的推移，硬币特征的价值

00:26:16.940 --> 00:26:20.930
通过去除一些生锈的粗糙边缘

00:26:19.070 --> 00:26:24.890
在JDK的末尾剩下了七个

00:26:20.930 --> 00:26:27.650
提醒一下，这些是项目硬币

00:26:24.890 --> 00:26:31.790
 JDK的第七和第三项功能

00:26:27.650 --> 00:26:33.590
他们在JDK 9中有小的更新

00:26:31.790 --> 00:26:36.140
这些是我们要谈论的更新

00:26:33.590 --> 00:26:38.120
其中大约三个用于项目硬币

00:26:36.140 --> 00:26:39.830
有一些类似的情况

00:26:38.120 --> 00:26:41.270
他们还剩下几个项目的lambda项目

00:26:39.830 --> 00:26:43.100
照顾照顾，那些是

00:26:41.270 --> 00:26:45.770
在碾磨项目玉米下处理

00:26:43.100 --> 00:26:47.540
好吧，我们首先进行这些更改

00:26:45.770 --> 00:26:51.620
谈论私密的安全varargs 

00:26:47.540 --> 00:26:52.910
实例方法回到jdk 5或6 

00:26:51.620 --> 00:26:54.740
您可能已经编写了这样的代码

00:26:52.910 --> 00:26:56.300
您有一个列出的字符串列表， 

00:26:54.740 --> 00:26:58.490
您想使用剃刀初始化它

00:26:56.300 --> 00:26:59.750
作为列出的平台方法之一

00:26:58.490 --> 00:27:03.560
那应该很好，所以你有一个

00:26:59.750 --> 00:27:07.280
真正的英语和意大利语二月

00:27:03.560 --> 00:27:09.220
因此，如果您对

00:27:07.280 --> 00:27:11.810
这个你会得到像这样的警告

00:27:09.220 --> 00:27:14.960
从栏中取消选中通用数组创建

00:27:11.810 --> 00:27:17.840
字符串数组的X参数类型列表

00:27:14.960 --> 00:27:21.590
这条消息听起来有点

00:27:17.840 --> 00:27:23.450
关于这里发生的事情是

00:27:21.590 --> 00:27:28.250
基本上之间的不良互动

00:27:23.450 --> 00:27:32.530
 VAR args中的数组和泛型

00:27:28.250 --> 00:27:35.000
数组ah des列表的参数和

00:27:32.530 --> 00:27:37.039
语言规范需要一个

00:27:35.000 --> 00:27:38.870
在这种情况下发出警告

00:27:37.039 --> 00:27:40.669
因为所谓的热污染

00:27:38.870 --> 00:27:42.919
可能会继续

00:27:40.669 --> 00:27:45.740
误导编译器无法证明

00:27:42.919 --> 00:27:49.070
事物的类型正确

00:27:45.740 --> 00:27:51.020
虽然这对你来说是正确的

00:27:49.070 --> 00:27:53.570
想在这种情况下警告

00:27:51.020 --> 00:27:55.909
可能实际上不会发生任何不良情况

00:27:53.570 --> 00:27:58.669
在这种情况下发生，所以这是错误的

00:27:55.909 --> 00:28:00.289
积极的错误，没有信息，所以

00:27:58.669 --> 00:28:02.809
我们不希望这些假盆栽

00:28:00.289 --> 00:28:04.370
正因错误，我们不必如此

00:28:02.809 --> 00:28:07.880
因此我们添加了这个安全的varargs 

00:28:04.370 --> 00:28:10.100
注释返回到JDK 7中，并为我们说

00:28:07.880 --> 00:28:12.470
基本上说编译器请相信我

00:28:10.100 --> 00:28:14.600
我会发誓什么也没做

00:28:12.470 --> 00:28:15.890
这些方面的坏事正在发生

00:28:14.600 --> 00:28:18.110
沼泽方法，所以您不必

00:28:15.890 --> 00:28:20.000
发出警告，我们添加了这个

00:28:18.110 --> 00:28:22.030
批注到多个平台

00:28:20.000 --> 00:28:24.200
列表中包含数组的方法

00:28:22.030 --> 00:28:25.880
现在这个注解有几件事

00:28:24.200 --> 00:28:28.100
它从中删除各种警告

00:28:25.880 --> 00:28:29.720
方法声明，但更重要的是

00:28:28.100 --> 00:28:31.580
它从方法调用中删除警告

00:28:29.720 --> 00:28:33.590
这些都是这些用途的网站

00:28:31.580 --> 00:28:36.159
方法，这样用户就不会得到这个

00:28:33.590 --> 00:28:38.960
不再提供有用的警告消息

00:28:36.159 --> 00:28:41.030
现在因为注释的设计

00:28:38.960 --> 00:28:43.880
注释仅继承

00:28:41.030 --> 00:28:45.470
类不是接口或方法

00:28:43.880 --> 00:28:46.970
表示我们只能使用安全参数

00:28:45.470 --> 00:28:49.130
注释不能的方法

00:28:46.970 --> 00:28:50.720
被覆盖了，那是什么样的

00:28:49.130 --> 00:28:54.380
 Java中无法覆盖的方法

00:28:50.720 --> 00:28:57.169
我们无法覆盖最终方法

00:28:54.380 --> 00:28:59.539
覆盖我们无法使用的静态方法

00:28:57.169 --> 00:29:02.150
覆盖构造函数，因为从

00:28:59.539 --> 00:29:04.039
从某种角度说虚拟机

00:29:02.150 --> 00:29:06.289
级别的构造函数这是一个非常

00:29:04.039 --> 00:29:08.390
具有相同的特殊静态方法

00:29:06.289 --> 00:29:10.789
有种感觉，但有第四种

00:29:08.390 --> 00:29:13.429
一种您无法覆盖的方法， 

00:29:10.789 --> 00:29:15.260
那是私人方法，我们忘了

00:29:13.429 --> 00:29:19.100
关于那些我们在做项目时

00:29:15.260 --> 00:29:21.950
克隆JDK 7，所以现在在JDK 9中我们添加了

00:29:19.100 --> 00:29:24.049
他们这是对应的部分

00:29:21.950 --> 00:29:25.700
 Java语言规范，我们

00:29:24.049 --> 00:29:27.409
只能添加两个单词到

00:29:25.700 --> 00:29:28.940
在这里介绍语言变化

00:29:27.409 --> 00:29:30.080
这是我们的很小的语言更改

00:29:28.940 --> 00:29:31.700
喜欢他们在很好和简单的喜欢下

00:29:30.080 --> 00:29:33.620
这是因为它们通常更多

00:29:31.700 --> 00:29:36.649
复杂而令我们惊讶的

00:29:33.620 --> 00:29:38.299
接下来我会毫不奇怪

00:29:36.649 --> 00:29:42.059
关于受影响的最终变量，以及

00:29:38.299 --> 00:29:44.679
尝试使用资源来提醒

00:29:42.059 --> 00:29:46.870
使用jd7费率会很熟悉

00:29:44.679 --> 00:29:49.000
您有之前的三个资料来源，所以您有

00:29:46.870 --> 00:29:51.250
您的资源处于阻塞状态，现在您

00:29:49.000 --> 00:29:54.190
管理它，这大致等效

00:29:51.250 --> 00:29:56.230
为此，编译器将插入一个try 

00:29:54.190 --> 00:29:58.240
终于在你的街区附近，它使

00:29:56.230 --> 00:30:00.210
确保关闭调用您的

00:29:58.240 --> 00:30:02.110
资源，如果资源不为null 

00:30:00.210 --> 00:30:04.269
实际上有点复杂

00:30:02.110 --> 00:30:06.600
这是关于异常处理的

00:30:04.269 --> 00:30:09.309
完全披露条款是

00:30:06.600 --> 00:30:10.870
文件夹螺丝环，这是更多

00:30:09.309 --> 00:30:12.580
参与其中，但我们不必担心

00:30:10.870 --> 00:30:16.779
关于这一点，编译器会照顾它

00:30:12.580 --> 00:30:19.360
对我们来说，这是什么结构

00:30:16.779 --> 00:30:21.070
 JDK 7中要管理的资源

00:30:19.360 --> 00:30:23.860
规则，最后我们是你不得不

00:30:21.070 --> 00:30:25.450
声明一个新的资源变量

00:30:23.860 --> 00:30:27.580
大火管理的资源

00:30:25.450 --> 00:30:29.470
资源声明不是

00:30:27.580 --> 00:30:31.299
最初的建议你可以

00:30:29.470 --> 00:30:33.850
传递具有

00:30:31.299 --> 00:30:36.490
正确的类型，内部可自动关闭

00:30:33.850 --> 00:30:38.260
表示该对象具有

00:30:36.490 --> 00:30:39.700
一个封闭的方法，但我们发现了一个问题

00:30:38.260 --> 00:30:42.370
因此，假设我们有一个

00:30:39.700 --> 00:30:44.529
资源R，然后我们用

00:30:42.370 --> 00:30:46.389
 chars资源声明以及

00:30:44.529 --> 00:30:48.870
部落资源代理的障碍

00:30:46.389 --> 00:30:51.639
我们将观点指向另一个对象

00:30:48.870 --> 00:30:53.679
所以当我们到达

00:30:51.639 --> 00:30:55.240
块的末尾，哪个对象应该

00:30:53.679 --> 00:30:56.679
是否应该调用它的关闭方法

00:30:55.240 --> 00:30:58.990
它应该是一种资源

00:30:56.679 --> 00:31:00.279
资源丰富的两个应该都是他们

00:30:58.990 --> 00:31:03.309
决定我们不想解决这个问题

00:31:00.279 --> 00:31:06.070
问题和我们没有解决的方法

00:31:03.309 --> 00:31:08.080
就是不允许你只传递

00:31:06.070 --> 00:31:12.820
你有一个任意表达式

00:31:08.080 --> 00:31:15.190
必须是最终变量的新变量

00:31:12.820 --> 00:31:18.059
那有点使它起作用

00:31:15.190 --> 00:31:20.169
但这有点烦人

00:31:18.059 --> 00:31:21.760
声明一个新的资源变量

00:31:20.169 --> 00:31:23.710
因为有时候我们知道

00:31:21.760 --> 00:31:25.630
这种情况不可能发生，你不能

00:31:23.710 --> 00:31:27.370
重新分配变量（如果是最终变量）， 

00:31:25.630 --> 00:31:29.230
如果是，则无法重新分配

00:31:27.370 --> 00:31:30.940
有效地最终有效地

00:31:29.230 --> 00:31:32.110
表示您可以宣布最终决定，而您

00:31:30.940 --> 00:31:36.840
只是没有绕过这样做

00:31:32.110 --> 00:31:39.490
但是，我们现在在jdk 9中所做的是

00:31:36.840 --> 00:31:41.860
允许您将现有变量用作

00:31:39.490 --> 00:31:43.960
只要是最终有效的决赛

00:31:41.860 --> 00:31:46.120
所以不要像这样写代码

00:31:43.960 --> 00:31:47.769
在这里，我们必须有第二个

00:31:46.120 --> 00:31:50.490
资源只是为了管理我们的资源

00:31:47.769 --> 00:31:53.080
声明我们可以通过最后

00:31:50.490 --> 00:31:54.639
变量R就在那里，这可行

00:31:53.080 --> 00:31:55.779
很好，我们避免了不

00:31:54.639 --> 00:31:59.109
知道哪个节目

00:31:55.779 --> 00:32:00.789
反对称呼衣服不是

00:31:59.109 --> 00:32:03.369
语法水平太难了

00:32:00.789 --> 00:32:07.049
只是将语法扩展到

00:32:03.369 --> 00:32:09.759
允许变量访问和

00:32:07.049 --> 00:32:12.309
规格变更对应需求

00:32:09.759 --> 00:32:13.869
现在在这里，您可能最初会认为

00:32:12.309 --> 00:32:15.940
这将是非常小的规格

00:32:13.869 --> 00:32:19.090
变化是一两个或几个句子

00:32:15.940 --> 00:32:22.029
的话，因为也许你只是想

00:32:19.090 --> 00:32:24.159
打电话给允许说一个局部变量

00:32:22.029 --> 00:32:25.840
很好或最终有效，但我们不

00:32:24.159 --> 00:32:27.489
只想允许本地变量

00:32:25.840 --> 00:32:29.259
最终有效，最终我们想要更多

00:32:27.489 --> 00:32:31.749
特征之间的正交性

00:32:29.259 --> 00:32:34.570
即使你有一个像决赛的东西

00:32:31.749 --> 00:32:36.879
匿名对象的新对象的字段

00:32:34.570 --> 00:32:40.929
也应该允许的课程

00:32:36.879 --> 00:32:43.629
这就是该更改所允许的

00:32:40.929 --> 00:32:46.210
带有匿名类的钻石

00:32:43.629 --> 00:32:48.249
钻石在地下形成

00:32:46.210 --> 00:32:49.359
巨大的深度和压力，我们将拥有

00:32:48.249 --> 00:32:51.029
往兔子洞下一点

00:32:49.359 --> 00:32:53.649
看看这里发生了什么，但是

00:32:51.029 --> 00:32:56.979
希望这次旅行值得，所以我会

00:32:53.649 --> 00:32:58.839
使用此框类型示例

00:32:56.979 --> 00:33:02.200
接下来的几张幻灯片，您会想到一个盒子

00:32:58.839 --> 00:33:04.210
是一个简化的集合，所以它是一个

00:33:02.200 --> 00:33:07.119
您可以将对象放入的参数化类型

00:33:04.210 --> 00:33:09.009
拿出物体，所以我们有一个

00:33:07.119 --> 00:33:11.440
这里的例子我们有问题清单

00:33:09.009 --> 00:33:13.529
标记为通配符类型，然后

00:33:11.440 --> 00:33:18.190
说我们想把它放进我们的盒子里， 

00:33:13.529 --> 00:33:20.229
使用钻石，所以现在很好

00:33:18.190 --> 00:33:22.149
编译器此时要做的是

00:33:20.229 --> 00:33:26.799
推断角度之间的关系

00:33:22.149 --> 00:33:28.929
方括号，因此Java仍然是静态的

00:33:26.799 --> 00:33:31.269
输入语言，即使不是

00:33:28.929 --> 00:33:32.769
明确键入这是什么意思

00:33:31.269 --> 00:33:35.019
我们有程序员不投入

00:33:32.769 --> 00:33:36.700
婴儿车尖括号的类型

00:33:35.019 --> 00:33:38.739
编译器必须执行的驱动器类型

00:33:36.700 --> 00:33:41.080
代替我们代表

00:33:38.739 --> 00:33:44.200
处理那完成的

00:33:41.080 --> 00:33:45.789
完成称为管道推断，因此在内部

00:33:44.200 --> 00:33:48.669
编译器的工作原理是什么

00:33:45.789 --> 00:33:51.129
推断此类型的捕获列表

00:33:48.669 --> 00:33:54.489
问号好，听起来有点

00:33:51.129 --> 00:33:56.320
有点不熟悉，怎么回事

00:33:54.489 --> 00:33:58.809
这是所谓的

00:33:56.320 --> 00:34:00.639
难辨的类型，这不是类型

00:33:58.809 --> 00:34:03.129
我们可以在程序中写自己

00:34:00.639 --> 00:34:05.320
但是它是内部可用的类型

00:34:03.129 --> 00:34:07.210
编译器这实际上是一个相当

00:34:05.320 --> 00:34:08.649
常用的实现技术

00:34:07.210 --> 00:34:09.580
类型丰富的编译器

00:34:08.649 --> 00:34:11.110
系统中

00:34:09.580 --> 00:34:14.380
然后由编译器直接

00:34:11.110 --> 00:34:18.550
可供程序员使用，因此可以捕获

00:34:14.380 --> 00:34:20.440
转换这是一个类型操作， 

00:34:18.550 --> 00:34:22.330
基本上，这意味着在编译器内部

00:34:20.440 --> 00:34:24.580
每个通配符耶稣问题

00:34:22.330 --> 00:34:27.580
标记，表示存在某种类型

00:34:24.580 --> 00:34:29.260
替换为新的新鲜类型变量

00:34:27.580 --> 00:34:31.060
在编译器内部某些特定类型

00:34:29.260 --> 00:34:32.860
变量，以便将其从

00:34:31.060 --> 00:34:35.830
给定一个特定的通配符

00:34:32.860 --> 00:34:36.820
名称，这在JLS中进行了说明，如果

00:34:35.830 --> 00:34:38.650
你对那种事情感兴趣

00:34:36.820 --> 00:34:39.820
如果您正在阅读Java的这一部分

00:34:38.650 --> 00:34:44.290
语言规范，很好

00:34:39.820 --> 00:34:46.090
您体内的类型理论手册

00:34:44.290 --> 00:34:48.010
箱病类可以细分

00:34:46.090 --> 00:34:50.050
包括匿名子类化

00:34:48.010 --> 00:34:53.740
再次，我们希望我们的功能

00:34:50.050 --> 00:34:55.570
相互作用并正交，但这

00:34:53.740 --> 00:34:57.160
匿名子分类有点

00:34:55.570 --> 00:34:59.650
钻石的问题，我们将看到

00:34:57.160 --> 00:35:01.540
下一张或两张幻灯片，假设我们要

00:34:59.650 --> 00:35:05.530
编译这个匿名子类

00:35:01.540 --> 00:35:07.450
那看起来像是一堂课吗

00:35:05.530 --> 00:35:10.330
需要一个班级文件，所以我们要有一个名字

00:35:07.450 --> 00:35:12.370
一个灯箱美元的地方，作为一个

00:35:10.330 --> 00:35:14.110
类文件，必须将其翻译成

00:35:12.370 --> 00:35:19.720
带有全套文件的类文件

00:35:14.110 --> 00:35:21.760
属性，因此特别是通用

00:35:19.720 --> 00:35:25.510
有关类的信息被放入

00:35:21.760 --> 00:35:28.330
类文件中的签名属性

00:35:25.510 --> 00:35:31.300
签名属性只能保留de 

00:35:28.330 --> 00:35:33.070
值得注意的类型签名的语法

00:35:31.300 --> 00:35:35.350
不允许非限定类型，所以

00:35:33.070 --> 00:35:38.140
语法不允许列出

00:35:35.350 --> 00:35:40.570
尤其是捕获问号

00:35:38.140 --> 00:35:43.510
当我们这很不幸

00:35:40.570 --> 00:35:45.190
在JDK 7中意识到了这一点，因为这是

00:35:43.510 --> 00:35:46.330
现在是一个我们不能写的问题

00:35:45.190 --> 00:35:49.330
出一个具有

00:35:46.330 --> 00:35:50.860
需要信息，所以发生了什么事

00:35:49.330 --> 00:35:52.900
你好，我们有语言

00:35:50.860 --> 00:35:56.260
随着时间的流逝互动

00:35:52.900 --> 00:35:58.120
 turn类在jdk 1.1泛型中路由

00:35:56.260 --> 00:36:00.340
在jdk 5和泛型中添加了

00:35:58.120 --> 00:36:03.130
内部类互操作就好了

00:36:00.340 --> 00:36:05.770
确保在JDK 7中发生了这种情况

00:36:03.130 --> 00:36:08.170
钻石就这样一对明智的钻石

00:36:05.770 --> 00:36:09.880
反过来，两人上课也很好

00:36:08.170 --> 00:36:11.200
仿制药中的明智钻石效果很好

00:36:09.880 --> 00:36:13.690
毕竟这就是我们想要做的

00:36:11.200 --> 00:36:16.120
但是如果我们结合钻石内部类

00:36:13.690 --> 00:36:18.460
在仿制药中，我们从袋子里来了

00:36:16.120 --> 00:36:21.430
这是杜克的邪恶双胞胎兄弟

00:36:18.460 --> 00:36:22.690
希望用我们的电池破坏硬币

00:36:21.430 --> 00:36:25.120
这里酸

00:36:22.690 --> 00:36:26.920
所以这就是今天的问题

00:36:25.120 --> 00:36:28.630
来自昨天的解决方案

00:36:26.920 --> 00:36:31.600
语言架构师Brian变得像

00:36:28.630 --> 00:36:36.610
因此，当我们发现

00:36:31.600 --> 00:36:39.010
在JDK 7中，我们必须快速

00:36:36.610 --> 00:36:42.760
解决方案，我们决定只是不允许

00:36:39.010 --> 00:36:43.840
我们都拥有匿名类的钻石

00:36:42.760 --> 00:36:45.850
认为这有点不幸

00:36:43.840 --> 00:36:47.530
当我们完成jsr时， 

00:36:45.850 --> 00:36:50.050
确实知道未来是可行的

00:36:47.530 --> 00:36:51.640
我们可以允许使用钻石的平台

00:36:50.050 --> 00:36:53.560
在创建匿名内部类时

00:36:51.640 --> 00:36:56.200
只要推断的类型很明显

00:36:53.560 --> 00:36:57.670
基本上只要那个坏情况

00:36:56.200 --> 00:36:59.530
可能发生，没有理由我们不能

00:36:57.670 --> 00:37:03.550
用钻石，那的确是

00:36:59.530 --> 00:37:05.470
我们现在已经在Java 9中完成了允许染色

00:37:03.550 --> 00:37:08.500
只要匿名类移动匿名类

00:37:05.470 --> 00:37:10.720
推断很好，这是

00:37:08.500 --> 00:37:12.430
规格文本需要做的是

00:37:10.720 --> 00:37:16.420
很少参与，但幸运的是我们有

00:37:12.430 --> 00:37:18.250
专门为我们做钻石的家伙

00:37:16.420 --> 00:37:18.790
根据我们的经验，JDK 7相当

00:37:18.250 --> 00:37:20.980
有效

00:37:18.790 --> 00:37:22.990
它能够摆脱约90％的

00:37:20.980 --> 00:37:25.540
构造函数的显式类型参数

00:37:22.990 --> 00:37:28.210
呼叫站点，我们认为与Diamondden 

00:37:25.540 --> 00:37:30.400
我的匿名类可以摆脱

00:37:28.210 --> 00:37:32.860
我们剩下的10％中的大部分

00:37:30.400 --> 00:37:34.900
更新杰克·奥克·杰克的好经验

00:37:32.860 --> 00:37:39.670
专门用于此的代码库

00:37:34.900 --> 00:37:41.470
接下来是对特权行动的呼吁

00:37:39.670 --> 00:37:45.100
下划线不再是标识符

00:37:41.470 --> 00:37:47.620
名字这个已经改变了

00:37:45.100 --> 00:37:49.780
多年来，并发布了一部分

00:37:47.620 --> 00:37:51.670
 JDK 8中的项目哀叹不是

00:37:49.780 --> 00:37:54.730
允许使用单个下划线

00:37:51.670 --> 00:37:56.860
作为lambda的参数目标是

00:37:54.730 --> 00:37:58.720
避免与Wunderbar混淆

00:37:56.860 --> 00:38:02.230
您可能会使用其他语言的功能

00:37:58.720 --> 00:38:04.420
已经使用过，而在JDK 8中，它仍然存在

00:38:02.230 --> 00:38:05.980
将单个下划线用作

00:38:04.420 --> 00:38:08.470
在其他情况下命名

00:38:05.980 --> 00:38:10.630
 Java C发出的警告通知您

00:38:08.470 --> 00:38:14.320
这可能会消失，的确

00:38:10.630 --> 00:38:15.970
现在和9它已经消失了，为什么会

00:38:14.320 --> 00:38:19.000
我们这样做是违反我们通常的

00:38:15.970 --> 00:38:20.200
您知道的兼容性政策

00:38:19.000 --> 00:38:22.930
今天编译的程序

00:38:20.200 --> 00:38:24.790
明天编译，我们要回收

00:38:22.930 --> 00:38:27.310
在分数上下划线

00:38:24.790 --> 00:38:28.570
还有其他目的

00:38:27.310 --> 00:38:30.100
有一些潜在的可能

00:38:28.570 --> 00:38:33.070
如果您偏爱钻石

00:38:30.100 --> 00:38:35.079
证人或官方方式说我不

00:38:33.070 --> 00:38:37.029
不使用护理或变量

00:38:35.079 --> 00:38:39.789
摆脱它们等等

00:38:37.029 --> 00:38:42.660
特殊用途正在讨论中

00:38:39.789 --> 00:38:45.609
在即将到来的JK的喷气机下

00:38:42.660 --> 00:38:49.809
在JEP的三分之二以下

00:38:45.609 --> 00:38:53.259
 lamda剩菜剩饭在下私人工作

00:38:49.809 --> 00:38:55.089
界面方法又是这些

00:38:53.259 --> 00:38:58.239
另一个lambda项目

00:38:55.089 --> 00:39:00.489
清理项目lambda添加了默认值

00:38:58.239 --> 00:39:03.789
接口的方法即方法

00:39:00.489 --> 00:39:06.309
可以有身体，所以他们不是

00:39:03.789 --> 00:39:08.279
现在在VM级别上抽象

00:39:06.309 --> 00:39:11.440
方便和有私人需要

00:39:08.279 --> 00:39:13.900
接口中帮助实现的方法

00:39:11.440 --> 00:39:15.519
这些但是私人的方法和

00:39:13.900 --> 00:39:19.690
接口在源端无效

00:39:15.519 --> 00:39:21.999
 JDK 8中的级别，所以现在我们已经更改了

00:39:19.690 --> 00:39:24.640
在JDK 9中，您可以同时拥有两个

00:39:21.999 --> 00:39:26.739
实例方法以及私有方法

00:39:24.640 --> 00:39:28.089
静态方法，为什么需要

00:39:26.739 --> 00:39:30.039
接口中的这​​些私有方法

00:39:28.089 --> 00:39:31.779
您可以将它们作为辅助方法

00:39:30.039 --> 00:39:35.890
其他默认方法，因此它们是

00:39:31.779 --> 00:39:37.809
为此，我将非常有用

00:39:35.890 --> 00:39:40.180
谈论被谈论过时和

00:39:37.809 --> 00:39:44.109
进口这是另外几个

00:39:40.180 --> 00:39:45.699
语言变化很小，所以他的背景

00:39:44.109 --> 00:39:47.890
几年前在JDK中说

00:39:45.699 --> 00:39:50.559
从JDK 8开始，我们有一些未付费用

00:39:47.890 --> 00:39:52.630
技术债务超过10,000 

00:39:50.559 --> 00:39:54.880
来自我们自己的代码的警告

00:39:52.630 --> 00:39:56.619
编译器，所以不是很好

00:39:54.880 --> 00:39:59.049
情况开始，这些年来我们

00:39:56.619 --> 00:40:01.269
努力不击倒那些

00:39:59.049 --> 00:40:03.759
警告，因此在JK9开始之前，我们

00:40:01.269 --> 00:40:05.799
有大约一半的约5,000 

00:40:03.759 --> 00:40:07.989
在JDK 9开始之间

00:40:05.799 --> 00:40:10.049
 47号楼，我们从几个落下

00:40:07.989 --> 00:40:12.640
一千个警告一直到零

00:40:10.049 --> 00:40:15.729
我们对转身感到很高兴

00:40:12.640 --> 00:40:18.339
在我们的构建中出现极好的W错误

00:40:15.729 --> 00:40:20.140
发现了我们的开放代码关闭代码并

00:40:18.339 --> 00:40:22.809
的某些部分中的所有其他代码

00:40:20.140 --> 00:40:24.789
现在看一下平台

00:40:22.809 --> 00:40:26.979
可能今天提交了，这不是很正确

00:40:24.789 --> 00:40:29.109
仍然有几十个

00:40:26.979 --> 00:40:31.989
在一段时间内是正确的，在许多情况下是正确的

00:40:29.109 --> 00:40:33.459
构建，但我们目前有几十个

00:40:31.989 --> 00:40:35.469
新的和九个的剩余警告

00:40:33.459 --> 00:40:37.359
类别，所以我们还没有完全了解

00:40:35.469 --> 00:40:38.619
围绕修复那些，但也许

00:40:37.359 --> 00:40:42.099
会议结束后我将可以修复

00:40:38.619 --> 00:40:43.479
那些9中的人和那些没有警告的人

00:40:42.099 --> 00:40:45.609
大多数没有警告的模块包括

00:40:43.479 --> 00:40:47.829
基本模块桌面在诸如

00:40:45.609 --> 00:40:48.480
我们无法解决的编译器

00:40:47.829 --> 00:40:51.300
覆盖

00:40:48.480 --> 00:40:53.040
平台的其他部分

00:40:51.300 --> 00:40:54.720
经常谈论技术债务，我也会

00:40:53.040 --> 00:40:56.420
喜欢谈论技术红利

00:40:54.720 --> 00:40:59.910
这样做有一些好处

00:40:56.420 --> 00:41:01.260
因为我们有外部警告，所以我们没有

00:40:59.910 --> 00:41:03.450
不必担心忘记

00:41:01.260 --> 00:41:06.030
声明，以便您使用版本UID， 

00:41:03.450 --> 00:41:07.440
等于从Java C到

00:41:06.030 --> 00:41:09.750
确保当您覆盖一个

00:41:07.440 --> 00:41:12.270
做到其他可能的安全

00:41:09.750 --> 00:41:14.609
受益于失败

00:41:12.270 --> 00:41:16.830
几年前的安全问题是

00:41:14.609 --> 00:41:18.570
类似于意外开关

00:41:16.830 --> 00:41:20.630
在跌倒，这是其中之一

00:41:18.570 --> 00:41:23.910
 Java C错误检查的条件，以及

00:41:20.630 --> 00:41:26.850
在那个图中最低的最低

00:41:23.910 --> 00:41:29.250
底层是关于弃用的

00:41:26.850 --> 00:41:31.740
弃用的确是可以接受的

00:41:29.250 --> 00:41:34.200
项目，我写了一些建议，如果

00:41:31.740 --> 00:41:37.790
您想要尝试删除Java C 

00:41:34.200 --> 00:41:37.790
来自您自己的代码库的错误，因此

00:41:39.470 --> 00:41:43.290
弃用错误，我们有数百个

00:41:41.670 --> 00:41:45.450
他们有几种方法可以

00:41:43.290 --> 00:41:47.970
解决它们，您可以删除使用

00:41:45.450 --> 00:41:49.470
不推荐使用的元素

00:41:47.970 --> 00:41:51.869
有些方法，但您不能总是做到这一点

00:41:49.470 --> 00:41:54.510
可能需要保持如何曝光

00:41:51.869 --> 00:41:56.130
您的客户的功能，您可以

00:41:54.510 --> 00:41:58.980
将不推荐使用的注释传播到

00:41:56.130 --> 00:42:00.420
现在以某种方式在青年站点

00:41:58.980 --> 00:42:02.040
治愈比疾病还差

00:42:00.420 --> 00:42:03.359
因为你在扩张而不是

00:42:02.040 --> 00:42:05.550
签约金额

00:42:03.359 --> 00:42:07.650
不推荐使用的代码，所以最后一件事

00:42:05.550 --> 00:42:10.380
你可以做的就是可以使用抑制

00:42:07.650 --> 00:42:11.910
警告注释声明是

00:42:10.380 --> 00:42:15.510
我知道我在做，但是不用担心

00:42:11.910 --> 00:42:17.160
没关系，让我们看看你如何

00:42:15.510 --> 00:42:19.859
可能会使用您的客户代码

00:42:17.160 --> 00:42:22.590
您拥有已弃用的库，所以当

00:42:19.859 --> 00:42:25.470
你编译你得到这个警告说

00:42:22.590 --> 00:42:26.970
好吧，我不能，我不想做这个

00:42:25.470 --> 00:42:28.500
弃用自己，就像你必须

00:42:26.970 --> 00:42:30.720
继续使用已弃用的库，因此

00:42:28.500 --> 00:42:32.640
您只需应用抑制警告

00:42:30.720 --> 00:42:35.250
像这样在顶部的注释

00:42:32.640 --> 00:42:37.710
看起来不错的课程，所以你

00:42:35.250 --> 00:42:41.280
再次编译，您仍然会得到一个

00:42:37.710 --> 00:42:42.330
弃用警告，这是怎么回事

00:42:41.280 --> 00:42:44.520
好吧，如果你再看一点

00:42:42.330 --> 00:42:46.410
到底发生了什么事，你实际上

00:42:44.520 --> 00:42:47.760
在这种情况下，会从

00:42:46.410 --> 00:42:49.890
导入声明，因为您

00:42:47.760 --> 00:42:52.440
导入不推荐使用的库

00:42:49.890 --> 00:42:54.210
现在，您必须由JLS发出警告

00:42:52.440 --> 00:42:55.859
可能会说那不是我要解决的问题

00:42:54.210 --> 00:42:58.290
只是应用另一个抑制警告

00:42:55.859 --> 00:43:00.480
您在导入语句上的注释

00:42:58.290 --> 00:43:02.460
现在不能放注释了

00:43:00.480 --> 00:43:04.860
句法上有效

00:43:02.460 --> 00:43:06.780
所以今天早上好用

00:43:04.860 --> 00:43:08.310
但这是无济于事的，因为如果

00:43:06.780 --> 00:43:11.340
您可以禁止使用其他所有用途

00:43:08.310 --> 00:43:13.170
过时的类型为什么可以为什么你

00:43:11.340 --> 00:43:14.580
从导入中获得此警告

00:43:13.170 --> 00:43:15.960
声明，您不必做

00:43:14.580 --> 00:43:17.790
像更改为完全使用

00:43:15.960 --> 00:43:19.680
到处都有合格的名称

00:43:17.790 --> 00:43:22.230
免费警告程序@wa little silly 

00:43:19.680 --> 00:43:25.650
所以我们改变语言规范

00:43:22.230 --> 00:43:28.440
在9中不需要警告

00:43:25.650 --> 00:43:30.030
情况，现在

00:43:28.440 --> 00:43:31.860
易于处理以清除大量代码

00:43:30.030 --> 00:43:33.810
弃用警告和存在

00:43:31.860 --> 00:43:38.400
证明就是它的jdk代码库

00:43:33.810 --> 00:43:41.160
关闭，因此还有更多更改

00:43:38.400 --> 00:43:42.990
在JDK 9中弃用

00:43:41.160 --> 00:43:44.820
弃用是什么意思

00:43:42.990 --> 00:43:46.560
周围很长一段时间，这意味着

00:43:44.820 --> 00:43:48.660
有害，这意味着它会消失， 

00:43:46.560 --> 00:43:50.610
如果确实意味着它会消失，为什么

00:43:48.660 --> 00:43:51.870
你不是把码头蛋糕的家伙都搬走了吗

00:43:50.610 --> 00:43:53.790
任何东西或只是删除一两个

00:43:51.870 --> 00:43:57.630
这些年来一切都好，我们

00:43:53.790 --> 00:43:59.790
需要一套更丰富的工具来帮助

00:43:57.630 --> 00:44:02.700
管理这一点，我们通过更改来做到这一点

00:43:59.790 --> 00:44:04.950
 JDK 9中的弃用注释

00:44:02.700 --> 00:44:07.380
特别是有更多信息

00:44:04.950 --> 00:44:09.420
添加了一种表示删除的方法

00:44:07.380 --> 00:44:11.970
无论您的设备是布尔型

00:44:09.420 --> 00:44:13.710
是否删除，这意味着什么

00:44:11.970 --> 00:44:15.150
我们在Java中应用的类型

00:44:13.710 --> 00:44:17.850
如果有问题，请在JDK上进行操作

00:44:15.150 --> 00:44:20.580
不建议移除，我们打算

00:44:17.850 --> 00:44:22.980
在下一个专业中删除该项目

00:44:20.580 --> 00:44:26.100
版本其他版本，以便该项目

00:44:22.980 --> 00:44:29.190
在JDK 9中不建议删除true 

00:44:26.100 --> 00:44:31.680
我们计划在JDK 10中删除

00:44:29.190 --> 00:44:33.930
此移除的新皮棉类别

00:44:31.680 --> 00:44:35.820
类别尚未完成清洁

00:44:33.930 --> 00:44:38.190
在我们自己的代码库中

00:44:35.820 --> 00:44:41.250
如果您使用的是一个额外的警告

00:44:38.190 --> 00:44:42.480
一个用于删除真实项目而不是

00:44:41.250 --> 00:44:44.400
只是对他们不赞成

00:44:42.480 --> 00:44:48.270
整个都有更新

00:44:44.400 --> 00:44:50.850
 Java语言规范中的平台

00:44:48.270 --> 00:44:52.740
 C和Java股票还有一个新的

00:44:50.850 --> 00:44:54.510
静态分析以添加deborah的罐头

00:44:52.740 --> 00:44:56.340
它将分析您的班级文件，并

00:44:54.510 --> 00:44:59.190
 jar文件，让您知道何时

00:44:56.340 --> 00:45:01.320
使用不推荐使用的API和不推荐使用的API 

00:44:59.190 --> 00:45:04.340
去除API的，所以你可以清理

00:45:01.320 --> 00:45:06.870
自行完成，无需重新编译

00:45:04.340 --> 00:45:08.520
最后，我将简要概述

00:45:06.870 --> 00:45:11.850
一些正在进行的库更新

00:45:08.520 --> 00:45:16.040
在发行版中首先有一个新的

00:45:11.850 --> 00:45:19.600
版本字符串方案库

00:45:16.040 --> 00:45:21.530
多年来我们有1.5 1.6 1.7 1.8 

00:45:19.600 --> 00:45:23.870
你会发现一个点永远不会

00:45:21.530 --> 00:45:25.430
变化，所以我们决定，因为它不是

00:45:23.870 --> 00:45:28.070
改变没有理由

00:45:25.430 --> 00:45:32.020
所以我们删除了它，现在从

00:45:28.070 --> 00:45:34.670
 JT 9将会像不是

00:45:32.020 --> 00:45:38.360
有一些完成的工作

00:45:34.670 --> 00:45:40.640
 JDK 9中的字符串有一个新的内部

00:45:38.360 --> 00:45:42.350
紧凑字符串的表示形式

00:45:40.640 --> 00:45:44.720
使用字节数组而不是汽车数组

00:45:42.350 --> 00:45:46.460
所以它们通常更密集，记忆更好

00:45:44.720 --> 00:45:49.640
垃圾收集和

00:45:46.460 --> 00:45:53.540
就像还有另外的努力

00:45:49.640 --> 00:45:56.150
提供沟通渠道

00:45:53.540 --> 00:45:58.130
 Java编译器之间的接口

00:45:56.150 --> 00:46:00.710
 VM具有更好的字符串连接

00:45:58.130 --> 00:46:04.640
字符串串联的形状

00:46:00.710 --> 00:46:07.940
 Java编译器发出的形状

00:46:04.640 --> 00:46:10.280
特定的VM可以使运行迅速

00:46:07.940 --> 00:46:12.620
随着时间的推移而改变，这是一个

00:46:10.280 --> 00:46:14.060
可以用来获得的稳定点

00:46:12.620 --> 00:46:19.280
更好的表现

00:46:14.060 --> 00:46:21.590
操作上的一些注意事项

00:46:19.280 --> 00:46:23.330
集合有多少次

00:46:21.590 --> 00:46:25.310
你想要的这样的书面代码

00:46:23.330 --> 00:46:26.780
这是一组可修改的字符串

00:46:25.310 --> 00:46:28.760
你会得到一个哈希，你会

00:46:26.780 --> 00:46:30.620
放一些东西然后放

00:46:28.760 --> 00:46:33.080
包装器这是一种占用很多

00:46:30.620 --> 00:46:35.120
空间的大小，以便我们做

00:46:33.080 --> 00:46:37.580
像这样的东西，我们使用

00:46:35.120 --> 00:46:39.410
凸起的点作为列表，然后我们有

00:46:37.580 --> 00:46:41.180
那里的包装纸较短，但是

00:46:39.410 --> 00:46:43.160
还是有点长，还有其他

00:46:41.180 --> 00:46:44.810
可以使用双重编码技术

00:46:43.160 --> 00:46:46.700
用匿名类我做大括号

00:46:44.810 --> 00:46:49.160
甚至不表明这一点，但这仍然

00:46:46.700 --> 00:46:49.670
相当笨拙，非常常见

00:46:49.160 --> 00:46:51.560
运作

00:46:49.670 --> 00:46:53.240
因此在JDK 9中，我们不必编写代码

00:46:51.560 --> 00:46:57.350
这样我们就可以编写代码了

00:46:53.240 --> 00:46:59.690
这样更好的这些

00:46:57.350 --> 00:47:02.720
有一个静态的工厂方法

00:46:59.690 --> 00:47:05.450
添加到列表集中并映射这些返回

00:47:02.720 --> 00:47:08.510
不可修改的收藏地图和列表

00:47:05.450 --> 00:47:10.370
在我的中有随机的迭代顺序

00:47:08.510 --> 00:47:12.440
同事对此有两点评论

00:47:10.370 --> 00:47:14.930
我们将要讨论的功能

00:47:12.440 --> 00:47:19.070
稍后在jt9中进行其他集合更改

00:47:14.930 --> 00:47:21.380
今天下午，delvia对象是一种类型

00:47:19.070 --> 00:47:22.850
有各种实用方法

00:47:21.380 --> 00:47:24.920
也扩大了它以拥有一些

00:47:22.850 --> 00:47:27.910
用于检查null的其他选项

00:47:24.920 --> 00:47:31.480
并检查索引很常见

00:47:27.910 --> 00:47:33.099
像我一样做数学，我们做了一些改变

00:47:31.480 --> 00:47:36.069
还有使用乘法加法

00:47:33.099 --> 00:47:37.270
硬件说明

00:47:36.069 --> 00:47:39.400
浮点数越来越多

00:47:37.270 --> 00:47:41.470
如果您做类似的事情更常见

00:47:39.400 --> 00:47:43.109
我们现在的字典顺序比较

00:47:41.470 --> 00:47:45.400
有内在的支持，所以我们可以使用

00:47:43.109 --> 00:47:47.670
硬件说明

00:47:45.400 --> 00:47:51.069
使用这种方法在平台上更快

00:47:47.670 --> 00:47:54.339
并发和变量也发生变化

00:47:51.069 --> 00:47:56.140
用于更高级编程的句柄

00:47:54.339 --> 00:48:00.490
还有很多其他变化

00:47:56.140 --> 00:48:03.220
重点介绍一下

00:48:00.490 --> 00:48:05.140
 jdk 9我们正在做出根本性的改变

00:48:03.220 --> 00:48:07.510
模块化的程序平台

00:48:05.140 --> 00:48:10.799
但是我们还有很多其他变化

00:48:07.510 --> 00:48:13.990
和模块化，其他变化是

00:48:10.799 --> 00:48:17.470
着眼于长期鼓励

00:48:13.990 --> 00:48:20.170
平台的发展如此发展

00:48:17.470 --> 00:48:22.240
在美国是合法的饮酒年龄

00:48:20.170 --> 00:48:24.640
已经存在超过21年了，我们

00:48:22.240 --> 00:48:28.510
希望有很多人可以使用Java 

00:48:24.640 --> 00:48:30.819
在这之后的几十年中

00:48:28.510 --> 00:48:32.710
这些语言更改和其他更改

00:48:30.819 --> 00:48:34.720
已计划并展开多个

00:48:32.710 --> 00:48:36.400
年和多个ESA，我们拥有

00:48:34.720 --> 00:48:38.319
现在更好的工具来帮助管理

00:48:36.400 --> 00:48:40.990
为自己和自己过渡

00:48:38.319 --> 00:48:42.910
 Java用户这是公开进行的

00:48:40.990 --> 00:48:44.470
 JDK，因此，如果您想更多地参与进来

00:48:42.910 --> 00:48:46.750
您，欢迎您跟随那里， 

00:48:44.470 --> 00:48:52.380
这些早期访问版本可用

00:48:46.750 --> 00:48:56.260
今天为您评估，所以请

00:48:52.380 --> 00:48:58.569
尽早试用jk9 

00:48:56.260 --> 00:49:02.079
访问位，这是幻灯片的URL 

00:48:58.569 --> 00:49:05.079
现在我们有时间来问一些问题

00:49:02.079 --> 00:49:10.170
您也可以在推特上提问

00:49:05.079 --> 00:49:10.170
最后一张幻灯片上的主题标签谢谢

00:49:12.220 --> 00:49:19.119
如果您有任何疑问，请提出

00:49:14.599 --> 00:49:19.119
过道中的麦克风之一

00:49:25.830 --> 00:49:31.830
我的问题是您是否考虑过

00:49:28.290 --> 00:49:33.890
 4/9中的数组切片，你会

00:49:31.830 --> 00:49:36.060
在将来考虑数组切片

00:49:33.890 --> 00:49:36.390
你能说出你的意思吗

00:49:36.060 --> 00:49:39.330
那

00:49:36.390 --> 00:49:41.220
就像在Python中一样

00:49:39.330 --> 00:49:44.280
通过使用

00:49:41.220 --> 00:49:45.900
语言是的，问题是我们

00:49:44.280 --> 00:49:49.490
考虑不是这样的数组切片

00:49:45.900 --> 00:49:51.450
考虑有更多基于数组的

00:49:49.490 --> 00:49:58.470
改变来了，但我不认为

00:49:51.450 --> 00:50:00.000
一个正在讨论的一个我会失望的

00:49:58.470 --> 00:50:01.090
这里如果还有其他问题谢谢

00:50:00.000 --> 00:50:07.630
你今天要来这里

00:50:01.090 --> 00:50:07.630
 [音乐] 

