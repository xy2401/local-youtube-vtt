WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.810 --> 00:00:10.020
你好，谢谢你今天来我这里

00:00:07.020 --> 00:00:12.090
我叫乔·达西（Jo Darcy） 

00:00:10.020 --> 00:00:15.420
平台小组，我将发言

00:00:12.090 --> 00:00:17.730
今天有关JDK 9语言工具和

00:00:15.420 --> 00:00:20.070
库功能，以防我们没有

00:00:17.730 --> 00:00:22.500
谈话结束时进行问答的时间是否

00:00:20.070 --> 00:00:24.960
您在此标签JDK 9上发布了推文

00:00:22.500 --> 00:00:27.390
工具库，我可以在那里回答问题

00:00:24.960 --> 00:00:29.640
演讲的最后一张幻灯片也将

00:00:27.390 --> 00:00:36.120
有指向幻灯片平台PDF的URL 

00:00:29.640 --> 00:00:38.040
所以这是甲骨文的避风港

00:00:36.120 --> 00:00:39.360
声明它让你知道你不应该

00:00:38.040 --> 00:00:41.579
对我必须做的事过于信任

00:00:39.360 --> 00:00:43.710
今天在这里告诉你，特别是关于

00:00:41.579 --> 00:00:45.780
福特寻找声明，但自

00:00:43.710 --> 00:00:46.620
演讲是关于JDK 9 + j TK 9要点

00:00:45.780 --> 00:00:48.559
船不是很多

00:00:46.620 --> 00:00:50.910
本演讲中的前瞻性陈述

00:00:48.559 --> 00:00:52.890
可能会有点重复

00:00:50.910 --> 00:00:53.489
 Oracle安全港声明全文

00:00:52.890 --> 00:00:55.469
此次会议

00:00:53.489 --> 00:00:57.000
如果您需要一些替代技巧

00:00:55.469 --> 00:00:59.969
我会很高兴在该地区的安全港

00:00:57.000 --> 00:01:02.340
为以后的人们提供快速

00:00:59.969 --> 00:01:03.870
在开始使用哪个JDK之前进行调查

00:01:02.340 --> 00:01:05.880
您正在生产中使用的火车

00:01:03.870 --> 00:01:06.799
 JDK上有非常早期的采用者

00:01:05.880 --> 00:01:08.700
九点了

00:01:06.799 --> 00:01:12.420
我会好好了解

00:01:08.700 --> 00:01:14.520
谁下载了JDK 9 JDK好

00:01:12.420 --> 00:01:15.750
很好，也许之后会有更多人

00:01:14.520 --> 00:01:17.850
演讲或演讲结束后

00:01:15.750 --> 00:01:21.830
会议将在其中下载JDK 8 

00:01:17.850 --> 00:01:27.420
几乎每个人都可以进行生产

00:01:21.830 --> 00:01:28.770
好吧，大约有四分之一的ek6还是

00:01:27.420 --> 00:01:31.380
现在有两只流浪的手

00:01:28.770 --> 00:01:33.990
这里的朋友，谁愿意

00:01:31.380 --> 00:01:35.909
在生产中使用5或更高版本的JDK 

00:01:33.990 --> 00:01:37.829
还好吧，一些诚实的人

00:01:35.909 --> 00:01:40.110
昨天的观众很棒

00:01:37.829 --> 00:01:41.670
发布，但我们有很多

00:01:40.110 --> 00:01:44.869
从那时起，希望如此

00:01:41.670 --> 00:01:48.689
您将可以很快尝试

00:01:44.869 --> 00:01:50.909
正如我提到的JDK 9一样，概述了JDK 9 

00:01:48.689 --> 00:01:53.490
就在几周前才刚发货

00:01:50.909 --> 00:01:55.409
最后的几个JDK项目是

00:01:53.490 --> 00:01:57.540
在开放JDK的主持下开发

00:01:55.409 --> 00:01:59.220
因此，如果您有兴趣参加

00:01:57.540 --> 00:02:00.899
邮件发送后的开发

00:01:59.220 --> 00:02:03.659
列出尝试找到的构建的列表

00:02:00.899 --> 00:02:06.390
在开放的JDK网站上获得更多信息

00:02:03.659 --> 00:02:08.670
在整个谈话中，我将使用

00:02:06.390 --> 00:02:11.250
 JEP JEP是JDK的增强功能

00:02:08.670 --> 00:02:13.800
提案这些是我们用于的文件

00:02:11.250 --> 00:02:17.610
 JDK中的功能跟踪，如果您

00:02:13.800 --> 00:02:19.050
转到JDK 9的打开的JDK页面

00:02:17.610 --> 00:02:20.430
您会看到一长串的喷气机

00:02:19.050 --> 00:02:22.730
他们大约是90架，我们不会

00:02:20.430 --> 00:02:26.460
今天谈论他们所有人，但是

00:02:22.730 --> 00:02:28.800
除了许多喷气机外，JDK 9还有很多错误

00:02:26.460 --> 00:02:32.040
修复这是一个比较图表

00:02:28.800 --> 00:02:35.070
 9 vs 8中的错误修复数量，因此

00:02:32.040 --> 00:02:37.380
可以看到JDK 9中有将近20,000个修复程序

00:02:35.070 --> 00:02:39.750
它略小于两倍

00:02:37.380 --> 00:02:42.750
 JDK 8有这么大的版本

00:02:39.750 --> 00:02:44.040
到处都有拼图

00:02:42.750 --> 00:02:45.860
功能和许多其他功能

00:02:44.040 --> 00:02:49.320
我们将谈论

00:02:45.860 --> 00:02:51.200
因此，关于JDK 9的讨论将不完整

00:02:49.320 --> 00:02:54.450
没有提到模块化

00:02:51.200 --> 00:02:56.670
项目拼图项目拼图是一个非常

00:02:54.450 --> 00:02:59.070
大功能和模块化

00:02:56.670 --> 00:03:02.010
拼图的功能是使

00:02:59.070 --> 00:03:03.900
在更简单的大型模块中编程

00:03:02.010 --> 00:03:05.880
将一个或多个包装包在一起

00:03:03.900 --> 00:03:08.790
重用单位并提供更强大的功能

00:03:05.880 --> 00:03:11.040
比jar文件封装的原因之一

00:03:08.790 --> 00:03:12.660
拼图是一个大项目，是因为

00:03:11.040 --> 00:03:15.060
它需要整个改变

00:03:12.660 --> 00:03:17.820
平台方面的语言

00:03:15.060 --> 00:03:20.040
工具和库的语言变化

00:03:17.820 --> 00:03:22.410
拼图包括一种新型文件

00:03:20.040 --> 00:03:25.230
声明的模块信息Java文件

00:03:22.410 --> 00:03:27.920
 Java C模块之间的依赖关系是

00:03:25.230 --> 00:03:30.510
更新以支持这种新的

00:03:27.920 --> 00:03:32.820
源文件以及查找

00:03:30.510 --> 00:03:34.230
通过模块的依赖

00:03:32.820 --> 00:03:36.480
对Java的相应更新

00:03:34.230 --> 00:03:38.580
命令和热点运行时间为

00:03:36.480 --> 00:03:41.549
了解模块化限制

00:03:38.580 --> 00:03:44.640
还有一些API更改

00:03:41.549 --> 00:03:46.380
 API更改包括对核心的更新

00:03:44.640 --> 00:03:49.459
反思和语言模型

00:03:46.380 --> 00:03:51.720
为平台的新方面建模

00:03:49.459 --> 00:03:54.030
现在还有更多要说的

00:03:51.720 --> 00:03:55.860
模块化，无法容纳单个45 

00:03:54.030 --> 00:03:57.989
因此，分钟会议

00:03:55.860 --> 00:04:00.269
拼图团队有5个45分钟的课程

00:03:57.989 --> 00:04:03.750
在JavaOne上，其中一些

00:04:00.269 --> 00:04:05.220
已经发生，他们可能会被给予

00:04:03.750 --> 00:04:07.290
稍后在会议中再次发言，以便您可以

00:04:05.220 --> 00:04:09.720
检查调度应用程序和

00:04:07.290 --> 00:04:13.620
其他几个会议稍后

00:04:09.720 --> 00:04:16.079
会议的下午或以后

00:04:13.620 --> 00:04:17.970
这个谈话我们接下来将开始谈论

00:04:16.079 --> 00:04:20.130
关于我们的管理方法

00:04:17.970 --> 00:04:22.169
 Java平台，那么我们将讨论

00:04:20.130 --> 00:04:24.540
工具语言和库更新

00:04:22.169 --> 00:04:26.039
虽然其中一些功能很漂亮

00:04:24.540 --> 00:04:27.990
有时会有所不同

00:04:26.039 --> 00:04:30.059
涉及多个领域，如果我们

00:04:27.990 --> 00:04:32.949
最后有时间进行一些问答

00:04:30.059 --> 00:04:35.199
所以管家我们使用的方法

00:04:32.949 --> 00:04:37.089
对于JDK的管理非常

00:04:35.199 --> 00:04:39.610
与管理方法不同

00:04:37.089 --> 00:04:41.110
由说Denethor及其当前使用

00:04:39.610 --> 00:04:44.169
国王电影的管家

00:04:41.110 --> 00:04:46.539
贡多Java的第一目标

00:04:44.169 --> 00:04:48.839
最后七个平台组和一个

00:04:46.539 --> 00:04:51.430
保持Java蓬勃发展已经有半年了

00:04:48.839 --> 00:04:52.749
保持Java充满活力的手段的一部分

00:04:51.430 --> 00:04:54.159
保持今天有效的东西

00:04:52.749 --> 00:04:57.729
明天工作

00:04:54.159 --> 00:05:00.159
这样的主题是兼容性，所以

00:04:57.729 --> 00:05:03.039
关于JDK的基本政策

00:05:00.159 --> 00:05:05.740
正在明智地管理兼容性

00:05:03.039 --> 00:05:07.270
我们的一般政策是

00:05:05.740 --> 00:05:09.309
不想破坏二进制兼容性

00:05:07.270 --> 00:05:11.229
如Java语言中所定义

00:05:09.309 --> 00:05:12.939
意味着我们想要的规格

00:05:11.229 --> 00:05:15.129
今天联系起来的程序员能够

00:05:12.939 --> 00:05:16.779
链接明天我们要避免

00:05:15.129 --> 00:05:19.449
引入源不兼容性

00:05:16.779 --> 00:05:21.309
那是程序停止编译的地方，或者

00:05:19.449 --> 00:05:22.870
如果他们编译他们编译他们的意思是

00:05:21.309 --> 00:05:24.520
有些不同，我们想要

00:05:22.870 --> 00:05:26.979
管理行为兼容性

00:05:24.520 --> 00:05:29.349
当您现在调用此方法时

00:05:26.979 --> 00:05:31.209
理念适用于我们的API更改

00:05:29.349 --> 00:05:34.120
在平台上制作，但它也适用

00:05:31.209 --> 00:05:35.800
我们拥有的语言功能

00:05:34.120 --> 00:05:39.580
实例，因为这项政策，我们仍然

00:05:35.800 --> 00:05:41.949
识别旧版本40 5.3类文件

00:05:39.580 --> 00:05:44.589
由Java一人在20多岁时产生

00:05:41.949 --> 00:05:46.839
多年前，我们限制了合法的案件

00:05:44.589 --> 00:05:50.129
存放的代码停止在较新的版本中编译

00:05:46.839 --> 00:05:52.509
平台发布，我们要避免

00:05:50.129 --> 00:05:55.240
代码语义的变化

00:05:52.509 --> 00:05:57.370
重新编译时生成

00:05:55.240 --> 00:05:59.139
任何形式的兼容政策之一

00:05:57.370 --> 00:06:02.669
这里的权衡是找到正确的

00:05:59.139 --> 00:06:04.899
稳定与进步之间的平衡

00:06:02.669 --> 00:06:07.120
所以我们有三种兼容性

00:06:04.899 --> 00:06:10.269
通过任何二进制和行为来源

00:06:07.120 --> 00:06:12.339
行为，如果我们还记得

00:06:10.269 --> 00:06:14.139
物理课，我们可以抓图

00:06:12.339 --> 00:06:16.360
这是三维图， 

00:06:14.139 --> 00:06:18.279
不同类型的发行有

00:06:16.360 --> 00:06:20.830
不同种类的兼容区域

00:06:18.279 --> 00:06:22.479
那是可以接受的，所以如果我们说

00:06:20.830 --> 00:06:25.089
该安全更新将释放那些

00:06:22.479 --> 00:06:27.129
每季度发布四次

00:06:25.089 --> 00:06:29.110
一年几次，他们有一个很小的

00:06:27.129 --> 00:06:30.999
进行更改的区域有一些

00:06:29.110 --> 00:06:33.069
行为改变当然是因为我们

00:06:30.999 --> 00:06:34.059
想修复该漏洞，也许

00:06:33.069 --> 00:06:36.909
有一点来源

00:06:34.059 --> 00:06:40.329
是否兼容JDK特定的API 

00:06:36.909 --> 00:06:42.729
我们有一个较大的版本，例如

00:06:40.329 --> 00:06:43.510
更新版本，例如8 you xx和8 u 40 

00:06:42.729 --> 00:06:45.550
的

00:06:43.510 --> 00:06:47.260
更大，所以他们有更多的空间

00:06:45.550 --> 00:06:49.570
改变行为等等

00:06:47.260 --> 00:06:51.940
进行源更改的机会

00:06:49.570 --> 00:06:53.380
但是在这两种情况下

00:06:51.940 --> 00:06:55.750
没有二进制和兼容的空间

00:06:53.380 --> 00:06:57.790
我们不想打扰别人的变化或

00:06:55.750 --> 00:06:59.560
更新版本，因为我们希望人们能够

00:06:57.790 --> 00:07:02.170
尽快使用这些更新版本

00:06:59.560 --> 00:07:05.680
他们出来发布平台

00:07:02.170 --> 00:07:08.950
像JDK 8 GA或JDK 9 GA的情况

00:07:05.680 --> 00:07:10.540
有所不同，有最大

00:07:08.950 --> 00:07:12.460
房间数量会改变行为

00:07:10.540 --> 00:07:15.340
还有更多空间来进行源更改，以及

00:07:12.460 --> 00:07:17.140
在特殊情况下，足够

00:07:15.340 --> 00:07:18.640
证明甚至有

00:07:17.140 --> 00:07:20.710
做一些二进制的可能性

00:07:18.640 --> 00:07:22.690
不兼容的更改，我会提到一些

00:07:20.710 --> 00:07:26.140
后来在JDK 9中制作的那些

00:07:22.690 --> 00:07:27.820
在谈话中，这是一个例子

00:07:26.140 --> 00:07:29.680
帮助说明兼容性

00:07:27.820 --> 00:07:31.390
政策以及如何适用于不同

00:07:29.680 --> 00:07:33.160
发布，所以如果我们看一下

00:07:31.390 --> 00:07:36.160
点迭代器的哈希规范

00:07:33.160 --> 00:07:37.510
它说你回到迭代器， 

00:07:36.160 --> 00:07:40.450
元素没有特别的返回

00:07:37.510 --> 00:07:42.900
这意味着根据

00:07:40.450 --> 00:07:46.000
规格，我们可以改变

00:07:42.900 --> 00:07:48.490
随时随地的迭代顺序

00:07:46.000 --> 00:07:52.030
发布并仍然遵守规范

00:07:48.490 --> 00:07:53.800
那么这如何改变与

00:07:52.030 --> 00:07:55.420
兼容性政策，这将是

00:07:53.800 --> 00:07:57.610
二进制兼容的更改，因为我们

00:07:55.420 --> 00:07:59.740
不改变它的方法集

00:07:57.610 --> 00:08:01.690
也是源兼容的更改，因为

00:07:59.740 --> 00:08:03.400
客户的汇编不

00:08:01.690 --> 00:08:04.630
取决于方法的内部

00:08:03.400 --> 00:08:05.890
主体，因此您可以更改主体的方法

00:08:04.630 --> 00:08:08.050
而且无论是否

00:08:05.890 --> 00:08:10.360
客户端编译，但这是一个

00:08:08.050 --> 00:08:13.150
行为兼容性改变，我们

00:08:10.360 --> 00:08:14.770
知道人们可以隐性做

00:08:13.150 --> 00:08:16.840
有时不小心依靠

00:08:14.770 --> 00:08:17.920
迭代顺序因此是

00:08:16.840 --> 00:08:19.510
我们通常的那种变化

00:08:17.920 --> 00:08:22.060
不会进行任何一种更新

00:08:19.510 --> 00:08:23.950
释放，但我们会做出并已经做出

00:08:22.060 --> 00:08:25.780
在平台上发布的原因

00:08:23.950 --> 00:08:27.880
我们会在平台发布中做到这一点

00:08:25.780 --> 00:08:32.919
利用说更好的哈希

00:08:27.880 --> 00:08:35.860
算法，这就是术语

00:08:32.919 --> 00:08:38.680
为了兼容JDK 8 

00:08:35.860 --> 00:08:40.360
和JDK 9发行指南，以及

00:08:38.680 --> 00:08:43.240
兼容性文件，所以我建议

00:08:40.360 --> 00:08:46.720
当你看着那些

00:08:43.240 --> 00:08:49.690
迁移到那些发行版，如何

00:08:46.720 --> 00:08:51.160
是JDK 9，不同的JDK 9遵循此

00:08:49.690 --> 00:08:54.250
相同的照顾模式

00:08:51.160 --> 00:08:55.720
兼容性，但支持模块化

00:08:54.250 --> 00:08:57.460
更大的兼容

00:08:55.720 --> 00:08:59.530
兼容性影响比平常大

00:08:57.460 --> 00:09:02.290
允许包括一些值得注意的

00:08:59.530 --> 00:09:04.060
的行为不相容

00:09:02.290 --> 00:09:07.180
例如，如果您使用的是

00:09:04.060 --> 00:09:08.710
假设您将拥有RTR 

00:09:07.180 --> 00:09:11.080
更新到该工具的较新版本

00:09:08.710 --> 00:09:13.510
那不依赖那个，因为RTR 

00:09:11.080 --> 00:09:15.970
已经消失了，它不再存在于JDK中

00:09:13.510 --> 00:09:19.270
 9图像信息存储

00:09:15.970 --> 00:09:20.500
不同地支持那里的模块化

00:09:19.270 --> 00:09:22.660
甚至有几次他破产

00:09:20.500 --> 00:09:25.060
二进制兼容性

00:09:22.660 --> 00:09:27.220
之间的不幸依赖

00:09:25.060 --> 00:09:30.550
 Java之间的日志记录框架

00:09:27.220 --> 00:09:32.860
台式机，所以我们不想吸

00:09:30.550 --> 00:09:34.840
 Java桌面随时随地

00:09:32.860 --> 00:09:36.640
使用日志记录，我们修复了问题

00:09:34.840 --> 00:09:40.090
摆脱这些属性侦听器方法

00:09:36.640 --> 00:09:41.320
后来对于API而言并不重要

00:09:40.090 --> 00:09:43.210
在谈话中也正在谈论

00:09:41.320 --> 00:09:44.620
我们有更强硬的弃用政策

00:09:43.210 --> 00:09:49.060
有更好的工具来管理

00:09:44.620 --> 00:09:50.380
过渡正在进行，所以现在我们将

00:09:49.060 --> 00:09:52.150
开始谈论一些工具

00:09:50.380 --> 00:09:56.070
改进和第一个

00:09:52.150 --> 00:09:58.990
工具的改进是J shell Lisp 

00:09:56.070 --> 00:10:01.090
系统通常提供了读取

00:09:58.990 --> 00:10:02.770
评估打印循环为主要方式

00:10:01.090 --> 00:10:05.170
您与该系统进行交互，因此您

00:10:02.770 --> 00:10:07.030
输入命令，系统评估

00:10:05.170 --> 00:10:08.470
它会回到你类似

00:10:07.030 --> 00:10:11.560
在Ruby中找到了功能， 

00:10:08.470 --> 00:10:13.990
 Python和JVM生态系统

00:10:11.560 --> 00:10:17.350
语言也支持Scala常规和闭包

00:10:13.990 --> 00:10:18.850
那么现在在jdk 9中Java又如何呢？ 

00:10:17.350 --> 00:10:21.460
也有叛逆者

00:10:18.850 --> 00:10:31.320
叫j show我将做一个快速演示

00:10:21.460 --> 00:10:31.320
右边的窗户在这里

00:10:31.500 --> 00:10:35.100
好了，所以J Shell是一个新命令

00:10:33.360 --> 00:10:41.070
在JDK bin目录中，我们将获得

00:10:35.100 --> 00:10:43.470
从这里开始，所以有命令

00:10:41.070 --> 00:10:45.660
和J显示Eli反斜杠，所以我们可以

00:10:43.470 --> 00:10:48.510
帮助介绍，因为它建议在这里，我们

00:10:45.660 --> 00:10:49.590
获得有关使用该工具的一些指导，但

00:10:48.510 --> 00:10:51.120
如果我们使用一种新的语言

00:10:49.590 --> 00:10:53.670
环境你第一个程序是什么

00:10:51.120 --> 00:10:55.500
想写你好世界，所以我们可以

00:10:53.670 --> 00:10:56.250
在这里开始输入hello world，我们将

00:10:55.500 --> 00:11:01.020
走着瞧吧

00:10:56.250 --> 00:11:03.090
现在我们回到世界，你好

00:11:01.020 --> 00:11:05.190
好东西不是很

00:11:03.090 --> 00:11:06.870
复杂，但请注意，我们不必

00:11:05.190 --> 00:11:08.880
处理公共静态无效主字符串

00:11:06.870 --> 00:11:10.260
所有这些事情，所以，如果您只想

00:11:08.880 --> 00:11:11.820
做一些非正式的程序并开始

00:11:10.260 --> 00:11:13.980
你可以马上做

00:11:11.820 --> 00:11:16.440
所以除了表达式我们可以定义

00:11:13.980 --> 00:11:18.900
 J中的变量显示，所以我们说

00:11:16.440 --> 00:11:20.610
想找到一个名为

00:11:18.900 --> 00:11:23.400
 tau，当您希望等于

00:11:20.610 --> 00:11:26.100
两次圆周率，所以我们知道有圆周率

00:11:23.400 --> 00:11:29.010
在数学课中保持不变，所以我们开始

00:11:26.100 --> 00:11:30.840
键入数学，我们可以在此处自动完成

00:11:29.010 --> 00:11:33.420
这些是替代方案，因此我们可以

00:11:30.840 --> 00:11:35.940
选择数学，然后再看数学

00:11:33.420 --> 00:11:38.610
变量以P开头的地方

00:11:35.940 --> 00:11:43.410
那里有圆周率，如果我们点击选项卡

00:11:38.610 --> 00:11:45.150
更多的时候，我们会看到我们可以得到

00:11:43.410 --> 00:11:49.160
 pi的文档，我们可以看到它

00:11:45.150 --> 00:11:49.160
确实是我们正在寻找的常数

00:11:49.550 --> 00:11:54.300
课程领域不是很有趣

00:11:51.780 --> 00:11:56.280
你自己也想要方法

00:11:54.300 --> 00:11:59.130
所以我们可以说定义一个方法名

00:11:56.280 --> 00:12:01.790
取双并返回的平方

00:11:59.130 --> 00:12:01.790
它的平方

00:12:06.360 --> 00:12:12.509
在自动完成元素上

00:12:10.059 --> 00:12:14.619
在JDK中，我们还可以自动完成

00:12:12.509 --> 00:12:17.709
我们定义的字段和方法

00:12:14.619 --> 00:12:27.939
我们自己，所以我们可以说走广场

00:12:17.709 --> 00:12:29.889
 tau自动完成的正弦

00:12:27.939 --> 00:12:32.290
进行一些命令行编辑，以便我们可以

00:12:29.889 --> 00:12:33.970
剪切并粘贴，所以如果我们平方

00:12:32.290 --> 00:12:35.559
余弦符号是平方

00:12:33.970 --> 00:12:37.379
我们应该得到接近一个的东西

00:12:35.559 --> 00:12:44.230
这确实是我们在这种情况下得到的

00:12:37.379 --> 00:12:47.170
然后我们可以退出演出，所以

00:12:44.230 --> 00:12:48.519
回到这里的幻灯片，这是

00:12:47.170 --> 00:12:50.199
对学生有好处，减少了仪式

00:12:48.519 --> 00:12:52.240
入门，但J Shell不只是

00:12:50.199 --> 00:12:54.369
对于新手程序员来说，这对

00:12:52.240 --> 00:12:56.019
如果您愿意，也可以是经验丰富的程序员

00:12:54.369 --> 00:12:59.019
开始使用诸如

00:12:56.019 --> 00:13:01.089
新的API在JDK 9中，我找到了J 

00:12:59.019 --> 00:13:03.999
自我帮助并公开帮助

00:13:01.089 --> 00:13:05.949
为这次和其他会谈做准备，所以J 

00:13:03.999 --> 00:13:08.410
外壳具有这些表达式的摘要

00:13:05.949 --> 00:13:10.209
以及Java命令的J Shell 

00:13:08.410 --> 00:13:12.519
实现很有趣

00:13:10.209 --> 00:13:14.290
利用许多现有的JDK技术

00:13:12.519 --> 00:13:16.149
包括编译器API和

00:13:14.290 --> 00:13:18.759
调试器API和用户指南

00:13:16.149 --> 00:13:21.189
帮助我们现在就开始

00:13:18.759 --> 00:13:23.649
我们在JavaOne没有Taco星期二

00:13:21.189 --> 00:13:26.259
周三有J炮弹，明天在那里

00:13:23.649 --> 00:13:28.569
是关于J Shell的4个话题的第一篇

00:13:26.259 --> 00:13:30.730
这些是罗伯特·菲尔德（Robert Field）的

00:13:28.569 --> 00:13:33.910
 J Shell的架构师和首席工程师

00:13:30.730 --> 00:13:36.730
如果罗伯特听到你喜欢J壳，他

00:13:33.910 --> 00:13:39.370
可能会向您展示如何调用嵌套的J 

00:13:36.730 --> 00:13:41.740
 J Shell中的shell，因此您可以使用

00:13:39.370 --> 00:13:42.939
使用波纹时会产生波纹

00:13:41.740 --> 00:13:46.360
如果你不赶上罗伯特·斯托克

00:13:42.939 --> 00:13:50.259
接下来还有其他要抓住的地方

00:13:46.360 --> 00:13:52.240
谈论Javadoc的一些变化

00:13:50.259 --> 00:13:55.809
多年以来，Java文档已输出

00:13:52.240 --> 00:13:58.360
几年前的HTML 401 html5是新的

00:13:55.809 --> 00:14:00.699
标准，现在Java文档可以选择

00:13:58.360 --> 00:14:03.629
输出html5而不是旧的

00:14:00.699 --> 00:14:06.309
 HTML 4.01，这是

00:14:03.629 --> 00:14:09.910
我们用于jdk文档的HTML 

00:14:06.309 --> 00:14:13.420
现在人们可能已经看过医生皮棉

00:14:09.910 --> 00:14:15.970
在JDK 8中检查这些是可以检查的

00:14:13.420 --> 00:14:18.340
从Java doc或Java C运行到

00:14:15.970 --> 00:14:20.260
验证Java文档注释

00:14:18.340 --> 00:14:23.260
我们添加了更多配置选项

00:14:20.260 --> 00:14:24.640
到码头区特别是选择

00:14:23.260 --> 00:14:26.920
您要检查的包裹

00:14:24.640 --> 00:14:29.110
适用于在JDK构建中

00:14:26.920 --> 00:14:31.750
我们主要检查Java的实例

00:14:29.110 --> 00:14:33.580
和Java X软件包，因为我们希望

00:14:31.750 --> 00:14:36.790
我们发布的免费文档

00:14:33.580 --> 00:14:39.880
这些问题的文件

00:14:36.790 --> 00:14:41.740
检查范围从HTML的语法

00:14:39.880 --> 00:14:43.480
标记他们的语义，您可以启用

00:14:41.740 --> 00:14:45.520
并分别禁用它们

00:14:43.480 --> 00:14:49.750
还没有完成清除一个类别的操作

00:14:45.520 --> 00:14:52.029
来自您的构建的警告

00:14:49.750 --> 00:14:54.660
 doclet的实现

00:14:52.029 --> 00:14:58.210
 doclet api很旧，导致返回

00:14:54.660 --> 00:15:00.940
或非常早的jdk并受益

00:14:58.210 --> 00:15:03.640
后见之明建模Java的API 

00:15:00.940 --> 00:15:05.230
语言可以改进，因为

00:15:03.640 --> 00:15:07.570
 doclet API我们实际上有几个

00:15:05.230 --> 00:15:09.490
其他反射式API和平台

00:15:07.570 --> 00:15:10.120
更适合允许语言

00:15:09.490 --> 00:15:12.339
演化

00:15:10.120 --> 00:15:14.860
所以我们重新实施了标准

00:15:12.339 --> 00:15:17.170
作业X Lion Model API之上的doclet 

00:15:14.860 --> 00:15:19.750
编译器支持

00:15:17.170 --> 00:15:23.410
这为我们提供了更好的Java基础

00:15:19.750 --> 00:15:25.839
 Doc的改进又向前迈进了一步

00:15:23.410 --> 00:15:29.430
我们拥有的功能是javac搜索， 

00:15:25.839 --> 00:15:29.430
我会回去做一个演示

00:15:32.850 --> 00:15:37.990
这是JDK九的下载

00:15:35.320 --> 00:15:40.180
 Javadoc有几处更改需要注意

00:15:37.990 --> 00:15:42.070
一个是它分为几个

00:15:40.180 --> 00:15:44.200
刚刚分析过的Java SE部分

00:15:42.070 --> 00:15:46.660
文档还有文档

00:15:44.200 --> 00:15:51.910
适用于JDK特定的类以及Java 

00:15:46.660 --> 00:15:53.410
 FX总共仍然显示框架视图

00:15:51.910 --> 00:15:54.910
可用，但不是默认值， 

00:15:53.410 --> 00:15:57.250
如果我们向下滚动，我们会看到

00:15:54.910 --> 00:15:59.920
主要组织由模块完成

00:15:57.250 --> 00:16:02.170
这样我们就拥有了所有的Java C模块

00:15:59.920 --> 00:16:02.670
 JDK中的模块等等

00:16:02.170 --> 00:16:05.590
向前

00:16:02.670 --> 00:16:07.420
在右上角

00:16:05.590 --> 00:16:09.090
一个搜索框，所以我们说

00:16:07.420 --> 00:16:16.720
有兴趣寻找更多关于数学的信息

00:16:09.090 --> 00:16:19.360
这是一个数学运算，所以我们在这里看到

00:16:16.720 --> 00:16:21.550
通过包获取搜索结果

00:16:19.360 --> 00:16:24.690
名称以及类型名称和字段

00:16:21.550 --> 00:16:28.630
名称，从这里我们可以导航到

00:16:24.690 --> 00:16:30.220
现在我们知道的那些事情

00:16:28.630 --> 00:16:32.080
 Java有时名称很长

00:16:30.220 --> 00:16:34.330
那是公约的一部分，所以如果

00:16:32.080 --> 00:16:36.070
我们想找到说平等无视

00:16:34.330 --> 00:16:37.300
案例方法会很多

00:16:36.070 --> 00:16:39.970
打字，但实际上我们不必

00:16:37.300 --> 00:16:41.950
键入所有内容，因为Java文档

00:16:39.970 --> 00:16:45.820
搜索报告驼峰先生，如果您

00:16:41.950 --> 00:16:48.550
开始输入EQ，然后IG我们可以得到

00:16:45.820 --> 00:16:52.420
等于North忽略大小写方法

00:16:48.550 --> 00:16:55.410
马上好了，我们将回到

00:16:52.420 --> 00:16:55.410
幻灯片

00:16:56.490 --> 00:17:01.440
所以实现是在JavaScript中

00:16:59.010 --> 00:17:03.150
在客户中，所以您不必去

00:17:01.440 --> 00:17:04.740
服务器，如果你想

00:17:03.150 --> 00:17:06.060
找到自己的索引词，有一个标签

00:17:04.740 --> 00:17:08.130
允许你也这样做

00:17:06.060 --> 00:17:10.020
目前它正在做索引

00:17:08.130 --> 00:17:12.650
在您知道的模块的名称上

00:17:10.020 --> 00:17:15.630
封装类型和字段等

00:17:12.650 --> 00:17:18.030
接下来的两个功能将被设计

00:17:15.630 --> 00:17:19.890
简化从一个JDK版本到

00:17:18.030 --> 00:17:22.410
另一个，第一个是十字架

00:17:19.890 --> 00:17:26.100
使用--release标志进行编译- 

00:17:22.410 --> 00:17:28.980
 Java C这么多年的建议

00:17:26.100 --> 00:17:30.900
 Java C mamta时代以及我写过的博客

00:17:28.980 --> 00:17:33.900
已写，其他人已写

00:17:30.900 --> 00:17:35.160
交叉编译到较旧的JDK 

00:17:33.900 --> 00:17:37.890
是你要做的三件事

00:17:35.160 --> 00:17:40.410
必须将源版本设置为

00:17:37.890 --> 00:17:42.900
较旧的版本在和发布目标版本

00:17:40.410 --> 00:17:45.990
最后是引导类路径到旧版本

00:17:42.900 --> 00:17:47.730
释放人们并不总是遵循这个

00:17:45.990 --> 00:17:49.620
指导，以便我们在

00:17:47.730 --> 00:17:52.860
在那里，我们想做点什么

00:17:49.620 --> 00:17:54.840
关于相关的政策变更是

00:17:52.860 --> 00:17:57.210
限制来源和目标的范围

00:17:54.840 --> 00:17:58.980
从Java C开始支持的值

00:17:57.210 --> 00:18:00.210
 JDK 8我们一路不支持

00:17:58.980 --> 00:18:02.430
从头开始

00:18:00.210 --> 00:18:05.910
我们支持当前版本，并在3 

00:18:02.430 --> 00:18:08.760
返回，因此在JDK 9中我们支持9以及

00:18:05.910 --> 00:18:10.170
不推荐使用8 7 + 6 + 6 

00:18:08.760 --> 00:18:11.940
找到下次删除它

00:18:10.170 --> 00:18:14.610
删除一个发布和类似的东西

00:18:11.940 --> 00:18:16.170
将针对JDK 10完成

00:18:14.610 --> 00:18:19.410
可能会被称为18而不是3或1 

00:18:16.170 --> 00:18:21.320
现在的后续发行中，为什么

00:18:19.410 --> 00:18:23.310
您需要启动设置启动类路径

00:18:21.320 --> 00:18:25.080
好吧，假设我们有两个版本的

00:18:23.310 --> 00:18:26.580
 JDK在这里，还有一个库

00:18:25.080 --> 00:18:28.710
第一个版本有一个foo方法

00:18:26.580 --> 00:18:30.960
需要一倍，然后作为

00:18:28.710 --> 00:18:32.340
在以后的JDK版本中进行优化

00:18:30.960 --> 00:18:33.960
有一个完整的方法需要

00:18:32.340 --> 00:18:35.640
整数，因此完全兼容

00:18:33.960 --> 00:18:38.220
根据我们的兼容性进行更改

00:18:35.640 --> 00:18:40.950
政策，假设我们有客户

00:18:38.220 --> 00:18:44.490
这里使用foo的库，我们

00:18:40.950 --> 00:18:46.440
针对JDK n + 1进行编译，因此

00:18:44.490 --> 00:18:49.980
这两个foo方法是编译器

00:18:46.440 --> 00:18:51.000
要为foo选择1 2 3 4 

00:18:49.980 --> 00:18:52.620
要选择需要

00:18:51.000 --> 00:18:54.450
最具体的食物是整数

00:18:52.620 --> 00:18:58.050
版本，那是什么语言

00:18:54.450 --> 00:18:59.730
指定可以，如果我们

00:18:58.050 --> 00:19:03.270
将针对JDK编译的文件

00:18:59.730 --> 00:19:04.680
加1，然后针对JDK运行它，我们将

00:19:03.270 --> 00:19:07.380
得到一个运行时错误或类似的东西

00:19:04.680 --> 00:19:09.630
这个没有这样的方法错误是什么

00:19:07.380 --> 00:19:10.440
错误的详细信息在这里是

00:19:09.630 --> 00:19:12.600
说

00:19:10.440 --> 00:19:15.120
正在寻找一种需要

00:19:12.600 --> 00:19:17.580
整数，但没有找到一个

00:19:15.120 --> 00:19:18.960
在JDK中找不到一个，因为

00:19:17.580 --> 00:19:21.029
不是只有一种食物方法

00:19:18.960 --> 00:19:22.769
需要一倍，所以这是一种

00:19:21.029 --> 00:19:24.240
人们在您遇到问题时会遇到的问题

00:19:22.769 --> 00:19:28.110
当你不说引导类路径

00:19:24.240 --> 00:19:29.639
交叉编译，所以因为我们仍然有这个

00:19:28.110 --> 00:19:31.590
我们谈论的一个Java C团队问题

00:19:29.639 --> 00:19:33.059
如果您未设置

00:19:31.590 --> 00:19:36.330
年龄较大时引导类路径

00:19:33.059 --> 00:19:38.879
版本我们在jdk 7中做了

00:19:36.330 --> 00:19:40.409
问题仍然存在，我们

00:19:38.879 --> 00:19:41.159
在团队上谈论，我们说

00:19:40.409 --> 00:19:43.139
你知道我们知道什么人

00:19:41.159 --> 00:19:45.330
其实想在这里做他们只是想要的

00:19:43.139 --> 00:19:46.350
交叉编译到旧版本

00:19:45.330 --> 00:19:48.360
为什么我们不让他们这样做

00:19:46.350 --> 00:19:51.480
直接而不需要设置这些

00:19:48.360 --> 00:19:53.610
三个变量，这的确是

00:19:51.480 --> 00:19:56.039
我们现在使用Java C破折号完成了操作- 

00:19:53.610 --> 00:19:57.720
从语义上释放em标志是

00:19:56.039 --> 00:19:59.700
等同于设置源和

00:19:57.720 --> 00:20:02.100
定位到较早的版本以及

00:19:59.700 --> 00:20:03.870
 MU类路径，但是

00:20:02.100 --> 00:20:06.059
有关类路径的信息是

00:20:03.870 --> 00:20:07.710
可用于Java C，因此已发货

00:20:06.059 --> 00:20:10.740
作为JDK的一部分压缩

00:20:07.710 --> 00:20:13.860
时尚，所以您不必管理

00:20:10.740 --> 00:20:15.419
对自己的状态已经不再

00:20:13.860 --> 00:20:17.610
的优点，您不必

00:20:15.419 --> 00:20:20.250
担心管理那些旧的RT jar 

00:20:17.610 --> 00:20:21.809
如果您使用Maven插件，请自行归档

00:20:20.250 --> 00:20:23.700
就像动物的嗅探器

00:20:21.809 --> 00:20:24.750
应避免使用错误的API 

00:20:23.700 --> 00:20:26.669
对此的需求较少

00:20:24.750 --> 00:20:28.769
如果这样做，另一个好处

00:20:26.669 --> 00:20:30.330
跨编译，你也许能够

00:20:28.769 --> 00:20:32.279
利用更新的编译器

00:20:30.330 --> 00:20:34.230
 Java中的惯用语可在中查看其错误修复

00:20:32.279 --> 00:20:36.809
 Java C有时有时

00:20:34.230 --> 00:20:39.000
大型性能改进之一

00:20:36.809 --> 00:20:40.919
我们在Java C和JDK 9中拥有的项目

00:20:39.000 --> 00:20:43.470
被称为分层归因

00:20:40.919 --> 00:20:44.429
在某些情况下有助于加快类型推断

00:20:43.470 --> 00:20:48.019
各种情况

00:20:44.429 --> 00:20:52.379
所以那条陡峭的上升曲线是

00:20:48.019 --> 00:20:54.419
 JDK 8运行时只需几秒钟，您将

00:20:52.379 --> 00:20:55.980
注意这是对数刻度，因此

00:20:54.419 --> 00:20:57.840
对于这些非常缓慢的

00:20:55.980 --> 00:21:00.059
我们正在使用的小型程序

00:20:57.840 --> 00:21:01.889
以一种特殊的方式推断

00:21:00.059 --> 00:21:03.330
对数刻度上的直线是

00:21:01.889 --> 00:21:04.980
基本上是指数增长，所以

00:21:03.330 --> 00:21:07.110
如果你想拥有一个不是很好

00:21:04.980 --> 00:21:08.399
可扩展的编译器环境，因此我们想要

00:21:07.110 --> 00:21:10.289
做其他事情，所以我们重新设计

00:21:08.399 --> 00:21:13.470
推论是如何工作的，我们得到了这些

00:21:10.289 --> 00:21:16.320
底部的线快得多，所以我们

00:21:13.470 --> 00:21:18.450
两者都从Jade Java Sea获得

00:21:16.320 --> 00:21:20.120
 JDK 9，我们得到了那种

00:21:18.450 --> 00:21:22.790
表演使用

00:21:20.120 --> 00:21:24.620
使用--从JDK 9中获取Java Sea 

00:21:22.790 --> 00:21:25.910
发布8，所以如果您的交叉编译为

00:21:24.620 --> 00:21:27.320
 8您将从中受益

00:21:25.910 --> 00:21:30.590
重新设计我们在较新的产品中所做的

00:21:27.320 --> 00:21:34.340
编译器的下一个功能是多

00:21:30.590 --> 00:21:36.350
释放jar文件，这样很不方便

00:21:34.340 --> 00:21:38.090
如果您想打包一个库

00:21:36.350 --> 00:21:39.440
发行一个版本的

00:21:38.090 --> 00:21:41.750
不同版本的库

00:21:39.440 --> 00:21:44.090
 JDK，因此通常您会为

00:21:41.750 --> 00:21:45.890
您计划支持的最早的JDK，然后

00:21:44.090 --> 00:21:47.690
分配它，所以如果你

00:21:45.890 --> 00:21:50.210
实际想使用中的功能

00:21:47.690 --> 00:21:52.280
较新的JDK有点尴尬， 

00:21:50.210 --> 00:21:53.810
我们的观点减缓了

00:21:52.280 --> 00:21:56.210
 JDK的新功能，我们当然

00:21:53.810 --> 00:21:57.590
希望人们使用它们，所以有时您

00:21:56.210 --> 00:21:59.960
可以通过反射来解决

00:21:57.590 --> 00:22:01.700
测试新的api，但这就是

00:21:59.960 --> 00:22:04.160
有点缓慢和尴尬， 

00:22:01.700 --> 00:22:06.470
 9中的模块化功能

00:22:04.160 --> 00:22:08.030
不应使用是如此的api 

00:22:06.470 --> 00:22:09.980
试图使用其中一些而不是

00:22:08.030 --> 00:22:12.080
某种程度上，星型api无法到达或

00:22:09.980 --> 00:22:12.740
很难到达所以这是什么

00:22:12.080 --> 00:22:15.320
替代方案

00:22:12.740 --> 00:22:17.840
这里的替代方案是多版本

00:22:15.320 --> 00:22:19.700
多版本jar文件中的jar文件

00:22:17.840 --> 00:22:22.700
整个区域有一个公共区域

00:22:19.700 --> 00:22:25.430
发行，然后在

00:22:22.700 --> 00:22:30.200
冥想的空气超载或

00:22:25.430 --> 00:22:31.940
提供特定于版本的类文件以

00:22:30.200 --> 00:22:33.320
用于特定的JDK版本，因此

00:22:31.940 --> 00:22:35.750
例如，有一个子目录

00:22:33.320 --> 00:22:37.250
 JDK 9，然后在使用这些文件时

00:22:35.750 --> 00:22:39.500
您在JDK 9上运行而不是

00:22:37.250 --> 00:22:41.570
您将在JDK 8上使用的文件有一些

00:22:39.500 --> 00:22:43.280
与这件事有关的事情，你可以

00:22:41.570 --> 00:22:46.130
你可以创建一个jar文件

00:22:43.280 --> 00:22:48.560
充当JDK 8上的常规旧jar文件

00:22:46.130 --> 00:22:51.590
和更早版本，但充当了新的模块化

00:22:48.560 --> 00:22:53.090
 JDK 9上的jar文件可以通过

00:22:51.590 --> 00:22:56.240
模块信息文档类文件

00:22:53.090 --> 00:22:57.950
在您指定的九个特定区域中可用

00:22:56.240 --> 00:22:59.540
创建这些多版本jar文件

00:22:57.950 --> 00:23:02.650
使用jar命令，我们已经更新

00:22:59.540 --> 00:23:05.690
另一个API是消耗jar文件

00:23:02.650 --> 00:23:08.720
 Java Java C和jar围网程序将变得更加多

00:23:05.690 --> 00:23:10.790
意识到发布有工具支持

00:23:08.720 --> 00:23:13.040
用于创建多个East jar文件，以及

00:23:10.790 --> 00:23:15.880
和Maven已经记录了方法

00:23:13.040 --> 00:23:18.440
 ，最近Trisha酥油发布了一个

00:23:15.880 --> 00:23:20.630
演示代码创建祭坛释放罐

00:23:18.440 --> 00:23:24.100
文件和IntelliJ，以便您可以检查

00:23:20.630 --> 00:23:26.960
局部于工具文档以获取详细信息

00:23:24.100 --> 00:23:29.170
接下来我们开始谈论小

00:23:26.960 --> 00:23:31.730
 JDK 9中进行的语言更改

00:23:29.170 --> 00:23:33.299
在JDK 7中，我们有一个名为

00:23:31.730 --> 00:23:35.100
项目声明，添加

00:23:33.299 --> 00:23:37.559
一打的小语言更改

00:23:35.100 --> 00:23:39.029
平台以及其中的三处变化

00:23:37.559 --> 00:23:41.700
我们有一些清理工作，我们想

00:23:39.029 --> 00:23:45.480
我们无法完成的工作

00:23:41.700 --> 00:23:47.580
 JDK 7的结束，所以这些是最重要的

00:23:45.480 --> 00:23:49.379
三个这里的项目lambda是

00:23:47.580 --> 00:23:50.970
在jdk 8中添加的也有一些小

00:23:49.379 --> 00:23:52.889
清理的物品，所以我们有点像

00:23:50.970 --> 00:23:56.340
一起解决这些问题，并修复JDK中的问题

00:23:52.889 --> 00:23:57.710
 9其中第一个是安全的varargs 

00:23:56.340 --> 00:24:00.419
私有实例方法

00:23:57.710 --> 00:24:02.639
所以回到jdk 5或6，我们可以写

00:24:00.419 --> 00:24:04.019
这样的代码，我们有一个列表列表

00:24:02.639 --> 00:24:07.889
字符串，我们想帮助初始化

00:24:04.019 --> 00:24:10.109
使用数组列表平台的

00:24:07.889 --> 00:24:12.210
上课，所以如果你对自己的话很小心

00:24:10.109 --> 00:24:14.700
您注意到编译器警告

00:24:12.210 --> 00:24:16.259
像这样的警告取消警告

00:24:14.700 --> 00:24:18.059
 var X的通用数组创建

00:24:16.259 --> 00:24:21.269
阵列的参数看到特斯拉的

00:24:18.059 --> 00:24:23.220
方法，这是怎么回事

00:24:21.269 --> 00:24:25.739
 Java语言强制执行警告

00:24:23.220 --> 00:24:27.539
规格，让您知道

00:24:25.739 --> 00:24:29.460
可能正在发生坏事

00:24:27.539 --> 00:24:31.470
不好的东西叫做堆

00:24:29.460 --> 00:24:34.940
可能违反的污染

00:24:31.470 --> 00:24:38.159
 Java的类型约束以及

00:24:34.940 --> 00:24:40.529
数组点的列表方法是恶意的

00:24:38.159 --> 00:24:41.879
并没有正确实施

00:24:40.529 --> 00:24:44.279
造成这种热污染

00:24:41.879 --> 00:24:46.320
但是在这种情况下没有什么不好

00:24:44.279 --> 00:24:48.119
实际发生的已经不是

00:24:46.320 --> 00:24:50.190
听平台不是恶意的

00:24:48.119 --> 00:24:52.350
方法，因此此错误为假阳性

00:24:50.190 --> 00:24:53.700
它没有信息所以没有信息

00:24:52.350 --> 00:24:56.850
警告消息不好

00:24:53.700 --> 00:24:59.820
所以我们在jdk中解决了这个问题

00:24:56.850 --> 00:25:01.889
 7通过添加安全的varargs批注

00:24:59.820 --> 00:25:03.840
类型和安全的varargs批注

00:25:01.889 --> 00:25:06.029
类型可以让您告诉编译器

00:25:03.840 --> 00:25:07.529
您的varargs方法实际上不是

00:25:06.029 --> 00:25:10.139
恶意的，它不应该警告人们

00:25:07.529 --> 00:25:11.970
关于它，所以这同时做两件事

00:25:10.139 --> 00:25:14.009
声明以下内容时删除警告

00:25:11.970 --> 00:25:15.869
大方法，更重要的是

00:25:14.009 --> 00:25:18.239
每次有人打电话时都会删除警告

00:25:15.869 --> 00:25:20.039
 varargs方法，所以我们应用了

00:25:18.239 --> 00:25:21.359
注释为列表和数组的数组

00:25:20.039 --> 00:25:23.789
另一个适当的消息

00:25:21.359 --> 00:25:25.980
平台因为设计

00:25:23.789 --> 00:25:28.859
您可以注释的注释仅

00:25:25.980 --> 00:25:31.379
在here Adhan类中不是接口或

00:25:28.859 --> 00:25:33.869
因此，方法是安全的可变参数

00:25:31.379 --> 00:25:35.940
注释只能在方法上使用

00:25:33.869 --> 00:25:38.190
那不能被覆盖，那是什么样的

00:25:35.940 --> 00:25:42.240
的方法不能被覆盖

00:25:38.190 --> 00:25:43.950
方法静态方法也是构造函数

00:25:42.240 --> 00:25:46.470
从特定的角度来看

00:25:43.950 --> 00:25:47.130
只是非常特殊的静态方法

00:25:46.470 --> 00:25:48.120
还有其他

00:25:47.130 --> 00:25:52.050
不可能的那种消息

00:25:48.120 --> 00:25:55.590
覆盖有私有方法和

00:25:52.050 --> 00:25:57.720
我们忘记了JDK 7中的那些，但是

00:25:55.590 --> 00:26:00.390
现在我们已经更改了

00:25:57.720 --> 00:26:01.860
实施也允许更安全的RS 

00:26:00.390 --> 00:26:04.140
私人方法，如果您有这样的

00:26:01.860 --> 00:26:07.920
现在可以使用注释的方法

00:26:04.140 --> 00:26:10.440
排队我们进行交易的其他下一个变化

00:26:07.920 --> 00:26:13.320
与try with resources语句一起使用

00:26:10.440 --> 00:26:16.020
就像您快速上手一样

00:26:13.320 --> 00:26:18.600
资源正在管理和落后

00:26:16.020 --> 00:26:20.580
编译器创建的场景

00:26:18.600 --> 00:26:22.740
隐式的finally块供您调用

00:26:20.580 --> 00:26:26.100
只要资源关闭

00:26:22.740 --> 00:26:29.100
现在不完全公开

00:26:26.100 --> 00:26:31.530
编译器使用的实际代码有点

00:26:29.100 --> 00:26:33.570
更复杂的是实际

00:26:31.530 --> 00:26:35.550
在这里加糖额外的复杂

00:26:33.570 --> 00:26:36.900
复杂性是为了给更好的例外

00:26:35.550 --> 00:26:38.580
处理，但我们不必担心

00:26:36.900 --> 00:26:43.470
关于这一点，编译器会照顾它

00:26:38.580 --> 00:26:45.180
对我们来说，因此在JDK 7中

00:26:43.470 --> 00:26:46.560
管理必须是一个新鲜的变量

00:26:45.180 --> 00:26:48.210
与部落地球资源相关联

00:26:46.560 --> 00:26:50.520
并非最初的陈述

00:26:48.210 --> 00:26:52.020
建议，但是最初您可以

00:26:50.520 --> 00:26:54.180
使用任何具有正确类型的表达式

00:26:52.020 --> 00:26:55.950
这是自动关闭的，表示已关闭

00:26:54.180 --> 00:26:58.320
方法在那里，但我们发现有一个

00:26:55.950 --> 00:27:00.420
使用这个问题，所以我们说

00:26:58.320 --> 00:27:02.730
将资源R初始化为新的

00:27:00.420 --> 00:27:04.740
资源对象，然后在try内

00:27:02.730 --> 00:27:07.020
阻止，我们提出了不同的观点

00:27:04.740 --> 00:27:08.250
资源对象到此结束

00:27:07.020 --> 00:27:10.440
的尝试块，我们是什么

00:27:08.250 --> 00:27:13.260
应该做哪个对象

00:27:10.440 --> 00:27:14.490
得到它的封闭方法叫我们

00:27:13.260 --> 00:27:16.050
决定我们不想解决

00:27:14.490 --> 00:27:18.290
这个问题和我们决定不的方式

00:27:16.050 --> 00:27:20.730
解决它是需要最终的

00:27:18.290 --> 00:27:23.460
要求将新的最终变量作为一部分

00:27:20.730 --> 00:27:25.470
驱动程序资源声明，但

00:27:23.460 --> 00:27:28.230
这实际上有点严格

00:27:25.470 --> 00:27:30.930
如果我们已经

00:27:28.230 --> 00:27:33.090
知道一些资源变量是

00:27:30.930 --> 00:27:35.520
最终或有效最终我们为什么

00:27:33.090 --> 00:27:37.500
必须声明一个新的新鲜的决赛或

00:27:35.520 --> 00:27:39.660
变量来照顾它

00:27:37.500 --> 00:27:41.460
真的没有理由这样做，那是

00:27:39.660 --> 00:27:44.490
确实是我们现在在JDK中所做的更改

00:27:41.460 --> 00:27:45.810
 9所以如果您已经有决赛

00:27:44.490 --> 00:27:47.250
您不必重新创建变量

00:27:45.810 --> 00:27:48.750
你可以重复使用一个

00:27:47.250 --> 00:27:51.920
因此，它尝试了我们的三个来源

00:27:48.750 --> 00:27:51.920
声明更加简洁

00:27:53.090 --> 00:27:57.390
匿名类中的Dimond是

00:27:55.620 --> 00:28:01.920
我们将要讨论的下一个功能

00:27:57.390 --> 00:28:04.830
回到JDK 7之前，如果您有

00:28:01.920 --> 00:28:07.230
您想要的字符串整数映射列表

00:28:04.830 --> 00:28:08.820
清除变量，然后在

00:28:07.230 --> 00:28:10.980
构造函数调用说ArrayList 

00:28:08.820 --> 00:28:12.900
必须重复的字符串映射列表

00:28:10.980 --> 00:28:14.610
整数，两者都有点

00:28:12.900 --> 00:28:17.040
你可以拥有钻石和

00:28:14.610 --> 00:28:17.520
编译器将推断出这些类型参数

00:28:17.040 --> 00:28:19.860
为了你

00:28:17.520 --> 00:28:21.720
这对于消除

00:28:19.860 --> 00:28:24.420
需要显式构造函数类型

00:28:21.720 --> 00:28:27.270
但是由于不好而引起的争论

00:28:24.420 --> 00:28:29.400
我们必须禁止的最坏情况的交互

00:28:27.270 --> 00:28:33.180
在使用钻石时

00:28:29.400 --> 00:28:35.130
匿名内部类的问题是

00:28:33.180 --> 00:28:36.870
在最坏的情况下，编译器可能

00:28:35.130 --> 00:28:37.260
推断出一种不显眼的东西

00:28:36.870 --> 00:28:39.150
类型

00:28:37.260 --> 00:28:41.220
这是类型之外的类型

00:28:39.150 --> 00:28:43.290
我们可以用作程序员的系统，但

00:28:41.220 --> 00:28:46.140
存在于编译器内部，并且

00:28:43.290 --> 00:28:49.410
问题是如果您有匿名者

00:28:46.140 --> 00:28:50.850
需要一个类文件和部分的类

00:28:49.410 --> 00:28:54.060
类文件中的信息

00:28:50.850 --> 00:28:56.190
需要的是类型参数，如果您

00:28:54.060 --> 00:28:57.660
有一个非明显的类型推断是

00:28:56.190 --> 00:29:00.720
在课堂上可以写的东西之外

00:28:57.660 --> 00:29:02.940
文件，所以不好，在其他情况下

00:29:00.720 --> 00:29:04.560
但是如果您得到D值得注意的类型推断

00:29:02.940 --> 00:29:05.970
我们通常处理的一种普通类型

00:29:04.560 --> 00:29:08.880
可以在

00:29:05.970 --> 00:29:10.680
类文件，所以我们注意到我们必须

00:29:08.880 --> 00:29:13.500
禁止Dimond和匿名类

00:29:10.680 --> 00:29:15.390
七个人一起工作

00:29:13.500 --> 00:29:17.250
当我们完成项目硬币时

00:29:15.390 --> 00:29:20.070
我们说将来可行

00:29:17.250 --> 00:29:21.780
我们可能会在

00:29:20.070 --> 00:29:23.700
当您得到D显着类型和

00:29:21.780 --> 00:29:25.440
您避免了最坏的情况，那就是

00:29:23.700 --> 00:29:27.570
实际上，实际上我们现在所做的

00:29:25.440 --> 00:29:29.640
 JDK 9，只要您不明白

00:29:27.570 --> 00:29:34.080
可以使用钻石的最坏情况

00:29:29.640 --> 00:29:36.240
在JDK 7 a中也具有匿名类

00:29:34.080 --> 00:29:37.950
钻石让我们摆脱了大约90％ 

00:29:36.240 --> 00:29:40.370
显式构造函数类型

00:29:37.950 --> 00:29:43.020
论点，我们对此感到

00:29:40.370 --> 00:29:45.780
清理我们可以注意到的类型

00:29:43.020 --> 00:29:47.430
解决我们剩下的10％中的大部分

00:29:45.780 --> 00:29:49.410
在使用此功能方面经验丰富

00:29:47.430 --> 00:29:51.330
在JDK代码库中，它让我们摆脱了

00:29:49.410 --> 00:29:55.560
数百个其他显式的

00:29:51.330 --> 00:29:57.630
接下来的代码中的构造函数参数

00:29:55.560 --> 00:29:59.610
两个功能来自lambda项目，因此

00:29:57.630 --> 00:30:03.510
下划线不再是标识符

00:29:59.610 --> 00:30:06.060
在JDK中添加lambda时重新命名

00:30:03.510 --> 00:30:08.700
八个，您可以使用下划线作为

00:30:06.060 --> 00:30:11.550
 Lambda的参数名称是

00:30:08.700 --> 00:30:13.050
避免与某些功能混淆

00:30:11.550 --> 00:30:17.010
来自其他编程语言，例如

00:30:13.050 --> 00:30:18.210
 Scout Scala Java Steve的wunderbar 

00:30:17.010 --> 00:30:20.340
开始注意到，如果你是

00:30:18.210 --> 00:30:22.410
在其他情况下使用下划线

00:30:20.340 --> 00:30:24.390
作为数据文件，您可能无法

00:30:22.410 --> 00:30:26.370
在将来使用它们，现在

00:30:24.390 --> 00:30:30.030
未来已经到来，您不能再使用

00:30:26.370 --> 00:30:34.200
在变量中以下划线作为变量名

00:30:30.030 --> 00:30:36.450
码头k9，所以这不是我们通常的政策

00:30:34.200 --> 00:30:38.310
但是为什么要保持代码编译

00:30:36.450 --> 00:30:40.080
但是我们为什么要进行此更改

00:30:38.310 --> 00:30:43.050
好吧，我们认为有更好的用途

00:30:40.080 --> 00:30:44.700
下划线a的句法不动产

00:30:43.050 --> 00:30:47.190
变量名称下划线

00:30:44.700 --> 00:30:49.740
这项工作正在讨论中

00:30:47.190 --> 00:30:51.600
未来的JEP JEP 3或2剩余的lambda 

00:30:49.740 --> 00:30:55.710
这是琥珀项目之一的一部分

00:30:51.600 --> 00:30:58.130
我们在开放式JDK中正在进行的项目终于

00:30:55.710 --> 00:31:01.200
我们有一个私有接口方法

00:30:58.130 --> 00:31:02.670
在8中，lambda项目的另一部分是

00:31:01.200 --> 00:31:05.520
添加接口的默认方法

00:31:02.670 --> 00:31:07.440
这些是接口上的方法

00:31:05.520 --> 00:31:09.780
有代码，所以它们不是抽象的

00:31:07.440 --> 00:31:12.360
虚拟机之前和之后使用的方法

00:31:09.780 --> 00:31:14.280
级别可以有私人

00:31:12.360 --> 00:31:16.530
 8个接口上的方法是

00:31:14.280 --> 00:31:17.850
但是实现lambda是必需的

00:31:16.530 --> 00:31:22.050
您无法在源代码中做到这一点

00:31:17.850 --> 00:31:24.510
语言，现在在Java 9中，您可以

00:31:22.050 --> 00:31:26.310
可以同时使用两个私有静态方法

00:31:24.510 --> 00:31:28.710
您的界面以及私人界面

00:31:26.310 --> 00:31:30.420
实例方法，所以您要做什么

00:31:28.710 --> 00:31:32.370
这些方法，您可以将它们用作帮助者

00:31:30.420 --> 00:31:33.840
其他默认方法的方法

00:31:32.370 --> 00:31:35.730
有任何公共方法的接口

00:31:33.840 --> 00:31:37.170
这再次非常非常方便

00:31:35.730 --> 00:31:38.310
一旦您开始添加默认值

00:31:37.170 --> 00:31:42.120
您自己的方法

00:31:38.310 --> 00:31:44.460
介面，所以您可能在

00:31:42.120 --> 00:31:46.140
关于新的六个月的主题演讲

00:31:44.460 --> 00:31:48.690
释放饮食节奏

00:31:46.140 --> 00:31:50.130
过渡到JDK之一

00:31:48.690 --> 00:31:51.510
我们认为将从中受益

00:31:50.130 --> 00:31:54.180
释放节奏是这样的

00:31:51.510 --> 00:31:56.130
较小的语言更改，我们提供了更多

00:31:54.180 --> 00:31:58.260
很快，他们将不会被备份

00:31:56.130 --> 00:31:59.460
在我改变之前的大我背后

00:31:58.260 --> 00:32:01.680
我们期待着得到

00:31:59.460 --> 00:32:05.070
这类小语言清理

00:32:01.680 --> 00:32:06.840
可供开发人员尽快使用

00:32:05.070 --> 00:32:10.020
我们对语言进行的数字更改

00:32:06.840 --> 00:32:12.620
与弃用有关

00:32:10.020 --> 00:32:16.080
那是折旧和进口像

00:32:12.620 --> 00:32:17.520
任何已经存在的旧代码库

00:32:16.080 --> 00:32:19.320
有时我们有一些技术

00:32:17.520 --> 00:32:21.150
 JDK中的债务

00:32:19.320 --> 00:32:22.980
在过去的几年中，我们有几个

00:32:21.150 --> 00:32:25.290
百次弃用警告

00:32:22.980 --> 00:32:26.850
 JDK本身的构建现在这些

00:32:25.290 --> 00:32:29.490
警告再次由

00:32:26.850 --> 00:32:30.930
语言规范，其中有三个

00:32:29.490 --> 00:32:32.790
解决这些折旧的方法

00:32:30.930 --> 00:32:35.070
警告，您可以删除对

00:32:32.790 --> 00:32:37.200
不推荐使用的元素，但

00:32:35.070 --> 00:32:39.660
你不能总是那样做

00:32:37.200 --> 00:32:41.640
将不推荐使用的注释传播到

00:32:39.660 --> 00:32:43.020
青年网站不是很好

00:32:41.640 --> 00:32:45.390
要么是因为现在您正在赚更多

00:32:43.020 --> 00:32:47.250
您的代码已弃用，因此如果您无法执行

00:32:45.390 --> 00:32:49.260
那些你可以压制

00:32:47.250 --> 00:32:53.220
使编译器不知道的警告

00:32:49.260 --> 00:32:56.850
再次警告您，让我们说

00:32:53.220 --> 00:32:58.890
您在JDK 5上拥有客户端库

00:32:56.850 --> 00:33:03.480
到8 

00:32:58.890 --> 00:33:04.740
您编译的JDK中不推荐使用的类型

00:33:03.480 --> 00:33:07.260
这，你得到你的重复

00:33:04.740 --> 00:33:09.720
警告，所以我认为没有问题

00:33:07.260 --> 00:33:12.360
继续使用这种类型，所以我就把

00:33:09.720 --> 00:33:14.280
禁止警告注释的权利

00:33:12.360 --> 00:33:15.030
在全班最高，这将

00:33:14.280 --> 00:33:18.150
照顾好一切

00:33:15.030 --> 00:33:19.290
现在不幸的是，如果您运行

00:33:18.150 --> 00:33:21.180
再次编译，您仍然会注意到

00:33:19.290 --> 00:33:23.580
有一个过时的早晨，那是什么

00:33:21.180 --> 00:33:26.070
在这里继续警告您

00:33:23.580 --> 00:33:27.390
现在不是来自任何代码

00:33:26.070 --> 00:33:31.010
类实际上是从导入

00:33:27.390 --> 00:33:33.150
顶部的声明，这是

00:33:31.010 --> 00:33:35.250
由Java语言授权

00:33:33.150 --> 00:33:36.810
您可能会说的规范是

00:33:35.250 --> 00:33:38.700
没问题，我只用另一个

00:33:36.810 --> 00:33:40.260
禁止显示警告注释

00:33:38.700 --> 00:33:42.180
在语法上你也不起作用

00:33:40.260 --> 00:33:43.710
你不能那样做

00:33:42.180 --> 00:33:46.290
警告可能非常彻底而且很好

00:33:43.710 --> 00:33:48.270
意图如果真的全部都没有帮助

00:33:46.290 --> 00:33:50.570
该用途的所有其他用途

00:33:48.270 --> 00:33:53.790
不推荐使用的类型可以由

00:33:50.570 --> 00:33:55.230
禁止显示警告注释

00:33:53.790 --> 00:33:57.270
有点傻逼你去做某事

00:33:55.230 --> 00:33:59.220
例如使用

00:33:57.270 --> 00:34:01.320
不推荐使用的类型，只是为了避免

00:33:59.220 --> 00:34:03.480
这个警告，所以我们认为这是一个

00:34:01.320 --> 00:34:05.370
一点点不必要，我们已经

00:34:03.480 --> 00:34:08.280
将语言规范更新为

00:34:05.370 --> 00:34:10.410
不需要中的弃用警告

00:34:08.280 --> 00:34:12.360
这个位置，因为这个

00:34:10.410 --> 00:34:13.860
语言更改现在很容易处理

00:34:12.360 --> 00:34:15.870
清除弃用的代码库

00:34:13.860 --> 00:34:17.520
警告，我们有存在证明

00:34:15.870 --> 00:34:19.380
通过清除基于Java的

00:34:17.520 --> 00:34:21.360
模块和Java桌面模块

00:34:19.380 --> 00:34:23.820
在JDK的其他模块中

00:34:21.360 --> 00:34:25.080
弃用警告，所以如果您有这样的警告

00:34:23.820 --> 00:34:26.370
您自己的代码库中的警告

00:34:25.080 --> 00:34:29.760
鼓励您调查一下并尝试

00:34:26.370 --> 00:34:30.720
尽力控制他们

00:34:29.760 --> 00:34:32.110
还有更多要说的

00:34:30.720 --> 00:34:33.700
过时了

00:34:32.110 --> 00:34:36.010
这是关于弃用的一些困惑

00:34:33.700 --> 00:34:37.690
这是什么意思？ 

00:34:36.010 --> 00:34:39.400
因为它是有害的，不建议使用

00:34:37.690 --> 00:34:40.750
因为它要消失了，如果

00:34:39.400 --> 00:34:42.310
已过时，因为它进展顺利

00:34:40.750 --> 00:34:44.470
我不是吗JDK家伙删除了东西

00:34:42.310 --> 00:34:46.630
但我们想提供更多

00:34:44.470 --> 00:34:48.820
在这种情况下的信息，我们做到了

00:34:46.630 --> 00:34:50.650
通过增强信息

00:34:48.820 --> 00:34:53.170
在弃用注释中可用

00:34:50.650 --> 00:34:55.270
键入添加了两种新方法

00:34:53.170 --> 00:34:57.790
这些是删除predicate， 

00:34:55.270 --> 00:35:00.070
默认为false，所以如果有

00:34:57.790 --> 00:35:02.680
弃用移除true表示

00:35:00.070 --> 00:35:04.930
在一些相对较近的平台上

00:35:02.680 --> 00:35:07.480
发布我们计划将其删除

00:35:04.930 --> 00:35:09.340
可以为之后的版本添加字符串

00:35:07.480 --> 00:35:11.830
最初不推荐使用的东西

00:35:09.340 --> 00:35:14.290
我们更新了弃用

00:35:11.830 --> 00:35:16.600
核心平台中的注释具有

00:35:14.290 --> 00:35:19.330
这用于删除信息及其

00:35:16.600 --> 00:35:22.510
支持语言更新

00:35:19.330 --> 00:35:24.610
规范java c和java talk也

00:35:22.510 --> 00:35:26.950
有一个新的静态分析工具

00:35:24.610 --> 00:35:29.230
 JDK称为J更深层扫描

00:35:26.950 --> 00:35:31.090
分析类文件和rar文件以获取

00:35:29.230 --> 00:35:33.040
在api中已弃用的api的使用

00:35:31.090 --> 00:35:35.050
 JDK，所以我们有这些

00:35:33.040 --> 00:35:37.780
弃用，包括去除

00:35:35.050 --> 00:35:39.490
弃用，所以您不必

00:35:37.780 --> 00:35:42.190
重新编译代码以找出答案

00:35:39.490 --> 00:35:43.810
但是如果您的jar文件受到

00:35:42.190 --> 00:35:45.550
它可以运行j更深的扫描

00:35:43.810 --> 00:35:49.090
而是您的jar文件，您可以找到

00:35:45.550 --> 00:35:50.680
知道接下来会发生什么

00:35:49.090 --> 00:35:53.980
关于一些库更新

00:35:50.680 --> 00:35:56.680
首先在这些发行中

00:35:53.980 --> 00:35:59.110
是新版本的字符串一个点

00:35:56.680 --> 00:36:03.190
在1.8和1.7中等等

00:35:59.110 --> 00:36:04.930
离开，所以如果您在新版本上运行版本

00:36:03.190 --> 00:36:07.450
 JDK 9的下载，它只会说

00:36:04.930 --> 00:36:10.840
这是版本9，您知道版本9 

00:36:07.450 --> 00:36:13.180
 + 1 81虽然不太习惯

00:36:10.840 --> 00:36:15.370
因为版本方案可能

00:36:13.180 --> 00:36:18.280
再次更改而不是JDK 10，我们可能

00:36:15.370 --> 00:36:20.650
有18.3，也许是X或JDK 

00:36:18.280 --> 00:36:22.570
我们将在未来一次看到

00:36:20.650 --> 00:36:24.850
最终名称是，但我们不会用1点

00:36:22.570 --> 00:36:26.620
不会再回来的，所以如果你有

00:36:24.850 --> 00:36:30.730
检查它的工具

00:36:26.620 --> 00:36:32.890
如果您使用Java与之交谈，则需要更新

00:36:30.730 --> 00:36:34.780
本机操作系统进程中有一些

00:36:32.890 --> 00:36:36.700
其他API元素来控制那些

00:36:34.780 --> 00:36:40.900
更直接地包括获取pid' 

00:36:36.700 --> 00:36:43.870
一些有趣的功能

00:36:40.900 --> 00:36:45.880
琴弦中的第一个是紧凑的

00:36:43.870 --> 00:36:48.190
字符串在哪里

00:36:45.880 --> 00:36:50.710
如果您的用户没有任何用户干预

00:36:48.190 --> 00:36:54.070
字符串不需要任何高

00:36:50.710 --> 00:36:56.290
个字节为非零，它将使用一个字节

00:36:54.070 --> 00:36:59.110
每个字符表示相对

00:36:56.290 --> 00:37:01.780
到老一关一车

00:36:59.110 --> 00:37:04.750
如果你有代表性的话

00:37:01.780 --> 00:37:08.230
需要使用两个高字节

00:37:04.750 --> 00:37:09.610
字节代替，这样可以给你一个

00:37:08.230 --> 00:37:11.320
更好的内存使用

00:37:09.610 --> 00:37:12.910
应用程序，尤其是使用

00:37:11.320 --> 00:37:14.680
字符串，您不必更新

00:37:12.910 --> 00:37:17.860
您的应用程序采用

00:37:14.680 --> 00:37:19.870
第二个功能的优势

00:37:17.860 --> 00:37:22.000
销毁成五个字符串串联

00:37:19.870 --> 00:37:26.020
是该功能的一个很好的例子

00:37:22.000 --> 00:37:29.020
跨所有VM的语言

00:37:26.020 --> 00:37:31.240
像Java这样的编译器看到了

00:37:29.020 --> 00:37:32.890
 Java中非常常见的操作

00:37:31.240 --> 00:37:35.380
将字符串连接在一起的平台

00:37:32.890 --> 00:37:38.530
 Java C碰巧通常会这样做

00:37:35.380 --> 00:37:41.890
字符串生成器调用，然后虚拟机具有

00:37:38.530 --> 00:37:43.330
注意Java所使用的这个惯用法

00:37:41.890 --> 00:37:45.820
其他编译器和尝试

00:37:43.330 --> 00:37:49.030
相应地进行优化，因此

00:37:45.820 --> 00:37:51.490
如此常见的操作而不是新的

00:37:49.030 --> 00:37:54.760
稳定的入口点是用Java创建的

00:37:51.490 --> 00:37:57.190
说谎调用和目标用户

00:37:54.760 --> 00:38:00.450
这个API不是程序员，而是

00:37:57.190 --> 00:38:02.710
 Java C之类的编译器，因此

00:38:00.450 --> 00:38:04.780
编译器可以采取的直接方式

00:38:02.710 --> 00:38:06.970
与之沟通的优势

00:38:04.780 --> 00:38:09.070
虚拟机，让虚拟机轻松拥有

00:38:06.970 --> 00:38:11.650
知道代码的语义，并且

00:38:09.070 --> 00:38:13.600
结果生成更快的代码，因此

00:38:11.650 --> 00:38:16.980
有效地添加了新的JVM功能

00:38:13.600 --> 00:38:19.150
无需定义新的自行车代码

00:38:16.980 --> 00:38:22.210
有许多更新

00:38:19.150 --> 00:38:24.400
安全库一般

00:38:22.210 --> 00:38:25.660
希望JDK成为安全策略的人

00:38:24.400 --> 00:38:27.850
开箱即用

00:38:25.660 --> 00:38:29.380
我的意思是谁想限制损坏或

00:38:27.850 --> 00:38:32.560
弱密码算法和

00:38:29.380 --> 00:38:34.240
如今，作为密码学家的协议成为

00:38:32.560 --> 00:38:36.370
更聪明，计算机变得更快

00:38:34.240 --> 00:38:39.730
哪些算法较弱

00:38:36.370 --> 00:38:42.420
变化，因此甲骨文发布了一个加密货币

00:38:39.730 --> 00:38:45.940
我们宣布的JDK路线图

00:38:42.420 --> 00:38:48.130
提前某些算法

00:38:45.940 --> 00:38:50.230
和协议将被弃用或

00:38:48.130 --> 00:38:52.960
由于以下原因而从默认设置中删除

00:38:50.230 --> 00:38:56.529
这些原因是文件

00:38:52.960 --> 00:38:59.000
确实随着情况的变化而更新

00:38:56.529 --> 00:39:02.509
如果您在

00:38:59.000 --> 00:39:05.089
安全API的安全性由9 

00:39:02.509 --> 00:39:07.819
默认策略默认密钥this 

00:39:05.089 --> 00:39:09.410
 RSA增加了，等等

00:39:07.819 --> 00:39:11.150
密钥较弱的证书为否

00:39:09.410 --> 00:39:12.650
默认情况下不再接受

00:39:11.150 --> 00:39:14.599
您可以用来进行一些系统设置

00:39:12.650 --> 00:39:17.059
仍然接受那些证书

00:39:14.599 --> 00:39:19.609
如果您需要他们，我的同事肖恩

00:39:17.059 --> 00:39:21.859
 Mullan发表了有关制作JDK的演讲

00:39:19.609 --> 00:39:23.329
更安全，涵盖了JDK 9 

00:39:21.859 --> 00:39:25.309
安全生活功能更详细

00:39:23.329 --> 00:39:29.930
该演讲的视频已经

00:39:25.309 --> 00:39:32.539
从会议开始还有

00:39:29.930 --> 00:39:34.819
客户端库和FX的更新

00:39:32.539 --> 00:39:38.119
像其他版本一样

00:39:34.819 --> 00:39:43.759
 JDK FX代码库最模块化

00:39:38.119 --> 00:39:46.789
他们是对图形支持的更新

00:39:43.759 --> 00:39:50.509
各种方式各不相同

00:39:46.789 --> 00:39:53.539
投影马林图形渲染

00:39:50.509 --> 00:39:56.240
取代了以前的双鱼座和导管

00:39:53.539 --> 00:39:58.009
渲染器删除了其中一个主要

00:39:56.240 --> 00:40:01.910
剩余的行为差异

00:39:58.009 --> 00:40:04.269
 Oracle JDK并打开JDK，所以现在就在那里

00:40:01.910 --> 00:40:05.900
知道JK正在使用相同的

00:40:04.269 --> 00:40:09.019
两者中的实现代码

00:40:05.900 --> 00:40:11.660
情况和摄影师的情况

00:40:09.019 --> 00:40:14.029
谁也使用过Java，现在有支持

00:40:11.660 --> 00:40:18.589
用于TIFF图像，包括exif 

00:40:14.029 --> 00:40:20.450
元数据有很多话题

00:40:18.589 --> 00:40:25.579
关于JavaOne上的客户端库

00:40:20.450 --> 00:40:27.759
您可以在此处看到其中列出的一些

00:40:25.579 --> 00:40:30.259
其他图书馆也一样

00:40:27.759 --> 00:40:31.940
首先是便利工厂

00:40:30.259 --> 00:40:34.009
方法，你有多少次

00:40:31.940 --> 00:40:36.559
最后写这样的代码

00:40:34.009 --> 00:40:38.569
您想要一组不可修改的

00:40:36.559 --> 00:40:40.940
字符串，所以你今天要做的是

00:40:38.569 --> 00:40:44.029
你知道你已经设置好一半了吗？ 

00:40:40.940 --> 00:40:46.339
添加添加，然后您有集合

00:40:44.029 --> 00:40:48.349
设置一些不可修改的包装器

00:40:46.339 --> 00:40:50.420
冗长的操作简单，所以

00:40:48.349 --> 00:40:52.099
你可以做的其他事情就是

00:40:50.420 --> 00:40:54.079
这样的代码，而不是你

00:40:52.099 --> 00:40:57.289
使用数组点初始化哈希集

00:40:54.079 --> 00:40:59.690
作为列表，然后将其包装

00:40:57.289 --> 00:41:02.059
还有些长，还有一倍

00:40:59.690 --> 00:41:05.359
支持IAM，我们什至不会显示

00:41:02.059 --> 00:41:08.119
一些人使用的，但是你不

00:41:05.359 --> 00:41:09.470
现在必须在jdk 9中再做一次

00:41:08.119 --> 00:41:13.220
可以写这个

00:41:09.470 --> 00:41:16.040
将其关闭，然后您想要

00:41:13.220 --> 00:41:20.329
将集合初始化为以及您得到什么

00:41:16.040 --> 00:41:24.200
这是一组不可修改的

00:41:20.329 --> 00:41:26.690
字符串，因此支持该惯用法

00:41:24.200 --> 00:41:28.280
设置地图中的列表，它近似

00:41:26.690 --> 00:41:30.200
收集功能

00:41:28.280 --> 00:41:31.880
收集小规矩

00:41:30.200 --> 00:41:33.890
规则是我们看过的功能之一

00:41:31.880 --> 00:41:39.380
在项目硬币和JDK 7，但我们

00:41:33.890 --> 00:41:40.910
没时间做这是一个好习惯

00:41:39.380 --> 00:41:42.530
获得大部分功能的方法

00:41:40.910 --> 00:41:45.859
复杂度的一小部分

00:41:42.530 --> 00:41:47.630
现在我们提到的平台

00:41:45.859 --> 00:41:50.210
散列该思想迭代顺序并

00:41:47.630 --> 00:41:52.790
人们在不知不觉中依靠这些

00:41:50.210 --> 00:41:55.579
新的收藏将不鼓励

00:41:52.790 --> 00:41:58.220
具有随机的迭代顺序集

00:41:55.579 --> 00:41:59.329
多套地图不在清单中，所以每一个

00:41:58.220 --> 00:42:00.530
创建这些内容时，您将获得一个

00:41:59.329 --> 00:42:01.910
不同的迭代顺序

00:42:00.530 --> 00:42:03.859
使其更难以依靠

00:42:01.910 --> 00:42:06.530
当您在的时候，迭代顺序

00:42:03.859 --> 00:42:08.569
使用它们并了解更多信息

00:42:06.530 --> 00:42:13.040
斯图尔特·马克思同事发表了有关

00:42:08.569 --> 00:42:15.440
如果您今天早上有此功能， 

00:42:13.040 --> 00:42:17.720
使用Java util对象进行通用

00:42:15.440 --> 00:42:19.220
我们确实添加了一些方法

00:42:17.720 --> 00:42:22.339
还有一些其他的null 

00:42:19.220 --> 00:42:24.290
检入索引检查方法一些

00:42:22.339 --> 00:42:27.829
其中有来自

00:42:24.290 --> 00:42:30.319
 VM我感兴趣的一些零散

00:42:27.829 --> 00:42:32.420
数学，所以我们有保险丝乘加

00:42:30.319 --> 00:42:34.339
方法添加它在平台上是

00:42:32.420 --> 00:42:36.589
越来越多的硬件指令

00:42:34.339 --> 00:42:38.359
越来越多的它可以让你做

00:42:36.589 --> 00:42:41.030
仅有两个浮点运算

00:42:38.359 --> 00:42:43.310
一个舍入错误，这对

00:42:41.030 --> 00:42:45.500
一些数字技巧，这又有

00:42:43.310 --> 00:42:48.890
许多平台上的硬件支持

00:42:45.500 --> 00:42:50.930
我们也有内在的

00:42:48.890 --> 00:42:52.640
一些喜欢的数组比较

00:42:50.930 --> 00:42:55.640
图形阵列也已经

00:42:52.640 --> 00:42:57.680
固有ID以及您是否有兴趣

00:42:55.640 --> 00:42:59.300
像var handles这样的东西

00:42:57.680 --> 00:43:02.150
并发编程常见

00:42:59.300 --> 00:43:03.560
使用像C ++ Atomics这样的东西

00:43:02.150 --> 00:43:05.810
也被添加到平台中

00:43:03.560 --> 00:43:08.750
我的同事保罗·桑托斯（Paul Santos）发表了演讲

00:43:05.810 --> 00:43:12.200
关于会议上的JVM LS 

00:43:08.750 --> 00:43:14.510
 2015年的会议还有其他

00:43:12.200 --> 00:43:16.040
关于JDK 9的调查

00:43:14.510 --> 00:43:17.810
会议，如果你想听其他

00:43:16.040 --> 00:43:20.450
人们对什么才是好事的看法

00:43:17.810 --> 00:43:21.990
这些JDK 9的第一个隐藏了

00:43:20.450 --> 00:43:24.089
 gems专注于VM 

00:43:21.990 --> 00:43:25.859
平台的性能方面

00:43:24.089 --> 00:43:26.960
该视频也在线播放

00:43:25.859 --> 00:43:30.900
已经

00:43:26.960 --> 00:43:32.430
所以总而言之，JDK 9很大

00:43:30.900 --> 00:43:35.130
发布，我们做了一些基本

00:43:32.430 --> 00:43:36.420
开发随着模块化而变化，但是

00:43:35.130 --> 00:43:38.880
更改不限于

00:43:36.420 --> 00:43:40.109
模块化我们也完成了长期计划

00:43:38.880 --> 00:43:44.130
语言的改进来自

00:43:40.109 --> 00:43:45.630
在lambda中投影硬币，如果您

00:43:44.130 --> 00:43:47.460
有兴趣跟随未来

00:43:45.630 --> 00:43:50.520
您可以在开放的JDK中做到这一点

00:43:47.460 --> 00:43:53.550
您可以将JDK 9位下载到

00:43:50.520 --> 00:44:08.790
现在尝试一下，我想我有

00:43:53.550 --> 00:44:10.619
时间是一两个问题吧

00:44:08.790 --> 00:44:12.420
问题是--发布如何

00:44:10.619 --> 00:44:15.480
标志与-来源和遮罩互动

00:44:12.420 --> 00:44:17.520
目标，答案是Java C提供了一个

00:44:15.480 --> 00:44:18.810
如果您尝试同时执行这两个操作，则会出错

00:44:17.520 --> 00:44:20.640
做一个或另一个你必须

00:44:18.810 --> 00:44:23.640
做--释放照顾的地方

00:44:20.640 --> 00:44:28.500
一切，或者您可以使用源和

00:44:23.640 --> 00:44:32.280
目标标志明确地将工具

00:44:28.500 --> 00:44:33.300
必须改变支持，是的，所有

00:44:32.280 --> 00:44:34.210
好吧，我想我说谢谢

00:44:33.300 --> 00:44:39.329
今天来你

00:44:34.210 --> 00:44:39.329
 [掌声] 

