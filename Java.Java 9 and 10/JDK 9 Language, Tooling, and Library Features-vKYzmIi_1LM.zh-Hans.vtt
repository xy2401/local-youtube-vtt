WEBVTT
Kind: captions
Language: zh-Hans

00:00:05.720 --> 00:00:11.639
你好，谢谢你来到这里

00:00:08.370 --> 00:00:14.250
早上我叫乔·达西，我在这里工作

00:00:11.639 --> 00:00:16.800
 Oracle的Java平台小组，我将成为

00:00:14.250 --> 00:00:21.029
今天谈论JDK 9语言

00:00:16.800 --> 00:00:23.250
工具和库功能，如果我们不这样做

00:00:21.029 --> 00:00:24.930
最后回答您的问题，或者

00:00:23.250 --> 00:00:27.779
您正在观看有关流媒体的演讲

00:00:24.930 --> 00:00:30.029
您可以在以下标签发布问题标签： 

00:00:27.779 --> 00:00:34.110
第一张幻灯片在这里得到9郎的

00:00:30.029 --> 00:00:36.330
工具库，这是非常重要的

00:00:34.110 --> 00:00:38.100
他们想要的甲骨文律师的幻灯片

00:00:36.330 --> 00:00:40.710
你要确保不要放太多

00:00:38.100 --> 00:00:44.370
相信我在此期间必须说的话

00:00:40.710 --> 00:00:45.930
在这次谈话中，这是安全港

00:00:44.370 --> 00:00:47.339
幻灯片，我必须说，如果你是

00:00:45.930 --> 00:00:49.110
对安全港感兴趣

00:00:47.339 --> 00:00:52.199
湾区许多其他安全港

00:00:49.110 --> 00:00:53.370
或您来拜访，所以特别是如果

00:00:52.199 --> 00:00:54.449
这是你第一次来

00:00:53.370 --> 00:00:58.110
一定要检查其中一些

00:00:54.449 --> 00:01:00.479
该地区的安全港快速调查

00:00:58.110 --> 00:01:03.239
现在正在使用哪个JDK 9版本

00:01:00.479 --> 00:01:05.129
生产展示之手JDK九

00:01:03.239 --> 00:01:07.979
抢先体验哪个最先进的挖锯

00:01:05.129 --> 00:01:10.619
一些人使用那很好

00:01:07.979 --> 00:01:12.990
关于其他JDK 9构建通常的

00:01:10.619 --> 00:01:14.820
最好将这些放在您的CI中

00:01:12.990 --> 00:01:16.939
系统现在看看您的

00:01:14.820 --> 00:01:20.340
产品可与即将推出的产品一起使用

00:01:16.939 --> 00:01:24.140
 JDK 8很好，很高兴看到强大

00:01:20.340 --> 00:01:30.090
通过JDK 8人还在7啊

00:01:24.140 --> 00:01:33.659
可能是15％到20％左右6 

00:01:30.090 --> 00:01:36.149
 hand 4 6我现在承认是谁在5或

00:01:33.659 --> 00:01:38.939
老年人，好吧，我们有些勇敢

00:01:36.149 --> 00:01:40.679
灵魂将在此之后希望

00:01:38.939 --> 00:01:42.390
交谈和其他人，您将拥有更多

00:01:40.679 --> 00:01:44.729
尝试更新某些内容的动机

00:01:42.390 --> 00:01:49.319
从那以后我们开始衰落

00:01:44.729 --> 00:01:52.770
然后是JDK 9的概述

00:01:49.319 --> 00:01:54.630
我明年七月发布的时间表

00:01:52.770 --> 00:01:57.149
提到提早进入账单是

00:01:54.630 --> 00:01:59.100
已经有一个主要的

00:01:57.149 --> 00:02:00.270
租赁开发线和第二条

00:01:59.100 --> 00:02:03.899
一个拼图，还有一点

00:02:00.270 --> 00:02:05.369
对于该产品，JDK 9的更远版本是

00:02:03.899 --> 00:02:07.679
在...的主持下发展

00:02:05.369 --> 00:02:09.000
打开JDK，所以如果您有兴趣

00:02:07.679 --> 00:02:09.360
跟上发展的步伐

00:02:09.000 --> 00:02:12.480
沿

00:02:09.360 --> 00:02:14.459
有邮件列表和项目，所以

00:02:12.480 --> 00:02:16.170
您可以获取源代码

00:02:14.459 --> 00:02:18.750
选项组，如果您需要帮助

00:02:16.170 --> 00:02:19.620
 JDK 9入门

00:02:18.750 --> 00:02:22.170
收养小组

00:02:19.620 --> 00:02:25.170
也是各种开放的延伸

00:02:22.170 --> 00:02:27.209
源项目以使它们运行

00:02:25.170 --> 00:02:29.250
 JDK测试套件及其产品

00:02:27.209 --> 00:02:31.980
 9为我们尽快提供更多反馈

00:02:29.250 --> 00:02:34.040
其他软件产品如何

00:02:31.980 --> 00:02:36.180
我一直与9合作的生态系统

00:02:34.040 --> 00:02:38.760
在接下来的演讲中，我将

00:02:36.180 --> 00:02:41.040
使用术语jep进行jdk增强

00:02:38.760 --> 00:02:44.640
提案这些是用于的文件

00:02:41.040 --> 00:02:48.239
项目跟踪现在，dhoop需要您

00:02:44.640 --> 00:02:50.640
是的-您可以帮助您尝试使用Java 

00:02:48.239 --> 00:02:52.590
 jdk 9的程序，请告诉我们

00:02:50.640 --> 00:02:57.060
怎么样，所以我们可以做任何

00:02:52.590 --> 00:02:59.640
明年GA之前的证明现在为

00:02:57.060 --> 00:03:01.829
您无疑听说过模块化是

00:02:59.640 --> 00:03:05.340
 JDK 9中引入了一项重大功能

00:03:01.829 --> 00:03:07.709
概述项目拼图

00:03:05.340 --> 00:03:10.170
模块化使您可以组合在一起

00:03:07.709 --> 00:03:12.060
单位中的包装组

00:03:10.170 --> 00:03:14.430
比您发现的更强大的封装

00:03:12.060 --> 00:03:16.859
一个jar文件，这是一个非常普遍的

00:03:14.430 --> 00:03:19.200
改变我们要改变的平台

00:03:16.859 --> 00:03:21.060
语言中有新的模块信息

00:03:19.200 --> 00:03:22.650
允许您声明的文件

00:03:21.060 --> 00:03:25.200
模块与其他模块之间的依赖性

00:03:22.650 --> 00:03:28.079
模块的各个方面，这意味着我们

00:03:25.200 --> 00:03:30.299
必须修改Java C命令以

00:03:28.079 --> 00:03:33.410
识别新的源文件，我们也

00:03:30.299 --> 00:03:36.060
必须更新运行时命令Java 

00:03:33.410 --> 00:03:37.560
识别模块，并且

00:03:36.060 --> 00:03:40.200
还更新了核心反射和

00:03:37.560 --> 00:03:43.739
这样的事情，所以我们必须做

00:03:40.200 --> 00:03:45.239
对许多人来说，那些变化

00:03:43.739 --> 00:03:47.340
较大的语言更改，例如lambda 

00:03:45.239 --> 00:03:49.139
也将不得不改变那些，但

00:03:47.340 --> 00:03:50.910
有了模块化，这也是对

00:03:49.139 --> 00:03:52.859
编程模型，所以它实际上是一个

00:03:50.910 --> 00:03:54.780
比许多其他方法更普遍的变化

00:03:52.859 --> 00:04:00.060
我们之前看到的变化

00:03:54.780 --> 00:04:01.980
 Java，因此模块化工作不适合

00:04:00.060 --> 00:04:04.590
拼图拼图团队

00:04:01.980 --> 00:04:07.049
实际上在JavaOne上进行了5个演讲

00:04:04.590 --> 00:04:08.099
他们大多数都给了两次

00:04:07.049 --> 00:04:10.019
他们中的一些人稍后开始

00:04:08.099 --> 00:04:12.000
下午在这个房间里，如果你

00:04:10.019 --> 00:04:14.220
想出去然后再回来

00:04:12.000 --> 00:04:16.709
在上面你会被拼图困扰

00:04:14.220 --> 00:04:20.599
稍后还会有一个黑客会议

00:04:16.709 --> 00:04:24.360
关于我们的一些简短笔记后一周

00:04:20.599 --> 00:04:28.530
 Java的管理主要有以下三个方面

00:04:24.360 --> 00:04:30.840
我们首先要讨论的领域

00:04:28.530 --> 00:04:32.849
需要注意的是，即使没有

00:04:30.840 --> 00:04:33.480
拼图是一个重要的版本

00:04:32.849 --> 00:04:35.400
很大

00:04:33.480 --> 00:04:37.590
只是为了给一些范围，这里是一个快速

00:04:35.400 --> 00:04:39.510
图中的错误计数为8 vs 9，因此

00:04:37.590 --> 00:04:42.630
基本上从一开始就

00:04:39.510 --> 00:04:44.160
 9分钟和8分钟内的错误修复率更高，因此

00:04:42.630 --> 00:04:45.660
甚至是非常重要的版本

00:04:44.160 --> 00:04:48.030
没有拼图，我们会谈

00:04:45.660 --> 00:04:50.970
关于中的非模块化功能

00:04:48.030 --> 00:04:53.040
今天的演讲，您可以将这些分组

00:04:50.970 --> 00:04:55.860
三个基本领域工具的功能

00:04:53.040 --> 00:04:58.230
改进语言库

00:04:55.860 --> 00:04:59.700
功能并不总是与整齐地对齐

00:04:58.230 --> 00:05:01.800
这些部门，所以我们不是

00:04:59.700 --> 00:05:04.160
伸展师怎么说话，如果我们

00:05:01.800 --> 00:05:07.140
最后有一些时间，我们将为您做一个

00:05:04.160 --> 00:05:09.030
因此，现在先简要介绍一下管理

00:05:07.140 --> 00:05:11.460
我们使用的管理方法

00:05:09.030 --> 00:05:13.080
 JDK不是那种管家

00:05:11.460 --> 00:05:16.710
我们由Denethor和《指环王》看到

00:05:13.080 --> 00:05:20.250
电影实际上更加良性

00:05:16.710 --> 00:05:21.990
在Oracle下， 

00:05:20.250 --> 00:05:24.030
 Java平台组一直保持

00:05:21.990 --> 00:05:26.130
 Java充满活力，这是我们始终如一的

00:05:24.030 --> 00:05:28.350
这些年来的优先事项

00:05:26.130 --> 00:05:31.440
影响我们使用的方法

00:05:28.350 --> 00:05:34.020
不断发展的平台，所以写

00:05:31.440 --> 00:05:36.570
在本文档中打开JDK 

00:05:34.020 --> 00:05:39.900
保留Java的开发者指南部分

00:05:36.570 --> 00:05:42.320
在大多数情况下，充满活力

00:05:39.900 --> 00:05:44.370
今天工作的事情明天工作

00:05:42.320 --> 00:05:46.680
当然有例外

00:05:44.370 --> 00:05:48.240
但这是更多情况下的默认设置

00:05:46.680 --> 00:05:49.650
详细说明技术上的含义

00:05:48.240 --> 00:05:51.930
条款是我们要保留

00:05:49.650 --> 00:05:54.060
兼容性和有不同

00:05:51.930 --> 00:05:56.630
您可以谈论的各种兼容性

00:05:54.060 --> 00:05:59.190
首先是二进制兼容性

00:05:56.630 --> 00:06:01.650
他们可以在JLS中获得乐趣

00:05:59.190 --> 00:06:04.260
继续链接的能力，所以当

00:06:01.650 --> 00:06:06.240
 Java运行您的jar文件或

00:06:04.260 --> 00:06:07.280
您仍然可以链接其他工件，并且

00:06:06.240 --> 00:06:10.050
开始吧

00:06:07.280 --> 00:06:12.390
存在源不兼容性

00:06:10.050 --> 00:06:13.980
您的代码仍然可以编译

00:06:12.390 --> 00:06:15.330
编译是否编译为程序

00:06:13.980 --> 00:06:15.750
这意味着一个类文件，这意味着

00:06:15.330 --> 00:06:17.940
一样

00:06:15.750 --> 00:06:19.680
最后有行为

00:06:17.940 --> 00:06:21.840
兼容性您的代码是什么

00:06:19.680 --> 00:06:24.360
实际上是在运行时做的，所以我们想

00:06:21.840 --> 00:06:26.370
请牢记所有这些，这会告知

00:06:24.360 --> 00:06:27.690
我们的语言也在发展

00:06:26.370 --> 00:06:29.310
确保继续认识旧的

00:06:27.690 --> 00:06:30.540
类文件，因此您不必重新创建

00:06:29.310 --> 00:06:32.760
您的罐子到新版本的

00:06:30.540 --> 00:06:35.280
我们要限制案件的平台

00:06:32.760 --> 00:06:38.250
不再冷的地方

00:06:35.280 --> 00:06:39.870
使用新的语言版本，我们

00:06:38.250 --> 00:06:41.550
不想引入沉默的变化

00:06:39.870 --> 00:06:47.280
以及Java C如何为

00:06:41.550 --> 00:06:48.960
大部分，这应该是一个

00:06:47.280 --> 00:06:51.510
三维图，但是你不能

00:06:48.960 --> 00:06:54.060
看到显示器上的轴好了

00:06:51.510 --> 00:06:55.980
但只要想象这是一个网格四源

00:06:54.060 --> 00:06:58.560
像你可能的二进制行为布局

00:06:55.980 --> 00:07:00.630
在物理课上看到这样

00:06:58.560 --> 00:07:01.500
兼容性政策因

00:07:00.630 --> 00:07:03.990
与不同的版本

00:07:01.500 --> 00:07:07.139
 a的实现方式不同，因此如果我们

00:07:03.990 --> 00:07:08.730
每个季度都有发布

00:07:07.139 --> 00:07:10.470
每隔几个出现的安全更新

00:07:08.730 --> 00:07:12.150
几个月我们想拥有一个很小的

00:07:10.470 --> 00:07:14.850
这种兼容性的影响

00:07:12.150 --> 00:07:18.180
释放，所以我们可能会有一些东西

00:07:14.850 --> 00:07:19.500
这仅限于源行为

00:07:18.180 --> 00:07:21.240
飞机，所以我们有一点

00:07:19.500 --> 00:07:23.970
行为兼容性，我们不希望

00:07:21.240 --> 00:07:26.280
利用漏洞修复您的漏洞

00:07:23.970 --> 00:07:29.669
安全问题可能源源不绝

00:07:26.280 --> 00:07:31.260
如果我们存在竞争性来源不兼容

00:07:29.669 --> 00:07:34.230
有更大的更新版本

00:07:31.260 --> 00:07:39.229
像8u 20或@u 40，我们有一点

00:07:34.230 --> 00:07:41.520
更大的回旋余地

00:07:39.229 --> 00:07:42.960
进行行为改变的余地

00:07:41.520 --> 00:07:45.900
因为它是一个大版本，但仍然

00:07:42.960 --> 00:07:48.060
没有太多的源兼容性和

00:07:45.900 --> 00:07:49.260
这两种情况都没有二进制

00:07:48.060 --> 00:07:51.570
我们不需要的兼容性更改

00:07:49.260 --> 00:07:54.600
人们没有联系的能力

00:07:51.570 --> 00:07:58.130
在程序上，如果我们有一个功能

00:07:54.600 --> 00:08:01.919
像JDK 8或特别是JDK 9发行

00:07:58.130 --> 00:08:04.470
我们将有更多的空间

00:08:01.919 --> 00:08:07.890
在某些情况下会有较大的行为改变

00:08:04.470 --> 00:08:09.570
将与

00:08:07.890 --> 00:08:12.240
一个向上的证明，我们将使二进制

00:08:09.570 --> 00:08:16.140
版本8中不兼容的更改

00:08:12.240 --> 00:08:17.940
或9，所以让我们举个例子来帮助

00:08:16.140 --> 00:08:20.520
说明此政策的运作方式

00:08:17.940 --> 00:08:22.830
实践这是针对

00:08:20.520 --> 00:08:25.200
哈希图buff迭代器返回一个

00:08:22.830 --> 00:08:26.640
迭代器，尤其是在这里

00:08:25.200 --> 00:08:27.680
元素没有特别的返回

00:08:26.640 --> 00:08:30.030
订购

00:08:27.680 --> 00:08:31.830
这意味着正确的程序不应该

00:08:30.030 --> 00:08:34.589
依靠元素的顺序

00:08:31.830 --> 00:08:36.810
由迭代器返回，因此

00:08:34.589 --> 00:08:38.610
如果我们想要在

00:08:36.810 --> 00:08:40.950
实施以更改此订单

00:08:38.610 --> 00:08:41.820
规范允许这样做

00:08:40.950 --> 00:08:43.409
通过不同的

00:08:41.820 --> 00:08:44.910
二进制兼容的兼容性

00:08:43.409 --> 00:08:46.800
有相同的方法集

00:08:44.910 --> 00:08:48.540
那里什么都没有改变

00:08:46.800 --> 00:08:49.860
出于相同的原因兼容

00:08:48.540 --> 00:08:52.110
没有任何会影响来源的东西

00:08:49.860 --> 00:08:54.300
代码正在更改，但是这是更改

00:08:52.110 --> 00:08:56.190
在行为兼容性上，我们

00:08:54.300 --> 00:08:58.230
知道人们可以并且确实依靠

00:08:56.190 --> 00:08:59.550
迭代顺序有时甚至是我们的测试

00:08:58.230 --> 00:09:01.080
依靠迭代顺序，那么我们有

00:08:59.550 --> 00:09:02.670
修复测试

00:09:01.080 --> 00:09:04.380
所以这种变化通常

00:09:02.670 --> 00:09:06.870
在任何一种情况下都不允许

00:09:04.380 --> 00:09:09.150
更新版本，但可以并且具有

00:09:06.870 --> 00:09:17.130
是在功能发布（例如8或

00:09:09.150 --> 00:09:19.080
 9，所以当您更新到新的JDK或

00:09:17.130 --> 00:09:21.810
也许因为您已经更新到JDK 

00:09:19.080 --> 00:09:24.360
 8我们使用这种二进制源行为

00:09:21.810 --> 00:09:26.220
兼容性文档

00:09:24.360 --> 00:09:31.640
发行说明和兼容性指南

00:09:26.220 --> 00:09:35.190
复制为JDK版本，所以他

00:09:31.640 --> 00:09:37.740
幻灯片将具有指向该指南的链接

00:09:35.190 --> 00:09:39.240
如果有的话，要注意八点

00:09:37.740 --> 00:09:41.550
更新了8您可能已经运行

00:09:39.240 --> 00:09:44.880
方法的顺序返回

00:09:41.550 --> 00:09:46.950
按类，但方法在JDK 8中已更改，因此

00:09:44.880 --> 00:09:49.070
如果您要进行单元测试

00:09:46.950 --> 00:09:51.630
您必须对其进行更新， 

00:09:49.070 --> 00:09:56.070
在九个时间段的后期会产生一个

00:09:51.630 --> 00:09:57.830
 JDK 9的类似文档，如果这

00:09:56.070 --> 00:10:00.900
关于兼容性的讨论

00:09:57.830 --> 00:10:02.700
感兴趣，你有Ian的演讲

00:10:00.900 --> 00:10:04.620
罗伯逊稍后在会议上谈到

00:10:02.700 --> 00:10:07.110
落后的科学与艺术

00:10:04.620 --> 00:10:08.340
兼容性ian在观众中，但是

00:10:07.110 --> 00:10:11.690
因为这是我们的主题演讲

00:10:08.340 --> 00:10:15.570
不会让他们站起来继续前进

00:10:11.690 --> 00:10:18.960
那么JDK 9与其他有什么不同

00:10:15.570 --> 00:10:21.090
即将发布的模块化产品

00:10:18.960 --> 00:10:24.330
因为这是一个很大的功能，而且

00:10:21.090 --> 00:10:26.900
我们认为有必要保留的一种

00:10:24.330 --> 00:10:29.220
未来21年Java充满活力

00:10:26.900 --> 00:10:31.350
有更大的兼容性

00:10:29.220 --> 00:10:35.430
更大的变化将使

00:10:31.350 --> 00:10:37.380
兼容性比平常更

00:10:35.430 --> 00:10:39.240
行为方面的例子

00:10:37.380 --> 00:10:41.310
兼容性，我们甚至在做出改变

00:10:39.240 --> 00:10:44.550
在文件的布局中，因此没有

00:10:41.310 --> 00:10:47.070
 RT jar和JDK 9，如果有的话

00:10:44.550 --> 00:10:48.690
依赖或假定RT jar的过程

00:10:47.070 --> 00:10:50.970
会在那里，不再了， 

00:10:48.690 --> 00:10:52.590
您必须更新它，所以这是一个

00:10:50.970 --> 00:10:54.660
开始抢先体验的充分理由

00:10:52.590 --> 00:10:56.400
现在建立要注意所有这些

00:10:54.660 --> 00:10:59.100
事情迟早不宜过

00:10:56.400 --> 00:11:02.580
比你跑jt9的时间

00:10:59.100 --> 00:11:04.500
熔断完成的绳索以帮助支撑

00:11:02.580 --> 00:11:07.140
模块化，我们甚至将打破二进制

00:11:04.500 --> 00:11:09.390
在某些情况下的兼容性

00:11:07.140 --> 00:11:12.060
在Java SE 8和

00:11:09.390 --> 00:11:14.880
我们已经在九个实施

00:11:12.060 --> 00:11:17.040
对Java的不幸依赖

00:11:14.880 --> 00:11:19.320
在平台的遥远部分

00:11:17.040 --> 00:11:20.880
 java.util jar是基础的一部分

00:11:19.320 --> 00:11:23.490
模块，所以我们不需要基本模块

00:11:20.880 --> 00:11:24.990
必须依靠豆子

00:11:23.490 --> 00:11:27.000
属性更改侦听器，所以我们摆脱了

00:11:24.990 --> 00:11:29.790
这些方法中的一个不是

00:11:27.000 --> 00:11:31.320
二进制不兼容的更改，但我们感到

00:11:29.790 --> 00:11:35.160
充分的理由

00:11:31.320 --> 00:11:37.470
在九年中，我们还将拥有更多

00:11:35.160 --> 00:11:38.520
九点和九点的肌肉弃用政策

00:11:37.470 --> 00:11:40.350
我们稍后会听到更多

00:11:38.520 --> 00:11:42.690
在谈话中，这是更好的帮助

00:11:40.350 --> 00:11:45.120
管理跨JDK的过渡已结束

00:11:42.690 --> 00:11:47.850
好多年，所以现在我们开始

00:11:45.120 --> 00:11:52.020
首先谈论工具改进

00:11:47.850 --> 00:11:53.820
我要谈论的是J shell in 

00:11:52.020 --> 00:11:55.320
历史观点是一种常见的方式

00:11:53.820 --> 00:11:57.450
用许多其他语言实施

00:11:55.320 --> 00:11:59.850
环境，尤其是嘴唇Lisp 

00:11:57.450 --> 00:12:01.950
传统一直是互动的壳

00:11:59.850 --> 00:12:04.410
称为读取评估打印循环或

00:12:01.950 --> 00:12:06.000
 repple现在有类似的功能

00:12:04.410 --> 00:12:09.120
您可能已经看过其他语言

00:12:06.000 --> 00:12:11.850
您可以使用Ruby和Python等

00:12:09.120 --> 00:12:15.540
 JVM端的JDK Scala groovy等

00:12:11.850 --> 00:12:17.760
等等，那么Java现在有一个

00:12:15.540 --> 00:12:21.480
执行此命令的命令称为J shell 

00:12:17.760 --> 00:12:23.510
和JDK 9，我将做一个简短的预告片演示

00:12:21.480 --> 00:12:23.510
那

00:12:37.450 --> 00:12:41.260
所以Jay的炮弹是喷气式K9的命令

00:12:39.670 --> 00:12:45.790
 bin目录，这样我们就可以得到

00:12:41.260 --> 00:12:48.190
从这里开始就开始了，所以你

00:12:45.790 --> 00:12:50.290
你有壳要做吗

00:12:48.190 --> 00:12:52.240
在外壳中可以获得一些帮助，因此您可以

00:12:50.290 --> 00:12:54.190
如果屏幕是

00:12:52.240 --> 00:13:06.240
通常的大小是帮助输出

00:12:54.190 --> 00:13:09.310
更有用，我现在将使其

00:13:06.240 --> 00:13:13.750
输出应适合屏幕而不是

00:13:09.310 --> 00:13:15.400
即使你以为自己得到了

00:13:13.750 --> 00:13:18.520
有时会提前设置

00:13:15.400 --> 00:13:19.690
你还好吧，我们去吧，那是什么

00:13:18.520 --> 00:13:22.060
您在其中编写的第一个程序

00:13:19.690 --> 00:13:25.510
编程语言你好世界，所以我们

00:13:22.060 --> 00:13:27.280
可以在这里开始输入并点击

00:13:25.510 --> 00:13:29.980
返回，J Shell评估了他的

00:13:27.280 --> 00:13:31.380
表达，所以请注意我们不必

00:13:29.980 --> 00:13:33.970
做任何公共static void主字符串

00:13:31.380 --> 00:13:35.560
你知道我们可以开始的所有事情

00:13:33.970 --> 00:13:38.920
立即输入并获得一些结果

00:13:35.560 --> 00:13:40.960
但这并不是我们的强项

00:13:38.920 --> 00:13:42.520
也可以在J shell中定义变量，因此

00:13:40.960 --> 00:13:44.710
假设我们想找到一个双

00:13:42.520 --> 00:13:48.400
等于pi的两倍的变量tau 

00:13:44.710 --> 00:13:51.610
 pi当然在数学课上，所以

00:13:48.400 --> 00:13:53.290
如果我们执行自动完成，请点击标签J 

00:13:51.610 --> 00:13:56.790
 Shell将在此处列出选择，因此如果

00:13:53.290 --> 00:14:00.190
我们为pi输入P即可完成

00:13:56.790 --> 00:14:02.230
所以大约是圆周率的两倍

00:14:00.190 --> 00:14:02.680
很好，我们可以在J中找到方法

00:14:02.230 --> 00:14:04.330
贝壳

00:14:02.680 --> 00:14:09.790
假设我们要定义一个

00:14:04.330 --> 00:14:17.680
取X和的平方方法

00:14:09.790 --> 00:14:19.540
返回自身的x倍，因此我们将其添加

00:14:17.680 --> 00:14:21.310
到现在我们的环境

00:14:19.540 --> 00:14:23.820
使用评估其他表达式

00:14:21.310 --> 00:14:28.150
这么说，我们想平方

00:14:23.820 --> 00:14:30.040
该数学点符号自动完成

00:14:28.150 --> 00:14:34.180
可以接受，我们可以使用

00:14:30.040 --> 00:14:38.950
我们以前可以做的变量

00:14:34.180 --> 00:14:43.390
通常的命令行编辑，如果我们

00:14:38.950 --> 00:14:44.560
取一个角度的正弦并添加

00:14:43.390 --> 00:14:45.820
角正弦的平方并加

00:14:44.560 --> 00:14:47.560
它到余弦的平方，我们

00:14:45.820 --> 00:14:50.759
应该得到接近一个的东西

00:14:47.560 --> 00:15:00.699
那的确是事实

00:14:50.759 --> 00:15:03.069
回到演示文稿那么多

00:15:00.699 --> 00:15:04.360
如果您是新手，此事

00:15:03.069 --> 00:15:06.310
学生开始使用Java 

00:15:04.360 --> 00:15:07.720
可以减少很多仪式

00:15:06.310 --> 00:15:09.279
立即开始输入您的表情

00:15:07.720 --> 00:15:10.930
而不必避免这种情况

00:15:09.279 --> 00:15:12.160
公共静态无效意味着是否也很好

00:15:10.930 --> 00:15:14.199
长话短说，我们稍后再讲

00:15:12.160 --> 00:15:18.579
在课程中，您不再这样做

00:15:14.199 --> 00:15:19.779
但这不仅是针对

00:15:18.579 --> 00:15:21.220
学生或学习Java的人们

00:15:19.779 --> 00:15:23.529
对经验丰富的人也很有帮助

00:15:21.220 --> 00:15:25.839
开发人员，这是探索的好方法

00:15:23.529 --> 00:15:28.170
使用那些新的9ap眼睛，如果您

00:15:25.839 --> 00:15:31.120
还没有升级到JDK，但是您知道

00:15:28.170 --> 00:15:32.920
新的API是您尚未使用的

00:15:31.120 --> 00:15:34.540
到目前为止，我们发现这在

00:15:32.920 --> 00:15:37.059
 jdk组玩新游戏

00:15:34.540 --> 00:15:38.649
语言功能方面如何J 

00:15:37.059 --> 00:15:41.170
外壳实现它使用了很多

00:15:38.649 --> 00:15:44.319
有趣的技术表明JDK 

00:15:41.170 --> 00:15:46.779
包括用于以编程方式调用的API 

00:15:44.319 --> 00:15:48.579
 Java C和一些调试api以及

00:15:46.779 --> 00:15:50.230
 J Shell Robert领域的首席工程师

00:15:48.579 --> 00:15:53.579
将进行更详细的演讲

00:15:50.230 --> 00:15:53.579
会议稍后将介绍有关J Shell的信息

00:15:54.209 --> 00:16:02.559
 Javadoc这么多年了，Java doc拥有

00:15:59.529 --> 00:16:05.319
几年前一直输出HTML 401 

00:16:02.559 --> 00:16:08.290
有一个新的HTML标准html5 

00:16:05.319 --> 00:16:11.319
出来了，现在Java文档可以输出了

00:16:08.290 --> 00:16:12.730
 html5作为选择加入的基础，即使

00:16:11.319 --> 00:16:15.699
它输出html5没有

00:16:12.730 --> 00:16:17.649
视频默认情况下，因此Java文档

00:16:15.699 --> 00:16:20.160
输出看起来基本上与

00:16:17.649 --> 00:16:23.050
之前的框架样式布局

00:16:20.160 --> 00:16:25.569
有多少人一起工作

00:16:23.050 --> 00:16:27.939
我们在JDK 8中引入的Dockland 

00:16:25.569 --> 00:16:31.629
几只手，也许几下牢骚

00:16:27.939 --> 00:16:34.839
带有不必要的警告或错误

00:16:31.629 --> 00:16:36.670
建立码头区是一个皮棉检查器

00:16:34.839 --> 00:16:40.449
 Java文档的结构和语义

00:16:36.670 --> 00:16:42.220
标记也可以在Java C中使用

00:16:40.449 --> 00:16:44.079
作为Java文档，因此您可以将其添加到

00:16:42.220 --> 00:16:48.129
建立，我们增加了一些额外的

00:16:44.079 --> 00:16:49.360
 JDK 9中的码头棉绒控件

00:16:48.129 --> 00:16:51.129
以前的控件或

00:16:49.360 --> 00:16:52.929
您现在可以限制的错误类别

00:16:51.129 --> 00:16:55.870
 doclet检查特定

00:16:52.929 --> 00:16:58.990
例如在JDK构建中的软件包

00:16:55.870 --> 00:17:03.600
仅记录Java X Java点X 

00:16:58.990 --> 00:17:03.600
在Java X点星程序包中

00:17:05.260 --> 00:17:09.190
这些有特别的码头

00:17:07.450 --> 00:17:11.320
类别，它们的范围从

00:17:09.190 --> 00:17:13.290
 HTML的语义语法

00:17:11.320 --> 00:17:15.760
这样，您就可以像

00:17:13.290 --> 00:17:17.260
在海上或在链接上引用一个

00:17:15.760 --> 00:17:18.880
不存在的方法是

00:17:17.260 --> 00:17:20.200
语义错误，可能会使它们失败

00:17:18.880 --> 00:17:23.650
当时未能通过帐单，因此您可以

00:17:20.200 --> 00:17:26.730
确保保持最新

00:17:23.650 --> 00:17:30.010
观众中有任何doclet作家

00:17:26.730 --> 00:17:31.630
这次不是，所以标准doclet 

00:17:30.010 --> 00:17:34.840
是我们最常用的doclet 

00:17:31.630 --> 00:17:36.430
生成HTML作为Javadoc的一部分

00:17:34.840 --> 00:17:40.450
输出，但您可以编写自己的

00:17:36.430 --> 00:17:43.090
原始doclet api的doclet是

00:17:40.450 --> 00:17:45.250
很老了，我认为这很公平

00:17:43.090 --> 00:17:48.340
会不会不是目前最好的

00:17:45.250 --> 00:17:50.470
 API设计中的实践

00:17:48.340 --> 00:17:52.570
后见之明，我们已经能够

00:17:50.470 --> 00:17:53.830
设计更好的API包括

00:17:52.570 --> 00:17:56.560
更好的语言模型

00:17:53.830 --> 00:18:00.480
可扩展的，我们已经阅读了Java文档

00:17:56.560 --> 00:18:03.310
在新API之上的命令，而不是

00:18:00.480 --> 00:18:06.880
我们很兴奋的另一个Java文档功能

00:18:03.310 --> 00:18:09.690
在JDK 9中是关于搜索的，我将快速进行

00:18:06.880 --> 00:18:09.690
演示

00:18:20.970 --> 00:18:24.840
好的，现在您可以在

00:18:22.860 --> 00:18:27.360
 Javadoc的右上角

00:18:24.840 --> 00:18:31.590
输出是一个搜索框，您可以开始

00:18:27.360 --> 00:18:35.120
输入它，让我们寻找数学

00:18:31.590 --> 00:18:37.850
这显示了它发现的一些东西

00:18:35.120 --> 00:18:41.280
软件包名称中出现数学运算

00:18:37.850 --> 00:18:44.700
所以基础中的Javadoc数学包

00:18:41.280 --> 00:18:47.880
模块以及类型名称，因此Java 

00:18:44.700 --> 00:18:49.970
躺在Java数学中的数学大十进制吗

00:18:47.880 --> 00:18:53.160
也分为两种方法和领域

00:18:49.970 --> 00:18:54.660
更远的地方也可以解决

00:18:53.160 --> 00:18:56.760
模块，因此，如果您要查找

00:18:54.660 --> 00:18:58.590
可以在那里弹出的基本模块

00:18:56.760 --> 00:19:00.660
然后您可以转到Javadoc页面

00:18:58.590 --> 00:19:10.320
对于基本模块，您可以看到

00:19:00.660 --> 00:19:11.430
也可以将该模块打包

00:19:10.320 --> 00:19:12.780
不必将搜索引擎用作

00:19:11.430 --> 00:19:14.690
经常在Java中找到东西让您震惊

00:19:12.780 --> 00:19:17.460
可以直接在Java文档中搜索

00:19:14.690 --> 00:19:20.370
相反，这是一个客户端

00:19:17.460 --> 00:19:22.520
我提到的实现JavaScript 

00:19:20.370 --> 00:19:26.430
它确实索引包的名称

00:19:22.520 --> 00:19:28.950
类型感觉领域和方法

00:19:26.430 --> 00:19:30.600
也可以添加其他索引的方法

00:19:28.950 --> 00:19:34.740
您自己的商品的条款（如果您选择） 

00:19:30.600 --> 00:19:36.450
为此，接下来的两个功能

00:19:34.740 --> 00:19:39.330
关于帮助的设施

00:19:36.450 --> 00:19:41.850
从一个JDK过渡到另一个

00:19:39.330 --> 00:19:44.450
将来都会发布jar文件和

00:19:41.850 --> 00:19:48.570
 Java C破折号发行选项

00:19:44.450 --> 00:19:50.130
首先-许多发行选项

00:19:48.570 --> 00:19:53.370
 Java C已经能够跨越

00:19:50.130 --> 00:19:55.290
用Java编译回旧的JDK 

00:19:53.370 --> 00:19:57.000
 C手册页和其他地方

00:19:55.290 --> 00:19:59.490
您如何执行此操作的说明

00:19:57.000 --> 00:20:02.160
做三件事，你必须设置

00:19:59.490 --> 00:20:04.500
向您想要的目标Roshan采购

00:20:02.160 --> 00:20:07.740
用于您想要的类文件版本

00:20:04.500 --> 00:20:11.970
最后，您必须设置启动类

00:20:07.740 --> 00:20:16.500
 RT rr TR类的路径，如果

00:20:11.970 --> 00:20:18.390
较早的租约完成了我们要做的三件事

00:20:16.500 --> 00:20:21.060
开始致力于限制

00:20:18.390 --> 00:20:21.960
我们支持的旧版本范围

00:20:21.060 --> 00:20:24.600
再加三回

00:20:21.960 --> 00:20:27.840
因此在jdk 9中，特别是9是

00:20:24.600 --> 00:20:29.970
默认情况下，我们支持8和7以及6 

00:20:27.840 --> 00:20:31.710
但不赞成使用6，您会得到一个

00:20:29.970 --> 00:20:33.180
使用时发出警告

00:20:31.710 --> 00:20:34.909
同样，当我们将它们推出到jdk中时

00:20:33.180 --> 00:20:39.590
 10将支持

00:20:34.909 --> 00:20:40.970
 10987，届时7将全部弃用

00:20:39.590 --> 00:20:43.220
对，那你为什么要设置启动

00:20:40.970 --> 00:20:45.830
类路径很好，让我们举个例子

00:20:43.220 --> 00:20:49.399
在jdk n中，我们有一个具有

00:20:45.830 --> 00:20:51.379
食物方法，然后在jdk n加1中

00:20:49.399 --> 00:20:53.809
添加一个int的重载foo 

00:20:51.379 --> 00:20:56.389
根据我们的兼容性政策

00:20:53.809 --> 00:20:58.879
这是一个很好的变化，不应引起

00:20:56.389 --> 00:21:02.389
很多问题，假设我们有

00:20:58.879 --> 00:21:04.909
这里的客户端库具有foo 

00:21:02.389 --> 00:21:07.700
整数参数可以

00:21:04.909 --> 00:21:10.489
好，让我们说我们采用这段代码

00:21:07.700 --> 00:21:14.059
针对这个JDK编译它，但是我们运行

00:21:10.489 --> 00:21:16.849
它针对这个JDK，所以当我们编译时

00:21:14.059 --> 00:21:18.769
针对JDK n加1的编译器C 

00:21:16.849 --> 00:21:20.659
好吧，你有一个foo方法需要一个

00:21:18.769 --> 00:21:24.529
 int，哪个foo方法要执行

00:21:20.659 --> 00:21:26.259
调用班级文件，但一个

00:21:24.529 --> 00:21:28.970
需要一个整数或一一六倍的整数

00:21:26.259 --> 00:21:30.950
它会编译成一个

00:21:28.970 --> 00:21:32.059
接受它是更具体的一个

00:21:30.950 --> 00:21:34.279
这就是语言所需要的

00:21:32.059 --> 00:21:36.830
规格，然后当您运行时

00:21:34.279 --> 00:21:39.739
针对早期JDK的该类文件

00:21:36.830 --> 00:21:41.450
即使您设置了类文件版本

00:21:39.739 --> 00:21:46.009
适当地，您会收到一条消息，例如

00:21:41.450 --> 00:21:48.109
这个没有这样的方法错误，这是什么

00:21:46.009 --> 00:21:49.909
基本上意味着它正在寻找

00:21:48.109 --> 00:21:52.099
愚人事件，没有找到它， 

00:21:49.909 --> 00:21:54.679
没错，因为没有食物

00:21:52.099 --> 00:21:56.029
那里只有双倍的foo 

00:21:54.679 --> 00:21:57.679
这就是为什么您必须设置启动

00:21:56.029 --> 00:22:00.559
避免这种情况的类路径

00:21:57.679 --> 00:22:03.409
情况，但人们不断遇到

00:22:00.559 --> 00:22:04.609
在JIT 7中的JIT中，我们说过

00:22:03.409 --> 00:22:06.559
知道人们继续拥有这个意志

00:22:04.609 --> 00:22:08.239
如果他们使用较旧的则发出警告

00:22:06.559 --> 00:22:10.039
源或目标，而无需设置

00:22:08.239 --> 00:22:12.409
引导类路径，所以我们做到了

00:22:10.039 --> 00:22:13.549
有所帮助，但我们仍然坚持

00:22:12.409 --> 00:22:15.739
有虫子进来

00:22:13.549 --> 00:22:17.119
所以在JDK 9中，我们认为您知道为什么

00:22:15.739 --> 00:22:19.460
我们不只是提供

00:22:17.119 --> 00:22:21.409
特色人物，艺术人物想使用

00:22:19.460 --> 00:22:22.909
这里是交叉编译到

00:22:21.409 --> 00:22:25.489
旧版本，使它更容易实现

00:22:22.909 --> 00:22:28.580
相反，这就是我们所做的

00:22:25.489 --> 00:22:30.320
 --释放关于该标记的注释

00:22:28.580 --> 00:22:32.629
我们正在采用更多新样式

00:22:30.320 --> 00:22:35.509
选项约定--发布或

00:22:32.629 --> 00:22:37.039
建议-释放，所以这是

00:22:35.509 --> 00:22:39.259
语义上等同于全部

00:22:37.039 --> 00:22:42.190
设定来源的三个目标

00:22:39.259 --> 00:22:45.259
以及通往旧RTR的蓝色路线

00:22:42.190 --> 00:22:46.639
现在旧RTR的信息是

00:22:45.259 --> 00:22:48.559
该平台的旧版本是

00:22:46.639 --> 00:22:51.169
作为Java C的一部分存储，它是

00:22:48.559 --> 00:22:55.789
现在是JDK构建，因此它是压缩的

00:22:51.169 --> 00:22:57.649
格式化是另一种好处

00:22:55.789 --> 00:23:00.350
帮助您准备好要使用的模块

00:22:57.649 --> 00:23:01.909
 --版本仅提供

00:23:00.350 --> 00:23:04.190
 api适用于您使用的较旧版本

00:23:01.909 --> 00:23:06.110
应该使用，所以它只会提供

00:23:04.190 --> 00:23:08.240
 Java SE AAP是

00:23:06.110 --> 00:23:11.570
标准以及导出的api是

00:23:08.240 --> 00:23:14.889
在jdk中，它是相同的

00:23:11.570 --> 00:23:17.929
释放源和目标值

00:23:14.889 --> 00:23:20.690
因此，如果您

00:23:17.929 --> 00:23:21.950
勤于使用旧音频

00:23:20.690 --> 00:23:23.330
您无需管理的罐子

00:23:21.950 --> 00:23:26.090
不再需要尝试

00:23:23.330 --> 00:23:28.309
从某个地方来解决这个问题

00:23:26.090 --> 00:23:30.740
问题的人有时会使用Maven 

00:23:28.309 --> 00:23:31.909
像动物嗅探器这样的插件

00:23:30.740 --> 00:23:33.590
有一些时间，所以你应该少

00:23:31.909 --> 00:23:36.559
需要这样做，因为它是正确的

00:23:33.590 --> 00:23:38.840
在Java C中，另一个优势是我们可以

00:23:36.559 --> 00:23:42.080
在新版本中对Java C进行改进

00:23:38.840 --> 00:23:43.369
版本有时会修复错误

00:23:42.080 --> 00:23:45.049
我们正在改善性能，您

00:23:43.369 --> 00:23:47.179
如果您使用，可以利用它们

00:23:45.049 --> 00:23:51.110
 -release标志，我们将看到一个

00:23:47.179 --> 00:23:54.230
这个例子在后来的演讲中如此多

00:23:51.110 --> 00:23:56.149
释放jar文件，以便如果您有

00:23:54.230 --> 00:23:58.970
图书馆很不方便

00:23:56.149 --> 00:24:00.619
不同的jar文件或工件

00:23:58.970 --> 00:24:02.690
对应不同版本的

00:24:00.619 --> 00:24:05.480
您更喜欢拥有一个JDK 

00:24:02.690 --> 00:24:09.499
工件并分配它，因此

00:24:05.480 --> 00:24:10.999
有一些下游影响

00:24:09.499 --> 00:24:12.559
意味着采用新技术的速度较慢

00:24:10.999 --> 00:24:14.720
功能，因为更多的人

00:24:12.559 --> 00:24:18.440
针对原版进行编译

00:24:14.720 --> 00:24:20.179
 jar文件，现在您可以解决一些问题

00:24:18.440 --> 00:24:22.850
这些问题偶尔使用

00:24:20.179 --> 00:24:25.039
反思，就像你想打电话给

00:24:22.850 --> 00:24:26.600
仅在运行时才使用新的固有API 

00:24:25.039 --> 00:24:29.419
您可以在8上进行反光检查

00:24:26.600 --> 00:24:30.919
而所有这些有时会起作用，但是

00:24:29.419 --> 00:24:33.559
这是尴尬的代码，当然

00:24:30.919 --> 00:24:36.379
运行时间比仅使用普通模式慢

00:24:33.559 --> 00:24:38.600
现在调用的另一个功能是

00:24:36.379 --> 00:24:41.210
 9中的模块化支持

00:24:38.600 --> 00:24:42.320
很难访问api的

00:24:41.210 --> 00:24:45.110
你不应该像那样使用

00:24:42.320 --> 00:24:47.749
吸引一些明星AP 

00:24:45.110 --> 00:24:49.940
人们从现在起再次找到帮助，但

00:24:47.749 --> 00:24:51.529
你很好，我有一个不

00:24:49.940 --> 00:24:55.220
打电话给他们，这样您将无法获得

00:24:51.529 --> 00:24:57.590
在9中对他们来说就像

00:24:55.220 --> 00:25:00.379
或者，我们添加了一个多释放罐

00:24:57.590 --> 00:25:02.320
 9中有一个功能

00:25:00.379 --> 00:25:04.600
和以前共享的jar文件一样

00:25:02.320 --> 00:25:06.759
在所有发行版中， 

00:25:04.600 --> 00:25:09.039
放置在meta中的特定于平台的替代

00:25:06.759 --> 00:25:11.700
倒数，所以如果你有基本平局

00:25:09.039 --> 00:25:14.440
文件8可以放9个具体

00:25:11.700 --> 00:25:16.330
覆盖此类的类文件

00:25:14.440 --> 00:25:19.480
版本九中的其他类文件

00:25:16.330 --> 00:25:22.120
目录类似地类似十

00:25:19.480 --> 00:25:24.009
依此类推，您可以使用

00:25:22.120 --> 00:25:25.659
 jar命令使用一些额外的选项和

00:25:24.009 --> 00:25:27.639
平台的其他部分

00:25:25.659 --> 00:25:31.360
读取jar文件（包括绘图文件） 

00:25:27.639 --> 00:25:33.700
 Java util和Java C中的API 

00:25:31.360 --> 00:25:37.870
知道多版本的jar文件

00:25:33.700 --> 00:25:41.710
现在我们接下来将讨论一些

00:25:37.870 --> 00:25:43.389
首先在jdk 9中进行语言更改

00:25:41.710 --> 00:25:45.850
我将讨论一组铣削项目

00:25:43.389 --> 00:25:47.590
硬币特征是在硬币上铣削是

00:25:45.850 --> 00:25:50.110
沿着这些山脊排列的名称

00:25:47.590 --> 00:25:51.990
最初作为

00:25:50.110 --> 00:25:54.429
努力避免使货币贬值

00:25:51.990 --> 00:25:56.169
当硬币使用贵重物品制成时返回

00:25:54.429 --> 00:25:58.029
金属人有点刮胡子

00:25:56.169 --> 00:25:59.740
你知道的边缘得到银或金

00:25:58.029 --> 00:26:02.019
并单独出售给某种

00:25:59.740 --> 00:26:04.120
货币贬值，所以四百万

00:26:02.019 --> 00:26:05.769
硬币是为了防止这种情况在我们

00:26:04.120 --> 00:26:07.090
感觉这里有百万项目葡萄酒

00:26:05.769 --> 00:26:09.639
保持硬币特征的价值

00:26:07.090 --> 00:26:13.210
通过修复一些未完成的内容

00:26:09.639 --> 00:26:16.000
早期版本的工作是

00:26:13.210 --> 00:26:17.470
我们通常在JDK 7中设置功能

00:26:16.000 --> 00:26:19.059
对此感到满意

00:26:17.470 --> 00:26:21.250
发布但是有一些功能

00:26:19.059 --> 00:26:22.480
我们想对其进行微调的地方

00:26:21.250 --> 00:26:26.129
但是我们在发布中用尽了时间

00:26:22.480 --> 00:26:30.460
所以我们现在要完成

00:26:26.129 --> 00:26:32.289
这些lambda项目的第一个是

00:26:30.460 --> 00:26:34.960
在类似情况下，他们也有

00:26:32.289 --> 00:26:36.789
他们无法完成的一些工作

00:26:34.960 --> 00:26:38.919
在JDK 8的末尾，所以我们包括

00:26:36.789 --> 00:26:43.809
作为铣削项目硬币的一部分

00:26:38.919 --> 00:26:48.309
首先使用JDK 9是安全的VAR参数

00:26:43.809 --> 00:26:50.399
私有实例方法，所以这是一个

00:26:48.309 --> 00:26:53.320
您可能已经在JDK中编写的代码

00:26:50.399 --> 00:26:55.029
从JDK 5开始已有很多年了

00:26:53.320 --> 00:26:56.799
字符串列表的列表

00:26:55.029 --> 00:26:59.590
使用一些平台类数组

00:26:56.799 --> 00:27:01.570
作为初始化它的列表，所以看起来

00:26:59.590 --> 00:27:03.610
通过Java C运行时很好

00:27:01.570 --> 00:27:04.830
虽然您会注意到您会得到一个

00:27:03.610 --> 00:27:07.360
这样的警告

00:27:04.830 --> 00:27:09.970
取消选中VAR X的通用数组创建

00:27:07.360 --> 00:27:11.200
字符串数组的参数类型列表

00:27:09.970 --> 00:27:12.879
当然听起来非常非常

00:27:11.200 --> 00:27:14.889
恐吓某事

00:27:12.879 --> 00:27:17.430
在这里出现这种警告是错误的

00:27:14.889 --> 00:27:20.200
由...授权

00:27:17.430 --> 00:27:21.850
有可能是坏事

00:27:20.200 --> 00:27:24.790
发生了一些事情

00:27:21.850 --> 00:27:26.890
污染这在Java中讨论

00:27:24.790 --> 00:27:29.260
语言规范基本上有

00:27:26.890 --> 00:27:32.020
数组之间的不良互动

00:27:29.260 --> 00:27:34.300
可能会出现在

00:27:32.020 --> 00:27:36.190
现在在这种情况下

00:27:34.300 --> 00:27:39.610
当前使用作为列表的数组

00:27:36.190 --> 00:27:42.190
实际上没有什么不好的事情发生

00:27:39.610 --> 00:27:47.500
可能发生的坏事不会

00:27:42.190 --> 00:27:49.330
在这种情况下发生，这是自然

00:27:47.500 --> 00:27:51.250
做这样的健全

00:27:49.330 --> 00:27:53.440
分析，所以如果您有分析

00:27:51.250 --> 00:27:55.210
想要发出声音，这意味着您必须

00:27:53.440 --> 00:27:56.830
警告如果您不知道某事

00:27:55.210 --> 00:27:58.000
坏事不会发生，但这不是

00:27:56.830 --> 00:28:00.010
在这种情况下翔实的是

00:27:58.000 --> 00:28:02.290
基本上是假阳性，我们想要

00:28:00.010 --> 00:28:04.960
用项目解决这种情况

00:28:02.290 --> 00:28:07.690
柯恩（Coyne）回来了七个，所以我们做了什么

00:28:04.960 --> 00:28:10.360
添加了新的注释类型安全VAR 

00:28:07.690 --> 00:28:12.100
 args基本上意味着相信我

00:28:10.360 --> 00:28:13.330
在VAR参数中没有做任何坏事

00:28:12.100 --> 00:28:14.830
你知道那种热量的方法

00:28:13.330 --> 00:28:17.730
不会解决的污染问题

00:28:14.830 --> 00:28:19.990
发生在这里，我们更新了平台

00:28:17.730 --> 00:28:22.150
适当的方法有这个

00:28:19.990 --> 00:28:23.770
注释完成了两件事

00:28:22.150 --> 00:28:25.600
在声明中摆脱警告

00:28:23.770 --> 00:28:27.910
方法，但更重要的是

00:28:25.600 --> 00:28:30.040
消除所有这些警告的使用

00:28:27.910 --> 00:28:31.750
方法，因此所有调用的用户代码

00:28:30.040 --> 00:28:34.740
这些方法没有这些警告

00:28:31.750 --> 00:28:38.380
如此，这是相当不错的

00:28:34.740 --> 00:28:40.060
由于设计的某些方面

00:28:38.380 --> 00:28:42.400
注释，您只能应用此

00:28:40.060 --> 00:28:45.100
注释不能的方法

00:28:42.400 --> 00:28:46.810
覆盖了，那么有哪些

00:28:45.100 --> 00:28:49.330
 Java中无法覆盖的方法

00:28:46.810 --> 00:28:52.000
好吧，我们不能通过以下方法覆盖最终方法

00:28:49.330 --> 00:28:55.480
根据定义，我们也不能覆盖

00:28:52.000 --> 00:28:57.940
出于同样的原因，现在使用静态方法

00:28:55.480 --> 00:28:59.680
我们无法从

00:28:57.940 --> 00:29:01.750
构造函数的某些观点是

00:28:59.680 --> 00:29:03.340
这是一个非常特殊的静态方法

00:29:01.750 --> 00:29:05.440
在虚拟机方面看起来如何

00:29:03.340 --> 00:29:07.180
我们不能，所以你现在在那里使用

00:29:05.440 --> 00:29:09.490
实际上是我们无法做到的另一种方法

00:29:07.180 --> 00:29:12.370
覆盖其中之一，这是私有的

00:29:09.490 --> 00:29:14.560
现在发出了私有方法

00:29:12.370 --> 00:29:17.410
从可以使用的方法列表中说

00:29:14.560 --> 00:29:21.760
在jdk 7中打开args，现在我们

00:29:17.410 --> 00:29:23.500
在jdk 9中修复它，这是一个非常

00:29:21.760 --> 00:29:25.150
小小的语言变化，我将展示

00:29:23.500 --> 00:29:29.530
整个规格变更

00:29:25.150 --> 00:29:30.220
现在屏幕，所以我们喜欢它

00:29:29.530 --> 00:29:31.750
很简单

00:29:30.220 --> 00:29:32.980
就这样，因为它们发生了

00:29:31.750 --> 00:29:37.090
很少，所以他们通常是很多

00:29:32.980 --> 00:29:38.890
接下来比较复杂，我们有一些

00:29:37.090 --> 00:29:40.659
部落资源声明的变更

00:29:38.890 --> 00:29:44.830
使其有效地最终使用

00:29:40.659 --> 00:29:46.450
变量只是快速入门Tri 

00:29:44.830 --> 00:29:49.780
资源声明，以便您拥有

00:29:46.450 --> 00:29:51.909
被管理的资源，基本上

00:29:49.780 --> 00:29:53.169
部落资源确保您接近

00:29:51.909 --> 00:29:56.289
当您离开一个

00:29:53.169 --> 00:29:57.789
块，以便它大致翻译为

00:29:56.289 --> 00:29:59.440
编译器或类似的东西

00:29:57.789 --> 00:30:01.299
最后还有另外的尝试

00:29:59.440 --> 00:30:03.429
在这里，你确定

00:30:01.299 --> 00:30:06.640
呼叫关闭实际上更多

00:30:03.429 --> 00:30:09.159
如此复杂

00:30:06.640 --> 00:30:13.150
公开这实际上是Java C 

00:30:09.159 --> 00:30:14.679
代表我们做，但你不是我们

00:30:13.150 --> 00:30:16.480
不用担心，因为Java C 

00:30:14.679 --> 00:30:18.159
照顾那个

00:30:16.480 --> 00:30:21.150
额外的并发症是因为

00:30:18.159 --> 00:30:24.520
异常处理的一些细微差别

00:30:21.150 --> 00:30:26.500
因此在jdk 7中正在管理的资源

00:30:24.520 --> 00:30:28.210
必须在一个新变量下完成

00:30:26.500 --> 00:30:30.880
宣布为三大地球的一部分

00:30:28.210 --> 00:30:32.860
如果您关注，请立即声明资源

00:30:30.880 --> 00:30:34.750
并非JDK 7的项目

00:30:32.860 --> 00:30:37.150
最初的建议你可以

00:30:34.750 --> 00:30:39.039
在这里有任何表达

00:30:37.150 --> 00:30:41.250
自动关闭类型，这是新的

00:30:39.039 --> 00:30:43.720
创建类型以托管close方法

00:30:41.250 --> 00:30:44.980
但是我们发现这可能是

00:30:43.720 --> 00:30:46.570
有问题，所以我们说我们有一个

00:30:44.980 --> 00:30:50.110
这里的资源指向

00:30:46.570 --> 00:30:51.970
我们通过的第一个资源

00:30:50.110 --> 00:30:54.700
好的，它具有正确的类型，然后

00:30:51.970 --> 00:30:57.059
在try块中，我们将其更改为

00:30:54.700 --> 00:31:00.640
指向不同的对象资源2 

00:30:57.059 --> 00:31:03.760
现在我们存在一个try块，哪个对象

00:31:00.640 --> 00:31:05.890
应该有其close方法调用，所以

00:31:03.760 --> 00:31:07.030
这是一个问题，它在

00:31:05.890 --> 00:31:09.370
特别是我们不想要的问题

00:31:07.030 --> 00:31:10.840
必须解决，所以我们决定

00:31:09.370 --> 00:31:12.340
你知道我们不会去做什么

00:31:10.840 --> 00:31:14.650
允许我们不会允许

00:31:12.340 --> 00:31:16.929
要求您有一个情况

00:31:14.650 --> 00:31:19.299
新鲜的资源变量，所以我们不会

00:31:16.929 --> 00:31:21.850
遇到那种情况

00:31:19.299 --> 00:31:24.130
有点太严格了，因为

00:31:21.850 --> 00:31:26.440
是无法在其中修改的变量

00:31:24.130 --> 00:31:28.840
三或三个来源像最终

00:31:26.440 --> 00:31:31.390
变量或有效的最终变量

00:31:28.840 --> 00:31:33.010
这些是程序的变量

00:31:31.390 --> 00:31:37.059
如果您将它们定为最终版本，则会进行编译， 

00:31:33.010 --> 00:31:40.000
你只是还没有让他们决赛而已

00:31:37.059 --> 00:31:41.770
我们现在能做的就是利用

00:31:40.000 --> 00:31:43.660
如果你有一个变量

00:31:41.770 --> 00:31:46.600
最终或有效地最终

00:31:43.660 --> 00:31:48.370
而不是在中声明新变量

00:31:46.600 --> 00:31:51.040
尝试资源声明托管

00:31:48.370 --> 00:31:53.530
您可以直接将其传递给

00:31:51.040 --> 00:31:54.970
因为你不能改变是在里面

00:31:53.530 --> 00:31:56.920
块，我们没有像

00:31:54.970 --> 00:32:00.810
哪个对象调用它的封闭方法

00:31:56.920 --> 00:32:04.030
在这方面的语法变化

00:32:00.810 --> 00:32:08.140
语法变化不是很困难

00:32:04.030 --> 00:32:11.050
规格变化比我们预期的更大

00:32:08.140 --> 00:32:12.910
在这里，它比

00:32:11.050 --> 00:32:14.530
你可能会怀疑，所以你可能会想

00:32:12.910 --> 00:32:16.420
就像你只需要拥有

00:32:14.530 --> 00:32:18.580
最终局部变量之类的

00:32:16.420 --> 00:32:21.370
如果语言发生变化，我们希望

00:32:18.580 --> 00:32:24.340
更加正交，因此您实际上可以

00:32:21.370 --> 00:32:26.200
如果你有最后的领域

00:32:24.340 --> 00:32:28.120
在新分配的对象中

00:32:26.200 --> 00:32:29.830
好吧，这是最终的-所以您可以使用它

00:32:28.120 --> 00:32:31.450
在您尝试地球资源的声明中

00:32:29.830 --> 00:32:35.920
相反，那是更长的时间

00:32:31.450 --> 00:32:37.440
此处的规格允许您下一步

00:32:35.920 --> 00:32:39.400
语言变化必须应对钻石

00:32:37.440 --> 00:32:40.960
钻石是在地下制造的， 

00:32:39.400 --> 00:32:42.400
巨大的热量和压力，将不得不

00:32:40.960 --> 00:32:44.260
往兔子洞下一点

00:32:42.400 --> 00:32:47.280
看看为什么需要此功能，但这是

00:32:44.260 --> 00:32:50.710
一个好的变化，我们有九个

00:32:47.280 --> 00:32:52.660
所以我们用这个盒子的小例子

00:32:50.710 --> 00:32:55.780
类型，您可以将盒子视为

00:32:52.660 --> 00:32:57.790
简化的收藏证明你采取

00:32:55.780 --> 00:33:00.450
您放入对象并获得的对象

00:32:57.790 --> 00:33:02.680
对象出来，所以你有一个清单

00:33:00.450 --> 00:33:06.250
问号在这里，你想要一个新的

00:33:02.680 --> 00:33:09.310
框来保存列表，所以这应该

00:33:06.250 --> 00:33:11.650
很好，这会发生什么

00:33:09.310 --> 00:33:13.720
菱形，所以在编译器中

00:33:11.650 --> 00:33:17.170
编译器需要推断要使用的类型

00:33:13.720 --> 00:33:19.390
 for box，所以Java仍然是静态的

00:33:17.170 --> 00:33:21.520
打字的语言并不总是

00:33:19.390 --> 00:33:23.500
显式输入语言，表示

00:33:21.520 --> 00:33:27.550
编译器有时会推断类型

00:33:23.500 --> 00:33:31.420
我们代表程序员，所以做什么

00:33:27.550 --> 00:33:34.630
在Java C中看起来像这样

00:33:31.420 --> 00:33:37.630
推断的磁盘是捕获的列表

00:33:34.630 --> 00:33:39.370
问号，所以你不能写一个类型

00:33:37.630 --> 00:33:43.000
您的捕获新鲜标记列表

00:33:39.370 --> 00:33:44.440
源代码，所以这里的情况很好

00:33:43.000 --> 00:33:46.900
这就是所谓的捕获

00:33:44.440 --> 00:33:49.420
转换，这不是很明显

00:33:46.900 --> 00:33:50.920
现在在JLS中描述的类型

00:33:49.420 --> 00:33:52.350
这是JLS的一部分

00:33:50.920 --> 00:33:54.940
可能想要一本类型理论书

00:33:52.350 --> 00:33:57.309
在附近以帮助弄清楚发生了什么

00:33:54.940 --> 00:33:59.080
基本上是什么

00:33:57.309 --> 00:34:00.639
就是说

00:33:59.080 --> 00:34:02.710
语言有更丰富的类型系统

00:34:00.639 --> 00:34:03.940
在编译器内部比一个

00:34:02.710 --> 00:34:07.059
可供程序员使用

00:34:03.940 --> 00:34:09.399
因此，当Java C看到通配符时， 

00:34:07.059 --> 00:34:11.589
问号类型在这里翻译

00:34:09.399 --> 00:34:13.419
直到一个新的新鲜类型变量

00:34:11.589 --> 00:34:14.919
编译器内部及其原因

00:34:13.419 --> 00:34:20.829
这就是验证码转换

00:34:14.919 --> 00:34:22.480
过程需要，所以你有你的盒子

00:34:20.829 --> 00:34:24.040
你可以用盒子做一件事

00:34:22.480 --> 00:34:26.470
你可以把它公开化

00:34:24.040 --> 00:34:30.069
构造函数，您也可以子类化

00:34:26.470 --> 00:34:33.490
匿名可以，这样可能

00:34:30.069 --> 00:34:36.760
可以，但也许不是，那你怎么办

00:34:33.490 --> 00:34:38.649
你如何编译一个匿名者

00:34:36.760 --> 00:34:40.929
子类，所以有完整的类文件

00:34:38.649 --> 00:34:42.579
为此，如果我们要在源代码中编写

00:34:40.929 --> 00:34:46.329
代码看起来像盒子类

00:34:42.579 --> 00:34:48.970
一美元可以扩展包装盒，我们需要

00:34:46.329 --> 00:34:51.310
有某种类型填写什么

00:34:48.970 --> 00:34:53.409
它如何扩展框和类型

00:34:51.310 --> 00:34:56.310
在Furbot编译器中，此列表是

00:34:53.409 --> 00:34:59.650
到目前为止很好地捕获了问号

00:34:56.310 --> 00:35:02.980
但是这里有一个问题

00:34:59.650 --> 00:35:04.450
因为此信息必须是

00:35:02.980 --> 00:35:07.240
存储在

00:35:04.450 --> 00:35:09.670
类文件签名的语法

00:35:07.240 --> 00:35:12.250
属性不允许非显着

00:35:09.670 --> 00:35:15.760
诸如捕获问号列表之类的类型

00:35:12.250 --> 00:35:18.579
要存储以表示

00:35:15.760 --> 00:35:20.800
是一个使用这里的问题

00:35:18.579 --> 00:35:23.950
当您拥有匿名类的Dimond 

00:35:20.800 --> 00:35:26.020
有这些不可听见的类型，那是什么

00:35:23.950 --> 00:35:29.290
随着时间的推移一直在这里互动

00:35:26.020 --> 00:35:32.079
早在1.1年前的内在

00:35:29.290 --> 00:35:34.839
几年后增加了类

00:35:32.079 --> 00:35:37.210
加入了泛型

00:35:34.839 --> 00:35:40.030
与内部类交互的方式

00:35:37.210 --> 00:35:42.660
这样很好，然后在JDK 7中

00:35:40.030 --> 00:35:45.310
钻石和钻石内部阶层

00:35:42.660 --> 00:35:47.859
互动在一起很好的内在

00:35:45.310 --> 00:35:49.720
通用类工程师钻石

00:35:47.859 --> 00:35:51.849
单独互动在一起工作

00:35:49.720 --> 00:35:53.530
很好，但是当我们结合在一起

00:35:51.849 --> 00:35:56.920
这三件事在一起，我们得到了

00:35:53.530 --> 00:35:59.440
来自方舟子的来访这是杜克大学的邪恶双胞胎

00:35:56.920 --> 00:36:01.930
来搞砸我们的兄弟

00:35:59.440 --> 00:36:03.579
计划改善语言，并作为

00:36:01.930 --> 00:36:06.579
布赖恩喜欢这样说

00:36:03.579 --> 00:36:08.549
今天还存在问题的情况

00:36:06.579 --> 00:36:10.789
从昨天的解决方案中，这些

00:36:08.549 --> 00:36:12.499
语言功能

00:36:10.789 --> 00:36:14.509
或相隔十年

00:36:12.499 --> 00:36:16.400
不幸的互动，这是

00:36:14.509 --> 00:36:18.109
实际上是由我们的jck团队发现的， 

00:36:16.400 --> 00:36:20.329
他们正在为编写性能测试

00:36:18.109 --> 00:36:23.390
七分之内的功能

00:36:20.329 --> 00:36:24.890
不幸的是有七个解决方案

00:36:23.390 --> 00:36:27.469
就像你知道这听起来像什么

00:36:24.890 --> 00:36:28.789
处理起来很复杂，我们不是

00:36:27.469 --> 00:36:30.349
让你用Dimond与

00:36:28.789 --> 00:36:33.140
匿名类，这样可以避免

00:36:30.349 --> 00:36:34.669
这个问题肯定是一点

00:36:33.140 --> 00:36:37.160
不幸的是，当我们完成时

00:36:34.669 --> 00:36:40.719
我们注意到的JCR 334规范

00:36:37.160 --> 00:36:42.979
你知道他在平台上的未来

00:36:40.719 --> 00:36:45.140
我们可以允许匿名的钻石

00:36:42.979 --> 00:36:46.759
如果我们不了解这些子类

00:36:45.140 --> 00:36:48.650
值得注意的类型，如果我们只是正常的

00:36:46.759 --> 00:36:50.419
值得注意的类型，那会很好，我们

00:36:48.650 --> 00:36:53.900
可以使用它，这实际上是什么

00:36:50.419 --> 00:36:55.849
我们现在已经在JDK中完成了

00:36:53.900 --> 00:36:58.699
规范做到这一点是更多

00:36:55.849 --> 00:37:01.939
这就是你怎么说不值得注意的

00:36:58.699 --> 00:37:04.579
在JLS中，幸运的是我们的规范人员

00:37:01.939 --> 00:37:06.709
照顾好我们，就在这里

00:37:04.579 --> 00:37:08.859
那这个的功效是什么

00:37:06.709 --> 00:37:11.509
当我们最初设计Dimond时

00:37:08.859 --> 00:37:13.429
我们可以摆脱约90％的

00:37:11.509 --> 00:37:16.069
使用的显式构造函数参数

00:37:13.429 --> 00:37:20.449
七个钻石特征，我们感到

00:37:16.069 --> 00:37:22.130
通过允许钻石与

00:37:20.449 --> 00:37:24.709
我们可以得到的匿名类中的类型

00:37:22.130 --> 00:37:26.329
摆脱了我们剩下的很多10％ 

00:37:24.709 --> 00:37:28.099
在使用此功能方面有很好的经验

00:37:26.329 --> 00:37:30.169
在JDK中，我们更新了数百个

00:37:28.099 --> 00:37:33.769
致电网站以经常将其用于

00:37:30.169 --> 00:37:35.689
安全支柱行动下一步

00:37:33.769 --> 00:37:38.419
下划线不再是标识符

00:37:35.689 --> 00:37:40.789
名称，所以这已经是

00:37:38.419 --> 00:37:43.939
讨论的是lambda项目的一部分

00:37:40.789 --> 00:37:46.489
几年前，当你有一个

00:37:43.939 --> 00:37:48.709
 lambda参数中有八种您无法使用

00:37:46.489 --> 00:37:50.599
 lambda作为参数名称，如果

00:37:48.709 --> 00:37:54.349
在8中使用lambda作为参数名称

00:37:50.599 --> 00:37:56.749
确实从Java C收到警告，通知

00:37:54.349 --> 00:37:58.130
那一天你可能不会

00:37:56.749 --> 00:38:00.559
能够使用它作为标识符

00:37:58.130 --> 00:38:04.039
确实，那天已经到了

00:38:00.559 --> 00:38:06.519
通过，所以我们为什么要这样做

00:38:04.039 --> 00:38:10.099
违反了我们一贯的保留政策

00:38:06.519 --> 00:38:11.900
我们觉得编译的程序

00:38:10.099 --> 00:38:14.150
它不是非常有用的选项，如果有

00:38:11.900 --> 00:38:16.729
如果我们回收它，将来会更好地使用它

00:38:14.150 --> 00:38:18.890
句法不动产

00:38:16.729 --> 00:38:22.309
可能会显示我们的部分钻石

00:38:18.890 --> 00:38:23.050
所以只是在一种类型的变量

00:38:22.309 --> 00:38:26.980
管理另一个

00:38:23.050 --> 00:38:30.100
或类似的部分书面文章

00:38:26.980 --> 00:38:32.230
也许我们可以编码为

00:38:30.100 --> 00:38:34.120
其他类似参数名称

00:38:32.230 --> 00:38:39.220
表达远不使用消息等

00:38:34.120 --> 00:38:42.070
第四种私有接口方法之一

00:38:39.220 --> 00:38:44.500
 lambda在8中所做的其他更改

00:38:42.070 --> 00:38:46.630
是默认方法，这些是方法

00:38:44.500 --> 00:38:50.620
具有代码的接口，因此它们不是

00:38:46.630 --> 00:38:53.800
抽象，所以这些非常有帮助

00:38:50.620 --> 00:38:55.450
在虚拟机级别发展平台

00:38:53.800 --> 00:38:56.920
这是方便和必要的

00:38:55.450 --> 00:39:00.190
实际上有私有方法

00:38:56.920 --> 00:39:02.740
界面以帮助拥有一些元

00:39:00.190 --> 00:39:04.270
工厂的东西继续在

00:39:02.740 --> 00:39:06.520
您无法拥有的源代码级别

00:39:04.270 --> 00:39:09.570
接口内部的方法，现在我们

00:39:06.520 --> 00:39:11.890
换成8，这样您也可以

00:39:09.570 --> 00:39:14.260
源代码中您自己的私有方法

00:39:11.890 --> 00:39:16.990
你们两个都有的接口代码

00:39:14.260 --> 00:39:19.060
私有中的私有静态方法

00:39:16.990 --> 00:39:21.250
实例方法，那么你会怎么做

00:39:19.060 --> 00:39:22.510
用这样的私有方法通常

00:39:21.250 --> 00:39:23.950
将其作为辅助方法

00:39:22.510 --> 00:39:25.540
类中的默认方法，因此您可以

00:39:23.950 --> 00:39:27.310
将一些通用代码放在一起

00:39:25.540 --> 00:39:31.570
私有接口而不暴露

00:39:27.310 --> 00:39:32.620
给下一个界面的所有用户

00:39:31.570 --> 00:39:35.800
我们将开始谈论

00:39:32.620 --> 00:39:38.050
弃用和导入语句，因此

00:39:35.800 --> 00:39:40.510
 JDK有点背景

00:39:38.050 --> 00:39:43.180
大型Java代码库

00:39:40.510 --> 00:39:46.750
多年来的技术债务

00:39:43.180 --> 00:39:48.220
 Java C的五彩图

00:39:46.750 --> 00:39:51.460
警告我们已经建立了JDK 

00:39:48.220 --> 00:39:53.410
您可以在jdk中看到它本身是

00:39:51.460 --> 00:39:56.650
超过10,000，所以我们有几个

00:39:53.410 --> 00:39:58.570
多年来代码库中的消息

00:39:56.650 --> 00:40:00.070
我们在这方面取得了进展，我们有一些

00:39:58.570 --> 00:40:02.950
好实习生和其他日子

00:40:00.070 --> 00:40:06.580
后来我们开始打开警告

00:40:02.950 --> 00:40:10.360
从法案开始到现在

00:40:06.580 --> 00:40:12.130
图表就停止了，然后在后面

00:40:10.360 --> 00:40:16.710
 jdk 9我们从成千上万的方法

00:40:12.130 --> 00:40:19.060
的警告消息数量降至零，因此

00:40:16.710 --> 00:40:20.920
在平台的核心部分

00:40:19.060 --> 00:40:24.310
打开代码关闭代码生成器代码

00:40:20.920 --> 00:40:27.340
我们建立的所有警告都是免费的

00:40:24.310 --> 00:40:30.220
出色的W错误，涵盖了许多

00:40:27.340 --> 00:40:32.320
码头区也有特色

00:40:30.220 --> 00:40:34.750
平台核心部分的封面

00:40:32.320 --> 00:40:36.369
表示基本模块和Java 

00:40:34.750 --> 00:40:38.170
基于模块和桌面模块

00:40:36.369 --> 00:40:41.319
好吧，它不包括类似

00:40:38.170 --> 00:40:42.819
也许是CORBA插孔速度插孔WS 

00:40:41.319 --> 00:40:44.549
我们有一天可能会到

00:40:42.819 --> 00:40:47.559
惯于

00:40:44.549 --> 00:40:49.240
人们经常谈论技术

00:40:47.559 --> 00:40:50.529
债务，但我认为

00:40:49.240 --> 00:40:53.319
这样的项目可以看作是

00:40:50.529 --> 00:40:54.940
现在有技术红利

00:40:53.319 --> 00:40:56.140
我们没有的JDK中的问题类别

00:40:54.940 --> 00:40:58.869
不必再担心了，因为

00:40:56.140 --> 00:41:01.390
他们会被建筑和

00:40:58.869 --> 00:41:02.769
人们马上修复它们，以便您

00:41:01.390 --> 00:41:05.019
您是否声明了一个可序列化的类

00:41:02.769 --> 00:41:06.400
串行版本UID甚至是一个例外

00:41:05.019 --> 00:41:08.710
类型，因为所有的异常类型

00:41:06.400 --> 00:41:10.329
可实现的等于和哈希码

00:41:08.710 --> 00:41:12.940
在那里容易犯错

00:41:10.329 --> 00:41:16.089
我们现在进行了非常细微的检查

00:41:12.940 --> 00:41:18.299
您知道的编译器确保您

00:41:16.089 --> 00:41:20.200
做好事

00:41:18.299 --> 00:41:22.059
甚至有可能的安全性

00:41:20.200 --> 00:41:25.210
暗示像开关

00:41:22.059 --> 00:41:27.430
失败可以执行意外

00:41:25.210 --> 00:41:29.710
代码，这是相同的基本问题

00:41:27.430 --> 00:41:33.130
那就是去失败去失败一个

00:41:29.710 --> 00:41:35.289
几年前的安全问题

00:41:33.130 --> 00:41:37.569
最后，真的可以接受

00:41:35.289 --> 00:41:41.589
关于的更多弃用警告

00:41:37.569 --> 00:41:43.239
不推荐使用的项目，因此按钮

00:41:41.589 --> 00:41:46.329
我确实写了一个博客条目，如果你

00:41:43.239 --> 00:41:48.849
想要从JDK体验中删除

00:41:46.329 --> 00:41:50.289
您可能需要的警告建议

00:41:48.849 --> 00:41:53.289
有自己的项目去

00:41:50.289 --> 00:41:56.410
通过类似的努力，现在

00:41:53.289 --> 00:41:58.650
该图的最底层

00:41:56.410 --> 00:42:01.900
警告有一个非常

00:41:58.650 --> 00:42:04.539
我们顽固的弃用警告

00:42:01.900 --> 00:42:06.039
必须摆脱淘汰

00:42:04.539 --> 00:42:08.470
警告是通过使用

00:42:06.039 --> 00:42:11.049
不推荐使用的类型方法等

00:42:08.470 --> 00:42:12.730
这些是JLS现在授权的

00:42:11.049 --> 00:42:14.769
有几种方法可以解决这些问题

00:42:12.730 --> 00:42:16.779
警告，您可以删除对

00:42:14.769 --> 00:42:18.279
不推荐使用的元素，当

00:42:16.779 --> 00:42:21.339
你可以做到，你不可能全部做到

00:42:18.279 --> 00:42:23.619
时间可能是您可以使用的API的一部分

00:42:21.339 --> 00:42:25.809
将不推荐使用的注释传播到

00:42:23.619 --> 00:42:27.099
在这种情况下，青年网站

00:42:25.809 --> 00:42:28.450
治愈比你患的病还糟

00:42:27.099 --> 00:42:30.900
使过时的部分成为

00:42:28.450 --> 00:42:33.009
平台更大而不是更小

00:42:30.900 --> 00:42:35.170
最后你可以使用抑制

00:42:33.009 --> 00:42:36.640
警告功能可禁止发出警告

00:42:35.170 --> 00:42:40.119
那是我们经常遇到的情况

00:42:36.640 --> 00:42:42.009
没事吧，这是这里的一些

00:42:40.119 --> 00:42:44.710
客户代码，这是已弃用的

00:42:42.009 --> 00:42:46.450
库，因此当您运行编译器时， 

00:42:44.710 --> 00:42:49.930
看到确实确实收到警告

00:42:46.450 --> 00:42:52.329
它使用不推荐使用的API 

00:42:49.930 --> 00:42:54.309
那蓝色在这里，所以你说全部

00:42:52.329 --> 00:42:56.740
没问题，我不能删除使用

00:42:54.309 --> 00:42:58.089
我不想让我的客户使用的API 

00:42:56.740 --> 00:43:00.190
太过时了，所以我会抑制

00:42:58.089 --> 00:43:02.260
而是在顶部警告

00:43:00.190 --> 00:43:05.740
上课时我会压制警告

00:43:02.260 --> 00:43:08.920
再次运行编译器，您仍然

00:43:05.740 --> 00:43:10.180
已弃用API警告，那是什么

00:43:08.920 --> 00:43:12.520
如果你看更多的话

00:43:10.180 --> 00:43:16.750
信息Java C警告您

00:43:12.520 --> 00:43:19.240
是的，您使用的是代理类型

00:43:16.750 --> 00:43:20.650
在您未使用的导入语句中

00:43:19.240 --> 00:43:23.619
导入语句中的代码

00:43:20.650 --> 00:43:24.790
 JLS也要求您这样做

00:43:23.619 --> 00:43:25.780
可能会说好吧，我将添加

00:43:24.790 --> 00:43:27.339
禁止导入警告

00:43:25.780 --> 00:43:30.520
无效的陈述

00:43:27.339 --> 00:43:32.440
这在语法上是不允许的，所以如果

00:43:30.520 --> 00:43:34.030
你真的想摆脱

00:43:32.440 --> 00:43:36.069
弃用一个你可以做的事

00:43:34.030 --> 00:43:37.510
就像对不推荐使用的类型的每次使用一样

00:43:36.069 --> 00:43:38.800
名称以完全合格的名称替换

00:43:37.510 --> 00:43:40.660
类型的名称，而不是

00:43:38.800 --> 00:43:42.550
重要的目标很好，这有点愚蠢

00:43:40.660 --> 00:43:44.470
就在您知道程序是

00:43:42.550 --> 00:43:46.270
如果使用短名称也一样糟糕

00:43:44.470 --> 00:43:50.650
相对于长名，为什么呢？ 

00:43:46.270 --> 00:43:54.369
不得不经历这种大惊小怪，所以

00:43:50.650 --> 00:43:55.930
我们将Java C更改为不需要发出

00:43:54.369 --> 00:43:57.940
此位置的弃用警告

00:43:55.930 --> 00:44:00.660
因此，如果您使用进口声明， 

00:43:57.940 --> 00:44:03.460
不必得到警告， 

00:44:00.660 --> 00:44:06.369
很容易解决，这里只有一句话

00:44:03.460 --> 00:44:08.109
在JLS中，但由于此修复程序

00:44:06.369 --> 00:44:11.650
现在易于处理，以消除折旧

00:44:08.109 --> 00:44:13.059
来自重要代码库的警告，以及

00:44:11.650 --> 00:44:15.400
我们有一个存在的证据

00:44:13.059 --> 00:44:16.960
 JDK，所以我鼓励您尝试获取

00:44:15.400 --> 00:44:20.260
摆脱您的弃用警告

00:44:16.960 --> 00:44:21.609
自己的代码，因为此修复程序有

00:44:20.260 --> 00:44:25.510
实际上还有更多要说的

00:44:21.609 --> 00:44:29.170
 jdk 9中的弃用只是一部分

00:44:25.510 --> 00:44:30.579
所以什么是贬值意味着

00:44:29.170 --> 00:44:33.339
这些年来有点不清楚

00:44:30.579 --> 00:44:35.349
表示此API有害吗

00:44:33.339 --> 00:44:37.480
意思是说它要消失了

00:44:35.349 --> 00:44:39.099
走开，为什么那些家伙没有

00:44:37.480 --> 00:44:41.470
 JK Group删除了这些东西

00:44:39.099 --> 00:44:43.720
已经被淘汰多年了

00:44:41.470 --> 00:44:45.309
我们想加强对

00:44:43.720 --> 00:44:47.380
帮助回答这些问题并使

00:44:45.309 --> 00:44:49.359
不推荐使用的API的管理更加轻松

00:44:47.380 --> 00:44:50.260
这些年来，有一些新的

00:44:49.359 --> 00:44:53.440
添加到

00:44:50.260 --> 00:44:55.329
说明是否

00:44:53.440 --> 00:44:58.270
此不推荐使用的项目是为了移除或

00:44:55.329 --> 00:44:59.859
不，默认为另一个

00:44:58.270 --> 00:45:02.140
一是因为什么时候有项目

00:44:59.859 --> 00:45:03.490
已弃用，我们已经更新了已弃用

00:45:02.140 --> 00:45:04.900
注释的核心部分

00:45:03.490 --> 00:45:07.000
这个额外的平台

00:45:04.900 --> 00:45:08.500
他们正在支持的信息

00:45:07.000 --> 00:45:10.690
都以Java语言更新

00:45:08.500 --> 00:45:13.330
规范java c和java talk 

00:45:10.690 --> 00:45:16.420
还有一个新的静态分析

00:45:13.330 --> 00:45:17.830
分析工具，称为j更深层扫描

00:45:16.420 --> 00:45:19.780
将分析您的课程文件并绘制

00:45:17.830 --> 00:45:22.750
使用ABAP眼睛的文件

00:45:19.780 --> 00:45:25.150
在JDK中已弃用，因此当

00:45:22.750 --> 00:45:27.280
我们向jdk添加新的弃用

00:45:25.150 --> 00:45:28.960
说jdk 9人并不总是

00:45:27.280 --> 00:45:30.700
重新编译他们的资源，这样他们就不会

00:45:28.960 --> 00:45:33.040
有办法得到通知

00:45:30.700 --> 00:45:35.110
现在已弃用，因此j depper 

00:45:33.040 --> 00:45:36.400
扫描旨在解决该问题

00:45:35.110 --> 00:45:38.710
因为你可以做一个现有的画

00:45:36.400 --> 00:45:42.040
文件运行j更深层扫描，看是否

00:45:38.710 --> 00:45:49.119
使用现在不推荐使用的api 

00:45:42.040 --> 00:45:50.619
 JDK的新版本有很多

00:45:49.119 --> 00:45:52.990
关于复制功能的更多说明

00:45:50.619 --> 00:45:55.180
您可以获得完整的预后

00:45:52.990 --> 00:45:57.340
斯图尔特的历史标志着博士。 

00:45:55.180 --> 00:46:01.150
在稍后的演讲中，您不赞成使用

00:45:57.340 --> 00:46:04.690
会议最后我们将讨论一些

00:46:01.150 --> 00:46:06.490
除了具有

00:46:04.690 --> 00:46:10.030
 JDK 9的新版本，我们有了一个新

00:46:06.490 --> 00:46:13.180
版本字符串方案的摘要是

00:46:10.030 --> 00:46:14.410
我们摆脱了1.9中的1点

00:46:13.180 --> 00:46:16.600
如果我们永远不会改变一个

00:46:14.410 --> 00:46:19.900
我们认为不妨摆脱

00:46:16.600 --> 00:46:22.119
这样做也是为了更好地对齐

00:46:19.900 --> 00:46:22.780
与语义版本控制和事物

00:46:22.119 --> 00:46:26.080
沿着这些路线

00:46:22.780 --> 00:46:28.630
所以这是当前版本

00:46:26.080 --> 00:46:31.119
输出看起来像来自JDK 8 build和

00:46:28.630 --> 00:46:33.670
这就是现在的样子9所以

00:46:31.119 --> 00:46:35.230
您有一些系统可以解析

00:46:33.670 --> 00:46:39.520
版本字符串输出，您必须

00:46:35.230 --> 00:46:41.950
如果您使用本地更新一点

00:46:39.520 --> 00:46:43.359
系统上的流程有更好的

00:46:41.950 --> 00:46:45.340
现在就这样做的API，尤其是您

00:46:43.359 --> 00:46:47.890
现在可以得到代表的东西

00:46:45.340 --> 00:46:51.190
本机过程的孩子，所以

00:46:47.890 --> 00:46:52.450
当您需要做弦时很方便

00:46:51.190 --> 00:46:55.359
是最常用的类型之一

00:46:52.450 --> 00:46:55.930
在Java中进行了一些更改

00:46:55.359 --> 00:47:00.330
那里

00:46:55.930 --> 00:47:02.740
以前的紧凑字符串项目

00:47:00.330 --> 00:47:04.750
字符串中的信息是

00:47:02.740 --> 00:47:07.960
存储在汽车阵列中，所以16位

00:47:04.750 --> 00:47:09.310
每个字符通常都是这样

00:47:07.960 --> 00:47:13.270
字符串中的字符具有

00:47:09.310 --> 00:47:16.710
高8位0，因为字符是

00:47:13.270 --> 00:47:18.329
全部在前128个字符中，因此

00:47:16.710 --> 00:47:21.119
现在基于紧凑的字符串

00:47:18.329 --> 00:47:23.069
此字符串的内容始终使用

00:47:21.119 --> 00:47:24.510
字节数组，有时它使用一个

00:47:23.069 --> 00:47:26.099
字节，用于字符编码和

00:47:24.510 --> 00:47:28.319
有时它使用2个字节的字符

00:47:26.099 --> 00:47:30.240
编码，因此对用户透明

00:47:28.319 --> 00:47:33.890
它是相同的API，但有更好的

00:47:30.240 --> 00:47:35.809
与字符串相关的内存密度为

00:47:33.890 --> 00:47:38.460
改善字符串连接

00:47:35.809 --> 00:47:41.400
喝猫的民族是另一个非常

00:47:38.460 --> 00:47:44.010
 Java C将生成的常见操作

00:47:41.400 --> 00:47:46.050
调用字符串生成器执行此操作

00:47:44.010 --> 00:47:49.470
现在，字符串构建器调用的模式

00:47:46.050 --> 00:47:50.910
 Java C生成和模式

00:47:49.470 --> 00:47:53.550
字符串生成器调用特定的VM 

00:47:50.910 --> 00:47:55.619
认为是和可亲的优化

00:47:53.550 --> 00:47:58.710
可能会有所不同，并且随着时间的推移可能会有所不同

00:47:55.619 --> 00:48:00.270
是其他变化之一，所以

00:47:58.710 --> 00:48:01.920
解决这个问题，因为这很常见

00:48:00.270 --> 00:48:09.030
操作我们创建了一个新的入口点

00:48:01.920 --> 00:48:11.520
在Java行字符串连接和

00:48:09.030 --> 00:48:14.130
然后VM可以识别

00:48:11.520 --> 00:48:15.809
运行时进行优化，所以这再次是

00:48:14.130 --> 00:48:17.730
使用它几乎是透明的，但应该

00:48:15.809 --> 00:48:19.559
为字符串带来更好的性能

00:48:17.730 --> 00:48:22.470
建造者，它应该是未来的证明

00:48:19.559 --> 00:48:24.299
将来API更新的条款

00:48:22.470 --> 00:48:27.690
就alpha而言，它不那么脆弱

00:48:24.299 --> 00:48:29.670
在其他情况下

00:48:27.690 --> 00:48:31.260
改善现有工程

00:48:29.670 --> 00:48:32.880
功能之一被称为分层

00:48:31.260 --> 00:48:35.430
处理类型的归因

00:48:32.880 --> 00:48:37.589
 Java C的推论，所以我们谈到了

00:48:35.430 --> 00:48:40.190
关于使用钻石之前的类型推断

00:48:37.589 --> 00:48:42.150
所以我们在这里有一个课程

00:48:40.190 --> 00:48:43.890
我们想要一个通用类

00:48:42.150 --> 00:48:46.230
您使用Diamond的构造函数，因此

00:48:43.890 --> 00:48:48.980
很好，所以我们开始编译它， 

00:48:46.230 --> 00:48:51.690
我们开始有一些嵌套

00:48:48.980 --> 00:48:53.640
构造函数需要一点时间

00:48:51.690 --> 00:48:56.430
编译它需要更长的时间

00:48:53.640 --> 00:48:58.290
似乎有更多的嵌套和嗯

00:48:56.430 --> 00:49:00.720
比实际需要的时间更长

00:48:58.290 --> 00:49:04.589
对于此程序长度，如果

00:49:00.720 --> 00:49:06.329
在这里只有16个嵌套调用

00:49:04.589 --> 00:49:10.170
我们用这台机器花了25分钟

00:49:06.329 --> 00:49:12.420
现在编译要长一点，但这

00:49:10.170 --> 00:49:13.680
似乎有点过分且相同

00:49:12.420 --> 00:49:15.089
如果有的话，这对lambda成立

00:49:13.680 --> 00:49:18.450
这样嵌套的lambda也可以

00:49:15.089 --> 00:49:20.160
现在获得非常长的编译时间

00:49:18.450 --> 00:49:21.720
不想给别人找借口

00:49:20.160 --> 00:49:24.630
等待他们的剑术

00:49:21.720 --> 00:49:26.809
类进行编译，因此我们可以用图形表示

00:49:24.630 --> 00:49:30.210
这里的线性比例看起来很糟糕

00:49:26.809 --> 00:49:30.510
但我们可以看看对数刻度

00:49:30.210 --> 00:49:31.830
是

00:49:30.510 --> 00:49:33.180
如果你有一条直线

00:49:31.830 --> 00:49:35.430
对数刻度表示您有一个

00:49:33.180 --> 00:49:38.490
指数增长曲线

00:49:35.430 --> 00:49:40.260
看起来在这里看起来很直

00:49:38.490 --> 00:49:42.510
这是这个不好

00:49:40.260 --> 00:49:44.970
通常在像Java C这样的编译器中

00:49:42.510 --> 00:49:46.560
想要使用线性算法

00:49:44.970 --> 00:49:48.030
程序规模的线性增长或

00:49:46.560 --> 00:49:49.560
长度是线性的，你可以得到

00:49:48.030 --> 00:49:52.410
指数远非如此

00:49:49.560 --> 00:49:54.240
所以我们已经在jdk 9中解决了

00:49:52.410 --> 00:49:56.970
原始归属，因此这些行

00:49:54.240 --> 00:49:59.760
底部显示这是JDK九

00:49:56.970 --> 00:50:02.040
平面，这是JDK的九个破折号

00:49:59.760 --> 00:50:04.140
破折号释放八，所以这意味着如果您

00:50:02.040 --> 00:50:06.690
在9个编译8个源代码

00:50:04.140 --> 00:50:08.550
编译器，您将避免这种指数

00:50:06.690 --> 00:50:11.130
在这里慢下来，这怎么样

00:50:08.550 --> 00:50:13.290
成功的类型侵权不是魔术

00:50:11.130 --> 00:50:16.260
或读心术是一种形式

00:50:13.290 --> 00:50:18.780
约束编程，因此您可以生成

00:50:16.260 --> 00:50:19.890
很多约束，什么是最

00:50:18.780 --> 00:50:22.440
生成的直接方法

00:50:19.890 --> 00:50:25.170
约束产生了很多

00:50:22.440 --> 00:50:27.290
他们的指数数目，然后你

00:50:25.170 --> 00:50:30.480
解决它，使纯点的本质

00:50:27.290 --> 00:50:32.310
斥责许多海洋，这是一种奇特的方式

00:50:30.480 --> 00:50:34.470
基本上说缓存的时候

00:50:32.310 --> 00:50:36.660
约束集已建立，未添加

00:50:34.470 --> 00:50:39.420
多余的约束在继续，那

00:50:36.660 --> 00:50:42.840
这样可以更快地解决问题

00:50:39.420 --> 00:50:44.220
用于类型推断，所以很好

00:50:42.840 --> 00:50:47.430
那里也奠定了基础

00:50:44.220 --> 00:50:50.070
在推理中进行更多优化

00:50:47.430 --> 00:50:51.660
未来还有其他部分

00:50:50.070 --> 00:50:54.990
包括安全库的平台

00:50:51.660 --> 00:50:55.980
让我们看看我们如何按时

00:50:54.990 --> 00:50:58.410
安全的不同部分

00:50:55.980 --> 00:51:03.000
库本身具有Java安全性

00:50:58.410 --> 00:51:04.770
 ap是您可以添加使用

00:51:03.000 --> 00:51:08.220
您自己的代码（例如摄影） 

00:51:04.770 --> 00:51:10.650
包括用于网络的SSL 

00:51:08.220 --> 00:51:14.070
还有一些命令行选项，例如

00:51:10.650 --> 00:51:16.800
关键工具等等政策

00:51:14.070 --> 00:51:18.450
默认情况下，安全性是安全的，这意味着

00:51:16.800 --> 00:51:20.040
开箱即用，您可以拥有一个安全的

00:51:18.450 --> 00:51:22.590
配置，即使您必须

00:51:20.040 --> 00:51:25.590
重新配置它以减少

00:51:22.590 --> 00:51:27.720
确保满足您自己的需求，并且

00:51:25.590 --> 00:51:29.130
有一个想法，这是东西

00:51:27.720 --> 00:51:31.170
一直在变化以跟上

00:51:29.130 --> 00:51:33.810
关于安全最佳实践的日期，以及

00:51:31.170 --> 00:51:36.390
就算法而言， 

00:51:33.810 --> 00:51:39.600
都是Oracle最近发布的

00:51:36.390 --> 00:51:41.070
密码学路线图

00:51:39.600 --> 00:51:43.690
在哪些算法将无法获得

00:51:41.070 --> 00:51:48.069
退休了，所以你可以为

00:51:43.690 --> 00:51:49.329
 Kove在jdk 9中如此加密路线图和

00:51:48.069 --> 00:51:51.819
默认情况下安全的是

00:51:49.329 --> 00:51:54.880
暗示我们增加了默认值

00:51:51.819 --> 00:51:56.770
在某些情况下证书的密钥大小

00:51:54.880 --> 00:51:58.480
弱键不再被

00:51:56.770 --> 00:52:03.520
默认，所以如果您有证书

00:51:58.480 --> 00:52:05.859
使用md5或RSA与短键那些

00:52:03.520 --> 00:52:07.030
不再被接受了

00:52:05.859 --> 00:52:09.250
原因是即使

00:52:07.030 --> 00:52:12.940
您的功能知道诸如

00:52:09.250 --> 00:52:14.290
 RSA和md5是相同的密码学家

00:52:12.940 --> 00:52:16.300
非常聪明，他们想出了

00:52:14.290 --> 00:52:17.890
更好的攻击旧方法

00:52:16.300 --> 00:52:19.930
算法，当然还有计算

00:52:17.890 --> 00:52:21.690
随着时间的推移会有更多的计算资源

00:52:19.930 --> 00:52:24.069
过去被认为是安全的

00:52:21.690 --> 00:52:25.690
必不可少的安全性以及通往

00:52:24.069 --> 00:52:28.300
谨防做这样的事情

00:52:25.690 --> 00:52:30.310
使用较大的密钥，并且

00:52:28.300 --> 00:52:32.890
如果保持行为兼容性

00:52:30.310 --> 00:52:33.970
您真的需要使用较旧的

00:52:32.890 --> 00:52:35.770
由于某种原因的算法

00:52:33.970 --> 00:52:39.010
通常是一个系统属性，可以让您

00:52:35.770 --> 00:52:40.390
这样做我们还保持了安全性

00:52:39.010 --> 00:52:42.460
与其他图书馆最新

00:52:40.390 --> 00:52:43.839
涉及新的哈希算法

00:52:42.460 --> 00:52:46.210
有一个新的随机数发生器

00:52:43.839 --> 00:52:49.450
他们称之为确定性随机

00:52:46.210 --> 00:52:52.329
位发生器代替性能

00:52:49.450 --> 00:52:55.690
包括星火的前端处理器

00:52:52.329 --> 00:52:57.369
处理器和x64处理器将具有

00:52:55.690 --> 00:53:01.270
专用指令有速度

00:52:57.369 --> 00:53:03.970
加密操作，我们采取

00:53:01.270 --> 00:53:05.440
 JDK nines使用的优点

00:53:03.970 --> 00:53:07.990
所谓的热点内在因素

00:53:05.440 --> 00:53:10.960
基本上热点可以识别某些

00:53:07.990 --> 00:53:13.000
操作很特殊，请更换

00:53:10.960 --> 00:53:15.910
与相应的汇编代码一样

00:53:13.000 --> 00:53:18.069
如果您愿意，他们会很快又好

00:53:15.910 --> 00:53:20.109
对安全性感兴趣的有一个会议

00:53:18.069 --> 00:53:22.720
关于它，实际上现在正在发生

00:53:20.109 --> 00:53:25.450
所以你看不到但你可以

00:53:22.720 --> 00:53:28.270
可能赶上重播，如果没有

00:53:25.450 --> 00:53:31.390
保安队明天要打球

00:53:28.270 --> 00:53:33.130
晚上你可以赶上他们说

00:53:31.390 --> 00:53:36.250
在客户端库上说几句话

00:53:33.130 --> 00:53:37.510
 JavaFX JavaFX也已针对

00:53:36.250 --> 00:53:42.250
即将出现的模块化功能

00:53:37.510 --> 00:53:43.900
平台以及高DPI屏幕

00:53:42.250 --> 00:53:45.609
客户图书馆属

00:53:43.900 --> 00:53:47.109
客户端库的

00:53:45.609 --> 00:53:50.020
完成这是警告的一部分

00:53:47.109 --> 00:53:53.200
再次清理工作，我们的DPI很高

00:53:50.020 --> 00:53:55.180
跨操作系统的字体布局

00:53:53.200 --> 00:53:57.339
已经更新了一些地方

00:53:55.180 --> 00:53:59.130
在JDK中，在其中打开JDK 

00:53:57.339 --> 00:54:01.719
 Oracle JDK使用了不同的代码库

00:53:59.130 --> 00:54:04.809
其中之一是在图形中

00:54:01.719 --> 00:54:06.999
渲染双鱼座一用导管

00:54:04.809 --> 00:54:09.039
和JDK 9他们都被改变了

00:54:06.999 --> 00:54:11.559
使用新的Marlin图形渲染器

00:54:09.039 --> 00:54:13.630
如果您喜欢TIFF文件，现在可以拥有

00:54:11.559 --> 00:54:15.880
支持那些the昧或

00:54:13.630 --> 00:54:16.989
好吧，如果您对客户感兴趣

00:54:15.880 --> 00:54:18.759
再次有一个会议权

00:54:16.989 --> 00:54:21.999
现在你本可以去

00:54:18.759 --> 00:54:23.819
但有一场复兴可以满足

00:54:21.999 --> 00:54:26.710
团队稍后在会议上以及

00:54:23.819 --> 00:54:28.089
少量其他小的库更改

00:54:26.710 --> 00:54:29.619
有帮助

00:54:28.089 --> 00:54:32.410
这是一家便利工厂

00:54:29.619 --> 00:54:34.329
方法，所以您多久写一次

00:54:32.410 --> 00:54:36.219
您想要一组这样的代码

00:54:34.329 --> 00:54:38.650
字符串，所以您有一个哈希集，然后

00:54:36.219 --> 00:54:40.450
就像我初始化它，现在你

00:54:38.650 --> 00:54:42.039
想要使其可修改，所以我有

00:54:40.450 --> 00:54:43.930
像这样有其他电话

00:54:42.039 --> 00:54:45.609
有点麻烦，很多代码

00:54:43.930 --> 00:54:47.529
这应该是一个简单的操作

00:54:45.609 --> 00:54:49.989
可能会说我会做其他事情

00:54:47.529 --> 00:54:51.369
相反，我将使用凸起的点作为列表

00:54:49.989 --> 00:54:54.489
不必所有这些添加呼叫

00:54:51.369 --> 00:54:56.349
和冰去这里有这个包装

00:54:54.489 --> 00:54:57.729
人们还有其他出行方式

00:54:56.349 --> 00:54:59.319
这我什至不展示技巧

00:54:57.729 --> 00:55:02.680
我们使用匿名的双括号

00:54:59.319 --> 00:55:04.329
子类，我知道人们会用它，所以我们

00:55:02.680 --> 00:55:06.670
不，我们不必再这样做了

00:55:04.329 --> 00:55:11.859
在JDK 9中，我们只能使用这样的代码

00:55:06.670 --> 00:55:13.869
啊，这不好，简短，是的，是的

00:55:11.859 --> 00:55:16.630
谢谢，是斯图尔特·马克的

00:55:13.869 --> 00:55:18.549
工作这是怎么回事

00:55:16.630 --> 00:55:20.859
列表上名为的静态工厂方法

00:55:18.549 --> 00:55:22.989
设置并映射它们返回的值不可修改

00:55:20.859 --> 00:55:24.849
收藏以确保人们不会

00:55:22.989 --> 00:55:27.099
取决于我们的迭代顺序

00:55:24.849 --> 00:55:29.799
随机将其用于集合和地图，而不用于

00:55:27.099 --> 00:55:31.479
列表，如果您想了解更多有关

00:55:29.799 --> 00:55:33.219
这是斯图尔特标记谁添加了这个

00:55:31.479 --> 00:55:37.749
功能正在召开会议

00:55:33.219 --> 00:55:40.359
会议Java的后续集合

00:55:37.749 --> 00:55:41.920
 util对象具有一些实用程序

00:55:40.359 --> 00:55:43.690
常见的编程任务有一些

00:55:41.920 --> 00:55:46.630
更多的null处理有一些方法

00:55:43.690 --> 00:55:49.269
拿TD写作问题指数

00:55:46.630 --> 00:55:51.400
检查几率和结束

00:55:49.269 --> 00:55:53.410
数学前沿我们支持

00:55:51.400 --> 00:55:55.390
保险丝乘加运算是

00:55:53.410 --> 00:55:58.089
也将有内在的支持

00:55:55.390 --> 00:56:00.609
如果您愿意，可以尽快使用其他处理器

00:55:58.089 --> 00:56:02.170
扎根您现在不仅可以

00:56:00.609 --> 00:56:03.910
取一些双精度值，但也

00:56:02.170 --> 00:56:06.969
大十进制值并开始您的

00:56:03.910 --> 00:56:09.430
某些人可能会发现有用的价值观是

00:56:06.969 --> 00:56:10.359
字典数组比较和

00:56:09.430 --> 00:56:12.519
 Java数组

00:56:10.359 --> 00:56:15.009
这些也有内在的支持，所以

00:56:12.519 --> 00:56:16.359
他们在处理器上运行得很好并且很快

00:56:15.009 --> 00:56:17.829
并发编程中有一些

00:56:16.359 --> 00:56:20.529
在那里更新超时

00:56:17.829 --> 00:56:22.630
未来的发展，如果你做火箭

00:56:20.529 --> 00:56:24.939
科学类的并发东西

00:56:22.630 --> 00:56:27.130
他们是invar处理的有趣的事情

00:56:24.939 --> 00:56:30.789
与c ++中的功能相当

00:56:27.130 --> 00:56:32.799
原子，所以总的来说

00:56:30.789 --> 00:56:34.539
 jdk 9中的基本变化

00:56:32.799 --> 00:56:37.150
模块化，但还有很多其他

00:56:34.539 --> 00:56:40.929
功能也包括完成

00:56:37.150 --> 00:56:43.479
项目硬币和项目的计划工作

00:56:40.929 --> 00:56:45.249
 lambda和这些功能旨在

00:56:43.479 --> 00:56:47.679
支持长期发展并提供帮助

00:56:45.249 --> 00:56:50.410
简化向新版本的过渡

00:56:47.679 --> 00:56:52.359
时间，如果你想找出是什么

00:56:50.410 --> 00:56:52.779
发生的事情，你可以跟随开放

00:56:52.359 --> 00:56:56.170
 JDK 

00:56:52.779 --> 00:56:59.380
现在可以使用EA帐单了

00:56:56.170 --> 00:57:02.769
您的评估，以便我接受

00:56:59.380 --> 00:57:05.259
一两分钟的一些问题

00:57:02.769 --> 00:57:07.869
是幻灯片的网址，您也可以

00:57:05.259 --> 00:57:11.529
向这个标签发布问题，并

00:57:07.869 --> 00:57:23.309
请确保下载jk9 

00:57:11.529 --> 00:57:23.309
建立评估谢谢你的问题

00:57:26.219 --> 00:57:32.140
问题是房子的o 

00:57:30.249 --> 00:57:34.059
它为它使用完美的哈希

00:57:32.140 --> 00:57:35.469
我不相信会这样，但是那会是

00:57:34.059 --> 00:57:38.709
一个很好的问题要问

00:57:35.469 --> 00:57:41.099
斯图尔特在晚些时候的会议

00:57:38.709 --> 00:57:41.099
那次会议

00:57:52.319 --> 00:57:58.029
所以问题是关于更高

00:57:55.000 --> 00:57:59.650
平面字符和字符串不是

00:57:58.029 --> 00:58:01.390
鉴于新的变化

00:57:59.650 --> 00:58:03.880
内部代表，所以阿姨

00:58:01.390 --> 00:58:05.079
舞者是不便还是不便

00:58:03.880 --> 00:58:07.569
不方便

00:58:05.079 --> 00:58:18.009
今天是以前

00:58:07.569 --> 00:58:19.180
得到代理巴黎很好

00:58:18.009 --> 00:58:21.759
速度相对速度不同

00:58:19.180 --> 00:58:24.160
工作运作是为了尝试

00:58:21.759 --> 00:58:25.240
没有不必要的退化

00:58:24.160 --> 00:58:26.799
性能，所以可能会有一些

00:58:25.240 --> 00:58:30.329
新产品运行缓慢

00:58:26.799 --> 00:58:30.329
编码，但其他更快

00:58:30.960 --> 00:58:34.559
不同的人想要不同的东西

00:58:39.710 --> 00:58:42.710
是的

00:58:53.859 --> 00:59:00.009
所以问题是你能得到吗

00:58:56.920 --> 00:59:01.930
围绕非显着类型的钻石

00:59:00.009 --> 00:59:03.759
通过使用特定的类型参数是

00:59:01.930 --> 00:59:07.829
你当然可以基本上不

00:59:03.759 --> 00:59:09.789
二手钻石或尝试影响

00:59:07.829 --> 00:59:13.769
正在进行的推理

00:59:09.789 --> 00:59:17.289
值得注意的是，但由于

00:59:13.769 --> 00:59:18.579
目的，所以这是一个后备，但我们

00:59:17.289 --> 00:59:20.170
确实想支持它

00:59:18.579 --> 00:59:22.119
在这种情况下的推论

00:59:20.170 --> 00:59:30.400
实际发生的不好是值得注意的

00:59:22.119 --> 00:59:32.680
类型，所以问题是什么

00:59:30.400 --> 00:59:35.410
 EI和EI之间的差异

00:59:32.680 --> 00:59:37.690
最新的拼图，所以拼图功能

00:59:35.410 --> 00:59:40.269
目前且一直在

00:59:37.690 --> 00:59:42.640
主线EI账单一段时间

00:59:40.269 --> 00:59:44.650
拼图团队，他们还有更多工作要做

00:59:42.640 --> 00:59:46.539
探索性工作

00:59:44.650 --> 00:59:49.119
然后一旦稳定下来

00:59:46.539 --> 00:59:51.759
进入拼图火车，然后

00:59:49.119 --> 00:59:57.640
一旦稳定下来，他们就把它放进去

00:59:51.759 --> 00:59:58.719
其他EI账单对吧

00:59:57.640 --> 01:00:01.319
流血的边缘多一点

00:59:58.719 --> 01:00:01.319
实验性的

01:00:08.609 --> 01:00:14.320
问题是安全性

01:00:11.680 --> 01:00:16.810
更新和使用消除

01:00:14.320 --> 01:00:18.520
我不知道jk9中的排名库

01:00:16.810 --> 01:00:20.050
但副手肖恩·穆兰（Sean Mullan）和其他人

01:00:18.520 --> 01:00:21.460
安全生命团队中的人员将

01:00:20.050 --> 01:00:26.050
将能够回答该问题

01:00:21.460 --> 01:00:28.349
轻而易举地虚张声势，我认为

01:00:26.050 --> 01:00:28.349
更多问题

01:00:39.529 --> 01:00:43.289
所以问题在向后

01:00:41.670 --> 01:00:44.640
兼容性，所以您是否询问J 

01:00:43.289 --> 01:00:47.059
黛博拉扫描或你是谁

01:00:44.640 --> 01:00:47.059
询问

01:01:02.330 --> 01:01:06.110
我不确定您的问题

01:01:04.310 --> 01:01:09.430
我想我会在这里离线回答

01:01:06.110 --> 01:01:09.430
所以谢谢你的光临

