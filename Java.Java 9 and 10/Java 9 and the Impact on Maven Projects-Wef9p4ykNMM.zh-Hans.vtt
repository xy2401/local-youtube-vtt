WEBVTT
Kind: captions
Language: zh-Hans

00:00:04.620 --> 00:00:14.219
好的，大家下午好

00:00:10.860 --> 00:00:16.350
我叫罗伯·索尔特（Rob Salt） 

00:00:14.219 --> 00:00:20.119
 Apache Maven项目，我要去

00:00:16.350 --> 00:00:23.310
谈论我所做的工作

00:00:20.119 --> 00:00:29.249
支持Java 940，但您可能拥有

00:00:23.310 --> 00:00:31.320
这个项目引用了Java的成功

00:00:29.249 --> 00:00:34.680
 9取决于ID和

00:00:31.320 --> 00:00:37.380
像maven这样的构建工具不是

00:00:34.680 --> 00:00:40.140
实际上仅适用于Java 9，但是

00:00:37.380 --> 00:00:43.020
对于每个Java版本，但在这种情况下

00:00:40.140 --> 00:00:45.720
 Java 9拥有许多新功能

00:00:43.020 --> 00:00:56.820
这可能是非常非常

00:00:45.720 --> 00:01:01.290
重要，所以什么时候开始

00:00:56.820 --> 00:01:05.519
始于2004年13 

00:01:01.290 --> 00:01:09.799
 Java 9发行版，并在2015年发布

00:01:05.519 --> 00:01:12.509
拼图的抢先体验版本

00:01:09.799 --> 00:01:15.270
拼图的抢先体验版本是zip 

00:01:12.509 --> 00:01:18.179
文件，这只是解压缩的问题

00:01:15.270 --> 00:01:21.119
并将其放在您的系统上

00:01:18.179 --> 00:01:24.569
另一个9 9 1的另一个G是一个

00:01:21.119 --> 00:01:27.630
向导，它将是的新默认设置

00:01:24.569 --> 00:01:35.340
您的系统，因此我更喜欢

00:01:27.630 --> 00:01:41.340
使用拼图，所以我们面临挑战

00:01:35.340 --> 00:01:43.319
我们说我们要支持Java 

00:01:41.340 --> 00:01:46.170
 9与Maven 3 Todo 

00:01:43.319 --> 00:01:49.920
现在我们在Maven 3.3 

00:01:46.170 --> 00:01:53.819
第九，我们只想支持

00:01:49.920 --> 00:01:55.850
 9通过升级插件，这就是我们的

00:01:53.819 --> 00:01:55.850
挑战

00:01:57.120 --> 00:02:04.600
我将要如何测试一下

00:02:00.100 --> 00:02:08.649
标准升级是使用指定Java 

00:02:04.600 --> 00:02:10.479
家，您将它指向JDK 9 

00:02:08.649 --> 00:02:12.790
验证源和目标在此

00:02:10.479 --> 00:02:16.240
案例，因为Java 9最低

00:02:12.790 --> 00:02:19.060
受支持的版本适用于源代码和

00:02:16.240 --> 00:02:21.910
目标是6，所以如果您有Java 5 

00:02:19.060 --> 00:02:25.720
项目，您将不得不使用叉子和

00:02:21.910 --> 00:02:29.470
参考不同的jdk，所以这也

00:02:25.720 --> 00:02:31.930
意味着Maven的运行时不会

00:02:29.470 --> 00:02:38.500
必须与JDK完全相同

00:02:31.930 --> 00:02:41.410
由maven编译器插件之一使用

00:02:38.500 --> 00:02:45.910
做时最有趣的事情

00:02:41.410 --> 00:02:48.880
对我们来说这是深度260 

00:02:45.910 --> 00:02:52.570
大部分封装在内部API中，因此

00:02:48.880 --> 00:02:56.459
内森（Nathan）将运行它会证明

00:02:52.570 --> 00:03:03.459
我们没有使用任何内部api 

00:02:56.459 --> 00:03:06.040
所以到目前为止，第一个Java发生了什么

00:03:03.459 --> 00:03:09.700
 9e抢先体验版就是其中之一

00:03:06.040 --> 00:03:13.060
从2014年开始，我们几乎没有

00:03:09.700 --> 00:03:15.130
关于系统的问题

00:03:13.060 --> 00:03:18.489
属性结合null 

00:03:15.130 --> 00:03:21.280
值，但恢复得很快

00:03:18.489 --> 00:03:24.760
没有很多项目

00:03:21.280 --> 00:03:27.340
问题，但是第一个

00:03:24.760 --> 00:03:29.860
拼图的抢先体验版约占99％ 

00:03:27.340 --> 00:03:34.450
 Java Maven项目失败

00:03:29.860 --> 00:03:37.090
这样一开始我们就编译

00:03:34.450 --> 00:03:39.459
注意到这我以为可能有一个

00:03:37.090 --> 00:03:42.370
核心问题，但实际上不是

00:03:39.459 --> 00:03:45.000
由Java 2提供程序在

00:03:42.370 --> 00:03:49.420
与系统类加载器结合

00:03:45.000 --> 00:03:53.290
我们没有使用Java可执行文件来

00:03:49.420 --> 00:03:55.810
编译我们正在使用Java工具的代码

00:03:53.290 --> 00:03:57.120
提供程序，因此我们可以使用Java来实现

00:03:55.810 --> 00:04:01.170
本身

00:03:57.120 --> 00:04:05.819
因此，此问题已在72秒内修复并发布

00:04:01.170 --> 00:04:08.280
几个小时直到现在我们不得不改变

00:04:05.819 --> 00:04:11.810
 Mayville核心中的零行代码

00:04:08.280 --> 00:04:11.810
在Java 9上运行

00:04:14.120 --> 00:04:20.690
大约10％的工作与

00:04:17.120 --> 00:04:26.570
 Maven，这是相关列表

00:04:20.690 --> 00:04:33.490
会话太短而无法处理的作业

00:04:26.570 --> 00:04:39.520
他们所有，所以这将是议程， 

00:04:33.490 --> 00:04:42.940
让我们从utf8属性文件开始

00:04:39.520 --> 00:04:46.880
所以特别是对于

00:04:42.940 --> 00:04:50.570
熟悉特殊字符集

00:04:46.880 --> 00:04:54.710
知道有时候你会变得非常

00:04:50.570 --> 00:05:02.990
输出中的怪异字符

00:04:54.710 --> 00:05:08.900
应该解决这个问题，让我们来看一下

00:05:02.990 --> 00:05:16.060
在这种情况下，我们有这种文件

00:05:08.900 --> 00:05:19.940
这个e由eclipse翻译

00:05:16.060 --> 00:05:21.950
正确，但这完全取决于

00:05:19.940 --> 00:05:25.100
您正在使用的编辑器，如果这是

00:05:21.950 --> 00:05:36.050
仍然是这种正确的方法

00:05:25.100 --> 00:05:39.700
这样做是为了逃脱它，所以在

00:05:36.050 --> 00:05:43.460
在这种情况下，我们可以像这样运行它

00:05:39.700 --> 00:05:46.190
在上方，您会看到Java 8的结果， 

00:05:43.460 --> 00:05:49.840
在Java行下方，这是基于ISO的

00:05:46.190 --> 00:05:52.840
属性文件，现在让我们来做

00:05:49.840 --> 00:05:52.840
 utf-8 

00:05:54.570 --> 00:06:03.970
你看到这个教堂的人

00:06:00.250 --> 00:06:05.350
熟悉utf-8和各种

00:06:03.970 --> 00:06:08.050
东西

00:06:05.350 --> 00:06:09.820
如果运行此命令和CODIS，您将获得

00:06:08.050 --> 00:06:12.520
总是这样，但是你会

00:06:09.820 --> 00:06:15.960
看到使用JDK 9不会

00:06:12.520 --> 00:06:15.960
接受没问题

00:06:19.860 --> 00:06:28.270
接下来是关于新版本的字符串

00:06:23.380 --> 00:06:31.030
计划昨天艾伦贝曼已经

00:06:28.270 --> 00:06:34.419
告诉这对

00:06:31.030 --> 00:06:37.570
整个系统中使用它的所有项目

00:06:34.419 --> 00:06:42.370
我们的案例，我们正在使用几个系统

00:06:37.570 --> 00:06:45.610
属性系统属性，因此在

00:06:42.370 --> 00:06:45.970
中间你看到的是原始版本

00:06:45.610 --> 00:06:49.419
方案

00:06:45.970 --> 00:06:53.740
在右侧，您会看到更深的帖子，因此

00:06:49.419 --> 00:06:56.650
为什么这是一个问题我们要做的是我们要做的

00:06:53.740 --> 00:06:58.870
一个版本和点拆分，并采取

00:06:56.650 --> 00:07:00.070
第二个参数，在这种情况下，您

00:06:58.870 --> 00:07:03.400
将使索引超出范围

00:07:00.070 --> 00:07:06.010
索引异常，以防万一

00:07:03.400 --> 00:07:08.740
像这样的东西

00:07:06.010 --> 00:07:11.430
版本有问题，所以这

00:07:08.740 --> 00:07:14.950
已经解决了几个

00:07:11.430 --> 00:07:15.460
项目，那么这个问题就在专家

00:07:14.950 --> 00:07:19.090
封存者

00:07:15.460 --> 00:07:22.030
并固定在3.1和几乎每个

00:07:19.090 --> 00:07:25.090
包装插件取决于它，因此

00:07:22.030 --> 00:07:28.330
主要是三个点哦，准备好了

00:07:25.090 --> 00:07:31.570
释放的行家完全一样

00:07:28.330 --> 00:07:34.180
 war插件和maven air插件将

00:07:31.570 --> 00:07:36.940
很快发布，包括此修复程序

00:07:34.180 --> 00:07:39.100
而且Maven Java插件已经存在

00:07:36.940 --> 00:07:43.289
固定，也许还有更多，但我们

00:07:39.100 --> 00:07:43.289
必须打这个问题是

00:07:45.880 --> 00:07:57.850
下一个杰克将为所有

00:07:48.980 --> 00:07:57.850
平台版本这里的问题是

00:07:58.120 --> 00:08:06.380
在某些情况下，它可能导致泄漏等级

00:08:01.460 --> 00:08:11.410
从jdk官方要求

00:08:06.380 --> 00:08:14.570
同时运行Java和Java C 

00:08:11.410 --> 00:08:16.370
源目标，以及启动类

00:08:14.570 --> 00:08:20.480
路径，我很确定没有人

00:08:16.370 --> 00:08:21.710
即使我们添加它也可能不这样做吗

00:08:20.480 --> 00:08:24.310
这是因为我们还有其他解决方案

00:08:21.710 --> 00:08:29.210
但这是官方的方式

00:08:24.310 --> 00:08:34.669
确保您的代码将被编译

00:08:29.210 --> 00:08:38.200
并且还将在运行时运行，所以让我们

00:08:34.669 --> 00:08:38.200
看到问题

00:08:42.930 --> 00:08:48.779
所以这里有一些外套

00:08:50.550 --> 00:09:02.160
这样，我们说它是Java 6 

00:08:59.370 --> 00:09:09.150
应该是Java 6 cot，应该在其上运行

00:09:02.160 --> 00:09:11.700
那是使用笔记本电脑的日食

00:09:09.150 --> 00:09:14.070
已经意识到这是一个问题

00:09:11.700 --> 00:09:18.000
但它带有一些有趣的东西

00:09:14.070 --> 00:09:20.420
它说对匿名班很安慰

00:09:18.000 --> 00:09:20.420
让我们做

00:09:26.750 --> 00:09:34.390
我想我做到了，没关系

00:09:41.550 --> 00:09:49.190
专案

00:09:43.770 --> 00:09:49.190
好的，我们再次遇到错误

00:09:56.639 --> 00:10:00.089
它曾经工作

00:10:04.860 --> 00:10:13.720
好吧，我可以做到，如果我没问题

00:10:08.709 --> 00:10:15.610
只是说在这种情况下，例如40 

00:10:13.720 --> 00:10:22.689
这里不需要，所以在这种情况下，我

00:10:15.610 --> 00:10:25.629
将保存它，但是此流方法是

00:10:22.689 --> 00:10:30.009
用Java引入的与

00:10:25.629 --> 00:10:36.279
即使我们说这个

00:10:30.009 --> 00:10:41.310
这些应该是Java 6代码

00:10:36.279 --> 00:10:41.310
 Java 8方法不抱怨

00:10:45.689 --> 00:10:52.259
我们可以在这里进行干净的编译

00:10:49.540 --> 00:10:52.259
这节课

00:10:52.950 --> 00:10:56.760
它说法案成功

00:10:57.850 --> 00:11:09.910
如果我要用Java 7运行它

00:11:01.590 --> 00:11:13.810
现在，Mavenlink再次认识到

00:11:09.910 --> 00:11:16.840
编译失败的方式变色

00:11:13.810 --> 00:11:19.900
认为这是下一个新功能

00:11:16.840 --> 00:11:25.240
版本的Maven，所以我在这里使用它

00:11:19.900 --> 00:11:28.840
对于演示，这是真正的问题

00:11:25.240 --> 00:11:33.760
我们只有几种方法

00:11:28.840 --> 00:11:41.800
在Java 8中以及在编译时已知

00:11:33.760 --> 00:11:43.750
与Java 8不能识别

00:11:41.800 --> 00:11:46.900
第一个mavis解决方案已经

00:11:43.750 --> 00:11:51.310
有使用Maven工具链

00:11:46.900 --> 00:11:54.490
带有的插件，您可以

00:11:51.310 --> 00:11:58.840
指定将JDK开关安装在

00:11:54.490 --> 00:12:02.200
您的系统的工具链XML可以是

00:11:58.840 --> 00:12:05.560
放在两个地方一个是等式

00:12:02.200 --> 00:12:08.200
在底部的两个文件夹中，自5月以来

00:12:05.560 --> 00:12:12.090
 3.3在Econ中也可用

00:12:08.200 --> 00:12:12.090
惊人的发行文件夹

00:12:14.170 --> 00:12:19.840
另一个解决方案是使用动物

00:12:17.200 --> 00:12:21.840
从不Maven插件

00:12:19.840 --> 00:12:24.580
因为它被称为动物嗅探器

00:12:21.840 --> 00:12:26.980
早期版本使用的代号

00:12:24.580 --> 00:12:32.560
 Java的例子，例如老虎

00:12:26.980 --> 00:12:35.050
野马海豚，根据该ID，我们

00:12:32.560 --> 00:12:36.840
创造了动物嗅探器，所以

00:12:35.050 --> 00:12:39.310
你在这里有签名

00:12:36.840 --> 00:12:48.490
包含所有类和方法

00:12:39.310 --> 00:12:52.240
仅用于死亡和JRE，现在用于

00:12:48.490 --> 00:12:56.200
 Java 9有一个新的解决方案

00:12:52.240 --> 00:13:01.360
 -实际上从最新版本发布

00:12:56.200 --> 00:13:04.450
拼图是--释放，这就是

00:13:01.360 --> 00:13:09.930
就像说这个来源一样- 

00:13:04.450 --> 00:13:09.930
目标和em的无引导路径

00:13:13.400 --> 00:13:18.770
你可以认为它无法像

00:13:15.470 --> 00:13:20.720
这只是在发布平台上

00:13:18.770 --> 00:13:23.240
特定版本，但您也可以使用

00:13:20.720 --> 00:13:26.360
属性可能尚未编译

00:13:23.240 --> 00:13:28.250
发布，如果您同时拥有来源和

00:13:26.360 --> 00:13:38.210
然后指定目标和释放

00:13:28.250 --> 00:13:41.630
发布将获胜，所以让我们现在就来看

00:13:38.210 --> 00:13:54.350
我要用工具更改进行编译

00:13:41.630 --> 00:13:56.840
在这种情况下已编辑为

00:13:54.350 --> 00:13:59.420
你可以看到我正在用Java 8运行它

00:13:56.840 --> 00:14:02.900
没有抱怨的那个

00:13:59.420 --> 00:14:06.230
这个编译失败的地方

00:14:02.900 --> 00:14:09.680
您会看到工具更换的版本

00:14:06.230 --> 00:14:15.230
在这种情况下，Java 7是因为

00:14:09.680 --> 00:14:17.180
我已经在系统上安装了一个

00:14:15.230 --> 00:14:21.350
看到医学飞行员插件会

00:14:17.180 --> 00:14:23.660
从工具链中使用它，并且正在使用

00:14:21.350 --> 00:14:26.090
再次使用Java 7，我们已经看到了

00:14:23.660 --> 00:14:29.980
在此之前，您使用

00:14:26.090 --> 00:14:29.980
 Java 7将出现编译错误

00:14:30.790 --> 00:14:34.970
所以现在我们要用

00:14:33.680 --> 00:14:37.780
动物嗅探器

00:14:34.970 --> 00:14:37.780
 Maven插件

00:14:40.930 --> 00:14:47.510
再次，我们建立失败的原因是

00:14:44.839 --> 00:14:50.120
完成成功，并且

00:14:47.510 --> 00:14:54.490
之后的动物信息

00:14:50.120 --> 00:14:59.570
开始杰克，它检测到这

00:14:54.490 --> 00:15:03.550
 java.util这个梦想是未知的

00:14:59.570 --> 00:15:03.550
每个消费者数40 

00:15:05.750 --> 00:15:12.050
然后我们有了JDK 9或Java 9 

00:15:09.890 --> 00:15:15.320
选项，我们可以将其指定为

00:15:12.050 --> 00:15:17.030
发布，所以我们现在在5月15日为Phi和

00:15:15.320 --> 00:15:24.620
我们在这种情况下用

00:15:17.030 --> 00:15:27.700
该属性可能具有编译器版本，并且

00:15:24.620 --> 00:15:33.470
再次比较抱怨

00:15:27.700 --> 00:15:35.690
代码中的失败，所以解决方案

00:15:33.470 --> 00:15:39.830
那里已经有

00:15:35.690 --> 00:15:48.730
专家现在可能有更好的选择

00:15:39.830 --> 00:15:51.340
现在让我们看看Java 9中的解决方案

00:15:48.730 --> 00:15:53.780
关于前向兼容性

00:15:51.340 --> 00:16:01.490
建议我们有这样的东西我们

00:15:53.780 --> 00:16:04.010
有一个特定的代码，我们想做

00:16:01.490 --> 00:16:06.200
一些计算，对于Java 8 

00:16:04.010 --> 00:16:09.290
我们可以使用数据API，因为它

00:16:06.200 --> 00:16:11.930
非常强大，否则我们可以做到

00:16:09.290 --> 00:16:18.140
基于此，但还有更多工作要做

00:16:11.930 --> 00:16:22.220
这样，我们希望能够运行此

00:16:18.140 --> 00:16:25.010
 Java 7中的代码有两种选择

00:16:22.220 --> 00:16:30.740
在这种情况下，您要么

00:16:25.010 --> 00:16:35.840
可以使用JDK 8进行编译，也可以进行编译

00:16:30.740 --> 00:16:39.370
它与JDK 1.7，但对我使用反射

00:16:35.840 --> 00:16:39.370
使用日期/时间API 

00:16:40.870 --> 00:16:49.370
为此，有Nautilus jar文件

00:16:44.240 --> 00:16:53.390
一个新的臂架到3/8，对于那些

00:16:49.370 --> 00:16:56.990
昨天与艾伦的会议

00:16:53.390 --> 00:17:00.830
贝特曼已经有一个例子

00:16:56.990 --> 00:17:03.590
关于它，这就是乔希

00:17:00.830 --> 00:17:06.440
结构看起来像这样，所以我们有一个

00:17:03.590 --> 00:17:09.670
 jar根有爪abc和d 

00:17:06.440 --> 00:17:13.250
然后你有一个元信息

00:17:09.670 --> 00:17:18.110
目录版本，在这种情况下为8 

00:17:13.250 --> 00:17:21.920
和9的具体实现

00:17:18.110 --> 00:17:24.950
这些类当然不是Java 8 

00:17:21.920 --> 00:17:27.290
知道多释放罐，所以

00:17:24.950 --> 00:17:30.800
只有40倍的例子来了解

00:17:27.290 --> 00:17:33.110
如果我们正在做它正在做的事情

00:17:30.800 --> 00:17:35.600
会将其翻译回源

00:17:33.110 --> 00:17:36.380
文件可能看起来会有些东西

00:17:35.600 --> 00:17:38.180
像这样

00:17:36.380 --> 00:17:41.240
所以我们有项目根

00:17:38.180 --> 00:17:44.600
带有这些Java文件的源Java主代码

00:17:41.240 --> 00:17:48.710
对于abc和d，我们有一个来源

00:17:44.600 --> 00:17:51.620
 Java 8的a和b以及一种

00:17:48.710 --> 00:17:57.590
主要和Java 9因此，如果您

00:17:51.620 --> 00:18:00.650
只有一个Maven项目一个罐子

00:17:57.590 --> 00:18:02.570
将与Maven一起工作

00:18:00.650 --> 00:18:05.150
由于执行而引起的任何问题

00:18:02.570 --> 00:18:07.100
您可以指定的代码块，但大多数ID 

00:18:05.150 --> 00:18:11.410
抱怨它，因为他们只能

00:18:07.100 --> 00:18:14.900
每个制作的项目使用一个Java版本

00:18:11.410 --> 00:18:18.920
所以我们一直在考虑，我们

00:18:14.900 --> 00:18:21.920
该解决方案附带了一个多模块

00:18:18.920 --> 00:18:25.910
项目它非常理想，您

00:18:21.920 --> 00:18:28.190
现在可以使用它了

00:18:25.910 --> 00:18:31.270
从根本上讲，我们拥有军事空间

00:18:28.190 --> 00:18:35.240
 Java的ABC和df--版本

00:18:31.270 --> 00:18:39.470
 Java 8的赛车比赛

00:18:35.240 --> 00:18:42.590
因为我们也用于9 

00:18:39.470 --> 00:18:44.900
最后我们有一个汇编描述符

00:18:42.590 --> 00:18:45.570
组装所有那些回到一个罐子

00:18:44.900 --> 00:18:48.510
文件

00:18:45.570 --> 00:18:56.090
您可以从

00:18:48.510 --> 00:18:56.090
下面的链接，让我们看看它是如何工作的

00:18:59.440 --> 00:19:02.770
所以在这里

00:19:05.669 --> 00:19:21.659
在这里，我们有军队的路线

00:19:11.669 --> 00:19:29.669
子模块Nash Cassie，这是基础

00:19:21.659 --> 00:19:31.619
与Java 7 Java 8和第一个没有

00:19:29.669 --> 00:19:34.200
我正在使用的Felicia Eclipse不知道

00:19:31.619 --> 00:19:41.190
 Java 9的诞生，所以它在抱怨

00:19:34.200 --> 00:19:43.979
这段代码这是一个具体方法

00:19:41.190 --> 00:19:45.929
在Java 9中已经引入

00:19:43.979 --> 00:19:54.809
因此，它在抱怨

00:19:45.929 --> 00:19:59.519
所以让我们执行它，所以我在做数学

00:19:54.809 --> 00:20:01.979
大多数时候我最干净

00:19:59.519 --> 00:20:07.769
会说从不使用数学全新安装

00:20:01.979 --> 00:20:13.859
除非你知道自己在做什么， 

00:20:07.769 --> 00:20:14.639
在这里，我们建立成功，所以我的原因

00:20:13.859 --> 00:20:17.700
做了

00:20:14.639 --> 00:20:19.559
 Maven全新安装而不是可能

00:20:17.700 --> 00:20:22.950
验证是因为我想给你看

00:20:19.559 --> 00:20:25.229
在这种情况下跳过安装

00:20:22.950 --> 00:20:29.700
而且在

00:20:25.229 --> 00:20:34.219
部署，以便子产品不会

00:20:29.700 --> 00:20:34.219
最终出现在任何存储库中

00:20:41.299 --> 00:20:48.840
所以让我们看一下输出

00:20:45.360 --> 00:20:52.529
使用Java 7运行它将非常简单

00:20:48.840 --> 00:20:54.629
 Java 8的基础当然相同

00:20:52.529 --> 00:20:58.019
因为它还不了解最多

00:20:54.629 --> 00:21:01.440
在Java 9中发布了jar 

00:20:58.019 --> 00:21:04.649
将来自基础矿山，如果我们有

00:21:01.440 --> 00:21:09.110
看一下你可以的代码

00:21:04.649 --> 00:21:11.330
认识到它在这里得到

00:21:09.110 --> 00:21:19.100
这是我的

00:21:11.330 --> 00:21:22.499
所以它确实选对了课程

00:21:19.100 --> 00:21:26.970
这不是这个Aires的内容

00:21:22.499 --> 00:21:32.639
 jar，以便您在此处识别文件夹8 

00:21:26.970 --> 00:21:36.590
 ＆9我们有一个8 8 4 9的a 

00:21:32.639 --> 00:21:36.590
首先拥有基地

00:21:41.220 --> 00:21:48.280
就像我说的，这只是证明

00:21:43.900 --> 00:21:50.530
概念开始，我们正在思考

00:21:48.280 --> 00:21:54.160
关于我们想要的一些改进

00:21:50.530 --> 00:21:57.340
应用我们要介绍新的表演

00:21:54.160 --> 00:22:00.490
输入类似sabji R的名称

00:21:57.340 --> 00:22:03.310
不进行任何安装或部署

00:22:00.490 --> 00:22:08.760
还必须考虑依赖关系

00:22:03.310 --> 00:22:12.970
例如，如果您有Java 8 

00:22:08.760 --> 00:22:15.280
可以有多个模块

00:22:12.970 --> 00:22:18.490
那里有特定的依赖关系，我们需要

00:22:15.280 --> 00:22:20.350
将它们放入新的专用配置文件中

00:22:18.490 --> 00:22:22.270
当然，我们要摆脱

00:22:20.350 --> 00:22:26.530
程序集描述符应该解决

00:22:22.270 --> 00:22:32.710
未来的盒子，所以我们

00:22:26.530 --> 00:22:37.690
仍在进行中

00:22:32.710 --> 00:22:40.300
让我们转到重要的运行时映像

00:22:37.690 --> 00:22:42.280
您可能已经知道， 

00:22:40.300 --> 00:22:44.950
整个完整结构已经改变， 

00:22:42.280 --> 00:22:48.310
这对行家有什么影响

00:22:44.950 --> 00:22:53.110
好吧，一些项目取决于工具

00:22:48.310 --> 00:22:55.530
顶罐，它已被删除，但

00:22:53.110 --> 00:22:57.670
大多数mave插件已经

00:22:55.530 --> 00:23:00.610
意识到这一点，他们有几个

00:22:57.670 --> 00:23:05.290
应对这种情况的方案

00:23:00.610 --> 00:23:08.220
我们工作的一个项目的情况

00:23:05.290 --> 00:23:13.270
与自定义医生上下文有关

00:23:08.220 --> 00:23:19.600
需要烤面包OTR，我们必须这样做

00:23:13.270 --> 00:23:24.660
修正个人资料，以防万一

00:23:19.600 --> 00:23:29.470
那是JDK在9以下

00:23:24.660 --> 00:23:36.670
表示在这种情况下不包括9 

00:23:29.470 --> 00:23:38.140
可以使用此工具将您接起

00:23:36.670 --> 00:23:41.710
从系统路径

00:23:38.140 --> 00:23:46.270
这实际上很酷

00:23:41.710 --> 00:23:48.880
因为行家我们作为一个项目想要

00:23:46.270 --> 00:23:54.150
摆脱这个系统范围和

00:23:48.880 --> 00:23:55.299
 Java 9那条路看起来不错

00:23:54.150 --> 00:23:57.910
嗯

00:23:55.299 --> 00:24:01.990
现在让我们最后进入模块

00:23:57.910 --> 00:24:06.100
系统本身已更改

00:24:01.990 --> 00:24:10.270
简而言之，我们在

00:24:06.100 --> 00:24:13.210
格式的角度，所以我们有

00:24:10.270 --> 00:24:17.410
此模块信息Java文件，它具有

00:24:13.210 --> 00:24:20.860
您可以指定几个不同的内容

00:24:17.410 --> 00:24:22.840
暴露的包，你也可以

00:24:20.860 --> 00:24:26.080
指定两者所需的模块

00:24:22.840 --> 00:24:28.179
建立时间和运行时间，您可以

00:24:26.080 --> 00:24:38.470
明确说明的用法和实现

00:24:28.179 --> 00:24:41.830
服务器SBI，所以这是一个例子

00:24:38.470 --> 00:24:44.530
目前仍在上网

00:24:41.830 --> 00:24:48.460
但您可能会发现它仍然是

00:24:44.530 --> 00:24:50.740
谈论公共和静态一些

00:24:48.460 --> 00:24:53.440
潜入请求部分

00:24:50.740 --> 00:25:00.760
与少女的依赖关系密切

00:24:53.440 --> 00:25:04.390
所以昨天当我听到谈话

00:25:00.760 --> 00:25:07.480
关于艾伦，这是关于

00:25:04.390 --> 00:25:11.950
需要模型修改器public is 

00:25:07.480 --> 00:25:15.309
可能会传递，所以我有

00:25:11.950 --> 00:25:17.950
今天早上要更改标题

00:25:15.309 --> 00:25:21.570
剩下的就是我说过的

00:25:17.950 --> 00:25:21.570
可比的

00:25:22.210 --> 00:25:27.490
这实际上是对其他项目的提示

00:25:24.519 --> 00:25:29.590
使用这个罐子作为依赖，所以它有

00:25:27.490 --> 00:25:38.440
对您正在工作的项目没有影响

00:25:29.590 --> 00:25:41.169
实际上行之有效的最佳实践是

00:25:38.440 --> 00:25:44.740
始终信任传递依赖

00:25:41.169 --> 00:25:47.169
指定每个类的依赖项

00:25:44.740 --> 00:25:49.649
您正在使用，其原因是

00:25:47.169 --> 00:25:54.730
假设我有一个使用

00:25:49.649 --> 00:25:57.220
 spring spring使用Commons日志记录和

00:25:54.730 --> 00:25:59.169
因此，Commons Logging是

00:25:57.220 --> 00:26:03.820
在课程路径上可用，所以我可以使用

00:25:59.169 --> 00:26:07.240
在我的项目中，春天决定放弃

00:26:03.820 --> 00:26:13.749
评论日志，我只是

00:26:07.240 --> 00:26:16.899
通过升级spring来更新spring 

00:26:13.749 --> 00:26:19.749
在这里记录下公地的遗失，我

00:26:16.899 --> 00:26:22.029
会得到编译错误甚至

00:26:19.749 --> 00:26:26.110
运行时错误，因此我们说

00:26:22.029 --> 00:26:30.159
始终为每个对象指定依赖项

00:26:26.110 --> 00:26:32.139
使用课程，但是我在和很多人交谈

00:26:30.159 --> 00:26:37.809
昨天冲，她在这说

00:26:32.139 --> 00:26:42.759
情况只会在春天发生

00:26:37.809 --> 00:26:46.539
在Commons日志记录中设置了传递

00:26:42.759 --> 00:26:51.480
但如果方法未公开

00:26:46.539 --> 00:26:56.440
他们不应该那样做

00:26:51.480 --> 00:26:58.779
您注意到它是静态的，或者我看到一封邮件

00:26:56.440 --> 00:27:02.730
有没有建议要改变这一点

00:26:58.779 --> 00:27:06.809
到与

00:27:02.730 --> 00:27:06.809
方法和依赖项可选

00:27:07.320 --> 00:27:14.310
我不确定所有人是否都知道

00:27:10.170 --> 00:27:16.560
我想你们大多数人都可以选择

00:27:14.310 --> 00:27:22.140
可能会使用类似

00:27:16.560 --> 00:27:23.280
提供，但在这里不一样

00:27:22.140 --> 00:27:25.260
建立时间没有区别

00:27:23.280 --> 00:27:27.930
两者都可以使用

00:27:25.260 --> 00:27:32.340
类路径，但在运行时有一个

00:27:27.930 --> 00:27:36.300
为您提供巨大的差异

00:27:32.340 --> 00:27:38.040
可以期待gr可用

00:27:36.300 --> 00:27:40.710
例如表面API，但

00:27:38.040 --> 00:27:44.420
可选的，因此

00:27:40.710 --> 00:27:44.420
实例跳板依赖性

00:27:47.560 --> 00:27:54.590
让我们来看看用例

00:27:52.520 --> 00:27:57.350
知道在左侧，我们有一个

00:27:54.590 --> 00:27:59.570
经典项目，在右侧，我们

00:27:57.350 --> 00:28:02.930
有各种各样的Java也有

00:27:59.570 --> 00:28:06.350
您当然可以拥有的模块信息

00:28:02.930 --> 00:28:10.220
脚趾源测试中的模块信息

00:28:06.350 --> 00:28:12.560
 Java，但是不支持

00:28:10.220 --> 00:28:18.170
我也想知道是否有意义

00:28:12.560 --> 00:28:19.790
把电机信息文件放在那里

00:28:18.170 --> 00:28:24.200
将会与医学飞行员发生

00:28:19.790 --> 00:28:27.920
如果有模块可以很好地插入

00:28:24.200 --> 00:28:31.070
信息文件，它将自动切换

00:28:27.920 --> 00:28:33.290
到你的多路径，所以你没有

00:28:31.070 --> 00:28:37.220
为自己配置一些东西

00:28:33.290 --> 00:28:40.970
使用我在以下情况下使用模块路径

00:28:37.220 --> 00:28:43.910
测试编译和MAIF编译器插件

00:28:40.970 --> 00:28:47.240
将切换到主模块的路径

00:28:43.910 --> 00:28:54.020
源和类路径

00:28:47.240 --> 00:28:57.710
测试源，让我们看看实际情况

00:28:54.020 --> 00:29:02.200
我在考虑多项目

00:28:57.710 --> 00:29:05.690
使用第三方Josh进行多个项目

00:29:02.200 --> 00:29:09.770
我的代码库很大，所以我想

00:29:05.690 --> 00:29:15.320
关于为什么不跟我建立Maven，以及

00:29:09.770 --> 00:29:21.580
我们看看这张照片

00:29:15.320 --> 00:29:21.580
是Apache Maven的整体图

00:29:25.220 --> 00:29:28.730
等一下

00:29:29.900 --> 00:29:34.580
所以我们不会编译整个

00:29:32.870 --> 00:29:37.580
项目，但我们只会编译

00:29:34.580 --> 00:29:39.350
这部分的设置设置是

00:29:37.580 --> 00:29:45.470
实际上是一个描述符

00:29:39.350 --> 00:29:48.860
生成具有Poggio风格的代码

00:29:45.470 --> 00:29:50.570
而且还创造了一个读者和一个

00:29:48.860 --> 00:29:53.720
 settings.xml的编写者，因此

00:29:50.570 --> 00:29:56.059
其实关于settings.xml 

00:29:53.720 --> 00:29:59.780
建立点是关于处理错误和

00:29:56.059 --> 00:30:02.000
将它们组合在一起，以便您

00:29:59.780 --> 00:30:04.160
不必从一个错误转到

00:30:02.000 --> 00:30:06.290
为了解决您的问题

00:30:04.160 --> 00:30:09.730
 settings.xml和设置构建器

00:30:06.290 --> 00:30:14.140
它本身具有各种规则

00:30:09.730 --> 00:30:14.140
例如ID是唯一的

00:30:20.850 --> 00:30:25.830
所以我们要编译这部分

00:30:32.470 --> 00:30:42.910
看起来不错，所以这就是我们所做的

00:30:38.160 --> 00:30:48.210
在开始JDK 9之前，我对我们说的很好

00:30:42.910 --> 00:30:51.870
希望它将与Maven 3.0一起运行

00:30:48.210 --> 00:30:51.870
所以让我们尝试一下

00:30:52.770 --> 00:30:56.430
那又是白色的

00:31:00.780 --> 00:31:10.830
再次建立成功，所以现在

00:31:05.190 --> 00:31:13.350
看起来非常非常好，让我们看一下

00:31:10.830 --> 00:31:16.530
在Maven进行体育运动，看看我们是否

00:31:13.350 --> 00:31:30.990
可以检测到它实际上是在使用

00:31:16.530 --> 00:31:33.450
多路径，所以我们在这里使用调试

00:31:30.990 --> 00:31:36.510
看到它没有使用classpath 

00:31:33.450 --> 00:31:40.200
它只是使用多路径而已

00:31:36.510 --> 00:31:47.130
添加了plexus utils和注释

00:31:40.200 --> 00:31:50.330
长度3现在让我们看看

00:31:47.130 --> 00:31:50.330
刚刚编译了我们

00:31:55.850 --> 00:32:01.140
再次准备

00:31:58.830 --> 00:32:07.080
所以现在我们有一个类的组合

00:32:01.140 --> 00:32:10.230
路径和多路径，所以罐子我们

00:32:07.080 --> 00:32:12.510
在编译过程中已经有了

00:32:10.230 --> 00:32:17.810
在模块路径上，但在这种情况下

00:32:12.510 --> 00:32:17.810
班级路径是J单位和皇后毛孔

00:32:18.110 --> 00:32:24.990
所以这全是基于

00:32:23.310 --> 00:32:32.310
是否提供模块信息文件

00:32:24.990 --> 00:32:38.490
所以你不必做任何事情

00:32:32.310 --> 00:32:42.150
我希望能很好地发现模块名称

00:32:38.490 --> 00:32:44.040
一旦模块名称发布

00:32:42.150 --> 00:32:47.850
有一些文档

00:32:44.040 --> 00:32:50.220
关于这个但是我也希望那个行家

00:32:47.850 --> 00:32:52.110
中央或任何其他存储库管理

00:32:50.220 --> 00:32:56.130
将提供这种信息作为

00:32:52.110 --> 00:32:58.320
好吧，但现在我要做的是

00:32:56.130 --> 00:33:00.930
我改善了田纳西州的行家

00:32:58.320 --> 00:33:03.870
插件，在这种情况下是lisko， 

00:33:00.930 --> 00:33:12.200
将为您显示所有模块的名称

00:33:03.870 --> 00:33:15.060
这些依赖关系，所以在这种情况下，Maven 

00:33:12.200 --> 00:33:17.610
依赖插件仍然是快照

00:33:15.060 --> 00:33:23.330
我尚未发布它，请致电

00:33:17.610 --> 00:33:23.330
列出特定模块上的目标

00:33:27.169 --> 00:33:33.570
如您所见，我们这里有GRU 

00:33:30.659 --> 00:33:37.259
主体工件ID和模块名称

00:33:33.570 --> 00:33:40.200
在这种情况下是普通语和4j 

00:33:37.259 --> 00:33:42.419
电机存储器在此被监禁的单位

00:33:40.200 --> 00:33:45.349
实际使用的是

00:33:42.419 --> 00:33:49.289
与我使用的相同的代码

00:33:45.349 --> 00:33:52.080
解析其他模块的名称，如果

00:33:49.289 --> 00:34:01.769
里面已经有模块信息文件

00:33:52.080 --> 00:34:03.629
 gr它将使用该死名，因此

00:34:01.769 --> 00:34:05.549
那些是图书馆建设者或

00:34:03.629 --> 00:34:09.839
框架构建器或Maven插件

00:34:05.549 --> 00:34:12.109
构建者降低Java版本

00:34:09.839 --> 00:34:16.079
您可以使用更多的项目吗

00:34:12.109 --> 00:34:20.450
但是那也意味着你在那里

00:34:16.079 --> 00:34:20.450
可以使用的工作功能较少

00:34:20.690 --> 00:34:28.530
我们可以在这种情况下添加模块信息吗？ 

00:34:24.299 --> 00:34:34.849
我们可以忽略模块信息

00:34:28.530 --> 00:34:37.440
如果您使用的是Java 8或更低版本

00:34:34.849 --> 00:34:41.700
有一个触发因素，有一个小问题

00:34:37.440 --> 00:34:45.450
使用它，必须编译模块fo 

00:34:41.700 --> 00:34:48.000
与-版本9和所有其他

00:34:45.450 --> 00:34:52.859
源必须与源一起编译

00:34:48.000 --> 00:34:57.990
目标低于9，因此我们必须将

00:34:52.859 --> 00:35:02.130
 Java C的少女，所以有两次

00:34:57.990 --> 00:35:06.240
几种死亡的解决方法

00:35:02.130 --> 00:35:08.279
可以将其分开来，以便

00:35:06.240 --> 00:35:10.440
实例源主Java和短主

00:35:08.279 --> 00:35:12.779
拼图意味着我们只

00:35:10.440 --> 00:35:15.359
在中具有死亡动机信息文件

00:35:12.779 --> 00:35:17.789
拼图文件夹不是很好吗

00:35:15.359 --> 00:35:22.020
如果我们能保留所有这些，那就更好了

00:35:17.789 --> 00:35:23.670
简称Java在一起

00:35:22.020 --> 00:35:25.470
有点像调皮的GRE 

00:35:23.670 --> 00:35:30.109
最近，您将需要

00:35:25.470 --> 00:35:33.539
多模块Maven多模式项目

00:35:30.109 --> 00:35:36.240
我们可能会建议使用

00:35:33.539 --> 00:35:39.510
两个执行块，在第一个

00:35:36.240 --> 00:35:39.810
你说的一个只编译

00:35:39.510 --> 00:35:43.320
发动机

00:35:39.810 --> 00:35:45.660
信息与九，在另一种情况下在

00:35:43.320 --> 00:35:49.310
另一种情况不包括模块信息和

00:35:45.660 --> 00:35:51.240
使用其他版本的Java进行编译

00:35:49.310 --> 00:35:54.210
我一直在努力

00:35:51.240 --> 00:35:58.040
 mave编译器承诺插件魔术

00:35:54.210 --> 00:36:04.320
开箱即用，我不喜欢它

00:35:58.040 --> 00:36:07.530
我现在要关注的是

00:36:04.320 --> 00:36:11.910
谈谈依赖和类

00:36:07.530 --> 00:36:15.540
路径，原因是这就是

00:36:11.910 --> 00:36:19.100
类路径顺序在以下情况下有效

00:36:15.540 --> 00:36:22.680
内森（Nathan）对于一个项目，它将首先

00:36:19.100 --> 00:36:24.540
选择所有直接依赖项

00:36:22.680 --> 00:36:26.250
它将直接进入第一级

00:36:24.540 --> 00:36:30.840
然后是第二个依存关系，依此类推

00:36:26.250 --> 00:36:34.560
等等，以此类推

00:36:30.840 --> 00:36:38.280
它将遍历该类路径

00:36:34.560 --> 00:36:45.210
相同的顺序和第一个比赛将赢得这场比赛

00:36:38.280 --> 00:36:48.930
如果您使用模块路径，它将更改

00:36:45.210 --> 00:36:51.980
可以想到图片被映射到

00:36:48.930 --> 00:36:55.200
一个特定的模块，如果有

00:36:51.980 --> 00:37:00.090
重复的包裹将有一个

00:36:55.200 --> 00:37:04.350
现在定位类抛出异常

00:37:00.090 --> 00:37:07.530
很简单，只需选择您的包裹钥匙

00:37:04.350 --> 00:37:11.000
它会找到模块，它将得到

00:37:07.530 --> 00:37:11.000
该模块中的该类

00:37:12.070 --> 00:37:20.260
现在有一个小陷阱，那就是

00:37:14.980 --> 00:37:22.360
关于依赖项不包括Java C 

00:37:20.260 --> 00:37:24.070
有一个可以说限制的选项

00:37:22.360 --> 00:37:26.680
模块，您必须指定所有

00:37:24.070 --> 00:37:31.720
您要从中排除的模块名称

00:37:26.680 --> 00:37:36.820
这个执行但是名称

00:37:31.720 --> 00:37:39.910
模块在gr和maven内部

00:37:36.820 --> 00:37:42.220
排除那些已经存在的依赖

00:37:39.910 --> 00:37:46.630
前端，因此无需下载

00:37:42.220 --> 00:37:50.050
那些来自或罐子和/或罐子的东西，如果在

00:37:46.630 --> 00:37:52.990
如果您有排除对象，我们可能

00:37:50.050 --> 00:37:54.910
必须下载世界加上一点

00:37:52.990 --> 00:37:57.910
更多，因为我们必须知道

00:37:54.910 --> 00:38:00.190
我们必须排除动机，所以没有

00:37:57.910 --> 00:38:02.950
解决方案尚未解决

00:38:00.190 --> 00:38:07.660
是自己在

00:38:02.950 --> 00:38:12.280
配置的参数，我们也是

00:38:07.660 --> 00:38:16.240
还没有这是所有的清单

00:38:12.280 --> 00:38:22.960
正在等待提案的主题

00:38:16.240 --> 00:38:24.820
并且有一些与Maven有关， 

00:38:22.960 --> 00:38:28.510
他们正在等待答案

00:38:24.820 --> 00:38:32.680
例如maven shade插件

00:38:28.510 --> 00:38:35.530
是可以使干燥机更干燥的插件

00:38:32.680 --> 00:38:39.040
这意味着它只会解开所有包装

00:38:35.530 --> 00:38:42.280
罐子组合在一起

00:38:39.040 --> 00:38:43.720
问题是，如果我们将合并

00:38:42.280 --> 00:38:49.720
可能会破坏的模块信息文件

00:38:43.720 --> 00:38:52.480
封装，因为它不知道

00:38:49.720 --> 00:38:55.500
不再是你自己的包了

00:38:52.480 --> 00:38:58.690
 VR，我们还必须考虑

00:38:55.500 --> 00:39:02.980
搬迁是关于转移

00:38:58.690 --> 00:39:05.770
或重命名包名称，因此

00:39:02.980 --> 00:39:09.430
这个问题仍然非常

00:39:05.770 --> 00:39:14.260
回答还有其他的东西

00:39:09.430 --> 00:39:16.710
现在动物嗅探器太快了

00:39:14.260 --> 00:39:19.930
不再只有一个巨大的

00:39:16.710 --> 00:39:24.040
我们可以验证的运行时

00:39:19.930 --> 00:39:25.450
签名，所以我们该怎么做

00:39:24.040 --> 00:39:28.000
我们必须为模块做

00:39:25.450 --> 00:39:31.210
还是现在仍然需要

00:39:28.000 --> 00:39:33.160
 -释放我们的选择，它仍然是

00:39:31.210 --> 00:39:38.230
问题是请求答案

00:39:33.160 --> 00:39:40.750
哦，那是最佳团队，所以现在

00:39:38.230 --> 00:39:45.220
您的问题是我的项目工作， 

00:39:40.750 --> 00:39:48.309
我已经准备好您的第一个问题

00:39:45.220 --> 00:39:50.890
必须回答自己是我在用吗

00:39:48.309 --> 00:39:56.160
内部类，为此

00:39:50.890 --> 00:39:59.980
创建了Maven jaidev的插件

00:39:56.160 --> 00:40:02.770
大约一年前发布了

00:39:59.980 --> 00:40:05.859
在Java 1期间，当我注意到

00:40:02.770 --> 00:40:07.630
拼图团队的幻灯片突然间

00:40:05.859 --> 00:40:10.930
提到了这个插件，但不是

00:40:07.630 --> 00:40:14.530
发布了，所以我们很快完成了

00:40:10.930 --> 00:40:18.690
官方发布是在Java期间

00:40:14.530 --> 00:40:18.690
一个，我将向您展示其工作原理

00:40:22.260 --> 00:40:25.470
所以我要做的是阿娃

00:40:24.849 --> 00:40:29.380
编译

00:40:25.470 --> 00:40:31.599
所以我有课程文件，因为玉

00:40:29.380 --> 00:40:35.049
 EPS使用类别而不是来源

00:40:31.599 --> 00:40:37.980
在这种情况下，它使用的是行家

00:40:35.049 --> 00:40:37.980
工件模块

00:40:42.220 --> 00:40:51.640
所以现在我们有一个庞大的清单，您可以

00:40:48.350 --> 00:40:55.010
查看所有包的映射

00:40:51.640 --> 00:40:58.670
所以在这种情况下，她让

00:40:55.010 --> 00:41:02.420
神器包是里面的类

00:40:58.670 --> 00:41:06.260
正在使用所有这些软件包，并且

00:41:02.420 --> 00:41:09.980
在这里你可以看到几个包

00:41:06.260 --> 00:41:13.940
在这种情况下属于

00:41:09.980 --> 00:41:16.850
没有使用任何内部类

00:41:13.940 --> 00:41:20.810
从Java，但我们当然希望看到

00:41:16.850 --> 00:41:24.860
吉达也开始了

00:41:20.810 --> 00:41:27.260
对其进行了集成测试

00:41:24.860 --> 00:41:29.570
我将进行集成测试， 

00:41:27.260 --> 00:41:33.100
运行数学编译和验证

00:41:29.570 --> 00:41:33.100
 JDK内部知识

00:41:35.770 --> 00:41:42.370
在这种情况下，我们看到失败

00:41:41.570 --> 00:41:46.550
一些杂项

00:41:42.370 --> 00:41:49.370
它被标记为当归内部API， 

00:41:46.550 --> 00:41:51.290
这已经破坏了构建，所以这是

00:41:49.370 --> 00:41:54.860
您现在已经可以做的事情

00:41:51.290 --> 00:41:59.120
只需将jeddak的插件添加到您的

00:41:54.860 --> 00:42:01.100
自己的文件，让它检查您的代码

00:41:59.120 --> 00:42:04.870
在我们的建造过程中

00:42:01.100 --> 00:42:04.870
看看您的产品现在是否支持Java 

00:42:08.290 --> 00:42:14.740
另一件事是我有重复吗

00:42:11.570 --> 00:42:18.500
您可以使用

00:42:14.740 --> 00:42:20.510
强制执行器maven强制执行插件和内部

00:42:18.500 --> 00:42:28.280
 Nathan强制插件指定此

00:42:20.510 --> 00:42:31.180
然后规则重复类，以防万一

00:42:28.280 --> 00:42:35.120
您想使用特定的作业9功能

00:42:31.180 --> 00:42:37.480
将插件升级到特定的

00:42:35.120 --> 00:42:37.480
版

00:42:43.060 --> 00:42:50.470
我们都必须选择

00:42:46.060 --> 00:42:53.950
结束请好，所以附件

00:42:50.470 --> 00:42:56.050
项目仍然有任务清单最多

00:42:53.950 --> 00:42:58.990
功能应该已经可以使用Maven 

00:42:56.050 --> 00:43:02.170
 3我们已经注意到，尽管

00:42:58.990 --> 00:43:04.360
有些需要方法3.3，因为

00:43:02.170 --> 00:43:07.540
改进的工具更换支持和

00:43:04.360 --> 00:43:10.120
这可能与我们何时

00:43:07.540 --> 00:43:11.860
在源代码中包含模块信息

00:43:10.120 --> 00:43:14.260
主Java，我们想用

00:43:11.860 --> 00:43:17.200
 Java的较旧版本

00:43:14.260 --> 00:43:19.360
需要更换大量

00:43:17.200 --> 00:43:23.410
功能已经开发，但它们

00:43:19.360 --> 00:43:27.460
你还没被释放，我们也

00:43:23.410 --> 00:43:32.710
必须写一些食谱

00:43:27.460 --> 00:43:35.050
专家的方式所以这是某事

00:43:32.710 --> 00:43:37.750
你们都应该知道模块信息

00:43:35.050 --> 00:43:41.010
 Java触发模块路径是否为

00:43:37.750 --> 00:43:44.620
使用或是否将使用类路径

00:43:41.010 --> 00:43:46.930
在测试编译的情况下，它将同时使用

00:43:44.620 --> 00:43:50.890
动机路径和阶级路径

00:43:46.930 --> 00:43:56.950
黑暗中有一个模块信息文件

00:43:50.890 --> 00:43:59.560
眼镜，以防万一您的项目

00:43:56.950 --> 00:44:01.120
将充满Java纳米拼图是

00:43:59.560 --> 00:44:03.790
可能是因为

00:44:01.120 --> 00:44:08.800
内部API或重复导出

00:44:03.790 --> 00:44:11.280
练习，这就是你的信息

00:44:08.800 --> 00:44:11.280
可以找到

00:44:16.030 --> 00:44:25.450
我将把这个片段发布为

00:44:18.760 --> 00:44:29.280
好吧，现在就给它一个

00:44:25.450 --> 00:44:29.280
尝试我会说，非常感谢你

00:44:33.390 --> 00:44:39.420
所以有什么问题请来

00:44:35.860 --> 00:44:39.420
放在前面，这样每个人都可以听到

00:44:40.380 --> 00:44:58.080
他们来听是因为他们

00:44:43.240 --> 00:45:00.970
也拍它是的然后你谈论

00:44:58.080 --> 00:45:03.630
复制乐队演奏加号，然后强制

00:45:00.970 --> 00:45:07.030
插件我的问题是只喜欢它

00:45:03.630 --> 00:45:08.830
检查我自己的构建类，例如

00:45:07.030 --> 00:45:13.480
应用程序类或它也检查

00:45:08.830 --> 00:45:15.850
第三方中的重复类

00:45:13.480 --> 00:45:17.860
大大影响了我们的典型用例

00:45:15.850 --> 00:45:19.960
我们已经看到的应用或

00:45:17.860 --> 00:45:21.490
有时你不知道的开发者

00:45:19.960 --> 00:45:23.350
依赖于不同的版本

00:45:21.490 --> 00:45:25.150
第三方罐子，它带来了两个

00:45:23.350 --> 00:45:26.890
相同实现的版本和

00:45:25.150 --> 00:45:29.290
大多数情况下它是冲突的，是的

00:45:26.890 --> 00:45:31.870
在运行时出错，以避免

00:45:29.290 --> 00:45:34.630
那真的是那样吗？ 

00:45:31.870 --> 00:45:37.510
只是我们，这到底是什么

00:45:34.630 --> 00:45:39.550
强制规则是其验证方式

00:45:37.510 --> 00:45:43.150
你没有任何重复

00:45:39.550 --> 00:45:45.460
好的课程，包括第三方工作

00:45:43.150 --> 00:45:47.920
尤其是特别完美

00:45:45.460 --> 00:45:50.860
这些第三方罐子

00:45:47.920 --> 00:45:53.220
传递树请来到前面

00:45:50.860 --> 00:45:53.220
我会

00:45:55.800 --> 00:46:01.170
所以有合并Maven的计划吗

00:45:59.820 --> 00:46:03.390
与模块的依赖

00:46:01.170 --> 00:46:06.720
模块信息中的依赖项还是我需要

00:46:03.390 --> 00:46:12.390
同时指定Maven依赖项和

00:46:06.720 --> 00:46:15.000
模块依赖性没有

00:46:12.390 --> 00:46:17.640
您刚才指定的区别

00:46:15.000 --> 00:46:20.610
习惯于Maven依赖

00:46:17.640 --> 00:46:27.290
你在说我要写吗

00:46:20.610 --> 00:46:31.620
我自己的模块信息文件可能是

00:46:27.290 --> 00:46:33.960
合并您正在谈论的它们

00:46:31.620 --> 00:46:36.300
生成模块信息的一部分

00:46:33.960 --> 00:46:38.400
文件的问题是，这只是一个

00:46:36.300 --> 00:46:44.430
该文件的特定部分，另一个

00:46:38.400 --> 00:46:47.150
像这样让我回去出口

00:46:44.430 --> 00:46:47.150
是

00:46:53.240 --> 00:46:59.960
就在这里，是的，需要的零件可以

00:46:57.770 --> 00:47:02.960
被产生，但其他所有不能

00:46:59.960 --> 00:47:10.250
所以我们有教堂

00:47:02.960 --> 00:47:14.210
用另一种方式生成文件的一半

00:47:10.250 --> 00:47:16.940
周围不可能，因为在哪里

00:47:14.210 --> 00:47:21.950
那些来自你的罐子不是吗

00:47:16.940 --> 00:47:24.250
无法指定计算到的路径

00:47:21.950 --> 00:47:27.980
特定的工件完全基于

00:47:24.250 --> 00:47:30.220
整个模块的名称

00:47:27.980 --> 00:47:30.220
问题

00:47:32.110 --> 00:47:38.600
嗨，符号实际上是一个

00:47:36.470 --> 00:47:40.490
开发人员正在尝试与

00:47:38.600 --> 00:47:43.580
注释以查看是否要

00:47:40.490 --> 00:47:46.310
工作是他的概念证明

00:47:43.580 --> 00:47:50.270
努力工作，谢谢你的演讲

00:47:46.310 --> 00:47:53.240
是我没有完全关注

00:47:50.270 --> 00:47:59.180
禁止重复的类有何关系

00:47:53.240 --> 00:48:05.290
准备好使用JDK 9可以了

00:47:59.180 --> 00:48:08.090
如果你有两个罐子

00:48:05.290 --> 00:48:11.750
复制类，所以我知道例如

00:48:08.090 --> 00:48:16.280
我想有时候是JBoss 

00:48:11.750 --> 00:48:20.750
只是有一个带有

00:48:16.280 --> 00:48:23.330
还有某种JRR 250 I 

00:48:20.750 --> 00:48:28.340
认为，他们正在使用

00:48:23.330 --> 00:48:32.630
在那种情况下，你不能

00:48:28.340 --> 00:48:36.440
用Java 9来启动它

00:48:32.630 --> 00:48:39.500
汽车它将出口一切，所以

00:48:36.440 --> 00:48:41.150
好，那不是专门的专家

00:48:39.500 --> 00:48:44.770
相关的不只是Java 9是Jeff 

00:48:41.150 --> 00:48:44.770
我真的是病得很对不起

00:48:46.240 --> 00:48:55.000
还有其他问题吗，非常感谢

00:48:52.819 --> 00:48:55.000
许多

