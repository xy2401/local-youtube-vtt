WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.000 --> 00:00:04.290
您好，欢迎来到Java演示文稿

00:00:02.190 --> 00:00:06.299
在荒野的Tanners中，我是Paul 

00:00:04.290 --> 00:00:09.360
 Sanders我是Java平台的成员

00:00:06.299 --> 00:00:12.150
团队和我一起攻读核心库

00:00:09.360 --> 00:00:15.080
 Java语言和热点，让我们开始吧

00:00:12.150 --> 00:00:15.080
进入这个演讲

00:00:15.440 --> 00:00:19.410
好吧，詹半天只有两天

00:00:17.730 --> 00:00:23.400
我要谈论的一件事

00:00:19.410 --> 00:00:24.689
运行jdk 9和docker容器以及

00:00:23.400 --> 00:00:27.269
第二部分是我要

00:00:24.689 --> 00:00:28.470
减少Docker中JDK 9的大小

00:00:27.269 --> 00:00:30.029
图片，所以我要介绍一些

00:00:28.470 --> 00:00:32.610
幻灯片，我将介绍一些

00:00:30.029 --> 00:00:34.260
在获得这两个方面的演示之前

00:00:32.610 --> 00:00:37.410
我只是想指出

00:00:34.260 --> 00:00:38.969
 Java 8 Docker映像可用于

00:00:37.410 --> 00:00:41.670
下载您可以在这里查看链接，如果

00:00:38.969 --> 00:00:43.040
您想尝试一下，让我们开始吧

00:00:41.670 --> 00:00:46.170
进入演示的第一部分

00:00:43.040 --> 00:00:47.579
在Docker容器中运行JDK 9 

00:00:46.170 --> 00:00:50.940
我们已经做了很多改进

00:00:47.579 --> 00:00:53.129
在JDK 9中遵守资源限制

00:00:50.940 --> 00:00:54.780
当您运行docker时在docker中

00:00:53.129 --> 00:00:58.800
容器可以在条款上进行约束

00:00:54.780 --> 00:01:01.949
的内存以及有多少个CPU先生

00:00:58.800 --> 00:01:03.449
我们现在尊重的第一个是si 

00:01:01.949 --> 00:01:06.030
已设置的组内存限制

00:01:03.449 --> 00:01:09.180
通过容器，我们添加了一个

00:01:06.030 --> 00:01:12.000
实验标记，您可以在这里看到使用

00:01:09.180 --> 00:01:13.860
查看堆的组内存限制，这是

00:01:12.000 --> 00:01:15.450
目前处于实验阶段，我们希望

00:01:13.860 --> 00:01:17.549
这样你就能获得经验

00:01:15.450 --> 00:01:20.220
运行它，然后我们将其切换

00:01:17.549 --> 00:01:21.950
稍后再恢复为默认设置

00:01:20.220 --> 00:01:25.110
我们很舒服，我们做对了

00:01:21.950 --> 00:01:27.630
 JDK现在尊重的另一个领域

00:01:25.110 --> 00:01:31.079
是为

00:01:27.630 --> 00:01:32.939
容器，例如运行时可用

00:01:31.079 --> 00:01:35.189
处理者现在将报告其正确的

00:01:32.939 --> 00:01:38.220
容器中的CPU数量

00:01:35.189 --> 00:01:41.040
以前用于报告CPU的

00:01:38.220 --> 00:01:43.110
主机本身，我们也做了一些

00:01:41.040 --> 00:01:45.750
修复了JVM，使其更稳定

00:01:43.110 --> 00:01:48.240
当资源变化时，例如

00:01:45.750 --> 00:01:50.220
 jiwon垃圾收集器现在可以在

00:01:48.240 --> 00:01:52.680
活动CPU无法发现该JVM 

00:01:50.220 --> 00:01:54.600
启动，而不是处于活动状态的CPU数量

00:01:52.680 --> 00:01:57.719
任何时候它决定要查询它

00:01:54.600 --> 00:02:00.479
因为G 1需要调整JVM的大小

00:01:57.719 --> 00:02:02.640
根据CPU计数正确启动它

00:02:00.479 --> 00:02:05.310
看到正在进行的证明如此计划

00:02:02.640 --> 00:02:07.649
将来的版本中，我们有一份JEP草案

00:02:05.310 --> 00:02:09.450
工程和容器感知的Java和

00:02:07.649 --> 00:02:11.640
我们将计划做一些

00:02:09.450 --> 00:02:13.830
增强功能，例如评估

00:02:11.640 --> 00:02:15.780
对Docker运行时的进一步支持

00:02:13.830 --> 00:02:17.100
您看到的标志因此在

00:02:15.780 --> 00:02:19.560
我们可以做很多工作

00:02:17.100 --> 00:02:20.790
在这里改善Java的工作方式，但是现在

00:02:19.560 --> 00:02:23.190
我将切换到一个小演示

00:02:20.790 --> 00:02:26.040
在这里并显示资源限制

00:02:23.190 --> 00:02:28.350
在行动中，所以我要做的就是

00:02:26.040 --> 00:02:30.990
将在docker中运行Java进程

00:02:28.350 --> 00:02:33.690
容器docker图像对不起

00:02:30.990 --> 00:02:37.560
 Java 9构建，我将运行J 

00:02:33.690 --> 00:02:39.540
 Shell作为Java进程，所以让我们

00:02:37.560 --> 00:02:41.730
继续运行，所以我在做什么

00:02:39.540 --> 00:02:44.160
我正在docker中运行J Shell 

00:02:41.730 --> 00:02:47.160
容器，它运行的是Java 9， 

00:02:44.160 --> 00:02:49.380
要查询CPU约束

00:02:47.160 --> 00:02:50.460
 CPU限制和内存限制以查看

00:02:49.380 --> 00:02:52.290
如果我首先是什么办公室

00:02:50.460 --> 00:02:53.820
没有任何限制地运行文档

00:02:52.290 --> 00:02:56.220
只是要运行默认值

00:02:53.820 --> 00:03:01.140
以及房东提供的服务

00:02:56.220 --> 00:03:05.400
我们使用运行时获取

00:03:01.140 --> 00:03:06.900
处理器，我们可以看到我们报告

00:03:05.400 --> 00:03:09.480
这个完整的过程可以通过

00:03:06.900 --> 00:03:13.230
默认情况下，我还添加了一些片段

00:03:09.480 --> 00:03:15.480
 JCL来查询两者的内存限制

00:03:13.230 --> 00:03:18.780
 Java Runtime，还有什么

00:03:15.480 --> 00:03:21.360
由C组和中的报告

00:03:18.780 --> 00:03:24.540
第二种情况，我们看到卸载了

00:03:21.360 --> 00:03:26.489
此处包含的文件

00:03:24.540 --> 00:03:28.560
泊坞窗的内存限制

00:03:26.489 --> 00:03:30.420
容器在这里，所以请记住我

00:03:28.560 --> 00:03:32.880
在这里在容器中运行J Shell 

00:03:30.420 --> 00:03:34.709
如果我们运行系统内存限制，让我们

00:03:32.880 --> 00:03:36.750
看看让我们看看它提供了什么

00:03:34.709 --> 00:03:39.090
报告它以兆字节为单位这是因为我

00:03:36.750 --> 00:03:40.890
说这是一个很大的数字

00:03:39.090 --> 00:03:42.989
说码头集装箱认为我不

00:03:40.890 --> 00:03:44.459
照顾我，无论主人提供我什么

00:03:42.989 --> 00:03:47.640
会尽力用尽

00:03:44.459 --> 00:03:49.920
如果我们看工作并限制在这里

00:03:47.640 --> 00:03:53.970
对于最大内存，我们拥有的是

00:03:49.920 --> 00:03:57.000
在这里选择默认的500兆字节

00:03:53.970 --> 00:03:59.790
没有任何限制

00:03:57.000 --> 00:04:01.080
如果我们切换回去并运行一个容器

00:03:59.790 --> 00:04:02.850
相反，我们要做的是

00:04:01.080 --> 00:04:06.540
将docker容器限制为

00:04:02.850 --> 00:04:10.260
 384兆字节并将其限制为

00:04:06.540 --> 00:04:13.700
旋转到CPU零，所以基本上是一个CPU，所以

00:04:10.260 --> 00:04:13.700
让我们看看运行该命令时会发生什么

00:04:15.560 --> 00:04:20.600
再次在

00:04:17.760 --> 00:04:20.600
这里的容器

00:04:22.200 --> 00:04:30.750
现在我们获取可用的流程

00:04:27.810 --> 00:04:32.940
只有一个处理器可用

00:04:30.750 --> 00:04:35.130
与之前的四个相比，因为我们设置了

00:04:32.940 --> 00:04:37.290
限制器的CPU数量

00:04:35.130 --> 00:04:40.380
现在可以正常工作了

00:04:37.290 --> 00:04:44.100
检查系统最大内存，我们看到它是

00:04:40.380 --> 00:04:46.950
 384因为我们在命令中限制了它

00:04:44.100 --> 00:04:51.180
像这样，现在让我们检查一下Java 

00:04:46.950 --> 00:04:53.520
内存限制在这里你会很好我们看到

00:04:51.180 --> 00:04:53.970
 Java忽略了

00:04:53.520 --> 00:04:55.800
码头工人

00:04:53.970 --> 00:04:57.060
它实际上是在尝试获取更多

00:04:55.800 --> 00:04:57.780
内存超过

00:04:57.060 --> 00:05:00.270
容器

00:04:57.780 --> 00:05:02.340
现在，当Java尝试分配球时

00:05:00.270 --> 00:05:04.890
这样的记忆，我认为这取决于

00:05:02.340 --> 00:05:06.750
关于如何运行docker的政策

00:05:04.890 --> 00:05:08.430
容器是否Java进程是

00:05:06.750 --> 00:05:12.840
一旦耗尽就被杀死或不被杀死

00:05:08.430 --> 00:05:14.940
内存和交换，所以我们如何解决这个问题

00:05:12.840 --> 00:05:16.830
我们可以使用我显示的选项

00:05:14.940 --> 00:05:19.610
较早的实验选项

00:05:16.830 --> 00:05:22.740
进入热点，现在你注意到他们

00:05:19.610 --> 00:05:24.870
因为方式在这里表达了两次

00:05:22.740 --> 00:05:27.450
 JCL的实施公民

00:05:24.870 --> 00:05:29.850
实际上运行到Java进程之一

00:05:27.450 --> 00:05:33.540
 repple和一个用于执行

00:05:29.850 --> 00:05:35.220
我们键入的Java代码段

00:05:33.540 --> 00:05:37.760
让我们运行它，看看如何

00:05:35.220 --> 00:05:37.760
表现

00:05:44.550 --> 00:05:49.259
好吧，让我们在这里获取系统内存

00:05:47.610 --> 00:05:53.460
应该以前免费的，让我们

00:05:49.259 --> 00:05:56.099
在这里获取Java最大内存，我们看到了

00:05:53.460 --> 00:05:58.020
它下降到121兆字节

00:05:56.099 --> 00:05:59.310
第三，所以它在这里做正确的事

00:05:58.020 --> 00:06:02.069
它正在尝试选择合理的

00:05:59.310 --> 00:06:03.810
基于的默认内存使用情况

00:06:02.069 --> 00:06:05.940
容器的最大内存限制

00:06:03.810 --> 00:06:10.139
本身，所以你可以使用这些

00:06:05.940 --> 00:06:12.030
您必须添加实验性选项

00:06:10.139 --> 00:06:14.069
在应用选项之前先进行标记

00:06:12.030 --> 00:06:15.569
在这里使用，并会对

00:06:14.069 --> 00:06:21.479
何时对您有帮助的反馈

00:06:15.569 --> 00:06:26.880
运行Java和容器就可以了

00:06:21.479 --> 00:06:28.349
我的演讲的第二部分

00:06:26.880 --> 00:06:30.509
演示的第二部分是

00:06:28.349 --> 00:06:33.870
减少JDK 9和docker的大小

00:06:30.509 --> 00:06:36.360
图像，因此JDK 9是模块化的，这要归功于

00:06:33.870 --> 00:06:39.090
专为专业设计的项目拼图

00:06:36.360 --> 00:06:40.949
 JDK 9和JDK 9发行版驱动程序

00:06:39.090 --> 00:06:42.990
向Java平台介绍模块

00:06:40.949 --> 00:06:45.120
那么什么是模块，模块是一组

00:06:42.990 --> 00:06:47.819
专为重用而设计的软件包

00:06:45.120 --> 00:06:49.830
简单的定义和模块改进

00:06:47.819 --> 00:06:52.680
您的可维护性的可靠性

00:06:49.830 --> 00:06:55.830
程序，我们已经将模块应用于

00:06:52.680 --> 00:06:57.900
 JDK 9它本身由79个组成

00:06:55.830 --> 00:07:01.020
我们重构了整个JDK的模块

00:06:57.900 --> 00:07:02.880
多年来，现在我们

00:07:01.020 --> 00:07:05.639
发现它更可靠和可维护

00:07:02.880 --> 00:07:08.130
 JDK 9本身也带有j-link 

00:07:05.639 --> 00:07:10.139
这是一个非常有趣的工具

00:07:08.130 --> 00:07:13.050
您可以用来创建自定义Java 

00:07:10.139 --> 00:07:15.569
运行时，例如Java Runtime 

00:07:13.050 --> 00:07:17.190
由基于Java的模块组成， 

00:07:15.569 --> 00:07:20.550
是所有其他模块的模块

00:07:17.190 --> 00:07:22.740
依靠，所以我们能做的就是

00:07:20.550 --> 00:07:26.279
使用称为alpine linux的发行版

00:07:22.740 --> 00:07:28.650
我们可以使用公开完成的工作

00:07:26.279 --> 00:07:31.590
 JDK项目为Portola提供了一个端口

00:07:28.650 --> 00:07:33.900
一个JDK到我们的pine Linux，特别是

00:07:31.590 --> 00:07:35.669
到高山的C肌肉库

00:07:33.900 --> 00:07:37.580
现在使用Linux的Linux用户是

00:07:35.669 --> 00:07:41.370
有趣，因为它很小

00:07:37.580 --> 00:07:43.139
分布，而是使用肌肉C 

00:07:41.370 --> 00:07:45.240
比嘴唇C缩小

00:07:43.139 --> 00:07:46.949
在那里分发早期访问版本

00:07:45.240 --> 00:07:49.139
通往linux的jdk端口

00:07:46.949 --> 00:07:51.449
可在那里的链接和

00:07:49.139 --> 00:07:54.419
幻灯片，我们可以使用J链接创建

00:07:51.449 --> 00:07:56.370
 Linux中我们的PI的自定义Java运行时

00:07:54.419 --> 00:07:57.740
因为我们的PI Linux很小，所以我们

00:07:56.370 --> 00:07:59.810
可以创建较小的自定义

00:07:57.740 --> 00:08:02.030
它增加了Java运行时

00:07:59.810 --> 00:08:05.080
码头工人的形象，所以我将解释如何

00:08:02.030 --> 00:08:07.699
我们可以做到这一点，所以我首先使用

00:08:05.080 --> 00:08:09.919
在我运行J Shell之前

00:08:07.699 --> 00:08:13.639
使用的是我创建的现有图像

00:08:09.919 --> 00:08:16.550
称为JDK 9 Alpine，所以JDK 9在

00:08:13.639 --> 00:08:21.410
如果我们有的话，Alpine Linux会有完整的JDK 

00:08:16.550 --> 00:08:23.479
我们在这里列出图像，我们可以看到我有

00:08:21.410 --> 00:08:26.360
我本地的Docker注册表中有两个图像

00:08:23.479 --> 00:08:29.030
我有所有的Alpine Linux 

00:08:26.360 --> 00:08:31.940
大约4兆，我有JDK 9 Alpine 

00:08:29.030 --> 00:08:34.459
最新的是356兆字节

00:08:31.940 --> 00:08:36.440
基本上整个JDK大约是350 

00:08:34.459 --> 00:08:38.919
总兆字节，我怎么

00:08:36.440 --> 00:08:46.610
创建那个JDK 9映像，所以我有一个

00:08:38.919 --> 00:08:48.230
码头工人文件可用这样，我想要

00:08:46.610 --> 00:08:50.480
从该泊坞窗构建一个泊坞窗映像

00:08:48.230 --> 00:08:54.050
文件，所以我所做的是从

00:08:50.480 --> 00:08:59.360
 Alpine Linux Docker镜像基础

00:08:54.050 --> 00:09:01.940
图片，然后添加EI版本的

00:08:59.360 --> 00:09:04.520
我在这里针对高山Linux的JDK 9 

00:09:01.940 --> 00:09:06.110
以前下载的，我基本上

00:09:04.520 --> 00:09:07.790
将其复制到图像并设置

00:09:06.110 --> 00:09:10.579
一些环境变量，我可以

00:09:07.790 --> 00:09:15.829
实际重建该图像只是为了显示

00:09:10.579 --> 00:09:17.480
它是如何工作的，有点

00:09:15.829 --> 00:09:19.160
更快，因为我已经内置了它

00:09:17.480 --> 00:09:21.680
缓存没有任何改变

00:09:19.160 --> 00:09:24.110
所以那里真的没有变化

00:09:21.680 --> 00:09:26.000
继续在这里，所以我能做的是

00:09:24.110 --> 00:09:30.320
运行它并显示有多少模块

00:09:26.000 --> 00:09:32.630
在名为JDK 9的JDK中运行时

00:09:30.320 --> 00:09:39.709
运行docker run命令并

00:09:32.630 --> 00:09:40.970
运行Java并列出模块和

00:09:39.709 --> 00:09:43.310
我们应该看到有很多

00:09:40.970 --> 00:09:49.730
完整的JDK中的模块实际上是

00:09:43.310 --> 00:09:53.540
我们只是对它们进行快速计数

00:09:49.730 --> 00:09:55.700
应该看到有79个模块

00:09:53.540 --> 00:09:57.279
 JDK Nikken，如果我们只是滚动浏览并

00:09:55.700 --> 00:09:59.779
看看我们看到有Java桌面

00:09:57.279 --> 00:10:02.329
现在，当您运行时，javac在这里

00:09:59.779 --> 00:10:03.829
一个说基于云的应用程序

00:10:02.329 --> 00:10:05.750
可能不需要桌面，您

00:10:03.829 --> 00:10:09.410
可能不需要CORBA，而您

00:10:05.750 --> 00:10:10.400
可能不需要jdkäôt或

00:10:09.410 --> 00:10:12.590
的

00:10:10.400 --> 00:10:15.860
这样的Javadoc内容，因此您可以剥离

00:10:12.590 --> 00:10:18.110
减少您的应用程序以供使用

00:10:15.860 --> 00:10:20.390
你的jdk模块

00:10:18.110 --> 00:10:22.460
需要，让我们尝试剥离它

00:10:20.390 --> 00:10:24.140
降至最小的Java 

00:10:22.460 --> 00:10:28.339
运行时，我们要做的是

00:10:24.140 --> 00:10:30.890
我将选择Java基本模块

00:10:28.339 --> 00:10:32.600
所有其他模块所依赖的模块

00:10:30.890 --> 00:10:35.210
所以我们要怎么做，所以我有

00:10:32.600 --> 00:10:37.940
另一个docker文件，所以首先

00:10:35.210 --> 00:10:39.500
我需要运行j-link 

00:10:37.940 --> 00:10:40.100
如前所述，我们需要运行

00:10:39.500 --> 00:10:44.600
链接

00:10:40.100 --> 00:10:46.460
在JDK 9的容器中

00:10:44.600 --> 00:10:48.110
 linux并且已经有一个脚本

00:10:46.460 --> 00:10:52.310
所以这将要做的事

00:10:48.110 --> 00:10:53.839
运行我的JDK 9高山容器并

00:10:52.310 --> 00:10:57.230
它会在里面运行监狱

00:10:53.839 --> 00:11:00.710
容器设置了我的模块路径

00:10:57.230 --> 00:11:04.360
 JDK 9运行时中的Java模块和

00:11:00.710 --> 00:11:07.460
它会说我只想建立一个

00:11:04.360 --> 00:11:09.290
包含Java的新Java运行时

00:11:07.460 --> 00:11:10.880
基本模块，我要使其更小

00:11:09.290 --> 00:11:12.320
通过压缩，我将删除

00:11:10.880 --> 00:11:14.720
一些我不需要的头文件，然后

00:11:12.320 --> 00:11:20.930
将其输出到此目录

00:11:14.720 --> 00:11:22.310
这样，所以让我们像这样运行

00:11:20.930 --> 00:11:24.620
所以在运行的时候我就去

00:11:22.310 --> 00:11:27.560
节省一些时间并复制此命令

00:11:24.620 --> 00:11:29.060
在这里，所以现在正在做监狱运行

00:11:27.560 --> 00:11:31.730
在Docker容器中有点像

00:11:29.060 --> 00:11:35.140
我们如何运行一个shell，现在它是

00:11:31.730 --> 00:11:37.910
我们应该看到这里有一个目录

00:11:35.140 --> 00:11:40.820
我们在这里创建的那是

00:11:37.910 --> 00:11:42.560
我们的pine Linux的自定义运行时

00:11:40.820 --> 00:11:44.390
我们刚刚创建了一个较小的

00:11:42.560 --> 00:11:46.070
我们是否将其放入docker文件中，所以我

00:11:44.390 --> 00:11:48.950
有一个码头工人形象，所以我有另一个

00:11:46.070 --> 00:11:53.360
我们可以用来创建的docker文件

00:11:48.950 --> 00:11:55.370
该码头工人图像非常相似

00:11:53.360 --> 00:11:58.070
到另一个我们基本上

00:11:55.370 --> 00:12:00.440
我们构建的自定义运行时

00:11:58.070 --> 00:12:02.709
复制到正确的位置并进行设置

00:12:00.440 --> 00:12:09.770
一些环境变量

00:12:02.709 --> 00:12:13.940
建立它，所以现在要做一些

00:12:09.770 --> 00:12:15.890
实际工作在这里复制此命令行

00:12:13.940 --> 00:12:17.570
当我们在这里等待时，它正在复制

00:12:15.890 --> 00:12:19.220
 Java Runtime的目录

00:12:17.570 --> 00:12:21.740
自定义Java运行时映像

00:12:19.220 --> 00:12:23.930
包含Java基础到

00:12:21.740 --> 00:12:26.420
容器设置环境

00:12:23.930 --> 00:12:28.730
变量，现在正在创建

00:12:26.420 --> 00:12:33.470
泊坞窗图片，如果我们看看我们的

00:12:28.730 --> 00:12:36.080
图片在这里我们可以看到，我们的

00:12:33.470 --> 00:12:38.570
自定义运行时间减少了一个订单

00:12:36.080 --> 00:12:40.820
与完整的JDK相比数量级

00:12:38.570 --> 00:12:43.220
九个运行时间在这里

00:12:40.820 --> 00:12:45.350
部分原因是Alpine Linux很小

00:12:43.220 --> 00:12:48.350
好吧，我们得到了一个小的好处

00:12:45.350 --> 00:12:50.180
自定义运行时间，体积小

00:12:48.350 --> 00:12:54.140
操作系统，所以现在我们可以

00:12:50.180 --> 00:12:57.260
在那里列出我们的模块，我们看到了

00:12:54.140 --> 00:12:58.940
那里只有Java基础，所以

00:12:57.260 --> 00:13:01.310
如何创造小小的例子

00:12:58.940 --> 00:13:03.680
所有的自定义运行时映像

00:13:01.310 --> 00:13:05.899
命令和docker文件以及

00:13:03.680 --> 00:13:06.980
我运行和使用的脚本是

00:13:05.899 --> 00:13:09.800
在此末尾可用

00:13:06.980 --> 00:13:12.649
演示文稿，您可以尝试一下

00:13:09.800 --> 00:13:15.170
自己动手，让我们回到

00:13:12.649 --> 00:13:17.810
演讲，最后终于

00:13:15.170 --> 00:13:20.330
所以只是回顾一下，我展示了Java是如何

00:13:17.810 --> 00:13:22.220
改善其执行或运行

00:13:20.330 --> 00:13:24.830
在Docker容器中以及如何

00:13:22.220 --> 00:13:28.750
减少Docker中JDK 9的大小

00:13:24.830 --> 00:13:31.370
图片等，接下来您可以转到

00:13:28.750 --> 00:13:32.990
从这里的链接下载JDK 

00:13:31.370 --> 00:13:35.060
可以加入打开的JDK邮件列表，并且

00:13:32.990 --> 00:13:38.110
您可以在Twitter上关注我们，希望您

00:13:35.060 --> 00:13:38.110
非常喜欢这个谢谢你

