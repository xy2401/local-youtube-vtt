WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.000 --> 00:00:08.340
比尔吉特（Birgit）做到这一点，使其受到欢迎

00:00:05.100 --> 00:00:11.730
关于迁移到模块的会议

00:00:08.340 --> 00:00:15.450
我叫Mark Reynolds我从事Java开发

00:00:11.730 --> 00:00:17.570
有多少人看到了

00:00:15.450 --> 00:00:19.859
我昨天下午做了会议哦

00:00:17.570 --> 00:00:23.119
优秀，可以让您领先

00:00:19.859 --> 00:00:26.060
我不是一定会帮上忙

00:00:23.119 --> 00:00:29.189
就像昨天一样

00:00:26.060 --> 00:00:31.619
我可能会完全编码

00:00:29.189 --> 00:00:33.600
如果发现一个错误，就会犯几个错误

00:00:31.619 --> 00:00:36.329
错误随时大声说出来我

00:00:33.600 --> 00:00:38.850
如果有的话不要介意纠正

00:00:36.329 --> 00:00:40.320
澄清问题随时可以

00:00:38.850 --> 00:00:42.870
大声喊那些，我会，我会

00:00:40.320 --> 00:00:44.940
尝试回答，但真正的你知道肉

00:00:42.870 --> 00:00:50.930
这是实质性的实质性问题，让我们

00:00:44.940 --> 00:00:54.680
让我们把那些留到最后好吧

00:00:50.930 --> 00:01:01.289
我昨天到这里来的是

00:00:54.680 --> 00:01:03.960
一个非常新的JDK 9版本，只是

00:01:01.289 --> 00:01:07.049
几天前，我们将要做什么

00:01:03.960 --> 00:01:10.229
这节课是上一堂课

00:01:07.049 --> 00:01:12.510
使用一些流行的路径应用程序

00:01:10.229 --> 00:01:15.420
库，我们将进行模块化

00:01:12.510 --> 00:01:18.210
现在那些图书馆自己

00:01:15.420 --> 00:01:19.740
实际上还没有模块化

00:01:18.210 --> 00:01:21.900
他们有些旧或不是最新的

00:01:19.740 --> 00:01:24.000
这些库的版本，所以我们将看到

00:01:21.900 --> 00:01:26.640
您可以模块化应用程序

00:01:24.000 --> 00:01:28.829
即使有些图书馆

00:01:26.640 --> 00:01:30.630
用途尚未转换为

00:01:28.829 --> 00:01:32.850
模块，然后我们做相反的事情

00:01:30.630 --> 00:01:34.829
假装我们是z的维护者

00:01:32.850 --> 00:01:37.320
这些库，我们将对它们进行模块化

00:01:34.829 --> 00:01:40.079
看看我们的小应用程序如何

00:01:37.320 --> 00:01:43.320
独自坐在课堂上可以

00:01:40.079 --> 00:01:46.140
利用现在模块化的

00:01:43.320 --> 00:01:47.100
有效的方法，然后

00:01:46.140 --> 00:01:48.450
最终在最后，我们将有一个

00:01:47.100 --> 00:01:50.009
漂亮的模块图在哪里

00:01:48.450 --> 00:01:52.079
一切都是模块和类路径

00:01:50.009 --> 00:01:56.219
是空的，毕竟是

00:01:52.079 --> 00:02:02.140
长期目标没事，所以我有

00:01:56.219 --> 00:02:05.170
这是一条推文文件

00:02:02.140 --> 00:02:07.660
不是本世纪的JSON格式

00:02:05.170 --> 00:02:09.520
特别可读，但是嘿

00:02:07.660 --> 00:02:11.080
胜过被提名人

00:02:09.520 --> 00:02:14.320
这些是我的一些推文

00:02:11.080 --> 00:02:15.700
一段时间后的时间表和我

00:02:14.320 --> 00:02:18.700
我写的是一个小小的应用程序

00:02:15.700 --> 00:02:24.420
将会在更多的地方显示这些

00:02:18.700 --> 00:02:24.420
可读的格式，让我们看一下

00:02:24.570 --> 00:02:31.510
我们有一个漂亮的主班

00:02:28.840 --> 00:02:33.010
简单的包装或收到推文

00:02:31.510 --> 00:02:35.950
我们正在使用杰克逊数据

00:02:33.010 --> 00:02:39.190
绑定API，因此我们导入了一些类

00:02:35.950 --> 00:02:40.020
从这一点来说，我们的主要班级很漂亮

00:02:39.190 --> 00:02:48.160
直截了当

00:02:40.020 --> 00:02:51.100
但是我们配置了一个Jackson对象

00:02:48.160 --> 00:02:53.560
禁用某些项目的映射器

00:02:51.100 --> 00:02:56.489
它的属性之一，我们读取此值

00:02:53.560 --> 00:02:58.930
来自标准输入流

00:02:56.489 --> 00:03:02.980
使自己成为推文列表， 

00:02:58.930 --> 00:03:05.560
然后针对该列表中的每条推文

00:03:02.980 --> 00:03:08.709
运行一点lambda以将其显示在

00:03:05.560 --> 00:03:10.780
标准输出流和这个

00:03:08.709 --> 00:03:13.030
鸣叫类这是另一个类

00:03:10.780 --> 00:03:14.920
这个小小的应用程序是

00:03:13.030 --> 00:03:18.459
基本上只是一点点PO Java 

00:03:14.920 --> 00:03:20.560
推文漂亮的数据持有人

00:03:18.459 --> 00:03:23.170
很简单，它使用

00:03:20.560 --> 00:03:27.780
续集时间戳类，仅用于

00:03:23.170 --> 00:03:32.170
娱乐导入一些杰克逊

00:03:27.780 --> 00:03:33.670
注释，这是一个漂亮的

00:03:32.170 --> 00:03:37.330
简单明了的照片

00:03:33.670 --> 00:03:39.610
两个属性是一个文本

00:03:37.330 --> 00:03:43.090
将推文的正文和

00:03:39.610 --> 00:03:44.980
具有杰克逊的时间戳属性

00:03:43.090 --> 00:03:46.299
上面有注释

00:03:44.980 --> 00:03:47.920
这条推文当然被发布了

00:03:46.299 --> 00:03:49.780
一条推文中有很多其他信息，但

00:03:47.920 --> 00:03:51.790
我们只是试图显示

00:03:49.780 --> 00:03:57.040
基本内容，所以我们不在乎

00:03:51.790 --> 00:03:58.959
其余的都很好，所以让我们

00:03:57.040 --> 00:04:00.430
编译我只是让我们确保

00:03:58.959 --> 00:04:03.400
这一切都正常了

00:04:00.430 --> 00:04:04.840
没有它的类路径应用程序

00:04:03.400 --> 00:04:07.049
没有什么特别的

00:04:04.840 --> 00:04:09.900
我到了

00:04:07.049 --> 00:04:12.480
在我的lib目录中，Jackson jar 

00:04:09.900 --> 00:04:15.750
文件266有点陈旧了

00:04:12.480 --> 00:04:22.070
认为最新的是2.8左右

00:04:15.750 --> 00:04:25.530
很好，让我们编译Lib Jackson 

00:04:22.070 --> 00:04:33.240
注释Lib Jackson克隆，然后

00:04:25.530 --> 00:04:34.650
盖杰克逊数据绑定，让我们看看

00:04:33.240 --> 00:04:41.070
是的，是的，让我们真正做到这一点

00:04:34.650 --> 00:04:46.440
这里先进的东西好吧，应该

00:04:41.070 --> 00:04:48.650
编译所有的东西，让我们做个大

00:04:46.440 --> 00:04:48.650
罐

00:04:50.270 --> 00:04:55.190
让我们来看看，让我们坚持下去

00:04:52.949 --> 00:04:55.190
盖

00:05:02.069 --> 00:05:04.819
面向对象

00:05:05.140 --> 00:05:13.250
有一个dur文件，所以我现在应该

00:05:08.180 --> 00:05:16.210
能够运行它，我将复制它

00:05:13.250 --> 00:05:22.210
课堂路径在这里

00:05:16.210 --> 00:05:26.720
 ad-lib鸣叫一些和/或鸣叫一些

00:05:22.210 --> 00:05:32.750
名为tweet的东西JSON 

00:05:26.720 --> 00:05:34.160
繁荣漂亮的一些推文显示还可以

00:05:32.750 --> 00:05:36.370
所以这很简单

00:05:34.160 --> 00:05:40.900
看到我们看到它按原样工作

00:05:36.370 --> 00:05:43.100
好的，所以第一部分让我们模块化的眼睛

00:05:40.900 --> 00:05:46.520
小推特一些应用程序

00:05:43.100 --> 00:05:47.960
不用对杰克逊做任何事

00:05:46.520 --> 00:05:50.240
 jar文件

00:05:47.960 --> 00:05:51.680
我们只是去，我们不会去

00:05:50.240 --> 00:05:56.900
修改它们，我们将要使用它们

00:05:51.680 --> 00:05:59.240
因为它们的存在，所以在鸣叫声中

00:05:56.900 --> 00:06:04.760
我们要把它变成一个模块做什么

00:05:59.240 --> 00:06:07.730
我们需要，所以让我们做一个

00:06:04.760 --> 00:06:10.310
您将回忆起的模块信息

00:06:07.730 --> 00:06:14.240
进入包的根目录

00:06:10.310 --> 00:06:16.070
模块的层次结构，我需要

00:06:14.240 --> 00:06:19.550
说的好，我需要给模块一个

00:06:16.070 --> 00:06:20.780
名称，我们甚至都将其称为推文

00:06:19.550 --> 00:06:22.940
虽然那不是一个好名字

00:06:20.780 --> 00:06:26.570
稍后再说

00:06:22.940 --> 00:06:29.660
关于模块的基本内容

00:06:26.570 --> 00:06:31.550
需要终止出口让我们谈谈

00:06:29.660 --> 00:06:35.480
出口至上是推文um需要

00:06:31.550 --> 00:06:37.490
导出任何东西不，这是一个应用程序

00:06:35.480 --> 00:06:40.000
没有为任何人提供API 

00:06:37.490 --> 00:06:42.650
其他使用，所以我们不需要任何出口

00:06:40.000 --> 00:06:45.860
好吧，我们需要输入什么

00:06:42.650 --> 00:06:47.660
需要我们在这里需要什么，所以我们

00:06:45.860 --> 00:06:50.540
知道推文um使用了这三个

00:06:47.660 --> 00:06:55.910
千斤顶和jar文件，所以会很好

00:06:50.540 --> 00:07:00.350
如果我们可以输入此内容或其他内容

00:06:55.910 --> 00:07:03.320
像这样，等一下，这些是

00:07:00.350 --> 00:07:06.380
只是jar文件，我这些都是旧的

00:07:03.320 --> 00:07:10.120
他们从中央那里的jar文件

00:07:06.380 --> 00:07:11.510
没有任何模块信息

00:07:10.120 --> 00:07:14.270
对

00:07:11.510 --> 00:07:16.380
元和一堆班通常的东西

00:07:14.270 --> 00:07:19.620
他们不是模块

00:07:16.380 --> 00:07:23.190
所以我们做得好，结果证明我们

00:07:19.620 --> 00:07:26.160
其实可以打字需要杰克逊核心

00:07:23.190 --> 00:07:29.820
由于这个原因，我们可以做到这一点

00:07:26.160 --> 00:07:31.980
功能称为自动模块，因此

00:07:29.820 --> 00:07:34.310
自动模块是迁移工具

00:07:31.980 --> 00:07:37.650
他们让您获取现有的jar文件

00:07:34.310 --> 00:07:39.660
您不必修改它，只需输入

00:07:37.650 --> 00:07:42.570
它在模块路径和模块上

00:07:39.660 --> 00:07:44.910
系统将其视为模块

00:07:42.570 --> 00:07:47.010
这有点特殊的模块催吐剂

00:07:44.910 --> 00:07:51.990
它可以访问更多的东西

00:07:47.010 --> 00:07:54.330
比常规模块要多，但这是

00:07:51.990 --> 00:07:55.830
对于迁移至关重要，所以如果您

00:07:54.330 --> 00:07:58.290
没有一些现有的jar文件

00:07:55.830 --> 00:08:00.570
他们的格式相当好，他们没有

00:07:58.290 --> 00:08:03.030
与软件包有冲突的软件包

00:08:00.570 --> 00:08:04.560
任何那种凌乱的东西

00:08:03.030 --> 00:08:06.870
你把它们放在模块上的东西

00:08:04.560 --> 00:08:08.640
模型系统综合的路径

00:08:06.870 --> 00:08:11.550
在编译时为其声明

00:08:08.640 --> 00:08:15.090
和运行时，模块的名称是

00:08:11.550 --> 00:08:16.980
取自其罐子的名称

00:08:15.090 --> 00:08:20.610
使用一个非常简单的启发式文件

00:08:16.980 --> 00:08:23.310
您的Jackson仪表板26.6罐子放下

00:08:20.610 --> 00:08:25.020
扩展名删除版本部分转换

00:08:23.310 --> 00:08:26.880
其余标点符号

00:08:25.020 --> 00:08:29.550
删除多余的码头，这是非常

00:08:26.880 --> 00:08:33.120
直接，不一定

00:08:29.550 --> 00:08:35.580
长期以来该模块的最佳名称，但

00:08:33.120 --> 00:08:38.340
我将在以后再讨论，以便

00:08:35.580 --> 00:08:41.010
在此模块声明中为

00:08:38.340 --> 00:08:42.719
即使那些杰克逊罐子鸣叫

00:08:41.010 --> 00:08:46.470
我说的不是适当的模块

00:08:42.719 --> 00:08:55.160
杰克逊的核心需要杰克逊数据

00:08:46.470 --> 00:08:59.040
绑定并需要Jackson批注

00:08:55.160 --> 00:09:03.960
好吧，现在还有另一种方法

00:08:59.040 --> 00:09:07.650
出来什么推特um需要多少人

00:09:03.960 --> 00:09:11.000
知道j-dub凳子，所以登门

00:09:07.650 --> 00:09:13.710
凳子是我们实际上的一种工具

00:09:11.000 --> 00:09:15.600
这是帮助迁移的工具

00:09:13.710 --> 00:09:18.180
分析现有代码，它会

00:09:15.600 --> 00:09:19.410
对jar文件进行静态分析并可以

00:09:18.180 --> 00:09:21.960
告诉你很多有趣的事情

00:09:19.410 --> 00:09:23.250
关于它的特性都具有潜力

00:09:21.960 --> 00:09:25.940
模块以及其他

00:09:23.250 --> 00:09:28.589
运行可能需要的模块

00:09:25.940 --> 00:09:29.040
这个工具是如此重要

00:09:28.589 --> 00:09:31.350
即使

00:09:29.040 --> 00:09:33.630
九点开发，我们将其移植回去

00:09:31.350 --> 00:09:36.509
到八个更新版本，所以如果您有

00:09:33.630 --> 00:09:38.160
一个相当新的JDK 8版本，然后您

00:09:36.509 --> 00:09:40.410
拥有玉器ups工具

00:09:38.160 --> 00:09:42.449
就像9中的那个一样现代，但是

00:09:40.410 --> 00:09:45.449
在那里，你已经知道了

00:09:42.449 --> 00:09:48.569
可能不知道，所以好吧之间的赤字

00:09:45.449 --> 00:09:51.089
其他事情一点点注意

00:09:48.569 --> 00:09:53.610
人们现在知道其中一件事

00:09:51.089 --> 00:09:56.850
我们在Java 9中所做的是

00:09:53.610 --> 00:10:03.779
封装内部API，因此Jade EPS具有

00:09:56.850 --> 00:10:05.250
告诉你是否有能力的能力

00:10:03.779 --> 00:10:09.360
有一个正在使用内部的jar文件

00:10:05.250 --> 00:10:11.639
 api的好推文，其中一些未使用

00:10:09.360 --> 00:10:12.870
通用API（如果已执行此操作） 

00:10:11.639 --> 00:10:16.949
这样做会打印警告

00:10:12.870 --> 00:10:19.380
等等，但是我们也可以

00:10:16.949 --> 00:10:23.550
只是问一下它做什么的总结

00:10:19.380 --> 00:10:26.279
 um依赖，因此需要Java 

00:10:23.550 --> 00:10:28.019
点库需要Java点续集哦

00:10:26.279 --> 00:10:31.699
对，我忘记了我使用了

00:10:28.019 --> 00:10:36.209
时间戳记类，所以我最好把它放在

00:10:31.699 --> 00:10:38.360
雇用了伽玛点续集，因为

00:10:36.209 --> 00:10:40.949
续集类型不在基本模块中

00:10:38.360 --> 00:10:42.660
然后在这里设置这是什么

00:10:40.949 --> 00:10:43.980
找不到好东西，但找不到

00:10:42.660 --> 00:10:45.779
东西是因为我没有讲

00:10:43.980 --> 00:10:49.699
上所有杰克逊的课堂路径

00:10:45.779 --> 00:10:52.319
事情让我抢了上课的路

00:10:49.699 --> 00:10:57.300
给贾德耶夫的课程路径，然后

00:10:52.319 --> 00:10:58.860
要求它做同样的分析

00:10:57.300 --> 00:11:03.120
现在确定推文um是

00:10:58.860 --> 00:11:05.389
在这三个杰克逊罐中使用类型

00:11:03.120 --> 00:11:05.389
档案

00:11:06.500 --> 00:11:14.870
好的，我已经有了模块化

00:11:08.480 --> 00:11:18.260
眼睛鸣叫嗯，让我们现在编译不好

00:11:14.870 --> 00:11:20.150
 Java C变得非常聪明

00:11:18.260 --> 00:11:21.980
编译模型编译模块是一个

00:11:20.150 --> 00:11:24.620
与编译完全不同的东西

00:11:21.980 --> 00:11:26.210
为编译一堆文件

00:11:24.620 --> 00:11:28.640
 classes目录并将其粘贴

00:11:26.210 --> 00:11:31.370
在jar文件中，因此Java C非常聪明

00:11:28.640 --> 00:11:32.900
现在我们将输出放入

00:11:31.370 --> 00:11:37.670
 mods，我们将告诉它模块

00:11:32.900 --> 00:11:39.800
路径是Lib目录，让我

00:11:37.670 --> 00:11:46.870
只需删除旧的推文发送一个罐子

00:11:39.800 --> 00:11:50.570
 Lib目录中的文件现在确定

00:11:46.870 --> 00:11:52.370
我们需要这样的模块路径是一种

00:11:50.570 --> 00:11:53.750
就像上课的路，但是

00:11:52.370 --> 00:11:56.420
在某些方面很重要

00:11:53.750 --> 00:11:59.000
系统在哪里找到模块的地方

00:11:56.420 --> 00:12:00.440
编译时和运行时之一

00:11:59.000 --> 00:12:02.210
与课堂道路的本质区别

00:12:00.440 --> 00:12:04.970
一旦找到模块

00:12:02.210 --> 00:12:07.100
该模块中仅从该模块加载

00:12:04.970 --> 00:12:08.750
模块的jar文件不会执行

00:12:07.100 --> 00:12:10.130
愚蠢的天真搜寻

00:12:08.750 --> 00:12:12.290
从前到后的类路径上的jar文件

00:12:10.130 --> 00:12:16.310
回到那边上头等舱

00:12:12.290 --> 00:12:18.590
碰巧找到一个大包装

00:12:16.310 --> 00:12:21.140
可靠配置的一部分好吗

00:12:18.590 --> 00:12:26.780
编译我们也可以给它一个模块

00:12:21.140 --> 00:12:29.180
源路径，这只是我们的源

00:12:26.780 --> 00:12:31.070
目录，直到它是我们想要的模块

00:12:29.180 --> 00:12:33.200
进行编译，Java C将会消失， 

00:12:31.070 --> 00:12:35.360
看看它，我们将找到所有这些文件

00:12:33.200 --> 00:12:37.630
做时间戳比较

00:12:35.360 --> 00:12:46.340
弄清楚需要编译什么， 

00:12:37.630 --> 00:12:49.090
在那里，我们走了

00:12:46.340 --> 00:12:49.090
他们早些哦

00:12:52.210 --> 00:13:03.670
是的，我把它们放在我身上的错误是什么

00:13:00.770 --> 00:13:09.820
到错误目录中的Limbo 

00:13:03.670 --> 00:13:09.820
好吧，让我们再次编译它

00:13:10.990 --> 00:13:16.310
好吧，我们已经爆炸了

00:13:13.160 --> 00:13:20.000
推特模块的分解形式

00:13:16.310 --> 00:13:21.470
在马自达直肠，我们现在可以

00:13:20.000 --> 00:13:25.040
我们可以做很多事情，让我们

00:13:21.470 --> 00:13:27.530
让我们在焦点模块上运行Java P 

00:13:25.040 --> 00:13:29.360
确保它看起来足够正确

00:13:27.530 --> 00:13:32.240
但这几乎是我输入的

00:13:29.360 --> 00:13:36.350
早先的好，就像我们现在可以做一个

00:13:32.240 --> 00:13:41.200
 jar文件，我们将其放回Lib中

00:13:36.350 --> 00:13:41.200
鸣叫一些罐子

00:13:46.630 --> 00:13:49.290
对

00:13:52.080 --> 00:13:56.710
在那阴暗的寒冷中退出了

00:13:55.090 --> 00:13:58.770
也得到了增强，它知道很多

00:13:56.710 --> 00:14:03.340
关于模块，我们可以说

00:13:58.770 --> 00:14:06.400
描述模块，它将找到

00:14:03.340 --> 00:14:12.970
模块信息（如果有）告诉你

00:14:06.400 --> 00:14:14.290
关于它的内容还可以，所以我们有了

00:14:12.970 --> 00:14:16.900
 Lib目录

00:14:14.290 --> 00:14:20.200
鸣叫一些罐子是一个适当的模块

00:14:16.900 --> 00:14:22.540
杰克逊罐子将保持不变

00:14:20.200 --> 00:14:27.310
现在用作自动模块

00:14:22.540 --> 00:14:29.620
应该能够运行我们给

00:14:27.310 --> 00:14:32.020
运行我的模块路径

00:14:29.620 --> 00:14:40.630
我要运行推文的lib目录

00:14:32.020 --> 00:14:42.460
我需要告诉一些模块什么

00:14:40.630 --> 00:14:44.730
主要的课是虽然我可以

00:14:42.460 --> 00:14:47.920
定义了实际上，但我没有

00:14:44.730 --> 00:14:52.830
让我们读读推文的JSON 

00:14:47.920 --> 00:14:59.860
现在文件没用了

00:14:52.830 --> 00:15:03.820
嗯，发生了什么，所以这里发生了什么

00:14:59.860 --> 00:15:07.450
是我们有一个无法访问的对象

00:15:03.820 --> 00:15:09.970
无法做出激动的异常或

00:15:07.450 --> 00:15:12.370
删除一些可访问的推文

00:15:09.970 --> 00:15:14.140
构造函数，因为模块鸣叫um 

00:15:12.370 --> 00:15:17.740
没有打开或完成推文

00:15:14.140 --> 00:15:21.580
模块Jackson数据绑定发生了什么

00:15:17.740 --> 00:15:23.860
在这里，杰克逊数据绑定不是，不是

00:15:21.580 --> 00:15:27.280
这是一个框架的小例子

00:15:23.860 --> 00:15:30.070
使用反射是当其中之一

00:15:27.280 --> 00:15:33.130
这些反思性框架现在是因为

00:15:30.070 --> 00:15:35.290
一件大事，整个主题

00:15:33.130 --> 00:15:37.270
努力一直提供强大

00:15:35.290 --> 00:15:41.440
封装使模块系统通过

00:15:37.270 --> 00:15:44.140
默认封装s-- api位于

00:15:41.440 --> 00:15:46.300
软件包，它们在以下位置不可访问

00:15:44.140 --> 00:15:47.560
您需要导出的运行时

00:15:46.300 --> 00:15:50.020
他们你以某种方式使他们

00:15:47.560 --> 00:15:53.890
如果您需要的话可以使用

00:15:50.020 --> 00:15:59.470
让我们回到中的模块信息

00:15:53.890 --> 00:16:02.279
适当的目录，我们可能尝试的是

00:15:59.470 --> 00:16:10.709
说这个出口

00:16:02.279 --> 00:16:12.740
在推特上阅读一些正确的只是去

00:16:10.709 --> 00:16:14.629
工作

00:16:12.740 --> 00:16:18.839
好吧，让我们退出

00:16:14.629 --> 00:16:20.430
好吧，我要去保存

00:16:18.839 --> 00:16:22.470
在这里用一个小贝壳

00:16:20.430 --> 00:16:26.389
我拥有的脚本

00:16:22.470 --> 00:16:34.160
 jar中的Java C融入其中

00:16:26.389 --> 00:16:37.860
我将钻探路径Lib模块的源代码

00:16:34.160 --> 00:16:42.120
好了，编译成一个罐子

00:16:37.860 --> 00:16:44.720
文件，让我们再次运行它是什么

00:16:42.120 --> 00:16:46.620
将会发生，但仍然无法正常工作

00:16:44.720 --> 00:16:48.689
为什么不起作用

00:16:46.620 --> 00:16:52.110
在这里，我们理智而方便

00:16:48.689 --> 00:16:55.379
对象对象异常的原因

00:16:52.110 --> 00:16:57.870
不起作用的是，仅导出一个

00:16:55.379 --> 00:17:00.059
软件包无法用于

00:16:57.870 --> 00:17:02.850
一种深层的侵入反射

00:17:00.059 --> 00:17:06.510
许多这样的反思框架

00:17:02.850 --> 00:17:08.880
要求也是故意的

00:17:06.510 --> 00:17:10.439
您正在定义想要的API 

00:17:08.880 --> 00:17:13.559
可以说好，我正在导出

00:17:10.439 --> 00:17:16.260
一些接口和一些类

00:17:13.559 --> 00:17:17.640
供其他模块使用，您知道

00:17:16.260 --> 00:17:18.959
对他们来说当然很好

00:17:17.640 --> 00:17:20.549
以正常方式引用它们

00:17:18.959 --> 00:17:23.789
编译时以正常方式引用它们

00:17:20.549 --> 00:17:25.829
在运行时的方式，但由于我想

00:17:23.789 --> 00:17:27.659
保护你的内心，你知道

00:17:25.829 --> 00:17:29.940
我们在谈论Java点库

00:17:27.659 --> 00:17:32.330
我们保护内部的模块是

00:17:29.940 --> 00:17:34.950
对安全性和完整性至关重要

00:17:32.330 --> 00:17:38.309
不应允许深度反射

00:17:34.950 --> 00:17:41.429
默认，所以还有另一个关键字

00:17:38.309 --> 00:17:44.429
可以使用，这就是所谓的打开

00:17:41.429 --> 00:17:47.580
在此错误消息中建议

00:17:44.429 --> 00:17:50.429
而不是在这里输入导出，我会说

00:17:47.580 --> 00:17:52.679
该模块打开了鸣叫一些

00:17:50.429 --> 00:17:55.230
打包一个，这是什么意思

00:17:52.679 --> 00:17:57.799
软件包在编译时不可用

00:17:55.230 --> 00:18:00.450
它不是API的编译时间

00:17:57.799 --> 00:18:02.970
但它在运行时可用于深度

00:18:00.450 --> 00:18:04.620
反射我是此代码的所有者

00:18:02.970 --> 00:18:05.940
知道我正在使用反射器框架

00:18:04.620 --> 00:18:08.039
不要介意这是否反映了您的

00:18:05.940 --> 00:18:09.809
框架深入内部

00:18:08.039 --> 00:18:13.590
那个包装的没关系

00:18:09.809 --> 00:18:14.820
实际上，我的意图是现在

00:18:13.590 --> 00:18:15.779
你真的需要你可以

00:18:14.820 --> 00:18:17.999
开和X 

00:18:15.779 --> 00:18:19.559
或包装的实际需要

00:18:17.999 --> 00:18:22.289
似乎很少见，但是你可以做

00:18:19.559 --> 00:18:23.849
那另一件事是我们的替代品

00:18:22.289 --> 00:18:26.219
可以做的是我们打开整个

00:18:23.849 --> 00:18:28.590
模块，这将使每个包

00:18:26.219 --> 00:18:30.599
开放，有时这是一种方法

00:18:28.590 --> 00:18:31.950
保存一些打字但没什么不同

00:18:30.599 --> 00:18:34.139
而不是说每个包裹都打开

00:18:31.950 --> 00:18:41.929
在那里，所以我们会做完整的

00:18:34.139 --> 00:18:46.379
打开或收到推文um将重新编译它

00:18:41.929 --> 00:18:49.080
我们将运行它，现在我们有了

00:18:46.379 --> 00:18:51.599
推特一些应用程序是一个模块

00:18:49.080 --> 00:18:55.519
它使用杰克逊的jar文件作为

00:18:51.599 --> 00:19:01.889
自动模块，一切正常

00:18:55.519 --> 00:19:04.139
好的接下来做什么

00:19:01.889 --> 00:19:05.549
一点Jerry和J链接工具

00:19:04.139 --> 00:19:09.029
我们可以仔细看看是什么

00:19:05.549 --> 00:19:17.129
其实在这里我有一点

00:19:09.029 --> 00:19:18.330
制作文件，这里有点杰里没有

00:19:17.129 --> 00:19:22.769
里面有很多东西，但是它拥有一切

00:19:18.330 --> 00:19:24.899
我们需要我们知道我们需要续集

00:19:22.769 --> 00:19:27.119
总是需要基础和续集

00:19:24.899 --> 00:19:38.940
很好地记录日志和XML 

00:19:27.119 --> 00:19:41.249
因为XML没问题，所以我们现在可以重新运行

00:19:38.940 --> 00:19:43.289
这与减少杰里和

00:19:41.249 --> 00:19:45.659
是的，它不仅有效，而且

00:19:43.289 --> 00:19:48.229
那里有几个新的选择

00:19:45.659 --> 00:19:51.690
运行时要显示模块

00:19:48.229 --> 00:19:53.460
分辨率从

00:19:51.690 --> 00:19:55.229
以前的版本，我们做了很大的清理

00:19:53.460 --> 00:19:58.139
最近在所有命令行上

00:19:55.229 --> 00:20:01.099
选项，如果您显示模块分辨率

00:19:58.139 --> 00:20:03.599
然后运行时将进行打印

00:20:01.099 --> 00:20:06.359
本质上是进度报告

00:20:03.599 --> 00:20:08.669
在配置模块时继续进行

00:20:06.359 --> 00:20:10.469
系统，因此您可以在顶部看到它

00:20:08.669 --> 00:20:11.820
从根模块开始是推文

00:20:10.469 --> 00:20:13.169
我们开始的模块

00:20:11.820 --> 00:20:16.679
这就是我们要尝试的事情

00:20:13.169 --> 00:20:17.940
运行推文um需要一些数据

00:20:16.679 --> 00:20:21.269
绑定有续集注射

00:20:17.940 --> 00:20:24.599
消息的注释显示您在哪里

00:20:21.269 --> 00:20:26.399
这些模块在大多数情况下都已定义

00:20:24.599 --> 00:20:29.090
它在文件中，但是Java点续集他

00:20:26.399 --> 00:20:31.090
有这个有趣的网址Jay arty： 

00:20:29.090 --> 00:20:34.340
 Javadoc续集，这意味着它是一个

00:20:31.090 --> 00:20:36.710
使用以下命令内置到系统映像中的模块

00:20:34.340 --> 00:20:40.100
使用内部jrt虚拟文件

00:20:36.710 --> 00:20:45.499
系统，然后再构建

00:20:40.100 --> 00:20:47.600
休息，我们要去比赛了，所以

00:20:45.499 --> 00:20:49.429
关于他们拥有的自动模块的一句话

00:20:47.600 --> 00:20:54.080
一直有争议

00:20:49.429 --> 00:20:57.710
很难找到正确的方法

00:20:54.080 --> 00:21:02.299
穿过我们的方式

00:20:57.710 --> 00:21:05.480
通过各种取舍，如果

00:21:02.299 --> 00:21:06.980
你有一个应用程序，但不是

00:21:05.480 --> 00:21:09.529
有些东西不在哪里

00:21:06.980 --> 00:21:11.690
您将要发布它不是

00:21:09.529 --> 00:21:13.580
它有一个API的东西，而你却没有

00:21:11.690 --> 00:21:15.919
将要发布

00:21:13.580 --> 00:21:18.409
外部使用，那么自动模块是

00:21:15.919 --> 00:21:20.629
一个伟大的工具，使您能够

00:21:18.409 --> 00:21:22.460
开始模块化您的应用程序

00:21:20.629 --> 00:21:24.529
如果您有内部应用程序

00:21:22.460 --> 00:21:26.659
也许实际上是一堆

00:21:24.529 --> 00:21:28.190
可以的模块数量

00:21:26.659 --> 00:21:30.529
那或者你可以从一个大的开始

00:21:28.190 --> 00:21:33.649
不是的应用程序并将其分解

00:21:30.529 --> 00:21:36.200
放入模块中就可以了

00:21:33.649 --> 00:21:39.679
让那些模块使用现有的jar 

00:21:36.200 --> 00:21:41.450
文件作为自动模块是什么

00:21:39.679 --> 00:21:44.059
这样的好主意是

00:21:41.450 --> 00:21:45.470
图书馆的维护者，尤其是图书馆的维护者

00:21:44.059 --> 00:21:46.820
如果您是

00:21:45.470 --> 00:21:49.309
您发布到Maven的库

00:21:46.820 --> 00:21:51.049
中央或任何地方，那与你

00:21:49.309 --> 00:21:53.330
模块化并制作该库

00:21:51.049 --> 00:21:55.850
依靠其他jar文件使用它们

00:21:53.330 --> 00:22:01.220
自动模块名称有点

00:21:55.850 --> 00:22:03.919
冒险，因为我基本上什么时候

00:22:01.220 --> 00:22:05.299
您正在使用的那些Windows jar文件

00:22:03.919 --> 00:22:07.519
自动模块最终

00:22:05.299 --> 00:22:09.110
他们希望将其模块化

00:22:07.519 --> 00:22:10.429
维护者z'，他们可能会选择一个

00:22:09.110 --> 00:22:12.320
别的名字

00:22:10.429 --> 00:22:15.649
事实上，希望他们会选择

00:22:12.320 --> 00:22:18.110
明智的反向DNS模块通道

00:22:15.649 --> 00:22:20.600
长期是命名一个的最佳方法

00:22:18.110 --> 00:22:22.730
模块，而不是我们的时髦

00:22:20.600 --> 00:22:24.950
源自北极

00:22:22.730 --> 00:22:30.320
 jar文件名本质上是Maven 

00:22:24.950 --> 00:22:32.480
文物ID，因此，如果您的

00:22:30.320 --> 00:22:34.429
这是内部的模块化代码

00:22:32.480 --> 00:22:37.190
自动使用您的组织

00:22:34.429 --> 00:22:40.580
模块准备好了

00:22:37.190 --> 00:22:42.860
这些jar文件是模块化的

00:22:40.580 --> 00:22:44.240
必须调整您的模块声明

00:22:42.860 --> 00:22:46.580
因为他们的名字很好

00:22:44.240 --> 00:22:49.820
变化，但如果您要维护

00:22:46.580 --> 00:22:52.010
为外部发布的库

00:22:49.820 --> 00:22:54.769
在中央或您发布的任何地方使用

00:22:52.010 --> 00:22:57.080
发布模块非常谨慎

00:22:54.769 --> 00:22:59.299
取决于自动模块

00:22:57.080 --> 00:23:01.730
因为您实际上是在吸引用户

00:22:59.299 --> 00:23:03.740
您模块的风险

00:23:01.730 --> 00:23:08.570
后来打破而不是

00:23:03.740 --> 00:23:10.130
你更新你的好吧，所以我们已经

00:23:08.570 --> 00:23:12.919
天才推特，嗯，我们去其他

00:23:10.130 --> 00:23:14.960
很好的方式有趣

00:23:12.919 --> 00:23:19.190
剩下的时间说仍然是50分钟

00:23:14.960 --> 00:23:21.409
当我在这里盲目飞行时，可以

00:23:19.190 --> 00:23:28.940
担心我要收拾东西

00:23:21.409 --> 00:23:30.679
在这里，我要前进，我们

00:23:28.940 --> 00:23:37.789
现在在另一个世界

00:23:30.679 --> 00:23:39.529
所以这是我的眼泪鸣叫

00:23:37.789 --> 00:23:41.480
编译方式与我相同

00:23:39.529 --> 00:23:43.789
我之前要做的是

00:23:41.480 --> 00:23:47.539
普通ol jar文件没有剩余时间剩余27 

00:23:43.789 --> 00:23:52.639
分钟，谢谢，好吧，我要去

00:23:47.539 --> 00:23:53.840
以正常方式编译它，我

00:23:52.639 --> 00:23:56.110
要作弊，只说斜线

00:23:53.840 --> 00:23:56.110
星

00:23:59.370 --> 00:24:05.080
好吧，所以我有推特和罐子

00:24:03.310 --> 00:24:07.390
那里没有模块信息

00:24:05.080 --> 00:24:10.900
这是一个普通的旧jar文件，现在让我们

00:24:07.390 --> 00:24:17.080
假装我们是……的维护者

00:24:10.900 --> 00:24:20.470
 Jackson JSON库的发生

00:24:17.080 --> 00:24:22.830
我有这三个罐子的源代码

00:24:20.470 --> 00:24:28.630
我们一直在这里使用的文件

00:24:22.830 --> 00:24:30.550
他们是他们还不是模块，但是

00:24:28.630 --> 00:24:32.680
我们可以看看里面，看到你的通讯

00:24:30.550 --> 00:24:35.200
更快的XML Jackson核心

00:24:32.680 --> 00:24:38.350
你知道其他所有课程

00:24:35.200 --> 00:24:42.580
在服务中相遇，所以这是

00:24:38.350 --> 00:24:46.680
所有在那里，我们如何去做一个

00:24:42.580 --> 00:24:50.110
 Jackson核心的模块声明

00:24:46.680 --> 00:24:53.680
神器杰克逊核心项目很好

00:24:50.110 --> 00:24:59.950
我们可以运行jaidev，它可以给我们一些

00:24:53.680 --> 00:25:01.660
正确的想法，这将告诉我们有关

00:24:59.950 --> 00:25:03.880
就像它告诉我们有关

00:25:01.660 --> 00:25:06.970
要求我们需要

00:25:03.880 --> 00:25:08.710
对于自身的推文，我们可以隐藏

00:25:06.970 --> 00:25:11.700
这些信息确实对我们有帮助

00:25:08.710 --> 00:25:14.500
与要求，但与

00:25:11.700 --> 00:25:18.850
出口我们如何做得好

00:25:14.500 --> 00:25:22.420
可以做些粗暴的事情

00:25:18.850 --> 00:25:25.030
可以看一下目录

00:25:22.420 --> 00:25:26.260
的结构，然后说好吧

00:25:25.030 --> 00:25:30.400
他们将成为包裹

00:25:26.260 --> 00:25:34.240
对应于所有这些东西，但是

00:25:30.400 --> 00:25:35.650
那会很乏味，所以J 

00:25:34.240 --> 00:25:38.860
再次进行救援

00:25:35.650 --> 00:25:41.800
 Jade EPS还有另一种选择

00:25:38.860 --> 00:25:48.720
我们可以要求它生成模块

00:25:41.800 --> 00:25:55.090
 Python Java文件j-dub生成模块

00:25:48.720 --> 00:25:56.620
信息，我要输入凳子是

00:25:55.090 --> 00:25:58.030
将写代码写入我的源代码

00:25:56.620 --> 00:26:00.880
树总是有点危险，所以要

00:25:58.030 --> 00:26:08.110
小心您实际上想做的

00:26:00.880 --> 00:26:10.960
 Lib Jackson的核心，现在我有一个

00:26:08.110 --> 00:26:13.290
模块信息让我们回到Emacs 

00:26:10.960 --> 00:26:13.290
这里

00:26:16.240 --> 00:26:21.499
有由生成的模块信息

00:26:19.129 --> 00:26:24.169
吉普森实际上看起来不错

00:26:21.499 --> 00:26:26.899
好，它出口包装出口全部

00:26:24.169 --> 00:26:29.749
默认情况下，有一个新的

00:26:26.899 --> 00:26:31.100
这里的东西就是那个

00:26:29.749 --> 00:26:34.639
提供条款

00:26:31.100 --> 00:26:36.980
侧面说明模块系统知道

00:26:34.639 --> 00:26:38.690
您熟悉Java的服务

00:26:36.980 --> 00:26:41.629
 util服务加载器已经存在

00:26:38.690 --> 00:26:43.879
很长一段时间是

00:26:41.629 --> 00:26:45.590
直接的服务提供商

00:26:43.879 --> 00:26:48.590
平台中已有的设施

00:26:45.590 --> 00:26:50.539
我们已经升级了，就是这样

00:26:48.590 --> 00:26:52.580
与模块系统集成

00:26:50.539 --> 00:26:54.169
模块系统了解服务

00:26:52.580 --> 00:26:56.179
模块系统需要了解

00:26:54.169 --> 00:26:58.369
服务，因为如果您有服务

00:26:56.179 --> 00:27:01.039
提供者，可能需要一些

00:26:58.369 --> 00:27:02.899
其他模块，如果是全部的话

00:27:01.039 --> 00:27:05.480
整个决议的一部分

00:27:02.899 --> 00:27:07.309
和配置过程等等

00:27:05.480 --> 00:27:10.669
这句话是说

00:27:07.309 --> 00:27:14.450
 Jackson核心模块提供了此功能

00:27:10.669 --> 00:27:16.700
杰克逊这杰森工厂服务和

00:27:14.450 --> 00:27:21.139
它通过阅读元知道

00:27:16.700 --> 00:27:26.480
和斜杠服务目录可以

00:27:21.139 --> 00:27:30.340
旁注好吧，让我们编译

00:27:26.480 --> 00:27:32.749
现在我们有了杰克逊核心模块

00:27:30.340 --> 00:27:33.980
我将把这些新模块

00:27:32.749 --> 00:27:36.369
在另一个目录中

00:27:33.980 --> 00:27:36.369
图书馆

00:27:43.120 --> 00:27:59.230
然后我们去描述罐子，那是

00:27:55.480 --> 00:28:01.330
正是我们所期望的，所以让我们开始吧

00:27:59.230 --> 00:28:05.620
然后做杰克逊注解和

00:28:01.330 --> 00:28:08.730
数据绑定jar文件，我要做的是

00:28:05.620 --> 00:28:12.790
我将对这里的所有内容运行EPS 

00:28:08.730 --> 00:28:15.130
所以它将生成三个模块

00:28:12.790 --> 00:28:17.110
当您使用Jade时立即显示相关信息

00:28:15.130 --> 00:28:20.290
应用程序这样做总是一个好主意

00:28:17.110 --> 00:28:21.840
去看看它创造了什么，因为

00:28:20.290 --> 00:28:25.540
它创造的东西可能没有任何意义

00:28:21.840 --> 00:28:27.580
也许可以改善一下

00:28:25.540 --> 00:28:30.460
这是数据绑定模型

00:28:27.580 --> 00:28:34.870
相当大的模块，让我们来

00:28:30.460 --> 00:28:37.090
寻找那里的第一个出口

00:28:34.870 --> 00:28:39.430
这里的任何出口看起来像他们

00:28:37.090 --> 00:28:46.300
不属于或者不是一个好主意

00:28:39.430 --> 00:28:48.220
出口你直到现在也许吧，但是

00:28:46.300 --> 00:28:50.920
不会不是专家

00:28:48.220 --> 00:28:52.420
这个项目的内部

00:28:50.920 --> 00:28:54.160
我不确定但有

00:28:52.420 --> 00:28:56.170
肯定这些意味着坐着

00:28:54.160 --> 00:28:58.450
如果您有怀疑的话

00:28:56.170 --> 00:29:04.210
包名为dimple，是的，不要

00:28:58.450 --> 00:29:06.100
导出它，让我们不要那样做吧

00:29:04.210 --> 00:29:08.140
我们不会导出这些内容，也不会看到

00:29:06.100 --> 00:29:10.530
另一个服务提供商，然后返回

00:29:08.140 --> 00:29:13.000
在顶部，这是值得注意的

00:29:10.530 --> 00:29:14.710
这些是要求指令，但

00:29:13.000 --> 00:29:16.180
他们是一种特殊的要求

00:29:14.710 --> 00:29:19.570
被称为Erik的指令

00:29:16.180 --> 00:29:21.580
需要传递是什么意思

00:29:19.570 --> 00:29:26.760
好吧，这实际上是建立一个

00:29:21.580 --> 00:29:29.770
一步式传递式快捷键

00:29:26.760 --> 00:29:32.260
所以Jackson数据绑定模块导出了

00:29:29.770 --> 00:29:34.780
所有这些软件包

00:29:32.260 --> 00:29:37.780
包括其类和接口

00:29:34.780 --> 00:29:39.280
签名是指杰克逊中的类型

00:29:37.780 --> 00:29:40.780
批注模块Jackson核心

00:29:39.280 --> 00:29:44.320
模块中有续集模块的模块

00:29:40.780 --> 00:29:48.490
 java xml模块以及其他一些模块

00:29:44.320 --> 00:29:53.590
说鸣叫一些使用杰克逊的东西

00:29:48.490 --> 00:29:55.810
数据绑定模块，它不需要

00:29:53.590 --> 00:29:56.380
说这也需要杰克逊

00:29:55.810 --> 00:29:59.020
注解

00:29:56.380 --> 00:30:02.230
课程和XML中的Java Seagal，因为

00:29:59.020 --> 00:30:03.850
这些要求赋予了它

00:30:02.230 --> 00:30:05.620
传递直接指令和

00:30:03.850 --> 00:30:07.990
你可以想到的非正式的感觉

00:30:05.620 --> 00:30:10.510
不仅需要传递和说

00:30:07.990 --> 00:30:14.320
这个模块要求

00:30:10.510 --> 00:30:16.290
该模块重新导出该API 

00:30:14.320 --> 00:30:18.880
一个到任何使用此模块的模块

00:30:16.290 --> 00:30:21.700
所以从技术上讲它不是真的反应

00:30:18.880 --> 00:30:23.620
运动它的真正含义是

00:30:21.700 --> 00:30:26.590
说用户模块也

00:30:23.620 --> 00:30:28.780
需要那个模块但是反应运动

00:30:26.590 --> 00:30:34.710
是一种很好的非正式思考方式

00:30:28.780 --> 00:30:34.710
好的，那是数据绑定模块

00:30:38.850 --> 00:30:46.090
对

00:30:40.320 --> 00:30:50.710
好吧，让我们编译数据绑定好

00:30:46.090 --> 00:30:53.280
批注，然后我们将进行编译

00:30:50.710 --> 00:30:53.280
数据绑定

00:30:59.820 --> 00:31:05.059
这是一个很大的模块

00:31:01.529 --> 00:31:08.239
一点，现在我们有三个

00:31:05.059 --> 00:31:10.429
 Lib目录末尾的Jackson模块

00:31:08.239 --> 00:31:14.129
好吧，我已经拿了

00:31:10.429 --> 00:31:15.479
让我将推文从中移出

00:31:14.129 --> 00:31:16.679
 Lib目录的常客，只是把

00:31:15.479 --> 00:31:19.109
它在这里，所以我们确定我们没有使用

00:31:16.679 --> 00:31:22.289
杰克逊的原始版本或

00:31:19.109 --> 00:31:25.350
像这样的任何奇怪的事

00:31:22.289 --> 00:31:30.149
让我们尝试现在运行此Java模块

00:31:25.350 --> 00:31:32.940
路径M Lib CP类，因为那是

00:31:30.149 --> 00:31:40.019
 CP花呢总结得好

00:31:32.940 --> 00:31:48.539
 jar或从tweets上获取tumets um main 

00:31:40.019 --> 00:31:50.340
杰森嗯发生了什么事没课

00:31:48.539 --> 00:31:52.979
死亡发现XML的错误补偿

00:31:50.340 --> 00:31:56.460
杰克逊核心等等等等等等不存在

00:31:52.979 --> 00:31:59.549
杰克逊发生了什么

00:31:56.460 --> 00:32:00.599
模块在模块路径上，但是

00:31:59.549 --> 00:32:02.009
他们没有被加载

00:32:00.599 --> 00:32:04.320
解决了他们不是这样的原因

00:32:02.009 --> 00:32:06.149
解决的是推文和AH罐只是

00:32:04.320 --> 00:32:07.889
常规的旧jar文件，没有模块

00:32:06.149 --> 00:32:09.330
这里发生的事情没有办法

00:32:07.889 --> 00:32:11.489
运行时系统找出

00:32:09.330 --> 00:32:14.609
推特实际上需要那些，所以我

00:32:11.489 --> 00:32:20.399
其实不得不告诉另一个

00:32:14.609 --> 00:32:29.190
选项添加模块Jackson核心Jackson 

00:32:20.399 --> 00:32:32.099
数据绑定杰克逊注释，现在

00:32:29.190 --> 00:32:33.629
工作，所以我们不得不做一点

00:32:32.099 --> 00:32:35.609
手动配置，因为鸣叫um 

00:32:33.629 --> 00:32:40.229
只是坐在那里

00:32:35.609 --> 00:32:42.419
类路径作为优化，如果您

00:32:40.229 --> 00:32:44.549
你记得杰克逊的数据

00:32:42.419 --> 00:32:46.379
绑定需要杰克逊核心注入和

00:32:44.549 --> 00:32:47.549
我们实际上可以摆脱的注释

00:32:46.379 --> 00:32:49.649
还有一些较短的东西

00:32:47.549 --> 00:32:51.960
其实只需要提杰克逊

00:32:49.649 --> 00:32:56.849
数据藤所以不是那么多

00:32:51.960 --> 00:32:59.129
必须输入文字，因此您可能会

00:32:56.849 --> 00:33:02.899
想知道类路径如何关联

00:32:59.129 --> 00:33:06.330
在模型系统中很好地进行模块化

00:33:02.899 --> 00:33:10.430
我们已经设定的方式

00:33:06.330 --> 00:33:13.880
类，每种类型实际上都在模块中

00:33:10.430 --> 00:33:17.200
但是有一个特殊的模块叫做

00:33:13.880 --> 00:33:19.070
未命名的模块

00:33:17.200 --> 00:33:21.440
基本上从时间开始

00:33:19.070 --> 00:33:24.020
有一个未命名包的概念

00:33:21.440 --> 00:33:26.060
在Java中，如果您只是键入就知道foo 

00:33:24.020 --> 00:33:27.560
 Java，它不在任何包中

00:33:26.060 --> 00:33:30.170
写你可以写你可以编译

00:33:27.560 --> 00:33:32.120
您可以运行它集成在

00:33:30.170 --> 00:33:33.860
从技术上讲它不在

00:33:32.120 --> 00:33:35.450
实际在包装中的任何包装

00:33:33.860 --> 00:33:36.680
它被称为未命名包，如果

00:33:35.450 --> 00:33:38.630
您阅读了精美的文字和Java 

00:33:36.680 --> 00:33:41.030
语言规范Java vm规范

00:33:38.630 --> 00:33:43.340
您会看到这是怎么回事

00:33:41.030 --> 00:33:45.560
解决了，所以我们做了类似的技巧

00:33:43.340 --> 00:33:49.430
在模块系统代码中

00:33:45.560 --> 00:33:52.270
将classpath加载到未命名的文件中

00:33:49.430 --> 00:33:56.810
模块是没有名称的模块

00:33:52.270 --> 00:33:58.940
未命名的模块读取它被感染

00:33:56.810 --> 00:34:01.100
需要其他所有模块

00:33:58.940 --> 00:34:04.790
已经解决了，这就是我们的方式

00:34:01.100 --> 00:34:06.230
这就是我们对事物的理解

00:34:04.790 --> 00:34:08.240
当然也出口一切

00:34:06.230 --> 00:34:11.929
因为那正是

00:34:08.240 --> 00:34:13.820
类专利是我做到的

00:34:11.929 --> 00:34:16.540
黄色让我们做出一点诊断

00:34:13.820 --> 00:34:16.540
杰瑞再次

00:34:22.020 --> 00:34:32.840
我们可以在那个小的JRE上运行它

00:34:25.590 --> 00:34:37.110
让我们边做展示模块

00:34:32.840 --> 00:34:39.570
你可以在这里看到它正在做

00:34:37.110 --> 00:34:42.080
我们几乎期望增加

00:34:39.570 --> 00:34:43.220
命令行上的modules选项

00:34:42.080 --> 00:34:45.990
 [音乐] 

00:34:43.220 --> 00:34:49.020
指定的其他路线

00:34:45.990 --> 00:34:50.720
分辨率，但它配置了杰克逊

00:34:49.020 --> 00:34:56.220
他们由Devine模块配置其余部分

00:34:50.720 --> 00:34:58.500
然后我们就赢了，所以

00:34:56.220 --> 00:35:00.390
模块化的库

00:34:58.500 --> 00:35:03.840
无需模块化应用程序

00:35:00.390 --> 00:35:08.390
最后，让我们回去做

00:35:03.840 --> 00:35:08.390
再次将um推到适当的模块

00:35:16.580 --> 00:35:21.790
需要外显子组数据盲目

00:35:34.830 --> 00:35:48.710
看起来不错，我认为是正确的

00:35:38.090 --> 00:35:48.710
可以编译

00:35:52.200 --> 00:36:08.569
模块路径和实时鸣叫一些鸣叫

00:36:02.280 --> 00:36:08.569
时间JSON好，这是诊断

00:36:13.190 --> 00:36:17.780
我们以推文开始，我们以推文开始

00:36:15.440 --> 00:36:19.840
需要一些东西，我们进行配置

00:36:17.780 --> 00:36:21.830
杰克逊数据藤和其他

00:36:19.840 --> 00:36:23.900
我们完成了一个很好的简单

00:36:21.830 --> 00:36:29.540
模块图类路径为空

00:36:23.900 --> 00:36:32.780
一切都作为模块运行，因此

00:36:29.540 --> 00:36:35.560
总结迁移到模块确实需要

00:36:32.780 --> 00:36:37.550
一些工作，没有它就可以做到

00:36:35.560 --> 00:36:40.370
等待着你所有的图书馆

00:36:37.550 --> 00:36:43.520
用于迁移到模块，那就是

00:36:40.370 --> 00:36:45.950
好吧，这是发送方式，这是一个

00:36:43.520 --> 00:36:47.240
如果从仿制药那里借来的技巧

00:36:45.950 --> 00:36:51.620
记得记得泛型是什么时候

00:36:47.240 --> 00:36:54.410
当我们回到Java 5中时

00:36:51.620 --> 00:36:57.290
保留原始类型的概念，我们

00:36:54.410 --> 00:36:59.990
没有输入修饰类型

00:36:57.290 --> 00:37:02.000
仍然是一个有争议的决定，但

00:36:59.990 --> 00:37:04.490
原因恰恰是为了让你

00:37:02.000 --> 00:37:07.160
无需创建自己的代码

00:37:04.490 --> 00:37:09.710
等待所有的图书馆你

00:37:07.160 --> 00:37:11.440
过去通常是诚实的，这是可行的

00:37:09.710 --> 00:37:13.910
很好，尽管仍然有

00:37:11.440 --> 00:37:16.760
令人苦恼的代码量在那里

00:37:13.910 --> 00:37:18.650
还不是真正的，但是

00:37:16.760 --> 00:37:19.990
就是这样，这是一个把戏

00:37:18.650 --> 00:37:22.130
被称为迁移

00:37:19.990 --> 00:37:24.940
兼容性和自动模块是

00:37:22.130 --> 00:37:27.140
获得迁移兼容性的方法

00:37:24.940 --> 00:37:32.480
希望每个人随着时间的流逝

00:37:27.140 --> 00:37:34.460
朝向模块的东西

00:37:32.480 --> 00:37:37.540
可以说的是

00:37:34.460 --> 00:37:40.430
不是，我当然不希望每一个

00:37:37.540 --> 00:37:42.920
活跃的代码主体在那里迁移

00:37:40.430 --> 00:37:45.950
迁移现有大型模块

00:37:42.920 --> 00:37:48.530
模块的代码体可能非常极端

00:37:45.950 --> 00:37:51.950
昂贵而痛苦的是我花了我们

00:37:48.530 --> 00:37:55.460
 JDK模块化的八年时间

00:37:51.950 --> 00:37:57.650
所以我对现有的建议

00:37:55.460 --> 00:37:59.540
系统是您之前要仔细考虑的

00:37:57.650 --> 00:38:01.820
开始模块化的道路

00:37:59.540 --> 00:38:03.200
你知道OSGi的人是完全

00:38:01.820 --> 00:38:05.240
关于这个模块化的

00:38:03.200 --> 00:38:07.610
现有的代码库可能需要大量工作

00:38:05.240 --> 00:38:09.230
坦率地说，这可能不值得，但

00:38:07.610 --> 00:38:11.900
如果您正在从中开始一个新项目

00:38:09.230 --> 00:38:16.940
从头开始然后绝对考虑使用

00:38:11.900 --> 00:38:20.360
从头开始的模块

00:38:16.940 --> 00:38:23.090
所以进一步的信息拼图是

00:38:20.360 --> 00:38:26.210
被保留仍然是一个相当大的项目

00:38:23.090 --> 00:38:28.070
它由六个单独的JDK覆盖

00:38:26.210 --> 00:38:31.250
开放的JDK中的增强建议

00:38:28.070 --> 00:38:34.400
社区加上爵士乐是376 

00:38:31.250 --> 00:38:40.610
模块系统本身，它位于

00:38:34.400 --> 00:38:43.580
 Java社区流程，因此这是一部分

00:38:40.610 --> 00:38:45.830
 JDK 9的存在

00:38:43.580 --> 00:38:48.290
在那里有一段时间你可以得到你

00:38:45.830 --> 00:38:51.770
可以获得最新的JDK 9抢先体验

00:38:48.290 --> 00:38:53.810
在JDK Java net / 9上构建

00:38:51.770 --> 00:38:55.640
新网址，旧网址重定向到这里， 

00:38:53.810 --> 00:38:59.210
这是我们移走的新网址

00:38:55.640 --> 00:39:02.510
这是因为其余的java.net都在进行中

00:38:59.210 --> 00:39:07.580
离开所以它会在那里

00:39:02.510 --> 00:39:09.110
发布了我不知道的mmm 

00:39:07.580 --> 00:39:12.620
这周早些时候的戏

00:39:09.110 --> 00:39:15.770
我认为目前的时间表

00:39:12.620 --> 00:39:17.630
 ga日期为7月27日可能有点

00:39:15.770 --> 00:39:21.620
不切实际，但我希望我们能够

00:39:17.630 --> 00:39:26.060
几个月内发货

00:39:21.620 --> 00:39:27.950
在那之后，我们有12 

00:39:26.060 --> 00:39:31.970
我为Oracle工作的问题分钟

00:39:27.950 --> 00:39:36.490
不相信我说过的一句话

00:39:31.970 --> 00:39:36.490
那里的麦克风和迈克

00:39:40.840 --> 00:39:44.490
返回信息页面

00:39:50.490 --> 00:39:57.270
当您采用Java核心并使其成为

00:39:53.339 --> 00:39:59.160
模块，我们比较了模块类

00:39:57.270 --> 00:40:01.859
你手工创建的，然后是什么

00:39:59.160 --> 00:40:04.190
被认为是模块本身

00:40:01.859 --> 00:40:10.170
我看到它有一个基于Java的需求

00:40:04.190 --> 00:40:15.540
强制我看到，但是你记得

00:40:10.170 --> 00:40:18.270
确切的哦，在你看到这个词

00:40:15.540 --> 00:40:26.970
可能在describe模块中授权

00:40:18.270 --> 00:40:29.820
输出山药权需要Java强制

00:40:26.970 --> 00:40:34.589
对，所以那是一个很好的

00:40:29.820 --> 00:40:36.869
问题阿拉让我解释一下

00:40:34.589 --> 00:40:40.080
所描述的模块选项2 

00:40:36.869 --> 00:40:43.410
 jar命令和类似的东西，例如

00:40:40.080 --> 00:40:45.390
当您运行它时，您将运行Java P 

00:40:43.410 --> 00:40:47.250
向您展示超出您表达能力的内容

00:40:45.390 --> 00:40:49.710
源代码，因为它们更多

00:40:47.250 --> 00:40:52.980
他们是一个类文件中的更多位

00:40:49.710 --> 00:40:55.020
然后然后然后严格地需要

00:40:52.980 --> 00:40:57.450
表示源代码中的内容之一

00:40:55.020 --> 00:41:00.330
类文件中的位是否用于

00:40:57.450 --> 00:41:03.690
需要由

00:41:00.330 --> 00:41:06.960
 Java语言规范，因此

00:41:03.690 --> 00:41:09.240
这是一个它是它的一种

00:41:06.960 --> 00:41:11.609
在某些方面更理论化

00:41:09.240 --> 00:41:13.830
使用比实际使用，但它告诉我们

00:41:11.609 --> 00:41:16.349
可以告诉一个工具，例如

00:41:13.830 --> 00:41:18.930
 Java插入了require指令

00:41:16.349 --> 00:41:21.240
 C，因为它是规范要求的

00:41:18.930 --> 00:41:23.520
而不是

00:41:21.240 --> 00:41:25.670
如果我实际上在代码中表示

00:41:23.520 --> 00:41:29.970
自己输入需要Java点库

00:41:25.670 --> 00:41:31.650
该命令不会在那里，所以它是

00:41:29.970 --> 00:41:35.180
这是一个微妙的区别，但它是滥用

00:41:31.650 --> 00:41:35.180
某些工具

00:41:37.860 --> 00:41:40.850
放在前面

00:41:44.970 --> 00:41:52.809
在这个样本中，我看到您打开了

00:41:48.180 --> 00:41:54.489
他们放了一些模组，但这是一个

00:41:52.809 --> 00:41:56.859
简单的案例吧，所以你把他们放

00:41:54.489 --> 00:41:58.059
一些应用程序模块，实际上

00:41:56.859 --> 00:41:59.890
很简单，但是如果有

00:41:58.059 --> 00:42:01.749
那里的一些属性像

00:41:59.890 --> 00:42:04.089
自动小数或

00:42:01.749 --> 00:42:06.130
我们班上另一个模块

00:42:04.089 --> 00:42:07.779
打包另一个不是的库

00:42:06.130 --> 00:42:10.989
与模块化你如何

00:42:07.779 --> 00:42:13.359
对不起，让我确保我

00:42:10.989 --> 00:42:16.269
了解问题，因为哦，等等

00:42:13.359 --> 00:42:18.069
等待，如果tweetIn一直在使用

00:42:16.269 --> 00:42:20.499
其他一些更复杂的类型

00:42:18.069 --> 00:42:22.329
模块，因为杰克逊现在只是

00:42:20.499 --> 00:42:25.299
试图从中获取属性

00:42:22.329 --> 00:42:27.940
每个班级都推特，布莱恩很简单

00:42:25.299 --> 00:42:30.759
对，你希望能够

00:42:27.940 --> 00:42:33.099
访问，但是如果您有

00:42:30.759 --> 00:42:38.799
以及该类中的更多属性

00:42:33.099 --> 00:42:40.779
还没开好怎么办

00:42:38.799 --> 00:42:45.999
的其他Kojo属性

00:42:40.779 --> 00:42:48.099
使用以下类型的推文类

00:42:45.999 --> 00:42:50.769
在推文中定义的

00:42:48.099 --> 00:42:52.839
模块，但不能打开另一个模块或在

00:42:50.769 --> 00:42:54.660
另一个模块另一个不，是的

00:42:52.839 --> 00:42:59.289
其实不管他们在哪里

00:42:54.660 --> 00:43:02.799
那好吧，这完全取决于

00:42:59.289 --> 00:43:06.849
 Jackson数据如何绑定框架

00:43:02.799 --> 00:43:09.880
它需要走多深可能是

00:43:06.849 --> 00:43:14.589
它只需要对

00:43:09.880 --> 00:43:17.109
推文客观对象本身正确

00:43:14.589 --> 00:43:19.299
并且，如果且如果其中之一的值

00:43:17.109 --> 00:43:20.710
这些属性是你知道其他一些

00:43:19.299 --> 00:43:23.589
只要在其他地方输入

00:43:20.710 --> 00:43:25.749
出口，杰克逊可以使用其公共场所

00:43:23.589 --> 00:43:29.140
 API，那很好，但是如果Jackson 

00:43:25.749 --> 00:43:32.019
由于某种原因必须开始

00:43:29.140 --> 00:43:34.029
其他类型的东西是为此

00:43:32.019 --> 00:43:37.569
值也必须放在包装中

00:43:34.029 --> 00:43:39.009
这是值得反思的，但通常

00:43:37.569 --> 00:43:40.329
在这些反思框架中

00:43:39.009 --> 00:43:42.430
承诺他们不会跟随

00:43:40.329 --> 00:43:44.170
这样的对象图

00:43:42.430 --> 00:43:45.789
所以他们会操纵你告诉他们的

00:43:44.170 --> 00:43:49.410
操纵和其他一切

00:43:45.789 --> 00:43:49.410
只是当作假的类型

00:43:59.460 --> 00:44:04.650
所以我的问题是关于早期

00:44:01.910 --> 00:44:07.680
运行时失败，我想我们已经

00:44:04.650 --> 00:44:10.500
引入，因此运行时现在可以捕获

00:44:07.680 --> 00:44:11.760
包装上存在一些错误

00:44:10.500 --> 00:44:14.279
模块中的名称等等

00:44:11.760 --> 00:44:17.279
是的，所以如果我使用的图书馆

00:44:14.279 --> 00:44:18.809
通过制动方式改进其API 

00:44:17.279 --> 00:44:22.829
重命名将被调用的包

00:44:18.809 --> 00:44:24.750
如果库在

00:44:22.829 --> 00:44:28.619
库不断发展，并将其重命名为

00:44:24.750 --> 00:44:30.480
包装一般

00:44:28.619 --> 00:44:32.670
很好，但是如果该软件包现在有冲突

00:44:30.480 --> 00:44:34.920
与其他东西，那可能是一个

00:44:32.670 --> 00:44:39.059
运行时中的问题将检测到它

00:44:34.920 --> 00:44:40.859
我想我的真正问题是，如果

00:44:39.059 --> 00:44:43.319
包仍然像以前一样

00:44:40.859 --> 00:44:45.269
但是类被重命名了吗

00:44:43.319 --> 00:44:47.369
尽早发现或失败

00:44:45.269 --> 00:44:48.779
最后一刻，就像你说的，你可以

00:44:47.369 --> 00:44:50.579
重命名课程一点工作都没问题

00:44:48.779 --> 00:44:53.490
可能会在以后开设一个新班级

00:44:50.579 --> 00:44:54.779
如果您有代码，请继续

00:44:53.490 --> 00:44:56.069
你没有像你一样重新编译

00:44:54.779 --> 00:44:58.230
没有编辑指的重新编译

00:44:56.069 --> 00:45:02.640
但这只是平常的事情

00:44:58.230 --> 00:45:04.289
运行时进行的分析

00:45:02.640 --> 00:45:07.289
 yupo对不起，补充分析认为

00:45:04.289 --> 00:45:09.900
现在只限于模块图

00:45:07.289 --> 00:45:12.029
以及每个模块的包装结构

00:45:09.900 --> 00:45:13.319
它看起来不再更深

00:45:12.029 --> 00:45:15.359
比它不去看

00:45:13.319 --> 00:45:16.980
输入并说哦，这个很好

00:45:15.359 --> 00:45:18.960
班级现在所指的是

00:45:16.980 --> 00:45:21.980
在中检测到的不存在

00:45:18.960 --> 00:45:24.779
同样的方式，没有创始人的阶级定义

00:45:21.980 --> 00:45:26.190
当代码到达那里时

00:45:24.779 --> 00:45:29.089
预先检测到

00:45:26.190 --> 00:45:29.089
谢谢

00:45:37.400 --> 00:45:41.060
我的问题是关于版本的

00:45:40.070 --> 00:45:43.160
模块的含义

00:45:41.060 --> 00:45:45.020
不好意思的版本控制呢

00:45:43.160 --> 00:45:46.790
一个模块的不同版本如何

00:45:45.020 --> 00:45:48.680
颜色可数我没看到任何

00:45:46.790 --> 00:45:51.290
关于模块的任何提及

00:45:48.680 --> 00:45:54.230
版本是否有该概念或

00:45:51.290 --> 00:45:58.550
不是经常问的第一名

00:45:54.230 --> 00:46:01.130
问题那里没有版本

00:45:58.550 --> 00:46:03.550
这个模块系统也都有

00:46:01.130 --> 00:46:07.010
在某些方面引起争议

00:46:03.550 --> 00:46:08.660
设计决定没有版本

00:46:07.010 --> 00:46:12.020
在此模型系统中，它不会尝试

00:46:08.660 --> 00:46:14.120
解决多个版本

00:46:12.020 --> 00:46:18.380
问题是什么意思

00:46:14.120 --> 00:46:20.210
几种不同的含义，因为如果

00:46:18.380 --> 00:46:23.300
那样的话你可能会不喜欢

00:46:20.210 --> 00:46:24.800
结果，主要有两个原因

00:46:23.300 --> 00:46:25.820
为什么你可能不喜欢

00:46:24.800 --> 00:46:30.290
结果

00:46:25.820 --> 00:46:33.350
一是许多行为

00:46:30.290 --> 00:46:35.450
现有的api可以做什么

00:46:33.350 --> 00:46:38.690
与选民甚至间接

00:46:35.450 --> 00:46:40.790
以不兼容的方式进行更改，因此

00:46:38.690 --> 00:46:42.860
移至模块的过程更多

00:46:40.790 --> 00:46:46.580
困难也许是更大的原因

00:46:42.860 --> 00:46:48.830
可能不喜欢结果是

00:46:46.580 --> 00:46:50.960
流行的构建工具不知道

00:46:48.830 --> 00:46:52.880
解决多重问题意味着什么

00:46:50.960 --> 00:46:55.430
你看Maven Gradle的版本问题

00:46:52.880 --> 00:46:57.710
所有这些工具，他们都走了

00:46:55.430 --> 00:46:59.360
检测冲突并指出冲突的方法

00:46:57.710 --> 00:47:01.880
出来，这就是为什么要解决冲突

00:46:59.360 --> 00:47:03.620
可能会在屁股上如此痛苦

00:47:01.880 --> 00:47:05.960
发展，但这是你所拥有的

00:47:03.620 --> 00:47:08.240
之所以这样做，是因为最终您对

00:47:05.960 --> 00:47:10.220
今天版本的课程路径

00:47:08.240 --> 00:47:13.910
同一件事的两个版本是

00:47:10.220 --> 00:47:16.430
现在几乎总是灾难的根源

00:47:13.910 --> 00:47:17.960
从长远来看， 

00:47:16.430 --> 00:47:20.720
解决多版本问题

00:47:17.960 --> 00:47:22.850
拥有某种方式会很棒

00:47:20.720 --> 00:47:25.130
知道但模块的意思是版本1 

00:47:22.850 --> 00:47:27.440
模块B和模块C需要版本2 

00:47:25.130 --> 00:47:29.300
模块B，只要我们可以保证

00:47:27.440 --> 00:47:31.550
那两个版本的类型

00:47:29.300 --> 00:47:33.560
的B永远不会相交和相遇

00:47:31.550 --> 00:47:36.440
因为那你想知道造成了

00:47:33.560 --> 00:47:38.450
内爆然后我们可以支持

00:47:36.440 --> 00:47:40.880
我们有所有的管道

00:47:38.450 --> 00:47:44.090
现在你知道它是什么

00:47:40.880 --> 00:47:45.800
我们可以做的不是很大

00:47:44.090 --> 00:47:48.710
努力，但不是一件小事

00:47:45.800 --> 00:47:50.480
在将来的版本中

00:47:48.710 --> 00:47:53.109
现在它将导致

00:47:50.480 --> 00:47:56.420
不太令人满意的经历

00:47:53.109 --> 00:47:58.580
因为这些工具不支持

00:47:56.420 --> 00:48:00.530
这将需要一段时间

00:47:58.580 --> 00:48:03.320
花一些时间让他们这样做

00:48:00.530 --> 00:48:05.420
你知道这花了很长时间吗

00:48:03.320 --> 00:48:08.000
足以获得您知道的工具

00:48:05.420 --> 00:48:10.130
支持我们到目前为止所做的一切，您知道

00:48:08.000 --> 00:48:11.270
如果我们决定解决

00:48:10.130 --> 00:48:12.680
多版本问题

00:48:11.270 --> 00:48:14.750
我们可以做到，这将需要另一个

00:48:12.680 --> 00:48:16.970
你知道一年的时间我不确定

00:48:14.750 --> 00:48:18.950
渴望工具赶上，所以

00:48:16.970 --> 00:48:20.990
我认为我们有一个很好的基础

00:48:18.950 --> 00:48:23.330
最好现在就把它弄清楚

00:48:20.990 --> 00:48:25.400
人们开始模块化，我们将采取

00:48:23.330 --> 00:48:28.730
深入了解多种版本

00:48:25.400 --> 00:48:30.740
我将来发布的问题

00:48:28.730 --> 00:48:34.930
说昨天可能比你早

00:48:30.740 --> 00:48:37.490
想想，但是他们有一个像什么的模块

00:48:34.930 --> 00:48:39.530
通常像可用模块一样获得

00:48:37.490 --> 00:48:42.890
梅根记者或有什么变化

00:48:39.530 --> 00:48:44.960
版本和一个依赖项之间的API 

00:48:42.890 --> 00:48:46.400
模块正在使用一个版本

00:48:44.960 --> 00:48:47.810
使用其他版本的

00:48:46.400 --> 00:48:49.670
将被用作我所说的

00:48:47.810 --> 00:48:50.960
评论好吧好吧好吧好吧

00:48:49.670 --> 00:48:52.280
现在，你现在，你只是

00:48:50.960 --> 00:48:55.609
你只需要选一个的东西

00:48:52.280 --> 00:48:58.220
你知道你今天做什么

00:48:55.609 --> 00:48:59.390
解决Maven或Gradle中的冲突

00:48:58.220 --> 00:49:02.180
或象牙或您使用的任何工具

00:48:59.390 --> 00:49:05.420
你可以，你可以继续做

00:49:02.180 --> 00:49:06.770
没错，你知道暴民

00:49:05.420 --> 00:49:09.460
模块路径的语义是

00:49:06.770 --> 00:49:12.590
模块系统从它的最前面开始

00:49:09.460 --> 00:49:13.880
在每个目录中查找以下模块

00:49:12.590 --> 00:49:15.320
它要寻找的名称

00:49:13.880 --> 00:49:17.359
找到的第一个，然后

00:49:15.320 --> 00:49:20.030
从那个点到那个点

00:49:17.359 --> 00:49:22.730
那是模块的定义

00:49:20.030 --> 00:49:30.609
那里的名字再也不会出现

00:49:22.730 --> 00:49:30.609
好的，好的，两分钟，最后一个问题

00:49:36.690 --> 00:49:42.900
我在想我在春天工作还是

00:49:40.120 --> 00:49:45.220
 Java环境，然后我会

00:49:42.900 --> 00:49:48.070
通常打开我的申请

00:49:45.220 --> 00:49:50.230
完全是因为反思

00:49:48.070 --> 00:49:52.720
常见，如春季冬眠

00:49:50.230 --> 00:49:54.910
哦，是的

00:49:52.720 --> 00:49:56.890
这样就打开了整个应用程序

00:49:54.910 --> 00:49:59.740
完全确定您可以做到这一点

00:49:56.890 --> 00:50:01.720
开始，但一般来说，如果您使用

00:49:59.740 --> 00:50:04.030
你知道春天冬眠的任何

00:50:01.720 --> 00:50:06.070
这些反射性框架

00:50:04.030 --> 00:50:07.750
最好把你的想法

00:50:06.070 --> 00:50:09.610
模块化的眼睛很好，您的包装

00:50:07.750 --> 00:50:11.890
实际上是要发出光束

00:50:09.610 --> 00:50:14.140
被春季或冬眠所操纵，或

00:50:11.890 --> 00:50:15.250
随便打开我的意思

00:50:14.140 --> 00:50:17.860
如果你愿意，你可以做

00:50:15.250 --> 00:50:21.850
您的整个模块打开，并且和

00:50:17.860 --> 00:50:24.550
那会起作用，但作为一个普遍点

00:50:21.850 --> 00:50:25.930
卫生只打开包装

00:50:24.550 --> 00:50:28.360
需要打开是更好的

00:50:25.930 --> 00:50:31.150
练习，但作为图书馆开发人员

00:50:28.360 --> 00:50:35.530
不知道我的图书馆可能是

00:50:31.150 --> 00:50:39.280
在反光镜框虫中用作艺术品

00:50:35.530 --> 00:50:41.970
就是这样，这是一个好问题

00:50:39.280 --> 00:50:45.940
原来那里有一个

00:50:41.970 --> 00:50:47.620
小而微妙的功能

00:50:45.940 --> 00:50:49.450
实际上将启用反射器

00:50:47.620 --> 00:50:51.220
框架，即使你没有

00:50:49.450 --> 00:50:53.680
开放，我没有时间解释

00:50:51.220 --> 00:50:56.860
现在它的细节，所以我想你

00:50:53.680 --> 00:50:59.920
是的，我相信我们有

00:50:56.860 --> 00:51:02.440
案件涵盖好时间了，谢谢

00:50:59.920 --> 00:51:03.730
我非常会在周围闲逛

00:51:02.440 --> 00:51:06.250
剩下的时间有时在

00:51:03.730 --> 00:51:07.600
 Oracle展位有时会在会议中出现，因此如果

00:51:06.250 --> 00:51:10.360
您还有其他问题，请随时

00:51:07.600 --> 00:51:17.309
抓住好吧谢谢

00:51:10.360 --> 00:51:17.309
 [掌声] 

