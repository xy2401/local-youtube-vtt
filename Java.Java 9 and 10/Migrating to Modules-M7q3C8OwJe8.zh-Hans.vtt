WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.810 --> 00:00:10.030
下午好，欢迎来到我的二年级

00:00:07.630 --> 00:00:12.220
将续集模块分为两个模块

00:00:10.030 --> 00:00:13.840
一课，我想我撒谎不是

00:00:12.220 --> 00:00:15.670
一课好，那是

00:00:13.840 --> 00:00:17.109
入门课程，但确实如此

00:00:15.670 --> 00:00:19.900
有多少人看到了

00:00:17.109 --> 00:00:21.609
今天早上的会议，好的，那会

00:00:19.900 --> 00:00:23.980
有点帮助，但我会尽力做到这一点

00:00:21.609 --> 00:00:27.130
相对独立，所以这是

00:00:23.980 --> 00:00:29.439
我将进行另一个现场编码会议

00:00:27.130 --> 00:00:32.140
错误请大声喊出来，如果你

00:00:29.439 --> 00:00:35.440
认为您可以帮助解决以下问题

00:00:32.140 --> 00:00:37.989
欢迎在此期间进行澄清

00:00:35.440 --> 00:00:40.629
主要部分，但更深层次的问题让我们尝试

00:00:37.989 --> 00:00:43.570
并坚持到底

00:00:40.629 --> 00:00:46.059
我们在这里要做的是看一个

00:00:43.570 --> 00:00:49.059
小应用稍大

00:00:46.059 --> 00:00:55.690
应用程序，那么我们今天早上看

00:00:49.059 --> 00:00:57.190
我在这里有JDK 9 build 180181 GA 

00:00:55.690 --> 00:00:59.769
版本或采用此小应用程序

00:00:57.190 --> 00:01:03.460
我们要去做-我们要去做两个

00:00:59.769 --> 00:01:05.680
首先，我们要对其进行模块化

00:01:03.460 --> 00:01:08.860
从上到下现在这个应用程序

00:01:05.680 --> 00:01:11.470
使用一些流行但尚未监控的内容

00:01:08.860 --> 00:01:13.000
库，并说明如何

00:01:11.470 --> 00:01:15.670
模块化的眼睛甚至一个小应用程序

00:01:13.000 --> 00:01:17.020
它的依赖关系已经模块化

00:01:15.670 --> 00:01:18.909
由他们的维护者

00:01:17.020 --> 00:01:20.079
然后我们会做相反的事情

00:01:18.909 --> 00:01:22.899
回到有规律的

00:01:20.079 --> 00:01:25.600
类路径应用程序，我们将进行模块化

00:01:22.899 --> 00:01:26.649
看着它的依赖关系，我们会假装

00:01:25.600 --> 00:01:29.350
我们是这些的维护者

00:01:26.649 --> 00:01:30.460
我们将这些库模块化

00:01:29.350 --> 00:01:32.409
我们将展示如何与全班一起使用

00:01:30.460 --> 00:01:35.290
战斗应用，然后终于在

00:01:32.409 --> 00:01:41.229
最后，我们将以实际完全

00:01:35.290 --> 00:01:44.320
模块化的眼睛应用程序，所以第一件事

00:01:41.229 --> 00:01:46.329
优先，而不是先做

00:01:44.320 --> 00:01:48.490
我以为无聊的无聊的旧世界

00:01:46.329 --> 00:01:50.439
我会做点事

00:01:48.490 --> 00:01:57.700
这里有点丰富，所以我这里有一个文件

00:01:50.439 --> 00:02:00.219
 JSON格式的推文，您知道

00:01:57.700 --> 00:02:01.600
 21世纪的XML也许是

00:02:00.219 --> 00:02:03.780
比XML更具可读性，我不是

00:02:01.600 --> 00:02:03.780
当然

00:02:03.820 --> 00:02:10.380
所以我们写一个小应用程序来

00:02:06.390 --> 00:02:12.280
以更易读的格式显示这些

00:02:10.380 --> 00:02:15.850
现在我们不必写它了，因为

00:02:12.280 --> 00:02:18.040
我已经知道了，或者发了一些推文

00:02:15.850 --> 00:02:19.450
该应用的名称，其中包含一个主克莱德

00:02:18.040 --> 00:02:20.860
有两堂课与此不同

00:02:19.450 --> 00:02:27.610
早上的应用程序有两个我有两个

00:02:20.860 --> 00:02:32.380
课让我们看一看

00:02:27.610 --> 00:02:36.270
主类使用Jackson XML对不起

00:02:32.380 --> 00:02:38.500
 Jackson JSON数据绑定库

00:02:36.270 --> 00:02:40.990
你知道我创建的这很简单

00:02:38.500 --> 00:02:43.060
创建对象映射器的对象

00:02:40.990 --> 00:02:45.850
从系统输入读取的推文列表

00:02:43.060 --> 00:02:49.060
然后在上面显示这些推文

00:02:45.850 --> 00:02:55.300
标准输出，它使用此

00:02:49.060 --> 00:02:57.220
在附近的小微博上发推文

00:02:55.300 --> 00:03:00.940
表示一条推文，它使用单个

00:02:57.220 --> 00:03:04.840
时间戳代表使用

00:03:00.940 --> 00:03:06.340
我们必须去的更多杰克逊的东西

00:03:04.840 --> 00:03:11.560
注释属性a 

00:03:06.340 --> 00:03:13.920
时间戳属性和文本属性

00:03:11.560 --> 00:03:15.720
这只是文字

00:03:13.920 --> 00:03:18.810
好吧，那很简单，让我们

00:03:15.720 --> 00:03:20.160
编译并显示它

00:03:18.810 --> 00:03:23.060
在我们尝试改变之前有效

00:03:20.160 --> 00:03:26.550
我的Lib目录中的所有内容

00:03:23.060 --> 00:03:28.530
我的杰克逊3：3杰克逊jar文件

00:03:26.550 --> 00:03:30.240
需要这些是这些有点老

00:03:28.530 --> 00:03:35.190
版本，但出于这些目的

00:03:30.240 --> 00:03:36.900
没关系，让我们编译

00:03:35.190 --> 00:03:42.000
这些，所以我们该怎么做Java C-D 

00:03:36.900 --> 00:03:47.640
让我们看看他们是否还活着

00:03:42.000 --> 00:03:53.400
杰克逊，它开始于核心数据绑定

00:03:47.640 --> 00:04:02.480
现场杰克逊注释，我只是

00:03:53.400 --> 00:04:09.470
找到我能做的一切并将其编译

00:04:02.480 --> 00:04:09.470
现在很多，让我们制作一个jar文件

00:04:18.220 --> 00:04:26.210
这都是非常平凡的

00:04:24.889 --> 00:04:28.030
我见过的最响亮的有趣蜂鸣器

00:04:26.210 --> 00:04:30.530
听过

00:04:28.030 --> 00:04:36.110
好，只是为了证明一切

00:04:30.530 --> 00:04:43.700
工作，我们可以这么长时间运行

00:04:36.110 --> 00:04:47.680
糟糕的classpath将我的tweet添加到了一些家伙

00:04:43.700 --> 00:04:47.680
那我们得到什么

00:04:52.210 --> 00:04:59.380
在那儿，我们在更多的地方发推文

00:04:57.940 --> 00:05:02.440
可读格式好

00:04:59.380 --> 00:05:04.300
 woohoo是我们的那是我们的

00:05:02.440 --> 00:05:10.180
起点，所以让我们开始

00:05:04.300 --> 00:05:11.500
模块化推文，嗯，这是

00:05:10.180 --> 00:05:12.789
再次构造只是为了提醒您什么

00:05:11.500 --> 00:05:15.130
我们要做的就是放

00:05:12.789 --> 00:05:18.090
组织点中的模块声明

00:05:15.130 --> 00:05:18.090
推特um目录

00:05:24.390 --> 00:05:33.130
模块或推文um，现在在模块中

00:05:30.790 --> 00:05:35.950
我需要声明模块导出的内容

00:05:33.130 --> 00:05:37.360
以及它需要什么，所以这是一个

00:05:35.950 --> 00:05:39.100
小应用程序模块

00:05:37.360 --> 00:05:41.730
导出任何API，因此不会

00:05:39.100 --> 00:05:45.640
任何出口都可以

00:05:41.730 --> 00:05:50.350
但是此模块中的代码使用JAXA 

00:05:45.640 --> 00:05:52.150
那三个杰克逊图书馆，但是

00:05:50.350 --> 00:05:54.340
我该怎么办我该怎么办

00:05:52.150 --> 00:05:57.400
我想写的是杰克逊的核心

00:05:54.340 --> 00:06:01.930
或者您知道冷静一点XML 

00:05:57.400 --> 00:06:04.630
某些东西，但是我实际上没有

00:06:01.930 --> 00:06:07.120
我仅有的Jackson核心模块是一个

00:06:04.630 --> 00:06:09.640
杰克逊核心jar文件与

00:06:07.120 --> 00:06:13.330
其他的杰克逊图书馆

00:06:09.640 --> 00:06:15.730
坐在那里所以我的意思是

00:06:13.330 --> 00:06:17.620
在普通的旧RAR文件中，它们不是

00:06:15.730 --> 00:06:20.800
模块没有就没有

00:06:17.620 --> 00:06:23.200
现在我可以去那些模块信息了

00:06:20.800 --> 00:06:25.750
编辑这些jar文件并进行排序

00:06:23.200 --> 00:06:28.690
模块和法塔赫类中的模块信息

00:06:25.750 --> 00:06:30.250
文件放入其中，但这可能不是

00:06:28.690 --> 00:06:31.690
一个好主意，这通常是从来没有

00:06:30.250 --> 00:06:35.770
这个用jar文件的好主意

00:06:31.690 --> 00:06:39.340
由别人提供，所以答案

00:06:35.770 --> 00:06:42.340
这是拼图中的一个功能，称为

00:06:39.340 --> 00:06:45.640
自动模块，所以自动模块

00:06:42.340 --> 00:06:47.920
是拿一个比较理智的罐子的方法

00:06:45.640 --> 00:06:51.040
文件或设置相对健全的jar文件

00:06:47.920 --> 00:06:53.260
甚至将它们视为模块

00:06:51.040 --> 00:06:55.840
虽然他们没有模块婴儿

00:06:53.260 --> 00:06:59.170
其中的类文件用于

00:06:55.840 --> 00:07:01.120
自上而下的迁移需要几个

00:06:59.170 --> 00:07:02.500
在所有这些jar文件中， 

00:07:01.120 --> 00:07:03.910
例子，他们不能有冲突

00:07:02.500 --> 00:07:05.110
包，所以有冲突

00:07:03.910 --> 00:07:07.330
包，你必须把它们放在一个

00:07:05.110 --> 00:07:09.400
上班路，但杰克逊是个好

00:07:07.330 --> 00:07:11.440
工程系统，没有

00:07:09.400 --> 00:07:14.680
有冲突的软件包，所以这不是

00:07:11.440 --> 00:07:16.750
自动模块的名称问题

00:07:14.680 --> 00:07:20.050
模块的名称取自

00:07:16.750 --> 00:07:22.210
 jar文件可能不是

00:07:20.050 --> 00:07:24.220
实际名称

00:07:22.210 --> 00:07:25.990
该模块将由其

00:07:24.220 --> 00:07:29.230
维护者得到维护者时

00:07:25.990 --> 00:07:31.000
因此，这就是为什么自上而下

00:07:29.230 --> 00:07:32.590
迁移时，我们建议您

00:07:31.000 --> 00:07:33.139
您正在使用事物作为自动模块

00:07:32.590 --> 00:07:35.719
别

00:07:33.139 --> 00:07:37.819
发布您自己的模块，因为您将

00:07:35.719 --> 00:07:39.710
声明对某事的依赖

00:07:37.819 --> 00:07:41.210
在以下情况下可能具有不同的名称

00:07:39.710 --> 00:07:43.819
它的维护者实际上需要模块

00:07:41.210 --> 00:07:45.199
无论如何都会出现两个

00:07:43.819 --> 00:07:47.120
自上而下的迁移，这相当不错

00:07:45.199 --> 00:07:49.129
启发式，如果你只是在做模型

00:07:47.120 --> 00:07:51.620
直到您的依赖为止

00:07:49.129 --> 00:07:53.599
已经赶上了，所以在这一点上我可以

00:07:51.620 --> 00:07:59.830
写它需要杰克逊核心要求

00:07:53.599 --> 00:08:06.580
公布的杰克逊数据需要杰克逊

00:07:59.830 --> 00:08:06.580
注释集注释

00:08:06.969 --> 00:08:13.629
注释，应该正确

00:08:14.379 --> 00:08:22.909
那是一个非常响亮的电话蜂鸣器

00:08:18.319 --> 00:08:25.419
会在唱片上，所以有一个

00:08:22.909 --> 00:08:29.120
还有另一种方法来弄清楚

00:08:25.419 --> 00:08:31.099
您现有的代码可能会做什么

00:08:29.120 --> 00:08:32.690
需求，这就是Jade EPS工具

00:08:31.099 --> 00:08:34.490
我在主题演讲中提到的

00:08:32.690 --> 00:08:38.180
昨天，所以Jade EPS有点像瑞士人

00:08:34.490 --> 00:08:41.690
军刀的静态分析

00:08:38.180 --> 00:08:50.209
在JDK上运行的代码

00:08:41.690 --> 00:08:53.269
旁注非常重要的一个是

00:08:50.209 --> 00:08:54.470
您可以运行的JDK内部选项

00:08:53.269 --> 00:08:56.600
使用此选项，将查看

00:08:54.470 --> 00:08:57.920
现有的jar文件或七个jar文件，以及

00:08:56.600 --> 00:09:01.490
看看是否有使用JDK和

00:08:57.920 --> 00:09:03.620
日记，很高兴没有用

00:09:01.490 --> 00:09:05.750
 JDK内部api的介绍

00:09:03.620 --> 00:09:08.350
应用程序还可以，这样很好

00:09:05.750 --> 00:09:12.589
您也可以使用此-s选项

00:09:08.350 --> 00:09:14.029
我们将向您展示更多未找到的内容

00:09:12.589 --> 00:09:17.089
是因为我需要告诉它去哪里

00:09:14.029 --> 00:09:20.589
在这里找到其余的依赖项

00:09:17.089 --> 00:09:20.589
所以让我复制

00:09:24.769 --> 00:09:37.550
因此，J技巧我们将研究所有这些

00:09:27.170 --> 00:09:40.069
现在，我们看到Jade EPS在说

00:09:37.550 --> 00:09:42.949
有代码，而Ord鸣叫一些罐子

00:09:40.069 --> 00:09:45.980
那就是要炖用的东西

00:09:42.949 --> 00:09:47.660
这些杰克逊的jar文件， 

00:09:45.980 --> 00:09:49.429
可能就像您将它们视为

00:09:47.660 --> 00:09:51.949
自动妈妈也告诉我们

00:09:49.429 --> 00:09:54.559
注意到我们忘记了或发了什么

00:09:51.949 --> 00:09:58.129
一些罐子正在使用该时间戳记

00:09:54.559 --> 00:09:59.989
 Java续集模块中的类，因此我们

00:09:58.129 --> 00:10:02.600
忘记了，我们需要在这里添加

00:09:59.989 --> 00:10:06.249
需要Java不续集，否则

00:10:02.600 --> 00:10:12.259
将不会编译，当然也不会运行

00:10:06.249 --> 00:10:18.249
好吧，所以我们有我们的

00:10:12.259 --> 00:10:22.939
模块化应用程序让我们

00:10:18.249 --> 00:10:26.449
删除并编译它，我们将

00:10:22.939 --> 00:10:30.619
编译前两个mod目录

00:10:26.449 --> 00:10:32.660
类目录模块的模块化形式

00:10:30.619 --> 00:10:35.319
路径库我们告诉编译器模块

00:10:32.660 --> 00:10:35.319
源路径

00:10:36.120 --> 00:10:42.870
 Java C的源代码是Java C有很深的

00:10:40.560 --> 00:10:44.010
对一个结构的理解

00:10:42.870 --> 00:10:46.230
源代码树，因此您可以构建一个

00:10:44.010 --> 00:10:51.360
与每个模块一起使用的源代码树

00:10:46.230 --> 00:10:53.190
目录，然后告诉它进行编译

00:10:51.360 --> 00:10:54.390
推文和模块，它只会

00:10:53.190 --> 00:10:58.020
抓住你不需要的全部东西

00:10:54.390 --> 00:10:59.700
列出单个Java源文件

00:10:58.020 --> 00:11:05.490
你自己的模特，你必须

00:10:59.700 --> 00:11:07.260
键入正确的标记，我们现在进入

00:11:05.490 --> 00:11:10.830
我们的mods目录我们作为一个

00:11:07.260 --> 00:11:13.190
爆炸爆炸模块，我们可以工作

00:11:10.830 --> 00:11:13.190
豌豆

00:11:13.790 --> 00:11:21.060
有我们的编译模块信息

00:11:16.320 --> 00:11:27.630
完全符合我们的期望

00:11:21.060 --> 00:11:30.260
让我们在这里为此创建一个jar文件

00:11:27.630 --> 00:11:30.260
我们要接受

00:11:30.780 --> 00:11:37.290
从那里，我们要把它放在

00:11:34.440 --> 00:11:39.180
 lib目录，一路走来

00:11:37.290 --> 00:11:42.060
添加它，让我们在您添加主类时

00:11:39.180 --> 00:11:43.620
包装一个模块化的罐子，甚至没有

00:11:42.060 --> 00:11:45.420
模块化的罐子，你可以

00:11:43.620 --> 00:11:47.340
指定主类的切入点

00:11:45.420 --> 00:11:49.170
为此，我们只是要说

00:11:47.340 --> 00:11:58.650
主要类是

00:11:49.170 --> 00:12:05.940
 in是org主推文中的org tweets 

00:11:58.650 --> 00:12:08.100
应该在那里工作，我们去了

00:12:05.940 --> 00:12:12.060
边际模块化推文um jar文件和

00:12:08.100 --> 00:12:14.240
现在我们可以运行它，我们将运行它

00:12:12.060 --> 00:12:14.240
与

00:12:14.810 --> 00:12:20.060
模块路径是活动的，因此请记住

00:12:17.240 --> 00:12:21.710
生活，我们现在有我们的杰克逊

00:12:20.060 --> 00:12:23.390
注解jar文件保持不变

00:12:21.710 --> 00:12:25.790
他们刚刚从Maven下载

00:12:23.390 --> 00:12:29.270
中央和鸣叫一些罐子文件

00:12:25.790 --> 00:12:36.320
我们刚刚构建的将说Java模块路径

00:12:29.270 --> 00:12:42.260
 lib并要求它运行鸣叫一些

00:12:36.320 --> 00:12:45.670
申请，我们得到一个例外哦

00:12:42.260 --> 00:12:45.670
没事

00:12:48.300 --> 00:12:54.490
发生了什么事我们错过了什么

00:12:52.180 --> 00:12:59.410
当我们将眼睛模块化时，让我们

00:12:54.490 --> 00:13:01.420
看一下java.lang的异常反映

00:12:59.410 --> 00:13:03.310
无法访问的对象异常无法

00:13:01.420 --> 00:13:05.290
使组织推文可访问一些推文

00:13:03.310 --> 00:13:07.839
模块词鸣叫一些无法打开组织

00:13:05.290 --> 00:13:09.940
鸣叫一些模块杰克逊点数据

00:13:07.839 --> 00:13:11.740
因此基本上绑定这里发生了什么

00:13:09.940 --> 00:13:13.690
 Jackson数据绑定库

00:13:11.740 --> 00:13:16.450
大多数数据绑定库正在使用

00:13:13.690 --> 00:13:19.779
反思POJO类

00:13:16.450 --> 00:13:22.080
它正在努力支持，那就是

00:13:19.779 --> 00:13:25.029
不工作，那是行不通的，因为

00:13:22.080 --> 00:13:28.839
鸣叫的模块声明

00:13:25.029 --> 00:13:30.790
某些模块无法使用

00:13:28.839 --> 00:13:33.940
你知道这是一个内部包装

00:13:30.790 --> 00:13:36.430
但这种情况并不完全

00:13:33.940 --> 00:13:38.020
内部的，因为以及

00:13:36.430 --> 00:13:40.240
我知道我的推文和模块ID 

00:13:38.020 --> 00:13:43.300
使用Jackson数据绑定可以

00:13:40.240 --> 00:13:46.209
 Jackson数据绑定以访问胆量

00:13:43.300 --> 00:13:48.250
我的内部班级中，我实际上

00:13:46.209 --> 00:13:50.980
想要它现在做我能做的

00:13:48.250 --> 00:13:55.810
是像我一样的出口我可以尝试

00:13:50.980 --> 00:14:01.300
出口或推特区，我已经尝试过了

00:13:55.810 --> 00:14:03.190
尝试导出可能会

00:14:01.300 --> 00:14:08.470
工作，但我很抱歉实际上不会

00:14:03.190 --> 00:14:14.770
工作我误会了，让我们看看

00:14:08.470 --> 00:14:16.690
碰巧我要用一点点

00:14:14.770 --> 00:14:19.240
命令一个名为Jada @jj的点击

00:14:16.690 --> 00:14:22.170
节省一些时间，让我们重新编译

00:14:19.240 --> 00:14:22.170
并重新包装

00:14:31.480 --> 00:14:41.800
我们的模块并尝试再次运行它，所以我

00:14:41.330 --> 00:14:44.809
意思

00:14:41.800 --> 00:14:44.809
 [音乐] 

00:14:52.110 --> 00:14:55.110
抱歉

00:15:11.930 --> 00:15:15.080
谢谢

00:15:20.170 --> 00:15:23.830
实时编码总是有点

00:15:21.700 --> 00:15:26.530
高压线好吧，让我们尝试一下

00:15:23.830 --> 00:15:28.900
再一次，会发生什么一样

00:15:26.530 --> 00:15:31.180
事情发生了，原因相同

00:15:28.900 --> 00:15:34.410
发生的事情是，当您导出一个

00:15:31.180 --> 00:15:37.780
不能完全包装的包装

00:15:34.410 --> 00:15:40.030
其所有非公开成员都可用

00:15:37.780 --> 00:15:43.450
为了深层思考，这使他们

00:15:40.030 --> 00:15:46.570
可作为API使用，因此

00:15:43.450 --> 00:15:48.250
其他代码可以使用导出的API 

00:15:46.570 --> 00:15:49.530
该包中我们真正需要的

00:15:48.250 --> 00:15:51.820
要做的是那个错误信息

00:15:49.530 --> 00:15:53.620
最初建议这是什么

00:15:51.820 --> 00:15:55.900
除了出口以外，还有其他方式

00:15:53.620 --> 00:15:59.710
暴露一个包装，这叫做

00:15:55.900 --> 00:16:02.500
打开，因此打开是专门为

00:15:59.710 --> 00:16:04.390
这种用例你有一个包装

00:16:02.500 --> 00:16:06.220
它有一些课程，你没有

00:16:04.390 --> 00:16:08.440
打算将该软件包用作API 

00:16:06.220 --> 00:16:10.930
不需要其他代码和其他代码

00:16:08.440 --> 00:16:14.110
其他模块或其他要编译的模块

00:16:10.930 --> 00:16:16.030
反对它，但你确实想允许

00:16:14.110 --> 00:16:18.430
类似于数据绑定绑定

00:16:16.030 --> 00:16:20.020
库在其上使用深层反射

00:16:18.430 --> 00:16:22.480
基本上你可以想到它

00:16:20.020 --> 00:16:25.450
水平是它在出口

00:16:22.480 --> 00:16:29.760
仅在运行时和在

00:16:25.450 --> 00:16:33.850
运行时允许对非公共进行反思

00:16:29.760 --> 00:16:37.410
非偶数类型的成员

00:16:33.850 --> 00:16:37.410
公开类型是您的一个快速问题

00:16:38.220 --> 00:16:44.440
的确可以，如果我想成为一个

00:16:42.490 --> 00:16:48.670
有点偏执我可以说打开zorg 

00:16:44.440 --> 00:16:52.030
鸣叫m2杰克逊数据绑定这是

00:16:48.670 --> 00:16:53.590
称为合格和合格公开赛

00:16:52.030 --> 00:16:55.240
您也可以进行合格的出口

00:16:53.590 --> 00:16:57.070
想要将某物导出到一个

00:16:55.240 --> 00:16:59.320
其他模块或一组模块

00:16:57.070 --> 00:17:02.770
你知道更高的水平

00:16:59.320 --> 00:17:09.890
系统的完整性

00:17:02.770 --> 00:17:15.080
好吧，让我们再JJ那个家伙起来， 

00:17:09.890 --> 00:17:16.820
现在可以了，所以现在我们有了

00:17:15.080 --> 00:17:19.820
使用的模块化应用程序

00:17:16.820 --> 00:17:26.470
杰克逊图书馆作为自动模块

00:17:19.820 --> 00:17:26.470
第一步就完成了

00:17:27.709 --> 00:17:31.460
提示获得点击所需的费用

00:17:29.900 --> 00:17:34.670
让我们仔细看一下

00:17:31.460 --> 00:17:36.170
一点JRE，所以我们可以看到什么

00:17:34.670 --> 00:17:43.100
继续，我只是要运行j-link real 

00:17:36.170 --> 00:17:45.290
在这里快速，所以我在此列出模块

00:17:43.100 --> 00:17:49.030
在这个Jerry中，只有模块

00:17:45.290 --> 00:17:49.030
该应用程序需要的

00:17:53.940 --> 00:17:58.600
我们将可以运行它，不需要，不需要

00:17:56.860 --> 00:18:01.120
全部需要JDK中的所有那些模块

00:17:58.600 --> 00:18:02.890
其中有70多个

00:18:01.120 --> 00:18:04.660
 Java中的一些不错的选择

00:18:02.890 --> 00:18:08.710
现在用于诊断模块的启动器

00:18:04.660 --> 00:18:11.860
系统可以显示模块分辨率

00:18:08.710 --> 00:18:14.110
它将显示信息为

00:18:11.860 --> 00:18:16.270
解析器会找出原因

00:18:14.110 --> 00:18:18.130
您需要的模块，因此从

00:18:16.270 --> 00:18:20.320
在这种情况下，根模块

00:18:18.130 --> 00:18:22.090
解决过程是鸣叫一些

00:18:20.320 --> 00:18:24.880
它看到的模块鸣叫一些要求

00:18:22.090 --> 00:18:27.850
续集需要Jackson数据绑定它

00:18:24.880 --> 00:18:30.070
向您显示找到它的URL 

00:18:27.850 --> 00:18:32.890
那些在续集模块的情况下

00:18:30.070 --> 00:18:35.530
在或的jrt网址中

00:18:32.890 --> 00:18:37.330
内部的Nya虚拟文件系统位于

00:18:35.530 --> 00:18:40.990
您可以找到所有课程

00:18:37.330 --> 00:18:43.450
在JDK中查找注释

00:18:40.990 --> 00:18:45.460
这里的核心是续集

00:18:43.450 --> 00:18:48.790
哦，是的，这意味着记录和续集

00:18:45.460 --> 00:18:52.600
需要xml绑定一些服务，并且

00:18:48.790 --> 00:18:56.080
然后就是这样

00:18:52.600 --> 00:19:00.970
那里是一个真正允许的电话

00:18:56.080 --> 00:19:02.890
这些是我，我很抱歉，对不起

00:19:00.970 --> 00:19:06.580
一扇门还好

00:19:02.890 --> 00:19:08.500
所以自动模块是很好的

00:19:06.580 --> 00:19:11.410
我说过用于模块化应用程序

00:19:08.500 --> 00:19:13.000
自上而下，但它们不是

00:19:11.410 --> 00:19:14.590
建议用于已发布

00:19:13.000 --> 00:19:20.470
图书馆现在在那里

00:19:14.590 --> 00:19:22.960
蒙塔的中间步骤

00:19:20.470 --> 00:19:24.310
可以溶解现有的图书馆可以

00:19:22.960 --> 00:19:27.400
有时他们需要做很多工作

00:19:24.310 --> 00:19:30.940
为了使维护者x' 

00:19:27.400 --> 00:19:32.860
现有库来设置

00:19:30.940 --> 00:19:34.960
押在你知道宣告的土地上

00:19:32.860 --> 00:19:36.970
这部分边界作为模块

00:19:34.960 --> 00:19:38.910
他们打算在使用时使用的名字

00:19:36.970 --> 00:19:42.040
进行适当的模块化

00:19:38.910 --> 00:19:45.280
我们提供了一个临时步骤

00:19:42.040 --> 00:19:48.520
可以在jar文件中使用新条目

00:19:45.280 --> 00:19:51.070
清单被称为自动模块名称，如果

00:19:48.520 --> 00:19:53.590
那个条目在那里，你的jar文件是

00:19:51.070 --> 00:19:55.210
不是实际的模块，而是模块

00:19:53.590 --> 00:19:58.240
系统将读取清单属性

00:19:55.210 --> 00:20:00.250
并将其用作

00:19:58.240 --> 00:20:02.200
将创建的自动模块

00:20:00.250 --> 00:20:04.000
为您的jar文件，所以今天是一种

00:20:02.200 --> 00:20:05.810
中等重量航点的

00:20:04.000 --> 00:20:08.590
一直到模块化

00:20:05.810 --> 00:20:11.000
我很高兴看到一些

00:20:08.590 --> 00:20:12.710
热门图书馆，其维护者

00:20:11.000 --> 00:20:14.210
已经声明为自动模块

00:20:12.710 --> 00:20:16.100
在工作之前先命名

00:20:14.210 --> 00:20:17.810
真正弄清楚应该在里面

00:20:16.100 --> 00:20:20.540
他们的模块声明和发布

00:20:17.810 --> 00:20:22.810
它们作为实际模块，所以

00:20:20.540 --> 00:20:22.810
大

00:20:23.050 --> 00:20:34.490
好吧，让我们在这里倒带，我会很干净

00:20:28.100 --> 00:20:38.350
一切都让我留给

00:20:34.490 --> 00:20:42.290
时刻，并通过奇观

00:20:38.350 --> 00:20:44.180
 Mercurial我现在要输入

00:20:42.290 --> 00:20:45.800
我假装的替代宇宙

00:20:44.180 --> 00:20:49.820
成为...的维护者z'之一

00:20:45.800 --> 00:20:57.250
杰克逊图书馆，让我们重新编译

00:20:49.820 --> 00:20:57.250
将某些应用程序发布为普通旧版本

00:20:57.790 --> 00:21:00.790
哎呀

00:21:01.040 --> 00:21:04.850
类路径应用

00:21:13.440 --> 00:21:18.870
应该可以解决的

00:21:19.149 --> 00:21:23.799
我们去了我的非模块化jar文件，所以

00:21:21.639 --> 00:21:30.839
这就是我们要运作的方式

00:21:23.799 --> 00:21:30.839
如果没有，我们去吧

00:21:36.410 --> 00:21:40.430
现在只要是真正的音乐就可以了

00:21:38.840 --> 00:21:41.750
事情以后再容易一点，所以

00:21:40.430 --> 00:21:44.000
我们以为我们是

00:21:41.750 --> 00:21:49.160
杰克逊图书馆，我们有这些

00:21:44.000 --> 00:21:51.140
这里是杰克逊本人的源代码树

00:21:49.160 --> 00:21:52.610
知道冷静下来牧师MXML杰克逊核心

00:21:51.140 --> 00:21:54.470
等等等等所有这些

00:21:52.610 --> 00:21:59.270
精彩的分类器Java源文件

00:21:54.470 --> 00:22:04.190
然后它已获得许可，依此类推

00:21:59.270 --> 00:22:05.210
你知道的可能是一个很大的项目

00:22:04.190 --> 00:22:08.210
这里有很多东西

00:22:05.210 --> 00:22:09.620
我们如何去做，所以目录

00:22:08.210 --> 00:22:12.860
结构实际上告诉我们一个公平

00:22:09.620 --> 00:22:16.280
你可以猜测的数量

00:22:12.860 --> 00:22:18.110
知道注释可能是您知道的

00:22:16.280 --> 00:22:19.670
这些中的每一项都执行这些中的一项

00:22:18.110 --> 00:22:21.170
 jar文件是吗，您知道吗

00:22:19.670 --> 00:22:23.660
看起来像模型有点模块

00:22:21.170 --> 00:22:25.070
已经，但是我们如何找出

00:22:23.660 --> 00:22:27.050
你知道他们出口什么

00:22:25.070 --> 00:22:30.530
要求他们什么他们什么他们

00:22:27.050 --> 00:22:31.600
需要再一次让我们有德普（J Depp） 

00:22:30.530 --> 00:22:37.340
营救

00:22:31.600 --> 00:22:39.100
所以我们在那些杰克逊罐子上运行J Depp 

00:22:37.340 --> 00:22:42.020
我们仍然在Lib目录中的文件

00:22:39.100 --> 00:22:44.270
和翡翠ups这样做相同的静态

00:22:42.020 --> 00:22:46.520
我之前显示并显示的分析

00:22:44.270 --> 00:22:47.750
关系到底是什么

00:22:46.520 --> 00:22:49.460
这些jar文件需要您知道

00:22:47.750 --> 00:22:52.600
基本模块以及每个人都需要

00:22:49.460 --> 00:22:57.440
基本模块数据绑定使用XML续集

00:22:52.600 --> 00:22:59.740
并使用另外两个杰克逊罐

00:22:57.440 --> 00:22:59.740
档案

00:23:00.980 --> 00:23:06.910
所以杰伊德普（Jay Depp's）还有另一种选择

00:23:04.270 --> 00:23:12.260
记得我说过瑞士军刀

00:23:06.910 --> 00:23:17.720
 jaidev可以生成模块信息草稿

00:23:12.260 --> 00:23:23.000
模块信息Java文件供您使用，我将

00:23:17.720 --> 00:23:25.220
确实将模块信息生成到目录中

00:23:23.000 --> 00:23:27.050
称邪恶为我的源目录

00:23:25.220 --> 00:23:28.430
这有点吓人我正在使用

00:23:27.050 --> 00:23:30.920
工具，它将写入我的源代码

00:23:28.430 --> 00:23:32.380
树好吧那没关系

00:23:30.920 --> 00:23:38.420
好的

00:23:32.380 --> 00:23:40.190
首先让我们做库伯·杰克逊的核心，好吧

00:23:38.420 --> 00:23:48.410
我们有一个模块信息，它总是一个很好的

00:23:40.190 --> 00:23:50.660
看看它在这里做了什么的主意， 

00:23:48.410 --> 00:23:54.380
我们有杰克逊核心出口一堆

00:23:50.660 --> 00:23:57.740
好的包装，哦，这是什么

00:23:54.380 --> 00:23:59.720
这说提供了什么

00:23:57.740 --> 00:24:02.990
大约是原来的模块系统

00:23:59.720 --> 00:24:05.240
了解服务，因此服务是

00:24:02.990 --> 00:24:07.010
模型系统中的基本工具

00:24:05.240 --> 00:24:09.200
它们对于破坏特别有用

00:24:07.010 --> 00:24:11.300
您可能会想到的循环依赖性

00:24:09.200 --> 00:24:13.160
修改为每个模块都需要

00:24:11.300 --> 00:24:14.720
依靠对方或通过

00:24:13.160 --> 00:24:17.540
一些更复杂的循环

00:24:14.720 --> 00:24:20.570
关系答案比

00:24:17.540 --> 00:24:22.610
不会将其中之一重构为

00:24:20.570 --> 00:24:25.100
另一个查找的服务

00:24:22.610 --> 00:24:26.750
这将帮助您打破这一周期，我们

00:24:25.100 --> 00:24:29.780
使用我们的二手服务

00:24:26.750 --> 00:24:33.580
整个JDK本身打破了许多

00:24:29.780 --> 00:24:33.580
在这里骑行

00:24:33.909 --> 00:24:49.399
好吧，所以我实际上可以生成模块

00:24:46.220 --> 00:24:51.919
所有这些的即时信息

00:24:49.399 --> 00:24:54.289
这三个让Corwin看起来很漂亮

00:24:51.919 --> 00:24:56.720
好，我可能应该改变

00:24:54.289 --> 00:24:58.909
您知道的模块名称平静的Doster XML 

00:24:56.720 --> 00:25:01.639
点点什么，但我就离开

00:24:58.909 --> 00:25:05.840
为了简单起见，现在来看

00:25:01.639 --> 00:25:07.669
在注释模块信息检查中

00:25:05.840 --> 00:25:10.519
没关系，它只是要出口

00:25:07.669 --> 00:25:15.740
一包看起来不错的数据

00:25:10.519 --> 00:25:18.169
绑定模块信息，所以有几件事

00:25:15.740 --> 00:25:20.389
这是我们看到的

00:25:18.169 --> 00:25:24.760
在这里特别是要求

00:25:20.389 --> 00:25:28.820
放在这些需要传递

00:25:24.760 --> 00:25:30.710
声明，因此当一个模块需要时

00:25:28.820 --> 00:25:33.860
另一个只是意味着

00:25:30.710 --> 00:25:36.919
第一个模块，我们将能够访问

00:25:33.860 --> 00:25:40.250
出口或打开包装

00:25:36.919 --> 00:25:42.649
其他模块，如果是的，你知道第三点

00:25:40.250 --> 00:25:44.990
模块需要第一个不是

00:25:42.649 --> 00:25:47.720
要第二次见到对不起，如果

00:25:44.990 --> 00:25:52.370
如果，如果

00:25:47.720 --> 00:25:54.470
如果模块，如果模块a需要B和B＆B 

00:25:52.370 --> 00:25:57.769
导出并打包然后打包一个罐

00:25:54.470 --> 00:26:01.340
如果有的话，使用B中导出的软件包

00:25:57.769 --> 00:26:03.710
第三个模块X需要一个它将看到的

00:26:01.340 --> 00:26:05.059
的导出包，但不会

00:26:03.710 --> 00:26:07.630
一定看不到导出

00:26:05.059 --> 00:26:11.240
 B的包装，除非X也需要B 

00:26:07.630 --> 00:26:14.330
但是如果a在自己的api中使用X，则

00:26:11.240 --> 00:26:16.370
方便用户使用的模块

00:26:14.330 --> 00:26:17.720
 X它应该这样做需要传递

00:26:16.370 --> 00:26:20.269
它提供了便利

00:26:17.720 --> 00:26:23.000
基本上是指任何需要

00:26:20.269 --> 00:26:25.429
 Jackson数据绑定也会隐式地

00:26:23.000 --> 00:26:29.240
需要Jackson注释和Jackson 

00:26:25.429 --> 00:26:32.090
核心和Java续集以及Java xml和j 

00:26:29.240 --> 00:26:33.740
深度数据具有启发性

00:26:32.090 --> 00:26:37.010
通过分析类型

00:26:33.740 --> 00:26:39.019
公共公共课的签名和

00:26:37.010 --> 00:26:40.950
接口好，所以这些是

00:26:39.019 --> 00:26:43.170
要求已经产生

00:26:40.950 --> 00:26:46.980
它也产生了一堆出口

00:26:43.170 --> 00:26:49.650
基于X存在的包

00:26:46.980 --> 00:26:51.210
现在，Jade EPS无法确定

00:26:49.650 --> 00:26:52.770
什么可能是内部的，为什么不在那里

00:26:51.210 --> 00:26:54.060
人们使用过的各种约定

00:26:52.770 --> 00:26:56.250
多年来标记事物

00:26:54.060 --> 00:26:59.580
内部的，但在这种情况下，我们可以

00:26:56.250 --> 00:27:01.950
容易看到有一些简单的软件包

00:26:59.580 --> 00:27:04.790
所以我们只是要评论那些或

00:27:01.950 --> 00:27:07.020
嘿，让我们删除它们，因为

00:27:04.790 --> 00:27:09.420
很有可能不是

00:27:07.020 --> 00:27:11.520
打算成为Jackson API的一部分，因此

00:27:09.420 --> 00:27:13.260
我们不需要它们，还有另一个

00:27:11.520 --> 00:27:15.450
这里的服务比J提示想的要

00:27:13.260 --> 00:27:19.350
通过查看服务

00:27:15.450 --> 00:27:26.010
 Meta F中的目录，好了，我们已经完成了

00:27:19.350 --> 00:27:30.890
所有这些让我们编译，我们将继续

00:27:26.010 --> 00:27:30.890
制作一个新目录mm Lib 

00:27:32.550 --> 00:27:38.250
我们将把模块模块化

00:27:34.590 --> 00:27:40.120
的源模块模块化版本

00:27:38.250 --> 00:27:45.150
杰克逊·杰克逊图书馆

00:27:40.120 --> 00:27:51.000
 [音乐] 

00:27:45.150 --> 00:27:54.000
 Jackson Guttacore使用或覆盖

00:27:51.000 --> 00:27:59.250
绑架者弃用的API否，这是

00:27:54.000 --> 00:28:07.260
问题改天了注解

00:27:59.250 --> 00:28:08.490
和数据绑定更大的模块需要一个

00:28:07.260 --> 00:28:11.130
多一点编译更多

00:28:08.490 --> 00:28:16.020
 API已弃用，现在在M Lib中

00:28:11.130 --> 00:28:22.050
我们有这些模块化的jar文件，我们可以

00:28:16.020 --> 00:28:25.230
以数据藤为例

00:28:22.050 --> 00:28:28.500
 jar工具来描述它，还有

00:28:25.230 --> 00:28:30.540
模块声明中的内容

00:28:28.500 --> 00:28:32.160
二进制形式导出我们的东西

00:28:30.540 --> 00:28:39.200
期望需要我们期望的东西

00:28:32.160 --> 00:28:43.429
我们很好走，所以我们有

00:28:39.200 --> 00:28:43.429
模块化的杰克逊，我们有

00:28:43.790 --> 00:28:49.860
未建模

00:28:46.070 --> 00:28:52.950
鸣叫一些应用程序，让我们现在尝试

00:28:49.860 --> 00:28:55.620
并一起运行它们，以便Java模块

00:28:52.950 --> 00:29:00.440
我们将杰克逊放到的路径M Lib 

00:28:55.620 --> 00:29:00.440
模块类路径

00:29:03.970 --> 00:29:07.750
好吧，让我用

00:29:10.360 --> 00:29:16.530
鸣叫一些抽屉文件鸣叫明星杰森

00:29:25.200 --> 00:29:32.810
哦，是的，我们走了

00:29:33.590 --> 00:29:38.910
好吧，出了什么问题

00:29:35.970 --> 00:29:40.740
好吧，哪里出了问题我是

00:29:38.910 --> 00:29:43.290
运行类路径时运行

00:29:40.740 --> 00:29:46.470
应用程序是什么

00:29:43.290 --> 00:29:51.090
推特um是模型系统不

00:29:46.470 --> 00:29:53.670
知道需要什么非JDK模块，如果

00:29:51.090 --> 00:29:58.200
它需要JDK之外的模型

00:29:53.670 --> 00:30:05.720
需要手动添加它们，以便我们

00:29:58.200 --> 00:30:09.050
我们要做的就是添加杰克逊点芯杰克逊

00:30:05.720 --> 00:30:09.050
数据思维

00:30:11.440 --> 00:30:18.430
和杰克逊的注解

00:30:15.780 --> 00:30:19.960
所以有点尴尬，但至少

00:30:18.430 --> 00:30:22.090
你知道你有可能

00:30:19.960 --> 00:30:24.190
在类路径上的代码，你可以有一些

00:30:22.090 --> 00:30:26.560
模块路径上模块中的其他代码

00:30:24.190 --> 00:30:27.670
他们和平共处， 

00:30:26.560 --> 00:30:31.980
您必须告诉模块系统

00:30:27.670 --> 00:30:31.980
它的启动将哪些模块放入其中

00:30:37.220 --> 00:30:46.280
所以模块路径就是你

00:30:40.530 --> 00:30:49.350
放置定义广告模块的工件

00:30:46.280 --> 00:30:50.880
我们所说的抱歉，模块路径是

00:30:49.350 --> 00:30:52.800
放置模块化驱动器文件的位置

00:30:50.880 --> 00:30:55.140
那么我们有更多的模块jar文件

00:30:52.800 --> 00:30:58.920
您想使用而不是

00:30:55.140 --> 00:31:01.590
在模块的类路径上剪辑n 

00:30:58.920 --> 00:31:04.530
系统将在模块路径上查找

00:31:01.590 --> 00:31:06.630
它可以告诉它需要的模块

00:31:04.530 --> 00:31:08.880
查找，但是当您只运行代码时

00:31:06.630 --> 00:31:11.430
在课堂上，它没有办法

00:31:08.880 --> 00:31:14.430
检测哦，这个未修改的大米代码

00:31:11.430 --> 00:31:17.250
类路径需要一些模块

00:31:14.430 --> 00:31:19.980
模块路径，因此添加模块告诉

00:31:17.250 --> 00:31:21.930
可以在开始之前启动解析器

00:31:19.980 --> 00:31:23.910
该代码在类路径上加载这些

00:31:21.930 --> 00:31:26.130
其他附加模块-加

00:31:23.910 --> 00:31:29.550
他们所依赖的任何模块

00:31:26.130 --> 00:31:31.230
为什么你们都需要使用模块

00:31:29.550 --> 00:31:32.910
指出他们在哪里的路径选项，以及

00:31:31.230 --> 00:31:35.520
然后添加模块选项说出

00:31:32.910 --> 00:31:38.820
您知道的代码是必需的

00:31:35.520 --> 00:31:40.380
在课程路径上-如果您是

00:31:38.820 --> 00:31:42.900
你很着急或者你只是想成为

00:31:40.380 --> 00:31:46.140
懒惰那里有一些

00:31:42.900 --> 00:31:51.300
例如这里的快捷方式，你可以说

00:31:46.140 --> 00:31:52.500
全部-模块路径，它只会走

00:31:51.300 --> 00:31:54.090
找到模块上的所有内容

00:31:52.500 --> 00:31:57.540
可能不是您想要的路径

00:31:54.090 --> 00:32:00.360
但如果您愿意的话，这可能是一个有用的步骤

00:31:57.540 --> 00:32:02.700
只是调试好，这样

00:32:00.360 --> 00:32:04.500
这是自下而上的迁移

00:32:02.700 --> 00:32:07.380
现在让我们做的是显而易见的最后

00:32:04.500 --> 00:32:17.160
一步，将一切模块化

00:32:07.380 --> 00:32:19.170
返回推文中的一些模块信息

00:32:17.160 --> 00:32:24.990
我高高兴兴地离开这里会

00:32:19.170 --> 00:32:30.420
写回并重新编译tweet 

00:32:24.990 --> 00:32:33.650
这次有些

00:32:30.420 --> 00:32:33.650
模块化jar文件

00:32:36.030 --> 00:32:42.550
好的，现在编译时我需要

00:32:38.260 --> 00:32:45.670
告诉编译器模块路径M 

00:32:42.550 --> 00:32:48.670
在我实际的模块所在的位置解放

00:32:45.670 --> 00:32:53.260
实际上将把推文开始

00:32:48.670 --> 00:32:56.500
也要结束，所以我们在这里

00:32:53.260 --> 00:32:58.980
在M Lib中，我所有不错的模块和我

00:32:56.500 --> 00:32:58.980
能跑

00:33:11.890 --> 00:33:21.930
啊，现在要去哪里，我就把那个

00:33:19.690 --> 00:33:21.930
再次

00:33:26.100 --> 00:33:30.930
全模块化迎接某些应用

00:33:29.130 --> 00:33:33.030
现在一切都是一个模块，我们相信我们

00:33:30.930 --> 00:33:35.670
创建了一个让他们把顶部放下来

00:33:33.030 --> 00:33:40.200
自底向上一切都是模块的生命

00:33:35.670 --> 00:33:44.640
很甜，在这里我们可以显示一个模块

00:33:40.200 --> 00:33:47.010
分辨率，看到一切

00:33:44.640 --> 00:33:48.570
通过路线解析路线是

00:33:47.010 --> 00:33:51.030
我们看到的推文和模块

00:33:48.570 --> 00:33:52.620
自上而下的迁移将加载所有这些

00:33:51.030 --> 00:33:55.310
其他适当的模块，现在他们不是

00:33:52.620 --> 00:33:58.020
他们不再是自动模块了

00:33:55.310 --> 00:34:02.250
然后通过打印完成

00:33:58.020 --> 00:34:05.190
输出，就是这样，您就知道

00:34:02.250 --> 00:34:07.950
就证明这一点而言

00:34:05.190 --> 00:34:11.520
迁移到模块确实需要一些工作

00:34:07.950 --> 00:34:13.110
如果您现有大型系统， 

00:34:11.520 --> 00:34:16.050
坦率地说，这可能不值得

00:34:13.110 --> 00:34:18.840
所以开始之前请三思

00:34:16.050 --> 00:34:20.910
一个项目并模块化很多

00:34:18.840 --> 00:34:22.169
现有的代码（如果您使用大型系统） 

00:34:20.910 --> 00:34:24.270
就像你知道一大堆

00:34:22.169 --> 00:34:26.340
 Maven项目，效果很好，并且

00:34:24.270 --> 00:34:27.770
您的，并且在维护中

00:34:26.340 --> 00:34:29.700
模式

00:34:27.770 --> 00:34:31.740
有一个不值得的好机会

00:34:29.700 --> 00:34:33.419
麻烦将其模块化

00:34:31.740 --> 00:34:35.400
另一方面，如果它是积极的

00:34:33.419 --> 00:34:38.370
保持和发展，您计划

00:34:35.400 --> 00:34:42.600
推进它，那可能值得

00:34:38.370 --> 00:34:44.880
努力，但好消息是拼图

00:34:42.600 --> 00:34:48.030
提供了自上而下和

00:34:44.880 --> 00:34:51.300
自下而上地迁移时

00:34:48.030 --> 00:34:53.100
迁移的概念是

00:34:51.300 --> 00:34:54.720
不是Java的关键核心价值之一，而是

00:34:53.100 --> 00:34:56.250
肯定在某个地方排名靠前

00:34:54.720 --> 00:34:58.140
我们已经认真对待了

00:34:56.250 --> 00:35:00.330
年，你知道它影响了

00:34:58.140 --> 00:35:03.960
泛型和Java设计示例

00:35:00.330 --> 00:35:06.300
 5我们竭尽全力确保

00:35:03.960 --> 00:35:08.370
适应通用类型的代码可以

00:35:06.300 --> 00:35:10.950
与尚未使用的代码配合使用

00:35:08.370 --> 00:35:12.750
现在已适应通用类型

00:35:10.950 --> 00:35:14.310
是的，大多数代码确实使用泛型类型

00:35:12.750 --> 00:35:17.220
但是仍然有一些不

00:35:14.310 --> 00:35:19.890
他们都一起工作很好，所以我们

00:35:17.220 --> 00:35:21.810
在拼图中采取了类似的方法

00:35:19.890 --> 00:35:23.940
模块中的代码和

00:35:21.810 --> 00:35:27.740
不在模块中可以共存并与之相关

00:35:23.940 --> 00:35:30.450
互相合作

00:35:27.740 --> 00:35:35.070
因此，这就是

00:35:30.450 --> 00:35:37.380
迁移兼容性好吧，我们有一个

00:35:35.070 --> 00:35:40.920
如果有问题还剩几分钟

00:35:37.380 --> 00:35:42.420
是的，是吗，请等待

00:35:40.920 --> 00:35:45.150
我们是的麦克风

00:35:42.420 --> 00:35:47.670
如果不等待则记录

00:35:45.150 --> 00:35:48.390
麦克风，那么它就不会在

00:35:47.670 --> 00:35:51.000
记录嘿

00:35:48.390 --> 00:35:54.090
一开始你有杰克逊

00:35:51.000 --> 00:35:56.760
下颚，然后打开模块

00:35:54.090 --> 00:35:59.220
并要求杰克逊先看

00:35:56.760 --> 00:36:03.660
这个名字是从哪里来的

00:35:59.220 --> 00:36:05.280
水魔术的乐趣是

00:36:03.660 --> 00:36:09.570
自动命名为Ord是

00:36:05.280 --> 00:36:11.550
包裹名称，所以当你拿的时候

00:36:09.570 --> 00:36:14.610
你拿一个不是的jar文件

00:36:11.550 --> 00:36:19.830
模块化和，并将其放在模块上

00:36:14.610 --> 00:36:23.550
路径，然后合成其模块名称

00:36:19.830 --> 00:36:26.760
从文件名以某种方式

00:36:23.550 --> 00:36:29.250
 hack，但我们还能做什么呢？ 

00:36:26.760 --> 00:36:30.990
杰克的名字

00:36:29.250 --> 00:36:35.580
模块定义的自动模型

00:36:30.990 --> 00:36:39.810
 Jackson Jackson-绳-2点6.6罐

00:36:35.580 --> 00:36:42.080
是杰克逊的核心，仅此而已

00:36:39.810 --> 00:36:45.300
仅此而已

00:36:42.080 --> 00:36:48.060
如果那个的维护者

00:36:45.300 --> 00:36:51.120
库放入一个自动模块名称

00:36:48.060 --> 00:36:52.380
 jar文件清单中的条目，然后

00:36:51.120 --> 00:36:56.040
自动模块的名称为

00:36:52.380 --> 00:36:58.440
从清单条目中取出，但您

00:36:56.040 --> 00:37:01.020
从长远来看，我们希望

00:36:58.440 --> 00:37:02.670
任何像杰克逊这样的图书馆都会

00:37:01.020 --> 00:37:03.930
实际上是我听到的完整模块

00:37:02.670 --> 00:37:05.460
最近杰克逊的维护者

00:37:03.930 --> 00:37:07.290
实际上确实放入了自动模块

00:37:05.460 --> 00:37:08.970
名字，所以他们采取了那种东西

00:37:07.290 --> 00:37:11.470
迈向第一步的第一步

00:37:08.970 --> 00:37:14.440
模块化的东西

00:37:11.470 --> 00:37:18.190
我不会说至少免费

00:37:14.440 --> 00:37:21.910
我最常支持

00:37:18.190 --> 00:37:27.010
您显示的命令和工具

00:37:21.910 --> 00:37:29.530
在这里，所以所以我有了你Jean Petrenko 

00:37:27.010 --> 00:37:32.500
来自IntelliJ的主题演讲

00:37:29.530 --> 00:37:36.790
昨天演示了IntelliJ IDEA 

00:37:32.500 --> 00:37:38.500
可以显示模块图，它具有很深的

00:37:36.790 --> 00:37:39.970
了解模块声明的方式

00:37:38.500 --> 00:37:42.010
如果它们之间如何相互联系

00:37:39.970 --> 00:37:45.490
你忘了说某处需要

00:37:42.010 --> 00:37:47.020
如果和

00:37:45.490 --> 00:37:52.900
等等，这样很漂亮

00:37:47.020 --> 00:37:55.119
光滑的日食有一些支持，但我

00:37:52.900 --> 00:37:56.680
不知道现在有多深

00:37:55.119 --> 00:37:58.089
知道他们正在积极努力

00:37:56.680 --> 00:38:01.359
我和我都相信这是真的， 

00:37:58.089 --> 00:38:04.030
这意味着在本C这意味着我

00:38:01.359 --> 00:38:05.829
相信我认识的那个人

00:38:04.030 --> 00:38:07.569
 NetBeans贡献者正在努力

00:38:05.829 --> 00:38:10.569
他们，但我不知道他们的状态

00:38:07.569 --> 00:38:13.690
还没有发布9 a 9版本

00:38:10.569 --> 00:38:17.410
尚未发布任何内容

00:38:13.690 --> 00:38:18.700
派对现在是的，有一个NetBeans 

00:38:17.410 --> 00:38:20.260
目前有九个预览

00:38:18.700 --> 00:38:22.480
是的，如果有九个预览

00:38:20.260 --> 00:38:24.160
但那不是那不是最终的我

00:38:22.480 --> 00:38:27.700
认为剪辑版本支持

00:38:24.160 --> 00:38:29.050
模块两个星期的时间还是不错的

00:38:27.700 --> 00:38:30.819
有日食的地方

00:38:29.050 --> 00:38:32.109
已知的

00:38:30.819 --> 00:38:35.380
 eclipse网站，告诉您如何

00:38:32.109 --> 00:38:37.000
你好，如何与九人和他们一起使用

00:38:35.380 --> 00:38:37.980
正式发布将在几

00:38:37.000 --> 00:38:41.319
周

00:38:37.980 --> 00:38:43.740
先生，还有其他问题吗

00:38:41.319 --> 00:38:43.740
回到那里

00:38:47.570 --> 00:38:57.420
嗨，他写的每个当前申请

00:38:53.490 --> 00:39:01.050
 Java 8中的Java将在Java 9虚拟机上运行

00:38:57.420 --> 00:39:03.210
机器很好，所以最快的答案

00:39:01.050 --> 00:39:06.390
是指免费的视频

00:39:03.210 --> 00:39:08.790
先生的主题演讲。一天更多

00:39:06.390 --> 00:39:11.490
更详细的答案是，如果您

00:39:08.790 --> 00:39:15.060
有一个仅使用的现有代码

00:39:11.490 --> 00:39:17.430
 Java SE 8 AP是并且不依赖于

00:39:15.060 --> 00:39:20.580
 JDK和日记API或其他内部

00:39:17.430 --> 00:39:27.660
杰克人的各个方面可能都起作用

00:39:20.580 --> 00:39:31.100
在jdk 9上没有变化谢谢你我需要

00:39:27.660 --> 00:39:31.100
向您展示此幻灯片，我在Oracle工作

00:39:32.810 --> 00:39:39.300
嗨，这对构建工具有什么影响

00:39:37.230 --> 00:39:41.040
作为行家和摇篮

00:39:39.300 --> 00:39:45.300
罗伯特·舒尔特（Robert Schulte）坐好了

00:39:41.040 --> 00:39:47.630
在这里，因为他当然可以说他

00:39:45.300 --> 00:39:50.730
知道我知道答案的方法，但是

00:39:47.630 --> 00:39:52.619
有影响，我很高兴

00:39:50.730 --> 00:39:55.950
报告我们已经紧密合作

00:39:52.619 --> 00:40:01.260
罗伯特和玛文有体面

00:39:55.950 --> 00:40:03.540
已经支持模块了，那又如何

00:40:01.260 --> 00:40:06.030
我们所做的是我们使用Maven Freedo测试的

00:40:03.540 --> 00:40:07.859
甚至可以正常工作

00:40:06.030 --> 00:40:11.490
 Mayville的早期版本可以

00:40:07.859 --> 00:40:13.800
也可以在Java 9上正常运行，但我们只是

00:40:11.490 --> 00:40:15.900
从三个左右开始

00:40:13.800 --> 00:40:17.520
它们通常与

00:40:15.900 --> 00:40:20.310
例如插件有这个

00:40:17.520 --> 00:40:23.760
更改为版本方案

00:40:20.310 --> 00:40:27.720
是一个点和一个新版本，它具有

00:40:23.760 --> 00:40:29.460
改变了2.29以及所有这些工具

00:40:27.720 --> 00:40:31.920
在做他们正在做数组

00:40:29.460 --> 00:40:34.260
他们把它分割成一个点

00:40:31.920 --> 00:40:36.119
第二个元素只有九个

00:40:34.260 --> 00:40:38.520
他们从山上走出来

00:40:36.119 --> 00:40:40.710
索引异常，所以这些已经

00:40:38.520 --> 00:40:43.619
固定，我认为大多数插件

00:40:40.710 --> 00:40:47.550
现在已经准备好Java了

00:40:43.619 --> 00:40:51.599
但是，行家，我们也会

00:40:47.550 --> 00:40:52.980
现在也构建模块化的jar文件，因此

00:40:51.599 --> 00:40:54.569
你知道这不只是它

00:40:52.980 --> 00:40:57.930
一直以在线方式运作

00:40:54.569 --> 00:40:59.220
它实际上具有它真正理解的

00:40:57.930 --> 00:41:03.170
什么是模块，您可以拥有一个

00:40:59.220 --> 00:41:03.170
模块信息并完成所有这些工作

00:41:04.740 --> 00:41:09.720
只需添加一件事，您就不必

00:41:06.990 --> 00:41:11.610
我想改变你的文件夹结构

00:41:09.720 --> 00:41:14.550
您看到的大多数示例中，您

00:41:11.610 --> 00:41:16.980
在您添加的源中添加模块名称

00:41:14.550 --> 00:41:19.140
对于大型项目不需要

00:41:16.980 --> 00:41:21.200
只需跟源管理者保持联系

00:41:19.140 --> 00:41:24.390
那里的动力，它将起作用

00:41:21.200 --> 00:41:26.610
对，那是因为漂亮

00:41:24.390 --> 00:41:28.980
很多，你知道一个模块是

00:41:26.610 --> 00:41:32.520
模块和Maven项目相同

00:41:28.980 --> 00:41:35.070
事情不存在，当我们

00:41:32.520 --> 00:41:36.450
如果我们在命令行显示东西

00:41:35.070 --> 00:41:38.250
需要谈论多个模块

00:41:36.450 --> 00:41:40.080
我们需要向模块显示每个

00:41:38.250 --> 00:41:41.640
模块习惯在以下位置有其自己的目录

00:41:40.080 --> 00:41:43.440
源路径或飞蛾或

00:41:41.640 --> 00:41:47.820
爆炸的模块，但这仅仅是一个

00:41:43.440 --> 00:41:48.150
神器真的是你秀玉

00:41:47.820 --> 00:41:50.640
每股收益

00:41:48.150 --> 00:41:52.890
在几张幻灯片中，罗伯特（Robert） 

00:41:50.640 --> 00:41:55.380
一个可以运行Maven项目的插件

00:41:52.890 --> 00:41:59.790
好吧，好点

00:41:55.380 --> 00:42:02.369
我只是想补充一点，我们有一个

00:41:59.790 --> 00:42:03.690
今晚的行家buff，所以，如果以及何时

00:42:02.369 --> 00:42:10.080
我们可以谈谈有趣的细节

00:42:03.690 --> 00:42:13.080
直到他们变得更好为止

00:42:10.080 --> 00:42:15.350
质疑其他任何问题

00:42:13.080 --> 00:42:15.350
分钟

00:42:16.910 --> 00:42:20.060
在那边

00:42:22.690 --> 00:42:32.390
是否有任何版本控制机制

00:42:26.479 --> 00:42:34.460
模块不，这是最常被问到的

00:42:32.390 --> 00:42:36.349
常见问题解答

00:42:34.460 --> 00:42:40.849
与之竞争的第一或第二

00:42:36.349 --> 00:42:43.369
你不只是融合了OSG我知道

00:42:40.849 --> 00:42:46.069
这个设计我们接受了

00:42:43.369 --> 00:42:47.420
方法不是不是我们的

00:42:46.069 --> 00:42:51.920
我们到达此的原始方法

00:42:47.420 --> 00:42:53.720
经过很长一段时间后

00:42:51.920 --> 00:42:57.009
模块和工件的位置

00:42:53.720 --> 00:43:00.289
定义它们是独立的概念，因此

00:42:57.009 --> 00:43:03.259
模块是更高级别的一种

00:43:00.289 --> 00:43:04.759
它们嵌入在

00:43:03.259 --> 00:43:05.420
虚拟人所熟悉的语言

00:43:04.759 --> 00:43:08.299
机

00:43:05.420 --> 00:43:10.220
他们没有版本号

00:43:08.299 --> 00:43:12.979
环境你知道的东西

00:43:10.220 --> 00:43:15.529
你知道模块是最基本的

00:43:12.979 --> 00:43:17.749
我们不放置的类或接口

00:43:15.529 --> 00:43:19.670
这些版本，但我们确实放版本

00:43:17.749 --> 00:43:22.039
在包含它们的东西上

00:43:19.670 --> 00:43:26.960
拥有版本非常合理

00:43:22.039 --> 00:43:28.519
模块化的jar文件，但是我们基本上

00:43:26.960 --> 00:43:30.440
留下来构建诸如maven和

00:43:28.519 --> 00:43:32.539
让一只蚂蚁摇摇欲坠

00:43:30.440 --> 00:43:35.900
版本冲突模块系统将

00:43:32.539 --> 00:43:37.940
如果有两个模块化，则检测冲突

00:43:35.900 --> 00:43:40.430
 jar文件位于

00:43:37.940 --> 00:43:42.200
定义模型的模块路径

00:43:40.430 --> 00:43:44.479
模块系统将使用相同的名称

00:43:42.200 --> 00:43:47.420
停下来说我不知道​​该怎么做

00:43:44.479 --> 00:43:52.910
做出选择，所以您必须删除

00:43:47.420 --> 00:43:55.430
其中之一或修复问题模块

00:43:52.910 --> 00:43:59.989
确实有这种艺术，我们编译了模块

00:43:55.430 --> 00:44:02.089
如果其中没有模块信息

00:43:59.989 --> 00:44:04.969
如果我列出模块，您会在

00:44:02.089 --> 00:44:06.680
 9您知道您插入了9 

00:44:04.969 --> 00:44:08.779
由构建系统知道进入模块

00:44:06.680 --> 00:44:11.359
信息点类文件，但是就在那里

00:44:08.779 --> 00:44:14.450
作为文档，以便该版本

00:44:11.359 --> 00:44:16.309
字符串不是真的被解释为

00:44:14.450 --> 00:44:17.299
只是进行诊断，所以如果

00:44:16.309 --> 00:44:18.829
您正在尝试诊断某些东西

00:44:17.299 --> 00:44:21.739
在大型系统中您可以看到错误

00:44:18.829 --> 00:44:24.469
解决了哪些版本的模块

00:44:21.739 --> 00:44:27.030
但解析器实际上并没有付款

00:44:24.469 --> 00:44:28.920
注意那些版本字符串

00:44:27.030 --> 00:44:31.230
就像我说的那样，你知道

00:44:28.920 --> 00:44:34.530
违反直觉的方法，这就是为什么

00:44:31.230 --> 00:44:36.299
人们自然会问很多，但是

00:44:34.530 --> 00:44:38.549
这就是答案，您知道抱歉

00:44:36.299 --> 00:44:39.240
到目前为止，这似乎工作得很好

00:44:38.549 --> 00:44:45.349
进一步

00:44:39.240 --> 00:44:45.349
好的时间也许还有一个

00:44:50.780 --> 00:44:54.280
好的，非常感谢你

00:44:53.099 --> 00:44:59.789
往前走，模块化的眼睛

00:44:54.280 --> 00:44:59.789
 [掌声] 

