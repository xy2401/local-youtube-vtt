WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.200 --> 00:00:09.300
 [音乐] 

00:00:03.710 --> 00:00:11.370
好的，大家好，我叫Alex Buckley 

00:00:09.300 --> 00:00:14.700
我在Java平台小组工作， 

00:00:11.370 --> 00:00:18.109
 Oracle这是模块化开发

00:00:14.700 --> 00:00:21.150
 JDK 9谢谢您的光临

00:00:18.109 --> 00:00:23.970
珍妮k-9快到了

00:00:21.150 --> 00:00:26.189
其中有很多功能

00:00:23.970 --> 00:00:27.330
性能改进，例如

00:00:26.189 --> 00:00:30.990
紧凑的弦

00:00:27.330 --> 00:00:33.480
有些是工具方面的改进，例如

00:00:30.990 --> 00:00:35.520
 Java doc中的搜索框看到任何人

00:00:33.480 --> 00:00:39.989
顺便说一下， 

00:00:35.520 --> 00:00:43.620
搜索框有些酷J 

00:00:39.989 --> 00:00:44.879
 shell工具有人尝试过吗

00:00:43.620 --> 00:00:47.430
是的

00:00:44.879 --> 00:00:49.860
当然会有很多更新

00:00:47.430 --> 00:00:53.280
现有功能，例如对

00:00:49.860 --> 00:00:55.590
 Unicode 8但主要功能和

00:00:53.280 --> 00:01:00.149
一个花了几年的时间

00:00:55.590 --> 00:01:02.190
成果是模块系统模块

00:01:00.149 --> 00:01:05.850
系统很重要，因为它可以

00:01:02.190 --> 00:01:07.950
一直到模块化开发

00:01:05.850 --> 00:01:10.049
 Java中内置了模块系统

00:01:07.950 --> 00:01:12.450
语言和Java虚拟机

00:01:10.049 --> 00:01:15.090
这样您编写的应用程序以及

00:01:12.450 --> 00:01:17.820
您消耗的库，甚至

00:01:15.090 --> 00:01:20.610
 JDK本身可以全部开发和

00:01:17.820 --> 00:01:23.750
经过测试，打包和部署为

00:01:20.610 --> 00:01:27.330
由模块系统管理的模块

00:01:23.750 --> 00:01:30.329
让每个人都使用相同的模块

00:01:27.330 --> 00:01:33.420
规则对可靠性有很大好处

00:01:30.329 --> 00:01:38.430
维护性和安全性

00:01:33.420 --> 00:01:40.560
在本讲的其余部分中请参见

00:01:38.430 --> 00:01:43.200
模块主题一直向下

00:01:40.560 --> 00:01:45.030
请注意，本次演讲分为三个部分

00:01:43.200 --> 00:01:47.850
部分说明模块是如何

00:01:45.030 --> 00:01:51.630
逾期未决的构建基块

00:01:47.850 --> 00:01:53.759
应用程序代码结构第二

00:01:51.630 --> 00:01:56.490
部分是关于应用程序和

00:01:53.759 --> 00:01:58.920
 Pendin可以迁移到的库数据

00:01:56.490 --> 00:02:02.180
更广泛的模块是关于您

00:01:58.920 --> 00:02:05.040
可以混合模块化代码和模块化代码

00:02:02.180 --> 00:02:07.920
第三部分是关于

00:02:05.040 --> 00:02:12.349
模块化JDK，其中包括一些

00:02:07.920 --> 00:02:12.349
由此产生的兼容性问题

00:02:12.490 --> 00:02:19.150
因此在大型模块化中进行编程

00:02:15.880 --> 00:02:22.150
面向对象的应用

00:02:19.150 --> 00:02:25.630
编程重用的基本单位是

00:02:22.150 --> 00:02:28.270
传统上，班级课程或

00:02:25.630 --> 00:02:31.530
 Java类具有出色的机制

00:02:28.270 --> 00:02:34.380
用于促进班级的重用

00:02:31.530 --> 00:02:37.200
重用行为的继承

00:02:34.380 --> 00:02:40.360
重用抽象的接口

00:02:37.200 --> 00:02:43.060
单独的编译动态链接和

00:02:40.360 --> 00:02:45.070
访问控制一直到

00:02:43.060 --> 00:02:50.380
各个领域和方法的水平

00:02:45.070 --> 00:02:52.620
自1997年以来我们就开始嵌套课程

00:02:50.380 --> 00:02:56.260
所以应该有可能一个

00:02:52.620 --> 00:02:59.560
顶级类来封装大量

00:02:56.260 --> 00:03:02.410
具有的功能

00:02:59.560 --> 00:03:04.570
介意我在这里设置一个稻草人，但是

00:03:02.410 --> 00:03:06.940
记住这一点，似乎

00:03:04.570 --> 00:03:09.970
就像一个应用程序可能是一个

00:03:06.940 --> 00:03:13.060
包含一些非常丰富的包装

00:03:09.970 --> 00:03:14.830
通过字段对所有共享数据进行分类

00:03:13.060 --> 00:03:18.570
包中可访问的方法

00:03:14.830 --> 00:03:21.910
以及少数公共课程

00:03:18.570 --> 00:03:26.370
形成入口或API的API 

00:03:21.910 --> 00:03:29.560
申请权不是真的

00:03:26.370 --> 00:03:32.500
有多少人在一个代码库上工作

00:03:29.560 --> 00:03:37.960
包含在您的应用程序中

00:03:32.500 --> 00:03:44.170
包没有手正确答案二

00:03:37.960 --> 00:03:46.930
套餐三套餐五顺序

00:03:44.170 --> 00:03:50.590
您的代码库中有十个软件包

00:03:46.930 --> 00:03:53.140
在10点到17点之间有一些

00:03:50.590 --> 00:03:54.430
至少一分钟右右右

00:03:53.140 --> 00:03:59.100
每个人都知道最低限度，但谁知道

00:03:54.430 --> 00:04:01.560
可能最多订购50个包裹

00:03:59.100 --> 00:04:06.270
也许有一些手

00:04:01.560 --> 00:04:06.270
有些手在射击

00:04:07.530 --> 00:04:12.580
只是您的代码您的短数字

00:04:09.790 --> 00:04:16.959
现在的代码是没有人使用

00:04:12.580 --> 00:04:19.030
很少的软件包，甚至

00:04:16.959 --> 00:04:21.840
最小的微服务不会

00:04:19.030 --> 00:04:25.180
预计将适合单个包装

00:04:21.840 --> 00:04:28.300
程序是软件包多个软件包

00:04:25.180 --> 00:04:30.009
不幸的是，没有类

00:04:28.300 --> 00:04:32.800
语言放弃了一次

00:04:30.009 --> 00:04:36.780
程序比这里的包大

00:04:32.800 --> 00:04:39.460
 Java中可访问性的层次结构

00:04:36.780 --> 00:04:41.139
简单易懂易用

00:04:39.460 --> 00:04:43.720
并在编译时强力执行

00:04:41.139 --> 00:04:47.460
和运行时，但它有一个很大的缺点

00:04:43.720 --> 00:04:50.160
您的程序是几十个软件包

00:04:47.460 --> 00:04:53.620
但是在之间共享代码的唯一方法

00:04:50.160 --> 00:04:57.039
打包是通过将事物公开

00:04:53.620 --> 00:04:59.410
那么你就是与所有人分享

00:04:57.039 --> 00:05:01.389
打包的友谊并不奇怪

00:04:59.410 --> 00:05:03.610
以一种或另一种形式

00:05:01.389 --> 00:05:05.680
多年来要求多次

00:05:03.610 --> 00:05:07.930
打包是组织的好方法

00:05:05.680 --> 00:05:12.910
课，但大多数人希望有一个

00:05:07.930 --> 00:05:14.830
现在也可以组织软件包的方法

00:05:12.910 --> 00:05:16.750
当然你可以把一些包放在一个

00:05:14.830 --> 00:05:18.580
 jar文件和其他包中的另一个

00:05:16.750 --> 00:05:21.340
 jar文件等，但是之后

00:05:18.580 --> 00:05:23.050
编译并不能帮助您控制

00:05:21.340 --> 00:05:25.870
从一个包装进入另一个包装

00:05:23.050 --> 00:05:28.900
在开发过程中，您不喜欢

00:05:25.870 --> 00:05:30.550
将您的包裹按逻辑分组

00:05:28.900 --> 00:05:34.630
当你真正发展时的时尚

00:05:30.550 --> 00:05:36.430
他们点头，也许是的，很好

00:05:34.630 --> 00:05:39.820
想着，是的，有一些

00:05:36.430 --> 00:05:43.060
观众点头表示

00:05:39.820 --> 00:05:46.870
带我进入JDK 9中的模块

00:05:43.060 --> 00:05:49.990
 JDK 9中的一组软件包

00:05:46.870 --> 00:05:51.760
感觉在一起，这是

00:05:49.990 --> 00:05:55.000
经典软件工程原理

00:05:51.760 --> 00:05:57.400
高凝聚力的一些包装

00:05:55.000 --> 00:06:01.030
适用于外部的代码

00:05:57.400 --> 00:06:02.620
这些模块是一些导出包

00:06:01.030 --> 00:06:04.690
套件的内部

00:06:02.620 --> 00:06:06.880
模块可以被内部代码使用

00:06:04.690 --> 00:06:10.840
模块，但不是通过这些之外的代码

00:06:06.880 --> 00:06:13.389
是隐藏的包装，现在使用一词

00:06:10.840 --> 00:06:16.360
不断使用

00:06:13.389 --> 00:06:18.970
此代码是模块的重用单位

00:06:16.360 --> 00:06:21.009
它描述了它的哪个包装

00:06:18.970 --> 00:06:24.430
外用和隐藏

00:06:21.009 --> 00:06:27.130
内部使用由模块构建的程序

00:06:24.430 --> 00:06:29.650
比程序更可靠

00:06:27.130 --> 00:06:31.570
由一组松散的程序包构建而成

00:06:29.650 --> 00:06:34.479
可以互相自由访问

00:06:31.570 --> 00:06:36.719
暴露于许多AP的外部

00:06:34.479 --> 00:06:36.719
世界

00:06:36.720 --> 00:06:43.860
让我们看一下Java基本模块

00:06:40.530 --> 00:06:49.020
是Java gdk9的基础

00:06:43.860 --> 00:06:52.260
它将救援平台分组

00:06:49.020 --> 00:06:54.390
必不可少的Java星和Java X点星

00:06:52.260 --> 00:06:57.720
大多数程序需要的软件包

00:06:54.390 --> 00:07:01.680
其中java.lang对象和Java IO文件

00:06:57.720 --> 00:07:04.110
和Java util列表将其声明为

00:07:01.680 --> 00:07:06.270
这给出了名为模块信息Java的文件

00:07:04.110 --> 00:07:09.480
模块的名称及其导出的

00:07:06.270 --> 00:07:12.150
打包导出的意思是

00:07:09.480 --> 00:07:14.760
 java.lang包意味着

00:07:12.150 --> 00:07:20.120
 java.lang的公共类是

00:07:14.760 --> 00:07:23.580
可访问此模块外部的代码

00:07:20.120 --> 00:07:28.470
没有明确导出的包

00:07:23.580 --> 00:07:32.070
隐藏在Java基本模块中

00:07:28.470 --> 00:07:35.310
红色，有很多评论，还有一些

00:07:32.070 --> 00:07:38.160
包对公众隐瞒

00:07:35.310 --> 00:07:41.520
不能从外部访问课程

00:07:38.160 --> 00:07:43.320
基于Java的模块，这是第一个

00:07:41.520 --> 00:07:46.740
模块系统的目标很强

00:07:43.320 --> 00:07:49.050
封装模块不仅仅是一组

00:07:46.740 --> 00:07:51.690
包，它是一组导出的

00:07:49.050 --> 00:07:54.030
包装和隐藏包装

00:07:51.690 --> 00:07:57.660
导出包的公共类是

00:07:54.030 --> 00:08:00.030
公众可以在模块外部访问

00:07:57.660 --> 00:08:04.500
隐藏包的类别不是

00:08:00.030 --> 00:08:07.110
可在模块外部访问，因此

00:08:04.500 --> 00:08:10.320
可访问性的层次更大

00:08:07.110 --> 00:08:13.110
 jdk 9比jdk AIDS中的阅读量更高

00:08:10.320 --> 00:08:15.450
在右边你可以安排公开

00:08:13.110 --> 00:08:19.050
类只能在内部访问

00:08:15.450 --> 00:08:22.729
他们的模块或在他们的内部可以访问

00:08:19.050 --> 00:08:25.919
模块和其他特定模块，或

00:08:22.729 --> 00:08:28.169
每个人都可以访问，以便在

00:08:25.919 --> 00:08:31.169
吉达钥匙9如果您正在公开场合

00:08:28.169 --> 00:08:33.469
在类声明上不再

00:08:31.169 --> 00:08:36.120
意味着每个人都可以访问课程

00:08:33.469 --> 00:08:42.839
访问权限取决于该类是否为

00:08:36.120 --> 00:08:44.940
从模块导出类的包，因为

00:08:42.839 --> 00:08:46.950
 Java base是一个模块，让我们重复使用它

00:08:44.940 --> 00:08:50.130
有我们自己的模块

00:08:46.950 --> 00:08:54.720
这是最简单的程序

00:08:50.130 --> 00:08:56.910
一包komm示例你好，让我们

00:08:54.720 --> 00:09:00.390
声明一个模块以将该包放入

00:08:56.910 --> 00:09:02.550
你好，世界上有一个模块

00:09:00.390 --> 00:09:04.650
 Java文件，为了便于讨论

00:09:02.550 --> 00:09:07.190
模块将导出平静示例

00:09:04.650 --> 00:09:09.480
你好包与exports指令

00:09:07.190 --> 00:09:12.450
你可能想知道你好

00:09:09.480 --> 00:09:14.490
世界模块知道它有一个包装

00:09:12.450 --> 00:09:17.580
毕竟叫comm example hello 

00:09:14.490 --> 00:09:20.850
包装中似乎没有任何东西指向

00:09:17.580 --> 00:09:23.160
该模块取决于工具

00:09:20.850 --> 00:09:26.340
在开发期间决定哪个模块

00:09:23.160 --> 00:09:28.740
每个包实际上都属于您

00:09:26.340 --> 00:09:31.080
 IDE会照顾您的，您将创建一个

00:09:28.740 --> 00:09:33.030
要求模块化作业或应用

00:09:31.080 --> 00:09:34.410
然后是每个包装的模块名称

00:09:33.030 --> 00:09:36.420
您创建的将被传递给

00:09:34.410 --> 00:09:40.170
模块让我们知道他们在那里

00:09:36.420 --> 00:09:42.420
如果您手动运行Java C，则会发生

00:09:40.170 --> 00:09:44.400
 Java C找出每个模块

00:09:42.420 --> 00:09:48.930
包就是这就是为什么模块信息

00:09:44.400 --> 00:09:51.420
 Java文件在SRC中的级别与

00:09:48.930 --> 00:09:54.570
包含

00:09:51.420 --> 00:09:56.550
包依赖的好处

00:09:54.570 --> 00:09:58.560
工具是，它真的很容易

00:09:56.550 --> 00:10:01.380
将现有包放在模块中

00:09:58.560 --> 00:10:03.240
然后立即给那个包裹

00:10:01.380 --> 00:10:06.630
强封装的好处

00:10:03.240 --> 00:10:09.180
我们不想每个班级都去

00:10:06.630 --> 00:10:11.070
必须选择强力封装

00:10:09.180 --> 00:10:14.310
通过声明它属于的模块

00:10:11.070 --> 00:10:16.230
会引起诸如类的错误

00:10:14.310 --> 00:10:19.170
在同一包中尝试加入

00:10:16.230 --> 00:10:22.110
不同的模块非常重要

00:10:19.170 --> 00:10:25.730
我稍后再提及的原因

00:10:22.110 --> 00:10:29.130
东西在包装里打个招呼类

00:10:25.730 --> 00:10:33.660
导入java.lang包，其中

00:10:29.130 --> 00:10:36.030
从现在开始导入的软件包

00:10:33.660 --> 00:10:38.070
说亚历克斯，答案显然是Java 

00:10:36.030 --> 00:10:40.500
基地，因为你在一分钟前告诉我

00:10:38.070 --> 00:10:42.690
基于Java的导出java.lang 

00:10:40.500 --> 00:10:45.120
包中有一张幻灯片显示了

00:10:42.690 --> 00:10:48.420
您的权利，但编译器如何

00:10:45.120 --> 00:10:50.580
知道一般情况下，当您导入

00:10:48.420 --> 00:10:53.040
包，编译器应搜索

00:10:50.580 --> 00:10:54.990
文件系统中寻找哪些模块

00:10:53.040 --> 00:10:57.900
出口到进口包装

00:10:54.990 --> 00:11:00.600
如果多个模块导出

00:10:57.900 --> 00:11:02.279
导入的包显然java.lang是

00:11:00.600 --> 00:11:04.889
特殊情况，但总的来说

00:11:02.279 --> 00:11:10.079
编译器知道哪个模块导出一个

00:11:04.889 --> 00:11:12.180
包，如果我们打算重用Java 

00:11:10.079 --> 00:11:14.490
基于模块，我们应该证明

00:11:12.180 --> 00:11:16.350
实际上，因为我们正在写一个

00:11:14.490 --> 00:11:18.480
我们必须自己做模块

00:11:16.350 --> 00:11:21.230
事实上，这是

00:11:18.480 --> 00:11:24.480
模块系统可靠的依赖关系

00:11:21.230 --> 00:11:26.759
模块不仅仅是一组软件包

00:11:24.480 --> 00:11:30.959
一组取决于

00:11:26.759 --> 00:11:34.500
包由其他模块导出，因此

00:11:30.959 --> 00:11:37.589
 HelloWorld模块指定它

00:11:34.500 --> 00:11:39.959
将基于Java的模块与

00:11:37.589 --> 00:11:40.850
在其模块中的require指令

00:11:39.959 --> 00:11:43.199
图片Java 

00:11:40.850 --> 00:11:46.220
这意味着HelloWorld中的代码

00:11:43.199 --> 00:11:48.380
模块可以导入任何软件包

00:11:46.220 --> 00:11:50.730
由Java库导出

00:11:48.380 --> 00:11:52.730
如果代码在hello world中会发生什么

00:11:50.730 --> 00:11:56.759
尝试导入任何软件包

00:11:52.730 --> 00:11:58.139
由Java基础隐藏，例如和

00:11:56.759 --> 00:12:02.639
有一个红色的一些安全

00:11:58.139 --> 00:12:05.970
提供者是一些例子

00:12:02.639 --> 00:12:08.639
完成GlassFish 4.1的代码

00:12:05.970 --> 00:12:11.310
无法在jdk 9上运行，因为VM 

00:12:08.639 --> 00:12:15.180
抛出非法访问错误

00:12:11.310 --> 00:12:17.100
留言是一个班级关注企业

00:12:15.180 --> 00:12:19.439
安全提供策略包装

00:12:17.100 --> 00:12:22.500
模块未命名模块不用担心

00:12:19.439 --> 00:12:25.410
纾困无法访问某些课程

00:12:22.500 --> 00:12:30.540
安全性在模块中提供策略文件

00:12:25.410 --> 00:12:33.540
 Java基础现在可以看一下开放的JDK 

00:12:30.540 --> 00:12:35.880
存储库向我们显示该策略文件

00:12:33.540 --> 00:12:38.310
该课程在阳光下宣布为公共

00:12:35.880 --> 00:12:40.620
安全提供程序包，但是因为

00:12:38.310 --> 00:12:44.040
该包不是由java导出的

00:12:40.620 --> 00:12:47.519
基本策略文件只能从以下位置访问

00:12:44.040 --> 00:12:50.009
 Java基础本身中的代码，因此要清楚

00:12:47.519 --> 00:12:52.380
在码头k9中，GlassFish代码无法

00:12:50.009 --> 00:12:55.139
访问位于的公共策略文件类

00:12:52.380 --> 00:12:57.420
编译时间或运行时

00:12:55.139 --> 00:12:59.579
就像尝试访问私有包一样

00:12:57.420 --> 00:13:01.529
包Java C外部的类

00:12:59.579 --> 00:13:03.959
给出虚拟机抛出合法错误

00:13:01.529 --> 00:13:07.350
访问错误GlassFish将需要查找

00:13:03.959 --> 00:13:10.160
受支持的API，而不是Sun dot star API 

00:13:07.350 --> 00:13:10.160
做好工作

00:13:10.740 --> 00:13:15.390
我想回到Inferno模块

00:13:12.990 --> 00:13:17.760
宣告世界的Java档案

00:13:15.390 --> 00:13:19.740
模块真的很重要

00:13:17.760 --> 00:13:26.700
了解模块导出

00:13:19.740 --> 00:13:28.470
包，但需要模块

00:13:26.700 --> 00:13:30.750
原因是由于旧软件

00:13:28.470 --> 00:13:34.470
工程原理重用单位

00:13:30.750 --> 00:13:37.410
是释放单位，原理是

00:13:34.470 --> 00:13:40.230
关于重用关注点分离的问题

00:13:37.410 --> 00:13:42.420
某人的代码，而不是复制粘贴

00:13:40.230 --> 00:13:45.209
到您自己的源代码树中，但是

00:13:42.420 --> 00:13:48.810
在某种程度上取决于黑匣子

00:13:45.209 --> 00:13:51.000
现在由其他人释放的工件

00:13:48.810 --> 00:13:54.089
 Java生态系统毫无疑问

00:13:51.000 --> 00:13:57.120
释放单元是一个jar文件

00:13:54.089 --> 00:13:59.190
罐子的模块不会改变

00:13:57.120 --> 00:14:01.560
文件作为HelloWorld一个jar就是

00:13:59.190 --> 00:14:04.620
您今天建造的只是带有

00:14:01.560 --> 00:14:06.420
模块信息点类文件

00:14:04.620 --> 00:14:09.420
由照片中的模块生成的编译器

00:14:06.420 --> 00:14:12.089
 Java以及普通的类文件

00:14:09.420 --> 00:14:16.980
像打个招呼，我们称之为模块化

00:14:12.089 --> 00:14:20.610
罐子，所以当有人释放模块化

00:14:16.980 --> 00:14:23.610
将其模块重用

00:14:20.610 --> 00:14:25.820
别人写作需要打招呼

00:14:23.610 --> 00:14:29.459
 Java自己的模块中的世界

00:14:25.820 --> 00:14:32.850
重新使用者受益于明确的

00:14:29.459 --> 00:14:37.440
相干的API恰好由

00:14:32.850 --> 00:14:39.510
导出的软件包释放者的好处

00:14:37.440 --> 00:14:42.089
遮盖物的强力封装

00:14:39.510 --> 00:14:44.880
包里面的模块

00:14:42.089 --> 00:14:47.670
即使存在很高的API 

00:14:44.880 --> 00:14:49.829
模块内部耦合松动

00:14:47.670 --> 00:14:52.649
模块之间的耦合是另一个

00:14:49.829 --> 00:14:55.110
好的软件工程原理

00:14:52.649 --> 00:14:56.970
作为您要导出的版本

00:14:55.110 --> 00:15:03.300
包，但是作为重用错误， 

00:14:56.970 --> 00:15:04.920
您正在使用模块，所以您想要

00:15:03.300 --> 00:15:08.010
需要您的Java基础

00:15:04.920 --> 00:15:11.070
您说需要的HelloWorld模块

00:15:08.010 --> 00:15:13.110
照片Java模块中的Java基础，其中

00:15:11.070 --> 00:15:16.680
编译器在物理上寻找它吗

00:15:13.110 --> 00:15:19.410
如果您已经构建了模块化jar文件

00:15:16.680 --> 00:15:21.209
包含模块的HelloWorld jar 

00:15:19.410 --> 00:15:21.740
照相课你身体放在哪里

00:15:21.209 --> 00:15:25.760
那罐子

00:15:21.740 --> 00:15:30.170
 JDK 9会在

00:15:25.760 --> 00:15:33.170
系统映像和模块路径上的

00:15:30.170 --> 00:15:33.950
系统映像在JDK安装中

00:15:33.170 --> 00:15:37.250
目录

00:15:33.950 --> 00:15:41.660
它包含Java基础和几十个

00:15:37.250 --> 00:15:43.810
核心JDK模块的模块路径已设置

00:15:41.660 --> 00:15:47.000
在命令行上，例如类路径

00:15:43.810 --> 00:15:50.410
除了模块路径指向

00:15:47.000 --> 00:15:53.120
包含模块化jar的目录

00:15:50.410 --> 00:15:54.590
而不是罐子本身

00:15:53.120 --> 00:15:56.270
非常方便，它使

00:15:54.590 --> 00:15:58.220
牧师说看库

00:15:56.270 --> 00:16:00.530
还有一大堆

00:15:58.220 --> 00:16:04.760
每个可能有数百个模块化罐

00:16:00.530 --> 00:16:07.880
目录现在关于

00:16:04.760 --> 00:16:09.920
彼此需要的模块是

00:16:07.880 --> 00:16:11.660
模块系统可以检查要求

00:16:09.920 --> 00:16:15.590
并验证模块化应用程序

00:16:11.660 --> 00:16:18.440
编译器或运行时发出声音

00:16:15.590 --> 00:16:22.070
找到了最初的hello world模块

00:16:18.440 --> 00:16:24.260
我的非良性组装系统

00:16:22.070 --> 00:16:26.870
映像或它执行的模块路径

00:16:24.260 --> 00:16:29.960
一个称为分辨率解析的过程

00:16:26.870 --> 00:16:32.570
意味着检查它需要指令

00:16:29.960 --> 00:16:34.040
并在其中找到那些必需的模块

00:16:32.570 --> 00:16:35.900
系统映像或模块路径上

00:16:34.040 --> 00:16:39.740
然后递归地解决它们

00:16:35.900 --> 00:16:42.460
我们正在建立一个节点为

00:16:39.740 --> 00:16:45.740
模块及其边缘是必需的

00:16:42.460 --> 00:16:50.080
关系，并且要在JDK 9中明确说明

00:16:45.740 --> 00:16:52.310
如果在编译时和运行时

00:16:50.080 --> 00:16:56.540
决议成功你得到三个

00:16:52.310 --> 00:17:00.110
首先保证每个模块

00:16:56.540 --> 00:17:02.090
必需的，可以的，很好

00:17:00.110 --> 00:17:03.860
明显，但比

00:17:02.090 --> 00:17:08.450
您找不到的课程路径

00:17:03.860 --> 00:17:11.410
缺少罐子，直到稍后的模块

00:17:08.450 --> 00:17:14.120
不在一个周期内互相依赖

00:17:11.410 --> 00:17:16.310
循环依赖性是一种设计气味

00:17:14.120 --> 00:17:19.250
我们正借此机会

00:17:16.310 --> 00:17:23.030
从第一天开始禁止他们进入模块

00:17:19.250 --> 00:17:24.560
 JDK 9现在有些人在想Alex 

00:17:23.030 --> 00:17:26.270
这只是依赖管理

00:17:24.560 --> 00:17:29.310
你没有听说过行家

00:17:26.270 --> 00:17:30.750
以为你绝对不是

00:17:29.310 --> 00:17:36.600
但绝对不会想到

00:17:30.750 --> 00:17:41.610
大象，你不确定

00:17:36.600 --> 00:17:43.260
周期性依赖性很好，现在让

00:17:41.610 --> 00:17:45.690
我说Maven仅在编译时有效

00:17:43.260 --> 00:17:48.960
此解决过程适用于

00:17:45.690 --> 00:17:51.000
运行时也一样，但更重要的是让

00:17:48.960 --> 00:17:53.820
我来决议第三个保证

00:17:51.000 --> 00:17:57.270
如果编码一个模块

00:17:53.820 --> 00:18:02.330
导入一个包，然后该包是

00:17:57.270 --> 00:18:04.980
从另一个模块导出

00:18:02.330 --> 00:18:07.290
现在，这种保证显然取决于

00:18:04.980 --> 00:18:10.440
出口以及需求，所以您不会

00:18:07.290 --> 00:18:12.930
在Maven中找到它意味着没有

00:18:10.440 --> 00:18:15.570
拆分包，这是怎么回事

00:18:12.930 --> 00:18:17.580
当类路径上的两个罐子包含

00:18:15.570 --> 00:18:19.350
相同的包装，您会加载一些

00:18:17.580 --> 00:18:21.330
从一个罐子包装中的类和

00:18:19.350 --> 00:18:23.880
包中的其他类

00:18:21.330 --> 00:18:25.920
其他罐子拆分包装是巨大的

00:18:23.880 --> 00:18:27.210
类路径机制的失败

00:18:25.920 --> 00:18:30.390
因为它们导致了难以置信的

00:18:27.210 --> 00:18:32.310
由于以下原因很难调试方案

00:18:30.390 --> 00:18:34.190
分辨率他们是完全

00:18:32.310 --> 00:18:36.390
在模块化应用中是不可能的

00:18:34.190 --> 00:18:38.670
这对于长期维护非常有用

00:18:36.390 --> 00:18:41.220
这就是我们的意思

00:18:38.670 --> 00:18:44.850
可靠的依赖关系

00:18:41.220 --> 00:18:47.070
在模块图中是可靠的

00:18:44.850 --> 00:18:48.480
每个模块只能访问一个版本

00:18:47.070 --> 00:18:51.990
一次打包

00:18:48.480 --> 00:18:54.810
第三个保证很重要

00:18:51.990 --> 00:18:56.970
也是为了表现，因为我们知道

00:18:54.810 --> 00:19:00.000
哪个模块导出哪个包

00:18:56.970 --> 00:19:01.440
无需扫描其中的每个模块

00:19:00.000 --> 00:19:04.560
系统映像和模块路径上

00:19:01.440 --> 00:19:06.390
尝试加载类对比时

00:19:04.560 --> 00:19:08.310
与如何从

00:19:06.390 --> 00:19:10.320
上课路径这是上课路径

00:19:08.310 --> 00:19:14.430
你们梅森在上课之前

00:19:10.320 --> 00:19:17.190
从Hadoop编译器或运行时

00:19:14.430 --> 00:19:20.310
通过110个罐子进行线性搜索

00:19:17.190 --> 00:19:21.780
现在每当需要一门新课时

00:19:20.310 --> 00:19:23.760
当然实施可以加快

00:19:21.780 --> 00:19:25.350
通过缓存类来解决问题

00:19:23.760 --> 00:19:28.080
在找不到他们的时候发现

00:19:25.350 --> 00:19:30.000
但他们仍然是同一个讨厌的一半

00:19:28.080 --> 00:19:33.450
这里有一半的包裹问题

00:19:30.000 --> 00:19:34.860
实际上，如果多个罐子分开

00:19:33.450 --> 00:19:37.770
你想想，上课的路径是

00:19:34.860 --> 00:19:40.080
那里一百一百个罐子疯狂

00:19:37.770 --> 00:19:42.840
超过12,000种可能的互动

00:19:40.080 --> 00:19:45.660
在不同罐子中的类之间

00:19:42.840 --> 00:19:47.810
每个开始线性搜索

00:19:45.660 --> 00:19:50.190
 classpath是亚航的终极选择

00:19:47.810 --> 00:19:52.710
无论你知道什么结构

00:19:50.190 --> 00:19:55.020
您的应用程序的类路径将其抛出

00:19:52.710 --> 00:19:58.590
离开并连接每个罐子到每个

00:19:55.020 --> 00:20:01.020
其他带有模块的jar模块信息

00:19:58.590 --> 00:20:02.700
 Java，您要告诉解决方案

00:20:01.020 --> 00:20:05.100
了解你的结构

00:20:02.700 --> 00:20:07.560
应用程序并使用该信息

00:20:05.100 --> 00:20:12.390
提供安全性和性能

00:20:07.560 --> 00:20:14.190
现在无论是编译时还是运行时

00:20:12.390 --> 00:20:15.900
所有关于依赖的讨论和

00:20:14.190 --> 00:20:17.250
分辨率和我知道的模块路径

00:20:15.900 --> 00:20:19.380
你在想什么

00:20:17.250 --> 00:20:22.290
谁在想哪里的版本号

00:20:19.380 --> 00:20:23.430
是版本号吗

00:20:22.290 --> 00:20:26.340
人们都认为你在哪里版本

00:20:23.430 --> 00:20:29.580
数字可以使我的模块和世界

00:20:26.340 --> 00:20:32.160
需要x和y，其中x需要版本

00:20:29.580 --> 00:20:35.970
某些库中有1个，而y需要版本

00:20:32.160 --> 00:20:37.830
现在是同一个图书馆的2 

00:20:35.970 --> 00:20:39.870
困难的问题

00:20:37.830 --> 00:20:42.450
多个版本是一个类加载器

00:20:39.870 --> 00:20:44.790
不能有两个同一个类

00:20:42.450 --> 00:20:47.880
现在使用包装类名称

00:20:44.790 --> 00:20:49.620
会的，你有一些版本

00:20:47.880 --> 00:20:51.330
依赖关系，它将选择其中之一

00:20:49.620 --> 00:20:53.310
适用于您的版本

00:20:51.330 --> 00:20:56.130
没有得到您认为的两个版本

00:20:53.310 --> 00:20:58.050
您曾经或在某些情况下取决于

00:20:56.130 --> 00:21:00.780
工件名称将它们都放入

00:20:58.050 --> 00:21:02.820
在这种情况下，您会得到

00:21:00.780 --> 00:21:04.380
拆分包问题，现在您已经

00:21:02.820 --> 00:21:06.300
一直在想Maven有可能

00:21:04.380 --> 00:21:08.130
有多个版本，因为没有人

00:21:06.300 --> 00:21:10.290
阻止了您这样做，但实际上

00:21:08.130 --> 00:21:12.390
你不玩游戏就做不到

00:21:10.290 --> 00:21:15.450
与类加载器，Maven没有

00:21:12.390 --> 00:21:17.430
如果您在哪里玩游戏，现在就做

00:21:15.450 --> 00:21:19.620
每个模块都在自己的类中加载

00:21:17.430 --> 00:21:22.230
装载机，您最好确保

00:21:19.620 --> 00:21:25.500
版本1和版本2的对象

00:21:22.230 --> 00:21:28.320
图书馆不要泄漏给普通人

00:21:25.500 --> 00:21:29.700
呼叫者像你好世界否则

00:21:28.320 --> 00:21:31.740
你会得到可怕的课堂演员

00:21:29.700 --> 00:21:33.750
无法将foo强制转换为的异常

00:21:31.740 --> 00:21:35.540
 foo，因为来自库1和的foo 

00:21:33.750 --> 00:21:37.920
库2的食物不同

00:21:35.540 --> 00:21:39.570
好的，您在想，这似乎是

00:21:37.920 --> 00:21:41.160
复杂的问题和阶级

00:21:39.570 --> 00:21:42.720
装载机很复杂，没关系

00:21:41.160 --> 00:21:46.140
一个库的多个版本忘记了

00:21:42.720 --> 00:21:48.900
我可以这样说

00:21:46.140 --> 00:21:52.080
一些库的第2版，而不是

00:21:48.900 --> 00:21:55.260
越野车版本1很好，现在您就是为什么

00:21:52.080 --> 00:21:56.190
在您想要版本2的幻灯片上

00:21:55.260 --> 00:21:58.409
确定

00:21:56.190 --> 00:22:00.750
但是你可能是你的模块可能是

00:21:58.409 --> 00:22:02.940
在更大的应用程序中重复使用

00:22:00.750 --> 00:22:07.830
别人同样确定他们想要

00:22:02.940 --> 00:22:09.720
版本一，因此模块系统强制

00:22:07.830 --> 00:22:12.509
您为每个选择一个版本

00:22:09.720 --> 00:22:15.059
应用程序所需的模块

00:22:12.509 --> 00:22:17.570
 Photo Java中的模块，您需要

00:22:15.059 --> 00:22:21.059
模块名称而不是版本名称

00:22:17.570 --> 00:22:23.250
当编译器或运行时扫描

00:22:21.059 --> 00:22:25.649
系统映像或模块路径查找

00:22:23.250 --> 00:22:28.500
对于该命名模块，只有第一个

00:22:25.649 --> 00:22:30.720
找到那个名字的模块，所以

00:22:28.500 --> 00:22:34.440
就像是由工具来帮助您

00:22:30.720 --> 00:22:36.269
将软件包与模块关联起来

00:22:34.440 --> 00:22:39.090
工具也可以帮助您选择

00:22:36.269 --> 00:22:45.990
依赖的那个单一版本

00:22:39.090 --> 00:22:48.179
所以还有更多要说的

00:22:45.990 --> 00:22:50.100
如果我有时间，那会很多，但是

00:22:48.179 --> 00:22:52.200
现在要记住的是

00:22:50.100 --> 00:22:54.899
模块是一组用于

00:22:52.200 --> 00:22:57.779
重用它们提供强大的封装

00:22:54.899 --> 00:23:00.149
可靠的依赖关系和模块

00:22:57.779 --> 00:23:06.000
意识到工具将是

00:23:00.149 --> 00:23:10.169
模块化的开发经验感动

00:23:06.000 --> 00:23:12.659
快点让我们谈谈如何

00:23:10.169 --> 00:23:15.600
使用现有的应用程序并迁移

00:23:12.659 --> 00:23:18.659
现在将其添加到模块中，因为这是不可能的

00:23:15.600 --> 00:23:20.669
将Java生态系统全部模块化

00:23:18.659 --> 00:23:22.500
一旦我们将与一个

00:23:20.669 --> 00:23:25.529
模块化代码的组合

00:23:22.500 --> 00:23:27.720
模块路径上的模块化jar和非

00:23:25.529 --> 00:23:29.070
传统的罐子我的模块化代码

00:23:27.720 --> 00:23:30.600
不想打电话给他们，我不想

00:23:29.070 --> 00:23:34.379
称它们为旧罐子，它们只是罐子

00:23:30.600 --> 00:23:36.600
在类路径上一段时间可以

00:23:34.379 --> 00:23:38.700
而JDK 9提供了一些工具来简化

00:23:36.600 --> 00:23:41.970
这就是本节的迁移

00:23:38.700 --> 00:23:44.250
关于，所以我们将从一个简单的开始

00:23:41.970 --> 00:23:47.279
我们要从中迁移的应用程序

00:23:44.250 --> 00:23:49.139
核心的课堂路径有三个

00:23:47.279 --> 00:23:52.470
应用程序顶部的图层

00:23:49.139 --> 00:23:54.299
罐子可能不止一个

00:23:52.470 --> 00:23:57.360
因为你有很多包

00:23:54.299 --> 00:23:58.740
底部是JDK， 

00:23:57.360 --> 00:24:00.539
中间有一堆图书馆

00:23:58.740 --> 00:24:04.649
从互联网下载的罐子和

00:24:00.539 --> 00:24:06.809
现在我暗示了在类路径上抛出

00:24:04.649 --> 00:24:08.970
我们已经将JDK变成了模块

00:24:06.809 --> 00:24:09.350
在此部分，绿色框将

00:24:08.970 --> 00:24:11.990
代表

00:24:09.350 --> 00:24:14.210
您已经看过Java基础的模块

00:24:11.990 --> 00:24:15.950
而且您不会惊讶于学习

00:24:14.210 --> 00:24:19.010
还有用于记录的模块

00:24:15.950 --> 00:24:21.080
数据库访问XML处理Java 

00:24:19.010 --> 00:24:21.520
记录Java续集Java XML和许多

00:24:21.080 --> 00:24:24.230
更多

00:24:21.520 --> 00:24:26.600
但是我们的应用程序没有模块化

00:24:24.230 --> 00:24:29.120
而且我们也不应该使用任何图书馆

00:24:26.600 --> 00:24:31.039
监控应用程序的状态

00:24:29.120 --> 00:24:32.480
你可以在课堂上运行它

00:24:31.039 --> 00:24:34.250
像往常一样的道路

00:24:32.480 --> 00:24:38.120
吉达上课的路不会消失

00:24:34.250 --> 00:24:40.549
 k9，但我们将jdk模块化

00:24:38.120 --> 00:24:42.470
通过以下方式提高安全性的理由

00:24:40.549 --> 00:24:44.530
强大的封装性和稳定性

00:24:42.470 --> 00:24:46.880
通过可靠的依赖

00:24:44.530 --> 00:24:48.530
应用程序可能想从中受益

00:24:46.880 --> 00:24:50.809
就像jdk那样

00:24:48.530 --> 00:24:53.270
 jdk模块没什么特别的

00:24:50.809 --> 00:24:56.870
只是模块，所以让我们看看如何

00:24:53.270 --> 00:24:58.510
将此应用程序转换为模块

00:24:56.870 --> 00:25:02.000
想象应用程序在两个罐子里

00:24:58.510 --> 00:25:04.970
我的应用程序jar帮助程序代码中的主要代码

00:25:02.000 --> 00:25:07.490
我的lib jar，让我们也想像一下

00:25:04.970 --> 00:25:09.470
图书馆罐子的汤仅限于

00:25:07.490 --> 00:25:12.380
杰克逊JSON处理库

00:25:09.470 --> 00:25:14.750
杰克逊作为三个罐子的核心数据而来

00:25:12.380 --> 00:25:19.039
绑定和注释，我们有

00:25:14.750 --> 00:25:20.690
底部的模块化JDK这是如何

00:25:19.039 --> 00:25:22.520
我们今天要运行应用程序

00:25:20.690 --> 00:25:24.140
设置Lib目录以包括

00:25:22.520 --> 00:25:26.030
我们的应用程序jar和我们的库

00:25:24.140 --> 00:25:28.070
罐子指出了他们的课堂道路

00:25:26.030 --> 00:25:30.679
然后使用Java运行应用程序

00:25:28.070 --> 00:25:32.570
发射器之一，我们将获得的东西

00:25:30.679 --> 00:25:34.580
模块化不必列出

00:25:32.570 --> 00:25:37.820
命令行中的依赖项

00:25:34.580 --> 00:25:39.620
脚本，他们可以在其中输入错误

00:25:37.820 --> 00:25:43.789
直到发现很多错误

00:25:39.620 --> 00:25:46.820
稍后，让我们来看一个场景

00:25:43.789 --> 00:25:49.340
从上向下迁移此应用程序

00:25:46.820 --> 00:25:51.380
我们首先将应用程序jar模块化

00:25:49.340 --> 00:25:54.440
没有模块化

00:25:51.380 --> 00:25:55.940
现在，如果您在图书馆里

00:25:54.440 --> 00:25:58.640
取决于您使用的第三方库

00:25:55.940 --> 00:26:00.500
依靠它们进行模块化，我们

00:25:58.640 --> 00:26:02.750
可以使图书馆更容易

00:26:00.500 --> 00:26:05.419
模块化，但是通常我们都必须

00:26:02.750 --> 00:26:08.780
等待他们做，没有人可以强迫

00:26:05.419 --> 00:26:10.700
他们，所以很可能是一些

00:26:08.780 --> 00:26:14.539
您所依赖的库不是

00:26:10.700 --> 00:26:16.669
模块化，但现在可以了

00:26:14.539 --> 00:26:19.640
您可以控制应用程序的jar 

00:26:16.669 --> 00:26:21.430
显而易见的途径是将它们一对一

00:26:19.640 --> 00:26:23.080
放入模块化的罐子里

00:26:21.430 --> 00:26:25.090
每个罐子在照片中都有一个模块

00:26:23.080 --> 00:26:27.580
类文件并不总是可能的

00:26:25.090 --> 00:26:29.860
特别是如果罐子中的代码具有

00:26:27.580 --> 00:26:33.580
循环依赖，但让我们一起去吧

00:26:29.860 --> 00:26:36.610
现在，如果我们要把每个

00:26:33.580 --> 00:26:38.830
将应用程序jar放入模块化jar中

00:26:36.610 --> 00:26:42.010
需要在其中编写模块声明

00:26:38.830 --> 00:26:44.350
照片Java中的模块，名称为

00:26:42.010 --> 00:26:47.620
所需模块列表和

00:26:44.350 --> 00:26:50.500
导出的软件包的名称很容易

00:26:47.620 --> 00:26:54.070
我的解放后，我们还不知道

00:26:50.500 --> 00:26:56.380
每个模块取决于我们可以做什么

00:26:54.070 --> 00:26:57.790
手动分析源文件

00:26:56.380 --> 00:27:01.240
类文件，但是更容易

00:26:57.790 --> 00:27:04.330
 Jade EPS工具的方式Jade EPS 

00:27:01.240 --> 00:27:07.390
扫描类文件或jar文件并告诉

00:27:04.330 --> 00:27:09.640
您从其他jar文件中获得了哪些代码

00:27:07.390 --> 00:27:13.150
代码实际上取决于现在的Jade EPS 

00:27:09.640 --> 00:27:16.540
 JDK 8附带了一个改进的功能

00:27:13.150 --> 00:27:18.970
现在不是JDK 9中的版本

00:27:16.540 --> 00:27:22.150
完美的解决方案来了，这是一个

00:27:18.970 --> 00:27:24.940
很好的开始，所以我们将运行Jade Epps 

00:27:22.150 --> 00:27:26.350
在应用程序上的罐子杰克逊

00:27:24.940 --> 00:27:28.900
假设图书馆在课堂上

00:27:26.350 --> 00:27:31.570
路径在这里，我们看到我的应用程序罐

00:27:28.900 --> 00:27:33.400
取决于两个杰克逊罐子

00:27:31.570 --> 00:27:35.500
记住并且没有模块化，但这是

00:27:33.400 --> 00:27:38.350
只是看参考

00:27:35.500 --> 00:27:41.440
字节码，当然还有我的小罐子

00:27:38.350 --> 00:27:45.280
再加上我的app jar取决于JDK 

00:27:41.440 --> 00:27:48.670
 Java基础模块和Java续集说我的

00:27:45.280 --> 00:27:50.950
实时jar仅取决于Java基础，因此

00:27:48.670 --> 00:27:54.280
很好，很简单，现在我们可以写

00:27:50.950 --> 00:27:56.560
我们的模块声明让我们开始

00:27:54.280 --> 00:27:59.050
我库中的简单助手代码

00:27:56.560 --> 00:28:01.480
我们知道这取决于Java基础

00:27:59.050 --> 00:28:02.710
虽然我已经写了需要Java基础

00:28:01.480 --> 00:28:05.170
一直在串扰你

00:28:02.710 --> 00:28:07.180
不必总是为您放置

00:28:05.170 --> 00:28:09.190
由编译器，因为每个Java 

00:28:07.180 --> 00:28:11.350
程序最终依赖于java.lang 

00:28:09.190 --> 00:28:15.070
对象，所以您总是无法做到

00:28:11.350 --> 00:28:18.340
不需要Java基础和Jade 

00:28:15.070 --> 00:28:21.220
 EPS运行，我们知道我的应用程序罐

00:28:18.340 --> 00:28:23.020
如果我们跑翡翠，取决于我的嘴唇

00:28:21.220 --> 00:28:26.170
更多的选择，我们会看到

00:28:23.020 --> 00:28:29.620
特别是我的应用程式罐子需要特别

00:28:26.170 --> 00:28:32.710
打包在我的Lib中，现在我们可以写

00:28:29.620 --> 00:28:34.590
在此模块中导出软件包

00:28:32.710 --> 00:28:36.809
声明允许任何人

00:28:34.590 --> 00:28:39.480
访问软件包，但是如果我们确定的话

00:28:36.809 --> 00:28:43.289
除了我的应用程序之外，没有人需要

00:28:39.480 --> 00:28:45.240
访问我们可以使用合格的出口

00:28:43.289 --> 00:28:47.789
最大化封装来说明

00:28:45.240 --> 00:28:52.289
那里的包只导出到代码

00:28:47.789 --> 00:28:55.260
在我的应用程序中，让我们转到模块

00:28:52.289 --> 00:28:58.289
为我的应用程序声明它需要我的

00:28:55.260 --> 00:29:00.750
 lib并不奇怪，还有一些JDK模块和

00:28:58.289 --> 00:29:02.610
我们知道它将使用杰克逊，但

00:29:00.750 --> 00:29:04.230
我们还不确定如何编写

00:29:02.610 --> 00:29:07.620
需要指令，因为它们不是

00:29:04.230 --> 00:29:09.960
模块，但这并不意味着我们

00:29:07.620 --> 00:29:11.820
意味着你必须把杰克逊变成

00:29:09.960 --> 00:29:13.529
模块，然后才能写这篇

00:29:11.820 --> 00:29:16.440
不幸的宣言

00:29:13.529 --> 00:29:20.909
因为我们你不控制杰克逊

00:29:16.440 --> 00:29:22.980
如果只有某种方式可以保存jar文件

00:29:20.909 --> 00:29:25.710
杰克逊的jar文件以某种方式成为

00:29:22.980 --> 00:29:28.679
模块自动看起来绿色

00:29:25.710 --> 00:29:30.029
他们要走了，我们不知道我们没有

00:29:28.679 --> 00:29:31.740
写杰克逊，我们不知道他们是什么

00:29:30.029 --> 00:29:32.700
依赖和出口将是但我们

00:29:31.740 --> 00:29:34.260
对什么有一个很好的主意

00:29:32.700 --> 00:29:39.240
名称将基本上是

00:29:34.260 --> 00:29:41.760
如果可以的话，与罐子的名字相同

00:29:39.240 --> 00:29:44.130
我们可以完成模块的编写

00:29:41.760 --> 00:29:48.750
我的应用声明幸福的表情

00:29:44.130 --> 00:29:50.789
这些需要指令，我们会有一个

00:29:48.750 --> 00:29:53.399
我的应用程序的可爱模块图

00:29:50.789 --> 00:29:55.559
取决于我的lib和杰克逊·科伦

00:29:53.399 --> 00:30:01.340
杰克逊数据绑定和Java基础和Java 

00:29:55.559 --> 00:30:01.340
续集和我的Lib取决于Java基础

00:30:01.370 --> 00:30:07.260
好消息是我们可以做到这一点

00:30:03.720 --> 00:30:10.110
带有自动模块

00:30:07.260 --> 00:30:13.649
 module是其声明为

00:30:10.110 --> 00:30:16.919
由模块系统从

00:30:13.649 --> 00:30:20.850
您放在的传统广口瓶

00:30:16.919 --> 00:30:22.710
它们是真实的转换模块路径

00:30:20.850 --> 00:30:25.140
模块在那里，他们真的在那里

00:30:22.710 --> 00:30:26.309
运行时，您不需要更改jar文件

00:30:25.140 --> 00:30:28.260
可以让您获得足够的收益

00:30:26.309 --> 00:30:29.909
以任何方式更改jar文件，因为

00:30:28.260 --> 00:30:33.240
你对它一无所知

00:30:29.909 --> 00:30:34.980
做一个自动的模块名称

00:30:33.240 --> 00:30:37.409
您需要的模块派生自

00:30:34.980 --> 00:30:39.149
 jar文件名，它导出所有这一切

00:30:37.409 --> 00:30:44.280
包，它需要所有其他

00:30:39.149 --> 00:30:48.029
有效模块是指自动模块

00:30:44.280 --> 00:30:53.099
今天的罐子已经是明天了

00:30:48.029 --> 00:30:55.889
模块现在是一次自动模块

00:30:53.099 --> 00:30:57.389
杰克逊核心的存在

00:30:55.889 --> 00:30:59.129
杰克逊数据绑定和杰克逊

00:30:57.389 --> 00:31:01.889
注解，因为您移动了

00:30:59.129 --> 00:31:03.929
模块上的那些jar路径

00:31:01.889 --> 00:31:06.149
图看起来很不一样，因为

00:31:03.929 --> 00:31:08.969
自动模块基本上说要求

00:31:06.149 --> 00:31:11.070
他们彼此需要的一切

00:31:08.969 --> 00:31:13.769
需要JDK映像中的所有模块

00:31:11.070 --> 00:31:15.690
他们需要您所有的模块

00:31:13.769 --> 00:31:17.639
好，他们探索了他们所有的包裹

00:31:15.690 --> 00:31:19.830
现在这可能不是

00:31:17.639 --> 00:31:21.570
要求并出口杰克逊

00:31:19.830 --> 00:31:24.330
维护者x'会用手写um 

00:31:21.570 --> 00:31:25.739
但这实际上是自动方式

00:31:24.330 --> 00:31:28.799
模块这样做是功能而非错误

00:31:25.739 --> 00:31:32.129
因为它模仿了

00:31:28.799 --> 00:31:35.429
它提供了最大的类路径

00:31:32.129 --> 00:31:38.759
可能的代码兼容性表面

00:31:35.429 --> 00:31:40.559
在jar文件中，实际上更好

00:31:38.759 --> 00:31:42.479
比起一切都在罐子上

00:31:40.559 --> 00:31:45.440
例如，您必须查看类路径

00:31:42.479 --> 00:31:49.979
小心地，我的库里没有箭

00:31:45.440 --> 00:31:52.679
到我的应用程序，因此没有助手的危险

00:31:49.979 --> 00:31:55.409
 Lib中的代码意外到达

00:31:52.679 --> 00:31:57.629
进入我在类路径中的应用程序内部

00:31:55.409 --> 00:31:59.759
我的实时jar中的代码可以访问以下代码

00:31:57.629 --> 00:32:01.499
我的应用程式点罐我的嘴唇点罐

00:31:59.759 --> 00:32:03.899
轻松访问我的光圈中的代码

00:32:01.499 --> 00:32:05.519
甚至根本不知道

00:32:03.899 --> 00:32:08.369
导致维护头痛

00:32:05.519 --> 00:32:08.700
现在你可能认为我们可以做到

00:32:08.369 --> 00:32:10.950
更好

00:32:08.700 --> 00:32:13.019
也许模块系统可以运行Jade 

00:32:10.950 --> 00:32:15.719
杰克逊罐子在启动时的EPS 

00:32:13.019 --> 00:32:18.839
尝试找出Jax的哪些模块

00:32:15.719 --> 00:32:20.549
和罐子需要这个

00:32:18.839 --> 00:32:22.739
真的没有帮助，原因是

00:32:20.549 --> 00:32:25.080
像杰克逊这样的图书馆经常利用

00:32:22.739 --> 00:32:28.349
核心反射java.lang反射

00:32:25.080 --> 00:32:31.950
用于检查应用程序类的API 

00:32:28.349 --> 00:32:33.929
可以动态看到Jade EPS的使用

00:32:31.950 --> 00:32:36.450
核心反射，但无法预测

00:32:33.929 --> 00:32:39.629
静态将是什么类

00:32:36.450 --> 00:32:41.399
动态检查，实际上

00:32:39.629 --> 00:32:43.440
 Jackson Beta绑定模块的功能完全一样

00:32:41.399 --> 00:32:45.299
这种思考将

00:32:43.440 --> 00:32:48.239
在您的所有应用程序类中扩展

00:32:45.299 --> 00:32:51.809
这样它就可以在它们和JSON之间转换

00:32:48.239 --> 00:32:54.509
文档，如果我的应用程序具有

00:32:51.809 --> 00:32:56.879
它想要Jax和数据绑定

00:32:54.509 --> 00:32:59.759
想要说Jax和

00:32:56.879 --> 00:33:00.750
数据绑定需要我的应用程序众多

00:32:59.759 --> 00:33:02.850
其他事情

00:33:00.750 --> 00:33:09.600
这正是自动模块

00:33:02.850 --> 00:33:12.300
给你代码时的另一皱纹

00:33:09.600 --> 00:33:15.060
那是杰克逊走向我的

00:33:12.300 --> 00:33:19.050
应用程式中的程式码呼叫

00:33:15.060 --> 00:33:23.100
 Jackson API通过自己的类

00:33:19.050 --> 00:33:25.650
那里的对象是最右边的

00:33:23.100 --> 00:33:28.620
目的是Jackson数据绑定可以

00:33:25.650 --> 00:33:31.380
创建该应用程序的实例

00:33:28.620 --> 00:33:33.840
分类我的价值，然后反思地设定

00:33:31.380 --> 00:33:35.970
此值的名称和年龄字段

00:33:33.840 --> 00:33:40.200
基于此内容的实例

00:33:35.970 --> 00:33:42.690
这里是JSON文档，但是此代码

00:33:40.200 --> 00:33:46.500
之所以失败，是因为我们从来没有到过

00:33:42.690 --> 00:33:49.860
说我的应用程序输出到Jackson的内容

00:33:46.500 --> 00:33:52.020
现在数据绑定在某种意义上是

00:33:49.860 --> 00:33:54.390
温柔，因为我的应用程序不是真的

00:33:52.020 --> 00:33:56.760
有一个API，它是一个应用程序，但是如果

00:33:54.390 --> 00:33:59.780
它想让杰克逊操纵

00:33:56.760 --> 00:34:02.580
通过反射查看其类的实例

00:33:59.780 --> 00:34:05.340
那么我的应用仍然需要导出一些

00:34:02.580 --> 00:34:07.140
适用于强封装的软件包

00:34:05.340 --> 00:34:09.870
不仅是来自一个模块的参考

00:34:07.140 --> 00:34:13.409
转向另一个编译时间

00:34:09.870 --> 00:34:15.870
用于在运行时进行反射访问

00:34:13.409 --> 00:34:18.570
然后模块不导出包

00:34:15.870 --> 00:34:22.830
其他模块中的代码无法检查

00:34:18.570 --> 00:34:26.129
通过反射的类现在是反射的

00:34:22.830 --> 00:34:29.190
应用程序代码之间的关系

00:34:26.129 --> 00:34:31.710
和库代码是常见的应用

00:34:29.190 --> 00:34:33.929
容器可能会遍历类

00:34:31.710 --> 00:34:36.540
找到要公开的注释方法

00:34:33.929 --> 00:34:38.370
端点依赖注入

00:34:36.540 --> 00:34:41.159
框架将调用您的方法

00:34:38.370 --> 00:34:43.379
反思性序列化框架

00:34:41.159 --> 00:34:46.800
将反思地创建和修改

00:34:43.379 --> 00:34:49.710
您的课程实例很多

00:34:46.800 --> 00:34:51.300
应用程序使用这些功能

00:34:49.710 --> 00:34:53.850
为了他们工作，我们不知何故

00:34:51.300 --> 00:34:57.420
暴露否则封装

00:34:53.850 --> 00:34:59.250
现在通过反射的应用程序类

00:34:57.420 --> 00:35:01.320
我们可以通过导出

00:34:59.250 --> 00:35:03.840
应用程序包，但有一个

00:35:01.320 --> 00:35:07.920
具体的细粒度机制

00:35:03.840 --> 00:35:09.270
通过反射访问该机制

00:35:07.920 --> 00:35:12.220
是开放的

00:35:09.270 --> 00:35:14.440
指令，所以我们说我们的域名

00:35:12.220 --> 00:35:17.349
像我的价值观这样的课程在这个通讯中

00:35:14.440 --> 00:35:20.740
我的应用程序域包中，我们可以打开它

00:35:17.349 --> 00:35:23.740
打包以通过反射访问

00:35:20.740 --> 00:35:26.369
所有模块，否则我们可以限定空缺

00:35:23.740 --> 00:35:30.300
就像我们以前做出口一样

00:35:26.369 --> 00:35:34.510
打开包装更窄更深

00:35:30.300 --> 00:35:38.260
比出口包裹要窄

00:35:34.510 --> 00:35:38.859
因为打开只会在

00:35:38.260 --> 00:35:41.560
运行

00:35:38.859 --> 00:35:46.000
而出口在编译时适用

00:35:41.560 --> 00:35:49.420
和运行时，但更深入，因为开放

00:35:46.000 --> 00:35:51.300
允许该包的所有元素

00:35:49.420 --> 00:35:54.790
通过反射访问

00:35:51.300 --> 00:35:59.500
而出口只允许反射

00:35:54.790 --> 00:36:01.510
访问公共元素

00:35:59.500 --> 00:36:06.180
使用起来比解释起来简单得多

00:36:01.510 --> 00:36:08.190
我们可以采取其他一些方式

00:36:06.180 --> 00:36:11.070
而不是打开一个方向

00:36:08.190 --> 00:36:14.280
可以反思的特定包装

00:36:11.070 --> 00:36:17.670
打开我们的所有我的应用程序包

00:36:14.280 --> 00:36:20.390
您宣布自己的任何人的反思

00:36:17.670 --> 00:36:23.700
可以将我的应用声明为开放模块

00:36:20.390 --> 00:36:25.470
开放式模块为您带来一半的好处

00:36:23.700 --> 00:36:27.510
模块化，您将获得可靠

00:36:25.470 --> 00:36:29.970
依赖所有require子句

00:36:27.510 --> 00:36:32.450
将在编译时解决，并且

00:36:29.970 --> 00:36:35.220
运行时，但封装不强

00:36:32.450 --> 00:36:37.650
因为任何人都可以反映自己的方式

00:36:35.220 --> 00:36:41.640
进入私人领域和方法

00:36:37.650 --> 00:36:44.070
我的应用程序，但由于框架反映了

00:36:41.640 --> 00:36:46.520
深入应用程序代码是

00:36:44.070 --> 00:36:49.050
日常Java开发中的现实

00:36:46.520 --> 00:36:51.180
应用程序代码不能总是

00:36:49.050 --> 00:36:53.370
高度封装和开放的模块

00:36:51.180 --> 00:36:56.040
我们认为这是一个务实的解决方案

00:36:53.370 --> 00:36:59.520
取决于应用程序的开发者

00:36:56.040 --> 00:37:01.650
选择注意，此打开模块

00:36:59.520 --> 00:37:04.830
不会，但是打开的模块仍可以使用

00:37:01.650 --> 00:37:08.550
推断模块中的导出指令

00:37:04.830 --> 00:37:13.860
 Java定义和静态API 

00:37:08.550 --> 00:37:15.540
在编译时使用，现在我们可以运行

00:37:13.860 --> 00:37:18.510
我们的模块化应用程序

00:37:15.540 --> 00:37:21.450
调用假定我们的模块化罐子

00:37:18.510 --> 00:37:25.410
那是我的应用程序罐，我的库是和

00:37:21.450 --> 00:37:28.680
现在处于EM lip和未更改的Jaxon中

00:37:25.410 --> 00:37:31.170
罐子仍在库中，我们只需要

00:37:28.680 --> 00:37:33.570
告诉Java启动器模块在哪里

00:37:31.170 --> 00:37:36.180
应该设置通行证，它将计算

00:37:33.570 --> 00:37:40.220
找出模块路径中的哪个jar 

00:37:36.180 --> 00:37:40.220
应该变成自动模块

00:37:40.580 --> 00:37:47.160
因此，当您迁移每个应用程序jar时

00:37:45.300 --> 00:37:50.760
通常是一个很好的候选人

00:37:47.160 --> 00:37:54.210
每个库jar的模块迁移

00:37:50.760 --> 00:37:57.480
自己的节奏和自动模块意味着

00:37:54.210 --> 00:38:01.820
您不是在等待最薄弱的环节

00:37:57.480 --> 00:38:05.390
那很可悲，我们必须这样做

00:38:01.820 --> 00:38:14.150
几乎在那里，我们来谈谈

00:38:05.390 --> 00:38:17.270
 JDK大致来说

00:38:14.150 --> 00:38:21.020
 Java平台已经跟上了

00:38:17.270 --> 00:38:24.200
主要版本号Java的平方

00:38:21.020 --> 00:38:28.010
 1.0只有几百个Java类

00:38:24.200 --> 00:38:31.610
 9是数以万计的JDK 1.0 

00:38:28.010 --> 00:38:35.960
下载它仍然安装并且没有7 

00:38:31.610 --> 00:38:37.390
在4 Meg以下时，JDK 9下载是一个

00:38:35.960 --> 00:38:40.910
一百五十兆

00:38:37.390 --> 00:38:43.670
现在，当Java平台很小时， 

00:38:40.910 --> 00:38:46.400
 JDK代码的组织不是一个

00:38:43.670 --> 00:38:48.410
问题，但平台每年都在增长

00:38:46.400 --> 00:38:51.860
更大一点，现在又很大了

00:38:48.410 --> 00:38:54.890
实际上是Java平台的整体式

00:38:51.860 --> 00:38:57.260
不是一回事，更像是25 

00:38:54.890 --> 00:38:59.480
单独的框架，包括秋千

00:38:57.260 --> 00:39:01.550
 UI框架crypto框架

00:38:59.480 --> 00:39:03.620
脚本框架多XML 

00:39:01.550 --> 00:39:05.540
处理框架等等

00:39:03.620 --> 00:39:07.670
这些单独的框架没有理由

00:39:05.540 --> 00:39:11.240
在一次下载中紧密结合

00:39:07.670 --> 00:39:13.580
实际上，这对我们来说是一个障碍

00:39:11.240 --> 00:39:16.820
开发过紧的JDK 

00:39:13.580 --> 00:39:19.160
耦合提高了开发和测试

00:39:16.820 --> 00:39:22.700
成本使平台变慢

00:39:19.160 --> 00:39:25.220
演化加上更大的表面

00:39:22.700 --> 00:39:28.580
您的平台更困难

00:39:25.220 --> 00:39:30.500
安全，这是很多障碍

00:39:28.580 --> 00:39:32.540
用户都想要运行他们的

00:39:30.500 --> 00:39:35.330
较小设备上的应用程序以及

00:39:32.540 --> 00:39:38.480
那些想要运行更多实例的

00:39:35.330 --> 00:39:40.700
它们在大型系统上的应用

00:39:38.480 --> 00:39:43.690
如果您只想要JDK的一部分

00:39:40.700 --> 00:39:46.940
你必须全部拿走

00:39:43.690 --> 00:39:50.720
好消息当然是JDK 9是

00:39:46.940 --> 00:39:53.420
模块化，我们采用了单片RT 

00:39:50.720 --> 00:39:56.360
 jar文件并将其分解为几个

00:39:53.420 --> 00:39:59.210
十几个模块，其中一些是其中的一部分

00:39:56.360 --> 00:40:02.360
 Java SE规范只是

00:39:59.210 --> 00:40:05.990
只是JDK实现的一部分

00:40:02.360 --> 00:40:07.490
这是我们的Java SE模块的图形

00:40:05.990 --> 00:40:10.130
可以看到底部有Java基础

00:40:07.490 --> 00:40:13.400
一切都取决于哪个

00:40:10.130 --> 00:40:15.170
依靠什么本身我们都没有打破

00:40:13.400 --> 00:40:17.600
将各种框架

00:40:15.170 --> 00:40:18.430
自己的模块检测日志记录XML 

00:40:17.600 --> 00:40:22.150
脚本编写

00:40:18.430 --> 00:40:26.829
您可以根据需要使用等

00:40:22.150 --> 00:40:29.859
根据您的需求在顶部

00:40:26.829 --> 00:40:32.980
没有实际的Java SE模块

00:40:29.859 --> 00:40:35.829
其中的代码，但只有依赖关系

00:40:32.980 --> 00:40:37.420
您可以说需要Java SE并且

00:40:35.829 --> 00:40:41.319
保证拥有所有这些模块

00:40:37.420 --> 00:40:43.569
值得一提的是

00:40:41.319 --> 00:40:46.329
仅找到这些模块边界

00:40:43.569 --> 00:40:48.450
在事后看来这可能是显而易见的

00:40:46.329 --> 00:40:51.579
他们付出了巨大的工程努力

00:40:48.450 --> 00:40:53.829
解耦整体要困难得多

00:40:51.579 --> 00:40:56.049
比建立一个解耦的系统

00:40:53.829 --> 00:40:58.480
我们不得不撤消多年的开始

00:40:56.049 --> 00:41:02.829
错误的假设和偶然的耦合

00:40:58.480 --> 00:41:05.109
在我们的茶缸里，但是向前

00:41:02.829 --> 00:41:07.869
模块系统施加的纪律

00:41:05.109 --> 00:41:10.990
可以防止我们意外

00:41:07.869 --> 00:41:15.539
滑回一个大泥球我

00:41:10.990 --> 00:41:17.589
意味着整体之间的区别

00:41:15.539 --> 00:41:18.700
实线和虚线是

00:41:17.589 --> 00:41:23.680
我们应该讨论的好问题

00:41:18.700 --> 00:41:26.109
后来的Java SE模块实际上是

00:41:23.680 --> 00:41:29.650
您会发现模块的一小部分

00:41:26.109 --> 00:41:32.230
如果您使用Java，则在JDK 9系统映像中

00:41:29.650 --> 00:41:35.049
 --列出模块，您将看到这两个模块

00:41:32.230 --> 00:41:37.809
 Java SE模块中的十几个Java 

00:41:35.049 --> 00:41:40.150
基于续集测井等，以及一些

00:41:37.809 --> 00:41:44.410
 Java FX模块，然后大量

00:41:40.150 --> 00:41:47.650
 JDK特定模块的说明JDK编译器JDK 

00:41:44.410 --> 00:41:49.809
 Java文档专用J Shell JDK Jade EPS 

00:41:47.650 --> 00:41:52.329
是自己的模块，Jade EPS工具是

00:41:49.809 --> 00:41:55.089
列在中间，依此类推

00:41:52.329 --> 00:41:57.069
它们都位于系统映像中

00:41:55.089 --> 00:41:59.049
但除此之外，他们只是

00:41:57.069 --> 00:42:03.700
带有require和的普通模块

00:41:59.049 --> 00:42:05.559
出口指令就像我想要的其他任何指令一样

00:42:03.700 --> 00:42:08.920
我喜欢花一些时间

00:42:05.559 --> 00:42:14.140
期望的剩余时间

00:42:08.920 --> 00:42:16.240
适用于JDK 9的兼容性

00:42:14.140 --> 00:42:17.529
每个人都在这里，这不是因为

00:42:16.240 --> 00:42:21.309
你不是那些一定

00:42:17.529 --> 00:42:22.720
依靠其中一些东西，但是

00:42:21.309 --> 00:42:26.859
值得每个人了解什么

00:42:22.720 --> 00:42:30.339
在这里进行一些其他base64编码

00:42:26.859 --> 00:42:31.609
和一些其他的base64解码器可以执行任何操作

00:42:30.339 --> 00:42:33.859
使用它们

00:42:31.609 --> 00:42:35.329
哦，这更是我所期待的

00:42:33.859 --> 00:42:37.130
我要说的手不过是

00:42:35.329 --> 00:42:40.339
您的图书馆确实可以，但是那些

00:42:37.130 --> 00:42:42.440
 JDK 9中没有类，但不是

00:42:40.339 --> 00:42:44.539
高度封装，它们在物理上

00:42:42.440 --> 00:42:47.749
不在那里，所以遇到这个可能会破坏

00:42:44.539 --> 00:42:50.089
您使用的某些库

00:42:47.749 --> 00:42:52.369
向库维护者提交错误

00:42:50.089 --> 00:42:58.660
并告诉他们使用优秀的

00:42:52.369 --> 00:43:02.269
 JDK中引入的base64类8秒

00:42:58.660 --> 00:43:05.509
谁用一些安全的小姐枪

00:43:02.269 --> 00:43:08.450
是不同的手好吗，所以有些神秘

00:43:05.509 --> 00:43:12.200
安全未消失太阳杂项

00:43:08.450 --> 00:43:14.359
包由JDK模块导出到

00:43:12.200 --> 00:43:18.829
手扶和不安全等级

00:43:14.359 --> 00:43:22.430
还在，但是当太阳

00:43:18.829 --> 00:43:25.549
 misc包导出了许多JDK 

00:43:22.430 --> 00:43:27.109
内部软件包不是一次又一次

00:43:25.549 --> 00:43:29.239
可能会破坏您使用的某些库

00:43:27.109 --> 00:43:32.359
因为如果库代码失败

00:43:29.239 --> 00:43:35.509
尝试访问隐藏的类

00:43:32.359 --> 00:43:37.699
打包通用的加密Sun提供商或

00:43:35.509 --> 00:43:41.630
逗号Sun或补丁是X YZ内部

00:43:37.699 --> 00:43:43.969
 Jax P或Sun nioh CH或Sun net www或

00:43:41.630 --> 00:43:46.190
 Sun反映注释或某些安全性

00:43:43.969 --> 00:43:48.109
 x.509，你们大多数人都不在乎

00:43:46.190 --> 00:43:54.019
这些软件包中的任何一个，但

00:43:48.109 --> 00:43:57.680
确实有问题，最后我们需要

00:43:54.019 --> 00:44:01.449
再谈出口出口

00:43:57.680 --> 00:44:04.039
软件包意味着您可以编译和运行

00:44:01.449 --> 00:44:07.449
反对公众

00:44:04.039 --> 00:44:10.519
该包的类是一个API 

00:44:07.449 --> 00:44:12.499
从Java导出软件包

00:44:10.519 --> 00:44:15.829
安装的JDK模块或从您的模块

00:44:12.499 --> 00:44:18.920
不是要让库代码使用

00:44:15.829 --> 00:44:20.839
反射访问私有元素，如果

00:44:18.920 --> 00:44:24.949
你还记得那是一个开放的模块

00:44:20.839 --> 00:44:30.979
允许，但没有JDK模块

00:44:24.949 --> 00:44:33.680
打开让我给你举个Java的例子

00:44:30.979 --> 00:44:37.400
基于模块的模块会导出一个名为

00:44:33.680 --> 00:44:40.609
 Java点安全性包含

00:44:37.400 --> 00:44:42.859
称为密钥库的公共类

00:44:40.609 --> 00:44:44.810
当我找到自己的班级时

00:44:42.859 --> 00:44:47.240
指针

00:44:44.810 --> 00:44:50.450
这个课程的目的是

00:44:47.240 --> 00:44:54.560
密码存储设备

00:44:50.450 --> 00:44:58.850
密钥和证书（如果有） 

00:44:54.560 --> 00:45:01.550
 API中的公共类，其私有

00:44:58.850 --> 00:45:06.320
字段应严格封装

00:45:01.550 --> 00:45:10.220
这是一口井，这里是一堆

00:45:06.320 --> 00:45:13.640
从2016年7月开始有人溢出问题

00:45:10.220 --> 00:45:16.190
这是在JDK 8上使用反射来

00:45:13.640 --> 00:45:19.310
访问密钥库中的私有字段

00:45:16.190 --> 00:45:21.410
上课，不仅这个人感到

00:45:19.310 --> 00:45:24.980
免费反映主要商店

00:45:21.410 --> 00:45:27.620
他们实际上在什么时候惹恼了内部人员

00:45:24.980 --> 00:45:30.710
内部结构在JDK中已更改

00:45:27.620 --> 00:45:34.430
更新JDK 8更新Java安全性

00:45:30.710 --> 00:45:37.190
 JDK 9中的软件包已导出，因此您可以

00:45:34.430 --> 00:45:38.810
针对密钥库api的代码并非如此

00:45:37.190 --> 00:45:41.270
您可以反映在关键商店

00:45:38.810 --> 00:45:43.790
内部因素是我们认为的原因之一

00:45:41.270 --> 00:45:46.910
强大的封装是如此重要

00:45:43.790 --> 00:45:49.580
它将使我们进一步发展JDK 

00:45:46.910 --> 00:45:52.330
快速可靠，因为我们都知道

00:45:49.580 --> 00:45:56.210
没有人可以依靠未指定的

00:45:52.330 --> 00:45:57.950
不幸的是实施细节

00:45:56.210 --> 00:45:59.420
当然有这个人的

00:45:57.950 --> 00:46:00.920
基本上写一个图书馆

00:45:59.420 --> 00:46:04.220
库代码在那里

00:46:00.920 --> 00:46:05.990
多年来一直依靠这些细节

00:46:04.220 --> 00:46:08.120
会有一些迁移的痛苦

00:46:05.990 --> 00:46:09.950
这些库和

00:46:08.120 --> 00:46:12.950
依赖这些的应用程序

00:46:09.950 --> 00:46:15.260
图书馆，如果这发生在你的hap 

00:46:12.950 --> 00:46:19.610
领事再请提交一个错误

00:46:15.260 --> 00:46:22.070
终于有了图书馆维修

00:46:19.610 --> 00:46:24.920
最后我再次想让你

00:46:22.070 --> 00:46:27.170
意识到

00:46:24.920 --> 00:46:28.730
对JDK进行了大修，然后再次进行

00:46:27.170 --> 00:46:31.070
可能不会影响您，但可能

00:46:28.730 --> 00:46:33.440
影响您依赖的库和工具

00:46:31.070 --> 00:46:35.810
在假定有文件的代码上

00:46:33.440 --> 00:46:39.070
在一个叫做RTO Jarl的工具罐中

00:46:35.810 --> 00:46:43.160
特定目录在JDK 9上将失败

00:46:39.070 --> 00:46:45.980
尝试使用以下命令修补JDK的脚本： 

00:46:43.160 --> 00:46:49.760
 X蓝色类路径斜线P将失败

00:46:45.980 --> 00:46:52.820
假定应用程序的JDK 9代码

00:46:49.760 --> 00:46:57.080
类加载器是一个URL类加载器

00:46:52.820 --> 00:46:59.290
在假定所有JDK的JDK 9代码上失败

00:46:57.080 --> 00:47:04.090
类由

00:46:59.290 --> 00:47:05.710
带加载程序将在JDK 9代码上失败

00:47:04.090 --> 00:47:08.590
假设版本字符串

00:47:05.710 --> 00:47:13.750
系统属性报告的开头是

00:47:08.590 --> 00:47:15.780
如果您在JDK 9上再打一个点， 

00:47:13.750 --> 00:47:19.690
看到由于这些原因导致库失败

00:47:15.780 --> 00:47:21.900
关于永不记录的假设

00:47:19.690 --> 00:47:25.030
指定从未标准化

00:47:21.900 --> 00:47:29.980
实施细节文件中的错误

00:47:25.030 --> 00:47:32.710
库维护，因此模块化

00:47:29.980 --> 00:47:35.680
 JDK一直是一些模块

00:47:32.710 --> 00:47:38.950
 misc导出了JDK内部软件包

00:47:35.680 --> 00:47:46.240
不是，要提防图书馆依赖

00:47:38.950 --> 00:47:48.900
在JDK 9的JDK内部上，一个模块是

00:47:46.240 --> 00:47:51.610
一组旨在重用的软件包

00:47:48.900 --> 00:47:56.590
自动模块有助于迁移

00:47:51.610 --> 00:47:59.800
库和模块，JDK可以

00:47:56.590 --> 00:48:02.560
发展得更快，更可靠，但

00:47:59.800 --> 00:48:09.160
流行的库和工具不是

00:48:02.560 --> 00:48:11.470
但都与2中的JDK 9兼容

00:48:09.160 --> 00:48:12.610
网络剩余分钟数

00:48:11.470 --> 00:48:16.150
最后两张幻灯片和所有

00:48:12.610 --> 00:48:17.830
问题是我需要承认

00:48:16.150 --> 00:48:19.900
模块中有很多

00:48:17.830 --> 00:48:22.990
我没时间说话的系统

00:48:19.900 --> 00:48:25.630
关于您可以将资源封装在

00:48:22.990 --> 00:48:27.610
您可以表达的模块最大类别

00:48:25.630 --> 00:48:30.040
通过编程的可选依赖项

00:48:27.610 --> 00:48:33.040
通过服务您可以自定义

00:48:30.040 --> 00:48:35.830
使用j-link工具制作系统映像

00:48:33.040 --> 00:48:39.040
您可以立即删除CORBA 

00:48:35.830 --> 00:48:41.730
实际上，您可以旋转多个

00:48:39.040 --> 00:48:44.440
带有层API的模块的版本

00:48:41.730 --> 00:48:47.260
如果您对此感兴趣

00:48:44.440 --> 00:48:50.410
它推荐两本书的第一本

00:48:47.260 --> 00:48:52.660
 Java 9模块化现在早已面世

00:48:50.410 --> 00:48:55.240
访问表格，这是非常务实的

00:48:52.660 --> 00:48:58.930
整个模块系统的演练

00:48:55.240 --> 00:49:01.360
和模块化的JDK，另一本书是

00:48:58.930 --> 00:49:04.090
 2012年以来的Java应用程序架构

00:49:01.360 --> 00:49:07.090
这是构建的原则

00:49:04.090 --> 00:49:09.430
它说我是模块化应用程序

00:49:07.090 --> 00:49:11.300
加入了标题，这不是特定的

00:49:09.430 --> 00:49:13.160
真正适用于任何模块系统

00:49:11.300 --> 00:49:15.050
它有很多非常非常好的建议

00:49:13.160 --> 00:49:17.000
无论您使用的是

00:49:15.050 --> 00:49:19.190
模块系统还是仅仅依靠

00:49:17.000 --> 00:49:23.540
关于如何构造的传统罐子

00:49:19.190 --> 00:49:25.910
一个应用程序，所以你可以做到最好

00:49:23.540 --> 00:49:28.660
为jdk 9做准备是下载

00:49:25.910 --> 00:49:32.390
抢先体验二进制文件有没有做过

00:49:28.660 --> 00:49:35.540
一些手好吗，如果谢谢你

00:49:32.390 --> 00:49:38.330
您是这些维护人员的图书馆维护者

00:49:35.540 --> 00:49:40.700
深入了解您的JDK内部结构

00:49:38.330 --> 00:49:43.630
依靠您现在就可以在JDK上执行此操作

00:49:40.700 --> 00:49:45.680
 8将对JDK AIDS起作用

00:49:43.630 --> 00:49:49.250
您曾经想知道的一切

00:49:45.680 --> 00:49:53.599
公开讨论模块系统

00:49:49.250 --> 00:49:55.910
喷气飞机261中的JDK我无法强调

00:49:53.599 --> 00:50:00.140
多少有价值的信息生活在其中

00:49:55.910 --> 00:50:03.020
射流261还有射流260 

00:50:00.140 --> 00:50:05.869
标识JDK内部类，例如

00:50:03.020 --> 00:50:09.830
一些暴露在其中的枪支小姐保险柜

00:50:05.869 --> 00:50:13.970
新定义的JDK 9 jet 223 

00:50:09.830 --> 00:50:16.940
版本字符串开始于9点并喷射

00:50:13.970 --> 00:50:17.619
 220描述了RT jar的运行方式

00:50:16.940 --> 00:50:21.349
远

00:50:17.619 --> 00:50:23.930
最后喷气200提供了一个概述

00:50:21.349 --> 00:50:26.000
 JDK模块，但如果您已经阅读过

00:50:23.930 --> 00:50:27.920
喷射261，这应该是因为它非常

00:50:26.000 --> 00:50:30.050
好，不会有任何惊喜， 

00:50:27.920 --> 00:50:37.580
正是那个时候，谢谢

00:50:30.050 --> 00:50:40.609
非常多，所以我们现在有消极的时间

00:50:37.580 --> 00:50:42.140
提出问题，所以我们都欢迎您

00:50:40.609 --> 00:50:44.950
有人早些时候有一个问题

00:50:42.140 --> 00:50:44.950
快做

00:51:03.930 --> 00:51:08.760
吉达k-8上的罐子版本

00:51:06.270 --> 00:51:12.360
您通常会在

00:51:08.760 --> 00:51:14.730
可以继续使用的软件包

00:51:12.360 --> 00:51:16.320
 jar文件在类路径和

00:51:14.730 --> 00:51:18.540
模块路径上的模块化jar文件

00:51:16.320 --> 00:51:20.280
没有什么比这更好的了

00:51:18.540 --> 00:51:23.880
特殊性全在模块信息中

00:51:20.280 --> 00:51:25.800
点类文件的内容

00:51:23.880 --> 00:51:30.860
模块，如果它们实际上包含

00:51:25.800 --> 00:51:30.860
重命名可以重新打包单词包

00:51:32.420 --> 00:51:39.480
如果您有阴影的话

00:51:36.960 --> 00:51:41.310
包并重命名，即使它是

00:51:39.480 --> 00:51:44.460
出口有不同

00:51:41.310 --> 00:51:56.040
他们是不同的班级

00:51:44.460 --> 00:51:57.210
问题，你有一个问题，嘿，怎么

00:51:56.040 --> 00:52:00.300
你测试不是

00:51:57.210 --> 00:52:02.700
出口那里是这是一个

00:52:00.300 --> 00:52:04.950
说话本身就是简短的答案

00:52:02.700 --> 00:52:08.100
是修补类的命令行标志

00:52:04.950 --> 00:52:10.200
进入模块，以便您可以访问

00:52:08.100 --> 00:52:12.720
内部部件GEB 261具有所有

00:52:10.200 --> 00:52:14.910
关于真正答案的信息

00:52:12.720 --> 00:52:17.730
是希望的测试框架

00:52:14.910 --> 00:52:21.120
测试非公开非出口非公开

00:52:17.730 --> 00:52:23.670
模块的元素应使用

00:52:21.120 --> 00:52:26.390
方法处理要访问的查找API 

00:52:23.670 --> 00:52:29.580
模块内部约束

00:52:26.390 --> 00:52:33.920
那就是一整天的价值

00:52:29.580 --> 00:52:36.990
说话，但你只需要

00:52:33.920 --> 00:52:40.010
测试框架旋转

00:52:36.990 --> 00:52:48.530
基础架构一次使用写API 

00:52:40.010 --> 00:52:52.460
我是一个反面的问题，是的

00:52:48.530 --> 00:52:59.270
合格的出口才让我

00:52:52.460 --> 00:53:03.380
回到出口出口包装

00:52:59.270 --> 00:53:04.880
到特定的朋友模块，是的，我认为

00:53:03.380 --> 00:53:05.240
这就是我们有时间再次感谢

00:53:04.880 --> 00:53:11.769
您

00:53:05.240 --> 00:53:11.769
 [音乐] 

