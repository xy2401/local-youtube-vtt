WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.189 --> 00:00:10.240
大家好，今天是5:30，我们只有

00:00:07.609 --> 00:00:12.769
 45分钟，所以我要开始

00:00:10.240 --> 00:00:15.169
谢谢大家来我的名字是亚历克斯

00:00:12.769 --> 00:00:22.370
 Buckley我是Java的规范负责人

00:00:15.169 --> 00:00:26.060
 Oracle JDK 9的语言和VM在这里

00:00:22.370 --> 00:00:27.890
而且其中有很多

00:00:26.060 --> 00:00:31.190
功能是性能改进

00:00:27.890 --> 00:00:33.320
例如紧凑的琴弦，一些我们的工具

00:00:31.190 --> 00:00:35.000
改进，例如Java中的搜索框

00:00:33.320 --> 00:00:38.600
马克在主题演讲中展示的文档，以及

00:00:35.000 --> 00:00:41.900
新的J Shell工具Strawpoll具有

00:00:38.600 --> 00:00:45.530
有人下载了JDK 9却没有正确答案

00:00:41.900 --> 00:00:46.940
有没有人玩过J Shell 

00:00:45.530 --> 00:00:47.210
正确的答案是最酷的事情

00:00:46.940 --> 00:00:52.880
曾经

00:00:47.210 --> 00:00:55.100
是的，当然，在这个广阔的地方，有些不错

00:00:52.880 --> 00:00:58.100
列表是对现有功能的更新

00:00:55.100 --> 00:01:00.320
例如对Unicode 8的支持，但是

00:00:58.100 --> 00:01:02.809
主要特征和所采取的

00:01:00.320 --> 00:01:06.680
要实现很多年是

00:01:02.809 --> 00:01:08.360
模块系统模块系统很大

00:01:06.680 --> 00:01:11.330
交易，因为它使模块化

00:01:08.360 --> 00:01:13.250
一直沿Java开发

00:01:11.330 --> 00:01:16.430
语言和Java虚拟机

00:01:13.250 --> 00:01:18.740
非常了解模块，以便

00:01:16.430 --> 00:01:21.560
您编写的应用程序以及

00:01:18.740 --> 00:01:24.500
您消耗的库，甚至是jdk 

00:01:21.560 --> 00:01:27.110
本身可以全部开发和测试

00:01:24.500 --> 00:01:29.990
并打包和部署为模块

00:01:27.110 --> 00:01:32.990
具有清晰的api并受到良好保护

00:01:29.990 --> 00:01:35.090
内部结构使每个人都在玩

00:01:32.990 --> 00:01:37.580
相同的模块化规则有很大的好处

00:01:35.090 --> 00:01:39.680
可靠性的可维护性和

00:01:37.580 --> 00:01:44.000
安全性，我们将在其余部分中看到

00:01:39.680 --> 00:01:46.070
这个话题以模块为主题

00:01:44.000 --> 00:01:48.140
一路沉思

00:01:46.070 --> 00:01:50.060
三个部分第一部分说明了如何

00:01:48.140 --> 00:01:53.180
模块对您有效

00:01:50.060 --> 00:01:54.830
在应用程序代码的结构中

00:01:53.180 --> 00:01:57.830
第二部分是关于应用程序的方式

00:01:54.830 --> 00:01:59.780
他们依赖的库可以

00:01:57.830 --> 00:02:02.030
迁移到有关的模块

00:01:59.780 --> 00:02:04.640
如何混合使用模块化和非模块化

00:02:02.030 --> 00:02:07.430
代码，第三部分是关于

00:02:04.640 --> 00:02:09.349
模块化JDK的结构，包括

00:02:07.430 --> 00:02:11.349
一些兼容性问题

00:02:09.349 --> 00:02:15.819
由此产生

00:02:11.349 --> 00:02:15.819
所以在大型编程

00:02:15.900 --> 00:02:21.760
在面向对象的编程中

00:02:18.670 --> 00:02:24.640
传统上，重用的基本单位是

00:02:21.760 --> 00:02:27.550
传统上Java类

00:02:24.640 --> 00:02:29.950
促进重用的绝佳机制

00:02:27.550 --> 00:02:32.170
重用的类继承

00:02:29.950 --> 00:02:34.080
重用的行为接口

00:02:32.170 --> 00:02:37.030
抽象单独编译

00:02:34.080 --> 00:02:39.010
动态链接和访问控制关闭

00:02:37.030 --> 00:02:42.730
到各个领域的水平

00:02:39.010 --> 00:02:46.030
方法，我们有嵌套的类

00:02:42.730 --> 00:02:48.400
自1997年以来， 

00:02:46.030 --> 00:02:52.360
单个顶级类进行封装

00:02:48.400 --> 00:02:54.640
大量的功能

00:02:52.360 --> 00:02:57.070
在心中看来，一个应用

00:02:54.640 --> 00:02:59.740
可能是一个包含

00:02:57.070 --> 00:03:01.900
几个非常丰富的类都共享数据

00:02:59.740 --> 00:03:03.910
包中可访问的字段

00:03:01.900 --> 00:03:06.910
以及少数公共课程

00:03:03.910 --> 00:03:11.400
形成入口或API的API 

00:03:06.910 --> 00:03:13.930
申请权不是真的

00:03:11.400 --> 00:03:17.920
有多少人在一个代码库上工作

00:03:13.930 --> 00:03:21.310
由一个包组成，实际上没有

00:03:17.920 --> 00:03:23.410
自己拿两个包

00:03:21.310 --> 00:03:26.980
代码库不是依赖项三

00:03:23.410 --> 00:03:30.240
打包有多少人在编写代码

00:03:26.980 --> 00:03:35.140
基于10个包装的数量

00:03:30.240 --> 00:03:37.390
一些手20包哇这要去

00:03:35.140 --> 00:03:40.660
比我上次做的要高

00:03:37.390 --> 00:03:45.880
给了这次演讲50包，这是

00:03:40.660 --> 00:03:46.780
只是您自己的代码库可能是3或400 

00:03:45.880 --> 00:03:49.440
在前面，这就是为什么你在

00:03:46.780 --> 00:03:52.120
前排做笔记，因为它是的

00:03:49.440 --> 00:03:55.330
所以这使我的观点更好了

00:03:52.120 --> 00:03:57.400
比我本来可以自己做的程序

00:03:55.330 --> 00:04:00.220
不包含少数软件包

00:03:57.400 --> 00:04:02.020
甚至最小的微服务

00:04:00.220 --> 00:04:05.350
不会适合

00:04:02.020 --> 00:04:07.320
单个程序包不对我们的程序包进行编程

00:04:05.350 --> 00:04:09.910
 Java中的类

00:04:07.320 --> 00:04:11.950
不幸的是Java语言

00:04:09.910 --> 00:04:15.430
一旦您的程序更大，就放弃

00:04:11.950 --> 00:04:17.500
而不是单个包装，只需想象一下

00:04:15.430 --> 00:04:20.109
很难控制内部的重用

00:04:17.500 --> 00:04:24.070
它说的是一个很大的代码库

00:04:20.109 --> 00:04:28.360
像JDK 8中的217个官方软件包

00:04:24.070 --> 00:04:32.320
但是你的代码库是217 

00:04:28.360 --> 00:04:35.780
共享代码的唯一途径

00:04:32.320 --> 00:04:37.660
包带有public修饰符，但是

00:04:35.780 --> 00:04:40.040
那你就跟大家分享

00:04:37.660 --> 00:04:42.230
打包就不足为奇了

00:04:40.040 --> 00:04:44.060
一种或另一种形式的友谊具有

00:04:42.230 --> 00:04:47.180
多年来被多次要求

00:04:44.060 --> 00:04:49.790
打包是一种很好的组织方式

00:04:47.180 --> 00:04:55.010
课，但大多数人希望有一个

00:04:49.790 --> 00:04:57.590
将软件包组织到模块的方法

00:04:55.010 --> 00:05:01.280
你认为一个模块是一组

00:04:57.590 --> 00:05:03.560
专为重复使用而设计的软件包

00:05:01.280 --> 00:05:06.680
 Java中的过期过期构建基块

00:05:03.560 --> 00:05:09.020
有效语言模块记录了

00:05:06.680 --> 00:05:11.660
程序的结构，以便

00:05:09.020 --> 00:05:12.440
您想重用的软件包可以是

00:05:11.660 --> 00:05:14.810
重用

00:05:12.440 --> 00:05:19.310
而您不想成为的包裹

00:05:14.810 --> 00:05:21.770
重用不能重用构建的程序

00:05:19.310 --> 00:05:23.870
的模块将比

00:05:21.770 --> 00:05:26.120
从一组松散的程序中构建的程序

00:05:23.870 --> 00:05:28.220
可以访问的jar文件中的软件包

00:05:26.120 --> 00:05:31.840
彼此自由地接触

00:05:28.220 --> 00:05:31.840
许多AP都面向外界

00:05:32.020 --> 00:05:42.620
换句话说，在码头犬包

00:05:36.230 --> 00:05:44.810
我们的程序是模块这是一个模块

00:05:42.620 --> 00:05:48.680
大家很快就会熟悉

00:05:44.810 --> 00:05:50.930
 Java基础是每个基础

00:05:48.680 --> 00:05:54.590
像java.lang对象这样的Java程序是

00:05:50.930 --> 00:05:57.020
每个蓝色班级的根源是

00:05:54.590 --> 00:06:00.310
打算使用的Java基础软件包

00:05:57.020 --> 00:06:04.160
通过模块外的代码，这些是

00:06:00.310 --> 00:06:07.400
红色导出的软件包是

00:06:04.160 --> 00:06:09.860
他们可以在Java基础内部打包

00:06:07.400 --> 00:06:12.500
由模块内部的代码使用，但

00:06:09.860 --> 00:06:16.610
不是通过模块外的代码，这些是

00:06:12.500 --> 00:06:18.860
其隐藏包模块是

00:06:16.610 --> 00:06:21.620
在一种称为

00:06:18.860 --> 00:06:23.950
照片Java中的模块，它给出了名称

00:06:21.620 --> 00:06:27.110
模块及其导出的软件包的名称

00:06:23.950 --> 00:06:28.910
通过导出java.lang包

00:06:27.110 --> 00:06:30.860
表示

00:06:28.910 --> 00:06:33.740
可以从外部访问java.lang 

00:06:30.860 --> 00:06:36.710
 java base和一个不是

00:06:33.740 --> 00:06:39.950
明确出口，如平静的阳光

00:06:36.710 --> 00:06:41.800
加密货币提供商对其公众隐瞒

00:06:39.950 --> 00:06:45.550
类无法访问

00:06:41.800 --> 00:06:47.979
 Java基础之外的表，所以这是

00:06:45.550 --> 00:06:51.370
 JDK 9强模块的第一个功能

00:06:47.979 --> 00:06:53.770
封装模块不仅仅是一组

00:06:51.370 --> 00:06:56.830
包，它是一组导出的

00:06:53.770 --> 00:06:58.990
包和隐藏包

00:06:56.830 --> 00:07:01.780
导出包的公共类是

00:06:58.990 --> 00:07:04.509
公众可以在模块外部访问

00:07:01.780 --> 00:07:08.400
隐藏包的类别不是

00:07:04.509 --> 00:07:11.020
在模块外部可访问

00:07:08.400 --> 00:07:14.349
这意味着访问控制更多

00:07:11.020 --> 00:07:17.169
在JDK 9中比在JDK 8中强大

00:07:14.349 --> 00:07:19.560
吉达k9可以安排公共活动

00:07:17.169 --> 00:07:21.909
每个人都可以访问的课程，或者

00:07:19.560 --> 00:07:24.639
仅可用于

00:07:21.909 --> 00:07:26.289
相同的模块或中途之家

00:07:24.639 --> 00:07:28.389
他们可以在哪里上课

00:07:26.289 --> 00:07:32.020
相同的模块和一组有限的

00:07:28.389 --> 00:07:35.110
朋友模块，所以如果我们在看

00:07:32.020 --> 00:07:37.389
在类声明上公开它不

00:07:35.110 --> 00:07:40.960
更长的时间意味着每个人都可以访问

00:07:37.389 --> 00:07:43.930
类访问取决于是否

00:07:40.960 --> 00:07:46.349
类的模块导出类的

00:07:43.930 --> 00:07:46.349
包

00:07:49.289 --> 00:07:56.110
因为Java base是一个模块，所以我们可以重用

00:07:52.569 --> 00:07:58.830
它与我们自己的模块一起

00:07:56.110 --> 00:08:01.840
包comm示例中的类hello 

00:07:58.830 --> 00:08:04.120
非常简单的类，让我们声明一个

00:08:01.840 --> 00:08:07.870
底部的“ hello world”模块

00:08:04.120 --> 00:08:09.969
为了实现照片Java中的模块

00:08:07.870 --> 00:08:13.259
争论让我们导出冷静的例子

00:08:09.969 --> 00:08:17.050
你好，出口指令包

00:08:13.259 --> 00:08:20.259
现在您可能想知道

00:08:17.050 --> 00:08:22.900
你好世界模块知道它有一个

00:08:20.259 --> 00:08:25.360
包之后叫做comm example hello 

00:08:22.900 --> 00:08:30.069
包装中的所有东西似乎都没有

00:08:25.360 --> 00:08:32.199
指向您好世界模块

00:08:30.069 --> 00:08:35.349
工具决定

00:08:32.199 --> 00:08:38.440
开发每个模块的模块

00:08:35.349 --> 00:08:40.630
实际上属于您的ID 

00:08:38.440 --> 00:08:42.640
照顾它，您将创建一个模块化的java 

00:08:40.630 --> 00:08:45.070
申请并被询问的名称

00:08:42.640 --> 00:08:46.480
模块，然后创建的每个包

00:08:45.070 --> 00:08:51.010
将成为该模块的一部分

00:08:46.480 --> 00:08:53.529
如果您手动运行Java C，则Java C 

00:08:51.010 --> 00:08:55.700
弄清楚每个软件包是哪个模块

00:08:53.529 --> 00:08:57.950
这就是模块推断的原因

00:08:55.700 --> 00:09:00.140
与通讯处于同一级别

00:08:57.950 --> 00:09:01.790
换句话说，如果我是现代人

00:09:00.140 --> 00:09:03.620
忘记了Java与

00:09:01.790 --> 00:09:05.510
包层次结构，然后Java C对待

00:09:03.620 --> 00:09:10.100
所有那些源文件都作为一个

00:09:05.510 --> 00:09:12.830
模块依赖工具的好处

00:09:10.100 --> 00:09:15.110
决定模块成员资格是

00:09:12.830 --> 00:09:17.210
放置现有包装真的很容易

00:09:15.110 --> 00:09:18.890
在一个模块中，并立即给

00:09:17.210 --> 00:09:19.790
包强利

00:09:18.890 --> 00:09:23.029
封装

00:09:19.790 --> 00:09:26.510
我们不希望每个班级都喜欢

00:09:23.029 --> 00:09:28.490
打招呼，必须通过声明加入

00:09:26.510 --> 00:09:31.160
它所属的模块将

00:09:28.490 --> 00:09:33.860
邀请错误，例如

00:09:31.160 --> 00:09:36.020
同一包试图加入不同

00:09:33.860 --> 00:09:41.120
模块，这是一个很大的禁忌

00:09:36.020 --> 00:09:46.160
我稍后再提及的原因

00:09:41.120 --> 00:09:48.890
你好类进口的东西

00:09:46.160 --> 00:09:52.910
 java.lang程序包在哪里？ 

00:09:48.890 --> 00:09:55.010
从现在开始导入，您可能会说

00:09:52.910 --> 00:09:57.500
答案显然是基于Java的，因为

00:09:55.010 --> 00:09:59.960
您在一分钟前告诉我Java基础

00:09:57.500 --> 00:10:01.910
导出java.lang包，您将

00:09:59.960 --> 00:10:05.240
一般而言，但如何

00:10:01.910 --> 00:10:07.220
编译器知道应该搜索

00:10:05.240 --> 00:10:09.200
文件系统中寻找哪些模块

00:10:07.220 --> 00:10:12.080
出口进口包装

00:10:09.200 --> 00:10:17.089
如果多个模块导出

00:10:12.080 --> 00:10:19.430
如果我们打算重复使用进口包装

00:10:17.089 --> 00:10:21.980
我们应该记录的Java基本模块

00:10:19.430 --> 00:10:23.600
这个事实实际上是因为我们正在写一个

00:10:21.980 --> 00:10:26.000
我们必须自己做模块

00:10:23.600 --> 00:10:28.970
事实上，这是

00:10:26.000 --> 00:10:31.940
 JDK 9中的模块可靠依赖项

00:10:28.970 --> 00:10:34.339
模块不仅仅是一组软件包

00:10:31.940 --> 00:10:38.690
一组可重复使用的软件包

00:10:34.339 --> 00:10:41.540
包由其他模块导出，因此

00:10:38.690 --> 00:10:43.700
 HelloWorld模块指定它

00:10:41.540 --> 00:10:45.980
将Java基本模块与

00:10:43.700 --> 00:10:47.110
在其模块中的require指令

00:10:45.980 --> 00:10:50.180
图片Java 

00:10:47.110 --> 00:10:53.350
这意味着HelloWorld中的代码

00:10:50.180 --> 00:10:55.720
模块可以导入任何软件包

00:10:53.350 --> 00:10:58.880
由Java库导出

00:10:55.720 --> 00:11:01.040
如果HelloWorld中的代码会怎样？ 

00:10:58.880 --> 00:11:04.550
模块尝试导入任何

00:11:01.040 --> 00:11:07.190
 Java基础隐藏的软件包，例如

00:11:04.550 --> 00:11:11.720
 Sun安全提供商

00:11:07.190 --> 00:11:14.200
阅读这是一些代码的真实示例

00:11:11.720 --> 00:11:17.090
那最后一点的鱼

00:11:14.200 --> 00:11:19.850
它不能在JDK 9上运行，因为

00:11:17.090 --> 00:11:22.190
 VM引发非法访问错误

00:11:19.850 --> 00:11:24.440
错误消息是班级通讯员

00:11:22.190 --> 00:11:26.900
企业安全提供者策略

00:11:24.440 --> 00:11:29.240
模块未命名模块中的包装器不

00:11:26.900 --> 00:11:31.970
担心无法访问班级儿子

00:11:29.240 --> 00:11:37.160
模块中的安全提供程序策略文件

00:11:31.970 --> 00:11:39.800
 Java基础现在可以看一下开放的JDK 

00:11:37.160 --> 00:11:43.900
存储库向我们显示该策略文件

00:11:39.800 --> 00:11:47.630
 Sun Security中的类宣布为公共

00:11:43.900 --> 00:11:50.450
但由于该软件包未导出

00:11:47.630 --> 00:11:53.860
仅通过Java基本策略文件

00:11:50.450 --> 00:11:56.540
可从Java基础本身的代码访问

00:11:53.860 --> 00:11:59.030
在跳船犬中要清楚

00:11:56.540 --> 00:12:01.430
 GlassFish代码无法访问此公众

00:11:59.030 --> 00:12:03.080
编译时的策略文件类或

00:12:01.430 --> 00:12:05.570
运行时就像尝试

00:12:03.080 --> 00:12:07.580
访问包私有类Java C 

00:12:05.570 --> 00:12:09.950
给出错误，VM抛出非法

00:12:07.580 --> 00:12:12.110
访问错误对不起，您将获得GlassFish 

00:12:09.950 --> 00:12:18.740
查找受支持的API而不是其中之一

00:12:12.110 --> 00:12:20.750
隐藏太阳点星api的我想

00:12:18.740 --> 00:12:23.510
回到地球你好

00:12:20.750 --> 00:12:26.570
声明以下内容的信息点Java文件

00:12:23.510 --> 00:12:29.000
 HelloWorld模块非常重要

00:12:26.570 --> 00:12:35.930
了解模块导出

00:12:29.000 --> 00:12:37.940
包但需要模块的原因

00:12:35.930 --> 00:12:41.480
是由于旧的软件工程

00:12:37.940 --> 00:12:44.570
原则重用的单位是单位

00:12:41.480 --> 00:12:47.690
释放这一原则最终是

00:12:44.570 --> 00:12:50.870
关于重用关注点分离的问题

00:12:47.690 --> 00:12:53.000
某人的代码，而不是复制粘贴

00:12:50.870 --> 00:12:55.360
到您自己的源代码树中，但是

00:12:53.000 --> 00:12:59.270
在某种程度上取决于黑匣子

00:12:55.360 --> 00:13:01.970
现在由其他人释放的工件

00:12:59.270 --> 00:13:04.060
 Java生态系统毫无疑问

00:13:01.970 --> 00:13:06.890
释放单位是jar文件

00:13:04.060 --> 00:13:09.110
罐子的模块不会改变

00:13:06.890 --> 00:13:11.300
文件仅包含模块信息点

00:13:09.110 --> 00:13:13.640
从模块信息生成的类文件

00:13:11.300 --> 00:13:17.270
 Java和普通的类文件

00:13:13.640 --> 00:13:19.760
我们称其为模块化罐子

00:13:17.270 --> 00:13:20.060
有人为

00:13:19.760 --> 00:13:23.300
地狱

00:13:20.060 --> 00:13:26.390
世界模块，其他人可以重用

00:13:23.300 --> 00:13:29.560
写作需要他们打招呼的世界

00:13:26.390 --> 00:13:32.510
照片Java中的自有模块

00:13:29.560 --> 00:13:34.550
受益于显式一致的API 

00:13:32.510 --> 00:13:37.730
正是由绿色组成

00:13:34.550 --> 00:13:40.070
导出的软件包和发布器

00:13:37.730 --> 00:13:43.160
受益于强力封装

00:13:40.070 --> 00:13:46.820
模块内部的密封包装

00:13:43.160 --> 00:13:49.130
支持导出的API，所以甚至

00:13:46.820 --> 00:13:51.530
如果模块内部耦合度高

00:13:49.130 --> 00:13:53.330
模块之间存在松散耦合

00:13:51.530 --> 00:13:59.630
另一个好的软件工程

00:13:53.330 --> 00:14:01.490
原则还可以，所以您需要Java 

00:13:59.630 --> 00:14:04.100
您的HelloWorld模块中的基础

00:14:01.490 --> 00:14:07.630
您已经为您构建了一个模块化的罐子

00:14:04.100 --> 00:14:10.550
您将模块化罐子放在哪里的模块

00:14:07.630 --> 00:14:13.880
 jdk九寻找系统中的模块

00:14:10.550 --> 00:14:16.070
映像以及系统上的模块路径

00:14:13.880 --> 00:14:19.400
映像在JDK安装中

00:14:16.070 --> 00:14:22.970
包含Java基础和目录的目录

00:14:19.400 --> 00:14:24.740
几十个核心模块的模块路径

00:14:22.970 --> 00:14:26.990
在命令行上设置为

00:14:24.740 --> 00:14:29.720
类路径，除了模块路径

00:14:26.990 --> 00:14:32.920
指向包含模块化的目录

00:14:29.720 --> 00:14:38.360
罐子而不是罐子本身

00:14:32.920 --> 00:14:41.570
所以Java P Java-P mods指定

00:14:38.360 --> 00:14:44.990
模块化的罐子可以在mod中找到

00:14:41.570 --> 00:14:51.500
目录和-HelloWorld指定

00:14:44.990 --> 00:14:53.660
然后运行关键点的模块

00:14:51.500 --> 00:14:55.490
关于彼此需要的模块是

00:14:53.660 --> 00:14:57.800
模块系统可以检查

00:14:55.490 --> 00:15:00.950
要求并验证模块化

00:14:57.800 --> 00:15:03.200
编译器应用程序正常

00:15:00.950 --> 00:15:05.810
或运行时已找到初始模块

00:15:03.200 --> 00:15:08.210
系统映像中或

00:15:05.810 --> 00:15:11.840
它执行的模块路径称为

00:15:08.210 --> 00:15:14.810
分辨率分辨率意味着检查

00:15:11.840 --> 00:15:17.360
它需要指令并找到那些

00:15:14.810 --> 00:15:19.190
系统映像中所需的模块或

00:15:17.360 --> 00:15:22.550
然后在模块路径上递归

00:15:19.190 --> 00:15:26.120
解决它们，我们正在建立一个图形

00:15:22.550 --> 00:15:28.850
其节点和模块以及其边缘

00:15:26.120 --> 00:15:30.380
是需求关系并且是

00:15:28.850 --> 00:15:33.340
在码头Cana上清除，我们在

00:15:30.380 --> 00:15:33.340
编译时间和

00:15:33.810 --> 00:15:39.820
 time.if解决方案成功，您将获得

00:15:36.580 --> 00:15:42.640
三个保证首先是每个模块

00:15:39.820 --> 00:15:44.620
是必需的，可以吗

00:15:42.640 --> 00:15:46.090
明显，但比

00:15:44.620 --> 00:15:49.030
您找不到的课程路径

00:15:46.090 --> 00:15:53.020
这些身份列出缺少的罐子，直到

00:15:49.030 --> 00:15:53.620
以后的第二个模块不依赖

00:15:53.020 --> 00:15:56.770
彼此

00:15:53.620 --> 00:15:59.050
在一个循环中，循环依赖性导致

00:15:56.770 --> 00:16:01.330
难以维护的代码，我们

00:15:59.050 --> 00:16:05.800
借此机会禁止他们

00:16:01.330 --> 00:16:07.330
从JDK 9的第一天开始的模块中

00:16:05.800 --> 00:16:09.670
你们当中有些人认为这仅仅是

00:16:07.330 --> 00:16:13.060
依赖管理甚至可能

00:16:09.670 --> 00:16:15.520
这样做，谁在想一些手

00:16:13.060 --> 00:16:17.350
好吧，你知道现在很公平

00:16:15.520 --> 00:16:20.080
请记住，Maven仅在编译时有效

00:16:17.350 --> 00:16:22.810
时间，此解决过程有效

00:16:20.080 --> 00:16:24.730
同样在运行时，但更重要的是

00:16:22.810 --> 00:16:29.470
让我来谈谈决议

00:16:24.730 --> 00:16:32.500
保证一个模块中的代码是否导入

00:16:29.470 --> 00:16:36.570
一个包装，然后该包装是

00:16:32.500 --> 00:16:40.300
从另一个模块导出

00:16:36.570 --> 00:16:42.130
此保证也依赖于出口

00:16:40.300 --> 00:16:44.290
根据需要，所以您不会在其中找到它

00:16:42.130 --> 00:16:46.750
专家意味着没有分裂

00:16:44.290 --> 00:16:48.790
包，当两个

00:16:46.750 --> 00:16:51.100
类路径上的jar包含相同的

00:16:48.790 --> 00:16:53.320
包，然后从中加载一些类

00:16:51.100 --> 00:16:56.170
一个罐子和其他同一个类

00:16:53.320 --> 00:16:58.480
从另一个罐子拆分的包装

00:16:56.170 --> 00:17:00.880
软件包是该类的一个巨大失败

00:16:58.480 --> 00:17:04.480
路径机制，因为它们导致

00:17:00.880 --> 00:17:06.280
由于难以调试方案

00:17:04.480 --> 00:17:08.170
分辨率，这是完全不可能的

00:17:06.280 --> 00:17:10.079
在一个模块化的应用程序是

00:17:08.170 --> 00:17:12.730
显然对长期维护有利

00:17:10.079 --> 00:17:15.640
这就是我们真正的意思

00:17:12.730 --> 00:17:18.910
可靠的依赖关系

00:17:15.640 --> 00:17:21.490
图表中的每个模块时都是可靠的

00:17:18.910 --> 00:17:26.770
只能访问软件包的一个版本

00:17:21.490 --> 00:17:28.810
一次保证不分裂

00:17:26.770 --> 00:17:31.630
软件包对性能至关重要

00:17:28.810 --> 00:17:35.020
也因为我们确切地知道

00:17:31.630 --> 00:17:37.120
模块导出哪个包没有

00:17:35.020 --> 00:17:39.070
需要扫描系统中的每个模块

00:17:37.120 --> 00:17:42.160
图像和尝试时在模块路径上

00:17:39.070 --> 00:17:44.360
加载一个类的对比

00:17:42.160 --> 00:17:47.539
您从课程路径加载课程

00:17:44.360 --> 00:17:50.299
这是hadoop的类路径

00:17:47.539 --> 00:17:53.990
编译器或运行时必须执行线性

00:17:50.299 --> 00:17:56.210
每当有新的罐子时搜索110个罐子

00:17:53.990 --> 00:17:57.919
当然需要上课

00:17:56.210 --> 00:18:00.470
实施可以加快速度

00:17:57.919 --> 00:18:02.299
缓存它发现时的类

00:18:00.470 --> 00:18:04.549
没在找他们，但是有

00:18:02.299 --> 00:18:07.010
还是这个讨厌的一半

00:18:04.549 --> 00:18:09.620
打包拆分问题

00:18:07.010 --> 00:18:13.190
多个罐子，你怎么会发现

00:18:09.620 --> 00:18:15.289
如果你认为那是在继续

00:18:13.190 --> 00:18:17.929
关于它，上课的路很疯狂

00:18:15.289 --> 00:18:20.299
有一百一十个罐子

00:18:17.929 --> 00:18:23.360
超过12,000种可能的互动

00:18:20.299 --> 00:18:26.690
在每个罐子中的类之间

00:18:23.360 --> 00:18:29.809
一个开始线性搜索的班级

00:18:26.690 --> 00:18:31.039
路径是擦除的最终方法

00:18:29.809 --> 00:18:32.840
你知道你的结构

00:18:31.039 --> 00:18:34.639
应用程序的类路径将其抛出

00:18:32.840 --> 00:18:37.519
离开并将一切连接到

00:18:34.639 --> 00:18:40.370
所有其他的模块

00:18:37.519 --> 00:18:42.679
告诉解决方案您了解什么

00:18:40.370 --> 00:18:44.929
您的应用程序的结构

00:18:42.679 --> 00:18:46.909
需要指令，它使用

00:18:44.929 --> 00:18:51.850
提供安全性和安全性的信息

00:18:46.909 --> 00:18:51.850
编译时和运行时的性能

00:18:53.409 --> 00:18:59.179
禁止拆分包装

00:18:56.539 --> 00:19:02.750
模块对应用程序有影响

00:18:59.179 --> 00:19:05.990
设计以及包装的原因之一

00:19:02.750 --> 00:19:08.029
可能被分开放在罐子里是为了

00:19:05.990 --> 00:19:11.000
允许应用程序的不同部分

00:19:08.029 --> 00:19:12.500
在共享软件包私密代码的同时

00:19:11.000 --> 00:19:16.220
允许零件进化

00:19:12.500 --> 00:19:17.809
现在这些罐子不能独立

00:19:16.220 --> 00:19:20.389
变成模块，因为他们会

00:19:17.809 --> 00:19:22.700
都出口相同的包裹

00:19:20.389 --> 00:19:24.919
但是模块系统有更好的

00:19:22.700 --> 00:19:29.179
构建应用程序的方式

00:19:24.919 --> 00:19:32.630
拆分程序包让我进行设置

00:19:29.179 --> 00:19:35.679
场景更详细地假设所有

00:19:32.630 --> 00:19:39.380
这发生在JDK 9之前的世界中

00:19:35.679 --> 00:19:42.230
因此在左侧，应用程序具有

00:19:39.380 --> 00:19:45.350
 API旨在全球可访问

00:19:42.230 --> 00:19:49.010
这是包中的公共foo接口

00:19:45.350 --> 00:19:51.169
 P应用程序也有一些帮助

00:19:49.010 --> 00:19:53.960
创建或协助的代码

00:19:51.169 --> 00:19:56.360
 API的理想实现

00:19:53.960 --> 00:19:57.600
却无法被

00:19:56.360 --> 00:20:00.450
应用

00:19:57.600 --> 00:20:03.559
这是小便助手包，最后

00:20:00.450 --> 00:20:05.960
在右边的应用程序有

00:20:03.559 --> 00:20:09.539
再次实现API 

00:20:05.960 --> 00:20:11.640
旨在不被用户使用

00:20:09.539 --> 00:20:14.160
是住在的x和y类

00:20:11.640 --> 00:20:18.330
不同的jar文件并实现p 

00:20:14.160 --> 00:20:20.280
点foo api，以获取辅助代码

00:20:18.330 --> 00:20:22.679
和实现一起工作

00:20:20.280 --> 00:20:25.169
他们需要放在同一个包装中

00:20:22.679 --> 00:20:27.179
实现肯定是你会

00:20:25.169 --> 00:20:30.870
绝对将它们打包为私有

00:20:27.179 --> 00:20:33.929
该用户代码现在无法访问它们

00:20:30.870 --> 00:20:37.110
然后将helper类foo helper打包

00:20:33.929 --> 00:20:38.760
私人的-可能是公开的，但后来

00:20:37.110 --> 00:20:43.200
将可供用户访问，但我们无法

00:20:38.760 --> 00:20:45.330
希望有很多问题

00:20:43.200 --> 00:20:48.390
有了这个设置，这实际上是唯一的

00:20:45.330 --> 00:20:51.870
构建应用程序的方式

00:20:48.390 --> 00:20:54.059
 9点之前，您必须要做的一件事

00:20:51.870 --> 00:20:57.270
确保中的实现

00:20:54.059 --> 00:21:00.419
 P helper包不要踩在每个

00:20:57.270 --> 00:21:02.039
别人的脚趾不能上任何课

00:21:00.419 --> 00:21:03.630
名称之间重叠

00:21:02.039 --> 00:21:05.970
实施，因为他们都

00:21:03.630 --> 00:21:07.950
贡献相同的包装P点

00:21:05.970 --> 00:21:12.240
尽管住在不同的罐子里，但帮手

00:21:07.950 --> 00:21:15.110
提出第二个问题是你不能

00:21:12.240 --> 00:21:17.730
有效利用子包作为

00:21:15.110 --> 00:21:20.039
这些实现变得更大了

00:21:17.730 --> 00:21:23.159
他们自然会介绍

00:21:20.039 --> 00:21:25.950
子包，但有些包不能

00:21:23.159 --> 00:21:28.679
访问P点中的软件包私人代码

00:21:25.950 --> 00:21:30.809
帮手，所以你真的需要一个公众

00:21:28.679 --> 00:21:33.480
 P点辅助程序中的类充当

00:21:30.809 --> 00:21:34.770
后门，用于居住在

00:21:33.480 --> 00:21:37.200
实现，但是当然

00:21:34.770 --> 00:21:41.789
世界上任何人都可以进入

00:21:37.200 --> 00:21:43.620
后门以及第三个问题

00:21:41.789 --> 00:21:46.230
当然，任何人都可以做一个罐子

00:21:43.620 --> 00:21:48.690
在p点帮助程序包中包含类

00:21:46.230 --> 00:21:51.990
并开始依赖于

00:21:48.690 --> 00:21:56.150
 api jar和类的详细信息x 

00:21:51.990 --> 00:21:56.150
和y在执行罐子中

00:21:57.900 --> 00:22:03.510
真正发生的是

00:22:01.170 --> 00:22:06.690
软件包P点帮助程序超载

00:22:03.510 --> 00:22:10.290
它以简单的命名空间开始

00:22:06.690 --> 00:22:12.990
用于帮助API的代码，但现在可以使用

00:22:10.290 --> 00:22:15.230
发现自己是不自然的家

00:22:12.990 --> 00:22:18.000
用于各种模糊的相关事物

00:22:15.230 --> 00:22:20.820
开发人员打算在其中做什么

00:22:18.000 --> 00:22:23.090
 JDK 8唯一的结构化机制

00:22:20.820 --> 00:22:25.440
是类的接口和包

00:22:23.090 --> 00:22:28.230
在jar文件中拆分包

00:22:25.440 --> 00:22:31.500
被视为可以接受，但您可以看到

00:22:28.230 --> 00:22:33.990
它有很多缺点

00:22:31.500 --> 00:22:36.050
吉达犬的构造机制

00:22:33.990 --> 00:22:40.020
是类接口包和

00:22:36.050 --> 00:22:42.270
模块承受的压力

00:22:40.020 --> 00:22:45.570
封装和隐藏

00:22:42.270 --> 00:22:48.120
这样软件包可以只专注于

00:22:45.570 --> 00:22:52.650
是意味着

00:22:48.120 --> 00:22:54.660
对开发人员有意义，所以这里是

00:22:52.650 --> 00:22:59.550
与开发相同的应用程序

00:22:54.660 --> 00:23:01.380
模块，让我们将API jar变成一个

00:22:59.550 --> 00:23:03.590
通过添加模块的模块化罐

00:23:01.380 --> 00:23:07.200
声明我要在这里展示

00:23:03.590 --> 00:23:10.800
称为API的模块将导出

00:23:07.200 --> 00:23:13.770
打包p2每个人都是主要API 

00:23:10.800 --> 00:23:17.670
并导出帮助包P点

00:23:13.770 --> 00:23:23.280
为其朋友模块的助手导入一个

00:23:17.670 --> 00:23:25.309
并执行第二个导出指令

00:23:23.280 --> 00:23:29.280
 Petr助手的称呼是合格的

00:23:25.309 --> 00:23:33.120
出口世界上任何模块都可以

00:23:29.280 --> 00:23:36.300
需要API模块并访问

00:23:33.120 --> 00:23:40.170
包P但只有朋友模块

00:23:36.300 --> 00:23:42.630
可以立即访问软件包P点帮助程序

00:23:40.170 --> 00:23:45.030
我没有显示模块方向

00:23:42.630 --> 00:23:46.770
没有显示模块声明

00:23:45.030 --> 00:23:49.590
朋友模块，但他们会

00:23:46.770 --> 00:23:53.880
显然需要使用API​​模块

00:23:49.590 --> 00:23:57.570
为了访问p点foo接口

00:23:53.880 --> 00:24:00.000
他们实现了朋友模块

00:23:57.570 --> 00:24:02.760
不会出口任何东西，他们可以

00:24:00.000 --> 00:24:07.500
组织他们的隐藏包

00:24:02.760 --> 00:24:10.260
他们现在希望P点帮助程序包

00:24:07.500 --> 00:24:11.410
没有过多的实现

00:24:10.260 --> 00:24:14.860
类

00:24:11.410 --> 00:24:18.250
多个jar包的命名是

00:24:14.860 --> 00:24:21.400
所有三个罐子都清晰得多

00:24:18.250 --> 00:24:25.720
并可以添加更多的实现

00:24:21.400 --> 00:24:29.200
效果模块使包装顺利

00:24:25.720 --> 00:24:36.060
和上课一样便宜，然后控制

00:24:29.200 --> 00:24:38.620
包的重用非常精确，因此

00:24:36.060 --> 00:24:41.380
模块是一组用于

00:24:38.620 --> 00:24:45.220
重用它们提供强大的封装

00:24:41.380 --> 00:24:47.710
和可靠的依赖关系以及

00:24:45.220 --> 00:24:50.290
在VI des中使用命令行工具

00:24:47.710 --> 00:24:57.400
将是模块化的重要组成部分

00:24:50.290 --> 00:24:59.170
发展第二部分将在现在谈

00:24:57.400 --> 00:25:02.400
关于如何利用现有的

00:24:59.170 --> 00:25:05.470
应用程序并将其迁移到模块

00:25:02.400 --> 00:25:07.780
因为不可能将

00:25:05.470 --> 00:25:09.250
我们马上就要走的Java生态系统

00:25:07.780 --> 00:25:11.620
与...结合在一起生活

00:25:09.250 --> 00:25:13.840
模块化代码是

00:25:11.620 --> 00:25:16.360
模块路径和非模块化代码

00:25:13.840 --> 00:25:19.780
在类的路径上的传统罐子

00:25:16.360 --> 00:25:21.670
很好，而JDK 9可以简化

00:25:19.780 --> 00:25:25.900
这就是本节的迁移

00:25:21.670 --> 00:25:28.030
关于我们将从一个简单的开始

00:25:25.900 --> 00:25:31.870
我们要从中迁移的应用程序

00:25:28.030 --> 00:25:34.660
核心路径是典型的Java 

00:25:31.870 --> 00:25:36.580
应用程序在顶部有三层

00:25:34.660 --> 00:25:38.650
您的应用程序罐子可能有吗

00:25:36.580 --> 00:25:40.840
底部的一个或多个是

00:25:38.650 --> 00:25:42.550
 JDK，中间有一个

00:25:40.840 --> 00:25:44.350
从这里下载的一堆图书馆罐子

00:25:42.550 --> 00:25:47.100
上网并上课

00:25:44.350 --> 00:25:52.180
看起来对任何人都熟悉的路径

00:25:47.100 --> 00:25:54.580
有些点头，是的，现在我暗示我们已经

00:25:52.180 --> 00:25:56.470
将JDK转换为模块，等等

00:25:54.580 --> 00:25:58.690
这部分绿色框将代表

00:25:56.470 --> 00:26:00.670
您已经看过Java的模块

00:25:58.690 --> 00:26:02.050
基本模块，您不会感到惊讶

00:26:00.670 --> 00:26:04.330
了解有一些模块

00:26:02.050 --> 00:26:08.470
记录数据库访问XML处理

00:26:04.330 --> 00:26:10.690
等在这​​里，但我们的应用程序

00:26:08.470 --> 00:26:13.000
没有模块化，也没有任何

00:26:10.690 --> 00:26:15.610
我们应该模块化我们的图书馆

00:26:13.000 --> 00:26:17.650
应用程序显然取决于您

00:26:15.610 --> 00:26:20.680
可以在类路径上运行它

00:26:17.650 --> 00:26:23.140
您曾经在JDK中做过，但是我们模块化地关注

00:26:20.680 --> 00:26:24.470
 JDK出于提高安全性的原因

00:26:23.140 --> 00:26:27.110
通过强

00:26:24.470 --> 00:26:29.840
通过可靠的光晕和稳定性

00:26:27.110 --> 00:26:31.100
依赖关系应用程序可能想要

00:26:29.840 --> 00:26:33.590
从中受益

00:26:31.100 --> 00:26:35.990
就像jdk一样，让我们​​来看一下

00:26:33.590 --> 00:26:41.030
我们如何将应用程序变成

00:26:35.990 --> 00:26:43.880
模块，假设我们的应用程序是

00:26:41.030 --> 00:26:47.840
我的应用程序车中有两个主要代码的罐子

00:26:43.880 --> 00:26:50.419
和Libby R中的帮助程序代码

00:26:47.840 --> 00:26:52.549
想象图书馆的罐子汤是

00:26:50.419 --> 00:26:55.669
仅限于Jack的JSON处理

00:26:52.549 --> 00:26:58.669
图书馆杰克逊作为三个罐子的核心

00:26:55.669 --> 00:27:02.659
数据绑定和注释，我们有

00:26:58.669 --> 00:27:04.909
底部的模量JDK是

00:27:02.659 --> 00:27:06.620
我们今天如何运行应用程序

00:27:04.909 --> 00:27:08.539
必须将Lib目录设置为

00:27:06.620 --> 00:27:10.309
包括我们的应用程序jar和库

00:27:08.539 --> 00:27:12.530
罐子，并指向它们的类路径

00:27:10.309 --> 00:27:13.760
专家为我做的很好，但是

00:27:12.530 --> 00:27:15.679
做到这一点，很高兴知道什么

00:27:13.760 --> 00:27:17.179
它在做掩护

00:27:15.679 --> 00:27:19.490
然后我们使用

00:27:17.179 --> 00:27:21.289
 Java启动器是我们获得的收获之一

00:27:19.490 --> 00:27:25.850
通过模块化不必列出

00:27:21.289 --> 00:27:27.950
依赖命令行

00:27:25.850 --> 00:27:29.870
让我们来看看一个mod的场景

00:27:27.950 --> 00:27:33.770
自上而下迁移此应用程序

00:27:29.870 --> 00:27:37.669
场景在这里，我们首先模块化我们的眼睛

00:27:33.770 --> 00:27:41.179
应用程序罐子不碰

00:27:37.669 --> 00:27:43.520
现在一般来说，图书馆的罐子

00:27:41.179 --> 00:27:45.440
取决于您的第三方库

00:27:43.520 --> 00:27:48.110
依靠它们进行模块化和

00:27:45.440 --> 00:27:50.299
我们可以使图书馆更容易

00:27:48.110 --> 00:27:52.870
模块化，但我们都必须等待

00:27:50.299 --> 00:27:55.309
没有他们可以强迫他们

00:27:52.870 --> 00:27:56.929
所以很可能是一些

00:27:55.309 --> 00:28:01.640
您所依赖的库不是

00:27:56.929 --> 00:28:04.789
模块化，但对您来说还可以

00:28:01.640 --> 00:28:07.190
应用程序的明显路径是

00:28:04.789 --> 00:28:10.039
将它们一对一地变成模块化的罐子

00:28:07.190 --> 00:28:12.890
每个jar文件都有一个模块信息

00:28:10.039 --> 00:28:14.960
点类文件并不总是这样

00:28:12.890 --> 00:28:17.659
可能，尤其是如果应用程序

00:28:14.960 --> 00:28:19.850
罐子之间具有循环依赖关系

00:28:17.659 --> 00:28:23.840
他们的课程，但让我们一起去

00:28:19.850 --> 00:28:27.230
现在，如果我们要把每个

00:28:23.840 --> 00:28:29.000
将应用程序jar放入模块化jar中

00:28:27.230 --> 00:28:31.940
需要在其中编写模块声明

00:28:29.000 --> 00:28:35.570
照片Java模块回忆

00:28:31.940 --> 00:28:37.570
模块声明给出一个名称和一个

00:28:35.570 --> 00:28:40.930
导出的软件包列表和

00:28:37.570 --> 00:28:42.960
所需模块列表的名称是

00:28:40.930 --> 00:28:45.700
容易，我们称它们为我的应用程序和我的库

00:28:42.960 --> 00:28:48.700
但是我们还不知道每个模块

00:28:45.700 --> 00:28:50.920
取决于我们可以制作手册

00:28:48.700 --> 00:28:53.440
分析源文件或

00:28:50.920 --> 00:28:56.980
类文件，但是有更好的方法

00:28:53.440 --> 00:28:59.710
 Jaidev工具Jade EPS扫描类

00:28:56.980 --> 00:29:03.160
文件是文件，告诉你什么

00:28:59.710 --> 00:29:06.940
他们依赖Jade的其他jar的代码

00:29:03.160 --> 00:29:09.670
 EPS实际上来自JDK 8， 

00:29:06.940 --> 00:29:12.730
 JDK 9的改进版本

00:29:09.670 --> 00:29:14.820
这种分析不可能是完美的

00:29:12.730 --> 00:29:17.680
解决方案，这是一个很好的开始，因此

00:29:14.820 --> 00:29:19.780
我们将在应用程序上运行Jade EPS 

00:29:17.680 --> 00:29:23.170
带有插孔和库的罐子

00:29:19.780 --> 00:29:25.390
类路径，我们看到我的应用程序jar 

00:29:23.170 --> 00:29:27.640
取决于千斤顶和罐子中的两个

00:29:25.390 --> 00:29:29.040
记住这些都不是

00:29:27.640 --> 00:29:32.890
模块尚未

00:29:29.040 --> 00:29:35.860
当然还有我的实时jar和我的应用程序

00:29:32.890 --> 00:29:38.500
点jar取决于Java的JDK模块

00:29:35.860 --> 00:29:41.260
基本和Java续集Jade EPS知道是否

00:29:38.500 --> 00:29:44.500
您使用的是JDBC API 

00:29:41.260 --> 00:29:46.120
来自Java续集模块maile 

00:29:44.500 --> 00:29:48.580
原来是一个罐子

00:29:46.120 --> 00:29:50.650
 Java基础，现在变得非常简单

00:29:48.580 --> 00:29:55.150
我们有什么需要写

00:29:50.650 --> 00:29:58.000
我们将从模块声明开始

00:29:55.150 --> 00:30:00.220
容易一个我的解放，我们知道这取决于

00:29:58.000 --> 00:30:01.870
我们可以编写的Java基础需要Java 

00:30:00.220 --> 00:30:05.110
基地，但我早些时候表明

00:30:01.870 --> 00:30:08.020
其实我们不必总是

00:30:05.110 --> 00:30:10.630
由编译器为您提供，因为

00:30:08.020 --> 00:30:13.600
每个Java程序最终都依赖

00:30:10.630 --> 00:30:16.420
无法编写Java的java.lang对象

00:30:13.600 --> 00:30:18.520
不间接依赖的程序

00:30:16.420 --> 00:30:20.530
 java.lang对象，因此您实际上并没有

00:30:18.520 --> 00:30:23.890
必须写需要Java基础

00:30:20.530 --> 00:30:27.250
总是从现在开始为您服务

00:30:23.890 --> 00:30:30.610
 Jade EPS运行，我们知道我的应用程序罐

00:30:27.250 --> 00:30:32.110
取决于我的嘴唇，如果我们跑J 

00:30:30.610 --> 00:30:34.210
深度，我们将看到更多选择

00:30:32.110 --> 00:30:39.660
我的apt或jar需要一个特定的

00:30:34.210 --> 00:30:42.550
打包在我的库中，这样我们就可以写

00:30:39.660 --> 00:30:45.100
在这个包中导出

00:30:42.550 --> 00:30:47.800
允许任何人访问的声明

00:30:45.100 --> 00:30:49.730
包装，但正如我们之前看到的

00:30:47.800 --> 00:30:52.640
合格出口

00:30:49.730 --> 00:30:55.310
如果我们确定除我的应用程序外没有其他人

00:30:52.640 --> 00:30:58.670
需要访问此通讯我的应用程序

00:30:55.310 --> 00:31:04.100
包，我们可以使用合格的出口

00:30:58.670 --> 00:31:07.730
最大化封装，让我们转向

00:31:04.100 --> 00:31:10.160
我的应用程序的模块声明

00:31:07.730 --> 00:31:13.250
需要我刚刚写的Lib， 

00:31:10.160 --> 00:31:15.410
一些基于Java和Java C的JDK模块

00:31:13.250 --> 00:31:17.810
打电话，我们知道它将使用

00:31:15.410 --> 00:31:20.270
杰克逊，但我们不确定如何写

00:31:17.810 --> 00:31:23.360
杰克逊需要指令

00:31:20.270 --> 00:31:25.790
因为杰克逊是和模块做到这一点

00:31:23.360 --> 00:31:28.100
意味着我们必须将杰克逊变成

00:31:25.790 --> 00:31:30.020
模块，然后我们才能模块化我们的眼睛

00:31:28.100 --> 00:31:31.910
该应用程序将非常不幸，因为

00:31:30.020 --> 00:31:36.050
我们不是我不是说我们我是说你

00:31:31.910 --> 00:31:38.030
如果不控制杰克逊的jar文件

00:31:36.050 --> 00:31:40.310
杰克逊只有办法

00:31:38.030 --> 00:31:43.100
 jar文件以某种方式成为模块

00:31:40.310 --> 00:31:45.950
自动地，我们不知道他们是什么

00:31:43.100 --> 00:31:47.540
依赖和出口将是但我们

00:31:45.950 --> 00:31:49.730
他们的名字叫个好主意

00:31:47.540 --> 00:31:52.970
他们会和罐子一样吗

00:31:49.730 --> 00:31:54.680
 Jackson核心Jackson数据绑定Jackson 

00:31:52.970 --> 00:31:59.420
注释从

00:31:54.680 --> 00:32:01.730
罐子，如果我们能做到的话，我们就可以完成

00:31:59.420 --> 00:32:06.290
为我写模块声明

00:32:01.730 --> 00:32:08.570
应用程序，我们将拥有一个漂亮的模块图

00:32:06.290 --> 00:32:10.670
我的应用程序取决于我的lib和Jackson 

00:32:08.570 --> 00:32:15.800
核心和Jackson数据绑定以及

00:32:10.670 --> 00:32:18.290
 Java基础和Java续集的好消息

00:32:15.800 --> 00:32:22.280
就是我们可以用自动

00:32:18.290 --> 00:32:25.100
一个自动模块就是一个模块

00:32:22.280 --> 00:32:28.460
其声明是由

00:32:25.100 --> 00:32:32.090
模块上的jar中的模块系统

00:32:28.460 --> 00:32:35.330
路径，所以如果我们有不是

00:32:32.090 --> 00:32:38.330
模块化的罐子，我们仍然可以把它们放在

00:32:35.330 --> 00:32:41.800
模块路径和模块系统

00:32:38.330 --> 00:32:43.820
将它们变成有效的模块

00:32:41.800 --> 00:32:46.580
自动模块的功能是

00:32:43.820 --> 00:32:53.870
表示昨天的罐子已经

00:32:46.580 --> 00:32:56.930
当今的模块曾经是自动模块

00:32:53.870 --> 00:32:58.520
杰克逊核心的存在

00:32:56.930 --> 00:33:00.440
 Jax和数据绑定以及Jackson 

00:32:58.520 --> 00:33:01.660
注释模块图看起来相当

00:33:00.440 --> 00:33:04.690
不同

00:33:01.660 --> 00:33:07.180
自动模块基本上说

00:33:04.690 --> 00:33:09.370
要求是他们的一切

00:33:07.180 --> 00:33:12.250
互相要求，所有模块

00:33:09.370 --> 00:33:15.250
在JDK和所有模块中

00:33:12.250 --> 00:33:17.950
好，他们全部出口

00:33:15.250 --> 00:33:20.860
现在打包，虽然这可能很好

00:33:17.950 --> 00:33:23.110
不是需求和出口的集合

00:33:20.860 --> 00:33:25.570
维护者zuv的指令

00:33:23.110 --> 00:33:28.510
杰克逊会亲手写的

00:33:25.570 --> 00:33:30.570
实际上是一个功能，因为它

00:33:28.510 --> 00:33:33.570
模拟类路径的行为

00:33:30.570 --> 00:33:36.640
它提供了最大可能

00:33:33.570 --> 00:33:40.660
 Jar中代码的兼容性表面

00:33:36.640 --> 00:33:42.760
文件，实际上总体来说​​这是

00:33:40.660 --> 00:33:45.130
比一切都破烂不如

00:33:42.760 --> 00:33:47.970
类路径，例如，如果您看

00:33:45.130 --> 00:33:51.640
小心地，我的库里没有箭

00:33:47.970 --> 00:33:54.550
到我的应用程序，因此没有代码危险

00:33:51.640 --> 00:33:58.570
在我的lib中意外进入

00:33:54.550 --> 00:34:00.610
内的类路径代码上的应用内部

00:33:58.570 --> 00:34:02.680
我的lib点jar可以访问我的代码

00:34:00.610 --> 00:34:04.480
应用程序点罐很容易甚至没有

00:34:02.680 --> 00:34:09.970
知道这就是原因

00:34:04.480 --> 00:34:12.520
维护麻烦在路上

00:34:09.970 --> 00:34:14.740
在考虑迁移时

00:34:12.520 --> 00:34:18.730
应用jar通常很好

00:34:14.740 --> 00:34:21.720
候选人成为每个图书馆的模块

00:34:18.730 --> 00:34:24.610
 jar将以自己的节奏模块化眼睛

00:34:21.720 --> 00:34:32.290
但是自动模块意味着您不是

00:34:24.610 --> 00:34:34.149
等待最弱的链接

00:34:32.290 --> 00:34:39.580
希望在这次决赛中引起我们的注意

00:34:34.149 --> 00:34:42.040
 20年前的模块化JDK部分

00:34:39.580 --> 00:34:44.440
 Java平台很小

00:34:42.040 --> 00:34:47.440
百个班级和组织

00:34:44.440 --> 00:34:49.570
 JDK不是问题，但是每年

00:34:47.440 --> 00:34:52.510
平台变得越来越大，现在

00:34:49.570 --> 00:34:56.440
 JDK是数以万计的类

00:34:52.510 --> 00:34:58.510
巨大和更糟的是，现在

00:34:56.440 --> 00:35:01.780
现实Java平台不是一个

00:34:58.510 --> 00:35:03.760
事情更像是25个独立的

00:35:01.780 --> 00:35:06.040
框架，包括swing UI 

00:35:03.760 --> 00:35:08.440
框架加密框架

00:35:06.040 --> 00:35:11.200
脚本框架多个XML 

00:35:08.440 --> 00:35:13.240
处理框架等等

00:35:11.200 --> 00:35:14.650
这些单独的框架没有理由

00:35:13.240 --> 00:35:17.859
紧密耦合

00:35:14.650 --> 00:35:21.549
一次下载实际上是一个障碍

00:35:17.859 --> 00:35:24.880
在开发JDK时过于紧张

00:35:21.549 --> 00:35:27.160
耦合，也许是偶然的加薪

00:35:24.880 --> 00:35:29.079
开发和测试费用

00:35:27.160 --> 00:35:32.260
变成平台发展缓慢

00:35:29.079 --> 00:35:35.789
再加上您的表面较大

00:35:32.260 --> 00:35:38.140
平台越难固定

00:35:35.789 --> 00:35:39.609
这是很多用户的障碍

00:35:38.140 --> 00:35:41.770
那些想跑自己的人

00:35:39.609 --> 00:35:44.020
较小设备上的应用程序以及

00:35:41.770 --> 00:35:46.809
那些想要运行更多实例的

00:35:44.020 --> 00:35:49.029
它们在大型系统上的应用

00:35:46.809 --> 00:35:53.890
如果您只想要JDK的一部分， 

00:35:49.029 --> 00:35:57.670
必须承担所有一切的改变

00:35:53.890 --> 00:35:59.829
在JDK 9中，我们采用了整体式JDK 

00:35:57.670 --> 00:36:02.470
分解成几十个

00:35:59.829 --> 00:36:05.529
一些模块是Java SE的一部分

00:36:02.470 --> 00:36:08.619
规范只是一部分

00:36:05.529 --> 00:36:11.799
这是JDK的实现图

00:36:08.619 --> 00:36:14.200
底部的Java SE模块

00:36:11.799 --> 00:36:16.980
一切都依赖的Java基础

00:36:14.200 --> 00:36:19.450
而这本身不依赖任何东西

00:36:16.980 --> 00:36:21.579
我们打破了各种框架

00:36:19.450 --> 00:36:24.369
放入自己的模块中

00:36:21.579 --> 00:36:27.849
记录您使用的XML脚本编制桌面

00:36:24.369 --> 00:36:31.990
可以根据您的需求而定

00:36:27.849 --> 00:36:35.200
规定在该处有一个Java SE模块

00:36:31.990 --> 00:36:37.930
上面没有代码的顶部

00:36:35.200 --> 00:36:41.289
依赖关系，所以你可以说要求

00:36:37.930 --> 00:36:44.319
 Java SE，并保证拥有所有

00:36:41.289 --> 00:36:46.660
这些模块现在值得

00:36:44.319 --> 00:36:48.700
提到仅仅找到这些

00:36:46.660 --> 00:36:50.950
模块边界和关系

00:36:48.700 --> 00:36:53.140
在事后看来，这可能是显而易见的

00:36:50.950 --> 00:36:55.599
您将付出巨大的工程努力

00:36:53.140 --> 00:36:58.660
在自己的代码中找到解耦一个

00:36:55.599 --> 00:37:00.220
整体建造比建造一个整体要难得多

00:36:58.660 --> 00:37:00.730
松散耦合系统

00:37:00.220 --> 00:37:03.730
开始

00:37:00.730 --> 00:37:06.400
未来的好消息是

00:37:03.730 --> 00:37:08.980
模块施加的纪律将

00:37:06.400 --> 00:37:12.400
防止我们所有人意外

00:37:08.980 --> 00:37:15.750
从后滑动重塑整体

00:37:12.400 --> 00:37:15.750
进入大泥球

00:37:16.049 --> 00:37:22.279
我想快速查看

00:37:18.269 --> 00:37:25.890
对JDK 9的兼容性的期望

00:37:22.279 --> 00:37:29.549
首先有各种各样的技术

00:37:25.890 --> 00:37:32.489
从JDK中附带的Java EE中

00:37:29.549 --> 00:37:35.880
以及在应用服务器中的Java列表

00:37:32.489 --> 00:37:40.099
 JDK 9中的EE模块包括CORBA 

00:37:35.880 --> 00:37:42.779
杰克的B jax-ws和常见注释

00:37:40.099 --> 00:37:44.279
这些不在我身上的模块

00:37:42.779 --> 00:37:46.349
在上一张幻灯片中没有它们

00:37:44.279 --> 00:37:50.699
为了简化起见，但它们在JDK 9中

00:37:46.349 --> 00:37:54.089
在JDK 9中已弃用，并且将

00:37:50.699 --> 00:37:57.900
由于以下原因在将来的版本中删除

00:37:54.089 --> 00:38:00.209
在JDK中默认情况下禁用它们

00:37:57.900 --> 00:38:02.699
 9如果您正在

00:38:00.209 --> 00:38:05.489
您可能需要使用添加的类路径

00:38:02.699 --> 00:38:12.299
启用的模块命令行标志

00:38:05.489 --> 00:38:14.789
这些Java EE模块会花费很多时间

00:38:12.299 --> 00:38:17.249
工具和库尝试访问零件

00:38:14.789 --> 00:38:18.829
 JDK的内部

00:38:17.249 --> 00:38:21.059
仅使用

00:38:18.829 --> 00:38:23.789
不幸的是，这需要一段时间

00:38:21.059 --> 00:38:27.029
工具和库开发人员转移

00:38:23.789 --> 00:38:31.289
从这种做法，所以JDK 9暂时

00:38:27.029 --> 00:38:34.829
允许访问JDK内部，但

00:38:31.289 --> 00:38:37.019
立即显示警告

00:38:34.829 --> 00:38:39.929
有一个命令行标志要避免

00:38:37.019 --> 00:38:41.880
这些警告，因此请使用工具进行检查

00:38:39.929 --> 00:38:45.509
和图书馆开发人员有关如何

00:38:41.880 --> 00:38:47.489
在JDK 9上部署或仅搜索Cova 

00:38:45.509 --> 00:38:48.109
人们一直在要求的流程

00:38:47.489 --> 00:38:50.910
现在几周

00:38:48.109 --> 00:38:53.369
为什么东西不运行这是什么

00:38:50.910 --> 00:38:55.859
例外，这是什么警告，我该怎么办

00:38:53.369 --> 00:39:02.789
必须做的，答案是暂时的

00:38:55.859 --> 00:39:05.249
添加打开也有杂项

00:39:02.789 --> 00:39:07.709
 JDK 9中与以下内容无关的更改

00:39:05.249 --> 00:39:10.199
模块，但可能会影响运行的代码

00:39:07.709 --> 00:39:13.079
在JDK 8上，我想提前

00:39:10.199 --> 00:39:15.329
它们尤其是假设Java的代码

00:39:13.079 --> 00:39:17.640
版本字符串以1个点开头或

00:39:15.329 --> 00:39:21.130
假设JDK位于文件中

00:39:17.640 --> 00:39:24.490
调用RT jar将在JDK 9上失败

00:39:21.130 --> 00:39:26.710
再次请检查工具和库

00:39:24.490 --> 00:39:30.789
开发者关于哪个版本

00:39:26.710 --> 00:39:33.130
不能在JDK 9上运行需要

00:39:30.789 --> 00:39:39.640
旧版工具和

00:39:33.130 --> 00:39:43.079
库将在JDK 9上运行，因此在

00:39:39.640 --> 00:39:47.049
模块化JDK，其模块一直向下

00:39:43.079 --> 00:39:50.829
 JDK内部临时可用

00:39:47.049 --> 00:39:55.049
在JDK 9中，您可能需要升级

00:39:50.829 --> 00:40:04.599
他们知道JDK 9的工具和库

00:39:55.049 --> 00:40:07.990
总而言之，模块是一组

00:40:04.599 --> 00:40:10.720
专为自动重用而设计的软件包

00:40:07.990 --> 00:40:13.390
模块有助于迁移到模块

00:40:10.720 --> 00:40:18.390
并且您可能需要升级工具和

00:40:13.390 --> 00:40:18.390
库到支持JDK 9的版本

00:40:19.619 --> 00:40:23.950
模块中有大量

00:40:22.029 --> 00:40:27.279
我没时间说话的系统

00:40:23.950 --> 00:40:29.559
关于您可以将资源封装在

00:40:27.279 --> 00:40:31.539
模块不只是可以表达的类

00:40:29.559 --> 00:40:33.910
通过编程的可选依赖项

00:40:31.539 --> 00:40:35.829
通过服务您可以自定义

00:40:33.910 --> 00:40:37.720
使用j-link工具制作系统映像

00:40:35.829 --> 00:40:40.420
您可以立即物理删除CORBA 

00:40:37.720 --> 00:40:42.279
如果您愿意，可以旋转

00:40:40.420 --> 00:40:45.250
一个库的多个版本

00:40:42.279 --> 00:40:46.630
模块层API（如果您对此感兴趣） 

00:40:45.250 --> 00:40:49.779
这种东西我推荐两本书

00:40:46.630 --> 00:40:52.569
首先是Java 9模块化

00:40:49.779 --> 00:40:55.359
这是一个务实的演练

00:40:52.569 --> 00:40:57.759
整个模块系统和模块化JDK 

00:40:55.359 --> 00:40:59.380
另一个是Java应用程序

00:40:57.759 --> 00:41:02.230
 2012年的建筑

00:40:59.380 --> 00:41:04.180
这是构建的原则

00:41:02.230 --> 00:41:06.250
模块化应用程序无关紧要

00:41:04.180 --> 00:41:08.410
用Jada q9逻辑锯，它有

00:41:06.250 --> 00:41:10.539
无论是或

00:41:08.410 --> 00:41:13.420
不是您使用此模块系统OSGi是

00:41:10.539 --> 00:41:15.579
在标题中是一般

00:41:13.420 --> 00:41:20.259
有关构造大型Java的建议

00:41:15.579 --> 00:41:22.450
程序，所以JDK 9在这里，它在JDK上

00:41:20.259 --> 00:41:24.789
如果您是图书馆，今天点java.net 

00:41:22.450 --> 00:41:27.099
维护人员，请运行Jade EPS以查看

00:41:24.789 --> 00:41:29.109
您可以依靠什么JDK内部结构

00:41:27.099 --> 00:41:31.030
立即在JDK 8上执行此操作

00:41:29.109 --> 00:41:33.550
安装

00:41:31.030 --> 00:41:36.100
您曾经想知道的一切

00:41:33.550 --> 00:41:39.240
 JEP中讨论了模块系统

00:41:36.100 --> 00:41:41.260
这是jdk增强建议261 I 

00:41:39.240 --> 00:41:44.490
不能强调多少

00:41:41.260 --> 00:41:47.560
有价值的信息生活在杰夫（61岁） 

00:41:44.490 --> 00:41:50.140
还有JEP 260可以识别

00:41:47.560 --> 00:41:53.980
 JDK内部类是

00:41:50.140 --> 00:41:55.690
临时暴露在9号喷气机223中

00:41:53.980 --> 00:41:58.030
定义新版本的字符串

00:41:55.690 --> 00:42:00.610
以9和喷气220开头

00:41:58.030 --> 00:42:03.090
讨论我们的头饰如何消失， 

00:42:00.610 --> 00:42:06.610
模块化JDK的结构和

00:42:03.090 --> 00:42:10.030
最后喷气200提供了一个概述

00:42:06.610 --> 00:42:12.370
 Java SE和jdk模块，但是如果

00:42:10.030 --> 00:42:14.290
您已经阅读过喷射261，不会有任何

00:42:12.370 --> 00:42:15.820
惊喜，因为已经有260个人

00:42:14.290 --> 00:42:17.920
讨论了模块和类

00:42:15.820 --> 00:42:21.550
加载ism您如何针对它们进行编译

00:42:17.920 --> 00:42:23.880
并修补它们，等等，谢谢

00:42:21.550 --> 00:42:23.880
你非常

00:42:27.920 --> 00:42:33.529
我们有三分钟的问题

00:42:30.619 --> 00:42:36.859
这是一个公平的问题，我的

00:42:33.529 --> 00:42:38.750
艾伦，我不好意思，谢谢你

00:42:36.859 --> 00:42:40.519
主题演讲说，我们将成为

00:42:38.750 --> 00:42:42.680
要进行六个月的节奏

00:42:40.519 --> 00:42:46.010
意味着我们的警告将成为

00:42:42.680 --> 00:42:46.430
六个月内出现错误或出现类似情况

00:42:46.010 --> 00:42:49.160
 ation 

00:42:46.430 --> 00:42:50.420
所以问题是JDK是否已经

00:42:49.160 --> 00:42:51.980
每六个月发布一次，我们

00:42:50.420 --> 00:42:53.480
临时打印有关警告

00:42:51.980 --> 00:42:55.039
允许访问某些内容

00:42:53.480 --> 00:42:56.559
表示时钟指望一个

00:42:55.039 --> 00:43:01.130
六个月的截止日期

00:42:56.559 --> 00:43:03.920
没有什么是一成不变的

00:43:01.130 --> 00:43:08.109
不要说那是下一个

00:43:03.920 --> 00:43:10.460
释放的将是

00:43:08.109 --> 00:43:13.430
封装将被拨号，但在

00:43:10.460 --> 00:43:14.029
很快将来会更快

00:43:13.430 --> 00:43:21.529
比我们想象的

00:43:14.029 --> 00:43:24.440
我这样说吧

00:43:21.529 --> 00:43:25.819
你实际上没有幻灯片

00:43:24.440 --> 00:43:30.380
因为你也需要笔记

00:43:25.819 --> 00:43:33.500
视频是最好的，是的

00:43:30.380 --> 00:43:37.160
有什么办法可以依靠包装

00:43:33.500 --> 00:43:38.900
没有指定模块在那里

00:43:37.160 --> 00:43:41.450
任何基本需要包装的方式

00:43:38.900 --> 00:43:43.339
是的，不是模块，没有依赖

00:43:41.450 --> 00:43:46.670
依赖性的粒度为

00:43:43.339 --> 00:43:49.490
模块到模块，所以你可以有两个

00:43:46.670 --> 00:43:51.920
提供替代方案的模块

00:43:49.490 --> 00:43:54.319
您可以执行的软件包的实现

00:43:51.920 --> 00:43:58.240
我对你意味着我的服务

00:43:54.319 --> 00:43:58.240
周三谈论服务

00:44:00.200 --> 00:44:03.670
后面有个问题

00:44:07.210 --> 00:44:11.360
你好

00:44:08.840 --> 00:44:15.230
你对未来有什么了解吗

00:44:11.360 --> 00:44:29.510
关于OSGi的模块化工作站

00:44:15.230 --> 00:44:37.870
 JDK没有下一个问题战争了吗

00:44:29.510 --> 00:44:37.870
应用程序询问e4j倡议

00:44:39.760 --> 00:44:49.100
先生。罗伯特·舒尔特（Robert Schulte）有一个问题

00:44:43.700 --> 00:44:52.510
可能是吧，你可以花钱吗

00:44:49.100 --> 00:44:56.720
关于迁移库的一些话

00:44:52.510 --> 00:44:58.010
关于自动模型名称

00:44:56.720 --> 00:45:00.680
问题是如何迁移

00:44:58.010 --> 00:45:02.570
库库只是Java 

00:45:00.680 --> 00:45:05.720
如果有的话，在一天结束时上课

00:45:02.570 --> 00:45:08.120
碰巧可以访问呼叫集

00:45:05.720 --> 00:45:11.480
使用核心反射的稻草人

00:45:08.120 --> 00:45:13.490
在最近的生活中可以公平地说

00:45:11.480 --> 00:45:16.760
有些人谁说

00:45:13.490 --> 00:45:20.960
可访问的啊，就像一组可访问的

00:45:16.760 --> 00:45:22.100
支持小组在这里好吧，我有点

00:45:20.960 --> 00:45:23.570
想问你你叫他什么

00:45:22.100 --> 00:45:26.570
可以访问，但我们没时间了

00:45:23.570 --> 00:45:30.110
因此对于图书馆，如果图书馆正在尝试

00:45:26.570 --> 00:45:32.240
违反定义类

00:45:30.110 --> 00:45:33.530
他们应该使用的应用程序类加载器

00:45:32.240 --> 00:45:36.530
创建自己的类加载器

00:45:33.530 --> 00:45:38.600
具体的建议，如果只是说

00:45:36.530 --> 00:45:41.570
儿子Mis枪支保险柜仍可在

00:45:38.600 --> 00:45:43.400
 JDK 9（如果您使用的是四热） 

00:45:41.570 --> 00:45:45.260
您应该使用var的内存访问

00:45:43.400 --> 00:45:47.180
相反，然后你应该

00:45:45.260 --> 00:45:49.370
使用多重释放罐将var 

00:45:47.180 --> 00:45:50.540
在单独的目录中处理代码

00:45:49.370 --> 00:45:52.340
九点，然后你在做什么

00:45:50.540 --> 00:45:53.930
八个，可能有一个整体

00:45:52.340 --> 00:45:56.420
有关该主题的整个演示文稿都在那里

00:45:53.930 --> 00:46:00.650
一个具体的，因为这里没有人是一个

00:45:56.420 --> 00:46:03.770
图书馆维护者右手两只

00:46:00.650 --> 00:46:06.470
双手好吧，这就是一切

00:46:03.770 --> 00:46:10.340
保持麦克莱恩惊人的生态系统

00:46:06.470 --> 00:46:14.000
因此，如果您是图书馆建设者，而您

00:46:10.340 --> 00:46:17.150
想参考尚未出现的乔希

00:46:14.000 --> 00:46:20.120
模块仅在以下情况下引用它们

00:46:17.150 --> 00:46:23.000
他们有一个带有

00:46:20.120 --> 00:46:25.730
清单文件，而不是基于

00:46:23.000 --> 00:46:27.290
 jar文件名是一个很好的观点

00:46:25.730 --> 00:46:29.720
你给了我一切机会

00:46:27.290 --> 00:46:31.580
做，但我没有这样做，关键是

00:46:29.720 --> 00:46:33.920
图书馆图书馆维护错误

00:46:31.580 --> 00:46:36.530
即使他们没有声明模块

00:46:33.920 --> 00:46:39.740
明确地应该去应该

00:46:36.530 --> 00:46:42.860
确实把它放在他们的手掌，并指定

00:46:39.740 --> 00:46:46.970
自动模块名称清单条目

00:46:42.860 --> 00:46:49.100
这是提交名称的一种方式

00:46:46.970 --> 00:46:53.320
无需实际放置的模块化广口瓶

00:46:49.100 --> 00:46:55.760
模块化jar中的模块信息类，以及

00:46:53.320 --> 00:47:00.310
提交模块的稳定名称

00:46:55.760 --> 00:47:03.260
是一笔大买卖，我们鼓励图书馆

00:47:00.310 --> 00:47:04.880
维护者x'会这样做，即使他们

00:47:03.260 --> 00:47:07.430
根本没有看过

00:47:04.880 --> 00:47:08.630
封装的故事或北约或什么

00:47:07.430 --> 00:47:12.080
他们将出口或他们是什么

00:47:08.630 --> 00:47:17.240
可能很快就会要求

00:47:12.080 --> 00:47:20.020
问题是那里没有一个人

00:47:17.240 --> 00:47:20.020
后面的快速问题

00:47:20.630 --> 00:47:28.130
我喘口气Java密码学扩展

00:47:25.430 --> 00:47:33.710
像充气城堡一样，我们必须

00:47:28.130 --> 00:47:36.130
用数字证书签名

00:47:33.710 --> 00:47:39.170
从Oracle能够部署

00:47:36.130 --> 00:47:42.350
将会有什么改变

00:47:39.170 --> 00:47:45.230
这样做（如果有的话）真的是一个

00:47:42.350 --> 00:47:47.270
关于签名模块化罐子的问题

00:47:45.230 --> 00:47:50.660
艾伦可以在

00:47:47.270 --> 00:47:53.450
麦克风你的答案城堡应该

00:47:50.660 --> 00:47:55.120
保安人员

00:47:53.450 --> 00:47:57.260
配置文件略有变化

00:47:55.120 --> 00:47:59.600
因为你实际上给了安全

00:47:57.260 --> 00:48:00.650
提供者名称比类别更广泛

00:47:59.600 --> 00:48:02.350
文件，但有一个落后的

00:48:00.650 --> 00:48:05.150
保持现有性的兼容性

00:48:02.350 --> 00:48:09.860
提供者实际上在工作，我不能给

00:48:05.150 --> 00:48:11.750
您在签名的加密货币上的完整答案

00:48:09.860 --> 00:48:13.280
提供程序作为模块打包，因为

00:48:11.750 --> 00:48:14.870
那里有几个问题

00:48:13.280 --> 00:48:17.680
那只是超出了范围

00:48:14.870 --> 00:48:19.910
模块时间，但有一个安全栏

00:48:17.680 --> 00:48:23.510
明天晚上，实际上是肖恩·穆兰

00:48:19.910 --> 00:48:26.480
是合法的，这将是一个很好的

00:48:23.510 --> 00:48:28.600
让自己正确的地方谢谢

00:48:26.480 --> 00:48:28.600
再次

