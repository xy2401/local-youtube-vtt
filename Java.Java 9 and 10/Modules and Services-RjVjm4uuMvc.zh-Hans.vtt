WEBVTT
Kind: captions
Language: zh-Hans

00:00:02.919 --> 00:00:08.320
大家好9:30大家好

00:00:06.140 --> 00:00:11.570
开始了

00:00:08.320 --> 00:00:13.099
欢迎使用模块和服务我的名字

00:00:11.570 --> 00:00:16.219
是Alex Buckley我在Java工作

00:00:13.099 --> 00:00:18.619
 Oracle的平台小组我编辑Java 

00:00:16.219 --> 00:00:20.989
语言规范和Java 

00:00:18.619 --> 00:00:24.050
虚拟机规范以及

00:00:20.989 --> 00:00:26.359
我已经从事很多年了

00:00:24.050 --> 00:00:29.869
曾经在模块上工作过的人

00:00:26.359 --> 00:00:32.059
 JDK 9中的系统我可以做几个

00:00:29.869 --> 00:00:34.780
我拥有你们所有人的时候

00:00:32.059 --> 00:00:38.560
在这里请谁下载了JDK 9 

00:00:34.780 --> 00:00:43.370
相当多的人熟悉

00:00:38.560 --> 00:00:46.250
 Metron斜杠服务数量少

00:00:43.370 --> 00:00:49.580
熟悉Java util的好手

00:00:46.250 --> 00:00:51.230
服务加载程序有些相同

00:00:49.580 --> 00:00:52.910
但也有不同的手

00:00:51.230 --> 00:00:56.570
有趣的嗯，他建立了一个

00:00:52.910 --> 00:00:59.320
调用服务加载程序的应用程序

00:00:56.570 --> 00:01:04.100
一个小特性，我们真的缩小了

00:00:59.320 --> 00:01:07.130
这就是我所说的

00:01:04.100 --> 00:01:09.469
经常说模块很

00:01:07.130 --> 00:01:12.770
与大多数语言功能不同

00:01:09.469 --> 00:01:15.310
例如lambdas lambdas是关于

00:01:12.770 --> 00:01:18.469
小程序的形状

00:01:15.310 --> 00:01:21.109
个人为循环变成方法

00:01:18.469 --> 00:01:24.710
可以使用lambda参数调用

00:01:21.109 --> 00:01:26.799
重塑程序以使用lambda 

00:01:24.710 --> 00:01:29.329
有人注意到

00:01:26.799 --> 00:01:32.359
模块与程序的形状有关

00:01:29.329 --> 00:01:35.119
大体上我们处理课程

00:01:32.359 --> 00:01:38.090
包装并从那里变大

00:01:35.119 --> 00:01:40.060
您重塑模块很可能

00:01:38.090 --> 00:01:44.030
别人会注意到

00:01:40.060 --> 00:01:46.609
尽管模块在源代码中表示

00:01:44.030 --> 00:01:48.829
他们所在的Java语言的代码

00:01:46.609 --> 00:01:53.319
他们在语言之外的某些方式

00:01:48.829 --> 00:01:56.329
定义架构而不是代码I 

00:01:53.319 --> 00:01:58.999
这么说是因为我会提供的服务

00:01:56.329 --> 00:02:02.029
谈论这里是最纯正的

00:01:58.999 --> 00:02:04.759
建筑的形式

00:02:02.029 --> 00:02:07.549
由模块系统提供的

00:02:04.759 --> 00:02:10.550
你必须设计的东西

00:02:07.549 --> 00:02:12.890
显然，实际上有可能

00:02:10.550 --> 00:02:15.810
在你的日常工作中，你永远不会来

00:02:12.890 --> 00:02:17.750
跨服务和所有

00:02:15.810 --> 00:02:19.620
所以如果你想撒种

00:02:17.750 --> 00:02:21.150
面向服务的架构

00:02:19.620 --> 00:02:23.700
这不是关于任何人的事情

00:02:21.150 --> 00:02:27.630
想，所以不，我想我可以接受

00:02:23.700 --> 00:02:29.459
该行不在演示文稿中，所以现在

00:02:27.630 --> 00:02:32.900
我们在这里谈论三个

00:02:29.459 --> 00:02:35.970
 JDK九是什么服务

00:02:32.900 --> 00:02:41.790
他们可以做什么以及如何做

00:02:35.970 --> 00:02:47.069
旧的代码更加模块化，所以

00:02:41.790 --> 00:02:49.709
服务，我也应该检查

00:02:47.069 --> 00:02:51.750
每个人都在星期一看到主题演讲， 

00:02:49.709 --> 00:02:55.019
星期一没有看到主题演讲

00:02:51.750 --> 00:03:00.709
有点不公平，好吧，有人做到了

00:02:55.019 --> 00:03:04.200
任何人都看过其他模块化讨论

00:03:00.709 --> 00:03:06.510
很好，很多手都很好

00:03:04.200 --> 00:03:08.580
所以这是对那些的加法

00:03:06.510 --> 00:03:10.920
你会你会从那里建立起来

00:03:08.580 --> 00:03:13.860
所以当我们谈论模块时

00:03:10.920 --> 00:03:18.090
通常谈论两件事模块

00:03:13.860 --> 00:03:20.750
依赖项和包导出Java 

00:03:18.090 --> 00:03:24.090
桌面是包含以下内容的JDK模块

00:03:20.750 --> 00:03:27.299
您可以看到AWT和摆动

00:03:24.090 --> 00:03:30.090
表示对java xml的依赖

00:03:27.299 --> 00:03:33.540
一些内部实现的模块

00:03:30.090 --> 00:03:36.209
原因，以便它可以访问所有

00:03:33.540 --> 00:03:40.950
 Java导出的api中的公共类型

00:03:36.209 --> 00:03:43.799
 XML和Java桌面导出

00:03:40.950 --> 00:03:46.639
 java.awt包，以便任何人

00:03:43.799 --> 00:03:49.650
需要Java桌面自己

00:03:46.639 --> 00:03:55.350
访问导出的公共类型

00:03:49.650 --> 00:04:00.329
 AWT API Java之间的耦合

00:03:55.350 --> 00:04:03.109
桌面和Java XML非常紧密，如果

00:04:00.329 --> 00:04:05.850
编译时找不到Java xml 

00:04:03.109 --> 00:04:10.290
然后是需要它的Java桌面

00:04:05.850 --> 00:04:12.780
无法建立，如果不是Java xml 

00:04:10.290 --> 00:04:16.049
在运行时发现，然后没有系统

00:04:12.780 --> 00:04:19.500
取决于Java桌面是否可以启动

00:04:16.049 --> 00:04:22.160
因为台式机对XML的依赖是

00:04:19.500 --> 00:04:22.160
未解决

00:04:23.840 --> 00:04:30.240
还有另一种耦合

00:04:27.300 --> 00:04:32.880
模块之间的距离比

00:04:30.240 --> 00:04:36.900
它是如此有用，我们已经建立了它

00:04:32.880 --> 00:04:39.840
进入模块系统，它涉及到一个

00:04:36.900 --> 00:04:44.180
模块的请求与实现

00:04:39.840 --> 00:04:47.520
接口和其他模块提供

00:04:44.180 --> 00:04:48.540
我是该接口的实现

00:04:47.520 --> 00:04:49.650
会再说一遍

00:04:48.540 --> 00:04:52.260
因为这就是整个

00:04:49.650 --> 00:04:54.210
演示是关于一个模块的

00:04:52.260 --> 00:04:56.930
要求实施

00:04:54.210 --> 00:05:00.930
其他模块提供的接口

00:04:56.930 --> 00:05:04.200
该接口的实现

00:05:00.930 --> 00:05:07.830
 Java桌面模块可以

00:05:04.200 --> 00:05:11.160
要求实施一些印刷品

00:05:07.830 --> 00:05:15.120
服务查找界面，而另一个

00:05:11.160 --> 00:05:19.110
模块打印库有一些类

00:05:15.120 --> 00:05:22.410
在以下位置实现打印服务查找

00:05:19.110 --> 00:05:25.890
 Java桌面模块中的运行时代码

00:05:22.410 --> 00:05:30.030
做打印可以叫简单

00:05:25.890 --> 00:05:33.810
标准API以获取

00:05:30.030 --> 00:05:36.950
打印服务在以下位置查找实例

00:05:33.810 --> 00:05:39.900
这种情况将是一种快速打印

00:05:36.950 --> 00:05:44.130
从print Lib模块，但Java 

00:05:39.900 --> 00:05:46.680
桌面不需要打印Lib this 

00:05:44.130 --> 00:05:49.320
意味着可以解决Java桌面

00:05:46.680 --> 00:05:51.750
通过模块系统即使打印库

00:05:49.320 --> 00:05:58.170
在编译时不存在或

00:05:51.750 --> 00:06:00.300
运行时也打印lib不会导出

00:05:58.170 --> 00:06:03.150
包含那个快速包

00:06:00.300 --> 00:06:05.250
打印类快速打印是它的一个类

00:06:03.150 --> 00:06:08.370
不是其他模块应该使用的API 

00:06:05.250 --> 00:06:10.650
直接访问其他模块，例如Java 

00:06:08.370 --> 00:06:13.050
桌面应调用快速方法

00:06:10.650 --> 00:06:18.930
仅通过打印服务打印

00:06:13.050 --> 00:06:21.000
查找界面该模块做什么

00:06:18.930 --> 00:06:24.630
声明看起来像这样

00:06:21.000 --> 00:06:27.990
关系，这是非常简单的Java 

00:06:24.630 --> 00:06:31.170
桌面会说它使用打印

00:06:27.990 --> 00:06:33.840
服务查询和Print Lib模块

00:06:31.170 --> 00:06:35.760
会说它提供打印服务

00:06:33.840 --> 00:06:39.630
用

00:06:35.760 --> 00:06:42.840
印刷玻璃印刷服务查找为

00:06:39.630 --> 00:06:45.780
称为服务类型

00:06:42.840 --> 00:06:47.460
通常是一个接口，但可以是

00:06:45.780 --> 00:06:51.690
抽象类甚至是具体类

00:06:47.460 --> 00:06:55.410
如果您真的需要这么快

00:06:51.690 --> 00:06:58.380
 print是提供者类，提供者

00:06:55.410 --> 00:07:00.300
班级必须是一个具体的班级

00:06:58.380 --> 00:07:03.030
实现或扩展服务类型

00:07:00.300 --> 00:07:04.170
并声明没有艺术的构造函数

00:07:03.030 --> 00:07:07.740
该ik，以便可以实例化

00:07:04.170 --> 00:07:10.050
通过模块系统我们说Java 

00:07:07.740 --> 00:07:13.590
桌面是他停止的消费者模块

00:07:10.050 --> 00:07:16.830
带有深蓝色箭头并打印lib 

00:07:13.590 --> 00:07:22.110
是提供商模块，他有紫色

00:07:16.830 --> 00:07:24.930
 Java桌面中的箭头通知您

00:07:22.110 --> 00:07:30.290
看到需要带一个名为

00:07:24.930 --> 00:07:35.400
 java xml导出采用包名称和

00:07:30.290 --> 00:07:38.280
用途取三个不同的类型名称

00:07:35.400 --> 00:07:40.500
三种不同模块的属性

00:07:38.280 --> 00:07:46.080
三种不同的关键字

00:07:40.500 --> 00:07:49.170
在打印库中提供的参数

00:07:46.080 --> 00:07:51.530
接受两个类型名称，一个用于服务

00:07:49.170 --> 00:07:54.660
类型，一个用于提供程序类， 

00:07:51.530 --> 00:07:58.050
提供指令的是模块化

00:07:54.660 --> 00:08:00.300
等效于称为会议室的文件

00:07:58.050 --> 00:08:03.630
斜线服务斜线打印服务

00:08:00.300 --> 00:08:08.160
查找将列出快速

00:08:03.630 --> 00:08:11.190
如果不是jar，则在JDK之前的九个类上打印

00:08:08.160 --> 00:08:13.800
文件已编译了模块信息类

00:08:11.190 --> 00:08:16.410
从这个模块声明然后

00:08:13.800 --> 00:08:18.900
 Metron服务中的mod中的文件是

00:08:16.410 --> 00:08:22.490
忽略了模块声明的思想

00:08:18.900 --> 00:08:22.490
使用并提供胜利

00:08:22.820 --> 00:08:28.050
只是为了澄清这里发生的事情

00:08:25.350 --> 00:08:31.380
如果没有依赖注入

00:08:28.050 --> 00:08:35.190
您的模块说使用某种服务类型

00:08:31.380 --> 00:08:38.340
而且您有该服务的领域

00:08:35.190 --> 00:08:40.110
类型，那么情况并非如此

00:08:38.340 --> 00:08:43.770
该服务类型的实例是

00:08:40.110 --> 00:08:46.620
神奇地分配给你的领域

00:08:43.770 --> 00:08:49.620
不得不要求一个实例

00:08:46.620 --> 00:08:55.710
类型的服务，所以让我们

00:08:49.620 --> 00:08:59.660
谈论获得一个实例

00:08:55.710 --> 00:09:01.710
打印服务查找接口代码

00:08:59.660 --> 00:09:05.660
 Java桌面中的假设代码

00:09:01.710 --> 00:09:10.230
模块采用服务加载程序API 

00:09:05.660 --> 00:09:12.600
 Java 6中引入的关键方法

00:09:10.230 --> 00:09:16.110
第二行的服务加载程序是

00:09:12.600 --> 00:09:18.779
加载需要一个类对象java.lang 

00:09:16.110 --> 00:09:22.110
代表服务类型的类

00:09:18.779 --> 00:09:25.080
打印服务查找停靠站使用时间最长

00:09:22.110 --> 00:09:28.610
因为Java桌面包含此代码

00:09:25.080 --> 00:09:31.920
说它使用打印服务查找

00:09:28.610 --> 00:09:34.860
该加载方法返回服务

00:09:31.920 --> 00:09:39.600
能够屈服的加载器对象

00:09:34.860 --> 00:09:42.330
该服务的实例键入

00:09:39.600 --> 00:09:45.650
模块系统在幕后工作

00:09:42.330 --> 00:09:48.210
协助服务装载者模块系统

00:09:45.650 --> 00:09:51.930
自动发现提供者模块

00:09:48.210 --> 00:09:55.410
在启动时，通过扫描

00:09:51.930 --> 00:09:58.440
 Java运行时映像和模块化jar 

00:09:55.410 --> 00:10:00.570
模块路径现在可能有很多

00:09:58.440 --> 00:10:02.790
提供程序模块的数量可能会更多

00:10:00.570 --> 00:10:05.130
一个供应商模块进行打印

00:10:02.790 --> 00:10:07.920
服务查询意味着不止一个

00:10:05.130 --> 00:10:11.670
提供一个实现

00:10:07.920 --> 00:10:14.610
接口服务的每个实例

00:10:11.670 --> 00:10:17.250
服务类型的加载程序收益为

00:10:14.610 --> 00:10:19.560
不同的提供者类有帮助

00:10:17.250 --> 00:10:23.100
的服务负载实现了可迭代

00:10:19.560 --> 00:10:27.270
 P是服务的PS L 

00:10:23.100 --> 00:10:29.880
加载程序对象实现可迭代，因此您

00:10:27.270 --> 00:10:31.980
可以通过每种方式

00:10:29.880 --> 00:10:35.089
已知可服务的可用实例

00:10:31.980 --> 00:10:39.540
装载机寻找您喜欢的那个

00:10:35.089 --> 00:10:41.580
在这种情况下，Java桌面希望找到

00:10:39.540 --> 00:10:44.339
打印服务查找实现

00:10:41.580 --> 00:10:47.240
提供专业的印刷服务

00:10:44.339 --> 00:10:49.320
涉及一种特殊的点味

00:10:47.240 --> 00:10:50.400
不知道是什么文档风格，但我

00:10:49.320 --> 00:10:55.380
知道他们与打印服务有关

00:10:50.400 --> 00:10:58.380
如果服务加载程序未生成，则进行查找

00:10:55.380 --> 00:11:01.110
打印服务查找的实例

00:10:58.380 --> 00:11:03.510
或是否这样做，但由于某种原因

00:11:01.110 --> 00:11:05.670
他们在for循环体内

00:11:03.510 --> 00:11:08.310
提供所需的专业服务

00:11:05.670 --> 00:11:09.720
这种情况下通过代码然后代码有

00:11:08.310 --> 00:11:11.820
决定在这种情况下该怎么做

00:11:09.720 --> 00:11:15.360
决定返回服务中的默认值

00:11:11.820 --> 00:11:18.810
对象，所有这些代码将

00:11:15.360 --> 00:11:21.120
通常生活在静态方法中

00:11:18.810 --> 00:11:25.050
服务类型，以便打印服务

00:11:21.120 --> 00:11:26.160
查找是其自己的工厂，用于获取

00:11:25.050 --> 00:11:30.810
实作

00:11:26.160 --> 00:11:33.690
现在无法使用JDK 8接口

00:11:30.810 --> 00:11:35.970
有静态方法，所以大多数服务

00:11:33.690 --> 00:11:39.180
打印服务器查找的类型是抽象的

00:11:35.970 --> 00:11:42.050
类而不是接口，但现在

00:11:39.180 --> 00:11:44.790
接口可以具有静态方法

00:11:42.050 --> 00:11:48.620
对于服务类型来说更常见

00:11:44.790 --> 00:11:48.620
将打印服务查找为接口

00:11:49.460 --> 00:11:57.270
在这一点上，每个人都问是否服务

00:11:54.480 --> 00:11:59.040
加载程序会找到所有

00:11:57.270 --> 00:12:01.320
实现该打印服务查找

00:11:59.040 --> 00:12:01.800
接口并产生每个的实例

00:12:01.320 --> 00:12:04.710
一

00:12:01.800 --> 00:12:07.980
 Java桌面如何包含该内容

00:12:04.710 --> 00:12:10.110
代码指定快速打印是我的

00:12:07.980 --> 00:12:14.610
最喜欢的打印服务实现

00:12:10.110 --> 00:12:17.640
查找或如何打印

00:12:14.610 --> 00:12:19.500
 lib模块指定我的班快

00:12:17.640 --> 00:12:23.010
打印是最好的实现

00:12:19.500 --> 00:12:25.470
打印服务la carpa相信我

00:12:23.010 --> 00:12:28.350
每个人问的另一个问题是关于

00:12:25.470 --> 00:12:31.350
订购Java桌面如何

00:12:28.350 --> 00:12:35.100
消费者模块指定自己喜欢的模块

00:12:31.350 --> 00:12:37.580
打印的快速打印实现

00:12:35.100 --> 00:12:39.930
净打印的表面查找

00:12:37.580 --> 00:12:42.240
实施，但会很高兴

00:12:39.930 --> 00:12:45.210
如果使用快速打印，则可以使用网络打印

00:12:42.240 --> 00:12:48.630
现在不存在，请记住

00:12:45.210 --> 00:12:51.300
通常在右侧的提供程序模块

00:12:48.630 --> 00:12:53.640
彼此不认识，所以他们

00:12:51.300 --> 00:12:57.540
无法合理地参与

00:12:53.640 --> 00:13:00.090
选择或排序实现

00:12:57.540 --> 00:13:02.160
消费者模块Java桌面是

00:13:00.090 --> 00:13:04.740
显然合适的地方

00:13:02.160 --> 00:13:07.470
但这很快导致复杂

00:13:04.740 --> 00:13:09.370
编码提供程序首选项的方案

00:13:07.470 --> 00:13:11.320
在模块声明中

00:13:09.370 --> 00:13:15.370
现在我们试图保留该模块

00:13:11.320 --> 00:13:18.580
系统简单，答案无人能及

00:13:15.370 --> 00:13:21.070
指定静态的全局种类

00:13:18.580 --> 00:13:25.180
提供者类别的偏好至少

00:13:21.070 --> 00:13:30.130
不在模块声明中

00:13:25.180 --> 00:13:32.830
消费者代替选择的基础

00:13:30.130 --> 00:13:36.730
一个提供者类比另一个提供者类是

00:13:32.830 --> 00:13:38.890
应用程序依赖性是一种选择

00:13:36.730 --> 00:13:42.070
消费者模块必须由

00:13:38.890 --> 00:13:44.200
检查可用属性

00:13:42.070 --> 00:13:46.840
提供者类回来时

00:13:44.200 --> 00:13:49.390
从服务加载程序和属性我

00:13:46.840 --> 00:13:52.300
并不意味着反思他们的领域

00:13:49.390 --> 00:13:55.540
我的意思是调用服务的方法

00:13:52.300 --> 00:13:59.890
在发现的每个实例上键入

00:13:55.540 --> 00:14:02.250
提供程序类，因此请回想一下Java 

00:13:59.890 --> 00:14:05.230
桌面，这是Java桌面中的代码

00:14:02.250 --> 00:14:06.640
服务加载器调用

00:14:05.230 --> 00:14:08.890
遍历整个印刷品

00:14:06.640 --> 00:14:11.650
它调用的表面查找实现

00:14:08.890 --> 00:14:14.110
获取默认的打印服务方法

00:14:11.650 --> 00:14:16.480
查找打印服务的每个实例

00:14:14.110 --> 00:14:19.120
然后在

00:14:16.480 --> 00:14:21.220
结果是支持点式决定

00:14:19.120 --> 00:14:24.090
如果该实例可以接受

00:14:21.220 --> 00:14:27.280
任何Java桌面正在尝试做的事情

00:14:24.090 --> 00:14:29.800
使用者模块不应为

00:14:27.280 --> 00:14:32.920
与身份有关

00:14:29.800 --> 00:14:35.560
提供程序类提供程序类

00:14:32.920 --> 00:14:38.620
是提供者的私人详细信息

00:14:35.560 --> 00:14:41.830
实际上，我们强烈建议不要使用模块

00:14:38.620 --> 00:14:43.600
提供者模块导出其

00:14:41.830 --> 00:14:46.270
提供程序类，因为如果它们是

00:14:43.600 --> 00:14:49.800
出口它鼓励这样的人

00:14:46.270 --> 00:14:52.600
围绕接口编写代码的人， 

00:14:49.800 --> 00:14:54.190
直接针对哪个阶级

00:14:52.600 --> 00:14:57.360
点你去过你已经失去了

00:14:54.190 --> 00:14:57.360
松耦合的好处

00:14:59.920 --> 00:15:04.089
所以我的建议是考虑一项服务

00:15:02.470 --> 00:15:06.299
键入其接口

00:15:04.089 --> 00:15:10.420
实现将被发现为

00:15:06.299 --> 00:15:12.309
粗粒选择器服务类型

00:15:10.420 --> 00:15:15.309
如打印服务查找应提供

00:15:12.309 --> 00:15:18.040
关于足够的描述符方法

00:15:15.309 --> 00:15:20.730
消费者的实施质量

00:15:18.040 --> 00:15:23.259
选择最佳提供者类别的模块

00:15:20.730 --> 00:15:25.629
在到目前为止的示例中，打印服务

00:15:23.259 --> 00:15:29.519
查找服务类型打印服务

00:15:25.629 --> 00:15:33.609
查找实际上是真实的代理

00:15:29.519 --> 00:15:36.730
在那里打印感兴趣的服务对象

00:15:33.609 --> 00:15:39.480
可能是打印服务的许多实例

00:15:36.730 --> 00:15:42.910
在不同模块中的系统上查找

00:15:39.480 --> 00:15:45.220
每个代表许多实例

00:15:42.910 --> 00:15:49.089
打印服务，但能够提供

00:15:45.220 --> 00:15:52.389
消费者的默认打印服务

00:15:49.089 --> 00:15:55.179
服务类型可能会出现的另一种情况

00:15:52.389 --> 00:15:57.910
直接代表感兴趣的对象

00:15:55.179 --> 00:16:00.189
在此示例中，打印服务

00:15:57.910 --> 00:16:03.040
界面本身或底部

00:16:00.189 --> 00:16:06.040
提供足够丰富的描述符

00:16:03.040 --> 00:16:08.529
可能与风味相关的方法

00:16:06.040 --> 00:16:13.809
也许是合法的服务类型

00:16:08.529 --> 00:16:16.239
自己设计多少抽象

00:16:13.809 --> 00:16:19.919
您的服务类型取决于您

00:16:16.239 --> 00:16:23.350
应用的主要因素是有多沉重

00:16:19.919 --> 00:16:25.089
最终的目的是为了

00:16:23.350 --> 00:16:28.299
例如，如果其中之一的性质

00:16:25.089 --> 00:16:29.709
打印服务的事情就是实例化

00:16:28.299 --> 00:16:32.249
可能很慢

00:16:29.709 --> 00:16:35.369
也许是因为提供程序类可能

00:16:32.249 --> 00:16:38.290
扫描网络以寻找打印机

00:16:35.369 --> 00:16:42.789
那么印刷服务就有价值

00:16:38.290 --> 00:16:44.889
查找实例充当代理

00:16:42.789 --> 00:16:47.739
决定是否打印服务实例

00:16:44.889 --> 00:16:50.199
实际可用，但如果自然

00:16:47.739 --> 00:16:53.289
打印服务的一个特点是它很便宜

00:16:50.199 --> 00:16:56.220
并易于实例化然后值

00:16:53.289 --> 00:17:00.039
打印服务查找作为代理

00:16:56.220 --> 00:17:01.509
服务类型减少了，我希望它是

00:17:00.039 --> 00:17:03.639
清除这与

00:17:01.509 --> 00:17:06.100
服务与印刷无关

00:17:03.639 --> 00:17:08.860
服务服务是完全

00:17:06.100 --> 00:17:10.480
一般机制，但以例证为例

00:17:08.860 --> 00:17:11.860
我必须为

00:17:10.480 --> 00:17:16.360
特定的服务类型和

00:17:11.860 --> 00:17:18.010
一小组提供程序类，然后

00:17:16.360 --> 00:17:19.809
这个问题很好，我有

00:17:18.010 --> 00:17:21.520
多个提供程序类我该怎么办

00:17:19.809 --> 00:17:23.709
当然，另一个问题是

00:17:21.520 --> 00:17:28.420
我没有提供者课程，我该怎么办

00:17:23.709 --> 00:17:30.940
我们将继续讲，这很有趣

00:17:28.420 --> 00:17:36.220
查看服务类型

00:17:30.940 --> 00:17:40.090
 Java桌面消耗的接口

00:17:36.220 --> 00:17:41.920
蓝色的服务类型是代理或

00:17:40.090 --> 00:17:44.770
工厂或包装，如果你喜欢

00:17:41.920 --> 00:17:46.330
打印服务查找在其中

00:17:44.770 --> 00:17:49.500
中间有印刷吗

00:17:46.330 --> 00:17:52.120
服务查找旁边的类型

00:17:49.500 --> 00:17:55.210
流打印服务工厂是相同的

00:17:52.120 --> 00:17:59.080
交易，并从顶部看你会

00:17:55.210 --> 00:18:01.660
输入实例上的调用方法

00:17:59.080 --> 00:18:04.000
方法描述符以便找到

00:18:01.660 --> 00:18:07.120
提供所需输入法的一种

00:18:04.000 --> 00:18:10.360
首都我首都m，你会打电话

00:18:07.120 --> 00:18:14.110
图像输入实例的方法

00:18:10.360 --> 00:18:15.970
流SPI服务提供商接口

00:18:14.110 --> 00:18:20.650
选择一种最能转换您的

00:18:15.970 --> 00:18:24.850
数据进入图像输入流

00:18:20.650 --> 00:18:27.970
这五种SPI类型的Javadoc 

00:18:24.850 --> 00:18:30.910
靠近顶部甚至说意图是

00:18:27.970 --> 00:18:34.000
相对便宜

00:18:30.910 --> 00:18:37.330
加载并检查所有可用服务

00:18:34.000 --> 00:18:41.650
提供程序类，即

00:18:37.330 --> 00:18:44.200
图像输入流SPI这些类可能

00:18:41.650 --> 00:18:47.230
然后用于定位和实例化

00:18:44.200 --> 00:18:49.540
更多重量级的课程

00:18:47.230 --> 00:18:52.679
在这种情况下执行实际工作

00:18:49.540 --> 00:18:55.360
图像读取器的实例图像写入器

00:18:52.679 --> 00:18:59.890
图像代码转换器图像输入流和

00:18:55.360 --> 00:19:04.419
图像输出流中的服务类型

00:18:59.890 --> 00:19:06.970
布朗不是代理人或工厂，而是

00:19:04.419 --> 00:19:07.660
而是它们代表实际的对象

00:19:06.970 --> 00:19:11.530
出于兴趣

00:19:07.660 --> 00:19:15.400
因此，虽然MIDI设备提供商

00:19:11.530 --> 00:19:19.390
蓝色的中间只是代表

00:19:15.400 --> 00:19:22.840
获取MIDI设备对象MIDI文件

00:19:19.390 --> 00:19:24.790
布朗下面的读者是真实的

00:19:22.840 --> 00:19:25.540
业务逻辑MIDI的提供程序类

00:19:24.790 --> 00:19:27.790
文件阅读器

00:19:25.540 --> 00:19:32.050
知道如何实际获取MIDI 

00:19:27.790 --> 00:19:34.930
文件的顺序最底线是

00:19:32.050 --> 00:19:37.800
服务加载API和模块

00:19:34.930 --> 00:19:40.000
系统对

00:19:37.800 --> 00:19:43.720
服务设计的粒度

00:19:40.000 --> 00:19:46.390
类型，表示类似

00:19:43.720 --> 00:19:53.560
实施质量问题是

00:19:46.390 --> 00:19:55.030
现在不包含在模块声明中

00:19:53.560 --> 00:19:58.030
您可能想知道在哪里

00:19:55.030 --> 00:20:01.540
服务类型打印服务查找

00:19:58.030 --> 00:20:05.470
界面实际上是服务类型

00:20:01.540 --> 00:20:09.250
只是一个包中的接口

00:20:05.470 --> 00:20:13.180
该模块几乎总是

00:20:09.250 --> 00:20:17.140
从模块中导出所有这些

00:20:13.180 --> 00:20:19.450
绿色箭头，这样其他模块

00:20:17.140 --> 00:20:23.230
因为Java桌面是消费者和印刷品

00:20:19.450 --> 00:20:25.450
笔尖作为提供者可以要求

00:20:23.230 --> 00:20:31.990
服务类型模块并访问

00:20:25.450 --> 00:20:35.470
服务类型诸如Java之类的使用者模块

00:20:31.990 --> 00:20:38.770
桌面需要访问服务类型

00:20:35.470 --> 00:20:42.580
为用户指示深蓝色

00:20:38.770 --> 00:20:43.600
箭头和用于员工的代码

00:20:42.580 --> 00:20:46.390
服务加载器

00:20:43.600 --> 00:20:47.980
获取服务类型的实例

00:20:46.390 --> 00:20:49.810
换句话说，打印服务查找

00:20:47.980 --> 00:20:52.030
类型名称实际上在

00:20:49.810 --> 00:20:58.690
 Java桌面，因此可以真正访问

00:20:52.030 --> 00:21:01.870
跨模块有提供者模块

00:20:58.690 --> 00:21:04.690
像打印神经网络打印需要

00:21:01.870 --> 00:21:07.930
访问其提供的服务类型

00:21:04.690 --> 00:21:10.120
指令，当然是针对班级的

00:21:07.930 --> 00:21:14.130
实际的快速打印或净打印

00:21:10.120 --> 00:21:18.040
实现或扩展服务类型

00:21:14.130 --> 00:21:20.410
通常会有很多消费者

00:21:18.040 --> 00:21:22.840
左侧的模块和许多提供商

00:21:20.410 --> 00:21:26.170
特定服务右侧的模块

00:21:22.840 --> 00:21:29.170
输入使用者模块会说需要

00:21:26.170 --> 00:21:32.980
并在提供商模块将使用时使用

00:21:29.170 --> 00:21:34.570
说出要求并提供箭头

00:21:32.980 --> 00:21:37.240
他们都看起来很复杂

00:21:34.570 --> 00:21:39.110
引出，但浏览的来源

00:21:37.240 --> 00:21:41.960
模块声明

00:21:39.110 --> 00:21:43.760
需要用户需要提供品牌

00:21:41.960 --> 00:21:47.570
很清楚什么模块

00:21:43.760 --> 00:21:50.750
关系是这样的

00:21:47.570 --> 00:21:52.519
在某种程度上有这个吗

00:21:50.750 --> 00:21:54.380
即使你在做一个

00:21:52.519 --> 00:21:56.210
 9之前的服务加载程序是

00:21:54.380 --> 00:21:59.299
这些到底是怎么回事

00:21:56.210 --> 00:22:03.019
之间的基本关系

00:21:59.299 --> 00:22:05.330
消费者和提供者的好处

00:22:03.019 --> 00:22:07.640
新闻是如果您浏览了例如JDK 

00:22:05.330 --> 00:22:10.760
模块摘要甚至Javadoc 

00:22:07.640 --> 00:22:12.919
由您自己的模块产生的

00:22:10.760 --> 00:22:15.950
容易看到哪些模块是消费者

00:22:12.919 --> 00:22:18.559
以及什么和哪些模块

00:22:15.950 --> 00:22:21.110
提供者，以及那是什么

00:22:18.559 --> 00:22:23.510
绝对处于高级过度

00:22:21.110 --> 00:22:25.820
用于服务加载的调用和

00:22:23.510 --> 00:22:32.990
想知道在类路径上的罐子

00:22:25.820 --> 00:22:37.429
在Metron服务中拥有所有文件

00:22:32.990 --> 00:22:40.159
说不是服务员

00:22:37.429 --> 00:22:44.269
要在其他模块中定义的类型

00:22:40.159 --> 00:22:46.970
比消费者和提供者

00:22:44.269 --> 00:22:50.570
 JDK是常见的模块

00:22:46.970 --> 00:22:53.690
定义服务类型并将其导出到

00:22:50.570 --> 00:22:57.409
也是为此的消费者模块

00:22:53.690 --> 00:23:01.789
服务类型，例如Java 

00:22:57.409 --> 00:23:05.889
桌面模块导出java.awt mSpy 

00:23:01.789 --> 00:23:09.080
包装在顶部，以便其他模块

00:23:05.889 --> 00:23:14.360
可以实现spi类型并充当

00:23:09.080 --> 00:23:19.549
提供程序模块和Java桌面使用

00:23:14.360 --> 00:23:22.549
在右侧java.awt mSpy的顶部

00:23:19.549 --> 00:23:24.740
输入法描述符，因此代码在

00:23:22.549 --> 00:23:29.090
 Java桌面可以使用服务加载程序

00:23:24.740 --> 00:23:31.909
获得该服务类型的实例很多

00:23:29.090 --> 00:23:34.480
 JDK中的知名框架，例如

00:23:31.909 --> 00:23:37.429
记录文件系统和日期/时间

00:23:34.480 --> 00:23:40.240
通过支持这种定制

00:23:37.429 --> 00:23:40.240
提供者模块

00:23:42.170 --> 00:23:48.350
在JDK中也相对常见

00:23:45.170 --> 00:23:51.790
消费者模块也可以

00:23:48.350 --> 00:23:54.290
提供程序模块，例如Java桌面

00:23:51.790 --> 00:23:57.290
使用打印服务查找确实可以

00:23:54.290 --> 00:24:00.530
并且它提供了一个实现

00:23:57.290 --> 00:24:05.000
以Sun打印服务器的形式

00:24:00.530 --> 00:24:07.940
查找提供程序，这允许在

00:24:05.000 --> 00:24:11.000
返回打印服务的Java桌面

00:24:07.940 --> 00:24:13.010
可以保证它总是可以返回

00:24:11.000 --> 00:24:15.440
至少有一些默认情况

00:24:13.010 --> 00:24:19.520
提供程序类一些打印打印服务

00:24:15.440 --> 00:24:21.880
查找提供商最终您可以看到

00:24:19.520 --> 00:24:25.730
像Java桌面这样的单个模块

00:24:21.880 --> 00:24:27.650
可能包含服务类型和

00:24:25.730 --> 00:24:30.320
用户指令以帮助代码

00:24:27.650 --> 00:24:32.990
雇用服务加载者并提供

00:24:30.320 --> 00:24:40.520
指定一个或多个的指令

00:24:32.990 --> 00:24:44.000
提供程序类，这就是服务

00:24:40.520 --> 00:24:46.400
服务关系的使用和

00:24:44.000 --> 00:24:49.400
提供我们一流的东西

00:24:46.400 --> 00:24:52.360
针对模块系统编程

00:24:49.400 --> 00:24:56.390
服务类型是使用者模块

00:24:52.360 --> 00:24:58.160
允许提供者模块和

00:24:56.390 --> 00:25:03.590
提供者类要坚决

00:24:58.160 --> 00:25:05.540
封装并且许多JDK框架都在使用

00:25:03.590 --> 00:25:08.270
服务我不应该说使用原因使用

00:25:05.540 --> 00:25:13.060
 ism关键字依赖于服务

00:25:08.270 --> 00:25:13.060
服务并根据他们进行定制

00:25:15.820 --> 00:25:26.350
所以继续介绍如何使用服务

00:25:22.520 --> 00:25:26.350
特定用例

00:25:27.860 --> 00:25:35.070
很明显，服务让

00:25:31.620 --> 00:25:37.050
您插入的不是

00:25:35.070 --> 00:25:39.150
程序在编译时已知

00:25:37.050 --> 00:25:42.330
通过以下方式动态发现它们

00:25:39.150 --> 00:25:45.150
服务加载器的示例说明

00:25:42.330 --> 00:25:50.430
我推荐Java 9模块化

00:25:45.150 --> 00:25:53.880
这本书本周不是

00:25:50.430 --> 00:25:55.830
很明显，服务实际上是

00:25:53.880 --> 00:25:57.660
编码多个

00:25:55.830 --> 00:26:00.930
之间的复杂关系

00:25:57.660 --> 00:26:03.330
否则可能会出现的模块

00:26:00.930 --> 00:26:05.190
不受模块系统的支持

00:26:03.330 --> 00:26:07.790
特别是我要讲的是

00:26:05.190 --> 00:26:14.630
可选模块依赖关系整齐

00:26:07.790 --> 00:26:18.240
以服务编码为例

00:26:14.630 --> 00:26:23.580
考虑一下Java脚本模块

00:26:18.240 --> 00:26:26.670
 JDK提供了一个评估API 

00:26:23.580 --> 00:26:30.230
代码片段详细介绍了该API 

00:26:26.670 --> 00:26:33.660
没关系，有一些课

00:26:30.230 --> 00:26:35.700
评估现在评估代码段的评估

00:26:33.660 --> 00:26:38.400
在运行时可能有很多

00:26:35.700 --> 00:26:41.670
脚本语言的实现

00:26:38.400 --> 00:26:44.280
能够评估例如

00:26:41.670 --> 00:26:49.950
 NASA号角是Oracle的实现

00:26:44.280 --> 00:26:52.320
 JavaScript或groovy或JRuby等如何

00:26:49.950 --> 00:26:57.000
是Java脚本模块的意思是

00:26:52.320 --> 00:26:59.520
依靠他们似乎

00:26:57.000 --> 00:27:02.820
就像我们需要一种在模块中说的方式

00:26:59.520 --> 00:27:06.240
 Java脚本声明需要

00:27:02.820 --> 00:27:09.060
可选模块名称，以便Java 

00:27:06.240 --> 00:27:10.920
脚本将读取任何模块

00:27:09.060 --> 00:27:12.090
可用，如果没有可用

00:27:10.920 --> 00:27:13.830
没关系，模块系统

00:27:12.090 --> 00:27:17.360
即使某些

00:27:13.830 --> 00:27:20.900
所需的内容可能不存在

00:27:17.360 --> 00:27:24.960
需要可选的麻烦是

00:27:20.900 --> 00:27:28.590
只有当

00:27:24.960 --> 00:27:31.620
 Java脚本模块具有Java时

00:27:28.590 --> 00:27:32.600
已经建成，但假设您在

00:27:31.620 --> 00:27:36.090
编译时间

00:27:32.600 --> 00:27:39.240
如果Java脚本中的源代码怎么办

00:27:36.090 --> 00:27:41.850
模块指的是其中一个

00:27:39.240 --> 00:27:43.950
可选模块，要么是JDK脚本，要么是

00:27:41.850 --> 00:27:46.830
 Sehorne或groovy脚本引擎等等

00:27:43.950 --> 00:27:50.400
可选模块在编译时不存在

00:27:46.830 --> 00:27:53.850
时间对于Java来说是不可接受的

00:27:50.400 --> 00:27:58.050
编译器在找不到时继续执行

00:27:53.850 --> 00:28:00.420
源代码中引用的类也不

00:27:58.050 --> 00:28:02.370
我们想放松Java语言

00:28:00.420 --> 00:28:03.900
某种形式的宽松动态类型

00:28:02.370 --> 00:28:06.600
说很好，我看到有一个参考

00:28:03.900 --> 00:28:08.070
来自可选模块的某些类型，以及

00:28:06.600 --> 00:28:09.360
它不是在编译时在这里，而是

00:28:08.070 --> 00:28:10.890
可能在运行时在这里，所以我只是

00:28:09.360 --> 00:28:14.420
编译它，并希望类型会

00:28:10.890 --> 00:28:18.480
弄清楚这不是真的Java方法

00:28:14.420 --> 00:28:20.910
现在，如果您能更进一步

00:28:18.480 --> 00:28:23.309
在您的源代码中永远不会引用

00:28:20.910 --> 00:28:25.740
直接从

00:28:23.309 --> 00:28:28.860
可选模块，而是访问它们

00:28:25.740 --> 00:28:31.679
通过反射，但这是非常痛苦的

00:28:28.860 --> 00:28:34.740
编程风格，这是您必须要做的

00:28:31.679 --> 00:28:37.110
 Java ME平台上的代码

00:28:34.740 --> 00:28:39.300
不同的设备实现了不同的

00:28:37.110 --> 00:28:41.130
 API，您必须动态地

00:28:39.300 --> 00:28:43.500
发现那里的东西并编码

00:28:41.130 --> 00:28:48.660
通过反射API 

00:28:43.500 --> 00:28:52.860
不按比例缩放这是一张幻灯片

00:28:48.660 --> 00:28:57.630
想以适当的方式拍照

00:28:52.860 --> 00:29:02.220
针对零个或多个编程

00:28:57.630 --> 00:29:04.890
模块与服务一起

00:29:02.220 --> 00:29:07.950
通过引入一个间接级别

00:29:04.890 --> 00:29:11.670
您可以使用的服务类型

00:29:07.950 --> 00:29:15.450
机械翻译可选

00:29:11.670 --> 00:29:17.280
我应该在顶部模块依赖

00:29:15.450 --> 00:29:19.290
说一种假设的可选

00:29:17.280 --> 00:29:22.070
你不能写的依赖要求

00:29:19.290 --> 00:29:24.330
可选权，这是假设的事情

00:29:22.070 --> 00:29:27.540
但是如果你想写你自己

00:29:24.330 --> 00:29:31.500
可以翻译成一对非

00:29:27.540 --> 00:29:37.710
模块上的可选依赖项

00:29:31.500 --> 00:29:40.260
导出服务类型有一个

00:29:37.710 --> 00:29:42.179
消费者模块Java脚本是

00:29:40.260 --> 00:29:44.720
将使用服务类型及其

00:29:42.179 --> 00:29:47.010
右侧的各种提供程序模块

00:29:44.720 --> 00:29:48.809
需要服务类型模块

00:29:47.010 --> 00:29:50.550
导师，以便他们可以执行脚本

00:29:48.809 --> 00:29:52.889
引擎工厂，他们宣布

00:29:50.550 --> 00:29:58.479
他们提供实施

00:29:52.889 --> 00:30:01.599
底部的这个方案解耦了

00:29:58.479 --> 00:30:04.929
提供商的编号和身份

00:30:01.599 --> 00:30:08.949
正确的消费者模块

00:30:04.929 --> 00:30:13.269
模块是什么，全部是可选项

00:30:08.949 --> 00:30:14.499
关于我认识到这是一个抽象

00:30:13.269 --> 00:30:18.539
图片的好处是它适合一个

00:30:14.499 --> 00:30:21.190
幻灯片有意义吗

00:30:18.539 --> 00:30:25.449
在这里很难说出是否

00:30:21.190 --> 00:30:27.789
我们烧掉的这个编程习惯

00:30:25.449 --> 00:30:30.849
这些变成Java语言

00:30:27.789 --> 00:30:34.359
关键字使用并提供了

00:30:30.849 --> 00:30:36.069
更清楚地了解

00:30:34.359 --> 00:30:38.440
不同之间的关系

00:30:36.069 --> 00:30:40.419
模块，它与

00:30:38.440 --> 00:30:43.739
 Lambda在其个人表达中

00:30:40.419 --> 00:30:47.559
在方法主体中很难分辨

00:30:43.739 --> 00:30:51.069
效果如何，但实际上

00:30:47.559 --> 00:30:55.029
是关于模块化的本质

00:30:51.069 --> 00:30:57.879
使消费者模块不在乎谁

00:30:55.029 --> 00:30:59.769
提供者模块是模块化的

00:30:57.879 --> 00:31:02.129
基本上是关于不关心和服务

00:30:59.769 --> 00:31:05.499
或您只是依靠

00:31:02.129 --> 00:31:13.289
精心设计的服务类型，您让

00:31:05.499 --> 00:31:17.649
模块系统找到提供者，因此

00:31:13.289 --> 00:31:20.109
由于Java脚本是JDK模块，因此

00:31:17.649 --> 00:31:22.119
不会感到惊讶的是

00:31:20.109 --> 00:31:24.549
不仅消费者模块说

00:31:22.119 --> 00:31:27.819
用途，但实际上也在哪里

00:31:24.549 --> 00:31:30.699
类型生活在Java的顶部

00:31:27.819 --> 00:31:32.499
脚本模块，它们都使用脚本

00:31:30.699 --> 00:31:34.929
引擎工厂界面，因为

00:31:32.499 --> 00:31:38.619
调用服务的Java脚本中的代码

00:31:34.929 --> 00:31:41.019
加载器和Java脚本实际上是

00:31:38.619 --> 00:31:45.369
该接口所在的位置，因此可以导出

00:31:41.019 --> 00:31:48.369
然后让其他人实施

00:31:45.369 --> 00:31:51.459
深入NASS的号角

00:31:48.369 --> 00:31:53.139
那里的模块又都是假想的

00:31:51.459 --> 00:31:55.839
实际上不是俗称的模块

00:31:53.139 --> 00:31:57.789
但我必须举一些例子

00:31:55.839 --> 00:32:00.309
各自提供其实现

00:31:57.789 --> 00:32:03.099
脚本引擎工厂和模块

00:32:00.309 --> 00:32:05.470
系统发现这两个角色

00:32:03.099 --> 00:32:08.289
模块作为提供程序模块

00:32:05.470 --> 00:32:10.750
当系统启动时假设

00:32:08.289 --> 00:32:15.759
这两个模块的罐子放在

00:32:10.750 --> 00:32:19.929
现在，Java脚本中的模块路径代码

00:32:15.759 --> 00:32:24.519
然后您会找到我的指针代码和Java 

00:32:19.929 --> 00:32:26.679
脚本编写可以使用服务加载程序

00:32:24.519 --> 00:32:30.100
获取脚本引擎工厂的实例

00:32:26.679 --> 00:32:33.220
并调用其方法而不必担心

00:32:30.100 --> 00:32:35.500
实施来自

00:32:33.220 --> 00:32:38.529
脚本引擎工厂界面有很多

00:32:35.500 --> 00:32:40.840
描述符方法让提供者

00:32:38.529 --> 00:32:43.120
类编码的质量

00:32:40.840 --> 00:32:44.950
脚本引擎的实现

00:32:43.120 --> 00:32:46.120
他们最终提出，我不会

00:32:44.950 --> 00:32:48.629
显示脚本引擎工厂，因为它

00:32:46.120 --> 00:32:50.799
将是一大堆get方法

00:32:48.629 --> 00:32:52.509
查找起来很容易，您会

00:32:50.799 --> 00:32:55.210
看到一种获取获取名称

00:32:52.509 --> 00:32:57.159
脚本引擎并获取一些详细信息

00:32:55.210 --> 00:33:01.629
它的一些语言功能

00:32:57.159 --> 00:33:04.750
它支持您，您会注意到

00:33:01.629 --> 00:33:07.210
 Java脚本模块不说

00:33:04.750 --> 00:33:10.480
需要JavaScript jdk脚本nass 

00:33:07.210 --> 00:33:12.070
角或常规脚本引擎实际上是否

00:33:10.480 --> 00:33:15.519
你仔细看，你会发现

00:33:12.070 --> 00:33:20.169
模块需要Java脚本，其中

00:33:15.519 --> 00:33:22.450
服务类型的生存方式

00:33:20.169 --> 00:33:25.320
你会得到非常可选的依赖

00:33:22.450 --> 00:33:29.320
松耦合是通过反转它们

00:33:25.320 --> 00:33:32.139
而不是高级脚本API 

00:33:29.320 --> 00:33:35.950
需要较低级别的模块

00:33:32.139 --> 00:33:39.159
每个人都在看的实现模块

00:33:35.950 --> 00:33:46.919
通过要求模块与服务

00:33:39.159 --> 00:33:51.429
类型，以便服务关系编码

00:33:46.919 --> 00:33:53.860
可选模块依赖关系

00:33:51.429 --> 00:33:56.620
服务不只是松散

00:33:53.860 --> 00:33:57.759
耦合作为一种机制

00:33:56.620 --> 00:33:59.799
模块系统，但实际上更好

00:33:57.759 --> 00:34:03.149
之间的关注点分离

00:33:59.799 --> 00:34:05.740
接口和实现，以及

00:34:03.149 --> 00:34:08.649
服务几乎总是更好

00:34:05.740 --> 00:34:11.139
选择实现的选择

00:34:08.649 --> 00:34:14.669
而不是倒影

00:34:11.139 --> 00:34:14.669
名称等的类点

00:34:15.260 --> 00:34:22.220
差不多完成了，让我们来谈谈周期

00:34:23.089 --> 00:34:34.800
这是一些模块的图形

00:34:26.579 --> 00:34:37.829
在JDK 9中，您对此有何注意

00:34:34.800 --> 00:34:40.560
是循环的，那里没有循环

00:34:37.829 --> 00:34:46.669
没有循环，它是有向非循环的

00:34:40.560 --> 00:34:51.990
图形模块系统不允许

00:34:46.669 --> 00:34:55.379
在您的require指令中循环

00:34:51.990 --> 00:34:58.530
花费了将近十年的时间

00:34:55.379 --> 00:35:01.290
数以万计的课程

00:34:58.530 --> 00:35:03.960
 JDK到无环且相对理智

00:35:01.290 --> 00:35:04.589
您在这里看到的州我们希望保留它

00:35:03.960 --> 00:35:08.130
那样

00:35:04.589 --> 00:35:10.890
实际上是

00:35:08.130 --> 00:35:14.099
投资代码的模块化

00:35:10.890 --> 00:35:18.000
基础是一旦完成的知识

00:35:14.099 --> 00:35:20.819
不会有任何退路

00:35:18.000 --> 00:35:25.740
循环依赖的泥球

00:35:20.819 --> 00:35:28.500
允许，我们不是唯一的

00:35:25.740 --> 00:35:31.410
像这样的java应用程序思考

00:35:28.500 --> 00:35:34.500
 2012年的建筑是杰出的

00:35:31.410 --> 00:35:36.450
在一节中有关模块化的书

00:35:34.500 --> 00:35:39.270
有资格的你实际上无法做到这一点

00:35:36.450 --> 00:35:39.750
真正的周期性依赖是

00:35:39.270 --> 00:35:42.540
丧钟

00:35:39.750 --> 00:35:45.690
它说过多的依赖是不好的

00:35:42.540 --> 00:35:49.640
过多的需求基本上是不好的，但是

00:35:45.690 --> 00:35:52.380
循环依赖特别糟糕

00:35:49.640 --> 00:35:54.510
一般说来

00:35:52.380 --> 00:35:57.359
周期总是不好，但有时

00:35:54.510 --> 00:35:59.970
有些周期比其他周期更糟糕

00:35:57.359 --> 00:36:01.740
类之间是可以容忍的

00:35:59.970 --> 00:36:03.829
它们不会导致

00:36:01.740 --> 00:36:06.480
包含它们的软件包或模块

00:36:03.829 --> 00:36:08.550
包之间的周期也可能是

00:36:06.480 --> 00:36:11.450
假设它们不会导致

00:36:08.550 --> 00:36:14.160
在包含它们的模块之间循环

00:36:11.450 --> 00:36:18.960
模块关系绝不能

00:36:14.160 --> 00:36:21.770
周期性的，但是在现实生活中

00:36:18.960 --> 00:36:26.599
有时周期似乎不可避免

00:36:21.770 --> 00:36:26.599
让我们看一个真实的例子

00:36:27.079 --> 00:36:34.769
假设有一个日志记录项目

00:36:30.779 --> 00:36:37.980
由两个模块记录API组成

00:36:34.769 --> 00:36:41.220
并登录需要一个拉

00:36:37.980 --> 00:36:44.490
其他，以便日志记录API模块

00:36:41.220 --> 00:36:48.029
需要记录实现

00:36:44.490 --> 00:36:52.069
模块就是蓝色箭头，为什么

00:36:48.029 --> 00:36:56.089
 API模块中的静态方法

00:36:52.069 --> 00:37:00.630
传统上一直使用反射

00:36:56.089 --> 00:37:07.589
创建锁定实例

00:37:00.630 --> 00:37:10.440
现在我们假设存在

00:37:07.589 --> 00:37:14.789
不相关的一些HTTP客户端模块

00:37:10.440 --> 00:37:17.299
它想要记录HTTP请求的项目

00:37:14.789 --> 00:37:20.640
它开始需要另一个蓝色箭头

00:37:17.299 --> 00:37:24.019
日志API模块没有

00:37:20.640 --> 00:37:28.799
服务，但这只是需要

00:37:24.019 --> 00:37:32.069
最后让我们假设

00:37:28.799 --> 00:37:34.380
日志记录实现模块想要

00:37:32.069 --> 00:37:38.130
添加可以上传日志的功能

00:37:34.380 --> 00:37:42.599
在这一点上作者

00:37:38.130 --> 00:37:47.009
在JDK中登录pull的过程很不幸

00:37:42.599 --> 00:37:50.190
 9因为日志记录依赖

00:37:47.009 --> 00:37:52.230
 HTTP客户端通过are需要第三个

00:37:50.190 --> 00:37:56.579
蓝色箭头将创建一个周期

00:37:52.230 --> 00:38:00.029
更糟糕的是，这将造成一个循环

00:37:56.579 --> 00:38:03.059
项目是非常不舒服的

00:38:00.029 --> 00:38:07.710
其余管理的耦合级别

00:38:03.059 --> 00:38:10.680
时间的日志作者可以做什么

00:38:07.710 --> 00:38:13.079
在拉做上传日志到网络

00:38:10.680 --> 00:38:15.059
服务器好一种选择是找到

00:38:13.079 --> 00:38:17.130
提供HTTP的另一个项目

00:38:15.059 --> 00:38:21.089
客户端模块，但看起来像

00:38:17.130 --> 00:38:24.420
作弊的另一种选择是通过电子邮件发送

00:38:21.089 --> 00:38:27.390
 HTTP客户端模块的作者并询问

00:38:24.420 --> 00:38:29.700
他们停止要求记录API，但是

00:38:27.390 --> 00:38:31.440
现在，HTTP客户端的作者是

00:38:29.700 --> 00:38:34.890
可以找到另一个人的人

00:38:31.440 --> 00:38:36.150
项目，即使HTTP的作者

00:38:34.890 --> 00:38:37.320
客户愿意使用其他

00:38:36.150 --> 00:38:39.570
测井

00:38:37.320 --> 00:38:41.910
日志实现的作者仍然会

00:38:39.570 --> 00:38:47.150
必须等待新版本的HTTP 

00:38:41.910 --> 00:38:50.550
这样做的客户谁在这里错

00:38:47.150 --> 00:38:54.270
不是拉入模块登录

00:38:50.550 --> 00:38:57.000
只是想重用记得在

00:38:54.270 --> 00:39:01.290
主题演讲Mark说一个模块是一组

00:38:57.000 --> 00:39:04.410
为重用日志而设计的软件包

00:39:01.290 --> 00:39:07.470
 imple模块只是试图重用

00:39:04.410 --> 00:39:10.200
逻辑上独立的HTTP客户端

00:39:07.470 --> 00:39:13.080
模块，我不认为这个问题

00:39:10.200 --> 00:39:16.010
在于HTTP客户端模块

00:39:13.080 --> 00:39:23.910
只是试图重用公共日志

00:39:16.010 --> 00:39:29.370
 API错误在于日志记录API 

00:39:23.910 --> 00:39:32.850
模块，API的样式很差

00:39:29.370 --> 00:39:33.680
依靠要求其实现

00:39:32.850 --> 00:39:37.170
两个原因

00:39:33.680 --> 00:39:40.140
首先，它意味着实施细节

00:39:37.170 --> 00:39:44.190
可能会泄漏到API中

00:39:40.140 --> 00:39:48.240
使API难以理解

00:39:44.190 --> 00:39:50.880
这意味着要满足API的需求

00:39:48.240 --> 00:39:52.980
整个实施需要

00:39:50.880 --> 00:39:56.190
运行使API减少

00:39:52.980 --> 00:39:58.380
加上我所说的一切

00:39:56.190 --> 00:40:01.440
到目前为止，这显然是错误的

00:39:58.380 --> 00:40:03.630
考虑一下Java基本模块吧

00:40:01.440 --> 00:40:06.060
声明Java util集合

00:40:03.630 --> 00:40:08.430
介面，但对于

00:40:06.060 --> 00:40:10.410
 Java基本模块依赖于要求

00:40:08.430 --> 00:40:13.110
任何实现该功能的模块

00:40:10.410 --> 00:40:18.690
接口实现取决于

00:40:13.110 --> 00:40:22.620
接口不是相反

00:40:18.690 --> 00:40:25.890
最好的结果是登录拉

00:40:22.620 --> 00:40:27.240
依赖于日志记录API而不是

00:40:25.890 --> 00:40:29.880
实现的其他方式

00:40:27.240 --> 00:40:31.800
依赖的接口，但是我听到了

00:40:29.880 --> 00:40:34.980
请问静态方法在

00:40:31.800 --> 00:40:39.560
 API创建日志记录实例

00:40:34.980 --> 00:40:41.820
实施带有服务的课程

00:40:39.560 --> 00:40:43.010
这是日志记录项目应具有的功能

00:40:41.820 --> 00:40:46.250
做

00:40:43.010 --> 00:40:48.530
首先，日志API模块定义了一个

00:40:46.250 --> 00:40:51.590
某些程序包中的服务类型记录器，以及

00:40:48.530 --> 00:40:53.360
该包装广泛出口

00:40:51.590 --> 00:40:57.800
绿箭的出口消费者

00:40:53.360 --> 00:41:00.290
导出到提供者第二次日志记录

00:40:57.800 --> 00:41:04.160
实现自带的提供程序模块

00:41:00.290 --> 00:41:08.270
它需要蓝色的日志记录API 

00:41:04.160 --> 00:41:10.550
箭头，并提供的实现

00:41:08.270 --> 00:41:13.010
服务键入紫色箭头

00:41:10.550 --> 00:41:19.040
请注意，日志记录实现

00:41:13.010 --> 00:41:23.600
模块最终不会导出任何内容

00:41:19.040 --> 00:41:27.860
带有服务的日志记录API模块

00:41:23.600 --> 00:41:30.440
它说类型充当其自己的消费者

00:41:27.860 --> 00:41:33.110
它使用记录器服务类型，并且

00:41:30.440 --> 00:41:35.990
然后在运行时询问服务加载器

00:41:33.110 --> 00:41:37.850
对于记录器实例，此实例

00:41:35.990 --> 00:41:40.370
然后将返回到HTTP 

00:41:37.850 --> 00:41:43.190
客户端模块，不知道

00:41:40.370 --> 00:41:46.610
记录api和

00:41:43.190 --> 00:41:49.990
锁定实现发生在我身上

00:41:46.610 --> 00:41:53.390
应该删除了蓝色的大箭头

00:41:49.990 --> 00:41:55.580
从登录下拉到HTTP客户端

00:41:53.390 --> 00:41:57.320
它应该假装不存在

00:41:55.580 --> 00:42:03.140
我知道你们都装作不是

00:41:57.320 --> 00:42:06.620
现在，HTTP客户端是

00:42:03.140 --> 00:42:09.410
被迫严格记录到记录器

00:42:06.620 --> 00:42:11.360
界面，无法访问

00:42:09.410 --> 00:42:13.900
基础实现类，因为

00:42:11.360 --> 00:42:17.030
它不是从登录拉中导出的

00:42:13.900 --> 00:42:20.240
基本上，最大的技巧是

00:42:17.030 --> 00:42:23.590
服务加载程序代表日志记录

00:42:20.240 --> 00:42:26.810
查看锁定实现的API 

00:42:23.590 --> 00:42:27.670
没有登录拉所以没有

00:42:26.810 --> 00:42:31.940
记录API 

00:42:27.670 --> 00:42:34.280
需要登录拉和没有

00:42:31.940 --> 00:42:36.500
日志记录实现将任何内容导出到

00:42:34.280 --> 00:42:39.710
换句话说，记录api非常

00:42:36.500 --> 00:42:42.890
 api和

00:42:39.710 --> 00:42:46.460
实施，因此很容易切换

00:42:42.890 --> 00:42:50.270
退出登录拉不同

00:42:46.460 --> 00:42:52.610
在运行时实施

00:42:50.270 --> 00:42:53.220
 HTTP客户端模块将不知道

00:42:52.610 --> 00:43:00.450
这件事

00:42:53.220 --> 00:43:01.530
如果您有需要，我需要加快速度

00:43:00.450 --> 00:43:03.720
感觉你已经看过了

00:43:01.530 --> 00:43:06.270
因为你有十分钟十分钟

00:43:03.720 --> 00:43:09.240
之前我说过你选择的方式

00:43:06.270 --> 00:43:10.730
依赖关系是通过反转它们

00:43:09.240 --> 00:43:12.599
比高级脚本模块

00:43:10.730 --> 00:43:14.970
需要低级实施

00:43:12.599 --> 00:43:17.599
每个人都通过要求查找模块

00:43:14.970 --> 00:43:21.480
具有服务类型的模块

00:43:17.599 --> 00:43:23.940
服务发挥相同的技巧来打破

00:43:21.480 --> 00:43:26.340
周期性依赖而不是高

00:43:23.940 --> 00:43:27.930
需要低级别的级别API模块

00:43:26.340 --> 00:43:30.060
实施模块

00:43:27.930 --> 00:43:33.330
实现模块按以下方式查找

00:43:30.060 --> 00:43:36.060
需要开发API模块

00:43:33.330 --> 00:43:38.340
服务需要工作，但回报是

00:43:36.060 --> 00:43:40.680
服务带出了

00:43:38.340 --> 00:43:42.359
整个程序比

00:43:40.680 --> 00:43:44.849
我们曾经介绍过的所有内容

00:43:42.359 --> 00:43:47.130
 Java语言，因为我们排名第一

00:43:44.849 --> 00:43:49.380
 Java代码的信念是阅读是

00:43:47.130 --> 00:43:51.270
比我们认为的写作更重要

00:43:49.380 --> 00:43:54.410
服务可以减轻他们的负担， 

00:43:51.270 --> 00:43:58.800
值得广泛采用

00:43:54.410 --> 00:44:01.260
因此周期会损害程序理解力， 

00:43:58.800 --> 00:44:04.380
维护服务关系是

00:44:01.260 --> 00:44:06.390
打破循环的自然方法

00:44:04.380 --> 00:44:08.160
仅用于几种用途，并提供和

00:44:06.390 --> 00:44:13.080
服务加载程序调用，您可以表示

00:44:08.160 --> 00:44:16.440
很多应用程序架构

00:44:13.080 --> 00:44:18.510
他们从字面上看是一流的服务

00:44:16.440 --> 00:44:21.000
给您宽松的耦合，但合乎逻辑

00:44:18.510 --> 00:44:23.550
更好地分离关注点， 

00:44:21.000 --> 00:44:27.839
所有关于架构而不是

00:44:23.550 --> 00:44:29.790
代码JDK九在这里

00:44:27.839 --> 00:44:31.109
如果没有，请下载

00:44:29.790 --> 00:44:33.900
进一步了解模块系统

00:44:31.109 --> 00:44:36.950
有很多JDK增强功能

00:44:33.900 --> 00:44:39.300
建议捷豹特别喷气261 

00:44:36.950 --> 00:44:42.810
基本上，您所遇到的每个问题

00:44:39.300 --> 00:44:46.299
 261回答了要问的问题， 

00:44:42.810 --> 00:44:48.359
非常感谢你

00:44:46.299 --> 00:44:48.359
您

