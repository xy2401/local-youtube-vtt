WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.000 --> 00:00:04.970
大家好，欢迎使用JDK 9中的模块

00:00:05.420 --> 00:00:10.889
我叫亚历克斯·巴克利（Alex Buckley）， 

00:00:08.639 --> 00:00:13.440
 Java语言规范和

00:00:10.889 --> 00:00:16.410
我工作过的Java虚拟机

00:00:13.440 --> 00:00:19.439
自2006年以来的Java平台，所以我

00:00:16.410 --> 00:00:22.470
看到了JDK 7 8和9的整个生命周期

00:00:19.439 --> 00:00:25.439
我研究了项目硬币并调用

00:00:22.470 --> 00:00:28.050
在Lambda和类型上的JDK 7中是动态的

00:00:25.439 --> 00:00:29.970
 JDK 8和模块中的注释

00:00:28.050 --> 00:00:34.200
在JDK 9中，我们将要讨论

00:00:29.970 --> 00:00:36.750
今天首先我们将讨论什么

00:00:34.200 --> 00:00:39.960
模块以及它们如何改进

00:00:36.750 --> 00:00:42.000
开发人员体验第二，我们再谈

00:00:39.960 --> 00:00:45.270
关于如何将JDK变成

00:00:42.000 --> 00:00:46.680
模块，第三个我们将讨论一些

00:00:45.270 --> 00:00:52.260
您需要了解的事情

00:00:46.680 --> 00:00:54.570
迁移到JDK 9的核心之一

00:00:52.260 --> 00:00:57.180
任何编程语言的特征是

00:00:54.570 --> 00:00:58.859
重用代码的能力如此之大

00:00:57.180 --> 00:01:03.059
程序可以从小构建

00:00:58.859 --> 00:01:05.850
 Java中的程序是重用的基本单位

00:01:03.059 --> 00:01:08.640
传统上是Java拥有的类

00:01:05.850 --> 00:01:11.310
促进重用的绝佳机制

00:01:08.640 --> 00:01:13.890
类的继承

00:01:11.310 --> 00:01:15.500
重用行为和接口

00:01:13.890 --> 00:01:18.900
重用抽象

00:01:15.500 --> 00:01:23.670
但是，当您的Java程序进入

00:01:18.900 --> 00:01:26.100
将5 10 20包放在2 4 8个jar文件中

00:01:23.670 --> 00:01:27.810
很难想象如何

00:01:26.100 --> 00:01:30.420
所有这些类和接口

00:01:27.810 --> 00:01:36.090
互动，这意味着很难

00:01:30.420 --> 00:01:38.640
控制谁在重用只是想像的东西

00:01:36.090 --> 00:01:41.600
控制重用有多困难

00:01:38.640 --> 00:01:44.880
在非常大的代码库（例如

00:01:41.600 --> 00:01:48.470
此处显示217个官方包装

00:01:44.880 --> 00:01:52.770
 JDK 8之间共享代码的唯一方法

00:01:48.470 --> 00:01:55.490
包带有public修饰符，但是

00:01:52.770 --> 00:01:57.659
然后将代码与所有人共享

00:01:55.490 --> 00:02:00.600
打包是一种很好的组织方式

00:01:57.659 --> 00:02:04.439
课，但大多数人希望有一个

00:02:00.600 --> 00:02:07.259
将软件包组织到模块的方法

00:02:04.439 --> 00:02:10.770
你认为一个模块是一组

00:02:07.259 --> 00:02:12.750
专为重复使用而设计的软件包

00:02:10.770 --> 00:02:13.709
 Java中的过期过期构建基块

00:02:12.750 --> 00:02:16.109
语言

00:02:13.709 --> 00:02:18.780
实际上召回给

00:02:16.109 --> 00:02:22.140
程序的结构，以便

00:02:18.780 --> 00:02:23.069
您想重复使用的零件可以是

00:02:22.140 --> 00:02:26.069
重用

00:02:23.069 --> 00:02:31.200
而你不想成为的部分

00:02:26.069 --> 00:02:33.840
重用不能重用构建的程序

00:02:31.200 --> 00:02:35.790
的模块将比

00:02:33.840 --> 00:02:38.040
从一组松散的程序中构建的程序

00:02:35.790 --> 00:02:39.810
可以访问的jar文件中的软件包

00:02:38.040 --> 00:02:43.200
彼此自由地接触

00:02:39.810 --> 00:02:45.180
通往外界的许多API 

00:02:43.200 --> 00:02:48.090
每个人都将成为的模块

00:02:45.180 --> 00:02:50.310
熟悉Java基础的

00:02:48.090 --> 00:02:52.379
每个Java程序的基础，例如

00:02:50.310 --> 00:02:55.260
 java.lang对象是每个对象的根

00:02:52.379 --> 00:02:58.469
蓝色的类是Java的软件包

00:02:55.260 --> 00:03:01.469
旨在供外部代码使用的库

00:02:58.469 --> 00:03:06.629
这些是其导出的模块

00:03:01.469 --> 00:03:09.689
红色包装其他内部包装

00:03:06.629 --> 00:03:11.909
到Java基础，它们可以被代码使用

00:03:09.689 --> 00:03:14.489
在模块内部，但不是通过代码

00:03:11.909 --> 00:03:19.349
在模块之外，这些是

00:03:14.489 --> 00:03:22.019
隐藏包声明了一个模块

00:03:19.349 --> 00:03:25.319
在一种称为模块信息的新文件中

00:03:22.019 --> 00:03:28.949
 Java，它给出了模块的名称， 

00:03:25.319 --> 00:03:31.409
通过导出

00:03:28.949 --> 00:03:34.169
 java.lang包意味着

00:03:31.409 --> 00:03:37.459
 java.lang的公共类是

00:03:34.169 --> 00:03:41.299
可从外部java base访问

00:03:37.459 --> 00:03:44.699
没有明确导出的包

00:03:41.299 --> 00:03:47.939
例如平静的太阳加密货币提供商是

00:03:44.699 --> 00:03:52.199
隐藏它的公共课不是

00:03:47.939 --> 00:03:55.590
在Java基础之外可以访问的是

00:03:52.199 --> 00:03:58.620
 JDK 9 Strong中模块的第一个功能

00:03:55.590 --> 00:04:01.319
封装模块不仅仅是一组

00:03:58.620 --> 00:04:05.359
包，它是一组导出的

00:04:01.319 --> 00:04:08.489
包装和隐藏包装

00:04:05.359 --> 00:04:11.819
这意味着访问控制更多

00:04:08.489 --> 00:04:14.430
在jdk 9中比在jdk 8中强大

00:04:11.819 --> 00:04:18.380
吉达q9可以安排公共活动

00:04:14.430 --> 00:04:21.359
每个人都可以访问的课程，或者

00:04:18.380 --> 00:04:25.710
仅可用于

00:04:21.359 --> 00:04:27.360
同一模块或中的类可访问

00:04:25.710 --> 00:04:30.870
相同的模块和肢体

00:04:27.360 --> 00:04:33.389
一组朋友模块，如果您

00:04:30.870 --> 00:04:36.330
在班级声明上看公众

00:04:33.389 --> 00:04:39.180
它不再意味着每个人都可以

00:04:36.330 --> 00:04:42.569
访问类访问取决于

00:04:39.180 --> 00:04:45.479
该类的模块是否导出

00:04:42.569 --> 00:04:48.449
编写自己的类包时

00:04:45.479 --> 00:04:51.449
您指定模块的模块

00:04:48.449 --> 00:04:54.569
取决于这是第二个特征

00:04:51.449 --> 00:04:56.909
 JDK中的模块九个可靠依赖项

00:04:54.569 --> 00:04:59.969
一个模块不仅仅是一组软件包

00:04:56.909 --> 00:05:04.770
这是重复使用

00:04:59.969 --> 00:05:07.379
其他模块在此处导出的软件包

00:05:04.770 --> 00:05:10.620
我们有一个hello world模块， 

00:05:07.379 --> 00:05:14.419
出口自己的包裹并依赖

00:05:10.620 --> 00:05:17.639
在Java上使用require关键字

00:05:14.419 --> 00:05:20.419
这意味着HelloWorld中的代码

00:05:17.639 --> 00:05:24.210
模块可以导入任何软件包

00:05:20.419 --> 00:05:26.879
由Java库导出，但没有

00:05:24.210 --> 00:05:29.819
 HelloWorld模块中的代码的方式

00:05:26.879 --> 00:05:32.550
导入由...隐藏的任何软件包

00:05:29.819 --> 00:05:35.279
 Java基础有很多好处

00:05:32.550 --> 00:05:37.710
开始将代码放入模块中

00:05:35.279 --> 00:05:40.500
 HelloWorld模块可以与

00:05:37.710 --> 00:05:43.949
指向一个简单的Java命令

00:05:40.500 --> 00:05:47.069
负P和

00:05:43.949 --> 00:05:49.289
要运行的模块减去您没有的M 

00:05:47.069 --> 00:05:52.379
需要设置模块的类路径

00:05:49.289 --> 00:05:54.960
自己说他们依赖JDK 9 

00:05:52.379 --> 00:05:59.129
在您检查两者的依赖项时

00:05:54.960 --> 00:06:01.080
编译并在运行时检查

00:05:59.129 --> 00:06:03.659
所需的每个模块都是

00:06:01.080 --> 00:06:05.370
可用，这是对

00:06:03.659 --> 00:06:09.089
您找不到的课程路径

00:06:05.370 --> 00:06:11.490
缺少罐子，直到以后它检查

00:06:09.089 --> 00:06:14.250
模块之间不需要彼此

00:06:11.490 --> 00:06:17.939
循环导致代码很难

00:06:14.250 --> 00:06:20.250
最终了解并维护它

00:06:17.939 --> 00:06:23.069
检查软件包是否从中导出

00:06:20.250 --> 00:06:25.439
恰好是另一个模块，这意味着

00:06:23.069 --> 00:06:27.029
没有拆分包拆分

00:06:25.439 --> 00:06:29.370
包是你上的烂摊子

00:06:27.029 --> 00:06:31.650
两个罐子包含的类路径

00:06:29.370 --> 00:06:33.599
同一包，您加载了一些类

00:06:31.650 --> 00:06:35.940
来自一个罐子，来自其他罐子

00:06:33.599 --> 00:06:39.180
另一个避免拆分包装的罐子是

00:06:35.940 --> 00:06:41.199
也是性能方面的胜利，因为JDK 9 

00:06:39.180 --> 00:06:43.509
确切知道每个包裹在哪里

00:06:41.199 --> 00:06:45.520
比重复好很多

00:06:43.509 --> 00:06:48.490
扫描类路径上的每个jar 

00:06:45.520 --> 00:06:51.610
顺便找一个需要的课程

00:06:48.490 --> 00:06:54.460
模块不是强制性的，您可以保留

00:06:51.610 --> 00:06:57.069
将罐子放在classpath和jdk 9上

00:06:54.460 --> 00:06:59.289
支持逐步迁移到模块

00:06:57.069 --> 00:07:01.270
这样您可以选择权衡

00:06:59.289 --> 00:07:03.939
你愿意做多少工作

00:07:01.270 --> 00:07:06.909
模块化与好处

00:07:03.939 --> 00:07:10.900
模块让我们将注意力转向

00:07:06.909 --> 00:07:13.539
 JDK 20年前，Java平台是

00:07:10.900 --> 00:07:15.990
小的只有几百堂课， 

00:07:13.539 --> 00:07:18.430
 JDK的组织不是问题

00:07:15.990 --> 00:07:19.960
但是平台每年都变大

00:07:18.430 --> 00:07:22.930
现在有成千上万

00:07:19.960 --> 00:07:26.560
 JDK是巨大的，更糟糕​​的是

00:07:22.930 --> 00:07:28.900
实际上是Java平台的整体式

00:07:26.560 --> 00:07:31.689
不是一回事，更像是25 

00:07:28.900 --> 00:07:34.210
单独的框架，包括秋千

00:07:31.689 --> 00:07:36.129
 UI框架加密框架

00:07:34.210 --> 00:07:38.589
脚本框架多个XML 

00:07:36.129 --> 00:07:40.389
处理框架等等

00:07:38.589 --> 00:07:42.419
这些单独的框架没有理由

00:07:40.389 --> 00:07:45.669
在一个下载中紧密耦合

00:07:42.419 --> 00:07:49.120
事实上这是发展的障碍

00:07:45.669 --> 00:07:51.430
 JDK过紧的联轴器引起

00:07:49.120 --> 00:07:53.729
开发和测试费用

00:07:51.430 --> 00:07:56.710
变成平台发展缓慢

00:07:53.729 --> 00:07:58.719
再加上您的表面较大

00:07:56.710 --> 00:08:01.960
平台越难

00:07:58.719 --> 00:08:03.550
安全，这是很多障碍

00:08:01.960 --> 00:08:04.990
的用户都想要运行

00:08:03.550 --> 00:08:07.930
它们在较小设备上的应用

00:08:04.990 --> 00:08:09.849
以及那些想运行更多实例的人

00:08:07.930 --> 00:08:12.639
在大型应用程序中的应用

00:08:09.849 --> 00:08:14.610
系统，即使您只想要一部分

00:08:12.639 --> 00:08:18.789
 JDK，您必须全部使用

00:08:14.610 --> 00:08:21.520
我们已经采取了JDK 9中的所有更改

00:08:18.789 --> 00:08:24.279
整体式JDK并将其分解为

00:08:21.520 --> 00:08:26.770
几十个模块，其中一些是

00:08:24.279 --> 00:08:29.080
 Java SE规范的一部分

00:08:26.770 --> 00:08:33.130
只是JDK实现的一部分

00:08:29.080 --> 00:08:36.039
这是Java SE模块的图形，位于

00:08:33.130 --> 00:08:38.260
底部有Java基础

00:08:36.039 --> 00:08:41.440
一切都取决于，取决于

00:08:38.260 --> 00:08:43.269
在没有任何事情上，我们已经打破了

00:08:41.440 --> 00:08:46.540
将各种框架整合到自己的框架中

00:08:43.269 --> 00:08:49.269
模块仪表记录XML 

00:08:46.540 --> 00:08:53.700
您可能需要的脚本桌面

00:08:49.269 --> 00:08:56.130
或不需要，因为您需要决定

00:08:53.700 --> 00:08:58.440
有一个Java SE模块没有

00:08:56.130 --> 00:09:01.170
实际的代码，但只有

00:08:58.440 --> 00:09:03.180
依赖关系，所以您可以说需要Java 

00:09:01.170 --> 00:09:05.340
 SE，并保证拥有所有这些

00:09:03.180 --> 00:09:07.890
可用模块值得一提

00:09:05.340 --> 00:09:09.690
仅仅找到这些模块

00:09:07.890 --> 00:09:12.060
边界可能在

00:09:09.690 --> 00:09:14.730
后见之明是一项巨大的工程

00:09:12.060 --> 00:09:17.460
您在自己的代码中会发现

00:09:14.730 --> 00:09:19.830
解耦整体要困难得多

00:09:17.460 --> 00:09:20.790
比建立一个松散耦合的系统

00:09:19.830 --> 00:09:23.790
从一开始就

00:09:20.790 --> 00:09:25.830
未来的好消息是

00:09:23.790 --> 00:09:27.960
模块施加的纪律将

00:09:25.830 --> 00:09:30.780
防止我们所有人意外

00:09:27.960 --> 00:09:32.850
重建我想要的整体

00:09:30.780 --> 00:09:36.810
快速查看以下人员的期望

00:09:32.850 --> 00:09:39.060
首先是JDK 9的兼容性

00:09:36.810 --> 00:09:42.600
 Java EE的各种技术

00:09:39.060 --> 00:09:45.930
在JDK和应用程序中都附带

00:09:42.600 --> 00:09:51.000
服务器中的Java EE模块列表

00:09:45.930 --> 00:09:54.470
 JDK 9包括Cober Jack的B jax-ws和

00:09:51.000 --> 00:09:57.660
这些模块的通用注释是

00:09:54.470 --> 00:10:01.110
 JDK 9中已弃用，将其删除

00:09:57.660 --> 00:10:03.950
因此，在将来的版本中

00:10:01.110 --> 00:10:06.450
如果在JDK 9中默认禁用

00:10:03.950 --> 00:10:09.120
您正在您的类路径上运行代码

00:10:06.450 --> 00:10:13.250
可能需要使用添加模块命令

00:10:09.120 --> 00:10:17.010
行标记以启用Java EE模块

00:10:13.250 --> 00:10:19.860
其次很多工具和库尝试

00:10:17.010 --> 00:10:22.700
访问JDK的以下部分

00:10:19.860 --> 00:10:24.900
仅供内部使用

00:10:22.700 --> 00:10:26.910
不幸的是，这需要一段时间

00:10:24.900 --> 00:10:29.940
工具和库开发人员转移

00:10:26.910 --> 00:10:33.330
从这种做法，所以JDK 9暂时

00:10:29.940 --> 00:10:37.410
允许访问JDK内部，但

00:10:33.330 --> 00:10:39.270
发生警告时会显示警告

00:10:37.410 --> 00:10:42.060
命令行标志以避免这些

00:10:39.270 --> 00:10:44.400
警告，因此请使用工具和

00:10:42.060 --> 00:10:48.750
库开发人员有关如何部署的信息

00:10:44.400 --> 00:10:51.630
最后在JDK 9上还有其他

00:10:48.750 --> 00:10:53.880
 JDK 9中与以下内容无关的更改

00:10:51.630 --> 00:10:57.780
模块，但可能会影响运行的代码

00:10:53.880 --> 00:10:59.850
在JDK 8上，特别是假设

00:10:57.780 --> 00:11:02.940
 Java版本流以一个点开头

00:10:59.850 --> 00:11:07.260
或假设JDK位于文件中

00:11:02.940 --> 00:11:07.860
调用RT jar将再次在JDK 9上失败

00:11:07.260 --> 00:11:09.480
请

00:11:07.860 --> 00:11:11.610
与工具和库开发人员核对

00:11:09.480 --> 00:11:15.390
关于需要运行哪些版本

00:11:11.610 --> 00:11:17.790
在JDK 9上得出结论，JDK 9很重要

00:11:15.390 --> 00:11:21.300
因为它支持模块化开发

00:11:17.790 --> 00:11:23.190
一直到Java语言

00:11:21.300 --> 00:11:25.589
 Java虚拟机了解

00:11:23.190 --> 00:11:28.140
模块非常深入，因此

00:11:25.589 --> 00:11:31.620
您编写的应用程序和库

00:11:28.140 --> 00:11:34.260
你消耗，甚至jdk本身可以

00:11:31.620 --> 00:11:37.079
全部经过开发，测试和打包

00:11:34.260 --> 00:11:40.680
并部署为带有清晰API的模块

00:11:37.079 --> 00:11:42.959
并保护好内部零件

00:11:40.680 --> 00:11:44.670
每个人都遵循相同的模块化规则

00:11:42.959 --> 00:11:47.640
对可靠性有很大好处

00:11:44.670 --> 00:11:49.649
可维护性和安全性

00:11:47.640 --> 00:11:52.290
流行的工具可能需要一些时间， 

00:11:49.649 --> 00:11:55.230
图书馆赶上你可以下载

00:11:52.290 --> 00:11:58.620
现在使用JDK 9并关注正在发生的事情

00:11:55.230 --> 00:12:00.810
在开放的JDK上进行JDK开发

00:11:58.620 --> 00:12:03.810
在开放的JDK上在Twitter上关注我们，并

00:12:00.810 --> 00:12:06.140
 Java 9标签，谢谢

00:12:03.810 --> 00:12:06.140
非常

