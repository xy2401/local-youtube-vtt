WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.000 --> 00:00:05.910
比尔吉特，你做到了，做到了

00:00:03.870 --> 00:00:10.019
下午好

00:00:05.910 --> 00:00:12.139
嗯，欢迎来到我的一堂课中的模块

00:00:10.019 --> 00:00:17.400
我叫Mark Reynolds我在Java上工作

00:00:12.139 --> 00:00:20.580
许多其他事情，所以这是一个略读

00:00:17.400 --> 00:00:23.250
模块系统的表面和

00:00:20.580 --> 00:00:26.640
模块化平台中的模块化平台

00:00:23.250 --> 00:00:29.550
模块化JDK以及我所从事的所有工作

00:00:26.640 --> 00:00:31.170
尝试实时向您展示一些

00:00:29.550 --> 00:00:33.809
强调什么意思

00:00:31.170 --> 00:00:36.890
创建一个模块如何制作一个

00:00:33.809 --> 00:00:39.450
模型取决于另一个向您展示

00:00:36.890 --> 00:00:43.710
深度集成的模块系统是

00:00:39.450 --> 00:00:45.750
进入平台并一路展示

00:00:43.710 --> 00:00:47.160
你可能还没有的其他一些东西

00:00:45.750 --> 00:00:48.840
与模块紧密相关

00:00:47.160 --> 00:00:51.539
系统，但它们是Java的很酷的功能

00:00:48.840 --> 00:00:53.879
 9我认为我认为很多人

00:00:51.539 --> 00:00:55.350
尚不知道，所以我将重点介绍

00:00:53.879 --> 00:00:59.579
那些以及希望最后

00:00:55.350 --> 00:01:04.519
我们将有一些时间来提问

00:00:59.579 --> 00:01:08.340
让我们在这里上一堂课

00:01:04.519 --> 00:01:10.110
所以我在一个外壳里，你知道

00:01:08.340 --> 00:01:13.920
的诅咒之一

00:01:10.110 --> 00:01:16.439
在jdk本身上工作很漂亮

00:01:13.920 --> 00:01:18.570
必须住在命令行上

00:01:16.439 --> 00:01:20.130
很多时候，因为当你

00:01:18.570 --> 00:01:24.030
在平台的下一版本上工作

00:01:20.130 --> 00:01:25.290
 ID的旧版本还没有

00:01:24.030 --> 00:01:26.549
支持您的新事物

00:01:25.290 --> 00:01:27.930
如果你只是在工作

00:01:26.549 --> 00:01:29.670
做一个新图书馆，是的，你可能会

00:01:27.930 --> 00:01:31.920
你也许很好，但是当你

00:01:29.670 --> 00:01:33.420
当您在进行深层手术时

00:01:31.920 --> 00:01:36.000
虚拟机中的库和

00:01:33.420 --> 00:01:38.250
改变语言，那么你就敬酒

00:01:36.000 --> 00:01:40.470
这样就回到了命令行

00:01:38.250 --> 00:01:43.560
为了你，这就是我们生活的地方

00:01:40.470 --> 00:01:45.540
很多时候，我有一个很好的

00:01:43.560 --> 00:01:48.930
看起来我这里有9伏特JDK 9 

00:01:45.540 --> 00:01:51.360
建立，我可以告诉你什么版本

00:01:48.930 --> 00:01:54.750
我是几天前建造的

00:01:51.360 --> 00:01:58.020
这是拼图的最新版本

00:01:54.750 --> 00:02:01.049
杰克原型有一段时间了

00:01:58.020 --> 00:02:02.820
在实际的JDK 9代码之前，这些

00:02:01.049 --> 00:02:04.110
天真的很近了

00:02:02.820 --> 00:02:05.640
跑了一点头，然后我们

00:02:04.110 --> 00:02:06.840
然后我们烘烤东西， 

00:02:05.640 --> 00:02:09.030
通过一堆测试，然后

00:02:06.840 --> 00:02:10.590
将它们合并到jdk 9主线中

00:02:09.030 --> 00:02:12.300
我们正在努力接近

00:02:10.590 --> 00:02:15.300
发布，如果这些差异

00:02:12.300 --> 00:02:16.680
这些天真的很小

00:02:15.300 --> 00:02:19.110
那就是那个版本

00:02:16.680 --> 00:02:24.570
我们正在跑步，开始时只有

00:02:19.110 --> 00:02:27.270
一个非常琐碎的应用程序

00:02:24.570 --> 00:02:32.040
你好，世界，他们看到了

00:02:27.270 --> 00:02:33.090
原始的，但有点，但这是一个

00:02:32.040 --> 00:02:36.360
有点不同，这是你好

00:02:33.090 --> 00:02:38.490
您所知的世界受到我们弟兄们的启发

00:02:36.360 --> 00:02:42.240
在JavaScript领域，我们还有一个

00:02:38.490 --> 00:02:45.630
垫方法在这里做得很明显

00:02:42.240 --> 00:02:48.360
并且主要方法需要它

00:02:45.630 --> 00:02:51.390
需要一些输入构造aa 

00:02:48.360 --> 00:02:54.840
你好世界字符串，它留下了它

00:02:51.390 --> 00:02:57.330
并打印出来非常简单，让我们

00:02:54.840 --> 00:03:01.050
让我们做普通的旧编译

00:02:57.330 --> 00:03:02.930
事情在这里，你看看我是否记得如何

00:03:01.050 --> 00:03:05.310
如何做到这一点，我们得到了一个

00:03:02.930 --> 00:03:06.840
实际上在我们之前随机其他东西

00:03:05.310 --> 00:03:11.100
我需要给你看几个

00:03:06.840 --> 00:03:13.320
其他事情之一就是J shell如何

00:03:11.100 --> 00:03:14.489
很多人听说过J shell 

00:03:13.320 --> 00:03:18.540
很多人和J打过交道

00:03:14.489 --> 00:03:19.580
 shell好吧J shell很酷，请尝试一下，这样J 

00:03:18.540 --> 00:03:22.200
贝壳

00:03:19.580 --> 00:03:23.730
欢迎来到James Shell，您能做什么

00:03:22.200 --> 00:03:26.760
在J shell中，您甚至可以

00:03:23.730 --> 00:03:35.790
输入表达式，它可以算出数学

00:03:26.760 --> 00:03:38.310
可以分配变量

00:03:35.790 --> 00:03:41.549
可以要求它做

00:03:38.310 --> 00:03:43.560
可变轴上的攻丝完成

00:03:41.549 --> 00:03:44.910
字符串类的实例，它

00:03:43.560 --> 00:03:46.920
在字符串类中问得很好

00:03:44.910 --> 00:03:49.590
您可以在这里做什么方法

00:03:46.920 --> 00:03:52.140
这里的方法完成告诉我

00:03:49.590 --> 00:03:54.720
哦，他们实际上是两个超载

00:03:52.140 --> 00:03:56.250
有一天，只有一天

00:03:54.720 --> 00:03:57.870
争论需要两个

00:03:56.250 --> 00:03:59.910
参数再按一次标签即可查看

00:03:57.870 --> 00:04:01.829
文档及其用途

00:03:59.910 --> 00:04:06.299
向您展示Javadoc的摘要

00:04:01.829 --> 00:04:12.000
就在工具中，所以X向上子

00:04:06.299 --> 00:04:16.799
字符串两个逗号说1逗号3，我们

00:04:12.000 --> 00:04:19.410
哇，好吧，让它

00:04:16.799 --> 00:04:21.359
周杰伦的微小介绍，所以我们得到了

00:04:19.410 --> 00:04:25.310
字符串变量X我们还能做什么

00:04:21.359 --> 00:04:25.310
询问X我们可以询问它的类

00:04:25.669 --> 00:04:32.759
我们可以问它的班级

00:04:28.169 --> 00:04:33.810
现在在每个课程中它是什么模块

00:04:32.759 --> 00:04:36.289
您上课的模块系统

00:04:33.810 --> 00:04:41.190
马德里ek现在在特定模块中

00:04:36.289 --> 00:04:42.840
此类绘制空白字符串在

00:04:41.190 --> 00:04:44.430
 Java模块称为基础

00:04:42.840 --> 00:04:47.729
包含系统的基础

00:04:44.430 --> 00:04:49.860
基本的东西

00:04:47.729 --> 00:04:53.789
我们可以问模块对象

00:04:49.860 --> 00:04:55.680
类是一个全新的实例

00:04:53.789 --> 00:04:57.509
在java.lang中输入新的新类型

00:04:55.680 --> 00:05:00.930
包称为模块

00:04:57.509 --> 00:05:03.780
反射模块的运行时视图

00:05:00.930 --> 00:05:06.330
所以真的很漂亮

00:05:03.780 --> 00:05:09.979
深入我们可以看看其他

00:05:06.330 --> 00:05:12.419
类让我们导入Java点续集

00:05:09.979 --> 00:05:22.199
进入RJ Shell环境，我们将

00:05:12.419 --> 00:05:26.340
时间戳说乘以0的10个剪辑键

00:05:22.199 --> 00:05:28.050
马克·J·谢尔（J Shell）幸运地拥有历史并

00:05:26.340 --> 00:05:31.380
标签补全

00:05:28.050 --> 00:05:37.039
合理的外壳，所以我们可以问什么T 

00:05:31.380 --> 00:05:37.039
类及其模块

00:05:39.450 --> 00:05:42.600
 Javadoc续集有自己的模块

00:05:41.340 --> 00:05:44.340
如果只是有另一件事

00:05:42.600 --> 00:05:45.780
您将没有的基本模块

00:05:44.340 --> 00:05:48.570
如果你是续集类型

00:05:45.780 --> 00:05:50.160
编写模块化应用程序，您

00:05:48.570 --> 00:05:52.440
需要使用续集，那么你需要

00:05:50.160 --> 00:05:54.210
确保沿线某处

00:05:52.440 --> 00:05:56.220
包含您的代码的模块要求

00:05:54.210 --> 00:05:57.440
续集，我们将看到更多有关此的内容

00:05:56.220 --> 00:06:03.030
后来

00:05:57.440 --> 00:06:03.930
已经是J壳了，还有什么哦

00:06:03.030 --> 00:06:07.890
对

00:06:03.930 --> 00:06:09.680
就像我今天早上说的那样

00:06:07.890 --> 00:06:12.300
他们那里很多

00:06:09.680 --> 00:06:14.610
我对成为一个人感到困惑

00:06:12.300 --> 00:06:15.870
想哦，Java 9不会

00:06:14.610 --> 00:06:17.520
运行我必须比较的旧代码

00:06:15.870 --> 00:06:18.600
一切都到模块或

00:06:17.520 --> 00:06:20.670
有很多不兼容性

00:06:18.600 --> 00:06:22.500
因为他们隐藏了内部猫

00:06:20.670 --> 00:06:25.740
模块内部的类和类似的东西

00:06:22.500 --> 00:06:31.530
只是为了在这里提出一点

00:06:25.740 --> 00:06:33.000
在这里秋千设置为飞镖，任何人

00:06:31.530 --> 00:06:36.060
记得在

00:06:33.000 --> 00:06:37.950
过去，秋千是一件很重要的事情，所以

00:06:36.060 --> 00:06:39.660
秋千设置为您所知道的

00:06:37.950 --> 00:06:41.490
所有人的母亲在演示时摇摆他们

00:06:39.660 --> 00:06:46.020
一切可能的每个挥杆部件

00:06:41.490 --> 00:06:50.280
模式，这是来自JDK的确切jar文件

00:06:46.020 --> 00:06:58.620
日期文件的日期为2000年的5ga是

00:06:50.280 --> 00:07:02.250
少年Java不是jsr是的右摇摆

00:06:58.620 --> 00:07:05.280
设置为jar凯蒂犬建立模型

00:07:02.250 --> 00:07:09.270
系统的一切，是的，它的工作原理

00:07:05.280 --> 00:07:12.240
所有的东西都在那里，我们有你

00:07:09.270 --> 00:07:13.560
认识太空人的孩子，所以所有的

00:07:12.240 --> 00:07:15.300
秋千出生时出生的婴儿

00:07:13.560 --> 00:07:18.680
在早期发展像

00:07:15.300 --> 00:07:21.270
现在大学毕业了，你知道吗

00:07:18.680 --> 00:07:24.120
实际上有很多

00:07:21.270 --> 00:07:25.980
九个方面的兼容性不如

00:07:24.120 --> 00:07:27.780
您可能听说过，有问题

00:07:25.980 --> 00:07:29.730
但是每个专业的问题

00:07:27.780 --> 00:07:31.850
平台发布，因为我们必须

00:07:29.730 --> 00:07:34.950
能够推动平台向前发展

00:07:31.850 --> 00:07:38.160
好了，现在让我们回到我们的

00:07:34.950 --> 00:07:42.600
你好，所以你有这么一点

00:07:38.160 --> 00:07:46.910
用Java命名的家伙进行编译

00:07:42.600 --> 00:07:51.200
 Java CD类

00:07:46.910 --> 00:07:54.800
或来源或去我爱我爱水龙头

00:07:51.200 --> 00:08:01.010
完成，好吧，我们把它塞进去

00:07:54.800 --> 00:08:17.720
通常的方法让我们把它放到库中

00:08:01.010 --> 00:08:21.280
目录jar，但我一直在输入

00:08:17.720 --> 00:08:21.280
是弗洛伊德的东西

00:08:23.410 --> 00:08:33.430
 openjdk和繁荣它起作用，我们可以

00:08:31.100 --> 00:08:33.430
类型

00:08:36.660 --> 00:08:43.770
任何参数，它都通过了

00:08:41.820 --> 00:08:45.990
你刚刚做的字符串好吗？ 

00:08:43.770 --> 00:08:49.200
一个jar文件，就像Java 101一样，为什么

00:08:45.990 --> 00:08:52.920
您在此浪费我们的时间，让我们

00:08:49.200 --> 00:08:56.310
稍作更改，我们将转换为

00:08:52.920 --> 00:08:59.030
到一个简单的模块中，我们该怎么做

00:08:56.310 --> 00:09:04.440
首先，启动我最喜欢的IDE 

00:08:59.030 --> 00:09:06.630
即Emacs这里是这里

00:09:04.440 --> 00:09:08.280
主班我们这样做的主要

00:09:06.630 --> 00:09:10.530
在其包装中分类

00:09:08.280 --> 00:09:14.190
目录或组织斜杠打开JDK斜杠

00:09:10.530 --> 00:09:20.550
你好，我们要放一个新文件

00:09:14.190 --> 00:09:22.470
根本没有调用模块信息

00:09:20.550 --> 00:09:25.820
进入任何特定的软件包目录

00:09:22.470 --> 00:09:27.900
所以模块信息文件是新事物

00:09:25.820 --> 00:09:30.420
这些是模块的疾病

00:09:27.900 --> 00:09:32.250
声明去模块声明是

00:09:30.420 --> 00:09:35.460
他们烤的语言的一部分

00:09:32.250 --> 00:09:44.610
深入地制作一个模块

00:09:35.460 --> 00:09:47.310
给它起个名字或打开JDK 

00:09:44.610 --> 00:09:51.350
模块不需要任何其他模块

00:09:47.310 --> 00:09:54.090
实际上它需要棒球模块

00:09:51.350 --> 00:09:55.950
但是由于每个模块都需要基础

00:09:54.090 --> 00:09:57.360
除了基本模块，我们

00:09:55.950 --> 00:10:00.750
实际上不需要说你可以

00:09:57.360 --> 00:10:02.210
如果您想要，但它没有价值，那么我们将

00:10:00.750 --> 00:10:06.240
只是这样做，我们有一个模块信息

00:10:02.210 --> 00:10:10.520
这个名字是我们的模块，现在让我们

00:10:06.240 --> 00:10:10.520
再次编译不好

00:10:16.430 --> 00:10:36.350
除非课程还不错，否则我们把它搞砸了

00:10:20.890 --> 00:10:38.240
哎呀，现在你好在罐子里

00:10:36.350 --> 00:10:39.830
得到了模块享受类模块由内而外

00:10:38.240 --> 00:10:42.920
 Java文件由编译器编译

00:10:39.830 --> 00:10:45.800
到您可以工作的模块信息类文件中

00:10:42.920 --> 00:10:47.390
你可以通过Java P运行它

00:10:45.800 --> 00:10:50.300
只需在这里使用classes目录并

00:10:47.390 --> 00:10:51.590
它很好地告诉你，是的

00:10:50.300 --> 00:10:52.970
我们期望的需求基础

00:10:51.590 --> 00:10:57.890
是由

00:10:52.970 --> 00:11:00.200
可以编译这个hello jar 

00:10:57.890 --> 00:11:02.750
实际上，您实际上可以将其作为

00:11:00.200 --> 00:11:06.470
类路径和模块信息文件

00:11:02.750 --> 00:11:11.810
被忽略，所以就像我在

00:11:06.470 --> 00:11:13.850
上课之前，我可以再做一次

00:11:11.810 --> 00:11:16.040
我也可以将该Lib目录视为

00:11:13.850 --> 00:11:18.110
模块路径模块路径是新事物

00:11:16.040 --> 00:11:21.310
您将实际模块放在jar中的位置

00:11:18.110 --> 00:11:23.510
包含模块信息的文件

00:11:21.310 --> 00:11:25.310
尽管它们是细节

00:11:23.510 --> 00:11:29.410
我将得到它并进入我的

00:11:25.310 --> 00:11:32.600
明天第二讲，所以Java模块一半

00:11:29.410 --> 00:11:36.770
 Lib我要告诉它我使用哪个模块

00:11:32.600 --> 00:11:42.080
要运行JDK的问候，我需要告诉

00:11:36.770 --> 00:11:47.450
它在该模块中运行什么类并

00:11:42.080 --> 00:11:49.250
我现在可以了

00:11:47.450 --> 00:11:51.200
没什么大不了的，但是那有点

00:11:49.250 --> 00:11:53.180
第一个婴儿第二步，我们只是采取了

00:11:51.200 --> 00:11:56.630
一些简单的Hello World应用程序

00:11:53.180 --> 00:11:58.520
现在是一个模块，现在我们可以

00:11:56.630 --> 00:12:04.370
去做一些更有趣的事情

00:11:58.520 --> 00:12:06.620
我喜欢其他问题的事情

00:12:04.370 --> 00:12:09.140
在其生命中询问它

00:12:06.620 --> 00:12:11.210
模块，以便我们可以询问我们可以询问

00:12:09.140 --> 00:12:15.340
运行时系统好吧，看看

00:12:11.210 --> 00:12:15.340
模块路径并为我描述一个模块

00:12:18.130 --> 00:12:25.040
在这里打印出运行时

00:12:21.590 --> 00:12:26.450
该模块在说什么

00:12:25.040 --> 00:12:28.460
它需要Java点基础

00:12:26.450 --> 00:12:30.230
由语言规范授权

00:12:28.460 --> 00:12:32.630
包含一个包或完全打开的JDK 

00:12:30.230 --> 00:12:38.540
你好，当然是组织名称

00:12:32.630 --> 00:12:43.100
打开JDK dot hello让我们看看还有什么

00:12:38.540 --> 00:12:48.170
是的，所以继续前进只是为了

00:12:43.100 --> 00:12:55.100
使生活更简单

00:12:48.170 --> 00:12:56.600
切入点，我们一直在

00:12:55.100 --> 00:12:58.790
增强了可怜的旧jar工具

00:12:56.600 --> 00:13:00.910
此版本中的所有内容

00:12:58.790 --> 00:13:03.860
制作等方便的事情

00:13:00.910 --> 00:13:05.930
指定入口点，并在

00:13:03.860 --> 00:13:08.060
模块系统的入口点

00:13:05.930 --> 00:13:10.160
模块实际上记录在

00:13:08.060 --> 00:13:14.420
模块信息点类文件，现在到

00:13:10.160 --> 00:13:16.760
运行我不需要指定的

00:13:14.420 --> 00:13:18.290
类名，因为现在有一个

00:13:16.760 --> 00:13:20.690
与模块关联的主类

00:13:18.290 --> 00:13:23.090
如果我要它描述那个模块

00:13:20.690 --> 00:13:24.710
它会告诉我现在我以前服用

00:13:23.090 --> 00:13:27.850
它应该告诉我主要的课程是什么

00:13:24.710 --> 00:13:32.900
那里有个小虫子

00:13:27.850 --> 00:13:34.490
好的，所以我们有这个

00:13:32.900 --> 00:13:37.400
非常简单的模块，我们有一个模块

00:13:34.490 --> 00:13:40.850
信息，我们有一个主要的主要Java 

00:13:37.400 --> 00:13:41.960
让我们进行重构重构是

00:13:40.850 --> 00:13:44.510
总是很有趣，所以我们要

00:13:41.960 --> 00:13:47.480
重构成两个模块吧

00:13:44.510 --> 00:13:49.250
因为自从你再次认识我们

00:13:47.480 --> 00:13:50.780
来自JavaScript的经验

00:13:49.250 --> 00:13:53.390
世界左城真的需要成为它的

00:13:50.780 --> 00:13:56.540
自己的模块，所以我们在输入左垫

00:13:53.390 --> 00:13:59.150
它自己的模块，并具有

00:13:56.540 --> 00:14:00.890
 HelloWorld模块取决于该模块

00:13:59.150 --> 00:14:04.250
因此，我们将了解模块依赖性和

00:14:00.890 --> 00:14:05.660
出口如何运作，让我们开始吧

00:14:04.250 --> 00:14:07.310
首先要做一些手术

00:14:05.660 --> 00:14:13.540
重新安排一些这些

00:14:07.310 --> 00:14:13.540
目录在这里，让我们来武装一下

00:14:14.110 --> 00:14:23.740
我们将要重命名源的类

00:14:17.390 --> 00:14:25.560
 org dot open JDK你好，我们要

00:14:23.740 --> 00:14:27.420
使

00:14:25.560 --> 00:14:29.399
我们要去的新的源目录

00:14:27.420 --> 00:14:33.870
移动组织开放数据Colette好的，你好

00:14:29.399 --> 00:14:36.089
进去，我们要放一些

00:14:33.870 --> 00:14:38.550
一些新的东西在那里，所以在模块化

00:14:36.089 --> 00:14:40.769
每个模块都有自己的源代码树

00:14:38.550 --> 00:14:43.139
您在其中找到目录

00:14:40.769 --> 00:14:45.689
正常的旧程序包层次结构

00:14:43.139 --> 00:14:47.220
模块信息Java就在

00:14:45.689 --> 00:14:48.870
名称是本机的目录

00:14:47.220 --> 00:14:50.339
模块的全名，是的

00:14:48.870 --> 00:14:52.379
这里有些冗余，因为

00:14:50.339 --> 00:14:54.720
名称是模块，名称相同

00:14:52.379 --> 00:14:58.949
仅在这种情况下作为其主体

00:14:54.720 --> 00:15:00.990
包，但是你去那是它

00:14:58.949 --> 00:15:02.670
最明智的命名方式

00:15:00.990 --> 00:15:05.009
您选择的模块选择主要

00:15:02.670 --> 00:15:07.230
里面的包，这就是

00:15:05.009 --> 00:15:14.480
您的模块请使用反向DNS 

00:15:07.230 --> 00:15:14.480
没事就好了，让我们放弃

00:15:17.209 --> 00:15:23.910
好的，所以我们要说的是

00:15:22.439 --> 00:15:27.779
我们要去对不起

00:15:23.910 --> 00:15:31.949
首先，让我们重构主

00:15:27.779 --> 00:15:34.170
方法主类，而我们要去

00:15:31.949 --> 00:15:36.000
把它拿出左垫我们

00:15:34.170 --> 00:15:42.899
将要制作一个全新的模块组织点

00:15:36.000 --> 00:15:47.360
打开JDK点txt或打开JDK文本，让我们

00:15:42.899 --> 00:15:47.360
说粉Java 

00:15:51.360 --> 00:15:53.989
是的

00:15:54.900 --> 00:15:58.310
这里我们包

00:16:02.389 --> 00:16:13.369
我是一个班级模式让我们做这个

00:16:07.279 --> 00:16:17.089
公益公益让生活变得简单

00:16:13.369 --> 00:16:18.799
我们需要这个文本家伙的模块信息

00:16:17.089 --> 00:16:22.910
这将继续下去

00:16:18.799 --> 00:16:24.709
去这里的根源

00:16:22.910 --> 00:16:29.239
高于此特定模块

00:16:24.709 --> 00:16:32.860
模块封装了更高的层次结构，因此

00:16:29.239 --> 00:16:32.860
模块获得一个名字

00:16:33.130 --> 00:16:36.570
 [音乐] 

00:16:39.980 --> 00:16:50.900
我们去那里或现在的OpenJDK文本

00:16:48.410 --> 00:16:52.310
他们是高级的，那里有三个

00:16:50.900 --> 00:16:55.700
有关模块的基本知识

00:16:52.310 --> 00:16:56.990
有个名字

00:16:55.700 --> 00:17:00.080
出口包装

00:16:56.990 --> 00:17:01.880
可能为零，它还有一些其他模块

00:17:00.080 --> 00:17:03.290
这取决于我们

00:17:01.880 --> 00:17:06.640
 Java的基础知识

00:17:03.290 --> 00:17:09.290
默认，所以文本模块将

00:17:06.640 --> 00:17:11.089
正在创建供其他人使用的API 

00:17:09.290 --> 00:17:14.300
模块，因此需要导出其

00:17:11.089 --> 00:17:19.190
主体包，所以我们写出口或

00:17:14.300 --> 00:17:20.690
打开JDK不发短信，只需要

00:17:19.190 --> 00:17:21.290
有基础，所以我们不必说

00:17:20.690 --> 00:17:25.120
在这里

00:17:21.290 --> 00:17:31.660
现在我们应该能够编译

00:17:25.120 --> 00:17:41.350
文本模块让我确定正确

00:17:31.660 --> 00:17:41.350
做或创建它

00:17:41.900 --> 00:17:45.070
我只是在这里作弊

00:17:49.580 --> 00:18:03.770
正确，让我们得出结论，没有主要的

00:17:55.400 --> 00:18:08.780
在这里上课哦哦亲爱的

00:18:03.770 --> 00:18:09.590
我知道先确定目录

00:18:08.780 --> 00:18:11.660
我们将为您使用

00:18:09.590 --> 00:18:13.780
好的，所以客户我们已经上课了

00:18:11.660 --> 00:18:19.220
我们有课程，有自由图书馆

00:18:13.780 --> 00:18:20.690
这是斯科特的文本罐

00:18:19.220 --> 00:18:22.460
模块信息，现在我们无法运行

00:18:20.690 --> 00:18:25.270
因为没有，因为没有

00:18:22.460 --> 00:18:29.780
 main，但是现在我们可以编译Hello了

00:18:25.270 --> 00:18:36.680
我们首先必须编辑的模块

00:18:29.780 --> 00:18:39.290
记住关于

00:18:36.680 --> 00:18:41.150
模块，它的名字有出口， 

00:18:39.290 --> 00:18:44.300
它必须说出它需要什么，现在

00:18:41.150 --> 00:18:48.200
 Hello模块将需要或

00:18:44.300 --> 00:18:50.150
打开JDK文本不是包，而是

00:18:48.200 --> 00:18:53.830
恰好具有

00:18:50.150 --> 00:18:53.830
垫上同名包裹

00:18:54.520 --> 00:19:01.570
好吧，让我们编译一下

00:19:06.930 --> 00:19:13.380
现在让我们保存工作的第一标记

00:19:15.480 --> 00:19:20.350
找不到模块或Gobind gatk文本I 

00:19:18.250 --> 00:19:22.120
没有告诉编译器在哪里找到

00:19:20.350 --> 00:19:26.740
我们已经编译的文本模块

00:19:22.120 --> 00:19:28.210
所以让我们告诉编译器

00:19:26.740 --> 00:19:32.800
编译器采用模块路径，就像

00:19:28.210 --> 00:19:35.710
运行时采用了我无法使用的模块路径

00:19:32.800 --> 00:19:39.310
找到符号哦，是的，今天10点-我

00:19:35.710 --> 00:19:49.000
爱静态打字图案左垫

00:19:39.310 --> 00:19:56.650
我喜欢静态输入，真的可以导入

00:19:49.000 --> 00:19:58.900
或openjdk文本模式好吗，我们该怎么办

00:19:56.650 --> 00:20:01.860
有内部Lib目录，但不是免费的

00:19:58.900 --> 00:20:01.860
必须做罐子市场

00:20:07.040 --> 00:20:14.890
将目录解放到jar文件，我们现在可以

00:20:12.590 --> 00:20:14.890
跑

00:20:20.880 --> 00:20:25.430
哦，我忘了那意味着我就去做

00:20:23.310 --> 00:20:25.430
这个

00:20:27.470 --> 00:20:32.309
你好世界，现在实际上

00:20:29.910 --> 00:20:34.080
在运行时组装它

00:20:32.309 --> 00:20:34.710
获取文本模块实例化

00:20:34.080 --> 00:20:36.840
它得到

00:20:34.710 --> 00:20:40.400
几个世纪以来的hello模块

00:20:36.840 --> 00:20:43.920
他们起来，并以模块化的形式运行

00:20:40.400 --> 00:20:47.549
所以保真真的很重要

00:20:43.920 --> 00:20:50.490
我们尝试过的各个阶段的保真度

00:20:47.549 --> 00:20:51.929
尽可能使我的意思不仅仅是

00:20:50.490 --> 00:20:53.940
命令行之类的世俗事物

00:20:51.929 --> 00:20:56.250
选项，虽然这是那里的能力

00:20:53.940 --> 00:20:58.740
也是有用的，但是模型系统可以工作

00:20:56.250 --> 00:21:02.150
尽可能以相同的方式

00:20:58.740 --> 00:21:06.059
像在运行时一样编译时间，因此

00:21:02.150 --> 00:21:08.340
以相同的方式检测错误

00:21:06.059 --> 00:21:12.320
两个阶段或更少且错误

00:21:08.340 --> 00:21:15.710
消息非常相似，例如

00:21:12.320 --> 00:21:18.510
在Lib目录中，假设我删除了

00:21:15.710 --> 00:21:19.890
 Lib文本很好，我们实际上

00:21:18.510 --> 00:21:22.440
已经看到了一个例子，但我会

00:21:19.890 --> 00:21:25.710
只需再次运行它，但如果我尝试

00:21:22.440 --> 00:21:27.120
即使编译Hello模块

00:21:25.710 --> 00:21:29.160
我确实给了它模块路径

00:21:27.120 --> 00:21:31.110
表示找不到模块或输入JDK文本

00:21:29.160 --> 00:21:38.160
因为那个jar文件不存在

00:21:31.110 --> 00:21:40.620
如果我尝试运行hello模块，我会得到一个

00:21:38.160 --> 00:21:43.200
类似的消息模块打开的JDK文本不行

00:21:40.620 --> 00:21:45.179
发现它不在Lib目录中，所以

00:21:43.200 --> 00:21:46.890
你知道这是其中之一

00:21:45.179 --> 00:21:49.169
关于可靠的伟大之处

00:21:46.890 --> 00:21:50.940
配置它不是正确的报告

00:21:49.169 --> 00:21:52.740
如果缺少某些东西，那不是

00:21:50.940 --> 00:21:55.080
就像它不像类路径一样

00:21:52.740 --> 00:21:56.910
如果缺少什么，你就不会

00:21:55.080 --> 00:21:59.309
发现它，直到您的应用程序被

00:21:56.910 --> 00:22:00.990
启动并运行数小时或数天

00:21:59.309 --> 00:22:07.370
知道什么时候马上知道

00:22:00.990 --> 00:22:07.370
缺少，让我们重新编译

00:22:10.149 --> 00:22:20.960
文本模型，我们会把它找回来

00:22:12.739 --> 00:22:22.729
进入我们的需求

00:22:20.960 --> 00:22:24.889
这是该模块的措施

00:22:22.729 --> 00:22:26.559
四个用于hello模块

00:22:24.889 --> 00:22:34.519
发生是因为我们对此进行了注释

00:22:26.559 --> 00:22:34.999
我们可以编译一下吗，您现在怎么想

00:22:34.519 --> 00:22:38.320
这很奇怪

00:22:34.999 --> 00:22:38.320
哦，两个宜居的掘金

00:22:46.030 --> 00:22:52.300
它被classes目录弄糊涂了

00:22:49.710 --> 00:22:56.320
是的，我们去包org open JDK 

00:22:52.300 --> 00:22:59.050
文字不存在，因为我们没有

00:22:56.320 --> 00:23:04.740
需要正确的东西，所以编译器

00:22:59.050 --> 00:23:04.740
也知道这一切，它可以重新编译

00:23:12.320 --> 00:23:15.100
嗯

00:23:15.200 --> 00:23:20.610
好吧，有各种各样的

00:23:17.970 --> 00:23:23.610
其他错误和另一个有趣的错误

00:23:20.610 --> 00:23:25.950
如果您无法导出某些内容

00:23:23.610 --> 00:23:27.659
这是导出的API，我可以评论

00:23:25.950 --> 00:23:29.340
这样重新编译编译器会

00:23:27.659 --> 00:23:31.799
抓住它我可以尝试在运行时运行它

00:23:29.340 --> 00:23:36.570
时间和运行时间系统将

00:23:31.799 --> 00:23:39.389
很好地捕获它

00:23:36.570 --> 00:23:42.720
足够的小演示，所以

00:23:39.389 --> 00:23:46.019
 JDK是我们已经分解了，我们使用了这个

00:23:42.720 --> 00:23:49.289
模块系统将其分解为一组

00:23:46.019 --> 00:23:51.570
您只需键入Java就可以设置模块数量

00:23:49.289 --> 00:23:54.590
点列表模块，您将获得整个

00:23:51.570 --> 00:23:58.710
清单上有很多哦

00:23:54.590 --> 00:24:01.259
让我们分页，他们开始了很多

00:23:58.710 --> 00:24:04.139
用字母JAV点，因为

00:24:01.259 --> 00:24:05.610
它们是Java SE平台的一部分，因此

00:24:04.139 --> 00:24:07.529
他们是你知道他们在那里的官方

00:24:05.610 --> 00:24:09.330
受到JCP和所有这些的祝福

00:24:07.529 --> 00:24:10.620
其他所有其他好东西

00:24:09.330 --> 00:24:13.049
是他们开始的一堆其他模块

00:24:10.620 --> 00:24:15.120
带有jdk点，因为它们属于

00:24:13.049 --> 00:24:17.580
他们的JDK特有的一些是

00:24:15.120 --> 00:24:19.500
内部他们不导出任何API是

00:24:17.580 --> 00:24:21.179
在jdk之外，其中一些是

00:24:19.500 --> 00:24:22.710
您实际上可以在JDK的某些部分

00:24:21.179 --> 00:24:24.960
针对他们的AP眼睛写代码

00:24:22.710 --> 00:24:27.179
就是说我们在

00:24:24.960 --> 00:24:29.519
从某种意义上讲，但他们是他们不属于

00:24:27.179 --> 00:24:31.769
标准的，所以如果你从

00:24:29.519 --> 00:24:35.279
来自其他地方的人

00:24:31.769 --> 00:24:43.740
没有它有很多

00:24:35.279 --> 00:24:46.830
模块7575模块仅28 28 

00:24:43.740 --> 00:24:48.690
它们是所谓的标准

00:24:46.830 --> 00:24:50.909
模型，它们都在图表上

00:24:48.690 --> 00:24:54.169
等你有依赖模块

00:24:50.909 --> 00:24:57.659
关系，你可以做一个图和

00:24:54.169 --> 00:25:03.289
这是图，因此快速浏览

00:24:57.659 --> 00:25:03.289
我们在底部有java java base 

00:25:03.409 --> 00:25:08.009
在那里，如果你看着这种

00:25:06.179 --> 00:25:10.169
幻灯片的底部

00:25:08.009 --> 00:25:12.149
事情是你知道的，你可以使用

00:25:10.169 --> 00:25:15.120
这里的东西不用用完

00:25:12.149 --> 00:25:19.620
右上方有一个模块

00:25:15.120 --> 00:25:23.490
称为Java SE，可以让您

00:25:19.620 --> 00:25:27.600
属于Java SE而非api的api 

00:25:23.490 --> 00:25:28.010
 java ee的一部分，有一种模块方式

00:25:27.600 --> 00:25:30.950
的

00:25:28.010 --> 00:25:33.020
称为Java scee，其中包括

00:25:30.950 --> 00:25:36.140
工会，所以如果你真的想要一切

00:25:33.020 --> 00:25:38.299
在Java中包括八

00:25:36.140 --> 00:25:40.880
包括所有您需要的EE东西

00:25:38.299 --> 00:25:44.540
用于使用该模块，否则使用Java 

00:25:40.880 --> 00:25:46.580
 SC是稍微精简的设置，因此

00:25:44.540 --> 00:25:50.360
基地在这里，这令人不安

00:25:46.580 --> 00:25:53.780
对象绘制空白字符串IO lang语util 

00:25:50.360 --> 00:25:56.000
是的，但是有很多安全方面的东西

00:25:53.780 --> 00:25:57.890
这些都是其他模块

00:25:56.000 --> 00:26:00.350
坐在顶部，然后是所有JDK 

00:25:57.890 --> 00:26:02.419
每个模型都模拟许多JDK模块

00:26:00.350 --> 00:26:04.880
包含他们给的服务提供商

00:26:02.419 --> 00:26:09.730
迷上了Java 

00:26:04.880 --> 00:26:11.750
通过服务机制的模块

00:26:09.730 --> 00:26:13.480
看这张图，你注意到了什么

00:26:11.750 --> 00:26:19.429
关于这件事

00:26:13.480 --> 00:26:23.809
记住图论101对不起

00:26:19.429 --> 00:26:26.179
 dag没有正确的周期，所以这

00:26:23.809 --> 00:26:29.120
模块系统不允许循环

00:26:26.179 --> 00:26:31.880
这有点争议

00:26:29.120 --> 00:26:34.610
决定，但不允许循环

00:26:31.880 --> 00:26:36.620
因为模块图中的周期是

00:26:34.610 --> 00:26:39.380
通常是一个非常糟糕的做法，这是

00:26:36.620 --> 00:26:41.419
不只是我的个人意见专家

00:26:39.380 --> 00:26:44.240
该领域一直为此提倡

00:26:41.419 --> 00:26:46.130
好一阵子了，没雪

00:26:44.240 --> 00:26:47.870
但是有一些方法可以在

00:26:46.130 --> 00:26:50.720
如果确实需要运行时

00:26:47.870 --> 00:26:53.540
反射API，但默认为循环

00:26:50.720 --> 00:26:55.070
只是不是一件很酷的事情

00:26:53.540 --> 00:26:57.770
事情，他们得到一点点

00:26:55.070 --> 00:27:00.530
小蝇头再次偏离轨道，但我会

00:26:57.770 --> 00:27:03.200
很乐意向您展示Java文档所了解的知识

00:27:00.530 --> 00:27:06.260
现在可以使用模块，因此Java文档主页面是

00:27:03.200 --> 00:27:09.440
不再是近乎无限的

00:27:06.260 --> 00:27:12.950
打包它实际上是一个结构化的

00:27:09.440 --> 00:27:14.990
您知道的模块清单

00:27:12.950 --> 00:27:17.679
 Java Donbass，但您可以向下滚动并

00:27:14.990 --> 00:27:20.710
您会首先看到所有Java语言， 

00:27:17.679 --> 00:27:25.190
然后最终有一些JDK 

00:27:20.710 --> 00:27:27.679
支持的api的显示，并且其中之一

00:27:25.190 --> 00:27:29.720
关于这个很酷的事情

00:27:27.679 --> 00:27:34.669
 Java文档增强功能可以进入

00:27:29.720 --> 00:27:37.220
一个模块和模块的主页

00:27:34.669 --> 00:27:39.440
包含部分模块图，所以它

00:27:37.220 --> 00:27:41.260
如果您可以直观地看到您

00:27:39.440 --> 00:27:45.340
使用CORBA 

00:27:41.260 --> 00:27:51.660
那么你也将获得RMI 

00:27:45.340 --> 00:27:54.160
也将获得桌面，因为CORBA 

00:27:51.660 --> 00:27:56.140
和桌面民意测验以及数据传输以及

00:27:54.160 --> 00:27:59.890
 XML，当然还有一切

00:27:56.140 --> 00:28:01.960
取决于基于Java的方式，所以这些

00:27:59.890 --> 00:28:03.880
小图真的很方便

00:28:01.960 --> 00:28:07.240
 Java Java文档让您对

00:28:03.880 --> 00:28:09.640
发生了什么事真的你知道

00:28:07.240 --> 00:28:11.760
 Java中超酷功能的快速广告

00:28:09.640 --> 00:28:15.460
 doc Java doc现已内置搜索

00:28:11.760 --> 00:28:17.350
 Java脚本对某些事情很有用，所以如果

00:28:15.460 --> 00:28:21.190
我想看到像工作一样的工作

00:28:17.350 --> 00:28:23.050
 Lang模型API看起来像我刚刚输入的

00:28:21.190 --> 00:28:25.000
那和繁荣我在那里你没有

00:28:23.050 --> 00:28:26.740
穿过树木丛生， 

00:28:25.000 --> 00:28:29.710
单击左右，到处都是

00:28:26.740 --> 00:28:32.340
可以搜索，然后就可以了

00:28:29.710 --> 00:28:32.340
那很漂亮

00:28:36.020 --> 00:28:42.130
好吧，我们要做的最后一件事

00:28:38.780 --> 00:28:45.830
希望表明您正在链接，所以在

00:28:42.130 --> 00:28:48.830
 Java 9作为拼图的一部分，我们添加了一个

00:28:45.830 --> 00:28:53.179
 Java从未拥有过的东西

00:28:48.830 --> 00:28:54.679
您知道CCC始终是一个链接器

00:28:53.179 --> 00:28:56.120
有正确的链接器，为什么Java没有

00:28:54.679 --> 00:29:00.230
链接器很好，因为Java是

00:28:56.120 --> 00:29:03.800
主要是一种非常动态的语言

00:29:00.230 --> 00:29:06.740
就其运行时行为而言

00:29:03.800 --> 00:29:10.580
模块系统强加它就是

00:29:06.740 --> 00:29:14.600
旨在施加足够的静态

00:29:10.580 --> 00:29:16.100
我们可以进行链接的约束是

00:29:14.600 --> 00:29:17.900
一条路线，这就是为什么

00:29:16.100 --> 00:29:21.530
你不知道那不是完全

00:29:17.900 --> 00:29:23.750
懒惰至少不是默认情况下，所以链接

00:29:21.530 --> 00:29:26.240
让我们将jdk作为一堆交付

00:29:23.750 --> 00:29:28.100
模块工件的集合，您可以链接

00:29:26.240 --> 00:29:30.860
包含仅

00:29:28.100 --> 00:29:33.080
您需要并且非常了解的模块

00:29:30.860 --> 00:29:36.050
也许与您自己的代码一起

00:29:33.080 --> 00:29:38.030
这是我一直在使用的JDK 

00:29:36.050 --> 00:29:39.920
你知道我已经在

00:29:38.030 --> 00:29:42.590
一个lib目录和法律和其他

00:29:39.920 --> 00:29:48.429
东西没有弧线

00:29:42.590 --> 00:29:52.340
在那里的j-mods目录

00:29:48.429 --> 00:29:55.160
包含一堆J mod文件和

00:29:52.340 --> 00:29:58.429
每个文件都有一个

00:29:55.160 --> 00:30:00.500
系统中的Java或JDK模块

00:29:58.429 --> 00:30:03.080
这些人有75个，所以J mod是

00:30:00.500 --> 00:30:04.790
因为不是他们的jar文件，J mod是

00:30:03.080 --> 00:30:07.309
特定于

00:30:04.790 --> 00:30:09.140
 JDK是类固醇上的jar文件

00:30:07.309 --> 00:30:11.030
因为对于JDK本身，我们必须

00:30:09.140 --> 00:30:14.179
能够处理你知道的事情

00:30:11.030 --> 00:30:15.920
本机代码和法律声明以及

00:30:14.179 --> 00:30:18.650
配置文件和许多其他

00:30:15.920 --> 00:30:20.240
东西，你就是不可能

00:30:18.650 --> 00:30:22.160
拿一个普通的jar文件进行匹配

00:30:20.240 --> 00:30:23.870
以某种方式

00:30:22.160 --> 00:30:27.230
因此，J mods写道

00:30:23.870 --> 00:30:28.760
基于像jar这样的zip格式，但是

00:30:27.230 --> 00:30:30.380
至少针对其数据案例

00:30:28.760 --> 00:30:33.170
现在也许他们以后会标准化

00:30:30.380 --> 00:30:35.570
如果以后有理由再做

00:30:33.170 --> 00:30:37.400
在给定的目录下

00:30:35.570 --> 00:30:40.190
完整的J mod文件，您可以运行此新文件

00:30:37.400 --> 00:30:44.260
称为J link的工具

00:30:40.190 --> 00:30:44.260
只要给它一个模块路径

00:30:44.650 --> 00:30:51.640
你告诉它你想要什么模块

00:30:48.450 --> 00:30:52.900
你总是必须告诉jailing 

00:30:51.640 --> 00:30:54.850
从哪儿开始

00:30:52.900 --> 00:30:56.710
我们只是开始，您可以

00:30:54.850 --> 00:31:00.630
制作一个只有

00:30:56.710 --> 00:31:07.990
基本模块放入其中，我们将其放入

00:31:00.630 --> 00:31:08.170
假设JRE是的，应该可以正常工作

00:31:07.990 --> 00:31:09.580
对

00:31:08.170 --> 00:31:13.200
它会暂时消失

00:31:09.580 --> 00:31:17.050
现在我们有自己的自定义JRE 

00:31:13.200 --> 00:31:19.330
这是整个JDK 9的大小

00:31:17.050 --> 00:31:23.830
我一直在与553合作

00:31:19.330 --> 00:31:27.000
这是JRE的兆字节

00:31:23.830 --> 00:31:29.530
我刚做的只有48兆字节

00:31:27.000 --> 00:31:31.300
它有一个bin目录，但是没有

00:31:29.530 --> 00:31:32.620
有很多Java和很好的keytool 

00:31:31.300 --> 00:31:39.179
因为那部分安全性

00:31:32.620 --> 00:31:42.000
在基本模块中，我可以运行它

00:31:39.179 --> 00:31:46.480
可以列出其中的模块

00:31:42.000 --> 00:31:50.410
 woohoo它所拥有的只是基本模块

00:31:46.480 --> 00:31:57.370
我们可以走，我们可以走得更远

00:31:50.410 --> 00:32:00.120
可以走吧，让我们运行Lib，让我们运行

00:31:57.370 --> 00:32:00.120
你好模块

00:32:18.710 --> 00:32:22.070
那个儿子

00:32:24.200 --> 00:32:27.799
无论如何都应该正常工作，但这是

00:32:26.659 --> 00:32:35.450
不工作，我不会像

00:32:27.799 --> 00:32:37.580
得到实时的好，所以我们有

00:32:35.450 --> 00:32:38.899
这两个这两个杰里是我另一个

00:32:37.580 --> 00:32:41.929
 Jalen可以做的很酷的事情是可以

00:32:38.899 --> 00:32:44.029
压缩，如果您更关心空间

00:32:41.929 --> 00:32:47.119
比你在乎时间

00:32:44.029 --> 00:32:50.869
我们可以使用的其他选项

00:32:47.119 --> 00:32:56.960
压缩压缩-最高

00:32:50.869 --> 00:33:03.769
我们将使用最小的VM 

00:32:56.960 --> 00:33:06.220
我们将去除调试符号

00:33:03.769 --> 00:33:06.220
我在做什么

00:33:14.370 --> 00:33:19.540
我们最好把它放在其他地方

00:33:16.240 --> 00:33:21.430
因为那会冲突，所以这是

00:33:19.540 --> 00:33:23.260
要进行一些压缩，它将

00:33:21.430 --> 00:33:24.610
剥离东西，它将使用

00:33:23.260 --> 00:33:27.130
精简的虚拟机

00:33:24.610 --> 00:33:29.710
没有像JB MTI这样的东西

00:33:27.130 --> 00:33:31.630
您不能远程监控它，但也许

00:33:29.710 --> 00:33:35.080
我们将把它放在一个小的

00:33:31.630 --> 00:33:36.820
设备，没关系，所以它

00:33:35.080 --> 00:33:42.490
刚熄灭，它做了一些工作

00:33:36.820 --> 00:33:47.050
他们对他们对他们对我们

00:33:42.490 --> 00:33:49.270
压缩机面积只有15混合，但会

00:33:47.050 --> 00:33:50.290
运行它，它是Gaga放低音的

00:33:49.270 --> 00:33:55.150
整个交易

00:33:50.290 --> 00:33:58.240
那里你还好，所以

00:33:55.150 --> 00:34:00.880
到目前为止，我们已经演示了15分钟

00:33:58.240 --> 00:34:03.730
离开了问题，所以人们是否会

00:34:00.880 --> 00:34:05.920
喜欢问很棒的问题

00:34:03.730 --> 00:34:09.340
有很多信息

00:34:05.920 --> 00:34:11.290
那里有拼图吗？ 

00:34:09.340 --> 00:34:13.570
庞大的项目正在进行中

00:34:11.290 --> 00:34:18.220
好几年了，一二三

00:34:13.570 --> 00:34:20.820
在开放的JDK中执行四五六步

00:34:18.220 --> 00:34:24.790
 Java社区流程中的整个jsr 

00:34:20.820 --> 00:34:27.400
如果您打开JDK java.net斜杠

00:34:24.790 --> 00:34:29.919
你可以找到漂亮的项目斜线拼图

00:34:27.400 --> 00:34:35.560
我们拥有的所有信息

00:34:29.919 --> 00:34:37.750
这个URL过期了对不起

00:34:35.560 --> 00:34:39.850
它应该只说JDK java.net吗

00:34:37.750 --> 00:34:42.340
 JDK non Java拒绝它将重定向

00:34:39.850 --> 00:34:45.190
在正确的地方，我们可能

00:34:42.340 --> 00:34:47.860
发布JDK 9早期访问版本

00:34:45.190 --> 00:34:50.169
每周我们都会尽早发布拼图游戏

00:34:47.860 --> 00:34:52.120
访问每个版本的构建，就是您

00:34:50.169 --> 00:34:53.500
知道什么时候都有

00:34:52.120 --> 00:34:57.370
是拼图中的变化

00:34:53.500 --> 00:34:59.680
森林那些建筑显示发布日期

00:34:57.370 --> 00:35:02.680
计划好的发生时间表

00:34:59.680 --> 00:35:04.150
说7月27日，但随着戏剧

00:35:02.680 --> 00:35:07.240
本周初我会说

00:35:04.150 --> 00:35:08.920
发布日期不确定我有没有

00:35:07.240 --> 00:35:11.400
知道什么时候会发布

00:35:08.920 --> 00:35:13.990
会很快

00:35:11.400 --> 00:35:16.440
不相信我说过的话

00:35:13.990 --> 00:35:16.440
对于Oracle 

00:35:16.800 --> 00:35:28.600
问题，请问那里有麦克风吗

00:35:20.530 --> 00:35:31.420
周围或很棒，或者如果您射击， 

00:35:28.600 --> 00:35:37.800
害羞，随时发推文给我

00:35:31.420 --> 00:35:40.630
那会在这里打招呼是的- 

00:35:37.800 --> 00:35:43.300
有相当于班级的人吗

00:35:40.630 --> 00:35:46.030
模块的加载程序功能

00:35:43.300 --> 00:35:47.650
就像在

00:35:46.030 --> 00:35:50.680
模块化或类似的东西

00:35:47.650 --> 00:35:54.940
有没有相当于类加载器

00:35:50.680 --> 00:35:57.160
功能我不确定，所以所以

00:35:54.940 --> 00:35:59.260
模块系统实际上很少在乎

00:35:57.160 --> 00:36:02.410
关于类加载器，那是

00:35:59.260 --> 00:36:03.970
有意为我扎营

00:36:02.410 --> 00:36:05.830
实现良好的兼容性

00:36:03.970 --> 00:36:07.450
那里有很多应用程序但是

00:36:05.830 --> 00:36:09.490
类加载器有很多疯狂的事情

00:36:07.450 --> 00:36:12.780
我们希望他们能够利用

00:36:09.490 --> 00:36:16.330
您知道的模块系统以及

00:36:12.780 --> 00:36:18.430
只是平台本身，您的平台也是如此

00:36:16.330 --> 00:36:20.530
问题你可以创建一个模块吗

00:36:18.430 --> 00:36:24.730
好的，您可以动态加载模块吗

00:36:20.530 --> 00:36:27.460
系统启动好之后

00:36:24.730 --> 00:36:30.070
我现在能看到的任何动态

00:36:27.460 --> 00:36:32.380
甚至模块都包含静态

00:36:30.070 --> 00:36:35.980
一组类，显然一切正常

00:36:32.380 --> 00:36:37.810
但是可以在以下位置下载这些类

00:36:35.980 --> 00:36:39.970
从某个地方运行时，或者您知道

00:36:37.810 --> 00:36:43.030
设计的意思是那里没有

00:36:39.970 --> 00:36:46.180
肯定有动态的规定

00:36:43.030 --> 00:36:48.190
行为不像OSGi和

00:36:46.180 --> 00:36:50.050
那不是各种各样的模块

00:36:48.190 --> 00:36:52.690
在任何时候都可以来来去去

00:36:50.050 --> 00:36:54.130
完全动态的方式来代替

00:36:52.690 --> 00:36:55.630
去了解

00:36:54.130 --> 00:36:57.970
动态性，以便我们可以做类似的事情

00:36:55.630 --> 00:37:00.430
链接并更早报告错误

00:36:57.970 --> 00:37:02.290
及时而不是稍后

00:37:00.430 --> 00:37:05.050
层的概念，因此模块可以

00:37:02.290 --> 00:37:07.450
本质上是成堆的

00:37:05.050 --> 00:37:10.510
一层Lea一层

00:37:07.450 --> 00:37:13.150
分层的，所以图层也可以

00:37:10.510 --> 00:37:14.710
如果您在有向无环图中

00:37:13.150 --> 00:37:16.750
只需默认启动一个系统

00:37:14.710 --> 00:37:18.460
获取所有的启动层

00:37:16.750 --> 00:37:20.410
来自模块水龙头的应用模型

00:37:18.460 --> 00:37:23.170
将被加载，这就是所有

00:37:20.410 --> 00:37:24.340
平台模块已加载，但如果

00:37:23.170 --> 00:37:26.530
你在做某事

00:37:24.340 --> 00:37:28.030
您正在创建的高级文件

00:37:26.530 --> 00:37:29.420
他们说有插件的应用程序

00:37:28.030 --> 00:37:31.700
 API和您以及

00:37:29.420 --> 00:37:33.680
用户模块作为您的插件

00:37:31.700 --> 00:37:36.559
框架或东西，然后你可以旋转

00:37:33.680 --> 00:37:38.089
上一层来加载插件模块

00:37:36.559 --> 00:37:40.369
不能是插件模块的子图

00:37:38.089 --> 00:37:41.599
与其中的模型图有关

00:37:40.369 --> 00:37:43.490
较低的层，所以有

00:37:41.599 --> 00:37:45.230
所有这些的机制，就是你

00:37:43.490 --> 00:37:52.760
知道这是为了处理

00:37:45.230 --> 00:37:54.650
动态案例谢谢您我们在哪里

00:37:52.760 --> 00:37:56.089
诸如版本控制之类的事情，我很抱歉

00:37:54.650 --> 00:37:58.490
靠近我们在什么地方

00:37:56.089 --> 00:38:00.170
版本控制，所以您显然不知道

00:37:58.490 --> 00:38:02.599
就像目前的最后一个专利地狱是

00:38:00.170 --> 00:38:04.040
您知道的不同版本

00:38:02.599 --> 00:38:05.780
我敢肯定，我们所有人都不会改变我们的

00:38:04.040 --> 00:38:10.339
公共api，但偶尔

00:38:05.780 --> 00:38:14.000
似乎是对的，所以我需要站起来

00:38:10.339 --> 00:38:17.150
在这里，我可以听到你的声音，我们在哪里

00:38:14.000 --> 00:38:19.369
关于版本控制是还是您知道所以

00:38:17.150 --> 00:38:21.369
知道我想用版本打补丁

00:38:19.369 --> 00:38:26.150
 1.2就是1.4 

00:38:21.369 --> 00:38:30.140
对，所以我今天早上说

00:38:26.150 --> 00:38:32.750
他们是拼图游戏，不会尝试解决

00:38:30.140 --> 00:38:35.030
多个版本的问题是

00:38:32.750 --> 00:38:35.630
有一个非常困难的问题

00:38:35.030 --> 00:38:38.630
原因

00:38:35.630 --> 00:38:40.069
你知道高级摘要，如果我们做了

00:38:38.630 --> 00:38:41.240
你可能至少不会喜欢

00:38:40.069 --> 00:38:47.450
没有可用的工具

00:38:41.240 --> 00:38:49.280
现在我们拥有的所有工具都是

00:38:47.450 --> 00:38:50.660
紧紧地面向你

00:38:49.280 --> 00:38:53.569
试图只获得一个版本

00:38:50.660 --> 00:38:54.799
在classpath上的任何东西都是

00:38:53.569 --> 00:38:57.559
将对

00:38:54.799 --> 00:38:59.510
 Maven和其他构建工具

00:38:57.559 --> 00:39:01.369
超越这一点，以便他们实际上

00:38:59.510 --> 00:39:03.319
传达更多的模型图

00:39:01.369 --> 00:39:06.140
实际计算并允许那些允许

00:39:03.319 --> 00:39:09.740
多个版本，我们也选择不

00:39:06.140 --> 00:39:13.069
将版本放入模型系统中

00:39:09.740 --> 00:39:14.990
这次是因为这很关键

00:39:13.069 --> 00:39:16.250
使人们能够收养

00:39:14.990 --> 00:39:18.500
能够使用他们所使用的工具

00:39:16.250 --> 00:39:22.000
熟悉并猜测什么行家

00:39:18.500 --> 00:39:25.309
 Gradle IV为您处理的所有工具

00:39:22.000 --> 00:39:26.900
今天的jar文件有一些处理方法

00:39:25.309 --> 00:39:28.670
版本选择一些方法

00:39:26.900 --> 00:39:30.260
冲突，他们都是不同的

00:39:28.670 --> 00:39:32.720
他们用来解决冲突的启发式方法

00:39:30.260 --> 00:39:36.109
如果我们实际上有一个

00:39:32.720 --> 00:39:38.900
拼图中基于版本的解析器

00:39:36.109 --> 00:39:40.430
你知道会生气吗

00:39:38.900 --> 00:39:42.720
一大群人，因为它会

00:39:40.430 --> 00:39:44.849
与至少一个不同

00:39:42.720 --> 00:39:46.680
也许是两个主要的构建工具， 

00:39:44.849 --> 00:39:49.710
那将是一个巨大的障碍

00:39:46.680 --> 00:39:51.150
采用的障碍，所以一直是

00:39:49.710 --> 00:39:53.520
一直有争议

00:39:51.150 --> 00:39:55.890
决定人们认为哦模块系统

00:39:53.520 --> 00:39:59.280
你必须有版本，好吧，我们

00:39:55.890 --> 00:40:00.990
不，但是我们选择它是为了

00:39:59.280 --> 00:40:02.730
增加其可及性，以便

00:40:00.990 --> 00:40:17.160
人们可以早点使用它，而不是

00:40:02.730 --> 00:40:21.330
还剩十一分钟，对不起

00:40:17.160 --> 00:40:23.460
版本与您的推理相同

00:40:21.330 --> 00:40:26.790
说您可以在

00:40:23.460 --> 00:40:28.230
您无法指定每个模块的权利

00:40:26.790 --> 00:40:32.340
至少您不能指定

00:40:28.230 --> 00:40:34.020
引用好吧，所以基本上你可以

00:40:32.340 --> 00:40:36.480
您只有一个版本的模块

00:40:34.020 --> 00:40:39.000
得到一个模块的一个版本

00:40:36.480 --> 00:40:40.440
在任何一本书的任何特定层中

00:40:39.000 --> 00:40:42.930
如果你在另一个地方

00:40:40.440 --> 00:40:44.760
复杂的应用程序，您真的

00:40:42.930 --> 00:40:46.500
需要加载不同版本的

00:40:44.760 --> 00:40:48.869
您可以旋转图层以完成此操作的事情

00:40:46.500 --> 00:40:51.150
 API实际上非常简单，所以

00:40:48.869 --> 00:40:52.770
如果您正在做插件

00:40:51.150 --> 00:40:54.450
您正在编写的架构，您知道

00:40:52.770 --> 00:40:56.670
类似于应用服务器的东西

00:40:54.450 --> 00:40:59.640
你知道用东西做花哨的事情

00:40:56.670 --> 00:41:03.359
在运行时，您可以加载

00:40:59.640 --> 00:41:05.160
不同的版本，但到目前为止

00:41:03.359 --> 00:41:06.450
至少我们没有考虑API 

00:41:05.160 --> 00:41:07.680
当然我不是说我们会得到

00:41:06.450 --> 00:41:09.780
永远不会有版本

00:41:07.680 --> 00:41:11.609
模块系统现在就可以了

00:41:09.780 --> 00:41:14.330
通过收养没有意义

00:41:11.609 --> 00:41:14.330
立场

00:41:15.660 --> 00:41:21.360
所以我们的系数，所以你把

00:41:17.970 --> 00:41:23.460
像这样的模块

00:41:21.360 --> 00:41:24.840
代码的源代码级别正确，如果

00:41:23.460 --> 00:41:26.190
有人去添加你拥有的东西

00:41:24.840 --> 00:41:28.020
返回并添加一些东西到列表中

00:41:26.190 --> 00:41:29.310
假设您正在使用的模块数量

00:41:28.020 --> 00:41:30.600
有人回去屋顶访问代码， 

00:41:29.310 --> 00:41:32.220
拿出东西有没有

00:41:30.600 --> 00:41:33.600
计划中的仪器或

00:41:32.220 --> 00:41:35.430
您希望连接调试

00:41:33.600 --> 00:41:37.020
说嘿，你有这额外的一块

00:41:35.430 --> 00:41:38.970
你的模块你真的不需要这个

00:41:37.020 --> 00:41:41.690
你可以摆脱它，我保持很好

00:41:38.970 --> 00:41:44.370
我说的是清洁模块系统II 

00:41:41.690 --> 00:41:47.100
期望统一的ID和其他

00:41:44.370 --> 00:41:49.530
在适当的时候做工具

00:41:47.100 --> 00:41:51.630
提供所有级别的建议

00:41:49.530 --> 00:41:54.300
那里的信息就可以

00:41:51.630 --> 00:41:57.330
轻松轻松告诉您何时

00:41:54.300 --> 00:41:59.550
导出没有类的包

00:41:57.330 --> 00:42:01.230
例如，在其中可以

00:41:59.550 --> 00:42:03.690
识别何时需要一个模块

00:42:01.230 --> 00:42:05.520
另一个但从未真正使用过

00:42:03.690 --> 00:42:07.110
静态地

00:42:05.520 --> 00:42:08.400
模块，所以也许这就是要求

00:42:07.110 --> 00:42:09.900
你不是你实际上不需要

00:42:08.400 --> 00:42:11.250
你知道我们拥有工具吗

00:42:09.900 --> 00:42:13.770
帮助清理进口和东西

00:42:11.250 --> 00:42:15.530
这样，我知道所有基础

00:42:13.770 --> 00:42:19.460
有工具可以做很多事情吗

00:42:15.530 --> 00:42:19.460
模块分析

00:42:27.460 --> 00:42:31.990
这再次与这有关

00:42:29.829 --> 00:42:35.559
版本控制功能使它产生了什么

00:42:31.990 --> 00:42:37.720
我处理CDC时有点困难

00:42:35.559 --> 00:42:39.309
您没有像我需要的版本控制

00:42:37.720 --> 00:42:41.950
在我的Nexus上有一个实时版本

00:42:39.309 --> 00:42:43.150
然后我需要做另一个模块

00:42:41.950 --> 00:42:44.440
您将如何处理这种情况

00:42:43.150 --> 00:42:47.289
必须打包以执行其他模块

00:42:44.440 --> 00:42:49.660
对不起，什么程序使用了

00:42:47.289 --> 00:42:51.339
我认识的首字母缩写现在是连续的

00:42:49.660 --> 00:42:53.559
集成或连续部署

00:42:51.339 --> 00:42:54.970
就像一场戏继续融合一样

00:42:53.559 --> 00:42:57.309
继续使用快照版本

00:42:54.970 --> 00:42:59.200
环境透视权第二期

00:42:57.309 --> 00:43:00.309
 Maven之类的东西，所以我发现发展

00:42:59.200 --> 00:43:02.619
两种不同的型号再使用

00:43:00.309 --> 00:43:05.339
已经直播了，我想更新一下

00:43:02.619 --> 00:43:07.930
不支持模块和版本控制

00:43:05.339 --> 00:43:10.630
对，那么您将如何处理

00:43:07.930 --> 00:43:13.359
场景取决于您的构建系统

00:43:10.630 --> 00:43:14.920
您和您的CI系统来更新

00:43:13.359 --> 00:43:17.859
就像它们一样需要模型工件

00:43:14.920 --> 00:43:19.329
今天要处理jar文件，所以我不确定

00:43:17.859 --> 00:43:22.900
在这里看到一个问题，但也许我没有

00:43:19.329 --> 00:43:24.730
了解问题好吗，所以模块

00:43:22.900 --> 00:43:27.010
系统好，我需要考虑一下

00:43:24.730 --> 00:43:29.970
回到我那里，好吧，我会

00:43:27.010 --> 00:43:29.970
待会儿见

00:43:39.039 --> 00:43:42.039
哑巴

00:43:42.549 --> 00:43:51.049
你好，你可以回到

00:43:45.410 --> 00:43:54.470
图到摩托车越野赛，我们去了

00:43:51.049 --> 00:43:57.230
例如，例如，我想使用Java SE 

00:43:54.470 --> 00:44:03.849
 OTE我也可以排除类似的模块

00:43:57.230 --> 00:44:06.589
 Nova nope nope 

00:44:03.849 --> 00:44:08.240
要求的SCE需要核心，但如果您

00:44:06.589 --> 00:44:11.750
如果你真的不想要的话就不要

00:44:08.240 --> 00:44:13.640
如果您想在科瓦上学习CORBA课程

00:44:11.750 --> 00:44:16.940
不想corba那么就只需要

00:44:13.640 --> 00:44:21.680
不需要SE EE模块，但是需要

00:44:16.940 --> 00:44:23.720
需要Java SE和Java xml WS和Java 

00:44:21.680 --> 00:44:26.660
点交易及其他

00:44:23.720 --> 00:44:29.539
只有CORBA才加入，所以在这里您

00:44:26.660 --> 00:44:31.519
可以做到，但我们接受

00:44:29.539 --> 00:44:33.140
如果模块a，一致性真的很重要

00:44:31.519 --> 00:44:34.640
说它需要模块B 

00:44:33.140 --> 00:44:38.569
去找一个B，如果我们找不到一个B 

00:44:34.640 --> 00:44:40.940
那是一个ER，那是什么样的

00:44:38.569 --> 00:44:45.470
为箭头颜色编码

00:44:40.940 --> 00:44:48.309
箭头的颜色编码为蓝色

00:44:45.470 --> 00:44:51.890
箭头表示存在API依赖关系，因此

00:44:48.309 --> 00:44:55.539
在Java点续集模块中

00:44:51.890 --> 00:44:58.069
导出包含类型和

00:44:55.539 --> 00:45:00.829
标题结尾和那些类型

00:44:58.069 --> 00:45:05.170
在Java点记录中提及类型

00:45:00.829 --> 00:45:08.599
模块中的灰色箭头是

00:45:05.170 --> 00:45:10.009
金字塔神道吊坠，或者它是

00:45:08.599 --> 00:45:11.390
 Java点基中的箭头，因为

00:45:10.009 --> 00:45:13.339
一切都取决于Java dot base和

00:45:11.390 --> 00:45:17.900
制作所有那些箭头会很无聊

00:45:13.339 --> 00:45:21.200
蓝色你知道这是最佳吗

00:45:17.900 --> 00:45:23.500
设计可能不是，但是那是什么

00:45:21.200 --> 00:45:23.500
今天在那里

00:45:24.770 --> 00:45:32.210
在这里，等待麦克风

00:45:28.710 --> 00:45:32.210
请使录音有意义

00:45:37.160 --> 00:45:43.380
因此，如果您要导出模块

00:45:41.010 --> 00:45:47.100
您不导出模型用于的

00:45:43.380 --> 00:45:50.130
包，如果您声明模块声明

00:45:47.100 --> 00:45:54.240
具有接口的模块

00:45:50.130 --> 00:45:56.940
它声明的一切都宣布如此

00:45:54.240 --> 00:45:59.430
因此界面较低或较低

00:45:56.940 --> 00:46:03.330
级别事物接口或示例我们

00:45:59.430 --> 00:46:05.010
只需声明一个模式接口

00:46:03.330 --> 00:46:05.820
不会实际实施

00:46:05.010 --> 00:46:09.450
可能的

00:46:05.820 --> 00:46:11.040
哦，是的，它在

00:46:09.450 --> 00:46:13.980
小小的文本模块模式

00:46:11.040 --> 00:46:16.590
是一个接口，可能会有一个

00:46:13.980 --> 00:46:18.000
内部类，要么说包

00:46:16.590 --> 00:46:20.250
私人的或其他包装

00:46:18.000 --> 00:46:22.280
没有导出的提供

00:46:20.250 --> 00:46:25.200
 atter沥沥的实现

00:46:22.280 --> 00:46:27.870
而且，该模式界面可以

00:46:25.200 --> 00:46:30.530
里面有一个方便的默认方法

00:46:27.870 --> 00:46:35.430
那可以去得到那个实例， 

00:46:30.530 --> 00:46:37.500
你会做一个主意吗

00:46:35.430 --> 00:46:39.750
作为单独的模块实现

00:46:37.500 --> 00:46:41.490
那会是哦，是的，你完全可以

00:46:39.750 --> 00:46:42.600
单独的接口和实现

00:46:41.490 --> 00:46:44.910
你可以有界面，你可以有一个

00:46:42.600 --> 00:46:46.380
充满接口的模块另一个模块

00:46:44.910 --> 00:46:50.330
这些接口的实现

00:46:46.380 --> 00:46:50.330
但这一切都可以

00:46:58.300 --> 00:47:08.150
有氧运动对您有好处，所以如何

00:47:05.570 --> 00:47:12.080
您是否建议从javaee迁移

00:47:08.150 --> 00:47:15.700
小心地将jello 9和

00:47:12.080 --> 00:47:15.700
像任何主要发行版一样进行审议

00:47:15.820 --> 00:47:22.370
所以我们在那里放很多东西

00:47:20.720 --> 00:47:25.250
工具来帮助解决这个问题，因为我们

00:47:22.370 --> 00:47:29.600
知道我们知道这将是一个问题

00:47:25.250 --> 00:47:32.900
 1 1 1最近添加的是

00:47:29.600 --> 00:47:35.210
现在是我们非正式地称为

00:47:32.900 --> 00:47:37.900
大杀手开关，所以我们知道

00:47:35.210 --> 00:47:41.090
那里有很多代码

00:47:37.900 --> 00:47:43.820
访问内部api的no 

00:47:41.090 --> 00:47:46.340
出口时间更长，所以这是非法的

00:47:43.820 --> 00:47:50.870
在那里访问标志是创造性的

00:47:46.340 --> 00:47:53.600
称为--许可证-非法-访问您

00:47:50.870 --> 00:47:56.440
您可以与此同时运行吗？ 

00:47:53.600 --> 00:47:58.730
模块系统基本上已关闭

00:47:56.440 --> 00:48:01.550
但它仍然在那里，它可以

00:47:58.730 --> 00:48:03.950
报告错误消息，以便您查找

00:48:01.550 --> 00:48:07.100
哪些代码正在访问

00:48:03.950 --> 00:48:08.570
内部，我们试图使

00:48:07.100 --> 00:48:10.790
错误消息的描述性

00:48:08.570 --> 00:48:12.830
有可能，所以你可以找出来

00:48:10.790 --> 00:48:15.610
你有一个充满你知道的课程

00:48:12.830 --> 00:48:19.670
您从中央下了几十个jar文件

00:48:15.610 --> 00:48:21.500
您现在可以诊断Excel您可以

00:48:19.670 --> 00:48:25.280
知道哪个jar文件中有代码

00:48:21.500 --> 00:48:27.230
萨斯访问哪个内部API，我们

00:48:25.280 --> 00:48:29.720
强烈鼓励您报告错误

00:48:27.230 --> 00:48:31.010
针对该项目，并要求他们修复

00:48:29.720 --> 00:48:31.310
还是如果您有一些时间

00:48:31.010 --> 00:48:33.470
手

00:48:31.310 --> 00:48:35.210
提交补丁提交请求请求

00:48:33.470 --> 00:48:38.510
不管那是什么

00:48:35.210 --> 00:48:43.490
他们想要的就是那一个

00:48:38.510 --> 00:48:45.740
相互迁移的有用工具

00:48:43.490 --> 00:48:47.270
我有一个问题是我没有想到

00:48:45.740 --> 00:48:50.930
通过这样的道歉，受害者的名字

00:48:47.270 --> 00:48:52.490
我在最后被砸了

00:48:50.930 --> 00:48:55.310
你你从不依赖一个好的观众

00:48:52.490 --> 00:48:56.660
好的，这与依赖项有关

00:48:55.310 --> 00:48:58.220
现在位于模块文件中

00:48:56.660 --> 00:49:02.390
是否有关于获得的讨论

00:48:58.220 --> 00:49:03.410
用导入语句哦，为什么

00:49:02.390 --> 00:49:04.670
我们摆脱了重要的

00:49:03.410 --> 00:49:06.320
声明，因为导入声明将

00:49:04.670 --> 00:49:06.660
告诉您代码的依赖性

00:49:06.320 --> 00:49:08.550
拥有

00:49:06.660 --> 00:49:09.330
然后在课堂上都说

00:49:08.550 --> 00:49:10.740
你真的不需要那是因为

00:49:09.330 --> 00:49:15.030
你在包装上设置好了

00:49:10.740 --> 00:49:17.430
我认为图书馆或包装水平

00:49:15.030 --> 00:49:19.080
他们是我认为你可以

00:49:17.430 --> 00:49:21.060
你可以和编译器可以在

00:49:19.080 --> 00:49:23.430
推断所有进口将

00:49:21.060 --> 00:49:24.870
基于需求，但我认为

00:49:23.430 --> 00:49:28.020
仍然有一定价值

00:49:24.870 --> 00:49:29.790
类和接口来控制什么

00:49:28.020 --> 00:49:31.410
进来只是为了让你的生活说

00:49:29.790 --> 00:49:32.760
特别是如果有像你这样的事情

00:49:31.410 --> 00:49:34.470
知道喜欢类名是

00:49:32.760 --> 00:49:36.360
复制你想有一些

00:49:34.470 --> 00:49:38.280
对此和两足动物的控制

00:49:36.360 --> 00:49:40.710
工具支持他们如支持

00:49:38.280 --> 00:49:42.510
填写年份ID的进口对帐单

00:49:40.710 --> 00:49:44.550
自动为您填写内容， 

00:49:42.510 --> 00:49:51.000
不是因为不是那么多

00:49:44.550 --> 00:49:54.540
只是为了确保

00:49:51.000 --> 00:49:56.280
这个血统对你出口

00:49:54.540 --> 00:49:57.990
来自模型的包

00:49:56.280 --> 00:50:02.850
该模型的应用意味着

00:49:57.990 --> 00:50:05.910
您来自依赖于该模型的模型

00:50:02.850 --> 00:50:08.970
模型仅查看接口

00:50:05.910 --> 00:50:11.790
在神职人员那是正确的

00:50:08.970 --> 00:50:14.880
如果模块a需要则对

00:50:11.790 --> 00:50:18.270
模块B和B中有一个包装

00:50:14.880 --> 00:50:19.950
编码调制仅使用类别

00:50:18.270 --> 00:50:22.020
和该软件包中的接口B 

00:50:19.950 --> 00:50:25.080
如果B不导出该包

00:50:22.020 --> 00:50:27.360
导出该包，假设您拥有

00:50:25.080 --> 00:50:30.660
内部和内部的接口

00:50:27.360 --> 00:50:33.660
不要出口那么长，这意味着你

00:50:30.660 --> 00:50:35.490
在内部使用，如果您在

00:50:33.660 --> 00:50:35.940
命令那个，那不是

00:50:35.490 --> 00:50:38.550
可见

00:50:35.940 --> 00:50:40.890
绝对必要，好吧，小心

00:50:38.550 --> 00:50:42.560
这不仅是不可见的，不是

00:50:40.890 --> 00:50:45.570
可访问性更深

00:50:42.560 --> 00:50:48.660
保证可见度很弱

00:50:45.570 --> 00:50:52.260
保证传达相同的旧信息

00:50:48.660 --> 00:50:55.470
申报亚洲申报几种型号否

00:50:52.260 --> 00:50:57.330
不，没有各种各样，所以这是一个模块

00:50:55.470 --> 00:50:58.920
宣言只宣布一个妈妈

00:50:57.330 --> 00:51:00.930
为此出口不同哦

00:50:58.920 --> 00:51:02.790
是的，你可以出口很多

00:51:00.930 --> 00:51:03.870
您可能需要许多其他包装

00:51:02.790 --> 00:51:05.730
模组

00:51:03.870 --> 00:51:08.850
语言中也有规定

00:51:05.730 --> 00:51:11.340
服务，但这是更高级的

00:51:08.850 --> 00:51:13.020
主题，但是是的，您可以为您服务

00:51:11.340 --> 00:51:14.520
当然可以做所有这些事情

00:51:13.020 --> 00:51:16.200
正确的时间到了，非常感谢

00:51:14.520 --> 00:51:17.000
如果有的话我待会儿待会儿

00:51:16.200 --> 00:51:19.060
问题

00:51:17.000 --> 00:51:19.060
您

