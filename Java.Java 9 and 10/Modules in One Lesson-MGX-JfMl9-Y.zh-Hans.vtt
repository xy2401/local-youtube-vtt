WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.810 --> 00:00:13.270
早上好，欢迎将模块合二为一

00:00:08.200 --> 00:00:15.610
课程，这是一个非常快的过程

00:00:13.270 --> 00:00:17.400
概述，但比我还深入

00:00:15.610 --> 00:00:21.220
昨天能够参加主题演讲

00:00:17.400 --> 00:00:23.410
我会做的，但主要是在

00:00:21.220 --> 00:00:24.999
实际上完全是实时编码，向您展示了一些

00:00:23.410 --> 00:00:28.150
有关模块系统的基础知识正在发展

00:00:24.999 --> 00:00:31.029
简单地说，您知道

00:00:28.150 --> 00:00:33.370
最琐碎的Hello World应用程序和

00:00:31.029 --> 00:00:35.770
将其转换成模块，看看如何

00:00:33.370 --> 00:00:37.030
模块系统工作原理

00:00:35.770 --> 00:00:39.699
东西与模块系统如何

00:00:37.030 --> 00:00:42.940
构建模块化的jar文件，了解如何

00:00:39.699 --> 00:00:44.579
模块系统既可以强制执行又可以强制执行

00:00:42.940 --> 00:00:47.410
尽力保证

00:00:44.579 --> 00:00:49.359
可靠的配置并执行

00:00:47.410 --> 00:00:52.000
两者均具有强封装性

00:00:49.359 --> 00:00:53.440
编译时和运行时， 

00:00:52.000 --> 00:00:59.230
我可以告诉你一些其他的东西

00:00:53.440 --> 00:01:04.059
到底有没有时间，所以首先

00:00:59.230 --> 00:01:07.680
首先，这是我的圆锥形

00:01:04.059 --> 00:01:13.210
命令行我在这里有一个Java 

00:01:07.680 --> 00:01:14.530
 jk9是的，我总是必须这样做

00:01:13.210 --> 00:01:19.750
显示J Shell，因为它是如此

00:01:14.530 --> 00:01:22.240
很酷吧，如果您愿意的话，请J Shell 

00:01:19.750 --> 00:01:23.710
在我敦促你去之前还没看过

00:01:22.240 --> 00:01:25.509
看看它真的很方便，我们

00:01:23.710 --> 00:01:27.310
基本上可以做各种各样的事情

00:01:25.509 --> 00:01:30.700
键入您在其中键入Java代码，然后

00:01:27.310 --> 00:01:32.680
评估它，它给你结果我

00:01:30.700 --> 00:01:35.380
不会感到我想要的东西在这里

00:01:32.680 --> 00:01:38.590
在这一点上显示的是

00:01:35.380 --> 00:01:40.479
模块系统接线在这里

00:01:38.590 --> 00:01:42.520
 Java中的其他模块系统

00:01:40.479 --> 00:01:44.590
情况有一些

00:01:42.520 --> 00:01:45.869
已经存在很长时间了

00:01:44.590 --> 00:01:47.890
他们很好，对他们有用

00:01:45.869 --> 00:01:51.310
某些类型的应用程序但不是

00:01:47.890 --> 00:01:54.490
并非全部，但它们全都生活在

00:01:51.310 --> 00:01:55.930
 Java SE平台，就是这样

00:01:54.490 --> 00:01:57.340
这是我们真正的原因之一

00:01:55.930 --> 00:01:59.740
无法使用它们来模块化

00:01:57.340 --> 00:02:01.600
平台本身的拼图模块系统

00:01:59.740 --> 00:02:03.219
深入了解它的

00:02:01.600 --> 00:02:05.109
知道编译器是已知的

00:02:03.219 --> 00:02:07.270
虚拟机，这样您就可以获得统一

00:02:05.109 --> 00:02:09.190
编译时和运行时的经验

00:02:07.270 --> 00:02:12.560
所以我们在运行

00:02:09.190 --> 00:02:14.569
我可以保存字符串

00:02:12.560 --> 00:02:18.050
我们知道我们都知道那会是什么

00:02:14.569 --> 00:02:22.760
返回正确的，但在九点，你现在可以问

00:02:18.050 --> 00:02:25.190
傅的模块是什么，你回来

00:02:22.760 --> 00:02:27.470
 Zinda模块掉落的东西

00:02:25.190 --> 00:02:31.940
在一个基础上，那本身就是一个实例

00:02:27.470 --> 00:02:34.520
 java.lang模型类的

00:02:31.940 --> 00:02:37.880
我们可以去一个新的类java.lang模块

00:02:34.520 --> 00:02:39.590
在这里到Javadoc，这里是John 

00:02:37.880 --> 00:02:41.540
轻松地说，您是否使用Java Docs 

00:02:39.590 --> 00:02:47.360
在9中搜索另一个很酷的功能，那就是

00:02:41.540 --> 00:02:49.070
在拼图游戏中，我们有Java行

00:02:47.360 --> 00:02:52.910
多年来的课程以及模块

00:02:49.070 --> 00:02:56.120
就像班上总是有这样的基础

00:02:52.910 --> 00:02:58.100
所以我不为什么不那样

00:02:56.120 --> 00:03:00.140
实际上有些令人困惑

00:02:58.100 --> 00:03:02.450
包名称旅行模块2但

00:03:00.140 --> 00:03:03.620
这是模型类，您可以找到

00:03:02.450 --> 00:03:08.690
出各种有趣的东西

00:03:03.620 --> 00:03:10.550
关于模块模型，他们有

00:03:08.690 --> 00:03:11.900
出口为雷吉奥打开了一切

00:03:10.550 --> 00:03:15.370
您可以在模块中编写

00:03:11.900 --> 00:03:15.370
我们将看到的描述符

00:03:15.430 --> 00:03:23.709
好的，如此深入地探讨

00:03:19.190 --> 00:03:26.799
基本模块中没有的内容

00:03:23.709 --> 00:03:29.660
您会知道基本模块是什么

00:03:26.799 --> 00:03:32.630
这是模块图，这是

00:03:29.660 --> 00:03:33.440
模块图的标准部分

00:03:32.630 --> 00:03:36.320
暂停鸣叫

00:03:33.440 --> 00:03:40.549
优秀所以有26标准

00:03:36.320 --> 00:03:42.590
 Java 9中的模块及其关系

00:03:40.549 --> 00:03:44.359
在这里指示，除了一些没有

00:03:42.590 --> 00:03:45.560
表示获得，因为如果我参加

00:03:44.359 --> 00:03:47.329
所有的边缘，这将是真的

00:03:45.560 --> 00:03:49.280
混淆了该特殊模块

00:03:47.329 --> 00:03:51.049
最底层的Java有了基础

00:03:49.280 --> 00:03:52.579
包含java.lang对象和java.lang 

00:03:51.049 --> 00:03:55.670
串你几乎总是

00:03:52.579 --> 00:03:57.590
到处都有，所以每个模块

00:03:55.670 --> 00:03:59.450
您隐式编写的模块取决于

00:03:57.590 --> 00:04:02.120
 Java代码库，无论您想要还是

00:03:59.450 --> 00:04:03.530
当然不是和Java点库

00:04:02.120 --> 00:04:05.840
取决于其他模块，因为

00:04:03.530 --> 00:04:08.660
好吧，就像非常核心

00:04:05.840 --> 00:04:11.109
系统的内核，所以

00:04:08.660 --> 00:04:11.109
模块图

00:04:11.950 --> 00:04:18.949
是的，我在哪里

00:04:15.459 --> 00:04:21.889
好吧，让我们来看看

00:04:18.949 --> 00:04:25.520
不同的模块让我们在这里看到J shell 

00:04:21.889 --> 00:04:27.099
即使模块名称也完成

00:04:25.520 --> 00:04:31.729
这很甜

00:04:27.099 --> 00:04:35.090
所以让自己成为续集时间戳

00:04:31.729 --> 00:04:38.990
 Java续集时间戳duh的实例

00:04:35.090 --> 00:04:42.250
那是在另一个模块中

00:04:38.990 --> 00:04:45.770
在Java doc续集模块中

00:04:42.250 --> 00:04:47.810
我们看这里是上面几个步骤

00:04:45.770 --> 00:04:53.630
基于Java的驱动器下降

00:04:47.810 --> 00:04:57.110
在甘丹上方两层的C羊毛处

00:04:53.630 --> 00:04:59.630
因此模块系统已深入连接

00:04:57.110 --> 00:05:02.180
这也是我们付出了极大的努力

00:04:59.630 --> 00:05:04.310
正如我昨天提到的，以确保

00:05:02.180 --> 00:05:08.270
有代码就可以兼容

00:05:04.310 --> 00:05:10.639
仅使用标准SC API的

00:05:08.270 --> 00:05:15.620
在八点上跑，那么机会非常大

00:05:10.639 --> 00:05:18.320
很好，它将要对九个人进行攻击

00:05:15.620 --> 00:05:22.419
记住秋千-这就是秋千

00:05:18.320 --> 00:05:26.110
来自jdk的步骤jar文件5 

00:05:22.419 --> 00:05:26.110
 2004年发行

00:05:29.610 --> 00:05:35.610
它运作良好，我很好，没问题

00:05:37.780 --> 00:05:43.720
然后点击所有你的东西好

00:05:43.750 --> 00:05:51.440
那么兼容性，让我们来看一下

00:05:46.610 --> 00:05:56.300
在我们的小应用程序中弹出

00:05:51.440 --> 00:05:58.449
 Emacs，您去了

00:05:56.300 --> 00:06:01.069
所有多合一的小屏幕

00:05:58.449 --> 00:06:04.099
软件包org openjdk hello类main 

00:06:01.069 --> 00:06:06.710
它的主要方法需要

00:06:04.099 --> 00:06:09.770
参数构造一个字符串

00:06:06.710 --> 00:06:12.289
它使用一种称为left的创新方法

00:06:09.770 --> 00:06:14.180
垫到垫在左边

00:06:12.289 --> 00:06:17.990
间隔到一定的列长度

00:06:14.180 --> 00:06:22.099
这个案例90然后你去了

00:06:17.990 --> 00:06:30.710
真的很简单，让我们编译

00:06:22.099 --> 00:06:37.599
这是我通常不想要的眼镜

00:06:30.710 --> 00:06:37.599
釉，装在罐子里

00:06:46.660 --> 00:06:57.020
现在我已经在

00:06:49.460 --> 00:07:03.130
惯常的时尚没有完成

00:06:57.020 --> 00:07:07.690
在这里对不起，我们去打招呼世界

00:07:03.130 --> 00:07:12.350
有一个模块化的世界你好，阳光明媚的世界

00:07:07.690 --> 00:07:15.620
那里你还好，所以这就是基本

00:07:12.350 --> 00:07:17.449
所以我们在一个简单的世界里

00:07:15.620 --> 00:07:19.550
类路径上的简单jar文件

00:07:17.449 --> 00:07:24.530
就像我们一直以来，让它成为一个

00:07:19.550 --> 00:07:27.139
模块我们该如何做得好

00:07:24.530 --> 00:07:30.710
需要使其成为一个模块，我们需要一个

00:07:27.139 --> 00:07:38.509
模块声明，我们将其放在模块中

00:07:30.710 --> 00:07:41.620
信息-模块具有什么功能

00:07:38.509 --> 00:07:41.620
有一个模块有一个名字

00:07:43.849 --> 00:07:50.039
我们正在使用反向DNS作为

00:07:46.499 --> 00:07:51.860
推荐这个模块只会

00:07:50.039 --> 00:07:55.050
在我可以输入的基本模型中使用东西

00:07:51.860 --> 00:07:57.539
需要Java在这里有基础，但我没有

00:07:55.050 --> 00:07:59.310
需要编译器将其插入

00:07:57.539 --> 00:08:02.430
对我来说，如果我不

00:07:59.310 --> 00:08:04.379
所以大多数人从来没有这么琐碎

00:08:02.430 --> 00:08:08.819
它只是命名模块或组织openjdk 

00:08:04.379 --> 00:08:10.590
你好，我现在看我的源代码树

00:08:08.819 --> 00:08:12.360
在顶部有模块信息

00:08:10.590 --> 00:08:14.879
然后通过同一类

00:08:12.360 --> 00:08:18.300
之前也一样

00:08:14.879 --> 00:08:24.029
让我们编译那个编译那个模块

00:08:18.300 --> 00:08:25.379
信息，现在我们可以做

00:08:24.029 --> 00:08:26.699
我们之前所做的一切都很好

00:08:25.379 --> 00:08:27.779
只是我们编译的另一个Java文件

00:08:26.699 --> 00:08:31.169
可以通过皮拉尔给它

00:08:27.779 --> 00:08:35.519
现在停留在目录类中

00:08:31.169 --> 00:08:37.349
我们在该课程中有一个模块

00:08:35.519 --> 00:08:39.240
可以问Java P里面有什么

00:08:37.349 --> 00:08:42.269
说哦，好吧，这是模块

00:08:39.240 --> 00:08:49.410
您编译的声明让我们

00:08:42.269 --> 00:08:53.399
让我们再次制作我们的jar文件，现在我们

00:08:49.410 --> 00:08:57.440
有模块化的jar文件

00:08:53.399 --> 00:09:03.769
我那里有模块信息类

00:08:57.440 --> 00:09:03.769
可以要求jar命令对其进行描述

00:09:06.130 --> 00:09:10.520
它会去，我们阅读模块

00:09:08.810 --> 00:09:12.860
描述符，告诉我里面是什么

00:09:10.520 --> 00:09:14.180
在里面，它不会发送

00:09:12.860 --> 00:09:16.310
简单的文本形式，很容易

00:09:14.180 --> 00:09:18.080
脚本而不是源脚本

00:09:16.310 --> 00:09:20.090
代码形式，它告诉您

00:09:18.080 --> 00:09:21.710
需要Java dot base强制手段

00:09:20.090 --> 00:09:23.870
是的，这是规范的要求

00:09:21.710 --> 00:09:26.330
编译器为我插入了它

00:09:23.870 --> 00:09:27.910
包含一个名为orgh orgh open的软件包

00:09:26.330 --> 00:09:30.740
 JDK你好

00:09:27.910 --> 00:09:35.630
所以我们现在可以以模块化形式运行它

00:09:30.740 --> 00:09:39.890
而在模块化形式中，我们不使用

00:09:35.630 --> 00:09:42.740
正确的上课道路我们会用好工作

00:09:39.890 --> 00:09:45.580
你们看到的很棒

00:09:42.740 --> 00:09:45.580
之前的演讲

00:09:49.180 --> 00:09:58.240
你好，我告诉我我的主要班级

00:09:57.850 --> 00:10:00.070
我们去

00:09:58.240 --> 00:10:02.140
模块化的你好世界好吧，好大了

00:10:00.070 --> 00:10:04.510
但是那里到底发生了什么

00:10:02.140 --> 00:10:06.700
实际上有相当一部分

00:10:04.510 --> 00:10:09.070
一些东西在这里，我们会看到

00:10:06.700 --> 00:10:11.230
现在更多的是关于

00:10:09.070 --> 00:10:14.230
模块化的罐子里有一个模块

00:10:11.230 --> 00:10:18.700
该课程，但如果您需要

00:10:14.230 --> 00:10:19.600
仍然可以在课程路径上运行它们

00:10:18.700 --> 00:10:20.890
就像我以前一样

00:10:19.600 --> 00:10:22.330
正确的然后你有相同的jar文件

00:10:20.890 --> 00:10:24.610
将其放在模块的类路径中

00:10:22.330 --> 00:10:26.140
信息被忽略，这对于

00:10:24.610 --> 00:10:29.770
迁移意味着如果您

00:10:26.140 --> 00:10:31.900
提供一个库，您可以编译所有

00:10:29.770 --> 00:10:34.390
它的类，如果您需要强制使用JDK 

00:10:31.900 --> 00:10:36.780
七个刚刚编译了其模块信息

00:10:34.390 --> 00:10:39.580
 JDK的九个类运出库

00:10:36.780 --> 00:10:43.090
在以前版本上运行的用户

00:10:39.580 --> 00:10:44.830
九个可以只使用那个jar文件

00:10:43.090 --> 00:10:46.270
类路径和正在运行的滥用者

00:10:44.830 --> 00:10:48.070
在九点或更晚的时候可以在课堂上使用它

00:10:46.270 --> 00:10:49.510
路径或模块上的路径

00:10:48.070 --> 00:10:51.190
路径将作为模块显示在

00:10:49.510 --> 00:10:52.900
上课的路径只是一堆哦

00:10:51.190 --> 00:10:56.680
像往常一样在课程路径上的课程

00:10:52.900 --> 00:10:59.320
可以简化我的事情

00:10:56.680 --> 00:11:05.140
要利用另一个

00:10:59.320 --> 00:11:07.240
 jar命令的功能

00:11:05.140 --> 00:11:09.760
而且实际上是另一个功能

00:11:07.240 --> 00:11:11.530
可以的模块系统

00:11:09.760 --> 00:11:15.460
打包模块时，您可以

00:11:11.530 --> 00:11:17.170
告诉jar工具插入

00:11:15.460 --> 00:11:18.970
模块描述符到类中的模块

00:11:17.170 --> 00:11:21.790
关于什么主要类的信息

00:11:18.970 --> 00:11:24.130
对于模块，您基本上可以

00:11:21.790 --> 00:11:32.850
声明入口点，所以我可以说

00:11:24.130 --> 00:11:32.850
主类或打开JDK hello main 

00:11:34.010 --> 00:11:37.850
现在当我在模块路径上写时

00:11:36.260 --> 00:11:39.650
我不必这样做，我只能说

00:11:37.850 --> 00:11:41.840
我要作为工作运行的模块

00:11:39.650 --> 00:11:43.720
 openjdk好的，你好，基本上是现在

00:11:41.840 --> 00:11:46.730
现在它是一个很小的应用程序模块， 

00:11:43.720 --> 00:11:52.900
它运行，我不需要

00:11:46.730 --> 00:11:57.020
说，好的，所以我们有了

00:11:52.900 --> 00:11:58.970
自此以来很少有一个模块应用程序

00:11:57.020 --> 00:12:00.230
这个应用程序太大了

00:11:58.970 --> 00:12:06.350
让维护更容易

00:12:00.230 --> 00:12:09.680
将其重构为两个模块

00:12:06.350 --> 00:12:11.890
我们将把每个模块放在

00:12:09.680 --> 00:12:17.710
源目录本身的子树

00:12:11.890 --> 00:12:25.940
让我们将源重命名为org open JDK 

00:12:17.710 --> 00:12:37.610
你好，我们已经进行了重组

00:12:25.940 --> 00:12:39.500
源树，当Emacs再次出现时，让我们

00:12:37.610 --> 00:12:41.450
让我们做一些重构，所以让

00:12:39.500 --> 00:12:43.460
所以让这显然离开Pat Metheny 

00:12:41.450 --> 00:12:45.020
我们需要一个单独的左垫模块

00:12:43.460 --> 00:12:46.520
对，我的意思是说如果JavaScript有一个

00:12:45.020 --> 00:12:48.110
左侧路径和Java的单独模块

00:12:46.520 --> 00:12:50.470
应该有一个单独的膝盖模块

00:12:48.110 --> 00:12:55.960
垫，所以我要做一个不同的模块

00:12:50.470 --> 00:12:55.960
在这种情况下，请打开JDK点txt 

00:13:00.879 --> 00:13:13.660
在那里上课，叫作pat da 

00:13:03.100 --> 00:13:19.389
 Java将其中一些内容复制出来，这样

00:13:13.660 --> 00:13:23.319
这是文字，这是公共场合的模式

00:13:19.389 --> 00:13:27.059
现在需要让这个公开好了，我们

00:13:23.319 --> 00:13:37.989
有模式，这是一个模块，它需要一个

00:13:27.059 --> 00:13:40.389
模块描述符声明现在这个

00:13:37.989 --> 00:13:43.179
模块正在导出某些内容以供

00:13:40.389 --> 00:13:47.019
另一个模块是hello模块，所以

00:13:43.179 --> 00:13:50.109
我需要说出口它的包裹

00:13:47.019 --> 00:13:56.319
也被命名为工作JD标签

00:13:50.109 --> 00:14:03.249
 org OpenJDK文本，然后应该是

00:13:56.319 --> 00:14:05.350
这样结束吧，让我们看看我需要走

00:14:03.249 --> 00:14:07.749
很明显地在这里修好主班

00:14:05.350 --> 00:14:13.409
不再需要这个了，但我确实需要

00:14:07.749 --> 00:14:13.409
导入组织openjdk 

00:14:13.860 --> 00:14:25.160
 atter沥沥，改变这个权利好吗

00:14:20.640 --> 00:14:25.160
你应该发现的工作

00:14:28.290 --> 00:14:32.980
可以节省一些时间，我已经

00:14:31.030 --> 00:14:39.240
执行Java的称为JJ的小命令

00:14:32.980 --> 00:14:39.240
 C和jar一步完成，让我们来看一下

00:14:45.900 --> 00:14:54.880
让我们编译和打包文本

00:14:48.880 --> 00:15:00.840
模块，我们有文本模块，让我们

00:14:54.880 --> 00:15:00.840
编译和打包Hello模块

00:15:03.180 --> 00:15:07.600
哎呀，我忘了一些东西和模块

00:15:06.280 --> 00:15:10.000
系统告诉我什么地方出了错

00:15:07.600 --> 00:15:15.220
忘了更改已更改的模块

00:15:10.000 --> 00:15:17.260
组织的信息打开JDK你好等等

00:15:15.220 --> 00:15:18.580
编译器说嘿我不知道

00:15:17.260 --> 00:15:19.410
哪里可以找到这个文字的东西告诉我

00:15:18.580 --> 00:15:24.070
在哪里找到它

00:15:19.410 --> 00:15:28.200
因此，让我们回到该模块信息

00:15:24.070 --> 00:15:28.200
我需要的是我需要的

00:15:31.309 --> 00:15:35.959
打开的专用文字在哪里

00:15:41.200 --> 00:16:01.339
好的，这样所有的编译我都有两个

00:15:43.670 --> 00:16:03.560
模块正确的专有名称，现在我们可以

00:16:01.339 --> 00:16:06.710
看看我是否要罐子里的罐子工具

00:16:03.560 --> 00:16:08.120
描述你好点罐我现在可以看到

00:16:06.710 --> 00:16:11.120
需要它的基础

00:16:08.120 --> 00:16:12.890
需要组织OpenJDK文本，并且它仍然

00:16:11.120 --> 00:16:16.600
包含组织OpenJDK的工作你好所以

00:16:12.890 --> 00:16:16.600
让我们来经营这个家伙

00:16:25.879 --> 00:16:30.350
不会忘记那不是我

00:16:32.200 --> 00:16:44.990
我们去了，所以现在作为一个

00:16:36.380 --> 00:16:46.760
模块好，所以模块路径是

00:16:44.990 --> 00:16:48.500
与班级路径不同的是

00:16:46.760 --> 00:16:50.030
课堂上有几个

00:16:48.500 --> 00:16:52.460
基本缺陷，这就是为什么

00:16:50.030 --> 00:16:54.620
如果您易碎且容易出错

00:16:52.460 --> 00:16:56.630
想一想，上课的路真的是

00:16:54.620 --> 00:17:00.020
这是一种查找类的方式

00:16:56.630 --> 00:17:02.570
无视查找课程

00:17:00.020 --> 00:17:04.160
究竟是什么jar文件包含它们

00:17:02.570 --> 00:17:05.959
你知道编译器的方式

00:17:04.160 --> 00:17:07.670
 VM搜索了为其编写的类路径

00:17:05.959 --> 00:17:09.620
一个类在第一个罐子里寻找

00:17:07.670 --> 00:17:11.060
如果没有的话，上课

00:17:09.620 --> 00:17:12.920
下一个看下一个，依此类推

00:17:11.060 --> 00:17:14.780
这就是为什么你可以打包

00:17:12.920 --> 00:17:17.270
冲突和其他各种令人讨厌的事情

00:17:14.780 --> 00:17:20.510
在类路径上的惊喜模块

00:17:17.270 --> 00:17:23.839
路径是一次查找整个模块的方法

00:17:20.510 --> 00:17:25.970
模块系统在其上找到一个模块

00:17:23.839 --> 00:17:28.220
模块路径，那么它只会读取

00:17:25.970 --> 00:17:30.740
该模型中该模型中的软件包

00:17:28.220 --> 00:17:33.500
从该模块，如果其他模块是

00:17:30.740 --> 00:17:35.540
解决，最后宣布相同

00:17:33.500 --> 00:17:37.250
打包方式与

00:17:35.540 --> 00:17:39.860
模块系统将报告错误，并且

00:17:37.250 --> 00:17:44.540
停止在两个编译时都知道

00:17:39.860 --> 00:17:49.460
时间和运行时，让我们来看一些

00:17:44.540 --> 00:17:52.760
那些潜在的故障模式

00:17:49.460 --> 00:17:55.150
假设我以某种方式放错了文字

00:17:52.760 --> 00:17:55.150
模组

00:18:01.740 --> 00:18:12.370
如果我现在尝试运行东西，则以模块化方式打开

00:18:09.309 --> 00:18:14.380
找不到组织要求的JD JDK文本

00:18:12.370 --> 00:18:18.010
打开JDK，您好，模块系统告诉您

00:18:14.380 --> 00:18:23.049
你它想做什么，做什么

00:18:18.010 --> 00:18:25.510
如果我尝试重新编译失败

00:18:23.049 --> 00:18:28.510
你好模块，然后再次编译

00:18:25.510 --> 00:18:30.340
错误模块未找到，所以有

00:18:28.510 --> 00:18:32.470
没有没有那里没有

00:18:30.340 --> 00:18:33.940
在这里作弊的可能性，我们和

00:18:32.470 --> 00:18:36.760
我们尽了最大的努力

00:18:33.940 --> 00:18:38.380
编译时和运行时都在

00:18:36.760 --> 00:18:40.510
他们应该完全一样的方式

00:18:38.380 --> 00:18:43.570
有一些例外情况

00:18:40.510 --> 00:18:48.540
他们有完全相同的行为是

00:18:43.570 --> 00:18:48.540
太好了，让我们还原那个文本家伙

00:18:49.470 --> 00:18:54.460
确保它再次运行是的，我们去了

00:18:51.850 --> 00:18:56.500
好吧，另一个失败是

00:18:54.460 --> 00:18:59.860
好了，我们已经看到了失败

00:18:56.500 --> 00:19:01.600
缺少要求，所以II不需要

00:18:59.860 --> 00:19:03.240
不需要再次显示

00:19:01.600 --> 00:19:07.720
有趣的是模块系统

00:19:03.240 --> 00:19:15.340
保证您对此有何注意

00:19:07.720 --> 00:19:20.110
图mm-hmm干净，是的，是的

00:19:15.340 --> 00:19:23.010
这很漂亮，不是你的几年

00:19:20.110 --> 00:19:23.010
辛苦的工作

00:19:23.460 --> 00:19:29.350
没有周期很好的模块

00:19:27.130 --> 00:19:34.240
系统保证没有

00:19:29.350 --> 00:19:36.010
循环，所以我想我去了模块

00:19:34.240 --> 00:19:40.530
文本模块的声明，我

00:19:36.010 --> 00:19:43.020
说需要组织开放JDK 

00:19:40.530 --> 00:19:44.490
你好，你知道，这可能很诱人

00:19:43.020 --> 00:19:46.740
如果您是现代人，可以这样做

00:19:44.490 --> 00:19:48.450
现有系统，你必须要振作起来

00:19:46.740 --> 00:19:50.160
文件看起来像是模块，但是

00:19:48.450 --> 00:19:51.270
每个人都需要一些东西

00:19:50.160 --> 00:19:53.250
而且你不知道如何

00:19:51.270 --> 00:19:55.560
解开它们，你知道这很自然

00:19:53.250 --> 00:19:58.860
想的东西哦，是的，我会做

00:19:55.560 --> 00:20:00.300
每个人都需要另一个，但在

00:19:58.860 --> 00:20:03.990
从长远来看，这可能会到来

00:20:00.300 --> 00:20:06.600
回到咬你，所以模型系统

00:20:03.990 --> 00:20:09.750
只是不允许它是它可能会看到它

00:20:06.600 --> 00:20:11.910
可能看起来很刺眼，但实际上确实是

00:20:09.750 --> 00:20:16.260
更好的生活方式，让我们

00:20:11.910 --> 00:20:21.980
重新提交stri以重新编译文本

00:20:16.260 --> 00:20:21.980
模块哦亲爱的

00:20:22.250 --> 00:20:31.080
是的，将其保存为第一个标记错误循环

00:20:28.350 --> 00:20:33.540
依赖涉及发展或走向

00:20:31.080 --> 00:20:35.610
和JDK打招呼，让您可靠

00:20:33.540 --> 00:20:39.290
配置不仅在运行时，而且

00:20:35.610 --> 00:20:39.290
也在编译时

00:20:40.040 --> 00:20:51.020
好吧，让我们修复它，然后

00:20:45.930 --> 00:20:53.910
另一个失败模式是假设我

00:20:51.020 --> 00:20:56.560
忘了出口

00:20:53.910 --> 00:20:59.920
这样会发生什么，所以我当然可以

00:20:56.560 --> 00:21:03.370
重新编译文本模块，但是如果我现在

00:20:59.920 --> 00:21:09.970
去尝试再次运行该应用程序

00:21:03.370 --> 00:21:12.640
我收到非法的访问错误课堂作业

00:21:09.970 --> 00:21:14.800
 OpenJDK hello主要在模块中或转到

00:21:12.640 --> 00:21:16.750
 JDK hello无法访问或进入- 

00:21:14.800 --> 00:21:19.510
 jdk文本模式在模块中或转到p-- 

00:21:16.750 --> 00:21:21.760
 jdk text，因为text不存在或不存在

00:21:19.510 --> 00:21:24.160
不将文本包导出到你好

00:21:21.760 --> 00:21:26.290
模块，所以看起来有点像远程

00:21:24.160 --> 00:21:27.550
详细，但这基本上应该是Thea 

00:21:26.290 --> 00:21:31.210
这就像一切的口头禅

00:21:27.550 --> 00:21:33.040
系统必须告诉您，它将

00:21:31.210 --> 00:21:36.270
希望有足够的信息来帮助

00:21:33.040 --> 00:21:36.270
您调试问题

00:21:36.990 --> 00:21:40.590
有一个快速的问题

00:21:42.140 --> 00:21:49.559
它会发出任何警告吗，这不是一个

00:21:45.000 --> 00:21:54.660
心力衰竭对吧，让我们

00:21:49.559 --> 00:22:02.190
请你一会儿好吧，让

00:21:54.660 --> 00:22:07.679
我撤消该操作，现在我们回到

00:22:02.190 --> 00:22:16.429
工作系统还可以

00:22:07.679 --> 00:22:16.429
关于这里发生的事情的话

00:22:23.200 --> 00:22:27.070
远至高山

00:22:25.149 --> 00:22:30.039
平台关注那里

00:22:27.070 --> 00:22:33.460
这些JDK的这26个标准模块

00:22:30.039 --> 00:22:36.340
本身实际上还有很多

00:22:33.460 --> 00:22:40.269
可以看到有一个方便的选择

00:22:36.340 --> 00:22:42.840
 Java启动器称为Java列表

00:22:40.269 --> 00:22:47.380
模块哇

00:22:42.840 --> 00:22:48.519
如果有一个开放的JDK构建中有75个

00:22:47.380 --> 00:22:51.159
如果您有Oracle JDK，就可以得到它

00:22:48.519 --> 00:22:52.899
建立那里最终会有更多

00:22:51.159 --> 00:22:55.210
他们每个人都有相同的数字

00:22:52.899 --> 00:23:01.929
我的开源之后

00:22:55.210 --> 00:23:04.389
来自Oracle JDK的让我

00:23:01.929 --> 00:23:06.340
有点容易阅读，所以在左边

00:23:04.389 --> 00:23:08.019
专栏，您可以看到一堆Java 

00:23:06.340 --> 00:23:10.809
这些模块是标准的Java 

00:23:08.019 --> 00:23:12.940
 SC模块和您的右侧专栏

00:23:10.809 --> 00:23:16.750
可以看到以

00:23:12.940 --> 00:23:18.429
那些JDK字母是JDK特有的

00:23:16.750 --> 00:23:19.779
其中相当一部分出口

00:23:18.429 --> 00:23:21.130
没有什么，他们只是内部的

00:23:19.779 --> 00:23:22.690
实现模块，也许他们

00:23:21.130 --> 00:23:25.899
提供的内部服务

00:23:22.690 --> 00:23:28.690
在其他情况下，由其他JDK模块使用

00:23:25.899 --> 00:23:32.980
它们包含例如您知道的工具

00:23:28.690 --> 00:23:34.570
 J Shell在其自己的模块中

00:23:32.980 --> 00:23:38.320
内部内部api本身

00:23:34.570 --> 00:23:40.779
模块等等，仅此而已

00:23:38.320 --> 00:23:42.429
那已经是很多模块了

00:23:40.779 --> 00:23:44.679
向您展示了模块化Java文档

00:23:42.429 --> 00:23:48.549
只是再快速看一下

00:23:44.679 --> 00:23:49.809
回到顶部，它被组织成

00:23:48.549 --> 00:23:51.880
首页分为三部分

00:23:49.809 --> 00:23:55.510
部分，您已经有了26种标准

00:23:51.880 --> 00:23:58.510
 SE模块位于顶部，然后是jdk 

00:23:55.510 --> 00:24:00.539
您可以说在中间的模块看到

00:23:58.510 --> 00:24:03.700
有关所有这些的更多信息，以及

00:24:00.539 --> 00:24:06.880
然后在底部有JavaFX 

00:24:03.700 --> 00:24:09.460
模块，然后其他几个

00:24:06.880 --> 00:24:11.830
在从未有过的土地上

00:24:09.460 --> 00:24:13.360
他们说这些是

00:24:11.830 --> 00:24:14.679
他们是标准的奇怪球

00:24:13.360 --> 00:24:17.019
他们的标准是

00:24:14.679 --> 00:24:18.820
在JCP中是标准化的，但不是

00:24:17.019 --> 00:24:20.620
 Java SC平台的一部分

00:24:18.820 --> 00:24:23.490
这就是为什么

00:24:20.620 --> 00:24:23.490
归类为其他

00:24:24.790 --> 00:24:32.990
好吧，我想展示的最后一件事

00:24:28.760 --> 00:24:36.170
在我们提问之前，您是J 

00:24:32.990 --> 00:24:39.410
链接，所以我做了一个J链接的快速演示

00:24:36.170 --> 00:24:43.250
昨天的主题演讲J链接是我们

00:24:39.410 --> 00:24:46.850
可以采用一组应用程序模块

00:24:43.250 --> 00:24:48.680
并与它们合并在一起

00:24:46.850 --> 00:24:51.230
那些JDK模块的子集

00:24:48.680 --> 00:24:54.050
应用程序模块需求

00:24:51.230 --> 00:24:55.700
为了创建一个紧凑的运行时

00:24:54.050 --> 00:24:57.680
知道可以的自定义运行时映像

00:24:55.700 --> 00:24:59.150
部署您可以粘贴在docker映像中

00:24:57.680 --> 00:25:00.790
那你就得玩云了

00:24:59.150 --> 00:25:09.400
通过工人管道或其他方式

00:25:00.790 --> 00:25:12.080
而且它会更紧凑，所以我有

00:25:09.400 --> 00:25:15.620
你的这里是我的这里是我的构建

00:25:12.080 --> 00:25:19.100
我一直在使用的JDK 9请问有多大

00:25:15.620 --> 00:25:21.290
是347兆字节

00:25:19.100 --> 00:25:27.170
是的，好吧，让我做

00:25:21.290 --> 00:25:29.120
包含让我们看看的自定义运行时

00:25:27.170 --> 00:25:30.620
焊接将开始通过做一个

00:25:29.120 --> 00:25:36.190
只是包含用于

00:25:30.620 --> 00:25:41.600
踢和成长，所以J Lang Mon驱使您

00:25:36.190 --> 00:25:45.040
我需要执行的文件在

00:25:41.600 --> 00:25:45.040
 j-mods目录在这里

00:25:46.020 --> 00:25:49.590
因此，对于JDK中的每个模块， 

00:25:48.270 --> 00:25:52.380
这些J mod文件之一，现在这些

00:25:49.590 --> 00:25:54.690
不是jar文件，因为它们包含

00:25:52.380 --> 00:25:57.750
 jar文件无法或应该执行的操作

00:25:54.690 --> 00:26:00.050
不包含本机本机库

00:25:57.750 --> 00:26:02.490
你知道共享对象dll是什么

00:26:00.050 --> 00:26:04.440
所以我们不得不不得不使用

00:26:02.490 --> 00:26:06.740
模型的不同格式

00:26:04.440 --> 00:26:09.240
 jdk本身的J mod是

00:26:06.740 --> 00:26:10.470
如果你有的话，那就是记录的

00:26:09.240 --> 00:26:13.230
需要附带本机代码的模块

00:26:10.470 --> 00:26:14.760
您可以自己使用它，但大多数情况下

00:26:13.230 --> 00:26:17.070
目的，如果你只是在处理

00:26:14.760 --> 00:26:20.220
纯Java而不是模块化的jar文件

00:26:17.070 --> 00:26:24.380
反正我已经有了我的j-mod 

00:26:20.220 --> 00:26:24.380
让我们在这里链接一个小图像

00:26:25.910 --> 00:26:31.770
我会说J链接很好，我给的链接花了一个

00:26:30.000 --> 00:26:36.510
模块路径就像编译器在

00:26:31.770 --> 00:26:40.830
运行时，我告诉它放在哪里

00:26:36.510 --> 00:26:42.570
结果创建一个名为JRE的目录

00:26:40.830 --> 00:26:44.730
总是必须告诉J链接哪些模块

00:26:42.570 --> 00:26:52.860
在这种情况下，我们只需要Java 

00:26:44.730 --> 00:26:54.540
更新，没有别的，J模式不

00:26:52.860 --> 00:27:03.710
 J Mods标记为“今天我是男孩” 

00:26:54.540 --> 00:27:03.710
可怕的是，我的JRE很小， 

00:27:03.950 --> 00:27:09.150
只有43兆字节

00:27:06.410 --> 00:27:11.480
现在不会变小

00:27:09.150 --> 00:27:11.480
仍然

00:27:15.110 --> 00:27:20.280
但你知道那是它认为的

00:27:17.550 --> 00:27:21.870
它认为这是一个运行时，但它

00:27:20.280 --> 00:27:23.700
实际上没有太多东西，所以

00:27:21.870 --> 00:27:26.130
让我们来一个自定义的另一个

00:27:23.700 --> 00:27:29.240
包含一个很小的

00:27:26.130 --> 00:27:32.070
应用程序执行此jaail命令

00:27:29.240 --> 00:27:36.290
我们将告诉它在哪里可以找到我们的模块

00:27:32.070 --> 00:27:47.070
将输出为HJ r e4 hello JRE 

00:27:36.290 --> 00:27:48.660
我们将添加org OpenJDK你好

00:27:47.070 --> 00:27:52.340
请问这是行不通的，我只需要

00:27:48.660 --> 00:27:52.340
在这里修理一件小东西

00:27:59.480 --> 00:28:07.340
是的

00:28:00.990 --> 00:28:07.340
现在可以工作了，所以我运行j-link 

00:28:12.240 --> 00:28:15.710
更大一点

00:28:22.740 --> 00:28:28.140
杰克（Jerry）看起来不对，请使用这一对

00:28:25.580 --> 00:28:30.620
你好世界都捆绑在那里

00:28:28.140 --> 00:28:36.870
用它自己的少量运行时

00:28:30.620 --> 00:28:40.320
嗯，嗯，那很好奇不是

00:28:36.870 --> 00:28:42.059
先生们前排指出

00:28:40.320 --> 00:28:45.390
那Aah Jerry Jerry有点

00:28:42.059 --> 00:28:52.080
较小，我不确定为什么会这样

00:28:45.390 --> 00:28:56.850
舍入错误好奇一定是那个链接

00:28:52.080 --> 00:28:57.899
时间优化家伙，我不确定，但是

00:28:56.850 --> 00:28:59.549
这应该是一个很好的问题

00:28:57.899 --> 00:29:02.130
我们可以使它变小

00:28:59.549 --> 00:29:07.250
仍然还有一些暴民

00:29:02.130 --> 00:29:10.289
我们可以使用的选项例如带

00:29:07.250 --> 00:29:13.309
这将使其变得更小

00:29:10.289 --> 00:29:17.820
获取我们可以压缩的调试信息

00:29:13.309 --> 00:29:21.320
类文件，我们甚至可以要求它

00:29:17.820 --> 00:29:21.320
为我们做一个发射器

00:29:28.730 --> 00:29:40.230
需要更多的时间，因为

00:29:30.690 --> 00:29:44.299
做更多的工作，现在这是我们的HJRes 

00:29:40.230 --> 00:29:44.299
 e只有28兆

00:29:44.510 --> 00:29:54.840
我们看那里，我们很方便

00:29:48.000 --> 00:29:57.330
一个很小的应用程序的启动器

00:29:54.840 --> 00:29:59.390
所以20兆字节将其保留在docker中

00:29:57.330 --> 00:30:02.570
 Alpine的图像Alpine Linux 

00:29:59.390 --> 00:30:05.279
内核它会起床，你知道3035 

00:30:02.570 --> 00:30:06.570
把它放到云端

00:30:05.279 --> 00:30:08.190
你可以，你有一个世界你好

00:30:06.570 --> 00:30:09.750
您可能想要制造的云

00:30:08.190 --> 00:30:11.610
它与网络而非标准对话

00:30:09.750 --> 00:30:15.570
穿好衣服

00:30:11.610 --> 00:30:19.169
这就是现在的准备部分

00:30:15.570 --> 00:30:22.440
我们有时间提问

00:30:19.169 --> 00:30:25.039
 15分钟我很高兴演示

00:30:22.440 --> 00:30:28.679
其他东西，或者只是回答问题

00:30:25.039 --> 00:30:30.240
这里有一个手咪

00:30:28.679 --> 00:30:33.510
想跑来跑去好极了

00:30:30.240 --> 00:30:35.220
哦，我们将与

00:30:33.510 --> 00:30:36.570
 MyPlate请等待麦克风，因为

00:30:35.220 --> 00:30:38.610
如果您正在录制会话

00:30:36.570 --> 00:30:40.289
只是大声喊出来就不会成功

00:30:38.610 --> 00:30:44.490
录音，如果我重复你的话

00:30:40.289 --> 00:30:48.179
说我可能会弄错好吧

00:30:44.490 --> 00:30:50.220
 Peter hi hi muck，所以这意味着现在

00:30:48.179 --> 00:30:53.570
你昨天摆脱了古巴

00:30:50.220 --> 00:30:57.120
没想到我们会摆脱它

00:30:53.570 --> 00:31:01.520
那java.util日期和

00:30:57.120 --> 00:31:06.360
日历为什么我们要摆脱那些

00:31:01.520 --> 00:31:11.750
因为你有新的

00:31:06.360 --> 00:31:15.320
自Java正确以来的日期和时间

00:31:11.750 --> 00:31:17.570
当我们坚持这些还是为什么

00:31:15.320 --> 00:31:21.350
那些不会被淘汰的人哦

00:31:17.570 --> 00:31:27.920
而是为什么那些类不能

00:31:21.350 --> 00:31:29.840
做成一个模块就可以了

00:31:27.920 --> 00:31:32.020
问题，如果您有双重使用日期

00:31:29.840 --> 00:31:36.010
看着它实际上几乎

00:31:32.020 --> 00:31:39.020
我相信已经完全弃用了

00:31:36.010 --> 00:31:40.910
但所有麻烦的方面

00:31:39.020 --> 00:31:46.400
 Java util date中的不推荐使用已久

00:31:40.910 --> 00:31:50.330
前段时间因为对不起班

00:31:46.400 --> 00:31:51.980
太糟糕了，但是有一个

00:31:50.330 --> 00:31:54.290
这里有一个成本效益的权衡

00:31:51.980 --> 00:31:57.560
对，我的意思是，我们要删除

00:31:54.290 --> 00:31:59.660
来自Java SE和

00:31:57.560 --> 00:32:01.520
不再知道的jdk 

00:31:59.660 --> 00:32:04.310
引人注目的平台

00:32:01.520 --> 00:32:06.590
实施的哪一部分？ 

00:32:04.310 --> 00:32:09.050
你尤其是你知道思考的事情

00:32:06.590 --> 00:32:10.150
就像你知道贾克斯这样的事情

00:32:09.050 --> 00:32:14.060
知道jax-ws 

00:32:10.150 --> 00:32:15.260
你的JDK从来没有真正的

00:32:14.060 --> 00:32:17.180
为他们所维护的人提供适当的家

00:32:15.260 --> 00:32:18.740
如果您在其他地方，它们是Java EE的一部分

00:32:17.180 --> 00:32:20.270
需要他们去找你知道的

00:32:18.740 --> 00:32:22.970
 Maven Central或无论您身在何处

00:32:20.270 --> 00:32:25.730
找到EE工件，所以真的有

00:32:22.970 --> 00:32:28.490
你知道回去的时候

00:32:25.730 --> 00:32:30.650
这些是在Java 6中添加的

00:32:28.490 --> 00:32:32.450
是的，是的，我们认为这些

00:32:30.650 --> 00:32:34.430
事情将被广泛使用

00:32:32.450 --> 00:32:36.950
他们在jdk中，因为那是我们知道的

00:32:34.430 --> 00:32:38.510
被广泛使用，人们却没有

00:32:36.950 --> 00:32:39.890
所以以前只是下载东西

00:32:38.510 --> 00:32:43.370
互联网，但你知道我们在

00:32:39.890 --> 00:32:45.500
现在像Java一样的不同世界

00:32:43.370 --> 00:32:48.170
 util白天工作，你看日历是的，我

00:32:45.500 --> 00:32:52.450
完全同意他们的糟糕API，我是如此

00:32:48.170 --> 00:32:54.470
很高兴我们在Java 8中有了更好的选择，但是

00:32:52.450 --> 00:32:56.810
那会花多少钱和

00:32:54.470 --> 00:33:00.080
好处是删除它们，您知道

00:32:56.810 --> 00:33:02.300
代价是我们会打破一些

00:33:00.080 --> 00:33:04.880
现有的代码，因为我们知道，因为我们

00:33:02.300 --> 00:33:06.470
经常扫描许多

00:33:04.880 --> 00:33:08.030
文件，它们一直以0为中心

00:33:06.470 --> 00:33:09.320
那里有图书馆

00:33:08.030 --> 00:33:13.490
最近正在使用这些老狡猾的人

00:33:09.320 --> 00:33:15.020
 api，答案是肯定的，是的，好的

00:33:13.490 --> 00:33:17.570
我们可以把那些拿出来

00:33:15.020 --> 00:33:20.130
破坏人们的密码会为我们节省任何

00:33:17.570 --> 00:33:24.210
维修负担

00:33:20.130 --> 00:33:26.370
也许一点，但最终

00:33:24.210 --> 00:33:28.440
可能没有那么多，可能是

00:33:26.370 --> 00:33:30.270
不值得破坏人们的代码

00:33:28.440 --> 00:33:31.320
因此，米娅代替

00:33:30.270 --> 00:33:33.450
他们被淘汰了，他们不是

00:33:31.320 --> 00:33:35.580
不建议移除，但它们已经

00:33:33.450 --> 00:33:37.560
长时间不推荐使用

00:33:35.580 --> 00:33:40.230
您知道的大多数情况下

00:33:37.560 --> 00:33:43.440
引用去使用去去工作

00:33:40.230 --> 00:33:45.870
在那里的时间更好

00:33:43.440 --> 00:33:47.520
为什么我们不能在其中放置Java util date 

00:33:45.870 --> 00:33:51.770
自己的模块，然后删除该模块

00:33:47.520 --> 00:33:56.240
技术原因是

00:33:51.770 --> 00:33:59.340
模块不能有冲突的软件包

00:33:56.240 --> 00:34:01.950
所以Java util必须放在一个模块中

00:33:59.340 --> 00:34:04.830
该模块是Java点基础，我们不能

00:34:01.950 --> 00:34:08.220
有另一个你知道Java点破

00:34:04.830 --> 00:34:10.710
具有Java使用日期的点日期模块

00:34:08.220 --> 00:34:15.060
在同一包装中的模块中

00:34:10.710 --> 00:34:17.370
系统无法解决该问题，所以在in in 

00:34:15.060 --> 00:34:18.810
拼图的早期原型可以追溯到

00:34:17.370 --> 00:34:20.130
那天艾伦，我们会记得我们

00:34:18.810 --> 00:34:22.440
其实我们为此感到挣扎

00:34:20.130 --> 00:34:24.360
实际上有一个允许的原型

00:34:22.440 --> 00:34:27.780
具有冲突软件包的模块

00:34:24.360 --> 00:34:29.940
它变成了一个思考的毛线球

00:34:27.780 --> 00:34:32.400
关于和理由，并指定

00:34:29.940 --> 00:34:34.740
所以我们只是放弃了

00:34:32.400 --> 00:34:37.050
就像禁止循环依赖一样

00:34:34.740 --> 00:34:40.080
如果您只是禁止的话，世界会更健康

00:34:37.050 --> 00:34:41.550
冲突的软件包

00:34:40.080 --> 00:34:42.960
相互关联的模块

00:34:41.550 --> 00:34:44.400
你原则上知道如果你有一个大

00:34:42.960 --> 00:34:45.720
有很多模块的系统

00:34:44.400 --> 00:34:47.880
模块上方的模块2 

00:34:45.720 --> 00:34:49.980
在那里，他们再也见不到对方

00:34:47.880 --> 00:34:51.720
可以有冲突的软件包，但如果有一个

00:34:49.980 --> 00:34:55.620
模块是否与模型相关

00:34:51.720 --> 00:34:59.370
在图中，那么他们不能全部

00:34:55.620 --> 00:35:02.310
是的，嗨，我有一个问题

00:34:59.370 --> 00:35:04.050
访问限定符，例如

00:35:02.310 --> 00:35:07.380
在课堂上，您宣布为公开私人

00:35:04.050 --> 00:35:08.670
等对我来说是有意义的

00:35:07.380 --> 00:35:10.350
有任何计划进入

00:35:08.670 --> 00:35:12.180
模块，以便特定模块可以

00:35:10.350 --> 00:35:15.240
出口或要求

00:35:12.180 --> 00:35:17.550
特定模块，或对不起模型

00:35:15.240 --> 00:35:20.700
可以说您要模型

00:35:17.550 --> 00:35:23.520
只供其他模块使用

00:35:20.700 --> 00:35:25.320
说是的，所以某种X的限定词

00:35:23.520 --> 00:35:27.780
像公共私人保护等

00:35:25.320 --> 00:35:30.779
是的，有一种方法可以做到，但是

00:35:27.780 --> 00:35:35.229
不像你刚才描述的那样

00:35:30.779 --> 00:35:38.559
有一个叫做合格的功能

00:35:35.229 --> 00:35:42.489
导出，所以如果我去输入文字

00:35:38.559 --> 00:35:47.109
模块，并假设我要确保

00:35:42.489 --> 00:35:49.569
只有全息模块可以使用此

00:35:47.109 --> 00:35:55.349
包我可以说是出口组织openjdk 

00:35:49.569 --> 00:35:57.819
文字2或点OpenJDK你好

00:35:55.349 --> 00:35:59.739
现在hello模块可以要求它

00:35:57.819 --> 00:36:01.869
但已经说过，但如果还有其他

00:35:59.739 --> 00:36:04.210
模块要求这将导致

00:36:01.869 --> 00:36:05.739
要记录的错误，这是一个

00:36:04.210 --> 00:36:09.359
我们在整个过程中使用的设施

00:36:05.739 --> 00:36:09.359
 JDK本身让我展示给您

00:36:11.230 --> 00:36:14.349
 [音乐] 

00:36:16.430 --> 00:36:23.730
所以这是声明的模块

00:36:18.960 --> 00:36:27.470
基类本身出口整个

00:36:23.730 --> 00:36:31.800
一堆东​​西你会期望

00:36:27.470 --> 00:36:34.350
逾越节服务，然后导出

00:36:31.800 --> 00:36:37.740
一堆东​​西以合格的方式

00:36:34.350 --> 00:36:40.590
到JDK中的其他模块

00:36:37.740 --> 00:36:42.210
像JDK内部点加载器到Java 

00:36:40.590 --> 00:36:46.140
仪器和Java点记录

00:36:42.210 --> 00:36:49.350
这些模块可以再次读取，您可以使用

00:36:46.140 --> 00:36:51.390
 api在这些软件包中，因此

00:36:49.350 --> 00:36:53.220
这不是很多人的设施

00:36:51.390 --> 00:36:57.180
将需要使用，但是当您需要时

00:36:53.220 --> 00:36:58.740
是的，它现在在

00:36:57.180 --> 00:37:00.540
在服务上可能看起来

00:36:58.740 --> 00:37:03.090
它只是基于名称，您可以

00:37:00.540 --> 00:37:04.920
想想，我需要做的所有事情来挫败

00:37:03.090 --> 00:37:08.040
这是我的模块Java点名称

00:37:04.920 --> 00:37:10.470
正确的工具，然后我就可以

00:37:08.040 --> 00:37:12.600
这个魔术包里的东西

00:37:10.470 --> 00:37:14.100
基本模块不正确，因为

00:37:12.600 --> 00:37:16.770
还有一个附加的机制

00:37:14.100 --> 00:37:19.620
最重要的是，您可以收集

00:37:16.770 --> 00:37:22.170
模块并将它们散列在一起，以便您

00:37:19.620 --> 00:37:24.360
结束记录所有哈希

00:37:22.170 --> 00:37:26.670
的叶模块中的模块

00:37:24.360 --> 00:37:29.400
它的图和那些哈希将是

00:37:26.670 --> 00:37:30.690
检查以确保出口合格

00:37:29.400 --> 00:37:32.490
正以适当的方式受到尊重

00:37:30.690 --> 00:37:34.590
如果可以的话，你可以尝试假装

00:37:32.490 --> 00:37:36.630
您自己的模块名称Java 

00:37:34.590 --> 00:37:38.940
乐器，但您仍然无法

00:37:36.630 --> 00:37:42.440
为此，这就是一种方式

00:37:38.940 --> 00:37:42.440
我们确保平台的完整性

00:37:49.869 --> 00:37:56.720
你好，我基本上有两个问题

00:37:53.510 --> 00:37:59.540
是一般性的，一种是技术性的，所以

00:37:56.720 --> 00:38:02.390
我从一般开始

00:37:59.540 --> 00:38:05.800
情况会如何

00:38:02.390 --> 00:38:08.420
开发需要分为模块

00:38:05.800 --> 00:38:09.830
企业在什么情况下

00:38:08.420 --> 00:38:16.520
您需要拆分开发

00:38:09.830 --> 00:38:18.950
如果您将东西很好地分成模块

00:38:16.520 --> 00:38:22.310
知道我猜这取决于你开心吗

00:38:18.950 --> 00:38:26.500
你对那里的上课路满意吗

00:38:22.310 --> 00:38:32.810
是对我有用的工具

00:38:26.500 --> 00:38:34.340
模块化的权利，所以他们有点

00:38:32.810 --> 00:38:34.780
多个多个答案两个答案

00:38:34.340 --> 00:38:38.210
这个

00:38:34.780 --> 00:38:40.550
就目前情况而言，因为Java从未

00:38:38.210 --> 00:38:41.750
有一个你知道的内置模块系统

00:38:40.550 --> 00:38:44.140
长大了很多解决方案

00:38:41.750 --> 00:38:46.910
解决平台周围的问题

00:38:44.140 --> 00:38:50.750
模块化开发编程

00:38:46.910 --> 00:38:52.880
一大堆问题对吧，让您了解一下

00:38:50.750 --> 00:38:55.160
可以认为是一种模型系统

00:38:52.880 --> 00:38:57.380
在构建时有限制

00:38:55.160 --> 00:38:59.570
 Maven可以强制执行什么，因为毕竟

00:38:57.380 --> 00:39:00.890
九点之前它只是在处理罐子

00:38:59.570 --> 00:39:02.599
类路径上的文件是

00:39:00.890 --> 00:39:04.849
完全泄漏，不是我真正的意思

00:39:02.599 --> 00:39:07.369
 jar文件jar文件放在类路径中

00:39:04.849 --> 00:39:08.780
给泄漏的抽象起一个不好的名字

00:39:07.369 --> 00:39:12.920
那里只是文件系统

00:39:08.780 --> 00:39:15.530
坚持，所以你知道也许有帮助

00:39:12.920 --> 00:39:17.900
如果您正在构建，则对此有所帮助

00:39:15.530 --> 00:39:19.400
 EEE应用程序的传统风格

00:39:17.900 --> 00:39:21.320
您将拥有部署描述符，并且

00:39:19.400 --> 00:39:23.570
所有其他这些其他团体

00:39:21.320 --> 00:39:24.800
组装EE应用程序， 

00:39:23.570 --> 00:39:28.430
我们正在努力做的是

00:39:24.800 --> 00:39:30.589
为更好奠定基础

00:39:28.430 --> 00:39:32.210
未来的权利，我们不会取代所有

00:39:30.589 --> 00:39:34.390
所有其他东西都会

00:39:32.210 --> 00:39:37.190
继续工作可能永远

00:39:34.390 --> 00:39:39.010
但是可以肯定的是，如果您正在开发新的

00:39:37.190 --> 00:39:41.540
我认为值得考虑的代码

00:39:39.010 --> 00:39:44.060
从一开始就使用模块

00:39:41.540 --> 00:39:45.859
以便您的代码可以从中受益

00:39:44.060 --> 00:39:47.570
配置可靠，坚固

00:39:45.859 --> 00:39:49.880
封装的所有阶段

00:39:47.570 --> 00:39:51.020
开发您可以使用链接器，如果

00:39:49.880 --> 00:39:53.210
如果没有模块，就没有

00:39:51.020 --> 00:39:54.680
不能使用j-link就是这样

00:39:53.210 --> 00:39:57.440
够了，还有另一个好处

00:39:54.680 --> 00:40:00.589
它，但你知道，正如我在

00:39:57.440 --> 00:40:01.770
昨天主题演讲Y广泛采用了

00:40:00.589 --> 00:40:04.710
模块系统是

00:40:01.770 --> 00:40:06.900
需要时间，这真的

00:40:04.710 --> 00:40:08.520
很难采用现有系统

00:40:06.900 --> 00:40:12.090
模块化它，如果您有这样的

00:40:08.520 --> 00:40:13.830
系统可能不值得，如果

00:40:12.090 --> 00:40:15.480
它工作正常，但您却没有

00:40:13.830 --> 00:40:17.940
期望做很多新的发展

00:40:15.480 --> 00:40:20.340
那么你知道坚持你的当前

00:40:17.940 --> 00:40:22.140
构建系统及其他

00:40:20.340 --> 00:40:23.490
您正在使用的工具，但如果您正在

00:40:22.140 --> 00:40:26.910
很好，如果你要开始

00:40:23.490 --> 00:40:28.350
新建项目，然后考虑

00:40:26.910 --> 00:40:30.540
使用模块有好处

00:40:28.350 --> 00:40:34.110
所以你也有一个技术问题

00:40:30.540 --> 00:40:37.650
是的，我在一次演讲中看到了

00:40:34.110 --> 00:40:38.280
有静态需要传递

00:40:37.650 --> 00:40:44.520
汽车

00:40:38.280 --> 00:40:46.950
是的，你能给一些描述吗

00:40:44.520 --> 00:40:50.310
使用权，所以那里有

00:40:46.950 --> 00:40:52.230
还有更多要模块的元素

00:40:50.310 --> 00:40:59.460
比我能证明的声明

00:40:52.230 --> 00:41:01.140
在这里我不确定我不确定亚历克斯

00:40:59.460 --> 00:41:03.330
亚历克斯可能已经涵盖了这些

00:41:01.140 --> 00:41:05.460
昨天的演讲我没看

00:41:03.330 --> 00:41:08.250
他我没看到他的决赛真的没有

00:41:05.460 --> 00:41:09.300
触摸好核心静态是这样

00:41:08.250 --> 00:41:10.770
他们在那里他们在那里

00:41:09.300 --> 00:41:14.540
最可能的其他事情

00:41:10.770 --> 00:41:17.550
重要的是需要传递

00:41:14.540 --> 00:41:20.630
让我快速解释一下

00:41:17.550 --> 00:41:20.630
剩下的时间很少

00:41:34.200 --> 00:41:38.170
对，所以Rico要求您在

00:41:37.780 --> 00:41:41.140
对

00:41:38.170 --> 00:41:43.000
你好需要使

00:41:41.140 --> 00:41:45.100
文本模块的导出包

00:41:43.000 --> 00:41:47.940
可访问hello模块中的代码

00:41:45.100 --> 00:41:50.500
但是假设你好自己是

00:41:47.940 --> 00:41:56.460
你这将解释你出口

00:41:50.500 --> 00:41:56.460
假设它可以导出Oracle JDK 

00:41:58.200 --> 00:42:04.270
你好，假设有一堂课

00:42:01.480 --> 00:42:06.580
俄勒冈州的JDK，你好，有人说

00:42:04.270 --> 00:42:09.730
俄勒冈和JDK中某个类的子类

00:42:06.580 --> 00:42:12.220
可以发短信，但是现在可以

00:42:09.730 --> 00:42:14.080
如果某些模型需要组织开放JDK 

00:42:12.220 --> 00:42:17.980
你好，它将需要Oracle 

00:42:14.080 --> 00:42:19.630
 viniq文本以使用该文本

00:42:17.980 --> 00:42:24.820
你刚做的课，所以你可以做什么

00:42:19.630 --> 00:42:27.910
是说需要传递和这是什么

00:42:24.820 --> 00:42:29.410
这样做是引入了一个额外的步骤

00:42:27.910 --> 00:42:31.960
传递关系

00:42:29.410 --> 00:42:35.230
这意味着需要任何模块

00:42:31.960 --> 00:42:38.560
 org openjdk hello也会隐式地

00:42:35.230 --> 00:42:40.960
需要组织openjdk文本，所以如果你是

00:42:38.560 --> 00:42:43.930
定义供其他模块使用的API 

00:42:40.960 --> 00:42:45.520
该API包含类或

00:42:43.930 --> 00:42:48.640
来自您的模块的接口

00:42:45.520 --> 00:42:50.650
模块使用则要求传递是

00:42:48.640 --> 00:42:53.190
您正在为用户带来利益

00:42:50.650 --> 00:42:55.300
让你知道你的模块

00:42:53.190 --> 00:42:58.060
基本上减少了工作量

00:42:55.300 --> 00:42:59.110
他们必须这样做是一种承诺

00:42:58.060 --> 00:43:01.690
尽管因为一旦您需要

00:42:59.110 --> 00:43:03.490
你基本上是在传递

00:43:01.690 --> 00:43:05.980
提供这些的责任

00:43:03.490 --> 00:43:07.660
其他包到使用任何模型的

00:43:05.980 --> 00:43:09.310
您的模块，就像

00:43:07.660 --> 00:43:11.590
您想仔细考虑的出口

00:43:09.310 --> 00:43:13.660
很好，如果我现在要导出此文件

00:43:11.590 --> 00:43:15.310
我仍然想将其导出两个

00:43:13.660 --> 00:43:16.360
几年后还是会回来

00:43:15.310 --> 00:43:18.930
咬我，因为这真的是

00:43:16.360 --> 00:43:18.930
内部API 

00:43:22.360 --> 00:43:29.270
请稍等

00:43:24.650 --> 00:43:31.340
记录下来是一个很好的细分

00:43:29.270 --> 00:43:33.530
喜欢前进，你如何设想

00:43:31.340 --> 00:43:35.870
这将继续与

00:43:33.530 --> 00:43:38.800
在JDK内部进行版本控制

00:43:35.870 --> 00:43:43.250
然后在外部就像这些

00:43:38.800 --> 00:43:47.420
模块发生变化，就像里面的东西一样

00:43:43.250 --> 00:43:50.180
说打开的JDK文本现在不一样了

00:43:47.420 --> 00:43:53.600
所以拼图中的一些模块

00:43:50.180 --> 00:43:56.750
系统没有正确的版本

00:43:53.600 --> 00:43:59.480
没有版本限制

00:43:56.750 --> 00:44:05.330
将版本信息添加为模块

00:43:59.480 --> 00:44:06.590
我这样做时的文档问题

00:44:05.330 --> 00:44:08.840
你可能已经注意到了

00:44:06.590 --> 00:44:10.850
这些都是9点，这意味着

00:44:08.840 --> 00:44:13.010
内部版本插入的版本号

00:44:10.850 --> 00:44:14.900
用于诊断目的的系统是九

00:44:13.010 --> 00:44:16.160
但是模块系统不起作用

00:44:14.900 --> 00:44:18.440
除了传达这一点之外

00:44:16.160 --> 00:44:20.450
信息，以便您可以诊断和

00:44:18.440 --> 00:44:23.210
调试无法正常工作的系统

00:44:20.450 --> 00:44:25.970
正确的重要

00:44:23.210 --> 00:44:28.040
设计是很重要的，但是模块是

00:44:25.970 --> 00:44:30.560
与人工制品不同的概念

00:44:28.040 --> 00:44:32.480
定义工件的版本

00:44:30.560 --> 00:44:34.400
数字，那很棒，那是

00:44:32.480 --> 00:44:37.100
好东西，像maven这样的工具可以帮助处理

00:44:34.400 --> 00:44:39.800
他们之间的冲突，但模块

00:44:37.100 --> 00:44:41.690
系统仅处理模块中的

00:44:39.800 --> 00:44:43.910
他们的名字和是否需要

00:44:41.690 --> 00:44:47.630
确保完整性，我们有哈希

00:44:43.910 --> 00:44:49.670
这样的机制，所以你知道和

00:44:47.630 --> 00:44:52.010
并展望未来，我期望模块

00:44:49.670 --> 00:44:53.960
每次有数据密钥时，JDK 

00:44:52.010 --> 00:44:57.430
发布，我们将有一个不同的版本

00:44:53.960 --> 00:44:59.870
数字，但事实并非如此

00:44:57.430 --> 00:45:02.630
如果我们能想到的那么好

00:44:59.870 --> 00:45:06.320
不要在JDK J中更改任何内容

00:45:02.630 --> 00:45:08.930
然后使用JDK 10或18.3中的shell模块

00:45:06.320 --> 00:45:11.480
它仍然是JDK或JDK点J链接，网址为

00:45:08.930 --> 00:45:13.640
虽然现在只有9个版本

00:45:11.480 --> 00:45:15.590
他们都有相同的版本号

00:45:13.640 --> 00:45:17.690
他们将被散列在一起以保护

00:45:15.590 --> 00:45:20.330
平台的完整性

00:45:17.690 --> 00:45:22.620
那就是我们没时间了

00:45:20.330 --> 00:45:27.280
害怕非常感谢你

00:45:22.620 --> 00:45:27.280
 [掌声] 

