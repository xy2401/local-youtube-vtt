WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.200 --> 00:00:06.420
 [音乐] 

00:00:03.200 --> 00:00:09.510
下午好，我叫斯图尔特

00:00:06.420 --> 00:00:12.450
标志着我在Java中使用Oracle 

00:00:09.510 --> 00:00:15.570
 Java平台小组工作的开放式JDK 

00:00:12.450 --> 00:00:17.699
在核心图书馆领域，所以今天

00:00:15.570 --> 00:00:19.369
谈话是可选的，所有自行车的母亲

00:00:17.699 --> 00:00:21.960
棚子，我要花整整

00:00:19.369 --> 00:00:24.810
技术会议谈论一个

00:00:21.960 --> 00:00:30.539
 API并讨论为什么我们需要它

00:00:24.810 --> 00:00:31.980
用它来滥用或滥用它说话

00:00:30.539 --> 00:00:33.540
关于自行车的一些概念

00:00:31.980 --> 00:00:37.079
我在

00:00:33.540 --> 00:00:41.430
标题，然后将其包装好

00:00:37.079 --> 00:00:44.640
为什么我们需要可选的，所以让我们谈谈

00:00:41.430 --> 00:00:49.020
没有API的情况

00:00:44.640 --> 00:00:51.420
可选，因此在Java 8之前很漂亮

00:00:49.020 --> 00:00:54.000
常见的具有寻找的API 

00:00:51.420 --> 00:00:56.460
某事，并且有可能

00:00:54.000 --> 00:00:58.800
该API可能找不到它是什么

00:00:56.460 --> 00:01:02.879
寻找，让我们来描述一下

00:00:58.800 --> 00:01:04.890
举个例子，其实这很早

00:01:02.879 --> 00:01:07.409
实际上是一个真实的例子，因为

00:01:04.890 --> 00:01:09.630
是我们拥有的api之一

00:01:07.409 --> 00:01:11.760
流API的早期草稿

00:01:09.630 --> 00:01:14.310
我们有一个我称之为搜索的东西

00:01:11.760 --> 00:01:15.570
拿了一个谓词，如果发现

00:01:14.310 --> 00:01:17.970
流中与之匹配的东西

00:01:15.570 --> 00:01:20.040
断言它将返回伟大

00:01:17.970 --> 00:01:22.830
好吧，如果什么都找不到

00:01:20.040 --> 00:01:24.210
符合谓词的意思

00:01:22.830 --> 00:01:25.860
你是怎么返回null我的意思是你

00:01:24.210 --> 00:01:30.920
这就是您一直使用Java所做的事情

00:01:25.860 --> 00:01:35.220
您返回null，那就是

00:01:30.920 --> 00:01:37.170
流中此方法的早期API 

00:01:35.220 --> 00:01:41.340
所以这里的例子是我有一个

00:01:37.170 --> 00:01:43.259
谓词检查一个ID 

00:01:41.340 --> 00:01:46.350
客户，所以我写了一个方法

00:01:43.259 --> 00:01:48.360
搜索正在寻找的客户列表

00:01:46.350 --> 00:01:51.090
具有该ID的客户，然后

00:01:48.360 --> 00:01:55.409
返回匹配的客户或它

00:01:51.090 --> 00:01:58.680
返回null，确定似乎很简单

00:01:55.409 --> 00:02:01.979
对了，现在让我们说我想回来

00:01:58.680 --> 00:02:05.100
与之匹配的客户名称

00:02:01.979 --> 00:02:07.649
想法ID好，所以我们有一个很好的流

00:02:05.100 --> 00:02:09.690
在这里，我们称其为搜索方法

00:02:07.649 --> 00:02:13.360
并传递与

00:02:09.690 --> 00:02:16.060
客户ID获取其名称并返回

00:02:13.360 --> 00:02:18.160
好吧，看起来像

00:02:16.060 --> 00:02:20.200
正确的事情，除非

00:02:18.160 --> 00:02:21.630
搜索返回null，这将引发

00:02:20.200 --> 00:02:24.760
空指针异常

00:02:21.630 --> 00:02:26.710
这可能一直在发生，所以

00:02:24.760 --> 00:02:29.020
你需要做什么

00:02:26.710 --> 00:02:31.750
首先运行您的流并存储

00:02:29.020 --> 00:02:33.520
产生局部变量，然后执行

00:02:31.750 --> 00:02:36.070
检查该局部变量

00:02:33.520 --> 00:02:39.250
 null，如果不为null，则转到

00:02:36.070 --> 00:02:42.100
提前打电话给名字，如果不是

00:02:39.250 --> 00:02:43.660
那么你必须做其他事情

00:02:42.100 --> 00:02:46.959
在这种情况下，我们将要返回

00:02:43.660 --> 00:02:48.910
一些占位符字符串，这有效

00:02:46.959 --> 00:02:51.910
这很好，我认为我们必须做

00:02:48.910 --> 00:02:53.680
一直这样，但这有点

00:02:51.910 --> 00:02:55.360
凌乱的第一件事就是很容易

00:02:53.680 --> 00:02:57.010
犯这个错误而忘记检查

00:02:55.360 --> 00:02:58.870
零，第二件事是当你

00:02:57.010 --> 00:03:02.350
确实添加了null检查，它添加了一个

00:02:58.870 --> 00:03:04.630
一堆混乱的代码好吧

00:03:02.350 --> 00:03:06.430
在Java 8中，我们说可以，我认为我们可以做到

00:03:04.630 --> 00:03:08.470
这种更好的与此

00:03:06.430 --> 00:03:09.010
问题，因此我们引入了新的API 

00:03:08.470 --> 00:03:12.070
叫

00:03:09.010 --> 00:03:14.890
可选，它是通用类型，具有类型

00:03:12.070 --> 00:03:17.380
 T，它可以是可选的实例

00:03:14.890 --> 00:03:21.370
可以处于两种状态之一

00:03:17.380 --> 00:03:24.760
可以为空，也可以包含非

00:03:21.370 --> 00:03:28.030
空引用类型为T的对象，因此

00:03:24.760 --> 00:03:31.120
如果确实包含名义参考

00:03:28.030 --> 00:03:35.110
我们称该礼物或可选礼物具有

00:03:31.120 --> 00:03:37.870
存在一个值，如果没有

00:03:35.110 --> 00:03:39.970
那里的类​​型P的引用我们说

00:03:37.870 --> 00:03:43.060
有时候我是空的

00:03:39.970 --> 00:03:44.769
说它包含空值，也许

00:03:43.060 --> 00:03:46.000
在实现中是正确的，但我

00:03:44.769 --> 00:03:48.280
认为有一种非常混乱的方法

00:03:46.000 --> 00:03:49.590
考虑一下，因为一个可选的

00:03:48.280 --> 00:03:51.580
可选的想法是考虑

00:03:49.590 --> 00:03:54.190
有无东西

00:03:51.580 --> 00:03:56.860
是否与空引用明显不同

00:03:54.190 --> 00:03:59.019
所以实际上我认为这是

00:03:56.860 --> 00:04:00.730
马虎的术语说

00:03:59.019 --> 00:04:02.799
可选包含null，因此我们说

00:04:00.730 --> 00:04:05.080
可选存在或不存在或

00:04:02.799 --> 00:04:07.390
和中存在或不存在值

00:04:05.080 --> 00:04:10.150
可选，专业很少

00:04:07.390 --> 00:04:11.769
为原始值关闭，可选英寸

00:04:10.150 --> 00:04:14.049
长而双倍不会覆盖那些

00:04:11.769 --> 00:04:17.130
但他们是他们基本上平行于

00:04:14.049 --> 00:04:20.950
可以包含参考的可选

00:04:17.130 --> 00:04:23.590
现在可选是普通类，并且

00:04:20.950 --> 00:04:25.600
就像Java每个类中的所有内容， 

00:04:23.590 --> 00:04:27.850
引用了您的实例

00:04:25.600 --> 00:04:32.410
人口普查，这些参考可以为空

00:04:27.850 --> 00:04:35.110
永远不会使用null作为参考

00:04:32.410 --> 00:04:37.570
如果您现在使用可选的本身

00:04:35.110 --> 00:04:38.980
我使用可选方式的风格化使用

00:04:37.570 --> 00:04:40.930
在这个演讲中要谈论

00:04:38.980 --> 00:04:43.150
基本上这不是问题

00:04:40.930 --> 00:04:44.890
请记住，当您有一个

00:04:43.150 --> 00:04:46.660
可选的，所以我在这里要做的是

00:04:44.890 --> 00:04:50.920
当我继续前进并将成为

00:04:46.660 --> 00:04:53.530
为我介绍一套规则

00:04:50.920 --> 00:04:55.390
认为适当使用可选的所以

00:04:53.530 --> 00:04:58.060
这是永远不会使用的规则第一

00:04:55.390 --> 00:05:01.090
 null为可选变量或返回

00:04:58.060 --> 00:05:01.960
价值，我将在最后介绍这些

00:05:01.090 --> 00:05:05.050
所以你不用担心

00:05:01.960 --> 00:05:07.180
很好地捕获它们，所以

00:05:05.050 --> 00:05:09.220
可选的理由提供了

00:05:07.180 --> 00:05:10.960
有限的机制意味着我们不是

00:05:09.220 --> 00:05:13.090
打算解决所有的最后一个问题

00:05:10.960 --> 00:05:15.940
宇宙有限机制

00:05:13.090 --> 00:05:19.210
方法返回类型，我认为这是一个关键

00:05:15.940 --> 00:05:23.050
指出可选方法的重点是方法

00:05:19.210 --> 00:05:24.220
返回值，所以它也很有用

00:05:23.050 --> 00:05:26.740
明显需要代表的地方

00:05:24.220 --> 00:05:29.380
没有类似发现的结果或

00:05:26.740 --> 00:05:30.760
搜索我认为是的示例

00:05:29.380 --> 00:05:32.470
找东西很合法

00:05:30.760 --> 00:05:34.870
并没有结果，所以您需要一种方法

00:05:32.470 --> 00:05:37.270
代表这一点，我们正在返回

00:05:34.870 --> 00:05:38.950
 null可能会导致错误，因此

00:05:37.270 --> 00:05:40.870
您在其中看到了一个例子

00:05:38.950 --> 00:05:42.610
几张幻灯片的示例，如果

00:05:40.870 --> 00:05:44.320
如果你马上就打开你

00:05:42.610 --> 00:05:46.480
解引用它得到一个空指针

00:05:44.320 --> 00:05:48.250
例外，这很诱人

00:05:46.480 --> 00:05:50.620
在代码中很容易很方便

00:05:48.250 --> 00:05:53.230
但它引入了空指针

00:05:50.620 --> 00:05:55.330
例外，所以如果你有那种

00:05:53.230 --> 00:05:58.570
可选可以帮助的情况

00:05:55.330 --> 00:06:00.870
你还好，让我们回到那个

00:05:58.570 --> 00:06:03.610
看看我们是否可以做得更好

00:06:00.870 --> 00:06:06.880
而不是搜索我们最终得到了什么

00:06:03.610 --> 00:06:09.280
在流API中找到在E中找到

00:06:06.880 --> 00:06:11.740
首先，所以这些是

00:06:09.280 --> 00:06:15.580
返回，如果您有T类型的流

00:06:11.740 --> 00:06:18.400
然后找到任何或好的我们将返回

00:06:15.580 --> 00:06:20.050
类型P的可选，它略带

00:06:18.400 --> 00:06:22.170
与你不同，实际上并没有通过

00:06:20.050 --> 00:06:25.780
直接基于find方法

00:06:22.170 --> 00:06:27.610
基本上在find方法的上游

00:06:25.780 --> 00:06:29.500
你填满你放入一个过滤器

00:06:27.610 --> 00:06:32.410
操作，这就是我们在这里拥有的

00:06:29.500 --> 00:06:33.910
带我们的客户列表流运行它

00:06:32.410 --> 00:06:37.210
通过寻找一个

00:06:33.910 --> 00:06:38.900
首先要找到匹配的ID 

00:06:37.210 --> 00:06:42.680
第一个匹配的客户

00:06:38.900 --> 00:06:46.400
匹配的ID，然后我们有了

00:06:42.680 --> 00:06:48.440
客户的某种表示

00:06:46.400 --> 00:06:50.690
那可能存在或可能不存在，我们

00:06:48.440 --> 00:06:52.460
想获得它的名字，所以这里的例子

00:06:50.690 --> 00:06:53.840
是我们要取好名字，所以

00:06:52.460 --> 00:06:56.060
这里有一个问题，因为很好

00:06:53.840 --> 00:06:58.550
首先返回一个可选但获取名称

00:06:56.060 --> 00:06:59.030
是对客户的一种方法，所以不会

00:06:58.550 --> 00:07:02.210
工作

00:06:59.030 --> 00:07:03.710
所以我们必须做一些不同的事情

00:07:02.210 --> 00:07:06.050
对，所以让我们分开

00:07:03.710 --> 00:07:08.560
为了举例，在这里

00:07:06.050 --> 00:07:12.050
最好不要担心，让我们来

00:07:08.560 --> 00:07:13.640
罚款的可选客户退货价值

00:07:12.050 --> 00:07:17.090
首先并将其存储在本地变量中

00:07:13.640 --> 00:07:21.830
所以现在我们有一个可选的

00:07:17.090 --> 00:07:24.650
可能没有客户，我们想要

00:07:21.830 --> 00:07:25.820
以某种方式获得名称，所以怎么办

00:07:24.650 --> 00:07:28.880
我们这样做是有一块的

00:07:25.820 --> 00:07:31.910
错过这里好吧，有一种方法

00:07:28.880 --> 00:07:34.160
称为获取一个可选的

00:07:31.910 --> 00:07:37.700
重视那些可选的伟大

00:07:34.160 --> 00:07:39.710
我们做完了哦，那空的呢

00:07:37.700 --> 00:07:42.950
正确的情况就像我们

00:07:39.710 --> 00:07:45.770
找不到匹配的客户

00:07:42.950 --> 00:07:48.050
该ID返回的内容为空

00:07:45.770 --> 00:07:50.720
可选调用get时会发生什么

00:07:48.050 --> 00:07:54.140
在可选的阿姨身上，没有抛出这样的东西

00:07:50.720 --> 00:07:55.490
元素异常好吧，我们还没有

00:07:54.140 --> 00:07:57.440
在这里买了什么，因为

00:07:55.490 --> 00:08:00.260
差不多这几乎完全一样

00:07:57.440 --> 00:08:01.850
如您打电话给

00:08:00.260 --> 00:08:04.100
在旧参考书上的方法，您会得到一些

00:08:01.850 --> 00:08:05.420
抛出异常，所以我们买了任何

00:08:04.100 --> 00:08:08.000
你知道这还没给我们买什么

00:08:05.420 --> 00:08:09.680
但是我们必须要做的是我们必须工作

00:08:08.000 --> 00:08:12.500
很难做到这一点

00:08:09.680 --> 00:08:15.850
对，这就是我要说的

00:08:12.500 --> 00:08:22.490
你如何正确使用可选

00:08:15.850 --> 00:08:23.900
如果您有参考，就喜欢您

00:08:22.490 --> 00:08:25.850
可以测试一下，看看是否是

00:08:23.900 --> 00:08:28.280
全部或非null（如果有可选选项） 

00:08:25.850 --> 00:08:30.650
有一种方法叫做

00:08:28.280 --> 00:08:33.140
布尔值告诉您是否

00:08:30.650 --> 00:08:35.690
是否有值或是否有值

00:08:33.140 --> 00:08:39.260
缺席，所以这是一种安全的方法

00:08:35.690 --> 00:08:41.480
实施我们的示例，我们要运行我们的

00:08:39.260 --> 00:08:43.940
串流并获得一个可选客户

00:08:41.480 --> 00:08:46.190
结果是这样可能

00:08:43.940 --> 00:08:48.980
包含匹配的客户

00:08:46.190 --> 00:08:51.020
可能是空的，所以我们说如果

00:08:48.980 --> 00:08:53.060
可选值存在

00:08:51.020 --> 00:08:56.110
吸引顾客，并致电

00:08:53.060 --> 00:08:58.490
得到它的名字，所以行得通，因为

00:08:56.110 --> 00:09:00.860
因为可选值存在一个值

00:08:58.490 --> 00:09:04.790
我们知道get将返回该引用

00:09:00.860 --> 00:09:06.560
那不是非null否则我们返回

00:09:04.790 --> 00:09:09.800
一些默认值，这里我只是

00:09:06.560 --> 00:09:11.960
使用字符串未知好吗，但再次

00:09:09.800 --> 00:09:14.420
这和测试是一样的

00:09:11.960 --> 00:09:16.550
对于null与非null，但实际上

00:09:14.420 --> 00:09:19.430
会好一点，因为

00:09:16.550 --> 00:09:21.950
非

00:09:19.430 --> 00:09:23.930
空引用是可选的

00:09:21.950 --> 00:09:25.610
你要说的是一种力量

00:09:23.930 --> 00:09:29.600
在这里是可选的，这意味着它可能是

00:09:25.610 --> 00:09:31.040
空我该如何处理这种情况，但

00:09:29.600 --> 00:09:33.290
仍然代码不是很好，因为

00:09:31.040 --> 00:09:37.150
我们必须有一个局部变量，我们

00:09:33.290 --> 00:09:37.150
必须在这里做这个明确的测试哦

00:09:37.690 --> 00:09:43.730
但在我继续之前，这里是规则编号

00:09:40.250 --> 00:09:46.280
两个从不使用可选的点获取，除非

00:09:43.730 --> 00:09:48.890
你可以证明你是可选的

00:09:46.280 --> 00:09:52.460
调用它具有当前值

00:09:48.890 --> 00:09:54.590
所以如果你打电话给一个空的可选

00:09:52.460 --> 00:09:57.350
它不会抛出此类元素异常，并且

00:09:54.590 --> 00:09:59.450
那就是相当于

00:09:57.350 --> 00:10:01.280
空指针异常，因此您可以

00:09:59.450 --> 00:10:03.890
用这种方式编写所有代码，然后说

00:10:01.280 --> 00:10:05.810
如果存在或使用三元

00:10:03.890 --> 00:10:08.390
运算符或本质上在说什么

00:10:05.810 --> 00:10:11.240
如果存在，则另做

00:10:08.390 --> 00:10:17.600
还有别的，你知道那没关系

00:10:11.240 --> 00:10:18.710
但是我们可以做得更好等等

00:10:17.600 --> 00:10:21.080
无论如何

00:10:18.710 --> 00:10:22.460
我们应该不能做得更好， 

00:10:21.080 --> 00:10:26.480
我们应该做得更好，所以第三条规则

00:10:22.460 --> 00:10:30.620
不要陷入永远的陷阱

00:10:26.480 --> 00:10:32.780
使用use present并获取代替使用

00:10:30.620 --> 00:10:34.370
我将向您展示的技术

00:10:32.780 --> 00:10:38.140
随后的幻灯片，他们是一堆

00:10:34.370 --> 00:10:41.660
存在和使用替代方法

00:10:38.140 --> 00:10:45.800
好了，所以有各种各样的方法

00:10:41.660 --> 00:10:47.510
在可选称为否则，所以我

00:10:45.800 --> 00:10:50.950
只是快一点

00:10:47.510 --> 00:10:54.500
这里的例子，但基本前提是

00:10:50.950 --> 00:10:58.360
如果可选值存在，则表明

00:10:54.500 --> 00:11:00.920
只是返回值，否则

00:10:58.360 --> 00:11:03.519
发生了一些不同的事情，所以那里

00:11:00.920 --> 00:11:08.660
这是三种方法第一种

00:11:03.519 --> 00:11:12.109
否则我们将返回默认值或

00:11:08.660 --> 00:11:14.869
否则获取而不是返回默认值

00:11:12.109 --> 00:11:16.549
价值它将呼叫供应商

00:11:14.869 --> 00:11:18.319
像lambda表达式或方法

00:11:16.549 --> 00:11:21.679
您可以提供参考，但它将

00:11:18.319 --> 00:11:24.309
致电供应商以创建或获取

00:11:21.679 --> 00:11:28.879
然后返回的默认值

00:11:24.309 --> 00:11:31.459
否则扔会说哦，好吧

00:11:28.879 --> 00:11:33.829
不应该是这个网，应该是

00:11:31.459 --> 00:11:35.389
永远不会为空，所以抛出异常， 

00:11:33.829 --> 00:11:38.720
它的作用是让您扔

00:11:35.389 --> 00:11:40.309
所选类型的例外，因此

00:11:38.720 --> 00:11:41.809
例如，您可能想违法

00:11:40.309 --> 00:11:44.269
国家例外，而不是没有

00:11:41.809 --> 00:11:45.829
元素异常，但再次

00:11:44.269 --> 00:11:49.309
事情有点奇怪

00:11:45.829 --> 00:11:51.919
至少在这里单独命名是或

00:11:49.309 --> 00:11:55.399
否则提取该值（如果存在） 

00:11:51.919 --> 00:11:57.679
总是这样做，然后否则

00:11:55.399 --> 00:12:01.659
否则得到，否则将抛出

00:11:57.679 --> 00:12:03.739
如果缺少该值则不同

00:12:01.659 --> 00:12:05.869
好的，所以还有另一种方法

00:12:03.739 --> 00:12:07.999
这是非常有用的，这是数学

00:12:05.869 --> 00:12:10.819
从某种意义上讲它是数学

00:12:07.999 --> 00:12:13.369
相同的用法

00:12:10.819 --> 00:12:18.079
作为流上的数学

00:12:13.369 --> 00:12:20.600
对象，所以地图的作用就可以了

00:12:18.079 --> 00:12:23.720
这是我们例子的概括

00:12:20.600 --> 00:12:27.079
在这里，我将向您展示代码

00:12:23.720 --> 00:12:29.779
使用地图，所以地图会说

00:12:27.079 --> 00:12:31.970
如果存在值，则调用

00:12:29.779 --> 00:12:33.589
映射器功能，并采取

00:12:31.970 --> 00:12:37.249
结果，并将其放回

00:12:33.589 --> 00:12:38.989
可选，但如果可选为空，则为空

00:12:37.249 --> 00:12:41.299
只是什么都不做，并通过

00:12:38.989 --> 00:12:44.839
空的好吧，有点像

00:12:41.299 --> 00:12:49.669
满嘴，但这正是我们想要的

00:12:44.839 --> 00:12:52.699
为此，在我们的流示例中， 

00:12:49.669 --> 00:12:54.499
我们确实找到了一个具有

00:12:52.699 --> 00:12:56.749
匹配的ID，我们可以选择

00:12:54.499 --> 00:13:00.829
客户以及我们真正想要的

00:12:56.749 --> 00:13:03.199
名称，所以我们用

00:13:00.829 --> 00:13:04.939
带有meth的meth的getname方法

00:13:03.199 --> 00:13:07.220
引用客户的名字

00:13:04.939 --> 00:13:09.109
方法是什么，如果有

00:13:07.220 --> 00:13:11.509
客户在那里，并替换为

00:13:09.109 --> 00:13:14.989
客户的名字，所以现在我们有一个

00:13:11.509 --> 00:13:16.440
可选字符串，但如果没有

00:13:14.989 --> 00:13:20.070
客户在那里

00:13:16.440 --> 00:13:22.650
这是一个空的可选内容，我们要做的是

00:13:20.070 --> 00:13:26.580
我们将其链结，否则将其结束

00:13:22.650 --> 00:13:28.410
所以如果那个顾客在场

00:13:26.580 --> 00:13:29.820
用名称替换，然后否则

00:13:28.410 --> 00:13:31.920
记住第一件事

00:13:29.820 --> 00:13:34.320
所做的是提取其中的值

00:13:31.920 --> 00:13:36.300
在那里，如果我们买了客户，我们

00:13:34.320 --> 00:13:38.630
改变了我们将其映射到客户中

00:13:36.300 --> 00:13:42.690
名称，然后这就是我们返回的内容

00:13:38.630 --> 00:13:44.910
但是如果可选为空，则映射器

00:13:42.690 --> 00:13:47.610
函数只是被忽略，否则

00:13:44.910 --> 00:13:50.310
说返回未知，这是我们的默认值

00:13:47.610 --> 00:13:52.620
值，所以您可以开始看到好吧，我们

00:13:50.310 --> 00:13:54.750
将这些方法链接到可选的

00:13:52.620 --> 00:13:56.460
以一种有趣的方式，我们可以

00:13:54.750 --> 00:14:01.170
得到一些非常方便的行为

00:13:56.460 --> 00:14:02.940
在这里，但是会变得更好，因为我们不

00:14:01.170 --> 00:14:04.860
不再需要那个讨厌的局部变量

00:14:02.940 --> 00:14:08.220
我们可以直接将这些方法链接起来

00:14:04.860 --> 00:14:10.140
流的尽头，所以现在我们有了

00:14:08.220 --> 00:14:12.000
流先终止的流

00:14:10.140 --> 00:14:15.360
但是我们可以保留链接方法

00:14:12.000 --> 00:14:16.980
所以很好先返回一个可选的

00:14:15.360 --> 00:14:18.780
然后我们就可以调用mapper 

00:14:16.980 --> 00:14:21.390
转换可能是

00:14:18.780 --> 00:14:24.090
存在于可选的，否则我们

00:14:21.390 --> 00:14:26.040
返回一些默认值，使

00:14:24.090 --> 00:14:28.590
这使事情变得更加方便

00:14:26.040 --> 00:14:30.360
整洁，所以您不需要

00:14:28.590 --> 00:14:34.890
局部变量，您就失去了需要

00:14:30.360 --> 00:14:36.540
用于明确测试所有条件

00:14:34.890 --> 00:14:38.370
对，所以我没有其他方法

00:14:36.540 --> 00:14:41.820
想要很快通过

00:14:38.370 --> 00:14:44.250
可选方法之一是过滤方法，因此

00:14:41.820 --> 00:14:48.360
过滤器的作用是建立一个

00:14:44.250 --> 00:14:50.700
在什么值上不变

00:14:48.360 --> 00:14:52.170
存在于可选的，如果有的话

00:14:50.700 --> 00:14:54.780
不满足那个不变性

00:14:52.170 --> 00:14:59.280
返回一个空的可选值，所以在这里我们

00:14:54.780 --> 00:15:01.650
有一个例子真的来自

00:14:59.280 --> 00:15:03.630
我认为JDK 9的早期访问版本

00:15:01.650 --> 00:15:05.370
我听说这段代码已经

00:15:03.630 --> 00:15:06.900
编辑得面目全非，所以您不会

00:15:05.370 --> 00:15:09.300
如果你去找它就不会在那里

00:15:06.900 --> 00:15:10.950
现在就可以了，但是基本上你知道

00:15:09.300 --> 00:15:13.589
关于模块和层的东西

00:15:10.950 --> 00:15:15.660
配置和确切的东西

00:15:13.589 --> 00:15:17.339
确切的情况不是那么重要，但是

00:15:15.660 --> 00:15:20.339
不变的是这里有趣的是

00:15:17.339 --> 00:15:22.620
这是我们有一个配置，我们想

00:15:20.339 --> 00:15:25.950
确保它有一个父母及其

00:15:22.620 --> 00:15:27.540
父母和我们父母一样

00:15:25.950 --> 00:15:30.570
这就是这段代码所做的

00:15:27.540 --> 00:15:33.180
一种可选的常规用法

00:15:30.570 --> 00:15:34.470
就像我之前说过的那样

00:15:33.180 --> 00:15:37.830
与传统的东西

00:15:34.470 --> 00:15:40.290
存在并获得，如果这种情况

00:15:37.830 --> 00:15:42.420
而且实际上这是检查

00:15:40.290 --> 00:15:45.990
他们想要的条件相反

00:15:42.420 --> 00:15:48.630
要断言，所以如果相反

00:15:45.990 --> 00:15:51.780
如果是真的，那么它会抛出非法

00:15:48.630 --> 00:15:55.380
参数异常以及更好的方法

00:15:51.780 --> 00:15:57.120
重写这段代码就像这样

00:15:55.380 --> 00:15:59.870
我们想要做的是编写一个过滤器

00:15:57.120 --> 00:16:03.090
这需要一个谓词

00:15:59.870 --> 00:16:05.460
好吧，我们有一个配置，我们得到了它

00:16:03.090 --> 00:16:10.430
父母，我们希望那个父母成为

00:16:05.460 --> 00:16:14.190
当前并等于我们的配置

00:16:10.430 --> 00:16:16.050
那末你会得到什么

00:16:14.190 --> 00:16:18.450
是包含值的可选

00:16:16.050 --> 00:16:20.670
符合谓词，否则

00:16:18.450 --> 00:16:23.100
空，在这种情况下，如果为空

00:16:20.670 --> 00:16:26.130
那是非法的，所以我们说不然

00:16:23.100 --> 00:16:27.990
抛出非法的参数异常等等

00:16:26.130 --> 00:16:30.630
你会注意到这读得很多

00:16:27.990 --> 00:16:32.520
比那个if语句更好

00:16:30.630 --> 00:16:35.250
具有复杂的布尔表达式，并且

00:16:32.520 --> 00:16:38.160
否定我们得到我们断言的父母

00:16:35.250 --> 00:16:42.200
它的配置等于这个

00:16:38.160 --> 00:16:42.200
配置，否则抛出异常

00:16:43.460 --> 00:16:50.100
好了，还有另一种方法

00:16:45.870 --> 00:16:52.710
如果存在，这很令人困惑

00:16:50.100 --> 00:16:55.380
因为那里我已经说过了

00:16:52.710 --> 00:16:57.810
关于一种叫他存在的方法

00:16:55.380 --> 00:16:59.160
因此，如果存在，这是一个

00:16:57.810 --> 00:17:02.130
一点点太容易获得这些

00:16:59.160 --> 00:17:03.900
对此感到很抱歉，但这是

00:17:02.130 --> 00:17:06.450
来自另一个例子的例子

00:17:03.900 --> 00:17:12.540
 JDK我们可以在哪里使用它

00:17:06.450 --> 00:17:15.660
如果存在，则执行lambda 

00:17:12.540 --> 00:17:17.940
表达式（如果可选）具有值

00:17:15.660 --> 00:17:19.710
目前，所以这里的用例是

00:17:17.940 --> 00:17:22.110
原始代码的种类

00:17:19.710 --> 00:17:24.150
写下来，所以我们得到了一个任务

00:17:22.110 --> 00:17:26.910
某个地方可能有或没有

00:17:24.150 --> 00:17:29.280
任务，因此它返回一个可选任务，因此

00:17:26.910 --> 00:17:30.600
常规代码是可以的，测试是

00:17:29.280 --> 00:17:33.690
可选的，看它是否有一个值

00:17:30.600 --> 00:17:36.210
如果有的话，我们就把任务拿出来

00:17:33.690 --> 00:17:39.810
然后请执行者运行

00:17:36.210 --> 00:17:42.000
这个任务很常规，但是我们可以

00:17:39.810 --> 00:17:43.340
使用if present方法

00:17:42.000 --> 00:17:45.740
好多了

00:17:43.340 --> 00:17:48.080
我可以说得到任务返回

00:17:45.740 --> 00:17:49.490
现在可选，请注意，我们不必

00:17:48.080 --> 00:17:51.920
将其存储在本地变量中

00:17:49.490 --> 00:17:55.100
只是说，我们说如果

00:17:51.920 --> 00:17:58.750
现在，然后有一个lambda表达式

00:17:55.100 --> 00:18:00.920
将任务提交给执行者

00:17:58.750 --> 00:18:03.380
好吧，我们可以做得更好

00:18:00.920 --> 00:18:05.800
因为我喜欢方法引用，所以我们

00:18:03.380 --> 00:18:09.500
可以说获得任务（如果存在） 

00:18:05.800 --> 00:18:12.910
嘿执行者执行该任务，我们

00:18:09.500 --> 00:18:16.700
这样做使事情变得更加整洁

00:18:12.910 --> 00:18:21.260
好吧，还有更多的方法

00:18:16.700 --> 00:18:22.760
可选的几种静态因子方法

00:18:21.260 --> 00:18:24.770
这就是你得到的

00:18:22.760 --> 00:18:26.690
从第一个开始的可选实例

00:18:24.770 --> 00:18:28.940
地方没有公共教练

00:18:26.690 --> 00:18:31.640
可选的，所以如果您想清空

00:18:28.940 --> 00:18:34.190
可选，您只需调用可选点

00:18:31.640 --> 00:18:37.430
空，如果您想要一个可选的

00:18:34.190 --> 00:18:40.670
包含您说的可选点的值

00:18:37.430 --> 00:18:42.320
关键一点是，如果您

00:18:40.670 --> 00:18:44.510
传递对类型T的引用

00:18:42.320 --> 00:18:46.730
引用必须为非null，以便您可以

00:18:44.510 --> 00:18:49.520
永远不要在

00:18:46.730 --> 00:18:51.920
可选，等于哈希码

00:18:49.520 --> 00:18:54.710
几乎可以达到您的期望

00:18:51.920 --> 00:18:56.360
就像你知道，谁在乎

00:18:54.710 --> 00:18:58.700
事实证明，这确实是

00:18:56.360 --> 00:19:01.730
在单元测试中很有用，所以如果您有

00:18:58.700 --> 00:19:04.790
单元测试返回的方法

00:19:01.730 --> 00:19:06.530
可选这里是如何这里是如何

00:19:04.790 --> 00:19:08.930
您说断言等于可选的测试拟合

00:19:06.530 --> 00:19:11.150
期望值或某些等于的点

00:19:08.930 --> 00:19:12.770
可选不为空，我认为这是J 

00:19:11.150 --> 00:19:18.920
期望值为的单元样式

00:19:12.770 --> 00:19:20.930
无论如何在左边，所以等于作品

00:19:18.920 --> 00:19:24.170
如您所料，实际上是

00:19:20.930 --> 00:19:29.150
可选内容中的内容（如果有） 

00:19:24.170 --> 00:19:31.220
都很好，所以有一些

00:19:29.150 --> 00:19:33.770
新方法，我们在其中添加了两个可选

00:19:31.220 --> 00:19:35.390
 Java 9那里有一个

00:19:33.770 --> 00:19:38.420
将可选内容转换为

00:19:35.390 --> 00:19:40.520
由零或一组成的流

00:19:38.420 --> 00:19:42.950
元素，然后有几个

00:19:40.520 --> 00:19:45.940
如果存在其他实用程序

00:19:42.950 --> 00:19:49.220
否则这是一口

00:19:45.940 --> 00:19:50.720
有可选的点或我不

00:19:49.220 --> 00:19:53.000
我想详细介绍这些

00:19:50.720 --> 00:19:56.300
用例比较复杂

00:19:53.000 --> 00:19:57.200
比我今天有时间但他们确实

00:19:56.300 --> 00:20:00.110
上来

00:19:57.200 --> 00:20:01.279
菜单，又是你平常的情况

00:20:00.110 --> 00:20:03.080
知道你有一个流想要

00:20:01.279 --> 00:20:05.029
找到东西，你需要处理

00:20:03.080 --> 00:20:06.889
可能存在的情况或

00:20:05.029 --> 00:20:10.159
缺席，有时您需要做

00:20:06.889 --> 00:20:11.929
和你在一起需要做的事情

00:20:10.159 --> 00:20:13.970
既需要服用的东西

00:20:11.929 --> 00:20:16.760
对本案和本案的诉讼

00:20:13.970 --> 00:20:19.159
缺席的情况下，有时您还想要

00:20:16.760 --> 00:20:20.899
合并两个可选值

00:20:19.159 --> 00:20:24.500
特殊的方式，所以这是可选的

00:20:20.899 --> 00:20:27.279
还是可以，所以这是一个例子

00:20:24.500 --> 00:20:30.139
使用可选点流的过程

00:20:27.279 --> 00:20:32.269
消除我们的客户ID列表， 

00:20:30.139 --> 00:20:34.730
您想将其转换为列表

00:20:32.269 --> 00:20:37.340
正确的客户群，因此您可以

00:20:34.730 --> 00:20:40.279
通过流，您将其映射到

00:20:37.340 --> 00:20:42.200
客户通过ID查找，因此现在您有了一个

00:20:40.279 --> 00:20:44.899
客户清单，您有一个清单

00:20:42.200 --> 00:20:46.700
可选客户，其中一些可能

00:20:44.899 --> 00:20:49.340
是空的，所以你有一堆空的

00:20:46.700 --> 00:20:49.820
列表中的可选内容，因此不是

00:20:49.340 --> 00:20:52.880
很好

00:20:49.820 --> 00:20:56.529
所以让我们在可选的

00:20:52.880 --> 00:21:00.320
存在，然后将其映射到

00:20:56.529 --> 00:21:03.230
可选点获取实际值

00:21:00.320 --> 00:21:06.830
客户中的可选和

00:21:03.230 --> 00:21:08.630
它可以在Java中工作，而且有点

00:21:06.830 --> 00:21:10.940
更好，因为我们可以通过

00:21:08.630 --> 00:21:12.769
平面图和中的平面图结果

00:21:10.940 --> 00:21:15.620
流，所以我们可以压缩这两个

00:21:12.769 --> 00:21:20.570
操作降到一，所以我们可以说

00:21:15.620 --> 00:21:24.470
我们有一些可选的东西，我们

00:21:20.570 --> 00:21:28.210
可以将那些平面地图绘制出来

00:21:24.470 --> 00:21:30.440
只是放弃了空的可选

00:21:28.210 --> 00:21:33.010
最后我会提问

00:21:30.440 --> 00:21:35.929
对不起，我会在最后提问

00:21:33.010 --> 00:21:38.210
好吧，现在有另外一个

00:21:35.929 --> 00:21:40.070
重要的用例是如何适应

00:21:38.210 --> 00:21:42.139
如果您正在编写新代码，则使用的是

00:21:40.070 --> 00:21:44.450
可选的，很好的适应

00:21:42.139 --> 00:21:46.610
编码到代码的其他部分

00:21:44.450 --> 00:21:48.830
可能仍在使用可为空的引用

00:21:46.610 --> 00:21:51.380
所以我们有两种技术

00:21:48.830 --> 00:21:53.269
与这些人打交道，如果你想

00:21:51.380 --> 00:21:55.070
从我的角度说

00:21:53.269 --> 00:21:57.470
处理使用可选和

00:21:55.070 --> 00:22:00.590
我正在调用一些可能会

00:21:57.470 --> 00:22:02.149
返回null，那么我该如何处理

00:22:00.590 --> 00:22:04.279
我应该如何处理空值

00:22:02.149 --> 00:22:06.559
 null进入可选世界，所以有

00:22:04.279 --> 00:22:09.290
一种不同的静态工厂方法，称为

00:22:06.559 --> 00:22:11.870
可为空的可选点

00:22:09.290 --> 00:22:14.180
并且允许引用为空

00:22:11.870 --> 00:22:16.790
所以这是关键的事情

00:22:14.180 --> 00:22:19.820
将空引用存储为值

00:22:16.790 --> 00:22:22.850
可选的，所以再次没有办法

00:22:19.820 --> 00:22:25.400
有一个空的礼物

00:22:22.850 --> 00:22:27.440
参考，所以如果您通过可选的

00:22:25.400 --> 00:22:30.020
可为空的未知参考，您将获得

00:22:27.440 --> 00:22:31.340
空可选，我认为这会抛出

00:22:30.020 --> 00:22:33.320
人们有点，但我认为

00:22:31.340 --> 00:22:35.990
实际上使事情变得更简单，因为

00:22:33.320 --> 00:22:37.370
同样只有两种情况

00:22:35.990 --> 00:22:39.530
你确实有一个可以

00:22:37.370 --> 00:22:40.940
包含一个空引用，您可能会

00:22:39.530 --> 00:22:42.350
可能会说，哦，现在有东西

00:22:40.940 --> 00:22:45.080
从中出来，然后仍然以

00:22:42.350 --> 00:22:46.250
空引用哪种会让您受益

00:22:45.080 --> 00:22:47.870
一直回到开始

00:22:46.250 --> 00:22:51.440
谈谈您必须再次测试null 

00:22:47.870 --> 00:22:54.080
我们不允许在空引用

00:22:51.440 --> 00:22:56.650
可选，因此为nullable的可选

00:22:54.080 --> 00:22:58.910
如果为null，则返回一个空的可选

00:22:56.650 --> 00:23:01.640
好吧，现在你想走另一条路

00:22:58.910 --> 00:23:03.740
有一个可能是

00:23:01.640 --> 00:23:06.170
在场或不在场，然后我想

00:23:03.740 --> 00:23:08.510
将其传递给期望

00:23:06.170 --> 00:23:10.310
可为空的引用我该怎么做

00:23:08.510 --> 00:23:13.220
事实证明，如果你只是说否则

00:23:10.310 --> 00:23:16.250
 null，它做正确的事

00:23:13.220 --> 00:23:19.100
转换它提取值，如果它是

00:23:16.250 --> 00:23:21.290
存在，但如果为空

00:23:19.100 --> 00:23:22.580
可选的，它只是将其变为null，所以

00:23:21.290 --> 00:23:26.230
某些东西需要一个熟悉的参考

00:23:22.580 --> 00:23:29.180
只是打电话，否则梅尔就可以了

00:23:26.230 --> 00:23:31.460
我认为这是其他

00:23:29.180 --> 00:23:33.710
有时我认为主要

00:23:31.460 --> 00:23:35.300
您应该关注的用例是

00:23:33.710 --> 00:23:38.600
您正在调用代码，或者您需要

00:23:35.300 --> 00:23:41.060
通过将值传递给

00:23:38.600 --> 00:23:43.490
期望得到一个光荣的参考

00:23:41.060 --> 00:23:46.460
有时使用它的时间

00:23:43.490 --> 00:23:48.700
人们真的很好人们过度使用

00:23:46.460 --> 00:23:48.700
强硬

00:23:52.770 --> 00:23:58.050
好的，那是我的快速失败

00:23:54.650 --> 00:24:00.060
正确使用可选的，所以有一个

00:23:58.050 --> 00:24:01.530
很多人抓住

00:24:00.060 --> 00:24:03.240
可选说哦，看看所有酷

00:24:01.530 --> 00:24:06.000
我们可以用它做的事情，所以有

00:24:03.240 --> 00:24:09.030
有滥用，滥用，滥用

00:24:06.000 --> 00:24:11.550
我认为以各种方式滥用

00:24:09.030 --> 00:24:13.610
该可选选项不应该使用，所以我会

00:24:11.550 --> 00:24:15.750
通过几个简单的例子

00:24:13.610 --> 00:24:18.090
好吧，人们要做的一件事是

00:24:15.750 --> 00:24:19.920
他们说嗯，真的很酷，你可以

00:24:18.090 --> 00:24:22.650
改变方法，您不再需要

00:24:19.920 --> 00:24:24.360
写if语句，以为我有一个

00:24:22.650 --> 00:24:27.120
称为process的方法

00:24:24.360 --> 00:24:28.650
可以为空的字符串，我可以做

00:24:27.120 --> 00:24:32.040
简单的事情，并针对null进行测试

00:24:28.650 --> 00:24:34.800
或者我可以说我会创建一个可选的

00:24:32.040 --> 00:24:39.800
知道的，然后打电话，否则继续

00:24:34.800 --> 00:24:42.810
它并让它调用其他东西

00:24:39.800 --> 00:24:44.880
为什么只需要对null进行测试

00:24:42.810 --> 00:24:47.010
每个人都了解什么测试

00:24:44.880 --> 00:24:48.300
反对空手段，所以如果你有

00:24:47.010 --> 00:24:52.010
如果您有一个参考是

00:24:48.300 --> 00:24:55.350
已知刚刚测试过，通常为null 

00:24:52.010 --> 00:24:57.210
为了方便而创建一个可选的

00:24:55.350 --> 00:24:58.890
改变方法，然后

00:24:57.210 --> 00:25:01.380
最后提取值不会

00:24:58.890 --> 00:25:03.690
给你买东西，所以我们有规则

00:25:01.380 --> 00:25:06.030
要创造的第四大坏主意

00:25:03.690 --> 00:25:07.830
用于明确目的的可选

00:25:06.030 --> 00:25:10.350
链接方法，然后将其提取

00:25:07.830 --> 00:25:12.900
所以我认为反模式

00:25:10.350 --> 00:25:15.210
我看到的是当您使用时

00:25:12.900 --> 00:25:19.290
完全在一个方法中可选

00:25:15.210 --> 00:25:22.170
甚至再一次发表声明

00:25:19.290 --> 00:25:24.810
可选的主要用例是何时

00:25:22.170 --> 00:25:28.470
您正在将价值返回给某人， 

00:25:24.810 --> 00:25:32.610
在返回位置，该值可能

00:25:28.470 --> 00:25:34.560
或可能不存在，所以

00:25:32.610 --> 00:25:36.630
还有更多的方法可以避免这种情况

00:25:34.560 --> 00:25:39.600
声明，所以这是一个奇怪的用例

00:25:36.630 --> 00:25:42.720
有人在Stack Overflow上问他

00:25:39.600 --> 00:25:44.730
他有两个可选的大十进制值

00:25:42.720 --> 00:25:46.320
他想现在把它们加在一起

00:25:44.730 --> 00:25:48.120
因为它们是可选的，所以有这个

00:25:46.320 --> 00:25:50.460
问题，如果其中之一，你会怎么做

00:25:48.120 --> 00:25:53.370
没有大的十进制值

00:25:50.460 --> 00:25:55.650
有点奇怪的规则

00:25:53.370 --> 00:25:57.620
存在但另一个不存在

00:25:55.650 --> 00:26:00.360
缺席者应视为零

00:25:57.620 --> 00:26:04.650
另一方面，如果他们都

00:26:00.360 --> 00:26:06.400
缺席，然后返回并清空可选内容，因此

00:26:04.650 --> 00:26:08.440
所以有点奇怪

00:26:06.400 --> 00:26:10.840
但这是他的用例，我不会

00:26:08.440 --> 00:26:12.430
说是对是错

00:26:10.840 --> 00:26:13.150
有人想出了一个答案

00:26:12.430 --> 00:26:14.950
哦，我知道

00:26:13.150 --> 00:26:16.690
让我们流式传输可选内容，然后

00:26:14.950 --> 00:26:21.190
过滤，然后映射，然后减少它们

00:26:16.690 --> 00:26:22.960
就像这样，等一下

00:26:21.190 --> 00:26:24.550
再一次，你真的必须了解

00:26:22.960 --> 00:26:26.950
 API也是如此

00:26:24.550 --> 00:26:28.540
出来，我的意思是这不是正确的事情， 

00:26:26.950 --> 00:26:30.010
事实上，当我正在经历

00:26:28.540 --> 00:26:32.350
我刚才说幻灯片稍等一下

00:26:30.010 --> 00:26:34.210
这里有一个错误哦哦等不

00:26:32.350 --> 00:26:35.710
其实没错，所以

00:26:34.210 --> 00:26:38.800
真的很难理解

00:26:35.710 --> 00:26:40.690
我了解Java 8 

00:26:38.800 --> 00:26:43.390
流API是，我仍然迷迷糊糊

00:26:40.690 --> 00:26:46.360
在此之上，它所依赖的是

00:26:43.390 --> 00:26:48.370
单参数单参数形式

00:26:46.360 --> 00:26:50.860
的reduce方法实际上返回了

00:26:48.370 --> 00:26:53.320
发现什么是可选的

00:26:50.860 --> 00:26:54.310
无论如何减少的结果，所以我

00:26:53.320 --> 00:26:56.800
不会经历所有情况

00:26:54.310 --> 00:26:59.050
这里太复杂了，就像

00:26:56.800 --> 00:27:01.660
哇，这很聪明，它使您能够

00:26:59.050 --> 00:27:03.280
避免在这句话中写，但是你

00:27:01.660 --> 00:27:04.990
知道有人写聪明的代码

00:27:03.280 --> 00:27:08.350
这是这些事情之一

00:27:04.990 --> 00:27:10.690
那就是那太聪明了

00:27:08.350 --> 00:27:12.130
所以这是另一个答案，那又怎样

00:27:10.690 --> 00:27:13.930
有时候人们会进入

00:27:12.130 --> 00:27:15.580
当他们说我时，这个代码打高尔夫

00:27:13.930 --> 00:27:18.010
可以在最少的时间内解决您的问题

00:27:15.580 --> 00:27:21.250
字符数，所以他在这里说

00:27:18.010 --> 00:27:23.410
哦，让我们映射可选的，然后在

00:27:21.250 --> 00:27:24.850
在mapper函数中，让我们映射

00:27:23.410 --> 00:27:27.070
第二个可选的，然后链接一些

00:27:24.850 --> 00:27:29.020
再次在提取的地图上使用方法

00:27:27.070 --> 00:27:31.210
然后说第二个

00:27:29.020 --> 00:27:32.380
就像哇为了了解

00:27:31.210 --> 00:27:33.900
我实际上不得不掏出一张纸

00:27:32.380 --> 00:27:37.980
并写出所有案例

00:27:33.900 --> 00:27:40.720
这个家伙，这个家伙真的很聪明

00:27:37.980 --> 00:27:41.740
但是你知道我鼓励你

00:27:40.720 --> 00:27:43.930
如果你想弄清楚这是什么

00:27:41.740 --> 00:27:44.680
确实可以做到相同的意思

00:27:43.930 --> 00:27:46.900
在你的头上做

00:27:44.680 --> 00:27:49.600
太好了，我不能做很多纸

00:27:46.900 --> 00:27:51.760
并经历了两种情况

00:27:49.600 --> 00:27:54.040
输入为空或存在或不存在

00:27:51.760 --> 00:27:57.790
或出示并确认您获得了

00:27:54.040 --> 00:27:59.770
根据的正确结果

00:27:57.790 --> 00:28:01.840
我在这里的问题陈述

00:27:59.770 --> 00:28:05.350
相信这是正确的，但是男孩这张卡

00:28:01.840 --> 00:28:07.450
这段代码难理解吗？ 

00:28:05.350 --> 00:28:10.570
这是我写的方式，这是

00:28:07.450 --> 00:28:14.310
不是最漂亮的代码，但是

00:28:10.570 --> 00:28:17.680
说出问题到底是什么

00:28:14.310 --> 00:28:20.050
都不存在返回可选的空

00:28:17.680 --> 00:28:22.740
除此以外

00:28:20.050 --> 00:28:26.950
如果加零则加一些

00:28:22.740 --> 00:28:29.530
可选项目之一为空，所以对我来说

00:28:26.950 --> 00:28:32.290
读起来更好，而且更容易

00:28:29.530 --> 00:28:34.450
明白，但这确实使我统治

00:28:32.290 --> 00:28:37.020
五是可选链

00:28:34.450 --> 00:28:39.340
巢状或实习生或

00:28:37.020 --> 00:28:43.840
可选的中间结果

00:28:39.340 --> 00:28:49.060
可能太复杂了，所以不要

00:28:43.840 --> 00:28:51.220
这样写代码，所以有

00:28:49.060 --> 00:28:52.840
这实际上是十三个TN 

00:28:51.220 --> 00:28:54.970
自行车的阴影有点

00:28:52.840 --> 00:28:57.550
可选点存在此问题

00:28:54.970 --> 00:29:00.010
被问及如此大喊

00:28:57.550 --> 00:29:02.620
 Brian获得Java Java语言

00:29:00.010 --> 00:29:04.870
建筑师在面试了几年

00:29:02.620 --> 00:29:06.610
以前他认为最大的错误

00:29:04.870 --> 00:29:10.030
他用Java 8做的是，他说

00:29:06.610 --> 00:29:11.410
可选的点获取，问题是和

00:29:10.030 --> 00:29:14.530
他所说的方式没有吸引力

00:29:11.410 --> 00:29:16.090
这是一个令人讨厌的麻烦，得到的是

00:29:14.530 --> 00:29:20.410
如此明显的事情

00:29:16.090 --> 00:29:23.080
可选，但它会导致您失败

00:29:20.410 --> 00:29:25.660
漂亮，我的意思是它引导您进入

00:29:23.080 --> 00:29:31.570
选择，我应该说这会误导您

00:29:25.660 --> 00:29:33.490
做出错误的选择，所以要少得多

00:29:31.570 --> 00:29:36.520
比起一个简短的名字有用

00:29:33.490 --> 00:29:38.050
像获取将表明您可以忘记

00:29:36.520 --> 00:29:40.330
为了保护自己，记住我的一个

00:29:38.050 --> 00:29:43.660
以前的规则永远不会调用get，除非

00:29:40.330 --> 00:29:46.420
您可以证明

00:29:43.660 --> 00:29:48.310
可选的值存在，以便

00:29:46.420 --> 00:29:50.650
反过来导致意识到的人

00:29:48.310 --> 00:29:54.880
所有编写代码的问题

00:29:50.650 --> 00:29:56.500
周围存在并获得但它们存在

00:29:54.880 --> 00:29:58.690
通常更好的替代品，例如

00:29:56.500 --> 00:30:00.880
那些更好的方法，例如map和or 

00:29:58.690 --> 00:30:04.240
和过滤器，我之前谈论过的

00:30:00.880 --> 00:30:06.700
真正使用得到倾向于导致

00:30:04.240 --> 00:30:09.160
你朝错误的方向前进

00:30:06.700 --> 00:30:11.320
我们想做的最终是

00:30:09.160 --> 00:30:12.880
替换获取并有一些

00:30:11.320 --> 00:30:14.830
关于我们想要的抱怨

00:30:12.880 --> 00:30:16.870
不赞成使用get，它导致太多

00:30:14.830 --> 00:30:19.030
许多警告，但仍然存在

00:30:16.870 --> 00:30:22.870
在九丹麦克朗，我们可能会摇摆

00:30:19.030 --> 00:30:24.910
再次在十丹麦克朗，但得到不是真的我

00:30:22.870 --> 00:30:27.370
意思是这是一件很基本的事情

00:30:24.910 --> 00:30:29.550
但实际上我们尽量避免使用它

00:30:27.370 --> 00:30:29.550
能够

00:30:29.860 --> 00:30:35.670
就在那里一堆地方

00:30:32.080 --> 00:30:40.690
人们在真正的地方使用可选

00:30:35.670 --> 00:30:42.010
不是你知道我会出来

00:30:40.690 --> 00:30:43.540
说他们真的不应该那样做

00:30:42.010 --> 00:30:48.400
认为有一种过度使用的方法

00:30:43.540 --> 00:30:50.110
可选的，所以人们做的一件事

00:30:48.400 --> 00:30:51.460
他们说好吗我有一个带有

00:30:50.110 --> 00:30:53.290
一堆领域，其中一些

00:30:51.460 --> 00:30:56.140
字段可能包含或可能不包含值

00:30:53.290 --> 00:30:59.020
啊，所以我应该使用可选和

00:30:56.140 --> 00:31:02.380
事实证明，他们有很多

00:30:59.020 --> 00:31:04.059
通常更好的方式来代表

00:31:02.380 --> 00:31:06.460
如果您正在设计，则没有价值

00:31:04.059 --> 00:31:09.280
某种数据类通常是

00:31:06.460 --> 00:31:12.850
就像一个空对象模式是

00:31:09.280 --> 00:31:14.650
这样做的好方法，或者你知道

00:31:12.850 --> 00:31:16.059
有时候你知道什么是价值

00:31:14.650 --> 00:31:18.429
您将要使用，所以只需填写其

00:31:16.059 --> 00:31:21.340
替换值是，如果不存在或

00:31:18.429 --> 00:31:24.040
或者实际上，拥有一个

00:31:21.340 --> 00:31:26.679
实际可为空的字段作为私有字段

00:31:24.040 --> 00:31:30.880
对象的原因，因为您可以控制

00:31:26.679 --> 00:31:33.669
该字段的所有用途都很漂亮

00:31:30.880 --> 00:31:35.860
当引用变得容易时

00:31:33.669 --> 00:31:37.780
在课外，那就是

00:31:35.860 --> 00:31:39.100
是时候开始担心这个了

00:31:37.780 --> 00:31:40.419
我想告诉我所有的东西

00:31:39.100 --> 00:31:43.450
客户必须检查是否为空

00:31:40.419 --> 00:31:46.830
那是你想要的时候

00:31:43.450 --> 00:31:49.059
谈论使用可选而不是

00:31:46.830 --> 00:31:51.760
在内部使用可选

00:31:49.059 --> 00:31:55.059
代表，另一件事是人

00:31:51.760 --> 00:31:57.580
难道他们说可选一件事

00:31:55.059 --> 00:32:00.190
 Java没有的是可选的

00:31:57.580 --> 00:32:01.870
程序选项ulm伦理参数

00:32:00.190 --> 00:32:04.780
注意哪里有穿梭的微妙之处

00:32:01.870 --> 00:32:05.950
移到这里我想要可选方法

00:32:04.780 --> 00:32:07.270
参数，因此我将使用

00:32:05.950 --> 00:32:09.940
他们真的在说选择性的嘛

00:32:07.270 --> 00:32:12.100
关于不同的事情，所以这个概念

00:32:09.940 --> 00:32:14.290
可选方法参数不

00:32:12.100 --> 00:32:17.320
实际上存在于Java中，确实存在于两个

00:32:14.290 --> 00:32:19.419
其他语言，但基本上是您

00:32:17.320 --> 00:32:22.049
知道提供或不提供的能力

00:32:19.419 --> 00:32:25.480
提供方法调用的参数

00:32:22.049 --> 00:32:30.460
而Java点util点大写

00:32:25.480 --> 00:32:33.010
可选的是一个类，所以那些不是

00:32:30.460 --> 00:32:35.500
即使他们有

00:32:33.010 --> 00:32:39.160
同一个名字，所以你不这样做的原因

00:32:35.500 --> 00:32:42.220
想要使用Java util可选来尝试

00:32:39.160 --> 00:32:43.630
模拟可选方法参数是

00:32:42.220 --> 00:32:46.450
真的

00:32:43.630 --> 00:32:49.290
浪费您的呼叫站点，因此您无法

00:32:46.450 --> 00:32:52.030
作为呼叫者，您不能忽略

00:32:49.290 --> 00:32:54.580
需要的参数，而不是什么

00:32:52.030 --> 00:32:55.930
您必须说的是可选点为空或

00:32:54.580 --> 00:32:57.220
如果你真的想填补一些东西

00:32:55.930 --> 00:32:59.650
在那你必须说可选完成

00:32:57.220 --> 00:33:01.600
有价值的东西，这增加了很多

00:32:59.650 --> 00:33:03.190
杂乱无章的呼叫者

00:33:01.600 --> 00:33:05.950
并没有真正实现

00:33:03.190 --> 00:33:08.770
可选的方法参数

00:33:05.950 --> 00:33:11.080
然后在另一个地方

00:33:08.770 --> 00:33:14.110
有时看到可选的滥用

00:33:11.080 --> 00:33:16.270
在集合中包含元素，因此

00:33:14.110 --> 00:33:17.710
例如可选客户列表或

00:33:16.270 --> 00:33:21.250
像这样的人存储

00:33:17.710 --> 00:33:23.110
离开某个地方，你知道是你

00:33:21.250 --> 00:33:24.610
知道这超出了此范围

00:33:23.110 --> 00:33:27.100
谈论谈论这个，但是你是

00:33:24.610 --> 00:33:30.490
代表某种原因

00:33:27.100 --> 00:33:31.990
你这只是一种有趣的代码气味

00:33:30.490 --> 00:33:33.370
为什么您有一个包含以下内容的列表

00:33:31.990 --> 00:33:35.620
可能会或可能不会的事情

00:33:33.370 --> 00:33:37.510
现在为什么那里是空的

00:33:35.620 --> 00:33:38.710
根本没有空的

00:33:37.510 --> 00:33:40.120
为什么不仅仅拥有客户列表

00:33:38.710 --> 00:33:45.130
完全有道理

00:33:40.120 --> 00:33:47.140
所以通常当一个

00:33:45.130 --> 00:33:48.940
我看着那个说你

00:33:47.140 --> 00:33:50.290
知道如果你，如果你如果你超越

00:33:48.940 --> 00:33:51.880
可能有更好的方法

00:33:50.290 --> 00:33:53.560
在您的应用程序中表示

00:33:51.880 --> 00:33:56.950
可选的种类不会买你

00:33:53.560 --> 00:33:58.900
那里有什么，所以反正则六避免

00:33:56.950 --> 00:34:08.160
使用可选和现场方法

00:33:58.900 --> 00:34:08.160
参数和集合都可以吧

00:34:09.360 --> 00:34:15.040
这里的田地多一点

00:34:12.399 --> 00:34:17.200
可选的是一个盒子，所以我们喜欢

00:34:15.040 --> 00:34:20.409
框原始图元，例如Capitol integer和

00:34:17.200 --> 00:34:22.020
资本双倍等等

00:34:20.409 --> 00:34:24.639
那些是与

00:34:22.020 --> 00:34:27.370
很便宜的原语

00:34:24.639 --> 00:34:29.830
可选的是引用周围的方框， 

00:34:27.370 --> 00:34:35.200
所以它比

00:34:29.830 --> 00:34:38.020
参考，所以如果您过度使用就可以

00:34:35.200 --> 00:34:39.970
可选，特别是如果您使用

00:34:38.020 --> 00:34:43.210
集合或字段中的可选

00:34:39.970 --> 00:34:45.399
那你就可以不用意识到

00:34:43.210 --> 00:34:47.620
大大增加内存量

00:34:45.399 --> 00:34:50.500
您的应用程序消耗并拥有

00:34:47.620 --> 00:34:52.899
导致GC经常更频繁地固化

00:34:50.500 --> 00:34:54.490
如果您想获得价值，也可以

00:34:52.899 --> 00:34:56.080
出于可选，您必须执行

00:34:54.490 --> 00:34:56.950
依赖负载，所以如果您有

00:34:56.080 --> 00:34:58.930
参考

00:34:56.950 --> 00:35:00.970
直接取消引用您有

00:34:58.930 --> 00:35:02.020
可选，其中包含参考，因此

00:35:00.970 --> 00:35:06.430
你必须跳一跳

00:35:02.020 --> 00:35:08.530
可选，然后再跳到另一个

00:35:06.430 --> 00:35:10.150
到实际对象，所以如果你有

00:35:08.530 --> 00:35:12.250
很多这些东西，如果你有一个

00:35:10.150 --> 00:35:13.870
他们大不了，但如果你有百万

00:35:12.250 --> 00:35:16.090
他们在一个集合中，你想

00:35:13.870 --> 00:35:17.860
扭转他们，你可能已经创建了一个

00:35:16.090 --> 00:35:19.360
一百万个额外的缓存未命中

00:35:17.860 --> 00:35:22.450
真的会减慢你的速度

00:35:19.360 --> 00:35:25.060
程序，所以如果您使用非常可选

00:35:22.450 --> 00:35:27.520
经常或在数据结构中

00:35:25.060 --> 00:35:29.650
可能要避免的事情，我认为

00:35:27.520 --> 00:35:30.910
是什么导致人们进入这个哦，我可以使用

00:35:29.650 --> 00:35:34.090
在所有这些不同地方都是可选的

00:35:30.910 --> 00:35:36.160
人们认为可选是

00:35:34.090 --> 00:35:37.390
替换为null，他们四处走动

00:35:36.160 --> 00:35:39.190
他们的代码说我要去的任何地方

00:35:37.390 --> 00:35:42.340
使用null我可以将其替换为

00:35:39.190 --> 00:35:44.320
可选的，这不是真的。 

00:35:42.340 --> 00:35:47.320
不打算替代null 

00:35:44.320 --> 00:35:49.570
再次引用可选范围狭窄

00:35:47.320 --> 00:35:55.180
专注于返回类型的问题

00:35:49.570 --> 00:35:56.710
可能有或没有全部价值

00:35:55.180 --> 00:36:00.820
现在，我会讲一点

00:35:56.710 --> 00:36:03.640
关于自行车脱落的历史

00:36:00.820 --> 00:36:10.390
打开的JDK邮件列表，其中

00:36:03.640 --> 00:36:13.780
在设计中讨论了可选

00:36:10.390 --> 00:36:16.150
 JDK 8的数量众多

00:36:13.780 --> 00:36:18.490
关于这些的电子邮件，他们去了数百

00:36:16.150 --> 00:36:21.610
以及成百上千的电子邮件

00:36:18.490 --> 00:36:23.380
我们称这些发送到线程，他们

00:36:21.610 --> 00:36:25.600
提出了很多问题

00:36:23.380 --> 00:36:27.790
你知道哪个在概念上如此简单

00:36:25.600 --> 00:36:30.340
可选的可能需要存在或

00:36:27.790 --> 00:36:32.260
缺席的

00:36:30.340 --> 00:36:34.390
您可以做出不同的设计决策

00:36:32.260 --> 00:36:36.910
所以所有这些问题都在

00:36:34.390 --> 00:36:39.460
自行车的某些观点

00:36:36.910 --> 00:36:40.810
可以进入阴影，所以我们

00:36:39.460 --> 00:36:42.310
关于我们前进的设计决策

00:36:40.810 --> 00:36:43.390
设计一堂课，有人说哦

00:36:42.310 --> 00:36:45.040
不，你不应该那样做

00:36:43.390 --> 00:36:48.460
应该这样做，而不是结束

00:36:45.040 --> 00:36:50.950
一遍又一遍，事实是在JDK中

00:36:48.460 --> 00:36:54.790
 8我们最终得到了一个可选的

00:36:50.950 --> 00:36:56.800
特殊设计特殊设计

00:36:54.790 --> 00:36:58.510
决定，不幸的是

00:36:56.800 --> 00:37:00.460
决定不是每个人都喜欢

00:36:58.510 --> 00:37:03.160
我们可以做一些事情

00:37:00.460 --> 00:37:05.830
可以通过添加一些方法来修复它

00:37:03.160 --> 00:37:09.990
也许过时的获取可能会改善

00:37:05.830 --> 00:37:11.220
东西，但是有些东西

00:37:09.990 --> 00:37:13.770
你知道那不会是

00:37:11.220 --> 00:37:15.960
人们喜欢，所以我要谈谈

00:37:13.770 --> 00:37:20.550
大约有几个，其中一个

00:37:15.960 --> 00:37:24.060
是可选的，不可序列化，这

00:37:20.550 --> 00:37:27.000
因此在jdk中有八个java.util可选

00:37:24.060 --> 00:37:28.530
类不可序列化，这是

00:37:27.000 --> 00:37:32.490
对于那些特别讨厌的人

00:37:28.530 --> 00:37:34.380
使用熔岩可选事实上

00:37:32.490 --> 00:37:39.390
番石榴项目负责人是专家

00:37:34.380 --> 00:37:43.440
 Java 8组，因此实际上是Java 8 

00:37:39.390 --> 00:37:44.820
可选是番石榴的后代

00:37:43.440 --> 00:37:45.960
可选的，所以有很多相同的地方

00:37:44.820 --> 00:37:48.660
想去那里

00:37:45.960 --> 00:37:51.869
但是熔岩是可选的，可以序列化

00:37:48.660 --> 00:37:53.369
而JDK S不是，原因是

00:37:51.869 --> 00:37:55.800
因为那是我将不得不

00:37:53.369 --> 00:37:57.090
高度压缩，但是我们有

00:37:55.800 --> 00:37:59.070
这个我们一直在努力的东西

00:37:57.090 --> 00:38:01.020
管道称为Valhalla项目

00:37:59.070 --> 00:38:03.210
想要介绍价值的概念

00:38:01.020 --> 00:38:04.950
类型值类型没有任何值

00:38:03.210 --> 00:38:07.920
身份，如果你看

00:38:04.950 --> 00:38:10.080
您意识到的任何细节的序列化

00:38:07.920 --> 00:38:14.000
它与概念紧密相关

00:38:10.080 --> 00:38:16.260
序列化的东西是对象， 

00:38:14.000 --> 00:38:18.570
当你看到意识到的东西， 

00:38:16.260 --> 00:38:21.570
反序列化它会得到一个对象

00:38:18.570 --> 00:38:23.910
一个对象不可避免地具有身份

00:38:21.570 --> 00:38:26.550
在Valhalla项目中，我们希望拥有

00:38:23.910 --> 00:38:28.530
没有身份等的价值观

00:38:26.550 --> 00:38:30.780
使可选的可序列化的遗嘱

00:38:28.530 --> 00:38:32.670
阻止我们将可选变成

00:38:30.780 --> 00:38:34.859
未来的价值类型就是这样

00:38:32.670 --> 00:38:36.450
这就是我们的想法，但是

00:38:34.859 --> 00:38:37.800
主要，因此您可以在

00:38:36.450 --> 00:38:39.750
 Javadoc中的免责声明，如果您

00:38:37.800 --> 00:38:41.670
实际去看Java 8它说

00:38:39.750 --> 00:38:44.250
有这个词，但基本上是

00:38:41.670 --> 00:38:48.090
避免使用身份敏感

00:38:44.250 --> 00:38:50.540
可选操作等等

00:38:48.090 --> 00:38:54.119
不要使用引用相等

00:38:50.540 --> 00:38:56.100
可选，好的，这是一个

00:38:54.119 --> 00:38:57.540
可能更多的细节

00:38:56.100 --> 00:38:59.190
序列化我不会去

00:38:57.540 --> 00:39:00.600
通过这个我以后再发布幻灯片

00:38:59.190 --> 00:39:02.970
您可以详细浏览一下，但是

00:39:00.600 --> 00:39:05.160
这基本上是在说什么时候

00:39:02.970 --> 00:39:07.080
你处理序列化绑定

00:39:05.160 --> 00:39:08.940
您坚定地进入对象空间， 

00:39:07.080 --> 00:39:12.630
对象库中的所有内容都具有

00:39:08.940 --> 00:39:13.830
身份好吧，为什么不使用可选

00:39:12.630 --> 00:39:17.100
和田野，所以我谈到了

00:39:13.830 --> 00:39:18.600
在我认为这是一种风格之前

00:39:17.100 --> 00:39:20.490
有些人想这样做

00:39:18.600 --> 00:39:21.960
如果这对您有意义

00:39:20.490 --> 00:39:23.880
应用程序，它表现良好，并且

00:39:21.960 --> 00:39:25.230
这不是问题，我想那没关系

00:39:23.880 --> 00:39:27.720
我不会告诉你你错了

00:39:25.230 --> 00:39:29.400
如果您想使用可选的内场但是

00:39:27.720 --> 00:39:35.039
有点告诉我可能有

00:39:29.400 --> 00:39:36.869
我们已经发生了其他事情

00:39:35.039 --> 00:39:38.940
谈到内存开销， 

00:39:36.869 --> 00:39:41.160
再次这个想法，我认为有些人

00:39:38.940 --> 00:39:43.470
想要不惜一切代价避免使用null 

00:39:41.160 --> 00:39:44.970
所以很好，你知道我认为那是

00:39:43.470 --> 00:39:48.269
如果您必须进行权衡

00:39:44.970 --> 00:39:50.880
想要通过创建可选值来避免空值

00:39:48.269 --> 00:39:52.650
到处都是对象，并做额外的工作

00:39:50.880 --> 00:39:54.750
指针使用额外的内存取消引用

00:39:52.650 --> 00:39:56.970
甚至会弄乱你的

00:39:54.750 --> 00:39:58.319
代码明天你知道我认为

00:39:56.970 --> 00:40:01.619
您可以根据需要进行权衡

00:39:58.319 --> 00:40:08.160
 ，但这不是我的选择

00:40:01.619 --> 00:40:10.200
会让自己成为个人等等

00:40:08.160 --> 00:40:11.519
关于这个有一些讨论

00:40:10.200 --> 00:40:14.970
互联网上有几个

00:40:11.519 --> 00:40:17.490
对此大声疾呼的人

00:40:14.970 --> 00:40:19.740
史蒂文·科尔布（Steven Kolb）ORN写了一篇博客文章

00:40:17.490 --> 00:40:23.369
称为可选的实用方法

00:40:19.740 --> 00:40:24.779
他经历了许多

00:40:23.369 --> 00:40:28.200
我们总体上有一些好的情况

00:40:24.779 --> 00:40:30.299
关于领域的建议，他的建议是

00:40:28.200 --> 00:40:32.789
如果您的字段可能或可能

00:40:30.299 --> 00:40:36.180
不包含值，只是使用一个已知的

00:40:32.789 --> 00:40:38.279
参考和在您的API中，如果您想

00:40:36.180 --> 00:40:39.869
在以下位置返回可选

00:40:38.279 --> 00:40:42.150
您返回的位置就是您创建

00:40:39.869 --> 00:40:43.500
可选，我认为这是一个非常

00:40:42.150 --> 00:40:46.230
有趣的方法，这是实用的

00:40:43.500 --> 00:40:47.640
他所说的方法，但我认为

00:40:46.230 --> 00:40:49.890
实际上我忘了一件事

00:40:47.640 --> 00:40:52.710
提到那一点提到哪一点

00:40:49.890 --> 00:40:55.279
想着你的内部

00:40:52.710 --> 00:40:58.650
表示形式与您的API不同

00:40:55.279 --> 00:41:01.230
可选结构是API 

00:40:58.650 --> 00:41:03.599
构造它对于API返回很有用

00:41:01.230 --> 00:41:05.369
值，但这并不意味着您必须

00:41:03.599 --> 00:41:07.529
在内部使用可选

00:41:05.369 --> 00:41:10.440
代表，所以斯蒂芬有一个很好的

00:41:07.529 --> 00:41:13.740
他说的示例在可选内部使用null 

00:41:10.440 --> 00:41:15.480
在外面，我认为这是个好建议

00:41:13.740 --> 00:41:19.380
我在这里的另一个参考是

00:41:15.480 --> 00:41:22.079
到我现在在这里的一篇文章

00:41:19.380 --> 00:41:25.470
在这次会议上，他正在演讲

00:41:22.079 --> 00:41:28.140
他的跳棋框架更早，等等

00:41:25.470 --> 00:41:30.089
这是该文章的链接，在

00:41:28.140 --> 00:41:33.029
他有他所说的跳棋框架

00:41:30.089 --> 00:41:34.769
 ulness检查器，所以如果您有

00:41:33.029 --> 00:41:36.599
您想摆脱空值的想法

00:41:34.769 --> 00:41:37.710
在整个代码中，您可能应该

00:41:36.599 --> 00:41:40.099
看看这个

00:41:37.710 --> 00:41:42.569
因为正如我之前所说

00:41:40.099 --> 00:41:44.490
可选不会摆脱所有

00:41:42.569 --> 00:41:48.089
在您的程序中为null，它仅被关注

00:41:44.490 --> 00:41:51.050
在用例的某些部分上

00:41:48.089 --> 00:41:53.760
在这里我说杯子装满了四分之一

00:41:51.050 --> 00:41:55.650
对，所以可选对

00:41:53.760 --> 00:41:57.839
返回类型，但对

00:41:55.650 --> 00:41:59.940
可选方法参数无用

00:41:57.839 --> 00:42:02.579
对于对此没有用的字段

00:41:59.940 --> 00:42:04.380
另一个权利好吧，我想是

00:42:02.579 --> 00:42:06.450
玻璃为四分之一装满（可选） 

00:42:04.380 --> 00:42:09.839
这对于返回类型非常有用，但是

00:42:06.450 --> 00:42:14.550
你知道它对于将它用于

00:42:09.839 --> 00:42:16.319
没关系，这样就把我带到了

00:42:14.550 --> 00:42:17.970
总结和结论再次在这里

00:42:16.319 --> 00:42:20.940
重述设计目标

00:42:17.970 --> 00:42:22.650
可选的有限回报机制

00:42:20.940 --> 00:42:26.480
有明确需求的类型

00:42:22.650 --> 00:42:30.839
表示没有结果，其中null为

00:42:26.480 --> 00:42:32.339
可能会导致错误，并且

00:42:30.839 --> 00:42:33.869
然后是我遵循的七个规则

00:42:32.339 --> 00:42:35.069
在开始的时候我会离开

00:42:33.869 --> 00:42:37.650
这些，如果你想拿一会儿

00:42:35.069 --> 00:42:39.390
看看那个，看起来我有一个

00:42:37.650 --> 00:42:41.130
几分钟提问，如果有的话

00:42:39.390 --> 00:42:42.650
他们是前面的麦克风的问题

00:42:41.130 --> 00:42:46.099
房间前面的过道

00:42:42.650 --> 00:42:46.099
有什么问题

00:42:52.150 --> 00:42:57.260
快速问题，以分享一些

00:42:54.950 --> 00:43:01.040
替换的可能名称

00:42:57.260 --> 00:43:06.230
债务啊，你在哪里还没有我

00:43:01.040 --> 00:43:07.579
我认为命名可以，所以命名是

00:43:06.230 --> 00:43:09.079
很难，我认为我确实有一个替代者

00:43:07.579 --> 00:43:11.480
我不想说因为

00:43:09.079 --> 00:43:12.890
我们会对此做出回应，我建议

00:43:11.480 --> 00:43:14.780
替代人反应了

00:43:12.890 --> 00:43:16.930
更换，然后导致

00:43:14.780 --> 00:43:19.460
通过交易分拆另一个

00:43:16.930 --> 00:43:21.109
但是如果人们有好的建议

00:43:19.460 --> 00:43:22.520
也许我不应该这样说，但是如果人们

00:43:21.109 --> 00:43:25.339
建议给我发推文

00:43:22.520 --> 00:43:26.660
哦，实际上我忘了提我会得到

00:43:25.339 --> 00:43:29.450
先生，给你

00:43:26.660 --> 00:43:31.609
在幻灯片的右上角

00:43:29.450 --> 00:43:33.290
如果你想说话有一个标签

00:43:31.609 --> 00:43:35.990
关于这个在推特上我在推特上

00:43:33.290 --> 00:43:38.210
可以在标签上向我发送推文

00:43:35.990 --> 00:43:39.200
期待会议结束后还是你

00:43:38.210 --> 00:43:42.200
可以直接发给我

00:43:39.200 --> 00:43:44.329
是的，我们最终会得到问题

00:43:42.200 --> 00:43:47.119
印度的空方法，如果您和密钥

00:43:44.329 --> 00:43:48.920
可选方法不错

00:43:47.119 --> 00:43:51.349
这是一个好点，因为有时

00:43:48.920 --> 00:43:52.880
测试不方便是

00:43:51.349 --> 00:43:54.770
目前，我认为这是主要问题

00:43:52.880 --> 00:43:59.329
这有点像API 

00:43:54.770 --> 00:44:01.460
句法糖我想你知道也许我

00:43:59.329 --> 00:44:02.960
认为事情是如果你知道我们

00:44:01.460 --> 00:44:04.250
需要一堆用例，如果

00:44:02.960 --> 00:44:06.319
一遍又一遍，这是

00:44:04.250 --> 00:44:09.859
造成很多混乱，也许我们可以

00:44:06.319 --> 00:44:11.750
添加它，但通常不是

00:44:09.859 --> 00:44:14.210
没有添加任何基本内容

00:44:11.750 --> 00:44:16.369
你不能使用，你知道不是

00:44:14.210 --> 00:44:18.109
目前，所以也许我知道还有其他

00:44:16.369 --> 00:44:21.950
我确实在API中放置的位置

00:44:18.109 --> 00:44:23.630
认为我们拍摄的物体为空并且

00:44:21.950 --> 00:44:25.640
非玩偶之类的东西

00:44:23.630 --> 00:44:27.619
这些对于方法真的很有用

00:44:25.640 --> 00:44:29.750
引用，所以我的意思是

00:44:27.619 --> 00:44:31.549
可能性，但不是

00:44:29.750 --> 00:44:34.460
不是不是最重要的事情

00:44:31.549 --> 00:44:37.250
当下的问题，所以我的问题是

00:44:34.460 --> 00:44:41.059
关于第二条规则，如果可以的话

00:44:37.250 --> 00:44:45.950
证明价值可以不是为什么

00:44:41.059 --> 00:44:47.960
你甚至可以使用可选的哦，好吧，所以

00:44:45.950 --> 00:44:49.400
再一次，如果您考虑如何

00:44:47.960 --> 00:44:55.309
可选用的是你在打电话

00:44:49.400 --> 00:44:57.079
其他地方的方法，它会返回您

00:44:55.309 --> 00:44:59.000
可选的，那是什么方法

00:44:57.079 --> 00:45:03.050
告诉你那里可能有也可能没有

00:44:59.000 --> 00:45:05.820
成为现在的价值

00:45:03.050 --> 00:45:08.160
一种证明存在价值的方法

00:45:05.820 --> 00:45:09.570
是要呼叫存在并检查

00:45:08.160 --> 00:45:12.780
返回值，但还有其他

00:45:09.570 --> 00:45:14.250
在流API中的情况

00:45:12.780 --> 00:45:17.250
我手太复杂了

00:45:14.250 --> 00:45:19.410
挥手，我没有，我没有

00:45:17.250 --> 00:45:21.270
方便的代码，但在某些情况下

00:45:19.410 --> 00:45:24.480
流API的一些方法

00:45:21.270 --> 00:45:25.920
返回一个可选的东西，但是如果

00:45:24.480 --> 00:45:28.530
您在一个

00:45:25.920 --> 00:45:31.650
特殊的方式，你绝对

00:45:28.530 --> 00:45:33.450
确定该可选内容可以包含一个

00:45:31.650 --> 00:45:36.390
值，它不可能为空

00:45:33.450 --> 00:45:37.530
然后继续打电话给它，但是

00:45:36.390 --> 00:45:39.960
你要做的就是要做

00:45:37.530 --> 00:45:41.460
关于数据的全局断言

00:45:39.960 --> 00:45:43.950
程序状态下的结构

00:45:41.460 --> 00:45:45.690
在您可以做到之前，有时

00:45:43.950 --> 00:45:47.730
直截了当地说差距

00:45:45.690 --> 00:45:57.300
有时这是关于

00:45:47.730 --> 00:45:58.530
您的程序，这样很好

00:45:57.300 --> 00:45:59.940
毕竟我们可以谈谈

00:45:58.530 --> 00:46:04.170
提出一个简单的例子或

00:45:59.940 --> 00:46:07.980
好的，谢谢你，Java 

00:46:04.170 --> 00:46:09.600
获得安全的遍历运算符基础，并

00:46:07.980 --> 00:46:13.170
如果我们将事物链接在一起

00:46:09.600 --> 00:46:17.430
哦，爱猫王操作员啊，是的

00:46:13.170 --> 00:46:19.020
猫王运算符嗯，我可能不是

00:46:17.430 --> 00:46:22.710
有一些尝试这样做

00:46:19.020 --> 00:46:28.830
 Java 7中的项目硬币

00:46:22.710 --> 00:46:30.450
他们付出了一些努力，他们我

00:46:28.830 --> 00:46:33.480
你不知道总是很难吗

00:46:30.450 --> 00:46:35.220
说为什么有些事情没有成功

00:46:33.480 --> 00:46:36.930
认为这是有人说的

00:46:35.220 --> 00:46:38.460
所有这些Adobe应该真的很容易

00:46:36.930 --> 00:46:41.340
他们原型证明它是

00:46:38.460 --> 00:46:42.390
真的很难，这根本不是

00:46:41.340 --> 00:46:45.300
更改时不常见

00:46:42.390 --> 00:46:47.910
我认为虽然编程语言

00:46:45.300 --> 00:46:50.220
我认为这是一种哲学

00:46:47.910 --> 00:46:53.910
一种哲学观点是时间

00:46:50.220 --> 00:46:59.070
继续，我们正在努力吸引

00:46:53.910 --> 00:47:01.410
远离容忍null的事物

00:46:59.070 --> 00:47:03.150
例如Java 9 

00:47:01.410 --> 00:47:05.430
收集了不可变的集合

00:47:03.150 --> 00:47:06.780
我介绍的我将要谈论

00:47:05.430 --> 00:47:09.330
明天在我的会议上

00:47:06.780 --> 00:47:10.800
如果您尝试

00:47:09.330 --> 00:47:13.890
在其中一个扔一个空值

00:47:10.800 --> 00:47:15.540
空指针异常和

00:47:13.890 --> 00:47:17.430
与可选相同

00:47:15.540 --> 00:47:20.940
您试图将一个空引用

00:47:17.430 --> 00:47:22.470
引发异常，因此

00:47:20.940 --> 00:47:23.820
我们想做的是说好

00:47:22.470 --> 00:47:26.070
我们知道有很多空值

00:47:23.820 --> 00:47:30.360
在那里我们要避免使用它们，所以

00:47:26.070 --> 00:47:34.200
在边界内你知道吗

00:47:30.360 --> 00:47:36.450
不处理的安全代码

00:47:34.200 --> 00:47:38.280
空值，因为并且不必处理

00:47:36.450 --> 00:47:40.530
用空值，我想关于

00:47:38.280 --> 00:47:42.630
空安全遍历或猫王

00:47:40.530 --> 00:47:44.520
操作员是做什么的

00:47:42.630 --> 00:47:46.860
鼓励零星散布到各处

00:47:44.520 --> 00:47:48.420
每次你写的时候就像

00:47:46.860 --> 00:47:49.980
哦，好吧，如果现在不行，我不在乎

00:47:48.420 --> 00:47:51.810
我将使用此运算符和null 

00:47:49.980 --> 00:47:54.060
传播到任何地方，直到你到达

00:47:51.810 --> 00:47:58.320
指出你无法应付的地方

00:47:54.060 --> 00:48:01.560
然后你被用软管吸住，所以我想

00:47:58.320 --> 00:48:04.140
我不认为有任何东西

00:48:01.560 --> 00:48:11.130
推动在以下位置添加空安全遍历

00:48:04.140 --> 00:48:12.970
这一点还有其他问题吗

00:48:11.130 --> 00:48:15.660
看起来像谢谢你的光临

00:48:12.970 --> 00:48:20.610
 [掌声] 

00:48:15.660 --> 00:48:20.610
 [音乐] 

