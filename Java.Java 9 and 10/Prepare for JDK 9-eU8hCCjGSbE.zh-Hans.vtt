WEBVTT
Kind: captions
Language: zh-Hans

00:00:05.890 --> 00:00:10.030
下午好，我叫艾伦

00:00:08.530 --> 00:00:12.850
贝特曼，我正在讲一个电话

00:00:10.030 --> 00:00:15.039
如果您正在寻找JDK 9的准备

00:00:12.850 --> 00:00:16.570
您可能拥有的内容剪切和目录

00:00:15.039 --> 00:00:18.220
看到它实际上是亚历克斯·巴克利

00:00:16.570 --> 00:00:20.590
应该说那只是一个

00:00:18.220 --> 00:00:22.450
有点混乱的名字

00:00:20.590 --> 00:00:24.790
我在这里实际上是亚历克斯·巴克利（Alex Buckley） 

00:00:22.450 --> 00:00:27.360
而在他身旁的是马克·莱因霍尔德，他们可能

00:00:24.790 --> 00:00:29.740
最后帮助一些问题，这样

00:00:27.360 --> 00:00:31.630
在我们进入这个演讲之前，我

00:00:29.740 --> 00:00:33.879
只想说这不是一个

00:00:31.630 --> 00:00:35.829
所有酷功能的介绍

00:00:33.879 --> 00:00:37.570
还有马克的一长串喷气机

00:00:35.829 --> 00:00:40.060
在主题演讲中显示这不是关于

00:00:37.570 --> 00:00:42.310
 JDK 9中的所有新功能是

00:00:40.060 --> 00:00:45.600
而是专注于

00:00:42.310 --> 00:00:47.860
 JDK 9中更改的含义

00:00:45.600 --> 00:00:51.280
特别是在强者周围

00:00:47.860 --> 00:00:53.200
 JDK内部封装

00:00:51.280 --> 00:00:55.420
 api的应用程序很多， 

00:00:53.200 --> 00:00:57.910
图书馆已经在利用

00:00:55.420 --> 00:01:00.670
这些年有几个小

00:00:57.910 --> 00:01:02.800
我需要该功能的JDK 9中的功能

00:01:00.670 --> 00:01:05.469
与迁移和帮助

00:01:02.800 --> 00:01:07.299
 JDK 8和9之间的中断

00:01:05.469 --> 00:01:08.799
将花几分钟的时间

00:01:07.299 --> 00:01:11.080
演讲结束但大部分

00:01:08.799 --> 00:01:15.640
这部分是关于

00:01:11.080 --> 00:01:17.380
 JDK 9所以在我开始之前我想我会

00:01:15.640 --> 00:01:20.650
有兴趣从

00:01:17.380 --> 00:01:22.570
观众中有多少人

00:01:20.650 --> 00:01:24.310
该受众群体正在跟踪功能

00:01:22.570 --> 00:01:29.070
以及进入JDK的更改

00:01:24.310 --> 00:01:31.780
 9好的，所以有几个人

00:01:29.070 --> 00:01:34.390
首先，我对你的手感到好奇

00:01:31.780 --> 00:01:38.549
实际上已经下载了JDK 9 

00:01:34.390 --> 00:01:38.549
抢先体验账单来尝试一下

00:01:38.820 --> 00:01:45.280
类似的手数好吧，这是

00:01:42.909 --> 00:01:47.710
一个奇怪的问题，谁担心

00:01:45.280 --> 00:01:49.060
 JDK 9中可能会有更改

00:01:47.710 --> 00:01:53.619
破坏他们现有的代码或

00:01:49.060 --> 00:01:56.409
现有应用程序

00:01:53.619 --> 00:01:59.490
好的那就是那很好

00:01:56.409 --> 00:02:02.049
这就是这个演讲的目的

00:01:59.490 --> 00:02:04.329
在我进入这个之前的一件事是我

00:02:02.049 --> 00:02:07.390
应该说明的是JDK 9仍然是

00:02:04.329 --> 00:02:10.509
开发，直到发布

00:02:07.390 --> 00:02:11.950
或计划在2017年发货

00:02:10.509 --> 00:02:14.349
许多仍在变化的事物

00:02:11.950 --> 00:02:17.020
没有什么是最终的，所以

00:02:14.349 --> 00:02:18.260
当我谈论和一些

00:02:17.020 --> 00:02:20.390
变化

00:02:18.260 --> 00:02:21.920
也许那会是当它在哪里

00:02:20.390 --> 00:02:23.689
最终出货，也许会有一些

00:02:21.920 --> 00:02:28.310
差异，因此请记住

00:02:23.689 --> 00:02:29.780
这不是最终的，但第一件事只是

00:02:28.310 --> 00:02:31.790
进入这个礼物

00:02:29.780 --> 00:02:33.980
演示文稿只是说这是第一个

00:02:31.790 --> 00:02:37.879
我和亚历克斯的五个演讲

00:02:33.980 --> 00:02:39.409
今年在JavaOne上做，其余的

00:02:37.879 --> 00:02:43.540
在这之后我们的谈话非常

00:02:39.409 --> 00:02:46.159
非常关注模块化和

00:02:43.540 --> 00:02:49.099
模块周围的所有功能

00:02:46.159 --> 00:02:51.709
在JDK中，我们重复其中的四个

00:02:49.099 --> 00:02:54.769
最后我将有一张幻灯片

00:02:51.709 --> 00:02:57.680
这些人的时间和地点

00:02:54.769 --> 00:03:01.159
您可以看到我们在谈论什么

00:02:57.680 --> 00:03:02.510
当它打开时，我想经历一个

00:03:01.159 --> 00:03:05.299
我们之前的几张背景幻灯片

00:03:02.510 --> 00:03:07.840
进入电表演示等等

00:03:05.299 --> 00:03:11.239
首先只是一些背景

00:03:07.840 --> 00:03:16.129
 JDK 9和项目的目标是什么

00:03:11.239 --> 00:03:17.959
拼图如此高层次是什么

00:03:16.129 --> 00:03:19.879
我们试图做的是使Java 

00:03:17.959 --> 00:03:24.530
平台和Java会看到更多

00:03:19.879 --> 00:03:25.849
灵活且可扩展，并允许

00:03:24.530 --> 00:03:28.639
还有更多的地方

00:03:25.849 --> 00:03:30.739
可靠而紧凑的部署，因此

00:03:28.639 --> 00:03:32.959
在云中或之上部署运行时

00:03:30.739 --> 00:03:35.329
我们试图达到的嵌入式系统

00:03:32.959 --> 00:03:38.959
我们拥有更多的点

00:03:35.329 --> 00:03:40.160
安全和可维护的平台，当我们

00:03:38.959 --> 00:03:41.870
谈论我们正在谈论的安全性

00:03:40.160 --> 00:03:43.790
封装了很多

00:03:41.870 --> 00:03:47.569
安全敏感和内部api 

00:03:43.790 --> 00:03:50.569
以及模块内和

00:03:47.569 --> 00:03:53.060
具有这些强大的可维护性

00:03:50.569 --> 00:03:54.980
封装和封装

00:03:53.060 --> 00:03:57.680
永恒的api会让事情变得很多

00:03:54.980 --> 00:03:59.799
对于JDK更具可维护性

00:03:57.680 --> 00:04:02.930
使它更易于维护

00:03:59.799 --> 00:04:05.209
对于图书馆和使用

00:04:02.930 --> 00:04:06.949
库，因为很多库和

00:04:05.209 --> 00:04:09.859
应用程序正在使用内部

00:04:06.949 --> 00:04:11.419
其他库中的API api可能

00:04:09.859 --> 00:04:13.730
可能是在不知不觉中

00:04:11.419 --> 00:04:15.049
因此拥有模块将使我们进入

00:04:13.730 --> 00:04:17.870
指出更多的地方

00:04:15.049 --> 00:04:19.519
可维护的，我们想使其易于

00:04:17.870 --> 00:04:22.940
构建维护部署和升级

00:04:19.519 --> 00:04:24.860
大型应用程序，而且都是Java 

00:04:22.940 --> 00:04:28.430
 C应用程序，最终在

00:04:24.860 --> 00:04:30.770
我们和未来的Java EE应用程序

00:04:28.430 --> 00:04:32.029
重要的是我们要朝着

00:04:30.770 --> 00:04:35.539
改善

00:04:32.029 --> 00:04:38.329
所谓的Jar Jar情况

00:04:35.539 --> 00:04:40.039
地狱，我们与

00:04:38.329 --> 00:04:43.249
今天的classpath，所以我们会走很长一段路

00:04:40.039 --> 00:04:44.509
改善情况，并与

00:04:43.249 --> 00:04:47.209
 JDK 9中的模块

00:04:44.509 --> 00:04:48.769
最后是我们在做的

00:04:47.209 --> 00:04:51.589
我们将实际使用的模块并启用

00:04:48.769 --> 00:04:56.059
在性能上有很多改进

00:04:51.589 --> 00:04:59.509
未来，所以我想从开始

00:04:56.059 --> 00:05:02.539
您的一些api类别

00:04:59.509 --> 00:05:05.360
拥有并且拥有Java平台

00:05:02.539 --> 00:05:08.239
知道Java点星号和Java X点

00:05:05.360 --> 00:05:10.759
星型api，因此我们使用java.lang对象或

00:05:08.239 --> 00:05:13.519
 javax.swing jpanel或类似的东西

00:05:10.759 --> 00:05:15.799
这些是标准的Java SE api 

00:05:13.519 --> 00:05:17.539
他们是他们绑在java上

00:05:15.799 --> 00:05:19.309
他们在那里定义的社区过程

00:05:17.539 --> 00:05:22.099
他们得到支持并记录了api 

00:05:19.309 --> 00:05:24.289
我们都知道那里有一堆

00:05:22.099 --> 00:05:27.019
其他的api总是有点

00:05:24.289 --> 00:05:30.799
有点令人困惑，我们称它们为jdk 

00:05:27.019 --> 00:05:32.959
特定的api这些api通常是

00:05:30.799 --> 00:05:35.719
在至少历史上

00:05:32.959 --> 00:05:39.139
如果您转到comm sun命名空间中

00:05:35.719 --> 00:05:40.879
您将在文档页面中找到

00:05:39.139 --> 00:05:42.949
实际看到一些记录

00:05:40.879 --> 00:05:45.550
 Khamsin API的安全性

00:05:42.949 --> 00:05:48.469
管理和其他一些领域

00:05:45.550 --> 00:05:50.899
在最近的JDK发布中，这些JDK 

00:05:48.469 --> 00:05:54.169
特定的api已经在jdk点中

00:05:50.899 --> 00:05:56.059
一些名称空间，因为我们拥有

00:05:54.169 --> 00:05:58.849
因为我们不再是太阳

00:05:56.059 --> 00:06:01.009
移至，我们现在是一个开放的JDK 

00:05:58.849 --> 00:06:03.019
着手定义这些JDK特定的API 

00:06:01.009 --> 00:06:05.779
在jdk命名空间rahdert和Comm中

00:06:03.019 --> 00:06:07.939
有些还有一大堆其他

00:06:05.779 --> 00:06:10.369
内部api也在通讯中

00:06:07.939 --> 00:06:11.809
一些命名空间，有时您会看到

00:06:10.369 --> 00:06:13.309
包名称中的内部单词和

00:06:11.809 --> 00:06:16.039
很明显，这是一个

00:06:13.309 --> 00:06:17.899
内部包装其他不清楚

00:06:16.039 --> 00:06:21.379
所以周围总是有混乱

00:06:17.899 --> 00:06:24.049
这些就是太阳点星

00:06:21.379 --> 00:06:25.909
命名空间，大多数人会知道，如果

00:06:24.049 --> 00:06:28.309
他们看到一个Sun点星API 

00:06:25.909 --> 00:06:30.739
可能是JDK内部出现了Sun 

00:06:28.309 --> 00:06:40.279
点星API一直回到jdk 

00:06:30.739 --> 00:06:42.559
 1.0所以这是这是这是

00:06:40.279 --> 00:06:45.500
从中捕获页面之一

00:06:42.559 --> 00:06:47.630
 jdk 1.0 1.1中的文档

00:06:45.500 --> 00:06:50.900
我把这个标记挖出来对于Java 

00:06:47.630 --> 00:06:52.670
去年显示页面在哪里

00:06:50.900 --> 00:06:55.220
有关于使用Sun dot的警告

00:06:52.670 --> 00:06:57.170
星号ap是底部底部的日期

00:06:55.220 --> 00:06:59.930
那些看不懂的我忘了

00:06:57.170 --> 00:07:02.210
带双筒望远镜说1996年在

00:06:59.930 --> 00:07:03.740
如果我要读出页面底部

00:07:02.210 --> 00:07:05.870
这是我用红色突出显示的内容

00:07:03.740 --> 00:07:07.640
它说太阳点是包装

00:07:05.870 --> 00:07:09.620
不属于受支持的Java 

00:07:07.640 --> 00:07:12.980
公共接口程序直接

00:07:09.620 --> 00:07:14.750
调用任何API和Sun dot star软件包

00:07:12.980 --> 00:07:17.060
不保证可以在所有Java上使用

00:07:14.750 --> 00:07:19.460
兼容的平台，所以有一个

00:07:17.060 --> 00:07:21.890
文档中的警告几乎

00:07:19.460 --> 00:07:24.020
关于不使用Sun Deathstar的20年

00:07:21.890 --> 00:07:25.430
 JDK 6中的api 

00:07:24.020 --> 00:07:27.169
这实际上是由

00:07:25.430 --> 00:07:29.090
编译器，因此它实际上会发出警告

00:07:27.169 --> 00:07:31.280
如果它尝试编译的代码是

00:07:29.090 --> 00:07:33.320
实际上使用任何内部EAP是

00:07:31.280 --> 00:07:35.150
我的猜测是，如果我吸引观众

00:07:33.320 --> 00:07:37.040
很多人不会有

00:07:35.150 --> 00:07:39.140
看到这个警告，他们会忽略

00:07:37.040 --> 00:07:42.230
我们都内of的警告

00:07:39.140 --> 00:07:44.120
这只是关于几件事的事情

00:07:42.230 --> 00:07:47.060
我之前的一般兼容性政策

00:07:44.120 --> 00:07:49.580
进入一些真正的幻灯片是

00:07:47.060 --> 00:07:52.100
如果一个应用程序是高水平的

00:07:49.580 --> 00:07:54.950
仅使用受支持的API，并且有效

00:07:52.100 --> 00:07:57.890
在特定版本上，则应该

00:07:54.950 --> 00:08:00.680
在下一个版本上工作，甚至

00:07:57.890 --> 00:08:02.419
如果我没有完整地编译我们

00:08:00.680 --> 00:08:04.610
 JDK上的某些内容，所以我已经对其进行了编译

00:08:02.419 --> 00:08:07.250
使用JDK 7时，它应该在JDK时代运行

00:08:04.610 --> 00:08:10.460
无需重新编译（假设正在使用） 

00:08:07.250 --> 00:08:12.050
只是受支持的api的

00:08:10.460 --> 00:08:15.260
一直是兼容性的故事

00:08:12.050 --> 00:08:16.669
 20年的大部分时间，这意味着

00:08:15.260 --> 00:08:18.500
很多人实际上可以保存

00:08:16.669 --> 00:08:20.120
他们现有的投资，因为他们

00:08:18.500 --> 00:08:21.830
知道或他们有一定的信心

00:08:20.120 --> 00:08:25.310
事情只会在下一个

00:08:21.830 --> 00:08:27.650
 JDK尝试的下一个发行版

00:08:25.310 --> 00:08:30.470
什么不会保证，永远不会

00:08:27.650 --> 00:08:32.120
答应了，它不会中断

00:08:30.470 --> 00:08:37.010
使用内部的应用程序

00:08:32.120 --> 00:08:39.469
 api和不兼容的更改

00:08:37.010 --> 00:08:41.570
支持的api往往仅限于

00:08:39.469 --> 00:08:43.610
主要发行版本有时带有内部

00:08:41.570 --> 00:08:46.100
 API有污垢有破损

00:08:43.610 --> 00:08:47.720
其他版本以及什么纸质钥匙

00:08:46.100 --> 00:08:50.300
人们在工作时尝试

00:08:47.720 --> 00:08:51.620
 JDK尝试考虑到

00:08:50.300 --> 00:08:55.280
人们正在使用的可能性

00:08:51.620 --> 00:08:56.990
这些api的政策是

00:08:55.280 --> 00:08:59.360
建立了几个发行版本

00:08:56.990 --> 00:09:02.959
返回以允许支持

00:08:59.360 --> 00:09:04.820
伙计们被删除，这不是

00:09:02.959 --> 00:09:07.370
实际被所有使用的东西

00:09:04.820 --> 00:09:10.750
经常这样，只是

00:09:07.370 --> 00:09:14.810
发生重大提前通知

00:09:10.750 --> 00:09:17.450
对于Java c9，我们建议删除

00:09:14.810 --> 00:09:19.640
少数不推荐使用的方法和

00:09:17.450 --> 00:09:22.880
我们会在后面看到

00:09:19.640 --> 00:09:26.300
介绍只是几点

00:09:22.880 --> 00:09:28.550
关于管理不兼容性等

00:09:26.300 --> 00:09:32.839
管理兼容性就是一切

00:09:28.550 --> 00:09:34.760
判断风险和影响以及很多

00:09:32.839 --> 00:09:36.620
当我们试图使用真实数据的时候

00:09:34.760 --> 00:09:38.089
试图判断是否有东西

00:09:36.620 --> 00:09:40.820
是不兼容的更改， 

00:09:38.089 --> 00:09:43.420
影响在很多时候

00:09:40.820 --> 00:09:45.440
对完成了静态分析

00:09:43.420 --> 00:09:47.420
成千上万

00:09:45.440 --> 00:09:51.170
例如在Maven Center中的项目

00:09:47.420 --> 00:09:53.360
了解有关API使用情况的信息，因此

00:09:51.170 --> 00:09:54.769
尝试时经常使用大量数据

00:09:53.360 --> 00:09:56.870
弄清楚是否要进行更改或

00:09:54.769 --> 00:10:01.060
不存在不兼容的更改时

00:09:56.870 --> 00:10:03.260
我们尝试尽早交流

00:10:01.060 --> 00:10:05.180
对于我们所做的一些改变

00:10:03.260 --> 00:10:06.529
谈到JDK 9，我们一直在

00:10:05.180 --> 00:10:09.410
现在真的在谈论这些

00:10:06.529 --> 00:10:11.120
快五年了，我就是

00:10:09.410 --> 00:10:13.220
谈论要谈论

00:10:11.120 --> 00:10:15.350
建议删除的

00:10:13.220 --> 00:10:17.480
是我们计划删除的东西

00:10:15.350 --> 00:10:20.149
很久以前，我们已弃用它们

00:10:17.480 --> 00:10:25.040
很久以前

00:10:20.149 --> 00:10:26.600
当我们做的时候转移到模块和JDK 9 

00:10:25.040 --> 00:10:28.610
不兼容的更改是我们尝试

00:10:26.600 --> 00:10:31.550
易于理解工具和

00:10:28.610 --> 00:10:33.290
代码将受到影响，并且

00:10:31.550 --> 00:10:34.820
几个人举起手来

00:10:33.290 --> 00:10:37.660
说他们正在尽早测试

00:10:34.820 --> 00:10:39.949
存取账单确实是时候

00:10:37.660 --> 00:10:41.680
在主要版本的开发过程中

00:10:39.949 --> 00:10:45.370
实际定义这些

00:10:41.680 --> 00:10:48.380
不兼容问题以及早期

00:10:45.370 --> 00:10:49.850
有时候我们可能会

00:10:48.380 --> 00:10:52.040
变化，我们可能不会意识到

00:10:49.850 --> 00:10:53.300
影响是很好，但我们得到反馈， 

00:10:52.040 --> 00:10:54.829
我们从那些

00:10:53.300 --> 00:10:56.360
试用早期访问版本

00:10:54.829 --> 00:10:58.160
指出我们可能没有的东西

00:10:56.360 --> 00:11:00.110
实际上发现，所以有这种

00:10:58.160 --> 00:11:04.040
早期访问法案的反馈是

00:11:00.110 --> 00:11:07.339
非常非常有用，而且经常

00:11:04.040 --> 00:11:08.930
进行更改时，我们拥有系统

00:11:07.339 --> 00:11:10.760
属性，或者我们还有其他命令行

00:11:08.930 --> 00:11:13.130
保留的选项

00:11:10.760 --> 00:11:15.380
他们正在恢复旧的行为

00:11:13.130 --> 00:11:16.850
发行，如果您每看一次

00:11:15.380 --> 00:11:18.470
 JDK的主要版本

00:11:16.850 --> 00:11:20.840
文档，所有的系统

00:11:18.470 --> 00:11:23.570
属性或其他小旋钮

00:11:20.840 --> 00:11:29.540
能够还原并保留所有行为

00:11:23.570 --> 00:11:32.330
最后我们写了漫长的迁移

00:11:29.540 --> 00:11:33.890
和发行说明，我不知道有多少

00:11:32.330 --> 00:11:35.600
人们实际上读了它们，但是有一个

00:11:33.890 --> 00:11:38.180
每个主要版本都有一个

00:11:35.600 --> 00:11:40.820
发行说明的详尽清单

00:11:38.180 --> 00:11:46.310
记录所有兼容性问题

00:11:40.820 --> 00:11:48.740
我们知道高就可以

00:11:46.310 --> 00:11:52.130
这些是一些不兼容的

00:11:48.740 --> 00:11:53.570
 JDK 9中的重要变化

00:11:52.130 --> 00:11:55.360
我将大部分时间都花在

00:11:53.570 --> 00:11:58.880
在第一个是

00:11:55.360 --> 00:12:00.620
内部封装大多数JDK API 

00:11:58.880 --> 00:12:02.870
我想谈谈

00:12:00.620 --> 00:12:04.700
 JDK的二进制结构和几个

00:12:02.870 --> 00:12:08.330
被移除的东西和

00:12:04.700 --> 00:12:09.980
其他一些变化以及

00:12:08.330 --> 00:12:13.640
版本更改原来是

00:12:09.980 --> 00:12:15.890
相当重要的问题，所以我

00:12:13.640 --> 00:12:19.430
从一个数据点开始

00:12:15.890 --> 00:12:22.160
是基于我们的分析

00:12:19.430 --> 00:12:27.290
去年做了关于JDK的用法

00:12:22.160 --> 00:12:29.810
内部API的，所以这里的图是

00:12:27.290 --> 00:12:32.470
根据对大约一百种的分析

00:12:29.810 --> 00:12:34.610
不同的图书馆和一些受欢迎的

00:12:32.470 --> 00:12:35.930
开源库和几个

00:12:34.610 --> 00:12:38.780
我们拥有的专有应用程序

00:12:35.930 --> 00:12:41.150
这样我们就可以动手了

00:12:38.780 --> 00:12:44.180
对此进行一些静态分析

00:12:41.150 --> 00:12:46.300
了解哪个JDK 

00:12:44.180 --> 00:12:49.490
内部API实际上正在使用

00:12:46.300 --> 00:12:50.870
该图的结构方式

00:12:49.490 --> 00:12:53.150
抱歉显示这是因为

00:12:50.870 --> 00:12:57.290
内部API绘制在x轴上

00:12:53.150 --> 00:13:00.200
并且使用计数在y轴上，因此

00:12:57.290 --> 00:13:02.300
从左边看，我们可以看到

00:13:00.200 --> 00:13:04.460
基于此静态分析，有一个

00:13:02.300 --> 00:13:07.250
一些的一百二十五用法

00:13:04.460 --> 00:13:09.110
内部API， 

00:13:07.250 --> 00:13:11.480
另一个烤箱的百次用法

00:13:09.110 --> 00:13:14.750
内部API，我们可以看到

00:13:11.480 --> 00:13:17.630
长长的尾巴在这里继续

00:13:14.750 --> 00:13:20.690
这是那段代码

00:13:17.630 --> 00:13:24.080
检查了700多种

00:13:20.690 --> 00:13:27.540
使用的内部api 

00:13:24.080 --> 00:13:29.970
所以我不知道是否有人愿意

00:13:27.540 --> 00:13:32.250
猜猜最流行的Sun点

00:13:29.970 --> 00:13:34.170
此代码使用的star API 

00:13:32.250 --> 00:13:35.430
就是说你就是这群人

00:13:34.170 --> 00:13:37.680
您所使用的库和应用程序

00:13:35.430 --> 00:13:42.090
还没看到有人要给

00:13:37.680 --> 00:13:44.490
凝视着我听到有人说不安全

00:13:42.090 --> 00:13:48.840
那是一个很好的猜测，但对于

00:13:44.490 --> 00:13:51.180
这对于这组图书馆和

00:13:48.840 --> 00:13:53.700
应用程序，事实证明是一些

00:13:51.180 --> 00:13:55.860
想念base64编码器是最多的

00:13:53.700 --> 00:13:58.830
流行的一种用途和太阳孙小姐枪

00:13:55.860 --> 00:14:00.510
如果我们能够做到，安全就不会落后太远

00:13:58.830 --> 00:14:03.840
下降到第三个

00:14:00.510 --> 00:14:07.230
实际上有些杂项base64解码器是

00:14:03.840 --> 00:14:09.240
第三流行的一种用途

00:14:07.230 --> 00:14:11.540
只是说说base64是这样的

00:14:09.240 --> 00:14:14.880
经过近20年的努力，我们终于做到了

00:14:11.540 --> 00:14:22.070
在Java中引入标准的base64 API 

00:14:14.880 --> 00:14:24.720
最后，基于此，Cace 

00:14:22.070 --> 00:14:27.090
内部API有一个分类

00:14:24.720 --> 00:14:28.290
那是放在一起，我去

00:14:27.090 --> 00:14:30.630
进去，聊了几分钟

00:14:28.290 --> 00:14:35.460
关于如何在JEP中进行记录

00:14:30.630 --> 00:14:37.230
 260，当我们看着

00:14:35.460 --> 00:14:38.550
内部API的所有这些用法是

00:14:37.230 --> 00:14:41.490
我们基本上可以将它们分成两部分

00:14:38.550 --> 00:14:45.870
桶里有非关键的API 

00:14:41.490 --> 00:14:47.670
这真的是api的那个

00:14:45.870 --> 00:14:48.839
没有被任何东西真正使用

00:14:47.670 --> 00:14:51.390
没有证据表明他们实际上是

00:14:48.839 --> 00:14:52.860
在此酒神中也将使用

00:14:51.390 --> 00:14:55.140
内部API实际上就是

00:14:52.860 --> 00:14:56.339
被某人方便使用

00:14:55.140 --> 00:14:58.170
碰巧发现有一个非常

00:14:56.339 --> 00:15:00.780
有用的Sun是我们的API，因此他们可以

00:14:58.170 --> 00:15:03.300
使用它没有真正的理由或

00:15:00.780 --> 00:15:05.730
关键原因是

00:15:03.300 --> 00:15:08.100
关键的API是Muskaan安全的

00:15:05.730 --> 00:15:10.200
最明显的不是

00:15:08.100 --> 00:15:12.000
可以写自己的太阳

00:15:10.200 --> 00:15:13.770
 Muskaan保险箱不在

00:15:12.000 --> 00:15:17.030
平台，并且数量很少

00:15:13.770 --> 00:15:20.610
其他关键内部API就是这样

00:15:17.030 --> 00:15:22.530
所以在JEP 260中，JEP是jdk 

00:15:20.610 --> 00:15:25.140
增强建议是它是

00:15:22.530 --> 00:15:28.080
这就是功能和其他大功能

00:15:25.140 --> 00:15:31.410
变化和重大变化

00:15:28.080 --> 00:15:32.820
实际跟踪到JDK，我们有JEP 260 

00:15:31.410 --> 00:15:35.550
比我都应该说的都多

00:15:32.820 --> 00:15:37.170
它提出了，这就是我们所拥有的

00:15:35.550 --> 00:15:39.869
我们比尔现在的房价还可以

00:15:37.170 --> 00:15:42.389
封装所有非关键内部

00:15:39.869 --> 00:15:45.180
 api默认记住非关键

00:15:42.389 --> 00:15:46.470
内部api是没有证据的

00:15:45.180 --> 00:15:48.230
他们正在被使用或只是

00:15:46.470 --> 00:15:50.550
为方便起见，我们

00:15:48.230 --> 00:15:52.889
封装所有关键内部

00:15:50.550 --> 00:15:56.730
支持替换的API 

00:15:52.889 --> 00:15:58.829
在jdk时代或Java SCH中，如果有

00:15:56.730 --> 00:16:00.149
如果确实有受支持的API，则不会

00:15:58.829 --> 00:16:02.309
而且没有理由在

00:16:00.149 --> 00:16:04.079
然后打开这个关键的内部API 

00:16:02.309 --> 00:16:07.040
没有理由应该这样

00:16:04.079 --> 00:16:10.649
可在九个国家广泛使用

00:16:07.040 --> 00:16:13.259
那么最后一个是不封装

00:16:10.649 --> 00:16:15.839
一些关键的内部API 

00:16:13.259 --> 00:16:17.490
 Sun Muskaan安全且完整

00:16:15.839 --> 00:16:19.829
在下一张幻灯片中从G到60的列表

00:16:17.490 --> 00:16:22.740
相反，我们要做的是

00:16:19.829 --> 00:16:25.199
弃用它们，然后计划

00:16:22.740 --> 00:16:29.999
一旦有支持，将其删除

00:16:25.199 --> 00:16:32.610
使用任何东西都可以使用的API 

00:16:29.999 --> 00:16:34.499
这些使用这些API的人也会有一个

00:16:32.610 --> 00:16:36.779
解决方法是通过命令行和

00:16:34.499 --> 00:16:39.329
您将看到的其他方式

00:16:36.779 --> 00:16:43.110
仍然可以在您使用这些api时

00:16:39.329 --> 00:16:46.129
真的需要让Jeff 260保持现状

00:16:43.110 --> 00:16:49.889
目前列出以下内容为

00:16:46.129 --> 00:16:53.639
关键内部API和Sun Muskaan 

00:16:49.889 --> 00:16:55.829
安全，这对很多低电量至关重要

00:16:53.639 --> 00:16:59.189
级别访问和高性能

00:16:55.829 --> 00:17:01.079
我们拥有信号API的库

00:16:59.189 --> 00:17:03.749
与两个信号有关

00:17:01.079 --> 00:17:06.270
处理和反思请致电我们

00:17:03.749 --> 00:17:08.490
现在被日志记录广泛使用的类

00:17:06.270 --> 00:17:12.350
框架有一个新的栈走

00:17:08.490 --> 00:17:16.860
 API是JEP 259中的一部分

00:17:12.350 --> 00:17:18.600
 Java C 9，最终我们将

00:17:16.860 --> 00:17:20.220
希望日志记录框架和

00:17:18.600 --> 00:17:22.529
此API的其他用法将迁移

00:17:20.220 --> 00:17:25.860
那里有阳光反射

00:17:22.529 --> 00:17:27.899
反射工厂被广泛使用

00:17:25.860 --> 00:17:31.890
序列化框架，因为它

00:17:27.899 --> 00:17:32.640
提供您所需要的一些功能

00:17:31.890 --> 00:17:34.409
需要能够例如

00:17:32.640 --> 00:17:38.220
实例化对象而不运行

00:17:34.409 --> 00:17:40.080
诸如此类的构造函数

00:17:38.220 --> 00:17:42.120
回到我们在这个

00:17:40.080 --> 00:17:43.380
几张幻灯片，所以这是

00:17:42.120 --> 00:17:46.049
大约一百种不同的产品

00:17:43.380 --> 00:17:50.279
这实际上使标签对不起颜色

00:17:46.049 --> 00:17:50.559
实际上是在内部api上

00:17:50.279 --> 00:17:53.409
您

00:17:50.559 --> 00:17:55.629
在这里，这样你就可以看到

00:17:53.409 --> 00:17:58.149
涉及到

00:17:55.629 --> 00:17:59.590
最后两张幻灯片，所以当我往下看时

00:17:58.149 --> 00:18:02.700
通过这个，我意识到颜色

00:17:59.590 --> 00:18:05.230
很难区分这是

00:18:02.700 --> 00:18:06.669
那些橙色的如果你

00:18:05.230 --> 00:18:08.700
看看第二个儿子穆斯卡恩（Muskaan） 

00:18:06.669 --> 00:18:11.769
安全是关键的内部api 

00:18:08.700 --> 00:18:14.980
紫色，其中很多

00:18:11.769 --> 00:18:16.690
 Sun缺少base64编码和解码，或者

00:18:14.980 --> 00:18:19.509
靠近顶部的是很好的例子

00:18:16.690 --> 00:18:21.220
它们是非关键的api，并且

00:18:19.509 --> 00:18:23.110
对他们来说，受支持的API从来没有

00:18:21.220 --> 00:18:25.419
确实有任何使用理由

00:18:23.110 --> 00:18:29.049
 JT案例和乌龟以及版本和

00:18:25.419 --> 00:18:33.369
无论如何，我是绿色的，并不重要， 

00:18:29.049 --> 00:18:34.929
非山姆，但有9个人支持

00:18:33.369 --> 00:18:36.820
类别很少

00:18:34.929 --> 00:18:38.470
当我们看这些内部API 

00:18:36.820 --> 00:18:40.450
用法意识到这些应该

00:18:38.470 --> 00:18:43.919
确实得到了api的支持，所以

00:18:40.450 --> 00:18:46.570
这些是w3c哑巴XPath是

00:18:43.919 --> 00:18:47.769
在这种情况下，我们不是

00:18:46.570 --> 00:18:50.350
在条款上没有做正确的事

00:18:47.769 --> 00:18:53.830
提供与

00:18:50.350 --> 00:18:56.200
 w3c api的，然后读取为否

00:18:53.830 --> 00:18:57.850
更换抱歉，没有很多约会

00:18:56.200 --> 00:19:06.360
这些只是它们用于

00:18:57.850 --> 00:19:09.100
方便如何找到这些用法

00:19:06.360 --> 00:19:10.659
所以回到观众面前

00:19:09.100 --> 00:19:15.399
分钟是这里有多少人

00:19:10.659 --> 00:19:19.690
听说J DEP凳子好吧，也许我

00:19:15.399 --> 00:19:21.909
看到这里大概有10 10手

00:19:19.690 --> 00:19:24.309
深度凳子是一种工具，可让您

00:19:21.909 --> 00:19:27.549
对您的库进行静态分析

00:19:24.309 --> 00:19:28.659
和应用程序，以了解什么是眼睛

00:19:27.549 --> 00:19:31.600
实际被用来

00:19:28.659 --> 00:19:34.529
依赖关系是该工具在JDK H中

00:19:31.600 --> 00:19:36.909
我们将该工具作为

00:19:34.529 --> 00:19:39.039
准备迁移到的平台

00:19:36.909 --> 00:19:41.860
模块和强大的封装

00:19:39.039 --> 00:19:45.490
未来真的非常有用

00:19:41.860 --> 00:19:47.980
与一个称为地球的选择

00:19:45.490 --> 00:19:51.369
选项名为-jdk内部，我会

00:19:47.980 --> 00:19:53.289
在下一张幻灯片中有示例， 

00:19:51.369 --> 00:19:55.389
让您快速查看您是否

00:19:53.289 --> 00:19:57.639
对JDK有任何直接依赖

00:19:55.389 --> 00:20:00.639
内部API，您可以快速运行

00:19:57.639 --> 00:20:02.320
并将其指向您的jar文件或

00:20:00.639 --> 00:20:04.179
应用程序，它将告诉您是否

00:20:02.320 --> 00:20:07.299
在内部重新使用任何JDK 

00:20:04.179 --> 00:20:10.269
 P是C罗伯特·谢尔顿在

00:20:07.299 --> 00:20:12.610
那里写的行家的观众

00:20:10.269 --> 00:20:13.869
实际使用J技巧的插件

00:20:12.610 --> 00:20:16.360
您实际上可以将其合并到

00:20:13.869 --> 00:20:18.820
您的Maven项目，因此他们可以

00:20:16.360 --> 00:20:20.649
实际报告我的想法

00:20:18.820 --> 00:20:22.720
如果您使用的是JDK，将失败

00:20:20.649 --> 00:20:24.549
内部api，所以这非常非常

00:20:22.720 --> 00:20:27.490
有用，所以我将展示几个

00:20:24.549 --> 00:20:31.269
例子，我只是拿了四个

00:20:27.490 --> 00:20:33.999
首先启动一个GlassFish罐子

00:20:31.269 --> 00:20:36.940
文件，只是为了展示示例

00:20:33.999 --> 00:20:41.230
输出是当您运行J技巧时-JDK 

00:20:36.940 --> 00:20:45.759
内部结构您在这里看到的是

00:20:41.230 --> 00:20:48.549
打印一些Sun dot security 

00:20:45.759 --> 00:20:51.369
那是被眼睛所吸引的东西

00:20:48.549 --> 00:20:54.460
在此直接由代码引用

00:20:51.369 --> 00:20:56.019
安全罐文件，我想是什么

00:20:54.460 --> 00:20:58.889
发生在这里的是，有一个

00:20:56.019 --> 00:21:02.200
内部框架

00:20:58.889 --> 00:21:04.779
安全性安全库代码

00:21:02.200 --> 00:21:07.929
正在使用这里发生了什么

00:21:04.779 --> 00:21:10.240
指出那败类的儿子

00:21:07.929 --> 00:21:12.100
企业通信IOP安全性

00:21:10.240 --> 00:21:14.080
做某事

00:21:12.100 --> 00:21:16.600
直接参考Sun Security util 

00:21:14.080 --> 00:21:18.610
对象标识符，可能是

00:21:16.600 --> 00:21:21.279
极端的情况下可能正在使用

00:21:18.610 --> 00:21:23.230
为了方便使用，但它给您

00:21:21.279 --> 00:21:25.809
关于JDK内部化的想法

00:21:23.230 --> 00:21:29.169
输出会在

00:21:25.809 --> 00:21:32.259
最终是，JJ提示有一点

00:21:29.169 --> 00:21:35.710
旧的历史内部api的映射

00:21:32.259 --> 00:21:37.360
到新的受支持的内部API，因此在此

00:21:35.710 --> 00:21:39.820
如果你从头开始读的话

00:21:37.360 --> 00:21:42.850
幻灯片，它建议您更改

00:21:39.820 --> 00:21:46.899
引用某些安全性X 500 X 500 

00:21:42.850 --> 00:21:48.789
授予Java安全性X 500 X 500 

00:21:46.899 --> 00:21:50.950
主体，因为这是受支持的

00:21:48.789 --> 00:21:53.619
无论如何，API最主要的是

00:21:50.950 --> 00:21:55.179
这个非常快的youmu jdk年龄是

00:21:53.619 --> 00:21:57.669
能够仅运行此工具并查看

00:21:55.179 --> 00:22:01.659
您是否有任何依赖

00:21:57.669 --> 00:22:03.970
内部API，因此我们现在知道

00:22:01.659 --> 00:22:06.490
这只是这个玻璃器皿

00:22:03.970 --> 00:22:09.730
文件已在使用内部API 

00:22:06.490 --> 00:22:14.429
所以如果我跑那个会怎样

00:22:09.730 --> 00:22:17.999
 JDK 9的代码，我们将看到

00:22:14.429 --> 00:22:21.779
它实际上在错误的时间失败，并带有

00:22:17.999 --> 00:22:23.220
非法访问错误忽略细节

00:22:21.779 --> 00:22:24.960
错误的本质上是说

00:22:23.220 --> 00:22:26.490
在这个控制台上的一些代码

00:22:24.960 --> 00:22:29.429
企业安全性

00:22:26.490 --> 00:22:32.039
正在尝试访问一些安全性

00:22:29.429 --> 00:22:34.769
 Java基础模块中的提供者策略文件

00:22:32.039 --> 00:22:37.740
忽略我们谈到的Java基础

00:22:34.769 --> 00:22:40.350
以后在以后的谈话中，然后你

00:22:37.740 --> 00:22:43.259
查看堆栈跟踪，它本质上是

00:22:40.350 --> 00:22:44.639
告诉你这是它是这是一个

00:22:43.259 --> 00:22:46.529
警告也许是致命的

00:22:44.639 --> 00:22:49.350
今年你要用玻璃杯

00:22:46.529 --> 00:22:50.399
利用内部API的我说

00:22:49.350 --> 00:22:52.980
早些时候，你会得到一个

00:22:50.399 --> 00:22:54.809
来自JDK的JT案例的编译错误

00:22:52.980 --> 00:22:56.999
如果您尝试直接使用6个字

00:22:54.809 --> 00:22:58.679
内部API的数量，现在您有了

00:22:56.999 --> 00:23:01.799
运行时执行以及与此

00:22:58.679 --> 00:23:04.860
在编译时加强执行

00:23:01.799 --> 00:23:06.929
这使您对

00:23:04.860 --> 00:23:10.159
强大的封装和

00:23:06.929 --> 00:23:12.990
 JDK内部API的封装

00:23:10.159 --> 00:23:14.820
现在让我们来看看另一个

00:23:12.990 --> 00:23:16.139
例如，我使用的是稍旧的

00:23:14.820 --> 00:23:19.200
 Gradle 2的版本

00:23:16.139 --> 00:23:22.019
跟踪Gradle，我尝试运行

00:23:19.200 --> 00:23:24.509
我已经凯末尔编译的Java任务

00:23:22.019 --> 00:23:26.519
以红色突出显示这是失败的

00:23:24.509 --> 00:23:28.700
无法创造平静的实例

00:23:26.519 --> 00:23:33.450
一些工具Java C API 

00:23:28.700 --> 00:23:34.889
 Java C工具不是很大

00:23:33.450 --> 00:23:36.119
有大量的信息，但Gradle 

00:23:34.889 --> 00:23:39.119
实际上是非常好的，因为你可以

00:23:36.119 --> 00:23:40.799
你可以给它一个堆栈跟踪选项

00:23:39.119 --> 00:23:42.809
平地机命令为您提供更多

00:23:40.799 --> 00:23:44.549
信息，所以在这里失败

00:23:42.809 --> 00:23:46.080
如果我们使用堆栈跟踪

00:23:44.549 --> 00:23:48.450
选项，我们会得到更多

00:23:46.080 --> 00:23:52.529
我们在此获得堆栈跟踪的信息

00:23:48.450 --> 00:23:55.440
如果是合法访问例外

00:23:52.529 --> 00:23:56.759
你如果知道你的X如果你知道你的X 

00:23:55.440 --> 00:23:58.559
 Java中的错误和异常

00:23:56.759 --> 00:24:00.149
平台你知道静态

00:23:58.559 --> 00:24:02.519
参考因错误而失败

00:24:00.149 --> 00:24:04.169
等效的工作或反思是

00:24:02.519 --> 00:24:08.070
异常，因为核心反射确实

00:24:04.169 --> 00:24:11.249
与虚拟访问权限相同

00:24:08.070 --> 00:24:13.950
机器，所以在这里我们有一些核心

00:24:11.249 --> 00:24:15.539
在这个较旧的版本中使用反射

00:24:13.950 --> 00:24:18.509
试图制作的Gradle版本

00:24:15.539 --> 00:24:23.330
在Java C中使用不受支持的API 

00:24:18.509 --> 00:24:25.559
编译器在运行时失败，所以我

00:24:23.330 --> 00:24:27.810
意识到当你第一次看到这些

00:24:25.559 --> 00:24:30.600
时间是这些可怕的例外

00:24:27.810 --> 00:24:33.330
只是看起来吓人，但你不要惊慌

00:24:30.600 --> 00:24:35.970
之前关于结果说

00:24:33.330 --> 00:24:38.820
这将是一个解决方法，并且

00:24:35.970 --> 00:24:41.820
解决方法是从命令开始

00:24:38.820 --> 00:24:44.550
的线版本，所以四个

00:24:41.820 --> 00:24:46.140
回到GlassFish示例，我可以得到

00:24:44.550 --> 00:24:48.270
 GlassFish的现有版本

00:24:46.140 --> 00:24:50.610
通过给它一堆仍然运行

00:24:48.270 --> 00:24:52.440
告诉我们我的命令行选项

00:24:50.610 --> 00:24:54.540
想打破封装，真的

00:24:52.440 --> 00:24:57.390
真的可以使用这些api 

00:24:54.540 --> 00:24:59.970
框，我不能，我不能编译，我不能

00:24:57.390 --> 00:25:03.630
运行并利用这些内部api 

00:24:59.970 --> 00:25:05.910
而且我仍然可以获取现有代码

00:25:03.630 --> 00:25:08.280
通过此命令行选项工作

00:25:05.910 --> 00:25:11.340
解释这意味着什么的细节

00:25:08.280 --> 00:25:13.080
几分钟后，我不喜欢

00:25:11.340 --> 00:25:14.880
选择以G和

00:25:13.080 --> 00:25:17.220
就GlassFish而言， 

00:25:14.880 --> 00:25:19.380
其实已经是一个真正的问题

00:25:17.220 --> 00:25:21.120
跟踪此问题，以便此旧

00:25:19.380 --> 00:25:24.570
使用一些但安全的代码

00:25:21.120 --> 00:25:26.040
上课时间会固定，所以

00:25:24.570 --> 00:25:29.940
回到我刚刚显示的选项

00:25:26.040 --> 00:25:31.680
几分钟前的格式

00:25:29.940 --> 00:25:34.860
选项，然后是名称

00:25:31.680 --> 00:25:36.450
选项是--广告导出，因此

00:25:34.860 --> 00:25:38.700
其他事情，您可能会在

00:25:36.450 --> 00:25:42.930
今天的其他一些演讲或

00:25:38.700 --> 00:25:46.440
这周是我们开始添加

00:25:42.930 --> 00:25:49.320
 JDK 9中的新命令行选项

00:25:46.440 --> 00:25:51.570
是引号中的新样式，因此它们是

00:25:49.320 --> 00:25:53.730
 UNIX风格更加冗长， 

00:25:51.570 --> 00:25:55.920
独特的JDK样式选项

00:25:53.730 --> 00:25:58.710
我们过去曾经有过

00:25:55.920 --> 00:26:00.660
如果是--a-出口是因为和

00:25:58.710 --> 00:26:04.230
顺便说一下，所有新选项都是

00:26:00.660 --> 00:26:07.530
这种风格的价值

00:26:04.230 --> 00:26:11.220
选项是因为它包括三个部分

00:26:07.530 --> 00:26:14.250
源模块包，然后是什么

00:26:11.220 --> 00:26:17.040
目标模块是您是否愿意

00:26:14.250 --> 00:26:20.190
今天晚些时候的谈判

00:26:17.040 --> 00:26:22.970
您可以展示我们如何迁移的模块

00:26:20.190 --> 00:26:26.910
什么是整体平台

00:26:22.970 --> 00:26:28.470
核心模块所在的模块的漂亮图表

00:26:26.910 --> 00:26:30.960
该系统称为Java基础， 

00:26:28.470 --> 00:26:32.940
这就是我在这里指定的

00:26:30.960 --> 00:26:35.790
是模块的名称，然后

00:26:32.940 --> 00:26:37.680
内部API的软件包名称，即

00:26:35.790 --> 00:26:39.960
被使用，然后我要去谁

00:26:37.680 --> 00:26:41.080
允许忽略什么细节

00:26:39.960 --> 00:26:42.759
全部命名为

00:26:41.080 --> 00:26:44.860
如果您参加模块化讲座， 

00:26:42.759 --> 00:26:46.720
我们今天要去做

00:26:44.860 --> 00:26:48.369
明天和星期三，我们将

00:26:46.720 --> 00:26:50.080
多解释一下这是什么

00:26:48.369 --> 00:26:52.419
意味着实际上亚历克斯在幕后

00:26:50.080 --> 00:26:54.279
谈论并经历很多事情

00:26:52.419 --> 00:26:56.710
目前未命名模块的概念

00:26:54.279 --> 00:26:58.809
只是假设它意味着类路径在

00:26:56.710 --> 00:27:00.999
换句话说，我给我出口

00:26:58.809 --> 00:27:02.619
 Sun安全提供程序包，以便

00:27:00.999 --> 00:27:05.710
可以被类路径上的代码使用

00:27:02.619 --> 00:27:08.889
这是阅读此书的简单方法

00:27:05.710 --> 00:27:11.019
讨论命令行，我们也在

00:27:08.889 --> 00:27:15.340
抢先体验法案有办法做到这一点

00:27:11.019 --> 00:27:16.960
通过主应用程序和清单

00:27:15.340 --> 00:27:20.460
在主应用程序jar文件中

00:27:16.960 --> 00:27:22.809
您可以负责和

00:27:20.460 --> 00:27:26.710
利用这些内部api 

00:27:22.809 --> 00:27:30.149
在清单中明确声明

00:27:26.710 --> 00:27:32.200
就像我们在命令行选项中一样

00:27:30.149 --> 00:27:34.779
所以这就是我现在要说的

00:27:32.200 --> 00:27:36.100
关于封装内部API，所以我

00:27:34.779 --> 00:27:37.840
想继续前进并尝试度过难关

00:27:36.100 --> 00:27:46.809
其他一些事情很重要

00:27:37.840 --> 00:27:50.080
在jdk 9中更改对吧，所以我想要

00:27:46.809 --> 00:27:52.629
说说二进制结构

00:27:50.080 --> 00:27:54.700
我指的是JDK中的JRE中的JRE 

00:27:52.629 --> 00:27:56.919
结构我基本上是说

00:27:54.700 --> 00:27:57.759
在磁盘上布局的事实是，我们有一个

00:27:56.919 --> 00:27:59.769
 bin目录

00:27:57.759 --> 00:28:01.690
 RGH是您的工具，这些是

00:27:59.769 --> 00:28:03.999
你会在中看到的东西

00:28:01.690 --> 00:28:06.340
 JDK和JRE版本可以追溯到

00:28:03.999 --> 00:28:09.460
几年我们终于

00:28:06.340 --> 00:28:11.350
看看磁盘上的这种布局

00:28:09.460 --> 00:28:14.169
所以这实际上是

00:28:11.350 --> 00:28:16.210
我将谈论的一些工具

00:28:14.169 --> 00:28:19.029
在下一张幻灯片中

00:28:16.210 --> 00:28:23.109
最终重新审查的许多动机

00:28:19.029 --> 00:28:25.690
当我们移动时这些磁盘上的布局

00:28:23.109 --> 00:28:27.549
到模块化运行时，正在发生的是

00:28:25.690 --> 00:28:30.309
是我们将要完全模糊

00:28:27.549 --> 00:28:33.460
历史和区别

00:28:30.309 --> 00:28:37.029
 JRE和Gerry以及我们提供的工具

00:28:33.460 --> 00:28:39.700
称它为JDK，这是我们看到他的主题演讲

00:28:37.029 --> 00:28:42.039
创建了一个只有

00:28:39.700 --> 00:28:45.340
一个模块或少量模块

00:28:42.039 --> 00:28:48.480
这是另一个运行时

00:28:45.340 --> 00:28:50.830
现有的是长期存在的

00:28:48.480 --> 00:28:53.710
运行时映像布局不可用

00:28:50.830 --> 00:28:54.770
自己来做这种眨眼

00:28:53.710 --> 00:28:56.980
整个模块在一起

00:28:54.770 --> 00:29:00.620
并制作自己的一次性图像

00:28:56.980 --> 00:29:02.300
其他动机是像

00:29:00.620 --> 00:29:05.030
 zip格式，我们一直在使用zip 

00:29:02.300 --> 00:29:07.550
格式长期作为jar的基础

00:29:05.030 --> 00:29:10.610
长期以来，这不是一种有效的方法

00:29:07.550 --> 00:29:12.710
存储我们拥有的平台类

00:29:10.610 --> 00:29:14.540
有这么多不同的创业公司和其他

00:29:12.710 --> 00:29:16.670
与jar文件相关的性能问题

00:29:14.540 --> 00:29:17.929
在我们的TVR中，尤其是作为平台

00:29:16.670 --> 00:29:20.809
越来越大

00:29:17.929 --> 00:29:23.870
多年来，所以终于

00:29:20.809 --> 00:29:25.700
 20年的时间重新审视这种旧格式

00:29:23.870 --> 00:29:28.640
我们有很多有趣的事情

00:29:25.700 --> 00:29:32.720
可以围绕性能而做

00:29:28.640 --> 00:29:37.220
重新检查，所以所有这些

00:29:32.720 --> 00:29:40.520
我们进入39岁以下年龄段的变化

00:29:37.220 --> 00:29:42.740
早在2014年末

00:29:40.520 --> 00:29:47.480
换工具如此具有破坏性的改变

00:29:42.740 --> 00:29:48.980
用于id的编译器等

00:29:47.480 --> 00:29:50.720
我们介绍了一种受支持的方式

00:29:48.980 --> 00:29:52.550
这些工具才能访问

00:29:50.720 --> 00:29:55.340
图片的内容，所以这是

00:29:52.550 --> 00:29:57.260
第一次我们有支持者

00:29:55.340 --> 00:29:59.750
能够访问类文件的工具

00:29:57.260 --> 00:30:01.220
和资源，所以这很有用

00:29:59.750 --> 00:30:02.990
的工具已经迁移到

00:30:01.220 --> 00:30:05.210
特别是在早期使用

00:30:02.990 --> 00:30:08.330
访问表单中仍有一些工具

00:30:05.210 --> 00:30:11.120
还没到那儿

00:30:08.330 --> 00:30:13.970
看着它的旧历史格式

00:30:11.120 --> 00:30:16.880
这是JDK 8，您可以看到

00:30:13.970 --> 00:30:18.080
本质上是两个级别的目录

00:30:16.880 --> 00:30:19.550
顶层有垃圾箱

00:30:18.080 --> 00:30:22.010
您将在其中找到类似工具的目录

00:30:19.550 --> 00:30:24.590
 Java和Java C在其中

00:30:22.010 --> 00:30:26.330
运行时，还有一个Lib目录

00:30:24.590 --> 00:30:28.340
我们定义了您所使用的工具

00:30:26.330 --> 00:30:30.950
下降到您将实际达到的水平

00:30:28.340 --> 00:30:33.610
查找另一个带有副本的bin目录

00:30:30.950 --> 00:30:36.679
相同的工具和一个Lib目录

00:30:33.610 --> 00:30:38.720
您找到的地方会找到我们的

00:30:36.679 --> 00:30:41.600
 GTR和其他一堆jar文件

00:30:38.720 --> 00:30:43.130
那里还有其他的jar文件

00:30:41.600 --> 00:30:47.090
他们都有关于如何的历史吗

00:30:43.130 --> 00:30:49.580
他们应运而生

00:30:47.090 --> 00:30:50.780
开始挖掘您的Lib目录

00:30:49.580 --> 00:30:54.320
实际上会发现一大堆

00:30:50.780 --> 00:30:55.760
其他一些有趣的文件

00:30:54.320 --> 00:30:57.320
它们是受支持的配置，例如

00:30:55.760 --> 00:30:59.020
例如安全策略文件

00:30:57.320 --> 00:31:01.190
还有其他还有其他

00:30:59.020 --> 00:31:03.080
您不在的配置文件

00:31:01.190 --> 00:31:05.510
真的应该改变那些，因为

00:31:03.080 --> 00:31:06.630
如果您这样做，那么JDK将无法启动，或者

00:31:05.510 --> 00:31:09.300
行为不端等等

00:31:06.630 --> 00:31:11.550
关于什么我们从来就不清楚

00:31:09.300 --> 00:31:13.590
什么是什么配置

00:31:11.550 --> 00:31:16.740
打算如此编辑

00:31:13.590 --> 00:31:18.060
 vs vs vs配置

00:31:16.740 --> 00:31:20.760
不应真正对其进行编辑，因为

00:31:18.060 --> 00:31:22.980
会破坏东西，所以新格式

00:31:20.760 --> 00:31:24.900
正如我所说，我们再次在JDK 9中拥有

00:31:22.980 --> 00:31:28.500
自从一个AE以来

00:31:24.900 --> 00:31:31.080
 2014删除该目录的一级

00:31:28.500 --> 00:31:37.200
我们想到的非常非常简单

00:31:31.080 --> 00:31:39.660
作为一个只有三个有趣的

00:31:37.200 --> 00:31:41.190
 bin目录中的目录

00:31:39.660 --> 00:31:44.490
在找到Java启动之前

00:31:41.190 --> 00:31:45.990
或java java c RM ID其他

00:31:44.490 --> 00:31:48.990
您会在其中找到有趣的工具

00:31:45.990 --> 00:31:52.260
那里有一个kampf目录

00:31:48.990 --> 00:31:54.480
所有的配置

00:31:52.260 --> 00:31:55.620
拟编辑的内容已移至此

00:31:54.480 --> 00:31:56.940
在这里您可以找到安全性

00:31:55.620 --> 00:32:00.000
文件，这是您在其中找到的

00:31:56.940 --> 00:32:01.530
诸如要配置的属性之类的东西

00:32:00.000 --> 00:32:03.570
所有这些东西的管理代理

00:32:01.530 --> 00:32:06.780
您想要能够进行编辑的

00:32:03.570 --> 00:32:10.380
一处其他地方都在

00:32:06.780 --> 00:32:12.630
库目录的某种格式

00:32:10.380 --> 00:32:14.610
可能会随着时间的流逝而变化

00:32:12.630 --> 00:32:17.040
类文件的情况，这是

00:32:14.610 --> 00:32:19.170
在JDK中，我们将它们放入

00:32:17.040 --> 00:32:21.810
完全锁定了Mai的格式

00:32:19.170 --> 00:32:24.320
会随着时间而改变，但是非常

00:32:21.810 --> 00:32:26.730
对于JDK而言，在和

00:32:24.320 --> 00:32:29.580
启动和其他性能方面的事情

00:32:26.730 --> 00:32:31.980
我们想要进入的就是全部

00:32:29.580 --> 00:32:34.110
我现在就说一下运行时

00:32:31.980 --> 00:32:36.060
图片主要是暗示

00:32:34.110 --> 00:32:40.380
用于工具而不是大多数

00:32:36.060 --> 00:32:45.510
我提到的有关删除的应用程序

00:32:40.380 --> 00:32:48.660
一些不推荐使用的方法，所以这是六个

00:32:45.510 --> 00:32:50.880
支持的Java点星方法

00:32:48.660 --> 00:32:52.530
我们实际上可能是在删除您

00:32:50.880 --> 00:32:54.540
不认识这些人或大多数人

00:32:52.530 --> 00:32:57.060
不会认出他这些是

00:32:54.540 --> 00:32:58.830
自JDK 9的首次构建以来已删除

00:32:57.060 --> 00:33:01.410
而且我不知道任何错误报告

00:32:58.830 --> 00:33:03.810
这表明没有太多

00:33:01.410 --> 00:33:05.610
重复使用这些的人有

00:33:03.810 --> 00:33:07.860
自从年龄就被弃用，他们

00:33:05.610 --> 00:33:09.330
被标记为要删除，因此作为

00:33:07.860 --> 00:33:10.680
在我们调制的平台中

00:33:09.330 --> 00:33:14.100
在接下来的演讲中谈到了一点

00:33:10.680 --> 00:33:16.230
这些是最多的六个

00:33:14.100 --> 00:33:17.760
有问题的，必须在

00:33:16.230 --> 00:33:21.080
为了真正进入漂亮的模块

00:33:17.760 --> 00:33:21.080
我们在下一个谈话中显示的图形

00:33:21.990 --> 00:33:27.909
有一些扩展机制

00:33:24.730 --> 00:33:31.360
已被删除且标准被覆盖

00:33:27.909 --> 00:33:32.649
最初很少使用的机制

00:33:31.360 --> 00:33:34.149
适用于以下应用服务器

00:33:32.649 --> 00:33:36.610
更换和升级一些

00:33:34.149 --> 00:33:40.770
 JDK和

00:33:36.610 --> 00:33:43.210
扩展机制再次这个

00:33:40.770 --> 00:33:45.460
还没有被广泛使用

00:33:43.210 --> 00:33:47.080
一个错误的功能，但本质上是

00:33:45.460 --> 00:33:48.490
一种您实际上不会震撼的方式

00:33:47.080 --> 00:33:50.320
文件放入运行时映像并具有

00:33:48.490 --> 00:33:54.340
他们表示您在

00:33:50.320 --> 00:33:56.140
编译和运行时不要这样

00:33:54.340 --> 00:33:58.179
下一个可能不太有趣

00:33:56.140 --> 00:34:01.659
有点有趣，所以我想展示

00:33:58.179 --> 00:34:06.190
您在GSR中的类路径上找到一个jar文件

00:34:01.659 --> 00:34:09.040
三个或五个jar假定此jar文件

00:34:06.190 --> 00:34:11.550
在其中有几个注释

00:34:09.040 --> 00:34:15.639
包Java X点注释I 

00:34:11.550 --> 00:34:19.750
猜猜大多数人甚至可能

00:34:15.639 --> 00:34:22.419
认识到这些不是不可为空的

00:34:19.750 --> 00:34:27.639
常用于缺陷检测

00:34:22.419 --> 00:34:31.030
这些注释在应用程序中

00:34:27.639 --> 00:34:35.379
与所谓的普通包装相同

00:34:31.030 --> 00:34:39.040
注释GS为250 GS或250th 

00:34:35.379 --> 00:34:42.250
和定义的注释，所以现在你

00:34:39.040 --> 00:34:45.700
通过将jsr 305放在

00:34:42.250 --> 00:34:47.950
类路径中有一些注释

00:34:45.700 --> 00:34:49.929
属于其中的Java X批注

00:34:47.950 --> 00:34:51.669
另外一个API，它们在以下位置加载

00:34:49.929 --> 00:34:53.290
通过所谓的平台或

00:34:51.669 --> 00:34:57.760
过去扩展类加载器

00:34:53.290 --> 00:35:00.580
然后我得到这些其他

00:34:57.760 --> 00:35:01.720
非显着可为空等

00:35:00.580 --> 00:35:04.119
类加载的类路径

00:35:01.720 --> 00:35:05.740
应用程序类加载器，这是一个

00:35:04.119 --> 00:35:08.500
有点奇怪，我在这里得到的是

00:35:05.740 --> 00:35:09.910
拆分包装问题，我有一些

00:35:08.500 --> 00:35:14.530
一些类是平台的一部分

00:35:09.910 --> 00:35:16.540
有些在课堂上，这只是

00:35:14.530 --> 00:35:20.170
高度可靠的api之一

00:35:16.540 --> 00:35:23.380
有问题的交易API 

00:35:20.170 --> 00:35:26.680
另一个Java C定义了一个小

00:35:23.380 --> 00:35:28.869
交易API的子集的原因

00:35:26.680 --> 00:35:32.200
它确实是支持的一部分

00:35:28.869 --> 00:35:32.990
与korba Java进行的交易

00:35:32.200 --> 00:35:38.119
电子工程

00:35:32.990 --> 00:35:40.640
定义另一个完整的交易API 

00:35:38.119 --> 00:35:42.350
潜在的拆分包装问题

00:35:40.640 --> 00:35:44.630
当你开始真的走下坡路

00:35:42.350 --> 00:35:47.470
看着corba的核心厂商

00:35:44.630 --> 00:35:50.180
应用服务器通常会升级并

00:35:47.470 --> 00:35:55.220
叠加了对

00:35:50.180 --> 00:35:57.440
其他和OMG标准

00:35:55.220 --> 00:36:00.410
已提出，JDK 9中的内容

00:35:57.440 --> 00:36:02.360
一段时间以来，这些模块

00:36:00.410 --> 00:36:04.250
与Java EE共享

00:36:02.360 --> 00:36:05.840
所有这里所有这些有问题的

00:36:04.250 --> 00:36:08.510
包就是一切

00:36:05.840 --> 00:36:11.570
通常是通过Java EE升级的

00:36:08.510 --> 00:36:13.250
默认情况下没有解决，我们还没有

00:36:11.570 --> 00:36:15.260
谈论模块和分辨率或

00:36:13.250 --> 00:36:18.290
我刚才讲这些时的一切

00:36:15.260 --> 00:36:21.200
模块不只是解决

00:36:18.290 --> 00:36:23.600
假设交易中的类型

00:36:21.200 --> 00:36:25.700
我所拥有的其他六个API中的任何一个

00:36:23.600 --> 00:36:26.420
在这里列出，它们不可见

00:36:25.700 --> 00:36:29.540
默认

00:36:26.420 --> 00:36:32.600
看起来好像那些类型没有

00:36:29.540 --> 00:36:34.070
存在，你会得到一个创始人创建的

00:36:32.600 --> 00:36:38.990
您尝试运行利用以下代码

00:36:34.070 --> 00:36:40.970
我们已经在喷气飞机260 a中记录了它们

00:36:38.990 --> 00:36:44.150
写出这样做的理由

00:36:40.970 --> 00:36:45.950
我会读一号以避免

00:36:44.150 --> 00:36:47.840
不必要的流行冲突

00:36:45.950 --> 00:36:49.970
在某些类型中定义类型的库

00:36:47.840 --> 00:36:52.460
就像我们在

00:36:49.970 --> 00:36:54.440
上一张幻灯片和第二张

00:36:52.460 --> 00:36:57.410
现有应用程序更容易

00:36:54.440 --> 00:36:59.300
服务器迁移到JDK 9应用程序

00:36:57.410 --> 00:37:01.040
服务器通常会覆盖

00:36:59.300 --> 00:37:03.109
这些模块中的一个或多个

00:37:01.040 --> 00:37:04.340
他们很可能在短期内这样做

00:37:03.109 --> 00:37:08.000
继续放置必要的

00:37:04.340 --> 00:37:09.920
类路径上的非模块化jar 

00:37:08.000 --> 00:37:12.230
这是如果您正在使用其中任何一个

00:37:09.920 --> 00:37:13.310
这里有六个，而你没有

00:37:12.230 --> 00:37:14.480
知道模块名称，因为我们还没有

00:37:13.310 --> 00:37:17.570
向他们展示了我们何时会

00:37:14.480 --> 00:37:19.460
其他讲座是我们组织了这些

00:37:17.570 --> 00:37:22.190
这些与之重叠的模块

00:37:19.460 --> 00:37:23.330
将Java EE分为六个模块Java核心

00:37:22.190 --> 00:37:26.540
您有交易Java 

00:37:23.330 --> 00:37:31.040
批注常用作业激活Java X 

00:37:26.540 --> 00:37:34.460
是我们用于Web服务的java xml ws 

00:37:31.040 --> 00:37:38.390
在java xml bind中进行绑定

00:37:34.460 --> 00:37:41.150
 api再次让我们在这里不惊慌，因为

00:37:38.390 --> 00:37:43.100
我们一直在思考，什么

00:37:41.150 --> 00:37:45.220
您必须保留现有选项

00:37:43.100 --> 00:37:48.050
世界走向

00:37:45.220 --> 00:37:50.870
在命令行上，如果

00:37:48.050 --> 00:37:52.640
我正在使用CORBA，我可以继续

00:37:50.870 --> 00:37:55.700
将继续像以前一样工作

00:37:52.640 --> 00:37:58.880
在JDK 9中，只需使用此选项

00:37:55.700 --> 00:38:00.320
称为添加模块添加模块Alex只是

00:37:58.880 --> 00:38:03.020
指出我这里有错字

00:38:00.320 --> 00:38:05.660
这应该是多个模块，所以添加

00:38:03.020 --> 00:38:07.550
 Java Corba模块的作用是什么

00:38:05.660 --> 00:38:09.080
本质上将该模块添加到集合中

00:38:07.550 --> 00:38:11.120
应解决的模块数量

00:38:09.080 --> 00:38:12.560
使用珊瑚的现有代码的开始

00:38:11.120 --> 00:38:17.150
将继续使用此选项

00:38:12.560 --> 00:38:20.150
对于App服务器来说并不是最

00:38:17.150 --> 00:38:23.150
应用程序，可以部署

00:38:20.150 --> 00:38:25.880
 CORBA的升级版作为模块

00:38:23.150 --> 00:38:28.130
而您只使用此升级模块

00:38:25.880 --> 00:38:30.200
这就像模块的路径

00:38:28.130 --> 00:38:31.760
等同于认可的替代

00:38:30.200 --> 00:38:33.650
我提到的机制

00:38:31.760 --> 00:38:36.080
早些时候只对

00:38:33.650 --> 00:38:38.990
应用服务器，这也是可能的

00:38:36.080 --> 00:38:40.760
因为有这些

00:38:38.990 --> 00:38:42.080
默认情况下，模块不解析

00:38:40.760 --> 00:38:43.490
实际上可以把它扔在

00:38:42.080 --> 00:38:45.890
 classpath没有拆分包

00:38:43.490 --> 00:38:51.020
问题，所以有两种可能

00:38:45.890 --> 00:38:53.300
此类问题的解决方法

00:38:51.020 --> 00:38:56.270
如果您直接使用这些

00:38:53.300 --> 00:38:59.120
 api的最后一句话就是说

00:38:56.270 --> 00:39:01.670
这是不解决的政策

00:38:59.120 --> 00:39:03.440
 e模块默认情况下非常

00:39:01.670 --> 00:39:05.930
我们所依赖的东西

00:39:03.440 --> 00:39:08.150
的反馈，因此我们需要查看

00:39:05.930 --> 00:39:10.370
接下来的几个月，以及您是否

00:39:08.150 --> 00:39:12.290
这种变化是否

00:39:10.370 --> 00:39:14.480
是否具有破坏性

00:39:12.290 --> 00:39:17.120
模块应该只是我们将实际上

00:39:14.480 --> 00:39:18.710
看到这是在JDK 9 

00:39:17.120 --> 00:39:20.960
有一段时间很少

00:39:18.710 --> 00:39:23.180
反馈给我们的可能性

00:39:20.960 --> 00:39:27.260
没有太多人利用这些

00:39:23.180 --> 00:39:28.820
 api或尝试一些可以的方法

00:39:27.260 --> 00:39:31.070
其他事物感兴趣

00:39:28.820 --> 00:39:33.350
我不会花在JDK 9中的更改

00:39:31.070 --> 00:39:35.090
今天是他们的时间是应用程序

00:39:33.350 --> 00:39:37.700
扩展类加载器

00:39:35.090 --> 00:39:40.580
重命名为平台类加载器否

00:39:37.700 --> 00:39:42.620
 URL类加载器的更长实例

00:39:40.580 --> 00:39:44.870
我们有几个案例

00:39:42.620 --> 00:39:46.040
现有的库代码已经

00:39:44.870 --> 00:39:48.080
假设

00:39:46.040 --> 00:39:50.900
应用程序类加载器是一个实例

00:39:48.080 --> 00:39:53.090
这种类型，盲目地投掷到

00:39:50.900 --> 00:39:54.950
类型，然后当然是因为

00:39:53.090 --> 00:39:55.830
在JDK 9中完全改变，他们得到了

00:39:54.950 --> 00:39:57.870
 Castex类

00:39:55.830 --> 00:40:00.330
在我们的日常活动中采取更多细节

00:39:57.870 --> 00:40:02.190
对象261上有几个

00:40:00.330 --> 00:40:04.890
选项被删除，如

00:40:02.190 --> 00:40:06.960
超越或前置于

00:40:04.890 --> 00:40:08.730
蓝班路径的原因是

00:40:06.960 --> 00:40:11.310
我们真正知道的蓝色阶级之路

00:40:08.730 --> 00:40:14.550
在JDK 9中不存在，并且全部

00:40:11.310 --> 00:40:16.650
转移到模块和

00:40:14.550 --> 00:40:20.550
与之相关的系统属性

00:40:16.650 --> 00:40:21.630
我也想被删除

00:40:20.550 --> 00:40:27.680
很快经历另外两个

00:40:21.630 --> 00:40:32.820
事物和版本双向双向码流芯片

00:40:27.680 --> 00:40:34.530
 223令人惊讶的是，这可能是

00:40:32.820 --> 00:40:39.270
我们拥有的最具破坏性的变化

00:40:34.530 --> 00:40:41.360
到目前为止，JDK 9和JDK 9 

00:40:39.270 --> 00:40:44.640
历史上，版本控制方案是

00:40:41.360 --> 00:40:49.050
令人困惑，因为我从吉卜赛读过

00:40:44.640 --> 00:40:51.720
这又是它的芯片

00:40:49.050 --> 00:40:53.970
动机有一些写作

00:40:51.720 --> 00:40:57.660
版本包含所有最新的

00:40:53.970 --> 00:41:03.750
安全修复程序是JDK 7更新55 

00:40:57.660 --> 00:41:06.480
 JDK 7更新60看起来像JDK 7 

00:41:03.750 --> 00:41:09.630
更新60比5晚发行

00:41:06.480 --> 00:41:13.950
更新55，因此它必须包括

00:41:09.630 --> 00:41:16.650
更多的安全修复程序可以计算出

00:41:13.950 --> 00:41:18.810
结论是错误的，这两个

00:41:16.650 --> 00:41:21.140
版本包含完全相同

00:41:18.810 --> 00:41:23.400
安全发布安全修复程序

00:41:21.140 --> 00:41:24.420
基于先前版本的安全版本

00:41:23.400 --> 00:41:27.480
次要版本是奇数

00:41:24.420 --> 00:41:30.890
在必要时将5 r增加6 

00:41:27.480 --> 00:41:37.950
为了使更新数量保持奇数

00:41:30.890 --> 00:41:40.530
总是令人困惑，这是

00:41:37.950 --> 00:41:42.720
建议的新版本字符串格式

00:41:40.530 --> 00:41:47.730
您将在Jeff中找到所有详细信息，以

00:41:42.720 --> 00:41:50.190
 2023年总结的简单方法

00:41:47.730 --> 00:41:54.200
幻灯片是20年后

00:41:50.190 --> 00:41:54.200
我们终于放弃了领先者

00:42:00.520 --> 00:42:07.730
更改版本和方案有一个

00:42:04.340 --> 00:42:09.920
对系统属性的影响，这是

00:42:07.730 --> 00:42:11.540
在相当破坏性的地方

00:42:09.920 --> 00:42:13.609
更改那里有很多代码

00:42:11.540 --> 00:42:17.420
读取Javadoc版本属性

00:42:13.609 --> 00:42:20.359
并解析它，所以这件事只是

00:42:17.420 --> 00:42:22.359
要记住是否有任何代码

00:42:20.359 --> 00:42:24.950
取决于版本，请参见

00:42:22.359 --> 00:42:27.340
我今天没有经历过的

00:42:24.950 --> 00:42:30.980
在此幻灯片中，有一个新的API 

00:42:27.340 --> 00:42:32.330
更喜欢Java C 9，它被称为

00:42:30.980 --> 00:42:34.580
您实际上可以运行的点版本

00:42:32.330 --> 00:42:37.730
调用一次该版本并返回

00:42:34.580 --> 00:42:40.910
您使用的M版本对象

00:42:37.730 --> 00:42:43.220
反思主要未成年人和其他

00:42:40.910 --> 00:42:47.720
关于版本的事情

00:42:43.220 --> 00:42:49.730
数字非常非常有用，所以我一直

00:42:47.720 --> 00:42:51.590
谈论我只是破坏性的事情

00:42:49.730 --> 00:42:53.599
想花一些时间在

00:42:51.590 --> 00:42:56.540
我认为很荣幸的功能

00:42:53.599 --> 00:42:59.599
有趣，当你开始寻找

00:42:56.540 --> 00:43:04.910
从8迁移到9 

00:42:59.599 --> 00:43:08.510
 DS在238和247中有描述

00:43:04.910 --> 00:43:13.880
 238是多重释放罐子248是

00:43:08.510 --> 00:43:16.820
针对较旧的平台版本进行了编译，因此

00:43:13.880 --> 00:43:20.000
因为考虑这种情况我

00:43:16.820 --> 00:43:23.869
利用内部api，但是

00:43:20.000 --> 00:43:25.609
 Java c 9中提供了受支持的API，因此

00:43:23.869 --> 00:43:27.160
也许您正在利用我们的

00:43:25.609 --> 00:43:29.690
处理，所以您不必利用

00:43:27.160 --> 00:43:32.660
一些较低级别的api可能是

00:43:29.690 --> 00:43:35.510
利用旧的内部

00:43:32.660 --> 00:43:39.470
 XML API用于序列化程序或目录， 

00:43:35.510 --> 00:43:41.750
还有一个新的目录API和9 

00:43:39.470 --> 00:43:43.369
应用程序很好，我真的很想工作

00:43:41.750 --> 00:43:47.240
在需要将其构建时

00:43:43.369 --> 00:43:48.290
放松，然后在9岁或9岁时跑步，这是

00:43:47.240 --> 00:43:50.359
常见的情况，特别是

00:43:48.290 --> 00:43:54.320
特别是当你在谈论

00:43:50.359 --> 00:43:56.780
关于2016年和JDK 9是不是

00:43:54.320 --> 00:43:58.480
即将发布到2017年，所以我需要

00:43:56.780 --> 00:44:02.750
能够做到这种情况

00:43:58.480 --> 00:44:06.920
因此，JDK 9和

00:44:02.750 --> 00:44:09.650
是多版本jar，jar格式有

00:44:06.920 --> 00:44:12.260
扩展以允许多个工作

00:44:09.650 --> 00:44:14.240
发布特定的类文件以共存

00:44:12.260 --> 00:44:15.290
在同一档案中，我不会

00:44:14.240 --> 00:44:17.330
花大量时间在

00:44:15.290 --> 00:44:20.750
今天的子弹，但它看起来

00:44:17.330 --> 00:44:24.320
 ，这是非常非常有用的功能

00:44:20.750 --> 00:44:29.480
如果一个多发行版jar文件中包含

00:44:24.320 --> 00:44:32.780
在其表现形式中，自然美人

00:44:29.480 --> 00:44:36.590
多次发布，其值为true 

00:44:32.780 --> 00:44:39.590
这是一个布尔值，然后有一个部分

00:44:36.590 --> 00:44:43.490
 meta INF版本/比版本

00:44:39.590 --> 00:44:46.730
在这种情况下，数字是九

00:44:43.490 --> 00:44:50.090
并且该部分中的资源可以

00:44:46.730 --> 00:44:52.370
覆盖顶层或底层的内容

00:44:50.090 --> 00:44:55.490
因此，如果我们要研究这个

00:44:52.370 --> 00:44:58.490
例如，我们可以看到我们已经到了那里

00:44:55.490 --> 00:45:00.560
帮助生产这个jar文件中的类

00:44:58.490 --> 00:45:03.260
在顶部，我们有漫画

00:45:00.560 --> 00:45:06.050
 neistat的内部帮手课程

00:45:03.260 --> 00:45:08.690
在meta-inf版本9中

00:45:06.050 --> 00:45:11.510
还有一个平静的痤疮统计数据

00:45:08.690 --> 00:45:15.470
运行时的内部帮助程序类

00:45:11.510 --> 00:45:17.720
在线底部的将在以下情况下使用

00:45:15.470 --> 00:45:20.530
你在顶部跑了一个八

00:45:17.720 --> 00:45:23.900
我们的基础部分将被使用

00:45:20.530 --> 00:45:25.610
在这个例子中，我将像

00:45:23.900 --> 00:45:27.860
目前主要的应用程序罐

00:45:25.610 --> 00:45:30.290
当我八点跑步时，我们可以看到

00:45:27.860 --> 00:45:31.850
镇静痤疮统计信息内部助手已加载

00:45:30.290 --> 00:45:34.820
从顶部开始我们的基础部分

00:45:31.850 --> 00:45:38.540
在线从meta-inf服务加载

00:45:34.820 --> 00:45:40.190
 INF版本，这非常有用

00:45:38.540 --> 00:45:43.400
当您尝试进行此迁移时

00:45:40.190 --> 00:45:47.240
从内部api到支持

00:45:43.400 --> 00:45:48.730
 api刚开始时

00:45:47.240 --> 00:45:51.290
想着哦，现在我必须要

00:45:48.730 --> 00:45:53.720
 jdk年龄和我构建中的jdk九

00:45:51.290 --> 00:45:55.460
为了做到这一点我想要的环境

00:45:53.720 --> 00:45:58.220
互相认识

00:45:55.460 --> 00:46:00.500
更改我们在jdk 9中的第三个功能

00:45:58.220 --> 00:46:02.540
是赋予编译器以

00:46:00.500 --> 00:46:06.190
针对我们一直以来的旧版本

00:46:02.540 --> 00:46:08.870
能够做Java C-源于目标

00:46:06.190 --> 00:46:11.470
七个或八个然后启动

00:46:08.870 --> 00:46:11.470
课堂路径

00:46:12.550 --> 00:46:16.550
好的，那意味着我必须再有一个

00:46:14.600 --> 00:46:17.930
我的系统上有JDK（如果我八岁） 

00:46:16.550 --> 00:46:19.640
要瞄准七个目标

00:46:17.930 --> 00:46:21.110
妈妈我要去玉门大厦

00:46:19.640 --> 00:46:22.670
我的目标是七个

00:46:21.110 --> 00:46:25.040
确保编译是

00:46:22.670 --> 00:46:29.240
我可以一口气做到这一点

00:46:25.040 --> 00:46:32.090
在JDK 9中可以使用Java C-- 

00:46:29.240 --> 00:46:34.640
释放我的目标版本

00:46:32.090 --> 00:46:36.470
相当于他们的来源- 

00:46:34.640 --> 00:46:38.690
仅以该新类路径为目标

00:46:36.470 --> 00:46:40.550
系统上只有一个JDK，所以这是

00:46:38.690 --> 00:46:43.040
我的JDK 9真的很棒

00:46:40.550 --> 00:46:46.400
我可以编译为六个的构建环境

00:46:43.040 --> 00:46:48.320
七八九而无

00:46:46.400 --> 00:46:50.870
我系统上的多个J衰变

00:46:48.320 --> 00:46:53.030
编译的多版本jar提供了

00:46:50.870 --> 00:46:55.460
远离现实的好方法

00:46:53.030 --> 00:46:59.660
内部api和构建应用程序

00:46:55.460 --> 00:47:01.790
在不同版本的

00:46:59.660 --> 00:47:03.740
平台相信有一个话题

00:47:01.790 --> 00:47:06.410
明天在Maven上-这将继续

00:47:03.740 --> 00:47:10.100
对这些的一些支持

00:47:06.410 --> 00:47:13.190
功能，所以我想开始包装

00:47:10.100 --> 00:47:17.900
起，所以有几件事要开始

00:47:13.190 --> 00:47:19.760
考虑为jdk 9移动

00:47:17.900 --> 00:47:22.010
我拥有的最重要的东西

00:47:19.760 --> 00:47:25.010
今天在这张幻灯片中显示的是J 

00:47:22.010 --> 00:47:27.260
提示工具很少有人提出

00:47:25.010 --> 00:47:28.850
当我较早地对观众进行投票时

00:47:27.260 --> 00:47:30.680
所以那里没有很大

00:47:28.850 --> 00:47:32.840
意识到这个工具要做一个

00:47:30.680 --> 00:47:34.520
对您的库进行静态分析

00:47:32.840 --> 00:47:36.740
应用程序真的非常好

00:47:34.520 --> 00:47:39.740
快速识别您是否正在使用的工具

00:47:36.740 --> 00:47:42.830
使用和任何JDK内部API一样

00:47:39.740 --> 00:47:45.500
这是要注意的一件事

00:47:42.830 --> 00:47:47.570
正如我所说，版本变更非常重要

00:47:45.500 --> 00:47:50.750
破坏性很多开源代码都有

00:47:47.570 --> 00:47:53.720
在过去一直在追赶

00:47:50.750 --> 00:47:56.060
六个月至九个月我毫无疑问

00:47:53.720 --> 00:47:58.040
还有大量其他代码

00:47:56.060 --> 00:47:59.960
在应用程序中解析

00:47:58.040 --> 00:48:01.190
 Java点版本的值，不是

00:47:59.960 --> 00:48:03.580
九点就能得到正确答案

00:48:01.190 --> 00:48:06.110
所以这是要检查的东西

00:48:03.580 --> 00:48:08.900
主要用于工具，但也许您已经

00:48:06.110 --> 00:48:12.800
这已经是我们已经有一个

00:48:08.900 --> 00:48:15.170
许多代码假设

00:48:12.800 --> 00:48:17.240
 RTR它开始在以下位置查找jar文件

00:48:15.170 --> 00:48:20.650
 JDK Lib目录或Jerry Lib 

00:48:17.240 --> 00:48:22.869
目录，因为它需要查找

00:48:20.650 --> 00:48:27.220
就像我说的，一切都改变了

00:48:22.869 --> 00:48:29.950
因为这是JDK 9中的新布局

00:48:27.220 --> 00:48:31.119
要注意的是一些

00:48:29.950 --> 00:48:33.309
人们确实举起了手

00:48:31.119 --> 00:48:36.520
开始有每周JDK 9 

00:48:33.309 --> 00:48:39.849
提早使用账单，以便我们

00:48:36.520 --> 00:48:42.579
在模块上工作，我们也做拼图

00:48:39.849 --> 00:48:44.470
定期进行早期访问

00:48:42.579 --> 00:48:47.680
而且总是很早就可以进入

00:48:44.470 --> 00:48:48.819
账单下载并尝试一下，我指出

00:48:47.680 --> 00:48:50.230
列出了一些有帮助的东西

00:48:48.819 --> 00:48:51.670
随着迁移的多版本

00:48:50.230 --> 00:48:56.799
罐子并编译到旧版本

00:48:51.670 --> 00:48:59.289
这也值得一试

00:48:56.799 --> 00:49:03.160
信息，所以我们正在努力

00:48:59.289 --> 00:49:06.069
模块系统，模块和

00:49:03.160 --> 00:49:08.380
适用于JT t 9的模块化JDK 

00:49:06.069 --> 00:49:10.420
在项目Jigsaw下的开放JDK中完成

00:49:08.380 --> 00:49:13.420
有到项目页面的链接

00:49:10.420 --> 00:49:16.240
和邮件列表抢先体验账单

00:49:13.420 --> 00:49:20.980
对于JDK 9或抢先体验下载是

00:49:16.240 --> 00:49:22.720
那里的Jade EPS工具有自己的Wiki 

00:49:20.980 --> 00:49:25.690
钟欣欣（Amanda Chung） 

00:49:22.720 --> 00:49:28.390
维护那是一个有用的页面

00:49:25.690 --> 00:49:31.750
能够查看内部API的快速列表

00:49:28.390 --> 00:49:34.299
是与支持的ap是

00:49:31.750 --> 00:49:36.910
使用的更好的API ste也包括在内

00:49:34.299 --> 00:49:40.470
与我的JYP的一些链接

00:49:36.910 --> 00:49:43.089
谈到即将结束的EM 

00:49:40.470 --> 00:49:45.460
会议，我将回到本幻灯片

00:49:43.089 --> 00:49:46.839
几分钟，但只是做广告

00:49:45.460 --> 00:49:48.609
我们实际上正在参加的其他会议

00:49:46.839 --> 00:49:50.559
我在这里说这是第一个

00:49:48.609 --> 00:49:52.720
我们正在做五个会议，Alex和

00:49:50.559 --> 00:49:54.910
我没有先生了

00:49:52.720 --> 00:49:56.440
我回到这里2:30关于介绍

00:49:54.910 --> 00:49:58.029
我们两个人回到这里

00:49:56.440 --> 00:50:01.539
下午晚些时候做高级

00:49:58.029 --> 00:50:04.869
亚历克斯然后有项目在对不起

00:50:01.539 --> 00:50:08.380
引擎盖下的服务和项目

00:50:04.869 --> 00:50:10.270
明天，然后我们重复

00:50:08.380 --> 00:50:12.460
这些会议实际上是重复的

00:50:10.270 --> 00:50:15.970
在星期三也有黑客会议

00:50:12.460 --> 00:50:17.500
早上第一件事，我想

00:50:15.970 --> 00:50:19.559
他们几乎全都是这个房间

00:50:17.500 --> 00:50:22.930
隔壁

00:50:19.559 --> 00:50:24.760
回到链接，我认为我们

00:50:22.930 --> 00:50:27.819
完成，我们只有几分钟的时间

00:50:24.760 --> 00:50:30.700
问题，但如果你想问一些

00:50:27.819 --> 00:50:32.109
问题，请继续，我们可能不得不

00:50:30.700 --> 00:50:35.130
之后带一些外面的问题

00:50:32.109 --> 00:50:35.130
如果我们没时间了

00:50:51.980 --> 00:50:55.119
你必须大喊

00:51:20.900 --> 00:51:24.329
好吧，我没有完全抓住所有

00:51:23.160 --> 00:51:26.280
问题，但我认为你说的是

00:51:24.329 --> 00:51:27.630
这是一些图书馆

00:51:26.280 --> 00:51:30.599
有九个问题，因为

00:51:27.630 --> 00:51:34.290
他们正在内部使用api，所以

00:51:30.599 --> 00:51:36.060
我只能说直到他们迁移

00:51:34.290 --> 00:51:37.319
远离那些API，我们有一些方法

00:51:36.060 --> 00:51:39.510
通过命令行减轻它

00:51:37.319 --> 00:51:41.040
我表明的选择是

00:51:39.510 --> 00:51:43.339
真的，我们在

00:51:41.040 --> 00:51:43.339
时刻

00:51:57.839 --> 00:52:02.400
对，所以问题在于

00:52:00.089 --> 00:52:06.269
释放罐是否暗示多个

00:52:02.400 --> 00:52:07.739
我认为是源代码树

00:52:06.269 --> 00:52:10.289
那就是那真的

00:52:07.739 --> 00:52:11.999
好问题，所以多发行

00:52:10.289 --> 00:52:14.789
 jar功能未规定来源

00:52:11.999 --> 00:52:16.349
您将拥有的布局

00:52:14.789 --> 00:52:20.670
有某种方式可以支持

00:52:16.349 --> 00:52:22.439
抱歉罗伯特是这个东西

00:52:20.670 --> 00:52:23.849
你要谈论好吧

00:52:22.439 --> 00:52:26.489
坐在罗伯特·舒尔特旁边

00:52:23.849 --> 00:52:28.319
他们的线索专家和人们给我的

00:52:26.489 --> 00:52:37.289
明天演讲，我想我们会

00:52:28.319 --> 00:52:43.789
掩盖这个，每个人都准备好了

00:52:37.289 --> 00:52:43.789
很好，很好，谢谢

