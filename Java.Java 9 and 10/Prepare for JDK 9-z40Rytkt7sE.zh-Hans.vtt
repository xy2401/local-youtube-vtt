WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.480 --> 00:00:08.769
欢迎使用JDK 9，我叫Alan Bateman 

00:00:06.850 --> 00:00:12.970
我在Java平台小组工作

00:00:08.769 --> 00:00:16.449
 Oracle是JDK的长期贡献者

00:00:12.970 --> 00:00:17.980
本次会议是为JDK 9 um准备的，因此

00:00:16.449 --> 00:00:20.109
我将从快速民意调查开始

00:00:17.980 --> 00:00:23.400
观众只是看有多少

00:00:20.109 --> 00:00:26.829
人们已经下载并尝试JDK 9 

00:00:23.400 --> 00:00:28.419
好吧，大概有三分之一的人

00:00:26.829 --> 00:00:30.550
对于那些举手的人

00:00:28.419 --> 00:00:31.779
很多人尝试了他们的应用程序

00:00:30.550 --> 00:00:38.080
或图书馆，一切正常

00:00:31.779 --> 00:00:40.000
完全没有太多的手多少

00:00:38.080 --> 00:00:42.010
举起手的人

00:00:40.000 --> 00:00:42.880
分钟前尝试了我们，但我们脾气暴躁

00:00:42.010 --> 00:00:46.750
在一天的剩余时间内，因为

00:00:42.880 --> 00:00:50.680
东西摔坏了

00:00:46.750 --> 00:00:53.200
你在正确的会议上，这是

00:00:50.680 --> 00:00:56.530
 JDK 9中的功能列表

00:00:53.200 --> 00:00:58.870
是所有列表的屏幕截图

00:00:56.530 --> 00:01:02.950
 jep的jdk增强了建议

00:00:58.870 --> 00:01:05.560
您会在开放的JDK mjd犬上找到

00:01:02.950 --> 00:01:08.319
项目页面这个很大的清单

00:01:05.560 --> 00:01:09.850
此会话的功能并非全部

00:01:08.319 --> 00:01:11.530
这些功能中，我将介绍几个

00:01:09.850 --> 00:01:12.909
的功能，但我不会

00:01:11.530 --> 00:01:15.460
详尽地经历所有这些

00:01:12.909 --> 00:01:17.229
功能，我将主要是

00:01:15.460 --> 00:01:19.869
谈论您可能遇到的问题

00:01:17.229 --> 00:01:22.170
遇到，当你开始准备

00:01:19.869 --> 00:01:24.700
并考虑迁移到JDK 9 

00:01:22.170 --> 00:01:28.689
有很多破坏性的变化

00:01:24.700 --> 00:01:31.689
 JDK 9我的同事Alex Buckley um写道

00:01:28.689 --> 00:01:35.009
 Java Java 9本书的序言

00:01:31.689 --> 00:01:39.909
模块化，在序言中，他

00:01:35.009 --> 00:01:41.649
将JDK 9中的更改比作一点

00:01:39.909 --> 00:01:44.200
像桌布的把戏

00:01:41.649 --> 00:01:46.389
我们有杯子和盘子堆放在

00:01:44.200 --> 00:01:48.819
桌子，你把桌布拉出来

00:01:46.389 --> 00:01:52.529
从不破坏盘子和

00:01:48.819 --> 00:01:52.529
杯，但反向

00:01:53.830 --> 00:01:59.390
有一些非常深刻的变化

00:01:56.720 --> 00:02:02.060
已经进入JDK 9 

00:01:59.390 --> 00:02:04.880
挑战是做桌布的把戏

00:02:02.060 --> 00:02:06.800
在倒车时不打乱杯子

00:02:04.880 --> 00:02:10.039
板和重型电动工具

00:02:06.800 --> 00:02:13.640
累积在桌子上

00:02:10.039 --> 00:02:15.350
最近20年，有几对

00:02:13.640 --> 00:02:18.950
很小的破损，那是最重要的

00:02:15.350 --> 00:02:21.380
我今天想谈的事情

00:02:18.950 --> 00:02:23.480
本次会议实际上是

00:02:21.380 --> 00:02:26.000
我们有五个会议

00:02:23.480 --> 00:02:28.390
模块化跟踪

00:02:26.000 --> 00:02:30.860
在轨道上谈论那些

00:02:28.390 --> 00:02:34.160
稍后在这个

00:02:30.860 --> 00:02:36.200
会议，所以在我们进入

00:02:34.160 --> 00:02:38.300
一些我只想谈的细节

00:02:36.200 --> 00:02:41.269
只是一般的兼容性

00:02:38.300 --> 00:02:44.600
政策以及应用程序或

00:02:41.269 --> 00:02:47.000
库使用受支持的api和Works 

00:02:44.600 --> 00:02:49.489
在发布时，它应该在

00:02:47.000 --> 00:02:52.970
即使没有也可以释放一加

00:02:49.489 --> 00:02:56.510
重新编译支持的api可以是

00:02:52.970 --> 00:02:59.150
已删除，但仅在事先通知的情况下如此

00:02:56.510 --> 00:03:01.820
让我们看看我们如何在jdk 9上相对于

00:02:59.150 --> 00:03:05.269
此政策兼容性政策

00:03:01.820 --> 00:03:08.720
已经存在了几年，我会

00:03:05.269 --> 00:03:12.440
从好消息开始

00:03:08.720 --> 00:03:15.829
尚未更改类加载尚未

00:03:12.440 --> 00:03:18.290
改变了你没有被迫迁移

00:03:15.829 --> 00:03:19.910
您的代码到模块我已经读了很多

00:03:18.290 --> 00:03:22.100
人们的文章和帖子

00:03:19.910 --> 00:03:23.630
认为你被迫搬家

00:03:22.100 --> 00:03:26.510
并迁移所有现有代码

00:03:23.630 --> 00:03:29.570
为了转移到JDK 9 

00:03:26.510 --> 00:03:32.180
感到困惑，请忽略它们

00:03:29.570 --> 00:03:34.400
听说太阳穆斯卡安很安全，你可能不知道

00:03:32.180 --> 00:03:36.230
直接在您的代码中使用它，但是

00:03:34.400 --> 00:03:37.940
可能是您使用的一些库

00:03:36.230 --> 00:03:41.030
你今天在上课的路上是

00:03:37.940 --> 00:03:44.870
使用Sun Muskaan safe可以像

00:03:41.030 --> 00:03:45.890
在大多数现有代码之前

00:03:44.870 --> 00:03:47.959
像以前一样工作

00:03:45.890 --> 00:03:50.180
当我们浏览此演示文稿时

00:03:47.959 --> 00:03:52.359
您实际上会发现那里确实没有

00:03:50.180 --> 00:03:54.859
涉及大量的代码更改

00:03:52.359 --> 00:03:58.940
关于好消息的最后一点就是全部

00:03:54.859 --> 00:04:01.669
主流ID专家及其所有

00:03:58.940 --> 00:04:04.579
插件是其大多数插件

00:04:01.669 --> 00:04:05.960
已经对其JDK 9提供了支持

00:04:04.579 --> 00:04:09.200
 9准备好了

00:04:05.960 --> 00:04:11.480
并在上周引用um时

00:04:09.200 --> 00:04:13.390
最终发布了JDK 9，因此

00:04:11.480 --> 00:04:16.670
好消息

00:04:13.390 --> 00:04:19.670
不太好消息，这是一个更好的消息

00:04:16.670 --> 00:04:22.490
你最会说坏消息的方式

00:04:19.670 --> 00:04:29.150
可能需要升级许多

00:04:22.490 --> 00:04:30.890
库和您使用的工具

00:04:29.150 --> 00:04:32.870
您正在直接使用一些

00:04:30.890 --> 00:04:34.490
共享一些

00:04:32.870 --> 00:04:36.650
 API就是在那里

00:04:34.490 --> 00:04:38.180
 EE版本和Java版本

00:04:36.650 --> 00:04:39.830
 C，但它们是同一个库，但是在那里

00:04:38.180 --> 00:04:42.350
他们不是完全不同步，如果

00:04:39.830 --> 00:04:43.940
你直接使用那些你可能有

00:04:42.350 --> 00:04:46.370
对您的构建进行一些调整，或者

00:04:43.940 --> 00:04:47.930
你的上课道路我会在

00:04:46.370 --> 00:04:51.620
在几分钟内

00:04:47.930 --> 00:04:52.340
许多受支持的API 

00:04:51.620 --> 00:04:54.260
已移除

00:04:52.340 --> 00:04:56.090
他们在某个时候过时了， 

00:04:54.260 --> 00:04:58.760
他们被删除，我们正在谈论

00:04:56.090 --> 00:05:02.240
 Java C API的六个方法是

00:04:58.760 --> 00:05:05.830
我们没有删除很多权利

00:05:02.240 --> 00:05:08.540
几年前的第一个JDK 9构建

00:05:05.830 --> 00:05:09.560
没有人抱怨，所以我不会

00:05:08.540 --> 00:05:10.850
麻烦他们覆盖这个

00:05:09.560 --> 00:05:12.520
介绍，因为显然知道

00:05:10.850 --> 00:05:15.530
人们真的不在乎他们

00:05:12.520 --> 00:05:18.290
有很多非API功能， 

00:05:15.530 --> 00:05:20.570
一些工具已被删除， 

00:05:18.290 --> 00:05:21.710
人们没有抱怨他们，所以

00:05:20.570 --> 00:05:24.340
我也不会掩盖

00:05:21.710 --> 00:05:29.380
因为它们不是重要的东西

00:05:24.340 --> 00:05:33.800
您可能会看到一些警告， 

00:05:29.380 --> 00:05:36.290
由于某些原因由运行时打印

00:05:33.800 --> 00:05:38.630
图书馆正在使用的我会

00:05:36.290 --> 00:05:42.140
在此谈论

00:05:38.630 --> 00:05:45.560
演示文稿，因此请深入了解

00:05:42.140 --> 00:05:52.430
项目首先是

00:05:45.560 --> 00:05:54.830
 Java SE和Java EE之间共享，因此

00:05:52.430 --> 00:05:57.110
关于JAVA海和

00:05:54.830 --> 00:06:00.590
 JDK是它被同化了

00:05:57.110 --> 00:06:05.090
在过去的许多技术中

00:06:00.590 --> 00:06:06.410
几年，所以有点像

00:06:05.090 --> 00:06:08.450
登上一些人把它比作

00:06:06.410 --> 00:06:10.460
博格和很多年前

00:06:08.450 --> 00:06:12.560
吸收了许多不同的文化

00:06:10.460 --> 00:06:14.120
技术，虽然它们没有显示

00:06:12.560 --> 00:06:15.620
在《星际迷航》的任何一集中

00:06:14.120 --> 00:06:18.260
很确定博格实际上有

00:06:15.620 --> 00:06:20.100
 JDK有时会后悔

00:06:18.260 --> 00:06:25.510
太

00:06:20.100 --> 00:06:26.860
这是Java C模块图，如果

00:06:25.510 --> 00:06:28.449
您在去过Java之前就去过

00:06:26.860 --> 00:06:30.760
看过我们的任何演讲

00:06:28.449 --> 00:06:32.350
年的模块，您将看到

00:06:30.760 --> 00:06:34.990
我们从

00:06:32.350 --> 00:06:38.110
意大利面图要比较干净

00:06:34.990 --> 00:06:41.290
你在这里看到的有向图

00:06:38.110 --> 00:06:44.080
本来有很多模块

00:06:41.290 --> 00:06:45.880
是独立技术还是谎言

00:06:44.080 --> 00:06:48.460
那里的字体很小，但是如果我

00:06:45.880 --> 00:06:50.710
看起来我会很容易发现

00:06:48.460 --> 00:06:52.389
例如包含GM X的Java管理

00:06:50.710 --> 00:06:55.030
那是一项独立的技术

00:06:52.389 --> 00:06:57.600
我看到的Java命名是jndi 

00:06:55.030 --> 00:07:01.120
一站式的技术

00:06:57.600 --> 00:07:04.419
我们打开了右侧的

00:07:01.120 --> 00:07:07.060
该图是一堆模块， 

00:07:04.419 --> 00:07:10.840
与Java EE重叠，并且没有

00:07:07.060 --> 00:07:12.190
被完全包含，所以我要

00:07:10.840 --> 00:07:14.979
我要开始放一点

00:07:12.190 --> 00:07:18.280
标签，我要用黑星来

00:07:14.979 --> 00:07:20.590
标记这些API永远不会完全

00:07:18.280 --> 00:07:21.880
包含在Java C中，您将

00:07:20.590 --> 00:07:24.070
实际上看到这些变成

00:07:21.880 --> 00:07:27.310
有问题的api，当您移动时

00:07:24.070 --> 00:07:30.850
从八到九，因为

00:07:27.310 --> 00:07:34.030
这个重叠，所以我放了一颗黑星

00:07:30.850 --> 00:07:37.300
超过四个API，其中两个是

00:07:34.030 --> 00:07:43.030
对他们来说真正的麻烦少了

00:07:37.300 --> 00:07:44.830
但是他们有两个同样的问题

00:07:43.030 --> 00:07:46.720
这些模块中的两个带来了

00:07:44.830 --> 00:07:48.760
沿着被激活的身体

00:07:46.720 --> 00:07:51.070
模块在Java中没有业务

00:07:48.760 --> 00:07:53.560
 C，但最终却是独立的

00:07:51.070 --> 00:07:55.479
 JDK之外的技术

00:07:53.560 --> 00:07:58.139
像这样同时在JDK中

00:07:55.479 --> 00:08:00.639
其他四个模块非常有问题

00:07:58.139 --> 00:08:03.250
我也要放一个黑星

00:08:00.639 --> 00:08:05.349
针对模块的核心和

00:08:03.250 --> 00:08:07.120
原因是CORBA一直是

00:08:05.349 --> 00:08:09.370
鞭打男孩最后的模块

00:08:07.120 --> 00:08:11.470
年数，但真正的原因

00:08:09.370 --> 00:08:13.330
当然，科尔巴实际上是

00:08:11.470 --> 00:08:15.310
取决于这些问题之一

00:08:13.330 --> 00:08:17.590
模块取决于

00:08:15.310 --> 00:08:20.729
交易API，其中Java C定义了

00:08:17.590 --> 00:08:23.799
此Java EE的子集定义了一个

00:08:20.729 --> 00:08:26.529
完整的API，还有一个

00:08:23.799 --> 00:08:29.289
真正有问题的区域以及当您

00:08:26.529 --> 00:08:31.689
转移到模块，这样的业务

00:08:29.289 --> 00:08:36.069
在JDK内部和外部

00:08:31.689 --> 00:08:38.529
 JDK和本质上同时

00:08:36.069 --> 00:08:41.589
 JDK的技术债务以及您何时

00:08:38.529 --> 00:08:43.240
将任何大型代码库移至您的模块

00:08:41.589 --> 00:08:46.089
可能会遇到技术故障

00:08:43.240 --> 00:08:48.670
这可能是JDK特有的

00:08:46.089 --> 00:08:51.339
但这仍然是技术数据

00:08:48.670 --> 00:08:54.370
我们必须以某种方式弄清楚你不能

00:08:51.339 --> 00:08:56.740
通过放置JDK中的模块

00:08:54.370 --> 00:08:58.720
您无法在类路径上的jar文件

00:08:56.740 --> 00:09:00.189
通过放置JDK中的模块

00:08:58.720 --> 00:09:01.569
室内标准中的jar文件

00:09:00.189 --> 00:09:03.730
覆盖机制，因为

00:09:01.569 --> 00:09:05.980
机制已经成为唯一的途径

00:09:03.730 --> 00:09:08.199
使用更新的版本覆盖JDK中的模块

00:09:05.980 --> 00:09:10.120
版本是通过升级模块

00:09:08.199 --> 00:09:13.089
机制，这是一种新的机制

00:09:10.120 --> 00:09:14.769
九个且仅当模块对齐时

00:09:13.089 --> 00:09:16.779
与您拥有SE的模块

00:09:14.769 --> 00:09:18.899
定义，这就是我们拥有的

00:09:16.779 --> 00:09:22.379
这些模块中的每一个都有问题

00:09:18.899 --> 00:09:25.449
所以这是一个已经存在的话题

00:09:22.379 --> 00:09:29.470
我们已经考虑了很长时间

00:09:25.449 --> 00:09:31.959
时间和根本上发生了什么

00:09:29.470 --> 00:09:35.350
是JDK是交付工具

00:09:31.959 --> 00:09:37.809
从任何这些api的2017年

00:09:35.350 --> 00:09:40.360
现在没有理由成为

00:09:37.809 --> 00:09:43.420
这些api的传送工具

00:09:40.360 --> 00:09:46.089
这些api具有独立版本， 

00:09:43.420 --> 00:09:48.790
没有理由为什么jdk需要

00:09:46.089 --> 00:09:51.009
真正拥有他们，所以提案

00:09:48.790 --> 00:09:53.500
很久以前在java c中

00:09:51.009 --> 00:09:56.500
最终被弃用了

00:09:53.500 --> 00:09:58.379
每个模块，这是

00:09:56.500 --> 00:10:01.660
六个是这些模块的名称

00:09:58.379 --> 00:10:04.809
 Java Korba是API的核心， 

00:10:01.660 --> 00:10:07.839
 RMI ILP驱动程序事务API 

00:10:04.809 --> 00:10:09.730
这是最大的麻烦制造者

00:10:07.839 --> 00:10:12.009
这是因为Java C 

00:10:09.730 --> 00:10:14.679
定义了

00:10:12.009 --> 00:10:16.620
交易API需要激活

00:10:14.679 --> 00:10:20.050
因为这里没有生意

00:10:16.620 --> 00:10:21.790
 Javik气味绑定，这是XML 

00:10:20.050 --> 00:10:23.949
绑定api这可能是

00:10:21.790 --> 00:10:25.600
您直接使用或使用某些库

00:10:23.949 --> 00:10:29.199
使用可能是最受欢迎的

00:10:25.600 --> 00:10:31.360
此列表上的一个Java xml WS其中

00:10:29.199 --> 00:10:34.420
是网络服务，因此

00:10:31.360 --> 00:10:38.440
附件所有这些东西2017 

00:10:34.420 --> 00:10:40.330
现在的旧版Jeff XML WS 

00:10:38.440 --> 00:10:44.170
批注实际上是

00:10:40.330 --> 00:10:46.630
这个API的这些称为

00:10:44.170 --> 00:10:49.930
 Java EE提供的常见注释

00:10:46.630 --> 00:10:52.000
该API的子集是为Java定义的

00:10:49.930 --> 00:10:55.510
 C支持Web服务，它结束了

00:10:52.000 --> 00:10:57.970
 Java C和有关这些的一件事

00:10:55.510 --> 00:11:00.430
模块是因为不推荐使用

00:10:57.970 --> 00:11:03.430
去除这是一种新的形式

00:11:00.430 --> 00:11:07.420
弃用，并在

00:11:03.430 --> 00:11:09.100
 Java C 9当一个模块或其他模块

00:11:07.420 --> 00:11:10.830
编程元素可以是类或

00:11:09.100 --> 00:11:13.870
可能是被标记的特定方法

00:11:10.830 --> 00:11:17.140
不建议移除，它提供了

00:11:13.870 --> 00:11:19.750
明确的意图是将其删除

00:11:17.140 --> 00:11:22.860
有一点编译器和Java 

00:11:19.750 --> 00:11:24.610
语言了解有关方法和

00:11:22.860 --> 00:11:27.550
实际上是编程元素

00:11:24.610 --> 00:11:32.140
不赞成删除，它知道要给

00:11:27.550 --> 00:11:34.180
您正确的警告，例如，如果

00:11:32.140 --> 00:11:36.400
您正在使用不需要的任何这些

00:11:34.180 --> 00:11:38.650
恐慌，我们进入其中一些

00:11:36.400 --> 00:11:43.390
几分钟之内的事情，但让我

00:11:38.650 --> 00:11:45.730
告诉你还有另一件事

00:11:43.390 --> 00:11:49.330
发生在9，所以他们不赞成

00:11:45.730 --> 00:11:52.690
搬迁，但我们也做了一个

00:11:49.330 --> 00:11:54.670
调整，这将为

00:11:52.690 --> 00:11:58.570
最终将它们从JAVA海中删除

00:11:54.670 --> 00:12:01.300
和JDK的区别在于，我们

00:11:58.570 --> 00:12:04.900
不会通过解析这些模块

00:12:01.300 --> 00:12:06.220
现在默认，您还没有去过那里

00:12:04.900 --> 00:12:09.000
有一些模块讨论，所以你不

00:12:06.220 --> 00:12:11.020
知道什么分辨率，又又又又又

00:12:09.000 --> 00:12:13.510
解决模块意味着但不用担心

00:12:11.020 --> 00:12:15.940
关于这意味着什么是

00:12:13.510 --> 00:12:19.270
本质上是如果您正在跑步

00:12:15.940 --> 00:12:22.660
类路径上的代码就像

00:12:19.270 --> 00:12:25.570
这些模块不存在，它将是

00:12:22.660 --> 00:12:28.270
如果这些模块中的类型不

00:12:25.570 --> 00:12:30.430
存在，让我给你看一个例子

00:12:28.270 --> 00:12:33.910
只是为了加强什么

00:12:30.430 --> 00:12:37.300
这意味着这是一些代码

00:12:33.910 --> 00:12:40.350
使用M Jax Jax B的片段

00:12:37.300 --> 00:12:43.420
 API，我正在调用静态方法

00:12:40.350 --> 00:12:46.240
 mjx XML绑定和

00:12:43.420 --> 00:12:51.010
 Jax被上下文这是一个静态方法

00:12:46.240 --> 00:12:52.450
让它成为上下文的Jax不必担心

00:12:51.010 --> 00:12:54.550
如果您从未使用过Jax，可以

00:12:52.450 --> 00:12:56.350
忽略这一点，重要的是

00:12:54.550 --> 00:12:58.030
接下来我想告诉你什么

00:12:56.350 --> 00:13:02.650
如果您尝试编译此发生

00:12:58.030 --> 00:13:05.320
代码，您会收到一个编译器错误，它将

00:13:02.650 --> 00:13:08.380
无法编译，我会读出错误

00:13:05.320 --> 00:13:11.350
我绑定的包javax.swing不是

00:13:08.380 --> 00:13:14.740
可见包装的Avex ml绑定是

00:13:11.350 --> 00:13:17.650
在模块java xml中声明的bind 

00:13:14.740 --> 00:13:20.170
当我说时不在模块图中

00:13:17.650 --> 00:13:21.880
该模块没有解决，不是

00:13:20.170 --> 00:13:23.710
在此模块图中， 

00:13:21.880 --> 00:13:25.840
运行时受到伤害，因此编译器有一个

00:13:23.710 --> 00:13:27.460
实际启动时没有运行时

00:13:25.840 --> 00:13:30.370
以及在编译代码时

00:13:27.460 --> 00:13:32.140
在类路径上运行代码，如果

00:13:30.370 --> 00:13:34.480
编译时出现此错误

00:13:32.140 --> 00:13:36.820
如果我已经有一些会发生什么

00:13:34.480 --> 00:13:41.200
先前编译使用的代码

00:13:36.820 --> 00:13:44.620
这些api，我尝试让它震惊

00:13:41.200 --> 00:13:47.800
可怕的是我没有班级开发者

00:13:44.620 --> 00:13:49.660
好像我缺少我的jar文件

00:13:47.800 --> 00:13:52.330
类路径到底是什么

00:13:49.660 --> 00:13:55.630
这是怎么回事，所以这是新事物

00:13:52.330 --> 00:13:57.580
到JDK，我们从未删除

00:13:55.630 --> 00:13:59.500
模块之前，这只是

00:13:57.580 --> 00:14:01.210
第一步，我想谈一些

00:13:59.500 --> 00:14:02.470
的迁移选项是

00:14:01.210 --> 00:14:04.690
围绕这个，这肯定是一个

00:14:02.470 --> 00:14:08.050
颠覆性变革，但仅针对那些

00:14:04.690 --> 00:14:11.370
直接使用和间接使用的

00:14:08.050 --> 00:14:13.480
这些模块中使用了API 

00:14:11.370 --> 00:14:15.100
有很多迁移选项

00:14:13.480 --> 00:14:17.740
我们已经在jdk中编写了这些

00:14:15.100 --> 00:14:21.430
迁移指南，我们有一个新的

00:14:17.740 --> 00:14:24.550
命令行选项添加模块，其中

00:14:21.430 --> 00:14:26.560
您给它提供一组模块

00:14:24.550 --> 00:14:30.510
在启动时另外解决

00:14:26.560 --> 00:14:33.070
这可用作短期解决方案

00:14:30.510 --> 00:14:35.950
获得使用这些的现有代码

00:14:33.070 --> 00:14:39.670
编译并运行它的api 

00:14:35.950 --> 00:14:42.160
就像jdk的年龄一直回到6岁

00:14:39.670 --> 00:14:45.310
在这个模块的情况下，这样保持

00:14:42.160 --> 00:14:48.529
现有代码工作正常

00:14:45.310 --> 00:14:52.279
添加带来的不便

00:14:48.529 --> 00:14:56.389
每个选项都有一个命令行选项

00:14:52.279 --> 00:15:00.290
 api的碳元素除外

00:14:56.389 --> 00:15:03.889
独立版本，它有自己的jsr 

00:15:00.290 --> 00:15:07.490
每个JCP都维护它

00:15:03.889 --> 00:15:09.680
这些模块中的每个模块的工件

00:15:07.490 --> 00:15:11.990
已经发布了我们的jar文件，我应该说

00:15:09.680 --> 00:15:15.199
在maven Central中发布，因此

00:15:11.990 --> 00:15:17.470
还有其他获取方式

00:15:15.199 --> 00:15:20.269
这些库，当您使用它们时

00:15:17.470 --> 00:15:24.709
您可以将它们部署在类路径上

00:15:20.269 --> 00:15:27.290
或者您可以在升级时部署它们

00:15:24.709 --> 00:15:30.079
模块路径，以便将它们部署为

00:15:27.290 --> 00:15:32.690
模块现在还不全在

00:15:30.079 --> 00:15:34.339
作为模块，但作为一个同事

00:15:32.690 --> 00:15:37.399
我正在和业主一起整理

00:15:34.339 --> 00:15:38.990
所有这些组成部分中

00:15:37.399 --> 00:15:42.470
确保最终他们都可以成为

00:15:38.990 --> 00:15:44.779
也部署为模块，所以

00:15:42.470 --> 00:15:48.019
鼻腔治疗器的一项重要重要改变

00:15:44.779 --> 00:15:50.170
颠覆性的变化，我想继续

00:15:48.019 --> 00:15:54.160
谈论强封装

00:15:50.170 --> 00:15:57.920
对于JDK而言， 

00:15:54.160 --> 00:15:59.870
封装JDK内部，以便

00:15:57.920 --> 00:16:03.130
这些模块之外的代码

00:15:59.870 --> 00:16:05.800
模块将无法到达

00:16:03.130 --> 00:16:11.180
不属于API的类

00:16:05.800 --> 00:16:13.519
而且也是，所以他们无法到达

00:16:11.180 --> 00:16:16.070
班级的非公开成员

00:16:13.519 --> 00:16:19.880
在API中，所以这是一个

00:16:16.070 --> 00:16:25.699
大不了的，我先回去

00:16:19.880 --> 00:16:29.930
这个尘土飞扬的管道滑道20年尘土飞扬

00:16:25.699 --> 00:16:31.270
文档页面是从1996年开始的，我将尝试

00:16:29.930 --> 00:16:33.550
阅读

00:16:31.270 --> 00:16:36.730
想念背后的任何人带来了

00:16:33.550 --> 00:16:39.850
双筒望远镜，可以为我阅读

00:16:36.730 --> 00:16:42.160
 Java点星包使化妆

00:16:39.850 --> 00:16:44.529
官方支持的公共Java接口

00:16:42.160 --> 00:16:47.070
 Sun dot star软件包不包含在内

00:16:44.529 --> 00:16:50.440
支持的公共Java接口

00:16:47.070 --> 00:16:53.140
这说这是文档

00:16:50.440 --> 00:16:56.680
说21年前，但没人读过

00:16:53.140 --> 00:17:01.600
这些文档现在事情已经过去了

00:16:56.680 --> 00:17:05.439
在JDK 6中，当Java C获得一个简单的

00:17:01.600 --> 00:17:08.559
符号数据库就足够了

00:17:05.439 --> 00:17:12.010
 Java C能够打印警告

00:17:08.559 --> 00:17:14.589
我们在编译代码时的错误是

00:17:12.010 --> 00:17:17.740
利用Sun dot star API或

00:17:14.589 --> 00:17:20.319
其他内部api的作用是

00:17:17.740 --> 00:17:23.589
威慑力，所以我要挑一些

00:17:20.319 --> 00:17:27.670
具有静态代码的示例

00:17:23.589 --> 00:17:31.210
参考Sun Security x.509 X 500 

00:17:27.670 --> 00:17:33.730
名称，我们将看到您发生什么情况

00:17:31.210 --> 00:17:35.559
尝试使用JDK 6或7或8进行编译

00:17:33.730 --> 00:17:38.170
您收到编译器警告

00:17:35.559 --> 00:17:40.630
警告X 500名称是什么

00:17:38.170 --> 00:17:43.750
是内部专有API，可能是

00:17:40.630 --> 00:17:46.240
删除了所有我们都忽略的未来版本

00:17:43.750 --> 00:17:47.860
飞行员警告，我肯定在这里

00:17:46.240 --> 00:17:50.590
忽略我们忽略的文档

00:17:47.860 --> 00:17:52.870
编译器警告现在开始

00:17:50.590 --> 00:17:58.600
到JDK 9，那里的东西又拨号了

00:17:52.870 --> 00:18:02.530
如果您尝试使用JDK 9， 

00:17:58.600 --> 00:18:05.470
直接参考的已编译代码

00:18:02.530 --> 00:18:08.309
内部API编译将失败

00:18:05.470 --> 00:18:11.290
故事结局

00:18:08.309 --> 00:18:14.000
我会宣扬空气

00:18:11.290 --> 00:18:17.120
包子安全x.509不是

00:18:14.000 --> 00:18:19.550
可见的安全性x.509软件包是

00:18:17.120 --> 00:18:21.590
声明的模块库不是

00:18:19.550 --> 00:18:23.120
不会将其导出到未命名的模块

00:18:21.590 --> 00:18:24.350
现在我们不知道未命名的是什么

00:18:23.120 --> 00:18:26.630
模块在这里，因为我们还没有去过

00:18:24.350 --> 00:18:28.880
参加其他会议，但

00:18:26.630 --> 00:18:32.390
只是假设这是一个类路径

00:18:28.880 --> 00:18:34.970
演示文稿摘要正在编译

00:18:32.390 --> 00:18:38.360
针对内部api，现在将导致

00:18:34.970 --> 00:18:41.240
在jdk 9中编译错误

00:18:38.360 --> 00:18:44.210
大约一次，所以更多

00:18:41.240 --> 00:18:49.580
在运行时很复杂哦，我忘了一个

00:18:44.210 --> 00:18:53.390
订购东西J技巧时非常有用的工具

00:18:49.580 --> 00:18:57.740
为JDK 9做准备就是运行Jade 

00:18:53.390 --> 00:19:02.300
 JDK中包含EPS工具和Jade EPS工具

00:18:57.740 --> 00:19:04.970
 8，并允许您进行静态分析

00:19:02.300 --> 00:19:07.670
代码或编译代码以查看是否

00:19:04.970 --> 00:19:09.320
它具有对内部api的任何引用

00:19:07.670 --> 00:19:10.580
实际上是一支瑞士军队

00:19:09.320 --> 00:19:12.500
刀，你实际上可以得到它能够

00:19:10.580 --> 00:19:14.420
看看并分析所有

00:19:12.500 --> 00:19:16.580
依赖关系，这是非常非常有用的工具

00:19:14.420 --> 00:19:19.820
快速调查实际上有多少人

00:19:16.580 --> 00:19:22.190
这里尝试过J技巧好吧

00:19:19.820 --> 00:19:24.970
比去年好

00:19:22.190 --> 00:19:28.430
那些拍照片的翡翠EPS是

00:19:24.970 --> 00:19:31.370
 jde PSM，所以我们经常会被问到吗

00:19:28.430 --> 00:19:32.510
演示只是为了说明这一点

00:19:31.370 --> 00:19:33.830
我将仅以此运行Jade应用

00:19:32.510 --> 00:19:36.620
我上一张幻灯片中的代码示例

00:19:33.830 --> 00:19:38.600
我正在使用J技巧-JDK内部

00:19:36.620 --> 00:19:39.950
给它上课我可以给它加罐子

00:19:38.600 --> 00:19:41.840
您可以提供一个类路径的文件

00:19:39.950 --> 00:19:43.940
实际上非常灵活

00:19:41.840 --> 00:19:46.310
输入将是，它正在推出

00:19:43.940 --> 00:19:49.310
消息说我的代码有一个

00:19:46.310 --> 00:19:52.900
对Sun Security x.509 X 500的依赖

00:19:49.310 --> 00:19:55.730
名称并将其标记为内部API 

00:19:52.900 --> 00:19:57.650
翡翠EPS有了很大的提高

00:19:55.730 --> 00:19:59.330
在JDK 9中，如果您尝试过8， 

00:19:57.650 --> 00:20:01.610
实际上在9中看到了一些改进，但是

00:19:59.330 --> 00:20:04.100
它具有的优点之一就是它具有

00:20:01.610 --> 00:20:06.710
一张内部API的小表格是vs。 

00:20:04.100 --> 00:20:08.150
支持的api，因此适用于

00:20:06.710 --> 00:20:10.280
任何受支持的API 

00:20:08.150 --> 00:20:12.740
介绍，它看到了对

00:20:10.280 --> 00:20:14.570
实际上会提供的旧内部API 

00:20:12.740 --> 00:20:16.400
你在这种情况下有一个提示

00:20:14.570 --> 00:20:18.410
有一个X 500的主要班级

00:20:16.400 --> 00:20:19.320
加了1/4更好了

00:20:18.410 --> 00:20:22.650
的方法

00:20:19.320 --> 00:20:24.390
现在我要处理x500名称

00:20:22.650 --> 00:20:28.200
回到运行时间再谈

00:20:24.390 --> 00:20:32.850
复杂性，但随着运行时间

00:20:28.200 --> 00:20:36.540
最终目标是封装所有

00:20:32.850 --> 00:20:41.280
一次也有内部api 

00:20:36.540 --> 00:20:44.550
在jdk 9中我们还没有尝试

00:20:41.280 --> 00:20:46.710
在j2k 9中去那里，实际上超过

00:20:44.550 --> 00:20:48.390
一年，我们有早期访问账单

00:20:46.710 --> 00:20:51.110
强烈封装了所有

00:20:48.390 --> 00:20:54.180
运行时内部

00:20:51.110 --> 00:20:56.280
但是很多代码破坏了很多代码是

00:20:54.180 --> 00:20:58.710
利用内部ap的很多

00:20:56.280 --> 00:21:02.120
代码侵入非公共成员

00:20:58.710 --> 00:21:02.120
 Java lang中的类的集合

00:21:02.250 --> 00:21:09.300
那么JDK 9和

00:21:05.190 --> 00:21:13.530
现在是运行时的摘要

00:21:09.300 --> 00:21:16.190
现在，JDK 9可以解决问题

00:21:13.530 --> 00:21:20.070
排除JDK 8中存在的所有软件包

00:21:16.190 --> 00:21:23.130
在类路径上对此代码开放

00:21:20.070 --> 00:21:25.200
允许现有的黑客像以前一样工作

00:21:23.130 --> 00:21:27.330
现在当我说现有的黑客工作

00:21:25.200 --> 00:21:29.160
在您当然拥有之前

00:21:27.330 --> 00:21:30.570
内部类的重构和

00:21:29.160 --> 00:21:32.880
破坏了很多黑客的东西

00:21:30.570 --> 00:21:36.060
无论如何，那只是一部分

00:21:32.880 --> 00:21:39.120
是我们生命中的第一，这是

00:21:36.060 --> 00:21:42.360
重要的一点是第一次使用

00:21:39.120 --> 00:21:45.810
利用这一点的核心思考

00:21:42.360 --> 00:21:48.600
入侵JDK内部是做什么的

00:21:45.810 --> 00:21:50.760
我们称其为非法反射访问， 

00:21:48.600 --> 00:21:53.370
我解释一下，几分钟后

00:21:50.760 --> 00:21:55.740
向标准错误发出警告

00:21:53.370 --> 00:21:56.940
不可抑制的警告，所以这

00:21:55.740 --> 00:22:00.960
是我们第一次成像

00:21:56.940 --> 00:22:05.690
运行时的警告

00:22:00.960 --> 00:22:08.580
我将在下一张幻灯片中显示

00:22:05.690 --> 00:22:10.740
使人们意识到有代码

00:22:08.580 --> 00:22:12.060
当内部结构破损时

00:22:10.740 --> 00:22:14.850
完全封装

00:22:12.060 --> 00:22:18.510
警告试图识别出什么

00:22:14.850 --> 00:22:20.390
令人讨厌的代码是告诉你什么

00:22:18.510 --> 00:22:24.210
它实际上是试图访问它们

00:22:20.390 --> 00:22:26.850
有一个命令行选项-- 

00:22:24.210 --> 00:22:29.190
允许您调试的非法访问

00:22:26.850 --> 00:22:31.649
更进一步，以便将来调试其中一个

00:22:29.190 --> 00:22:33.600
可以进入你可以得到

00:22:31.649 --> 00:22:38.669
您可能会堆积的其他警告

00:22:33.600 --> 00:22:41.159
种族，您甚至可以拒绝访问

00:22:38.669 --> 00:22:43.139
内部结构，让您可以尝试

00:22:41.159 --> 00:22:46.759
当

00:22:43.139 --> 00:22:49.440
 GDK完全封装了其内部

00:22:46.759 --> 00:22:53.129
所以我要用一个例子

00:22:49.440 --> 00:22:54.990
杰森波纹的例子

00:22:53.129 --> 00:22:56.639
我没有选择杰森的方式

00:22:54.990 --> 00:22:58.889
仅以它为例

00:22:56.639 --> 00:23:00.269
最后我可以选择很多例子

00:22:58.889 --> 00:23:02.429
我用的一年和前一年

00:23:00.269 --> 00:23:04.669
 Gradle和GlassFish I的示例

00:23:02.429 --> 00:23:07.950
决定今年休息一下

00:23:04.669 --> 00:23:09.690
让我们看看警告是什么

00:23:07.950 --> 00:23:11.909
这是Java的可执行jar 

00:23:09.690 --> 00:23:14.389
 dash jar我收到警告和法律

00:23:11.909 --> 00:23:16.860
发生反射访问操作

00:23:14.389 --> 00:23:19.019
和它的非法反射访问

00:23:16.860 --> 00:23:21.179
给我类型名称，给我

00:23:19.019 --> 00:23:23.519
在这种情况下的代码库是

00:23:21.179 --> 00:23:26.999
带有Jason波纹的jar文件和

00:23:23.519 --> 00:23:30.809
它正在尝试访问某些成员

00:23:26.999 --> 00:23:33.539
 Sun和IO CH，这是可选的

00:23:30.809 --> 00:23:36.179
渠道实施内部是

00:23:33.539 --> 00:23:38.460
尝试访问此访问

00:23:36.179 --> 00:23:39.960
成功，但是您收到此警告，并且它

00:23:38.460 --> 00:23:42.749
提出有关提交

00:23:39.960 --> 00:23:44.519
错误，还提示您什么

00:23:42.749 --> 00:23:47.549
您可以实际使用的命令行选项

00:23:44.519 --> 00:23:50.580
以获得进一步的警告，如果你想

00:23:47.549 --> 00:23:56.399
调查人员，所以这是新事物， 

00:23:50.580 --> 00:23:58.289
一次警告现在有很多

00:23:56.399 --> 00:24:02.519
我想要的基因JDK 9中的其他变化

00:23:58.289 --> 00:24:07.679
谈谈他的新版本字符串

00:24:02.519 --> 00:24:09.029
方案芯片223，您可能听说过

00:24:07.679 --> 00:24:11.490
这实际上是相当

00:24:09.029 --> 00:24:14.190
我不会花费的颠覆性变革

00:24:11.490 --> 00:24:16.740
时间经过它，芯片拥有了所有

00:24:14.190 --> 00:24:18.659
为什么旧的动机

00:24:16.740 --> 00:24:20.879
令人困惑的编号方案

00:24:18.659 --> 00:24:23.429
替换为新的编号方案

00:24:20.879 --> 00:24:27.720
这要简单得多，我希望人们

00:24:23.429 --> 00:24:30.779
会弄清楚很多，所以

00:24:27.720 --> 00:24:35.480
这是一个例子，我们只是一张桌子

00:24:30.779 --> 00:24:35.480
显示JDK 8 vs j TK 9 

00:24:35.490 --> 00:24:42.360
这些是四个五个助手

00:24:38.250 --> 00:24:44.880
并显示版本的属性

00:24:42.360 --> 00:24:48.990
 Java版本by是助手

00:24:44.880 --> 00:24:54.600
许多图书馆和检查的财产

00:24:48.990 --> 00:24:56.850
看看他们在做什么，所以

00:24:54.600 --> 00:25:00.870
漂亮而简单，经过20年的发展

00:24:56.850 --> 00:25:06.570
本质上放弃了领先者，但

00:25:00.870 --> 00:25:08.429
这是一个极具破坏性的变化

00:25:06.570 --> 00:25:13.610
可以在代码上进行整个会话

00:25:08.429 --> 00:25:16.679
显示错误代码的示例

00:25:13.610 --> 00:25:19.290
 Java版本，我们已经看到了认为

00:25:16.679 --> 00:25:21.270
它在JD k 1j tk1上时

00:25:19.290 --> 00:25:24.179
跑了九个我们已经看到我们已经看到

00:25:21.270 --> 00:25:26.760
实际尝试执行的代码

00:25:24.179 --> 00:25:28.559
并加载从未有过的库

00:25:26.760 --> 00:25:30.690
它已经运行了十多年

00:25:28.559 --> 00:25:32.280
我们看到了异常我们看到了错误

00:25:30.690 --> 00:25:34.440
各种疯狂的事情就足够了

00:25:32.280 --> 00:25:39.660
整个会议的材料

00:25:34.440 --> 00:25:41.130
旧金山喜剧俱乐部很多

00:25:39.660 --> 00:25:42.720
图书馆已经与

00:25:41.130 --> 00:25:44.730
我们在过去的几年中有

00:25:42.720 --> 00:25:47.370
附加了解析后即可处理

00:25:44.730 --> 00:25:49.830
有九个，但那里可能

00:25:47.370 --> 00:25:52.530
如果您维护任何其他代码

00:25:49.830 --> 00:25:54.990
现在解析Java版本的代码是

00:25:52.530 --> 00:25:57.000
审核的好时机，看看是否

00:25:54.990 --> 00:26:01.230
实际上会有问题和动

00:25:57.000 --> 00:26:03.090
从八点到九点

00:26:01.230 --> 00:26:05.100
在九个功能上

00:26:03.090 --> 00:26:07.470
实际上避免了解析Java 

00:26:05.100 --> 00:26:08.040
版本带有新的运行时版本

00:26:07.470 --> 00:26:09.480
 API 

00:26:08.040 --> 00:26:11.850
所以最后你实际上有一个

00:26:09.480 --> 00:26:14.520
现在以编程方式获取版本

00:26:11.850 --> 00:26:16.320
这周你会听到很多关于搬家的信息

00:26:14.520 --> 00:26:18.450
到更快的版本，也许会改变

00:26:16.320 --> 00:26:20.220
版本方案再次，所以也许这

00:26:18.450 --> 00:26:21.960
必须重新审查API，但

00:26:20.220 --> 00:26:24.750
关键是能够更好

00:26:21.960 --> 00:26:27.600
使用API​​而不是获取此信息

00:26:24.750 --> 00:26:30.270
而不是自己解析， 

00:26:27.600 --> 00:26:31.740
多释放罐，这是

00:26:30.270 --> 00:26:36.210
我稍后要谈论的东西

00:26:31.740 --> 00:26:38.100
在本演示文稿中，新

00:26:36.210 --> 00:26:42.120
二进制结构是针对JRE中的

00:26:38.100 --> 00:26:44.300
 JDK是220，这就是全部

00:26:42.120 --> 00:26:44.300
关于

00:26:44.980 --> 00:26:51.200
转向模块化

00:26:49.399 --> 00:26:53.059
平台，因为其中的意义之一

00:26:51.200 --> 00:26:55.759
模块化平台是否完全

00:26:53.059 --> 00:27:00.919
模糊了两者之间的历史区别

00:26:55.759 --> 00:27:03.409
 JRE和JDK，这是一个

00:27:00.919 --> 00:27:06.200
破坏性变化和原因之一

00:27:03.409 --> 00:27:09.710
实际上，我们早在JDK上就已经有了

00:27:06.200 --> 00:27:11.539
我们在2014年末获得了该工具

00:27:09.710 --> 00:27:13.820
以及编译器和想法以及

00:27:11.539 --> 00:27:16.639
那些实际上依赖于

00:27:13.820 --> 00:27:20.119
文件系统上的布局可能是

00:27:16.639 --> 00:27:24.230
只是提前应对这种变化

00:27:20.119 --> 00:27:25.700
所以这意味着什么

00:27:24.230 --> 00:27:28.159
抱歉，我会向您展示旧结构

00:27:25.700 --> 00:27:30.830
首先只是为了让您有所了解

00:27:28.159 --> 00:27:32.450
我们实际上是从JDK观点出发

00:27:30.830 --> 00:27:34.340
一路下载八七六

00:27:32.450 --> 00:27:37.129
回到1.2的结构

00:27:34.340 --> 00:27:39.080
介绍您有一个JRE目录

00:27:37.129 --> 00:27:40.759
在JDK下载中

00:27:39.080 --> 00:27:42.710
运行时有一个Lib目录

00:27:40.759 --> 00:27:45.200
你可能有Archie jar 

00:27:42.710 --> 00:27:47.570
听说RT jar有一个Lib目录

00:27:45.200 --> 00:27:49.429
在顶层Lib目录中

00:27:47.570 --> 00:27:52.059
您会发现其他jar文件工具

00:27:49.429 --> 00:27:54.619
那个罐子可能是最有名的

00:27:52.059 --> 00:27:56.090
有两个bin目录，其中一个位于

00:27:54.619 --> 00:27:59.090
杰里（Jerry）的最高一级

00:27:56.090 --> 00:28:00.739
他们有相同工具的副本

00:27:59.090 --> 00:28:03.950
这是一个令人尴尬的事故

00:28:00.739 --> 00:28:06.980
是布局，来了关于库

00:28:03.950 --> 00:28:10.039
目录是事物的大杂烩

00:28:06.980 --> 00:28:12.230
它里面有一些文件

00:28:10.039 --> 00:28:15.710
打算对其提供的内容进行编辑

00:28:12.230 --> 00:28:17.179
像管理这样的配置

00:28:15.710 --> 00:28:18.590
配置文件我们的安全策略

00:28:17.179 --> 00:28:20.210
他们打算被编辑的文件

00:28:18.590 --> 00:28:22.340
里面有一堆其他文件

00:28:20.210 --> 00:28:23.720
在那里，您可以触摸它们

00:28:22.340 --> 00:28:25.850
你不应该编辑它们

00:28:23.720 --> 00:28:27.739
人们总是对什么感到困惑

00:28:25.850 --> 00:28:31.309
你应该改变并注意什么

00:28:27.739 --> 00:28:36.200
不更改JDK 9运行时发射

00:28:31.309 --> 00:28:38.059
格式化运行时，这要简单得多

00:28:36.200 --> 00:28:40.489
使用工具将一级bin目录

00:28:38.059 --> 00:28:42.590
 Java启动器Java C等

00:28:40.489 --> 00:28:45.470
直接与用户一起编辑

00:28:42.590 --> 00:28:47.119
配置文件（如果有） 

00:28:45.470 --> 00:28:49.009
倾向于被编辑

00:28:47.119 --> 00:28:52.159
目录，如果不打算

00:28:49.009 --> 00:28:55.700
编辑它不在那里，这意味着什么

00:28:52.159 --> 00:28:57.560
是JRE目录消失了RTG是

00:28:55.700 --> 00:28:59.240
对不起，阿奇罐子

00:28:57.560 --> 00:29:02.150
那个罐子不见了，所以这是一个很大的

00:28:59.240 --> 00:29:03.710
改变，你知道我认为大多数人

00:29:02.150 --> 00:29:05.630
这里不会有太多的代码

00:29:03.710 --> 00:29:07.550
依赖于此，许多工具

00:29:05.630 --> 00:29:08.570
您使用的可能就是那个

00:29:07.550 --> 00:29:12.020
必须升级的原因

00:29:08.570 --> 00:29:13.460
现在，如果您进入模块，则可以使用您的工具

00:29:12.020 --> 00:29:15.500
会话，您会听到一些有关

00:29:13.460 --> 00:29:18.410
 j-link工具并创建自己的工具

00:29:15.500 --> 00:29:20.810
运行时映像并仅链接

00:29:18.410 --> 00:29:23.600
您想要创建的模块

00:29:20.810 --> 00:29:25.400
使用j-link时拥有自己的运行时

00:29:23.600 --> 00:29:28.880
可能开始熟悉

00:29:25.400 --> 00:29:31.460
通过这种布局，还有许多其他功能

00:29:28.880 --> 00:29:33.980
我刚才说过的变化

00:29:31.460 --> 00:29:35.600
类路径没有改变类

00:29:33.980 --> 00:29:37.040
加载没有改变，但是有

00:29:35.600 --> 00:29:40.640
实际上在这方面有一些变化

00:29:37.040 --> 00:29:43.850
应用程序类加载器区域

00:29:40.640 --> 00:29:44.480
不再是URL类的实例

00:29:43.850 --> 00:29:47.210
装载机

00:29:44.480 --> 00:29:48.770
从来没有这样记录过我们

00:29:47.210 --> 00:29:50.540
发现那里有很多图书馆

00:29:48.770 --> 00:29:55.520
假设这并真的希望它存在

00:29:50.540 --> 00:29:59.000
 URL类加载器的所有核心

00:29:55.520 --> 00:30:00.590
您曾经使用过的模块

00:29:59.000 --> 00:30:03.950
他们的班级曾经是RTG 

00:30:00.590 --> 00:30:06.770
现在它们都在模块中了吗

00:30:03.950 --> 00:30:08.840
不需要布尔类路径，因此

00:30:06.770 --> 00:30:11.090
有一些变化，这些是

00:30:08.840 --> 00:30:12.350
你可能不会碰到的东西

00:30:11.090 --> 00:30:14.240
太多了，但是如果你有自己的

00:30:12.350 --> 00:30:15.740
自定义类加载器，它是10 

00:30:14.240 --> 00:30:17.420
那是父母不知道的

00:30:15.740 --> 00:30:20.270
突然的是

00:30:17.420 --> 00:30:24.470
对它可见ar-ar-ar-ar减少所以

00:30:20.270 --> 00:30:26.720
事情两件事，什么都不知道

00:30:24.470 --> 00:30:28.970
与模块有关，但有很多

00:30:26.720 --> 00:30:32.780
安全深度防御工作完成

00:30:28.970 --> 00:30:35.090
在jdk 9中移动了很多非核心

00:30:32.780 --> 00:30:36.320
库和模块远离

00:30:35.090 --> 00:30:39.350
引导加载程序所在位置所在位置

00:30:36.320 --> 00:30:41.120
他们已移至的所有权限

00:30:39.350 --> 00:30:42.980
平台类加载器或

00:30:41.120 --> 00:30:44.890
扩展类加载器，因为它曾经是

00:30:42.980 --> 00:30:48.860
所以这是另一回事

00:30:44.890 --> 00:30:53.680
共同创建和自定义类加载器可以

00:30:48.860 --> 00:30:56.120
实际上并且可能实际上观察到了

00:30:53.680 --> 00:30:58.490
做的勇敢的事情之一

00:30:56.120 --> 00:30:59.240
 JDK 9将遍历Unicode 

00:30:58.490 --> 00:31:03.230
 cldr 

00:30:59.240 --> 00:31:05.150
默认情况下，语言环境数据是

00:31:03.230 --> 00:31:08.060
非常微妙的变化，但这是一个非常

00:31:05.150 --> 00:31:10.940
真的是很好的改变，这就是

00:31:08.060 --> 00:31:15.109
已经准备好多年了

00:31:10.940 --> 00:31:16.999
以及将近20年的GDK 

00:31:15.109 --> 00:31:19.309
维护我们自己的语言环境数据

00:31:16.999 --> 00:31:22.820
它，我们现在将其称为旧版JRE 

00:31:19.309 --> 00:31:24.409
语言环境数据jdk年龄已更新为可发货

00:31:22.820 --> 00:31:26.059
有两套语言环境数据， 

00:31:24.409 --> 00:31:28.879
您可以翻转的系统属性

00:31:26.059 --> 00:31:31.609
他们两个之间没有

00:31:28.879 --> 00:31:32.269
更改默认的JDK 9开关

00:31:31.609 --> 00:31:35.090
默认

00:31:32.269 --> 00:31:37.039
这就是如果你有

00:31:35.090 --> 00:31:38.210
部署的应用程序和我

00:31:37.039 --> 00:31:39.710
猜猜我在那儿读东西

00:31:38.210 --> 00:31:42.019
最近有人在跑步

00:31:39.710 --> 00:31:44.629
变成一些奇怪的日期格式

00:31:42.019 --> 00:31:46.580
问题，我认为是澳大利亚人

00:31:44.629 --> 00:31:49.519
英语，这是一个微妙的区别

00:31:46.580 --> 00:31:52.729
在标准化的cldr和

00:31:49.519 --> 00:31:56.419
旧的格里语言环境数据

00:31:52.729 --> 00:31:57.830
格式略有不同， 

00:31:56.419 --> 00:31:58.399
已经在几年前更新了

00:31:57.830 --> 00:32:00.379
 cldr 

00:31:58.399 --> 00:32:03.019
所以这些都是微妙的事情

00:32:00.379 --> 00:32:05.659
知道，但是您可以使用JDK做的是

00:32:03.019 --> 00:32:06.950
您可以为您配置cldr，然后您

00:32:05.659 --> 00:32:08.509
可以实际观察到

00:32:06.950 --> 00:32:09.649
您支持的不同语言环境

00:32:08.509 --> 00:32:13.820
看你是否只有一个

00:32:09.649 --> 00:32:15.919
 JDK 9的差异也很勇敢

00:32:13.820 --> 00:32:18.369
切换默认值的步骤

00:32:15.919 --> 00:32:20.179
垃圾收集器到g1，哪个

00:32:18.369 --> 00:32:23.450
可能会改变性能

00:32:20.179 --> 00:32:24.950
一些应用程序的特征

00:32:23.450 --> 00:32:26.690
我不会在所有这些

00:32:24.950 --> 00:32:29.210
现在，细节才真正使人意识到

00:32:26.690 --> 00:32:33.259
移动时要考虑的事情

00:32:29.210 --> 00:32:34.820
现在我要继续前进到gjd犬

00:32:33.259 --> 00:32:37.639
到现在为止只是谈论几个

00:32:34.820 --> 00:32:40.489
 jdk 9中的功能确实有所帮助

00:32:37.639 --> 00:32:43.429
随着迁移，我选择了

00:32:40.489 --> 00:32:47.269
给他们的japchae 38多功能释放罐

00:32:43.429 --> 00:32:51.080
文件和Gipp 247为旧版本编译

00:32:47.269 --> 00:32:55.279
平台版本，我将从多

00:32:51.080 --> 00:32:59.929
释放jar文件，以便Java C 9具有

00:32:55.279 --> 00:33:02.570
引入了一大堆新的API M 

00:32:59.929 --> 00:33:04.369
有四个句柄，例如，何时

00:33:02.570 --> 00:33:06.139
与远处的奇妙事物

00:33:04.369 --> 00:33:07.849
 var handles is this is you can start 

00:33:06.139 --> 00:33:10.039
替换正在使用的一些代码

00:33:07.849 --> 00:33:12.470
一些Muskaan安全使用的标准

00:33:10.039 --> 00:33:14.899
 api，但创建一个有趣的

00:33:12.470 --> 00:33:16.279
事情和一个有趣的问题

00:33:14.899 --> 00:33:18.679
那些想要拥有一个图书馆的人

00:33:16.279 --> 00:33:20.389
运行七八点，他们会

00:33:18.679 --> 00:33:24.259
喜欢利用新的API 

00:33:20.389 --> 00:33:24.950
当他们九点钟的时候

00:33:24.259 --> 00:33:27.200
有趣的是

00:33:24.950 --> 00:33:29.000
我如何使它工作

00:33:27.200 --> 00:33:33.440
示例是XML目录API 

00:33:29.000 --> 00:33:35.389
 9中引入的标准API 

00:33:33.440 --> 00:33:38.059
避免不得不侵入内部

00:33:35.389 --> 00:33:40.460
 XML解析器代码的一部分

00:33:38.059 --> 00:33:43.659
图书馆这样做是出于动机

00:33:40.460 --> 00:33:46.820
用于多版本并具有jar文件

00:33:43.659 --> 00:33:49.039
所以多版本jar文件的作用是

00:33:46.820 --> 00:33:51.769
他们扩展了jar格式以允许

00:33:49.039 --> 00:33:55.480
多个Java特定版本类

00:33:51.769 --> 00:33:59.059
文件要共存于同一档案中，并且

00:33:55.480 --> 00:34:02.299
我将举例说明

00:33:59.059 --> 00:34:06.230
一秒钟，所以我们从这个开始

00:34:02.299 --> 00:34:09.169
这是一个使用jar工具的示例

00:34:06.230 --> 00:34:11.810
创建一个jar文件，我要

00:34:09.169 --> 00:34:13.909
使用G RTF来获取表格

00:34:11.810 --> 00:34:15.710
内容不新鲜这些是

00:34:13.909 --> 00:34:17.480
这是这些旧选项

00:34:15.710 --> 00:34:18.889
您可以为jar工具指定

00:34:17.480 --> 00:34:20.570
最近20年，这就是您的创造方式

00:34:18.889 --> 00:34:21.649
命令行上的jar文件是

00:34:20.570 --> 00:34:26.060
您实际上如何获得

00:34:21.649 --> 00:34:27.859
现在让我们向其中添加一些选项

00:34:26.060 --> 00:34:32.359
 jar工具，因为要知道的jar 

00:34:27.859 --> 00:34:34.280
关于多释放罐，我已经添加了

00:34:32.359 --> 00:34:37.369
当我创建jar文件时-- 

00:34:34.280 --> 00:34:38.899
发行9 +-c，然后我给它一个

00:34:37.369 --> 00:34:41.030
我所在的完全不同的目录

00:34:38.899 --> 00:34:44.240
会找到一些编译类

00:34:41.030 --> 00:34:47.540
 jdk 9，让我们看看

00:34:44.240 --> 00:34:50.089
 jar文件，看看发生了什么

00:34:47.540 --> 00:34:52.669
 jar工具打包了这些类

00:34:50.089 --> 00:34:54.319
并将它们放到

00:34:52.669 --> 00:34:57.470
版本的jar文件

00:34:54.319 --> 00:34:59.300
部分meta-inf这样的版本斜杠和

00:34:57.470 --> 00:35:02.690
然后是版本号

00:34:59.300 --> 00:35:05.329
在这种情况下，进入第9版

00:35:02.690 --> 00:35:08.690
紧密地，您实际上会看到

00:35:05.329 --> 00:35:11.270
两个com Acme stats CLI帮助程序类

00:35:08.690 --> 00:35:13.910
该jar文件中的文件在基础中的一个

00:35:11.270 --> 00:35:15.950
版本部分中的第一部分

00:35:13.910 --> 00:35:18.440
这很有趣，我上课了

00:35:15.950 --> 00:35:21.190
我想在此使用九

00:35:18.440 --> 00:35:21.190
版本部分

00:35:21.730 --> 00:35:28.660
现在假设我将这个jar文件放在

00:35:25.750 --> 00:35:31.329
具有8个类的类路径

00:35:28.660 --> 00:35:34.329
加载的要加载的类是

00:35:31.329 --> 00:35:36.640
从jdk年龄段及更高年龄段开始

00:35:34.329 --> 00:35:38.859
不知道多释放罐

00:35:36.640 --> 00:35:42.450
它永远不会尝试加载类

00:35:38.859 --> 00:35:45.040
从meta-inf版本9第i部分

00:35:42.450 --> 00:35:49.839
将jar文件放在类路径上

00:35:45.040 --> 00:35:52.150
 9神奇的是

00:35:49.839 --> 00:35:55.170
版本部分中的类将

00:35:52.150 --> 00:35:57.490
覆盖基础部分中的类

00:35:55.170 --> 00:36:00.220
所以这实际上非常有用，因为

00:35:57.490 --> 00:36:03.280
这意味着我可以将图书馆作为一个多

00:36:00.220 --> 00:36:04.480
放罐子，我可以用一个

00:36:03.280 --> 00:36:07.030
八位时的代码版本

00:36:04.480 --> 00:36:08.740
和，并使用较新的api 

00:36:07.030 --> 00:36:11.200
我在跑步时编译为九

00:36:08.740 --> 00:36:15.250
九点，所以这实际上是真的

00:36:11.200 --> 00:36:18.910
有用的移民帮助

00:36:15.250 --> 00:36:21.910
引入复杂的复杂性，因为

00:36:18.910 --> 00:36:24.130
我现在要有M个不同的来源

00:36:21.910 --> 00:36:26.530
不同的源树不同的编译

00:36:24.130 --> 00:36:27.880
树木，但不用担心

00:36:26.530 --> 00:36:30.880
有一些好的食谱

00:36:27.880 --> 00:36:33.190
在那里，罗伯特·舒尔特（Robert Schulte）在说话

00:36:30.880 --> 00:36:34.930
在其他房间之一

00:36:33.190 --> 00:36:37.480
关于Maven和与之集成的主题

00:36:34.930 --> 00:36:39.730
 JDK 9我不知道他们如何结局

00:36:37.480 --> 00:36:42.400
让我们在同一时间安排

00:36:39.730 --> 00:36:46.869
但是他要去D展示一个

00:36:42.400 --> 00:36:48.640
这个时候我正在使用Maven和

00:36:46.869 --> 00:36:51.400
他创造的一些食谱

00:36:48.640 --> 00:36:53.890
多发布jar文件是另一回事

00:36:51.400 --> 00:36:57.550
我真的想在这里观察

00:36:53.890 --> 00:36:59.170
是我现在正在为8编译代码

00:36:57.550 --> 00:37:01.869
然后我将要编译

00:36:59.170 --> 00:37:03.880
 9的课程是否表示我

00:37:01.869 --> 00:37:05.589
现在最终不得不在我的J衰变中

00:37:03.880 --> 00:37:08.530
建立一个痛苦的环境

00:37:05.589 --> 00:37:10.690
这是另一个杰夫来的地方

00:37:08.530 --> 00:37:13.030
在247个已编译的较旧版本中计数

00:37:10.690 --> 00:37:15.359
进来是因为它可以帮助您

00:37:13.030 --> 00:37:15.359
问题

00:37:16.290 --> 00:37:21.940
我们最后问问题，所以

00:37:19.440 --> 00:37:25.240
历史上，如果您要编译到

00:37:21.940 --> 00:37:27.130
旧版本，您必须指定三个

00:37:25.240 --> 00:37:31.000
选项-来源

00:37:27.130 --> 00:37:34.030
 -目标-引导类路径，大多数人

00:37:31.000 --> 00:37:35.830
忘记第三个，这就是为什么

00:37:34.030 --> 00:37:37.570
 Java C编译器已省略

00:37:35.830 --> 00:37:40.119
警告，我认为从8:00开始， 

00:37:37.570 --> 00:37:46.869
因为它创造了一些真正的

00:37:40.119 --> 00:37:49.990
用您替换的JDK 9有问题的案例

00:37:46.869 --> 00:37:54.040
所有这些都通过--发布，然后

00:37:49.990 --> 00:37:58.510
您可以使用JDK 9s Java C的版本

00:37:54.040 --> 00:38:01.960
编译成六七八八或九

00:37:58.510 --> 00:38:04.450
 Java C有足够的信息要知道

00:38:01.960 --> 00:38:07.720
六个API中的公开API是什么

00:38:04.450 --> 00:38:09.730
八点和九点，如果有的话

00:38:07.720 --> 00:38:11.350
一些API，您尝试将其编译为

00:38:09.730 --> 00:38:12.640
七个，但该API是在

00:38:11.350 --> 00:38:14.110
第八，那么它实际上会失败

00:38:12.640 --> 00:38:18.010
编译，所以它真的是

00:38:14.110 --> 00:38:19.390
意识到你有用的东西

00:38:18.010 --> 00:38:21.250
那一个多放罐子，你

00:38:19.390 --> 00:38:25.810
实际上有一个很好的解决方案， 

00:38:21.250 --> 00:38:28.180
迁移的绝佳组合

00:38:25.810 --> 00:38:31.660
我只想提及的其他工具是JD 

00:38:28.180 --> 00:38:34.450
 / scan这是JD案例中的新工具

00:38:31.660 --> 00:38:36.820
 J tk9用于执行静态分析，例如

00:38:34.450 --> 00:38:39.220
 Jade EPS，它扫描类

00:38:36.820 --> 00:38:42.010
不推荐使用的API，这成为

00:38:39.220 --> 00:38:44.350
弃用真的非常重要

00:38:42.010 --> 00:38:45.940
删除，因为你想知道

00:38:44.350 --> 00:38:49.030
你正在使用的东西

00:38:45.940 --> 00:38:50.950
如果您看到博士，则标记为已删除

00:38:49.030 --> 00:38:52.780
弃用的是走来走去

00:38:50.950 --> 00:38:55.030
会议上他穿着白大褂， 

00:38:52.780 --> 00:38:58.680
听诊器一定要问他关于GD 

00:38:55.030 --> 00:39:02.619
 /扫描，他会和你谈谈

00:38:58.680 --> 00:39:06.550
所以我该怎么做才能准备JDK 9:00 

00:39:02.619 --> 00:39:08.920
最重要的是

00:39:06.550 --> 00:39:12.640
升级工具和库

00:39:08.920 --> 00:39:15.010
某些版本支持JDK 9 

00:39:12.640 --> 00:39:16.540
不幸的是，这可能是全栈

00:39:15.010 --> 00:39:18.490
升级，尤其是如果您年龄较大

00:39:16.540 --> 00:39:20.770
版本真的是某些版本的旧版本

00:39:18.490 --> 00:39:22.540
工具，如果你只做一件事情

00:39:20.770 --> 00:39:24.430
在本次会议中，您将需要

00:39:22.540 --> 00:39:26.140
升级许多图书馆， 

00:39:24.430 --> 00:39:28.030
工具，如果您在执行此操作之前

00:39:26.140 --> 00:39:28.990
升级到JDK 9，您将省去很多麻烦

00:39:28.030 --> 00:39:32.860
很多

00:39:28.990 --> 00:39:34.540
挫败共享的模块

00:39:32.860 --> 00:39:36.180
我列出的EE 

00:39:34.540 --> 00:39:38.710
在演讲的前面是

00:39:36.180 --> 00:39:40.930
属性确实对

00:39:38.710 --> 00:39:43.390
那些依赖那些模块的

00:39:40.930 --> 00:39:44.650
有几个迁移选项， 

00:39:43.390 --> 00:39:48.820
你可以找出想要的方式

00:39:44.650 --> 00:39:51.160
真正使用Jade EPS工具

00:39:48.820 --> 00:39:52.750
有用并且能够分析

00:39:51.160 --> 00:39:56.080
您的代码以查看是否正在使用任何

00:39:52.750 --> 00:39:58.060
任何内部api的JDK 9试用

00:39:56.080 --> 00:39:59.890
寻找合法的反射访问

00:39:58.060 --> 00:40:01.990
警告并提交错误

00:39:59.890 --> 00:40:04.270
重要的是，这样的代码是

00:40:01.990 --> 00:40:05.650
做这些淘气的事情可以是

00:40:04.270 --> 00:40:08.680
那些坚持认为

00:40:05.650 --> 00:40:11.100
代码，如果您解析类使这些无效

00:40:08.680 --> 00:40:13.720
是Java版本， 

00:40:11.100 --> 00:40:16.480
物业，请重新访问该代码

00:40:13.720 --> 00:40:18.340
因为可能性很高

00:40:16.480 --> 00:40:19.960
它可能无法在9中使用并阅读

00:40:18.340 --> 00:40:25.450
发行说明没有人阅读发行

00:40:19.960 --> 00:40:28.720
注释JDK 9具有43页的发行版

00:40:25.450 --> 00:40:30.280
注意这可能是任何问题

00:40:28.720 --> 00:40:31.420
你学习可以实际上你会

00:40:30.280 --> 00:40:33.100
实际找到发行说明会

00:40:31.420 --> 00:40:34.630
实际上会详细说明

00:40:33.100 --> 00:40:36.970
里面有很多细节

00:40:34.630 --> 00:40:39.100
那里的地图绝大多数

00:40:36.970 --> 00:40:41.050
细节和那些问题

00:40:39.100 --> 00:40:42.640
发行说明与

00:40:41.050 --> 00:40:47.670
发行说明和相同级别的

00:40:42.640 --> 00:40:51.340
您将在7和8中看到的更改

00:40:47.670 --> 00:40:53.859
您如何为发布JDK 9做准备，为什么

00:40:51.340 --> 00:40:55.390
我本周谈论的是JDK 9发布

00:40:53.859 --> 00:40:56.680
您将听到有关提议的

00:40:55.390 --> 00:40:58.330
一个新的发行模型，其中有一个

00:40:56.680 --> 00:41:01.480
主要版本或小于

00:40:58.330 --> 00:41:05.500
我们每六个月所做的工作

00:41:01.480 --> 00:41:10.359
这意味着事情将会

00:41:05.500 --> 00:41:14.830
我们希望移动得更快，这意味着我们

00:41:10.359 --> 00:41:17.290
将有机会最后工作

00:41:14.830 --> 00:41:19.390
通过有关删除的最终步骤

00:41:17.290 --> 00:41:21.010
与Java EE共享的模块

00:41:19.390 --> 00:41:22.600
这意味着您需要弄清楚

00:41:21.010 --> 00:41:24.760
您将如何迁移到

00:41:22.600 --> 00:41:28.000
独立版本再次运行Jade EPS 

00:41:24.760 --> 00:41:30.510
真的非常重要，没有

00:41:28.000 --> 00:41:34.390
拟议的计划，但我们最终将如何

00:41:30.510 --> 00:41:36.790
在运行时封装api 

00:41:34.390 --> 00:41:38.470
警告并允许代码和类

00:41:36.790 --> 00:41:41.079
继续黑客的道路将

00:41:38.470 --> 00:41:42.550
将是你有一个九，但

00:41:41.079 --> 00:41:44.310
最终我们要讲到重点

00:41:42.550 --> 00:41:47.680
内部结构完全

00:41:44.310 --> 00:41:49.450
封装运行非法访问

00:41:47.680 --> 00:41:53.650
哦，我看到一种应该是的空气

00:41:49.450 --> 00:41:56.680
我当然会和非法访问

00:41:53.650 --> 00:41:59.470
平等否认可以让您测试未来

00:41:56.680 --> 00:42:01.480
现在就行动，因为它会拒绝访问

00:41:59.470 --> 00:42:04.270
这意味着试图调皮的代码

00:42:01.480 --> 00:42:06.069
事情会变得正确和违法

00:42:04.270 --> 00:42:09.220
访问错误非法行为

00:42:06.069 --> 00:42:10.660
再次成为不可访问的对象异常

00:42:09.220 --> 00:42:12.130
审核您的代码以获取版本字符串

00:42:10.660 --> 00:42:15.280
特别是如果版本字符串更改

00:42:12.130 --> 00:42:18.010
再次测试EA帐单，我认为这

00:42:15.280 --> 00:42:20.260
实际上我们发现这个最多

00:42:18.010 --> 00:42:22.359
有用的九个EA账单

00:42:20.260 --> 00:42:24.250
可以使用早期访问账单吧

00:42:22.359 --> 00:42:26.770
从一开始，每个构建实际上都是

00:42:24.250 --> 00:42:28.869
发布，并允许云

00:42:26.770 --> 00:42:31.030
库和维护者实际上

00:42:28.869 --> 00:42:34.329
从一开始就与我们合作并达成协议

00:42:31.030 --> 00:42:36.220
处理问题，所以总结大多数代码

00:42:34.329 --> 00:42:37.480
可以在线工作而无需更改

00:42:36.220 --> 00:42:39.300
谈到很少的变化

00:42:37.480 --> 00:42:43.630
实际上需要代码，除了

00:42:39.300 --> 00:42:45.790
部分多云，Java版本为JDK 

00:42:43.630 --> 00:42:47.380
九个确实包括一些破坏性的

00:42:45.790 --> 00:42:49.780
我认为我涵盖了大多数变化

00:42:47.380 --> 00:42:51.339
这些更改，并再次确保您

00:42:49.780 --> 00:42:54.210
升级您的工具和库

00:42:51.339 --> 00:42:57.010
提前避免大多数问题

00:42:54.210 --> 00:43:00.460
这是最重要的信息

00:42:57.010 --> 00:43:05.500
此演示文稿，以便更多信息

00:43:00.460 --> 00:43:08.230
 JDK 9有一个开放的JDK有一个

00:43:05.500 --> 00:43:09.550
项目JDK 9，您将看到所有

00:43:08.230 --> 00:43:10.390
我在开始时展示的筹码

00:43:09.550 --> 00:43:13.240
这个演讲

00:43:10.390 --> 00:43:15.490
这些筹码真的充满了

00:43:13.240 --> 00:43:17.200
有空的话有用的信息

00:43:15.490 --> 00:43:19.000
要阅读它，有一个迁移指南

00:43:17.200 --> 00:43:21.460
其实还不错

00:43:19.000 --> 00:43:23.530
涵盖了您的大部分主要问题

00:43:21.460 --> 00:43:26.560
可能会碰到很多

00:43:23.530 --> 00:43:29.740
关于JDK 9的会议本周是如此

00:43:26.560 --> 00:43:32.550
并尝试参加那些，如果你现在可以的话

00:43:29.740 --> 00:43:33.849
只是提醒我们的会议

00:43:32.550 --> 00:43:36.069
我

00:43:33.849 --> 00:43:39.250
亚历克斯·巴克利·马克·莱因霍尔德我们有5 

00:43:36.069 --> 00:43:41.310
会议在这个房间里，而亚历克斯正在做

00:43:39.250 --> 00:43:44.520
在这里使用JDK 9开发模块

00:43:41.310 --> 00:43:46.839
今天晚上5:30在做

00:43:44.520 --> 00:43:49.569
一课中的模块并迁移到

00:43:46.839 --> 00:43:50.420
明天11:30在这个房间里的模块

00:43:49.569 --> 00:43:53.359
和150 

00:43:50.420 --> 00:43:56.269
然后亚历克斯在星期三回到

00:43:53.359 --> 00:43:58.640
 9：30做模块和服务等等

00:43:56.269 --> 00:44:00.410
那就是那届会议

00:43:58.640 --> 00:44:03.619
我想插入，因为这是我们

00:44:00.410 --> 00:44:06.950
被困在一条轨道上基本上停留

00:44:03.619 --> 00:44:09.559
连接并且有一个DevOps角落

00:44:06.950 --> 00:44:12.380
那些在这里工作的人

00:44:09.559 --> 00:44:16.010
 JDK将在

00:44:12.380 --> 00:44:18.410
接下来的几天以及一些链接

00:44:16.010 --> 00:44:20.329
也不要相信我

00:44:18.410 --> 00:44:23.059
说请不要购买任何基于

00:44:20.329 --> 00:44:25.640
我说的任何话就是这样

00:44:23.059 --> 00:44:27.769
让我们看看我们有一两分钟的时间

00:44:25.640 --> 00:44:29.450
问题，我不知道是否

00:44:27.769 --> 00:44:33.440
这里没有麦克风，所以我会

00:44:29.450 --> 00:44:34.519
如果是这样，必须重复您的问题

00:44:33.440 --> 00:44:47.059
那是因为我们实际上是

00:44:34.519 --> 00:44:49.460
记录在这里好吧，所以问题是

00:44:47.059 --> 00:44:54.529
对于这个jar文件，当我

00:44:49.460 --> 00:44:56.569
在十点左右，或者在18.3点这样

00:44:54.529 --> 00:44:59.750
这种情况是假设

00:44:56.569 --> 00:45:01.309
不是一个十个有四个的部分

00:44:59.750 --> 00:45:02.960
或18.3，它将直接转到

00:45:01.309 --> 00:45:05.029
以前的版本是九个，所以这个

00:45:02.960 --> 00:45:08.180
它将加载主

00:45:05.029 --> 00:45:10.640
基础部分的课程，它将

00:45:08.180 --> 00:45:13.150
从版本加载帮助程序类

00:45:10.640 --> 00:45:13.150
部分

00:45:24.360 --> 00:45:29.290
对不起，汤姆，我不是很了解你

00:45:26.980 --> 00:45:31.270
 jar文件的大小还可以，所以我

00:45:29.290 --> 00:45:32.530
认为问题就像罐子一样

00:45:31.270 --> 00:45:34.810
这些额外的文件变得更大

00:45:32.530 --> 00:45:37.060
类，是的，那是因为

00:45:34.810 --> 00:45:45.820
它与jar文件的大小成正比

00:45:37.060 --> 00:45:47.530
到它的条目数还可以

00:45:45.820 --> 00:45:50.710
所以问题是这个例子

00:45:47.530 --> 00:45:52.540
为什么是主要阶级而不是

00:45:50.710 --> 00:45:57.970
反转部分，因此对于此特定

00:45:52.540 --> 00:45:59.920
例如主类没有

00:45:57.970 --> 00:46:03.130
任何JDK 9特定代码，仅此而已

00:45:59.920 --> 00:46:04.930
用于此的帮助程序类

00:46:03.130 --> 00:46:06.250
例如我做的辅助类有

00:46:04.930 --> 00:46:09.880
九个特定的代码，所以有两个

00:46:06.250 --> 00:46:11.740
助手类的版本权利

00:46:09.880 --> 00:46:13.540
确实是某人

00:46:11.740 --> 00:46:24.400
刚出去有点像覆盖和

00:46:13.540 --> 00:46:25.780
修补好，所以问题是

00:46:24.400 --> 00:46:29.260
正如我提到的与

00:46:25.780 --> 00:46:31.930
和e模块，所以有一个

00:46:29.260 --> 00:46:33.220
一个你想让我扩展这一点

00:46:31.930 --> 00:46:35.080
是几个领域之一是

00:46:33.220 --> 00:46:37.240
真正的交易API 

00:46:35.080 --> 00:46:39.820
有问题的Java C，您需要找到一个

00:46:37.240 --> 00:46:41.520
交易API的一小部分，如果

00:46:39.820 --> 00:46:43.900
你看Javik交易， 

00:46:41.520 --> 00:46:45.400
 Java C中的软件包，您只会看到

00:46:43.900 --> 00:46:47.260
那里的三个例外

00:46:45.400 --> 00:46:50.680
实际需要的最小数量

00:46:47.260 --> 00:46:53.410
 Java的理想和规格，以支持

00:46:50.680 --> 00:46:56.410
 CORBA事务异常的映射

00:46:53.410 --> 00:46:58.600
远程异常和另一个

00:46:56.410 --> 00:47:01.660
问题区域是所谓的共同点

00:46:58.600 --> 00:47:04.060
 Java C定义的注释是

00:47:01.660 --> 00:47:05.950
这些注释的最小子集

00:47:04.060 --> 00:47:09.250
支持网络服务，因此它们确实

00:47:05.950 --> 00:47:13.380
确实有问题的地区，所以他们

00:47:09.250 --> 00:47:13.380
他们将是两个主要问题领域

00:47:22.770 --> 00:47:30.790
好吧，我认为问题是

00:47:25.060 --> 00:47:32.530
是关于加密货币提供商的，所以

00:47:30.790 --> 00:47:34.330
他们应该这样做，所以加密

00:47:32.530 --> 00:47:38.440
提供者（如果已部署）应该

00:47:34.330 --> 00:47:40.720
像以前一样在其中工作

00:47:38.440 --> 00:47:42.670
 jce已更新，能够

00:47:40.720 --> 00:47:49.120
支持将加密提供商部署为

00:47:42.670 --> 00:47:53.770
模块以及其他任何问题

00:47:49.120 --> 00:47:54.600
好吧，我想我们已经完成了，谢谢

00:47:53.770 --> 00:47:59.460
你参加

00:47:54.600 --> 00:47:59.460
 [掌声] 

