WEBVTT
Kind: captions
Language: zh-Hans

00:00:05.209 --> 00:00:14.520
欢迎大家参加第五届

00:00:09.900 --> 00:00:18.240
五个拼图谈判项目下的拼图

00:00:14.520 --> 00:00:23.700
曾经去过的引擎盖快速民意调查

00:00:18.240 --> 00:00:26.010
五只少量的手还可以

00:00:23.700 --> 00:00:28.110
人们已经战斗好了是是是

00:00:26.010 --> 00:00:29.310
所以人们有一个严重的

00:00:28.110 --> 00:00:31.430
问题人们一直在采摘， 

00:00:29.310 --> 00:00:34.590
选择何时我们有一系列

00:00:31.430 --> 00:00:37.829
人们一直在拼图游戏

00:00:34.590 --> 00:00:41.039
然后选择要去的

00:00:37.829 --> 00:00:44.280
好吧，有趣的是，我们所有人都有另一个

00:00:41.039 --> 00:00:46.679
五星级，我们有25 *参加者

00:00:44.280 --> 00:00:53.909
前我想你可能去过

00:00:46.679 --> 00:00:55.589
他们五个全部一次两次

00:00:53.909 --> 00:01:01.709
你在第五个，让我们一起去

00:00:55.589 --> 00:01:03.269
他们还可以，所以我叫亚历克斯

00:01:01.709 --> 00:01:07.020
 Buckley我在Java平台上工作

00:01:03.269 --> 00:01:09.300
甲骨文团队，这是最深的

00:01:07.020 --> 00:01:11.280
潜入幕后

00:01:09.300 --> 00:01:14.340
课堂上到底发生了什么

00:01:11.280 --> 00:01:16.260
吉达犬的装载机试图

00:01:14.340 --> 00:01:19.740
解释一些

00:01:16.260 --> 00:01:22.620
您可能在其他人听到的陈述

00:01:19.740 --> 00:01:26.100
谈论谈论喷气式飞机

00:01:22.620 --> 00:01:27.650
在jdk 9中有时会有些陈述

00:01:26.100 --> 00:01:31.230
看起来有点混乱

00:01:27.650 --> 00:01:36.720
我希望这个演讲能解释什么

00:01:31.230 --> 00:01:39.360
真的在jdk九中进行了，但是

00:01:36.720 --> 00:01:41.730
独立存在，所以我仍然需要介绍

00:01:39.360 --> 00:01:44.190
在JDK 9中，主要功能是

00:01:41.730 --> 00:01:47.640
模块系统让我们的代码更多

00:01:44.190 --> 00:01:50.159
可靠且可维护，我们使用了

00:01:47.640 --> 00:01:53.520
模块系统转向单片JDK 

00:01:50.159 --> 00:01:56.700
进入正在分解的模块化JDK 

00:01:53.520 --> 00:02:00.810
将JDK中的RT jar文件放入

00:01:56.700 --> 00:02:02.880
数十个可重用模块jdk 9也

00:02:00.810 --> 00:02:04.979
对Java有一些小的增强

00:02:02.880 --> 00:02:07.700
语言和更大

00:02:04.979 --> 00:02:12.420
加强标准劳动，再加上

00:02:07.700 --> 00:02:16.889
 Javadoc通过J获取搜索框和JDK 

00:02:12.420 --> 00:02:18.240
外壳在最后一轮中包含波纹

00:02:16.889 --> 00:02:25.350
掌声我能听到

00:02:18.240 --> 00:02:28.590
在我的头上啊，所以项目X还是一个

00:02:25.350 --> 00:02:30.170
由Oracle在OpenJDK中领导的项目

00:02:28.590 --> 00:02:32.250
我们所有工作的容器

00:02:30.170 --> 00:02:35.370
建立一个模块系统

00:02:32.250 --> 00:02:37.350
模块化我们正在标准化的JDK 

00:02:35.370 --> 00:02:41.040
 java社区中的模块系统

00:02:37.350 --> 00:02:42.630
通过jsr 376处理，我们

00:02:41.040 --> 00:02:45.090
规范结构

00:02:42.630 --> 00:02:48.000
 Java社区中的模块化JDK 

00:02:45.090 --> 00:02:52.740
通过伞jsr处理

00:02:48.000 --> 00:02:54.840
 Java SE 9，因此当您使用JDK 9时

00:02:52.740 --> 00:02:56.700
始终遵守

00:02:54.840 --> 00:02:59.040
模块系统就是

00:02:56.700 --> 00:03:03.000
引擎盖，这就是本讲的大部分内容

00:02:59.040 --> 00:03:05.190
关于他们将涉及一些方面

00:03:03.000 --> 00:03:09.420
模块化JDK在附近的影响

00:03:05.190 --> 00:03:11.160
最后，本演讲分为四个部分

00:03:09.420 --> 00:03:13.200
第一部分解释模块

00:03:11.160 --> 00:03:15.660
系统与Java语言一起使用，并且

00:03:13.200 --> 00:03:18.300
 vm提高您的可靠性

00:03:15.660 --> 00:03:21.480
代码第二部分是关于

00:03:18.300 --> 00:03:23.310
迁移到模块第三部分

00:03:21.480 --> 00:03:25.500
解释什么是模块系统

00:03:23.310 --> 00:03:28.260
根本有能力超越你

00:03:25.500 --> 00:03:30.780
可以用Java语言和

00:03:28.260 --> 00:03:33.060
第四部分是关于通往jdk的道路

00:03:30.780 --> 00:03:37.620
九，有些事情你应该

00:03:33.060 --> 00:03:43.740
在旅行时要当心

00:03:37.620 --> 00:03:45.750
第一部分，每个人都知道层次结构

00:03:43.740 --> 00:03:49.860
语言的可访问性

00:03:45.750 --> 00:03:52.110
和vm易于理解，易于理解

00:03:49.860 --> 00:03:56.370
使用并强烈执行

00:03:52.110 --> 00:03:59.340
编译器和虚拟机，但它有一个很大的

00:03:56.370 --> 00:04:03.990
弱点是共享代码的唯一方法

00:03:59.340 --> 00:04:07.200
包之间是公共的，但是

00:04:03.990 --> 00:04:09.420
与所有人共享不是

00:04:07.200 --> 00:04:11.370
令人惊讶的包装友谊

00:04:09.420 --> 00:04:15.630
已要求一种或另一种形式

00:04:11.370 --> 00:04:17.370
这些年来，一个目标

00:04:15.630 --> 00:04:20.070
模块系统坚固

00:04:17.370 --> 00:04:22.710
封装以允许组件

00:04:20.070 --> 00:04:25.170
声明其公共类型是

00:04:22.710 --> 00:04:31.290
其他组件可以访问的

00:04:25.170 --> 00:04:32.100
不是斜体字的线是

00:04:31.290 --> 00:04:34.860
行为水平

00:04:32.100 --> 00:04:37.590
杰里犬的能力与

00:04:34.860 --> 00:04:40.560
模块系统向上读取

00:04:37.590 --> 00:04:43.640
可以安排公共类型

00:04:40.560 --> 00:04:46.230
只能在其模块内访问或

00:04:43.640 --> 00:04:49.400
在他们的模块和两个

00:04:46.230 --> 00:04:53.040
其他特定的朋友模块或

00:04:49.400 --> 00:04:57.150
每个人都可以接近，因为他受伤了

00:04:53.040 --> 00:04:59.790
吃了点东西，因为通常的迁移驱动了很多

00:04:57.150 --> 00:05:02.760
我们想让我们轻松一点

00:04:59.790 --> 00:05:05.610
将现有的包装放入

00:05:02.760 --> 00:05:08.430
模块并立即提供该软件包

00:05:05.610 --> 00:05:11.190
强封装的好处我们

00:05:08.430 --> 00:05:13.770
不想每个公共类型

00:05:11.190 --> 00:05:16.710
必须选择加入强

00:05:13.770 --> 00:05:20.220
封装，以便将公共类型

00:05:16.710 --> 00:05:25.230
包不能在外部访问

00:05:20.220 --> 00:05:27.690
默认情况下，该模块在

00:05:25.230 --> 00:05:31.440
类型声明不再意味着

00:05:27.690 --> 00:05:33.150
每个人都可以访问类型

00:05:31.440 --> 00:05:38.340
如果有人尝试访问

00:05:33.150 --> 00:05:41.280
在这里无法访问的公共类型

00:05:38.340 --> 00:05:44.220
稍微老化但很有趣

00:05:41.280 --> 00:05:47.160
当时来自glassfish 4.1的示例

00:05:44.220 --> 00:05:50.130
屏幕抓取未开始

00:05:47.160 --> 00:05:52.800
 jdk的九个因为vm通过

00:05:50.130 --> 00:05:54.870
我没想到有非法访问错误

00:05:52.800 --> 00:05:57.720
您将能够阅读铃声文本

00:05:54.870 --> 00:05:59.880
但它说非法访问错误类

00:05:57.720 --> 00:06:03.270
康信企业安全提供了

00:05:59.880 --> 00:06:05.840
未命名模块中的策略说唱歌手不要

00:06:03.270 --> 00:06:10.290
担心却无法上课

00:06:05.840 --> 00:06:13.590
中的Sun安全提供程序策略文件

00:06:10.290 --> 00:06:16.260
 Java模块的基础是

00:06:13.590 --> 00:06:20.220
子级安全提供程序策略文件

00:06:16.260 --> 00:06:23.550
被宣布为公开，但由于它是jdk 

00:06:20.220 --> 00:06:26.490
内部API，现在只能访问

00:06:23.550 --> 00:06:27.960
 Java基本模块中的对不起

00:06:26.490 --> 00:06:32.090
您需要找到一个玻璃鱼

00:06:27.960 --> 00:06:32.090
替代安全API 

00:06:34.630 --> 00:06:40.660
在jdk中，九个模块是一流的

00:06:38.020 --> 00:06:43.630
程序组件，例如类和

00:06:40.660 --> 00:06:46.350
接口是这里的声明

00:06:43.630 --> 00:06:49.510
包含JDBC的Java续集模块

00:06:46.350 --> 00:06:51.910
它在名为module info java的文件中

00:06:49.510 --> 00:06:54.400
在以模块命名的目录中

00:06:51.910 --> 00:06:57.040
厌倦或续集的编译器对待

00:06:54.400 --> 00:06:59.530
像其他任何Java文件一样进行翻译

00:06:57.040 --> 00:07:01.870
它到你的照相课中的模块

00:06:59.530 --> 00:07:05.770
可以像往常一样放入jar文件

00:07:01.870 --> 00:07:08.080
称模块罐为包装

00:07:05.770 --> 00:07:11.310
层次结构存在于同一目录中

00:07:08.080 --> 00:07:14.140
源Java续集作为模块信息java 

00:07:11.310 --> 00:07:16.870
所以Java的模块工作不在

00:07:14.140 --> 00:07:18.220
该模块中的所有软件包

00:07:16.870 --> 00:07:21.070
因为这是模块的工作

00:07:18.220 --> 00:07:24.430
声明是否包装

00:07:21.070 --> 00:07:27.370
高度封装或不容易

00:07:24.430 --> 00:07:29.530
获得强大的封装

00:07:27.370 --> 00:07:32.890
包裹中的类型不要提及

00:07:29.530 --> 00:07:36.070
包中的模块声明为

00:07:32.890 --> 00:07:37.600
允许其他模块访问其中之一

00:07:36.070 --> 00:07:40.270
您的包裹，或更具体地说

00:07:37.600 --> 00:07:43.810
您包的公开类型只需添加

00:07:40.270 --> 00:07:46.060
和出口条款，正如我所说，您可以

00:07:43.810 --> 00:07:49.110
照原样导出到所有其他模块

00:07:46.060 --> 00:07:51.460
发生在这里，或者您可以说出口到

00:07:49.110 --> 00:07:55.810
只允许访问您的朋友

00:07:51.460 --> 00:07:58.270
 Java Sea编译时的模块

00:07:55.810 --> 00:08:00.100
防止Java续集之外的代码

00:07:58.270 --> 00:08:02.590
访问公共类型的模块

00:08:00.100 --> 00:08:06.100
除了其中的任何软件包

00:08:02.590 --> 00:08:08.020
列出的三个包您得到相同的

00:08:06.100 --> 00:08:10.150
尝试时编译时间错误

00:08:08.020 --> 00:08:12.420
从访问包私有类型

00:08:10.150 --> 00:08:15.160
在几十年的时间里包装

00:08:12.420 --> 00:08:17.950
然后在运行时，如果您以某种方式构建了

00:08:15.160 --> 00:08:20.050
在运行时手动生成类文件

00:08:17.950 --> 00:08:22.000
虚拟机引发非法访问错误

00:08:20.050 --> 00:08:24.250
就像您尝试用玻璃鱼看到的一样

00:08:22.000 --> 00:08:27.160
访问任何事物的公共类型

00:08:24.250 --> 00:08:32.010
除了那三个包，让我们潜入

00:08:27.160 --> 00:08:34.510
传统上更深入地进入虚拟机

00:08:32.010 --> 00:08:37.150
 Java平台中的可访问性是

00:08:34.510 --> 00:08:39.789
关于谁在进行访问以及执行什么操作

00:08:37.150 --> 00:08:43.180
是受公共保护的私人标志

00:08:39.789 --> 00:08:45.310
 vm使用的运行时目标类

00:08:43.180 --> 00:08:48.260
访问类的类加载器

00:08:45.310 --> 00:08:50.900
查找并加载目标类

00:08:48.260 --> 00:08:53.890
然后虚拟机检查标志public 

00:08:50.900 --> 00:08:57.410
受保护的私有对象

00:08:53.890 --> 00:09:00.560
现在，因为虚拟机依赖于类

00:08:57.410 --> 00:09:03.440
装载机的人们可以创建装载机

00:09:00.560 --> 00:09:06.680
只知道如何查找和加载类

00:09:03.440 --> 00:09:09.440
效果加载程序中某些软件包的数量

00:09:06.680 --> 00:09:13.340
可以将一个包装与另一个包装隔离

00:09:09.440 --> 00:09:17.960
顶级图片类PC试图

00:09:13.340 --> 00:09:20.420
 PC加载程序知道的访问类QD 

00:09:17.960 --> 00:09:23.480
委托给我就好了

00:09:20.420 --> 00:09:27.500
知道委托给另一个装载者

00:09:23.480 --> 00:09:30.140
包Q中的任何类，例如仅QD 

00:09:27.500 --> 00:09:33.320
当其他装载者发现装载时

00:09:30.140 --> 00:09:36.050
 QD可以让vm检查其标志以

00:09:33.320 --> 00:09:39.610
确定它是否对POC足够公开

00:09:36.050 --> 00:09:44.360
现在可以在底部的图片中访问它

00:09:39.610 --> 00:09:48.020
 PC的加载器不知道在哪里

00:09:44.360 --> 00:09:51.950
找到包Q，因此无法访问QD 

00:09:48.020 --> 00:09:54.920
从技术上讲这可能不是从PC 

00:09:51.950 --> 00:09:57.380
自vm以来的可访问性失败

00:09:54.920 --> 00:10:00.470
从来没有真正加载

00:09:57.380 --> 00:10:03.860
检查QLD的标志，而是

00:10:00.470 --> 00:10:06.980
可见性故障QD对

00:10:03.860 --> 00:10:10.370
 PC，因为无法加载课程

00:10:06.980 --> 00:10:12.440
发现QD效果还是蛮不错的

00:10:10.370 --> 00:10:15.860
功能强大，如果

00:10:12.440 --> 00:10:17.510
访问类猫找不到和

00:10:15.860 --> 00:10:19.490
加载目标类，然后它不会

00:10:17.510 --> 00:10:23.120
目标类别是否公开是很重要的

00:10:19.490 --> 00:10:25.910
它被有效地封装，无论谁

00:10:23.120 --> 00:10:30.980
设置类加载器来设置

00:10:25.910 --> 00:10:33.140
有效封装的东西是

00:10:30.980 --> 00:10:35.780
尽管基于类的封装

00:10:33.140 --> 00:10:40.610
装载机封装不牢固

00:10:35.780 --> 00:10:42.710
 sadface它依赖于软件包

00:10:40.610 --> 00:10:45.440
仔细分配到不同

00:10:42.710 --> 00:10:47.750
加载程序，但JDK并非如此

00:10:45.440 --> 00:10:50.030
在JDK中曾经工作过的大多数代码是

00:10:47.750 --> 00:10:52.010
由引导程序或平台加载

00:10:50.030 --> 00:10:54.080
类加载器，而代码在

00:10:52.010 --> 00:10:57.500
 classpath全部由

00:10:54.080 --> 00:11:00.140
应用程序类加载器旋转起来

00:10:57.500 --> 00:11:01.730
所有这些代码的装载机

00:11:00.140 --> 00:11:03.800
尝试将其隔离并尝试

00:11:01.730 --> 00:11:06.949
封装将是兼容性

00:11:03.800 --> 00:11:09.860
噩梦，无论如何都没有

00:11:06.949 --> 00:11:11.959
您可以规避的实际隔离

00:11:09.860 --> 00:11:14.120
通过掌握类加载器

00:11:11.959 --> 00:11:15.800
对java.lang.class对象的引用

00:11:14.120 --> 00:11:18.110
您可以随时为任何对象执行的操作

00:11:15.800 --> 00:11:19.990
然后有了一个类对象

00:11:18.110 --> 00:11:23.180
类加载器是无关紧要的， 

00:11:19.990 --> 00:11:26.949
不可能停止引用

00:11:23.180 --> 00:11:30.139
类对象不被传递

00:11:26.949 --> 00:11:33.380
强大的封装能力

00:11:30.139 --> 00:11:35.540
防止访问，即使访问

00:11:33.380 --> 00:11:37.430
类和目标类在

00:11:35.540 --> 00:11:40.160
相同的类加载器，例如

00:11:37.430 --> 00:11:42.529
应用程序类加载器，即使

00:11:40.160 --> 00:11:48.829
有人正在使用核心反射

00:11:42.529 --> 00:11:51.019
操作类对象，所以让我们假设

00:11:48.829 --> 00:11:54.889
以某种方式映射了多个模块

00:11:51.019 --> 00:12:00.490
到同一个类加载器可以让你紧扣

00:11:54.889 --> 00:12:03.290
参见模块X中的访问QD模块中的QD 

00:12:00.490 --> 00:12:06.139
模块系统的另一个目标是

00:12:03.290 --> 00:12:08.449
可靠的依赖关系来取代

00:12:06.139 --> 00:12:11.000
易碎的易错类路径机制

00:12:08.449 --> 00:12:14.149
用程序组件的方式

00:12:11.000 --> 00:12:20.360
声明对一个的显式依赖

00:12:14.149 --> 00:12:24.170
以便PC访问QD 

00:12:20.360 --> 00:12:28.670
不仅模块y需要导出

00:12:24.170 --> 00:12:33.350
包q但模块X需要某种方式

00:12:28.670 --> 00:12:35.300
明确取决于模块为何

00:12:33.350 --> 00:12:39.130
依赖的正式名称是

00:12:35.300 --> 00:12:41.839
可读性可读性的基础

00:12:39.130 --> 00:12:47.389
 Java语言的可访问性和

00:12:41.839 --> 00:12:50.180
 9中的vm，访问类PC必须是

00:12:47.389 --> 00:12:52.040
在一个模块中读取

00:12:50.180 --> 00:12:55.279
读取模块的目标类为何

00:12:52.040 --> 00:12:58.250
和包含目标的模块

00:12:55.279 --> 00:13:02.620
类必须将其包导出到

00:12:58.250 --> 00:13:06.350
至少是访问类的模块

00:13:02.620 --> 00:13:09.110
因此可访问性是一条位于

00:13:06.350 --> 00:13:11.689
模块X读取模块ya模块y 

00:13:09.110 --> 00:13:13.580
将此有趣的包q导出到

00:13:11.689 --> 00:13:16.750
至少x 

00:13:13.580 --> 00:13:19.400
注意这些箭头

00:13:16.750 --> 00:13:21.050
可访问性与类无关

00:13:19.400 --> 00:13:22.910
装载机，我不需要谈论

00:13:21.050 --> 00:13:25.460
像这张幻灯片上的Otis类

00:13:22.910 --> 00:13:27.890
可访问性在模块之前

00:13:25.460 --> 00:13:30.950
系统很重要，有两个原因

00:13:27.890 --> 00:13:35.590
这意味着可访问性在编译时有效

00:13:30.950 --> 00:13:37.880
没有任何类加载器的时间

00:13:35.590 --> 00:13:40.520
其次，这意味着您可以推理

00:13:37.880 --> 00:13:43.340
可访问性完全基于

00:13:40.520 --> 00:13:45.110
模块中的require和export子句

00:13:43.340 --> 00:13:46.790
在Java照片文件中，无需

00:13:45.110 --> 00:13:50.180
担心哪些装载机会

00:13:46.790 --> 00:13:52.280
实际上存在一个运行时

00:13:50.180 --> 00:13:53.990
可访问性的出口部分是

00:13:52.280 --> 00:13:56.150
相当简单的软件包

00:13:53.990 --> 00:14:00.140
导出，或者不是，但可读性强

00:13:56.150 --> 00:14:02.930
当您依靠一个

00:14:00.140 --> 00:14:05.030
您希望依靠的模块

00:14:02.930 --> 00:14:09.230
连贯的软件包集

00:14:05.030 --> 00:14:12.110
从某种意义上说出口就是表面

00:14:09.230 --> 00:14:15.470
这些软件包是

00:14:12.110 --> 00:14:17.810
模块内的模块数以百计

00:14:15.470 --> 00:14:21.260
包可能被牢固地封装

00:14:17.810 --> 00:14:24.350
没有导出不为您等待帮助

00:14:21.260 --> 00:14:27.050
实现该接口

00:14:24.350 --> 00:14:29.270
当你依赖一个模块

00:14:27.050 --> 00:14:33.860
间接依赖于所有模块

00:14:29.270 --> 00:14:37.430
这取决于例如你是否依赖

00:14:33.860 --> 00:14:41.150
在JDK中的Java激活模块上

00:14:37.430 --> 00:14:44.450
有35个班级，那么您间接地

00:14:41.150 --> 00:14:49.700
取决于Java桌面模块

00:14:44.450 --> 00:14:53.270
 jdk及其5835类，如果

00:14:49.700 --> 00:14:55.730
当时，JDK 8的口号已经开始运作

00:14:53.270 --> 00:14:57.650
对于JD k9，该标语是可传递的

00:14:55.730 --> 00:15:00.830
你应该考虑一套

00:14:57.650 --> 00:15:03.430
您的传递需要的模块

00:15:00.830 --> 00:15:06.410
间接的应用程序

00:15:03.430 --> 00:15:09.200
依赖可能与

00:15:06.410 --> 00:15:13.640
直接依赖关系让我们看看如何

00:15:09.200 --> 00:15:16.070
可读性模型，我将使用

00:15:13.640 --> 00:15:19.610
图表的可读性示例

00:15:16.070 --> 00:15:23.150
 JDK将Java续集模块

00:15:19.610 --> 00:15:24.800
持有JDBC需要Java登录

00:15:23.150 --> 00:15:27.160
导出包的模块

00:15:24.800 --> 00:15:30.950
 java.util日志记录

00:15:27.160 --> 00:15:33.080
这需要条款意味着

00:15:30.950 --> 00:15:35.420
 Java续集模块可以访问

00:15:33.080 --> 00:15:37.700
 Java util日志记录的公共类型，例如

00:15:35.420 --> 00:15:40.220
作为记录器，您可以看到其中的一些代码

00:15:37.700 --> 00:15:45.160
上的JDBC驱动程序管理器类

00:15:40.220 --> 00:15:45.160
左是更新一个更大的罚款实例

00:15:45.280 --> 00:15:49.940
如果是Java的API怎么办

00:15:48.230 --> 00:15:51.920
续集模块而不是其

00:15:49.940 --> 00:15:53.510
想要使用

00:15:51.920 --> 00:15:55.640
换句话说，小盒上的标识

00:15:53.510 --> 00:15:58.460
方法签名公共方法

00:15:55.640 --> 00:16:01.670
公共接口的签名作者

00:15:58.460 --> 00:16:04.400
在导出的包中，如果那样

00:16:01.670 --> 00:16:08.570
 API要引用标识

00:16:04.400 --> 00:16:10.820
而不是某些方法主体，所以这里

00:16:08.570 --> 00:16:15.470
 JDBC驱动程序接口要返回一个

00:16:10.820 --> 00:16:17.960
记录器让我们通过

00:16:15.470 --> 00:16:22.160
使用的应用程序模块的眼睛

00:16:17.960 --> 00:16:23.900
 JDBC我的应用程序为了使用它干

00:16:22.160 --> 00:16:26.930
调用返回的驱动程序方法

00:16:23.900 --> 00:16:30.140
记录器不仅是我的应用程序模块

00:16:26.930 --> 00:16:32.810
需要阅读Java续集模块，但是

00:16:30.140 --> 00:16:36.230
还有Java日志记录模块

00:16:32.810 --> 00:16:38.540
出口记录器，如果

00:16:36.230 --> 00:16:41.780
我的应用程序的开发人员必须记住

00:16:38.540 --> 00:16:43.850
说当使用

00:16:41.780 --> 00:16:50.210
 Java api的特定部分

00:16:43.850 --> 00:16:52.400
续集悲伤的面孔有个好消息

00:16:50.210 --> 00:16:57.530
 java续集模块可以承担

00:16:52.400 --> 00:16:59.930
记住看的责任

00:16:57.530 --> 00:17:04.040
现在说的Java续集模块

00:16:59.930 --> 00:17:05.930
需要传递Java点记录

00:17:04.040 --> 00:17:09.280
这里的“可及”一词意味着任何人

00:17:05.930 --> 00:17:12.820
谁也阅读Java续集模块

00:17:09.280 --> 00:17:15.829
免费读取Java日志记录模块

00:17:12.820 --> 00:17:18.500
我的应用模块不再需要

00:17:15.829 --> 00:17:21.140
麻烦需要Java日志记录

00:17:18.500 --> 00:17:25.189
因为它读取Java日志记录，这要归功于

00:17:21.140 --> 00:17:27.500
读java续集笑脸这是

00:17:25.189 --> 00:17:33.020
称为隐式可读性，这非常

00:17:27.500 --> 00:17:36.080
功能强大，功能强大，因为它可以让

00:17:33.020 --> 00:17:38.900
重构模块而不中断

00:17:36.080 --> 00:17:39.940
例如，消费者假设Java 

00:17:38.900 --> 00:17:42.070
测井

00:17:39.940 --> 00:17:44.139
有一些辅助软件包，我们会

00:17:42.070 --> 00:17:47.409
喜欢开始单独发货

00:17:44.139 --> 00:17:51.159
模块日志额外的东西在其中一些

00:17:47.409 --> 00:17:53.440
导出Java日志记录模块可以说

00:17:51.159 --> 00:17:55.750
需要传递Java需要

00:17:53.440 --> 00:17:58.600
传递日志附加功能，以便我的应用

00:17:55.750 --> 00:18:03.870
已经隐式读取Java 

00:17:58.600 --> 00:18:06.399
日志记录还隐式读取日志附加内容

00:18:03.870 --> 00:18:10.320
我的应用程序不会意识到

00:18:06.399 --> 00:18:16.210
向下进行堆栈重构

00:18:10.320 --> 00:18:18.509
它只是说需要Java续集，所以在

00:18:16.210 --> 00:18:21.159
本质上就是这种可读性模型

00:18:18.509 --> 00:18:23.889
支持向下分解

00:18:21.159 --> 00:18:26.830
您阅读的模块可以被其分解

00:18:23.889 --> 00:18:29.559
编写新模块并提高可读性

00:18:26.830 --> 00:18:31.600
的新模块可以使用

00:18:29.559 --> 00:18:34.690
在旧版本中需要一个及物从句

00:18:31.600 --> 00:18:36.909
模块，因此您可以看到

00:18:34.690 --> 00:18:39.669
读取的定义一个模块的读取

00:18:36.909 --> 00:18:42.610
另一个是X读取的递归模块

00:18:39.669 --> 00:18:45.639
通过要求另一个模块Y 

00:18:42.610 --> 00:18:47.919
直接与require子句或

00:18:45.639 --> 00:18:50.350
读一些第三个模块q 

00:18:47.919 --> 00:18:53.500
递归读取一些第三模块q 

00:18:50.350 --> 00:18:56.710
 q表示需要传递的原因，以及

00:18:53.500 --> 00:18:58.059
现在，X知道了为什么可以说

00:18:56.710 --> 00:19:02.679
需要传递其他

00:18:58.059 --> 00:19:05.620
模块和X现在也会阅读

00:19:02.679 --> 00:19:09.159
一旦有人需要您的模块，请小心

00:19:05.620 --> 00:19:11.500
明确地，您可以向下重构它

00:19:09.159 --> 00:19:14.590
尽可能多但不能

00:19:11.500 --> 00:19:17.500
删除它是没有模块的

00:19:14.590 --> 00:19:20.799
参加另一个模块

00:19:17.500 --> 00:19:24.730
它的名称作为别名（如果有人需要） 

00:19:20.799 --> 00:19:32.350
 X和X被删除，然后该模块

00:19:24.730 --> 00:19:34.629
系统无法启动我之前说过

00:19:32.350 --> 00:19:36.039
可访问性的出口部分是

00:19:34.629 --> 00:19:38.409
包非常简单

00:19:36.039 --> 00:19:40.409
要么导出，要么不是，但是

00:19:38.409 --> 00:19:43.450
实际上比这更微妙

00:19:40.409 --> 00:19:46.450
这是一些

00:19:43.450 --> 00:19:48.840
基于Java的模块导出包

00:19:46.450 --> 00:19:51.399
意味着任何人都可以编译运行

00:19:48.840 --> 00:19:52.990
反对其公共类型及其

00:19:51.399 --> 00:19:56.179
公共元素

00:19:52.990 --> 00:19:59.030
 Java中还有数十个软件包

00:19:56.179 --> 00:20:01.370
没有出口的基地

00:19:59.030 --> 00:20:03.080
甚至针对他们的公共类型进行编译

00:20:01.370 --> 00:20:04.880
如果您手动制作课程文件， 

00:20:03.080 --> 00:20:07.250
指非公共类型

00:20:04.880 --> 00:20:09.260
导出的程序包它将无法运行这不是

00:20:07.250 --> 00:20:12.650
只是编译VMS做的时间欺骗

00:20:09.260 --> 00:20:14.690
它也一样，但仅此而已

00:20:12.650 --> 00:20:16.700
 Java语言中的可访问性

00:20:14.690 --> 00:20:18.740
 VMware访问类和

00:20:16.700 --> 00:20:20.960
目标类是已知的静态线索

00:20:18.740 --> 00:20:22.970
在字节码的源代码中是什么

00:20:20.960 --> 00:20:25.250
关于反射的可访问性

00:20:22.970 --> 00:20:30.320
仅知道目标类别的地方

00:20:25.250 --> 00:20:34.040
动态地我们认为这非常重要

00:20:30.320 --> 00:20:38.360
导出像Java这样的包

00:20:34.040 --> 00:20:41.059
是的，安全是静态访问

00:20:38.360 --> 00:20:42.980
被编程反对并不意味着

00:20:41.059 --> 00:20:46.070
任何人都可以反思

00:20:42.980 --> 00:20:49.910
该软件包的内部，因为如果

00:20:46.070 --> 00:20:54.380
他们可以，他们会在这里是一个堆栈

00:20:49.910 --> 00:20:57.160
从2016年7月开始有人溢出问题

00:20:54.380 --> 00:21:00.380
这是Reven拍摄的URL图片

00:20:57.160 --> 00:21:04.280
有人正在使用可访问的集

00:21:00.380 --> 00:21:08.480
访问类Java中的私有字段

00:21:04.280 --> 00:21:11.299
安全密钥存储的目的

00:21:08.480 --> 00:21:13.520
类Java安全密钥库是和我

00:21:11.299 --> 00:21:16.340
引用以下存储设备

00:21:13.520 --> 00:21:19.549
加密密钥和证书，如果

00:21:16.340 --> 00:21:22.309
曾经有一个班级的私人

00:21:19.549 --> 00:21:26.720
字段应该无法访问，是这个

00:21:22.309 --> 00:21:29.600
现在的Java安全包是

00:21:26.720 --> 00:21:31.549
已导出，因此您可以针对

00:21:29.600 --> 00:21:34.220
公共类型的公用密钥库

00:21:31.549 --> 00:21:38.260
字段和方法不能使您可以

00:21:34.220 --> 00:21:38.260
反思clicky商店内部

00:21:39.040 --> 00:21:45.110
铃声我爱第一个答案

00:21:42.500 --> 00:21:47.299
如何更新我没有的东西

00:21:45.110 --> 00:21:49.010
工作如何解决它，您可以通过以下方式解决它

00:21:47.299 --> 00:21:55.150
不摆弄私人数据成员

00:21:49.010 --> 00:21:58.250
其他班级的第一答案就是

00:21:55.150 --> 00:22:01.220
出口包装出口P不

00:21:58.250 --> 00:22:03.830
允许反射访问

00:22:01.220 --> 00:22:06.650
包的非公共元素

00:22:03.830 --> 00:22:11.240
非公共类型甚至

00:22:06.650 --> 00:22:14.600
非公开的非自豪

00:22:11.240 --> 00:22:19.760
公共类型的元素，所以我再说一遍

00:22:14.600 --> 00:22:24.140
如果您获得非

00:22:19.760 --> 00:22:26.630
包中的公共类型，您仍然可以

00:22:24.140 --> 00:22:30.400
列出其成员，但您无法致电

00:22:26.630 --> 00:22:30.400
获取或设置其

00:22:39.460 --> 00:22:49.610
 java.lang.reflect.method.invoke类型

00:22:45.580 --> 00:22:51.800
同样，如果您以某种方式获得了

00:22:49.610 --> 00:22:54.530
有人将其传递给您一个Java Lang 

00:22:51.800 --> 00:22:58.220
反映私有字段的字段对象

00:22:54.530 --> 00:23:01.160
在公共类型中，您不能调用get或

00:22:58.220 --> 00:23:05.720
放在上面，甚至打电话说

00:23:01.160 --> 00:23:07.880
如果作者是可访问的，将无济于事

00:23:05.720 --> 00:23:11.330
该模块确实希望允许访问

00:23:07.880 --> 00:23:14.540
通过反射进入非公共元素

00:23:11.330 --> 00:23:17.150
这可以用出口来表达

00:23:14.540 --> 00:23:19.430
私人，然后允许反思

00:23:17.150 --> 00:23:21.500
像在jdk 8 private中一样工作

00:23:19.430 --> 00:23:24.850
可以访问公共类型的成员

00:23:21.500 --> 00:23:27.470
和非公共类型的公共成员

00:23:24.850 --> 00:23:29.450
我们没有正式称它为弱者

00:23:27.470 --> 00:23:34.790
封装，但您可以想到

00:23:29.450 --> 00:23:37.850
这样的底线是那么强大

00:23:34.790 --> 00:23:40.010
封装甚至比

00:23:37.850 --> 00:23:41.600
强大的反射能力是

00:23:40.010 --> 00:23:45.680
传统上由Java提供

00:23:41.600 --> 00:23:48.590
平台，取决于模块作者

00:23:45.680 --> 00:23:52.970
选择强封装，如果他们选择

00:23:48.590 --> 00:23:55.790
通过飞机出口来完成，就像我们在Java中一样

00:23:52.970 --> 00:23:59.960
没有其他模块的基础

00:23:55.790 --> 00:24:02.600
打破模块系统API的作用

00:23:59.960 --> 00:24:05.330
不允许一个模块增加

00:24:02.600 --> 00:24:07.940
反射另一个模块的输出a 

00:24:05.330 --> 00:24:11.450
模块只能X只能增加其

00:24:07.940 --> 00:24:15.050
通过API自己导出，所以说

00:24:11.450 --> 00:24:18.230
可访问的行为现在取决于

00:24:15.050 --> 00:24:19.559
模块作者如何选择包装

00:24:18.230 --> 00:24:22.710
出口

00:24:19.559 --> 00:24:25.019
当然，对于Java安全性公众

00:24:22.710 --> 00:24:27.029
键入那些没有问题的公共方法

00:24:25.019 --> 00:24:30.269
公共类型没有针对的问题代码

00:24:27.029 --> 00:24:36.929
他们，但你里面的私人事物不能

00:24:30.269 --> 00:24:38.610
碰他们有一个问题

00:24:36.929 --> 00:24:44.940
很多问题，但我会接受

00:24:38.610 --> 00:24:47.429
最后谢谢您使用的辅助功能

00:24:44.940 --> 00:24:49.499
基本上是一个简单的检查

00:24:47.429 --> 00:24:53.490
公共或相同的软件包在编译时

00:24:49.499 --> 00:24:55.110
并在jdk 9中可访问性

00:24:53.490 --> 00:24:57.649
是强力的机制

00:24:55.110 --> 00:24:59.999
封装的模块内部

00:24:57.649 --> 00:25:02.990
可访问性取决于可读性

00:24:59.999 --> 00:25:06.119
可以是直接的或暗示的

00:25:02.990 --> 00:25:09.389
可访问性由

00:25:06.119 --> 00:25:18.860
编译器VM和反射符合

00:25:09.389 --> 00:25:18.860
模块声明第2部分

00:25:19.309 --> 00:25:26.039
到目前为止，一切都与命名有关

00:25:22.830 --> 00:25:29.730
用以下命令明确声明的模块

00:25:26.039 --> 00:25:32.009
照片Java模块中的名称

00:25:29.730 --> 00:25:34.379
关于classpath上的jar文件

00:25:32.009 --> 00:25:36.539
照片类文件中没有模块

00:25:34.379 --> 00:25:41.309
他们似乎处于自己的世界中

00:25:36.539 --> 00:25:44.639
保持可访问性模型

00:25:41.309 --> 00:25:48.869
可读性一致性，我们介绍

00:25:44.639 --> 00:25:51.960
未命名的模块所有未命名的类

00:25:48.869 --> 00:25:55.980
模块位于未命名的模块中

00:25:51.960 --> 00:25:59.269
好像为此付出了一切

00:25:55.980 --> 00:26:02.190
 classpath在一个大模块中， 

00:25:59.269 --> 00:26:04.799
因为这是模块，我们可以问两个

00:26:02.190 --> 00:26:10.639
质疑它读什么，什么

00:26:04.799 --> 00:26:14.220
它是否导出读取的内容很简单

00:26:10.639 --> 00:26:17.929
每个命名模块都好像

00:26:14.220 --> 00:26:20.610
免费的魔术，这意味着一切

00:26:17.929 --> 00:26:23.249
可以通过命名模块导出

00:26:20.610 --> 00:26:26.490
通过未命名模块中的代码访问

00:26:23.249 --> 00:26:28.769
您可以将一个jar文件转换为一个

00:26:26.490 --> 00:26:31.440
通过添加模块信息doc类添加模块

00:26:28.769 --> 00:26:33.980
并将罐子放在模块路径上

00:26:31.440 --> 00:26:37.710
找到命名模块时

00:26:33.980 --> 00:26:40.800
保留在classpath上的jar不会

00:26:37.710 --> 00:26:43.230
意识到发生任何事情他们都可以

00:26:40.800 --> 00:26:46.650
仍然阅读那些命名模块

00:26:43.230 --> 00:26:49.070
下一个迁移的巨大帮助

00:26:46.650 --> 00:26:52.290
问题是未命名的模块是什么

00:26:49.070 --> 00:26:56.850
在此之前我们应该问一下出口

00:26:52.290 --> 00:26:58.290
读未命名模块的人记得

00:26:56.850 --> 00:27:00.690
我们在模块系统中的目标是

00:26:58.290 --> 00:27:03.660
我们相信非常可靠的依赖

00:27:00.690 --> 00:27:07.160
强烈建议命名模块不应

00:27:03.660 --> 00:27:09.810
开箱即用地读取未命名的模块

00:27:07.160 --> 00:27:13.170
它会嘲笑可靠

00:27:09.810 --> 00:27:15.180
让命名模块依赖的依赖项

00:27:13.170 --> 00:27:20.280
关于任意内容

00:27:15.180 --> 00:27:22.950
 classpath，所以你不能写要求

00:27:20.280 --> 00:27:26.100
未命名或模块中需要classpath 

00:27:22.950 --> 00:27:29.370
信息java没有读取边缘

00:27:26.100 --> 00:27:31.800
到未命名的模块，这似乎

00:27:29.370 --> 00:27:33.990
像移民的巨大障碍

00:27:31.800 --> 00:27:37.230
因为任何罐子变成了一个

00:27:33.990 --> 00:27:43.530
模块无法访问左侧的jar 

00:27:37.230 --> 00:27:47.580
 classpath答案是自动的

00:27:43.530 --> 00:27:50.370
你可以带一个罐子说番石榴模块

00:27:47.580 --> 00:27:53.940
并将其从类路径移至

00:27:50.370 --> 00:27:56.400
将罐子变成一个

00:27:53.940 --> 00:28:00.470
您只需要做的自动模块

00:27:56.400 --> 00:28:03.390
做一个自动模块就是一个命名模块

00:28:00.470 --> 00:28:06.570
隐式声明而不是声明

00:28:03.390 --> 00:28:09.210
明确地，其名称源自其名称

00:28:06.570 --> 00:28:11.490
 jar文件名以明显的方式放置

00:28:09.210 --> 00:28:14.400
模块路径上的番石榴罐给出了一个

00:28:11.490 --> 00:28:16.650
像以前一样称为guava的自动模块

00:28:14.400 --> 00:28:18.120
每当你看到一个模块，你应该问

00:28:16.650 --> 00:28:23.700
它读什么，它做什么

00:28:18.120 --> 00:28:26.670
导出番石榴自动读取的模块

00:28:23.700 --> 00:28:29.670
 JDK中的所有内容以及未命名的

00:28:26.670 --> 00:28:32.730
模块就好像要求

00:28:29.670 --> 00:28:35.700
现在未命名迁移的障碍

00:28:32.730 --> 00:28:38.520
不见了，你可以把一个罐子变成一个

00:28:35.700 --> 00:28:42.390
自动模块，它仍然可以访问

00:28:38.520 --> 00:28:44.820
我们问的类路径上剩下的罐子

00:28:42.390 --> 00:28:47.190
较早的未命名模块导出的内容

00:28:44.820 --> 00:28:49.620
答案是所有的包装

00:28:47.190 --> 00:28:52.350
在ju najar和玻璃鱼缸中

00:28:49.620 --> 00:28:55.320
休眠jar正是为了帮助代码

00:28:52.350 --> 00:28:57.270
读取未命名的自动模块

00:28:55.320 --> 00:29:01.850
模块，这是一个完整的力量

00:28:57.270 --> 00:29:01.850
导出以及您可以反映回去

00:29:02.720 --> 00:29:09.030
因为自动模块是真实的

00:29:05.550 --> 00:29:12.420
命名模块另一个命名模块可以

00:29:09.030 --> 00:29:15.600
假设我的应用程序模块需要它

00:29:12.420 --> 00:29:19.470
说需要番石榴，所以读

00:29:15.600 --> 00:29:22.380
然后从我的应用程序到番石榴边缘

00:29:19.470 --> 00:29:24.660
像番石榴出口这样的自动模块

00:29:22.380 --> 00:29:27.420
这很容易

00:29:24.660 --> 00:29:30.570
包括反思，这样我的应用程序就可以

00:29:27.420 --> 00:29:34.800
访问所有公共番石榴类型和

00:29:30.570 --> 00:29:39.420
反映它没有问题，我的应用程序可以

00:29:34.800 --> 00:29:42.270
甚至说需要传递番石榴来

00:29:39.420 --> 00:29:44.580
传输对番石榴的依赖

00:29:42.270 --> 00:29:48.320
它自己的消费者，以便任何人

00:29:44.580 --> 00:29:52.190
读取我的应用程序将免费读取Wafaa 

00:29:48.320 --> 00:29:56.340
即使番石榴是自动模块

00:29:52.190 --> 00:29:58.560
因此，通过将罐子从类路径移动到

00:29:56.340 --> 00:30:00.930
您会自动获得模块路径

00:29:58.560 --> 00:30:04.320
使您可以开始构建的模块

00:30:00.930 --> 00:30:06.720
你自己的模块图不是

00:30:04.320 --> 00:30:09.570
有必要等待上的每个罐子

00:30:06.720 --> 00:30:12.540
类路径由其模块化

00:30:09.570 --> 00:30:19.290
在开始开发您的作品之前

00:30:12.540 --> 00:30:22.170
自己的模块需要它，所以有

00:30:19.290 --> 00:30:25.980
三种模块的显式命名

00:30:22.170 --> 00:30:29.280
像Java续集这样的模块自动命名

00:30:25.980 --> 00:30:32.100
番石榴和未命名的模块

00:30:29.280 --> 00:30:33.810
模块又名classpath和密钥

00:30:32.100 --> 00:30:36.780
重点是可读性强

00:30:33.810 --> 00:30:39.210
免费帮助迁移和

00:30:36.780 --> 00:30:40.800
因为可读性是

00:30:39.210 --> 00:30:45.290
无障碍获取，然后您将获得很多

00:30:40.800 --> 00:30:45.290
就像果冻辅助工具上的辅助功能

00:30:47.270 --> 00:30:51.110
装载机和层

00:30:52.160 --> 00:30:58.520
我说过强封装之前

00:30:55.430 --> 00:31:00.800
与类加载器无关

00:30:58.520 --> 00:31:04.940
表示在

00:31:00.800 --> 00:31:08.660
 jdk 9 jdk中的类加载模型

00:31:04.940 --> 00:31:10.340
 9不变的装载机机制

00:31:08.660 --> 00:31:12.560
对于那些拥有

00:31:10.340 --> 00:31:15.100
一直在阅读虚拟机规格不变

00:31:12.560 --> 00:31:18.470
运行时软件包的概念是

00:31:15.100 --> 00:31:22.070
不变的java.lang类加载器api 

00:31:18.470 --> 00:31:27.800
本质上是不变的类加载

00:31:22.070 --> 00:31:30.170
除了在jdk 9中不变

00:31:27.800 --> 00:31:33.920
实际的类加载器，实际的对象

00:31:30.170 --> 00:31:37.130
 jdk 9中的内容与jdk aid中的相同

00:31:33.920 --> 00:31:39.200
有引导加载程序

00:31:37.130 --> 00:31:41.330
平台加载器曾经被称为

00:31:39.200 --> 00:31:43.310
扩展加载程序太混乱了

00:31:41.330 --> 00:31:45.500
它是平台加载程序，然后有

00:31:43.310 --> 00:31:47.900
加载的应用程序加载器

00:31:45.500 --> 00:31:53.630
类路径上的所有内容都在顶部

00:31:47.900 --> 00:31:57.260
传统上， 

00:31:53.630 --> 00:32:00.050
大多数JDK类是由

00:31:57.260 --> 00:32:02.540
引导加载程序关键JDK 

00:32:00.050 --> 00:32:04.850
 Java base等模块仍然具有

00:32:02.540 --> 00:32:08.690
引导程序定义的类

00:32:04.850 --> 00:32:11.510
非关键JDK模块的加载程序

00:32:08.690 --> 00:32:13.940
对于移动他们的安全至关重要

00:32:11.510 --> 00:32:16.640
引导加载程序之外的类，如果

00:32:13.940 --> 00:32:19.460
引导加载程序中可能的模块

00:32:16.640 --> 00:32:22.490
使用所有权限运行

00:32:19.460 --> 00:32:25.130
从安全角度来看，理想的是

00:32:22.490 --> 00:32:27.770
模块只能获得D特权，即

00:32:25.130 --> 00:32:30.830
如果使用较少的权限运行

00:32:27.770 --> 00:32:33.760
不在吉士大的引导加载程序中

00:32:30.830 --> 00:32:37.160
 k9包含Java EE的所有模块

00:32:33.760 --> 00:32:40.490
 Java goober之类的技术具有

00:32:37.160 --> 00:32:42.920
以及JDBC模块已被移走

00:32:40.490 --> 00:32:45.650
 Java续集和Java续集玫瑰花结

00:32:42.920 --> 00:32:49.040
他们的类别现在由

00:32:45.650 --> 00:32:54.320
平台装载器坦然地移动模块

00:32:49.040 --> 00:32:57.260
和Java cawber 1831类一样大

00:32:54.320 --> 00:33:00.410
 31个导出包不小

00:32:57.260 --> 00:33:03.140
 D特权是孩子

00:33:00.410 --> 00:33:06.039
指定更少权限的自我

00:33:03.140 --> 00:33:08.960
将持续多年

00:33:06.039 --> 00:33:12.350
然后，应用程序加载器

00:33:08.960 --> 00:33:15.559
对其他一切负责

00:33:12.350 --> 00:33:17.419
 JDK工具模块（例如JDK编译器） 

00:33:15.559 --> 00:33:21.049
由应用定义其类

00:33:17.419 --> 00:33:23.030
加载模块上模块中的所有类

00:33:21.049 --> 00:33:25.960
模块路径，无论它们是否在模块化中

00:33:23.030 --> 00:33:29.150
 jar或番石榴等自动模块中

00:33:25.960 --> 00:33:32.690
由应用程序加载程序定义

00:33:29.150 --> 00:33:35.510
以及classpath中的所有类

00:33:32.690 --> 00:33:38.900
传统的jar文件，例如jo nijar和

00:33:35.510 --> 00:33:44.030
玻璃鱼缸的定义与以前相同

00:33:38.900 --> 00:33:47.809
应用程序加载器的一些注意事项

00:33:44.030 --> 00:33:50.419
关于兼容性优先框架

00:33:47.809 --> 00:33:53.809
直接委托给引导程序

00:33:50.419 --> 00:33:57.289
加载程序以查找JDK类可能会中断

00:33:53.809 --> 00:34:00.620
在jdk 9上，因为许多jdk类

00:33:57.289 --> 00:34:02.510
不再有框架应该

00:34:00.620 --> 00:34:04.850
使用新的类加载器方法get' 

00:34:02.510 --> 00:34:07.190
平台类加载器，返回一个

00:34:04.850 --> 00:34:13.159
装载机保证提供可见度

00:34:07.190 --> 00:34:15.679
导出的JDK类的第二

00:34:13.159 --> 00:34:18.919
仍然有应用程序加载器

00:34:15.679 --> 00:34:22.550
一个对象本身不再是一个

00:34:18.919 --> 00:34:25.580
 URL类加载器框架的实例

00:34:22.550 --> 00:34:27.790
假设它是为了通过

00:34:25.580 --> 00:34:33.230
可以访问其添加URL方法

00:34:27.790 --> 00:34:35.359
 sadface将会在9枚jdk上打破

00:34:33.230 --> 00:34:36.859
支持的方式来动态扩展

00:34:35.359 --> 00:34:39.230
类路径与类路径

00:34:36.859 --> 00:34:43.700
 jar文件或代理中的属性

00:34:39.230 --> 00:34:45.830
 API和java.lang工具现在

00:34:43.700 --> 00:34:51.740
可能想知道模块系统在哪里

00:34:45.830 --> 00:34:53.570
本身生活在这一切之中

00:34:51.740 --> 00:34:57.950
重要的是要意识到模块在哪里

00:34:53.570 --> 00:35:00.980
传统上，系统不是模块

00:34:57.950 --> 00:35:04.280
系统只是起作用的Java代码

00:35:00.980 --> 00:35:07.130
作为装载机的工厂

00:35:04.280 --> 00:35:09.859
创建定义类的加载器

00:35:07.130 --> 00:35:11.900
在一些模块化工件中找到，然后

00:35:09.859 --> 00:35:13.940
这些负载在

00:35:11.900 --> 00:35:16.550
按照某种模块化

00:35:13.940 --> 00:35:19.180
我提到的进出口

00:35:16.550 --> 00:35:22.910
在有封装之前

00:35:19.180 --> 00:35:25.370
上课，因为那些装载机是B 

00:35:22.910 --> 00:35:28.160
 C可以隐藏他们可以隔离的类

00:35:25.370 --> 00:35:31.790
相互分类的模块系统

00:35:28.160 --> 00:35:34.130
这样做仍然可以在jdk上工作

00:35:31.790 --> 00:35:38.990
九是因为没有上课

00:35:34.130 --> 00:35:44.180
更改了，但jdk中的模块系统

00:35:38.990 --> 00:35:48.020
九是完全不同的模块

00:35:44.180 --> 00:35:51.250
 JDK 9中的系统不是工厂

00:35:48.020 --> 00:35:53.780
类装载机，而是管道

00:35:51.250 --> 00:35:57.910
传输机制允许

00:35:53.780 --> 00:36:00.710
与虚拟机通信的模块

00:35:57.910 --> 00:36:03.380
创建类加载器的人是

00:36:00.710 --> 00:36:06.910
负责使用模块系统

00:36:03.380 --> 00:36:09.920
用于传输模块名称内容的API 

00:36:06.910 --> 00:36:12.590
依赖关系并导出到vm 

00:36:09.920 --> 00:36:15.770
这就是虚拟机足够了解的方式

00:36:12.590 --> 00:36:17.870
强制执行可访问性，这也是

00:36:15.770 --> 00:36:19.970
核心反射API可以强制执行

00:36:17.870 --> 00:36:23.540
可访问性，因为核心反射是

00:36:19.970 --> 00:36:26.530
基于vm提供的类对象

00:36:23.540 --> 00:36:29.810
可以认为Java启动器是

00:36:26.530 --> 00:36:32.390
创建三个加载程序并执行

00:36:29.810 --> 00:36:34.940
向下传输到模块的vm 

00:36:32.390 --> 00:36:36.620
在模块路径上，您可以看到为什么我们

00:36:34.940 --> 00:36:39.800
希望模块系统成为

00:36:36.620 --> 00:36:42.050
对类加载器JDK不感兴趣

00:36:39.800 --> 00:36:44.420
已经分解成数十个模块

00:36:42.050 --> 00:36:45.530
但它是类加载架构

00:36:44.420 --> 00:36:49.730
课堂学习架构的形状

00:36:45.530 --> 00:36:52.940
没有更改提供的封装

00:36:49.730 --> 00:36:56.870
烦恼em级别的可访问性，而不是

00:36:52.940 --> 00:36:59.180
基于类加载器的可见性，因此

00:36:56.870 --> 00:37:01.580
模块系统不需要强制要求

00:36:59.180 --> 00:37:04.610
每个模块可以处理一个装载程序

00:37:01.580 --> 00:37:08.570
每个加载程序有多个模块就可以了

00:37:04.610 --> 00:37:10.970
这就是图片所显示的

00:37:08.570 --> 00:37:14.030
回想一下我之前谈到的

00:37:10.970 --> 00:37:17.930
未命名模块作为车辆

00:37:14.030 --> 00:37:20.870
兼容性严格来说我是

00:37:17.930 --> 00:37:24.050
指的是未命名的模块

00:37:20.870 --> 00:37:27.260
应用程序加载器实际上是每个类

00:37:24.050 --> 00:37:30.770
每个类加载器都有一个未命名的模块

00:37:27.260 --> 00:37:33.080
如果vm看到由定义的类

00:37:30.770 --> 00:37:35.900
加载程序和虚拟机

00:37:33.080 --> 00:37:38.420
将该类与命名模块关联

00:37:35.900 --> 00:37:40.700
那是早些时候传下来的

00:37:38.420 --> 00:37:44.180
虚拟机将类视为

00:37:40.700 --> 00:37:47.180
装载程序未命名模块

00:37:44.180 --> 00:37:51.650
猜测虚拟机始终允许访问

00:37:47.180 --> 00:37:54.140
未命名模块中的公共类this 

00:37:51.650 --> 00:37:57.560
意味着这一切意味着每堂课

00:37:54.140 --> 00:37:59.630
每个类甚至是模块的成员

00:37:57.560 --> 00:38:02.450
 jar文件上的类

00:37:59.630 --> 00:38:04.250
 classpath j罐子和玻璃鱼顶

00:38:02.450 --> 00:38:05.360
 jar是它的模块成员

00:38:04.250 --> 00:38:10.310
实际上，这意味着

00:38:05.360 --> 00:38:12.830
右侧虚拟机中的第七个框

00:38:10.310 --> 00:38:14.960
如果您有一个类对象，则获取

00:38:12.830 --> 00:38:21.970
模块方法将始终返回

00:38:14.960 --> 00:38:25.400
明智的模块对象模块系统

00:38:21.970 --> 00:38:29.050
将层的概念引入

00:38:25.400 --> 00:38:32.780
将类加载器与模块关联

00:38:29.050 --> 00:38:35.570
层是一类的类加载器

00:38:32.780 --> 00:38:38.990
一起为一个类加载类

00:38:35.570 --> 00:38:40.780
 Java逻辑上的模块图

00:38:38.990 --> 00:38:44.290
启动器定义启动层

00:38:40.780 --> 00:38:47.570
由三个熟悉的装载机组成

00:38:44.290 --> 00:38:49.730
是引导层将

00:38:47.570 --> 00:38:52.880
 Java基础和Java日志记录模块

00:38:49.730 --> 00:38:54.650
引导程序Java续集和

00:38:52.880 --> 00:39:00.440
 Java Korba模块与平台

00:38:54.650 --> 00:39:03.470
加载程序等，以便创建一个图层

00:39:00.440 --> 00:39:05.960
从两个模块的图和一个

00:39:03.470 --> 00:39:10.490
映射模块两个加载器的功能

00:39:05.960 --> 00:39:12.920
左边是解析的图形

00:39:10.490 --> 00:39:15.530
 JDK j-link模块，其中包含

00:39:12.920 --> 00:39:17.660
用于构建运行时jeddak的jaail工具

00:39:15.530 --> 00:39:21.770
 8张图像只是一个模块的示例

00:39:17.660 --> 00:39:24.020
右边的图是lambda 

00:39:21.770 --> 00:39:26.270
表达式映射某些模块

00:39:24.020 --> 00:39:32.240
在该图中引导加载程序

00:39:26.270 --> 00:39:35.750
然后应用程序加载器创建一个

00:39:32.240 --> 00:39:37.880
层通知模块系统有关

00:39:35.750 --> 00:39:40.310
将存在于

00:39:37.880 --> 00:39:42.110
程序以及它们将要出现的模块

00:39:40.310 --> 00:39:43.609
这是一张很棒的幻灯片

00:39:42.110 --> 00:39:46.290
提示图片提示图片

00:39:43.609 --> 00:39:48.750
模块系统通过了

00:39:46.290 --> 00:39:50.820
信息到虚拟机，以便何时

00:39:48.750 --> 00:39:53.670
最终加载类并

00:39:50.820 --> 00:39:56.460
定义了vm知道哪个模块

00:39:53.670 --> 00:40:00.119
类属于那个模块

00:39:56.460 --> 00:40:03.510
读取并导出，就像虚拟机有一个

00:40:00.119 --> 00:40:06.000
它的模块图的影子副本

00:40:03.510 --> 00:40:10.170
在检查之间的可访问性时使用

00:40:06.000 --> 00:40:13.170
现在上课，因为如何加载类

00:40:10.170 --> 00:40:15.599
模块系统必须执行的工作

00:40:13.170 --> 00:40:18.480
图层模块上的某些约束

00:40:15.599 --> 00:40:21.090
图形和从

00:40:18.480 --> 00:40:23.730
加载程序的模块让我们谈谈

00:40:21.090 --> 00:40:28.380
图的最后一次机会

00:40:23.730 --> 00:40:37.109
图片和背面滑动很好

00:40:28.380 --> 00:40:42.330
哦，或多或少，好吧，这是

00:40:37.109 --> 00:40:48.540
吉达k9中的模块图

00:40:42.330 --> 00:40:49.560
您会注意到这完全是个问题

00:40:48.540 --> 00:40:51.720
来自那边的同样的艺术

00:40:49.560 --> 00:40:57.930
去年我记得这么精确

00:40:51.720 --> 00:41:01.230
回答好吧，这是有针对性的

00:40:57.930 --> 00:41:04.170
有向无环图

00:41:01.230 --> 00:41:07.500
是第一个也是最大的约束

00:41:04.170 --> 00:41:10.320
模块图花了将近十年

00:41:07.500 --> 00:41:13.440
纠缠成千上万

00:41:10.320 --> 00:41:16.050
 JDK中的非循环类

00:41:13.440 --> 00:41:18.540
你在这里看到的相对理智的状态

00:41:16.050 --> 00:41:21.540
我们实际上希望保持这种方式

00:41:18.540 --> 00:41:24.300
投资的动机之一

00:41:21.540 --> 00:41:26.760
代码库的模块化是

00:41:24.300 --> 00:41:29.130
一旦完成的知识

00:41:26.760 --> 00:41:34.099
不会向后退

00:41:29.130 --> 00:41:34.099
的循环依赖

00:41:34.460 --> 00:41:40.230
我们并不是唯一一个像

00:41:36.630 --> 00:41:43.830
这个Java应用程序架构是

00:41:40.230 --> 00:41:46.710
关于模块化的杰出著作

00:41:43.830 --> 00:41:50.310
循环依赖部分

00:41:46.710 --> 00:41:53.099
丧钟说过度依赖

00:41:50.310 --> 00:41:55.070
是关于但循环依赖

00:41:53.099 --> 00:41:58.320
特别糟糕

00:41:55.070 --> 00:42:00.900
一般说来

00:41:58.320 --> 00:42:03.240
周期总是不好，但是有些

00:42:00.900 --> 00:42:05.340
周期比其他周期差

00:42:03.240 --> 00:42:06.900
类之间是可以容忍的

00:42:05.340 --> 00:42:09.170
它们不会导致

00:42:06.900 --> 00:42:11.670
包含它们的软件包或模块

00:42:09.170 --> 00:42:13.800
包之间的周期也可能是

00:42:11.670 --> 00:42:15.780
可以容忍的，假设他们没有

00:42:13.800 --> 00:42:18.330
导致模块之间的循环

00:42:15.780 --> 00:42:22.800
包含它们之间的模块关系

00:42:18.330 --> 00:42:25.890
永远不要循环，这本书来自

00:42:22.800 --> 00:42:29.180
多年前与Java无关

00:42:25.890 --> 00:42:31.980
模块系统，但这是一个很好的建议

00:42:29.180 --> 00:42:37.290
让我们转向另一个约束

00:42:31.980 --> 00:42:40.890
模块绘制第二个约束图

00:42:37.290 --> 00:42:44.270
模块图将是

00:42:40.890 --> 00:42:48.660
该层的基础是模块

00:42:44.270 --> 00:42:52.290
必须仅读取一个导出

00:42:48.660 --> 00:42:54.930
给定名称的包（如果有模块） 

00:42:52.290 --> 00:42:58.470
可以读取多个模块， 

00:42:54.930 --> 00:43:02.970
出口p作为x试图在这里做

00:42:58.470 --> 00:43:05.160
 P将访问哪个模块

00:43:02.970 --> 00:43:08.010
没有答案模块图只是

00:43:05.160 --> 00:43:09.660
坏了，所以我们只能防御

00:43:08.010 --> 00:43:13.560
遵从此的模块图

00:43:09.660 --> 00:43:16.860
约束，没有周期可以

00:43:13.560 --> 00:43:19.160
变成了真正的一层

00:43:16.860 --> 00:43:22.140
我们的意思是可靠的依赖

00:43:19.160 --> 00:43:24.300
模块依赖时可靠

00:43:22.140 --> 00:43:28.590
只能访问软件包的一个版本

00:43:24.300 --> 00:43:31.320
一次没有拆分包

00:43:28.590 --> 00:43:33.960
就像当多个罐子放在

00:43:31.320 --> 00:43:37.980
类路径可能包含不同的内容

00:43:33.960 --> 00:43:39.840
现在，同一软件包的版本

00:43:37.980 --> 00:43:44.040
可能想知道是否有可能

00:43:39.840 --> 00:43:46.770
 X在时读取Y的版本1 

00:43:44.040 --> 00:43:50.370
同时另一个模块读取版本2 

00:43:46.770 --> 00:43:52.430
毕竟X和其他模块的原因

00:43:50.370 --> 00:43:56.910
每个将只读取一个模块

00:43:52.430 --> 00:43:59.760
导出p的答案是，不是

00:43:56.910 --> 00:44:02.490
可能因为它只能安全​​地工作

00:43:59.760 --> 00:44:04.710
在某些情况下以及那些情况之外

00:44:02.490 --> 00:44:07.710
方案尚不清楚

00:44:04.710 --> 00:44:08.520
开箱即用

00:44:07.710 --> 00:44:11.090
 Java启动

00:44:08.520 --> 00:44:13.170
创建类加载器的那个

00:44:11.090 --> 00:44:16.080
尚不清楚是否支持它

00:44:13.170 --> 00:44:17.550
盒子值得，但你可以

00:44:16.080 --> 00:44:23.670
十个问题

00:44:17.550 --> 00:44:26.250
分钟时间回想起一层

00:44:23.670 --> 00:44:28.530
包括我们看到的模块图

00:44:26.250 --> 00:44:31.620
两个约束和一个映射

00:44:28.530 --> 00:44:34.200
模块两个装载机的主要约束

00:44:31.620 --> 00:44:37.020
在映射上是如果不同

00:44:34.200 --> 00:44:39.510
图中的模块有一个名为

00:44:37.020 --> 00:44:41.460
 C然后必须将这些模块映射到

00:44:39.510 --> 00:44:43.200
不同的装载机，这是

00:44:41.460 --> 00:44:44.940
类加载的基本限制

00:44:43.200 --> 00:44:48.480
类加载器只能创建一个类

00:44:44.940 --> 00:44:50.460
叫保守地说，我们说

00:44:48.480 --> 00:44:53.310
如果不同的模块具有相同的

00:44:50.460 --> 00:44:55.230
包装不仅是类，还有那些

00:44:53.310 --> 00:45:00.780
模块必须映射到不同的

00:44:55.230 --> 00:45:02.730
映射的图层的加载器

00:45:00.780 --> 00:45:04.890
模块两个装载机有另一个

00:45:02.730 --> 00:45:06.960
检查不实际的约束

00:45:04.890 --> 00:45:09.480
虽然因为它涉及负载如何

00:45:06.960 --> 00:45:11.240
准时的行为是装载机

00:45:09.480 --> 00:45:13.920
必须互相委托

00:45:11.240 --> 00:45:16.050
根据阅读的边缘

00:45:13.920 --> 00:45:19.740
模块图的原因很明显，如果

00:45:16.050 --> 00:45:22.800
模块X依次读取模块y 

00:45:19.740 --> 00:45:25.770
 X的类在一个加载器中访问

00:45:22.800 --> 00:45:28.050
另一个加载程序X中的明智类

00:45:25.770 --> 00:45:31.350
加载程序必须委派给明智的加载程序

00:45:28.050 --> 00:45:36.570
只是为了在您之前找到课程

00:45:31.350 --> 00:45:40.320
可以开始担心访问权限

00:45:36.570 --> 00:45:42.840
名称表明可以在以下情况下分层

00:45:40.320 --> 00:45:45.020
一个模块图就解决了

00:45:42.840 --> 00:45:48.000
实际针对父层解决

00:45:45.020 --> 00:45:50.610
然后当图形有助于创建一个

00:45:48.000 --> 00:45:53.550
新层新层接

00:45:50.610 --> 00:45:55.950
父层，这允许

00:45:53.550 --> 00:45:59.220
具有悬挂引用的模块

00:45:55.950 --> 00:46:01.500
是模块的require子句， 

00:45:59.220 --> 00:46:05.060
模块系统将在父级中找到

00:46:01.500 --> 00:46:08.460
分辨率期间在左图层

00:46:05.060 --> 00:46:11.220
分辨率不仅设置为读取

00:46:08.460 --> 00:46:13.470
模块之间的莫特之间的边缘

00:46:11.220 --> 00:46:15.960
将水平层也分层

00:46:13.470 --> 00:46:20.010
读取不同模块之间的边缘

00:46:15.960 --> 00:46:22.440
层构建中的层树

00:46:20.010 --> 00:46:24.839
这种时尚是一个人的工作

00:46:22.440 --> 00:46:27.410
应用服务器或测试之类的框架

00:46:24.839 --> 00:46:30.000
线束层提供框架

00:46:27.410 --> 00:46:32.760
极大地自由地组织模块

00:46:30.000 --> 00:46:35.010
在运行时不会破坏

00:46:32.760 --> 00:46:37.500
框架传统使用类

00:46:35.010 --> 00:46:39.750
加载程序就像动态调用

00:46:37.500 --> 00:46:42.060
来自JDK 7的指令

00:46:39.750 --> 00:46:45.480
框架开发人员进行交互

00:46:42.060 --> 00:46:48.990
虚拟机来验证有关

00:46:45.480 --> 00:46:53.760
程序的形状让我们来看一个

00:46:48.990 --> 00:46:56.550
图层帮助图层的场景

00:46:53.760 --> 00:47:00.180
系统如何支持

00:46:56.550 --> 00:47:03.150
该模块的多个版本

00:47:00.180 --> 00:47:07.500
应用服务器在顶部创建了两层

00:47:03.150 --> 00:47:10.500
 Hadoop左侧的启动层

00:47:07.500 --> 00:47:13.619
播放器使用番石榴校正模块图

00:47:10.500 --> 00:47:16.410
版本11和杰克逊版本1及更高版本

00:47:13.619 --> 00:47:19.619
右边的JavaScript层将

00:47:16.410 --> 00:47:23.550
番石榴18和版本的模块图

00:47:19.619 --> 00:47:26.190
杰克逊版本2每个模块图是

00:47:23.550 --> 00:47:28.230
格式正确并映射到

00:47:26.190 --> 00:47:30.510
明智的方式，但在模块

00:47:28.230 --> 00:47:32.700
 Hadoop层不知道

00:47:30.510 --> 00:47:36.540
 JavaScript层中的模块，反之

00:47:32.700 --> 00:47:38.849
反之亦然，但请注意，这一切都是感谢

00:47:36.540 --> 00:47:41.250
到创建Hadoop的框架，以及

00:47:38.849 --> 00:47:43.950
 JavaScript将Java启动器分层

00:47:41.250 --> 00:47:46.140
不会像这样创建图层

00:47:43.950 --> 00:47:48.810
这样做是解决您给的模块

00:47:46.140 --> 00:47:50.670
然后在命令行中映射所有内容

00:47:48.810 --> 00:47:54.000
结果模块图

00:47:50.670 --> 00:47:56.750
应用程序加载器在启动层吗

00:47:54.000 --> 00:47:59.730
每个模块仅支持一个版本

00:47:56.750 --> 00:48:02.220
原因是为了避免噩梦

00:47:59.730 --> 00:48:05.190
多个时发生的问题

00:48:02.220 --> 00:48:07.170
模块的版本或实际上任何jar 

00:48:05.190 --> 00:48:09.750
随便与每个人接触

00:48:07.170 --> 00:48:12.359
其他真的只有安全使用

00:48:09.750 --> 00:48:15.060
一个模块的多个版本

00:48:12.359 --> 00:48:20.010
像应用程序服务器这样的框架

00:48:15.060 --> 00:48:22.560
控制外卖就是这样

00:48:20.010 --> 00:48:25.020
模块包装了相关的集合

00:48:22.560 --> 00:48:28.589
打包并与VMS交互

00:48:25.020 --> 00:48:31.410
可访问性机制层总结

00:48:28.589 --> 00:48:33.030
连贯的模块集并进行交互

00:48:31.410 --> 00:48:36.270
具有类加载器的可见性

00:48:33.030 --> 00:48:39.840
机制取决于框架

00:48:36.270 --> 00:48:42.060
在未来20年内仅使用图层

00:48:39.840 --> 00:48:45.480
因为他们在

00:48:42.060 --> 00:48:47.670
 Java前20年我强烈要求

00:48:45.480 --> 00:48:50.820
框架开发人员正在观察开放

00:48:47.670 --> 00:48:54.260
 JDK 9 Javadoc并查看java.lang 

00:48:50.820 --> 00:48:54.260
模块配置和

00:49:00.470 --> 00:49:11.610
然后调用java.lang.reflect.method.invoke 

00:49:09.450 --> 00:49:14.130
控制模块之间的关系

00:49:11.610 --> 00:49:17.550
模块图和类加载器

00:49:14.130 --> 00:49:19.140
并假设装载机尊重

00:49:17.550 --> 00:49:21.210
他们委托的模块图

00:49:19.140 --> 00:49:23.100
明智的做法是通过

00:49:21.210 --> 00:49:28.260
施工没有周期或

00:49:23.100 --> 00:49:31.320
拆分包装，一直缩小

00:49:28.260 --> 00:49:33.360
这是三个关键点

00:49:31.320 --> 00:49:36.510
模块对模块的强力封装

00:49:33.360 --> 00:49:39.360
编译器vm和核心反射在那里

00:49:36.510 --> 00:49:42.330
是未命名的自动模块

00:49:39.360 --> 00:49:44.520
帮助迁移和整个系统

00:49:42.330 --> 00:49:51.450
施工安全无循环

00:49:44.520 --> 00:49:55.340
本质上将包拆分为模块

00:49:51.450 --> 00:49:58.440
系统是安全带，不是喷气背包，如果

00:49:55.340 --> 00:50:01.380
这使您想起了

00:49:58.440 --> 00:50:04.350
仿制药15年以上的15年

00:50:01.380 --> 00:50:06.240
之前您编写模块的权利

00:50:04.350 --> 00:50:08.700
声明使您的代码更加

00:50:06.240 --> 00:50:10.620
可靠和可维护的，就像

00:50:08.700 --> 00:50:13.200
写一个字符串列表而不是

00:50:10.620 --> 00:50:15.120
列出您一直都知道的清单

00:50:13.200 --> 00:50:17.610
持有的字符串和泛型可以让您

00:50:15.120 --> 00:50:20.100
知道你一直都知道一个包裹

00:50:17.610 --> 00:50:22.710
不能用于一般用途，而让模块

00:50:20.100 --> 00:50:25.590
你知道这不是巧合

00:50:22.710 --> 00:50:28.770
设计实用的模块系统

00:50:25.590 --> 00:50:31.080
和JDK采取的模块化崛起

00:50:28.770 --> 00:50:33.870
大约只要设计

00:50:31.080 --> 00:50:40.290
语用通用类型系统和属

00:50:33.870 --> 00:50:43.590
克服JDK，还有很长的路要走

00:50:40.290 --> 00:50:47.130
头虽然模块系统是

00:50:43.590 --> 00:50:49.829
概念上很简单

00:50:47.130 --> 00:50:52.049
可能不会破坏音乐的jdk 9 

00:50:49.829 --> 00:50:55.709
但可能会破坏框架代码，我会

00:50:52.049 --> 00:50:59.459
喜欢在那里快速通过他们

00:50:55.709 --> 00:51:02.160
是三个不兼容的领域

00:50:59.459 --> 00:51:05.849
 JDK九连官方

00:51:02.160 --> 00:51:08.969
首先定义Java SE 

00:51:05.849 --> 00:51:11.039
从软件包中删除了六种方法

00:51:08.969 --> 00:51:13.200
 java.util日志记录和Java util jar 

00:51:11.039 --> 00:51:15.420
他们的签名成为Java的基础

00:51:13.200 --> 00:51:18.900
模块取决于Java桌面模块

00:51:15.420 --> 00:51:21.859
而且没有人希望这是

00:51:18.900 --> 00:51:26.249
在雨伞jsr se8中宣布

00:51:21.859 --> 00:51:29.190
此外，2014年我们已移至WT 

00:51:26.249 --> 00:51:30.719
从未支持的软件包

00:51:29.190 --> 00:51:37.140
尽管在那里

00:51:30.719 --> 00:51:40.769
 Java命名空间非常可悲第二

00:51:37.140 --> 00:51:44.819
 JDK附带的Java EE类型是

00:51:40.769 --> 00:51:47.369
默认情况下无法访问

00:51:44.819 --> 00:51:49.559
 korba杰克的jax-ws Java 

00:51:47.369 --> 00:51:52.890
激活框架和JD kaise 

00:51:49.559 --> 00:51:56.039
 Java交易API的子集和

00:51:52.890 --> 00:51:59.099
常见的注释API类型是

00:51:56.039 --> 00:52:02.249
物理上在JDK映像中，但是

00:51:59.099 --> 00:52:06.180
未命名的模块不会读取模块

00:52:02.249 --> 00:52:08.219
应用加载程序的模块（如果您要

00:52:06.180 --> 00:52:11.009
编写模块没问题，只需要

00:52:08.219 --> 00:52:13.259
 java koerber或Java XML绑定或

00:52:11.009 --> 00:52:15.449
不管是什么，但是如果您正在从以下位置运行代码

00:52:13.259 --> 00:52:20.339
您需要命令行的类路径

00:52:15.449 --> 00:52:23.309
标记以激活EE模块

00:52:20.339 --> 00:52:25.589
版本报告的版本字符串

00:52:23.309 --> 00:52:27.420
系统属性Java规范

00:52:25.589 --> 00:52:30.469
版本Java VM版本Java VM 

00:52:27.420 --> 00:52:33.839
规格版本等已更改

00:52:30.469 --> 00:52:36.449
在代码中寻找一个点的代码

00:52:33.839 --> 00:52:40.349
字符串的开头将在jdk上失败

00:52:36.449 --> 00:52:46.380
九，因为版本字符串开始

00:52:40.349 --> 00:52:49.079
有九个则有三个区域

00:52:46.380 --> 00:52:52.410
 jdk九内不兼容

00:52:49.079 --> 00:52:55.140
实施首先我们精简了

00:52:52.410 --> 00:52:58.859
太阳杂物包装有些枪支小姐

00:52:55.140 --> 00:53:02.039
仍可访问，但有些杂项base64 

00:52:58.859 --> 00:53:03.430
编码器和一些其他base64解码器是

00:53:02.039 --> 00:53:05.410
不见了

00:53:03.430 --> 00:53:09.250
您今天可以做的一件事就是运行

00:53:05.410 --> 00:53:11.589
 jdk 8随附的Jade EPS工具

00:53:09.250 --> 00:53:13.690
你所有的罐子都会告诉你

00:53:11.589 --> 00:53:16.150
他们正在使用诸如

00:53:13.690 --> 00:53:18.609
一些杂项烘烤64编码器，然后

00:53:16.150 --> 00:53:22.240
建议像这样的官方替代品

00:53:18.609 --> 00:53:27.849
 jdk中引入的java.util base64类

00:53:22.240 --> 00:53:30.670
 8秒很多jdk内部api 

00:53:27.849 --> 00:53:34.839
未导出尝试访问的代码

00:53:30.670 --> 00:53:38.950
甚至公共类型在阳光网www 

00:53:34.839 --> 00:53:41.230
包装或防晒x509或Khamsin 

00:53:38.950 --> 00:53:43.809
 ork apache xerxes内部插孔p I 

00:53:41.230 --> 00:53:45.520
可能会继续下去，并因非法而失败

00:53:43.809 --> 00:53:49.809
访问错误是重新获得的唯一方法

00:53:45.520 --> 00:53:53.170
访问带有命令行标志

00:53:49.809 --> 00:53:55.690
 JDK的许多内部方面

00:53:53.170 --> 00:53:58.150
大修，如布局

00:53:55.690 --> 00:54:00.550
磁盘与执行三

00:53:58.150 --> 00:54:03.730
假定存在

00:54:00.550 --> 00:54:07.020
一个名为RT jar或tools jar的文件

00:54:03.730 --> 00:54:10.599
特定目录在JD k9上将失败

00:54:07.020 --> 00:54:13.450
尝试使用以下命令修补JDK的脚本

00:54:10.599 --> 00:54:16.480
减去X引导类通行证/预支笔p 

00:54:13.450 --> 00:54:19.329
会在9英镑兑美元失败，正如我提到的

00:54:16.480 --> 00:54:21.849
假定应用程序的代码之前

00:54:19.329 --> 00:54:25.210
 loader是URL类loader的实例

00:54:21.849 --> 00:54:27.160
或假设所有jdk类都是

00:54:25.210 --> 00:54:31.180
引导加载程序定义的将

00:54:27.160 --> 00:54:34.329
在JD k9模块系统本身上失败

00:54:31.180 --> 00:54:37.809
尽力支持迁移，但是

00:54:34.329 --> 00:54:40.630
只需要一个未维护的库即可

00:54:37.809 --> 00:54:42.640
防止迁移到jdk 9 

00:54:40.630 --> 00:54:44.829
库正在迁移，因为它正在使用

00:54:42.640 --> 00:54:48.130
所有/修补程序轴上的通讯内容

00:54:44.829 --> 00:54:50.109
内部检查p然后什么也没有

00:54:48.130 --> 00:54:53.440
它可以迁移为模块

00:54:50.109 --> 00:54:55.210
在这方面，模块是不寻常的

00:54:53.440 --> 00:54:58.150
遭受公地悲剧

00:54:55.210 --> 00:55:00.910
而大多数大功能（如泛型） 

00:54:58.150 --> 00:55:03.250
或lambdas让人们选择加入

00:55:00.910 --> 00:55:08.589
自己的节奏，无需等待

00:55:03.250 --> 00:55:09.760
正如我说的那样，其他人最后一张幻灯片

00:55:08.589 --> 00:55:12.790
您可以做的最好的准备

00:55:09.760 --> 00:55:14.170
码头犬正在启动JDK 8并运行

00:55:12.790 --> 00:55:17.019
进行分析的Jade EPS工具

00:55:14.170 --> 00:55:19.630
依赖关系可以告诉您您的合作伙伴

00:55:17.019 --> 00:55:23.169
或您依赖的代码将是

00:55:19.630 --> 00:55:25.719
受9中更改的影响，请尝试

00:55:23.169 --> 00:55:28.269
上的JDK 9早期访问二进制文件

00:55:25.719 --> 00:55:29.890
 java.net的模块系统已经

00:55:28.269 --> 00:55:32.890
现在和积极做

00:55:29.890 --> 00:55:35.469
自JDK模块的封装以来， 

00:55:32.890 --> 00:55:38.589
 3月26日加J深度

00:55:35.469 --> 00:55:42.249
 JDK 9中的工具比

00:55:38.589 --> 00:55:44.140
 jdk 8中的一个，您所拥有的一切

00:55:42.249 --> 00:55:45.819
想了解模块系统

00:55:44.140 --> 00:55:49.569
包括我在这里所说的很多

00:55:45.819 --> 00:55:51.909
我不能强调在JEP 261中讨论的内容

00:55:49.569 --> 00:55:56.169
有多少有价值的信息

00:55:51.909 --> 00:55:59.079
注入261还有JEP 260 

00:55:56.169 --> 00:56:02.949
定义那些JDK内部类为

00:55:59.079 --> 00:56:04.479
暴露在jdk 9和JEP 223中

00:56:02.949 --> 00:56:07.299
定义新版本的字符串

00:56:04.479 --> 00:56:09.659
开头的九个点和JEP 220 

00:56:07.299 --> 00:56:13.209
描述三人如何消失， 

00:56:09.659 --> 00:56:15.130
最后，JEP 200概述了

00:56:13.209 --> 00:56:17.890
 JDK模块，但如果您已经阅读过

00:56:15.130 --> 00:56:20.469
 JEP 261不会有任何惊喜

00:56:17.890 --> 00:56:23.519
 200，并在第五十六分钟

00:56:20.469 --> 00:56:23.519
非常感谢你

00:56:28.210 --> 00:56:33.530
我们会提出我认为我们已经提出的问题

00:56:30.860 --> 00:56:36.740
到了15分钟

00:56:33.530 --> 00:56:41.240
一直在为他们的iphone充电

00:56:36.740 --> 00:56:44.630
进行得如此缓慢如果您一切顺利

00:56:41.240 --> 00:56:46.670
有问题请提出

00:56:44.630 --> 00:56:48.200
前面，如果你站着，我们听不见你的声音

00:56:46.670 --> 00:56:49.580
你在哪里我保证我们不会

00:56:48.200 --> 00:56:51.920
我们听不到您的声音，所以如果您有

00:56:49.580 --> 00:56:55.970
问题，请过来使用此麦克风

00:56:51.920 --> 00:56:57.380
这是一个不同于

00:56:55.970 --> 00:57:02.180
是你之前问过的

00:56:57.380 --> 00:57:05.240
不同，所以我一直都在做一件事

00:57:02.180 --> 00:57:07.100
在tomcat中发现奇怪之处，他们试图防止

00:57:05.240 --> 00:57:09.170
通过了解Classloader D联盟

00:57:07.100 --> 00:57:12.880
卸载网站时的所有静态字段

00:57:09.170 --> 00:57:15.380
我认为这将不再起作用的应用程序

00:57:12.880 --> 00:57:17.240
如果他们做对了就行

00:57:15.380 --> 00:57:19.550
他们如何做到这一点，因为

00:57:17.240 --> 00:57:22.970
他们正在加载Tomcat类

00:57:19.550 --> 00:57:24.680
如果网络应用本身是一个模块，但是

00:57:22.970 --> 00:57:29.180
它的所有类均由tom cat加载

00:57:24.680 --> 00:57:33.140
汤姆猫是神，它可以重写模块

00:57:29.180 --> 00:57:35.360
声明方式可以选择

00:57:33.140 --> 00:57:38.810
顺便出口到自己

00:57:35.360 --> 00:57:41.060
或其任何模块将其打包到其模块之一

00:57:38.810 --> 00:57:42.230
需要反思，虽然是否

00:57:41.060 --> 00:57:43.880
它实际上需要做你刚刚做的

00:57:42.230 --> 00:57:48.550
说听起来像是一个优化

00:57:43.880 --> 00:57:52.580
您可能不需要对它的麦克风

00:57:48.550 --> 00:57:55.070
还有一个具体的问题清单

00:57:52.580 --> 00:57:58.010
 Tomcat对JDK的引用

00:57:55.070 --> 00:58:00.080
以及它进入JDK的位置以及所有

00:57:58.010 --> 00:58:01.250
怀疑领域和诸如此类的事情

00:58:00.080 --> 00:58:03.590
这些问题实际上已经

00:58:01.250 --> 00:58:06.110
已经解决，实际上在过去

00:58:03.590 --> 00:58:08.840
几张账单有一些具体的

00:58:06.110 --> 00:58:13.180
在JDK中专门针对这些进行了修复

00:58:08.840 --> 00:58:15.500
 Tomcat遇到的问题类型

00:58:13.180 --> 00:58:17.000
谢谢你，实际上是维护者

00:58:15.500 --> 00:58:18.230
 zuv Tomcat，我认为Mark Thomas在

00:58:17.000 --> 00:58:19.940
特别是在

00:58:18.230 --> 00:58:22.990
实际上发现这些问题， 

00:58:19.940 --> 00:58:22.990
发送错误报告

00:58:23.069 --> 00:58:27.579
有问题的人是

00:58:25.119 --> 00:58:32.619
离开，那是一个成功的策略

00:58:27.579 --> 00:58:38.380
是的，这将是命运

00:58:32.619 --> 00:58:42.249
阴影罐子和超级罐子，罗伯特在哪里

00:58:38.380 --> 00:58:47.319
哦，就在您身后

00:58:42.249 --> 00:58:53.559
我他们我不知道问行家

00:58:47.319 --> 00:58:56.460
提交人说某人不仅是

00:58:53.559 --> 00:58:59.619
女佣的问题是关于分享

00:58:56.460 --> 00:59:03.369
正确创建超级罐子

00:58:59.619 --> 00:59:06.819
您将所有课程都放在一个内

00:59:03.369 --> 00:59:11.019
罐子，所以您失去了封装

00:59:06.819 --> 00:59:14.470
所以我知道商标与

00:59:11.019 --> 00:59:16.420
那只是他的问题清单，所以

00:59:14.470 --> 00:59:18.809
等待答案的生活或建议

00:59:16.420 --> 00:59:18.809
为了它

00:59:24.580 --> 00:59:34.220
哈没有其他问题啊，好的，哇

00:59:32.600 --> 00:59:35.780
我们确实提高了进入壁垒

00:59:34.220 --> 00:59:41.000
很高，所以没有人有疑问

00:59:35.780 --> 00:59:43.910
你能再举一个例子吗？ 

00:59:41.000 --> 00:59:45.380
您在这里有什么网站可以管理

00:59:43.910 --> 00:59:51.470
就像这个Hadoop层

00:59:45.380 --> 00:59:53.690
 JavaScript层Tomcats我的意思是

00:59:51.470 --> 00:59:54.980
很难理解我们多么无私

00:59:53.690 --> 00:59:57.350
如果您是

00:59:54.980 --> 01:00:02.150
今天旋转装载机的框架

00:59:57.350 --> 01:00:04.490
一切仍然有效v你甚至可以知道你

01:00:02.150 --> 01:00:05.930
甚至可以从模块化jar中加载类

01:00:04.490 --> 01:00:07.490
文件，如果你是全部

01:00:05.930 --> 01:00:09.500
框架，而您忽略了该模块

01:00:07.490 --> 01:00:13.640
在照片课程文件中，好，这是您的

01:00:09.500 --> 01:00:16.730
 out望台，但如果您想尊重

01:00:13.640 --> 01:00:20.900
模块化依赖关系和封装

01:00:16.730 --> 01:00:23.480
 Web应用程序代码本身将其编写出来

01:00:20.900 --> 01:00:25.820
到容器中不要忽略模块

01:00:23.480 --> 01:00:28.370
联邦级文件以加载它们并

01:00:25.820 --> 01:00:29.450
当您加载它们时，整个要点是

01:00:28.370 --> 01:00:31.570
一个模块说不仅

01:00:29.450 --> 01:00:36.110
出口局取决于

01:00:31.570 --> 01:00:38.510
希望汤姆猫能够打电话

01:00:36.110 --> 01:00:42.230
模块系统API来解决这些问题

01:00:38.510 --> 01:00:44.270
依赖并旋转一小层

01:00:42.230 --> 01:00:48.170
与完全相同的类

01:00:44.270 --> 01:00:51.620
它曾经有过，但有

01:00:48.170 --> 01:00:55.610
该装载机现在已知是

01:00:51.620 --> 01:00:58.610
模块加载映射的模块告诉

01:00:55.610 --> 01:01:00.200
到这个新层，所以图

01:00:58.610 --> 01:01:02.810
类气味看起来相同

01:01:00.200 --> 01:01:04.850
运行时（如果可以这样可视化） 

01:01:02.810 --> 01:01:07.040
别人是我们的一部分吗

01:01:04.850 --> 01:01:10.850
然后将资源导出到或做

01:01:07.040 --> 01:01:13.790
遵循相同的规则是的

01:01:10.850 --> 01:01:16.520
关于您使用哪些资源的规则

01:01:13.790 --> 01:01:19.520
出口关键字是宾得包

01:01:16.520 --> 01:01:21.500
命名这是一个好问题，不是

01:01:19.520 --> 01:01:23.780
你没有这样指定资源

01:01:21.500 --> 01:01:26.360
但它们大多是有用的

01:01:23.780 --> 01:01:27.950
导出资源以进行反思

01:01:26.360 --> 01:01:33.500
访问方式是如何到达他们的

01:01:27.950 --> 01:01:35.720
是的，所以朱莉像你一样知道

01:01:33.500 --> 01:01:36.890
有时候你把资源放在一个

01:01:35.720 --> 01:01:37.280
相同的名称放置您的包裹

01:01:36.890 --> 01:01:40.700
其他

01:01:37.280 --> 01:01:42.860
我不只是喜欢发明

01:01:40.700 --> 01:01:45.860
现在一切都需要在Java中完成

01:01:42.860 --> 01:01:48.350
包裹，我知道哦，不，不，你仍然可以

01:01:45.860 --> 01:01:49.970
在Metron中拥有您的资源，这是什么

01:01:48.350 --> 01:01:52.880
是否将其导出的规则

01:01:49.970 --> 01:01:54.260
艺术，如果有的话

01:01:52.880 --> 01:01:56.030
映射到包，那么必须有

01:01:54.260 --> 01:01:58.190
如果您已经进入顶级，则导出

01:01:56.030 --> 01:01:59.870
确定在的软件包

01:01:58.190 --> 01:02:01.670
顶级目录不是真的

01:01:59.870 --> 01:02:03.470
像meta-inf这样的软件包无效

01:02:01.670 --> 01:02:05.360
包名称，然后他们继续

01:02:03.470 --> 01:02:08.930
能够找到并访问它们

01:02:05.360 --> 01:02:12.890
就像您一向做的一样

01:02:08.930 --> 01:02:14.510
在两个例外的情况下， 

01:02:12.890 --> 01:02:16.490
更新的提案中有一个具体的

01:02:14.510 --> 01:02:18.290
 doc类文件的异常，因为

01:02:16.490 --> 01:02:21.710
有很多很多你需要卡通

01:02:18.290 --> 01:02:23.540
访问类文件，以便它们可以正常工作

01:02:21.710 --> 01:02:25.430
我可以只说一件事吗

01:02:23.540 --> 01:02:27.200
在第一方的第一层上

01:02:25.430 --> 01:02:30.530
问题是它实际上并不需要

01:02:27.200 --> 01:02:32.540
复杂的应用服务器以使用图层

01:02:30.530 --> 01:02:33.980
实际上有很多工具甚至可能

01:02:32.540 --> 01:02:37.330
实际也使用图层

01:02:33.980 --> 01:02:39.590
 Java C编译器加载的示例

01:02:37.330 --> 01:02:41.990
部署的注释处理器

01:02:39.590 --> 01:02:44.420
作为各自层中的模块

01:02:41.990 --> 01:02:46.100
 jaail工具可以有一个插件

01:02:44.420 --> 01:02:49.700
您可以实际部署的界面

01:02:46.100 --> 01:02:51.640
插件作为模块，他们将

01:02:49.700 --> 01:02:54.320
实际上被加载到自己的图层中

01:02:51.640 --> 01:02:56.660
是的，这就是靴巢的父母

01:02:54.320 --> 01:02:58.810
所以有很多工具可以

01:02:56.660 --> 01:02:58.810
全部做完

