WEBVTT
Kind: captions
Language: zh-Hans

00:00:05.009 --> 00:00:10.470
早上好，欢迎来到宽敞的

00:00:08.719 --> 00:00:12.680
项目拼图黑客

00:00:10.470 --> 00:00:15.720
而且前面有很多座位

00:00:12.680 --> 00:00:18.480
只是警告您，但这将是质量检查

00:00:15.720 --> 00:00:20.189
如果您想提一个问题，我们

00:00:18.480 --> 00:00:22.350
会要求您在这里使用麦克风

00:00:20.189 --> 00:00:23.970
这样每个人都能听到，所以所有

00:00:22.350 --> 00:00:26.610
互联网上可爱的人可以

00:00:23.970 --> 00:00:28.560
听到，如果你打算问问题

00:00:26.610 --> 00:00:30.119
坐在前面可能是我们的

00:00:28.560 --> 00:00:32.130
另一方面，如果你想要

00:00:30.119 --> 00:00:35.310
你可以坐在后面做运动

00:00:32.130 --> 00:00:37.770
嗨，我是马克·莱因霍尔德，我是艾伦

00:00:35.310 --> 00:00:40.440
 Bateman和Mandy Chung我们都在努力

00:00:37.770 --> 00:00:42.120
项目拼图以及其他一些项目

00:00:40.440 --> 00:00:46.670
像Alex Buckley这样的人

00:00:42.120 --> 00:00:50.940
今天早上在这里快速提醒

00:00:46.670 --> 00:00:52.980
可悲的是，我们有很多次会议

00:00:50.940 --> 00:00:55.400
其中一些是过去和现在

00:00:52.980 --> 00:00:59.070
这一点你可以在视频上捕捉到他们

00:00:55.400 --> 00:01:00.900
除了亲自以外

00:00:59.070 --> 00:01:05.189
模块化开发简介将

00:01:00.900 --> 00:01:08.159
今天3点4:30被重复

00:01:05.189 --> 00:01:10.439
以及明天的模块和服务

00:01:08.159 --> 00:01:12.600
下午2点

00:01:10.439 --> 00:01:16.230
快速调查一下有多少人

00:01:12.600 --> 00:01:19.320
去过介绍已经好多少

00:01:16.230 --> 00:01:20.460
人们去过先进如何

00:01:19.320 --> 00:01:24.150
很多人去过模块和

00:01:20.460 --> 00:01:26.130
服务人员，这正在减少

00:01:24.150 --> 00:01:29.040
回到这里好吧，那对你好

00:01:26.130 --> 00:01:33.000
你有更多的机会让我们看看

00:01:29.040 --> 00:01:35.100
否则，我们是否能获得信息

00:01:33.000 --> 00:01:38.130
从那以后就已经看到过这样的幻灯片

00:01:35.100 --> 00:01:40.470
您去过较早的会谈

00:01:38.130 --> 00:01:44.430
有大量的文档，尽管

00:01:40.470 --> 00:01:47.250
一二之中很多都比较密集

00:01:44.430 --> 00:01:49.830
三四五不同的jep的jdk 

00:01:47.250 --> 00:01:53.270
您可以找到增强建议链接

00:01:49.830 --> 00:01:53.270
到拼图项目页面上的人

00:01:53.750 --> 00:01:58.560
还有jsr 376， 

00:01:57.030 --> 00:02:00.930
从拼图项目页面链接到

00:01:58.560 --> 00:02:03.409
特别是有一个文件叫做

00:02:00.930 --> 00:02:05.970
模块系统的状态为aa 

00:02:03.409 --> 00:02:13.379
所有基本功能的摘要

00:02:05.970 --> 00:02:17.760
模块系统的另一个笑话

00:02:13.379 --> 00:02:22.010
提醒282对，那里的J 

00:02:17.760 --> 00:02:22.010
链接JEP 282应该添加对不起

00:02:22.510 --> 00:02:36.950
好吧，我们为Oracle问题工作

00:02:32.780 --> 00:02:40.340
请如果你是

00:02:36.950 --> 00:02:41.330
害羞，如果你在

00:02:40.340 --> 00:02:42.590
你知道我是说我们就是我们

00:02:41.330 --> 00:02:45.380
这里的朋友不是

00:02:42.590 --> 00:02:48.459
很多人所有的一切

00:02:45.380 --> 00:02:48.459
发生在房间里停留在房间里

00:02:49.720 --> 00:02:52.930
好，我们完成了

00:02:53.830 --> 00:02:59.450
请那个麦克风

00:02:55.989 --> 00:03:01.099
所以我从事安全工程

00:02:59.450 --> 00:03:04.579
团队和我们遇到的问题之一

00:03:01.099 --> 00:03:10.280
是一些api是通用的

00:03:04.579 --> 00:03:13.760
有些容易被滥用，因此放置

00:03:10.280 --> 00:03:16.160
如果您可以导出软件包

00:03:13.760 --> 00:03:19.250
容易被滥用，因为这使您

00:03:16.160 --> 00:03:24.410
归类为消耗他们的白名单

00:03:19.250 --> 00:03:27.410
很好，但很多时候，如果出口

00:03:24.410 --> 00:03:30.380
因为声明由

00:03:27.410 --> 00:03:32.000
他们可能没有图书馆作者

00:03:30.380 --> 00:03:34.120
详尽的清单，特别是如果这是

00:03:32.000 --> 00:03:39.730
某种开源的一部分

00:03:34.120 --> 00:03:45.200
安全产品，有没有办法

00:03:39.730 --> 00:03:49.370
捆绑在一起时是正确的

00:03:45.200 --> 00:03:52.069
一个应用程序将导出为

00:03:49.370 --> 00:03:54.200
他们可能是基于一些基本的

00:03:52.069 --> 00:03:55.970
你，你，你，你，你在想像

00:03:54.200 --> 00:04:00.160
有别人制作的模块

00:03:55.970 --> 00:04:02.030
你想改变他的出口

00:04:00.160 --> 00:04:04.630
因为你比他们更了解

00:04:02.030 --> 00:04:04.630
你会介意的

00:04:06.170 --> 00:04:20.489
确保我来了麦克风之前

00:04:09.000 --> 00:04:23.460
请给我上一堂课

00:04:20.489 --> 00:04:25.980
提供的未经检查的转化

00:04:23.460 --> 00:04:28.530
类型的工厂方法

00:04:25.980 --> 00:04:31.160
封装了安全属性，因此

00:04:28.530 --> 00:04:34.830
如果你想知道

00:04:31.160 --> 00:04:36.900
在安全范围内注册商标，以及

00:04:34.830 --> 00:04:39.990
因此取消选中转换很容易

00:04:36.900 --> 00:04:41.970
如果您认识的某人误用了

00:04:39.990 --> 00:04:43.770
他们的自动填充功能很抱歉，这是这个

00:04:41.970 --> 00:04:44.850
是这是您创建的类

00:04:43.770 --> 00:04:47.280
是

00:04:44.850 --> 00:04:49.740
你能不出口什么我知道

00:04:47.280 --> 00:04:52.280
我可以拿起一件事吗

00:04:49.740 --> 00:04:54.540
你用你在问题中说的

00:04:52.280 --> 00:04:57.030
自动更正，所以我假设你

00:04:54.540 --> 00:04:59.220
实际上是指IDE 

00:04:57.030 --> 00:05:02.160
不知道有关模块的信息

00:04:59.220 --> 00:05:08.460
并自动完成，然后将

00:05:02.160 --> 00:05:12.000
方法名称，是的，我正在使用

00:05:08.460 --> 00:05:18.450
自动完成作为一种指称方式

00:05:12.000 --> 00:05:19.980
天真的用户发现此API可以，因此

00:05:18.450 --> 00:05:22.200
这是您在

00:05:19.980 --> 00:05:25.230
你维持的模型，你

00:05:22.200 --> 00:05:29.280
需要将其导出到其他模块

00:05:25.230 --> 00:05:32.580
但是不是，例如，我可能有

00:05:29.280 --> 00:05:34.230
类型安全的HTML，它是

00:05:32.580 --> 00:05:36.690
可安全嵌入的HTML 

00:05:34.230 --> 00:05:38.220
应用程序域运行我有一个

00:05:36.690 --> 00:05:40.830
可能会产生这种情况的模板系统

00:05:38.220 --> 00:05:44.720
那是第三方，我有洗手液

00:05:40.830 --> 00:05:44.720
这是脚本标签和元素统计

00:05:45.230 --> 00:05:51.840
所以项目负责人可能会说我相信

00:05:49.620 --> 00:05:53.550
编写模板系统的人

00:05:51.840 --> 00:05:54.510
我相信维护

00:05:53.550 --> 00:05:58.440
消毒剂

00:05:54.510 --> 00:06:01.290
我希望我的开发人员使用安全的HTML 

00:05:58.440 --> 00:06:05.550
不想大批

00:06:01.290 --> 00:06:10.530
应用程序开发人员正确的如此

00:06:05.550 --> 00:06:13.500
对，所以我不是一个合格的专家

00:06:10.530 --> 00:06:15.840
对不起，我太无知了

00:06:13.500 --> 00:06:16.420
与出口不同的合格专家

00:06:15.840 --> 00:06:19.390
如

00:06:16.420 --> 00:06:21.430
那里不对不起没有出口

00:06:19.390 --> 00:06:24.010
出来，所以您可以将公鸡出口导出到

00:06:21.430 --> 00:06:26.440
 ISA记录，您开始感到抱歉

00:06:24.010 --> 00:06:28.030
出口到合格暴露所以

00:06:26.440 --> 00:06:30.940
你可以说出口福

00:06:28.030 --> 00:06:32.350
出口包装食品给任何人

00:06:30.940 --> 00:06:34.840
需要您的模块的其他模块

00:06:32.350 --> 00:06:37.930
是的，或者您可以说将食物出口到酒吧

00:06:34.840 --> 00:06:40.600
逗号baz无论什么，只有模块

00:06:37.930 --> 00:06:45.070
名为bar和baz的用户可以访问

00:06:40.600 --> 00:06:47.220
好吧，所以我的问题是

00:06:45.070 --> 00:06:51.130
安全的HTML我想导出这个

00:06:47.220 --> 00:06:54.660
未经检查的转换包

00:06:51.130 --> 00:06:58.270
包含未经检查的转化

00:06:54.660 --> 00:07:01.120
对模板系统进行消毒的权利

00:06:58.270 --> 00:07:02.530
所有这三个都是安全的HTML 

00:07:01.120 --> 00:07:05.830
定义这些都是开源的

00:07:02.530 --> 00:07:10.890
项目，我想做出口

00:07:05.830 --> 00:07:15.430
到没有你知道我是否要

00:07:10.890 --> 00:07:19.260
重写安全的HTML捆绑软件说

00:07:15.430 --> 00:07:23.710
定义不错，但是知道了

00:07:19.260 --> 00:07:26.830
所以我们的总体理念是

00:07:23.710 --> 00:07:29.080
虽然是最好的尊重

00:07:26.830 --> 00:07:30.940
模块作者的初衷

00:07:29.080 --> 00:07:32.800
就在我们投入更多的地方

00:07:30.940 --> 00:07:34.480
权力掌握在某人手中

00:07:32.800 --> 00:07:38.850
维护组件，以便他们可以

00:07:34.480 --> 00:07:41.410
说我想出口这个而不是那个

00:07:38.850 --> 00:07:43.900
这就是主要的

00:07:41.410 --> 00:07:46.720
但是是的，有时候你

00:07:43.900 --> 00:07:48.880
当你需要打破的时候

00:07:46.720 --> 00:07:52.030
粗略的方法是在命令行上

00:07:48.880 --> 00:07:54.820
你处在一个场景中

00:07:52.030 --> 00:07:56.380
你在写，你在写

00:07:54.820 --> 00:07:57.940
那种容器或者你在写

00:07:56.380 --> 00:07:59.440
写某种容器

00:07:57.940 --> 00:08:02.290
你有机会可以

00:07:59.440 --> 00:08:05.680
当然可以重写模块输入

00:08:02.290 --> 00:08:09.640
加载文件时知道的类文件

00:08:05.680 --> 00:08:11.530
这是一个班级文件并且sm已经

00:08:09.640 --> 00:08:13.150
一个已经了解他们，所以如果你

00:08:11.530 --> 00:08:15.250
真的很想你可以拦截他们

00:08:13.150 --> 00:08:17.260
你知道如果你写的话

00:08:15.250 --> 00:08:19.450
创建班级字母的代码

00:08:17.260 --> 00:08:21.730
它加载那些然后你可以拦截

00:08:19.450 --> 00:08:24.490
他们在途中去改变

00:08:21.730 --> 00:08:26.350
他们的出口，如果你想或

00:08:24.490 --> 00:08:28.490
您可以轻松编辑二进制文件

00:08:26.350 --> 00:08:30.349
文物

00:08:28.490 --> 00:08:31.849
我的意思是我不想在生产中做

00:08:30.349 --> 00:08:34.849
环境但是有些人喜欢

00:08:31.849 --> 00:08:36.919
做到这一点就可以，当然可以

00:08:34.849 --> 00:08:38.120
知道把jar文件移到中央或

00:08:36.919 --> 00:08:40.760
随身携带它

00:08:38.120 --> 00:08:44.390
去修改修改那个，然后把那个

00:08:40.760 --> 00:08:47.660
在您的档案中并部署

00:08:44.390 --> 00:08:52.810
那里没有故意

00:08:47.660 --> 00:08:54.830
没有让它变得微不足道的API， 

00:08:52.810 --> 00:08:56.060
基本上违反了

00:08:54.830 --> 00:08:59.180
模块作者，因为我们认为

00:08:56.060 --> 00:09:01.279
同样重要，我们认为这很重要

00:08:59.180 --> 00:09:04.070
有一定的门槛

00:09:01.279 --> 00:09:13.580
你知道那里的抵抗障碍

00:09:04.070 --> 00:09:14.720
因为不应该阻止它

00:09:13.580 --> 00:09:18.399
没有没有层次的

00:09:14.720 --> 00:09:18.399
间接我们是我们足够

00:09:18.880 --> 00:09:23.750
有远见的模块作者可以

00:09:21.170 --> 00:09:25.370
会想，哦，也许你知道一些

00:09:23.750 --> 00:09:27.230
我的用户将要这样做并放入

00:09:25.370 --> 00:09:28.580
在占位符中，然后放在那里

00:09:27.230 --> 00:09:30.830
有一个导航由

00:09:28.580 --> 00:09:34.370
稍后的模块系统

00:09:30.830 --> 00:09:36.709
您知道我认为的可配置性

00:09:34.370 --> 00:09:39.350
很有趣，但是我们

00:09:36.709 --> 00:09:40.790
需要得到一个零，你知道

00:09:39.350 --> 00:09:42.290
经过几年的经验

00:09:40.790 --> 00:09:49.220
也许我们要添加一些东西

00:09:42.290 --> 00:09:50.570
这样也许吧，就是这样

00:09:49.220 --> 00:09:52.279
绝对感觉像是种东西

00:09:50.570 --> 00:09:56.990
我们需要更多的经验

00:09:52.279 --> 00:09:58.459
证明是正确的，所以你知道它总是

00:09:56.990 --> 00:10:01.790
设计类似的东西有点费劲

00:09:58.459 --> 00:10:04.490
不管你怎么努力思考

00:10:01.790 --> 00:10:07.430
转发你会想念小姐的东西， 

00:10:04.490 --> 00:10:09.440
所以我们尽量让您知道尝试保持

00:10:07.430 --> 00:10:11.720
轻松开始了解人们的

00:10:09.440 --> 00:10:14.920
经验使您对它有所了解

00:10:11.720 --> 00:10:14.920
接下来的几个主要版本

00:10:30.930 --> 00:10:34.680
别再问问题了

00:10:37.490 --> 00:10:41.660
利亚特请来麦克风

00:10:43.430 --> 00:10:49.910
所以我实际上是在介绍

00:10:46.490 --> 00:10:53.300
买一个工作的人

00:10:49.910 --> 00:10:54.500
项目，但在预conf，这样

00:10:53.300 --> 00:10:57.800
可能一直在讨论

00:10:54.500 --> 00:11:01.100
实际上，但是如果您能给一点

00:10:57.800 --> 00:11:03.500
有关其如何工作的详细信息

00:11:01.100 --> 00:11:08.180
您可以使用两个不同的版本

00:11:03.500 --> 00:11:12.020
相同的模块，所以假设您知道

00:11:08.180 --> 00:11:14.360
我们有谁说你可以那样做对不起

00:11:12.020 --> 00:11:16.760
等我不知道会怎样

00:11:14.360 --> 00:11:19.280
前一天的预告片是什么样的

00:11:16.760 --> 00:11:23.390
 Java一个故事，所以我给了

00:11:19.280 --> 00:11:24.980
演示文稿我可以拿起来我

00:11:23.390 --> 00:11:28.250
只是好奇，因为我们都不是

00:11:24.980 --> 00:11:31.940
是的，就像前一天一样

00:11:28.250 --> 00:11:34.340
在星期天，在那里有人提到

00:11:31.940 --> 00:11:36.980
所以现在我们有问题

00:11:34.340 --> 00:11:39.740
对的，例如你，nettie好吧，我

00:11:36.980 --> 00:11:41.600
有三个不同的库使用

00:11:39.740 --> 00:11:44.200
不同版本的nettie，它们

00:11:41.600 --> 00:11:47.120
碰撞，所以我有elasticsearch我有一个

00:11:44.200 --> 00:11:49.070
动物园管理员客户，我有CH DP 

00:11:47.120 --> 00:11:52.340
客户所有在团结中使用

00:11:49.070 --> 00:11:54.620
不同的版本，好吧，如何

00:11:52.340 --> 00:11:57.470
你今天处理这个吗

00:11:54.620 --> 00:12:00.140
罐子，我很痛苦地重新包装

00:11:57.470 --> 00:12:02.330
他们是可怕的是

00:12:00.140 --> 00:12:05.630
通常您需要上传这些二进制文件

00:12:02.330 --> 00:12:07.940
重新包装与您知道，所以经常

00:12:05.630 --> 00:12:09.320
但我在决赛中如此

00:12:07.940 --> 00:12:12.590
您有三种不同的应用

00:12:09.320 --> 00:12:13.850
 Nettie的副本是至少两个

00:12:12.590 --> 00:12:17.960
还没有全部

00:12:13.850 --> 00:12:21.680
软件包重命名为是，很抱歉，是这样

00:12:17.960 --> 00:12:23.270
这在最后是有效的，然后

00:12:21.680 --> 00:12:25.070
它有效，但很痛苦，而且

00:12:23.270 --> 00:12:27.200
容易出错，因为人们可以使用您

00:12:25.070 --> 00:12:28.610
知道不同是因为我们

00:12:27.200 --> 00:12:29.900
那么就没有多系统质量

00:12:28.610 --> 00:12:32.410
一切都暴露了人们可以使用

00:12:29.900 --> 00:12:36.320
这个版本的C和那个音乐家

00:12:32.410 --> 00:12:39.590
这样就可以了，所以很容易回答

00:12:36.320 --> 00:12:41.870
我给的是选一个，但我

00:12:39.590 --> 00:12:44.270
我不能，因为它们是二进制的

00:12:41.870 --> 00:12:45.860
不兼容，我需要该功能

00:12:44.270 --> 00:12:47.420
来自elasticsearch以及该功能

00:12:45.860 --> 00:12:50.300
来自Zookeeper，而该功能来自

00:12:47.420 --> 00:12:53.260
性感大灯右先生

00:12:50.300 --> 00:12:56.089
所以拼图是不会解决的

00:12:53.260 --> 00:12:58.459
那不是那不是设计

00:12:56.089 --> 00:13:00.760
平台模块中心

00:12:58.459 --> 00:13:00.760
系统

00:13:05.459 --> 00:13:11.179
有设施允许

00:13:07.589 --> 00:13:14.220
您有一个的多个版本

00:13:11.179 --> 00:13:16.110
系统中同名的模块

00:13:14.220 --> 00:13:18.449
但他们相当先进，他们

00:13:16.110 --> 00:13:21.149
他们是专为那些谁是

00:13:18.449 --> 00:13:23.160
编写您知道应用服务器的容器

00:13:21.149 --> 00:13:26.100
或测试线束或事物

00:13:23.160 --> 00:13:27.329
具有至少

00:13:26.100 --> 00:13:30.389
他们在做自己的事的老练

00:13:27.329 --> 00:13:33.899
自己做自己的类加载器

00:13:30.389 --> 00:13:35.639
没有做出故意的设计决定

00:13:33.899 --> 00:13:38.879
尝试处理多个版本

00:13:35.639 --> 00:13:42.990
问题，因为在

00:13:38.879 --> 00:13:46.819
普遍性带来大量复杂性

00:13:42.990 --> 00:13:49.259
然后你结束了那些胃肠道

00:13:46.819 --> 00:13:52.410
是的，哦，那实际上是

00:13:49.259 --> 00:13:55.350
在那次会议上讨论过，我问他

00:13:52.410 --> 00:13:57.959
听起来像OSGi做得对，他

00:13:55.350 --> 00:14:00.179
说不同，但可以给你

00:13:57.959 --> 00:14:04.740
就像很多相同的价值系列

00:14:00.179 --> 00:14:06.179
说不容易，所以我需要写

00:14:04.740 --> 00:14:07.769
所以他们在那里有一个

00:14:06.179 --> 00:14:09.329
这个概念叫做层，如果

00:14:07.769 --> 00:14:10.980
您去过高级讲座或

00:14:09.329 --> 00:14:13.049
仍然可以去发明

00:14:10.980 --> 00:14:15.360
是的，您可以了解图层和

00:14:13.049 --> 00:14:16.980
如果你知道的话

00:14:15.360 --> 00:14:20.220
像你真正需要做的

00:14:16.980 --> 00:14:24.240
这一种方法适合您

00:14:20.220 --> 00:14:25.619
加载您知道的nettie的每个版本

00:14:24.240 --> 00:14:27.029
与特定的事物一起

00:14:25.619 --> 00:14:28.740
 elasticsearch或任何需要

00:14:27.029 --> 00:14:32.429
将其用于自己的图层

00:14:28.740 --> 00:14:34.589
一流的汽车，对吧，我们知道

00:14:32.429 --> 00:14:35.670
实际上我们有api使我

00:14:34.589 --> 00:14:36.299
如果您只是需要

00:14:35.670 --> 00:14:38.339
花园品种

00:14:36.299 --> 00:14:41.129
类加载器，那么您可以非常轻松地

00:14:38.339 --> 00:14:43.410
铺一层，然后喂

00:14:41.129 --> 00:14:45.629
将ISM作为解析器的输入

00:14:43.410 --> 00:14:46.949
所以不难做到不喜欢它

00:14:45.629 --> 00:14:48.860
需要一千行代码

00:14:46.949 --> 00:14:51.240
你大概可以做到

00:14:48.860 --> 00:14:55.679
但这有点复杂

00:14:51.240 --> 00:14:56.879
方法好吧谢谢我

00:14:55.679 --> 00:14:59.309
实际上应该认为那可能

00:14:56.879 --> 00:15:01.290
就像你所说的测试线束

00:14:59.309 --> 00:15:05.129
因为我们遇到的问题之一

00:15:01.290 --> 00:15:07.799
是我们已经有几次

00:15:05.129 --> 00:15:12.149
应用程序部署，我们将喷气机嵌入我们的

00:15:07.799 --> 00:15:13.620
自己的可运行罐子和应用程序去了

00:15:12.149 --> 00:15:15.899
没有我的生产

00:15:13.620 --> 00:15:17.999
后继连接器，因为在测试过程中

00:15:15.899 --> 00:15:19.260
人们在范围测试中得到了我的签名

00:15:17.999 --> 00:15:20.400
和行家

00:15:19.260 --> 00:15:22.770
一切正常，因为

00:15:20.400 --> 00:15:25.170
类路径是共享的，但是当

00:15:22.770 --> 00:15:27.150
他们来了一个失败的作品，所以我

00:15:25.170 --> 00:15:29.040
也许还可以使用图层

00:15:27.150 --> 00:15:30.360
层也可能在这里有用

00:15:29.040 --> 00:15:33.480
等一下，我们已经在使用图层了

00:15:30.360 --> 00:15:36.390
在JT reg测试工具中并打开

00:15:33.480 --> 00:15:38.550
 JDK我们使用Java C所使用的

00:15:36.390 --> 00:15:41.850
你有一个注释处理器

00:15:38.550 --> 00:15:43.230
 Java C和JDK 9将它们加载到

00:15:41.850 --> 00:15:47.160
层并不特别困难

00:15:43.230 --> 00:15:49.350
好吧，所以你可以，你当然可以做

00:15:47.160 --> 00:15:52.740
有点背景故事

00:15:49.350 --> 00:15:57.510
在那并填写一些

00:15:52.740 --> 00:15:58.890
你知道的哲学图景

00:15:57.510 --> 00:16:00.510
我们经历了许多回合

00:15:58.890 --> 00:16:02.520
饮料原型，所以第一个大

00:16:00.510 --> 00:16:04.760
我们实际上拥有的原型

00:16:02.520 --> 00:16:08.280
语言和版本限制

00:16:04.760 --> 00:16:10.740
你知道复杂的启发式

00:16:08.280 --> 00:16:13.020
寻找最佳的您知道的版本

00:16:10.740 --> 00:16:16.170
从

00:16:13.020 --> 00:16:20.670
透视模型中的一组模块

00:16:16.170 --> 00:16:23.370
图，它变得非常毛茸茸

00:16:20.670 --> 00:16:26.850
很快，除了叹息

00:16:23.370 --> 00:16:29.430
不想复制那种

00:16:26.850 --> 00:16:30.990
模块系统的复杂性

00:16:29.430 --> 00:16:32.760
知道我们这就是它的全部创造

00:16:30.990 --> 00:16:35.430
与我们其他目标之一的紧张关系

00:16:32.760 --> 00:16:38.220
可以与现有产品很好地配合

00:16:35.430 --> 00:16:40.170
建立工具，让您知道Maven Gradle全部

00:16:38.220 --> 00:16:42.090
这些东西的想法四或任何他们

00:16:40.170 --> 00:16:47.190
都有自己的应对方式

00:16:42.090 --> 00:16:50.400
版本冲突，我III理解他们

00:16:47.190 --> 00:16:52.740
不是最优的，但是它们是什么

00:16:50.400 --> 00:16:54.330
他们是，你知道数百万， 

00:16:52.740 --> 00:16:55.680
数百万开发人员使用它们， 

00:16:54.330 --> 00:16:58.530
希望他们会随着时间的推移变得更好

00:16:55.680 --> 00:17:01.170
不管我们知道是否做满

00:16:58.530 --> 00:17:02.940
拼图中的完整版本解决方案

00:17:01.170 --> 00:17:05.190
我们所做的与您的不符

00:17:02.940 --> 00:17:06.839
构建系统可以或我们可以做到

00:17:05.190 --> 00:17:09.540
匹配其中一个而不是另一个

00:17:06.839 --> 00:17:11.459
知道两个或五个或任何东西，所以我们

00:17:09.540 --> 00:17:13.709
几年前的某个时刻，我们只是

00:17:11.459 --> 00:17:16.230
让这个里面稍等一下吧

00:17:13.709 --> 00:17:18.930
做版本，它简化了很多

00:17:16.230 --> 00:17:22.520
东西，所以这就是为什么我们想要一个

00:17:18.930 --> 00:17:22.520
我们今天就在这里

00:17:23.920 --> 00:17:30.520
我想验证了解

00:17:27.450 --> 00:17:34.210
反思以及这一切如何运作

00:17:30.520 --> 00:17:36.280
如果我是杰克逊开发人员，显然

00:17:34.210 --> 00:17:39.040
不知道谁要寄给我他们的

00:17:36.280 --> 00:17:41.350
类，所以我不能要求他们，但是

00:17:39.040 --> 00:17:44.530
运行时间，对不起，您正在努力

00:17:41.350 --> 00:17:45.640
杰克逊（Jackson），我在Jax上工作。 

00:17:44.530 --> 00:17:50.530
其实不知道我只是在做

00:17:45.640 --> 00:17:53.200
好的，不管我们做什么

00:17:50.530 --> 00:17:55.680
使这个机会发展

00:17:53.200 --> 00:17:57.670
今天下午也要提前讲话

00:17:55.680 --> 00:17:59.890
杰克逊一直以来都非常非常

00:17:57.670 --> 00:18:03.400
对我们来说很好的例子

00:17:59.890 --> 00:18:06.730
像杰克逊这样的东西在

00:18:03.400 --> 00:18:10.780
如果有人通过我上课或

00:18:06.730 --> 00:18:13.480
一个类名，那么他们将不得不

00:18:10.780 --> 00:18:17.710
出口我的意思是，他们必须记得

00:18:13.480 --> 00:18:20.470
好出口给我，如果很好，或者

00:18:17.710 --> 00:18:22.450
只是向所有人出口，如果

00:18:20.470 --> 00:18:24.190
他们想锁定我的意思是如果他们

00:18:22.450 --> 00:18:26.530
想完全开放自己

00:18:24.190 --> 00:18:29.110
他们可以说是私人的，这样我可以

00:18:26.530 --> 00:18:32.590
反映并进入私人领域

00:18:29.110 --> 00:18:35.620
是的，所以在这种情况下需要

00:18:32.590 --> 00:18:39.330
甚至根本不是不可能或没有必要

00:18:35.620 --> 00:18:41.740
对杰克逊说的对不起，所以

00:18:39.330 --> 00:18:43.600
反映花圈反射方式的工作方式

00:18:41.740 --> 00:18:46.840
它本来不是这样工作的，但是

00:18:43.600 --> 00:18:49.290
反射的工作原理就是这样

00:18:46.840 --> 00:18:51.520
必要时隐式添加读取边缘

00:18:49.290 --> 00:18:54.580
所以如果你是写作的话

00:18:51.520 --> 00:18:57.790
写杰克逊代码，你去用你

00:18:54.580 --> 00:18:59.320
知道Java行中的内容反映和

00:18:57.790 --> 00:19:01.720
您尝试访问某些内容

00:18:59.320 --> 00:19:03.310
其他模块（如果您所在的模块） 

00:19:01.720 --> 00:19:05.940
还没有阅读优势

00:19:03.310 --> 00:19:11.650
反射机械模块添加

00:19:05.940 --> 00:19:13.600
免费，好吧，你知道我不知道

00:19:11.650 --> 00:19:15.340
大概一年半以前，我们实际上

00:19:13.600 --> 00:19:17.280
我们实际上没有那个，所以你

00:19:15.340 --> 00:19:19.450
必须手动添加读取边缘，然后

00:19:17.280 --> 00:19:21.250
很多人指出

00:19:19.450 --> 00:19:25.090
麻烦，所以我们做到了

00:19:21.250 --> 00:19:27.730
自动对吗

00:19:25.090 --> 00:19:29.200
需要为我做那是

00:19:27.730 --> 00:19:31.420
在您的情况下，您不会

00:19:29.200 --> 00:19:33.370
在您的情况下，您不需要它

00:19:31.420 --> 00:19:35.860
你在做反射

00:19:33.370 --> 00:19:36.650
一切就在运行时

00:19:35.860 --> 00:19:38.120
而你

00:19:36.650 --> 00:19:41.120
你和你不是你是你

00:19:38.120 --> 00:19:42.830
也不仅仅是使用静态引用

00:19:41.120 --> 00:19:45.620
从编译的字节码

00:19:42.830 --> 00:19:48.740
对对对，所以您不需要它，但是

00:19:45.620 --> 00:19:51.110
对于我确实需要你做的事情

00:19:48.740 --> 00:19:53.300
知道你需要静态

00:19:51.110 --> 00:19:54.740
如果你想编译它，如果你

00:19:53.300 --> 00:19:56.990
想要如果想要的话

00:19:54.740 --> 00:19:58.520
运行它并正确安装模块

00:19:56.990 --> 00:20:01.040
为您解决，是的，您需要

00:19:58.520 --> 00:20:04.910
没关系，所以需要

00:20:01.040 --> 00:20:06.550
静态引用会给我一个很好的

00:20:04.910 --> 00:20:10.250
编译器，我不必等待

00:20:06.550 --> 00:20:13.280
运行时，但如果通过反思，我的意思是

00:20:10.250 --> 00:20:16.880
除非我不能放弃编译

00:20:13.280 --> 00:20:18.200
需要使用我的意思是我无法纠正

00:20:16.880 --> 00:20:21.680
好吧，除非你想写全部

00:20:18.200 --> 00:20:24.140
反射你的代码

00:20:21.680 --> 00:20:25.940
痛苦的是，我了解我们的方式

00:20:24.140 --> 00:20:27.380
自从你选择了之后就退出了

00:20:25.940 --> 00:20:31.550
独立开发中的Jackson图书馆

00:20:27.380 --> 00:20:32.810
我们今天稍后会重复的谈话

00:20:31.550 --> 00:20:35.870
实际看例如

00:20:32.810 --> 00:20:37.340
杰克逊数据绑定，这是一个大量使用

00:20:35.870 --> 00:20:39.050
核心反射，但它也有一个数字

00:20:37.340 --> 00:20:42.440
依赖本身，因为杰克逊

00:20:39.050 --> 00:20:44.330
数据绑定是这些部分附带的

00:20:42.440 --> 00:20:46.610
注释是Jackson核心的一部分

00:20:44.330 --> 00:20:48.440
需要它实际上需要XML它

00:20:46.610 --> 00:20:49.580
需要续集，有一堆

00:20:48.440 --> 00:20:50.960
实际需要的东西，所以我们

00:20:49.580 --> 00:20:52.640
实际上使用J技巧甚至看它

00:20:50.960 --> 00:20:54.620
依赖，我们实际上会产生一个

00:20:52.640 --> 00:20:56.480
一个模块信息声明只是为了显示

00:20:54.620 --> 00:21:00.160
它实际上看起来像什么， 

00:20:56.480 --> 00:21:00.160
您实际上会看到所有这些

00:21:02.160 --> 00:21:08.130
如果有人在看直播

00:21:04.680 --> 00:21:11.720
随时通过发送问题

00:21:08.130 --> 00:21:11.720
 Twitter我们将尽力回答他们

00:21:17.580 --> 00:21:31.960
有一些我不喜欢的东西

00:21:19.330 --> 00:21:35.470
从高级中了解

00:21:31.960 --> 00:21:40.930
该模型系统不可知

00:21:35.470 --> 00:21:44.110
类加载器正确，所以如果我有

00:21:40.930 --> 00:21:48.730
例如每个版本的Jackson的两个版本

00:21:44.110 --> 00:21:53.520
他们中有不同的阶级

00:21:48.730 --> 00:21:56.050
持有人，其中之一就骗了

00:21:53.520 --> 00:21:59.950
出口东西，然后再出口

00:21:56.050 --> 00:22:02.890
出口另一件事然后看起来像

00:21:59.950 --> 00:22:09.400
它需要意识到以下事实： 

00:22:02.890 --> 00:22:11.230
没关系，所以让我确保我已经

00:22:09.400 --> 00:22:13.870
场景正确，但您有两个版本

00:22:11.230 --> 00:22:15.550
杰克逊是的，他们俩都是

00:22:13.870 --> 00:22:18.250
它们都具有相同的模块名称

00:22:15.550 --> 00:22:19.870
是的，好的，所以您可以加载

00:22:18.250 --> 00:22:22.690
每个都放入一个单独的类加载器

00:22:19.870 --> 00:22:26.410
您可以将每个类加载器放入

00:22:22.690 --> 00:22:28.120
它自己的层，这就是我正在尝试的

00:22:26.410 --> 00:22:33.780
在Nettie场景中进行解释

00:22:28.120 --> 00:22:35.740
早期有两个不同的层

00:22:33.780 --> 00:22:37.870
在

00:22:35.740 --> 00:22:39.850
同样的费用，它们由一些托管

00:22:37.870 --> 00:22:56.590
容器应用，他们正在使用

00:22:39.850 --> 00:22:58.750
不同版本出口暴民

00:22:56.590 --> 00:23:00.520
系统将隐式地

00:22:58.750 --> 00:23:03.250
意识到这一点，因为他们在

00:23:00.520 --> 00:23:05.410
不同的层次，以便

00:23:03.250 --> 00:23:09.790
约束在一个让内

00:23:05.410 --> 00:23:14.800
一层只能有一个模块

00:23:09.790 --> 00:23:18.150
任何给定的名称，即使包装

00:23:14.800 --> 00:23:18.150
可以的冲突

00:23:27.330 --> 00:23:33.100
出口单位是

00:23:29.770 --> 00:23:37.090
如果我们做到了就打包

00:23:33.100 --> 00:23:38.410
出口单位为单一类

00:23:37.090 --> 00:23:43.720
都会非常不满意

00:23:38.410 --> 00:23:45.910
表演它也不是你

00:23:43.720 --> 00:23:49.510
实际上知道似乎

00:23:45.910 --> 00:23:52.150
是大多数组件所必需的

00:23:49.510 --> 00:23:54.400
我们已经看过，我们已经看过

00:23:52.150 --> 00:23:56.580
很多专家维护内部克隆

00:23:54.400 --> 00:23:59.530
我们调查的Maven Central的

00:23:56.580 --> 00:24:01.150
问这些你知道的问题

00:23:59.530 --> 00:24:03.490
通常，包装是指具有

00:24:01.150 --> 00:24:05.260
您的comfo使用的API 

00:24:03.490 --> 00:24:06.730
组件将具有

00:24:05.260 --> 00:24:08.320
打算被其他人使用

00:24:06.730 --> 00:24:11.800
组件和其他内部组件

00:24:08.320 --> 00:24:13.570
并且找到一个是相当不常见的

00:24:11.800 --> 00:24:22.120
具有内部和

00:24:13.570 --> 00:24:23.890
确实发生了外部问题，但是

00:24:22.120 --> 00:24:25.150
移动内部内部移动

00:24:23.890 --> 00:24:28.210
东西放到另一个包裹里

00:24:25.150 --> 00:24:29.590
不要出口是另一点

00:24:28.210 --> 00:24:31.140
在那边没有

00:24:29.590 --> 00:24:34.140
要求

00:24:31.140 --> 00:24:35.670
您模块中的类是版本

00:24:34.140 --> 00:24:37.679
您可能实际有53岁或以上

00:24:35.670 --> 00:24:39.390
您可以编译的类

00:24:37.679 --> 00:24:40.980
较旧的版本，没有任何内容

00:24:39.390 --> 00:24:43.080
实际告诉的类文件是

00:24:40.980 --> 00:24:44.010
它在什么模块中，所以当您启动时

00:24:43.080 --> 00:24:47.490
想着，你实际上

00:24:44.010 --> 00:24:49.410
认识到出口的单位

00:24:47.490 --> 00:24:50.790
出口或出口的粒度

00:24:49.410 --> 00:24:53.299
包装真的很有意义

00:24:50.790 --> 00:24:53.299
在那些情况下

00:25:00.400 --> 00:25:04.980
任何人都对罗伯特有疑问

00:25:02.230 --> 00:25:04.980
咸在这里

00:25:13.210 --> 00:25:22.990
好吧，他是你多年的斯蒂芬·好

00:25:21.550 --> 00:25:25.360
早上好，早上好，哦，你有一个

00:25:22.990 --> 00:25:27.250
清单我已经醒了，是的，我在想

00:25:25.360 --> 00:25:29.890
一夜之间我只有两个

00:25:27.250 --> 00:25:37.440
清单上的东西，所以很确定

00:25:29.890 --> 00:25:44.110
我们有一个模块a是

00:25:37.440 --> 00:25:46.240
要求模块B嗯，模块B可以看到吗

00:25:44.110 --> 00:25:48.240
模块a中的代码实际上是

00:25:46.240 --> 00:25:50.440
被模块系统阻止或只是

00:25:48.240 --> 00:25:53.260
因为通常您无法编译

00:25:50.440 --> 00:25:57.340
模块B，所以有时，如果a 

00:25:53.260 --> 00:26:00.940
需要B然后B不能要求确定

00:25:57.340 --> 00:26:04.060
但是您可以在B中使用以下代码

00:26:00.940 --> 00:26:05.980
反思阅读确定

00:26:04.060 --> 00:26:08.020
假设德出口空头， 

00:26:05.980 --> 00:26:11.230
很好，我了解那部分，但是

00:26:08.020 --> 00:26:14.470
可能已经被编译成一些

00:26:11.230 --> 00:26:17.800
其他方式，我以前得到的网络

00:26:14.470 --> 00:26:19.420
引用E类，哦，是的，如果

00:26:17.800 --> 00:26:20.920
你有一些，如果有的话

00:26:19.420 --> 00:26:23.100
打破了破碎的工具列或某些

00:26:20.920 --> 00:26:27.070
类和B的怪异出处

00:26:23.100 --> 00:26:28.780
那么你当然可以拥有

00:26:27.070 --> 00:26:31.690
您期望的一种奇怪的情况

00:26:28.780 --> 00:26:35.860
可以在运行时正常工作，但是不行

00:26:31.690 --> 00:26:39.070
所以如果你愿意的话，会阻止它马丁

00:26:35.860 --> 00:26:41.140
如果您成功创建了aa和B， 

00:26:39.070 --> 00:26:42.820
他们的模块描述符都有

00:26:41.140 --> 00:26:46.120
要求你认识你的另一个

00:26:42.820 --> 00:26:47.500
可以在运行时完成模块系统

00:26:46.120 --> 00:26:49.060
会拒绝加载它会

00:26:47.500 --> 00:26:51.820
停下来告诉你，你有一个

00:26:49.060 --> 00:26:53.680
可以在模块图中循环，但是

00:26:51.820 --> 00:26:56.230
问我为什么要a是否需要B 

00:26:53.680 --> 00:27:00.370
并且B不需要a但B却需要

00:26:56.230 --> 00:27:02.470
包含一些涉及遗嘱的代码

00:27:00.370 --> 00:27:04.870
那项工作不，你会得到非法的

00:27:02.470 --> 00:27:07.990
访问或确定记住可访问性是

00:27:04.870 --> 00:27:10.120
是一条双向路，在那

00:27:07.990 --> 00:27:12.070
它需要B然后B的情况

00:27:10.120 --> 00:27:13.330
不知何故被编译成一些有趣的东西

00:27:12.070 --> 00:27:15.400
静态引用的方式

00:27:13.330 --> 00:27:16.930
里面有东西，但看不懂

00:27:15.400 --> 00:27:17.380
因此，可读性是

00:27:16.930 --> 00:27:19.120
访问

00:27:17.380 --> 00:27:22.210
好的，为了进行访问检查

00:27:19.120 --> 00:27:24.130
工作是我们必须阅读一本

00:27:22.210 --> 00:27:26.620
而且不需要出口任何东西

00:27:24.130 --> 00:27:29.490
该类型的包装在

00:27:26.620 --> 00:27:33.160
至少现在可以在运行时在那里

00:27:29.490 --> 00:27:35.980
被使用反射API读取a和

00:27:33.160 --> 00:27:37.270
在这种情况下，它将在这里工作，但在

00:27:35.980 --> 00:27:39.040
这之间的不匹配

00:27:37.270 --> 00:27:40.900
编译时和运行时环境

00:27:39.040 --> 00:27:44.200
那么该访问检查将

00:27:40.900 --> 00:27:46.570
现在实际上失败了，如果a是一个

00:27:44.200 --> 00:27:52.120
周模块而不是强大

00:27:46.570 --> 00:27:54.640
模块会改变它吗

00:27:52.120 --> 00:27:56.800
只有改变B才能从我们身上得到

00:27:54.640 --> 00:28:01.240
反思它给它更多它没有

00:27:56.800 --> 00:28:02.230
改变B一开始就读的内容

00:28:01.240 --> 00:28:03.460
我必须考虑一下，因为我的

00:28:02.230 --> 00:28:07.870
印象是眼睛受到影响

00:28:03.460 --> 00:28:10.870
导出所有软件包是的

00:28:07.870 --> 00:28:14.140
但这不是在读

00:28:10.870 --> 00:28:15.790
对，我们一个星期的模块只是一个

00:28:14.140 --> 00:28:18.430
出口私人的每一个

00:28:15.790 --> 00:28:20.820
包，所以B仍然需要阅读

00:28:18.430 --> 00:28:20.820
它哪个

00:28:31.139 --> 00:28:34.740
请给我一点

00:29:10.410 --> 00:29:15.070
这是一个介绍

00:29:12.890 --> 00:29:17.750
开始了

00:29:15.070 --> 00:29:19.610
这是我们的两条街

00:29:17.750 --> 00:29:23.900
在印度的轨迹上有一对

00:29:19.610 --> 00:29:27.140
统计模块的存在

00:29:23.900 --> 00:29:29.210
统计得分，已导出一堆

00:29:27.140 --> 00:29:31.400
的AP用于诸如回归和

00:29:29.210 --> 00:29:32.950
聚类等等，然后我们有一个

00:29:31.400 --> 00:29:40.880
 CLI是命令行界面

00:29:32.950 --> 00:29:43.220
需要统计得分等等

00:29:40.880 --> 00:29:44.750
属于Eli的CLS需要统计得分

00:29:43.220 --> 00:29:47.470
换句话说，它实际上会阅读它， 

00:29:44.750 --> 00:29:49.760
因此，它可以访问

00:29:47.470 --> 00:29:52.280
包中的公共类型是

00:29:49.760 --> 00:29:53.540
按统计得分按自行车输出，因此

00:29:52.280 --> 00:29:56.360
这是两条路吗

00:29:53.540 --> 00:29:58.400
现在假设我很抱歉

00:29:56.360 --> 00:29:59.870
统计得分的事情是在

00:29:58.400 --> 00:30:01.820
例如有很多内部

00:29:59.870 --> 00:30:03.470
包以及其中没有类型

00:30:01.820 --> 00:30:06.260
包可供任何人访问

00:30:03.470 --> 00:30:10.580
统计得分以外的地方让我们假设

00:30:06.260 --> 00:30:12.710
统计数据Eli没有读取统计数据分数

00:30:10.580 --> 00:30:16.510
那意味着什么都没有

00:30:12.710 --> 00:30:18.710
刚开始就可以得分

00:30:16.510 --> 00:30:20.480
对不起，只知道什么都没有

00:30:18.710 --> 00:30:22.220
统计数据Eli可以访问，因为它确实

00:30:20.480 --> 00:30:26.060
看不到统计得分，所以我认为

00:30:22.220 --> 00:30:28.550
场景是如果我放上A和B标签

00:30:26.060 --> 00:30:30.200
取代我在这里的东西，我想

00:30:28.550 --> 00:30:34.190
您是说统计得分是一周

00:30:30.200 --> 00:30:36.170
模块统计Eli并不这样阅读

00:30:34.190 --> 00:30:37.400
因此任何静态引用都会

00:30:36.170 --> 00:30:39.620
实际上在运行时失败，因为它

00:30:37.400 --> 00:30:47.659
不读

00:30:39.620 --> 00:30:49.309
现在我想我知道你已经放木了

00:30:47.659 --> 00:30:50.929
在这两个轴上， 

00:30:49.309 --> 00:30:52.690
失败，因为那里没有

00:30:50.929 --> 00:30:54.440
依赖关系在模块中声明

00:30:52.690 --> 00:30:57.020
声明，因此没有

00:30:54.440 --> 00:31:00.669
一次可读性和Mark一样

00:30:57.020 --> 00:31:00.669
说核心反射会很好

00:31:02.750 --> 00:31:05.929
因为没有其他人潜入询问

00:31:04.490 --> 00:31:09.409
我马上要问另一个问题

00:31:05.929 --> 00:31:11.000
我的第二个问题，所以我们有自动

00:31:09.409 --> 00:31:13.100
模块和自动名称

00:31:11.000 --> 00:31:16.760
模块是从文件名派生的

00:31:13.100 --> 00:31:18.799
巴特的标准行家方法

00:31:16.760 --> 00:31:22.429
文件名maven文件名不

00:31:18.799 --> 00:31:23.929
对应于您的名字

00:31:22.429 --> 00:31:27.200
通常希望声明

00:31:23.929 --> 00:31:30.860
模块，即反向域名列表

00:31:27.200 --> 00:31:33.440
所以番石榴通常应该是

00:31:30.860 --> 00:31:34.640
如果您以Condor Google番石榴发布

00:31:33.440 --> 00:31:37.010
实际声明了模块名称

00:31:34.640 --> 00:31:38.960
 joda-time实际上是娘家的名字

00:31:37.010 --> 00:31:41.299
有一个破折号，但你真的想要

00:31:38.960 --> 00:31:43.100
现在似乎都是自大崇拜

00:31:41.299 --> 00:31:46.039
对我来说，如果您是开源的

00:31:43.100 --> 00:31:48.559
发布依赖项的项目

00:31:46.039 --> 00:31:51.200
派生自的自动模块

00:31:48.559 --> 00:31:53.600
罐子的简称

00:31:51.200 --> 00:31:57.110
该模块实际存在时的文件

00:31:53.600 --> 00:31:58.580
将来由其所有者发布

00:31:57.110 --> 00:32:01.400
开源项目现在将不再

00:31:58.580 --> 00:32:02.330
可以被世界接受

00:32:01.400 --> 00:32:04.280
对我来说，这将是一个非常糟糕的主意

00:32:02.330 --> 00:32:09.220
让任何开源项目发布一个

00:32:04.280 --> 00:32:13.940
基于自动凡人之眼的项目

00:32:09.220 --> 00:32:17.690
所以这里有几件事

00:32:13.940 --> 00:32:22.280
对此发表评论可以使这一点

00:32:17.690 --> 00:32:24.860
周围说好吧，如果，如果因为

00:32:22.280 --> 00:32:27.710
番石榴今天是番石榴-你知道版本

00:32:24.860 --> 00:32:31.820
数字罐作为自动模块

00:32:27.710 --> 00:32:33.260
名字可能就是番石榴

00:32:31.820 --> 00:32:35.870
或者说， 

00:32:33.260 --> 00:32:39.200
番石榴，如果他们把它变成一个

00:32:35.870 --> 00:32:40.400
适当的显式模块（如果他们愿意） 

00:32:39.200 --> 00:32:45.460
关于他们的用户，他们应该打电话给

00:32:40.400 --> 00:32:47.299
模块番石榴而不是kombu GLE点

00:32:45.460 --> 00:32:49.700
无论使用哪种方式收集

00:32:47.299 --> 00:32:52.130
因为它要求任何人到达那里

00:32:49.700 --> 00:32:53.990
首先赢得并能够做好

00:32:52.130 --> 00:32:56.150
他们有效地

00:32:53.990 --> 00:32:58.940
实际上，他们已经都是

00:32:56.150 --> 00:33:01.909
他们的第一个，因为你知道番石榴- 

00:32:58.940 --> 00:33:05.870
版本无论罐子是什么

00:33:01.909 --> 00:33:06.919
走上上课的路，是的，但是我的意思是

00:33:05.870 --> 00:33:07.420
模块名称是您应该使用的名称

00:33:06.919 --> 00:33:10.600
挑剔

00:33:07.420 --> 00:33:12.190
取决于那是的，我的名字是

00:33:10.600 --> 00:33:13.330
我是说II认为规格是

00:33:12.190 --> 00:33:15.730
定义电动机名称旨在

00:33:13.330 --> 00:33:17.170
与比目鱼呆在一起所以所以我们所以我们

00:33:15.730 --> 00:33:20.200
我们可以，我们可以

00:33:17.170 --> 00:33:21.340
出自动模块，我想会

00:33:20.200 --> 00:33:23.470
很好，那将不得不

00:33:21.340 --> 00:33:25.030
关于建议的东西

00:33:23.470 --> 00:33:26.110
对于模块名称，模块名称实际上是

00:33:25.030 --> 00:33:27.730
重要的是，他们将成为

00:33:26.110 --> 00:33:32.050
您需要什么和做什么

00:33:27.730 --> 00:33:33.400
你所依赖的我认为我们

00:33:32.050 --> 00:33:38.290
放在桌子这一侧的位置

00:33:33.400 --> 00:33:40.270
请勿使用Google bla bla bla bla 

00:33:38.290 --> 00:33:42.040
作为模块的名称，我们将

00:33:40.270 --> 00:33:43.900
真的叫那个番石榴，所以实际上

00:33:42.040 --> 00:33:46.180
更接近工件名称而不是

00:33:43.900 --> 00:33:48.190
包名称是的，这有

00:33:46.180 --> 00:33:52.000
实际上是我们在逐步转变

00:33:48.190 --> 00:33:53.470
如果你看的话，我们自己的看法

00:33:52.000 --> 00:33:54.640
例如当前的状态

00:33:53.470 --> 00:33:58.210
模块系统要几个月了

00:33:54.640 --> 00:34:00.220
建议使用反向DNS作为日期

00:33:58.210 --> 00:34:02.100
随着时间的流逝，时间的流逝

00:34:00.220 --> 00:34:04.450
更多的经验，我们已经意识到您知道

00:34:02.100 --> 00:34:06.190
你知道一件事就是

00:34:04.450 --> 00:34:09.580
还有这整个问题

00:34:06.190 --> 00:34:11.440
您和其他人提出了如何

00:34:09.580 --> 00:34:15.250
您是否将模块名称与

00:34:11.440 --> 00:34:18.730
包名称在模块中声明

00:34:15.250 --> 00:34:20.350
它可以看起来有点好吗

00:34:18.730 --> 00:34:22.480
混淆阅读模块

00:34:20.350 --> 00:34:25.270
声明，然后查看模块名称为

00:34:22.480 --> 00:34:27.010
冷静的狗粮吧，然后出口

00:34:25.270 --> 00:34:28.929
包叫镇定狗粮吧

00:34:27.010 --> 00:34:30.490
现在没有视觉上的区别

00:34:28.929 --> 00:34:31.630
所有语法自行车都很好

00:34:30.490 --> 00:34:33.400
我们可以有一个完全不同的

00:34:31.630 --> 00:34:35.260
模块名称的语法，我们已经

00:34:33.400 --> 00:34:37.900
我们把那辆自行车漆成一堆

00:34:35.260 --> 00:34:41.919
不同的颜色，没有什么比这更好的了

00:34:37.900 --> 00:34:43.360
点已经出现，所以如果你

00:34:41.919 --> 00:34:45.520
如果接受，那就接受

00:34:43.360 --> 00:34:48.460
将是点然后是帽子而不是使用

00:34:45.520 --> 00:34:50.620
模块名称的反向dns变为

00:34:48.460 --> 00:34:52.090
更具吸引力，因为这样您就可以

00:34:50.620 --> 00:34:53.980
只是说好模块名称是

00:34:52.090 --> 00:34:55.900
 foo，因为毕竟这是

00:34:53.980 --> 00:34:58.810
清盘，你知道食物-1 2 3罐

00:34:55.900 --> 00:35:01.660
和包的包名称仍然

00:34:58.810 --> 00:35:04.480
您使用反向DNS或类似的域名

00:35:01.660 --> 00:35:09.970
约定，如果没有其他要最小化的地方

00:35:04.480 --> 00:35:12.160
类加载器发生冲突，所以II表示我

00:35:09.970 --> 00:35:14.790
我了解使用反向的吸引力

00:35:12.160 --> 00:35:16.440
 DNS作为模块名称

00:35:14.790 --> 00:35:18.840
我不得不说这对我没有吸引力

00:35:16.440 --> 00:35:21.210
通常你不会这样

00:35:18.840 --> 00:35:23.100
当然可以免费使用反向DNS模型

00:35:21.210 --> 00:35:24.690
为更多公司命名的模型

00:35:23.100 --> 00:35:27.240
有内部项目将有一个

00:35:24.690 --> 00:35:29.160
名字和那个名字突然这些未来

00:35:27.240 --> 00:35:30.810
与一些大型开源项目发生冲突

00:35:29.160 --> 00:35:33.360
因为很明显，团队没有

00:35:30.810 --> 00:35:34.470
两者之间的联系是的

00:35:33.360 --> 00:35:36.330
时间表问题和类似的项目

00:35:34.470 --> 00:35:38.490
 joda-time的名称- 

00:35:36.330 --> 00:35:40.500
专家显然会-无法拥有

00:35:38.490 --> 00:35:42.120
 -以它的名义很好

00:35:40.500 --> 00:35:44.060
自动模块命名我们的算法

00:35:42.120 --> 00:35:46.320
将-轻松转换为攻击

00:35:44.060 --> 00:35:48.120
至少肯定是你

00:35:46.320 --> 00:35:51.000
说他需要写一个模块

00:35:48.120 --> 00:35:53.880
命名有关您的内容的文档

00:35:51.000 --> 00:35:55.740
名字是策略，我很惊讶

00:35:53.880 --> 00:35:59.790
您正在考虑不反向域名

00:35:55.740 --> 00:36:01.530
我留下你的名字我很惊讶

00:35:59.790 --> 00:36:03.120
说得很好，也许是说实话

00:36:01.530 --> 00:36:04.680
我们对此有点紧张- 

00:36:03.120 --> 00:36:05.940
因为我打算建议，但也许

00:36:04.680 --> 00:36:08.190
命名补贴应该看一下

00:36:05.940 --> 00:36:09.570
路由包位于jar文件中，因此

00:36:08.190 --> 00:36:11.430
确定人们如何能够

00:36:09.570 --> 00:36:13.650
自动解释，你

00:36:11.430 --> 00:36:16.590
使用混淆路由包作为

00:36:13.650 --> 00:36:19.080
是的，名字的美

00:36:16.590 --> 00:36:21.600
当前的惯例是它可以自动

00:36:19.080 --> 00:36:24.480
模块非常容易推理和

00:36:21.600 --> 00:36:25.950
自动模块非常重要

00:36:24.480 --> 00:36:28.620
受益于整个移民故事

00:36:25.950 --> 00:36:30.660
对，如果我们没有自动的话

00:36:28.620 --> 00:36:35.100
模块，那么我们将迫使所有人

00:36:30.660 --> 00:36:36.840
进行自下而上的迁移，它将和

00:36:35.100 --> 00:36:39.300
要花20年才能被采纳

00:36:36.840 --> 00:36:44.640
或具有“地图”模块的文本文件

00:36:39.300 --> 00:36:46.110
 Java的名称确保您可以解决

00:36:44.640 --> 00:36:48.320
另一个层次的任何问题

00:36:46.110 --> 00:36:48.320
间接的

00:36:48.410 --> 00:36:52.640
反正问题还好谢谢

00:37:02.630 --> 00:37:14.170
我有一个使用

00:37:05.480 --> 00:37:17.180
工具不错，对不起杰夫220 

00:37:14.170 --> 00:37:20.720
是的，所以两个工具罐都消失了

00:37:17.180 --> 00:37:24.080
实际上已经消失了很长时间

00:37:20.720 --> 00:37:26.420
如果您需要使用编译器

00:37:24.080 --> 00:37:30.170
那你应该使用编译器

00:37:26.420 --> 00:37:32.720
实际上已经存在的API 

00:37:30.170 --> 00:37:33.860
此时，我们发布了多个版本

00:37:32.720 --> 00:37:47.630
用两个就是你在用

00:37:33.860 --> 00:37:49.850
关于董事会的工具哦，你就是

00:37:47.630 --> 00:37:53.320
你在外面，你在用

00:37:49.850 --> 00:37:53.320
关于jar的工具中的内部API 

00:37:56.840 --> 00:38:03.020
好的工具已经不存在

00:37:59.660 --> 00:38:05.720
类几乎存在于某个地方

00:38:03.020 --> 00:38:09.740
当然要封装，如果你想去

00:38:05.720 --> 00:38:11.810
你知道打法你知道打法

00:38:09.740 --> 00:38:14.390
封装并做反射魔术

00:38:11.810 --> 00:38:17.500
您可以仍然可以使用它，但这是一个

00:38:14.390 --> 00:38:17.500
完全不受支持的API 

00:38:22.020 --> 00:38:29.070
您实际使用的是哪个API 

00:38:25.619 --> 00:38:32.610
王朝MXB也没有

00:38:29.070 --> 00:38:35.520
不同的API转储威胁

00:38:32.610 --> 00:38:39.930
您可能不想要的gdk9最新版本

00:38:35.520 --> 00:38:41.910
要使用的是踏步机，它是

00:38:39.930 --> 00:38:44.850
新的API可让您遍历整个

00:38:41.910 --> 00:38:48.240
统计并过滤掉它刚刚返回

00:38:44.850 --> 00:38:51.690
您的步框流，因此您可以

00:38:48.240 --> 00:38:53.480
灵活地过滤任何东西，您允许

00:38:51.690 --> 00:38:56.970
您也可以访问类对象

00:38:53.480 --> 00:39:00.360
所以这是最新的

00:38:56.970 --> 00:39:04.560
想要在其中堆叠跟踪字符串

00:39:00.360 --> 00:39:07.830
线程获取该跟踪线程获取该跟踪

00:39:04.560 --> 00:39:20.100
自从JDK 5以来，它就一直存在

00:39:07.830 --> 00:39:24.330
相信Locke是是很好不抱歉

00:39:20.100 --> 00:39:26.130
如果您依赖的话，它是洛克信息

00:39:24.330 --> 00:39:28.080
您要寻找的是标枪

00:39:26.130 --> 00:39:30.869
管理是公共API 

00:39:28.080 --> 00:39:33.060
您不需要使用开始但

00:39:30.869 --> 00:39:36.540
我不是基于Java 

00:39:33.060 --> 00:39:39.600
意思是在Java点管理模块中

00:39:36.540 --> 00:39:40.260
但这是Java SE的公共支持API 

00:39:39.600 --> 00:39:44.130
 API 

00:39:40.260 --> 00:39:47.970
再看Java Lane管理威胁MX 

00:39:44.130 --> 00:39:51.630
是否有锁信息返回给

00:39:47.970 --> 00:39:54.660
您可以检查谁是

00:39:51.630 --> 00:39:59.310
谁锁谁拥有谁的锁

00:39:54.660 --> 00:40:02.940
是的，自JDK 5 + j起就一直在那里

00:39:59.310 --> 00:40:07.710
 TK 6增强了对Java的支持

00:40:02.940 --> 00:40:15.660
征服堆栈Walker API的锁

00:40:07.710 --> 00:40:18.570
曼迪说这是真的

00:40:15.660 --> 00:40:21.030
很好，但要指出的是

00:40:18.570 --> 00:40:22.530
那个班还是那个实习班

00:40:21.030 --> 00:40:24.480
昨天还在那里是的

00:40:22.530 --> 00:40:26.940
你实际上并没有用工具

00:40:24.480 --> 00:40:29.400
没了，但是那堂课实际上还是

00:40:26.940 --> 00:40:31.020
该类型实际上仍然可见

00:40:29.400 --> 00:40:32.310
不知道您是如何访问它的

00:40:31.020 --> 00:40:34.079
名称类，或者您有一个静态名称

00:40:32.310 --> 00:40:35.790
参考，但您将获得非法

00:40:34.079 --> 00:40:40.200
访问错误合法访问异常，如果

00:40:35.790 --> 00:40:42.420
你用它是参议员你内部

00:40:40.200 --> 00:40:44.609
您正在使用的API，因此我会在

00:40:42.420 --> 00:40:52.619
 Jade应用程式Wiki，并告诉您

00:40:44.609 --> 00:40:54.960
替换是的，我对这个应用程序有疑问

00:40:52.619 --> 00:40:55.740
它在JDK 9下不起作用，我只是

00:40:54.960 --> 00:40:58.319
弄清楚为什么

00:40:55.740 --> 00:41:01.440
因此它在安全管理器下运行

00:40:58.319 --> 00:41:05.040
因为它是由学生和你经营的

00:41:01.440 --> 00:41:06.810
不信任你的学生，不，我不知道

00:41:05.040 --> 00:41:08.190
是的，每隔一段时间我会得到一个

00:41:06.810 --> 00:41:12.420
向其他设法举报的人举报

00:41:08.190 --> 00:41:15.720
破解一些东西，然后编译

00:41:12.420 --> 00:41:18.300
 Java代码及其正确完成方式

00:41:15.720 --> 00:41:21.660
现在是工具罐被赋予了所有

00:41:18.300 --> 00:41:23.280
现在在策略文件中具有权限

00:41:21.660 --> 00:41:27.119
工具触摸永远不会消失谁

00:41:23.280 --> 00:41:33.089
我授予所有权限JDK编译器

00:41:27.119 --> 00:41:34.440
有这样一个衰落的年龄， 

00:41:33.089 --> 00:41:35.880
我的猜测是年纪大了

00:41:34.440 --> 00:41:38.250
当然，你会给一个

00:41:35.880 --> 00:41:41.160
代码库，即到的文件路径

00:41:38.250 --> 00:41:43.710
用JDK 9和

00:41:41.160 --> 00:41:45.990
模块是您授予的权限

00:41:43.710 --> 00:41:47.760
杰伊·阿蒂（Jay arty）： 

00:41:45.990 --> 00:41:49.740
斜杠，然后是模块名

00:41:47.760 --> 00:41:52.220
情况可能是JDK编译器

00:41:49.740 --> 00:41:52.220
模块名称

00:41:56.300 --> 00:41:59.730
真的很好，真的

00:41:58.589 --> 00:42:01.710
真的很好，因为您可以按

00:41:59.730 --> 00:42:03.960
模块基础的所有详细信息是

00:42:01.710 --> 00:42:06.839
写在第20章好吧，如果你

00:42:03.960 --> 00:42:10.410
看看JDK 9下载看看

00:42:06.839 --> 00:42:12.960
 comp安全策略文件已移至

00:42:10.410 --> 00:42:14.819
配置目录看看

00:42:12.960 --> 00:42:17.040
现有文件，您将看到他们的

00:42:14.819 --> 00:42:20.520
例子，因为我们授予

00:42:17.040 --> 00:42:23.359
细粒度的JDK模块数量

00:42:20.520 --> 00:42:23.359
已有权限

00:42:26.000 --> 00:42:34.140
只有一个人正好在那儿

00:42:32.760 --> 00:42:35.549
是指标案例的例子

00:42:34.140 --> 00:42:37.440
授予默认策略

00:42:35.549 --> 00:42:39.660
特定模块的权限是的

00:42:37.440 --> 00:42:41.900
好的语法真的很容易

00:42:39.660 --> 00:42:41.900
工作

00:42:57.130 --> 00:43:05.980
现在Twitter问题我们还为时过早

00:43:03.850 --> 00:43:08.190
去年很多就是这个

00:43:05.980 --> 00:43:08.190
时间

00:43:12.959 --> 00:43:16.499
大家在那里醒来

00:43:25.880 --> 00:43:30.709
如果您的Web应用程序更接近

00:43:29.420 --> 00:43:33.890
麦克风，如果您有网络请

00:43:30.709 --> 00:43:35.420
应用程序将如何自动

00:43:33.890 --> 00:43:40.160
模块工作，是否有标准

00:43:35.420 --> 00:43:44.440
关于我如何认为这是一个问题

00:43:40.160 --> 00:43:44.440
可能是针对Java EE 9专家组的

00:43:44.650 --> 00:43:49.430
这样我们才能真正开始迁移

00:43:47.239 --> 00:43:54.380
当服务器9出现时，我们可以构建

00:43:49.430 --> 00:43:56.029
模块仍然是正确的，所以这样，所以

00:43:54.380 --> 00:43:58.640
希望希望和期望是

00:43:56.029 --> 00:44:02.660
 Java EE 9将利用此模块

00:43:58.640 --> 00:44:05.390
系统到底是怎么做的，不是为了

00:44:02.660 --> 00:44:07.430
我们任何一个人在这里都在说

00:44:05.390 --> 00:44:10.369
显然，您知道我们一直在努力

00:44:07.430 --> 00:44:16.069
与许多您认识的专家

00:44:10.369 --> 00:44:17.949
和规格导致获得反馈，但我你

00:44:16.069 --> 00:44:21.769
知道我不知道什么是模块化

00:44:17.949 --> 00:44:24.049
一年，就像你知道的

00:44:21.769 --> 00:44:26.329
当然，您知道如果需要的话我会的

00:44:24.049 --> 00:44:28.699
猜想我希望在模块化工作中

00:44:26.329 --> 00:44:30.739
模块化年份看起来很像

00:44:28.699 --> 00:44:35.269
今天除了罐子文件

00:44:30.739 --> 00:44:38.239
将是模块化的罐子和e op 

00:44:35.269 --> 00:44:40.940
加载它们的服务器机器会

00:44:38.239 --> 00:44:42.559
将使用模数作为系统

00:44:40.940 --> 00:44:45.289
解析器构建模块图和

00:44:42.559 --> 00:44:47.299
层，并完成所有工作，所以您

00:44:45.289 --> 00:44:51.199
知道简单容易的答案很确定

00:44:47.299 --> 00:44:54.170
继续制作模块，但要

00:44:51.199 --> 00:44:56.779
当这些被加载时

00:44:54.170 --> 00:44:59.539
放入EE容器或servlet 

00:44:56.779 --> 00:45:00.769
容器，他们只是要放在

00:44:59.539 --> 00:45:02.089
像他们认为的那样上课的路

00:45:00.769 --> 00:45:04.190
一直以来，但如果您使用相同的

00:45:02.089 --> 00:45:07.400
在其他情况下的模块，那么他们可以

00:45:04.190 --> 00:45:10.059
实际上用作模块有意义

00:45:07.400 --> 00:45:10.059
是的

00:45:22.750 --> 00:45:29.460
如果在我的应用程序中我很小

00:45:27.040 --> 00:45:33.099
容器，这将创建两层

00:45:29.460 --> 00:45:35.070
两者都加载了很多不同的东西

00:45:33.099 --> 00:45:37.750
分类器让我们做一些Java文件

00:45:35.070 --> 00:45:38.980
大概是这两层

00:45:37.750 --> 00:45:41.290
分类器是完全独立的

00:45:38.980 --> 00:45:45.510
彼此之间没有共享

00:45:41.290 --> 00:45:51.340
他们之间没有任何关系

00:45:45.510 --> 00:45:55.210
他们之间直接共享

00:45:51.340 --> 00:45:59.349
由模块系统启用但

00:45:55.210 --> 00:46:06.310
记住总是有反思，所以在

00:45:59.349 --> 00:46:07.619
在运行时代码是，不，不，不是

00:46:06.310 --> 00:46:12.220
确实所有赌注都没有

00:46:07.619 --> 00:46:14.740
但是在运行时， 

00:46:12.220 --> 00:46:17.440
第一层可以添加添加运行时

00:46:14.740 --> 00:46:19.210
从该模块读取边缘到模块

00:46:17.440 --> 00:46:22.630
在另一层，如果该模块

00:46:19.210 --> 00:46:25.990
出口的东西，那么第一个模块将

00:46:22.630 --> 00:46:30.369
能够访问它，我什至会

00:46:25.990 --> 00:46:33.369
了解其他偏差是否泄漏

00:46:30.369 --> 00:46:36.010
通过API或您可以

00:46:33.369 --> 00:46:37.750
您可以通过某种方式变老

00:46:36.010 --> 00:46:40.150
层的保持力是

00:46:37.750 --> 00:46:41.410
当然，您知道这是可能的，我

00:46:40.150 --> 00:46:42.369
猜猜我在努力锻炼，所以

00:46:41.410 --> 00:46:45.369
什么是隔离度

00:46:42.369 --> 00:46:46.720
在这两层之间，因为

00:46:45.369 --> 00:46:49.150
显然有隔离是

00:46:46.720 --> 00:46:50.560
优点在于您无法将其他排序

00:46:49.150 --> 00:46:52.180
我把它弄乱了，但还有我

00:46:50.560 --> 00:46:54.010
想象这很糟糕，因为你最终会

00:46:52.180 --> 00:46:56.619
音频日树和静态的两个副本

00:46:54.010 --> 00:46:58.859
排序正确，所以隔离是

00:46:56.619 --> 00:47:00.790
与封装权不同

00:46:58.859 --> 00:47:04.000
我们正在努力提供强大的

00:47:00.790 --> 00:47:05.619
那就是那的封装

00:47:04.000 --> 00:47:07.300
相当困难，尽管不是

00:47:05.619 --> 00:47:10.150
不可能打破，我们不是要

00:47:07.300 --> 00:47:13.570
提供隔离我认为它说一些

00:47:10.150 --> 00:47:17.050
你们知道某种硬边界

00:47:13.570 --> 00:47:18.670
那是他之间不可穿透的

00:47:17.050 --> 00:47:20.380
如果需要的话，可以分为不同的层

00:47:18.670 --> 00:47:23.430
硬边界比操作系统

00:47:20.380 --> 00:47:23.430
流程或您的朋友

00:47:35.890 --> 00:47:40.780
在非常繁重的配置上工作

00:47:37.930 --> 00:47:42.940
驱动的项目，其中很多代码

00:47:40.780 --> 00:47:45.040
不知道其他资源

00:47:42.940 --> 00:47:46.780
它需要加载，所以我们有

00:47:45.040 --> 00:47:48.670
许多已加载的配置文件

00:47:46.780 --> 00:47:51.520
根据他们在课程路径上的位置

00:47:48.670 --> 00:47:54.790
放在很多的罐子里

00:47:51.520 --> 00:47:55.180
高于需要看的课程

00:47:54.790 --> 00:47:58.710
他们

00:47:55.180 --> 00:48:00.970
对不起，更高的尺寸

00:47:58.710 --> 00:48:03.070
如果我们要画一个图

00:48:00.970 --> 00:48:05.680
配置级别的jar取决于

00:48:03.070 --> 00:48:07.180
代码级的罐子可以，但是它们都缠绕

00:48:05.680 --> 00:48:10.150
依靠他们做的线性类能力

00:48:07.180 --> 00:48:12.550
好的，我们的代码在下面

00:48:10.150 --> 00:48:14.020
级别的模块能够看到

00:48:12.550 --> 00:48:16.030
较高级别的资源

00:48:14.020 --> 00:48:22.990
模块，因此仅配置模块

00:48:16.030 --> 00:48:24.910
包含资源文件是的，要付钱

00:48:22.990 --> 00:48:31.810
取决于它如何取决于事物

00:48:24.910 --> 00:48:36.940
被命名为

00:48:31.810 --> 00:48:39.130
系统资源已封装但

00:48:36.940 --> 00:48:42.100
仅当它们是有效的包装名称时

00:48:39.130 --> 00:48:43.990
实际上是合法的Java 

00:48:42.100 --> 00:48:45.250
包裹名称，如果你放

00:48:43.990 --> 00:48:50.040
您是配置的一部分

00:48:45.250 --> 00:48:53.020
您知道的文件meta-您知道的信息

00:48:50.040 --> 00:48:54.940
如此长的字符串

00:48:53.020 --> 00:48:57.430
转换为Java包名称

00:48:54.940 --> 00:48:59.530
那么它将始终被导出，如果

00:48:57.430 --> 00:49:02.230
你在同一个类中有代码

00:48:59.530 --> 00:49:03.520
加载器组织或可能在其中的代码

00:49:02.230 --> 00:49:05.560
读取该模块的模块

00:49:03.520 --> 00:49:07.920
您将能够加载资源

00:49:05.560 --> 00:49:07.920
问题

00:49:17.300 --> 00:49:21.530
你能再解释一次吗

00:49:18.890 --> 00:49:23.720
 JDK九个常规之间的区别

00:49:21.530 --> 00:49:26.960
抢先体验版和

00:49:23.720 --> 00:49:30.260
拼图的人正在流血

00:49:26.960 --> 00:49:32.780
边缘那么JDK 9的方式如何

00:49:30.260 --> 00:49:35.330
一种是出血边缘稍少

00:49:32.780 --> 00:49:40.570
你知道什么时候在流血

00:49:35.330 --> 00:49:44.270
伤害了我可能期望的区别

00:49:40.570 --> 00:49:48.530
好吧，随着时间的流逝，他们会改变

00:49:44.270 --> 00:49:49.940
我们随着我们发展模型

00:49:48.530 --> 00:49:51.890
将周围的所有东西都放入

00:49:49.940 --> 00:49:55.040
对反馈的回应和进一步

00:49:51.890 --> 00:50:00.020
认为我们在

00:49:55.040 --> 00:50:04.750
在开放式JDK中进行拼图森林操作

00:50:00.020 --> 00:50:07.490
与较少严格的代码审查和

00:50:04.750 --> 00:50:08.690
减少质量检查，以便您知道

00:50:07.490 --> 00:50:09.650
当然可以进行一些测试，但是

00:50:08.690 --> 00:50:12.620
基本上，您在

00:50:09.650 --> 00:50:15.320
拼图EI是我们不断的融合

00:50:12.620 --> 00:50:21.310
最新拼图的构建

00:50:15.320 --> 00:50:23.450
您在JDK 9 EA中看到的更多

00:50:21.310 --> 00:50:25.580
精心开发的代码库

00:50:23.450 --> 00:50:27.590
一切都有代码审查那里

00:50:25.580 --> 00:50:29.540
对此进行了更多测试

00:50:27.590 --> 00:50:32.180
当然还不完整，但是你更多

00:50:29.540 --> 00:50:35.170
超过您在拼图上能找到的

00:50:32.180 --> 00:50:37.760
可能是您知道有时可能

00:50:35.170 --> 00:50:40.090
拼图中有很多东西

00:50:37.760 --> 00:50:42.530
 EA，现在就是这种情况

00:50:40.090 --> 00:50:44.060
通常他们是同步的，并且有一个

00:50:42.530 --> 00:50:46.370
我们在九点的几次

00:50:44.060 --> 00:50:48.020
停止发布拼图EA 

00:50:46.370 --> 00:50:49.400
因为我们一直在做所有的工作

00:50:48.020 --> 00:50:53.890
在JDK 9中，我们可能会

00:50:49.400 --> 00:50:53.890
今年秋天的另一个阶段

00:50:55.060 --> 00:51:00.590
他们之间的区别是Corbett 

00:50:57.560 --> 00:51:05.840
这是完全破账单的人都没有

00:51:00.590 --> 00:51:07.910
注意到我们当然会修复它

00:51:05.840 --> 00:51:09.980
它进入JDK 9，但与

00:51:07.910 --> 00:51:11.480
马克说这是什么建议

00:51:09.980 --> 00:51:13.010
该标记被放在那里，我们试图

00:51:11.480 --> 00:51:14.900
与实施保持同步

00:51:13.010 --> 00:51:17.060
这么多的变化

00:51:14.900 --> 00:51:20.510
 jukes EA称赞我们的原型质量

00:51:17.060 --> 00:51:23.180
并优化我们调整模型的内容

00:51:20.510 --> 00:51:26.020
示例不在JDK 9 EA中，但它们

00:51:23.180 --> 00:51:26.020
在拼图中

00:51:36.740 --> 00:52:05.540
不要害羞，没人问

00:51:38.960 --> 00:52:11.720
提出正确的问题，所以这是一个要求

00:52:05.540 --> 00:52:13.339
尚未实现，但我们意识到

00:52:11.720 --> 00:52:16.940
那里需要有能力

00:52:13.339 --> 00:52:19.069
扫描模块中的类

00:52:16.940 --> 00:52:20.540
有某些注释，等等

00:52:19.069 --> 00:52:21.829
知道如何做

00:52:20.540 --> 00:52:24.410
我们只是没有特别困难

00:52:21.829 --> 00:52:28.490
尚未完成，但基本上

00:52:24.410 --> 00:52:30.829
你知道想像一种自省的方法

00:52:28.490 --> 00:52:32.210
在一个模块上，问你知道什么

00:52:30.829 --> 00:52:35.109
存在哪些注释以及什么

00:52:32.210 --> 00:52:37.940
哪个班有他们，然后你

00:52:35.109 --> 00:52:41.270
是的，甚至没有出口

00:52:37.940 --> 00:52:43.010
因为我们知道很多CDI 

00:52:41.270 --> 00:52:45.170
框架在注释上运行

00:52:43.010 --> 00:52:48.619
在你知道完全私人的

00:52:45.170 --> 00:52:50.530
元素，所以也必须工作， 

00:52:48.619 --> 00:52:52.970
这主要是性能的东西

00:52:50.530 --> 00:52:54.920
您正在扫描的任何有效工具

00:52:52.970 --> 00:52:58.750
今天的上课地点

00:52:54.920 --> 00:52:58.750
一切都会像以前一样工作

00:53:05.230 --> 00:53:13.120
罗伯特让我们努力一点，所以这

00:53:10.840 --> 00:53:15.610
可能是关于Java的问题

00:53:13.120 --> 00:53:18.790
所以假设我们都相信

00:53:15.610 --> 00:53:21.010
多路径是我们要走的路

00:53:18.790 --> 00:53:23.260
摆脱类路径，因为

00:53:21.010 --> 00:53:27.520
现在我们在编译期间

00:53:23.260 --> 00:53:30.100
阶段，我们可以在

00:53:27.520 --> 00:53:32.110
编译我们现在都必须使用

00:53:30.100 --> 00:53:35.170
类路径和模块路径，因为

00:53:32.110 --> 00:53:39.370
包冲突，您无法添加

00:53:35.170 --> 00:53:44.100
源主测试中的模块信息

00:53:39.370 --> 00:53:46.300
目录，然后我们有第三个

00:53:44.100 --> 00:53:48.520
点，我们需要一个多部分

00:53:46.300 --> 00:53:50.980
这是在J单元运行期间

00:53:48.520 --> 00:53:54.460
测试，然后我们现在我必须

00:53:50.980 --> 00:53:57.640
拿来，那又是当我们有

00:53:54.460 --> 00:54:01.150
使用类路径在某处

00:53:57.640 --> 00:54:02.770
将来可能会摆脱

00:54:01.150 --> 00:54:05.050
上课的路径，否则会在那里

00:54:02.770 --> 00:54:11.050
永远成为我们的课堂之路

00:54:05.050 --> 00:54:13.690
直到宇宙的热死我我

00:54:11.050 --> 00:54:15.970
只是不，我从没看到过

00:54:13.690 --> 00:54:17.770
走了，我想在那里

00:54:15.970 --> 00:54:20.590
成为使用的一天

00:54:17.770 --> 00:54:23.500
你很少或仅在某些情况下知道

00:54:20.590 --> 00:54:26.230
像这样你有充分的理由

00:54:23.500 --> 00:54:27.550
为此，标准做法是

00:54:26.230 --> 00:54:33.070
运送模型并将其放在模型上

00:54:27.550 --> 00:54:36.240
路径，但是，我不认为这堂课

00:54:33.070 --> 00:54:36.240
道路将永远消失

00:54:37.530 --> 00:54:45.210
我确实希望我希望未来

00:54:41.990 --> 00:54:50.400
平台从错误中吸取教训

00:54:45.210 --> 00:54:52.850
类路径，不要重复，但是你

00:54:50.400 --> 00:54:52.850
知道我们在这里

00:55:03.650 --> 00:55:09.230
没有人在问，我正在努力

00:55:05.720 --> 00:55:11.360
在这里调试我的东西，请例外

00:55:09.230 --> 00:55:12.920
在工具下一些通讯点中的某处

00:55:11.360 --> 00:55:15.320
我从未听说过的课程

00:55:12.920 --> 00:55:17.080
找出应该使用哪个模块引擎

00:55:15.320 --> 00:55:20.300
在堆栈跟踪中

00:55:17.080 --> 00:55:24.610
所以我们增强了堆栈跟踪

00:55:20.300 --> 00:55:26.870
包括模块名称以及if 

00:55:24.610 --> 00:55:28.460
甚至适合班级名称

00:55:26.870 --> 00:55:31.400
装载机您知道类装载机可以

00:55:28.460 --> 00:55:33.200
现在有名字，我想这是一个

00:55:31.400 --> 00:55:34.820
安全管理器访问控制

00:55:33.200 --> 00:55:43.340
没有模块的异常

00:55:34.820 --> 00:55:45.440
在其中命名，还好吧，所以我们在

00:55:43.340 --> 00:55:47.090
改善她的条件和例外

00:55:45.440 --> 00:55:50.390
猜想我们可以专注于更多的事情，例如

00:55:47.090 --> 00:55:52.700
非法访问xxx类演员表

00:55:50.390 --> 00:55:57.140
例外另一种，但我们应该

00:55:52.700 --> 00:56:27.650
解决这个问题，我们应该解决这个问题，但是

00:55:57.140 --> 00:56:29.690
如果您愿意，那么Java Java编译器实际上是

00:56:27.650 --> 00:56:32.690
一个标准模块，它导出

00:56:29.690 --> 00:56:34.070
标准的Java X工具和Lulu，但是

00:56:32.690 --> 00:56:38.510
不包含编译器

00:56:34.070 --> 00:56:40.130
令人困惑，但是哦，效果很好

00:56:38.510 --> 00:56:41.780
我们可以修复的其他许多错误

00:56:40.130 --> 00:56:44.660
命名此会话标记时效果很好

00:56:41.780 --> 00:56:54.710
 hack session是的，好的，我们做了一些

00:56:44.660 --> 00:56:56.480
黑客出色，可以肯定

00:56:54.710 --> 00:57:00.740
很多人有一个拼图

00:56:56.480 --> 00:57:02.630
建立在他们的笔记本电脑上，好关闭

00:57:00.740 --> 00:57:06.490
其余的你可以去融化为什么

00:57:02.630 --> 00:57:06.490
好吧，现在就得到

00:57:07.150 --> 00:57:14.210
是的，今年的Wi-Fi不错

00:57:10.310 --> 00:57:15.410
是的，早上好，我是

00:57:14.210 --> 00:57:17.360
很好奇实际上有多少人

00:57:15.410 --> 00:57:21.950
实际尝试过J联赛做一些

00:57:17.360 --> 00:57:28.150
监狱中的运行时监狱招致一个人

00:57:21.950 --> 00:57:28.150
好吧，他们工作，他们工作得很好

00:57:36.680 --> 00:57:42.330
是否会有任何类型的JVM选项

00:57:40.020 --> 00:57:44.760
那将允许您在

00:57:42.330 --> 00:57:47.160
触点内部的反射和

00:57:44.760 --> 00:57:49.230
有一些包裹在那里

00:57:47.160 --> 00:57:50.670
已经没事了，所以有

00:57:49.230 --> 00:57:54.510
您可以阅读的命令行选项

00:57:50.670 --> 00:57:59.130
他们在JEP 261中允许您突破

00:57:54.510 --> 00:58:00.660
封装好运，谢谢依靠

00:57:59.130 --> 00:58:02.160
在内部API上并报告错误

00:58:00.660 --> 00:58:05.310
反对它将被关闭不会

00:58:02.160 --> 00:58:07.050
修复里面还有一些例子

00:58:05.310 --> 00:58:12.120
为我们所做的JDK 9演讲做准备

00:58:07.050 --> 00:58:14.010
星期一，还可以

00:58:12.120 --> 00:58:16.560
然后关于

00:58:14.010 --> 00:58:18.420
专门在笔记本电脑上

00:58:16.560 --> 00:58:20.880
可能让你交流

00:58:18.420 --> 00:58:25.770
与Symantec并让他们执行

00:58:20.880 --> 00:58:27.450
从他们的防病毒声誉

00:58:25.770 --> 00:58:29.220
我尝试过的东西

00:58:27.450 --> 00:58:30.660
安装它，它消失了

00:58:29.220 --> 00:58:35.060
而且结束，所以我不能在我的身上使用它

00:58:30.660 --> 00:58:37.920
公司笔记本电脑um III具有Linux 

00:58:35.060 --> 00:58:38.690
如果要在闪存驱动器上保存图像

00:58:37.920 --> 00:58:46.680
借它

00:58:38.690 --> 00:58:48.720
抱歉，爸爸，我什至不知道我们是否愿意

00:58:46.680 --> 00:58:50.160
定期与Symantec通信，但

00:58:48.720 --> 00:58:51.420
是的，我想我们可以调查一下

00:58:50.160 --> 00:58:54.600
我要问我们的一种产品

00:58:51.420 --> 00:58:59.010
经理，如果我们在那里有渠道，但是

00:58:54.600 --> 00:59:01.110
没有没有办法调整

00:58:59.010 --> 00:59:04.140
您自己正在使用的防病毒软件

00:59:01.110 --> 00:59:06.620
锁定环境是的，对不起，我

00:59:04.140 --> 00:59:06.620
非常抱歉

00:59:08.700 --> 00:59:15.609
斯蒂芬要问同样的问题

00:59:10.779 --> 00:59:17.759
关于McAfee希望有所作为

00:59:15.609 --> 00:59:21.210
我只是要记下Avast 

00:59:17.759 --> 00:59:23.140
安全拒绝了Java和Javac 

00:59:21.210 --> 00:59:25.809
当我尝试运行可执行文件时

00:59:23.140 --> 00:59:28.720
当我捐赠东西时，这种病毒

00:59:25.809 --> 00:59:30.640
早点检查这很常见

00:59:28.720 --> 00:59:33.549
幸运的是，可以使用Avast访问产品

00:59:30.640 --> 00:59:35.289
您刚刚将罐子上传回他们

00:59:33.549 --> 00:59:37.480
 19分钟后，他们说是的

00:59:35.289 --> 00:59:40.180
很安全，这还不是全部

00:59:37.480 --> 00:59:43.480
出于好奇，这是一个问题

00:59:40.180 --> 00:59:46.059
是每一个构建

00:59:43.480 --> 00:59:47.710
只有我尝试过的，我下载了早期的

00:59:46.059 --> 00:59:49.359
访问构建，它没有反对我

00:59:47.710 --> 00:59:52.900
下载了拼图的抢先体验版

00:59:49.359 --> 00:59:55.539
哦，是的，一定一定更好

00:59:52.900 --> 00:59:57.970
谁知道为什么那东西撕裂

00:59:55.539 --> 00:59:59.859
但是，是的，以为Java 

00:59:57.970 --> 01:00:03.490
尽管Java是一种病毒，并将其放入

00:59:59.859 --> 01:00:04.930
胸部谢谢，我会问我会问我们

01:00:03.490 --> 01:00:05.589
产品管理团队（如果有） 

01:00:04.930 --> 01:00:08.559
频道也

01:00:05.589 --> 01:00:12.490
是的，我的问题是你可以去吗

01:00:08.559 --> 01:00:15.160
通过j-mods经文罐子

01:00:12.490 --> 01:00:18.759
您可以将J mods放在

01:00:15.160 --> 01:00:21.400
模块路径为什么你要走

01:00:18.759 --> 01:00:26.289
通过这样的J mods 

01:00:21.400 --> 01:00:28.480
 n个jar，所以jar文件是什么

01:00:26.289 --> 01:00:31.210
每个开发人员和每个构建工具

01:00:28.480 --> 01:00:32.980
已经了解了，所以很棒

01:00:31.210 --> 01:00:34.480
模块化罐子的窍门是它们只是

01:00:32.980 --> 01:00:36.940
具有这些额外功能的jar文件

01:00:34.480 --> 01:00:38.619
归档在其中，如果您编译的东西

01:00:36.940 --> 01:00:40.720
正确的，您甚至可以将其用于我们的

01:00:38.619 --> 01:00:45.279
文件放在类路径中，然后输入8或

01:00:40.720 --> 01:00:48.910
早期的J mod是不同的

01:00:45.279 --> 01:00:53.220
我们创建的格式，因为

01:00:48.910 --> 01:00:55.750
 JDK本身，我们需要一个工件

01:00:53.220 --> 01:00:59.079
不仅可以包含类的类型

01:00:55.750 --> 01:01:02.589
文件，但配置文件和本机文件

01:00:59.079 --> 01:01:05.380
库，启动器和许可证

01:01:02.589 --> 01:01:08.380
文件和手册页

01:01:05.380 --> 01:01:09.970
的东西，没有没有

01:01:08.380 --> 01:01:13.270
将其放入罐子的自然方式

01:01:09.970 --> 01:01:15.910
不会很混乱

01:01:13.270 --> 01:01:18.150
所以目前有j-mods 

01:01:15.910 --> 01:01:20.530
它们只是zip文件

01:01:18.150 --> 01:01:24.010
 Mandis正在努力清理它们

01:01:20.530 --> 01:01:25.780
并且最终将实际放一个

01:01:24.010 --> 01:01:27.760
在前面放一个魔术数字，以便

01:01:25.780 --> 01:01:30.670
有可能将它们与

01:01:27.760 --> 01:01:34.150
其他实际上是

01:01:30.670 --> 01:01:38.050
未来的zip文件，我们可能会

01:01:34.150 --> 01:01:40.630
可能会更改该格式，这是J 

01:01:38.050 --> 01:01:43.150
我认为不会的mod格式

01:01:40.630 --> 01:01:45.070
 Java SE 9规范的一部分，但它将

01:01:43.150 --> 01:01:46.420
被记录下来，你知道这肯定是

01:01:45.070 --> 01:01:47.890
想到我们要使用它的人

01:01:46.420 --> 01:01:50.080
那会没事的

01:01:47.890 --> 01:01:51.940
一个受支持的工具，称为J mod 

01:01:50.080 --> 01:01:53.800
创建和处理J mod文件

01:01:51.940 --> 01:01:56.530
这就是我们用来制作所有j-mod的东西

01:01:53.800 --> 01:01:59.140
目前J mods带有jdk的芯片

01:01:56.530 --> 01:02:01.270
只是你可以把它们放在模块上

01:01:59.140 --> 01:02:03.850
路径，但只有链接时间或

01:02:01.270 --> 01:02:07.570
编译时间他们在那里，他们不在

01:02:03.850 --> 01:02:08.980
它们对运行时没有用，所以如果

01:02:07.570 --> 01:02:12.600
你会玩，如果你会玩

01:02:08.980 --> 01:02:15.280
链接游戏，那么他们就很方便

01:02:12.600 --> 01:02:16.540
但是如果您要运送的话

01:02:15.280 --> 01:02:19.090
可以在mod上进行的事情

01:02:16.540 --> 01:02:21.760
运行时的模块路径，则它们不是

01:02:19.090 --> 01:02:24.280
你想要什么，他们会they饮

01:02:21.760 --> 01:02:30.220
将来会在运行时支持

01:02:24.280 --> 01:02:33.490
可能发布，但子弹我们会

01:02:30.220 --> 01:02:35.619
看看进展如何，所以我想我们是否要

01:02:33.490 --> 01:02:38.080
总结当时的J mod 

01:02:35.619 --> 01:02:41.380
主要用于Oracle的内部目的

01:02:38.080 --> 01:02:42.000
那会是他们的糟糕总结吗

01:02:41.380 --> 01:02:44.109
一世

01:02:42.000 --> 01:02:46.450
我们不应该担心

01:02:44.109 --> 01:02:48.490
虽然那个三世会在没有

01:02:46.450 --> 01:02:50.560
总结两点是什么

01:02:48.490 --> 01:02:52.690
不是Oracle内部写的，这是

01:02:50.560 --> 01:02:55.359
打开JDK我希望有任何打开的JDK 

01:02:52.690 --> 01:02:57.130
您知道要支持的派生分布

01:02:55.359 --> 01:03:02.410
 j-mods，除非他们将其淘汰

01:02:57.130 --> 01:03:05.260
会是愚蠢的举动吗？ 

01:03:02.410 --> 01:03:10.570
在九个J中大体上是正确的

01:03:05.260 --> 01:03:14.710
 mods用于包含的模块

01:03:10.570 --> 01:03:17.770
 JDK II不会感到惊讶

01:03:14.710 --> 01:03:21.340
其他一些J mod出现在

01:03:17.770 --> 01:03:22.630
特别是对于包含

01:03:21.340 --> 01:03:24.990
一堆本机代码

01:03:22.630 --> 01:03:28.690
会有一种便捷的运送方式

01:03:24.990 --> 01:03:30.519
但我当然知道我没有

01:03:28.690 --> 01:03:34.329
我们有任何期望的期望

01:03:30.519 --> 01:03:37.289
 j-mods至少不会替换jar 

01:03:34.329 --> 01:03:37.289
接下来的几年

01:03:51.589 --> 01:03:57.589
不，请进入我们的麦克风

01:03:56.420 --> 01:04:00.529
如果我们真的很难听到你

01:03:57.589 --> 01:04:03.289
你站着不讨好麦克风

01:04:00.529 --> 01:04:04.880
昨天有你能给我们吗

01:04:03.289 --> 01:04:09.439
链接，因为我找不到

01:04:04.880 --> 01:04:12.109
正确的决定，是的，这是

01:04:09.439 --> 01:04:15.019
我所有的拼图游戏的幻灯片

01:04:12.109 --> 01:04:17.029
将创建一个链接到的页面

01:04:15.019 --> 01:04:18.619
拼图页面可能今天晚些时候与

01:04:17.029 --> 01:04:22.279
所有PDF和视频链接

01:04:18.619 --> 01:04:24.170
流和所有有关您的信息，如果您愿意

01:04:22.279 --> 01:04:25.489
如果没有其他办法可以发推

01:04:24.170 --> 01:04:28.059
在那找到它或只是去拼图

01:04:25.489 --> 01:04:31.670
几天之内就会找到它

01:04:28.059 --> 01:04:35.900
我们在两个JVM中工作的另一个问题

01:04:31.670 --> 01:04:38.930
所以我们启动我们的IDE然后调用另一个

01:04:35.900 --> 01:04:43.809
 JVM将用户代码放到哪里

01:04:38.930 --> 01:04:47.869
 JDK 9中的更改以任何方式受到影响

01:04:43.809 --> 01:04:54.219
两个JVM之间的tcp / ip对话

01:04:47.869 --> 01:04:54.219
还是不好，谢谢收看

01:04:59.370 --> 01:05:07.620
我们的多释放罐在此范围内

01:05:02.640 --> 01:05:08.520
聊天多释放罐是，他们是

01:05:07.620 --> 01:05:11.730
在JDK九

01:05:08.520 --> 01:05:17.670
是的，但是你要提问哦

01:05:11.730 --> 01:05:18.840
哦，可以确定，我们可以尝试

01:05:17.670 --> 01:05:20.580
顺便说一句，他们真的是毛茸茸的边缘

01:05:18.840 --> 01:05:21.900
多释放罐和

01:05:20.580 --> 01:05:25.110
我们仍在尝试的模块化罐子

01:05:21.900 --> 01:05:26.910
锻炼得很好我的意思是我真的很感激

01:05:25.110 --> 01:05:30.330
你们在做多警察罐，因为

01:05:26.910 --> 01:05:31.830
我们有一个满意的客户

01:05:30.330 --> 01:05:34.470
实际上我们一直在想

01:05:31.830 --> 01:05:36.390
有人会用这些吗？我很好

01:05:34.470 --> 01:05:38.190
谈论他们为JDK 9做准备

01:05:36.390 --> 01:05:40.590
昨天谈话，并重复有一个

01:05:38.190 --> 01:05:42.240
好很多的问题，所以我有一个

01:05:40.590 --> 01:05:45.150
具有已安装基础的库

01:05:42.240 --> 01:05:48.750
你知道还在5:00并期待

01:05:45.150 --> 01:05:51.090
 6:00，所以我给你包了一个

01:05:48.750 --> 01:05:53.100
解析器事件流，我希望它成为

01:05:51.090 --> 01:05:54.360
当基础事物自动关闭

01:05:53.100 --> 01:05:56.520
我包装的是自动关闭的，但是我

01:05:54.360 --> 01:05:58.550
想重新封闭，所以自动

01:05:56.520 --> 01:06:00.630
不可关闭的五个

01:05:58.550 --> 01:06:03.480
在七年内生产回来

01:06:00.630 --> 01:06:07.290
是的，所以我做了五个可怕的事情

01:06:03.480 --> 01:06:08.870
和六个反射，所以我

01:06:07.290 --> 01:06:13.320
期待着

01:06:08.870 --> 01:06:15.720
所以我的问题是你建议

01:06:13.320 --> 01:06:18.870
使用

01:06:15.720 --> 01:06:20.310
释放标志或什么样的机械

01:06:18.870 --> 01:06:22.620
周围是否有我必须把我们的

01:06:20.310 --> 01:06:24.360
发布，因为我相信我必须把我们的

01:06:22.620 --> 01:06:28.670
发行四五六七七八和

01:06:24.360 --> 01:06:28.670
九本书正在推出一个五

01:06:30.080 --> 01:06:34.220
好吧，您是否要尝试创建一个

01:06:31.700 --> 01:06:37.220
适用于5 6 7 8＆9的工件

01:06:34.220 --> 01:06:39.230
是的，所以我想我能做的是

01:06:37.220 --> 01:06:44.660
想我可以把编译下来

01:06:39.230 --> 01:06:47.570
源5，然后我认为我可以4 7 8 9 

01:06:44.660 --> 01:06:56.210
我想我必须把个人或

01:06:47.570 --> 01:06:59.720
我可以这样说-我们3 

01:06:56.210 --> 01:07:00.440
抱歉-3和我是，还有and和- 

01:06:59.720 --> 01:07:04.010
 3周

01:07:00.440 --> 01:07:07.940
所以嘿，我们没有退港的计划

01:07:04.010 --> 01:07:11.120
多释放罐t29在6a中没有

01:07:07.940 --> 01:07:13.280
连8点都没有，所以多罐

01:07:11.120 --> 01:07:15.740
对处理差异很有用

01:07:13.280 --> 01:07:19.760
从8到9，然后在9到10 

01:07:15.740 --> 01:07:22.850
等等，所以我们没有

01:07:19.760 --> 01:07:24.680
计划将其移植回8 7 

01:07:22.850 --> 01:07:28.750
他们会解决类似的问题

01:07:24.680 --> 01:07:28.750
未来，但是对不起

01:07:36.859 --> 01:07:40.309
得到两个非常小的问题，所以

01:07:38.569 --> 01:07:41.569
现在有了这些策略文件，然后

01:07:40.309 --> 01:07:44.749
必须有两套政策

01:07:41.569 --> 01:08:05.930
文件，因为jrt语法不是

01:07:44.749 --> 01:08:07.190
我被jdk年龄接受了

01:08:05.930 --> 01:08:11.749
过去认为应该

01:08:07.190 --> 01:08:14.509
致命的，但我敢肯定不是

01:08:11.749 --> 01:08:17.210
所以就像我在里面有j-unit之类的东西

01:08:14.509 --> 01:08:19.759
我的构建，因为此工具运行j-unit 

01:08:17.210 --> 01:08:22.339
在学生代码上，所以我现在应该去

01:08:19.759 --> 01:08:24.500
返回并将其放入模块中

01:08:22.339 --> 01:08:26.569
等待他们去做，所以就忽略它

01:08:24.500 --> 01:08:29.599
并把它作为自动

01:08:26.569 --> 01:08:30.589
模块人是什么意思

01:08:29.599 --> 01:08:32.299
进入那里并放入一个模块

01:08:30.589 --> 01:08:33.920
声明我没有正确的选择

01:08:32.299 --> 01:08:39.049
错误地依赖hamcrest等

01:08:33.920 --> 01:08:40.520
但是我写得很好，我以为你不

01:08:39.049 --> 01:08:42.109
真的很想进去改变一个人

01:08:40.520 --> 01:08:43.549
其他的jar文件不是特别

01:08:42.109 --> 01:08:46.040
有点什么好

01:08:43.549 --> 01:08:47.389
练习良好的做法，直到

01:08:46.040 --> 01:08:49.549
维护者zuv je-yoon发布了

01:08:47.389 --> 01:08:51.529
 Jane的版本作为模块，然后在

01:08:49.549 --> 01:08:54.469
你可以临时过渡

01:08:51.529 --> 01:08:55.730
将单元推入模块

01:08:54.469 --> 01:08:57.469
路径作为自动模块，所以我们已经

01:08:55.730 --> 01:08:58.819
实际尝试了一下，它有效

01:08:57.469 --> 01:09:01.270
很好，我会尝试的

01:08:58.819 --> 01:09:01.270
谢谢

01:09:05.029 --> 01:09:10.130
先生。科尔布或其他任何人都会有

01:09:13.039 --> 01:09:16.559
给你或得到这个行家中央

01:09:15.209 --> 01:09:18.389
你实际上可以去弄清楚的东西

01:09:16.559 --> 01:09:21.209
关于Maven中央罐的很多东西

01:09:18.389 --> 01:09:23.309
文件你有什么数字

01:09:21.209 --> 01:09:26.699
 Maven Central上jar文件的百分比

01:09:23.309 --> 01:09:30.089
对于敏感产品项目有

01:09:26.699 --> 01:09:32.729
包名之间相互冲突

01:09:30.089 --> 01:09:35.339
我知道Commons Bean utils的版本

01:09:32.729 --> 01:09:37.499
在最新版本包含

01:09:35.339 --> 01:09:39.749
来自Commons Collections的包装是

01:09:37.499 --> 01:09:41.909
谈到那个例子，你说

01:09:39.749 --> 01:09:43.859
你知道这件事显然有

01:09:41.909 --> 01:09:45.599
发生了，那仍然发生，我只是

01:09:43.859 --> 01:09:48.739
想知道您是否进行了任何分析或

01:09:45.599 --> 01:09:51.920
找出问题有多严重

01:09:48.739 --> 01:09:55.619
我们完成了包裹冲突分析

01:09:51.920 --> 01:09:59.670
没有正式做，但是冲突

01:09:55.619 --> 01:10:03.150
我尝试过的包装数量

01:09:59.670 --> 01:10:05.459
年前但数量很大

01:10:03.150 --> 01:10:08.459
因为我有很多

01:10:05.459 --> 01:10:11.130
文物，还有一些旧的

01:10:08.459 --> 01:10:14.369
版本也很高

01:10:11.130 --> 01:10:16.530
但不是，如果您要询问s 

01:10:14.369 --> 01:10:19.289
是的，我没有我们的电话号码

01:10:16.530 --> 01:10:23.820
到现在，是的，是的，是的

01:10:19.289 --> 01:10:25.469
很难，因为如果你知道的话

01:10:23.820 --> 01:10:28.439
如果您探索Maven Central， 

01:10:25.469 --> 01:10:30.809
可以找到你知道的地方

01:10:28.439 --> 01:10:33.059
可能会在六岁以下找到冬眠

01:10:30.809 --> 01:10:34.979
不同的组ID，这非常

01:10:33.059 --> 01:10:36.449
令人困惑，因为任何人你都可以知道

01:10:34.979 --> 01:10:37.709
将其上传到其他组ID下

01:10:36.449 --> 01:10:41.099
我们自己的包装版本或其他

01:10:37.709 --> 01:10:43.050
所以你知道什么吗

01:10:41.099 --> 01:10:45.150
权威，以便您实际上

01:10:43.050 --> 01:10:47.329
做一个包冲突分析很漂亮

01:10:45.150 --> 01:10:47.329
强硬

01:10:48.590 --> 01:10:52.630
我认为如果我们

01:10:50.630 --> 01:10:56.150
可以找出什么是真正活跃的

01:10:52.630 --> 01:10:58.639
项目使用的工件和

01:10:56.150 --> 01:11:01.520
然后从那里统计

01:10:58.639 --> 01:11:03.790
更多，嗯，代表任何东西

01:11:01.520 --> 01:11:03.790
是的

01:11:19.640 --> 01:11:25.730
在模块信息文件中进行编译

01:11:22.310 --> 01:11:30.500
分别是，模块信息文件可以是

01:11:25.730 --> 01:11:33.170
单独编译，因此来自JDK的模块

01:11:30.500 --> 01:11:36.230
我可以剥离模块信息并

01:11:33.170 --> 01:11:41.120
在那儿插入我自己的模型，以便

01:11:36.230 --> 01:11:43.130
我得到了更广泛的访问，您可以这样做

01:11:41.120 --> 01:11:45.110
你必须重新运行链接器

01:11:43.130 --> 01:11:53.650
如果您真的想这样做，可以

01:11:45.110 --> 01:11:57.340
你可以做到你无法创新

01:11:53.650 --> 01:12:03.560
反思后证交会成真

01:11:57.340 --> 01:12:05.630
那可以确保你你你你你

01:12:03.560 --> 01:12:08.540
可以带走所有的J mod 

01:12:05.630 --> 01:12:10.910
在JDK 9中重写了所有

01:12:08.540 --> 01:12:13.220
模块和适合类文件以导出

01:12:10.910 --> 01:12:15.890
您可能会做的所有事情J链接

01:12:13.220 --> 01:12:31.250
变成你自己的形象，你可以

01:12:15.890 --> 01:12:46.730
一直访问所有内容，是吗

01:12:31.250 --> 01:12:48.860
一个很好的实践，实际上我们

01:12:46.730 --> 01:12:53.690
在J中确实进行了一些完整性检查

01:12:48.860 --> 01:12:57.230
在我们记录的JDK的J mods中

01:12:53.690 --> 01:13:00.260
 J mod中每个人的强哈希

01:12:57.230 --> 01:13:02.630
对于基本模块，因此，这是一个

01:13:00.260 --> 01:13:06.320
其实很难欺骗

01:13:02.630 --> 01:13:08.420
内置模块（如果您） 

01:13:06.320 --> 01:13:09.800
您将要链接它们，我们只是

01:13:08.420 --> 01:13:11.570
我们没有做任何公钥

01:13:09.800 --> 01:13:13.910
密码学或签名或任何

01:13:11.570 --> 01:13:16.850
东西是它是你知道它得到

01:13:13.910 --> 01:13:19.450
非常麻烦，并且它不会

01:13:16.850 --> 01:13:19.450
似乎值得麻烦

01:13:19.710 --> 01:13:26.170
那不是一件有趣的事

01:13:22.300 --> 01:13:27.940
我们没有考虑过我们可以

01:13:26.170 --> 01:13:32.079
我们可以将VM的哈希值烘烤到VM中

01:13:27.940 --> 01:13:34.869
基本模型本身以及那个和那个

01:13:32.079 --> 01:13:35.770
会阻止这种事情

01:13:34.869 --> 01:13:37.030
英国不会后悔

01:13:35.770 --> 01:13:38.980
阻止它，您总是可以获取源

01:13:37.030 --> 01:13:41.820
自己编写代码并进行构建

01:13:38.980 --> 01:13:47.849
会阻止人们

01:13:41.820 --> 01:13:47.849
猖re地重写模块信息

