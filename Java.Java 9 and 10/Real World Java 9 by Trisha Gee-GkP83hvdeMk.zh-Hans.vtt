WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.030 --> 00:00:07.350
很好，你玩狗屎，请确保

00:00:03.870 --> 00:00:09.210
大家早上好欢迎您

00:00:07.350 --> 00:00:11.219
我见过的最有组织的观众

00:00:09.210 --> 00:00:13.710
您喜欢改组腾出的空间

00:00:11.219 --> 00:00:14.730
每个人都用光了

00:00:13.710 --> 00:00:16.410
太棒了，我从未见过

00:00:14.730 --> 00:00:20.310
我去过很多会议

00:00:16.410 --> 00:00:21.900
做得好，是的，我是特里西娅，我的意思是

00:00:20.310 --> 00:00:25.230
我想在Java方面为您服务

00:00:21.900 --> 00:00:28.170
我打算回家这并不令人震惊

00:00:25.230 --> 00:00:30.150
所有人，我是

00:00:28.170 --> 00:00:33.270
我主要与IntelliJ合作的JetBrains 

00:00:30.150 --> 00:00:35.399
任何使用IntelliJ IDEA的人

00:00:33.270 --> 00:00:39.770
你我爱你你所有的幻想

00:00:35.399 --> 00:00:42.600
蚀用户，为您和我感到抱歉

00:00:39.770 --> 00:00:44.879
也可以与源代码一起进行代码审查

00:00:42.600 --> 00:00:47.700
工具，但我的大部分工作是在做

00:00:44.879 --> 00:00:50.219
并研究Java的新功能

00:00:47.700 --> 00:00:51.840
或当前有趣的是什么

00:00:50.219 --> 00:00:53.969
在Java中，然后说出如何

00:00:51.840 --> 00:00:55.949
应用于日常工作

00:00:53.969 --> 00:00:58.320
基本上是因为我是Java程序

00:00:55.949 --> 00:01:01.050
大约20年了

00:00:58.320 --> 00:01:02.250
令人恐惧，你认识的人

00:01:01.050 --> 00:01:04.860
总是告诉你新的和令人兴奋的

00:01:02.250 --> 00:01:05.939
的东西，但这与什么无关

00:01:04.860 --> 00:01:07.350
你在做日常工作，除非

00:01:05.939 --> 00:01:09.510
有人让它更适合您

00:01:07.350 --> 00:01:11.460
所以这就是我对工作的看法

00:01:09.510 --> 00:01:14.340
你喜欢所以今天我们要谈

00:01:11.460 --> 00:01:16.619
关于现实世界中的Java 9，这是

00:01:14.340 --> 00:01:18.390
很棒，因为Java 9还没有推出

00:01:16.619 --> 00:01:22.320
我真的很想掩饰一点

00:01:18.390 --> 00:01:24.180
拼图在行动中，谁去了

00:01:22.320 --> 00:01:26.759
或Marc在

00:01:24.180 --> 00:01:27.930
会议很棒，因为我不

00:01:26.759 --> 00:01:29.130
想重复很多东西

00:01:27.930 --> 00:01:31.880
他说我只想给我们一个

00:01:29.130 --> 00:01:33.810
我用拼图看了一下

00:01:31.880 --> 00:01:35.790
会涉及一些反应性

00:01:33.810 --> 00:01:37.350
 Java 9中的编程我会隐藏标记

00:01:35.790 --> 00:01:40.710
在我的观众中，请不要对

00:01:37.350 --> 00:01:42.570
我如果我弄错了，我也

00:01:40.710 --> 00:01:44.970
我真的很想做，希望

00:01:42.570 --> 00:01:46.229
我有时间最后会很好

00:01:44.970 --> 00:01:48.060
我们将花费大量时间

00:01:46.229 --> 00:01:49.350
 Java 9中的其他功能不是

00:01:48.060 --> 00:01:51.479
所有这些，但我认为

00:01:49.350 --> 00:01:52.920
在您中与您息息相关

00:01:51.479 --> 00:01:56.250
日常工作，所以他们很有趣

00:01:52.920 --> 00:01:57.990
首先向开发人员介绍其他东西

00:01:56.250 --> 00:02:00.210
让我们退后一步，看看为什么

00:01:57.990 --> 00:02:02.280
除了新版本，我们还关心Java 9 

00:02:00.210 --> 00:02:04.799
令人兴奋的，显然我们想要新的

00:02:02.280 --> 00:02:06.180
从我的理解中令人兴奋， 

00:02:04.799 --> 00:02:08.160
当然你要记住

00:02:06.180 --> 00:02:10.950
没有人希望没有人使用

00:02:08.160 --> 00:02:12.780
生产但Java 9的想法是

00:02:10.950 --> 00:02:14.310
你会得到一堆东西

00:02:12.780 --> 00:02:16.709
三，您将获得更好的性能

00:02:14.310 --> 00:02:18.360
更好地使用内存，它使用新的CPU 

00:02:16.709 --> 00:02:20.370
指示类似的事情，所以你

00:02:18.360 --> 00:02:22.319
应该得到性能

00:02:20.370 --> 00:02:24.180
改善和总体上更好

00:02:22.319 --> 00:02:26.280
编译器之类的经验

00:02:24.180 --> 00:02:29.880
并且无需使用任何新

00:02:26.280 --> 00:02:31.410
功能，这是一件好事，让我们

00:02:29.880 --> 00:02:34.140
就像让我们看一下大象

00:02:31.410 --> 00:02:36.180
房间马上和大多数人

00:02:34.140 --> 00:02:38.160
他们谈论Java 9 

00:02:36.180 --> 00:02:41.010
我提到了拼图，特别是如果

00:02:38.160 --> 00:02:43.560
你的名字是马克·莱因霍尔德（Mark Reinhold）等

00:02:41.010 --> 00:02:48.000
这是Java 9的一大功能

00:02:43.560 --> 00:02:50.400
好吧，我不知道我要说什么

00:02:48.000 --> 00:02:52.200
对于我们来说，这可能并不令人兴奋

00:02:50.400 --> 00:02:54.480
开发人员，也许我们会继续

00:02:52.200 --> 00:02:56.100
这样您就可以了解Java 9 

00:02:54.480 --> 00:02:58.980
听说谁听说过

00:02:56.100 --> 00:03:01.350
重复杰伊壳梦幻般的观众你

00:02:58.980 --> 00:03:03.360
是的，所以也许你们一半以上

00:03:01.350 --> 00:03:04.709
所以记者的想法

00:03:03.360 --> 00:03:07.319
用另一种不是

00:03:04.709 --> 00:03:09.720
 Java我不知道那是同一套

00:03:07.319 --> 00:03:12.090
的人，但这是你们的很大一部分

00:03:09.720 --> 00:03:14.400
所以我们大多数人都在从事Java和

00:03:12.090 --> 00:03:16.860
很长时间以来，只有Java是

00:03:14.400 --> 00:03:18.420
一种有趣而新颖的想法

00:03:16.860 --> 00:03:19.860
能够执行小事的想法

00:03:18.420 --> 00:03:21.780
命令行中的代码片段

00:03:19.860 --> 00:03:24.030
尝试一下，这对于

00:03:21.780 --> 00:03:25.440
介绍自己的语言，但

00:03:24.030 --> 00:03:26.880
它也很适合尝试

00:03:25.440 --> 00:03:28.709
点点滴滴看看事情如何运作

00:03:26.880 --> 00:03:30.360
我认为这是一个

00:03:28.709 --> 00:03:31.980
 Java很有趣，因为在

00:03:30.360 --> 00:03:33.600
过去你知道我们被指控拥有

00:03:31.980 --> 00:03:35.070
我不知道很多样板

00:03:33.600 --> 00:03:37.079
为什么他们这么说，当一个简单的

00:03:35.070 --> 00:03:39.870
你好世界申请只有24行

00:03:37.079 --> 00:03:41.700
代码，但记录将帮助我们和

00:03:39.870 --> 00:03:43.890
尝试所有东西而不必拥有所有东西

00:03:41.700 --> 00:03:45.450
样板，但我们有点

00:03:43.890 --> 00:03:48.090
剩下的这个问题，我们有

00:03:45.450 --> 00:03:49.350
拨浪鼓和拼图，还有什么

00:03:48.090 --> 00:03:51.570
有什么东西可以

00:03:49.350 --> 00:03:53.459
作为开发人员对我来说很有趣，但是

00:03:51.570 --> 00:03:56.130
事实证明，在Java 9中有一个或

00:03:53.459 --> 00:03:57.720
两件事进入了

00:03:56.130 --> 00:03:59.250
语言中的一些不是

00:03:57.720 --> 00:04:00.570
一定对你可见

00:03:59.250 --> 00:04:02.070
作为开发人员，有很多东西

00:04:00.570 --> 00:04:03.510
显然已经被掩盖了

00:04:02.070 --> 00:04:05.370
诸如模块化的东西

00:04:03.510 --> 00:04:07.470
 JDK就像更新是

00:04:05.370 --> 00:04:08.640
在JDK中记录类似我的东西

00:04:07.470 --> 00:04:10.230
认为我写了很多表演

00:04:08.640 --> 00:04:12.090
测试之类的东西，所以不是

00:04:10.230 --> 00:04:14.100
必须对您可见，但您

00:04:12.090 --> 00:04:16.410
应该从中受益

00:04:14.100 --> 00:04:18.209
做一个更好的书面更好的设计

00:04:16.410 --> 00:04:19.890
语言，但还有其他一些地方

00:04:18.209 --> 00:04:21.630
在这里，我想拿一个

00:04:19.890 --> 00:04:22.880
也要看最后

00:04:21.630 --> 00:04:25.610
做到三分之一

00:04:22.880 --> 00:04:27.620
通过演示

00:04:25.610 --> 00:04:31.250
里面哪些东西最多

00:04:27.620 --> 00:04:32.750
适用于我们平时喜欢的设置

00:04:31.250 --> 00:04:34.460
我对这次演讲的期望

00:04:32.750 --> 00:04:38.060
适当低，因为大约

00:04:34.460 --> 00:04:40.069
当然有500个人在这个房间里

00:04:38.060 --> 00:04:43.129
您不应该在其中使用Java 9 

00:04:40.069 --> 00:04:45.289
生产请不要这样做，不是

00:04:43.129 --> 00:04:47.960
准备好了，它确实从星期开始改变

00:04:45.289 --> 00:04:49.610
一周，所以每次你都知道

00:04:47.960 --> 00:04:51.349
您在那里下载最新版本

00:04:49.610 --> 00:04:55.069
事物运作方式有一些变化

00:04:51.349 --> 00:04:56.780
所以不要在生产中使用它

00:04:55.069 --> 00:04:59.139
玩的肯定是

00:04:56.780 --> 00:05:01.280
准备尝试

00:04:59.139 --> 00:05:03.500
说什么都早

00:05:01.280 --> 00:05:06.110
再次访问以设定期望

00:05:03.500 --> 00:05:07.909
适当低，我正在使用早期

00:05:06.110 --> 00:05:10.370
我实际上是访问Java 9的版本

00:05:07.909 --> 00:05:12.710
我认为使用构建1 6 6 

00:05:10.370 --> 00:05:14.840
最近的一个是build 1 6 8，但我们会

00:05:12.710 --> 00:05:18.020
版本1 6 8与

00:05:14.840 --> 00:05:19.879
最新的IntelliJ IDEA EA版本

00:05:18.020 --> 00:05:21.860
你必须得到正确的选择

00:05:19.879 --> 00:05:24.979
抢先体验组合

00:05:21.860 --> 00:05:27.439
为了尝试并尝试得到东西

00:05:24.979 --> 00:05:28.909
正常工作，所以我只使用

00:05:27.439 --> 00:05:32.090
访问Java 9，然后进行早期访问

00:05:28.909 --> 00:05:34.580
建筑商IntelliJ IDEA和2017指向

00:05:32.090 --> 00:05:36.469
那些早期访问只是出来的

00:05:34.580 --> 00:05:39.169
就像上周一样，现在还很早

00:05:36.469 --> 00:05:42.529
几天我不会用不稳定这个词，而是

00:05:39.169 --> 00:05:44.389
而且总是很有趣的

00:05:42.529 --> 00:05:46.129
 Java 9当然我们真的不知道

00:05:44.389 --> 00:05:48.259
最佳做法是什么样的

00:05:46.129 --> 00:05:50.089
因为我们没有使用它，所以我们没有

00:05:48.259 --> 00:05:51.710
在生产中使用我们只是

00:05:50.089 --> 00:05:53.240
开始了解什么是最好的

00:05:51.710 --> 00:05:54.979
实践可能看起来像

00:05:53.240 --> 00:05:56.900
带有lambda和流的Java 8 

00:05:54.979 --> 00:05:59.060
事情，所以我真的不能告诉你喜欢

00:05:56.900 --> 00:06:01.190
这是做拼图明智的方法

00:05:59.060 --> 00:06:02.750
因为我们直到那时才会真正知道

00:06:01.190 --> 00:06:06.770
它被嵌入并且人们开始使用

00:06:02.750 --> 00:06:07.909
如果你愿意的话，会更生气

00:06:06.770 --> 00:06:10.879
我为案例研究设定了背景

00:06:07.909 --> 00:06:13.520
我们将看看devoxx UK 

00:06:10.879 --> 00:06:16.400
几年前，我做了一个Java演示

00:06:13.520 --> 00:06:18.289
 8我很生气地写了这个申请

00:06:16.400 --> 00:06:20.029
演示Java 8功能，例如lambdas 

00:06:18.289 --> 00:06:22.610
和流，想法是它是Java 

00:06:20.029 --> 00:06:24.620
响应的效果UI 

00:06:22.610 --> 00:06:26.659
实时推文数据等等

00:06:24.620 --> 00:06:28.789
恰好有很多

00:06:26.659 --> 00:06:30.560
可能很小的微小服务

00:06:28.789 --> 00:06:31.879
但它们不是微服务，因为

00:06:30.560 --> 00:06:33.680
他们不可靠，他们跌倒了

00:06:31.879 --> 00:06:35.240
没有监控或没有任何时间的时候

00:06:33.680 --> 00:06:36.979
东西实际上适合微

00:06:35.240 --> 00:06:39.420
服务，但是这个主意

00:06:36.979 --> 00:06:41.640
应用是要使用

00:06:39.420 --> 00:06:43.230
架构某些东西的八个功能

00:06:41.640 --> 00:06:45.390
这就像很多

00:06:43.230 --> 00:06:47.460
独立服务并对

00:06:45.390 --> 00:06:49.350
实时数据，事实证明

00:06:47.460 --> 00:06:50.850
这是一个很好的例子

00:06:49.350 --> 00:06:52.050
 Java 9特别是当我们

00:06:50.850 --> 00:06:54.270
看着像导演

00:06:52.050 --> 00:06:56.040
流API，这是我想要的

00:06:54.270 --> 00:06:58.020
详细一点，如果

00:06:56.040 --> 00:07:00.060
您对原版感兴趣

00:06:58.020 --> 00:07:01.830
应用程序，我有资源

00:07:00.060 --> 00:07:03.210
明确地说，所以我不会去

00:07:01.830 --> 00:07:04.530
进入它的所有来龙去脉

00:07:03.210 --> 00:07:07.620
以及为什么这样做，因为我

00:07:04.530 --> 00:07:09.450
已经有一个演讲了

00:07:07.620 --> 00:07:11.070
首先，也是我唯一的方式

00:07:09.450 --> 00:07:13.020
大概有50分钟的时间谈论所有

00:07:11.070 --> 00:07:15.540
 Java 9，所以我要讲得很快

00:07:13.020 --> 00:07:19.170
道歉但我在伦敦所以我感到

00:07:15.540 --> 00:07:22.320
舒适地在这里和下一个

00:07:19.170 --> 00:07:24.120
是的，所以我想，如果您阅读

00:07:22.320 --> 00:07:26.130
如果您阅读过有关Java 9的任何内容

00:07:24.120 --> 00:07:28.350
在新闻中你可能会得到一点

00:07:26.130 --> 00:07:30.300
惊恐的一些恐怖故事

00:07:28.350 --> 00:07:32.940
一切都会破坏它们Java 9 

00:07:30.300 --> 00:07:34.290
所以我真正想做的第一件事

00:07:32.940 --> 00:07:37.680
是像我这样的应用程序

00:07:34.290 --> 00:07:38.970
应用程序很小，就像小

00:07:37.680 --> 00:07:40.620
足以让您的大脑绕开它，但是

00:07:38.970 --> 00:07:42.600
足以做某事的复杂

00:07:40.620 --> 00:07:45.210
有趣，我想编译它

00:07:42.600 --> 00:07:48.540
 Java 9，看看有什么坏处

00:07:45.210 --> 00:07:52.290
我们可以了解潜在潜力的方式

00:07:48.540 --> 00:07:57.420
问题可能存在，所以让我们尝试

00:07:52.290 --> 00:07:59.160
让这个运行哦，是的，第一件事

00:07:57.420 --> 00:08:00.480
我想做的是我想看到它正在运行

00:07:59.160 --> 00:08:02.340
一开始只是为了确保

00:08:00.480 --> 00:08:04.770
一切都从一开始

00:08:02.340 --> 00:08:06.540
因为如果不行不通

00:08:04.770 --> 00:08:08.760
在我开始重构之前是Java 9 

00:08:06.540 --> 00:08:11.510
其余用户对零希望

00:08:08.760 --> 00:08:11.510
其余的演示

00:08:35.990 --> 00:08:40.010
正如我所说的那样， 

00:08:37.940 --> 00:08:41.870
我有一个独立的服务

00:08:40.010 --> 00:08:43.490
服务像Twitter一样

00:08:41.870 --> 00:08:45.500
服务，它正在从文件中读取推文

00:08:43.490 --> 00:08:47.210
为了让生活更轻松一点

00:08:45.500 --> 00:08:50.300
正在提取用户名的服务

00:08:47.210 --> 00:08:52.970
从那些推文中，我有心情服务

00:08:50.300 --> 00:08:58.400
这还没有开始，让我们尝试一下

00:08:52.970 --> 00:08:59.990
我又有一个情绪服务，看起来

00:08:58.400 --> 00:09:01.490
在推文上，提取是否

00:08:59.990 --> 00:09:06.430
推文通常是快乐的

00:09:01.490 --> 00:09:09.080
悲伤，我有一个仪表板

00:09:06.430 --> 00:09:10.520
实时显示这些结果

00:09:09.080 --> 00:09:12.470
是的，看看那个例外

00:09:10.520 --> 00:09:14.750
我认为这是因为我

00:09:12.470 --> 00:09:17.060
开始之前先启动了仪表板

00:09:14.750 --> 00:09:20.140
情绪服务，因此我对

00:09:17.060 --> 00:09:20.140
缺乏可靠性

00:09:27.860 --> 00:09:32.550
这是一种工作

00:09:29.300 --> 00:09:32.550
 [音乐] 

00:09:35.830 --> 00:09:39.700
好的，我们去了，是的，所以工作

00:09:38.230 --> 00:09:49.480
在重构之前，这是一个真正的

00:09:39.700 --> 00:09:50.620
好的开始，现在我要

00:09:49.480 --> 00:09:52.540
看看我第一次发生了什么

00:09:50.620 --> 00:09:55.180
针对Java 9编译了此应用程序

00:09:52.540 --> 00:09:58.029
这显然是一个Java 8应用程序，所以

00:09:55.180 --> 00:09:59.740
让我们回到一个版本

00:09:58.029 --> 00:10:02.250
在我开始做Java 9之前

00:09:59.740 --> 00:10:02.250
移民

00:10:07.860 --> 00:10:11.060
所以如果我建立这个

00:10:17.080 --> 00:10:21.370
我们去那里，所以我有几件事

00:10:19.810 --> 00:10:22.570
确实插入了一些失败的内容

00:10:21.370 --> 00:10:25.690
目的，但大多数东西

00:10:22.570 --> 00:10:27.940
失败首先已经存在

00:10:25.690 --> 00:10:29.860
下划线不能为有效字段

00:10:27.940 --> 00:10:30.940
现在命名人们可能会认为我没有

00:10:29.860 --> 00:10:33.040
知道你可以那样做

00:10:30.940 --> 00:10:35.260
令人兴奋的是我可以使用下划线作为有效

00:10:33.040 --> 00:10:36.820
字段名称，直到Java 8 

00:10:35.260 --> 00:10:39.279
可以在有效字段中使用下划线或

00:10:36.820 --> 00:10:40.630
参数或变量名称，但使用Java 

00:10:39.279 --> 00:10:42.430
 Java 8中的9点，您会收到警告

00:10:40.630 --> 00:10:44.440
在Java 9中无法正常工作

00:10:42.430 --> 00:10:48.149
不再这样做了

00:10:44.440 --> 00:10:50.829
相当容易的修复和明智的选择

00:10:48.149 --> 00:10:52.000
然后你走了，原因是

00:10:50.829 --> 00:10:53.410
他们将使用下划线或

00:10:52.000 --> 00:10:55.600
在以后的版本中有趣的事情

00:10:53.410 --> 00:10:56.800
 Java的，所以有点酷，但是

00:10:55.600 --> 00:10:59.410
同时显然我们必须得到

00:10:56.800 --> 00:11:03.339
从我们的代码库中删除它之一

00:10:59.410 --> 00:11:10.570
其他的就是把它拿出来

00:11:03.339 --> 00:11:12.010
演示模式，当然就像我们

00:11:10.570 --> 00:11:14.110
总是在这里与拼图，其中之一

00:11:12.010 --> 00:11:15.519
想法是封装内部

00:11:14.110 --> 00:11:18.459
 API是您不应该访问的

00:11:15.519 --> 00:11:20.290
任何像杂项的东西，我

00:11:18.459 --> 00:11:21.940
知道我写了这个应用程序

00:11:20.290 --> 00:11:23.410
不应该访问一些文档错过但

00:11:21.940 --> 00:11:25.930
懒得弄清楚对不对

00:11:23.410 --> 00:11:27.670
这样做的方式是，所以我正在使用

00:11:25.930 --> 00:11:29.950
编码器，现在当然在Java 9下

00:11:27.670 --> 00:11:31.899
它无法编译，并且此修复时间

00:11:29.950 --> 00:11:33.970
实际上相当容易，因为有一个

00:11:31.899 --> 00:11:35.980
有一个简单的替代品，所以

00:11:33.970 --> 00:11:44.550
在这里而不是使用我的基本C 

00:11:35.980 --> 00:11:49.450
编码器，我使用base64非常64 Java util 

00:11:44.550 --> 00:11:50.740
得到编码器并编码两个字符串，所以我

00:11:49.450 --> 00:11:51.940
可以取代它，然后

00:11:50.740 --> 00:11:54.420
如果我建立，一切都会编译

00:11:51.940 --> 00:11:54.420
现在一切

00:11:58.899 --> 00:12:03.410
我的整个应用程序已编译

00:12:01.220 --> 00:12:05.480
成功，所以对我来说，这相当

00:12:03.410 --> 00:12:08.600
轻松转换此Java八

00:12:05.480 --> 00:12:10.370
应用程序以不使用Java 9 

00:12:08.600 --> 00:12:12.170
任何新功能都有一些

00:12:10.370 --> 00:12:14.959
问题，但没什么可

00:12:12.170 --> 00:12:19.670
表现一流，所以还不如我

00:12:14.959 --> 00:12:25.130
以为那是我该怎么办

00:12:19.670 --> 00:12:26.630
远程是谁，所以当我创建这个

00:12:25.130 --> 00:12:28.580
我实际上不想要的演示文稿

00:12:26.630 --> 00:12:29.870
完全谈论拼图，因为

00:12:28.580 --> 00:12:31.640
开始会有很多人

00:12:29.870 --> 00:12:33.680
做关于拼图的讨论

00:12:31.640 --> 00:12:36.980
是很多的重点

00:12:33.680 --> 00:12:38.240
 Java Nayan演示文稿，相当

00:12:36.980 --> 00:12:40.700
一个大话题，你不能只是

00:12:38.240 --> 00:12:43.490
提哦，顺便说一下，但它

00:12:40.700 --> 00:12:45.620
原来我最终和

00:12:43.490 --> 00:12:47.209
拼图还是想办法

00:12:45.620 --> 00:12:50.380
它会相当公平地寻找我

00:12:47.209 --> 00:12:53.480
小项目，也主要是因为

00:12:50.380 --> 00:12:56.570
 Gradle在Java 9上不起作用

00:12:53.480 --> 00:12:59.330
此刻，我在本周星期一听到我

00:12:56.570 --> 00:13:03.200
确实使其与Java 9一起使用

00:12:59.330 --> 00:13:04.670
一堆类似的编译器标志，我有

00:13:03.200 --> 00:13:05.930
在没有守护程序的情况下运行它，并且不得不

00:13:04.670 --> 00:13:07.640
我无法在命令行中运行它

00:13:05.930 --> 00:13:09.230
从IntelliJ内部运行它

00:13:07.640 --> 00:13:11.390
您可以做一些事情来获得Gradle 

00:13:09.230 --> 00:13:14.150
工作，但我无法完成我的项目

00:13:11.390 --> 00:13:16.400
与Gradle一起在IntelliJ中工作

00:13:14.150 --> 00:13:18.410
多模块项目和整个要点

00:13:16.400 --> 00:13:20.839
这是一个多模块项目吗

00:13:18.410 --> 00:13:23.000
你知道我想要Gradle工作

00:13:20.839 --> 00:13:25.070
但这也意味着我也许

00:13:23.000 --> 00:13:27.080
开始玩模块，所以我做了

00:13:25.070 --> 00:13:29.029
原来是这样的目录结构

00:13:27.080 --> 00:13:32.360
这是一个非常典型的Gradle类型

00:13:29.029 --> 00:13:34.220
我所拥有的目录结构

00:13:32.360 --> 00:13:36.020
真的很傻

00:13:34.220 --> 00:13:38.000
所以我有几个不同

00:13:36.020 --> 00:13:41.300
模块和模块有来源

00:13:38.000 --> 00:13:43.610
 Java的主要源代码在其中测试Java 

00:13:41.300 --> 00:13:46.430
相当典型的常规和Gradle 

00:13:43.610 --> 00:13:49.390
整理我最终做的事

00:13:46.430 --> 00:13:51.680
开始玩拼图游戏

00:13:49.390 --> 00:13:54.170
将我的项目的结构更改为

00:13:51.680 --> 00:13:56.270
更仔细地遵循建议

00:13:54.170 --> 00:13:58.279
在教程中，这意味着我

00:13:56.270 --> 00:14:00.230
有资料，然后我所有的人

00:13:58.279 --> 00:14:02.570
我的来源区域内的模块

00:14:00.230 --> 00:14:04.490
测试和我所有的个人模块

00:14:02.570 --> 00:14:06.110
我的测试目录是

00:14:04.490 --> 00:14:08.660
由内而外

00:14:06.110 --> 00:14:12.370
这反映了开放中的内容

00:14:08.660 --> 00:14:15.260
 JDK，所以我有点想遵循

00:14:12.370 --> 00:14:16.820
这是一件不平凡的事情

00:14:15.260 --> 00:14:19.190
重新整理整个内容，以便

00:14:16.820 --> 00:14:21.680
你可以放一些模块信息文件

00:14:19.190 --> 00:14:22.940
在您的模块内部，我已经知道了

00:14:21.680 --> 00:14:25.130
也可以使用Gradle结构

00:14:22.940 --> 00:14:26.810
所以这不是必须的部分，但是如果

00:14:25.130 --> 00:14:28.250
您将按照他们的教程进行操作

00:14:26.810 --> 00:14:29.660
看到一个目录结构是

00:14:28.250 --> 00:14:31.490
与您习惯的不同

00:14:29.660 --> 00:14:33.400
与那种古怪的方式不同

00:14:31.490 --> 00:14:35.900
做那些Gradle做事的方式

00:14:33.400 --> 00:14:37.610
在生产代码中，我添加了一个

00:14:35.900 --> 00:14:40.580
 Java魔咒内部的模块

00:14:37.610 --> 00:14:42.830
归档到我的各个模块中

00:14:40.580 --> 00:14:47.510
你会注意到我没有他们

00:14:42.830 --> 00:14:49.820
测试目录，这是一个务实的

00:14:47.510 --> 00:14:52.190
选择有人称它为务实

00:14:49.820 --> 00:14:54.470
选择让所有东西都在里面的选择

00:14:52.190 --> 00:14:56.090
 IntelliJ IDEA，因为您不能

00:14:54.470 --> 00:14:58.130
显然，您无法为

00:14:56.090 --> 00:15:00.350
相同的软件包名称（两个不同） 

00:14:58.130 --> 00:15:03.380
模块，所以我没有测试模块

00:15:00.350 --> 00:15:05.600
和生产模块，所以我知道

00:15:03.380 --> 00:15:07.160
有一种解决方法，可以使用拼图

00:15:05.600 --> 00:15:09.470
但我没有时间去做

00:15:07.160 --> 00:15:11.360
工作，所以我选择这是一个务实的

00:15:09.470 --> 00:15:12.890
演示的方法有

00:15:11.360 --> 00:15:14.660
的过程和权衡

00:15:12.890 --> 00:15:17.240
例如我只能运行测试

00:15:14.660 --> 00:15:19.610
从IDE内部也因为我不是

00:15:17.240 --> 00:15:21.530
不再使用Gradle我也可以管理我的

00:15:19.610 --> 00:15:23.660
从IDE内部的依赖关系，所以这

00:15:21.530 --> 00:15:26.660
并不是真正的生产评级系统

00:15:23.660 --> 00:15:28.460
就目前而言，但它做了什么

00:15:26.660 --> 00:15:31.580
找出我何时完成整个过程

00:15:28.460 --> 00:15:35.000
我的代码模块化是我的原始

00:15:31.580 --> 00:15:37.400
模块结构有点天真

00:15:35.000 --> 00:15:41.180
我们说，所以我有他们，我有两个

00:15:37.400 --> 00:15:43.250
后端服务和代码

00:15:41.180 --> 00:15:45.770
后端服务取决于代码

00:15:43.250 --> 00:15:47.510
现在我的Twitter服务没有

00:15:45.770 --> 00:15:48.800
我可以听的任何意义

00:15:47.510 --> 00:15:50.570
 Twitter服务，但我不应该

00:15:48.800 --> 00:15:53.540
取决于Twitter中的代码

00:15:50.570 --> 00:15:55.160
服务，所以通过看我的依赖

00:15:53.540 --> 00:15:57.290
通过将模块视为一个结构

00:15:55.160 --> 00:15:59.270
我意识到我是一流的公民

00:15:57.290 --> 00:16:02.360
模仿了我的模型修改

00:15:59.270 --> 00:16:04.040
错误地，我还注意到

00:16:02.360 --> 00:16:05.900
客户代码取决于网络

00:16:04.040 --> 00:16:06.950
套接字API，但没有别的是

00:16:05.900 --> 00:16:10.010
有点奇怪，因为它们都是

00:16:06.950 --> 00:16:13.190
使用WebSockets和我的反应堆流

00:16:10.010 --> 00:16:15.110
我的两个模块正在使用API 

00:16:13.190 --> 00:16:18.100
而不是全部或全部

00:16:15.110 --> 00:16:21.210
一个管理东西的API方面

00:16:18.100 --> 00:16:23.730
所以我有点吵

00:16:21.210 --> 00:16:25.770
只是感觉有点不对

00:16:23.730 --> 00:16:27.150
代码的组织方式

00:16:25.770 --> 00:16:29.130
当我在想我的

00:16:27.150 --> 00:16:30.540
模块真的是，以及如何

00:16:29.130 --> 00:16:32.390
封装代码我的

00:16:30.540 --> 00:16:35.070
依赖关系应该看起来像我

00:16:32.390 --> 00:16:36.990
重新安排了很多，所以现在我所有的

00:16:35.070 --> 00:16:38.550
服务在同一级别

00:16:36.990 --> 00:16:40.530
他们不依赖彼此的代码

00:16:38.550 --> 00:16:43.740
明智的做法会感觉更正确， 

00:16:40.530 --> 00:16:46.080
我有一个可重用的模块

00:16:43.740 --> 00:16:47.970
服务代码取决于

00:16:46.080 --> 00:16:49.560
所有有意义的服务-和

00:16:47.970 --> 00:16:51.240
这是唯一在乎的

00:16:49.560 --> 00:16:53.160
 WebSockets，因为这是

00:16:51.240 --> 00:16:55.050
隐藏了哪些实现

00:16:53.160 --> 00:16:58.440
恰好是实际的WebSockets 

00:16:55.050 --> 00:17:01.370
服务本身，我也有所有

00:16:58.440 --> 00:17:03.780
后端服务取决于我

00:17:01.370 --> 00:17:06.630
反应性流的辅助模块

00:17:03.780 --> 00:17:09.270
 API，所以很酷，因为它们都使用

00:17:06.630 --> 00:17:12.240
反应性流，然后我有两个

00:17:09.270 --> 00:17:16.290
通过选择使用rxjava的服务和

00:17:12.240 --> 00:17:17.370
一种使用反应堆的服务，因为我

00:17:16.290 --> 00:17:19.680
想表明你可以使用

00:17:17.370 --> 00:17:21.480
的不同实现

00:17:19.680 --> 00:17:24.510
我们将看的反应堆流API 

00:17:21.480 --> 00:17:26.580
后来，所以我对此更加满意

00:17:24.510 --> 00:17:27.990
模块结构以及通过思考

00:17:26.580 --> 00:17:29.550
模块化和对我的思考

00:17:27.990 --> 00:17:32.730
我想出了很多依赖

00:17:29.550 --> 00:17:36.300
更清洁的设计，适合我的应用

00:17:32.730 --> 00:17:38.310
让我们看看所涉及的

00:17:36.300 --> 00:17:40.320
创建模块信息文件

00:17:38.310 --> 00:17:41.580
这种方式是什么，我知道吗

00:17:40.320 --> 00:17:42.780
今天早上在他的演讲中谈到了这一点

00:17:41.580 --> 00:17:44.910
但我将从内部进行

00:17:42.780 --> 00:17:48.150
 IDE，因为这就是我们真正要做的

00:17:44.910 --> 00:17:49.710
在现实世界中，所有RIT都是

00:17:48.150 --> 00:17:51.990
对Mark的命令行印象深刻

00:17:49.710 --> 00:17:54.570
 foo我只是不那么酷

00:17:51.990 --> 00:17:56.840
好吧，让我们切换到右边

00:17:54.570 --> 00:17:56.840
科

00:18:15.460 --> 00:18:26.780
好吧，所以你可以在这里看到我有我的

00:18:18.020 --> 00:18:33.110
供应模块，我们把它放进去是因为

00:18:26.780 --> 00:18:36.170
他好一点了，我所拥有的是

00:18:33.110 --> 00:18:38.300
在我的大多数模块中，我都有模块

00:18:36.170 --> 00:18:42.230
信息文件，我有一个模块

00:18:38.300 --> 00:18:44.630
还没变成拼图

00:18:42.230 --> 00:18:49.810
模块，所以我需要做的是

00:18:44.630 --> 00:18:49.810
需要创建一个新的模块信息

00:18:50.710 --> 00:18:54.170
 IntelliJ对

00:18:52.940 --> 00:18:55.790
该模块的名称应为

00:18:54.170 --> 00:19:00.860
我想像你一样

00:18:55.790 --> 00:19:03.170
真的不能很好看，所以

00:19:00.860 --> 00:19:05.990
通过添加我的模块信息来做到这一点

00:19:03.170 --> 00:19:08.000
这个特定模块的Java和我

00:19:05.990 --> 00:19:10.100
开始神奇地使用诸如

00:19:08.000 --> 00:19:12.020
模块路径，我正在做的事情

00:19:10.100 --> 00:19:13.070
模块化的方式，而不是旧的方式

00:19:12.020 --> 00:19:15.200
这就是我们这样做的方式

00:19:13.070 --> 00:19:18.430
现在，所以现在当我编译它时

00:19:15.200 --> 00:19:18.430
应该会出现一些有趣的错误

00:19:25.150 --> 00:19:30.580
而我们所看到的是该模块内部

00:19:27.910 --> 00:19:32.680
现在的课程之一是

00:19:30.580 --> 00:19:35.200
之前还可以编译，它说

00:19:32.680 --> 00:19:38.190
模块敏感流没有

00:19:35.200 --> 00:19:40.240
模块Java登录要求

00:19:38.190 --> 00:19:42.970
显然是因为我正在使用IntelliJ 

00:19:40.240 --> 00:19:46.809
我使用Alt Enter神奇地修复了我的想法

00:19:42.970 --> 00:19:49.420
问题，我们看到的是模块信息

00:19:46.809 --> 00:19:51.910
现在我们需要Java点记录

00:19:49.420 --> 00:19:53.170
默认情况下它将是

00:19:51.910 --> 00:19:54.820
能够从Java点看到所有内容

00:19:53.170 --> 00:19:57.670
基本但不是所有其他模块

00:19:54.820 --> 00:19:59.110
在JDK中，因此您必须进入

00:19:57.670 --> 00:20:01.120
并声明您使用哪个模块

00:19:59.110 --> 00:20:03.580
需要使用，您可以通过

00:20:01.120 --> 00:20:06.340
自动修复东西，或者显然得到

00:20:03.580 --> 00:20:09.010
所有人都满意的代码完成

00:20:06.340 --> 00:20:11.140
您的Java模块对其进行了

00:20:09.010 --> 00:20:15.160
这没有错我们的下一个

00:20:11.140 --> 00:20:17.620
错误，所以我们在这里有一个类似的问题

00:20:15.160 --> 00:20:20.320
只是这不是来自JDK内部

00:20:17.620 --> 00:20:22.870
是外部和外部依赖

00:20:20.320 --> 00:20:27.400
在XML jar文件上，我需要添加

00:20:22.870 --> 00:20:29.679
库到集群的想法，然后我

00:20:27.400 --> 00:20:32.140
需要说添加需要反应点

00:20:29.679 --> 00:20:34.390
流到模块信息，因此执行相同操作

00:20:32.140 --> 00:20:36.100
我们现在有两种东西

00:20:34.390 --> 00:20:38.230
不同需要从内部

00:20:36.100 --> 00:20:40.050
 JDK和一种正在使用自动

00:20:38.230 --> 00:20:45.280
模块，因此它将使用

00:20:40.050 --> 00:20:47.020
外部的jar文件，然后那些

00:20:45.280 --> 00:20:49.260
错误消失了，我们的下一套是什么

00:20:47.020 --> 00:20:49.260
错误

00:20:52.140 --> 00:21:01.120
现在从外面从另一个模块

00:20:54.970 --> 00:21:03.550
我得到的错误是敏感流程没有

00:21:01.120 --> 00:21:06.370
将包从流中导出到

00:21:03.550 --> 00:21:07.720
模块传感器用户，所以现在这是

00:21:06.370 --> 00:21:10.120
抱怨一些人

00:21:07.720 --> 00:21:12.070
外部模块正在使用

00:21:10.120 --> 00:21:15.070
在此模块内部，因此该模块需要

00:21:12.070 --> 00:21:18.190
声明其他一些模块

00:21:15.070 --> 00:21:20.230
可以使用，所以我只是要导出我的

00:21:18.190 --> 00:21:27.070
包装在那里，然后一切都应该

00:21:20.230 --> 00:21:29.020
只是工作，所以很好， 

00:21:27.070 --> 00:21:31.450
一点点就可以了

00:21:29.020 --> 00:21:33.400
像这样的模块没有太多的事情

00:21:31.450 --> 00:21:35.560
里面有一个需求

00:21:33.400 --> 00:21:38.350
出口，这很容易做到

00:21:35.560 --> 00:21:38.830
通过解决每个错误来解决

00:21:38.350 --> 00:21:41.260
错误

00:21:38.830 --> 00:21:43.570
我将向您展示其他模块

00:21:41.260 --> 00:21:45.790
花费了我更多时间的信息

00:21:43.570 --> 00:21:47.890
所以这是UI，您可以看到

00:21:45.790 --> 00:21:49.360
我需要一堆Java效果

00:21:47.890 --> 00:21:53.080
模块和Java 

00:21:49.360 --> 00:21:56.650
日志记录，我也使用JavaFX 

00:21:53.080 --> 00:21:58.930
反思，所以我不得不打开我的漂亮

00:21:56.650 --> 00:22:01.240
我的所有代码都对Java有影响

00:21:58.930 --> 00:22:03.550
反思现在我明确决定

00:22:01.240 --> 00:22:05.410
只需将其打开以使用Java效果，我

00:22:03.550 --> 00:22:09.130
想要向所有人开放

00:22:05.410 --> 00:22:11.230
访问我，我也必须导出

00:22:09.130 --> 00:22:13.300
这些很有趣

00:22:11.230 --> 00:22:14.800
当时我是作为错误出现的

00:22:13.300 --> 00:22:16.870
编译，而我正在运行的东西

00:22:14.800 --> 00:22:18.940
所以我有点像在偷东西

00:22:16.870 --> 00:22:21.370
尝试使其工作，它变成

00:22:18.940 --> 00:22:23.920
当我向某人展示这个

00:22:21.370 --> 00:22:25.330
从Oracle内部，我不必

00:22:23.920 --> 00:22:26.980
这样做，实际上出现了一个错误

00:22:25.330 --> 00:22:28.960
在JDK中如何进行

00:22:26.980 --> 00:22:32.110
解决这个问题，这就是

00:22:28.960 --> 00:22:35.710
如果X恰好反映了Java 

00:22:32.110 --> 00:22:38.310
在您的代码上，但这就是魔术

00:22:35.710 --> 00:22:42.450
我需要的咒语，所有的作品

00:22:38.310 --> 00:22:44.950
另一个，让我们看看服务

00:22:42.450 --> 00:22:47.620
这个用了一堆东西

00:22:44.950 --> 00:22:50.440
从外部的jar文件中，所以很多

00:22:47.620 --> 00:22:52.510
是自动模块，我发现了这个

00:22:50.440 --> 00:22:54.640
通过反复试验的蛮力，因为

00:22:52.510 --> 00:22:56.260
我很固执，但我建议您使用

00:22:54.640 --> 00:22:58.750
您阅读了有关

00:22:56.260 --> 00:23:00.970
 Jade X 2土地使用舱口盖，因为它需要

00:22:58.750 --> 00:23:02.290
比重新启动您的时间更少的时间

00:23:00.970 --> 00:23:04.810
一直在申请和确定

00:23:02.290 --> 00:23:10.960
找出这些错误是什么意思，是的

00:23:04.810 --> 00:23:13.150
请务必阅读手册，它非常有用，因此

00:23:10.960 --> 00:23:15.400
那就是我要做的

00:23:13.150 --> 00:23:17.620
有点让我的申请变得更多

00:23:15.400 --> 00:23:18.730
模块化，这不是一个小小的教育

00:23:17.620 --> 00:23:21.340
像这个庞大的企业

00:23:18.730 --> 00:23:24.040
申请花了我大约一天的时间

00:23:21.340 --> 00:23:28.300
一天半的时间使所有运行

00:23:24.040 --> 00:23:29.890
而努力，我发现的痛苦是

00:23:28.300 --> 00:23:31.660
主要是我更大

00:23:29.890 --> 00:23:32.950
不起作用，我花了另一天时间

00:23:31.660 --> 00:23:34.750
一周尝试让Gradle工作

00:23:32.950 --> 00:23:36.430
 great不适用于Java 9 

00:23:34.750 --> 00:23:38.650
我不确定行家的状态

00:23:36.430 --> 00:23:40.990
我认为在某些情况下

00:23:38.650 --> 00:23:42.790
我认为Gradle的工作原理是

00:23:40.990 --> 00:23:44.650
您没有多模块项目

00:23:42.790 --> 00:23:48.190
但是我们很多人正在与

00:23:44.650 --> 00:23:49.630
多模块项目，如果您决定

00:23:48.190 --> 00:23:51.700
重新整理文件结构

00:23:49.630 --> 00:23:53.970
我不推荐一项非平凡的任务

00:23:51.700 --> 00:23:57.130
除非您绝对必须这样做

00:23:53.970 --> 00:23:59.230
当然我有这个方法

00:23:57.130 --> 00:24:00.790
工作没有命令行构建

00:23:59.230 --> 00:24:02.470
为此，无法运行

00:24:00.790 --> 00:24:04.060
在CI环境中测试或

00:24:02.470 --> 00:24:07.360
类似的东西

00:24:04.060 --> 00:24:09.040
麻烦的是那里有IDE支持

00:24:07.360 --> 00:24:10.810
对拼图之类的东西的支持

00:24:09.040 --> 00:24:12.790
就这样，我有一些自动完成

00:24:10.810 --> 00:24:14.800
我有一些快速修复方法

00:24:12.790 --> 00:24:17.230
从IDE那里帮忙，但我没有

00:24:14.800 --> 00:24:20.200
像魔术一样为我生成了我的模块信息

00:24:17.230 --> 00:24:21.520
键入按钮，我没有一些

00:24:20.200 --> 00:24:22.840
其他可能使我的生活变得美好的事物

00:24:21.520 --> 00:24:25.540
一点点容易，我就不快

00:24:22.840 --> 00:24:29.380
修复了所有问题，因此我们正在努力

00:24:25.540 --> 00:24:31.840
在那之上，但是我们需要什么

00:24:29.380 --> 00:24:34.510
 JetBrains IntelliJ IDEA方面是

00:24:31.840 --> 00:24:36.130
如果您发现使用Java 9感到痛苦

00:24:34.510 --> 00:24:37.900
 IntelliJ IDEA我们需要您报告

00:24:36.130 --> 00:24:40.660
给我们，以便我们可以基本上解决它

00:24:37.900 --> 00:24:43.390
如果你要去做功课

00:24:40.660 --> 00:24:45.100
为此特别是拼图做一个

00:24:43.390 --> 00:24:47.140
很多阅读都弄清楚了工具是如何

00:24:45.100 --> 00:24:48.760
弄清楚这些东西是如何工作的

00:24:47.140 --> 00:24:51.460
在跳入命令行之前

00:24:48.760 --> 00:24:52.690
 IDE，因为否则您不是真的

00:24:51.460 --> 00:24:55.470
了解下面发生了什么

00:24:52.690 --> 00:24:57.310
封面，这可能会很痛苦

00:24:55.470 --> 00:24:59.530
对，我想继续谈论

00:24:57.310 --> 00:25:01.300
反应性API，因为整个讨论

00:24:59.530 --> 00:25:03.460
本来是关于rah反应的

00:25:01.300 --> 00:25:07.140
很好，这是Java的OD反应性

00:25:03.460 --> 00:25:11.650
 9存在一个反应​​流API 

00:25:07.140 --> 00:25:14.080
目前在导演流1.0中

00:25:11.650 --> 00:25:15.760
定义排序所需的一切

00:25:14.080 --> 00:25:16.770
两个不同反应堆之间的API的数量

00:25:15.760 --> 00:25:19.200
程式库

00:25:16.770 --> 00:25:21.270
所以显然你有一个出版商

00:25:19.200 --> 00:25:23.280
订户，我不想说太多

00:25:21.270 --> 00:25:24.690
关于什么是真正反应的流或

00:25:23.280 --> 00:25:25.320
异步编程或其他任何东西

00:25:24.690 --> 00:25:26.820
像那样

00:25:25.320 --> 00:25:28.550
我只是想略过

00:25:26.820 --> 00:25:32.910
并向您展示其工作原理

00:25:28.550 --> 00:25:34.590
真的很生气

00:25:32.910 --> 00:25:36.630
流API我们有一个发布者

00:25:34.590 --> 00:25:37.920
一个订户，我们有一个处理器

00:25:36.630 --> 00:25:40.290
结合发布者和订阅者

00:25:37.920 --> 00:25:41.880
和订阅有什么帮助

00:25:40.290 --> 00:25:43.790
您来管理之间的关系

00:25:41.880 --> 00:25:45.600
发布者和订阅者

00:25:43.790 --> 00:25:47.670
反应流的实现

00:25:45.600 --> 00:25:50.670
包括回声流反应器之类的东西

00:25:47.670 --> 00:25:52.950
 rx Java顶点如此受欢迎

00:25:50.670 --> 00:25:55.920
用于进行反应式编程的库

00:25:52.950 --> 00:25:57.929
实际上在Java和其他jvm语言中

00:25:55.920 --> 00:26:00.570
不只是他们的JVM语言

00:25:57.929 --> 00:26:02.010
实现此API，所以非常不错

00:26:00.570 --> 00:26:03.540
他们可以互相交谈而无需

00:26:02.010 --> 00:26:05.280
真正关心自己

00:26:03.540 --> 00:26:08.070
他们正在谈论的实现

00:26:05.280 --> 00:26:11.340
相同的API，因此在Java中

00:26:08.070 --> 00:26:13.679
 9我们有三个活动流API 

00:26:11.340 --> 00:26:15.120
内置在图书馆里，我认为这

00:26:13.679 --> 00:26:16.800
我认为这是一件非常积极的事情

00:26:15.120 --> 00:26:18.660
我认为反应性流很棒， 

00:26:16.800 --> 00:26:20.790
反应式编程是一个很好的模型

00:26:18.660 --> 00:26:22.500
遵循，这是一个很好的方法

00:26:20.790 --> 00:26:25.530
异步编程不是

00:26:22.500 --> 00:26:27.270
与其他模型和事实一样复杂

00:26:25.530 --> 00:26:28.620
这是Java 9 I的一部分

00:26:27.270 --> 00:26:30.600
认为意味着我们有点

00:26:28.620 --> 00:26:33.570
作为一个Java社区来接受它

00:26:30.600 --> 00:26:36.210
工作方式之一，这样

00:26:33.570 --> 00:26:39.090
很棒，唯一的缺点是

00:26:36.210 --> 00:26:42.270
当然反应堆流的API是

00:26:39.090 --> 00:26:44.280
实际上与Java 9 API不同

00:26:42.270 --> 00:26:45.480
 API本身不是接口

00:26:44.280 --> 00:26:46.679
方法被称为同一件事

00:26:45.480 --> 00:26:48.300
他们称相同的东西

00:26:46.679 --> 00:26:50.250
签名，但它们位于不同的位置

00:26:48.300 --> 00:26:53.160
包装，所以目前他们还没有

00:26:50.250 --> 00:26:55.350
真正可重用，所以如果我使用rx Java 

00:26:53.160 --> 00:26:57.090
我正在找一个出版商

00:26:55.350 --> 00:26:59.040
我是一个组织反应式流发布者

00:26:57.090 --> 00:27:01.650
没有得到Java util并发流

00:26:59.040 --> 00:27:02.880
发布者，所以我为此

00:27:01.650 --> 00:27:04.679
示范我实际上写了一个

00:27:02.880 --> 00:27:06.750
适配器只是为了包装那些东西， 

00:27:04.679 --> 00:27:07.740
将它们从一个转换为另一个

00:27:06.750 --> 00:27:10.590
这是我认为的一件事

00:27:07.740 --> 00:27:12.480
很有趣，因为

00:27:10.590 --> 00:27:14.429
目前的图书馆将

00:27:12.480 --> 00:27:16.350
使用反应堆流API而不是

00:27:14.429 --> 00:27:20.280
 Java 9 API显然是因为它们不是

00:27:16.350 --> 00:27:22.230
针对Java 9进行编译，因此当您

00:27:20.280 --> 00:27:26.100
想要使用类似反应式的东西

00:27:22.230 --> 00:27:29.010
我在应用程序中设计了API 

00:27:26.100 --> 00:27:30.450
是事件驱动的，所以看起来

00:27:29.010 --> 00:27:34.410
非常适合

00:27:30.450 --> 00:27:36.750
或指令API II确实很愚蠢

00:27:34.410 --> 00:27:38.490
他们使用WebSockets的服务

00:27:36.750 --> 00:27:40.350
从WebSocket上串出一个字符串

00:27:38.490 --> 00:27:42.480
到WebSocket上，然后我有

00:27:40.350 --> 00:27:44.850
显然这是一些业务逻辑

00:27:42.480 --> 00:27:49.080
基本上是架构图

00:27:44.850 --> 00:27:50.970
永远为每个人的应用

00:27:49.080 --> 00:27:52.770
我有一些非常简单的业务逻辑

00:27:50.970 --> 00:27:53.700
因为出于多种原因之一

00:27:52.770 --> 00:27:56.130
需要平易近人

00:27:53.700 --> 00:27:58.440
可以理解的演示2我需要

00:27:56.130 --> 00:28:00.540
演示Java 8功能

00:27:58.440 --> 00:28:02.880
业务逻辑通常来说是

00:28:00.540 --> 00:28:05.430
映射字符串的lambda表达式

00:28:02.880 --> 00:28:07.260
从一个值到另一个值

00:28:05.430 --> 00:28:09.420
整个用户服务

00:28:07.260 --> 00:28:13.140
推文的JSON表示形式和

00:28:09.420 --> 00:28:15.120
返回一个用户名，例如，所以

00:28:13.140 --> 00:28:16.800
看起来您通过了

00:28:15.120 --> 00:28:18.620
签名是我要带一个

00:28:16.800 --> 00:28:22.020
功能是我的业务逻辑， 

00:28:18.620 --> 00:28:23.340
我利用我传递的优势

00:28:22.020 --> 00:28:25.320
 Lambda表达式或方法

00:28:23.340 --> 00:28:27.390
代表业务的参考

00:28:25.320 --> 00:28:30.780
我服务的逻辑

00:28:27.390 --> 00:28:33.360
所以给你我所说的服务

00:28:30.780 --> 00:28:35.070
故意很愚蠢，但我可以

00:28:33.360 --> 00:28:37.230
使他们变得更聪明

00:28:35.070 --> 00:28:39.450
公开反应堆流API 

00:28:37.230 --> 00:28:41.640
所以我想的是

00:28:39.450 --> 00:28:44.220
实际上是从业务逻辑的角度

00:28:41.640 --> 00:28:47.040
我可能正在听或订阅

00:28:44.220 --> 00:28:50.370
给要给我的出版商

00:28:47.040 --> 00:28:52.650
信息流，我可以成为

00:28:50.370 --> 00:28:54.360
将那些消息发送到

00:28:52.650 --> 00:28:56.550
使我订阅的东西

00:28:54.360 --> 00:28:58.710
订户，所以我要更改

00:28:56.550 --> 00:29:00.870
整体服务的形状，这样我

00:28:58.710 --> 00:29:02.790
拥有一个发布字符串的发布者

00:29:00.870 --> 00:29:05.460
就我而言，还有一个订户

00:29:02.790 --> 00:29:08.820
聆听的结果

00:29:05.460 --> 00:29:11.810
业务逻辑，所以是的，让我们来

00:29:08.820 --> 00:29:11.810
快速浏览一下外观

00:29:31.990 --> 00:29:38.500
所以在这种情况下，让我们回到

00:29:34.270 --> 00:29:40.570
在我的情况下，发布者是一个

00:29:38.500 --> 00:29:41.980
该类称为客户端端点，因为

00:29:40.570 --> 00:29:44.770
它的作用是听

00:29:41.980 --> 00:29:47.980
 WebSockets，然后发布一些

00:29:44.770 --> 00:29:50.440
字符串值，那就是

00:29:47.980 --> 00:29:52.240
客户端点，所以我需要做的是

00:29:50.440 --> 00:29:55.180
我只是让客户端端点实现

00:29:52.240 --> 00:29:57.370
浮动发布者，然后它需要什么

00:29:55.180 --> 00:29:59.860
实现浮动发布程序后要做的事情

00:29:57.370 --> 00:30:02.260
您需要实施订阅， 

00:29:59.860 --> 00:30:04.090
 SUBSCRIBE方法需要一个订户并

00:30:02.260 --> 00:30:06.220
那么你将要做的是

00:30:04.090 --> 00:30:07.780
我关心的发布者是谁

00:30:06.220 --> 00:30:10.180
订阅我，然后我会做

00:30:07.780 --> 00:30:12.340
与那些订户一起的东西

00:30:10.180 --> 00:30:13.840
以后我需要的时候，我只是

00:30:12.340 --> 00:30:17.440
将通过以下方式管理这些订阅

00:30:13.840 --> 00:30:20.830
通过将它们保存在列表中来实现它们，因此Java 9 

00:30:17.440 --> 00:30:23.380
提供反应式的接口

00:30:20.830 --> 00:30:25.480
无需实现的流API 

00:30:23.380 --> 00:30:27.100
他们与您自己的实现

00:30:25.480 --> 00:30:29.350
想法是，您将使用

00:30:27.100 --> 00:30:31.540
像rx Java或Reactor这样的实现

00:30:29.350 --> 00:30:33.340
或类似的东西，但对于这种情况

00:30:31.540 --> 00:30:35.830
我的服务，因为它们非常非常

00:30:33.340 --> 00:30:37.960
愚蠢的我实际上决定实施

00:30:35.830 --> 00:30:39.160
我自己的出版商，那就是

00:30:37.960 --> 00:30:41.230
我在这里所做的选择，但不是

00:30:39.160 --> 00:30:43.930
一定不是我

00:30:41.230 --> 00:30:45.100
会建议，因为有

00:30:43.930 --> 00:30:46.270
可以完成所有这些工作的大量框架

00:30:45.100 --> 00:30:48.400
东西，但我要自己管理

00:30:46.270 --> 00:30:51.310
从这个角度来看

00:30:48.400 --> 00:30:54.550
另一端是我的订户

00:30:51.310 --> 00:30:57.160
是称为广播服务器的类

00:30:54.550 --> 00:30:58.420
端点，它是做什么的

00:30:57.160 --> 00:31:01.090
侦听业务逻辑中的内容

00:30:58.420 --> 00:31:04.270
然后使用WebSockets将其发送到

00:31:01.090 --> 00:31:08.850
谁在乎，所以我又得到了什么

00:31:04.270 --> 00:31:13.330
我正在实施订户，并且

00:31:08.850 --> 00:31:15.010
订户已取消订阅

00:31:13.330 --> 00:31:16.900
接下来是有趣的事情

00:31:15.010 --> 00:31:21.100
就像当我得到一个

00:31:16.900 --> 00:31:22.240
事件发生在错误和完成时， 

00:31:21.100 --> 00:31:25.840
是我必须执行的事情

00:31:22.240 --> 00:31:27.190
在我的课上，所以订阅“我就是

00:31:25.840 --> 00:31:28.660
我要说的就是给我

00:31:27.190 --> 00:31:30.250
结束时得到的一切

00:31:28.660 --> 00:31:31.810
时间，如果你想做的话

00:31:30.250 --> 00:31:33.760
你说我只想看第一个

00:31:31.810 --> 00:31:35.080
三个消息，但就我而言，我只是

00:31:33.760 --> 00:31:38.710
总是听什么

00:31:35.080 --> 00:31:41.350
业务逻辑让我知道接下来的事情

00:31:38.710 --> 00:31:43.090
我需要做的是我需要听所有

00:31:41.350 --> 00:31:44.509
所有会话的会话

00:31:43.090 --> 00:31:49.339
在听我说

00:31:44.509 --> 00:31:53.119
向他们发送错误消息

00:31:49.339 --> 00:31:55.129
建议您不要执行此错误

00:31:53.119 --> 00:31:58.279
异步系统中的处理是

00:31:55.129 --> 00:32:00.019
非常有趣的情况，我做了一个

00:31:58.279 --> 00:32:02.599
就以下方面而言，许多简单的错误处理

00:32:00.019 --> 00:32:05.359
忘记了演示工作，我做了很多

00:32:02.599 --> 00:32:07.999
像print stacktrace之类的东西

00:32:05.359 --> 00:32:10.190
并且不要吞下错误

00:32:07.999 --> 00:32:12.320
异步系统，因为事情会

00:32:10.190 --> 00:32:13.429
只是不工作，你将不知道

00:32:12.320 --> 00:32:15.289
该怎么办

00:32:13.429 --> 00:32:17.119
错误处理是一流的公民

00:32:15.289 --> 00:32:18.649
异步系统，这真的

00:32:17.119 --> 00:32:21.499
了解如何处理很重要

00:32:18.649 --> 00:32:23.059
他们，所以不要那样做，然后再做

00:32:21.499 --> 00:32:24.979
东西完成了，所以我需要关闭

00:32:23.059 --> 00:32:28.759
我的WebSocket不再存在时

00:32:24.979 --> 00:32:30.619
消息，所以这是相当

00:32:28.759 --> 00:32:33.229
对我来说，直接使用

00:32:30.619 --> 00:32:35.389
反应流API提供简单

00:32:33.229 --> 00:32:37.309
适用于任何需要的API 

00:32:35.389 --> 00:32:40.489
基本上创建了一个新的

00:32:37.309 --> 00:32:42.649
服务，这意味着什么

00:32:40.489 --> 00:32:46.369
我要使用这个API是什么

00:32:42.649 --> 00:32:47.599
具有反应性API的观点

00:32:46.369 --> 00:32:49.429
我要看的第一件事是

00:32:47.599 --> 00:32:52.190
我要看一下我的推特服务

00:32:49.429 --> 00:32:54.529
我现在如何利用反应式

00:32:52.190 --> 00:32:57.699
我的推文中的编程框架

00:32:54.529 --> 00:32:57.699
服务如何改变事情

00:33:02.210 --> 00:33:06.630
所以我以前提到的

00:33:04.950 --> 00:33:09.780
这几次是，这是

00:33:06.630 --> 00:33:11.550
目的是演示着陆器并进行流式传输

00:33:09.780 --> 00:33:14.760
我以前有过我真的很好

00:33:11.550 --> 00:33:17.670
 Java 8的功能为什么我使用文件行

00:33:14.760 --> 00:33:20.820
为每个人获取一串字符串

00:33:17.670 --> 00:33:22.650
文件中的一行，我将返回一个字符串

00:33:20.820 --> 00:33:24.180
在流中，然后我可以做点什么

00:33:22.650 --> 00:33:26.880
有了它，所以我在读

00:33:24.180 --> 00:33:28.770
我正在阅读推文文件，然后

00:33:26.880 --> 00:33:30.630
每行我都略去了

00:33:28.770 --> 00:33:33.030
对那些在乎我的人

00:33:30.630 --> 00:33:34.290
过滤掉此文件中的一些噪音，然后

00:33:33.030 --> 00:33:36.840
然后我要做的另一件事是

00:33:34.290 --> 00:33:38.910
该演示的目的是我插入一个

00:33:36.840 --> 00:33:40.290
 100毫秒的延迟，以便您可以

00:33:38.910 --> 00:33:42.630
在界面上看到有趣的东西

00:33:40.290 --> 00:33:44.370
再次不要在生产中这样做，但是

00:33:42.630 --> 00:33:46.320
从我的演示角度来看

00:33:44.370 --> 00:33:47.640
应用程序，这实际上是我的一部分

00:33:46.320 --> 00:33:49.440
您需要的业务需求

00:33:47.640 --> 00:33:52.320
看到推文在

00:33:49.440 --> 00:33:55.380
定期间隔，让我们重写一下

00:33:52.320 --> 00:33:58.830
使用反应堆流，因为我们可以

00:33:55.380 --> 00:34:04.260
我将为此使用Rx Java 

00:33:58.830 --> 00:34:06.840
专辑，所以我需要添加rx Java 

00:34:04.260 --> 00:34:10.110
添加需要rx Java到我的模块信息

00:34:06.840 --> 00:34:21.419
因为我们时不时是Java 9 

00:34:10.110 --> 00:34:24.450
从可怜我要说

00:34:21.419 --> 00:34:27.720
充分利用好文件

00:34:24.450 --> 00:34:29.190
 Java 8中的行功能，但我确实得到了

00:34:27.720 --> 00:34:31.440
有机会做类似的事情

00:34:29.190 --> 00:34:34.860
然后我基本上可以解除

00:34:31.440 --> 00:34:38.010
从这里添加相同的功能

00:34:34.860 --> 00:34:39.149
进入我的反应流

00:34:38.010 --> 00:34:41.460
区别在于没有这么乱

00:34:39.149 --> 00:34:43.409
偷看它，所以我使用了一种称为

00:34:41.460 --> 00:34:46.350
下段基本上做的准确

00:34:43.409 --> 00:34:49.470
同样的事情，所以我可以使用反应

00:34:46.350 --> 00:34:52.440
流做我曾经做过的同样的事情

00:34:49.470 --> 00:34:56.850
使用Java 8流，我们将

00:34:52.440 --> 00:34:58.110
稍后再讨论这个智慧

00:34:56.850 --> 00:35:01.320
您可以看到它看起来或多或少

00:34:58.110 --> 00:35:04.070
同样，我可以删除所有这些

00:35:01.320 --> 00:35:04.070
开始我的服务

00:35:12.940 --> 00:35:16.210
一切都以相同的方式

00:35:14.710 --> 00:35:17.680
习惯这不是一个很大的惊喜

00:35:16.210 --> 00:35:19.660
因为代码看起来几乎完全一样

00:35:17.680 --> 00:35:22.119
一样，所以您可能会想

00:35:19.660 --> 00:35:24.700
你自己那是什么意思

00:35:22.119 --> 00:35:27.160
现在我基本上已经添加了另一个

00:35:24.700 --> 00:35:28.599
外部库外部依赖

00:35:27.160 --> 00:35:30.880
做和我完全一样的事情

00:35:28.599 --> 00:35:33.670
之前，我有一点点

00:35:30.880 --> 00:35:35.260
很好地创建我的流的丑陋方法

00:35:33.670 --> 00:35:36.789
对信息流做出反应会给您很多

00:35:35.260 --> 00:35:39.430
 Java 8所没有的功能

00:35:36.789 --> 00:35:41.170
流，例如这个东西总是

00:35:39.430 --> 00:35:43.410
这个想法让我非常不舒服

00:35:41.170 --> 00:35:45.579
就像在100毫秒的暂停中推

00:35:43.410 --> 00:35:47.289
特别是使用偷看方法，因为

00:35:45.579 --> 00:35:49.089
窥视通常只是一种调试

00:35:47.289 --> 00:35:51.579
允许您对某事做某事的方法

00:35:49.089 --> 00:35:53.650
通过的任何很多东西

00:35:51.579 --> 00:35:54.250
流，所以感觉有点像

00:35:53.650 --> 00:35:58.059
骇客

00:35:54.250 --> 00:36:00.539
我正在使用反应性流

00:35:58.059 --> 00:36:04.690
像你可以创建一个流动的东西

00:36:00.539 --> 00:36:07.480
间隔一段时间，以便我可以创建一个

00:36:04.690 --> 00:36:10.240
间隔为100 

00:36:07.480 --> 00:36:13.210
毫秒，这是要做的

00:36:10.240 --> 00:36:15.280
让我们称这为滴答

00:36:13.210 --> 00:36:17.500
每100毫秒发出一个长值

00:36:15.280 --> 00:36:19.779
这将每100个接管一次

00:36:17.500 --> 00:36:22.359
毫秒，这非常好， 

00:36:19.779 --> 00:36:25.660
那我能做的就是合并

00:36:22.359 --> 00:36:28.510
与我的流或与我的反应

00:36:25.660 --> 00:36:30.549
流以读取文件，这样我就可以

00:36:28.510 --> 00:36:34.539
可以将这两件事拉在一起

00:36:30.549 --> 00:36:37.059
我可以强迫阅读

00:36:34.539 --> 00:36:39.069
从文件中获取所有内容

00:36:37.059 --> 00:36:43.329
 100毫秒，这相当容易

00:36:39.069 --> 00:36:46.779
我只需要说zip wiz给它

00:36:43.329 --> 00:36:48.490
勾选，然后我必须告诉它

00:36:46.779 --> 00:36:50.770
我现在有两个值

00:36:48.490 --> 00:36:53.619
滴答流的价值，我有一个

00:36:50.770 --> 00:36:55.089
我的文件读取流中的字符串值

00:36:53.619 --> 00:36:56.500
但我不在乎长期价值

00:36:55.089 --> 00:36:58.839
因为它只是一个占位符

00:36:56.500 --> 00:37:01.900
接管，所以我要

00:36:58.839 --> 00:37:06.730
省略字符串值，然后这样

00:37:01.900 --> 00:37:08.440
我会重新使用

00:37:06.730 --> 00:37:10.420
反应堆流的这一特征

00:37:08.440 --> 00:37:13.150
是真正在两个方面工作的能力

00:37:10.420 --> 00:37:14.859
流并将其合并在一起以给出

00:37:13.150 --> 00:37:16.630
我做同样的事情

00:37:14.859 --> 00:37:18.130
和以前一样，但我认为确实是

00:37:16.630 --> 00:37:20.260
一个很好的优雅的解决方案来证明

00:37:18.130 --> 00:37:22.390
这注定要发生，这意味着

00:37:20.260 --> 00:37:25.980
花费每一百毫秒

00:37:22.390 --> 00:37:28.180
而不是使用稍微有点怪异的方法

00:37:25.980 --> 00:37:29.650
这就是反应堆梦想的特征

00:37:28.180 --> 00:37:32.920
 Java 8流不具备

00:37:29.650 --> 00:37:34.510
例如，好吧，我们还能做什么

00:37:32.920 --> 00:37:36.579
我想知道用户服务，因为它

00:37:34.510 --> 00:37:39.460
心情服务不是很有趣

00:37:36.579 --> 00:37:43.390
让我们看看心情服务13 

00:37:39.460 --> 00:37:45.539
还剩几分钟，让我们快速看一下

00:37:43.390 --> 00:37:48.309
情绪服务

00:37:45.539 --> 00:37:51.940
所以这是我对服务所做的

00:37:48.309 --> 00:37:53.740
如你所见，我是一位出版商

00:37:51.940 --> 00:37:55.539
和订户任何东西是

00:37:53.740 --> 00:37:56.799
要使用这些服务，然后我

00:37:55.539 --> 00:37:59.680
只是必须告诉它如何处理

00:37:56.799 --> 00:38:10.930
这些东西，所以说我想得到

00:37:59.680 --> 00:38:13.329
我与发布商订阅者的心情

00:38:10.930 --> 00:38:14.260
打算用电抗器来展示

00:38:13.329 --> 00:38:17.619
你可以使用不同的

00:38:14.260 --> 00:38:21.609
向量流的实现

00:38:17.619 --> 00:38:28.630
流动中的面试我有助焊剂

00:38:21.609 --> 00:38:30.400
现在我要从发布商那里得到一个

00:38:28.630 --> 00:38:32.230
错误在这里，因为来自发布者是

00:38:30.400 --> 00:38:34.720
期待一个被动的流发布者

00:38:32.230 --> 00:38:40.480
我肯定要通过它一张流程图

00:38:34.720 --> 00:38:41.650
所以我有一个适配器来做到这一点

00:38:40.480 --> 00:38:43.539
那虽然我只是要包装

00:38:41.650 --> 00:38:46.210
它放在我的适配器中，然后我可以

00:38:43.539 --> 00:38:48.250
我基本上是在做同样的事情

00:38:46.210 --> 00:38:52.059
我正在做的Java 8流

00:38:48.250 --> 00:38:53.799
它与残骸流平的地图

00:38:52.059 --> 00:38:58.599
当然不同，因为我不能接受

00:38:53.799 --> 00:39:02.049
流，我必须从

00:38:58.599 --> 00:39:04.390
数组，然后一切正常

00:39:02.049 --> 00:39:06.220
与之前一样

00:39:04.390 --> 00:39:08.500
有点问题是什么

00:39:06.220 --> 00:39:09.309
点好点，实际上是什么时候哦

00:39:08.500 --> 00:39:14.020
是的，我需要

00:39:09.309 --> 00:39:16.569
我无法收集，因为我很惊讶

00:39:14.020 --> 00:39:19.809
我无法收集的编译内容

00:39:16.569 --> 00:39:20.920
订阅我要把

00:39:19.809 --> 00:39:24.760
订户到最后

00:39:20.920 --> 00:39:27.420
听也需要

00:39:24.760 --> 00:39:30.539
包裹在适配器内

00:39:27.420 --> 00:39:30.539
 [音乐] 

00:39:30.660 --> 00:39:35.020
所以再次看起来与

00:39:33.579 --> 00:39:36.880
 Java 8流有什么意义

00:39:35.020 --> 00:39:39.790
关键是实际上如果我运行

00:39:36.880 --> 00:39:42.730
它不起作用什么都没发生，他停了下来

00:39:39.790 --> 00:39:44.619
这是一个谜

00:39:42.730 --> 00:39:46.570
特别是当我覆盖了我所有的

00:39:44.619 --> 00:39:49.720
错误处理，我将在

00:39:46.570 --> 00:39:51.460
这一点，事实证明， 

00:39:49.720 --> 00:39:53.140
反应堆物流完全是

00:39:51.460 --> 00:39:54.550
他们完全可以工作的不同模式

00:39:53.140 --> 00:39:56.290
他们的工作方式不同

00:39:54.550 --> 00:39:58.810
在无限流上，它们旨在

00:39:56.290 --> 00:40:03.130
结合设备设计

00:39:58.810 --> 00:40:05.020
应该分裂，他们有

00:40:03.130 --> 00:40:07.060
背压的想法

00:40:05.020 --> 00:40:09.339
重要的头等公民

00:40:07.060 --> 00:40:11.500
如果您的发布商背压

00:40:09.339 --> 00:40:14.410
超过您的消费者，您必须

00:40:11.500 --> 00:40:15.400
明确告诉系统该怎么做

00:40:14.410 --> 00:40:17.079
关于那你要放弃

00:40:15.400 --> 00:40:18.609
地板上的消息你要去吗

00:40:17.079 --> 00:40:20.950
施加反压力并用力

00:40:18.609 --> 00:40:22.780
制片人出版商放慢脚步

00:40:20.950 --> 00:40:24.520
您必须了解

00:40:22.780 --> 00:40:27.130
信息通过您的系统起作用

00:40:24.520 --> 00:40:29.349
而且，如果你不做，事情就会倒下

00:40:27.130 --> 00:40:30.970
在这种特殊情况下，它变成

00:40:29.349 --> 00:40:32.859
平面图产生了一个整体

00:40:30.970 --> 00:40:34.569
一堆不同的线程来处理

00:40:32.859 --> 00:40:35.980
平面地图现在这在Java中不会发生

00:40:34.569 --> 00:40:37.720
八弦，因为如果你不

00:40:35.980 --> 00:40:39.849
并行它只是说了一切

00:40:37.720 --> 00:40:42.040
在单个操作中作为阻塞

00:40:39.849 --> 00:40:43.359
单线程操作，这是一个

00:40:42.040 --> 00:40:45.160
完全不同的模型

00:40:43.359 --> 00:40:47.050
反应流的东西，所以我不得不把

00:40:45.160 --> 00:40:48.910
用魔咒说只能跑

00:40:47.050 --> 00:40:50.829
一个线程，然后一切

00:40:48.910 --> 00:40:52.329
我希望能够给予的作品

00:40:50.829 --> 00:40:54.880
您为什么要提供一些详细的信息

00:40:52.329 --> 00:40:56.980
那不过是说实话我不知道

00:40:54.880 --> 00:40:59.260
但现在可以了，那就是

00:40:56.980 --> 00:41:00.790
重要的事情，重要的

00:40:59.260 --> 00:41:02.170
这里的信息是反应基督徒不是

00:41:00.790 --> 00:41:03.880
与Java八流Java相同

00:41:02.170 --> 00:41:06.400
八个流是一个非常好的方法

00:41:03.880 --> 00:41:08.260
查询集合的方式是

00:41:06.400 --> 00:41:10.480
如果使用魔术并行，则可扩展

00:41:08.260 --> 00:41:12.010
咒语，你的收藏很大

00:41:10.480 --> 00:41:13.930
够了，您的手术很昂贵

00:41:12.010 --> 00:41:16.359
足够您可以生成多个

00:41:13.930 --> 00:41:18.550
 CPU，那很好，那是不一样的

00:41:16.359 --> 00:41:20.950
建模为反应流，不是

00:41:18.550 --> 00:41:23.560
即使API也会做同样的事情

00:41:20.950 --> 00:41:28.300
看起来完全一样，非常

00:41:23.560 --> 00:41:29.680
好吧，我已经九岁了

00:41:28.300 --> 00:41:31.450
分钟以了解其他所有内容

00:41:29.680 --> 00:41:32.500
真的，我不会去

00:41:31.450 --> 00:41:35.310
这不是因为那的细节

00:41:32.500 --> 00:41:37.650
令人兴奋和

00:41:35.310 --> 00:41:39.270
是的，所以反应堆的梦想看起来像

00:41:37.650 --> 00:41:40.830
与工作八流一样，它们不是

00:41:39.270 --> 00:41:42.510
每次看反应堆都一样

00:41:40.830 --> 00:41:44.580
流，您将获得非常直观的

00:41:42.510 --> 00:41:47.610
我不是真的大理石图

00:41:44.580 --> 00:41:49.170
了解这一点，以便您继续进行事件

00:41:47.610 --> 00:41:50.940
一个流和继续发生的事件

00:41:49.170 --> 00:41:52.980
溪流不穿越，不穿越

00:41:50.940 --> 00:41:53.970
溪流，你不知道如何

00:41:52.980 --> 00:41:55.620
他们应该与每个人互动

00:41:53.970 --> 00:41:57.690
其他以及哪个时间进入

00:41:55.620 --> 00:41:59.190
但除此之外，这非常清楚

00:41:57.690 --> 00:42:05.850
解释反应流的方式

00:41:59.190 --> 00:42:07.260
看起来不错，所以反应堆学生可以与

00:42:05.850 --> 00:42:09.870
多个流可以有多个

00:42:07.260 --> 00:42:11.220
消费者的背压真的是

00:42:09.870 --> 00:42:12.960
重要，他们有很大的不同

00:42:11.220 --> 00:42:14.310
并发模型，因此，如果您在考虑

00:42:12.960 --> 00:42:16.230
关于变得被动，你没有

00:42:14.310 --> 00:42:18.150
已经完成，所以您需要了解

00:42:16.230 --> 00:42:21.810
这些东西，否则事情会发生

00:42:18.150 --> 00:42:23.670
很快变得非常混乱

00:42:21.810 --> 00:42:25.550
 Java 9的其他功能很好，我有一个

00:42:23.670 --> 00:42:27.390
整个九分钟的时间

00:42:25.550 --> 00:42:29.600
便利工厂方法

00:42:27.390 --> 00:42:33.090
收藏有人听说过

00:42:29.600 --> 00:42:34.680
几个人，我个人的看法是

00:42:33.090 --> 00:42:36.630
这将是最常用的

00:42:34.680 --> 00:42:38.700
 9的功能，这是一个真正的

00:42:36.630 --> 00:42:40.860
一个愚蠢的人，一个愚蠢的人

00:42:38.700 --> 00:42:43.530
有用的，但它不是

00:42:40.860 --> 00:42:50.040
令人兴奋的lambda和字符串让我们

00:42:43.530 --> 00:42:54.210
看看过去，即现在和你

00:42:50.040 --> 00:42:57.140
创建，让我们将其列出来吧

00:42:54.210 --> 00:42:57.140
列出字符串

00:42:59.410 --> 00:43:09.539
然后您将通过创建一个字符串列表

00:43:03.849 --> 00:43:09.539
做一些像数组点作为列表

00:43:14.160 --> 00:43:17.829
这就是我们创建小字符串的方式

00:43:17.170 --> 00:43:23.160
没关系

00:43:17.829 --> 00:43:25.359
在Java 9中，您可以说出

00:43:23.160 --> 00:43:27.750
你只是救了自己像

00:43:25.359 --> 00:43:31.450
四个字符

00:43:27.750 --> 00:43:33.130
生活是美好的，那不是超级

00:43:31.450 --> 00:43:35.259
令人兴奋的是，它看起来不错

00:43:33.130 --> 00:43:36.849
更好一点，但还有更多

00:43:35.259 --> 00:43:38.980
从我的角度来看，有趣的是你

00:43:36.849 --> 00:43:41.230
可以用set做同样的事情，但是你

00:43:38.980 --> 00:43:43.359
以前做不到，所以你可以这样做

00:43:41.230 --> 00:43:46.240
用于创建无法修改的突变

00:43:43.359 --> 00:43:47.380
列出和不可修改的数据集，因此

00:43:46.240 --> 00:43:49.420
如果你要设置一些东西

00:43:47.380 --> 00:43:51.220
一次，然后在整个过程中使用它

00:43:49.420 --> 00:43:53.319
应用程序，所以很明显我可以看到

00:43:51.220 --> 00:43:55.119
对于测试来说超级有用，但是

00:43:53.319 --> 00:43:58.000
这也是这里的生产代码

00:43:55.119 --> 00:43:59.589
某种测试数据，但您经常

00:43:58.000 --> 00:44:01.420
可能只想设置一个

00:43:59.589 --> 00:44:03.309
即将进行的收藏

00:44:01.420 --> 00:44:05.589
可修改的，你想这样做

00:44:03.309 --> 00:44:06.819
尽可能容易，所以这是一种

00:44:05.589 --> 00:44:08.380
很好

00:44:06.819 --> 00:44:10.660
从那里更有趣

00:44:08.380 --> 00:44:16.180
我的观点是

00:44:10.660 --> 00:44:17.799
再次映射，这不是一个错误的例子

00:44:16.180 --> 00:44:21.640
我在这里只是为了展示Java 9的东西

00:44:17.799 --> 00:44:24.220
我需要这样做，以便

00:44:21.640 --> 00:44:25.690
用一组值建立一个静态映射

00:44:24.220 --> 00:44:28.150
我将用来比较的东西

00:44:25.690 --> 00:44:30.039
所以我必须要有这个可怕的

00:44:28.150 --> 00:44:32.559
在这里设置静态东西

00:44:30.039 --> 00:44:33.970
地图，而且非常丑陋，但是

00:44:32.559 --> 00:44:37.329
不少见，我们必须要做很多

00:44:33.970 --> 00:44:41.130
现在我们不需要这样做，我们可以说

00:44:37.329 --> 00:44:41.130
参赛地图

00:45:09.070 --> 00:45:13.900
所以现在我们可以用地图做到这一点

00:45:11.860 --> 00:45:15.310
的条目，所以这是一个很好的人

00:45:13.900 --> 00:45:16.660
为自己节省了一些代码行

00:45:15.310 --> 00:45:19.300
不必使用ASCII静态块

00:45:16.660 --> 00:45:20.680
我可以再次看到一些测试

00:45:19.300 --> 00:45:22.870
数据可能真的有用

00:45:20.680 --> 00:45:26.260
如果您更少的话，它似乎更有用

00:45:22.870 --> 00:45:30.540
超过十个条目，因为您不需要

00:45:26.260 --> 00:45:30.540
您几乎不会说任何这样的地图

00:45:31.170 --> 00:45:34.650
摆脱所有这些

00:45:42.640 --> 00:45:48.940
还有两个键值键值键

00:45:45.010 --> 00:45:50.530
最多十个值

00:45:48.940 --> 00:45:53.020
在MongoDB和我的大部分工作上工作

00:45:50.530 --> 00:45:55.810
在Java中编写地图，这是

00:45:53.020 --> 00:45:57.430
超级有用，只是摆脱了

00:45:55.810 --> 00:46:00.100
围绕创建的大量样板

00:45:57.430 --> 00:46:00.910
地图和其他收藏类型，所以我

00:46:00.100 --> 00:46:03.010
认为这将是极端

00:46:00.910 --> 00:46:05.020
有价值，不如

00:46:03.010 --> 00:46:07.660
 Groovy的方法例如

00:46:05.020 --> 00:46:11.320
相比于

00:46:07.660 --> 00:46:12.040
我们在正确的五点之前做了什么

00:46:11.320 --> 00:46:13.660
还剩分钟

00:46:12.040 --> 00:46:19.810
我没有时间问问题了

00:46:13.660 --> 00:46:21.700
道歉并主张私人方法

00:46:19.810 --> 00:46:23.920
现在的接口看起来像

00:46:21.700 --> 00:46:25.360
真的很愚蠢，因为界面

00:46:23.920 --> 00:46:27.730
应该定义您的公共API 

00:46:25.360 --> 00:46:29.650
你为什么需要一个私有方法

00:46:27.730 --> 00:46:32.440
一个接口，当然答案

00:46:29.650 --> 00:46:34.270
是在Java 8中我们有默认方法

00:46:32.440 --> 00:46:37.600
接口上的静态方法，因此

00:46:34.270 --> 00:46:40.060
再次示例，这是一些真正的代码

00:46:37.600 --> 00:46:42.730
那是在这个应用程序中，我有

00:46:40.060 --> 00:46:44.470
静态方法，但我有复制和

00:46:42.730 --> 00:46:46.720
在这里粘贴代码，因为

00:46:44.470 --> 00:46:48.970
我没有其他优雅的方式

00:46:46.720 --> 00:46:56.470
意味着我可以将其提取到一个

00:46:48.970 --> 00:46:58.840
方法获取字段的值哎呀

00:46:56.470 --> 00:47:00.460
值错误，但这在Java 8中

00:46:58.840 --> 00:47:02.410
这仍然必须公开，我可能

00:47:00.460 --> 00:47:05.350
不想在我的API上公开

00:47:02.410 --> 00:47:07.240
当然，现在在Java 9中，我只是做到了

00:47:05.350 --> 00:47:09.430
私有的，然后我可以重用该代码

00:47:07.240 --> 00:47:11.140
因此，如果

00:47:09.430 --> 00:47:15.040
您开始使用静态或默认值

00:47:11.140 --> 00:47:18.270
接口上的方法，对不起

00:47:15.040 --> 00:47:18.270
拼写错误真的使我丧命

00:47:19.420 --> 00:47:27.770
现在感觉好多了，新方法

00:47:25.369 --> 00:47:29.750
流API Java的八个流

00:47:27.770 --> 00:47:31.550
 API确实允许您使用无限

00:47:29.750 --> 00:47:33.260
流，并且通常不会让

00:47:31.550 --> 00:47:35.950
你停止了无限的流

00:47:33.260 --> 00:47:38.059
似乎是一个小小的错误估计

00:47:35.950 --> 00:47:40.849
但是现在您有了新的方法

00:47:38.059 --> 00:47:43.130
流API，让您可以做一些

00:47:40.849 --> 00:47:45.859
操作直到某事直到

00:47:43.130 --> 00:47:48.020
某些事情是正确的或忽略系列

00:47:45.859 --> 00:47:50.180
直到一些操作直到一些

00:47:48.020 --> 00:47:54.500
值是真实的，这被称为

00:47:50.180 --> 00:47:58.130
并同时下降，例如，我

00:47:54.500 --> 00:47:59.569
在这种情况下使用过滤器，因为它

00:47:58.130 --> 00:48:00.970
我试图做的那种工作

00:47:59.569 --> 00:48:03.980
有一定价值的东西

00:48:00.970 --> 00:48:08.720
但是现在我只能说花点时间

00:48:03.980 --> 00:48:12.470
虽然一些标准是正确的，然后我想

00:48:08.720 --> 00:48:14.390
你做点什么，在这种情况下我

00:48:12.470 --> 00:48:15.770
流只有17件事长，所以

00:48:14.390 --> 00:48:17.809
没什么大不了的，但是很明显

00:48:15.770 --> 00:48:19.520
就像无限流一样

00:48:17.809 --> 00:48:22.579
想做点事直到有价值

00:48:19.520 --> 00:48:24.500
然后停下来，我做了

00:48:22.579 --> 00:48:27.140
在Java 9出现之前就被这个咬了

00:48:24.500 --> 00:48:29.510
因为当我阅读我的档案时

00:48:27.140 --> 00:48:31.579
我没有办法终止

00:48:29.510 --> 00:48:32.960
服务只是要去直到

00:48:31.579 --> 00:48:35.510
文件末尾没有办法

00:48:32.960 --> 00:48:37.880
说现在停止，这将是真的

00:48:35.510 --> 00:48:40.430
有用，所以花点时间做点什么

00:48:37.880 --> 00:48:42.500
直到一些标准，然后下降是

00:48:40.430 --> 00:48:44.900
忽略一切，直到有一些标准

00:48:42.500 --> 00:48:46.190
我相信您可以将两者结合起来

00:48:44.900 --> 00:48:48.440
你可以说所有这些

00:48:46.190 --> 00:48:50.180
用这些做点什么，然后停在

00:48:48.440 --> 00:48:52.250
这一点特别好

00:48:50.180 --> 00:48:54.700
有序的流，但不必

00:48:52.250 --> 00:48:57.440
只是被命令流

00:48:54.700 --> 00:48:58.790
我是stat walk API玩过的

00:48:57.440 --> 00:48:59.930
这周是因为我以为我

00:48:58.790 --> 00:49:02.420
应该可能会进行一些错误处理

00:48:59.930 --> 00:49:06.700
进入我的应用程序和堆栈

00:49:02.420 --> 00:49:06.700
步行API让我们看一下

00:49:12.270 --> 00:49:16.930
我会告诉你我还没玩过

00:49:14.920 --> 00:49:21.550
正确地做，所以它承担我一个

00:49:16.930 --> 00:49:23.650
一点，虽然你可以堆叠沃克，然后

00:49:21.550 --> 00:49:28.120
你能不能走麻袋吗

00:49:23.650 --> 00:49:30.520
给它一些功能，它给你一个

00:49:28.120 --> 00:49:32.560
流，然后你可以做些什么

00:49:30.520 --> 00:49:34.060
我不需要得到的说明

00:49:32.560 --> 00:49:36.220
错误或任何我的堆栈跟踪

00:49:34.060 --> 00:49:37.990
可以随时获取我的堆栈跟踪

00:49:36.220 --> 00:49:40.360
在应用程序中，这让我做什么

00:49:37.990 --> 00:49:43.000
我可以做的事情就是可以使用

00:49:40.360 --> 00:49:45.970
流的力量找到例如

00:49:43.000 --> 00:49:47.590
假设堆栈中的第一名

00:49:45.970 --> 00:49:50.620
具有特定的软件包名称或

00:49:47.590 --> 00:49:54.730
我的堆栈有多深我的脚有多深

00:49:50.620 --> 00:49:56.680
以及它如何开始唱歌，或者你知道

00:49:54.730 --> 00:49:59.050
你可以做，你可以充分利用

00:49:56.680 --> 00:50:00.610
串流API看看您的

00:49:59.050 --> 00:50:02.560
堆叠，当然这里的重点是

00:50:00.610 --> 00:50:04.000
懒得做，是因为

00:50:02.560 --> 00:50:07.420
当然每个人都知道堆栈跟踪是

00:50:04.000 --> 00:50:09.070
如果你的流真的很贵

00:50:07.420 --> 00:50:11.080
操作不适用，您不适用

00:50:09.070 --> 00:50:12.400
你不会承担那笔费用，所以

00:50:11.080 --> 00:50:14.290
这很好，我还没有

00:50:12.400 --> 00:50:15.460
有机会像正常玩，但

00:50:14.290 --> 00:50:18.010
我认为这将是真的

00:50:15.460 --> 00:50:19.930
在某些情况下有用

00:50:18.010 --> 00:50:22.330
特别是我想看看

00:50:19.930 --> 00:50:24.820
像我一样在堆栈中排名第一

00:50:22.330 --> 00:50:27.910
我的包裹名称可能可用，或者

00:50:24.820 --> 00:50:29.940
多少深多少

00:50:27.910 --> 00:50:34.090
我所有的时间都在打包

00:50:29.940 --> 00:50:36.100
即将完成的多功能释放罐

00:50:34.090 --> 00:50:37.630
文件，这对我来说真的很令人兴奋

00:50:36.100 --> 00:50:40.180
从事图书馆发展工作的人

00:50:37.630 --> 00:50:42.610
从Java 9以后的未来

00:50:40.180 --> 00:50:46.030
作为图书馆开发人员，我将能够

00:50:42.610 --> 00:50:48.130
释放一个使用的jar文件

00:50:46.030 --> 00:50:51.850
 Java主要功能（如果正在使用） 

00:50:48.130 --> 00:50:55.060
 Java 9否则会使用Java 9之前的版本

00:50:51.850 --> 00:50:57.790
功能，它将适用于9 

00:50:55.060 --> 00:50:59.830
 10岁及以上，或工作前，我会

00:50:57.790 --> 00:51:01.420
据我所知，例如

00:50:59.830 --> 00:51:03.010
不知道这是否会发生

00:51:01.420 --> 00:51:05.680
例如，Java可以发布一个

00:51:03.010 --> 00:51:07.900
使用Java 9的jar文件

00:51:05.680 --> 00:51:10.240
如果您使用的是反应式流API 

00:51:07.900 --> 00:51:12.160
 Java 9否则将使用反应堆

00:51:10.240 --> 00:51:13.540
如果不使用Java 9，将使用流API 

00:51:12.160 --> 00:51:16.260
我认为这将非常有用

00:51:13.540 --> 00:51:18.850
特别是对于迁移到Java 9的东西

00:51:16.260 --> 00:51:20.620
处理API更新，您现在可以获取

00:51:18.850 --> 00:51:22.430
坑你的过程，如果你杀死它

00:51:20.620 --> 00:51:24.140
想要这是一件好事

00:51:22.430 --> 00:51:25.550
那里还有很多其他东西

00:51:24.140 --> 00:51:26.990
因此，如果您想管理自己的

00:51:25.550 --> 00:51:28.790
自己的服务（如果您要创建自己的服务） 

00:51:26.990 --> 00:51:30.860
微服务，您可以做类似的事情

00:51:28.790 --> 00:51:33.470
实际使用命令行工具

00:51:30.860 --> 00:51:35.210
真正有用的方式更新应用程序

00:51:33.470 --> 00:51:36.650
当您阅读《 

00:51:35.210 --> 00:51:39.110
您将能够看到的文档

00:51:36.650 --> 00:51:41.240
是否计划了不推荐使用的方法

00:51:39.110 --> 00:51:42.620
删除还是像我一样

00:51:41.240 --> 00:51:44.240
你可能不应该使用这个

00:51:42.620 --> 00:51:46.280
您还会看到什么时候

00:51:44.240 --> 00:51:49.850
不推荐使用，例如Java 1.8或1.2或

00:51:46.280 --> 00:51:51.530
任何html5 Java狗（如果生成） 

00:51:49.850 --> 00:51:55.910
 Java点，我们大多数人不知道

00:51:51.530 --> 00:51:59.120
在html5中生成它是的Java文档

00:51:55.910 --> 00:52:04.640
搜索看起来有点搜索栏

00:51:59.120 --> 00:52:05.870
 Java狗皮辉煌的爬行动物

00:52:04.640 --> 00:52:07.520
谢谢上帝，我没有时间看

00:52:05.870 --> 00:52:09.350
爬行动物，但是有一个

00:52:07.520 --> 00:52:12.620
我在这里讨论过的教程

00:52:09.350 --> 00:52:14.690
我的其他一些谈话以及

00:52:12.620 --> 00:52:16.100
你习惯于使用爬行动物，而你

00:52:14.690 --> 00:52:18.380
对步枪应该如何工作有想法

00:52:16.100 --> 00:52:19.880
在IDE中请告诉我们，因为您

00:52:18.380 --> 00:52:24.170
真的很想了解哪些用户

00:52:19.880 --> 00:52:27.100
想要从乳头状权利对不起我

00:52:24.170 --> 00:52:30.800
随着时间的流逝，我感到非常抱歉和

00:52:27.100 --> 00:52:32.510
 Java 9的痛苦可能会破坏您的代码

00:52:30.800 --> 00:52:35.180
使用Java 9确实是您的代码可能

00:52:32.510 --> 00:52:36.470
尤其是使用Gradle打破，他们

00:52:35.180 --> 00:52:38.360
正在按照他们的方式进行

00:52:36.470 --> 00:52:39.770
将其修复，但在

00:52:38.360 --> 00:52:41.240
片刻不起作用，但最好的事情

00:52:39.770 --> 00:52:42.800
要做的就是尽快尝试

00:52:41.240 --> 00:52:44.240
可能找出问题所在

00:52:42.800 --> 00:52:45.380
尤其是当某些问题

00:52:44.240 --> 00:52:46.580
其实不是你的错

00:52:45.380 --> 00:52:47.570
然后你需要别人的错

00:52:46.580 --> 00:52:49.550
可以向那些人报告

00:52:47.570 --> 00:52:51.410
库或jdk团队左右

00:52:49.550 --> 00:52:52.790
不管怎样，请尽快使用它

00:52:51.410 --> 00:52:55.190
可能找出问题所在

00:52:52.790 --> 00:52:56.690
是，有一堆东西

00:52:55.190 --> 00:52:58.310
消失这是原因之一

00:52:56.690 --> 00:52:59.990
为什么东西会破裂，并且有

00:52:58.310 --> 00:53:02.390
一堆东​​西，这将

00:52:59.990 --> 00:53:04.550
更改，例如g1现在是默认值

00:53:02.390 --> 00:53:05.810
垃圾收集器，我不认为那是

00:53:04.550 --> 00:53:07.100
将会产生巨大的影响，因为我

00:53:05.810 --> 00:53:08.630
想想你是否在乎什么垃圾

00:53:07.100 --> 00:53:10.130
您已经将其调整到的收集器

00:53:08.630 --> 00:53:11.360
在生命的一英寸之内，如果

00:53:10.130 --> 00:53:13.400
不在乎它可能不是

00:53:11.360 --> 00:53:15.770
将产生任何变化，例如

00:53:13.400 --> 00:53:18.560
所有新版本的字符串版本

00:53:15.770 --> 00:53:21.200
字符串方案，现在是Java 9了

00:53:18.560 --> 00:53:22.640
 1.9所以如果您暂停版本

00:53:21.200 --> 00:53:24.620
确定您是否在

00:53:22.640 --> 00:53:26.120
一分八跑一分六跑

00:53:24.620 --> 00:53:28.490
一分一分，你将要

00:53:26.120 --> 00:53:32.330
当您通过Java 9时跌倒了

00:53:28.490 --> 00:53:34.400
所以要注意Java和其他东西

00:53:32.330 --> 00:53:35.250
 9包括IntelliJ仍在发展

00:53:34.400 --> 00:53:37.230
想法如此

00:53:35.250 --> 00:53:39.090
这些功能正在发展， 

00:53:37.230 --> 00:53:40.980
情况正在好转，但需要

00:53:39.090 --> 00:53:44.100
反馈一些真正的开发人员

00:53:40.980 --> 00:53:46.020
帮助您不必发生这种情况

00:53:44.100 --> 00:53:49.140
按顺序模块化整个代码库

00:53:46.020 --> 00:53:50.850
实际上，如果II将使用Java 9 

00:53:49.140 --> 00:53:52.830
建议可能不这样做

00:53:50.850 --> 00:53:54.300
除非你绝对必须

00:53:52.830 --> 00:53:56.190
也许不是，也许不是你的

00:53:54.300 --> 00:53:57.630
不是模块化的重要内容

00:53:56.190 --> 00:54:00.270
查看您的代码库，但不必

00:53:57.630 --> 00:54:02.010
所以不要惊慌

00:54:00.270 --> 00:54:04.230
反应堆的梦想与Java不同

00:54:02.010 --> 00:54:05.400
 8个流，因此您必须要注意

00:54:04.230 --> 00:54:09.870
不同的用例有什么用

00:54:05.400 --> 00:54:11.550
我找到Java的那些东西

00:54:09.870 --> 00:54:13.740
鼓励与

00:54:11.550 --> 00:54:15.120
模块化封装等等

00:54:13.740 --> 00:54:16.560
来吧，这让我想了很多

00:54:15.120 --> 00:54:17.780
有关建筑和设计的更多信息

00:54:16.560 --> 00:54:19.740
认为这是一件好事

00:54:17.780 --> 00:54:21.270
鼓励采用新的工作方式

00:54:19.740 --> 00:54:23.070
用反应性撕开乳头

00:54:21.270 --> 00:54:25.890
流有一些不同的模型

00:54:23.070 --> 00:54:27.840
使用，里面有很多东西

00:54:25.890 --> 00:54:29.370
那里只是使代码更易于编写

00:54:27.840 --> 00:54:31.620
像collections framework这样的东西

00:54:29.370 --> 00:54:33.390
像栈行走API之类的东西

00:54:31.620 --> 00:54:34.920
像流程API之类的

00:54:33.390 --> 00:54:37.500
点点滴滴就变成了

00:54:34.920 --> 00:54:39.330
更好地编写代码

00:54:37.500 --> 00:54:39.750
有关此演讲的资源，请访问： 

00:54:39.330 --> 00:54:41.220
这个连结

00:54:39.750 --> 00:54:43.140
包括幻灯片链接到更多

00:54:41.220 --> 00:54:44.940
信息链接到我使用的所有东西

00:54:43.140 --> 00:54:46.500
尝试把这东西放在一起

00:54:44.940 --> 00:54:48.510
当视频可用时，我会放

00:54:46.500 --> 00:54:49.510
它也在那里谢谢你

00:54:48.510 --> 00:54:57.779
非常

00:54:49.510 --> 00:54:57.779
 [掌声] 

