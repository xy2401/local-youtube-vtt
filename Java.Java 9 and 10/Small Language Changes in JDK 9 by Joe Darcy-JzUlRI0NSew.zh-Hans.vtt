WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.000 --> 00:00:05.069
你好，我叫乔·达西，我是

00:00:02.760 --> 00:00:07.410
 Oracle Java平台团队的工程师

00:00:05.069 --> 00:00:12.179
我今天将谈论小

00:00:07.410 --> 00:00:13.200
首先在jt9中更改语言，但是我们

00:00:12.179 --> 00:00:15.839
应该提到，有一个非常

00:00:13.200 --> 00:00:18.630
在JDK 9中大语言更改为

00:00:15.839 --> 00:00:21.689
他的项目是模块化的一部分

00:00:18.630 --> 00:00:24.570
拼图里有一种新的源文件

00:00:21.689 --> 00:00:27.539
使用的模块信息点Java文件

00:00:24.570 --> 00:00:31.170
声明模块之间的依赖关系

00:00:27.539 --> 00:00:32.940
以及声明什么包裹

00:00:31.170 --> 00:00:36.300
模块导出和其他信息

00:00:32.940 --> 00:00:38.160
像这样还有更多的话要说

00:00:36.300 --> 00:00:41.340
关于模块，并了解更多有关

00:00:38.160 --> 00:00:44.070
我建议您听模块

00:00:41.340 --> 00:00:47.160
模块和我同事的JDK 9演讲

00:00:44.070 --> 00:00:50.190
小语言的亚历克斯·巴克利（Alex Buckley） 

00:00:47.160 --> 00:00:52.829
在JDK 9中所做的更改分为两部分

00:00:50.190 --> 00:00:55.530
类别之一是一组计划的

00:00:52.829 --> 00:00:58.440
 JDK对lambda项目的改进

00:00:55.530 --> 00:01:00.090
 8，并从JDK 7和

00:00:58.440 --> 00:01:01.920
第二组变更涉及

00:01:00.090 --> 00:01:05.100
淘汰设施更多

00:01:01.920 --> 00:01:07.950
内容丰富的项目代币，而JDK 7是

00:01:05.100 --> 00:01:09.900
收集小六个

00:01:07.950 --> 00:01:12.030
语言更改，我们做了进一步的改进

00:01:09.900 --> 00:01:14.549
对JDK 9中的3的改进

00:01:12.030 --> 00:01:17.600
钻石尝试地球的资源和瓦格

00:01:14.549 --> 00:01:20.250
警告小语言更改

00:01:17.600 --> 00:01:22.650
包括那些更新硬币

00:01:20.250 --> 00:01:24.900
作为与lambda项目相关的两个更新

00:01:22.650 --> 00:01:27.600
从奉献，并会讲

00:01:24.900 --> 00:01:30.090
这些首先是安全的

00:01:27.600 --> 00:01:31.829
您可以编写的私有实例方法

00:01:30.090 --> 00:01:35.130
这样的代码一段时间

00:01:31.829 --> 00:01:37.320
甚至使用

00:01:35.130 --> 00:01:41.310
实用程序方法将点数组作为列表

00:01:37.320 --> 00:01:44.549
我们在此轻松创建的平台

00:01:41.310 --> 00:01:47.880
情况下，但字符串列表

00:01:44.549 --> 00:01:49.259
当您编译此代码时

00:01:47.880 --> 00:01:51.540
谨慎对待您的警告消息

00:01:49.259 --> 00:01:54.210
您会注意到这样的警告的消息

00:01:51.540 --> 00:01:56.640
警告未经检查的通用数组创建

00:01:54.210 --> 00:02:00.180
对于VAR x参数，这是怎么回事

00:01:56.640 --> 00:02:01.850
这里实际上是强制发出此警告

00:02:00.180 --> 00:02:05.070
由Java语言规范

00:02:01.850 --> 00:02:07.170
因为这可能是坏事

00:02:05.070 --> 00:02:08.910
可能发生的事情是坏事

00:02:07.170 --> 00:02:11.610
称为热污染，并进行了讨论

00:02:08.910 --> 00:02:13.710
在规范中有详细说明

00:02:11.610 --> 00:02:16.830
当您调用平台阵列时

00:02:13.710 --> 00:02:19.530
周到的方法实际上没有什么不好

00:02:16.830 --> 00:02:21.690
在这种情况下发生平台方法

00:02:19.530 --> 00:02:23.910
不是行为异常，因此此错误是

00:02:21.690 --> 00:02:26.520
即使是强制性的，也没有信息

00:02:23.910 --> 00:02:27.780
通过平台，我们认为那不是

00:02:26.520 --> 00:02:29.640
很好的情况

00:02:27.780 --> 00:02:31.080
因此在Coyne项目中，我们创建了一个

00:02:29.640 --> 00:02:33.750
摆脱这些的设施

00:02:31.080 --> 00:02:36.180
无关紧要的警告消息

00:02:33.750 --> 00:02:39.390
设施是节省我们的参数

00:02:36.180 --> 00:02:41.550
注释，如果程序员应用

00:02:39.390 --> 00:02:43.590
我们组织的安全varargs注释

00:02:41.550 --> 00:02:46.650
它使编译器知道的方法

00:02:43.590 --> 00:02:49.050
程序员声称VAR 

00:02:46.650 --> 00:02:51.780
不会有不当行为的论点

00:02:49.050 --> 00:02:53.490
不会发生热污染

00:02:51.780 --> 00:02:56.030
因此，编译器是

00:02:53.490 --> 00:02:59.930
由更新的规范证明

00:02:56.030 --> 00:03:02.280
在不发出警告消息

00:02:59.930 --> 00:03:04.050
方法的声明站点等

00:03:02.280 --> 00:03:07.350
重要的是， 

00:03:04.050 --> 00:03:09.660
方法，因此从JDK 7开始，您不会

00:03:07.350 --> 00:03:12.690
警告消息调用数组点为

00:03:09.660 --> 00:03:14.880
列出原因是因为

00:03:12.690 --> 00:03:17.670
注释工具注释仅

00:03:14.880 --> 00:03:20.040
继承于类而不是接口或

00:03:17.670 --> 00:03:21.900
方法，因此安全参数

00:03:20.040 --> 00:03:24.240
注释只能在方法上使用

00:03:21.900 --> 00:03:25.290
不能被覆盖的是什么

00:03:24.240 --> 00:03:27.570
各种不可能的方法

00:03:25.290 --> 00:03:32.040
覆盖我们不能覆盖最终

00:03:27.570 --> 00:03:35.250
方法或静态方法的构造函数

00:03:32.040 --> 00:03:37.080
也不能从VM覆盖

00:03:35.250 --> 00:03:39.420
观点的建设者只是非常

00:03:37.080 --> 00:03:41.220
静态方法的特殊缺点

00:03:39.420 --> 00:03:43.350
另一类方法

00:03:41.220 --> 00:03:46.410
被覆盖，那些是私有的

00:03:43.350 --> 00:03:49.170
方法，我们在JDK中省略了这些方法

00:03:46.410 --> 00:03:51.530
 7，但现在在jdk 9中我们已经解决了

00:03:49.170 --> 00:03:53.340
添加它们，所以我们有一个很小的

00:03:51.530 --> 00:03:55.950
更新为Java语言

00:03:53.340 --> 00:04:00.120
现在的规格还允许说远

00:03:55.950 --> 00:04:02.940
接下来有效地解决私有方法

00:04:00.120 --> 00:04:05.100
最终变量和部落资源为

00:04:02.940 --> 00:04:07.290
部落世界的提醒

00:04:05.100 --> 00:04:09.420
资源声明，您有一个try块

00:04:07.290 --> 00:04:12.210
在此管理您的资源R 

00:04:09.420 --> 00:04:14.420
情况和内部编译器

00:04:12.210 --> 00:04:17.520
将此转换为类文件

00:04:14.420 --> 00:04:20.460
大致相当于这个

00:04:17.520 --> 00:04:22.560
尝试包装的最后一块

00:04:20.460 --> 00:04:24.770
最终块关闭被调用

00:04:22.560 --> 00:04:26.940
资源，只要它不为空

00:04:24.770 --> 00:04:27.450
现在实际上更多了

00:04:26.940 --> 00:04:29.730
复杂

00:04:27.450 --> 00:04:32.670
这样可以提供更好的异常处理

00:04:29.730 --> 00:04:36.260
因此，就全面披露而言，这是

00:04:32.670 --> 00:04:38.250
完全毁灭的戒指看起来像什么

00:04:36.260 --> 00:04:40.260
我们不必为此担心

00:04:38.250 --> 00:04:41.720
程序员，因为编译器需要

00:04:40.260 --> 00:04:46.770
为我们照顾这个

00:04:41.720 --> 00:04:48.270
所以在JDK 7中，要求是

00:04:46.770 --> 00:04:50.640
尝试管理的资源

00:04:48.270 --> 00:04:52.290
资源声明必须是新鲜的

00:04:50.640 --> 00:04:54.810
宣告为

00:04:52.290 --> 00:04:57.420
声明不是原始的

00:04:54.810 --> 00:04:59.460
最初可以使用任何建议

00:04:57.420 --> 00:05:02.400
如果类型正确的表达式

00:04:59.460 --> 00:05:03.780
是文章的完整界面类型

00:05:02.400 --> 00:05:06.510
具有封闭的方法是

00:05:03.780 --> 00:05:08.790
很好，但是我们注意到有一个

00:05:06.510 --> 00:05:10.440
该建议存在问题，我们看到

00:05:08.790 --> 00:05:13.290
假设您有资源

00:05:10.440 --> 00:05:15.540
被初始化为您的新资源

00:05:13.290 --> 00:05:17.340
尝试管理变量R 

00:05:15.540 --> 00:05:18.540
三个来源声明，并在

00:05:17.340 --> 00:05:21.630
阻止你使它指向某事

00:05:18.540 --> 00:05:24.330
现在，当你走到尽头

00:05:21.630 --> 00:05:25.740
包机资源阻止了哪些对象

00:05:24.330 --> 00:05:29.190
应该有其关闭的方法调用

00:05:25.740 --> 00:05:30.030
资源1或资源2我们决定

00:05:29.190 --> 00:05:32.130
不想解决这个问题

00:05:30.030 --> 00:05:36.780
问题，解决方案是要求

00:05:32.130 --> 00:05:38.010
与之一起使用的新的最终变量

00:05:36.780 --> 00:05:40.410
试用三源声明

00:05:38.010 --> 00:05:43.980
但是那有点太过分了

00:05:40.410 --> 00:05:46.500
限制性的，因为如果表达

00:05:43.980 --> 00:05:49.320
已经是决赛或有效决赛

00:05:46.500 --> 00:05:52.170
变量不会发生此问题，所以

00:05:49.320 --> 00:05:54.240
在JDK 9中，我们放宽了规则，因此如果

00:05:52.170 --> 00:05:55.740
您已经有了最终决定权或有效决定权

00:05:54.240 --> 00:05:57.750
您不必清除的最终资源

00:05:55.740 --> 00:06:01.050
新变量而不是

00:05:57.750 --> 00:06:03.270
在这种情况下声明资源R 2 

00:06:01.050 --> 00:06:04.890
您可以重复使用现有的

00:06:03.270 --> 00:06:07.020
资源变数

00:06:04.890 --> 00:06:10.440
摆脱一些简化

00:06:07.020 --> 00:06:12.180
代码中不必要的样板

00:06:10.440 --> 00:06:14.580
我们将谈论匿名的钻石

00:06:12.180 --> 00:06:16.770
钻石类使用类型推断

00:06:14.580 --> 00:06:19.320
在编译器内部以允许程序员

00:06:16.770 --> 00:06:20.820
避免使用显式类型

00:06:19.320 --> 00:06:23.700
调用构造函数时的参数

00:06:20.820 --> 00:06:26.580
所以如果你想的话，回到钻石之前

00:06:23.700 --> 00:06:31.110
做类似初始化列表的操作

00:06:26.580 --> 00:06:33.120
字符串映射为整数你会说

00:06:31.110 --> 00:06:35.430
调用新的ArrayList，然后重复

00:06:33.120 --> 00:06:37.590
这些类型参数映射字符串，并且

00:06:35.430 --> 00:06:39.660
整数，但您不必这样做

00:06:37.590 --> 00:06:41.509
现在你可以说新话了

00:06:39.660 --> 00:06:44.099
数组列表

00:06:41.509 --> 00:06:46.770
小于大于和编译器

00:06:44.099 --> 00:06:48.810
现在将为您推断其余部分

00:06:46.770 --> 00:06:50.639
语言功能非常有效

00:06:48.810 --> 00:06:52.889
消除了对显式类型的需求

00:06:50.639 --> 00:06:55.560
争论但是有一些情况

00:06:52.889 --> 00:06:59.129
你不能因为坏而使用它

00:06:55.560 --> 00:07:01.860
钻石之间最坏情况的相互作用

00:06:59.129 --> 00:07:04.560
和匿名类，您不能使用

00:07:01.860 --> 00:07:06.360
那些彼此的问题是

00:07:04.560 --> 00:07:07.979
在某些情况下，类型推断可以

00:07:06.360 --> 00:07:11.340
推断出某种非显着的东西

00:07:07.979 --> 00:07:13.379
 nan de显着类型在外部的类型

00:07:11.340 --> 00:07:16.050
我们可以用作的类型系统

00:07:13.379 --> 00:07:17.490
程序员，无法代表

00:07:16.050 --> 00:07:19.430
在需要的类文件中

00:07:17.490 --> 00:07:22.139
为匿名类生成

00:07:19.430 --> 00:07:24.990
但是，这是最坏的情况

00:07:22.139 --> 00:07:26.969
在许多情况下，可以推断出显着的类型

00:07:24.990 --> 00:07:29.729
这可以在一个班级中代表

00:07:26.969 --> 00:07:31.740
文件，所以我们认为此限制是

00:07:29.729 --> 00:07:34.650
有点不幸，我们确实注意到

00:07:31.740 --> 00:07:36.779
我们正在用JDK完成项目硬币

00:07:34.650 --> 00:07:39.089
 7将来我们可能会放松这一点

00:07:36.779 --> 00:07:40.770
限制并允许钻石和

00:07:39.089 --> 00:07:43.020
匿名类一起使用

00:07:40.770 --> 00:07:45.779
只要那个最坏的结果没有

00:07:43.020 --> 00:07:47.909
发生，这的确是我们所做的

00:07:45.779 --> 00:07:50.009
现在在JDK 9中我们放宽了

00:07:47.909 --> 00:07:53.400
限制，现在您可以使用钻石

00:07:50.009 --> 00:07:55.680
在许多情况下使用匿名类

00:07:53.400 --> 00:07:57.539
在JDK 7中，我们发现钻石非常

00:07:55.680 --> 00:08:00.330
有效消除显式类型

00:07:57.539 --> 00:08:03.449
超过构造函数调用的90％的参数

00:08:00.330 --> 00:08:05.339
网站，有了这项新的增强功能，我们

00:08:03.449 --> 00:08:07.289
觉得允许钻石与

00:08:05.339 --> 00:08:08.689
匿名类允许删除

00:08:07.289 --> 00:08:11.969
其余10％的很大一部分

00:08:08.689 --> 00:08:13.469
我们在使用这个方面有很好的经验

00:08:11.969 --> 00:08:16.139
 JDK代码库中的功能

00:08:13.469 --> 00:08:19.620
消除了数百个额外的通话

00:08:16.139 --> 00:08:21.960
网站接下来的两种小语言

00:08:19.620 --> 00:08:23.580
更改是对项目的更新

00:08:21.960 --> 00:08:26.159
在八个功能中添加的lambda功能

00:08:23.580 --> 00:08:29.580
第一个下划线不再是

00:08:26.159 --> 00:08:31.949
标识符名称从8开始

00:08:29.580 --> 00:08:34.680
如果您使用过，编译器会发出警告

00:08:31.949 --> 00:08:36.719
下划线作为标识符警告

00:08:34.680 --> 00:08:39.690
将来可能不允许

00:08:36.719 --> 00:08:43.050
该平台的版本，甚至现在

00:08:39.690 --> 00:08:46.440
在JT 9中是不允许的，什么是

00:08:43.050 --> 00:08:48.480
警告消息现在是错误，为什么

00:08:46.440 --> 00:08:51.260
我们在这样做我们想回收

00:08:48.480 --> 00:08:54.690
强调为语法房地产

00:08:51.260 --> 00:08:56.639
将其重新用于更多有用的东西

00:08:54.690 --> 00:09:00.120
描述那些更有用的东西

00:08:56.639 --> 00:09:04.110
在JEP 302 lambda剩菜JEP是

00:09:00.120 --> 00:09:09.470
 JDK增强建议作为土地的一部分

00:09:04.110 --> 00:09:11.910
在JDK 8中，您可以将方法添加到

00:09:09.470 --> 00:09:14.459
有代码的接口是

00:09:11.910 --> 00:09:17.250
称为默认方法，所以这些方法

00:09:14.459 --> 00:09:20.600
是非抽象的，因此它们有一个

00:09:17.250 --> 00:09:22.589
 VM级别和JDK 8的方法主体

00:09:20.600 --> 00:09:24.180
接口可以具有私有方法

00:09:22.589 --> 00:09:27.120
这些被用来帮助实施

00:09:24.180 --> 00:09:29.069
 lambda等，但是在

00:09:27.120 --> 00:09:31.230
源代码级程序员无法

00:09:29.069 --> 00:09:36.120
在中声明私有接口方法

00:09:31.230 --> 00:09:38.819
 JDK 8，现在我们可以在JDK 9中

00:09:36.120 --> 00:09:41.129
将两个私有静态方法都声明为

00:09:38.819 --> 00:09:42.629
以及私有实例方法如何

00:09:41.129 --> 00:09:44.339
你会在这样的私人方法

00:09:42.629 --> 00:09:46.379
可以将它们用作帮助程序的界面

00:09:44.339 --> 00:09:49.319
实施其他公众的信息

00:09:46.379 --> 00:09:51.149
默认方法，我们已经找到了

00:09:49.319 --> 00:09:54.720
该功能在编写

00:09:51.149 --> 00:09:56.490
 JDK接下来的两个小改动都是

00:09:54.720 --> 00:09:58.889
与折旧设施有关

00:09:56.490 --> 00:10:01.439
首先，我们将讨论弃用

00:09:58.889 --> 00:10:03.689
警告和导入的方法之一

00:10:01.439 --> 00:10:06.149
我们已经偿还了

00:10:03.689 --> 00:10:08.519
 JDK是为了减少

00:10:06.149 --> 00:10:11.069
在我们的代码库中，警告实际上

00:10:08.519 --> 00:10:13.560
清除了所有类别的警告

00:10:11.069 --> 00:10:15.449
要编码的大部分

00:10:13.560 --> 00:10:18.060
包括消除折旧

00:10:15.449 --> 00:10:20.130
现在警告您何时弃用

00:10:18.060 --> 00:10:22.019
这些警告将在Java中讨论

00:10:20.130 --> 00:10:24.060
语言规范，您就会得到

00:10:22.019 --> 00:10:26.399
当您使用不推荐使用的类型方法时

00:10:24.060 --> 00:10:27.600
构造函数等等，还有

00:10:26.399 --> 00:10:30.839
解决这些问题的三种方法

00:10:27.600 --> 00:10:32.790
警告，您可以停止使用

00:10:30.839 --> 00:10:34.410
首选的不推荐使用的元素

00:10:32.790 --> 00:10:37.050
当你能做到的时候

00:10:34.410 --> 00:10:39.300
做到这一点，您可以传播不赞成使用的内容

00:10:37.050 --> 00:10:40.559
现在是使用站点的注释

00:10:39.300 --> 00:10:42.630
比疾病更糟糕，因为你

00:10:40.559 --> 00:10:45.050
扩大而不是缩小

00:10:42.630 --> 00:10:47.160
不推荐使用的元素数量，以及

00:10:45.050 --> 00:10:48.930
最后你可以使用抑制

00:10:47.160 --> 00:10:51.379
警告注释让编译器

00:10:48.930 --> 00:10:54.120
知道你不想得到这个

00:10:51.379 --> 00:10:56.160
警告消息了，所以再说一遍

00:10:54.120 --> 00:10:59.879
有您的客户库，而您

00:10:56.160 --> 00:11:02.250
使用不推荐使用的库，您

00:10:59.879 --> 00:11:05.189
想要抑制来自

00:11:02.250 --> 00:11:06.689
注释，因为您收到警告

00:11:05.189 --> 00:11:07.720
消息在这里，你想摆脱

00:11:06.689 --> 00:11:10.269
那

00:11:07.720 --> 00:11:12.639
您可能会认为在顶部正确

00:11:10.269 --> 00:11:16.000
在班上我会压制

00:11:12.639 --> 00:11:17.860
弃用警告，而我不必

00:11:16.000 --> 00:11:20.740
但是当你做其他的事情

00:11:17.860 --> 00:11:23.079
编译此代码，您仍然会得到

00:11:20.740 --> 00:11:26.470
弃用警告，这是怎么回事

00:11:23.079 --> 00:11:28.990
如果你看警告的话

00:11:26.470 --> 00:11:32.410
更详细的消息警告不是

00:11:28.990 --> 00:11:34.389
从类中的代码主体

00:11:32.410 --> 00:11:36.970
实际上是从import语句

00:11:34.389 --> 00:11:39.459
现在就在文件顶部

00:11:36.970 --> 00:11:42.879
此导入由Java强制执行

00:11:39.459 --> 00:11:44.259
语言规范，使您更糟

00:11:42.879 --> 00:11:46.120
不能使用抑制警告

00:11:44.259 --> 00:11:48.939
 import语句上的注释是

00:11:46.120 --> 00:11:50.709
在语法上不允许这样做

00:11:48.939 --> 00:11:52.480
如果所有的警告都无济于事

00:11:50.709 --> 00:11:53.050
不推荐使用的类型的其他用途可以是

00:11:52.480 --> 00:11:56.139
压抑

00:11:53.050 --> 00:11:57.610
你为什么不能消除警告

00:11:56.139 --> 00:12:00.939
似乎没有的导入语句

00:11:57.610 --> 00:12:04.959
非常有帮助，的确，我们对此进行了更改

00:12:00.939 --> 00:12:07.329
 JDK 9中的行为不需要

00:12:04.959 --> 00:12:11.110
该位置不再显示警告消息

00:12:07.329 --> 00:12:12.399
正因为如此，它现在很容易处理

00:12:11.110 --> 00:12:14.470
清除大型代码库

00:12:12.399 --> 00:12:16.720
弃用警告，我们有一个

00:12:14.470 --> 00:12:19.420
 JDK的存在证明

00:12:16.720 --> 00:12:21.069
基于Java的模块和Java 

00:12:19.420 --> 00:12:22.620
桌面模块已清除

00:12:21.069 --> 00:12:25.300
弃用警告

00:12:22.620 --> 00:12:27.009
弃用是什么意思

00:12:25.300 --> 00:12:28.779
平台中已经存在的设施

00:12:27.009 --> 00:12:31.360
很长一段时间，但有一些

00:12:28.779 --> 00:12:32.500
如果它的语义不确定

00:12:31.360 --> 00:12:34.899
之所以弃用，是因为

00:12:32.500 --> 00:12:36.670
是有害的，还是因为它

00:12:34.899 --> 00:12:37.529
走开，如果它已被弃用

00:12:36.670 --> 00:12:40.990
因为它要消失了

00:12:37.529 --> 00:12:43.449
为什么还没有从中删除更多项目

00:12:40.990 --> 00:12:45.250
这些年来，JDK已经做了一些

00:12:43.449 --> 00:12:47.980
进度删除删除不推荐使用

00:12:45.250 --> 00:12:50.199
 JDK 9中的项目，但我们也想到了更多

00:12:47.980 --> 00:12:52.360
您需要传达的信息

00:12:50.199 --> 00:12:53.439
弃用注释

00:12:52.360 --> 00:12:56.800
区分这些不同

00:12:53.439 --> 00:12:59.290
案例，我们通过添加一个新的案例

00:12:56.800 --> 00:13:01.329
弃用注释的方法

00:12:59.290 --> 00:13:04.660
删除方法为true或

00:13:01.329 --> 00:13:06.430
 false，默认为false，但是如果

00:13:04.660 --> 00:13:08.920
标记为true表示

00:13:06.430 --> 00:13:10.660
作为开发人员，您应该

00:13:08.920 --> 00:13:12.639
不再使用它，因为它

00:13:10.660 --> 00:13:15.730
在将来的版本中将被删除

00:13:12.639 --> 00:13:18.339
平台周围的工具

00:13:15.730 --> 00:13:21.580
进行了弃用处理

00:13:18.339 --> 00:13:23.680
关于两种语言规范

00:13:21.580 --> 00:13:26.440
以及Java C和Java可以说全部

00:13:23.680 --> 00:13:29.320
有更新来处理此问题，并且有一个

00:13:26.440 --> 00:13:32.350
新的静态分析工具

00:13:29.320 --> 00:13:34.570
分析类的JDK J更深层扫描

00:13:32.350 --> 00:13:36.400
 api的文件和jar文件

00:13:34.570 --> 00:13:38.190
在jdk中弃用的

00:13:36.400 --> 00:13:40.180
您另外警告您

00:13:38.190 --> 00:13:42.210
应用程序可能正在使用它们，所以您

00:13:40.180 --> 00:13:45.580
可以采取一些措施停止使用它们

00:13:42.210 --> 00:13:47.620
所以总的来说，模块化是很大的

00:13:45.580 --> 00:13:49.540
语言更改即将在jdk 9中发布，但

00:13:47.620 --> 00:13:51.250
我们还有许多其他有用的更新

00:13:49.540 --> 00:13:53.800
经历过计划语言

00:13:51.250 --> 00:13:56.170
语言变化的改进

00:13:53.800 --> 00:13:58.000
以前用JDK 7和8制作

00:13:56.170 --> 00:13:59.740
这些是非常非常直接的

00:13:58.000 --> 00:14:02.770
使用，您可以自己使用它们

00:13:59.740 --> 00:14:04.810
今天的代码，并开始在其中使用

00:14:02.770 --> 00:14:07.420
您的新代码，您可以下载一个版本

00:14:04.810 --> 00:14:09.130
适用于您平台的JDK 

00:14:07.420 --> 00:14:11.350
有兴趣参与

00:14:09.130 --> 00:14:13.030
开JDK开发你可以看一下

00:14:11.350 --> 00:14:15.820
打开的JDK上的邮件列表

00:14:13.030 --> 00:14:18.730
网站，您还可以获取有关的更新

00:14:15.820 --> 00:14:21.330
通过在以下位置打开JDK来打开JDK 

00:14:18.730 --> 00:14:21.330
 Twitter谢谢

