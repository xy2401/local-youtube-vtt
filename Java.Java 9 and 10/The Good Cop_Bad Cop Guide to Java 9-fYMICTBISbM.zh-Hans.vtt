WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.170 --> 00:00:08.570
好的，大家好，非常感谢

00:00:06.500 --> 00:00:09.769
参加我们的会议很重要

00:00:08.570 --> 00:00:11.720
欣赏有一大堆

00:00:09.769 --> 00:00:14.210
会议真的很好，所以谢谢你

00:00:11.720 --> 00:00:16.580
因为加入我们，我叫西蒙

00:00:14.210 --> 00:00:20.720
枫，这是我的同事奥格奴隶

00:00:16.580 --> 00:00:23.269
大家好，这是一个会议

00:00:20.720 --> 00:00:27.159
好警察坏警察指南到Java 9所以

00:00:23.269 --> 00:00:29.869
迄今为止在Java 1中听说过Java 9的人

00:00:27.159 --> 00:00:31.789
大多数人，我希望

00:00:29.869 --> 00:00:34.790
星期三，所以我们要稍微

00:00:31.789 --> 00:00:36.559
对此有不同的看法

00:00:34.790 --> 00:00:38.270
会议，这不仅会成为常规

00:00:36.559 --> 00:00:39.890
会议，我们将成为一个好警察和

00:00:38.270 --> 00:00:42.739
坏警察，所以首先来介绍

00:00:39.890 --> 00:00:45.680
自己，是的，这是我，我的名字是

00:00:42.739 --> 00:00:47.359
我从爱沙尼亚工作的亚历克斯妻子

00:00:45.680 --> 00:00:51.140
被称为零到四舍五入的公司

00:00:47.359 --> 00:00:53.929
开发者倡导者有几个

00:00:51.140 --> 00:00:55.219
我要做的事情我维护我们的博客

00:00:53.929 --> 00:00:57.320
在我们发布的地方称为反叛应用

00:00:55.219 --> 00:00:57.620
技术含量，如果您去检查

00:00:57.320 --> 00:00:59.230
出

00:00:57.620 --> 00:01:02.510
这会让我个人很开心

00:00:59.230 --> 00:01:05.960
我和西蒙（Simon）共同领导

00:01:02.510 --> 00:01:07.939
这是Java在线药品Java 

00:01:05.960 --> 00:01:10.310
用户组，因此，如果您足够懒惰

00:01:07.939 --> 00:01:12.320
加入您的本地Java用户组，我们将

00:01:10.310 --> 00:01:17.659
欢迎您，我们将很高兴拥有

00:01:12.320 --> 00:01:19.970
您和我也是GDG集团的负责人

00:01:17.659 --> 00:01:25.430
在爱沙尼亚的聚会上

00:01:19.970 --> 00:01:28.070
小镇，但非常自豪，所以我

00:01:25.430 --> 00:01:30.680
还与伦敦水罐和

00:01:28.070 --> 00:01:32.570
虚拟水罐，我在开发人员中工作

00:01:30.680 --> 00:01:35.409
关系，所以我以

00:01:32.570 --> 00:01:39.500
开发者倡导零周转

00:01:35.409 --> 00:01:41.509
但是，让我们开始吧，所以Java 9 

00:01:39.500 --> 00:01:43.180
辩论这将如何工作的方式是

00:01:41.509 --> 00:01:45.890
我们要扮演好警察坏警察

00:01:43.180 --> 00:01:48.439
我们将采取一些主要

00:01:45.890 --> 00:01:50.299
 Java知识和一些次要Java 9 

00:01:48.439 --> 00:01:51.770
更新，我们中的一个将扮演

00:01:50.299 --> 00:01:53.899
好警察我们中的一个会扮演坏人

00:01:51.770 --> 00:01:57.619
警察，所以好的警察会看一些

00:01:53.899 --> 00:01:59.930
积极的方面具有

00:01:57.619 --> 00:02:01.250
坏警察会看一些

00:01:59.930 --> 00:02:03.890
该功能的某些部分并非如此

00:02:01.250 --> 00:02:06.140
好，陪审团当您听到

00:02:03.890 --> 00:02:08.539
您将投票的利弊

00:02:06.140 --> 00:02:10.640
关于您是否喜欢该功能

00:02:08.539 --> 00:02:14.209
是否使用Java 9或是否是Java 9 

00:02:10.640 --> 00:02:15.319
足以让您迁移

00:02:14.209 --> 00:02:18.379
过去的样子

00:02:15.319 --> 00:02:20.569
如果我是好警察或我是坏警察向你征税

00:02:18.379 --> 00:02:24.260
总是投票支持我所说的一切，因为我

00:02:20.569 --> 00:02:25.879
喜欢赢球，只是无视奥列格

00:02:24.260 --> 00:02:28.280
那可能就是我要说的

00:02:25.879 --> 00:02:30.560
这样在我开始之前就开始

00:02:28.280 --> 00:02:33.019
开始让我们不要参与这场辩论，所以

00:02:30.560 --> 00:02:34.909
斋戒谁兴奋，所以约翰9是

00:02:33.019 --> 00:02:37.219
煮了很长时间，然后

00:02:34.909 --> 00:02:38.900
被释放，有人

00:02:37.219 --> 00:02:40.219
感到兴奋的是有些人没有

00:02:38.900 --> 00:02:42.709
对此感到兴奋

00:02:40.219 --> 00:02:44.870
所以让我们在开始时投票

00:02:42.709 --> 00:02:46.939
会议之前，我们伤害了我们所有的论点

00:02:44.870 --> 00:02:53.000
兴奋是好是坏

00:02:46.939 --> 00:02:55.010
关于约翰，我知道是的，如果你这样做

00:02:53.000 --> 00:02:57.560
爱沙尼亚那将永远不会发生

00:02:55.010 --> 00:03:00.620
永远不会发生，我们可能会有客人

00:02:57.560 --> 00:03:02.930
从某个地方欢迎保罗

00:03:00.620 --> 00:03:05.750
对约翰9感到不高兴，这很友善

00:03:02.930 --> 00:03:10.519
对此版本感到失望的

00:03:05.750 --> 00:03:13.400
人们没事吧，让我们开始吧

00:03:10.519 --> 00:03:15.349
是的模块化房间里的大象

00:03:13.400 --> 00:03:17.419
黑手党房间里的大象

00:03:15.349 --> 00:03:19.669
那么模块化为什么我们需要模块化

00:03:17.419 --> 00:03:20.900
好吧，我们有几个模块化

00:03:19.669 --> 00:03:22.340
我们拥有平台的不同方式

00:03:20.900 --> 00:03:25.370
模块化，我们有应用

00:03:22.340 --> 00:03:27.439
我们真正需要平台的模块化

00:03:25.370 --> 00:03:29.290
模块化，因为方式

00:03:27.439 --> 00:03:32.060
平台已经有很多年了

00:03:29.290 --> 00:03:33.799
需要向后兼容

00:03:32.060 --> 00:03:36.229
变成了真正的大象

00:03:33.799 --> 00:03:37.970
房间对，这是一个巨大的野兽，我们

00:03:36.229 --> 00:03:41.750
需要支持可怕的事情，例如

00:03:37.970 --> 00:03:43.400
喜欢核心棒的炸弹

00:03:41.750 --> 00:03:45.199
百无聊赖

00:03:43.400 --> 00:03:46.519
我们不喜欢clo，但是为什么我们有

00:03:45.199 --> 00:03:48.680
拥有它，因为我们必须支持

00:03:46.519 --> 00:03:50.359
真正需要核心功能的旧应用

00:03:48.680 --> 00:03:52.129
但即使我们不想使用核心

00:03:50.359 --> 00:03:54.109
但我们仍然必须将其作为

00:03:52.129 --> 00:03:56.120
我们的平台，所以我们要做的是

00:03:54.109 --> 00:03:57.590
将平台现代化为模块

00:03:56.120 --> 00:04:00.229
我们可以选择是否要加入

00:03:57.590 --> 00:04:03.199
是否在我们的运行时中并取决于

00:04:00.229 --> 00:04:05.719
从我们的应用程序需要什么

00:04:03.199 --> 00:04:08.150
从它的平台，我们可以捆绑一个新的

00:04:05.719 --> 00:04:09.769
运行时只提供了这样

00:04:08.150 --> 00:04:11.780
我们正在基于

00:04:09.769 --> 00:04:14.659
我们应用程序的需求，而不是

00:04:11.780 --> 00:04:17.209
有一个适合所有人的JVM， 

00:04:14.659 --> 00:04:18.949
大尺寸适合所有JVM 

00:04:17.209 --> 00:04:22.820
要在其上运行的应用程序

00:04:18.949 --> 00:04:25.219
您会在底部看到的工作平台

00:04:22.820 --> 00:04:27.320
这里我们有基于Java的类

00:04:25.219 --> 00:04:28.389
这是基础课

00:04:27.320 --> 00:04:30.129
每个

00:04:28.389 --> 00:04:32.050
所有必须使用的内容都包含

00:04:30.129 --> 00:04:33.460
像您收藏的东西

00:04:32.050 --> 00:04:35.620
如果需要，您需要使用

00:04:33.460 --> 00:04:37.090
我们也有一种Java应用程序

00:04:35.620 --> 00:04:39.280
那里有一些紧凑的配置文件

00:04:37.090 --> 00:04:42.669
可能从其他事物中认识到

00:04:39.280 --> 00:04:45.699
排队我们的依赖关系，所以如果你如果你

00:04:42.669 --> 00:04:47.590
需要特定的捆绑包

00:04:45.699 --> 00:04:50.020
就像模块，我是OS GI人

00:04:47.590 --> 00:04:52.449
同样，如果您需要，这是赫兹

00:04:50.020 --> 00:04:55.120
像我们在这里说的某个模块

00:04:52.449 --> 00:04:57.460
具有该模块将依次执行的脚本

00:04:55.120 --> 00:05:00.069
取决于基础，因此取决于哪个

00:04:57.460 --> 00:05:03.699
您需要的模块将构建此模块

00:05:00.069 --> 00:05:05.860
依赖树好吧，我们处理

00:05:03.699 --> 00:05:08.110
我们在设计事物时就已经有了模块化

00:05:05.860 --> 00:05:10.060
我们画框，我们在

00:05:08.110 --> 00:05:12.189
框，我们在它们之间绘制箭头

00:05:10.060 --> 00:05:15.009
设计以模块化的方式，所以当我们写

00:05:12.189 --> 00:05:17.439
代码我们写得非常平坦好吧，我们

00:05:15.009 --> 00:05:20.620
实际上不要将其推入

00:05:17.439 --> 00:05:22.900
模块化成模块化的方式

00:05:20.620 --> 00:05:25.270
原因到现在为止，我们还没有参加

00:05:22.900 --> 00:05:26.889
现在在我们的运行时中执行任何强制措施

00:05:25.270 --> 00:05:29.229
我们是在编译还是在

00:05:26.889 --> 00:05:31.509
实际上在运行时

00:05:29.229 --> 00:05:34.479
平台将始终执行模块化

00:05:31.509 --> 00:05:37.120
如果，如果

00:05:34.479 --> 00:05:38.710
确定以下内容的模块结构： 

00:05:37.120 --> 00:05:40.930
我们实际上并不依赖那个模块

00:05:38.710 --> 00:05:43.389
同样在我们的运行时，我们无法启动

00:05:40.930 --> 00:05:45.580
我们的运行时，除非所有模块

00:05:43.389 --> 00:05:48.400
目前为该应用程序

00:05:45.580 --> 00:05:50.800
在编译时都非常关键

00:05:48.400 --> 00:05:52.870
在运行期间

00:05:50.800 --> 00:05:55.029
结构必须满足我们的要求

00:05:52.870 --> 00:05:56.560
完全编译或完全运行

00:05:55.029 --> 00:05:59.589
这很重要，但这是

00:05:56.560 --> 00:06:01.870
第一次我们现在有执法了

00:05:59.589 --> 00:06:03.939
我们有模块路径

00:06:01.870 --> 00:06:06.099
上课的路径，所以如果你仍然想

00:06:03.939 --> 00:06:07.900
尽管可以使用类路径

00:06:06.099 --> 00:06:11.080
在幕后一切依旧

00:06:07.900 --> 00:06:13.960
在平台中模块化，因此您无法

00:06:11.080 --> 00:06:15.879
使用对你隐藏的东西

00:06:13.960 --> 00:06:17.650
模块中对您隐藏的是什么

00:06:15.879 --> 00:06:20.110
你有封装什么模块

00:06:17.650 --> 00:06:22.300
导出是其他模块可以使用的

00:06:20.110 --> 00:06:23.020
什么模块取决于它

00:06:22.300 --> 00:06:26.339
要求

00:06:23.020 --> 00:06:29.319
那就是导致模块增长的原因

00:06:26.339 --> 00:06:30.789
如果客户端应用程序在

00:06:29.319 --> 00:06:34.060
类框仍在运行

00:06:30.789 --> 00:06:35.979
模块化JVM，但如果您选择使用

00:06:34.060 --> 00:06:38.560
然后在您的应用程序中使用模块路径

00:06:35.979 --> 00:06:40.810
您的平台和您的

00:06:38.560 --> 00:06:41.940
应用程序将在模块化中运行

00:06:40.810 --> 00:06:45.900
方式，但你不

00:06:41.940 --> 00:06:49.590
 soli需要做两个看起来都不错的哇

00:06:45.900 --> 00:06:52.830
结果不是很痛苦吗

00:06:49.590 --> 00:06:54.360
许多人都听说过的不安全的API 

00:06:52.830 --> 00:06:58.020
大多数可能是框架和

00:06:54.360 --> 00:07:00.810
库不安全的API将要

00:06:58.020 --> 00:07:03.390
对您隐藏这是一个API 

00:07:00.810 --> 00:07:05.580
原本是内部的

00:07:03.390 --> 00:07:07.830
 API，但正如我之前所说， 

00:07:05.580 --> 00:07:09.690
以前是执法的，所以人们

00:07:07.830 --> 00:07:10.680
使用它，实际上是有充分理由的

00:07:09.690 --> 00:07:13.460
因为里面有很棒的东西

00:07:10.680 --> 00:07:15.750
在那里，这使我们的生态系统更加丰富

00:07:13.460 --> 00:07:17.340
让我们做一个演示杰克，我们应该看看

00:07:15.750 --> 00:07:20.280
我们实际上看到了一个演示

00:07:17.340 --> 00:07:25.020
已经知道模块如何调用Java 

00:07:20.280 --> 00:07:26.580
在模块演示中任何陷入困境的人都有

00:07:25.020 --> 00:07:30.450
几个人给我看，我给你看

00:07:26.580 --> 00:07:33.420
演示服务，所以我要去

00:07:30.450 --> 00:07:36.540
转到IntelliJ，让我们清除一些

00:07:33.420 --> 00:07:40.350
所以在IntelliJ中，我现在有

00:07:36.540 --> 00:07:42.750
我有三个模块我有三个j9模块

00:07:40.350 --> 00:07:44.790
在API下旋转0，让我们开始

00:07:42.750 --> 00:07:47.640
消费者消费者是我们的消费者模块

00:07:44.790 --> 00:07:50.190
实际上通过

00:07:47.640 --> 00:07:59.070
一个API现在就是我们的API 

00:07:50.190 --> 00:08:01.080
看一下对吧，API非常

00:07:59.070 --> 00:08:03.000
很简单，这就是我的服务， 

00:08:01.080 --> 00:08:05.940
有一个称为get message的方法

00:08:03.000 --> 00:08:07.440
在我们的模块信息Java中，我们只是导出

00:08:05.940 --> 00:08:10.350
那个包，所以这是一个模块

00:08:07.440 --> 00:08:14.010
包含然后暴露给

00:08:10.350 --> 00:08:17.010
其余模块系统使用者

00:08:14.010 --> 00:08:19.110
我们的消费者在哪里，不，那是我们的

00:08:17.010 --> 00:08:21.510
提供者抱歉，这里的消费者有一个

00:08:19.110 --> 00:08:22.980
单班叫消费者哇，这是

00:08:21.510 --> 00:08:27.720
不是玛丽，是的，不是很好

00:08:22.980 --> 00:08:29.880
好的，消费者只有一个主要

00:08:27.720 --> 00:08:32.160
它在循环调用中旋转的方法

00:08:29.880 --> 00:08:35.130
很棒的服务很棒的服务

00:08:32.160 --> 00:08:36.839
系统打印出柜台外观

00:08:35.130 --> 00:08:39.270
对于计数递增的服务

00:08:36.839 --> 00:08:40.530
我们睡一秒钟，然后打印

00:08:39.270 --> 00:08:42.479
一点都没有出来，所以它很漂亮

00:08:40.530 --> 00:08:43.710
是的，没什么，但是有一点

00:08:42.479 --> 00:08:46.800
在我们中间为您扰流

00:08:43.710 --> 00:08:51.200
不会再谈论下一件事

00:08:46.800 --> 00:08:53.760
是提供者，而拉中的提供者

00:08:51.200 --> 00:08:56.190
拉的提供者所要做的就是

00:08:53.760 --> 00:08:58.949
提供者实施我的服务

00:08:56.190 --> 00:09:01.199
并实现他们获取消息方法

00:08:58.949 --> 00:09:02.490
好的，所以我们有一个提供商

00:09:01.199 --> 00:09:04.800
实施我们拥有的服务

00:09:02.490 --> 00:09:07.529
消费者将很快抓住

00:09:04.800 --> 00:09:08.850
服务，仅此而已，所以我

00:09:07.529 --> 00:09:10.980
要运行它，我什至可以运行它

00:09:08.850 --> 00:09:15.060
使用持久性，所以我们将获得一个代码， 

00:09:10.980 --> 00:09:16.829
像jeribai一样更新它

00:09:15.060 --> 00:09:18.720
加载，现在我们在这里循环

00:09:16.829 --> 00:09:20.579
寻找服务，但没有

00:09:18.720 --> 00:09:22.680
服务在那里，我们如何实际使用

00:09:20.579 --> 00:09:24.389
服务很好，我们用它来服务

00:09:22.680 --> 00:09:26.970
加载程序和服务层实际上是

00:09:24.389 --> 00:09:29.759
是1/6也许是1/4的东西

00:09:26.970 --> 00:09:32.160
像那样的东西，它在那里

00:09:29.759 --> 00:09:33.870
并且模块化系统使用

00:09:32.160 --> 00:09:35.970
我们可以注册的服务加载程序

00:09:33.870 --> 00:09:37.500
事情，我们可以抓住

00:09:35.970 --> 00:09:39.300
那里的服务，所以我要去

00:09:37.500 --> 00:09:41.220
首先要做的是

00:09:39.300 --> 00:09:43.589
确保我们正在使用服务加载器

00:09:41.220 --> 00:09:45.089
所以在消费者和模块中，我是

00:09:43.589 --> 00:09:48.389
要说的是我要说的是

00:09:45.089 --> 00:09:52.850
我们使用特定服务，因此

00:09:48.389 --> 00:09:57.720
将成为英雄转身或API 

00:09:52.850 --> 00:09:59.579
点我的服务，所以我们现在要说

00:09:57.720 --> 00:10:02.189
我们将使用该服务，因此

00:09:59.579 --> 00:10:04.680
我要点击保存，我要重建我的

00:10:02.189 --> 00:10:06.779
我们去那里的应用程序

00:10:04.680 --> 00:10:08.279
重新将生活重新加载到环境中

00:10:06.779 --> 00:10:09.810
没有任何服务，其中之一

00:10:08.279 --> 00:10:11.790
原因很好，我们不是

00:10:09.810 --> 00:10:13.259
实际上是从

00:10:11.790 --> 00:10:15.420
服务加载器，所以我要回来

00:10:13.259 --> 00:10:17.189
在这里我要取消注释这是

00:10:15.420 --> 00:10:19.709
这是一种很棒的新风格

00:10:17.189 --> 00:10:22.199
开发称为开发

00:10:19.709 --> 00:10:23.130
取消编码，您得到的错误少得多

00:10:22.199 --> 00:10:25.920
太神奇了，我不知道为什么会有更多的人

00:10:23.130 --> 00:10:28.500
不要这样做，所以我们去了服务

00:10:25.920 --> 00:10:30.180
加载程序，我们说加载所有服务或

00:10:28.500 --> 00:10:32.610
接口我实际上得到的服务

00:10:30.180 --> 00:10:33.870
我们的服务很糟糕

00:10:32.610 --> 00:10:35.759
通过那个，我们只是尝试打电话

00:10:33.870 --> 00:10:37.500
得到消息，所以我要打

00:10:35.759 --> 00:10:40.620
保存，我要重新加载到我的

00:10:37.500 --> 00:10:41.850
运行时，我们去了它重新加载

00:10:40.620 --> 00:10:43.769
但是我们还是什么也没得到

00:10:41.850 --> 00:10:45.389
返回，那是因为没有服务

00:10:43.769 --> 00:10:49.079
现在已经注册了注册方式

00:10:45.389 --> 00:10:50.279
服务在我的提供程序类中

00:10:49.079 --> 00:10:52.410
我们去提供者

00:10:50.279 --> 00:10:54.420
简单来说，我们有我们的提供者输入

00:10:52.410 --> 00:10:56.430
在模块信息中向您展示了Java 

00:10:54.420 --> 00:10:57.389
我们实际上需要说的是

00:10:56.430 --> 00:10:59.100
说我们要做的是

00:10:57.389 --> 00:11:05.009
要提供

00:10:59.100 --> 00:11:07.740
该类组织点零转刚得到

00:11:05.009 --> 00:11:11.910
摆脱那转身

00:11:07.740 --> 00:11:14.250
点API点我的服务，我们要去

00:11:11.910 --> 00:11:20.519
为了提供这些信息，我们将

00:11:14.250 --> 00:11:21.899
提供零点转向的组织机构

00:11:20.519 --> 00:11:26.009
点周围

00:11:21.899 --> 00:11:27.420
提供者点提供者

00:11:26.009 --> 00:11:29.670
简单，所以我们说我们要

00:11:27.420 --> 00:11:31.230
提供服务，这是我们的

00:11:29.670 --> 00:11:35.370
实施以及将要做什么

00:11:31.230 --> 00:11:36.899
当我保存它并做f9那就是

00:11:35.370 --> 00:11:38.910
要重新加载，突然之间

00:11:36.899 --> 00:11:40.769
我们正在获得服务回馈

00:11:38.910 --> 00:11:43.290
只是返回下划线是什么

00:11:40.769 --> 00:11:45.209
简单提供的消息确实是

00:11:43.290 --> 00:11:46.829
 Java Runtime是隐藏的

00:11:45.209 --> 00:11:48.449
向该服务注册该服务

00:11:46.829 --> 00:11:50.759
服务加载器，然后当我们实际

00:11:48.449 --> 00:11:53.519
由另一个模块由另一个使用

00:11:50.759 --> 00:11:55.680
并实际上对我们进行查找

00:11:53.519 --> 00:11:57.750
我们的服务负担

00:11:55.680 --> 00:11:59.759
服务回来，只是为了证明

00:11:57.750 --> 00:12:03.810
是我可以提供给我们的服务

00:11:59.759 --> 00:12:09.449
提供者放大了想要说的

00:12:03.810 --> 00:12:10.649
假设这是从Plus得到的

00:12:09.449 --> 00:12:13.829
班级糟糕

00:12:10.649 --> 00:12:14.970
飞镖并击中名称，让我们联系一下

00:12:13.829 --> 00:12:18.660
然后，您将获得名称

00:12:14.970 --> 00:12:20.760
哎呀，我们上课了

00:12:18.660 --> 00:12:26.870
来自水的周转或供应商

00:12:20.760 --> 00:12:26.870
池，这就是模块将

00:12:27.410 --> 00:12:32.370
走

00:12:28.620 --> 00:12:34.560
所以这是Java的九个模块

00:12:32.370 --> 00:12:37.050
只是想说更多

00:12:34.560 --> 00:12:40.589
模块不仅在那里可用

00:12:37.050 --> 00:12:42.870
平台，并让我们拥有

00:12:40.589 --> 00:12:44.880
更多的模块化应用程序，但是由于

00:12:42.870 --> 00:12:46.680
模块系统，我敢肯定

00:12:44.880 --> 00:12:48.600
听说过新的发行节奏

00:12:46.680 --> 00:12:50.639
 Java向前发展将是每一个

00:12:48.600 --> 00:12:51.959
六个月，所以明年三月

00:12:50.639 --> 00:12:54.600
有可能被称为

00:12:51.959 --> 00:12:56.850
 18.3发布他们的下一个九月

00:12:54.600 --> 00:12:58.410
要发布18.9的原因

00:12:56.850 --> 00:13:00.509
这是模块的cuz 

00:12:58.410 --> 00:13:02.880
通过拥有一切让我拥有

00:13:00.509 --> 00:13:05.310
作为模块，制作起来要容易得多

00:13:02.880 --> 00:13:07.290
我们的更新并将其推送到

00:13:05.310 --> 00:13:09.209
与它一起进入新的运行时

00:13:07.290 --> 00:13:10.680
在一个模块中知道而无需

00:13:09.209 --> 00:13:12.180
对其他模块的依赖过多

00:13:10.680 --> 00:13:14.970
我们也可以

00:13:12.180 --> 00:13:18.600
一个名为j-link的工具，它使我们能够

00:13:14.970 --> 00:13:20.660
减少使用的运行时大小

00:13:18.600 --> 00:13:23.610
 j-link我们可以说这是我的应用

00:13:20.660 --> 00:13:26.340
为我提供一个Java映像，它将

00:13:23.610 --> 00:13:27.930
只允许您使用平台

00:13:26.340 --> 00:13:29.610
您需要的模块，它将为您提供

00:13:27.930 --> 00:13:31.230
像一张40兆的图片，而不是

00:13:29.610 --> 00:13:33.690
这个巨大的形象，那将会

00:13:31.230 --> 00:13:35.640
允许您运行知道JVM的信息

00:13:33.690 --> 00:13:38.460
与您的应用程序有关

00:13:35.640 --> 00:13:40.110
更快的更小的占位空间

00:13:38.460 --> 00:13:42.750
孵化器，我们将谈论一些

00:13:40.110 --> 00:13:45.000
 HTTP 2之后，但尚未准备就绪，因为

00:13:42.750 --> 00:13:46.680
我们需要更多的社区反馈，但

00:13:45.000 --> 00:13:49.080
现在我们可以做的是释放一个

00:13:46.680 --> 00:13:50.880
模块作为孵化器，将允许

00:13:49.080 --> 00:13:52.830
对于该社区的反馈，然后

00:13:50.880 --> 00:13:55.560
后期我们将其推入主要

00:13:52.830 --> 00:13:57.390
打开JDK，所以不仅要提供模块

00:13:55.560 --> 00:13:59.400
我们以更好的方式

00:13:57.390 --> 00:14:01.500
开发我们的代码，但这也是

00:13:59.400 --> 00:14:03.900
赋予我们所有这些新自由

00:14:01.500 --> 00:14:07.170
更快地发布Java以使其更小

00:14:03.900 --> 00:14:08.730
运行时，实际上你知道玩

00:14:07.170 --> 00:14:10.380
 Java和更多孵化器，所以我

00:14:08.730 --> 00:14:12.350
认为我们应该现在就投票我不

00:14:10.380 --> 00:14:14.870
认为这里有一个坏警察

00:14:12.350 --> 00:14:17.490
那很好

00:14:14.870 --> 00:14:19.620
相当惊人的模块是

00:14:17.490 --> 00:14:21.630
鲑鱼说的很棒，我们有一个

00:14:19.620 --> 00:14:23.340
占用空间更小，发布速度更快

00:14:21.630 --> 00:14:25.440
节奏与无关

00:14:23.340 --> 00:14:28.680
模块，但谁可以得到的功能

00:14:25.440 --> 00:14:31.440
早一点，所以在我们前进之前

00:14:28.680 --> 00:14:33.270
我们需要评估每个功能，而不仅仅是

00:14:31.440 --> 00:14:35.400
通过它给我们或其他人带来什么

00:14:33.270 --> 00:14:37.950
说它给了我们，但实际上是什么

00:14:35.400 --> 00:14:40.020
它为我们解决了一个问题吗？ 

00:14:37.950 --> 00:14:42.990
必须记住内置的模块

00:14:40.020 --> 00:14:45.270
 JDK旨在

00:14:42.990 --> 00:14:49.020
为JDK开发人员解决问题

00:14:45.270 --> 00:14:51.060
这不是在戳刺中，没有任何计划

00:14:49.020 --> 00:14:54.000
设计一个模块化系统来构建

00:14:51.060 --> 00:14:56.280
从零开始的消费者应用程序

00:14:54.000 --> 00:14:59.640
有机会在我们的OSGi 

00:14:56.280 --> 00:15:02.420
对的系统，我们没有选择那么多

00:14:59.640 --> 00:15:03.630
我们当中的人没有选择创造，而是享受

00:15:02.420 --> 00:15:07.530
优秀的

00:15:03.630 --> 00:15:10.560
你是好人，我们中有些人没有

00:15:07.530 --> 00:15:12.690
选择那个，等等模块酱

00:15:10.560 --> 00:15:14.820
真正好的开发问题

00:15:12.690 --> 00:15:18.450
 JDK并执行规则和

00:15:14.820 --> 00:15:20.430
完整的开放式JDK更好

00:15:18.450 --> 00:15:22.649
但是成本是多少，因为它非常

00:15:20.430 --> 00:15:25.440
在语言层面上，这很简单

00:15:22.649 --> 00:15:28.500
就像五个新关键字组成一个新模块

00:15:25.440 --> 00:15:31.019
信息文件，实际上很多痛苦

00:15:28.500 --> 00:15:32.730
将旧项目迁移到Java 9 

00:15:31.019 --> 00:15:34.709
如果您从事未开发的项目

00:15:32.730 --> 00:15:37.620
你从头开始，这是

00:15:34.709 --> 00:15:40.260
很棒，如果您愿意，您会喜欢的

00:15:37.620 --> 00:15:44.279
实际上有一个应用程序是

00:15:40.260 --> 00:15:46.589
几千兆字节几千个文件

00:15:44.279 --> 00:15:48.149
大那么你可能会有一个

00:15:46.589 --> 00:15:50.310
问题，你会遇到一个问题

00:15:48.149 --> 00:15:52.470
构建系统，我们将有一个问题

00:15:50.310 --> 00:15:54.300
拥有一些图书馆的生态系统

00:15:52.470 --> 00:15:56.490
实际上不迁移谁

00:15:54.300 --> 00:15:59.339
没有任何支持或维护

00:15:56.490 --> 00:16:01.440
一切都会给你带来麻烦

00:15:59.339 --> 00:16:04.260
当您对

00:16:01.440 --> 00:16:08.459
您必须知道有一个模块

00:16:04.260 --> 00:16:10.410
迁移路径，因此在迁移之前

00:16:08.459 --> 00:16:12.300
路径有点不清楚

00:16:10.410 --> 00:16:15.000
 Java发行的最后一刻

00:16:12.300 --> 00:16:17.370
 9但目前我们认为这是

00:16:15.000 --> 00:16:18.839
如何进一步迁移的想法

00:16:17.370 --> 00:16:19.860
你想做什么你不想

00:16:18.839 --> 00:16:21.810
升级到开发环境

00:16:19.860 --> 00:16:23.760
立即启动模块上升

00:16:21.810 --> 00:16:25.410
你想做的一切

00:16:23.760 --> 00:16:27.360
如果无法升级，则升级

00:16:25.410 --> 00:16:29.850
生产环境突飞猛进

00:16:27.360 --> 00:16:31.410
因为那是不明智的，所以你想要

00:16:29.850 --> 00:16:33.510
升级您的暂存环境或

00:16:31.410 --> 00:16:35.190
可以尝试的东西

00:16:33.510 --> 00:16:38.160
可以从其他改进中受益

00:16:35.190 --> 00:16:40.140
在约翰福音第9章中，然后您想

00:16:38.160 --> 00:16:42.630
解决最简单的事情

00:16:40.140 --> 00:16:46.529
可能修复有关模块的问题

00:16:42.630 --> 00:16:49.589
系统当前未强制执行

00:16:46.529 --> 00:16:51.510
默认情况下最严格的级别，但是

00:16:49.589 --> 00:16:53.190
您可以根据需要打开它

00:16:51.510 --> 00:16:55.529
需要更多的工作来修复那些地球

00:16:53.190 --> 00:16:57.930
但您可以修正警告，然后

00:16:55.529 --> 00:17:00.839
你最好等一段时间

00:16:57.930 --> 00:17:02.220
直到2018年4月为止的某个地方

00:17:00.839 --> 00:17:04.589
将具有Java的新主要版本

00:17:02.220 --> 00:17:06.120
其次可能是ACA的系统

00:17:04.589 --> 00:17:08.100
将赶上，您可以迁移到

00:17:06.120 --> 00:17:10.140
模块从

00:17:08.100 --> 00:17:12.689
您还可以迁移其他库

00:17:10.140 --> 00:17:14.790
到处走，但要困难得多，所以当

00:17:12.689 --> 00:17:18.000
您考虑模块保留此

00:17:14.790 --> 00:17:20.339
那两个人心中的画面

00:17:18.000 --> 00:17:22.880
他们认为谁是开发商，谁是谁

00:17:20.339 --> 00:17:22.880
一位建筑师

00:17:25.860 --> 00:17:31.299
类似模块的功能

00:17:28.779 --> 00:17:33.970
利益架构关注点各不相同

00:17:31.299 --> 00:17:36.120
很大，但对于开发人员来说，可能是

00:17:33.970 --> 00:17:38.890
很多痛苦，所以好事是

00:17:36.120 --> 00:17:41.700
不安全仍然可以访问，所以我们可以做

00:17:38.890 --> 00:17:43.360
隐藏的东西

00:17:41.700 --> 00:17:47.080
如此模块化

00:17:43.360 --> 00:17:49.270
让我们启动，以便谁思考谁在想

00:17:47.080 --> 00:17:51.850
模块化节省了Java语言

00:17:49.270 --> 00:17:54.340
并且实际上已经使Java 

00:17:51.850 --> 00:17:56.890
语言对未来更具可持续性

00:17:54.340 --> 00:18:01.450
谁认为模块化是一个好选择

00:17:56.890 --> 00:18:03.520
 Java 9中的东西

00:18:01.450 --> 00:18:07.390
好吧，谁相信Java和发布

00:18:03.520 --> 00:18:09.880
我相信迁移并不容易

00:18:07.390 --> 00:18:13.480
嗯，那不是那不是

00:18:09.880 --> 00:18:15.669
问题，但这是答案，不让我们

00:18:13.480 --> 00:18:17.350
走得更远，尽管让我们让我们谈论

00:18:15.669 --> 00:18:20.169
我不会一个权利

00:18:17.350 --> 00:18:21.850
哦，我会给你的

00:18:20.169 --> 00:18:23.289
 yay模块，让我们谈谈其他

00:18:21.850 --> 00:18:25.240
功能，让我们来看一下垃圾

00:18:23.289 --> 00:18:27.970
收集，因为这是东西

00:18:25.240 --> 00:18:29.289
确实将Java与

00:18:27.970 --> 00:18:31.980
时代的开始，我们有了

00:18:29.289 --> 00:18:34.029
托管内存，我们都使用

00:18:31.980 --> 00:18:35.830
应用程序Reese是硬件

00:18:34.029 --> 00:18:38.320
资源和原样的内存

00:18:35.830 --> 00:18:40.720
无限，而且绝对完美，所以

00:18:38.320 --> 00:18:43.480
约翰福音9章讲的是新的

00:18:40.720 --> 00:18:46.450
默认的垃圾收集器称为g1 GC 

00:18:43.480 --> 00:18:48.429
如果您想到Java堆Java 

00:18:46.450 --> 00:18:50.110
你可能会想到一张照片的记忆

00:18:48.429 --> 00:18:52.200
这样的东西你有堆

00:18:50.110 --> 00:18:55.240
它被分隔在不同的区域

00:18:52.200 --> 00:18:57.640
有伊甸园空间，新的

00:18:55.240 --> 00:18:59.860
对象被分配，然后当它们

00:18:57.640 --> 00:19:02.470
如果幸存者活得足够长

00:18:59.860 --> 00:19:04.299
他们被提升到特纳太空

00:19:02.470 --> 00:19:07.000
然后他们成为老一辈

00:19:04.299 --> 00:19:08.890
这里的假设很简单

00:19:07.000 --> 00:19:10.750
已经幸存下来的旧物件

00:19:08.890 --> 00:19:12.990
几个GC周期问题将

00:19:10.750 --> 00:19:15.880
生存更多，所以没有意义

00:19:12.990 --> 00:19:17.860
从整个空间收集记忆

00:19:15.880 --> 00:19:19.090
但最好将其分成

00:19:17.860 --> 00:19:21.279
不同的地区，然后您就可以

00:19:19.090 --> 00:19:23.409
执行较小的垃圾收集并

00:19:21.279 --> 00:19:24.909
节省时间，这样的延迟

00:19:23.409 --> 00:19:29.260
单个垃圾回收周期将过去

00:19:24.909 --> 00:19:32.669
下降，所以现在有了G 1 GC这个概念

00:19:29.260 --> 00:19:35.580
被推到不是极端，而是我的

00:19:32.669 --> 00:19:38.309
更进一步，您希望看到什么

00:19:35.580 --> 00:19:41.340
将堆分成很小的区域

00:19:38.309 --> 00:19:43.169
然后他们都被分配了， 

00:19:41.340 --> 00:19:45.720
对象随机分配在其中

00:19:43.169 --> 00:19:47.159
而且它们仍然具有这种类型

00:19:45.720 --> 00:19:49.529
他们当中会有年轻的物体

00:19:47.159 --> 00:19:52.049
其中一些将是旧物体， 

00:19:49.529 --> 00:19:54.240
对象一直移动，但主体

00:19:52.049 --> 00:19:56.010
好处是垃圾

00:19:54.240 --> 00:19:58.679
收集可以决定有多少个

00:19:56.010 --> 00:20:00.899
它可以在任何地方收集的小区域

00:19:58.679 --> 00:20:02.580
给定的时刻，通过它可以

00:20:00.899 --> 00:20:04.740
控制垃圾这个词是什么

00:20:02.580 --> 00:20:07.470
收集暂停，他可以做

00:20:04.740 --> 00:20:09.539
宏伟的事物首先是潜伏期

00:20:07.470 --> 00:20:13.590
垃圾收集下降第二

00:20:09.539 --> 00:20:16.409
您可以自适应地控制

00:20:13.590 --> 00:20:18.149
不必像

00:20:16.409 --> 00:20:20.610
 JVM选项调整垃圾

00:20:18.149 --> 00:20:22.470
收集实际上是为了调整您的垃圾

00:20:20.610 --> 00:20:24.539
现在收集您想做什么

00:20:22.470 --> 00:20:26.899
只想说这是我的要求

00:20:24.539 --> 00:20:29.429
用于垃圾收集过程，以及

00:20:26.899 --> 00:20:32.639
这是我的要求我有多少空间

00:20:29.429 --> 00:20:35.039
可以牺牲来实现莱顿的

00:20:32.639 --> 00:20:37.350
数字，这都是垃圾

00:20:35.039 --> 00:20:39.630
所需的集合调整

00:20:37.350 --> 00:20:44.370
 g1g很好看，当然还有更多

00:20:39.630 --> 00:20:46.679
为此，但在正常对话中

00:20:44.370 --> 00:20:52.200
可以在那停下来，所以你想看看

00:20:46.679 --> 00:20:53.970
真的很棒，不是吗

00:20:52.200 --> 00:20:56.370
它是如何变成了我们

00:20:53.970 --> 00:20:58.409
是在GDP 6中引入的，因此经过了测试

00:20:56.370 --> 00:21:00.029
这是一项非常成熟的技术

00:20:58.409 --> 00:21:02.220
在很多之前就用过

00:21:00.029 --> 00:21:03.870
公司尝试对它进行测试

00:21:02.220 --> 00:21:05.970
不同的工作负载，并且有效

00:21:03.870 --> 00:21:08.130
漂亮，现在它正在普及

00:21:05.970 --> 00:21:11.070
 jt9中的我们，所以当您运行

00:21:08.130 --> 00:21:12.870
 Java 9上的应用程序，他们将

00:21:11.070 --> 00:21:15.809
可能在

00:21:12.870 --> 00:21:19.260
拥有较小垃圾的条件

00:21:15.809 --> 00:21:22.200
集合暂停它确实折衷了一些

00:21:19.260 --> 00:21:23.700
吞吐量最大愚蠢，因为

00:21:22.200 --> 00:21:26.010
垃圾做一个GC将同时运行

00:21:23.700 --> 00:21:27.539
与应用程序，而不是食物

00:21:26.010 --> 00:21:29.370
您硬件的资源将是

00:21:27.539 --> 00:21:31.380
提供给您，但大多数情况下

00:21:29.370 --> 00:21:33.419
应用，尤其是应用

00:21:31.380 --> 00:21:36.600
延迟很重要的地方

00:21:33.419 --> 00:21:37.660
我认为下一件很伟大的事情

00:21:36.600 --> 00:21:40.330
你的

00:21:37.660 --> 00:21:42.160
是的，所以总结一下，您得到了

00:21:40.330 --> 00:21:46.270
具有卓越性能的更快的内存管理

00:21:42.160 --> 00:21:48.790
应用技巧，因此G 1 GC很好

00:21:46.270 --> 00:21:50.170
一些性能专家说的很好

00:21:48.790 --> 00:21:51.820
是的，一些性能专家说不

00:21:50.170 --> 00:21:53.410
最终，这实际上取决于您

00:21:51.820 --> 00:21:55.630
您需要测试的应用程序

00:21:53.410 --> 00:22:00.010
您的应用程序，但问题是

00:21:55.630 --> 00:22:02.380
 G 1 GC在Java 9中令人兴奋

00:22:00.010 --> 00:22:06.670
其实回到两件事

00:22:02.380 --> 00:22:10.090
这是在JDK 6中引入的

00:22:06.670 --> 00:22:12.700
我五岁的儿子出生时经过测试， 

00:22:10.090 --> 00:22:14.080
在我之前的JDK 7中受支持

00:22:12.700 --> 00:22:16.510
五岁的儿子出生

00:22:14.080 --> 00:22:17.350
正式是您在JDK 9中看到的默认值

00:22:16.510 --> 00:22:19.570
谁在乎

00:22:17.350 --> 00:22:22.240
您可以随时使用它

00:22:19.570 --> 00:22:25.620
在JDK 9之前，只需使用此开关

00:22:22.240 --> 00:22:29.770
如果您使用的是特定的

00:22:25.620 --> 00:22:30.940
您的JVM参数中的GC为19 

00:22:29.770 --> 00:22:34.510
会影响你，因为你要

00:22:30.940 --> 00:22:36.460
继续在JDK 9中使用它，G 1也是如此

00:22:34.510 --> 00:22:38.620
 GC是一件好事，可能是因为

00:22:36.460 --> 00:22:41.470
给您选择是Java很好

00:22:38.620 --> 00:22:43.870
在JDK 9中被杀死的JDK 9很好

00:22:41.470 --> 00:22:45.820
它在JDK 8＆7＆6中

00:22:43.870 --> 00:22:48.610
一直都在那里

00:22:45.820 --> 00:22:51.400
这就是我为什么要使用G 1 GC的观点

00:22:48.610 --> 00:22:53.590
在同意的JDK 9中没什么大不了的

00:22:51.400 --> 00:22:59.260
跟我说，结果不算大

00:22:53.590 --> 00:23:02.110
处理JDK 9好的，这可能会更近

00:22:59.260 --> 00:23:03.370
轻松地相遇并走开

00:23:02.110 --> 00:23:05.530
东欧不同

00:23:03.370 --> 00:23:06.970
所以谁相信这是一个好人

00:23:05.530 --> 00:23:12.460
相信这是一件非常好的事

00:23:06.970 --> 00:23:17.050
 JDK 9甚至是，甚至还可以

00:23:12.460 --> 00:23:19.240
就在下一个你在那个J shell上

00:23:17.050 --> 00:23:23.760
谁都从J的L中消失

00:23:19.240 --> 00:23:27.430
谁喜欢J Shell谁讨厌J Shell 

00:23:23.760 --> 00:23:29.980
对，好的，我很高兴，因为我很好

00:23:27.430 --> 00:23:33.120
警察在这里J壳好吧，让我们停止

00:23:29.980 --> 00:23:35.200
好东西，J shell是个mm头

00:23:33.120 --> 00:23:37.150
合理的人，我知道你可以离开

00:23:35.200 --> 00:23:39.730
你们，因为我是这里的好警察

00:23:37.150 --> 00:23:45.070
所以J shell J shell是

00:23:39.730 --> 00:23:48.850
涟漪代表真正的牛奶计划

00:23:45.070 --> 00:23:50.380
关闭打印Luc知道我们去阅读评估

00:23:48.850 --> 00:23:51.840
打印循环，让我们进入演示

00:23:50.380 --> 00:23:56.350
我们可以

00:23:51.840 --> 00:23:59.380
好的谢谢

00:23:56.350 --> 00:24:01.120
不是那种废除，而是

00:23:59.380 --> 00:24:02.799
抽奖，所以我只要输入J shell 

00:24:01.120 --> 00:24:04.289
使我的轮廓非常好

00:24:02.799 --> 00:24:06.940
从背面可以读懂

00:24:04.289 --> 00:24:08.919
竖起大拇指很好的权利，所以它使我陷入

00:24:06.940 --> 00:24:11.320
在这里，我可以在控制台中

00:24:08.919 --> 00:24:14.230
与JDK对话我可以与Shell对话

00:24:11.320 --> 00:24:16.419
如果我想和JDK交谈，我只是

00:24:14.230 --> 00:24:18.070
像一加二一样简单

00:24:16.419 --> 00:24:20.289
如果我想的话，那会让我三个

00:24:18.070 --> 00:24:21.820
和壳说话，我只放了一个斜线， 

00:24:20.289 --> 00:24:23.169
我放下斜线就不说话

00:24:21.820 --> 00:24:25.840
到JDK，所以我有很多事情

00:24:23.169 --> 00:24:27.370
我可以做的另一件事是

00:24:25.840 --> 00:24:28.779
提到我放一加二的时候

00:24:27.370 --> 00:24:30.279
我不是我不是

00:24:28.779 --> 00:24:31.750
将其分配给变量，所以它是什么

00:24:30.279 --> 00:24:33.700
实际完成的是将其分配给

00:24:31.750 --> 00:24:35.710
如果我给我变一美元

00:24:33.700 --> 00:24:38.529
想做类似int的事情

00:24:35.710 --> 00:24:40.389
 X等于18我要加下划线

00:24:38.529 --> 00:24:43.299
和双下划线，因为我可以加倍

00:24:40.389 --> 00:24:46.120
下划线等于二加三

00:24:43.299 --> 00:24:48.250
二加三我注意到我的控制权

00:24:46.120 --> 00:24:51.100
刚走进那就是为什么我做了那两个

00:24:48.250 --> 00:24:52.629
加三，你得到五，所以现在

00:24:51.100 --> 00:24:53.950
双下划线那里有多酷

00:24:52.629 --> 00:24:54.700
标志着您留下的辉煌

00:24:53.950 --> 00:24:57.879
对我们来说

00:24:54.700 --> 00:24:59.259
我输入斜杠，那给了我

00:24:57.879 --> 00:25:01.600
给我变量当前

00:24:59.259 --> 00:25:03.129
如果我有我们拥有的变量

00:25:01.600 --> 00:25:05.740
想做一些有趣的事情

00:25:03.129 --> 00:25:07.450
您知道的系统操作系统任何人都可以告诉

00:25:05.740 --> 00:25:10.289
我在那里缺少的东西让我放

00:25:07.450 --> 00:25:12.759
在顶部，这里缺少什么

00:25:10.289 --> 00:25:15.610
分号，我们可以，我们可以编码Java 

00:25:12.759 --> 00:25:17.379
没有分号，那有多好

00:25:15.610 --> 00:25:18.610
令人惊讶的是值得付出的工作

00:25:17.379 --> 00:25:21.669
如果没有别的值得等待

00:25:18.610 --> 00:25:22.210
只是看电影，我们穿

00:25:21.669 --> 00:25:28.629
红点

00:25:22.210 --> 00:25:30.659
哎呀，哇，不要尝试/赶上它有多酷

00:25:28.629 --> 00:25:30.659
那

00:25:30.780 --> 00:25:38.520
如果我愿意的话，我会知道有一个公众空话

00:25:34.140 --> 00:25:41.670
你好，然后在这里我可以做

00:25:38.520 --> 00:25:47.280
像系统oops系统点

00:25:41.670 --> 00:25:48.840
点打印我打印然后打招呼

00:25:47.280 --> 00:25:51.000
这一点是因为我正在做多行

00:25:48.840 --> 00:25:53.430
它显然需要一个明显需要的

00:25:51.000 --> 00:25:55.170
分号，所以当我这样做时，我们现在有了

00:25:53.430 --> 00:25:59.160
一种可以输入斜线m的方法

00:25:55.170 --> 00:26:04.200
得到一种方法，我可以斜线编辑说

00:25:59.160 --> 00:26:08.360
一两个闲散的资本会打招呼吗，我们

00:26:04.200 --> 00:26:12.270
得到这个惊人的1970年代的窗口弹出， 

00:26:08.360 --> 00:26:14.280
从这里我可以说你好世界我

00:26:12.270 --> 00:26:15.930
除了那我能说吗，你会

00:26:14.280 --> 00:26:18.420
请注意，实际上

00:26:15.930 --> 00:26:21.060
更新在那里我可以退出我可以执行

00:26:18.420 --> 00:26:24.150
对此致歉， 

00:26:21.060 --> 00:26:26.160
顺便说一句，我们变得空洞

00:26:24.150 --> 00:26:27.780
好吧，我可以做到，我们也可以添加

00:26:26.160 --> 00:26:30.750
类和类似的东西，如果我想

00:26:27.780 --> 00:26:34.190
所以我很兴奋，所以我可以说A级

00:26:30.750 --> 00:26:38.490
我们得到一个我可以说接口的类

00:26:34.190 --> 00:26:40.680
接口B我们可以得到我们的接口

00:26:38.490 --> 00:26:42.030
斜线团队我们得到了我们的类型

00:26:40.680 --> 00:26:45.570
几乎就是您知道使用的

00:26:42.030 --> 00:26:47.610
使用之前使用过的叛军

00:26:45.570 --> 00:26:49.470
其他语言，是的，我们很棒

00:26:47.610 --> 00:26:51.000
我们可以使用那里吗，我认为是

00:26:49.470 --> 00:26:52.740
 Java排斥通讯是我们可以使用的

00:26:51.000 --> 00:26:55.410
以前但是这很好地连接

00:26:52.740 --> 00:26:56.940
直接进入开放的JDK是的，其他

00:26:55.410 --> 00:26:59.520
像你可以检查的东西

00:26:56.940 --> 00:27:01.590
如果我想导入其他东西

00:26:59.520 --> 00:27:04.170
可以只输入列表，我可以看到

00:27:01.590 --> 00:27:07.320
我在JDK中输入的所有内容

00:27:04.170 --> 00:27:08.610
我也可以输入以削减历史记录

00:27:07.320 --> 00:27:11.190
得到我键入的所有内容是否

00:27:08.610 --> 00:27:14.610
到JDK或控制台本身（如果我

00:27:11.190 --> 00:27:17.940
想我可以将其保存为命令

00:27:14.610 --> 00:27:19.740
可以大刀阔斧地进行研究，从而重拾我的状态

00:27:17.940 --> 00:27:22.170
因此，如果我现在输入斜杠PI，则一无所获

00:27:19.740 --> 00:27:24.530
但我能做的是打开命令

00:27:22.170 --> 00:27:27.090
这实际上只是将其保存为

00:27:24.530 --> 00:27:28.530
作为文本文件，现在可以运行

00:27:27.090 --> 00:27:30.150
一切，所以你看到那一秒钟

00:27:28.530 --> 00:27:31.350
维修延迟，然后您就知道了

00:27:30.150 --> 00:27:33.660
一切的创造，然后你看到

00:27:31.350 --> 00:27:35.580
你好，世界，所以J 

00:27:33.660 --> 00:27:38.580
相当不错的另一件事

00:27:35.580 --> 00:27:40.350
其实如果我斜线退出，这是我们的

00:27:38.580 --> 00:27:41.539
这里只有用户venkat行，具体取决于

00:27:40.350 --> 00:27:43.159
怎么样

00:27:41.539 --> 00:27:44.330
您当时感觉可以退出

00:27:43.159 --> 00:27:46.279
您可以通过两种不同的方式

00:27:44.330 --> 00:27:48.049
如果您感到知道，则命令D 

00:27:46.279 --> 00:27:49.220
就像你真的不想要任何人

00:27:48.049 --> 00:27:50.869
与您交谈，如果您感到有点沮丧

00:27:49.220 --> 00:27:51.649
如果您情绪低落，需要一些

00:27:50.869 --> 00:27:55.090
你需要一个拥抱

00:27:51.649 --> 00:27:55.090
只需输入斜杠重音即可说再见

00:27:55.119 --> 00:28:04.519
因此，如果您输入以下内容，我们就可以了

00:28:02.570 --> 00:28:06.799
 J shell，您只需键入打印

00:28:04.519 --> 00:28:09.049
一些非常非常好的东西

00:28:06.799 --> 00:28:12.229
我们变得有点烂了

00:28:09.049 --> 00:28:13.279
它实际上所做的就是如果看

00:28:12.229 --> 00:28:15.710
它为我提供整体的方法

00:28:13.279 --> 00:28:19.220
打印清单，这样我就可以输入

00:28:15.710 --> 00:28:21.590
输入print hello或hell up up 

00:28:19.220 --> 00:28:22.309
您选择，而且您知道很多

00:28:21.590 --> 00:28:23.450
很好，您不必

00:28:22.309 --> 00:28:24.859
 system.out.print Leland的与众不同

00:28:23.450 --> 00:28:26.779
我会说一件事

00:28:24.859 --> 00:28:27.979
绝对很棒， 

00:28:26.779 --> 00:28:29.599
那个马克综合症实际上很棒

00:28:27.979 --> 00:28:30.889
我会说，所以我会在这里标记

00:28:29.599 --> 00:28:32.149
我敢肯定他在海顿之前就说了

00:28:30.889 --> 00:28:33.950
转换者做得非常好

00:28:32.149 --> 00:28:35.359
大约30分钟左右的视频

00:28:33.950 --> 00:28:38.679
他做的一件事是他实际上创造了

00:28:35.359 --> 00:28:41.690
一个带有哈希银行的脚本，并且

00:28:38.679 --> 00:28:43.909
传入J Shell，然后编写脚本

00:28:41.690 --> 00:28:45.739
一些Java代码并通过

00:28:43.909 --> 00:28:47.299
您实际上可以执行J Shell 

00:28:45.739 --> 00:28:48.649
如果您像一个bash脚本或

00:28:47.299 --> 00:28:49.729
如果它抛出一个类似的东西

00:28:48.649 --> 00:28:51.470
例外，我不知道它是否仍然

00:28:49.729 --> 00:28:53.989
也许会引发异常，但是你

00:28:51.470 --> 00:28:55.609
可以忽略它，然后运行

00:28:53.989 --> 00:28:57.649
 Java就像脚本一样，那有多酷

00:28:55.609 --> 00:29:00.109
但是，是的，J Shell很棒

00:28:57.649 --> 00:29:03.769
辉煌的辉煌，为您服务

00:29:00.109 --> 00:29:06.080
是个坏警察，是的，耶瑟尔是

00:29:03.769 --> 00:29:07.789
辉煌，它将改变我们

00:29:06.080 --> 00:29:12.289
帮助人们学习Java和帮助人们

00:29:07.789 --> 00:29:19.009
开始使用Java尤其是小型Java 

00:29:12.289 --> 00:29:21.109
人类的孩子儿童和敏捷是

00:29:19.009 --> 00:29:23.090
同时非常令人惊讶

00:29:21.109 --> 00:29:25.519
很难想象乔会

00:29:23.090 --> 00:29:27.349
改变我们开发软件的方式

00:29:25.519 --> 00:29:29.749
很难像

00:29:27.349 --> 00:29:32.179
很大的程序变成了

00:29:29.749 --> 00:29:33.649
单秀有这个原因

00:29:32.179 --> 00:29:36.009
西蒙（Simon）没有向您展示如何创建

00:29:33.649 --> 00:29:36.009
注解

00:29:36.410 --> 00:29:40.430
没有理由可以发表演讲

00:29:38.720 --> 00:29:43.400
在监狱里，但只需要一点点

00:29:40.430 --> 00:29:44.870
更多的打字，所以这是一个伟大的

00:29:43.400 --> 00:29:46.610
感觉有点花哨

00:29:44.870 --> 00:29:48.350
我个人很想看看

00:29:46.610 --> 00:29:50.420
未来可以连接杰伊的地方

00:29:48.350 --> 00:29:53.440
外壳程序以运行JVM进程Java 

00:29:50.420 --> 00:29:57.350
处理写和执行命令

00:29:53.440 --> 00:29:58.790
在那个过程中我

00:29:57.350 --> 00:30:00.920
据我目前所知，你做不到

00:29:58.790 --> 00:30:03.050
您可以嵌入gesso并创建像

00:30:00.920 --> 00:30:05.360
应用中的控制台，但您必须

00:30:03.050 --> 00:30:06.680
事先考虑一下，如果

00:30:05.360 --> 00:30:12.410
你事先考虑一下

00:30:06.680 --> 00:30:14.420
不算数，是的，我这是一个手势

00:30:12.410 --> 00:30:16.130
这是一个mm头，所有的语言

00:30:14.420 --> 00:30:19.370
现在有了Java 

00:30:16.130 --> 00:30:20.630
是的Java谁相信Jay Shell是

00:30:19.370 --> 00:30:22.340
一个有趣的工具，您可能会

00:30:20.630 --> 00:30:25.040
用它来测试我们的API 

00:30:22.340 --> 00:30:27.470
无需知道支持

00:30:25.040 --> 00:30:29.480
整个浏览器和浏览器ID并执行

00:30:27.470 --> 00:30:34.190
一大堆喜欢的东西

00:30:29.480 --> 00:30:36.380
只是编码的想法很快就好了

00:30:34.190 --> 00:30:39.590
谁在这里使用适当的IDE而没有

00:30:36.380 --> 00:30:42.710
在VI或Emacs中完成Java开发

00:30:39.590 --> 00:30:44.720
年龄和Omar ID支持某种形式

00:30:42.710 --> 00:30:46.430
评价表达词的方式

00:30:44.720 --> 00:30:48.680
像便笺本之类的东西，他们

00:30:46.430 --> 00:30:51.680
知道他们几乎永远不会碰

00:30:48.680 --> 00:30:55.090
杰伊·壳（Jay shell）在实际工作中

00:30:51.680 --> 00:30:55.090
测试球拍之类的

00:30:55.970 --> 00:31:02.250
好吧，所以模块模块是大拇指

00:30:59.490 --> 00:31:05.690
你想不想看到它在抽奖中

00:31:02.250 --> 00:31:09.720
而且我认为为JC开奖已经正确了

00:31:05.690 --> 00:31:11.549
对我来说是50/50，我们无法更新API 

00:31:09.720 --> 00:31:13.020
真的对API更新不满意，所以

00:31:11.549 --> 00:31:15.029
我们都会成为API的好警察

00:31:13.020 --> 00:31:16.500
更新，因为API更新是

00:31:15.029 --> 00:31:19.140
 Java总是很棒

00:31:16.500 --> 00:31:20.309
开发人员，这样您就可以

00:31:19.140 --> 00:31:22.400
演示对，是的，您也可以在这里

00:31:20.309 --> 00:31:25.140
除了你的，我的意思是

00:31:22.400 --> 00:31:28.230
显然，我要向您展示新的API 

00:31:25.140 --> 00:31:30.570
使用花哨的J表演哇

00:31:28.230 --> 00:31:32.390
我现在不想更改他们的投票

00:31:30.570 --> 00:31:34.919
 [掌声] 

00:31:32.390 --> 00:31:36.870
这不是我的机器，所以我的打字会

00:31:34.919 --> 00:31:38.909
有点慢，但我们会设法

00:31:36.870 --> 00:31:40.200
我们时间用完了，请告诉我

00:31:38.909 --> 00:31:41.940
我们需要涵盖其他事情

00:31:40.200 --> 00:31:43.919
因为有很多API 

00:31:41.940 --> 00:31:45.750
第9频道的改善，我们

00:31:43.919 --> 00:31:47.789
不会经历所有的人，我会

00:31:45.750 --> 00:31:49.320
给你看几个我喜欢的

00:31:47.789 --> 00:31:51.419
最多，或者我认为他们是最多的

00:31:49.320 --> 00:31:53.580
富有的影响力也许，我们会看到

00:31:51.419 --> 00:31:56.279
我能做到的一件事

00:31:53.580 --> 00:31:57.570
我们想要Java的年龄合适， 

00:31:56.279 --> 00:31:58.980
每个人都认为这将是

00:31:57.570 --> 00:32:01.440
从事这项工作绝对很棒

00:31:58.980 --> 00:32:03.659
集合文字，因此我们不需要

00:32:01.440 --> 00:32:05.309
创建新的早期列表，然后

00:32:03.659 --> 00:32:09.240
随后的语句填充

00:32:05.309 --> 00:32:11.970
数据，现在我们有了那些集合

00:32:09.240 --> 00:32:13.649
 Java的领导者来了

00:32:11.970 --> 00:32:15.330
那里的便笺收集负责人

00:32:13.649 --> 00:32:17.370
因数方法，因为我们正在谈论

00:32:15.330 --> 00:32:20.039
关于Java，但是我们可以做的事情

00:32:17.370 --> 00:32:22.649
你可以谈谈你可以创建一个

00:32:20.039 --> 00:32:25.169
中的元素列表或一组元素

00:32:22.649 --> 00:32:27.919
一行代码，然后填充

00:32:25.169 --> 00:32:29.669
那是一个功能齐全的

00:32:27.919 --> 00:32:32.909
列表接口的实现

00:32:29.669 --> 00:32:34.770
结束，你可以做一个集合，你只要输入

00:32:32.909 --> 00:32:37.049
离开，你做的元素，你有

00:32:34.770 --> 00:32:39.779
一套你也可以做一张地图

00:32:37.049 --> 00:32:42.179
将只提供密钥和条目

00:32:39.779 --> 00:32:43.830
值连续，它将创建一个

00:32:42.179 --> 00:32:47.549
映射回你的好东西

00:32:43.830 --> 00:32:49.140
这是因为它简化了

00:32:47.549 --> 00:32:50.549
语法也很重要

00:32:49.140 --> 00:32:53.669
那些东西的实现

00:32:50.549 --> 00:32:56.279
课程非常有趣，所以如果我这样做

00:32:53.669 --> 00:32:57.690
这并获得我认为会的课程

00:32:56.279 --> 00:33:01.799
得到谁认为会得到数组的人

00:32:57.690 --> 00:33:06.650
列出一些认为我会得到

00:33:01.799 --> 00:33:08.180
链表很聪明，所以实际上我会得到

00:33:06.650 --> 00:33:10.580
刚刚添加的新实现

00:33:08.180 --> 00:33:13.100
在Java 9中，这是一个不可变的列表

00:33:10.580 --> 00:33:16.040
一要素之一是

00:33:13.100 --> 00:33:18.590
这些实现相当繁重

00:33:16.040 --> 00:33:20.990
经过优化，例如可以存储

00:33:18.590 --> 00:33:22.550
领域中的元素，所以与被动

00:33:20.990 --> 00:33:24.800
不需要在数组中这样做

00:33:22.550 --> 00:33:26.570
访问，因此它只是直接读取元素

00:33:24.800 --> 00:33:28.790
因为它的可变性包含一个

00:33:26.570 --> 00:33:30.530
元素，依此类推，如果您有

00:33:28.790 --> 00:33:32.750
两个要素也进行了优化

00:33:30.530 --> 00:33:34.850
而且有一个n的集合

00:33:32.750 --> 00:33:36.500
要素及进一步

00:33:34.850 --> 00:33:38.030
因此这些收集文字将使

00:33:36.500 --> 00:33:41.270
您的代码更具可读性

00:33:38.030 --> 00:33:42.230
绝对好用那些

00:33:41.270 --> 00:33:43.790
其他有趣的事情

00:33:42.230 --> 00:33:46.040
如果你只是有门课程

00:33:43.790 --> 00:33:47.450
再从那门课上抓住你

00:33:46.040 --> 00:33:52.820
我实际上可以做一个点

00:33:47.450 --> 00:33:54.650
它得到模块模块就可以了

00:33:52.820 --> 00:33:55.850
获取模块，所以如果您不获取模块

00:33:54.650 --> 00:33:57.710
在那里，您实际上会看到可以

00:33:55.850 --> 00:33:59.270
实际看到来自哪个模块

00:33:57.710 --> 00:34:02.600
这是一件很有趣的事情

00:33:59.270 --> 00:34:04.280
在这里知道一个人然后你

00:34:02.600 --> 00:34:07.400
记得你还在上课

00:34:04.280 --> 00:34:09.290
一切都很棒，除此之外

00:34:07.400 --> 00:34:12.350
有几件事是这样的

00:34:09.290 --> 00:34:14.000
约翰八世，我们得到了流API， 

00:34:12.350 --> 00:34:15.860
可选的sanjana，那些真的

00:34:14.000 --> 00:34:17.210
太好了，然后在约翰福音9章中有一个

00:34:15.860 --> 00:34:19.220
几个改进之一

00:34:17.210 --> 00:34:20.860
最喜欢的是流方法

00:34:19.220 --> 00:34:25.130
可选，所以您现在可以做的是

00:34:20.860 --> 00:34:27.919
说1的可选内容，我可以进行直播

00:34:25.130 --> 00:34:29.919
它，我得到了流

00:34:27.919 --> 00:34:31.880
实施，虽然看起来像

00:34:29.919 --> 00:34:35.929
做不合理的事情，因为

00:34:31.880 --> 00:34:37.880
可选为您提供游泳

00:34:35.929 --> 00:34:39.950
映射函数的方法或

00:34:37.880 --> 00:34:43.630
可选容器中的值

00:34:39.950 --> 00:34:46.970
这很重要，所以如果我这样做

00:34:43.630 --> 00:34:49.700
 27:27我在这里做Map函数，所以我

00:34:46.970 --> 00:34:54.679
没有任何应用功能

00:34:49.700 --> 00:34:57.650
说x乘2我会得到什么

00:34:54.679 --> 00:35:00.710
我会得到4我会得到可选的4还是

00:34:57.650 --> 00:35:04.670
 1对我的群众来说太可怕了

00:35:00.710 --> 00:35:07.160
其实我不会，因为流很懒

00:35:04.670 --> 00:35:09.320
现在默认情况下，如果转换可选

00:35:07.160 --> 00:35:12.680
变成溪流，我会变得懒惰

00:35:09.320 --> 00:35:13.940
在我的可选流，所以回来我会

00:35:12.680 --> 00:35:16.150
获取参考管道，我们将

00:35:13.940 --> 00:35:18.279
需要终端操作才能真正

00:35:16.150 --> 00:35:20.140
在评估他们的功能

00:35:18.279 --> 00:35:22.480
如果我只是做正常的事情而提供

00:35:20.140 --> 00:35:26.020
一个可选，我会做一张地图

00:35:22.480 --> 00:35:28.510
立即在这里，我会得到结果

00:35:26.020 --> 00:35:30.339
立即开始，如果您有功能

00:35:28.510 --> 00:35:33.039
您可能会映射功能

00:35:30.339 --> 00:35:34.750
在性能上是昂贵的

00:35:33.039 --> 00:35:37.029
您基本上不需要真的进行评估

00:35:34.750 --> 00:35:39.210
他们很早就可以转换

00:35:37.029 --> 00:35:41.500
可选茶流非常非常容易

00:35:39.210 --> 00:35:44.220
存在的另一个很酷的东西

00:35:41.500 --> 00:35:44.220
可选的

00:35:44.250 --> 00:35:50.200
什么是空的，让我们做空的

00:35:47.640 --> 00:35:52.690
以前我们有一个叫做if的方法

00:35:50.200 --> 00:35:54.819
存在的功能

00:35:52.690 --> 00:35:56.619
仅当

00:35:54.819 --> 00:35:59.589
现在可选值​​存在

00:35:56.619 --> 00:36:02.710
可以有两种方法

00:35:59.589 --> 00:36:06.520
参数，它被称为如果

00:36:02.710 --> 00:36:08.349
现在，否则需要两个

00:36:06.520 --> 00:36:13.150
功能，所以如果它存在，那么我们

00:36:08.349 --> 00:36:16.630
有功能，我认为我们

00:36:13.150 --> 00:36:21.220
在这里需要这种副作用吗？ 

00:36:16.630 --> 00:36:24.970
与喝是打印X，如果它是

00:36:21.220 --> 00:36:29.369
不那么我们只有供应商，我们

00:36:24.970 --> 00:36:32.680
确实打印为空，我希望这行得通

00:36:29.369 --> 00:36:36.809
空的你永远不知道它是否行不通

00:36:32.680 --> 00:36:36.809
你知道为什么，因为我们在J秀中

00:36:36.990 --> 00:36:41.770
爱我爱我爱的方式

00:36:40.150 --> 00:36:44.020
大概花了四次

00:36:41.770 --> 00:36:47.520
你实际上是笑脸而不是

00:36:44.020 --> 00:36:52.150
安静的东西我是相当乐观的人

00:36:47.520 --> 00:36:54.490
我很少是一个坏警察，所以有一个

00:36:52.150 --> 00:36:57.880
流API上的几件事，如果

00:36:54.490 --> 00:37:00.849
我参加了直播，如果要输入

00:36:57.880 --> 00:37:03.819
正确，然后我们将

00:37:00.849 --> 00:37:05.680
现在有1到10 

00:37:03.819 --> 00:37:08.859
 while元素和take while元素

00:37:05.680 --> 00:37:11.950
他们也参加了

00:37:08.859 --> 00:37:14.020
所有其他流实现以及现在

00:37:11.950 --> 00:37:16.270
我们也将它们内置在JDK中

00:37:14.020 --> 00:37:21.160
所以说我们可以删除元素直到

00:37:16.270 --> 00:37:25.890
满足特定条件且X大于

00:37:21.160 --> 00:37:28.100
 5之后，我们将为每个

00:37:25.890 --> 00:37:35.060
将打印

00:37:28.100 --> 00:37:36.920
当我们看到这个元素时， 

00:37:35.060 --> 00:37:38.930
前五个元素也可以

00:37:36.920 --> 00:37:40.730
从中吸收许多元素

00:37:38.930 --> 00:37:43.070
您的信息流，如果您只是

00:37:40.730 --> 00:37:44.390
需要说像五个要素，但不是

00:37:43.070 --> 00:37:46.310
这五个要素，但就像你需要

00:37:44.390 --> 00:37:48.140
进行事件，直到出现某种情况

00:37:46.310 --> 00:37:50.000
例如遇到您要跳过

00:37:48.140 --> 00:37:53.750
重复事件或其他

00:37:50.000 --> 00:37:54.740
流API也得到了增强

00:37:53.750 --> 00:37:57.950
我喜欢这件事

00:37:54.740 --> 00:37:59.090
其实就是拿墙，例如

00:37:57.950 --> 00:38:00.080
如果您实际上有无限的流

00:37:59.090 --> 00:38:01.550
而你不希望它继续下去

00:38:00.080 --> 00:38:02.900
运行并运行您

00:38:01.550 --> 00:38:04.370
可能会说我要花一会儿

00:38:02.900 --> 00:38:05.660
满足一些其他条件，然后

00:38:04.370 --> 00:38:07.340
当我有十亿的命中

00:38:05.660 --> 00:38:08.690
是的，那么你就停止那无限的流

00:38:07.340 --> 00:38:10.340
你知道我要杀死一个进程

00:38:08.690 --> 00:38:13.250
杀死那条溪流

00:38:10.340 --> 00:38:15.380
是的，还有有趣的

00:38:13.250 --> 00:38:17.060
添加的是迭代

00:38:15.380 --> 00:38:19.400
您可以做适当的方法

00:38:17.060 --> 00:38:21.140
迭代，我们需要检查

00:38:19.400 --> 00:38:23.480
语法，所以您从

00:38:21.140 --> 00:38:25.610
起始值，然后进行增量

00:38:23.480 --> 00:38:28.940
步骤，然后您指定一个条件

00:38:25.610 --> 00:38:30.650
在约翰一世之前， 

00:38:28.940 --> 00:38:33.530
这样做是因为没有迭代

00:38:30.650 --> 00:38:36.290
做到这一点的方法，但现在我们可以做到这一点

00:38:33.530 --> 00:38:43.360
如果小于10，那么我们

00:38:36.290 --> 00:38:43.360
每个人都会打印它们， 

00:38:51.080 --> 00:39:01.020
另一种方法是查看正确的ID 

00:38:57.330 --> 00:39:03.480
会建议我这样做，我应该

00:39:01.020 --> 00:39:06.810
知道这就像一个for循环，但是

00:39:03.480 --> 00:39:09.060
现在您可以正常生成流

00:39:06.810 --> 00:39:11.430
喜欢你，因为你有一些

00:39:09.060 --> 00:39:13.380
条件，然后从

00:39:11.430 --> 00:39:15.510
值一个我有步骤，这是一个

00:39:13.380 --> 00:39:17.910
相当有趣的API 

00:39:15.510 --> 00:39:19.770
当地有一些改进

00:39:17.910 --> 00:39:22.470
数据时间有一些改善

00:39:19.770 --> 00:39:24.720
对于流程处理流程

00:39:22.470 --> 00:39:27.510
流程管理很有趣

00:39:24.720 --> 00:39:29.550
因为以前在Java 9中是如此混乱

00:39:27.510 --> 00:39:31.680
然后我们将向您展示那件事

00:39:29.550 --> 00:39:33.480
然后我们转到下一个下一个

00:39:31.680 --> 00:39:35.610
东西也有并发

00:39:33.480 --> 00:39:36.810
改进，完全是未来

00:39:35.610 --> 00:39:39.930
还有一些新方法

00:39:36.810 --> 00:39:41.550
像流这样的反应性类，所以我们

00:39:39.930 --> 00:39:45.210
可以更接近反应性

00:39:41.550 --> 00:39:47.220
主要在jdk 18 3中编程或

00:39:45.210 --> 00:39:51.420
无论版本最终是

00:39:47.220 --> 00:39:56.280
与过程的过程句柄有

00:39:51.420 --> 00:40:00.300
新课，你可以做这个过程

00:39:56.280 --> 00:40:02.070
处理当前你可以做的子

00:40:00.300 --> 00:40:04.230
流程管理相当容易，所以您

00:40:02.070 --> 00:40:10.020
可以获得当前流程，然后

00:40:04.230 --> 00:40:18.900
执行一些信息并获取一些参数

00:40:10.020 --> 00:40:22.280
但是你可以得到

00:40:18.900 --> 00:40:24.300
任何可以获取流程的流程

00:40:22.280 --> 00:40:26.010
 Java代码中的表示形式，因此，如果

00:40:24.300 --> 00:40:28.470
您处理子流程，或者

00:40:26.010 --> 00:40:30.450
需要检查您可以的任何参数

00:40:28.470 --> 00:40:32.880
与木丹工艺区别很大

00:40:30.450 --> 00:40:34.980
更容易，这也是跨平台的

00:40:32.880 --> 00:40:37.020
相当不错，因为现在

00:40:34.980 --> 00:40:38.760
一切都在docker中运行，所以现在我们

00:40:37.020 --> 00:40:41.520
特别需要跨平台

00:40:38.760 --> 00:40:43.620
事情有很多改进

00:40:41.520 --> 00:40:47.700
我个人最喜欢的是，现在我们可以

00:40:43.620 --> 00:40:50.040
在其中读取utf-8中的属性文件

00:40:47.700 --> 00:40:52.560
正是一种支持这一点的方法

00:40:50.040 --> 00:40:53.700
但我们可以这样做，所以如果您能找到它

00:40:52.560 --> 00:40:56.550
太酷了

00:40:53.700 --> 00:41:00.060
不支持下划线

00:40:56.550 --> 00:41:01.080
现在输入东西是不合理的

00:41:00.060 --> 00:41:03.890
像这样

00:41:01.080 --> 00:41:06.810
如果他入睡会发生

00:41:03.890 --> 00:41:08.340
例外权，没有我没有的类型

00:41:06.810 --> 00:41:10.590
知道没有键盘关键字

00:41:08.340 --> 00:41:13.350
如果我只对两个下划线做

00:41:10.590 --> 00:41:15.630
像西蒙一样，我的名字是

00:41:13.350 --> 00:41:19.230
没有变量类型推断

00:41:15.630 --> 00:41:21.150
足够，我们会做，但是你

00:41:19.230 --> 00:41:22.650
可以使用两个关键字，所以您将

00:41:21.150 --> 00:41:24.680
检查您的源代码是否为单个

00:41:22.650 --> 00:41:27.510
下划线，然后你可以穿

00:41:24.680 --> 00:41:28.800
其他API语言方面的改进

00:41:27.510 --> 00:41:30.870
可以在

00:41:28.800 --> 00:41:32.730
现在使用默认界面

00:41:30.870 --> 00:41:34.140
您可以使用私有方法中的方法

00:41:32.730 --> 00:41:37.790
实际上在你的逻辑上

00:41:34.140 --> 00:41:40.170
界面很棒，而且

00:41:37.790 --> 00:41:43.920
还有其他几件事

00:41:40.170 --> 00:41:45.960
哦，让我检查一下是否可以使用

00:41:43.920 --> 00:41:47.280
有资源，这太棒了，这是

00:41:45.960 --> 00:41:49.470
不是您使用的API改进语言

00:41:47.280 --> 00:41:51.420
修剪他们现在尝试使用资源块

00:41:49.470 --> 00:41:53.370
您可以有效地使用最终变量

00:41:51.420 --> 00:41:57.030
尝试使用资源，这样您就不会

00:41:53.370 --> 00:41:58.920
需要在这一点内声明它们

00:41:57.030 --> 00:42:01.260
 try块的行，但是您可以

00:41:58.920 --> 00:42:03.060
将它们声明在上方某处，然后

00:42:01.260 --> 00:42:05.220
使用它们在尝试中引用它们

00:42:03.060 --> 00:42:07.140
资源块，它们将被关闭

00:42:05.220 --> 00:42:09.540
在尝试结束时自动

00:42:07.140 --> 00:42:11.310
块，使代码更多

00:42:09.540 --> 00:42:15.360
可读性强，但很难显示

00:42:11.310 --> 00:42:16.770
 JSON，但我们仍然非常兴奋

00:42:15.360 --> 00:42:23.640
对于for API 

00:42:16.770 --> 00:42:25.380
改进好吧，所以在这里好吧， 

00:42:23.640 --> 00:42:30.840
最后几件事，我们将谈论

00:42:25.380 --> 00:42:34.260
关于HTTP到HTTPS项目而不是

00:42:30.840 --> 00:42:35.520
在完整的完整JDK中，这是什么

00:42:34.260 --> 00:42:37.200
我之前提到过，所以我在哪里谈论

00:42:35.520 --> 00:42:38.400
太久了，这是你的幻灯片

00:42:37.200 --> 00:42:40.680
就像我不知道你为什么选择这个

00:42:38.400 --> 00:42:43.350
此页面是完整图片

00:42:40.680 --> 00:42:47.040
谷歌搜索生气的时髦，这是

00:42:43.350 --> 00:42:49.320
因为jason-- jason--库

00:42:47.040 --> 00:42:51.540
和杰森操纵没有做到这一点

00:42:49.320 --> 00:42:52.800
进入jdk 9，这非常好，因为

00:42:51.540 --> 00:42:54.300
我们有很多第三方

00:42:52.800 --> 00:42:56.130
实现，您可以选择

00:42:54.300 --> 00:43:00.090
无论我目前的个人身份是什么

00:42:56.130 --> 00:43:02.160
沼泽，我认为是Square，但是，是的

00:43:00.090 --> 00:43:04.650
赶时髦的人可能会对你生气

00:43:02.160 --> 00:43:08.310
保存最好直到最后

00:43:04.650 --> 00:43:11.790
 html5 Java文档，它是可搜索的

00:43:08.310 --> 00:43:15.450
是的，您无法输入

00:43:11.790 --> 00:43:16.800
等一下，看看这个小搜寻框

00:43:15.450 --> 00:43:18.210
在这边你可以输入一些东西

00:43:16.800 --> 00:43:19.830
在今天，我想你实际上可以

00:43:18.210 --> 00:43:21.150
比如说我的未来

00:43:19.830 --> 00:43:24.030
认为你可以做资本C资本

00:43:21.150 --> 00:43:25.860
 F没关系，可以算是资本C资本

00:43:24.030 --> 00:43:27.090
 F实际上，它实际上会进行搜索

00:43:25.860 --> 00:43:30.780
对于完好的期货，我很漂亮

00:43:27.090 --> 00:43:32.310
确保这样做，是的，你可以

00:43:30.780 --> 00:43:35.250
几乎可以搜索任何东西

00:43:32.310 --> 00:43:39.890
想要被称为智能搜索，是的

00:43:35.250 --> 00:43:39.890
欢迎来到2005年

00:43:40.160 --> 00:43:43.680
无论如何，还剩下几分钟

00:43:42.900 --> 00:43:46.560
还剩几分钟

00:43:43.680 --> 00:43:48.240
还有两分钟，所以可能有任何问题

00:43:46.560 --> 00:43:50.040
在狮子座提问之前，因为

00:43:48.240 --> 00:43:52.050
人们开始离开让我们做

00:43:50.040 --> 00:43:53.460
另一个，所以在有一个之前

00:43:52.050 --> 00:43:55.860
几个不兴奋的人

00:43:53.460 --> 00:44:00.990
关于伽玛9，让我们再试一次

00:43:55.860 --> 00:44:05.400
谁对Java 9发布感到兴奋

00:44:00.990 --> 00:44:08.130
认为这是一条中等曲线

00:44:05.400 --> 00:44:12.030
他们走的时候有一些

00:44:08.130 --> 00:44:13.320
以前，但我会认为J，所以我会说

00:44:12.030 --> 00:44:16.260
我会非常感谢大家

00:44:13.320 --> 00:44:18.230
对于出现，我们喜欢在

00:44:16.260 --> 00:44:20.250
 JavaOne，谢谢您的整个房间

00:44:18.230 --> 00:44:21.780
请可以请你投票

00:44:20.250 --> 00:44:23.250
对于我们的会议来说太棒了

00:44:21.780 --> 00:44:24.840
我不会像我以前那样知道

00:44:23.250 --> 00:44:26.010
走在伙计们告诉我， 

00:44:24.840 --> 00:44:29.130
黄色和红色按钮不

00:44:26.010 --> 00:44:30.000
实际工作，是的，如果你觉得

00:44:29.130 --> 00:44:31.290
按下绿色按钮会

00:44:30.000 --> 00:44:33.530
非常感谢你

00:44:31.290 --> 00:44:33.530
许多

00:44:35.990 --> 00:44:41.609
如果您不喜欢演示文稿

00:44:38.930 --> 00:44:44.540
您可以使用J rebel赎回您的六十岁

00:44:41.609 --> 00:44:44.540
分钟前谢谢

