WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.120 --> 00:00:09.990
对你们来说，这次会议是什么

00:00:06.450 --> 00:00:12.570
如果我们在Java 8中很酷，在Java 9中又很新

00:00:09.990 --> 00:00:13.500
最后有时间，我会告诉你一个

00:00:12.570 --> 00:00:15.180
几个演示

00:00:13.500 --> 00:00:18.960
如果没有，我们将尽一切努力

00:00:15.180 --> 00:00:21.660
幻灯片中的内容如此标准

00:00:18.960 --> 00:00:24.690
当我谈论9中的内容时免责声明

00:00:21.660 --> 00:00:26.850
这些是我们目前计划的主题

00:00:24.690 --> 00:00:29.520
改变，所以这不是一个承诺，而是

00:00:26.850 --> 00:00:34.199
只是目前的计划好，不要写

00:00:29.520 --> 00:00:35.970
基于关于我自己的合同

00:00:34.199 --> 00:00:38.850
产品管理总监

00:00:35.970 --> 00:00:42.149
我与Oracle的Java平台组

00:00:38.850 --> 00:00:44.700
自加入以来一直负责JDK 

00:00:42.149 --> 00:00:46.980
甲骨文通过参议院职位使我

00:00:44.700 --> 00:00:49.890
是那些大量加入的人之一

00:00:46.980 --> 00:00:53.040
 2010年之前，我在Sun工作

00:00:49.890 --> 00:00:54.899
微系统支持管理

00:00:53.040 --> 00:00:57.480
 Java团队也不是直接与

00:00:54.899 --> 00:01:00.090
当时和之前的JDK 

00:00:57.480 --> 00:01:02.370
在佛罗里达工作了一点

00:01:00.090 --> 00:01:05.280
麻省理工学院的MBA和系统工程

00:01:02.370 --> 00:01:06.689
如果发生我的大学灌肠学位

00:01:05.280 --> 00:01:11.369
名字没有放弃它不是

00:01:06.689 --> 00:01:14.579
真的从这里开始所以第一部分

00:01:11.369 --> 00:01:17.159
是Java 8的最大更新之一

00:01:14.579 --> 00:01:20.849
曾经是主要语言

00:01:17.159 --> 00:01:22.319
博士编辑多布斯这个实际上是

00:01:20.849 --> 00:01:24.270
我最骄傲的一件事

00:01:22.319 --> 00:01:27.420
那是团队的一部分

00:01:24.270 --> 00:01:29.279
现在使用JDK 8 

00:01:27.420 --> 00:01:32.399
版本的JDK，我将给出

00:01:29.279 --> 00:01:35.849
你一个非常丰富的内容有多少人

00:01:32.399 --> 00:01:39.060
这是我在的开发人员好

00:01:35.849 --> 00:01:47.170
正确的会议，所以这里有多少人

00:01:39.060 --> 00:01:53.080
正在使用Java 8好的，最多七个

00:01:47.170 --> 00:01:56.380
六五四三二不要以为耻

00:01:53.080 --> 00:01:58.630
现在有一个人在那里，所以

00:01:56.380 --> 00:02:02.350
对于那些在Java 7中使用过的人

00:01:58.630 --> 00:02:03.910
或以后这些将是新的

00:02:02.350 --> 00:02:06.190
使用Java 8我想你会

00:02:03.910 --> 00:02:10.840
看到这里有八个人的一部分

00:02:06.190 --> 00:02:14.980
尝试了JDK九种早期访问方式，为什么不这样做

00:02:10.840 --> 00:02:17.459
你首先我们会经历它，所以让我

00:02:14.980 --> 00:02:19.900
告诉你一些有关JDK 8和

00:02:17.459 --> 00:02:21.160
还有很多，但是你

00:02:19.900 --> 00:02:23.850
知道这些是最有趣的

00:02:21.160 --> 00:02:27.580
部分土地表达

00:02:23.850 --> 00:02:29.769
默认方法，方法引用和

00:02:27.580 --> 00:02:31.780
白天API的简要概述和

00:02:29.769 --> 00:02:33.730
那我就给你视力表X 

00:02:31.780 --> 00:02:36.910
所有其他功能，以便

00:02:33.730 --> 00:02:41.140
你可以去找到更多关于它的

00:02:36.910 --> 00:02:45.850
第一部分任何与这里进行编程的人

00:02:41.140 --> 00:02:47.290
 JavaScript，Ruby或Python可以

00:02:45.850 --> 00:02:50.640
您熟悉lambda表达式

00:02:47.290 --> 00:02:53.230
正确的想法是您可以传递数据

00:02:50.640 --> 00:02:56.680
抱歉您可以通过行为

00:02:53.230 --> 00:02:58.269
因为您可以传递数据，所以每个人的

00:02:56.680 --> 00:03:01.030
熟悉我的概念

00:02:58.269 --> 00:03:04.299
变量，我要在其中输入一个数字

00:03:01.030 --> 00:03:06.190
有数据就是lambda的想法

00:03:04.299 --> 00:03:09.269
表达式是我可以做到的

00:03:06.190 --> 00:03:13.150
行为不仅是数据，还包括现在的行为

00:03:09.269 --> 00:03:16.090
例如，这是使用新

00:03:13.150 --> 00:03:19.180
如果我想增强循环功能

00:03:16.090 --> 00:03:21.610
删除集合中的所有人

00:03:19.180 --> 00:03:25.030
大于18并在寻找您

00:03:21.610 --> 00:03:27.390
像只有18岁以下的人一样知道

00:03:25.030 --> 00:03:30.700
我会使用此构造将其删除吗

00:03:27.390 --> 00:03:33.400
在增强的for循环运算符中

00:03:30.700 --> 00:03:36.489
没有任何方法可以调出

00:03:33.400 --> 00:03:37.600
所以如果我想尝试这个权利，这是

00:03:36.489 --> 00:03:40.570
我只是给你看一点

00:03:37.600 --> 00:03:43.720
 Lambda如何改变

00:03:40.570 --> 00:03:45.310
设计API的方式，所以如果我想做

00:03:43.720 --> 00:03:47.799
我实际上必须去

00:03:45.310 --> 00:03:50.350
切换回原来的长格式

00:03:47.799 --> 00:03:53.340
在使用我的JDK 5之前可用

00:03:50.350 --> 00:03:57.340
迭代器，这是因为我需要

00:03:53.340 --> 00:03:59.560
迭代器删除按钮，所以我刚刚添加了

00:03:57.340 --> 00:04:00.790
很多样板才能

00:03:59.560 --> 00:04:05.230
只是删除一些

00:04:00.790 --> 00:04:09.370
对我的收藏来说，有一个更好的选择

00:04:05.230 --> 00:04:11.010
但直到JDK 8之前，这真的很难

00:04:09.370 --> 00:04:15.010
以正确的方式做到这一点

00:04:11.010 --> 00:04:17.769
理想情况下，我们想要的是那里

00:04:15.010 --> 00:04:20.380
成为某种可以

00:04:17.769 --> 00:04:23.110
让我传递行为，然后

00:04:20.380 --> 00:04:26.169
对于集合的设计师

00:04:23.110 --> 00:04:30.130
提供一个称为remove的虚拟方法

00:04:26.169 --> 00:04:32.020
如果可以，请通过

00:04:30.130 --> 00:04:34.479
在一个集合中并通过

00:04:32.020 --> 00:04:35.949
谓词，那么我该怎么办， 

00:04:34.479 --> 00:04:39.460
它会神奇地去收集

00:04:35.949 --> 00:04:42.340
并删除我们现在可以拥有的所有人

00:04:39.460 --> 00:04:46.030
是在JDK 7中创建的，但是

00:04:42.340 --> 00:04:47.770
使用起来非常痛苦，因为

00:04:46.030 --> 00:04:49.870
通过这种行为的唯一方法

00:04:47.770 --> 00:04:52.660
知道这里是收集人

00:04:49.870 --> 00:04:54.070
一堆人，然后我会

00:04:52.660 --> 00:04:58.030
必须写所有这些

00:04:54.070 --> 00:05:00.910
通过该功能的样板

00:04:58.030 --> 00:05:04.090
这是很多东西的代码

00:05:00.910 --> 00:05:06.570
非常简单，现实是我们没有

00:05:04.090 --> 00:05:08.770
编写集合API的人

00:05:06.570 --> 00:05:10.419
不觉得这是

00:05:08.770 --> 00:05:12.699
每个人都将使用，因此

00:05:10.419 --> 00:05:19.810
我没有删除的收藏集80 

00:05:12.699 --> 00:05:23.409
如果现在这里所有的东西都是绿色的

00:05:19.810 --> 00:05:29.500
真正使用lambdas的样板，你可以

00:05:23.409 --> 00:05:33.340
重写这个我猜对了删除人

00:05:29.500 --> 00:05:36.909
那么对于每个人来说

00:05:33.340 --> 00:05:38.740
操作权规大于18 

00:05:36.909 --> 00:05:39.400
如果这是真的，你将要做

00:05:38.740 --> 00:05:43.320
每个人都可以

00:05:39.400 --> 00:05:47.560
从集合中删除它们，这样

00:05:43.320 --> 00:05:49.139
现在你可以通过行为

00:05:47.560 --> 00:05:54.699
我将与他们每个人做

00:05:49.139 --> 00:05:57.039
在我可以传递数据之前，这不是

00:05:54.699 --> 00:05:59.289
只是试图使代码看起来

00:05:57.039 --> 00:06:03.669
让我们来展示一下

00:05:59.289 --> 00:06:07.300
任何人都可以使用更复杂的示例

00:06:03.669 --> 00:06:09.690
这段代码只是通过查看来做什么

00:06:07.300 --> 00:06:09.690
快点

00:06:12.959 --> 00:06:20.110
它在我的人中找到

00:06:16.449 --> 00:06:23.169
仅从男性收集

00:06:20.110 --> 00:06:25.569
最高的重量会扔掉

00:06:23.169 --> 00:06:27.580
你知道像女性一样

00:06:25.569 --> 00:06:29.889
你们中的一些人知道阅读

00:06:27.580 --> 00:06:32.830
那个权利，如果你注意到我不是

00:06:29.889 --> 00:06:36.099
只是告诉你我该怎么办

00:06:32.830 --> 00:06:38.529
你告诉我按照什么顺序去做

00:06:36.099 --> 00:06:42.369
集合在一个位置迭代一个人

00:06:38.529 --> 00:06:48.249
正确的时间让性别变得正确

00:06:42.369 --> 00:06:50.829
得到最大值，我们可以使用

00:06:48.249 --> 00:06:52.779
 lambdas看起来有点像的东西

00:06:50.829 --> 00:06:56.800
有点像问题陈述

00:06:52.779 --> 00:07:00.579
正确地将人员列表过滤掉

00:06:56.800 --> 00:07:04.449
你认识的每个人都过滤男性

00:07:00.579 --> 00:07:06.999
然后在地图上听到

00:07:04.449 --> 00:07:08.979
表达式Map缩小这是地图

00:07:06.999 --> 00:07:11.949
一部分，我有一堆人

00:07:08.979 --> 00:07:14.829
需要将其映射到某个东西，我是

00:07:11.949 --> 00:07:16.029
说去看看那个等待

00:07:14.829 --> 00:07:18.189
我本来可以看年龄的

00:07:16.029 --> 00:07:20.110
没关系，那是地图的一部分

00:07:18.189 --> 00:07:21.909
然后我要减少它并说

00:07:20.110 --> 00:07:23.019
现在而不是收集

00:07:21.909 --> 00:07:25.719
我将要收集的人

00:07:23.019 --> 00:07:27.839
映射后的权重

00:07:25.719 --> 00:07:33.309
说只给我最大就减少它

00:07:27.839 --> 00:07:35.019
好吧，现在看起来还不错

00:07:33.309 --> 00:07:36.459
事实是，如果这就是我们

00:07:35.019 --> 00:07:38.529
要摆脱lambda表达式

00:07:36.459 --> 00:07:40.110
在这里要做很多工作

00:07:38.529 --> 00:07:42.309
我们不会仅仅为此而做

00:07:40.110 --> 00:07:44.050
是什么使得它更有趣？ 

00:07:42.309 --> 00:07:46.809
如果您要重写此事件

00:07:44.050 --> 00:07:48.849
因为这仍然依序进行

00:07:46.809 --> 00:07:51.129
一次一个人做

00:07:48.849 --> 00:07:54.009
顺序地，如果你想写

00:07:51.129 --> 00:07:55.479
这是并行的，所以如果你有一个

00:07:54.009 --> 00:07:57.039
一堆不同的处理器，你可以

00:07:55.479 --> 00:08:00.669
让某些处理器处理一半的

00:07:57.039 --> 00:08:02.079
其他处理器JDK 7上的collection 

00:08:00.669 --> 00:08:05.349
我们介绍了一种叫做叉子的东西

00:08:02.079 --> 00:08:06.550
加入框架，这差不多

00:08:05.349 --> 00:08:07.989
允许你那样做

00:08:06.550 --> 00:08:09.519
你会说一个问题

00:08:07.989 --> 00:08:11.499
我要把它切成小块

00:08:09.519 --> 00:08:13.989
件，我要让每个

00:08:11.499 --> 00:08:18.159
处理器，或者您知道要处理它的一部分

00:08:13.989 --> 00:08:20.379
而如果我想在

00:08:18.159 --> 00:08:22.420
使用for游戏框架并行

00:08:20.379 --> 00:08:26.440
叉关节框架

00:08:22.420 --> 00:08:28.090
你不应该读那个

00:08:26.440 --> 00:08:32.080
只是为了告诉你

00:08:28.090 --> 00:08:33.730
样板里红色的东西实际上是

00:08:32.080 --> 00:08:36.400
您如何解决问题

00:08:33.730 --> 00:08:42.730
其他一切都是锻造框架

00:08:36.400 --> 00:08:45.370
现在使用它并不总是更好

00:08:42.730 --> 00:08:48.040
并行性，您将为此付出一些代价

00:08:45.370 --> 00:08:50.710
所以在很多情况下，问题是

00:08:48.040 --> 00:08:53.770
我应该做还是不做，你知道尝试

00:08:50.710 --> 00:08:54.610
衡量响应，看看

00:08:53.770 --> 00:08:57.220
哪一个更好

00:08:54.610 --> 00:09:00.130
你认为有多少人愿意

00:08:57.220 --> 00:09:02.380
写下所有这些，我们会得到的

00:09:00.130 --> 00:09:04.240
为了发现你知道

00:09:02.380 --> 00:09:05.950
顺序执行比较容易

00:09:04.240 --> 00:09:10.540
你知道它足够小

00:09:05.950 --> 00:09:13.180
如果你去的话，现在没有人收藏

00:09:10.540 --> 00:09:16.650
回到一个小例子，不是吗

00:09:13.180 --> 00:09:22.090
如果那个D api里的人很棒

00:09:16.650 --> 00:09:24.100
为您传授知识，所以让我们

00:09:22.090 --> 00:09:28.540
将此转换为并行

00:09:24.100 --> 00:09:30.430
版本完成了

00:09:28.540 --> 00:09:33.280
而不是我并行执行的流

00:09:30.430 --> 00:09:34.750
流可能看起来像这样

00:09:33.280 --> 00:09:37.810
正在遍历集合

00:09:34.750 --> 00:09:40.780
三遍一滤

00:09:37.810 --> 00:09:42.580
映射一个产生这个的很多

00:09:40.780 --> 00:09:44.110
比这更好的事

00:09:42.580 --> 00:09:48.210
单次通过，所以只击中了

00:09:44.110 --> 00:09:50.320
收集一次非常有效，所以

00:09:48.210 --> 00:09:52.360
那就是lambda的一点点

00:09:50.320 --> 00:09:56.470
表达式为您服务我们介绍了

00:09:52.360 --> 00:10:00.100
这些在JDK 8中已经改变了

00:09:56.470 --> 00:10:02.220
我们编写代码的方式也很多

00:10:00.100 --> 00:10:04.750
介绍了几个有趣的

00:10:02.220 --> 00:10:10.870
情况正确，所以那是lambda 

00:10:04.750 --> 00:10:13.300
表达式现在是默认方法了

00:10:10.870 --> 00:10:19.210
记得你还记得API叫

00:10:13.300 --> 00:10:21.730
尼罗河被称为新IO权利，那就是

00:10:19.210 --> 00:10:23.710
因为我们有一个IO一个新的输入输出

00:10:21.730 --> 00:10:26.350
界面，然后有人想出了

00:10:23.710 --> 00:10:28.960
对其进行了一些改进，然后

00:10:26.350 --> 00:10:32.710
为此创建一个新的API集

00:10:28.960 --> 00:10:35.830
称为新IO，我们有一堆

00:10:32.710 --> 00:10:39.300
现在，我们要添加此新收藏

00:10:35.830 --> 00:10:41.770
诸如删除f4h语句之类的功能

00:10:39.300 --> 00:10:43.360
如果我们告诉你，你会感觉如何

00:10:41.770 --> 00:10:46.000
这是一组新的收藏

00:10:43.360 --> 00:10:48.340
集合-对

00:10:46.000 --> 00:10:50.470
因为所有其他收藏

00:10:48.340 --> 00:10:53.170
没有这些新功能， 

00:10:50.470 --> 00:10:55.030
您已经为他们编写了代码

00:10:53.170 --> 00:10:57.900
 Java，我们不允许您修改

00:10:55.030 --> 00:11:00.130
通过添加一个新的方法收集权利

00:10:57.900 --> 00:11:00.940
那真的是个问题

00:11:00.130 --> 00:11:04.240
不想看到另一个新的

00:11:00.940 --> 00:11:06.790
集合API，因此我们引入了另一个

00:11:04.240 --> 00:11:12.520
有趣的概念称为默认

00:11:06.790 --> 00:11:14.320
您在这里看到的方法我们说正确的流

00:11:12.520 --> 00:11:17.860
没有流的收藏

00:11:14.320 --> 00:11:19.300
 JDK 7集合如何流化

00:11:17.860 --> 00:11:21.310
现在，如果您创建了自己的

00:11:19.300 --> 00:11:23.970
集合而您没有实现

00:11:21.310 --> 00:11:28.330
流，我不会破坏您的代码

00:11:23.970 --> 00:11:30.520
这是我们在定义

00:11:28.330 --> 00:11:35.530
收集界面现在您可以通过

00:11:30.520 --> 00:11:41.410
默认方法，这的好处是

00:11:35.530 --> 00:11:44.620
如果您确实实现了该方法

00:11:41.410 --> 00:11:47.170
您实施的将是什么

00:11:44.620 --> 00:11:50.500
使用过，但是如果有人没有实现

00:11:47.170 --> 00:11:52.990
他们免费获得一个的方法是

00:11:50.500 --> 00:11:55.000
像公设辩护人，你知道你是否

00:11:52.990 --> 00:11:57.000
付不起实施的意愿

00:11:55.000 --> 00:12:01.270
免费提供给您

00:11:57.000 --> 00:12:03.340
这使我们可以创建一些方法

00:12:01.270 --> 00:12:05.200
在已经存在的收藏上

00:12:03.340 --> 00:12:07.480
因此您可以继续使用

00:12:05.200 --> 00:12:09.730
他们神奇地获得新的收藏

00:12:07.480 --> 00:12:13.420
您不必为新方法选择的方法

00:12:09.730 --> 00:12:15.880
可以，所以这是主要的优点

00:12:13.420 --> 00:12:17.800
十年来，我们当然是在

00:12:15.880 --> 00:12:20.040
 API，您可以在自己的代码上执行

00:12:17.800 --> 00:12:20.040
好

00:12:23.080 --> 00:12:30.940
我们现在还允许在

00:12:25.060 --> 00:12:34.630
接口还可以，所以您可以使用静态方法

00:12:30.940 --> 00:12:37.380
可以有零个或多个静态数

00:12:34.630 --> 00:12:40.000
我喜欢的一种是方法引用

00:12:37.380 --> 00:12:43.089
有很多lambda表达式

00:12:40.000 --> 00:12:45.310
看起来像这样，我会得到一个

00:12:43.089 --> 00:12:47.950
特定的变量，我就去

00:12:45.310 --> 00:12:52.959
在变量右边调用一个方法

00:12:47.950 --> 00:12:56.920
所以pp取名，这很常见， 

00:12:52.959 --> 00:13:00.490
当我们做JDK 8时，我们不仅

00:12:56.920 --> 00:13:03.700
创建我们去过的这些新方法，我们

00:13:00.490 --> 00:13:06.100
在jdk库本身中使用它们，因此

00:13:03.700 --> 00:13:10.180
甚至在里斯还没来得及

00:13:06.100 --> 00:13:11.529
你知道用例数百

00:13:10.180 --> 00:13:14.320
数千行代码

00:13:11.529 --> 00:13:15.640
以为哦，让我们使用这种方法，我们

00:13:14.320 --> 00:13:17.500
发现这很普遍，所以

00:13:15.640 --> 00:13:22.149
如果你现在有一个简写

00:13:17.500 --> 00:13:24.610
看到这个小小的双列运算符

00:13:22.149 --> 00:13:28.600
这是同一件事，就走了

00:13:24.610 --> 00:13:30.850
然后调用大写字母，那就是Method 

00:13:28.600 --> 00:13:32.649
引用，您可能会发现

00:13:30.850 --> 00:13:34.270
当您开始研究JDK 8代码时

00:13:32.649 --> 00:13:36.279
现在你知道它是什么

00:13:34.270 --> 00:13:41.649
对，这只是第二个的简写

00:13:36.279 --> 00:13:45.670
总之，lambda是一个

00:13:41.649 --> 00:13:47.649
这些功能使我们能够创建

00:13:45.670 --> 00:13:49.779
新的api，现在我们可以使用功能了

00:13:47.649 --> 00:13:53.560
我们引入的接口默认

00:13:49.779 --> 00:13:55.089
方法和方法参考现在

00:13:53.560 --> 00:13:59.079
对于实用的技术部分

00:13:55.089 --> 00:14:01.660
您知道我最常使用NetBeans的部分

00:13:59.079 --> 00:14:04.089
我会用某种工具

00:14:01.660 --> 00:14:06.820
让您自动转换您的

00:14:04.089 --> 00:14:08.350
代码，以便它使用新的土地

00:14:06.820 --> 00:14:10.750
表达式，例如您所在的位置

00:14:08.350 --> 00:14:12.070
使用匿名内部类，所以这是

00:14:10.750 --> 00:14:14.500
看起来是什么意思，如果你

00:14:12.070 --> 00:14:18.810
这是一个匿名的内部类， 

00:14:14.500 --> 00:14:21.610
我会说使用lambda表达po 

00:14:18.810 --> 00:14:23.980
我们将对其进行转换，如果您是新手， 

00:14:21.610 --> 00:14:25.899
这些我推荐的是

00:14:23.980 --> 00:14:28.720
您编写的一些代码

00:14:25.899 --> 00:14:30.670
了解让工具找到一些

00:14:28.720 --> 00:14:33.610
它可以转换您的内容的实例

00:14:30.670 --> 00:14:35.620
写给lambda表达式，然后

00:14:33.610 --> 00:14:38.410
在转换之前先看一下

00:14:35.620 --> 00:14:40.000
至少花了我我不知道

00:14:38.410 --> 00:14:42.460
经过三四天

00:14:40.000 --> 00:14:44.020
这些在点击之前，我开始

00:14:42.460 --> 00:14:46.900
我自己直接写lambda 

00:14:44.020 --> 00:14:48.400
而不是使用任何工具来帮助我， 

00:14:46.900 --> 00:14:49.510
使用您自己的代码更容易做到

00:14:48.400 --> 00:14:51.970
熟悉，这样你就不会

00:14:49.510 --> 00:14:53.650
想知道它在做什么，而你只是

00:14:51.970 --> 00:14:58.480
研究语法及其变化

00:14:53.650 --> 00:15:00.550
所以这是另一个

00:14:58.480 --> 00:15:01.900
使用成员引用，所以您会看到

00:15:00.550 --> 00:15:05.680
一个看起来有点像我

00:15:01.900 --> 00:15:11.340
解释说小会员参考

00:15:05.680 --> 00:15:11.340
它变成了真正的计数，所以

00:15:11.400 --> 00:15:15.370
许多工具甚至允许批处理

00:15:13.480 --> 00:15:17.440
重构，而不是仅仅重构

00:15:15.370 --> 00:15:20.170
一次提交文件就可以说

00:15:17.440 --> 00:15:21.640
这是我的项目，您可以检查一下

00:15:20.170 --> 00:15:24.340
语法，并确保它正在使用

00:15:21.640 --> 00:15:25.930
 JDK格式的所有内容，它将给

00:15:24.340 --> 00:15:28.630
你们每个人前后

00:15:25.930 --> 00:15:31.720
其中之一，所以非常有用

00:15:28.630 --> 00:15:34.420
我建议你不要盲目地

00:15:31.720 --> 00:15:35.830
接受事物了解他们，因为

00:15:34.420 --> 00:15:41.080
这就是你要写的重点

00:15:35.830 --> 00:15:42.760
从现在开始这样的方式

00:15:41.080 --> 00:15:44.680
说的是丰富的内容

00:15:42.760 --> 00:15:47.170
 lambdas现在我要谈一个

00:15:44.680 --> 00:15:48.300
白天我最喜欢的表情

00:15:47.170 --> 00:15:51.880
 API 

00:15:48.300 --> 00:15:53.770
这些是3:10，我相信Stephen Colburn 

00:15:51.880 --> 00:15:56.440
这是那些不是

00:15:53.770 --> 00:16:03.430
由Oracle开发的任何人都可以在这里听到

00:15:56.440 --> 00:16:05.860
 Java时间的权宜之计

00:16:03.430 --> 00:16:09.640
现在有自己的API集

00:16:05.860 --> 00:16:14.140
以前的API没什么问题，但是

00:16:09.640 --> 00:16:16.720
他们不会让你承担任何责任

00:16:14.140 --> 00:16:19.600
任何人都知道的几个问题

00:16:16.720 --> 00:16:25.290
无论我们使用公历还是

00:16:19.600 --> 00:16:25.290
朱利安历法

00:16:25.579 --> 00:16:28.439
好吧，我不会把你放在一个地方

00:16:27.269 --> 00:16:31.169
我们正在使用公历

00:16:28.439 --> 00:16:32.660
如今的下一个问题是什么

00:16:31.169 --> 00:16:37.949
两者之间的区别

00:16:32.660 --> 00:16:40.229
格里高利安和朱利安有人在

00:16:37.949 --> 00:16:43.139
朱利安历法则是每四个

00:16:40.229 --> 00:16:44.939
年，你会有get年，那就是

00:16:43.139 --> 00:16:47.369
旧的新的有一点

00:16:44.939 --> 00:16:49.470
规则说，除了那几年

00:16:47.369 --> 00:16:50.819
在这种情况下可以被100整除

00:16:49.470 --> 00:16:53.489
如果他们还活着，那么他们只能活几年

00:16:50.819 --> 00:16:55.439
可除以400，最后

00:16:53.489 --> 00:16:57.329
问谁认为开发人员应该

00:16:55.439 --> 00:16:59.879
在确定哪个日历之前要知道

00:16:57.329 --> 00:17:00.839
之所以使用，是因为以前的API 

00:16:59.879 --> 00:17:03.269
假设您将不得不

00:17:00.839 --> 00:17:04.709
也回答所有这些问题吧

00:17:03.269 --> 00:17:07.620
没有让你逃脱任何事情

00:17:04.709 --> 00:17:09.569
喜欢忽略时区

00:17:07.620 --> 00:17:11.429
指定您必须告诉的时间

00:17:09.569 --> 00:17:13.589
我不接受的时区

00:17:11.429 --> 00:17:16.019
默认情况下任何东西，我们人类

00:17:13.589 --> 00:17:18.509
其实更舒服

00:17:16.019 --> 00:17:20.699
有一点回旋余地，我们大多数人

00:17:18.509 --> 00:17:23.819
问题不需要那么详细

00:17:20.699 --> 00:17:26.069
所以显示时间和现在这个新日期

00:17:23.819 --> 00:17:27.750
时间更直观了

00:17:26.069 --> 00:17:33.809
更接近我们思考日期的方式

00:17:27.750 --> 00:17:38.370
和时间，所以我们去替换日期

00:17:33.809 --> 00:17:40.740
日历时区和日期格式

00:17:38.370 --> 00:17:42.690
现在精通可变线程安全

00:17:40.740 --> 00:17:44.100
如果您曾经

00:17:42.690 --> 00:17:45.600
使用Java时间，这看起来非常

00:17:44.100 --> 00:17:48.179
熟悉这是做过的同一个人

00:17:45.600 --> 00:17:50.279
他们两个都可以仰望他， 

00:17:48.179 --> 00:17:51.870
他会解释为什么他认为这是

00:17:50.279 --> 00:17:54.059
进化的下一阶段，所以有一些

00:17:51.870 --> 00:17:58.820
调整他没有其他时间

00:17:54.059 --> 00:18:02.009
他在这里强力打字

00:17:58.820 --> 00:18:03.120
易于格式化和解析，它的

00:18:02.009 --> 00:18:05.610
互操作性，所以如果我们使用

00:18:03.120 --> 00:18:09.929
您可以切换回日历日期

00:18:05.610 --> 00:18:11.610
来回单位字段和时间顺序

00:18:09.929 --> 00:18:13.679
他会解释这些并支持一些

00:18:11.610 --> 00:18:16.769
它有很多的区域日历

00:18:13.679 --> 00:18:18.149
如果有时间，我会内置日历

00:18:16.769 --> 00:18:23.070
给你一些演示，你知道

00:18:18.149 --> 00:18:25.769
很酷的实例，它使用ISO 

00:18:23.070 --> 00:18:27.899
 8601和那些不关心的人

00:18:25.769 --> 00:18:31.860
正常日历的数字

00:18:27.899 --> 00:18:35.490
这样，但我现在使用的是

00:18:31.860 --> 00:18:37.810
有一系列类型的日期，包括

00:18:35.490 --> 00:18:40.240
每年的年月日

00:18:37.810 --> 00:18:43.780
像当地人一样不在乎时间

00:18:40.240 --> 00:18:45.460
日期当地时间让我们只是时间和

00:18:43.780 --> 00:18:47.920
如果您将它们组合在一起， 

00:18:45.460 --> 00:18:49.660
另一种称为本地白天的类型

00:18:47.920 --> 00:18:54.010
看起来很像你加入那些

00:18:49.660 --> 00:18:57.450
两个在一起的时间很方便

00:18:54.010 --> 00:18:59.680
区域分别处理好吗， 

00:18:57.450 --> 00:19:01.720
有瞬时的时间点

00:18:59.680 --> 00:19:04.530
瞬间是最接近的事物

00:19:01.720 --> 00:19:08.140
我们必须到以前的java.util日期

00:19:04.530 --> 00:19:13.570
现在选择正确的日期和时间

00:19:08.140 --> 00:19:17.020
在设计应用程序时可以在本地进行

00:19:13.570 --> 00:19:18.490
日期存储在年月日期中的大多数

00:19:17.020 --> 00:19:20.980
这些将使用公历

00:19:18.490 --> 00:19:23.440
我们知道的一种使用了大部分

00:19:20.980 --> 00:19:25.720
时间，例如生日开始

00:19:23.440 --> 00:19:28.120
这些假期，有人问

00:19:25.720 --> 00:19:29.860
你你的生日，你通常会跟进

00:19:28.120 --> 00:19:32.890
在你出生的地方

00:19:29.860 --> 00:19:34.720
让他们知道你告诉你快乐

00:19:32.890 --> 00:19:36.520
晚上7点生日，因为那是

00:19:34.720 --> 00:19:42.310
现在的时间，你只是在乎日期

00:19:36.520 --> 00:19:47.440
恰到好处的时间在当地晒黑

00:19:42.310 --> 00:19:48.130
这里没有日期，所以营业时间

00:19:47.440 --> 00:19:50.850
在笔记本电脑上

00:19:48.130 --> 00:19:53.920
他们每天在6:30叫醒我

00:19:50.850 --> 00:19:59.920
好吧，在当地的白天，你只是胶水

00:19:53.920 --> 00:20:03.640
他们在一起，你瞬间得到最好的

00:19:59.920 --> 00:20:07.060
减少登录时间，然后

00:20:03.640 --> 00:20:09.550
您现在有时区时区

00:20:07.060 --> 00:20:12.160
如您所知，世界分为

00:20:09.550 --> 00:20:15.610
不同的时区，不是

00:20:12.160 --> 00:20:18.010
数学上，我们会在何时更改规则

00:20:15.610 --> 00:20:20.010
你有夏令时，他们

00:20:18.010 --> 00:20:22.990
甚至在同一个国家内变化

00:20:20.010 --> 00:20:26.290
根据人们在

00:20:22.990 --> 00:20:28.570
发现它们一年一年变化，所以如果

00:20:26.290 --> 00:20:29.830
您可以避免使用它们，而只能与

00:20:28.570 --> 00:20:32.440
欧洲这样的当地时间和安全地带

00:20:29.830 --> 00:20:34.480
如果你的生活会简单得多

00:20:32.440 --> 00:20:36.010
可以将所有内容说成是通用的

00:20:34.480 --> 00:20:39.010
时间，然后仅将它们转换为

00:20:36.010 --> 00:20:44.380
输出或输入要简单得多的尝试

00:20:39.010 --> 00:20:46.690
我们确实有时区信息

00:20:44.380 --> 00:20:48.400
如果你需要这些，你有四个班级

00:20:46.690 --> 00:20:51.370
带有编号的歌曲ID 

00:20:48.400 --> 00:20:54.940
您熟悉的小文字

00:20:51.370 --> 00:20:57.460
告诉您五到五的偏移量

00:20:54.940 --> 00:20:58.920
我们在这里的几个小时-八个或七个

00:20:57.460 --> 00:21:01.960
根据一年中的时间而定

00:20:58.920 --> 00:21:05.380
一些规则可以告诉您何时

00:21:01.960 --> 00:21:06.460
从一个切换到另一个和星期日

00:21:05.380 --> 00:21:12.580
时间是你保留所有的时间

00:21:06.460 --> 00:21:14.440
现在这个日历系统的主要类别

00:21:12.580 --> 00:21:16.030
使用ISO日历系统

00:21:14.440 --> 00:21:19.450
匹配公历之一

00:21:16.030 --> 00:21:21.310
我们今天不使用的一种

00:21:19.450 --> 00:21:25.060
历史上准确我不知道

00:21:21.310 --> 00:21:26.590
你知道你知道我们从

00:21:25.060 --> 00:21:28.210
儒略历到公历和

00:21:26.590 --> 00:21:31.570
不同国家的做法不同

00:21:28.210 --> 00:21:33.400
时候有一些抵消，所以一些

00:21:31.570 --> 00:21:36.520
如果您看，日期实际上并不存在

00:21:33.400 --> 00:21:38.110
他们起来好吗

00:21:36.520 --> 00:21:41.920
还有其他日历

00:21:38.110 --> 00:21:43.960
支持这里的应用程序，这是一个农历

00:21:41.920 --> 00:21:46.450
日历，实际上是我最喜欢的日历之一

00:21:43.960 --> 00:21:47.830
用于特定应用的

00:21:46.450 --> 00:21:50.500
我等一下

00:21:47.830 --> 00:21:51.970
就我而言，日本民俗泰国佛教徒

00:21:50.500 --> 00:21:54.940
可以分辨出

00:21:51.970 --> 00:21:56.970
这最后三个是相同的

00:21:54.940 --> 00:21:59.500
我们只有他们有不同的年份， 

00:21:56.970 --> 00:22:01.540
这太过简单了

00:21:59.500 --> 00:22:03.640
你知道有人在乎教育吗

00:22:01.540 --> 00:22:05.110
我待会儿没事，隐藏的是

00:22:03.640 --> 00:22:09.850
更有趣的是我的想法

00:22:05.110 --> 00:22:12.970
农历好吗，它只会影响

00:22:09.850 --> 00:22:14.560
日期当然不是你的时间

00:22:12.970 --> 00:22:16.420
持续时间有时你不想

00:22:14.560 --> 00:22:19.330
指定您只想开始和结束

00:22:16.420 --> 00:22:20.680
说持续三分钟，我

00:22:19.330 --> 00:22:21.880
不想说从现在开始

00:22:20.680 --> 00:22:22.210
从现在三分钟到三分钟

00:22:21.880 --> 00:22:26.040
分钟

00:22:22.210 --> 00:22:29.380
你知道没有起点和终点， 

00:22:26.040 --> 00:22:32.020
你有持续时间是可以的

00:22:29.380 --> 00:22:35.110
认为它是正确的小时和分钟

00:22:32.020 --> 00:22:36.460
这是确切的，那么你有一个时期

00:22:35.110 --> 00:22:39.070
这有点复杂

00:22:36.460 --> 00:22:40.920
那就是当我说

00:22:39.070 --> 00:22:43.060
我们人们对

00:22:40.920 --> 00:22:47.200
与日期和

00:22:43.060 --> 00:22:49.300
年月日日和我的榜样

00:22:47.200 --> 00:22:54.400
如果我告诉你这是一个

00:22:49.300 --> 00:22:57.730
一个月走了好几天

00:22:54.400 --> 00:23:00.880
取决于可能是28 30或31 

00:22:57.730 --> 00:23:02.320
我们对此表示满意，如果您知道

00:23:00.880 --> 00:23:03.760
如果您在该级别上工作，则可以

00:23:02.320 --> 00:23:05.070
如果您想要更多，请使用一段时间

00:23:03.760 --> 00:23:08.700
粒度使用

00:23:05.070 --> 00:23:10.169
这个权利适合你们

00:23:08.700 --> 00:23:13.529
拍照这是有

00:23:10.169 --> 00:23:16.409
一切都如此当地日期当地时间

00:23:13.529 --> 00:23:20.190
他们一起缝制白天的时间

00:23:16.409 --> 00:23:27.600
即时持续时间和期间的时间

00:23:20.190 --> 00:23:30.419
正如我所承诺的那样， 

00:23:27.600 --> 00:23:34.019
平均内容我们有很多变化

00:23:30.419 --> 00:23:36.509
在JDK 8中，您可以找到

00:23:34.019 --> 00:23:38.190
有关任何这些更改的信息

00:23:36.509 --> 00:23:41.669
顺便说一句，这块本身是一个

00:23:38.190 --> 00:23:45.149
我现在显示的简短列表

00:23:41.669 --> 00:23:47.220
您在这里可以找到更多

00:23:45.149 --> 00:23:49.769
如果要使用Java 8，请查看详细信息

00:23:47.220 --> 00:23:51.929
启动事件，所以我讨厌网址，因为

00:23:49.769 --> 00:23:54.090
没有人记得他们，所以我会

00:23:51.929 --> 00:23:55.649
告诉你要去找什么

00:23:54.090 --> 00:23:59.669
您的搜索引擎，然后键入Java 8 

00:23:55.649 --> 00:24:02.690
启动您会发现专家

00:23:59.669 --> 00:24:06.299
在那些api的那些库上工作

00:24:02.690 --> 00:24:09.389
在lamda上解释了更多

00:24:06.299 --> 00:24:11.070
比我以往任何时候都更细致

00:24:09.389 --> 00:24:14.100
要了解更多这些是人们

00:24:11.070 --> 00:24:15.919
看看正确的布莱恩达到我们的目标

00:24:14.100 --> 00:24:18.509
史蒂文·科弗

00:24:15.919 --> 00:24:20.549
现在，这是我最喜欢的摘要

00:24:18.509 --> 00:24:22.950
现在让我们看一下JDK 8中的功能

00:24:20.549 --> 00:24:28.980
 JDK的未来发展

00:24:22.950 --> 00:24:31.350
 9有超过90个jep的Java，并且

00:24:28.980 --> 00:24:32.730
是针对性的提案， 

00:24:31.350 --> 00:24:38.129
早就准备好了

00:24:32.730 --> 00:24:40.500
 JDK 9的构建，这是一个公共页面

00:24:38.129 --> 00:24:43.529
只需搜索打开的JDK 9，您就会发现

00:24:40.500 --> 00:24:44.070
时间表和这里完整的

00:24:43.529 --> 00:24:47.159
清单

00:24:44.070 --> 00:24:48.750
现在，您认识的任何人都无法正常工作

00:24:47.159 --> 00:24:50.909
这曾经读过完整的清单

00:24:48.750 --> 00:24:52.740
详细信息，所以我就选择

00:24:50.909 --> 00:24:55.980
其中一些，我已经将其分类

00:24:52.740 --> 00:24:58.529
进行幕后改进新

00:24:55.980 --> 00:25:00.299
提供新标准的客房清洁服务和

00:24:58.529 --> 00:25:03.889
一些已经消失的东西

00:25:00.299 --> 00:25:06.269
在JDK 9中可用，因此在幕后

00:25:03.889 --> 00:25:08.669
这些是你得到的好东西

00:25:06.269 --> 00:25:10.080
通过迁移到JDK 9，您不必

00:25:08.669 --> 00:25:12.629
重新编译代码即可

00:25:10.080 --> 00:25:16.080
您在JDK 8上编译的类将运行它们

00:25:12.629 --> 00:25:17.429
在JDK 9上，您会得到一些免费赠品

00:25:16.080 --> 00:25:19.040
一些性能改进较少

00:25:17.429 --> 00:25:22.530
记忆等

00:25:19.040 --> 00:25:24.150
所以我不会过多地讨论

00:25:22.530 --> 00:25:25.710
细节，因为这里的意图是

00:25:24.150 --> 00:25:29.220
如果您愿意，我会给您一瞥

00:25:25.710 --> 00:25:31.380
知道更多，我没有提及

00:25:29.220 --> 00:25:34.740
那个是那个小URL 

00:25:31.380 --> 00:25:35.880
只需在此处输入飞机号，您就会

00:25:34.740 --> 00:25:41.730
获得更多细节

00:25:35.880 --> 00:25:44.670
好的，因此将字符串依次存储在CD中

00:25:41.730 --> 00:25:47.580
存档不足的是，您可以拥有一个

00:25:44.670 --> 00:25:49.860
一串弦共享相同

00:25:47.580 --> 00:25:54.000
表示内存，因此使用较少

00:25:49.860 --> 00:25:57.390
内存为我们节省了很多内存

00:25:54.000 --> 00:26:00.360
管理产品的Oracle产品中的测试

00:25:57.390 --> 00:26:03.750
很多弦甚至更好的紧凑

00:26:00.360 --> 00:26:09.330
我们意识到我们可以做的字符串

00:26:03.750 --> 00:26:11.760
胜于将所有内容保存在

00:26:09.330 --> 00:26:14.850
四位，我们可以做16位，对不起

00:26:11.760 --> 00:26:17.340
在4个字节中，我们通常可以做16位

00:26:14.850 --> 00:26:19.200
如果需要，我们可以做得更大，但是

00:26:17.340 --> 00:26:24.240
现在大多数弦大约占一半

00:26:19.200 --> 00:26:25.890
现在有足够的空间好吗，我爱这个

00:26:24.240 --> 00:26:32.430
因为它只花了20年

00:26:25.890 --> 00:26:34.230
 Java文档获得一个小的搜索框，因此

00:26:32.430 --> 00:26:36.840
您使用Java doc创建的文档

00:26:34.230 --> 00:26:39.210
现在将具有该搜索功能

00:26:36.840 --> 00:26:43.320
默认，这是一个很好的搜索

00:26:39.210 --> 00:26:44.490
即使我自己也这么说

00:26:43.320 --> 00:26:46.830
可以搜索驼峰

00:26:44.490 --> 00:26:48.810
我们会做一个明智的选择

00:26:46.830 --> 00:26:52.680
只需按字母顺序查找所有内容， 

00:26:48.810 --> 00:26:54.150
把它放在那里，但真是不可思议

00:26:52.680 --> 00:26:57.810
在这里说话更有可能

00:26:54.150 --> 00:27:00.990
一个你想要的就可以了

00:26:57.810 --> 00:27:03.840
您免费获得，我们也有一堆

00:27:00.990 --> 00:27:06.270
改进这些是新工具

00:27:03.840 --> 00:27:07.680
最喜欢的功能

00:27:06.270 --> 00:27:09.690
如果您不使用它们，您将不会得到

00:27:07.680 --> 00:27:13.010
它的价值，但它们可用于

00:27:09.690 --> 00:27:14.880
如果您现在再次调用JDK 9 

00:27:13.010 --> 00:27:16.560
这些是最有可能的

00:27:14.880 --> 00:27:18.630
可供大多数开发人员使用

00:27:16.560 --> 00:27:23.820
一堆其他较小的

00:27:18.630 --> 00:27:25.620
相当模糊的第一个项目Dixon 

00:27:23.820 --> 00:27:28.080
我会讲一点

00:27:25.620 --> 00:27:31.230
如果有人去打个电话，可以得到更多细节

00:27:28.080 --> 00:27:32.160
关于JDK 9的任何会议都是

00:27:31.230 --> 00:27:34.910
你会看到的

00:27:32.160 --> 00:27:37.710
是的，我们已经将该平台模块化

00:27:34.910 --> 00:27:42.030
现在大部分的工作是模块化

00:27:37.710 --> 00:27:44.100
 jdk本身，但是您当然可以使用

00:27:42.030 --> 00:27:46.950
模块化您自己的应用程序

00:27:44.100 --> 00:27:53.010
这使得管理大型代码库

00:27:46.950 --> 00:27:55.500
简单多了，还有另一面

00:27:53.010 --> 00:27:57.360
故事这是局部的，你知道这是

00:27:55.500 --> 00:27:59.790
只是图的缩放

00:27:57.360 --> 00:28:01.890
解释模块，以便您有基础

00:27:59.790 --> 00:28:03.420
系统取决于你知道然后你有

00:28:01.890 --> 00:28:06.720
取决于基础的模块

00:28:03.420 --> 00:28:11.460
其实这里是梅森，我不能

00:28:06.720 --> 00:28:14.280
甚至在这里读到这个

00:28:11.460 --> 00:28:17.100
模块化允许我们创建这个

00:28:14.280 --> 00:28:21.270
我最喜欢的其他工具之一j-link 

00:28:17.100 --> 00:28:24.030
 Java链接器到目前为止

00:28:21.270 --> 00:28:29.340
部署模式模型是每一个Java 

00:28:24.030 --> 00:28:31.350
程序共享一个GRE写入，因此全部

00:28:29.340 --> 00:28:34.650
程序在相同的运行时上运行

00:28:31.350 --> 00:28:36.390
这意味着即使你

00:28:34.650 --> 00:28:38.460
可能希望它只运行一个

00:28:36.390 --> 00:28:39.930
不使用很多的小程序

00:28:38.460 --> 00:28:42.840
可用的类

00:28:39.930 --> 00:28:45.270
 JRE认为Jerry包含所有正确的内容

00:28:42.840 --> 00:28:47.370
它包含核心条加密，如果

00:28:45.270 --> 00:28:49.580
你想做一个小小的世界你为什么

00:28:47.370 --> 00:28:53.520
你想拥有所有这些吗

00:28:49.580 --> 00:28:56.580
功能现在变得更加普遍

00:28:53.520 --> 00:28:58.080
具有自己的应用程序

00:28:56.580 --> 00:29:00.380
运行权

00:28:58.080 --> 00:29:03.570
我们的这个模型共享一个运行时

00:29:00.380 --> 00:29:06.630
它来自50 

00:29:03.570 --> 00:29:08.490
兆字节是一个巨大的负载，没有人

00:29:06.630 --> 00:29:10.770
想再携带50兆字节

00:29:08.490 --> 00:29:12.690
现在你们有多少人很少

00:29:10.770 --> 00:29:17.220
手机上的应用程序

00:29:12.690 --> 00:29:19.110
以GB为单位，因此我们的想法

00:29:17.220 --> 00:29:21.840
必须全部共享一个运行时以节省一些

00:29:19.110 --> 00:29:24.810
不再是最大的兆字节

00:29:21.840 --> 00:29:27.030
当前的一个j-link 

00:29:24.810 --> 00:29:29.370
我们介绍了一个可选的

00:29:27.030 --> 00:29:30.990
中间步骤，通常是你

00:29:29.370 --> 00:29:32.910
我们正在编译您的代码，然后您

00:29:30.990 --> 00:29:35.010
在正确运行jaelyn，您可以

00:29:32.910 --> 00:29:38.040
链接它，您也可以使用它来

00:29:35.010 --> 00:29:40.680
创建一个自定义的运行时，所以我们将

00:29:38.040 --> 00:29:43.800
基本上去说什么模块

00:29:40.680 --> 00:29:44.970
您的应用程序需要哦，它只需要

00:29:43.800 --> 00:29:47.340
基础

00:29:44.970 --> 00:29:49.620
登录和其他模块还可以

00:29:47.340 --> 00:29:51.390
而不是把整个东西放在那里

00:29:49.620 --> 00:29:53.760
我为你打造一个特殊的形象

00:29:51.390 --> 00:29:56.280
与这三个模块，因此

00:29:53.760 --> 00:30:00.480
您可以更快地变小很多

00:29:56.280 --> 00:30:03.659
在此图像中包含您自己的模块

00:30:00.480 --> 00:30:05.280
所以我可以给你一个运行时

00:30:03.659 --> 00:30:08.850
它具有您需要的一切

00:30:05.280 --> 00:30:11.789
运行您的Java程序，它的一半或

00:30:08.850 --> 00:30:13.860
完整GRE大小的三分之一，所以如果

00:30:11.789 --> 00:30:16.620
您正在创建一堆容器

00:30:13.860 --> 00:30:18.179
并尝试为

00:30:16.620 --> 00:30:19.140
特定的应用而不是

00:30:18.179 --> 00:30:22.200
东西会跑

00:30:19.140 --> 00:30:27.600
您真正需要的可能的Java程序

00:30:22.200 --> 00:30:33.270
研究这个可以增强的功能

00:30:27.600 --> 00:30:38.760
贬低任何人说我们为什么

00:30:33.270 --> 00:30:42.419
过时的API，我们想到了一些东西

00:30:38.760 --> 00:30:43.530
比那个更好的东西

00:30:42.419 --> 00:30:46.110
与上一个错误，我们必须

00:30:43.530 --> 00:30:48.299
把它弄出来或者风格不是

00:30:46.110 --> 00:30:50.240
对，我们实际上将折旧用于

00:30:48.299 --> 00:30:54.090
很多事情，这非常令人困惑

00:30:50.240 --> 00:30:56.370
因为对我来说重要的是

00:30:54.090 --> 00:30:59.010
该应用程序是你要

00:30:56.370 --> 00:31:00.600
丢弃此API，因为如果您

00:30:59.010 --> 00:31:01.049
要删除它我想知道

00:31:00.600 --> 00:31:03.059
它

00:31:01.049 --> 00:31:06.090
在其他情况下

00:31:03.059 --> 00:31:08.250
有新的更好的东西可用

00:31:06.090 --> 00:31:10.530
这意味着如果我正在编码一个新程序

00:31:08.250 --> 00:31:12.360
我应该使用它，但是如果我有一个旧的

00:31:10.530 --> 00:31:13.860
程序运行正常，我不需要

00:31:12.360 --> 00:31:18.270
去重构它是正确的

00:31:13.860 --> 00:31:20.340
工作正常，因为我们超载了

00:31:18.270 --> 00:31:22.950
术语“弃用”是指其中的任何一个

00:31:20.340 --> 00:31:25.020
在我们添加的JDK 9中非常有用

00:31:22.950 --> 00:31:29.250
注释和重要的注释

00:31:25.020 --> 00:31:31.980
被谴责等于真实，想法是

00:31:29.250 --> 00:31:34.770
告诉您我们打算删除此API 

00:31:31.980 --> 00:31:37.549
在下一版本中，如果您使用的是

00:31:34.770 --> 00:31:40.590
被谴责的API等于true 

00:31:37.549 --> 00:31:42.090
你今天知道这不太可能

00:31:40.590 --> 00:31:44.370
将在下一个版本的

00:31:42.090 --> 00:31:46.679
即使下一个版本的JDK也可以

00:31:44.370 --> 00:31:50.429
 JDK甚至还没有开始

00:31:46.679 --> 00:31:52.140
知道现在您可以在收到警告时

00:31:50.429 --> 00:31:54.179
您编译，但我们也为您提供

00:31:52.140 --> 00:31:56.549
这是设置红色项目符号的工具

00:31:54.179 --> 00:31:58.770
第二个叫做翡翠鞋面

00:31:56.549 --> 00:32:00.330
扫描你可以运行它

00:31:58.770 --> 00:32:03.990
任何代码，并会告诉您是否

00:32:00.330 --> 00:32:05.340
使用任何不推荐使用的API，您可以

00:32:03.990 --> 00:32:06.720
传递一个参数，然后说给我看

00:32:05.340 --> 00:32:08.580
即将被删除的

00:32:06.720 --> 00:32:09.750
这是非常有用的，您不需要

00:32:08.580 --> 00:32:17.190
有源代码，您可以直接运行它

00:32:09.750 --> 00:32:22.650
在microf上谁创造了小

00:32:17.190 --> 00:32:23.520
对吧，如果情况更糟

00:32:22.650 --> 00:32:25.530
您正在尝试创建一些

00:32:23.520 --> 00:32:27.000
一成不变，因为我不知道你是否

00:32:25.530 --> 00:32:29.130
发现如何做，你必须先

00:32:27.000 --> 00:32:31.980
创建它，然后一次填充一次

00:32:29.130 --> 00:32:33.270
然后将其转换为不可变的

00:32:31.980 --> 00:32:34.950
磨牙板有点太多

00:32:33.270 --> 00:32:38.700
这个东西很小，你

00:32:34.950 --> 00:32:40.890
一口气就能做到，所以大多数人

00:32:38.700 --> 00:32:45.210
他们有超负荷，所以我认为

00:32:40.890 --> 00:32:46.410
十个元素是的，所以你可以做到

00:32:45.210 --> 00:32:47.700
这些工厂的十个要素

00:32:46.410 --> 00:32:53.400
收集还可以

00:32:47.700 --> 00:32:59.100
不错的J Shell，任何人都知道

00:32:53.400 --> 00:33:02.820
盖伊叛军其他语言有这些

00:32:59.100 --> 00:33:05.310
工具一会儿，所以如果你想

00:33:02.820 --> 00:33:08.940
立即探索API，您该怎么做

00:33:05.310 --> 00:33:12.090
启动NetBeans或创建的磁带

00:33:08.940 --> 00:33:14.070
一点脚手架，因为如果我

00:33:12.090 --> 00:33:15.210
想知道我将如何使用API 

00:33:14.070 --> 00:33:17.220
需要创建一个使用

00:33:15.210 --> 00:33:19.350
该API是正确的，所以我将不得不

00:33:17.220 --> 00:33:21.210
用那些你知道的主要

00:33:19.350 --> 00:33:24.600
称这个小东西只是为了发现

00:33:21.210 --> 00:33:25.800
 API的工作方式太多了

00:33:24.600 --> 00:33:29.550
麻烦

00:33:25.800 --> 00:33:31.470
所以ID实际上已经集成了

00:33:29.550 --> 00:33:32.970
工具本身，我说我使用NetBeans 

00:33:31.470 --> 00:33:37.800
有一个早期访问版本

00:33:32.970 --> 00:33:39.000
适用于JDK 9的NetBeans 

00:33:37.800 --> 00:33:41.340
快点完成，我会告诉你一点

00:33:39.000 --> 00:33:43.800
如何使用此反叛工具的示例

00:33:41.340 --> 00:33:46.880
玩转就可以打开命令

00:33:43.800 --> 00:33:48.870
行，您可以键入它具有代码完成

00:33:46.880 --> 00:33:50.340
有点简化，你不用

00:33:48.870 --> 00:33:54.870
必须将分号放在

00:33:50.340 --> 00:33:57.930
您可以导出的每个语句都可以

00:33:54.870 --> 00:33:59.640
你知道有一点Java接口

00:33:57.930 --> 00:34:01.260
出现，您可以编辑自己的内容

00:33:59.640 --> 00:34:03.300
使用过，因此对于

00:34:01.260 --> 00:34:05.160
探索性代码，一旦您理解

00:34:03.300 --> 00:34:06.600
如何运作，您可以继续

00:34:05.160 --> 00:34:09.320
无需编写写API 

00:34:06.600 --> 00:34:09.320
玩它

00:34:09.570 --> 00:34:15.669
我希望我们在搬家之前有一些东西

00:34:12.879 --> 00:34:18.129
释放jar文件，那么会发生什么

00:34:15.669 --> 00:34:21.340
当我们提出一个很棒的新主意时

00:34:18.129 --> 00:34:25.179
 JDK 9，但您希望使用相同的代码

00:34:21.340 --> 00:34:27.790
在JDK 9＆8＆7上工作，您几乎可以

00:34:25.179 --> 00:34:30.700
卡住是因为您知道我无法使用

00:34:27.790 --> 00:34:32.560
这个新的API，因为当

00:34:30.700 --> 00:34:34.290
有人试图在JDK 8上运行它

00:34:32.560 --> 00:34:35.980
要炸毁他们的脸， 

00:34:34.290 --> 00:34:37.720
因此，有些事情

00:34:35.980 --> 00:34:39.730
不要像他们一样被尽快采纳

00:34:37.720 --> 00:34:41.290
可能是因为开发人员有这个

00:34:39.730 --> 00:34:42.580
担心我不想

00:34:41.290 --> 00:34:44.320
创建一个援助版本和一个版本

00:34:42.580 --> 00:34:46.450
 9我想要一个可以使用的版本

00:34:44.320 --> 00:34:50.320
现在这两个人都这样

00:34:46.450 --> 00:34:53.409
看起来像JDK 8，如果您正在运行

00:34:50.320 --> 00:34:56.919
 JDK 8或更低版本中的特定jar 

00:34:53.409 --> 00:34:58.720
这些是ABCD类别，如果您

00:34:56.919 --> 00:35:00.250
在JDK 9中运行它

00:34:58.720 --> 00:35:02.800
覆盖a，它将使用它

00:35:00.250 --> 00:35:05.710
一个代替B这个代替

00:35:02.800 --> 00:35:11.830
这两个班是A班和B班

00:35:05.710 --> 00:35:13.810
在这里只能使用九个API 

00:35:11.830 --> 00:35:15.369
 B班上课了

00:35:13.810 --> 00:35:18.340
你写的八岁及以下

00:35:15.369 --> 00:35:20.350
想法是随着我们前进

00:35:18.340 --> 00:35:21.970
你有这个可以

00:35:20.350 --> 00:35:23.320
不同的班级，说这是

00:35:21.970 --> 00:35:25.359
四八九十十这个是

00:35:23.320 --> 00:35:28.300
大概可以放在一个罐子里

00:35:25.359 --> 00:35:34.300
以不同方式运行的程序

00:35:28.300 --> 00:35:36.550
 Java版本可以使用一些新标准

00:35:34.300 --> 00:35:38.470
这些是我们没有发明的东西

00:35:36.550 --> 00:35:42.340
他们只是我们在抢什么

00:35:38.470 --> 00:35:44.800
在其他地方可用Unicode八，因此您

00:35:42.340 --> 00:35:47.230
可以看到每个Java版本都采用了新的

00:35:44.800 --> 00:35:50.109
我打败你的Unicode版本

00:35:47.230 --> 00:35:54.400
七个与unicode一起启动六个所以

00:35:50.109 --> 00:35:55.869
大约有10,000个新符号

00:35:54.400 --> 00:36:01.150
猜猜绝大多数

00:35:55.869 --> 00:36:04.180
那些都是表情符号骑手，但是如果

00:36:01.150 --> 00:36:06.250
你很想写较低的那瓦伙族人

00:36:04.180 --> 00:36:07.510
如果您需要Unicode 8 

00:36:06.250 --> 00:36:09.460
因为那是它引入的地方

00:36:07.510 --> 00:36:12.400
在那之前，你总是在尖叫

00:36:09.460 --> 00:36:16.480
当您在纳瓦霍写作时，我不得不

00:36:12.400 --> 00:36:18.580
查一下，因为你可以写你的

00:36:16.480 --> 00:36:20.740
您的财产文件，现在您可以使用

00:36:18.580 --> 00:36:22.119
 utf-8，所以当您将其与另一个配对时

00:36:20.740 --> 00:36:22.900
一个你可以有一个属性文件是

00:36:22.119 --> 00:36:27.070
所有阿玛吉

00:36:22.900 --> 00:36:28.420
如果你知道你很喜欢你

00:36:27.070 --> 00:36:29.590
在那之前你可以做到，但是你有

00:36:28.420 --> 00:36:35.070
现在可以对它们进行编码了

00:36:29.590 --> 00:36:38.560
 utf-8，所以OC速度相当不错

00:36:35.070 --> 00:36:40.150
 CSP装订很麻烦

00:36:38.560 --> 00:36:42.370
这是我最喜欢的功能之一

00:36:40.150 --> 00:36:47.200
非常技术，但是我在这里喜欢

00:36:42.370 --> 00:36:51.340
任何人都知道我能得到的好处

00:36:47.200 --> 00:36:53.440
继续前进时马上炫耀

00:36:51.340 --> 00:36:56.170
对服务器执行ping操作，请想象您尝试

00:36:53.440 --> 00:36:59.710
连接到说我要去的API 

00:36:56.170 --> 00:37:01.270
连接到我不知道微软的

00:36:59.710 --> 00:37:02.950
它的工作方式是您去连接

00:37:01.270 --> 00:37:06.580
微软和微软的回复以及

00:37:02.950 --> 00:37:09.580
说HTTP这是由

00:37:06.580 --> 00:37:11.470
威瑞信说我是微软，所以

00:37:09.580 --> 00:37:13.420
您的计算机说什么时候

00:37:11.470 --> 00:37:14.980
这是我们最后一次检查

00:37:13.420 --> 00:37:17.950
被撤销的证书

00:37:14.980 --> 00:37:20.200
威瑞信是一个多小时前

00:37:17.950 --> 00:37:22.090
不，不到一个小时，好吧，我走

00:37:20.200 --> 00:37:23.920
检查该列表，是的，证书是

00:37:22.090 --> 00:37:25.450
如果不是，那我们就好了

00:37:23.920 --> 00:37:29.470
这一个小时是你的第一件事

00:37:25.450 --> 00:37:31.810
检查您是否必须继续使用Ping 

00:37:29.470 --> 00:37:35.290
并说那个证书是

00:37:31.810 --> 00:37:36.610
撤销权利，这意味着很多

00:37:35.290 --> 00:37:39.070
的人正在使用第一台Microsoft付款

00:37:36.610 --> 00:37:40.570
然后Verisign甚至还有一个

00:37:39.070 --> 00:37:43.420
理论上的拒绝服务攻击

00:37:40.570 --> 00:37:45.670
您使用的证书具有

00:37:43.420 --> 00:37:49.360
被撤销，您阻止了此人

00:37:45.670 --> 00:37:50.890
远离Verisign的权利

00:37:49.360 --> 00:37:52.390
浏览器现在他们假设，如果他们

00:37:50.890 --> 00:37:53.920
不能认为很难过，你知道

00:37:52.390 --> 00:37:56.080
连接问题一切都在

00:37:53.920 --> 00:37:58.990
可能很好，很好，让我们休息

00:37:56.080 --> 00:38:01.240
它也可以让您泄漏

00:37:58.990 --> 00:38:02.140
很少的信息Verisign有一个想法

00:38:01.240 --> 00:38:03.880
那么有多少人来

00:38:02.140 --> 00:38:06.300
微软，因为他们越来越

00:38:03.880 --> 00:38:08.620
 ping，这如何工作

00:38:06.300 --> 00:38:10.990
微软每小时一次的事情很

00:38:08.620 --> 00:38:14.590
沉默，你能给我签个字条吗

00:38:10.990 --> 00:38:16.660
说我没有过期，而是

00:38:14.590 --> 00:38:18.880
比每个客户都必须非常

00:38:16.660 --> 00:38:20.560
时间记得你打算如何

00:38:18.880 --> 00:38:22.570
相信答案一个小时

00:38:20.560 --> 00:38:24.370
这没什么不同，唯一的区别

00:38:22.570 --> 00:38:26.110
现在微软说这是我的

00:38:24.370 --> 00:38:28.000
证书，这是最近的

00:38:26.110 --> 00:38:29.590
签名不到一小时的俗语

00:38:28.000 --> 00:38:33.600
我没有过期，你不必

00:38:29.590 --> 00:38:33.600
检查其他的东西很整洁吧

00:38:33.800 --> 00:38:38.130
新的哈希算法

00:38:35.910 --> 00:38:40.320
谁跟上了所有

00:38:38.130 --> 00:38:41.940
有关md5和sha-1的新闻，它们都是

00:38:40.320 --> 00:38:43.740
被黑客入侵意味着您需要新的

00:38:41.940 --> 00:38:46.410
那些，所以你知道我们将继续

00:38:43.740 --> 00:38:47.640
在这个小仓鼠轮子上

00:38:46.410 --> 00:38:50.070
我可以认为我没有任何答案

00:38:47.640 --> 00:38:57.090
现在，他们将继续努力，我们将

00:38:50.070 --> 00:39:05.520
继续添加html5 Java文档

00:38:57.090 --> 00:39:08.460
更好，所以这里是另一个HTTP-所以

00:39:05.520 --> 00:39:10.920
这是协议，您知道非常习惯

00:39:08.460 --> 00:39:13.620
如今，它使事情看起来像加载

00:39:10.920 --> 00:39:15.240
更快，有很多技巧

00:39:13.620 --> 00:39:16.410
他们使用的-即使它正在发送

00:39:15.240 --> 00:39:20.370
它们与相同数量的信息

00:39:16.410 --> 00:39:21.660
事情现在似乎加载更快

00:39:20.370 --> 00:39:25.040
一个也让我介绍

00:39:21.660 --> 00:39:29.760
新的东西叫做孵化器模块

00:39:25.040 --> 00:39:31.860
现在你可能会问什么

00:39:29.760 --> 00:39:35.100
窝哦，不要和我一起玩是什么

00:39:31.860 --> 00:39:36.870
所以孵化器模块是当我们

00:39:35.100 --> 00:39:38.640
定义一个API，我们把它放在

00:39:36.870 --> 00:39:40.680
标准我们放出的时间

00:39:38.640 --> 00:39:42.090
有人去建造一个巨大的

00:39:40.680 --> 00:39:44.940
系统就可以了

00:39:42.090 --> 00:39:46.500
再一次，所以只要有

00:39:44.940 --> 00:39:49.470
我们不太确定是否

00:39:46.500 --> 00:39:51.420
 API已经准备好了，我们总是有这个

00:39:49.470 --> 00:39:53.700
问题权，我们尝试寻求反馈

00:39:51.420 --> 00:39:55.680
但直到它实际上在JDK中

00:39:53.700 --> 00:39:58.020
人们没有得到反馈孵化器

00:39:55.680 --> 00:39:59.640
模块是一组模块

00:39:58.020 --> 00:40:02.430
几乎可以保证该API 

00:39:59.640 --> 00:40:04.740
在下一个版本中不会出现

00:40:02.430 --> 00:40:05.520
所以你可以去玩，但是它

00:40:04.740 --> 00:40:08.340
带有警告

00:40:05.520 --> 00:40:09.330
你不应该在

00:40:08.340 --> 00:40:10.470
您打算在其中使用的这些

00:40:09.330 --> 00:40:12.810
长期生产

00:40:10.470 --> 00:40:15.360
因为它不会在下一个

00:40:12.810 --> 00:40:17.790
版本希望它将有所帮助

00:40:15.360 --> 00:40:19.860
通过获取更多反馈，我们可以

00:40:17.790 --> 00:40:25.830
确保API进入时

00:40:19.860 --> 00:40:27.930
这个标准是正确的API，现在可以了

00:40:25.830 --> 00:40:30.000
家政服务，我们已经建立了一些未来

00:40:27.930 --> 00:40:32.790
改进，我们减少了一些

00:40:30.000 --> 00:40:34.470
这是一个复杂的

00:40:32.790 --> 00:40:38.400
将获得我们拥有的最新消息

00:40:34.470 --> 00:40:41.760
现在我可以封装大多数内部API 

00:40:38.400 --> 00:40:44.610
在1998年的网页上可以找到您

00:40:41.760 --> 00:40:46.400
在您知道的Internet存档中

00:40:44.610 --> 00:40:49.180
 Sun Microsystems讲述其发展

00:40:46.400 --> 00:40:51.460
首先不要使用内部API 

00:40:49.180 --> 00:40:54.079
它们不是规范的一部分

00:40:51.460 --> 00:40:57.319
这就是我们内部使用的

00:40:54.079 --> 00:41:00.140
实施规范，所以远离

00:40:57.319 --> 00:41:03.289
从他们可能改变的可能

00:41:00.140 --> 00:41:05.270
消失了，你知道这是如果你是

00:41:03.289 --> 00:41:10.279
使用其他供应商实施

00:41:05.270 --> 00:41:12.079
的Java他们可能现在不在那里

00:41:10.279 --> 00:41:14.390
我们这样做了，我们当然可以使用

00:41:12.079 --> 00:41:16.549
相同的开源资源库

00:41:14.390 --> 00:41:18.980
大家都去看了一堆

00:41:16.549 --> 00:41:23.119
常用库的数量

00:41:18.980 --> 00:41:24.799
人们以为你知道不到

00:41:23.119 --> 00:41:26.299
他们一半，但你知道一半

00:41:24.799 --> 00:41:32.690
他们使用此内部API 

00:41:26.299 --> 00:41:34.520
他们一半人都知道60 80 90 

00:41:32.690 --> 00:41:36.200
你实际认为多少

00:41:34.520 --> 00:41:40.700
即使我们告诉使用内部API 

00:41:36.200 --> 00:41:43.190
他们不要尝试百分百好吧

00:41:40.700 --> 00:41:46.130
我们定义的每个平凡的API 

00:41:43.190 --> 00:41:48.020
他们使用了一些内部API 

00:41:46.130 --> 00:41:50.630
使您的代码易碎，并且使

00:41:48.020 --> 00:41:52.640
您知道我们无法使用的那些内部API 

00:41:50.630 --> 00:41:54.319
真正地发展它们，因此我们可以并且

00:41:52.640 --> 00:41:56.710
我们最终要封装它们

00:41:54.319 --> 00:41:57.950
他们默认不会在那里

00:41:56.710 --> 00:42:02.480
好的

00:41:57.950 --> 00:42:03.410
现在，这意味着那些常见的

00:42:02.480 --> 00:42:05.000
我正在谈论的图书馆

00:42:03.410 --> 00:42:07.270
将会有一个新版本的

00:42:05.000 --> 00:42:11.779
他们不使用那些内部API 

00:42:07.270 --> 00:42:14.329
还有逃逸条款

00:42:11.779 --> 00:42:18.670
您可以传递以暴露的命令行

00:42:14.329 --> 00:42:21.079
这些api之一，如果需要的话

00:42:18.670 --> 00:42:23.089
请不要这样做，除非你是

00:42:21.079 --> 00:42:26.960
打算重写您的代码

00:42:23.089 --> 00:42:30.760
只是一个临时步骤，好吧

00:42:26.960 --> 00:42:33.529
少数API，当我们去寻找

00:42:30.760 --> 00:42:35.270
我们决定你知道这些不是

00:42:33.529 --> 00:42:38.390
这些实际所做的只是方便的事情

00:42:35.270 --> 00:42:40.789
重要的事情，没有实际的

00:42:38.390 --> 00:42:42.559
真正的您知道支持API的一部分

00:42:40.789 --> 00:42:45.859
可以做到这些的规范

00:42:42.559 --> 00:42:49.549
那里列出的人这样做

00:42:45.859 --> 00:42:50.900
只有那些将保持启用状态

00:42:49.549 --> 00:42:52.970
默认情况下，您不必通过

00:42:50.900 --> 00:42:56.420
任何那些都将留在那里

00:42:52.970 --> 00:42:58.849
非常努力地提供一些API 

00:42:56.420 --> 00:43:00.200
是规范的一部分， 

00:42:58.849 --> 00:43:03.260
这些家伙所做的事情

00:43:00.200 --> 00:43:06.740
以支持的方式，直到我们做到

00:43:03.260 --> 00:43:07.520
保持可用这不是我们

00:43:06.740 --> 00:43:09.290
把它们变成了一部分

00:43:07.520 --> 00:43:10.310
规范，现在他们

00:43:09.290 --> 00:43:12.860
永远存在

00:43:10.310 --> 00:43:14.300
希望在JDK 10或JDK 11中或尽快

00:43:12.860 --> 00:43:17.750
因为我们可以用新的替代品来应用

00:43:14.300 --> 00:43:19.150
那些会消失，但九个不会

00:43:17.750 --> 00:43:24.860
他们需要使用它们

00:43:19.150 --> 00:43:27.890
好的，有一个可用的工具

00:43:24.860 --> 00:43:30.680
自从JDK 8被称为Java依赖J 

00:43:27.890 --> 00:43:32.390
您可以通过代码运行的深度

00:43:30.680 --> 00:43:35.060
它会告诉您您是否

00:43:32.390 --> 00:43:36.710
使用这个API，所以我建议

00:43:35.060 --> 00:43:39.320
你继续对你的

00:43:36.710 --> 00:43:40.910
代码以及当我说您的意思时

00:43:39.320 --> 00:43:43.190
代码，我的意思并不只是你迈出的一步

00:43:40.910 --> 00:43:46.760
还写了你的图书馆

00:43:43.190 --> 00:43:48.500
依靠好的，因为我希望大多数

00:43:46.760 --> 00:43:50.510
人们至少必须得到

00:43:48.500 --> 00:43:55.070
他们的登录实用程序的下一版本或

00:43:50.510 --> 00:43:56.690
框架等模块化应用

00:43:55.070 --> 00:43:58.010
包装记得我说过

00:43:56.690 --> 00:44:00.740
有一个J链接创建了一个

00:43:58.010 --> 00:44:05.000
特殊的运行时，我们有一个工具

00:44:00.740 --> 00:44:07.280
创建一个程序包，使其看起来像一个

00:44:05.000 --> 00:44:10.670
 JDK 8提供的本机应用程序

00:44:07.280 --> 00:44:12.500
但是它将整个评审团与JDK 9捆绑在一起

00:44:10.670 --> 00:44:13.850
它使用此每日链接工具来创建一个

00:44:12.500 --> 00:44:19.550
更小的运行时间

00:44:13.850 --> 00:44:21.380
应用新版本的字符串有你吗

00:44:19.550 --> 00:44:27.290
好的，哪个Java版本是

00:44:21.380 --> 00:44:29.000
当前一8更新120什么

00:44:27.290 --> 00:44:35.840
正确，如果您使用Java版本

00:44:29.000 --> 00:44:38.240
字符串你会得到一个点8.0 

00:44:35.840 --> 00:44:40.700
正确的一点是什么

00:44:38.240 --> 00:44:43.160
零是多少

00:44:40.700 --> 00:44:43.730
这些东西在那里的很好的理由

00:44:43.160 --> 00:44:45.830
首先

00:44:43.730 --> 00:44:50.450
但是它们在JDK 9中已经消失了，因此版本

00:44:45.830 --> 00:44:53.030
 9的字符串是9而不是1.9，它有

00:44:50.450 --> 00:44:55.850
语义版本控制，所以没有你

00:44:53.030 --> 00:44:59.540
知道新闻，不止一个

00:44:55.850 --> 00:45:02.030
要读取的数字，如果您正在解析

00:44:59.540 --> 00:45:04.370
版本字符串，我们已经看到了代码

00:45:02.030 --> 00:45:06.320
查看版本字符串将丢弃

00:45:04.370 --> 00:45:10.420
第一位数字，然后开始查看

00:45:06.320 --> 00:45:13.490
第二个行不通

00:45:10.420 --> 00:45:14.900
如果不提前编译

00:45:13.490 --> 00:45:16.310
想在您的公司上编制冬季局

00:45:14.900 --> 00:45:18.830
您要创建编辑的喷气机

00:45:16.310 --> 00:45:22.940
提前运行在下一个可用

00:45:18.830 --> 00:45:24.470
一个md5字符串串联我喜欢这个

00:45:22.940 --> 00:45:28.490
我不得不告诉你一个

00:45:24.470 --> 00:45:33.050
就像我提到的，我们已经介绍了

00:45:28.490 --> 00:45:36.890
在7或8个越来越多的市场中调用动态

00:45:33.050 --> 00:45:38.900
在7 JDK 7中，这意味着

00:45:36.890 --> 00:45:41.990
比编译器找出代码

00:45:38.900 --> 00:45:45.380
它可以说你知道在

00:45:41.990 --> 00:45:48.670
现在运行时，这将使我们能够

00:45:45.380 --> 00:45:51.590
做完之后要做的就是编译

00:45:48.670 --> 00:45:52.820
现在我们是一样的，但如果我们认为

00:45:51.590 --> 00:45:54.230
做弦的更好方法

00:45:52.820 --> 00:45:56.780
将来串联

00:45:54.230 --> 00:45:58.430
我们可以做到，这样代码可以编译

00:45:56.780 --> 00:45:59.840
 9岁以上的人

00:45:58.430 --> 00:46:01.970
这些不必要的好处

00:45:59.840 --> 00:46:03.500
重新编译它，这就是我所说的

00:46:01.970 --> 00:46:05.360
知道这只是看家务

00:46:03.500 --> 00:46:05.930
当我们提出更好的建议时

00:46:05.360 --> 00:46:08.330
理念

00:46:05.930 --> 00:46:13.430
您无需重新编译即可得到

00:46:08.330 --> 00:46:16.370
优势统一平均排序

00:46:13.430 --> 00:46:21.710
登录，我们切换默认

00:46:16.370 --> 00:46:23.900
垃圾收集器好吧，现在有人在这里

00:46:21.710 --> 00:46:27.230
关心哪个垃圾收集器

00:46:23.900 --> 00:46:28.400
您的应用程序使用的是

00:46:27.230 --> 00:46:30.380
猜你有一个参数

00:46:28.400 --> 00:46:32.540
告诉操作员运行时间

00:46:30.380 --> 00:46:34.640
使用哪个，这样您就不会

00:46:32.540 --> 00:46:39.070
影响这些只会影响人

00:46:34.640 --> 00:46:39.070
没有指定默认值就可以

00:46:39.130 --> 00:46:44.840
您熟悉的项目硬币

00:46:41.750 --> 00:46:46.850
 JDK 7附带一个，我们做了一些小改动

00:46:44.840 --> 00:46:50.530
改变我们正在做的语言

00:46:46.850 --> 00:46:50.530
可以进一步改善

00:46:52.210 --> 00:46:57.620
我喜欢这个过滤器传入

00:46:55.100 --> 00:46:59.750
序列化数据现在这个我有

00:46:57.620 --> 00:47:03.500
在这里，因为这实际上是现在

00:46:59.750 --> 00:47:05.600
在版本6 7和8中可用，因此它是一个

00:47:03.500 --> 00:47:07.460
你可以告诉不要的机制

00:47:05.600 --> 00:47:09.890
只是接受任何数据，这是一组

00:47:07.460 --> 00:47:11.840
规则我的应用程序只期望这样

00:47:09.890 --> 00:47:12.200
要序列化的数据类型

00:47:11.840 --> 00:47:15.260
其他

00:47:12.200 --> 00:47:18.670
踢出去好吧，这就是我说的

00:47:15.260 --> 00:47:21.200
我能想到的唯一特征是

00:47:18.670 --> 00:47:22.640
从9开始，已经回来了

00:47:21.200 --> 00:47:28.190
板，目前可用

00:47:22.640 --> 00:47:30.590
释放一堆垃圾

00:47:28.190 --> 00:47:32.300
在8个中可以弃用的组合

00:47:30.590 --> 00:47:34.360
你告诉那些是红色的

00:47:32.300 --> 00:47:40.010
可见对，所以这些人就在这里

00:47:34.360 --> 00:47:42.650
红色表示在JDK 8中已弃用

00:47:40.010 --> 00:47:44.090
而且我们还没有测试它们，所以我

00:47:42.650 --> 00:47:47.810
工作做得不好

00:47:44.090 --> 00:47:52.010
他们现在将在JDK 9中消失

00:47:47.810 --> 00:47:53.750
这是什么一般规则

00:47:52.010 --> 00:47:56.290
您现在正在运行JDK，并且您正在

00:47:53.750 --> 00:48:00.170
得到警告之类的东西

00:47:56.290 --> 00:48:03.710
正确，如果您在JDK 8中设置了parmgen大小

00:48:00.170 --> 00:48:07.400
它告诉你我忽略了我删除的内容

00:48:03.710 --> 00:48:11.660
您知道这是我们要删除的

00:48:07.400 --> 00:48:15.050
这在JDK 9中的JDK 8中是相同的选项

00:48:11.660 --> 00:48:16.220
会出错，所以不要只是忽略

00:48:15.050 --> 00:48:16.720
这些警告，他们在那里

00:48:16.220 --> 00:48:19.130
原因

00:48:16.720 --> 00:48:20.450
请，我知道人们会

00:48:19.130 --> 00:48:25.850
我们打电话给我抱怨

00:48:20.450 --> 00:48:28.400
上线，我挑我的那些

00:48:25.850 --> 00:48:32.240
就像我说的那样，很喜欢

00:48:28.400 --> 00:48:34.730
在那里您可以阅读任何内容

00:48:32.240 --> 00:48:37.430
其中之一比

00:48:34.730 --> 00:48:41.500
您认识的任何人都可以一次完成

00:48:37.430 --> 00:48:41.500
会议还可以

00:48:41.730 --> 00:48:52.320
现在就开始我的号召性用语下载

00:48:46.560 --> 00:48:54.240
我认为我的JDK和早期访问版本

00:48:52.320 --> 00:48:57.900
留在这里只是搜索ek9 

00:48:54.240 --> 00:48:59.550
您会发现我们会更改版本

00:48:57.900 --> 00:49:01.020
定期编号，所以不要随便抓

00:48:59.550 --> 00:49:03.690
一个，永远测试

00:49:01.020 --> 00:49:05.670
你知道我们每次都检查

00:49:03.690 --> 00:49:07.290
已完成功能，因此如果您

00:49:05.670 --> 00:49:08.840
等待这些拥有所有

00:49:07.290 --> 00:49:10.860
开始测试之前的功能

00:49:08.840 --> 00:49:13.890
您不再等待，您可以做到

00:49:10.860 --> 00:49:16.410
今天还可以，并且有一个摘要

00:49:13.890 --> 00:49:20.430
在下一个版本上进行更改

00:49:16.410 --> 00:49:23.130
参加每个人的对话

00:49:20.430 --> 00:49:25.740
这些刺戳，如果您寻找

00:49:23.130 --> 00:49:27.270
讨论区，它会告诉您

00:49:25.740 --> 00:49:30.180
您可以问以下问题之一

00:49:27.270 --> 00:49:33.000
关于最了解的人

00:49:30.180 --> 00:49:34.830
这些特定的增强监视器

00:49:33.000 --> 00:49:37.740
他们在这些讨论中，你可以去

00:49:34.830 --> 00:49:40.170
如有任何疑问，请提前加入

00:49:37.740 --> 00:49:43.140
建议，请查看存档

00:49:40.170 --> 00:49:45.150
因为我们有很多问题， 

00:49:43.140 --> 00:49:48.360
没有人喜欢回答这样的问题

00:49:45.150 --> 00:49:49.890
在六个月前得到了答复，但如果您

00:49:48.360 --> 00:49:53.100
有任何建议，所以你找到任何

00:49:49.890 --> 00:49:54.840
问题，你可以ping我，然后我

00:49:53.100 --> 00:49:56.000
会选择他们，或者你可以砍我

00:49:54.840 --> 00:50:01.500
跳出循环，直接去找他们

00:49:56.000 --> 00:50:03.690
好吧，下载一些您的口味的想法

00:50:01.500 --> 00:50:07.260
就像您喜欢的NetBeans一样

00:50:03.690 --> 00:50:09.870
他们现在提供功能相同的东西

00:50:07.260 --> 00:50:13.350
他们正在努力为

00:50:09.870 --> 00:50:15.480
 GA的新功能像我们一样，他们也

00:50:13.350 --> 00:50:16.650
需要反馈请与他们联系

00:50:15.480 --> 00:50:22.110
告诉他们他们在做什么

00:50:16.650 --> 00:50:24.120
以及他们在做什么翡翠

00:50:22.110 --> 00:50:28.170
我提到的EPS工具可用

00:50:24.120 --> 00:50:30.360
在JDK 8中，最好使用一个

00:50:28.170 --> 00:50:31.830
在JDK 9中，当您发现

00:50:30.360 --> 00:50:34.590
你不应该使用你会

00:50:31.830 --> 00:50:35.850
告诉你什么时候知道

00:50:34.590 --> 00:50:38.910
您应该使用的受支持的API 

00:50:35.850 --> 00:50:41.370
相反好吧，所以请运行它

00:50:38.910 --> 00:50:43.200
使您更轻松地过渡到JDK 9 

00:50:41.370 --> 00:50:45.750
比较简单，这有点像

00:50:43.200 --> 00:50:47.910
不想退休

00:50:45.750 --> 00:50:49.590
等到您必须去JDK 9 

00:50:47.910 --> 00:50:53.090
如果您现在就做就做

00:50:49.590 --> 00:50:53.090
逐步地，这将很容易

00:50:53.460 --> 00:51:03.430
正如我所说的

00:50:56.470 --> 00:51:06.910
复杂的此处广告集导出

00:51:03.430 --> 00:51:08.650
是什么让您我们将其删除

00:51:06.910 --> 00:51:13.479
限制，并有那些内部

00:51:08.650 --> 00:51:15.729
 api会重新出现在您的程序中，所以

00:51:13.479 --> 00:51:17.249
滑盖就是这样，我

00:51:15.729 --> 00:51:20.440
认为我们还有几分钟

00:51:17.249 --> 00:51:22.539
在我忘记刚来的那个人之前

00:51:20.440 --> 00:51:24.609
在我们开始之前，布鲁诺提醒我

00:51:22.539 --> 00:51:26.739
提醒您有招待会

00:51:24.609 --> 00:51:28.809
我们要喝啤酒酒

00:51:26.739 --> 00:51:29.769
我们在这里吃东西的东西

00:51:28.809 --> 00:51:31.930
会议结束后

00:51:29.769 --> 00:51:33.489
不要只是给你的车打碗

00:51:31.930 --> 00:51:36.489
在那消磨时间，等待

00:51:33.489 --> 00:51:38.440
交通死了，有没有

00:51:36.489 --> 00:51:40.509
我所显示或所做的问题

00:51:38.440 --> 00:51:44.549
任何人都希望看到J的一些演示

00:51:40.509 --> 00:51:44.549
外壳，也许还有一些示例代码

00:51:49.780 --> 00:51:55.150
是的，让我们尝试一下，我还没有

00:51:53.050 --> 00:51:57.970
向演示之神祈祷，所以你要去

00:51:55.150 --> 00:52:01.180
必须忍受我的电脑

00:51:57.970 --> 00:52:03.100
也很慢，有人可以读

00:52:01.180 --> 00:52:05.290
首先，因为这不会

00:52:03.100 --> 00:52:12.840
为了好玩，我们可以改变分辨率

00:52:05.290 --> 00:52:12.840
那是可击败的，是吗，所以这是

00:52:15.960 --> 00:52:24.280
 JDK 9我认为我有几个版本

00:52:19.420 --> 00:52:25.320
回到我所说的我的电脑超级

00:52:24.280 --> 00:52:28.300
慢点我们去

00:52:25.320 --> 00:52:29.850
 156我要告诉你她她会

00:52:28.300 --> 00:52:32.680
记得我提到过

00:52:29.850 --> 00:52:36.660
这个工具repple工具

00:52:32.680 --> 00:52:41.410
让您探索一些代码，以便

00:52:36.660 --> 00:52:43.330
我最喜欢的地方之一，我们去吧

00:52:41.410 --> 00:52:50.050
做任何我可以做的简单的事情

00:52:43.330 --> 00:52:53.620
像你好，这是串右点汤

00:52:50.050 --> 00:52:55.030
我要点击这里，它告诉我

00:52:53.620 --> 00:53:00.150
有哪些可用的方法

00:52:55.030 --> 00:53:05.440
对于那个字符串，让我们现在说子字符串

00:53:00.150 --> 00:53:08.740
我要做一个制表符，它告诉

00:53:05.440 --> 00:53:09.850
我有什么可能的正确方法

00:53:08.740 --> 00:53:11.260
我可能会在那里使用它

00:53:09.850 --> 00:53:13.870
超载，所以这可能是一个开始

00:53:11.260 --> 00:53:18.820
趋势，我可以说2 

00:53:13.870 --> 00:53:23.980
到4并创建此伪变量

00:53:18.820 --> 00:53:26.440
 1就是1 1，你也可以得到

00:53:23.980 --> 00:53:27.340
如果您不想访问IDE 

00:53:26.440 --> 00:53:29.640
你可以这样做

00:53:27.340 --> 00:53:33.700
我想展示的例子是

00:53:29.640 --> 00:53:36.310
任何人都试图计算相位

00:53:33.700 --> 00:53:39.190
你想知道的月亮

00:53:36.310 --> 00:53:41.740
无论是满月还是打蜡的月亮还是

00:53:39.190 --> 00:53:43.270
赢得月亮等你可以做得非常

00:53:41.740 --> 00:53:44.890
要做复杂的数学运算，我敢肯定

00:53:43.270 --> 00:53:47.350
 NASA的某人很想告诉你

00:53:44.890 --> 00:53:49.600
怎么做，但我只是作弊

00:53:47.350 --> 00:53:52.540
我将简单地转换日期

00:53:49.600 --> 00:53:54.700
您想要在农历中约会

00:53:52.540 --> 00:53:56.320
日历和农历之美

00:53:54.700 --> 00:54:00.580
日历是所有月份

00:53:56.320 --> 00:54:03.330
在1到29或30之间

00:54:00.580 --> 00:54:07.800
日期恰好符合月亮的日子

00:54:03.330 --> 00:54:11.460
所以那都是蓝色的，有一个

00:54:07.800 --> 00:54:14.550
默认情况下此处支持的日历

00:54:11.460 --> 00:54:18.300
在JDK中，这是历史悠久的日历

00:54:14.550 --> 00:54:20.430
在这里，让我们再做一次

00:54:18.300 --> 00:54:24.690
我可以每个输入日期点时间

00:54:20.430 --> 00:54:28.760
时间，但是我可以输入日期

00:54:24.690 --> 00:54:34.470
时间我很抱歉

00:54:28.760 --> 00:54:41.100
 Java点时间在这里，我需要一个

00:54:34.470 --> 00:54:45.930
其他几个让我们得到时间点

00:54:41.100 --> 00:54:47.610
计时并导入您没有的任何情况

00:54:45.930 --> 00:54:50.310
记得我可以做水龙头的Java 

00:54:47.610 --> 00:54:52.920
东西，它会告诉我，就是这样

00:54:50.310 --> 00:55:01.350
完成了，让我们尝试一下

00:54:52.920 --> 00:55:04.080
那里的时间时空，所以现在如果我

00:55:01.350 --> 00:55:05.630
只是想得到我的当前日期

00:55:04.080 --> 00:55:09.330
他们可以说些什么吗？ 

00:55:05.630 --> 00:55:13.590
本地的，我正在使用该代码完成

00:55:09.330 --> 00:55:19.920
因为我可以输入本地日期点

00:55:13.590 --> 00:55:21.300
现在这是当前日期，如果我

00:55:19.920 --> 00:55:23.130
我想知道一样

00:55:21.300 --> 00:55:26.580
导入，我将向您展示

00:55:23.130 --> 00:55:29.040
方式列表就是我键入的所有内容

00:55:26.580 --> 00:55:33.750
我想知道的话可以帮忙

00:55:29.040 --> 00:55:37.320
我能做的一切，但让我们

00:55:33.750 --> 00:55:44.400
以阴历格式显示的当前日期，以及

00:55:37.320 --> 00:55:47.690
那现在叫做cifra日期点

00:55:44.400 --> 00:55:50.730
我只想看看那天- 

00:55:47.690 --> 00:55:51.930
因为月亮从0 0开始新月

00:55:50.730 --> 00:55:56.880
我们几乎是新月，没有

00:55:51.930 --> 00:55:59.100
今天好吧，你可以做你

00:55:56.880 --> 00:56:00.570
可以看到很简单，我不必走

00:55:59.100 --> 00:56:04.500
并写出我没有做的代码

00:56:00.570 --> 00:56:06.330
甚至把分号都可以

00:56:04.500 --> 00:56:10.820
美元6会为我创建该变量

00:56:06.330 --> 00:56:10.820
点得到

00:56:16.670 --> 00:56:20.839
时空点

00:56:23.660 --> 00:56:34.440
一个月中的某天你可以去看看

00:56:32.130 --> 00:56:35.790
如果我在这里如何快速执行功能

00:56:34.440 --> 00:56:41.040
想要创建一个日期而不是使用

00:56:35.790 --> 00:56:53.880
现在我说当地的日期点，我可以说

00:56:41.040 --> 00:56:55.260
离开，然后看这是2017哦304他会

00:56:53.880 --> 00:56:57.120
这样创建日期，如您所见

00:56:55.260 --> 00:56:58.410
创建新的日期和时间很漂亮

00:56:57.120 --> 00:57:00.300
直截了当的是

00:56:58.410 --> 00:57:01.380
新的一天的美丽雇用310您

00:57:00.300 --> 00:57:03.480
不必做全部让我创造

00:57:01.380 --> 00:57:07.520
日历让我设定月份和

00:57:03.480 --> 00:57:10.590
这个日历一月的方式是

00:57:07.520 --> 00:57:14.100
猜猜上一月是什么

00:57:10.590 --> 00:57:16.020
日历零，您知道我们是开发人员

00:57:14.100 --> 00:57:19.940
我们开始计数，所以本月过去了

00:57:16.020 --> 00:57:22.140
从零到11 

00:57:19.940 --> 00:57:28.230
这就是我的小样子

00:57:22.140 --> 00:57:37.080
我要在这里完成课程

00:57:28.230 --> 00:57:39.780
从一年中的一个月日中获得一天，所以如果

00:57:37.080 --> 00:57:43.830
我说好，这是当地人的约会

00:57:39.780 --> 00:57:46.310
白天年月日这将接受

00:57:43.830 --> 00:57:50.400
一年一个月的一天，它将返回

00:57:46.310 --> 00:57:52.200
阴历日，如果你现在还可以的话

00:57:50.400 --> 00:57:55.470
阴历日基于特定城市

00:57:52.200 --> 00:57:56.880
在中东，所以不是很

00:57:55.470 --> 00:57:58.980
准确，但我会告诉你

00:57:56.880 --> 00:58:00.930
胖手指，说好吧，如果值

00:57:58.980 --> 00:58:03.870
大于四或小于十二

00:58:00.930 --> 00:58:06.720
您处于第一季度的13 

00:58:03.870 --> 00:58:08.580
和18岁至17岁之间的满月

00:58:06.720 --> 00:58:10.170
 26您在第三季度

00:58:08.580 --> 00:58:14.850
一二三的一切

00:58:10.170 --> 00:58:18.150
 27到30就是新月了，现在我

00:58:14.850 --> 00:58:19.740
可以运行它，但让我们将其

00:58:18.150 --> 00:58:21.890
我想要一点点有趣

00:58:19.740 --> 00:58:24.240
将此放入我的Oracle云

00:58:21.890 --> 00:58:28.140
帐户，因为我们当然要放

00:58:24.240 --> 00:58:32.850
它在云中，这意味着我有

00:58:28.140 --> 00:58:36.360
创建一个读取的小功能

00:58:32.850 --> 00:58:36.970
写下您通过的所有内容并将其吐出

00:58:36.360 --> 00:58:41.290
所以

00:58:36.970 --> 00:58:42.760
这是我正在使用火花没有

00:58:41.290 --> 00:58:44.080
编码任何东西，因为你

00:58:42.760 --> 00:58:46.810
知道我真的不想进入

00:58:44.080 --> 00:58:50.140
听董事会的小气概我

00:58:46.810 --> 00:58:53.859
我可以将民意调查作为参数传递

00:58:50.140 --> 00:58:56.530
不起作用，我将使用DAT，在这里

00:58:53.859 --> 00:58:58.180
说当我收到一个要求只是检查

00:58:56.530 --> 00:58:59.890
你还活着，你知道我是否不通过

00:58:58.180 --> 00:59:03.520
我会回复的一切都还活着

00:58:59.890 --> 00:59:05.560
如果我通过月亮，我通过

00:59:03.520 --> 00:59:10.060
带日期的参数我可以传递任何日期

00:59:05.560 --> 00:59:14.710
我将返回日期和时间

00:59:10.060 --> 00:59:18.340
所以这是我去我的甲骨文

00:59:14.710 --> 00:59:22.540
应用程序云，我刚刚加载了这个

00:59:18.340 --> 00:59:27.070
现在事情完全一样，你能

00:59:22.540 --> 00:59:28.330
阅读我可以写的只是看

00:59:27.070 --> 00:59:30.609
我没有作弊和适应

00:59:28.330 --> 00:59:34.750
硬编码其中的几个是

00:59:30.609 --> 00:59:38.440
 2017年加利福尼亚州的月相

00:59:34.750 --> 00:59:44.800
我只是谷歌这个权利，所以

00:59:38.440 --> 00:59:47.790
让我们尝试2017年10月5日的满月吧

00:59:44.800 --> 00:59:47.790
我们要说的是

00:59:51.800 --> 01:00:01.690
你去那里满月你想尝试

00:59:56.590 --> 01:00:01.690
假设第一季度是4月3日

01:00:06.750 --> 01:00:15.710
 Aygul，所以它已经启动并正在运行

01:00:10.040 --> 01:00:18.030
从字面上看这就是它

01:00:15.710 --> 01:00:21.270
包括我听的部分

01:00:18.030 --> 01:00:24.750
不好的话，做的一切都那么漂亮

01:00:21.270 --> 01:00:31.500
简单明了，请尝试一下

01:00:24.750 --> 01:00:36.780
你知道，你可以看到这是我

01:00:31.500 --> 01:00:38.310
已经登录，我可以告诉你

01:00:36.780 --> 01:00:44.790
关于项目的一点点

01:00:38.310 --> 01:00:47.280
因为您所有的开发人员都这样

01:00:44.790 --> 01:00:50.210
只需要这里有一个小工具

01:00:47.280 --> 01:00:55.100
它将抓住所有依赖

01:00:50.210 --> 01:01:02.130
将其放在一个jar文件中，包括

01:00:55.100 --> 01:01:05.280
小文件说我要

01:01:02.130 --> 01:01:07.650
运行它命令Java-jar，这是

01:01:05.280 --> 01:01:10.230
这个项目的名称是

01:01:07.650 --> 01:01:12.510
 jar将所有这些内容放入该zip文件中

01:01:10.230 --> 01:01:15.540
并从字面上在Oracle中运行

01:01:12.510 --> 01:01:17.370
我要做的就是上传

01:01:15.540 --> 01:01:22.620
压缩文件，这就是你所拥有的

01:01:17.370 --> 01:01:24.330
在这里跑，所以如果你有更多

01:01:22.620 --> 01:01:26.280
有关此特定部分的问题

01:01:24.330 --> 01:01:28.260
关于将它放在云上有一个

01:01:26.280 --> 01:01:30.180
在房间右边叫肖恩·史密斯的家伙

01:01:28.260 --> 01:01:32.610
隔壁的这将是

01:01:30.180 --> 01:01:34.590
在接下来的几周里可能会有啤酒

01:01:32.610 --> 01:01:38.400
我可以指出的下一次会议记录

01:01:34.590 --> 01:01:40.820
他们给你，如果你想要的就是这样谢谢

01:01:38.400 --> 01:01:40.820
你来了

01:01:42.869 --> 01:01:46.619
如果您有问题的权利

01:01:55.030 --> 01:02:07.870
好的，什么是模块和模块

01:01:57.220 --> 01:02:09.610
系统肯定可以，所以

01:02:07.870 --> 01:02:11.770
我说的是模块系统，而不是

01:02:09.610 --> 01:02:14.560
有一个整体项目要运行

01:02:11.770 --> 01:02:16.750
在JDK中，我们分离了库

01:02:14.560 --> 01:02:20.140
现在分成不同的模块

01:02:16.750 --> 01:02:22.510
在实践中，这对您意味着

01:02:20.140 --> 01:02:25.600
不在乎模块，这没什么意思

01:02:22.510 --> 01:02:27.040
对，这样您的程序将继续

01:02:25.600 --> 01:02:29.800
运行您不必切换到

01:02:27.040 --> 01:02:31.990
模块系统对他们所做的一切

01:02:29.800 --> 01:02:34.450
它会继续工作，所以它

01:02:31.990 --> 01:02:35.530
将在JDK级别影响我们，除了

01:02:34.450 --> 01:02:37.930
因为如果您使用

01:02:35.530 --> 01:02:41.400
内部API的副作用是

01:02:37.930 --> 01:02:41.400
现在由于模块系统而恢复

01:02:55.369 --> 01:03:06.540
对，正如我所说，这可能

01:02:57.690 --> 01:03:08.609
在一个完整的一小时的会议上

01:03:06.540 --> 01:03:10.020
高层是我们对集合进行了分组

01:03:08.609 --> 01:03:12.210
如果想起一堆

01:03:10.020 --> 01:03:14.190
打包所有必须要做的

01:03:12.210 --> 01:03:15.660
安全地集成到一个模块中

01:03:14.190 --> 01:03:20.160
必须将桌面管理到

01:03:15.660 --> 01:03:22.109
一个模块是不同的

01:03:20.160 --> 01:03:25.970
就像我说的是它的集合

01:03:22.109 --> 01:03:30.060
 api是内置于每个模块中的

01:03:25.970 --> 01:03:32.099
每两个都有一些依赖

01:03:30.060 --> 01:03:35.480
我可能应该使用不同的模块

01:03:32.099 --> 01:03:35.480
向您展示模块系统映像

01:03:47.170 --> 01:03:52.680
 [音乐] 

01:03:48.990 --> 01:03:55.080
对，所以我们已经将JDK模块化了

01:03:52.680 --> 01:03:57.390
开发人员可以模仿并做到这一点

01:03:55.080 --> 01:03:59.280
到您自己的代码并分离您的代码

01:03:57.390 --> 01:04:00.390
而不只是让你知道

01:03:59.280 --> 01:04:03.390
套餐级别可以有不同

01:04:00.390 --> 01:04:04.500
模块的想法是

01:04:03.390 --> 01:04:06.270
将是独立的

01:04:04.500 --> 01:04:07.589
他们只会让你知道他们会创建一个

01:04:06.270 --> 01:04:10.020
依赖图，因此很容易

01:04:07.589 --> 01:04:14.270
现在一次不更新模块

01:04:10.020 --> 01:04:14.270
必须做任何事情，但是你可以

01:04:17.990 --> 01:04:29.280
是的，我的意思是我说的是

01:04:26.310 --> 01:04:32.520
可以说以前的JDK是一个

01:04:29.280 --> 01:04:34.619
巨大的模块适合您，如果您没有

01:04:32.520 --> 01:04:35.700
想排除任何你漂亮的模块

01:04:34.619 --> 01:04:51.570
和你以前在同一个地方

01:04:35.700 --> 01:04:53.280
在我说好之前，让我别针

01:04:51.570 --> 01:04:55.200
那个人来这里是因为我说过

01:04:53.280 --> 01:04:56.339
我们可以花超过五倍的钱

01:04:55.200 --> 01:04:58.200
分钟不是三分钟

01:04:56.339 --> 01:05:00.240
对话更像是三十

01:04:58.200 --> 01:05:02.660
分钟的交谈，我很乐意

01:05:00.240 --> 01:05:07.080
现在就在这里

01:05:02.660 --> 01:05:11.180
和其他人在这里好吧，再见

01:05:07.080 --> 01:05:11.180
茶点桌上的家伙

