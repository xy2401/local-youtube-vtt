WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.200 --> 00:00:07.919
 [音乐] 

00:00:03.350 --> 00:00:10.139
所以这个话题是关于我们在哪里

00:00:07.919 --> 00:00:12.870
将JVM推送到JVM似乎在哪里

00:00:10.139 --> 00:00:15.960
不管我们是否推动

00:00:12.870 --> 00:00:18.630
我们认为我们甚至会在10 

00:00:15.960 --> 00:00:20.970
或20年就是10或20年

00:00:18.630 --> 00:00:22.619
进入Java生态系统，我们认为

00:00:20.970 --> 00:00:26.130
至少还有很多时间可以运行

00:00:22.619 --> 00:00:28.349
保存和保护的关键方法之一

00:00:26.130 --> 00:00:30.810
扩展工作和任务

00:00:28.349 --> 00:00:32.880
 JVM和Java是为了确保我们

00:00:30.810 --> 00:00:35.219
能够完成即将到来的工作

00:00:32.880 --> 00:00:39.020
以后我想谈谈

00:00:35.219 --> 00:00:42.270
关于今天，这将是我，我是

00:00:39.020 --> 00:00:44.640
我是JVM的架构师

00:00:42.270 --> 00:00:48.000
绝不是全部设计，而是

00:00:44.640 --> 00:00:50.700
我是现任Oracle架构师

00:00:48.000 --> 00:00:53.340
我参与了JVM团队

00:00:50.700 --> 00:00:54.809
自Java几乎开始以来

00:00:53.340 --> 00:00:58.260
大约二十年了

00:00:54.809 --> 00:01:00.410
所以我想告诉你它的样子

00:00:58.260 --> 00:01:03.930
对我以及我们团队的感觉如何

00:01:00.410 --> 00:01:05.489
以及在某种程度上它看起来如何

00:01:03.930 --> 00:01:07.500
 JDK社区我不代表

00:01:05.489 --> 00:01:10.710
我为自己和整个社区说话

00:01:07.500 --> 00:01:13.740
我的团队和甲骨文，但我也希望

00:01:10.710 --> 00:01:15.479
为我们社区想要的地方说话

00:01:13.740 --> 00:01:16.790
配合这项奇妙的技术

00:01:15.479 --> 00:01:19.110
请享用

00:01:16.790 --> 00:01:24.450
但是律师指示我告诉

00:01:19.110 --> 00:01:25.799
你不要相信我说的话

00:01:24.450 --> 00:01:28.829
想做我想给你一些

00:01:25.799 --> 00:01:31.619
我想展示我们的趋势

00:01:28.829 --> 00:01:34.079
今天采取具体行动

00:01:31.619 --> 00:01:36.630
那些趋势使它变得复杂

00:01:34.079 --> 00:01:38.820
说话，我要说话快，我要

00:01:36.630 --> 00:01:42.899
每张幻灯片我有大约一分钟的时间

00:01:38.820 --> 00:01:44.880
还是不多，所以它来了

00:01:42.899 --> 00:01:48.479
我没有时间把它缩短

00:01:44.880 --> 00:01:50.729
正如雅致的信作者所说

00:01:48.479 --> 00:01:52.890
这是一个鼻涕，这是我的幻灯片

00:01:50.729 --> 00:01:55.140
几年前喜欢

00:01:52.890 --> 00:01:58.079
 JVM语言峰会上有多少人

00:01:55.140 --> 00:02:01.740
参加过JVM语言峰会

00:01:58.079 --> 00:02:03.450
是的，这是爆炸，总是很拥挤

00:02:01.740 --> 00:02:05.009
房间里充满了疯狂的人

00:02:03.450 --> 00:02:09.270
考虑下一步的步骤

00:02:05.009 --> 00:02:11.550
 Java Runtime我们有一些我们认为我们

00:02:09.270 --> 00:02:13.260
有一些长期目标

00:02:11.550 --> 00:02:17.040
坚持下一个

00:02:13.260 --> 00:02:19.110
或二十年，至今两年

00:02:17.040 --> 00:02:22.439
进入预测周期

00:02:19.110 --> 00:02:24.720
工作，我们希望Java运行时具有

00:02:22.439 --> 00:02:26.790
一个统一的模型，我们希望所有

00:02:24.720 --> 00:02:29.879
感到相似的数据片段

00:02:26.790 --> 00:02:32.040
你所学反射的事物

00:02:29.879 --> 00:02:33.900
使用数组处理值

00:02:32.040 --> 00:02:35.790
对象，基元和方法以及

00:02:33.900 --> 00:02:37.799
您想要分配的类型

00:02:35.790 --> 00:02:40.319
将任何内容传递给变量

00:02:37.799 --> 00:02:42.870
作为参数返回任何东西作为

00:02:40.319 --> 00:02:46.019
结果就是您想要的东西

00:02:42.870 --> 00:02:47.849
您想要统一的强类型

00:02:46.019 --> 00:02:51.120
处理所有不同的方式

00:02:47.849 --> 00:02:53.220
应用程序组成的详细信息和

00:02:51.120 --> 00:02:55.290
您希望所有这些都非常

00:02:53.220 --> 00:02:57.629
您想要的高效内存

00:02:55.290 --> 00:03:00.060
具有可以进行的数据布局

00:02:57.629 --> 00:03:03.959
调整为尽可能平整

00:03:00.060 --> 00:03:06.180
具有易于制作的数据， 

00:03:03.959 --> 00:03:07.829
然后当你决定

00:03:06.180 --> 00:03:10.109
特定类型的关键任务

00:03:07.829 --> 00:03:12.030
数据非常紧凑非常有效

00:03:10.109 --> 00:03:13.500
你希望厨师能够消费

00:03:12.030 --> 00:03:16.170
进行额外的调整

00:03:13.500 --> 00:03:19.410
尽管特别代表

00:03:16.170 --> 00:03:23.099
 Java VM和语言开始是一种

00:03:19.410 --> 00:03:27.510
更好的闲聊

00:03:23.099 --> 00:03:31.889
说或更好的C ++，您不希望这么做

00:03:27.510 --> 00:03:33.900
如此集中指针以获取

00:03:31.889 --> 00:03:35.849
当今高效的内存布局指针

00:03:33.900 --> 00:03:37.859
实际上比他们要高

00:03:35.849 --> 00:03:40.470
在20年前，在20年之前

00:03:37.859 --> 00:03:41.819
成本可能会更高

00:03:40.470 --> 00:03:43.500
我们希望能够拥有数据布局

00:03:41.819 --> 00:03:46.379
指针节俭是新的

00:03:43.500 --> 00:03:48.000
 Java的新方向

00:03:46.379 --> 00:03:51.449
无法预料的20 

00:03:48.000 --> 00:03:54.480
多年前，我们一直想要的一件事

00:03:51.449 --> 00:03:56.940
是速度和好的代码计算机

00:03:54.480 --> 00:03:58.829
运行在错误的代码上，英特尔实际上可以运行

00:03:56.940 --> 00:04:01.440
在非常糟糕的代码上，但这太神奇了

00:03:58.829 --> 00:04:04.139
无论如何，他们如何做到这一点

00:04:01.440 --> 00:04:06.239
想要您负责的代码

00:04:04.139 --> 00:04:08.069
被有效地编译为

00:04:06.239 --> 00:04:11.000
尽可能的硬件，我们希望

00:04:08.069 --> 00:04:13.169
继续是真实的Java在线使用

00:04:11.000 --> 00:04:15.239
优化技术意味着

00:04:13.169 --> 00:04:17.190
它可以在许多情况下产生更好的热循环

00:04:15.239 --> 00:04:19.019
比静态编译器（例如C和

00:04:17.190 --> 00:04:21.539
 C ++ 

00:04:19.019 --> 00:04:24.180
未来我想我们会少

00:04:21.539 --> 00:04:26.009
线程或更多小东西

00:04:24.180 --> 00:04:29.759
曾经是更好的线程，但是

00:04:26.009 --> 00:04:31.680
更易组合和敏捷，所以我们希望我们

00:04:29.759 --> 00:04:34.440
想触发更细粒度的并发

00:04:31.680 --> 00:04:37.500
同时更少的程度

00:04:34.440 --> 00:04:39.840
创造种族的不重要自由

00:04:37.500 --> 00:04:42.120
在我们的应用程序中的条件

00:04:39.840 --> 00:04:44.910
我会说未来是帖子线程

00:04:42.120 --> 00:04:48.000
因此，请考虑一下

00:04:44.910 --> 00:04:50.009
未来也是可以互操作的

00:04:48.000 --> 00:04:51.690
你可以写一种语言的情况

00:04:50.009 --> 00:04:53.400
如此引人注目，每个人都会

00:04:51.690 --> 00:04:54.780
删除其现有的源代码并

00:04:53.400 --> 00:04:56.789
他们现有的图书馆，然后转到

00:04:54.780 --> 00:05:00.180
语言和其中的代码

00:04:56.789 --> 00:05:02.190
他们的生活没用，但是

00:05:00.180 --> 00:05:04.590
你能做的就是提供一种语言

00:05:02.190 --> 00:05:06.870
真正有能力连接

00:05:04.590 --> 00:05:08.669
这些预先存在的组件和

00:05:06.870 --> 00:05:10.319
拿那些你已经在图书馆

00:05:08.669 --> 00:05:12.780
依靠并以新方式将它们结合起来

00:05:10.319 --> 00:05:14.610
并开发新的应用程序和一种语言

00:05:12.780 --> 00:05:15.990
那样做的很好

00:05:14.610 --> 00:05:19.919
成为人们更多使用的语言

00:05:15.990 --> 00:05:21.750
更多，也许最终

00:05:19.919 --> 00:05:23.520
将要写入的内容数量

00:05:21.750 --> 00:05:25.050
它，但仍然可以与所有人一起使用

00:05:23.520 --> 00:05:26.430
未翻译的东西

00:05:25.050 --> 00:05:27.840
听起来的新语言

00:05:26.430 --> 00:05:29.699
熟悉的，这真的是

00:05:27.840 --> 00:05:34.349
 Java的一生已成为美妙的粘合剂

00:05:29.699 --> 00:05:35.849
对于应用程序以及一些东西

00:05:34.349 --> 00:05:41.759
自己编写新算法

00:05:35.849 --> 00:05:43.650
对，当然你要

00:05:41.759 --> 00:05:46.320
像Java这样的通用语言

00:05:43.650 --> 00:05:47.370
你不希望它在20年后

00:05:46.320 --> 00:05:48.539
不想看Java说哦

00:05:47.370 --> 00:05:50.219
是的，这就是编写代码

00:05:48.539 --> 00:05:52.110
以他们写的方式应用20 

00:05:50.219 --> 00:05:53.849
多年前那不是那样

00:05:52.110 --> 00:05:55.590
今天是今天的语言

00:05:53.849 --> 00:05:59.599
编写我们想要的现代应用程序

00:05:55.590 --> 00:06:03.330
继续像那样，最后

00:05:59.599 --> 00:06:05.340
胶水的工作之一是胶水是

00:06:03.330 --> 00:06:07.830
保持一秒钟以上

00:06:05.340 --> 00:06:09.870
写一年后放手的胶水是

00:06:07.830 --> 00:06:11.400
如果工作需要，胶水不是很好

00:06:09.870 --> 00:06:13.949
用来将东西粘在一起

00:06:11.400 --> 00:06:15.750
你想让胶水持续很长时间

00:06:13.949 --> 00:06:18.840
您希望成为图书馆质量的时间

00:06:15.750 --> 00:06:21.419
这意味着创建的罐子

00:06:18.840 --> 00:06:25.500
 20年前30年前未来

00:06:21.419 --> 00:06:28.199
应该仍然继续运行我打电话给他们

00:06:25.500 --> 00:06:31.020
尘土飞扬的罐子，并比喻

00:06:28.199 --> 00:06:33.210
老式的尘土飞扬的甲板就可以了

00:06:31.020 --> 00:06:35.930
一堆尘土飞扬的Fortran代码会运行吗

00:06:33.210 --> 00:06:38.760
我不知道这总是冒险

00:06:35.930 --> 00:06:42.270
最后，无论未来如何发展

00:06:38.760 --> 00:06:44.580
您知道更多核心的新型CPU类型

00:06:42.270 --> 00:06:46.139
知道即将发生什么的数据路径

00:06:44.580 --> 00:06:50.699
持久的记忆是一件大事，对吧

00:06:46.139 --> 00:06:52.500
现在，无论我们想要什么新的CPU 

00:06:50.699 --> 00:06:54.479
 JVM和Java Runtime以及

00:06:52.500 --> 00:06:57.570
 Java语言团队对此进行跟踪

00:06:54.479 --> 00:06:59.550
并能够编译有用的程序

00:06:57.570 --> 00:07:02.699
高效地应对那些新CPU 

00:06:59.550 --> 00:07:05.070
这意味着我们不能只坚持

00:07:02.699 --> 00:07:09.389
 64位Long，并说这是结束

00:07:05.070 --> 00:07:11.219
我们所有原始的东西都是

00:07:09.389 --> 00:07:14.310
很难预测，但有时您可以

00:07:11.219 --> 00:07:16.259
取当地的衍生品

00:07:14.310 --> 00:07:17.580
使向量中的向量过于简单

00:07:16.259 --> 00:07:19.409
你认为你要去的方向， 

00:07:17.580 --> 00:07:21.270
然后也许当你将来

00:07:19.409 --> 00:07:23.159
你到那里的时候你会说是的

00:07:21.270 --> 00:07:25.139
该向量已关闭，但并没有关闭

00:07:23.159 --> 00:07:27.360
太对了，那是你在做什么的时候

00:07:25.139 --> 00:07:31.279
您通过以下方式进行预测： 

00:07:27.360 --> 00:07:31.279
我的两个图形，希望您喜欢

00:07:31.550 --> 00:07:37.949
这些幻灯片将放在我的

00:07:35.310 --> 00:07:40.740
演示页面和openjdk有一个

00:07:37.949 --> 00:07:42.120
链接的末尾，这样您就不会

00:07:40.740 --> 00:07:43.620
能够阅读所有这些，但我不是

00:07:42.120 --> 00:07:45.509
我将能够解释所有这些

00:07:43.620 --> 00:07:50.130
事实上，我可能必须开始

00:07:45.509 --> 00:07:52.110
无论如何，这是一些趋势

00:07:50.130 --> 00:07:54.419
在JVM设计中，我们看到的是正确的

00:07:52.110 --> 00:07:56.159
现在这里是尝试绘制

00:07:54.419 --> 00:07:58.320
在这个点上看的那个向量

00:07:56.159 --> 00:08:01.889
我们认为可预测性和

00:07:58.320 --> 00:08:05.550
安全可靠性在不断提高

00:08:01.889 --> 00:08:08.130
我们希望能够创造的重要性

00:08:05.550 --> 00:08:11.339
 JVM打包的应用程序Java 

00:08:08.130 --> 00:08:13.199
可以预配的应用程序

00:08:11.339 --> 00:08:14.909
提前做一些特定的工作，然后

00:08:13.199 --> 00:08:16.919
可靠地快速启动以执行这些操作

00:08:14.909 --> 00:08:19.889
工作，没有，只消耗一个

00:08:16.919 --> 00:08:22.139
我们想要的可预测资源量

00:08:19.889 --> 00:08:24.899
资源消耗是

00:08:22.139 --> 00:08:26.610
可管理的，我们希望它是可调的，如果

00:08:24.899 --> 00:08:29.070
他们将是我们想要的GC暂停

00:08:26.610 --> 00:08:31.740
 GC暂停以可控制

00:08:29.070 --> 00:08:34.020
长度这是这是这不是

00:08:31.740 --> 00:08:35.550
我们今天做得很好，但

00:08:34.020 --> 00:08:37.319
我们正在努力工作，我们已经

00:08:35.550 --> 00:08:39.569
取得了一些进展，接下来

00:08:37.319 --> 00:08:41.699
几年我们会做更多

00:08:39.569 --> 00:08:43.860
另外，我们希望能够进步

00:08:41.699 --> 00:08:45.959
将遥测从

00:08:43.860 --> 00:08:48.450
并查看该VM发生了什么情况，并

00:08:45.959 --> 00:08:50.399
远距离控制它，这样您就不会

00:08:48.450 --> 00:08:51.890
必须亲密接触

00:08:50.399 --> 00:08:54.329
调试器以便对其进行正确管理

00:08:51.890 --> 00:08:55.920
每个人都知道这就是未来的方向

00:08:54.329 --> 00:08:58.470
计算进入大数据

00:08:55.920 --> 00:09:00.660
中心，所以我们有许多日志记录

00:08:58.470 --> 00:09:02.610
功能和远程管理

00:09:00.660 --> 00:09:04.110
能力，我们将继续

00:09:02.610 --> 00:09:09.769
投资那些我认为这将

00:09:04.110 --> 00:09:11.970
重要的是我已经提到过密度

00:09:09.769 --> 00:09:13.440
数据指针节俭的平坦度

00:09:11.970 --> 00:09:15.300
这将很重要，因为

00:09:13.440 --> 00:09:16.350
我们正在投入越来越多的东西

00:09:15.300 --> 00:09:18.570
内存，因为内存只是越来越

00:09:16.350 --> 00:09:21.540
更大的内存也越来越少

00:09:18.570 --> 00:09:24.180
统一内存高达TB 

00:09:21.540 --> 00:09:27.089
缩放，但它变得越来越慢，因为

00:09:24.180 --> 00:09:29.310
这是一种特殊的持久性记忆

00:09:27.089 --> 00:09:31.290
所以它不仅活在

00:09:29.310 --> 00:09:33.300
进程死了，但获取起来也比较慢

00:09:31.290 --> 00:09:36.750
进出数据

00:09:33.300 --> 00:09:39.709
所以我们需要继续

00:09:36.750 --> 00:09:41.459
提供许多尺寸适合许多

00:09:39.709 --> 00:09:43.860
创建数据的机会

00:09:41.459 --> 00:09:46.130
不是所有尺寸的结构都能适合

00:09:43.860 --> 00:09:48.230
 Lisp或闲聊模型

00:09:46.130 --> 00:09:50.760
不变性也很重要

00:09:48.230 --> 00:09:53.690
不变是避免的关键

00:09:50.760 --> 00:09:55.680
那些意外的比赛条件

00:09:53.690 --> 00:09:57.329
你意想不到的自由度

00:09:55.680 --> 00:10:00.089
数据结构您真的需要吗

00:09:57.329 --> 00:10:01.800
可用的领域是

00:10:00.089 --> 00:10:03.089
当你当你吸引虫子

00:10:01.800 --> 00:10:04.680
在事情发生之前先交出

00:10:03.089 --> 00:10:07.079
完全安定下来再记忆

00:10:04.680 --> 00:10:08.490
别人读值读

00:10:07.079 --> 00:10:11.100
字段，然后再将值存储在

00:10:08.490 --> 00:10:13.110
它或某些攻击者设法注意到

00:10:11.100 --> 00:10:14.540
进入该领域并投放的方式

00:10:13.110 --> 00:10:17.480
比赛条件只是

00:10:14.540 --> 00:10:20.370
没有人没有人从比赛条件中获胜

00:10:17.480 --> 00:10:21.810
最好减少自由度

00:10:20.370 --> 00:10:25.740
和数据结构，尤其是

00:10:21.810 --> 00:10:27.779
锁定所有人的不变性

00:10:25.740 --> 00:10:29.579
知道不只是

00:10:27.779 --> 00:10:33.180
世界上一种编程语言

00:10:29.579 --> 00:10:34.829
 JVM拥抱Java留下了很多东西

00:10:33.180 --> 00:10:36.990
其他语言运行的空间

00:10:34.829 --> 00:10:39.000
它旁边，所以我们想要

00:10:36.990 --> 00:10:41.040
互操作性和

00:10:39.000 --> 00:10:42.690
选择您想要的语言

00:10:41.040 --> 00:10:45.440
同时我们要做到最好

00:10:42.690 --> 00:10:48.930
我们知道如何制作的语言- 

00:10:45.440 --> 00:10:51.510
最后，我认为这是一个趋势

00:10:48.930 --> 00:10:54.810
对创作者很重要

00:10:51.510 --> 00:10:56.760
我们想要成为虚拟机的基础架构

00:10:54.810 --> 00:10:57.190
能够更好地分层实施

00:10:56.760 --> 00:10:58.870
我们

00:10:57.190 --> 00:11:00.610
想写这么多汇编代码

00:10:58.870 --> 00:11:02.260
不想写太多的C ++代码

00:11:00.610 --> 00:11:03.940
坦率地说，通常感觉像

00:11:02.260 --> 00:11:05.530
我们希望能够的汇编代码

00:11:03.940 --> 00:11:07.930
用Java和

00:11:05.530 --> 00:11:09.990
更高级的Java，当我

00:11:07.930 --> 00:11:12.160
说的东西，我的意思是实际上

00:11:09.990 --> 00:11:14.170
解释Java代码，所以有一个

00:11:12.160 --> 00:11:17.050
真正的元圆自举问题

00:11:14.170 --> 00:11:19.360
在这里，但这就是已知的解决方法

00:11:17.050 --> 00:11:21.460
我们希望能够创建

00:11:19.360 --> 00:11:23.980
不仅对我们而且对我们

00:11:21.460 --> 00:11:27.190
还有我们的程序员和编译器

00:11:23.980 --> 00:11:28.720
实施者也只表达什么

00:11:27.190 --> 00:11:30.640
他们需要在字节码中没有

00:11:28.720 --> 00:11:32.710
创造了大量的样板

00:11:30.640 --> 00:11:34.120
字节码级别的代码，就像在

00:11:32.710 --> 00:11:35.920
我们的源代码级别

00:11:34.120 --> 00:11:37.810
对样板过敏，我们喜欢使用ID 

00:11:35.920 --> 00:11:39.490
为了帮助我们扩展它，我们希望VM 

00:11:37.810 --> 00:11:41.860
能够在处扩展样板

00:11:39.490 --> 00:11:43.510
字节码级别invokedynamic是一个

00:11:41.860 --> 00:11:45.490
我们想要的例子，我们想要一个

00:11:43.510 --> 00:11:48.010
更加统一的数据模型

00:11:45.490 --> 00:11:50.770
输入值，然后最后

00:11:48.010 --> 00:11:54.070
自己实现JVM 

00:11:50.770 --> 00:11:56.830
语言，我们对他们感到非常兴奋

00:11:54.070 --> 00:11:59.230
较新的技术，例如抓取

00:11:56.830 --> 00:12:00.730
允许您拥有完整的代码

00:11:59.230 --> 00:12:06.610
用Java编写的管道

00:12:00.730 --> 00:12:11.110
随身携带的工作好一些大创意

00:12:06.610 --> 00:12:12.790
与这些趋势有关的

00:12:11.110 --> 00:12:14.970
平台应与

00:12:12.790 --> 00:12:17.350
附近的其他平台

00:12:14.970 --> 00:12:20.020
让我们看一下本机代码和数据

00:12:17.350 --> 00:12:22.120
就像Java代码和数据一样，我们不能

00:12:20.020 --> 00:12:23.890
使所有差异消失，但

00:12:22.120 --> 00:12:27.310
让他们在一起，让我们治愈

00:12:23.890 --> 00:12:30.040
让我们不要强迫程序员

00:12:27.310 --> 00:12:32.620
离开Java生态系统以便

00:12:30.040 --> 00:12:34.330
在这里或公寓得到一个紧密的循环

00:12:32.620 --> 00:12:37.120
此处或关闭的数据结构

00:12:34.330 --> 00:12:38.740
这就是为什么我很安全

00:12:37.120 --> 00:12:40.510
是在几年前引入的

00:12:38.740 --> 00:12:42.460
不必离开Java生态系统

00:12:40.510 --> 00:12:45.760
为了进入本机内存，我们有

00:12:42.460 --> 00:12:48.430
更好的替代品，例如

00:12:45.760 --> 00:12:50.560
巴拿马项目，让您得到

00:12:48.430 --> 00:12:53.860
以一种类型安全的方式存储本机数据

00:12:50.560 --> 00:12:55.750
无论如何，大主意是不要强迫

00:12:53.860 --> 00:12:58.240
人们离开托管运行时

00:12:55.750 --> 00:13:00.190
为了管理事情，我们聊了

00:12:58.240 --> 00:13:05.770
昨晚在老板那里

00:13:00.190 --> 00:13:08.950
巴拿马这是这部分取决于

00:13:05.770 --> 00:13:11.150
在值类型上，因为Java的类

00:13:08.950 --> 00:13:12.620
当前绑定到Java对象，并且

00:13:11.150 --> 00:13:14.030
会认为课程本质上是

00:13:12.620 --> 00:13:17.030
与物体捆绑在一起，但它们不是一类

00:13:14.030 --> 00:13:19.550
是一堆命名的API点方法

00:13:17.030 --> 00:13:20.740
和和数据连接字段，如果您

00:13:19.550 --> 00:13:23.540
将

00:13:20.740 --> 00:13:27.140
与无关的接口

00:13:23.540 --> 00:13:28.880
对象必定特别是

00:13:27.140 --> 00:13:31.310
类所做的对象的一部分

00:13:28.880 --> 00:13:32.780
与身份无关

00:13:31.310 --> 00:13:34.370
您可以拥有的对象的状态

00:13:32.780 --> 00:13:37.400
完美的课程，不是

00:13:34.370 --> 00:13:38.810
有状态的，这正是我们

00:13:37.400 --> 00:13:41.210
处理项目中的价值类型

00:13:38.810 --> 00:13:44.420
瓦尔哈拉我们正在创造我们正在创造

00:13:41.210 --> 00:13:46.970
没有的值

00:13:44.420 --> 00:13:48.800
与之相关的间接费用和负担

00:13:46.970 --> 00:13:51.620
标头和指针的对象

00:13:48.800 --> 00:13:53.350
以及州和种族条件

00:13:51.620 --> 00:13:58.070
具有其他所有优点

00:13:53.350 --> 00:14:00.830
这会让我们有小

00:13:58.070 --> 00:14:03.140
轻量级的敏捷数据类型，可以

00:14:00.830 --> 00:14:05.210
然后用作其他部分的游标

00:14:03.140 --> 00:14:06.890
换句话说，世界的智慧

00:14:05.210 --> 00:14:08.630
 C ++中的指针，您称它们为智能指针

00:14:06.890 --> 00:14:10.460
指针智能指针有点

00:14:08.630 --> 00:14:12.110
您可以轻松工作的结构权

00:14:10.460 --> 00:14:15.140
它有自己的不变式

00:14:12.110 --> 00:14:16.580
自己的行为就是我们

00:14:15.140 --> 00:14:18.440
也可以用Java来做，这是其中之一

00:14:16.580 --> 00:14:22.790
那是瓦尔哈拉的结果之一

00:14:18.440 --> 00:14:26.030
会给我们描述不状态的方法

00:14:22.790 --> 00:14:28.370
由Java堆拥有，但不是

00:14:26.030 --> 00:14:31.570
指出聪明地指出

00:14:28.370 --> 00:14:31.570
宇宙中的其他地方

00:14:32.440 --> 00:14:37.700
互操作性还取决于一种方式

00:14:35.390 --> 00:14:38.360
从Java代码过渡到本机代码

00:14:37.700 --> 00:14:42.080
至

00:14:38.360 --> 00:14:43.850
非非Java布局，而JIT是

00:14:42.080 --> 00:14:45.710
很棒的代码生成器

00:14:43.850 --> 00:14:48.560
没有什么表明Java喷气机有

00:14:45.710 --> 00:14:51.410
生成仅用于

00:14:48.560 --> 00:14:52.900
与Java数据结构

00:14:51.410 --> 00:14:57.590
完美的通用代码生成

00:14:52.900 --> 00:15:00.230
它的力量堪比

00:14:57.590 --> 00:15:03.790
其他代码生成器，例如GCC back 

00:15:00.230 --> 00:15:06.710
结束或LLVM，因此我们将其用于

00:15:03.790 --> 00:15:12.130
这将使耦合到更广泛

00:15:06.710 --> 00:15:15.470
硬件类型范围，数据类型和

00:15:12.130 --> 00:15:17.510
为了有一个如果我们得到

00:15:15.470 --> 00:15:20.330
更好的互操作性故事

00:15:17.510 --> 00:15:22.550
这就是巴拿马

00:15:20.330 --> 00:15:25.160
针对巴拿马项目，我们将

00:15:22.550 --> 00:15:27.620
能够用Java代码编写

00:15:25.160 --> 00:15:31.009
自然且类似于Java并能够

00:15:27.620 --> 00:15:34.100
与某些Java IDE的Java强强合作

00:15:31.009 --> 00:15:37.160
键入Java封装，但仍然

00:15:34.100 --> 00:15:40.879
有指向灰尘的智能指针

00:15:37.160 --> 00:15:42.829
甲板COBOL图像或尖端的GPU 

00:15:40.879 --> 00:15:45.230
阵列，并能够进入那里， 

00:15:42.829 --> 00:15:50.060
在没有离开的情况下完成工作

00:15:45.230 --> 00:15:52.430
 Java调用的舒适性

00:15:50.060 --> 00:15:54.259
特别是我们有一些东西

00:15:52.430 --> 00:15:56.720
我称Java为as in语句

00:15:54.259 --> 00:15:59.720
在原型中，您可以

00:15:56.720 --> 00:16:01.879
做一个方法，我希望你有

00:15:59.720 --> 00:16:04.430
听说过方法句柄

00:16:01.879 --> 00:16:07.370
封装一条指令

00:16:04.430 --> 00:16:09.379
有一点信息要告诉

00:16:07.370 --> 00:16:12.110
注册该指令的JIT 

00:16:09.379 --> 00:16:13.910
使用，否则只是告诉JIT 

00:16:12.110 --> 00:16:16.189
我打电话时放下这条指令

00:16:13.910 --> 00:16:18.800
这个方法可以处理

00:16:16.189 --> 00:16:20.480
 Java的NASM声明，我们在

00:16:18.800 --> 00:16:22.730
与其他技术结合

00:16:20.480 --> 00:16:26.029
一些英特尔工程师确实在做

00:16:22.730 --> 00:16:28.370
出色的工作创造了非常好的轻松

00:16:26.029 --> 00:16:30.470
使用Java API进行直接编码

00:16:28.370 --> 00:16:32.689
向量循环，这在我看来

00:16:30.470 --> 00:16:36.370
当前编码矢量的最佳方法

00:16:32.689 --> 00:16:39.259
你已经在英特尔上循环了

00:16:36.370 --> 00:16:47.750
汇编语言和新CC 

00:16:39.259 --> 00:16:50.360
内在函数，但是这样更好

00:16:47.750 --> 00:16:51.470
泛泛地说，我已经

00:16:50.360 --> 00:16:53.660
提到了几次

00:16:51.470 --> 00:16:56.720
这是互连的故事

00:16:53.660 --> 00:16:58.790
紧随J，而我则更广泛

00:16:56.720 --> 00:17:01.009
管理之间的更广泛的高速公路

00:16:58.790 --> 00:17:03.740
最终管理的世界，而不是

00:17:01.009 --> 00:17:07.100
红带缠着狭窄的小径

00:17:03.740 --> 00:17:10.250
 j'ni的目标之一是，我们拥有

00:17:07.100 --> 00:17:12.049
昨晚保罗的零手写代码

00:17:10.250 --> 00:17:16.159
桑托斯对此做了出色的演示

00:17:12.049 --> 00:17:18.350
他展示了一个C语言API 

00:17:16.159 --> 00:17:19.280
与头文件，并在动态

00:17:18.350 --> 00:17:21.199
链接库

00:17:19.280 --> 00:17:23.839
他将头文件运行到头文件

00:17:21.199 --> 00:17:26.360
 grovel或称为J提取它提取

00:17:23.839 --> 00:17:28.100
元数据元数据大约是六个

00:17:26.360 --> 00:17:30.590
格式为千字节

00:17:28.100 --> 00:17:32.030
一个罐子是一堆接口

00:17:30.590 --> 00:17:34.700
您可以放入您的真实界面

00:17:32.030 --> 00:17:37.600
 IDE，并查看有关以下内容的注释

00:17:34.700 --> 00:17:38.690
绑定，然后将其输入到

00:17:37.600 --> 00:17:40.820
绑定

00:17:38.690 --> 00:17:42.529
在

00:17:40.820 --> 00:17:44.779
可以连接的接口

00:17:42.529 --> 00:17:48.230
立即将数据和代码

00:17:44.779 --> 00:17:51.110
 C API，它是普通的非凡的东西

00:17:48.230 --> 00:17:52.639
具有数十种数据结构的C API和

00:17:51.110 --> 00:17:54.679
数十个功能入口点和

00:17:52.639 --> 00:17:55.879
指针和护理之星等

00:17:54.679 --> 00:17:59.480
周围没有漂浮的东西

00:17:55.879 --> 00:18:01.129
使用Java的前提条件

00:17:59.480 --> 00:18:04.429
如果您按照旧的j'ni方式进行操作

00:18:01.129 --> 00:18:06.080
你有10 KB的东西

00:18:04.429 --> 00:18:08.659
不是自动的东西

00:18:06.080 --> 00:18:11.480
由提取器生成的，您必须

00:18:08.659 --> 00:18:14.450
写它的每个字节都是Java代码

00:18:11.480 --> 00:18:18.769
和C绑定中的Java代码

00:18:14.450 --> 00:18:21.259
本机功能，这没什么好玩的

00:18:18.769 --> 00:18:23.629
也可以使用这种新方法

00:18:21.259 --> 00:18:25.669
得到直接可优化的电话

00:18:23.629 --> 00:18:27.350
我刚才说过你直接

00:18:25.669 --> 00:18:28.580
可优化访问堆外

00:18:27.350 --> 00:18:30.769
等同于您将从中得到的

00:18:28.580 --> 00:18:33.679
不安全，但都是安全的，并且

00:18:30.769 --> 00:18:35.960
为您管理也可以获得存储

00:18:33.679 --> 00:18:37.909
可以帮助您的管理抽象

00:18:35.960 --> 00:18:40.580
避免悬空指针是

00:18:37.909 --> 00:18:42.100
 C的问题，然后最后

00:18:40.580 --> 00:18:46.549
我之前提到的直接访问

00:18:42.100 --> 00:18:49.490
像256位向量这样的巨型数据类型

00:18:46.549 --> 00:18:50.870
在类似的事情中那些将是一个

00:18:49.490 --> 00:18:53.090
我们做价值类型的原因

00:18:50.870 --> 00:18:55.309
 Java在Valhalla项目中，这样我们

00:18:53.090 --> 00:18:59.269
可以直接与

00:18:55.309 --> 00:19:01.759
 CPU抛出的任何数据类型

00:18:59.269 --> 00:19:07.460
即使它们大于64位

00:19:01.759 --> 00:19:10.700
大小，最后我们想要酷

00:19:07.460 --> 00:19:14.509
提供更好的胶水更好地使用

00:19:10.700 --> 00:19:18.830
本地资源

00:19:14.509 --> 00:19:20.750
 Java托管运行时的另一个好主意

00:19:18.830 --> 00:19:22.009
我已经提到过，但我不会扩展

00:19:20.750 --> 00:19:25.009
 on on Java是Java 

00:19:22.009 --> 00:19:27.980
让我们在以下基础上实现Java堆栈

00:19:25.009 --> 00:19:30.200
 Java让我们减少对

00:19:27.980 --> 00:19:32.419
汇编代码以及C和C ++ 

00:19:30.200 --> 00:19:33.919
特别是由于C ++正在

00:19:32.419 --> 00:19:37.009
自己的方向与自己的

00:19:33.919 --> 00:19:42.320
托管运行时祝他们好运，但我们

00:19:37.009 --> 00:19:45.590
想使用我们的运行时，这是一种

00:19:42.320 --> 00:19:47.330
另一个统一的举动

00:19:45.590 --> 00:19:49.519
特别是我们想降低成本

00:19:47.330 --> 00:19:51.240
关键Java技术的所有权

00:19:49.519 --> 00:19:54.600
从虚拟机开始，但也

00:19:51.240 --> 00:19:56.460
我要部分依赖巴拿马的其他事情

00:19:54.600 --> 00:19:58.860
本身，因为虚拟机的一部分将

00:19:56.460 --> 00:20:00.750
始终处于可见状态或对硬件敏感

00:19:58.860 --> 00:20:02.220
所以总是需要一些方法来获得

00:20:00.750 --> 00:20:05.580
无论其他虚拟机是什么

00:20:02.220 --> 00:20:08.460
用Java编码到本机部分

00:20:05.580 --> 00:20:10.289
硬件零件，但我们希望能够

00:20:08.460 --> 00:20:13.080
集成越来越多的Java 

00:20:10.289 --> 00:20:15.600
例如Grall进入热点，这取决于

00:20:13.080 --> 00:20:19.020
也部分涉及硬件级别的数据

00:20:15.600 --> 00:20:25.440
意思是瓦尔哈拉的结构

00:20:19.020 --> 00:20:27.360
固定数据和小值类型

00:20:25.440 --> 00:20:30.289
将减少我们所有的代码编写成本

00:20:27.360 --> 00:20:33.870
我们自己的语言而不是C ++ 

00:20:30.289 --> 00:20:36.809
目前整个JDK以及

00:20:33.870 --> 00:20:38.070
夸张，但99％的jdk已编码

00:20:36.809 --> 00:20:40.409
在Java中，这很好，这是事实

00:20:38.070 --> 00:20:42.690
 20年来该方法没有运行时间

00:20:40.409 --> 00:20:44.850
最初被涂上了汇编代码

00:20:42.690 --> 00:20:45.330
男孩，那是我的错误

00:20:44.850 --> 00:20:47.850
错误

00:20:45.330 --> 00:20:49.730
我不得不撤消它并用Java编写代码

00:20:47.850 --> 00:20:51.750
相反，它更易于管理

00:20:49.730 --> 00:20:55.590
我们中有些人过着磨牙的生活

00:20:51.750 --> 00:20:58.320
 äôt编译器的痛苦在于

00:20:55.590 --> 00:21:01.679
实际上是Gras的一个应用

00:20:58.320 --> 00:21:03.000
为Java静态生成代码

00:21:01.679 --> 00:21:06.210
你们中的许多人都知道时间的流逝

00:21:03.000 --> 00:21:10.260
 Java 9中的编译器哦，是的，很好，是的

00:21:06.210 --> 00:21:11.669
所以在那里很好地宣传了

00:21:10.260 --> 00:21:15.360
是我们正在做的其他实验

00:21:11.669 --> 00:21:16.590
使用高尔夫，实验室正在使用咆哮声

00:21:15.360 --> 00:21:19.260
他们一直这样做的准时化

00:21:16.590 --> 00:21:21.419
而且看起来还不错，还没有

00:21:19.260 --> 00:21:24.000
准备替换服务器编译器，但是

00:21:21.419 --> 00:21:30.450
它会在那里进行其他实验，例如

00:21:24.000 --> 00:21:32.549
底层VM Java和Java需要

00:21:30.450 --> 00:21:34.860
项目需要一个统一的项目

00:21:32.549 --> 00:21:36.929
开放的JDK生态系统，这是一个

00:21:34.860 --> 00:21:39.659
这是您项目的工作名称

00:21:36.929 --> 00:21:42.390
大都市没有正式呼吁

00:21:39.659 --> 00:21:45.330
项目，但我们还没有准备好将

00:21:42.390 --> 00:21:47.429
拼在一起，但我设想一个城市

00:21:45.330 --> 00:21:50.610
你明天可能会成为大都市

00:21:47.429 --> 00:21:52.350
认识弗里茨·朗（Fritz Lang）电影

00:21:50.610 --> 00:21:54.000
电影的那个主题

00:21:52.350 --> 00:21:55.260
也治愈了某种裂痕

00:21:54.000 --> 00:21:56.159
在心脏和头部之间或

00:21:55.260 --> 00:21:59.220
像那样的东西

00:21:56.159 --> 00:22:02.510
感伤的，但考虑到我们正在做

00:21:59.220 --> 00:22:05.020
治愈Java统一中的裂痕

00:22:02.510 --> 00:22:07.150
大都市未来的城市是

00:22:05.020 --> 00:22:09.790
一个不好的参考，这里的想法是

00:22:07.150 --> 00:22:12.490
 JDK 10的实验克隆

00:22:09.790 --> 00:22:15.130
主持äôt上的扩展程序

00:22:12.490 --> 00:22:17.140
特别是因为编译器和Grall 

00:22:15.130 --> 00:22:19.300
 äôt建立在鹅肝的基础上

00:22:17.140 --> 00:22:22.660
协同作用，但我们也想

00:22:19.300 --> 00:22:25.540
在受限模式下成长

00:22:22.660 --> 00:22:29.230
它将替代

00:22:25.540 --> 00:22:32.380
当前服务器的C ++代码

00:22:29.230 --> 00:22:33.910
为了做到这一点，我们需要

00:22:32.380 --> 00:22:35.980
可能定义类似系统的东西

00:22:33.910 --> 00:22:40.060
适用于静态的Java 

00:22:35.980 --> 00:22:41.590
编译和归约，以便我们成为

00:22:40.060 --> 00:22:43.780
能够做实验

00:22:41.590 --> 00:22:47.530
使用基板VM样式部署

00:22:43.780 --> 00:22:50.590
基板vm是另一个实验室

00:22:47.530 --> 00:22:52.840
你可以看到基督教的项目

00:22:50.590 --> 00:22:55.360
 Bimmer工作在上面，您可以看到

00:22:52.840 --> 00:22:58.750
最后的JVM语言峰会演讲

00:22:55.360 --> 00:23:00.700
夏天被称为一一

00:22:58.750 --> 00:23:02.110
 VM到一个编译器来全部统治

00:23:00.700 --> 00:23:06.820
像这样的东西之一

00:23:02.110 --> 00:23:10.720
各种各样的标题哦，在那儿保持差距

00:23:06.820 --> 00:23:14.800
我们除了更换

00:23:10.720 --> 00:23:16.570
 JIT与带有Java编码的东西

00:23:14.800 --> 00:23:19.420
是目前最大的虚拟机

00:23:16.570 --> 00:23:21.430
就像我不知道40％的VM或

00:23:19.420 --> 00:23:23.200
更复杂的是

00:23:21.430 --> 00:23:25.390
我宁愿有大量的C ++代码

00:23:23.200 --> 00:23:26.860
复杂的Java代码必须

00:23:25.390 --> 00:23:28.810
复杂，这是一个空的完整

00:23:26.860 --> 00:23:31.410
问题，但至少我想编码

00:23:28.810 --> 00:23:34.990
用高级语言，但是

00:23:31.410 --> 00:23:37.870
出牙练习或初学者手指

00:23:34.990 --> 00:23:39.670
我们想做一些较小的练习

00:23:37.870 --> 00:23:42.150
也用Java分割VM等

00:23:39.670 --> 00:23:45.040
有一个P的可能性列表

00:23:42.150 --> 00:23:47.110
 Java VM的离散部分

00:23:45.040 --> 00:23:50.110
可以从

00:23:47.110 --> 00:23:54.130
 C ++进入系统Java但最大的是

00:23:50.110 --> 00:23:56.440
当然咆哮是非常好的

00:23:54.130 --> 00:23:59.980
如我之前所说的代码生成器和

00:23:56.440 --> 00:24:01.540
它最终应该替换c2，但是它

00:23:59.980 --> 00:24:03.310
还应该替换c1 

00:24:01.540 --> 00:24:05.020
客户端编译器也应替换

00:24:03.310 --> 00:24:06.880
解释器生成器和各种存根

00:24:05.020 --> 00:24:08.320
换句话说，发电机为什么

00:24:06.880 --> 00:24:10.780
我们的多个代码生成器

00:24:08.320 --> 00:24:12.580
你知道的生态系统也许有一些

00:24:10.780 --> 00:24:14.020
外码生成码生成器

00:24:12.580 --> 00:24:15.310
在您使用的一侧

00:24:14.020 --> 00:24:17.020
专业的目的，但如果你是

00:24:15.310 --> 00:24:18.179
产生用于中间的东西

00:24:17.020 --> 00:24:20.460
 Java堆栈

00:24:18.179 --> 00:24:25.440
它应该是由我们产生的

00:24:20.460 --> 00:24:27.389
最终控制了我二十年

00:24:25.440 --> 00:24:30.960
现在in中可能有零个C代码

00:24:27.389 --> 00:24:32.970
 Java Runtime中的东西

00:24:30.960 --> 00:24:38.220
这是连接到C的边缘边缘代码

00:24:32.970 --> 00:24:40.169
 api的这将是明天的参考

00:24:38.220 --> 00:24:41.970
实施，它将是一个更好的

00:24:40.169 --> 00:24:44.249
今天参考实施

00:24:41.970 --> 00:24:46.230
今天是因为当你提到它

00:24:44.249 --> 00:24:48.240
参考，您将参考高级

00:24:46.230 --> 00:24:51.659
易于理解的Java代码

00:24:48.240 --> 00:24:53.659
然后是C代码和汇编代码

00:24:51.659 --> 00:24:55.619
我之前提到的另一个大想法

00:24:53.659 --> 00:24:58.980
线程之后是什么

00:24:55.619 --> 00:25:02.399
我认为线像是恐龙

00:24:58.980 --> 00:25:06.659
像恐龙一样，它们非常沉重， 

00:25:02.399 --> 00:25:09.480
大他们通常会慢慢移动

00:25:06.659 --> 00:25:11.070
有点愚蠢，或者说有些

00:25:09.480 --> 00:25:13.289
那里的情报，但是就像

00:25:11.070 --> 00:25:14.879
当前堆栈中的小脑

00:25:13.289 --> 00:25:17.159
框架就是所有的一切

00:25:14.879 --> 00:25:19.559
线程的其他部分只是堆栈

00:25:17.159 --> 00:25:21.210
框架和其他正在等待的元数据

00:25:19.559 --> 00:25:23.549
让您完成重要的工作

00:25:21.210 --> 00:25:25.259
你正在做的事情是

00:25:23.549 --> 00:25:28.080
即使您必须支付的费用

00:25:25.259 --> 00:25:29.759
所有有用的东西都在继续

00:25:28.080 --> 00:25:33.240
还有一些缓存行

00:25:29.759 --> 00:25:35.730
靠近栈顶，让我们

00:25:33.240 --> 00:25:37.379
把那些重要的部分保留下来

00:25:35.730 --> 00:25:38.970
让我们扔掉巨大的东西

00:25:37.379 --> 00:25:41.429
预分配堆栈帧

00:25:38.970 --> 00:25:43.529
如果不是的话，我们就扔掉

00:25:41.429 --> 00:25:46.559
不仅仅是重新分配堆栈

00:25:43.529 --> 00:25:48.809
细分也是预先分配的

00:25:46.559 --> 00:25:51.389
注册文件有几十千位

00:25:48.809 --> 00:25:54.179
现代处理器中的状态

00:25:51.389 --> 00:25:56.220
线程，如果您之间进行交换

00:25:54.179 --> 00:25:58.470
您必须加载和存储的线程

00:25:56.220 --> 00:26:00.210
该状态的副本会将其从您的

00:25:58.470 --> 00:26:02.700
处理器，然后获得新的

00:26:00.210 --> 00:26:04.740
快照到您的处理器中

00:26:02.700 --> 00:26:07.799
我们想要的恐龙心态

00:26:04.740 --> 00:26:11.159
能够拥有

00:26:07.799 --> 00:26:13.019
并发执行自行调用

00:26:11.159 --> 00:26:14.580
几乎互相称呼为

00:26:13.019 --> 00:26:15.419
当函数调用正确时

00:26:14.580 --> 00:26:18.330
一个老想法

00:26:15.419 --> 00:26:20.249
它被称为协程或光纤，但是在

00:26:18.330 --> 00:26:22.379
任何情况下我们都不想模拟

00:26:20.249 --> 00:26:24.470
有了巨大的线程，所以我们想要

00:26:22.379 --> 00:26:27.090
留下化石

00:26:24.470 --> 00:26:30.299
这取决于一些非常棘手的削减

00:26:27.090 --> 00:26:32.070
在JVM中，因为JVM已经

00:26:30.299 --> 00:26:34.409
以螺纹模型设计

00:26:32.070 --> 00:26:36.359
很难将其解耦并断奶

00:26:34.409 --> 00:26:38.279
线程模型，但我们有一些

00:26:36.359 --> 00:26:39.929
关于如何做到的很好的见解

00:26:38.279 --> 00:26:41.549
最近几年有在

00:26:39.929 --> 00:26:45.179
 jvm语言峰会上的方法

00:26:41.549 --> 00:26:46.529
这个图书馆的工作也需要

00:26:45.179 --> 00:26:48.299
所有可能阻塞的边缘

00:26:46.529 --> 00:26:50.850
你以为你有一个线程

00:26:48.299 --> 00:26:52.649
可以永远徘徊在你所知道的

00:26:50.850 --> 00:26:54.989
在焦油坑中直到完成

00:26:52.649 --> 00:26:56.489
阻止然后醒来拉

00:26:54.989 --> 00:26:58.289
本身脱离了焦油和木材

00:26:56.489 --> 00:27:01.169
并做其他不好的事情

00:26:58.289 --> 00:27:03.659
相反，您希望阻止的API说

00:27:01.169 --> 00:27:05.700
好吧，我被挡住了

00:27:03.659 --> 00:27:07.769
堆上的重要数据

00:27:05.700 --> 00:27:09.359
去做别的意思

00:27:07.769 --> 00:27:16.919
这很有用

00:27:09.359 --> 00:27:18.859
没有笨拙的恐龙仍会

00:27:16.919 --> 00:27:21.749
需要类似线程的东西，但是

00:27:18.859 --> 00:27:24.779
基本上一个威胁将运行一个线程

00:27:21.749 --> 00:27:26.519
您知道的任何数量的纤维顺序

00:27:24.779 --> 00:27:29.009
多种方式，这就是您的方式

00:27:26.519 --> 00:27:31.889
获得巨大的并发成功

00:27:29.009 --> 00:27:33.869
这就是像gogo那样的纤维

00:27:31.889 --> 00:27:35.460
纤维被称为go例程和Co 

00:27:33.869 --> 00:27:39.330
例行程序，但是基本上

00:27:35.460 --> 00:27:41.129
轻量级的深度计算

00:27:39.330 --> 00:27:42.690
从繁重的线程和

00:27:41.129 --> 00:27:44.389
线成为草稿动物， 

00:27:42.690 --> 00:27:47.009
纤维成为智能小

00:27:44.389 --> 00:27:48.509
思维恐龙猛禽或人类

00:27:47.009 --> 00:27:50.729
在上面写的存在

00:27:48.509 --> 00:27:55.259
恐龙，我可以跳下

00:27:50.729 --> 00:27:57.149
当他们陷入泥巴中时， 

00:27:55.259 --> 00:27:58.590
安装和拆卸是我的方式

00:27:57.149 --> 00:28:01.169
喜欢考虑纤维，所以我们

00:27:58.590 --> 00:28:03.419
做更多的当前实验

00:28:01.169 --> 00:28:05.970
在线程上智能编写之一

00:28:03.419 --> 00:28:08.879
他们最好走栈，有一个

00:28:05.970 --> 00:28:10.970
栈漫步API 

00:28:08.879 --> 00:28:13.679
堆栈并能够看到它的内部

00:28:10.970 --> 00:28:15.479
我们希望最终能够

00:28:13.679 --> 00:28:17.279
只看堆栈也要更换

00:28:15.479 --> 00:28:18.779
它说嘿，我不喜欢你那堆

00:28:17.279 --> 00:28:20.909
跑步我有一个更好的主意

00:28:18.779 --> 00:28:23.039
运行这个堆栈，我已经保存了

00:28:20.909 --> 00:28:25.320
无论我关心什么

00:28:23.039 --> 00:28:26.700
以前的堆栈相信我可以回到

00:28:25.320 --> 00:28:30.590
现在，我要您查看

00:28:26.700 --> 00:28:33.210
恐龙基本上更易于操纵

00:28:30.590 --> 00:28:34.529
再次需要大量的图书馆工作

00:28:33.210 --> 00:28:35.970
并且有相互作用

00:28:34.529 --> 00:28:39.049
同步很棒

00:28:35.970 --> 00:28:39.049
研究项目

00:28:42.220 --> 00:28:48.070
我做一次检查时请原谅我

00:28:44.360 --> 00:28:52.460
我看不到时钟好吗

00:28:48.070 --> 00:28:53.929
在任何情况下，JVM都有新的技巧

00:28:52.460 --> 00:28:56.120
它需要学习才能做到这一点

00:28:53.929 --> 00:28:58.820
需要能够发挥有用的作用

00:28:56.120 --> 00:29:00.830
计算并放下

00:28:58.820 --> 00:29:02.929
卸下到堆上，这意味着

00:29:00.830 --> 00:29:04.970
正确的大小和正确的输入

00:29:02.929 --> 00:29:07.070
现在就堆栈框架信息

00:29:04.970 --> 00:29:08.809
在堆栈框架内真的很好

00:29:07.070 --> 00:29:10.760
但是我们没有办法移动它

00:29:08.809 --> 00:29:12.440
进入堆下马然后移动

00:29:10.760 --> 00:29:15.230
当您想将其执行到

00:29:12.440 --> 00:29:16.850
堆栈重新安装，但那是

00:29:15.230 --> 00:29:19.790
技巧，我们知道如何知道

00:29:16.850 --> 00:29:21.049
创造另一个大想法是价值类型

00:29:19.790 --> 00:29:23.240
每个人都听说过这是

00:29:21.049 --> 00:29:25.490
另一个治愈裂谷类

00:29:23.240 --> 00:29:27.890
他们之间的原始选择

00:29:25.490 --> 00:29:31.490
我将如何在列表之间进行选择

00:29:27.890 --> 00:29:33.049
还有一个数组事件哦，没人好

00:29:31.490 --> 00:29:34.040
有时对方擅长对方

00:29:33.049 --> 00:29:36.890
他们每个人都有自己的劣势

00:29:34.040 --> 00:29:38.750
让他们看起来更一样

00:29:36.890 --> 00:29:40.850
想法是区分传统类型

00:29:38.750 --> 00:29:42.860
之所以称为L型

00:29:40.850 --> 00:29:45.260
新提示的描述符中的字母

00:29:42.860 --> 00:29:47.270
带有提示字母的类型

00:29:45.260 --> 00:29:48.590
描述符的想法是L类型

00:29:47.270 --> 00:29:50.270
和Q类型非常相似

00:29:48.590 --> 00:29:52.100
都基于类，但仅L类型

00:29:50.270 --> 00:29:55.370
是对象，它们是q类型，是纯净的

00:29:52.100 --> 00:29:58.100
值，所以这可以让我们说int 

00:29:55.370 --> 00:30:00.380
不管是哪种方式，它们都是整数

00:29:58.100 --> 00:30:02.120
同样你可以写你的代码

00:30:00.380 --> 00:30:05.270
可以在int和integer之间重构

00:30:02.120 --> 00:30:06.919
价值主张更容易

00:30:05.270 --> 00:30:09.200
对于Q类型来说，代码就像一个类

00:30:06.919 --> 00:30:10.929
它像int一样工作，不是对象

00:30:09.200 --> 00:30:13.610
这是一个价值，但你全力以赴

00:30:10.929 --> 00:30:16.760
舒适，所以您可以封装和

00:30:13.610 --> 00:30:18.650
方法等等取决于Val 

00:30:16.760 --> 00:30:20.660
我如何依靠很多事情

00:30:18.650 --> 00:30:22.549
得到正确的一件事是我们需要

00:30:20.660 --> 00:30:24.410
所谓的参数多态

00:30:22.549 --> 00:30:26.960
需要能够拥有int和

00:30:24.410 --> 00:30:30.140
终于可以了吗？ 

00:30:26.960 --> 00:30:32.450
好的权利基本上可以归结为

00:30:30.140 --> 00:30:34.070
到现在，我们知道如何做清单

00:30:32.450 --> 00:30:35.840
任何L型的，因为L型真的

00:30:34.070 --> 00:30:37.520
两者看起来都一样

00:30:35.840 --> 00:30:39.590
类型看起来不同他们有不同

00:30:37.520 --> 00:30:41.480
尺寸和布局，因此我们需要能够

00:30:39.590 --> 00:30:43.070
做列表和数组的技巧

00:30:41.480 --> 00:30:47.179
容器的其他东西

00:30:43.070 --> 00:30:48.740
这些可变的价值观，但

00:30:47.179 --> 00:30:51.350
它可以让您获取平面数据等

00:30:48.740 --> 00:30:53.170
有效使用内存以使以下其中一项有效

00:30:51.350 --> 00:30:55.240
金字塔的技术要求

00:30:53.170 --> 00:30:57.670
多态性是类的行为

00:30:55.240 --> 00:30:59.770
有点像C ++模板， 

00:30:57.670 --> 00:31:02.230
每个模板一旦您给它模板

00:30:59.770 --> 00:31:04.720
论点变成另一个

00:31:02.230 --> 00:31:06.610
类，但该类的一个物种等等

00:31:04.720 --> 00:31:08.770
你有一个通用的类，然后

00:31:06.610 --> 00:31:12.610
你有很多种类，每种类型一个

00:31:08.770 --> 00:31:15.550
再像纤维一样争​​论

00:31:12.610 --> 00:31:17.500
需要对JVM进行深入研究

00:31:15.550 --> 00:31:19.690
会说这是我们最大的大项目

00:31:17.500 --> 00:31:21.790
希望这些是最后的类型

00:31:19.690 --> 00:31:24.070
我们将永远需要或最后的方式

00:31:21.790 --> 00:31:26.770
使类型对象类型非常适合

00:31:24.070 --> 00:31:29.830
模拟这些要少得多

00:31:26.770 --> 00:31:34.210
间接费用'fl更直接的非模拟

00:31:29.830 --> 00:31:37.300
价值的影响将是

00:31:34.210 --> 00:31:38.830
相当于影响其他一些主要

00:31:37.300 --> 00:31:41.410
语言特性，例如泛型和

00:31:38.830 --> 00:31:45.640
 lambdas，但重要的是

00:31:41.410 --> 00:31:48.760
像一个类的代码，因此还有一些注意事项

00:31:45.640 --> 00:31:50.740
关于参数多态性

00:31:48.760 --> 00:31:53.200
它真正的作用是让你这样说

00:31:50.740 --> 00:31:56.050
代码，请参阅此代码，此代码适用

00:31:53.200 --> 00:31:58.780
所有值不只是引用

00:31:56.050 --> 00:32:01.240
从某个接口继承但int 

00:31:58.780 --> 00:32:03.190
以及双打和复数

00:32:01.240 --> 00:32:04.960
还没发明四元数

00:32:03.190 --> 00:32:08.050
我还没有发明这个

00:32:04.960 --> 00:32:09.670
算法适用于所有这些

00:32:08.050 --> 00:32:13.480
很好，我们已经在

00:32:09.670 --> 00:32:15.640
带有模板的C ++非常强大

00:32:13.480 --> 00:32:16.990
也许会在

00:32:15.640 --> 00:32:18.400
 Java，但您将能够构建所有

00:32:16.990 --> 00:32:23.470
关于它的有趣的事情

00:32:18.400 --> 00:32:25.030
同时像我的游标

00:32:23.470 --> 00:32:26.740
前面提到的成堆数据

00:32:25.030 --> 00:32:30.460
那些不应该的结构

00:32:26.740 --> 00:32:32.800
是对象，应该是值，类型

00:32:30.460 --> 00:32:35.170
变量是参数化中的关键角色

00:32:32.800 --> 00:32:36.700
多态性类型变量说我是

00:32:35.170 --> 00:32:38.320
类型的占位符，但我不知道

00:32:36.700 --> 00:32:40.990
我还不知道我有多大

00:32:38.320 --> 00:32:43.120
我是我，我对自己知之甚少

00:32:40.990 --> 00:32:45.790
但是你最好准备给我编码

00:32:43.120 --> 00:32:47.610
用户要求的任何类型

00:32:45.790 --> 00:32:50.410
就像模板一样

00:32:47.610 --> 00:32:51.910
这很难做到，因为

00:32:50.410 --> 00:32:54.460
原语看起来完全不同于

00:32:51.910 --> 00:32:58.060
从参考文献中得知，我们已经

00:32:54.460 --> 00:32:59.890
为此我们有一些方法

00:32:58.060 --> 00:33:01.660
就像我们在我想

00:32:59.890 --> 00:33:04.510
参数化原型

00:33:01.660 --> 00:33:06.050
多态原语看起来不像

00:33:04.510 --> 00:33:09.350
他们没有方法的类

00:33:06.050 --> 00:33:11.960
所以他们没有超级类型

00:33:09.350 --> 00:33:14.270
今天看起来很好的解决方案，我

00:33:11.960 --> 00:33:15.950
认为这可能接近我们所在的地方

00:33:14.270 --> 00:33:17.990
要建立一个有效的映射

00:33:15.950 --> 00:33:19.070
将原语转化为值类型

00:33:17.990 --> 00:33:21.740
因为那是他们的本性

00:33:19.070 --> 00:33:23.600
有第一个值输入队列

00:33:21.740 --> 00:33:25.160
类型，然后在那时

00:33:23.600 --> 00:33:27.260
您的通用代码必须在队列上工作

00:33:25.160 --> 00:33:29.360
类型和el类型，所以更多

00:33:27.260 --> 00:33:30.710
一个或非命题而不是我的命题

00:33:29.360 --> 00:33:31.760
天哪，这是怎么回事，我不知道

00:33:30.710 --> 00:33:34.520
我在想什么和类型

00:33:31.760 --> 00:33:36.650
变量，然后最后你说

00:33:34.520 --> 00:33:38.510
好吧，如果我想能够与

00:33:36.650 --> 00:33:40.730
可能是/或者是我的类型

00:33:38.510 --> 00:33:43.010
您再输入一个字母

00:33:40.730 --> 00:33:44.480
 G联盟的意思是不相交的联盟

00:33:43.010 --> 00:33:45.710
和L的数量，到那时

00:33:44.480 --> 00:33:48.620
治愈了裂痕你有没有

00:33:45.710 --> 00:33:50.540
 JVM中可以正常工作的类型系统可以

00:33:48.620 --> 00:33:54.410
提到任何你可以扔给它的东西

00:33:50.540 --> 00:33:55.700
从Java看来我们可能会做到

00:33:54.410 --> 00:33:57.350
如果我们只是坚持下去

00:33:55.700 --> 00:33:59.840
原始，我们没有，我们没有

00:33:57.350 --> 00:34:01.640
要添加复数和256位

00:33:59.840 --> 00:34:03.620
数字，但我们想要它，我们想要那些

00:34:01.640 --> 00:34:05.030
原语编码像一个类，所以我们

00:34:03.620 --> 00:34:07.910
有一个全新的队列

00:34:05.030 --> 00:34:09.950
类型，然后与l类型组合

00:34:07.910 --> 00:34:14.090
为您提供各种视图类型

00:34:09.950 --> 00:34:16.130
在顶部，这意味着将有

00:34:14.090 --> 00:34:18.050
更少的类型相同的类型

00:34:16.130 --> 00:34:19.850
代码将适用于您不会使用的所有值

00:34:18.050 --> 00:34:22.250
必须说好我的编码整数或

00:34:19.850 --> 00:34:25.280
我今天的编码，因为您对它们进行编码

00:34:22.250 --> 00:34:26.899
隐式非常不同

00:34:25.280 --> 00:34:30.169
转换有帮助，但您仍然可以对其进行编码

00:34:26.899 --> 00:34:34.070
完全不同，因此我们将

00:34:30.169 --> 00:34:36.560
模板化的类，然后

00:34:34.070 --> 00:34:39.110
导致如何编码对象

00:34:36.560 --> 00:34:43.220
像原语一样你可以做运算符

00:34:39.110 --> 00:34:44.960
超载，我不知道那是一个

00:34:43.220 --> 00:34:46.730
我把它放进去是因为人们问

00:34:44.960 --> 00:34:47.899
为此，但我不确定我们要如何

00:34:46.730 --> 00:34:50.179
之所以这样做，是因为操作员

00:34:47.899 --> 00:34:56.990
超载是真正的所谓的

00:34:50.179 --> 00:34:59.540
道德风险会吸引不良行为者，因此

00:34:56.990 --> 00:35:01.430
无论如何要再说一遍

00:34:59.540 --> 00:35:03.850
模板类现在看起来像

00:35:01.430 --> 00:35:06.440
模板类看起来像一个

00:35:03.850 --> 00:35:08.660
常数改变代码的东西

00:35:06.440 --> 00:35:10.640
不改变代码中的名称不要

00:35:08.660 --> 00:35:12.500
变化，但常数变化，所以

00:35:10.640 --> 00:35:14.030
模板类有孔，它是

00:35:12.500 --> 00:35:15.740
您填入的固定池

00:35:14.030 --> 00:35:17.270
做一个物种，所以这将继续

00:35:15.740 --> 00:35:19.460
在这将是双打

00:35:17.270 --> 00:35:21.560
将是复数

00:35:19.460 --> 00:35:23.450
这需要很多深入的思考

00:35:21.560 --> 00:35:25.210
什么是恒定池，但最难

00:35:23.450 --> 00:35:28.340
问题，我说这是关于

00:35:25.210 --> 00:35:31.520
常量池，而不是定制

00:35:28.340 --> 00:35:33.590
 C ++模板中的代码可扩展

00:35:31.520 --> 00:35:36.020
代码正确，但我不想这样做

00:35:33.590 --> 00:35:38.870
因为我们想要用Java做的是

00:35:36.020 --> 00:35:40.400
因为我们是这个的较晚采用者

00:35:38.870 --> 00:35:42.830
我们可以做出不同的技术

00:35:40.400 --> 00:35:44.300
选择和聪明，我想避免

00:35:42.830 --> 00:35:46.790
代码分割我想要一个副本

00:35:44.300 --> 00:35:50.120
适用于所有版本的代码

00:35:46.790 --> 00:35:52.010
模板，直到您批准需要

00:35:50.120 --> 00:35:55.280
针对特定类型对其进行优化

00:35:52.010 --> 00:35:57.560
做一个热点概念吧，然后

00:35:55.280 --> 00:35:59.030
一旦你在某个特定的热点

00:35:57.560 --> 00:36:00.890
然后使用特定模板中的种类

00:35:59.030 --> 00:36:02.450
你做通常的内联事情，你

00:36:00.890 --> 00:36:07.070
获取特定代码的最佳代码

00:36:02.450 --> 00:36:08.330
键入小我们的想法时间检查可以

00:36:07.070 --> 00:36:12.920
有人告诉我我有多少时间

00:36:08.330 --> 00:36:15.490
左我15岁，好吧，我会

00:36:12.920 --> 00:36:18.740
加快速度

00:36:15.490 --> 00:36:20.810
较小的想法这些是

00:36:18.740 --> 00:36:22.730
有点容易缠头

00:36:20.810 --> 00:36:25.130
我已经提到过的堆栈自省

00:36:22.730 --> 00:36:27.470
长度多态性是

00:36:25.130 --> 00:36:29.240
对象可能是一个类的对象

00:36:27.470 --> 00:36:31.070
长度可能与

00:36:29.240 --> 00:36:34.130
相同类数组的对象是

00:36:31.070 --> 00:36:36.620
像这样，我们将其概括为引导程序

00:36:34.130 --> 00:36:39.080
方法无处不在这是我们

00:36:36.620 --> 00:36:41.870
在上一小时中谈到

00:36:39.080 --> 00:36:44.210
调用游戏和不变性

00:36:41.870 --> 00:36:45.620
知道那是去除不必要的东西

00:36:44.210 --> 00:36:49.400
数据的自由度

00:36:45.620 --> 00:36:50.870
结构我没有时间去研究

00:36:49.400 --> 00:36:52.640
所有这些，所以我只是要过去

00:36:50.870 --> 00:36:53.900
真的很快，但是我想说

00:36:52.640 --> 00:36:54.650
这些东西都融合在一起

00:36:53.900 --> 00:36:56.720
令人惊讶的方式

00:36:54.650 --> 00:36:58.640
每个人都可以理解

00:36:56.720 --> 00:36:59.960
它本身的权利，但是当您建立

00:36:58.640 --> 00:37:01.780
他们在一起，您会得到一个

00:36:59.960 --> 00:37:04.370
超过其总和

00:37:01.780 --> 00:37:07.310
所以我们希望能够实时走动

00:37:04.370 --> 00:37:08.960
框架即使您有特权也能看到

00:37:07.310 --> 00:37:10.580
查看存储在其中的临时值

00:37:08.960 --> 00:37:12.740
堆栈框架直到我们

00:37:10.580 --> 00:37:15.140
能够剥离我们的筹码

00:37:12.740 --> 00:37:17.510
堆栈中的帧记录了

00:37:15.140 --> 00:37:19.640
堆栈正在扔掉它，然后

00:37:17.510 --> 00:37:21.650
稍后重新构造并继续

00:37:19.640 --> 00:37:23.450
从那开始做

00:37:21.650 --> 00:37:28.580
指向前进声音听起来很有用

00:37:23.450 --> 00:37:31.890
像检查点还原这样的操作，所以我们

00:37:28.580 --> 00:37:33.750
现在我们有充分的观察

00:37:31.890 --> 00:37:39.420
最终我们希望能够

00:37:33.750 --> 00:37:41.640
全部编辑各种应用程序

00:37:39.420 --> 00:37:44.279
这将在网络上，所以你可以看看

00:37:41.640 --> 00:37:46.650
后来它的长度多态性融合了

00:37:44.279 --> 00:37:48.630
数组，如果有，则如何

00:37:46.650 --> 00:37:51.299
知道这个列表是一个不变的列表

00:37:48.630 --> 00:37:53.339
总是只有四个要素

00:37:51.299 --> 00:37:55.650
在其中不应该只是一个对象

00:37:53.339 --> 00:37:58.019
标题，然后是四个字段

00:37:55.650 --> 00:37:59.549
 JVM应该无法表达这一点

00:37:58.019 --> 00:38:01.710
很好，但是我们会得到

00:37:59.549 --> 00:38:04.650
还有弦为什么弦有

00:38:01.710 --> 00:38:06.329
有一个很好的数组的子对象

00:38:04.650 --> 00:38:07.769
这只是历史，这是它的方式

00:38:06.329 --> 00:38:09.480
我们一直在建造东西的方式，但是

00:38:07.769 --> 00:38:11.099
不必像一个字符串

00:38:09.480 --> 00:38:13.799
毕竟它有固定的长度

00:38:11.099 --> 00:38:15.599
应该是字符串标题，然后

00:38:13.799 --> 00:38:17.519
字节或之后的护理就在那里

00:38:15.599 --> 00:38:21.299
对象尾部的F，但这

00:38:17.519 --> 00:38:22.440
需要长度多态性，所以我们将

00:38:21.299 --> 00:38:24.329
到达那里，我认为这是

00:38:22.440 --> 00:38:27.779
我们需要能够做到

00:38:24.329 --> 00:38:29.609
技术要求，但我们会

00:38:27.779 --> 00:38:31.380
我们将特别到达那里

00:38:29.609 --> 00:38:35.099
能够与工厂合作

00:38:31.380 --> 00:38:37.710
而不是新调用

00:38:35.099 --> 00:38:39.000
有一个技术问题

00:38:37.710 --> 00:38:41.039
需要在幕后解决

00:38:39.000 --> 00:38:42.599
 Java程序员什至看不到

00:38:41.039 --> 00:38:44.009
如果我们修复它，他们甚至不会注意到

00:38:42.599 --> 00:38:47.940
除了我们将能够更好地建立

00:38:44.009 --> 00:38:49.440
对象无处不在促进我们的方法

00:38:47.940 --> 00:38:51.779
我们再次详细讨论了这一点

00:38:49.440 --> 00:38:53.400
最后一个小时，但想法是加倍

00:38:51.779 --> 00:38:55.559
现在使用bootstrap方法

00:38:53.400 --> 00:38:57.450
调用动态指令链接本身

00:38:55.559 --> 00:38:59.279
通过吸引用户编码的引导程序

00:38:57.450 --> 00:39:01.079
任意静态常数的方法

00:38:59.279 --> 00:39:03.180
这非常强大，我们正在将其用于

00:39:01.079 --> 00:39:04.859
我们将要采用的多种不同方式

00:39:03.180 --> 00:39:07.559
将来以更多方式使用它，但是

00:39:04.859 --> 00:39:10.380
让我们将引导方法放在lvc下

00:39:07.559 --> 00:39:12.539
另一个地方的恒定池

00:39:10.380 --> 00:39:14.369
您从中获得独特的价值

00:39:12.539 --> 00:39:17.309
能够吸引用户代码

00:39:14.369 --> 00:39:20.369
链接一个常量，如果您

00:39:17.309 --> 00:39:22.380
在特定位置上调用访问点

00:39:20.369 --> 00:39:23.940
一种类，也许没有代码

00:39:22.380 --> 00:39:25.710
在该访问点后面直到您触摸

00:39:23.940 --> 00:39:27.839
它，然后运行一个引导方法

00:39:25.710 --> 00:39:29.640
及时填写代码，然后

00:39:27.839 --> 00:39:31.769
该广告中包含代码

00:39:29.640 --> 00:39:33.390
要运行的对象可能是整个方法或

00:39:31.769 --> 00:39:35.759
甚至可以创建整个类

00:39:33.390 --> 00:39:40.859
第一次您通过吸引来触摸它

00:39:35.759 --> 00:39:42.480
我们想要的引导方法

00:39:40.859 --> 00:39:44.420
有一种叫做常数的东西

00:39:42.480 --> 00:39:47.630
动态的，有一个

00:39:44.420 --> 00:39:48.950
有一个jbs条目和一个

00:39:47.630 --> 00:39:51.200
原型即将成为

00:39:48.950 --> 00:39:53.809
在开放的JDK中发布了

00:39:51.200 --> 00:39:58.099
常数是动态的，我们有常数

00:39:53.809 --> 00:40:00.980
知道如何创建，但让我们

00:39:58.099 --> 00:40:08.089
使常量可以生成数组

00:40:00.980 --> 00:40:09.470
列出Maps模板DSL ast，以便

00:40:08.089 --> 00:40:12.650
为所有这些做常量

00:40:09.470 --> 00:40:14.269
需要添加50,000个新代码点

00:40:12.650 --> 00:40:15.920
常量池编码机制或

00:40:14.269 --> 00:40:17.239
一个新的代码点说

00:40:15.920 --> 00:40:18.890
引导程序方法来填写

00:40:17.239 --> 00:40:23.569
常数，您认为我们要去哪

00:40:18.890 --> 00:40:25.579
做对是有要求

00:40:23.569 --> 00:40:28.190
在此我不会去做一个设计

00:40:25.579 --> 00:40:30.710
现在是原型

00:40:28.190 --> 00:40:32.779
最好看看最后几个小时的谈话

00:40:30.710 --> 00:40:37.519
或将要使用的代码

00:40:32.779 --> 00:40:40.819
即将发布，这可以用于

00:40:37.519 --> 00:40:42.859
示例组成数组而不是通过

00:40:40.819 --> 00:40:46.130
命令式Java代码（如果您曾经看过） 

00:40:42.859 --> 00:40:48.650
在初始化大静态

00:40:46.130 --> 00:40:51.079
您的班级文件中的数组

00:40:48.650 --> 00:40:52.460
大概丢了一点，但是

00:40:51.079 --> 00:40:54.859
有更好的方法

00:40:52.460 --> 00:40:59.690
创建数组比你知道的大

00:40:54.859 --> 00:41:01.670
临时字节码的数量

00:40:59.690 --> 00:41:03.499
与项目有关的样板

00:41:01.670 --> 00:41:05.630
琥珀色是语言级别的项目

00:41:03.499 --> 00:41:06.529
所以在VM中我们不在乎

00:41:05.630 --> 00:41:08.059
他们在那里做什么

00:41:06.529 --> 00:41:09.589
编译器，除非它们下雨了

00:41:08.059 --> 00:41:11.420
关于我们的那种错误的代码，那一点

00:41:09.589 --> 00:41:13.400
我们转身就什么提供建议

00:41:11.420 --> 00:41:16.809
在这种情况下要处理的代码类型

00:41:13.400 --> 00:41:20.450
我们想要拥有的就是拥有

00:41:16.809 --> 00:41:22.309
刻板印象方法

00:41:20.450 --> 00:41:26.299
声明式地使用引导程序而不是

00:41:22.309 --> 00:41:27.499
比您所知道的长行字节码

00:41:26.299 --> 00:41:29.509
因为字节码通常非常

00:41:27.499 --> 00:41:32.900
无聊，只会增加应用程序的体积

00:41:29.509 --> 00:41:34.609
启动，所以样板方法包括

00:41:32.900 --> 00:41:36.710
像构造函数那样对字符串进行哈希处理的事情

00:41:34.609 --> 00:41:38.089
代码等于还有桥接方法

00:41:36.710 --> 00:41:40.819
我们知道已经存在很长时间了

00:41:38.089 --> 00:41:43.489
时间和其他方法构建者

00:41:40.819 --> 00:41:46.039
巴拿马活页夹也建立了引导程序

00:41:43.489 --> 00:41:47.630
巴拿马从中获取元数据的方法

00:41:46.039 --> 00:41:50.210
从头文件中抓取的

00:41:47.630 --> 00:41:52.489
并将其绑定为直接方法

00:41:50.210 --> 00:41:54.859
的句柄和方法

00:41:52.489 --> 00:41:57.440
本机代码和数据也是

00:41:54.859 --> 00:41:59.329
刻板印象的活动和

00:41:57.440 --> 00:42:01.540
换句话说，应该懒惰地做

00:41:59.329 --> 00:42:04.069
您，如果您使用活页夹创建您

00:42:01.540 --> 00:42:06.319
绑定到头文件

00:42:04.069 --> 00:42:08.089
您应该只获得实际的代码

00:42:06.319 --> 00:42:10.270
您触摸的入口点，这可以

00:42:08.089 --> 00:42:16.250
通过减少样板来完成

00:42:10.270 --> 00:42:17.780
技术和方法，所以您知道

00:42:16.250 --> 00:42:19.700
琥珀色，您也许可以写一个

00:42:17.780 --> 00:42:22.190
一行真的很有趣，但是

00:42:19.700 --> 00:42:24.560
如果您的班级文件是10 KB 

00:42:22.190 --> 00:42:27.319
然后出事了，所以这

00:42:24.560 --> 00:42:28.849
解决方案是生成

00:42:27.319 --> 00:42:30.740
引导东西，然后

00:42:28.849 --> 00:42:32.390
将那些细节整理成字节码

00:42:30.740 --> 00:42:35.329
只有当您使用它们时， 

00:42:32.390 --> 00:42:37.819
很好，也许有些人

00:42:35.329 --> 00:42:38.810
人们不写等于哈希码

00:42:37.819 --> 00:42:40.280
字符串不仅是因为

00:42:38.810 --> 00:42:41.569
不便，还因为它增加了

00:42:40.280 --> 00:42:43.250
两者都放在罐子里，他们知道他们是

00:42:41.569 --> 00:42:44.390
不会正确使用它，但是如果

00:42:43.250 --> 00:42:46.250
您可以拥有该功能

00:42:44.390 --> 00:42:47.660
他们已经准备好使用，但您只需支付

00:42:46.250 --> 00:42:52.849
如果您使用它，那就太好了

00:42:47.660 --> 00:42:57.530
现货细节，我不打算讨论

00:42:52.849 --> 00:43:00.440
没有详细说明其他应用程序

00:42:57.530 --> 00:43:02.540
现在很有趣的源代码

00:43:00.440 --> 00:43:04.430
琥珀项目正在探索源代码

00:43:02.540 --> 00:43:06.050
语法用于执行这些巧妙的VM技巧

00:43:04.430 --> 00:43:08.180
所以不仅是字节码微调器

00:43:06.050 --> 00:43:10.670
最终是给Java程序员的，所以

00:43:08.180 --> 00:43:13.790
恒定的动态常数甚至

00:43:10.670 --> 00:43:15.800
调用动态指令将在

00:43:13.790 --> 00:43:19.569
在不久的将来可能可用

00:43:15.800 --> 00:43:26.180
您作为Java程序员进行编码

00:43:19.569 --> 00:43:28.040
仅使用这种力量就可以了

00:43:26.180 --> 00:43:30.349
基本思想是能够拥有

00:43:28.040 --> 00:43:33.140
 Java中的常量表达式

00:43:30.349 --> 00:43:36.380
 C ++中的基本思想有一个相关的思想

00:43:33.140 --> 00:43:39.140
称为Const专家函数

00:43:36.380 --> 00:43:41.619
设计用来写

00:43:39.140 --> 00:43:44.780
甚至产生常数的函数

00:43:41.619 --> 00:43:47.839
非常强大的缺点

00:43:44.780 --> 00:43:49.819
引导方法无处不在

00:43:47.839 --> 00:43:51.829
如果您正在扩展一切

00:43:49.819 --> 00:43:53.329
动态地你是一个OT编译器

00:43:51.829 --> 00:43:54.589
真的很困惑，因为它不知道

00:43:53.329 --> 00:43:56.480
将会动态发生什么

00:43:54.589 --> 00:43:59.359
运行时，所以我们必须教它

00:43:56.480 --> 00:44:00.770
必须基本上离开教乔T 

00:43:59.359 --> 00:44:03.130
与引导程序一起工作

00:44:00.770 --> 00:44:03.130
方法

00:44:04.420 --> 00:44:09.080
不变性，我要做一个

00:44:06.800 --> 00:44:11.540
超快速的商业性

00:44:09.080 --> 00:44:12.560
有较少的程序状态可以推理

00:44:11.540 --> 00:44:15.500
关于何时拥有不可变数据

00:44:12.560 --> 00:44:17.810
 Java一直具有的结构

00:44:15.500 --> 00:44:20.960
默认情况下的可变性很糟糕

00:44:17.810 --> 00:44:22.970
可变数组中没有的数组

00:44:20.960 --> 00:44:24.200
你只能有可变数组

00:44:22.970 --> 00:44:25.520
只有具有种族的数组

00:44:24.200 --> 00:44:28.700
他们唯一的条件就是我们

00:44:25.520 --> 00:44:31.880
给你，我们将解决这个问题

00:44:28.700 --> 00:44:33.440
现在也为了应付一些

00:44:31.880 --> 00:44:36.770
程序中的许多状态

00:44:33.440 --> 00:44:38.330
防御复制问题解决了吗

00:44:36.770 --> 00:44:41.650
您将州的数量增加了一倍

00:44:38.330 --> 00:44:41.650
在你的程序中很好

00:44:41.840 --> 00:44:47.330
语义上的简化也使未来

00:44:44.480 --> 00:44:48.950
时间编译器和喷气机来预测

00:44:47.330 --> 00:44:50.990
推进程序将要执行的操作

00:44:48.950 --> 00:44:53.960
更准确地进行优化

00:44:50.990 --> 00:44:56.420
如果您的数据有状态漏洞

00:44:53.960 --> 00:44:58.400
数组中的结构只是

00:44:56.420 --> 00:44:59.600
制作时要非常谨慎

00:44:58.400 --> 00:45:01.520
关于将会发生什么的假设

00:44:59.600 --> 00:45:04.180
那些未来的漏洞

00:45:01.520 --> 00:45:04.180
性能

00:45:05.060 --> 00:45:10.520
想象一下Java是否已经定型了

00:45:08.720 --> 00:45:12.140
默认情况下，有一个非最终的

00:45:10.520 --> 00:45:14.210
关键字，我认为我们会做得更好

00:45:12.140 --> 00:45:15.950
声明，但您知道我们不知道如何

00:45:14.210 --> 00:45:18.820
二十年前建造这样的东西，我们现在做

00:45:15.950 --> 00:45:18.820
所以没有任何借口

00:45:19.250 --> 00:45:24.100
冻结数组是的，请冻结

00:45:21.980 --> 00:45:26.690
数组就像尾巴学院，这是一个

00:45:24.100 --> 00:45:28.700
相当小的众所周知

00:45:26.690 --> 00:45:30.500
接触过多的问题

00:45:28.700 --> 00:45:32.390
堆栈的其他部分，因此

00:45:30.500 --> 00:45:33.950
要做的事情很昂贵，而且一直存在

00:45:32.390 --> 00:45:36.680
被更高优先级的资金取代

00:45:33.950 --> 00:45:38.150
物品，这就是我为什么不这样做

00:45:36.680 --> 00:45:42.650
正确执行尾调用或冻结的数组

00:45:38.150 --> 00:45:44.840
现在，真正适用于最终领域的箱子

00:45:42.650 --> 00:45:47.000
真的应该是决赛，他们不是新闻

00:45:44.840 --> 00:45:51.970
闪光灯，您可以将访问权限设置为

00:45:47.000 --> 00:45:54.680
更改它们，我们需要真正冻结的对象

00:45:51.970 --> 00:45:56.540
我之间有联系

00:45:54.680 --> 00:45:59.780
前面提到的不变性

00:45:56.540 --> 00:46:02.650
谢谢，我想那是几分钟

00:45:59.780 --> 00:46:05.240
对，是的，不是秒

00:46:02.650 --> 00:46:08.480
可变性之间存在联系

00:46:05.240 --> 00:46:10.460
和对象身份，我们来了

00:46:08.480 --> 00:46:11.960
以我们认为的方式思考

00:46:10.460 --> 00:46:14.450
关于这个道具这些问题

00:46:11.960 --> 00:46:16.050
意识到对象身份可以是

00:46:14.450 --> 00:46:17.970
被视为许多邪恶的根源

00:46:16.050 --> 00:46:20.310
如果可以摆脱对象标识

00:46:17.970 --> 00:46:22.230
然后不变性也消失了

00:46:20.310 --> 00:46:26.520
自动但很多其他坏事

00:46:22.230 --> 00:46:29.070
基本上也是如此，即使你

00:46:26.520 --> 00:46:30.510
对象是非常精心组织的

00:46:29.070 --> 00:46:33.660
你永远不会在外面写

00:46:30.510 --> 00:46:35.369
您保证JIT应该的构造函数

00:46:33.660 --> 00:46:37.080
相信你，但那不会因为有人

00:46:35.369 --> 00:46:38.460
可能带有反思和突破

00:46:37.080 --> 00:46:40.410
这是您精心构造的

00:46:38.460 --> 00:46:42.270
不变式，因此我们想在

00:46:40.410 --> 00:46:43.920
虚拟机级别，但即使您能够

00:46:42.270 --> 00:46:46.020
加强所有领域的真实性

00:46:43.920 --> 00:46:47.910
最终报头进行状态

00:46:46.020 --> 00:46:49.710
对象头是有状态的，什么状态

00:46:47.910 --> 00:46:51.270
好，你必须记住系统

00:46:49.710 --> 00:46:55.380
您为其分配的身份哈希码

00:46:51.270 --> 00:46:58.320
看到你对你拥有的单词身份

00:46:55.380 --> 00:46:59.820
必须，如果您同步它

00:46:58.320 --> 00:47:01.140
必须记住谁在同步它

00:46:59.820 --> 00:47:04.020
以及如何在您不同步时

00:47:01.140 --> 00:47:05.670
做到了，甚至有一个偶数

00:47:04.020 --> 00:47:08.130
说明我正在同步的状态

00:47:05.670 --> 00:47:09.869
不是，我就是那一部分

00:47:08.130 --> 00:47:12.570
还有无状态的对象，它是

00:47:09.869 --> 00:47:15.540
因为那个古怪的身份所以

00:47:12.570 --> 00:47:17.460
这就是为什么我们要添加提示类型两种

00:47:15.540 --> 00:47:19.470
类型完全是敌对身份

00:47:17.460 --> 00:47:21.119
他们拒绝让您看到任何身份

00:47:19.470 --> 00:47:23.730
没有系统身份哈希码

00:47:21.119 --> 00:47:25.080
出生提示类型仅适用于所有旧类型

00:47:23.730 --> 00:47:27.810
我们将把所有遗留物

00:47:25.080 --> 00:47:30.060
类型本身很难兼容

00:47:27.810 --> 00:47:32.220
尘土飞扬的甲板问题对吧，但我们

00:47:30.060 --> 00:47:36.660
将添加不包含的新类型

00:47:32.220 --> 00:47:38.490
有缺陷但有认同感

00:47:36.660 --> 00:47:40.800
而且我们还将研究如何

00:47:38.490 --> 00:47:42.510
有一些遗产，所有类型都很好

00:47:40.800 --> 00:47:45.420
像基于价值的类那样的条件

00:47:42.510 --> 00:47:47.400
脱去他们的身份假扮

00:47:45.420 --> 00:47:50.040
提示类型，然后更优化

00:47:47.400 --> 00:47:53.150
以这种形式，然后您键入

00:47:50.040 --> 00:47:55.170
我之前提到过或顶级礼帽

00:47:53.150 --> 00:47:58.290
我想谈的最后一点

00:47:55.170 --> 00:47:59.369
大约在60秒内比较合适

00:47:58.290 --> 00:48:00.770
并完成我们正在寻找的位

00:47:59.369 --> 00:48:03.780
考虑在不久的将来做

00:48:00.770 --> 00:48:06.060
巢友，这是在

00:48:03.780 --> 00:48:08.609
虚拟机谈论信任圈

00:48:06.060 --> 00:48:11.310
这是一个

00:48:08.609 --> 00:48:13.770
 Java cup源文件中的Java 

00:48:11.310 --> 00:48:15.450
你知道如何在同一个内部类

00:48:13.770 --> 00:48:17.730
班级巢穴可以互相交谈

00:48:15.450 --> 00:48:20.570
通过他们的私有JVM不会

00:48:17.730 --> 00:48:23.369
知道了，我们将解决这个问题

00:48:20.570 --> 00:48:25.500
这很有用，因为这样您可以

00:48:23.369 --> 00:48:27.030
有这些大小合适的微小圆圈

00:48:25.500 --> 00:48:29.130
可以看到彼此的私人的信任

00:48:27.030 --> 00:48:29.509
不变性，甚至没有人

00:48:29.130 --> 00:48:31.309
相同

00:48:29.509 --> 00:48:33.319
包装可以触摸它，那就是

00:48:31.309 --> 00:48:34.849
在VM中会很好，但是它

00:48:33.319 --> 00:48:36.229
需要明确定义什么

00:48:34.849 --> 00:48:38.089
估计所以没有一个明确的

00:48:36.229 --> 00:48:43.639
定义VM现在可以使用的位置

00:48:38.089 --> 00:48:45.919
我们要把它密封起来

00:48:43.639 --> 00:48:47.419
接口接口非常适合

00:48:45.919 --> 00:48:50.359
隐藏信息，但它们很糟糕

00:48:47.419 --> 00:48:53.479
作为安全漏洞，因为任何人

00:48:50.359 --> 00:48:55.099
可以实现界面将修复它

00:48:53.479 --> 00:48:56.899
允许界面清晰如

00:48:55.099 --> 00:48:59.209
密封，这是一个建议

00:48:56.899 --> 00:49:00.529
不要听我的律师，也不要

00:48:59.209 --> 00:49:02.089
不要去银行，但是我

00:49:00.529 --> 00:49:04.069
认为我们将要有接口

00:49:02.089 --> 00:49:05.630
可以像接口一样密封

00:49:04.069 --> 00:49:07.819
有一个私人的建设者，是一个

00:49:05.630 --> 00:49:11.719
抽象类，但作为接口

00:49:07.819 --> 00:49:13.849
天花板真的很不透明

00:49:11.719 --> 00:49:16.099
粒度应该是嵌套包

00:49:13.849 --> 00:49:17.749
或模块，这些非常有用

00:49:16.099 --> 00:49:20.509
强大的同心信任圈

00:49:17.749 --> 00:49:23.719
 JVM提供并最终密封

00:49:20.509 --> 00:49:24.889
密封的领域是什么

00:49:23.719 --> 00:49:26.630
您可以阅读但无法阅读的字段

00:49:24.889 --> 00:49:28.819
写出什么用途不只是一个

00:49:26.630 --> 00:49:30.469
如果私有访问，则最后一个字段不是

00:49:28.819 --> 00:49:32.779
家伙可以写，但只有公众才能写

00:49:30.469 --> 00:49:34.849
大家只能阅读它，我们不会

00:49:32.779 --> 00:49:36.829
如果可能的话，会更多地使用字段

00:49:34.849 --> 00:49:39.169
公开但不能公开

00:49:36.829 --> 00:49:41.989
写那会很酷不会

00:49:39.169 --> 00:49:46.609
我们做吧，没有理由我们不能做

00:49:41.989 --> 00:49:48.019
内部时间还不算晚，所以

00:49:46.609 --> 00:49:50.239
想法有一个对称场

00:49:48.019 --> 00:49:54.249
无障碍环境对

00:49:50.239 --> 00:49:56.749
少读一些正确的权利

00:49:54.249 --> 00:49:58.489
让我的律师再告诉你不要

00:49:56.749 --> 00:50:01.029
相信我所说的话

00:49:58.489 --> 00:50:05.289
这是我的最后我的最后一点

00:50:01.029 --> 00:50:08.359
这是JVM语言峰会

00:50:05.289 --> 00:50:11.569
图形和嵌入其中

00:50:08.359 --> 00:50:13.669
查找位的秘密网址

00:50:11.569 --> 00:50:17.449
这个演讲的我的演讲

00:50:13.669 --> 00:50:20.419
 CR上的文件夹打开JDK java.net并使用

00:50:17.449 --> 00:50:22.479
我已经完成了，我真的很高兴你能

00:50:20.419 --> 00:50:22.479
这里

00:50:22.539 --> 00:50:26.170
没有时间提问

00:50:25.010 --> 00:50:28.520
 [音乐] 

00:50:26.170 --> 00:50:28.960
 [掌声] 

00:50:28.520 --> 00:50:32.489
您

00:50:28.960 --> 00:50:32.489
 [音乐] 

