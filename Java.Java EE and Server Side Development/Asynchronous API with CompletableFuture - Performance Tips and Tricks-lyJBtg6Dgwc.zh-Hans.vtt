WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.800 --> 00:00:12.900
大家好，我很高兴见到你

00:00:09.450 --> 00:00:17.789
大家都在这里，现在我想

00:00:12.900 --> 00:00:24.270
分享一些细节

00:00:17.789 --> 00:00:28.110
谈论可完成的未来

00:00:24.270 --> 00:00:30.660
关于幻灯片的一些细节可能是

00:00:28.110 --> 00:00:36.180
很多已经熟悉的幻灯片

00:00:30.660 --> 00:00:39.899
但无论如何我都必须说出我喜欢的

00:00:36.180 --> 00:00:44.010
就像真的，如果我们的公司

00:00:39.899 --> 00:00:47.010
我没有那么可爱的律师

00:00:44.010 --> 00:00:48.870
请他们这样做，因为这张幻灯片

00:00:47.010 --> 00:00:51.840
是我的积蓄

00:00:48.870 --> 00:00:56.399
我可以从

00:00:51.840 --> 00:00:57.120
阶段，这意味着我不负责任

00:00:56.399 --> 00:01:01.379
为了那个原因

00:00:57.120 --> 00:01:06.119
好吧，关于我的几句话我在工作

00:01:01.379 --> 00:01:09.990
在Oracle中的工作以及我在Oracle中的目标

00:01:06.119 --> 00:01:12.030
甲骨文公司将GDK Java Java虚拟化

00:01:09.990 --> 00:01:17.000
机速我是一个表现

00:01:12.030 --> 00:01:19.409
工程师，所以我必须检查

00:01:17.000 --> 00:01:26.430
过去表现合理

00:01:19.409 --> 00:01:29.549
如果没有解决我在任何地方

00:01:26.430 --> 00:01:33.000
没有绑定到特定的Java库

00:01:29.549 --> 00:01:35.580
并发的东西等什么需要

00:01:33.000 --> 00:01:38.670
管理或客户和本周

00:01:35.580 --> 00:01:42.689
我正在为此工作，好吧，我们是什么

00:01:38.670 --> 00:01:44.700
谈论可实现的未来是

00:01:42.689 --> 00:01:48.350
很好的课，这些都很好

00:01:44.700 --> 00:01:51.030
 Java 8中出现的功能

00:01:48.350 --> 00:01:55.700
不幸的是，未来本身可以完成

00:01:51.030 --> 00:01:59.939
没有在Java 8的其他任何部分中使用

00:01:55.700 --> 00:02:03.170
确实存在，这就是我会尝试的全部

00:01:59.939 --> 00:02:06.540
了解周围有多少人

00:02:03.170 --> 00:02:10.530
星星开始使用我做了一些

00:02:06.540 --> 00:02:12.779
在Twitter上短途询问如何

00:02:10.530 --> 00:02:15.059
人们正在使用可完成的未来

00:02:12.779 --> 00:02:16.140
可以看到结果，我想问你

00:02:15.059 --> 00:02:19.020
关于那个

00:02:16.140 --> 00:02:23.630
首先请举手

00:02:19.020 --> 00:02:31.820
在您的代码中使用可完成的未来

00:02:23.630 --> 00:02:36.300
很酷的人，只是和那个玩

00:02:31.820 --> 00:02:39.000
对可计算的未来家伙什么都不做

00:02:36.300 --> 00:02:41.760
我只想要你，对不起，我不会

00:02:39.000 --> 00:02:44.310
讲述我的未来

00:02:41.760 --> 00:02:47.040
试图解释性能技巧

00:02:44.310 --> 00:02:51.150
性能同步如何更快地使用它

00:02:47.040 --> 00:02:52.980
我没有时间解释

00:02:51.150 --> 00:02:56.760
有关可计算鱼本身的详细信息，但

00:02:52.980 --> 00:02:59.610
我希望这将是又一次

00:02:56.760 --> 00:03:02.570
问那些正在使用的家伙

00:02:59.610 --> 00:03:05.400
请在生产中完成未来

00:03:02.570 --> 00:03:12.600
谁对此感到满意和满意

00:03:05.400 --> 00:03:14.400
上课，谁不好，请来

00:03:12.600 --> 00:03:16.950
会议结束后我可能都在

00:03:14.400 --> 00:03:18.770
格林纳达我想说的问题我想

00:03:16.950 --> 00:03:24.660
收集有关该股票的信息

00:03:18.770 --> 00:03:28.500
真的，你可以看到不到一半

00:03:24.660 --> 00:03:31.380
的回答者正在使用可完成的

00:03:28.500 --> 00:03:34.170
未来，现在我试图了解什么

00:03:31.380 --> 00:03:36.480
发生在github上只是尝试使

00:03:34.170 --> 00:03:40.530
寻找可完成的未来，我们

00:03:36.480 --> 00:03:43.440
可以得出结论，采用

00:03:40.530 --> 00:03:47.519
完成的不是很大，但是

00:03:43.440 --> 00:03:50.280
每年增加增加我们

00:03:47.519 --> 00:03:52.640
首先，我要在Java 9中有一个新功能

00:03:50.280 --> 00:03:56.310
想说在Java 9中我们已经

00:03:52.640 --> 00:04:00.269
内部具有可完成的未来

00:03:56.310 --> 00:04:03.330
我们的图书馆就像

00:04:00.269 --> 00:04:08.820
原型和最有趣的部分

00:04:03.330 --> 00:04:11.160
是一个新的HTTP客户端，大部分结果

00:04:08.820 --> 00:04:13.019
我将介绍的大多数性能提示

00:04:11.160 --> 00:04:17.370
不以为我只是

00:04:13.019 --> 00:04:19.979
发明了实用的实用水槽

00:04:17.370 --> 00:04:24.390
在我工作时发现的

00:04:19.979 --> 00:04:27.690
 HTTP到客户端的性能，这是一个

00:04:24.390 --> 00:04:28.889
实际发现也许我失去了一些

00:04:27.690 --> 00:04:31.919
想法但是

00:04:28.889 --> 00:04:34.680
所以就没出现了

00:04:31.919 --> 00:04:37.710
关于新HTTP客户端的几句话

00:04:34.680 --> 00:04:43.139
它出现在Java 9中是一个新的

00:04:37.710 --> 00:04:46.099
应涵盖老板HTTP 1.1和

00:04:43.139 --> 00:04:48.990
 HTTP 2是新的API 

00:04:46.099 --> 00:04:52.379
不幸的是，这个客户没有参与

00:04:48.990 --> 00:04:54.539
 Java标准，但因为它是一个

00:04:52.379 --> 00:04:58.259
很多讨论和争论

00:04:54.539 --> 00:05:00.199
我们决定将这个客户

00:04:58.259 --> 00:05:04.650
孵化器是一个新功能

00:05:00.199 --> 00:05:07.139
这是一种沙盒， 

00:05:04.650 --> 00:05:09.379
 API将离开一段时间

00:05:07.139 --> 00:05:12.449
然后我们只有两个选择

00:05:09.379 --> 00:05:15.270
您将有选择将a悔改变为

00:05:12.449 --> 00:05:19.110
或者我们可以选择放弃的联系

00:05:15.270 --> 00:05:22.439
它完全下降，所以4 gdk9 HTTP 

00:05:19.110 --> 00:05:24.689
孵化器中的客户，这就是为什么

00:05:22.439 --> 00:05:28.979
对我们来说很重要

00:05:24.689 --> 00:05:33.000
反馈并进行更改和改进

00:05:28.979 --> 00:05:38.180
仍然可以下载现有的API 

00:05:33.000 --> 00:05:41.909
 gdk9并玩我不会告诉

00:05:38.180 --> 00:05:43.909
关于HTTP客户端，我只是会尝试

00:05:41.909 --> 00:05:46.529
专注于异步

00:05:43.909 --> 00:05:49.620
请求，因为这是我们的目标

00:05:46.529 --> 00:05:51.750
讨论，因此在HTTP客户端中

00:05:49.620 --> 00:05:54.539
两种发送请求的方式

00:05:51.750 --> 00:05:57.740
这是同步解锁请求

00:05:54.539 --> 00:06:00.569
和异步的样子

00:05:57.740 --> 00:06:04.259
同步或阻止请求外观

00:06:00.569 --> 00:06:08.699
很简单，我们正在准备请求

00:06:04.259 --> 00:06:11.159
做沙子，等到我们的HTTP 

00:06:08.699 --> 00:06:13.979
响应到达我们正在阻止， 

00:06:11.159 --> 00:06:17.360
之后的方法集调用

00:06:13.979 --> 00:06:19.860
我们完全完成了

00:06:17.360 --> 00:06:22.789
响应并可以提取所有

00:06:19.860 --> 00:06:27.360
我们需要的信息，以及

00:06:22.789 --> 00:06:33.270
我们的计划也有一种沉没的方法

00:06:27.360 --> 00:06:36.509
在这种情况下，异步同步

00:06:33.270 --> 00:06:41.039
阻止该调用

00:06:36.509 --> 00:06:42.069
我们只是返回我们可完成的未来

00:06:41.039 --> 00:06:45.219
有抱负的人

00:06:42.069 --> 00:06:47.169
在某个地方我们可以做那个未来

00:06:45.219 --> 00:06:49.319
随便你怎么走

00:06:47.169 --> 00:06:52.119
那个未来要付出结果，所以我们可以

00:06:49.319 --> 00:06:57.399
附加行动和过程链

00:06:52.119 --> 00:07:01.919
他们是这样，而我想要的另一件事

00:06:57.399 --> 00:07:04.659
为我们的HTTP客户端强调的是

00:07:01.919 --> 00:07:06.610
建立执行人的能力

00:07:04.659 --> 00:07:08.409
所以总的来说，我们有很多

00:07:06.610 --> 00:07:10.779
成为客户的选择

00:07:08.409 --> 00:07:14.319
 bla bla bla bla需要做什么

00:07:10.779 --> 00:07:16.360
正确的工作是HTTP协议

00:07:14.319 --> 00:07:21.789
选择下面，您可以看到我们在

00:07:16.360 --> 00:07:23.559
 HTTP到新标准，但正如我所说

00:07:21.789 --> 00:07:25.389
我们提供两种方法阻止

00:07:23.559 --> 00:07:27.330
方法和异步，如果我们有一个

00:07:25.389 --> 00:07:30.939
同步方法，我们应该

00:07:27.330 --> 00:07:34.770
某处与执行有关，因为

00:07:30.939 --> 00:07:38.259
我们原来的方法不是阻塞

00:07:34.770 --> 00:07:40.330
为了向用户提供其API， 

00:07:38.259 --> 00:07:43.139
不是一个独立的应用程序

00:07:40.330 --> 00:07:45.459
控制我们应该执行的

00:07:43.139 --> 00:07:48.550
建立外部执行者的能力

00:07:45.459 --> 00:07:54.099
由于，用户可能会缩小或

00:07:48.550 --> 00:07:56.439
扩大那个范围，好吧，我

00:07:54.099 --> 00:07:59.860
在考虑阻止异步

00:07:56.439 --> 00:08:01.779
 API，特别是我会认为这两个

00:07:59.860 --> 00:08:05.519
各种方法第一种方法

00:08:01.779 --> 00:08:08.740
在做某事并返回

00:08:05.519 --> 00:08:12.490
为我们完成的结果和异步

00:08:08.740 --> 00:08:14.439
这正在做国家的时刻

00:08:12.490 --> 00:08:17.349
调用并返回可完成的未来

00:08:14.439 --> 00:08:19.559
我不会谈论另一种

00:08:17.349 --> 00:08:22.180
知道提供通话袋等的场景

00:08:19.559 --> 00:08:25.949
这超出了讨论范围

00:08:22.180 --> 00:08:30.249
让我们谈谈可实现的未来

00:08:25.949 --> 00:08:31.330
好吧，问题是您真的需要吗

00:08:30.249 --> 00:08:35.050
老板

00:08:31.330 --> 00:08:37.260
这样的方法同时你呢

00:08:35.050 --> 00:08:37.260
认为

00:08:38.970 --> 00:08:45.900
但我只想告诉你

00:08:42.270 --> 00:08:48.060
跟随一个沉没

00:08:45.900 --> 00:08:50.610
跟着它很容易

00:08:48.060 --> 00:08:53.790
在API中润滑以转换I同步

00:08:50.610 --> 00:08:56.580
同步度假只是为了

00:08:53.790 --> 00:09:01.340
加入可完成的未来并抛出

00:08:56.580 --> 00:09:05.370
社会，我们可以使我们可以采取我们的

00:09:01.340 --> 00:09:07.680
传递给补给船时阻塞API 

00:09:05.370 --> 00:09:09.870
由完全融合构成

00:09:07.680 --> 00:09:12.150
在鲑鱼中执行作为线程，我们

00:09:09.870 --> 00:09:15.360
将获得完全的融合

00:09:12.150 --> 00:09:17.550
足够，所以问题可能是

00:09:15.360 --> 00:09:21.540
感觉就离开一个小伙子， 

00:09:17.550 --> 00:09:24.920
不要爆炸我们的公共API 

00:09:21.540 --> 00:09:32.130
关于他们首先让我们考虑

00:09:24.920 --> 00:09:37.140
如果实施阻塞，第一个会下沉

00:09:32.130 --> 00:09:42.510
 API仅具有同步API作为

00:09:37.140 --> 00:09:44.820
基本的基本内容是全部三个

00:09:42.510 --> 00:09:50.940
我们需要在其中插入的行

00:09:44.820 --> 00:09:53.940
平底锅工作会正确吗

00:09:50.940 --> 00:09:56.100
它会工作，但让我们看看它会如何

00:09:53.940 --> 00:09:58.230
工作，所以我们拥有的是

00:09:56.100 --> 00:10:00.770
用户线程用户，我的意思是

00:09:58.230 --> 00:10:04.590
我们称呼的用户环境比率

00:10:00.770 --> 00:10:06.500
 API的方法，以及

00:10:04.590 --> 00:10:09.840
同步有一些执行者

00:10:06.500 --> 00:10:11.700
我们应该在哪里做有用的工作，我们

00:10:09.840 --> 00:10:16.050
在做有用的工作

00:10:11.700 --> 00:10:18.180
执行者当然是这种转移

00:10:16.050 --> 00:10:21.360
从一种状态到另一种状态并返回

00:10:18.180 --> 00:10:23.060
应该花费我们只是检查一下

00:10:21.360 --> 00:10:27.089
它要多少钱

00:10:23.060 --> 00:10:33.690
让我们做一些执行，我做到了

00:10:27.089 --> 00:10:36.120
相对图表我有一些执行力100 

00:10:33.690 --> 00:10:38.820
纳秒有用功100微秒

00:10:36.120 --> 00:10:41.910
有用的工作和100毫秒

00:10:38.820 --> 00:10:45.600
工作是一条蓝线，由

00:10:41.910 --> 00:10:49.200
 100％和橙色

00:10:45.600 --> 00:10:50.890
这是我们转移的开销

00:10:49.200 --> 00:10:54.730
执行到

00:10:50.890 --> 00:10:57.250
是的，第一行100秒

00:10:54.730 --> 00:10:58.930
我没有地方应该是ZZZ这些

00:10:57.250 --> 00:11:03.400
橙色线应该在这里通过

00:10:58.930 --> 00:11:07.120
在这里，但看起来像

00:11:03.400 --> 00:11:10.720
执行的很大一部分

00:11:07.120 --> 00:11:12.700
像100毫秒这样的大盒子10 

00:11:10.720 --> 00:11:16.240
毫秒甚至一毫秒

00:11:12.700 --> 00:11:17.410
紧要紧多大都没关系

00:11:16.240 --> 00:11:19.540
让我们稍后再检查

00:11:17.410 --> 00:11:26.050
让我们检查一下我何时执行

00:11:19.540 --> 00:11:28.450
在某些电台曾遇到压力的情况下

00:11:26.050 --> 00:11:31.990
正在增加并清理执行

00:11:28.450 --> 00:11:34.600
我知道我对希腊寄养

00:11:31.990 --> 00:11:36.430
那个我的笔记本电脑

00:11:34.600 --> 00:11:38.020
显示您的演示文稿是联想

00:11:36.430 --> 00:11:41.560
 ThinkPad等等等等

00:11:38.020 --> 00:11:44.080
这是Casa，它必须满足您的课程要求， 

00:11:41.560 --> 00:11:47.020
超线程，所以我们通常有

00:11:44.080 --> 00:11:49.900
我们执行的四个硬件线程

00:11:47.020 --> 00:11:52.360
字母K是

00:11:49.900 --> 00:11:56.260
当我们的系统位于

00:11:52.360 --> 00:12:00.370
有更多相同数量的线程

00:11:56.260 --> 00:12:03.130
比我的硬件允许我做的

00:12:00.370 --> 00:12:07.330
他们曾经遇到过这样的情况

00:12:03.130 --> 00:12:11.380
即使在非常情况下

00:12:07.330 --> 00:12:14.590
像100毫秒这样的大块

00:12:11.380 --> 00:12:17.590
已经很可行了，这就是为什么我

00:12:14.590 --> 00:12:19.600
认为这是第一个原因

00:12:17.590 --> 00:12:22.180
问题，为什么我们需要分开

00:12:19.600 --> 00:12:24.130
同步雇用者可能会显得黑

00:12:22.180 --> 00:12:26.260
我们需要提供的api 

00:12:24.130 --> 00:12:28.510
最高性能

00:12:26.260 --> 00:12:33.180
吞吐量不做任何事情

00:12:28.510 --> 00:12:36.370
平行它会更好地摇摆，好吗

00:12:33.180 --> 00:12:37.960
它也是某人的过渡形式

00:12:36.370 --> 00:12:41.050
执行任务从一个线程到

00:12:37.960 --> 00:12:43.810
另一个线程的成本，所以这是一个相当

00:12:41.050 --> 00:12:44.130
简单的主意可以避免

00:12:43.810 --> 00:12:49.510
它

00:12:44.130 --> 00:12:53.200
好，让我们谈谈第二种方式

00:12:49.510 --> 00:12:55.150
你在API中有块很容易

00:12:53.200 --> 00:12:58.930
创建一个同步页面

00:12:55.150 --> 00:13:01.510
提交任务持续不断的威胁

00:12:58.930 --> 00:13:03.740
通常，我们以这种经典方式

00:13:01.510 --> 00:13:06.170
当我们已经有一对旧的

00:13:03.740 --> 00:13:08.210
我们只想在父母中有一个障碍

00:13:06.170 --> 00:13:12.020
添加一个同步API 

00:13:08.210 --> 00:13:14.090
这项工作会改变吗？ 

00:13:12.020 --> 00:13:18.500
我们的抽象做点什么，让我们

00:13:14.090 --> 00:13:23.020
回到陡峭的山坡上

00:13:18.500 --> 00:13:26.930
客户端，看起来像这样我

00:13:23.020 --> 00:13:30.260
必须说它会工作，但不会

00:13:26.930 --> 00:13:32.660
在所有情况下，对不起，我们不得不

00:13:30.260 --> 00:13:36.290
花不到10分钟的时间来解释

00:13:32.660 --> 00:13:40.370
为什么，所以两种情况下都行不通

00:13:36.290 --> 00:13:44.750
所以典型的HTTP请求是什么样的

00:13:40.370 --> 00:13:47.480
我们发送头到服务器将发送正文

00:13:44.750 --> 00:13:49.790
我们正在等待标题等待主体

00:13:47.480 --> 00:13:52.090
这是非常非常简单的图片

00:13:49.790 --> 00:13:57.410
当然还有很多其他细节

00:13:52.090 --> 00:13:59.720
这些收到的意思意味着

00:13:57.410 --> 00:14:03.650
我们必须等待我们必须等待

00:13:59.720 --> 00:14:05.990
阻止一些拥有的东西

00:14:03.650 --> 00:14:08.120
让我们检查一下我们有多努力

00:14:05.990 --> 00:14:11.480
将我们的执行转移到数字

00:14:08.120 --> 00:14:14.570
线程，我们必须阻止它

00:14:11.480 --> 00:14:17.090
可能是对象监视器上的消息等待

00:14:14.570 --> 00:14:20.300
或者可以在一个

00:14:17.090 --> 00:14:22.760
条件可能是某种

00:14:20.300 --> 00:14:25.130
阻止下面的立方体最后通atum 

00:14:22.760 --> 00:14:27.200
阻塞队列，再次等待

00:14:25.130 --> 00:14:30.110
无论如何，我们应该停止某种方式

00:14:27.200 --> 00:14:31.690
等待，我们将停止执行

00:14:30.110 --> 00:14:34.400
叛徒不再工作

00:14:31.690 --> 00:14:37.790
在这种情况下，我们要做的是

00:14:34.400 --> 00:14:39.950
必须在某处执行方法

00:14:37.790 --> 00:14:43.960
将会收到来自

00:14:39.950 --> 00:14:47.920
服务器和将发送的方法

00:14:43.960 --> 00:14:50.360
通知信号我们状况良好，并且

00:14:47.920 --> 00:14:53.870
继续执行是对的，我

00:14:50.360 --> 00:14:55.580
必须警告这种计划，我

00:14:53.870 --> 00:15:01.700
在这里写不要这样做

00:14:55.580 --> 00:15:04.160
为什么在那把钥匙我的眼睛和接收

00:15:01.700 --> 00:15:08.540
在同一执行程序中响应

00:15:04.160 --> 00:15:10.160
这意味着在某些情况下

00:15:08.540 --> 00:15:13.580
执行者可能会阻止所有压力

00:15:10.160 --> 00:15:16.160
而且我没有地方处理

00:15:13.580 --> 00:15:17.459
反应以及在哪里醒来

00:15:16.160 --> 00:15:19.740
现实中我需要一些

00:15:17.459 --> 00:15:22.920
不仅仅是用户设置执行器

00:15:19.740 --> 00:15:24.779
说我需要一些氧气

00:15:22.920 --> 00:15:28.649
阿斯特雷厄斯可能为零

00:15:24.779 --> 00:15:29.579
目标可能很多，但对于

00:15:28.649 --> 00:15:32.490
 httpclient 

00:15:29.579 --> 00:15:35.249
有些人足以

00:15:32.490 --> 00:15:40.399
永远不会阻塞的街道

00:15:35.249 --> 00:15:44.819
这将对

00:15:40.399 --> 00:15:47.730
收到数据并在压力中等待

00:15:44.819 --> 00:15:51.540
我们正在等待结果如何

00:15:47.730 --> 00:15:56.149
是第二部分的第一部分

00:15:51.540 --> 00:16:00.509
我向您展示了

00:15:56.149 --> 00:16:03.869
船运客户，这缩小了我的使用范围

00:16:00.509 --> 00:16:06.449
可爱的签证让我可以配置

00:16:03.869 --> 00:16:10.139
系统，我认为这是一个好主意

00:16:06.449 --> 00:16:12.110
如果我们不指定一些，我们真的

00:16:10.139 --> 00:16:15.179
不要对该方法施加任何约束

00:16:12.110 --> 00:16:18.149
它应该允许我们的图书馆卡车

00:16:15.179 --> 00:16:20.819
任何种类的执行者，包括

00:16:18.149 --> 00:16:23.279
默认执行者默认执行者

00:16:20.819 --> 00:16:25.649
缓存线程池让我们考虑一下

00:16:23.279 --> 00:16:27.779
关于决明子压力池的一点点

00:16:25.649 --> 00:16:32.129
只是复制了Javadoc而不会阅读

00:16:27.779 --> 00:16:36.569
阿姨强调了一个很好的想法

00:16:32.129 --> 00:16:39.449
缓存线程池，这意味着如果所有

00:16:36.569 --> 00:16:43.559
忙碌的小时将创建新的集合

00:16:39.449 --> 00:16:46.709
我们的新任务将很酷地执行

00:16:43.559 --> 00:16:48.959
但同样的事情是负面力量

00:16:46.709 --> 00:16:51.360
有关缓存污水池的负面信息

00:16:48.959 --> 00:16:53.160
因为我们必须创建线程并

00:16:51.360 --> 00:16:55.290
线程可能是资源

00:16:53.160 --> 00:16:57.179
昂贵，让我们做一些实验

00:16:55.290 --> 00:17:01.860
如果您尝试的话，这是一个非常好的开始

00:16:57.179 --> 00:17:05.189
通过简单的方式实现我们的HTTP请求

00:17:01.860 --> 00:17:07.289
在API中包装现有块

00:17:05.189 --> 00:17:09.390
只是片刻，我意识到

00:17:07.289 --> 00:17:12.709
不知道为什么，但单个HTTP 

00:17:09.390 --> 00:17:15.539
请求一般使用20个线程

00:17:12.709 --> 00:17:22.500
并不意味着同时100 

00:17:15.539 --> 00:17:27.620
请求将需要200个压力

00:17:22.500 --> 00:17:27.620
除了200层以外的其他想法

00:17:27.759 --> 00:17:36.049
是的，也许在三明治机上

00:17:32.960 --> 00:17:40.100
配置和扩展堆栈管道

00:17:36.049 --> 00:17:42.799
空间等将工作，但我可以单位

00:17:40.100 --> 00:17:49.879
为100 simoleons请求，但有人

00:17:42.799 --> 00:17:52.249
将使您收到101个请求，确定该怎么办

00:17:49.879 --> 00:17:56.090
您认为如果您解决该问题

00:17:52.249 --> 00:17:59.179
封锁了我们的创新线索

00:17:56.090 --> 00:18:02.090
执行者，所以我们必须解决它

00:17:59.179 --> 00:18:07.369
在这里，我们有一个发送方法

00:18:02.090 --> 00:18:09.080
做一个等待，等待结果的想法

00:18:07.369 --> 00:18:10.789
如何避免阻塞相当

00:18:09.080 --> 00:18:14.210
简单，它首先包括两个步骤

00:18:10.789 --> 00:18:16.100
最重要的是

00:18:14.210 --> 00:18:18.919
可以考虑未来的发展

00:18:16.100 --> 00:18:21.379
只能一次性使用

00:18:18.919 --> 00:18:23.080
条件，但为了上帝，这是

00:18:21.379 --> 00:18:26.269
与以前相同的代码

00:18:23.080 --> 00:18:28.580
与以前相同

00:18:26.269 --> 00:18:31.460
因为里面有图纸

00:18:28.580 --> 00:18:33.350
重量，但这只是第一步

00:18:31.460 --> 00:18:35.840
第二步，我们在这里做什么

00:18:33.350 --> 00:18:37.399
正在尝试执行供应发送的接收器

00:18:35.840 --> 00:18:41.419
代码和一些网络阻止

00:18:37.399 --> 00:18:43.009
让我们内联并放入

00:18:41.419 --> 00:18:44.960
为了采取不同的行动

00:18:43.009 --> 00:18:47.960
了解我们正在如何运作

00:18:44.960 --> 00:18:51.619
链，这就是我们所使用的链方式

00:18:47.960 --> 00:18:53.799
阻止可完成的未来吧

00:18:51.619 --> 00:18:53.799
这个

00:18:54.200 --> 00:19:00.580
谁知道设计是由什么组成的

00:18:56.960 --> 00:19:05.210
厄运是如何运作的

00:19:00.580 --> 00:19:07.309
没有人有很多手

00:19:05.210 --> 00:19:10.100
您正在使用可完成的未来

00:19:07.309 --> 00:19:13.909
您如何使用抱怨未来

00:19:10.100 --> 00:19:16.460
毫无疑问，这是一个

00:19:13.909 --> 00:19:20.379
参孙几乎不可能参孙

00:19:16.460 --> 00:19:20.379
比坎波斯还有趣

00:19:20.450 --> 00:19:26.869
然后就组成了

00:19:22.970 --> 00:19:28.970
执行lambda函数的位置

00:19:26.869 --> 00:19:34.039
动作完成的动作

00:19:28.970 --> 00:19:38.119
将来再撰写返回

00:19:34.039 --> 00:19:43.649
可计算融合

00:19:38.119 --> 00:19:45.629
封装我们隐藏的结果

00:19:43.649 --> 00:19:51.149
我们以前的完整级别的鱼

00:19:45.629 --> 00:19:53.940
就像一个方法中的平面图

00:19:51.149 --> 00:19:56.779
函数式编程，但是大多数

00:19:53.940 --> 00:19:59.549
她最有趣的部分是

00:19:56.779 --> 00:20:03.179
鱼未完成的时间

00:19:59.549 --> 00:20:05.669
那一刻我们没有阻止我们

00:20:03.179 --> 00:20:06.539
只是我们没有执行我们的

00:20:05.669 --> 00:20:09.749
在这里行动

00:20:06.539 --> 00:20:11.369
我们刚完成建设

00:20:09.749 --> 00:20:14.639
我们不会为此得到保证

00:20:11.369 --> 00:20:16.879
在这里采取行动，这意味着我们

00:20:14.639 --> 00:20:20.220
压力将返回来执行错误

00:20:16.879 --> 00:20:23.190
如果是从技术人员那里读来的，则意味着我们

00:20:20.220 --> 00:20:27.570
没有从捕获该线程

00:20:23.190 --> 00:20:30.379
准备审查的执行情况

00:20:27.570 --> 00:20:33.239
一些有用的东西，它的关键部分

00:20:30.379 --> 00:20:36.269
完全陷入现实

00:20:33.239 --> 00:20:38.869
使用时消除了阻塞

00:20:36.269 --> 00:20:43.230
可计算融合改变Quietus 

00:20:38.869 --> 00:20:46.470
东西什么都没有，所以我们在这里我们

00:20:43.230 --> 00:20:48.269
在这里有我们的线程我们在这里我们在

00:20:46.470 --> 00:20:52.259
做他们的撰写方法有一个

00:20:48.269 --> 00:20:54.929
对象是我们的未来，也是我们的氧气

00:20:52.259 --> 00:20:57.899
我们只是发送完整的威胁信号

00:20:54.929 --> 00:21:00.210
这意味着当未来变成

00:20:57.899 --> 00:21:02.669
在某个地方完成也许是另一个威胁

00:21:00.210 --> 00:21:08.809
我们执行后续的变更分数

00:21:02.669 --> 00:21:12.869
并按照要求做

00:21:08.809 --> 00:21:16.369
通过简单的HTTP客户端上的简单结果

00:21:12.869 --> 00:21:20.639
我们得到的所有障碍物的产生和

00:21:16.369 --> 00:21:25.700
更改以替换为Zen组成您

00:21:20.639 --> 00:21:28.649
提升了40％的工作敌人速度

00:21:25.700 --> 00:21:31.710
特别是你应该如何成为客户

00:21:28.649 --> 00:21:34.590
而这是消除的障碍

00:21:31.710 --> 00:21:40.049
最重要的事情如何制作

00:21:34.590 --> 00:21:42.149
如果您是未来，可以更快完成

00:21:40.049 --> 00:21:44.970
使我们陷入混乱

00:21:42.149 --> 00:21:47.520
如果不阻止，就不应该阻止

00:21:44.970 --> 00:21:51.200
我们的压力或回报

00:21:47.520 --> 00:21:54.120
蜗牛，这是非常重要的

00:21:51.200 --> 00:21:55.650
幻灯片只是与之相关

00:21:54.120 --> 00:21:58.440
表现，仅用于教育

00:21:55.650 --> 00:22:01.110
目的时刻然后组成我以为

00:21:58.440 --> 00:22:03.450
这是最有趣的方法

00:22:01.110 --> 00:22:09.180
计算以上巨大的演员这个例子

00:22:03.450 --> 00:22:11.130
向您展示如何进行无限递归

00:22:09.180 --> 00:22:15.810
如果需要，可完成融合链

00:22:11.130 --> 00:22:18.480
只有这样我们才能做到这一点

00:22:15.810 --> 00:22:22.880
调整谷歌家伙，这是非常

00:22:18.480 --> 00:22:25.860
好东西，让我们进一步

00:22:22.880 --> 00:22:28.040
在我们继续讨论之前，我只是

00:22:25.860 --> 00:22:30.450
想问你以下问题

00:22:28.040 --> 00:22:32.610
假设我有两条线

00:22:30.450 --> 00:22:34.410
从我将来要做的那些

00:22:32.610 --> 00:22:37.980
从其他直系我附上

00:22:34.410 --> 00:22:42.870
哪条线会给人以感情

00:22:37.980 --> 00:22:53.550
您采取我们的行动，谁将投票支持

00:22:42.870 --> 00:22:56.700
案例abcdr我们如何接受教育

00:22:53.550 --> 00:22:58.650
可能是正确的答案

00:22:56.700 --> 00:23:02.220
从一组或任一组执行

00:22:58.650 --> 00:23:06.030
从如此真实，这也是相当

00:23:02.220 --> 00:23:09.120
重点链

00:23:06.030 --> 00:23:11.430
可计算的未来将被执行

00:23:09.120 --> 00:23:14.820
加工且不了解

00:23:11.430 --> 00:23:18.840
我们不能谈论抱怨

00:23:14.820 --> 00:23:20.700
未来的表现只是一些

00:23:18.840 --> 00:23:23.160
摘要，稍后我将展示

00:23:20.700 --> 00:23:25.710
例子，但这里有一些总结

00:23:23.160 --> 00:23:29.600
我只是说，如果我们使用

00:23:25.710 --> 00:23:31.800
然后应用方法然后撰写等

00:23:29.600 --> 00:23:34.290
这个动作可以执行

00:23:31.800 --> 00:23:36.210
可以从任何地方执行

00:23:34.290 --> 00:23:41.010
威胁完成我们的

00:23:36.210 --> 00:23:43.290
将来可以从链中执行

00:23:41.010 --> 00:23:46.530
在我们所处的地方建造

00:23:43.290 --> 00:23:50.610
构建我们的链，甚至可以

00:23:46.530 --> 00:23:54.630
当我们打电话给get的时候写

00:23:50.610 --> 00:23:57.720
在这里加入用户，我想给你看一个

00:23:54.630 --> 00:23:59.270
几个我做了的例子

00:23:57.720 --> 00:24:03.280
用苦恼

00:23:59.270 --> 00:24:08.060
这是一些这样的工具

00:24:03.280 --> 00:24:13.610
有时用于分析品尝

00:24:08.060 --> 00:24:17.000
 GDK内部的并发G技巧

00:24:13.610 --> 00:24:20.080
副业，这是第一个例子

00:24:17.000 --> 00:24:22.370
关于符号的一点点

00:24:20.080 --> 00:24:26.390
前提条件是之前执行过

00:24:22.370 --> 00:24:28.550
我们在左侧执行了线程

00:24:26.390 --> 00:24:30.320
那是右边的一个威胁

00:24:28.550 --> 00:24:33.190
他们执行的不是直线

00:24:30.320 --> 00:24:36.890
同时很多很多类型

00:24:33.190 --> 00:24:40.160
是时候捕捉各种

00:24:36.890 --> 00:24:42.080
比赛规模巨大，我们可以得到第一个榜样

00:24:40.160 --> 00:24:43.610
从一个威胁，我们正在完成

00:24:42.080 --> 00:24:46.160
从另一个州我们正在做小腿

00:24:43.610 --> 00:24:48.680
以下说明可以看到结果

00:24:46.160 --> 00:24:52.100
这是执行的确切数量

00:24:48.680 --> 00:24:54.500
建筑内部很多动作说

00:24:52.100 --> 00:24:57.770
完成内部有很多锁定动作

00:24:54.500 --> 00:24:59.840
实力再举一个例子

00:24:57.770 --> 00:25:03.170
如果您将来完成的话会发生

00:24:59.840 --> 00:25:09.770
两个知道返回类型的线程

00:25:03.170 --> 00:25:12.110
未来的完整回报类型

00:25:09.770 --> 00:25:25.390
完整的方法是布尔值可以吗

00:25:12.110 --> 00:25:25.390
猜猜这是什么意思

00:25:25.990 --> 00:25:34.220
是邮件完整的原因为

00:25:30.650 --> 00:25:36.380
调用完成的将来或返回

00:25:34.220 --> 00:25:38.330
如果该位置失败，则返回false 

00:25:36.380 --> 00:25:43.040
完整的未来，因为它可能是

00:25:38.330 --> 00:25:44.780
比赛好吧，让我们采取行动， 

00:25:43.040 --> 00:25:46.820
尝试与公司合作之前的行动

00:25:44.780 --> 00:25:49.060
只是未来的行动，而我

00:25:46.820 --> 00:25:52.910
两股完成

00:25:49.060 --> 00:25:57.620
在我写那个测试之前，我是

00:25:52.910 --> 00:26:00.740
认为这是新闻行动

00:25:57.620 --> 00:26:03.950
应该从成功完成

00:26:00.740 --> 00:26:05.840
线程，但这不是真的，它也可以

00:26:03.950 --> 00:26:12.230
从另一个线程执行

00:26:05.840 --> 00:26:15.110
未能完成好吗？ 

00:26:12.230 --> 00:26:16.910
第二个例子，我们只是做一个

00:26:15.110 --> 00:26:19.340
完成并加入一个联接

00:26:16.910 --> 00:26:21.980
来自我们未来的结果

00:26:19.340 --> 00:26:24.110
该动作可以从两个执行

00:26:21.980 --> 00:26:29.180
由于下雨天的压力

00:26:24.110 --> 00:26:31.730
威胁和最后一个例子，因为尝试

00:26:29.180 --> 00:26:33.770
当我有未来的时候成为疑问

00:26:31.730 --> 00:26:36.140
两个动作是并行独立的

00:26:33.770 --> 00:26:38.450
我像两条链子一样附加的动作

00:26:36.140 --> 00:26:40.040
从一开始我就在做

00:26:38.450 --> 00:26:45.140
从另一个时间完成

00:26:40.040 --> 00:26:47.240
再次享受我的行动

00:26:45.140 --> 00:26:49.040
从单线程执行或

00:26:47.240 --> 00:26:54.410
我的两个动作都可以在

00:26:49.040 --> 00:26:58.160
不同，这是一个问题，所以为什么我们

00:26:54.410 --> 00:27:00.440
有这样的行为在哪里

00:26:58.160 --> 00:27:02.450
现实中我们知道的所有计算机方法

00:27:00.440 --> 00:27:05.840
未来有几种形式，然后适用

00:27:02.450 --> 00:27:07.520
然后采用相应的方法

00:27:05.840 --> 00:27:12.230
在查询中，我们可以指定特定

00:27:07.520 --> 00:27:16.670
我们想成为我们行动的执行者

00:27:12.230 --> 00:27:20.500
为了执行我们为什么绝对需要

00:27:16.670 --> 00:27:22.760
并获得SATA的答案并尝试

00:27:20.500 --> 00:27:25.220
建议比较性能

00:27:22.760 --> 00:27:29.660
我有两个简单的链

00:27:25.220 --> 00:27:32.090
动作不多，一个链条是

00:27:29.660 --> 00:27:34.910
然后应用它意味着我们不

00:27:32.090 --> 00:27:37.160
有额外的提交给执行者

00:27:34.910 --> 00:27:38.610
每次和供应中的知识

00:27:37.160 --> 00:27:42.070
同步处理

00:27:38.610 --> 00:27:44.650
动作拉链分别提交给

00:27:42.070 --> 00:27:47.020
在这里执行表演

00:27:44.650 --> 00:27:49.600
因为数字差异很大

00:27:47.020 --> 00:27:51.640
仅显示的相对差异

00:27:49.600 --> 00:27:56.380
小任务，所以差异很大

00:27:51.640 --> 00:27:58.930
对于大型任务可见，也许不

00:27:56.380 --> 00:28:01.930
对于我们的过渡很重要，但再次

00:27:58.930 --> 00:28:03.940
直到我们的系统

00:28:01.930 --> 00:28:06.850
当他们有很多饱和

00:28:03.940 --> 00:28:11.920
线程之间的差异

00:28:06.850 --> 00:28:14.440
单线链和马丁吉他

00:28:11.920 --> 00:28:16.450
链条可能会有所不同，因此

00:28:14.440 --> 00:28:19.870
结论很简单，我们必须形成

00:28:16.450 --> 00:28:23.500
方法n Samson Samson我认为有两个

00:28:19.870 --> 00:28:27.210
接收器可预测的原因

00:28:23.500 --> 00:28:31.150
有控制方式来执行您的代码

00:28:27.210 --> 00:28:34.780
但随后有一些表现方式

00:28:31.150 --> 00:28:37.150
不回去”，也只是

00:28:34.780 --> 00:28:39.900
相同的过渡或执行

00:28:37.150 --> 00:28:39.900
一个线程到另一个

00:28:40.020 --> 00:28:46.240
为什么我们需要可预测性

00:28:43.120 --> 00:28:49.900
简单的例子，特别是来自

00:28:46.240 --> 00:28:51.850
与我们的HTTP客户端相同的方式

00:28:49.900 --> 00:28:54.960
准备好一个辅助助手

00:28:51.850 --> 00:28:59.350
它叫做选择器管理器

00:28:54.960 --> 00:29:02.230
真的在新选择器上睡觉

00:28:59.350 --> 00:29:04.930
通知从网络读取数据并

00:29:02.230 --> 00:29:09.550
将数据分发给特定的接收者

00:29:04.930 --> 00:29:12.970
非常简单，知道它如何在

00:29:09.550 --> 00:29:16.900
情况，我们有未来，我们有

00:29:12.970 --> 00:29:19.750
动作集动作foo是动作

00:29:16.900 --> 00:29:22.330
改变我们内心的未来

00:29:19.750 --> 00:29:24.910
遗嘱执行人彻底的内部行动，但

00:29:22.330 --> 00:29:28.390
之后，我们将未来归还给用户

00:29:24.910 --> 00:29:30.640
用户可以附加任何种类的

00:29:28.390 --> 00:29:34.120
混淆其思想的行动

00:29:30.640 --> 00:29:36.670
完成了连锁行动的未来，所以我们

00:29:34.120 --> 00:29:39.760
有一系列的行动，如果你在做

00:29:36.670 --> 00:29:42.550
从选择器完成是什么

00:29:39.760 --> 00:29:44.560
意味着我们可以领导行动

00:29:42.550 --> 00:29:48.160
 foo和bar从该特定位置执行

00:29:44.560 --> 00:29:51.640
选择器经理为什么我们不应该做

00:29:48.160 --> 00:29:52.210
因为你不知道多少

00:29:51.640 --> 00:29:54.730
时间

00:29:52.210 --> 00:29:57.220
 Foom好的，您可能了解Excel 

00:29:54.730 --> 00:29:58.930
傻瓜，你可以衡量，你可以做到

00:29:57.220 --> 00:30:02.800
你可以写，但你不知道

00:29:58.930 --> 00:30:05.320
关于动作栏的任何事情，它都可以

00:30:02.800 --> 00:30:07.540
对您来说是任何一种dos攻击

00:30:05.320 --> 00:30:10.690
系统我们有一个非常重要的

00:30:07.540 --> 00:30:11.620
阅读重要的哔声，您会做很多事情

00:30:10.690 --> 00:30:13.630
在这里行动

00:30:11.620 --> 00:30:16.120
没错，不会读取任何内容

00:30:13.630 --> 00:30:18.790
网络调度作为请求和全部

00:30:16.120 --> 00:30:21.400
活动停止了，所以你不能那样做

00:30:18.790 --> 00:30:24.520
您需要可预测性，应该避免

00:30:21.400 --> 00:30:27.310
这样的教育，我们只是

00:30:24.520 --> 00:30:30.180
不能从执行者那里读到使他们

00:30:27.310 --> 00:30:33.190
作一些动作，这是一个使

00:30:30.180 --> 00:30:35.260
我们行动的完成发生了什么

00:30:33.190 --> 00:30:38.290
哦，有几种方法可以解决这个问题

00:30:35.260 --> 00:30:40.840
问题首先在Java九中

00:30:38.290 --> 00:30:44.860
 Java 8中缺少的新方法

00:30:40.840 --> 00:30:46.900
我认为这意味着完成

00:30:44.860 --> 00:30:49.750
我们将不会执行任何事情

00:30:46.900 --> 00:30:51.640
潜在的选择器菜单将完成

00:30:49.750 --> 00:30:56.290
直接执行给我们

00:30:51.640 --> 00:31:00.940
执行者很好的解决方法

00:30:56.290 --> 00:31:03.820
问题和Chara八我们

00:31:00.940 --> 00:31:06.460
在这里完成，但是我们知道

00:31:03.820 --> 00:31:11.800
使用我们保护的设计撰写同步

00:31:06.460 --> 00:31:14.500
我们的精选经理人很好

00:31:11.800 --> 00:31:17.020
现在可以正常工作了

00:31:14.500 --> 00:31:20.860
解决方案，但这会导致成本增加

00:31:17.020 --> 00:31:24.790
如果我们已经有例如

00:31:20.860 --> 00:31:26.500
完成融合使他们组成了我们

00:31:24.790 --> 00:31:28.810
使他们组成同步，我们

00:31:26.500 --> 00:31:30.700
是由一位执行人说的

00:31:28.810 --> 00:31:33.100
有同样的问题，我们非常

00:31:30.700 --> 00:31:35.950
经常从

00:31:33.100 --> 00:31:39.160
一个在剧院和可爱的陷阱

00:31:35.950 --> 00:31:43.120
那是无用的活动，也许我们

00:31:39.160 --> 00:31:47.170
可以以某种方式组合起来，这很简单

00:31:43.120 --> 00:31:48.610
让我们检查一下，如果我们的未来完成了

00:31:47.170 --> 00:31:53.740
还是以前没做过

00:31:48.610 --> 00:31:55.810
如果我们的未来完成了，那就去做

00:31:53.740 --> 00:31:58.090
坎波斯，在这种情况下将被处决

00:31:55.810 --> 00:32:01.630
直接在同一点的最高点

00:31:58.090 --> 00:32:04.980
线程，如果我们的未来没有任何问题

00:32:01.630 --> 00:32:08.070
还没有完成还可以

00:32:04.980 --> 00:32:11.070
说我们是否必须进入执行者

00:32:08.070 --> 00:32:14.490
并提供以下保护

00:32:11.070 --> 00:32:19.080
带有同步选项的身份功能

00:32:14.490 --> 00:32:20.730
在执行器和那棵树中移动它

00:32:19.080 --> 00:32:24.720
不能提示那棵树是一棵树

00:32:20.730 --> 00:32:30.740
但这给了我们百分之十六

00:32:24.720 --> 00:32:33.690
我们的HTTP客户端的执行时间是

00:32:30.740 --> 00:32:36.960
这只是一个不错的结果

00:32:33.690 --> 00:32:39.630
改变只是写三行

00:32:36.960 --> 00:32:45.870
的代码，以获得十六个真正发送给您的代码

00:32:39.630 --> 00:32:48.179
可以做到，而我知道另一个技巧

00:32:45.870 --> 00:32:51.770
我们有以下行动链

00:32:48.179 --> 00:32:55.380
像金这样的完整融合

00:32:51.770 --> 00:32:58.220
内科护理方法

00:32:55.380 --> 00:33:01.200
从用户开始调用AIESEC并

00:32:58.220 --> 00:33:03.470
我们期望它将使所有

00:33:01.200 --> 00:33:04.760
细节回报即将完成的未来

00:33:03.470 --> 00:33:08.150
立即

00:33:04.760 --> 00:33:12.480
我们的API，因为它应该基本上

00:33:08.150 --> 00:33:14.610
在实践中它意识到我检查了我

00:33:12.480 --> 00:33:18.720
做一些测量，意识到

00:33:14.610 --> 00:33:21.690
在极少数情况下，只有3％的请求

00:33:18.720 --> 00:33:24.390
但是在3％的请求中

00:33:21.690 --> 00:33:26.160
通过了我们最后的动作

00:33:24.390 --> 00:33:29.750
已经有一个完整的未来，因为

00:33:26.160 --> 00:33:33.330
服务器响应我们，我们得到了结果

00:33:29.750 --> 00:33:36.650
但是我们必须做一些其他的事情

00:33:33.330 --> 00:33:41.340
结果和过程像但变坏了

00:33:36.650 --> 00:33:44.940
等等等等，如果我们有这样的连锁店，我们

00:33:41.340 --> 00:33:48.330
已经完成了未来，这意味着

00:33:44.940 --> 00:33:49.830
那最后一条链条的尾巴

00:33:48.330 --> 00:33:53.490
动作将由用户执行

00:33:49.830 --> 00:33:56.850
线程，我们转移，但我们想要

00:33:53.490 --> 00:34:02.940
一切转移到执行者的力量

00:33:56.850 --> 00:34:07.200
不要从用户那里做，我们可以使用

00:34:02.940 --> 00:34:08.940
然后按照我告诉你的方式思考

00:34:07.200 --> 00:34:11.639
线程将受到保护，我们不会

00:34:08.940 --> 00:34:12.629
做某事，但还是一样

00:34:11.639 --> 00:34:14.899
站

00:34:12.629 --> 00:34:18.140
当我们不想的时候不必要的切换

00:34:14.899 --> 00:34:20.270
如何解决这个问题

00:34:18.140 --> 00:34:24.080
简单的想法，让我们做

00:34:20.270 --> 00:34:27.860
执行只是使一个完整的球

00:34:24.080 --> 00:34:30.290
不完整的期货开始使

00:34:27.860 --> 00:34:32.600
我们完整的整个食物链

00:34:30.290 --> 00:34:35.570
融合了我们完整的行动链

00:34:32.600 --> 00:34:38.080
需要做的，只有我们的下巴

00:34:35.570 --> 00:34:40.760
准备触发提示球

00:34:38.080 --> 00:34:43.190
将此事发送完整

00:34:40.760 --> 00:34:45.560
提供中间声音真的没有

00:34:43.190 --> 00:34:49.100
足以触发

00:34:45.560 --> 00:34:51.550
扩散整个链并延迟

00:34:49.100 --> 00:35:00.380
开始给我们一些实际的例子

00:34:51.550 --> 00:35:02.830
再加上10％的两个同步请求

00:35:00.380 --> 00:35:02.830
问题

00:35:08.720 --> 00:35:13.430
这很简单我有很多我没有

00:35:11.089 --> 00:35:16.400
需要结果，所以我可以做一个

00:35:13.430 --> 00:35:18.740
可计算的未来空缺完整

00:35:16.400 --> 00:35:20.210
融合避免什么是完整的

00:35:18.740 --> 00:35:21.799
完全稳定之间的差异

00:35:20.210 --> 00:35:31.010
木材的未来和可替代的未来

00:35:21.799 --> 00:35:32.960
谁能猜出多少个州的布尔值

00:35:31.010 --> 00:35:37.839
发生可完成的未来布尔值和

00:35:32.960 --> 00:35:37.839
完全没有未来

00:35:39.250 --> 00:35:43.970
为了布尔的完整未来

00:35:42.109 --> 00:35:47.450
国家通常会完成这件事

00:35:43.970 --> 00:35:51.339
完全正常使用错误不完全和

00:35:47.450 --> 00:35:55.099
完成我有空的例外

00:35:51.339 --> 00:35:57.440
少欠我不完整的债务

00:35:55.099 --> 00:35:59.780
由于我而异常而完整

00:35:57.440 --> 00:36:02.510
没有其他任何值

00:35:59.780 --> 00:36:06.280
那不行，但我只想完成

00:36:02.510 --> 00:36:10.970
或未来的需求不完整，请在这里

00:36:06.280 --> 00:36:14.630
可以在这里使用任何类型但无效

00:36:10.970 --> 00:36:17.630
足够小，最后一个和' 

00:36:14.630 --> 00:36:19.730
 lyin'我只是触发执行

00:36:17.630 --> 00:36:23.240
因为我完成了我的未来， 

00:36:19.730 --> 00:36:25.309
在那之前我已经开始运行了

00:36:23.240 --> 00:36:29.500
链受到保护，因为

00:36:25.309 --> 00:36:33.589
最重要的未来我想被执行

00:36:29.500 --> 00:36:38.109
只是建筑链，而只是

00:36:33.589 --> 00:36:46.819
简单简单的把戏给了我百分之十

00:36:38.109 --> 00:36:51.890
真实的HTTP请求示例是是

00:36:46.819 --> 00:36:53.960
因为所有我同步的KD 

00:36:51.890 --> 00:36:55.250
要求完成紫红色

00:36:53.960 --> 00:36:58.609
关于可完成的未来

00:36:55.250 --> 00:37:01.490
关于线程，线程是我们的

00:36:58.609 --> 00:37:05.029
关键资源，我们不需要很多

00:37:01.490 --> 00:37:08.170
线程，我们不需要几个月

00:37:05.029 --> 00:37:10.760
我们通常需要适量的压力

00:37:08.170 --> 00:37:13.520
可以与这个课程相当

00:37:10.760 --> 00:37:17.740
我们的机器或其他方式受

00:37:13.520 --> 00:37:20.690
我们的环境，我们必须避免

00:37:17.740 --> 00:37:22.100
我们必须避免不必要的压力

00:37:20.690 --> 00:37:24.170
无效量

00:37:22.100 --> 00:37:25.640
而且我们必须避免不必要的

00:37:24.170 --> 00:37:28.760
从一台服务器过渡到另一台服务器

00:37:25.640 --> 00:37:30.860
就这样，如果我们延迟启动

00:37:28.760 --> 00:37:33.200
通常如果车轮只是为了

00:37:30.860 --> 00:37:36.080
我们更好地了解我的行为

00:37:33.200 --> 00:37:41.360
将被执行以避免各种

00:37:36.080 --> 00:37:43.610
比赛，然后选择最后一个

00:37:41.360 --> 00:37:46.490
我想告诉你的把戏不是

00:37:43.610 --> 00:37:50.480
与完成鱼本身有关，但

00:37:46.490 --> 00:37:53.090
我告诉我，我不能将其隐藏

00:37:50.480 --> 00:37:57.440
我们船舶计划的默认执行人

00:37:53.090 --> 00:38:05.330
缓存在游泳池是一个非常好的

00:37:57.440 --> 00:38:07.730
选择为什么没有全部解决办法

00:38:05.330 --> 00:38:11.390
做了很多执行却没有增长

00:38:07.730 --> 00:38:12.310
超过100个阶层

00:38:11.390 --> 00:38:14.660
我在做

00:38:12.310 --> 00:38:18.740
当然除了用户动作

00:38:14.660 --> 00:38:22.580
可以阻止，但这是您提交的

00:38:18.740 --> 00:38:27.020
行动，但问题是，因为我

00:38:22.580 --> 00:38:32.090
告诉我这不是最好的阅读

00:38:27.020 --> 00:38:35.270
我没有HTTP请求的最佳执行程序

00:38:32.090 --> 00:38:38.660
尝试做一些不道德的事

00:38:35.270 --> 00:38:42.380
我只是做了实际的评估，因为

00:38:38.660 --> 00:38:45.530
我有一个基准，我可能会有所不同

00:38:42.380 --> 00:38:48.110
执行者并检查其工作方式以及

00:38:45.530 --> 00:38:50.300
特定的HTTP协议修复

00:38:48.110 --> 00:38:55.250
仅用2个三点报告可爱

00:38:50.300 --> 00:38:57.710
最近，max给我最好的结果

00:38:55.250 --> 00:39:00.020
我很容易解释一下，因为

00:38:57.710 --> 00:39:02.270
我知道船是如何运作的

00:39:00.020 --> 00:39:04.220
仅限写互联网或给我打电话

00:39:02.270 --> 00:39:07.100
因为它是其中的顺序部分

00:39:04.220 --> 00:39:08.750
几乎不让它瘫痪

00:39:07.100 --> 00:39:10.430
编码，因为单元格编码也

00:39:08.750 --> 00:39:12.530
很难瘫痪，这就是为什么我要强调

00:39:10.430 --> 00:39:17.180
足以获得最快的速度

00:39:12.530 --> 00:39:19.760
但是未来的正确工具可以

00:39:17.180 --> 00:39:22.700
我想给你带来很大的不同

00:39:19.760 --> 00:39:29.860
初期您应该检查一下

00:39:22.700 --> 00:39:31.420
应用还可以一点结论

00:39:29.860 --> 00:39:34.390
我们在谈论可完成的巨大

00:39:31.420 --> 00:39:36.970
表演，我肯定会问大家

00:39:34.390 --> 00:39:40.020
问题出在哪里

00:39:36.970 --> 00:39:44.110
或不喜欢不完整的未来

00:39:40.020 --> 00:39:45.720
我要抱怨的事

00:39:44.110 --> 00:39:48.070
很多很多次

00:39:45.720 --> 00:39:51.550
每个人都告诉我

00:39:48.070 --> 00:39:53.470
未来有特定的完成阶段

00:39:51.550 --> 00:39:55.840
作为可计算的关键接口

00:39:53.470 --> 00:39:59.860
有一个非常困难的阶段

00:39:55.840 --> 00:40:03.400
难以记住的方法，我们有四种

00:39:59.860 --> 00:40:05.680
剩下的几分钟，我希望能在最后几分钟

00:40:03.400 --> 00:40:08.050
就是说我会告诉你如何加速

00:40:05.680 --> 00:40:13.500
不是可计算的未来，而是Java 

00:40:08.050 --> 00:40:20.460
开发人员可以完成的阶段

00:40:13.500 --> 00:40:23.730
恰好有38种方法，而这38种方法中有36种

00:40:20.460 --> 00:40:26.800
这是三种形式的重复方法

00:40:23.730 --> 00:40:30.610
与显式同步

00:40:26.800 --> 00:40:33.630
执行器没有它的异步

00:40:30.610 --> 00:40:36.430
最后的执行者，总和让我们检查一下

00:40:33.630 --> 00:40:40.030
参孙，我认为这意味着

00:40:36.430 --> 00:40:42.160
我们应该在此处提交的操作

00:40:40.030 --> 00:40:44.890
被给予，调用将是

00:40:42.160 --> 00:40:48.670
传递给那个烈性人执行

00:40:44.890 --> 00:40:50.380
行动所有后续更改其显示

00:40:48.670 --> 00:40:51.660
一个例子，对于

00:40:50.380 --> 00:40:54.520
可预测性

00:40:51.660 --> 00:40:56.440
第二种方法与

00:40:54.520 --> 00:41:02.410
在我们使用派生联接之前

00:40:56.440 --> 00:41:04.690
作为执行人的池意味着NASA和

00:41:02.410 --> 00:41:06.400
简短的方法意味着如果将来

00:41:04.690 --> 00:41:08.650
完成后，我们将在

00:41:06.400 --> 00:41:11.920
如果不完整的地方将是

00:41:08.650 --> 00:41:14.140
从其他情况稀释

00:41:11.920 --> 00:41:18.580
更加困难的组合

00:41:14.140 --> 00:41:21.550
前36种方法有三种形式

00:41:18.580 --> 00:41:24.550
表示我们只有12种方法

00:41:21.550 --> 00:41:27.100
了解现在的交易

00:41:24.550 --> 00:41:30.550
从这12种方法中可以分开

00:41:27.100 --> 00:41:32.980
三种形式适用，但陷阱也适用

00:41:30.550 --> 00:41:35.860
他们完全相似

00:41:32.980 --> 00:41:38.350
行为差异是极地适用

00:41:35.860 --> 00:41:41.170
正在从以前的未来取得成果

00:41:38.350 --> 00:41:43.540
我认为接下来的新结果

00:41:41.170 --> 00:41:46.180
未来接受只是得到

00:41:43.540 --> 00:41:49.180
未来给予它的结果

00:41:46.180 --> 00:41:50.980
消费者再也没有结果

00:41:49.180 --> 00:41:53.080
可计算的未来的类型为

00:41:50.980 --> 00:41:55.360
向我们表明执行已完成

00:41:53.080 --> 00:41:56.920
那可完成的未来何时完成

00:41:55.360 --> 00:42:01.060
这意味着我们的场合已经结束

00:41:56.920 --> 00:42:03.820
再跑一次，我们没有任何结果

00:42:01.060 --> 00:42:05.110
你不支持以前的执行

00:42:03.820 --> 00:42:06.730
我们没有提供任何结果

00:42:05.110 --> 00:42:10.210
问题的后续变化我们

00:42:06.730 --> 00:42:13.420
只需执行可运行，这九个

00:42:10.210 --> 00:42:15.850
方法非常简单，所以我们有一个

00:42:13.420 --> 00:42:19.240
简单同意即适用并接受

00:42:15.850 --> 00:42:22.450
周围我们有一个二进制或可操作的

00:42:19.240 --> 00:42:25.900
在二进制和操作中，当我们拥有它

00:42:22.450 --> 00:42:28.270
或我们在伊希斯（Isis） 

00:42:25.900 --> 00:42:30.880
在阿里扎港，此输入已准备就绪

00:42:28.270 --> 00:42:32.590
二进制和常规操作

00:42:30.880 --> 00:42:35.230
等待老板结果准备好

00:42:32.590 --> 00:42:37.930
我们这两个九很简单

00:42:35.230 --> 00:42:41.020
我们有三米的方法

00:42:37.930 --> 00:42:43.720
探索意味着方法和

00:42:41.020 --> 00:42:46.780
再一次，你应该忘记所有的事情

00:42:43.720 --> 00:42:50.320
在没有任何新签证的半外国人之前

00:42:46.780 --> 00:42:52.660
下沉，我认为我们有另一个版本

00:42:50.320 --> 00:42:55.930
拉米雷斯然后坎波斯处理的方法

00:42:52.660 --> 00:42:58.680
完成后，我已经告诉过您

00:42:55.930 --> 00:43:01.210
一点点和坎波斯，你可以

00:42:58.680 --> 00:43:04.570
读一些有关

00:43:01.210 --> 00:43:08.860
知道该怎么办

00:43:04.570 --> 00:43:11.710
周围有很多有趣的博客

00:43:08.860 --> 00:43:15.940
这些东西可能我必须添加链接

00:43:11.710 --> 00:43:17.920
我可能稍后再处理

00:43:15.940 --> 00:43:20.530
这是一种方法，不仅我们

00:43:17.920 --> 00:43:22.060
通常完成的未来，但对我来说

00:43:20.530 --> 00:43:26.020
非常完整的描述，我们

00:43:22.060 --> 00:43:28.090
只是采取结果或例外

00:43:26.020 --> 00:43:32.380
一对参数将其传递给函数

00:43:28.090 --> 00:43:35.680
并提供新结果以及何时

00:43:32.380 --> 00:43:38.050
完成与处理相同

00:43:35.680 --> 00:43:40.900
接受我们正在使用的手柄版本

00:43:38.050 --> 00:43:43.300
结果如此异常，但事实并非如此

00:43:40.900 --> 00:43:45.130
哪个结果将提供

00:43:43.300 --> 00:43:50.740
男性完成的结果将是

00:43:45.130 --> 00:43:55.010
和所有雇主一样的地区

00:43:50.740 --> 00:43:57.680
有2个没有的Menno 

00:43:55.010 --> 00:44:00.790
下沉形式异常

00:43:57.680 --> 00:44:02.960
允许异常转换

00:44:00.790 --> 00:44:05.420
完成，将来正常完成

00:44:02.960 --> 00:44:08.540
未来的一些结果和方法

00:44:05.420 --> 00:44:11.630
转换完成状态以完成我的

00:44:08.540 --> 00:44:13.700
从我的角度来看，这就是全部

00:44:11.630 --> 00:44:16.430
记住所有内容并不难

00:44:13.700 --> 00:44:18.680
从完成阶段到工作的方法

00:44:16.430 --> 00:44:22.880
结果还好

00:44:18.680 --> 00:44:25.540
我没时间了，你呢

00:44:22.880 --> 00:44:25.540
有任何疑问

00:44:28.980 --> 00:44:35.760
 [掌声] 

