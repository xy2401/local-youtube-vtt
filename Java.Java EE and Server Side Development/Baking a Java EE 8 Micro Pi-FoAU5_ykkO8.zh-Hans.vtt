WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.580 --> 00:00:07.810
好吧，看看这个，让我们有一个

00:00:06.080 --> 00:00:11.950
跟着我们所拥有的

00:00:07.810 --> 00:00:16.760
所以这将是一个相当繁重的演示

00:00:11.950 --> 00:00:18.980
演讲很幸运，我实际上

00:00:16.760 --> 00:00:21.800
从演示中获得了一些代码片段

00:00:18.980 --> 00:00:23.720
幻灯片，希望我们应该

00:00:21.800 --> 00:00:29.029
至少可以谈论那种

00:00:23.720 --> 00:00:30.589
我要做的事情，如果我们

00:00:29.029 --> 00:00:32.780
以后可以切换到我的笔记本电脑

00:00:30.589 --> 00:00:41.899
然后我们会，但是如果不能，那么我们会

00:00:32.780 --> 00:00:44.780
我们会尽力而为，所以我叫迈克

00:00:41.899 --> 00:00:47.989
都在那里的支持团队工作

00:00:44.780 --> 00:00:51.500
这个演讲的标题是烘烤Java EE 8 

00:00:47.989 --> 00:00:54.230
微型PI，必须更改

00:00:51.500 --> 00:00:55.429
一点点由于

00:00:54.230 --> 00:00:56.480
完全不同的硬件问题

00:00:55.429 --> 00:01:00.140
在我们到达这里之前

00:00:56.480 --> 00:01:03.170
因此，对于硬件来说，这不是很多好话

00:01:00.140 --> 00:01:06.890
 gremlins虽然影响这是什么

00:01:03.170 --> 00:01:10.400
关于将Java e8和Java放入

00:01:06.890 --> 00:01:12.920
一般而言，因此请参阅

00:01:10.400 --> 00:01:14.960
 Java 8刚刚发布了

00:01:12.920 --> 00:01:16.159
与Java 1进行大量讨论

00:01:14.960 --> 00:01:17.630
将进入所有规格

00:01:16.159 --> 00:01:20.570
会告诉大家他们如何

00:01:17.630 --> 00:01:23.270
工作，尽管我们会继续

00:01:20.570 --> 00:01:24.350
那不是

00:01:23.270 --> 00:01:26.720
这是我最核心的话题

00:01:24.350 --> 00:01:31.159
想要在这里做的就是写一点

00:01:26.720 --> 00:01:34.549
的上下文向您展示了Java 8在哪里

00:01:31.159 --> 00:01:36.890
现在是它去过的地方以及如何

00:01:34.549 --> 00:01:42.530
与我们所处的世界有关

00:01:36.890 --> 00:01:46.520
目前是的，所以让我们开始吧

00:01:42.530 --> 00:01:49.520
关于我和安德烈的一些事，所以我

00:01:46.520 --> 00:01:50.840
我的支持团队成员的一部分

00:01:49.520 --> 00:01:54.610
如果你想跟我推特

00:01:50.840 --> 00:01:57.710
和滑雪板，这是我的证明

00:01:54.610 --> 00:01:59.570
那是我的真实照片，但是

00:01:57.710 --> 00:02:02.750
它看起来比

00:01:59.570 --> 00:02:05.450
他实际上是安德烈（Andre） 

00:02:02.750 --> 00:02:07.219
支持那是他在Twitter上，他是一个

00:02:05.450 --> 00:02:09.530
爸爸，显然没有太多时间

00:02:07.219 --> 00:02:12.270
对于任何真正令人兴奋的事情

00:02:09.530 --> 00:02:18.250
因为那件事发生了

00:02:12.270 --> 00:02:19.990
那么这是怎么回事，所以关键

00:02:18.250 --> 00:02:22.480
我想谈的事情开始

00:02:19.990 --> 00:02:26.770
 Joffrey到底有多轻巧

00:02:22.480 --> 00:02:28.270
从传统上讲，乔佛里就是这样

00:02:26.770 --> 00:02:32.260
你会知道有很多很多

00:02:28.270 --> 00:02:34.240
有关其重量如何的批评

00:02:32.260 --> 00:02:38.590
 ated肿它笨重，很难

00:02:34.240 --> 00:02:40.210
与我合作我认为我是诚实的

00:02:38.590 --> 00:02:41.500
总的来说，潮流正在加剧

00:02:40.210 --> 00:02:43.840
这种意见越来越多

00:02:41.500 --> 00:02:44.860
人们在使用现代Joffrey 

00:02:43.840 --> 00:02:47.140
发现它是完全

00:02:44.860 --> 00:02:48.520
与过去不同

00:02:47.140 --> 00:02:52.660
不想过多标记这一点

00:02:48.520 --> 00:02:54.370
但只是调查是什么使

00:02:52.660 --> 00:02:58.720
它很轻便，为什么容易

00:02:54.370 --> 00:03:00.370
拿起它并与我一起运行

00:02:58.720 --> 00:03:04.060
看看杰里八世有什么

00:03:00.370 --> 00:03:08.380
今天发布了什么，什么样的

00:03:04.060 --> 00:03:10.660
可以使用的东西，所以这

00:03:08.380 --> 00:03:11.830
最后一点已经过大量修改，因此

00:03:10.660 --> 00:03:14.020
他最近才发现

00:03:11.830 --> 00:03:17.070
 Java正在迁移到Eclipse Foundation 

00:03:14.020 --> 00:03:19.510
然后宣布

00:03:17.070 --> 00:03:22.870
该项目将被命名为Eva J 

00:03:19.510 --> 00:03:24.520
 Eclipse Enterprise for Java，但随后

00:03:22.870 --> 00:03:26.860
最近也有澄清

00:03:24.520 --> 00:03:29.470
来自Eclipse的itch的Michael链接

00:03:26.860 --> 00:03:31.720
说尽管J的EE是

00:03:29.470 --> 00:03:33.340
伞项目名称不是

00:03:31.720 --> 00:03:36.850
必将成为替代品

00:03:33.340 --> 00:03:38.440
 Java EE的品牌，所以我不得不修改

00:03:36.850 --> 00:03:40.959
第三次因为我们不知道是什么

00:03:38.440 --> 00:03:43.090
我们知道它的名字

00:03:40.959 --> 00:03:48.820
可能不会是Java 

00:03:43.090 --> 00:03:51.550
 EE由于只是商标而已

00:03:48.820 --> 00:03:53.880
有很多原因

00:03:51.550 --> 00:03:57.580
对Java re的未来感到兴奋

00:03:53.880 --> 00:04:00.910
不管它变成什么，我都会讲

00:03:57.580 --> 00:04:03.040
这一点，还取决于

00:04:00.910 --> 00:04:08.320
演示如何进行，希望能得到一个

00:04:03.040 --> 00:04:11.800
有机会看一下，所以当我

00:04:08.320 --> 00:04:14.440
从最近的历史开始

00:04:11.800 --> 00:04:18.040
大约在这一次的四个

00:04:14.440 --> 00:04:22.030
几年前，我们有7个Java 

00:04:18.040 --> 00:04:23.919
 GlassFish对我来说是门的

00:04:22.030 --> 00:04:25.810
因为我不是Java人，但是我是

00:04:23.919 --> 00:04:26.770
回到办公室写博客

00:04:25.810 --> 00:04:29.250
关于它，并试图让每个人

00:04:26.770 --> 00:04:31.570
对新的Java re'7版本感到兴奋

00:04:29.250 --> 00:04:37.480
当我准备这个演讲时

00:04:31.570 --> 00:04:39.250
我在想很多

00:04:37.480 --> 00:04:40.480
我们在

00:04:39.250 --> 00:04:43.240
当下我们获得的服务

00:04:40.480 --> 00:04:44.500
可用的情况如何变化

00:04:43.240 --> 00:04:47.290
发生了很多变化

00:04:44.500 --> 00:04:50.580
最近几个月，但试图思考

00:04:47.290 --> 00:04:52.990
回到GlassFish 4第一次问世的时候

00:04:50.580 --> 00:04:55.300
其实很难，所以我去了

00:04:52.990 --> 00:04:57.180
谷歌搜索我去看看

00:04:55.300 --> 00:04:59.470
关键技术在哪里

00:04:57.180 --> 00:05:00.910
我发现她有点

00:04:59.470 --> 00:05:03.010
让我们感到惊讶的是，我们走了这么远

00:05:00.910 --> 00:05:04.419
短时间，所以第一件事是

00:05:03.010 --> 00:05:07.450
码头工人此时只有三个

00:05:04.419 --> 00:05:09.610
几个月大，所以Linux容器很明显

00:05:07.450 --> 00:05:11.770
是一件事情，人们意识到

00:05:09.610 --> 00:05:14.200
他们人们试图使用它们，但是

00:05:11.770 --> 00:05:17.740
码头工人真的很新，所以在

00:05:14.200 --> 00:05:19.330
 Java EE 7发布的时间

00:05:17.740 --> 00:05:22.870
整个你都知道勇敢的新世界

00:05:19.330 --> 00:05:24.220
集装箱，你知道运输

00:05:22.870 --> 00:05:26.350
一晚上绝对一切

00:05:24.220 --> 00:05:29.890
那年整齐漂亮

00:05:26.350 --> 00:05:31.450
运营团队不能惹你

00:05:29.890 --> 00:05:34.590
那完全超出了

00:05:31.450 --> 00:05:34.590
大多数人的头

00:05:37.490 --> 00:05:44.480
并不是真的在路线图上

00:05:40.860 --> 00:05:48.150
它是Pyro的竞争对手之一

00:05:44.480 --> 00:05:50.310
它在一个命名的前者中不存在

00:05:48.150 --> 00:05:53.210
仍然是JBoss AAS的开源

00:05:50.310 --> 00:05:53.210
 JBoss版本

00:05:58.020 --> 00:06:04.260
所以我把它放在 spring boot 之前

00:06:01.280 --> 00:06:05.930
实际上在那个日期你可以检查

00:06:04.260 --> 00:06:08.310
 github，因为那是我发现的方式

00:06:05.930 --> 00:06:09.840
有很多标签

00:06:08.310 --> 00:06:11.340
 spring boot 的预发布标签

00:06:09.840 --> 00:06:15.240
在

00:06:11.340 --> 00:06:16.830
那一点，但是我知道我没有去

00:06:15.240 --> 00:06:18.570
深入了解他们具有哪些功能

00:06:16.830 --> 00:06:21.750
到达那里，但仍然非常

00:06:18.570 --> 00:06:27.030
很早就离它很远

00:06:21.750 --> 00:06:30.380
的第一个版本的WebSphere Liberty概要文件

00:06:27.030 --> 00:06:33.630
最近发布了2013年6月

00:06:30.380 --> 00:06:36.000
其实我没多久

00:06:33.630 --> 00:06:38.790
离开了IBM，所以我曾经为IBM工作

00:06:36.000 --> 00:06:40.110
在这之前一点点，所以我有点看到

00:06:38.790 --> 00:06:42.360
一点点的背景

00:06:40.110 --> 00:06:45.930
自由被创造，那是

00:06:42.360 --> 00:06:47.550
我很感兴趣但是

00:06:45.930 --> 00:06:50.100
那时还是非常非常

00:06:47.550 --> 00:06:53.430
早期它实际上只是在实施

00:06:50.100 --> 00:06:55.680
 Java EE 6规范

00:06:53.430 --> 00:06:57.060
这与用Java进行开发还差得很远

00:06:55.680 --> 00:07:00.210
我花了相当长的时间才完成的7件事

00:06:57.060 --> 00:07:02.310
适应这些和很多功能

00:07:00.210 --> 00:07:08.600
现在在WebSphere Liberty中是

00:07:02.310 --> 00:07:10.800
不在自由概况中

00:07:08.600 --> 00:07:13.590
将此推到四年后

00:07:10.800 --> 00:07:16.530
我们现在处于Java EE 8拥有的阶段

00:07:13.590 --> 00:07:18.120
被释放，显然是在那个时候

00:07:16.530 --> 00:07:20.880
码头工人现在是主要的容器

00:07:18.120 --> 00:07:22.110
格式，所以它完全消失了

00:07:20.880 --> 00:07:24.090
崭新的，很多人

00:07:22.110 --> 00:07:25.500
对此持怀疑态度的人已经过去了

00:07:24.090 --> 00:07:28.500
通过传统的炒作曲线知道

00:07:25.500 --> 00:07:31.380
而且说实话并不是真的

00:07:28.500 --> 00:07:35.150
幻灭的巨大低谷

00:07:31.380 --> 00:07:39.000
大多数事情，但是当你看着

00:07:35.150 --> 00:07:40.920
像核心OS这样的docker的竞争对手

00:07:39.000 --> 00:07:43.080
做了他们自己的容器格式，即使他们

00:07:40.920 --> 00:07:46.500
他们的引擎将支持Dockers 

00:07:43.080 --> 00:07:47.820
容器格式，因此可能仍然是

00:07:46.500 --> 00:07:52.440
早一点叫它，但它确实

00:07:47.820 --> 00:07:54.180
我的医生可能是

00:07:52.440 --> 00:07:58.110
容器格式甚至比他们大战

00:07:54.180 --> 00:07:59.730
确实开始了，但是实际上

00:07:58.110 --> 00:08:01.710
引入了相当大的变化

00:07:59.730 --> 00:08:03.720
我们一般部署事物的方式

00:08:01.710 --> 00:08:07.500
当你看着真正的关键

00:08:03.720 --> 00:08:09.490
云计算技术

00:08:07.500 --> 00:08:10.990
马上我们有了kubernetes 

00:08:09.490 --> 00:08:13.599
尴尬很热，还有很多其他事情

00:08:10.990 --> 00:08:16.509
真正存在是因为

00:08:13.599 --> 00:08:19.000
码头工人做了什么，为什么我加入了一个

00:08:16.509 --> 00:08:21.340
非Java技术还有一段时间

00:08:19.000 --> 00:08:23.319
第一次飞行已成为一种飞行

00:08:21.340 --> 00:08:26.639
他们把我完全放下

00:08:23.319 --> 00:08:30.789
蜂拥而至的群体

00:08:26.639 --> 00:08:32.399
可组合的作业EE应用程序服务器

00:08:30.789 --> 00:08:35.729
如果您还没使用过它

00:08:32.399 --> 00:08:37.959
定义群中的分数是

00:08:35.729 --> 00:08:39.760
很小的一种组件可能是

00:08:37.959 --> 00:08:41.979
就像jax-rs上的CD一样，什么也没有

00:08:39.760 --> 00:08:45.690
否则他们有一个麦克风文件

00:08:41.979 --> 00:08:48.760
我也没有说他们已经

00:08:45.690 --> 00:08:51.910
发布它是因为我不确定

00:08:48.760 --> 00:08:53.560
他们是否愿意支持以了解

00:08:51.910 --> 00:08:59.860
野外飞行是他们不支持的你

00:08:53.560 --> 00:09:01.149
知道创新流现在已经变成了

00:08:59.860 --> 00:09:03.130
正确的产品记住它什么时候第一次

00:09:01.149 --> 00:09:04.390
出来的确对我来说确实如此， 

00:09:03.130 --> 00:09:07.540
可能对很多其他人来说

00:09:04.390 --> 00:09:09.940
作为一个业余项目，这是相当

00:09:07.540 --> 00:09:12.100
它工作时很好，很容易

00:09:09.940 --> 00:09:14.980
弄错了，打破了，很难

00:09:12.100 --> 00:09:16.870
找出破裂的地方，但相当

00:09:14.980 --> 00:09:18.399
红帽很快投入了很多心血

00:09:16.870 --> 00:09:21.870
变成一个真正的

00:09:18.399 --> 00:09:25.089
好的产品，对我们来说比较好

00:09:21.870 --> 00:09:26.920
从你的 spring boot 一直

00:09:25.089 --> 00:09:29.560
他们的罐子不是足够长

00:09:26.920 --> 00:09:31.029
我现在待了好几年

00:09:29.560 --> 00:09:33.630
认为真正关键的是

00:09:31.029 --> 00:09:36.690
他们真的是那些

00:09:33.630 --> 00:09:40.329
开始当前的胖子罐

00:09:36.690 --> 00:09:42.399
运动，如果你喜欢，那真的

00:09:40.329 --> 00:09:44.050
我认为主要是流行还是关键

00:09:42.399 --> 00:09:47.200
我看到的好处是你保留了所有

00:09:44.050 --> 00:09:50.350
一个华夫饼中的配置

00:09:47.200 --> 00:09:53.170
在一个可分配范围内，而不是

00:09:50.350 --> 00:09:54.790
拥有您可以的应用程序

00:09:53.170 --> 00:09:56.410
部署到应用服务器，然后

00:09:54.790 --> 00:09:57.850
它不会运行，因为您还需要

00:09:56.410 --> 00:10:00.130
在中获取一些配置

00:09:57.850 --> 00:10:01.329
非发行的应用程序服务器

00:10:00.130 --> 00:10:04.950
耳语的引导，因为这只是

00:10:01.329 --> 00:10:04.950
打包在一起很好

00:10:04.990 --> 00:10:12.459
 IBM一个开放的开放Liberty所有人

00:10:09.190 --> 00:10:15.520
注意到这是最近发生的，如果

00:10:12.459 --> 00:10:17.020
你不是我BM显然有一个

00:10:15.520 --> 00:10:19.089
您可以在展览中心的摊位

00:10:17.020 --> 00:10:20.709
去了解一下，我知道很多

00:10:19.089 --> 00:10:21.400
那里的家伙很想聊天

00:10:20.709 --> 00:10:26.060
关于那个

00:10:21.400 --> 00:10:28.040
所以开放的自由是记得什么时候

00:10:26.060 --> 00:10:29.600
网络自由是最主要的

00:10:28.040 --> 00:10:32.750
他们说我认为大约40％ 

00:10:29.600 --> 00:10:34.700
服务器是开源的，所以他们已经

00:10:32.750 --> 00:10:36.860
开源更多的服务器

00:10:34.700 --> 00:10:38.900
它不是WebSphere Liberty的全部

00:10:36.860 --> 00:10:41.690
所以一些遗漏的东西

00:10:38.900 --> 00:10:43.760
例如管理控制台

00:10:41.690 --> 00:10:46.190
他们没有公开

00:10:43.760 --> 00:10:48.200
源代码版本，但是里面有

00:10:46.190 --> 00:10:50.990
所有Java EE规范和

00:10:48.200 --> 00:10:54.350
所有微轮廓规范

00:10:50.990 --> 00:10:56.510
他们已经推出，所以作为开发人员

00:10:54.350 --> 00:10:59.270
谁想要编写运行应用程序

00:10:56.510 --> 00:11:02.060
一台服务器，只想运行一些东西

00:10:59.270 --> 00:11:06.860
真的很棒

00:11:02.060 --> 00:11:09.950
现在选择，当然就是我们

00:11:06.860 --> 00:11:12.890
显然我们四年前不存在

00:11:09.950 --> 00:11:15.430
但是从那以后我们就看到了GlassFish 

00:11:12.890 --> 00:11:18.140
不再受到商业支持

00:11:15.430 --> 00:11:20.030
 payara带来了海盗服务器，并且

00:11:18.140 --> 00:11:23.720
我们还介绍了PI micro 

00:11:20.030 --> 00:11:26.750
我们将在今天最后讨论

00:11:23.720 --> 00:11:29.060
我们有Eclipse微型配置文件

00:11:26.750 --> 00:11:33.110
看到没有听说过的举手

00:11:29.060 --> 00:11:35.570
微型个人资料好，所以有些人没有

00:11:33.110 --> 00:11:37.190
没关系，所以我给你一点

00:11:35.570 --> 00:11:41.450
关于什么微资料的背景

00:11:37.190 --> 00:11:44.950
其实就是这样

00:11:41.450 --> 00:11:47.770
从去年6月左右开始

00:11:44.950 --> 00:11:51.140
这实际上是

00:11:47.770 --> 00:11:56.000
红帽IBM出色的Payara 

00:11:51.140 --> 00:11:59.810
汤米部落和一些Java 

00:11:56.000 --> 00:12:04.520
伦敦爪哇等社区团体

00:11:59.810 --> 00:12:06.770
社区和巴西的Su Java 

00:12:04.520 --> 00:12:10.430
实际上，这只是一个

00:12:06.770 --> 00:12:12.860
对经常遇到的问题的回应

00:12:10.430 --> 00:12:15.530
引发Java EE创新

00:12:12.860 --> 00:12:16.250
您可能设计精通的Java EE 

00:12:15.530 --> 00:12:17.690
慢慢地

00:12:16.250 --> 00:12:19.340
它不想推进

00:12:17.690 --> 00:12:23.470
并尝试标准化某些东西

00:12:19.340 --> 00:12:25.760
才是受人尊敬的技术

00:12:23.470 --> 00:12:27.080
因为它必须向后

00:12:25.760 --> 00:12:30.490
兼容，所有这些都不同

00:12:27.080 --> 00:12:32.380
种业务要求

00:12:30.490 --> 00:12:33.970
所以因为很明显

00:12:32.380 --> 00:12:36.910
 Java EE的限制，我们不想

00:12:33.970 --> 00:12:39.010
打破所有的家伙

00:12:36.910 --> 00:12:42.370
参与了我的个人资料，我们为payara 

00:12:39.010 --> 00:12:43.930
参与了这个决定

00:12:42.370 --> 00:12:45.610
我们真正需要的是一个新地方

00:12:43.930 --> 00:12:47.350
我们可以在哪里找到新的沙箱

00:12:45.610 --> 00:12:48.880
对什么做出反应的技术

00:12:47.350 --> 00:12:51.010
实际发生在现实世界中

00:12:48.880 --> 00:12:52.540
从您那里获得一些快速反馈

00:12:51.010 --> 00:12:56.770
想要使用此功能的开发人员

00:12:52.540 --> 00:12:58.090
这类东西，然后这些API 

00:12:56.770 --> 00:13:01.860
希望以此作为一种方式

00:12:58.090 --> 00:13:05.920
推进Java EE 

00:13:01.860 --> 00:13:08.650
它显然是宣布为

00:13:05.920 --> 00:13:13.630
去年六月的倡议

00:13:08.650 --> 00:13:17.260
宣布了微伏特1.0，这真的

00:13:13.630 --> 00:13:21.970
只是基于Java EE 7的起点

00:13:17.260 --> 00:13:25.090
 api只是CDI jax-rs和JSONP 

00:13:21.970 --> 00:13:26.830
去年在JavaOne的原因

00:13:25.090 --> 00:13:28.270
只是去那些是因为我们

00:13:26.830 --> 00:13:30.490
想把它粘回去

00:13:28.270 --> 00:13:32.860
绝对的最低要求

00:13:30.490 --> 00:13:36.070
需要写一个微服务风格

00:13:32.860 --> 00:13:37.780
在当今世界的应用，所以我们

00:13:36.070 --> 00:13:40.300
接受您可能必须添加

00:13:37.780 --> 00:13:41.860
我们想要的最重要的是

00:13:40.300 --> 00:13:43.750
尽可能少地开始

00:13:41.860 --> 00:13:47.350
我们没有添加太多多余的东西

00:13:43.750 --> 00:13:49.210
我们很遗憾

00:13:47.350 --> 00:13:53.020
从那以后进步很大

00:13:49.210 --> 00:13:56.980
我们发布了1.1，我认为1.2是

00:13:53.020 --> 00:14:03.100
我已经被释放在那里了，所以

00:13:56.980 --> 00:14:04.210
我认为那里发布了1.2 

00:14:03.100 --> 00:14:05.620
仍然需要一些事

00:14:04.210 --> 00:14:08.110
我们需要绑扎好

00:14:05.620 --> 00:14:10.480
宣布它，但我们有一个API 

00:14:08.110 --> 00:14:13.900
我实际上显示的配置

00:14:10.480 --> 00:14:18.460
在这个幻灯片中，我们有一点

00:14:13.900 --> 00:14:24.490
 1.2中用于健康指标的API 

00:14:18.460 --> 00:14:27.790
检查JWT令牌传播，我

00:14:24.490 --> 00:14:28.840
想代码一切我认为那是

00:14:27.790 --> 00:14:30.610
一切都有更新

00:14:28.840 --> 00:14:31.270
以及config API 

00:14:30.610 --> 00:14:35.350
容错

00:14:31.270 --> 00:14:39.490
是的，我们有8个API错误

00:14:35.350 --> 00:14:43.060
微服务的容忍度也是如此

00:14:39.490 --> 00:14:43.699
还是sinjar v8，我不想友善

00:14:43.060 --> 00:14:46.579
的来

00:14:43.699 --> 00:14:47.929
忽略其中的所有内容

00:14:46.579 --> 00:14:53.269
有一些已经升级的东西

00:14:47.929 --> 00:14:55.100
 jax-rs现在有一个响应式客户端

00:14:53.269 --> 00:14:57.379
它只哭了好一阵子，但是

00:14:55.100 --> 00:15:00.799
没有可使用的反应式API 

00:14:57.379 --> 00:15:04.279
还有服务器发送的事件

00:15:00.799 --> 00:15:07.669
我认为已经存在的jax-rs或

00:15:04.279 --> 00:15:08.959
非Java标准化

00:15:07.669 --> 00:15:12.379
球体了很长一段时间，所以现在我们已经

00:15:08.959 --> 00:15:13.669
在jax-rs中肯定有标准

00:15:12.379 --> 00:15:16.040
我认为这实际上是其中之一

00:15:13.669 --> 00:15:18.350
真的很重要

00:15:16.040 --> 00:15:20.689
发布我知道servlet很老了

00:15:18.350 --> 00:15:25.639
技术，但现在支持80到

00:15:20.689 --> 00:15:28.730
是-如果您想的很好，那很好

00:15:25.639 --> 00:15:30.529
 h-2b-或您确实需要做的一件大事

00:15:28.730 --> 00:15:33.919
调查一下，我真的认为这是

00:15:30.529 --> 00:15:36.259
将成为主要的重大事情

00:15:33.919 --> 00:15:38.199
未来几年，尤其是

00:15:36.259 --> 00:15:40.429
带来的速度改进和

00:15:38.199 --> 00:15:42.649
默认情况下会带来安全性

00:15:40.429 --> 00:15:45.109
不能真实地运行-没有被

00:15:42.649 --> 00:15:47.959
确保我可以谈一点

00:15:45.109 --> 00:15:50.389
那晚，但我不想工作

00:15:47.959 --> 00:15:52.910
太多了

00:15:50.389 --> 00:15:54.799
我一直在验证2.0已经完成了

00:15:52.910 --> 00:15:58.160
在与相同的很多更新

00:15:54.799 --> 00:16:00.019
 JSF我什么都没有

00:15:58.160 --> 00:16:01.639
在JSF中主要涉及的个别事情

00:16:00.019 --> 00:16:03.709
我知道它现在支持WebSockets 

00:16:01.639 --> 00:16:06.499
本机的，所以您不必添加

00:16:03.709 --> 00:16:10.569
您自己的框架，例如气氛或

00:16:06.499 --> 00:16:14.269
都是本地CDI的东西-带来

00:16:10.569 --> 00:16:17.149
异步事件和JSONP带来了

00:16:14.269 --> 00:16:20.839
我认为我合并了一些小小的补充

00:16:17.149 --> 00:16:22.789
补丁和杰森指针，只是你知道

00:16:20.839 --> 00:16:27.649
关闭一些缺少的东西

00:16:22.789 --> 00:16:30.049
确实是从最初的新规格开始

00:16:27.649 --> 00:16:32.059
我们有jari安全性

00:16:30.049 --> 00:16:33.649
基于下巴选择我不知道我非常

00:16:32.059 --> 00:16:36.100
很高兴你不得不谈论一个

00:16:33.649 --> 00:16:36.100
如果你想多一点

00:16:36.230 --> 00:16:46.040
但是应该没有多少空间

00:16:38.570 --> 00:16:48.560
是的，你能听到我的意思吗

00:16:46.040 --> 00:16:50.480
具有安全性，它是一个

00:16:48.560 --> 00:16:52.750
 Java EE的关键组件以及

00:16:50.480 --> 00:16:54.560
商业应用程序，但是

00:16:52.750 --> 00:17:00.620
传统上很难设置安全性

00:16:54.560 --> 00:17:02.300
并且被划分或之间

00:17:00.620 --> 00:17:07.280
应用程序和应用程序服务器

00:17:02.300 --> 00:17:10.160
因此传统上指定用户

00:17:07.280 --> 00:17:12.440
凭据被授权，但是如何

00:17:10.160 --> 00:17:15.050
用户通过身份验证并获得

00:17:12.440 --> 00:17:16.400
角色指定服务器和

00:17:15.050 --> 00:17:20.300
应用程序仅消耗此

00:17:16.400 --> 00:17:23.210
信息指定了所需角色，但

00:17:20.300 --> 00:17:26.030
是癌症还是无法影响

00:17:23.210 --> 00:17:30.260
用户已通过身份验证和授权

00:17:26.030 --> 00:17:34.550
我认为这是一个补充

00:17:30.260 --> 00:17:36.470
 Java支持六种，仅此而已

00:17:34.550 --> 00:17:40.670
有一个规范叫做规范

00:17:36.470 --> 00:17:43.850
这提供了一种方法来插入您的

00:17:40.670 --> 00:17:47.410
应用程序的授权机制

00:17:43.850 --> 00:17:49.820
但是这个问题太多了

00:17:47.410 --> 00:17:52.370
明显的问题是很少有人

00:17:49.820 --> 00:17:54.350
知道它，因为还有其他

00:17:52.370 --> 00:17:56.570
 Java EE版本中的规范

00:17:54.350 --> 00:17:59.180
也鲜为人知，这是

00:17:56.570 --> 00:18:02.660
可能是鲜为人知的规范

00:17:59.180 --> 00:18:05.390
还有一点为什么它也不是这样

00:18:02.660 --> 00:18:08.750
被广泛采用和众所周知的是

00:18:05.390 --> 00:18:11.060
非常复杂，就像三个

00:18:08.750 --> 00:18:13.580
不同的界面，但您需要

00:18:11.060 --> 00:18:15.830
结合在一起，如果可以的话

00:18:13.580 --> 00:18:19.220
将其与新的Java安全性API进行比较

00:18:15.830 --> 00:18:21.410
就像在jb2和III型中一样

00:18:19.220 --> 00:18:24.200
只是偷看工作真的很复杂

00:18:21.410 --> 00:18:26.840
和音乐安全性API是基于

00:18:24.200 --> 00:18:29.390
在CDI上并且只有发烧

00:18:26.840 --> 00:18:32.060
您可以指定自己的轮换

00:18:29.390 --> 00:18:34.760
可插入的可插入模块

00:18:32.060 --> 00:18:36.950
您的应用程序，以便您可以考虑

00:18:34.760 --> 00:18:38.690
来自的认证和授权

00:18:36.950 --> 00:18:40.059
在您的应用程序中，而您没有

00:18:38.690 --> 00:18:42.460
不再需要

00:18:40.059 --> 00:18:44.889
取决于提供的配置

00:18:42.460 --> 00:18:51.129
应用服务器如此简单

00:18:44.889 --> 00:18:52.119
想到那里谢谢安德烈

00:18:51.129 --> 00:18:53.830
很高兴在这里有其他人

00:18:52.119 --> 00:18:57.039
知道他们在说什么

00:18:53.830 --> 00:18:59.200
一些额外的细节，我认为

00:18:57.039 --> 00:19:02.289
与我们在

00:18:59.200 --> 00:19:04.539
关于Java EE的上一张幻灯片

00:19:02.289 --> 00:19:06.849
景观已经改变，我们如何

00:19:04.539 --> 00:19:08.830
 spring boot ，我应该胡扯冰

00:19:06.849 --> 00:19:11.979
形式和馅饼或微或允许

00:19:08.830 --> 00:19:15.669
您为您的配置添加配置

00:19:11.979 --> 00:19:18.669
应用服务器进入部署

00:19:15.669 --> 00:19:20.109
工件，因此再次像Java安全性一样

00:19:18.669 --> 00:19:25.929
在某种程度上使这件事变得重要

00:19:20.109 --> 00:19:27.460
以及Jason B显然是我

00:19:25.929 --> 00:19:28.839
总是以为有危险

00:19:27.460 --> 00:19:31.419
杰森（Jason）的身材相当小

00:19:28.839 --> 00:19:33.119
我认为实际上更多

00:19:31.419 --> 00:19:35.769
比人们想象的重要

00:19:33.119 --> 00:19:38.279
当然可以在演示中使用它

00:19:35.769 --> 00:19:41.559
我希望它将融化

00:19:38.279 --> 00:19:43.809
它非常重要，我认为

00:19:41.559 --> 00:19:45.219
这是很大的帮助，很多

00:19:43.809 --> 00:19:51.369
方便注释，但它将使

00:19:45.219 --> 00:19:53.919
生活要容易得多，所以当我们

00:19:51.369 --> 00:19:56.769
演示希望我们会

00:19:53.919 --> 00:19:58.450
在micro上用柴堆运行

00:19:56.769 --> 00:20:00.309
想要造福于那些

00:19:58.450 --> 00:20:03.269
可能不知道PI或micro以及什么

00:20:00.309 --> 00:20:05.499
那是关于

00:20:03.269 --> 00:20:06.039
里面到底有什么，我们有什么

00:20:05.499 --> 00:20:12.700
用它做

00:20:06.039 --> 00:20:16.809
所以这是一个可下载的jar工件

00:20:12.700 --> 00:20:18.399
仅仅60兆字节就可以了

00:20:16.809 --> 00:20:20.499
总是趋向于大约60 

00:20:18.399 --> 00:20:23.169
兆字节有点不同

00:20:20.499 --> 00:20:25.299
从发布到发布

00:20:23.169 --> 00:20:29.710
动态可扩展，因此从本质上讲

00:20:25.299 --> 00:20:31.809
它有淡褐色，很明显淡褐色

00:20:29.710 --> 00:20:33.210
演员真的很擅长动态

00:20:31.809 --> 00:20:35.289
与其他不同的聚类

00:20:33.210 --> 00:20:38.349
环境，所以如果你站成一堆

00:20:35.289 --> 00:20:40.779
在Micro上只是Java-jar播放器

00:20:38.349 --> 00:20:42.190
可能会创建一个罐子，然后您站起来

00:20:40.779 --> 00:20:43.539
他们会自动另一个

00:20:42.190 --> 00:20:46.450
彼此发现并聚在一起

00:20:43.539 --> 00:20:48.399
您需要付出额外的努力，并且

00:20:46.450 --> 00:20:51.639
很明显，因为我们基于淡褐色

00:20:48.399 --> 00:20:53.260
种姓，我们拥有所有不同的

00:20:51.639 --> 00:20:56.290
一种榛子演员插件

00:20:53.260 --> 00:20:59.740
像AWS部署这样的事情

00:20:56.290 --> 00:21:03.429
本机发现Aveda其他实例

00:20:59.740 --> 00:21:07.240
在AWS上运行的它可以通过TCP或

00:21:03.429 --> 00:21:09.309
多播可以使用kubernetes作为

00:21:07.240 --> 00:21:12.610
你也是，我想还有其他一些

00:21:09.309 --> 00:21:15.910
以及不同的发现方法

00:21:12.610 --> 00:21:17.470
可以通过插件完全添加

00:21:15.910 --> 00:21:20.860
可嵌入的，因此您可以将其嵌入

00:21:17.470 --> 00:21:25.900
您的应用程序，我们称其为Web个人资料

00:21:20.860 --> 00:21:29.080
加号，因为它提供或它将

00:21:25.900 --> 00:21:31.390
支持与Java re'相同的所有API 

00:21:29.080 --> 00:21:34.600
网页个人资料，但另外一两个

00:21:31.390 --> 00:21:37.210
好吧，它们已经被添加进来了

00:21:34.600 --> 00:21:40.150
那里的Maven中心，所以我不确定

00:21:37.210 --> 00:21:42.190
 Beta 1快照实际上已启动

00:21:40.150 --> 00:21:44.380
但据称它大约在

00:21:42.190 --> 00:21:45.929
现在我实际上并没有联系

00:21:44.380 --> 00:21:49.030
与开发人员一起查看是否

00:21:45.929 --> 00:21:52.000
发布了，但肯定有一个

00:21:49.030 --> 00:21:56.890
 Maven上的alpha 2快照

00:21:52.000 --> 00:21:58.240
快照存储库

00:21:56.890 --> 00:22:00.880
关键的API，所以我不会通过它们

00:21:58.240 --> 00:22:03.220
所有，但我们可以看到仅此而已

00:22:00.880 --> 00:22:05.799
基本上是网站配置文件，除了

00:22:03.220 --> 00:22:08.110
我们添加了J批处理

00:22:05.799 --> 00:22:10.660
并发和J缓存，这显然

00:22:08.110 --> 00:22:12.610
不是jari API，但仍然是

00:22:10.660 --> 00:22:16.360
我认为应该成为一个候选人

00:22:12.610 --> 00:22:18.190
但这确实需要向前发展

00:22:16.360 --> 00:22:22.660
虽然规范本身仍然

00:22:18.190 --> 00:22:26.140
不断发展，我们最近还添加了

00:22:22.660 --> 00:22:30.160
 JCA为此，它不是一个问题

00:22:26.140 --> 00:22:32.290
可以使用网络配置文件之前的内容

00:22:30.160 --> 00:22:34.750
使您能够做的就是将其用作

00:22:32.290 --> 00:22:36.669
我认为这是一个真正的JMS客户端

00:22:34.750 --> 00:22:40.210
对于云原生而言重要的事情

00:22:36.669 --> 00:22:43.900
部署，但这也意味着我们

00:22:40.210 --> 00:22:45.700
可以创建我们自己的资源档案

00:22:43.900 --> 00:22:48.850
使用现代消息传递

00:22:45.700 --> 00:22:53.049
像mqtt Apache这样的通讯工具

00:22:48.850 --> 00:22:56.200
 Kafka Amazon的sqs服务我们实际上

00:22:53.049 --> 00:22:58.270
在github中有一个名为我们的存储库

00:22:56.200 --> 00:23:01.330
云连接器存储库

00:22:58.270 --> 00:23:02.950
所有这些的例子都说

00:23:01.330 --> 00:23:05.230
使用起来非常简单，只是创建一个

00:23:02.950 --> 00:23:06.360
新的MDB使用相同的激活

00:23:05.230 --> 00:23:09.540
冲突财产和

00:23:06.360 --> 00:23:13.800
耐心为您设置位置

00:23:09.540 --> 00:23:16.740
您的MQTT经纪人，您可以订阅

00:23:13.800 --> 00:23:20.910
只是带有普通MDB内容的消息

00:23:16.740 --> 00:23:25.050
所以是的，EJB池配置可以

00:23:20.910 --> 00:23:27.210
用来控制另一件事

00:23:25.050 --> 00:23:30.600
是配置，这是微型配置文件

00:23:27.210 --> 00:23:31.470
 config api，并且已经为

00:23:30.600 --> 00:23:34.770
不久

00:23:31.470 --> 00:23:39.210
我想我们肯定有一些

00:23:34.770 --> 00:23:42.510
配置1.1的额外更新，我认为

00:23:39.210 --> 00:23:46.860
那是十一月的时间

00:23:42.510 --> 00:23:49.890
我们的下一个版本，使我们进入

00:23:46.860 --> 00:23:52.020
准备切换的演示

00:23:49.890 --> 00:23:59.930
对笔记本电脑来说就是那样

00:23:52.020 --> 00:23:59.930
碰巧让我得到排序的数字5 

00:24:01.929 --> 00:24:17.639
确保我很幸运

00:24:11.369 --> 00:24:17.639
太好了，你没有东西

00:24:33.570 --> 00:24:37.550
那你去不行那太好了

00:24:51.820 --> 00:24:55.180
有人是这样的

00:25:10.320 --> 00:25:15.580
所以我们去看看是否可以得到

00:25:12.490 --> 00:25:19.740
如果没有一切，一切就开始运转了

00:25:15.580 --> 00:25:19.740
可以跟你讲讲我猜的事情

00:25:28.760 --> 00:25:35.669
是的，不是的最好的问题

00:25:31.320 --> 00:25:40.200
检测任何输入它做的第一件事

00:25:35.669 --> 00:25:47.669
今天早上，但是可以，因为不能

00:25:40.200 --> 00:25:52.049
从那时开始就得到它

00:25:47.669 --> 00:25:54.200
好吧，让我们忽略该演示，然后让我们

00:25:52.049 --> 00:25:54.200
走

00:26:01.350 --> 00:26:10.380
好的，让我们向您展示什么是演示

00:26:06.289 --> 00:26:13.820
他将要依靠我的爱

00:26:10.380 --> 00:26:18.870
树莓派集群在那里

00:26:13.820 --> 00:26:20.549
集群本身只是为了利益

00:26:18.870 --> 00:26:24.179
房间里的任何硬件黑客

00:26:20.549 --> 00:26:25.890
底部的Raspberry Pi 3红色

00:26:24.179 --> 00:26:27.149
在上面的板子，这是一种

00:26:25.890 --> 00:26:28.830
看起来像是插入了它本身

00:26:27.149 --> 00:26:34.860
不只是从那里输送电力

00:26:28.830 --> 00:26:36.870
只是一个主板的主板

00:26:34.860 --> 00:26:39.510
哪种支持4 

00:26:36.870 --> 00:26:42.090
批准的零在上面允许

00:26:39.510 --> 00:26:44.130
聚集在一起工作

00:26:42.090 --> 00:26:46.740
漂亮地回到家里，然后我

00:26:44.130 --> 00:26:48.390
杀了它，因为它的问题是

00:26:46.740 --> 00:26:52.500
全部来自单一力量

00:26:48.390 --> 00:26:53.820
来源，问题在于

00:26:52.500 --> 00:26:58.289
当你让他们四个都跑的时候

00:26:53.820 --> 00:27:00.270
一次加上主板没有

00:26:58.289 --> 00:27:02.850
有很多力量可以绕过去

00:27:00.270 --> 00:27:05.309
只是减慢了很多，所以我试图

00:27:02.850 --> 00:27:07.620
增加模式是的，不要乱

00:27:05.309 --> 00:27:09.169
充满力量和类似的东西

00:27:07.620 --> 00:27:12.000
当你不知道自己在做什么时

00:27:09.169 --> 00:27:16.500
演示场景将是关于

00:27:12.000 --> 00:27:19.320
停靠它基于一个应用程序

00:27:16.500 --> 00:27:21.960
我们已经猜到了股票行情

00:27:19.320 --> 00:27:25.289
演示中我们有几个Ralphie 

00:27:21.960 --> 00:27:27.360
 PI是我们在微机上站得住脚的工具

00:27:25.289 --> 00:27:29.070
里面有股票行情自动收录器， 

00:27:27.360 --> 00:27:33.090
我们将桩标放在第二个

00:27:29.070 --> 00:27:37.010
其中有一个网络应用程序，我们

00:27:33.090 --> 00:27:39.299
使用EJB计时器通过CDI触发事件

00:27:37.010 --> 00:27:41.610
那是因为我们有淡褐色

00:27:39.299 --> 00:27:43.440
脚轮将这两个群集在一起

00:27:41.610 --> 00:27:45.450
而不是仅仅发生这些事件

00:27:43.440 --> 00:27:48.720
这些可以在第一个JVM中发送

00:27:45.450 --> 00:27:50.330
通过网络连接到另一个JVM并成为

00:27:48.720 --> 00:27:52.650
由节点的另一个成员处理

00:27:50.330 --> 00:27:55.800
这是我们提供的一个非常简洁的API 

00:27:52.650 --> 00:27:57.120
 PI或Micro都是相同的CDI事件API 

00:27:55.800 --> 00:28:04.170
您通常会使用的，但我们只是

00:27:57.120 --> 00:28:06.450
用出站注释，这是

00:28:04.170 --> 00:28:09.570
大概会是什么，所以我们已经

00:28:06.450 --> 00:28:12.510
在底部显示股票行情

00:28:09.570 --> 00:28:14.910
我们在payara中还有另一个功能

00:28:12.510 --> 00:28:17.340
这使您可以聚类

00:28:14.910 --> 00:28:20.880
 Singleton的基本意思是

00:28:17.340 --> 00:28:24.900
在整个集群中，您可以站立

00:28:20.880 --> 00:28:26.760
建立您想要的相同微服务

00:28:24.900 --> 00:28:28.020
但您可以保证

00:28:26.760 --> 00:28:32.220
整个集群永远不会

00:28:28.020 --> 00:28:34.470
该EJB或附件的一个实例

00:28:32.220 --> 00:28:39.390
实际上完全功能，但很快

00:28:34.470 --> 00:28:41.660
成为并应用集群范围

00:28:39.390 --> 00:28:44.550
 CDI光束

00:28:41.660 --> 00:28:46.710
所以是的股票行情自动收录器

00:28:44.550 --> 00:28:49.680
在其中的计时器是一个单例

00:28:46.710 --> 00:28:51.480
产生事件，股票网站明显

00:28:49.680 --> 00:28:54.020
聚集在一起将收到

00:28:51.480 --> 00:28:56.280
这些事件并推动它们通过

00:28:54.020 --> 00:29:00.930
 WebSockets到浏览器，以便它们可以

00:28:56.280 --> 00:29:05.250
消耗掉了，所以我可能不得不跳过

00:29:00.930 --> 00:29:07.680
关于那件事的一点点

00:29:05.250 --> 00:29:09.450
要显示但有效地我

00:29:07.680 --> 00:29:12.840
会显示出所有这些

00:29:09.450 --> 00:29:15.140
 github，所以我可以看看是否可以

00:29:12.840 --> 00:29:15.140
那个

00:29:33.560 --> 00:29:41.350
至少能够谈论代码

00:29:36.170 --> 00:29:41.350
她比那更好

00:29:45.020 --> 00:29:48.100
太好了

00:29:49.690 --> 00:29:55.660
首先是库存如何

00:29:51.760 --> 00:30:01.120
对象，所以希望这是一个库存库

00:29:55.660 --> 00:30:09.550
这有一些设置

00:30:01.120 --> 00:30:11.100
更好，看起来很好

00:30:09.550 --> 00:30:15.670
实际上，这将拥有所有

00:30:11.100 --> 00:30:17.290
完成了一些最终的东西，所以我

00:30:15.670 --> 00:30:19.120
要通过它来运行

00:30:17.290 --> 00:30:23.560
为此编写所有代码，但我们只是

00:30:19.120 --> 00:30:26.230
看看这里的最终产品

00:30:23.560 --> 00:30:28.210
得到的只是我的普通库存对象

00:30:26.230 --> 00:30:31.270
已经添加了JSONP注释，但是

00:30:28.210 --> 00:30:34.060
后来，所以我们拥有的一切

00:30:31.270 --> 00:30:34.930
股票对象是符号说明

00:30:34.060 --> 00:30:36.790
和一个价格

00:30:34.930 --> 00:30:39.210
所以这个符号显然是每只股票

00:30:36.790 --> 00:30:41.140
需要有一个标志，它

00:30:39.210 --> 00:30:46.480
标识自己需要与之

00:30:41.140 --> 00:30:48.550
现在唯一的价格只是一个随机

00:30:46.480 --> 00:30:54.790
双重和描述是

00:30:48.550 --> 00:31:00.070
字符串，因此我首先创建了一个

00:30:54.790 --> 00:31:03.190
杰森方法，显然只是看到

00:31:00.070 --> 00:31:05.230
与我相邻的物体有关

00:31:03.190 --> 00:31:06.820
然后有一个字符串，只有两个字符串

00:31:05.230 --> 00:31:09.490
刚刚调用的方法，然后

00:31:06.820 --> 00:31:11.650
数据对象上的两个字符串

00:31:09.490 --> 00:31:13.330
返回这是旧的那种

00:31:11.650 --> 00:31:19.600
 Java re'的七种处理方式

00:31:13.330 --> 00:31:21.040
 JSONP api，所以相当

00:31:19.600 --> 00:31:23.260
功能性我的意思是没有太多

00:31:21.040 --> 00:31:27.700
那真的很难还是很难

00:31:23.260 --> 00:31:30.160
使用or，但它是相当手动的，所以

00:31:27.700 --> 00:31:36.310
创建所有这些东西涉及

00:31:30.160 --> 00:31:37.570
我认为还有很多额外的工作

00:31:36.310 --> 00:31:40.390
一旦获得，我们需要的其他东西

00:31:37.570 --> 00:31:43.180
我们的库存对象是股票行情

00:31:40.390 --> 00:31:45.310
实际上设定了股票价格，所以我们已经

00:31:43.180 --> 00:31:48.360
显然，对象就在那里

00:31:45.310 --> 00:31:48.360
目前没有做任何事情

00:32:04.950 --> 00:32:09.570
是的，在这里我们可以看到我们有一个

00:32:07.340 --> 00:32:13.050
股票行情记录只是一个

00:32:09.570 --> 00:32:17.010
带有EJB计时器的单例EJB 

00:32:13.050 --> 00:32:19.520
预定您每秒

00:32:17.010 --> 00:32:23.400
可以在顶部看到我已经添加了

00:32:19.520 --> 00:32:26.850
在那里的聚簇注释是pyro 

00:32:23.400 --> 00:32:30.650
微注解只是为了确保单个

00:32:26.850 --> 00:32:30.650
整个集群中的实例

00:32:33.140 --> 00:32:46.140
可能会更好一点

00:32:39.450 --> 00:32:48.930
所以我们在这里有这个活动

00:32:46.140 --> 00:32:51.870
在这里创建的我已注解

00:32:48.930 --> 00:32:54.930
在出站，所以出站

00:32:51.870 --> 00:32:58.170
注释是否告诉群集的CDI 

00:32:54.930 --> 00:33:00.030
这些事件需要去的事件总线

00:32:58.170 --> 00:33:01.260
跨网络到其他任何地方

00:33:00.030 --> 00:33:03.480
那是那个集群，而不是那个

00:33:01.260 --> 00:33:05.520
听他们的话，然后在

00:33:03.480 --> 00:33:08.490
括号在这里还添加了回送等于

00:33:05.520 --> 00:33:10.770
是的，现在的原因是，如果

00:33:08.490 --> 00:33:12.630
您想要处理其中的事件

00:33:10.770 --> 00:33:14.130
相同的JVM以及通过网络

00:33:12.630 --> 00:33:16.350
然后我们将循环添加回去

00:33:14.130 --> 00:33:20.520
也可以将其发送给自己

00:33:16.350 --> 00:33:21.900
默认情况下，这里显然

00:33:20.520 --> 00:33:27.840
计时器只是一种创造

00:33:21.900 --> 00:33:29.700
一个新的通用股票实例

00:33:27.840 --> 00:33:31.800
只是数学或随机

00:33:29.700 --> 00:33:35.570
实际股价显然

00:33:31.800 --> 00:33:35.570
是的，是的

00:33:38.240 --> 00:33:42.540
每一个音符是的是我们无法做到的

00:33:41.309 --> 00:33:43.740
实际上也做的是

00:33:42.540 --> 00:33:46.740
我们可以做的事情

00:33:43.740 --> 00:33:49.140
有一个名称添加到事件和

00:33:46.740 --> 00:33:51.540
然后当您添加入站时

00:33:49.140 --> 00:33:53.040
注释，您可以指定仅

00:33:51.540 --> 00:33:54.570
想听一个名字，所以

00:33:53.040 --> 00:33:56.820
有效地工作它不是一个

00:33:54.570 --> 00:34:00.110
事情的主题风格，但这是

00:33:56.820 --> 00:34:00.110
有效地做同样的事情

00:34:05.990 --> 00:34:10.020
是的，参与者只是指出

00:34:08.250 --> 00:34:18.389
带有CDI事件的黄色

00:34:10.020 --> 00:34:21.060
按对象类类型过滤好吧

00:34:18.389 --> 00:34:22.619
是的，所以我们有股票报价器

00:34:21.060 --> 00:34:26.310
设定股票价格，我们有一个

00:34:22.619 --> 00:34:29.340
 CDI事件总线的发布者，因此如果

00:34:26.310 --> 00:34:31.470
股票网络监听器我们在做什么

00:34:29.340 --> 00:34:36.690
正在创建一个WebSocket 

00:34:31.470 --> 00:34:39.480
端点，这只是一个标准的API 

00:34:36.690 --> 00:34:41.159
在Java EE 7中已经存在

00:34:39.480 --> 00:34:43.260
演示中的这一点，我们正在使用

00:34:41.159 --> 00:34:44.850
只是现有的Java EE 7 

00:34:43.260 --> 00:34:47.340
技术，所以我们会

00:34:44.850 --> 00:34:51.149
从那里开始，然后在Java EE上添加

00:34:47.340 --> 00:34:53.010
东西，所以我们需要分类

00:34:51.149 --> 00:34:54.330
管理WebSocket会话，然后

00:34:53.010 --> 00:34:56.399
对于每个注册的会话，我们

00:34:54.330 --> 00:35:01.740
会通过

00:34:56.399 --> 00:35:03.750
在我认为的消息上，然后上课

00:35:01.740 --> 00:35:06.030
收听CD上的库存事件

00:35:03.750 --> 00:35:09.219
事件总线

00:35:06.030 --> 00:35:09.219
 [音乐] 

00:35:17.270 --> 00:35:23.690
所以首先我们有会议经理

00:35:20.040 --> 00:35:27.270
这是应用程序范围内的CDI bean 

00:35:23.690 --> 00:35:29.360
然后注入CDI事件总线本身

00:35:27.270 --> 00:35:34.320
这就是我们实际上收到的方式

00:35:29.360 --> 00:35:35.910
我们所拥有的事件

00:35:34.320 --> 00:35:40.980
注册你注册会议吗

00:35:35.910 --> 00:35:43.500
这只是一个哈希集，我们在这里

00:35:40.980 --> 00:35:48.990
我们添加了一个观察者方法

00:35:43.500 --> 00:35:50.130
我们在观察库存

00:35:48.990 --> 00:35:51.780
我们真正添加到那里的唯一一件事

00:35:50.130 --> 00:35:53.040
是入站，在那里

00:35:51.780 --> 00:35:57.510
你把你知道的多余的东西放在

00:35:53.040 --> 00:36:00.120
括号以按名称过滤

00:35:57.510 --> 00:36:02.190
我们得到的每个循环

00:36:00.120 --> 00:36:08.970
那里的每个环节

00:36:02.190 --> 00:36:10.860
已注册，我们等待事件发生

00:36:08.970 --> 00:36:12.330
收到后立即收到

00:36:10.860 --> 00:36:18.210
将一切发送给每个人

00:36:12.330 --> 00:36:20.610
订阅的消费者就是这些

00:36:18.210 --> 00:36:29.240
有点基本的只是发送文本

00:36:20.610 --> 00:36:29.240
作为字符串对象（如果我知道的话） 

00:36:33.089 --> 00:36:37.469
让我们看看实际

00:36:34.809 --> 00:36:37.469
 WebSocket类

00:36:41.470 --> 00:36:46.900
所以我们有服务器端

00:36:43.510 --> 00:36:50.010
斜线图，我们正在注入会话

00:36:46.900 --> 00:36:52.619
我们刚刚创建的经理未打开

00:36:50.010 --> 00:36:55.390
在此注册会话的方法

00:36:52.619 --> 00:36:56.650
然后一旦注册，我们就让

00:36:55.390 --> 00:37:03.119
会话管理器将所有

00:36:56.650 --> 00:37:05.950
基于观察方法的数据

00:37:03.119 --> 00:37:10.030
这就是那里发生的一切

00:37:05.950 --> 00:37:11.380
我不会去实际的

00:37:10.030 --> 00:37:15.599
 JavaScript页面，因为它只是一个

00:37:11.380 --> 00:37:15.599
具有JavaScript的JavaScript页面

00:37:16.800 --> 00:37:26.380
 WebSocket端点监听

00:37:19.810 --> 00:37:30.760
那些，所以现在我们应该在

00:37:26.380 --> 00:37:33.220
指出我们所拥有的一切

00:37:30.760 --> 00:37:34.780
如果我能够在一个

00:37:33.220 --> 00:37:37.630
表明你在工作，我们会有一个

00:37:34.780 --> 00:37:38.650
每个股票行情自动收录器的单个JVM 

00:37:37.630 --> 00:37:40.690
第二个将发布事件

00:37:38.650 --> 00:37:43.630
这些将被解雇，然后

00:37:40.690 --> 00:37:46.270
被另一个实例接收，然后

00:37:43.630 --> 00:37:48.069
这将推动这些事情

00:37:46.270 --> 00:37:50.589
通过WebSockets和会话退出

00:37:48.069 --> 00:37:53.589
浏览器的管理员，那么用户

00:37:50.589 --> 00:37:58.000
看到的是一个很好的动态图

00:37:53.589 --> 00:37:59.770
具有WebSockets动态更新

00:37:58.000 --> 00:38:03.310
一切都在那一刻

00:37:59.770 --> 00:38:06.130
你可以做得很好的事情

00:38:03.310 --> 00:38:07.690
在Java EE 8发布之前的今天， 

00:38:06.130 --> 00:38:14.230
没有什么特别新的

00:38:07.690 --> 00:38:15.339
在那里，所以我首先想到的是

00:38:14.230 --> 00:38:19.030
我说一开始我想放

00:38:15.339 --> 00:38:20.890
 Java 8进入了一点上下文，所以我

00:38:19.030 --> 00:38:22.230
以为使用问题

00:38:20.890 --> 00:38:24.280
 cd-i事件总线，尽管它是

00:38:22.230 --> 00:38:26.280
如果你有一个内部的，那就太棒了

00:38:24.280 --> 00:38:28.720
您可以控制所有应用程序的应用程序

00:38:26.280 --> 00:38:31.569
您所知道的服务会给您带来终点

00:38:28.720 --> 00:38:33.730
您可以使用CDI事件的应用程序

00:38:31.569 --> 00:38:36.339
内部通讯总线

00:38:33.730 --> 00:38:38.140
在那里，您可以使用的范围比

00:38:36.339 --> 00:38:39.700
你想要，但你不能保证有

00:38:38.140 --> 00:38:41.680
想要使用一个的其他人

00:38:39.700 --> 00:38:44.650
您的麦克风Riserva TSA的麦克风，还是您想要的

00:38:41.680 --> 00:38:45.760
公开露面，你不能

00:38:44.650 --> 00:38:47.319
真正保证他们会

00:38:45.760 --> 00:38:51.930
能够消耗这类事件

00:38:47.319 --> 00:38:51.930
所以我们需要别的东西来处理

00:38:51.990 --> 00:39:00.300
和解决方案有服务器发送

00:38:54.900 --> 00:39:03.030
我确实有来自Jackson RS的事件

00:39:00.300 --> 00:39:04.500
 WebSockets已经设置好了

00:39:03.030 --> 00:39:08.310
股票网站显然我们可以拥有

00:39:04.500 --> 00:39:10.140
用那个，但那里的区别

00:39:08.310 --> 00:39:14.390
 WebSockets是二进制的吗？ 

00:39:10.140 --> 00:39:14.390
传播者双向交流所以

00:39:15.140 --> 00:39:19.380
你基本上要做的是开放一个

00:39:17.220 --> 00:39:20.940
您不仅发送日期的渠道

00:39:19.380 --> 00:39:21.750
但您正在等待接收数据

00:39:20.940 --> 00:39:23.099
好，所以您拥有了所有这些额外功能

00:39:21.750 --> 00:39:25.230
端点监听那些

00:39:23.099 --> 00:39:27.630
什么也没做，因为我们

00:39:25.230 --> 00:39:31.050
这样做是广播，所以服务和事件

00:39:27.630 --> 00:39:32.609
这是一个绝好的机会，因为

00:39:31.050 --> 00:39:33.990
只是使用其余部分，而是使用标准网络

00:39:32.609 --> 00:39:36.960
已经存在的技术

00:39:33.990 --> 00:39:40.410
时间长了，基本上已经设计好了

00:39:36.960 --> 00:39:42.750
广播等等

00:39:40.410 --> 00:39:43.830
我本来也会做的

00:39:42.750 --> 00:39:46.590
假设我们要做这个

00:39:43.830 --> 00:39:48.690
供其他人消费的公共物品

00:39:46.590 --> 00:39:55.200
我们将使用JSON be序列化股票

00:39:48.690 --> 00:39:57.780
反对，给人一种很好的一种

00:39:55.200 --> 00:40:03.240
库存对象，然后我们可以

00:39:57.780 --> 00:40:06.660
其他消费者容易使用，所以这是

00:40:03.240 --> 00:40:09.109
其实我在

00:40:06.660 --> 00:40:13.410
幻灯片使事情变得容易得多

00:40:09.109 --> 00:40:16.440
所以首先我们在github上看到了

00:40:13.410 --> 00:40:18.780
这已经是我的原始方式

00:40:16.440 --> 00:40:20.790
用JSONP做事，所以我们所做的一切

00:40:18.780 --> 00:40:22.980
得到的只是它返回的JSON对象

00:40:20.790 --> 00:40:24.869
相邻方法，然后我们就

00:40:22.980 --> 00:40:28.349
说串就好了，但是

00:40:24.869 --> 00:40:30.780
这有点手动，有点脆

00:40:28.349 --> 00:40:34.109
这些就是Jason B 

00:40:30.780 --> 00:40:37.230
带来了Jason B dotnet 

00:40:34.109 --> 00:40:39.720
相当多的例子，事物和链接

00:40:37.230 --> 00:40:40.770
符合规范，并且已经

00:40:39.720 --> 00:40:44.040
受影响的我们可以在底部看到

00:40:40.770 --> 00:40:45.990
那里我们有这种存货

00:40:44.040 --> 00:40:52.130
等于jason构建它或从中创建点

00:40:45.990 --> 00:40:54.690
杰森，对不起，那是为了

00:40:52.130 --> 00:40:57.330
反序列化，以便上面的一个

00:40:54.690 --> 00:40:59.910
那就是两个字符串的方法而已

00:40:57.330 --> 00:41:02.550
在这里，所以我们在这里做的是

00:40:59.910 --> 00:41:04.170
有杰森被配置，这就是所谓的移动

00:41:02.550 --> 00:41:09.960
可配置，因为我们

00:41:04.170 --> 00:41:11.220
对于空值，我所做的是

00:41:09.960 --> 00:41:15.360
只是把它放在我已经

00:41:11.220 --> 00:41:16.710
有文档创建您不想要的可配置

00:41:15.360 --> 00:41:18.090
必须有他们可以做点创建

00:41:16.710 --> 00:41:21.210
括号内没有任何东西，它将

00:41:18.090 --> 00:41:22.530
只需遵循自己的默认规则即可

00:41:21.210 --> 00:41:25.770
创建杰森，它只会

00:41:22.530 --> 00:41:31.950
在中间为您序列化

00:41:25.770 --> 00:41:33.420
我们已经进入了三个领域

00:41:31.950 --> 00:41:35.640
我们有象征我刚刚离开了

00:41:33.420 --> 00:41:38.000
娜娜·泰特（Nana Tate），“我把杰森（Jason） 

00:41:35.640 --> 00:41:40.470
字符串描述上的瞬态

00:41:38.000 --> 00:41:42.630
因为只是为了证明我们可能

00:41:40.470 --> 00:41:43.890
喜欢很长很重

00:41:42.630 --> 00:41:46.590
我们不想的数据字段

00:41:43.890 --> 00:41:49.920
序列化或可能是图像

00:41:46.590 --> 00:41:51.690
或你班上的东西

00:41:49.920 --> 00:41:53.040
不想看到很多-Jason Jason 

00:41:51.690 --> 00:41:56.430
是短暂的，我们将其设置为

00:41:53.040 --> 00:41:59.670
忽略了，我们还有Jason B 

00:41:56.430 --> 00:42:01.020
再次出现在那儿，因为这是

00:41:59.670 --> 00:42:03.570
每一次的礼仪

00:42:01.020 --> 00:42:05.520
生成随机数，这是一个

00:42:03.570 --> 00:42:07.200
股票报价器认为这可能很好

00:42:05.520 --> 00:42:08.970
让人们知道这不是

00:42:07.200 --> 00:42:12.180
实际股价只是随机的

00:42:08.970 --> 00:42:14.250
数字，这样就可以覆盖

00:42:12.180 --> 00:42:17.580
实际价格，这意味着

00:42:14.250 --> 00:42:21.090
您返回的json对象是

00:42:17.580 --> 00:42:23.840
那里捡到什么，我已经看到

00:42:21.090 --> 00:42:26.550
在演示中，我们需要更改我们的

00:42:23.840 --> 00:42:29.340
 javascript类，从寻找

00:42:26.550 --> 00:42:33.590
点价调查点随机价格

00:42:29.340 --> 00:42:33.590
实际上总是找不到

00:42:36.470 --> 00:42:42.230
所以继续前进，我要问安德烈

00:42:40.369 --> 00:42:45.440
再来一点

00:42:42.230 --> 00:42:46.910
关于jax-rs反应式客户端API，所以

00:42:45.440 --> 00:42:49.130
这不是我真正的东西

00:42:46.910 --> 00:42:50.390
包含在我自己的演示中，但我认为

00:42:49.130 --> 00:42:53.089
实际上是一个重要的功能

00:42:50.390 --> 00:42:55.970
 jax-rs，所以我想提一提

00:42:53.089 --> 00:42:58.790
幸运的是，Alex tdum在这里和

00:42:55.970 --> 00:43:00.440
自己做一些演讲，然后

00:42:58.790 --> 00:43:01.760
如果可以的话赶上他们，这是一个非常

00:43:00.440 --> 00:43:06.770
好的演讲者

00:43:01.760 --> 00:43:08.720
我敢肯定他的演示总是奏效的

00:43:06.770 --> 00:43:10.819
写了这篇博客，这是非常

00:43:08.720 --> 00:43:11.960
很好地调查事物，他

00:43:10.819 --> 00:43:20.930
谈到了一些

00:43:11.960 --> 00:43:24.859
反应性客户端API就在这里，所以

00:43:20.930 --> 00:43:27.319
反应式客户端API就像改进一样

00:43:24.859 --> 00:43:29.630
 API的存在

00:43:27.319 --> 00:43:35.800
已经在Java EE 7中被使用

00:43:29.630 --> 00:43:38.660
同步客户端API， 

00:43:35.800 --> 00:43:42.140
基于无法使用的Java 7 

00:43:38.660 --> 00:43:44.480
可完成的未来或不是所有这些新事物

00:43:42.140 --> 00:43:49.310
 Java 8中的东西像lambdas这样

00:43:44.480 --> 00:43:53.630
提供了更多麻烦的API，那么它可以

00:43:49.310 --> 00:43:56.300
使用Java 8，但以前使用视频

00:43:53.630 --> 00:43:59.270
同步API，您可以选择

00:43:56.300 --> 00:44:04.190
发送回调时提供回调

00:43:59.270 --> 00:44:06.530
获取对服务和电话的请求

00:44:04.190 --> 00:44:09.589
不会被阻止，因此您可以继续

00:44:06.530 --> 00:44:13.010
在进行其他一些计算

00:44:09.589 --> 00:44:15.920
同样的威胁，然后当服务

00:44:13.010 --> 00:44:18.020
通话完成了申请

00:44:15.920 --> 00:44:21.440
服务器将执行回调

00:44:18.020 --> 00:44:25.210
通常在不同的线程中

00:44:21.440 --> 00:44:29.180
不会阻塞您的原始线程

00:44:25.210 --> 00:44:31.430
这很麻烦，因为你

00:44:29.180 --> 00:44:34.220
需要提供回调作为

00:44:31.430 --> 00:44:38.150
接口的实现

00:44:34.220 --> 00:44:41.150
无法简单地将其他人联系在一起

00:44:38.150 --> 00:44:44.480
在其他执行之上

00:44:41.150 --> 00:44:47.420
它的顶部，所以如果您只执行它

00:44:44.480 --> 00:44:48.520
内的另一个同步呼叫

00:44:47.420 --> 00:44:52.030
回调你

00:44:48.520 --> 00:44:54.700
 -意大利面条代码，称为

00:44:52.030 --> 00:44:57.610
回调地狱，因为那里

00:44:54.700 --> 00:45:01.480
复杂里面的许多括号

00:44:57.610 --> 00:45:04.540
嵌套在其中，因此使用Java 8 

00:45:01.480 --> 00:45:07.690
新事物或它不是已经不是

00:45:04.540 --> 00:45:11.590
新但Java 8可完成的功能

00:45:07.690 --> 00:45:15.490
未来有新事物允许

00:45:11.590 --> 00:45:17.950
链接这些调用并创建

00:45:15.490 --> 00:45:23.050
可读代码，虽然它仍然是

00:45:17.950 --> 00:45:27.820
同步和新的轨道是如此

00:45:23.050 --> 00:45:30.550
反应性API，现在可以链接

00:45:27.820 --> 00:45:32.680
具有可完成的未来的回调

00:45:30.550 --> 00:45:35.580
但不仅知道可计算的

00:45:32.680 --> 00:45:39.119
未来，但您可以插入

00:45:35.580 --> 00:45:41.920
替代机制，例如rxjava 

00:45:39.119 --> 00:45:44.160
 Java的处理程序是相当

00:45:41.920 --> 00:45:47.740
编写反应式代码时很流行，并且

00:45:44.160 --> 00:45:51.340
 John Jarvis原生支持它，因此您

00:45:47.740 --> 00:45:55.690
想要你唯一需要的就是

00:45:51.340 --> 00:45:58.900
一个可以将结果转化为

00:45:55.690 --> 00:46:01.660
一个小时的服务电话将我们的

00:45:58.900 --> 00:46:05.200
观察者，然后我们可以在

00:46:01.660 --> 00:46:07.330
不需要jax-rs的相同API 

00:46:05.200 --> 00:46:08.920
不需要将其包装到另一个

00:46:07.330 --> 00:46:13.390
对象，您可以更改方法

00:46:08.920 --> 00:46:16.840
打电话，只是改变改变回报

00:46:13.390 --> 00:46:19.420
重视您不需要工作的东西

00:46:16.840 --> 00:46:22.180
与图书馆，所以这是我很好，但

00:46:19.420 --> 00:46:24.940
默认情况下，反应式调用

00:46:22.180 --> 00:46:28.060
返回可堆肥的未来或动力

00:46:24.940 --> 00:46:31.210
更确切地说是完成阶段，但是你

00:46:28.060 --> 00:46:34.240
可以覆盖它并插入您的

00:46:31.210 --> 00:46:37.060
工厂退换不同

00:46:34.240 --> 00:46:39.369
时间，以便您可以轻松地进行更多更改

00:46:37.060 --> 00:46:46.600
计算并将其转化为流

00:46:39.369 --> 00:46:50.590
的调用不是技术上的

00:46:46.600 --> 00:46:54.280
数据流，因为简单的反应式

00:46:50.590 --> 00:46:56.710
简单的休息电话只会等待

00:46:54.280 --> 00:46:58.700
然后把待办事项

00:46:56.710 --> 00:47:01.370
它可以把它

00:46:58.700 --> 00:47:04.340
或将其处理为Java对象

00:47:01.370 --> 00:47:07.790
解析JSON或XML，然后您仍然

00:47:04.340 --> 00:47:09.920
最后有最后一个对象，但是它

00:47:07.790 --> 00:47:12.080
使同步编写更容易

00:47:09.920 --> 00:47:16.040
代码，以便您的原始blah线程

00:47:12.080 --> 00:47:18.860
如果要使用实数，则不会被阻止

00:47:16.040 --> 00:47:21.770
 jax-rs将与您一起流

00:47:18.860 --> 00:47:27.320
 SSE服务器发送事件

00:47:21.770 --> 00:47:30.470
允许发起呼叫，然后在

00:47:27.320 --> 00:47:32.990
服务器可以发送单个事件流

00:47:30.470 --> 00:47:36.170
数据作为服务器发送的事件

00:47:32.990 --> 00:47:40.430
您可以再次用一个完整的循环链

00:47:36.170 --> 00:47:53.210
未来的回调，所以这是新的

00:47:40.430 --> 00:47:56.150
添加反应式客户端，以便CI返回

00:47:53.210 --> 00:47:59.030
到我们正在谈论的应用程序

00:47:56.150 --> 00:48:02.600
关于，因此服务器发送的事件是

00:47:59.030 --> 00:48:06.260
我真的很想

00:48:02.600 --> 00:48:09.790
在这里谈论，所以我在玩

00:48:06.260 --> 00:48:09.790
为此有一些事件

00:48:10.570 --> 00:48:15.860
其实几个月前

00:48:13.670 --> 00:48:20.210
基本上是jax-rs规范

00:48:15.860 --> 00:48:21.590
当时还没有完成，所以我

00:48:20.210 --> 00:48:23.390
当时所做的实际上只是使用

00:48:21.590 --> 00:48:27.650
它的泽西岛实施

00:48:23.390 --> 00:48:31.180
 jax-rs Edition的版本

00:48:27.650 --> 00:48:37.070
来自，所以我们可以看到这里

00:48:31.180 --> 00:48:39.890
 SSE端点在这里，或者这是泽西岛

00:48:37.070 --> 00:48:41.410
 API不是jax-rs，但我想拥有

00:48:39.890 --> 00:48:44.290
它只是为了让您可以比较

00:48:41.410 --> 00:48:47.180
到现在是什么样

00:48:44.290 --> 00:48:50.630
所以在这里你可以看到我们

00:48:47.180 --> 00:48:52.850
返回的事件输出类型已注释

00:48:50.630 --> 00:48:55.820
与sse制作人一起的特色观察员

00:48:52.850 --> 00:48:58.310
和事件显然现在我们有一个

00:48:55.820 --> 00:49:02.810
适当的媒体类型，您知道我们可以

00:48:58.310 --> 00:49:05.510
生产，所以我们需要创建一个新的

00:49:02.810 --> 00:49:08.840
线程并做那一切

00:49:05.510 --> 00:49:10.520
单独的线程里没有东西

00:49:08.840 --> 00:49:13.220
尤其

00:49:10.520 --> 00:49:15.200
复杂但有很多额外的二氧化碳

00:49:13.220 --> 00:49:19.310
对，还有很多额外的机会

00:49:15.200 --> 00:49:22.850
的错误，所以只是将其与

00:49:19.310 --> 00:49:25.130
 jax-rs代码确实不需要

00:49:22.850 --> 00:49:27.590
变得尽可能复杂

00:49:25.130 --> 00:49:29.450
就像SSE广播一样简单

00:49:27.590 --> 00:49:31.400
广播，您可以看到

00:49:29.450 --> 00:49:33.350
在那里，所以我们的原因

00:49:31.400 --> 00:49:37.280
有两种方法是

00:49:33.350 --> 00:49:42.320
到可以接待客户的终点

00:49:37.280 --> 00:49:44.540
作为SSE事件的请求现在同步

00:49:42.320 --> 00:49:48.170
事件同步只是您的事情

00:49:44.540 --> 00:49:50.510
可以在您的广播公司中注册，以便

00:49:48.170 --> 00:49:53.630
然后第二种方法是

00:49:50.510 --> 00:49:56.240
实际广播事件是因为

00:49:53.630 --> 00:49:59.210
我们实际上还注释了第二个

00:49:56.240 --> 00:50:01.520
那里有贴子的方法，这意味着

00:49:59.210 --> 00:50:02.870
你不仅可以知道这个

00:50:01.520 --> 00:50:05.840
同一内部的广播方法

00:50:02.870 --> 00:50:07.310
在同一个应用程序中

00:50:05.840 --> 00:50:09.050
可以像单独的微服务一样

00:50:07.310 --> 00:50:11.090
发送一些东西然后

00:50:09.050 --> 00:50:14.690
由单独的微服务广播到

00:50:11.090 --> 00:50:17.630
所有的消费者，因此您可以在

00:50:14.690 --> 00:50:18.950
最上面的我第一个是

00:50:17.630 --> 00:50:21.140
事件输出实际上是一个

00:50:18.950 --> 00:50:22.820
两行，第一行不是

00:50:21.140 --> 00:50:26.930
必要的，但这是您如何做的一个例子

00:50:22.820 --> 00:50:30.260
可以只发送一个事件，因此您可以

00:50:26.930 --> 00:50:32.530
在那里使用那种API，但是

00:50:30.260 --> 00:50:37.570
我认为SSE广播公司是真正的

00:50:32.530 --> 00:50:37.570
对于我们想要的目的有用的

00:50:38.650 --> 00:50:43.250
现在接下来要考虑的是

00:50:41.300 --> 00:50:45.050
从架构的角度来看是

00:50:43.250 --> 00:50:47.090
您在哪里将其插入

00:50:45.050 --> 00:50:49.850
我现在看到的应用程序

00:50:47.090 --> 00:50:51.350
已经有接近CDI的CDI事件

00:50:49.850 --> 00:50:55.550
股票行情自动收录器与

00:50:51.350 --> 00:50:57.740
股票网络服务，然后我得到了

00:50:55.550 --> 00:50:59.450
 WebSockets在前端，因此我们可以

00:50:57.740 --> 00:51:01.070
要做的是替换上的WebSockets 

00:50:59.450 --> 00:51:02.780
前端，所以我们还有CDO活动

00:51:01.070 --> 00:51:05.870
股票报价器和

00:51:02.780 --> 00:51:09.880
股票网站，然后

00:51:05.870 --> 00:51:12.800
我们必须使用的JavaScript SSE客户端

00:51:09.880 --> 00:51:14.330
我们必须创建基本上自己的

00:51:12.800 --> 00:51:16.190
那些之间的变化和

00:51:14.330 --> 00:51:19.010
幸运的是还没有幻灯片

00:51:16.190 --> 00:51:23.040
但它们很小

00:51:19.010 --> 00:51:28.620
这样做不多，但是当我们

00:51:23.040 --> 00:51:30.180
早一点谈到了

00:51:28.620 --> 00:51:32.100
我们管理这些东西的方式

00:51:30.180 --> 00:51:36.660
我们拥有的另一个选择是

00:51:32.100 --> 00:51:37.770
 jax-rs SSE客户端，实际上

00:51:36.660 --> 00:51:39.750
决定在这里是你想去的地方

00:51:37.770 --> 00:51:41.910
如果我们已经安排了微服务

00:51:39.750 --> 00:51:44.820
有了一个更复杂的场景

00:51:41.910 --> 00:51:47.400
您具有特定功能的地方

00:51:44.820 --> 00:51:48.780
您要运行的过程

00:51:47.400 --> 00:51:51.630
几项不同的工作，所以您认为五

00:51:48.780 --> 00:51:54.090
或六个你要编排

00:51:51.630 --> 00:51:56.160
在基于JavaScript浏览器的

00:51:54.090 --> 00:51:58.410
应用程序还是您想

00:51:56.160 --> 00:52:00.720
在后端进行编排，然后

00:51:58.410 --> 00:52:03.690
让您的JavaScript网页更具吸引力

00:52:00.720 --> 00:52:06.710
我通常会是一个瘦客户

00:52:03.690 --> 00:52:09.780
宁愿做第二种方式

00:52:06.710 --> 00:52:11.310
一切都精心策划

00:52:09.780 --> 00:52:12.300
后端，然后有一个瘦客户端

00:52:11.310 --> 00:52:14.880
在前面，但我知道那不是

00:52:12.300 --> 00:52:18.990
每个人的偏好，无论哪种方式

00:52:14.880 --> 00:52:23.010
可能的话，我再次看看

00:52:18.990 --> 00:52:26.300
 SSE客户端代码来自jax-rs 

00:52:23.010 --> 00:52:30.330
现在这又是旧球衣的方法

00:52:26.300 --> 00:52:31.800
我们可以创建一个新的客户端构建器

00:52:30.330 --> 00:52:34.290
实际上非常类似于新的jax-rs 

00:52:31.800 --> 00:52:39.090
 api，但我们只是使用不同的

00:52:34.290 --> 00:52:41.730
这里的物体和东西，我们需要

00:52:39.090 --> 00:52:45.500
实际返回事件源并

00:52:41.730 --> 00:52:50.850
我们正在创建一个新的客户端生成器

00:52:45.500 --> 00:52:52.920
注册并将其定位到

00:52:50.850 --> 00:52:56.730
盘点URL，所以我们需要知道

00:52:52.920 --> 00:52:58.320
预先输入这个网址很棘手

00:52:56.730 --> 00:53:04.740
我们有办法解决，我会说

00:52:58.320 --> 00:53:06.600
关于稍后我们需要的事件监听器

00:53:04.740 --> 00:53:08.100
添加并注册到事件

00:53:06.600 --> 00:53:10.350
源，所以我们只是创建一个新课程

00:53:08.100 --> 00:53:12.000
显然这有点旧

00:53:10.350 --> 00:53:15.270
因此实际上可以被替换的代码

00:53:12.000 --> 00:53:21.620
用lambda而不是匿名

00:53:15.270 --> 00:53:24.390
方法是在jax-rs 2.1中，所以我们已经

00:53:21.620 --> 00:53:26.270
将其基本上设置为三个

00:53:24.390 --> 00:53:28.700
我们得到的不同方法

00:53:26.270 --> 00:53:30.560
我正在执行后期构造的EJB 

00:53:28.700 --> 00:53:31.580
在后结构的预破坏中

00:53:30.560 --> 00:53:33.260
初始化一切都非常

00:53:31.580 --> 00:53:37.460
在Web目标中初始化客户端

00:53:33.260 --> 00:53:40.730
和以前完全一样，我们

00:53:37.460 --> 00:53:42.410
将源设置为SSE事件

00:53:40.730 --> 00:53:44.750
来源，而不仅仅是正常事件

00:53:42.410 --> 00:53:47.000
源，然后只调用观察

00:53:44.750 --> 00:53:48.650
方法，所以在观察方法中，这是

00:53:47.000 --> 00:53:52.490
我们实际上如何消费事件

00:53:48.650 --> 00:53:53.960
我们在那里有了一个简短的lambda 

00:53:52.490 --> 00:53:56.380
只是为了处理所有即将发生的事件

00:53:53.960 --> 00:53:57.680
我再次使用Jason B API 

00:53:56.380 --> 00:54:02.570
反序列化

00:53:57.680 --> 00:54:04.790
提供的库存事件

00:54:02.570 --> 00:54:07.790
可抛出的打印堆栈跟踪

00:54:04.790 --> 00:54:09.290
那里的方法参考

00:54:07.790 --> 00:54:13.010
出错了，所以我们不需要处理

00:54:09.290 --> 00:54:15.380
再详细一点，最后我

00:54:13.010 --> 00:54:18.260
只是不要打开源，然后这些

00:54:15.380 --> 00:54:20.420
事件将开始在

00:54:18.260 --> 00:54:22.520
到此为止，我有一种销毁方法

00:54:20.420 --> 00:54:25.730
优雅地关闭我所看到的，这样我们就不会

00:54:22.520 --> 00:54:28.580
在远端得到任何错误，它

00:54:25.730 --> 00:54:31.150
只是找到客户消费者

00:54:28.580 --> 00:54:31.150
消失了

00:54:31.660 --> 00:54:38.810
如果你想卖的话

00:54:36.500 --> 00:54:40.100
 JavaScript在我的机器上做

00:54:38.810 --> 00:54:42.980
特别的例子，因为我正在跑步

00:54:40.100 --> 00:54:46.190
这在一个或我会一直在运行

00:54:42.980 --> 00:54:48.020
它在笔记本电脑上的一切都被

00:54:46.190 --> 00:54:51.820
本地主机，您可以清楚地看到

00:54:48.020 --> 00:54:56.030
如果您有跨源问题

00:54:51.820 --> 00:54:57.560
从两个不同的端口请求

00:54:56.030 --> 00:55:02.270
我那里有一个小图

00:54:57.560 --> 00:55:03.560
来自开发人员mozilla.org和我

00:55:02.270 --> 00:55:08.450
不会说这只是一个

00:55:03.560 --> 00:55:09.710
仅用于jax-rs的标准响应过滤器

00:55:08.450 --> 00:55:11.420
添加一个标题只是为了说

00:55:09.710 --> 00:55:14.720
是的，可以跨源请求

00:55:11.420 --> 00:55:15.980
没关系，这不会

00:55:14.720 --> 00:55:18.290
真的是一个问题，因为他们会

00:55:15.980 --> 00:55:23.510
总是来自同一个域，所以我们会

00:55:18.290 --> 00:55:27.140
知道那没关系，所以真的很前方

00:55:23.510 --> 00:55:29.450
现在的时间表，但是是的，下一个

00:55:27.140 --> 00:55:33.320
要看的一件事，所以我们已经

00:55:29.450 --> 00:55:35.360
添加了一些jar v8 api来制作

00:55:33.320 --> 00:55:37.160
事情有点通用

00:55:35.360 --> 00:55:39.140
下一个是看未来

00:55:37.160 --> 00:55:42.430
 Java EE及其发展方向

00:55:39.140 --> 00:55:48.890
或II代表J或任何被称为

00:55:42.430 --> 00:55:50.210
偷偷地因为我想了很多

00:55:48.890 --> 00:55:52.940
参与其中的人

00:55:50.210 --> 00:55:54.440
微型配置文件的努力取得了巨大成功

00:55:52.940 --> 00:55:57.980
实际上是微观的异象

00:55:54.440 --> 00:55:59.960
本身正在获得很大的吸引力

00:55:57.980 --> 00:56:03.920
比我想的要多得多

00:55:59.960 --> 00:56:06.769
预计我认为有一个强大的

00:56:03.920 --> 00:56:08.420
感觉Java EE的未来是否

00:56:06.769 --> 00:56:13.009
你想现在看到它看起来微

00:56:08.420 --> 00:56:14.420
个人简介这再次像

00:56:13.009 --> 00:56:16.309
我认为完全是我的个人观点

00:56:14.420 --> 00:56:20.119
其实这真的是未来

00:56:16.309 --> 00:56:24.019
 Java EE是否包含我的个人资料

00:56:20.119 --> 00:56:25.430
不知道我不希望

00:56:24.019 --> 00:56:26.869
我不觉得我很喜欢

00:56:25.430 --> 00:56:28.759
我们可以创新的独立项目

00:56:26.869 --> 00:56:33.920
它有额外的自由去做

00:56:28.759 --> 00:56:35.779
人们需要的东西我知道IBM 

00:56:33.920 --> 00:56:37.279
和红帽正在大力投资

00:56:35.779 --> 00:56:39.710
他们有很多人

00:56:37.279 --> 00:56:42.200
致力于它，我们赋予我们以及

00:56:39.710 --> 00:56:43.970
我们的汤米部落，但我们还有

00:56:42.200 --> 00:56:47.930
社区里有很多人，所以我们

00:56:43.970 --> 00:56:49.460
有很多社区Apache提交者

00:56:47.930 --> 00:56:53.029
花费很多时间， 

00:56:49.460 --> 00:56:54.619
努力进入微观形象， 

00:56:53.029 --> 00:56:57.859
的全部目标是要真的真的

00:56:54.619 --> 00:56:59.869
以社区为导向，所以任何人

00:56:57.859 --> 00:57:00.920
想要参与其中的人可以

00:56:59.869 --> 00:57:03.349
可以参与其中

00:57:00.920 --> 00:57:04.730
实际上站在展厅里

00:57:03.349 --> 00:57:07.039
楼下，这样你就可以找到一个

00:57:04.730 --> 00:57:09.759
关于它的更多信息以及如何获得

00:57:07.039 --> 00:57:09.759
参与哦

00:57:10.160 --> 00:57:15.289
在那边放一些过渡是的

00:57:13.339 --> 00:57:17.079
这是1.1的依赖

00:57:15.289 --> 00:57:20.720
当前发行版

00:57:17.079 --> 00:57:24.739
就像我说的1.2迫在眉睫

00:57:20.720 --> 00:57:26.569
目前基本上代码已完成

00:57:24.739 --> 00:57:28.190
您需要知道指定的类型是

00:57:26.569 --> 00:57:30.920
解析并指定所提供的内容，因为

00:57:28.190 --> 00:57:32.930
这只是一个API，没有实际的jar 

00:57:30.920 --> 00:57:34.609
实施但实施

00:57:32.930 --> 00:57:41.359
以与Java相同的方式提供

00:57:34.609 --> 00:57:42.880
由供应商实施，因此

00:57:41.359 --> 00:57:46.369
是您需要做的所有事情

00:57:42.880 --> 00:57:50.509
设置我们的股票行情URL 

00:57:46.369 --> 00:57:52.610
在我们的sse客户类上，所以现在

00:57:50.509 --> 00:57:55.850
我们在那里的问题是

00:57:52.610 --> 00:57:58.790
我们的jax-rs客户需要

00:57:55.850 --> 00:58:00.950
连接到它不知道的URL 

00:57:58.790 --> 00:58:02.690
已经因为你不知道在哪里

00:58:00.950 --> 00:58:06.920
直到它启动，如果

00:58:02.690 --> 00:58:09.200
您所在的社区

00:58:06.920 --> 00:58:11.060
远程服务器可能还不存在

00:58:09.200 --> 00:58:12.410
不知道我们不知道提前

00:58:11.060 --> 00:58:14.270
终点将在哪里

00:58:12.410 --> 00:58:18.350
可能会改变，我们需要对

00:58:14.270 --> 00:58:22.040
因此，配置API为我们提供了

00:58:18.350 --> 00:58:25.010
寻找我们所拥有的财产的能力

00:58:22.040 --> 00:58:26.090
就API而言设置

00:58:25.010 --> 00:58:29.090
三个地方

00:58:26.090 --> 00:58:33.410
那是系统属性环境

00:58:29.090 --> 00:58:37.430
变量和文件中的是

00:58:33.410 --> 00:58:40.730
配置的meta-inf或web-inf 

00:58:37.430 --> 00:58:42.890
财产，所以这是我的完美烂摊子，是的

00:58:40.730 --> 00:58:45.530
在meta-inf中的F目录

00:58:42.890 --> 00:58:48.200
您的应用程序可以创建一个微型

00:58:45.530 --> 00:58:49.550
配置文件具有

00:58:48.200 --> 00:58:51.500
所有这些属性，那就是

00:58:49.550 --> 00:58:53.690
有效的配置源以及每个

00:58:51.500 --> 00:58:55.310
有不同的顺序优先顺序，因此

00:58:53.690 --> 00:58:58.610
你总能知道哪一个是

00:58:55.310 --> 00:59:00.350
将成为首选，所以我们正在注入

00:58:58.610 --> 00:59:02.450
那如何将默认值设置为

00:59:00.350 --> 00:59:05.540
好，这样我们就可以知道

00:59:02.450 --> 00:59:13.270
它不在那里，这就是您所需要的

00:59:05.540 --> 00:59:16.010
去在顶部使用它

00:59:13.270 --> 00:59:18.290
给出了如何实际运行的示例

00:59:16.010 --> 00:59:21.650
我们在那里所做的一切

00:59:18.290 --> 00:59:25.280
股票网络应用程序，这是一个

00:59:21.650 --> 00:59:27.170
微束我们真的在

00:59:25.280 --> 00:59:29.930
项目，我们正在建立一个新的

00:59:27.170 --> 00:59:32.990
用PI桥接我们的微信，但我

00:59:29.930 --> 00:59:37.460
设置微型部署库存

00:59:32.990 --> 00:59:38.990
代码点URL属性作为系统

00:59:37.460 --> 00:59:40.280
财产，然后将其拿起

00:59:38.990 --> 00:59:44.330
通过有效的应用程序

00:59:40.280 --> 00:59:45.830
如果我有一个演示很漂亮，但是有

00:59:44.330 --> 00:59:46.640
我们为之添加的另一个选项

00:59:45.830 --> 00:59:48.230
 pi我们的服务器

00:59:46.640 --> 00:59:50.210
显然我们很熟悉

00:59:48.230 --> 00:59:51.590
如果您没有使用pyro，请与GlassFish一起使用

00:59:50.210 --> 00:59:53.930
服务器呢，你绝对应该

00:59:51.590 --> 00:59:57.020
检查一下，但我们添加了一些额外的功能

00:59:53.930 --> 00:59:59.600
 AAS管理员命令来设置和获取

00:59:57.020 --> 01:00:01.400
冲突属性我之所以如此

00:59:59.600 --> 01:00:03.260
想在这里展示这个

01:00:01.400 --> 01:00:04.460
我们有

01:00:03.260 --> 01:00:06.560
属性名称属性值相当

01:00:04.460 --> 01:00:09.020
清楚，但后来我添加了

01:00:06.560 --> 01:00:11.210
集群，所以我说有三个

01:00:09.020 --> 01:00:14.810
微型配置文件的默认来源

01:00:11.210 --> 01:00:16.790
您可以依赖的配置API 

01:00:14.810 --> 01:00:20.720
微型配置文件的实施是否

01:00:16.790 --> 01:00:21.260
华夫饼干冰温暖的自由或汤米或

01:00:20.720 --> 01:00:24.290
帕亚拉

01:00:21.260 --> 01:00:26.900
他们在这里很可靠，尽管我们已经

01:00:24.290 --> 01:00:28.190
有集群的来源，这意味着

01:00:26.900 --> 01:00:30.140
那么所有这些属性可以是

01:00:28.190 --> 01:00:32.450
储存在淡褐色铸模中，然后

01:00:30.140 --> 01:00:34.550
分发给任何其他集群成员

01:00:32.450 --> 01:00:37.970
以后再加入该集群

01:00:34.550 --> 01:00:41.090
时间点，因此一旦设置

01:00:37.970 --> 01:00:42.680
加入的任何其他成员将获得一个

01:00:41.090 --> 01:00:46.130
存储该群集，以便如果您

01:00:42.680 --> 01:00:47.540
最初的成员​​是财产

01:00:46.130 --> 01:00:50.090
仍然设置并且仍可用于

01:00:47.540 --> 01:00:51.470
您的应用程序再次

01:00:50.090 --> 01:00:53.900
看着正在使用的东西

01:00:51.470 --> 01:00:55.940
就像我们在集群注释中

01:00:53.900 --> 01:00:58.040
接近单身，仍然会

01:00:55.940 --> 01:01:00.260
当那个单身人士可用时

01:00:58.040 --> 01:01:06.520
稍后开始，所以相当

01:01:00.260 --> 01:01:08.720
干净利落的便利方法

01:01:06.520 --> 01:01:13.750
我真的真的希望提前

01:01:08.720 --> 01:01:13.750
你有50分钟的问题

01:01:14.320 --> 01:01:18.620
也许我会准备不说话

01:01:16.730 --> 01:01:20.180
下次演示，是的，我想

01:01:18.620 --> 01:01:23.330
回顾一下我们所说的话

01:01:20.180 --> 01:01:26.360
我主要是强调

01:01:23.330 --> 01:01:29.060
我所说的很多

01:01:26.360 --> 01:01:32.150
除了API实际上是

01:01:29.060 --> 01:01:34.970
在Java 7之前的四年之间

01:01:32.150 --> 01:01:38.120
是乔佛里宣布到今年

01:01:34.970 --> 01:01:40.370
宣布8一切还没有到来

01:01:38.120 --> 01:01:43.250
从Java EE规范本身来看

01:01:40.370 --> 01:01:45.620
从供应商那里看到什么

01:01:43.250 --> 01:01:48.560
发生在他们周围的世界中

01:01:45.620 --> 01:01:52.130
对这种变化做出反应，所以Java 

01:01:48.560 --> 01:01:53.390
 EE适应性极强， 

01:01:52.130 --> 01:01:55.250
已创建的供应商本身

01:01:53.390 --> 01:01:57.470
这些新发行版我什至春天

01:01:55.250 --> 01:02:02.150
显然不是Java EE，但是

01:01:57.470 --> 01:02:05.300
使用y2 Java API甚至是

01:02:02.150 --> 01:02:07.640
影响力有助于推动

01:02:05.300 --> 01:02:09.680
事情向前发展，即使那

01:02:07.640 --> 01:02:12.630
肯定有很大的延迟

01:02:09.680 --> 01:02:14.400
在Java 8版本中

01:02:12.630 --> 01:02:16.110
这个行业并没有停止发展， 

01:02:14.400 --> 01:02:19.500
发生了很多变化

01:02:16.110 --> 01:02:21.420
由疾病实施和

01:02:19.500 --> 01:02:23.370
最后就是Eclipse的微概要文件

01:02:21.420 --> 01:02:25.680
我认为那里有很多

01:02:23.370 --> 01:02:28.380
目前正在发生的创新

01:02:25.680 --> 01:02:29.910
如果有很多有趣的规格

01:02:28.380 --> 01:02:33.690
你真的很感兴趣

01:02:29.910 --> 01:02:35.150
我的微服务部署真的

01:02:33.690 --> 01:02:37.980
很高兴看看，如果你下去

01:02:35.150 --> 01:02:39.540
我认为展览中心在任何时候

01:02:37.980 --> 01:02:41.370
会议期间， 

01:02:39.540 --> 01:02:44.190
那里发生的Micra个人资料演示

01:02:41.370 --> 01:02:46.920
所以去检查真的很好

01:02:44.190 --> 01:02:49.950
希望我认为其中一些

01:02:46.920 --> 01:02:52.320
演示应包括一些1.2规格，但

01:02:49.950 --> 01:02:55.710
因为它们很新，所以没有很多

01:02:52.320 --> 01:02:57.870
我周围的实现

01:02:55.710 --> 01:03:00.990
认为这就是我所拥有的一切

01:02:57.870 --> 01:03:02.970
没有笔记本电脑CI的一切

01:03:00.990 --> 01:03:03.960
抱歉，事情还没有解决

01:03:02.970 --> 01:03:07.050
正如计划

01:03:03.960 --> 01:03:12.980
是的，我们有什么疑问吗

01:03:07.050 --> 01:03:12.980
对他们来说是很多时间，太好了

01:03:16.940 --> 01:03:23.210
对对对

01:03:35.440 --> 01:03:43.609
好吧，我知道抱歉，是的，所以我会

01:03:41.240 --> 01:03:45.140
重复问题，以便问题

01:03:43.609 --> 01:03:47.390
是集群的CDI事件总线

01:03:45.140 --> 01:03:49.190
显然是非常热解的

01:03:47.390 --> 01:03:54.470
问题是你是否知道

01:03:49.190 --> 01:03:58.220
任何计划使它像一个

01:03:54.470 --> 01:04:00.740
我知道适当的标准化功能

01:03:58.220 --> 01:04:02.570
 CDI带来异步事件

01:04:00.740 --> 01:04:07.550
桌子比我了解的更多

01:04:02.570 --> 01:04:08.390
但是我的天哪不是同一件事

01:04:07.550 --> 01:04:11.000
感觉就是

01:04:08.390 --> 01:04:13.820
难以标准化， 

01:04:11.000 --> 01:04:15.980
原因是，即使J 

01:04:13.820 --> 01:04:19.099
提供的缓存规范

01:04:15.980 --> 01:04:22.520
淡褐色种姓实际上不是

01:04:19.099 --> 01:04:24.050
包括任何群集，我认为在那里

01:04:22.520 --> 01:04:27.260
胃口不大

01:04:24.050 --> 01:04:30.320
从编写规范的人包括

01:04:27.260 --> 01:04:36.470
集群技术的一部分

01:04:30.320 --> 01:04:38.510
实施，所以是的

01:04:36.470 --> 01:04:41.330
如果可能的话，我会感到惊讶

01:04:38.510 --> 01:04:49.270
是一件有用的事情，但是

01:04:41.330 --> 01:04:49.270
如果是的话会感到惊讶

01:04:49.450 --> 01:04:55.369
绝对是的，那是

01:04:51.530 --> 01:04:58.790
在球员显然我们正在寻找

01:04:55.369 --> 01:05:00.859
与PI或a5的意图是

01:04:58.790 --> 01:05:04.369
删除旧的域模型并转到

01:05:00.859 --> 01:05:06.470
更倾向于域数据结构

01:05:04.369 --> 01:05:08.690
是的，它将更像

01:05:06.470 --> 01:05:10.160
我知道我认为顶点非常

01:05:08.690 --> 01:05:12.530
相似之处在于他们使用淡褐色

01:05:10.160 --> 01:05:14.359
好吧，我不知道他们有没有

01:05:12.530 --> 01:05:18.710
类似的技术

01:05:14.359 --> 01:05:20.990
群集的CDI事件，但它们又起什么作用

01:05:18.710 --> 01:05:23.420
不知道会发生什么事情

01:05:20.990 --> 01:05:24.830
认为他们显然有消息

01:05:23.420 --> 01:05:27.140
但是他们的通讯时间

01:05:24.830 --> 01:05:30.200
消息传递机制基于

01:05:27.140 --> 01:05:31.730
发送JSON数据，以便可以

01:05:30.200 --> 01:05:33.800
分发到任何一种语言

01:05:31.730 --> 01:05:36.140
因为顶点不仅支持Java 

01:05:33.800 --> 01:05:39.740
但是Java Script Groovy和其他

01:05:36.140 --> 01:05:41.160
语言，但他们也依靠

01:05:39.740 --> 01:05:43.770
处理演员平等

01:05:41.160 --> 01:05:45.510
像分布式数据等级

01:05:43.770 --> 01:05:46.320
有趣，因为很容易

01:05:45.510 --> 01:05:48.420
建立

01:05:46.320 --> 01:05:50.460
它们非常复杂，所以您不会

01:05:48.420 --> 01:05:54.030
想要在您的应用程序中编写它们

01:05:50.460 --> 01:05:56.070
您宁愿使用现有的经过验证的

01:05:54.030 --> 01:05:57.990
他们提供了很多解决方案

01:05:56.070 --> 01:06:02.280
有趣的功能，它们非常

01:05:57.990 --> 01:06:04.020
易于使用和显示，以及

01:06:02.280 --> 01:06:06.960
城市甚至被我们嗡嗡作响

01:06:04.020 --> 01:06:09.690
我们服务器上的麦克风演示

01:06:06.960 --> 01:06:12.320
集成一个多么容易

01:06:09.690 --> 01:06:16.260
 zorka的解决方案

01:06:12.320 --> 01:06:19.680
分发我们是CDI的消息

01:06:16.260 --> 01:06:23.430
实际上，有效的API仅

01:06:19.680 --> 01:06:25.590
两个注释，所以您可以和这两个

01:06:23.430 --> 01:06:26.130
注释基本上是

01:06:25.590 --> 01:06:28.800
 CDI 

01:06:26.130 --> 01:06:31.020
所以即使实现不是

01:06:28.800 --> 01:06:34.020
那里有伊朗人的申请

01:06:31.020 --> 01:06:35.760
使用CDI的应用程序甚至可以让您老大

01:06:34.020 --> 01:06:38.550
在其他应用程序服务器上运行

01:06:35.760 --> 01:06:42.710
您仍然可以插入序列号

01:06:38.550 --> 01:06:45.630
扩展或只是CDI观察员，以及

01:06:42.710 --> 01:06:48.030
插入您自己的解决方案

01:06:45.630 --> 01:06:50.220
根据榛树种姓， 

01:06:48.030 --> 01:06:54.750
由我们的服务器创建和创建

01:06:50.220 --> 01:06:58.110
微型有内置的，但是

01:06:54.750 --> 01:07:03.570
只需在这两个中使用PI API 

01:06:58.110 --> 01:07:07.500
限定词，您只需放置依赖项

01:07:03.570 --> 01:07:10.080
在这两个预选赛上，然后

01:07:07.500 --> 01:07:12.690
可以插入自己的观察者

01:07:10.080 --> 01:07:14.460
如果只是分发您自己的消息

01:07:12.690 --> 01:07:18.150
 PI R使它变得容易，因为它提供了

01:07:14.460 --> 01:07:20.790
这个清单给你，但它展示了

01:07:18.150 --> 01:07:24.330
插入其他东西有多容易

01:07:20.790 --> 01:07:26.430
借助CDI，CDI API非常

01:07:24.330 --> 01:07:29.490
非常容易使用，非常简单

01:07:26.430 --> 01:07:32.210
而且很容易插入另外两个

01:07:29.490 --> 01:07:32.210
扩展名

01:07:34.939 --> 01:07:40.439
是的，我猜那里还有其他人

01:07:37.769 --> 01:07:49.459
有问题或者我们有几个

01:07:40.439 --> 01:07:49.459
我们可以随身携带的更多东西

01:07:51.229 --> 01:07:54.229
是的

01:08:00.140 --> 01:08:06.809
 [音乐] 

01:08:03.170 --> 01:08:09.959
是的，所以我以为自己

01:08:06.809 --> 01:08:11.369
我特别不知道为什么不是这样

01:08:09.959 --> 01:08:13.739
如果你也是他们的一半

01:08:11.369 --> 01:08:15.299
我想亲自熟悉一下

01:08:13.739 --> 01:08:16.440
我就是这样想的

01:08:15.299 --> 01:08:24.000
能够看到你直接向亚尼尔撒谎

01:08:16.440 --> 01:08:29.069
因为我会很好

01:08:24.000 --> 01:08:32.339
是的，我是说实际上

01:08:29.069 --> 01:08:33.900
安德烈指出我有一天

01:08:32.339 --> 01:08:36.509
在演示文稿中没有包括

01:08:33.900 --> 01:08:38.279
显然服务和事件已经得到

01:08:36.509 --> 01:08:42.119
自己方便的序列化方法

01:08:38.279 --> 01:08:46.020
也可以转换成Jason格式

01:08:42.119 --> 01:08:54.109
很多这样的几乎就像我一样

01:08:46.020 --> 01:08:59.309
我认为重复的事情是

01:08:54.109 --> 01:09:01.710
也许杰森的格式有点

01:08:59.309 --> 01:09:04.770
与湿疹和水罐B不同的是

01:09:01.710 --> 01:09:09.449
专为轴突而设计

01:09:04.770 --> 01:09:11.969
缺乏一些对极端情况的支持

01:09:09.449 --> 01:09:14.639
在Jason中，这就是我创建它们的原因

01:09:11.969 --> 01:09:17.449
创建杰森是为了支持它

01:09:14.639 --> 01:09:22.679
头等公民支持阿泽姆和

01:09:17.449 --> 01:09:25.290
一些我不是的应用服务器

01:09:22.679 --> 01:09:28.920
肯定有偏见，但有些折衷

01:09:25.290 --> 01:09:33.089
杰克的B批注中的服务器支持

01:09:28.920 --> 01:09:36.599
将对象转换为JSON然后返回

01:09:33.089 --> 01:09:41.309
但这仅限于您

01:09:36.599 --> 01:09:43.980
每个案例用例都很难达到DC 

01:09:41.309 --> 01:09:46.619
得到它的结果，你期望

01:09:43.980 --> 01:09:49.290
它会工作，但如果您真的想要

01:09:46.619 --> 01:09:53.819
以符合特定格式

01:09:49.290 --> 01:09:56.849
 JSON序列化数据很难

01:09:53.819 --> 01:10:00.000
正确的字段名称

01:09:56.849 --> 01:10:02.309
只是创建一个随机的随机字段，但

01:10:00.000 --> 01:10:05.369
显然没有JSON的架构

01:10:02.309 --> 01:10:08.369
但是如果有的话就很难适应

01:10:05.369 --> 01:10:09.880
模式并使其针对

01:10:08.369 --> 01:10:14.080
这个架构

01:10:09.880 --> 01:10:14.500
因此可以使用Jax B， 

01:10:14.080 --> 01:10:18.760
用过的

01:10:14.500 --> 01:10:21.400
这不是标准的Standa通常

01:10:18.760 --> 01:10:25.140
它被标准化为反对

01:10:21.400 --> 01:10:27.880
 XML，但也有一些应用服务器

01:10:25.140 --> 01:10:32.730
可以使用杰克的B注释来

01:10:27.880 --> 01:10:36.600
生产杰森，也反对杰森

01:10:32.730 --> 01:10:39.820
但它缺少一些功能， 

01:10:36.600 --> 01:10:43.150
因为juggs B已经是Java的一部分

01:10:39.820 --> 01:10:46.510
语言不仅是Java EE 

01:10:43.150 --> 01:10:48.430
很难扩展Jack's B并添加

01:10:46.510 --> 01:10:50.770
他们有一些更多的功能

01:10:48.430 --> 01:10:54.040
创建一个新的规范是

01:10:50.770 --> 01:10:56.080
专为杰森（Jason）量身定制

01:10:54.040 --> 01:10:59.110
猜想另一点是我们只是

01:10:56.080 --> 01:11:02.800
我认为当杰森B被提议时

01:10:59.110 --> 01:11:05.380
它被故意限制为

01:11:02.800 --> 01:11:08.620
避免你知道变得如此巨大

01:11:05.380 --> 01:11:11.590
试图让你知道的东西

01:11:08.620 --> 01:11:13.120
成为我想知道的所有人的一切

01:11:11.590 --> 01:11:14.860
我知道她有一个决定

01:11:13.120 --> 01:11:17.490
限制它让你知道

01:11:14.860 --> 01:11:21.010
一件事做好

01:11:17.490 --> 01:11:22.150
是的，所以理想情况下，我希望看到

01:11:21.010 --> 01:11:23.890
只是你知道的东西

01:11:22.150 --> 01:11:26.260
相同的注释和相同的内容

01:11:23.890 --> 01:11:29.640
你可以只知道或插入

01:11:26.260 --> 01:11:31.720
您想要的任何数据格式，但是

01:11:29.640 --> 01:11:35.350
我还不足以让开发人员知道

01:11:31.720 --> 01:11:37.030
这是多么可行，所以也许

01:11:35.350 --> 01:11:39.340
我有一个特别复杂的问题

01:11:37.030 --> 01:11:42.780
解决你知道的，安德烈斯给了一些

01:11:39.340 --> 01:11:42.780
复杂的例子

01:11:49.770 --> 01:11:52.770
是

01:11:56.269 --> 01:12:00.489
是的，微型配置文件配置是

01:12:09.000 --> 01:12:16.180
是的，这很有可能，所以这是

01:12:13.360 --> 01:12:19.450
我几乎用的东西

01:12:16.180 --> 01:12:21.330
与演示，但我认为，如果我

01:12:19.450 --> 01:12:25.630
做到了，那我可能没时间了

01:12:21.330 --> 01:12:28.630
具有讽刺意味的是，是的，我们基本上

01:12:25.630 --> 01:12:30.610
在办公室里讨论这个，但是

01:12:28.630 --> 01:12:33.100
我在这里得到的用例是

01:12:30.610 --> 01:12:34.660
我们不知道这个URL的嘶嘶声

01:12:33.100 --> 01:12:37.590
提前提供微服务，因此我们需要

01:12:34.660 --> 01:12:40.540
有种运行时间来发现它

01:12:37.590 --> 01:12:43.360
但随后的远程微服务

01:12:40.540 --> 01:12:45.610
可能还不知道这是未来的事情

01:12:43.360 --> 01:12:48.040
时间，所以实际上我们需要做的是

01:12:45.610 --> 01:12:51.010
有一个远程设置

01:12:48.040 --> 01:12:54.310
现在在某些配置源中的属性

01:12:51.010 --> 01:13:02.200
有一家公司我认为配置

01:12:54.310 --> 01:13:04.210
集线器，就像服务器，您可以

01:13:02.200 --> 01:13:06.670
知道您可以从中设置和获取属性

01:13:04.210 --> 01:13:09.550
因此，配置API是故意的

01:13:06.670 --> 01:13:13.630
我待会儿让安德烈谈一谈

01:13:09.550 --> 01:13:15.520
帮助指定它，或者有一个非常

01:13:13.630 --> 01:13:18.430
避免做出故意决定

01:13:15.520 --> 01:13:21.640
所以我们是他们希望它成为

01:13:18.430 --> 01:13:25.540
专门为避免事情而只读

01:13:21.640 --> 01:13:29.650
被设置，所以有可能做

01:13:25.540 --> 01:13:31.930
这让您有点矛盾

01:13:29.650 --> 01:13:33.219
通过代码动态属性

01:13:31.930 --> 01:13:37.690
您需要做的就是创建自己的

01:13:33.219 --> 01:13:40.020
配置源权限，然后在

01:13:37.690 --> 01:13:43.150
这样使用可用的SPI 

01:13:40.020 --> 01:13:46.330
所以我不想做的原因

01:13:43.150 --> 01:13:49.150
那是因为它移出了

01:13:46.330 --> 01:13:51.610
配置范围

01:13:49.150 --> 01:13:53.530
应用并成为服务

01:13:51.610 --> 01:13:58.120
有效地注册，所以您知道在

01:13:53.530 --> 01:14:02.680
 CD或其他我刚发行的CD 

01:13:58.120 --> 01:14:04.930
可能忘记了其他任何控制台

01:14:02.680 --> 01:14:07.239
似乎超出了

01:14:04.930 --> 01:14:10.050
真正的配置是什么，所以如果您不

01:14:07.239 --> 01:14:12.240
你的荣誉正确的妻子

01:14:10.050 --> 01:14:16.260
不知道我是否可以添加

01:14:12.240 --> 01:14:18.570
好吧，你没有说，只是

01:14:16.260 --> 01:14:21.030
配置API，它是micro的一部分

01:14:18.570 --> 01:14:23.040
个人资料有两个不同

01:14:21.030 --> 01:14:25.380
组件之一是用于阅读

01:14:23.040 --> 01:14:28.080
配置，这提供了两个

01:14:25.380 --> 01:14:31.580
不同的API仅用于播放Java 

01:14:28.080 --> 01:14:33.870
具有静态和静态方法的API 

01:14:31.580 --> 01:14:37.530
序列化，以便您可以注入

01:14:33.870 --> 01:14:42.750
值，但也有扩展名或

01:14:37.530 --> 01:14:44.820
接口中的SPI，您可以提供

01:14:42.750 --> 01:14:46.260
您自己的配置源

01:14:44.820 --> 01:14:48.330
您的应用程序，因此您只是

01:14:46.260 --> 01:14:52.320
有我的时候实现接口

01:14:48.330 --> 01:14:56.130
认为其中一种方法是得到

01:14:52.320 --> 01:14:58.560
获取值，获取键的名称

01:14:56.130 --> 01:15:01.860
然后您从中提供价值

01:14:58.560 --> 01:15:04.530
对象和配置机制

01:15:01.860 --> 01:15:07.290
检测到您的实现

01:15:04.530 --> 01:15:09.390
通过第二个服务定位器配置源

01:15:07.290 --> 01:15:12.330
所以我们需要创建一个额外的

01:15:09.390 --> 01:15:16.440
今天要查找的服务文件进行注册

01:15:12.330 --> 01:15:18.300
此实现和配置

01:15:16.440 --> 01:15:21.830
是具体的哦，这不是规范

01:15:18.300 --> 01:15:25.920
就jsr而言，但配置

01:15:21.830 --> 01:15:28.770
机制指定这些的顺序

01:15:25.920 --> 01:15:30.840
来源，因此有默认值或配置

01:15:28.770 --> 01:15:33.690
阅读证明者提供的资料

01:15:30.840 --> 01:15:36.990
来自属性系统属性的值

01:15:33.690 --> 01:15:41.580
从环境变量，我有

01:15:36.990 --> 01:15:47.910
一些定单值或一些指数

01:15:41.580 --> 01:15:49.470
订购这些配置源是是

01:15:47.910 --> 01:15:52.290
你可以改变他们你可以

01:15:49.470 --> 01:15:54.990
改变他们，然后基本上

01:15:52.290 --> 01:15:57.780
来源是是否要求更高的顺序

01:15:54.990 --> 01:16:01.080
首先，如果该值不存在

01:15:57.780 --> 01:16:04.170
询问其他来源，直到找到

01:16:01.080 --> 01:16:08.010
因此您可以提供一个配置源

01:16:04.170 --> 01:16:09.900
高高阶高优先级，您

01:16:08.010 --> 01:16:11.490
可以覆盖那里的任何值，它是

01:16:09.900 --> 01:16:13.970
仍然在应用程序中

01:16:11.490 --> 01:16:18.030
向服务注册

01:16:13.970 --> 01:16:19.480
服务文件的定位器机制

01:16:18.030 --> 01:16:21.070
和

01:16:19.480 --> 01:16:23.680
它会做什么配置

01:16:21.070 --> 01:16:27.489
检测配置源将询问它

01:16:23.680 --> 01:16:29.080
为价值，它将提供

01:16:27.489 --> 01:16:39.090
他们在需要时

01:16:29.080 --> 01:16:39.090
申请是

01:16:49.420 --> 01:16:56.120
好吧，这是一个全新的体验

01:16:53.239 --> 01:16:57.380
它实际上是演示的功能

01:16:56.120 --> 01:16:59.330
我要去跑什么

01:16:57.380 --> 01:17:02.900
是一个问题，我很抱歉我应该

01:16:59.330 --> 01:17:05.540
这是正确的问题

01:17:02.900 --> 01:17:12.530
哪个服务器在集群中的哪个节点

01:17:05.540 --> 01:17:15.170
是主人是正确的东西

01:17:12.530 --> 01:17:17.449
希西家的优势是

01:17:15.170 --> 01:17:19.070
为什么我说这很复杂，你呢

01:17:17.449 --> 01:17:22.219
不想写它是一个

01:17:19.070 --> 01:17:25.310
分布式内存或分布式数据

01:17:22.219 --> 01:17:28.219
集群，所以它没有一个概念

01:17:25.310 --> 01:17:30.199
您刚刚从其连接的主人

01:17:28.219 --> 01:17:32.870
从一个节点甚至从一个客户端

01:17:30.199 --> 01:17:35.659
不属于集群，您可以

01:17:32.870 --> 01:17:38.090
将数据发送到那里，并且均匀地

01:17:35.659 --> 01:17:40.190
分布在整个集群中的是

01:17:38.090 --> 01:17:43.310
支持数据分发和

01:17:40.190 --> 01:17:46.580
复制，所以我认为但如果全部

01:17:43.310 --> 01:17:49.400
将数据复制三遍，以便

01:17:46.580 --> 01:17:53.000
总是至少在三个音符上

01:17:49.400 --> 01:17:55.580
当任何一个节点出现故障时， 

01:17:53.000 --> 01:17:58.460
分布，以便再次在三个

01:17:55.580 --> 01:18:00.440
不同的节点，所以它总是在那里

01:17:58.460 --> 01:18:02.389
没有单点故障

01:18:00.440 --> 01:18:05.870
有一个可以降低的成本

01:18:02.389 --> 01:18:08.360
任何至少有一个音符

01:18:05.870 --> 01:18:10.460
如果您有节点，则数据在那里

01:18:08.360 --> 01:18:15.350
节点上有足够的内存来存储

01:18:10.460 --> 01:18:17.659
数据，因此足以发送

01:18:15.350 --> 01:18:20.600
来自节点的数据并被分发

01:18:17.659 --> 01:18:22.340
那就没有主人了

01:18:20.600 --> 01:18:23.420
如果数据不可用，则可用

01:18:22.340 --> 01:18:25.760
笔记

01:18:23.420 --> 01:18:29.800
你好卡会问其他节点

01:18:25.760 --> 01:18:29.800
带来意愿并从他们那里带来数据

01:18:30.250 --> 01:18:37.960
是的，这是一个友好的功能，因此

01:18:33.530 --> 01:18:43.790
它甚至还没有发布，我想我们

01:18:37.960 --> 01:18:49.600
根据测试的方式，这是一个

01:18:43.790 --> 01:18:52.370
是的，是的，所以

01:18:49.600 --> 01:18:54.350
显然我得到它的方式

01:18:52.370 --> 01:18:55.870
我的演示，您从多个

01:18:54.350 --> 01:18:57.920
这些股票行情

01:18:55.870 --> 01:18:59.719
约鲁巴罐子，他们都有

01:18:57.920 --> 01:19:01.790
应用程序，如果已经有一个

01:18:59.719 --> 01:19:02.810
运行正在运行此单例

01:19:01.790 --> 01:19:05.930
那就没有开始

01:19:02.810 --> 01:19:08.540
 Hib计时器，然后显然

01:19:05.930 --> 01:19:10.900
浪费下来，我想你

01:19:08.540 --> 01:19:15.140
知道分区已设置

01:19:10.900 --> 01:19:16.550
所以现在它来指定一个通知我

01:19:15.140 --> 01:19:18.170
取得了数据的主要副本， 

01:19:16.550 --> 01:19:19.810
然后像周围的备份我不知道

01:19:18.170 --> 01:19:22.460
如何决定要备份哪个

01:19:19.810 --> 01:19:24.980
重新初始化，但是就是这样

01:19:22.460 --> 01:19:29.200
会工作，所以您现在就拥有

01:19:24.980 --> 01:19:35.480
我认为它只是在ejbs上起作用

01:19:29.200 --> 01:19:38.090
但是，是的，我说我们是

01:19:35.480 --> 01:19:43.460
这样做是在CDI上工作

01:19:38.090 --> 01:19:45.440
一开始我也在回答豆子

01:19:43.460 --> 01:19:47.690
我以为是一个不同的问题

01:19:45.440 --> 01:19:50.210
您在询问配置

01:19:47.690 --> 01:19:52.850
冲突源也基于

01:19:50.210 --> 01:19:55.640
带有群集配置的汽车头部

01:19:52.850 --> 01:19:58.850
来源我们在Peyer micro和bi中

01:19:55.640 --> 01:20:00.170
服务器是您可以发送或提供

01:19:58.850 --> 01:20:02.660
来自您其中之一的配置源

01:20:00.170 --> 01:20:04.970
申请发送或发送

01:20:02.660 --> 01:20:06.920
从以下任一配置到群集

01:20:04.970 --> 01:20:08.270
您的节点，然后对所有人可用

01:20:06.920 --> 01:20:13.340
节点，因为它是均匀的

01:20:08.270 --> 01:20:17.000
随该类集群一起分发

01:20:13.340 --> 01:20:19.730
范围在于它更复杂

01:20:17.000 --> 01:20:22.010
因为您需要同步并进行

01:20:19.730 --> 01:20:25.310
确保数据仅存在一次

01:20:22.010 --> 01:20:27.820
而Hisoka也提供锁定

01:20:25.310 --> 01:20:31.790
机制与同步

01:20:27.820 --> 01:20:34.670
原语，所以我们只需要放

01:20:31.790 --> 01:20:38.300
所有这些东西一起提供

01:20:34.670 --> 01:20:41.630
 Java EE API的事情，因为榛树

01:20:38.300 --> 01:20:46.160
凯尔对它不了解

01:20:41.630 --> 01:20:48.860
 Java EE，因此我们本质上想做

01:20:46.160 --> 01:20:52.550
我们在做什么，帝国正在带来

01:20:48.860 --> 01:20:55.610
榛树的所有这些出色功能

01:20:52.550 --> 01:20:58.220
投射到可以轻松实现的水平

01:20:55.610 --> 01:21:00.770
从Java EE应用程序访问

01:20:58.220 --> 01:21:04.420
叙利亚甚至公共汽车都一样

01:21:00.770 --> 01:21:08.030
使用螺旋主题和作为Acosta 

01:21:04.420 --> 01:21:10.580
排队分发数据

01:21:08.030 --> 01:21:13.280
 API非常简单，只有两个

01:21:10.580 --> 01:21:15.230
限定词与CDI相同

01:21:13.280 --> 01:21:18.050
范围只是一个

01:21:15.230 --> 01:21:20.270
范围注释，它提供了这些

01:21:18.050 --> 01:21:27.160
事物的基础或处理方式

01:21:20.270 --> 01:21:27.160
同步好吗其他问题

01:21:28.239 --> 01:21:36.040
不，我想很好，再次感谢您的支持

01:21:32.870 --> 01:21:38.600
和我们在一起，我们几乎可以度过它

01:21:36.040 --> 01:21:41.150
是的，我认为我们实际上有一个演示

01:21:38.600 --> 01:21:43.370
这有点类似于

01:21:41.150 --> 01:21:44.390
 payara站在展厅里

01:21:43.370 --> 01:21:46.910
如果你想来看看

01:21:44.390 --> 01:21:51.520
实际使用树莓的东西

01:21:46.910 --> 01:21:51.520
馅饼，你也来

01:21:53.980 --> 01:21:56.630
 [掌声] 

