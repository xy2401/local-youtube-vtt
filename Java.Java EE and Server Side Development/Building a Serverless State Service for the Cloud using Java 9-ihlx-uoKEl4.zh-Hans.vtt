WEBVTT
Kind: captions
Language: zh-Hans

00:00:01.040 --> 00:00:05.790
嗨，我在本次会议上被烫伤， 

00:00:04.410 --> 00:00:10.070
打算和您谈谈建立一个

00:00:05.790 --> 00:00:13.469
云服务状态服务

00:00:10.070 --> 00:00:15.800
我一直在做的关于我的事

00:00:13.469 --> 00:00:19.859
软件开发超过25年

00:00:15.800 --> 00:00:22.410
您可能从Java EE领域了解我

00:00:19.859 --> 00:00:24.960
我是JavaServer Faces的规范负责人

00:00:22.410 --> 00:00:28.769
和servlet很多年了，我非常

00:00:24.960 --> 00:00:31.769
很高兴能帮助交出那些

00:00:28.769 --> 00:00:33.920
 Eclipse项目的EE项目

00:00:31.769 --> 00:00:35.969
周杰伦，我真的很兴奋

00:00:33.920 --> 00:00:38.640
社区将承担这些

00:00:35.969 --> 00:00:41.399
前进的事情，我们有些激动

00:00:38.640 --> 00:00:43.950
我经常去计划的事情

00:00:41.399 --> 00:00:45.750
在会议上做演讲者，我经常喜欢

00:00:43.950 --> 00:00:49.950
每当我去时都会教一个工作坊

00:00:45.750 --> 00:00:51.870
会议以及我现在

00:00:49.950 --> 00:00:53.039
很高兴在这种状态下工作

00:00:51.870 --> 00:00:56.340
我正在与您谈论的服务

00:00:53.039 --> 00:00:59.390
今天我们有一支很棒的团队

00:00:56.340 --> 00:01:02.699
甲骨文一致性背后的人

00:00:59.390 --> 00:01:05.780
这是甲骨文长期以来的产品

00:01:02.699 --> 00:01:08.700
与我们取得了巨大的成功

00:01:05.780 --> 00:01:10.680
客户并自己运行

00:01:08.700 --> 00:01:13.619
为了各种商业目的，我们

00:01:10.680 --> 00:01:16.290
继续，当我们谈论更多

00:01:13.619 --> 00:01:20.610
关于这一点，我写了一个

00:01:16.290 --> 00:01:23.790
麦格劳-希尔的几本书，所以让我们

00:01:20.610 --> 00:01:25.530
转到下一张幻灯片，这是我们的

00:01:23.790 --> 00:01:28.320
无聊的安全港声明，但非常

00:01:25.530 --> 00:01:30.140
在这次会议上很重要，因为我

00:01:28.320 --> 00:01:32.759
将向您显示代码和api 

00:01:30.140 --> 00:01:35.700
但这仍在发展中，因此我们

00:01:32.759 --> 00:01:40.290
还没有我们的最终表格

00:01:35.700 --> 00:01:42.049
所以期望它能改变这些

00:01:40.290 --> 00:01:44.850
没用的东西的图片

00:01:42.049 --> 00:01:48.030
用巧克力做的咖啡壶

00:01:44.850 --> 00:01:49.710
显然融化，汤匙，你

00:01:48.030 --> 00:01:52.159
抱歉，你不能

00:01:49.710 --> 00:01:54.869
拿起

00:01:52.159 --> 00:01:56.670
你真的不能强迫的水壶

00:01:54.869 --> 00:01:58.649
东西从方轮

00:01:56.670 --> 00:02:03.929
某些东西的原型例子

00:01:58.649 --> 00:02:07.640
在软件中没有用，有很多

00:02:03.929 --> 00:02:11.250
关于这样做的嗡嗡声和合理的嗡嗡声

00:02:07.640 --> 00:02:12.780
无状态服务，因为我们面对现实

00:02:11.250 --> 00:02:14.660
国家确实带来了很多

00:02:12.780 --> 00:02:17.989
您必须处理的问题

00:02:14.660 --> 00:02:21.140
您必须处理的并发问题

00:02:17.989 --> 00:02:24.329
您必须应对的可变性

00:02:21.140 --> 00:02:26.730
真正的可扩展性问题

00:02:24.329 --> 00:02:28.200
源于必须与国家打交道

00:02:26.730 --> 00:02:32.610
关于无状态，有很多话要说

00:02:28.200 --> 00:02:34.829
哦，别哭了

00:02:32.610 --> 00:02:37.319
宝贝在这里，你可以没有状态怎么办

00:02:34.829 --> 00:02:41.819
好人都清楚

00:02:37.319 --> 00:02:44.090
无状态系统的巨大进步

00:02:41.819 --> 00:02:46.829
基本上可以将输入转换为输出

00:02:44.090 --> 00:02:50.459
这就是纯函数所做的正确的事情

00:02:46.829 --> 00:02:53.129
从数学意义上讲

00:02:50.459 --> 00:02:54.870
建立软件应用程序以

00:02:53.129 --> 00:02:57.630
处理状态，您可以使

00:02:54.870 --> 00:02:59.459
呼叫者的问题，因为我们称之为

00:02:57.630 --> 00:03:03.930
你刚刚通过的热土豆问题

00:02:59.459 --> 00:03:07.799
在您做某事时声明或

00:03:03.930 --> 00:03:09.900
您可以将状态外部化

00:03:07.799 --> 00:03:11.130
大多数人使用的方法

00:03:09.900 --> 00:03:13.200
生产，这确实是

00:03:11.130 --> 00:03:14.819
我们在这里提倡的方法

00:03:13.200 --> 00:03:19.349
与国家服务

00:03:14.819 --> 00:03:20.880
当您将问题外部化时

00:03:19.349 --> 00:03:24.900
这样做是因为您必须真正拥有

00:03:20.880 --> 00:03:27.480
完全一致的系统

00:03:24.900 --> 00:03:29.639
表现也非常好，我相信

00:03:27.480 --> 00:03:33.900
我正在谈论的这个国家服务

00:03:29.639 --> 00:03:36.419
在我们之前，你就是这两个东西

00:03:33.900 --> 00:03:39.599
进入状态，让我们谈谈状态和

00:03:36.419 --> 00:03:42.900
无服务器无服务器本身有点

00:03:39.599 --> 00:03:45.810
一个营销术语，实际上意味着

00:03:42.900 --> 00:03:48.209
仍然有服务器，但是服务器

00:03:45.810 --> 00:03:50.970
是别人的问题，我非常

00:03:48.209 --> 00:03:52.919
喜欢提及别人的

00:03:50.970 --> 00:03:56.099
旅行者的问题领域

00:03:52.919 --> 00:03:57.810
银河指南在这里别人的

00:03:56.099 --> 00:03:59.220
问题领域更简单，更多

00:03:57.810 --> 00:04:00.750
有效，而且可以运行

00:03:59.220 --> 00:04:02.939
一次充电超过100年

00:04:00.750 --> 00:04:04.530
电池，这是来自旅行者的

00:04:02.939 --> 00:04:05.700
星系指南，你直立到

00:04:04.530 --> 00:04:07.680
别人的问题

00:04:05.700 --> 00:04:09.599
周围的东西你不想要任何人

00:04:07.680 --> 00:04:11.520
看到，因为当他们看到它时

00:04:09.599 --> 00:04:14.450
真的就像我不想弄乱

00:04:11.520 --> 00:04:17.489
这是别人的问题

00:04:14.450 --> 00:04:19.440
回到我们一直在做的事情

00:04:17.489 --> 00:04:22.410
在软件和商业软件中

00:04:19.440 --> 00:04:24.930
永远是不懈的追求

00:04:22.410 --> 00:04:27.150
允许开发人员专注于业务

00:04:24.930 --> 00:04:29.220
我们一直试图减少的逻辑

00:04:27.150 --> 00:04:37.130
因为我们

00:04:29.220 --> 00:04:39.870
发明这种想法的锅炉是分开的

00:04:37.130 --> 00:04:42.150
你需要的东西要点

00:04:39.870 --> 00:04:43.950
您的业​​务逻辑从

00:04:42.150 --> 00:04:46.310
您允许您使用的实际业务逻辑

00:04:43.950 --> 00:04:48.740
专注于核心业务逻辑和

00:04:46.310 --> 00:04:51.060
这可以追溯到

00:04:48.740 --> 00:04:53.880
编程语言的想法

00:04:51.060 --> 00:04:56.930
将核心语言与

00:04:53.880 --> 00:05:00.210
您知道它开始的运行时库

00:04:56.930 --> 00:05:03.000
可能在C之前，但是C真的很好

00:05:00.210 --> 00:05:05.040
例子C如此接近开创性

00:05:03.000 --> 00:05:06.990
我在大学有CS教授的语言

00:05:05.040 --> 00:05:09.270
你会说C是汇编语言

00:05:06.990 --> 00:05:12.600
那是NASA的可移植声明

00:05:09.270 --> 00:05:14.460
这是一个准确的陈述

00:05:12.600 --> 00:05:18.360
设置核心语言的分离

00:05:14.460 --> 00:05:20.220
到

00:05:18.360 --> 00:05:23.600
企业软件世界和

00:05:20.220 --> 00:05:25.979
特别是在Java中，而不仅仅是Java 

00:05:23.600 --> 00:05:28.740
我们可以说无服务器

00:05:25.979 --> 00:05:32.240
是依赖关系的逻辑扩展

00:05:28.740 --> 00:05:35.640
注入，所以依赖注入是

00:05:32.240 --> 00:05:37.979
它坐在那里你知道

00:05:35.640 --> 00:05:39.840
最先进的技术让您

00:05:37.979 --> 00:05:43.380
将业务逻辑与一切分离

00:05:39.840 --> 00:05:46.770
否则在2002年脱颖而出

00:05:43.380 --> 00:05:50.010
春季JSF的Java世界

00:05:46.770 --> 00:05:52.020
与2004年同一时间和

00:05:50.010 --> 00:05:53.820
依赖注入是你有你的

00:05:52.020 --> 00:05:56.100
核心代码，您只是说您知道

00:05:53.820 --> 00:05:57.330
注入业务逻辑，您就可以

00:05:56.100 --> 00:06:00.660
业务逻辑和注入

00:05:57.330 --> 00:06:05.550
它需要的依赖

00:06:00.660 --> 00:06:07.590
这有明显的好处测试

00:06:05.550 --> 00:06:09.660
可测试性就是其中之一，因为您

00:06:07.590 --> 00:06:12.140
您的核心代码可以在不同的位置运行

00:06:09.660 --> 00:06:14.840
测试上下文中的上下文

00:06:12.140 --> 00:06:16.760
运行时上下文，在每种情况下，您

00:06:14.840 --> 00:06:20.660
有不同的依赖关系

00:06:16.760 --> 00:06:23.450
示例对象，这是进一步

00:06:20.660 --> 00:06:28.550
 2009年在Java世界中标准化

00:06:23.450 --> 00:06:32.450
当我们进行集装箱运输时，我很抱歉

00:06:28.550 --> 00:06:34.130
当我们有广告注入jsr 3:30这

00:06:32.450 --> 00:06:37.840
标准化依赖概念

00:06:34.130 --> 00:06:40.190
注射随着时间的推移进一步发展

00:06:37.840 --> 00:06:43.220
对坦纳来说，是一个罪恶开始

00:06:40.190 --> 00:06:47.150
在2014年左右流行，这是

00:06:43.220 --> 00:06:50.500
权利的另一个例子

00:06:47.150 --> 00:06:52.630
在正确的时间放置影响云

00:06:50.500 --> 00:06:54.320
平台日趋成熟， 

00:06:52.630 --> 00:06:56.600
集装箱化是一个完美的选择

00:06:54.320 --> 00:07:00.170
包装应用中的想法

00:06:56.600 --> 00:07:02.990
云，这是另一种方式

00:07:00.170 --> 00:07:04.790
有依赖注入，你有

00:07:02.990 --> 00:07:07.850
核心代码及其周围的所有内容

00:07:04.790 --> 00:07:09.920
并不是很在乎，因为你是

00:07:07.850 --> 00:07:16.670
在本身本身的容器内运行

00:07:09.920 --> 00:07:18.200
此时正在云中运行

00:07:16.670 --> 00:07:20.150
虽然我认为我已经说服了你

00:07:18.200 --> 00:07:21.920
您确实需要一些状态，所以现在在哪里

00:07:20.150 --> 00:07:26.300
让我们来看看这些的历史

00:07:21.920 --> 00:07:30.050
就像我们曾经经历过的

00:07:26.300 --> 00:07:33.620
核心语言与

00:07:30.050 --> 00:07:35.450
运行时库状态始终为

00:07:33.620 --> 00:07:38.690
有点脱离核心

00:07:35.450 --> 00:07:41.450
编程语言代码一直都是你

00:07:38.690 --> 00:07:45.350
知道行为是代码

00:07:41.450 --> 00:07:50.120
状态是它开始的数据

00:07:45.350 --> 00:07:51.080
从简单的文本文件中取出

00:07:50.120 --> 00:07:54.380
被阅读

00:07:51.080 --> 00:07:57.580
你从磁带机上知道了

00:07:54.380 --> 00:08:02.210
通过引入进一步完善

00:07:57.580 --> 00:08:05.300
结构化查询语言SQL现在在那里

00:08:02.210 --> 00:08:09.050
这是处理特定领域的语言

00:08:05.300 --> 00:08:10.480
与国家打交道，你知道

00:08:09.050 --> 00:08:13.010
你想在你的身上处理它

00:08:10.480 --> 00:08:15.260
编程语言代码就是你

00:08:13.010 --> 00:08:17.750
知道你可以做到，你很好

00:08:15.260 --> 00:08:19.790
将不得不进行SQL注入

00:08:17.750 --> 00:08:21.320
某种或

00:08:19.790 --> 00:08:24.620
可能使用对象关系映射

00:08:21.320 --> 00:08:26.930
技术，但关键是你

00:08:24.620 --> 00:08:28.520
总是创建SQL语句和

00:08:26.930 --> 00:08:30.950
将它们发送到数据库

00:08:28.520 --> 00:08:32.930
与代码分开是正确的

00:08:30.950 --> 00:08:35.720
当所谓的

00:08:32.930 --> 00:08:39.290
没有SQL方法和文档样式

00:08:35.720 --> 00:08:40.750
我们在这里知道的数据库

00:08:39.290 --> 00:08:43.430
右上方的Oracle云数据库

00:08:40.750 --> 00:08:48.950
 MongoDB DynamoDB这种看似

00:08:43.430 --> 00:08:50.600
现在事物的逻辑发展

00:08:48.950 --> 00:08:53.210
知道我们需要状态但是您需要什么

00:08:50.600 --> 00:08:56.330
从州立商店谈起

00:08:53.210 --> 00:08:58.760
很少有操作会输入内容

00:08:56.330 --> 00:09:02.780
操作已经在这里，所以你想

00:08:58.760 --> 00:09:05.470
如果您知道自己的

00:09:02.780 --> 00:09:08.720
客户端断开连接并回来或

00:09:05.470 --> 00:09:11.060
一些节点在数据中下降

00:09:08.720 --> 00:09:13.550
集群您不会丢失任何数据

00:09:11.060 --> 00:09:15.140
一切都非常耐用

00:09:13.550 --> 00:09:19.190
当然你要有可靠性和

00:09:15.140 --> 00:09:20.750
高可用性，因此回来时

00:09:19.190 --> 00:09:23.930
它很耐用，但事实是

00:09:20.750 --> 00:09:26.030
完全可以信赖的事实是

00:09:23.930 --> 00:09:29.090
故障转移甚至没有引起注意或

00:09:26.030 --> 00:09:33.290
服务降级很小

00:09:29.090 --> 00:09:38.690
正常运行时间是重要的可扩展性数字

00:09:33.290 --> 00:09:40.550
的能力

00:09:38.690 --> 00:09:42.350
处理能力作为负载

00:09:40.550 --> 00:09:44.350
增加，我们将在以下方面获得更多

00:09:42.350 --> 00:09:47.720
我们谈论它的云方面

00:09:44.350 --> 00:09:51.110
和课程数量的吞吐量

00:09:47.720 --> 00:09:52.820
每秒请求数

00:09:51.110 --> 00:09:55.460
您要操作的处理

00:09:52.820 --> 00:09:58.370
在数据所在的位置上，您

00:09:55.460 --> 00:10:01.250
不想拿你的电脑

00:09:58.370 --> 00:10:02.990
并以您真正的方式吸取数据

00:10:01.250 --> 00:10:04.760
想做的就是将您的计算机发送到哪里

00:10:02.990 --> 00:10:07.030
数据是查询和

00:10:04.760 --> 00:10:09.340
在那里聚集和操纵

00:10:07.030 --> 00:10:11.950
将结果发回

00:10:09.340 --> 00:10:14.080
这就是M播放的过程

00:10:11.950 --> 00:10:16.970
水族馆聚集这是一个

00:10:14.080 --> 00:10:21.970
编程级别关注您在哪里

00:10:16.970 --> 00:10:24.710
知道所有这些显然都存在于SQL中

00:10:21.970 --> 00:10:27.500
我们希望拥有一个

00:10:24.710 --> 00:10:30.200
更接近于核心编程

00:10:27.500 --> 00:10:32.990
基甸的在那里

00:10:30.200 --> 00:10:35.270
您想要的系统

00:10:32.990 --> 00:10:36.680
监听地图事件，例如

00:10:35.270 --> 00:10:39.380
确保它做的高度

00:10:36.680 --> 00:10:41.090
性能的方式，它需要

00:10:39.380 --> 00:10:43.340
可通过编程语言访问

00:10:41.090 --> 00:10:47.480
选择，所以这就是所谓的

00:10:43.340 --> 00:10:49.130
多语言多语言用例

00:10:47.480 --> 00:10:50.750
只是国家的核心要求

00:10:49.130 --> 00:10:52.750
服务您还需要什么

00:10:50.750 --> 00:10:55.220
当您将其带入云端时

00:10:52.750 --> 00:10:57.650
良好的按需配置和

00:10:55.220 --> 00:11:00.710
当然只需要弹性

00:10:57.650 --> 00:11:03.350
支付您使用的费用，而不是您所用的费用

00:11:00.710 --> 00:11:06.020
不使用那是整个理由

00:11:03.350 --> 00:11:07.760
首先要云

00:11:06.020 --> 00:11:13.460
有一个服务器这种操作模式

00:11:07.760 --> 00:11:14.930
那就是管理是由

00:11:13.460 --> 00:11:17.840
供应商，您不必管理它

00:11:14.930 --> 00:11:21.740
你自己你想要随付随付

00:11:17.840 --> 00:11:23.450
和公用事业计算定价，您

00:11:21.740 --> 00:11:25.130
想有一个平稳的入口

00:11:23.450 --> 00:11:26.480
在当地发展的情况下

00:11:25.130 --> 00:11:29.240
您想要的云开发案例

00:11:26.480 --> 00:11:30.980
您的管道具有类似的功能

00:11:29.240 --> 00:11:37.610
您的开发管道可以输入

00:11:30.980 --> 00:11:40.130
这些东西，所以使用有什么问题

00:11:37.610 --> 00:11:43.130
我们现有的特定语言数据

00:11:40.130 --> 00:11:44.930
结构最重要的是还要映射

00:11:43.130 --> 00:11:46.790
被称为字典哈希容器

00:11:44.930 --> 00:11:48.590
每种语言都有的关联数组

00:11:46.790 --> 00:11:51.170
这个概念真的包含了一切

00:11:48.590 --> 00:11:53.960
您需要它的行和列

00:11:51.170 --> 00:11:56.120
领域及其关键中心

00:11:53.960 --> 00:11:57.890
意味着它将非常可扩展，但是

00:11:56.120 --> 00:12:00.770
到目前为止，所有这些的问题是

00:11:57.890 --> 00:12:03.590
它们卡在您想成为的堆上

00:12:00.770 --> 00:12:07.730
能够接受并扩展这个概念

00:12:03.590 --> 00:12:10.550
这样就不会屈服了，让我们

00:12:07.730 --> 00:12:13.160
深入了解为什么哈希图非常合适

00:12:10.550 --> 00:12:15.770
所以他们有基础

00:12:13.160 --> 00:12:19.790
哈希计算机科学中的概念

00:12:15.770 --> 00:12:22.310
功能，如果你想采取和

00:12:19.790 --> 00:12:24.740
使它在

00:12:22.310 --> 00:12:27.200
多线程环境最简单

00:12:24.740 --> 00:12:29.930
 Java中的方式只是说集合

00:12:27.200 --> 00:12:31.970
保持地图同步的地图

00:12:29.930 --> 00:12:34.220
哈希语义，并提供

00:12:31.970 --> 00:12:36.680
线程安全，但在其中非常粗糙

00:12:34.220 --> 00:12:37.939
每个操作的竞争条件

00:12:36.680 --> 00:12:42.259
每个客户

00:12:37.939 --> 00:12:45.470
被序列化同步并执行

00:12:42.259 --> 00:12:49.329
在串行并发哈希图中是

00:12:45.470 --> 00:12:53.569
好一点，它只能锁定东西

00:12:49.329 --> 00:12:54.979
操作基础，因此它正在进行中

00:12:53.569 --> 00:12:59.659
它的粒度更细

00:12:54.979 --> 00:13:02.089
争夺比同步地图好

00:12:59.659 --> 00:13:06.459
让我们介绍一下它的云图

00:13:02.089 --> 00:13:08.659
与并发应用相同的哈希语义

00:13:06.459 --> 00:13:11.209
但是高度分散

00:13:08.659 --> 00:13:12.979
进程和多线程，我将

00:13:11.209 --> 00:13:14.899
解释我们如何做到这一点，那就是

00:13:12.979 --> 00:13:18.019
凝聚力的神奇之处

00:13:14.899 --> 00:13:20.209
玩，但编程经验是

00:13:18.019 --> 00:13:22.369
只是我们计划基于地图的API 

00:13:20.209 --> 00:13:27.139
作为国家服务之一

00:13:22.369 --> 00:13:28.639
 api的意思是在当地情况下

00:13:27.139 --> 00:13:31.579
我已经简单地提到了这些

00:13:28.639 --> 00:13:35.629
哈希右哈希图，你有一张桌子吗

00:13:31.579 --> 00:13:38.059
您在密钥哈希上执行哈希的位置

00:13:35.629 --> 00:13:40.999
函数对表的长度取模

00:13:38.059 --> 00:13:44.149
这会给您一个新条目，并且

00:13:40.999 --> 00:13:47.029
并发哈希图，我们将其锁定

00:13:44.149 --> 00:13:50.479
您要处理的特定存储桶

00:13:47.029 --> 00:13:53.029
然后是分布式哈希图

00:13:50.479 --> 00:13:55.069
我们有一个非常好的专利哈希

00:13:53.029 --> 00:13:57.109
一致性内在的算法

00:13:55.069 --> 00:13:59.599
进行映射到

00:13:57.109 --> 00:14:03.109
你知道的分区也知道

00:13:59.599 --> 00:14:05.419
作为桶或某个特定成员

00:14:03.109 --> 00:14:07.539
那是数据分区

00:14:05.419 --> 00:14:10.579
您的数据生活在分布式环境中

00:14:07.539 --> 00:14:13.519
上下文中您可以有多个节点

00:14:10.579 --> 00:14:18.409
节点一致性运行数千个节点

00:14:13.519 --> 00:14:19.759
您甚至可以轻松拥有

00:14:18.409 --> 00:14:23.659
有数据的节点就是那个

00:14:19.759 --> 00:14:25.369
必须锁定，以便您可以想到

00:14:23.659 --> 00:14:27.619
爬升应用程序作为分布式地图，再加上

00:14:25.369 --> 00:14:29.359
再加上国家服务界

00:14:27.619 --> 00:14:32.359
它运行在Oracle的

00:14:29.359 --> 00:14:35.199
裸金属云，它正在运行

00:14:32.359 --> 00:14:35.199
甲骨文的一致性

00:14:36.010 --> 00:14:39.400
我提到我们已经有很多年了

00:14:37.570 --> 00:14:41.980
经历过我们投入的

00:14:39.400 --> 00:14:44.110
具有站点可靠性的一致性

00:14:41.980 --> 00:14:47.160
您可以想到的内部工程

00:14:44.110 --> 00:14:49.960
作为Serena盒子

00:14:47.160 --> 00:14:57.160
好吧，许多语言让我们来

00:14:49.960 --> 00:15:02.950
我想先在这里看一个演示

00:14:57.160 --> 00:15:04.540
本地开发用例，让我们

00:15:02.950 --> 00:15:06.460
看看当地的发展

00:15:04.540 --> 00:15:09.580
国家服务的故事

00:15:06.460 --> 00:15:12.460
我们以FN为例

00:15:09.580 --> 00:15:15.670
将我们的无服务器功能投影为

00:15:12.460 --> 00:15:16.720
服务努力，我们在当地

00:15:15.670 --> 00:15:19.810
命令行

00:15:16.720 --> 00:15:21.610
我们的名字叫CM，就是这个名字

00:15:19.810 --> 00:15:24.190
可能会改变，但代表云

00:15:21.610 --> 00:15:26.560
当前的地图，它具有多个

00:15:24.190 --> 00:15:30.930
命令，首先我们要去

00:15:26.560 --> 00:15:35.770
创建本地实例，请参阅我正在创建- 

00:15:30.930 --> 00:15:37.540
 p5为此，我们有一个要做的事情

00:15:35.770 --> 00:15:40.900
应用程序，我将在

00:15:37.540 --> 00:15:44.770
 p5是一个分区，非常详细

00:15:40.900 --> 00:15:47.080
帐户，它是对

00:15:44.770 --> 00:15:49.570
潜在的产业实力一致性

00:15:47.080 --> 00:15:51.880
我们背后的技术

00:15:49.570 --> 00:15:53.920
你可以看到，当我们开始

00:15:51.880 --> 00:15:58.000
它有两个不同的端口

00:15:53.920 --> 00:16:00.790
公开的G RPC和管理端口，以及

00:15:58.000 --> 00:16:03.520
 G RPC非常重要，因为它

00:16:00.790 --> 00:16:05.620
利用了这一非常流行的潮流

00:16:03.520 --> 00:16:08.280
远程程序的技术

00:16:05.620 --> 00:16:11.110
称这给我们带来很多好处

00:16:08.280 --> 00:16:13.870
我今天要展示的是其中之一

00:16:11.110 --> 00:16:15.790
它们是多语言支持， 

00:16:13.870 --> 00:16:20.920
这对我来说真的很重要

00:16:15.790 --> 00:16:22.660
前面提到的管理端口

00:16:20.920 --> 00:16:23.020
与其他几种互动

00:16:22.660 --> 00:16:27.880
方法

00:16:23.020 --> 00:16:30.070
通过休息以及通过Maven，让我们

00:16:27.880 --> 00:16:32.440
看看我们的演示

00:16:30.070 --> 00:16:34.180
我们要开始吗

00:16:32.440 --> 00:16:35.590
的几种不同语言版本

00:16:34.180 --> 00:16:39.220
它在这里，但我要展示

00:16:35.590 --> 00:16:44.260
首先是基于节点的一个和pm 

00:16:39.220 --> 00:16:46.660
开始，这很简单

00:16:44.260 --> 00:16:49.450
使用react JSON的应用程序

00:16:46.660 --> 00:16:55.450
和节点在中间层和状态

00:16:49.450 --> 00:16:58.150
后台服务，方便快捷

00:16:55.450 --> 00:17:00.880
我们使用Facebook登录获取我们

00:16:58.150 --> 00:17:02.500
您可以添加当前用户的用户名

00:17:00.880 --> 00:17:06.699
让我们假装这是一个

00:17:02.500 --> 00:17:07.560
购物清单牛奶饼干和花生

00:17:06.699 --> 00:17:10.300
牛油

00:17:07.560 --> 00:17:13.449
我们将详细介绍UI本身

00:17:10.300 --> 00:17:16.390
稍后，但我想展示的是

00:17:13.449 --> 00:17:19.120
实时代码部署功能，如果我们

00:17:16.390 --> 00:17:21.370
点击这个，我们希望它检查一下

00:17:19.120 --> 00:17:23.829
完成，但是我们注意到

00:17:21.370 --> 00:17:26.470
它做得不好

00:17:23.829 --> 00:17:28.209
因为我还没有部署

00:17:26.470 --> 00:17:31.000
处理条目的代码

00:17:28.209 --> 00:17:33.370
执行检查的处理器

00:17:31.000 --> 00:17:36.850
事情，所以让我们看看该代码是什么

00:17:33.370 --> 00:17:40.630
看起来像我提到的中间层

00:17:36.850 --> 00:17:44.140
写在节点上，后端是

00:17:40.630 --> 00:17:46.930
完全是国家服务，所以

00:17:44.140 --> 00:17:48.910
背面只有应用程序代码

00:17:46.930 --> 00:17:51.850
在这里结束的是这个小入口处理器

00:17:48.910 --> 00:17:55.090
现在入口处理器是核心

00:17:51.850 --> 00:17:57.580
连贯性以及云的概念

00:17:55.090 --> 00:18:00.220
地图和国家服务，它给

00:17:57.580 --> 00:18:02.020
您具有服务器端的能力

00:18:00.220 --> 00:18:05.350
处理您的数据操作

00:18:02.020 --> 00:18:07.780
代码我将讨论众多

00:18:05.350 --> 00:18:10.570
在其他地方的好处

00:18:07.780 --> 00:18:12.520
演示文稿，但现在我们只能说

00:18:10.570 --> 00:18:15.850
我们正在实施该条目

00:18:12.520 --> 00:18:19.450
具有一种方法的处理器接口

00:18:15.850 --> 00:18:25.600
叫做过程，这是一张地图

00:18:19.450 --> 00:18:29.140
现在进入我们的域名申请表

00:18:25.600 --> 00:18:31.720
数据结构是映射到的字符串

00:18:29.140 --> 00:18:34.240
 JSON对象，字符串为UUID 

00:18:31.720 --> 00:18:37.660
由客户和

00:18:34.240 --> 00:18:40.390
 JSON对象只是JSON的一小部分

00:18:37.660 --> 00:18:42.070
代表我们要做的是

00:18:40.390 --> 00:18:45.670
超级简单，这是一个布尔值

00:18:42.070 --> 00:18:49.570
选中要执行此操作的用户标识

00:18:45.670 --> 00:18:53.020
将被考虑和的文本

00:18:49.570 --> 00:18:56.740
为此，我们将这一切

00:18:53.020 --> 00:18:59.100
我们要做的就是获取

00:18:56.740 --> 00:19:02.669
完工的财产

00:18:59.100 --> 00:19:04.409
 -不要完成，因为可以

00:19:02.669 --> 00:19:07.289
看到它是一个JSON映射，所以我们可以

00:19:04.409 --> 00:19:11.179
在这里获取完成的财产

00:19:07.289 --> 00:19:14.519
想要翻转并再次存储回去

00:19:11.179 --> 00:19:16.860
所以它还没有被部署

00:19:14.519 --> 00:19:19.409
很好地部署它是行家，因此您可以

00:19:16.860 --> 00:19:22.169
只是简单地进行Maven部署，我们

00:19:19.409 --> 00:19:24.570
我有提到管理端口吗

00:19:22.169 --> 00:19:28.259
它正在听大约8080 

00:19:24.570 --> 00:19:31.080
 Maven存储库，所以让我们运行Maven 

00:19:28.259 --> 00:19:36.240
部署Maven-是的，我有一个设置

00:19:31.080 --> 00:19:43.470
文件并部署，您可以看到

00:19:36.240 --> 00:19:46.230
很快就会过去的

00:19:43.470 --> 00:19:48.000
现在部署这是两个步骤

00:19:46.230 --> 00:19:50.220
过程，我们必须回到CM 

00:19:48.000 --> 00:19:53.850
命令，您可以看到我们有厘米

00:19:50.220 --> 00:19:56.909
激活，因此需要Maven组

00:19:53.850 --> 00:20:02.669
 ID工件的ID和版本，并使其

00:19:56.909 --> 00:20:05.519
可用于运行的代码我有它

00:20:02.669 --> 00:20:07.559
在我的历史记录中，cm会激活通讯

00:20:05.519 --> 00:20:12.779
 Oracle云应用程序示例- 

00:20:07.559 --> 00:20:16.710
作为服务器的组ID是应缴费用

00:20:12.779 --> 00:20:19.440
工件ID，100是要发布的版本

00:20:16.710 --> 00:20:22.019
让我们来比较一下

00:20:19.440 --> 00:20:27.240
与绒球，你可以看到它是

00:20:22.019 --> 00:20:28.320
同样，所以我们激活它，我们得到了

00:20:27.240 --> 00:20:31.110
 200 OK 

00:20:28.320 --> 00:20:33.899
现在当我们检查这些东西时

00:20:31.110 --> 00:20:35.940
检查一下，我不必重新部署

00:20:33.899 --> 00:20:38.399
我不需要重启的所有内容

00:20:35.940 --> 00:20:41.100
我只需要部署Maven的任何东西

00:20:38.399 --> 00:20:42.960
现在启动它并激活它

00:20:41.100 --> 00:20:46.230
我们当然处于云中

00:20:42.960 --> 00:20:48.779
这是云图，我们部署

00:20:46.230 --> 00:20:51.929
早期-贫穷常常很多

00:20:48.779 --> 00:20:53.519
部署在云端

00:20:51.929 --> 00:20:58.200
要做一个新的版本

00:20:53.519 --> 00:21:02.159
事情，我们有时会知道

00:20:58.200 --> 00:21:04.679
碰巧引入了一个错误，所以谢天谢地

00:21:02.159 --> 00:21:07.799
在微服务世界中

00:21:04.679 --> 00:21:10.620
金丝雀测试等许多技术

00:21:07.799 --> 00:21:12.340
和Bluegreen部署以及任何数量

00:21:10.620 --> 00:21:15.669
其他可爱的名字

00:21:12.340 --> 00:21:17.080
您减轻了这种影响，但在

00:21:15.669 --> 00:21:17.559
我们的简单情况下，我们只是要滚动它

00:21:17.080 --> 00:21:20.650
背部

00:21:17.559 --> 00:21:23.140
因此，让我们在存在错误的情况下进行部署

00:21:20.650 --> 00:21:24.850
它应该阻止它运行

00:21:23.140 --> 00:21:27.460
再次，我们将无法切换它

00:21:24.850 --> 00:21:29.350
这种情况哦，是的，我忘了几乎忘了

00:21:27.460 --> 00:21:31.539
我必须增加版本号

00:21:29.350 --> 00:21:35.559
因为毕竟这是行家

00:21:31.539 --> 00:21:38.110
版本是一成不变的，所以如果我要

00:21:35.559 --> 00:21:39.279
尝试部署这个我会得到500 

00:21:38.110 --> 00:21:41.650
错误或类似的东西

00:21:39.279 --> 00:21:46.450
访问被拒绝，我不确定

00:21:41.650 --> 00:21:50.520
我们已经将其设置为现在

00:21:46.450 --> 00:21:54.970
我们已经部署了101 

00:21:50.520 --> 00:21:57.640
好吧，我们得到200好，让我们单击

00:21:54.970 --> 00:21:59.799
这，它不起作用，我们单击

00:21:57.640 --> 00:22:03.700
这个，那也不行，好吧

00:21:59.799 --> 00:22:05.620
好吧，这是一个问题，让我们回滚

00:22:03.700 --> 00:22:09.149
所以我们不必部署其他任何东西

00:22:05.620 --> 00:22:12.100
我们可以简单地回到100版本， 

00:22:09.149 --> 00:22:19.059
点击这个，现在你可以看到它

00:22:12.100 --> 00:22:21.789
再次工作，所以真的很重要

00:22:19.059 --> 00:22:23.080
你知道你可以看到我们没有

00:22:21.789 --> 00:22:25.840
必须恢复任何东西，这是一个

00:22:23.080 --> 00:22:27.789
高度动态的系统终于在

00:22:25.840 --> 00:22:31.480
我想在CM上提到的最后一点

00:22:27.789 --> 00:22:33.220
现在的当地发展故事

00:22:31.480 --> 00:22:35.980
不使用这些东西，但我们会

00:22:33.220 --> 00:22:40.450
使用此命令将施法者URL指向

00:22:35.980 --> 00:22:42.010
可能是负载的云服务器

00:22:40.450 --> 00:22:44.799
我们服务的平衡终点

00:22:42.010 --> 00:22:46.899
我们也将对

00:22:44.799 --> 00:22:49.809
工人我们在做的一切

00:22:46.899 --> 00:22:51.669
 Oracle开发人员经验真的是

00:22:49.809 --> 00:22:53.409
试图利用很多其他伟大的东西

00:22:51.669 --> 00:22:57.220
我将要讨论的云技术

00:22:53.409 --> 00:22:58.630
裸金属云，但我们也要去

00:22:57.220 --> 00:23:01.330
要利用工人

00:22:58.630 --> 00:23:03.539
我们真正伟大的管道技术

00:23:01.330 --> 00:23:03.539
有

00:23:12.080 --> 00:23:17.450
让我们来看看多国语言

00:23:15.020 --> 00:23:19.940
通过三个方面的支持

00:23:17.450 --> 00:23:23.060
我们有两个不同的新客户

00:23:19.940 --> 00:23:26.090
到目前为止，我们已经实现了

00:23:23.060 --> 00:23:28.820
 JavaScript在此之上

00:23:26.090 --> 00:23:32.300
在这里，我们写了一篇文本， 

00:23:28.820 --> 00:23:37.720
上下下来，我们有一个基于Java的

00:23:32.300 --> 00:23:39.500
用Java FX编写的一个让我们看一下

00:23:37.720 --> 00:23:42.620
先去

00:23:39.500 --> 00:23:45.560
这是文本，所以我们有一个小的CLI 

00:23:42.620 --> 00:23:49.220
可以说清单列出您要获得的物品

00:23:45.560 --> 00:23:53.870
您可以说添加以添加新项目

00:23:49.220 --> 00:23:55.880
让我们改变，让我们添加葡萄，你

00:23:53.870 --> 00:23:59.210
可以看到我在这里添加它的时间

00:23:55.880 --> 00:24:02.630
在JavaFX以及此处

00:23:59.210 --> 00:24:05.300
节点一，这是因为我们有一个

00:24:02.630 --> 00:24:08.110
该州功能齐全的事件服务

00:24:05.300 --> 00:24:11.800
服务，但我将在代码中显示更多

00:24:08.110 --> 00:24:13.910
部分，但它基本上使用

00:24:11.800 --> 00:24:18.470
您所用语言的功能

00:24:13.910 --> 00:24:20.360
并具有基于反应的事件系统

00:24:18.470 --> 00:24:22.190
允许流式传输和过滤，以及

00:24:20.360 --> 00:24:24.830
各种伟大的事物

00:24:22.190 --> 00:24:28.520
期待何时处理数据

00:24:24.830 --> 00:24:30.380
 Java中的结构和地图，我做不到

00:24:28.520 --> 00:24:34.070
说够了，我们如何放松

00:24:30.380 --> 00:24:37.100
使用集合和map API 

00:24:34.070 --> 00:24:38.750
特别作为指导并添加一些

00:24:37.100 --> 00:24:40.940
除此之外，我们还有其他功能

00:24:38.750 --> 00:24:43.700
希望用户体验非常

00:24:40.940 --> 00:24:45.920
无缝的，而不必要求您

00:24:43.700 --> 00:24:49.760
考虑不同的范式进行交互

00:24:45.920 --> 00:24:53.770
好吧，我提到你可以

00:24:49.760 --> 00:24:59.300
项目，您还可以编辑项目，所以让我们

00:24:53.770 --> 00:25:04.160
列表会将编辑内容更改为大块

00:24:59.300 --> 00:25:07.820
花生酱，你可以看到它更新了

00:25:04.160 --> 00:25:12.700
在那里您可以标记和未标记它们

00:25:07.820 --> 00:25:20.200
假设我们的Cookie标记为两个， 

00:25:12.700 --> 00:25:25.610
假设我们也获得了葡萄标志三

00:25:20.200 --> 00:25:27.290
好的，所以您也可以从

00:25:25.610 --> 00:25:29.090
列出，所以我们不再需要牛奶了

00:25:27.290 --> 00:25:32.860
收到了短信，然后有人买了

00:25:29.090 --> 00:25:35.750
家庭和矮胖的花生酱

00:25:32.860 --> 00:25:40.960
我们仍然想要那个，所以我们检查一下

00:25:35.750 --> 00:25:44.150
关闭，您也可以说清除完成

00:25:40.960 --> 00:25:46.010
现在我们没有任何活动，所以我只添加

00:25:44.150 --> 00:25:50.840
多一些，只是显示不同

00:25:46.010 --> 00:25:52.370
过滤，我们现在可以这样做

00:25:50.840 --> 00:25:54.770
晚上，所以我们要去

00:25:52.370 --> 00:26:03.230
一些更有趣的东西，我们会喝啤酒

00:25:54.770 --> 00:26:06.950
吃一些葡萄酒奶酪和饼干

00:26:03.230 --> 00:26:10.130
这里有一个小小的品尝会，所以我们会

00:26:06.950 --> 00:26:12.730
互相检查一下然后说

00:26:10.130 --> 00:26:14.720
嘿，她只会完成的

00:26:12.730 --> 00:26:17.540
这将向您展示

00:26:14.720 --> 00:26:18.980
选中的和活动的是

00:26:17.540 --> 00:26:24.580
未选中的那些我们仍然没有

00:26:18.980 --> 00:26:24.580
得到了，这是对UI的快速浏览

00:26:31.179 --> 00:26:35.469
让我们来看看

00:26:33.159 --> 00:26:37.299
首先是三个不同的客户

00:26:35.469 --> 00:26:39.789
检查他们每个人如何连接到

00:26:37.299 --> 00:26:42.999
状态服务在每个方面都非常相似

00:26:39.789 --> 00:26:46.389
案例首先在这里，我们有节点

00:26:42.999 --> 00:26:48.909
 JavaScript 1我们有一张云图

00:26:46.389 --> 00:26:52.029
是我们为您提供的API的一部分

00:26:48.909 --> 00:26:54.879
请求它通过状态的会话

00:26:52.029 --> 00:26:57.339
可能是本地的服务端点

00:26:54.879 --> 00:27:02.789
开发案例或指向云

00:26:57.339 --> 00:27:06.129
 1，然后一旦您有状态服务

00:27:02.789 --> 00:27:08.799
会议，你说云图，对不起你

00:27:06.129 --> 00:27:10.779
说会话获取地图的架构

00:27:08.799 --> 00:27:13.149
这是应用程序使用单个

00:27:10.779 --> 00:27:16.809
数据结构称为单个云图

00:27:13.149 --> 00:27:18.159
两个做，我们存储所有两个

00:27:16.809 --> 00:27:21.639
关键所在的职责

00:27:18.159 --> 00:27:27.389
 uu ID和值是JSON数据

00:27:21.639 --> 00:27:31.330
具有用户属性的结构

00:27:27.389 --> 00:27:35.169
文字和完成或不是很简单

00:27:31.330 --> 00:27:37.029
 Java中的三元素数据结构

00:27:35.169 --> 00:27:38.889
情况非常相似，你有一个

00:27:37.029 --> 00:27:42.190
使用称为工厂方法的会话

00:27:38.889 --> 00:27:45.759
创建带有状态URL的创建

00:27:42.190 --> 00:27:49.989
服务，然后您再说一次

00:27:45.759 --> 00:27:52.960
映射传递给会费和此Java 

00:27:49.989 --> 00:27:55.570
这里的例子，我们将要保存

00:27:52.960 --> 00:27:58.389
此用户过滤器，因为大多数

00:27:55.570 --> 00:27:59.979
我们正在处理的查询和

00:27:58.389 --> 00:28:02.859
过滤掉我提到的用户

00:27:59.979 --> 00:28:05.109
每个条目中都有一个用户属性，并且

00:28:02.859 --> 00:28:06.549
在地图中，我们存储来自

00:28:05.109 --> 00:28:09.849
所有的不同用户

00:28:06.549 --> 00:28:12.429
服务，所以我们只想处理

00:28:09.849 --> 00:28:14.769
与

00:28:12.429 --> 00:28:18.070
当前登录的用户，这就是为什么

00:28:14.769 --> 00:28:21.099
在这里使用该用户过滤器，并且

00:28:18.070 --> 00:28:24.489
终于让我们看一看

00:28:21.099 --> 00:28:27.460
我们有一个新的云地图生成器

00:28:24.489 --> 00:28:30.940
通过主机和端口，以及

00:28:27.460 --> 00:28:32.830
名称，然后我们可以访问它

00:28:30.940 --> 00:28:34.539
云图，你可以看到它去了

00:28:32.830 --> 00:28:38.169
当然，因为我们有多重

00:28:34.539 --> 00:28:42.179
错误响应，我们正在使用一个生成器

00:28:38.169 --> 00:28:44.619
模式，也许现在让我们来看看

00:28:42.179 --> 00:28:45.480
使用云地图客户端，这是

00:28:44.619 --> 00:28:48.990
最重要的

00:28:45.480 --> 00:28:51.750
代码演练在这里和它

00:28:48.990 --> 00:28:54.390
提供像用户一样的Java八图

00:28:51.750 --> 00:28:57.750
具有服务器端代码的经验

00:28:54.390 --> 00:28:59.940
执行过滤查询聚合

00:28:57.750 --> 00:29:02.280
和事件流，将遇到

00:28:59.940 --> 00:29:07.620
我们经历的所有这些方面

00:29:02.280 --> 00:29:08.940
代码让我们先去吧

00:29:07.620 --> 00:29:12.870
我们将展示简单的布丁和

00:29:08.940 --> 00:29:15.240
删除好吧，所以我们有了

00:29:12.870 --> 00:29:18.299
云图，我们只是这样说

00:29:15.240 --> 00:29:22.049
删除很简单

00:29:18.299 --> 00:29:25.320
我们已经删除了云图，我们还

00:29:22.049 --> 00:29:28.679
有一个删除所有这是如何

00:29:25.320 --> 00:29:32.270
执行清除完成是

00:29:28.679 --> 00:29:36.240
在旅途中完成

00:29:32.270 --> 00:29:38.730
因此，如果我们说DC，则删除已完成

00:29:36.240 --> 00:29:41.400
现在就是那样

00:29:38.730 --> 00:29:45.330
调用此删除全部，以便通过

00:29:41.400 --> 00:29:47.460
这个过滤器，这里的过滤器是

00:29:45.330 --> 00:29:50.460
说我希望您删除

00:29:47.460 --> 00:29:58.620
完整属性所在的条目

00:29:50.460 --> 00:30:01.230
现在，让我们来看一下查询和

00:29:58.620 --> 00:30:05.280
此处出现的汇总

00:30:01.230 --> 00:30:08.429
列出客户我们的列表方法

00:30:05.280 --> 00:30:10.230
我们是说这又是一个过滤器

00:30:08.429 --> 00:30:13.340
给我，用户给我两个

00:30:10.230 --> 00:30:16.350
来自当前用户的会费

00:30:13.340 --> 00:30:19.260
如果该标志处于活动状态，我们将添加

00:30:16.350 --> 00:30:20.669
等于完成为假，如果

00:30:19.260 --> 00:30:23.190
标志是负的，我们要说

00:30:20.669 --> 00:30:27.270
等于完成是真的，我们

00:30:23.190 --> 00:30:29.130
枚举条目集，以便执行此操作

00:30:27.270 --> 00:30:35.160
列出我们正在传递的清单

00:30:29.130 --> 00:30:38.520
是对本地地图的引用

00:30:35.160 --> 00:30:43.410
填充了以下值

00:30:38.520 --> 00:30:51.360
匹配查询让我们看一下

00:30:43.410 --> 00:30:56.990
 JavaScript方面在j / s中做API 

00:30:51.360 --> 00:30:56.990
我想展示的第一个没有得到

00:30:57.700 --> 00:31:02.720
列出用户的所有会费

00:31:00.230 --> 00:31:06.170
在这里，我们要说的是

00:31:02.720 --> 00:31:10.300
我们从服务器Jas获得的云图

00:31:06.170 --> 00:31:13.970
传递说值贯穿用户

00:31:10.300 --> 00:31:16.190
他等于当前用户，并且

00:31:13.970 --> 00:31:18.650
 JavaScript客户端使用JavaScript 

00:31:16.190 --> 00:31:21.260
保证一切都会发生

00:31:18.650 --> 00:31:23.510
异步发生是指

00:31:21.260 --> 00:31:27.230
意味着你可以通过这个然后你

00:31:23.510 --> 00:31:28.820
通过功能参考，这里一次

00:31:27.230 --> 00:31:30.830
我们获得了价值，我们只是

00:31:28.820 --> 00:31:37.010
将它们发送给我的反应客户

00:31:30.830 --> 00:31:38.770
意思是让我们看看让我们看看

00:31:37.010 --> 00:31:41.720
一个更有趣的是

00:31:38.770 --> 00:31:43.760
在这里更新待办事项文本

00:31:41.720 --> 00:31:46.120
这里我们在调用调用方法

00:31:43.760 --> 00:31:49.370
地图这是服务器端处理

00:31:46.120 --> 00:31:51.530
所以我们通过了UUID和

00:31:49.370 --> 00:31:54.830
那么我们在这里通过了活动

00:31:51.530 --> 00:31:57.170
处理器，处理器被调用， 

00:31:54.830 --> 00:32:00.860
这为我们提供了数据本地服务器端

00:31:57.170 --> 00:32:03.980
代码执行，然后一致性是

00:32:00.860 --> 00:32:07.220
大规模可扩展的多节点

00:32:03.980 --> 00:32:10.370
架构，您的数据将

00:32:07.220 --> 00:32:11.840
被复制并尽可能多地被复制

00:32:10.370 --> 00:32:15.740
在它利用最大

00:32:11.840 --> 00:32:17.840
网络拓扑以提供最大的

00:32:15.740 --> 00:32:19.580
弹性，如果您拥有广泛的

00:32:17.840 --> 00:32:22.460
它将传播的分布式网络

00:32:19.580 --> 00:32:24.590
减少事情发生的机会

00:32:22.460 --> 00:32:27.200
数据丢失当然不会

00:32:24.590 --> 00:32:29.960
无论如何都输了，但减少了机会

00:32:27.200 --> 00:32:33.740
恢复并使其更快地康复

00:32:29.960 --> 00:32:35.390
当它回来时，无论如何我们回来了

00:32:33.740 --> 00:32:37.760
通过入口处理器，它将

00:32:35.390 --> 00:32:40.000
在具有以下条件的节点上执行

00:32:37.760 --> 00:32:43.070
实际数据，所以没有其他

00:32:40.000 --> 00:32:45.530
分区将需要锁定， 

00:32:43.070 --> 00:32:47.090
我们说的是更新文本，因此

00:32:45.530 --> 00:32:50.630
一个入口处理器

00:32:47.090 --> 00:32:54.170
更新财产，当然

00:32:50.630 --> 00:32:59.750
承诺发生，他们回到了

00:32:54.170 --> 00:33:02.330
 404我提到了完成标志

00:32:59.750 --> 00:33:04.040
较早的事件，自定义事件

00:33:02.330 --> 00:33:07.670
处理器，这就是我们要调用的位置

00:33:04.040 --> 00:33:09.210
切换完成，因此只需调用

00:33:07.670 --> 00:33:12.809
 Java代码

00:33:09.210 --> 00:33:14.919
儿童再次显示真实或快速

00:33:12.809 --> 00:33:22.230
切换完成的价值

00:33:14.919 --> 00:33:26.230
属性好吧，让我们来看看

00:33:22.230 --> 00:33:29.649
删除所有我们再次通过的内容

00:33:26.230 --> 00:33:32.679
两个过滤器等于用户和等于

00:33:29.649 --> 00:33:37.720
完成是真的，让我们来看看

00:33:32.679 --> 00:33:38.529
 Java方面要做的是客户端Java 

00:33:37.720 --> 00:33:40.990
嗯嗯

00:33:38.529 --> 00:33:47.860
这样我们已经了解了如何创建

00:33:40.990 --> 00:33:50.080
地图，让我们看一下添加和

00:33:47.860 --> 00:33:52.750
删除非常简单的调用它们的输出

00:33:50.080 --> 00:33:54.640
穿着可能会删除思想可能会删除

00:33:52.750 --> 00:33:58.419
你也可以看到它非常相似

00:33:54.640 --> 00:34:00.730
在那里进行过滤和查询

00:33:58.419 --> 00:34:04.870
这里我们说的是云图给我

00:34:00.730 --> 00:34:06.010
与过滤器流匹配的值

00:34:04.870 --> 00:34:09.399
在Java 8的流式传输上

00:34:06.010 --> 00:34:11.649
流式传输并传递此地图生成

00:34:09.399 --> 00:34:15.460
做这产生非常做

00:34:11.649 --> 00:34:18.700
简单，这里是减速器，所以

00:34:15.460 --> 00:34:22.119
 Java 8 Map API是一个实现

00:34:18.700 --> 00:34:25.270
的MapReduce范式，所以这是

00:34:22.119 --> 00:34:27.520
地图，这是reduce让我们开始吧

00:34:25.270 --> 00:34:31.300
回到JavaScript，看看

00:34:27.520 --> 00:34:33.250
事件，这就是客户的方式

00:34:31.300 --> 00:34:36.940
能够意识到发生了什么

00:34:33.250 --> 00:34:38.980
在节点的另一侧

00:34:36.940 --> 00:34:41.500
使用服务器发送的应用程序

00:34:38.980 --> 00:34:44.649
事件，因此react应用程序将

00:34:41.500 --> 00:34:48.899
休息一下这个东西

00:34:44.649 --> 00:34:51.849
将返回文本事件流，然后

00:34:48.899 --> 00:34:54.419
我们正在过滤当前用户，因此

00:34:51.849 --> 00:34:57.280
给我事件的用户和

00:34:54.419 --> 00:34:59.650
我们在安装时派她去

00:34:57.280 --> 00:35:03.670
几种不同的插入侦听器

00:34:59.650 --> 00:35:06.280
更新和删除，因此在每种情况下

00:35:03.670 --> 00:35:09.150
只需将SSE发送给客户端

00:35:06.280 --> 00:35:14.080
如果我们看客户端代码

00:35:09.150 --> 00:35:18.040
组件应用程序，您可以在这里看到我们

00:35:14.080 --> 00:35:19.720
创建事件源，这使得

00:35:18.040 --> 00:35:21.119
其余的电话回到事件

00:35:19.720 --> 00:35:23.249
来源，我们

00:35:21.119 --> 00:35:27.029
不同的事件监听器

00:35:23.249 --> 00:35:30.269
与我们的待办事项互动

00:35:27.029 --> 00:35:39.569
应用程序看起来不错，事件如何

00:35:30.269 --> 00:35:44.369
工作去你用了吗

00:35:39.569 --> 00:35:50.999
正在通过事件订阅者来做

00:35:44.369 --> 00:35:53.910
进入事件订阅者，这是一个结构

00:35:50.999 --> 00:35:55.470
使用此客户端订阅

00:35:53.910 --> 00:35:58.799
这是来自

00:35:55.470 --> 00:36:00.390
去客户端，它有一些方法，你

00:35:58.799 --> 00:36:05.039
需要在订阅上实施

00:36:00.390 --> 00:36:07.589
完成直播以及接下来和此处的

00:36:05.039 --> 00:36:10.289
下一种情况，如果是一两个

00:36:07.589 --> 00:36:13.259
意味着更新一个是

00:36:10.289 --> 00:36:17.309
插入两个正在更新，我们得到一个新

00:36:13.259 --> 00:36:21.059
要做输入，我们要么更新它

00:36:17.309 --> 00:36:24.180
或者只是你知道处理好吗

00:36:21.059 --> 00:36:27.019
这种处理地图的范式

00:36:24.180 --> 00:36:31.739
去程序员应该很熟悉

00:36:27.019 --> 00:36:35.390
 mm-hmm，让我们看看如何将其连接起来

00:36:31.739 --> 00:36:38.309
在这里这样做进入事件订阅者

00:36:35.390 --> 00:36:40.259
就在那里，就像我们看到的一样

00:36:38.309 --> 00:36:42.749
其他客户端云地图事件

00:36:40.259 --> 00:36:45.299
过滤器等于用户，然后订阅

00:36:42.749 --> 00:36:49.999
通过我们的地址

00:36:45.299 --> 00:36:49.999
我们刚刚在此处创建的订阅者

00:36:50.269 --> 00:36:53.269
好的

00:37:03.210 --> 00:37:09.580
这样我们可以看到呃云图是

00:37:07.060 --> 00:37:11.760
具有更多优点的分布式地图

00:37:09.580 --> 00:37:14.980
最重要的是，我们已经分发了

00:37:11.760 --> 00:37:16.870
一致性带来的持久性

00:37:14.980 --> 00:37:19.960
不需要存储，需要存储

00:37:16.870 --> 00:37:22.680
不鼓励它也支持快照

00:37:19.960 --> 00:37:26.520
和归档分布式状态

00:37:22.680 --> 00:37:33.190
这样您可以看到很多不同的地方

00:37:26.520 --> 00:37:35.230
拓扑在这里是可能的，我们有

00:37:33.190 --> 00:37:37.300
在Oracle，这里有一个全新的平台

00:37:35.230 --> 00:37:42.040
我们正在建立，我们为您带来了

00:37:37.300 --> 00:37:44.440
 Java EE和现在的社区

00:37:42.040 --> 00:37:47.470
正在接管，我们已经看到

00:37:44.440 --> 00:37:50.230
事情改变了一点，微服务

00:37:47.470 --> 00:37:53.920
和无服务器和影响力，我们感到

00:37:50.230 --> 00:37:58.870
这些需要一种新的方法

00:37:53.920 --> 00:38:00.790
一种应用程序，所以我们有一个微型

00:37:58.870 --> 00:38:03.970
服务项目将是

00:38:00.790 --> 00:38:06.630
出来，我们也是一份工作

00:38:03.970 --> 00:38:08.980
宣布FN无服务器项目并

00:38:06.630 --> 00:38:10.690
把这些绑在一起是国家

00:38:08.980 --> 00:38:14.440
投影我所处的国家服务

00:38:10.690 --> 00:38:16.120
今天在这里和你聊天

00:38:14.440 --> 00:38:17.590
没有国家服务，你就知道你

00:38:16.120 --> 00:38:19.930
可以带上自己可以使用的东西

00:38:17.590 --> 00:38:22.600
 Redis或其他一些东西

00:38:19.930 --> 00:38:24.310
有你但是那些不那么好

00:38:22.600 --> 00:38:26.980
紧密集成以提供整体

00:38:24.310 --> 00:38:30.700
珍惜其他两个经验

00:38:26.980 --> 00:38:32.020
事情，此外我们更好

00:38:30.700 --> 00:38:35.740
性能比任何一个

00:38:32.020 --> 00:38:39.490
现成的-我们有一个演示

00:38:35.740 --> 00:38:42.250
基于FN项目，这是

00:38:39.490 --> 00:38:44.080
 Vista的车牌演示它是一个微

00:38:42.250 --> 00:38:47.170
基于服务的东西，但实际上

00:38:44.080 --> 00:38:49.780
甚至比它的功能还微

00:38:47.170 --> 00:38:52.210
基于功能的服务，因此您可以

00:38:49.780 --> 00:38:53.620
想起微服务，对不起你

00:38:52.210 --> 00:38:55.510
可以认为功能就像

00:38:53.620 --> 00:38:57.760
最小的微服务，这是一个

00:38:55.510 --> 00:39:01.270
它们是单方法调用

00:38:57.760 --> 00:39:04.270
打算旋转并拒绝

00:39:01.270 --> 00:39:06.520
对于每个请求，您现在都可以观察到

00:39:04.270 --> 00:39:09.190
在这种情况下，您如何处理Java 

00:39:06.520 --> 00:39:11.920
好吧，您可以标记基于Java 

00:39:09.190 --> 00:39:13.090
充当服务充当热点

00:39:11.920 --> 00:39:15.390
功能

00:39:13.090 --> 00:39:18.160
这将使JVM保持高温

00:39:15.390 --> 00:39:20.620
在指定的时间段内， 

00:39:18.160 --> 00:39:22.690
默认是两分钟，所以如果没有

00:39:20.620 --> 00:39:26.020
超过两分钟的请求

00:39:22.690 --> 00:39:27.940
 JVM将会降级，但正在生产中

00:39:26.020 --> 00:39:31.090
您期望获得更多了解

00:39:27.940 --> 00:39:33.190
除此之外，更明智的计费方式

00:39:31.090 --> 00:39:35.730
我们不会为

00:39:33.190 --> 00:39:38.530
 VM的加速时间和加速时间

00:39:35.730 --> 00:39:41.740
因为我们知道Java正在

00:39:38.530 --> 00:39:45.820
解释并受制于

00:39:41.740 --> 00:39:48.430
像时间和未来一样的策略

00:39:45.820 --> 00:39:50.680
时间编译和所有

00:39:48.430 --> 00:39:54.400
我们知道热点类型优化

00:39:50.680 --> 00:39:57.640
随着时间的流逝，VM变得越来越好

00:39:54.400 --> 00:39:59.530
我们考虑到这一点，让我们

00:39:57.640 --> 00:40:02.950
谈论域名，所以这个许可证

00:39:59.530 --> 00:40:06.070
平板演示它的功能是得到一些

00:40:02.950 --> 00:40:09.010
车牌并在地图上发布鸣叫权

00:40:06.070 --> 00:40:13.060
您可以想象一个警报服务

00:40:09.010 --> 00:40:16.780
您要监控车牌

00:40:13.060 --> 00:40:19.660
活动，所以我们有很多

00:40:16.780 --> 00:40:21.930
这里的不同功能之一

00:40:19.660 --> 00:40:24.970
他们两个是用Ruby编写的

00:40:21.930 --> 00:40:26.440
其中四个是用Java编写的

00:40:24.970 --> 00:40:31.300
其中之一被写走

00:40:26.440 --> 00:40:33.970
另一个是用Python写的

00:40:31.300 --> 00:40:37.810
发生的是刮板服务查询

00:40:33.970 --> 00:40:40.510
 Flickr获取车牌图像

00:40:37.810 --> 00:40:41.320
包含车牌，那么我们称

00:40:40.510 --> 00:40:43.090
阿尔普

00:40:41.320 --> 00:40:45.220
自动车牌识别

00:40:43.090 --> 00:40:48.460
软件作为单独的功能存在

00:40:45.220 --> 00:40:51.460
这将在车牌上进行OCR 

00:40:48.460 --> 00:40:55.020
还给我坐标

00:40:51.460 --> 00:40:57.850
车牌在图像中的位置

00:40:55.020 --> 00:41:01.470
我们有一个检测二元服务， 

00:40:57.850 --> 00:41:05.350
会阻止我们采取行动

00:41:01.470 --> 00:41:09.190
我们已经看过的盘子，然后我们有一个

00:41:05.350 --> 00:41:10.990
使用图像魔术来进行绘图的服务

00:41:09.190 --> 00:41:13.270
根据坐标画那个盒子

00:41:10.990 --> 00:41:15.790
来自检测功能和

00:41:13.270 --> 00:41:18.910
然后我们有一个警报服务

00:41:15.790 --> 00:41:20.430
通过Twitter发送出去，我们也有

00:41:18.910 --> 00:41:24.310
这些在底部

00:41:20.430 --> 00:41:28.000
进度警报管理器并发布

00:41:24.310 --> 00:41:31.510
协调此事物的用户界面

00:41:28.000 --> 00:41:34.510
还有进度条和警报

00:41:31.510 --> 00:41:36.520
经理提供某种状态

00:41:34.510 --> 00:41:41.530
管理员如何处理推文

00:41:36.520 --> 00:41:43.120
当他们通过这些服务来到这里

00:41:41.530 --> 00:41:45.340
我提到的是写的

00:41:43.120 --> 00:41:51.400
 Java中的人正在与状态服务对话

00:41:45.340 --> 00:41:54.730
直接，我们可以看看如何

00:41:51.400 --> 00:41:57.240
运行，所以让我告诉你这是什么

00:41:54.730 --> 00:41:57.240
在实践中看起来像

00:42:00.810 --> 00:42:07.600
好的，这是Vista状态服务

00:42:03.340 --> 00:42:12.220
演示，所以我们将重新加载此页面

00:42:07.600 --> 00:42:17.440
然后点击开始，我们将要发送

00:42:12.220 --> 00:42:21.790
通过系统的一些数据，所以这

00:42:17.440 --> 00:42:27.550
将查询Flickr并开始

00:42:21.790 --> 00:42:29.230
整个功能，实际上我们

00:42:27.550 --> 00:42:33.280
现在看到一些功能通过

00:42:29.230 --> 00:42:35.670
系统的第一个功能是

00:42:33.280 --> 00:42:43.780
调用检测板功能

00:42:35.670 --> 00:42:49.560
下一个是抽奖

00:42:43.780 --> 00:42:52.060
功能，而正在运行

00:42:49.560 --> 00:42:56.860
最终，我们的目标是达到

00:42:52.060 --> 00:42:59.320
提醒Java函数，我们可以看到，但是

00:42:56.860 --> 00:43:05.380
我们没有发出任何推文

00:42:59.320 --> 00:43:07.720
尚未运行，但我们一直在运行

00:43:05.380 --> 00:43:10.900
这个演示一段时间，您还可以看到

00:43:07.720 --> 00:43:13.120
这里的功能进度

00:43:10.900 --> 00:43:15.700
流过系统，您可以

00:43:13.120 --> 00:43:21.160
看看花了多少毫秒

00:43:15.700 --> 00:43:23.860
每个不同的阶段，我们都有

00:43:21.160 --> 00:43:27.280
此处的标记图将包括

00:43:23.860 --> 00:43:29.800
你知道的车牌数据

00:43:27.280 --> 00:43:33.880
车牌所针对的州

00:43:29.800 --> 00:43:36.320
属于我们的C和一些抽屉

00:43:33.880 --> 00:43:40.340
一起来

00:43:36.320 --> 00:43:45.780
我们最终应该靠近

00:43:40.340 --> 00:43:51.920
如果我们在这里注意到，我们可能会有店员

00:43:45.780 --> 00:43:54.630
到目前为止，各州有27盘比赛

00:43:51.920 --> 00:43:57.210
我们应该期望这个数字会增加

00:43:54.630 --> 00:44:05.760
随着更多板块的检测和流动

00:43:57.210 --> 00:44:08.010
通过系统，而那是

00:44:05.760 --> 00:44:16.290
运行让我们看一下Java 

00:44:08.010 --> 00:44:18.510
警报服务警报作业的代码，因此

00:44:16.290 --> 00:44:21.240
这是一个基于Java的示例

00:44:18.510 --> 00:44:23.940
功能和功能是服务

00:44:21.240 --> 00:44:29.250
平台，它只是一个简单的Java类

00:44:23.940 --> 00:44:32.040
它有一个句柄请求方法

00:44:29.250 --> 00:44:36.960
是由调用的

00:44:32.040 --> 00:44:42.270
功能服务以及何时使用此方法

00:44:36.960 --> 00:44:44.640
调用后，我们获取JSON，然后退出

00:44:42.270 --> 00:44:46.950
警报云图，我们做了一些

00:44:44.640 --> 00:44:52.380
你在那里看到的操纵

00:44:46.950 --> 00:44:54.450
它从27上升到28 

00:44:52.380 --> 00:44:58.200
状态服务与此交互

00:44:54.450 --> 00:45:00.630
凭借此数量的申请

00:44:58.200 --> 00:45:01.980
属性，但状态过滤器在这里

00:45:00.630 --> 00:45:04.080
可以放一个正则表达式

00:45:01.980 --> 00:45:06.300
只会调整那些

00:45:04.080 --> 00:45:09.110
匹配某个状态，例如

00:45:06.300 --> 00:45:12.900
您还可以享受另一项服务

00:45:09.110 --> 00:45:15.660
如果不这样做，将过滤出重复项

00:45:12.900 --> 00:45:18.870
想看看现在还可以吗

00:45:15.660 --> 00:45:20.340
 29所以如果我们回到图表

00:45:18.870 --> 00:45:23.160
应该期望看到一些警报

00:45:20.340 --> 00:45:25.200
有两个，我们也应该

00:45:23.160 --> 00:45:27.830
重新加载Twitter，我们应该期待

00:45:25.200 --> 00:45:33.870
看那里的一些推文

00:45:27.830 --> 00:45:39.840
好的35秒前和53秒前

00:45:33.870 --> 00:45:42.930
还有我想要的另一种模式

00:45:39.840 --> 00:45:48.150
显示与待办演示类似

00:45:42.930 --> 00:45:52.440
我所做的就是你如何获得云图

00:45:48.150 --> 00:45:55.080
所以你有状态服务端点

00:45:52.440 --> 00:45:57.570
在这种情况下再次是一个遥控器

00:45:55.080 --> 00:46:00.210
远程运行在云中，我们

00:45:57.570 --> 00:46:01.470
说端点会话创建端点

00:46:00.210 --> 00:46:03.630
的，然后我们有一些

00:46:01.470 --> 00:46:06.780
简单的应用程序所拥有的不同地图

00:46:03.630 --> 00:46:08.730
这个只有一个

00:46:06.780 --> 00:46:11.760
接下来我要重点介绍的是

00:46:08.730 --> 00:46:16.230
请求进度图，这是如何

00:46:11.760 --> 00:46:18.510
进度条以及此表的绘制方式

00:46:16.230 --> 00:46:22.260
在这里填充了数据，所以我们有

00:46:18.510 --> 00:46:26.000
警报Java交互的两种服务

00:46:22.260 --> 00:46:26.000
通过将一些数据放入其中

00:46:26.540 --> 00:46:32.780
更新进度，因此它正在调用

00:46:29.610 --> 00:46:36.540
发送此的invoke方法

00:46:32.780 --> 00:46:38.040
运行到服务器上运行

00:46:36.540 --> 00:46:42.480
让我们看一下看起来像什么

00:46:38.040 --> 00:46:44.610
更新进度，这是一个云功能

00:46:42.480 --> 00:46:47.820
我们正在序列化和设置

00:46:44.610 --> 00:46:50.250
此代码在服务器端运行， 

00:46:47.820 --> 00:46:52.140
再次，如果我们想处理代码

00:46:50.250 --> 00:46:54.990
超出此范围的部署

00:46:52.140 --> 00:46:56.700
您可以与Maven互动的Lambda 

00:46:54.990 --> 00:47:00.840
您之前拥有的工件

00:46:56.700 --> 00:47:02.400
部署到云服务和

00:47:00.840 --> 00:47:05.670
我想展示的其他服务是

00:47:02.400 --> 00:47:09.120
进度更新服务这也

00:47:05.670 --> 00:47:11.670
与云地图请求进行交互

00:47:09.120 --> 00:47:17.300
进度云图也有更新

00:47:11.670 --> 00:47:19.590
类似的进度方法

00:47:17.300 --> 00:47:21.720
实际上，它可以在

00:47:19.590 --> 00:47:27.780
两种不同的服务，但我们还没有

00:47:21.720 --> 00:47:31.370
做到了，还好，你有三个

00:47:27.780 --> 00:47:31.370
更多推文让我们重新加载

00:47:34.220 --> 00:47:39.740
 Twitter有点慢也可以

00:47:37.359 --> 00:47:42.170
其实他们还没有给我们

00:47:39.740 --> 00:47:54.680
很好就足够了

00:47:42.170 --> 00:47:57.470
总结一下无服务器状态

00:47:54.680 --> 00:48:00.140
服务是无限可扩展的

00:47:57.470 --> 00:48:03.020
有弹性，持续可用

00:48:00.140 --> 00:48:05.900
该地图基于无处不在

00:48:03.020 --> 00:48:07.970
他了解本地刻录模型数据

00:48:05.900 --> 00:48:10.369
处理并按需付款

00:48:07.970 --> 00:48:12.549
希望它临近云

00:48:10.369 --> 00:48:12.549
您

