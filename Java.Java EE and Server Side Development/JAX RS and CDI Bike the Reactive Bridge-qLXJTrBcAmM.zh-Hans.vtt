WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.540 --> 00:00:09.470
首先，早上好，谢谢

00:00:06.120 --> 00:00:11.520
来这辆jax-rs和CDI自行车

00:00:09.470 --> 00:00:14.550
指令桥会议

00:00:11.520 --> 00:00:17.850
所以在我们开始之前，很快

00:00:14.550 --> 00:00:20.670
关于我们的几句话，所以我叫大卫

00:00:17.850 --> 00:00:22.260
 Alaba CI在Oracle的

00:00:20.670 --> 00:00:25.080
负责的组织

00:00:22.260 --> 00:00:26.670
 Java SE Java EE我们也负责

00:00:25.080 --> 00:00:30.420
适用于开源项目，例如

00:00:26.670 --> 00:00:32.340
我们的组织也

00:00:30.420 --> 00:00:34.590
负责此类商品

00:00:32.340 --> 00:00:36.899
作为WebLogic服务器和其他有趣的东西

00:00:34.590 --> 00:00:40.589
就像只是一个活动项目

00:00:36.899 --> 00:00:43.109
在主题演讲之前开源

00:00:40.589 --> 00:00:45.929
我在Sun及之前呆了十年

00:00:43.109 --> 00:00:48.870
 Sun我花了四年时间从事Java工作

00:00:45.929 --> 00:00:50.519
所以基本上看一下进化

00:00:48.870 --> 00:00:51.870
我的Orkut可以清楚地看到

00:00:50.519 --> 00:00:57.600
我参与了Java领域

00:00:51.870 --> 00:01:00.449
因为好几次了，我的名字是

00:00:57.600 --> 00:01:02.879
乔西我住在巴黎地区

00:01:00.449 --> 00:01:04.140
我提供了一些链接，我们是

00:01:02.879 --> 00:01:05.940
将会谈论很多

00:01:04.140 --> 00:01:08.730
完成阶段和可完成的未来

00:01:05.940 --> 00:01:11.460
以及与jax-rs API的交互

00:01:08.730 --> 00:01:13.800
如果您查看我的YouTube帐户，我

00:01:11.460 --> 00:01:16.260
有几个演讲，特别是关于

00:01:13.800 --> 00:01:19.320
我是完成阶段的主题

00:01:16.260 --> 00:01:21.270
同样在我们的网站上

00:01:19.320 --> 00:01:23.480
巴黎Java用户的骄傲成员

00:01:21.270 --> 00:01:23.480
组

00:01:26.270 --> 00:01:31.829
所以几个月前就是我

00:01:29.939 --> 00:01:33.810
瑞典的Jeff声学会议

00:01:31.829 --> 00:01:34.409
我正在演讲的地方，有人在

00:01:33.810 --> 00:01:36.090
听众

00:01:34.409 --> 00:01:38.459
推特说这不是一个真正的会议

00:01:36.090 --> 00:01:41.850
除非您阅读或演员安全港

00:01:38.459 --> 00:01:46.679
声明至少一次，请欣赏

00:01:41.850 --> 00:01:49.140
今天我们要谈的是

00:01:46.679 --> 00:01:51.750
未来，但同时发生

00:01:49.140 --> 00:01:53.789
 util软件包不像将来那样

00:01:51.750 --> 00:01:55.049
我们可能会在产品中做的事情

00:01:53.789 --> 00:01:57.840
我们站在安全的一面

00:01:55.049 --> 00:02:01.500
所以我们基本上可以忽略正在发生的事情

00:01:57.840 --> 00:02:05.849
说接下来是我们的个人

00:02:01.500 --> 00:02:08.429
在法语上免责声明

00:02:05.849 --> 00:02:11.970
比其他人更容易理解法语

00:02:08.429 --> 00:02:18.510
现在说英语，我不是法语，但

00:02:11.970 --> 00:02:20.579
不要告诉乔西，让我们先设置

00:02:18.510 --> 00:02:23.010
舞台，所以今天我们要谈论

00:02:20.579 --> 00:02:25.340
如果您查看指令，现在就反应

00:02:23.010 --> 00:02:28.260
宣言定义了类似的东西

00:02:25.340 --> 00:02:30.030
像反应一样的弹性

00:02:28.260 --> 00:02:33.060
我认为消息传递了那种

00:02:30.030 --> 00:02:34.410
在...的情况下通过反应

00:02:33.060 --> 00:02:37.139
这个演讲，我们的意思是

00:02:34.410 --> 00:02:39.870
反应能力

00:02:37.139 --> 00:02:42.660
有效地应对某种事件

00:02:39.870 --> 00:02:44.639
通过了，所以基本上我们会采取

00:02:42.660 --> 00:02:47.220
部分API的一部分

00:02:44.639 --> 00:02:49.019
 Java平台，例如Jack的逮捕和CDI 

00:02:47.220 --> 00:02:51.810
同样，我们将提取它们

00:02:49.019 --> 00:02:53.880
从Java，我们将在纯

00:02:51.810 --> 00:02:55.109
 Java C上下文说明了所有

00:02:53.880 --> 00:02:57.720
我们将要呈现的模式

00:02:55.109 --> 00:03:00.120
今天也可以完美地工作

00:02:57.720 --> 00:03:03.540
 Java环境和想法真的

00:03:00.120 --> 00:03:06.329
看看我们如何利用这些API 

00:03:03.540 --> 00:03:09.060
和Java EE压缩阶段API来

00:03:06.329 --> 00:03:12.510
基本上有这个反应

00:03:09.060 --> 00:03:15.209
对您的反应能力

00:03:12.510 --> 00:03:16.980
应用程序，一旦您将获得

00:03:15.209 --> 00:03:18.419
父母，一旦您，我们将介绍

00:03:16.980 --> 00:03:19.799
将这些模式应用于您的

00:03:18.419 --> 00:03:21.620
在一天结束时申请

00:03:19.799 --> 00:03:24.780
应用程序显然将存在

00:03:21.620 --> 00:03:26.730
使用同步消息传递

00:03:24.780 --> 00:03:29.040
功能，但归根结底

00:03:26.730 --> 00:03:31.260
他们将扩大规模，他们将

00:03:29.040 --> 00:03:33.560
反应更快，这就是我们真正的

00:03:31.260 --> 00:03:37.800
意思是今天反应

00:03:33.560 --> 00:03:40.319
所以我要讨论的第一个API 

00:03:37.800 --> 00:03:42.660
是jax-rs API，我们将花一些钱

00:03:40.319 --> 00:03:44.489
时间在jax-rs上，因为基本上

00:03:42.660 --> 00:03:47.130
会议基于我们如何更好

00:03:44.489 --> 00:03:51.690
使用这个的杰克的地址

00:03:47.130 --> 00:03:52.590
反应性ID，所以我们刚刚发布了

00:03:51.690 --> 00:03:56.819
杰克的rs21 

00:03:52.590 --> 00:03:59.850
连同Java 8 Jack的其余一款一起来

00:03:56.819 --> 00:04:02.040
具有不同的增强功能，例如支持

00:03:59.850 --> 00:04:04.170
为Jason B提供服务甚至支持

00:04:02.040 --> 00:04:06.630
等等等等，我们要

00:04:04.170 --> 00:04:08.670
基本上今天我们会跳过

00:04:06.630 --> 00:04:09.959
专注于一项具有

00:04:08.670 --> 00:04:14.819
已添加到杰克的rs21中

00:04:09.959 --> 00:04:17.370
这是一个新的反应式调用程序，因此

00:04:14.819 --> 00:04:19.650
解释什么是什么反应

00:04:17.370 --> 00:04:22.620
调用者解决让我们先来看一下

00:04:19.650 --> 00:04:26.310
我们注入的jax-rs客户端API 

00:04:22.620 --> 00:04:27.870
其余的-喷油器是-我们基本上

00:04:26.310 --> 00:04:30.210
有一个我们可以轻松使用的API 

00:04:27.870 --> 00:04:32.790
消耗远程休息端点，并且

00:04:30.210 --> 00:04:34.830
首先需要它如何运作良好

00:04:32.790 --> 00:04:36.630
客户对象，因此基本上是

00:04:34.830 --> 00:04:39.390
您可以使用的客户端容器

00:04:36.630 --> 00:04:40.860
使用远程端点就可以了

00:04:39.390 --> 00:04:42.270
通过这种叫做so client的方法

00:04:40.860 --> 00:04:44.700
将学习客户，您将获得

00:04:42.270 --> 00:04:45.510
那种容器就过去了

00:04:44.700 --> 00:04:47.130
组态

00:04:45.510 --> 00:04:49.560
我没有指定任何东西，但显然

00:04:47.130 --> 00:04:53.160
我有能力配置，如果

00:04:49.560 --> 00:04:55.650
我需要我的客户

00:04:53.160 --> 00:04:57.960
我需要建立一个网站的容器

00:04:55.650 --> 00:05:00.900
瞄准网页目标基本上是酒吧

00:04:57.960 --> 00:05:02.610
某种美化的网址，因此

00:05:00.900 --> 00:05:07.020
基本上在网络上更多的地方

00:05:02.610 --> 00:05:09.960
远程休息端点，我有我的网站

00:05:07.020 --> 00:05:12.240
目标，所以接下来我需要构建基于

00:05:09.960 --> 00:05:13.740
在我的目标我的要求，所以

00:05:12.240 --> 00:05:16.789
基本上我想要的要求

00:05:13.740 --> 00:05:19.350
我的客户端容器发出和

00:05:16.789 --> 00:05:21.390
然后我们会在某个时间点看到

00:05:19.350 --> 00:05:23.460
发出该请求，所以基本上我会

00:05:21.390 --> 00:05:25.470
告诉我的客户容器发出

00:05:23.460 --> 00:05:27.810
休息请求，因此在这种情况下，例如

00:05:25.470 --> 00:05:29.550
我们看到这是一个获取请求

00:05:27.810 --> 00:05:31.669
可能是发布请求，可能是

00:05:29.550 --> 00:05:34.169
删除请求并不重要

00:05:31.669 --> 00:05:35.639
您会看到我们所期待的

00:05:34.169 --> 00:05:39.080
得到回报是回报是

00:05:35.639 --> 00:05:39.080
预测对象

00:05:39.760 --> 00:05:43.790
鉴于我们有这种

00:05:42.110 --> 00:05:45.770
我们可以多次使用的容器

00:05:43.790 --> 00:05:48.020
显然，我们需要确保我们

00:05:45.770 --> 00:05:49.730
关闭它实现关闭每个

00:05:48.020 --> 00:05:52.000
界面，这是一种简单的交易方式

00:05:49.730 --> 00:05:55.040
带着这种担忧

00:05:52.000 --> 00:05:57.920
所以在jax-rs 2中，我们有折扣API 

00:05:55.040 --> 00:05:59.780
拥有这个流利的API，您可以计划

00:05:57.920 --> 00:06:01.310
来自客户端构建器的构建器，您是谁

00:05:59.780 --> 00:06:03.050
从你说的客户那里得到一个客户

00:06:01.310 --> 00:06:05.360
网络目标中的网络目标

00:06:03.050 --> 00:06:08.630
消费者请求，最后您调用

00:06:05.360 --> 00:06:10.280
如果您现在要求保释

00:06:08.630 --> 00:06:12.020
看看我们的幻灯片的底部

00:06:10.280 --> 00:06:13.640
一个典型的要求，所以我们有能力

00:06:12.020 --> 00:06:16.040
设置标题等等

00:06:13.640 --> 00:06:18.920
真的很重要，但是关键是

00:06:16.040 --> 00:06:21.020
大门被堵的事实

00:06:18.920 --> 00:06:23.180
那种容器会发出

00:06:21.020 --> 00:06:24.890
请求，基本上我的方法会

00:06:23.180 --> 00:06:31.310
阻止，直到我们从

00:06:24.890 --> 00:06:33.920
现在在jax-rs 2中的远程端点

00:06:31.310 --> 00:06:35.540
具有同步功能，如果

00:06:33.920 --> 00:06:38.360
您没有指定任何会

00:06:35.540 --> 00:06:40.250
如此异步的阻止请求

00:06:38.360 --> 00:06:43.760
请求，但如果您查看的底部

00:06:40.250 --> 00:06:45.770
幻灯片中有一个同步方法

00:06:43.760 --> 00:06:47.510
这基本上是告诉插孔

00:06:45.770 --> 00:06:52.220
我要使用的休息和容器

00:06:47.510 --> 00:06:54.650
任务工，如果你看

00:06:52.220 --> 00:06:56.960
该请求的返回类型

00:06:54.650 --> 00:06:59.150
调用我们没有字符串

00:06:56.960 --> 00:07:01.580
在这种情况下，但是我们有

00:06:59.150 --> 00:07:03.140
字符串的未来，所以基本上

00:07:01.580 --> 00:07:05.180
意味着我们有一个可以

00:07:03.140 --> 00:07:09.669
将来用于基本获得

00:07:05.180 --> 00:07:09.669
请求调用的结果

00:07:12.220 --> 00:07:19.120
现在，如果我们这样做的话

00:07:16.420 --> 00:07:21.220
要求我们将回答我们将基本上

00:07:19.120 --> 00:07:25.050
有非阻塞代码，所以我们的方法

00:07:21.220 --> 00:07:27.610
正确后将立即返回

00:07:25.050 --> 00:07:30.550
但你知道进入未来

00:07:27.610 --> 00:07:33.430
我们需要获取的对象和问题

00:07:30.550 --> 00:07:35.110
是那个门被挡住了

00:07:33.430 --> 00:07:37.270
我们没有卖任何东西

00:07:35.110 --> 00:07:38.950
只是推迟了一个问题，我们仍然有一个

00:07:37.270 --> 00:07:44.380
阻止行为，显然我们没有

00:07:38.950 --> 00:07:46.270
真正想要的问题是，如果它

00:07:44.380 --> 00:07:48.400
永远需要远程端点

00:07:46.270 --> 00:07:50.530
发送好结果，我们的代码将是

00:07:48.400 --> 00:07:52.630
永远被封锁，所以你需要做什么

00:07:50.530 --> 00:07:55.300
确定是您需要确保您

00:07:52.630 --> 00:07:57.100
至少有超时的权利，所以如果

00:07:55.300 --> 00:07:59.380
在这种情况下需要5秒钟以上

00:07:57.100 --> 00:08:01.480
我们会有一个例外，因此我们的代码将

00:07:59.380 --> 00:08:03.370
被字挡了5秒钟

00:08:01.480 --> 00:08:08.410
不理想，但比它更好

00:08:03.370 --> 00:08:10.990
永远吊死现在我们也可以做这些

00:08:08.410 --> 00:08:12.820
所以不是直接

00:08:10.990 --> 00:08:14.500
访问我们可以检查的未来对象

00:08:12.820 --> 00:08:17.650
如果那个物体有某种原因

00:08:14.500 --> 00:08:19.330
如果有我们可以访问它

00:08:17.650 --> 00:08:21.190
并不能真正解决问题

00:08:19.330 --> 00:08:23.110
而且您还需要确保

00:08:21.190 --> 00:08:26.320
你设置了一个计时器但现在是法官

00:08:23.110 --> 00:08:28.270
访问级别，以确保再次

00:08:26.320 --> 00:08:30.550
由于某种原因，您没有得到回应

00:08:28.270 --> 00:08:35.890
从远程端点，您的代码是

00:08:30.550 --> 00:08:38.410
现在不是永远吊死的好消息是

00:08:35.890 --> 00:08:39.940
是在杰克的逮捕中，我们有一个

00:08:38.410 --> 00:08:42.310
可以让我们基本上

00:08:39.940 --> 00:08:44.260
解决这些阻塞问题，并

00:08:42.310 --> 00:08:47.200
这是调用回调工具

00:08:44.260 --> 00:08:49.290
所以基本上是一个具有

00:08:47.200 --> 00:08:51.970
需要实现的两种方法

00:08:49.290 --> 00:08:52.570
完成并失败，名称为

00:08:51.970 --> 00:08:54.340
很明显

00:08:52.570 --> 00:08:56.589
因此完成的回调基本上

00:08:54.340 --> 00:09:00.339
当我们得到以下结果时被调用

00:08:56.589 --> 00:09:04.150
远程端点并失败了

00:09:00.339 --> 00:09:06.820
如果出了问题就调用它

00:09:04.150 --> 00:09:09.790
像这样工作，所以我还是这样

00:09:06.820 --> 00:09:10.450
使用

00:09:09.790 --> 00:09:12.490
资产调用者

00:09:10.450 --> 00:09:15.700
告诉我的客户容器

00:09:12.490 --> 00:09:17.680
确实是一个独特的调用，现在

00:09:15.700 --> 00:09:19.519
当我执行请求时，我将其传递给

00:09:17.680 --> 00:09:21.740
调用回调

00:09:19.519 --> 00:09:25.369
需要具有的调用回调

00:09:21.740 --> 00:09:26.959
完成了两个回调以处理

00:09:25.369 --> 00:09:29.920
将在某些时候签署的回应

00:09:26.959 --> 00:09:37.970
远程端点的时间点

00:09:29.920 --> 00:09:39.589
如果出了问题会失败，现在让我们

00:09:37.970 --> 00:09:41.540
透视一下，这是一个

00:09:39.589 --> 00:09:44.389
我们在典型的微服务场景中

00:09:41.540 --> 00:09:45.800
有一个旅行社服务

00:09:44.389 --> 00:09:47.749
需要消耗多个后端

00:09:45.800 --> 00:09:49.699
在这种情况下，我们有四个服务

00:09:47.749 --> 00:09:52.009
后端服务和

00:09:49.699 --> 00:09:54.410
场景是我们有一个用户

00:09:52.009 --> 00:09:56.660
出差旅行和周到的服务

00:09:54.410 --> 00:09:59.779
将调用客户服务以获取

00:09:56.660 --> 00:10:01.790
用户拥有的历史

00:09:59.779 --> 00:10:03.529
我们将调用目标

00:10:01.790 --> 00:10:06.110
有一个我们可以的潜在目的地

00:10:03.529 --> 00:10:08.569
根据其旅行向该用户建议

00:10:06.110 --> 00:10:11.569
历史以及每个目的地

00:10:08.569 --> 00:10:13.610
我们将建议我们不要

00:10:11.569 --> 00:10:16.069
有一些天气信息和

00:10:13.610 --> 00:10:18.829
一些编码信息，以便用户

00:10:16.069 --> 00:10:20.389
进来，旅行社服务将

00:10:18.829 --> 00:10:22.759
成为这四个后端的客户

00:10:20.389 --> 00:10:24.829
服务，它必须像回答

00:10:22.759 --> 00:10:29.179
五个或十个目的地

00:10:24.829 --> 00:10:34.899
详细信息，例如预测和定价

00:10:29.179 --> 00:10:34.899
现在给定的用户

00:10:36.340 --> 00:10:41.780
这是很明显的，但是如果我们把

00:10:38.930 --> 00:10:44.030
一些成本，一些重量， 

00:10:41.780 --> 00:10:47.180
我们必须执行的请求调用

00:10:44.030 --> 00:10:49.070
我们是否清楚地看到，如果我们经历

00:10:47.180 --> 00:10:51.400
纯阻塞串行方法

00:10:49.070 --> 00:10:54.740
没有道理，它将需要

00:10:51.400 --> 00:10:56.780
五秒钟返回这些结果，所以

00:10:54.740 --> 00:11:00.440
我们清楚地知道规模不是问题

00:10:56.780 --> 00:11:02.590
另一方面，我们想做的是

00:11:00.440 --> 00:11:04.460
看到我们可以优化我们的

00:11:02.590 --> 00:11:06.110
那些之间的业务流程

00:11:04.460 --> 00:11:08.450
不同的服务调用

00:11:06.110 --> 00:11:09.650
示例我们需要的第一个服务

00:11:08.450 --> 00:11:12.710
调用的客户很少

00:11:09.650 --> 00:11:14.390
服务，一旦我们有，我们必须

00:11:12.710 --> 00:11:15.980
调用推荐目的地

00:11:14.390 --> 00:11:18.440
服务，但是一旦我们有了

00:11:15.980 --> 00:11:20.360
建议我们可以调用的目的地

00:11:18.440 --> 00:11:22.370
与此并行的报价服务

00:11:20.360 --> 00:11:25.700
给定目的地和天气

00:11:22.370 --> 00:11:29.000
预测相同目的地

00:11:25.700 --> 00:11:31.520
因此，如果我们再次应用这些费用

00:11:29.000 --> 00:11:32.990
要求我们在末尾看到

00:11:31.520 --> 00:11:39.290
一天，我们应该拥有某种方式

00:11:32.990 --> 00:11:41.620
现在更快，让我们看看它如何工作

00:11:39.290 --> 00:11:45.290
与jax-rs 

00:11:41.620 --> 00:11:48.440
 API并使用此调用回调

00:11:45.290 --> 00:11:50.420
工具，让我们简化方案

00:11:48.440 --> 00:11:52.940
让我们假装一点

00:11:50.420 --> 00:11:54.380
只有两个服务系统消耗

00:11:52.940 --> 00:11:58.430
目的地服务和天气

00:11:54.380 --> 00:12:01.190
服务，那么我们如何编写该代码

00:11:58.430 --> 00:12:03.410
使用jax-rs两个api我们有一个

00:12:01.190 --> 00:12:05.120
要求获得嗡嗡声

00:12:03.410 --> 00:12:09.020
推荐目的地

00:12:05.120 --> 00:12:10.790
鉴于它是一个同步请求

00:12:09.020 --> 00:12:13.160
在同步请求中，我们必须将其传递给

00:12:10.790 --> 00:12:15.680
调用回调

00:12:13.160 --> 00:12:17.150
回调必须回调完成

00:12:15.680 --> 00:12:19.910
那就是将被调用的回调

00:12:17.150 --> 00:12:21.620
当我们有结果时

00:12:19.910 --> 00:12:23.810
目的地我们是什么我们是什么

00:12:21.620 --> 00:12:25.970
做得好，我们基本上会研究所有

00:12:23.810 --> 00:12:28.310
我们拥有的区别

00:12:25.970 --> 00:12:31.430
目的地，我们将再次提出要求

00:12:28.310 --> 00:12:34.340
另一个休息的请求将一无所获

00:12:31.430 --> 00:12:35.590
请求，这意味着我们必须

00:12:34.340 --> 00:12:37.610
向其传递调用回调

00:12:35.590 --> 00:12:39.560
调用回调与回调

00:12:37.610 --> 00:12:41.420
包括完成的交易

00:12:39.560 --> 00:12:44.690
结果，在这种情况下，我们只是

00:12:41.420 --> 00:12:46.460
从中获取预测信息

00:12:44.690 --> 00:12:49.059
远程端点，我们将其放置到地图上

00:12:46.460 --> 00:12:53.540
对于给定的目的地

00:12:49.059 --> 00:12:55.069
显然，我们必须实施

00:12:53.540 --> 00:12:58.129
两种类型的失败回调

00:12:55.069 --> 00:13:00.499
要求我们有，所以我想

00:12:58.129 --> 00:13:02.480
你想要你很好，你知道我在哪里

00:13:00.499 --> 00:13:05.149
基本上这将是一个

00:13:02.480 --> 00:13:07.189
回调地狱，我不得不简化我的

00:13:05.149 --> 00:13:09.589
方案到两个服务只是为了尝试

00:13:07.189 --> 00:13:11.809
使它适合滑动原件

00:13:09.589 --> 00:13:13.910
基本方案有四个服务，因此

00:13:11.809 --> 00:13:16.879
那种代码很难

00:13:13.910 --> 00:13:19.309
编写调试并维护得非常清楚

00:13:16.879 --> 00:13:20.929
不会随着时间的推移而起作用

00:13:19.309 --> 00:13:27.529
这就是当你有

00:13:20.929 --> 00:13:29.959
有依赖性的服务，所以很好

00:13:27.529 --> 00:13:32.600
新闻是，这就是重点

00:13:29.959 --> 00:13:34.939
在Jack的rs21的演讲中，我们有了一个新的

00:13:32.600 --> 00:13:36.679
反应性调用程序，因此您可以在

00:13:34.939 --> 00:13:38.389
幻灯片的底部，我们有这个RX 

00:13:36.679 --> 00:13:40.670
基本上用来告诉的方法

00:13:38.389 --> 00:13:42.410
我们想要的jax-rs类容器

00:13:40.670 --> 00:13:44.660
使用同步反应式调用程序

00:13:42.410 --> 00:13:46.489
如果您查看的返回类型

00:13:44.660 --> 00:13:46.879
那个调用者不是未来的对象

00:13:46.489 --> 00:13:49.040
不再

00:13:46.879 --> 00:13:56.629
这是回应的完成阶段

00:13:49.040 --> 00:13:58.399
键入之间的主要区别

00:13:56.629 --> 00:14:00.350
未来和完成阶段的东西是

00:13:58.399 --> 00:14:02.269
 Java 8这样的完成阶段

00:14:00.350 --> 00:14:05.240
这是一种现代的API， 

00:14:02.269 --> 00:14:08.959
 Java 5 2004中的未来内容

00:14:05.240 --> 00:14:11.629
几乎是一个较旧的API，因此

00:14:08.959 --> 00:14:14.509
完成阶段是一个界面

00:14:11.629 --> 00:14:18.679
由可计算的未来实现，这是一个

00:14:14.509 --> 00:14:21.079
完整的API的想法实际上是采取

00:14:18.679 --> 00:14:24.139
任务，这个任务将是

00:14:21.079 --> 00:14:27.470
由于我们位于

00:14:24.139 --> 00:14:29.990
 Java 8焊机，此卡任务为

00:14:27.470 --> 00:14:31.730
将被同步执行

00:14:29.990 --> 00:14:33.889
除调用线程外的另一个线程

00:14:31.730 --> 00:14:36.319
默认情况下，我们可以通过执行程序

00:14:33.889 --> 00:14:37.999
服务的方式告诉API嘿

00:14:36.319 --> 00:14:40.639
您应该在执行此任务

00:14:37.999 --> 00:14:43.730
这个给定的执行人服务，或者这个

00:14:40.639 --> 00:14:47.480
给定线程的好处是

00:14:43.730 --> 00:14:49.850
给出了具有

00:14:47.480 --> 00:14:52.579
执行任务的责任

00:14:49.850 --> 00:14:54.949
链接正在进行的其他任务

00:14:52.579 --> 00:14:57.410
在此完成时执行

00:14:54.949 --> 00:14:59.869
完成阶段不是这样

00:14:57.410 --> 00:15:02.630
使用未来的API，您将无法做到

00:14:59.869 --> 00:15:05.300
在未来的API中，这个想法是

00:15:02.630 --> 00:15:07.880
真正打造一个

00:15:05.300 --> 00:15:10.010
同步任务在这里CS想

00:15:07.880 --> 00:15:14.270
我的第一个完成阶段

00:15:10.010 --> 00:15:17.440
触发两个任务21和22然后

00:15:14.270 --> 00:15:21.170
 22不触发任何东西21触发器

00:15:17.440 --> 00:15:23.840
 31在另一边，我也有

00:15:21.170 --> 00:15:28.100
与任务无关的另一个任务是

00:15:23.840 --> 00:15:29.600
 32，而31和32都将运行一次

00:15:28.100 --> 00:15:32.780
他们都完成了

00:15:29.600 --> 00:15:35.150
触发CS 41，所以这基本上是

00:15:32.780 --> 00:15:38.210
我可以创建的任务图

00:15:35.150 --> 00:15:39.830
使用此完成阶段API，这是

00:15:38.210 --> 00:15:42.320
现在的大局

00:15:39.830 --> 00:15:44.350
这个完成阶段的API相当

00:15:42.320 --> 00:15:46.820
复杂其中有很多方法

00:15:44.350 --> 00:15:49.490
也有很多方法可以完成

00:15:46.820 --> 00:15:52.130
未来的东西有点

00:15:49.490 --> 00:15:54.590
凌乱地去理解不容易

00:15:52.130 --> 00:15:56.690
首先了解它会做什么

00:15:54.590 --> 00:15:59.300
做我们在这里要做的事情真的是

00:15:56.690 --> 00:16:00.680
将简单的模式呈现给

00:15:59.300 --> 00:16:04.850
解决我们已经建立的问题

00:16:00.680 --> 00:16:07.160
与David一起触发查询

00:16:04.850 --> 00:16:11.750
红色服务给出的清单

00:16:07.160 --> 00:16:14.770
我们有目的地，让我们先走

00:16:11.750 --> 00:16:17.840
第一步是查询

00:16:14.770 --> 00:16:20.810
一旦有了我们就可以预测后端服务

00:16:17.840 --> 00:16:23.150
目的地清单请记住我们

00:16:20.810 --> 00:16:26.000
是客户，我们正在购买某种

00:16:23.150 --> 00:16:27.860
旅行到某个地方和网站

00:16:26.000 --> 00:16:30.560
我们正在想把我们推向其他

00:16:27.860 --> 00:16:33.680
我们可能感兴趣的目的地

00:16:30.560 --> 00:16:36.140
以及我们想要的目的地

00:16:33.680 --> 00:16:38.090
向信息添加预测

00:16:36.140 --> 00:16:40.040
此目的地和报价

00:16:38.090 --> 00:16:42.170
该目的地的价格和

00:16:40.040 --> 00:16:45.980
一切都分布在几个

00:16:42.170 --> 00:16:48.290
休息服务因此给定了

00:16:45.980 --> 00:16:52.250
目的地不明目的地

00:16:48.290 --> 00:16:54.290
我能做的第一件事就是查询

00:16:52.250 --> 00:16:56.870
使用这种预测服务

00:16:54.290 --> 00:16:58.820
此后大部分时间都在

00:16:56.870 --> 00:17:01.940
是一项红色的服务，我将得到

00:16:58.820 --> 00:17:04.510
实际上是一个JSON对象，所以一旦我有了

00:17:01.940 --> 00:17:07.280
将来某个时间此JSON对象

00:17:04.510 --> 00:17:09.920
还记得这是完成阶段么

00:17:07.280 --> 00:17:12.800
我能做的是我必须做的对不起病了

00:17:09.920 --> 00:17:13.340
使用一些基本的JSON构建器进行调制

00:17:12.800 --> 00:17:15.980
码

00:17:13.340 --> 00:17:18.760
就像这样，这是一个功能

00:17:15.980 --> 00:17:22.670
那只是一个JSON对象， 

00:17:18.760 --> 00:17:26.060
编组成为预测对象

00:17:22.670 --> 00:17:28.760
得到的数据我可以正确使用

00:17:26.060 --> 00:17:31.670
我该如何触发执行

00:17:28.760 --> 00:17:34.090
一旦完成阶段就开始运作

00:17:31.670 --> 00:17:36.410
完成得很好，我有一个API 

00:17:34.090 --> 00:17:39.020
查询预测这是我的完成

00:17:36.410 --> 00:17:41.750
状态对象然后应用马歇尔

00:17:39.020 --> 00:17:44.420
预测这将触发此

00:17:41.750 --> 00:17:46.700
应用触发方法方法调用将

00:17:44.420 --> 00:17:48.860
触发自己的JSON封送处理

00:17:46.700 --> 00:17:52.460
对象一旦可用即为

00:17:48.860 --> 00:17:54.890
有时候将来还可以，所以我

00:17:52.460 --> 00:17:58.160
需要把它揉成一种方法

00:17:54.890 --> 00:18:00.800
到达目的地

00:17:58.160 --> 00:18:01.850
首先会触发一个请求

00:18:00.800 --> 00:18:04.190
预测

00:18:01.850 --> 00:18:07.070
将返回JSON的res服务器

00:18:04.190 --> 00:18:09.650
对象将获得此JSON对象

00:18:07.070 --> 00:18:11.810
我孩子的情绪低落

00:18:09.650 --> 00:18:14.810
对象，然后一旦我有这个

00:18:11.810 --> 00:18:16.820
预测对象的想法是设置一个

00:18:14.810 --> 00:18:20.290
我目的地的特殊财产

00:18:16.820 --> 00:18:23.510
对象与此预测对象因此

00:18:20.290 --> 00:18:26.570
直接提供此预测

00:18:23.510 --> 00:18:29.390
在我的目的地箱中，所以基本上

00:18:26.570 --> 00:18:32.240
接受目标对象，但不接受

00:18:29.390 --> 00:18:34.250
用它做很多事情不会返回新的

00:18:32.240 --> 00:18:37.000
目标对象，它只是设置一个

00:18:34.250 --> 00:18:39.980
此目标对象内的属性

00:18:37.000 --> 00:18:42.530
所以这是一个需要

00:18:39.980 --> 00:18:44.960
目标对象，因为有一个

00:18:42.530 --> 00:18:47.180
然后应用那是触发

00:18:44.960 --> 00:18:48.740
自己编组，然后是

00:18:47.180 --> 00:18:50.990
触发设置

00:18:48.740 --> 00:18:54.260
对象内部的属性返回一个

00:18:50.990 --> 00:18:56.120
完成阶段避免建设

00:18:54.260 --> 00:18:58.490
这个功能什么也没做

00:18:56.120 --> 00:19:01.340
只是某种声明

00:18:58.490 --> 00:19:03.830
管道中的方法，所以

00:19:01.340 --> 00:19:06.770
立即返回，但当然

00:19:03.830 --> 00:19:09.830
任务本身将在某个时间执行

00:19:06.770 --> 00:19:12.170
未来的时间，所以一旦我有了我

00:19:09.830 --> 00:19:13.520
可以做同样的报价

00:19:12.170 --> 00:19:17.290
实例完全一样

00:19:13.520 --> 00:19:19.750
模式，如果我有三个或四个

00:19:17.290 --> 00:19:22.970
在我的目标对象中设置的属性

00:19:19.750 --> 00:19:24.800
查询三个或四个休息服务

00:19:22.970 --> 00:19:26.390
我可以相应的阅读服务

00:19:24.800 --> 00:19:29.690
乘以这个

00:19:26.390 --> 00:19:31.820
返回的功能数量

00:19:29.690 --> 00:19:36.110
竞争阶段无效，这是

00:19:31.820 --> 00:19:38.420
我将来会用什么

00:19:36.110 --> 00:19:41.720
我的旅行服务将开始什么？ 

00:19:38.420 --> 00:19:44.120
看起来像我可以创建这个

00:19:41.720 --> 00:19:46.940
填充目标函数

00:19:44.120 --> 00:19:49.040
基本上会到达目的地

00:19:46.940 --> 00:19:51.950
设置这个的不同属性

00:19:49.040 --> 00:19:54.230
目标对象使用的结果

00:19:51.950 --> 00:19:56.150
其余服务的查询

00:19:54.230 --> 00:19:58.190
我将要使用此静态

00:19:56.150 --> 00:20:01.400
未来完成方法

00:19:58.190 --> 00:20:04.310
类兼容的未来

00:20:01.400 --> 00:20:07.880
返回完成阶段，可以

00:20:04.310 --> 00:20:09.500
尽他们所能再次获得

00:20:07.880 --> 00:20:12.110
两者结合的可计算的未来

00:20:09.500 --> 00:20:14.960
那么可计算的未来方法

00:20:12.110 --> 00:20:18.410
完成状态对象此olaf对象

00:20:14.960 --> 00:20:20.600
将要过去的一切完成

00:20:18.410 --> 00:20:23.390
完成阶段将是

00:20:20.600 --> 00:20:26.090
完成自己，所以如果我有三个

00:20:23.390 --> 00:20:29.270
四个或更多财产来设置所有我

00:20:26.090 --> 00:20:31.910
需要做的只是按比例缩放此模式

00:20:29.270 --> 00:20:34.790
通过更多的完成阶段

00:20:31.910 --> 00:20:37.730
我可以做的奥拉夫方法

00:20:34.790 --> 00:20:41.120
现在的好处是，如果我有

00:20:37.730 --> 00:20:42.980
我的执行器服务中有很多线程

00:20:41.120 --> 00:20:45.350
将要执行所有这些

00:20:42.980 --> 00:20:45.830
请求将在

00:20:45.350 --> 00:20:48.620
平行

00:20:45.830 --> 00:20:52.250
假设我要设置50个属性

00:20:48.620 --> 00:20:54.890
如果我有25个线程，那么每个线程

00:20:52.250 --> 00:20:57.080
将处理可能的两个属性

00:20:54.890 --> 00:21:00.740
设置但如果我有50个以上

00:20:57.080 --> 00:21:02.930
正确处理每个查询

00:21:00.740 --> 00:21:06.290
设置将在给定的条件下处理

00:21:02.930 --> 00:21:08.900
从而使事情变得更快

00:21:06.290 --> 00:21:12.140
大卫在大片中展示了

00:21:08.900 --> 00:21:15.560
关于的图片

00:21:12.140 --> 00:21:17.780
的组织

00:21:15.560 --> 00:21:19.880
整个系统，所以这是

00:21:17.780 --> 00:21:22.430
到达目的地并将填充

00:21:19.880 --> 00:21:24.980
使用该目的地的属性

00:21:22.430 --> 00:21:27.280
其余服务的查询

00:21:24.980 --> 00:21:31.550
同步方式和并行方式

00:21:27.280 --> 00:21:34.420
对，所以现在我要去这个目的地

00:21:31.550 --> 00:21:37.700
从某处获取它，让我们这样做

00:21:34.420 --> 00:21:39.770
我实际上从res那里得到什么

00:21:37.700 --> 00:21:42.380
来自第一个读取服务的服务是

00:21:39.770 --> 00:21:44.660
目的地列表，所以我需要做什么

00:21:42.380 --> 00:21:48.080
现在是针对每个目的地

00:21:44.660 --> 00:21:50.390
现在一个接一个地应用此功能

00:21:48.080 --> 00:21:53.480
当然对流来说是不错的工作

00:21:50.390 --> 00:21:56.450
 API，因此我可以流式传输此列表

00:21:53.480 --> 00:21:59.240
每个目的地适用的目的地

00:21:56.450 --> 00:22:01.430
这个填充目标函数

00:21:59.240 --> 00:22:04.220
将返回兼容的未来

00:22:01.430 --> 00:22:06.500
一旦完成所有属性

00:22:04.220 --> 00:22:09.200
确切的目的地将是

00:22:06.500 --> 00:22:11.720
设置好吧，所以我在这

00:22:09.200 --> 00:22:15.370
在这里流，我有一个兼容的未来

00:22:11.720 --> 00:22:18.440
 /目的地各兼容的未来

00:22:15.370 --> 00:22:20.480
对应尽可能多的可比性

00:22:18.440 --> 00:22:23.060
未来我需要四个属性

00:22:20.480 --> 00:22:25.220
设置好，所以如果我真的会很多

00:22:23.060 --> 00:22:27.050
有50个目的地和三个属性

00:22:25.220 --> 00:22:29.390
设置为一百五十

00:22:27.050 --> 00:22:30.890
最后的可比未来，我

00:22:29.390 --> 00:22:32.930
将把所有这些可计算的功能

00:22:30.890 --> 00:22:35.930
在一个数组中为什么因为我是

00:22:32.930 --> 00:22:37.790
感兴趣的是所有的时间

00:22:35.930 --> 00:22:40.930
那些可以完成的未来将会完成

00:22:37.790 --> 00:22:43.280
为此，我将使用奥拉夫

00:22:40.930 --> 00:22:45.320
静态调用再次为此

00:22:43.280 --> 00:22:48.460
需要一个数组，所以我要把所有

00:22:45.320 --> 00:22:53.480
此流的结果

00:22:48.460 --> 00:22:55.610
在数组中映射好，那我该如何

00:22:53.480 --> 00:22:58.070
现在在我的休息服务中进行设置

00:22:55.610 --> 00:23:00.800
对象RS我实际上有两种模式

00:22:58.070 --> 00:23:03.080
第一个受欢迎的目的地

00:23:00.800 --> 00:23:05.990
返回一个空白并接收一个接收器

00:23:03.080 --> 00:23:10.010
响应，这是一个jax-rs 2.0 

00:23:05.990 --> 00:23:12.290
模式我首先查询目的地红色

00:23:10.010 --> 00:23:16.130
服务将返回我一个

00:23:12.290 --> 00:23:18.620
 JSON后的目标列表

00:23:16.130 --> 00:23:23.270
和封送我的JSON数组对象

00:23:18.620 --> 00:23:26.740
我们将其放在一边，然后我可以拿到我的

00:23:23.270 --> 00:23:29.360
通过组成这个完成阶段

00:23:26.740 --> 00:23:31.490
注定是这个完成阶段

00:23:29.360 --> 00:23:33.710
将获得目的地的列表

00:23:31.490 --> 00:23:36.050
我之前写的函数

00:23:33.710 --> 00:23:38.150
使用Zen堆肥向右滑动，然后

00:23:36.050 --> 00:23:41.720
奥拉夫记得

00:23:38.150 --> 00:23:44.150
目的地返回自己一个数组好吗

00:23:41.720 --> 00:23:47.480
所以这个可计算的未来奥拉夫将是

00:23:44.150 --> 00:23:50.060
一旦所有目的地都完成

00:23:47.480 --> 00:23:52.700
被他们的属性填充

00:23:50.060 --> 00:23:53.390
想要设置此返回更新

00:23:52.700 --> 00:23:55.760
目的地

00:23:53.390 --> 00:23:59.000
完成阶段，我需要通过

00:23:55.760 --> 00:24:01.460
完成阶段的有效负载为

00:23:59.000 --> 00:24:05.240
同步响应，因为这是

00:24:01.460 --> 00:24:09.290
这种模式在jax-rs中的工作方式

00:24:05.240 --> 00:24:12.350
 2.0，所以我需要切换此完成

00:24:09.290 --> 00:24:14.150
进入兼容的未来

00:24:12.350 --> 00:24:16.820
兼容的未来是对

00:24:14.150 --> 00:24:18.440
将来我可以调用get方法

00:24:16.820 --> 00:24:20.990
大卫告诉我的所有注意事项

00:24:18.440 --> 00:24:24.290
告诉你超时和类似的东西

00:24:20.990 --> 00:24:27.230
如果这个过程花了太长时间

00:24:24.290 --> 00:24:29.929
我会说老式的方式

00:24:27.230 --> 00:24:33.740
因为我在和jax-rs而写东西

00:24:29.929 --> 00:24:36.020
 2.1好，我也可以直接返回

00:24:33.740 --> 00:24:38.630
完成阶段和开幕

00:24:36.020 --> 00:24:43.280
完成阶段将由

00:24:38.630 --> 00:24:46.010
 jax-rs 2.1 API直接就可以了

00:24:43.280 --> 00:24:48.080
这是大图，我会说

00:24:46.010 --> 00:24:50.570
一个不平凡的现实世界的例子

00:24:48.080 --> 00:24:53.960
处理此完成的示例

00:24:50.570 --> 00:24:56.360
阶段API现在如果我发生了什么

00:24:53.960 --> 00:24:58.520
我有些时候有例外

00:24:56.360 --> 00:25:01.160
查询可能不是的红色服务

00:24:58.520 --> 00:25:04.820
在这里，我正在成熟一些JSON对象

00:25:01.160 --> 00:25:07.669
这可能会引发例外情况

00:25:04.820 --> 00:25:10.280
完成阶段的API是

00:25:07.669 --> 00:25:13.010
给定我的任务链的重点

00:25:10.280 --> 00:25:15.679
引发异常，然后所有

00:25:13.010 --> 00:25:18.650
下游完成阶段将是

00:25:15.679 --> 00:25:22.250
也提出了一个例外，它将

00:25:18.650 --> 00:25:24.290
如果我会破坏所有过程

00:25:22.250 --> 00:25:27.260
在某个时候有例外，但我

00:25:24.290 --> 00:25:29.179
有方法来处理

00:25:27.260 --> 00:25:31.940
不错，我的第一个是

00:25:29.179 --> 00:25:34.070
异常返回新值的方法

00:25:31.940 --> 00:25:36.770
完成阶段，我可以决定是否

00:25:34.070 --> 00:25:40.160
这个完成阶段本身就是错误的

00:25:36.770 --> 00:25:41.929
或不使用该行，让我们尝试

00:25:40.160 --> 00:25:43.760
做一些例外的聪明事

00:25:41.929 --> 00:25:47.360
知道这并不容易，但是我们可以

00:25:43.760 --> 00:25:49.700
最少尝试我也有一个handle方法

00:25:47.360 --> 00:25:52.910
这需要结果和

00:25:49.700 --> 00:25:55.190
如果没有例外，那么例外

00:25:52.910 --> 00:25:56.480
此异常对象将是新的，如果

00:25:55.190 --> 00:25:58.940
并非如此

00:25:56.480 --> 00:26:01.820
有一些东西，所以我可以决定

00:25:58.940 --> 00:26:03.770
创建一个新的结果，例如

00:26:01.820 --> 00:26:05.360
例如，如果我不靠近

00:26:03.770 --> 00:26:06.919
有预测，我可以忍受

00:26:05.360 --> 00:26:09.350
没有关于的信息

00:26:06.919 --> 00:26:11.929
播客我可以叫设定的预报

00:26:09.350 --> 00:26:14.359
与新的对象，我可以决定做

00:26:11.929 --> 00:26:16.519
那我也去了完整的方法

00:26:14.359 --> 00:26:19.070
而不是一点B功能

00:26:16.519 --> 00:26:21.109
需要一个不会

00:26:19.070 --> 00:26:23.389
返回任何东西，那是另一种方式

00:26:21.109 --> 00:26:24.739
处理异常的事实

00:26:23.389 --> 00:26:29.320
我有三种处理方式

00:26:24.739 --> 00:26:33.080
完成阶段API的异常

00:26:29.320 --> 00:26:35.629
所以这是这里要做的

00:26:33.080 --> 00:26:38.239
我们刚刚写的模式

00:26:35.629 --> 00:26:40.100
应用它直到年轻

00:26:38.239 --> 00:26:42.559
实例对象的马歇尔报价

00:26:40.100 --> 00:26:44.210
假设我们有一个例外

00:26:42.559 --> 00:26:46.039
我们可以说好吧，我们得到了

00:26:44.210 --> 00:26:48.139
例外，所以我们对此

00:26:46.039 --> 00:26:50.359
如果没有，则为异常方法

00:26:48.139 --> 00:26:53.029
例外，此异常调用将

00:26:50.359 --> 00:26:55.850
什么也没做，所以要透明

00:26:53.029 --> 00:26:58.279
在中国，事实上，如果

00:26:55.850 --> 00:26:59.960
提出了一个例外，事实并非如此

00:26:58.279 --> 00:27:03.200
不好的报价为此

00:26:59.960 --> 00:27:04.909
对象，因此我仍然可以设置新值

00:27:03.200 --> 00:27:08.119
为我的财产报价

00:27:04.909 --> 00:27:09.859
目的地，这次是我的完成

00:27:08.119 --> 00:27:12.320
阶段将不会再有错误

00:27:09.859 --> 00:27:17.509
多亏了这个的使用

00:27:12.320 --> 00:27:20.869
我也可以决定使用

00:27:17.509 --> 00:27:22.879
安达法的模式不是那样

00:27:20.869 --> 00:27:25.429
很好，因为我有这个if-then-else 

00:27:22.879 --> 00:27:27.529
在其中，因为我处在一个

00:27:25.429 --> 00:27:29.029
 lambda和函数式编程

00:27:27.529 --> 00:27:31.279
如果那真的不太适合

00:27:29.029 --> 00:27:33.409
我想在这个世界上，但是嘿，你可以

00:27:31.279 --> 00:27:35.149
如果您愿意，仍然可以使用它，如果

00:27:33.409 --> 00:27:37.669
投掷球几乎意味着我

00:27:35.149 --> 00:27:39.590
没有任何例外，所以我可以设置

00:27:37.669 --> 00:27:42.259
如果为空，则使用这样的引号

00:27:39.590 --> 00:27:44.059
我决定做不好，我需要

00:27:42.259 --> 00:27:48.750
决定如何处理

00:27:44.059 --> 00:27:51.520
这个目标对象可以

00:27:48.750 --> 00:27:55.100
 [音乐] 

00:27:51.520 --> 00:27:57.920
好的，所以您已经看到了一些使用示例

00:27:55.100 --> 00:28:01.520
现在是新的rx调用程序的一部分

00:27:57.920 --> 00:28:03.950
 Jax rs21您已经为我们所有人看到了

00:28:01.520 --> 00:28:08.060
示例我们一直在使用HTTP GET 

00:28:03.950 --> 00:28:09.440
方法，但如果它适用于所有HTTP 

00:28:08.060 --> 00:28:12.290
所支持的方法

00:28:09.440 --> 00:28:14.240
客户端API对象出现-1就是

00:28:12.290 --> 00:28:16.160
删除获取头像选项，依此类推

00:28:14.240 --> 00:28:17.960
基本上所有的HTTP方法，除了补丁

00:28:16.160 --> 00:28:22.520
因为补丁不支持

00:28:17.960 --> 00:28:24.200
客户端API现在，我们已经讨论了什么

00:28:22.520 --> 00:28:26.000
今天基本上也可以

00:28:24.200 --> 00:28:27.770
利用

00:28:26.000 --> 00:28:31.700
压缩存储API是其中的一部分

00:28:27.770 --> 00:28:34.160
 Java SE 8现在我们也承认

00:28:31.700 --> 00:28:38.600
在其中还有其他反应式API 

00:28:34.160 --> 00:28:41.080
市场使jax-rs成为一体

00:28:38.600 --> 00:28:44.900
规范以某种方式编写

00:28:41.080 --> 00:28:46.760
因此，这是强制性的

00:28:44.900 --> 00:28:50.930
支持补全API，但是

00:28:46.760 --> 00:28:53.090
同时也开放给第三方API 

00:28:50.930 --> 00:28:55.130
 jax-rs实现者可以决定支持

00:28:53.090 --> 00:28:57.950
除了压缩阶段的api 

00:28:55.130 --> 00:29:00.350
自动反应式API，如果您看

00:28:57.950 --> 00:29:02.300
新泽西州的一口井的球衣

00:29:00.350 --> 00:29:05.360
 jax-rs参考

00:29:02.300 --> 00:29:07.040
我们确实支持的实施

00:29:05.360 --> 00:29:10.040
压缩阶段

00:29:07.040 --> 00:29:12.170
我们必须做到的，但我们也支持

00:29:10.040 --> 00:29:15.710
番石榴稳定的未来，我们也支持

00:29:12.170 --> 00:29:19.250
我们在Java和Java 2中的分量

00:29:15.710 --> 00:29:23.210
工作，所以如果您想使用

00:29:19.250 --> 00:29:25.160
您首先遇到的气泡示例

00:29:23.210 --> 00:29:28.130
当您构建客户端容器时

00:29:25.160 --> 00:29:31.070
您需要将特定的调用程序传递给它

00:29:28.130 --> 00:29:33.470
在这种情况下，该API的提供者是

00:29:31.070 --> 00:29:35.780
我们可利用的调用方提供程序，因此您

00:29:33.470 --> 00:29:38.510
通过那堂课，然后当你做

00:29:35.780 --> 00:29:41.780
您需要通过的请求

00:29:38.510 --> 00:29:45.080
使用rx方法的特定调用程序

00:29:41.780 --> 00:29:48.050
然后我们就可以使用

00:29:45.080 --> 00:29:50.030
特定的反应式API，所以基本上

00:29:48.050 --> 00:29:51.320
可以使用我们拥有的模式

00:29:50.030 --> 00:29:54.800
今天讨论的压缩

00:29:51.320 --> 00:29:56.720
该tej API，但您也可以使用该API 

00:29:54.800 --> 00:29:59.600
思维方式，但使用具体

00:29:56.720 --> 00:30:01.100
市场上的反应式API 

00:29:59.600 --> 00:30:03.780
再次，这是可选的，但这是

00:30:01.100 --> 00:30:06.760
我们喜欢的东西

00:30:03.780 --> 00:30:08.890
现在让我们快速快速地谈论CDI 

00:30:06.760 --> 00:30:12.970
我的意思是jax-rs之间有什么联系

00:30:08.890 --> 00:30:16.000
我们已经发布了Java 8中的CDI和CDI 

00:30:12.970 --> 00:30:21.820
 CDI GSR三七三六五

00:30:16.000 --> 00:30:23.710
而CDI的两个解决方案

00:30:21.820 --> 00:30:25.690
很多新事物有很多新事物

00:30:23.710 --> 00:30:28.299
东西，但CDI的东西之一

00:30:25.690 --> 00:30:29.860
正在添加是一个同步事件，所以您

00:30:28.299 --> 00:30:32.200
知道在CDI中，我们自

00:30:29.860 --> 00:30:33.820
开始这个很好的七种机制

00:30:32.200 --> 00:30:35.710
所以你有这个生产者的消费者

00:30:33.820 --> 00:30:38.049
基本实现的模式

00:30:35.710 --> 00:30:39.490
让您轻松产生事件

00:30:38.049 --> 00:30:42.190
您的应用程序将被消耗

00:30:39.490 --> 00:30:44.230
我在欧洲其他地方的某个地方

00:30:42.190 --> 00:30:47.620
您的应用程序的问题是，直到

00:30:44.230 --> 00:30:49.780
 CDI-纯粹是同步的

00:30:47.620 --> 00:30:51.370
基本上你是在消耗事件

00:30:49.780 --> 00:30:55.659
与生产趋势相同

00:30:51.370 --> 00:30:58.419
线程这在CDI中不再是真的- 

00:30:55.659 --> 00:31:00.520
所以我们现在有能力提高和

00:30:58.419 --> 00:31:02.230
消耗一个同步事件，这样

00:31:00.520 --> 00:31:05.590
它的工作原理完全一样

00:31:02.230 --> 00:31:10.299
所以我们注入给定的事件

00:31:05.590 --> 00:31:12.159
输入，然后在叙利亚很好地输入

00:31:10.299 --> 00:31:13.960
一直是同步事件，我们会

00:31:12.159 --> 00:31:16.929
在那个事件上调用了公平

00:31:13.960 --> 00:31:19.360
如果给出的是NASA事件，则该方法

00:31:16.929 --> 00:31:22.299
我们正在调用fire异步方法，因此

00:31:19.360 --> 00:31:23.860
这是CDI中的新方法-所以这是

00:31:22.299 --> 00:31:26.710
生产方面，所以基本上我是

00:31:23.860 --> 00:31:29.260
在这里，显然在

00:31:26.710 --> 00:31:31.750
我想要的其他地方

00:31:29.260 --> 00:31:34.000
消耗那个事件来消耗那个

00:31:31.750 --> 00:31:36.130
我只需要定义一个行为

00:31:34.000 --> 00:31:38.650
没有什么可观察的，所以我有一个

00:31:36.130 --> 00:31:42.100
正在使用此新方法的方法

00:31:38.650 --> 00:31:42.909
观察到同步注释，并在

00:31:42.100 --> 00:31:45.460
任何时候

00:31:42.909 --> 00:31:48.220
我的活动将被解雇，但是

00:31:45.460 --> 00:31:49.809
生产者，我的观察者将在

00:31:48.220 --> 00:31:51.700
锦上添花

00:31:49.809 --> 00:31:55.929
以专注的方式

00:31:51.700 --> 00:31:57.700
 CI中的新功能-而您

00:31:55.929 --> 00:31:59.950
看到当我们触发一个事件时

00:31:57.700 --> 00:32:02.950
我们得到的回报是完成

00:31:59.950 --> 00:32:05.350
舞台，以便它可以进入

00:32:02.950 --> 00:32:06.429
结合我们完成的阶段

00:32:05.350 --> 00:32:09.970
与jax-rs讨论过

00:32:06.429 --> 00:32:12.039
在那个完成阶段对象之前

00:32:09.970 --> 00:32:14.850
同样，这也是关键

00:32:12.039 --> 00:32:14.850
两个API之间

00:32:15.160 --> 00:32:20.330
现在您可以通过

00:32:18.440 --> 00:32:23.150
执行器服务，这就是

00:32:20.330 --> 00:32:31.250
当你开火的时候就完成了

00:32:23.150 --> 00:32:33.080
该事件基本上是您何时

00:32:31.250 --> 00:32:34.880
你是说你想

00:32:33.080 --> 00:32:36.950
同步执行

00:32:34.880 --> 00:32:39.380
不提供执行服务

00:32:36.950 --> 00:32:42.110
实际上会在一个共同的地方被调用

00:32:39.380 --> 00:32:44.180
 Java 8虚拟池期间出现雾

00:32:42.110 --> 00:32:45.800
机器，但你也有

00:32:44.180 --> 00:32:48.290
通过遗嘱执行人的可能性

00:32:45.800 --> 00:32:49.910
参数以确保您的任务

00:32:48.290 --> 00:32:52.340
将要执行

00:32:49.910 --> 00:32:55.070
执行器，这特别有用

00:32:52.340 --> 00:32:56.450
在您的CDI世界中

00:32:55.070 --> 00:32:59.420
实例你有一个正在运行的系统

00:32:56.450 --> 00:33:03.590
触发一个事件，这个事件是

00:32:59.420 --> 00:33:06.590
应该更新某种摇摆

00:33:03.590 --> 00:33:09.080
面板或jfif xpanel，或者如果您位于

00:33:06.590 --> 00:33:11.540
 Android空间有点人类

00:33:09.080 --> 00:33:13.790
界面面板，您知道

00:33:11.540 --> 00:33:16.790
为了更新这种

00:33:13.790 --> 00:33:19.310
图形组件的组件使用

00:33:16.790 --> 00:33:20.840
图形界面组件和

00:33:19.310 --> 00:33:22.760
正确地，您需要执行该代码

00:33:20.840 --> 00:33:25.220
在特殊的线程中

00:33:22.760 --> 00:33:27.230
遗嘱执行人，因此您可以将遗嘱执行人作为

00:33:25.220 --> 00:33:29.060
这里的参数，这真的

00:33:27.230 --> 00:33:30.860
当您想要这样做时必须

00:33:29.060 --> 00:33:33.950
实例swing实用程序comic-con 

00:33:30.860 --> 00:33:36.890
稍后调用是

00:33:33.950 --> 00:33:39.020
执行程序界面可能看起来很奇怪

00:33:36.890 --> 00:33:41.600
但是确实如此，您可以通过

00:33:39.020 --> 00:33:44.510
确保此有效载荷正在运行

00:33:41.600 --> 00:33:46.460
触发旋转面板的更新

00:33:44.510 --> 00:33:48.620
例如在右边的右边

00:33:46.460 --> 00:33:52.700
线程，这就是为什么它被添加到

00:33:48.620 --> 00:33:56.360
也可以在CDI中使用，我认为是时候打包了

00:33:52.700 --> 00:33:57.340
到那边去，这样结束时间

00:33:56.360 --> 00:34:01.610
时间

00:33:57.340 --> 00:34:05.120
令人难以置信，所以今天我们讨论了

00:34:01.610 --> 00:34:07.820
关于Jax rs21 API和CDI到

00:34:05.120 --> 00:34:10.210
这些API是较大型API的一部分

00:34:07.820 --> 00:34:15.500
 Java 8的努力

00:34:10.210 --> 00:34:18.560
定于12天前九月21日

00:34:15.500 --> 00:34:20.150
他们旁边的人不太好

00:34:18.560 --> 00:34:25.130
有一些不错的草皮引擎

00:34:20.150 --> 00:34:27.590
 Java还像支持力量hep-2一样

00:34:25.130 --> 00:34:29.960
某些方面对Jason B的servlet API支持

00:34:27.590 --> 00:34:32.120
我们的代码中，我们使用了Jason B 

00:34:29.960 --> 00:34:34.520
 API，使我们能够轻松地

00:34:32.120 --> 00:34:37.220
 Marshall和Marshall Java对象以及

00:34:34.520 --> 00:34:39.470
 JSON文档等，依此类推

00:34:37.220 --> 00:34:41.240
关于这些API的大部分优点是

00:34:39.470 --> 00:34:43.340
他们显然可以成为

00:34:41.240 --> 00:34:45.110
 Java平台，也可以使用

00:34:43.340 --> 00:34:47.419
在Java平台之外，那就是

00:34:45.110 --> 00:34:51.140
基本上我们今天所做的

00:34:47.419 --> 00:34:52.820
唯一的事情是，如果您正在使用

00:34:51.140 --> 00:34:54.770
 Java中的完成阶段

00:34:52.820 --> 00:34:56.780
您需要通过管理的平台

00:34:54.770 --> 00:34:59.210
执行服务，因为

00:34:56.780 --> 00:35:01.130
容器必须基本管理所有

00:34:59.210 --> 00:35:05.450
那个你会的线程

00:35:01.130 --> 00:35:06.890
被用来使我们有两个

00:35:05.450 --> 00:35:12.190
提问时间

00:35:06.890 --> 00:35:12.190
是的，先生

00:35:16.150 --> 00:35:21.110
是的，杰克的逮捕，你可以在上面用它

00:35:18.710 --> 00:35:24.250
 Java的人看到那不是我们一直在做的

00:35:21.110 --> 00:35:28.910
这样做是为了让杰克逮捕杰森B 

00:35:24.250 --> 00:35:30.680
 Servlet JSON P cgi-bin验证GSF为

00:35:28.910 --> 00:35:33.170
一种棘手和安全的安全性是

00:35:30.680 --> 00:35:37.400
显然，只有Java的唯一API 

00:35:33.170 --> 00:35:39.110
所以，是的，忘了提及

00:35:37.400 --> 00:35:41.240
压缩阶段的API是

00:35:39.110 --> 00:35:46.960
基本上我们今天谈话的核心是

00:35:41.240 --> 00:35:46.960
 Java C是是是

00:36:01.440 --> 00:36:05.260
添加一些重复问题

00:36:03.670 --> 00:36:07.329
是的，我会重复，好的，抱歉，我会重复

00:36:05.260 --> 00:36:09.099
问题是关于以下事实

00:36:07.329 --> 00:36:12.309
当您到达完成阶段

00:36:09.099 --> 00:36:14.380
您要确保此jax-rs方法

00:36:12.309 --> 00:36:17.380
它仍然在

00:36:14.380 --> 00:36:20.740
异步时尚好吗，所以

00:36:17.380 --> 00:36:23.559
实际上，答案是

00:36:20.740 --> 00:36:26.260
完成阶段完成的任务是

00:36:23.559 --> 00:36:28.030
在一个线程中执行

00:36:26.260 --> 00:36:30.220
您已通过的执行人服务

00:36:28.030 --> 00:36:32.260
参数，因为您可以传递

00:36:30.220 --> 00:36:35.170
创建时将执行程序作为参数

00:36:32.260 --> 00:36:37.750
任务或当您致电然后申请

00:36:35.170 --> 00:36:40.359
然后除了然后撰写等等

00:36:37.750 --> 00:36:44.290
或在评论中，例如您的

00:36:40.359 --> 00:36:45.880
您的Java 8虚拟机就可以了

00:36:44.290 --> 00:36:49.089
是保证的，因为这就是

00:36:45.880 --> 00:36:53.170
 Java AC 8完成阶段可完成

00:36:49.089 --> 00:36:54.579
将来的东西现在可以很好地工作了

00:36:53.170 --> 00:36:57.640
给定点，你需要得到结果

00:36:54.579 --> 00:37:00.670
的权利，你必须等待

00:36:57.640 --> 00:37:04.270
为了得到它的结果，所以这必须

00:37:00.670 --> 00:37:06.970
被同步制作好了，你们都可以

00:37:04.270 --> 00:37:09.339
仅将结果提供给

00:37:06.970 --> 00:37:11.619
此结果一经发布，客户端

00:37:09.339 --> 00:37:13.780
所以在某个时候你会退缩

00:37:11.619 --> 00:37:15.670
在某种同步呼叫上

00:37:13.780 --> 00:37:18.760
触发此同步呼叫

00:37:15.670 --> 00:37:20.349
通过API本身同步

00:37:18.760 --> 00:37:22.150
它触发了一个，结果是

00:37:20.349 --> 00:37:24.849
可用，您不必等待

00:37:22.150 --> 00:37:27.040
你自己，这对API来说还不算老

00:37:24.849 --> 00:37:29.710
不知道它是否回答了你的问题

00:37:27.040 --> 00:37:33.059
是的，谢谢

00:37:29.710 --> 00:37:33.059
还有其他问题吗

00:37:33.930 --> 00:37:37.380
来吧别害羞

00:37:42.189 --> 00:37:47.479
好吧，我们会给你一分钟

00:37:44.719 --> 00:37:48.949
返回，所以我们要感谢你

00:37:47.479 --> 00:37:50.539
我们来到这里，希望您喜欢

00:37:48.949 --> 00:37:53.740
并且请确保留下反馈

00:37:50.539 --> 00:37:57.820
当你离开房间的时候谢谢

00:37:53.740 --> 00:37:57.820
 [掌声] 

