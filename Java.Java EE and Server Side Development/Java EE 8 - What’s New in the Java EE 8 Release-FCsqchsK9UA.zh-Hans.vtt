WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.359 --> 00:00:09.309
好，伙计们终于为所有

00:00:06.460 --> 00:00:12.880
这里的技术困难远远超出了

00:00:09.309 --> 00:00:14.440
在我开始吃饱之前我们的控制

00:00:12.880 --> 00:00:16.480
披露我一直在处理

00:00:14.440 --> 00:00:19.900
如果我失去声音我会讨厌

00:00:16.480 --> 00:00:23.199
提前道歉，可能会这样

00:00:19.900 --> 00:00:25.300
欢迎参加Java EE 8会议

00:00:23.199 --> 00:00:29.199
琳达·德·麦克海尔我是其中之一

00:00:25.300 --> 00:00:31.839
 Java EE 8的规范引线

00:00:29.199 --> 00:00:33.970
平台，在本次演讲中，我将

00:00:31.839 --> 00:00:35.860
在谈论新的Java EE 8 

00:00:33.970 --> 00:00:38.230
释放我们完成的工作

00:00:35.860 --> 00:00:40.600
新功能是非常

00:00:38.230 --> 00:00:42.430
在会议上进行了很多高层概述

00:00:40.600 --> 00:00:44.620
演讲结束时，我会给你一个

00:00:42.430 --> 00:00:46.720
指向会话的指针列表

00:00:44.620 --> 00:00:49.450
您可以听到许多关于API的信息

00:00:46.720 --> 00:00:58.630
从我们的规格可以更深入地了解

00:00:49.450 --> 00:01:00.430
这个会议我不习惯两个

00:00:58.630 --> 00:01:03.250
窗户了，所以我希望我不会

00:01:00.430 --> 00:01:05.229
弄糟这个太糟糕了，所以我要

00:01:03.250 --> 00:01:06.970
首先简要概述一下

00:01:05.229 --> 00:01:10.439
历史背景

00:01:06.970 --> 00:01:12.850
 Java EE 8为何花了这么长时间

00:01:10.439 --> 00:01:17.409
然后我要讲的大部分内容

00:01:12.850 --> 00:01:19.380
谈论jsr和M ARS 

00:01:17.409 --> 00:01:23.319
我们解决的维护版本

00:01:19.380 --> 00:01:25.299
作为Java EE 8中的目标

00:01:23.319 --> 00:01:27.789
我会说一些关于我们的总结

00:01:25.299 --> 00:01:30.159
当前状态和我们的计划

00:01:27.789 --> 00:01:31.569
未来，如果你去了其中之一

00:01:30.159 --> 00:01:33.939
今天早上您可能有过主题演讲

00:01:31.569 --> 00:01:36.219
听到了一些类似的话， 

00:01:33.939 --> 00:01:41.979
最后我会留给你一些

00:01:36.219 --> 00:01:46.600
 Java的其他演示文稿的指针

00:01:41.979 --> 00:01:50.469
 EE 8是下一步，也可能是最后一步

00:01:46.600 --> 00:01:52.990
在Java EE品牌中发展

00:01:50.469 --> 00:01:56.649
我们这里的企业平台

00:01:52.990 --> 00:01:58.779
在甲骨文公司，因此该平台

00:01:56.649 --> 00:02:00.399
越来越大，显然我们有网络

00:01:58.779 --> 00:02:02.499
如果您不需要完整的个人资料

00:02:00.399 --> 00:02:05.709
完整平台的功能

00:02:02.499 --> 00:02:07.090
这个版本我们遵循了

00:02:05.709 --> 00:02:10.840
我们设定的许多目标

00:02:07.090 --> 00:02:13.300
自己使用Java EE 7，即专注于

00:02:10.840 --> 00:02:15.900
网络层技术，确保我们

00:02:13.300 --> 00:02:19.030
网络层实现现代化

00:02:15.900 --> 00:02:21.160
延续我们的易用性趋势

00:02:19.030 --> 00:02:24.070
通过充分利用来发展

00:02:21.160 --> 00:02:26.560
 CDI提供的设施，然后

00:02:24.070 --> 00:02:28.780
我们想要解决的另一个项目

00:02:26.560 --> 00:02:34.840
长期以来是现代化

00:02:28.780 --> 00:02:38.860
简化安全API的操作

00:02:34.840 --> 00:02:41.740
在这里我们快速回顾历史

00:02:38.860 --> 00:02:46.710
在此版本上开始这项工作

00:02:41.740 --> 00:02:46.710
我们在2014年提交了SRS 

00:02:47.460 --> 00:02:53.410
不幸的是有一段时间

00:02:49.720 --> 00:02:55.870
作为我们的一些规格中断了将近一年

00:02:53.410 --> 00:02:57.880
线索转移到更高的优先级

00:02:55.870 --> 00:03:00.270
内部任务，就像我们

00:02:57.880 --> 00:03:03.880
并没有取得太多进展

00:03:00.270 --> 00:03:06.280
所以在2016年，当我们的资源再次

00:03:03.880 --> 00:03:08.230
解放了我们后退了一步，我们

00:03:06.280 --> 00:03:11.530
看着我们真的专注吗

00:03:08.230 --> 00:03:13.800
适当地，我们如何获得释放

00:03:11.530 --> 00:03:16.960
优先事项

00:03:13.800 --> 00:03:19.150
在我们完成的时间范围内完成

00:03:16.960 --> 00:03:24.430
以为我们要解决的是

00:03:19.150 --> 00:03:26.950
到2017年，所以我们要做的是

00:03:24.430 --> 00:03:30.400
专注于我们认为的那些项目

00:03:26.950 --> 00:03:34.030
是最重要的，所以这些是

00:03:30.400 --> 00:03:38.230
 Java EE 8的最初目标是

00:03:34.030 --> 00:03:42.790
我们提交的jsr的条款

00:03:38.230 --> 00:03:45.550
但是经过我们之后，我们

00:03:42.790 --> 00:03:49.090
意识到其中一些较少

00:03:45.550 --> 00:03:51.400
对于云中的新趋势很重要

00:03:49.090 --> 00:03:54.460
在微服务中，也许我们

00:03:51.400 --> 00:03:58.090
应该优先考虑那些东西

00:03:54.460 --> 00:04:01.120
我们所做的是我们进行了社区

00:03:58.090 --> 00:04:03.790
调查此目标是

00:04:01.120 --> 00:04:05.530
验证我们的直觉是否

00:04:03.790 --> 00:04:06.960
我们应该重新聚焦

00:04:05.530 --> 00:04:10.480
适当

00:04:06.960 --> 00:04:12.850
确实，调查是否使我们以为

00:04:10.480 --> 00:04:16.120
应该专注于网络层技术

00:04:12.850 --> 00:04:18.430
网络层的现代化

00:04:16.120 --> 00:04:21.040
其他领域，例如JMS 

00:04:18.430 --> 00:04:23.170
相对成熟的技术

00:04:21.040 --> 00:04:25.390
对云环境不太重要

00:04:23.170 --> 00:04:27.900
我们想要的管理API 

00:04:25.390 --> 00:04:30.000
再次解决现有问题

00:04:27.900 --> 00:04:32.220
管理API，这本来可以

00:04:30.000 --> 00:04:34.350
好的现代化不是

00:04:32.220 --> 00:04:37.650
大量使用，所以我们说好吧，也许我们

00:04:34.350 --> 00:04:41.460
不想在那里优先和MVC 

00:04:37.650 --> 00:04:43.740
这是一个新的jsr 

00:04:41.460 --> 00:04:46.229
云中的应用程序

00:04:43.740 --> 00:04:48.630
无头的所以MVC似乎少了

00:04:46.229 --> 00:04:51.389
我们对MVC的优先考虑

00:04:48.630 --> 00:04:53.970
 jsr是我们将其交给

00:04:51.389 --> 00:04:57.509
专家组，那是

00:04:53.970 --> 00:04:59.880
尽管成功完成了MVC 1o 

00:04:57.509 --> 00:05:04.740
它不是Java EE 8平台的一部分

00:04:59.880 --> 00:05:06.930
好的，所以这张幻灯片反映了

00:05:04.740 --> 00:05:12.240
我们删除了

00:05:06.930 --> 00:05:18.510
 JMS和管理方面的工作，然后

00:05:12.240 --> 00:05:20.550
削减对MVC的确定，所以现在我要

00:05:18.510 --> 00:05:23.690
了解这个话题， 

00:05:20.550 --> 00:05:27.360
各种J afar的调查

00:05:23.690 --> 00:05:29.880
正如我在关注重点之前所说的那样

00:05:27.360 --> 00:05:31.830
将在网络层上增强功能

00:05:29.880 --> 00:05:34.470
通过利用CDI进行开发

00:05:31.830 --> 00:05:36.210
然后简化和

00:05:34.470 --> 00:05:39.930
周边地区的现代化

00:05:36.210 --> 00:05:42.389
安全，所以这些都是重点

00:05:39.930 --> 00:05:44.729
确实是在Web层并利用

00:05:42.389 --> 00:05:52.380
 CDI在此过程中，所以我想开始

00:05:44.729 --> 00:05:56.280
好的Jason处理Jason 

00:05:52.380 --> 00:06:00.810
处理API是作为的一部分引入的

00:05:56.280 --> 00:06:04.110
 Java EE 7当时是新技术

00:06:00.810 --> 00:06:07.260
我们希望它继续发展到

00:06:04.110 --> 00:06:09.780
与新兴标准保持同步

00:06:07.260 --> 00:06:12.449
有三个标准是

00:06:09.780 --> 00:06:15.630
 IETF制作的我们想要跟踪的

00:06:12.449 --> 00:06:19.470
并合并到JSON的api中

00:06:15.630 --> 00:06:22.979
处理即Jason指针Jason 

00:06:19.470 --> 00:06:25.949
补丁和杰森合并补丁，我们也

00:06:22.979 --> 00:06:30.510
想要添加类和方法到

00:06:25.949 --> 00:06:32.460
更好地利用Java SE 8流

00:06:30.510 --> 00:06:36.750
操作，以便您可以利用

00:06:32.460 --> 00:06:39.260
这些在您的报价中取消引用JSON 

00:06:36.750 --> 00:06:39.260
查询

00:06:39.639 --> 00:06:46.240
好吧，Jason指针，它叫什么名字

00:06:43.659 --> 00:06:48.580
表明这只是一个指针

00:06:46.240 --> 00:06:51.370
指向Jason文档

00:06:48.580 --> 00:06:54.129
引用一个具有字符串的JSON值

00:06:51.370 --> 00:06:57.819
基于语法，并且有方法

00:06:54.129 --> 00:07:01.090
允许您提取值或使用

00:06:57.819 --> 00:07:03.210
转换杰森的指针

00:07:01.090 --> 00:07:08.500
添加删除和替换的文档

00:07:03.210 --> 00:07:11.500
操作，所以如果我们看一个简单的

00:07:08.500 --> 00:07:16.419
例如，我们正在创建一个指针

00:07:11.500 --> 00:07:20.289
在我们的相邻数组上的文档

00:07:16.419 --> 00:07:22.210
我们的权利，它有两个要素

00:07:20.289 --> 00:07:24.129
代表杜克，另一个代表

00:07:22.210 --> 00:07:26.860
简，他们有电话号码，依此类推

00:07:24.129 --> 00:07:28.719
所以我们创建一个指针

00:07:26.860 --> 00:07:32.740
这只是一个指针，不是

00:07:28.719 --> 00:07:37.870
仍参考我们的文档

00:07:32.740 --> 00:07:40.719
为此，我们将引用传递给

00:07:37.870 --> 00:07:44.500
 Jason文档作为get的参数

00:07:40.719 --> 00:07:47.889
指针的value方法，然后我们

00:07:44.500 --> 00:07:55.169
用它来提取他们对不起，我们用

00:07:47.889 --> 00:07:58.330
提取相关值

00:07:55.169 --> 00:08:00.819
这一次我又是我们的文件

00:07:58.330 --> 00:08:03.610
将要使用替换替换

00:08:00.819 --> 00:08:07.479
 Jason指针转换方法

00:08:03.610 --> 00:08:10.629
文档，而我这样做的方式很明显

00:08:07.479 --> 00:08:14.699
替换第一个元素的值

00:08:10.629 --> 00:08:14.699
新手机检查文档

00:08:17.099 --> 00:08:25.360
 JSON修补程序修补附近的自身

00:08:21.729 --> 00:08:28.719
文档，它表示一个序列

00:08:25.360 --> 00:08:32.229
您应用于目标的操作

00:08:28.719 --> 00:08:34.750
文件和IETF定义了确切的集合

00:08:32.229 --> 00:08:40.390
这些操作中的

00:08:34.750 --> 00:08:43.329
添加删除替换移动或复制

00:08:40.390 --> 00:08:46.420
您要做的是使用JSON补丁

00:08:43.329 --> 00:08:49.120
生成补丁的构建器方法

00:08:46.420 --> 00:08:52.270
您构建补丁，然后

00:08:49.120 --> 00:08:53.260
通过Apply将其应用于文档

00:08:52.270 --> 00:08:56.220
方法

00:08:53.260 --> 00:09:02.550
我的Jason数组方法可以让你

00:08:56.220 --> 00:09:02.550
允许您转换补丁

00:09:03.420 --> 00:09:10.060
所以这是另一个例子，我们使用

00:09:07.330 --> 00:09:14.170
修补程序生成器来构建修补程序并

00:09:10.060 --> 00:09:16.830
那我如果不动就可以看到

00:09:14.170 --> 00:09:20.680
周围那么多，然后我们使用

00:09:16.830 --> 00:09:22.990
替换方法-我们使用Builder 

00:09:20.680 --> 00:09:25.660
制作补丁的方法

00:09:22.990 --> 00:09:27.790
该补丁有两个操作

00:09:25.660 --> 00:09:30.880
替换一个值，然后第二个

00:09:27.790 --> 00:09:33.220
删除数组的第二个元素

00:09:30.880 --> 00:09:36.850
现在，当您执行补丁时，这些

00:09:33.220 --> 00:09:40.330
操作按顺序应用，因此

00:09:36.850 --> 00:09:42.550
补丁的后续操作

00:09:40.330 --> 00:09:44.470
可以参考在

00:09:42.550 --> 00:09:47.200
补丁的先前操作，如果

00:09:44.470 --> 00:09:51.100
这就是您想要的，所以我们在这里建立

00:09:47.200 --> 00:09:52.360
补丁，然后当我们应用它时

00:09:51.100 --> 00:09:55.720
首先发生的是

00:09:52.360 --> 00:09:58.570
手机的改造，然后

00:09:55.720 --> 00:10:06.730
第二件事是移除

00:09:58.570 --> 00:10:10.300
的第二个元素，因此合并补丁是

00:10:06.730 --> 00:10:12.610
这些IETF标准中的另一个

00:10:10.300 --> 00:10:16.750
这种工作方式有点

00:10:12.610 --> 00:10:19.210
不同的是，你基本上比较

00:10:16.750 --> 00:10:21.880
补丁中的值

00:10:19.210 --> 00:10:25.120
原始文件，然后根据

00:10:21.880 --> 00:10:28.990
它们如何联系您产生您的输出

00:10:25.120 --> 00:10:31.360
所以，如果如果该元素的补丁

00:10:28.990 --> 00:10:33.130
参考文献在原始文档中

00:10:31.360 --> 00:10:35.620
然后您转换的价值是

00:10:33.130 --> 00:10:37.780
如果它不存在，则引用

00:10:35.620 --> 00:10:40.570
原始文档，然后将其添加到

00:10:37.780 --> 00:10:43.270
文档以及它是否为空值

00:10:40.570 --> 00:10:48.940
然后说删除元素

00:10:43.270 --> 00:10:50.890
在文档中然后最后

00:10:48.940 --> 00:10:55.300
我想谈谈我们所做的

00:10:50.890 --> 00:10:58.650
关于对sc8流的支持

00:10:55.300 --> 00:10:58.650
操作对不起

00:11:01.140 --> 00:11:07.000
所以在这里，我们可以将其视为

00:11:03.670 --> 00:11:08.440
 JSON查询，我们正在使用联系人

00:11:07.000 --> 00:11:14.170
再次记录

00:11:08.440 --> 00:11:17.640
所以我们在这里过滤那些

00:11:14.170 --> 00:11:21.130
女性的元素和

00:11:17.640 --> 00:11:24.850
然后我们提取名称并

00:11:21.130 --> 00:11:29.110
我们正在收集结果，所以请注意

00:11:24.850 --> 00:11:31.450
使用内置的Java SE收集器

00:11:29.110 --> 00:11:34.959
我们在其中将它们提取为列表

00:11:31.450 --> 00:11:38.800
但是结果是一个字符串列表

00:11:34.959 --> 00:11:42.149
我们不在JSON世界之外，因此

00:11:38.800 --> 00:11:45.399
解决方案显然是介绍

00:11:42.149 --> 00:11:48.250
专门的JSON收集器，所以这是

00:11:45.399 --> 00:11:50.850
相同的查询，如果您愿意，而是

00:11:48.250 --> 00:11:53.980
只是提取为字符串，我们现在

00:11:50.850 --> 00:11:56.410
根据JSON数组提取，因此

00:11:53.980 --> 00:11:58.899
您通常可以随后申请

00:11:56.410 --> 00:12:07.390
操作或继续在JSON世界中

00:11:58.899 --> 00:12:10.180
根据您的结果，可以做一些绑定

00:12:07.390 --> 00:12:15.040
这是我们在Java中添加的新API 

00:12:10.180 --> 00:12:18.459
 EE 8它是一个jax就像

00:12:15.040 --> 00:12:22.570
 api至马歇尔和之间的元帅

00:12:18.459 --> 00:12:24.820
 Java对象和JSON文档

00:12:22.570 --> 00:12:27.190
作为自然的后续活动参加

00:12:24.820 --> 00:12:31.300
增强JSON的功能

00:12:27.190 --> 00:12:34.260
处理API，就像其他映射API一样

00:12:31.300 --> 00:12:37.720
如果我们有文件B或JPA 

00:12:34.260 --> 00:12:39.880
我们设计这个是为了方便

00:12:37.720 --> 00:12:43.329
一个之间存在默认映射

00:12:39.880 --> 00:12:45.699
类和Java Java 

00:12:43.329 --> 00:12:47.380
类是相邻文档，然后

00:12:45.699 --> 00:12:50.160
有丰富的自定义设置

00:12:47.380 --> 00:12:52.540
这些定制的可能性

00:12:50.160 --> 00:12:57.339
可以通过以下方式实现

00:12:52.540 --> 00:13:00.459
可能适用于的注释

00:12:57.339 --> 00:13:03.820
适用于单个属性或字段或

00:13:00.459 --> 00:13:05.709
其中一些课程的等级，或者如果您

00:13:03.820 --> 00:13:07.300
想做一些更一般的事情

00:13:05.709 --> 00:13:09.820
甚至比

00:13:07.300 --> 00:13:12.610
注释提供了一个

00:13:09.820 --> 00:13:14.200
您可以用来配置API 

00:13:12.610 --> 00:13:17.320
执行一定的转移

00:13:14.200 --> 00:13:18.760
国家或自定义项在运行时

00:13:17.320 --> 00:13:20.890
我想说的另一件事是当我们

00:13:18.760 --> 00:13:25.680
开始这项工作已经有一个

00:13:20.890 --> 00:13:28.960
 Jason绑定或Jason绑定的数量

00:13:25.680 --> 00:13:31.660
实施，所以我们希望它成为

00:13:28.960 --> 00:13:33.910
灵活，让您选择是否

00:13:31.660 --> 00:13:36.130
有首选的Jason绑定提供者

00:13:33.910 --> 00:13:38.800
您不一定需要了解二手货

00:13:36.130 --> 00:13:45.220
使用内置的，您可以选择

00:13:38.800 --> 00:13:48.460
您想要的提供者

00:13:45.220 --> 00:13:51.040
几个关键的api在这里是

00:13:48.460 --> 00:13:53.820
客户是Jason B Builder 

00:13:51.040 --> 00:13:57.400
绑定API的入口点，以及

00:13:53.820 --> 00:13:59.350
这使您可以进行设置操作

00:13:57.400 --> 00:14:04.060
提供者的实现和设置

00:13:59.350 --> 00:14:07.540
配置属性，它也是一个

00:14:04.060 --> 00:14:10.480
杰森B级和

00:14:07.540 --> 00:14:12.970
杰森（Jason B）是

00:14:10.480 --> 00:14:15.580
框架的操作如此

00:14:12.970 --> 00:14:18.100
为您提供JSON的操作

00:14:15.580 --> 00:14:26.410
并以JSON进行序列化

00:14:18.100 --> 00:14:29.200
反序列化操作如此简单

00:14:26.410 --> 00:14:32.950
例如，我们有两辆车要去

00:14:29.200 --> 00:14:35.320
将它们放入硅谷的列表中

00:14:32.950 --> 00:14:37.890
也许只有普锐斯和特斯拉

00:14:35.320 --> 00:14:42.580
我的意思是他们在这里很常见

00:14:37.890 --> 00:14:44.980
然后使用JSON B API，我们使用

00:14:42.580 --> 00:14:48.700
生成器创建实例

00:14:44.980 --> 00:14:54.690
 Jason B班，然后和Jason B一起

00:14:48.700 --> 00:14:59.880
调用to JSON方法进行序列化

00:14:54.690 --> 00:15:02.530
这些实例到相邻

00:14:59.880 --> 00:15:04.420
我作弊的文件，因为

00:15:02.530 --> 00:15:06.490
我已经完成了漂亮的格式化

00:15:04.420 --> 00:15:08.290
我不知道那是不是内置的

00:15:06.490 --> 00:15:10.630
定制与否

00:15:08.290 --> 00:15:16.120
格式定制选项可以

00:15:10.630 --> 00:15:18.520
使用，所以你可以做其他事情有一个

00:15:16.120 --> 00:15:20.560
属性和字段的默认命名

00:15:18.520 --> 00:15:24.100
您可以使用注释来更改

00:15:20.560 --> 00:15:26.740
如果您愿意，可以使用注释来

00:15:24.100 --> 00:15:27.430
无论您是否更改null行为

00:15:26.740 --> 00:15:30.970
想要或

00:15:27.430 --> 00:15:36.190
不希望空值出现在您的

00:15:30.970 --> 00:15:38.560
序列化的JSON，然后有一个丰富的

00:15:36.190 --> 00:15:41.320
一组自定义选项以及这些

00:15:38.560 --> 00:15:43.360
从命名到订购什么

00:15:41.320 --> 00:15:46.150
您希望事物出现的顺序

00:15:43.360 --> 00:15:48.390
空处理您要忽略的内容

00:15:46.150 --> 00:15:52.240
你想带什么到你的

00:15:48.390 --> 00:15:56.940
资料的文件或类别格式

00:15:52.240 --> 00:16:02.230
编号，编码和适配器

00:15:56.940 --> 00:16:05.950
适配器API允许您定义自定义

00:16:02.230 --> 00:16:10.060
映射，因此您可以实现两种方法

00:16:05.950 --> 00:16:17.530
适应json并适应json和

00:16:10.060 --> 00:16:21.610
然后这些将为您调用

00:16:17.530 --> 00:16:23.770
在这里，我们将使用json config 

00:16:21.610 --> 00:16:27.100
你知道我们漂亮的格式和

00:16:23.770 --> 00:16:29.230
我们将使用一个车载适配器

00:16:27.100 --> 00:16:33.820
去做我们的转变，然后

00:16:29.230 --> 00:16:37.360
我们将此配置传递给jason be builder 

00:16:33.820 --> 00:16:42.790
当我们这样做时，它将被使用

00:16:37.360 --> 00:16:46.090
我们的序列化和反序列化

00:16:42.790 --> 00:16:50.050
也可以使用

00:16:46.090 --> 00:16:52.690
我们要使用特定的构建器

00:16:50.050 --> 00:16:54.280
提供者，所以这只是一个中间

00:16:52.690 --> 00:16:57.270
步

00:16:54.280 --> 00:16:57.270
在配置中

00:17:04.240 --> 00:17:13.160
好的，所以jax-rs确实是另一个

00:17:08.949 --> 00:17:15.309
对我们来说成功的API有两个关键

00:17:13.160 --> 00:17:18.260
我们想要提供的区域

00:17:15.309 --> 00:17:21.679
此版本的增强功能之一

00:17:18.260 --> 00:17:26.390
提供反应性

00:17:21.679 --> 00:17:29.780
客户端API充分利用Java SE的八点优势

00:17:26.390 --> 00:17:33.620
在它，然后支持服务器发送

00:17:29.780 --> 00:17:37.190
指定了事件服务器发送的事件

00:17:33.620 --> 00:17:39.730
在HTML html5标准中，然后

00:17:37.190 --> 00:17:43.460
还有其他一些未成年人

00:17:39.730 --> 00:17:45.559
对Jason B实体的改进支持

00:17:43.460 --> 00:17:52.850
提供者以帮助您进行映射

00:17:45.559 --> 00:17:57.320
和HTTP补丁请求，所以这是

00:17:52.850 --> 00:17:59.030
 Java在jax-rs中的外观-哦

00:17:57.320 --> 00:18:02.540
向后退一点

00:17:59.030 --> 00:18:05.470
客户端api的jax-rs-哦介绍了

00:18:02.540 --> 00:18:09.200
您可以使用的客户端API 

00:18:05.470 --> 00:18:12.170
在此同步或异步

00:18:09.200 --> 00:18:14.420
如果我们同步使用它，那么您

00:18:12.170 --> 00:18:20.030
建立一个请求，然后你

00:18:14.420 --> 00:18:22.130
发出请求，这样不会很麻烦

00:18:20.030 --> 00:18:25.250
有趣，但这是前进的一步

00:18:22.130 --> 00:18:27.920
您可以在客户端API中指定

00:18:25.250 --> 00:18:30.380
你想要一个异步调用者

00:18:27.920 --> 00:18:34.040
比常规调用者要多

00:18:30.380 --> 00:18:37.120
您将获得以下方面的结果

00:18:34.040 --> 00:18:37.120
未来

00:18:41.250 --> 00:18:50.570
或者更灵活地可以通过

00:18:46.880 --> 00:18:54.840
您可以传递回调给您

00:18:50.570 --> 00:18:58.320
通知的结果

00:18:54.840 --> 00:19:01.740
具有完整方法的请求在这里

00:18:58.320 --> 00:19:04.080
或者，如果请求失败，则

00:19:01.740 --> 00:19:05.880
失败的方法，所以这给了一点

00:19:04.080 --> 00:19:07.680
更大的灵活性，然后您就可以

00:19:05.880 --> 00:19:16.980
可以使用

00:19:07.680 --> 00:19:18.930
未来，所以Jax rs21要做的是

00:19:16.980 --> 00:19:21.900
对此样式进行了改进

00:19:18.930 --> 00:19:25.590
这给您更多的灵活性

00:19:21.900 --> 00:19:28.530
一个Rx调用程序，它可以将您带回

00:19:25.590 --> 00:19:34.080
而是完成阶段，因此在此

00:19:28.530 --> 00:19:35.700
一个简单的例子，我们将一个方法传递给

00:19:34.080 --> 00:19:38.120
基本上就是完成阶段

00:19:35.700 --> 00:19:40.050
说打印出来不是很可怕

00:19:38.120 --> 00:19:43.500
有趣，但事情变得更多

00:19:40.050 --> 00:19:46.200
有趣的是，当你看几个

00:19:43.500 --> 00:19:49.290
真正的完成能力

00:19:46.200 --> 00:19:51.780
可以执行的阶段

00:19:49.290 --> 00:19:53.580
您可以将多个请求合并

00:19:51.780 --> 00:19:55.320
您可以选择它们的顺序

00:19:53.580 --> 00:19:57.750
你要去哪一个

00:19:55.320 --> 00:20:00.120
然后在一天结束时

00:19:57.750 --> 00:20:02.970
最终将接受并打印出来

00:20:00.120 --> 00:20:05.790
在这种情况下，我们正在做的是

00:20:02.970 --> 00:20:08.640
取两个结果

00:20:05.790 --> 00:20:10.620
完成阶段结果在这里

00:20:08.640 --> 00:20:12.450
结合它们，我们将它们串联在一起

00:20:10.620 --> 00:20:15.090
我们将打印出某种形式的内容

00:20:12.450 --> 00:20:17.450
最后看起来像你好卓悦

00:20:15.090 --> 00:20:17.450
今天的

00:20:21.990 --> 00:20:31.330
因此以服务器发送的事件为目标

00:20:27.490 --> 00:20:34.480
允许客户订阅

00:20:31.330 --> 00:20:37.840
来自的事件通知顺序

00:20:34.480 --> 00:20:40.330
服务器的工作方式是

00:20:37.840 --> 00:20:43.450
客户建立与

00:20:40.330 --> 00:20:45.520
服务器，这是一个HTTP连接，但是

00:20:43.450 --> 00:20:48.100
这是一个长期运行的连接

00:20:45.520 --> 00:20:50.650
一直保持到客户关闭为止

00:20:48.100 --> 00:20:54.700
可以重复用于多个通知

00:20:50.650 --> 00:20:57.400
从您指定的服务器

00:20:54.700 --> 00:21:00.460
一种特殊的媒体类型，一个事件流

00:20:57.400 --> 00:21:02.620
媒体类型，然后是事件对象

00:21:00.460 --> 00:21:05.230
它本身是结构化的，具有有效载荷

00:21:02.620 --> 00:21:08.410
这是我们对应的数据

00:21:05.230 --> 00:21:11.650
字段，它具有其他信息

00:21:08.410 --> 00:21:14.710
可以使用的名称

00:21:11.650 --> 00:21:18.300
识别一个频道或一个ID 

00:21:14.710 --> 00:21:20.770
您可能会使用一些测序

00:21:18.300 --> 00:21:27.970
操作或跟踪内容

00:21:20.770 --> 00:21:30.850
回来重试和评论字段，所以

00:21:27.970 --> 00:21:35.860
该API有两个方面

00:21:30.850 --> 00:21:38.050
 jax-rs到客户端使用这些

00:21:35.860 --> 00:21:41.830
是最重要的界面

00:21:38.050 --> 00:21:44.110
客户端使用的事件源

00:21:41.830 --> 00:21:47.950
打开与Web目标的连接

00:21:44.110 --> 00:21:50.320
然后订阅您的消费者

00:21:47.950 --> 00:21:54.280
自动关闭，但您可以将其关闭

00:21:50.320 --> 00:21:56.020
显式和入站SSE事件

00:21:54.280 --> 00:21:58.870
这是您将要使用的

00:21:56.020 --> 00:22:05.590
提取已经的通知

00:21:58.870 --> 00:22:07.470
从服务器等客户端发送

00:22:05.590 --> 00:22:10.600
一边，你可能会有这样的事情

00:22:07.470 --> 00:22:13.480
我们正在构建，我们正在恢复

00:22:10.600 --> 00:22:17.050
事件源，然后和我们一起

00:22:13.480 --> 00:22:18.820
我们正在注册的源

00:22:17.050 --> 00:22:21.280
注册我们想要的方法

00:22:18.820 --> 00:22:23.820
事件进入时调用了

00:22:21.280 --> 00:22:27.040
然后开始

00:22:23.820 --> 00:22:28.510
来自我们打开的服务器的通知

00:22:27.040 --> 00:22:31.380
与事件源的连接

00:22:28.510 --> 00:22:31.380
开放方法

00:22:34.379 --> 00:22:41.740
您在服务器端进行事件同步

00:22:38.320 --> 00:22:43.980
可能希望这作为

00:22:41.740 --> 00:22:47.139
向资源隐藏参数

00:22:43.980 --> 00:22:50.879
服务器端的方法

00:22:47.139 --> 00:22:53.889
实例对应一个客户

00:22:50.879 --> 00:22:59.740
 HTTP连接，服务器使用此连接

00:22:53.889 --> 00:23:01.419
发送事件到客户端SSE是我

00:22:59.740 --> 00:23:04.119
猜你可以把它当作工厂

00:23:01.419 --> 00:23:07.480
用于创建新事件的类，或

00:23:04.119 --> 00:23:14.289
创建事件广播者并

00:23:07.480 --> 00:23:17.049
在服务器上配置事件

00:23:14.289 --> 00:23:20.049
您可能有一种资源方法

00:23:17.049 --> 00:23:22.629
看起来像这样，请注意，我们已经

00:23:20.049 --> 00:23:25.629
指定媒体类型媒体类型

00:23:22.629 --> 00:23:27.759
再次是文本事件流媒体

00:23:25.629 --> 00:23:31.299
类型是服务和事件的映射

00:23:27.759 --> 00:23:34.629
到然后在我们的SUBSCRIBE方法中

00:23:31.299 --> 00:23:37.360
我们注入了事件同步，并且

00:23:34.629 --> 00:23:40.419
注入了此SSE工厂方法并

00:23:37.360 --> 00:23:45.240
然后我们使用事件同步发送

00:23:40.419 --> 00:23:45.240
新事件移交给客户

00:23:56.399 --> 00:24:04.539
我们的另一个高价商品

00:24:01.149 --> 00:24:07.359
在servlet API中寻址

00:24:04.539 --> 00:24:10.209
 servlet哦，因为这是一个相当

00:24:07.359 --> 00:24:13.959
主要任务是支持

00:24:10.209 --> 00:24:17.379
新的HTTP协议，这是另一个最近的协议

00:24:13.959 --> 00:24:21.219
 IETF的标准和HTTP的目标

00:24:17.379 --> 00:24:25.599
二是克服局限性

00:24:21.219 --> 00:24:28.269
现有的HTTP一一协议即

00:24:25.599 --> 00:24:29.909
减少延迟以支持并行

00:24:28.269 --> 00:24:32.379
不需要你有多个

00:24:29.909 --> 00:24:35.889
连接作为解决方法

00:24:32.379 --> 00:24:39.069
并行处理一个头

00:24:35.889 --> 00:24:41.619
线头阻塞问题基本上

00:24:39.069 --> 00:24:46.569
同时改善了许多性能

00:24:41.619 --> 00:24:50.339
保留HTTP 1 1的语义，因此

00:24:46.569 --> 00:24:53.009
这看起来或多或少是透明的， 

00:24:50.339 --> 00:24:55.629
是什么使得这项工作的

00:24:53.009 --> 00:24:58.659
请求/响应多路复用

00:24:55.629 --> 00:25:01.319
具有二进制框架的单连接

00:24:58.659 --> 00:25:05.589
层和二进制框架层

00:25:01.319 --> 00:25:08.379
允许发送过来的帧

00:25:05.589 --> 00:25:11.139
此连接被标识为

00:25:08.379 --> 00:25:14.019
它们对应于哪些流，以便

00:25:11.139 --> 00:25:16.059
您可以这样就可以在

00:25:14.019 --> 00:25:18.190
他们的接收并提取

00:25:16.059 --> 00:25:20.469
消息流是

00:25:18.190 --> 00:25:23.579
一致的消息流

00:25:20.469 --> 00:25:27.249
它还可以包含服务器推送API 

00:25:23.579 --> 00:25:30.129
因此服务器可以通过推送进行优化

00:25:27.249 --> 00:25:32.889
提前向客户发送数据

00:25:30.129 --> 00:25:35.229
客户要求它，然后

00:25:32.889 --> 00:25:36.999
客户端可以缓存此信息，以便

00:25:35.229 --> 00:25:41.169
如果您要发送数据的示例

00:25:36.999 --> 00:25:44.109
 HTML页面已被请求

00:25:41.169 --> 00:25:46.029
你知道或者你可以预期

00:25:44.109 --> 00:25:48.489
也许您想发送CSS数据

00:25:46.029 --> 00:25:51.759
您想尽早将其推出或

00:25:48.489 --> 00:25:54.339
你想推出其他需要的

00:25:51.759 --> 00:25:56.019
先于先知

00:25:54.339 --> 00:25:58.329
信息

00:25:56.019 --> 00:26:00.669
也有标头设施

00:25:58.329 --> 00:26:04.449
压缩以再次使该协议

00:26:00.669 --> 00:26:05.920
更有效，所以这是

00:26:04.449 --> 00:26:14.020
的大件物品

00:26:05.920 --> 00:26:16.390
 servlet哦，对I的HTTP支持

00:26:14.020 --> 00:26:19.030
相信关于servlet的话题

00:26:16.390 --> 00:26:21.040
因为在这次会议的后面，我会

00:26:19.030 --> 00:26:25.420
给你的指针，我相信

00:26:21.040 --> 00:26:28.690
主或唯一用户应用程序可见

00:26:25.420 --> 00:26:30.610
这里的功能是服务器推送API，因此

00:26:28.690 --> 00:26:33.400
您可以配置您的推送

00:26:30.610 --> 00:26:34.870
从您的servlet，看起来

00:26:33.400 --> 00:26:37.750
像这样的东西有推动

00:26:34.870 --> 00:26:40.180
构建器API，因此您可以构建

00:26:37.750 --> 00:26:43.150
推送引用您要推送的内容

00:26:40.180 --> 00:26:46.120
然后是标题或其他

00:26:43.150 --> 00:26:48.460
适用于

00:26:46.120 --> 00:26:59.170
传播的推动，然后你

00:26:48.460 --> 00:27:01.630
可以将其推出客户端JSF是

00:26:59.170 --> 00:27:04.170
当然，这是一项成熟的技术

00:27:01.630 --> 00:27:07.120
 2.3发布，我认为这表明

00:27:04.170 --> 00:27:10.390
除了嗯，我在这里不多说

00:27:07.120 --> 00:27:13.930
专家组的演讲

00:27:10.390 --> 00:27:17.020
较小的功能请求数和

00:27:13.930 --> 00:27:18.640
我最初准备JIRA物品时

00:27:17.020 --> 00:27:22.660
李告诉我， 

00:27:18.640 --> 00:27:25.420
大约有600个JIRA物品

00:27:22.660 --> 00:27:27.700
已在此版本中得到解决，因此

00:27:25.420 --> 00:27:30.400
从那一点来看肯定是不平凡的

00:27:27.700 --> 00:27:32.410
认为这只是一些事情

00:27:30.400 --> 00:27:36.510
包含改进的集成

00:27:32.410 --> 00:27:39.960
 CDI支持WebSocket集成

00:27:36.510 --> 00:27:42.970
然后调用Ajax方法

00:27:39.960 --> 00:27:46.740
利用验证和新

00:27:42.970 --> 00:27:46.740
日期/时间支持

00:27:51.970 --> 00:27:57.879
好吧，说到cd-i这是一个关键

00:27:56.409 --> 00:28:02.440
我们的技术

00:27:57.879 --> 00:28:05.289
 CDI 200是一个很大的版本，但其中之一

00:28:02.440 --> 00:28:09.759
 CDI的主要关注领域不是很多

00:28:05.289 --> 00:28:14.169
 Java EE为使用提供支持

00:28:09.759 --> 00:28:17.860
 Java EE外部的CDI，即

00:28:14.169 --> 00:28:22.269
引导程序API，可让您引导CDI 

00:28:17.860 --> 00:28:25.659
 SZ环境中的集装箱专家

00:28:22.269 --> 00:28:29.649
明智地将规格分为三部分

00:28:25.659 --> 00:28:33.190
当他们这样做时是核心

00:28:29.649 --> 00:28:35.710
在EE和SC中都使用的CDI 

00:28:33.190 --> 00:28:40.059
环境，然后是那些api 

00:28:35.710 --> 00:28:42.730
专门用于SE环境

00:28:40.059 --> 00:28:47.169
像这样的自举API，然后

00:28:42.730 --> 00:28:50.740
 Java中使用更多的api 

00:28:47.169 --> 00:28:54.070
 EE认为会话bean是因为CDI 

00:28:50.740 --> 00:28:57.159
实际上，谈到EJB会话bean和

00:28:54.070 --> 00:28:58.840
如何在EE的CDI中使用它们

00:28:57.159 --> 00:29:01.269
角度我要在这里说

00:28:58.840 --> 00:29:05.289
主要是关于

00:29:01.269 --> 00:29:07.120
由观察者和事件

00:29:05.289 --> 00:29:09.879
还有许多其他功能

00:29:07.120 --> 00:29:13.419
完成的注释文字是

00:29:09.879 --> 00:29:16.690
易于使用的功能与

00:29:13.419 --> 00:29:23.409
一些新的SC功能具有流

00:29:16.690 --> 00:29:27.009
 API重复注释lambda使用

00:29:23.409 --> 00:29:31.840
完成阶段和许多丰富的

00:29:27.009 --> 00:29:33.610
 CDI SPI好吗

00:29:31.840 --> 00:29:41.590
事件和观察者这是什么东西

00:29:33.610 --> 00:29:44.679
看起来像在CDI 1：1或EE Java EE 7中

00:29:41.590 --> 00:29:47.850
构造一个事件，然后触发

00:29:44.679 --> 00:29:50.379
当你开火时，观察者

00:29:47.850 --> 00:29:52.029
他们在那里同步调用

00:29:50.379 --> 00:29:55.059
在与火相同的线程中调用

00:29:52.029 --> 00:29:57.759
方法，它们在任何情况下都被调用

00:29:55.059 --> 00:30:00.779
订购CDI容器选择

00:29:57.759 --> 00:30:00.779
调用它们

00:30:02.499 --> 00:30:08.690
在CDI转换为OCD方面，我做了两项改进

00:30:06.619 --> 00:30:11.539
首先，它给你

00:30:08.690 --> 00:30:14.590
订购同步事件的能力

00:30:11.539 --> 00:30:17.179
使用优先级注释

00:30:14.590 --> 00:30:19.639
优先事项和注释相同

00:30:17.179 --> 00:30:23.690
不适用于的注释

00:30:19.639 --> 00:30:26.960
我们更新了两个参数的共同点

00:30:23.690 --> 00:30:29.289
带有MR的注释，以便您

00:30:26.960 --> 00:30:32.960
可以做到这一点，现在您可以订购

00:30:29.289 --> 00:30:35.200
观察者，以便您知道何时

00:30:32.960 --> 00:30:37.549
观察者触发，如果你想

00:30:35.200 --> 00:30:42.889
利用在该观察者中所做的事情

00:30:37.549 --> 00:30:45.259
你有这种确定性

00:30:42.889 --> 00:30:50.059
所做的改进是支持

00:30:45.259 --> 00:30:52.549
用于异步事件，因此当您触发

00:30:50.059 --> 00:30:55.940
异步事件

00:30:52.549 --> 00:30:57.619
确保至少有一个或

00:30:55.940 --> 00:31:01.940
更多将要使用的线程

00:30:57.619 --> 00:31:03.799
为解雇观察员

00:31:01.940 --> 00:31:06.080
对此作出响应的方法

00:31:03.799 --> 00:31:08.600
事件以及您指定这些事件的方式

00:31:06.080 --> 00:31:15.619
观察者方法与观察者

00:31:08.600 --> 00:31:17.269
与他们同步的观察同步

00:31:15.619 --> 00:31:20.749
您可能希望它不会

00:31:17.269 --> 00:31:22.490
可移植以通过同步指定优先级

00:31:20.749 --> 00:31:24.559
观察者，因为存在的本质

00:31:22.490 --> 00:31:28.730
异步，您将无法

00:31:24.559 --> 00:31:32.659
以任何确定性的方式订购它们，以便

00:31:28.730 --> 00:31:35.389
这件事要注意的几件事

00:31:32.659 --> 00:31:38.059
可以触发相同类型的事件

00:31:35.389 --> 00:31:42.730
同步或异步

00:31:38.059 --> 00:31:45.950
但有资格参加的观察员

00:31:42.730 --> 00:31:48.200
被通知事件取决于

00:31:45.950 --> 00:31:49.820
他们是否是同步观察者

00:31:48.200 --> 00:31:52.519
将会收到通知

00:31:49.820 --> 00:31:54.200
同步事件或异步

00:31:52.519 --> 00:31:58.399
观察员将被通知

00:31:54.200 --> 00:32:00.499
异步触发的事件

00:31:58.399 --> 00:32:04.369
异步观察者在新的方法中被调用

00:32:00.499 --> 00:32:06.139
生命周期上下文及其新

00:32:04.369 --> 00:32:08.740
交易环境，因此它们不能

00:32:06.139 --> 00:32:13.039
交易意义上的

00:32:08.740 --> 00:32:15.429
同步观察者好吧我怎么样

00:32:13.039 --> 00:32:15.429
准时做

00:32:18.549 --> 00:32:25.039
好的光束验证，这是另一个

00:32:22.639 --> 00:32:27.619
两个哦，我认为是有充分理由的

00:32:25.039 --> 00:32:31.609
包括许多有用的新功能

00:32:27.619 --> 00:32:34.340
现代化以利用Java SE 8 

00:32:31.609 --> 00:32:37.340
提供对Java的支持

00:32:34.340 --> 00:32:40.669
时间api的可重复注释

00:32:37.340 --> 00:32:45.019
可以将约束应用于集合

00:32:40.669 --> 00:32:47.960
可选元素，它有一个主机

00:32:45.019 --> 00:32:50.419
一些新的约束条件是

00:32:47.960 --> 00:32:52.070
已经在那里并且休眠验证器

00:32:50.419 --> 00:32:54.169
我认为他们已经得到了非常

00:32:52.070 --> 00:32:56.659
那里的积极接待，所以要求

00:32:54.169 --> 00:33:00.619
被制成将它们添加到标准中

00:32:56.659 --> 00:33:08.830
光束验证以及许多新的

00:33:00.619 --> 00:33:12.649
约束，所以其中一些通过了

00:33:08.830 --> 00:33:14.600
当我们完成所有

00:33:12.649 --> 00:33:17.350
这些J SRS和维护版本

00:33:14.600 --> 00:33:20.419
我会说我们一直在

00:33:17.350 --> 00:33:23.269
机会地引入重复

00:33:20.419 --> 00:33:26.509
我们尚未阅读规格的注释

00:33:23.269 --> 00:33:28.759
为了增加重复的目的

00:33:26.509 --> 00:33:31.940
注解，但我认为我们大多数J 

00:33:28.759 --> 00:33:33.769
 SRS已经进行了足够的更改，以至于

00:33:31.940 --> 00:33:35.539
我们一直在利用

00:33:33.769 --> 00:33:38.059
重复注释，现在

00:33:35.539 --> 00:33:44.409
在每个方面都非常一致

00:33:38.059 --> 00:33:46.940
容器内的平台约束

00:33:44.409 --> 00:33:48.950
元素，例如这里您想要的

00:33:46.940 --> 00:33:52.999
有效客户和有效客户的地图

00:33:48.950 --> 00:33:55.639
帐户或带有可选选项的最后一个

00:33:52.999 --> 00:33:58.639
这里的例子说明了新的

00:33:55.639 --> 00:34:00.379
注释您的列表

00:33:58.639 --> 00:34:02.389
结果不应为空

00:34:00.379 --> 00:34:06.369
这个，你想要顾客

00:34:02.389 --> 00:34:09.049
电子邮件为非空白字符串

00:34:06.369 --> 00:34:11.649
适当配置为电子邮件

00:34:09.049 --> 00:34:11.649
地址

00:34:17.770 --> 00:34:23.599
好的，新的Java EE安全API 

00:34:21.919 --> 00:34:29.030
是要求

00:34:23.599 --> 00:34:31.190
时间长了所以有很多关键

00:34:29.030 --> 00:34:33.770
我要在这里添加的新api 

00:34:31.190 --> 00:34:36.550
说说这三个安全

00:34:33.770 --> 00:34:40.460
上下文HTTP认证

00:34:36.550 --> 00:34:42.980
机制API和身份存储区

00:34:40.460 --> 00:34:45.770
目标的一部分或大部分

00:34:42.980 --> 00:34:48.349
目标是简化安全性

00:34:45.770 --> 00:34:52.570
 Java EE通用方法通用

00:34:48.349 --> 00:34:56.119
 CDI的机制和杠杆作用

00:34:52.570 --> 00:35:03.200
指定一个如何工作，两个指定

00:34:56.119 --> 00:35:05.660
它们被配置为安全上下文

00:35:03.200 --> 00:35:07.550
这有验证方法

00:35:05.660 --> 00:35:10.849
身份验证将在网络中使用

00:35:07.550 --> 00:35:14.450
层获取颜色原理并获取

00:35:10.849 --> 00:35:16.849
键入的原则称为角色

00:35:14.450 --> 00:35:19.160
您熟悉servlet和EJB 

00:35:16.849 --> 00:35:22.069
规格，您会注意到我们没有

00:35:19.160 --> 00:35:24.079
在这些api上统一命名

00:35:22.069 --> 00:35:26.420
您是否通常知道

00:35:24.079 --> 00:35:29.079
我猜你在困惑和错别字

00:35:26.420 --> 00:35:32.780
尝试编写您的应用程序，以便

00:35:29.079 --> 00:35:35.810
这些旨在取代

00:35:32.780 --> 00:35:37.940
现有不一致使用的方法，以及

00:35:35.810 --> 00:35:40.099
一致命名的方法

00:35:37.940 --> 00:35:43.400
当然你仍然可以继续使用

00:35:40.099 --> 00:35:51.410
以便在整个

00:35:43.400 --> 00:35:54.650
不同的容器类型HTTP 

00:35:51.410 --> 00:35:56.990
设计认证机制

00:35:54.650 --> 00:36:01.069
专门针对网络层

00:35:56.990 --> 00:36:06.920
仅以servlet容器为模型

00:36:01.069 --> 00:36:10.480
 jaspe服务器关闭了模块SPI，但是

00:36:06.920 --> 00:36:13.280
这是为了捕获

00:36:10.480 --> 00:36:15.560
只是选择是非常强大的，但是

00:36:13.280 --> 00:36:17.089
非常复杂，我们已经知道了

00:36:15.560 --> 00:36:19.280
关注人数

00:36:17.089 --> 00:36:21.800
复杂性使用笨拙，所以

00:36:19.280 --> 00:36:24.920
这里的目标是提供一些

00:36:21.800 --> 00:36:29.240
在以下方面更加用户友好

00:36:24.920 --> 00:36:29.960
您如何使用它如何定义

00:36:29.240 --> 00:36:33.950
的

00:36:29.960 --> 00:36:37.720
嗨，VIIRS，这的关键方法

00:36:33.950 --> 00:36:39.619
接口是验证请求

00:36:37.720 --> 00:36:41.630
提供给呼叫者

00:36:39.619 --> 00:36:43.490
验证，以便您可以提取这是

00:36:41.630 --> 00:36:45.530
在适当的过滤器或证书之前调用，或

00:36:43.490 --> 00:36:50.000
服务方法，以便您可以提取

00:36:45.530 --> 00:36:53.450
来自HTTP标头的信息或

00:36:50.000 --> 00:36:55.790
请求参数等安全

00:36:53.450 --> 00:37:00.080
您可能会调用的响应

00:36:55.790 --> 00:37:02.330
期待之后，那将使您能够

00:37:00.080 --> 00:37:03.800
做类似我想加密你的事情

00:37:02.330 --> 00:37:08.420
如果您要它做某事，请回应

00:37:03.800 --> 00:37:12.980
他们是干净的主题，让您清理

00:37:08.420 --> 00:37:15.589
摆脱任何特定的来电者

00:37:12.980 --> 00:37:18.109
信息cookie状态或

00:37:15.589 --> 00:37:21.890
你不会做的其他事情

00:37:18.109 --> 00:37:23.720
希望进一步传播

00:37:21.890 --> 00:37:28.210
您可以将其与

00:37:23.720 --> 00:37:30.740
您可以打包自己的HTT应用程序

00:37:28.210 --> 00:37:32.599
 HTTP认证机制

00:37:30.740 --> 00:37:35.030
与应用程序一起实施或

00:37:32.599 --> 00:37:37.339
您可以使用提供的容器

00:37:35.030 --> 00:37:41.500
有优先顺序的规则

00:37:37.339 --> 00:37:47.780
这些和这些的配置

00:37:41.500 --> 00:37:57.640
因此此api可以委托给

00:37:47.780 --> 00:38:00.859
身份存储api用于

00:37:57.640 --> 00:38:04.280
与有用户的商店互动

00:38:00.859 --> 00:38:06.890
用于身份验证和

00:38:04.280 --> 00:38:11.599
检索用户组之类的信息

00:38:06.890 --> 00:38:14.839
信息安全API规范

00:38:11.599 --> 00:38:18.490
识别多种身份

00:38:14.839 --> 00:38:23.060
商店，我相信这些都是可扩展的，所以

00:38:18.490 --> 00:38:24.859
曾经被嵌入的LDAP数据库

00:38:23.060 --> 00:38:29.570
我不确定这是被拉走还是

00:38:24.859 --> 00:38:31.220
不在最终版本中，您可以找到

00:38:29.570 --> 00:38:33.770
在安全性讨论中可以了解更多

00:38:31.220 --> 00:38:36.980
在会议的后面，但是使用了

00:38:33.770 --> 00:38:41.240
用于身份验证或授权，或

00:38:36.980 --> 00:38:43.220
这两个主要方法都是有效的

00:38:41.240 --> 00:38:45.680
这样您就可以验证

00:38:43.220 --> 00:38:48.890
关于这是否有效，以及

00:38:45.680 --> 00:38:51.859
用户可以继续进行，也可以提取

00:38:48.890 --> 00:38:55.240
呼叫者呼叫者分组以进一步

00:38:51.859 --> 00:38:58.880
授权，如果实际上是

00:38:55.240 --> 00:39:03.140
身份存储所支持的身份

00:38:58.880 --> 00:39:05.900
商店可以支持身份验证或

00:39:03.140 --> 00:39:08.060
授权或两者兼而有之，您可以

00:39:05.900 --> 00:39:14.230
从身份存储中确定哪个

00:39:08.060 --> 00:39:14.230
它支持HTTP身份验证

00:39:14.740 --> 00:39:21.050
机制可以利用多个身份

00:39:19.369 --> 00:39:25.300
商店，因此它可以经历几个

00:39:21.050 --> 00:39:28.460
身份存储确定是否

00:39:25.300 --> 00:39:32.930
是否基于凭证调用方

00:39:28.460 --> 00:39:35.630
有权继续，所以您

00:39:32.930 --> 00:39:38.540
可以结合身份的结果

00:39:35.630 --> 00:39:46.640
存储身份存储

00:39:38.540 --> 00:39:49.839
就像我提到的那样，我们做了一个

00:39:46.640 --> 00:39:53.270
维护版本的数量

00:39:49.839 --> 00:39:55.849
 JPA其中大多数都是相当小的JPA 

00:39:53.270 --> 00:39:59.960
可能更重要

00:39:55.849 --> 00:40:02.530
此列表之一Java Mail中有一个数字

00:39:59.960 --> 00:40:04.790
小改进通用注释

00:40:02.530 --> 00:40:08.119
提到优先和重复

00:40:04.790 --> 00:40:10.550
注释拦截器只是一个

00:40:08.119 --> 00:40:12.770
清理和WebSocket完成了一段时间

00:40:10.550 --> 00:40:16.750
以前我们还完成了一些

00:40:12.770 --> 00:40:20.180
 Java SE 9和Java的维护版本

00:40:16.750 --> 00:40:22.970
这些都包含在

00:40:20.180 --> 00:40:25.700
玻璃鱼参考实现

00:40:22.970 --> 00:40:28.010
当您使用GlassFish时，您会看到

00:40:25.700 --> 00:40:30.650
这些的结果，但它们是因为

00:40:28.010 --> 00:40:35.089
这些是SC API，不包含在内

00:40:30.650 --> 00:40:42.650
如Java e8本身所追求的那样

00:40:35.089 --> 00:40:45.109
基于Java SE 8，所以我向我们保证

00:40:42.650 --> 00:40:48.730
我在团队中谈到了JP a.22 

00:40:45.109 --> 00:40:51.619
特别是这增加了

00:40:48.730 --> 00:40:53.450
重复注释支持，我认为是JP 

00:40:51.619 --> 00:40:55.520
一个可能是海报的孩子

00:40:53.450 --> 00:40:57.610
发行时的注释，所以我

00:40:55.520 --> 00:41:02.650
认为他们现在

00:40:57.610 --> 00:41:06.680
十六个可重复注释和JPA 

00:41:02.650 --> 00:41:11.000
支持日期/时间，我们决定

00:41:06.680 --> 00:41:15.280
在这里要做的是那些的支持映射

00:41:11.000 --> 00:41:18.620
支持的Java时间类型

00:41:15.280 --> 00:41:21.770
在JDBC下面，我们不想得到

00:41:18.620 --> 00:41:24.080
过于庞大地在这里创作

00:41:21.770 --> 00:41:27.020
有很多定制功能，但是

00:41:24.080 --> 00:41:30.800
建立在JDBC提供的基础上

00:41:27.020 --> 00:41:33.290
这五个Java时间支持本地日期

00:41:30.800 --> 00:41:36.410
当地时间当地日期时间和偏移量

00:41:33.290 --> 00:41:40.610
时间和偏移日期时间，然后

00:41:36.410 --> 00:41:44.720
流查询结果的能力

00:41:40.610 --> 00:41:48.410
执行，以便获取结果流方法

00:41:44.720 --> 00:41:51.920
已添加到查询和类型查询中

00:41:48.410 --> 00:41:54.100
界面，然后进行CDI注入

00:41:51.920 --> 00:41:56.840
进入属性转换器

00:41:54.100 --> 00:41:59.690
以前有CDI注入和实体

00:41:56.840 --> 00:42:01.370
听众，但我们有很多

00:41:59.690 --> 00:42:06.110
请求将此添加到属性

00:42:01.370 --> 00:42:09.830
转换器，所以也可以

00:42:06.110 --> 00:42:16.030
我们现在在哪里，所以我们只是

00:42:09.830 --> 00:42:20.960
九月发布，它终于完成了

00:42:16.030 --> 00:42:27.890
因此此图说明了这些api的

00:42:20.960 --> 00:42:31.970
在Java EE中经历了jsr new jsr的

00:42:27.890 --> 00:42:35.030
 8现有深蓝色

00:42:31.970 --> 00:42:37.130
修改过的API 

00:42:35.030 --> 00:42:39.770
在这些下方的橙色是新的api 

00:42:37.130 --> 00:42:44.000
用Java添加到平台中

00:42:39.770 --> 00:42:48.470
 EE 8，如果我们查看网站配置文件

00:42:44.000 --> 00:42:52.070
是子集，请注意两者

00:42:48.470 --> 00:42:57.080
杰森B和安全评论

00:42:52.070 --> 00:43:02.840
安全性，这里安全性API发挥了作用

00:42:57.080 --> 00:43:06.200
只是选择servlet概要文件，所以我们

00:43:02.840 --> 00:43:09.980
还需要在网络上添加下巴图片

00:43:06.200 --> 00:43:15.230
配置文件，但只有servlet 

00:43:09.980 --> 00:43:17.570
个人资料支持是必需的，所以

00:43:15.230 --> 00:43:22.730
我们在哪里进展顺利

00:43:17.570 --> 00:43:24.770
即将蚀，所以我们要像

00:43:22.730 --> 00:43:28.970
您可能已经听说我们正在搬家

00:43:24.770 --> 00:43:32.540
 Java EE至Eclipse Foundation I 

00:43:28.970 --> 00:43:34.490
相信它的名字是ee 

00:43:32.540 --> 00:43:38.869
杰伊，至少那是我最新的

00:43:34.490 --> 00:43:41.510
听到了，我们得到了我们的大力支持

00:43:38.869 --> 00:43:43.310
 IBM和Red Hat在这一举动中我们

00:43:41.510 --> 00:43:45.680
首先与他们联系以确保

00:43:43.310 --> 00:43:47.119
只是为了验证这是正确的

00:43:45.680 --> 00:43:49.820
方向，我们变得非常坚强

00:43:47.119 --> 00:43:53.380
我们认为在这里达成协议

00:43:49.820 --> 00:43:56.300
导致更加敏捷和灵活

00:43:53.380 --> 00:43:58.850
开发过程会更加开放

00:43:56.300 --> 00:44:02.780
让事情更快地移动

00:43:58.850 --> 00:44:06.470
也许细节还在

00:44:02.780 --> 00:44:09.230
制定了我们期望我们期望这一点

00:44:06.470 --> 00:44:11.030
过程进行得相当快，我们正在

00:44:09.230 --> 00:44:15.440
相当激进，试图做到这一点

00:44:11.030 --> 00:44:19.390
算了，这就是我们的未来

00:44:15.440 --> 00:44:22.100
认为未来会更加开放

00:44:19.390 --> 00:44:23.990
我们得到了很多积极的反馈

00:44:22.100 --> 00:44:25.400
在这一步上，有很多

00:44:23.990 --> 00:44:31.250
激动，我想我们要去

00:44:25.400 --> 00:44:34.490
在这里开始一些细节

00:44:31.250 --> 00:44:39.050
我们正在过渡GlassFish我们的

00:44:34.490 --> 00:44:44.680
盯着产品停靠的地方

00:44:39.050 --> 00:44:47.390
我认为邮件列表，Oracle会

00:44:44.680 --> 00:44:51.770
继续通过以下方式提供支持

00:44:47.390 --> 00:44:54.200
 Java EE 8-给我们的客户带来

00:44:51.770 --> 00:44:59.450
社区，然后我们经常跑

00:44:54.200 --> 00:45:02.869
在Eclipse下，所以我要离开

00:44:59.450 --> 00:45:05.600
你在这里有几个指针

00:45:02.869 --> 00:45:06.530
如果您想留下来，可以了解更多

00:45:05.600 --> 00:45:09.170
在这个房间里

00:45:06.530 --> 00:45:12.170
我注意到Ed Burns是我们的一员

00:45:09.170 --> 00:45:14.330
 Servlet API和Ching的规范负责人

00:45:12.170 --> 00:45:16.250
陈刚进来的

00:45:14.330 --> 00:45:19.730
将在这里谈论servlet 4 

00:45:16.250 --> 00:45:21.920
哦，如果那是你的兴趣，然后

00:45:19.730 --> 00:45:23.660
今天晚些时候有一个小组讨论

00:45:21.920 --> 00:45:26.660
在月球上

00:45:23.660 --> 00:45:30.380
 EE的原理-Eclipse Foundation这样

00:45:26.660 --> 00:45:32.809
 Oracle IBM Red Hat和

00:45:30.380 --> 00:45:36.289
 Eclipse Foundation将存在

00:45:32.809 --> 00:45:39.260
在那里，然后随着一周的进行，我们将

00:45:36.289 --> 00:45:43.309
还有其他规范线索描述了一些

00:45:39.260 --> 00:45:47.720
许多的一些新功能

00:45:43.309 --> 00:45:51.349
我将在该平台中使用其他API 

00:45:47.720 --> 00:45:53.119
明天为JCP的爱好者戴上插头

00:45:51.349 --> 00:45:56.030
夜晚将包括一个数字

00:45:53.119 --> 00:45:58.910
的规格线索我希望能在那里

00:45:56.030 --> 00:46:01.250
好，在那里你可以问问题和

00:45:58.910 --> 00:46:06.859
与以下成员进行更非正式的互动

00:46:01.250 --> 00:46:09.470
社区，以至于我不知道

00:46:06.859 --> 00:46:11.680
如果我有任何问题的时间，我认为

00:46:09.470 --> 00:46:14.720
我需要离开让这些人成立

00:46:11.680 --> 00:46:17.839
但是我会在黑客花园里

00:46:14.720 --> 00:46:21.559
下午，所以如果有人想去科勒尔

00:46:17.839 --> 00:46:23.690
我在那里我很乐意去

00:46:21.559 --> 00:46:26.740
与您见面并回答任何问题

00:46:23.690 --> 00:46:26.740
问题，谢谢

