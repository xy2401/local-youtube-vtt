WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.030 --> 00:00:06.839
嗨，欢迎参加本Oracle代码会议

00:00:04.310 --> 00:00:14.730
今天我们将讨论在

00:00:06.839 --> 00:00:16.830
同步世界，所以这个目标

00:00:14.730 --> 00:00:19.470
会议是讨论宁静的网络

00:00:16.830 --> 00:00:22.680
鉴于我们与之合作的服务

00:00:19.470 --> 00:00:25.650
 Java，我们将基于

00:00:22.680 --> 00:00:28.199
 jaxa现在此会议将

00:00:25.650 --> 00:00:30.869
基本上看2个角度

00:00:28.199 --> 00:00:34.559
对比和同步比较

00:00:30.869 --> 00:00:38.040
现在的方法和同步方法

00:00:34.559 --> 00:00:40.950
我们将为双方提供休息

00:00:38.040 --> 00:00:42.300
端点和消耗剩余端点

00:00:40.950 --> 00:00:46.050
这基本上意味着我们将

00:00:42.300 --> 00:00:50.390
一沉到底意味着什么

00:00:46.050 --> 00:00:50.390
客户端，也可以在服务器端

00:00:50.480 --> 00:00:55.010
让我们先讨论客户端

00:00:55.789 --> 00:01:01.739
所以在Java空间中，我们有jax-rs 

00:00:58.879 --> 00:01:04.379
 jax-rs代表Java api带来宁静

00:01:01.739 --> 00:01:07.260
 Web服务，这是一个标准的基本API 

00:01:04.379 --> 00:01:10.710
我们可以用来产生剩余端点

00:01:07.260 --> 00:01:14.369
由于jax-rs-我们也可以使用

00:01:10.710 --> 00:01:16.860
消耗剩余端点的API，因此如果您

00:01:14.369 --> 00:01:19.320
在杰克升起之前先看看jax-rs 

00:01:16.860 --> 00:01:22.560
 jax-rs基本上是一个易于使用的

00:01:19.320 --> 00:01:26.189
您将用来公开的框架

00:01:22.560 --> 00:01:30.030
其余端点，它是Java EE的一部分

00:01:26.189 --> 00:01:33.030
说了也可以用杰克的

00:01:30.030 --> 00:01:36.360
 Java之外的右脉轮，因此您可以

00:01:33.030 --> 00:01:38.880
使用地址就在Java C之上

00:01:36.360 --> 00:01:41.310
休税前-您很容易

00:01:38.880 --> 00:01:44.070
使用服务器端框架公开

00:01:41.310 --> 00:01:46.290
终点，但涉及消费

00:01:44.070 --> 00:01:48.829
这些端点你基本上必须

00:01:46.290 --> 00:01:51.390
写自己的代码来做到这一点， 

00:01:48.829 --> 00:01:54.450
无论您是使用API 

00:01:51.390 --> 00:01:58.130
例如来自

00:01:54.450 --> 00:02:01.979
 JDK很老很老

00:01:58.130 --> 00:02:05.250
低级API，因此显然

00:02:01.979 --> 00:02:07.770
客户端之间的不匹配

00:02:05.250 --> 00:02:09.869
我们将如何消耗其余端点

00:02:07.770 --> 00:02:12.069
而服务器端在服务器端

00:02:09.869 --> 00:02:18.040
您有一个非常易于使用的API 

00:02:12.069 --> 00:02:20.560
 API，因此您必须使用

00:02:18.040 --> 00:02:23.379
低级API或您可以依靠强硬

00:02:20.560 --> 00:02:26.040
帕蒂解决方案，这是在JAX-RS解决

00:02:23.379 --> 00:02:30.189
也增加了客户端API 

00:02:26.040 --> 00:02:32.170
所以现在在jax-rs注射器中-我们有一个

00:02:30.189 --> 00:02:34.719
我们可以使用的服务器端API 

00:02:32.170 --> 00:02:36.459
公开其余端点，但我们也有一个

00:02:34.719 --> 00:02:40.359
我们可以使用的客户端API 

00:02:36.459 --> 00:02:42.010
消费领先于其他终点

00:02:40.359 --> 00:02:43.239
今天我将讨论jax-rs- 

00:02:42.010 --> 00:02:45.879
这是当前版本

00:02:43.239 --> 00:02:48.879
规格J是3 3 9 

00:02:45.879 --> 00:02:51.430
 Java e7的一部分，但同样您也可以

00:02:48.879 --> 00:02:54.189
在Java EE之外使用短语

00:02:51.430 --> 00:02:56.650
仅在7月，CI还将

00:02:54.189 --> 00:02:58.629
讨论作为对1的访问的一部分

00:02:56.650 --> 00:03:00.370
规范的下一个版本

00:02:58.629 --> 00:03:03.069
应该在夏天发布

00:03:00.370 --> 00:03:06.959
今年，那就是GSR三七

00:03:03.069 --> 00:03:08.889
零，应作为评估的一部分

00:03:06.959 --> 00:03:12.579
重要的事情要提

00:03:08.889 --> 00:03:15.129
我将基于jax-rs进行讨论

00:03:12.579 --> 00:03:17.199
我将使用Jersey，因为它是

00:03:15.129 --> 00:03:19.509
的开源参考实现

00:03:17.199 --> 00:03:21.340
 jax-rs，但考虑到扇区ax的事实

00:03:19.509 --> 00:03:23.489
通常是小斧头，我看你可以

00:03:21.340 --> 00:03:28.299
显然使用任何合规的

00:03:23.489 --> 00:03:31.479
难民阿帕奇等实施

00:03:28.299 --> 00:03:33.819
眨眼等等

00:03:31.479 --> 00:03:38.370
所以实际上没有任何东西

00:03:33.819 --> 00:03:41.229
在本届会议期间特定于泽西岛

00:03:38.370 --> 00:03:44.069
让我们来看看所有的jax-rs 

00:03:41.229 --> 00:03:47.010
 23个鸡蛋制品

00:03:44.069 --> 00:03:49.980
我们首先需要一个客户实例

00:03:47.010 --> 00:03:52.530
我们通过获取一个jax-rs客户实例

00:03:49.980 --> 00:03:54.810
这个非常简单的引导机制

00:03:52.530 --> 00:03:58.709
客户建设者新客户将为我们提供

00:03:54.810 --> 00:04:00.989
我们可以使用的客户端实例

00:03:58.709 --> 00:04:03.480
从那个肯特，我们将不得不构建

00:04:00.989 --> 00:04:06.659
 Web资源目标Web资源

00:04:03.480 --> 00:04:10.849
目标只是它的位置

00:04:06.659 --> 00:04:13.469
我们的远程端点所在的网络

00:04:10.849 --> 00:04:16.530
然后根据目标，我们将

00:04:13.469 --> 00:04:18.269
实际上构造请求本身

00:04:16.530 --> 00:04:22.049
在这种情况下，假设我们要

00:04:18.269 --> 00:04:23.460
得到巴黎市的预报

00:04:22.049 --> 00:04:28.259
这就是为什么我们要设置一些查询

00:04:23.460 --> 00:04:29.849
参数我们也使用get HTTP 

00:04:28.259 --> 00:04:32.940
给定我们想要得到的动词

00:04:29.849 --> 00:04:36.090
来自网络的资源，我们也

00:04:32.940 --> 00:04:38.009
指定我们期望的响应类型

00:04:36.090 --> 00:04:40.440
从远程端点获取

00:04:38.009 --> 00:04:44.039
案例，这是一个焦点课程，你会看到

00:04:40.440 --> 00:04:49.080
我们调用的结果是

00:04:44.039 --> 00:04:50.759
鉴于

00:04:49.080 --> 00:04:53.009
事实上，我们有这种容器

00:04:50.759 --> 00:04:55.800
这种容器相对来说

00:04:53.009 --> 00:04:57.930
锋利的对象，我们需要确保我们

00:04:55.800 --> 00:05:03.030
一旦我们关闭了时间容器

00:04:57.930 --> 00:05:05.880
这样做是注射器-我们有这个新的

00:05:03.030 --> 00:05:09.300
客户端API，它是流利的API，因此

00:05:05.880 --> 00:05:11.130
表示这是一个非常易于使用的API 

00:05:09.300 --> 00:05:13.800
基本上，您将在其中链接所有

00:05:11.130 --> 00:05:15.000
方法调用以构造您的

00:05:13.800 --> 00:05:16.970
请求

00:05:15.000 --> 00:05:19.320
所以就像一个短语

00:05:16.970 --> 00:05:22.409
逐步指定您要的内容

00:05:19.320 --> 00:05:28.110
做你想从你那里得到的

00:05:22.409 --> 00:05:31.650
因此浪费了调用，API本身

00:05:28.110 --> 00:05:33.300
引入了不同的新对象，例如

00:05:31.650 --> 00:05:37.409
我们已经拥有的试用容器

00:05:33.300 --> 00:05:39.150
提到是这样，如果你不欺骗

00:05:37.409 --> 00:05:41.940
如果太平洋公约结束

00:05:39.150 --> 00:05:44.880
配置，如果您看到有

00:05:41.940 --> 00:05:48.719
定制该客户的能力

00:05:44.880 --> 00:05:52.500
容器，然后我们有一个网络目标

00:05:48.719 --> 00:05:55.680
网络资源目标，可能是一些

00:05:52.500 --> 00:05:57.570
荣耀你我是

00:05:55.680 --> 00:06:00.539
我们网络上的位置

00:05:57.570 --> 00:06:03.240
远程端点构建网站

00:06:00.539 --> 00:06:05.580
客户端容器中的目标和

00:06:03.240 --> 00:06:08.190
关于jax-rs客户端API的好处

00:06:05.580 --> 00:06:10.080
基本上是分享了很多

00:06:08.190 --> 00:06:13.259
我们在服务器端拥有的概念

00:06:10.080 --> 00:06:15.690
所以我们显然有路径的概念

00:06:13.259 --> 00:06:17.940
我们也支持模板

00:06:15.690 --> 00:06:20.220
我们在服务器端有支持

00:06:17.940 --> 00:06:22.680
用于查询参数矩阵参数

00:06:20.220 --> 00:06:24.479
依此类推，依此类推，如果您是

00:06:22.680 --> 00:06:27.000
已经熟悉ajax的服务

00:06:24.479 --> 00:06:33.120
 ipi，您将看到客户端

00:06:27.000 --> 00:06:34.830
 API非常简单易学，我们也

00:06:33.120 --> 00:06:37.889
具有这种请求调用的概念

00:06:34.830 --> 00:06:40.500
基本上您真正拥有的建筑商

00:06:37.889 --> 00:06:42.750
定制您的要求的能力

00:06:40.500 --> 00:06:45.509
就像你有能力设置

00:06:42.750 --> 00:06:48.150
 Cookies您希望使用哪种媒体类型

00:06:45.509 --> 00:06:51.240
设置标题等等

00:06:48.150 --> 00:06:54.440
显然，定义网络的安全性

00:06:51.240 --> 00:06:56.699
您想使用哪些HTTP动词

00:06:54.440 --> 00:06:58.800
值得一提的是确切的休息

00:06:56.699 --> 00:07:01.380
一个人也有能力设定

00:06:58.800 --> 00:07:03.830
访问或服务，我们将来到

00:07:01.380 --> 00:07:03.830
稍后的

00:07:07.110 --> 00:07:12.419
调用流程

00:07:10.229 --> 00:07:14.759
已经看过非常简单，所以我们有一个

00:07:12.419 --> 00:07:17.610
来自那个土地的客户集装箱

00:07:14.759 --> 00:07:19.800
容器，我们将构建一个网络目标

00:07:17.610 --> 00:07:21.720
从该网络目标中，我们将

00:07:19.800 --> 00:07:24.870
构建我们的请求并预订

00:07:21.720 --> 00:07:26.370
要求得到回应，如果我们看

00:07:24.870 --> 00:07:28.250
那个例子是液体

00:07:26.370 --> 00:07:32.280
唯一的例子是这次

00:07:28.250 --> 00:07:35.789
我们指定我们希望得到

00:07:32.280 --> 00:07:39.060
作为回报，我们还设置了一些JSON类型

00:07:35.789 --> 00:07:41.250
一些标题，在这种情况下，我们不

00:07:39.060 --> 00:07:43.229
想要一个单一的预测，但是我们

00:07:41.250 --> 00:07:45.810
希望有一点预测，所以

00:07:43.229 --> 00:07:52.020
为什么我们使用这种通用类型的

00:07:45.810 --> 00:07:53.789
现在预测的Vista跟踪器是

00:07:52.020 --> 00:07:56.310
客户端API也具有以下概念

00:07:53.789 --> 00:07:58.380
调用者，所以如果您看这个例子

00:07:56.310 --> 00:08:00.930
这是我们一直在做的例子

00:07:58.380 --> 00:08:03.690
直到现在我们还没有指定

00:08:00.930 --> 00:08:05.969
调用者，这意味着我们

00:08:03.690 --> 00:08:07.879
获取默认行为并通过

00:08:05.969 --> 00:08:11.069
默认我们拥有的调用者

00:08:07.879 --> 00:08:13.169
发起是同步调用者，因此

00:08:11.069 --> 00:08:16.940
这意味着这是一个阻止呼叫

00:08:13.169 --> 00:08:19.289
所以这意味着一旦计数

00:08:16.940 --> 00:08:23.490
抱歉，get方法在上被调用

00:08:19.289 --> 00:08:25.889
客户端将一直阻塞该方法，直到

00:08:23.490 --> 00:08:28.139
响应已由远程发送

00:08:25.889 --> 00:08:32.039
端点，所以这确实是一个障碍

00:08:28.139 --> 00:08:34.560
打电话来的好消息是

00:08:32.039 --> 00:08:37.680
 jax-ur是-也是异步的

00:08:34.560 --> 00:08:41.550
 invoker-基本介绍的调用者

00:08:37.680 --> 00:08:44.790
允许我们在

00:08:41.550 --> 00:08:46.950
无阻碍的时尚做到这一点

00:08:44.790 --> 00:08:50.700
完全一样的api唯一的优点是

00:08:46.950 --> 00:08:52.980
我们必须指定的是，我们需要

00:08:50.700 --> 00:08:55.110
指定我们要使用异步

00:08:52.980 --> 00:08:58.350
调用者，您会在底部看到

00:08:55.110 --> 00:09:00.420
这张幻灯片，我正在为此锦上添花

00:08:58.350 --> 00:09:03.149
方法，这基本上是为了告诉

00:09:00.420 --> 00:09:06.990
反对者可以把我的容器

00:09:03.149 --> 00:09:08.760
想要使用结冰调用程序，并且

00:09:06.990 --> 00:09:12.029
区别在于，只要我们这样做

00:09:08.760 --> 00:09:14.820
我们执行get调用的方法

00:09:12.029 --> 00:09:16.649
将直接返回，如果您查看

00:09:14.820 --> 00:09:19.630
从这些中得到的返回类型

00:09:16.649 --> 00:09:22.300
 Oracle的调用这不是字符串

00:09:19.630 --> 00:09:23.980
或者，但这是字符串类型的未来类型

00:09:22.300 --> 00:09:26.290
这意味着我们有未来

00:09:23.980 --> 00:09:28.840
我们可以在某些地方使用的对象

00:09:26.290 --> 00:09:35.380
指向实际得到我们的结果

00:09:28.840 --> 00:09:37.390
我想休息一下，所以要做一个

00:09:35.380 --> 00:09:39.790
远程并指向一个同步

00:09:37.390 --> 00:09:42.760
我们基本上需要讲的调用

00:09:39.790 --> 00:09:44.380
因此，我们的客户端需要

00:09:42.760 --> 00:09:45.970
告诉我们的目标客户

00:09:44.380 --> 00:09:48.490
我们想跳舞的容器

00:09:45.970 --> 00:09:50.530
调用者可以做到这一点，我们只需要使用

00:09:48.490 --> 00:09:52.720
道德方法，同时我们保留

00:09:50.530 --> 00:09:53.920
请求，这样您就可以看到

00:09:52.720 --> 00:09:56.500
我们得到的回报

00:09:53.920 --> 00:09:58.420
是我们未来的束缚，这意味着

00:09:56.500 --> 00:10:00.430
我们有一个未来的目标，我们可以

00:09:58.420 --> 00:10:03.610
稍后查询以实际获取

00:10:00.430 --> 00:10:07.180
我们与远程端点的结果

00:10:03.610 --> 00:10:08.620
位置的问题是，如果需要

00:10:07.180 --> 00:10:11.350
服务器发送了很长时间

00:10:08.620 --> 00:10:13.000
回应我们对get metal的呼吁

00:10:11.350 --> 00:10:15.790
知道未来的对象将基本上

00:10:13.000 --> 00:10:18.070
阻止等待该结果，并

00:10:15.790 --> 00:10:20.230
比这更糟糕的是，由于某种原因

00:10:18.070 --> 00:10:22.330
服务器，如果远程端点不是

00:10:20.230 --> 00:10:24.220
能够将结果发送给我们的客户

00:10:22.330 --> 00:10:28.870
应用程序将永远等待

00:10:24.220 --> 00:10:32.350
结果永远不会到来，所以我们需要

00:10:28.870 --> 00:10:34.390
确保我们设置了超时时间

00:10:32.350 --> 00:10:36.340
这是一些例子，但是你看到

00:10:34.390 --> 00:10:39.850
这次我们设置了五个超时

00:10:36.340 --> 00:10:41.740
进行调用的秒数

00:10:39.850 --> 00:10:44.800
未来的对象，这意味着

00:10:41.740 --> 00:10:47.680
这个未来的对象将被查询

00:10:44.800 --> 00:10:49.840
在此之后最多五秒钟

00:10:47.680 --> 00:10:52.660
将会引发异常，因此我们

00:10:49.840 --> 00:10:55.210
即使

00:10:52.660 --> 00:10:59.550
服务器无法发送

00:10:55.210 --> 00:11:02.530
回应，但如果仍然存在问题

00:10:59.550 --> 00:11:05.350
因此，这意味着我们的应用程序可能

00:11:02.530 --> 00:11:06.970
在最坏的情况下被阻止

00:11:05.350 --> 00:11:10.570
五秒钟，这意味着

00:11:06.970 --> 00:11:13.000
基本上我们的客户端线程将是

00:11:10.570 --> 00:11:15.700
五秒钟阻塞吹气

00:11:13.000 --> 00:11:17.860
这是一个大问题，因为

00:11:15.700 --> 00:11:18.610
线程直接无法执行

00:11:17.860 --> 00:11:20.290
还要别的吗

00:11:18.610 --> 00:11:22.300
所以如果我们使用相同的

00:11:20.290 --> 00:11:27.610
特定线程，例如更新

00:11:22.300 --> 00:11:30.000
用户界面我们的用户界面将冻结五个

00:11:27.610 --> 00:11:30.000
秒

00:11:32.320 --> 00:11:37.570
鉴于这是一个未来的目标，我们可以

00:11:34.480 --> 00:11:40.510
做这样的事情而不是

00:11:37.570 --> 00:11:43.330
调用要素对象上的get 

00:11:40.510 --> 00:11:47.380
这本身就是一个封锁电话

00:11:43.330 --> 00:11:52.000
可以检查是否已完成，而Ethan是

00:11:47.380 --> 00:11:52.630
基本上，一旦我们有了

00:11:52.000 --> 00:11:55.510
结果

00:11:52.630 --> 00:11:58.810
所以一旦功能完成或具有

00:11:55.510 --> 00:12:01.050
被取消或发生了异常

00:11:58.810 --> 00:12:01.050
提高

00:12:02.690 --> 00:12:09.220
这是克服该问题的解决方法

00:12:05.509 --> 00:12:13.459
问题，但仍然不是很实用

00:12:09.220 --> 00:12:16.250
一旦我们拥有，我们确定完成的是

00:12:13.459 --> 00:12:18.290
是的，我们实际上可以调用get 

00:12:16.250 --> 00:12:22.240
关于未来对象的方法

00:12:18.290 --> 00:12:22.240
这种情况下，我们知道我不会阻止

00:12:25.300 --> 00:12:31.550
在这种情况下，这也是一个好主意

00:12:28.250 --> 00:12:33.889
设置客户端容器计时器，因为

00:12:31.550 --> 00:12:38.920
我们要确保得到

00:12:33.889 --> 00:12:45.889
请求，以便获取休息调用

00:12:38.920 --> 00:12:47.690
不会太久发短信是

00:12:45.889 --> 00:12:51.649
也是jax-rs的一部分

00:12:47.690 --> 00:12:54.350
在客户端这就是我们所说的

00:12:51.649 --> 00:12:56.690
同步调用回调

00:12:54.350 --> 00:13:01.009
我们可以使用它基本上是一个非常

00:12:56.690 --> 00:13:03.079
简单界面谁有两种方法1 

00:13:01.009 --> 00:13:04.579
方法完成，所以方法是

00:13:03.079 --> 00:13:08.360
基本上是一个回调

00:13:04.579 --> 00:13:10.699
同步响应时调用

00:13:08.360 --> 00:13:15.259
已经处理，第二个

00:13:10.699 --> 00:13:18.680
回调是一个妖怪的方法

00:13:15.259 --> 00:13:20.360
自动调用Finneran 

00:13:18.680 --> 00:13:25.610
引发了异常，所以如果存在

00:13:20.360 --> 00:13:30.740
在调用中一直是一个问题，所以

00:13:25.610 --> 00:13:34.519
它像往常一样构造

00:13:30.740 --> 00:13:36.709
来自客户的资源目标

00:13:34.519 --> 00:13:38.569
鉴于我正在使用我认为的调用者

00:13:36.709 --> 00:13:42.769
这是我们的异步调用

00:13:38.569 --> 00:13:45.529
想做的我们正在使用get HTTP 

00:13:42.769 --> 00:13:48.910
动词方法，但是这次我们通过了

00:13:45.529 --> 00:13:51.649
调用回调的实例，以及

00:13:48.910 --> 00:13:53.959
记住关于

00:13:51.649 --> 00:13:55.850
叫回第一个完成的

00:13:53.959 --> 00:13:58.160
那是调用回调

00:13:55.850 --> 00:14:00.850
一旦我们获得了

00:13:58.160 --> 00:14:00.850
远程端点

00:14:01.590 --> 00:14:06.750
第二个回调是cell方法

00:14:04.860 --> 00:14:08.880
如果有事情会被调用

00:14:06.750 --> 00:14:10.830
如果您看一下定义，现在错了

00:14:08.880 --> 00:14:13.740
我们拥有的调用回调

00:14:10.830 --> 00:14:15.570
在这种情况下定义参数化类型

00:14:13.740 --> 00:14:18.300
这是一个客户，所以这意味着

00:14:15.570 --> 00:14:21.540
我们期望从远程获得什么

00:14:18.300 --> 00:14:24.810
端点是一种客户类型，您会看到

00:14:21.540 --> 00:14:27.150
该资源调用的返回

00:14:24.810 --> 00:14:31.080
是类型为customer的未来对象，并且

00:14:27.150 --> 00:14:33.720
您还看到完成的回调

00:14:31.080 --> 00:14:36.360
期望获得客户类型为

00:14:33.720 --> 00:14:41.600
参数有意义，这就是我们

00:14:36.360 --> 00:14:45.030
希望从调用中得到回报

00:14:41.600 --> 00:14:48.390
现在让我们继续前进，让我们

00:14:45.030 --> 00:14:51.930
从这个角度来看，我们有一个

00:14:48.390 --> 00:14:54.510
简单的微服务典型场景

00:14:51.930 --> 00:14:59.700
我们有一个旅行社服务

00:14:54.510 --> 00:15:00.210
那将是多种背

00:14:59.700 --> 00:15:04.500
结束

00:15:00.210 --> 00:15:06.960
阅读服务场景如下

00:15:04.500 --> 00:15:09.420
所以我们有一个用户通过

00:15:06.960 --> 00:15:12.030
旅行社服务和那次旅行

00:15:09.420 --> 00:15:14.610
代理服务想建议

00:15:12.030 --> 00:15:17.250
该用户的潜在目的地

00:15:14.610 --> 00:15:20.400
您可能要访问的用户

00:15:17.250 --> 00:15:22.620
到旅行社服务

00:15:20.400 --> 00:15:25.140
将要调用的第一个服务将

00:15:22.620 --> 00:15:26.730
是客户服务，所以这个主意是

00:15:25.140 --> 00:15:30.480
首先我们需要某种

00:15:26.730 --> 00:15:32.730
该给定客户的历史记录基于

00:15:30.480 --> 00:15:35.190
旅行社服务将

00:15:32.730 --> 00:15:37.500
调用接收到的目的地

00:15:35.190 --> 00:15:41.730
该服务的想法是提供一些

00:15:37.500 --> 00:15:43.230
该用户的潜在目的地，因此

00:15:41.730 --> 00:15:45.450
这意味着旅行社有

00:15:43.230 --> 00:15:48.480
现在列出潜在的

00:15:45.450 --> 00:15:50.490
建议的目的地，我们还

00:15:48.480 --> 00:15:52.740
要做的是针对每个目的地

00:15:50.490 --> 00:15:54.270
我们将建议我们要

00:15:52.740 --> 00:15:57.150
调用气象服务和

00:15:54.270 --> 00:16:00.150
报价服务以增加一些天气

00:15:57.150 --> 00:16:02.040
信息到每个目的地，而且

00:16:00.150 --> 00:16:04.320
我们也想要一些价格

00:16:02.040 --> 00:16:07.410
信息到目的地，我们

00:16:04.320 --> 00:16:10.170
即将向用户建议

00:16:07.410 --> 00:16:12.630
具有所有这些结果，我们基本上

00:16:10.170 --> 00:16:14.680
合并它们并将它们发送回

00:16:12.630 --> 00:16:17.350
用户，所以我们

00:16:14.680 --> 00:16:20.769
得到一个潜在目的地的清单

00:16:17.350 --> 00:16:23.379
您可能想与每个人一起访问

00:16:20.769 --> 00:16:27.480
根据价格的目的地

00:16:23.379 --> 00:16:27.480
信息和一些天气预报

00:16:28.589 --> 00:16:37.720
现在显然，鉴于我们有

00:16:35.170 --> 00:16:39.970
多种服务消耗我们

00:16:37.720 --> 00:16:43.089
基本上需要实施一些

00:16:39.970 --> 00:16:45.850
工作流程，因此旅行社服务

00:16:43.089 --> 00:16:48.279
会有一些非常基本的

00:16:45.850 --> 00:16:50.290
等式层调用不同

00:16:48.279 --> 00:16:52.869
服务，所以第一项服务是

00:16:50.290 --> 00:16:54.699
调用基于

00:16:52.869 --> 00:16:56.679
它将调用目标

00:16:54.699 --> 00:16:59.619
服务，一旦拥有了所有

00:16:56.679 --> 00:17:01.119
它将并行调用的目标

00:16:59.619 --> 00:17:04.569
气象服务和

00:17:01.119 --> 00:17:07.059
涂层服务，因此非常明显

00:17:04.569 --> 00:17:08.679
纯粹的同步方法不会

00:17:07.059 --> 00:17:11.559
这种方法真的很有意义

00:17:08.679 --> 00:17:14.260
这是一个非常简单的场景，但仍然

00:17:11.559 --> 00:17:17.860
在性能方面，这将是非常

00:17:14.260 --> 00:17:19.299
基本上是很糟糕的时间

00:17:17.860 --> 00:17:22.020
将结果提供给最终用户

00:17:19.299 --> 00:17:24.909
基本上是所有

00:17:22.020 --> 00:17:26.679
个人要求旅行和

00:17:24.909 --> 00:17:29.919
这样做的服务不是

00:17:26.679 --> 00:17:31.960
我们想要做的事情很明显

00:17:29.919 --> 00:17:35.830
我们必须同步

00:17:31.960 --> 00:17:39.279
并简化服务

00:17:35.830 --> 00:17:45.570
只看两个服务

00:17:39.279 --> 00:17:48.279
想简化工作流程并调用

00:17:45.570 --> 00:17:50.289
目的地服务，所以我们想

00:17:48.279 --> 00:17:53.080
有一些目的地，每个目的地

00:17:50.289 --> 00:17:56.409
我们想要一些天气的目的地

00:17:53.080 --> 00:17:58.510
我们想要在

00:17:56.409 --> 00:18:02.020
异步方式，所以如果我们看一下

00:17:58.510 --> 00:18:04.510
看起来像这样的代码

00:18:02.020 --> 00:18:07.299
首先向目的地提出要求

00:18:04.510 --> 00:18:09.429
服务获得一些推荐或一些

00:18:07.299 --> 00:18:13.510
建议显然我们正在使用

00:18:09.429 --> 00:18:17.200
同步调用程序，我们必须指定一个

00:18:13.510 --> 00:18:19.120
教育回调记得

00:18:17.200 --> 00:18:21.429
您需要执行的调用回调

00:18:19.120 --> 00:18:23.740
回电话第一个是完成的

00:18:21.429 --> 00:18:25.779
一旦我们调用回调

00:18:23.740 --> 00:18:28.150
具有调用的所有结果

00:18:25.779 --> 00:18:30.400
在这种情况下，我们将获得此列表

00:18:28.150 --> 00:18:32.440
国家，因此有潜在建议的清单

00:18:30.400 --> 00:18:38.260
我们可能想提供给

00:18:32.440 --> 00:18:40.930
用户，那么我们基本上会过去

00:18:38.260 --> 00:18:43.300
该列表以及所有元素

00:18:40.930 --> 00:18:47.500
那个清单，我们会再休息

00:18:43.300 --> 00:18:50.170
再次请求，我们必须在

00:18:47.500 --> 00:18:53.650
序列时尚，所以我们使用做同步

00:18:50.170 --> 00:18:55.540
调用者认为这没什么

00:18:53.650 --> 00:18:58.480
调用我们必须指定一个

00:18:55.540 --> 00:19:01.420
调用时调用

00:18:58.480 --> 00:19:04.510
回电需要回电

00:19:01.420 --> 00:19:06.490
定义，所以第一个是那个

00:19:04.510 --> 00:19:11.140
只要我们拥有所有

00:19:06.490 --> 00:19:13.240
结果，我们还必须确保

00:19:11.140 --> 00:19:16.330
我们提供的线程回调

00:19:13.240 --> 00:19:19.060
 -我认为我们正在做的要求

00:19:16.330 --> 00:19:23.830
所以我们会有这样的事情

00:19:19.060 --> 00:19:26.140
所以我知道你看到那种

00:19:23.830 --> 00:19:28.870
代码变得有点困难

00:19:26.140 --> 00:19:30.520
写，这意味着最后

00:19:28.870 --> 00:19:32.860
那天我们会打电话给

00:19:30.520 --> 00:19:35.980
很难编写调试信息， 

00:19:32.860 --> 00:19:38.580
维护您还看到错误

00:19:35.980 --> 00:19:41.380
处理基本上遍布

00:19:38.580 --> 00:19:44.260
我们的代码，所以很明显

00:19:41.380 --> 00:19:46.480
有点困难，为什么会这样

00:19:44.260 --> 00:19:47.830
我们说过要同步

00:19:46.480 --> 00:19:50.680
因为我们想要得到

00:19:47.830 --> 00:19:52.780
性能和可扩展性，我们没有

00:19:50.680 --> 00:19:55.570
想要阻止我们这样做

00:19:52.780 --> 00:19:57.400
使用来自API的赎金

00:19:55.570 --> 00:19:59.590
他们是我们之间的依赖

00:19:57.400 --> 00:20:01.630
服务，我们看到这个API并没有

00:19:59.590 --> 00:20:04.000
确实适合我们需要的模型

00:20:01.630 --> 00:20:06.850
在一个资产指令中调用多个

00:20:04.000 --> 00:20:10.480
服务和每个服务的依赖关系

00:20:06.850 --> 00:20:16.080
在其他服务之间，所以它不会

00:20:10.480 --> 00:20:18.370
扎卡里（Zachary）的确很有效-对于调用者

00:20:16.080 --> 00:20:20.950
默认调用者是

00:20:18.370 --> 00:20:23.410
同步调用者，这意味着

00:20:20.950 --> 00:20:25.180
它正在阻塞，并且还有另一个

00:20:23.410 --> 00:20:29.410
介绍适当的这是我认为

00:20:25.180 --> 00:20:31.630
方法注入器-一个正在添加一个

00:20:29.410 --> 00:20:34.180
万千阻滞剂是反应性的

00:20:31.630 --> 00:20:36.130
同步调用程序是RX方法

00:20:34.180 --> 00:20:38.710
您在幻灯片底部看到的

00:20:36.130 --> 00:20:40.540
当我们使用时，您会看到一个

00:20:38.710 --> 00:20:41.100
该调用者我们得到的回报

00:20:40.540 --> 00:20:43.530
的

00:20:41.100 --> 00:20:47.669
请求位置是类型

00:20:43.530 --> 00:20:50.039
压缩阶段，让我们快速谈谈

00:20:47.669 --> 00:20:52.320
关于完成阶段的API 

00:20:50.039 --> 00:20:54.900
已添加以延迟的新API参见8 

00:20:52.320 --> 00:20:57.030
我会否认有关该API的事情是

00:20:54.900 --> 00:21:00.240
我们有一个状态的概念

00:20:57.030 --> 00:21:02.220
阶段是一个运算

00:21:00.240 --> 00:21:06.179
执行动作或计算机

00:21:02.220 --> 00:21:07.590
以同步的方式实现价值，我们

00:21:06.179 --> 00:21:10.110
有能力基本连锁

00:21:07.590 --> 00:21:11.789
不同的阶段，所以我们可以定义一个流程

00:21:10.110 --> 00:21:13.309
不同阶段的需要

00:21:11.789 --> 00:21:17.610
按特定顺序调用

00:21:13.309 --> 00:21:20.909
因此，在阶段结束时，一个阶段可能会

00:21:17.610 --> 00:21:23.789
进而触发另一个依赖阶段

00:21:20.909 --> 00:21:27.330
现在看一下执行

00:21:23.789 --> 00:21:29.940
压缩阶段RDoc it API本身

00:21:27.330 --> 00:21:31.799
似乎有些令人生畏

00:21:29.940 --> 00:21:36.179
它有大约40种方法

00:21:31.799 --> 00:21:38.580
掌握API的方法

00:21:36.179 --> 00:21:40.559
了解一些概念，每个概念

00:21:38.580 --> 00:21:43.260
概念有逻辑关键字和

00:21:40.559 --> 00:21:46.440
该关键字将基本上用于

00:21:43.260 --> 00:21:48.150
构造您要使用的方法

00:21:46.440 --> 00:21:50.700
使用，这就是为什么我们很多

00:21:48.150 --> 00:21:52.559
方法，但归根结底

00:21:50.700 --> 00:21:55.890
方法基本上只是一种组合

00:21:52.559 --> 00:21:59.429
不同的行为，例如一个

00:21:55.890 --> 00:22:02.159
阶段执行，我们可能会触发另一个

00:21:59.429 --> 00:22:04.710
因此，如果您只想触发

00:22:02.159 --> 00:22:07.860
执行另一个阶段，您将使用

00:22:04.710 --> 00:22:10.590
然后关键字，但如果你想

00:22:07.860 --> 00:22:14.400
触发给定阶段的执行

00:22:10.590 --> 00:22:17.520
一旦完成给定阶段，您

00:22:14.400 --> 00:22:19.470
将使用组合阶段，如果

00:22:17.520 --> 00:22:23.280
想触发初等教育

00:22:19.470 --> 00:22:26.429
如果两者之一

00:22:23.280 --> 00:22:31.799
完成阶段，您将使用

00:22:26.429 --> 00:22:34.440
其他关键字等等

00:22:31.799 --> 00:22:36.740
你必须知道计算

00:22:34.440 --> 00:22:38.909
接受参数并返回结果

00:22:36.740 --> 00:22:40.559
例如我们有热灯

00:22:38.909 --> 00:22:42.809
关键字，这意味着您

00:22:40.559 --> 00:22:45.510
将为功能提供一个

00:22:42.809 --> 00:22:47.610
前一阶段的结果作为参数

00:22:45.510 --> 00:22:51.030
该函数将返回结果

00:22:47.610 --> 00:22:53.590
你必须接受一个

00:22:51.030 --> 00:22:55.630
需要一个消费者，我只需要技术

00:22:53.590 --> 00:22:58.539
因此它不会返回任何内容

00:22:55.630 --> 00:23:01.600
是消费者，您也有机会

00:22:58.539 --> 00:23:03.400
具有可运行性的关键字

00:23:01.600 --> 00:23:07.840
没有论点，国米的和

00:23:03.400 --> 00:23:09.370
返回结果的另一个概念

00:23:07.840 --> 00:23:12.820
您必须使用的关键字

00:23:09.370 --> 00:23:14.919
理解是对

00:23:12.820 --> 00:23:18.010
压缩做计算是

00:23:14.919 --> 00:23:20.200
这样安排，如果字母不交

00:23:18.010 --> 00:23:22.360
我认为关键字意味着

00:23:20.200 --> 00:23:24.970
我们正在使用舞台默认

00:23:22.360 --> 00:23:27.399
执行设施，但只有高

00:23:24.970 --> 00:23:31.360
另一方面，如果该方法以a结尾

00:23:27.399 --> 00:23:33.580
下沉意味着我们要使用

00:23:31.360 --> 00:23:36.399
阶段默认同步执行

00:23:33.580 --> 00:23:39.460
设施，此外您还拥有

00:23:36.399 --> 00:23:42.130
通过特定的trivet或

00:23:39.460 --> 00:23:44.320
服务基本上就是看

00:23:42.130 --> 00:23:46.840
压缩阶段的API 

00:23:44.320 --> 00:23:49.210
结合这些不同的关键字来

00:23:46.840 --> 00:23:51.429
基本上获得您所使用的方法

00:23:49.210 --> 00:23:54.460
想要使用，例如，您必须

00:23:51.429 --> 00:23:56.320
然后接受方法，然后如果你想要

00:23:54.460 --> 00:23:59.350
以同步动作执行

00:23:56.320 --> 00:24:01.510
除了我认为，然后

00:23:59.350 --> 00:24:04.630
除了能够通过

00:24:01.510 --> 00:24:07.720
遗嘱执行人等等，否则您可能会有

00:24:04.630 --> 00:24:10.950
完成，除了两个，如果你想等待

00:24:07.720 --> 00:24:14.169
两个完成阶段的执行

00:24:10.950 --> 00:24:17.740
在触发另一个完成之前

00:24:14.169 --> 00:24:20.409
阶段或然后接受两种通过方法

00:24:17.740 --> 00:24:22.990
依此类推，等等

00:24:20.409 --> 00:24:24.520
常数您真正需要的GPA 

00:24:22.990 --> 00:24:26.289
了解那些不同的关键字， 

00:24:24.520 --> 00:24:33.549
那只是使用

00:24:26.289 --> 00:24:35.789
正确的方法，如果我们看一个例子，我们

00:24:33.549 --> 00:24:39.880
有第一个要求，所以这个

00:24:35.789 --> 00:24:42.250
请求与一些远程端点

00:24:39.880 --> 00:24:44.799
给定价格信息

00:24:42.250 --> 00:24:49.090
目的地，您看到我们正在使用我们

00:24:44.799 --> 00:24:51.159
正在使用Oracle调用程序，然后我们

00:24:49.090 --> 00:24:54.250
还有第二个要求

00:24:51.159 --> 00:24:56.260
得到一个的预测信息

00:24:54.250 --> 00:24:59.890
给定目的地，您再次看到

00:24:56.260 --> 00:25:01.809
我们正在使用它的it调用程序，所以它

00:24:59.890 --> 00:25:04.740
这意味着我们得到的回报是

00:25:01.809 --> 00:25:04.740
到完成阶段

00:25:05.420 --> 00:25:13.410
当两种状态都正常完成时

00:25:09.270 --> 00:25:17.550
两个结果传递给函数

00:25:13.410 --> 00:25:19.110
我们在这里，那就是

00:25:17.550 --> 00:25:21.000
为什么我们使用两个然后合并

00:25:19.110 --> 00:25:23.430
如果我们是第一次压缩

00:25:21.000 --> 00:25:26.040
舞台，我们想展示一个

00:25:23.430 --> 00:25:28.740
第二个压缩阶段

00:25:26.040 --> 00:25:31.350
 GS F一旦我们得到了结果

00:25:28.740 --> 00:25:33.600
传递给其中的功能

00:25:31.350 --> 00:25:36.540
如果负担得起的方法保留案例

00:25:33.600 --> 00:25:39.750
得到的得到作为的参数

00:25:36.540 --> 00:25:42.900
导致调用的结果

00:25:39.750 --> 00:25:45.210
以下示例并行获取

00:25:42.900 --> 00:25:47.580
在另一种价格和结构中

00:25:45.210 --> 00:25:50.550
预测目的地及其

00:25:47.580 --> 00:25:54.510
如果有一些特定的保留

00:25:50.550 --> 00:25:55.980
条件rmx，所以这基本上是一个新的

00:25:54.510 --> 00:25:57.870
关于一个喷油器，我们有这个新的

00:25:55.980 --> 00:26:01.230
爱立信摇杆，让您

00:25:57.870 --> 00:26:04.470
以同步方式消费

00:26:01.230 --> 00:26:06.600
休息终点，然后我思考

00:26:04.470 --> 00:26:08.940
该API是我们正在使用Java 

00:26:06.600 --> 00:26:10.590
喷射压缩搜索API基本上

00:26:08.940 --> 00:26:15.990
定义之间的依赖关系

00:26:10.590 --> 00:26:18.210
我们要调用的服务

00:26:15.990 --> 00:26:20.010
完成阶段受支持

00:26:18.210 --> 00:26:21.870
所有这些演员的盒装注射器

00:26:20.010 --> 00:26:24.180
实现所有插孔或s21 

00:26:21.870 --> 00:26:26.460
实现必须中止

00:26:24.180 --> 00:26:29.430
压缩阶段API表示

00:26:26.460 --> 00:26:32.040
规范的目标是使

00:26:29.430 --> 00:26:34.980
它可以扩展并打开八度

00:26:32.040 --> 00:26:43.020
框架，例如泽西岛计划

00:26:34.980 --> 00:26:45.450
添加对rx Java的支持，让我们看一下

00:26:43.020 --> 00:26:47.130
快速演示来说明这一点

00:26:45.450 --> 00:26:49.130
我在我的机器上运行的是

00:26:47.130 --> 00:26:52.890
基本上，这种旅行密集型服务

00:26:49.130 --> 00:26:54.900
它是向量的一个样本

00:26:52.890 --> 00:26:58.140
样本基本上具有所有这些

00:26:54.900 --> 00:27:00.330
实现该方案所需的服务

00:26:58.140 --> 00:27:02.220
所以我们有旅行紧急服务

00:27:00.330 --> 00:27:04.440
然后在我们拥有的同一台机器上运行

00:27:02.220 --> 00:27:06.450
神话般的后端服务

00:27:04.440 --> 00:27:13.299
天气服务目的地服务

00:27:06.450 --> 00:27:15.190
等等，这是

00:27:13.299 --> 00:27:17.019
该样品，所以基本上我们有

00:27:15.190 --> 00:27:20.289
身份服务，所以这基本上是

00:27:17.019 --> 00:27:21.850
旅行身份服务，它具有

00:27:20.289 --> 00:27:24.909
多种实现，它有一个

00:27:21.850 --> 00:27:26.980
同步执行，因此如果

00:27:24.909 --> 00:27:28.749
旅行社服务将消耗掉所有

00:27:26.980 --> 00:27:30.549
后端服务使用

00:27:28.749 --> 00:27:33.610
传统的同步方法

00:27:30.549 --> 00:27:36.190
预订一个也有一个同步

00:27:33.610 --> 00:27:38.529
方法，最后我们还将使用

00:27:36.190 --> 00:27:40.869
完成阶段再次如此

00:27:38.529 --> 00:27:43.029
如果我们使用计算机而不是GPIO 

00:27:40.869 --> 00:27:45.249
看这里我们也有远程服务

00:27:43.029 --> 00:27:48.850
所以这个远程服务基本上是

00:27:45.249 --> 00:27:51.009
后端服务，例如我们

00:27:48.850 --> 00:27:55.179
有一个访问过的偏远目的地

00:27:51.009 --> 00:27:57.820
将给我们一份拜访服务的清单

00:27:55.179 --> 00:28:02.529
因此，如果我们转到URL，那么我将

00:27:57.820 --> 00:28:04.509
我的本地机器在哪里或9090让我们看看

00:28:02.529 --> 00:28:08.139
我们的极端目的地来了我

00:28:04.509 --> 00:28:12.129
应该刚才说的这就是我的意思

00:28:08.139 --> 00:28:14.980
被作为摘要故事出售，所以这是

00:28:12.129 --> 00:28:22.179
只是您一项服务的结果

00:28:14.980 --> 00:28:26.999
 hanif要求推荐

00:28:22.179 --> 00:28:29.710
用户必须存放什么的存放区域

00:28:26.999 --> 00:28:32.919
这个国家只是给我们的用户

00:28:29.710 --> 00:28:37.090
一些结果，例如，我可以

00:28:32.919 --> 00:28:40.389
也要问一些具体的预测

00:28:37.090 --> 00:28:48.669
对于一个给定的目的地，所以我们需要

00:28:40.389 --> 00:28:53.470
给这里一个城市，这只是结果

00:28:48.669 --> 00:28:55.570
现在，我们来调用一个位置的

00:28:53.470 --> 00:28:58.259
传统旅行

00:28:55.570 --> 00:29:00.850
议事日程使用纯

00:28:58.259 --> 00:29:03.309
同步同步

00:29:00.850 --> 00:29:08.019
方法，所以我正在使用同步

00:29:03.309 --> 00:29:11.470
代理，我们很好地看到了

00:29:08.019 --> 00:29:13.210
好的时间，现在我们有了结果，所以

00:29:11.470 --> 00:29:15.580
这是由两个组成的结果

00:29:13.210 --> 00:29:17.999
正在使用多个位置

00:29:15.580 --> 00:29:20.919
服务，因此我们拥有所有的历史和

00:29:17.999 --> 00:29:23.409
我们有一套建议，您

00:29:20.919 --> 00:29:24.700
看到每个建议，我们都有

00:29:23.409 --> 00:29:26.110
不仅仅

00:29:24.700 --> 00:29:28.300
目的地，但我们会为您服务

00:29:26.110 --> 00:29:31.540
浇灌一些预报信息

00:29:28.300 --> 00:29:36.160
还有一些价格信息，我们有

00:29:31.540 --> 00:29:38.110
五倍有趣的是

00:29:36.160 --> 00:29:40.060
最后算出总数

00:29:38.110 --> 00:29:41.770
处理时间，我们看到

00:29:40.060 --> 00:29:44.470
装瓶方法来调用所有这些

00:29:41.770 --> 00:29:50.890
服务基本必要和时尚

00:29:44.470 --> 00:29:53.950
同样要花四秒钟以上

00:29:50.890 --> 00:29:59.350
方法，但这次使用

00:29:53.950 --> 00:30:01.300
异步API对象的出现-我们

00:29:59.350 --> 00:30:03.130
可以得到所有结果，我们看到了

00:30:01.300 --> 00:30:04.540
速度很快，所以我们拥有

00:30:03.130 --> 00:30:07.900
参观过的目的地，我们

00:30:04.540 --> 00:30:11.440
每次都有一套建议

00:30:07.900 --> 00:30:14.440
预测和定价信息以及

00:30:11.440 --> 00:30:18.430
处理时间不到一秒钟

00:30:14.440 --> 00:30:20.290
所以它真的更快，最后但不是

00:30:18.430 --> 00:30:24.130
至少让我们对

00:30:20.290 --> 00:30:26.140
 API，再次非常快

00:30:24.130 --> 00:30:28.630
所以我们将获得所有结果

00:30:26.140 --> 00:30:30.490
此目的地和过程状态

00:30:28.630 --> 00:30:33.280
使用压缩处理时间

00:30:30.490 --> 00:30:36.300
阶段基本上更多是相同的

00:30:33.280 --> 00:30:39.250
作为同步方法而与众不同

00:30:36.300 --> 00:30:41.950
这里的要点是

00:30:39.250 --> 00:30:44.410
您应该具有的性能和可伸缩性

00:30:41.950 --> 00:30:46.990
采取同步方法，然后你

00:30:44.410 --> 00:30:49.450
使用控制台有一个2选择标头

00:30:46.990 --> 00:30:53.710
作为同步API或使用

00:30:49.450 --> 00:30:55.630
反应式和发布API以及术语

00:30:53.710 --> 00:30:57.160
基本上可以得到的性能

00:30:55.630 --> 00:30:59.980
超过相同的性能，但

00:30:57.160 --> 00:31:02.710
显然，如果您之间有依赖性

00:30:59.980 --> 00:31:04.800
您的服务，这就是我们所拥有的

00:31:02.710 --> 00:31:06.390
例如这里

00:31:04.800 --> 00:31:08.760
调用

00:31:06.390 --> 00:31:12.030
列出清单之前的气象服务

00:31:08.760 --> 00:31:14.280
建议的目的地，如果您有

00:31:12.030 --> 00:31:16.230
然后您的服务之间的依赖

00:31:14.280 --> 00:31:20.270
您的代码将更容易使用

00:31:16.230 --> 00:31:20.270
使用反应式同步API 

00:31:28.130 --> 00:31:34.680
总而言之，我们有喷油器s2 

00:31:32.580 --> 00:31:37.860
有一个客户端API，我们可以用来

00:31:34.680 --> 00:31:39.540
轻松消耗剩余的远程端点

00:31:37.860 --> 00:31:41.730
有这个客户端容器

00:31:39.540 --> 00:31:44.010
基本上隐藏了很多复杂性

00:31:41.730 --> 00:31:47.970
对我们来说，这是我们的高级API 

00:31:44.010 --> 00:31:51.270
可以使用它有多个调用程序，它有一个

00:31:47.970 --> 00:31:53.130
同步行为就是你

00:31:51.270 --> 00:31:56.880
没有指定您将得到的调用者

00:31:53.130 --> 00:31:59.520
默认的调用者阻止了我们

00:31:56.880 --> 00:32:02.370
也有净同步调用者

00:31:59.520 --> 00:32:05.220
杰克的rs-24的一部分，你必须

00:32:02.370 --> 00:32:09.210
使用异步调用程序，您会在

00:32:05.220 --> 00:32:11.250
在某些情况下，即使遇到障碍

00:32:09.210 --> 00:32:15.000
我认为这是我的障碍，因为

00:32:11.250 --> 00:32:17.730
记住，我得到的未来可能只是

00:32:15.000 --> 00:32:19.740
阻止等待输入，所以如果我们

00:32:17.730 --> 00:32:21.390
想要绕过我们可以使用

00:32:19.740 --> 00:32:25.140
调用回调设施是

00:32:21.390 --> 00:32:27.120
杰克升为零的一部分，但我们

00:32:25.140 --> 00:32:29.310
通常当我们看到这样的局限性

00:32:27.120 --> 00:32:30.420
有多个服务要调用以及何时

00:32:29.310 --> 00:32:32.010
我们是

00:32:30.420 --> 00:32:35.460
我们在服务之间有依赖性

00:32:32.010 --> 00:32:38.430
所以写这样的书并不容易

00:32:35.460 --> 00:32:40.290
一个代码，所以这是

00:32:38.430 --> 00:32:43.710
在获得我们所做的解决方案中得到解决

00:32:40.290 --> 00:32:45.210
新的反应式调用者，即rx方法

00:32:43.710 --> 00:32:51.120
我们用来反应的

00:32:45.210 --> 00:32:54.870
调用者让我们讨论低端

00:32:51.120 --> 00:32:56.610
乳房暴露休息资源终点

00:32:54.870 --> 00:32:59.850
使用X射线，我们将不得不做

00:32:56.610 --> 00:33:02.130
像清单，我们有一堂课

00:32:59.850 --> 00:33:04.050
我们正在使用添加Pat的一些金属

00:33:02.130 --> 00:33:06.210
特定注释是受信任的

00:33:04.050 --> 00:33:09.750
还指定这是你写的

00:33:06.210 --> 00:33:12.210
对于该方法的所有资源

00:33:09.750 --> 00:33:14.250
然后我们在

00:33:12.210 --> 00:33:15.590
给出给定方法的说明

00:33:14.250 --> 00:33:17.270
子路径

00:33:15.590 --> 00:33:20.480
示例我也在使用路径参数

00:33:17.270 --> 00:33:22.130
那是由于时间和

00:33:20.480 --> 00:33:23.950
最终我在使用减少

00:33:22.130 --> 00:33:27.890
另外指定此特定

00:33:23.950 --> 00:33:30.980
剩余资源终点正在产生

00:33:27.890 --> 00:33:32.900
该特定媒体类型XML注释

00:33:30.980 --> 00:33:34.940
没有指定任何HTTP动词，因此

00:33:32.900 --> 00:33:37.820
表示我正在使用默认的

00:33:34.940 --> 00:33:41.289
这是得到的，如果你看到我有

00:33:37.820 --> 00:33:45.289
使用诸如post之类的不同动词的能力

00:33:41.289 --> 00:33:48.980
在这个例子中，在这种情况下，我的休息

00:33:45.289 --> 00:33:52.549
端点正在生成XML，并且它

00:33:48.980 --> 00:33:54.620
使用的XML还请注意，我正在使用

00:33:52.549 --> 00:33:56.899
一些特定的查询参数

00:33:54.620 --> 00:33:59.529
例子，所以这被称为对象

00:33:56.899 --> 00:34:03.409
我们一直在使用Tinder的范围

00:33:59.529 --> 00:34:05.029
现在注入上升，我们也有瑜伽士

00:34:03.409 --> 00:34:09.619
上的同步能力

00:34:05.029 --> 00:34:10.879
服务价值，所以它像这样工作

00:34:09.619 --> 00:34:13.220
我们逮捕了杰克

00:34:10.879 --> 00:34:16.609
方法并注意，我们正在注入

00:34:13.220 --> 00:34:17.510
使用Ab暂停动画

00:34:16.609 --> 00:34:22.419
新对象

00:34:17.510 --> 00:34:26.240
没有反应也注意到

00:34:22.419 --> 00:34:30.940
方法是返回无效的，所以它不会

00:34:26.240 --> 00:34:34.580
返回任何东西，所以我们现在有了这些

00:34:30.940 --> 00:34:37.970
 Sexers回应，我们基本上可以

00:34:34.580 --> 00:34:41.109
用于基本执行请求

00:34:37.970 --> 00:34:41.109
在不同的线程中处理

00:34:41.560 --> 00:34:46.120
所以我在这里说的是

00:34:44.260 --> 00:34:48.669
我在Java环境中，因此我正在使用

00:34:46.120 --> 00:34:51.970
磁性纹理服务开始

00:34:48.669 --> 00:34:54.159
我会在该线程中创建新线程

00:34:51.970 --> 00:34:56.679
我可能会非常

00:34:54.159 --> 00:34:59.650
这种资源很昂贵，所以我

00:34:56.679 --> 00:35:01.690
有一个外部线程，我正在运行一些

00:34:59.650 --> 00:35:03.910
非常长时间运行的计算，然后

00:35:01.690 --> 00:35:06.040
有一个我的沉沦反应主题

00:35:03.910 --> 00:35:10.030
可以在我的外部线程中使用

00:35:06.040 --> 00:35:14.740
基本上恢复了原来的线程

00:35:10.030 --> 00:35:16.630
处理所有传入请求

00:35:14.740 --> 00:35:19.330
使用此分析完成

00:35:16.630 --> 00:35:21.130
该方法给出的响应对象

00:35:19.330 --> 00:35:24.760
执行业务的能力

00:35:21.130 --> 00:35:26.260
逻辑在不同的线程中

00:35:24.760 --> 00:35:27.970
值得一提的是

00:35:26.260 --> 00:35:31.690
底层I / O线程仍在阻塞

00:35:27.970 --> 00:35:36.070
所以这意味着我的客户仍然

00:35:31.690 --> 00:35:38.170
直到我认为回应被封锁

00:35:36.070 --> 00:35:39.970
视频这在两边都是对的

00:35:38.170 --> 00:35:44.830
连接服务器上的连接

00:35:39.970 --> 00:35:47.530
方面，在客户端，我们有

00:35:44.830 --> 00:35:49.270
现在提供新的Vasek响应

00:35:47.530 --> 00:35:50.680
它们用于同步服务器端或

00:35:49.270 --> 00:35:53.200
响应处理，所以我们有

00:35:50.680 --> 00:35:55.960
处理能力

00:35:53.200 --> 00:36:00.730
在不同的线程中响应

00:35:55.960 --> 00:36:04.240
创建使用这个新的注入

00:36:00.730 --> 00:36:07.030
扩展注释，我们有

00:36:04.240 --> 00:36:11.200
我认为有不同的工作方式

00:36:07.030 --> 00:36:13.570
响应对象，因此通常我们注入

00:36:11.200 --> 00:36:16.270
正确的同步响应，所以我们基本上

00:36:13.570 --> 00:36:18.160
暂停我们要处理的线程

00:36:16.270 --> 00:36:20.710
在不同的线程中

00:36:18.160 --> 00:36:22.870
一旦某个时候，我们在不同的线程

00:36:20.710 --> 00:36:25.780
有结果，我们将继续

00:36:22.870 --> 00:36:28.630
请求的反应，所以基本上我们

00:36:25.780 --> 00:36:31.000
将不得不发送结果

00:36:28.630 --> 00:36:33.690
回复客户，我们也可以

00:36:31.000 --> 00:36:36.910
取消请求我们也可以配置

00:36:33.690 --> 00:36:39.610
请求设置一些超时等等

00:36:36.910 --> 00:36:41.530
关键是关键

00:36:39.610 --> 00:36:44.880
请记住，重要的是

00:36:41.530 --> 00:36:47.620
基础线程仍在阻塞，并且

00:36:44.880 --> 00:36:50.080
它将被阻止直到阻力

00:36:47.620 --> 00:36:52.000
被发送到客户端，并且

00:36:50.080 --> 00:36:54.510
客户端将阻止，直到它具有

00:36:52.000 --> 00:36:58.650
反应，这是一个关键方面

00:36:54.510 --> 00:37:01.710
要记住，所以如果我们尝试看看

00:36:58.650 --> 00:37:04.440
一个基本的架构会很大

00:37:01.710 --> 00:37:06.660
会工作，我们有一个孩子， 

00:37:04.440 --> 00:37:08.480
在南侧发出请求

00:37:06.660 --> 00:37:10.800
有我们的捷克特雷斯

00:37:08.480 --> 00:37:14.100
可以处理请求的容器

00:37:10.800 --> 00:37:16.680
然后在连接的两侧

00:37:14.100 --> 00:37:18.210
 IO踏板被阻塞，因此

00:37:16.680 --> 00:37:22.290
表示在服务器端的ioad 

00:37:18.210 --> 00:37:22.830
我的克莱德橘黄色的线是

00:37:22.290 --> 00:37:25.620
已锁定

00:37:22.830 --> 00:37:28.610
所以我杰克的rest应用程序正在运行

00:37:25.620 --> 00:37:33.000
在某个时间点之一

00:37:28.610 --> 00:37:37.770
沮丧的方法基本上会暂停

00:37:33.000 --> 00:37:42.060
通过注入暂停请求

00:37:37.770 --> 00:37:45.840
我认为我们现在有了回应对象

00:37:42.060 --> 00:37:47.580
进行处理的能力

00:37:45.840 --> 00:37:50.550
获得那些响应的业务逻辑

00:37:47.580 --> 00:37:52.980
在不同的线程中，所以通常

00:37:50.550 --> 00:37:55.410
在Java环境中，我们使用

00:37:52.980 --> 00:37:59.060
托管灯具服务，然后

00:37:55.410 --> 00:38:01.830
摘录就是一个例子

00:37:59.060 --> 00:38:05.460
可从外部获得的结果

00:38:01.830 --> 00:38:07.860
线程，我们将使用结果抱歉

00:38:05.460 --> 00:38:11.610
简历，基本上将其发送给

00:38:07.860 --> 00:38:13.680
直到客户端被锁定为止

00:38:11.610 --> 00:38:16.140
和服务器小时的I / O线程大约

00:38:13.680 --> 00:38:19.380
所以我们调用了我认为响应简历

00:38:16.140 --> 00:38:24.420
以后基本上恢复执行

00:38:19.380 --> 00:38:26.520
响应和Jersey容器

00:38:24.420 --> 00:38:29.580
现在可以将响应发送回

00:38:26.520 --> 00:38:30.390
客户，直到那个孩子

00:38:29.580 --> 00:38:33.150
受阻

00:38:30.390 --> 00:38:35.430
现在客户有了响应

00:38:33.150 --> 00:38:40.740
准备就绪不再受阻，因此可以

00:38:35.430 --> 00:38:42.870
继续工作做一些我们

00:38:40.740 --> 00:38:44.790
通常在服务器端使用

00:38:42.870 --> 00:38:47.880
一种我们长期运行的休息手术

00:38:44.790 --> 00:38:50.730
所以它像这样工作，所以我们做一个帖子

00:38:47.880 --> 00:38:53.190
请求一些长时间运行的操作

00:38:50.730 --> 00:38:56.850
发生，然后在某个时间点，我们

00:38:53.190 --> 00:38:58.710
发送回复给客户，所以我们

00:38:56.850 --> 00:39:00.780
将通过发送201 

00:38:58.710 --> 00:39:03.660
正在创建的资源， 

00:39:00.780 --> 00:39:05.880
资源的位置现在我们

00:39:03.660 --> 00:39:07.530
可能想要使用其他模式

00:39:05.880 --> 00:39:11.010
解决

00:39:07.530 --> 00:39:14.280
测试用例，所以我们首先使用相同的方法

00:39:11.010 --> 00:39:17.090
当前将发布请求，然后

00:39:14.280 --> 00:39:20.190
服务器将直接回答

00:39:17.090 --> 00:39:22.860
 202这基本上意味着我已经

00:39:20.190 --> 00:39:25.500
接受redzone资源

00:39:22.860 --> 00:39:27.270
创作，但我知道这需要时间

00:39:25.500 --> 00:39:29.130
这将做什么会告诉

00:39:27.270 --> 00:39:30.870
客户端好，我现在将致力于创建

00:39:29.130 --> 00:39:33.060
这些资源，但我知道它将

00:39:30.870 --> 00:39:37.140
需要时间，请稍后再返回

00:39:33.060 --> 00:39:39.330
看看服务器什么时候完成

00:39:37.140 --> 00:39:41.160
还会发送一些临时

00:39:39.330 --> 00:39:43.230
客户可以用来获取的位置

00:39:41.160 --> 00:39:46.770
通过键或状态

00:39:43.230 --> 00:39:49.470
资源创建，这意味着

00:39:46.770 --> 00:39:53.580
不能慈善地针对

00:39:49.470 --> 00:39:55.470
该临时或资源使用

00:39:53.580 --> 00:39:58.800
被发送回的并发症

00:39:55.470 --> 00:40:01.320
他，然后服务器将回答

00:39:58.800 --> 00:40:03.590
大概是200左右

00:40:01.320 --> 00:40:05.850
这是有效的临时资源， 

00:40:03.590 --> 00:40:09.630
残疾人也有能力增加

00:40:05.850 --> 00:40:11.160
其他详细信息，例如我

00:40:09.630 --> 00:40:14.130
一起期待资源

00:40:11.160 --> 00:40:16.410
在接下来的20秒内可用

00:40:14.130 --> 00:40:18.990
基本上会给

00:40:16.410 --> 00:40:22.800
客户何时可以期望

00:40:18.990 --> 00:40:26.130
资源使其可用

00:40:22.800 --> 00:40:28.680
那只有时间的罐子会做一个

00:40:26.130 --> 00:40:32.100
针对同一临时工的要求

00:40:28.680 --> 00:40:36.000
位置以及是否已创建

00:40:32.100 --> 00:40:39.450
服务器，以便其余服务器端点

00:40:36.000 --> 00:40:41.850
发出3和3的所有把戏

00:40:39.450 --> 00:40:45.240
 C领所以哥们进来了

00:40:41.850 --> 00:40:49.170
请求已创建，这是一个

00:40:45.240 --> 00:40:51.570
基本上曾经重定向到新数组

00:40:49.170 --> 00:40:54.780
已创建的资源

00:40:51.570 --> 00:40:58.080
在帖子之后，以便回复

00:40:54.780 --> 00:41:00.300
不仅包括303 

00:40:58.080 --> 00:41:02.160
重定向，但也的位置

00:41:00.300 --> 00:41:03.600
资源的最终位置

00:41:02.160 --> 00:41:06.210
在第一个中创建的

00:41:03.600 --> 00:41:08.610
的地方，所以这是我们要

00:41:06.210 --> 00:41:11.910
使用一个我们长期运行的操作

00:41:08.610 --> 00:41:14.190
这是显示的流行模式

00:41:11.910 --> 00:41:16.980
这样的话，基本上可以避免

00:41:14.190 --> 00:41:20.160
客户必须等待

00:41:16.980 --> 00:41:23.690
在很多资源的情况下

00:41:20.160 --> 00:41:23.690
在服务器上分级的时间

00:41:24.140 --> 00:41:28.259
现在让我们谈论一些

00:41:26.640 --> 00:41:31.470
在特定用途中可能会有用

00:41:28.259 --> 00:41:33.450
案例，茶水服务和活动，因此ICC 

00:41:31.470 --> 00:41:36.299
是一种广泛使用的机制

00:41:33.450 --> 00:41:38.519
主要用于从

00:41:36.299 --> 00:41:39.690
服务器端到连接的客户端，这是

00:41:38.519 --> 00:41:42.509
被广泛使用的东西

00:41:39.690 --> 00:41:44.670
网络上有一个明确定义的标准

00:41:42.509 --> 00:41:46.140
那只是一种方式

00:41:44.670 --> 00:41:48.900
所以这意味着不能建立

00:41:46.140 --> 00:41:50.910
一旦连接是

00:41:48.900 --> 00:41:54.210
建立服务器已导致

00:41:50.910 --> 00:41:56.549
从服务器推送一些负载到

00:41:54.210 --> 00:41:58.980
该连接的客户端，以便客户端具有

00:41:56.549 --> 00:42:00.480
无法从

00:41:58.980 --> 00:42:01.849
客户端到服务器，这真的是一个

00:42:00.480 --> 00:42:04.140
仅方式

00:42:01.849 --> 00:42:07.170
但我们通常可以使用

00:42:04.140 --> 00:42:08.880
允许服务器发送的机制

00:42:07.170 --> 00:42:12.299
通知工厂

00:42:08.880 --> 00:42:16.619
长时间运行的操作的示例

00:42:12.299 --> 00:42:18.269
这样做是因为我看到了

00:42:16.619 --> 00:42:20.819
添加到弹出或s21 

00:42:18.269 --> 00:42:22.829
所以jax-ur是他们真正的

00:42:20.819 --> 00:42:25.140
引入不同的新对象，例如

00:42:22.829 --> 00:42:27.450
骚动事件，因此当此事件为身体时

00:42:25.140 --> 00:42:30.599
在职演示文稿的剪辑和

00:42:27.450 --> 00:42:34.019
如果它是一个超级接口

00:42:30.599 --> 00:42:36.329
一方面通过两个接口扩展

00:42:34.019 --> 00:42:38.640
有出站ACC事件是

00:42:36.329 --> 00:42:41.279
 SS事件的自我表示

00:42:38.640 --> 00:42:43.920
另一方面，我们有入站

00:42:41.279 --> 00:42:47.609
 SEC事件是客户端的视图

00:42:43.920 --> 00:42:50.339
服务器发送事件，因此在服务器上

00:42:47.609 --> 00:42:52.170
方面，我们带领创建活动

00:42:50.339 --> 00:42:55.019
客户端，我们没有

00:42:52.170 --> 00:42:56.759
再次创建事件的能力是

00:42:55.019 --> 00:42:59.279
只有这样，在客户端，我们

00:42:56.759 --> 00:43:04.170
只是消耗服务器发送的事件

00:42:59.279 --> 00:43:06.210
服务器已推送的

00:43:04.170 --> 00:43:08.519
我们在查看API的同时

00:43:06.210 --> 00:43:12.089
新上交所甚至认为对象是

00:43:08.519 --> 00:43:14.730
基本上是服务器之间的连接

00:43:12.089 --> 00:43:16.950
和一个客户

00:43:14.730 --> 00:43:19.739
餐厅点，用来

00:43:16.950 --> 00:43:25.440
字符串SS事件，所以这基本上是

00:43:19.739 --> 00:43:28.410
与SSE连接的服务器侧视图

00:43:25.440 --> 00:43:30.780
 API使我们可以分组

00:43:28.410 --> 00:43:33.360
多个连接或多个资产

00:43:30.780 --> 00:43:35.940
甚至一个物体中的东西

00:43:33.360 --> 00:43:38.370
广播公司和SEC广播公司以及

00:43:35.940 --> 00:43:41.160
想法是伊丽莎白章只是

00:43:38.370 --> 00:43:42.930
连接种类的集合，所以如果你

00:43:41.160 --> 00:43:44.880
正在将有效载荷推入ACC 

00:43:42.930 --> 00:43:49.080
广播公司将能够神奇地

00:43:44.880 --> 00:43:51.570
如果您推送到所有连接的客户端

00:43:49.080 --> 00:43:53.850
看看我们使用CC的智慧作品

00:43:51.570 --> 00:43:57.000
 API，您好，我们看到它非常

00:43:53.850 --> 00:44:00.030
很简单，所以我们注入了这种方法

00:43:57.000 --> 00:44:02.310
反对第一个，所以这是一个

00:44:00.030 --> 00:44:04.950
服务器端您在服务器上

00:44:02.310 --> 00:44:06.870
注入SS甚至是

00:44:04.950 --> 00:44:10.530
服务器与服务器之间的连接

00:44:06.870 --> 00:44:12.750
趋势，我们也在注入上证所

00:44:10.530 --> 00:44:14.550
方便的对象

00:44:12.750 --> 00:44:18.180
我们可以使用例如轻松创建

00:44:14.550 --> 00:44:20.640
 SS事件，那么所有要做的就是

00:44:18.180 --> 00:44:23.580
基本上利用现有的jax-rs 

00:44:20.640 --> 00:44:26.790
注解，所以我们使用pad get 

00:44:23.580 --> 00:44:30.450
在这种特殊情况下，我们的注释

00:44:26.790 --> 00:44:33.600
 sse端点将使用

00:44:30.450 --> 00:44:35.670
 SSE端点，它产生了

00:44:33.600 --> 00:44:42.540
特定媒体类型的服务和事件

00:44:35.670 --> 00:44:44.250
媒体类型，然后我们的方法做点什么

00:44:42.540 --> 00:44:47.520
显然在分班时

00:44:44.250 --> 00:44:50.330
期望将一些有效载荷推向

00:44:47.520 --> 00:44:52.530
例如趋势告诉时间

00:44:50.330 --> 00:44:55.770
 -非常流鼻涕

00:44:52.530 --> 00:44:57.810
 -现在可以进行长时间运行的操作

00:44:55.770 --> 00:45:02.310
当前可以获取实际

00:44:57.810 --> 00:45:04.320
冷漠地给予资源和去做

00:45:02.310 --> 00:45:07.020
我们只需要调用发送

00:45:04.320 --> 00:45:09.080
连接对象上的方法

00:45:07.020 --> 00:45:12.330
在这种情况下，即使国王点一个和

00:45:09.080 --> 00:45:14.760
显然，我们必须发送一些实际的

00:45:12.330 --> 00:45:18.720
有效负载，因此我们正在创建一个

00:45:14.760 --> 00:45:21.900
事件，我们可以使用SSC对象

00:45:18.720 --> 00:45:24.990
有给我们捷径和精力

00:45:21.900 --> 00:45:27.930
创建一些我们可以做的SS事件的方法

00:45:24.990 --> 00:45:30.060
根据需要多次

00:45:27.930 --> 00:45:31.800
我们应用程序的业务逻辑

00:45:30.060 --> 00:45:33.870
这里的ID是要发送的

00:45:31.800 --> 00:45:36.240
通知连接的客户端

00:45:33.870 --> 00:45:38.780
指定特定于运行

00:45:36.240 --> 00:45:40.910
操作完成

00:45:38.780 --> 00:45:44.600
如果在某个时间点喝茶，我们

00:45:40.910 --> 00:45:48.640
将不得不关闭该SEC连接

00:45:44.600 --> 00:45:51.230
如果我们看看客户端，现在反对

00:45:48.640 --> 00:45:53.690
我们还有一个正在处理的对象

00:45:51.230 --> 00:45:55.400
连接，但现在来自客户端

00:45:53.690 --> 00:45:58.490
到服务器，因此称为

00:45:55.400 --> 00:46:00.530
消耗的第七个来源是此事件

00:45:58.490 --> 00:46:05.600
在客户端，我们正在使用JAXA 

00:46:00.530 --> 00:46:07.070
上升到一个通道侧API，我们需要

00:46:05.600 --> 00:46:08.990
首先创建一个连接

00:46:07.070 --> 00:46:11.570
事件源，我们将单词free source设置为

00:46:08.990 --> 00:46:13.670
我们在终点的目标

00:46:11.570 --> 00:46:15.740
配置该连接的能力

00:46:13.670 --> 00:46:18.470
因此，在此示例中，我们将

00:46:15.740 --> 00:46:21.770
重新连接间隔为五秒，然后

00:46:18.470 --> 00:46:23.180
等等，我们看到我们需要确保

00:46:21.770 --> 00:46:25.100
我们实际上涉及

00:46:23.180 --> 00:46:27.800
调用build方法来实际

00:46:25.100 --> 00:46:31.760
转换那个对象，所以我们现在有了

00:46:27.800 --> 00:46:34.040
连接我们接下来要做的是

00:46:31.760 --> 00:46:35.810
首先注册一些回调

00:46:34.040 --> 00:46:38.510
我正在此注册的回调

00:46:35.810 --> 00:46:41.120
例如在孟加拉国甚至一个消费者

00:46:38.510 --> 00:46:44.510
所以我们基本上是消费者

00:46:41.120 --> 00:46:46.430
在此示例中使用传入事件

00:46:44.510 --> 00:46:49.700
我的消费者所做的唯一一件事

00:46:46.430 --> 00:46:51.140
只是打印像豆一样的东西，我有

00:46:49.700 --> 00:46:53.420
注册不同的能力

00:46:51.140 --> 00:46:55.280
消费者，例如我可以注册一个

00:46:53.420 --> 00:46:59.000
将要调用的旅行消费者

00:46:55.280 --> 00:47:01.460
出问题了，最后我

00:46:59.000 --> 00:47:05.240
需要做的是调用open方法

00:47:01.460 --> 00:47:07.430
在SS事件等方面

00:47:05.240 --> 00:47:10.580
本身，这基本上就是我告诉的地方

00:47:07.430 --> 00:47:12.620
我想要我的客户端的容器

00:47:10.580 --> 00:47:15.200
建立与之连接的容器

00:47:12.620 --> 00:47:16.940
我的远程决策点和

00:47:15.200 --> 00:47:19.520
客户端容器将容器

00:47:16.940 --> 00:47:21.020
为我做所有繁重的工作

00:47:19.520 --> 00:47:24.590
将建立连接，它将

00:47:21.020 --> 00:47:26.390
还注册回调等等

00:47:24.590 --> 00:47:29.090
建立连接后， 

00:47:26.390 --> 00:47:31.610
任何时候从发送一些有效载荷

00:47:29.090 --> 00:47:33.140
服务器到客户端我的入站

00:47:31.610 --> 00:47:36.530
决定甚至消费者

00:47:33.140 --> 00:47:38.390
自动为我调用，如果您

00:47:36.530 --> 00:47:41.780
看到一旦我完成，我需要确保

00:47:38.390 --> 00:47:45.290
我实际上关闭了我的客户ID 

00:47:41.780 --> 00:47:47.240
连接，因此ID要么是

00:47:45.290 --> 00:47:50.600
杰克逮捕了一名状态报告人

00:47:47.240 --> 00:47:53.690
这可能会有用

00:47:50.600 --> 00:48:00.050
我说她支持我们

00:47:53.690 --> 00:48:01.720
南侧运行时间更长

00:48:00.050 --> 00:48:06.550
火箭

00:48:01.720 --> 00:48:06.550
所以今天我们讨论了jax-rs 

00:48:07.020 --> 00:48:10.530
基本上我们已经谈论过Jax 

00:48:08.610 --> 00:48:12.330
主要关于Jax升至零

00:48:10.530 --> 00:48:14.430
这是当前版本

00:48:12.330 --> 00:48:16.590
规范，它是设备七的一部分

00:48:14.430 --> 00:48:19.080
但我们也可以仅用于

00:48:16.590 --> 00:48:22.070
嫉妒，我们也讨论了一些

00:48:19.080 --> 00:48:24.690
这些X射线的一种新功能

00:48:22.070 --> 00:48:28.890
那是Java的一部分

00:48:24.690 --> 00:48:30.840
它们可以在Java C中使用，所以

00:48:28.890 --> 00:48:32.970
两种能力两种新能力

00:48:30.840 --> 00:48:34.770
我们已经讨论过的是新的

00:48:32.970 --> 00:48:37.440
同步活动帐户API或

00:48:34.770 --> 00:48:41.760
 Jax rs21以及

00:48:37.440 --> 00:48:45.120
该报告，因此jax-rs是标准基础

00:48:41.760 --> 00:48:46.650
宁静的框架，它支持

00:48:45.120 --> 00:48:49.890
最初的服务站点和

00:48:46.650 --> 00:48:53.280
单访问我们已添加了支持

00:48:49.890 --> 00:48:56.550
适用于标准的客户端API 

00:48:53.280 --> 00:48:58.560
事实是您基本上可以

00:48:56.550 --> 00:49:01.590
选择您是哪种实现

00:48:58.560 --> 00:49:04.170
今天使用了球衣，但我

00:49:01.590 --> 00:49:06.770
表示您采用该代码，并且在逻辑上

00:49:04.170 --> 00:49:10.770
适用于任何标准检查器

00:49:06.770 --> 00:49:12.390
在客户端实施

00:49:10.770 --> 00:49:13.890
已经讨论了客户端容器

00:49:12.390 --> 00:49:16.110
基本上完成了所有繁重的工作

00:49:13.890 --> 00:49:20.130
对我们来说，它提供了一个非常高级的

00:49:16.110 --> 00:49:22.890
简单易用的API消耗休息时间

00:49:20.130 --> 00:49:25.440
端点具有三个调用程序注入器

00:49:22.890 --> 00:49:27.150
眼睛-喷油器2.0我们有一个

00:49:25.440 --> 00:49:29.790
同步能力是

00:49:27.150 --> 00:49:33.180
在默认调用者中，我们也有默认

00:49:29.790 --> 00:49:34.770
同步调用者和注入器

00:49:33.180 --> 00:49:37.580
行动一个，我们有一个浴缸

00:49:34.770 --> 00:49:40.410
同步反应调用程序和

00:49:37.580 --> 00:49:44.280
通常您会使用该反应式

00:49:40.410 --> 00:49:46.800
当您有多个服务时调用

00:49:44.280 --> 00:49:49.170
需要被调用并想知道

00:49:46.800 --> 00:49:51.570
这些远程服务之间的依赖性

00:49:49.170 --> 00:49:53.400
在性能方面，我认为

00:49:51.570 --> 00:49:56.250
可以说，纯净的

00:49:53.400 --> 00:49:59.130
同步调用方反向速度一样快

00:49:56.250 --> 00:50:01.230
作为同步反应调用者

00:49:59.130 --> 00:50:04.280
所以只有当你有

00:50:01.230 --> 00:50:06.960
服务之间的依赖关系

00:50:04.280 --> 00:50:10.470
你真的需要看看新的

00:50:06.960 --> 00:50:12.680
将成为Jax一部分的调用者

00:50:10.470 --> 00:50:12.680
一

00:50:15.030 --> 00:50:22.590
使用Java ec8的反应式调用程序

00:50:18.750 --> 00:50:25.140
完成状态API，这是强制性的

00:50:22.590 --> 00:50:28.020
每三项检查第一个规格

00:50:25.140 --> 00:50:30.390
但它说我们也认识到

00:50:28.020 --> 00:50:34.080
已经有实际的解决方案

00:50:30.390 --> 00:50:37.380
那里的规范是开放的

00:50:34.080 --> 00:50:41.340
顽强的党整改工程，因此

00:50:37.380 --> 00:50:44.160
示例Georgi对arocs Java的支持

00:50:41.340 --> 00:50:47.430
我会去和合理的功能

00:50:44.160 --> 00:50:48.750
来自番石榴，唯一的是

00:50:47.430 --> 00:50:50.580
授权是对

00:50:48.750 --> 00:50:52.620
压缩阶段api，它将达到

00:50:50.580 --> 00:50:54.810
实施决定哪一个

00:50:52.620 --> 00:50:58.980
他们将要使用的其他框架

00:50:54.810 --> 00:51:02.430
首先我们讨论过杰克的支持

00:50:58.980 --> 00:51:04.740
服务器端，所以我们看到了这个Java 

00:51:02.430 --> 00:51:06.510
能力，这增加了ins 

00:51:04.740 --> 00:51:09.090
联合喷油器的能力

00:51:06.510 --> 00:51:11.730
基本上可以恢复

00:51:09.090 --> 00:51:15.210
来自一个请求处理的位置

00:51:11.730 --> 00:51:18.030
不同的部落，我们也讨论父母

00:51:15.210 --> 00:51:21.150
用于长时间运行

00:51:18.030 --> 00:51:23.310
避免客户端阻塞

00:51:21.150 --> 00:51:25.320
很长一段时间，终于我们有了

00:51:23.310 --> 00:51:28.370
讨论了我们的服务事件

00:51:25.320 --> 00:51:32.180
杰克休息的一部分可能会有用

00:51:28.370 --> 00:51:32.180
使用该模式时

00:51:33.090 --> 00:51:37.080
演讲的重点是

00:51:34.710 --> 00:51:38.700
拒绝逮捕-我们还有

00:51:37.080 --> 00:51:41.820
讨论了一些技术对象

00:51:38.700 --> 00:51:44.640
升至Java 8的1，但

00:51:41.820 --> 00:51:46.890
 Java 8实际上比这更广泛

00:51:44.640 --> 00:51:49.470
例如月亮果冻，但我们有

00:51:46.890 --> 00:51:52.860
支持HTTP的API的色拉

00:51:49.470 --> 00:51:55.200
 2我们有一个新的绑定API 

00:51:52.860 --> 00:51:58.050
 Java对象的混搭和聚集

00:51:55.200 --> 00:52:01.200
从JSON文档中我们是CDI 2 

00:51:58.050 --> 00:52:03.210
具有同步偶数功能

00:52:01.200 --> 00:52:07.200
这可能是非常

00:52:03.210 --> 00:52:10.680
很好地用于对象上升到埃里克的

00:52:07.200 --> 00:52:13.680
 API甚至具有CDI的同步功能

00:52:10.680 --> 00:52:16.800
也支持压缩阶段API 

00:52:13.680 --> 00:52:19.880
 7月8日，依此类推，等等

00:52:16.800 --> 00:52:23.220
 7月8日确实有很多新东西

00:52:19.880 --> 00:52:24.840
 7月8日是关于

00:52:23.220 --> 00:52:27.260
平台和简化

00:52:24.840 --> 00:52:31.650
平台，这确实正在进行中

00:52:27.260 --> 00:52:36.230
目标是最终确定Java 8 

00:52:31.650 --> 00:52:38.100
夏天我们有开源

00:52:36.230 --> 00:52:40.020
 Java的实现，这是

00:52:38.100 --> 00:52:42.120
 GlassFish 5即将完成

00:52:40.020 --> 00:52:44.220
在那之后不久，但与此同时

00:52:42.120 --> 00:52:46.140
您已经可以访问

00:52:44.220 --> 00:52:48.570
不同的Java 8参考

00:52:46.140 --> 00:52:52.890
像GlassFish这样的实现，但也

00:52:48.570 --> 00:52:55.020
泽西岛和其他地区，所以我认为今天

00:52:52.890 --> 00:52:57.890
您已经可以使用该API 

00:52:55.020 --> 00:53:01.560
将成为Java 8的一部分，包括jax-rs 

00:52:57.890 --> 00:53:03.330
 2.1，实际上我们最近已经搬迁了

00:53:01.560 --> 00:53:06.420
所有Java开发以及最后

00:53:03.330 --> 00:53:09.960
从java.net获得的少量开发

00:53:06.420 --> 00:53:13.410
所以就去github.com抱歉

00:53:09.960 --> 00:53:15.060
您将可以查看

00:53:13.410 --> 00:53:18.120
不同的规格是

00:53:15.060 --> 00:53:22.260
有些已经完成，有些已经

00:53:18.120 --> 00:53:24.120
以草稿形式，因此您已经可以

00:53:22.260 --> 00:53:26.070
可以访问并且很高兴

00:53:24.120 --> 00:53:28.170
引用实现和ID 

00:53:26.070 --> 00:53:33.110
我们希望得到您的反馈

00:53:28.170 --> 00:53:33.110
在夏季决赛之前

00:53:33.440 --> 00:53:37.730
所以我

00:53:35.000 --> 00:53:40.790
用一些资源总结一下

00:53:37.730 --> 00:53:42.350
可能想检查以了解更多信息

00:53:40.790 --> 00:53:43.940
进一步了解

00:53:42.350 --> 00:53:46.940
第一个是检查苏拉

00:53:43.940 --> 00:53:48.800
规范，我也鼓励您

00:53:46.940 --> 00:53:51.200
检查不同的例子，但我们

00:53:48.800 --> 00:53:55.280
在github仓库中的部分

00:53:51.200 --> 00:53:57.620
您可能想要的jax-rs Whipple存储库

00:53:55.280 --> 00:54:01.670
检查球衣文件

00:53:57.620 --> 00:54:05.500
有很多关于

00:54:01.670 --> 00:54:05.500
同步功能对象数组

00:54:06.630 --> 00:54:12.520
所以我们现在以一个问题结束

00:54:10.390 --> 00:54:17.820
回答，所以请随时提出

00:54:12.520 --> 00:54:17.820
问题，我们将回答他们，谢谢

00:54:23.140 --> 00:54:25.200
您

