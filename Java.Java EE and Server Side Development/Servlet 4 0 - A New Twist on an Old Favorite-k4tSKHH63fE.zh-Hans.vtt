WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.120 --> 00:00:12.680
大家好，欢迎来到服务器图片

00:00:06.600 --> 00:00:12.680
哦，一棵新树，众人宠爱

00:00:12.990 --> 00:00:23.320
这是我不会的标准狡猾

00:00:16.900 --> 00:00:27.040
说说这个，我是青海昌

00:00:23.320 --> 00:00:30.160
这样3.1和照片哦，教练我很糟糕

00:00:27.040 --> 00:00:32.560
还在南方选择三个

00:00:30.160 --> 00:00:38.860
彻底的实施和安全

00:00:32.560 --> 00:00:40.270
 jsr JCCC和jasp我会在

00:00:38.860 --> 00:00:43.030
介绍自己

00:00:40.270 --> 00:00:44.500
好吧，我知道我以爱德·伯恩斯的名字

00:00:43.030 --> 00:00:46.660
我很高兴来到这里

00:00:44.500 --> 00:00:49.600
鉴于servlet可以进行交谈

00:00:46.660 --> 00:00:52.030
多年的Java试图获得

00:00:49.600 --> 00:00:53.679
尊重您的servlet和Java EE 

00:00:52.030 --> 00:00:58.320
八个SPECT已经很长了

00:00:53.679 --> 00:01:00.309
技术业务和

00:00:58.320 --> 00:01:04.480
组织原因，但我们很高兴

00:01:00.309 --> 00:01:07.750
最终完成它，我们认为

00:01:04.480 --> 00:01:09.610
规范中有很多很棒的东西

00:01:07.750 --> 00:01:11.830
只是生存而已

00:01:09.610 --> 00:01:13.240
我希望今天能说服你

00:01:11.830 --> 00:01:15.370
炫耀为什么，我希望说服您

00:01:13.240 --> 00:01:17.079
今天我认为这是为了

00:01:15.370 --> 00:01:17.409
自动前进就是我正在做的事情

00:01:17.079 --> 00:01:21.780
这里

00:01:17.409 --> 00:01:24.930
嗯，嗯，必须把它修好

00:01:21.780 --> 00:01:31.170
是的，我必须坚持

00:01:24.930 --> 00:01:34.920
那是可怕的幻灯片设置显示

00:01:31.170 --> 00:01:34.920
这就是为什么这样做

00:01:35.700 --> 00:01:42.990
从当前手动播放

00:01:40.420 --> 00:01:46.690
对此感到抱歉

00:01:42.990 --> 00:01:49.570
所以我一直在做规范JSF 

00:01:46.690 --> 00:01:50.830
和servlet期待潜在客户，并且

00:01:49.570 --> 00:01:53.200
许多专家小组成员

00:01:50.830 --> 00:01:55.570
不同的规格写了几本书

00:01:53.200 --> 00:01:59.520
 Java和很多会议

00:01:55.570 --> 00:02:02.080
谈论这个话题，并与

00:01:59.520 --> 00:02:03.160
 Eclipse Foundation和

00:02:02.080 --> 00:02:04.450
移交Eclipse Foundation 

00:02:03.160 --> 00:02:07.539
您将有很多细节

00:02:04.450 --> 00:02:09.759
希望以后还能做

00:02:07.539 --> 00:02:14.320
但是与任何人合作

00:02:09.759 --> 00:02:15.730
在社区上努力工作

00:02:14.320 --> 00:02:17.739
我们有很多的要谈的话题

00:02:15.730 --> 00:02:20.950
选择，我很荣幸您

00:02:17.739 --> 00:02:24.459
选择了我们的，我想做到这一点

00:02:20.950 --> 00:02:26.560
值得您花些时间的投资

00:02:24.459 --> 00:02:28.470
当代的高级内容

00:02:26.560 --> 00:02:31.540
 servlet的历史地位

00:02:28.470 --> 00:02:33.340
特别是微服务

00:02:31.540 --> 00:02:35.380
观点和历史微观

00:02:33.340 --> 00:02:38.440
服务的观点

00:02:35.380 --> 00:02:40.920
谈话的重点主要是shewag 

00:02:38.440 --> 00:02:43.360
提供新功能，而不是四个

00:02:40.920 --> 00:02:46.320
然后我们将有一些东西

00:02:43.360 --> 00:02:48.940
打开Java EE，然后进行总结

00:02:46.320 --> 00:02:50.680
活着，只有我们只有45 

00:02:48.940 --> 00:02:51.700
今天我们会议的时间

00:02:50.680 --> 00:02:53.590
知道我们是否有时间提问

00:02:51.700 --> 00:02:56.350
但是我会在黑客花园里

00:02:53.590 --> 00:02:59.500
我整周都会在这里，你可以赶上

00:02:56.350 --> 00:03:01.560
我在那里，也在展位上，所以

00:02:59.500 --> 00:03:02.980
让我们进入历史部分

00:03:01.560 --> 00:03:08.290
微型马诺

00:03:02.980 --> 00:03:12.630
哦，不，我在这里将j2ee servlets非常

00:03:08.290 --> 00:03:14.950
早期的Java微服务平台如此

00:03:12.630 --> 00:03:18.030
嗯，什么是正确的开始

00:03:14.950 --> 00:03:22.750
没错，谁在使用servlet 

00:03:18.030 --> 00:03:27.640
 2000开始使用的任何人都可以

00:03:22.750 --> 00:03:29.549
像2005年这样的服务是谁

00:03:27.640 --> 00:03:31.840
仍然使用今天的东西

00:03:29.549 --> 00:03:35.410
好吧好吧好吧，这是

00:03:31.840 --> 00:03:37.690
这个微服务术语已经存在了

00:03:35.410 --> 00:03:39.850
是新事物，但你知道

00:03:37.690 --> 00:03:42.639
真的没有什么新鲜的东西

00:03:39.850 --> 00:03:46.180
想拿几张幻灯片

00:03:42.639 --> 00:03:47.560
是时候通过这个定义了

00:03:46.180 --> 00:03:49.420
我已经确定要同意

00:03:47.560 --> 00:03:52.120
微服务的定义是

00:03:49.420 --> 00:03:54.400
看看历史如何

00:03:52.120 --> 00:03:56.890
老式的j2ee servlet堆积

00:03:54.400 --> 00:03:58.180
用我自己的观点和分析，你

00:03:56.890 --> 00:04:00.580
可能会有不同的意见

00:03:58.180 --> 00:04:03.880
这是有争议的

00:04:00.580 --> 00:04:07.030
主题也是如此，因此一般来说微服务

00:04:03.880 --> 00:04:08.680
似乎都是一个很小的系统

00:04:07.030 --> 00:04:12.069
是每个服务的集合

00:04:08.680 --> 00:04:15.900
松散耦合很小，可以

00:04:12.069 --> 00:04:18.730
与其他服务隔离

00:04:15.900 --> 00:04:21.180
具有很高的内部凝聚力

00:04:18.730 --> 00:04:23.590
每项服务做一件事

00:04:21.180 --> 00:04:25.810
可以管理部署和开发

00:04:23.590 --> 00:04:27.780
独立于其他人并且是

00:04:25.810 --> 00:04:31.870
负责拥有自己的数据

00:04:27.780 --> 00:04:33.490
让我们现在来看这些

00:04:31.870 --> 00:04:35.050
另一面没有停止

00:04:33.490 --> 00:04:37.870
您无需保留服务器上的内容

00:04:35.050 --> 00:04:40.660
小事情之一，我们，我

00:04:37.870 --> 00:04:44.620
在进行JSF方面学到的是

00:04:40.660 --> 00:04:47.160
 Web框架是这个挑战

00:04:44.620 --> 00:04:51.100
试图在哪里设计东西

00:04:47.160 --> 00:04:53.140
容易做正确的事，并且

00:04:51.100 --> 00:04:54.580
很难但并非没有可能

00:04:53.140 --> 00:04:56.110
真的是错误的事情，因为很多

00:04:54.580 --> 00:04:58.750
有时候你需要做错事

00:04:56.110 --> 00:05:01.930
您知道完成工作，因此servlet 

00:04:58.750 --> 00:05:03.280
使用HTTP会话非常容易

00:05:01.930 --> 00:05:05.770
以及它的许多特性

00:05:03.280 --> 00:05:08.500
提供无处不在

00:05:05.770 --> 00:05:10.960
可用并且通常可靠，然后

00:05:08.500 --> 00:05:12.850
多年来，应用服务器已添加

00:05:10.960 --> 00:05:14.530
群集和故障转移到HTTP 

00:05:12.850 --> 00:05:18.389
会议，所以我们做了很多事情

00:05:14.530 --> 00:05:22.270
真的很容易滥用那件事，所以

00:05:18.389 --> 00:05:24.100
从这个意义上讲，servlet很小，您可以

00:05:22.270 --> 00:05:26.860
做到了，但你必须努力一点

00:05:24.100 --> 00:05:30.070
确保它很小，我会给

00:05:26.860 --> 00:05:33.520
也许是松散耦合的

00:05:30.070 --> 00:05:34.870
过滤器可以很好地构成

00:05:33.520 --> 00:05:36.970
他们设计用来过滤的东西

00:05:34.870 --> 00:05:40.389
 in那教的概念是专为

00:05:36.970 --> 00:05:42.850
支持撰写，如果您有

00:05:40.389 --> 00:05:45.250
系统由许多

00:05:42.850 --> 00:05:50.560
您可以考虑不同的穿着

00:05:45.250 --> 00:05:53.500
它们是可组合的，也很孤立

00:05:50.560 --> 00:05:55.960
从其他服务通常

00:05:53.500 --> 00:05:57.520
不是人们如何使用服务

00:05:55.960 --> 00:05:58.889
该模型是否是

00:05:57.520 --> 00:06:02.219
整体是

00:05:58.889 --> 00:06:03.629
被视为逃避的模式是

00:06:02.219 --> 00:06:05.370
停电，仆人会阻止

00:06:03.629 --> 00:06:07.740
整个呼叫流程的其余部分来自

00:06:05.370 --> 00:06:10.949
执行那是stacktrace的地方

00:06:07.740 --> 00:06:14.039
是我们得到这些大的长堆栈痕迹

00:06:10.949 --> 00:06:15.719
我现在对Java的看法是我们

00:06:14.039 --> 00:06:17.460
仍然有巨大的长堆栈痕迹

00:06:15.719 --> 00:06:20.340
只是散布在所有这些

00:06:17.460 --> 00:06:23.610
不同的机器，但另一方面

00:06:20.340 --> 00:06:25.919
我们有一大堆原木

00:06:23.610 --> 00:06:28.770
那里的科学技术

00:06:25.919 --> 00:06:31.439
帮助您理解这么大

00:06:28.770 --> 00:06:33.270
堆栈跟踪，所以想象一下是否可以放

00:06:31.439 --> 00:06:36.569
来自地狱的巨大堆栈跟踪

00:06:33.270 --> 00:06:37.919
 j2ee变成类似cabana的东西

00:06:36.569 --> 00:06:39.840
能够分析并将其分解

00:06:37.919 --> 00:06:41.969
这样可能有用

00:06:39.840 --> 00:06:44.279
但这只是一种不同的方法

00:06:41.969 --> 00:06:47.639
人们现在正在使用，因此

00:06:44.279 --> 00:06:50.009
孤立我会说我会给

00:06:47.639 --> 00:06:53.009
一个人在内部非常了解

00:06:50.009 --> 00:06:56.339
凝聚力一般做一件事

00:06:53.009 --> 00:06:59.129
侦探用作控制器或

00:06:56.339 --> 00:07:00.629
对HTTP请求起作用的过滤器，以及

00:06:59.129 --> 00:07:03.810
要么将其传递给其他服务

00:07:00.629 --> 00:07:07.490
或发送回复，所以我会说是

00:07:03.810 --> 00:07:09.810
他们可以说是做一件事情

00:07:07.490 --> 00:07:13.229
可以进行poi开发

00:07:09.810 --> 00:07:17.250
独立于其他人

00:07:13.229 --> 00:07:20.430
很难做坏事

00:07:17.250 --> 00:07:22.050
好东西，j2ee的表现不佳

00:07:20.430 --> 00:07:24.120
这是因为他们想出了这只耳朵

00:07:22.050 --> 00:07:26.310
概念，它使人们非常懒惰

00:07:24.120 --> 00:07:28.229
只是说这是一个巨大的

00:07:26.310 --> 00:07:31.310
耳朵有五根电线，还有其他东西

00:07:28.229 --> 00:07:36.960
在其中，它永远需要部署和

00:07:31.310 --> 00:07:40.379
所以一个人可能是你知道我

00:07:36.960 --> 00:07:41.789
给它一个是，但这就像

00:07:40.379 --> 00:07:44.669
你，如果你限制自己只是

00:07:41.789 --> 00:07:47.279
您要部署在不同位置的电线

00:07:44.669 --> 00:07:49.319
负责的容器和servlet 

00:07:47.279 --> 00:07:51.029
一般处理自己的数据服务

00:07:49.319 --> 00:07:52.800
没有太多的数据方式

00:07:51.029 --> 00:07:55.710
总是由其他部分处理

00:07:52.800 --> 00:07:57.149
 java ee monolith但无论数据是什么

00:07:55.710 --> 00:07:58.439
一般都有什么

00:07:57.149 --> 00:08:01.620
未与其他部分共享

00:07:58.439 --> 00:08:03.509
系统，所以我会给一个

00:08:01.620 --> 00:08:05.009
您可以总体评价一点

00:08:03.509 --> 00:08:08.819
将servlet视为非常早期的

00:08:05.009 --> 00:08:10.379
微服务平台，但您知道是否

00:08:08.819 --> 00:08:11.639
这是完美的微服务

00:08:10.379 --> 00:08:12.569
平台，那么我们就不会在哪里

00:08:11.639 --> 00:08:15.990
今天

00:08:12.569 --> 00:08:19.830
进化，人们改变口味

00:08:15.990 --> 00:08:23.929
应对经济趋势和流行

00:08:19.830 --> 00:08:23.929
工具和最佳做法

00:08:24.409 --> 00:08:29.759
因此谈论趋势是

00:08:27.479 --> 00:08:32.009
我真的很想谈论我们

00:08:29.759 --> 00:08:35.009
做了很长时间的JCP规范

00:08:32.009 --> 00:08:38.339
我认为这是一个可靠的途径

00:08:35.009 --> 00:08:42.300
成功的记录通常被保留为

00:08:38.339 --> 00:08:44.639
缓慢而繁琐而艰难，但是你

00:08:42.300 --> 00:08:47.660
知道你确实得到了结果，你确实得到了

00:08:44.639 --> 00:08:50.759
代表性如此

00:08:47.660 --> 00:08:52.500
 servlet方面David我们一直

00:08:50.759 --> 00:08:54.360
采用并合并了新功能

00:08:52.500 --> 00:08:56.550
从行业趋势和最佳实践

00:08:54.360 --> 00:08:58.620
一直以来，我们都有包装

00:08:56.550 --> 00:09:03.269
永远的waar的概念

00:08:58.620 --> 00:09:05.220
我们添加了异步I / O 

00:09:03.269 --> 00:09:06.660
开始变得越来越流行的时候

00:09:05.220 --> 00:09:10.079
你知道什么时候它进入Java 

00:09:06.660 --> 00:09:12.899
 niño平台，我们补充说，我会

00:09:10.079 --> 00:09:15.000
还说我们有能力做一个

00:09:12.899 --> 00:09:17.120
完全反应性的应用程序

00:09:15.000 --> 00:09:19.410
反应性宣言被放在那里

00:09:17.120 --> 00:09:21.329
能够承受背压

00:09:19.410 --> 00:09:25.829
写入时可用的可用数据

00:09:21.329 --> 00:09:28.290
依赖注入和

00:09:25.829 --> 00:09:32.000
控制反转在

00:09:28.290 --> 00:09:35.490
春天的到来，然后是CDI 

00:09:32.000 --> 00:09:38.850
此后不久，我们添加了资源

00:09:35.490 --> 00:09:41.720
注入到servlet和Java EE中

00:09:38.850 --> 00:09:47.910
当然，最新趋势

00:09:41.720 --> 00:09:50.699
将HTTP 2纳入规范，因此如果

00:09:47.910 --> 00:09:54.029
你有一个Greenfield项目来自

00:09:50.699 --> 00:09:57.120
您会选择使用servlet吗

00:09:54.029 --> 00:09:59.939
考虑到该项目的选择

00:09:57.120 --> 00:10:02.130
您拥有的工具，它将是一个

00:09:59.939 --> 00:10:03.420
向右伸展，但有一些原因

00:10:02.130 --> 00:10:04.649
您可能想选择使用的地方

00:10:03.420 --> 00:10:08.759
为绿色食品发展服务

00:10:04.649 --> 00:10:10.980
微服务风格可以说很多

00:10:08.759 --> 00:10:14.699
企业有很严格的标准

00:10:10.980 --> 00:10:16.620
认可什么，不认可什么

00:10:14.699 --> 00:10:18.720
几年前批准的

00:10:16.620 --> 00:10:20.130
很高兴发表演讲并与

00:10:18.720 --> 00:10:22.559
汉莎航空的几个同事

00:10:20.130 --> 00:10:24.720
航空公司，他们把这个东西叫做

00:10:22.559 --> 00:10:26.080
标准的大书本

00:10:24.720 --> 00:10:28.240
在许多企业中并不少见

00:10:26.080 --> 00:10:31.089
如果您想使用

00:10:28.240 --> 00:10:33.670
技术及其解决方案

00:10:31.089 --> 00:10:36.070
在那里，那些解决方案都是

00:10:33.670 --> 00:10:38.320
由他们的公司架构师审核

00:10:36.070 --> 00:10:42.029
已达到必要的安全性

00:10:38.320 --> 00:10:44.709
要求和法律要求以及

00:10:42.029 --> 00:10:47.920
赔偿和支持所有这些

00:10:44.709 --> 00:10:49.959
重要的企业问题，所以你

00:10:47.920 --> 00:10:52.209
可能在这样的商店里，你有

00:10:49.959 --> 00:10:55.380
基本上必须使用您所使用的

00:10:52.209 --> 00:10:58.630
根据j2ee或servlet给出

00:10:55.380 --> 00:11:00.310
您可能想利用

00:10:58.630 --> 00:11:01.779
微服务架构，但不是

00:11:00.310 --> 00:11:02.200
能够使用所有不同种类的

00:11:01.779 --> 00:11:04.930
工具

00:11:02.200 --> 00:11:07.029
这也是原因之一

00:11:04.930 --> 00:11:09.040
团队本身也许是规避风险的

00:11:07.029 --> 00:11:11.350
尝试新技术但冒险

00:11:09.040 --> 00:11:14.200
并尝试他们想要的新架构

00:11:11.350 --> 00:11:16.570
采取增量方法

00:11:14.200 --> 00:11:18.430
让我们使用

00:11:16.570 --> 00:11:19.899
旧堆栈，如果一旦我们得到

00:11:18.430 --> 00:11:22.420
正确的架构，我们了解如何

00:11:19.899 --> 00:11:23.620
为此，我们可以采取

00:11:22.420 --> 00:11:26.320
架构并将其应用于新

00:11:23.620 --> 00:11:27.940
堆叠，所以有一些原因使您

00:11:26.320 --> 00:11:32.320
想要选择微型的servlet 

00:11:27.940 --> 00:11:35.589
服务，但更常见的方法是

00:11:32.320 --> 00:11:37.300
通过巨大的判断来给出

00:11:35.589 --> 00:11:39.399
分手的谈判次数

00:11:37.300 --> 00:11:40.839
整体式，我确定您是否进行过网络搜索

00:11:39.399 --> 00:11:46.120
打破整体，你会看到

00:11:40.839 --> 00:11:47.410
他们中的很多人都在使用servlet作为

00:11:46.120 --> 00:11:51.610
踏上更纯净的垫脚石

00:11:47.410 --> 00:11:54.160
微服务系统，所以我提到了耳朵

00:11:51.610 --> 00:11:56.740
有你知道分开的电线

00:11:54.160 --> 00:11:58.540
那些分开的电线

00:11:56.740 --> 00:12:00.339
人们要做的就是站起来

00:11:58.540 --> 00:12:00.730
在现有服务之前休息

00:12:00.339 --> 00:12:03.100
穿着

00:12:00.730 --> 00:12:05.079
然后最终分解那些

00:12:03.100 --> 00:12:07.690
电线，以便您获得其余服务

00:12:05.079 --> 00:12:10.899
纯微服务，所以

00:12:07.690 --> 00:12:12.670
这种方法，所以我要去

00:12:10.899 --> 00:12:14.410
交给成Y在这里给我们

00:12:12.670 --> 00:12:21.310
讨论的核心

00:12:14.410 --> 00:12:24.760
功能评论谢谢

00:12:21.310 --> 00:12:27.519
感谢添加的介绍

00:12:24.760 --> 00:12:29.380
现在没有微服务的servlet 

00:12:27.519 --> 00:12:34.690
尝试看看中的新功能

00:12:29.380 --> 00:12:37.120
服务器照片哦，现在进入

00:12:34.690 --> 00:12:40.070
我想提及的新功能

00:12:37.120 --> 00:12:43.970
我们在Java EE中所做的一切

00:12:40.070 --> 00:12:47.240
可在嘻哈平静和斜线中使用

00:12:43.970 --> 00:12:49.760
欢迎您尝试Java EE的反汇编

00:12:47.240 --> 00:12:53.240
在Quixote um Java EE中

00:12:49.760 --> 00:12:56.240
草鱼-那里有样品

00:12:53.240 --> 00:12:59.510
您将看到很多示例，并且

00:12:56.240 --> 00:13:09.050
说明Java中的新功能

00:12:59.510 --> 00:13:12.470
 EE特别是servlet照片

00:13:09.050 --> 00:13:15.920
让我们看一下HTTP 2 

00:13:12.470 --> 00:13:17.180
多年以来，我们都知道超过了HTTP 

00:13:15.920 --> 00:13:20.330
 2很重要

00:13:17.180 --> 00:13:24.590
主要重点是表现

00:13:20.330 --> 00:13:28.070
它有很多功能需要改进

00:13:24.590 --> 00:13:31.370
在浏览器中加载页面怎么办

00:13:28.070 --> 00:13:36.560
他们这样做，让我们先来看一下

00:13:31.370 --> 00:13:40.190
现在是HTTP 1.1中的主要框架

00:13:36.560 --> 00:13:42.020
协议以清晰标签和主要

00:13:40.190 --> 00:13:44.210
知道虽然更紧凑， 

00:13:42.020 --> 00:13:49.310
当这种转移跨

00:13:44.210 --> 00:13:53.420
电线，第二个是流

00:13:49.310 --> 00:13:57.530
现在在HTTP 1.1中多路传输

00:13:53.420 --> 00:14:01.250
有一个请求一个回应一个

00:13:57.530 --> 00:14:04.760
请求和一个回应，他们也

00:14:01.250 --> 00:14:07.790
具有一个称为HTTP流水线的功能

00:14:04.760 --> 00:14:09.680
 1.1基本上说可以发送

00:14:07.790 --> 00:14:12.050
同时发送多个请求

00:14:09.680 --> 00:14:14.450
因此您可以请求一个请求- 

00:14:12.050 --> 00:14:17.210
免费要求，但有要求

00:14:14.450 --> 00:14:20.330
要求是响应

00:14:17.210 --> 00:14:24.560
按照请求的顺序

00:14:20.330 --> 00:14:29.810
因此它必须是回应1回应和

00:14:24.560 --> 00:14:32.840
现在免费回复存在问题

00:14:29.810 --> 00:14:36.250
花了很长时间才发生

00:14:32.840 --> 00:14:39.590
在这种情况下计算响应1 

00:14:36.250 --> 00:14:42.290
回应并回应3需要等待

00:14:39.590 --> 00:14:45.820
响应1完成，并且

00:14:42.290 --> 00:14:50.780
是石灰公园问题的负责人吗

00:14:45.820 --> 00:14:52.950
现在在htv-2中，您实际上可以发送

00:14:50.780 --> 00:14:55.320
以不同的顺序回应

00:14:52.950 --> 00:14:58.860
这是免费的多路复用

00:14:55.320 --> 00:15:02.490
意思是我可以发送一个请求

00:14:58.860 --> 00:15:08.130
到然后要求免费，然后我可以

00:15:02.490 --> 00:15:11.550
发送响应，然后响应一个，然后

00:15:08.130 --> 00:15:14.430
然后自由回应，因此

00:15:11.550 --> 00:15:17.910
响应甚至不再重要

00:15:14.430 --> 00:15:20.040
更好的是我们可以拆分请求

00:15:17.910 --> 00:15:23.160
和反应成碎片

00:15:20.040 --> 00:15:26.610
例如您有一个请求

00:15:23.160 --> 00:15:30.840
请求-然后您被送回

00:15:26.610 --> 00:15:34.590
第一响应的一部分和第一响应

00:15:30.840 --> 00:15:37.200
的回应，然后是第二部分

00:15:34.590 --> 00:15:40.650
响应一，然后是第二部分

00:15:37.200 --> 00:15:43.380
回应-这是一个非常好的功能

00:15:40.650 --> 00:15:46.620
 HTTP中的practicin的流- 

00:15:43.380 --> 00:15:49.170
这使我们在

00:15:46.620 --> 00:15:51.960
我们可以在浏览器中加载页面

00:15:49.170 --> 00:15:54.870
今天晚些时候再见

00:15:51.960 --> 00:15:57.150
现在，我们拥有的第三个功能

00:15:54.870 --> 00:15:59.660
 HTTP改善浏览

00:15:57.150 --> 00:16:03.030
性能就是头压缩

00:15:59.660 --> 00:16:05.130
现在，如果您尝试看看

00:16:03.030 --> 00:16:08.070
给定浏览器之间的通信

00:16:05.130 --> 00:16:10.500
和一台服务器，您会注意到大多数

00:16:08.070 --> 00:16:13.650
很多时候他们的头

00:16:10.500 --> 00:16:16.050
通过电线发送实际上是相同的

00:16:13.650 --> 00:16:18.330
对希瑟来说很多，实际上对于

00:16:16.050 --> 00:16:20.970
示例哪种内容类型的

00:16:18.330 --> 00:16:23.490
浏览器将观察到的思维类型

00:16:20.970 --> 00:16:28.110
他们需要每次通过电线发送

00:16:23.490 --> 00:16:31.620
现在的时间现在是多余的

00:16:28.110 --> 00:16:33.870
 HTTP的方式--大约两年

00:16:31.620 --> 00:16:36.480
允许做某种意义上的压缩

00:16:33.870 --> 00:16:41.850
第一次发送标头

00:16:36.480 --> 00:16:45.150
第二次您发送的索引

00:16:41.850 --> 00:16:48.480
他们特定表的标题

00:16:45.150 --> 00:16:51.060
在另一边，所以在这种情况下

00:16:48.480 --> 00:16:55.070
您确实需要发送整个标头

00:16:51.060 --> 00:16:55.070
他们只需要发送一个图像整数

00:16:55.130 --> 00:17:02.220
是的，因为该表是私人的

00:16:58.920 --> 00:17:05.420
在服务器和浏览器之间

00:17:02.220 --> 00:17:05.420
服务器未共享

00:17:05.640 --> 00:17:11.790
好吧，第四个功能是一定要推动

00:17:08.700 --> 00:17:14.820
和服务器推送基本上是说

00:17:11.790 --> 00:17:17.370
好的，您允许服务器推送

00:17:14.820 --> 00:17:18.839
数据给我要谈论的客户

00:17:17.370 --> 00:17:24.360
稍后更多

00:17:18.839 --> 00:17:28.290
最后是他们在这个HTTP中-我们

00:17:24.360 --> 00:17:30.930
总是使用保持有条件的生活

00:17:28.290 --> 00:17:33.240
在HTTP 1中，可以保留

00:17:30.930 --> 00:17:37.620
连接仍然有效，但您可以选择

00:17:33.240 --> 00:17:39.690
将其关闭，但在HTTP 2中始终

00:17:37.620 --> 00:17:45.660
保持活动状态，以便您可以将数据发送回去

00:17:39.690 --> 00:17:49.530
现在因为这样

00:17:45.660 --> 00:17:52.110
服务器照片哦，如果您是苏联照片， 

00:17:49.530 --> 00:17:55.740
使用它，那么你基本上可以使用

00:17:52.110 --> 00:17:58.370
利用HTTP 2中的所有功能，以便

00:17:55.740 --> 00:18:00.930
您将获得主要的帧流

00:17:58.370 --> 00:18:04.310
多路复用有一个压缩， 

00:18:00.930 --> 00:18:09.990
连接那些东西免费

00:18:04.310 --> 00:18:12.870
这对用户是透明的，因此

00:18:09.990 --> 00:18:14.880
您唯一要做的就是做

00:18:12.870 --> 00:18:18.960
服务器推送上方的特殊内容

00:18:14.880 --> 00:18:22.830
我将在高清电视中谈论更多

00:18:18.960 --> 00:18:26.460
您的我们也有一些流量控制

00:18:22.830 --> 00:18:29.280
你可以说的东西

00:18:26.460 --> 00:18:32.010
我想打开或关闭服务器

00:18:29.280 --> 00:18:36.060
推动这部分仍然有效

00:18:32.010 --> 00:18:40.790
强调我们要去的Polacco 

00:18:36.060 --> 00:18:43.830
仔细看看现在发生了什么

00:18:40.790 --> 00:18:46.740
在我们去服务器推送之前，让我们

00:18:43.830 --> 00:18:51.060
尝试回顾一下发生了什么

00:18:46.740 --> 00:18:55.020
 servlet中的经典案例现在您有了一个

00:18:51.060 --> 00:18:58.980
浏览器浏览器将去获取

00:18:55.020 --> 00:19:00.930
索引或采用HTML，然后他们将

00:18:58.980 --> 00:19:03.540
返回浏览器转到服务器

00:19:00.930 --> 00:19:07.980
然后回到浏览器

00:19:03.540 --> 00:19:11.060
浏览器将执行几项操作

00:19:07.980 --> 00:19:14.730
首先将完整地看进去

00:19:11.060 --> 00:19:18.630
 HTML进行传递，然后他们将

00:19:14.730 --> 00:19:19.470
发现哦，我需要一个样式表，我

00:19:18.630 --> 00:19:22.409
还需要

00:19:19.470 --> 00:19:27.210
 javascript，这样他们经过之后

00:19:22.409 --> 00:19:31.080
他们将发送另外两个HTTP请求

00:19:27.210 --> 00:19:34.289
称为获取样式表，然后返回

00:19:31.080 --> 00:19:36.900
然后获取JavaScript然后返回

00:19:34.289 --> 00:19:41.490
现在，这是非常普遍的古典用法

00:19:36.900 --> 00:19:45.299
案例现在让我们来看看服务器

00:19:41.490 --> 00:19:49.080
推送可以改善

00:19:45.299 --> 00:19:51.120
现在考虑到这一点，我们

00:19:49.080 --> 00:19:55.980
要仔细看看

00:19:51.120 --> 00:19:59.669
现在，如果我们增加额外的服务器推送量

00:19:55.980 --> 00:20:02.070
从RFC中调用措辞

00:19:59.669 --> 00:20:05.039
基本上说服务器推送允许服务器

00:20:02.070 --> 00:20:07.679
投机地将数据发送到一种

00:20:05.039 --> 00:20:10.830
服务器预期的那种

00:20:07.679 --> 00:20:14.100
需要再次交易一些网络使用情况

00:20:10.830 --> 00:20:16.890
潜在的延迟游戏现在能做什么

00:20:14.100 --> 00:20:21.720
这意味着好吧，我爱参议院

00:20:16.890 --> 00:20:24.059
数据从服务器到客户端，然后

00:20:21.720 --> 00:20:28.919
他们实际上很友善

00:20:24.059 --> 00:20:35.850
现在先问一下好吗

00:20:28.919 --> 00:20:39.510
数据可以是任何东西，不是必须的

00:20:35.850 --> 00:20:41.780
 HTTP响应正确，因为浏览器

00:20:39.510 --> 00:20:46.500
只了解高清电视的回应

00:20:41.780 --> 00:20:51.059
其次是对相应的

00:20:46.500 --> 00:20:56.880
到一个请求现在可以是任何

00:20:51.059 --> 00:21:01.080
那种要求原来不让我们

00:20:56.880 --> 00:21:03.750
看看RFC怎么说

00:21:01.080 --> 00:21:06.630
要求它们对应的是

00:21:03.750 --> 00:21:08.159
打电话给帕尔马斯，你有

00:21:06.630 --> 00:21:12.630
三个标准

00:21:08.159 --> 00:21:15.990
第一个是可兑现的，第二个是可兑现的

00:21:12.630 --> 00:21:19.799
是安全的，他发送的意思是

00:21:15.990 --> 00:21:24.030
基本上只有第三个是

00:21:19.799 --> 00:21:26.940
要求现在不能有这个

00:21:24.030 --> 00:21:30.179
要求你可以看看维恩

00:21:26.940 --> 00:21:32.350
右侧的图表

00:21:30.179 --> 00:21:36.700
标准的HTTP方法

00:21:32.350 --> 00:21:40.990
可散列的平均姿势获取和拥有且安全

00:21:36.700 --> 00:21:44.260
意味着期权交易得到了，所以如果你

00:21:40.990 --> 00:21:47.110
想要成为可缓存且安全的

00:21:44.260 --> 00:21:51.640
在这种情况下只能得到帮助

00:21:47.110 --> 00:21:54.460
当然，如果您有自定义的HDTV方法

00:21:51.640 --> 00:21:56.980
像servlet这样支持

00:21:54.460 --> 00:22:00.400
您可以定义一个称为foo和的方法

00:21:56.980 --> 00:22:03.760
在这种情况下，只要他们满足

00:22:00.400 --> 00:22:06.429
可缓存的安全标准，并与我们

00:22:03.760 --> 00:22:10.809
会越过身体，您仍然可以使用

00:22:06.429 --> 00:22:17.770
现在让我们来看看push方法

00:22:10.809 --> 00:22:21.610
现在我们在servlet API中所做的是

00:22:17.770 --> 00:22:24.400
我在Servlet之前提到过数据

00:22:21.610 --> 00:22:29.830
我们越过电线对应

00:22:24.400 --> 00:22:32.440
到HTTP请求，所以我们有一个API 

00:22:29.830 --> 00:22:35.049
呼叫推送构建器基本上是

00:22:32.440 --> 00:22:38.140
构造相应的HTTP请求

00:22:35.049 --> 00:22:43.630
这样您就可以看到类似add的方法

00:22:38.140 --> 00:22:46.720
标头方法是get或head或

00:22:43.630 --> 00:22:49.330
您的自定义可缓存保存与我们

00:22:46.720 --> 00:22:51.429
请求身体，然后你有一个居里

00:22:49.330 --> 00:22:54.370
字符串，然后您可以指定一个

00:22:51.429 --> 00:22:56.890
部分ID，当然您必须

00:22:54.370 --> 00:23:01.750
指定相应的URL路径并

00:22:56.890 --> 00:23:05.200
那么你现在就按这个推

00:23:01.750 --> 00:23:09.400
建造者，你可以打电话给我们建造

00:23:05.200 --> 00:23:12.070
相应的请求，但您仍然有

00:23:09.400 --> 00:23:14.950
给我一种方法来尝试推动

00:23:12.070 --> 00:23:18.400
佛陀，我们可以从HTTP获取它

00:23:14.950 --> 00:23:21.039
现在在HTTP请求中请求API 

00:23:18.400 --> 00:23:22.659
称为“新推送构建器” 

00:23:21.039 --> 00:23:24.130
这你会得到推生成器，然后

00:23:22.659 --> 00:23:26.500
您可以操纵和创建

00:23:24.130 --> 00:23:28.750
现在请求，我想提及两个

00:23:26.500 --> 00:23:31.960
首先为这个新的推送构建器准备的事情

00:23:28.750 --> 00:23:36.280
它被称为新的推送生成器，所以每个

00:23:31.960 --> 00:23:42.549
调用它的时间可能会得到一个新副本

00:23:36.280 --> 00:23:45.730
校对对象第二个是什么

00:23:42.549 --> 00:23:48.389
当这种连接发生

00:23:45.730 --> 00:23:51.820
哭着说我什么都不要

00:23:48.389 --> 00:23:53.529
从推送服务器推送，然后再次

00:23:51.820 --> 00:23:56.320
实际上关闭它，你知道

00:23:53.529 --> 00:23:58.690
政治层在这种情况下推

00:23:56.320 --> 00:24:00.610
现在将返回的账单反对

00:23:58.690 --> 00:24:02.679
每次您呼叫新的推送构建器

00:24:00.610 --> 00:24:04.779
您要做的就是检查

00:24:02.679 --> 00:24:09.370
是否现在才尝试使用

00:24:04.779 --> 00:24:13.720
现在说明一下，让我们来

00:24:09.370 --> 00:24:16.690
看第二张图，看看有什么

00:24:13.720 --> 00:24:18.730
我们可以做来改善

00:24:16.690 --> 00:24:22.779
常见的用例是你

00:24:18.730 --> 00:24:25.750
没关系，现在你仍然有一个

00:24:22.779 --> 00:24:29.860
浏览器，浏览器将进入

00:24:25.750 --> 00:24:33.240
感应器HTML，然后

00:24:29.860 --> 00:24:36.279
允许它到一个servlet和该servlet 

00:24:33.240 --> 00:24:38.529
在内部，因为T是

00:24:36.279 --> 00:24:41.620
您可以放入服务器的信息是

00:24:38.529 --> 00:24:43.899
好的T已建立索引或HTML，您知道

00:24:41.620 --> 00:24:47.019
您将需要样式表和

00:24:43.899 --> 00:24:53.080
 JavaScript，所以您要做的是

00:24:47.019 --> 00:24:56.590
像这样先得到一个新的

00:24:53.080 --> 00:25:00.159
推建设者，一旦你得到你的

00:24:56.590 --> 00:25:02.860
返回对象，然后您返回对象

00:25:00.159 --> 00:25:05.529
您必须检查T现在在哪里或

00:25:02.860 --> 00:25:08.860
曾经没有，你知道那不是现在

00:25:05.529 --> 00:25:15.010
然后您可以开始使用它，然后您

00:25:08.860 --> 00:25:16.929
可以设置路径，然后按然后

00:25:15.010 --> 00:25:19.570
一旦从容器中推入

00:25:16.929 --> 00:25:23.710
然后回来，然后一旦你推到

00:25:19.570 --> 00:25:26.049
样式表，您可以做同样的事情

00:25:23.710 --> 00:25:30.850
 JavaScript，然后是服务器

00:25:26.049 --> 00:25:33.850
会将推送数学框架发送到

00:25:30.850 --> 00:25:35.529
到浏览器，然后最终

00:25:33.850 --> 00:25:39.610
他们被发送了数据，然后他们

00:25:35.529 --> 00:25:43.419
将发送感应器HTML的正文

00:25:39.610 --> 00:25:45.970
现在我想提几个

00:25:43.419 --> 00:25:50.590
关于这个信号图的第一件事

00:25:45.970 --> 00:25:55.480
我们注意到，推送构建器是

00:25:50.590 --> 00:25:59.160
在这种情况下可以重复使用，因此一按即可

00:25:55.480 --> 00:26:01.500
被推了两​​次的建设者

00:25:59.160 --> 00:26:04.980
第一次你推

00:26:01.500 --> 00:26:08.130
样式表，然后您还可以按

00:26:04.980 --> 00:26:11.130
如果您共享推送，现在使用JavaScript 

00:26:08.130 --> 00:26:14.790
建设者，他们是你可以的优势

00:26:11.130 --> 00:26:17.580
实际上P填充了所有信息

00:26:14.790 --> 00:26:20.370
这是HTTP方法常见的

00:26:17.580 --> 00:26:23.430
例如我知道这很害怕

00:26:20.370 --> 00:26:25.860
我只是把点方法得到'然后他们

00:26:23.430 --> 00:26:28.260
可以分享一些共同的现场直播

00:26:25.860 --> 00:26:30.930
想法或其他什么可以设置

00:26:28.260 --> 00:26:34.110
一站式构建器中的所有内容，然后

00:26:30.930 --> 00:26:35.670
您继续设置路径，然后按

00:26:34.110 --> 00:26:42.120
您已经保存了不需要的工作

00:26:35.670 --> 00:26:43.710
再次重建对象

00:26:42.120 --> 00:26:46.770
我想提的这件事

00:26:43.710 --> 00:26:49.380
在此图中，我说我发出了一个

00:26:46.770 --> 00:26:54.660
千和JavaScript在这里，我们只

00:26:49.380 --> 00:26:57.840
先发送推Tomas帧，然后再发送

00:26:54.660 --> 00:27:00.540
稍后，服务器会将正文作为

00:26:57.840 --> 00:27:04.230
数据框，我想这是要谈的

00:27:00.540 --> 00:27:07.230
在一个具体的例子中对此有更多的了解

00:27:04.230 --> 00:27:11.310
现在有了这个特殊的设置，我们

00:27:07.230 --> 00:27:13.710
有就是这样我们保存了两次旅行

00:27:11.310 --> 00:27:17.040
我们保存了从

00:27:13.710 --> 00:27:19.310
浏览器再次请求服务器

00:27:17.040 --> 00:27:23.130
样式表并要求

00:27:19.310 --> 00:27:26.400
 JavaScript T现在是一个很大的优势

00:27:23.130 --> 00:27:30.120
因为在上图中，当您

00:27:26.400 --> 00:27:33.720
使用数据HTML进行旅行，您尝试获取

00:27:30.120 --> 00:27:36.000
样式表和JavaScript，但我们可以

00:27:33.720 --> 00:27:38.610
不是立即在一起，您必须得到

00:27:36.000 --> 00:27:41.580
首先深入了解HTML，然后

00:27:38.610 --> 00:27:43.650
通过互联网或HTML，然后

00:27:41.580 --> 00:27:46.410
你内心很低，然后最终

00:27:43.650 --> 00:27:48.900
发现您确实需要它，然后

00:27:46.410 --> 00:27:51.090
您提出了一个要求，因此导致了

00:27:48.900 --> 00:27:53.700
延迟在这种情况下，但在这里

00:27:51.090 --> 00:27:56.310
一切，你知道你需要它，你只是

00:27:53.700 --> 00:27:59.100
通过电线发送，然后让

00:27:56.310 --> 00:28:05.280
浏览器现在将其拾起

00:27:59.100 --> 00:28:09.990
空气在服务器上做一个演示推OK 

00:28:05.280 --> 00:28:12.419
谁在使用任何类型的Java服务器

00:28:09.990 --> 00:28:14.759
任何形式的侧面Web框架

00:28:12.419 --> 00:28:17.039
对，很多人都可以，保持你的

00:28:14.759 --> 00:28:20.239
放手把它们放起来，如果

00:28:17.039 --> 00:28:23.489
您没有使用JSF放下手

00:28:20.239 --> 00:28:27.059
好的，所以我们让一些JSF用户进行了演示

00:28:23.489 --> 00:28:31.950
我将展示基于JSF和

00:28:27.059 --> 00:28:34.440
很好，很简单，这只是

00:28:31.950 --> 00:28:35.549
我正在运行GlassFish 5，我有

00:28:34.440 --> 00:28:41.399
素面

00:28:35.549 --> 00:28:45.840
部署了演示程序并启用了http2 

00:28:41.399 --> 00:28:50.190
默认情况下，在某些和JSF中

00:28:45.840 --> 00:28:53.190
是的，还有JSF 2.3，所以您将获得

00:28:50.190 --> 00:28:55.470
如果您要检查H的功能

00:28:53.190 --> 00:28:58.320
如果不这样做，您将通过HTTP 

00:28:55.470 --> 00:29:00.749
至少通过GlassFish上的HTTPS 

00:28:58.320 --> 00:29:05.249
您不会获得HCB-它必须

00:29:00.749 --> 00:29:07.619
是HTTPS，以便服务器推送工作，并且

00:29:05.249 --> 00:29:12.960
所以你知道我们只是重新加载这个

00:29:07.619 --> 00:29:15.629
页面，这只是主要内容之一

00:29:12.960 --> 00:29:20.279
面对组件，让我们看一下

00:29:15.629 --> 00:29:23.700
在chrome net内部localhost 

00:29:20.279 --> 00:29:26.039
我只是在寻找推诺框架

00:29:23.700 --> 00:29:29.639
这些是你可以看到它使

00:29:26.039 --> 00:29:32.029
要求提供一些展示CSS 

00:29:29.639 --> 00:29:35.149
文件，并且有很多

00:29:32.029 --> 00:29:40.409
资源进来这里一些jQuery 

00:29:35.149 --> 00:29:42.960
 JavaScript中有一些方面的东西

00:29:40.409 --> 00:29:46.859
在这里内联模板化

00:29:42.960 --> 00:29:48.929
我要指出的是素颜

00:29:46.859 --> 00:29:53.159
六个不必重写自己

00:29:48.929 --> 00:29:55.859
利用服务器推送事实

00:29:53.159 --> 00:29:59.609
 Web框架不仅是JSF，而且是Web 

00:29:55.859 --> 00:30:01.590
框架通常知道那些

00:29:59.609 --> 00:30:03.269
他们知道协会的资源吗

00:30:01.590 --> 00:30:05.220
在页面和相关联之间

00:30:03.269 --> 00:30:07.289
在JSF的情况下， 

00:30:05.220 --> 00:30:09.480
众所周知，因为我们有这个

00:30:07.289 --> 00:30:11.609
整个资源加载程序的概念在哪里

00:30:09.480 --> 00:30:13.230
为这件事定义你的资源

00:30:11.609 --> 00:30:15.090
你说这是我的资源加载器

00:30:13.230 --> 00:30:17.279
或你不必把它放在罐子里

00:30:15.090 --> 00:30:18.989
但是你放在那里然后一旦你放

00:30:17.279 --> 00:30:21.749
服务器在那里知道这些是

00:30:18.989 --> 00:30:23.820
我的资源和包含

00:30:21.749 --> 00:30:25.830
资源对这些资源的依赖

00:30:23.820 --> 00:30:26.160
知道它将为他们服务

00:30:25.830 --> 00:30:28.890
所以是

00:30:26.160 --> 00:30:31.890
一个非常适合做的情况

00:30:28.890 --> 00:30:33.660
服务器推送，因此是快速演示

00:30:31.890 --> 00:30:35.490
我们时间紧迫，所以我只是

00:30:33.660 --> 00:30:39.080
交回盛行给

00:30:35.490 --> 00:30:39.080
我们还有更多功能

00:30:44.650 --> 00:30:50.840
我们是为演示添加的朋友， 

00:30:47.690 --> 00:30:53.450
现在谈到服务器推送

00:30:50.840 --> 00:30:56.600
让我们尝试谈一下，看看

00:30:53.450 --> 00:30:59.660
现在称为HTTP预告片的另一个功能

00:30:56.600 --> 00:31:03.830
拖车不是为了

00:30:59.660 --> 00:31:06.800
只有HTTP 2，我们对HTTP也很满意

00:31:03.830 --> 00:31:10.390
 1.1更早

00:31:06.800 --> 00:31:12.980
现在让我们看看它的含义

00:31:10.390 --> 00:31:16.460
现在让我从

00:31:12.980 --> 00:31:18.350
 RFC表示发件人决定

00:31:16.460 --> 00:31:21.110
以尾迹的形式发送元数据

00:31:18.350 --> 00:31:22.820
查看另一条消息

00:31:21.110 --> 00:31:25.130
发件人应该生成一个预告片

00:31:22.820 --> 00:31:26.900
邮件前的标头字段

00:31:25.130 --> 00:31:28.040
表示哪个字段的正文

00:31:26.900 --> 00:31:31.970
出现在预告片中

00:31:28.040 --> 00:31:34.250
好吧，现在很简单，让我尝试

00:31:31.970 --> 00:31:36.680
从中提取信息

00:31:34.250 --> 00:31:41.470
首先陈述观点

00:31:36.680 --> 00:31:46.460
有一些元数据可以吗

00:31:41.470 --> 00:31:47.750
元数据在这里表示标题，因此

00:31:46.460 --> 00:31:51.140
标头在这里好

00:31:47.750 --> 00:31:54.200
其次，当我打电话给预告片时

00:31:51.140 --> 00:31:57.200
在末尾发送的东西

00:31:54.200 --> 00:31:57.680
消息，以便您可以看到位于

00:31:57.200 --> 00:32:02.470
讯息

00:31:57.680 --> 00:32:07.280
最后是拖车的发件人

00:32:02.470 --> 00:32:09.470
需要通知接收者您我是

00:32:07.280 --> 00:32:11.690
打算给您发送一个预告片字段

00:32:09.470 --> 00:32:14.450
在这种情况下，他们会向您发送预告片

00:32:11.690 --> 00:32:20.720
标头现在让我们来看看

00:32:14.450 --> 00:32:23.810
具体的例子现在意味着什么

00:32:20.720 --> 00:32:29.050
现在有一个标准的HTTP响应

00:32:23.810 --> 00:32:32.150
 HTTP 1.1以使用预告片

00:32:29.050 --> 00:32:37.730
有您需要使用的要求

00:32:32.150 --> 00:32:40.220
这里的强传输编码

00:32:37.730 --> 00:32:42.790
在此使用大块错误的先生

00:32:40.220 --> 00:32:46.880
在这里编码，然后在这种情况下我

00:32:42.790 --> 00:32:49.790
想让用户知道我要给

00:32:46.880 --> 00:32:52.640
您的预告片您发送的预告片

00:32:49.790 --> 00:32:54.630
结束通话foo Colon bar食物是

00:32:52.640 --> 00:32:58.710
预告片PI的名称非常

00:32:54.630 --> 00:33:03.030
然后为了在我的

00:32:58.710 --> 00:33:06.059
请求标头我必须设置一个拖车： 

00:33:03.030 --> 00:33:10.130
 foo告诉他们我要发送

00:33:06.059 --> 00:33:10.130
您的名字叫傻瓜的拖车

00:33:10.280 --> 00:33:17.549
有RAC的意义

00:33:14.520 --> 00:33:23.130
我之前描述过的声明

00:33:17.549 --> 00:33:25.350
现在现在那么我们在这里有一个问题

00:33:23.130 --> 00:33:28.169
知道所有的拖车拖车领域

00:33:25.350 --> 00:33:34.110
将是这样的标题可以吗

00:33:28.169 --> 00:33:37.440
任何类型的标题都可以，我们可以

00:33:34.110 --> 00:33:41.929
但事实证明它可以是任何一种

00:33:37.440 --> 00:33:41.929
对此有要求

00:33:42.470 --> 00:33:50.549
它可以是任何东西，但不能是伪的

00:33:47.370 --> 00:33:53.850
头是什么伪头头是伪

00:33:50.549 --> 00:33:58.440
请求的标头将是HTTP 

00:33:53.850 --> 00:34:02.100
方法是HTTP或HTTPS的方案

00:33:58.440 --> 00:34:05.669
权限将是软管和端口

00:34:02.100 --> 00:34:08.879
以及路径，这样的信息

00:34:05.669 --> 00:34:12.179
您无法在预告片视图中发送

00:34:08.879 --> 00:34:14.429
响应您无法发送的状态码

00:34:12.179 --> 00:34:16.710
在预告片视图中发送交易，必须

00:34:14.429 --> 00:34:18.500
现在在标题中早点说

00:34:16.710 --> 00:34:21.540
是您对

00:34:18.500 --> 00:34:24.540
 HTTP尾部字段，然后我们有一个

00:34:21.540 --> 00:34:27.300
问题是，人们为什么要这样做

00:34:24.540 --> 00:34:33.720
你能想到任何用例吗

00:34:27.300 --> 00:34:35.940
人们尝试这样做，很好的校验和

00:34:33.720 --> 00:34:38.750
是另一件事，然后是另一件事

00:34:35.940 --> 00:34:44.369
将是数字签名权，并且

00:34:38.750 --> 00:34:47.129
我们有更多，我们有一个漂亮

00:34:44.369 --> 00:34:50.909
最近流行的用例称为G 

00:34:47.129 --> 00:34:53.520
 RPC是我们开发的PC协议

00:34:50.909 --> 00:34:56.760
通过gogo，此协议将需要

00:34:53.520 --> 00:35:00.330
他们需要HTTP 2的两件事

00:34:56.760 --> 00:35:04.830
使用了预告片字段，实际上

00:35:00.330 --> 00:35:08.220
功能由用户请求

00:35:04.830 --> 00:35:10.050
从例如讨论和

00:35:08.220 --> 00:35:11.550
带他们说，哦，我们需要支持

00:35:10.050 --> 00:35:14.460
拖车vo，所以这是一个很好的例子

00:35:11.550 --> 00:35:19.290
专家组之间的合作

00:35:14.460 --> 00:35:22.230
现在我们知道了什么是

00:35:19.290 --> 00:35:23.820
观点以及它有多重要

00:35:22.230 --> 00:35:28.109
看看服务器是什么

00:35:23.820 --> 00:35:30.930
为API完成照片好的API 

00:35:28.109 --> 00:35:32.760
由两部分组成，一部分用于HTTP 

00:35:30.930 --> 00:35:36.300
服务器请求另一个用于

00:35:32.760 --> 00:35:38.760
 HTTP服务器响应我们的请求

00:35:36.300 --> 00:35:40.830
有两个ABI，你得分是拖车

00:35:38.760 --> 00:35:44.010
准备好你害怕的另一个

00:35:40.830 --> 00:35:47.130
为您预告片的getcha评论将

00:35:44.010 --> 00:35:50.040
返回地图，所以我们会喜欢fubar 

00:35:47.130 --> 00:35:53.790
诸如此类的东西，然后是HTTP 

00:35:50.040 --> 00:35:56.310
服务器回应您的设置速率为

00:35:53.790 --> 00:35:58.619
查看并摆脱您，现在我想

00:35:56.310 --> 00:36:01.050
强调在右边

00:35:58.619 --> 00:36:02.760
您说得到并设置时的响应

00:36:01.050 --> 00:36:06.359
为你挺身而出，你没有设置地图

00:36:02.760 --> 00:36:08.790
在这里对象，而是您向供应商发送

00:36:06.359 --> 00:36:12.690
在这里反对和供应商

00:36:08.790 --> 00:36:16.230
对象是Jady的新功能Jady ka 

00:36:12.690 --> 00:36:18.359
基本上你只有一种方法

00:36:16.230 --> 00:36:20.640
叫来这里，这是一个

00:36:18.359 --> 00:36:22.290
功能的函数式接口

00:36:20.640 --> 00:36:26.490
界面意味着您实际上可以

00:36:22.290 --> 00:36:28.859
在lambda表达式和

00:36:26.490 --> 00:36:32.070
我们为什么先给我们什么的原因

00:36:28.859 --> 00:36:34.440
而不是地图是那个时候

00:36:32.070 --> 00:36:37.170
您尝试设置供应设置

00:36:34.440 --> 00:36:39.869
您可能实际上不知道的预告片字段

00:36:37.170 --> 00:36:41.849
例如，您尝试设置的是

00:36:39.869 --> 00:36:44.460
校验和，您不执行以下校验和

00:36:41.849 --> 00:36:47.099
你的身体，你现在计算一切

00:36:44.460 --> 00:36:51.869
如果您尝试设置拖车的感觉

00:36:47.099 --> 00:36:53.609
早些时候，你必须知道

00:36:51.869 --> 00:36:55.680
让他们知道什么是校验和

00:36:53.609 --> 00:36:57.510
这种情况下我会给你一个供应商

00:36:55.680 --> 00:36:59.790
功能和供应商功能将

00:36:57.510 --> 00:37:02.640
跟踪信息并进行计算

00:36:59.790 --> 00:37:08.369
对应于校验和并放入

00:37:02.640 --> 00:37:13.310
标头好了，现在让我们来看看

00:37:08.369 --> 00:37:16.950
 HDTV服务器请求现在我们可以

00:37:13.310 --> 00:37:22.690
称它摆脱你而没有着色

00:37:16.950 --> 00:37:26.089
他的奖杯准备好了我们能做到吗

00:37:22.690 --> 00:37:28.820
事实证明，我们不能因为

00:37:26.089 --> 00:37:31.369
原因是如果您这样做

00:37:28.820 --> 00:37:34.010
到那时，真正的评论可能还没有

00:37:31.369 --> 00:37:37.550
准备好了还没准备好，你尝试出去

00:37:34.010 --> 00:37:39.710
称它为例外，所以

00:37:37.550 --> 00:37:42.170
正确的方法是的，您有

00:37:39.710 --> 00:37:44.420
 Kogi对您的足迹准备就绪，然后您

00:37:42.170 --> 00:37:46.970
得到布尔值的回报，然后检查

00:37:44.420 --> 00:37:49.160
布尔值是否为真

00:37:46.970 --> 00:37:55.460
然后你会得到你的踪迹， 

00:37:49.160 --> 00:37:58.460
那你现在回去就好了

00:37:55.460 --> 00:38:01.760
关于请求方，我们有

00:37:58.460 --> 00:38:04.579
回应然后再回应

00:38:01.760 --> 00:38:07.700
在您确定自己的足迹之前

00:38:04.579 --> 00:38:10.099
 API，在这里您将获得供应商

00:38:07.700 --> 00:38:12.680
供应商将是lambda 

00:38:10.099 --> 00:38:14.690
在这种情况下，他们将创建

00:38:12.680 --> 00:38:17.329
清除哈希图，然后他们

00:38:14.690 --> 00:38:20.119
如果使用，现在在此处填充对象

00:38:17.329 --> 00:38:24.079
 JDK 9有一个新功能，称为

00:38:20.119 --> 00:38:27.410
映射，您实际上可以简化

00:38:24.079 --> 00:38:30.020
表达式在这里，我会让你找到

00:38:27.410 --> 00:38:34.790
 Java表，否则您将拒绝GDK 

00:38:30.020 --> 00:38:37.790
谈谈，他们会告诉您，现在通知

00:38:34.790 --> 00:38:40.490
在AVR中，没有关于我的回复

00:38:37.790 --> 00:38:42.890
有一个预告片字段，你也

00:38:40.490 --> 00:38:45.440
有一套，你就会饱和

00:38:42.890 --> 00:38:49.010
也摆脱了我们为什么

00:38:45.440 --> 00:38:51.440
需要摆脱你，因为你是

00:38:49.010 --> 00:38:54.050
已经对拖车场说过的车主

00:38:51.440 --> 00:39:00.140
你已经知道这是为什么吗

00:38:54.050 --> 00:39:06.079
需要再次得到它，事实证明

00:39:00.140 --> 00:39:09.050
这是有原因的

00:39:06.079 --> 00:39:13.520
您可以在此示例中看到

00:39:09.050 --> 00:39:16.220
在servlet前面过滤，您就

00:39:13.520 --> 00:39:19.910
调用以过滤您内部的过滤器

00:39:16.220 --> 00:39:21.920
将设置预告片视图，然后在

00:39:19.910 --> 00:39:24.349
那时您来到servlet 

00:39:21.920 --> 00:39:28.069
有人已经说过预告片

00:39:24.349 --> 00:39:30.470
服务器也很有趣

00:39:28.069 --> 00:39:32.359
设置预告片视图，但您没有

00:39:30.470 --> 00:39:35.330
想覆盖所有内容

00:39:32.359 --> 00:39:38.150
过滤器正确，你必须知道他

00:39:35.330 --> 00:39:40.310
在这种情况下，少数这样做的您

00:39:38.150 --> 00:39:43.040
先把拖车装满

00:39:40.310 --> 00:39:45.170
您一次又一次地恢复了供应商

00:39:43.040 --> 00:39:47.810
你知道供应商，那么你可以

00:39:45.170 --> 00:39:50.440
根据一些控制另一个供应商

00:39:47.810 --> 00:39:53.780
前一个，然后将其设置回此处

00:39:50.440 --> 00:39:55.640
所以大门的主要目的

00:39:53.780 --> 00:40:01.850
拖车领域就是为了支持这一点

00:39:55.640 --> 00:40:04.220
用例的复合拖车好吗

00:40:01.850 --> 00:40:06.530
关于预告片我能说的一切

00:40:04.220 --> 00:40:08.930
还有更多关于

00:40:06.530 --> 00:40:11.390
我将让服务器继续运行的服务器

00:40:08.930 --> 00:40:12.830
是的，我很快就会知道

00:40:11.390 --> 00:40:15.770
这大概五分钟

00:40:12.830 --> 00:40:18.830
离开了地图发现功能

00:40:15.770 --> 00:40:21.470
完全由社区成员捐赠

00:40:18.830 --> 00:40:23.660
银色是z'，然后我们进行了辩论， 

00:40:21.470 --> 00:40:27.430
在他的专家组中讨论过

00:40:23.660 --> 00:40:29.720
现在在PR服务器上的PR上工作， 

00:40:27.430 --> 00:40:31.910
微观配置工作的一部分

00:40:29.720 --> 00:40:35.240
希望将从中受益

00:40:31.910 --> 00:40:36.770
 EE Foundation允许的东西

00:40:35.240 --> 00:40:39.680
发现当前服务器的状态

00:40:36.770 --> 00:40:42.290
到达您不仅为苏尔工作

00:40:39.680 --> 00:40:44.090
什么不适合过滤器

00:40:42.290 --> 00:40:47.990
容器可以使用的所有各种方式

00:40:44.090 --> 00:40:49.820
调用一个很多正确的servlet，这样

00:40:47.990 --> 00:40:51.320
声称您认为您可以调用servlet 

00:40:49.820 --> 00:40:53.900
通过容器应用映射

00:40:51.320 --> 00:40:57.440
规则或应用程序代码可以调用

00:40:53.900 --> 00:40:59.240
这些方法中的任何一种，如果它们

00:40:57.440 --> 00:41:01.340
使用这种方法，那么有一个

00:40:59.240 --> 00:41:03.110
关联的请求属性集

00:41:01.340 --> 00:41:06.530
伴随着让你

00:41:03.110 --> 00:41:09.700
在它来之前发现它在哪里

00:41:06.530 --> 00:41:12.680
通过获取被冠2.4字或

00:41:09.700 --> 00:41:14.390
包括在内，以便与

00:41:12.680 --> 00:41:18.410
我们已经拥有的艺术

00:41:14.390 --> 00:41:20.870
要求时的规格

00:41:18.410 --> 00:41:23.150
给我发球映射

00:41:20.870 --> 00:41:26.450
返回此不变的服务映射

00:41:23.150 --> 00:41:29.840
它有一个枚举属性，它将告诉

00:41:26.450 --> 00:41:32.650
你是什​​么样的背景

00:41:29.840 --> 00:41:34.850
你知道确切的扩展路线等

00:41:32.650 --> 00:41:37.430
然后它还有一些其他的javabeans 

00:41:34.850 --> 00:41:39.280
属性匹配值是什么

00:41:37.430 --> 00:41:41.770
实际匹配的模式

00:41:39.280 --> 00:41:44.240
被调用的服务器的名称

00:41:41.770 --> 00:41:46.430
并且如果您有多个servlet正在

00:41:44.240 --> 00:41:48.260
打电话，你碰巧叫这个东西

00:41:46.430 --> 00:41:48.770
它会给你一个名字，将是

00:41:48.260 --> 00:41:52.910
当前

00:41:48.770 --> 00:41:55.610
目前正在执行一些

00:41:52.910 --> 00:41:58.580
杂项，我们有一些编码

00:41:55.610 --> 00:42:00.410
我们根据要求做了的澄清

00:41:58.580 --> 00:42:03.770
从电线读取伯爵路径的侧面

00:42:00.410 --> 00:42:06.470
被指定为utf-8，我们没有

00:42:03.770 --> 00:42:08.480
尽管我们允许，但在之前指定

00:42:06.470 --> 00:42:11.360
供应商特定的配置

00:42:08.480 --> 00:42:14.060
阅读伯爵路径部分

00:42:11.360 --> 00:42:18.260
关于xww编码的说明

00:42:14.060 --> 00:42:19.760
伯爵编码形式，我们添加了方法集

00:42:18.260 --> 00:42:22.369
请求字符编码

00:42:19.760 --> 00:42:24.380
 servlet上下文中有一个新的XML 

00:42:22.369 --> 00:42:27.710
元素，您也可以进行设置

00:42:24.380 --> 00:42:35.720
在响应方面，我们有相同的

00:42:27.710 --> 00:42:39.430
事物方法和XML元素还可以， 

00:42:35.720 --> 00:42:39.430
我想你会带我们出去的

00:42:39.700 --> 00:42:47.390
是的，我们在

00:42:44.180 --> 00:42:49.369
服务器照片哦，其中之一是e我们

00:42:47.390 --> 00:42:51.860
添加一些API，以便我们可以

00:42:49.369 --> 00:42:54.680
实现servlet API更容易吃

00:42:51.860 --> 00:42:57.020
第一个是我们有一些锡

00:42:54.680 --> 00:43:00.530
侦听器的默认方法和

00:42:57.020 --> 00:43:03.640
第二个是在其中的过滤器中

00:43:00.530 --> 00:43:06.980
销毁，我们还添加了一个助手类

00:43:03.640 --> 00:43:13.520
用于通用过滤器和HTTP 

00:43:06.980 --> 00:43:15.950
过滤器和架构中的唯一更改

00:43:13.520 --> 00:43:17.780
在Web点XML中，我们添加了一个新的

00:43:15.950 --> 00:43:21.650
称为默认联系人根目录的元素

00:43:17.780 --> 00:43:24.410
过去我们做不到

00:43:21.650 --> 00:43:27.890
 servlet，您必须依靠

00:43:24.410 --> 00:43:30.859
设置联系人根的聚会树方法和

00:43:27.890 --> 00:43:33.680
我们还添加了一个新的API来设置会话

00:43:30.859 --> 00:43:36.920
超时时间（以分钟为单位） 

00:43:33.680 --> 00:43:39.740
然后您还有一个API可添加JSF 

00:43:36.920 --> 00:43:44.950
 R类似于表面的JSP 

00:43:39.740 --> 00:43:46.790
抱歉，我将添加文件继续

00:43:44.950 --> 00:43:48.590
因为你会在

00:43:46.790 --> 00:43:51.260
主题演讲，但还有另一面

00:43:48.590 --> 00:43:53.330
我想让你看到

00:43:51.260 --> 00:43:57.400
主题演讲，但我想给我

00:43:53.330 --> 00:43:57.400
 servlet方面的观点

00:43:58.060 --> 00:44:02.740
实际上，如果您曾经在

00:44:00.400 --> 00:44:04.480
从琳达的谈话中，您可以了解到很多

00:44:02.740 --> 00:44:07.090
这也是，但我可以看到的挑战

00:44:04.480 --> 00:44:09.060
对于servlet和EE对于J 

00:44:07.090 --> 00:44:11.500
事物的名称和蚀

00:44:09.060 --> 00:44:14.620
 servlet一直在修订

00:44:11.500 --> 00:44:17.440
与整个EEE平台保持同步

00:44:14.620 --> 00:44:19.900
 e4j的既定目标是使其

00:44:17.440 --> 00:44:20.410
更加敏捷，将很难做到这一点

00:44:19.900 --> 00:44:23.170
对

00:44:20.410 --> 00:44:27.280
还有Sarila的后退率很高

00:44:23.170 --> 00:44:30.400
兼容性期望和重要

00:44:27.280 --> 00:44:31.960
 Servlet EG成员不是完整的Java EE 

00:44:30.400 --> 00:44:34.510
供应商，这样问题就不得不

00:44:31.960 --> 00:44:36.820
得到解决，我们一直都有

00:44:34.510 --> 00:44:39.390
这个小二分法，码头和

00:44:36.820 --> 00:44:42.640
 Tomcat最流行的一些

00:44:39.390 --> 00:44:45.160
容器没有完整的Java 

00:44:42.640 --> 00:44:48.400
您不会通过EJB获得EE容器

00:44:45.160 --> 00:44:50.740
默认为例如CDI，那是

00:44:48.400 --> 00:44:53.050
所谓大的区别

00:44:50.740 --> 00:44:57.180
完整的Java EE供应商WebLogic和

00:44:53.050 --> 00:44:59.710
 WebSphere和GlassFish并同时配对

00:44:57.180 --> 00:45:02.680
而且还有很多

00:44:59.710 --> 00:45:06.280
实现，因此servlet已经

00:45:02.680 --> 00:45:08.200
拥有成功的一个很好的例子

00:45:06.280 --> 00:45:10.810
 JCP的努力，但这将是一个

00:45:08.200 --> 00:45:12.760
拥有所有这些利益相关者的挑战

00:45:10.810 --> 00:45:14.920
多年来，这一直是我的挑战

00:45:12.760 --> 00:45:18.670
 servlet EG可以保留所有这些

00:45:14.920 --> 00:45:20.170
眼镜的利益相关者同意

00:45:18.670 --> 00:45:22.150
有很大的不同

00:45:20.170 --> 00:45:26.760
意见，我们将看看情况如何

00:45:22.150 --> 00:45:29.440
是的，正如我所说的

00:45:26.760 --> 00:45:32.770
敏捷灵活开放兼容，您将

00:45:29.440 --> 00:45:36.420
看到在主题演讲，那是

00:45:32.770 --> 00:45:38.890
将Java EE迁移到e4j的摘要，以及

00:45:36.420 --> 00:45:44.350
让我们用字符串Y将我们封闭

00:45:38.890 --> 00:45:48.010
整个谈话的摘要

00:45:44.350 --> 00:45:52.030
总结服务器照片哦带

00:45:48.010 --> 00:45:54.280
 HTTP到Java EE平台的操作

00:45:52.030 --> 00:45:57.190
是对

00:45:54.280 --> 00:45:59.620
网站，我们也很落后

00:45:57.190 --> 00:46:03.070
兼容，您可以下载

00:45:59.620 --> 00:46:05.500
草鱼全力以赴，尝试新的

00:46:03.070 --> 00:46:06.820
服务器文件夹中的功能哦

00:46:05.500 --> 00:46:10.600
现在我想做的一件事

00:46:06.820 --> 00:46:11.430
现在提起phyto只运行一次

00:46:10.600 --> 00:46:15.420
上

00:46:11.430 --> 00:46:18.270
 gdka不能在jdk noggins上运行， 

00:46:15.420 --> 00:46:23.700
我们正在进行版本斗争或1 

00:46:18.270 --> 00:46:25.500
它将与Java SE 9一起运行

00:46:23.700 --> 00:46:30.309
谢谢

00:46:25.500 --> 00:46:30.309
 [掌声] 

