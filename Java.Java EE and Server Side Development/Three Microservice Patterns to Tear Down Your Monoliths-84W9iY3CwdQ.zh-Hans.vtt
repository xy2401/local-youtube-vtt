WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.200 --> 00:00:08.360
大家好，很高兴看到你

00:00:06.110 --> 00:00:10.519
今天有这么多人，我们要

00:00:08.360 --> 00:00:12.920
谈谈三项微服务专利

00:00:10.519 --> 00:00:17.060
你可以用来拆除你的

00:00:12.920 --> 00:00:19.519
单片s-并且有一些

00:00:17.060 --> 00:00:22.550
挑战我们的微服务

00:00:19.519 --> 00:00:24.529
当然微服务很好，但是如何

00:00:22.550 --> 00:00:26.449
你管理好你的笔记吗

00:00:24.529 --> 00:00:28.609
协调您的笔记以及如何

00:00:26.449 --> 00:00:31.159
确保你有一致性

00:00:28.609 --> 00:00:33.850
整个笔记，你怎么能

00:00:31.159 --> 00:00:36.379
测试它们，如何真正创建

00:00:33.850 --> 00:00:37.969
错误的国家，我的意思是

00:00:36.379 --> 00:00:40.640
程序员，所以我们从不做任何事情

00:00:37.969 --> 00:00:44.059
我们是否做错

00:00:40.640 --> 00:00:47.059
至少我是的

00:00:44.059 --> 00:00:49.100
那很好，怪游戏是

00:00:47.059 --> 00:00:51.109
重要的，所以我们要谈论

00:00:49.100 --> 00:00:53.329
这里我们要讨论的三种模式

00:00:51.109 --> 00:00:54.800
关于事件源，我们要谈谈

00:00:53.329 --> 00:00:57.440
关于所谓的物化

00:00:54.800 --> 00:01:00.109
意见和siku orest代表

00:00:57.440 --> 00:01:02.960
命令查询责任分离

00:01:00.109 --> 00:01:05.269
我只想简单地提一下

00:01:02.960 --> 00:01:07.490
现在是事件源

00:01:05.269 --> 00:01:08.960
而不是写结果或

00:01:07.490 --> 00:01:10.460
例如，如果您增加

00:01:08.960 --> 00:01:12.310
某人的工资有一百美元

00:01:10.460 --> 00:01:15.740
你不说

00:01:12.310 --> 00:01:18.890
薪水等于薪水加100，但您

00:01:15.740 --> 00:01:20.899
说工资增加了100 

00:01:18.890 --> 00:01:23.600
您可以重播该事件的不同之处

00:01:20.899 --> 00:01:25.610
稍后，您可以查看和跟踪

00:01:23.600 --> 00:01:28.329
后续的整个状态

00:01:25.610 --> 00:01:31.070
该人的一定工资

00:01:28.329 --> 00:01:32.899
唯物主义者的观点消耗了这些事件

00:01:31.070 --> 00:01:35.689
并产生一些您可以查看的东西

00:01:32.899 --> 00:01:38.930
例如，这是当前的工资

00:01:35.689 --> 00:01:40.969
命令查询的职责是

00:01:38.930 --> 00:01:42.860
你基本上是写和读

00:01:40.969 --> 00:01:45.320
不同的对象，所以写作和

00:01:42.860 --> 00:01:48.229
阅读是分离的，这非常

00:01:45.320 --> 00:01:51.380
重要，所以艾米丽在这里将展示

00:01:48.229 --> 00:01:54.229
顺便说一句预订系统的演示

00:01:51.380 --> 00:01:55.369
安培我发明了很多东西

00:01:54.229 --> 00:01:58.310
一直在使用Java 

00:01:55.369 --> 00:02:00.350
从1.0开始住在这里Palo Alto 

00:01:58.310 --> 00:02:02.060
我和加利福尼亚都有博客，请确保

00:02:00.350 --> 00:02:06.109
用数以百万计的

00:02:02.060 --> 00:02:08.210
读是，我的名字是Emil fortuned，我

00:02:06.109 --> 00:02:10.399
也在同一公司perahera工作

00:02:08.210 --> 00:02:13.160
我和Speedman还是开发人员居住地

00:02:10.399 --> 00:02:15.530
在帕洛阿尔托，我的博客叫做

00:02:13.160 --> 00:02:17.109
 Java的时代，但我也想

00:02:15.530 --> 00:02:18.879
介绍我们的吉祥物

00:02:17.109 --> 00:02:20.739
那是生活中的开源吉祥物

00:02:18.879 --> 00:02:22.090
在github上有3年的吉祥物

00:02:20.739 --> 00:02:27.430
经验，你可以检查他

00:02:22.090 --> 00:02:30.099
后来，是的，很酷，是的，所以速度是多少

00:02:27.430 --> 00:02:35.500
马特·斯皮德曼（Matt Speedman）可以

00:02:30.099 --> 00:02:38.920
从流中产生续集查询

00:02:35.500 --> 00:02:40.959
不要遗漏，知道我应该这样，如果

00:02:38.920 --> 00:02:42.549
你有一个流，它可以

00:02:40.959 --> 00:02:45.040
产生相等，所以你不必写

00:02:42.549 --> 00:02:47.230
您可以使用自己的续集查询

00:02:45.040 --> 00:02:49.209
溪流和溪流都很好，因为我们所有人

00:02:47.230 --> 00:02:51.760
自从工作八，甚至现在知道

00:02:49.209 --> 00:02:53.889
与Java九，他们甚至更好

00:02:51.760 --> 00:02:55.389
那基本上是速度的意思，什么时候

00:02:53.889 --> 00:02:57.489
你看它还有更多

00:02:55.389 --> 00:02:59.799
续集之间非常相似

00:02:57.489 --> 00:03:02.409
和流操作，以便您可以

00:02:59.799 --> 00:03:05.379
基本上可以构造任何东西

00:03:02.409 --> 00:03:08.799
续集流，您不必

00:03:05.379 --> 00:03:11.409
生活在两种语言的世界中

00:03:08.799 --> 00:03:14.079
那我写了，然后写了一篇文章

00:03:11.409 --> 00:03:16.480
关于Java的最新一期

00:03:14.079 --> 00:03:18.879
杂志，所以如果您想了解更多

00:03:16.480 --> 00:03:22.030
关于这个，你可以上网检查

00:03:18.879 --> 00:03:25.209
那你认出桌子

00:03:22.030 --> 00:03:26.829
例如今天我们不打算

00:03:25.209 --> 00:03:30.819
谈论这么多，因为我们不能

00:03:26.829 --> 00:03:32.409
进一步讨论微服务，所以我

00:03:30.819 --> 00:03:35.709
只想说这是什么

00:03:32.409 --> 00:03:37.689
将流转换为它做的续集

00:03:35.709 --> 00:03:39.159
惰性流，因此，如果您创建流

00:03:37.689 --> 00:03:40.989
只消耗三四个

00:03:39.159 --> 00:03:43.870
您不必全部投入的元素

00:03:40.989 --> 00:03:46.449
来自数据库的那些结果集

00:03:43.870 --> 00:03:49.720
它只会按原样拉入元素

00:03:46.449 --> 00:03:51.519
被消耗了，我们有完整的类型

00:03:49.720 --> 00:03:54.400
安全，因为当您构造自己的

00:03:51.519 --> 00:03:56.379
您的流，如果是，则不能使用int 

00:03:54.400 --> 00:03:58.599
例如字符串，反之亦然

00:03:56.379 --> 00:04:01.569
一件很酷的事情是，您可以使用

00:03:58.599 --> 00:04:03.370
并行数据库查询

00:04:01.569 --> 00:04:07.569
真的很难做

00:04:03.370 --> 00:04:10.060
使用JDBC，它是纯Java， 

00:04:07.569 --> 00:04:12.939
同时支持Java 9和Java 

00:04:10.060 --> 00:04:14.769
转到github并尝试使用

00:04:12.939 --> 00:04:15.879
我将交给电子邮件发送

00:04:14.769 --> 00:04:19.900
几乎整个演示文稿

00:04:15.879 --> 00:04:21.519
今天，是的，谢谢，我要

00:04:19.900 --> 00:04:24.639
要做大多数的微服务

00:04:21.519 --> 00:04:26.409
东西，所以首先我想

00:04:24.639 --> 00:04:27.880
解释一些我要使用的术语

00:04:26.409 --> 00:04:29.529
在整个演示文稿中使用

00:04:27.880 --> 00:04:30.340
确保通用语言

00:04:29.529 --> 00:04:32.949
和vocab 

00:04:30.340 --> 00:04:36.100
并让任何人感到困惑

00:04:32.949 --> 00:04:38.500
谈论客户的，您可能会认为

00:04:36.100 --> 00:04:40.660
我们是指最终用户，但是当您

00:04:38.500 --> 00:04:43.330
谈论客户的微服务

00:04:40.660 --> 00:04:45.760
所有可以调用服务的东西

00:04:43.330 --> 00:04:47.530
另一个服务可能是客户，所以您

00:04:45.760 --> 00:04:49.660
不要对

00:04:47.530 --> 00:04:51.639
另一个服务调用您的API或

00:04:49.660 --> 00:04:54.699
最终用户调用您的API 

00:04:51.639 --> 00:04:56.949
客户您也有服务和

00:04:54.699 --> 00:04:59.169
服务是可以称为的东西

00:04:56.949 --> 00:05:01.360
由客户他们是某种

00:04:59.169 --> 00:05:03.610
业务逻辑，它独立存在

00:05:01.360 --> 00:05:04.630
可以自己部署，也可以

00:05:03.610 --> 00:05:06.310
部署在同一台机器上或

00:05:04.630 --> 00:05:09.580
其他的东西，但它仍然是自己的

00:05:06.310 --> 00:05:12.160
一个服务可以存在多个

00:05:09.580 --> 00:05:14.680
实例，这意味着您可以扩展

00:05:12.160 --> 00:05:16.510
分别进行放大和缩小

00:05:14.680 --> 00:05:20.169
当我们谈论一个实例时，我们的意思是

00:05:16.510 --> 00:05:21.990
服务实例和服务

00:05:20.169 --> 00:05:24.789
可以访问端点

00:05:21.990 --> 00:05:26.950
端点是您所使用的URL的种类

00:05:24.789 --> 00:05:30.460
使用看这是您与他人互动的方式

00:05:26.950 --> 00:05:34.419
服务，所以这只是一些短

00:05:30.460 --> 00:05:36.310
因此，在此过程中

00:05:34.419 --> 00:05:38.770
我们将要进行的演示

00:05:36.310 --> 00:05:40.410
抱歉，我为此太老了

00:05:38.770 --> 00:05:43.360
认为我们将要谈论

00:05:40.410 --> 00:05:45.460
所谓的预订系统

00:05:43.360 --> 00:05:48.099
这是我们的应用程序

00:05:45.460 --> 00:05:50.020
今晚要在这里建造，所以

00:05:48.099 --> 00:05:54.310
烘焙预订系统的目的是

00:05:50.020 --> 00:05:55.870
允许用户预订资源，我们

00:05:54.310 --> 00:05:57.550
并没有真正定义什么是资源

00:05:55.870 --> 00:06:00.190
因为我希望你能够想象

00:05:57.550 --> 00:06:02.530
遇到任何情况

00:06:00.190 --> 00:06:05.950
通常可以使用，但可能是汽车

00:06:02.530 --> 00:06:07.510
可能是在租洗衣服

00:06:05.950 --> 00:06:09.430
您正在居住的机器

00:06:07.510 --> 00:06:10.870
隔间可以是任何一种

00:06:09.430 --> 00:06:14.740
您想要确保的事情

00:06:10.870 --> 00:06:16.479
用户可以预订，我们也将

00:06:14.740 --> 00:06:18.250
支持多个用户，所以有

00:06:16.479 --> 00:06:19.990
那里有多个用户

00:06:18.250 --> 00:06:23.650
可以预订的多种资源

00:06:19.990 --> 00:06:26.229
而且我们只能允许每个用户

00:06:23.650 --> 00:06:28.000
每个时隙的资源，这意味着

00:06:26.229 --> 00:06:31.150
我们的系统必须确保我们可以

00:06:28.000 --> 00:06:32.349
永远不会重复预订用户可以做的任何事情

00:06:31.150 --> 00:06:34.090
也重新安排

00:06:32.349 --> 00:06:35.770
他们可以说的事，哦，等等我

00:06:34.090 --> 00:06:37.330
提到我想预订

00:06:35.770 --> 00:06:39.640
星期一我实际上想参加

00:06:37.330 --> 00:06:41.950
星期二是那样，否则他们可以竞争

00:06:39.640 --> 00:06:43.450
在结束时间取消预订，因此

00:06:41.950 --> 00:06:44.260
意味着系统必须具有弹性

00:06:43.450 --> 00:06:46.240
改变

00:06:44.260 --> 00:06:49.450
用户可以更改条件

00:06:46.240 --> 00:06:51.280
一生中，我们也

00:06:49.450 --> 00:06:52.840
限制它，以便每个用户都可以

00:06:51.280 --> 00:06:55.390
最多只能预订

00:06:52.840 --> 00:06:57.850
同时打开，所以这些

00:06:55.390 --> 00:06:59.320
条件带来一些挑战

00:06:57.850 --> 00:07:02.710
从那时起使用微服务

00:06:59.320 --> 00:07:04.480
它要求我们保持同步

00:07:02.710 --> 00:07:06.310
不同机器之间的状态

00:07:04.480 --> 00:07:09.550
并不是你倾向于做的事情

00:07:06.310 --> 00:07:10.990
事情是最简单的实现方法

00:07:09.550 --> 00:07:14.410
该系统将创建一个

00:07:10.990 --> 00:07:16.750
从整体中得到整体，基本上是一个

00:07:14.410 --> 00:07:18.990
存储的单个Java应用程序

00:07:16.750 --> 00:07:22.060
关系数据库中的事物

00:07:18.990 --> 00:07:24.580
每当用户发送请求（例如

00:07:22.060 --> 00:07:27.310
发布获取请求请求等

00:07:24.580 --> 00:07:29.800
基本上只是授权的请求

00:07:27.310 --> 00:07:31.440
哪个用户正在执行此操作，然后更改

00:07:29.800 --> 00:07:34.120
数据库取决于用户的操作

00:07:31.440 --> 00:07:36.400
这是有状态的，不是

00:07:34.120 --> 00:07:39.100
即使我们正在使用post and get 

00:07:36.400 --> 00:07:40.270
等等，以暴露它，所以这是

00:07:39.100 --> 00:07:42.880
我们试图摆脱的那种事情

00:07:40.270 --> 00:07:45.040
从很难

00:07:42.880 --> 00:07:46.600
维护他们很难测试他们

00:07:45.040 --> 00:07:48.280
很难追踪实际上是什么

00:07:46.600 --> 00:07:50.290
之所以发生，是因为一旦数据库

00:07:48.280 --> 00:07:52.180
状态已经改变，你永远无法真正

00:07:50.290 --> 00:07:54.340
返回，除非您开始跟踪审核

00:07:52.180 --> 00:07:57.100
日志或类似的东西，所以

00:07:54.340 --> 00:07:59.920
很难了解什么

00:07:57.100 --> 00:08:02.950
确实在8月23日发生

00:07:59.920 --> 00:08:05.890
发生了，那有点丢进

00:08:02.950 --> 00:08:07.540
日志以及您想执行的任何操作

00:08:05.890 --> 00:08:09.580
像您这样的维护

00:08:07.540 --> 00:08:11.620
定期更新您的这些产品

00:08:09.580 --> 00:08:13.870
必须取下来或暂时

00:08:11.620 --> 00:08:16.330
用其他服务替换它

00:08:13.870 --> 00:08:18.550
可能很难维护

00:08:16.330 --> 00:08:20.620
持续集成环境

00:08:18.550 --> 00:08:24.730
这就是我们想要得到的东西

00:08:20.620 --> 00:08:27.220
远离，如果您要可视化

00:08:24.730 --> 00:08:30.280
这种系统看起来很简单

00:08:27.220 --> 00:08:31.690
我的意思是，只有三件事

00:08:30.280 --> 00:08:34.419
与孩子互动非常

00:08:31.690 --> 00:08:38.140
很好，很清楚，所以这应该是

00:08:34.419 --> 00:08:39.490
很好，事实证明，一旦

00:08:38.140 --> 00:08:41.849
您开始管理这类系统

00:08:39.490 --> 00:08:44.290
这并不像看起来那样容易，因为

00:08:41.849 --> 00:08:46.000
首先，您想扩大规模

00:08:44.290 --> 00:08:47.950
必须基本上扩大整个规模

00:08:46.000 --> 00:08:50.560
你无法扩大一个人的事情

00:08:47.950 --> 00:08:52.890
功能性原则，因此意味着更多

00:08:50.560 --> 00:08:55.300
许可成本意味着更多的机器

00:08:52.890 --> 00:08:56.769
做可能不是的事情

00:08:55.300 --> 00:08:59.499
真的必要

00:08:56.769 --> 00:09:01.600
你也没有很好的回应

00:08:59.499 --> 00:09:03.009
最终用户，因为每次用户

00:09:01.600 --> 00:09:04.720
每次用户时我们都会做一些事情

00:09:03.009 --> 00:09:06.309
想做他们发送的东西

00:09:04.720 --> 00:09:07.839
一个请求，它必须一直走下去

00:09:06.309 --> 00:09:10.420
一直到数据库

00:09:07.839 --> 00:09:12.610
有时需要多次回应

00:09:10.420 --> 00:09:13.959
单个查询以授权用户

00:09:12.610 --> 00:09:17.079
确保您被允许这样做

00:09:13.959 --> 00:09:19.059
那以及所有这些东西很多

00:09:17.079 --> 00:09:20.619
我见过的系统需要几秒钟

00:09:19.059 --> 00:09:22.839
完成一项业务

00:09:20.619 --> 00:09:24.610
交易仅仅是因为您必须

00:09:22.839 --> 00:09:26.709
转到数据库

00:09:24.610 --> 00:09:28.540
回来，然后人们抱怨

00:09:26.709 --> 00:09:30.459
数据库，但实际上不是数据库

00:09:28.540 --> 00:09:33.369
这很慢，这是一般

00:09:30.459 --> 00:09:38.110
系统设计的所有用户都可以

00:09:33.369 --> 00:09:40.119
或用户，这就是您的那种

00:09:38.110 --> 00:09:41.949
知道只是重新构想我们拥有的系统

00:09:40.119 --> 00:09:45.369
今天，以便我们有潜力

00:09:41.949 --> 00:09:47.649
创造性的改进，我们也有

00:09:45.369 --> 00:09:50.139
不会因故障而正常降级，因此

00:09:47.649 --> 00:09:51.730
如果我想你知道拔掉这一个

00:09:50.139 --> 00:09:54.009
机器，整个系统故障

00:09:51.730 --> 00:09:56.769
用户得到您知道奇怪的错误

00:09:54.009 --> 00:09:58.809
代码在您的浏览器中，所以我们想要

00:09:56.769 --> 00:09:59.980
单一故障不会发生的事情

00:09:58.809 --> 00:10:02.259
影响整个的完整性

00:09:59.980 --> 00:10:04.509
系统基本上可以插入任何类型

00:10:02.259 --> 00:10:08.199
系统外墙和系统

00:10:04.509 --> 00:10:10.089
将继续工作，所以相反，我们

00:10:08.199 --> 00:10:11.259
结合这三种设计模式

00:10:10.089 --> 00:10:13.420
我们今晚在这里谈论

00:10:11.259 --> 00:10:15.759
这就是事件来源的物化视图

00:10:13.420 --> 00:10:19.299
和萨加里斯司令部查询种族隔离

00:10:15.759 --> 00:10:20.799
责任和命令色点

00:10:19.299 --> 00:10:23.230
建立隔离的方式

00:10:20.799 --> 00:10:26.470
而不是存储国家

00:10:23.230 --> 00:10:28.809
我们基本上是存储更改，所以当

00:10:26.470 --> 00:10:31.480
用户想预订我们允许的东西

00:10:28.809 --> 00:10:33.970
他们预订了我们不控制的

00:10:31.480 --> 00:10:35.920
你知道接受者还是不接受我们

00:10:33.970 --> 00:10:38.160
即将发生的事件，我们进行注册

00:10:35.920 --> 00:10:40.899
在数据库中，因此数据库是

00:10:38.160 --> 00:10:44.499
只是事件日志

00:10:40.899 --> 00:10:46.540
发生在事件发生时

00:10:44.499 --> 00:10:48.850
被其中一种服务所消耗

00:10:46.540 --> 00:10:51.939
服务必须评估是这个事件

00:10:48.850 --> 00:10:54.249
是否接受，所以这有点

00:10:51.939 --> 00:10:55.660
我知道你不想

00:10:54.249 --> 00:10:58.059
如果不是的话，将其存储在数据库中

00:10:55.660 --> 00:10:59.649
应该在那里就好了

00:10:58.059 --> 00:11:02.829
这些实际上解决了很多

00:10:59.649 --> 00:11:04.269
问题，因为如果你有一个

00:11:02.829 --> 00:11:06.339
具有所有内容的单个日志

00:11:04.269 --> 00:11:08.169
发生了，你让每一个人

00:11:06.339 --> 00:11:10.250
为自己服务

00:11:08.169 --> 00:11:11.840
订阅此日志

00:11:10.250 --> 00:11:13.610
事件，并在每次事件时对其进行评估

00:11:11.840 --> 00:11:15.680
阅读它们意味着您可以扩展

00:11:13.610 --> 00:11:17.630
服务的实例数量最多

00:11:15.680 --> 00:11:19.580
你想要，因为他们所有人都会

00:11:17.630 --> 00:11:22.150
他们最终的一致性

00:11:19.580 --> 00:11:26.090
最终处于完全相同的状态

00:11:22.150 --> 00:11:27.890
以便允许用户依次进行互动

00:11:26.090 --> 00:11:30.230
与系统，你必须允许

00:11:27.890 --> 00:11:33.230
用户可以访问此事件

00:11:30.230 --> 00:11:35.570
流并允许他们订阅

00:11:33.230 --> 00:11:37.280
事件，但用户没有

00:11:35.570 --> 00:11:38.900
一定要评估他们的事件

00:11:37.280 --> 00:11:40.730
只需要知道一个事件何时发生

00:11:38.900 --> 00:11:42.020
发生在受害者身上，然后他们可以

00:11:40.730 --> 00:11:44.210
从其中一种观点要求

00:11:42.020 --> 00:11:48.050
服务并获得最新视图

00:11:44.210 --> 00:11:50.630
情况和材料视图

00:11:48.050 --> 00:11:53.570
基本上是因为它正在流

00:11:50.630 --> 00:11:55.880
事件和评估事件以及

00:11:53.570 --> 00:11:57.920
接受将它们与当前集成

00:11:55.880 --> 00:11:59.890
国家，所以他们有一个国家，他们采取

00:11:57.920 --> 00:12:02.600
新事件检查此事件正确吗

00:11:59.890 --> 00:12:04.510
对应于州，如果是的话，我

00:12:02.600 --> 00:12:06.950
整合它，否则我将其丢弃

00:12:04.510 --> 00:12:08.570
这样一来，您只能处理一个

00:12:06.950 --> 00:12:13.250
一次发生的事件

00:12:08.570 --> 00:12:16.430
一致性，而此aguar是其中的一部分

00:12:13.250 --> 00:12:19.070
最后一部分，你必须保持

00:12:16.430 --> 00:12:20.810
作者和读者可以分开

00:12:19.070 --> 00:12:23.060
从来没有作家永远不会知道

00:12:20.810 --> 00:12:25.370
当前状态和当前

00:12:23.060 --> 00:12:27.920
你们的物质永远无法知道

00:12:25.370 --> 00:12:29.150
永远不会影响您当前的状态

00:12:27.920 --> 00:12:30.650
必须保留这两个很酷的问题

00:12:29.150 --> 00:12:32.150
分开，否则你会得到

00:12:30.650 --> 00:12:36.770
依赖将非常

00:12:32.150 --> 00:12:42.290
很难解开，所以与

00:12:36.770 --> 00:12:44.360
预订系统，如果有多个用户去

00:12:42.290 --> 00:12:46.490
并尝试在预订相同的资源

00:12:44.360 --> 00:12:48.080
同时应该发生什么

00:12:46.490 --> 00:12:50.540
在这个系统中将会发生的是

00:12:48.080 --> 00:12:53.210
他们中的一个会成功

00:12:50.540 --> 00:12:55.910
会失败，但是会有一个

00:12:53.210 --> 00:12:58.670
他们都知道谁之前的一段时间

00:12:55.910 --> 00:13:00.320
知道了，谁没有呢，那就是

00:12:58.670 --> 00:13:02.030
用户需要输入事件日志

00:13:00.320 --> 00:13:03.860
能够订阅事件日志到

00:13:02.030 --> 00:13:05.870
看到哦，我的活动实际上是

00:13:03.860 --> 00:13:08.060
现在正在处理中，但这是一个

00:13:05.870 --> 00:13:10.210
很高兴告诉您我们有

00:13:08.060 --> 00:13:13.700
参加了活动，我们正在考虑

00:13:10.210 --> 00:13:15.770
并且如果两个预订在

00:13:13.700 --> 00:13:17.570
在同一时间进入同一时间段

00:13:15.770 --> 00:13:19.970
所以两个人都想预定相同的资源

00:13:17.570 --> 00:13:22.250
同时但书已经

00:13:19.970 --> 00:13:23.750
存在，我们只是修改了其中一个

00:13:22.250 --> 00:13:24.270
预订应修改，其他

00:13:23.750 --> 00:13:27.870
一

00:13:24.270 --> 00:13:29.250
保持以前的样子，所以他们

00:13:27.870 --> 00:13:33.420
可以在

00:13:29.250 --> 00:13:35.820
该系统，所以当您刚开始时

00:13:33.420 --> 00:13:37.560
可视化这样的事件或系统

00:13:35.820 --> 00:13:39.420
预订系统，看起来更多

00:13:37.560 --> 00:13:41.880
比它复杂，当我们有

00:13:39.420 --> 00:13:44.400
现场模特，让您看到我有

00:13:41.880 --> 00:13:47.940
映射出来，在这种情况下，请参见客户端

00:13:44.400 --> 00:13:49.590
是最终用户，我已经制定了一个

00:13:47.940 --> 00:13:51.030
边缘服务，我们有服务发现

00:13:49.590 --> 00:13:52.980
服务，我们有某种

00:13:51.030 --> 00:13:54.390
流服务，我们知道我们在做什么

00:13:52.980 --> 00:13:56.430
呼叫日历和预订服务

00:13:54.390 --> 00:13:58.650
他们是读和写的

00:13:56.430 --> 00:13:59.910
服务，我们有数据库，然后我们有

00:13:58.650 --> 00:14:01.140
配置服务的商店

00:13:59.910 --> 00:14:04.410
整个配置设置

00:14:01.140 --> 00:14:06.540
那里有七个服务

00:14:04.410 --> 00:14:09.120
这怎么可能更简单？我们有什么

00:14:06.540 --> 00:14:10.650
在此之前，您必须考虑

00:14:09.120 --> 00:14:13.740
考虑到这些中的每一个

00:14:10.650 --> 00:14:15.930
服务在代码上真的很小，因为

00:14:13.740 --> 00:14:17.460
他们只有一个目的，所以

00:14:15.930 --> 00:14:19.320
有一点让你明白

00:14:17.460 --> 00:14:20.760
他们都在做，但是当你实际上

00:14:19.320 --> 00:14:22.440
看看他们的源代码

00:14:20.760 --> 00:14:24.930
发现大多数这些服务是

00:14:22.440 --> 00:14:27.210
简单的工具，您基本上可以

00:14:24.930 --> 00:14:29.100
只需将其从网络上复制粘贴

00:14:27.210 --> 00:14:31.770
将适合您的情况，可能必须

00:14:29.100 --> 00:14:33.720
更改一些参数，因为当您

00:14:31.770 --> 00:14:37.110
使每个服务都符合这个特定条件

00:14:33.720 --> 00:14:40.620
一个目的，真的很容易测试

00:14:37.110 --> 00:14:41.880
理论上看到释放的工具，所以如果

00:14:40.620 --> 00:14:44.400
你只是想像发生了什么

00:14:41.880 --> 00:14:47.100
这里说用户想说我们

00:14:44.400 --> 00:14:48.960
想要首先部署此系统

00:14:47.100 --> 00:14:50.940
我们的服务需要自己注册

00:14:48.960 --> 00:14:53.460
在服务发现事件中

00:14:50.940 --> 00:14:55.350
发现服务，在这种情况下，我是

00:14:53.460 --> 00:14:57.300
使用尤里卡，但您可以使用任何一种

00:14:55.350 --> 00:14:59.280
很好的服务在这里意味着什么

00:14:57.300 --> 00:15:01.410
注册告诉我更多有关此的信息

00:14:59.280 --> 00:15:03.600
是的，所以当我送达寄存器时

00:15:01.410 --> 00:15:06.060
它本身告诉服务发现

00:15:03.600 --> 00:15:08.730
服务它在哪里以及什么

00:15:06.060 --> 00:15:11.160
它可以提供服务的种类

00:15:08.730 --> 00:15:13.350
嘿，我在这个IP地址上

00:15:11.160 --> 00:15:16.890
这门廊，这些是休息的关键

00:15:13.350 --> 00:15:18.390
我可以实现的端点

00:15:16.890 --> 00:15:20.430
服务发现服务不是真的

00:15:18.390 --> 00:15:22.050
基本上做很多这些信息

00:15:20.430 --> 00:15:24.180
将信息发送到边缘

00:15:22.050 --> 00:15:26.880
服务说嘿新服务有

00:15:24.180 --> 00:15:30.090
被发现，有这些

00:15:26.880 --> 00:15:33.110
在这些端点，然后在边缘

00:15:30.090 --> 00:15:36.060
服务种类保持这些分类帐

00:15:33.110 --> 00:15:37.860
我可以将进来的人路由到哪里

00:15:36.060 --> 00:15:39.510
我有什么服务

00:15:37.860 --> 00:15:42.149
这些服务的实例存在，并且

00:15:39.510 --> 00:15:44.610
然后，只要用户要求

00:15:42.149 --> 00:15:47.399
服务人员知道该发送到哪里

00:15:44.610 --> 00:15:49.470
请求这样的好东西

00:15:47.399 --> 00:15:50.850
设计就是服务永远不需要

00:15:49.470 --> 00:15:52.620
知道其他服务在哪里

00:15:50.850 --> 00:15:55.200
位于，或者如果他们甚至是和

00:15:52.620 --> 00:15:56.610
运行，因为它们都必须使用

00:15:55.200 --> 00:15:58.260
与服务沟通

00:15:56.610 --> 00:16:00.209
发现服务，然后边缘

00:15:58.260 --> 00:16:04.470
服务是负责任的

00:16:00.209 --> 00:16:06.630
路由流量，让您拒绝

00:16:04.470 --> 00:16:08.190
这里曾经有本书资源

00:16:06.630 --> 00:16:11.040
联系边缘服务

00:16:08.190 --> 00:16:14.100
仅公开可用的服务

00:16:11.040 --> 00:16:15.810
为用户提供边缘服务

00:16:14.100 --> 00:16:18.120
将请求路由到预订

00:16:15.810 --> 00:16:20.519
服务，因为它是关于写作

00:16:18.120 --> 00:16:24.089
关于预订资源的一些事情

00:16:20.519 --> 00:16:27.269
在特定时间和预订

00:16:24.089 --> 00:16:30.209
发送的同时完成服务

00:16:27.269 --> 00:16:32.519
那种推动信息

00:16:30.209 --> 00:16:34.860
到创建事件的数据库

00:16:32.519 --> 00:16:37.440
在数据库中作为新行，它也

00:16:34.860 --> 00:16:39.660
同时发回收据给

00:16:37.440 --> 00:16:41.370
对用户说我有

00:16:39.660 --> 00:16:43.380
收到您参加过的活动

00:16:41.370 --> 00:16:45.540
分配了这个特定的序列号

00:16:43.380 --> 00:16:48.240
这真的很重要，因为

00:16:45.540 --> 00:16:50.250
客户需要知道何时

00:16:48.240 --> 00:16:53.190
该事件正在处理中

00:16:50.250 --> 00:16:55.740
发生，所以预订服务没有

00:16:53.190 --> 00:16:57.839
评估并没有说这

00:16:55.740 --> 00:16:59.610
基本上是否允许该事件

00:16:57.839 --> 00:17:04.679
有寄存器和返回包

00:16:59.610 --> 00:17:06.959
接收数据库，然后信息去

00:17:04.679 --> 00:17:09.089
从日历中的PDB向下

00:17:06.959 --> 00:17:10.230
通过推或池，它不是真的

00:17:09.089 --> 00:17:13.169
软件设计问题

00:17:10.230 --> 00:17:16.020
并说哦，有新的预订

00:17:13.169 --> 00:17:19.530
如果在这里发生事件，那么它是一个真实的日历

00:17:16.020 --> 00:17:21.660
它决定接受或拒绝

00:17:19.530 --> 00:17:23.189
无论哪种情况，它都会将其发送到

00:17:21.660 --> 00:17:25.260
流，在这种情况下，流是

00:17:23.189 --> 00:17:28.079
 WebSocket，以便客户端可以订阅

00:17:25.260 --> 00:17:30.179
基本上这是事件

00:17:28.079 --> 00:17:33.450
我收到了，我决定接受

00:17:30.179 --> 00:17:36.150
或者我决定拒绝它，那

00:17:33.450 --> 00:17:37.590
然后如果客户

00:17:36.150 --> 00:17:40.290
事件是接受客户可以

00:17:37.590 --> 00:17:43.350
然后加入事件查看

00:17:40.290 --> 00:17:45.990
哦，我的要求被接受了，所以我想

00:17:43.350 --> 00:17:48.330
查看系统的最新视图

00:17:45.990 --> 00:17:49.540
所以我发送我想看的请求

00:17:48.330 --> 00:17:52.030
最新的日历视图

00:17:49.540 --> 00:17:55.120
就像我们活动的最后一周

00:17:52.030 --> 00:17:57.130
以及我的活动应该位于哪里

00:17:55.120 --> 00:17:59.620
转到日历视图， 

00:17:57.130 --> 00:18:04.270
日历返回修改后的

00:17:59.620 --> 00:18:06.670
状态，所以这是

00:18:04.270 --> 00:18:08.800
系统以及您获得的优势

00:18:06.670 --> 00:18:10.960
这是因为服务可以

00:18:08.800 --> 00:18:13.570
如果您注意到

00:18:10.960 --> 00:18:15.220
你知道你得到回应了

00:18:13.570 --> 00:18:16.720
从日历服务中

00:18:15.220 --> 00:18:18.610
需要时间的事情

00:18:16.720 --> 00:18:20.140
您不必扩大预订

00:18:18.610 --> 00:18:22.510
系统，您不必扩大规模

00:18:20.140 --> 00:18:23.950
配置服务器或您的数据库

00:18:22.510 --> 00:18:27.520
基本上可以放大日历

00:18:23.950 --> 00:18:28.810
服务，因此，如果您注意到那一部分

00:18:27.520 --> 00:18:30.580
该系统花费的时间比

00:18:28.810 --> 00:18:33.130
还有其他可以扩大的范围

00:18:30.580 --> 00:18:35.020
个人服务，所以您的意思是您

00:18:33.130 --> 00:18:36.730
可以只添加另一个节点，这将

00:18:35.020 --> 00:18:40.360
去服务发现，将

00:18:36.730 --> 00:18:42.850
是的一部分，如果日历

00:18:40.360 --> 00:18:44.620
变慢，您只是部署一个新实例

00:18:42.850 --> 00:18:45.730
日历服务

00:18:44.620 --> 00:18:48.790
发现但有服务

00:18:45.730 --> 00:18:50.560
发现和边缘服务将获得

00:18:48.790 --> 00:18:52.330
关于它的通知将开始

00:18:50.560 --> 00:18:55.540
路由流量以及旧流量

00:18:52.330 --> 00:18:59.770
一个，然后你基本上有两倍

00:18:55.540 --> 00:19:01.810
现在的容量等等

00:18:59.770 --> 00:19:03.610
真的很好，用户也

00:19:01.810 --> 00:19:05.170
得到即时反馈，我的意思是用户

00:19:03.610 --> 00:19:06.940
不必等到事件发生

00:19:05.170 --> 00:19:09.160
一直到数据库

00:19:06.940 --> 00:19:10.900
回到一个非常评价，所有

00:19:09.160 --> 00:19:13.900
用户可以立即得到响应

00:19:10.900 --> 00:19:15.250
从第一个预订服务开始

00:19:13.900 --> 00:19:17.830
说您的活动已被接受

00:19:15.250 --> 00:19:19.690
它正在处理中，因此允许

00:19:17.830 --> 00:19:22.450
前端开发人员例如

00:19:19.690 --> 00:19:25.180
显示一个很好的动画，例如

00:19:22.450 --> 00:19:28.360
在等待的同时，他们可以得到

00:19:25.180 --> 00:19:31.750
真正反应灵敏的感觉

00:19:28.360 --> 00:19:35.050
系统和服务也可以

00:19:31.750 --> 00:19:37.060
单独维护，如果您

00:19:35.050 --> 00:19:39.880
在系统上工作，您正在

00:19:37.060 --> 00:19:41.500
实施它，如果您正在努力

00:19:39.880 --> 00:19:42.640
您甚至没有的书先生系统

00:19:41.500 --> 00:19:45.670
必须具有源代码或免费

00:19:42.640 --> 00:19:47.890
 kallergis系统正在运行，如果您

00:19:45.670 --> 00:19:49.540
不想部署一个新实例

00:19:47.890 --> 00:19:52.540
影响已经运行的实例

00:19:49.540 --> 00:19:54.580
您可以将它们热交换到

00:19:52.540 --> 00:19:59.020
新实例删除旧实例，然后

00:19:54.580 --> 00:20:00.910
如果以下情况，系统也将保持完好无损

00:19:59.020 --> 00:20:03.340
如果一项服务出现问题

00:20:00.910 --> 00:20:05.830
失败，例如存在错误

00:20:03.340 --> 00:20:07.750
工作系统突然变得如此差事

00:20:05.830 --> 00:20:09.130
输入kima和所有预订服务

00:20:07.750 --> 00:20:10.840
没事了

00:20:09.130 --> 00:20:12.850
用户仍然可以看到

00:20:10.840 --> 00:20:15.190
日历，因为他们仍然可以访问

00:20:12.850 --> 00:20:16.690
日历服务，所以这真的是

00:20:15.190 --> 00:20:18.610
对于...的弹性很重要

00:20:16.690 --> 00:20:20.920
整个系统应该有一个错误

00:20:18.610 --> 00:20:22.420
不影响其他人，所以当然在那里

00:20:20.920 --> 00:20:24.490
这是一些服务

00:20:22.420 --> 00:20:26.170
设计比其他更重要

00:20:24.490 --> 00:20:28.960
服务发现失败了

00:20:26.170 --> 00:20:31.060
例子，很快所有的服务都会

00:20:28.960 --> 00:20:32.920
无法互相识别，但

00:20:31.060 --> 00:20:34.690
边缘服务器可能仍可用于

00:20:32.920 --> 00:20:37.480
一段时间，而服务具有相同的

00:20:34.690 --> 00:20:39.850
以前的IP地址，因此

00:20:37.480 --> 00:20:42.790
即使没有，系统也可以保持完整

00:20:39.850 --> 00:20:44.290
服务发现一段时间，除非

00:20:42.790 --> 00:20:49.900
你开始杀人的过程说

00:20:44.290 --> 00:20:51.730
组织者，所以如果我们要设计

00:20:49.900 --> 00:20:53.200
作为预订服务，而不是

00:20:51.730 --> 00:20:56.500
有一个关系数据库

00:20:53.200 --> 00:20:58.720
每种实体都有多个表

00:20:56.500 --> 00:21:01.300
在数据库中，我们尝试将所有内容

00:20:58.720 --> 00:21:02.710
在同一张桌子上，这真的

00:21:01.300 --> 00:21:05.920
重要，因为我们必须能够

00:21:02.710 --> 00:21:08.020
以一个定义的顺序播放它，所以我们只

00:21:05.920 --> 00:21:09.850
有一张桌子叫预订活动， 

00:21:08.020 --> 00:21:15.250
它包含有关的所有信息

00:21:09.850 --> 00:21:17.080
那件事发生了一个

00:21:15.250 --> 00:21:18.880
可以存在多个的服务

00:21:17.080 --> 00:21:20.920
实例，但写一个服务

00:21:18.880 --> 00:21:23.470
通过数据库不做评估

00:21:20.920 --> 00:21:24.970
它可能能够消毒一些您

00:21:23.470 --> 00:21:26.980
知道HTTP请求或类似的东西

00:21:24.970 --> 00:21:28.990
那，但是它从不做任何事情

00:21:26.980 --> 00:21:31.540
要求它知道状态

00:21:28.990 --> 00:21:34.120
系统，所以一切都是有效的

00:21:31.540 --> 00:21:37.090
只是HTTP请求基本上是输入它

00:21:34.120 --> 00:21:38.530
然后进入数据库

00:21:37.090 --> 00:21:41.080
数字差异，以便它们可以

00:21:38.530 --> 00:21:42.940
顺序读取，以便数据库提供

00:21:41.080 --> 00:21:44.500
每个新事件的编号，以便他们

00:21:42.940 --> 00:21:46.030
我们知道所有的客户

00:21:44.500 --> 00:21:47.950
不管他们在世界上什么地方

00:21:46.030 --> 00:21:51.670
位于他们都会消耗

00:21:47.950 --> 00:21:53.980
事件以相同的顺序和另一个

00:21:51.670 --> 00:21:56.440
服务评估所有传入

00:21:53.980 --> 00:21:58.240
被编号的事件

00:21:56.440 --> 00:22:00.780
数据库，并实现它们

00:21:58.240 --> 00:22:03.070
用户可以查询的视图

00:22:00.780 --> 00:22:09.400
系统最终是一致的

00:22:03.070 --> 00:22:10.390
在所有实例中进行描述

00:22:09.400 --> 00:22:13.600
关于第一个的更多信息

00:22:10.390 --> 00:22:14.950
这里的事件采购模式，所以我们

00:22:13.600 --> 00:22:16.870
提到关系

00:22:14.950 --> 00:22:18.820
数据库不存储任何状态

00:22:16.870 --> 00:22:21.309
它从不存储该用户拥有此内容

00:22:18.820 --> 00:22:23.769
用户名或类似的名称

00:22:21.309 --> 00:22:25.980
存储具有

00:22:23.769 --> 00:22:28.990
自上次状态以来发生了变化

00:22:25.980 --> 00:22:31.419
如果状态为

00:22:28.990 --> 00:22:33.340
接受与否，只是存储

00:22:31.419 --> 00:22:36.159
我就是这样

00:22:33.340 --> 00:22:37.360
预订服务发生了，所以你

00:22:36.159 --> 00:22:39.370
不需要任何更新或删除

00:22:37.360 --> 00:22:40.929
您只需要插入和的语句

00:22:39.370 --> 00:22:43.419
选择，因为你永远不会

00:22:40.929 --> 00:22:45.519
改变任何事情，因为那是事实

00:22:43.419 --> 00:22:48.279
那时好吧，你是说

00:22:45.519 --> 00:22:49.600
数据库基本上是一个提示，所以

00:22:48.279 --> 00:22:53.830
数据库句柄很大

00:22:49.600 --> 00:22:56.529
持久的提示，你也不会有任何提示

00:22:53.830 --> 00:22:59.950
除主要索引外的索引

00:22:56.529 --> 00:23:02.049
键是序列号，因为

00:22:59.950 --> 00:23:04.119
在这种情况下，索引只会趋向于变慢

00:23:02.049 --> 00:23:05.499
如果数据库必须

00:23:04.119 --> 00:23:07.210
每次不更新索引

00:23:05.499 --> 00:23:09.100
插入它会减慢

00:23:07.210 --> 00:23:10.240
写和读不会走

00:23:09.100 --> 00:23:11.559
无论如何通过数据库

00:23:10.240 --> 00:23:14.350
要经历物化

00:23:11.559 --> 00:23:15.700
查看整个数据库设计

00:23:14.350 --> 00:23:19.360
倒在一张桌子上，没有

00:23:15.700 --> 00:23:21.970
索引和没有关节，这是一个相当

00:23:19.360 --> 00:23:23.830
简单分配和

00:23:21.970 --> 00:23:25.119
你没有冲突的麻烦

00:23:23.830 --> 00:23:26.590
分辨率，因为唯一的东西

00:23:25.119 --> 00:23:29.289
数据库要做的基本上只是

00:23:26.590 --> 00:23:31.149
增加一个整数并插入

00:23:29.289 --> 00:23:32.649
数据库可以处理数千个

00:23:31.149 --> 00:23:36.179
每秒写入，即使您正在使用

00:23:32.649 --> 00:23:36.179
像我的续集这样的开源数据库

00:23:36.269 --> 00:23:42.129
由于事件是在事件发生时进行评估的

00:23:38.799 --> 00:23:45.129
阅读事件的阅读

00:23:42.129 --> 00:23:47.259
不影响读数可缩放

00:23:45.129 --> 00:23:48.759
独立起来，作家没有

00:23:47.259 --> 00:23:51.220
必须了解当前情况

00:23:48.759 --> 00:23:52.690
状态，因此您不必同步

00:23:51.220 --> 00:23:54.490
与骑手一起坐骑

00:23:52.690 --> 00:23:56.139
在那里，对系统一无所知

00:23:54.490 --> 00:23:59.590
您可以将所有内容写入

00:23:56.139 --> 00:24:03.460
数据库-第二种模式

00:23:59.590 --> 00:24:05.529
物化视图和最终用户

00:24:03.460 --> 00:24:07.869
从不查询关系数据库

00:24:05.529 --> 00:24:10.119
他们只查询视图，所以一个请求

00:24:07.869 --> 00:24:12.279
物化视图不会导致

00:24:10.119 --> 00:24:13.629
对数据库的请求，那就是

00:24:12.279 --> 00:24:15.399
重要的事情要进入你的头脑

00:24:13.629 --> 00:24:18.070
因为这意味着可扩展性

00:24:15.399 --> 00:24:20.289
是极端的，你可以拥有数十个

00:24:18.070 --> 00:24:21.940
数亿用户付费

00:24:20.289 --> 00:24:24.309
系统和数据库仍可以使用

00:24:21.940 --> 00:24:27.100
时间，因为数据库未获取

00:24:24.309 --> 00:24:29.290
每个请求来自用户的任何请求

00:24:27.100 --> 00:24:31.330
它只收到请求

00:24:29.290 --> 00:24:32.710
在读取的时间间隔

00:24:31.330 --> 00:24:37.540
服务D的物化视图是

00:24:32.710 --> 00:24:39.970
当有新服务时查询结果

00:24:37.540 --> 00:24:42.340
开始了新的物化视图服务

00:24:39.970 --> 00:24:44.380
并且它加载了所有的事件

00:24:42.340 --> 00:24:47.320
从一开始就发生了

00:24:44.380 --> 00:24:47.950
从数据库中，此过程可以

00:24:47.320 --> 00:24:50.920
需要一段时间

00:24:47.950 --> 00:24:53.050
在某些情况下，我们可以提供服务

00:24:50.920 --> 00:24:55.330
最多花费几分钟来加载全部

00:24:53.050 --> 00:24:56.830
事件，没关系，因为那里

00:24:55.330 --> 00:25:00.630
通常是其他服务

00:24:56.830 --> 00:25:00.630
可用并可以吸引流量

00:25:18.380 --> 00:25:21.860
我不确定回答这个问题，但是你

00:25:20.630 --> 00:25:24.820
想知道这是否不是耦合

00:25:21.860 --> 00:25:24.820
在作者和读者之间

00:25:38.539 --> 00:25:41.199
是的

00:25:50.230 --> 00:25:54.140
如果您想更改架构

00:25:52.310 --> 00:25:57.170
结构中您确实有地毯

00:25:54.140 --> 00:25:58.610
系统设计感和

00:25:57.170 --> 00:26:01.940
我将解释如何解决

00:25:58.610 --> 00:26:04.670
后来，它不是一个物化视图

00:26:01.940 --> 00:26:07.280
数据库不是唯物主义观点

00:26:04.670 --> 00:26:09.230
记忆可能有人认为

00:26:07.280 --> 00:26:11.510
某些数据库有一个概念

00:26:09.230 --> 00:26:15.160
这被称为唯物主义观点，但是

00:26:11.510 --> 00:26:15.160
这是另一个概念

00:26:31.309 --> 00:26:36.450
是的，那么你开始有很多

00:26:33.809 --> 00:26:38.399
耦合，所以我们不想我们想要

00:26:36.450 --> 00:26:40.049
非常简单的服务

00:26:38.399 --> 00:26:42.450
做一件很小的事情，如果你

00:26:40.049 --> 00:26:44.880
引入整体式的连贯

00:26:42.450 --> 00:26:47.370
缓存，我想那我们差不多

00:26:44.880 --> 00:26:48.899
回到第一个方块，但这绝对是

00:26:47.370 --> 00:26:52.649
我们以后可以讨论的东西

00:26:48.899 --> 00:26:53.909
所以在这种情况下每秒

00:26:52.649 --> 00:26:56.820
事件正在从

00:26:53.909 --> 00:26:58.019
数据库和商家评论，现在

00:26:56.820 --> 00:26:59.970
有些人可能想法很好

00:26:58.019 --> 00:27:01.799
拉扯拉扯是一件坏事，我们

00:26:59.970 --> 00:27:03.870
曾有过关于极化a的不良经验

00:27:01.799 --> 00:27:06.840
数据库，尤其是在定时间隔

00:27:03.870 --> 00:27:10.350
所以我只想花一点时间

00:27:06.840 --> 00:27:12.120
当你把数学放在这里

00:27:10.350 --> 00:27:13.710
在数据库上没有任何索引，并且

00:27:12.120 --> 00:27:15.360
你没有关节

00:27:13.710 --> 00:27:17.730
基本上是一张桌子

00:27:15.360 --> 00:27:19.049
递增整数多少个请求

00:27:17.730 --> 00:27:21.870
每秒你认为那个数据库

00:27:19.049 --> 00:27:23.490
可以说您正在运行

00:27:21.870 --> 00:27:27.269
例如我的续集的单个实例

00:27:23.490 --> 00:27:32.159
只是丢一个数字然后一个

00:27:27.269 --> 00:27:34.169
有每秒5,000，是的

00:27:32.159 --> 00:27:35.700
合理认为每秒5,000 

00:27:34.169 --> 00:27:39.149
应该绝对能够处理

00:27:35.700 --> 00:27:40.710
是的，还是笔记本电脑，如果您

00:27:39.149 --> 00:27:42.269
每秒有5,000个请求

00:27:40.710 --> 00:27:44.669
容量意味着您可以拥有

00:27:42.269 --> 00:27:47.070
 5,000个物化视图

00:27:44.669 --> 00:27:51.360
数据库，如果您知道他们在

00:27:47.070 --> 00:27:53.490
是一些在不同的时间间隔是的

00:27:51.360 --> 00:27:55.169
如果您可以拥有5,000个物化视图

00:27:53.490 --> 00:27:57.529
每个物化视图

00:27:55.169 --> 00:28:00.510
当前状态的内存视图

00:27:57.529 --> 00:28:02.600
每个物化视图都应该

00:28:00.510 --> 00:28:05.130
能够处理大量流量

00:28:02.600 --> 00:28:07.289
您可以对总体有所了解

00:28:05.130 --> 00:28:09.090
您可以拥有的用户数量

00:28:07.289 --> 00:28:11.700
系统，只有一个

00:28:09.090 --> 00:28:14.190
我的续集的笔记，所以轮询

00:28:11.700 --> 00:28:16.769
数据库通常是一件坏事，但不是

00:28:14.190 --> 00:28:18.149
如果是从内部服务中提取的

00:28:16.769 --> 00:28:23.399
可以存在几千个

00:28:18.149 --> 00:28:24.899
因此，当评估事件时

00:28:23.399 --> 00:28:27.149
他们被接受，他们被合并到

00:28:24.899 --> 00:28:28.769
视图，所以这意味着

00:28:27.149 --> 00:28:31.830
物化视图服务必须具有

00:28:28.769 --> 00:28:33.510
关于期望的所有规则

00:28:31.830 --> 00:28:35.820
从事件中它必须能够

00:28:33.510 --> 00:28:37.230
评估一下，这就是那种

00:28:35.820 --> 00:28:38.980
正确的事情有点棘手

00:28:37.230 --> 00:28:41.440
这种设计

00:28:38.980 --> 00:28:43.630
因为规则集往往会发生变化， 

00:28:41.440 --> 00:28:45.790
你必须要当心

00:28:43.630 --> 00:28:51.790
您更改它以确保您

00:28:45.790 --> 00:28:53.470
不影响以前的事件

00:28:51.790 --> 00:29:00.880
最终观点在整个

00:28:53.470 --> 00:29:03.760
当一个事件是

00:29:00.880 --> 00:29:06.100
被消耗了，应该是

00:29:03.760 --> 00:29:08.740
在视图中实现，然后您应用

00:29:06.100 --> 00:29:11.500
该事件的所有业务规则

00:29:08.740 --> 00:29:13.960
表示该事件表示用户一次尝试

00:29:11.500 --> 00:29:16.150
要求洗衣机在

00:29:13.960 --> 00:29:17.770
这个日期和另一个事件说

00:29:16.150 --> 00:29:19.740
用户尝试要求洗衣

00:29:17.770 --> 00:29:21.880
当时的机器以及

00:29:19.740 --> 00:29:24.309
物化视图是否需要

00:29:21.880 --> 00:29:26.559
第一个事件是洗衣服

00:29:24.309 --> 00:29:29.169
当时可用的机器是

00:29:26.559 --> 00:29:31.030
好吧，我接受那个事件，然后什么时候

00:29:29.169 --> 00:29:32.440
第二个事件进来

00:29:31.030 --> 00:29:34.030
贷款人的机器，看起来似乎

00:29:32.440 --> 00:29:35.740
当时被预订了，所以我拒绝了

00:29:34.030 --> 00:29:38.110
事件，这就是我的意思

00:29:35.740 --> 00:29:40.090
接受和拒绝，做到了

00:29:38.110 --> 00:29:44.340
当实现时没有完成

00:29:40.090 --> 00:29:44.340
当你进入数据库间我

00:29:46.950 --> 00:29:50.919
将在物化中注册

00:29:49.450 --> 00:29:52.780
认为我不会在

00:29:50.919 --> 00:29:54.340
数据库，因为这将创建一个

00:29:52.780 --> 00:29:56.169
从物化视图耦合到

00:29:54.340 --> 00:29:57.669
数据库，这只是预订

00:29:56.169 --> 00:30:03.640
允许写入的服务

00:29:57.669 --> 00:30:05.440
数据库，是的，所以第三个

00:30:03.640 --> 00:30:08.650
模式的萨加里斯进入

00:30:05.440 --> 00:30:10.299
特定查询，因此代表

00:30:08.650 --> 00:30:12.700
职责装修相当明确

00:30:10.299 --> 00:30:14.440
命令就是写的东西

00:30:12.700 --> 00:30:16.299
一些改变状态和

00:30:14.440 --> 00:30:18.730
查询是感兴趣的东西

00:30:16.299 --> 00:30:20.650
的状态和总体思路

00:30:18.730 --> 00:30:22.270
整个设计理念永远

00:30:20.650 --> 00:30:27.400
允许这两个在同一位置

00:30:22.270 --> 00:30:29.260
服务，所以作家他们从来没有

00:30:27.400 --> 00:30:31.150
允许了解当前状态

00:30:29.260 --> 00:30:33.419
因为这需要他们查询

00:30:31.150 --> 00:30:36.549
东西，破坏了格局

00:30:33.419 --> 00:30:38.080
读不允许写

00:30:36.549 --> 00:30:39.340
像你这样的人从来没有

00:30:38.080 --> 00:30:41.200
允许在

00:30:39.340 --> 00:30:45.790
数据库，因为这会创建另一个

00:30:41.200 --> 00:30:47.590
依赖关系，因此两种服务都可以存在于

00:30:45.790 --> 00:30:48.909
尽可能多的实例，他们

00:30:47.590 --> 00:30:51.460
永远不需要与每个同步

00:30:48.909 --> 00:30:52.660
其他，因为他们都实现了

00:30:51.460 --> 00:30:55.360
观点最终是常数

00:30:52.660 --> 00:30:57.040
并且不允许作家

00:30:55.360 --> 00:30:59.320
看一下当前状态，这意味着

00:30:57.040 --> 00:31:04.180
信息可以合而为一

00:30:59.320 --> 00:31:06.700
始终保持单一方向， 

00:31:04.180 --> 00:31:08.950
是的，我们只是使用关系

00:31:06.700 --> 00:31:12.490
数据库作为持久队列没有

00:31:08.950 --> 00:31:14.530
更多，所以有些人可能想知道

00:31:12.490 --> 00:31:17.530
为什么我们在使用关系数据库

00:31:14.530 --> 00:31:18.910
所有为什么不没有续集等等

00:31:17.530 --> 00:31:21.070
基本上下降差不多

00:31:18.910 --> 00:31:23.440
当你拿走所有的东西

00:31:21.070 --> 00:31:25.300
放慢关系

00:31:23.440 --> 00:31:27.880
像联接外键和

00:31:25.300 --> 00:31:30.070
索引以及诸如此类的东西

00:31:27.880 --> 00:31:31.900
简单地写-这是表现

00:31:30.070 --> 00:31:34.930
通常与写给

00:31:31.900 --> 00:31:36.130
新的续集数据库，因此归结为

00:31:34.930 --> 00:31:38.260
口味问题实际上是什么

00:31:36.130 --> 00:31:41.260
最容易让您的团队进行管理和

00:31:38.260 --> 00:31:43.330
部署和执行以来

00:31:41.260 --> 00:31:45.640
关系数据库很少

00:31:43.330 --> 00:31:48.490
系统瓶颈，即使您曾经

00:31:45.640 --> 00:31:50.020
看到一些性能提升

00:31:48.490 --> 00:31:52.120
替换通常的数据库

00:31:50.020 --> 00:31:56.770
不是改善的最佳方法

00:31:52.120 --> 00:31:58.210
系统的性能等等

00:31:56.770 --> 00:31:59.710
这个预订应用程序的实施我

00:31:58.210 --> 00:32:01.510
知道你一直在等

00:31:59.710 --> 00:32:05.350
残疾，我要去

00:32:01.510 --> 00:32:07.480
去一点，你知道快节奏的公开，但

00:32:05.350 --> 00:32:08.740
我首先要说的就是

00:32:07.480 --> 00:32:10.510
我今天在这里显示的源代码是

00:32:08.740 --> 00:32:12.130
在github页面上可用，所以如果你

00:32:10.510 --> 00:32:13.690
以后想看一下就可以

00:32:12.130 --> 00:32:16.480
只是去那里有一个仓库

00:32:13.690 --> 00:32:19.960
称为活动采购演示，您可以在其中

00:32:16.480 --> 00:32:21.280
看到所有这些，但是首先我们

00:32:19.960 --> 00:32:24.460
用我的续集来存储事件日志

00:32:21.280 --> 00:32:26.470
和 spring boot 来创建REST API，我们

00:32:24.460 --> 00:32:30.310
使用Eureka进行服务发现和

00:32:26.470 --> 00:32:32.320
适用于边缘服务的Netflix工具

00:32:30.310 --> 00:32:34.390
也可以使用龙目岛计划来减少

00:32:32.320 --> 00:32:36.460
样板自己的系统和Speedman的

00:32:34.390 --> 00:32:39.580
我们自己的产品来编写和查询

00:32:36.460 --> 00:32:40.960
数据库重用您的ID流

00:32:39.580 --> 00:32:42.400
好像每个人都举起电话

00:32:40.960 --> 00:32:50.380
所以我将在幻灯片上停留一个

00:32:42.400 --> 00:32:52.720
不久，仓库

00:32:50.380 --> 00:32:56.760
艾米丽提到的是在github下

00:32:52.720 --> 00:32:56.760
斜线声明是的

00:32:58.730 --> 00:33:05.399
是的，如果你想的话，他怎么工作

00:33:03.870 --> 00:33:07.679
扩大您刚刚启动的任何内容

00:33:05.399 --> 00:33:09.510
这些过程就像新的春天一样

00:33:07.679 --> 00:33:11.100
配置为生成随机端口

00:33:09.510 --> 00:33:12.919
对于它的服务，您基本上可以

00:33:11.100 --> 00:33:15.779
启动您想要的许多服务

00:33:12.919 --> 00:33:18.539
可能是来自Google Cloud的AWS或

00:33:15.779 --> 00:33:21.059
像这样的东西，当一个新的

00:33:18.539 --> 00:33:23.130
实例首先联机，然后开始

00:33:21.059 --> 00:33:25.500
从下载事件日志

00:33:23.130 --> 00:33:27.990
数据库，所以我们将开始提取数据

00:33:25.500 --> 00:33:29.789
大约一千场从未发生的事件

00:33:27.990 --> 00:33:32.159
再有一个愚蠢的问题，那如果

00:33:29.789 --> 00:33:35.610
我们有数以百万计的活动面包

00:33:32.159 --> 00:33:36.860
是的，这就是当我们使用

00:33:35.610 --> 00:33:39.450
所谓的快照

00:33:36.860 --> 00:33:40.830
快照尚未涵盖

00:33:39.450 --> 00:33:43.890
例如他们只是没有时间

00:33:40.830 --> 00:33:46.200
它，但是如果您要开发快照

00:33:43.890 --> 00:33:47.850
服务真的很容易引入

00:33:46.200 --> 00:33:50.990
这个模型基本上没有

00:33:47.850 --> 00:33:53.299
本身使用Prem的REST API 

00:33:50.990 --> 00:33:55.500
订阅事件日志中的事件

00:33:53.299 --> 00:33:57.360
时不时地像每小时一次

00:33:55.500 --> 00:33:59.010
每天只保存一次

00:33:57.360 --> 00:34:01.200
物化视图下到文件，然后

00:33:59.010 --> 00:34:03.390
当有人要求最

00:34:01.200 --> 00:34:04.770
最近使用的文件将其提供给他们，这样您

00:34:03.390 --> 00:34:07.110
表示您可以从该位置重新开始

00:34:04.770 --> 00:34:08.820
是的，您可以重新启动，因为订单是

00:34:07.110 --> 00:34:11.129
总是相同的事件

00:34:08.820 --> 00:34:12.750
从一个琐碎的任务开始

00:34:11.129 --> 00:34:16.679
特定时间并按顺序

00:34:12.750 --> 00:34:17.399
但我可能会去实现

00:34:16.679 --> 00:34:19.560
服务也一样

00:34:17.399 --> 00:34:21.419
因此，当新服务启动时

00:34:19.560 --> 00:34:24.929
将所有事件下载到

00:34:21.419 --> 00:34:26.669
数据库中的当前时间

00:34:24.929 --> 00:34:29.849
有时这可能需要一分钟

00:34:26.669 --> 00:34:31.830
或然后服务发现

00:34:29.849 --> 00:34:33.810
通知有新

00:34:31.830 --> 00:34:35.490
该服务的实例可用，因此

00:34:33.810 --> 00:34:37.290
我将通知发送到边缘

00:34:35.490 --> 00:34:39.060
服务开始在那里路由流量

00:34:37.290 --> 00:34:40.830
边缘服务将继续

00:34:39.060 --> 00:34:41.970
在那儿路由流量直到开始

00:34:40.830 --> 00:34:43.800
越来越奇怪的例外

00:34:41.970 --> 00:34:46.169
服务不再可用，并且

00:34:43.800 --> 00:34:48.720
在这种情况下，它基本上将其删除

00:34:46.169 --> 00:34:50.369
从路线出发，所以这是一种简单的方法

00:34:48.720 --> 00:34:52.530
扩展系统易于扩展

00:34:50.369 --> 00:34:55.020
你只是开始进程或杀死

00:34:52.530 --> 00:34:57.030
流程和系统将保留在

00:34:55.020 --> 00:35:02.570
在那期间它有什么能力

00:34:57.030 --> 00:35:05.660
情况如此续集

00:35:02.570 --> 00:35:07.500
我们用作事件日志的表

00:35:05.660 --> 00:35:10.230
这里有很多事情

00:35:07.500 --> 00:35:11.450
首先我们要注意有趣

00:35:10.230 --> 00:35:13.500
叫做序列的东西

00:35:11.450 --> 00:35:15.300
这基本上是

00:35:13.500 --> 00:35:17.190
数据库给出了所有收到的信息

00:35:15.300 --> 00:35:19.020
事件，以便他们永远可以

00:35:17.190 --> 00:35:21.600
以相同的顺序播放，这是

00:35:19.020 --> 00:35:24.840
在这种情况下也是主键

00:35:21.600 --> 00:35:26.730
也有一个叫做verson的专栏

00:35:24.840 --> 00:35:28.770
我学到的困难方法是

00:35:26.730 --> 00:35:30.720
如果您不介绍名为

00:35:28.770 --> 00:35:33.750
 Verson可能真的很难

00:35:30.720 --> 00:35:35.400
稍后更改数据库架构，然后

00:35:33.750 --> 00:35:38.190
我认为那是你们中的一个

00:35:35.400 --> 00:35:41.160
有点暗示你是否想

00:35:38.190 --> 00:35:43.320
之后更改数据库架构

00:35:41.160 --> 00:35:45.720
可能会增加一些麻烦的实现

00:35:43.320 --> 00:35:47.790
明智的，所以我在那些情况下的建议

00:35:45.720 --> 00:35:51.360
我们一直在做的是你

00:35:47.790 --> 00:35:54.360
基本上更新所有的物化

00:35:51.360 --> 00:35:56.880
一次支持一次视图

00:35:54.360 --> 00:36:00.030
旧模式和新模式

00:35:56.880 --> 00:36:02.940
使用此值分隔事件

00:36:00.030 --> 00:36:05.940
版本，然后当他们都拥有

00:36:02.940 --> 00:36:07.910
更新后，您可以在

00:36:05.940 --> 00:36:11.400
因为他们俩都可以应付

00:36:07.910 --> 00:36:13.350
世界，然后你改变持久性

00:36:11.400 --> 00:36:15.720
逻辑，然后您更改

00:36:13.350 --> 00:36:18.510
数据库模式以支持此新功能

00:36:15.720 --> 00:36:20.580
确保永远不会丢失任何版本

00:36:18.510 --> 00:36:22.560
信息，因为您永远无法删除

00:36:20.580 --> 00:36:24.030
事件日志中的任何内容，因此您可以

00:36:22.560 --> 00:36:25.800
例如，添加具有

00:36:24.030 --> 00:36:28.400
例如允许的默认值

00:36:25.800 --> 00:36:30.630
如果您增加API版本，并且

00:36:28.400 --> 00:36:32.940
然后，当您完成更新

00:36:30.630 --> 00:36:35.490
 D作家，所以如果作家来

00:36:32.940 --> 00:36:37.380
按照这个新标准

00:36:35.490 --> 00:36:39.900
协调的方式

00:36:37.380 --> 00:36:41.580
更新系统，但您可以

00:36:39.900 --> 00:36:44.250
想象对数据库进行更改

00:36:41.580 --> 00:36:46.860
模式会增加很多痛苦，因此请尝试并

00:36:44.250 --> 00:36:48.360
除非有必要，否则请使用它

00:36:46.860 --> 00:36:51.060
确保您没有的方法

00:36:48.360 --> 00:36:53.580
不必要地做就是不存储

00:36:51.060 --> 00:36:57.750
将来可能会改变的一切

00:36:53.580 --> 00:36:59.790
在事件日志中，还有一个由

00:36:57.750 --> 00:37:01.920
经验，所以在这种情况下，您可能

00:36:59.790 --> 00:37:02.730
注意它并没有真正存储任何

00:37:01.920 --> 00:37:05.010
重要信息

00:37:02.730 --> 00:37:09.570
它只是存储二进制十六

00:37:05.010 --> 00:37:10.740
是我续集中的一个变种，所以你

00:37:09.570 --> 00:37:12.840
基本上存储有一个

00:37:10.740 --> 00:37:15.090
预订具有特定ID的地方

00:37:12.840 --> 00:37:17.070
某处有一个用户

00:37:15.090 --> 00:37:18.810
特定的ID，并且有资源

00:37:17.070 --> 00:37:20.880
能够放置特定ID的地方

00:37:18.810 --> 00:37:23.100
不知道名字叫什么

00:37:20.880 --> 00:37:24.839
资源我不知道用户名是什么

00:37:23.100 --> 00:37:27.930
的用户是或类似的东西

00:37:24.839 --> 00:37:31.049
我只知道这是最终用户

00:37:27.930 --> 00:37:33.390
我可以确定的，如果您开始

00:37:31.049 --> 00:37:37.769
将其他信息添加到您的日志中

00:37:33.390 --> 00:37:39.630
以后可能会遇到问题和问题

00:37:37.769 --> 00:37:41.549
我们还存储第二本书和第二本书

00:37:39.630 --> 00:37:43.799
基本上是因为我们需要

00:37:41.549 --> 00:37:47.819
评估如果发生的事件

00:37:43.799 --> 00:37:50.099
他们被允许还是不允许

00:37:47.819 --> 00:37:52.079
实现D关系映射

00:37:50.099 --> 00:37:54.150
我们使用Speedman的

00:37:52.079 --> 00:37:56.160
真的很简单，您只需运行一个Maven 

00:37:54.150 --> 00:37:58.019
目标并真正产生所有

00:37:56.160 --> 00:38:01.249
您需要的课程，这是行家

00:37:58.019 --> 00:38:03.690
 Speedman：我早先谈过两次的工具

00:38:01.249 --> 00:38:05.299
关于这一点，我是

00:38:03.690 --> 00:38:07.799
这里不做任何详细说明

00:38:05.299 --> 00:38:09.839
但是这个简短的版本是

00:38:07.799 --> 00:38:11.489
 Spirit生成预订

00:38:09.839 --> 00:38:14.190
实施预订经理等

00:38:11.489 --> 00:38:16.229
就像APA一样

00:38:14.190 --> 00:38:18.299
除了速度薄荷之外，我们

00:38:16.229 --> 00:38:20.910
为您生成样板

00:38:18.299 --> 00:38:23.460
 APA从代码生成数据库

00:38:20.910 --> 00:38:24.660
所以这与速度相反

00:38:23.460 --> 00:38:26.249
用于与流一起使用

00:38:24.660 --> 00:38:30.180
在这种情况下效果很好的API 

00:38:26.249 --> 00:38:31.589
所以当Spearman开始时，您就可以连接

00:38:30.180 --> 00:38:33.660
图形对话框中访问数据库

00:38:31.589 --> 00:38:36.559
你只要按生成，你有

00:38:33.660 --> 00:38:42.900
您申请时间的95％已经

00:38:36.559 --> 00:38:44.969
是的，那基本上就是这些

00:38:42.900 --> 00:38:46.079
我们说了哦，最后一件事，我们也

00:38:44.969 --> 00:38:47.940
有一个开源插件

00:38:46.079 --> 00:38:49.769
与spring集成在一起，因此，如果您使用

00:38:47.940 --> 00:38:51.900
该插件还将生成所有

00:38:49.769 --> 00:38:53.729
弹簧配置需要设置

00:38:51.900 --> 00:38:58.079
数据库以及已使用的所有内容

00:38:53.729 --> 00:39:00.599
今天是开源的，所以预订

00:38:58.079 --> 00:39:03.809
服务没什么新鲜的两件事

00:39:00.599 --> 00:39:06.809
请注意，我们启用了服务发现功能， 

00:39:03.809 --> 00:39:10.559
使其成为一个春季启动应用程序

00:39:06.809 --> 00:39:12.479
只是设置应用程序然后

00:39:10.559 --> 00:39:13.829
我们想要实现一个控制器

00:39:12.479 --> 00:39:15.749
实际将东西插入

00:39:13.829 --> 00:39:17.309
数据库，我们只是自动连接

00:39:15.749 --> 00:39:19.739
 Speedman生成的经理

00:39:17.309 --> 00:39:20.160
然后我们使用弹簧配置

00:39:19.739 --> 00:39:23.549
价值观

00:39:20.160 --> 00:39:25.259
这就是默认的API版本

00:39:23.549 --> 00:39:26.509
只是一个，以便我们可以轻松地更改

00:39:25.259 --> 00:39:30.769
将来如果你想

00:39:26.509 --> 00:39:33.989
以编程方式添加新的API版本

00:39:30.769 --> 00:39:35.670
当我们想要的时候，我们也在这里使用龙目岛

00:39:33.989 --> 00:39:37.710
有点为

00:39:35.670 --> 00:39:38.340
预订请求和预订收据

00:39:37.710 --> 00:39:39.960
的

00:39:38.340 --> 00:39:42.870
发出的两件事

00:39:39.960 --> 00:39:45.060
预订服务，所以当一个请求

00:39:42.870 --> 00:39:47.430
进来我们要退订

00:39:45.060 --> 00:39:49.410
收据，我们希望该请求是

00:39:47.430 --> 00:39:52.560
格式化为区域，所以我们使用杰克逊

00:39:49.410 --> 00:39:54.060
与隆波克一起在这里，所以这将

00:39:52.560 --> 00:39:59.370
生成所有的getter和setter 

00:39:54.060 --> 00:40:01.110
我们和D我们还添加了一些帮助器

00:39:59.370 --> 00:40:04.710
新预订事件的方法

00:40:01.110 --> 00:40:06.600
这创建了新的事件集

00:40:04.710 --> 00:40:09.600
资源的使用等

00:40:06.600 --> 00:40:12.690
请求进来，我用

00:40:09.600 --> 00:40:14.510
其他八次API，您可能不会

00:40:12.690 --> 00:40:17.220
熟悉它，但是

00:40:14.510 --> 00:40:19.110
基本上，用户指定您是否看

00:40:17.220 --> 00:40:21.270
有时在上一个

00:40:19.110 --> 00:40:22.920
官员类型日期是时间，这意味着

00:40:21.270 --> 00:40:24.420
他们可以指定哪个时间码

00:40:22.920 --> 00:40:25.950
他们指的是当他们说

00:40:24.420 --> 00:40:28.800
我想在八点预定

00:40:25.950 --> 00:40:30.630
然后服务器将时间本地化为

00:40:28.800 --> 00:40:33.660
插入之前的自己的时区

00:40:30.630 --> 00:40:35.160
数据库，然后您当然需要

00:40:33.660 --> 00:40:39.260
确保服务器正在运行

00:40:35.160 --> 00:40:39.260
与数据库在同一时区

00:40:39.800 --> 00:40:45.360
记住要创建预订

00:40:42.600 --> 00:40:47.580
其余的api很简单，我们包装一个

00:40:45.360 --> 00:40:49.560
超速请求以保留行

00:40:47.580 --> 00:40:50.850
放在条板箱收据中的数据库中

00:40:49.560 --> 00:40:53.370
得到回应以发送回

00:40:50.850 --> 00:40:56.100
客户，这就是所需要的全部逻辑

00:40:53.370 --> 00:40:57.690
在数据库中做持久化的事情

00:40:56.100 --> 00:41:01.170
可能还会注意到我们设置了类型

00:40:57.690 --> 00:41:03.090
创建预订，我们从不做任何事情

00:41:01.170 --> 00:41:04.800
除了坚持，这意味着

00:41:03.090 --> 00:41:07.590
如果用户想更新预订

00:41:04.800 --> 00:41:09.690
我们不会更新任何现有行

00:41:07.590 --> 00:41:12.210
基本上坚持新行并设置

00:41:09.690 --> 00:41:15.890
时间更新预订，然后我们使用

00:41:12.210 --> 00:41:17.940
与上一个相同的预订ID 

00:41:15.890 --> 00:41:18.750
当您想删除预订或

00:41:17.940 --> 00:41:20.250
取消它

00:41:18.750 --> 00:41:23.010
你要做的基本上是发送一个删除

00:41:20.250 --> 00:41:24.960
带有预订UID的要求

00:41:23.010 --> 00:41:30.000
您要处理，然后我们通知

00:41:24.960 --> 00:41:31.830
作为取消的预订请求，如果

00:41:30.000 --> 00:41:34.140
我们现在想测试服务

00:41:31.830 --> 00:41:36.060
只需执行URL的curl命令，我们

00:41:34.140 --> 00:41:38.850
说，嘿，我想发布到

00:41:36.060 --> 00:41:40.710
预订系统我有这个用户

00:41:38.850 --> 00:41:43.080
资源来自此预订，现为

00:41:40.710 --> 00:41:45.270
预订到，我希望它能够持续存在

00:41:43.080 --> 00:41:47.400
如果您想像您一样增加安全性

00:41:45.270 --> 00:41:50.220
我可能建议这样做

00:41:47.400 --> 00:41:52.090
您使用JSON网络令牌进行处理

00:41:50.220 --> 00:41:53.680
因为那是一种非常宁静的方式

00:41:52.090 --> 00:41:56.470
处理用户权限，它具有

00:41:53.680 --> 00:41:57.940
内置弹簧安全支持，因此

00:41:56.470 --> 00:42:00.100
在这种情况下，当我发送此请求时， 

00:41:57.940 --> 00:42:02.380
得到一个很好的回应

00:42:00.100 --> 00:42:03.880
格式化位置标记为

00:42:02.380 --> 00:42:06.820
预定的位置

00:42:03.880 --> 00:42:09.490
一旦被接受或拒绝

00:42:06.820 --> 00:42:12.580
作为序列号和事件

00:42:09.490 --> 00:42:16.210
给它的ID，因此允许客户端

00:42:12.580 --> 00:42:19.710
连接到该URL并开始显示

00:42:16.210 --> 00:42:22.210
给用户的格式化好的消息

00:42:19.710 --> 00:42:25.120
日历服务的工作方式与我们类似

00:42:22.210 --> 00:42:28.990
只需启用Eureka，我们启用

00:42:25.120 --> 00:42:30.550
 spring boot ，然后我们建立了一个

00:42:28.990 --> 00:42:34.030
预订视图，这将是我们的

00:42:30.550 --> 00:42:36.250
物化视图，我使用调度，所以

00:42:34.030 --> 00:42:38.740
启用日程安排和服务

00:42:36.250 --> 00:42:40.000
春季服务，然后您可以看到

00:42:38.740 --> 00:42:41.950
物化视图来了

00:42:40.000 --> 00:42:47.110
下来使用基本的哈希图

00:42:41.950 --> 00:42:49.600
从UID到预订的位图，以及

00:42:47.110 --> 00:42:51.580
我也有几个听众可以

00:42:49.600 --> 00:42:57.190
将它们进一步发送到WebSockets 

00:42:51.580 --> 00:43:00.130
而不用打扰光环

00:42:57.190 --> 00:43:01.120
然后再次是龙目岛创建

00:43:00.130 --> 00:43:03.580
预订和预订确认

00:43:01.120 --> 00:43:05.560
这将被存储用于采访

00:43:03.580 --> 00:43:07.330
避免所有的二传手

00:43:05.560 --> 00:43:10.390
和吸气剂，因此预订确认

00:43:07.330 --> 00:43:13.150
是通过什么发回给客户的

00:43:10.390 --> 00:43:15.610
 WebSocket能够通知

00:43:13.150 --> 00:43:17.800
预订的用户已被接受

00:43:15.610 --> 00:43:19.990
直到今晚，这只是一个枚举

00:43:17.800 --> 00:43:22.720
那里被接受或拒绝以及

00:43:19.990 --> 00:43:24.730
关于它的所有信息我也

00:43:22.720 --> 00:43:26.950
在底部添加了一个字符串消息是

00:43:24.730 --> 00:43:29.530
以便允许服务器添加

00:43:26.950 --> 00:43:31.960
给用户的信息就像

00:43:29.530 --> 00:43:34.420
请求被拒绝，因为有人

00:43:31.960 --> 00:43:35.920
预订了这个资源也是为了

00:43:34.420 --> 00:43:39.670
更容易开发前端

00:43:35.920 --> 00:43:41.410
显示相关信息，然后我

00:43:39.670 --> 00:43:44.140
添加了帖子构造以能够

00:43:41.410 --> 00:43:47.320
当服务从数据库加载时

00:43:44.140 --> 00:43:51.360
在上网之前开始，我

00:43:47.320 --> 00:43:51.360
每秒安排一次

00:43:53.850 --> 00:44:00.720
令人震惊的实际循环

00:43:57.990 --> 00:44:02.580
您看到dat Paul的事件方法是

00:44:00.720 --> 00:44:04.860
使用旋转流建议

00:44:02.580 --> 00:44:07.500
超出您正在处理的需求

00:44:04.860 --> 00:44:09.150
事件过滤掉所有具有

00:44:07.500 --> 00:44:11.370
序列号大于最后一个

00:44:09.150 --> 00:44:17.450
事件限制到一千

00:44:11.370 --> 00:44:17.450
元素，并且对它们进行评分哦，是的

00:44:20.300 --> 00:44:27.900
是的，它注意到它实现了

00:44:24.630 --> 00:44:30.150
数据存储到内存中，如果您有很多

00:44:27.900 --> 00:44:31.230
关于相同预订的事件

00:44:30.150 --> 00:44:34.020
何时会崩溃

00:44:31.230 --> 00:44:37.980
实现，但是是的，它加载到内存中

00:44:34.020 --> 00:44:40.470
这是哈希图不同，所以为什么

00:44:37.980 --> 00:44:42.870
你只有一千拉里

00:44:40.470 --> 00:44:45.960
基本上是因为我不想

00:44:42.870 --> 00:44:47.190
挂在数据库上的时间过长，因此我们注意到

00:44:45.960 --> 00:44:49.770
狂野之后，当您开始新的

00:44:47.190 --> 00:44:52.350
第一次服务，可能

00:44:49.770 --> 00:44:54.060
花一些时间重新加载所有事件

00:44:52.350 --> 00:44:56.760
到目前为止，除非您

00:44:54.060 --> 00:44:59.700
抢购，所以这是一种简单的方法

00:44:56.760 --> 00:45:02.340
允许其他逻辑进入

00:44:59.700 --> 00:45:04.050
循环，而不是挂得太久，所以它

00:45:02.340 --> 00:45:05.850
一次只需要一千

00:45:04.050 --> 00:45:07.890
从原子布尔值到

00:45:05.850 --> 00:45:11.250
有点回头并继续工作

00:45:07.890 --> 00:45:13.920
万一有更多的事件

00:45:11.250 --> 00:45:17.520
一个小技巧，使重复

00:45:13.920 --> 00:45:19.230
循环，您也可以在右侧看到

00:45:17.520 --> 00:45:21.020
在这里的续集查询

00:45:19.230 --> 00:45:23.640
产生，所以实际上实际上是

00:45:21.020 --> 00:45:29.460
格式正确的查询，即使您使用

00:45:23.640 --> 00:45:30.930
谓词和限制是

00:45:29.460 --> 00:45:32.700
日历服务非常简单，我们只是

00:45:30.930 --> 00:45:35.780
在预订视图中列出一条线

00:45:32.700 --> 00:45:38.480
我们之前创建的，然后公开

00:45:35.780 --> 00:45:40.500
两个不同的其余端点

00:45:38.480 --> 00:45:43.490
要求所有预订或

00:45:40.500 --> 00:45:46.470
通过特定的UID请求预订

00:45:43.490 --> 00:45:49.860
而且我们也有，所以您可以通过查找来预订

00:45:46.470 --> 00:45:52.800
特定的所有预订

00:45:49.860 --> 00:45:55.080
资源和/或所有预订

00:45:52.800 --> 00:45:56.430
特定用户这只是我们的事情

00:45:55.080 --> 00:46:00.510
添加到更多

00:45:56.430 --> 00:46:03.330
交互式的，所以当我们测试时我们会做

00:46:00.510 --> 00:46:05.340
再次使用curl只是说嘿

00:46:03.330 --> 00:46:06.510
我想阅读这份预订，我们可以

00:46:05.340 --> 00:46:07.269
看到预订已被接受

00:46:06.510 --> 00:46:10.419
通过

00:46:07.269 --> 00:46:12.369
看到200的眼泪，然后我们

00:46:10.419 --> 00:46:14.739
可以看到哪个用户

00:46:12.369 --> 00:46:15.130
那本书这是什么资源， 

00:46:14.739 --> 00:46:19.029
依此类推

00:46:15.130 --> 00:46:20.469
看来我说的话太多了，但我

00:46:19.029 --> 00:46:22.449
演示总是会做的

00:46:20.469 --> 00:46:24.880
请随时抬头

00:46:22.449 --> 00:46:26.709
快车员后来的图书馆我们

00:46:24.880 --> 00:46:30.159
在这里用来做数据库逻辑

00:46:26.709 --> 00:46:34.659
就像我在这里说的所有例子

00:46:30.159 --> 00:46:35.620
今天正在全力研究Gita，所以

00:46:34.659 --> 00:46:40.739
是的，谢谢你

00:46:35.620 --> 00:46:40.739
 [掌声] 

