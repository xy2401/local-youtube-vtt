WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.210 --> 00:00:08.889
好的，我想是8:30早上好

00:00:06.340 --> 00:00:10.120
每个人我都很高兴你们这么多

00:00:08.889 --> 00:00:11.500
可以到第一天早上

00:00:10.120 --> 00:00:14.670
会议我希望这会很有趣

00:00:11.500 --> 00:00:17.260
对你来说足够了，所以你真的可以醒来

00:00:14.670 --> 00:00:18.750
所以我今天说的是关于分析

00:00:17.260 --> 00:00:21.279
热点崩溃

00:00:18.750 --> 00:00:24.970
我的名字叫莫妮丝，我在工作

00:00:21.279 --> 00:00:28.029
对于AP JVM团队中的sa P，我们正在做

00:00:24.970 --> 00:00:30.910
我们自己的AP Java虚拟机

00:00:28.029 --> 00:00:32.619
基于热点

00:00:30.910 --> 00:00:35.070
同时我们的热点版本

00:00:32.619 --> 00:00:37.660
在开放的JDK中也很忙

00:00:35.070 --> 00:00:43.030
我们是维护者和贡献者

00:00:37.660 --> 00:00:47.100
 PowerPC斧头和s / 390端口，我们

00:00:43.030 --> 00:00:49.750
也在Java执行委员会中

00:00:47.100 --> 00:00:51.760
好吧，让我们开始谈谈

00:00:49.750 --> 00:00:53.320
有什么问题请问

00:00:51.760 --> 00:00:57.060
他们很快就会尝试回答

00:00:53.320 --> 00:01:00.700
如果没有他们，我们可以在谈话后做

00:00:57.060 --> 00:01:02.550
所以我在这次演讲中的所有例子

00:01:00.700 --> 00:01:05.110
幻灯片本身在github上

00:01:02.550 --> 00:01:07.390
因此，如果您想拍照，可以

00:01:05.110 --> 00:01:08.440
拍这张幻灯片的照片，我将展示

00:01:07.390 --> 00:01:10.630
你再滑一次

00:01:08.440 --> 00:01:17.070
在演讲结束时，您将拥有

00:01:10.630 --> 00:01:21.580
再有一次机会就可以了

00:01:17.070 --> 00:01:24.159
每个人都准备好了，什么是热点

00:01:21.580 --> 00:01:26.260
崩溃好了，这实际上是一个致命错误

00:01:24.159 --> 00:01:28.930
或我们无法做到的情况

00:01:26.260 --> 00:01:30.580
恢复它不与

00:01:28.930 --> 00:01:33.010
例如我们可以例外

00:01:30.580 --> 00:01:35.920
处理异常和/或未处理

00:01:33.010 --> 00:01:38.350
异常显示您自己的错误

00:01:35.920 --> 00:01:42.310
在应用程序中编程时很热

00:01:38.350 --> 00:01:43.900
点崩溃或VM崩溃显示错误

00:01:42.310 --> 00:01:47.080
在虚拟机本身中

00:01:43.900 --> 00:01:49.240
不应该发生，所以我们唯一的事情

00:01:47.080 --> 00:01:51.340
可以做到，我说这是无法恢复的

00:01:49.240 --> 00:01:53.229
错误我们唯一能做的就是

00:01:51.340 --> 00:01:56.380
尝试收集尽可能多的信息

00:01:53.229 --> 00:01:58.120
可能从崩溃中分析出来

00:01:56.380 --> 00:02:02.530
找到根本原因并加以预防

00:01:58.120 --> 00:02:05.619
下次再带大家

00:02:02.530 --> 00:02:10.509
在同一行上只是一个非常简短的摘要

00:02:05.619 --> 00:02:13.840
关于热点VM的介绍等

00:02:10.509 --> 00:02:15.710
最基本的是我们有两个CPU 

00:02:13.840 --> 00:02:17.810
今天要进入CPU 

00:02:15.710 --> 00:02:20.900
我过去的12年中一直在从事热门工作

00:02:17.810 --> 00:02:23.630
当场我们也发现一些CPU错误，但是

00:02:20.900 --> 00:02:26.300
我今天不会讨论这个话题

00:02:23.630 --> 00:02:28.760
我们有C ++代码的基础

00:02:26.300 --> 00:02:30.770
 Java启动器，我们有不同的Java 

00:02:28.760 --> 00:02:33.050
库Lib Java是原生的

00:02:30.770 --> 00:02:35.870
类库的一部分，我们有

00:02:33.050 --> 00:02:39.350
系统C库都是C代码

00:02:35.870 --> 00:02:42.350
或记忆中最大的部分是

00:02:39.350 --> 00:02:44.180
显然，热点本身就是虚拟的

00:02:42.350 --> 00:02:47.000
 Lib JVM中的计算机本身

00:02:44.180 --> 00:02:51.410
共享库包含

00:02:47.000 --> 00:02:53.540
运行时，然后使用GC和JIT编译器（如果有） 

00:02:51.410 --> 00:02:56.840
您正在使用的服务器版本

00:02:53.540 --> 00:02:59.990
热点，这是今天的默认值

00:02:56.840 --> 00:03:03.260
也用C ++编写，接下来

00:02:59.990 --> 00:03:04.940
级别，我们已经生成了代码，所以这是

00:03:03.260 --> 00:03:06.800
遇到的主要问题之一

00:03:04.940 --> 00:03:08.960
调试和分析热点

00:03:06.800 --> 00:03:11.330
我们必须处理的错误

00:03:08.960 --> 00:03:15.230
生成本地调试器的代码

00:03:11.330 --> 00:03:17.240
不能对我们有很大帮助，所以首先

00:03:15.230 --> 00:03:19.850
解释器本身是生成的

00:03:17.240 --> 00:03:21.490
将向您展示一个简单的例子

00:03:19.850 --> 00:03:24.620
以下幻灯片看起来像

00:03:21.490 --> 00:03:27.770
然后我们有各种选项卡

00:03:24.620 --> 00:03:31.850
本地C代码之间的粘合代码

00:03:27.770 --> 00:03:34.520
以及及时生成的编译器

00:03:31.850 --> 00:03:36.440
我们有C 1的已编译代码

00:03:34.520 --> 00:03:38.180
方法C 2编译方法如此

00:03:36.440 --> 00:03:40.580
 C 1是客户端编译器-是

00:03:38.180 --> 00:03:42.380
有一个服务器编译器运行

00:03:40.580 --> 00:03:45.320
速度较慢，但​​由代码和

00:03:42.380 --> 00:03:48.410
最近我们提前编译了

00:03:45.320 --> 00:03:50.930
消息也出现在代码中

00:03:48.410 --> 00:03:52.580
现在缓存，最后我们有了数据

00:03:50.930 --> 00:03:54.950
我们的程序，所以我们有Java 

00:03:52.580 --> 00:03:57.650
 Java堆中的对象

00:03:54.950 --> 00:03:59.360
自己上课，今天住在

00:03:57.650 --> 00:04:00.860
他们以前居住的元空间

00:03:59.360 --> 00:04:03.830
带圆圈的术语是堆的一部分

00:04:00.860 --> 00:04:07.070
代，但已在中删除

00:04:03.830 --> 00:04:10.550
 Java 8，我们仍然在VM仍使用

00:04:07.070 --> 00:04:12.530
 C堆的相当一部分，所以这是

00:04:10.550 --> 00:04:12.980
还有很多人不知道的事情

00:04:12.530 --> 00:04:14.870
的

00:04:12.980 --> 00:04:16.609
他们配置虚拟机，让我们

00:04:14.870 --> 00:04:19.280
说8 GB，然后他们想知道

00:04:16.609 --> 00:04:20.989
为什么要使用12，例如

00:04:19.280 --> 00:04:23.060
即时编译器可以很好地使用

00:04:20.989 --> 00:04:25.970
高达一个千兆字节，用于编译一个非常

00:04:23.060 --> 00:04:27.710
大方法，并取决于

00:04:25.970 --> 00:04:29.330
您正在运行的硬件有一个

00:04:27.710 --> 00:04:30.860
很多线程正在运行

00:04:29.330 --> 00:04:33.800
即使您只是开始打招呼的世界

00:04:30.860 --> 00:04:36.050
对热点VM进行编程，今天将开始于

00:04:33.800 --> 00:04:38.210
我们至少有10个线程

00:04:36.050 --> 00:04:40.400
你有一些簿记

00:04:38.210 --> 00:04:42.650
 GCS编写各种使用权

00:04:40.400 --> 00:04:46.789
根据课程的不同

00:04:42.650 --> 00:04:50.090
 JIT线程数，它们也都

00:04:46.789 --> 00:04:51.650
当然需要记忆，当他们

00:04:50.090 --> 00:04:54.139
他们在跑步时也会消耗

00:04:51.650 --> 00:04:56.150
 Sahib，最后我们有了

00:04:54.139 --> 00:04:59.030
应用程序线程Java线程和

00:04:56.150 --> 00:05:01.430
这些Java线程执行代码

00:04:59.030 --> 00:05:03.800
从这里开始，所以他们由

00:05:01.430 --> 00:05:05.479
发射艺术品，他们跳进了

00:05:03.800 --> 00:05:08.479
运行时，他们执行一些解释器

00:05:05.479 --> 00:05:11.300
要及时执行的代码

00:05:08.479 --> 00:05:13.639
编译代码等等，在此期间

00:05:11.300 --> 00:05:15.530
交谈，我们将看到可以在哪些地方

00:05:13.639 --> 00:05:20.960
崩溃以及我们如何检测到

00:05:15.530 --> 00:05:24.830
希望解决它，所以我们有一个很小的

00:05:20.960 --> 00:05:26.419
崩溃的例子，所以你们当中谁见过

00:05:24.830 --> 00:05:28.849
这是在他运行Java之前

00:05:26.419 --> 00:05:32.449
应用程序，所以可能很多人

00:05:28.849 --> 00:05:36.190
这就是为什么我们在这里还可以，所以

00:05:32.449 --> 00:05:39.379
这说了我们，所以首先

00:05:36.190 --> 00:05:41.419
简短的摘要总结

00:05:39.379 --> 00:05:45.379
这种情况下分割错误

00:05:41.419 --> 00:05:47.900
发生在这个程序柜台

00:05:45.379 --> 00:05:50.270
告诉我们最上面的功能

00:05:47.900 --> 00:05:52.789
错误发生时的堆栈数量

00:05:50.270 --> 00:05:54.229
在这种情况下，它在Lib JVM中，所以在

00:05:52.789 --> 00:05:57.529
虚拟机本身是

00:05:54.229 --> 00:06:00.319
内存访问功能告诉我们在哪里

00:05:57.529 --> 00:06:02.419
核心文件已写入，并且

00:06:00.319 --> 00:06:04.580
告诉我们热点错误文件在哪里

00:06:02.419 --> 00:06:08.000
被写到这个热点错误

00:06:04.580 --> 00:06:10.069
文件实际上是我们将要查看的数据

00:06:08.000 --> 00:06:13.099
最多在这次谈话中，因为

00:06:10.069 --> 00:06:16.219
包含很多有用的信息，所以

00:06:13.099 --> 00:06:20.659
跑步时有一些卡维特

00:06:16.219 --> 00:06:24.979
你限制负c 0所以核心5 0否

00:06:20.659 --> 00:06:26.690
通常会生产核心5 

00:06:24.979 --> 00:06:30.349
拥有核心文件可能会非常有帮助

00:06:26.690 --> 00:06:32.839
正如我们将至少在您运行时看到的那样

00:06:30.349 --> 00:06:37.339
陷入问题并想重现

00:06:32.839 --> 00:06:39.830
您应该将极限值设置为c 2 

00:06:37.339 --> 00:06:42.979
无限，因此您也可以获得核心文件

00:06:39.830 --> 00:06:43.610
 gnu / linux系统也像包子一样，即使

00:06:42.979 --> 00:06:46.250
你安顿下来

00:06:43.610 --> 00:06:47.599
 -无限资格将不会被创建

00:06:46.250 --> 00:06:49.909
在您的文件系统中，但它们将

00:06:47.599 --> 00:06:52.400
通过管道传输到系统应用程序，例如

00:06:49.909 --> 00:06:55.159
机场，你不会看到他们，所以你

00:06:52.400 --> 00:06:57.050
可能必须在代理中进行配置

00:06:55.159 --> 00:06:59.300
漫画或图案，或取决于您

00:06:57.050 --> 00:07:00.740
系统这可能是一个不同的文件，但

00:06:59.300 --> 00:07:02.569
您可能必须配置核心

00:07:00.740 --> 00:07:07.699
模式到文件系统上的文件

00:07:02.569 --> 00:07:12.439
而不是到这里某处的管道

00:07:07.699 --> 00:07:14.960
服务程序还可以，我该怎么办

00:07:12.439 --> 00:07:16.969
造成这种崩溃实际上是非常

00:07:14.960 --> 00:07:19.009
简单地使用不安全的方法，您就会知道

00:07:16.969 --> 00:07:21.800
不应该使用不安全的名称，因为

00:07:19.009 --> 00:07:26.300
说这是不安全的，但是对于

00:07:21.800 --> 00:07:29.449
导致崩溃，所以实际上我们在做什么

00:07:26.300 --> 00:07:32.180
这是我只是定义一个方法崩溃和

00:07:29.449 --> 00:07:34.460
它使用不安全的值X写入

00:07:32.180 --> 00:07:37.520
地址99，因此地址99通常不是

00:07:34.460 --> 00:07:40.159
可访问性，我们称崩溃为42， 

00:07:37.520 --> 00:07:42.349
写给别人99它崩溃了

00:07:40.159 --> 00:07:45.409
程序，所以让我们看看这是怎么回事

00:07:42.349 --> 00:07:48.430
错误文件在这种情况下看起来是这样

00:07:45.409 --> 00:07:49.699
热点错误文件中，我们有一个

00:07:48.430 --> 00:07:52.009
摘要

00:07:49.699 --> 00:07:53.690
它包含确切的命令行

00:07:52.009 --> 00:07:57.139
当您为

00:07:53.690 --> 00:07:59.000
例子从什么得到什么文件

00:07:57.139 --> 00:08:02.180
您的客户，这很有用

00:07:59.000 --> 00:08:04.129
您所运行的内容包含

00:08:02.180 --> 00:08:06.650
有关CPU的详细信息

00:08:04.129 --> 00:08:08.210
同时使用的硬件

00:08:06.650 --> 00:08:11.509
使用的系统以及多长时间

00:08:08.210 --> 00:08:13.819
程序确实在我们的情况下运行，这是

00:08:11.509 --> 00:08:16.279
当然只有一秒钟，但我们经常得到

00:08:13.819 --> 00:08:19.969
从运行的客户端崩溃文件

00:08:16.279 --> 00:08:22.750
数周甚至数月，以便您查看是否

00:08:19.969 --> 00:08:25.279
几个月后出现问题

00:08:22.750 --> 00:08:27.770
通常不容易复制

00:08:25.279 --> 00:08:29.750
通常，所以您最好拥有所有

00:08:27.770 --> 00:08:31.310
您在此错误文件中需要的信息

00:08:29.750 --> 00:08:34.810
或在核心文件中（如果您有一个） 

00:08:31.310 --> 00:08:37.399
因为你不会再有机会

00:08:34.810 --> 00:08:40.159
好的，让我们深入研究热点

00:08:37.399 --> 00:08:44.329
错误文件，因为下一部分是Java 

00:08:40.159 --> 00:08:45.949
堆栈跟踪它包含所有Java 

00:08:44.329 --> 00:08:48.680
堆栈中的堆栈帧

00:08:45.949 --> 00:08:52.220
当错误发生时，我们看到我们

00:08:48.680 --> 00:08:54.829
叫我们的崩溃程序，这个叫

00:08:52.220 --> 00:08:57.320
然后根据JDK misc不安全

00:08:54.829 --> 00:09:01.060
 JDK 9中的热不安全

00:08:57.320 --> 00:09:04.160
不安全的大田，然后叫入

00:09:01.060 --> 00:09:06.020
但这只是当您使用Java框架时

00:09:04.160 --> 00:09:07.850
如果你还记得一开始

00:09:06.020 --> 00:09:11.420
我们实际上崩溃了交流功能

00:09:07.850 --> 00:09:13.370
这是在嘴唇JVM中，所以下一部分

00:09:11.420 --> 00:09:16.160
箭火包含什么

00:09:13.370 --> 00:09:19.100
称为本机或Mixtec跟踪

00:09:16.160 --> 00:09:22.130
包含所有实际帧

00:09:19.100 --> 00:09:25.820
已经在堆栈上，在这里您可以

00:09:22.130 --> 00:09:27.770
看到我们从昏昏欲睡的汗水开始

00:09:25.820 --> 00:09:30.530
就在这出戏中的Java主角

00:09:27.770 --> 00:09:34.940
在飞跃jli然后我们去的发射器

00:09:30.530 --> 00:09:38.180
通过简我称静态等等

00:09:34.940 --> 00:09:41.300
最终我们到达了Java 

00:09:38.180 --> 00:09:43.700
方法和最后的Java问题趋向于

00:09:41.300 --> 00:09:46.010
把它不安全地放在本地

00:09:43.700 --> 00:09:47.630
如此不安全的代码

00:09:46.010 --> 00:09:50.810
此声明的实现

00:09:47.630 --> 00:09:53.180
 Java中的负数，然后调用

00:09:50.810 --> 00:09:55.250
进入Lib JDM本身

00:09:53.180 --> 00:10:00.290
崩溃的实际方法

00:09:55.250 --> 00:10:02.000
发生了，所以它只是一个动画

00:10:00.290 --> 00:10:05.660
我告诉你的那件事不是真的

00:10:02.000 --> 00:10:08.540
将有一个激光笔，以便未来

00:10:05.660 --> 00:10:11.270
回到我们的概述，所以我们坠毁了

00:10:08.540 --> 00:10:16.130
执行运行时代码时的运行时

00:10:11.270 --> 00:10:17.930
在Java线程中很容易

00:10:16.130 --> 00:10:19.880
进一步研究热点错误

00:10:17.930 --> 00:10:22.190
文件中有一个包含

00:10:19.880 --> 00:10:26.930
记录该值的订单

00:10:22.190 --> 00:10:30.050
在VM崩溃时以及在您注册时进行注册

00:10:26.930 --> 00:10:31.820
可以看到包含

00:10:30.050 --> 00:10:34.310
值42这实际上是我们的方式

00:10:31.820 --> 00:10:38.540
正在写地址99 

00:10:34.310 --> 00:10:43.360
记住并寻址该寄存器dxdx 

00:10:38.540 --> 00:10:45.380
包含地址，但这是一个

00:10:43.360 --> 00:10:48.140
注册到内存映射不是

00:10:45.380 --> 00:10:51.410
实际上只是纯寄存器值

00:10:48.140 --> 00:10:54.590
正如您在撰写本文时所看到的

00:10:51.410 --> 00:10:57.290
 VM尝试制作的热点错误文件

00:10:54.590 --> 00:11:01.220
这些价值观的意义，例如

00:10:57.290 --> 00:11:04.160
寄存器RBX包含一个奇怪的十六进制

00:11:01.220 --> 00:11:06.230
我们知道它是什么的价值，但是

00:11:04.160 --> 00:11:09.190
虚拟机可以发现这是

00:11:06.230 --> 00:11:11.300
实际上是一个指向put int方法的指针

00:11:09.190 --> 00:11:14.000
所以

00:11:11.300 --> 00:11:16.700
对于这些其他值，虚拟机无法

00:11:14.000 --> 00:11:18.170
找出或实际上这是

00:11:16.700 --> 00:11:21.470
指向堆栈，但没有

00:11:18.170 --> 00:11:24.560
关于它的更多信息，最后我们

00:11:21.470 --> 00:11:26.930
在我们看到的页面顶部看到它

00:11:24.560 --> 00:11:29.270
这个奇怪的箭头说错误

00:11:26.930 --> 00:11:32.210
在错误报告期间发生

00:11:29.270 --> 00:11:33.830
 VM正在写入错误文件

00:11:32.210 --> 00:11:35.810
试图理解价值观

00:11:33.830 --> 00:11:36.980
包含在它运行的寄存器中

00:11:35.810 --> 00:11:40.280
另一个问题可能是另一个

00:11:36.980 --> 00:11:43.250
细分错误，因为我告诉过您

00:11:40.280 --> 00:11:45.830
我们处于不一致状态的虚拟机

00:11:43.250 --> 00:11:47.660
无法确定中的所有值

00:11:45.830 --> 00:11:49.070
如果有物件则登记

00:11:47.660 --> 00:11:52.160
他们指向的地方，但尝试

00:11:49.070 --> 00:11:55.190
找出来，并在此过程中

00:11:52.160 --> 00:11:59.360
它可能会遇到另一个问题，但

00:11:55.190 --> 00:12:01.010
有一个非常复杂的算法

00:11:59.360 --> 00:12:03.740
在抓住这个的热点

00:12:01.010 --> 00:12:07.130
分段错误将其忽略，并且

00:12:03.740 --> 00:12:08.660
尝试向前反转

00:12:07.130 --> 00:12:11.090
热点FS提供尽可能多的

00:12:08.660 --> 00:12:13.040
信息，所以在此之后

00:12:11.090 --> 00:12:16.160
错误，本节将被关闭

00:12:13.040 --> 00:12:19.090
注册映射，但热点写作

00:12:16.160 --> 00:12:22.640
下一节将继续

00:12:19.090 --> 00:12:26.180
实际上下一部分是纯

00:12:22.640 --> 00:12:28.910
注册值，在这里您看到了

00:12:26.180 --> 00:12:34.150
无法理解寄存器R 9，所以

00:12:28.910 --> 00:12:37.090
在这里我们看到寄存器R 9具有该值

00:12:34.150 --> 00:12:39.290
而这恰好指向堆

00:12:37.090 --> 00:12:42.830
但这并没有真正指向

00:12:39.290 --> 00:12:45.140
对象的开始，因此

00:12:42.830 --> 00:12:47.660
 VM想要打印出

00:12:45.140 --> 00:12:48.890
对象，但因为它刚发生

00:12:47.660 --> 00:12:51.830
指向堆，但不在开始

00:12:48.890 --> 00:12:55.100
跟随时崩溃的对象

00:12:51.830 --> 00:12:58.730
对象的类指针，所以在这里

00:12:55.100 --> 00:13:01.790
我们至少得到了

00:12:58.730 --> 00:13:06.290
注册是

00:13:01.790 --> 00:13:09.230
所以走得更远，我们也得到了价值

00:13:06.290 --> 00:13:11.990
当它们位于堆栈顶部时

00:13:09.230 --> 00:13:13.940
发生错误，我们也得到了

00:13:11.990 --> 00:13:15.880
之前和之后的值

00:13:13.940 --> 00:13:19.750
发生坠机的指示

00:13:15.880 --> 00:13:23.480
所以当车祸发生在

00:13:19.750 --> 00:13:25.070
 Lib JVM中的C ++很重要，我们实际上可以

00:13:23.480 --> 00:13:26.750
实际上可以提取

00:13:25.070 --> 00:13:29.210
手动，但如果发生在

00:13:26.750 --> 00:13:31.280
生成的代码，这可能非常有用

00:13:29.210 --> 00:13:33.560
有实际的指示

00:13:31.280 --> 00:13:35.090
已被执行，因为不会

00:13:33.560 --> 00:13:50.930
容易提取它们，如果不是

00:13:35.090 --> 00:13:59.360
没有核心文件是是非

00:13:50.930 --> 00:14:02.660
映射各种回我

00:13:59.360 --> 00:14:04.220
告诉你，因为我知道我的意思是我们

00:14:02.660 --> 00:14:06.590
只是分析热点错误文件

00:14:04.220 --> 00:14:08.360
我们看到它有这条线，所以

00:14:06.590 --> 00:14:11.060
说，当这伤害了我

00:14:08.360 --> 00:14:12.650
被写成没有意义

00:14:11.060 --> 00:14:14.870
注册九，我刚刚告诉你

00:14:12.650 --> 00:14:18.430
为什么会这样，因为我知道何时

00:14:14.870 --> 00:14:21.710
您在调试此崩溃时

00:14:18.430 --> 00:14:22.940
你，你在调试帽子

00:14:21.710 --> 00:14:26.240
无论将要写入什么文件

00:14:22.940 --> 00:14:27.950
看到它尝试打印的值

00:14:26.240 --> 00:14:32.530
该对象然后崩溃

00:14:27.950 --> 00:14:32.530
时间，然后打印此值

00:14:35.560 --> 00:14:42.250
我认为这个西Java 9实际上可以

00:14:39.250 --> 00:14:46.840
只是查找它应该在这里

00:14:42.250 --> 00:14:49.930
我在这里看不到，但是是Java 

00:14:46.840 --> 00:14:53.440
 9我刚刚使用了Java 9的调试版本

00:14:49.930 --> 00:14:56.440
为此，但它也会在Java中发生

00:14:53.440 --> 00:14:58.240
 8，因为如果您写入地址99 

00:14:56.440 --> 00:15:01.540
不安全的情况下，您的平均崩溃率

00:14:58.240 --> 00:15:04.840
曾经的版本还可以，所以让我们继续

00:15:01.540 --> 00:15:06.430
我们是指示，即使您

00:15:04.840 --> 00:15:09.460
只有这个十六进制的

00:15:06.430 --> 00:15:11.260
您可以使用gdb或对象的说明

00:15:09.460 --> 00:15:12.940
转储或在线或SEM拆装器

00:15:11.260 --> 00:15:15.130
一些东西可以拆开

00:15:12.940 --> 00:15:17.770
指令，你实际上看到了

00:15:15.130 --> 00:15:21.640
指令写的内容

00:15:17.770 --> 00:15:28.600
注册是42的地址的斧头

00:15:21.640 --> 00:15:30.580
 X的RDX是99，所以我们

00:15:28.600 --> 00:15:33.160
看到热点错误文件包含

00:15:30.580 --> 00:15:33.910
很多有用和有趣的

00:15:33.160 --> 00:15:36.100
信息

00:15:33.910 --> 00:15:39.130
所以有时候我们可能想要这个

00:15:36.100 --> 00:15:41.370
信息而不会导致VM崩溃

00:15:39.130 --> 00:15:44.910
因此我们可以使用J命令

00:15:41.370 --> 00:15:47.650
 JDK附带的实用程序

00:15:44.910 --> 00:15:50.500
分布，我们可以叫J 

00:15:47.650 --> 00:15:52.540
命令与您的进程的PID 

00:15:50.500 --> 00:15:57.340
您的Java进程和命令vm信息

00:15:52.540 --> 00:15:59.590
如果您生成所谓的vm info 

00:15:57.340 --> 00:16:02.230
文件不包含所有

00:15:59.590 --> 00:16:03.610
我们热点错误文件的信息

00:16:02.230 --> 00:16:06.340
当发生崩溃时，因为

00:16:03.610 --> 00:16:08.530
我们不是在崩溃中，但它仍然

00:16:06.340 --> 00:16:09.820
包含很多有用的信息，所以

00:16:08.530 --> 00:16:14.290
例如在这里你可以看到这个

00:16:09.820 --> 00:16:15.880
是jdk 9包含的慢调试字段

00:16:14.290 --> 00:16:17.050
命令行中包含

00:16:15.880 --> 00:16:19.930
硬件

00:16:17.050 --> 00:16:22.060
它包含堆地址和很多

00:16:19.930 --> 00:16:23.710
其他有用的东西，所以有时当

00:16:22.060 --> 00:16:26.740
客户有问题可以问一下

00:16:23.710 --> 00:16:29.080
他要给他发送这样的信息文件

00:16:26.740 --> 00:16:30.940
生成它，因此生成此信息

00:16:29.080 --> 00:16:33.790
西装应该很安全

00:16:30.940 --> 00:16:36.160
生成此类信息文件的示例

00:16:33.790 --> 00:16:38.350
不注册到区域

00:16:36.160 --> 00:16:42.250
映射，因为如我们所见

00:16:38.350 --> 00:16:46.690
危险的，所以它只打印纯

00:16:42.250 --> 00:16:48.100
地址的值，因为您没有

00:16:46.690 --> 00:16:49.329
想要使VM崩溃只是为了获得

00:16:48.100 --> 00:16:54.670
信息全部

00:16:49.329 --> 00:16:58.689
学习虚拟机对不起，所以现在

00:16:54.670 --> 00:17:01.569
让我们从一个真实的例子开始

00:16:58.689 --> 00:17:04.029
假设有人您的一些客户

00:17:01.569 --> 00:17:06.789
或同事向您显示此崩溃文件

00:17:04.029 --> 00:17:09.429
还是这次崩溃，问你能做什么

00:17:06.789 --> 00:17:13.809
说出发生了什么事，所以我的意思是

00:17:09.429 --> 00:17:16.870
听众发生在这里，所以有一个

00:17:13.809 --> 00:17:19.929
看起来我们看到这次我们没有

00:17:16.870 --> 00:17:22.569
崩溃在本机代码或嘴唇

00:17:19.929 --> 00:17:25.029
当VM请求解释代码时

00:17:22.569 --> 00:17:27.069
所以这个小写的J表示它是Java 

00:17:25.029 --> 00:17:29.019
方法，它是一种解释方法

00:17:27.069 --> 00:17:31.960
大写字母J表示这只是一个

00:17:29.019 --> 00:17:35.230
时间编译器方法，因此我们崩溃了

00:17:31.960 --> 00:17:40.440
解释方法，称为崩溃

00:17:35.230 --> 00:17:43.149
因为这又是一个例子

00:17:40.440 --> 00:17:45.220
我们得到了PC分割错误

00:17:43.149 --> 00:17:47.470
这次发生了

00:17:45.220 --> 00:17:49.929
我们还获得了其他信息，因为

00:17:47.470 --> 00:17:52.360
我们在即时编译器中崩溃了

00:17:49.929 --> 00:17:54.510
所以热点错误文件，这是

00:17:52.360 --> 00:17:56.980
热点错误文件的内容

00:17:54.510 --> 00:17:58.840
总结我省略了一些部分

00:17:56.980 --> 00:18:03.850
我们已经知道了，所以这次

00:17:58.840 --> 00:18:06.639
热所以吓人还包含

00:18:03.850 --> 00:18:10.059
字节码的模板，其中

00:18:06.639 --> 00:18:11.710
解释器缓存崩溃，因此热点

00:18:10.059 --> 00:18:14.529
有一个所谓的模板解释器

00:18:11.710 --> 00:18:18.070
这意味着它会产生装配

00:18:14.529 --> 00:18:20.860
对于每个Java字节码，然后调用

00:18:18.070 --> 00:18:22.630
他们一个接一个地执行着你

00:18:20.860 --> 00:18:24.940
知道字节码，这一次我们崩溃了

00:18:22.630 --> 00:18:26.380
在错误长度字节码和

00:18:24.940 --> 00:18:29.320
热点错误火包含

00:18:26.380 --> 00:18:35.139
为此错误长度生成的代码

00:18:29.320 --> 00:18:38.110
字节码，我们可以在下面看到地址

00:18:35.139 --> 00:18:39.850
我们坠毁了，我们看到了

00:18:38.110 --> 00:18:42.130
这是在哪个请求的说明

00:18:39.850 --> 00:18:44.049
崩溃的指令，我们看到了

00:18:42.130 --> 00:18:49.120
寄存器区X包含奇数

00:18:44.049 --> 00:18:51.850
值蝙蝠宝宝，所以这就是所谓的眼睛

00:18:49.120 --> 00:18:56.679
经常使用的捕手

00:18:51.850 --> 00:18:59.139
在整个热点2使用零

00:18:56.679 --> 00:19:02.680
记忆或显示一些值

00:18:59.139 --> 00:19:05.530
非法的，所以如果你看到这样的价值观

00:19:02.680 --> 00:19:07.600
您可以搜索代码并查看

00:19:05.530 --> 00:19:10.060
这些值写在哪里

00:19:07.600 --> 00:19:13.320
可能会让您知道为什么此崩溃

00:19:10.060 --> 00:19:17.020
发生了，我们实际上正在移动

00:19:13.320 --> 00:19:21.880
该地址的ax值和

00:19:17.020 --> 00:19:25.360
入口崩溃，让我们看看我

00:19:21.880 --> 00:19:28.030
引发了这个错误

00:19:25.360 --> 00:19:31.030
设法使虚拟机处于以下状态

00:19:28.030 --> 00:19:34.830
它在解释器中崩溃了，所以这是

00:19:31.030 --> 00:19:42.220
一个非常简单的程序，称为crash int 

00:19:34.830 --> 00:19:44.710
它有一个它包含一个整数数组

00:19:42.220 --> 00:19:46.480
你有一个崩溃功能

00:19:44.710 --> 00:19:49.990
返回此数组的长度，然后

00:19:46.480 --> 00:19:54.850
再一次，我们创建一个崩溃到对象

00:19:49.990 --> 00:19:57.220
我们用不安全的方法来放一些这种不好的东西

00:19:54.850 --> 00:19:58.990
该对象地址处的支付价值

00:19:57.220 --> 00:20:01.270
不安全，所以这又是

00:19:58.990 --> 00:20:06.270
你不应该只是为了缘故

00:20:01.270 --> 00:20:09.370
的例子，然后我们称崩溃

00:20:06.270 --> 00:20:13.920
这是我们崩溃的内存布局

00:20:09.370 --> 00:20:13.920
放入堆中的对象，因此包含

00:20:14.340 --> 00:20:19.420
具有指向的指针的对象标头

00:20:16.930 --> 00:20:21.460
标记词中的类或对象，以及

00:20:19.420 --> 00:20:24.910
然后是实际数据本身

00:20:21.460 --> 00:20:27.310
如果数据只是对

00:20:24.910 --> 00:20:28.600
整数数组，然后在另一个地方

00:20:27.310 --> 00:20:30.960
放在堆中，我们有整数

00:20:28.600 --> 00:20:33.880
再次错误本身整数数组有

00:20:30.960 --> 00:20:36.400
对象标头，然后有一个长度字段

00:20:33.880 --> 00:20:38.710
这是长度为1的整数区域

00:20:36.400 --> 00:20:43.570
所以它包含一个整数，所以当我们

00:20:38.710 --> 00:20:48.250
将这个值错误的管道写入I 

00:20:43.570 --> 00:20:50.770
当前对象的偏移量12 

00:20:48.250 --> 00:20:52.510
我们将覆盖对

00:20:50.770 --> 00:20:55.360
整数数组，这将指向

00:20:52.510 --> 00:20:59.920
某个地方到无处，所以当我们

00:20:55.360 --> 00:21:02.230
实际执行功能崩溃

00:20:59.920 --> 00:21:04.480
所以这是我们崩溃的字节码

00:21:02.230 --> 00:21:07.000
您可以通过运行获得的功能

00:21:04.480 --> 00:21:10.660
 Java P在类上您会看到它

00:21:07.000 --> 00:21:16.210
实际上会加载，因此加载此

00:21:10.660 --> 00:21:18.369
然后获得推动的获取领域

00:21:16.210 --> 00:21:21.009
堆栈上的整数区域以及任何

00:21:18.369 --> 00:21:25.539
成本错误哭声和错误分支

00:21:21.009 --> 00:21:28.179
当然要访问长度字段

00:21:25.539 --> 00:21:33.490
这个对象的东西，所以这就是你

00:21:28.179 --> 00:21:37.600
实际上我们在这里看到的

00:21:33.490 --> 00:21:39.820
偏移此对象的十二

00:21:37.600 --> 00:21:41.619
包含长度，但是当我们

00:21:39.820 --> 00:21:44.710
访问这个我们崩溃了，因为

00:21:41.619 --> 00:21:47.379
我们已经覆盖了这个，所以这再次是

00:21:44.710 --> 00:21:48.909
只是一个例子，这个例子也

00:21:47.379 --> 00:21:50.950
给你看东西

00:21:48.909 --> 00:21:54.100
在分析崩溃时非常重要

00:21:50.950 --> 00:21:56.049
因为实际上我们已经坠毁了

00:21:54.100 --> 00:21:58.119
解释器中的解释器方法，但

00:21:56.049 --> 00:22:01.179
这不是解释器中的错误

00:21:58.119 --> 00:22:03.059
解释器什么工作很好，如果

00:22:01.179 --> 00:22:05.619
你有例如简我的代码

00:22:03.059 --> 00:22:07.570
实际上我实际上已经模拟了j'ni 

00:22:05.619 --> 00:22:09.909
代码不安全，因此如果您有J＆I 

00:22:07.570 --> 00:22:11.610
例如代码并污染您的堆

00:22:09.909 --> 00:22:14.340
或者在你的堆里做一些坏事

00:22:11.610 --> 00:22:16.960
一切都会发生，所以我们只是

00:22:14.340 --> 00:22:18.519
破坏了堆中的对象，并且

00:22:16.960 --> 00:22:20.830
然后我们终于坠毁了

00:22:18.519 --> 00:22:24.240
口译员，这就是你

00:22:20.830 --> 00:22:26.379
必须记住您的成本

00:22:24.240 --> 00:22:28.960
对象并不总是与

00:22:26.379 --> 00:22:31.470
你真正崩溃的地方

00:22:28.960 --> 00:22:40.179
使得发现错误非常棘手

00:22:31.470 --> 00:22:43.149
有时还可以，所以我现在来

00:22:40.179 --> 00:22:44.950
真实的例子，那么你的问题

00:22:43.149 --> 00:22:47.769
直到现在才真正从我们的客户那里得到

00:22:44.950 --> 00:22:50.350
我们只有两个例子向您展示

00:22:47.769 --> 00:22:53.139
一切实际上都有效，所以我们得到了

00:22:50.350 --> 00:22:55.450
来自客户的消息，他得到了

00:22:53.139 --> 00:22:58.690
内存不足错误内存不足元

00:22:55.450 --> 00:23:02.499
空间，这是我们收到的所有错误信息

00:22:58.690 --> 00:23:05.769
信息，因此您可以选择一种

00:23:02.499 --> 00:23:09.119
如果客户使用该程序，则使用

00:23:05.769 --> 00:23:13.539
还是因为异常而停止

00:23:09.119 --> 00:23:16.990
可以尝试使用xx崩溃

00:23:13.539 --> 00:23:21.249
内存错误，因此在这种情况下，VM将

00:23:16.990 --> 00:23:23.289
不仅退出，而且有例外

00:23:21.249 --> 00:23:25.899
但它会同时产生一个

00:23:23.289 --> 00:23:29.109
完整的热点错误文件和核心

00:23:25.899 --> 00:23:30.520
文件，我们要求客户做到这一点， 

00:23:29.109 --> 00:23:33.730
他发给我们

00:23:30.520 --> 00:23:42.490
生成的热点错误文件和

00:23:33.730 --> 00:23:43.930
对应的代码文件很快这个

00:23:42.490 --> 00:23:46.540
发生在Java 8中

00:23:43.930 --> 00:23:52.660
问题是在Java 8中，但我已经

00:23:46.540 --> 00:23:54.610
用Java 9转移对其进行了分析

00:23:52.660 --> 00:23:56.650
已经在Java 8中，所以舞会甘蔗是

00:23:54.610 --> 00:24:03.820
在Java 8中删除并由meta代替

00:23:56.650 --> 00:24:09.660
空间，这是Java 8向上的状态，所以

00:24:03.820 --> 00:24:14.020
看起来怎么样，这不是

00:24:09.660 --> 00:24:17.550
来自客户的热点错误提示

00:24:14.020 --> 00:24:20.140
我不能告诉你这个，但我已经做了

00:24:17.550 --> 00:24:21.790
完全相同的复制器

00:24:20.140 --> 00:24:23.500
发生在客户端的事情

00:24:21.790 --> 00:24:31.750
我会告诉你

00:24:23.500 --> 00:24:34.420
谈话还可以，所以您可以看到

00:24:31.750 --> 00:24:37.870
程序正在调用它具有的定义类

00:24:34.420 --> 00:24:41.230
然后是一个类加载器分类器解析器

00:24:37.870 --> 00:24:43.600
实际上恒定池分配它运行

00:24:41.230 --> 00:24:45.910
进入错误，所以这不会

00:24:43.600 --> 00:24:48.340
看起来很奇怪，我的意思是Java程序应该

00:24:45.910 --> 00:24:51.520
加载类并分配常量池

00:24:48.340 --> 00:24:52.960
等等，热点的另一部分

00:24:51.520 --> 00:24:55.900
我没有的错误文件

00:24:52.960 --> 00:24:58.590
在事件发生之前没有向您显示

00:24:55.900 --> 00:25:02.770
部分，因此热点错误文件也

00:24:58.590 --> 00:25:06.630
有一个记录重要的部分

00:25:02.770 --> 00:25:09.700
执行期间发生的事件以及

00:25:06.630 --> 00:25:11.230
您可以在崩溃之前看到

00:25:09.700 --> 00:25:13.570
发生了

00:25:11.230 --> 00:25:18.180
问题是加载自定义类

00:25:13.570 --> 00:25:19.930
加载程序，最后执行

00:25:18.180 --> 00:25:21.700
收集元空间

00:25:19.930 --> 00:25:24.370
因为它显然空间不足

00:25:21.700 --> 00:25:26.650
你会看到元空间

00:25:24.370 --> 00:25:30.070
馆藏非常免费

00:25:26.650 --> 00:25:33.570
内存，但无法成功，所以

00:25:30.070 --> 00:25:36.840
实际上是错误原因

00:25:33.570 --> 00:25:40.240
所以有了这些信息我们就无法获得

00:25:36.840 --> 00:25:42.190
任何进一步，但还有其他有用的

00:25:40.240 --> 00:25:44.740
维修性代理等工具

00:25:42.190 --> 00:25:48.820
您可以用来检查核心

00:25:44.740 --> 00:25:53.350
所以我们也得到了核心文件

00:25:48.820 --> 00:25:55.330
 Java热点的热点调试器

00:25:53.350 --> 00:25:58.210
 Java 9调试器的可维护性

00:25:55.330 --> 00:26:00.630
工具来分析此核心文件和

00:25:58.210 --> 00:26:04.420
热点调试器具有类浏览器

00:26:00.630 --> 00:26:06.790
这使您可以查找所有

00:26:04.420 --> 00:26:09.970
将所有活动的加载类分类

00:26:06.790 --> 00:26:14.710
 VM崩溃以及何时崩溃

00:26:09.970 --> 00:26:17.830
您在一个中寻找这些类

00:26:14.710 --> 00:26:21.630
显示此示例的包夸克

00:26:17.830 --> 00:26:24.040
西蒙尼斯（Simonis）我们看到我们实际上有

00:26:21.630 --> 00:26:27.700
这个自定义类加载器

00:26:24.040 --> 00:26:30.700
崩溃前加载，我们有两个

00:26:27.700 --> 00:26:33.280
同一类的版本，因此

00:26:30.700 --> 00:26:36.520
其实也不罕见，因为你

00:26:33.280 --> 00:26:39.490
用Java知道每个类加载器都可以拥有

00:26:36.520 --> 00:26:41.530
它自己的类版本，所以当您

00:26:39.490 --> 00:26:45.280
有一个自定义的类加载器，这是可能的

00:26:41.530 --> 00:26:48.460
它是内存崩溃的版本

00:26:45.280 --> 00:26:49.660
同时应用程序类

00:26:48.460 --> 00:26:51.730
桌子本可以上课

00:26:49.660 --> 00:26:53.620
之前有一个类的两个两个版本

00:26:51.730 --> 00:26:57.520
其实不应该不坏

00:26:53.620 --> 00:26:59.980
填补元空间，以便我们可以挖掘

00:26:57.520 --> 00:27:03.310
进一步在热点错误文件中

00:26:59.980 --> 00:27:06.250
还包含最后一个例外

00:27:03.310 --> 00:27:08.620
被虚拟机扔了

00:27:06.250 --> 00:27:10.630
虚拟机之前的最后十个异常

00:27:08.620 --> 00:27:14.770
坠毁，在这里我们看到一个有趣的

00:27:10.630 --> 00:27:19.960
所以在VM崩溃之前它显示了

00:27:14.770 --> 00:27:21.520
链接错误异常

00:27:19.960 --> 00:27:26.200
链接异常由我们抛出

00:27:21.520 --> 00:27:29.260
自定义类加载器，它表示尝试

00:27:26.200 --> 00:27:31.540
为名称定义类定义

00:27:29.260 --> 00:27:34.870
我们的班级名称很明显

00:27:31.540 --> 00:27:38.260
许多贴花的最后定义

00:27:34.870 --> 00:27:40.180
发生，当然是一类命令

00:27:38.260 --> 00:27:41.950
只能有一个类别的一个版本

00:27:40.180 --> 00:27:44.350
类，如果它尝试重新加载相同的

00:27:41.950 --> 00:27:46.720
类它得到这个异常，但这

00:27:44.350 --> 00:27:50.050
例外显然是由

00:27:46.720 --> 00:27:52.090
应用程序，所以我们没有看到它们，但是在

00:27:50.050 --> 00:27:54.190
最终导致内存不足

00:27:52.090 --> 00:27:55.630
在元空间，所以还是这样

00:27:54.190 --> 00:27:58.179
不应该发生，因为我的意思是我们

00:27:55.630 --> 00:28:01.389
处理这个异常，为什么我们得到一个

00:27:58.179 --> 00:28:05.019
内存不足错误在这里，所以

00:28:01.389 --> 00:28:07.149
稳定剂实际上是非常非常

00:28:05.019 --> 00:28:09.610
功能强大的工具，我们不仅可以使用

00:28:07.149 --> 00:28:11.440
图形工具

00:28:09.610 --> 00:28:14.289
有了它我们也可以使用它

00:28:11.440 --> 00:28:19.059
以编程方式它具有一个API并且它

00:28:14.289 --> 00:28:21.999
允许我们检查所有数据

00:28:19.059 --> 00:28:26.350
构造所有C ++数据结构

00:28:21.999 --> 00:28:30.600
热点在其维护期间

00:28:26.350 --> 00:28:32.799
运行时间，例如每个课程

00:28:30.600 --> 00:28:34.480
您在Java中拥有的对象

00:28:32.799 --> 00:28:38.909
在Java中，您可以获取，可以调用get 

00:28:34.480 --> 00:28:43.360
每个对象上的类都有一个对应的

00:28:38.909 --> 00:28:47.289
凯的一个C ++对象中的类

00:28:43.360 --> 00:28:51.549
热点，现在我们可以使用

00:28:47.289 --> 00:28:54.279
这些的服务性代理商

00:28:51.549 --> 00:28:57.759
这些这些的C ++表示

00:28:54.279 --> 00:28:59.889
核心文件中的Java类

00:28:57.759 --> 00:29:02.710
这就是所谓的

00:28:59.889 --> 00:29:06.820
数据图对象是所有类

00:29:02.710 --> 00:29:10.360
热点中的类加载器，那么我们

00:29:06.820 --> 00:29:15.850
走他们，对于每一个类装载者

00:29:10.360 --> 00:29:18.460
查询其中所有的C ++类对象

00:29:15.850 --> 00:29:22.539
一次很活跃，我们将它们打印出来

00:29:18.460 --> 00:29:25.029
存入内存，所以当我们运行它时

00:29:22.539 --> 00:29:27.909
再次编程，这是使用Java 9完成的

00:29:25.029 --> 00:29:30.909
所以我们必须添加JDK热点代理

00:29:27.909 --> 00:29:34.539
 Java 8的模块，它在工具I中

00:29:30.909 --> 00:29:35.889
想想牙罐锉，所以如果你有一个

00:29:34.539 --> 00:29:38.139
 JDK，您无需执行任何操作

00:29:35.889 --> 00:29:41.730
无论哪个9您都必须添加模块

00:29:38.139 --> 00:29:44.259
而且还增加了很多出口，因为

00:29:41.730 --> 00:29:47.019
不幸的是，该API并未公开

00:29:44.259 --> 00:29:50.460
导出了，所以如果您在

00:29:47.019 --> 00:29:55.600
我们的核心文件中，我们将看到

00:29:50.460 --> 00:29:58.419
我们有很多C ++类

00:29:55.600 --> 00:30:00.460
实际上我们有两个类的版本

00:29:58.419 --> 00:30:02.320
使用Java，然后运行

00:30:00.460 --> 00:30:06.309
通过什么计数我们看到我们有

00:30:02.320 --> 00:30:08.590
实际上是320个版本，所以这是

00:30:06.309 --> 00:30:10.869
显然不行，因为您应该只

00:30:08.590 --> 00:30:12.070
具有一个C ++类表示

00:30:10.869 --> 00:30:17.670
每个JAVA

00:30:12.070 --> 00:30:20.350
所有这些信息

00:30:17.670 --> 00:30:23.380
我们能够重现问题

00:30:20.350 --> 00:30:25.720
这实际上是转载人

00:30:23.380 --> 00:30:29.350
我也在这个演讲中使用了

00:30:25.720 --> 00:30:32.650
所以我们实际上要做的是

00:30:29.350 --> 00:30:35.200
我们类的字节码我们定义一个

00:30:32.650 --> 00:30:37.780
已知的类加载器以重新定义

00:30:35.200 --> 00:30:40.510
定义的类方法的类顺序

00:30:37.780 --> 00:30:46.570
受保护，然后进入循环

00:30:40.510 --> 00:30:49.480
我们迅速定义了相同的类，因此

00:30:46.570 --> 00:30:50.980
将在第一次和之后成功

00:30:49.480 --> 00:30:53.680
第一次我们显然会得到

00:30:50.980 --> 00:30:56.320
我们捕获的链接错误以及何时发生

00:30:53.680 --> 00:30:59.080
我们可以循环进行复制

00:30:56.320 --> 00:31:01.780
这个问题，发现内存泄漏，所以

00:30:59.080 --> 00:31:03.400
这是meta的第一天问题

00:31:01.780 --> 00:31:07.360
引入的空间变化

00:31:03.400 --> 00:31:10.810
 Java 8显然从来没有人这样做

00:31:07.360 --> 00:31:12.550
在发现链接错误之前，我们

00:31:10.810 --> 00:31:15.310
客户出于某种原因这样做了， 

00:31:12.550 --> 00:31:19.150
然后他遇到了这个问题，所以我解决了

00:31:15.310 --> 00:31:24.880
就像2017年2月一样

00:31:19.150 --> 00:31:27.360
 Java 9好了，让我们来看一下

00:31:24.880 --> 00:31:27.360
下一个例子

00:31:27.660 --> 00:31:37.900
所以我来看看这个热点错误

00:31:31.690 --> 00:31:43.570
这次我们在lip JVM中崩溃了

00:31:37.900 --> 00:31:44.890
在海量代码中生成数组副本，如果

00:31:43.570 --> 00:31:46.870
你对短裤不熟悉

00:31:44.890 --> 00:31:49.270
这什么都没告诉你，但是你

00:31:46.870 --> 00:31:51.790
看到它生成了一个核心文件热点

00:31:49.270 --> 00:31:55.630
错误文件，这次证书文件有

00:31:51.790 --> 00:31:58.330
生成了所谓的重播文件

00:31:55.630 --> 00:32:01.350
这很有趣，因为这意味着

00:31:58.330 --> 00:32:04.330
这次崩溃发生了

00:32:01.350 --> 00:32:06.130
在JIT编译期间

00:32:04.330 --> 00:32:08.560
我们可以在房子里看到这个

00:32:06.130 --> 00:32:12.100
错误文件，因此我们看到了

00:32:08.560 --> 00:32:13.630
该程序，我们看到当前

00:32:12.100 --> 00:32:17.560
坠机发生的威胁是

00:32:13.630 --> 00:32:19.230
 C 2编译器的威胁我们还看到

00:32:17.560 --> 00:32:23.770
崩溃发生时读取了汇编

00:32:19.230 --> 00:32:25.660
崩溃方法，然后我们得到

00:32:23.770 --> 00:32:28.450
堆栈跟踪并看到

00:32:25.660 --> 00:32:31.050
发生在一种称为“生成时代”的方法中

00:32:28.450 --> 00:32:33.790
咖啡，所以很明显，我们再次编译了

00:32:31.050 --> 00:32:35.920
阵列复制系统的每种复制方法和

00:32:33.790 --> 00:32:39.760
当我们编译那个

00:32:35.920 --> 00:32:41.800
编译器由于某种原因而崩溃，因此

00:32:39.760 --> 00:32:46.240
我们现在在哪里，我们坠毁了

00:32:41.800 --> 00:32:48.070
 C2编译器中的C ++代码不在

00:32:46.240 --> 00:32:51.640
生成的代码，但每次调用C加上

00:32:48.070 --> 00:32:54.400
 C2应该来编译汗水，所以

00:32:51.640 --> 00:32:57.670
现在我们可以使用重播编译和

00:32:54.400 --> 00:33:01.000
 Java feed中的重放数据文件选项

00:32:57.670 --> 00:33:04.030
此重播文件可重现

00:33:01.000 --> 00:33:05.950
问题，但是当我们尝试

00:33:04.030 --> 00:33:10.380
重现崩溃没有的问题

00:33:05.950 --> 00:33:12.910
发生，所以任何想法为什么没有发生

00:33:10.380 --> 00:33:15.640
所以如果你仔细看热点

00:33:12.910 --> 00:33:18.700
错误文件，您可能还记得它是一个

00:33:15.640 --> 00:33:21.910
命令行使用称为

00:33:18.700 --> 00:33:23.740
 xx-逃脱分析，所以程序是

00:33:21.910 --> 00:33:26.020
运行时没有转义分析

00:33:23.740 --> 00:33:28.390
崩溃了，所以如果您想重现

00:33:26.020 --> 00:33:30.280
问题，我们显然必须使用

00:33:28.390 --> 00:33:31.750
完全相同的命令行选项

00:33:30.280 --> 00:33:33.910
因为否则其他代码将是

00:33:31.750 --> 00:33:35.770
产生的其他成本路径

00:33:33.910 --> 00:33:38.890
并不意味着我们可以复制

00:33:35.770 --> 00:33:40.420
问题，这就是为什么命令行

00:33:38.890 --> 00:33:43.420
热点错误文件中的参数是

00:33:40.420 --> 00:33:46.060
对于重现问题很有用

00:33:43.420 --> 00:33:47.680
当我们在上使用完全相同的选项时

00:33:46.060 --> 00:33:51.190
现在在命令行重播

00:33:47.680 --> 00:33:51.790
您看到的文件可以很容易地复制

00:33:51.190 --> 00:33:54.580
问题

00:33:51.790 --> 00:33:57.730
所以很明显，这意味着我们需要相同的

00:33:54.580 --> 00:33:59.740
类路径上的类作为

00:33:57.730 --> 00:34:02.020
客户，因此只有在您

00:33:59.740 --> 00:34:05.380
具有与该程序相同的版本

00:34:02.020 --> 00:34:07.000
客户拥有了，现在我们可以

00:34:05.380 --> 00:34:11.860
重播此重播问题

00:34:07.000 --> 00:34:14.919
文件，使用其他本机非常容易

00:34:11.860 --> 00:34:17.910
例如gdb的调试器放置一个

00:34:14.919 --> 00:34:21.550
断点到冒犯的方法和

00:34:17.910 --> 00:34:24.450
运行程序，看看会发生什么

00:34:21.550 --> 00:34:29.020
我再次在这里作弊

00:34:24.450 --> 00:34:32.260
实际上我刚刚修补了虚拟机

00:34:29.020 --> 00:34:34.750
这样它就崩溃了

00:34:32.260 --> 00:34:36.190
这个特殊的例子，但这是

00:34:34.750 --> 00:34:38.690
实际上它如何在

00:34:36.190 --> 00:34:41.210
相对有一个问题

00:34:38.690 --> 00:34:42.740
在他们经常不经常但是

00:34:41.210 --> 00:34:45.950
有时在

00:34:42.740 --> 00:34:47.929
指示仅在以下位置出现的编译器

00:34:45.950 --> 00:34:50.419
你知道很奇怪的情况

00:34:47.929 --> 00:34:52.099
分析是及时的

00:34:50.419 --> 00:34:55.250
编译完成Tina McGee做

00:34:52.099 --> 00:34:58.099
内联这是分析，并在一些

00:34:55.250 --> 00:35:00.020
有时会有奇怪的情况

00:34:58.099 --> 00:35:02.319
发生一些内联一些优化

00:35:00.020 --> 00:35:04.910
从来没有发生过的

00:35:02.319 --> 00:35:07.160
编译器并输入编译

00:35:04.910 --> 00:35:08.690
崩溃，然后对

00:35:07.160 --> 00:35:10.640
有这个重播文件，因为

00:35:08.690 --> 00:35:12.800
重播文件允许您编译

00:35:10.640 --> 00:35:15.430
消息以完全相同的方式

00:35:12.800 --> 00:35:18.170
崩溃发生时会发生，所以

00:35:15.430 --> 00:35:22.280
这次我补充了什么

00:35:18.170 --> 00:35:26.440
我实际上是说，当我们编译时

00:35:22.280 --> 00:35:30.970
数组复制，通用复制方法和

00:35:26.440 --> 00:35:34.910
目标数组的类型是

00:35:30.970 --> 00:35:37.069
在X类中崩溃或在X中崩溃5 

00:35:34.910 --> 00:35:42.020
 X级或X级崩溃6 

00:35:37.069 --> 00:35:44.540
我们只会崩溃，所以看着

00:35:42.020 --> 00:35:47.180
我们使用的程序有一个

00:35:44.540 --> 00:35:51.170
破解类崩溃5 

00:35:47.180 --> 00:35:53.690
这个x和y我们有崩溃方法

00:35:51.170 --> 00:35:56.900
只是导致数组复制需要一个源

00:35:53.690 --> 00:36:01.250
对象并将其复制到

00:35:56.900 --> 00:36:03.410
 X类型的目标数组，如果

00:36:01.250 --> 00:36:05.300
这种情况在这里我们可以引起

00:36:03.410 --> 00:36:07.970
崩溃，然后我们称之为20,000次

00:36:05.300 --> 00:36:11.200
预热JIT编译器并进行编译

00:36:07.970 --> 00:36:14.829
消息，所以我们使用这种方法

00:36:11.200 --> 00:36:14.829
惹出问题

00:36:17.950 --> 00:36:24.880
由于某种原因，幻灯片还可以，所以

00:36:22.510 --> 00:36:28.859
现在我来看看你有什么

00:36:24.880 --> 00:36:32.920
学会到现在为止，我们有一个类似的

00:36:28.859 --> 00:36:36.990
再次崩溃，我们完全一样崩溃

00:36:32.920 --> 00:36:40.599
相同的位置，我们有一个重播文件

00:36:36.990 --> 00:36:43.210
所以这次我们足够聪明

00:36:40.599 --> 00:36:51.849
相同的命令行选项

00:36:43.210 --> 00:36:54.790
在热点错误文件中，我们想要

00:36:51.849 --> 00:36:56.380
重现问题，但是这次我们

00:36:54.790 --> 00:36:58.720
遇到另一个我们实际上无法解决的错误

00:36:56.380 --> 00:37:01.960
重现问题，我们得到一个错误

00:36:58.720 --> 00:37:04.540
在重放编辑内容的同时

00:37:01.960 --> 00:37:07.450
一个奇怪的对不起奇怪的错误

00:37:04.540 --> 00:37:10.150
消息说java.lang类不是我

00:37:07.450 --> 00:37:12.400
发现可以处理的lambda形式善良

00:37:10.150 --> 00:37:17.380
像这样的东西怎么办

00:37:12.400 --> 00:37:19.900
在论坛处理期间表示很好

00:37:17.380 --> 00:37:22.290
调用虚拟机生成的动态

00:37:19.900 --> 00:37:25.869
动态生成字节码

00:37:22.290 --> 00:37:28.089
辅助类，这些类是

00:37:25.869 --> 00:37:30.430
它们在运行时动态生成

00:37:28.089 --> 00:37:33.490
不在您的班级文件中

00:37:30.430 --> 00:37:36.010
应用程序类文件，所以这次我们

00:37:33.490 --> 00:37:37.900
希望它重现我们的编译，但

00:37:36.010 --> 00:37:40.690
并非所有活跃于

00:37:37.900 --> 00:37:43.710
问题发生的时间是

00:37:40.690 --> 00:37:47.049
可用于VM，因此我们会收到此错误

00:37:43.710 --> 00:37:48.520
但是正如我们之前看到的那样

00:37:47.049 --> 00:37:51.309
使用lambdas，所以也许这不是

00:37:48.520 --> 00:37:55.059
重要，这些方法通常是

00:37:51.309 --> 00:37:57.250
并不是真正需要的，所以我们有

00:37:55.059 --> 00:37:59.619
热点提供了额外的选择

00:37:57.250 --> 00:38:02.319
称为重播点燃回复忽略

00:37:59.619 --> 00:38:07.390
初始化错误，您可以使用

00:38:02.319 --> 00:38:10.059
那一个忽略这些错误，所以我们

00:38:07.390 --> 00:38:13.260
看到错误然后被忽略，但是我们

00:38:10.059 --> 00:38:16.690
仍然无法重现我们的问题

00:38:13.260 --> 00:38:19.630
所有初始化过程都将被忽略

00:38:16.690 --> 00:38:22.000
但仍然不会发生错误，因此

00:38:19.630 --> 00:38:23.920
验证我们的消息确实得到了

00:38:22.000 --> 00:38:27.760
编译我们使用打印编译

00:38:23.920 --> 00:38:31.270
如您所见，这次

00:38:27.760 --> 00:38:31.810
崩溃六种崩溃方法，我们在哪里

00:38:31.270 --> 00:38:33.640
坠毁

00:38:31.810 --> 00:38:36.640
我们从热点错误文件中注意到

00:38:33.640 --> 00:38:40.900
确实是被狗屎编译，但是

00:38:36.640 --> 00:38:43.450
没有错误发生，那么可以

00:38:40.900 --> 00:38:47.080
成为这里的问题，所以再次成为热点

00:38:43.450 --> 00:38:50.380
错误文件可能会帮助我们在这里获得一些帮助

00:38:47.080 --> 00:38:54.070
更多信息，例如这里

00:38:50.380 --> 00:38:54.970
包含，如果它表明我们之前

00:38:54.070 --> 00:38:59.880
崩溃发生了

00:38:54.970 --> 00:39:02.710
我们进行了课程重新定义活动

00:38:59.880 --> 00:39:05.200
在运行时，您知道可以使用

00:39:02.710 --> 00:39:07.330
班级仪器和班级

00:39:05.200 --> 00:39:10.450
重新定义以重新定义类

00:39:07.330 --> 00:39:12.430
例子很多工具监控工具

00:39:10.450 --> 00:39:15.070
例如，有时这样做

00:39:12.430 --> 00:39:18.520
他们只是重新定义类或调试器

00:39:15.070 --> 00:39:23.730
也可以找到课程，所以在这里

00:39:18.520 --> 00:39:23.730
我们坠毁的班级真的找到了

00:39:23.880 --> 00:39:29.530
所以我们看到该类已加载，然后

00:39:27.310 --> 00:39:32.530
它被重新定义，所以反对

00:39:29.530 --> 00:39:38.260
适用性代理可能在这里使用

00:39:32.530 --> 00:39:40.630
因为它允许我们转储类

00:39:38.260 --> 00:39:42.820
以他们活跃的形式

00:39:40.630 --> 00:39:45.250
崩溃发生在核心文件中

00:39:42.820 --> 00:39:48.580
它使用限定符中的信息

00:39:45.250 --> 00:39:50.050
重建类文件，这

00:39:48.580 --> 00:39:53.349
实际上不是该类的版本

00:39:50.050 --> 00:39:56.320
静态存储在磁盘上的文件

00:39:53.349 --> 00:39:58.150
但是类的重新定义版本

00:39:56.320 --> 00:40:01.150
在

00:39:58.150 --> 00:40:04.050
崩溃发生了，也许做了，可能

00:40:01.150 --> 00:40:09.040
如果发生了自由定义则有所不同

00:40:04.050 --> 00:40:11.740
实际上这不是一个不

00:40:09.040 --> 00:40:14.080
简单的步骤，因为元空间不会

00:40:11.740 --> 00:40:16.390
一对一地包含您的课程文件

00:40:14.080 --> 00:40:20.619
专注于包含它的磁盘

00:40:16.390 --> 00:40:23.470
包含分解后的单词数据

00:40:20.619 --> 00:40:25.330
拥有常数的所有信息

00:40:23.470 --> 00:40:27.670
池和方法中的字节码

00:40:25.330 --> 00:40:30.640
和所有在不同的地方，但

00:40:27.670 --> 00:40:33.220
可维护性代理可以收集

00:40:30.640 --> 00:40:35.440
一起创造一个非常一流的

00:40:33.220 --> 00:40:38.530
它的一部分，所以我们称Java 

00:40:35.440 --> 00:40:41.310
热点调试器命令行界面

00:40:38.530 --> 00:40:41.310
这次是

00:40:41.840 --> 00:40:50.460
这就是所有的openjdk，全部是OpenJDK 

00:40:45.600 --> 00:40:54.510
我在这里显示的内容，所以我称为命令

00:40:50.460 --> 00:40:57.060
建立重播罐子，我退出了，我看到了

00:40:54.510 --> 00:40:58.770
热汗汉堡创建到jar文件

00:40:57.060 --> 00:41:00.390
一个与应用程序类

00:40:58.770 --> 00:41:03.300
由应用程序类加载

00:41:00.390 --> 00:41:05.760
装载机，一种是称为bucho的装载机

00:41:03.300 --> 00:41:07.730
哪个包含所有

00:41:05.760 --> 00:41:16.980
引导类加载器加载的类

00:41:07.730 --> 00:41:18.660
现在我们可以再次尝试重播，但是

00:41:16.980 --> 00:41:21.570
这次不上课了

00:41:18.660 --> 00:41:23.550
在类传递的磁盘上，但是

00:41:21.570 --> 00:41:26.869
我们提取的类

00:41:23.550 --> 00:41:30.690
从核心文件中，当我们这样做时

00:41:26.869 --> 00:41:34.380
我们看到，现在我们可以真正复制

00:41:30.690 --> 00:41:36.119
再次出现错误，因为

00:41:34.380 --> 00:41:39.300
现在我们可以进入调试器了

00:41:36.119 --> 00:41:45.180
看看发生了什么，希望找到

00:41:39.300 --> 00:41:47.310
问题，所以我怎么做这个例子

00:41:45.180 --> 00:41:49.980
其实是一样的例子

00:41:47.310 --> 00:41:54.840
之前唯一的区别是现在

00:41:49.980 --> 00:41:57.240
目标的元素类型

00:41:54.840 --> 00:42:00.390
数组副本的数组不是X而是Y 

00:41:57.240 --> 00:42:02.400
你还记得我们只是在

00:42:00.390 --> 00:42:06.000
元素类型时的目的地

00:42:02.400 --> 00:42:10.160
是X，所以当我们使用该程序时

00:42:06.000 --> 00:42:15.300
静态上不会发生任何错误

00:42:10.160 --> 00:42:17.850
但是这里在运行时我们使用了类

00:42:15.300 --> 00:42:19.710
重新定义我不会详细介绍

00:42:17.850 --> 00:42:21.990
我只是用

00:42:19.710 --> 00:42:26.580
仪表代理重新定义此

00:42:21.990 --> 00:42:28.500
并将Y替换为X，所以当您

00:42:26.580 --> 00:42:30.720
只需使用它在磁盘上的此类

00:42:28.500 --> 00:42:33.330
什么都不会发生，但是当你跑步时

00:42:30.720 --> 00:42:36.180
这个课程这个班将是

00:42:33.330 --> 00:42:38.250
重新定义为另一个目的地

00:42:36.180 --> 00:42:40.590
键入不是Y而是X，然后崩溃

00:42:38.250 --> 00:42:42.900
发生，所以这就是为什么当您使用

00:42:40.590 --> 00:42:44.609
类是从核心文件中提取的

00:42:42.900 --> 00:42:47.490
他们有重新定义的版本

00:42:44.609 --> 00:42:50.609
上课，我们可以重现问题

00:42:47.490 --> 00:42:52.560
这实际上是一个很普遍的问题

00:42:50.609 --> 00:42:54.240
如今因为许多大客户

00:42:52.560 --> 00:42:58.700
您所安装的装置

00:42:54.240 --> 00:43:03.290
各种仪器工具

00:42:58.700 --> 00:43:06.270
监控他们的工具和实际代码

00:43:03.290 --> 00:43:08.760
被执行可能是相当

00:43:06.270 --> 00:43:11.790
与您的飞船不同

00:43:08.760 --> 00:43:20.369
他们，那通常很难

00:43:11.790 --> 00:43:21.869
在实验室中重现问题好吗

00:43:20.369 --> 00:43:23.390
再次，这是崩溃的地方

00:43:21.869 --> 00:43:28.440
发生了

00:43:23.390 --> 00:43:31.740
没有人，实际上是

00:43:28.440 --> 00:43:35.100
结论不像我之前告诉你的

00:43:31.740 --> 00:43:37.650
崩溃位置崩溃原因通常是

00:43:35.100 --> 00:43:42.360
完全不同，所以如果我抓到一些简

00:43:37.650 --> 00:43:44.820
一些错误的代码会改变您的Java 

00:43:42.360 --> 00:43:47.130
堆你真的很走运，因为

00:43:44.820 --> 00:43:51.030
你可以例如问你

00:43:47.130 --> 00:43:52.890
看到你也可能会崩溃

00:43:51.030 --> 00:43:56.160
您所看到或生成的解释器

00:43:52.890 --> 00:43:59.580
代码，因此当机位置是当机原因

00:43:56.160 --> 00:44:01.080
不幸的是，并非总是如此

00:43:59.580 --> 00:44:04.020
即时编译器的示例

00:44:01.080 --> 00:44:06.210
生成错误代码并不意味着您

00:44:04.020 --> 00:44:08.400
在代码生成期间崩溃，但在

00:44:06.210 --> 00:44:12.020
方法的执行，所以它是

00:44:08.400 --> 00:44:14.700
这种方法可能很难

00:44:12.020 --> 00:44:18.200
破坏堆，后来又

00:44:14.700 --> 00:44:23.130
撞到一个非常不同的位置，所以

00:44:18.200 --> 00:44:29.580
找到崩溃原因只是

00:44:23.130 --> 00:44:31.440
崩溃位置非常困难，因此

00:44:29.580 --> 00:44:33.869
这实际上我走到了尽头

00:44:31.440 --> 00:44:38.609
谈论有很多有趣的东西

00:44:33.869 --> 00:44:40.590
关于网络崩溃分析的内容

00:44:38.609 --> 00:44:43.740
 Java中有一些文章

00:44:40.590 --> 00:44:46.230
杂志和六本木去年净下沉

00:44:43.740 --> 00:44:48.359
我想谈谈建立您的

00:44:46.230 --> 00:44:50.790
自己的Java调试工具

00:44:48.359 --> 00:44:54.330
适用性代理和仪器

00:44:50.790 --> 00:44:56.340
像这样的东西我最后一件事

00:44:54.330 --> 00:45:00.080
想指出可维护性

00:44:56.340 --> 00:45:04.290
代理实际上是在2001年推出的

00:45:00.080 --> 00:45:05.850
你已经知道肯尼思的论文

00:45:04.290 --> 00:45:07.710
罗素和最后的钱，所以这是一个非常

00:45:05.850 --> 00:45:09.150
旧技术

00:45:07.710 --> 00:45:11.700
不幸的是，它仍然没有

00:45:09.150 --> 00:45:16.070
官方支持，它从

00:45:11.700 --> 00:45:19.650
有时，因为它确实必须

00:45:16.070 --> 00:45:22.020
始终将Java实现保持在

00:45:19.650 --> 00:45:23.839
热点实现和同步，但是

00:45:22.020 --> 00:45:27.000
不过，如果您想深入了解

00:45:23.839 --> 00:45:29.880
热点的实现细节

00:45:27.000 --> 00:45:33.390
这是我可以真正为您提供建议的工具

00:45:29.880 --> 00:45:35.670
使用，就在这里再次

00:45:33.390 --> 00:45:37.619
幻灯片，我认为我们已经没时间了

00:45:35.670 --> 00:45:40.260
但是如果有快速问题，我可以

00:45:37.619 --> 00:45:44.999
尝试回答非常感谢

00:45:40.260 --> 00:45:44.999
 [掌声] 

