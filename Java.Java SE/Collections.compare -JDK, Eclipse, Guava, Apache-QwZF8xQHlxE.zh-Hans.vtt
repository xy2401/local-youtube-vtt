WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.310 --> 00:00:10.650
嗨，谢谢大家参加我们的活动

00:00:05.950 --> 00:00:13.360
来选举比较谈话，这是一个

00:00:10.650 --> 00:00:16.350
互动会话（如果您不喜欢） 

00:00:13.360 --> 00:00:18.760
问问题，否则就做

00:00:16.350 --> 00:00:21.940
说话时间足够长，我们可以重复

00:00:18.760 --> 00:00:24.630
回来重新输入就可以了，我会

00:00:21.940 --> 00:00:26.890
简短地谈论我们的客人

00:00:24.630 --> 00:00:28.330
首先要了解医疗的演讲者

00:00:26.890 --> 00:00:30.820
订购请不要

00:00:28.330 --> 00:00:31.540
嘿，所以欢迎大家，我叫

00:00:30.820 --> 00:00:33.489
唐纳德·罗伯

00:00:31.540 --> 00:00:35.859
我是新银行的董事总经理

00:00:33.489 --> 00:00:38.289
约克梅隆总部设在泽西城

00:00:35.859 --> 00:00:40.030
那些不认识我的人是我

00:00:38.289 --> 00:00:41.949
一个小框架的创建者

00:00:40.030 --> 00:00:46.570
 Eclipse集合意味着

00:00:41.949 --> 00:00:48.780
谈话也将完全公正

00:00:46.570 --> 00:00:50.800
 jsr 3:35专家组成员

00:00:48.780 --> 00:00:53.859
你知道的是得到的东西

00:00:50.800 --> 00:00:56.229
 lambda和流到Java中，我已经

00:00:53.859 --> 00:00:57.909
参加过各种会议，这是我的

00:00:56.229 --> 00:01:01.030
我去过的第四个Java语言

00:00:57.909 --> 00:01:05.199
 devoxx jvm语言峰会这样做了，并且

00:01:01.030 --> 00:01:06.970
等等，是的，我叫伦纳德·利马

00:01:05.199 --> 00:01:08.560
我在维亚康姆公司工作

00:01:06.970 --> 00:01:11.380
确实引起依赖的巴西公司

00:01:08.560 --> 00:01:12.399
或茶，我目前住在

00:01:11.380 --> 00:01:17.409
德克萨斯州奥斯汀

00:01:12.399 --> 00:01:20.469
而且我很棒，而且我现在

00:01:17.409 --> 00:01:22.840
我让Viacom的首席技术官

00:01:20.469 --> 00:01:24.909
软件开发，这就是我们的方式

00:01:22.840 --> 00:01:27.280
他们开始尝试这些话题了

00:01:24.909 --> 00:01:30.130
说得好，您应该使用我们的框架

00:01:27.280 --> 00:01:32.109
我说了为什么然后你比较

00:01:30.130 --> 00:01:35.170
这就是我们开始的收藏

00:01:32.109 --> 00:01:37.689
所以我公司也是

00:01:35.170 --> 00:01:42.250
 GCP执行委员会，我做了

00:01:37.689 --> 00:01:44.829
领先GSR 363度量单位

00:01:42.250 --> 00:01:47.049
我是Nicole Nani Radhika我是副

00:01:44.829 --> 00:01:49.119
我是高盛的总裁

00:01:47.049 --> 00:01:50.829
盐湖城和学术界

00:01:49.119 --> 00:01:53.409
教育机械硕士

00:01:50.829 --> 00:01:57.159
工程实际上不是书面的

00:01:53.409 --> 00:01:59.979
甚至Java的HelloWorld截止到7月3日

00:01:57.159 --> 00:02:02.649
 2012 2012年7月2日是我在这里的第一天

00:01:59.979 --> 00:02:05.439
高盛，这就是我的旅程

00:02:02.649 --> 00:02:08.050
 2017年3月，我开始拥有Eclipse 

00:02:05.439 --> 00:02:10.090
收集他的大框架

00:02:08.050 --> 00:02:12.220
创建，所以现在几乎是我的

00:02:10.090 --> 00:02:14.880
确保我只合并的责任

00:02:12.220 --> 00:02:17.370
那些有意义的事情

00:02:14.880 --> 00:02:20.280
对于框架，这就是原因

00:02:17.370 --> 00:02:22.770
为什么我们三个都在这里，因为李

00:02:20.280 --> 00:02:24.300
狮子座来自他

00:02:22.770 --> 00:02:26.880
不想使用Eclipse集合

00:02:24.300 --> 00:02:28.920
我们希望他使用Eclipse集合

00:02:26.880 --> 00:02:30.960
然后最终发生在他所在的地方

00:02:28.920 --> 00:02:33.150
向我们展示所有可用的东西

00:02:30.960 --> 00:02:35.550
在其他框架中

00:02:33.150 --> 00:02:37.650
最终就像有一个不错的

00:02:35.550 --> 00:02:39.450
我应该说共生关系

00:02:37.650 --> 00:02:41.610
我们在看其他框架

00:02:39.450 --> 00:02:46.770
并进行实际比较，从而导致

00:02:41.610 --> 00:02:48.420
是的，是的，我的背景是

00:02:46.770 --> 00:02:51.060
你有一个开发人员

00:02:48.420 --> 00:02:53.490
比他成长12年

00:02:51.060 --> 00:02:55.890
比他少，我一直在使用Java 

00:02:53.490 --> 00:02:58.530
永远的YouTube收藏

00:02:55.890 --> 00:03:00.570
因为它们出来了，所以我总是用

00:02:58.530 --> 00:03:02.070
它和我不了解你，但我

00:03:00.570 --> 00:03:05.010
像我的项目一样少

00:03:02.070 --> 00:03:07.920
尽可能少的依赖关系

00:03:05.010 --> 00:03:10.080
担心，所以我说了什么

00:03:07.920 --> 00:03:12.090
在w2集合中可用，并且

00:03:10.080 --> 00:03:15.390
它已经存在了一段时间了

00:03:12.090 --> 00:03:18.300
 98，而且非常基础但很关键

00:03:15.390 --> 00:03:20.250
对馆藏的支持，它很友善

00:03:18.300 --> 00:03:22.620
两个主要接口Maps和

00:03:20.250 --> 00:03:25.020
集合，所以有不同的树

00:03:22.620 --> 00:03:28.410
在这个实现集合中

00:03:25.020 --> 00:03:30.950
除了地图之外什么都没有，所以在qdq列出

00:03:28.410 --> 00:03:33.120
或是全部都是收藏品

00:03:30.950 --> 00:03:37.380
在集合接口中实现

00:03:33.120 --> 00:03:39.630
地图只是地图Cheryl JDK 

00:03:37.380 --> 00:03:41.460
提供了一堆基本的

00:03:39.630 --> 00:03:44.460
这些接口的实现以及

00:03:41.460 --> 00:03:46.800
他们在Java 5推出时

00:03:44.460 --> 00:03:48.240
并发，他们发布了

00:03:46.800 --> 00:03:50.490
它们的并发版本也是如此

00:03:48.240 --> 00:03:53.490
您可以在并发代码上使用它们

00:03:50.490 --> 00:03:56.040
他们确实有一些算法

00:03:53.490 --> 00:03:57.740
做所有的基本东西

00:03:56.040 --> 00:04:00.450
收集就像排序洗牌一样

00:03:57.740 --> 00:04:04.590
数据操作，例如添加删除

00:04:00.450 --> 00:04:05.940
搜索以及所有这些东西和一些

00:04:04.590 --> 00:04:08.430
人们真的是新来的语言

00:04:05.940 --> 00:04:09.840
这就像不是第一个

00:04:08.430 --> 00:04:12.000
你好之后你应该做的第二件事

00:04:09.840 --> 00:04:14.850
世界将与一个集合一起工作， 

00:04:12.000 --> 00:04:17.730
他们有关于Java的很好的教程

00:04:14.850 --> 00:04:19.530
 Oracle上的网站，这里有链接

00:04:17.730 --> 00:04:22.770
因为它们在并发中很简单

00:04:19.530 --> 00:04:24.300
教程，我认为我认为

00:04:22.770 --> 00:04:26.340
很高兴展示收藏

00:04:24.300 --> 00:04:28.430
框架自启动以来就不断发展

00:04:26.340 --> 00:04:30.590
这样我们就可以看到它在哪里

00:04:28.430 --> 00:04:32.660
战争以及事物如何随着时间演变

00:04:30.590 --> 00:04:36.410
又是近二十年的

00:04:32.660 --> 00:04:39.889
演变，你可以从java中看到

00:04:36.410 --> 00:04:42.770
到Java v，所以从98到2005并不多

00:04:39.889 --> 00:04:45.680
已经更改，但随后Java 5附带了

00:04:42.770 --> 00:04:47.570
 for循环中的泛型对不起

00:04:45.680 --> 00:04:49.550
循环，那带来了

00:04:47.570 --> 00:04:50.539
带来了很多代码方面的改进

00:04:49.550 --> 00:04:52.669
可读性和

00:04:50.539 --> 00:04:54.740
对您的收藏所做的比

00:04:52.669 --> 00:04:56.870
你以为有可能

00:04:54.740 --> 00:04:59.240
不需要太多的仿制药

00:04:56.870 --> 00:05:02.930
铸造，他们增加了一些

00:04:59.240 --> 00:05:05.720
并发实用程序也是如此

00:05:02.930 --> 00:05:08.419
我看到的巨大进步以及当我

00:05:05.720 --> 00:05:11.270
当我我搬Java 5的理由是

00:05:08.419 --> 00:05:14.509
仿制药，我喜欢它，我留下了

00:05:11.270 --> 00:05:17.000
永远在那里，真的很棒

00:05:14.509 --> 00:05:19.009
然后在Java 6上，他们添加了更多

00:05:17.000 --> 00:05:22.460
一些更多的东西，然后java 7 

00:05:19.009 --> 00:05:24.500
没那么多，然后Java 8就像

00:05:22.460 --> 00:05:27.440
他们又一次大修，所以花了

00:05:24.500 --> 00:05:29.360
例如从Java到2:05的7年，或者

00:05:27.440 --> 00:05:32.510
再过九年像九年

00:05:29.360 --> 00:05:34.970
得到lambdas并引用方法

00:05:32.510 --> 00:05:37.220
和一堆其他极端接口

00:05:34.970 --> 00:05:39.620
如果你没看到的话，我想你们所有人

00:05:37.220 --> 00:05:42.199
在Java之前的最后几年

00:05:39.620 --> 00:05:46.159
有很多弦乐话题，以及如何

00:05:42.199 --> 00:05:49.909
在这个库上使用流哦

00:05:46.159 --> 00:05:52.460
很抱歉在这些界面中，并在2009年哦

00:05:49.909 --> 00:05:56.120
对不起，Java 9 2017 D启动了更多

00:05:52.460 --> 00:05:59.750
有关API的更多内容，我看到了很多

00:05:56.120 --> 00:06:00.949
在不可变集合上排队4小时

00:05:59.750 --> 00:06:04.250
一夜之间，这就是我们

00:06:00.949 --> 00:06:08.360
在本次演讲中将继续谈论

00:06:04.250 --> 00:06:12.259
他们没有像

00:06:08.360 --> 00:06:16.370
可能的，我会告诉你需求如何

00:06:12.259 --> 00:06:19.509
为什么我使用非Java的东西

00:06:16.370 --> 00:06:21.830
您去收藏，例如

00:06:19.509 --> 00:06:25.130
有时您正在比较事物， 

00:06:21.830 --> 00:06:27.020
你想让他们按他们的排序

00:06:25.130 --> 00:06:28.250
命名，以便如果有人和你

00:06:27.020 --> 00:06:31.009
想告诉你有多少人

00:06:28.250 --> 00:06:33.169
用相同的名字，然后你

00:06:31.009 --> 00:06:35.150
想要与

00:06:33.169 --> 00:06:38.300
显示他们的姓氏的相同名称，以及

00:06:35.150 --> 00:06:39.850
然后我们将做一个非常漂亮的桌子

00:06:38.300 --> 00:06:41.980
你这样做

00:06:39.850 --> 00:06:45.810
在Java中，您必须要收集

00:06:41.980 --> 00:06:50.110
具有列表或偏移量的映射字符串

00:06:45.810 --> 00:06:52.180
再次串起或移开物体，然后照做

00:06:50.110 --> 00:06:55.990
这些越来越多，你得到一个

00:06:52.180 --> 00:06:58.690
非常长的钻石经营者们

00:06:55.990 --> 00:07:01.060
周围真的不是很干净

00:06:58.690 --> 00:07:04.180
另一个收藏是你有多张地图

00:07:01.060 --> 00:07:05.890
那就是为什么当他们说

00:07:04.180 --> 00:07:09.250
嘿，您应该将我们的收藏用作

00:07:05.890 --> 00:07:11.350
你们如何处理多张地图

00:07:09.250 --> 00:07:13.240
知道Apache Commons集合

00:07:11.350 --> 00:07:15.940
这是我的另一行库

00:07:13.240 --> 00:07:17.530
通常去他们那里，所以

00:07:15.940 --> 00:07:19.810
这就是我们开始谈论的方式

00:07:17.530 --> 00:07:21.460
那还有哪些其他收藏

00:07:19.810 --> 00:07:26.400
可用那里还有什么

00:07:21.460 --> 00:07:29.410
人们可以使用Java 5 6 8 9 

00:07:26.400 --> 00:07:31.780
可以用来解决

00:07:29.410 --> 00:07:34.030
收藏需求，我想就是

00:07:31.780 --> 00:07:37.030
选择是因为我认为这些更适合

00:07:34.030 --> 00:07:40.590
有关更多列，我们将其与Java进行了比较

00:07:37.030 --> 00:07:42.820
我们没有时间的8个收藏

00:07:40.590 --> 00:07:44.980
 Java 9集合的经验

00:07:42.820 --> 00:07:48.450
做适当的更新工作

00:07:44.980 --> 00:07:51.520
向G展示超过9，但Java 8 

00:07:48.450 --> 00:07:54.580
除了Java之外，我们还有部分漫画

00:07:51.520 --> 00:07:58.450
当前在版本401上的操作是

00:07:54.580 --> 00:08:01.480
我在Java Eclipse以外最常使用的功能

00:07:58.450 --> 00:08:03.160
之前的收藏

00:08:01.480 --> 00:08:05.470
高盛的收藏就是这样

00:08:03.160 --> 00:08:09.100
这就是Nikki照顾它的原因

00:08:05.470 --> 00:08:11.710
以前唐正和他一起工作

00:08:09.100 --> 00:08:14.080
他把它带到了开源

00:08:11.710 --> 00:08:17.500
这是非常不错的举动，而Google 

00:08:14.080 --> 00:08:19.120
番石榴谷歌番石榴新报价谁更

00:08:17.500 --> 00:08:21.520
我什至不知道我是否说

00:08:19.120 --> 00:08:23.890
是的，但是在他们之前是Java lang语

00:08:21.520 --> 00:08:26.440
都有他们做的收藏框架

00:08:23.890 --> 00:08:28.510
其他东西不仅是收藏品

00:08:26.440 --> 00:08:29.920
他们确实有某些收藏品

00:08:28.510 --> 00:08:32.440
有时候我用番石榴

00:08:29.920 --> 00:08:34.060
其他的东西，我需要一张多张地图

00:08:32.440 --> 00:08:35.740
繁荣在那里已经是你没有

00:08:34.060 --> 00:08:39.580
带来仅为一个

00:08:35.740 --> 00:08:41.860
多地图，所以我们再次要这个

00:08:39.580 --> 00:08:44.229
发布，这有很好的链接

00:08:41.860 --> 00:08:45.940
他们的用户指导文档，我

00:08:44.229 --> 00:08:48.220
认为那是你必须做的一件事

00:08:45.940 --> 00:08:49.330
考虑一下您是否在寻找东西

00:08:48.220 --> 00:08:50.740
不好

00:08:49.330 --> 00:08:52.660
您应该转走的文档

00:08:50.740 --> 00:08:53.170
因为这通常意味着没有人是

00:08:52.660 --> 00:08:55.900
使用

00:08:53.170 --> 00:08:57.970
我认为这些家伙以及所有这些

00:08:55.900 --> 00:09:02.080
其他人在

00:08:57.970 --> 00:09:03.820
维护他们的文件，我

00:09:02.080 --> 00:09:05.290
想你想解释的是如何

00:09:03.820 --> 00:09:09.160
进化我认为你是最合适的人

00:09:05.290 --> 00:09:10.690
谈论这个，所以我来这里

00:09:09.160 --> 00:09:13.930
和你一起在这里完成

00:09:10.690 --> 00:09:15.550
因此，如果您看过，因为您知道Java 2 

00:09:13.930 --> 00:09:19.270
出来，我们首先得到了Java util 

00:09:15.550 --> 00:09:21.070
集合库最初位于

00:09:19.270 --> 00:09:22.600
她有Java收藏的空间，然后

00:09:21.070 --> 00:09:24.610
有Apache Commons，但是如果你

00:09:22.600 --> 00:09:26.740
快进最后一个你

00:09:24.610 --> 00:09:29.800
知道将近20年的时间

00:09:26.740 --> 00:09:31.870
还有更多的事情正在进行

00:09:29.800 --> 00:09:33.730
在收藏空间中，确实

00:09:31.870 --> 00:09:35.590
自Java 8推出以来

00:09:33.730 --> 00:09:37.360
现在除了lambdas 

00:09:35.590 --> 00:09:40.540
做很多有趣的事情的能力

00:09:37.360 --> 00:09:42.610
事情对了，你看到我认为

00:09:40.540 --> 00:09:44.380
集合中的复兴

00:09:42.610 --> 00:09:47.740
就功能而言，空间

00:09:44.380 --> 00:09:49.480
可用，所以您一路知道

00:09:47.740 --> 00:09:51.400
知道自从Java 9发布以来，如果

00:09:49.480 --> 00:09:53.320
你在2017年看起来今年

00:09:51.400 --> 00:09:55.720
你知道两个新的，实际上三个新的

00:09:53.320 --> 00:09:58.450
番石榴的版本，你有三个新

00:09:55.720 --> 00:10:01.510
您拥有的Eclipse集合的版本

00:09:58.450 --> 00:10:03.430
现在有了Java lang语已成为

00:10:01.510 --> 00:10:04.570
瓦瓦（Vava），你有弗弗（Perver）点

00:10:03.430 --> 00:10:06.760
知道第九点，实际上他们是

00:10:04.570 --> 00:10:09.490
我认为当前潮流

00:10:06.760 --> 00:10:11.080
您知道的Apache Commons快照4.2 

00:10:09.490 --> 00:10:13.060
实际上有工作正在进行

00:10:11.080 --> 00:10:15.520
在那里，您已经看到这种增长

00:10:13.060 --> 00:10:16.870
空间和两个你知道里奥的观点

00:10:15.520 --> 00:10:19.450
那里发生了很多事， 

00:10:16.870 --> 00:10:22.030
有很多东西不是

00:10:19.450 --> 00:10:24.100
今天在JDK集合中可用

00:10:22.030 --> 00:10:28.270
和其他你知道事情正在提供

00:10:24.100 --> 00:10:30.760
这些类型的功能，所以我们

00:10:28.270 --> 00:10:32.950
今天要去做的实际上就是

00:10:30.760 --> 00:10:35.290
五个不同的框架，所以Apache 

00:10:32.950 --> 00:10:37.330
番石榴番石榴Eclipse系列沃尔沃

00:10:35.290 --> 00:10:41.500
和Java 8个流，实际上是

00:10:37.330 --> 00:10:43.630
比较和我们所处的领域

00:10:41.500 --> 00:10:47.350
在这次比较中将使用

00:10:43.630 --> 00:10:48.820
很简单，这是一副纸牌，所以我们

00:10:47.350 --> 00:10:51.850
有一张卡片，每个人都知道卡片组

00:10:48.820 --> 00:10:56.590
喜欢玩纸牌，如果我去钓鱼或你

00:10:51.850 --> 00:10:57.910
知道单人纸牌游戏或其他任何游戏

00:10:56.590 --> 00:10:59.260
您在域中拥有什么

00:10:57.910 --> 00:11:01.390
这是领域的共同组成部分

00:10:59.260 --> 00:11:02.980
在底部，您有一张卡片

00:11:01.390 --> 00:11:04.810
穿西装有等级，所以等级就像你

00:11:02.980 --> 00:11:07.150
通过国王了解王牌， 

00:11:04.810 --> 00:11:11.890
西服是你知道的黑桃俱乐部

00:11:07.150 --> 00:11:13.330
艺术和纸牌构造很漂亮

00:11:11.890 --> 00:11:16.660
很简单，实际上只是笛卡尔

00:11:13.330 --> 00:11:18.310
这两个东西的乘积

00:11:16.660 --> 00:11:20.170
我想说的一件事很有趣

00:11:18.310 --> 00:11:22.510
通常是你看到我从

00:11:20.170 --> 00:11:24.910
这个阶段非常适合

00:11:22.510 --> 00:11:27.279
我正在改组的域

00:11:24.910 --> 00:11:27.670
发言人，我们没事，我是

00:11:27.279 --> 00:11:32.529
抱歉

00:11:27.670 --> 00:11:34.089
恩，所以我反正离题

00:11:32.529 --> 00:11:35.500
所以我们要解决的问题陈述

00:11:34.089 --> 00:11:36.730
说说今天，我们有一堆

00:11:35.500 --> 00:11:39.610
我们将要进行的不同操作

00:11:36.730 --> 00:11:41.170
实际使用，如果您查看

00:11:39.610 --> 00:11:42.700
一副扑克牌本身就是

00:11:41.170 --> 00:11:44.410
将在框架之间进行更改

00:11:42.700 --> 00:11:46.600
我们将把卡片存储为

00:11:44.410 --> 00:11:48.250
不可变列表，然后我们实际上

00:11:46.600 --> 00:11:49.450
将卡片分组

00:11:48.250 --> 00:11:51.880
不可变列表多图

00:11:49.450 --> 00:11:53.260
现在，如果框架具有我们要的类型

00:11:51.880 --> 00:11:55.000
如果不使用它们，我们将

00:11:53.260 --> 00:11:57.250
用以下类型模拟它们

00:11:55.000 --> 00:11:58.330
在框架中可用，因此第一个

00:11:57.250 --> 00:12:00.420
我们实际上要做的是创建

00:11:58.330 --> 00:12:02.740
牌组，我之前说过

00:12:00.420 --> 00:12:05.529
创建一副扑克牌很容易

00:12:02.740 --> 00:12:07.180
一个等级枚举和一个诉讼枚举

00:12:05.529 --> 00:12:09.700
只需要做的笛卡尔积

00:12:07.180 --> 00:12:10.390
这些东西，所以我们将向您展示

00:12:09.700 --> 00:12:12.160
看起来像什么

00:12:10.390 --> 00:12:13.959
一旦完成，我们将存储它

00:12:12.160 --> 00:12:15.820
进入一个不变的列表，那么我们将

00:12:13.959 --> 00:12:18.130
将卡片分组为不可变的列表

00:12:15.820 --> 00:12:19.750
多张地图，然后我们将做不同的事情

00:12:18.130 --> 00:12:22.930
我们要获取的操作数

00:12:19.750 --> 00:12:24.610
卡按等级和西装划分，我们是

00:12:22.930 --> 00:12:26.160
会把它们作为多件套归还

00:12:24.610 --> 00:12:28.450
或袋子，取决于可用的类型

00:12:26.160 --> 00:12:30.550
在我们使用的框架中

00:12:28.450 --> 00:12:31.810
那我们现在要把卡片发给

00:12:30.550 --> 00:12:33.910
发牌，我们必须洗牌

00:12:31.810 --> 00:12:36.430
首先，然后我们要处理

00:12:33.910 --> 00:12:38.410
卡从甲板上出来，我们要

00:12:36.430 --> 00:12:46.480
将卡片作为的不可变列表返回

00:12:38.410 --> 00:12:48.400
资产五张，每张都可以，这样

00:12:46.480 --> 00:12:50.260
滑动您所看到的是什么

00:12:48.400 --> 00:12:51.580
每副扑克牌的定义

00:12:50.260 --> 00:12:53.410
再次如此，我告诉过你像你一样

00:12:51.580 --> 00:12:54.970
具有卡片等级西装的共同领域

00:12:53.410 --> 00:12:58.529
不会改变唯一的事情

00:12:54.970 --> 00:13:00.880
变化是纸牌，所以我们有

00:12:58.529 --> 00:13:03.550
从JDK开始，您会看到

00:13:00.880 --> 00:13:05.920
 JDK卡组的定义我们

00:13:03.550 --> 00:13:08.290
定义一个列表，然后我们有卡和

00:13:05.920 --> 00:13:09.700
然后我们有一张西装图，以列出

00:13:08.290 --> 00:13:13.720
卡正确，这就是我们要做的

00:13:09.700 --> 00:13:15.339
我们对Apache Commons的分组

00:13:13.720 --> 00:13:17.079
得到一张卡片清单，然后是零用钱

00:13:15.339 --> 00:13:18.400
公地实际上有多张地图，所以

00:13:17.079 --> 00:13:20.680
我们将使用多值地图

00:13:18.400 --> 00:13:22.930
从西装到卡片

00:13:20.680 --> 00:13:24.369
与剪辑集合，有一个

00:13:22.930 --> 00:13:25.779
不可变的列表，并且有一个不可变的

00:13:24.369 --> 00:13:26.639
列出多张地图，以便我们使用

00:13:25.779 --> 00:13:28.720
这些类型

00:13:26.639 --> 00:13:29.889
同样在番石榴，他们有一个

00:13:28.720 --> 00:13:31.059
不可变的列表，他们有一个不可变的

00:13:29.889 --> 00:13:34.749
列出我们将要使用的多张地图

00:13:31.059 --> 00:13:36.730
这些类型与沃尔沃，我们将

00:13:34.749 --> 00:13:39.249
列出和地图没有多地图类型

00:13:36.730 --> 00:13:41.709
有趣的是

00:13:39.249 --> 00:13:44.139
您看到的JDK 8和Apache Commons 

00:13:41.709 --> 00:13:45.579
与列表界面，我们没有

00:13:44.139 --> 00:13:47.649
这两个中的不可变列表

00:13:45.579 --> 00:13:49.360
框架，所以我们必须实际上

00:13:47.649 --> 00:13:50.980
将通过不可修改的方式进行模拟

00:13:49.360 --> 00:13:52.480
正确的收藏，所以我们要

00:13:50.980 --> 00:13:54.579
实际快速地创造出一些东西

00:13:52.480 --> 00:13:56.619
我是可修改的，进化是这种类型

00:13:54.579 --> 00:13:58.389
您在这里看到的列表并映射这些是

00:13:56.619 --> 00:14:00.069
不是JDK类型，因此它们具有相同的

00:13:58.389 --> 00:14:03.850
名称，但实际上是Vava类型

00:14:00.069 --> 00:14:04.809
它们在默认情况下是不可变的，因此

00:14:03.850 --> 00:14:09.309
名称没有一成不变，但它们是

00:14:04.809 --> 00:14:10.929
实际上这两个不可变类型，所以首先

00:14:09.309 --> 00:14:14.559
我们要做笛卡尔式的事情

00:14:10.929 --> 00:14:15.459
产品，因为我正在研究这个

00:14:14.559 --> 00:14:16.779
代码，这很有趣，因为我们已经

00:14:15.459 --> 00:14:19.629
我现在实际上给出了这个演讲

00:14:16.779 --> 00:14:21.220
这是第三次会议第一次

00:14:19.629 --> 00:14:23.079
我们给它两次，我们使用了

00:14:21.220 --> 00:14:24.759
完全不同的数据集

00:14:23.079 --> 00:14:27.790
结构我们使用了可变的排序集

00:14:24.759 --> 00:14:29.319
不可变的排序集多图，所以我们

00:14:27.790 --> 00:14:30.999
想尝试一下，看看是否

00:14:29.319 --> 00:14:32.199
我们尝试将其更改为可变列表

00:14:30.999 --> 00:14:34.660
它看起来像

00:14:32.199 --> 00:14:35.889
现在，当我通过解决方案

00:14:34.660 --> 00:14:38.079
在这东西上，当我

00:14:35.889 --> 00:14:39.639
做笛卡尔积的第一件事

00:14:38.079 --> 00:14:41.230
我意识到它的笛卡尔积

00:14:39.639 --> 00:14:43.149
所以我可以知道我应该实际使用

00:14:41.230 --> 00:14:44.889
那然后我意识到那里是

00:14:43.149 --> 00:14:46.839
我可以实际输入的通用代码

00:14:44.889 --> 00:14:48.790
在一个地方分享一堆

00:14:46.839 --> 00:14:50.769
解决方案，所以我所做的就是

00:14:48.790 --> 00:14:52.929
卡类本身就有一个流卡

00:14:50.769 --> 00:14:55.480
然后我调用另一个方法的方法

00:14:52.929 --> 00:14:58.509
在称为笛卡尔积的卡上

00:14:55.480 --> 00:15:00.370
采取一个枚举等级，所以两个

00:14:58.509 --> 00:15:02.709
这些是枚举，所以我取任意数量的

00:15:00.370 --> 00:15:04.809
这套西装的等级枚举

00:15:02.709 --> 00:15:06.850
然后我实际上实现了笛卡尔

00:15:04.809 --> 00:15:08.350
这里的乘积，这就是笛卡尔

00:15:06.850 --> 00:15:10.829
产品实施看起来像您

00:15:08.350 --> 00:15:13.749
基本上用右图做平面图

00:15:10.829 --> 00:15:15.100
当我打电话给流卡时， 

00:15:13.749 --> 00:15:16.420
我要拿出一堆纸牌

00:15:15.100 --> 00:15:20.319
然后我实际上必须把那个

00:15:16.420 --> 00:15:21.819
用Eclipse变成不可变的列表

00:15:20.319 --> 00:15:23.139
我们实际上有一个笛卡尔坐标系

00:15:21.819 --> 00:15:25.179
产品方法，实际上这是一个

00:15:23.139 --> 00:15:27.730
我们的更新版本

00:15:25.179 --> 00:15:29.499
用于返回一个旧的笛卡尔积

00:15:27.730 --> 00:15:30.970
配对对象正确，我想

00:15:29.499 --> 00:15:32.980
实际上使它足够灵活，所以我

00:15:30.970 --> 00:15:34.390
实际上可以返回我想要的类型

00:15:32.980 --> 00:15:36.310
所以实际上现在有一个笛卡尔

00:15:34.390 --> 00:15:37.750
具有功能的产品，所以我们只是

00:15:36.310 --> 00:15:39.430
与Eclipse集合一起使用，所以我

00:15:37.750 --> 00:15:40.720
可以说，就像您知道卡片新

00:15:39.430 --> 00:15:42.190
方法引用或构造函数

00:15:40.720 --> 00:15:44.530
引用将被映射到

00:15:42.190 --> 00:16:01.510
功能，然后我可以打电话

00:15:44.530 --> 00:16:03.220
我们订购了笛卡尔积

00:16:01.510 --> 00:16:05.800
所以必须经过迈克先生

00:16:03.220 --> 00:16:07.330
对不起，先生，我想是这样，如果她

00:16:05.800 --> 00:16:09.520
说像现在我们有它，那是

00:16:07.330 --> 00:16:11.440
因为我们就像我们在说话

00:16:09.520 --> 00:16:13.060
我们正在开发API，那就是

00:16:11.440 --> 00:16:15.250
我喜欢开源项目

00:16:13.060 --> 00:16:18.610
每个人都可以开始使用

00:16:15.250 --> 00:16:21.220
这是你的一个很好的方式

00:16:18.610 --> 00:16:24.280
帮助开源开发人员

00:16:21.220 --> 00:16:26.980
给他们用例，所以如果我从不

00:16:24.280 --> 00:16:28.960
贡献了一行代码来蚀

00:16:26.980 --> 00:16:31.210
收藏但我帮他们给他

00:16:28.960 --> 00:16:33.220
例如用例，我们该如何做以及

00:16:31.210 --> 00:16:35.080
让我们将注释更改为

00:16:33.220 --> 00:16:36.370
更好地展示如何做到这一点，所以我认为

00:16:35.080 --> 00:16:38.650
那是一件非常好的事情

00:16:36.370 --> 00:16:40.060
人们通常不会说，你会

00:16:38.650 --> 00:16:43.390
与您一起学习和与他人合作

00:16:40.060 --> 00:16:45.070
永远不会一起工作，就像

00:16:43.390 --> 00:16:47.970
他们在银行工作，而我在

00:16:45.070 --> 00:16:50.200
物联网因此无关，但我们

00:16:47.970 --> 00:16:52.450
在彼此合作和学习

00:16:50.200 --> 00:16:54.070
这个项目，所以我认为这真的很好

00:16:52.450 --> 00:16:55.840
如果你们不参与

00:16:54.070 --> 00:16:57.430
任何开源项目，甚至只是

00:16:55.840 --> 00:17:03.089
阅读评论并屈服

00:16:57.430 --> 00:17:10.329
尝试用例，你应该可以

00:17:03.089 --> 00:17:12.339
所以我们经历的时候会很好

00:17:10.329 --> 00:17:14.829
收藏集的幻灯片比较我们

00:17:12.339 --> 00:17:16.690
不仅会比较

00:17:14.829 --> 00:17:18.850
代码看起来像，但是我们想要一些

00:17:16.690 --> 00:17:20.920
指标，我们将

00:17:18.850 --> 00:17:22.839
看两个基本的基本指标之一

00:17:20.920 --> 00:17:25.570
 jmh指标和其他指标是

00:17:22.839 --> 00:17:28.060
内存测试，所以看

00:17:25.570 --> 00:17:30.910
 Java微型计算机的性能基准

00:17:28.060 --> 00:17:33.910
利用它是公开可用的

00:17:30.910 --> 00:17:35.980
 JDK和jmh的作用是它有一个

00:17:33.910 --> 00:17:38.410
您可以在其中运行一些选项

00:17:35.980 --> 00:17:40.540
基准测试，您可以将其运行为

00:17:38.410 --> 00:17:44.290
每秒操作数或您可以运行它

00:17:40.540 --> 00:17:46.390
作为第二次电源操作，所以我的意思是

00:17:44.290 --> 00:17:47.860
您想作为每个操作运行

00:17:46.390 --> 00:17:50.410
第二你可以

00:17:47.860 --> 00:17:52.120
您可以放心，嘿

00:17:50.410 --> 00:17:54.970
越高越好，基本上如果

00:17:52.120 --> 00:17:57.520
数字越高，意味着

00:17:54.970 --> 00:17:59.440
特定的收藏更好，它是

00:17:57.520 --> 00:18:01.450
对于任何基准测试都非常重要

00:17:59.440 --> 00:18:03.549
特别是性能基准

00:18:01.450 --> 00:18:05.380
知道它在哪台机器上运行，所以我们

00:18:03.549 --> 00:18:07.240
试图保持它完全相同

00:18:05.380 --> 00:18:10.900
机器是我的笔记本电脑， 

00:18:07.240 --> 00:18:13.059
四核Intel i7，我们用50跑了

00:18:10.900 --> 00:18:15.400
预热迭代和30次测量

00:18:13.059 --> 00:18:18.910
对三个人的迭代，所以

00:18:15.400 --> 00:18:22.299
这些基本上是90次迭代

00:18:18.910 --> 00:18:23.710
数字是根据的，所以下一个

00:18:22.299 --> 00:18:27.820
您要查看的指标是

00:18:23.710 --> 00:18:30.610
内存测试是JDK 8的一部分，我们

00:18:27.820 --> 00:18:32.799
在国家内部有一个阶级

00:18:30.610 --> 00:18:34.900
作为对象大小称为计算器

00:18:32.799 --> 00:18:38.049
对象大小计算器为您提供

00:18:34.900 --> 00:18:40.900
完整对象的大小，如果

00:18:38.049 --> 00:18:43.690
有一个列表或地图，那么它也会

00:18:40.900 --> 00:18:46.059
有对象的记忆或

00:18:43.690 --> 00:18:47.799
该列表中包含的元素

00:18:46.059 --> 00:18:49.809
我们正在做的事情的一部分

00:18:47.799 --> 00:18:52.360
内存测试是我们采用这种大小

00:18:49.809 --> 00:18:54.460
然后减去那些的大小

00:18:52.360 --> 00:18:56.350
特定元素，以便所有

00:18:54.460 --> 00:18:59.140
您将看到的尺寸为

00:18:56.350 --> 00:19:03.309
我现在的数据结构是

00:18:59.140 --> 00:19:04.809
其实包括卡好吧，所以

00:19:03.309 --> 00:19:08.740
他们正在使用相同的对象，所以

00:19:04.809 --> 00:19:10.480
苹果与苹果的比较因此

00:19:08.740 --> 00:19:12.340
内存测试它的数字较小

00:19:10.480 --> 00:19:15.460
更好，因为您想少用

00:19:12.340 --> 00:19:17.650
内存，我们测试数据的大小

00:19:15.460 --> 00:19:20.860
每个代码示例中创建的结构

00:19:17.650 --> 00:19:23.320
因此，请查看实际指标

00:19:20.860 --> 00:19:26.830
第一个是不可变列表，所以这是

00:19:23.320 --> 00:19:28.780
为组创建甲板

00:19:26.830 --> 00:19:31.720
卡笛卡尔积运算

00:19:28.780 --> 00:19:33.280
这样您就可以按字母顺序查看

00:19:31.720 --> 00:19:36.370
从左到右，您有Apache 

00:19:33.280 --> 00:19:38.890
我们和所有框架都很漂亮

00:19:36.370 --> 00:19:42.460
可比性强但Eclipse集合

00:19:38.890 --> 00:19:46.450
大约每秒235,000次操作

00:19:42.460 --> 00:19:49.150
所以它有点磨边，但是

00:19:46.450 --> 00:19:51.880
这不是一个非常重大的变化

00:19:49.150 --> 00:19:54.190
部分原因是

00:19:51.880 --> 00:19:55.690
每当我们创建一个不可变的列表时

00:19:54.190 --> 00:19:59.230
在Eclipse集合中，您必须首先

00:19:55.690 --> 00:20:00.990
从易变的一面走到

00:19:59.230 --> 00:20:02.490
不变的一面，让我

00:20:00.990 --> 00:20:05.280
用这些表演说些什么

00:20:02.490 --> 00:20:07.860
当你看到我们也在展示

00:20:05.280 --> 00:20:10.170
显示187,000的内容

00:20:07.860 --> 00:20:12.240
每秒的操作数

00:20:10.170 --> 00:20:14.250
显然不会有共同点

00:20:12.240 --> 00:20:15.960
您正在查看的用例知道基础

00:20:14.250 --> 00:20:17.640
我会说您的基本决定

00:20:15.960 --> 00:20:19.410
正确的应用程序很多

00:20:17.640 --> 00:20:21.900
每秒的操作数就足够了

00:20:19.410 --> 00:20:23.190
在内存中，这永远不可能是

00:20:21.900 --> 00:20:25.020
瓶颈对吧，所以

00:20:23.190 --> 00:20:26.309
差异，它们看起来很有趣

00:20:25.020 --> 00:20:28.020
在，但我不会说你知道吗

00:20:26.309 --> 00:20:30.390
我必须使用它，因为我的代码将

00:20:28.020 --> 00:20:33.960
以某种方式走得更快，这可能没有任何

00:20:30.390 --> 00:20:35.670
完全影响您，所以这是

00:20:33.960 --> 00:20:38.220
肯定会有一个

00:20:35.670 --> 00:20:40.830
对你的影响，这是内存使用它

00:20:38.220 --> 00:20:42.660
所以你可以从左到右看到

00:20:40.830 --> 00:20:45.330
再次是Apache两个小时，我会继续

00:20:42.660 --> 00:20:46.740
提醒在记忆方面

00:20:45.330 --> 00:20:48.960
内存测试较小的数字

00:20:46.740 --> 00:20:51.150
在jmh上测试更好，数字越高

00:20:48.960 --> 00:20:53.280
更好，所以就像逆向

00:20:51.150 --> 00:20:54.690
内存端，所以数字越小

00:20:53.280 --> 00:20:56.429
更好的是，您可以看到Eclipse 

00:20:54.690 --> 00:20:59.280
收藏品和番石榴几乎都在

00:20:56.429 --> 00:21:02.130
大约等于两百

00:20:59.280 --> 00:21:04.559
和76.22万

00:21:02.130 --> 00:21:07.850
七百七十六个字节

00:21:04.559 --> 00:21:10.470
整个整个扑克牌，但是

00:21:07.850 --> 00:21:12.390
重点是我们不是

00:21:10.470 --> 00:21:13.770
从零开始，因为我们需要

00:21:12.390 --> 00:21:16.410
可比性，所以它开始于

00:21:13.770 --> 00:21:19.620
二千七百所以不是我的意思

00:21:16.410 --> 00:21:21.480
他们就像有优势，但是

00:21:19.620 --> 00:21:25.460
再次没有太大的优势， 

00:21:21.480 --> 00:21:27.570
我们将在随后的幻灯片中看到原因

00:21:25.460 --> 00:21:30.210
是的，我现在要做的实际上是

00:21:27.570 --> 00:21:32.970
向您展示您必须编写的代码

00:21:30.210 --> 00:21:34.650
做这两个操作

00:21:32.970 --> 00:21:36.270
笛卡尔积变成一个不变的列表

00:21:34.650 --> 00:21:38.610
然后实际进行分组

00:21:36.270 --> 00:21:41.850
首先我们要看一下JDK 

00:21:38.610 --> 00:21:43.770
并放大我们实际的代码

00:21:41.850 --> 00:21:44.940
必须使用仅创建不可变的

00:21:43.770 --> 00:21:48.270
清单，所以我们要做的是

00:21:44.940 --> 00:21:50.010
通过调用来初始化cards变量

00:21:48.270 --> 00:21:51.630
卡流卡，使我们

00:21:50.010 --> 00:21:53.340
您知道的卡片流

00:21:51.630 --> 00:21:55.980
笛卡尔积，我们将

00:21:53.340 --> 00:21:57.780
对其进行排序，以便每张卡实际上都有一个

00:21:55.980 --> 00:22:00.510
定义比较器是工具

00:21:57.780 --> 00:22:01.860
可比性，因此将其排序

00:22:00.510 --> 00:22:04.050
正确的顺序，然后我们实际上可以

00:22:01.860 --> 00:22:06.570
叫收集，我们用收集器

00:22:04.050 --> 00:22:09.570
清单，然后我们实际上在包装

00:22:06.570 --> 00:22:12.300
这个带有可修改的列表

00:22:09.570 --> 00:22:14.140
有效地改变了有趣的事情

00:22:12.300 --> 00:22:16.050
是我尝试了许多不同的方法

00:22:14.140 --> 00:22:19.530
您可以实际尝试和使用的方式

00:22:16.050 --> 00:22:22.210
收藏家与收集，然后

00:22:19.530 --> 00:22:24.340
它可以工作，实际上看起来更多

00:22:22.210 --> 00:22:25.930
流利，但实际上成为

00:22:24.340 --> 00:22:27.640
屏幕上有点梅西耶，所以我

00:22:25.930 --> 00:22:29.380
基本上是我最简单的事情

00:22:27.640 --> 00:22:33.190
可以在这里显示实际在做什么

00:22:29.380 --> 00:22:34.840
用Apache在外面包裹

00:22:33.190 --> 00:22:37.060
公地

00:22:34.840 --> 00:22:40.050
类似地，我们将要使用的集合

00:22:37.060 --> 00:22:42.880
流卡，然后我将放大

00:22:40.050 --> 00:22:43.930
对它们进行排序，我们使用相同的收集器

00:22:42.880 --> 00:22:46.420
从盖特清单中列出

00:22:43.930 --> 00:22:47.500
斑驳的下议院有一个经典清单

00:22:46.420 --> 00:22:49.870
 utils，我们将其称为

00:22:47.500 --> 00:22:52.480
实际可修改列表上的详细信息

00:22:49.870 --> 00:22:56.320
包裹包裹清单，让您知道

00:22:52.480 --> 00:22:57.670
剪辑的伪不变性

00:22:56.320 --> 00:22:59.170
收集一组呼叫流

00:22:57.670 --> 00:23:02.020
卡现在将称为懒卡

00:22:59.170 --> 00:23:04.510
所以懒牌给我们一个懒惰的迭代

00:23:02.020 --> 00:23:06.310
然后我们可以做的就是使用

00:23:04.510 --> 00:23:07.900
两个排序列表的API，所以我们已经

00:23:06.310 --> 00:23:09.520
现在有一个可变的排序列表， 

00:23:07.900 --> 00:23:12.870
我们称两个不可变，现在我们有一个

00:23:09.520 --> 00:23:17.890
不变列表存储到卡中

00:23:12.870 --> 00:23:20.770
用番石榴，如果我们放大我们得到

00:23:17.890 --> 00:23:22.420
然后我们将流卡称为“ 

00:23:20.770 --> 00:23:24.280
流，然后有一个特殊的

00:23:22.420 --> 00:23:26.020
番石榴给你的收藏家

00:23:24.280 --> 00:23:27.700
可变列出实际存在的班级

00:23:26.020 --> 00:23:30.160
两个不可变列表，因此您可以进行排序

00:23:27.700 --> 00:23:34.480
点收集，然后您知道通过了

00:23:30.160 --> 00:23:38.440
可变列表到可变列表

00:23:34.480 --> 00:23:41.800
静脉，我们放大，我们采取相同

00:23:38.440 --> 00:23:43.660
流卡，然后我们将其排序

00:23:41.800 --> 00:23:46.210
再次，瓦瓦也有自己的

00:23:43.660 --> 00:23:48.040
在其列表类上的收集器可以

00:23:46.210 --> 00:23:52.000
电话清单收集器，实际上

00:23:48.040 --> 00:23:53.920
给你不可变的清单好吧

00:23:52.000 --> 00:23:56.460
那就是我们创造不变的方式

00:23:53.920 --> 00:23:58.240
列出权利非常简单

00:23:56.460 --> 00:24:00.730
好，接下来我们要做的是

00:23:58.240 --> 00:24:03.910
将衣服按西装分组成一成不变

00:24:00.730 --> 00:24:06.100
列出多张地图，所以首先我想

00:24:03.910 --> 00:24:09.100
解释到底什么是多重地图

00:24:06.100 --> 00:24:10.360
就像利奥在聚会前提到的那样

00:24:09.100 --> 00:24:13.000
这是多张地图，一切如此

00:24:10.360 --> 00:24:15.700
基本上，多图是多值的

00:24:13.000 --> 00:24:17.290
地图，所以它会有一把钥匙， 

00:24:15.700 --> 00:24:19.810
将有一个价值观的集合

00:24:17.290 --> 00:24:22.420
法线贴图将有一把钥匙和一把

00:24:19.810 --> 00:24:24.700
值一个值，但多图是

00:24:22.420 --> 00:24:27.100
它有多个值或在那里

00:24:24.700 --> 00:24:27.820
名称，所以如果您查看分组依据

00:24:27.100 --> 00:24:31.030
运作

00:24:27.820 --> 00:24:33.130
你可以看到得到一个特定的

00:24:31.030 --> 00:24:34.990
您实质上是按照多地图分组

00:24:33.130 --> 00:24:37.660
这就是为什么我们要提到这个的关键

00:24:34.990 --> 00:24:40.390
成为一个小组，你可以看到

00:24:37.660 --> 00:24:44.500
性能测试越高越好

00:24:40.390 --> 00:24:47.290
所以你可以看到哇哇，对不起

00:24:44.500 --> 00:24:50.170
 JDK无疑是赢家，部分原因是

00:24:47.290 --> 00:24:54.370
原因是JDK没有

00:24:50.170 --> 00:24:57.970
一个不变的多图，所以我们将

00:24:54.370 --> 00:25:00.640
在中详细了解更多

00:24:57.970 --> 00:25:03.940
编解码器，而与Eclipse相反

00:25:00.640 --> 00:25:09.910
收集和番石榴都有

00:25:03.940 --> 00:25:15.880
多地图我也这样认为

00:25:09.910 --> 00:25:19.090
 Apache，如果您再次看到

00:25:15.880 --> 00:25:21.580
性能指标就像是JDK的打击

00:25:19.090 --> 00:25:23.440
通过图表，我的意思是他们很漂亮

00:25:21.580 --> 00:25:24.940
很多只是通过它，那就是

00:25:23.440 --> 00:25:27.400
部分原因是由于

00:25:24.940 --> 00:25:31.990
它的不变性，但是如果你

00:25:27.400 --> 00:25:34.120
然后与实际使用的空间进行比较

00:25:31.990 --> 00:25:35.920
同样，所有框架都差不多

00:25:34.120 --> 00:25:38.710
兼容，所以我想说出来

00:25:35.920 --> 00:25:42.220
如果您正在寻找

00:25:38.710 --> 00:25:45.430
一成不变的

00:25:42.220 --> 00:25:47.380
多图，那么你必须要认识

00:25:45.430 --> 00:25:49.750
除了性能

00:25:47.380 --> 00:25:51.820
以及内存到内存端

00:25:49.750 --> 00:25:56.680
内存方面几乎是可比的

00:25:51.820 --> 00:25:58.330
在那里可以，所以现在我们要

00:25:56.680 --> 00:25:59.740
专注于按代码分组的外观

00:25:58.330 --> 00:26:01.360
就像是正确的，所以我们再次尝试

00:25:59.740 --> 00:26:02.890
创建一个不可变的列表多图并

00:26:01.360 --> 00:26:04.300
因为我们没有可用的类型

00:26:02.890 --> 00:26:05.770
在JDK中

00:26:04.300 --> 00:26:08.110
我们必须确保在创建时

00:26:05.770 --> 00:26:09.700
带有列表的地图

00:26:08.110 --> 00:26:13.120
都是不可修改的，列表是

00:26:09.700 --> 00:26:15.640
不可修改的权利，所以我们采取

00:26:13.120 --> 00:26:17.200
然后我们可以看到的卡片

00:26:15.640 --> 00:26:19.360
用收集者收集，然后

00:26:17.200 --> 00:26:22.060
在这里，我们进行分组

00:26:19.360 --> 00:26:23.470
西装，然后我们根据您知道的地图

00:26:22.060 --> 00:26:26.290
身份和要做收藏家

00:26:23.470 --> 00:26:27.670
收集然后创建列表，并

00:26:26.290 --> 00:26:29.230
实际上要确保每个人

00:26:27.670 --> 00:26:31.510
里面的清单被包裹在一个无

00:26:29.230 --> 00:26:32.890
可修改的列表，然后是最终的

00:26:31.510 --> 00:26:34.060
收集，然后这就是我告诉的地方

00:26:32.890 --> 00:26:36.220
你在我使用之前记得我曾经

00:26:34.060 --> 00:26:37.690
收藏家不可修改的艺术

00:26:36.220 --> 00:26:39.280
我不是纤维清单的收藏

00:26:37.690 --> 00:26:40.990
本来可以修改的

00:26:39.280 --> 00:26:41.380
地图，但我想给你看

00:26:40.990 --> 00:26:42.700
是什么

00:26:41.380 --> 00:26:44.170
收集然后看起来像是正确的

00:26:42.700 --> 00:26:45.910
我有两个选择

00:26:44.170 --> 00:26:47.980
把整个事情都包裹在一个电话里

00:26:45.910 --> 00:26:49.600
到收藏完成找到文件映射或我

00:26:47.980 --> 00:26:51.060
可以在其中使用收集

00:26:49.600 --> 00:26:53.140
也一样

00:26:51.060 --> 00:26:54.280
我本可以放大这里的，但是

00:26:53.140 --> 00:26:55.690
有趣，因为在此页面上没有

00:26:54.280 --> 00:26:58.000
实际上让您知道更多

00:26:55.690 --> 00:27:00.310
幻灯片并没有真正帮助

00:26:58.000 --> 00:27:03.730
 Apache收集我们实际得到的东西

00:27:00.310 --> 00:27:12.520
我们要做的是创建一个是的，我们要去

00:27:03.730 --> 00:27:13.840
回来好吧，我们首先得到了卡片流

00:27:12.520 --> 00:27:15.430
我们要做的就是说收集

00:27:13.840 --> 00:27:16.540
他们，这意味着我们要收集

00:27:15.430 --> 00:27:17.980
一些事情，然后我们将要做

00:27:16.540 --> 00:27:20.410
收集到东西之后

00:27:17.980 --> 00:27:22.300
正确的事情，我们要去

00:27:20.410 --> 00:27:24.160
首先要做的是

00:27:22.300 --> 00:27:27.070
对，所以我们实际上将

00:27:24.160 --> 00:27:28.410
创建一个您知道的列表钥匙

00:27:27.070 --> 00:27:30.550
在地图上将会很适合

00:27:28.410 --> 00:27:33.310
清单将是为此的卡片

00:27:30.550 --> 00:27:35.650
西装，我们要确定的是

00:27:33.310 --> 00:27:37.450
当我们收集那些

00:27:35.650 --> 00:27:39.040
列出是和你的脸

00:27:37.450 --> 00:27:44.260
正是你应该做的脸

00:27:39.040 --> 00:27:47.350
让他喜欢对此做出回应

00:27:44.260 --> 00:27:50.140
滑动是的，所以重点是

00:27:47.350 --> 00:27:52.950
对我来说，这很长，而且是

00:27:50.140 --> 00:27:55.000
隐藏一些实现或

00:27:52.950 --> 00:27:56.170
界面的特性或

00:27:55.000 --> 00:27:58.030
实际上，相反的方法是

00:27:56.170 --> 00:28:00.280
在那里暴露东西，所以不是真的

00:27:58.030 --> 00:28:03.250
我喜欢美丽，因为即使你

00:28:00.280 --> 00:28:05.920
有一个可修改的清单，你会得到一个

00:28:03.250 --> 00:28:07.060
有ADD方法的列表，是的，您

00:28:05.920 --> 00:28:08.920
不想返回不可修改的

00:28:07.060 --> 00:28:10.330
右边有可变列表的地图

00:28:08.920 --> 00:28:14.170
因为那真的不是一成不变的

00:28:10.330 --> 00:28:16.750
是的，做起来真的很复杂

00:28:14.170 --> 00:28:18.760
这是因为你不这样做

00:28:16.750 --> 00:28:20.260
有一个数据结构，你尝试去做

00:28:18.760 --> 00:28:21.430
通过算法将事物变成

00:28:20.260 --> 00:28:22.930
更复杂的权利

00:28:21.430 --> 00:28:24.430
通过数据结构得到更好的服务

00:28:22.930 --> 00:28:26.530
还有一件关于

00:28:24.430 --> 00:28:28.090
不可修改的方面是

00:28:26.530 --> 00:28:30.550
你正在做一些不可修改的事情

00:28:28.090 --> 00:28:32.620
与不可变相比，如果

00:28:30.550 --> 00:28:35.320
你是从一个易变的一面走

00:28:32.620 --> 00:28:37.690
到不变的一面，那总是

00:28:35.320 --> 00:28:39.550
运行中的O，因为您必须

00:28:37.690 --> 00:28:42.970
确保您有一份

00:28:39.550 --> 00:28:45.040
不可变的，因为不可变的列表或

00:28:42.970 --> 00:28:47.830
一个不可变的集合是必须

00:28:45.040 --> 00:28:49.690
在整个地方保持其状态

00:28:47.830 --> 00:28:51.700
反对你无法修改的地方

00:28:49.690 --> 00:28:53.080
在上面添加一个包装，然后全部

00:28:51.700 --> 00:28:54.460
要做的就是所有变异

00:28:53.080 --> 00:28:57.250
操作将要抛出

00:28:54.460 --> 00:28:59.470
咕unt一声，所以您正在比较哦

00:28:57.250 --> 00:29:00.760
与哦n，这清楚地表明

00:28:59.470 --> 00:29:04.990
性能基准

00:29:00.760 --> 00:29:07.000
好的，所以可以快速转发到Apache 

00:29:04.990 --> 00:29:08.830
所以他们这里确实有数据结构

00:29:07.000 --> 00:29:10.270
对，这很有趣，因为

00:29:08.830 --> 00:29:12.790
列出我们在此处创建的有价值的地图

00:29:10.270 --> 00:29:15.010
使用multi map utils是可变的

00:29:12.790 --> 00:29:17.410
映射，然后我们遍历卡片

00:29:15.010 --> 00:29:19.750
只是用于输入的每个呼叫

00:29:17.410 --> 00:29:22.240
多图，因此放在多图上具有

00:29:19.750 --> 00:29:23.800
在多重中找到密钥的效果

00:29:22.240 --> 00:29:26.220
映射并基本上添加到列表中

00:29:23.800 --> 00:29:28.540
那是关键，但是有一个

00:29:26.220 --> 00:29:31.030
实用程序类和称为Apache Commons的

00:29:28.540 --> 00:29:33.190
多地图实用程序，我们实际上可以包装

00:29:31.030 --> 00:29:35.290
整个多图，不可修改

00:29:33.190 --> 00:29:36.970
你知道多值地图是

00:29:35.290 --> 00:29:38.470
比我们所拥有的要简单一些

00:29:36.970 --> 00:29:40.600
还是拿些东西之前

00:29:38.470 --> 00:29:44.530
您知道可变的模型，然后制作

00:29:40.600 --> 00:29:47.170
最后它是不可变的，所以剪辑

00:29:44.530 --> 00:29:49.570
集合，因为我们有一个API 

00:29:47.170 --> 00:29:51.850
由于我们所有的方法

00:29:49.570 --> 00:29:53.440
是协变量，我们在一个不变的列表上

00:29:51.850 --> 00:29:55.120
我们将返回一个不变的

00:29:53.440 --> 00:29:57.850
列出多张地图，所以我们只需要说

00:29:55.120 --> 00:30:00.040
卡片组逐个穿衣服，我们回来了

00:29:57.850 --> 00:30:05.230
您想要的不可变列表多地图

00:30:00.040 --> 00:30:07.420
我来解释这就像

00:30:05.230 --> 00:30:08.740
像你这样卖点

00:30:07.420 --> 00:30:11.110
有些东西不在那里，我们把它

00:30:08.740 --> 00:30:14.050
在那里然后使用它并重复使用

00:30:11.110 --> 00:30:18.100
请记住，这是更快

00:30:14.050 --> 00:30:21.010
这是我上次跑给你的更快

00:30:18.100 --> 00:30:26.160
慢一点，但对我来说却不慢

00:30:21.010 --> 00:30:28.510
写正确是的，好的，谷歌番石榴，所以

00:30:26.160 --> 00:30:31.060
番石榴里有一类叫多

00:30:28.510 --> 00:30:32.500
具有索引的地图，此地图返回

00:30:31.060 --> 00:30:34.420
一个非常具体的尺寸，这是

00:30:32.500 --> 00:30:36.310
使用静态实用程序的缺点是您可以

00:30:34.420 --> 00:30:38.020
只从这里返回一种类型

00:30:36.310 --> 00:30:39.730
 group by是协变的，因此它基于

00:30:38.020 --> 00:30:41.500
你总是在索引上进食的类型

00:30:39.730 --> 00:30:43.690
返回可变列表多图，但它

00:30:41.500 --> 00:30:45.640
在这里效果很好，所以我可以使用多张地图

00:30:43.690 --> 00:30:47.620
索引需要迭代

00:30:45.640 --> 00:30:49.630
传递卡片，然后做卡片套装

00:30:47.620 --> 00:30:51.910
它既好又简单，它是

00:30:49.630 --> 00:30:56.110
 amitabh alyssum全部与沃尔沃合作

00:30:51.910 --> 00:30:58.510
类似于eclipse collection bobbers 

00:30:56.110 --> 00:31:01.600
分组依据实际上返回一个不可变的

00:30:58.510 --> 00:31:03.040
地图不是多张地图，而是给了我们

00:31:01.600 --> 00:31:07.000
同样的效果，所以我只能说卡片

00:31:03.040 --> 00:31:07.760
依卡分组适合

00:31:07.000 --> 00:31:10.160
时间的利益

00:31:07.760 --> 00:31:12.590
会轻而易举地通过这个，因为

00:31:10.160 --> 00:31:14.870
这就像一枪一击

00:31:12.590 --> 00:31:16.970
在左边看到的是纸牌

00:31:14.870 --> 00:31:21.050
所以实际上是当你

00:31:16.970 --> 00:31:22.820
叠加做一些数学

00:31:21.050 --> 00:31:24.710
在右边的两件事，你会得到

00:31:22.820 --> 00:31:26.810
但是不，我们实际上进行了测试，所以

00:31:24.710 --> 00:31:29.720
那里没有数学

00:31:26.810 --> 00:31:31.790
实际的性能测试是什么

00:31:29.720 --> 00:31:33.770
看起来像这样，您可以看到所有

00:31:31.790 --> 00:31:36.920
他们在左边创建一个甲板

00:31:33.770 --> 00:31:39.080
卡总和是可以的

00:31:36.920 --> 00:31:40.970
但是如果你看一眼不可变的清单

00:31:39.080 --> 00:31:42.950
当我说相同的时候

00:31:40.970 --> 00:31:46.610
如果您看一眼不可变的列表，则类似

00:31:42.950 --> 00:31:49.310
和分组，但JDK轻而易举

00:31:46.610 --> 00:31:51.170
通过但它得到补偿，因为

00:31:49.310 --> 00:31:54.050
再次出现在不可变列表中

00:31:51.170 --> 00:31:56.870
看着可修改与不变

00:31:54.050 --> 00:32:01.070
所以请记住，这是一个

00:31:56.870 --> 00:32:05.420
我们会再次回忆

00:32:01.070 --> 00:32:08.150
可比性，也是原因之一

00:32:05.420 --> 00:32:10.550
我们的内存使用率最高

00:32:08.150 --> 00:32:12.320
因为它们是不可变的

00:32:10.550 --> 00:32:15.290
实施列表是因为它们

00:32:12.320 --> 00:32:17.030
封面下方的链接列表

00:32:15.290 --> 00:32:18.050
是的，现在显然这些数字不是

00:32:17.030 --> 00:32:20.570
您的应用程序很有趣

00:32:18.050 --> 00:32:22.940
角度，但如果您考虑甲板

00:32:20.570 --> 00:32:25.010
的卡片，也许会

00:32:22.940 --> 00:32:26.360
在您的域中代表您

00:32:25.010 --> 00:32:28.190
知道客户的订单，你已经

00:32:26.360 --> 00:32:29.930
数以百万计的这些事情对您有用

00:32:28.190 --> 00:32:31.580
可以看到的是，你知道什么是

00:32:29.930 --> 00:32:33.500
现在在这些幻灯片上以字节为单位

00:32:31.580 --> 00:32:34.730
可以以兆字节或

00:32:33.500 --> 00:32:38.260
你知道他们是否足够

00:32:34.730 --> 00:32:40.370
一个你知道谁知道千兆字节的权利

00:32:38.260 --> 00:32:42.320
好吧，我们要做的下一件事就是

00:32:40.370 --> 00:32:43.340
卡的数量，所以应该有一个

00:32:42.320 --> 00:32:46.880
我们会轻松一点

00:32:43.340 --> 00:32:49.100
西装和按等级计数，所以我们有

00:32:46.880 --> 00:32:51.860
基本概念称为多集或

00:32:49.100 --> 00:32:53.960
袋子，那意味着如果你有

00:32:51.860 --> 00:32:56.360
一个元素然后那么几个

00:32:53.960 --> 00:32:58.550
元素在那里

00:32:56.360 --> 00:32:59.960
 Eclipse的特定集合

00:32:58.550 --> 00:33:03.140
集合中我们有一个叫做

00:32:59.960 --> 00:33:03.560
一袋一个补丁有一个多套和

00:33:03.140 --> 00:33:05.750
袋

00:33:03.560 --> 00:33:08.330
他们基本上是一样的东西

00:33:05.750 --> 00:33:10.280
番石榴虽然有多种设置

00:33:08.330 --> 00:33:13.220
这些之间的差异是我们的

00:33:10.280 --> 00:33:15.140
包实际上是在下面实现的

00:33:13.220 --> 00:33:18.380
作为原始地图的封面，所以它是

00:33:15.140 --> 00:33:21.299
地图中的对象，如果您查看

00:33:18.380 --> 00:33:23.730
这就是为什么

00:33:21.299 --> 00:33:25.860
我们创造的方式几乎是

00:33:23.730 --> 00:33:28.950
真的很快，但是那真的

00:33:25.860 --> 00:33:30.720
重要的，或者当你

00:33:28.950 --> 00:33:33.389
现在看内存测试，这些是

00:33:30.720 --> 00:33:35.940
从零开始，所以整个

00:33:33.389 --> 00:33:38.429
我们所有的西服套装

00:33:35.940 --> 00:33:40.769
在那里你最终得到了记忆

00:33:38.429 --> 00:33:43.499
消耗仅为408字节

00:33:40.769 --> 00:33:46.289
 eclipse集合以及JDK和

00:33:43.499 --> 00:33:51.330
 wahwah的水准与Apache和guava相同

00:33:46.289 --> 00:33:53.820
那时也差不多

00:33:51.330 --> 00:33:55.950
依等级计算同样是一回事

00:33:53.820 --> 00:33:58.109
在下面是多集和

00:33:55.950 --> 00:33:59.970
后背差异，但差异

00:33:58.109 --> 00:34:01.799
在按西装数和按等级数之间

00:33:59.970 --> 00:34:04.230
您将要使用的键数

00:34:01.799 --> 00:34:06.960
因此最终会影响

00:34:04.230 --> 00:34:09.419
性能测试等等

00:34:06.960 --> 00:34:11.819
在内存测试中非常明显，但是

00:34:09.419 --> 00:34:14.730
再次因为Eclipse callenge Eclipse 

00:34:11.819 --> 00:34:18.030
收藏是袋子在下面

00:34:14.730 --> 00:34:23.429
陷阱中的对象我们最终节省了最多

00:34:18.030 --> 00:34:26.339
内存还可以，所以我想提供代码

00:34:23.429 --> 00:34:27.780
对于这些，您知道性能统计信息和

00:34:26.339 --> 00:34:30.149
您看到的是我们是否要依靠

00:34:27.780 --> 00:34:32.700
用JDK按等级排序，我们

00:34:30.149 --> 00:34:34.409
我们是拿走了我们称为的卡片

00:34:32.700 --> 00:34:36.569
流，然后我们将称为收集

00:34:34.409 --> 00:34:38.490
流中的方法并使用收集器

00:34:36.569 --> 00:34:41.549
按收藏家分组，计数和

00:34:38.490 --> 00:34:43.409
我们之前已经看过了这段代码

00:34:41.549 --> 00:34:44.730
第一次好吧，这是哦莫里斯

00:34:43.409 --> 00:34:46.319
您之前已经看过此代码

00:34:44.730 --> 00:34:50.270
可能是因为您知道此代码在

00:34:46.319 --> 00:34:52.500
没事就没事说话

00:34:50.270 --> 00:34:53.700
所以反正这就是你实际上的方式

00:34:52.500 --> 00:34:55.319
知道算什么，如果你想

00:34:53.700 --> 00:34:56.730
用一个特定的键来计算它们

00:34:55.319 --> 00:34:58.680
这是西装的卡片

00:34:56.730 --> 00:35:00.119
我们回来的西装图太久了

00:34:58.680 --> 00:35:02.670
对

00:35:00.119 --> 00:35:04.619
同样的事情，我们仍然排名

00:35:02.670 --> 00:35:07.829
调用流收集收集器

00:35:04.619 --> 00:35:09.599
通过使用不同的键分组

00:35:07.829 --> 00:35:12.869
将使用卡获得等级，然后

00:35:09.599 --> 00:35:15.359
用Apache计数的收藏家

00:35:12.869 --> 00:35:17.849
集合类型有趣的Apache 

00:35:15.359 --> 00:35:21.660
集合既有手提袋又有一个

00:35:17.849 --> 00:35:25.440
多集他们是同一回事

00:35:21.660 --> 00:35:27.630
历史上只有两个不同的名称

00:35:25.440 --> 00:35:29.130
引入袋装式多行程

00:35:27.630 --> 00:35:30.510
我认为是自第四版以来

00:35:29.130 --> 00:35:32.040
所以发现它有点惊讶

00:35:30.510 --> 00:35:33.960
在这种情况下，我使用这两个都是因为

00:35:32.040 --> 00:35:35.190
都在那嘿，你知道我喜欢一个

00:35:33.960 --> 00:35:37.319
我喜欢另一个

00:35:35.190 --> 00:35:40.260
对，所以我们在做什么

00:35:37.319 --> 00:35:42.180
我们流我们然后映射属性

00:35:40.260 --> 00:35:43.829
要么获得诉讼或获得排名，然后我们

00:35:42.180 --> 00:35:45.540
收集到目标集合中

00:35:43.829 --> 00:35:47.220
哈希包或哈希多集

00:35:45.540 --> 00:35:49.140
这将产生如下效果

00:35:47.220 --> 00:35:51.210
我们将添加到一个哈希多中心包中

00:35:49.140 --> 00:35:52.740
数据结构本身保持

00:35:51.210 --> 00:35:53.819
在内部跟踪计数，因此我们

00:35:52.740 --> 00:35:56.160
实际上不必指定

00:35:53.819 --> 00:35:59.910
像我们对收集器所做的算法

00:35:56.160 --> 00:36:02.550
按收藏家分组

00:35:59.910 --> 00:36:05.520
剪辑集合，这是一个新的API 

00:36:02.550 --> 00:36:07.260
进入LEA点之前

00:36:05.520 --> 00:36:09.510
当我写这些的时候，你知道这一点

00:36:07.260 --> 00:36:11.160
为dev ox说话我就像看到我是

00:36:09.510 --> 00:36:12.780
就像你知道，如果我们

00:36:11.160 --> 00:36:14.040
有一种叫做计数购买的方法，因为

00:36:12.780 --> 00:36:17.220
当我告诉别人你必须使用

00:36:14.040 --> 00:36:18.750
懒得回去收拾包

00:36:17.220 --> 00:36:20.400
懒惰正在收集什么书包

00:36:18.750 --> 00:36:21.780
对，如果没有太大的意义

00:36:20.400 --> 00:36:22.859
你不知道这些是什么

00:36:21.780 --> 00:36:24.599
我要跟你解释一下

00:36:22.859 --> 00:36:26.400
但我可以告诉您

00:36:24.599 --> 00:36:27.869
实际上可能传达了一些

00:36:26.400 --> 00:36:30.450
关于正在发生的事情的更多含义

00:36:27.869 --> 00:36:32.280
这里只是一点，所以我们称这个东西

00:36:30.450 --> 00:36:33.900
卡计数并指定我们想要的

00:36:32.280 --> 00:36:36.210
算数，我们拿回一袋

00:36:33.900 --> 00:36:37.349
汤，现在您可能仍然会问得很好

00:36:36.210 --> 00:36:40.079
什么是包包，你可以想象

00:36:37.349 --> 00:36:42.599
袋子下面是一张基本上的地图

00:36:40.079 --> 00:36:44.760
适合求和或在这种情况下

00:36:42.599 --> 00:36:49.319
等级图的其他案例包

00:36:44.760 --> 00:36:50.819
番石榴总和他们有一个多集

00:36:49.319 --> 00:36:53.790
不，我也有包，所以我只用

00:36:50.819 --> 00:36:57.119
多子，但在这里我做了同样的事情

00:36:53.790 --> 00:37:00.630
我在卡片上吃过一块下议院

00:36:57.119 --> 00:37:03.030
使用流，我收集和番石榴有

00:37:00.630 --> 00:37:04.800
这个收集器在一个叫做multi的类上

00:37:03.030 --> 00:37:06.960
设置为如此，有趣的是，这是一个

00:37:04.800 --> 00:37:08.460
作为创造者的事物

00:37:06.960 --> 00:37:10.109
收集框架的一种

00:37:08.460 --> 00:37:11.220
穿上别人的衣服很有趣

00:37:10.109 --> 00:37:12.390
一双鞋，进入他们的

00:37:11.220 --> 00:37:14.220
收集框架并尝试

00:37:12.390 --> 00:37:16.020
发现如何使用它，实际上

00:37:14.220 --> 00:37:18.450
帮助您多一点发展

00:37:16.020 --> 00:37:20.280
对开发人员的同情和同情

00:37:18.450 --> 00:37:22.109
必须尝试发现您的API正确

00:37:20.280 --> 00:37:23.790
就像您如何找到这些东西， 

00:37:22.109 --> 00:37:26.069
文件在哪里，哦，天哪

00:37:23.790 --> 00:37:27.450
像真主一样，这太难了

00:37:26.069 --> 00:37:29.640
我怎么能放弃

00:37:27.450 --> 00:37:31.470
所以无论如何我发现马耳他语是

00:37:29.640 --> 00:37:33.660
存在，你可以收集你知道的

00:37:31.470 --> 00:37:35.730
分成多组到指定的多组

00:37:33.660 --> 00:37:37.770
您想要有效地计算的依据

00:37:35.730 --> 00:37:39.329
您实际上可以在此处指定一个

00:37:37.770 --> 00:37:41.910
也算功能，所以我只是

00:37:39.329 --> 00:37:45.980
将元素映射到我正在计数的元素

00:37:41.910 --> 00:37:45.980
逐个然后放入哈希多集

00:37:46.380 --> 00:37:51.550
 Evolver很有趣，理发师没有

00:37:48.460 --> 00:37:54.610
有一个袋子或多件套，但没有

00:37:51.550 --> 00:37:55.750
对我来说真的有一个很好的方法

00:37:54.610 --> 00:37:59.080
在自己的地图上工作，所以我

00:37:55.750 --> 00:38:00.700
基本上只是委派使用

00:37:59.080 --> 00:38:02.920
 Java util map现在很有趣

00:38:00.700 --> 00:38:05.020
在这里看到的问题是

00:38:02.920 --> 00:38:06.640
在我有地图的课程中编码

00:38:05.020 --> 00:38:08.950
那是沃尔沃斯在Java的地图上

00:38:06.640 --> 00:38:11.170
现在我必须基本解决

00:38:08.950 --> 00:38:12.970
两件事同名的问题

00:38:11.170 --> 00:38:15.340
我必须使用名称中的包

00:38:12.970 --> 00:38:16.870
在这些方法上，但番石榴

00:38:15.340 --> 00:38:20.080
抱歉，瓦瓦（Vava）有一个方法

00:38:16.870 --> 00:38:22.420
直接收集它们的类型和内容

00:38:20.080 --> 00:38:24.760
这是流媒体的捷径

00:38:22.420 --> 00:38:25.960
收集，所以他们基本上给你一个

00:38:24.760 --> 00:38:27.340
右边的快捷方式，所以你知道我

00:38:25.960 --> 00:38:28.540
不知道这天这张敲门卡

00:38:27.340 --> 00:38:30.520
是我只能说的流收集

00:38:28.540 --> 00:38:31.900
此卡的收集通行证在收集器中

00:38:30.520 --> 00:38:33.280
我正在通过计数来分组

00:38:31.900 --> 00:38:37.660
这实际上是同一件事

00:38:33.280 --> 00:38:40.390
 JDK和Apache Commons做到了，现在

00:38:37.660 --> 00:38:42.190
我们要发一些卡吗

00:38:40.390 --> 00:38:43.590
跳过这张幻灯片，我们只有四个六

00:38:42.190 --> 00:38:52.000
分钟前还可以

00:38:43.590 --> 00:38:53.680
发卡很快，所以当我们

00:38:52.000 --> 00:38:57.160
发卡，我们要做的就是退货

00:38:53.680 --> 00:39:00.340
一组不可变的列表，每组五个

00:38:57.160 --> 00:39:03.970
你在这里看到的是我们要

00:39:00.340 --> 00:39:05.890
拿一个堆栈，在JDK的情况下

00:39:03.970 --> 00:39:08.500
使用推荐的堆栈，我们

00:39:05.890 --> 00:39:09.910
实际使用失败者

00:39:08.500 --> 00:39:11.350
要传递的甲板数量

00:39:09.910 --> 00:39:13.510
我们想要的手和每张卡片

00:39:11.350 --> 00:39:15.430
手，我们将使用创建一个

00:39:13.510 --> 00:39:18.910
不可修改的清单环绕着通话

00:39:15.430 --> 00:39:20.680
在流范围内映射到对象

00:39:18.910 --> 00:39:23.290
基本上这将给我们

00:39:20.680 --> 00:39:24.730
交出每只手，这样我们就得到了一套

00:39:23.290 --> 00:39:26.860
然后我们实际上会

00:39:24.730 --> 00:39:30.190
返回，因为列表包装不是

00:39:26.860 --> 00:39:31.900
修改列表， 

00:39:30.190 --> 00:39:34.570
所有这些代码都可以在线获得的方式

00:39:31.900 --> 00:39:36.250
你可以去看看并尝试

00:39:34.570 --> 00:39:39.160
您自己也可以在

00:39:36.250 --> 00:39:43.030
 Apache末尾的链接很漂亮

00:39:39.160 --> 00:39:47.560
除了清单utils以外，其他基本相同

00:39:43.030 --> 00:39:49.240
正确的代码集合，我们

00:39:47.560 --> 00:39:51.580
有而不是int流，我们有

00:39:49.240 --> 00:39:52.690
自己进入间隔我做一只两只手，所以

00:39:51.580 --> 00:39:58.210
这是我想要的手数

00:39:52.690 --> 00:39:59.830
一二五然后收集

00:39:58.210 --> 00:40:02.860
我想要的套手

00:39:59.830 --> 00:40:04.840
这笔交易返回一组，然后因为

00:40:02.860 --> 00:40:06.760
我们正在收集一些

00:40:04.840 --> 00:40:08.680
有效的Liana可变int列表

00:40:06.760 --> 00:40:09.670
间隔实际上结束的情况

00:40:08.680 --> 00:40:15.790
返回且不变的列表

00:40:09.670 --> 00:40:17.800
用番石榴自动类似于

00:40:15.790 --> 00:40:18.940
 JDK和Apache，除了我们使用

00:40:17.800 --> 00:40:21.040
我们要收集的其他收集者

00:40:18.940 --> 00:40:29.440
进入不可变列表的最后， 

00:40:21.040 --> 00:40:31.750
然后浮子就是我在尝试

00:40:29.440 --> 00:40:34.420
有趣的麻烦类型是

00:40:31.750 --> 00:40:36.850
默认不可变以及您在此处看到的内容

00:40:34.420 --> 00:40:38.950
他们实际上有一个不变的堆栈

00:40:36.850 --> 00:40:40.420
我认为实际上是我们幻灯片上的错误

00:40:38.950 --> 00:40:42.250
在这里我应该改变它

00:40:40.420 --> 00:40:45.190
过去在Java lang语中被称为堆栈

00:40:42.250 --> 00:40:46.900
它已更改为仅列出

00:40:45.190 --> 00:40:48.100
 -提升它的一成不变及其含义

00:40:46.900 --> 00:40:49.720
是我们实际上无法更改它吗

00:40:48.100 --> 00:40:51.550
想象你有一个不变的堆栈

00:40:49.720 --> 00:40:53.560
正确，如何将其推入并弹出

00:40:51.550 --> 00:40:55.000
每次您对其进行操作时

00:40:53.560 --> 00:40:56.710
你将不得不获得一个新的堆栈， 

00:40:55.000 --> 00:40:58.210
你突然冒出来的东西

00:40:56.710 --> 00:40:59.560
这就是你所看到的

00:40:58.210 --> 00:41:01.090
我们每次都在这里发生

00:40:59.560 --> 00:41:03.280
我们回到了两个

00:41:01.090 --> 00:41:04.840
我们想要的东西，你知道

00:41:03.280 --> 00:41:07.240
那么我们必须让您知道传承

00:41:04.840 --> 00:41:09.160
有效地复制堆栈的新副本

00:41:07.240 --> 00:41:10.690
是的，所以这很难推理

00:41:09.160 --> 00:41:12.250
首先考虑它，就像我一样

00:41:10.690 --> 00:41:14.470
我只想要一个不变的堆栈

00:41:12.250 --> 00:41:17.040
堆栈是可变的，但是你知道我用过

00:41:14.470 --> 00:41:17.040
他们有什么

00:41:20.589 --> 00:41:27.289
是的，我做到了那不是那不是我的

00:41:24.109 --> 00:41:29.059
代码，以便重复该问题

00:41:27.289 --> 00:41:31.700
问题是他们是否有方法

00:41:29.059 --> 00:41:33.049
用他们的名字强调是的

00:41:31.700 --> 00:41:35.539
确实有一个下划线

00:41:33.049 --> 00:41:38.029
强调两个我们有我们也有喜欢

00:41:35.539 --> 00:41:39.890
我们称之为一对一对

00:41:38.029 --> 00:41:44.539
但这是一个命名约定，所以他们

00:41:39.890 --> 00:41:46.249
强调了一个这样的

00:41:44.539 --> 00:41:49.339
那

00:41:46.249 --> 00:41:51.170
我们有这个比较表

00:41:49.339 --> 00:41:54.440
每个人都想知道就像什么

00:41:51.170 --> 00:41:55.759
对我来说最好的框架

00:41:54.440 --> 00:41:57.979
当然答案取决于

00:41:55.759 --> 00:41:59.960
您在找什么，什么

00:41:57.979 --> 00:42:02.450
你看到的是我们试图权衡事物

00:41:59.960 --> 00:42:03.910
跨框架基于功能

00:42:02.450 --> 00:42:06.650
认为我们很有趣

00:42:03.910 --> 00:42:08.359
然后我们尝试对我们的排名

00:42:06.650 --> 00:42:11.390
以为是每个功能

00:42:08.359 --> 00:42:14.719
前三名，所以如果您需要的是

00:42:11.390 --> 00:42:16.579
列表集和地图JDK很好用

00:42:14.719 --> 00:42:17.960
您需要什么才对

00:42:16.579 --> 00:42:20.059
它有很多功能

00:42:17.960 --> 00:42:21.950
尤其是现在，如果需要，可以使用流

00:42:20.059 --> 00:42:23.269
箱包和多张地图，很好地购买地图

00:42:21.950 --> 00:42:26.150
有可用的框架可以

00:42:23.269 --> 00:42:27.920
给你那些权利，所以你有一个

00:42:26.150 --> 00:42:30.799
你有番石榴的补丁，你知道你有

00:42:27.920 --> 00:42:31.489
 Eclipse提供了您需要的那些东西

00:42:30.799 --> 00:42:33.559
堆栈

00:42:31.489 --> 00:42:35.569
好吧，如果需要，他们可以使用甲板

00:42:33.559 --> 00:42:36.920
或者你知道你可以使用不可变的堆栈

00:42:35.569 --> 00:42:39.229
从bravura或您可以使用可变

00:42:36.920 --> 00:42:41.329
 Eclipse集合中的任何堆栈

00:42:39.229 --> 00:42:43.339
你知道这些的树或尝试或表

00:42:41.329 --> 00:42:44.599
有空，你知道你知道

00:42:43.339 --> 00:42:46.130
某些跨框架不可用的框架

00:42:44.599 --> 00:42:48.710
其他的，但是如果你需要像

00:42:46.130 --> 00:42:50.390
不可变的，你知道基元和

00:42:48.710 --> 00:42:51.650
真的很流利的API 

00:42:50.390 --> 00:42:53.059
取决于您要寻找的东西

00:42:51.650 --> 00:42:56.299
你可以看到自己知道是什么

00:42:53.059 --> 00:42:59.059
可用，我们已经获得了一定的排名

00:42:56.299 --> 00:43:01.819
绿色复选标记为是，红色Xs为否

00:42:59.059 --> 00:43:05.749
然后是绿色的复选标记和框

00:43:01.819 --> 00:43:08.739
一种，然后您知道橙色x 

00:43:05.749 --> 00:43:10.849
和盒子不是很正确，所以

00:43:08.739 --> 00:43:17.059
对于状态复选框，那些很棒

00:43:10.849 --> 00:43:18.469
好吧，反正这是一种

00:43:17.059 --> 00:43:21.109
谈话周的时间比较快

00:43:18.469 --> 00:43:22.069
问题，但这是指向

00:43:21.109 --> 00:43:23.420
源代码将要签出

00:43:22.069 --> 00:43:25.819
并且有多种实现

00:43:23.420 --> 00:43:27.499
有不变的排序集

00:43:25.819 --> 00:43:29.420
我们在开发人员中使用的实现

00:43:27.499 --> 00:43:30.830
牛话和不可变的清单之一

00:43:29.420 --> 00:43:31.760
我们今天完成了

00:43:30.830 --> 00:43:33.290
看起来像代码的样子

00:43:31.760 --> 00:43:34.820
喜欢，你知道我会经历你

00:43:33.290 --> 00:43:36.440
知道自己说实验

00:43:34.820 --> 00:43:37.700
那里的东西自己尝试一下

00:43:36.440 --> 00:43:39.050
如果您想要不同的数据类型

00:43:37.700 --> 00:43:40.940
如果性能是

00:43:39.050 --> 00:43:43.100
对您很有趣，您知道您可以使用

00:43:40.940 --> 00:43:44.990
 jmh基准，您可以使用

00:43:43.100 --> 00:43:46.340
知道物体大小的纳斯角

00:43:44.990 --> 00:43:48.650
计算器，如果您好奇什么

00:43:46.340 --> 00:43:51.020
是的东西的内存占用量是这样的

00:43:48.650 --> 00:43:53.210
包括我们的性能基准

00:43:51.020 --> 00:43:55.580
内存测试一切都在

00:43:53.210 --> 00:43:58.040
树人将推这些幻灯片

00:43:55.580 --> 00:44:00.380
在Java上也是如此

00:43:58.040 --> 00:44:02.840
因此它们也将可用

00:44:00.380 --> 00:44:04.940
以及我们可能会把它们放在

00:44:02.840 --> 00:44:06.560
 SlideShare，但是如果您有任何疑问

00:44:04.940 --> 00:44:08.660
我的意思是我知道我们快没时间了

00:44:06.560 --> 00:44:11.510
如果您有任何疑问，您可以随时

00:44:08.660 --> 00:44:13.910
向我们任何人发推文，我们将开始

00:44:11.510 --> 00:44:16.820
重定向谁是专家

00:44:13.910 --> 00:44:19.490
集合或在哪个框架中

00:44:16.820 --> 00:44:21.740
说，我们将在JavaOne 

00:44:19.490 --> 00:44:24.980
楼下和开发商休息室

00:44:21.740 --> 00:44:26.090
地区以及周围的明天，所以

00:44:24.980 --> 00:44:28.430
如果您有任何疑问，您可以

00:44:26.090 --> 00:44:30.320
解决我们，我们会谈更多

00:44:28.430 --> 00:44:32.240
离线，我想你知道我喜欢

00:44:30.320 --> 00:44:33.650
呼应狮子座之前所说的话

00:44:32.240 --> 00:44:35.240
所有这些框架都是开源的

00:44:33.650 --> 00:44:37.970
如果您要使用它们，并且您喜欢

00:44:35.240 --> 00:44:39.830
他们你认识的人

00:44:37.970 --> 00:44:41.420
维护一个开源框架

00:44:39.830 --> 00:44:43.460
当人们贡献事物时热爱

00:44:41.420 --> 00:44:44.660
他们需要正确的，是的，这很棒

00:44:43.460 --> 00:44:46.000
如果我建立了您需要的一切

00:44:44.660 --> 00:44:48.020
为您打造了我所需的大部分东西

00:44:46.000 --> 00:44:49.520
但是如果你有，你需要做些什么

00:44:48.020 --> 00:44:50.990
太棒了，您知道的非常感谢

00:44:49.520 --> 00:44:52.580
贡献，我们在这里为您提供帮助

00:44:50.990 --> 00:44:53.930
做到这一点就像你想做的那样

00:44:52.580 --> 00:44:56.570
我们可以在github中为您提供帮助

00:44:53.930 --> 00:44:57.620
你知道在编码方面

00:44:56.570 --> 00:44:59.540
得到代码审查，实际上

00:44:57.620 --> 00:45:02.030
将您的贡献合并到

00:44:59.540 --> 00:45:04.310
回购和贡献不只是

00:45:02.030 --> 00:45:06.440
如果发现错误或想要通过代码

00:45:04.310 --> 00:45:10.100
功能请要求我们，因为

00:45:06.440 --> 00:45:11.630
对于Eclipse Collections 9.0，我们有很多

00:45:10.100 --> 00:45:13.700
最终导致的用户请求数量

00:45:11.630 --> 00:45:18.350
容纳和使用以外的用途

00:45:13.700 --> 00:45:20.240
所以我们如此，我们确实要研究和

00:45:18.350 --> 00:45:22.580
当我们的用户告诉我们

00:45:20.240 --> 00:45:25.220
改进框架，因为那是

00:45:22.580 --> 00:45:27.980
我们无法达到我们的全部范围

00:45:25.220 --> 00:45:29.750
自己的代码，不要忘记投票我

00:45:27.980 --> 00:45:31.760
如果你和我们在一起就很好

00:45:29.750 --> 00:45:33.140
但只要回来告诉我们为什么

00:45:31.760 --> 00:45:36.050
您不赞成投票，因为这会有所帮助

00:45:33.140 --> 00:45:37.400
我们改善我们的下一站是

00:45:36.050 --> 00:45:40.310
不会亲自考虑

00:45:37.400 --> 00:45:41.930
不用担心，谢谢

00:45:40.310 --> 00:45:42.730
每个人都参加了Java 1的出色表现

00:45:41.930 --> 00:45:44.790
是的

00:45:42.730 --> 00:45:44.790
您

