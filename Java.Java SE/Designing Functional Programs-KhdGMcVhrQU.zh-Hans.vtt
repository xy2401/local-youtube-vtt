WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.029 --> 00:00:07.840
好吧，让我们开始吧，欢迎来到

00:00:06.100 --> 00:00:09.880
设计功能程序会议

00:00:07.840 --> 00:00:11.980
我叫Venkat Subramanyam，我们是

00:00:09.880 --> 00:00:14.349
谈论我们如何处理

00:00:11.980 --> 00:00:15.879
我们通常有的一些担忧

00:00:14.349 --> 00:00:18.340
在设计功能时

00:00:15.879 --> 00:00:20.710
应用程序只是为了快速设置

00:00:18.340 --> 00:00:23.260
这种讲话来自的阶段

00:00:20.710 --> 00:00:25.240
我一直在谈编程

00:00:23.260 --> 00:00:27.400
 Java中的功能样式

00:00:25.240 --> 00:00:30.040
现在已经有很多年了

00:00:27.400 --> 00:00:31.240
每当我说完话，我都会

00:00:30.040 --> 00:00:33.489
有人来找我，问一些

00:00:31.240 --> 00:00:35.500
问题，有一个非常普遍的

00:00:33.489 --> 00:00:38.110
几乎发生的问题的主题

00:00:35.500 --> 00:00:39.550
我每次演讲都

00:00:38.110 --> 00:00:42.490
就像哦，我听过很多这个问题

00:00:39.550 --> 00:00:43.090
时代，所以我说的很好

00:00:42.490 --> 00:00:45.790
手段

00:00:43.090 --> 00:00:47.200
它值得一个演讲，所以我很客气

00:00:45.790 --> 00:00:49.480
抓住了其中一些问题， 

00:00:47.200 --> 00:00:50.590
创建一个演讲，所以我真的

00:00:49.480 --> 00:00:52.810
想谈谈我们如何真正

00:00:50.590 --> 00:00:55.030
你知道设计一些方法

00:00:52.810 --> 00:00:58.180
功能系统还有哪些

00:00:55.030 --> 00:01:00.790
函数式风格的不足

00:00:58.180 --> 00:01:03.010
用Java进行编程的地方

00:01:00.790 --> 00:01:05.079
有点平，我们可能需要

00:01:03.010 --> 00:01:06.999
做一点不同，这不是

00:01:05.079 --> 00:01:09.189
关于一般的函数式编程

00:01:06.999 --> 00:01:11.649
这与我们如何处理有关

00:01:09.189 --> 00:01:14.889
在Java中与此相关，因为我们使用的工具

00:01:11.649 --> 00:01:16.270
经常限制我们在做什么的同时

00:01:14.889 --> 00:01:18.850
有概念和理论， 

00:01:16.270 --> 00:01:20.530
练习，我们可能无法

00:01:18.850 --> 00:01:22.209
以我们希望的方式完成所有这些工作

00:01:20.530 --> 00:01:23.979
取决于哪种工具

00:01:22.209 --> 00:01:26.200
环境，语言和框架

00:01:23.979 --> 00:01:28.450
和我们使用的库，这很漂亮

00:01:26.200 --> 00:01:30.340
关于我们大多数人所处的世界

00:01:28.450 --> 00:01:32.079
这个房间住的嘿我们

00:01:30.340 --> 00:01:34.149
 Java编程，我们采用了Java 

00:01:32.079 --> 00:01:36.459
 8我们以函数式风格进行编程

00:01:34.149 --> 00:01:37.929
但是我们如何真正做到这一点

00:01:36.459 --> 00:01:40.810
我真正想要关注的是

00:01:37.929 --> 00:01:43.240
从功能上讲

00:01:40.810 --> 00:01:45.929
编程，什么才是真正的功能

00:01:43.240 --> 00:01:48.459
编程很好，我们正在尝试做一个

00:01:45.929 --> 00:01:50.349
函数分解就是我们要做的

00:01:48.459 --> 00:01:52.149
真的试图做一件事情

00:01:50.349 --> 00:01:53.349
这让我感到非常沮丧

00:01:52.149 --> 00:01:56.259
练习功能的人

00:01:53.349 --> 00:01:57.729
编程出去，说天哪，这是

00:01:56.259 --> 00:01:59.770
太好了，我们不必做任何事情

00:01:57.729 --> 00:02:02.380
对我来说，这正试图把

00:01:59.770 --> 00:02:03.700
婴儿洗澡水，我不

00:02:02.380 --> 00:02:05.289
面向对象有问题

00:02:03.700 --> 00:02:07.060
编程我的方式有问题

00:02:05.289 --> 00:02:10.060
人们使用面向对象的编程

00:02:07.060 --> 00:02:11.709
所以问题不在哦

00:02:10.060 --> 00:02:14.590
是以及如何被许多人使用

00:02:11.709 --> 00:02:15.780
人们和我都从中受益匪浅

00:02:14.590 --> 00:02:17.490
从对象到编程

00:02:15.780 --> 00:02:18.930
我不想扔掉它，但是在

00:02:17.490 --> 00:02:21.060
那个方面我想看一下

00:02:18.930 --> 00:02:23.400
有点不同，我到底是什么

00:02:21.060 --> 00:02:24.510
当我尝试编程时尝试做

00:02:23.400 --> 00:02:26.490
我真正的函数式风格是什么

00:02:24.510 --> 00:02:28.170
如果你真的回头

00:02:26.490 --> 00:02:30.480
在Java的20年左右

00:02:28.170 --> 00:02:32.690
编程我们都可以同意我们

00:02:30.480 --> 00:02:35.580
面向对象编程中

00:02:32.690 --> 00:02:38.430
系统正确，所以我们一直在做

00:02:35.580 --> 00:02:40.620
面向对象的程序设计

00:02:38.430 --> 00:02:42.330
就是这样的总结

00:02:40.620 --> 00:02:44.370
我们一直在做，但让我们成为现实

00:02:42.330 --> 00:02:47.310
老实说，没有人拥有

00:02:44.370 --> 00:02:49.440
曾经用

00:02:47.310 --> 00:02:51.930
只有对象是不可能做到的

00:02:49.440 --> 00:02:53.610
因为当您创建对象时，什么是

00:02:51.930 --> 00:02:55.709
接下来要做的是创建方法

00:02:53.610 --> 00:02:57.510
和田野也许然后当你

00:02:55.709 --> 00:02:59.459
创建方法你擅长什么

00:02:57.510 --> 00:03:01.200
将要实施的方法

00:02:59.459 --> 00:03:03.120
好吧，我们要写一些代码

00:03:01.200 --> 00:03:05.540
实现方法，所以我们已经

00:03:03.120 --> 00:03:07.470
真正做到诚实不是

00:03:05.540 --> 00:03:09.810
我们只保留面向对象的编程

00:03:07.470 --> 00:03:13.800
说这是我们一直在做的

00:03:09.810 --> 00:03:15.569
势在必行加上面向对象

00:03:13.800 --> 00:03:17.819
所有诚实的权利，因为那是什么

00:03:15.569 --> 00:03:19.590
我们一直在做当务之急

00:03:17.819 --> 00:03:21.989
编程的目的是

00:03:19.590 --> 00:03:24.660
这些年来一直在做，因为

00:03:21.989 --> 00:03:26.519
我们编写的方法以及如何使用

00:03:24.660 --> 00:03:29.489
多个对象都已经

00:03:26.519 --> 00:03:32.220
势在必行，对我而言，这部分内容

00:03:29.489 --> 00:03:34.350
哦，那真的很糟糕，但是有

00:03:32.220 --> 00:03:36.299
哦的那部分非常强大

00:03:34.350 --> 00:03:37.950
有用，我不想放手

00:03:36.299 --> 00:03:39.989
他们只是我个人的选择

00:03:37.950 --> 00:03:42.360
知道我可能不会发怒

00:03:39.989 --> 00:03:44.100
进入编程，但是

00:03:42.360 --> 00:03:46.470
问题是我们到底在尝试什么

00:03:44.100 --> 00:03:48.060
到我仍然要去的地方康复

00:03:46.470 --> 00:03:50.519
继续做对象编程

00:03:48.060 --> 00:03:52.859
但我要用功能

00:03:50.519 --> 00:03:55.200
分解加对象或在

00:03:52.859 --> 00:03:57.900
编程，所以我真的很感兴趣

00:03:55.200 --> 00:04:00.000
这里是替换那部分而不是

00:03:57.900 --> 00:04:02.790
右边，因为右边不是

00:04:00.000 --> 00:04:04.200
我的主要问题是可以做到的

00:04:02.790 --> 00:04:06.090
我不是很可恶

00:04:04.200 --> 00:04:08.880
人们做事不坏，但是如果我

00:04:06.090 --> 00:04:11.160
哦，哦，哦，那真的很好

00:04:08.880 --> 00:04:12.510
问题是不要扔它哦哦我的

00:04:11.160 --> 00:04:14.489
问题是当务之急

00:04:12.510 --> 00:04:16.500
样式或至少将其替换为

00:04:14.489 --> 00:04:18.359
 Java中的功能样式

00:04:16.500 --> 00:04:21.989
今天和其他语言

00:04:18.359 --> 00:04:23.580
你知道Ruby，Scala和groovy 

00:04:21.989 --> 00:04:25.409
 Java不是唯一的语言

00:04:23.580 --> 00:04:27.510
这很多不同的语言

00:04:25.409 --> 00:04:28.790
可以实际使用面向对象

00:04:27.510 --> 00:04:30.560
分解

00:04:28.790 --> 00:04:33.200
可以将其与功能分解混合

00:04:30.560 --> 00:04:34.790
也可以从中受益

00:04:33.200 --> 00:04:36.890
这两个词，这是其中之一

00:04:34.790 --> 00:04:38.750
为我们这样做真的很有意义

00:04:36.890 --> 00:04:41.510
所以呃我正在努力做的

00:04:38.750 --> 00:04:43.520
这几年真的好起来了

00:04:41.510 --> 00:04:45.050
我可以在哪里应用对象

00:04:43.520 --> 00:04:46.850
编程，我可以在哪里申请

00:04:45.050 --> 00:04:48.200
功能编程并将其放入

00:04:46.850 --> 00:04:50.450
真的很好用，并从中受益

00:04:48.200 --> 00:04:52.490
其中之一是因为我在两者中都找到了价值

00:04:50.450 --> 00:04:55.010
他们，当然我有时候

00:04:52.490 --> 00:04:57.020
必须承认我确实使用命令式风格

00:04:55.010 --> 00:04:59.330
对我来说，编程也只是

00:04:57.020 --> 00:05:00.200
我不偏向于一二的工具

00:04:59.330 --> 00:05:02.300
与另一个

00:05:00.200 --> 00:05:03.710
我更喜欢函数式编程

00:05:02.300 --> 00:05:05.750
我的生活在哪里有意义

00:05:03.710 --> 00:05:07.670
更容易让我真正受益的地方

00:05:05.750 --> 00:05:09.230
它，但有时可能会

00:05:07.670 --> 00:05:10.970
命令式的风格更适合

00:05:09.230 --> 00:05:13.550
眼前的问题，我真的不介意

00:05:10.970 --> 00:05:15.560
在那个特定的上下文中使用它

00:05:13.550 --> 00:05:17.450
所以从这个意义上说，真正的是

00:05:15.560 --> 00:05:19.250
你知道的函数式编程

00:05:17.450 --> 00:05:20.630
它真正提供了什么？ 

00:05:19.250 --> 00:05:22.040
我们听到的第一件事

00:05:20.630 --> 00:05:23.240
开始时进行功能编程

00:05:22.040 --> 00:05:24.950
阅读功能编程将

00:05:23.240 --> 00:05:26.210
开始了解它是什么

00:05:24.950 --> 00:05:28.340
告诉我们他们告诉你的第一件事是

00:05:26.210 --> 00:05:30.470
嘿，你不应该做任何改变

00:05:28.340 --> 00:05:32.750
权利分配少的编程是

00:05:30.470 --> 00:05:34.640
非常重要的是不要做作业

00:05:32.750 --> 00:05:37.190
无论如何不要更改变量和值

00:05:34.640 --> 00:05:39.560
我有很多语言

00:05:37.190 --> 00:05:42.650
将这些语言分类为

00:05:39.560 --> 00:05:44.540
将语言分为几类

00:05:42.650 --> 00:05:47.320
在这种情况下，我有不同的方式

00:05:44.540 --> 00:05:50.660
称它们为纯功能

00:05:47.320 --> 00:05:52.100
编程语言语言和

00:05:50.660 --> 00:05:55.130
那当然有语言

00:05:52.100 --> 00:05:57.410
我称之为混合功能语言

00:05:55.130 --> 00:05:59.870
就像在面向对象的编程中一样

00:05:57.410 --> 00:06:02.120
你有完全面向对象的语言

00:05:59.870 --> 00:06:04.160
但是你也有混合的面向对象

00:06:02.120 --> 00:06:06.140
语言混合光学的一个例子

00:06:04.160 --> 00:06:07.730
语言是C ++，即使人们愿意

00:06:06.140 --> 00:06:09.710
争论它是面向对象的还是

00:06:07.730 --> 00:06:11.360
不是，但是我并不真正感兴趣

00:06:09.710 --> 00:06:13.550
这种说法是混合语言

00:06:11.360 --> 00:06:16.220
至于一些担心，因为我可以

00:06:13.550 --> 00:06:18.140
完全没有对象，对，纯C pro 

00:06:16.220 --> 00:06:20.270
如果需要，可以在其中进行编码，也可以混合使用

00:06:18.140 --> 00:06:22.910
匹配它，而如果您采取非常非常

00:06:20.270 --> 00:06:24.920
纯粹的面向对象语言

00:06:22.910 --> 00:06:26.780
并不是所有人真正拥有任何东西

00:06:24.920 --> 00:06:28.430
在对象之外，它将强制执行

00:06:26.780 --> 00:06:29.960
对象真的变成了

00:06:28.430 --> 00:06:31.610
在这种情况下，范式当然是

00:06:29.960 --> 00:06:33.440
仍然势在必行，但他们

00:06:31.610 --> 00:06:35.630
外部程序不完全

00:06:33.440 --> 00:06:37.490
很像这样

00:06:35.630 --> 00:06:39.980
纯粹是功能性的语言

00:06:37.490 --> 00:06:41.790
编程语言这些语言

00:06:39.980 --> 00:06:46.020
不会让你

00:06:41.790 --> 00:06:48.660
任何时期都没有语法

00:06:46.020 --> 00:06:51.390
创建变量后对其进行修改

00:06:48.660 --> 00:06:53.190
你可以一起度过数小时和数天

00:06:51.390 --> 00:06:55.020
我无法改变它

00:06:53.190 --> 00:06:56.670
教授编程语言课程

00:06:55.020 --> 00:06:58.380
在那个过程中，我通常使用

00:06:56.670 --> 00:06:59.370
大约八种语言，但我的学生

00:06:58.380 --> 00:07:00.960
比我好

00:06:59.370 --> 00:07:02.820
我们总共使用大约20或25 

00:07:00.960 --> 00:07:04.380
课程中的语言非常

00:07:02.820 --> 00:07:06.180
奖励课程，因为我来

00:07:04.380 --> 00:07:08.670
从这个课程中学到很多东西，但是

00:07:06.180 --> 00:07:10.290
一个学期有一个关于你的学生

00:07:08.670 --> 00:07:11.940
知道我有15年的经验

00:07:10.290 --> 00:07:14.790
说你知道我用过这些

00:07:11.940 --> 00:07:17.010
语言，但我实际上很喜欢

00:07:14.790 --> 00:07:18.720
功能语言比混合语言更好

00:07:17.010 --> 00:07:20.730
他说的功能语言我说为什么

00:07:18.720 --> 00:07:22.830
你这么说和以及原因

00:07:20.730 --> 00:07:24.930
他给的方式有两种

00:07:22.830 --> 00:07:26.670
他说原因是当我坐下来

00:07:24.930 --> 00:07:28.260
写代码来自命令式风格

00:07:26.670 --> 00:07:30.630
静音背景的背景对象

00:07:28.260 --> 00:07:33.090
当写代码的时候

00:07:30.630 --> 00:07:35.640
语言是混合的，我为此苦苦挣扎

00:07:33.090 --> 00:07:37.920
 15分钟我无法弄清楚

00:07:35.640 --> 00:07:39.840
要做到这一点，我安静地回到我的旧

00:07:37.920 --> 00:07:41.820
处事方式和语言

00:07:39.840 --> 00:07:43.920
另一方面让我安静地做

00:07:41.820 --> 00:07:46.080
这种纯粹的功能性语言击败了我

00:07:43.920 --> 00:07:47.790
没错，这需要我并击败我

00:07:46.080 --> 00:07:50.970
我的头说这是我的方式

00:07:47.790 --> 00:07:53.760
公路，我哭泣，我抱怨我诅咒， 

00:07:50.970 --> 00:07:55.230
七个小时后，我仍然陷于困境， 

00:07:53.760 --> 00:07:57.690
然后我去休息一下

00:07:55.230 --> 00:08:00.300
第二天，最后事情开始

00:07:57.690 --> 00:08:02.460
工作，毕竟这让我沮丧

00:08:00.300 --> 00:08:04.410
开始看到如何做的光

00:08:02.460 --> 00:08:06.600
所以他从那个角度说

00:08:04.410 --> 00:08:08.340
我真的很喜欢打败我的语言

00:08:06.600 --> 00:08:10.320
下来告诉我这是方法

00:08:08.340 --> 00:08:13.440
我说那正是原因

00:08:10.320 --> 00:08:15.990
我也更喜欢混合语言，因为

00:08:13.440 --> 00:08:18.000
当我上班时我的老板会被击败

00:08:15.990 --> 00:08:20.220
当我不明白的时候我会更加努力

00:08:18.000 --> 00:08:22.170
这个词完成了，所以我真的很高兴地说

00:08:20.220 --> 00:08:24.120
你知道这种纯度是什么

00:08:22.170 --> 00:08:25.950
但是我现在已经在生产中了

00:08:24.120 --> 00:08:27.420
可以回来重构它，我是

00:08:25.950 --> 00:08:31.020
真正务实的人而不是

00:08:27.420 --> 00:08:32.760
是一个完美主义者，是的，我真的想要

00:08:31.020 --> 00:08:34.650
做善事，但在最后

00:08:32.760 --> 00:08:36.750
那天我仍然要你知道继续

00:08:34.650 --> 00:08:38.370
也要发布产品

00:08:36.750 --> 00:08:40.080
我之所以喜欢这些类型的原因

00:08:38.370 --> 00:08:41.250
语言，因为它们确实为您提供了

00:08:40.080 --> 00:08:43.830
当你陷入困境时的逃生路线

00:08:41.250 --> 00:08:45.000
在这方面有一些东西

00:08:43.830 --> 00:08:48.060
一些没有的语言

00:08:45.000 --> 00:08:50.790
完全可变，所以这里

00:08:48.060 --> 00:08:52.080
肯定是不变性之一，但

00:08:50.790 --> 00:08:54.030
那是起作用的事情之一

00:08:52.080 --> 00:08:55.000
编程语言真的支持

00:08:54.030 --> 00:08:56.950
另一件事是

00:08:55.000 --> 00:08:59.350
高阶函数的功能

00:08:56.950 --> 00:09:01.150
高阶函数很好吗

00:08:59.350 --> 00:09:02.710
再考虑一分钟

00:09:01.150 --> 00:09:03.340
 Java的上下文以及我们一直以来的经历

00:09:02.710 --> 00:09:05.320
过去

00:09:03.340 --> 00:09:08.920
到目前为止我们一直在做什么

00:09:05.320 --> 00:09:11.140
我们可能将对象传递给

00:09:08.920 --> 00:09:13.180
我不是我故意的功能

00:09:11.140 --> 00:09:15.010
使用世界方法，所以很清楚

00:09:13.180 --> 00:09:17.200
得到它，把它弄走给我

00:09:15.010 --> 00:09:19.720
方法，它只是一个函数

00:09:17.200 --> 00:09:22.540
与...关联的功能

00:09:19.720 --> 00:09:24.550
类或对象，因此函数可以

00:09:22.540 --> 00:09:26.530
成为独立功能的一种方法是

00:09:24.550 --> 00:09:28.450
与类或类相关的功能

00:09:26.530 --> 00:09:30.130
我们到一个实例，所以我只是要

00:09:28.450 --> 00:09:32.650
通常使用单词function，我们可能

00:09:30.130 --> 00:09:36.900
将对象传递给函数

00:09:32.650 --> 00:09:39.790
在所有对象之后创建一个create 

00:09:36.900 --> 00:09:41.290
功能，所以在这里我们也可以做到这一点

00:09:39.790 --> 00:09:43.440
已经以类似

00:09:41.290 --> 00:09:46.510
 Java，最后我们可能会返回

00:09:43.440 --> 00:09:47.830
我不想要的功能对象

00:09:46.510 --> 00:09:49.870
在语法上要正确正确

00:09:47.830 --> 00:09:52.090
原因，所以这就是我们去过的地方

00:09:49.870 --> 00:09:54.150
这样做我们已经习惯了

00:09:52.090 --> 00:09:57.730
毕竟高阶函数

00:09:54.150 --> 00:10:00.339
高阶函数是我们可以在哪里

00:09:57.730 --> 00:10:02.440
将功能传递给我们可能会使用的功能

00:10:00.339 --> 00:10:04.540
在函数中创建函数

00:10:02.440 --> 00:10:06.520
可能从一个函数返回一个函数，所以

00:10:04.540 --> 00:10:08.440
这基本上就是使函数成为

00:10:06.520 --> 00:10:10.750
高阶函数是我们可以

00:10:08.440 --> 00:10:12.580
使用其他功能组合功能

00:10:10.750 --> 00:10:14.170
把东西放在一起，所以我们正在使用

00:10:12.580 --> 00:10:16.360
高阶函数来构建东西

00:10:14.170 --> 00:10:18.310
围绕它，因此具有更高阶的功能

00:10:16.360 --> 00:10:19.960
给我们您仍然可以接受的能力

00:10:18.310 --> 00:10:22.210
对象仍然可以作为参数

00:10:19.960 --> 00:10:23.920
返回对象作为结果，但是

00:10:22.210 --> 00:10:26.110
此外，您还可以使用

00:10:23.920 --> 00:10:28.420
接收它们的函数创建它们

00:10:26.110 --> 00:10:29.740
并把它们还给我们

00:10:28.420 --> 00:10:31.930
我们有编程能力

00:10:29.740 --> 00:10:34.990
您所在的高阶函数

00:10:31.930 --> 00:10:36.940
提高你的水平，你是说我不是

00:10:34.990 --> 00:10:38.920
只会收到你的东西

00:10:36.940 --> 00:10:41.320
或您的数据或您的原始数据

00:10:38.920 --> 00:10:43.150
我也很愿意接受功能

00:10:41.320 --> 00:10:44.860
基本上也是你的意思

00:10:43.150 --> 00:10:46.120
高阶函数很好地做到了这一点

00:10:44.860 --> 00:10:49.150
导致一些真正强大的

00:10:46.120 --> 00:10:51.190
和我在一起的时候

00:10:49.150 --> 00:10:53.020
我对不变性感到兴奋

00:10:51.190 --> 00:10:54.910
你真的很兴奋

00:10:53.020 --> 00:10:56.680
高阶函数，但对我来说这些

00:10:54.910 --> 00:10:58.810
不是最重要的事情

00:10:56.680 --> 00:11:01.330
真的可以工作，例如有人

00:10:58.810 --> 00:11:02.860
来找你说真的

00:11:01.330 --> 00:11:03.459
面向对象真酷

00:11:02.860 --> 00:11:05.620
程式设计

00:11:03.459 --> 00:11:07.390
我不是在建议对象或编程

00:11:05.620 --> 00:11:07.950
是介绍所有这些的

00:11:07.390 --> 00:11:09.870
但

00:11:07.950 --> 00:11:11.340
对象真正酷的是什么

00:11:09.870 --> 00:11:13.920
编程很好，我们可以这样说

00:11:11.340 --> 00:11:16.860
编程的对象是我们真正的地方

00:11:13.920 --> 00:11:19.170
荣誉抽象权利绝对肯定

00:11:16.860 --> 00:11:21.390
然后我们尊重封装

00:11:19.170 --> 00:11:23.100
绝对我们要真正填补

00:11:21.390 --> 00:11:24.090
进行一些封装，然后

00:11:23.100 --> 00:11:26.610
当然我们真的想要

00:11:24.090 --> 00:11:28.590
继承，然后当然是什么

00:11:26.610 --> 00:11:31.290
最后是多态性，但是如果你

00:11:28.590 --> 00:11:34.920
真的在其中考虑

00:11:31.290 --> 00:11:36.900
最重要的四件事

00:11:34.920 --> 00:11:38.910
最多态的东西

00:11:36.900 --> 00:11:41.040
重要的是抽象不是

00:11:38.910 --> 00:11:43.860
完全反对编程

00:11:41.040 --> 00:11:45.690
我们已经为许多人做了抽象

00:11:43.860 --> 00:11:46.500
很多系列，甚至在我们想到之前

00:11:45.690 --> 00:11:48.300
编程权

00:11:46.500 --> 00:11:50.160
柏拉图介绍了

00:11:48.300 --> 00:11:51.960
如果不是其中之一则抽象

00:11:50.160 --> 00:11:53.670
首先肯定是最早的人之一

00:11:51.960 --> 00:11:55.980
为此，我们一直在使用抽象

00:11:53.670 --> 00:11:57.600
我们在每一件事中所做的每一件事

00:11:55.980 --> 00:11:59.820
我们曾经写过的语言

00:11:57.600 --> 00:12:01.560
抽象某种形式或其他

00:11:59.820 --> 00:12:04.140
并非所有的语言都给我们用户

00:12:01.560 --> 00:12:06.270
定义数据类型，但是我们可以说

00:12:04.140 --> 00:12:09.060
太好了，我们可以做得很好

00:12:06.270 --> 00:12:11.340
一定要丢弃该封装

00:12:09.060 --> 00:12:12.840
封装非常重要，但

00:12:11.340 --> 00:12:14.940
您甚至可以在

00:12:12.840 --> 00:12:16.800
功能无论您放置什么局部变量

00:12:14.940 --> 00:12:18.300
在一个函数中被封装了，所以

00:12:16.800 --> 00:12:20.640
这真的延伸，给你其他

00:12:18.300 --> 00:12:22.110
绝对的封装形式

00:12:20.640 --> 00:12:25.530
我不是说这没用

00:12:22.110 --> 00:12:27.120
但是我不会因为我而去

00:12:25.530 --> 00:12:28.140
可以做封装确保

00:12:27.120 --> 00:12:30.750
非常热情

00:12:28.140 --> 00:12:33.950
继承是唯一的问题吗

00:12:30.750 --> 00:12:36.540
继承是痛苦的，因为在这种情况下，您

00:12:33.950 --> 00:12:38.640
大多数情况下这确实是问题的原因

00:12:36.540 --> 00:12:40.620
不仅仅是力量的原因

00:12:38.640 --> 00:12:42.530
语言下的各种对象

00:12:40.620 --> 00:12:44.760
甚至都不在乎继承

00:12:42.530 --> 00:12:47.520
不幸的是，当我们在一个程序中编程时

00:12:44.760 --> 00:12:49.470
语言主要是他们使我们蒙蔽

00:12:47.520 --> 00:12:51.750
他们真心遗憾地因为

00:12:49.470 --> 00:12:53.310
他们真的使我们蒙蔽了我们

00:12:51.750 --> 00:12:54.510
认为这是其中之一

00:12:53.310 --> 00:12:56.400
我真的想学习不同的原因

00:12:54.510 --> 00:12:57.660
我不会想到的那种语言

00:12:56.400 --> 00:12:59.460
以某种特定方式处理任何事情

00:12:57.660 --> 00:13:00.600
对，所以没有一种真正的方法

00:12:59.460 --> 00:13:02.730
想想事情太多了

00:13:00.600 --> 00:13:04.410
变异继承不是真的

00:13:02.730 --> 00:13:05.910
在很多方面都需要

00:13:04.410 --> 00:13:07.650
它通常是问题的一部分，而不是

00:13:05.910 --> 00:13:09.540
大部分时间都可以解决，但是

00:13:07.650 --> 00:13:11.310
尽管保留了这种多态性

00:13:09.540 --> 00:13:12.090
多态性并非对象独有

00:13:11.310 --> 00:13:15.180
正在编程中

00:13:12.090 --> 00:13:17.760
我真的为

00:13:15.180 --> 00:13:19.740
多态行为，因为这是

00:13:17.760 --> 00:13:21.500
是什么让我的扩展性

00:13:19.740 --> 00:13:23.600
软件对我来说是如此

00:13:21.500 --> 00:13:27.850
但是哦，那真的是什么，我们真的

00:13:23.600 --> 00:13:30.830
多态性是面向对象之后

00:13:27.850 --> 00:13:33.260
编程所以这就是我真正的

00:13:30.830 --> 00:13:35.450
真的在谈到

00:13:33.260 --> 00:13:38.480
编程多态性意味着

00:13:35.450 --> 00:13:40.910
编程的对象以及我是什么

00:13:38.480 --> 00:13:43.160
真的如此向前迈进

00:13:40.910 --> 00:13:44.960
关于函数式编程

00:13:43.160 --> 00:13:46.880
人们通常告诉我们他们

00:13:44.960 --> 00:13:49.370
在函数式编程中告诉我们

00:13:46.880 --> 00:13:50.780
世界的不可改变性

00:13:49.370 --> 00:13:52.610
重要，这就像在说

00:13:50.780 --> 00:13:54.620
所有这些抽象和封装

00:13:52.610 --> 00:13:56.500
好东西，他们告诉我们

00:13:54.620 --> 00:13:58.610
高阶函数真的

00:13:56.500 --> 00:14:00.410
重要哦，是的，我绝对

00:13:58.610 --> 00:14:02.570
完全同意那个高阶

00:14:00.410 --> 00:14:04.370
功能固然重要，但真正的

00:14:02.570 --> 00:14:06.620
功能的迷人之处

00:14:04.370 --> 00:14:08.690
我认为编程真的来了

00:14:06.620 --> 00:14:11.540
从两件事来看，一是功能

00:14:08.690 --> 00:14:14.660
组成，另一个很懒

00:14:11.540 --> 00:14:16.760
评估，所以这是两个最重要的

00:14:14.660 --> 00:14:18.680
迷人的功能，我们的功能

00:14:16.760 --> 00:14:20.690
编程，这就是我醒来的

00:14:18.680 --> 00:14:22.880
每天早晨享受

00:14:20.690 --> 00:14:26.420
对我来说，函数式编程是

00:14:22.880 --> 00:14:29.720
我无法做到的途径

00:14:26.420 --> 00:14:31.940
没有这两个就做，但是我不是

00:14:29.720 --> 00:14:33.950
做这两个而没有得到这些

00:14:31.940 --> 00:14:37.160
二是我真正追求的

00:14:33.950 --> 00:14:42.260
所以我要说功能组成

00:14:37.160 --> 00:14:44.360
懒惰的评估对功能

00:14:42.260 --> 00:14:46.910
编程，因为那就是我们

00:14:44.360 --> 00:14:49.430
就我们而言，确实是在追求

00:14:46.910 --> 00:14:50.180
我们的目标是珍惜

00:14:49.430 --> 00:14:52.610
重要特征

00:14:50.180 --> 00:14:55.310
为什么因为功能组合给

00:14:52.610 --> 00:14:57.020
我们具有表现力的代码

00:14:55.310 --> 00:15:00.050
真正将代码表达为一系列

00:14:57.020 --> 00:15:02.210
它消除了偶然的转变

00:15:00.050 --> 00:15:04.730
复杂性原因不满意

00:15:02.210 --> 00:15:07.280
命令性代码是因为

00:15:04.730 --> 00:15:08.540
复杂性给他们带来了意外

00:15:07.280 --> 00:15:11.210
它带来了代码的复杂性

00:15:08.540 --> 00:15:13.430
而功能组成

00:15:11.210 --> 00:15:14.810
消除了意外的复杂性

00:15:13.430 --> 00:15:16.040
使代码更具表现力

00:15:14.810 --> 00:15:18.110
代码更容易遵循，这使得代码

00:15:16.040 --> 00:15:19.910
更容易理解，这是其中之一

00:15:18.110 --> 00:15:22.220
我从中获得最大的收获，但是

00:15:19.910 --> 00:15:23.780
不幸的是，尽管我不能卖掉

00:15:22.220 --> 00:15:25.910
你说功能组合很棒

00:15:23.780 --> 00:15:28.280
回家吧，因为你要去尝试

00:15:25.910 --> 00:15:30.589
并说你是白痴，因为这

00:15:28.280 --> 00:15:32.720
将要在对象之后创建对象

00:15:30.589 --> 00:15:35.240
在对象之后，我们可能真的

00:15:32.720 --> 00:15:37.309
问题是您的船员越垃圾

00:15:35.240 --> 00:15:38.689
您必须收集更多的垃圾， 

00:15:37.309 --> 00:15:41.240
我们不会有好的表现

00:15:38.689 --> 00:15:43.879
如果我们继续创建大型数据集

00:15:41.240 --> 00:15:45.649
对象，但公平地说，有一个

00:15:43.879 --> 00:15:47.509
许多语言完全可以做到

00:15:45.649 --> 00:15:49.790
他们给你的函数式风格

00:15:47.509 --> 00:15:51.980
功能组成，但它们不

00:15:49.790 --> 00:15:53.689
给你那些懒惰的评价

00:15:51.980 --> 00:15:54.980
创建大型语言时

00:15:53.689 --> 00:15:56.929
收集并通过功能

00:15:54.980 --> 00:15:58.519
管道，您将创建很多

00:15:56.929 --> 00:16:01.069
一路上的中间收藏

00:15:58.519 --> 00:16:03.319
但他们似乎并不在乎

00:16:01.069 --> 00:16:04.819
有几个原因，因为大多数

00:16:03.319 --> 00:16:05.600
和你一起工作的人很少

00:16:04.819 --> 00:16:07.550
馆藏

00:16:05.600 --> 00:16:10.160
它不会再次损害性能

00:16:07.550 --> 00:16:11.600
务实地说，我不想

00:16:10.160 --> 00:16:13.550
抱怨不影响的事情

00:16:11.600 --> 00:16:16.069
我嘿，我的收藏很小

00:16:13.550 --> 00:16:18.230
性能合理，为什么要打扰

00:16:16.069 --> 00:16:20.929
对此感到高兴，但我个人

00:16:18.230 --> 00:16:23.089
在大数据项目上工作的是

00:16:20.929 --> 00:16:25.550
这些天我处理数百万个数据

00:16:23.089 --> 00:16:27.499
性能是最重要的

00:16:25.550 --> 00:16:29.990
一切都在那之后

00:16:27.499 --> 00:16:31.639
懒惰使人真正成为

00:16:29.990 --> 00:16:33.499
高效而富有表现力的

00:16:31.639 --> 00:16:35.360
时间是真正的原因之一

00:16:33.499 --> 00:16:37.910
我们从中受益，在其他方面

00:16:35.360 --> 00:16:39.649
不变性和

00:16:37.910 --> 00:16:43.339
高阶函数真的很好

00:16:39.649 --> 00:16:45.110
非常有用，非常关键，但是在哪里

00:16:43.339 --> 00:16:47.929
我真的是那两个

00:16:45.110 --> 00:16:50.269
功能组成和懒惰评估

00:16:47.929 --> 00:16:52.160
那才是我真正的想法

00:16:50.269 --> 00:16:53.959
这些语言有什么作用

00:16:52.160 --> 00:16:56.329
这真的对我们有帮助吗？ 

00:16:53.959 --> 00:16:58.910
帮助我们，让我们了解

00:16:56.329 --> 00:17:01.040
我爱这怎么会很有用

00:16:58.910 --> 00:17:04.100
语言是做什么的，因为什么时候

00:17:01.040 --> 00:17:05.120
语言知道某种结构

00:17:04.100 --> 00:17:07.370
很纯净

00:17:05.120 --> 00:17:09.260
有语言可以做的优化

00:17:07.370 --> 00:17:11.860
让我们来看一个例子

00:17:09.260 --> 00:17:14.630
很快，一种这样的语言是

00:17:11.860 --> 00:17:16.640
 Haskell我们的Haskell可能是其中之一

00:17:14.630 --> 00:17:19.250
真正令我惊讶的语言

00:17:16.640 --> 00:17:21.380
因为我实际上拒绝了该语言

00:17:19.250 --> 00:17:23.600
几次我试图学习它三

00:17:21.380 --> 00:17:25.429
每次我放弃的时间

00:17:23.600 --> 00:17:27.020
我第三次坐下来对你说

00:17:25.429 --> 00:17:29.090
知道我所有的朋友告诉我，这很好

00:17:27.020 --> 00:17:31.010
我相信他们的事我想学习

00:17:29.090 --> 00:17:34.010
这就是我真的很难过的

00:17:31.010 --> 00:17:36.529
我每次坐都学习Haskell 

00:17:34.010 --> 00:17:38.779
去学习Haskell，我想去

00:17:36.529 --> 00:17:40.520
通过静态输入，我

00:17:38.779 --> 00:17:42.529
我不够聪明甚至无法得到

00:17:40.520 --> 00:17:44.419
它，我就是失败了

00:17:42.529 --> 00:17:45.860
每当有一天，我意识到

00:17:44.419 --> 00:17:48.049
哦，天哪，我做错了

00:17:45.860 --> 00:17:50.809
 Haskell不在乎

00:17:48.049 --> 00:17:52.759
关于我告诉它是什么类型的

00:17:50.809 --> 00:17:54.590
具有非常强大的类型的语言

00:17:52.759 --> 00:17:56.960
推断它可以找出

00:17:54.590 --> 00:17:58.519
类型非常聪明，我在这里

00:17:56.960 --> 00:18:00.619
试图告诉每个细节

00:17:58.519 --> 00:18:03.080
我正试图伤害自己， 

00:18:00.619 --> 00:18:05.450
如今我根本不放任何类型

00:18:03.080 --> 00:18:06.710
主要是当我编写Haskell代码时

00:18:05.450 --> 00:18:08.480
似乎不在乎，我们真的

00:18:06.710 --> 00:18:10.549
好朋友，现在不是这样

00:18:08.480 --> 00:18:12.639
我们开始就这么美丽

00:18:10.549 --> 00:18:15.169
关于这是语言实际上

00:18:12.639 --> 00:18:16.480
在这方面非常强大，但我想要

00:18:15.169 --> 00:18:19.159
你想一件事

00:18:16.480 --> 00:18:20.749
默认值，这是一些语言

00:18:19.159 --> 00:18:23.059
纯粹是语言的基本权利

00:18:20.749 --> 00:18:25.129
有些语言可以保存

00:18:23.059 --> 00:18:28.820
默认值，然后有语言

00:18:25.129 --> 00:18:30.769
没有保存默认值，所以我真的

00:18:28.820 --> 00:18:33.499
花一点时间思考

00:18:30.769 --> 00:18:36.710
看像Haskell这样的语言

00:18:33.499 --> 00:18:38.539
如果您保存默认设置，那么一切都是纯净的

00:18:36.710 --> 00:18:41.299
想要使你有不纯净的东西

00:18:38.539 --> 00:18:44.029
求求你说一次

00:18:41.299 --> 00:18:46.220
请只在今天下午让我做

00:18:44.029 --> 00:18:48.350
这种不纯洁，Haskell会说不

00:18:46.220 --> 00:18:50.149
今天，就像真的真的真的

00:18:48.350 --> 00:18:52.129
很难使事情变得不正确

00:18:50.149 --> 00:18:54.799
必须加倍努力才能做到这一点

00:18:52.129 --> 00:18:58.190
知道Java之类的语言

00:18:54.799 --> 00:19:00.710
不安全主要是您想去Java和

00:18:58.190 --> 00:19:03.019
说我能不能使这个不变

00:19:00.710 --> 00:19:05.179
这次请这次，Java说

00:19:03.019 --> 00:19:07.249
好吧，我会考虑的，这是一个

00:19:05.179 --> 00:19:09.200
对面的完整办公室

00:19:07.249 --> 00:19:10.999
那里不是那里和那里

00:19:09.200 --> 00:19:13.039
一种语言可以强制执行的情况

00:19:10.999 --> 00:19:14.690
纯度有些事情我可以做

00:19:13.039 --> 00:19:16.759
只是给你一个例子

00:19:14.690 --> 00:19:19.279
只是为了分享我的兴奋

00:19:16.759 --> 00:19:21.830
见证人，说我有一个广告功能

00:19:19.279 --> 00:19:24.409
如果广告B是Haskell代码， 

00:19:21.830 --> 00:19:26.359
加B好治好这是很简单的

00:19:24.409 --> 00:19:29.119
例如加号B但有一些东西

00:19:26.359 --> 00:19:31.399
 Haskell知道像

00:19:29.119 --> 00:19:33.379
 Java永远不会知道，那就是

00:19:31.399 --> 00:19:35.749
 Haskell知道这是纯粹的

00:19:33.379 --> 00:19:37.940
功能，因为变量是不可变的

00:19:35.749 --> 00:19:39.950
默认情况下，在Haskell中，您不能

00:19:37.940 --> 00:19:41.960
更改它们，结果Haskell 

00:19:39.950 --> 00:19:44.029
知道这是一个纯函数，如果

00:19:41.960 --> 00:19:45.470
您在Java中编写相同的代码Java 

00:19:44.029 --> 00:19:46.669
说我天哪，我不知道你是什么

00:19:45.470 --> 00:19:48.529
在这些功能中我做不到

00:19:46.669 --> 00:19:49.609
在这一点上保证纯度

00:19:48.529 --> 00:19:50.239
改变其他地方B可能改变

00:19:49.609 --> 00:19:52.249
别处

00:19:50.239 --> 00:19:55.279
我可以保证，那么我

00:19:52.249 --> 00:19:57.519
在这种情况下要在这里说

00:19:55.279 --> 00:20:00.350
说我要说哦，让我们说评估

00:19:57.519 --> 00:20:01.290
价值再次等于价值，真是愚蠢

00:20:00.350 --> 00:20:03.180
愚蠢的例子

00:20:01.290 --> 00:20:05.010
那我要在这里说缅因州

00:20:03.180 --> 00:20:06.870
而在缅因州，当我要

00:20:05.010 --> 00:20:08.880
引入一些杂质，这是

00:20:06.870 --> 00:20:10.650
基本上是说嘿，我真的想要一个

00:20:08.880 --> 00:20:12.360
依次执行此代码

00:20:10.650 --> 00:20:13.980
我依赖订购的东西

00:20:12.360 --> 00:20:15.510
这样，在这种情况下，我要去

00:20:13.980 --> 00:20:17.580
前进去打印，然后我要

00:20:15.510 --> 00:20:19.770
说评估，然后我会通过

00:20:17.580 --> 00:20:21.900
通过它并添加一个和三个以及一个

00:20:19.770 --> 00:20:23.550
您可以看到一个非常简单的示例，但是

00:20:21.900 --> 00:20:24.270
当我运行此代码时，它会产生一个值

00:20:23.550 --> 00:20:27.030
共4 

00:20:24.270 --> 00:20:28.830
但是像Haskell这样的语言可以做到

00:20:27.030 --> 00:20:32.010
确实与众不同

00:20:28.830 --> 00:20:33.840
 Haskell的语言

00:20:32.010 --> 00:20:36.570
是两个独特的评估模型

00:20:33.840 --> 00:20:39.470
一种叫做正常秩序， 

00:20:36.570 --> 00:20:42.540
其他被称为适用令

00:20:39.470 --> 00:20:45.180
适用命令，在这种情况下

00:20:42.540 --> 00:20:47.100
 Java和我们大多数的语言

00:20:45.180 --> 00:20:49.320
曾经做过所谓的

00:20:47.100 --> 00:20:51.570
您知道这是真的

00:20:49.320 --> 00:20:53.640
有趣的是，我们称其为正常顺序，因为

00:20:51.570 --> 00:20:56.160
非常少见的语言

00:20:53.640 --> 00:20:59.010
实际上是在正常情况下做到这一点

00:20:56.160 --> 00:21:01.440
订单函数的计算不在

00:20:59.010 --> 00:21:02.940
您应用它们的顺序，如果您

00:21:01.440 --> 00:21:05.460
要在你的眼中看这个

00:21:02.940 --> 00:21:06.420
 Java程式，如果我问您何时会刊登广告

00:21:05.460 --> 00:21:07.890
叫做

00:21:06.420 --> 00:21:09.990
你告诉我广告将被称为

00:21:07.890 --> 00:21:11.460
马上，因为这将是

00:21:09.990 --> 00:21:12.960
立即被调用和广告的结果

00:21:11.460 --> 00:21:15.540
将要发送评估和

00:21:12.960 --> 00:21:18.360
结果评估将是Haskell 

00:21:15.540 --> 00:21:20.490
说没关系不会打广告

00:21:18.360 --> 00:21:22.020
你会怎么做与AD好天哪

00:21:20.490 --> 00:21:23.430
我要发送它来评估我

00:21:22.020 --> 00:21:24.900
我要去做评估

00:21:23.430 --> 00:21:25.770
发送打印好吗

00:21:24.900 --> 00:21:28.080
这样做的理由

00:21:25.770 --> 00:21:30.240
这绝对是懒惰吧，它

00:21:28.080 --> 00:21:33.600
推迟但可以推迟

00:21:30.240 --> 00:21:35.520
因为我只有一三个不会

00:21:33.600 --> 00:21:37.560
给你一百万的不同结果

00:21:35.520 --> 00:21:39.030
年，它是纯净的，这是其中之一

00:21:37.560 --> 00:21:40.380
纯函数的性质

00:21:39.030 --> 00:21:42.540
给你同样的结果

00:21:40.380 --> 00:21:44.760
每次您打电话时，我想

00:21:42.540 --> 00:21:47.370
向您证明这实际上不是

00:21:44.760 --> 00:21:48.270
会打给您知道的广告，直到您

00:21:47.370 --> 00:21:50.460
真的需要它

00:21:48.270 --> 00:21:52.650
我该如何证明

00:21:50.460 --> 00:21:54.270
如果我我经常做一份打印声明

00:21:52.650 --> 00:21:55.860
放一份Haskell的打印声明

00:21:54.270 --> 00:21:57.780
剁碎的恐惧真的是你

00:21:55.860 --> 00:21:59.730
试图做到这一点，所以我做不到

00:21:57.780 --> 00:22:01.470
没想到我会使用调试器

00:21:59.730 --> 00:22:03.630
证明一点，我感到很羞耻，所以

00:22:01.470 --> 00:22:05.520
在这种情况下，请原谅我这样做

00:22:03.630 --> 00:22:09.540
我要去这里住

00:22:05.520 --> 00:22:11.730
刚提出GHC我，这是一个如果

00:22:09.540 --> 00:22:13.410
我知道如何键入GHC，所以这是

00:22:11.730 --> 00:22:14.410
我要用于Haskell的repple 

00:22:13.410 --> 00:22:18.010
我要说

00:22:14.410 --> 00:22:19.600
在此处加载样本样本点HS和

00:22:18.010 --> 00:22:22.000
我要在这里蓝色加载此文件

00:22:19.600 --> 00:22:24.760
然后我要说休息我要放一个

00:22:22.000 --> 00:22:28.660
第一行字符上的断点

00:22:24.760 --> 00:22:30.280
 16号，所以我要说1和16 

00:22:28.660 --> 00:22:32.440
现在我设置了一个断点

00:22:30.280 --> 00:22:35.860
很好地调用主函数

00:22:32.440 --> 00:22:38.560
看到这里在线等着我

00:22:35.860 --> 00:22:40.990
字符11和15的数字1表示

00:22:38.560 --> 00:22:41.740
我要等待，谢谢

00:22:40.990 --> 00:22:44.230
你等待

00:22:41.740 --> 00:22:45.940
继续，她或它给了保留

00:22:44.230 --> 00:22:47.530
因为我并没有真正证明很多

00:22:45.940 --> 00:22:49.450
现在我很好，让我们回到

00:22:47.530 --> 00:22:52.660
这个，但我要回到这段代码

00:22:49.450 --> 00:22:55.390
并说出当您致电评估价值时

00:22:52.660 --> 00:22:57.610
等于我跑步时要返回42 

00:22:55.390 --> 00:22:59.050
代码注意到我在这冲浪42 

00:22:57.610 --> 00:23:01.210
 Haskell非常聪明

00:22:59.050 --> 00:23:04.090
 Haskell说您想做什么

00:23:01.210 --> 00:23:05.530
说Haskell电话加上它说为什么，因为

00:23:04.090 --> 00:23:07.780
评估结果合格的程度

00:23:05.530 --> 00:23:09.610
为什么，因为我要打印好

00:23:07.780 --> 00:23:12.010
让我们只打印评估结果

00:23:09.610 --> 00:23:14.410
它在运行时评估重新评估

00:23:12.010 --> 00:23:17.020
返回42个您从未关心的通知

00:23:14.410 --> 00:23:18.790
价值和Haskell说，天哪，我为什么

00:23:17.020 --> 00:23:20.590
浪费时间做没有的事情

00:23:18.790 --> 00:23:23.290
意思是我不必真的浪费我的

00:23:20.590 --> 00:23:25.780
时间让我们变得懒惰，但是懒惰变得

00:23:23.290 --> 00:23:27.760
纯粹，所以我要向你展示

00:23:25.780 --> 00:23:29.950
该广告从未被调用过，但是我们该如何

00:23:27.760 --> 00:23:31.360
证明广告从未被很好地调用过

00:23:29.950 --> 00:23:34.210
事实证明真的很容易

00:23:31.360 --> 00:23:37.030
毕竟因为如果我回到这里

00:23:34.210 --> 00:23:38.860
运行GHC我再次回去可以把

00:23:37.030 --> 00:23:41.410
在那条线上再断点一次

00:23:38.860 --> 00:23:43.510
但这一次它称为main方法

00:23:41.410 --> 00:23:44.980
在这种情况下当然抱歉

00:23:43.510 --> 00:23:47.830
我错过了出现，让我再试一次

00:23:44.980 --> 00:23:49.450
所以在这种情况下我当然要走了

00:23:47.830 --> 00:23:51.160
返回再试一次，让我们继续说

00:23:49.450 --> 00:23:54.340
再次加载文件，所以我要加载

00:23:51.160 --> 00:23:56.400
该文件让我们加载样本点HS 

00:23:54.340 --> 00:23:59.380
知道了，让我们在断点上

00:23:56.400 --> 00:24:01.600
 116我要调用主函数

00:23:59.380 --> 00:24:03.700
注意它从未停止过添加

00:24:01.600 --> 00:24:06.130
运作良好，真的

00:24:03.700 --> 00:24:08.410
何时可能发生的优化

00:24:06.130 --> 00:24:10.510
一种语言开始知道你是

00:24:08.410 --> 00:24:13.450
遵循功能纯正

00:24:10.510 --> 00:24:16.180
而且这很长一段路要走

00:24:13.450 --> 00:24:17.980
真的是我想要这样做的原因

00:24:16.180 --> 00:24:19.840
保持事物纯洁并遵循这些事物

00:24:17.980 --> 00:24:21.940
是因为我得到了更高的效率

00:24:19.840 --> 00:24:23.890
出来的，那真的是

00:24:21.940 --> 00:24:25.780
推动我前进的因素

00:24:23.890 --> 00:24:27.879
朝着那个井， 

00:24:25.780 --> 00:24:30.489
然后问是否功能正常

00:24:27.879 --> 00:24:33.129
纯度是如此重要

00:24:30.489 --> 00:24:35.709
我们能使那些事情发生吗

00:24:33.129 --> 00:24:37.539
你知道我在用Java编程吗

00:24:35.709 --> 00:24:39.519
必须加倍努力才能使这些

00:24:37.539 --> 00:24:42.039
之所以有效，是因为该语言可能无法

00:24:39.519 --> 00:24:43.809
一直在保护你

00:24:42.039 --> 00:24:45.190
你必须有相当好的代码

00:24:43.809 --> 00:24:46.869
评论您必须拥有其他工具

00:24:45.190 --> 00:24:48.819
检查您可能拥有的这些东西

00:24:46.869 --> 00:24:50.709
在以下方面做更多的工作

00:24:48.819 --> 00:24:52.419
确定这些事情，我们该如何去

00:24:50.709 --> 00:24:54.369
做好这件事之一

00:24:52.419 --> 00:24:57.669
我要你想的是当你

00:24:54.369 --> 00:25:00.099
编写尽可能多的函数

00:24:57.669 --> 00:25:02.949
这些功能纯净，所以这是

00:25:00.099 --> 00:25:05.409
你和我实际上可以做的一件事

00:25:02.949 --> 00:25:07.479
实际上我们可以帮助您做到的是

00:25:05.409 --> 00:25:08.949
保持功能相对简短一些

00:25:07.479 --> 00:25:11.949
人们倾向于非常写作

00:25:08.949 --> 00:25:14.319
长函数长方法长方法

00:25:11.949 --> 00:25:16.389
在几种方面是邪恶的， 

00:25:14.319 --> 00:25:18.369
长方法真的很难证明

00:25:16.389 --> 00:25:19.149
他们在做什么邪恶的事情

00:25:18.369 --> 00:25:21.099
引擎盖下

00:25:19.149 --> 00:25:22.989
所以你绝对想保留方法

00:25:21.099 --> 00:25:25.359
真的很短，所以更容易检查

00:25:22.989 --> 00:25:27.639
并表明我们也可以使用工具

00:25:25.359 --> 00:25:29.289
也可以验证纯度，但是

00:25:27.639 --> 00:25:31.599
当涉及到功能的纯净性时，我们

00:25:29.289 --> 00:25:33.759
必须真正实现纯洁，而我

00:25:31.599 --> 00:25:36.159
原因如此关键

00:25:33.759 --> 00:25:38.349
我提到的是因为你无法得到

00:25:36.159 --> 00:25:39.999
更好的性能而无需

00:25:38.349 --> 00:25:42.339
功能纯正，这就是为什么

00:25:39.999 --> 00:25:44.649
变得绝对关键，但从

00:25:42.339 --> 00:25:46.389
从实用角度来看如何

00:25:44.649 --> 00:25:48.039
实际做到这一点非常

00:25:46.389 --> 00:25:49.749
首先是当您编写方法时

00:25:48.039 --> 00:25:52.119
确保您使用的是这些方法

00:25:49.749 --> 00:25:54.909
尽量写一个纯我

00:25:52.119 --> 00:25:57.879
一个好的早晨开始工作，并且

00:25:54.909 --> 00:26:00.009
我的一个伙伴说，嘿，代码行得通

00:25:57.879 --> 00:26:02.799
顺序确实很好，但是花了很多

00:26:00.009 --> 00:26:04.329
运行时间我使它平行

00:26:02.799 --> 00:26:07.539
甚至不必告诉你

00:26:04.329 --> 00:26:09.789
结果是速度是多少

00:26:07.539 --> 00:26:11.049
结果是错误的，是的，但是

00:26:09.789 --> 00:26:12.699
结果是错误的，没关系

00:26:11.049 --> 00:26:14.979
很快，你得到了错误的结果，不是吗

00:26:12.699 --> 00:26:16.569
所以我立刻说你知道我

00:26:14.979 --> 00:26:18.249
还没有看过代码，但是我可以

00:26:16.569 --> 00:26:21.429
告诉你发生了什么事

00:26:18.249 --> 00:26:23.379
某个地方的变量，这是一个字段

00:26:21.429 --> 00:26:25.419
您的课程中，您正在调用方法， 

00:26:23.379 --> 00:26:26.829
该方法正在改变那个领域， 

00:26:25.419 --> 00:26:29.019
每个眼泪都有一个名字说，就是这样哈

00:26:26.829 --> 00:26:31.569
你的智慧就像是

00:26:29.019 --> 00:26:33.279
有趣的是去发现它，我们

00:26:31.569 --> 00:26:36.579
开始只是看代码

00:26:33.279 --> 00:26:39.249
并且肯定在30分钟后，我们发现

00:26:36.579 --> 00:26:41.410
正是那个小变量

00:26:39.249 --> 00:26:43.120
在这一功能中发生了变异

00:26:41.410 --> 00:26:44.860
大约一个小时来重构我们的代码

00:26:43.120 --> 00:26:46.810
运行它，我们得到的并行结果很多

00:26:44.860 --> 00:26:48.700
当然更快不正确，并且

00:26:46.810 --> 00:26:50.380
不变性真的很难

00:26:48.700 --> 00:26:53.200
使其平行也是如此

00:26:50.380 --> 00:26:55.450
评估和并行需要纯度

00:26:53.200 --> 00:26:57.610
如果是这样的话，功能很好

00:26:55.450 --> 00:27:00.190
我们如何真正实现这一目标

00:26:57.610 --> 00:27:02.290
实际上是在程序中

00:27:00.190 --> 00:27:05.350
来设计晶圆厂

00:27:02.290 --> 00:27:08.290
应用二尝试使用的口号

00:27:05.350 --> 00:27:10.900
一个纯净的圆圈，但

00:27:08.290 --> 00:27:13.900
周围的杂质，所以我的意思是

00:27:10.900 --> 00:27:16.000
通过那个我要绕一圈

00:27:13.900 --> 00:27:18.820
我要说的是

00:27:16.000 --> 00:27:20.800
圆圈将是纯净的，所以我会

00:27:18.820 --> 00:27:23.290
建立功能库，这些

00:27:20.800 --> 00:27:25.870
功能库将全部保证

00:27:23.290 --> 00:27:27.820
对我来说纯洁，当我在这里

00:27:25.870 --> 00:27:30.550
圈子内的函数库

00:27:27.820 --> 00:27:32.890
我不会改变那纯洁的圈子

00:27:30.550 --> 00:27:34.900
任何变量我都不会突变

00:27:32.890 --> 00:27:36.850
全局状态，我不会改变任何值

00:27:34.900 --> 00:27:39.400
给我，我不会谈

00:27:36.850 --> 00:27:40.930
并更改状态我接受输入

00:27:39.400 --> 00:27:43.510
返回我要的输出

00:27:40.930 --> 00:27:46.360
并围绕纯净的圈子我会

00:27:43.510 --> 00:27:49.240
建立一个非常细的杂质环

00:27:46.360 --> 00:27:51.250
臭臭的环是我的所在

00:27:49.240 --> 00:27:53.950
如果我想从数据库中读取

00:27:51.250 --> 00:27:55.900
我会记录日志，我可能会这样做

00:27:53.950 --> 00:27:57.610
与Web服务对话的示例

00:27:55.900 --> 00:28:00.310
我可以做的很多事情

00:27:57.610 --> 00:28:02.530
杂质，但是我抓到数据的那一刻

00:28:00.310 --> 00:28:04.390
我想和我一起工作

00:28:02.530 --> 00:28:04.990
一旦我进入

00:28:04.390 --> 00:28:07.000
纯度

00:28:04.990 --> 00:28:09.220
我不会变异任何东西，我会

00:28:07.000 --> 00:28:10.990
等到我退出纯洁的圈子

00:28:09.220 --> 00:28:13.180
然后一旦我走出

00:28:10.990 --> 00:28:15.220
纯粹，我可以再次开始变异

00:28:13.180 --> 00:28:17.860
因为实际上这种语言就像

00:28:15.220 --> 00:28:19.810
 Java没有这个概念嘿

00:28:17.860 --> 00:28:22.150
我们将真正强制您知道

00:28:19.810 --> 00:28:24.190
不变性为您，我们必须建立

00:28:22.150 --> 00:28:26.110
围绕着我们的局限性

00:28:24.190 --> 00:28:28.210
会有这样的语言，所以

00:28:26.110 --> 00:28:30.310
有那种纯洁的模型与

00:28:28.210 --> 00:28:31.720
纯度为一圈的杂质

00:28:30.310 --> 00:28:34.000
我不会真正导致的地方

00:28:31.720 --> 00:28:36.670
关于这个的任何不纯

00:28:34.000 --> 00:28:39.400
纯度也要小心

00:28:36.670 --> 00:28:41.950
只是不变异变量，而不是

00:28:39.400 --> 00:28:44.950
也要取决于将

00:28:41.950 --> 00:28:47.080
否则是易变的，这是一回事

00:28:44.950 --> 00:28:49.060
我们可以在这方面做

00:28:47.080 --> 00:28:51.670
我们都想关注一个主要问题

00:28:49.060 --> 00:28:54.220
作为程序员，那就是如果我要

00:28:51.670 --> 00:28:54.700
做不变性的一种方法

00:28:54.220 --> 00:28:58.000
静音

00:28:54.700 --> 00:29:00.700
我们过去经常复制对象，等等

00:28:58.000 --> 00:29:02.890
我要复制对象的分钟不是

00:29:00.700 --> 00:29:05.080
那会很傻，因为我们要

00:29:02.890 --> 00:29:06.670
最终带有大量物体

00:29:05.080 --> 00:29:08.740
在那将不是很好

00:29:06.670 --> 00:29:10.840
性能，那么我们如何真正

00:29:08.740 --> 00:29:12.640
说得好，这是我们可以享受的地方

00:29:10.840 --> 00:29:14.800
从一些我想称呼为

00:29:12.640 --> 00:29:16.600
例如功能数据结构

00:29:14.800 --> 00:29:18.760
如果你真的考虑清单，如果你

00:29:16.600 --> 00:29:21.550
将以Clojure等语言列出

00:29:18.760 --> 00:29:25.900
和Scala的列表是完全

00:29:21.550 --> 00:29:29.080
不可变，因此您无法修改列表

00:29:25.900 --> 00:29:31.320
一旦你创造了那么一成不变，但是当

00:29:29.080 --> 00:29:33.790
你看一个清单这些清单全部

00:29:31.320 --> 00:29:36.130
充分提供某些操作

00:29:33.790 --> 00:29:38.740
您可以在其中添加元素的头部

00:29:36.130 --> 00:29:40.660
好吧，这不是可变的，而是什么

00:29:38.740 --> 00:29:42.640
是否意味着您去时要增加好

00:29:40.660 --> 00:29:44.950
列表，然后添加以下示例

00:29:42.640 --> 00:29:47.650
 Scala代码（如果有列表） 

00:29:44.950 --> 00:29:50.440
说一二三

00:29:47.650 --> 00:29:53.380
因为val list等于现在，您可以

00:29:50.440 --> 00:29:55.570
只需说零，然后您就可以

00:29:53.380 --> 00:29:57.490
列出它，这可以说

00:29:55.570 --> 00:30:00.760
列出你从中得到的两个

00:29:57.490 --> 00:30:03.280
好清单一是不可变的清单二是一

00:30:00.760 --> 00:30:05.410
复制您从给定列表中获得的内容

00:30:03.280 --> 00:30:07.420
结果，他们实际上做了什么

00:30:05.410 --> 00:30:09.430
这样做是一种非常有趣的方式

00:30:07.420 --> 00:30:11.110
想想这是如何运作的

00:30:09.430 --> 00:30:13.180
前排的人员列表

00:30:11.110 --> 00:30:15.580
想象清单是一成不变的，我不能

00:30:13.180 --> 00:30:17.740
改变那个清单我可以走到哪里

00:30:15.580 --> 00:30:19.810
列表的最前面并声明自己

00:30:17.740 --> 00:30:21.340
作为列表中的第一个人

00:30:19.810 --> 00:30:23.620
尊重他们对此无能为力

00:30:21.340 --> 00:30:26.260
我之所以这样，是因为清单是

00:30:23.620 --> 00:30:28.180
一成不变，我可以宣称自己是

00:30:26.260 --> 00:30:30.430
列表中的第一人称，如果您问

00:30:28.180 --> 00:30:31.810
那边的绅士有多少人

00:30:30.430 --> 00:30:33.610
在您的清单中，他可能会说

00:30:31.810 --> 00:30:35.860
我的名单上有五个人，但是如果你

00:30:33.610 --> 00:30:37.570
问我，我会说我有六个人

00:30:35.860 --> 00:30:39.640
列出，因为我很乐意

00:30:37.570 --> 00:30:41.740
分享那里的清单，那是

00:30:39.640 --> 00:30:44.320
这些语言到底是什么

00:30:41.740 --> 00:30:45.040
共享现有数据，因为该数据是

00:30:44.320 --> 00:30:47.380
一成不变的

00:30:45.040 --> 00:30:49.030
他们可以有效地做到这一点，但是

00:30:47.380 --> 00:30:51.070
当然，您要添加到头部和

00:30:49.030 --> 00:30:53.470
可能从头部移到

00:30:51.070 --> 00:30:55.360
收集一个创建另一个列表，如果

00:30:53.470 --> 00:30:57.700
我一直在添加和删除

00:30:55.360 --> 00:31:00.550
头是什么样的数据结构

00:30:57.700 --> 00:31:02.590
好吧，这显然是很多东西

00:31:00.550 --> 00:31:05.620
基于堆栈的算法非常适合

00:31:02.590 --> 00:31:07.980
很好地进入了这个

00:31:05.620 --> 00:31:10.020
你实际上可以做的就是使用

00:31:07.980 --> 00:31:12.690
像崔斯这样的结构绅士

00:31:10.020 --> 00:31:15.120
菲尔·巴格韦（Phil Bagwell）创造了这个

00:31:12.690 --> 00:31:17.340
具有非常大的数据结构

00:31:15.120 --> 00:31:19.350
分支因子和尝试

00:31:17.340 --> 00:31:20.970
本质上，这些被称为持久性

00:31:19.350 --> 00:31:23.190
数据结构，它被称为

00:31:20.970 --> 00:31:24.780
持久的，因为它们是不可变的

00:31:23.190 --> 00:31:27.799
你不会改变它两次

00:31:24.780 --> 00:31:30.480
本身不是一成不变的，但里奇

00:31:27.799 --> 00:31:32.190
提交附件并建议

00:31:30.480 --> 00:31:33.929
我们实际上可以利用它，但是

00:31:32.190 --> 00:31:37.380
由于非常重的分支因子

00:31:33.929 --> 00:31:40.610
进行变更的成本正在增加

00:31:37.380 --> 00:31:43.350
如果您愿意的话，副本很小

00:31:40.610 --> 00:31:45.720
 Ricky将此称为有效常数

00:31:43.350 --> 00:31:48.000
或者实际上是恒定不变的

00:31:45.720 --> 00:31:51.690
实际上是恒定的，因为它是有序的

00:31:48.000 --> 00:31:54.990
假设log n的顺序

00:31:51.690 --> 00:31:58.169
 log n，但在这种情况下n的对数为n 

00:31:54.990 --> 00:32:01.410
不是元素的数量n是

00:31:58.169 --> 00:32:02.970
级别数（如果您愿意） 

00:32:01.410 --> 00:32:05.340
当然，如果您有四个级别

00:32:02.970 --> 00:32:07.350
因为分支因子真的

00:32:05.340 --> 00:32:09.179
一个巨大的分支因素是什么时候可以

00:32:07.350 --> 00:32:10.770
有很多儿童尝试

00:32:09.179 --> 00:32:13.440
通常有32个或更多的孩子

00:32:10.770 --> 00:32:15.750
在四个级别内，您可以按字面意思

00:32:13.440 --> 00:32:17.669
打包了超过一百万个元素

00:32:15.750 --> 00:32:19.770
复制该特定的百万

00:32:17.669 --> 00:32:22.530
您要去的元素集合

00:32:19.770 --> 00:32:24.510
花一个订单四的日志是

00:32:22.530 --> 00:32:27.150
几乎是恒定的，我跑了一些

00:32:24.510 --> 00:32:29.130
这个例子我带了矢量

00:32:27.150 --> 00:32:31.650
在斯卡拉，这是一个价格

00:32:29.130 --> 00:32:33.780
实现从Java内部运行

00:32:31.650 --> 00:32:36.030
我发现了十万

00:32:33.780 --> 00:32:37.410
元素创建一个新的成本

00:32:36.030 --> 00:32:39.840
我在其中更改了一些内容

00:32:37.410 --> 00:32:41.400
中间大概是33 33 

00:32:39.840 --> 00:32:43.500
十亿分之一秒

00:32:41.400 --> 00:32:45.419
因为我实际上已经运行了，但是可以

00:32:43.500 --> 00:32:47.580
真的非常快，所以我们可以

00:32:45.419 --> 00:32:48.870
开始使用其中一些想法，但如果

00:32:47.580 --> 00:32:51.179
你真的必须戳数据

00:32:48.870 --> 00:32:53.250
最终那是

00:32:51.179 --> 00:32:54.570
纯度是一圈杂质

00:32:53.250 --> 00:32:56.700
纯度环与环

00:32:54.570 --> 00:32:58.799
杂质可以真正有效地进入

00:32:56.700 --> 00:33:00.540
但是还有一个问题

00:32:58.799 --> 00:33:02.429
处理，我们必须考虑

00:33:00.540 --> 00:33:04.559
这个的函数式风格

00:33:02.429 --> 00:33:06.990
建议以声明方式思考

00:33:04.559 --> 00:33:08.429
首先，然后你现在说得很好

00:33:06.990 --> 00:33:10.140
我知道如何X是问题所在

00:33:08.429 --> 00:33:12.960
我要尝试写的单词

00:33:10.140 --> 00:33:15.059
 JDK有很多功能

00:33:12.960 --> 00:33:17.130
在那里可以帮助我们的方法

00:33:15.059 --> 00:33:18.390
 JDK中有很多方法，我们

00:33:17.130 --> 00:33:20.220
可以用来做这些

00:33:18.390 --> 00:33:21.159
您可以进行转换

00:33:20.220 --> 00:33:23.409
收集在

00:33:21.159 --> 00:33:24.729
从内存中可以获取文件内容

00:33:23.409 --> 00:33:26.590
您可以开始遍历它们

00:33:24.729 --> 00:33:27.639
你知道功能性的风格

00:33:26.590 --> 00:33:29.109
你有很多不同的事情

00:33:27.639 --> 00:33:30.639
可以做到的函数式风格

00:33:29.109 --> 00:33:32.919
编程以及开始写作时

00:33:30.639 --> 00:33:34.809
编码自己问这个问题我该怎么办

00:33:32.919 --> 00:33:36.849
用函数式风格表达

00:33:34.809 --> 00:33:40.269
我想讲的最后一件事是

00:33:36.849 --> 00:33:42.249
症结是例外

00:33:40.269 --> 00:33:44.349
我敢肯定我们很多人都感到那种痛苦

00:33:42.249 --> 00:33:46.929
对，所以当你去溪流

00:33:44.349 --> 00:33:48.220
例如，如果你去一个小溪，让我们说

00:33:46.929 --> 00:33:50.229
我们有一个流的集合

00:33:48.220 --> 00:33:51.070
数字，在这种情况下，我想

00:33:50.229 --> 00:33:52.659
尖叫

00:33:51.070 --> 00:33:55.299
操作，我们该怎么办

00:33:52.659 --> 00:33:57.609
数字飞镖流，我要

00:33:55.299 --> 00:34:00.009
给定元素执行映射操作

00:33:57.609 --> 00:34:01.869
转换元素，然后说

00:34:00.009 --> 00:34:03.700
我要说的是每个

00:34:01.869 --> 00:34:05.830
然后我将简单地打印出来

00:34:03.700 --> 00:34:08.230
赋予我的价值

00:34:05.830 --> 00:34:10.270
我将其打印出来的元素是什么

00:34:08.230 --> 00:34:12.669
真正要做的变换方法

00:34:10.270 --> 00:34:13.299
对我来说很不错

00:34:12.669 --> 00:34:16.149
方法

00:34:13.299 --> 00:34:18.129
如果变革要给我怎么办

00:34:16.149 --> 00:34:20.230
在这种情况下，请注意例外

00:34:18.129 --> 00:34:23.049
让我们从婴儿的脚步开始

00:34:20.230 --> 00:34:25.089
静态的说int转换需要一个

00:34:23.049 --> 00:34:28.359
数字和所有要做的事

00:34:25.089 --> 00:34:31.389
说只是简单地返回数字对

00:34:28.359 --> 00:34:33.129
现在，这是一个返回数字

00:34:31.389 --> 00:34:34.599
这将是一个计算

00:34:33.129 --> 00:34:37.179
我们不必担心的一些努力

00:34:34.599 --> 00:34:40.359
现在，但是如果我做某事怎么办

00:34:37.179 --> 00:34:44.049
像这样如果我最终会做的话

00:34:40.359 --> 00:34:47.679
假设数字等于o假设

00:34:44.049 --> 00:34:50.289
 7那我要说扔和新

00:34:47.679 --> 00:34:52.690
例外，我要扔些东西

00:34:50.289 --> 00:34:54.369
一个艺术例外，所以让我们说

00:34:52.690 --> 00:34:56.289
就像我们得到了一样，出了点问题

00:34:54.369 --> 00:34:58.480
我们系统中的异常，我

00:34:56.289 --> 00:35:00.490
会说错了是什么

00:34:58.480 --> 00:35:03.430
将会在这一点上发生

00:35:00.490 --> 00:35:05.410
是一个非常具体的检查异常

00:35:03.430 --> 00:35:07.839
你知道我想要什么名字

00:35:05.410 --> 00:35:10.180
为此提供Java 

00:35:07.839 --> 00:35:12.130
编译器给你一个错误，它说

00:35:10.180 --> 00:35:14.770
嘿，你不能从

00:35:12.130 --> 00:35:16.720
该代码，因为在第五行

00:35:14.770 --> 00:35:18.849
你必须说你在扔一个

00:35:16.720 --> 00:35:20.440
例外，这只会得到

00:35:18.849 --> 00:35:23.920
我们经历的时候更糟

00:35:20.440 --> 00:35:26.109
现在你说抛出异常现在是什么

00:35:23.920 --> 00:35:29.440
即将发生Java现在抱怨

00:35:26.109 --> 00:35:32.289
第14行结果很多

00:35:29.440 --> 00:35:34.330
这些方法不处理检查

00:35:32.289 --> 00:35:36.670
完全例外

00:35:34.330 --> 00:35:40.000
功能界面好吗

00:35:36.670 --> 00:35:42.850
根本没有功能

00:35:40.000 --> 00:35:46.410
功能接口谓词消费者

00:35:42.850 --> 00:35:49.600
供应商他们都不处理支票

00:35:46.410 --> 00:35:51.580
一方面你可以说天哪，他们

00:35:49.600 --> 00:35:53.350
没有处理检查的异常，但是

00:35:51.580 --> 00:35:54.760
实际上有一个很好的理由

00:35:53.350 --> 00:35:56.890
他们为什么不提供检查

00:35:54.760 --> 00:35:59.290
例外，因为这样做实际上是

00:35:56.890 --> 00:36:01.840
不是解决方案的一部分，而是解决方案的一部分

00:35:59.290 --> 00:36:04.420
更大的问题，我们该怎么办

00:36:01.840 --> 00:36:06.490
让我们再考虑一下

00:36:04.420 --> 00:36:09.190
如果我们不打算退一步

00:36:06.490 --> 00:36:11.440
说好吧，我真的要处理

00:36:09.190 --> 00:36:13.390
这是我们做什么，有些人会

00:36:11.440 --> 00:36:15.700
向您建议一个非常危险的解决方案

00:36:13.390 --> 00:36:18.520
在我看来，那就是进来

00:36:15.700 --> 00:36:21.040
在这里画出真正的例外

00:36:18.520 --> 00:36:22.990
发生了，你知道你可能不是

00:36:21.040 --> 00:36:24.310
一个抛出这个异常的人

00:36:22.990 --> 00:36:26.050
这种例外来自下层

00:36:24.310 --> 00:36:28.120
打电话给其他人时

00:36:26.050 --> 00:36:30.580
被检查掉的方法

00:36:28.120 --> 00:36:32.920
例外，你擅长什么，所以你

00:36:30.580 --> 00:36:34.750
大概拿了这个数字，你做了

00:36:32.920 --> 00:36:37.450
你叫另一个工作

00:36:34.750 --> 00:36:39.790
函数在这里计算

00:36:37.450 --> 00:36:41.770
计算功能，也许你通过了

00:36:39.790 --> 00:36:43.630
在它上面的数字和那吹

00:36:41.770 --> 00:36:45.130
例外，所以他们可能会建议你

00:36:43.630 --> 00:36:48.160
他们可能会说这样的话哦

00:36:45.130 --> 00:36:50.800
这是一个想法，尝试并抓住

00:36:48.160 --> 00:36:52.960
围绕它，然后抓住那个异常

00:36:50.800 --> 00:36:56.140
不管那个异常是什么，然后

00:36:52.960 --> 00:36:58.720
当然要在上面做一个包装

00:36:56.140 --> 00:37:00.490
运行时异常，他们甚至

00:36:58.720 --> 00:37:03.310
给你方便的方法来做到这一点

00:37:00.490 --> 00:37:05.170
然后将其包裹起来非常简单

00:37:03.310 --> 00:37:07.570
描述这个的方式称为

00:37:05.170 --> 00:37:09.970
好主意，那这为什么不好

00:37:07.570 --> 00:37:12.820
好主意，原因是我们不是真的

00:37:09.970 --> 00:37:14.320
解决问题，我们只是安静了

00:37:12.820 --> 00:37:15.910
编译器，如果您真的考虑过

00:37:14.320 --> 00:37:18.970
那就是我们在

00:37:15.910 --> 00:37:21.190
竞争对手说现在要安静

00:37:18.970 --> 00:37:23.710
编译器就像是，我很高兴我不会

00:37:21.190 --> 00:37:25.990
抱怨问题确实消失了

00:37:23.710 --> 00:37:28.330
编译器只是安静下来，这是一个

00:37:25.990 --> 00:37:31.090
灾难这是什么原因

00:37:28.330 --> 00:37:34.590
一场灾难，好好想想我们在哪里

00:37:31.090 --> 00:37:37.750
现在我们在功能管道中

00:37:34.590 --> 00:37:40.360
现在在功能管道中，您可能

00:37:37.750 --> 00:37:43.240
在这里过滤你可能有

00:37:40.360 --> 00:37:44.920
更多过滤器就在这里，您可能

00:37:43.240 --> 00:37:47.700
还有其他操作，例如

00:37:44.920 --> 00:37:50.310
哦，再说几张地图

00:37:47.700 --> 00:37:51.810
谁知道多少时间的操作

00:37:50.310 --> 00:37:54.390
该功能管道将要做

00:37:51.810 --> 00:37:56.700
好吧，这是一条正确的管道

00:37:54.390 --> 00:37:59.520
现在以及当您可视化管道时

00:37:56.700 --> 00:38:02.099
将此视为数据流

00:37:59.520 --> 00:38:05.250
从一个阶段到另一个阶段

00:38:02.099 --> 00:38:09.210
现在在这个管道中结束阶段

00:38:05.250 --> 00:38:11.940
如果其中一件事情炸毁了，你怎么办

00:38:09.210 --> 00:38:15.359
真的这样做例外的问题

00:38:11.940 --> 00:38:17.369
处理是异常处理oops your 

00:38:15.359 --> 00:38:19.589
调用堆栈，我要走了

00:38:17.369 --> 00:38:21.599
并说异常处理和

00:38:19.589 --> 00:38:24.510
编程的函数式风格不是

00:38:21.599 --> 00:38:26.670
正交或完全断开

00:38:24.510 --> 00:38:29.400
将它们混合在一起没有任何意义

00:38:26.670 --> 00:38:31.320
那上下文为什么这个问题让

00:38:29.400 --> 00:38:33.329
我给你一个非常愚蠢的例子

00:38:31.320 --> 00:38:36.180
想象你在开车

00:38:33.329 --> 00:38:38.900
高速公路，您大约两英里远

00:38:36.180 --> 00:38:41.160
从你的鸡蛋中，你轮胎漏气了

00:38:38.900 --> 00:38:43.170
我能告诉你的最坏的事是什么

00:38:41.160 --> 00:38:45.780
我要告诉你你有一个公寓

00:38:43.170 --> 00:38:48.000
轮胎现在在反向行驶中返回

00:38:45.780 --> 00:38:50.640
你从哪里来

00:38:48.000 --> 00:38:53.339
安全地向右驶出出口

00:38:50.640 --> 00:38:55.950
换句话说，你总是面对下游

00:38:53.339 --> 00:38:57.300
你永远不会上游，你不会尝试

00:38:55.950 --> 00:38:59.940
跳出不是

00:38:57.300 --> 00:39:01.950
安全，因此也可以将其视为流

00:38:59.940 --> 00:39:04.260
当你流过溪流时

00:39:01.950 --> 00:39:06.540
你不会从流中退出

00:39:04.260 --> 00:39:08.700
异常地，您仍然必须退出

00:39:06.540 --> 00:39:10.200
流在底部，所以当你有一个

00:39:08.700 --> 00:39:12.569
流向上游

00:39:10.200 --> 00:39:14.819
下游你如何处理

00:39:12.569 --> 00:39:17.790
好吧，问题是你如何处理

00:39:14.819 --> 00:39:20.970
用它与此在Java中让我说我

00:39:17.790 --> 00:39:23.520
我真的很喜欢流媒体

00:39:20.970 --> 00:39:25.770
流，我要告诉你我

00:39:23.520 --> 00:39:28.230
享受溪流，我爱它，我用完了

00:39:25.770 --> 00:39:31.730
时间，但这并不意味着它是完美的

00:39:28.230 --> 00:39:35.430
所以问一个问题

00:39:31.730 --> 00:39:38.250
处理异常他们处理异常

00:39:35.430 --> 00:39:40.800
有两个漂亮的词，他们被称为

00:39:38.250 --> 00:39:43.230
祝你好运，所以基本上没有

00:39:40.800 --> 00:39:45.240
回答其他语言确实提供的

00:39:43.230 --> 00:39:47.940
其他解决方案，但Java悄悄地说

00:39:45.240 --> 00:39:49.530
处理它，所以没有真正的好

00:39:47.940 --> 00:39:51.359
回答如何处理它，你如何

00:39:49.530 --> 00:39:53.670
如果你真的处理异常

00:39:51.359 --> 00:39:55.500
要好好处理就可以了

00:39:53.670 --> 00:39:57.480
艰难的方式，你可以应对

00:39:55.500 --> 00:39:58.440
其中之一的确是这样

00:39:57.480 --> 00:40:00.329
功能上的区别

00:39:58.440 --> 00:40:01.310
心态与命令式心态

00:40:00.329 --> 00:40:03.140
 Java 8流

00:40:01.310 --> 00:40:05.450
一件事不能给你一个很好的答案

00:40:03.140 --> 00:40:08.540
你可能会在这里做你

00:40:05.450 --> 00:40:09.890
可以很好地处理数据

00:40:08.540 --> 00:40:12.440
你真正想要做的是你想要

00:40:09.890 --> 00:40:14.330
对待异常或错误

00:40:12.440 --> 00:40:16.400
作为错误，您想将错误视为

00:40:14.330 --> 00:40:18.110
另一种形式的数据就是你

00:40:16.400 --> 00:40:20.120
真的想做的只是另一回事

00:40:18.110 --> 00:40:23.540
数据形式出现问题

00:40:20.120 --> 00:40:24.980
事情确实搞砸了，没关系

00:40:23.540 --> 00:40:27.080
你不想被拍打

00:40:24.980 --> 00:40:28.730
当出现问题时，请处理

00:40:27.080 --> 00:40:30.620
以一种非常文明的方式，我们该怎么办

00:40:28.730 --> 00:40:32.870
在这种情况下做得很好，我在流动

00:40:30.620 --> 00:40:35.420
通过这种处理数据， 

00:40:32.870 --> 00:40:38.390
这里出了点问题，所以我要

00:40:35.420 --> 00:40:40.460
去把它作为错误推下来，这样你就可以

00:40:38.390 --> 00:40:42.140
处理下游，所以在其他

00:40:40.460 --> 00:40:44.660
话，但你如何真正做到这一点

00:40:42.140 --> 00:40:47.240
遗憾的是，Java没有真正简单的方法

00:40:44.660 --> 00:40:49.910
在流API中执行此操作，因为如果我

00:40:47.240 --> 00:40:53.240
我把它很好地放在流API中

00:40:49.910 --> 00:40:55.970
现在创建一个我有一个结构

00:40:53.240 --> 00:40:57.860
数据，我有一个错误，我想

00:40:55.970 --> 00:40:59.540
压低它们，Java不太

00:40:57.860 --> 00:41:01.280
给我们这样的东西

00:40:59.540 --> 00:41:03.200
提供构造的其他语言

00:41:01.280 --> 00:41:05.420
处理这些类型的夫妇

00:41:03.200 --> 00:41:08.180
数据和错误，但是Java没有

00:41:05.420 --> 00:41:10.580
一个，所以我们也许可以寻找解决方案

00:41:08.180 --> 00:41:13.070
其他地方和我们可以的地方

00:41:10.580 --> 00:41:15.680
寻找解决方案在JavaScript中

00:41:13.070 --> 00:41:18.290
保证这正是你的

00:41:15.680 --> 00:41:20.000
 Java中可完成的期货也是如此

00:41:18.290 --> 00:41:22.070
因为毕竟在未来可以完成

00:41:20.000 --> 00:41:24.290
 Java只是承诺

00:41:22.070 --> 00:41:26.690
感觉如何，可完成的期货和

00:41:24.290 --> 00:41:29.450
许诺做的很好的期货和

00:41:26.690 --> 00:41:31.970
有数据时，诺言说得好

00:41:29.450 --> 00:41:34.190
将数据通过其他

00:41:31.970 --> 00:41:36.500
承诺和完成的话

00:41:34.190 --> 00:41:39.440
我要说的期货有两个

00:41:36.500 --> 00:41:42.860
渠道和他们拥有的两个渠道

00:41:39.440 --> 00:41:45.260
是一个数据通道，然后

00:41:42.860 --> 00:41:47.180
有所谓的错误通道

00:41:45.260 --> 00:41:50.150
我就是这样看的

00:41:47.180 --> 00:41:52.850
说这条管道马上

00:41:50.150 --> 00:41:54.380
有两个与您合作的渠道

00:41:52.850 --> 00:41:56.180
数据通道，您有一个错误

00:41:54.380 --> 00:41:57.920
频道，或者您可以说这是对的

00:41:56.180 --> 00:41:59.360
通道和左通道以及

00:41:57.920 --> 00:42:01.130
事情进展顺利

00:41:59.360 --> 00:42:03.140
你只是通过改变

00:42:01.130 --> 00:42:04.850
数据通道或右通道时

00:42:03.140 --> 00:42:07.340
事情真的很糟糕，你去错误

00:42:04.850 --> 00:42:10.220
频道，您可以通过

00:42:07.340 --> 00:42:12.560
构造可完成的期货和

00:42:10.220 --> 00:42:14.440
这两种类型都建立了承诺

00:42:12.560 --> 00:42:16.329
的频道数

00:42:14.440 --> 00:42:18.099
在我看来，更优雅

00:42:16.329 --> 00:42:19.780
处理它的更好方法，因为它

00:42:18.099 --> 00:42:21.730
促进我们应对的模式

00:42:19.780 --> 00:42:24.160
下游的东西，所以你给

00:42:21.730 --> 00:42:25.480
转换数据的机会，但是

00:42:24.160 --> 00:42:27.970
您也给了机会

00:42:25.480 --> 00:42:30.099
转换错误以及其中之一

00:42:27.970 --> 00:42:31.480
它的工作方式是

00:42:30.099 --> 00:42:33.220
进展顺利，您继续前进

00:42:31.480 --> 00:42:35.050
如果事情进展不顺利的话

00:42:33.220 --> 00:42:36.550
你来到左边而你

00:42:35.050 --> 00:42:38.410
处理异常，但如果您是

00:42:36.550 --> 00:42:40.119
能够处理错误，您可以返回

00:42:38.410 --> 00:42:42.400
在右侧，所以您可以真正

00:42:40.119 --> 00:42:43.990
从错误中恢复以及

00:42:42.400 --> 00:42:46.210
给您一个非常好的处理方式

00:42:43.990 --> 00:42:48.280
不幸的是，这并没有回答

00:42:46.210 --> 00:42:51.970
我们的问题，因为一个承诺

00:42:48.280 --> 00:42:54.579
从字面上看还是零，我们的

00:42:51.970 --> 00:42:56.050
数据，我们可完成的未来为零或

00:42:54.579 --> 00:42:57.430
通过完整的数据

00:42:56.050 --> 00:43:00.069
将来你可能会有一份数据

00:42:57.430 --> 00:43:02.380
通过我们的艺术，只有通过

00:43:00.069 --> 00:43:04.359
一个流，您有n条数据

00:43:02.380 --> 00:43:06.310
经过，所以你将有n件

00:43:04.359 --> 00:43:08.650
您无法通过的数据

00:43:06.310 --> 00:43:12.010
显然依靠诺言去做

00:43:08.650 --> 00:43:14.589
我们可以做到这一点吗？ 

00:43:12.010 --> 00:43:17.109
想法开始走一些路，所以

00:43:14.589 --> 00:43:19.569
可观察物是取决于什么的流量

00:43:17.109 --> 00:43:22.329
你正在使用观察者是真的

00:43:19.569 --> 00:43:24.010
有点像诺言，除了

00:43:22.329 --> 00:43:26.099
他们可能是0太多数据

00:43:24.010 --> 00:43:29.290
所以我最喜欢的一件事

00:43:26.099 --> 00:43:31.630
可观察到的是他们确实有数据

00:43:29.290 --> 00:43:33.520
渠道，就像我们在

00:43:31.630 --> 00:43:36.640
其他情况下他们有一个数据通道

00:43:33.520 --> 00:43:39.369
另外还有错误通道

00:43:36.640 --> 00:43:41.760
除此之外，他们还

00:43:39.369 --> 00:43:45.160
有第三个频道，这是我们的

00:43:41.760 --> 00:43:47.319
完成一个完整的渠道，因此

00:43:45.160 --> 00:43:49.030
完成的渠道是您通过它

00:43:47.319 --> 00:43:51.220
发送一条信息说我没有任何信息

00:43:49.030 --> 00:43:53.619
更多数据，以便您可以清理

00:43:51.220 --> 00:43:55.089
操作，但更重要的是

00:43:53.619 --> 00:43:57.369
这再次是数据通道错误

00:43:55.089 --> 00:44:00.339
通过承诺和渠道

00:43:57.369 --> 00:44:02.470
最多一个数据的可完成期货或

00:44:00.339 --> 00:44:05.470
通过一个错误

00:44:02.470 --> 00:44:07.599
另一方面可观察到的任何数字

00:44:05.470 --> 00:44:09.550
的数据可能会通过，当然，如果

00:44:07.599 --> 00:44:11.680
有什么地方出了错你的错误

00:44:09.550 --> 00:44:14.890
通道将携带错误，因此您

00:44:11.680 --> 00:44:17.740
将错误视为数据只是另一种形式

00:44:14.890 --> 00:44:19.450
数据，因此依赖其中一些

00:44:17.740 --> 00:44:22.630
结构为我们提供了机会

00:44:19.450 --> 00:44:24.730
在下游处理错误

00:44:22.630 --> 00:44:26.710
而不是试图通过打扰电话链

00:44:24.730 --> 00:44:26.910
引发异常，所以这是其中之一

00:44:26.710 --> 00:44:28.980
的

00:44:26.910 --> 00:44:31.380
我会真诚地思考

00:44:28.980 --> 00:44:33.599
以函数式风格进行编程是我们

00:44:31.380 --> 00:44:35.520
考虑一下我如何处理的策略

00:44:33.599 --> 00:44:38.700
有例外，因为从根本上

00:44:35.520 --> 00:44:40.260
抛出异常确实是一个问题

00:44:38.700 --> 00:44:41.520
在这个世界上毫无意义

00:44:40.260 --> 00:44:43.530
编程风格的功能

00:44:41.520 --> 00:44:45.539
真的想像对待错误一样

00:44:43.530 --> 00:44:47.010
这只是另一种数据形式

00:44:45.539 --> 00:44:49.109
只是想将其推向下游， 

00:44:47.010 --> 00:44:51.329
处理，所以这是地方之一

00:44:49.109 --> 00:44:53.819
我通常从流开始

00:44:51.329 --> 00:44:56.369
我的项目我喜欢串流，我用它

00:44:53.819 --> 00:44:58.260
但是当我的项目变成

00:44:56.369 --> 00:45:00.450
稍微复杂一点，我们必须

00:44:58.260 --> 00:45:02.730
处理相当复杂的

00:45:00.450 --> 00:45:04.410
我当时的例外与错误

00:45:02.730 --> 00:45:07.109
考虑真的看东西

00:45:04.410 --> 00:45:08.880
像可观察或可流动的，因为

00:45:07.109 --> 00:45:11.250
有一个更好的答案

00:45:08.880 --> 00:45:13.799
如何继续使用流程

00:45:11.250 --> 00:45:15.510
数据流，但数据可以

00:45:13.799 --> 00:45:17.190
流过下游，我们可以

00:45:15.510 --> 00:45:18.869
处理它，所以这是一个

00:45:17.190 --> 00:45:21.329
重新思考我们要如何处理

00:45:18.869 --> 00:45:23.430
例外，所以总结一下我们

00:45:21.329 --> 00:45:25.890
谈到功能

00:45:23.430 --> 00:45:27.510
编程语言的风格，例如

00:45:25.890 --> 00:45:29.039
 Java使我们能够编写代码

00:45:27.510 --> 00:45:31.230
 lambda，它们使我们能够

00:45:29.039 --> 00:45:34.289
写流，但这是真正的

00:45:31.230 --> 00:45:36.240
有趣的开始是因为我们不能只是走进去

00:45:34.289 --> 00:45:38.220
并从编程开始

00:45:36.240 --> 00:45:39.930
 Java之类的语言，因为有

00:45:38.220 --> 00:45:41.760
其他制约因素

00:45:39.930 --> 00:45:44.609
真的要非常小心

00:45:41.760 --> 00:45:46.470
不幸的是要记住

00:45:44.609 --> 00:45:48.329
我非常喜欢这份工作

00:45:46.470 --> 00:45:50.190
因为它给你的力量是

00:45:48.329 --> 00:45:52.079
无法保护所有人的语言

00:45:50.190 --> 00:45:55.020
与您打交道的方式

00:45:52.079 --> 00:45:56.430
在变量和可变性方面， 

00:45:55.020 --> 00:45:58.349
承担个人责任

00:45:56.430 --> 00:46:00.029
确保您尊重不变性

00:45:58.349 --> 00:46:01.920
您必须控制的地方

00:46:00.029 --> 00:46:03.630
这些东西，你还必须

00:46:01.920 --> 00:46:05.849
试图处理类似的事情

00:46:03.630 --> 00:46:08.010
设计中的例外

00:46:05.849 --> 00:46:09.329
系统和循环纯度以及

00:46:08.010 --> 00:46:11.279
杂质环可能会

00:46:09.329 --> 00:46:12.250
希望对您有所帮助

00:46:11.279 --> 00:46:17.469
谢谢

00:46:12.250 --> 00:46:17.469
 [掌声] 

