WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.180 --> 00:00:11.700
可以，但是Acquia你好

00:00:08.250 --> 00:00:14.760
好的，没错，欢迎谈谈

00:00:11.700 --> 00:00:17.840
关于java.util并发流是什么

00:00:14.760 --> 00:00:21.269
以前称为反应流和

00:00:17.840 --> 00:00:24.179
快速浏览一下

00:00:21.269 --> 00:00:28.800
实际上我做了一个硬币还是

00:00:24.179 --> 00:00:33.990
对我好吧，如果是你，那就是我

00:00:28.800 --> 00:00:36.420
回声好吧，所以说星期五，所以我的名字是

00:00:33.990 --> 00:00:40.520
卡门·斯基斯基我在微风中工作，所以

00:00:36.420 --> 00:00:43.800
 Scala背后的公司继续前进

00:00:40.520 --> 00:00:45.450
分布式微服务，基本上

00:00:43.800 --> 00:00:48.000
它也被称为编程语言

00:00:45.450 --> 00:00:51.120
但是我们所有的API眼睛都有Java API 

00:00:48.000 --> 00:00:55.800
我会谈一点，但不会太过

00:00:51.120 --> 00:00:58.260
很多，我也做了反应流TCK 

00:00:55.800 --> 00:01:00.570
所以你会看到什么反应流

00:00:58.260 --> 00:01:02.910
其实这不是你可以做的

00:01:00.570 --> 00:01:05.759
拿起并使用它只是一个

00:01:02.910 --> 00:01:07.710
标准，我们将讨论为什么

00:01:05.759 --> 00:01:11.400
您关心的是这样的标准， 

00:01:07.710 --> 00:01:13.920
它实际上是如何变得不同于

00:01:11.400 --> 00:01:17.400
我在其中做了很多社区工作

00:01:13.920 --> 00:01:20.070
波兰像极客一样参加1200会议

00:01:17.400 --> 00:01:22.770
每年都有人报告Java是一个小组

00:01:20.070 --> 00:01:24.750
我发现这很像卡里

00:01:22.770 --> 00:01:28.800
白皮书阅读俱乐部之类的东西

00:01:24.750 --> 00:01:30.990
无论如何，所以通常的问题

00:01:28.800 --> 00:01:34.020
没有听说过存档的会议

00:01:30.990 --> 00:01:36.810
我罐起来，我不会被冒犯

00:01:34.020 --> 00:01:37.260
好，谁听说过甚至使用过

00:01:36.810 --> 00:01:43.020
它

00:01:37.260 --> 00:01:45.440
哦，好吧，所以人们输了问题，所以

00:01:43.020 --> 00:01:47.880
谁听说过反应流

00:01:45.440 --> 00:01:50.520
好吧，所以你知道有关反应的问题，所以

00:01:47.880 --> 00:01:53.790
我们将看到我们可以跳过多少或如何

00:01:50.520 --> 00:01:56.010
不多，但比发生的更多

00:01:53.790 --> 00:01:57.810
我们做和分布式计算是的

00:01:56.010 --> 00:01:59.250
我们拥有ARCA流的方式

00:01:57.810 --> 00:02:01.080
实施是被动的

00:01:59.250 --> 00:02:04.140
通过HTTP自己实现实现

00:02:01.080 --> 00:02:08.310
到服务器，当然是分布式的

00:02:04.140 --> 00:02:10.860
如此简短的提醒人群

00:02:08.310 --> 00:02:13.610
不知道那是什么车

00:02:10.860 --> 00:02:15.230
工具集中有哪些工具

00:02:13.610 --> 00:02:16.790
我们几乎可以选择是否

00:02:15.230 --> 00:02:18.110
您只想使用我们的Parker 

00:02:16.790 --> 00:02:20.090
谈论我们的派克戴夫

00:02:18.110 --> 00:02:22.880
像整合的东西

00:02:20.090 --> 00:02:24.710
流权，这就是为什么它适合

00:02:22.880 --> 00:02:26.240
进入今天的话题，您可以选择

00:02:24.710 --> 00:02:30.500
不需要做演员或

00:02:26.240 --> 00:02:32.600
集群，反之亦然

00:02:30.500 --> 00:02:36.260
企业宣传的结束让我们来谈谈技术

00:02:32.600 --> 00:02:39.110
所以流可能是最

00:02:36.260 --> 00:02:41.720
现在重载条款

00:02:39.110 --> 00:02:44.390
即使没有流媒体

00:02:41.720 --> 00:02:46.940
人们称它为流媒体很好的例子

00:02:44.390 --> 00:02:49.730
将是火花流这是一种

00:02:46.940 --> 00:02:51.100
流引用-取消引用但

00:02:49.730 --> 00:02:53.420
实际上说的更多

00:02:51.100 --> 00:02:55.220
迷你批次，您会变得与众不同

00:02:53.420 --> 00:02:56.570
所有不同语言之间的语义

00:02:55.220 --> 00:02:59.060
声称他们的图书馆

00:02:56.570 --> 00:03:01.220
流媒体库，您可以获得更多

00:02:59.060 --> 00:03:04.940
决定诸如火花之类的导向性事物

00:03:01.220 --> 00:03:07.100
虚张声势然后你得到东西

00:03:04.940 --> 00:03:10.190
像反应堆流一样

00:03:07.100 --> 00:03:12.320
像输入流一样的水平

00:03:10.190 --> 00:03:14.870
有时人们要我比较

00:03:12.320 --> 00:03:17.240
我不知道火花的反应流

00:03:14.870 --> 00:03:19.580
正确播放该问题

00:03:17.240 --> 00:03:22.269
真的很有意义，因为

00:03:19.580 --> 00:03:25.790
你会比较过去吗

00:03:22.269 --> 00:03:26.989
比较Hadoop输入流不正确

00:03:25.790 --> 00:03:29.540
不太一样

00:03:26.989 --> 00:03:33.010
即使两个都差不多

00:03:29.540 --> 00:03:35.630
概念的东西什么都消失了，所以

00:03:33.010 --> 00:03:37.760
这是一些术语，然后

00:03:35.630 --> 00:03:40.220
我们将跳回过去看看

00:03:37.760 --> 00:03:42.350
一切都来自哪里，所以这是

00:03:40.220 --> 00:03:45.410
存档奇怪的术语，我们称之为

00:03:42.350 --> 00:03:49.430
事情比一些更具体

00:03:45.410 --> 00:03:50.930
同一级别的其他库

00:03:49.430 --> 00:03:53.269
例如我们的X Java 

00:03:50.930 --> 00:03:55.340
谈论可观察的价值和

00:03:53.269 --> 00:03:57.260
一切都是可观察的，我们

00:03:55.340 --> 00:03:59.090
流，我们有源流沉，它

00:03:57.260 --> 00:04:02.750
取决于多少输入和多少

00:03:59.090 --> 00:04:05.060
输出，所以有更多

00:04:02.750 --> 00:04:09.430
你的脸，但这是为了消耗数据

00:04:05.060 --> 00:04:11.930
或者这是用于转换数据等

00:04:09.430 --> 00:04:15.170
我们有一个同步的边界， 

00:04:11.930 --> 00:04:17.239
签证实际上是反应性的

00:04:15.170 --> 00:04:18.919
新学校的意义以及什么

00:04:17.239 --> 00:04:20.510
我们今天要谈的是

00:04:18.919 --> 00:04:23.390
这些之间的同步边界

00:04:20.510 --> 00:04:23.970
处理元素，每个都可以

00:04:23.390 --> 00:04:26.730
实际上

00:04:23.970 --> 00:04:29.430
不同的技术，所以它没有

00:04:26.730 --> 00:04:31.410
成为我们的约束和背压

00:04:29.430 --> 00:04:33.900
服务的两个主要特点

00:04:31.410 --> 00:04:35.790
反应流，它确实进行流量控制，因此

00:04:33.900 --> 00:04:38.940
它可以防止内存错误，例如

00:04:35.790 --> 00:04:40.380
那是一个很多种的标准

00:04:38.940 --> 00:04:42.900
库之间可以中断

00:04:40.380 --> 00:04:46.440
其他，但我想快一点

00:04:42.900 --> 00:04:48.450
再说第二

00:04:46.440 --> 00:04:51.780
现在地球上的重载单词

00:04:48.450 --> 00:04:54.330
对西点有反应

00:04:51.780 --> 00:04:56.490
我写了一本迷你书给

00:04:54.330 --> 00:05:00.510
澄清什么才是真正的反应性

00:04:56.490 --> 00:05:02.010
不仅是反应流

00:05:00.510 --> 00:05:04.650
很多人会希望你相信

00:05:02.010 --> 00:05:07.170
现在不止于此

00:05:04.650 --> 00:05:10.860
如果你还记得反应式宣言

00:05:07.170 --> 00:05:15.270
至少那是我们的想法

00:05:10.860 --> 00:05:17.280
关于它，为什么我们说好的客家人

00:05:15.270 --> 00:05:20.370
正确意味着我们认为这有点

00:05:17.280 --> 00:05:22.650
不仅仅是反应式编程，所以

00:05:20.370 --> 00:05:24.750
永远和平时期的Oryx Java akka流

00:05:22.650 --> 00:05:26.880
样式，这是一个不错的构建块，但是

00:05:24.750 --> 00:05:30.270
那不是我的全部故事，这无济于事

00:05:26.880 --> 00:05:32.610
您实现了我们所想到的最终目标

00:05:30.270 --> 00:05:35.460
胜利者发起了一个非常

00:05:32.610 --> 00:05:38.190
活跃的流事物还可以，所以反应灵敏

00:05:35.460 --> 00:05:41.910
应用程序绝对是当今的主题

00:05:38.190 --> 00:05:44.270
不说吸血鬼的事情，所以还有更多

00:05:41.910 --> 00:05:47.220
诸如此类的东西

00:05:44.270 --> 00:05:49.169
弹性并能够横向扩展

00:05:47.220 --> 00:05:51.750
或下降，这也是反应的一部分

00:05:49.169 --> 00:05:56.130
系统至少我们如何定义它

00:05:51.750 --> 00:05:58.080
粉丝和非常活跃的宣言，为什么

00:05:56.130 --> 00:06:00.060
我们实际上着手进行反应

00:05:58.080 --> 00:06:01.620
流，所以这里的人们提高了他们的

00:06:00.060 --> 00:06:05.550
手，但他们知道吸引人的溪流

00:06:01.620 --> 00:06:07.740
曾经是，但这是为什么呢

00:06:05.550 --> 00:06:12.510
进入我们的想法

00:06:07.740 --> 00:06:14.820
基本上在我们团队中，我们会

00:06:12.510 --> 00:06:17.250
有很多顾客进来

00:06:14.820 --> 00:06:19.650
我们，基本上是一个项目

00:06:17.250 --> 00:06:21.570
重写还是未开发的，他们想要

00:06:19.650 --> 00:06:23.790
使用一些反应技术，他们选择了

00:06:21.570 --> 00:06:25.770
曲线他们重写系统，或者他们

00:06:23.790 --> 00:06:26.160
编写一个新系统，它超级好

00:06:25.770 --> 00:06:28.260
很棒

00:06:26.160 --> 00:06:30.630
安德烈斯的交通像老板一样大骂人

00:06:28.260 --> 00:06:32.210
戴墨镜的每个人都很高兴

00:06:30.630 --> 00:06:33.810
他们把它用于负载测试

00:06:32.210 --> 00:06:35.770
一切安好

00:06:33.810 --> 00:06:38.530
他们把它投入生产

00:06:35.770 --> 00:06:39.220
与其他系统集成

00:06:38.530 --> 00:06:41.500
其他系统

00:06:39.220 --> 00:06:44.259
尚未现代化的东西

00:06:41.500 --> 00:06:46.349
只是或什至不在您的控制之下

00:06:44.259 --> 00:06:48.639
可能是第三方等

00:06:46.349 --> 00:06:52.479
他们中的一些人并不能真正解决这个问题

00:06:48.639 --> 00:06:55.389
你猛烈抨击他们的新交通就结束了

00:06:52.479 --> 00:06:58.659
像这样，所以它真的是由

00:06:55.389 --> 00:07:00.400
有需要但一方面还可以

00:06:58.659 --> 00:07:02.050
我们的API这么快，我们可以

00:07:00.400 --> 00:07:03.400
声称对人们哈看我们的车所以

00:07:02.050 --> 00:07:05.830
速度真快

00:07:03.400 --> 00:07:07.750
另一方面，我们要整合

00:07:05.830 --> 00:07:09.639
与地球其他地方很好

00:07:07.750 --> 00:07:11.979
我们不想继续粉碎其余的

00:07:09.639 --> 00:07:13.419
通过使他们超载而使公司

00:07:11.979 --> 00:07:15.789
因为我们可以先处理事情

00:07:13.419 --> 00:07:19.319
报仇其他系统，这就是

00:07:15.789 --> 00:07:21.159
流量控制等的主要需求

00:07:19.319 --> 00:07:23.259
特别是异步编程

00:07:21.159 --> 00:07:26.349
所以火箭火箭就是关于

00:07:23.259 --> 00:07:29.229
同步编程只是增加流程

00:07:26.349 --> 00:07:31.599
对事物的控制不如对事物的琐碎

00:07:29.229 --> 00:07:33.280
它在阻止应用程序中，因为

00:07:31.599 --> 00:07:34.990
在阻止应用程序中

00:07:33.280 --> 00:07:37.180
基本上会自动变慢

00:07:34.990 --> 00:07:39.460
下来，因为你一直阻塞到

00:07:37.180 --> 00:07:42.250
有人正确地处理了

00:07:39.460 --> 00:07:44.830
您可以保留的同步应用程序

00:07:42.250 --> 00:07:46.360
继续前进，即使

00:07:44.830 --> 00:07:49.889
事情还没有完成处理

00:07:46.360 --> 00:07:52.509
另一面，这是那种

00:07:49.889 --> 00:07:55.110
我们想要解决的迫切需求

00:07:52.509 --> 00:07:58.389
三年前

00:07:55.110 --> 00:08:00.460
如今，我们看到了一个有趣的模式

00:07:58.389 --> 00:08:02.169
我会拍一小腿罐

00:08:00.460 --> 00:08:04.659
稍有不同将解决

00:08:02.169 --> 00:08:08.469
对，我发现这很有趣

00:08:04.659 --> 00:08:10.810
因为我认为这两个要约

00:08:08.469 --> 00:08:12.729
那本书中的要约，他在推特上说

00:08:10.810 --> 00:08:16.120
一个不断提出的问题

00:08:12.729 --> 00:08:18.159
 Kafka Connect，那就是那种

00:08:16.120 --> 00:08:20.440
您想流失的系统

00:08:18.159 --> 00:08:23.139
从数据库导入Kafka或

00:08:20.440 --> 00:08:25.599
相反，许多下游系统没有

00:08:23.139 --> 00:08:26.949
听起来既规模又舒适

00:08:25.599 --> 00:08:29.949
熟悉的权利

00:08:26.949 --> 00:08:32.229
同一故事的新技术比其他新技术快

00:08:29.949 --> 00:08:34.959
其他系统仍然有价值的系统

00:08:32.229 --> 00:08:36.669
也许甚至可以赚钱

00:08:34.959 --> 00:08:38.709
系统甚至没有净赚钱，因为

00:08:36.669 --> 00:08:41.820
另一个作品，所以你知道这是一个

00:08:38.709 --> 00:08:44.340
有点难辩，如果

00:08:41.820 --> 00:08:47.070
你会离开，在这里我暗示

00:08:44.340 --> 00:08:48.390
它是一个口袋项目，你会

00:08:47.070 --> 00:08:50.040
基本上了解它的全部内容

00:08:48.390 --> 00:08:52.860
关于整合这些各种

00:08:50.040 --> 00:08:56.250
技术而不必锁定您

00:08:52.860 --> 00:08:58.020
或非常具体哦，是的，我们

00:08:56.250 --> 00:08:59.640
只喜欢这些技术，我们不

00:08:58.020 --> 00:09:03.990
就像那种技术

00:08:59.640 --> 00:09:05.850
相机，但我们会给您打底，所以这是

00:09:03.990 --> 00:09:08.850
我们想要的迫切需求

00:09:05.850 --> 00:09:13.590
地址反应极端开始三个左右

00:09:08.850 --> 00:09:15.180
多年前，所以我谈论的原因

00:09:13.590 --> 00:09:17.730
这些东西，你看到我在谈论

00:09:15.180 --> 00:09:19.860
它为TCK做过一系列

00:09:17.730 --> 00:09:21.990
测试会验证您是否确实

00:09:19.860 --> 00:09:25.140
正确实施它，您会看到

00:09:21.990 --> 00:09:27.480
为什么这实际上很重要，因为

00:09:25.140 --> 00:09:29.460
如今，它已成为JDK 9的一部分， 

00:09:27.480 --> 00:09:33.090
超级核心对此感到非常兴奋

00:09:29.460 --> 00:09:36.420
它包括暴力丑陋和刺戳

00:09:33.090 --> 00:09:38.760
 266所以更多的并发更新了很多

00:09:36.420 --> 00:09:41.430
这里非常有趣的事情之一

00:09:38.760 --> 00:09:43.920
他们基本上是反应流

00:09:41.430 --> 00:09:46.650
复制粘贴并彼此重命名

00:09:43.920 --> 00:09:48.630
并发流，但所有语义

00:09:46.650 --> 00:09:51.780
关于我们的行为的规则是

00:09:48.630 --> 00:09:55.620
记住，那是一种

00:09:51.780 --> 00:09:58.110
重要的一点，所以它是完全反应的

00:09:55.620 --> 00:10:00.240
流，但是好吧，这不是确切的

00:09:58.110 --> 00:10:02.220
类型，所以现在我们必须有一些

00:10:00.240 --> 00:10:04.530
图书馆将拥有的时间段

00:10:02.220 --> 00:10:06.930
支持这两个，因为我们想要

00:10:04.530 --> 00:10:09.690
建立一种生态系统来证明

00:10:06.930 --> 00:10:13.080
 Doug，如果Java生态系统

00:10:09.690 --> 00:10:15.630
好的，这很有价值，现在我们必须

00:10:13.080 --> 00:10:18.990
有点把所有这些都带到流

00:10:15.630 --> 00:10:20.850
界面应该很简单，所以如果

00:10:18.990 --> 00:10:23.670
你很好奇你已经可以了

00:10:20.850 --> 00:10:26.370
今天使用流接口和

00:10:23.670 --> 00:10:28.620
绝对是伟大的事情，我们支持

00:10:26.370 --> 00:10:31.680
 Annika已经发布了

00:10:28.620 --> 00:10:33.660
它的罐子可以与流整合

00:10:31.680 --> 00:10:35.280
界面，同时您可以

00:10:33.660 --> 00:10:37.140
仍与反应流集成

00:10:35.280 --> 00:10:38.640
接口，从技术上讲，这是一个

00:10:37.140 --> 00:10:40.920
重大更改，因为包重命名

00:10:38.640 --> 00:10:45.300
但实际上您不会感到任何痛苦

00:10:40.920 --> 00:10:48.450
因此，它更像是SPI， 

00:10:45.300 --> 00:10:49.990
我的意思是说

00:10:48.450 --> 00:10:51.580
整合的东西

00:10:49.990 --> 00:10:53.500
对，你有这些各种

00:10:51.580 --> 00:10:56.320
技术以及我们工作时

00:10:53.500 --> 00:10:59.680
溪流我们邀请了春季偷窥者或

00:10:56.320 --> 00:11:01.870
工程反应堆世界的伟大人物

00:10:59.680 --> 00:11:03.970
有点说：特定于生态系统

00:11:01.870 --> 00:11:05.920
当然是arocs Java项目

00:11:03.970 --> 00:11:08.440
本·克里斯蒂安森（Ben Christiansen）从

00:11:05.920 --> 00:11:10.570
从红帽开始

00:11:08.440 --> 00:11:13.899
顶点和所有这些不同的供应商

00:11:10.570 --> 00:11:16.000
但是可以解决相同的问题， 

00:11:13.899 --> 00:11:20.440
我们决定好吧，让我们在一起

00:11:16.000 --> 00:11:22.810
建立这个东西，然后我们都会

00:11:20.440 --> 00:11:25.000
受益而不是让所有人

00:11:22.810 --> 00:11:26.350
研究非常生态的系统，让我们建立一个

00:11:25.000 --> 00:11:33.310
更大的生态系统

00:11:26.350 --> 00:11:35.140
对所有人都有利，所以我想

00:11:33.310 --> 00:11:39.850
在这里快进一点河的历史

00:11:35.140 --> 00:11:42.459
但就像我说的2014年， 

00:11:39.850 --> 00:11:44.230
三个部分起到清醒作用

00:11:42.459 --> 00:11:47.080
框架已经介绍并返回

00:11:44.230 --> 00:11:52.120
使用中的压力API称为

00:11:47.080 --> 00:11:53.709
当时的条约是

00:11:52.120 --> 00:11:56.170
觉得好吧，也许那会解决

00:11:53.709 --> 00:11:58.990
实际上就是这样

00:11:56.170 --> 00:12:03.579
对于最终用户来说太复杂了

00:11:58.990 --> 00:12:06.130
很好用我们有一个很好的iolair但是

00:12:03.579 --> 00:12:08.200
这些api都不是一个很好的API 

00:12:06.130 --> 00:12:10.930
在克里斯坦森银行（Christensen）与之合作

00:12:08.200 --> 00:12:13.300
带到桌子上的是Oryx Java 

00:12:10.930 --> 00:12:15.399
一个很好的API，可以与我们一起使用

00:12:13.300 --> 00:12:17.649
建立在背压的概念上

00:12:15.399 --> 00:12:20.410
 Oryx Java最初没有的

00:12:17.649 --> 00:12:25.720
然后我们添加了某种

00:12:20.410 --> 00:12:28.600
无论如何都要一起工作，这是为了

00:12:25.720 --> 00:12:31.959
放心，如果您快速看一下，您

00:12:28.600 --> 00:12:33.490
可以想象它没有说话

00:12:31.959 --> 00:12:35.680
你在五秒钟之内

00:12:33.490 --> 00:12:37.149
这样做是为什么我们将其刮掉了

00:12:35.680 --> 00:12:39.790
会解决流量控制的问题

00:12:37.149 --> 00:12:42.370
和背压，但非常沙哑

00:12:39.790 --> 00:12:44.980
受到启发并且不太像本土人

00:12:42.370 --> 00:12:46.959
以Java作为角落开发人员，所以我们

00:12:44.980 --> 00:12:50.410
以及当这种互动时解雇

00:12:46.959 --> 00:12:53.250
开始确定我们的目标

00:12:50.410 --> 00:12:57.080
要解决已经谈论过

00:12:53.250 --> 00:13:01.010
最后，它包含在其中

00:12:57.080 --> 00:13:03.770
好的，那那给我们留下了什么

00:13:01.010 --> 00:13:07.640
这些接口给了我们

00:13:03.770 --> 00:13:08.360
目前在您可以使用的JDK中

00:13:07.640 --> 00:13:11.600
马上

00:13:08.360 --> 00:13:14.330
但我会要求您不要实施

00:13:11.600 --> 00:13:17.540
直接因为当你看着他们

00:13:14.330 --> 00:13:21.490
这基本上是七种方法

00:13:17.540 --> 00:13:24.620
界面看起来非常简单，但是

00:13:21.490 --> 00:13:26.720
并发的事情是它有很多

00:13:24.620 --> 00:13:30.910
何时和如何调用的含义

00:13:26.720 --> 00:13:33.260
正确的事情，这是实际的

00:13:30.910 --> 00:13:36.110
极端反应的复杂性

00:13:33.260 --> 00:13:40.490
我可以放大一些随机规则

00:13:36.110 --> 00:13:43.550
让我们尝试看看这不是

00:13:40.490 --> 00:13:44.990
有趣的不是作为一个问题

00:13:43.550 --> 00:13:46.340
必须准备接受非

00:13:44.990 --> 00:13:49.550
有或没有信号完整

00:13:46.340 --> 00:13:51.470
处理请求核心，以便我们可以

00:13:49.550 --> 00:13:54.110
用一个空字符串完成

00:13:51.470 --> 00:13:56.720
正确的例子似乎很明显，但是如果

00:13:54.110 --> 00:13:59.030
你是一种实现假设

00:13:56.720 --> 00:14:02.360
以前总是要提出要求

00:13:59.030 --> 00:14:02.660
一个完整的信号，你会

00:14:02.360 --> 00:14:05.060
错误

00:14:02.660 --> 00:14:08.410
因此，而不是直接实施

00:14:05.060 --> 00:14:11.000
我建议使用现有的库

00:14:08.410 --> 00:14:14.150
可以是我们的习俗可以是我们的任何一个

00:14:11.000 --> 00:14:18.290
 JDK附带的实现

00:14:14.150 --> 00:14:20.500
例子发布错了不是很好

00:14:18.290 --> 00:14:23.480
功能强大，但您可以开始使用它

00:14:20.500 --> 00:14:25.610
因此，让我们解释一下

00:14:23.480 --> 00:14:28.640
单张幻灯片实际上是协议

00:14:25.610 --> 00:14:32.020
不是很困难，我们选择了

00:14:28.640 --> 00:14:35.900
命名发布者和订阅者是一个

00:14:32.020 --> 00:14:38.690
那时的大命名辩论不是

00:14:35.900 --> 00:14:40.880
弹出来是我的问题

00:14:38.690 --> 00:14:43.250
您说发布时的当前名称

00:14:40.880 --> 00:14:45.800
或订阅者认为弹出框正确

00:14:43.250 --> 00:14:48.320
很有道理，但这特别是

00:14:45.800 --> 00:14:50.180
点对点协议

00:14:48.320 --> 00:14:53.300
使用此协议进行扇出操作

00:14:50.180 --> 00:14:56.150
但是当每次互动都会

00:14:53.300 --> 00:14:58.310
遵守这种规则

00:14:56.150 --> 00:15:00.950
互动它没有在集合上定义

00:14:58.310 --> 00:15:05.690
的订户是点对点的

00:15:00.950 --> 00:15:06.840
基础，因为我们旨在解决流程

00:15:05.690 --> 00:15:08.640
这里的控制机制

00:15:06.840 --> 00:15:12.230
而且显然是

00:15:08.640 --> 00:15:14.880
与它的目的同步

00:15:12.230 --> 00:15:18.110
通常你有某种缓冲

00:15:14.880 --> 00:15:21.690
在您的系统中绘制如下

00:15:18.110 --> 00:15:23.670
较小的形状，您正在处理一些

00:15:21.690 --> 00:15:26.070
消息同步发生了什么

00:15:23.670 --> 00:15:27.870
您仍然缓冲着某些东西， 

00:15:26.070 --> 00:15:30.870
您的缓冲区中有一些可用空间

00:15:27.870 --> 00:15:33.720
如果您认为自己没有缓冲， 

00:15:30.870 --> 00:15:37.350
无论如何在某处有缓冲，因为

00:15:33.720 --> 00:15:39.600
要么是网络，要么是I / O，要么

00:15:37.350 --> 00:15:42.420
在某个地方我们会有一些

00:15:39.600 --> 00:15:47.010
缓冲空间，然后同步

00:15:42.420 --> 00:15:50.280
系统，假设我们定义了

00:15:47.010 --> 00:15:52.110
谈论元素，所以与TCP不同，我们

00:15:50.280 --> 00:15:54.240
不要谈论好吧，给我这么多

00:15:52.110 --> 00:15:56.850
来自此无限blob流的字节

00:15:54.240 --> 00:15:58.770
我们谈论特定元素的数据

00:15:56.850 --> 00:16:02.030
可能有人会给我一个

00:15:58.770 --> 00:16:06.360
一个人给我三个人，所以这里一个

00:16:02.030 --> 00:16:10.440
绿色箭头表示我要三个

00:16:06.360 --> 00:16:13.680
我也可以说的元素

00:16:10.440 --> 00:16:16.320
准备最多接受三个

00:16:13.680 --> 00:16:18.030
正确的元素，因为您知道

00:16:16.320 --> 00:16:19.530
您的缓冲区空间，如果您认为可以， 

00:16:18.030 --> 00:16:23.730
给我三个要素，我不会吹

00:16:19.530 --> 00:16:26.510
上游和上游，因此发布商甚至

00:16:23.730 --> 00:16:29.760
虽然它可以更快，但永远不会

00:16:26.510 --> 00:16:32.520
发出更多的信号

00:16:29.760 --> 00:16:36.020
确认现在基本要求

00:16:32.520 --> 00:16:38.850
和要求加总的规则

00:16:36.020 --> 00:16:40.800
但基本上解决了一个简单的流程

00:16:38.850 --> 00:16:43.380
一些边缘情况下的控制问题

00:16:40.800 --> 00:16:45.360
围绕完成和取消错误

00:16:43.380 --> 00:16:48.420
处理，但这就是为什么我们有这个

00:16:45.360 --> 00:16:50.700
回来和TCK，就像我说的

00:16:48.420 --> 00:16:52.830
还没有，所以您不必等待

00:16:50.700 --> 00:16:56.220
很高兴我们能够

00:16:52.830 --> 00:16:58.560
证明它并不需要多

00:16:56.220 --> 00:17:00.810
如果有人

00:16:58.560 --> 00:17:05.040
考虑人们如何接受他的

00:17:00.810 --> 00:17:06.720
介绍新的API驾驶者的事情

00:17:05.040 --> 00:17:08.490
罐子不是那么有用

00:17:06.720 --> 00:17:09.340
我们希望改变

00:17:08.490 --> 00:17:11.590
实作

00:17:09.340 --> 00:17:13.960
例如，如果我们曾经使用过

00:17:11.590 --> 00:17:16.180
现在使用一些不安全的功能，我们可以

00:17:13.960 --> 00:17:18.910
继续使用其他替代方法，例如VAR 

00:17:16.180 --> 00:17:21.970
手动驱动器等，但用于引入新驱动器

00:17:18.910 --> 00:17:24.460
 API（如果您产生库或如果您

00:17:21.970 --> 00:17:25.300
使用不是工具的库

00:17:24.460 --> 00:17:27.610
可以帮助您

00:17:25.300 --> 00:17:33.490
特别是，这只是正常工作

00:17:27.610 --> 00:17:35.130
链接到我们的JDK 9类，所以

00:17:33.490 --> 00:17:37.600
实际上进行介绍并不起作用

00:17:35.130 --> 00:17:40.350
只是一个简单的例子

00:17:37.600 --> 00:17:43.480
可行的实现数量

00:17:40.350 --> 00:17:45.610
演示这些东西有点无聊

00:17:43.480 --> 00:17:50.080
并展示这些东西，因为它是可行的

00:17:45.610 --> 00:17:54.580
但这是一个功能，所以更多

00:17:50.080 --> 00:17:57.100
流，所以我们简要地看了一下

00:17:54.580 --> 00:17:59.440
图，但让我们看一下代码和

00:17:57.100 --> 00:18:01.390
他们在这里使用Java 

00:17:59.440 --> 00:18:04.450
将是Scala，但您使用API​​的通知

00:18:01.390 --> 00:18:06.340
看到非常非常相似，尤其是

00:18:04.450 --> 00:18:09.190
自Java以来​​的lambda和lambda支持

00:18:06.340 --> 00:18:12.970
 8它越来越相似

00:18:09.190 --> 00:18:16.510
如您所见，对此感到非常高兴

00:18:12.970 --> 00:18:18.880
我们有同步流程，所以流程就像一个

00:18:16.510 --> 00:18:21.250
基本起作用，如果您好奇

00:18:18.880 --> 00:18:24.250
关于为什么我们有自由类型

00:18:21.250 --> 00:18:27.100
流程中的参数以及

00:18:24.250 --> 00:18:30.940
来源基本上是因为我们发现

00:18:27.100 --> 00:18:32.680
很多时候你需要互动

00:18:30.940 --> 00:18:34.840
我们已经投资了REME，您很容易

00:18:32.680 --> 00:18:37.960
做一个流处理操作

00:18:34.840 --> 00:18:40.570
转发你减少你的事情，但

00:18:37.960 --> 00:18:43.390
很多时候您需要注入

00:18:40.570 --> 00:18:47.850
来自外界的一些控制或

00:18:43.390 --> 00:18:50.830
一些像

00:18:47.850 --> 00:18:52.750
像上帝一样，就像一个速率表或一个

00:18:50.830 --> 00:18:55.330
您想控制的欺诈者

00:18:52.750 --> 00:18:58.450
外面，所以我们有一个类型

00:18:55.330 --> 00:19:00.940
安全时尚，但每个阶段都能产生

00:18:58.450 --> 00:19:02.350
已经输入的某种价值

00:19:00.940 --> 00:19:04.780
你手里拿着它，你可以做

00:19:02.350 --> 00:19:10.030
东西，我们有一个特殊的类型

00:19:04.780 --> 00:19:12.130
类型称为未使用，但您可以更多

00:19:10.030 --> 00:19:15.130
很好地表达了，我没有使用

00:19:12.130 --> 00:19:16.420
这种类型的参数，而不是坚持

00:19:15.130 --> 00:19:18.250
到处都是空的

00:19:16.420 --> 00:19:21.850
这是我们不喜欢的东西

00:19:18.250 --> 00:19:24.700
和许多Java API，但是当您没有

00:19:21.850 --> 00:19:26.920
使用一个值就可以使用void upper 

00:19:24.700 --> 00:19:30.190
大写的void有点奇怪

00:19:26.920 --> 00:19:32.950
所以我们没有用，我们已经做了

00:19:30.190 --> 00:19:35.799
再次输入相同的东西不带任何东西

00:19:32.950 --> 00:19:38.290
意味着我们的货车，更易于阅读

00:19:35.799 --> 00:19:41.110
因此，如果您获得了完成的价值，那么信息流

00:19:38.290 --> 00:19:44.500
已经完成，与

00:19:41.110 --> 00:19:46.450
其他Recta流实现

00:19:44.500 --> 00:19:49.390
具有提升的代表性

00:19:46.450 --> 00:19:52.419
意味着到这个时候你有一个来源

00:19:49.390 --> 00:19:56.049
认为它还没有运行的流程

00:19:52.419 --> 00:19:58.840
仅在您运行它或我们如何调用时运行

00:19:56.049 --> 00:20:01.330
它实现了，这使我们能够做到

00:19:58.840 --> 00:20:03.549
一些有趣的合并

00:20:01.330 --> 00:20:08.020
将多个阶段合并为一个阶段

00:20:03.549 --> 00:20:11.200
具有更多的可配置性

00:20:08.020 --> 00:20:12.970
并没有取消实施，所以这里是

00:20:11.200 --> 00:20:16.090
一个实例化的例子

00:20:12.970 --> 00:20:18.700
值从沉头基本上是一个

00:20:16.090 --> 00:20:21.280
实现完成的接收器

00:20:18.700 --> 00:20:23.650
阶段谢谢你可以看到确定，所以重新运行

00:20:21.280 --> 00:20:25.390
有了这个水槽，它给了我们这个

00:20:23.650 --> 00:20:27.580
我所说的完成阶段

00:20:25.390 --> 00:20:30.309
关于这种与非

00:20:27.580 --> 00:20:32.110
流媒体世界非常重要， 

00:20:30.309 --> 00:20:35.110
这是我们编程的东西

00:20:32.110 --> 00:20:37.330
这样其他方式可以做到

00:20:35.110 --> 00:20:39.309
侧面设置有更多副作用

00:20:37.330 --> 00:20:44.290
我们认为还有一点

00:20:39.309 --> 00:20:46.059
清除您已经看到的内容

00:20:44.290 --> 00:20:50.370
源流汇，但您可以拥有

00:20:46.059 --> 00:20:54.070
任意多个端口，如果您希望这样

00:20:50.370 --> 00:20:55.450
那是我认为关于阿卡的最后一句话

00:20:54.070 --> 00:20:58.150
流我刚想去的门

00:20:55.450 --> 00:21:00.100
解释我们拥有的基本要素

00:20:58.150 --> 00:21:03.700
您从以下方面考虑

00:21:00.100 --> 00:21:05.910
下沉，流动和来源，因为

00:21:03.700 --> 00:21:09.070
反应流的整个未来

00:21:05.910 --> 00:21:12.700
进入并发流程

00:21:09.070 --> 00:21:14.770
提供积木可以，如果

00:21:12.700 --> 00:21:16.570
你有这些积木，你

00:21:14.770 --> 00:21:18.669
知道你没有被锁定

00:21:16.570 --> 00:21:21.669
单一实施，因为它们都

00:21:18.669 --> 00:21:24.250
内部，你可以开始考虑

00:21:21.669 --> 00:21:25.440
真正挑选和选择

00:21:24.250 --> 00:21:27.570
您的流媒体管道

00:21:25.440 --> 00:21:30.659
从这里的任何图书馆

00:21:27.570 --> 00:21:32.820
他们中的大多数正在慢慢转化为

00:21:30.659 --> 00:21:36.840
这些类型，所以我们有一个很好的成长

00:21:32.820 --> 00:21:40.860
生态系统，我们可以很好地封装

00:21:36.840 --> 00:21:42.840
他们，例如，如果您必须

00:21:40.860 --> 00:21:46.080
像这样解释蜜蜂是的

00:21:42.840 --> 00:21:48.179
你可以拥有某种流动

00:21:46.080 --> 00:21:49.889
卡夫卡处理器和行为

00:21:48.179 --> 00:21:51.750
那也许是从你的数据库

00:21:49.889 --> 00:21:54.149
不在乎这是一件蓝色的事， 

00:21:51.750 --> 00:21:57.750
在左手边这就是你的逻辑

00:21:54.149 --> 00:22:01.139
将是我们目前的应用

00:21:57.750 --> 00:22:03.570
术语流术语

00:22:01.139 --> 00:22:07.980
这是处理器合而为一的事情

00:22:03.570 --> 00:22:09.690
东西出来，你可以轻松地替换，但是

00:22:07.980 --> 00:22:12.090
例如，这有点

00:22:09.690 --> 00:22:14.070
一旦看到它就可以弯曲

00:22:12.090 --> 00:22:15.659
我没有的正常日常代码

00:22:14.070 --> 00:22:17.850
认为它是如此弯曲，所以我继续

00:22:15.659 --> 00:22:21.330
如图所示，您可以更换

00:22:17.850 --> 00:22:23.940
具有某种概念的功能

00:22:21.330 --> 00:22:26.340
具有独立来源的功能流程

00:22:23.940 --> 00:22:30.750
和下沉，实际上是非常非常

00:22:26.340 --> 00:22:33.360
有趣的测试或

00:22:30.750 --> 00:22:36.870
例如您要注入一些测试数据

00:22:33.360 --> 00:22:39.559
与您的来源，但接收器的一面是

00:22:36.870 --> 00:22:42.059
仍然是您的实际逻辑，而不是

00:22:39.559 --> 00:22:45.960
从您的实际逻辑中发出数据

00:22:42.059 --> 00:22:48.299
将其发送到一些断言收集器

00:22:45.960 --> 00:22:50.580
然后使用断言收集器

00:22:48.299 --> 00:22:52.289
只是把它插在一起有点不同

00:22:50.580 --> 00:22:54.240
而且您拥有强大的力量

00:22:52.289 --> 00:22:56.309
可组合性，无需更改

00:22:54.240 --> 00:22:58.320
你的实际逻辑，这一切都在尖叫

00:22:56.309 --> 00:23:03.000
仍然是因为我们有这种抽象

00:22:58.320 --> 00:23:04.980
如果我们现在可以这样做的话

00:23:03.000 --> 00:23:06.779
谈论积木这是

00:23:04.980 --> 00:23:11.429
现在我想谈谈我们的帕克

00:23:06.779 --> 00:23:14.370
我认为很重要的项目

00:23:11.429 --> 00:23:16.019
有点，因为我谈论好的图书馆

00:23:14.370 --> 00:23:20.220
打断，那很好

00:23:16.019 --> 00:23:22.019
当然，如果您可以放心

00:23:20.220 --> 00:23:25.919
你不会被锁在一个

00:23:22.019 --> 00:23:28.500
当然祈祷或其他任何事情

00:23:25.919 --> 00:23:31.590
特别是波尔卡，你不能

00:23:28.500 --> 00:23:34.379
只需使用所有的连接器

00:23:31.590 --> 00:23:35.160
流连接器，包括一些IBM 

00:23:34.379 --> 00:23:38.000
技术

00:23:35.160 --> 00:23:47.700
我们有时与服务器合作或

00:23:38.000 --> 00:23:49.950
一些我忘记了我们没有的名字

00:23:47.700 --> 00:23:51.450
作为免费的兼容API， 

00:23:49.950 --> 00:23:53.430
实际上很有趣，因为

00:23:51.450 --> 00:23:57.930
我们认为我们将不得不写一个

00:23:53.430 --> 00:24:01.290
像IBM这样的特定端点

00:23:57.930 --> 00:24:05.310
像API一样免费，但事实证明它们

00:24:01.290 --> 00:24:07.800
非常符合作为的免费API 

00:24:05.310 --> 00:24:09.750
亚马逊，所以实际上我们只是重复使用了

00:24:07.800 --> 00:24:12.020
将一个位文件塑造为免费连接器

00:24:09.750 --> 00:24:15.510
也可以使用我们的API和

00:24:12.020 --> 00:24:17.880
那很有趣，因为你不

00:24:15.510 --> 00:24:19.440
您只需要关注用户

00:24:17.880 --> 00:24:21.480
您的清单好吗，羊驼有我的

00:24:19.440 --> 00:24:23.250
您使用事物最喜欢的技术

00:24:21.480 --> 00:24:24.870
这是一个流连接器

00:24:23.250 --> 00:24:27.390
不管你喜欢什么技术

00:24:24.870 --> 00:24:29.280
公平，如果你不这样做， 

00:24:27.390 --> 00:24:31.920
这很简单，您可以构建它

00:24:29.280 --> 00:24:33.270
使用您想要的任何技术

00:24:31.920 --> 00:24:34.680
可以使用我们的汽车尖叫声

00:24:33.270 --> 00:24:37.460
强烈推荐，但您可以使用

00:24:34.680 --> 00:24:41.010
只要一切顺利就可以

00:24:37.460 --> 00:24:45.030
 TCK是完全流式传输且安全的

00:24:41.010 --> 00:24:47.310
适合这个生态系统的东西

00:24:45.030 --> 00:24:50.340
而不是超级竞争

00:24:47.310 --> 00:24:51.870
喜欢对我们非常激进

00:24:50.340 --> 00:24:54.450
为此有一个连接器

00:24:51.870 --> 00:24:56.880
我们投资的连接器

00:24:54.450 --> 00:24:59.580
在更有用的环境中，如果

00:24:56.880 --> 00:25:01.860
任何人都会产生像MongoDB这样的驱动程序来

00:24:59.580 --> 00:25:05.220
直立的极端，每个人都可以

00:25:01.860 --> 00:25:07.830
直接使用它以及它如何增长

00:25:05.220 --> 00:25:10.140
如果是在几个月前

00:25:07.830 --> 00:25:12.210
其中一些连接器的数量

00:25:10.140 --> 00:25:15.540
我们实施了其中的一些人

00:25:12.210 --> 00:25:18.660
在社区实施，这是

00:25:15.540 --> 00:25:21.720
今天甚至还不太合适，所以我

00:25:18.660 --> 00:25:23.670
必须使文本变小，所以我们

00:25:21.720 --> 00:25:28.470
有很多东西，包括lambda 

00:25:23.670 --> 00:25:30.300
 3sn是SQS，所以很多亚马逊东西

00:25:28.470 --> 00:25:32.310
 google api开关等效于

00:25:30.300 --> 00:25:35.430
供应商和东西，这是一个

00:25:32.310 --> 00:25:38.400
如果您喜欢的话，有趣的一点还可以

00:25:35.430 --> 00:25:41.730
抽象您使用客户端的方式

00:25:38.400 --> 00:25:44.880
我不知道的特定云库

00:25:41.730 --> 00:25:46.980
假设这个消息传递API然后

00:25:44.880 --> 00:25:50.850
如果需要，可以更轻松地将其换出

00:25:46.980 --> 00:25:53.130
再次，我们很乐意帮助您成为

00:25:50.850 --> 00:25:55.020
更灵活，可以选择

00:25:53.130 --> 00:25:57.600
你想要的云，因为这个月还好

00:25:55.020 --> 00:25:59.370
下个月我们在这里卖个好价钱哦

00:25:57.600 --> 00:26:05.040
我们降价了，让我们用冰

00:25:59.370 --> 00:26:07.740
 API总是与Express一起

00:26:05.040 --> 00:26:10.679
源，汇和流，您可以

00:26:07.740 --> 00:26:12.360
如果有水槽，总是可以

00:26:10.679 --> 00:26:13.830
从中获得订阅者（如果您有） 

00:26:12.360 --> 00:26:14.370
来源，您总是可以得到出版商

00:26:13.830 --> 00:26:18.299
从中

00:26:14.370 --> 00:26:20.100
再次完成并放下，让我们来看一下

00:26:18.299 --> 00:26:22.679
在一个例子中，我们将如何实际

00:26:20.100 --> 00:26:26.100
我们是否设想构建流媒体应用程序

00:26:22.679 --> 00:26:29.100
或更多集成实验室，因为

00:26:26.100 --> 00:26:30.720
人们说流媒体应用程序也是

00:26:29.100 --> 00:26:33.450
有点令人困惑，因为有时他们

00:26:30.720 --> 00:26:35.429
意味着数据密集型分析机

00:26:33.450 --> 00:26:40.140
学习繁重的管道，通常

00:26:35.429 --> 00:26:42.179
激发或激发技术

00:26:40.140 --> 00:26:43.919
他们是否拥有整个管道？ 

00:26:42.179 --> 00:26:48.059
他们开始流，他们与

00:26:43.919 --> 00:26:51.660
流指令流和流在这里

00:26:48.059 --> 00:26:53.790
真的更多是关于小型工作的

00:26:51.660 --> 00:26:56.070
必须做的，这将是很好，如果

00:26:53.790 --> 00:26:59.160
他们正在流式传输，我们不必

00:26:56.070 --> 00:27:00.270
有50个节点可以做到

00:26:59.160 --> 00:27:02.809
单节点，因为实际上

00:27:00.270 --> 00:27:07.890
有时更快，现在，如果您已经看到

00:27:02.809 --> 00:27:10.049
有一些善良的例子

00:27:07.890 --> 00:27:13.140
比较设置和包装

00:27:10.049 --> 00:27:15.360
 Hadoop中的问题设置和包装

00:27:13.140 --> 00:27:17.429
会更简单更快

00:27:15.360 --> 00:27:19.380
是的，我们希望成为企业级产品并使用

00:27:17.429 --> 00:27:22.320
做大事吧，也许你不会

00:27:19.380 --> 00:27:24.240
需要使用大物件，所以更多

00:27:22.320 --> 00:27:26.820
旁注，那么我将如何建造一个东西

00:27:24.240 --> 00:27:31.650
用我们的扑克，你只要选择我想要的

00:27:26.820 --> 00:27:35.160
我想使用-kafra流式传输是

00:27:31.650 --> 00:27:37.500
在这里包括依赖

00:27:35.160 --> 00:27:41.220
会包括好的HTTP只是因为我

00:27:37.500 --> 00:27:44.640
喜欢它，然后基本上你选择什么

00:27:41.220 --> 00:27:46.169
您想要正确的来源，所以我们有点

00:27:44.640 --> 00:27:48.750
用名字解释什么样的

00:27:46.169 --> 00:27:50.640
我们拥有的语义以及最多的来源和

00:27:48.750 --> 00:27:53.160
可提交的源代码，我们给您

00:27:50.640 --> 00:27:55.409
我这里的类型略有不同

00:27:53.160 --> 00:27:57.230
排一下他们，你可以看到

00:27:55.409 --> 00:28:00.060
您会获得消费者记录或

00:27:57.230 --> 00:28:02.970
可提交的消息，因此，如果认知

00:28:00.060 --> 00:28:05.340
留言一个你负责打

00:28:02.970 --> 00:28:09.120
提交每条消息，当我们做一个

00:28:05.340 --> 00:28:12.390
累积到给定的偏移量提交和

00:28:09.120 --> 00:28:14.700
正如我所说的，我们有这种外部控制

00:28:12.390 --> 00:28:17.400
您可以控制的参数

00:28:14.700 --> 00:28:20.280
运行流并获得指标

00:28:17.400 --> 00:28:25.290
它或停止它或暂停它之类的东西

00:28:20.280 --> 00:28:28.530
这样，您选择了其中一个，然后

00:28:25.290 --> 00:28:30.240
您基本上只需要，他们

00:28:28.530 --> 00:28:32.010
稍微弄乱了幻灯片，但基本上

00:28:30.240 --> 00:28:36.600
我们需要将一些源连接到

00:28:32.010 --> 00:28:39.480
基本上就这么简单

00:28:36.600 --> 00:28:41.820
并谐振整个流HTTP F 

00:28:39.480 --> 00:28:45.440
从卡夫卡出来，你只是选择一个来源

00:28:41.820 --> 00:28:48.990
因为墨水可以运行HTTP服务器

00:28:45.440 --> 00:28:51.300
所以这有点让人难以理解

00:28:48.990 --> 00:28:53.760
也许是因为三行好

00:28:51.300 --> 00:28:55.980
魔术，实际上不是

00:28:53.760 --> 00:28:57.750
魔术，这是非常无聊的技术

00:28:55.980 --> 00:28:59.840
连接，因为我们有相同的类型

00:28:57.750 --> 00:29:04.380
到处都是，因为他的

00:28:59.840 --> 00:29:07.590
低于低于低于涵盖

00:29:04.380 --> 00:29:09.990
这些不同的库之间，但

00:29:07.590 --> 00:29:12.330
一旦你意识到这就是我的方式

00:29:09.990 --> 00:29:18.090
可以把东西塞在一起，我认为是

00:29:12.330 --> 00:29:20.310
很好，称之为利润，然后你

00:29:18.090 --> 00:29:22.830
只需更改来源或同步即可

00:29:20.310 --> 00:29:27.660
成为FTP东西可以随心所欲

00:29:22.830 --> 00:29:31.640
只是为了工作训练，就像我说的

00:29:27.660 --> 00:29:33.750
这又是我们的帕克社区

00:29:31.640 --> 00:29:35.220
希望您不带代码使用它

00:29:33.750 --> 00:29:39.060
但您可以在此之前使用它

00:29:35.220 --> 00:29:43.350
你想要如此包容而持久

00:29:39.060 --> 00:29:47.880
人们不喜欢的东西

00:29:43.350 --> 00:29:50.970
经常想到的是一个HTTP服务器

00:29:47.880 --> 00:29:53.400
也可以制作流媒体我们该怎么办

00:29:50.970 --> 00:29:55.860
我们通过表达HTTP来做到这一点

00:29:53.400 --> 00:30:00.240
服务器和HTTP实体再次作为

00:29:55.860 --> 00:30:01.660
反应性流WebSockets以及等待

00:30:00.240 --> 00:30:04.340
片刻因为

00:30:01.660 --> 00:30:07.820
拍照很有趣

00:30:04.340 --> 00:30:11.690
这是更精确的

00:30:07.820 --> 00:30:14.450
建模HTTP以将服务器用作电话

00:30:11.690 --> 00:30:16.760
当服务器是一个功能，因为

00:30:14.450 --> 00:30:18.140
服务器作为一种功能隐含着

00:30:16.760 --> 00:30:20.810
一物一物

00:30:18.140 --> 00:30:23.480
嘿，处理器可以拥有一件事

00:30:20.810 --> 00:30:25.910
在很多事情上，以便建模

00:30:23.480 --> 00:30:27.920
 HTTP的服务器方法或您得到

00:30:25.910 --> 00:30:30.770
一个请求，您就开始推动

00:30:27.920 --> 00:30:34.160
资产马上就这么好副作用

00:30:30.770 --> 00:30:37.750
然后一直缓冲下去

00:30:34.160 --> 00:30:40.280
正如我所说，我们基本上会传播

00:30:37.750 --> 00:30:42.500
都推送所有数据

00:30:40.280 --> 00:30:44.780
反应性流一直到TCP 

00:30:42.500 --> 00:30:47.120
我们已经实施并且过度活跃

00:30:44.780 --> 00:30:49.070
图书馆，我们传播

00:30:47.120 --> 00:30:51.680
背压或操作系统的方式

00:30:49.070 --> 00:30:55.180
从TCP的窗口机制

00:30:51.680 --> 00:30:57.740
实际上是否拉更多推文

00:30:55.180 --> 00:30:59.420
从字面上看是否TCP正在恢复

00:30:57.740 --> 00:31:02.750
压力，因为有人在隧道里

00:30:59.420 --> 00:31:05.240
并且没有收到数据，我们将停止

00:31:02.750 --> 00:31:09.020
拉线，所以它也是从

00:31:05.240 --> 00:31:12.350
该网站再次很有趣

00:31:09.020 --> 00:31:15.980
许多核心代码是源重复

00:31:12.350 --> 00:31:18.380
没关系，HTTP细节还可以

00:31:15.980 --> 00:31:20.330
但这基本上是路径推文， 

00:31:18.380 --> 00:31:24.320
当您通过这些推文完成它时

00:31:20.330 --> 00:31:24.770
作为杰森一些样板，但不是太

00:31:24.320 --> 00:31:26.630
坏

00:31:24.770 --> 00:31:29.720
您开始为服务器，您已经完全

00:31:26.630 --> 00:31:32.380
我们停止的流HTTP服务器

00:31:29.720 --> 00:31:35.810
流数据到客户端

00:31:32.380 --> 00:31:37.940
基本上会发出这种新的推文负载

00:31:35.810 --> 00:31:39.380
对，这可能是一个繁重的操作

00:31:37.940 --> 00:31:41.540
这可能是从数据库中提取的，或者

00:31:39.380 --> 00:31:44.120
东西，所以它将停止调用

00:31:41.540 --> 00:31:48.950
如果没有需求，第一件事

00:31:44.120 --> 00:31:51.710
在用户的手机上非常酷

00:31:48.950 --> 00:31:55.520
跟我说的一样，在Scala中也是一样

00:31:51.710 --> 00:31:57.560
与API相当相似

00:31:55.520 --> 00:32:02.180
简洁但不要太多，因此您可以

00:31:57.560 --> 00:32:04.520
坚持任何您想要和采用的

00:32:02.180 --> 00:32:06.170
对，这东西实际上

00:32:04.520 --> 00:32:08.130
从大人物那里领养

00:32:06.170 --> 00:32:09.870
亚马逊的

00:32:08.130 --> 00:32:13.200
随着衰变的宣布，将会有一个

00:32:09.870 --> 00:32:14.940
基本上公开我们所有的图书馆

00:32:13.200 --> 00:32:18.240
与反应性流，并再次

00:32:14.940 --> 00:32:22.830
意味着它们将与JDK兼容

00:32:18.240 --> 00:32:25.290
类型，我们已经有一个非常令人兴奋的

00:32:22.830 --> 00:32:30.090
 JDK 10中的项目

00:32:25.290 --> 00:32:32.670
同步异步JDBC是

00:32:30.090 --> 00:32:34.980
似乎终于来了，当然

00:32:32.670 --> 00:32:38.160
他们将使用那些执行类型

00:32:34.980 --> 00:32:40.020
所以这是一个流订阅

00:32:38.160 --> 00:32:43.020
您将数据流式传输到

00:32:40.020 --> 00:32:46.320
数据库，这是我非常喜欢的东西

00:32:43.020 --> 00:32:49.440
感到兴奋，因为它有点

00:32:46.320 --> 00:32:51.240
长期以来，很多人都要求我

00:32:49.440 --> 00:32:53.940
有点害怕，因为我们想

00:32:51.240 --> 00:32:55.740
将其运送到9，这意味着

00:32:53.940 --> 00:32:57.900
意味着他们没有时间收养

00:32:55.740 --> 00:33:00.120
反应流的东西，这将是

00:32:57.900 --> 00:33:02.700
流的东西，而不是反应流

00:33:00.120 --> 00:33:04.350
我在JDK 10中的等待实际上是

00:33:02.700 --> 00:33:08.010
超级好时机

00:33:04.350 --> 00:33:12.750
 véra，所以他们可以使用一种现成的

00:33:08.010 --> 00:33:15.240
生态系统，就在其中

00:33:12.750 --> 00:33:18.540
更多关于akka的幻灯片以及如何

00:33:15.240 --> 00:33:21.750
那种复杂性和权力互动

00:33:18.540 --> 00:33:24.420
彼此之间基本上是我想要的

00:33:21.750 --> 00:33:27.240
就是不使用线程而已

00:33:24.420 --> 00:33:29.670
如果您考虑一下，直接锁定就可以了

00:33:27.240 --> 00:33:31.860
哦，我有这个并发问题， 

00:33:29.670 --> 00:33:34.950
然后您开始使用低级

00:33:31.860 --> 00:33:38.370
原语好吧可能是一个有趣的项目

00:33:34.950 --> 00:33:40.710
晚上，但不要把它放进去

00:33:38.370 --> 00:33:42.390
生产，因为当我们看到

00:33:40.710 --> 00:33:44.990
错误的事情和更好的工具

00:33:42.390 --> 00:33:49.860
对我来说，这是在做梦或行动

00:33:44.990 --> 00:33:52.350
嗯嗯

00:33:49.860 --> 00:33:54.210
我们显然有监控重点

00:33:52.350 --> 00:33:58.230
监控将是我们自定义的

00:33:54.210 --> 00:33:59.880
没有具体流动，但它正在

00:33:58.230 --> 00:34:02.040
准备绝对采用和生产

00:33:59.880 --> 00:34:04.770
因为在过去三年中

00:34:02.040 --> 00:34:06.480
看到被动流的大量采用

00:34:04.770 --> 00:34:09.270
知道它正在回升，我们已经看到了

00:34:06.480 --> 00:34:12.429
玩家采用了，所以这只是一个问题

00:34:09.270 --> 00:34:15.190
人们跳上JDK 9和

00:34:12.429 --> 00:34:17.409
在监狱里开心我们开会

00:34:15.190 --> 00:34:19.990
但更多地侧重于反应的方面

00:34:17.409 --> 00:34:22.210
事情，所以这不是一个猩红色的会议

00:34:19.990 --> 00:34:23.800
有时候人们问我是你

00:34:22.210 --> 00:34:26.679
知道某种相关的问我们

00:34:23.800 --> 00:34:28.540
生态系统是一种特别的反应

00:34:26.679 --> 00:34:30.700
建筑会议分为两个部分

00:34:28.540 --> 00:34:34.089
如果要打折，请从现在起数周

00:34:30.700 --> 00:34:37.389
他们你知道，是的，我所拥有的

00:34:34.089 --> 00:34:40.240
如果您有任何疑问，我不会

00:34:37.389 --> 00:34:44.409
确定我们如何准时我认为我们

00:34:40.240 --> 00:34:46.569
随着时间的流逝，但是你可以抓住我

00:34:44.409 --> 00:34:48.879
一些贴纸或乐于

00:34:46.569 --> 00:34:50.150
讨论或回答任何问题

00:34:48.879 --> 00:34:50.739
非常感谢

00:34:50.150 --> 00:34:51.679
 [掌声] 

00:34:50.739 --> 00:34:54.749
 [音乐] 

00:34:51.679 --> 00:34:54.749
 [掌声] 

