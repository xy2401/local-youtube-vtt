WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.180 --> 00:00:14.309
大家早上好

00:00:06.990 --> 00:00:18.500
这个演讲感谢您的光临

00:00:14.309 --> 00:00:18.500
切换到不起作用的地方

00:00:30.670 --> 00:00:36.430
是的，谢谢你

00:00:34.090 --> 00:00:39.720
好的，所以欢迎来到这里

00:00:36.430 --> 00:00:42.489
代码交谈谢谢您的光临

00:00:39.720 --> 00:00:44.890
这是关于lambda表达式的讨论

00:00:42.489 --> 00:00:47.050
释放您的lambda，实际上是重播

00:00:44.890 --> 00:00:49.269
我去年已经做过

00:00:47.050 --> 00:00:53.320
因此，如果您去年看过这个演讲， 

00:00:49.269 --> 00:00:56.019
与今年基本相同

00:00:53.320 --> 00:00:57.550
辅导课程，所以我们将开始

00:00:56.019 --> 00:00:59.800
在lambda的一开始

00:00:57.550 --> 00:01:02.949
表情我不认为你

00:00:59.800 --> 00:01:06.100
对编写lambda有任何了解

00:01:02.949 --> 00:01:13.390
谁从来没有写过lambda表达式

00:01:06.100 --> 00:01:15.759
 Java没问题，如果考虑的话

00:01:13.390 --> 00:01:20.170
作为经验丰富的Lambda表情表达自己

00:01:15.759 --> 00:01:23.950
作家对相同数量的东西还可以

00:01:20.170 --> 00:01:26.340
人们，所以我们将继续从

00:01:23.950 --> 00:01:29.170
并排，例如创建

00:01:26.340 --> 00:01:30.670
没有和我们不能写的模式

00:01:29.170 --> 00:01:33.399
他们看到这是真的表达

00:01:30.670 --> 00:01:35.500
这个话题的主题是关于

00:01:33.399 --> 00:01:37.540
 Lambda和函数式接口以及

00:01:35.500 --> 00:01:39.490
诸如此类的事情是不谈论

00:01:37.540 --> 00:01:42.369
流和字符，所以我不会

00:01:39.490 --> 00:01:44.170
我将使用所有涉及此主题的内容

00:01:42.369 --> 00:01:46.720
收集流中的数字和

00:01:44.170 --> 00:01:51.369
可用的文化

00:01:46.720 --> 00:01:52.960
前排座位，如果有的话

00:01:51.369 --> 00:01:58.350
旁边有可用的棍子吗

00:01:52.960 --> 00:02:01.570
举起你的手

00:01:58.350 --> 00:02:05.380
好吧，我叫乔西，我住在

00:02:01.570 --> 00:02:08.590
巴黎地区我在这里放了一些链接

00:02:05.380 --> 00:02:10.420
我的Twitter帐户github帐户

00:02:08.590 --> 00:02:12.100
两个名为stream的开源项目

00:02:10.420 --> 00:02:14.290
可能的职责和角色GT 

00:02:12.100 --> 00:02:15.940
检查您是否有兴趣，我也

00:02:14.290 --> 00:02:19.030
有我要发布的SlideShare帐户

00:02:15.940 --> 00:02:21.790
我的SlideShare帐户上的那些灯

00:02:19.030 --> 00:02:23.950
今晚还有一些内容

00:02:21.790 --> 00:02:29.940
我也是Java的github 

00:02:23.950 --> 00:02:29.940
冠军和Java工作明星音乐

00:02:31.829 --> 00:02:36.609
在我们开始之前，我要道歉

00:02:34.690 --> 00:02:40.239
因为从接下来的两个小时开始

00:02:36.609 --> 00:02:42.690
必须学习英语口语

00:02:40.239 --> 00:02:45.460
法国口音

00:02:42.690 --> 00:02:48.810
另一种可能是我说

00:02:45.460 --> 00:02:52.510
法语可能效果不大

00:02:48.810 --> 00:02:54.190
好吧，如果您有任何疑问要

00:02:52.510 --> 00:02:57.010
解决方案，你举起你的手，你喊

00:02:54.190 --> 00:02:59.530
你让自己听到，所以我可以

00:02:57.010 --> 00:03:00.970
听到你听到你，看看你是否

00:02:59.530 --> 00:03:02.710
否，或者如果您有疑问， 

00:03:00.970 --> 00:03:06.160
无论您可以使用此标签如何， 

00:03:02.710 --> 00:03:09.300
并尝试观看它对其进行监控，以便

00:03:06.160 --> 00:03:12.580
你我可以用Twitter回答你

00:03:09.300 --> 00:03:16.780
好吧，我们将从

00:03:12.580 --> 00:03:20.560
基本的东西第一个问题是什么

00:03:16.780 --> 00:03:25.690
这样做的代码很容易

00:03:20.560 --> 00:03:28.960
正确的一天，所以这基本上是一个比较

00:03:25.690 --> 00:03:31.540
表还可以的比较器，这是这个

00:03:28.960 --> 00:03:34.090
 Java 5代码对，我们可以这样写

00:03:31.540 --> 00:03:37.000
 2004年发布Java 5时编写的代码

00:03:34.090 --> 00:03:39.880
这基本上是一个编译器

00:03:37.000 --> 00:03:41.980
与使用姓氏I的人相比

00:03:39.880 --> 00:03:45.510
想对我可以使用的人进行排序

00:03:41.980 --> 00:03:48.610
这个比较器这是非常基本的东西

00:03:45.510 --> 00:03:57.330
您认为此代码是两个问题

00:03:48.610 --> 00:04:00.760
可读的，不是，我还不错

00:03:57.330 --> 00:04:04.410
不会说它可读性很强

00:04:00.760 --> 00:04:07.260
好的，我们实际上使用了此代码

00:04:04.410 --> 00:04:12.940
你会说这段代码很健壮吗

00:04:07.260 --> 00:04:14.620
它会崩溃吗，可以尝试如果p1是

00:04:12.940 --> 00:04:16.840
新知识姓氏是新的

00:04:14.620 --> 00:04:18.670
我不检查任何新的

00:04:16.840 --> 00:04:20.590
指针异常，所以您的指针

00:04:18.670 --> 00:04:24.370
可以使用这种方法引发异常

00:04:20.590 --> 00:04:28.240
好的代码让我们把它变成

00:04:24.370 --> 00:04:31.270
这个稍微复杂一点

00:04:28.240 --> 00:04:34.300
这基本上可以做得很好吗

00:04:31.270 --> 00:04:35.800
做同一件事比较两个

00:04:34.300 --> 00:04:37.990
人们使用姓氏，如果

00:04:35.800 --> 00:04:41.160
姓氏是相同的，它压缩了

00:04:37.990 --> 00:04:45.060
排序此人名单的名字

00:04:41.160 --> 00:04:50.979
如果我问自己这是代码

00:04:45.060 --> 00:04:52.750
可读性更好吗

00:04:50.979 --> 00:04:55.720
比上一个

00:04:52.750 --> 00:04:58.510
完全不是，它的治疗性可能较差

00:04:55.720 --> 00:05:01.060
为什么，因为我里面有一个if，我们会

00:04:58.510 --> 00:05:03.730
我想我们都知道声纳工具包

00:05:01.060 --> 00:05:06.310
这种循环复杂性

00:05:03.730 --> 00:05:08.680
现在计算出来，我们增加了

00:05:06.310 --> 00:05:11.680
该代码的圈复杂度

00:05:08.680 --> 00:05:15.010
所以是可读性，因为降低了一点

00:05:11.680 --> 00:05:18.730
以及鲁棒性，因为如果p1是

00:05:15.010 --> 00:05:21.070
新的获取姓氏返回新值

00:05:18.730 --> 00:05:23.050
名字就在新值上

00:05:21.070 --> 00:05:26.440
代码还将抛出一个空指针

00:05:23.050 --> 00:05:29.350
例外，那就是如果我想做到

00:05:26.440 --> 00:05:31.600
健壮的它将更加复杂， 

00:05:29.350 --> 00:05:34.720
可读性差得多，因为我将拥有

00:05:31.600 --> 00:05:38.470
所有这些技术代码以检查是否有新

00:05:34.720 --> 00:05:47.470
我的应用程序代码中的所有东西

00:05:38.470 --> 00:05:50.980
对，这段代码在做什么比较

00:05:47.470 --> 00:05:53.560
人们使用姓氏，然后使用

00:05:50.980 --> 00:05:55.150
名字，姓氏和

00:05:53.560 --> 00:05:58.380
名字是一样的，可以

00:05:55.150 --> 00:05:59.620
当然会比较使用年龄

00:05:58.380 --> 00:06:05.080
是的

00:05:59.620 --> 00:06:07.990
可读性不是很好吗

00:06:05.080 --> 00:06:09.669
对得多低，我会说

00:06:07.990 --> 00:06:12.460
这是那种代码，习惯了

00:06:09.669 --> 00:06:15.220
在应用程序中看到我们并不是真的

00:06:12.460 --> 00:06:18.430
我们需要逐行阅读它

00:06:15.220 --> 00:06:20.729
放眼全球，我们看到了

00:06:18.430 --> 00:06:24.940
了解它的作用，所以我们

00:06:20.729 --> 00:06:28.060
了解它是做什么的，它是

00:06:24.940 --> 00:06:31.360
既不那么健壮，顺便说一句

00:06:28.060 --> 00:06:34.570
因为我们不逐行阅读

00:06:31.360 --> 00:06:38.800
没有看到可能的问题

00:06:34.570 --> 00:06:41.290
潜入了这些代码是的，你

00:06:38.800 --> 00:06:46.240
检查真的我会修复代码

00:06:41.290 --> 00:06:48.010
哦，天哪，我正在比较最后一个

00:06:46.240 --> 00:06:49.570
网站的第一人的名字

00:06:48.010 --> 00:06:51.550
与第二件事的第一件事

00:06:49.570 --> 00:06:54.280
您看到了一个，但是又显示了一次

00:06:51.550 --> 00:06:56.530
对，因为我们有某种

00:06:54.280 --> 00:06:59.710
自动读取此代码，我们不

00:06:56.530 --> 00:07:03.220
我们给藏匿偷偷摸摸的虫子的地方

00:06:59.710 --> 00:07:05.830
在此代码中存在一个错误

00:07:03.220 --> 00:07:08.440
我们也许有人

00:07:05.830 --> 00:07:11.919
你们中有些人起初没有看到

00:07:08.440 --> 00:07:14.650
最好有一个很好的单元测试用例

00:07:11.919 --> 00:07:16.000
修复此代码好大看这个

00:07:14.650 --> 00:07:18.759
 bug，因为您需要两个人

00:07:16.000 --> 00:07:21.849
具有相同的姓氏和姓氏

00:07:18.759 --> 00:07:23.319
第一人称名字必须小写

00:07:21.849 --> 00:07:26.440
比第一件事更重要

00:07:23.319 --> 00:07:28.569
看这个的人，所以这通常是

00:07:26.440 --> 00:07:30.759
会变成什么样的错误

00:07:28.569 --> 00:07:33.669
您的生产代码（如果您只是

00:07:30.759 --> 00:07:35.979
排序学生或学生的清单，或

00:07:33.669 --> 00:07:39.699
教室里的学生可能还可以

00:07:35.979 --> 00:07:41.680
但是如果您要吸引1的获胜者

00:07:39.699 --> 00:07:44.680
百万的价格和某种损失

00:07:41.680 --> 00:07:46.360
如果这样做就可能有麻烦，所以

00:07:44.680 --> 00:07:48.639
这个比较器的问题在这里我

00:07:46.360 --> 00:07:51.699
我真的想解决一个非常

00:07:48.639 --> 00:07:54.430
我需要的简单而非常经典的问题

00:07:51.699 --> 00:07:56.919
使用最后一个排序人名单

00:07:54.430 --> 00:07:59.259
命名他们的名字和年龄，以及

00:07:56.919 --> 00:08:02.650
每次我在此添加条件

00:07:59.259 --> 00:08:04.780
在这个比较中，我增加了

00:08:02.650 --> 00:08:07.840
圈复杂度降低了

00:08:04.780 --> 00:08:10.060
健壮性，我的糟糕透顶

00:08:07.840 --> 00:08:12.789
如果有的话很难修复的代码

00:08:10.060 --> 00:08:15.219
是其中的错误，所以这正是我

00:08:12.789 --> 00:08:16.810
不想做，这就是我们

00:08:15.219 --> 00:08:18.669
将使用lambda解决

00:08:16.810 --> 00:08:21.159
表达式和模式与

00:08:18.669 --> 00:08:23.860
默认的beta系统基本上是代码

00:08:21.159 --> 00:08:26.139
我们要写的是这个

00:08:23.860 --> 00:08:28.840
做与...完全相同的事情

00:08:26.139 --> 00:08:31.270
上一个不同的是，如果我

00:08:28.840 --> 00:08:34.899
通过我的比较器我添加标准

00:08:31.270 --> 00:08:38.079
只会添加方法调用，所以我不

00:08:34.899 --> 00:08:41.050
增加了苏格拉底式的复杂性

00:08:38.079 --> 00:08:42.880
代码将使我的竞争对手

00:08:41.050 --> 00:08:44.260
强大的所有代码

00:08:42.880 --> 00:08:48.490
检查空指针异常并

00:08:44.260 --> 00:08:51.070
东西被推送到API代码中不

00:08:48.490 --> 00:08:53.949
我的应用程序代码中泄漏，所以它确实

00:08:51.070 --> 00:08:58.690
不要让我的应用程序代码任何

00:08:53.949 --> 00:09:00.790
更复杂吧，让我们来

00:08:58.690 --> 00:09:03.010
仔细看比较器

00:09:00.790 --> 00:09:05.230
我们要做的是对

00:09:03.010 --> 00:09:07.420
的字符串列表中的字符串

00:09:05.230 --> 00:09:09.850
角色，以便我们可以创建一个

00:09:07.420 --> 00:09:12.370
字符串的比较器在这里我正在排序我的

00:09:09.850 --> 00:09:14.290
字符串使用其长度而不是

00:09:12.370 --> 00:09:17.620
字母顺序的人

00:09:14.290 --> 00:09:19.560
自然顺序好，所以我可以创建一个

00:09:17.620 --> 00:09:22.170
战斗，所以这是Java 

00:09:19.560 --> 00:09:25.380
五种必须用Java 7编写的方式

00:09:22.170 --> 00:09:28.500
我该怎么做比较器

00:09:25.380 --> 00:09:30.630
简而言之，我想做的是

00:09:28.500 --> 00:09:33.180
将此比较器传递给盐方法

00:09:30.630 --> 00:09:36.089
所以我在JDK数组中有两个点

00:09:33.180 --> 00:09:38.490
排序和更正

00:09:36.089 --> 00:09:42.420
排序方法将使用此

00:09:38.490 --> 00:09:45.300
比较器之后我们做了什么

00:09:42.420 --> 00:09:48.410
刚刚通过了一段代码作为

00:09:45.300 --> 00:09:51.480
方法的参数和此方法

00:09:48.410 --> 00:09:54.480
在这种情况下，我们将使用盐法

00:09:51.480 --> 00:09:57.779
稍后再使用该代码

00:09:54.480 --> 00:10:00.620
正确的时间，为什么我使用

00:09:57.779 --> 00:10:03.180
万物有灵论者的实例

00:10:00.620 --> 00:10:06.000
好吧，因为这是我唯一的方法

00:10:03.180 --> 00:10:08.670
在Java 7中将密码作为参数

00:10:06.000 --> 00:10:11.279
如果我想将代码作为参数传递给

00:10:08.670 --> 00:10:13.020
 Java 7我必须使用

00:10:11.279 --> 00:10:17.490
我没有其他匿名班

00:10:13.020 --> 00:10:20.790
 lambda Azam I的解决方案

00:10:17.490 --> 00:10:23.880
可以像lambda一样准确地传递此代码

00:10:20.790 --> 00:10:27.390
表达，所以lambda基本上是一种方法

00:10:23.880 --> 00:10:29.700
重写此比较器

00:10:27.390 --> 00:10:31.410
 lambda现在回来了，我只需要

00:10:29.700 --> 00:10:34.320
认为我有一个障碍

00:10:31.410 --> 00:10:37.350
此方法的参数

00:10:34.320 --> 00:10:39.630
比较器这里有两个字符串和一个

00:10:37.350 --> 00:10:42.510
返回语句，lambda是

00:10:39.630 --> 00:10:45.290
更大，因为我只是复制/粘贴

00:10:42.510 --> 00:10:50.700
参数块画得这么少

00:10:45.290 --> 00:10:54.000
 ASCII艺术使用它的符号行

00:10:50.700 --> 00:10:57.180
大于标志，这只是LG 

00:10:54.000 --> 00:11:00.510
推算的过去

00:10:57.180 --> 00:11:02.010
返回语句是这样的

00:11:00.510 --> 00:11:06.560
我们将看到许多这样的例子

00:11:02.010 --> 00:11:10.950
这就是我们一般编写lambda的方式

00:11:06.560 --> 00:11:13.560
比较器接口变为Java 

00:11:10.950 --> 00:11:15.900
 8所谓的函数式接口

00:11:13.560 --> 00:11:18.360
什么是函数式接口

00:11:15.900 --> 00:11:20.910
只有一个摘要的接口

00:11:18.360 --> 00:11:22.560
方法，这是最简单的

00:11:20.910 --> 00:11:25.459
功能定义

00:11:22.560 --> 00:11:29.190
接口是函数式接口

00:11:25.459 --> 00:11:31.680
可能带有此功能的注释

00:11:29.190 --> 00:11:32.760
接口注释不是强制性的

00:11:31.680 --> 00:11:35.940
它坐

00:11:32.760 --> 00:11:37.890
可选，如果您不必这样做

00:11:35.940 --> 00:11:40.620
编译器会告诉您

00:11:37.890 --> 00:11:43.170
在IDE中编译时间

00:11:40.620 --> 00:11:46.050
我们将看到，如果对此进行了注释

00:11:43.170 --> 00:11:48.750
接口是否确实起作用，如果

00:11:46.050 --> 00:11:50.760
你不这样做，那么编译器会

00:11:48.750 --> 00:11:53.010
告诉你是否尝试实现这一点

00:11:50.760 --> 00:11:55.170
界面使用lambda嘿你可以做

00:11:53.010 --> 00:11:57.150
因为这不是功能

00:11:55.170 --> 00:11:59.700
界面，所以只是

00:11:57.150 --> 00:12:02.130
在这里帮助您的助手不是

00:11:59.700 --> 00:12:05.750
顺便说一句

00:12:02.130 --> 00:12:10.920
由于不是强制性的，因此它也是一个

00:12:05.750 --> 00:12:14.880
采用旧Java的方式让我们保存

00:12:10.920 --> 00:12:16.560
罐子中的五个代码，并使用

00:12:14.880 --> 00:12:18.870
 Java 8中的lambda表达式

00:12:16.560 --> 00:12:22.920
您的应用程序的一部分而无需

00:12:18.870 --> 00:12:27.210
重组它们，所以这也是

00:12:22.920 --> 00:12:31.170
向后兼容性原因演示时间

00:12:27.210 --> 00:12:35.280
太棒了，我喜欢演示，但我需要戴眼镜

00:12:31.170 --> 00:12:37.830
好吧，电话够大的，如果

00:12:35.280 --> 00:12:43.380
你，如果你不能只看代码

00:12:37.830 --> 00:12:45.660
告诉我，我可以，你可以在我

00:12:43.380 --> 00:12:47.520
如果可以举手的话

00:12:45.660 --> 00:12:50.210
您附近有空位，因为

00:12:47.520 --> 00:12:50.210
那里有人

00:12:55.240 --> 00:13:08.480
是不是更好，现在可以了吗

00:12:59.710 --> 00:13:16.010
这是一个列表，一旦列表，我们可以

00:13:08.480 --> 00:13:18.800
将要为每个使用此新

00:13:16.010 --> 00:13:22.190
在间隔接口上定义的方法

00:13:18.800 --> 00:13:23.840
这需要很长的时间

00:13:22.190 --> 00:13:26.720
将被应用到列表中， 

00:13:23.840 --> 00:13:28.430
在这里，每种方法都需要一个非de 

00:13:26.720 --> 00:13:30.740
表达式作为参数， 

00:13:28.430 --> 00:13:32.990
我问自己的问题是我怎么能

00:13:30.740 --> 00:13:35.120
写这个lambda表达式这个lambda 

00:13:32.990 --> 00:13:37.130
表达式-沿着表达式

00:13:35.120 --> 00:13:39.590
您需要确定什么是

00:13:37.130 --> 00:13:41.960
您需要实现的接口

00:13:39.590 --> 00:13:44.570
成为函数式接口，什么是

00:13:41.960 --> 00:13:47.210
这个接口的抽象方法

00:13:44.570 --> 00:13:49.090
这就是我要做的

00:13:47.210 --> 00:13:53.380
可以导航到冰箱的方法哦

00:13:49.090 --> 00:13:56.690
好的，这是一种默认方法

00:13:53.380 --> 00:13:59.330
这种方法将消费者视为

00:13:56.690 --> 00:14:02.240
参数，我要看这个

00:13:59.330 --> 00:14:05.030
消费者界面，这确实是一个

00:14:02.240 --> 00:14:07.850
函数式接口，按定义

00:14:05.030 --> 00:14:10.520
只有一种抽象方法是

00:14:07.850 --> 00:14:12.890
我这里的接受方法

00:14:10.520 --> 00:14:15.770
使用以下方法实现此抽象方法

00:14:12.890 --> 00:14:18.170
就像我们在幻灯片中看到的那样

00:14:15.770 --> 00:14:22.880
只需要复制粘贴的块

00:14:18.170 --> 00:14:27.410
参数让我做得出这个

00:14:22.880 --> 00:14:32.990
小小的老式小时像问游艇

00:14:27.410 --> 00:14:35.050
然后返回void，所以如果我只想

00:14:32.990 --> 00:14:37.370
返回我可以这样写的东西

00:14:35.050 --> 00:14:40.130
这是返回的代码块

00:14:37.370 --> 00:14:43.520
无效，因此至少应编译为

00:14:40.130 --> 00:14:46.970
只要我说这个T实际上是

00:14:43.520 --> 00:14:49.370
字符串，实际上此代码确实可以编译

00:14:46.970 --> 00:14:51.860
我刚刚用这个写的lambda 

00:14:49.370 --> 00:14:55.430
方法是

00:14:51.860 --> 00:15:00.320
消费者界面当然不是

00:14:55.430 --> 00:15:04.060
做很多事情，让我们在这里变得聪明

00:15:00.320 --> 00:15:04.060
我要打印出来

00:15:05.980 --> 00:15:14.530
这串字符好吗，我

00:15:09.410 --> 00:15:14.530
叫足够t，如果我运行这段代码

00:15:23.410 --> 00:15:30.519
好吧，它只是打印出内容

00:15:26.349 --> 00:15:33.749
列表，我不必

00:15:30.519 --> 00:15:36.389
在这里写参数的类型

00:15:33.749 --> 00:15:38.559
因为编译器足够聪明

00:15:36.389 --> 00:15:41.199
因为他知道我的方法

00:15:38.559 --> 00:15:44.049
实现它足够聪明，可以猜测

00:15:41.199 --> 00:15:47.529
 T的类型，编译器知道

00:15:44.049 --> 00:15:49.689
这实际上是一个字符串，所以

00:15:47.529 --> 00:15:52.449
您会发现它并不那么复杂

00:15:49.689 --> 00:15:55.989
右撇子让我们再拿一个

00:15:52.449 --> 00:15:57.549
另一个功能的例子

00:15:55.989 --> 00:16:00.220
接口是可迭代的

00:15:57.549 --> 00:16:07.869
界面让我们写一个可迭代的

00:16:00.220 --> 00:16:11.169
字符串好吧，让我们看看这个

00:16:07.869 --> 00:16:13.449
间隔接口这个小接口

00:16:11.169 --> 00:16:15.549
没有用功能注释

00:16:13.449 --> 00:16:19.689
接口，但只有一个摘要

00:16:15.549 --> 00:16:22.389
返回迭代器的方法

00:16:19.689 --> 00:16:24.899
不带任何参数让我们实施

00:16:22.389 --> 00:16:30.489
使用lambda表达式的方法

00:16:24.899 --> 00:16:33.539
复制/粘贴代码块

00:16:30.489 --> 00:16:38.229
空的代码块画了一点

00:16:33.539 --> 00:16:42.069
箭头的东西，并返回一个迭代器，所以我

00:16:38.229 --> 00:16:44.649
很可能返回null值

00:16:42.069 --> 00:16:47.049
代码应该编译，确实可以

00:16:44.649 --> 00:16:50.559
现在编译我应该返回

00:16:47.049 --> 00:16:54.369
当然有一个真正的迭代器，我有一个清单

00:16:50.559 --> 00:16:56.589
在这里，所以我可以把

00:16:54.369 --> 00:16:58.959
来自此字符串列表的迭代器，并且

00:16:56.589 --> 00:17:04.329
这是一个实现

00:16:58.959 --> 00:17:07.269
可迭代的界面，我可以检查一下

00:17:04.329 --> 00:17:14.230
通过将此迭代传递给

00:17:07.269 --> 00:17:19.329
每个图案并像打印结果一样

00:17:14.230 --> 00:17:21.610
它确实打印出了所有

00:17:19.329 --> 00:17:26.289
其他接口的元素

00:17:21.610 --> 00:17:32.039
我们可以列举最后一个例子

00:17:26.289 --> 00:17:32.039
另一个接口执行器接口

00:17:32.340 --> 00:17:37.680
执行者

00:17:34.210 --> 00:17:40.290
这个执行者界面也是

00:17:37.680 --> 00:17:42.940
函数式接口只有一个

00:17:40.290 --> 00:17:45.550
抽象方法再次不是

00:17:42.940 --> 00:17:48.820
带有函数式接口，但

00:17:45.550 --> 00:17:50.980
我们仍然可以使用它，但需要运行

00:17:48.820 --> 00:17:55.380
一个球作为参数，让我们来

00:17:50.980 --> 00:17:55.380
此代码块并复制粘贴

00:17:55.950 --> 00:18:05.230
画这个小箭头，它会返回

00:18:00.700 --> 00:18:06.250
无效，所以我可以使用它来实现

00:18:05.230 --> 00:18:09.130
倾倒

00:18:06.250 --> 00:18:12.670
秩序，这应该编译，的确

00:18:09.130 --> 00:18:15.550
现在我要做的是

00:18:12.670 --> 00:18:18.910
当然执行这个跑球，所以我

00:18:15.550 --> 00:18:21.700
可以写这个命令运行

00:18:18.910 --> 00:18:26.490
实例来执行我​​所有的运行

00:18:21.700 --> 00:18:28.750
要拨打这个执行人号码

00:18:26.490 --> 00:18:30.730
因为当然不是

00:18:28.750 --> 00:18:32.650
在当前执行可运行

00:18:30.730 --> 00:18:35.470
不是执行者的线程

00:18:32.650 --> 00:18:39.280
如果我想创建另一个应该怎么做

00:18:35.470 --> 00:18:42.580
我可以称之为聪明的执行者

00:18:39.280 --> 00:18:47.820
执行器并在另一个中运行此任务

00:18:42.580 --> 00:18:47.820
线程我可以使用这些执行程序

00:18:48.390 --> 00:18:58.600
遗嘱执行人实际上matado new还是

00:18:52.660 --> 00:19:03.580
单线程执行器执行此

00:18:58.600 --> 00:19:08.080
命令作为参数，以便您可以

00:19:03.580 --> 00:19:12.460
好的，我们可以测试此代码

00:19:08.080 --> 00:19:16.330
我需要一个可运行的，这将是我的

00:19:12.460 --> 00:19:19.450
顺便说一句，如果我检查可运行

00:19:16.330 --> 00:19:21.220
界面猜测缝制了什么继电器

00:19:19.450 --> 00:19:24.420
函数式接口，因此我可以实施

00:19:21.220 --> 00:19:28.470
使用lambda的runnable让我们做到这一点

00:19:24.420 --> 00:19:30.850
它不需要什么参数，并且

00:19:28.470 --> 00:19:37.290
不返回任何东西，所以我应该

00:19:30.850 --> 00:19:37.290
能够像这样实现

00:19:38.789 --> 00:19:46.259
看起来像JavaScript没关系，所以这

00:19:44.009 --> 00:19:48.629
这是一个随机的废话吗

00:19:46.259 --> 00:19:50.940
它当然会工作，但不会

00:19:48.629 --> 00:19:54.359
做很多事，但是会起作用，所以我可以

00:19:50.940 --> 00:20:01.709
做是任命，例如只是打印

00:19:54.359 --> 00:20:10.999
退出线程Amina我正在线程中读取

00:20:01.709 --> 00:20:17.869
目前读这样的东西， 

00:20:10.999 --> 00:20:24.169
然后转储执行程序执行此任务

00:20:17.869 --> 00:20:28.559
然后用我聪明的执行者再做一次

00:20:24.169 --> 00:20:30.419
如果我运行此代码，确实是第一个

00:20:28.559 --> 00:20:34.169
在主线程中执行

00:20:30.419 --> 00:20:36.929
这正是所期望的

00:20:34.169 --> 00:20:39.329
第二个在一个线程中执行

00:20:36.929 --> 00:20:43.949
这是我的执行人的线程

00:20:39.329 --> 00:20:45.719
服务我需要手动关闭

00:20:43.949 --> 00:20:48.359
因为我没有关闭这个模组

00:20:45.719 --> 00:20:50.219
可执行文件，这当然是非常错误的

00:20:48.359 --> 00:20:53.399
不要在

00:20:50.219 --> 00:20:56.609
如果我接受这一点，生产只是一个音符

00:20:53.399 --> 00:20:57.509
在此处作为可迭代和复制粘贴的代码

00:20:56.609 --> 00:21:02.519
那里

00:20:57.509 --> 00:21:03.419
如果您能看到我没有，我有一个

00:21:02.519 --> 00:21:07.559
编译器

00:21:03.419 --> 00:21:09.929
糟糕，我有一个编译器错误此代码

00:21:07.559 --> 00:21:13.019
不编译为什么，因为

00:21:09.929 --> 00:21:15.079
编译器必须在编译时知道

00:21:13.019 --> 00:21:18.299
我正在写的lambda表达式的类型

00:21:15.079 --> 00:21:21.209
因此，lambda应该要么受到

00:21:18.299 --> 00:21:24.359
字段或变量将作为

00:21:21.209 --> 00:21:27.419
参数或由方法I编写

00:21:24.359 --> 00:21:30.269
不能像输入的那样接受lambda 

00:21:27.419 --> 00:21:33.299
就像这段代码和希望一样

00:21:30.269 --> 00:21:37.399
例如，如果我

00:21:33.299 --> 00:21:40.139
只是复制粘贴此代码像这样

00:21:37.399 --> 00:21:41.969
放在括号和类似的代码中

00:21:40.139 --> 00:21:44.309
我会有一个编译器错误

00:21:41.969 --> 00:21:45.989
因为编译器无法猜测

00:21:44.309 --> 00:21:47.849
是公正的lambda的类型

00:21:45.989 --> 00:21:50.239
写的我需要把它放在一个变量中

00:21:47.849 --> 00:21:50.239
为了那个原因

00:21:52.150 --> 00:22:03.320
我要去游泳了

00:21:56.360 --> 00:22:05.390
好吧，让我们继续，所以写

00:22:03.320 --> 00:22:08.120
坐在椅子上是一个发现的问题

00:22:05.390 --> 00:22:11.060
你什么接口什么功能

00:22:08.120 --> 00:22:13.550
我正在实现的界面

00:22:11.060 --> 00:22:15.980
界面来确定我是哪种方法

00:22:13.550 --> 00:22:18.170
实施以及何时确定

00:22:15.980 --> 00:22:20.510
这是一个障碍的问题

00:22:18.170 --> 00:22:22.670
参数了解什么

00:22:20.510 --> 00:22:26.300
返回并变得聪明，把

00:22:22.670 --> 00:22:28.790
在他们身上正确的代码

00:22:26.300 --> 00:22:32.450
基本上方法lambda只是一个

00:22:28.790 --> 00:22:38.480
我可以作为参数传递的方法

00:22:32.450 --> 00:22:41.240
我的应用程序中的代码有

00:22:38.480 --> 00:22:43.640
发生什么事的地方

00:22:41.240 --> 00:22:44.990
啊，是的，这个有趣的语法叫做

00:22:43.640 --> 00:22:46.760
我们将要看到的方法参考

00:22:44.990 --> 00:22:50.390
在一分钟内，每个

00:22:46.760 --> 00:22:52.730
方法在迭代器上定义

00:22:50.390 --> 00:22:58.370
接口，这就是我们刚才的代码

00:22:52.730 --> 00:23:01.070
正确地写在这里，并已添加到

00:22:58.370 --> 00:23:04.130
 Java 8，因此在

00:23:01.070 --> 00:23:05.930
接口当然意味着所有

00:23:04.130 --> 00:23:10.580
该接口的实现

00:23:05.930 --> 00:23:13.490
更新代码以使其正常工作

00:23:10.580 --> 00:23:15.740
当然，这本来意味着重构

00:23:13.490 --> 00:23:18.320
所有集合API和所有

00:23:15.740 --> 00:23:20.360
可迭代的现有实现

00:23:18.320 --> 00:23:23.930
 interval是所有根接口

00:23:20.360 --> 00:23:26.630
收集场，所以它将有

00:23:23.930 --> 00:23:28.190
需要更新所有代码

00:23:26.630 --> 00:23:30.590
这是不可能的

00:23:28.190 --> 00:23:32.960
当然它会打破落后

00:23:30.590 --> 00:23:35.600
校正的兼容性

00:23:32.960 --> 00:23:37.160
现在不可能的框架

00:23:35.600 --> 00:23:40.940
用Java去做这样的事情

00:23:37.160 --> 00:23:43.130
如果您有一个接口，接口的工作方式

00:23:40.940 --> 00:23:45.200
您附近的空位可以举起吗

00:23:43.130 --> 00:23:49.580
再次举手请发表评论

00:23:45.200 --> 00:23:51.950
座落在市中心，所以在后面

00:23:49.580 --> 00:23:55.040
接口工作方式已被修改

00:23:51.950 --> 00:23:57.470
在Java 8中，实际上每种方法

00:23:55.040 --> 00:24:00.590
默认方法什么是默认方法

00:23:57.470 --> 00:24:02.750
方法这是一个常规方法

00:24:00.590 --> 00:24:04.340
接口及其实现

00:24:02.750 --> 00:24:06.919
它只是具有默认值

00:24:04.340 --> 00:24:11.240
在它前面的关键词

00:24:06.919 --> 00:24:15.140
有一点就是

00:24:11.240 --> 00:24:19.070
普通的常规方法非常非常容易

00:24:15.140 --> 00:24:20.960
了解此默认方法是

00:24:19.070 --> 00:24:22.340
普通方法放在一个接口里是什么

00:24:20.960 --> 00:24:24.590
新的是，我们现在可以拥有

00:24:22.340 --> 00:24:27.380
接口中的实现不是

00:24:24.590 --> 00:24:31.159
可能直到Java 7为止，但这是一个新的

00:24:27.380 --> 00:24:33.620
接口的概念不是一个新概念

00:24:31.159 --> 00:24:36.080
方法的概念只是一个普通的旧

00:24:33.620 --> 00:24:39.440
常规方法也用于编写

00:24:36.080 --> 00:24:42.500
下来这就是它卖给我们的方式

00:24:39.440 --> 00:24:45.440
当Java 8发布近4年时

00:24:42.500 --> 00:24:47.779
以前，但远不止于此

00:24:45.440 --> 00:24:50.360
而且我想从那以后的几年

00:24:47.779 --> 00:24:52.190
现在人们将不会学习

00:24:50.360 --> 00:24:53.750
引入了默认方法

00:24:52.190 --> 00:24:57.710
向后兼容性bla bla bla 

00:24:53.750 --> 00:24:59.570
他们会学到其他东西

00:24:57.710 --> 00:25:03.350
我们也可以将公共静态方法

00:24:59.570 --> 00:25:05.570
接口中Java 8中的方法

00:25:03.350 --> 00:25:10.610
 Java 9中的新功能

00:25:05.570 --> 00:25:13.880
私有静态方法如此功能

00:25:10.610 --> 00:25:16.429
现在我可以在界面中这样

00:25:13.880 --> 00:25:19.820
有抽象方法默认方法

00:25:16.429 --> 00:25:23.090
和静态方法只有抽象方法

00:25:19.820 --> 00:25:25.580
数出一个接口是否是一个

00:25:23.090 --> 00:25:28.370
函数式接口或不是默认界面

00:25:25.580 --> 00:25:30.350
静态方法不算哪个好

00:25:28.370 --> 00:25:32.120
因为这意味着我将能够

00:25:30.350 --> 00:25:34.549
将抽象方法放入函数中

00:25:32.120 --> 00:25:36.909
界面并添加一堆默认值

00:25:34.549 --> 00:25:45.559
我要做的方法

00:25:36.909 --> 00:25:46.640
另一个，我们要做什么

00:25:45.559 --> 00:25:51.700
要关闭此标签

00:25:46.640 --> 00:25:51.700
我不再需要了

00:25:53.700 --> 00:25:57.450
我准备了两个接口

00:25:56.610 --> 00:25:59.610
现在要使用

00:25:57.450 --> 00:26:02.039
首先是我的消费者界面

00:25:59.610 --> 00:26:03.299
用户界面的模仿

00:26:02.039 --> 00:26:06.149
我们将要使用的java.util包

00:26:03.299 --> 00:26:07.799
稍等一下，我们要去

00:26:06.149 --> 00:26:10.590
用它做东西是什么消费者

00:26:07.799 --> 00:26:12.269
它只有一种方法是

00:26:10.590 --> 00:26:14.159
我们已经去过系统dot out dot println 

00:26:12.269 --> 00:26:20.850
与Forex方法一起使用

00:26:14.159 --> 00:26:24.419
分钟前，所以我要创建

00:26:20.850 --> 00:26:28.070
的第一个消费者消费者字符串

00:26:24.419 --> 00:26:28.070
实例在吃呀

00:26:44.420 --> 00:26:57.600
是的，这是吃得好，如果我

00:26:54.860 --> 00:27:05.040
叫这个我的接受方法

00:26:57.600 --> 00:27:07.560
消费者界面和我一起吃鸡肉

00:27:05.040 --> 00:27:10.230
运行此代码，它只会显示进餐

00:27:07.560 --> 00:27:18.270
我要写的鸡真好

00:27:10.230 --> 00:27:20.900
第二个喝酒的人

00:27:18.270 --> 00:27:20.900
差不多一样

00:27:24.600 --> 00:27:41.740
喝酒，我要去喝酒

00:27:31.810 --> 00:27:43.240
除了咖啡还可以喝鸡肉和

00:27:41.740 --> 00:27:49.900
现在我想喝咖啡

00:27:43.240 --> 00:27:56.020
想要创造另一个消费者的饮食

00:27:49.900 --> 00:28:00.000
实际上我想组成的喝酒

00:27:56.020 --> 00:28:03.640
那两个消费者合而为一

00:28:00.000 --> 00:28:09.100
为此，我想写这个

00:28:03.640 --> 00:28:10.570
某种代码，然后饮用

00:28:09.100 --> 00:28:13.450
当然这然后方法不起作用

00:28:10.570 --> 00:28:15.370
在上面，然后我需要创建它

00:28:13.450 --> 00:28:17.560
我可以实施这种想法吗

00:28:15.370 --> 00:28:19.360
这是非常基本的模式，我不会

00:28:17.560 --> 00:28:21.280
只是为了创建一个消费者

00:28:19.360 --> 00:28:23.050
第一个消费者的组合

00:28:21.280 --> 00:28:24.640
并且第一个链接

00:28:23.050 --> 00:28:27.700
消费者，然后是第二消费者

00:28:24.640 --> 00:28:30.790
如果我检查此方法然后

00:28:27.700 --> 00:28:31.420
这是什么方法

00:28:30.790 --> 00:28:34.690
叫

00:28:31.420 --> 00:28:38.290
这里只吃东西，所以

00:28:34.690 --> 00:28:40.710
饮食对象的实例方法

00:28:38.290 --> 00:28:45.730
我有这个我的消费界面

00:28:40.710 --> 00:28:47.380
另一个方法称为然后

00:28:45.730 --> 00:28:48.250
这将需要一些东西， 

00:28:47.380 --> 00:28:50.920
还东西

00:28:48.250 --> 00:28:53.500
它作为参数是什么

00:28:50.920 --> 00:28:56.940
带我的消费者，这是什么

00:28:53.500 --> 00:29:03.700
返回他们返回另一个微米湿婆

00:28:56.940 --> 00:29:10.110
这样做，我将我的消费者视为

00:29:03.700 --> 00:29:12.760
参数并返回我的消费者对象

00:29:10.110 --> 00:29:15.580
如果我这样写的话

00:29:12.760 --> 00:29:17.200
是完全合法的，但您当然可以

00:29:15.580 --> 00:29:19.240
有问题，因为我有一个

00:29:17.200 --> 00:29:21.670
具有抽象方法的接口

00:29:19.240 --> 00:29:23.650
它不再是函数式接口

00:29:21.670 --> 00:29:26.100
所以它不能编译我不能

00:29:23.650 --> 00:29:30.570
使用lambda实现此接口

00:29:26.100 --> 00:29:30.570
顺便说一句，如果我添加

00:29:33.190 --> 00:29:41.059
该函数式接口注释

00:29:37.729 --> 00:29:43.279
在这里，您看到这次

00:29:41.059 --> 00:29:45.469
编译器将在接口上引发

00:29:43.279 --> 00:29:47.479
本身，因为我有两种抽象方法

00:29:45.469 --> 00:29:52.099
而且此接口不起作用

00:29:47.479 --> 00:29:54.379
接口了，所以这个添加了这个

00:29:52.099 --> 00:29:57.679
方法作为抽象方法不是

00:29:54.379 --> 00:30:00.379
要走的路，但请记住我可以添加默认值

00:29:57.679 --> 00:30:03.259
 Maya分数接口上的方法

00:30:00.379 --> 00:30:06.769
顺便说一下，任何一种界面

00:30:03.259 --> 00:30:13.579
我们这次将这个界面设为默认界面

00:30:06.769 --> 00:30:15.919
我需要提供一个实现

00:30:13.579 --> 00:30:19.009
您会看到这段代码确实编译了我的

00:30:15.919 --> 00:30:21.829
界面再次正常工作

00:30:19.009 --> 00:30:24.709
当然我可以用lambda实现

00:30:21.829 --> 00:30:28.279
表达式，所以现在我该怎么做

00:30:24.709 --> 00:30:32.899
然后我需要的方法

00:30:28.279 --> 00:30:35.659
回报是我的消费者，好吧，我的消费者

00:30:32.899 --> 00:30:38.989
是一个函数式接口，因此可以

00:30:35.659 --> 00:30:41.899
使用lambda实现这是什么

00:30:38.989 --> 00:30:42.979
 lambda很好，只需要应用确切的

00:30:41.899 --> 00:30:46.639
同样的方法

00:30:42.979 --> 00:30:48.559
我们以前应用过的唯一

00:30:46.639 --> 00:30:51.619
我的消费者的抽象方法

00:30:48.559 --> 00:30:56.559
界面，然后复制/粘贴

00:30:51.619 --> 00:31:02.899
参数画这个小有趣的权利

00:30:56.559 --> 00:31:06.619
东西，还好男孩，所以如果我写

00:31:02.899 --> 00:31:08.599
它应该编译并

00:31:06.619 --> 00:31:11.059
的确确实编译了它，这是一个

00:31:08.599 --> 00:31:15.889
消费者好，所以现在我需要成为一个

00:31:11.059 --> 00:31:20.179
我期望这里要聪明一点

00:31:15.889 --> 00:31:23.989
第一个消费者我要去的对象

00:31:20.179 --> 00:31:25.429
传递给这个堆肥消费者

00:31:23.989 --> 00:31:28.909
他们与第一个消费者

00:31:25.429 --> 00:31:33.409
消费者我在这个消费者中，然后

00:31:28.909 --> 00:31:35.779
消费者作为参数传递，因此

00:31:33.409 --> 00:31:38.929
当我在这段代码中时，让我们这样做

00:31:35.779 --> 00:31:42.240
在一个消费者的实例中，所以我可以

00:31:38.929 --> 00:31:46.890
称之为接受

00:31:42.240 --> 00:31:51.240
的T可能会打印出类似的内容

00:31:46.890 --> 00:31:54.480
然后再消耗这个T对象

00:31:51.240 --> 00:31:59.910
与其他消费者通过

00:31:54.480 --> 00:32:07.710
如果我现在吃东西， 

00:31:59.910 --> 00:32:10.800
喝酒吃喝接受好

00:32:07.710 --> 00:32:13.260
食物还可以，我喝的不是很好

00:32:10.800 --> 00:32:16.800
食物，但是无论如何它会像

00:32:13.260 --> 00:32:19.710
我的默认方法已实现

00:32:16.800 --> 00:32:23.550
邀请链接到消费者

00:32:19.710 --> 00:32:26.100
这个和其他作为参数传递，所以

00:32:23.550 --> 00:32:30.480
您会看到使用这种默认设置

00:32:26.100 --> 00:32:32.040
方法允许我们邀请打开所有

00:32:30.480 --> 00:32:34.710
新模式的方式是

00:32:32.040 --> 00:32:37.230
组成lambda表达式，这是

00:32:34.710 --> 00:32:44.550
直到年底我们将要做的事情

00:32:37.230 --> 00:32:48.000
本届会议的这个让我们再来

00:32:44.550 --> 00:32:49.770
与另一个功能的示例

00:32:48.000 --> 00:32:54.740
我拥有的JDK接口

00:32:49.770 --> 00:32:54.740
在这里模仿任何可用的座位

00:32:58.370 --> 00:33:02.010
好吧，所以它可以预测八

00:33:00.390 --> 00:33:04.200
界面再次是模仿

00:33:02.010 --> 00:33:08.010
 J上可用的 Predicate 接口

00:33:04.200 --> 00:33:10.490
在JDK中，我们将要编写

00:33:08.010 --> 00:33:13.140
一些东西

00:33:10.490 --> 00:33:20.550
所以我要举个例子

00:33:13.140 --> 00:33:23.610
我的奥地利谓语

00:33:20.550 --> 00:33:27.000
字符串，你知道不是新的权利，它

00:33:23.610 --> 00:33:34.200
只会检查这个给定

00:33:27.000 --> 00:33:41.700
字符串是否存在，我要去

00:33:34.200 --> 00:33:47.300
再花一个短一点然后全部

00:33:41.700 --> 00:33:47.300
对，就是那样的长度

00:33:48.329 --> 00:33:55.209
长度小于十的那是两个

00:33:53.199 --> 00:33:57.429
谓词和自然的组合方式

00:33:55.209 --> 00:33:59.559
谓词组成谓词是为了

00:33:57.429 --> 00:34:08.099
实例二使用和见面

00:33:59.559 --> 00:34:20.440
所以不是新点，并且少于十

00:34:08.099 --> 00:34:25.329
也应该是谓词字符串， 

00:34:20.440 --> 00:34:27.220
我要打电话说p1好吧

00:34:25.329 --> 00:34:29.559
我再次面对着完全一样的

00:34:27.220 --> 00:34:32.710
问题作为我的组成

00:34:29.559 --> 00:34:35.409
消费者在这里，我的方法是

00:34:32.710 --> 00:34:38.079
不是新对象的实例方法

00:34:35.409 --> 00:34:42.249
所以这是我的即时方法

00:34:38.079 --> 00:34:44.499
 Predicate 接口，不能是另一个

00:34:42.249 --> 00:34:47.499
抽象方法，因为如果是这样

00:34:44.499 --> 00:34:49.419
会破坏函数式接口

00:34:47.499 --> 00:34:54.599
东西，所以我将其设为默认值

00:34:49.419 --> 00:34:57.220
方法，然后这个，然后方法

00:34:54.599 --> 00:35:00.579
以谓词为参数， 

00:34:57.220 --> 00:35:05.680
还返回一个谓词，让我们做到这一点

00:35:00.579 --> 00:35:08.650
所以返回谓词需要一个

00:35:05.680 --> 00:35:11.230
谓词作为参数，所以如果我只是

00:35:08.650 --> 00:35:18.190
返回这里至少应该

00:35:11.230 --> 00:35:20.940
编译它不会哦，对不起，这是

00:35:18.190 --> 00:35:25.569
只是在这里所以现在应该编译

00:35:20.940 --> 00:35:28.420
好的，谢谢，我该怎么办

00:35:25.569 --> 00:35:31.630
和我的谓词我该如何实施

00:35:28.420 --> 00:35:33.400
使用lambda的谓词，此lambda是

00:35:31.630 --> 00:35:37.269
测试方法的实现

00:35:33.400 --> 00:35:39.430
在这里总是相同的过程

00:35:37.269 --> 00:35:41.970
创建这个lambda，所以我要去

00:35:39.430 --> 00:35:44.710
复制粘贴参数I的块

00:35:41.970 --> 00:35:47.529
需要返回一个布尔值，所以如果我只是

00:35:44.710 --> 00:35:49.869
第一步返回true返回

00:35:47.529 --> 00:35:53.019
至少可以编译确实可以

00:35:49.869 --> 00:35:56.529
这个布尔值应该是合乎逻辑的

00:35:53.019 --> 00:35:57.800
我内部使用的谓词结尾

00:35:56.529 --> 00:35:59.830
此测试方法

00:35:57.800 --> 00:36:10.060
谓词作为参数传递

00:35:59.830 --> 00:36:10.060
所以这只是T和测试的测试

00:36:11.740 --> 00:36:31.000
我们可以测试这段代码p1测试稳定

00:36:25.370 --> 00:36:31.000
打印机n测试

00:36:34.109 --> 00:36:38.940
从此代码哎呀

00:36:49.100 --> 00:36:51.940
抱歉

00:36:55.839 --> 00:36:58.839
九九

00:36:59.480 --> 00:37:04.010
是的，这是一个漂亮的蛋糕

00:37:06.360 --> 00:37:14.930
哦，是的，对不起，是的，是的

00:37:17.030 --> 00:37:23.370
好的谢谢

00:37:19.580 --> 00:37:26.310
会发生什么，好吧，这就像

00:37:23.370 --> 00:37:30.750
如果我不通过，会发生什么

00:37:26.310 --> 00:37:33.050
参数在这里，如果我很有趣

00:37:30.750 --> 00:37:38.310
当然运行这段代码

00:37:33.050 --> 00:37:39.900
我要运行以下代码

00:37:38.310 --> 00:37:42.660
当然我有一个空指针异常

00:37:39.900 --> 00:37:45.300
但有趣的一点是在哪里

00:37:42.660 --> 00:37:47.810
这个没有指针的异常来自你

00:37:45.300 --> 00:37:51.450
看到它来自lambda内部

00:37:47.810 --> 00:37:54.390
如果现在有这个就在这里

00:37:51.450 --> 00:37:56.970
代码将抛出空指针

00:37:54.390 --> 00:38:02.210
只要第一个测试是例外

00:37:56.970 --> 00:38:06.090
是真的，这意味着如果我不打电话

00:38:02.210 --> 00:38:09.870
此代码此代码将要运行

00:38:06.090 --> 00:38:13.590
很好，您知道，所以如果我创建一个

00:38:09.870 --> 00:38:16.140
谓词与另一个是新的我

00:38:13.590 --> 00:38:18.090
 lambda表达式已损坏

00:38:16.140 --> 00:38:20.280
要去那肯定会抛出一个

00:38:18.090 --> 00:38:22.200
空指针异常在某处但是

00:38:20.280 --> 00:38:25.380
这个新的指针异常将不会

00:38:22.200 --> 00:38:27.570
在创建lambda时抛出，但是

00:38:25.380 --> 00:38:30.320
当我将使用它下来

00:38:27.570 --> 00:38:33.030
我的申请，所以如果我通过这个lambda 

00:38:30.320 --> 00:38:35.790
到我的某种其他模块

00:38:33.030 --> 00:38:38.010
应用程序，该标准用于

00:38:35.790 --> 00:38:40.080
从现在起十天

00:38:38.010 --> 00:38:42.390
异常将被抛出很多

00:38:40.080 --> 00:38:45.810
迟于此lambda的时刻

00:38:42.390 --> 00:38:47.160
被创建，这将使一种

00:38:45.810 --> 00:38:51.570
无法修复

00:38:47.160 --> 00:38:54.390
但是因为我的堆栈跟踪

00:38:51.570 --> 00:38:56.940
有给我的地方

00:38:54.390 --> 00:38:59.420
实际上存在错误时使用lambda 

00:38:56.940 --> 00:39:01.710
在创建lambda的地方

00:38:59.420 --> 00:39:04.590
所以如果我想防止这种情况

00:39:01.710 --> 00:39:10.230
我需要抛出空指针的东西

00:39:04.590 --> 00:39:15.200
 Lambda创建中的异常是

00:39:10.230 --> 00:39:15.200
现在在这里，如果我再次运行此代码

00:39:15.740 --> 00:39:20.210
当然，空指针异常是

00:39:17.690 --> 00:39:22.700
当我尝试构建lambda时抛出

00:39:20.210 --> 00:39:24.109
这是我们真正需要使用的模式

00:39:22.700 --> 00:39:26.060
因为我们不想拥有

00:39:24.109 --> 00:39:29.060
无法修复我们的错误

00:39:26.060 --> 00:39:31.700
应用程序这是一个应用程序

00:39:29.060 --> 00:39:34.520
一个非常古老的原则，例外

00:39:31.700 --> 00:39:37.010
车道让我们畏惧失败

00:39:34.520 --> 00:39:38.869
首先，如果我知道这将要发生

00:39:37.010 --> 00:39:43.250
混乱不堪，我只说了一点

00:39:38.869 --> 00:39:46.930
现在是这样的异常

00:39:43.250 --> 00:39:49.930
我也应该在这里做什么

00:39:46.930 --> 00:39:49.930
对象

00:39:54.680 --> 00:40:06.170
是啊

00:40:00.470 --> 00:40:07.790
是的，你的意思是如果我打电话然后

00:40:06.170 --> 00:40:15.790
然后然后然后它将继续

00:40:07.790 --> 00:40:15.790
工作没问题，然后

00:40:17.190 --> 00:40:26.130
是的，行不通，你不能改变

00:40:23.549 --> 00:40:27.750
您可以连锁的消费者

00:40:26.130 --> 00:40:29.819
您需要的消费者，您可以

00:40:27.750 --> 00:40:32.250
根据需要组成任意多个谓词

00:40:29.819 --> 00:40:41.099
与和创建所有方法或

00:40:32.250 --> 00:40:47.460
这种事情是的，你的意思是

00:40:41.099 --> 00:40:49.049
妮可，是的，但这就是这个

00:40:47.460 --> 00:40:56.130
我写了这是否是我需要的

00:40:49.049 --> 00:40:57.720
好吧，你看到这是一个消费者

00:40:56.130 --> 00:40:59.450
您无法采取任何预防措施

00:40:57.720 --> 00:41:02.520
在意图方法中

00:40:59.450 --> 00:41:04.910
因为你不知道这是一个

00:41:02.520 --> 00:41:09.089
消费者，我可以把它放在一个变量中

00:41:04.910 --> 00:41:10.829
这只是我的老顾客

00:41:09.089 --> 00:41:13.079
只是调用然后在

00:41:10.829 --> 00:41:16.079
普通消费者，所以没有办法

00:41:13.079 --> 00:41:19.109
在Endon方法中让我知道

00:41:16.079 --> 00:41:23.329
实际上，消费者II在

00:41:19.109 --> 00:41:23.329
本身就是其他消费者的组成

00:41:29.660 --> 00:41:34.529
我们也可以断言我们

00:41:32.609 --> 00:41:41.190
也可以创建其他默认方法

00:41:34.529 --> 00:41:44.460
例如p1短于10 

00:41:41.190 --> 00:41:47.490
我可以说我想我想要

00:41:44.460 --> 00:41:49.890
实现否定运算符

00:41:47.490 --> 00:41:51.720
消费者，这个否定运算符是

00:41:49.890 --> 00:41:54.869
也是默认方法，但是这次

00:41:51.720 --> 00:41:57.900
不需要任何参数，所以让

00:41:54.869 --> 00:42:05.819
我们写它默认它返回一个我的

00:41:57.900 --> 00:42:14.339
 T调用谓词否定，并且不

00:42:05.819 --> 00:42:17.089
可以接受任何参数，那我该怎么办

00:42:14.339 --> 00:42:21.059
现在再次返回，这是一个

00:42:17.089 --> 00:42:24.510
谓词，所以我复制/粘贴

00:42:21.059 --> 00:42:27.230
参数在这里小箭头和这个

00:42:24.510 --> 00:42:27.230
应该回来

00:42:27.910 --> 00:42:38.530
我对T测试的否定

00:42:33.490 --> 00:42:41.560
可以这样写，所以你看到

00:42:38.530 --> 00:42:43.360
默认方法允许我们实现

00:42:41.560 --> 00:42:56.110
的组成和操作

00:42:43.360 --> 00:42:58.060
可以用作表达式，所以我们已经

00:42:56.110 --> 00:43:00.640
有可写的函数式接口

00:42:58.060 --> 00:43:04.540
那些表达式我们有默认方法

00:43:00.640 --> 00:43:07.090
组成它们，我们还有一个静态的

00:43:04.540 --> 00:43:08.680
可以用作工厂的方法

00:43:07.090 --> 00:43:11.590
我们将进一步看到

00:43:08.680 --> 00:43:14.610
实例给出什么想法

00:43:11.590 --> 00:43:17.710
对我们的代码更好的可读性

00:43:14.610 --> 00:43:19.660
基本上是因为我们正在移动一些

00:43:17.710 --> 00:43:22.690
特别是技术规范的一部分

00:43:19.660 --> 00:43:24.940
对API的空指针处理

00:43:22.690 --> 00:43:28.360
而不是让他们拥有该代码

00:43:24.940 --> 00:43:31.150
在我们的应用程序代码中，这是

00:43:28.360 --> 00:43:33.970
是什么导致更好的可读性和

00:43:31.150 --> 00:43:35.760
更好的鲁棒性，因为我们可以

00:43:33.970 --> 00:43:38.920
检查里面的所有异常

00:43:35.760 --> 00:43:40.840
在我们的代码中，它也提供了更好的

00:43:38.920 --> 00:43:42.340
表演我不会讲

00:43:40.840 --> 00:43:44.320
点，但如果您对此感兴趣

00:43:42.340 --> 00:43:46.210
有一个非常有趣的谈话

00:43:44.320 --> 00:43:52.420
布赖恩·盖茨（Brian Gates）在

00:43:46.210 --> 00:43:54.310
 YouTube上的引擎盖，我们有我

00:43:52.420 --> 00:43:56.620
提到了几次我的

00:43:54.310 --> 00:44:00.220
消费者和我的谓词

00:43:56.620 --> 00:44:01.840
消费者的事实模仿和

00:44:00.220 --> 00:44:04.390
谓词函数式接口

00:44:01.840 --> 00:44:06.940
实际上我已经在GDK中找到了

00:44:04.390 --> 00:44:09.460
功能的四大类

00:44:06.940 --> 00:44:12.310
此Java util函数中的接口

00:44:09.460 --> 00:44:14.290
包装消费者，供应商

00:44:12.310 --> 00:44:16.620
函数和谓词，我们将看到

00:44:14.290 --> 00:44:21.040
供应商示例和功能

00:44:16.620 --> 00:44:24.850
这些是最基本的例子

00:44:21.040 --> 00:44:27.610
这些功能的实现

00:44:24.850 --> 00:44:30.100
消费者采取的接口

00:44:27.610 --> 00:44:32.080
什么不返回任何东西

00:44:30.100 --> 00:44:35.470
供应商不采取任何行动， 

00:44:32.080 --> 00:44:37.300
达到功能需要

00:44:35.470 --> 00:44:38.609
给定类型的对象，并返回

00:44:37.300 --> 00:44:40.950
宾语

00:44:38.609 --> 00:44:43.260
谓词是一种特殊的

00:44:40.950 --> 00:44:48.920
返回布尔值的函数

00:44:43.260 --> 00:44:52.829
我也可以说那些更详尽

00:44:48.920 --> 00:44:54.839
例如，我还有第五个

00:44:52.829 --> 00:44:57.300
 Lambda表达式在哪里起作用

00:44:54.839 --> 00:44:59.790
我认为合适的界面

00:44:57.300 --> 00:45:02.309
在这个集合中这是可运行的

00:44:59.790 --> 00:45:04.260
接口不是可运行的接口

00:45:02.309 --> 00:45:07.050
新的，从很早就到这里了

00:45:04.260 --> 00:45:09.180
 GDK的日子，那是

00:45:07.050 --> 00:45:11.760
不带任何东西，也不带

00:45:09.180 --> 00:45:13.829
返回任何事情的思考

00:45:11.760 --> 00:45:21.450
记录器例如基本上是记录器

00:45:13.829 --> 00:45:24.390
它可以被建模为彩虹让我们走

00:45:21.450 --> 00:45:27.569
回到我们的比较器示例

00:45:24.390 --> 00:45:30.390
要写一个人的比较器

00:45:27.569 --> 00:45:33.180
为此，我们将使用

00:45:30.390 --> 00:45:35.579
 lambda表达式，然后对不起

00:45:33.180 --> 00:45:42.180
匿名课程，然后

00:45:35.579 --> 00:45:47.869
表达它再次是演示时间，好吧，我们

00:45:42.180 --> 00:45:50.819
需要关闭所有这些东西

00:45:47.869 --> 00:45:53.130
与比较器一起玩，所以我有一个

00:45:50.819 --> 00:45:56.430
比较器接口，类似于

00:45:53.130 --> 00:45:58.380
真正的比较界面还可以

00:45:56.430 --> 00:46:02.579
我要去玩，我也

00:45:58.380 --> 00:46:04.650
有一个人类，这是一个基本的箱

00:46:02.579 --> 00:46:07.099
具有三个属性的名字姓氏

00:46:04.650 --> 00:46:14.059
我将使用的名称和年龄

00:46:07.099 --> 00:46:18.540
所以让我们创建一个比较器的人

00:46:14.059 --> 00:46:25.700
我将其称为CMP新产品

00:46:18.540 --> 00:46:25.700
竞争对手是，如果我不支持这一点

00:46:27.360 --> 00:46:39.340
我们要真正实现的人

00:46:32.440 --> 00:46:42.240
快速正确的人p1和人P 2以及

00:46:39.340 --> 00:46:46.870
我想做的是以下我

00:46:42.240 --> 00:46:49.170
想先，我想先p1 

00:46:46.870 --> 00:46:49.170
名称

00:46:51.270 --> 00:47:01.450
这是这里的姓氏，p2 

00:46:59.800 --> 00:47:03.490
我们也叫姓氏

00:47:01.450 --> 00:47:07.440
然后我只想返回

00:47:03.490 --> 00:47:13.870
姓氏与

00:47:07.440 --> 00:47:17.590
持续两个，这是我现在的比较

00:47:13.870 --> 00:47:21.900
我仔细看看这段代码我

00:47:17.590 --> 00:47:29.170
这里可以做的就是将其提取为一种方法

00:47:21.900 --> 00:47:34.210
是的，如果我这样做，我可以看到他们

00:47:29.170 --> 00:47:36.940
实际上我的比较器仅取决于

00:47:34.210 --> 00:47:39.100
如果我想比较这种方法

00:47:36.940 --> 00:47:42.190
人们用他们的名字我

00:47:39.100 --> 00:47:45.190
需要做的是更改其代码， 

00:47:42.190 --> 00:47:48.190
其余代码相同，因此

00:47:45.190 --> 00:47:52.330
比较器实际上已经写取决于

00:47:48.190 --> 00:47:54.550
在方法上，这很好，因为

00:47:52.330 --> 00:47:59.800
我知道与伦敦的

00:47:54.550 --> 00:48:02.470
我可以将方法作为参数传递

00:47:59.800 --> 00:48:05.680
我要做的就是转换这种方法

00:48:02.470 --> 00:48:09.040
在lambda中，然后我将能够

00:48:05.680 --> 00:48:11.560
仅仅通过冒险就可以创建一个比较器

00:48:09.040 --> 00:48:15.280
 lambda作为某种参数的

00:48:11.560 --> 00:48:18.180
例如工厂方法好吗

00:48:15.280 --> 00:48:21.970
这种方法需要一个人吗

00:48:18.180 --> 00:48:24.190
并返回一个字符串

00:48:21.970 --> 00:48:26.790
一个对象从另一个对象返回一个对象

00:48:24.190 --> 00:48:28.930
为此键入模型

00:48:26.790 --> 00:48:31.600
函数式接口是模型

00:48:28.930 --> 00:48:33.400
因为那是需要一个

00:48:31.600 --> 00:48:36.010
恰好相反的对象

00:48:33.400 --> 00:48:38.700
另一种类型的对象，让我们写

00:48:36.010 --> 00:48:38.700
这个功能

00:48:39.630 --> 00:48:50.109
我需要一个人返回一个字符串

00:48:44.979 --> 00:48:52.930
要叫它没有姓好吗

00:48:50.109 --> 00:48:54.700
如果发现我有一个人P 

00:48:52.930 --> 00:48:58.390
实施困难，我只能

00:48:54.700 --> 00:49:02.319
导航到此并复制粘贴任何内容

00:48:58.390 --> 00:49:06.960
我需要这种应用的方法

00:49:02.319 --> 00:49:06.960
直接去做需要一个人P 

00:49:08.759 --> 00:49:17.589
并立即呼叫获取姓氏

00:49:14.259 --> 00:49:20.259
我有这个功能来改变这个

00:49:17.589 --> 00:49:30.039
 p1变成姓氏我需要做什么

00:49:20.259 --> 00:49:32.039
是呼叫姓氏并将其应用于p1和

00:49:30.039 --> 00:49:40.119
在这里做同样的事情

00:49:32.039 --> 00:49:40.960
姓抱歉姓申请一些

00:49:40.119 --> 00:49:45.729
 p2在这里

00:49:40.960 --> 00:49:49.660
我不再需要这种方法了

00:49:45.729 --> 00:49:52.239
现在我的代码只取决于一种

00:49:49.660 --> 00:49:54.599
对象不是一个真正的对象，而是让

00:49:52.239 --> 00:49:59.349
我们这样称呼它

00:49:54.599 --> 00:50:03.279
我看到实际上所有这些代码如果

00:49:59.349 --> 00:50:05.589
我把它放在一个方法中，我可以转换

00:50:03.279 --> 00:50:07.599
如果我放入一个方法，它仅取决于

00:50:05.589 --> 00:50:11.410
这是我要去的姓氏

00:50:07.599 --> 00:50:18.869
使它全部运行表达式

00:50:11.410 --> 00:50:21.819
 IDS可以提取出来，这是

00:50:18.869 --> 00:50:27.489
这让我们把它弄得太长了

00:50:21.819 --> 00:50:30.009
表达好吧，因为我已经提取了

00:50:27.489 --> 00:50:32.049
将此代码转换为静态方法

00:50:30.009 --> 00:50:36.210
具有功能的工厂方法

00:50:32.049 --> 00:50:41.109
然后返回比较器写入

00:50:36.210 --> 00:50:44.019
作为lambda表达式，因此此方法

00:50:41.109 --> 00:50:48.460
称为提取物Erdem，因为它是

00:50:44.019 --> 00:50:51.920
工厂方法，因为我被允许

00:50:48.460 --> 00:50:55.600
放置静态因子

00:50:51.920 --> 00:50:58.850
在接口上我可以把它放在这里

00:50:55.600 --> 00:51:03.200
提取器此方法返回一个my 

00:50:58.850 --> 00:51:05.630
 T的比较器，因为它是静态的I 

00:51:03.200 --> 00:51:09.880
需要在这里声明类型，我是

00:51:05.630 --> 00:51:09.880
将其称为例如比较

00:51:12.010 --> 00:51:19.150
怎么了耶

00:51:19.310 --> 00:51:22.700
应该是这样

00:51:25.349 --> 00:51:34.359
所以现在我可以创建比较器了

00:51:31.960 --> 00:51:42.819
将此工厂方法称为我的

00:51:34.359 --> 00:51:44.440
比较器比较姓氏我不

00:51:42.819 --> 00:51:46.780
这里需要此静态方法，因为

00:51:44.440 --> 00:51:49.660
我已经将其移至我的编译器中

00:51:46.780 --> 00:51:51.280
界面，这个姓氏就是

00:51:49.660 --> 00:51:54.970
这个lambda表达式，所以我要

00:51:51.280 --> 00:51:57.250
点燃并移除此

00:51:54.970 --> 00:52:00.400
这次表达的方式

00:51:57.250 --> 00:52:02.829
作为方法参考返回

00:52:00.400 --> 00:52:04.540
 IDE可能一直在做那个人

00:52:02.829 --> 00:52:06.550
当前计数获取姓氏

00:52:04.540 --> 00:52:08.800
方法引用的另一种语法是

00:52:06.550 --> 00:52:11.020
只是编写lambda的另一种语法

00:52:08.800 --> 00:52:13.869
表达式，这是最终的

00:52:11.020 --> 00:52:15.760
模式以使用创建比较器

00:52:13.869 --> 00:52:18.369
那些工厂方法和lambda 

00:52:15.760 --> 00:52:20.559
表达式，如果我实际上检查代码

00:52:18.369 --> 00:52:23.619
所有创建的编译到

00:52:20.559 --> 00:52:26.500
我自己的API中现在使用lambda本身

00:52:23.619 --> 00:52:29.740
而不是在我的应用程序代码中

00:52:26.500 --> 00:52:33.640
如果我想通过以下方式使代码健壮

00:52:29.740 --> 00:52:36.099
检查姓氏是否为零

00:52:33.640 --> 00:52:39.640
我应该做的当然是

00:52:36.099 --> 00:52:47.230
抛出另一个实验指针

00:52:39.640 --> 00:52:57.339
例外，如果顺便说一句我在这里

00:52:47.230 --> 00:52:59.410
会好好叫那个提取器

00:52:57.339 --> 00:53:03.700
如果我想检查那个姓氏

00:52:59.410 --> 00:53:09.400
他们说这是s1，这不是s2 

00:53:03.700 --> 00:53:11.920
如果我想的话，需要姓

00:53:09.400 --> 00:53:16.510
检查s1或s2是否在我附近

00:53:11.920 --> 00:53:19.650
在我的API中，而不必降低

00:53:16.510 --> 00:53:22.119
我的应用程序代码的可读性

00:53:19.650 --> 00:53:23.920
但是我现在想做的是

00:53:22.119 --> 00:53:26.559
再走一步说好吧

00:53:23.920 --> 00:53:28.960
我两个的姓

00:53:26.559 --> 00:53:33.460
人是一样的，那么我想

00:53:28.960 --> 00:53:36.650
使用名字比较

00:53:33.460 --> 00:53:41.450
然后

00:53:36.650 --> 00:53:45.900
人呢

00:53:41.450 --> 00:53:48.769
名这个的状态是什么

00:53:45.900 --> 00:53:53.599
新方法然后比较明显

00:53:48.769 --> 00:53:57.240
它在比较器上被称为

00:53:53.599 --> 00:54:00.420
好吧，这是一个实例方法

00:53:57.240 --> 00:54:02.039
我的比较器接口

00:54:00.420 --> 00:54:05.099
与以前一样的问题

00:54:02.039 --> 00:54:08.069
有我们看到的

00:54:05.099 --> 00:54:09.900
我所有谓词的消费者，那么我

00:54:08.069 --> 00:54:13.319
可以做的就是创建这个然后比较

00:54:09.900 --> 00:54:16.740
方法作为my的默认方法

00:54:13.319 --> 00:54:19.200
比较器接口

00:54:16.740 --> 00:54:21.779
与

00:54:19.200 --> 00:54:25.019
工厂方法比较并返回

00:54:21.779 --> 00:54:32.940
也是我的T比较器，所以让我们做

00:54:25.019 --> 00:54:35.880
我说的那个默认值返回我的

00:54:32.940 --> 00:54:43.710
 T的比较器称为

00:54:35.880 --> 00:54:48.690
比较并采用一个函数

00:54:43.710 --> 00:54:51.779
两个T现在返回字符串Y 

00:54:48.690 --> 00:54:53.970
需要将它们返回的是比较器

00:54:51.779 --> 00:54:57.029
比较器是一个函数式接口， 

00:54:53.970 --> 00:54:58.339
这种方法的实现一次

00:54:57.029 --> 00:55:02.130
我又在做同样的事情

00:54:58.339 --> 00:55:06.779
复制并粘贴此参数块，然后

00:55:02.130 --> 00:55:11.579
返回一个整数，例如在

00:55:06.779 --> 00:55:13.079
至少它应该工作，现在不行

00:55:11.579 --> 00:55:15.989
我需要比这更聪明

00:55:13.079 --> 00:55:17.730
当然我应该先做什么

00:55:15.989 --> 00:55:21.839
需要比较使用

00:55:17.730 --> 00:55:25.220
比较器，我的意思是说得到

00:55:21.839 --> 00:55:31.470
比较T 1和T 2 

00:55:25.220 --> 00:55:33.539
现在，如果CMP等于零，那么我需要

00:55:31.470 --> 00:55:36.809
落在比较器上

00:55:33.539 --> 00:55:40.460
用过去建造是关键

00:55:36.809 --> 00:55:43.249
提取器，如果不是这种情况，我

00:55:40.460 --> 00:55:47.249
只需返回CM的值

00:55:43.249 --> 00:55:50.069
此代码消失了，我需要创建

00:55:47.249 --> 00:55:52.640
使用过去的密钥的另一个比较器

00:55:50.069 --> 00:55:58.859
那里的提取器，但我有这个

00:55:52.640 --> 00:56:04.739
该提取器的工厂方法

00:55:58.859 --> 00:56:07.950
我的TI比较器可以称之为吗

00:56:04.739 --> 00:56:13.499
其他并返回结果

00:56:07.950 --> 00:56:14.819
比较使用其他的好吧，这是

00:56:13.499 --> 00:56:17.369
一个可能的实现

00:56:14.819 --> 00:56:19.980
两者结合实施

00:56:17.369 --> 00:56:23.309
用两个不同的键创建比较器

00:56:19.980 --> 00:56:27.749
顺便提一下我也

00:56:23.309 --> 00:56:31.049
需要保护自己免受

00:56:27.749 --> 00:56:33.499
精神病患者尝试用弧线给我打电话

00:56:31.049 --> 00:56:36.630
提取器

00:56:33.499 --> 00:56:38.700
这个甚至应该是

00:56:36.630 --> 00:56:41.789
用三元运算符编写

00:56:38.700 --> 00:56:46.249
有点像三元运算符

00:56:41.789 --> 00:56:46.249
让我想起了我过去的C编程

00:56:50.089 --> 00:56:54.720
所以我等于零

00:56:52.739 --> 00:56:57.839
退回公司检察官

00:56:54.720 --> 00:57:01.380
比较器比较t 1和t 2以及

00:56:57.839 --> 00:57:03.619
如果不是这种情况，只需对此进行CMP 

00:57:01.380 --> 00:57:03.619
码

00:57:03.769 --> 00:57:06.769
几乎

00:57:14.349 --> 00:57:27.999
你怎么了，好吧，这是

00:57:24.940 --> 00:57:29.769
很好，所以您看到我们几乎完成了

00:57:27.999 --> 00:57:32.680
我们的程序你还记得这么大吗

00:57:29.769 --> 00:57:33.910
片不可读的烂Java 7等等

00:57:32.680 --> 00:57:36.430
等等等等代码向您展示了

00:57:33.910 --> 00:57:37.119
开始我们几乎我们几乎在那里我们

00:57:36.430 --> 00:57:38.949
快好了

00:57:37.119 --> 00:57:42.539
我们不在那里，因为我

00:57:38.949 --> 00:57:48.640
想做的就是比较一下

00:57:42.539 --> 00:57:52.029
使用年龄的人，这个

00:57:48.640 --> 00:57:55.029
不编译为什么因为年龄是一个

00:57:52.029 --> 00:57:57.130
整数，我写了代码

00:57:55.029 --> 00:57:59.979
需要一个字符串的函数

00:57:57.130 --> 00:58:03.819
将字符串写为参数，所以我

00:57:59.979 --> 00:58:06.299
需要深入研究更一般的地狱

00:58:03.819 --> 00:58:09.729
这是每个人都喜欢的东西

00:58:06.299 --> 00:58:11.219
当然，所以我要请客

00:58:09.729 --> 00:58:26.619
为了那个权利

00:58:11.219 --> 00:58:29.160
看看我该怎么做在这里，我

00:58:26.619 --> 00:58:29.160
要去

00:58:35.080 --> 00:58:41.950
永远不要告诉任何人你看到我这样做

00:58:37.900 --> 00:58:45.140
好吧，我要在这里做同样的事情

00:58:41.950 --> 00:58:48.230
鼓励你，所以我基本上知道我

00:58:45.140 --> 00:58:51.170
尝试做是好的，这不是一个

00:58:48.230 --> 00:58:55.210
字符串，这是任何类型的对象

00:58:51.170 --> 00:58:58.040
输入您的姓名，以便现在可以正常使用，因为

00:58:55.210 --> 00:58:59.960
因为这段代码可以编译，但是

00:58:58.040 --> 00:59:02.030
工厂方法执行的静态操作

00:58:59.960 --> 00:59:04.610
无法编译，因为您对此表示反对

00:59:02.030 --> 00:59:06.050
将需求与方法进行比较，并

00:59:04.610 --> 00:59:09.350
这种与方法的比较实际上是

00:59:06.050 --> 00:59:15.020
在可比接口上定义，因此

00:59:09.350 --> 00:59:20.330
你必须扩大可比性，如果你

00:59:15.020 --> 00:59:25.490
想要正确地使其具有可比性

00:59:20.330 --> 00:59:30.830
超级你某种理由欢迎您

00:59:25.490 --> 00:59:32.800
仿制药天堂好吧，如果我

00:59:30.830 --> 00:59:36.290
这样就可以了，并且

00:59:32.800 --> 00:59:40.490
代码将编译，因为整数是一个

00:59:36.290 --> 00:59:45.050
可比较的对象和字符串是和现在

00:59:40.490 --> 00:59:52.580
我的比较者可以是我什至可以

00:59:45.050 --> 00:59:54.140
像这样更进一步

00:59:52.580 --> 00:59:56.690
现在告诉我我有这个

00:59:54.140 --> 00:59:59.119
比较器实际上我想对我的排序

00:59:56.690 --> 01:00:00.950
学生反过来

00:59:59.119 --> 01:00:03.680
在这个上调用反向

01:00:00.950 --> 01:00:05.390
比较器如此再次反转我认为

01:00:03.680 --> 01:00:07.609
你现在有把戏了

01:00:05.390 --> 01:00:12.350
我的编译器界面的默认方法

01:00:07.609 --> 01:00:14.930
所以让我们写它，你会发现它是

01:00:12.350 --> 01:00:19.040
实际上很容易做到默认

01:00:14.930 --> 01:00:21.230
让我的T编译器返回ROI或

01:00:19.040 --> 01:00:24.890
与T比较的方法

01:00:21.230 --> 01:00:29.980
不带任何参数是什么

01:00:24.890 --> 01:00:33.920
返回是一个比较器，所以再次

01:00:29.980 --> 01:00:37.310
使用lambda实现，它

01:00:33.920 --> 01:00:40.760
返回结果的反面

01:00:37.310 --> 01:00:42.460
 t1和t2的比较

01:00:40.760 --> 01:00:45.460
相比

01:00:42.460 --> 01:00:50.260
你想我有两个窍门

01:00:45.460 --> 01:00:54.280
实现我在这里放减号

01:00:50.260 --> 01:00:56.290
它将颠倒比较或

01:00:54.280 --> 01:01:00.700
我不想把减号放在这里

01:00:56.290 --> 01:01:03.310
可以只比较t2和t1来实现

01:01:00.700 --> 01:01:04.930
同样的结果肯定是的-您不这样做

01:01:03.310 --> 01:01:09.220
两者都是因为如果两者都做，将不会

01:01:04.930 --> 01:01:11.710
当然可以工作，但是你可以

01:01:09.220 --> 01:01:13.390
选择我很确定

01:01:11.710 --> 01:01:16.300
你在想我是否认为如果我

01:01:13.390 --> 01:01:22.380
放-比我快

01:01:16.300 --> 01:01:22.380
好吧，我不知道这真的取决于你

01:01:23.339 --> 01:01:28.660
是的

01:01:25.780 --> 01:01:31.570
我也可以治疗其他工厂方法

01:01:28.660 --> 01:01:34.540
在这个比较器上的东西，例如我的

01:01:31.570 --> 01:01:41.099
比较器字符串

01:01:34.540 --> 01:01:41.099
 CMP-我想创建我的竞争对手

01:01:41.830 --> 01:01:46.230
 [音乐] 

01:01:43.230 --> 01:01:46.230
因为

01:01:50.160 --> 01:01:59.099
零，而您的幻想为零

01:01:57.119 --> 01:02:11.400
他们说这是一个静态

01:01:59.099 --> 01:02:16.609
我可以创建它的方法吗

01:02:11.400 --> 01:02:22.230
我将返回比较器

01:02:16.609 --> 01:02:25.460
将此字符串发送到并返回

01:02:22.230 --> 01:02:31.769
 s1与模型的比较

01:02:25.460 --> 01:02:40.140
返回抱歉，没有，所以没有道理

01:02:31.769 --> 01:02:41.910
我想让我们搞砸了

01:02:40.140 --> 01:02:44.069
是的，这是一个字符串，所以让我们

01:02:41.910 --> 01:02:50.700
假设我们只想比较

01:02:44.069 --> 01:02:51.799
那些使用自然顺序的字符串

01:02:50.700 --> 01:02:54.329
改变对不起

01:02:51.799 --> 01:02:56.789
所以对于混乱我要改变

01:02:54.329 --> 01:02:58.890
这个例子还可以，因为字符串是

01:02:56.789 --> 01:03:01.410
已经是可比较对象的共同点

01:02:58.890 --> 01:03:04.200
所以我可以使用自然顺序

01:03:01.410 --> 01:03:10.289
这将是像

01:03:04.200 --> 01:03:11.910
与之相比， 

01:03:10.289 --> 01:03:19.670
我可以做任何事情的方式

01:03:11.910 --> 01:03:22.670
可扩展的对象

01:03:19.670 --> 01:03:22.670
可比

01:03:23.119 --> 01:03:28.029
对不起，是的

01:03:28.960 --> 01:03:32.200
我们完成了

01:03:34.810 --> 01:03:47.870
好，你问考试对不起，你问

01:03:40.520 --> 01:03:50.000
扩展可比性，因为我

01:03:47.870 --> 01:03:52.100
做的是使用此比较方法

01:03:50.000 --> 01:03:54.770
正是在

01:03:52.100 --> 01:03:57.110
可比的界面应变工具

01:03:54.770 --> 01:04:00.770
可比的是与

01:03:57.110 --> 01:04:03.470
和我去的时候一样

01:04:00.770 --> 01:04:05.210
从字符串到你到我

01:04:03.470 --> 01:04:07.520
并不是说您扩展了可比性

01:04:05.210 --> 01:04:09.050
你挑剔回到对象，我不

01:04:07.520 --> 01:04:11.510
与没有一个对象相比

01:04:09.050 --> 01:04:15.320
这就是为什么我不能使用比较

01:04:11.510 --> 01:04:18.170
这里的方法我是说你扩展

01:04:15.320 --> 01:04:19.790
可比的和这种可比的方法

01:04:18.170 --> 01:04:28.040
顺便说一下函数式接口

01:04:19.790 --> 01:04:30.140
有compareto方法，所以这是另一个

01:04:28.040 --> 01:04:32.930
在上创建工厂方法的方法

01:04:30.140 --> 01:04:36.350
比较器接口是的，我们可以

01:04:32.930 --> 01:04:38.830
 -我们可以快速浏览一下

01:04:36.350 --> 01:04:43.430
来自GDK的比较器接口八

01:04:38.830 --> 01:04:47.900
它像往常一样具有compareto方法， 

01:04:43.430 --> 01:04:49.790
在那五百行之后

01:04:47.900 --> 01:04:52.100
五百行默认和静态

01:04:49.790 --> 01:04:54.380
五种创建比较器的方法

01:04:52.100 --> 01:04:56.560
方法，并结合在一起

01:04:54.380 --> 01:04:56.560
他们

01:05:01.700 --> 01:05:10.010
好的，所以我们看到了如何使用默认值

01:05:07.609 --> 01:05:12.589
组合和组成的方法

01:05:10.010 --> 01:05:15.290
谓词和比较器，如何使用

01:05:12.589 --> 01:05:17.630
创建实例的工厂方法

01:05:15.290 --> 01:05:22.549
没有任何lambda表达式

01:05:17.630 --> 01:05:25.549
一种复杂的东西在编码器中泄漏

01:05:22.549 --> 01:05:28.250
让我们更进一步

01:05:25.549 --> 01:05:30.619
我一直在使用方法引用

01:05:28.250 --> 01:05:35.180
代码，我可以向您展示其他示例

01:05:30.619 --> 01:05:39.109
那是因为我们写的lambda 

01:05:35.180 --> 01:05:42.200
实际上方法引用这是一个

01:05:39.109 --> 01:05:45.049
方法参考我有这个魔力

01:05:42.200 --> 01:05:46.730
 Eclipse控件1中的快捷方式，如果

01:05:45.049 --> 01:05:50.599
 lambda是您选择的方法参考

01:05:46.730 --> 01:05:54.140
它控制1，它将为您提供

01:05:50.599 --> 01:05:55.819
直接使其实现的可能性

01:05:54.140 --> 01:06:01.099
方法参考这也是

01:05:55.819 --> 01:06:03.670
测量参考并猜测这是什么

01:06:01.099 --> 01:06:03.670
一个也是

01:06:06.210 --> 01:06:11.299
哦，这是给我参考的

01:06:11.690 --> 01:06:19.109
在这里，下一个不是

01:06:16.010 --> 01:06:21.119
好，所以有四种方法

01:06:19.109 --> 01:06:22.190
参考我已经把他们放在这个

01:06:21.119 --> 01:06:24.930
表

01:06:22.190 --> 01:06:26.760
静态绑定实例未绑定实例

01:06:24.930 --> 01:06:30.059
构造函数将在

01:06:26.760 --> 01:06:32.849
一分钟，我还给你举了一些例子

01:06:30.059 --> 01:06:38.609
如何从lambda传递给方法

01:06:32.849 --> 01:06:43.190
为了参考案例

01:06:38.609 --> 01:06:45.299
幻灯片将是可变的slideshare I 

01:06:43.190 --> 01:06:47.339
猜猜你们都知道这本书是

01:06:45.299 --> 01:06:51.210
叫做“四人帮”，有一堆

01:06:47.339 --> 01:06:52.799
的奇妙图案，我们不是

01:06:51.210 --> 01:06:54.539
要谈论所有这些模式

01:06:52.799 --> 01:06:56.609
但我想告诉你的是

01:06:54.539 --> 01:06:59.609
只是关于如何实施一些提示

01:06:56.609 --> 01:07:02.369
使用lambda表达式的那些模式

01:06:59.609 --> 01:07:05.069
中的默认方法和工厂方法

01:07:02.369 --> 01:07:12.299
非常有效的方法

01:07:05.069 --> 01:07:14.710
我喜欢这个的工厂模式

01:07:12.299 --> 01:07:20.290
厂

01:07:14.710 --> 01:07:22.510
关闭这个，所以我创建了一个类

01:07:20.290 --> 01:07:32.740
是一家工厂，对工厂没有多大帮助

01:07:22.510 --> 01:07:36.100
现在是我要使用的那个

01:07:32.740 --> 01:07:39.790
打算用这个小班

01:07:36.100 --> 01:07:41.500
我想做什么工厂好

01:07:39.790 --> 01:07:44.770
建立工厂

01:07:41.500 --> 01:07:47.260
我还有其他几个对象

01:07:44.770 --> 01:07:49.540
我在我的模型包中的形状是

01:07:47.260 --> 01:07:52.530
形状对象只是一个抽象

01:07:49.540 --> 01:07:55.750
形状里面没有东西

01:07:52.530 --> 01:07:58.090
用两个形状扩展的类

01:07:55.750 --> 01:08:00.820
需要一个空的构造函数

01:07:58.090 --> 01:08:06.430
另一种颜色

01:08:00.820 --> 01:08:11.080
还有一个正方形和一个三角形类

01:08:06.430 --> 01:08:15.190
使用我应该如何使用工厂

01:08:11.080 --> 01:08:18.120
如果我想反对，这是我的工厂

01:08:15.190 --> 01:08:22.180
创建一个所谓的圆形工厂

01:08:18.120 --> 01:08:29.110
工厂基本上是我期望的

01:08:22.180 --> 01:08:32.170
这个不知道怎么办的工厂

01:08:29.110 --> 01:08:34.660
创建它，但是我期望从中得到什么

01:08:32.170 --> 01:08:37.840
这个工厂可以调用方法

01:08:34.660 --> 01:08:43.030
假设要使用的get方法

01:08:37.840 --> 01:08:46.510
返回，所以他们说这是基本的

01:08:43.030 --> 01:08:50.590
如果我现在如何使用工厂的模式

01:08:46.510 --> 01:08:52.000
看一下这段代码，如果我

01:08:50.590 --> 01:08:57.690
从中看这段代码

01:08:52.000 --> 01:09:00.640
 Lambda透视图，这里的get方法

01:08:57.690 --> 01:09:03.160
不带任何参数，而是

01:09:00.640 --> 01:09:05.050
返回一个对象，所以如果您还记得

01:09:03.160 --> 01:09:08.320
 lambda表达式四类我

01:09:05.050 --> 01:09:11.290
有这个供应商，不需要

01:09:08.320 --> 01:09:15.010
任何东西都会创建一个对象，所以这意味着

01:09:11.290 --> 01:09:17.350
我的工厂实际上不在

01:09:15.010 --> 01:09:21.210
一个类可能是一个接口

01:09:17.350 --> 01:09:21.210
延伸

01:09:21.640 --> 01:09:31.030
茶和奶酪的供应商

01:09:28.900 --> 01:09:33.340
非常好，因为它具有get方法

01:09:31.030 --> 01:09:37.560
那并不需要任何东西

01:09:33.340 --> 01:09:40.440
这会产生一些东西，所以如果我想

01:09:37.560 --> 01:09:46.450
创建该工厂的实现

01:09:40.440 --> 01:09:50.560
所以我们还是一样

01:09:46.450 --> 01:09:52.530
参数，我应该返回什么

01:09:50.560 --> 01:09:56.200
一个新圈子

01:09:52.530 --> 01:09:59.200
所以基本上这是一家工厂

01:09:56.200 --> 01:10:01.950
海湾地区在7月使用Lambda实施

01:09:59.200 --> 01:10:04.960
顺便说一句，这也是

01:10:01.950 --> 01:10:09.070
我来的构造方法参考

01:10:04.960 --> 01:10:12.220
我可以这样写

01:10:09.070 --> 01:10:16.290
我可以很好地与这家工厂合作

01:10:12.220 --> 01:10:26.550
举例说，好吧，工厂

01:10:16.290 --> 01:10:26.550
在清单上给我五个圆圈

01:10:28.900 --> 01:10:33.030
五圈

01:10:38.470 --> 01:10:43.130
这是什么get方法，不是

01:10:41.690 --> 01:10:45.830
与不使用的get方法相同

01:10:43.130 --> 01:10:49.310
接受任何参数，这是定义的方法

01:10:45.830 --> 01:10:53.510
以工厂为例，所以一次

01:10:49.310 --> 01:10:56.540
再次，这是默认方法，所以我

01:10:53.510 --> 01:11:00.590
可以在这里创建默认方法

01:10:56.540 --> 01:11:06.710
在T列表上对待

01:11:00.590 --> 01:11:11.690
整数，让我们将其写入您的列表

01:11:06.710 --> 01:11:14.060
只是要编译这是一个列表

01:11:11.690 --> 01:11:18.590
这是在您的列表中，仅此而已

01:11:14.060 --> 01:11:21.950
至少现在编译我应该是什么

01:11:18.590 --> 01:11:24.890
在此过程中创建五个圈子， 

01:11:21.950 --> 01:11:29.240
将它们放在列表中，我可以创建一个

01:11:24.890 --> 01:11:33.920
跟进，但我使用Java 8，所以我已经

01:11:29.240 --> 01:11:38.950
得到了这个不错的流对象然后可以

01:11:33.920 --> 01:11:44.030
为我创建n个整数流

01:11:38.950 --> 01:11:47.650
可以将流映射到对象

01:11:44.030 --> 01:11:49.970
索引返回，您看到了新的抱歉

01:11:47.650 --> 01:11:53.000
返回这个的新实例

01:11:49.970 --> 01:11:57.110
工厂可以创建一个称为

01:11:53.000 --> 01:12:04.600
权宜之计可以将其放在此处

01:11:57.110 --> 01:12:04.600
并放入结果列表

01:12:05.650 --> 01:12:11.320
只是返回for循环是如此

01:12:10.510 --> 01:12:14.950
 Java 8 

01:12:11.320 --> 01:12:17.080
 Java 7对不起，所以这只是一个

01:12:14.950 --> 01:12:22.770
线到创建这个东西， 

01:12:17.080 --> 01:12:22.770
如果我在工厂运行此代码

01:12:26.080 --> 01:12:42.610
每个系统五个圈

01:12:36.090 --> 01:12:45.220
打印机N代码，并得到我所有的五个

01:12:42.610 --> 01:12:48.820
使用此默认设置创建的圈子

01:12:45.220 --> 01:12:50.650
现在我有另一个构造函数的方法是

01:12:48.820 --> 01:12:53.590
我在我的圈子中

01:12:50.650 --> 01:12:56.230
假设颜色是参数

01:12:53.590 --> 01:13:00.600
我现在想做的是

01:12:56.230 --> 01:13:06.670
例如创建红色红色圆圈

01:13:00.600 --> 01:13:23.370
红圈工厂不带

01:13:06.670 --> 01:13:23.370
任何东西，你称之为这是

01:13:24.810 --> 01:13:35.860
创建代码的方式只是复制粘贴

01:13:29.320 --> 01:13:44.050
代码五这是五个红色圆圈

01:13:35.860 --> 01:13:47.110
这段代码，然后如果我运行这段代码， 

01:13:44.050 --> 01:13:49.990
先有五个正常的圈子，然后

01:13:47.110 --> 01:13:52.720
来自工厂的五个红色圆圈

01:13:49.990 --> 01:13:54.970
我可以添加尽可能多的默认方法

01:13:52.720 --> 01:13:56.530
我需要创建更多东西来添加

01:13:54.970 --> 01:13:59.440
我到我工厂的功能

01:13:56.530 --> 01:14:01.330
哪个好不是那个好

01:13:59.440 --> 01:14:04.180
此代码的编写方式

01:14:01.330 --> 01:14:06.790
因为事实上我在做什么

01:14:04.180 --> 01:14:09.760
这是放在供应商内部

01:14:06.790 --> 01:14:11.560
我想作为一个参数传递

01:14:09.760 --> 01:14:13.780
参数实际上是另一种方法

01:14:11.560 --> 01:14:17.230
会不会，我不太满意

01:14:13.780 --> 01:14:22.180
这段代码我最好这样写

01:14:17.230 --> 01:14:26.110
我更喜欢像Factory这样写

01:14:22.180 --> 01:14:31.350
说好吧，我将构造函数作为

01:14:26.110 --> 01:14:36.390
参数新所谓的颜色和

01:14:31.350 --> 01:14:39.330
然后将颜色也作为参数传递

01:14:36.390 --> 01:14:42.910
好的，这就是我想做的

01:14:39.330 --> 01:14:44.980
工厂并通过例如

01:14:42.910 --> 01:14:48.810
工厂方法到工厂

01:14:44.980 --> 01:14:51.250
类本身，所以这里的创建方法

01:14:48.810 --> 01:14:55.540
用工厂的静态方法

01:14:51.250 --> 01:15:07.030
我们一直在做的课，以返回

01:14:55.540 --> 01:15:09.610
工厂需要的工厂是

01:15:07.030 --> 01:15:11.680
这以汽车为参数， 

01:15:09.610 --> 01:15:13.840
返回此代码零，所以这是一个

01:15:11.680 --> 01:15:21.610
函数需要一个对象返回

01:15:13.840 --> 01:15:25.300
节点类型创建的对象需要一个

01:15:21.610 --> 01:15:28.060
我们将要实现的功能

01:15:25.300 --> 01:15:29.740
这是一个工厂界，所以我

01:15:28.060 --> 01:15:30.220
打算这样写

01:15:29.740 --> 01:15:34.900
更轻松

01:15:30.220 --> 01:15:39.550
它使用颜色作为参数， 

01:15:34.900 --> 01:15:43.360
圈我一圈，这实际上是我的

01:15:39.550 --> 01:15:47.470
构造函数并将颜色作为

01:15:43.360 --> 01:15:50.290
参数，应该是我要

01:15:47.470 --> 01:15:55.510
回到这里，应该

01:15:50.290 --> 01:15:57.940
应该返回，这应该返回

01:15:55.510 --> 01:16:01.930
工厂是没有的

01:15:57.940 --> 01:16:06.880
接受任何论点并返回工厂

01:16:01.930 --> 01:16:10.120
圈，因此我实际上需要

01:16:06.880 --> 01:16:14.860
带上我的构造函数并应用颜色

01:16:10.120 --> 01:16:17.140
在这里我要做的是一个

01:16:14.860 --> 01:16:20.950
我进行的非常重要的预备手术

01:16:17.140 --> 01:16:23.410
一个功能，并使其成为供应商

01:16:20.950 --> 01:16:26.460
固定该函数的参数

01:16:23.410 --> 01:16:28.540
对，这是第二个基本原则

01:16:26.460 --> 01:16:30.700
功能编程中的操作

01:16:28.540 --> 01:16:32.860
第一个是组成，第二个

01:16:30.700 --> 01:16:34.540
一种是我的部分应用

01:16:32.860 --> 01:16:36.610
在这里完成的是部分应用

01:16:34.540 --> 01:16:39.250
减少数量的功能

01:16:36.610 --> 01:16:42.460
带有日期的参数

01:16:39.250 --> 01:16:46.510
因为此功能只需要一个

01:16:42.460 --> 01:16:47.380
参数吹给我一个供应商

01:16:46.510 --> 01:16:51.100
和这个

01:16:47.380 --> 01:16:52.989
正是我现在所做的，我的工厂可以

01:16:51.100 --> 01:16:56.440
返回我仍然在工作

01:16:52.989 --> 01:17:00.760
好的，这很好，因为

01:16:56.440 --> 01:17:03.570
这也是我可以的方法参考

01:17:00.760 --> 01:17:06.100
这样写，它给了我一个

01:17:03.570 --> 01:17:08.440
非常干净的图案，因为如果我

01:17:06.100 --> 01:17:11.679
比较这里的两种模式

01:17:08.440 --> 01:17:13.360
这圈圈列列新

01:17:11.679 --> 01:17:16.719
即使没有

01:17:13.360 --> 01:17:21.100
代表同一件事，这是一些

01:17:16.719 --> 01:17:23.380
带有方法引用的陷阱是

01:17:21.100 --> 01:17:27.179
如果您不知道类型

01:17:23.380 --> 01:17:29.679
您无法真正知道的方法参考

01:17:27.179 --> 01:17:32.409
该方法的确切参考是什么

01:17:29.679 --> 01:17:35.590
你看这里我有一个方法参考

01:17:32.409 --> 01:17:37.300
那是供应商，这是

01:17:35.590 --> 01:17:39.429
相同的方法引用相同

01:17:37.300 --> 01:17:41.440
供参考的字符串

01:17:39.429 --> 01:17:43.179
但这是一个功能，它是不一样的

01:17:41.440 --> 01:17:47.050
类型，它不会做同样的事情

01:17:43.179 --> 01:17:49.840
正确，如果我控制点击此新按钮

01:17:47.050 --> 01:17:52.360
在这里它将带我空虚

01:17:49.840 --> 01:17:54.760
圆的构造函数不需要

01:17:52.360 --> 01:17:59.550
任何参数写的东西是

01:17:54.760 --> 01:18:01.900
供应商，如果我检查其他

01:17:59.550 --> 01:18:04.389
如果我控制点击，方法参考在这里

01:18:01.900 --> 01:18:06.040
在这个新对象上，这里是新代码

01:18:04.389 --> 01:18:08.139
它带我到构造函数

01:18:06.040 --> 01:18:10.170
接受一个参数，因为

01:18:08.139 --> 01:18:13.060
这个方法参考不一样

01:18:10.170 --> 01:18:15.730
好吧，我怎么知道这不是

01:18:13.060 --> 01:18:19.030
一样，因为这里的创建方法

01:18:15.730 --> 01:18:21.730
需要一个功能而不是为了生存

01:18:19.030 --> 01:18:24.840
到底是什么招要小心

01:18:21.730 --> 01:18:24.840
与那些金属参考

01:18:28.120 --> 01:18:36.890
好吧，我认为我们已经完成了工厂

01:18:30.890 --> 01:18:39.250
那是在下一个模式，我会

01:18:36.890 --> 01:18:43.790
想要表明您是注册表， 

01:18:39.250 --> 01:18:45.280
在建造者模式下登记

01:18:43.790 --> 01:18:58.190
按钮是一个非常好的模式

01:18:45.280 --> 01:19:00.350
是的演示时间再次如此

01:18:58.190 --> 01:19:02.840
我想做的是创建一个

01:19:00.350 --> 01:19:06.830
注册表事实将创建的工厂

01:19:02.840 --> 01:19:08.870
提供一些对象的实例

01:19:06.830 --> 01:19:11.060
可以说我想要什么的钥匙

01:19:08.870 --> 01:19:12.560
是一个圆，我想要的是一个三角形

01:19:11.060 --> 01:19:15.940
我想要的是一个类似正方形的东西

01:19:12.560 --> 01:19:19.280
如果我做这种事， 

01:19:15.940 --> 01:19:34.480
可能最终会写这种

01:19:19.280 --> 01:19:36.620
代码切换键（如果我的键是一个圆圈） 

01:19:34.480 --> 01:19:42.590
我知道我想做的是

01:19:36.620 --> 01:19:47.510
我要归还新工厂

01:19:42.590 --> 01:19:55.760
如果我得到的是一个三角形则圈一下

01:19:47.510 --> 01:20:05.360
我想返回一个工厂三角形

01:19:55.760 --> 01:20:07.780
这个，如果我有一个正方形，或者我想要

01:20:05.360 --> 01:20:07.780
返回

01:20:09.300 --> 01:20:12.630
他是一个正方形

01:20:30.730 --> 01:20:37.810
如果我想要下面它应该是一个形状

01:20:34.510 --> 01:20:39.280
默认权默认值，如果我不这样做

01:20:37.810 --> 01:20:44.880
有什么我想做的就是

01:20:39.280 --> 01:20:44.880
抛出新的非法论证异常

01:20:51.550 --> 01:20:54.570
什么也没有

01:21:06.800 --> 01:21:10.630
那是一家啤酒厂

01:21:12.450 --> 01:21:16.310
眉山这一个

01:21:17.180 --> 01:21:29.510
好的

01:21:18.769 --> 01:21:40.239
所以这没关系，我要去

01:21:29.510 --> 01:21:43.219
是的，所以在这里我有这个

01:21:40.239 --> 01:21:50.300
所以在这里我要创造我的形状

01:21:43.219 --> 01:21:54.050
工厂运送回您的形状

01:21:50.300 --> 01:21:59.260
等于新形状工厂的权利

01:21:54.050 --> 01:22:11.929
如果我叫形状工厂，那么创建

01:21:59.260 --> 01:22:14.329
将每个圆圈圈起来，是的，我要画画

01:22:11.929 --> 01:22:20.539
在这里的形状是不正确的

01:22:14.329 --> 01:22:29.409
形状创建好了，所以这

01:22:20.539 --> 01:22:29.409
是我我的圈子工厂

01:22:30.280 --> 01:22:37.340
我想把它丢进工厂

01:22:33.170 --> 01:22:39.969
因为我得到的实际上是一个

01:22:37.340 --> 01:22:39.969
工厂机器

01:22:46.079 --> 01:22:50.800
对

01:22:47.660 --> 01:22:50.800
我们很高兴

01:22:54.189 --> 01:23:03.760
好吧，像这样，我很有趣

01:23:00.269 --> 01:23:06.880
警告，让我们摆脱与

01:23:03.760 --> 01:23:10.119
这种由

01:23:06.880 --> 01:23:14.499
 GDK取消警告未选中，是的，我

01:23:10.119 --> 01:23:16.840
知道我在做什么，所以这是这个

01:23:14.499 --> 01:23:20.079
基本上是我们的注册表模式

01:23:16.840 --> 01:23:22.269
所有人在我们的应用程序中看到的可能是

01:23:20.079 --> 01:23:24.999
不是以这种确切的形式，而是基本上

01:23:22.269 --> 01:23:27.219
这就是我们所能做到的

01:23:24.999 --> 01:23:29.289
你看到这个注册表模式吗

01:23:27.219 --> 01:23:30.429
可以用一种方式创造好

01:23:29.289 --> 01:23:34.419
在之前的工厂中创建

01:23:30.429 --> 01:23:37.809
基本上是这个的例子

01:23:34.419 --> 01:23:40.419
一个，如果我想创建一个

01:23:37.809 --> 01:23:42.610
例如我想要的一个家

01:23:40.419 --> 01:23:44.919
一路返回相同的三角形

01:23:42.610 --> 01:23:47.320
如果我在这家工厂的话

01:23:44.919 --> 01:23:48.459
我每次都会返回一个新的三角形

01:23:47.320 --> 01:23:51.159
我叫这个工厂

01:23:48.459 --> 01:23:53.789
但是如果我想让它变成单音

01:23:51.159 --> 01:23:53.789
可以

01:23:55.730 --> 01:24:04.489
只是创建一个三角形作为私人

01:24:01.400 --> 01:24:10.600
哦，这不是静态的，所以我可以做到

01:24:04.489 --> 01:24:10.600
像那个三角形等于新三角形

01:24:10.690 --> 01:24:19.760
而随着走板收益总是

01:24:17.090 --> 01:24:21.080
与我的供应商相同的三角形

01:24:19.760 --> 01:24:23.330
将是

01:24:21.080 --> 01:24:24.980
单例模式作为单例模式

01:24:23.330 --> 01:24:27.140
可能不是最好的模式

01:24:24.980 --> 01:24:29.180
世界，但您仍然可以实现它

01:24:27.140 --> 01:24:32.300
使用这种金发女郎

01:24:29.180 --> 01:24:35.390
表达什么不是那么好

01:24:32.300 --> 01:24:37.489
这种写东西的方式是

01:24:35.390 --> 01:24:43.970
网格不是那么好，如果我

01:24:37.489 --> 01:24:46.900
想要将它们添加到我到我的

01:24:43.970 --> 01:24:49.640
注册表我需要修改此代码

01:24:46.900 --> 01:24:51.710
重新编译它重新编译我一生

01:24:49.640 --> 01:24:55.520
应用程序和需要II的任何地方

01:24:51.710 --> 01:24:59.170
我正在使用此注册表我们重写我的

01:24:55.520 --> 01:25:01.850
代码无处不在，这不是很好

01:24:59.170 --> 01:25:06.770
我怎么能说非常非常有活力

01:25:01.850 --> 01:25:09.440
注册管理机构的方式我是什么

01:25:06.770 --> 01:25:13.310
大多数情况下，人们会这样做

01:25:09.440 --> 01:25:17.000
是要用宾果图案

01:25:13.310 --> 01:25:19.580
到这里的建设者是这个类

01:25:17.000 --> 01:25:23.600
构建器模式首先需要两个步骤

01:25:19.580 --> 01:25:26.780
步骤我将元素添加到注册表中， 

01:25:23.600 --> 01:25:30.710
然后第二步，我使用我的注册表

01:25:26.780 --> 01:25:38.590
是通过调用big方法并使用

01:25:30.710 --> 01:25:38.590
这个Jai工厂，我们可以

01:25:40.920 --> 01:25:47.710
我要把这个放在这里

01:25:43.830 --> 01:25:52.719
所以我可以如何使用这个生成器

01:25:47.710 --> 01:25:55.420
模式，但很多建设者在哪里

01:25:52.719 --> 01:25:58.530
是次要的感谢

01:25:55.420 --> 01:26:06.960
对一个建筑商来说，这有点

01:25:58.530 --> 01:26:09.790
有点像新的投标人

01:26:06.960 --> 01:26:16.510
好的，所以第一步我要添加

01:26:09.790 --> 01:26:23.739
所谓的我是圈子的工厂

01:26:16.510 --> 01:26:26.219
所谓的你和

01:26:23.739 --> 01:26:26.219
三角形

01:26:31.720 --> 01:26:41.800
谢谢剪辑稍后再做零

01:26:38.490 --> 01:26:46.320
没有另一个三角形， 

01:26:41.800 --> 01:26:46.320
相同的四个正方形

01:26:52.219 --> 01:26:59.360
就像那样，现在我的建造者

01:26:55.999 --> 01:27:05.119
完成了，我只是把大东西叫做

01:26:59.360 --> 01:27:07.309
在其上构建方法以创建我的外壳

01:27:05.119 --> 01:27:09.170
工厂和那个芯片工厂

01:27:07.309 --> 01:27:12.079
将能够创建我的工厂， 

01:27:09.170 --> 01:27:14.239
用我的工厂，因为我的意思是

01:27:12.079 --> 01:27:17.420
模式的使用方式

01:27:14.239 --> 01:27:20.619
行业本身，如果我检查

01:27:17.420 --> 01:27:24.249
流接口，我有一个生成器

01:27:20.619 --> 01:27:28.280
扩展消费者的成员接口

01:27:24.249 --> 01:27:30.949
我可以在其中添加元素

01:27:28.280 --> 01:27:33.530
这是该构建器的元素

01:27:30.949 --> 01:27:35.499
完成，我刚刚获得了Builder方法

01:27:33.530 --> 01:27:37.969
该构建器可以创建流

01:27:35.499 --> 01:27:41.179
加上我添加到的所有元素

01:27:37.969 --> 01:27:43.849
投标人的问题是，一旦我

01:27:41.179 --> 01:27:46.550
已经调用了我无法建立的方法

01:27:43.849 --> 01:27:51.019
称他们为add方法了，所以这

01:27:46.550 --> 01:27:53.360
对象必须记住状态好，我在

01:27:51.019 --> 01:27:55.760
我认为构建模式相当于我的

01:27:53.360 --> 01:27:57.920
生成器，然后我创建了

01:27:55.760 --> 01:27:59.929
我正在建造的物体，所以我不在

01:27:57.920 --> 01:28:03.590
构建模式，有人造成了

01:27:59.929 --> 01:28:04.940
再次添加对象，我应该提出一个

01:28:03.590 --> 01:28:07.579
例外或类似的东西

01:28:04.940 --> 01:28:09.590
告诉别人这个的例外

01:28:07.579 --> 01:28:12.260
构建器完成，您无法再添加

01:28:09.590 --> 01:28:14.239
元素，所以如果我回到

01:28:12.260 --> 01:28:16.420
我的模式我实际上有确切的

01:28:14.239 --> 01:28:19.610
这种模式的相同问题是

01:28:16.420 --> 01:28:22.460
一旦我在这里调用此账单方法

01:28:19.610 --> 01:28:24.229
我需要创建某种内部

01:28:22.460 --> 01:28:26.630
确保没有人是的机制

01:28:24.229 --> 01:28:29.650
要为此添加更多对象

01:28:26.630 --> 01:28:31.760
建设者，这可能很复杂

01:28:29.650 --> 01:28:33.110
首先，您需要编写这段代码

01:28:31.760 --> 01:28:36.320
这不是那么简单

01:28:33.110 --> 01:28:39.289
其次，您需要考虑其他

01:28:36.320 --> 01:28:42.979
人们可以使用反射进行访问

01:28:39.289 --> 01:28:45.320
到您的内部注册表其他线程

01:28:42.979 --> 01:28:47.510
可能也一样，所以你需要

01:28:45.320 --> 01:28:49.369
处理所有这类情况，如果您

01:28:47.510 --> 01:28:51.050
不想在您的任何错误

01:28:49.369 --> 01:28:57.099
他们说这不是那个应用

01:28:51.050 --> 01:28:57.099
现在好极了

01:28:57.360 --> 01:29:04.750
使这个使这个模式更好

01:29:01.020 --> 01:29:09.480
首先要精确地使用数字

01:29:04.750 --> 01:29:14.650
可以看到的是这里的形状工厂

01:29:09.480 --> 01:29:17.590
因为实际上只有一种实现方法

01:29:14.650 --> 01:29:20.200
在这里，当你有一堂课

01:29:17.590 --> 01:29:21.700
只有一种方法可以实现

01:29:20.200 --> 01:29:23.470
你心里有话要告诉你

01:29:21.700 --> 01:29:25.570
哦，也许我可以使其成为一个界面

01:29:23.470 --> 01:29:27.660
并使用lambda实现

01:29:25.570 --> 01:29:32.100
因为大多数时候都有可能

01:29:27.660 --> 01:29:39.550
我将这个形状称为工厂

01:29:32.100 --> 01:29:43.530
需要重命名它遗留的遗留形状

01:29:39.550 --> 01:29:52.230
工厂，我要创建另一个

01:29:43.530 --> 01:29:52.230
形状工厂作为界面

01:29:56.159 --> 01:30:00.960
我只是保持相同的方法

01:29:58.080 --> 01:30:06.860
在这里谢谢你

01:30:00.960 --> 01:30:06.860
你这样吗

01:30:09.460 --> 01:30:14.590
您可以看到此代码仍然

01:30:11.560 --> 01:30:18.420
还是顺便编译是的，因为

01:30:14.590 --> 01:30:18.420
它现在建立在纯粹的工厂上

01:30:31.219 --> 01:30:34.849
它保持请

01:30:38.869 --> 01:30:46.480
他在做什么不想导入

01:30:43.480 --> 01:30:46.480
重构

01:30:51.069 --> 01:30:56.699
相信这是他做的

01:31:08.940 --> 01:31:22.230
哦，是一些公众对不起吗， 

01:31:20.370 --> 01:31:26.820
这笔账单将要归还

01:31:22.230 --> 01:31:30.540
船厂是好的，所以我的形状

01:31:26.820 --> 01:31:33.030
因素是现在是现在，现在我需要

01:31:30.540 --> 01:31:36.450
面对，我将使用

01:31:33.030 --> 01:31:40.290
一名木材现在承认这是怎么回事

01:31:36.450 --> 01:31:42.180
要做好，就必须把它放进去

01:31:40.290 --> 01:31:45.750
某种注册表，让我们创建

01:31:42.180 --> 01:31:50.990
那是自然的方式

01:31:45.750 --> 01:31:50.990
这样做是陌生人和工厂的地图

01:31:52.400 --> 01:32:02.550
洗地图确定时T注册表的内容和

01:32:00.000 --> 01:32:14.610
我要做的就是添加这个

01:32:02.550 --> 01:32:16.410
注册表把是关键，现在当我

01:32:14.610 --> 01:32:17.880
建立我需要的东西

01:32:16.410 --> 01:32:21.060
回报是一个形状工厂

01:32:17.880 --> 01:32:23.850
这个形状工厂是什么

01:32:21.060 --> 01:32:26.760
功能正常的界面

01:32:23.850 --> 01:32:29.390
使用lambda实现我如何

01:32:26.760 --> 01:32:35.540
使用lambda实现

01:32:29.390 --> 01:32:35.540
只需复制粘贴参数块

01:32:43.949 --> 01:32:51.980
从那个钥匙我需要得到

01:32:48.060 --> 01:32:54.510
工厂在这里，因为这很抱歉

01:32:51.980 --> 01:32:57.870
此实现返回工厂

01:32:54.510 --> 01:33:02.390
还有地图上的工厂

01:32:57.870 --> 01:33:02.390
有点东西注册表，但得到

01:33:27.030 --> 01:33:35.360
与通用的东西麻烦

01:33:32.239 --> 01:33:35.360
劳驾

01:33:37.469 --> 01:33:46.320
尝试决赛是我的一切

01:33:55.540 --> 01:34:05.179
好的，所以实际上这个账单方法只是

01:34:00.110 --> 01:34:07.630
我要像你一样

01:34:05.179 --> 01:34:13.670
看到我要复制粘贴此代码

01:34:07.630 --> 01:34:17.449
在这里重复，因为实际上这段代码是

01:34:13.670 --> 01:34:20.480
方法引用，这只是一个获取

01:34:17.449 --> 01:34:22.130
我的注册方法，这是

01:34:20.480 --> 01:34:24.409
比尔做切斯特实际上是什么

01:34:22.130 --> 01:34:27.099
这只是一个注册表，当我创建

01:34:24.409 --> 01:34:30.110
我只是给这张地图的东西

01:34:27.099 --> 01:34:32.960
但是我还是不太满意

01:34:30.110 --> 01:34:36.070
代码，因为这里有一些代码

01:34:32.960 --> 01:34:40.219
将要多次调用添加， 

01:34:36.070 --> 01:34:43.310
做饭可以打断

01:34:40.219 --> 01:34:44.750
被制成多线程

01:34:43.310 --> 01:34:47.869
反思不是，不是

01:34:44.750 --> 01:34:49.670
很好，但是如果我检查这段代码是什么

01:34:47.869 --> 01:34:52.130
实际上，我将使用相同的

01:34:49.670 --> 01:34:56.030
我用来告诉你的技巧

01:34:52.130 --> 01:34:59.480
如果我提取这个比较器

01:34:56.030 --> 01:35:02.239
对此方法或我看到的代码

01:34:59.480 --> 01:35:04.550
实际上是一段代码

01:35:02.239 --> 01:35:08.960
将构建器作为参数， 

01:35:04.550 --> 01:35:11.719
在某种意义上不返回任何东西

01:35:08.960 --> 01:35:13.900
这一段代码需要做什么

01:35:11.719 --> 01:35:16.280
东西什么都不会返回

01:35:13.900 --> 01:35:19.099
它本身就是一个lambda表达式

01:35:16.280 --> 01:35:23.480
消费者的权利，所以事实上这一切

01:35:19.099 --> 01:35:27.739
代码可以作为消费者返回

01:35:23.480 --> 01:35:34.280
这样做是什么的消费者

01:35:27.739 --> 01:35:38.210
消费者vinda好的建筑商的消费者

01:35:34.280 --> 01:35:43.310
我们称其为消费者

01:35:38.210 --> 01:35:45.650
将构建器作为参数的瞬间

01:35:43.310 --> 01:35:52.580
我只是要像下面这样写

01:35:45.650 --> 01:35:55.630
那并且做到这一点我可以摆脱

01:35:52.580 --> 01:36:01.790
这种方法我不再需要了

01:35:55.630 --> 01:36:05.420
现在好东西是我不需要

01:36:01.790 --> 01:36:05.930
那一点我不再需要建造者

01:36:05.420 --> 01:36:08.360
在

01:36:05.930 --> 01:36:10.880
我的应用程序代码初始化一个

01:36:08.360 --> 01:36:13.010
生成器，您已经创建了模型

01:36:10.880 --> 01:36:16.190
初始化，这是一个非常

01:36:13.010 --> 01:36:18.350
其实很普通的过程

01:36:16.190 --> 01:36:21.830
使用构建器完成对象的过程

01:36:18.350 --> 01:36:25.640
基本上是消费者，所以你可以写

01:36:21.830 --> 01:36:30.080
这个消费者通过这个消费者

01:36:25.640 --> 01:36:32.300
提取的东西通过了这个消费者

01:36:30.080 --> 01:36:38.240
我们的构建者的分解方法

01:36:32.300 --> 01:36:41.960
界面生成器创建通过此

01:36:38.240 --> 01:36:49.730
消费者作为参数，现在我

01:36:41.960 --> 01:36:53.150
期望作为返回对象是

01:36:49.730 --> 01:36:56.570
既创建又更大的对象

01:36:53.150 --> 01:37:00.080
用我有的消费者初始化

01:36:56.570 --> 01:37:02.930
提供确定，这是什么方法

01:37:00.080 --> 01:37:08.900
显然，这是我的静态方法

01:37:02.930 --> 01:37:11.540
构建器接口public static还是我

01:37:08.900 --> 01:37:17.210
称之为创建纹理消费者

01:37:11.540 --> 01:37:24.080
参数返回可以的构建器

01:37:17.210 --> 01:37:29.690
 TI需要告诉其酸度

01:37:24.080 --> 01:37:34.810
将T制造商的消费者视为

01:37:29.690 --> 01:37:34.810
参数，这是我的初始值设定项

01:37:39.149 --> 01:37:49.570
让我们返回您，看看是否收到

01:37:44.019 --> 01:37:52.119
是的，我想现在可以了

01:37:49.570 --> 01:38:01.889
我必须要使用的静态方法是

01:37:52.119 --> 01:38:01.889
创建此建造者新的投标人

01:38:02.789 --> 01:38:12.639
好的，将此苦味作为参数传递

01:38:06.039 --> 01:38:20.409
到我们刚刚传递的初始化程序

01:38:12.639 --> 01:38:23.139
然后返回这个生成器，好吧，你

01:38:20.409 --> 01:38:26.589
看到现在我的意思是我处在一个更好的状态

01:38:23.139 --> 01:38:28.300
形状比以前因为我不能

01:38:26.589 --> 01:38:30.399
中断之间的过程

01:38:28.300 --> 01:38:32.949
对象的构造及其

01:38:30.399 --> 01:38:36.969
初始化，所以不可能

01:38:32.949 --> 01:38:39.429
不再互动了，但我什至可以

01:38:36.969 --> 01:38:41.320
更进一步，因为现在我只是

01:38:39.429 --> 01:38:44.530
在另一个中称这个创造因素

01:38:41.320 --> 01:38:52.199
所以这里不使用这种构建方法

01:38:44.530 --> 01:38:55.809
我现在可以摆脱它了

01:38:52.199 --> 01:39:00.099
我在这里看到的是，我只有

01:38:55.809 --> 01:39:01.989
如果我可以在视频对象中使用一种方法

01:39:00.099 --> 01:39:05.260
只有一种方法可能意味着

01:39:01.989 --> 01:39:07.089
那是我的意思是一个实例方法

01:39:05.260 --> 01:39:09.339
我的视频对象中只有一种方法

01:39:07.089 --> 01:39:12.300
可能意味着我可以做到

01:39:09.339 --> 01:39:18.659
界面并使该方法抽象

01:39:12.300 --> 01:39:22.389
我要注释掉这段代码

01:39:18.659 --> 01:39:27.909
使此方法抽象并使我的

01:39:22.389 --> 01:39:31.419
现在闪闪发光的界面

01:39:27.909 --> 01:39:35.669
这里的注册表不能是实例

01:39:31.419 --> 01:39:38.859
我无法创建的接口故障

01:39:35.669 --> 01:39:41.939
这样的建造者，因为

01:39:38.859 --> 01:39:47.199
这是另一个对象，但这是一个lambda 

01:39:41.939 --> 01:39:48.670
所以我可以使用

01:39:47.199 --> 01:39:53.140
实作

01:39:48.670 --> 01:39:55.870
这里的这种抽象方法

01:39:53.140 --> 01:39:58.239
我只是总是复制粘贴

01:39:55.870 --> 01:40:00.190
同样的原则，我只是复制粘贴块

01:39:58.239 --> 01:40:06.870
参数，我应该怎么做

01:40:00.190 --> 01:40:12.969
与做注册表点把钥匙和

01:40:06.870 --> 01:40:16.960
工厂无法创建此注册表

01:40:12.969 --> 01:40:22.000
作为字段，但可以将其创建为

01:40:16.960 --> 01:40:25.800
好了，所以我首先创建

01:40:22.000 --> 01:40:29.260
我的注册表，然后创建我的生成器

01:40:25.800 --> 01:40:34.150
第三步，使用

01:40:29.260 --> 01:40:39.640
消费者，然后我将其退回

01:40:34.150 --> 01:40:43.179
这段代码实际上是一种方法

01:40:39.640 --> 01:40:45.880
参考我会保留，所以如果我

01:40:43.179 --> 01:40:53.100
真的很想让我的代码完全

01:40:45.880 --> 01:40:53.100
不可读我可以这样写

01:40:53.640 --> 01:40:56.640
好的

01:41:03.429 --> 01:41:16.570
好吧好吧，所以你看到使用这个

01:41:14.050 --> 01:41:19.300
我可以非常非常喜欢的一种代码

01:41:16.570 --> 01:41:23.020
仅用非常简单的原理

01:41:19.300 --> 01:41:25.960
那是试图去了解

01:41:23.020 --> 01:41:28.449
当我有一个lambda时

01:41:25.960 --> 01:41:30.040
只考虑一种方法的类

01:41:28.449 --> 01:41:31.600
我可以很好地实施该课程

01:41:30.040 --> 01:41:33.909
可以与该类建立接口

01:41:31.600 --> 01:41:36.969
并用lambda实现它

01:41:33.909 --> 01:41:39.100
看到这里我的状态更好

01:41:36.969 --> 01:41:47.260
形状比以前好得多

01:41:39.100 --> 01:41:50.860
在前面的示例中， 

01:41:47.260 --> 01:41:53.830
第一步，我创建了一个

01:41:50.860 --> 01:42:01.239
类中的对象注册表是一个

01:41:53.830 --> 01:42:03.610
那个班级的人记得这里

01:42:01.239 --> 01:42:06.130
是那个阶级的领域，任何人都可以

01:42:03.610 --> 01:42:08.530
可以反射到脚

01:42:06.130 --> 01:42:12.060
该类的意思是说

01:42:08.530 --> 01:42:14.500
可以用反射来纠正我的代码或

01:42:12.060 --> 01:42:17.110
并发或类似的东西现在我

01:42:14.500 --> 01:42:19.780
注册表是完全隐藏的

01:42:17.110 --> 01:42:21.730
静态接口中的局部变量

01:42:19.780 --> 01:42:24.340
连反射都没人看

01:42:21.730 --> 01:42:26.290
我不必使用并发-映射

01:42:24.340 --> 01:42:28.840
在这里，因为此代码将被执行

01:42:26.290 --> 01:42:31.960
只需一个线程，您就可以拥有一个

01:42:28.840 --> 01:42:34.600
局部变量共享，恐怕这是

01:42:31.960 --> 01:42:37.780
不可能，所以这段代码很多

01:42:34.600 --> 01:42:40.000
更加健壮，比发生错误的可能性要小得多

01:42:37.780 --> 01:42:44.320
上一个可能不是

01:42:40.000 --> 01:42:45.599
简单-对，我同意，但仍然

01:42:44.320 --> 01:42:54.050
非常

01:42:45.599 --> 01:42:54.050
对，我想我已经完成了

01:43:00.900 --> 01:43:03.500
是的

01:43:05.240 --> 01:43:07.930
好吧

01:43:11.440 --> 01:43:17.930
所以这是我的困惑我的困惑

01:43:15.070 --> 01:43:20.030
你看到那个lambdas表情的校友

01:43:17.930 --> 01:43:23.090
表达式已表示为

01:43:20.030 --> 01:43:25.370
编写实例的更好的方法

01:43:23.090 --> 01:43:29.360
匿名类和默认方法

01:43:25.370 --> 01:43:32.240
也作为一种方式提出

01:43:29.360 --> 01:43:36.830
修改现有接口而无需

01:43:32.240 --> 01:43:38.840
换班这很有用

01:43:36.830 --> 01:43:40.550
当Java是新的，这不是

01:43:38.840 --> 01:43:43.250
情况再一次，那边有一个9 

01:43:40.550 --> 01:43:46.010
从现在开始的几年内

01:43:43.250 --> 01:43:49.160
会记得之前的事

01:43:46.010 --> 01:43:51.560
我想我会留下的是

01:43:49.160 --> 01:43:54.260
 Java中新的函数模型

01:43:51.560 --> 01:43:56.390
称为具有两个函数式接口

01:43:54.260 --> 01:43:59.510
给出的可能性组成

01:43:56.390 --> 01:44:01.610
默认方法部分应用

01:43:59.510 --> 01:44:03.140
这是第二个基本要素

01:44:01.610 --> 01:44:08.170
功能编程中的操作和

01:44:03.140 --> 01:44:10.550
也可以轻松创建工厂方法

01:44:08.170 --> 01:44:14.060
使用参数使用lambda表达式

01:44:10.550 --> 01:44:15.770
所以这真的是一种新的创造方式

01:44:14.060 --> 01:44:19.520
应用程序和实施模式

01:44:15.770 --> 01:44:24.620
而且我认为这是非常不错的补充

01:44:19.520 --> 01:44:27.110
我们的应用程序和API，这就是

01:44:24.620 --> 01:44:29.470
我今天想告诉你，谢谢

01:44:27.110 --> 01:44:29.470
你的注意力

01:44:35.820 --> 01:44:53.320
我认为我们有一些时间

01:44:37.780 --> 01:44:55.000
问题是吗，是的，如果你

01:44:53.320 --> 01:44:58.710
应该只是谷歌我的帐户

01:44:55.000 --> 01:44:58.710
 SlideShare您会发现它

01:45:06.550 --> 01:45:12.190
是的，我可以在Mario中推送代码记录

01:45:08.860 --> 01:45:18.099
 github帐户好吧做一些也许

01:45:12.190 --> 01:45:28.659
其他一些清洁服务

01:45:18.099 --> 01:45:33.519
问题是，请您对不起

01:45:28.659 --> 01:45:34.900
指定类型，现在是可选的

01:45:33.519 --> 01:45:36.940
当您额外编写lambda时， 

01:45:34.900 --> 01:45:38.409
如果你真的是一个可读性问题

01:45:36.940 --> 01:45:40.210
认为Jo代码更易于阅读

01:45:38.409 --> 01:45:42.400
指定代码是否对您有帮助

01:45:40.210 --> 01:45:45.249
做到这一点没有什么区别

01:45:42.400 --> 01:45:46.900
代码被编译并且性能

01:45:45.249 --> 01:45:49.269
所执行的代码，所以这只是一个

01:45:46.900 --> 01:45:51.039
重要的是，lambda与

01:45:49.269 --> 01:45:53.559
方法参考，如果您更多

01:45:51.039 --> 01:45:55.840
对lambda感到满意，只是保持

01:45:53.559 --> 01:45:59.469
随着时间的推移，您会遵循新的代码

01:45:55.840 --> 01:46:00.849
通过你可能会习惯

01:45:59.469 --> 01:46:03.909
我想给你写的方法引用

01:46:00.849 --> 01:46:05.559
使用它们但已编译的代码的视频

01:46:03.909 --> 01:46:07.269
是一样的，所以没有区别

01:46:05.559 --> 01:46:13.719
金属参考之间的性能

01:46:07.269 --> 01:46:15.999
伦敦问，有一个

01:46:13.719 --> 01:46:18.219
莫里斯写的好书

01:46:15.999 --> 01:46:21.300
萘流中的坏λ 

01:46:18.219 --> 01:46:24.249
那里我什么都不知道

01:46:21.300 --> 01:46:26.739
特别是在lambda上，仅在lambdas上

01:46:24.249 --> 01:46:28.749
他们通常会覆盖新的Lambda 

01:46:26.739 --> 01:46:31.539
收集框架上的方法

01:46:28.749 --> 01:46:34.119
流和字符，我认为

01:46:31.539 --> 01:46:36.249
莫里森之后写的是

01:46:34.119 --> 01:46:51.210
很好，可以在图书馆找到

01:46:36.249 --> 01:46:51.210
还有Java在起作用

01:46:58.180 --> 01:47:05.750
你不能打开一个类名

01:47:02.930 --> 01:47:08.690
切换只需原始

01:47:05.750 --> 01:47:11.360
时间整数枚举和字符串

01:47:08.690 --> 01:47:13.010
您不能在交换机中提供课程

01:47:11.360 --> 01:47:15.920
声明，因此您必须提供一个密钥

01:47:13.010 --> 01:47:18.620
可以是类名或任何种类

01:47:15.920 --> 01:47:20.660
代表班级的标签

01:47:18.620 --> 01:47:22.130
还有其他方法可以实现

01:47:20.660 --> 01:47:24.160
模式，您也可以使用

01:47:22.130 --> 01:47:27.020
您例如使用数字

01:47:24.160 --> 01:47:29.480
首先获取获得动画师的设置值

01:47:27.020 --> 01:47:31.610
珍惜您需要的东西，然后

01:47:29.480 --> 01:47:33.560
调用一个实例方法

01:47:31.610 --> 01:47:35.510
枚举值，将为您提供

01:47:33.560 --> 01:47:37.400
正确的工厂，这不是唯一的方法

01:47:35.510 --> 01:47:40.190
做到这一点，但我应该做到这一点

01:47:37.400 --> 01:47:47.230
我认为最经典的

01:47:40.190 --> 01:47:47.230
实现它的方式

01:47:50.930 --> 01:47:53.560
是的

01:47:59.670 --> 01:48:08.550
我不太确定你的问题

01:48:01.900 --> 01:48:08.550
对不起

01:48:09.320 --> 01:48:12.320
是的

01:48:16.179 --> 01:48:21.130
是的，通常当您使用

01:48:19.360 --> 01:48:23.440
您可以依赖注入框架

01:48:21.130 --> 01:48:25.840
还提供工厂方法来创建

01:48:23.440 --> 01:48:27.130
您的对象，无论是春季还是春季

01:48:25.840 --> 01:48:30.250
例如在CDI中

01:48:27.130 --> 01:48:34.000
所以只要注释正确的部分

01:48:30.250 --> 01:48:36.420
代码的周围，所以如果您可以看到

01:48:34.000 --> 01:48:40.420
做到这一点，是的杠杆杠杆

01:48:36.420 --> 01:48:43.120
 lambda但依赖项注入

01:48:40.420 --> 01:48:45.640
框架将创建代理

01:48:43.120 --> 01:48:48.489
对象，因此，如果您在使用lambda 

01:48:45.640 --> 01:48:50.230
他们约兰达的会有点混乱

01:48:48.489 --> 01:48:53.590
所有这些代理，您将输掉

01:48:50.230 --> 01:48:56.130
大部分最美好的事物

01:48:53.590 --> 01:48:59.650
仅使用普通lambda时将具有

01:48:56.130 --> 01:49:02.080
基本上lambdas没有实现为

01:48:59.650 --> 01:49:03.940
 JVM中的一个对象，如果她

01:49:02.080 --> 01:49:06.820
正在调用两个字符串或等于

01:49:03.940 --> 01:49:08.560
 lambda上的对象方法

01:49:06.820 --> 01:49:11.409
这仍然是可能的，因为它将

01:49:08.560 --> 01:49:14.530
编译那么你就是你正在失去所有

01:49:11.409 --> 01:49:19.510
 JVM的优化

01:49:14.530 --> 01:49:21.070
能够以某种方式为您设置

01:49:19.510 --> 01:49:23.860
你只是用普通的lambda，所以如果

01:49:21.070 --> 01:49:28.210
您正在使用纯lambda，而只是使用

01:49:23.860 --> 01:49:32.159
他们照原样做任何有趣的事情

01:49:28.210 --> 01:49:32.159
和他们在一起

01:49:34.750 --> 01:49:43.040
我从来没有听说过我没有

01:49:40.040 --> 01:49:46.160
我不认为我不能完全

01:49:43.040 --> 01:49:48.110
确保有改进的空间

01:49:46.160 --> 01:49:49.940
等待lambda已实施

01:49:48.110 --> 01:49:52.370
在JDM中，还有改进的空间

01:49:49.940 --> 01:49:54.530
将来我不确定

01:49:52.370 --> 01:50:02.960
他们是对此的重大修改

01:49:54.530 --> 01:50:03.830
现场还有其他问题好吗谢谢

01:50:02.960 --> 01:50:06.090
为了您的关注

01:50:03.830 --> 01:50:09.989
祝你有美好的一天

01:50:06.090 --> 01:50:09.989
 [掌声] 

