WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.149 --> 00:00:09.219
好吧，我欢迎大家高兴

00:00:07.240 --> 00:00:12.070
你们都可以让它看起来像

00:00:09.219 --> 00:00:14.110
一些熟悉的面孔，我们哦，我的

00:00:12.070 --> 00:00:16.150
儿子要来

00:00:14.110 --> 00:00:17.650
所以今天是的，我确定你已经看过

00:00:16.150 --> 00:00:19.329
安全港声明一大堆

00:00:17.650 --> 00:00:21.480
时代，但我只是想

00:00:19.329 --> 00:00:23.199
在本次演讲中再次强调

00:00:21.480 --> 00:00:25.829
我今天谈论的一切

00:00:23.199 --> 00:00:28.899
本节或今天的会议是

00:00:25.829 --> 00:00:31.539
从JDK 9开始试验性的

00:00:28.899 --> 00:00:32.980
以任何方式得到官方支持

00:00:31.539 --> 00:00:35.350
通常我们只是通过

00:00:32.980 --> 00:00:37.390
通过这些事情，但在这种情况下

00:00:35.350 --> 00:00:39.190
其实很重要，所以请

00:00:37.390 --> 00:00:42.070
不要建立整个产品

00:00:39.190 --> 00:00:43.420
基于OT技术的系统

00:00:42.070 --> 00:00:46.330
你要说我们要说

00:00:43.420 --> 00:00:48.160
今天大约有几个人

00:00:46.330 --> 00:00:50.170
听众，我想知道我，但只是为了

00:00:48.160 --> 00:00:52.090
那些不属于我的人

00:00:50.170 --> 00:00:54.910
持续的工程师，这意味着我要修复

00:00:52.090 --> 00:00:57.550
这是我今天发布的热点错误

00:00:54.910 --> 00:01:00.310
我几乎是JDK更新的工作

00:00:57.550 --> 00:01:02.170
项目维护者或其中之一，所以您

00:01:00.310 --> 00:01:03.790
有时会找我吵架

00:01:02.170 --> 00:01:05.740
网上人们关于什么样的变化

00:01:03.790 --> 00:01:08.560
应该也不应更新

00:01:05.740 --> 00:01:10.659
发布我之前做过Java的版本

00:01:08.560 --> 00:01:14.799
我是日本最畅销书的合著者

00:01:10.659 --> 00:01:17.619
 WebLogic书，我做Twitter，有

00:01:14.799 --> 00:01:19.539
一个博客，所以我们没有很多

00:01:17.619 --> 00:01:20.920
今天要谈谈，所以我们会很友善

00:01:19.539 --> 00:01:23.380
尝试使事情保持简单

00:01:20.920 --> 00:01:24.219
这是三种不同的物联网讨论之一

00:01:23.380 --> 00:01:27.460
我知道的

00:01:24.219 --> 00:01:29.259
本周在JavaOne上，幸运的是

00:01:27.460 --> 00:01:30.399
其他两个谈话都是明天，所以如果

00:01:29.259 --> 00:01:33.459
你并没有计划

00:01:30.399 --> 00:01:35.439
明天参加他们也许你可以

00:01:33.459 --> 00:01:36.880
把它放在你的时间表，因为一些

00:01:35.439 --> 00:01:39.340
即将举行的演讲看起来很漂亮

00:01:36.880 --> 00:01:40.810
有趣又好，我有一些

00:01:39.340 --> 00:01:42.880
幻灯片末尾指向它们的指针

00:01:40.810 --> 00:01:44.619
甲板上，但今天这有点像

00:01:42.880 --> 00:01:45.999
功能本身介绍

00:01:44.619 --> 00:01:48.429
一开始就要开始

00:01:45.999 --> 00:01:50.979
并介绍什么是物联网

00:01:48.429 --> 00:01:52.840
这样的目标是什么

00:01:50.979 --> 00:01:56.380
此新功能的设计目标以及

00:01:52.840 --> 00:01:58.060
您可能希望摆脱它的原因

00:01:56.380 --> 00:01:59.799
我们从某种无聊开始

00:01:58.060 --> 00:02:01.149
警告只是为了确保有

00:01:59.799 --> 00:02:02.979
没有误会，每个人

00:02:01.149 --> 00:02:05.380
一点点地接受我说的一切

00:02:02.979 --> 00:02:07.179
盐粒，所以第一件事是

00:02:05.380 --> 00:02:09.340
就像我之前说过的那样

00:02:07.179 --> 00:02:10.980
正式支持儿子，然后再

00:02:09.340 --> 00:02:14.620
 Oracle有点悠久的历史

00:02:10.980 --> 00:02:17.420
通过其他方式介绍新功能

00:02:14.620 --> 00:02:21.420
示例可能是分层编译

00:02:17.420 --> 00:02:23.459
 gg1编译器我是g1车

00:02:21.420 --> 00:02:26.610
垃圾收集器首先这些垃圾

00:02:23.459 --> 00:02:28.290
是最初输入的所有功能

00:02:26.610 --> 00:02:30.060
产品作为实验功能

00:02:28.290 --> 00:02:31.470
没有得到官方的支持， 

00:02:30.060 --> 00:02:33.900
然后他们得到了支持，然后

00:02:31.470 --> 00:02:36.360
后来他们成为默认启用

00:02:33.900 --> 00:02:39.239
开箱即用，所以当我们

00:02:36.360 --> 00:02:41.790
不确定是否有OT 

00:02:39.239 --> 00:02:44.190
那里会走类似的路

00:02:41.790 --> 00:02:46.260
有种乐观的空间，但是

00:02:44.190 --> 00:02:48.660
到现在为止，这还不是你

00:02:46.260 --> 00:02:50.819
真的可以影响期望官方

00:02:48.660 --> 00:02:52.860
从甲骨文的支持说，如果

00:02:50.819 --> 00:02:54.120
您确实发现错误，请提交错误

00:02:52.860 --> 00:02:56.330
报告我们想了解他们，我们

00:02:54.120 --> 00:03:00.239
要修复它，我们要使其成为

00:02:56.330 --> 00:03:04.709
到今天为止尽可能高质量

00:03:00.239 --> 00:03:07.110
仅在Intel 64位上支持

00:03:04.709 --> 00:03:08.880
专业Linux，以及其他

00:03:07.110 --> 00:03:11.160
要求您必须拥有lib elf 

00:03:08.880 --> 00:03:12.650
安装好了，这没什么大不了的

00:03:11.160 --> 00:03:16.290
在建造之前获得它

00:03:12.650 --> 00:03:19.769
但它必须在那里，所以希望

00:03:16.290 --> 00:03:22.560
我们正计划添加其他

00:03:19.769 --> 00:03:24.239
平台以及将来

00:03:22.560 --> 00:03:26.340
今天，这是你唯一可以

00:03:24.239 --> 00:03:28.650
没有官方使用

00:03:26.340 --> 00:03:30.030
希望我能帮忙的文档

00:03:28.650 --> 00:03:32.519
填补与

00:03:30.030 --> 00:03:36.090
今天的会议是唯一的官方事情

00:03:32.519 --> 00:03:38.670
外面确实是jep文件

00:03:36.090 --> 00:03:42.000
再一次，现在我们不知道

00:03:38.670 --> 00:03:44.670
何时甚至即使官方支持

00:03:42.000 --> 00:03:46.650
遵循或确定在什么时间范围内

00:03:44.670 --> 00:03:48.989
平台可能会或可能不会输入

00:03:46.650 --> 00:03:50.100
这就是我所有无聊的样板

00:03:48.989 --> 00:03:52.019
为了摆脱困境，让我们

00:03:50.100 --> 00:03:52.650
实际上跳入一个OT，它是什么

00:03:52.019 --> 00:03:55.560
所有关于

00:03:52.650 --> 00:03:57.180
鉴于我刚才说的所有话

00:03:55.560 --> 00:03:58.950
你为什么要去学习

00:03:57.180 --> 00:04:01.079
如果您不知道是否真的在使用它

00:03:58.950 --> 00:04:03.420
生产还不错，这是一件事

00:04:01.079 --> 00:04:05.880
很有可能这可能是

00:04:03.420 --> 00:04:07.350
在将来得到支持，所以就在

00:04:05.880 --> 00:04:09.840
您想要获得相同的感觉

00:04:07.350 --> 00:04:11.489
持有EA版本和早期访问版本

00:04:09.840 --> 00:04:13.530
和他们一起玩以了解

00:04:11.489 --> 00:04:15.239
平台可能会在此方向

00:04:13.530 --> 00:04:17.700
是您获得快速入门的机会

00:04:15.239 --> 00:04:20.010
关于什么可能是非常重要的

00:04:17.700 --> 00:04:22.049
令人兴奋的技术被引入

00:04:20.010 --> 00:04:24.180
在平台上另一件事是

00:04:22.049 --> 00:04:26.250
像我的大多数演讲一样，我们将

00:04:24.180 --> 00:04:29.010
跳上一些随机的切线

00:04:26.250 --> 00:04:30.630
克服其他功能

00:04:29.010 --> 00:04:32.160
热点JVM和

00:04:30.630 --> 00:04:34.410
所以这是一个很好的借口

00:04:32.160 --> 00:04:37.470
覆盖一些有趣的材料

00:04:34.410 --> 00:04:39.240
而且如果你像我一样

00:04:37.470 --> 00:04:41.310
只是觉得这东西真的很酷， 

00:04:39.240 --> 00:04:42.810
很有趣，所以总是很好

00:04:41.310 --> 00:04:45.990
进行探索并窥视

00:04:42.810 --> 00:04:47.970
引擎盖，所以每个人都很感兴趣

00:04:45.990 --> 00:04:52.020
因为这是根本

00:04:47.970 --> 00:04:54.630
更改或添加Java执行

00:04:52.020 --> 00:04:57.150
模型，并且已经存在

00:04:54.630 --> 00:04:59.910
自从不朽之始

00:04:57.150 --> 00:05:02.040
原来我们有你知道你有你的

00:04:59.910 --> 00:05:04.680
您可以堆放在Java C上的Java源代码

00:05:02.040 --> 00:05:06.270
您得到一个类文件，然后运行

00:05:04.680 --> 00:05:08.400
在运行时这不应该是

00:05:06.270 --> 00:05:11.280
让任何人都感到惊讶，然后当然

00:05:08.400 --> 00:05:13.740
在Java 1.2时间框架中

00:05:11.280 --> 00:05:16.650
开始将JIT编译添加到

00:05:13.740 --> 00:05:18.900
混合，所以在您运行时

00:05:16.650 --> 00:05:21.420
 JIT上运行应用程序

00:05:18.900 --> 00:05:23.760
编译器将发出实际的机器代码

00:05:21.420 --> 00:05:27.570
将被存储并从内存中运行

00:05:23.760 --> 00:05:30.240
 JIT编译有很多优点

00:05:27.570 --> 00:05:33.110
这里的想法是方法确实可以

00:05:30.240 --> 00:05:36.450
编译但是编译很昂贵

00:05:33.110 --> 00:05:39.150
编译总是很资源

00:05:36.450 --> 00:05:41.700
激烈的运动，因此CPU 

00:05:39.150 --> 00:05:44.540
周期和内存被消耗， 

00:05:41.700 --> 00:05:48.120
您的应用程序执行线程是

00:05:44.540 --> 00:05:50.580
基本上与C 1和C 2竞争

00:05:48.120 --> 00:05:52.410
有限的编译线程

00:05:50.580 --> 00:05:55.860
您的资源或有限资源

00:05:52.410 --> 00:05:58.050
应用程序，但是一旦我们克服了

00:05:55.860 --> 00:05:59.730
驼峰，我们得到编译的方法

00:05:58.050 --> 00:06:02.280
我们承认的机器语言版本

00:05:59.730 --> 00:06:04.290
运行非常非常快，使我们达到了顶峰

00:06:02.280 --> 00:06:07.200
我们期望从Java获得的性能

00:06:04.290 --> 00:06:09.060
今天，一个合理的问题是

00:06:07.200 --> 00:06:11.910
好吧，j编译真的总是

00:06:09.060 --> 00:06:14.430
优于或优于同龄人

00:06:11.910 --> 00:06:17.220
插入同声传译器

00:06:14.430 --> 00:06:20.370
实施，我们有点像

00:06:17.220 --> 00:06:21.750
该J火箭的可能案例研究

00:06:20.370 --> 00:06:23.760
我在自我介绍中没有提到

00:06:21.750 --> 00:06:26.370
但我实际上来自J 

00:06:23.760 --> 00:06:28.650
事情原本是火箭的一面，我们

00:06:26.370 --> 00:06:30.300
拥有纯净的喷气式飞机

00:06:28.650 --> 00:06:32.220
经典喷气式飞机的实现方式

00:06:30.300 --> 00:06:35.040
没有像热点这样的口译员

00:06:32.220 --> 00:06:39.000
确实要依靠，所以一切都只是

00:06:35.040 --> 00:06:40.080
默认情况下对jet进行了编译，所以

00:06:39.000 --> 00:06:44.100
这确实给你更好的表现

00:06:40.080 --> 00:06:45.870
这种好战的尝试

00:06:44.100 --> 00:06:47.340
一切机器代码和

00:06:45.870 --> 00:06:50.160
答案很好，你对它的定义是什么

00:06:47.340 --> 00:06:52.200
性能如此极端

00:06:50.160 --> 00:06:55.410
例子，没有，这是非常不公平的

00:06:52.200 --> 00:06:57.810
 Java，但在这里我正在运行

00:06:55.410 --> 00:07:01.050
只是本地的HelloWorld，您知道

00:06:57.810 --> 00:07:02.430
用C写的，你知道这个

00:07:01.050 --> 00:07:04.350
比较毫无意义，因为

00:07:02.430 --> 00:07:06.300
显然是这样写的

00:07:04.350 --> 00:07:08.400
而不是整个运行时的垃圾

00:07:06.300 --> 00:07:09.510
集合和其他所有Java 

00:07:08.400 --> 00:07:11.190
带到桌子上

00:07:09.510 --> 00:07:12.930
你不会竞争而是这个想法

00:07:11.190 --> 00:07:15.930
这是人们真的看起来

00:07:12.930 --> 00:07:17.580
在这些类型的用例中， 

00:07:15.930 --> 00:07:20.130
问自己你知道像

00:07:17.580 --> 00:07:21.540
好吧，为什么Java需要这么长时间

00:07:20.130 --> 00:07:24.360
总是有这种压力

00:07:21.540 --> 00:07:27.060
尝试使Java启动并以

00:07:24.360 --> 00:07:29.130
尽可能快，所以重点

00:07:27.060 --> 00:07:32.490
在这里使用HelloWorld就是

00:07:29.130 --> 00:07:34.950
甚至执行任何操作

00:07:32.490 --> 00:07:36.660
知道JVM有点落后

00:07:34.950 --> 00:07:38.580
在启动时间方面的原生世界

00:07:36.660 --> 00:07:40.500
人们注意到了

00:07:38.580 --> 00:07:42.330
比较公平与否

00:07:40.500 --> 00:07:44.190
做比较，这是东西

00:07:42.330 --> 00:07:46.770
我们必须意识到的

00:07:44.190 --> 00:07:49.650
这种动机促使我们尝试

00:07:46.770 --> 00:07:53.190
在这些时间上证明与人类一样多

00:07:49.650 --> 00:07:55.980
可能，所以检查编译不是

00:07:53.190 --> 00:07:57.960
总是最快，这就是为什么我们有

00:07:55.980 --> 00:08:00.270
热点思维方式或

00:07:57.960 --> 00:08:01.860
我们不J编译的哲学

00:08:00.270 --> 00:08:04.110
像J火箭所做的一切

00:08:01.860 --> 00:08:06.420
就像我说的，这对夫妻开销

00:08:04.110 --> 00:08:09.240
编译非常高

00:08:06.420 --> 00:08:12.450
所以我们正在消耗内存等资源

00:08:09.240 --> 00:08:14.100
和CPU时间，还有另一个问题

00:08:12.450 --> 00:08:15.680
人们不一定总是意识到

00:08:14.100 --> 00:08:17.880
的是还有延迟

00:08:15.680 --> 00:08:19.470
参与JIT编译以及我的工作

00:08:17.880 --> 00:08:21.960
意思是即使我们有

00:08:19.470 --> 00:08:24.240
可以开始的口译员

00:08:21.960 --> 00:08:27.060
立即运行代码，我们可以

00:08:24.240 --> 00:08:30.000
异步进行编译

00:08:27.060 --> 00:08:31.770
还有一个单独的编译线程

00:08:30.000 --> 00:08:33.330
我们有一个延迟

00:08:31.770 --> 00:08:36.330
编译版本，因此会有延迟

00:08:33.330 --> 00:08:38.520
在我们达到最佳性能之前

00:08:36.330 --> 00:08:40.140
那个特定的方法等等

00:08:38.520 --> 00:08:41.400
感觉你知道我们可以运行它

00:08:40.140 --> 00:08:42.900
立即，但我们运行缓慢

00:08:41.400 --> 00:08:44.550
我们在解释器中运行它， 

00:08:42.900 --> 00:08:46.650
我们想要做的是我们想要

00:08:44.550 --> 00:08:48.120
运行它的最快版本

00:08:46.650 --> 00:08:50.240
该方法的编译版本

00:08:48.120 --> 00:08:54.210
尽可能快的方法

00:08:50.240 --> 00:08:55.800
所以在热点，我们要做的是开始

00:08:54.210 --> 00:08:58.050
每种方法都始于

00:08:55.800 --> 00:08:59.610
解释这是你知道的默认值

00:08:58.050 --> 00:09:01.619
一切都会发生的行为，然后

00:08:59.610 --> 00:09:03.449
我们一直在做我们所谓的

00:09:01.619 --> 00:09:04.980
热点分析基本上是

00:09:03.449 --> 00:09:06.839
只是收集你知道停下来

00:09:04.980 --> 00:09:09.029
世界，看到所有

00:09:06.839 --> 00:09:11.910
线程正在运行并跟踪

00:09:09.029 --> 00:09:13.679
所有这些，然后我们有统计

00:09:11.910 --> 00:09:14.339
因为您知道调用计数和

00:09:13.679 --> 00:09:15.600
像这样的东西

00:09:14.339 --> 00:09:18.480
口译员实际上给了我们最多

00:09:15.600 --> 00:09:20.730
无论如何都是免费的

00:09:18.480 --> 00:09:22.470
我们拥有所有这些信息，然后我们

00:09:20.730 --> 00:09:24.420
确定哪些方法是高方法，我们

00:09:22.470 --> 00:09:26.279
只是编译那些，然后

00:09:24.420 --> 00:09:28.519
解释的只是保持解释

00:09:26.279 --> 00:09:30.779
你知道静态之类的东西

00:09:28.519 --> 00:09:33.959
初始化程序和其他东西

00:09:30.779 --> 00:09:36.149
你知道支付毫无价值

00:09:33.959 --> 00:09:38.970
编译的间接费用只是

00:09:36.149 --> 00:09:43.439
通过不编译来避免

00:09:38.970 --> 00:09:47.339
除了热点JIT， 

00:09:43.439 --> 00:09:49.259
还有一些很糟糕的

00:09:47.339 --> 00:09:52.079
我们必须解决的弱点

00:09:49.259 --> 00:09:54.869
与应用程序启动时间仍然

00:09:52.079 --> 00:09:56.699
一个问题需要你知道我们更长的时间

00:09:54.869 --> 00:09:58.769
有一个热身期，所以即使你

00:09:56.699 --> 00:10:01.290
应用程序开始响应

00:09:58.769 --> 00:10:03.329
传入的请求仍然可能需要一个

00:10:01.290 --> 00:10:06.480
在足够的热门方法之前

00:10:03.329 --> 00:10:08.610
得到编译为机器代码，我们

00:10:06.480 --> 00:10:10.769
开始看到最佳性能，因此启动

00:10:08.610 --> 00:10:12.420
时间是一种度量，然后是时间

00:10:10.769 --> 00:10:13.679
最佳表现是另一项指标， 

00:10:12.420 --> 00:10:15.360
他们俩都是

00:10:13.679 --> 00:10:17.879
可能的改进空间

00:10:15.360 --> 00:10:19.709
当前的编译模型

00:10:17.879 --> 00:10:22.829
我们最消耗大量资源

00:10:19.709 --> 00:10:24.929
尤其是记忆力和某种方面

00:10:22.829 --> 00:10:26.730
事情不是什么大问题

00:10:24.929 --> 00:10:29.339
甲骨文的产品，但有

00:10:26.730 --> 00:10:31.470
一些平台

00:10:29.339 --> 00:10:34.439
出于任何原因不允许动态

00:10:31.470 --> 00:10:37.170
在运行时生成机器代码

00:10:34.439 --> 00:10:38.610
因此，如果您想在

00:10:37.170 --> 00:10:40.170
他们你有点被困在

00:10:38.610 --> 00:10:42.929
解释器，除非您能找到一些方法

00:10:40.170 --> 00:10:44.790
围绕着这就是我

00:10:42.929 --> 00:10:46.079
我在我谈论过他

00:10:44.790 --> 00:10:47.879
昨天的会议，我认为那些

00:10:46.079 --> 00:10:50.279
人们和我们在一起，但有两个

00:10:47.879 --> 00:10:53.459
内置的独立编译器

00:10:50.279 --> 00:10:55.439
虚拟机a c1的热点

00:10:53.459 --> 00:10:57.239
客户使用哪种类型的

00:10:55.439 --> 00:10:59.220
快速而肮脏的编译的想法是

00:10:57.239 --> 00:11:01.739
完成某种编辑行为

00:10:59.220 --> 00:11:03.660
得到那台更快的机器

00:11:01.739 --> 00:11:06.299
该方法的语言版本

00:11:03.660 --> 00:11:09.059
为了尽快执行

00:11:06.299 --> 00:11:11.520
 C 2是服务器编译器

00:11:09.059 --> 00:11:14.730
那会花很多时间

00:11:11.520 --> 00:11:16.730
即资源做得很重

00:11:14.730 --> 00:11:20.520
优化以给您最大的收益

00:11:16.730 --> 00:11:23.220
尽可能的高性能代码

00:11:20.520 --> 00:11:25.680
这里的关键区别是c2 

00:11:23.220 --> 00:11:28.170
不能只用完C2 

00:11:25.680 --> 00:11:30.300
取决于有一堆

00:11:28.170 --> 00:11:33.630
分析由收集的数据

00:11:30.300 --> 00:11:35.610
编译方法之前的运行时

00:11:33.630 --> 00:11:38.790
因此，没有这些数据，我们将无法真正看到

00:11:35.610 --> 00:11:40.730
编译方法，这将会

00:11:38.790 --> 00:11:44.010
稍后再播放

00:11:40.730 --> 00:11:47.370
这就是目前的情况

00:11:44.010 --> 00:11:50.010
存在于今天或JDK 9之前

00:11:47.370 --> 00:11:52.800
哦，要带给别人带什么？ 

00:11:50.010 --> 00:11:54.510
这里的桌子很好的想法是

00:11:52.800 --> 00:11:56.790
你当然知道，因为它领先

00:11:54.510 --> 00:11:58.980
时间是在生成机器代码之前

00:11:56.790 --> 00:12:00.930
我们实际运行之前的运行时

00:11:58.980 --> 00:12:03.270
应用程序，所以这就像

00:12:00.930 --> 00:12:06.390
像传统的静态编译和

00:12:03.270 --> 00:12:09.270
因此JVM有望找到并加载

00:12:06.390 --> 00:12:12.350
该代码在运行时，然后我们

00:12:09.270 --> 00:12:15.330
绕过系统开销的延迟

00:12:12.350 --> 00:12:18.000
在我们运行的同时进行编译工作

00:12:15.330 --> 00:12:19.440
这是一种标准模型

00:12:18.000 --> 00:12:22.440
今天又有了，我们刚刚看到

00:12:19.440 --> 00:12:24.600
在几张幻灯片中的幻灯片中， 

00:12:22.440 --> 00:12:28.829
另外，现在我们有了

00:12:24.600 --> 00:12:30.839
这个新工具this.ja OTC Java领先于

00:12:28.829 --> 00:12:33.750
时间编译器，它将为您提供

00:12:30.839 --> 00:12:38.089
 LF共享对象或共享库

00:12:33.750 --> 00:12:41.250
您可以加载到运行时

00:12:38.089 --> 00:12:43.290
使用该预先存在的机器代码来

00:12:41.250 --> 00:12:45.450
尽快启动，但是有

00:12:43.290 --> 00:12:46.890
这里有一些其他好处，所以在

00:12:45.450 --> 00:12:48.510
您拥有的传统模型

00:12:46.890 --> 00:12:50.310
多个JVM在运行，它们都是

00:12:48.510 --> 00:12:53.370
运行相同的代码，例如说某种

00:12:50.310 --> 00:12:59.160
冗余或集群

00:12:53.370 --> 00:13:01.380
是每个JVM都使用的同一OS VM 

00:12:59.160 --> 00:13:03.260
得到它自己的副本，所以不仅

00:13:01.380 --> 00:13:05.520
您要支付的性能费用

00:13:03.260 --> 00:13:07.440
所有这些时间都进行编译，但随后

00:13:05.520 --> 00:13:08.940
一旦你有该行为的输出

00:13:07.440 --> 00:13:10.829
一旦有了实际的编译

00:13:08.940 --> 00:13:12.990
必须保留在机器代码中

00:13:10.829 --> 00:13:14.790
代码缓存，代码缓存占用一个

00:13:12.990 --> 00:13:16.410
很大的空间，尤其是

00:13:14.790 --> 00:13:18.690
介绍分层编译

00:13:16.410 --> 00:13:22.709
代码缓存大小扩大了大约五倍

00:13:18.690 --> 00:13:24.630
时间，所以如果您在上运行很多JVM 

00:13:22.709 --> 00:13:26.010
同一操作系统实例

00:13:24.630 --> 00:13:29.760
实际上可能很多

00:13:26.010 --> 00:13:32.450
不必要的冗余开销

00:13:29.760 --> 00:13:35.580
允许我们创建这些只读

00:13:32.450 --> 00:13:38.100
内存中具有

00:13:35.580 --> 00:13:40.800
其中的机器代码和佣金

00:13:38.100 --> 00:13:42.870
可以在多个JVM之间共享

00:13:40.800 --> 00:13:44.580
实例，所以我们有一个密度

00:13:42.870 --> 00:13:46.290
如果您要部署的地方进行改进

00:13:44.580 --> 00:13:48.570
所有这些不同的宝石云

00:13:46.290 --> 00:13:51.720
总消耗的内存将是

00:13:48.570 --> 00:13:53.340
少，所以这里有很多优点

00:13:51.720 --> 00:13:56.100
它可以使您更快地启动

00:13:53.340 --> 00:13:58.050
时代这只是你知道

00:13:56.100 --> 00:13:59.700
当您的应用程序准备好

00:13:58.050 --> 00:14:02.310
开始实际服用和加工

00:13:59.700 --> 00:14:05.760
要求将有所改善，然后我们

00:14:02.310 --> 00:14:09.300
具有更快的预热时间或

00:14:05.760 --> 00:14:11.340
预热时间更少，因此即使

00:14:09.300 --> 00:14:12.840
像我说几张幻灯片一样接受请求

00:14:11.340 --> 00:14:14.940
之前需要一段时间

00:14:12.840 --> 00:14:16.890
您可以达到最佳性能，但是

00:14:14.940 --> 00:14:19.530
因为很多那些热门方法

00:14:16.890 --> 00:14:21.570
已经可以使用了

00:14:19.530 --> 00:14:23.250
更快达到最佳性能， 

00:14:21.570 --> 00:14:25.590
当然是因为我们没有这样做

00:14:23.250 --> 00:14:28.920
在运行时进行编译，我们也减少了

00:14:25.590 --> 00:14:31.230
内存占用量，我们的开销较小

00:14:28.920 --> 00:14:33.000
进行编译以与您竞争

00:14:31.230 --> 00:14:36.450
您的应用程序的执行线程

00:14:33.000 --> 00:14:37.740
正在为您和

00:14:36.450 --> 00:14:39.330
当然，我们可以节省空间

00:14:37.740 --> 00:14:41.280
如果您要提高密度

00:14:39.330 --> 00:14:44.760
运行多个正在运行的JVM 

00:14:41.280 --> 00:14:46.710
相同的代码，现在我们可以继续

00:14:44.760 --> 00:14:49.620
你知道平台不管

00:14:46.710 --> 00:14:54.030
原因可能会禁止运行时生成

00:14:49.620 --> 00:14:55.290
机器代码，所以我很少

00:14:54.030 --> 00:14:58.140
所有这些旁边，所以我的意思是

00:14:55.290 --> 00:14:59.970
你的里程可能会有所不同，我的意思是

00:14:58.140 --> 00:15:03.300
这就像很多选择

00:14:59.970 --> 00:15:06.900
如分层编译或其他

00:15:03.300 --> 00:15:09.120
不同的GCC垃圾收集器

00:15:06.900 --> 00:15:10.830
会发现某些应用程序受益

00:15:09.120 --> 00:15:12.540
从这些变化和改进中

00:15:10.830 --> 00:15:14.520
其他人甚至可能有表现

00:15:12.540 --> 00:15:16.560
从中回归很难

00:15:14.520 --> 00:15:19.410
说没有那种子弹

00:15:16.560 --> 00:15:21.450
改善了所有情况，这是其中之一

00:15:19.410 --> 00:15:24.300
这项技术之所以是

00:15:21.450 --> 00:15:25.740
并不是真的，您知道官方支持吗

00:15:24.300 --> 00:15:29.190
还可能更长

00:15:25.740 --> 00:15:31.620
才默认打开

00:15:29.190 --> 00:15:33.510
那是因为真的有

00:15:31.620 --> 00:15:34.890
实际情况并非如此的情况

00:15:33.510 --> 00:15:36.930
对于许多应用程序无济于事

00:15:34.890 --> 00:15:39.330
我们已经看到了改进

00:15:36.930 --> 00:15:41.070
所以我确定里面有几个人

00:15:39.330 --> 00:15:42.960
观众他们要去，你会更快地知道

00:15:41.070 --> 00:15:43.650
更快的预热时间，更快的启动

00:15:42.960 --> 00:15:45.660
次

00:15:43.650 --> 00:15:48.000
在不同的JVM之间共享数据

00:15:45.660 --> 00:15:49.680
这听起来真是太熟悉了

00:15:48.000 --> 00:15:51.990
为什么我觉得我听到了所有这些

00:15:49.680 --> 00:15:55.290
之前和现实中实际上有一个

00:15:51.990 --> 00:15:57.330
其他功能数量

00:15:55.290 --> 00:16:00.360
已添加到该平台的

00:15:57.330 --> 00:16:03.029
最近几年有非常

00:16:00.360 --> 00:16:05.610
与我们类似的设计目标

00:16:03.029 --> 00:16:06.990
试图做一个OT，所以我只是

00:16:05.610 --> 00:16:09.180
想要快速覆盖那些

00:16:06.990 --> 00:16:11.850
放眼一切

00:16:09.180 --> 00:16:14.730
并看看物联网如何适合

00:16:11.850 --> 00:16:16.380
启动时间的大图和

00:16:14.730 --> 00:16:18.900
我们正在改善的性能

00:16:16.380 --> 00:16:20.880
试图这样做，两个大的是

00:16:18.900 --> 00:16:23.610
分层编译和类数据

00:16:20.880 --> 00:16:25.650
共享以及应用程序类数据共享

00:16:23.610 --> 00:16:28.110
当然还有公告

00:16:25.650 --> 00:16:29.930
我们基本上将所有

00:16:28.110 --> 00:16:33.720
目前是

00:16:29.930 --> 00:16:36.060
 JVM并使其成为开源

00:16:33.720 --> 00:16:37.589
第一次开放JDK的用户还将

00:16:36.060 --> 00:16:40.980
能够利用应用程序类

00:16:37.589 --> 00:16:43.380
在不久的将来进行数据共享

00:16:40.980 --> 00:16:45.510
分层编译非常漂亮

00:16:43.380 --> 00:16:46.920
话题本身很复杂，所以我

00:16:45.510 --> 00:16:49.500
不想深入细节

00:16:46.920 --> 00:16:50.820
在这里，但基本上的想法是，我们没有

00:16:49.500 --> 00:16:53.490
不得不在以下两者之间做出选择

00:16:50.820 --> 00:16:56.959
使用ce-1编译器或c2 

00:16:53.490 --> 00:16:59.850
编译器我们实际上同时使用了

00:16:56.959 --> 00:17:01.860
传统上，服务器JVM只会

00:16:59.850 --> 00:17:06.150
有将要运行的口译员

00:17:01.860 --> 00:17:07.500
说您知道15,000次执行

00:17:06.150 --> 00:17:09.030
特定的方法，然后它将

00:17:07.500 --> 00:17:13.079
使用所有分析数据进行编译

00:17:09.030 --> 00:17:16.110
启用tieran后，我们现在有了

00:17:13.079 --> 00:17:18.390
我们使用c1的中点

00:17:16.110 --> 00:17:20.520
编译生成

00:17:18.390 --> 00:17:23.910
收集代码的工具化代码

00:17:20.520 --> 00:17:27.870
分析c2所需的数据，但是

00:17:23.910 --> 00:17:29.460
比完整的c2更快更容易

00:17:27.870 --> 00:17:31.380
编译，以便我们获得最佳

00:17:29.460 --> 00:17:33.360
在两个世界中，我们都能很快

00:17:31.380 --> 00:17:36.690
编译发生得很早

00:17:33.360 --> 00:17:38.970
在过程的生命周期中

00:17:36.690 --> 00:17:41.760
这是足够快的是

00:17:38.970 --> 00:17:44.250
比翻译快得多

00:17:41.760 --> 00:17:47.100
 Java字节码直接和

00:17:44.250 --> 00:17:49.020
一种使事情更快直到后来的事情

00:17:47.100 --> 00:17:50.150
 c2可以进来给你真正的

00:17:49.020 --> 00:17:53.420
巅峰表现

00:17:50.150 --> 00:17:56.000
这是一个很好的快乐中间地带

00:17:53.420 --> 00:17:57.620
具有班级数据共享，因此在

00:17:56.000 --> 00:18:00.470
传统情况应该看起来

00:17:57.620 --> 00:18:03.800
几张幻灯片之前我们非常熟悉

00:18:00.470 --> 00:18:07.070
 masane类正在由加载

00:18:03.800 --> 00:18:09.170
同一OS实例上的多个JVM 

00:18:07.070 --> 00:18:11.600
每个JVM都要经历所有

00:18:09.170 --> 00:18:14.330
解析Java字节码的努力

00:18:11.600 --> 00:18:16.220
并将其转化为内部数据

00:18:14.330 --> 00:18:18.800
热点使用的结构

00:18:16.220 --> 00:18:20.810
 JVM传统上是在

00:18:18.800 --> 00:18:22.340
现在那永久的一代

00:18:20.810 --> 00:18:24.740
信息已移至

00:18:22.340 --> 00:18:27.080
我们在JDK 8中称元空间

00:18:24.740 --> 00:18:29.780
关键是它消耗着真正的

00:18:27.080 --> 00:18:31.970
内存，以便与类数据共享

00:18:29.780 --> 00:18:35.150
想法是，您将创建一个存档

00:18:31.970 --> 00:18:36.710
那将坐在您的文件系统上， 

00:18:35.150 --> 00:18:39.860
那实际上会有种

00:18:36.710 --> 00:18:43.010
的解析或摘要版本

00:18:39.860 --> 00:18:44.630
类数据，因此JVM可以共享

00:18:43.010 --> 00:18:46.010
那会给你更快

00:18:44.630 --> 00:18:48.050
启动时间，因为您实际上不是

00:18:46.010 --> 00:18:49.940
解析Java字节码，它将

00:18:48.050 --> 00:18:52.490
也给你一些密度的改善

00:18:49.940 --> 00:18:56.510
因为你正在分享

00:18:52.490 --> 00:18:57.890
多个地址空间

00:18:56.510 --> 00:19:00.200
实际上是两种不同形式的课堂

00:18:57.890 --> 00:19:01.640
数据共享为标准类

00:19:00.200 --> 00:19:03.560
一直在进行的数据共享

00:19:01.640 --> 00:19:04.820
相当一段时间我不是

00:19:03.560 --> 00:19:07.820
记得他们添加时添加的东西

00:19:04.820 --> 00:19:09.590
在5或6时代的某个地方，以及

00:19:07.820 --> 00:19:10.940
每个人都可以免费使用

00:19:09.590 --> 00:19:13.910
这从来都不是商业功能

00:19:10.940 --> 00:19:16.010
但仅适用于JDK 

00:19:13.910 --> 00:19:19.910
类本身，即曾经是

00:19:16.010 --> 00:19:22.910
 Archie jar的一部分，因此Java SC类

00:19:19.910 --> 00:19:25.070
图书馆实际上是唯一的类

00:19:22.910 --> 00:19:27.350
更兼容或与

00:19:25.070 --> 00:19:29.540
然后传统的类数据共享

00:19:27.350 --> 00:19:32.090
有适当的类数据共享

00:19:29.540 --> 00:19:34.370
你可能会假设名字

00:19:32.090 --> 00:19:36.380
表示它是相同的类数据

00:19:34.370 --> 00:19:38.660
分享技术，但已应用于您的

00:19:36.380 --> 00:19:42.050
自己的类并在您的应用程序中

00:19:38.660 --> 00:19:43.940
并通过应用类数据共享给您

00:19:42.050 --> 00:19:46.130
其实可以和你做同样的事情

00:19:43.940 --> 00:19:48.710
上课并分享给他们

00:19:46.130 --> 00:19:51.590
它们之间的预解析版本

00:19:48.710 --> 00:19:54.140
多个JVM实例，今天

00:19:51.590 --> 00:19:55.940
这是您的商业功能

00:19:54.140 --> 00:19:57.380
那不是开放JDK的一部分吗？ 

00:19:55.940 --> 00:19:58.130
你不知道可以使用这个

00:19:57.380 --> 00:20:00.380
不用付钱

00:19:58.130 --> 00:20:01.970
甲骨文有钱但将来会

00:20:00.380 --> 00:20:03.889
不久的将来

00:20:01.970 --> 00:20:05.360
只是与Java飞行记录器和所有

00:20:03.889 --> 00:20:07.340
实际上是其他很棒的东西

00:20:05.360 --> 00:20:10.610
将其带入开源

00:20:07.340 --> 00:20:12.370
因此，这将是

00:20:10.610 --> 00:20:14.720
在不久的将来

00:20:12.370 --> 00:20:17.299
所以只是为了弄清楚那是什么

00:20:14.720 --> 00:20:18.590
这里的差异是这样的原因

00:20:17.299 --> 00:20:20.059
整个声音可能真的很熟悉

00:20:18.590 --> 00:20:21.710
对你来说是因为这些饮食中有很多

00:20:20.059 --> 00:20:23.570
设计目标是相同的层次

00:20:21.710 --> 00:20:26.120
杀手级应用的汇编

00:20:23.570 --> 00:20:30.460
代表着更快的启动时间， 

00:20:26.120 --> 00:20:33.529
更快或更不明显

00:20:30.460 --> 00:20:35.779
预热差距，然后进行类数据共享

00:20:33.529 --> 00:20:38.629
应用类数据共享也给

00:20:35.779 --> 00:20:40.639
您可以加快预热时间，并且一些

00:20:38.629 --> 00:20:42.860
通过删除

00:20:40.639 --> 00:20:45.049
否则会存在冗余

00:20:42.860 --> 00:20:46.580
使多个JVM加载相同

00:20:45.049 --> 00:20:49.610
类，但有什么不同

00:20:46.580 --> 00:20:51.740
这些使OT独特的是

00:20:49.610 --> 00:20:54.649
这些都不涉及实际的输出

00:20:51.740 --> 00:20:56.840
 JIT编译过程的说明，因此是OT 

00:20:54.649 --> 00:20:58.970
就是关于

00:20:56.840 --> 00:21:01.460
 JVM代码缓存实际上是

00:20:58.970 --> 00:21:03.049
生成所有

00:21:01.460 --> 00:21:05.330
类数据共享应用程序类数据

00:21:03.049 --> 00:21:08.000
共享保存了有关

00:21:05.330 --> 00:21:10.879
上课，但实际上不是

00:21:08.000 --> 00:21:12.740
用生成的代码做任何事情，所以

00:21:10.879 --> 00:21:15.350
确实是该平台的第一个

00:21:12.740 --> 00:21:18.620
所有这些技术一起工作

00:21:15.350 --> 00:21:20.000
这不是相互排斥的情况

00:21:18.620 --> 00:21:20.360
您必须在其中选择一个

00:21:20.000 --> 00:21:22.429
其他

00:21:20.360 --> 00:21:24.379
我们在性能测试中发现

00:21:22.429 --> 00:21:27.350
他们实际上真的工作得最好

00:21:24.379 --> 00:21:29.269
您可以同时使用所有这些

00:21:27.350 --> 00:21:32.059
这是一个OT代表另一个

00:21:29.269 --> 00:21:35.179
逐步改善我们的目标

00:21:32.059 --> 00:21:39.200
启动时间更快，更好

00:21:35.179 --> 00:21:41.899
内存使用情况，所以之前建议

00:21:39.200 --> 00:21:43.309
我为Java做过这个特别的演讲

00:21:41.899 --> 00:21:45.379
我可以打得更好的东京

00:21:43.309 --> 00:21:47.389
通过更多内容使我的演示人性化

00:21:45.379 --> 00:21:49.639
人的照片，我得到了这个

00:21:47.389 --> 00:21:52.580
幻灯片，这样就带来了总计

00:21:49.639 --> 00:21:54.080
人的照片到10整个

00:21:52.580 --> 00:21:55.669
演示文稿，这是一个很好的

00:21:54.080 --> 00:21:57.320
平均而言，我认为大部分

00:21:55.669 --> 00:21:59.389
同事只有5个或6个

00:21:57.320 --> 00:22:02.779
人的照片，所以我不认为

00:21:59.389 --> 00:22:04.730
任何人都会抱怨使用不再

00:22:02.779 --> 00:22:06.590
所以这是我们进入

00:22:04.730 --> 00:22:09.529
如前所述，我们有

00:22:06.590 --> 00:22:11.059
这款新工具是OTC，它坐着

00:22:09.529 --> 00:22:12.379
就在Java C和

00:22:11.059 --> 00:22:16.340
 bin目录中的其他所有内容

00:22:12.379 --> 00:22:18.289
并且使用它非常简单

00:22:16.340 --> 00:22:21.049
他们，因为你必须

00:22:18.289 --> 00:22:22.789
明确标记输出，否则

00:22:21.049 --> 00:22:24.049
你会得到一个非常可怕的默认值

00:22:22.789 --> 00:22:26.659
好吧，我想这就像输出点

00:22:24.049 --> 00:22:30.380
 o或某种让我想起的东西

00:22:26.659 --> 00:22:31.520
海湾合作委员会，但无论如何，你只是告诉它什么

00:22:30.380 --> 00:22:33.340
您想要的库的名称

00:22:31.520 --> 00:22:36.320
生成并为您提供课程

00:22:33.340 --> 00:22:38.690
它会给你它会给你

00:22:36.320 --> 00:22:40.490
您那个共享对象文件和

00:22:38.690 --> 00:22:43.279
当然，网上有很多

00:22:40.490 --> 00:22:46.100
帮助将是有用的，特别是如果

00:22:43.279 --> 00:22:48.200
这是一个新工具，您会注意到

00:22:46.100 --> 00:22:50.929
默认调用类型如下

00:22:48.200 --> 00:22:53.270
您知道的UNIX哲学不说

00:22:50.929 --> 00:22:54.980
除非出现问题，否则什么都不会发生

00:22:53.270 --> 00:22:56.419
与您所有的东西兼容

00:22:54.980 --> 00:22:59.000
假设任何

00:22:56.419 --> 00:23:01.190
外来的表现代表某种

00:22:59.000 --> 00:23:02.870
错误，但您可以使用

00:23:01.190 --> 00:23:04.490
信息标志和这种访问

00:23:02.870 --> 00:23:06.830
这就像一个冗长的设置， 

00:23:04.490 --> 00:23:09.260
会告诉你它到底是什么

00:23:06.830 --> 00:23:12.260
在类文件中找到了什么

00:23:09.260 --> 00:23:13.640
决定决定尝试编译，以便您

00:23:12.260 --> 00:23:16.370
可以向自己证明这是

00:23:13.640 --> 00:23:17.659
如您所愿地工作

00:23:16.370 --> 00:23:20.059
做理智很重要

00:23:17.659 --> 00:23:22.220
检查您何时使用新工具，以便

00:23:20.059 --> 00:23:24.860
有一些陷阱

00:23:22.220 --> 00:23:27.049
有趣的是

00:23:24.860 --> 00:23:30.679
你知道大多数人的断言

00:23:27.049 --> 00:23:33.890
永远不必费心启用

00:23:30.679 --> 00:23:35.179
在编译时通常是已知的

00:23:33.890 --> 00:23:38.210
 JIT编译这不是问题

00:23:35.179 --> 00:23:40.520
因为JVM知道您是否拥有

00:23:38.210 --> 00:23:41.510
断言是否启用，但一个

00:23:40.520 --> 00:23:44.840
可能发生的事情是

00:23:41.510 --> 00:23:47.240
无需预先声明就可以编译

00:23:44.840 --> 00:23:49.309
时间，然后在JVM中运行它

00:23:47.240 --> 00:23:52.010
您认为在运行时

00:23:49.309 --> 00:23:53.779
通过在那里启用断言

00:23:52.010 --> 00:23:56.120
打开所有的断言

00:23:53.779 --> 00:23:58.100
当现实中任何你

00:23:56.120 --> 00:23:59.899
与此提前编译

00:23:58.100 --> 00:24:01.429
工具将没有断言

00:23:59.899 --> 00:24:02.630
启用，所以如果你想拥有那些

00:24:01.429 --> 00:24:05.690
关于你的断言必须使

00:24:02.630 --> 00:24:07.700
决定何时进行äôt编译

00:24:05.690 --> 00:24:11.179
这个标志与此编译

00:24:07.700 --> 00:24:13.880
断言可以让您做到这一点，我认为我们

00:24:11.179 --> 00:24:15.710
有已编译的命令标志，这

00:24:13.880 --> 00:24:18.740
只是一种纾困的方式

00:24:15.710 --> 00:24:20.390
编译特定方法的过程

00:24:18.740 --> 00:24:23.419
将来我们可能会扩展它，我们可能会添加

00:24:20.390 --> 00:24:26.210
其他选项或设置

00:24:23.419 --> 00:24:28.220
到今天为止，我们唯一支持的是

00:24:26.210 --> 00:24:30.650
排除个别方法

00:24:28.220 --> 00:24:33.679
或者您可以使用通配符来说

00:24:30.650 --> 00:24:35.390
排除整个包裹，所以因为

00:24:33.679 --> 00:24:37.340
这项技术是新的，我们还没有

00:24:35.390 --> 00:24:39.770
完全解决了那里的所有问题

00:24:37.340 --> 00:24:42.169
在某些情况下您会遇到问题

00:24:39.770 --> 00:24:45.220
特定方法可能导致的地方

00:24:42.169 --> 00:24:48.350
编译本身失败或

00:24:45.220 --> 00:24:50.419
也许更糟糕的方法可能是

00:24:48.350 --> 00:24:52.850
已编译，但可能已编译

00:24:50.419 --> 00:24:54.500
错误地，因此生成的机器

00:24:52.850 --> 00:24:56.690
代码可能在其中存在某种问题

00:24:54.500 --> 00:24:59.419
它，所以在运行时出现问题

00:24:56.690 --> 00:25:00.890
以某种可怕的方式表现出来

00:24:59.419 --> 00:25:02.150
你可以做的是，如果发现有一个

00:25:00.890 --> 00:25:04.669
导致

00:25:02.150 --> 00:25:06.710
问题很好，第一件事就是我希望

00:25:04.669 --> 00:25:08.450
如果我们将您的错误报告发送给我们

00:25:06.710 --> 00:25:09.980
还不知道，但是

00:25:08.450 --> 00:25:12.530
第二件事是，您可以使用

00:25:09.980 --> 00:25:15.470
在已编译的命令文件中排除行

00:25:12.530 --> 00:25:17.299
这样你就可以告诉OT编译

00:25:15.470 --> 00:25:20.809
除了那种方法，然后

00:25:17.299 --> 00:25:22.520
继续使用它，不只是

00:25:20.809 --> 00:25:24.350
类的问候世界

00:25:22.520 --> 00:25:27.110
例子就是你知道上课

00:25:24.350 --> 00:25:28.940
但是实际上我们通常想要

00:25:27.110 --> 00:25:32.120
使用的是整个模块

00:25:28.940 --> 00:25:35.870
一次或一次整个jar文件

00:25:32.120 --> 00:25:37.730
 äôt这样做毫无问题

00:25:35.870 --> 00:25:40.760
只是把整个事情吸了一件事

00:25:37.730 --> 00:25:42.380
我想指出的是，编译

00:25:40.760 --> 00:25:45.740
正如我已经说过好几次了

00:25:42.380 --> 00:25:48.890
非常耗费资源并且格力

00:25:45.740 --> 00:25:52.250
这是我们用于的编译器

00:25:48.890 --> 00:25:54.020
物联网编译肯定会使用很多

00:25:52.250 --> 00:25:56.270
大量的内存和大量的资源

00:25:54.020 --> 00:25:58.429
因为这实际上发生在

00:25:56.270 --> 00:26:00.169
 Java这就是你所知道的就是全部Java 

00:25:58.429 --> 00:26:04.039
进行编译的软件

00:26:00.169 --> 00:26:06.020
我们这是一个本地代码

00:26:04.039 --> 00:26:08.870
有堆你可以用光了

00:26:06.020 --> 00:26:11.360
因此，例如，如果您正在编译

00:26:08.870 --> 00:26:14.679
整个Java基本模块

00:26:11.360 --> 00:26:16.640
我发现了我需要的最新版本

00:26:14.679 --> 00:26:20.450
五到六点之间

00:26:16.640 --> 00:26:22.220
技嘉堆只有两个来编译Java 

00:26:20.450 --> 00:26:26.600
基本，所以如果您通过此命令行

00:26:22.220 --> 00:26:28.370
今天到äôt编译器，实际上

00:26:26.600 --> 00:26:30.140
内存不足或在大多数系统上

00:26:28.370 --> 00:26:32.299
因为大多数系统您都不会

00:26:30.140 --> 00:26:34.850
具有默认的堆最大堆大小

00:26:32.299 --> 00:26:35.929
大到足以应付所有这些

00:26:34.850 --> 00:26:38.240
你将要编译一些大东西

00:26:35.929 --> 00:26:40.429
做好准备，就像你一样

00:26:38.240 --> 00:26:41.539
知道JDK的很大一部分，所以它不是

00:26:40.429 --> 00:26:43.729
那令人惊讶，但

00:26:41.539 --> 00:26:46.789
准备给它很多内存

00:26:43.729 --> 00:26:48.409
很多时间我都认为

00:26:46.789 --> 00:26:50.059
通常需要大约20 

00:26:48.409 --> 00:26:54.769
和30分钟，具体取决于速度

00:26:50.059 --> 00:26:56.720
你的机器很紧张所以

00:26:54.769 --> 00:26:59.570
另一件事是，那个

00:26:56.720 --> 00:27:02.090
语法不是äôt编译器独有的

00:26:59.570 --> 00:27:04.909
但你应该知道如何通过

00:27:02.090 --> 00:27:06.979
选项当然像例如

00:27:04.909 --> 00:27:08.960
您想要设置更大的最大堆

00:27:06.979 --> 00:27:10.639
大小，这将是您的方式

00:27:08.960 --> 00:27:12.259
它是这是标准格式

00:27:10.639 --> 00:27:14.960
 C和一大堆其他工具

00:27:12.259 --> 00:27:17.840
使用它可以让您将事物传递给

00:27:14.960 --> 00:27:19.580
 JVM运行任何东西

00:27:17.840 --> 00:27:22.190
您正在尝试的工具

00:27:19.580 --> 00:27:24.019
在那里执行，但这实际上是这样

00:27:22.190 --> 00:27:26.419
比那时更重要

00:27:24.019 --> 00:27:29.479
通常，我将解释为什么

00:27:26.419 --> 00:27:32.570
几张幻灯片，但只知道它是

00:27:29.479 --> 00:27:36.999
标准-J然后是其他

00:27:32.570 --> 00:27:36.999
您想传递的任何JVM选项

00:27:45.009 --> 00:27:49.549
知道这只会下去

00:27:47.509 --> 00:27:50.330
是您明确将其交给

00:27:49.549 --> 00:27:53.299
命令行

00:27:50.330 --> 00:27:58.239
它不会落后于您进行编译

00:27:53.299 --> 00:28:00.649
不管是好是坏

00:27:58.239 --> 00:28:02.899
还有另一种选择

00:28:00.649 --> 00:28:04.340
我会分层的编译

00:28:02.899 --> 00:28:06.830
介绍了几张幻灯片，还有

00:28:04.340 --> 00:28:10.789
编译为分层选项，因此它变成

00:28:06.830 --> 00:28:12.580
知道你内部知道

00:28:10.789 --> 00:28:15.409
工具不使用相同

00:28:12.580 --> 00:28:17.570
编译的实现

00:28:15.409 --> 00:28:19.580
像我说过的那样，热点JIT编译器使用

00:28:17.570 --> 00:28:22.549
必须进行喷射编译，我们有C 1和C 2 

00:28:19.580 --> 00:28:24.200
很多人都认为很好

00:28:22.549 --> 00:28:26.119
显然，他们使用的工具

00:28:24.200 --> 00:28:28.700
该代码库或那个

00:28:26.119 --> 00:28:31.369
实现编译但是

00:28:28.700 --> 00:28:34.309
实际上使用咆哮咆哮这是一部分

00:28:31.369 --> 00:28:38.479
 Oracle实验室的工作和研究

00:28:34.309 --> 00:28:41.269
 JVM技术和咆哮产生代码

00:28:38.479 --> 00:28:43.460
与C 1唯一不同的地方

00:28:41.269 --> 00:28:46.580
 C 2和性能明智的是

00:28:43.460 --> 00:28:48.139
在很多测试之间的某个地方

00:28:46.580 --> 00:28:50.440
我们所做的表明那到某个地方

00:28:48.139 --> 00:28:54.019
大概是百分之十

00:28:50.440 --> 00:28:54.860
比C 2还慢

00:28:54.019 --> 00:28:57.290
该死的好

00:28:54.860 --> 00:28:59.240
但是你没有达到最高峰

00:28:57.290 --> 00:29:02.270
您将从中获得的效果

00:28:59.240 --> 00:29:05.270
合法的C进行编译，可能

00:29:02.270 --> 00:29:07.130
缺少的部分是事实，我们

00:29:05.270 --> 00:29:09.290
没有运行时分析

00:29:07.130 --> 00:29:12.170
 c2可以利用的信息

00:29:09.290 --> 00:29:14.809
 JIT编译器的时间，所以

00:29:12.170 --> 00:29:17.720
高峰的实际理想情况

00:29:14.809 --> 00:29:21.410
性能是我之前说过的

00:29:17.720 --> 00:29:23.059
只是您的一个组成部分

00:29:21.410 --> 00:29:24.920
最佳策略

00:29:23.059 --> 00:29:26.690
性能可能，您可以通过

00:29:24.920 --> 00:29:28.910
如果有的话说编译四层

00:29:26.690 --> 00:29:31.220
 OT编译，那么它是做什么的

00:29:28.910 --> 00:29:33.799
不生成默认的咆哮代码

00:29:31.220 --> 00:29:36.440
它告诉咆哮包括

00:29:33.799 --> 00:29:38.780
 c2的分析仪器

00:29:36.440 --> 00:29:41.240
需要它来编译，所以你

00:29:38.780 --> 00:29:42.470
实际上以相同的方式结束

00:29:41.240 --> 00:29:45.380
您分层的情况

00:29:42.470 --> 00:29:49.130
除中间步骤外的编译

00:29:45.380 --> 00:29:52.040
不再是c1，而是äôt 

00:29:49.130 --> 00:29:54.740
编译的咆哮代码，这将是

00:29:52.040 --> 00:29:57.230
只是希望的前兆

00:29:54.740 --> 00:29:59.660
最终是c2编译的代码， 

00:29:57.230 --> 00:30:00.830
所以你基本上不需要

00:29:59.660 --> 00:30:04.309
还要吃你的蛋糕

00:30:00.830 --> 00:30:06.290
在这里，您也可以立即获得

00:30:04.309 --> 00:30:09.290
性能优势

00:30:06.290 --> 00:30:11.600
那里有预编译代码的大门

00:30:09.290 --> 00:30:14.660
但是最终，JVM自行产生了

00:30:11.600 --> 00:30:19.610
时间可以环顾四周

00:30:14.660 --> 00:30:22.100
给你额外的10％的颠簸

00:30:19.610 --> 00:30:23.390
确实在您运行它时执行

00:30:22.100 --> 00:30:24.650
当实际上第一次提出这个建议时

00:30:23.390 --> 00:30:26.150
谈话我感觉很好，我们将要做一个

00:30:24.650 --> 00:30:27.890
整个演示，结果

00:30:26.150 --> 00:30:33.410
演示就像不令人兴奋

00:30:27.890 --> 00:30:35.179
因为这是正确的，并且

00:30:33.410 --> 00:30:38.030
这里没有什么可以告诉你的

00:30:35.179 --> 00:30:41.240
你知道你的图书馆

00:30:38.030 --> 00:30:42.650
使用实际创建的，所以我们能做什么

00:30:41.240 --> 00:30:44.540
如果我们确实要验证

00:30:42.650 --> 00:30:45.830
实际上使用得很好，有一个

00:30:44.540 --> 00:30:48.799
选项，有一个新的选择

00:30:45.830 --> 00:30:52.070
添加到名为printäôt的JVM和

00:30:48.799 --> 00:30:53.750
默认情况下它是默认禁用的，但是

00:30:52.070 --> 00:30:55.910
如果您将其放入并运行它，您将

00:30:53.750 --> 00:30:57.679
实际得到一些输出

00:30:55.910 --> 00:30:59.870
看起来有点像印刷品

00:30:57.679 --> 00:31:01.669
我们都很漂亮的编译输出

00:30:59.870 --> 00:31:03.470
曾经看到，这告诉你

00:31:01.669 --> 00:31:06.020
这里的两个重要信息

00:31:03.470 --> 00:31:06.920
一个能够找到图书馆的人

00:31:06.020 --> 00:31:09.350
并加载它

00:31:06.920 --> 00:31:11.930
另外两件事是

00:31:09.350 --> 00:31:14.840
是两种不同的方法

00:31:11.930 --> 00:31:16.460
确定并装入或种类

00:31:14.840 --> 00:31:19.730
被确认为代码的一部分

00:31:16.460 --> 00:31:23.180
缓存，这就是

00:31:19.730 --> 00:31:25.400
课，然后是实际的世界

00:31:23.180 --> 00:31:27.170
你们不需要看的主要

00:31:25.400 --> 00:31:31.160
源代码，因为它是

00:31:27.170 --> 00:31:33.080
像您想象的那样无聊，让我们来看一下

00:31:31.160 --> 00:31:35.030
让我们尝试相同的事情，让我们开始吧

00:31:33.080 --> 00:31:37.190
我将禁用压缩

00:31:35.030 --> 00:31:38.570
哎呀，所以只是为了了解如何

00:31:37.190 --> 00:31:40.220
这里很多人都熟悉

00:31:38.570 --> 00:31:45.080
压缩oop压缩引用

00:31:40.220 --> 00:31:46.340
好吧，大约三分之二这么好，我们

00:31:45.080 --> 00:31:48.710
我要详细一点

00:31:46.340 --> 00:31:51.680
时间允许稍晚一点在幻灯片中

00:31:48.710 --> 00:31:53.630
甲板上那些，但你知道的很

00:31:51.680 --> 00:31:55.070
常见的是您可能想要

00:31:53.630 --> 00:31:56.900
你知道禁用压缩

00:31:55.070 --> 00:31:58.670
压缩oops参考

00:31:56.900 --> 00:32:00.470
无论出于什么原因，我们在这里

00:31:58.670 --> 00:32:02.330
启动JVM，我只是禁用

00:32:00.470 --> 00:32:04.190
那和其他一切都一样

00:32:02.330 --> 00:32:05.620
之前在命令行上

00:32:04.190 --> 00:32:09.350
您会看到我实际上收到了一个错误

00:32:05.620 --> 00:32:12.710
它告诉我，嘿，你认识你，你

00:32:09.350 --> 00:32:15.410
想加载这个äôt库，但是

00:32:12.710 --> 00:32:17.960
实际上是用不同的方式编译的

00:32:15.410 --> 00:32:21.020
设置，而不是JVM运行时

00:32:17.960 --> 00:32:23.480
现在设置，请注意它确实在运行

00:32:21.020 --> 00:32:27.410
该代码实际上没有中断，所以甚至

00:32:23.480 --> 00:32:30.080
当我们无法加载äôt库和

00:32:27.410 --> 00:32:31.280
出于任何原因使用它

00:32:30.080 --> 00:32:33.110
应用程序仍然会烂掉

00:32:31.280 --> 00:32:34.790
只要有一点警告

00:32:33.110 --> 00:32:37.430
如果您没有

00:32:34.790 --> 00:32:41.780
打印出来，它实际上会默默地

00:32:37.430 --> 00:32:44.200
无法加载AOA ot库

00:32:41.780 --> 00:32:46.190
可能是理想的行为，也可能不是

00:32:44.200 --> 00:32:48.740
它确实遵循

00:32:46.190 --> 00:32:53.120
不破坏任何东西的哲学

00:32:48.740 --> 00:32:57.950
目前有效，所以这里的想法是

00:32:53.120 --> 00:33:02.210
您需要匹配您的运行时

00:32:57.950 --> 00:33:04.520
与编译，所以选项

00:33:02.210 --> 00:33:06.530
您在编译期间使用的必须匹配

00:33:04.520 --> 00:33:09.290
运行时使用的选项

00:33:06.530 --> 00:33:10.850
这里我只是指出，如果

00:33:09.290 --> 00:33:12.530
你，如果你带走，我重申

00:33:10.850 --> 00:33:15.410
基本上，如果您拿走

00:33:12.530 --> 00:33:17.570
打印东西，然后运行它，这是

00:33:15.410 --> 00:33:18.950
仍然失败，这是完全一样的

00:33:17.570 --> 00:33:20.730
我刚刚通过的命令行

00:33:18.950 --> 00:33:23.130
除了我们没有冗长

00:33:20.730 --> 00:33:26.820
输出，所以它默默地失败了

00:33:23.130 --> 00:33:30.179
为您加载，但我们必须拥有

00:33:26.820 --> 00:33:31.950
匹配这些选项和

00:33:30.179 --> 00:33:34.350
当前的文档类型

00:33:31.950 --> 00:33:36.179
说出JEP文件，即

00:33:34.350 --> 00:33:38.640
我们必须面对的最接近的事物

00:33:36.179 --> 00:33:41.370
 OT的官方文件

00:33:38.640 --> 00:33:43.110
目前说只是说

00:33:41.370 --> 00:33:45.660
您需要匹配选项，但是

00:33:43.110 --> 00:33:47.850
并没有真正说出您的选择

00:33:45.660 --> 00:33:50.790
确实需要匹配，尽管

00:33:47.850 --> 00:33:51.990
暗示，实际上只有两个

00:33:50.790 --> 00:33:53.370
您需要担心的事情

00:33:51.990 --> 00:33:55.230
担心哪个垃圾收集器

00:33:53.370 --> 00:33:57.630
您正在使用，您需要担心

00:33:55.230 --> 00:33:59.640
是否启用压缩的oop或

00:33:57.630 --> 00:34:02.309
没有，这很有趣

00:33:59.640 --> 00:34:04.290
关于为什么这样的事情，但仅仅是

00:34:02.309 --> 00:34:06.990
在这里总结，以便您可以想到

00:34:04.290 --> 00:34:09.750
每个单独的编译-编译

00:34:06.990 --> 00:34:12.750
每一次运行都属于

00:34:09.750 --> 00:34:14.100
这四个象限，所以您知道每个

00:34:12.750 --> 00:34:15.960
这些可以被认为是一个

00:34:14.100 --> 00:34:18.419
二进制的东西，它要么开要么关

00:34:15.960 --> 00:34:19.740
我会给你，让你坚持其中之一

00:34:18.419 --> 00:34:22.109
这些东西，只要你匹配

00:34:19.740 --> 00:34:24.570
您的运行时编译

00:34:22.109 --> 00:34:29.520
设置，那么库应该是

00:34:24.570 --> 00:34:30.840
加载，我们确保它是

00:34:29.520 --> 00:34:32.850
健全性在加载时检查

00:34:30.840 --> 00:34:35.010
库，这样您就永远不会结束

00:34:32.850 --> 00:34:37.500
加载不兼容的东西

00:34:35.010 --> 00:34:38.850
通过运行时，我们还可以

00:34:37.500 --> 00:34:41.369
当然要检查课程没有

00:34:38.850 --> 00:34:44.760
改变了，所以里面有代码

00:34:41.369 --> 00:34:46.649
基本上是指纹类

00:34:44.760 --> 00:34:48.389
不是我们不是真的想要

00:34:46.649 --> 00:34:50.570
恶意用户尝试做任何事情

00:34:48.389 --> 00:34:53.220
偷偷摸摸的，所以它不像加密

00:34:50.570 --> 00:34:54.419
声音哈希或类似的东西，但它

00:34:53.220 --> 00:34:56.850
应该足以防止您

00:34:54.419 --> 00:34:59.550
意外地更改了您的

00:34:56.850 --> 00:35:02.850
类，因此字节码与

00:34:59.550 --> 00:35:06.390
从一个OT产生的库

00:35:02.850 --> 00:35:07.950
相同字节码的编译，为什么

00:35:06.390 --> 00:35:11.130
我们需要同步VM选项吗

00:35:07.950 --> 00:35:12.600
看起来真的很武断

00:35:11.130 --> 00:35:15.270
身体的疼痛就这样晃来晃去

00:35:12.600 --> 00:35:17.430
这是一个可用性问题

00:35:15.270 --> 00:35:20.490
这里肯定有改进的空间

00:35:17.430 --> 00:35:22.560
这在内部

00:35:20.490 --> 00:35:24.510
希望使这项工作成为一个路线图

00:35:22.560 --> 00:35:26.640
一点点容易或更美好或更至少

00:35:24.510 --> 00:35:28.500
多一点直觉，但今天你

00:35:26.640 --> 00:35:30.720
你真的做不到我们所说的

00:35:28.500 --> 00:35:32.100
作为交叉编译，我的意思是

00:35:30.720 --> 00:35:34.140
交叉编译不是我在说

00:35:32.100 --> 00:35:34.470
从一种CPU类型到另一种

00:35:34.140 --> 00:35:36.480
甚至

00:35:34.470 --> 00:35:39.150
就像我们压缩了参考文献一样

00:35:36.480 --> 00:35:40.890
使用运行OT工具的JVM 

00:35:39.150 --> 00:35:43.230
使用对运行时的压缩引用

00:35:40.890 --> 00:35:45.119
不使用压缩参考

00:35:43.230 --> 00:35:47.130
我们目前不支持，为什么

00:35:45.119 --> 00:35:48.930
如果我们看一下我们不是很好地支持

00:35:47.130 --> 00:35:51.660
压缩的参考对象或压缩的

00:35:48.930 --> 00:35:54.500
哎呀哎呀哎呀

00:35:51.660 --> 00:35:57.480
熟悉oops先生的每个人

00:35:54.500 --> 00:35:59.400
好的，哎呀，仅表示参考

00:35:57.480 --> 00:36:01.560
指向堆上对象的指针

00:35:59.400 --> 00:36:04.020
它代表普通的对象指针

00:36:01.560 --> 00:36:06.780
这是一个奇怪的名字，但是

00:36:04.020 --> 00:36:11.010
有很多历史先例

00:36:06.780 --> 00:36:12.720
闲聊和自我显然使用了这个

00:36:11.010 --> 00:36:15.780
学期，这就是为什么我们继承了

00:36:12.720 --> 00:36:19.260
它，当然还有热点JVM 

00:36:15.780 --> 00:36:21.119
是从自我运行时演变而来的

00:36:19.260 --> 00:36:23.760
免费使用那里的很多历史

00:36:21.119 --> 00:36:25.650
学期，但我们知道在这里，小伙子们会想到

00:36:23.760 --> 00:36:27.359
对象引用是一个指针

00:36:25.650 --> 00:36:30.119
到堆里这样压缩的地方

00:36:27.359 --> 00:36:34.550
 oops是一个压缩的对象指针

00:36:30.119 --> 00:36:36.960
这样的想法是

00:36:34.550 --> 00:36:40.349
最初当你创造的时候

00:36:36.960 --> 00:36:41.790
从32位迁移到64位

00:36:40.349 --> 00:36:44.369
你曾经表现欠佳

00:36:41.790 --> 00:36:45.540
甚至在像Intel这样的平台上付款

00:36:44.369 --> 00:36:47.310
你在哪里得到所有这些

00:36:45.540 --> 00:36:49.109
额外的寄存器和东西等等

00:36:47.310 --> 00:36:51.060
您通常会期望加速

00:36:49.109 --> 00:36:53.310
当您转到64位，因为

00:36:51.060 --> 00:36:56.069
寄存器压力释放到

00:36:53.310 --> 00:36:57.630
在很大程度上，但放缓是

00:36:56.069 --> 00:37:00.510
突然之间事实的结果

00:36:57.630 --> 00:37:02.430
我们所有的参考资料都是64位的

00:37:00.510 --> 00:37:04.140
当然这不是Java特有的

00:37:02.430 --> 00:37:06.089
所有软件都具有相同的

00:37:04.140 --> 00:37:09.750
从32位迁移到

00:37:06.089 --> 00:37:12.960
 64位是突然之间你

00:37:09.750 --> 00:37:15.000
您的带宽成本介于

00:37:12.960 --> 00:37:17.819
内存和CPU，因为所有

00:37:15.000 --> 00:37:19.619
指针的大小现在是指针的两倍大

00:37:17.819 --> 00:37:23.280
堆，也许我们可以做点什么

00:37:19.619 --> 00:37:25.050
减轻开销，并减轻

00:37:23.280 --> 00:37:27.839
使回归变得神奇

00:37:25.050 --> 00:37:30.079
离开，最酷的是这些家伙

00:37:27.839 --> 00:37:33.089
那个儿子确实找到了办法

00:37:30.079 --> 00:37:34.829
实际上我认为我们做到了

00:37:33.089 --> 00:37:37.380
首先是j-rok，他们抄袭了我们，但

00:37:34.829 --> 00:37:40.740
我不确定是什么历史

00:37:37.380 --> 00:37:41.910
那里，但是无论如何，也许我们

00:37:40.740 --> 00:37:44.970
两者都提出了相同的想法

00:37:41.910 --> 00:37:47.069
时间，但想法很简单， 

00:37:44.970 --> 00:37:48.780
如果堆实际上是什么

00:37:47.069 --> 00:37:51.540
小于4 GB 

00:37:48.780 --> 00:37:54.960
那么您就不需要堆地址空间

00:37:51.540 --> 00:37:56.580
大于32位，所以你

00:37:54.960 --> 00:37:59.130
可以做的就是知道堆在上面

00:37:56.580 --> 00:38:01.530
在您地址中的某处

00:37:59.130 --> 00:38:03.780
处理地址空间，然后

00:38:01.530 --> 00:38:07.680
添加该堆的偏移量

00:38:03.780 --> 00:38:10.500
开始每个他的喜好，哦，你

00:38:07.680 --> 00:38:13.470
基本上可以解决整个四个

00:38:10.500 --> 00:38:16.800
无需存储的千兆字节堆

00:38:13.470 --> 00:38:19.740
每个地址的64位，这有一个

00:38:16.800 --> 00:38:22.590
对性能的巨大影响不是

00:38:19.740 --> 00:38:24.930
只是速度而大小，因为所有

00:38:22.590 --> 00:38:26.640
您的物体任何具有很多物体的物体

00:38:24.930 --> 00:38:28.560
对其他对象的引用

00:38:26.640 --> 00:38:30.840
指向其他对象的指针变为

00:38:28.560 --> 00:38:32.520
小得多，所以它实际上可以

00:38:30.840 --> 00:38:35.070
使您的堆消耗较小

00:38:32.520 --> 00:38:36.510
好，这很好

00:38:35.070 --> 00:38:39.300
但这实际上是如何得到的

00:38:36.510 --> 00:38:42.450
实施得很好我说你知道

00:38:39.300 --> 00:38:45.000
我们将64位指针分解为

00:38:42.450 --> 00:38:47.010
两半，所以至少有32位

00:38:45.000 --> 00:38:48.960
有效位，然后是32位

00:38:47.010 --> 00:38:50.250
最重要的部分，这个想法是

00:38:48.960 --> 00:38:52.260
这些不会改变的

00:38:50.250 --> 00:38:53.850
对，如果你有一个堆在下面

00:38:52.260 --> 00:38:55.470
 4 GB，您将其对齐

00:38:53.850 --> 00:38:57.720
正确，所以它不是坐在一个

00:38:55.470 --> 00:39:00.570
你知道两个不同的边界

00:38:57.720 --> 00:39:03.030
一种32位地址空间页

00:39:00.570 --> 00:39:05.670
感觉那么整个这将是

00:39:03.030 --> 00:39:07.170
您的所有指针都一样，所以我们

00:39:05.670 --> 00:39:08.940
可以像扔掉我们一样

00:39:07.170 --> 00:39:11.370
需要保持信息方便

00:39:08.940 --> 00:39:15.330
所以这实际上是存储在

00:39:11.370 --> 00:39:17.880
堆上对象的每个字段

00:39:15.330 --> 00:39:19.980
指向另一个对象

00:39:17.880 --> 00:39:22.170
很好，很花花公子，但是那怎么

00:39:19.980 --> 00:39:23.880
我们实际使用了那个，所以在

00:39:22.170 --> 00:39:25.770
当我们

00:39:23.880 --> 00:39:29.130
实际上在看参考，因为

00:39:25.770 --> 00:39:30.840
显然，如果我们在64位平台上

00:39:29.130 --> 00:39:33.510
有一个指针在寄存器中

00:39:30.840 --> 00:39:35.760
 CPU或其中的某处

00:39:33.510 --> 00:39:38.250
线程执行栈必须是

00:39:35.760 --> 00:39:40.980
真正的64位指针正确，那么我们该怎么办

00:39:38.250 --> 00:39:43.290
展开或解压缩，基本上

00:39:40.980 --> 00:39:45.390
我们要做的就是添加基础

00:39:43.290 --> 00:39:46.530
堆的地址，所以它非常

00:39:45.390 --> 00:39:47.760
简单，真的很容易，但是

00:39:46.530 --> 00:39:50.400
我们必须要做的事情

00:39:47.760 --> 00:39:52.230
编译的代码必须这样做，所以这是

00:39:50.400 --> 00:39:55.380
我们必须提前知道的时候

00:39:52.230 --> 00:39:56.760
我们编译这实际上是

00:39:55.380 --> 00:39:58.470
指出你知道这实际上是

00:39:56.760 --> 00:40:00.210
压缩参考不完整

00:39:58.470 --> 00:40:01.860
参考，然后我们必须实际

00:40:00.210 --> 00:40:05.640
操纵它，但是

00:40:01.860 --> 00:40:08.700
或者我们可以以原始形式使用它

00:40:05.640 --> 00:40:10.260
真正便宜又容易做，但是更多

00:40:08.700 --> 00:40:12.630
复杂的例子是如果堆

00:40:10.260 --> 00:40:14.970
在4到32 GB之间

00:40:12.630 --> 00:40:16.770
令人惊讶的是，我们实际上可以做到

00:40:14.970 --> 00:40:20.250
压缩的引用他们也是

00:40:16.770 --> 00:40:22.560
诀窍是在64位平台上

00:40:20.250 --> 00:40:25.290
有对齐要求，所以

00:40:22.560 --> 00:40:28.140
我们必须从根本上开始一切

00:40:25.290 --> 00:40:30.150
地址始终具有8的倍数

00:40:28.140 --> 00:40:33.030
是8的倍数，所以这意味着

00:40:30.150 --> 00:40:35.370
至少在地址中

00:40:33.030 --> 00:40:37.950
有效的3位总是

00:40:35.370 --> 00:40:39.870
为0，这当然意味着

00:40:37.950 --> 00:40:42.360
认为那是多余的

00:40:39.870 --> 00:40:45.870
我们不需要的信息

00:40:42.360 --> 00:40:47.910
一种扩展我们的能力

00:40:45.870 --> 00:40:52.140
最大的地址空间

00:40:47.910 --> 00:40:54.120
我们可以推理到它的8倍

00:40:52.140 --> 00:40:57.810
之前，所以实际上给了我们

00:40:54.120 --> 00:41:00.930
我们占用了32 GB的空间

00:40:57.810 --> 00:41:04.740
只能参考32张独特的床

00:41:00.930 --> 00:41:06.690
所以我们只是拿出来

00:41:04.740 --> 00:41:08.220
那么你知道那唯一的部分

00:41:06.690 --> 00:41:10.830
可以这么说，这是

00:41:08.220 --> 00:41:12.390
什么存储在堆中，然后

00:41:10.830 --> 00:41:15.090
我们所扔的所有其他东西

00:41:12.390 --> 00:41:16.890
离开，但同样有代价

00:41:15.090 --> 00:41:20.130
在运行中没有太多的表现

00:41:16.890 --> 00:41:22.890
时间，但是很复杂，所以当我们

00:41:20.130 --> 00:41:25.070
现在进行编译，我们需要意识到

00:41:22.890 --> 00:41:28.200
我们只需要添加一些基础

00:41:25.070 --> 00:41:33.840
地址堆所在的地址，但是我们

00:41:28.200 --> 00:41:36.240
还得把地址移三

00:41:33.840 --> 00:41:38.220
三位数三位数

00:41:36.240 --> 00:41:39.690
向左还是向右取决于我们是

00:41:38.220 --> 00:41:42.720
压缩或解压缩

00:41:39.690 --> 00:41:46.320
有趣的是，这有

00:41:42.720 --> 00:41:49.890
这种转变基本上是免费的，因为

00:41:46.320 --> 00:41:51.470
我们支持的CPU允许移动

00:41:49.890 --> 00:41:54.000
说明有一个比例因子

00:41:51.470 --> 00:41:58.770
这是指令中内置的，所以我们

00:41:54.000 --> 00:42:01.650
可以上升到我们可以乘以

00:41:58.770 --> 00:42:04.380
八，当我们做这些动作，等等

00:42:01.650 --> 00:42:07.500
实际上没有换班指令

00:42:04.380 --> 00:42:09.240
被添加到输出代码中

00:42:07.500 --> 00:42:11.820
紧凑而一致

00:42:09.240 --> 00:42:14.070
说明，所以我们免费获得

00:42:11.820 --> 00:42:14.589
 äôt编译器必须意识到这一点

00:42:14.070 --> 00:42:16.930
它必须

00:42:14.589 --> 00:42:19.479
为此，这就是为什么我们必须

00:42:16.930 --> 00:42:21.999
匹配我们的或VM选项

00:42:19.479 --> 00:42:24.009
现在是垃圾回收策略

00:42:21.999 --> 00:42:26.710
垃圾收集是一个巨大的话题

00:42:24.009 --> 00:42:28.450
一堆非常复杂的细节

00:42:26.710 --> 00:42:30.190
你不知道我们真的没有

00:42:28.450 --> 00:42:32.049
时间涵盖，但只给一个

00:42:30.190 --> 00:42:33.700
为什么需要注意的示例

00:42:32.049 --> 00:42:37.210
什么是垃圾收集器

00:42:33.700 --> 00:42:38.619
在编译时使用

00:42:37.210 --> 00:42:41.410
为此它是否是鸡肉锅

00:42:38.619 --> 00:42:45.160
编译或物联网编译是

00:42:41.410 --> 00:42:47.440
正确设置障碍的必要性

00:42:45.160 --> 00:42:50.859
障碍基本上是我们可以

00:42:47.440 --> 00:42:52.690
用于避免为标记做标记

00:42:50.859 --> 00:42:53.859
整个堆，当我说马克的时候

00:42:52.690 --> 00:42:56.109
谈论标记为“扫一扫” 

00:42:53.859 --> 00:42:59.410
女人mm，我们想看看堆

00:42:56.109 --> 00:43:02.099
我只想确定哪些对象

00:42:59.410 --> 00:43:04.569
是活着还是死了

00:43:02.099 --> 00:43:06.160
显然，很长一段时间以来

00:43:04.569 --> 00:43:07.719
使用了一种称为世代的技术

00:43:06.160 --> 00:43:09.940
垃圾收集基于

00:43:07.719 --> 00:43:12.430
世代假设，那就是

00:43:09.940 --> 00:43:15.369
我们将堆分成一个区域

00:43:12.430 --> 00:43:17.380
年轻，然后老，我

00:43:15.369 --> 00:43:19.599
故意简化

00:43:17.380 --> 00:43:22.210
显然，g1看起来一无所有

00:43:19.599 --> 00:43:23.920
就像这样，甚至没有CMS之类的东西

00:43:22.210 --> 00:43:25.660
你知道那里有拾荒空间

00:43:23.920 --> 00:43:27.819
角色执行更多

00:43:25.660 --> 00:43:29.289
复杂，但总的来说，有时我们

00:43:27.819 --> 00:43:32.259
有我们关心的堆部分

00:43:29.289 --> 00:43:33.880
关于我们想要收集的信息，您

00:43:32.259 --> 00:43:35.440
知道我很频繁，我们还有其他

00:43:33.880 --> 00:43:37.119
我们不堆的部分

00:43:35.440 --> 00:43:40.359
一定要收集或

00:43:37.119 --> 00:43:41.619
经常标记，所以我们有

00:43:40.359 --> 00:43:44.739
我们要处理一些分歧

00:43:41.619 --> 00:43:46.509
他们不同，所以如果我进来，我

00:43:44.739 --> 00:43:49.599
试图做某种并发

00:43:46.509 --> 00:43:51.880
例如收藏，我知道

00:43:49.599 --> 00:43:53.529
 execution子手mutator线程进来

00:43:51.880 --> 00:43:55.989
并创建一个新对象，然后有一个

00:43:53.529 --> 00:43:58.239
然后修改一些

00:43:55.989 --> 00:44:00.069
堆上其他先前存在的对象

00:43:58.239 --> 00:44:02.049
指向这个新对象

00:44:00.069 --> 00:44:03.910
好吧，这还可以，我们不是真的

00:44:02.049 --> 00:44:05.650
需要保持跟踪，因为如果

00:44:03.910 --> 00:44:07.390
这是新事物的年轻空间

00:44:05.650 --> 00:44:09.099
托儿所的空间或其他

00:44:07.390 --> 00:44:11.289
在实际的垃圾收集器中

00:44:09.099 --> 00:44:14.319
使用我们会在标记时找到它

00:44:11.289 --> 00:44:16.869
这个区域，所以这实际上是一个

00:44:14.319 --> 00:44:18.670
你本身就很好，但是什么

00:44:16.869 --> 00:44:21.249
如果我们在旧空间有东西，或者

00:44:18.670 --> 00:44:22.900
你知道我们不知道的任何地区

00:44:21.249 --> 00:44:24.339
想要标记您知道这是在

00:44:22.900 --> 00:44:27.130
我们没有的堆的一部分

00:44:24.339 --> 00:44:28.569
经常去尝试收集

00:44:27.130 --> 00:44:31.179
好吧，如果

00:44:28.569 --> 00:44:34.779
该代码修改了地址指针或

00:44:31.179 --> 00:44:36.009
一个非收集中的OOP 

00:44:34.779 --> 00:44:38.739
我们不打算去的地区

00:44:36.009 --> 00:44:40.239
接下来收集我们需要跟踪

00:44:38.739 --> 00:44:43.089
我们需要以某种方式进行簿记

00:44:40.239 --> 00:44:45.009
所以我们要做的是

00:44:43.089 --> 00:44:47.890
叫做卡表，而卡表是

00:44:45.009 --> 00:44:49.959
基本上是它使用的数据结构

00:44:47.890 --> 00:44:51.509
对于我们的写障碍，那么什么是

00:44:49.959 --> 00:44:54.249
写障碍写障碍

00:44:51.509 --> 00:44:56.679
我们在我们接受的其他代码

00:44:54.249 --> 00:44:59.739
 JIT编译或解释器

00:44:56.679 --> 00:45:01.630
执行说，如果你，如果你

00:44:59.739 --> 00:45:03.519
如果您在堆上写东西

00:45:01.630 --> 00:45:05.289
在堆上的任何地方更改地址

00:45:03.519 --> 00:45:07.509
您想在此做一点标记

00:45:05.289 --> 00:45:09.549
卡表某处说嘿

00:45:07.509 --> 00:45:11.559
这里有一个变化，所以每个小块

00:45:09.549 --> 00:45:15.880
牌桌基本上就像一个

00:45:11.559 --> 00:45:20.979
恰好对应于的地图

00:45:15.880 --> 00:45:23.469
是堆的512字节，所以如果

00:45:20.979 --> 00:45:25.719
有一个，因为每个

00:45:23.469 --> 00:45:27.729
如果已设置该标志，则视为标志

00:45:25.719 --> 00:45:29.799
告诉垃圾收集器

00:45:27.729 --> 00:45:32.140
嘿，有变化，你知道

00:45:29.799 --> 00:45:34.089
堆的大块与此对应

00:45:32.140 --> 00:45:35.229
一个标志那里发生了变化， 

00:45:34.089 --> 00:45:39.429
你应该去看看

00:45:35.229 --> 00:45:42.429
所以现在当我们修改任何对象时

00:45:39.429 --> 00:45:44.349
你知道任何对象字段或指针

00:45:42.429 --> 00:45:47.650
我们只标记对象中的字段

00:45:44.349 --> 00:45:49.839
在那里，然后在这里，不是年轻的我们

00:45:47.650 --> 00:45:52.689
标记在那里-然后当我们做一个

00:45:49.839 --> 00:45:54.819
 GC我们可以知道年轻吗

00:45:52.689 --> 00:45:57.009
我们一如既往的收藏

00:45:54.819 --> 00:46:00.130
知道标记整个事情，然后我们

00:45:57.009 --> 00:46:02.769
可以检查单个零件

00:46:00.130 --> 00:46:05.109
我们没有收集到的部分

00:46:02.769 --> 00:46:07.630
看看是否有任何传入的指针和

00:46:05.109 --> 00:46:09.429
这比拥有

00:46:07.630 --> 00:46:10.900
标记整个东西，所以在

00:46:09.429 --> 00:46:12.759
简而言之，我们如何代代相传

00:46:10.900 --> 00:46:14.799
收集，这也是我们的工作方式

00:46:12.759 --> 00:46:17.380
卡表上的并发收集

00:46:14.799 --> 00:46:19.179
牌桌上正确的障碍是

00:46:17.380 --> 00:46:21.339
这两个部分不可分割的一部分

00:46:19.179 --> 00:46:23.949
 GC，我想知道现在

00:46:21.339 --> 00:46:27.189
很容易理解，当我们

00:46:23.949 --> 00:46:29.439
 OT编译器编译的类

00:46:27.189 --> 00:46:31.659
需要知道什么垃圾收集

00:46:29.439 --> 00:46:33.339
我们正在使用的算法，因为我们需要

00:46:31.659 --> 00:46:35.019
知道是否会有正确的障碍

00:46:33.339 --> 00:46:37.390
如果您正在使用，则是否需要

00:46:35.019 --> 00:46:40.659
并行GC我们实际上不需要

00:46:37.390 --> 00:46:41.890
正确的障碍一定知道

00:46:40.659 --> 00:46:45.580
如果不是

00:46:41.890 --> 00:46:47.200
世代收藏家不是我

00:46:45.580 --> 00:46:48.730
意味着在某些情况下我们没有

00:46:47.200 --> 00:46:50.530
我们需要不同类型的右路障碍

00:46:48.730 --> 00:46:52.450
有不同的数据结构

00:46:50.530 --> 00:46:54.970
 GC使用需要或不需要

00:46:52.450 --> 00:46:56.680
更新，您知道这一切都取决于

00:46:54.970 --> 00:46:59.200
各个垃圾收集器

00:46:56.680 --> 00:47:01.630
您正在使用，但关键要点是

00:46:59.200 --> 00:47:03.820
我们需要知道什么垃圾

00:47:01.630 --> 00:47:08.350
收藏家的期望是，但是当我们

00:47:03.820 --> 00:47:10.270
编译，无论如何，我们有这四个

00:47:08.350 --> 00:47:13.120
一类或四种不同的方案

00:47:10.270 --> 00:47:15.880
不同类型的äôt编译

00:47:13.120 --> 00:47:18.880
我们最终可以得到结果，每个

00:47:15.880 --> 00:47:20.790
一个对应于一组GART 

00:47:18.880 --> 00:47:21.970
选择垃圾收集器和

00:47:20.790 --> 00:47:25.890
压缩的

00:47:21.970 --> 00:47:28.870
 oops已启用或未启用，并且

00:47:25.890 --> 00:47:31.300
实际上有一个已知的

00:47:28.870 --> 00:47:34.570
库名称，如果我们坚持这些

00:47:31.300 --> 00:47:38.320
这些库在Lib目录下

00:47:34.570 --> 00:47:40.150
 JDK目录中的JVM运行时

00:47:38.320 --> 00:47:42.520
实际上会自动找到这些

00:47:40.150 --> 00:47:45.220
并使用它们，但这仅适用于一小部分

00:47:42.520 --> 00:47:47.890
逻辑模块的子集

00:47:45.220 --> 00:47:51.340
实际上是JDK本身的一部分

00:47:47.890 --> 00:47:53.440
现在，如果您想使用自己的

00:47:51.340 --> 00:47:55.480
你知道你要不要OT编译

00:47:53.440 --> 00:47:58.900
自己上课是您唯一的选择

00:47:55.480 --> 00:48:02.140
今天要传递的是库文件

00:47:58.900 --> 00:48:05.200
在命令行上命名，但如果您是

00:48:02.140 --> 00:48:07.240
做一个JDK的一部分

00:48:05.200 --> 00:48:08.910
本身就是JDK中的一个模块

00:48:07.240 --> 00:48:11.350
本身，这是这五个之一

00:48:08.910 --> 00:48:14.710
包裹，或者我很抱歉其中一个包裹

00:48:11.350 --> 00:48:17.140
这四个模块之一或Java的五个模块

00:48:14.710 --> 00:48:20.770
如果是这五种之一，那么您

00:48:17.140 --> 00:48:23.560
可以将其粘贴到库中的库中

00:48:20.770 --> 00:48:26.650
目录，JVM可能会选择它

00:48:23.560 --> 00:48:30.480
自动，所以我们没时间了，但是

00:48:26.650 --> 00:48:33.520
只是把东西包起来，这样的价值

00:48:30.480 --> 00:48:35.560
 ot编译在这里添加的是

00:48:33.520 --> 00:48:37.360
它确实为您提供了更快的开始

00:48:35.560 --> 00:48:39.430
更快地达到最佳性能

00:48:37.360 --> 00:48:41.800
如果您有一个较小的足迹

00:48:39.430 --> 00:48:43.930
多个JVM，总占地面积较小

00:48:41.800 --> 00:48:46.990
如果您有多个JVM运行

00:48:43.930 --> 00:48:48.880
相同的代码，我们甚至可以继续

00:48:46.990 --> 00:48:51.940
否则将不允许的平台

00:48:48.880 --> 00:48:54.160
在这里喷射风险，需要注意的是

00:48:51.940 --> 00:48:55.180
这是实验性的，不是

00:48:54.160 --> 00:48:58.450
记录

00:48:55.180 --> 00:49:00.880
它今天只能在Linux amd64上运行，并且

00:48:58.450 --> 00:49:04.030
自定义类加载器invokedynamic或

00:49:00.880 --> 00:49:06.880
印度不受支持，当然

00:49:04.030 --> 00:49:09.099
您的里程可能会有所不同，因此其他

00:49:06.880 --> 00:49:10.780
会议是这个

00:49:09.099 --> 00:49:12.970
介绍一，这是怎么一回事

00:49:10.780 --> 00:49:14.140
使用它，无论您是否知道

00:49:12.970 --> 00:49:15.819
您需要考虑的信息

00:49:14.140 --> 00:49:17.349
您是否想要使用它

00:49:15.819 --> 00:49:19.960
做出决定并希望

00:49:17.349 --> 00:49:21.609
你会带着感觉离开这里

00:49:19.960 --> 00:49:23.200
你已经知道了，但是如果你想

00:49:21.609 --> 00:49:24.270
我将在下面更深入的讨论

00:49:23.200 --> 00:49:27.339
引擎盖

00:49:24.270 --> 00:49:28.869
这些家伙正在做一个演讲

00:49:27.339 --> 00:49:31.240
他们还以JVM语言交付

00:49:28.869 --> 00:49:32.589
首脑会议，这是很棒的

00:49:31.240 --> 00:49:35.980
在语言峰会上，您实际上可以

00:49:32.589 --> 00:49:38.140
如果您无法在YouTube上捕捉到它

00:49:35.980 --> 00:49:40.089
去看今天的直播，但是如果你能适应的话

00:49:38.140 --> 00:49:42.130
我强烈建议将其纳入您的日程安排

00:49:40.089 --> 00:49:44.020
去看他们明天的生活

00:49:42.130 --> 00:49:46.809
然后还有另一个会议

00:49:44.020 --> 00:49:49.589
真的不知道有关的细节，但是

00:49:46.809 --> 00:49:51.910
我猜有人正在做更多的事情

00:49:49.589 --> 00:49:54.670
从根本上讲一些

00:49:51.910 --> 00:49:56.859
静态与静态有关的原理

00:49:54.670 --> 00:49:59.109
 OT编译，所以它应该是

00:49:56.859 --> 00:50:00.700
有趣的谈话，非常感谢

00:49:59.109 --> 00:50:09.250
在您的时间里，我非常感谢

00:50:00.700 --> 00:50:11.530
哦，抱歉，这是你的话题，好的

00:50:09.250 --> 00:50:16.329
是的，所以我敢肯定这会很棒

00:50:11.530 --> 00:50:16.970
说话好吧，非常感谢你的

00:50:16.329 --> 00:50:22.030
时间

00:50:16.970 --> 00:50:22.030
 [掌声] 

