WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.200 --> 00:00:05.850
 [音乐] 

00:00:03.259 --> 00:00:07.830
好的，欢迎参加

00:00:05.850 --> 00:00:09.240
 Java 8中的猫编程我的名字是

00:00:07.830 --> 00:00:10.530
我要谈一谈Venkat Subramanyam 

00:00:09.240 --> 00:00:12.420
关于一般的功能编程

00:00:10.530 --> 00:00:14.820
画一点，然后我画

00:00:12.420 --> 00:00:16.470
 Java 8的示例，看看Java 8如何

00:00:14.820 --> 00:00:19.050
支持其中一些样式，我也会

00:00:16.470 --> 00:00:20.400
对一些做出某些区分

00:00:19.050 --> 00:00:22.140
关于功能风格与

00:00:20.400 --> 00:00:24.689
函数式编程，让我们开始吧

00:00:22.140 --> 00:00:27.000
很好的开始了，真的很好

00:00:24.689 --> 00:00:29.099
关于Java的事情Java已经进化

00:00:27.000 --> 00:00:31.109
融入功能风格

00:00:29.099 --> 00:00:33.750
编程大约20多个

00:00:31.109 --> 00:00:35.280
 Java支持的命令式风格

00:00:33.750 --> 00:00:36.690
编程以及面向对象

00:00:35.280 --> 00:00:38.340
编程风格，但现在我们可以

00:00:36.690 --> 00:00:40.079
实际做的功能风格

00:00:38.340 --> 00:00:41.219
也要编程，但为什么要

00:00:40.079 --> 00:00:43.559
真的很在乎

00:00:41.219 --> 00:00:45.420
功能良好的编程已经

00:00:43.559 --> 00:00:47.730
已经有很长一段时间了

00:00:45.420 --> 00:00:49.289
周围甚至比

00:00:47.730 --> 00:00:51.570
面向对象的编程已经

00:00:49.289 --> 00:00:53.579
周围和有趣的事情之一

00:00:51.570 --> 00:00:55.559
关于功能编程是否解决了

00:00:53.579 --> 00:00:57.210
一定数量的问题

00:00:55.559 --> 00:01:00.120
在过去变得迫在眉睫

00:00:57.210 --> 00:01:02.039
十年左右的事情之一是

00:01:00.120 --> 00:01:04.320
我们正在发展计算机应用

00:01:02.039 --> 00:01:05.939
看到大量使用计算机

00:01:04.320 --> 00:01:08.400
我们没有人的应用

00:01:05.939 --> 00:01:10.080
今天不涉及的骇客活动

00:01:08.400 --> 00:01:12.090
不是的计算机应用程序

00:01:10.080 --> 00:01:13.590
当然是几十年前的事了

00:01:12.090 --> 00:01:16.020
那当然是写作

00:01:13.590 --> 00:01:18.869
代码有两种复杂性

00:01:16.020 --> 00:01:20.850
我们每个人都应对其中之一

00:01:18.869 --> 00:01:23.640
它们是固有的内在复杂性

00:01:20.850 --> 00:01:26.400
复杂性是根本的复杂性

00:01:23.640 --> 00:01:28.560
的应用程序域和

00:01:26.400 --> 00:01:30.540
另一方面，我们处理很多事情

00:01:28.560 --> 00:01:33.659
与也被称为偶然

00:01:30.540 --> 00:01:35.220
不幸的是，尽管我们

00:01:33.659 --> 00:01:37.829
无法摆脱固有的

00:01:35.220 --> 00:01:39.840
复杂性很多我们在努力

00:01:37.829 --> 00:01:41.670
每一天都是偶然的

00:01:39.840 --> 00:01:44.189
我要提出的复杂性

00:01:41.670 --> 00:01:46.890
编程的命令式风格是

00:01:44.189 --> 00:01:49.110
本质上复杂的功能

00:01:46.890 --> 00:01:51.270
编程已消除了意外情况

00:01:49.110 --> 00:01:53.100
从我们的肩膀上看那是一个复杂性

00:01:51.270 --> 00:01:55.320
为什么这更好的原因

00:01:53.100 --> 00:01:57.240
很多东西的编程模型

00:01:55.320 --> 00:01:58.950
可以做到，当然可以

00:01:57.240 --> 00:02:01.590
面向对象程序设计之一

00:01:58.950 --> 00:02:03.840
我们很快遇到的是

00:02:01.590 --> 00:02:06.119
并没有很好地处理可变状态

00:02:03.840 --> 00:02:08.160
很好，共享可变，但它

00:02:06.119 --> 00:02:10.020
变成一个真正的问题，当然

00:02:08.160 --> 00:02:12.590
随着多核处理器的出现

00:02:10.020 --> 00:02:14.060
我们不再真正在交易

00:02:12.590 --> 00:02:16.209
在一个线程上运行多个线程

00:02:14.060 --> 00:02:18.319
单机或单处理器

00:02:16.209 --> 00:02:20.269
多线程剪确实是

00:02:18.319 --> 00:02:22.790
多线程，多线程

00:02:20.269 --> 00:02:24.230
可以运行，当然， 

00:02:22.790 --> 00:02:26.150
可能假装在

00:02:24.230 --> 00:02:28.910
单核实际上可能最终被

00:02:26.150 --> 00:02:31.280
在多核处理器上坏了怎么办

00:02:28.910 --> 00:02:33.739
我们管理好其中一些使用情况吗？ 

00:02:31.280 --> 00:02:34.580
最大的问题是可变状态

00:02:33.739 --> 00:02:36.709
好

00:02:34.580 --> 00:02:39.110
几乎每个人都是可变性

00:02:36.709 --> 00:02:41.180
这已经做完了，我们真的不觉得

00:02:39.110 --> 00:02:44.209
关于可变性的问题太糟糕了

00:02:41.180 --> 00:02:45.829
好的，分享好分享

00:02:44.209 --> 00:02:48.590
记得妈妈说的是好事

00:02:45.829 --> 00:02:51.260
我们分享，所以可变性还可以

00:02:48.590 --> 00:02:53.390
共享是好的，但共享的知名度是

00:02:51.260 --> 00:02:55.370
我们带来共享的那一刻，魔鬼的作品

00:02:53.390 --> 00:02:58.310
可变性很多事情都会出错

00:02:55.370 --> 00:03:00.769
真的很难，其中之一是

00:02:58.310 --> 00:03:02.420
我记得非常容易出错的代码

00:03:00.769 --> 00:03:04.579
有一天开发商来找我，他

00:03:02.420 --> 00:03:06.170
说得好，这里的代码不是

00:03:04.579 --> 00:03:08.569
工作，你可以看看它是

00:03:06.170 --> 00:03:10.519
公平，这不是一个很长的

00:03:08.569 --> 00:03:11.930
代码，然后我迅速查看了

00:03:10.519 --> 00:03:13.099
我说如果您发送此输入，应该

00:03:11.930 --> 00:03:15.530
给你这个输出是我知道

00:03:13.099 --> 00:03:17.060
是的，但是事实并非如此，我们俩都是

00:03:15.530 --> 00:03:19.160
像我们一样直视它

00:03:17.060 --> 00:03:21.260
愚蠢的，几分钟后我说

00:03:19.160 --> 00:03:23.660
等等你真的是要改变

00:03:21.260 --> 00:03:26.090
在此为此功能提供的输入

00:03:23.660 --> 00:03:27.590
他以为第七行

00:03:26.090 --> 00:03:29.750
第二，他说我很愚蠢，他

00:03:27.590 --> 00:03:32.480
很多次我们都走的很好

00:03:29.750 --> 00:03:34.609
考虑修改变量

00:03:32.480 --> 00:03:36.709
真的很难，因为它容易出错

00:03:34.609 --> 00:03:38.599
时间代码真的很难推理

00:03:36.709 --> 00:03:40.790
以及我们正在努力

00:03:38.599 --> 00:03:42.889
了解此代码的实际工作方式

00:03:40.790 --> 00:03:44.750
并解释代码也成为

00:03:42.889 --> 00:03:47.239
换句话说，非常困难

00:03:44.750 --> 00:03:49.069
状态更改，我们在代码中

00:03:47.239 --> 00:03:51.709
很难读到一个原因

00:03:49.069 --> 00:03:53.419
代码，当然等到有人

00:03:51.709 --> 00:03:55.639
告诉你使代码并发

00:03:53.419 --> 00:03:57.680
使这样的代码并发是

00:03:55.639 --> 00:04:00.200
事实上难以置信的困难之一

00:03:57.680 --> 00:04:02.269
我们要解决的真正大问题是

00:04:00.200 --> 00:04:04.160
代码的结构非常不同

00:04:02.269 --> 00:04:06.620
在顺序和存在之间

00:04:04.160 --> 00:04:08.660
并发，这真的伤害了我们

00:04:06.620 --> 00:04:10.370
一旦意识到，性能就会超出代码

00:04:08.660 --> 00:04:12.470
我们必须使其并发良好

00:04:10.370 --> 00:04:14.900
函数编程解决了很多

00:04:12.470 --> 00:04:17.780
这些东西，但是旧的是新的

00:04:14.900 --> 00:04:19.070
再次事实上， 

00:04:17.780 --> 00:04:23.390
函数编程真的是

00:04:19.070 --> 00:04:24.890
早在1929年1930年代就引入了

00:04:23.390 --> 00:04:25.970
 lambda演算控制台是

00:04:24.890 --> 00:04:27.290
引进

00:04:25.970 --> 00:04:29.270
当然首先

00:04:27.290 --> 00:04:31.490
编程语言实际上是

00:04:29.270 --> 00:04:33.860
本质上是功能性的，所以这不是

00:04:31.490 --> 00:04:35.480
昨天发明了新奇的想法

00:04:33.860 --> 00:04:38.690
已经存在很长时间了

00:04:35.480 --> 00:04:41.060
只是在等待行业成长

00:04:38.690 --> 00:04:43.280
利用其中的一些想法，但是

00:04:41.060 --> 00:04:45.320
中心概念之一是

00:04:43.280 --> 00:04:47.870
功能编程是赋值

00:04:45.320 --> 00:04:49.850
更少的编程，您可能会说等待

00:04:47.870 --> 00:04:53.060
第二，你不在意

00:04:49.850 --> 00:04:55.490
你怎么不能编程没有作业，所以

00:04:53.060 --> 00:04:58.640
我想与此平行，所以我们

00:04:55.490 --> 00:05:01.490
可以对此有更好的认识

00:04:58.640 --> 00:05:04.010
如果您真的时光倒流

00:05:01.490 --> 00:05:06.530
 60和70年代甚至到80年代

00:05:04.010 --> 00:05:10.130
我们真正关注的一件事

00:05:06.530 --> 00:05:12.890
那是四个字母的单词，所以我

00:05:10.130 --> 00:05:16.070
说去太过结构化

00:05:12.890 --> 00:05:18.290
编程，换句话说， 

00:05:16.070 --> 00:05:21.650
这是我们真正受到打击的东西

00:05:18.290 --> 00:05:23.900
与不使用去牙让我们

00:05:21.650 --> 00:05:26.450
待一会儿

00:05:23.900 --> 00:05:27.680
这是我要使用的Java代码

00:05:26.450 --> 00:05:30.650
往前叫一个小东西

00:05:27.680 --> 00:05:33.980
很好，非常小心地注意到什么

00:05:30.650 --> 00:05:36.590
这对我们说它说错误不是

00:05:33.980 --> 00:05:38.510
声明只是记住，等等是

00:05:36.590 --> 00:05:42.080
不是声明，我要改变

00:05:38.510 --> 00:05:43.550
这个很好，我们知道

00:05:42.080 --> 00:05:46.130
邪恶，我们不应该使用它

00:05:43.550 --> 00:05:48.740
迪克斯特拉告诉我们，哥达人是邪恶的，不要

00:05:46.130 --> 00:05:51.020
使用它，所以我在Java中使用了转到此处

00:05:48.740 --> 00:05:54.250
但是当我运行它时，注意到Java并没有

00:05:51.020 --> 00:05:57.290
说不是声明而是Java说

00:05:54.250 --> 00:06:00.830
非法开始表达那是什么

00:05:57.290 --> 00:06:04.040
 Java表示Go-to是有效的

00:06:00.830 --> 00:06:05.630
关键字，但我敢于使用它，因此

00:06:04.040 --> 00:06:08.030
他们不想要我们的禁止关键字

00:06:05.630 --> 00:06:10.130
使用很好的关键字，但是

00:06:08.030 --> 00:06:11.630
我真的要继续进行

00:06:10.130 --> 00:06:14.210
小代码，我将采取非常

00:06:11.630 --> 00:06:16.160
简单的例子在这里，我们知道我们

00:06:14.210 --> 00:06:18.140
无法使用定位，我们不应该使用定位

00:06:16.160 --> 00:06:20.419
如果有人甚至建议使用转到

00:06:18.140 --> 00:06:22.520
会为他们皱眉，但是很棒

00:06:20.419 --> 00:06:25.520
我要说的很远

00:06:22.520 --> 00:06:27.050
等于零，我小于10，然后

00:06:25.520 --> 00:06:29.600
我当然要做一个非常

00:06:27.050 --> 00:06:31.490
简单的循环在这里我加加

00:06:29.600 --> 00:06:34.250
这种情况我当然要说

00:06:31.490 --> 00:06:36.890
我大于5然后输出

00:06:34.250 --> 00:06:38.810
变数我所以没什么大不了的，但是

00:06:36.890 --> 00:06:39.990
我们称之为结构化编程

00:06:38.810 --> 00:06:41.610
它是结构化的程序

00:06:39.990 --> 00:06:43.680
因为我们对

00:06:41.610 --> 00:06:45.539
代码我们正在堆积代码一

00:06:43.680 --> 00:06:47.130
一个又一个又一个好

00:06:45.539 --> 00:06:48.870
入口点有一个很好的出口点

00:06:47.130 --> 00:06:50.880
嘿，这真的很有意义

00:06:48.870 --> 00:06:52.470
基本上这就是我们所说的

00:06:50.880 --> 00:06:54.599
结构化编程，但我是

00:06:52.470 --> 00:06:56.310
虽然我要去这里做

00:06:54.599 --> 00:06:58.919
转到命令行并说Java P 

00:06:56.310 --> 00:07:00.930
减C和减C已经是别名

00:06:58.919 --> 00:07:03.120
在我的机器上，所以我不会提供

00:07:00.930 --> 00:07:05.400
然后我要说正确的课程

00:07:03.120 --> 00:07:08.250
在这里采样，让我们​​看一下

00:07:05.400 --> 00:07:09.720
字节码，如果您感到惊讶

00:07:08.250 --> 00:07:13.020
看看正在生成的字节码

00:07:09.720 --> 00:07:15.120
您在那边看到了什么

00:07:13.020 --> 00:07:16.349
字节码嘿，等一下我们说

00:07:15.120 --> 00:07:19.110
在结构化程序中

00:07:16.349 --> 00:07:22.020
不应该使用合二为一的工具

00:07:19.110 --> 00:07:24.000
喜欢比赛，我确定这里的每个人

00:07:22.020 --> 00:07:25.949
家里有火柴，我们都用火柴

00:07:24.000 --> 00:07:27.389
但你不要去孩子们说

00:07:25.949 --> 00:07:28.650
孩子们，我要去这里洗个澡

00:07:27.389 --> 00:07:31.320
有一些比赛供您玩

00:07:28.650 --> 00:07:33.120
我们使用火柴，但是火柴是为了

00:07:31.320 --> 00:07:34.440
大人不要给孩子玩

00:07:33.120 --> 00:07:36.419
以案例为例

00:07:34.440 --> 00:07:39.139
去是完全一样的，所以

00:07:36.419 --> 00:07:41.669
结构化程序将转到

00:07:39.139 --> 00:07:44.699
除了我们不会去

00:07:41.669 --> 00:07:47.880
我们的代码可能会起作用

00:07:44.699 --> 00:07:50.550
下面以非常类似的方式

00:07:47.880 --> 00:07:52.470
说我们少分配编程

00:07:50.550 --> 00:07:54.720
不说没有作业期

00:07:52.470 --> 00:07:58.199
我们在说，就像我们不

00:07:54.720 --> 00:08:00.210
使用转到，我们将不使用分配，但

00:07:58.199 --> 00:08:02.580
就像任务一样

00:08:00.210 --> 00:08:04.789
可以在引擎盖下完成

00:08:02.580 --> 00:08:09.110
也可能在引擎盖下发生

00:08:04.789 --> 00:08:12.120
作业很容易分配

00:08:09.110 --> 00:08:14.370
函数式编程，这是一种方法

00:08:12.120 --> 00:08:16.169
得出区分是

00:08:14.370 --> 00:08:17.789
结构化的编程像

00:08:16.169 --> 00:08:20.849
分配这两个功能

00:08:17.789 --> 00:08:22.979
编程是邪恶的一部分

00:08:20.849 --> 00:08:24.690
我们尝试避免的事情

00:08:22.979 --> 00:08:27.630
为了避免去讲师编程，我们

00:08:24.690 --> 00:08:29.610
尽量避免在功能中分配

00:08:27.630 --> 00:08:31.830
编程，但是很多时候我使用

00:08:29.610 --> 00:08:33.810
单词显式分配而不是

00:08:31.830 --> 00:08:35.399
分配意味着我们不做

00:08:33.810 --> 00:08:38.370
作业，但可能发生在

00:08:35.399 --> 00:08:40.229
罩在井下面

00:08:38.370 --> 00:08:42.450
接下来的事情当然是处理

00:08:40.229 --> 00:08:45.180
不变的状态，我们不想成为

00:08:42.450 --> 00:08:47.040
改变状态相反，我们想要

00:08:45.180 --> 00:08:49.020
尽最大可能改变状态

00:08:47.040 --> 00:08:51.089
而且因为改变国家

00:08:49.020 --> 00:08:53.370
变得更容易推理和

00:08:51.089 --> 00:08:54.960
工作而不是改变状态

00:08:53.370 --> 00:08:56.880
但显然还有一个问题

00:08:54.960 --> 00:08:59.160
凯拉，如果你要成为我的天哪

00:08:56.880 --> 00:09:01.800
处理不可变状态，你会

00:08:59.160 --> 00:09:04.140
不能通过复制对象来提高性能

00:09:01.800 --> 00:09:05.910
一遍又一遍，让我们想一想

00:09:04.140 --> 00:09:08.550
关于真正平行的东西

00:09:05.910 --> 00:09:10.500
版本控件又在做

00:09:08.550 --> 00:09:12.960
这很长一段时间，当您处理

00:09:10.500 --> 00:09:15.210
您签入文件的版本控制

00:09:12.960 --> 00:09:17.700
版本控制功能不完整

00:09:15.210 --> 00:09:20.190
文件的副本显然是做什么的

00:09:17.700 --> 00:09:22.260
他们做得很好吗？ 

00:09:20.190 --> 00:09:24.630
他们保持差异的地方

00:09:22.260 --> 00:09:26.700
换句话说，我们进行智能复制

00:09:24.630 --> 00:09:29.700
而不是通过复制或完整

00:09:26.700 --> 00:09:31.890
以类似的方式复制语言和

00:09:29.700 --> 00:09:33.870
工具和库可以为我们做到这一点

00:09:31.890 --> 00:09:36.420
当我们复制对象时

00:09:33.870 --> 00:09:38.940
不一定要是完整副本

00:09:36.420 --> 00:09:41.670
一个非常有效的例子就是

00:09:38.940 --> 00:09:43.770
一个例子是尝试上升的地方

00:09:41.670 --> 00:09:46.740
数据结构在

00:09:43.770 --> 00:09:49.560
像闭包和Scala这样的语言

00:09:46.740 --> 00:09:52.290
两次制作非常智能的对象副本

00:09:49.560 --> 00:09:54.240
按需复制最少

00:09:52.290 --> 00:09:56.010
同样变得非常有效

00:09:54.240 --> 00:09:58.380
图书馆也可以很聪明

00:09:56.010 --> 00:10:00.420
他们处理数据，以便他们可以最小化

00:09:58.380 --> 00:10:02.760
这些垃圾对象在

00:10:00.420 --> 00:10:04.680
之间，所以有一些方法可以真正保存

00:10:02.760 --> 00:10:06.990
在实现这些目标的同时表现

00:10:04.680 --> 00:10:09.150
也是最重要的之一

00:10:06.990 --> 00:10:11.610
要考虑的是功能

00:10:09.150 --> 00:10:13.320
被认为是头等公民

00:10:11.610 --> 00:10:15.270
这真正意味着功能是什么

00:10:13.320 --> 00:10:18.240
头等舱公民好意思

00:10:15.270 --> 00:10:21.570
到目前为止，我们所做的是

00:10:18.240 --> 00:10:24.440
不能很好地传递对象

00:10:21.570 --> 00:10:27.810
确保我们可以在这种情况下创建一个

00:10:24.440 --> 00:10:29.810
功能内的对象，然后

00:10:27.810 --> 00:10:33.089
最后，我们当然不能返回

00:10:29.810 --> 00:10:34.950
函数中的对象，所以我们习惯了

00:10:33.089 --> 00:10:37.020
做这些事很久了

00:10:34.950 --> 00:10:39.000
但是如果我们将函数视为

00:10:37.020 --> 00:10:40.920
一流的公民，我们可以开始

00:10:39.000 --> 00:10:42.990
对待他们并四处移动

00:10:40.920 --> 00:10:45.270
换句话说，将它们绕过

00:10:42.990 --> 00:10:47.459
这些被称为高阶函数

00:10:45.270 --> 00:10:49.740
那么什么是高阶函数

00:10:47.459 --> 00:10:51.510
高阶函数通常是

00:10:49.740 --> 00:10:53.400
我们将接受这个想法

00:10:51.510 --> 00:10:56.070
关于，但除了

00:10:53.400 --> 00:10:58.410
我们也可以做对象合成

00:10:56.070 --> 00:11:00.450
功能组成，所以，如果你看

00:10:58.410 --> 00:11:02.940
高阶函数高阶

00:11:00.450 --> 00:11:06.089
函数可以将函数传递给

00:11:02.940 --> 00:11:07.139
以及它们不仅作用于对象

00:11:06.089 --> 00:11:09.329
可以创造乐趣

00:11:07.139 --> 00:11:11.429
功能内的功能，当然

00:11:09.329 --> 00:11:13.769
他们还可以从

00:11:11.429 --> 00:11:15.389
也可以发挥作用

00:11:13.769 --> 00:11:17.699
被称为高阶函数

00:11:15.389 --> 00:11:19.949
您可以非常有效地与我们合作，因此我们

00:11:17.699 --> 00:11:21.809
可以分解或对象化

00:11:19.949 --> 00:11:24.329
分解，但我们也可以

00:11:21.809 --> 00:11:25.829
功能分解也一样

00:11:24.329 --> 00:11:28.829
要保留的最重要的东西

00:11:25.829 --> 00:11:31.049
介意的是功能没有边

00:11:28.829 --> 00:11:33.629
我想强调的是

00:11:31.049 --> 00:11:36.319
分钟，因为很容易错过这个

00:11:33.629 --> 00:11:39.959
我想强调一点

00:11:36.319 --> 00:11:41.790
功能必须是纯正的

00:11:39.959 --> 00:11:45.929
意思是纯正的意思是纯正的

00:11:41.790 --> 00:11:48.029
功能没有副作用，所以

00:11:45.929 --> 00:11:50.100
副作用好是什么副作用

00:11:48.029 --> 00:11:52.379
那么在这种情况下，有两个

00:11:50.100 --> 00:11:54.419
我们需要考虑的几点，我会

00:11:52.379 --> 00:11:56.639
认为第一点很容易

00:11:54.419 --> 00:11:59.160
对于我们很多人来说，第二点是

00:11:56.639 --> 00:12:02.279
不是那么直观，第一件事是

00:11:59.160 --> 00:12:04.439
纯函数不会改变任何东西

00:12:02.279 --> 00:12:06.809
所以我们当然可以与之相关

00:12:04.439 --> 00:12:08.999
功能修改得很好

00:12:06.809 --> 00:12:12.629
那不是纯粹的，但是有一个重要的

00:12:08.999 --> 00:12:17.389
规则在这里不依赖任何东西

00:12:12.629 --> 00:12:20.279
也会发生变化，换句话说， 

00:12:17.389 --> 00:12:22.589
纯函数不应该做任何

00:12:20.279 --> 00:12:25.049
变化，但不应该依赖

00:12:22.589 --> 00:12:27.029
任何变化的东西以及

00:12:25.049 --> 00:12:29.309
我认为第一条规则很清楚

00:12:27.029 --> 00:12:31.169
我们大多数人很明显你不

00:12:29.309 --> 00:12:33.749
想要弄乱您不想要的数据

00:12:31.169 --> 00:12:35.309
更改明显的共享数据，但是如果

00:12:33.749 --> 00:12:37.410
我说纯函数不应该

00:12:35.309 --> 00:12:40.139
依靠任何改变我们的东西

00:12:37.410 --> 00:12:41.549
就像为什么原因是其中之一

00:12:40.139 --> 00:12:44.220
功能的关键特征

00:12:41.549 --> 00:12:46.439
编程是功能可以

00:12:44.220 --> 00:12:48.809
懒惰，如果你依赖

00:12:46.439 --> 00:12:50.699
在你之外改变的东西

00:12:48.809 --> 00:12:52.499
功能不能被懒惰地评估

00:12:50.699 --> 00:12:54.720
我们稍后会看到其中的一些

00:12:52.499 --> 00:12:56.879
看一路上的一些例子

00:12:54.720 --> 00:12:58.410
说了这到底是什么

00:12:56.879 --> 00:13:01.079
最大的好处之一

00:12:58.410 --> 00:13:03.299
好处是它变得更容易

00:13:01.079 --> 00:13:05.789
使用代码可以减少意外

00:13:03.299 --> 00:13:07.529
代码的复杂性经常是

00:13:05.789 --> 00:13:08.399
最大的好处之一，但我想要

00:13:07.529 --> 00:13:10.949
区分

00:13:08.399 --> 00:13:12.449
功能风格与纯粹风格

00:13:10.949 --> 00:13:14.759
函数式编程语言

00:13:12.449 --> 00:13:17.699
纯函数式编程语言

00:13:14.759 --> 00:13:21.180
将不允许任何可变期a 

00:13:17.699 --> 00:13:24.210
经常使用功能风格的语言

00:13:21.180 --> 00:13:26.100
适应性可能会导致我们无法

00:13:24.210 --> 00:13:28.830
做正确的事情，所以会加重负担

00:13:26.100 --> 00:13:30.840
在你身上而不是保护你，但是它

00:13:28.830 --> 00:13:32.520
提供高阶功能，因此

00:13:30.840 --> 00:13:34.710
您可以说的其他语言

00:13:32.520 --> 00:13:37.260
提供高阶功能

00:13:34.710 --> 00:13:38.940
语言的功能，如果一种语言

00:13:37.260 --> 00:13:42.180
达到限制的程度

00:13:38.940 --> 00:13:44.070
可变性，除了提供

00:13:42.180 --> 00:13:45.690
功能高阶功能

00:13:44.070 --> 00:13:48.450
然后就变成了纯粹的功能

00:13:45.690 --> 00:13:50.370
语言，例如Java和很多

00:13:48.450 --> 00:13:53.040
其他语言都是功能样式

00:13:50.370 --> 00:13:54.630
例如像Haskell这样的语言

00:13:53.040 --> 00:13:56.850
是一种纯粹的功能性语言，因为

00:13:54.630 --> 00:13:59.070
它们提供高阶功能，但

00:13:56.850 --> 00:14:00.900
他们也不允许变异，但

00:13:59.070 --> 00:14:02.610
有什么真正的好处

00:14:00.900 --> 00:14:04.050
这是我们要看的状态

00:14:02.610 --> 00:14:06.750
转变而不是状态

00:14:04.050 --> 00:14:08.820
变异，所以我们获取他们的数据， 

00:14:06.750 --> 00:14:10.620
通过国家而不是转变

00:14:08.820 --> 00:14:12.780
改变状态，让我们看一下

00:14:10.620 --> 00:14:15.180
在某些情况下这对我们真正意味着什么

00:14:12.780 --> 00:14:18.210
我们先说一下上下文

00:14:15.180 --> 00:14:21.000
进一步讲一下方法

00:14:18.210 --> 00:14:24.020
所以世界上是一种方法

00:14:21.000 --> 00:14:28.140
毕竟这是一个功能

00:14:24.020 --> 00:14:30.570
属于一个类或对象，所以

00:14:28.140 --> 00:14:32.910
这就是我们在Java中称为方法的东西

00:14:30.570 --> 00:14:35.130
方法是一种功能，但那

00:14:32.910 --> 00:14:37.800
函数通常属于一个类

00:14:35.130 --> 00:14:40.620
或它属于一个对象，但在

00:14:37.800 --> 00:14:42.600
另一方面，功能有四件事

00:14:40.620 --> 00:14:44.640
那么功能的四件事是什么

00:14:42.600 --> 00:14:47.130
通常拥有的第一件事是

00:14:44.640 --> 00:14:48.990
函数的名称，所以我们庆祝了

00:14:47.130 --> 00:14:51.150
我们给第二个函数命名

00:14:48.990 --> 00:14:53.190
它经常包含的东西是返回类型

00:14:51.150 --> 00:14:55.110
请问这是什么

00:14:53.190 --> 00:14:57.630
函数返回的第三件事是

00:14:55.110 --> 00:14:59.520
参数列表，当然还有最后一个

00:14:57.630 --> 00:15:01.110
当然是身体的

00:14:59.520 --> 00:15:03.870
功能，这就是功能

00:15:01.110 --> 00:15:05.430
通常包含在我们编写它们时

00:15:03.870 --> 00:15:07.800
让我们来看一个使用

00:15:05.430 --> 00:15:10.650
方法或函数假设我要

00:15:07.800 --> 00:15:12.090
说线程等于新线程，并且

00:15:10.650 --> 00:15:14.460
那我当然要说线程

00:15:12.090 --> 00:15:17.130
飞镖从这里开始，然后我要去

00:15:14.460 --> 00:15:19.320
在这里主要说一下，我们

00:15:17.130 --> 00:15:20.970
可以看到主要弹出

00:15:19.320 --> 00:15:23.400
我当然想在

00:15:20.970 --> 00:15:25.980
另一个线程，所以我们说新的可运行

00:15:23.400 --> 00:15:28.170
在这里，然后一旦我创建了

00:15:25.980 --> 00:15:30.660
我要说的是公共无效

00:15:28.170 --> 00:15:33.420
运行，然后与他们一起运行方法

00:15:30.660 --> 00:15:36.600
我当然要再说一遍

00:15:33.420 --> 00:15:38.880
比方说一个节点或线程

00:15:36.600 --> 00:15:41.250
当然，我们将运行此功能

00:15:38.880 --> 00:15:43.020
我们可以看到主要弹出

00:15:41.250 --> 00:15:45.540
首先，然后线程的结束一次

00:15:43.020 --> 00:15:47.190
踢进去的踢线说

00:15:45.540 --> 00:15:50.280
那将会运行，但是如果你看

00:15:47.190 --> 00:15:52.740
此代码行号16他是一个方法

00:15:50.280 --> 00:15:54.390
这是我们缺少的运行方法

00:15:52.740 --> 00:15:56.910
不可运行的方法，然后我们通过

00:15:54.390 --> 00:15:59.000
它到我们一直在做的线程类

00:15:56.910 --> 00:16:01.890
这当然很长时间了

00:15:59.000 --> 00:16:04.010
想像您正在登机， 

00:16:01.890 --> 00:16:06.810
他们告诉你你只能吃两个

00:16:04.010 --> 00:16:09.210
物品，你不能再拿更多

00:16:06.810 --> 00:16:11.610
比两个项目那两个项目是什么

00:16:09.210 --> 00:16:13.530
您将从这里很好地选择

00:16:11.610 --> 00:16:16.520
你认为最重要的项目吗

00:16:13.530 --> 00:16:19.050
在这里，你不能没有一个

00:16:16.520 --> 00:16:20.550
显然，这将是

00:16:19.050 --> 00:16:22.140
没有主体的功能

00:16:20.550 --> 00:16:24.900
功能是没有意义的

00:16:22.140 --> 00:16:27.000
是的，您选择了一项

00:16:24.900 --> 00:16:29.760
只有一个项目可以选择

00:16:27.000 --> 00:16:31.620
好吧，显然有什么好处

00:16:29.760 --> 00:16:33.900
身体，如果您没有工作数据

00:16:31.620 --> 00:16:36.270
用，所以你必须有参数

00:16:33.900 --> 00:16:37.920
看起来会给你，仅此而已

00:16:36.270 --> 00:16:38.610
您超出限制，只能接受

00:16:37.920 --> 00:16:40.820
两件事情

00:16:38.610 --> 00:16:44.610
那正是lambda罐头所做的

00:16:40.820 --> 00:16:47.250
 Lambda表达式本质上只有

00:16:44.610 --> 00:16:49.530
这两个东西有一个参数

00:16:47.250 --> 00:16:51.360
首先列出一个箭头

00:16:49.530 --> 00:16:53.460
将主体与参数分开

00:16:51.360 --> 00:16:55.800
清单是lambda的结构

00:16:53.460 --> 00:16:58.800
表达式，因此lambda表达式具有

00:16:55.800 --> 00:17:00.750
最小，最小参数

00:16:58.800 --> 00:17:03.150
清单和身体很好

00:17:00.750 --> 00:17:05.340
返回类型推断返回类型

00:17:03.150 --> 00:17:07.260
根据这里的上下文，您没有

00:17:05.340 --> 00:17:09.300
说返回类型怎么样

00:17:07.260 --> 00:17:11.760
谁在乎的方法名称

00:17:09.300 --> 00:17:14.190
工作完成了，所以匿名

00:17:11.760 --> 00:17:16.500
表达式是匿名方法，其

00:17:14.190 --> 00:17:18.510
返回管道被推断出来

00:17:16.500 --> 00:17:20.910
随身携带的是参数清单

00:17:18.510 --> 00:17:22.950
箭头和功能的主体所以

00:17:20.910 --> 00:17:25.710
我要在这里做的就是

00:17:22.950 --> 00:17:27.240
这个例子在这里工作了一分钟

00:17:25.710 --> 00:17:29.880
前，但我要继续

00:17:27.240 --> 00:17:32.130
这次改写这个，但是这次我

00:17:29.880 --> 00:17:35.040
要删除所有的仪式

00:17:32.130 --> 00:17:37.980
它注意到那是我的纯净噪音

00:17:35.040 --> 00:17:39.630
高亮显示，所以我消除了噪音

00:17:37.980 --> 00:17:40.830
那里的小箭头

00:17:39.630 --> 00:17:43.380
然后我要删除

00:17:40.830 --> 00:17:45.720
从这里剩下的噪音，所以我们

00:17:43.380 --> 00:17:48.210
将代码转换为使用Lambda X 

00:17:45.720 --> 00:17:50.280
版本而不是使用匿名

00:17:48.210 --> 00:17:53.039
函数匿名方法匿名

00:17:50.280 --> 00:17:55.530
类，所以在这种情况下，线程是

00:17:53.039 --> 00:17:58.049
实际上是一个构造函数

00:17:55.530 --> 00:18:00.570
线程说的高阶函数

00:17:58.049 --> 00:18:03.299
你不必把东西传给我

00:18:00.570 --> 00:18:05.400
可以运行，如果您通过了

00:18:03.299 --> 00:18:07.230
对我来说没有名字的功能

00:18:05.400 --> 00:18:09.090
该功能当然是lambda 

00:18:07.230 --> 00:18:11.010
我们传递给这个的表达

00:18:09.090 --> 00:18:13.230
功能，在这种情况下，您可以看到

00:18:11.010 --> 00:18:15.090
我们传递了一个不需要

00:18:13.230 --> 00:18:16.710
参数，然后当然是箭头

00:18:15.090 --> 00:18:18.900
和正在打印的主体

00:18:16.710 --> 00:18:20.970
消息，所以我们能够通过

00:18:18.900 --> 00:18:21.330
长期以来第一次的方法

00:18:20.970 --> 00:18:23.760
时间

00:18:21.330 --> 00:18:26.130
我们已经能够将函数视为

00:18:23.760 --> 00:18:28.169
头等公民，这意味着什么

00:18:26.130 --> 00:18:29.700
就像我们一直在创造

00:18:28.169 --> 00:18:31.710
像他们是幼儿园的功能

00:18:29.700 --> 00:18:34.140
功能就这么少

00:18:31.710 --> 00:18:36.510
代码来找你，说我可以去吗

00:18:34.140 --> 00:18:38.549
社区公园，请你说不

00:18:36.510 --> 00:18:40.590
亲爱的你不能独自一人让我发送

00:18:38.549 --> 00:18:43.110
和你一起成人，我们一直

00:18:40.590 --> 00:18:45.240
现在包装它，您可以释放它，并且

00:18:43.110 --> 00:18:46.919
您可以自行发送，所以我已经

00:18:45.240 --> 00:18:49.500
创造一流的功能

00:18:46.919 --> 00:18:51.450
 Java 8中的公民现在向前迈进

00:18:49.500 --> 00:18:55.409
具有编程的功能风格

00:18:51.450 --> 00:18:57.179
所以导致我们去做的是我们可以做的

00:18:55.409 --> 00:18:59.730
一些非常强大的功能

00:18:57.179 --> 00:19:02.250
让我们快速看一下如何

00:18:59.730 --> 00:19:03.780
我们可以从其中获得一些好处，让我们

00:19:02.250 --> 00:19:06.350
去我们一直在做的非常

00:19:03.780 --> 00:19:09.299
很久很传统

00:19:06.350 --> 00:19:11.669
循环播放，所以我得到了1到1的数字列表

00:19:09.299 --> 00:19:13.679
 10就在这里，我想做的是

00:19:11.669 --> 00:19:17.220
通过这些循环，所以我可以为我说

00:19:13.679 --> 00:19:20.070
等于0我小于和数字

00:19:17.220 --> 00:19:21.720
星，然后您通过并询问是

00:19:20.070 --> 00:19:23.669
大小就是长度

00:19:21.720 --> 00:19:26.039
因为显然我们不能

00:19:23.669 --> 00:19:27.990
标准不是它，如果它是一个数组，它是一个

00:19:26.039 --> 00:19:29.039
长度，如果是ArrayList，则为大小

00:19:27.990 --> 00:19:31.919
去搞清楚

00:19:29.039 --> 00:19:33.780
所以我们可以说加号再然后

00:19:31.919 --> 00:19:35.850
我们再次通过，因为问题少了

00:19:33.780 --> 00:19:37.590
小于或小于或等于，因为我们

00:19:35.850 --> 00:19:40.289
永远不确定，然后

00:19:37.590 --> 00:19:42.270
当然要加重对我的伤害

00:19:40.289 --> 00:19:44.610
再说一遍，做得到

00:19:42.270 --> 00:19:47.070
数据很好，这是一个非常

00:19:44.610 --> 00:19:49.409
隆重的仪式，但如果你看着这个

00:19:47.070 --> 00:19:51.600
代码，我要说这是一个非常

00:19:49.409 --> 00:19:53.880
您可能会说复杂的代码，请稍等

00:19:51.600 --> 00:19:56.610
你是说复杂不是那么简单吗

00:19:53.880 --> 00:19:59.140
循环哦，不，这不是简单的

00:19:56.610 --> 00:20:01.060
循环是一个熟悉的for循环

00:19:59.140 --> 00:20:02.980
重要的是不要混淆

00:20:01.060 --> 00:20:04.600
用简单和

00:20:02.980 --> 00:20:07.030
每个人都很熟悉

00:20:04.600 --> 00:20:09.430
其他这不是一个简单的外观

00:20:07.030 --> 00:20:11.590
复杂但熟悉的外观

00:20:09.430 --> 00:20:13.690
熟悉，这是我们拥有的东西

00:20:11.590 --> 00:20:15.370
看了几次我们不

00:20:13.690 --> 00:20:17.530
可能想再看一遍

00:20:15.370 --> 00:20:19.990
我们非常了解的东西

00:20:17.530 --> 00:20:22.060
这是一个非常熟悉的for循环，但是我

00:20:19.990 --> 00:20:23.830
要说这实际上很复杂

00:20:22.060 --> 00:20:25.870
证明它很复杂很容易

00:20:23.830 --> 00:20:28.450
因为已经有一些东西

00:20:25.870 --> 00:20:30.340
很简单，我们可以说int元素在

00:20:28.450 --> 00:20:33.310
数字，然后我们当然可以

00:20:30.340 --> 00:20:35.410
立即输出元素，因此

00:20:33.310 --> 00:20:38.020
您可以看到，两个代码

00:20:35.410 --> 00:20:39.760
产生与此完全相同的结果

00:20:38.020 --> 00:20:42.150
比上一个简单很多

00:20:39.760 --> 00:20:45.580
这两个统称为

00:20:42.150 --> 00:20:48.370
外部迭代器，但我们可以使用

00:20:45.580 --> 00:20:50.680
叫做内部迭代器

00:20:48.370 --> 00:20:53.200
我们可以在这里做的是我们可以做的

00:20:50.680 --> 00:20:56.680
内部迭代器向前发展， 

00:20:53.200 --> 00:20:59.230
这意味着我们可以说

00:20:56.680 --> 00:21:02.140
而不是通过这种方式进行迭代

00:20:59.230 --> 00:21:04.600
可以简单地说井号代表

00:21:02.140 --> 00:21:07.120
每个井，让我们就停在那里

00:21:04.600 --> 00:21:10.240
谈论这个，在第二次通知

00:21:07.120 --> 00:21:12.760
我们通过的较早的示例

00:21:10.240 --> 00:21:14.920
数字太远，我们知道一件事

00:21:12.760 --> 00:21:18.040
关于这样的代码结构

00:21:14.920 --> 00:21:21.160
另一方面，永不多态

00:21:18.040 --> 00:21:23.140
分钟，你说每个数字点

00:21:21.160 --> 00:21:25.240
你知道是多态的，因为

00:21:23.140 --> 00:21:27.790
的实现可以改变

00:21:25.240 --> 00:21:29.740
取决于运行时的实现

00:21:27.790 --> 00:21:31.900
您正在处理的集合中的

00:21:29.740 --> 00:21:34.120
所以你已经是一个好处

00:21:31.900 --> 00:21:37.240
随身携带但我们能做什么

00:21:34.120 --> 00:21:39.910
有了这个，您现在可以针对每个

00:21:37.240 --> 00:21:42.640
然后你可以说新消费者

00:21:39.910 --> 00:21:45.430
整数，然后在这种情况下当然

00:21:42.640 --> 00:21:49.030
我要说的是公共无效

00:21:45.430 --> 00:21:51.370
整数值或元素E，然后我们

00:21:49.030 --> 00:21:53.680
可以在那里输出这个元素

00:21:51.370 --> 00:21:56.740
所以在这种情况下，您可以看到输出

00:21:53.680 --> 00:21:59.110
与我们之前没有的完全一样

00:21:56.740 --> 00:22:01.870
必须使用我们使用的外部迭代器

00:21:59.110 --> 00:22:04.210
内部迭代器的好处是

00:22:01.870 --> 00:22:05.950
这段代码是你在告诉做什么

00:22:04.210 --> 00:22:08.500
而不是专注于

00:22:05.950 --> 00:22:10.900
您要放置的每次迭代该做什么

00:22:08.500 --> 00:22:12.550
自动驾驶仪上的迭代，当然

00:22:10.900 --> 00:22:14.380
你可以享受多态

00:22:12.550 --> 00:22:15.850
所有这些都是好东西

00:22:14.380 --> 00:22:18.850
但是我知道你在想什么

00:22:15.850 --> 00:22:20.740
在想如果真的很不错但是

00:22:18.850 --> 00:22:23.320
如果必须使用，请离开该福利

00:22:20.740 --> 00:22:25.600
另一个匿名内部类

00:22:23.320 --> 00:22:28.090
当然可以，但这就是它的美

00:22:25.600 --> 00:22:30.190
我们没有必要我们可以拿这个

00:22:28.090 --> 00:22:33.400
立即说出好话而不是

00:22:30.190 --> 00:22:36.760
如此努力，我们可以删除所有

00:22:33.400 --> 00:22:39.010
从这里举行的仪式只保留本质

00:22:36.760 --> 00:22:41.050
从这个，然后我们可以删除

00:22:39.010 --> 00:22:43.690
其余部分也可以看到

00:22:41.050 --> 00:22:46.120
该代码仍然在这里工作，所以

00:22:43.690 --> 00:22:48.670
我们可以做的就是摆脱

00:22:46.120 --> 00:22:49.450
在代码中所有这些噪音是

00:22:48.670 --> 00:22:52.270
叫

00:22:49.450 --> 00:22:53.710
我总是笑的功能接口

00:22:52.270 --> 00:22:55.270
我听到功能界面一词

00:22:53.710 --> 00:22:57.070
因为我想知道是否有一些

00:22:55.270 --> 00:22:58.120
具有功能的接口

00:22:57.070 --> 00:23:00.010
关于其他几点

00:22:58.120 --> 00:23:02.230
功能失调，但实质上

00:23:00.010 --> 00:23:04.120
基本上在这种情况下

00:23:02.230 --> 00:23:05.860
单个抽象方法接口是

00:23:04.120 --> 00:23:08.380
期望你可以打电话

00:23:05.860 --> 00:23:10.870
或在这种情况下使消费者受益

00:23:08.380 --> 00:23:13.090
任何地方的文件过滤器都只有一个摘要

00:23:10.870 --> 00:23:16.120
现在可以使用方法界面

00:23:13.090 --> 00:23:18.760
当然可以通过lambda表达

00:23:16.120 --> 00:23:20.530
这就是我们刚刚所做的，但是我们

00:23:18.760 --> 00:23:23.080
可以让我们更进一步并改善

00:23:20.530 --> 00:23:25.420
如果您现在再看一下

00:23:23.080 --> 00:23:28.720
在这段代码中，我们说的是

00:23:25.420 --> 00:23:30.820
这是给定一个整数的lambda 

00:23:28.720 --> 00:23:33.970
继续打印该整数

00:23:30.820 --> 00:23:36.190
但是让我们大胆猜测一下

00:23:33.970 --> 00:23:38.410
迭代一个集合

00:23:36.190 --> 00:23:40.810
您将手放在此整数

00:23:38.410 --> 00:23:43.720
收集并选择您的元素

00:23:40.810 --> 00:23:45.430
最疯狂的想象力你能想象什么

00:23:43.720 --> 00:23:48.520
你会从一个集合中选择

00:23:45.430 --> 00:23:50.770
当然，让狗成为猴子的整数

00:23:48.520 --> 00:23:52.750
这将是一个整数，所以你知道

00:23:50.770 --> 00:23:53.170
语言知道它是一个整数

00:23:52.750 --> 00:23:56.110
整数

00:23:53.170 --> 00:23:57.670
为什么要打扰或打字员

00:23:56.110 --> 00:24:00.940
很久以来的第一次

00:23:57.670 --> 00:24:04.750
 Java终于可以使用了

00:24:00.940 --> 00:24:07.870
使用lambda轻松键入推断

00:24:04.750 --> 00:24:10.570
表达式，这样您就可以省去

00:24:07.870 --> 00:24:12.940
类型，因为类型未添加

00:24:10.570 --> 00:24:15.280
在这种情况下，任何值都是友善的

00:24:12.940 --> 00:24:17.890
现在非常明显，不要误会，这是

00:24:15.280 --> 00:24:20.740
不是动态输入，这实际上是

00:24:17.890 --> 00:24:23.950
推断类型的静态类型

00:24:20.740 --> 00:24:25.799
在编译时只是为了验证我是否

00:24:23.950 --> 00:24:28.279
回到这段代码， 

00:24:25.799 --> 00:24:31.049
如果要调用foo，则在元素II上

00:24:28.279 --> 00:24:34.860
注意我们收到的错误消息

00:24:31.049 --> 00:24:38.100
它说方法foo类型的变量e 

00:24:34.860 --> 00:24:40.559
整数，所以它很清楚地知道

00:24:38.100 --> 00:24:42.600
整数的难易度绝对是

00:24:40.559 --> 00:24:44.309
在这一点上不要混淆，所以我们不要

00:24:42.600 --> 00:24:46.649
必须在此指定类型

00:24:44.309 --> 00:24:49.019
情况，但我们可以再走一步

00:24:46.649 --> 00:24:50.909
在此如果您现在就知道

00:24:49.019 --> 00:24:53.279
这是一个整数，我们不必

00:24:50.909 --> 00:24:55.769
说好类型，我们也可以摆脱

00:24:53.279 --> 00:24:58.739
傻括号，所以如果你只

00:24:55.769 --> 00:25:01.559
正好有一个要素

00:24:58.739 --> 00:25:03.960
你的lambda，你可以摆脱这种类型

00:25:01.559 --> 00:25:06.600
括号也是如此，如果您不

00:25:03.960 --> 00:25:08.100
有任何参数，您必须将

00:25:06.600 --> 00:25:09.989
如果您有两个或多个，请加上括号

00:25:08.100 --> 00:25:11.700
您必须加上括号的参数

00:25:09.989 --> 00:25:15.359
但是如果你只有一个，那就没有

00:25:11.700 --> 00:25:17.549
必须明确指出，但还要

00:25:15.359 --> 00:25:18.809
如果您看这段代码，将会有所改善

00:25:17.549 --> 00:25:21.690
我们手头有

00:25:18.809 --> 00:25:24.659
请注意，在这种情况下，我们收到E 

00:25:21.690 --> 00:25:27.419
然后我们将其打印出来，就可以完成T 

00:25:24.659 --> 00:25:30.749
例如加1，否则我们可以完成

00:25:27.419 --> 00:25:33.720
 e例如2倍，但要点是

00:25:30.749 --> 00:25:36.509
我们没有，我们正在做的是

00:25:33.720 --> 00:25:39.899
接收数据并简单地传递它

00:25:36.509 --> 00:25:42.960
这种lambda非常

00:25:39.899 --> 00:25:45.779
琐碎的是它收到一个参数

00:25:42.960 --> 00:25:47.909
参数，然后将其传递给

00:25:45.779 --> 00:25:50.309
另一个函数或调用我们的方法

00:25:47.909 --> 00:25:52.289
在上面我有个特别的名字

00:25:50.309 --> 00:25:54.929
我称为这些的lambda 

00:25:52.289 --> 00:25:56.549
 lambdas是作为办公空间模式

00:25:54.929 --> 00:25:58.649
如果你记得看办公室

00:25:56.549 --> 00:26:00.869
太空电影，嘿，汤姆，你在做什么

00:25:58.649 --> 00:26:02.970
我接受这家公司的要求

00:26:00.869 --> 00:26:04.769
程序程序员并将其交给

00:26:02.970 --> 00:26:06.749
来自业务经理

00:26:04.769 --> 00:26:09.119
人，我把它交给程序员

00:26:06.749 --> 00:26:11.070
所以汤姆在这家公司所做的一切

00:26:09.119 --> 00:26:12.299
他是从

00:26:11.070 --> 00:26:14.429
商人和给予

00:26:12.299 --> 00:26:16.889
程序员实际上真的没有

00:26:14.429 --> 00:26:19.080
当你有lambda的时候很好地使用

00:26:16.889 --> 00:26:22.320
这实际上并没有做很多其他事情

00:26:19.080 --> 00:26:24.450
不仅仅是转换您的数据

00:26:22.320 --> 00:26:26.789
写这个会很累

00:26:24.450 --> 00:26:29.460
你会说这段代码很愚蠢

00:26:26.789 --> 00:26:31.919
但是历史我向我们展示了一件事Java 

00:26:29.460 --> 00:26:34.440
程序员永远不会编写愚蠢的代码

00:26:31.919 --> 00:26:36.210
相反，开发IDE是要呕吐愚蠢

00:26:34.440 --> 00:26:38.630
代码，每个人都会问

00:26:36.210 --> 00:26:40.340
其他我该怎么办

00:26:38.630 --> 00:26:42.200
为了做到这一点，他们知道这是

00:26:40.340 --> 00:26:44.990
来，所以他们删除了这个重复

00:26:42.200 --> 00:26:47.810
所以如果你注意到我们在这边

00:26:44.990 --> 00:26:50.180
所以这把滑雪板很普通，所以我们将其删除

00:26:47.810 --> 00:26:52.730
有了这个e在这里，然后我们将

00:26:50.180 --> 00:26:55.280
也要删除此箭头，我们只需

00:26:52.730 --> 00:26:56.060
将这个基座更改为double： 

00:26:55.280 --> 00:26:58.700
叫做

00:26:56.060 --> 00:27:00.500
方法参考方法参考

00:26:58.700 --> 00:27:02.180
代码锁更容易理解和

00:27:00.500 --> 00:27:03.830
我要说的方法

00:27:02.180 --> 00:27:05.720
参考需要更多的努力

00:27:03.830 --> 00:27:07.610
在你来之前写它们

00:27:05.720 --> 00:27:10.400
习惯了，但是方法参考

00:27:07.610 --> 00:27:12.140
通常更容易阅读，所以它们

00:27:10.400 --> 00:27:13.970
更容易阅读，然后在

00:27:12.140 --> 00:27:16.520
开始，但随着时间的流逝，我们真的

00:27:13.970 --> 00:27:18.830
我们在使用它时会更好，所以我们做了

00:27:16.520 --> 00:27:21.380
在这个例子中，我们采取了外部

00:27:18.830 --> 00:27:24.380
迭代器，我们以前有一个

00:27:21.380 --> 00:27:26.360
我们重构了几次，这是

00:27:24.380 --> 00:27:28.670
我们传统的外部迭代器

00:27:26.360 --> 00:27:31.280
首先我们得到了一些简单的东西

00:27:28.670 --> 00:27:33.200
这也是一个外部迭代器

00:27:31.280 --> 00:27:35.690
当然我们采用了内部迭代器

00:27:33.200 --> 00:27:37.940
这很冗长，但向我们展示了我们如何

00:27:35.690 --> 00:27:40.490
可以进行循环并打印内容

00:27:37.940 --> 00:27:42.590
在这个循环中，最后

00:27:40.490 --> 00:27:44.990
当然我们用lambda进行交易

00:27:42.590 --> 00:27:47.930
表达式，我们摆脱了类型和

00:27:44.990 --> 00:27:49.760
使用我们摆脱的类型推断

00:27:47.930 --> 00:27:51.440
之后的括号，然后是

00:27:49.760 --> 00:27:53.000
当然最终我们使用该方法

00:27:51.440 --> 00:27:54.980
参考，因为这个特定的lambda 

00:27:53.000 --> 00:27:57.830
就是这么简单，所以这给你一个

00:27:54.980 --> 00:28:00.110
关于如何使用的想法

00:27:57.830 --> 00:28:02.480
 Lambda表达式开始写作

00:28:00.110 --> 00:28:04.460
这些代码向前发展

00:28:02.480 --> 00:28:06.800
这成为一个非常根本的转变

00:28:04.460 --> 00:28:09.860
我们如何做到这一点，但要做的事情之一

00:28:06.800 --> 00:28:13.190
请记住，这本质上是

00:28:09.860 --> 00:28:16.670
我们更喜欢的编程方式

00:28:13.190 --> 00:28:18.800
的装饰风格比第一

00:28:16.670 --> 00:28:21.500
然后是一种实用的方法

00:28:18.800 --> 00:28:24.230
什么是装饰风格

00:28:21.500 --> 00:28:26.420
编码风格可以告诉您什么

00:28:24.230 --> 00:28:29.510
去做，你让底层

00:28:26.420 --> 00:28:32.120
函数找出如何做到这一点

00:28:29.510 --> 00:28:34.400
命令式的代码风格

00:28:32.120 --> 00:28:36.650
时间，如果我们告诉该怎么做， 

00:28:34.400 --> 00:28:38.690
还有怎么做让我们来看一个

00:28:36.650 --> 00:28:41.360
这个例子可以更好地理解

00:28:38.690 --> 00:28:43.700
真正的意思是，所以这里有一个清单

00:28:41.360 --> 00:28:47.680
 1到10的数字，但假设

00:28:43.700 --> 00:28:51.320
给定的问题是找到总数

00:28:47.680 --> 00:28:52.520
偶数的两倍，所以我们被问到

00:28:51.320 --> 00:28:55.130
找出总数

00:28:52.520 --> 00:28:57.740
通常创建的偶数

00:28:55.130 --> 00:29:00.410
这首先是命令式的

00:28:57.740 --> 00:29:02.420
您会说结果等于

00:29:00.410 --> 00:29:04.520
零，当您完成后，您想

00:29:02.420 --> 00:29:07.460
打印结果，然后您说

00:29:04.520 --> 00:29:10.970
这里的int元素来自

00:29:07.460 --> 00:29:14.360
数字，然后你说如果元素在这里

00:29:10.970 --> 00:29:16.309
标记2等于0那么

00:29:14.360 --> 00:29:19.220
你会说结果相等

00:29:16.309 --> 00:29:21.050
到e乘以2，但随后您必须放一个

00:29:19.220 --> 00:29:24.260
打破它打破这一点

00:29:21.050 --> 00:29:25.820
在这种情况下当然循环良好

00:29:24.260 --> 00:29:27.559
实际上在这种情况下，我们想找到

00:29:25.820 --> 00:29:29.090
所有数字的总和，所以不间断

00:29:27.559 --> 00:29:31.010
在这里，我们必须做所有这些

00:29:29.090 --> 00:29:33.590
决定，然后我们不得不说加

00:29:31.010 --> 00:29:35.630
等于所以您可以顺利通过

00:29:33.590 --> 00:29:38.120
在这种情况下，总计为总数的两倍

00:29:35.630 --> 00:29:39.950
集合中的偶数，但

00:29:38.120 --> 00:29:42.410
我们永远都这样写过代码

00:29:39.950 --> 00:29:44.000
但是如果你看这段代码的话

00:29:42.410 --> 00:29:46.429
像以前这样打印代码的英雄

00:29:44.000 --> 00:29:49.309
当然，我们每个人，但

00:29:46.429 --> 00:29:52.400
问题是当你感觉如何

00:29:49.309 --> 00:29:55.250
像这样写代码真的很脏

00:29:52.400 --> 00:29:57.200
脏了实际上是经过一天的漫长工作之后

00:29:55.250 --> 00:29:58.940
编写此代码，您就可以回家了

00:29:57.200 --> 00:30:00.140
孩子们跑来跑向你

00:29:58.940 --> 00:30:02.179
你说不要碰我

00:30:00.140 --> 00:30:03.920
我得先推她，因为

00:30:02.179 --> 00:30:06.860
是非常低级的编码，我们必须

00:30:03.920 --> 00:30:08.990
做完了，我们可以再做一次，但是

00:30:06.860 --> 00:30:11.059
在我们这样做之前，让我们先讨论两个

00:30:08.990 --> 00:30:13.760
不同的东西两种不同的气味

00:30:11.059 --> 00:30:16.520
命令性代码的第一个气味是我们

00:30:13.760 --> 00:30:18.650
有一个我们在这里定义的变量，但是

00:30:16.520 --> 00:30:21.110
我们可以改变那个变量

00:30:18.650 --> 00:30:23.660
一遍又一遍，这是其中之一

00:30:21.110 --> 00:30:26.420
命令式风格的气味是

00:30:23.660 --> 00:30:27.800
我们经常做可变性

00:30:26.420 --> 00:30:30.200
事情是你必须花力气

00:30:27.800 --> 00:30:33.110
不仅告诉做什么，而且告诉

00:30:30.200 --> 00:30:35.059
说如何实际做到这一点

00:30:33.110 --> 00:30:37.670
另一方面，我们可以重写这段代码

00:30:35.059 --> 00:30:41.090
这次，但我要说的是输出

00:30:37.670 --> 00:30:43.460
从这里的数字开始

00:30:41.090 --> 00:30:46.880
流认为流是内部的

00:30:43.460 --> 00:30:48.710
迭代器，然后我们可以说过滤器和

00:30:46.880 --> 00:30:52.580
我要说的是给定元素e 

00:30:48.710 --> 00:30:55.070
返回仅偶数的元素

00:30:52.580 --> 00:30:56.809
而不是其他任何元素

00:30:55.070 --> 00:30:59.600
在这种情况下，我们应用了过滤器

00:30:56.809 --> 00:31:02.059
给定一个元素的地图乘以两倍

00:30:59.600 --> 00:31:04.970
最后我当然要说

00:31:02.059 --> 00:31:05.600
继续给我一笔总和运算

00:31:04.970 --> 00:31:08.210
 L 

00:31:05.600 --> 00:31:10.250
结果并将结果很好地归还给我

00:31:08.210 --> 00:31:12.770
如果你看这两个代码

00:31:10.250 --> 00:31:14.270
代码产生完全相同的结果，但是

00:31:12.770 --> 00:31:16.370
确实有一些关键的区别

00:31:14.270 --> 00:31:18.799
这两种代码之间的顶部

00:31:16.370 --> 00:31:20.990
代码本质上当然是必不可少的

00:31:18.799 --> 00:31:23.330
我们告诉做什么和怎么做，我们

00:31:20.990 --> 00:31:25.010
如果您在代码中也有可变性

00:31:23.330 --> 00:31:26.270
看看我要在底部的代码

00:31:25.010 --> 00:31:29.179
说底部的代码非常

00:31:26.270 --> 00:31:30.740
人道的，在

00:31:29.179 --> 00:31:33.289
结果，所以我们不是

00:31:30.740 --> 00:31:34.730
反复变异任何变量

00:31:33.289 --> 00:31:37.789
第二件事是，如果您看一下代码

00:31:34.730 --> 00:31:40.039
在最上面，你必须说每一个

00:31:37.789 --> 00:31:41.630
你不得不说的细节

00:31:40.039 --> 00:31:43.820
一段时间请检查是那个元素

00:31:41.630 --> 00:31:45.650
甚至可以继续加倍

00:31:43.820 --> 00:31:47.630
元素就在这里，然后获取

00:31:45.650 --> 00:31:49.520
结果的当前值，然后添加到

00:31:47.630 --> 00:31:51.919
结果的值，然后将其存储到

00:31:49.520 --> 00:31:54.230
结果你必须说每一个

00:31:51.919 --> 00:31:56.390
这段代码就像和

00:31:54.230 --> 00:31:58.669
第一次和孩子聊天

00:31:56.390 --> 00:32:00.260
小孩会让你兴奋

00:31:58.669 --> 00:32:01.760
说哇，这真棒

00:32:00.260 --> 00:32:03.679
小孩好，接下来你

00:32:01.760 --> 00:32:05.840
意识到你必须说同样的话

00:32:03.679 --> 00:32:08.179
一遍又一遍你会说的很好

00:32:05.840 --> 00:32:10.190
双手慢慢抬起

00:32:08.179 --> 00:32:12.080
你要去的地方不要踩猫

00:32:10.190 --> 00:32:14.390
在您将不得不

00:32:12.080 --> 00:32:17.450
说这个然后你意识到这是

00:32:14.390 --> 00:32:19.640
接下来的18年

00:32:17.450 --> 00:32:21.169
那叫做育儿不好吗

00:32:19.640 --> 00:32:23.419
当您开始时就是这样

00:32:21.169 --> 00:32:25.730
用命令式风格编写代码

00:32:23.419 --> 00:32:27.740
另一方面功能风格

00:32:25.730 --> 00:32:29.840
感觉就像你在和

00:32:27.740 --> 00:32:31.730
负责任的成年人是

00:32:29.840 --> 00:32:34.610
您从中获得的最大好处是

00:32:31.730 --> 00:32:36.530
一种非常好的转换方式，因此

00:32:34.610 --> 00:32:38.419
数字集合让我

00:32:36.530 --> 00:32:42.080
只有偶数的集合

00:32:38.419 --> 00:32:43.970
将值和总数加倍，因此代码

00:32:42.080 --> 00:32:46.909
开始读起来像问题陈述

00:32:43.970 --> 00:32:49.700
它消除了意外的复杂性

00:32:46.909 --> 00:32:51.530
通常是代码固有的

00:32:49.700 --> 00:32:53.179
您获得的最大好处之一

00:32:51.530 --> 00:32:56.090
有哪些区别

00:32:53.179 --> 00:32:58.070
势在必行的风格

00:32:56.090 --> 00:33:00.530
东西，而在装饰和

00:32:58.070 --> 00:33:03.110
您专注于功能样式的事情

00:33:00.530 --> 00:33:05.840
大多数情况下，您鼓励

00:33:03.110 --> 00:33:08.210
命令式风格，您可以在其中转换数据

00:33:05.840 --> 00:33:09.919
您经常处理的功能性和装饰性

00:33:08.210 --> 00:33:12.049
带有副作用

00:33:09.919 --> 00:33:14.780
你写的命令式纯

00:33:12.049 --> 00:33:16.700
装饰功能

00:33:14.780 --> 00:33:18.980
和功能注意这些

00:33:16.700 --> 00:33:19.340
函数是纯函数，它们不会改变

00:33:18.980 --> 00:33:21.200
字

00:33:19.340 --> 00:33:22.910
在他们周围，他们不依赖

00:33:21.200 --> 00:33:26.060
任何易变的东西

00:33:22.910 --> 00:33:27.830
这些一路走来，当然你

00:33:26.060 --> 00:33:30.170
在这种情况下可以传递对象

00:33:27.830 --> 00:33:31.670
以及功能，最后

00:33:30.170 --> 00:33:33.680
代码很难组成一个

00:33:31.670 --> 00:33:35.870
命令式风格，因为陈述

00:33:33.680 --> 00:33:38.390
通常会花费可变性，因此您必须离开

00:33:35.870 --> 00:33:40.340
返回并获取数据，而函数

00:33:38.390 --> 00:33:42.410
很好地组合，您可以进行变换

00:33:40.340 --> 00:33:44.060
数据从一个到另一个到另一个

00:33:42.410 --> 00:33:46.130
下一个，但我想偏离一点

00:33:44.060 --> 00:33:48.680
一点点回头再说

00:33:46.130 --> 00:33:51.140
关于lambda和

00:33:48.680 --> 00:33:54.590
关闭一分钟，所以回去

00:33:51.140 --> 00:33:57.020
在本例中，我们取值1 2 3 

00:33:54.590 --> 00:33:59.990
一分钟，在这种情况下，我是

00:33:57.020 --> 00:34:02.000
我要做的是要

00:33:59.990 --> 00:34:04.040
值首先要加倍

00:34:02.000 --> 00:34:06.650
打印它，在这种情况下，我要

00:34:04.040 --> 00:34:09.320
说数字飞镖流，然后我会

00:34:06.650 --> 00:34:11.510
说给定一个元素的地图乘以2 

00:34:09.320 --> 00:34:14.210
然后我要说的每个

00:34:11.510 --> 00:34:16.700
系统点出并打印错误

00:34:14.210 --> 00:34:19.460
再看一下这段代码

00:34:16.700 --> 00:34:22.700
仅此一行，如果您要在这里

00:34:19.460 --> 00:34:24.770
 lambda如果我问你2是2是

00:34:22.700 --> 00:34:28.130
当然，字面意思是e 

00:34:24.770 --> 00:34:30.770
 e是lambda的参数，很像

00:34:28.130 --> 00:34:32.630
 args是main e的参数

00:34:30.770 --> 00:34:34.640
此lambda表达式的参数

00:34:32.630 --> 00:34:36.650
那么这个lambda是非常独立的

00:34:34.640 --> 00:34:40.130
很高兴它抓住了所有需要的东西

00:34:36.650 --> 00:34:43.340
另一方面，如果我没有问题

00:34:40.130 --> 00:34:45.740
要说的是这里的因素，如果你

00:34:43.340 --> 00:34:48.710
看这个代码，如果我问你什么是电子

00:34:45.740 --> 00:34:50.630
很清楚e是什么东西

00:34:48.710 --> 00:34:52.910
这个lambda的参数在

00:34:50.630 --> 00:34:55.010
世界就是这个因素，事实是

00:34:52.910 --> 00:34:57.680
当然没有在此定义

00:34:55.010 --> 00:35:00.950
 lambda，所以这个lambda必须寻找

00:34:57.680 --> 00:35:03.020
这个因素，所以我很好

00:35:00.950 --> 00:35:08.390
要把这个放到这里

00:35:03.020 --> 00:35:13.730
 lambda必须结束其定义

00:35:08.390 --> 00:35:17.540
范围，因此定义范围寻找

00:35:13.730 --> 00:35:21.350
绑定到其他变量中

00:35:17.540 --> 00:35:22.970
这个lambda必须关闭的单词尝试

00:35:21.350 --> 00:35:24.920
说这个词真的很快结束了

00:35:22.970 --> 00:35:28.340
好几次，你知道

00:35:24.920 --> 00:35:31.070
闭包是这样的lambda没有

00:35:28.340 --> 00:35:32.750
状态，所以我要说的是lambda 

00:35:31.070 --> 00:35:35.090
无状态的

00:35:32.750 --> 00:35:40.010
另一方面，关闭

00:35:35.090 --> 00:35:42.260
闭包具有不变的状态，因此

00:35:40.010 --> 00:35:45.080
您想确保它实际上是

00:35:42.260 --> 00:35:48.010
一成不变的，所以非常关键

00:35:45.080 --> 00:35:51.140
带有状态的关闭

00:35:48.010 --> 00:35:53.510
 Lambda非常无状态，那又如何

00:35:51.140 --> 00:35:55.670
封闭可以做的是封闭

00:35:53.510 --> 00:35:58.130
捕获您正在定义的状态

00:35:55.670 --> 00:36:01.880
它并延续到

00:35:58.130 --> 00:36:03.170
执行等待这段代码，但让我们

00:36:01.880 --> 00:36:06.500
快速在这里看看

00:36:03.170 --> 00:36:10.190
这个lambda是在这里定义的

00:36:06.500 --> 00:36:12.680
 main，然后在其中调用map方法

00:36:10.190 --> 00:36:15.320
您可以调用map方法

00:36:12.680 --> 00:36:17.870
 lambda或您可以将lambda传递给

00:36:15.320 --> 00:36:20.420
还有几个级别，您可以致电

00:36:17.870 --> 00:36:23.120
 lambda之后，换句话说， 

00:36:20.420 --> 00:36:25.910
在主要的may中定义的lambda 

00:36:23.120 --> 00:36:28.280
实际上在一两个或两个执行

00:36:25.910 --> 00:36:30.380
从堆栈下面的三个级别，但是

00:36:28.280 --> 00:36:33.260
在该堆栈级别执行时

00:36:30.380 --> 00:36:35.600
下面需要定义一个变量

00:36:33.260 --> 00:36:38.870
在这里，这就是它捕获

00:36:35.600 --> 00:36:41.660
从这里开始的背景，并把它带下来

00:36:38.870 --> 00:36:43.790
那里有空房，所以

00:36:41.660 --> 00:36:45.260
基本上是封闭的，所以其中之一

00:36:43.790 --> 00:36:48.620
我们应该记住的事情是

00:36:45.260 --> 00:36:50.930
闭包带有状态，但是很重要

00:36:48.620 --> 00:36:52.970
让我们确保状态

00:36:50.930 --> 00:36:56.060
由封闭带是不可变的

00:36:52.970 --> 00:36:58.550
现在为什么如此重要

00:36:56.060 --> 00:37:01.250
闭包状态对于

00:36:58.550 --> 00:37:02.480
了解我们继续前进

00:37:01.250 --> 00:37:04.940
这有点不同

00:37:02.480 --> 00:37:06.770
我将继续进行

00:37:04.940 --> 00:37:08.840
流过这里，我要说

00:37:06.770 --> 00:37:12.380
尖叫，飞镖尖叫，我要说

00:37:08.840 --> 00:37:15.170
从这里的整数流掉

00:37:12.380 --> 00:37:17.630
然后等于数字点尖叫

00:37:15.170 --> 00:37:21.290
但我要说的是点图

00:37:17.630 --> 00:37:23.570
我要说的元素x因子

00:37:21.290 --> 00:37:26.420
然后当然在这种情况下

00:37:23.570 --> 00:37:27.110
会说给定流点

00:37:26.420 --> 00:37:28.970
每个

00:37:27.110 --> 00:37:31.970
我要继续说系统点

00:37:28.970 --> 00:37:33.890
列印Len，我要走了

00:37:31.970 --> 00:37:36.020
前面并正确打印字符串

00:37:33.890 --> 00:37:38.270
到目前为止还不错，但是我在哪里

00:37:36.020 --> 00:37:41.750
在这种情况下，要说的是

00:37:38.270 --> 00:37:44.420
整数因子等于2，所以代码

00:37:41.750 --> 00:37:45.800
实际上在这种情况下

00:37:44.420 --> 00:37:47.750
 n和

00:37:45.800 --> 00:37:50.840
用它来制造产品

00:37:47.750 --> 00:37:54.290
显然有效，但要保留一件事

00:37:50.840 --> 00:37:56.990
想到的是看一下这种关闭

00:37:54.290 --> 00:38:01.100
分钟好，这个关闭肯定是

00:37:56.990 --> 00:38:03.320
不修改任何特定变量

00:38:01.100 --> 00:38:05.650
很好，它满足了第一条规则

00:38:03.320 --> 00:38:08.030
纯粹不会改变任何东西

00:38:05.650 --> 00:38:10.250
那第二条纯净规则怎么办

00:38:08.030 --> 00:38:12.530
还记得纯洁的第二条法则吗

00:38:10.250 --> 00:38:15.140
不依赖于任何变化

00:38:12.530 --> 00:38:17.930
哦，等等，这取决于

00:38:15.140 --> 00:38:20.930
因素，但美丽的事物之一

00:38:17.930 --> 00:38:23.480
关于Java的是，将它们视为

00:38:20.930 --> 00:38:25.250
所谓的有效最终

00:38:23.480 --> 00:38:28.100
换句话说，你可以把单词final 

00:38:25.250 --> 00:38:30.890
在这种情况下，如果我说因素

00:38:28.100 --> 00:38:34.040
等于四个注意，您会得到一个错误

00:38:30.890 --> 00:38:36.530
就在第15行，它说你

00:38:34.040 --> 00:38:39.470
无法更改因子，因为其最终

00:38:36.530 --> 00:38:42.680
但是，如果我从中删除此决赛

00:38:39.470 --> 00:38:46.670
在Java的旧版本中都很好，直到

00:38:42.680 --> 00:38:49.520
 Java 7您必须将最终的

00:38:46.670 --> 00:38:53.060
从以下位置访问的局部变量

00:38:49.520 --> 00:38:56.060
内部类Java 8中的更改

00:38:53.060 --> 00:38:58.760
在Java 8中只是一点点规则

00:38:56.060 --> 00:38:59.420
您不必说现在就进入决赛

00:38:58.760 --> 00:39:02.450
等一下

00:38:59.420 --> 00:39:05.180
为什么没有我必须把最后的好

00:39:02.450 --> 00:39:07.730
 Java 8说你和我一直在

00:39:05.180 --> 00:39:10.100
长期以来我们可以信任每个人

00:39:07.730 --> 00:39:12.440
其他只要一点点

00:39:10.100 --> 00:39:14.450
你知道怎么做，你不必

00:39:12.440 --> 00:39:17.690
进行决赛的仪式

00:39:14.450 --> 00:39:20.860
因此当我编写这段代码时

00:39:17.690 --> 00:39:26.590
这实际上称为最终

00:39:20.860 --> 00:39:29.840
如果你来这里说因子等于4 

00:39:26.590 --> 00:39:32.120
 Java立刻大喊，说我

00:39:29.840 --> 00:39:34.340
以为我们之间有一个了解

00:39:32.120 --> 00:39:36.140
我们和你现在违反了

00:39:34.340 --> 00:39:38.600
合同，这就是为什么它被称为

00:39:36.140 --> 00:39:41.630
换句话说，有效地最终

00:39:38.600 --> 00:39:44.600
无法访问本地变量

00:39:41.630 --> 00:39:46.940
如果您很好地变异它

00:39:44.600 --> 00:39:48.640
这是一个好消息，这是Java 

00:39:46.940 --> 00:39:51.650
在这种情况下试图保护您

00:39:48.640 --> 00:39:53.480
像Haskell这样的语言纯粹是

00:39:51.650 --> 00:39:55.730
功能语言没有

00:39:53.480 --> 00:39:58.150
如果你尝试了一些非常的事情

00:39:55.730 --> 00:40:01.210
与此类似，在c-sharp中

00:39:58.150 --> 00:40:04.510
 javascript是其他几种语言

00:40:01.210 --> 00:40:06.520
这些语言不会阻止您使用Java 

00:40:04.510 --> 00:40:08.770
在这里试图保护自己并说

00:40:06.520 --> 00:40:11.230
不，不，不，那不是一个好习惯

00:40:08.770 --> 00:40:13.450
编程实践做得不好

00:40:11.230 --> 00:40:15.760
到目前为止，这是个好主意，但您知道

00:40:13.450 --> 00:40:17.770
他们将如何发展一些程序员

00:40:15.760 --> 00:40:20.319
袖手旁观，说让我告诉你

00:40:17.770 --> 00:40:22.660
如何真正欺骗Java这些非常

00:40:20.319 --> 00:40:24.549
危险的人通常，但是你

00:40:22.660 --> 00:40:26.500
在这种情况下可以做的是

00:40:24.549 --> 00:40:29.289
因为Java并不全都

00:40:26.500 --> 00:40:33.970
您可能会想说的改变因素

00:40:29.289 --> 00:40:36.339
方括号中的因子等于new int 

00:40:33.970 --> 00:40:39.430
然后你可以在这里放两个

00:40:36.339 --> 00:40:41.920
在这一点上，工作要说好运

00:40:39.430 --> 00:40:44.619
保持安静，所以当您运行此代码时

00:40:41.920 --> 00:40:48.190
当然你有零因子，但是如果我

00:40:44.619 --> 00:40:52.089
回到这里说零因子是

00:40:48.190 --> 00:40:54.760
在这种情况下等于零通知Java 

00:40:52.089 --> 00:40:56.529
将不再抱怨Java 

00:40:54.760 --> 00:40:57.910
可能坐在那里继续笑， 

00:40:56.529 --> 00:41:00.190
特卖会很有趣

00:40:57.910 --> 00:41:02.079
这些代码，但在这种情况下

00:41:00.190 --> 00:41:04.869
不再保护您，这也是

00:41:02.079 --> 00:41:07.809
如果这是一个成员变量，则为true 

00:41:04.869 --> 00:41:09.789
 Java中的字段不再

00:41:07.809 --> 00:41:14.440
要保护，但要牢记

00:41:09.789 --> 00:41:17.680
此lambda披露是错误的结局

00:41:14.440 --> 00:41:19.720
因为它不再是纯净的，为什么不

00:41:17.680 --> 00:41:22.059
不再纯净，因为记住这两个

00:41:19.720 --> 00:41:25.180
纯函数的纯净规则

00:41:22.059 --> 00:41:27.160
不会改变任何好的东西，但是

00:41:25.180 --> 00:41:30.010
纯功能也不应依赖

00:41:27.160 --> 00:41:31.930
任何明显改变的东西

00:41:30.010 --> 00:41:33.490
取决于变化的东西

00:41:31.930 --> 00:41:36.039
其实这真的是一个原因

00:41:33.490 --> 00:41:39.190
糟糕的代码是您可以接受此代码

00:41:36.039 --> 00:41:41.140
为此制作一个封面照片并显示

00:41:39.190 --> 00:41:44.770
给不同的人问

00:41:41.140 --> 00:41:46.569
我的输出将是什么-你是

00:41:44.770 --> 00:41:48.309
从中得到不同的答案

00:41:46.569 --> 00:41:52.329
人，其中一些人会告诉你

00:41:48.309 --> 00:41:53.980
很好，因为二因子0是-这是

00:41:52.329 --> 00:41:57.190
将是价值的两倍

00:41:53.980 --> 00:42:00.430
其他人可能会说因为因子为0 

00:41:57.190 --> 00:42:03.099
现在它将是0，但是哪个是

00:42:00.430 --> 00:42:05.829
正确的答案是我们真的应该

00:42:03.099 --> 00:42:07.990
做这样的编程，因为如果你

00:42:05.829 --> 00:42:11.079
试图写这样的代码

00:42:07.990 --> 00:42:12.110
很难推理容易出错

00:42:11.079 --> 00:42:15.530
很难工作

00:42:12.110 --> 00:42:18.560
这也被称为坏主意，所以不要

00:42:15.530 --> 00:42:21.110
这样做是因为这就是为什么

00:42:18.560 --> 00:42:22.670
功能的纯度是如此重要，我们

00:42:21.110 --> 00:42:24.800
不想惹事

00:42:22.670 --> 00:42:26.810
这样我们要保持纯度

00:42:24.800 --> 00:42:29.240
的封闭变得非常极端

00:42:26.810 --> 00:42:31.640
重要的，所以我们不应该混用

00:42:29.240 --> 00:42:33.920
与这些杂质，但这也

00:42:31.640 --> 00:42:36.380
说明了懒惰的要点

00:42:33.920 --> 00:42:38.600
评价，所以让我们谈谈懒惰

00:42:36.380 --> 00:42:40.730
评价引起了关于懒惰的整个话题

00:42:38.600 --> 00:42:42.280
明天评估，但我会简单地

00:42:40.730 --> 00:42:45.950
现在只是刮擦表面

00:42:42.280 --> 00:42:48.620
请注意，在第13行，我们有一个lambda 

00:42:45.950 --> 00:42:51.980
坐在第13行的那个表情

00:42:48.620 --> 00:42:55.850
第13行上的lambda表达式没有

00:42:51.980 --> 00:42:59.360
当您越过线路时立即执行

00:42:55.850 --> 00:43:02.720
 13执行期间改为等待

00:42:59.360 --> 00:43:05.480
直到您到达第17行， 

00:43:02.720 --> 00:43:08.390
当第13行执行时

00:43:05.480 --> 00:43:10.640
延迟评估或延迟执行

00:43:08.390 --> 00:43:14.150
说我现在不需要这样做

00:43:10.640 --> 00:43:16.100
函数式编程非常重要

00:43:14.150 --> 00:43:18.200
关于这个，所以我要继续

00:43:16.100 --> 00:43:20.810
在这里说如果有人来找你， 

00:43:18.200 --> 00:43:23.270
说你是面向对象的粉丝吗

00:43:20.810 --> 00:43:25.850
编程你说哦我爱的对象

00:43:23.270 --> 00:43:27.590
编程很好你为什么这么在乎

00:43:25.850 --> 00:43:28.610
很多对象都很好地编程

00:43:27.590 --> 00:43:29.990
不要误会我的意思

00:43:28.610 --> 00:43:33.050
像抽象和

00:43:29.990 --> 00:43:34.760
封装非常重要

00:43:33.050 --> 00:43:37.310
但是你不是在编程

00:43:34.760 --> 00:43:40.040
仅用于提取的面向对象系统

00:43:37.310 --> 00:43:43.430
或封装了

00:43:40.040 --> 00:43:46.690
对象编程是多态之后

00:43:43.430 --> 00:43:50.540
都是吗，所以多态是- 

00:43:46.690 --> 00:43:52.700
面向对象的程序设计

00:43:50.540 --> 00:43:56.440
话说这就是我们真正追求的

00:43:52.700 --> 00:43:59.450
现在我们都可以同意你不能享受

00:43:56.440 --> 00:44:02.000
没有抽象的多态你

00:43:59.450 --> 00:44:05.450
没有它就无法享受多态

00:44:02.000 --> 00:44:08.060
封装但多态性是什么

00:44:05.450 --> 00:44:10.310
我们真的是在抽象之后

00:44:08.060 --> 00:44:12.470
封装确实使它成为可能

00:44:10.310 --> 00:44:15.620
所以多态性是光学的

00:44:12.470 --> 00:44:20.190
像这样的编程，我要说的是

00:44:15.620 --> 00:44:21.310
懒惰评估评估是为了

00:44:20.190 --> 00:44:25.410
 [音乐] 

00:44:21.310 --> 00:44:27.720
评估是对函数式编程

00:44:25.410 --> 00:44:30.510
当然如果你要偷懒

00:44:27.720 --> 00:44:34.020
估值你不能偷懒

00:44:30.510 --> 00:44:35.850
没有不变性的评估

00:44:34.020 --> 00:44:38.340
正是我们在本例中看到的

00:44:35.850 --> 00:44:41.550
因为什么是不变性

00:44:38.340 --> 00:44:44.400
和可亲的，说这个功能不会

00:44:41.550 --> 00:44:46.620
修改任何东西，这并不取决于

00:44:44.400 --> 00:44:49.860
在任何会改变的东西上

00:44:46.620 --> 00:44:52.410
现在运行它，您可以稍后找到它或运行

00:44:49.860 --> 00:44:56.010
如果它是

00:44:52.410 --> 00:44:57.660
功能不完善，您迫切需要运行它

00:44:56.010 --> 00:45:00.450
你会说运行它快运行它

00:44:57.660 --> 00:45:02.220
在世界改变之前，你

00:45:00.450 --> 00:45:04.500
会一直很忙

00:45:02.220 --> 00:45:06.180
你问这个问题什么时候运行的

00:45:04.500 --> 00:45:08.430
它是在更改之前还是之后运行的

00:45:06.180 --> 00:45:11.790
您可以完全击败的变化

00:45:08.430 --> 00:45:14.910
目的，所以如果没有

00:45:11.790 --> 00:45:16.790
具有不变性和懒惰

00:45:14.910 --> 00:45:19.710
是一件非常重要的事情，因为

00:45:16.790 --> 00:45:21.570
懒惰导致代码效率

00:45:19.710 --> 00:45:23.850
因为你不坐在那里

00:45:21.570 --> 00:45:25.860
制作和复制对象

00:45:23.850 --> 00:45:28.290
可以将执行推迟到以后

00:45:25.860 --> 00:45:30.030
时间，让他们执行得很好

00:45:28.290 --> 00:45:33.270
那是你最大的好处之一

00:45:30.030 --> 00:45:35.940
摆脱这个，所以把这个包起来

00:45:33.270 --> 00:45:38.310
真正的力量是懒惰

00:45:35.940 --> 00:45:40.050
但是懒惰也来了

00:45:38.310 --> 00:45:43.140
所谓功能的能力

00:45:40.050 --> 00:45:45.270
流水线我们的功能组成

00:45:43.140 --> 00:45:48.240
功能组成非常强大

00:45:45.270 --> 00:45:51.420
模式，我们之前看到了这样的示例

00:45:48.240 --> 00:45:54.120
但是让我们重新审视一下，假设我有

00:45:51.420 --> 00:45:56.100
跟我一起收集数字

00:45:54.120 --> 00:45:58.230
用数字说集合

00:45:56.100 --> 00:46:02.760
 1到10的数字，我想要这个

00:45:58.230 --> 00:46:06.330
时间说是平方的两倍

00:46:02.760 --> 00:46:09.230
我们说偶数根

00:46:06.330 --> 00:46:12.090
好吧，我可以写一个很好的

00:46:09.230 --> 00:46:14.580
流动的模式，所以我能做的就是

00:46:12.090 --> 00:46:17.760
可以说输出，但是这次我可以说

00:46:14.580 --> 00:46:20.790
数字开始流，然后我可以说

00:46:17.760 --> 00:46:24.570
好过滤器给一个元素给我

00:46:20.790 --> 00:46:28.590
元素标记2等于0，那么我可以

00:46:24.570 --> 00:46:29.970
在我说点图和Matt Squire扎根之后

00:46:28.590 --> 00:46:31.800
有兴趣找到平方根

00:46:29.970 --> 00:46:33.840
这些，当然，这是

00:46:31.800 --> 00:46:37.410
这次将被映射为两倍

00:46:33.840 --> 00:46:38.840
最后我可以说飞镖和

00:46:37.410 --> 00:46:41.630
那当然一

00:46:38.840 --> 00:46:43.460
所以我完全可以把它还好

00:46:41.630 --> 00:46:45.530
如果您这次看这段代码

00:46:43.460 --> 00:46:46.970
尽管我们在这种情况下所做的是

00:46:45.530 --> 00:46:49.820
我们说的是鉴于

00:46:46.970 --> 00:46:51.410
数字只能让我得到偶数，但

00:46:49.820 --> 00:46:54.200
给我那些的平方根

00:46:51.410 --> 00:46:55.820
数字，然后求和

00:46:54.200 --> 00:46:58.130
您可以看到它如何开始流动

00:46:55.820 --> 00:47:00.490
通过这个变成了所谓的

00:46:58.130 --> 00:47:02.960
您将要完成的功能组合

00:47:00.490 --> 00:47:05.870
您选择的转换

00:47:02.960 --> 00:47:08.120
您将偶数转换为映射

00:47:05.870 --> 00:47:10.430
加倍表现出色

00:47:08.120 --> 00:47:13.850
这是一个功能组合，但是

00:47:10.430 --> 00:47:16.820
评价也很懒，所以我

00:47:13.850 --> 00:47:19.430
意思是评估是懒惰的，直到

00:47:16.820 --> 00:47:22.070
你打总和这些

00:47:19.430 --> 00:47:23.450
操作将不会执行， 

00:47:22.070 --> 00:47:25.940
然后他们最少要执行

00:47:23.450 --> 00:47:29.270
一切必要，所以效率

00:47:25.940 --> 00:47:31.550
那么大，然后是语言

00:47:29.270 --> 00:47:34.460
像Java一样很酷的事情之一

00:47:31.550 --> 00:47:37.310
这是不是要收集

00:47:34.460 --> 00:47:39.260
并创建一个中间集合

00:47:37.310 --> 00:47:41.510
然后是另一种中间体

00:47:39.260 --> 00:47:44.330
收集它不会做的

00:47:41.510 --> 00:47:46.310
对你来说这是非常有效的

00:47:44.330 --> 00:47:48.470
在知道这些中间

00:47:46.310 --> 00:47:49.670
确实不需要先收集

00:47:48.470 --> 00:47:52.730
所有他们不可用，他们不是

00:47:49.670 --> 00:47:55.490
在外部可见，因此在内部不可见

00:47:52.730 --> 00:47:58.430
通过创建所有这些来浪费性能

00:47:55.490 --> 00:48:00.410
内部垃圾收集

00:47:58.430 --> 00:48:03.350
直接将您带到结果中

00:48:00.410 --> 00:48:05.090
结束，所以效率很高，那就是

00:48:03.350 --> 00:48:07.610
要提高效率真的很难

00:48:05.090 --> 00:48:09.740
其实也没有懒惰

00:48:07.610 --> 00:48:11.480
终端操作有些叫做

00:48:09.740 --> 00:48:14.600
那就是它执行操作的时间

00:48:11.480 --> 00:48:16.880
因此，它可以高效

00:48:14.600 --> 00:48:19.310
这不是在浪费时间和精力

00:48:16.880 --> 00:48:21.320
建立所有这些中间结果

00:48:19.310 --> 00:48:24.140
一路摆脱困境

00:48:21.320 --> 00:48:26.780
所以这样做的好处是第一

00:48:24.140 --> 00:48:28.640
当您

00:48:26.780 --> 00:48:30.770
看一下你不回头的代码

00:48:28.640 --> 00:48:33.230
它试图找出这段代码

00:48:30.770 --> 00:48:35.630
在做你就可以循环

00:48:33.230 --> 00:48:38.930
按照此代码考虑一下

00:48:35.630 --> 00:48:41.210
分钟，如果我给你一个for循环

00:48:38.930 --> 00:48:43.010
如果条件和烘烤，我继续

00:48:41.210 --> 00:48:44.660
我给你这个代码问你

00:48:43.010 --> 00:48:46.910
告诉我这段代码在做什么， 

00:48:44.660 --> 00:48:49.310
这是您面临的挑战

00:48:46.910 --> 00:48:51.920
要求别人问的命令性代码

00:48:49.310 --> 00:48:52.559
这是做什么的，坐在前面

00:48:51.920 --> 00:48:54.539
他们

00:48:52.559 --> 00:48:56.219
他们的眼球和他们的眼神是什么

00:48:54.539 --> 00:48:58.469
眼球会做到这一点

00:48:56.219 --> 00:49:00.390
首先从顶部看代码

00:48:58.469 --> 00:49:02.099
它会这样做，然后它会

00:49:00.390 --> 00:49:04.469
这一点被称为相当

00:49:02.099 --> 00:49:06.299
困惑吧，就像我不知道

00:49:04.469 --> 00:49:08.699
这段代码在做什么，但请看一下

00:49:06.299 --> 00:49:11.670
您只需一次完成功能代码

00:49:08.699 --> 00:49:13.829
通过它给定的集合得到

00:49:11.670 --> 00:49:16.439
我所有偶数都找到平方根

00:49:13.829 --> 00:49:18.539
他们，总的来说，你正在做一个

00:49:16.439 --> 00:49:21.059
通过它变得非常清楚

00:49:18.539 --> 00:49:24.630
了解您也减少了错误

00:49:21.059 --> 00:49:27.509
在代码中，因为代码不是

00:49:24.630 --> 00:49:29.069
其次是偶然的复杂性

00:49:27.509 --> 00:49:31.650
错误更少的原因是

00:49:29.069 --> 00:49:34.890
代码中的可变性也较少

00:49:31.650 --> 00:49:38.189
而且减少错误的可能性也降低了

00:49:34.890 --> 00:49:40.859
复杂性越少，可变性越少

00:49:38.189 --> 00:49:43.529
代码中的错误也会删除所有

00:49:40.859 --> 00:49:45.989
我们必须携带的额外垃圾变量

00:49:43.529 --> 00:49:48.660
周围，​​所以变得很难推理

00:49:45.989 --> 00:49:51.479
您也可以删除它，最后

00:49:48.660 --> 00:49:53.640
代码变得更容易瘫痪

00:49:51.479 --> 00:49:55.979
好吧，如果你有必要

00:49:53.640 --> 00:49:58.380
共享可变性的代码，您告诉

00:49:55.979 --> 00:50:01.109
他们使代码并发

00:49:58.380 --> 00:50:03.719
真的很难，因为

00:50:01.109 --> 00:50:06.329
顺序之间的代码变化很大

00:50:03.719 --> 00:50:08.699
而另一方面

00:50:06.329 --> 00:50:11.549
这种代码想象这是一个

00:50:08.699 --> 00:50:13.199
非常大的收藏

00:50:11.549 --> 00:50:15.779
可以做的就是在运行代码时

00:50:13.199 --> 00:50:18.150
看到它会产生结果，但是你

00:50:15.779 --> 00:50:20.309
可以简单地在这里扔一个并行

00:50:18.150 --> 00:50:22.410
这将并行运行并产生

00:50:20.309 --> 00:50:24.299
整个课程的结果

00:50:22.410 --> 00:50:26.400
可以像这样并行调用

00:50:24.299 --> 00:50:28.890
也将其转换为并行流

00:50:26.400 --> 00:50:31.349
但更重要的是

00:50:28.890 --> 00:50:34.140
代码结构没有不同

00:50:31.349 --> 00:50:35.910
在顺序和并行之间

00:50:34.140 --> 00:50:38.429
和弦结构首次出现在

00:50:35.910 --> 00:50:40.979
长时间之间是完全一样的

00:50:38.429 --> 00:50:43.679
顺序和并发这是巨大的

00:50:40.979 --> 00:50:45.539
让我们享受的好处，这就是其中之一

00:50:43.679 --> 00:50:48.150
最大的好处告诉我们

00:50:45.539 --> 00:50:51.449
总结函数式编程删除

00:50:48.150 --> 00:50:54.059
代码中的意外复杂性

00:50:51.449 --> 00:50:56.039
显然我们都同意功能

00:50:54.059 --> 00:50:57.989
编程需要花费更多的精力

00:50:56.039 --> 00:51:00.119
了解开始是因为

00:50:57.989 --> 00:51:01.859
我们不熟悉我们

00:51:00.119 --> 00:51:03.449
熟悉命令式

00:51:01.859 --> 00:51:05.729
编程，但一旦成为

00:51:03.449 --> 00:51:06.510
熟悉它可以减少我们的工作量

00:51:05.729 --> 00:51:08.940
来写

00:51:06.510 --> 00:51:11.430
它消除了这些意外的复杂性

00:51:08.940 --> 00:51:13.290
它使代码推理更加容易

00:51:11.430 --> 00:51:15.930
使得惩罚代码更容易

00:51:13.290 --> 00:51:17.400
我们可以享受的所有好处就是

00:51:15.930 --> 00:51:19.830
我们为什么要赞成这一点的原因

00:51:17.400 --> 00:51:22.020
而且真的很酷

00:51:19.830 --> 00:51:23.910
当今主流语言正在提供

00:51:22.020 --> 00:51:25.080
这包括Java 8 

00:51:23.910 --> 00:51:26.790
有兴趣下载代码

00:51:25.080 --> 00:51:28.620
我告诉你的例子

00:51:26.790 --> 00:51:30.570
欢迎通过链接下载它们

00:51:28.620 --> 00:51:32.270
在最下面的希望中显示了

00:51:30.570 --> 00:51:38.799
有用的感谢您的时间

00:51:32.270 --> 00:51:38.799
 [音乐] 

