WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.150 --> 00:00:10.080
好的，欢迎大家，谢谢

00:00:07.230 --> 00:00:11.820
非常重要，我是Eric，今天

00:00:10.080 --> 00:00:14.670
我们将谈谈g1 

00:00:11.820 --> 00:00:16.860
概念和性能调优，但

00:00:14.670 --> 00:00:19.349
在我们开始之前，我先放这张幻灯片

00:00:16.860 --> 00:00:25.170
在那里呆了几秒钟

00:00:19.349 --> 00:00:27.570
让大家享受吧

00:00:25.170 --> 00:00:29.099
看看我们今天的议程

00:00:27.570 --> 00:00:30.900
从三点开始

00:00:29.099 --> 00:00:32.490
重要的特性

00:00:30.900 --> 00:00:35.820
垃圾收集吞吐量延迟

00:00:32.490 --> 00:00:37.800
和足迹，我们现在要继续

00:00:35.820 --> 00:00:39.600
了解如何衡量JVM和

00:00:37.800 --> 00:00:41.880
之后垃圾收集器

00:00:39.600 --> 00:00:43.020
进行一些调整，最后

00:00:41.880 --> 00:00:45.930
我们将谈论一些

00:00:43.020 --> 00:00:47.940
社区，但首先我是谁

00:00:45.930 --> 00:00:50.790
我喜欢对Eric编程垃圾

00:00:47.940 --> 00:00:52.680
我在JVM中在Oracle工作的收集器

00:00:50.790 --> 00:00:55.200
垃圾收集小组已经这样做了

00:00:52.680 --> 00:00:56.850
大约六年

00:00:55.200 --> 00:00:59.490
过去三年来我一直在研究g1 

00:00:56.850 --> 00:01:03.270
垃圾收集器，我是评论员

00:00:59.490 --> 00:01:05.129
和OPI衰减的频繁提交者，因此

00:01:03.270 --> 00:01:08.670
让我们进入今天的第一点

00:01:05.129 --> 00:01:11.130
吞吐延迟和占用空间

00:01:08.670 --> 00:01:14.220
三个重要的属性可以大致

00:01:11.130 --> 00:01:16.380
被定义为我们免费放的数量

00:01:14.220 --> 00:01:18.450
每秒的请求数，如果您有网络

00:01:16.380 --> 00:01:19.770
服务器或其他一些后端服务

00:01:18.450 --> 00:01:22.710
您可以处理的请求数

00:01:19.770 --> 00:01:24.690
每秒的延迟，您可以想到

00:01:22.710 --> 00:01:27.480
作为请求的最长时间

00:01:24.690 --> 00:01:29.610
对于脚印来说，通常

00:01:27.480 --> 00:01:32.490
考虑一下Java的内存使用情况

00:01:29.610 --> 00:01:34.200
流程，我们将探讨

00:01:32.490 --> 00:01:37.260
这些都多一点

00:01:34.200 --> 00:01:39.690
详细的属性，以便获得吞吐量

00:01:37.260 --> 00:01:42.750
我们通常将其作为总数

00:01:39.690 --> 00:01:44.280
 Java进程的运行时间和

00:01:42.750 --> 00:01:46.500
说到垃圾收集

00:01:44.280 --> 00:01:48.750
在不同的GCS之间可能有所不同

00:01:46.500 --> 00:01:50.729
他们为总数贡献了多少

00:01:48.750 --> 00:01:52.740
运行时间一些收藏家要去

00:01:50.729 --> 00:01:54.659
暂停所以停止Java应用程序

00:01:52.740 --> 00:01:56.700
这些姿势当然会

00:01:54.659 --> 00:01:58.590
有助于

00:01:56.700 --> 00:02:00.810
程序，但还有更多

00:01:58.590 --> 00:02:02.490
耶稣可以做的细微差别

00:02:00.810 --> 00:02:04.740
暂停期间进行不同的优化

00:02:02.490 --> 00:02:06.270
以及程序运行时

00:02:04.740 --> 00:02:08.369
所以不同的收藏家会导致

00:02:06.270 --> 00:02:11.249
缩短或延长总运行时间

00:02:08.369 --> 00:02:13.230
相同的工作量以及涉及的时间

00:02:11.249 --> 00:02:13.819
水果你通常会在意

00:02:13.230 --> 00:02:16.430
你有更多

00:02:13.819 --> 00:02:17.989
例如，pache之类的工作负载

00:02:16.430 --> 00:02:20.239
当您编译Java源代码时

00:02:17.989 --> 00:02:22.519
使用Java C您也不太在乎

00:02:20.239 --> 00:02:24.499
 JVM在发布过程中发布了多长时间

00:02:22.519 --> 00:02:26.299
完成，您只需要您的来源

00:02:24.499 --> 00:02:29.329
代码要尽快编译

00:02:26.299 --> 00:02:30.889
可能你也可能离线很大

00:02:29.329 --> 00:02:33.439
数据作业正在运行，或者您有一些

00:02:30.889 --> 00:02:35.150
您不在的科学计算

00:02:33.439 --> 00:02:36.530
真正与程序进行交互

00:02:35.150 --> 00:02:39.439
告诉开始，你想得到

00:02:36.530 --> 00:02:41.329
结果返回通常我们将其测量为

00:02:39.439 --> 00:02:43.760
总的运行时间还是

00:02:41.329 --> 00:02:46.900
例如在时间单位内输出

00:02:43.760 --> 00:02:49.250
每秒请求数或类似

00:02:46.900 --> 00:02:52.159
我们要谈的第二个属性

00:02:49.250 --> 00:02:53.269
大约是延迟，我会加载您的

00:02:52.159 --> 00:02:55.310
这里大概担心这个

00:02:53.269 --> 00:02:57.949
通常，当您有一个

00:02:55.310 --> 00:02:59.480
网络服务等服务

00:02:57.949 --> 00:03:01.909
有一些后端服务，你有

00:02:59.480 --> 00:03:03.709
通常您会评估请求时间，因此

00:03:01.909 --> 00:03:06.109
用户希望看到您的网站多长时间

00:03:03.709 --> 00:03:07.730
从他们加载页面很长时间

00:03:06.109 --> 00:03:10.849
从低开始，患者将得到结果

00:03:07.730 --> 00:03:13.129
回来，这非常重要，而且经常

00:03:10.849 --> 00:03:15.019
你看到这样的图--在哪里滑动

00:03:13.129 --> 00:03:17.959
 x轴，您当时的y轴

00:03:15.019 --> 00:03:20.449
您有请求时间和DC 

00:03:17.959 --> 00:03:22.819
促成这一点或当它成为问题时

00:03:20.449 --> 00:03:24.769
来到这里，因为如果垃圾

00:03:22.819 --> 00:03:26.689
收藏家决定暂停您的

00:03:24.769 --> 00:03:28.359
应用程序意味着它将

00:03:26.689 --> 00:03:30.949
有助于请求时间和

00:03:28.359 --> 00:03:32.900
通常当我们谈论延迟时

00:03:30.949 --> 00:03:35.750
必须比我们思考更多

00:03:32.900 --> 00:03:39.229
量化它，我们经常做的是，我们

00:03:35.750 --> 00:03:41.840
将请求类型从最长到最大排序

00:03:39.229 --> 00:03:44.540
最短，注意我在标签上放了标签

00:03:41.840 --> 00:03:47.329
在x轴上，这只是一种排序

00:03:44.540 --> 00:03:49.389
时不时的请求类型数

00:03:47.329 --> 00:03:52.430
可以开始量化其含义

00:03:49.389 --> 00:03:55.129
稍后告诉较低或较高

00:03:52.430 --> 00:03:57.709
可以说我的95％ 

00:03:55.129 --> 00:04:00.469
请求在50毫秒内完成

00:03:57.709 --> 00:04:01.849
较短，我们当然可以

00:04:00.469 --> 00:04:04.489
关于垃圾同样的事情

00:04:01.849 --> 00:04:06.829
收集过程中我们可以测量GC 

00:04:04.489 --> 00:04:08.959
停顿一下，注意并非总是如此

00:04:06.829 --> 00:04:10.879
最长的请求的情况

00:04:08.959 --> 00:04:12.680
最长的看到应该有一个

00:04:10.879 --> 00:04:14.090
一堆其他有助于

00:04:12.680 --> 00:04:17.090
请求的时间可能是

00:04:14.090 --> 00:04:18.739
他们可能会遇到的网络延迟

00:04:17.090 --> 00:04:21.079
关于您可能必须阅读一些内容

00:04:18.739 --> 00:04:22.279
磁盘，但我们有点

00:04:21.079 --> 00:04:24.590
当然，做的事情都是一样的

00:04:22.279 --> 00:04:26.719
到GC暂停，这将是请求类型

00:04:24.590 --> 00:04:27.650
我们可以将它们从最长到最大

00:04:26.719 --> 00:04:29.780
现在最短

00:04:27.650 --> 00:04:31.669
可以开始量化关于

00:04:29.780 --> 00:04:35.000
例如，我们的DC发布时间

00:04:31.669 --> 00:04:38.150
我的DC姿势中有90％较短

00:04:35.000 --> 00:04:39.830
少于10毫秒

00:04:38.150 --> 00:04:42.350
延迟，您经常在乎我们

00:04:39.830 --> 00:04:43.970
例如具有交互式工作负载

00:04:42.350 --> 00:04:46.970
如果您正在尝试新的喊工具

00:04:43.970 --> 00:04:48.979
在雪人犬中，任何类型的表达

00:04:46.970 --> 00:04:50.300
在HL中，您不想等待

00:04:48.979 --> 00:04:51.680
很长一段时间，直到你得到答案

00:04:50.300 --> 00:04:55.150
您想立即看到它并得到

00:04:51.680 --> 00:04:59.180
响应性也网络服务

00:04:55.150 --> 00:05:01.039
再次是某种网络后端

00:04:59.180 --> 00:05:03.470
关心返回到的请求

00:05:01.039 --> 00:05:05.150
用户也可以以图形方式

00:05:03.470 --> 00:05:07.370
应用程序，如果您正在渲染事物

00:05:05.150 --> 00:05:08.900
以您不想画格的画格

00:05:07.370 --> 00:05:10.880
需要很长时间，因为它将

00:05:08.900 --> 00:05:13.910
导致你的懈怠

00:05:10.880 --> 00:05:16.070
应用程序，当我们测量它时，我们

00:05:13.910 --> 00:05:18.590
通常谈论百分比

00:05:16.070 --> 00:05:21.500
时间单位，例如第95 

00:05:18.590 --> 00:05:24.470
百分位数是50毫秒，这意味着

00:05:21.500 --> 00:05:28.610
 95％的韩军短50 

00:05:24.470 --> 00:05:29.690
毫秒和最后一个适当的时间是

00:05:28.610 --> 00:05:32.389
会看到一点

00:05:29.690 --> 00:05:35.180
足迹，在这里我们看到了一点

00:05:32.389 --> 00:05:37.280
正在进行的Java进程的X射线照片

00:05:35.180 --> 00:05:39.710
以及什么导致内存使用

00:05:37.280 --> 00:05:41.210
这样的Java进程当然

00:05:39.710 --> 00:05:42.949
大量的内存使用情况可能是

00:05:41.210 --> 00:05:44.659
将会是Java堆本身

00:05:42.949 --> 00:05:46.520
包含很多Java对象

00:05:44.659 --> 00:05:48.979
但是还有其他事情

00:05:46.520 --> 00:05:50.930
例如C堆或本机堆

00:05:48.979 --> 00:05:52.520
 JVM可以用来分配数据

00:05:50.930 --> 00:05:54.770
它需要支持其结构

00:05:52.520 --> 00:05:56.960
算法可能有匿名

00:05:54.770 --> 00:05:59.240
他们将用M地图映射的页面

00:05:56.960 --> 00:06:01.460
当然也有天赋的代码

00:05:59.240 --> 00:06:03.830
占用您的过程和一些空间

00:06:01.460 --> 00:06:05.690
其他事情正在发生，何时发生

00:06:03.830 --> 00:06:08.030
对于GC，这也有助于

00:06:05.690 --> 00:06:11.380
因为不同的算法可能

00:06:08.030 --> 00:06:13.789
导致较小或较大的堆

00:06:11.380 --> 00:06:16.130
不同的DC算法也会消耗

00:06:13.789 --> 00:06:19.580
或多或少的本机内存以便

00:06:16.130 --> 00:06:22.810
支持它的算法，还有一些

00:06:19.580 --> 00:06:25.450
足够的页面等

00:06:22.810 --> 00:06:26.889
如果您担心占地面积

00:06:25.450 --> 00:06:28.420
你可能还要工作一些

00:06:26.889 --> 00:06:29.889
内存受限环境

00:06:28.420 --> 00:06:32.650
您可能要编程运行的示例

00:06:29.889 --> 00:06:35.020
在Raspberry Pi和IOT设备上，但是

00:06:32.650 --> 00:06:37.240
它也开始变得有点

00:06:35.020 --> 00:06:38.380
流行还是经常出现问题

00:06:37.240 --> 00:06:41.320
它涉及到您想要的容器

00:06:38.380 --> 00:06:44.169
将很多JVM或容器打包到一个

00:06:41.320 --> 00:06:46.240
单机，我们通常测量

00:06:44.169 --> 00:06:50.770
这是一个进程的内存使用量

00:06:46.240 --> 00:06:52.570
兆字节或千兆字节，所以问题

00:06:50.770 --> 00:06:53.950
这通常很难进行优化

00:06:52.570 --> 00:06:55.960
所有这些属性同时

00:06:53.950 --> 00:06:57.880
通常，您可以权衡取舍

00:06:55.960 --> 00:06:59.560
针对其中一两个进行优化，然后

00:06:57.880 --> 00:07:01.780
你将不得不牺牲第三个

00:06:59.560 --> 00:07:03.580
有时有时候会有一些金

00:07:01.780 --> 00:07:06.930
优化，但不太常见

00:07:03.580 --> 00:07:09.580
重要的是您定义

00:07:06.930 --> 00:07:11.800
对您的程序意味着成功

00:07:09.580 --> 00:07:15.160
表现出色

00:07:11.800 --> 00:07:17.050
例如，如果我正在提供服务

00:07:15.160 --> 00:07:19.060
上一个网页，然后我可能会说得很好

00:07:17.050 --> 00:07:21.729
我所有访问网页或访问的用户

00:07:19.060 --> 00:07:24.550
至少有99.9％的人应该得到

00:07:21.729 --> 00:07:26.320
网页返回300毫秒或

00:07:24.550 --> 00:07:28.479
程序应该在很小的程度上运行错误

00:07:26.320 --> 00:07:30.220
覆盆子pi零或重要的一天

00:07:28.479 --> 00:07:32.320
知道对象在四个小时内完成

00:07:30.220 --> 00:07:34.419
这些是你自己的财产

00:07:32.320 --> 00:07:37.270
程序没有人在乎，如果你有一个非常

00:07:34.419 --> 00:07:38.800
放置在快速的JVM中，但是您的程序

00:07:37.270 --> 00:07:41.350
运行缓慢，重要的是

00:07:38.800 --> 00:07:43.090
程序很快，如果这意味着你

00:07:41.350 --> 00:07:45.580
给我一台可能是虚拟机的虚拟机，但是

00:07:43.090 --> 00:07:47.289
请记住，这都是关于如何

00:07:45.580 --> 00:07:52.930
用户感知到您的应用程序

00:07:47.289 --> 00:07:54.340
性能不是JVM本身，所以我们

00:07:52.930 --> 00:07:55.810
看了一下这三个

00:07:54.340 --> 00:07:59.640
属性，现在我们将看到

00:07:55.810 --> 00:07:59.640
我们如何从JVM中获取一些数据

00:08:05.880 --> 00:08:11.199
因此性能问题可能来自

00:08:09.009 --> 00:08:13.419
您拥有自己的堆栈中的任何一层

00:08:11.199 --> 00:08:15.370
可能有数据的应用程序

00:08:13.419 --> 00:08:18.400
结构库算法

00:08:15.370 --> 00:08:20.080
执行次优的JVM本身

00:08:18.400 --> 00:08:22.210
正在运行您的应用程序的课程

00:08:20.080 --> 00:08:25.060
可能与JIT有问题

00:08:22.210 --> 00:08:27.729
与GC同步锁定

00:08:25.060 --> 00:08:29.710
操作系统，您可能会使用的内核

00:08:27.729 --> 00:08:33.669
查看调度程序的问题

00:08:29.710 --> 00:08:35.320
透明的大页面再次锁定您

00:08:33.669 --> 00:08:36.880
密封库可能有问题

00:08:35.320 --> 00:08:39.610
在操作系统的用户空间中

00:08:36.880 --> 00:08:40.719
执行次优a，最后您

00:08:39.610 --> 00:08:42.279
当然也会有问题

00:08:40.719 --> 00:08:44.229
硬件本身可能已过时

00:08:42.279 --> 00:08:46.270
没有所有固件

00:08:44.229 --> 00:08:47.560
那里最新的性能增强

00:08:46.270 --> 00:08:51.880
可能是虚拟化的问题

00:08:47.560 --> 00:08:53.529
内存带宽等，但在本次演讲中

00:08:51.880 --> 00:08:55.570
我们将专注于JVM和

00:08:53.529 --> 00:08:56.620
特别是GC，但如果您真的

00:08:55.570 --> 00:08:58.089
想要获得最佳性能

00:08:56.620 --> 00:09:00.490
你将不得不全力以赴

00:08:58.089 --> 00:09:03.610
系统考虑并看各种

00:09:00.490 --> 00:09:05.080
其他事情，如果我们想了解更多

00:09:03.610 --> 00:09:07.690
要给他们如何获得一些

00:09:05.080 --> 00:09:10.240
数据很好，我们有两个主要

00:09:07.690 --> 00:09:12.730
选项，这里有Java飞行

00:09:10.240 --> 00:09:15.700
通过其标志启用的记录器

00:09:12.730 --> 00:09:17.410
 -x轴塔式飞行记录此

00:09:15.700 --> 00:09:19.870
将导致二进制记录

00:09:17.410 --> 00:09:21.400
二进制格式，您可以选择

00:09:19.870 --> 00:09:23.980
您要订阅的活动

00:09:21.400 --> 00:09:26.110
订阅并获取其中的数据

00:09:23.980 --> 00:09:28.209
录音，该录音可以

00:09:26.110 --> 00:09:30.940
以后通常在Java Mission中查看

00:09:28.209 --> 00:09:33.940
控制您还可以使用基于文本的

00:09:30.940 --> 00:09:35.440
在JDK 9中登录，您有了新的统一

00:09:33.940 --> 00:09:38.770
在后面介绍的日志记录

00:09:35.440 --> 00:09:41.529
标志-X日志日志为文本格式

00:09:38.770 --> 00:09:44.290
在这里，当您选择哪种类型

00:09:41.529 --> 00:09:46.240
您要使用标签测量的数据

00:09:44.290 --> 00:09:48.820
和级别来描述哪些信息

00:09:46.240 --> 00:09:50.380
您想摆脱JVM和

00:09:48.820 --> 00:09:52.600
当然这些文本文件可以在

00:09:50.380 --> 00:09:53.890
您选择的社论，我们

00:09:52.600 --> 00:09:56.650
会更深入地研究

00:09:53.890 --> 00:09:59.350
依次选择这两个选项，让我们

00:09:56.650 --> 00:10:01.810
从Java飞行记录器开始

00:09:59.350 --> 00:10:04.300
今天的飞行记录仪在您的K9中

00:10:01.810 --> 00:10:06.730
将编写Java XX解锁的商业广告

00:10:04.300 --> 00:10:09.130
功能，然后开始飞行记录

00:10:06.730 --> 00:10:11.079
给它一个文件名记录点j4 

00:10:09.130 --> 00:10:14.230
这个例子，然后运行

00:10:11.079 --> 00:10:15.910
完成申请后，如果

00:10:14.230 --> 00:10:17.890
你在同一时间做LS 

00:10:15.910 --> 00:10:21.790
在工厂，您会发现j4的录音

00:10:17.890 --> 00:10:24.640
在那里记录数据

00:10:21.790 --> 00:10:25.930
参与其中或基于事件的问题

00:10:24.640 --> 00:10:28.270
您想订阅的那种仆人

00:10:25.930 --> 00:10:30.580
并获取记录中的数据

00:10:28.270 --> 00:10:33.280
您可以在JFC中选择这些事件

00:10:30.580 --> 00:10:35.170
设置文件，在JDK 9中，您还可以

00:10:33.280 --> 00:10:35.830
创建自己的新事件

00:10:35.170 --> 00:10:37.660
你k 9 

00:10:35.830 --> 00:10:39.640
这是一个非常强大的功能，您可以

00:10:37.660 --> 00:10:41.860
在您的应用程序中创建事件

00:10:39.640 --> 00:10:43.660
最终将与

00:10:41.860 --> 00:10:45.730
您可以从JVM本身获取事件

00:10:43.660 --> 00:10:47.110
相关也许你可以看到你

00:10:45.730 --> 00:10:49.510
开始时创建一个事件

00:10:47.110 --> 00:10:51.610
您的报告分析工作，您会看到

00:10:49.510 --> 00:10:54.340
当你得到的时候

00:10:51.610 --> 00:10:56.410
例如说GC的事件

00:10:54.340 --> 00:10:57.940
花了太长时间或其他时间，现在

00:10:56.410 --> 00:11:00.130
我们可以很容易地将

00:10:57.940 --> 00:11:01.540
这两个事件正在发生，看到

00:11:00.130 --> 00:11:05.800
好吧，这也许就是成本，而这

00:11:01.540 --> 00:11:08.400
在观看效果录音时

00:11:05.800 --> 00:11:11.950
 Java Mission Control或JMC的简称

00:11:08.400 --> 00:11:14.530
 JMC 6.0与Oracle一起发布

00:11:11.950 --> 00:11:15.970
 JDK 9，您可以使用您的发射

00:11:14.530 --> 00:11:18.100
控制开始录制，这样您就不必

00:11:15.970 --> 00:11:19.870
必须使用您可以使用的命令行

00:11:18.100 --> 00:11:21.850
 MC来获取录音

00:11:19.870 --> 00:11:24.370
也可以在JMC中配置哪些事件

00:11:21.850 --> 00:11:26.170
您想从中获取数据

00:11:24.370 --> 00:11:28.090
从游戏开始六点钟

00:11:26.170 --> 00:11:31.600
自动分析您的录音

00:11:28.090 --> 00:11:33.250
因此，JMC是可以做到的规则引擎

00:11:31.600 --> 00:11:35.290
使用基于

00:11:33.250 --> 00:11:37.420
记录中的事件以及是否需要

00:11:35.290 --> 00:11:38.890
更多信息，请参见oracle / 

00:11:37.420 --> 00:11:42.640
任务控制有关的更多详细信息

00:11:38.890 --> 00:11:45.250
 JMC和下面的屏幕快照显示了

00:11:42.640 --> 00:11:46.630
詹姆斯，当我们看起来有点像

00:11:45.250 --> 00:11:52.150
更详细地介绍了垃圾

00:11:46.630 --> 00:11:53.740
收集信息记录另一个

00:11:52.150 --> 00:11:57.640
从JVM提取数据的选择

00:11:53.740 --> 00:12:00.670
因此JDK 9引入了一个新标志-X日志

00:11:57.640 --> 00:12:02.440
和统一的日志记录框架

00:12:00.670 --> 00:12:05.710
用于启用日志记录的选项的格式

00:12:02.440 --> 00:12:07.690
是简化形式-X日志就像一个

00:12:05.710 --> 00:12:10.450
标记您选择想要的级别

00:12:07.690 --> 00:12:12.220
标签上的信息，您告诉日志

00:12:10.450 --> 00:12:14.410
在子系统中日志应该结束的地方

00:12:12.220 --> 00:12:17.260
在esterday出城或竞技场档案

00:12:14.410 --> 00:12:20.410
也许是幻灯片上的一个例子

00:12:17.260 --> 00:12:22.360
我们看到我想要所有消息

00:12:20.410 --> 00:12:24.880
标记为DC的信息级别

00:12:22.360 --> 00:12:25.630
如果或消息标记有DC 

00:12:24.880 --> 00:12:28.570
加脸

00:12:25.630 --> 00:12:29.140
我想要在dos和上的调试级别

00:12:28.570 --> 00:12:29.570
安全

00:12:29.140 --> 00:12:31.700
几乎

00:12:29.570 --> 00:12:33.500
刚刚标记了安全点，我想要他们

00:12:31.700 --> 00:12:37.040
在跟踪级别上，我想要所有这些

00:12:33.500 --> 00:12:39.680
在文件GZ中-更多徽标文字

00:12:37.040 --> 00:12:41.780
有关此命令行标志的详细信息以及

00:12:39.680 --> 00:12:44.510
如何指定可以看到的语法

00:12:41.780 --> 00:12:50.300
杰克158开启java.net十年

00:12:44.510 --> 00:12:52.220
斜杠158，例如

00:12:50.300 --> 00:12:54.740
从这里的日志输出看起来只是

00:12:52.220 --> 00:12:57.350
从第四级开始启用GC 

00:12:54.740 --> 00:12:59.530
是信息，我现在将收到一条消息

00:12:57.350 --> 00:13:02.110
在信息级别上用GC标记，并且

00:12:59.530 --> 00:13:04.640
然后您还运行您的应用程序

00:13:02.110 --> 00:13:06.740
首先，我们看到每一行

00:13:04.640 --> 00:13:09.050
得到一些装饰，所以第一个

00:13:06.740 --> 00:13:11.210
列，在这种情况下，您会得到一个

00:13:09.050 --> 00:13:13.970
此日志消息的时间戳记

00:13:11.210 --> 00:13:15.350
写你会看到水平，所以我

00:13:13.970 --> 00:13:17.680
以默认级别运行

00:13:15.350 --> 00:13:19.970
信息，所以我所有的行都有信息级别

00:13:17.680 --> 00:13:22.640
我也得到了带有标签的日志

00:13:19.970 --> 00:13:25.070
与GC和只有GC，所以在这里

00:13:22.640 --> 00:13:27.140
 C此消息没有标签的

00:13:25.070 --> 00:13:29.930
当然只GC，然后消息

00:13:27.140 --> 00:13:33.830
本身，JVM在这里告诉你

00:13:29.930 --> 00:13:35.540
你现在正在用g1运行

00:13:33.830 --> 00:13:37.340
更像G的样子

00:13:35.540 --> 00:13:39.890
就像在这种日志记录级别上

00:13:37.340 --> 00:13:42.860
再次查看时间戳信息级别

00:13:39.890 --> 00:13:45.350
 GC标签，然后我们进入

00:13:42.860 --> 00:13:47.720
实际日志消息以及每个日志

00:13:45.350 --> 00:13:49.130
消息，您将在此处获得GC ID 

00:13:47.720 --> 00:13:51.590
第一个是0，他们不必

00:13:49.130 --> 00:13:52.880
以连续的顺序来只是一个

00:13:51.590 --> 00:13:55.160
标识符，因为我们稍后会看到

00:13:52.880 --> 00:13:57.080
可能会有更多的日志行

00:13:55.160 --> 00:13:59.090
单个GC，然后ID可以帮助您

00:13:57.080 --> 00:14:01.670
识别哪些线属于

00:13:59.090 --> 00:14:03.230
垃圾收集帖子告诉你

00:14:01.670 --> 00:14:04.820
这是什么样的帖子

00:14:03.230 --> 00:14:07.340
年轻的职位显然，我们将看到

00:14:04.820 --> 00:14:10.460
那是该职位的原因

00:14:07.340 --> 00:14:14.470
这是堆的娱乐场所

00:14:10.460 --> 00:14:17.420
发帖前的用法发帖后和

00:14:14.470 --> 00:14:20.690
容量可能有多少内存

00:14:17.420 --> 00:14:22.310
也长大了，这是给你的

00:14:20.690 --> 00:14:26.900
关注帖子的长度

00:14:22.310 --> 00:14:29.060
本身很好，所以我们研究了如何

00:14:26.900 --> 00:14:30.950
获取数据顺序JVM并执行一些操作

00:14:29.060 --> 00:14:34.070
现在让我们开始测量

00:14:30.950 --> 00:14:35.270
多一点调整，所以经常调整

00:14:34.070 --> 00:14:37.370
从你的问题开始

00:14:35.270 --> 00:14:39.020
注意到请求可能花费了太长时间

00:14:37.370 --> 00:14:41.990
表演的时间

00:14:39.020 --> 00:14:43.160
实验室，您发现一个CPU 

00:14:41.990 --> 00:14:45.410
你的服务一百

00:14:43.160 --> 00:14:47.150
和利用或Java流程

00:14:45.410 --> 00:14:48.560
整个内存中，您需要

00:14:47.150 --> 00:14:49.700
了解为什么和发生了什么，以及

00:14:48.560 --> 00:14:52.850
那里发生了什么

00:14:49.700 --> 00:14:55.310
所以在所有这些情况下，我通常都会申请

00:14:52.850 --> 00:14:57.350
我先看一下的方法

00:14:55.310 --> 00:14:59.180
发生了什么事，那么我需要

00:14:57.350 --> 00:15:01.040
了解为什么会这样，并且

00:14:59.180 --> 00:15:02.750
当我们有数据，我们有一个

00:15:01.040 --> 00:15:05.270
了解他们所面临的问题

00:15:02.750 --> 00:15:09.290
经常在它周围调音，所以

00:15:05.270 --> 00:15:11.210
发出但先要先

00:15:09.290 --> 00:15:13.280
当您开始排队并开始

00:15:11.210 --> 00:15:15.350
测量您想要优化的东西

00:15:13.280 --> 00:15:18.460
使用最少数量的Aeon Flux 

00:15:15.350 --> 00:15:20.810
首先，我们看到许多例子

00:15:18.460 --> 00:15:24.260
人们一直在继承以前

00:15:20.810 --> 00:15:25.940
多年的同事JVM标志可能在

00:15:24.260 --> 00:15:27.710
他们的第五代有很多

00:15:25.940 --> 00:15:29.660
其中的大多数标记可能不会

00:15:27.710 --> 00:15:31.610
甚至不再使用

00:15:29.660 --> 00:15:32.900
不同的冲突标志标志

00:15:31.610 --> 00:15:35.930
一样的垃圾收集

00:15:32.900 --> 00:15:37.990
命令行，因此只需从X MX开始

00:15:35.930 --> 00:15:41.900
首先要获得干净的新鲜石板

00:15:37.990 --> 00:15:44.110
当您开始优化时，请

00:15:41.900 --> 00:15:47.120
依靠第一手资料

00:15:44.110 --> 00:15:50.900
对于ek9和我的同事Thomas 

00:15:47.120 --> 00:15:53.870
重写了整个g1调整准则

00:15:50.900 --> 00:15:55.520
所以他们被重新改写为9 

00:15:53.870 --> 00:15:58.130
所有最新信息，所以请

00:15:55.520 --> 00:16:00.410
看那个文件，还有很多

00:15:58.130 --> 00:16:02.660
演示当然基于此

00:16:00.410 --> 00:16:05.210
当您调音时它将帮助您

00:16:02.660 --> 00:16:07.970
再次g1已经存在很长时间了

00:16:05.210 --> 00:16:10.940
关于许多过时的信息

00:16:07.970 --> 00:16:12.710
各种博客讨论中的网络等等

00:16:10.940 --> 00:16:14.960
请在以下情况使用最新信息

00:16:12.710 --> 00:16:16.610
您开始调音，最后用作

00:16:14.960 --> 00:16:18.920
最近的JDK可能是

00:16:16.610 --> 00:16:21.140
对于具有

00:16:18.920 --> 00:16:24.980
近年来有了很大的进步a 

00:16:21.140 --> 00:16:27.280
发布好了，所以我们的问题

00:16:24.980 --> 00:16:29.960
今天要看的姿势太长了

00:16:27.280 --> 00:16:34.550
这通常是我们从用户那里听到的

00:16:29.960 --> 00:16:37.010
他们关心并想要的

00:16:34.550 --> 00:16:39.560
再次调整，为什么我们会关心

00:16:37.010 --> 00:16:42.230
如果你有某种

00:16:39.560 --> 00:16:45.440
交互应用程序和JVM 

00:16:42.230 --> 00:16:47.750
 GC这种情况给您提出了申请

00:16:45.440 --> 00:16:50.540
将会有更长的请求时间，否则您

00:16:47.750 --> 00:16:52.730
会丢帧等，所以我们想

00:16:50.540 --> 00:16:56.210
缩短这些姿势以进行互动

00:16:52.730 --> 00:16:56.950
申请您​​的第一个标志

00:16:56.210 --> 00:17:00.130
这将是

00:16:56.950 --> 00:17:02.650
 Maxie支持Millis，因为这是

00:17:00.130 --> 00:17:06.010
在许多情况下驱动D的标志

00:17:02.650 --> 00:17:08.890
或经济引擎，所以智元尝试

00:17:06.010 --> 00:17:12.040
保持职位目标和本博士后

00:17:08.890 --> 00:17:14.620
如果您默认设置为200毫秒

00:17:12.040 --> 00:17:16.329
增加这个职位目标，你给

00:17:14.620 --> 00:17:18.940
较高的价值，可以说我很好

00:17:16.329 --> 00:17:22.390
 500毫秒脉冲意味着您

00:17:18.940 --> 00:17:24.220
会从你身上拿出更多的水果

00:17:22.390 --> 00:17:25.480
申请，但您还会得到更高

00:17:24.220 --> 00:17:27.699
延迟，因为你是说我

00:17:25.480 --> 00:17:29.110
罚款500毫秒海报，如果

00:17:27.699 --> 00:17:31.060
你会没事的，你会

00:17:29.110 --> 00:17:32.740
另一方面获得更好的吞吐量

00:17:31.060 --> 00:17:34.630
如果你说我要很短

00:17:32.740 --> 00:17:37.000
暂停然后您可以降低此值

00:17:34.630 --> 00:17:39.670
到例如100毫秒或80 

00:17:37.000 --> 00:17:40.150
当然会附带一个毫秒

00:17:39.670 --> 00:17:42.130
成本

00:17:40.150 --> 00:17:45.250
这些权衡总是表明

00:17:42.130 --> 00:17:46.540
上升，因为您得到的Rupert会减少，但是

00:17:45.250 --> 00:17:50.890
另一方面，你也会变矮

00:17:46.540 --> 00:17:52.480
摆姿势，但是如果将最大DC设置为

00:17:50.890 --> 00:17:54.880
最臭的还不够，您将其设置为

00:17:52.480 --> 00:17:57.250
您要在这里值200我正在运行

00:17:54.880 --> 00:18:00.670
默认但这些姿势似乎仍然

00:17:57.250 --> 00:18:02.260
有点太久了，我们有一个220 170 

00:18:00.670 --> 00:18:06.130
然后我们有一个非常慢的

00:18:02.260 --> 00:18:07.600
 400我首先要看的是什么

00:18:06.130 --> 00:18:09.460
这种力量是因为你需要

00:18:07.600 --> 00:18:11.020
为了解决这个问题而了解

00:18:09.460 --> 00:18:13.210
问题，我们必须了解发生了什么

00:18:11.020 --> 00:18:15.610
否则我们会请客人在

00:18:13.210 --> 00:18:17.800
一堆JVM标志在之后随机尝试

00:18:15.610 --> 00:18:21.550
有些东西似乎有效，那将不会

00:18:17.800 --> 00:18:23.080
导致任何好处，所以再次开始寻找

00:18:21.550 --> 00:18:24.310
在这里的帖子中，我们看到了一些

00:18:23.080 --> 00:18:27.280
我们显然有不同的力量

00:18:24.310 --> 00:18:29.020
有一个燕姿势一个混合职位和一个

00:18:27.280 --> 00:18:30.370
完整的姿势，我们将要看

00:18:29.020 --> 00:18:32.860
他们反过来看看我们能做什么

00:18:30.370 --> 00:18:34.330
关于这些问题，所以从我们开始

00:18:32.860 --> 00:18:36.700
会看到更多关于

00:18:34.330 --> 00:18:38.530
联合姿势和这个年轻的职位

00:18:36.700 --> 00:18:40.480
显然运行了太长时间

00:18:38.530 --> 00:18:42.550
其他20毫秒，而200毫秒

00:18:40.480 --> 00:18:44.710
他们不是我们的比目鱼问题

00:18:42.550 --> 00:18:46.420
必须先记住我们测量的步骤

00:18:44.710 --> 00:18:48.970
我们已经测量并确定了一个日期

00:18:46.420 --> 00:18:50.500
然后我们需要了解为什么

00:18:48.970 --> 00:18:52.930
这发生了什么事

00:18:50.500 --> 00:18:55.900
 JVM当我们掌握了这些知识后， 

00:18:52.930 --> 00:18:57.760
可以解决问题，但是我们可以

00:18:55.900 --> 00:19:00.250
在这种情况下有足够的帮助或

00:18:57.760 --> 00:19:01.390
我们知道的不，我不认为，所以我们

00:19:00.250 --> 00:19:04.510
需要知道一点流动青年

00:19:01.390 --> 00:19:06.250
连接主义者，这是怎么回事g1 

00:19:04.510 --> 00:19:08.950
将堆分成多个区域

00:19:06.250 --> 00:19:09.850
你有伊甸园地区和生存

00:19:08.950 --> 00:19:11.950
地区这

00:19:09.850 --> 00:19:13.780
一起被称为青年地区

00:19:11.950 --> 00:19:15.100
堆上会有免费的见证人

00:19:13.780 --> 00:19:19.120
里面没有物体

00:19:15.100 --> 00:19:20.980
河水也是老区的一个对象

00:19:19.120 --> 00:19:24.340
通过分配到

00:19:20.980 --> 00:19:25.780
伊甸园地区后来成为约翰

00:19:24.340 --> 00:19:27.669
收集发生并且可以生存

00:19:25.780 --> 00:19:30.070
巨大的收藏将被复制到

00:19:27.669 --> 00:19:31.780
一个生存区域，如果生存

00:19:30.070 --> 00:19:34.480
它将收集多个纱线

00:19:31.780 --> 00:19:38.830
最终被提升为

00:19:34.480 --> 00:19:41.530
在看堆之前的旧区域

00:19:38.830 --> 00:19:43.570
庞大的收藏，您会发现

00:19:41.530 --> 00:19:46.450
我们的伊甸园地区里面有物体

00:19:43.570 --> 00:19:48.130
他们以及生存地区

00:19:46.450 --> 00:19:51.309
橙色物体是活的，那些是

00:19:48.130 --> 00:19:53.020
实际使用中的，因此g1将

00:19:51.309 --> 00:19:54.760
在乙醚中找到这个橙色的物体

00:19:53.020 --> 00:19:57.280
生存到达了活着的

00:19:54.760 --> 00:20:00.250
它将紧凑地复制到一个免费的

00:19:57.280 --> 00:20:02.169
区域并更新所有参考，以便

00:20:00.250 --> 00:20:06.640
当世界再次变得理智

00:20:02.169 --> 00:20:10.210
作业申请恢复时的JVM 

00:20:06.640 --> 00:20:11.919
 f是自由区域，因此我们复制

00:20:10.210 --> 00:20:14.350
将活动对象紧凑地复制到

00:20:11.919 --> 00:20:17.140
自由区域，之后何时是

00:20:14.350 --> 00:20:19.000
复制完成，我们将因此

00:20:17.140 --> 00:20:21.460
将自由区域变成一个

00:20:19.000 --> 00:20:23.110
生存区和伊甸园地区

00:20:21.460 --> 00:20:25.690
变成三个区域，可以一次

00:20:23.110 --> 00:20:27.549
再次用于分配，如您所见

00:20:25.690 --> 00:20:29.140
从一个自由区域开始

00:20:27.549 --> 00:20:30.669
紧凑地复制了四个区域

00:20:29.140 --> 00:20:33.460
进入一个自由区域，现在我们有了

00:20:30.669 --> 00:20:36.010
四个空闲区域，所以我们拥有的堆是

00:20:33.460 --> 00:20:39.880
更密集，更紧凑，因此我们可以重复使用

00:20:36.010 --> 00:20:42.340
新分配的内存，因此

00:20:39.880 --> 00:20:44.289
看这个帖子，我们现在有

00:20:42.340 --> 00:20:46.659
了解发生了什么

00:20:44.289 --> 00:20:48.669
更多和提里奥收集，但我们

00:20:46.659 --> 00:20:50.260
没有足够的数据，在这种情况下，我们

00:20:48.669 --> 00:20:53.200
否，所以我们需要启用更多日志记录

00:20:50.260 --> 00:20:56.049
现在我要说的是-X log G store 

00:20:53.200 --> 00:20:58.210
这意味着我要滞后记录所有标签

00:20:56.049 --> 00:21:01.030
这包括在IDC中，所以可能

00:20:58.210 --> 00:21:03.159
是包括GC的日志消息，而且

00:21:01.030 --> 00:21:05.650
其他标签，现在我想要所有行

00:21:03.159 --> 00:21:07.150
带有GC和其他可能的标签

00:21:05.650 --> 00:21:09.940
在他们里面，让我们看看我们得到了什么

00:21:07.150 --> 00:21:11.409
当我们做简单的商店哇，现在我们有一个

00:21:09.940 --> 00:21:15.039
更多信息，在这里我们可以看到

00:21:11.409 --> 00:21:16.570
 DC ID可以帮助我们，因此我们可以看到

00:21:15.039 --> 00:21:18.730
哪些行属于哪个垃圾

00:21:16.570 --> 00:21:21.790
集合，这些都属于GC 

00:21:18.730 --> 00:21:22.540
 154我们可以看到我们还有约翰

00:21:21.790 --> 00:21:23.140
力

00:21:22.540 --> 00:21:25.450
哪里

00:21:23.140 --> 00:21:27.400
事情显然为此18名工人

00:21:25.450 --> 00:21:30.190
疏散，所以事情很多

00:21:27.400 --> 00:21:31.720
与他们不同的面孔平行

00:21:30.190 --> 00:21:33.430
显然，我们已经预先疏散了

00:21:31.720 --> 00:21:35.860
集合集撤离的集合集

00:21:33.430 --> 00:21:38.200
然后撤离后接受，然后一些

00:21:35.860 --> 00:21:40.240
其他时候我们可以看到辐射

00:21:38.200 --> 00:21:43.450
收集之前分发

00:21:40.240 --> 00:21:45.100
收集后，我们有三百

00:21:43.450 --> 00:21:47.350
和该区域之前的14个

00:21:45.100 --> 00:21:48.910
垃圾收集，现在我们知道

00:21:47.350 --> 00:21:50.710
吃光彩，我们会紧凑地复制

00:21:48.910 --> 00:21:52.360
这些物体分为三个区域

00:21:50.710 --> 00:21:55.780
后来都是塞拉利昂人

00:21:52.360 --> 00:21:57.430
变得自由，我们有34个生存时间

00:21:55.780 --> 00:21:59.170
今天要去的地区

00:21:57.430 --> 00:22:01.660
收集以及完成后

00:21:59.170 --> 00:22:03.850
数据位于32个生存区域， 

00:22:01.660 --> 00:22:05.290
旧的光辉从四个增加

00:22:03.850 --> 00:22:05.590
一百十五至四百四十

00:22:05.290 --> 00:22:07.420
九

00:22:05.590 --> 00:22:08.950
我们还获得了有关

00:22:07.420 --> 00:22:11.530
在学生中，我在一个空间中

00:22:08.950 --> 00:22:13.840
今天不谈那个，最后我们

00:22:11.530 --> 00:22:15.460
获取之前和之后的堆使用情况

00:22:13.840 --> 00:22:18.370
职位的能力和时间

00:22:15.460 --> 00:22:20.650
本身，所以如果我们仔细观察一下

00:22:18.370 --> 00:22:22.930
在这里，我们看到这张脸

00:22:20.650 --> 00:22:25.870
撤离集合几乎需要全部

00:22:22.930 --> 00:22:29.410
我们看到的时间花了52分

00:22:25.870 --> 00:22:31.480
 54毫秒中有5毫秒

00:22:29.410 --> 00:22:34.140
似乎增加了

00:22:31.480 --> 00:22:38.320
在旧的地区，我们也在使用

00:22:34.140 --> 00:22:39.850
相当多的生存区域

00:22:38.320 --> 00:22:41.440
撤离收藏集需要时间

00:22:39.850 --> 00:22:43.870
九十年代有一个近邻

00:22:41.440 --> 00:22:45.940
职位员的百分比帮助使人显得

00:22:43.870 --> 00:22:48.220
为了生存，我们必须使用34个新的

00:22:45.940 --> 00:22:50.830
算法和四十二个新的生存

00:22:48.220 --> 00:22:52.480
区域，但要真正触底

00:22:50.830 --> 00:22:54.910
我们需要更多的信息来

00:22:52.480 --> 00:22:57.640
终于看到这里发生了什么，所以我们

00:22:54.910 --> 00:23:01.240
将在所有日志上启用调试级别

00:22:57.640 --> 00:23:02.530
包括潮汐GC在内的各行，让我们来看一下

00:23:01.240 --> 00:23:03.850
我们得到的我们会得到很多

00:23:02.530 --> 00:23:06.730
输出这不是你想要的东西

00:23:03.850 --> 00:23:08.680
在生产中运行，您将快速填充

00:23:06.730 --> 00:23:10.480
记录很多信息，但是如果您是

00:23:08.680 --> 00:23:12.700
调优并深入到特定

00:23:10.480 --> 00:23:15.220
问题，这可能会有所帮助

00:23:12.700 --> 00:23:16.780
所以我只复制日志的一部分

00:23:15.220 --> 00:23:19.090
这里有一堆更多的信息

00:23:16.780 --> 00:23:20.950
关于GC，但现在我们将看到所有

00:23:19.090 --> 00:23:23.200
相中列出的子相下的相

00:23:20.950 --> 00:23:25.540
日志，我们将看到那张脸

00:23:23.200 --> 00:23:27.580
花了很多时间是OB复制，现在

00:23:25.540 --> 00:23:29.440
你看到那张脸标有意思

00:23:27.580 --> 00:23:31.720
这是因为所有这些的最大平均值

00:23:29.440 --> 00:23:34.930
在并行和并发运行

00:23:31.720 --> 00:23:36.440
因此，平均时间是

00:23:34.930 --> 00:23:38.420
工人花你做

00:23:36.440 --> 00:23:40.610
大约是四到九点

00:23:38.420 --> 00:23:41.870
毫秒和最多时间的工作人员

00:23:40.610 --> 00:23:43.760
又花了五十分钟，所以

00:23:41.870 --> 00:23:46.610
显然，该职位是花在做OB 

00:23:43.760 --> 00:23:49.370
复制，那么我们能得出什么很好的结论

00:23:46.610 --> 00:23:51.470
复制对象需要时间，但为什么G 

00:23:49.370 --> 00:23:57.680
一个有两个副本，所以有很多对象

00:23:51.470 --> 00:23:59.480
这个姿势很好，大多数物体都应该

00:23:57.680 --> 00:24:02.960
最年轻的物体或应该是

00:23:59.480 --> 00:24:04.670
死了，这是基于假设

00:24:02.960 --> 00:24:07.460
大多数物体要么早逝，要么死亡

00:24:04.670 --> 00:24:10.280
他们如果活了很长时间

00:24:07.460 --> 00:24:12.260
不是真正的免费应用程序

00:24:10.280 --> 00:24:14.660
必须调整约翰地区的数量

00:24:12.260 --> 00:24:17.330
你可以使用的你可能已经设定

00:24:14.660 --> 00:24:19.940
 g1中出现的标志CG一个新尺寸

00:24:17.330 --> 00:24:21.980
最大新尺寸百分比，也许您有

00:24:19.940 --> 00:24:24.260
有关您的应用程序的更多信息

00:24:21.980 --> 00:24:26.480
比g1可以推断出来，因为我的工效学

00:24:24.260 --> 00:24:27.590
引擎将尝试找到最佳选择

00:24:26.480 --> 00:24:29.930
在这里很有价值，但您可能会知道一些

00:24:27.590 --> 00:24:31.460
你想要want子

00:24:29.930 --> 00:24:33.620
知道我会产生很大的变化

00:24:31.460 --> 00:24:35.450
报告或其他内容，一旦报告

00:24:33.620 --> 00:24:38.120
完成所有基本的工作就不会死，但是如果

00:24:35.450 --> 00:24:38.570
 g1决定在报表生成之前暂停

00:24:38.120 --> 00:24:40.250
完成

00:24:38.570 --> 00:24:41.630
下面可能有一个活物

00:24:40.250 --> 00:24:44.870
如果您只是要复制

00:24:41.630 --> 00:24:47.330
增加约翰地区的数量

00:24:44.870 --> 00:24:49.520
一点物体将有更多时间

00:24:47.330 --> 00:24:55.550
死亡，将减少活物

00:24:49.520 --> 00:24:58.580
富士想复制前进，我们将

00:24:55.550 --> 00:25:00.110
稍微看看混合姿势

00:24:58.580 --> 00:25:02.360
好东西是你现在

00:25:00.110 --> 00:25:04.340
对年轻人有更好的了解

00:25:02.360 --> 00:25:06.200
您可以带来这些知识的收藏

00:25:04.340 --> 00:25:08.990
进入混合收藏，因为它们

00:25:06.200 --> 00:25:10.490
非常非常相似，区别是

00:25:08.990 --> 00:25:13.640
混合收集同时收集

00:25:10.490 --> 00:25:16.100
年轻人和老年人地区以及我们

00:25:13.640 --> 00:25:17.600
已经见过的年轻地区可以

00:25:16.100 --> 00:25:19.310
全部消失

00:25:17.600 --> 00:25:22.310
年轻的读物可能会受到限制

00:25:19.310 --> 00:25:24.110
 g1最大新大小百分比，但是

00:25:22.310 --> 00:25:26.630
旧的地区你可以绑定数字吗

00:25:24.110 --> 00:25:28.160
我们需要摆姿势的旧区域

00:25:26.630 --> 00:25:29.270
了解更多有关混合的信息

00:25:28.160 --> 00:25:32.420
为了回答一个集合

00:25:29.270 --> 00:25:33.920
问题，所以如果你看看这个堆

00:25:32.420 --> 00:25:35.690
幻灯片在这里，我们有一堆伊甸园

00:25:33.920 --> 00:25:38.180
它们之间为橙色水平的区域

00:25:35.690 --> 00:25:40.610
我们将两个旧区域分为三个

00:25:38.180 --> 00:25:43.790
地区和旧半径是一些

00:25:40.610 --> 00:25:44.990
橙色物体的活动

00:25:43.790 --> 00:25:47.630
混合收藏

00:25:44.990 --> 00:25:49.250
选择所有的年轻地区

00:25:47.630 --> 00:25:49.430
即使是幸存者，一旦他们总是不得不

00:25:49.250 --> 00:25:52.130
是

00:25:49.430 --> 00:25:55.730
收集对立的和一个或多个旧的

00:25:52.130 --> 00:25:57.590
地区，并且肯定会做同样的事情

00:25:55.730 --> 00:25:59.120
就像一个巨大的收藏

00:25:57.590 --> 00:26:02.120
对象将被紧凑地复制到

00:25:59.120 --> 00:26:04.520
三个区域，然后是

00:26:02.120 --> 00:26:06.380
这个，然后是老弧度， 

00:26:04.520 --> 00:26:09.440
收集的杨辉

00:26:06.380 --> 00:26:11.750
成为自由地区，所以再次

00:26:09.440 --> 00:26:14.590
类似的代码实际上几乎是

00:26:11.750 --> 00:26:17.570
对于年轻和混合的收藏也是如此

00:26:14.590 --> 00:26:20.060
因此g1选择了一个集合集

00:26:17.570 --> 00:26:22.040
我们可以绑定的垃圾部分的区域

00:26:20.060 --> 00:26:25.220
 g1最大新大小的收藏集

00:26:22.040 --> 00:26:28.460
 ％，我们可以用g1绑定旧部分

00:26:25.220 --> 00:26:30.380
混合GC计数目标g1混合此帐户

00:26:28.460 --> 00:26:33.800
目标默认为8，这意味着

00:26:30.380 --> 00:26:36.380
贾将努力收集所有旧的

00:26:33.800 --> 00:26:38.300
 8个混合集合中的区域，如果

00:26:36.380 --> 00:26:40.130
您正在寻找更低的延迟时间

00:26:38.300 --> 00:26:42.290
也许是一种低价值的方法

00:26:40.130 --> 00:26:44.030
您有800个旧区域，因为它们

00:26:42.290 --> 00:26:45.530
堆很大，你想

00:26:44.030 --> 00:26:47.900
摆出你不想的姿势

00:26:45.530 --> 00:26:49.820
您想要复制每个帖子一些数据

00:26:47.900 --> 00:26:52.100
在许多混合中分散工作

00:26:49.820 --> 00:26:54.260
如果您有800个旧的收藏

00:26:52.100 --> 00:26:57.290
地区，您有一份混合GC合同

00:26:54.260 --> 00:26:59.330
之八，您可能会得到大约

00:26:57.290 --> 00:27:01.670
 100个旧区域允许收集

00:26:59.330 --> 00:27:04.880
大部分地区都比较饱满

00:27:01.670 --> 00:27:07.280
可能太多了，您会看到两种方法

00:27:04.880 --> 00:27:09.380
漫长的过程，这是一个好兆头

00:27:07.280 --> 00:27:13.430
您可能需要增加混合GC计数

00:27:09.380 --> 00:27:15.560
定位到更高的价值，您也可以

00:27:13.430 --> 00:27:18.170
告诉你一个不必做

00:27:15.560 --> 00:27:20.690
这么多，似乎有点奇怪，但

00:27:18.170 --> 00:27:24.020
您可以尽快减少与

00:27:20.690 --> 00:27:29.330
标志，例如mix GC活动阈值

00:27:24.020 --> 00:27:31.940
百分比，默认情况下是85， 

00:27:29.330 --> 00:27:33.860
标志会告诉g1去考虑

00:27:31.940 --> 00:27:35.510
收集旧区域，因为如果

00:27:33.860 --> 00:27:37.640
该地区主要是现场直播

00:27:35.510 --> 00:27:38.900
对象，然后我们只是随机播放

00:27:37.640 --> 00:27:41.300
堆中的数据

00:27:38.900 --> 00:27:43.280
移动物体有一个是旧的

00:27:41.300 --> 00:27:44.900
从一个地区生活到另一个地区，依此类推

00:27:43.280 --> 00:27:46.550
我们还没有真正获得的幻灯片

00:27:44.900 --> 00:27:48.350
任何我想说的都是这些

00:27:46.550 --> 00:27:50.540
集合是要收集多个

00:27:48.350 --> 00:27:52.940
他们之间生活着几个地区

00:27:50.540 --> 00:27:54.620
分成一个区域，这样我们就可以重复使用

00:27:52.940 --> 00:27:56.840
其他区域，但如果一个区域是

00:27:54.620 --> 00:28:01.400
现在快要满了

00:27:56.840 --> 00:28:03.980
单体背和g1混合潜水是吗

00:28:01.400 --> 00:28:06.470
要混合，就像阈值％告诉

00:28:03.980 --> 00:28:08.030
 g1可以考虑的阈值

00:28:06.470 --> 00:28:11.030
收集旧区域，默认情况下

00:28:08.030 --> 00:28:13.610
如果减少此数量，则已满85％ 

00:28:11.030 --> 00:28:16.760
表示g1将跳过的值

00:28:13.610 --> 00:28:19.870
如果说65％或55，则收集

00:28:16.760 --> 00:28:23.420
则g1将跳过收集

00:28:19.870 --> 00:28:25.010
那些古老的地区，但这可能会导致

00:28:23.420 --> 00:28:27.490
在更多的堆使用中，我们将离开

00:28:25.010 --> 00:28:30.910
更多的垃圾躺在堆上

00:28:27.490 --> 00:28:34.160
另一个标志是g1堆浪费百分比

00:28:30.910 --> 00:28:36.650
这几乎也意味着名字

00:28:34.160 --> 00:28:37.730
允许堆上有更多垃圾，所以这

00:28:36.650 --> 00:28:39.740
是g1的目标

00:28:37.730 --> 00:28:41.930
它说我可以离开

00:28:39.740 --> 00:28:44.150
默认情况下5％的垃圾散落在

00:28:41.930 --> 00:28:45.500
如果还可以的话，堆更多的垃圾

00:28:44.150 --> 00:28:47.420
在堆上，这意味着甚至可以做

00:28:45.500 --> 00:28:48.920
减少工作量，您可以增加它

00:28:47.420 --> 00:28:51.380
值，但再次警告这将

00:28:48.920 --> 00:28:52.760
导致更多的堆使用，我们再次

00:28:51.380 --> 00:28:57.190
开始看到你的这种交易

00:28:52.760 --> 00:28:59.480
较短的姿势，但可能会占用更多的空间

00:28:57.190 --> 00:29:02.330
好吧，我们挽救了最糟糕的一个

00:28:59.480 --> 00:29:04.580
所以在这里我们看到一个完整的剪辑姿势， 

00:29:02.330 --> 00:29:06.740
显然这花了很长时间

00:29:04.580 --> 00:29:09.260
时间是200的错字故事

00:29:06.740 --> 00:29:11.600
 400这里，这似乎不太好

00:29:09.260 --> 00:29:13.160
如果看到一个完整的，这是怎么回事

00:29:11.600 --> 00:29:15.290
这是一个不好的迹象

00:29:13.160 --> 00:29:17.990
不应该发生，这是一个失败

00:29:15.290 --> 00:29:20.510
 d1模式，显然没有运行

00:29:17.990 --> 00:29:22.070
最理想的是对您来说很重要

00:29:20.510 --> 00:29:24.470
了解为什么要完整收集

00:29:22.070 --> 00:29:26.450
发生的好消息是

00:29:24.470 --> 00:29:28.850
通常很容易找出哪里充满

00:29:26.450 --> 00:29:30.530
收集发生并解决它，但是

00:29:28.850 --> 00:29:32.210
如果一个

00:29:30.530 --> 00:29:34.970
完整的收藏会显示在您的日志中，或

00:29:32.210 --> 00:29:36.020
在您录制的那一天，您需要

00:29:34.970 --> 00:29:39.370
收集对正在发生的事情的了解

00:29:36.020 --> 00:29:42.410
亮，因为这又是一种失败模式

00:29:39.370 --> 00:29:44.330
所以在日志中，您将看到帖子

00:29:42.410 --> 00:29:47.150
底部的完整文章以粗体显示

00:29:44.330 --> 00:29:49.460
如果你只是早一点看

00:29:47.150 --> 00:29:51.110
进入前几行，您会注意到

00:29:49.460 --> 00:29:54.170
前约翰的这句话

00:29:51.110 --> 00:29:56.360
收集到太空用尽了什么

00:29:54.170 --> 00:30:00.110
这意味着在约翰收藏期间

00:29:56.360 --> 00:30:02.660
正如我们所见，g1将尝试紧凑

00:30:00.110 --> 00:30:04.850
将所有活动对象复制到免费

00:30:02.660 --> 00:30:07.730
该地区的生活水平较低

00:30:04.850 --> 00:30:09.530
对象在年轻地区而不是

00:30:07.730 --> 00:30:12.560
堆上还有那么多空闲区域

00:30:09.530 --> 00:30:14.210
好吧，我们将得到一个太空人

00:30:12.560 --> 00:30:15.920
那意味着战争

00:30:14.210 --> 00:30:20.240
复制活动对象的空间

00:30:15.920 --> 00:30:22.400
因此，伊甸园地区和

00:30:20.240 --> 00:30:24.020
即将到来的生存地区将只是

00:30:22.400 --> 00:30:26.540
变成我们不会的旧地区

00:30:24.020 --> 00:30:28.790
几乎释放了所有内存，并且

00:30:26.540 --> 00:30:32.960
结果我们最终会很快

00:30:28.790 --> 00:30:34.790
遇到完整的收藏后， 

00:30:32.960 --> 00:30:37.340
出来问你自己我没做什么

00:30:34.790 --> 00:30:39.350
我什至在这里做一个混合的收藏

00:30:37.340 --> 00:30:40.790
如果我们再看一次，有几个

00:30:39.350 --> 00:30:42.890
那里的老城区我们不能

00:30:40.790 --> 00:30:46.670
收集了一些，释放了一些

00:30:42.890 --> 00:30:49.220
我们必须了解的内存和重用

00:30:46.670 --> 00:30:50.570
关于g1的更多回答问题

00:30:49.220 --> 00:30:52.070
我了解我们没有做什么

00:30:50.570 --> 00:30:56.060
做了一个垃圾收集，而不是一个旧的

00:30:52.070 --> 00:30:57.920
收集或混合收集等

00:30:56.060 --> 00:30:59.450
以前的幻灯片我们只看过

00:30:57.920 --> 00:31:01.190
隐约暗示好了

00:30:59.450 --> 00:31:02.930
是这个橙色的活物，但永远不会

00:31:01.190 --> 00:31:04.700
真的告诉你为什么他们在那里

00:31:02.930 --> 00:31:07.940
你甚至发现了生活是什么， 

00:31:04.700 --> 00:31:10.310
什么不是活着，所以J人找到了活着

00:31:07.940 --> 00:31:12.170
每次都在年轻地区的物体

00:31:10.310 --> 00:31:14.060
是否有一个巨大的收藏

00:31:12.170 --> 00:31:16.160
通常在丛林中有一些活物

00:31:14.060 --> 00:31:18.650
地区，所以这是非常快的

00:31:16.160 --> 00:31:21.890
但是，对于旧的

00:31:18.650 --> 00:31:24.310
经常有很多g1的地区

00:31:21.890 --> 00:31:27.740
我们将同时找到所有对象

00:31:24.310 --> 00:31:29.420
这可以称为并发

00:31:27.740 --> 00:31:31.430
标记，可能需要一些时间

00:31:29.420 --> 00:31:32.960
特别是如果你有一大堆

00:31:31.430 --> 00:31:34.910
好消息是，这不会停止

00:31:32.960 --> 00:31:36.770
您的求职申请正在运行

00:31:34.910 --> 00:31:39.170
与工作同时进行

00:31:36.770 --> 00:31:41.780
应用程序正在运行，但是问题

00:31:39.170 --> 00:31:44.180
是贾明无法收集一个地区

00:31:41.780 --> 00:31:46.340
没有亮度信息，如果没有

00:31:44.180 --> 00:31:48.650
知道哪些物体是活的还是死的

00:31:46.340 --> 00:31:50.540
不知道要回收哪个空间

00:31:48.650 --> 00:31:52.700
混合连接需要并发

00:31:50.540 --> 00:31:55.310
标记完成，为什么会出现问题

00:31:52.700 --> 00:31:56.810
让我们看一个例子

00:31:55.310 --> 00:31:59.660
您的应用程序启动后，您将

00:31:56.810 --> 00:32:02.540
将对象分配给伊甸地区

00:31:59.660 --> 00:32:03.740
你分配越来越多，你要去

00:32:02.540 --> 00:32:06.620
开始填充越来越多

00:32:03.740 --> 00:32:07.970
成分和d1现在决定

00:32:06.620 --> 00:32:09.230
现在是暂停你的好时机

00:32:07.970 --> 00:32:11.990
充满了数百万个地区

00:32:09.230 --> 00:32:14.330
还有你的年轻收藏

00:32:11.990 --> 00:32:17.570
在那期间所有年轻的活物

00:32:14.330 --> 00:32:20.240
发布它会紧凑地将它们放入

00:32:17.570 --> 00:32:21.320
如我们所见和您一样生存

00:32:20.240 --> 00:32:22.580
在时间轴上猜这是一个

00:32:21.320 --> 00:32:26.110
您的应用程序所在的小职位

00:32:22.580 --> 00:32:28.779
发布，我将继续运行

00:32:26.110 --> 00:32:30.429
随着时间的流逝，越来越多的

00:32:28.779 --> 00:32:32.769
这些年轻的收藏将会出现， 

00:32:30.429 --> 00:32:34.510
最终我们开始生存的对象

00:32:32.769 --> 00:32:37.929
越来越多的年轻收藏，并将

00:32:34.510 --> 00:32:40.000
再次被提升到旧的光彩

00:32:37.929 --> 00:32:41.440
持续不断的停顿，现在

00:32:40.000 --> 00:32:43.840
旧的地区开始充满

00:32:41.440 --> 00:32:45.309
同样，但从g1的角度来看

00:32:43.840 --> 00:32:46.480
被满满的东西

00:32:45.309 --> 00:32:48.970
信徒们真的不能说

00:32:46.480 --> 00:32:51.340
关于现场直播的不同之处

00:32:48.970 --> 00:32:52.750
现在在旧区域的Adobe Act中

00:32:51.340 --> 00:32:54.909
现在是开始连贯的好时机

00:32:52.750 --> 00:32:57.490
标记，因为我们需要并发标记

00:32:54.909 --> 00:33:00.070
在我们用尽免费之前完成

00:32:57.490 --> 00:33:01.480
堆上的区域，所以在这里您可以看到

00:33:00.070 --> 00:33:04.750
并发线程被踢

00:33:01.480 --> 00:33:06.700
在时间轴上关闭并且正在运行

00:33:04.750 --> 00:33:08.049
在假期的同时

00:33:06.700 --> 00:33:10.480
运行，所以那里没有暂停

00:33:08.049 --> 00:33:12.070
可能会有年轻的收藏

00:33:10.480 --> 00:33:14.409
在并发上

00:33:12.070 --> 00:33:15.970
标记非常好，这些

00:33:14.409 --> 00:33:17.919
庞大的收藏可能会促进更多的发展， 

00:33:15.970 --> 00:33:19.990
更多的物体变成旧弧度，所以现在

00:33:17.919 --> 00:33:22.120
全场热越来越大， 

00:33:19.990 --> 00:33:23.710
希望并发标记即将

00:33:22.120 --> 00:33:26.080
即将完成，以便我们可以回收内存

00:33:23.710 --> 00:33:29.559
来自旧地区，幸运的是

00:33:26.080 --> 00:33:31.450
刚刚完成，所以现在并发

00:33:29.559 --> 00:33:32.919
马克·吉娃（jeeva）完蛋了

00:33:31.450 --> 00:33:35.320
它需要的活动信息，以及

00:33:32.919 --> 00:33:38.590
发现啊哈，只有几个

00:33:35.320 --> 00:33:40.720
每个旧区域的Excel，如果

00:33:38.590 --> 00:33:43.000
我们回到有问题的帖子

00:33:40.720 --> 00:33:45.309
很长时间，我们在底部看到

00:33:43.000 --> 00:33:46.960
有长时间的完整发布通知

00:33:45.309 --> 00:33:48.850
失败，我们再往前看

00:33:46.960 --> 00:33:51.100
两个基本的油烟机好吧，他们

00:33:48.850 --> 00:33:53.200
没有足够的生存区域

00:33:51.100 --> 00:33:55.149
纱线收藏要共同发布到

00:33:53.200 --> 00:33:57.100
如果我们进一步向上看，我们会看到

00:33:55.149 --> 00:34:00.309
哦，并发周期开始了

00:33:57.100 --> 00:34:01.720
并发标记开始了，但是

00:34:00.309 --> 00:34:03.820
重要的是我们要做的

00:34:01.720 --> 00:34:05.850
在日志中看不到，我们应该不要

00:34:03.820 --> 00:34:08.020
并发周期看完

00:34:05.850 --> 00:34:10.450
并发标记没有时间

00:34:08.020 --> 00:34:11.980
完成它没有按时完成g1 

00:34:10.450 --> 00:34:13.750
无法获得母狮信息

00:34:11.980 --> 00:34:16.149
需要收集旧地区和

00:34:13.750 --> 00:34:17.710
因此，当他们不再自由时

00:34:16.149 --> 00:34:22.780
可用的读数必须回落

00:34:17.710 --> 00:34:24.879
到故障模式下的完整集合

00:34:22.780 --> 00:34:27.129
盖尔九我们引入了自适应排序

00:34:24.879 --> 00:34:30.010
并发周期，这意味着我们

00:34:27.129 --> 00:34:31.659
将由我们收集的数据驱动

00:34:30.010 --> 00:34:35.260
在您的应用程序运行时如何

00:34:31.659 --> 00:34:36.819
它的行为和我们的政策，我们将

00:34:35.260 --> 00:34:38.889
启动并发标记线程

00:34:36.819 --> 00:34:39.940
希望这是由

00:34:38.889 --> 00:34:42.789
经济学和

00:34:39.940 --> 00:34:44.139
但你可能会说我真的

00:34:42.789 --> 00:34:47.649
对此我真的很想

00:34:44.139 --> 00:34:49.389
及时完成，所以如果增加g1 

00:34:47.649 --> 00:34:52.539
保留百分比，默认为10 

00:34:49.389 --> 00:34:54.909
说好吧，我知道你可以

00:34:52.539 --> 00:34:56.559
计算得很好，何时存储

00:34:54.909 --> 00:34:58.480
汽车市场，但请留意

00:34:56.559 --> 00:35:00.579
三个区域的末端，以便您

00:34:58.480 --> 00:35:02.650
确实确实按时完成，如果

00:35:00.579 --> 00:35:04.930
卡片标记期间发生了某些事情

00:35:02.650 --> 00:35:06.910
例如，您在以下位置获得博客文章

00:35:04.930 --> 00:35:09.249
曲棍球新闻，突然之间你也有

00:35:06.910 --> 00:35:10.809
您网站的访问者很多，很多

00:35:09.249 --> 00:35:13.630
的对象被分配为

00:35:10.809 --> 00:35:16.509
结果你可能需要一点

00:35:13.630 --> 00:35:18.519
稍大的缓冲区，您也可以

00:35:16.509 --> 00:35:20.319
增加堆大小

00:35:18.519 --> 00:35:22.749
同时标记更多的净空和

00:35:20.319 --> 00:35:26.259
遍历

00:35:22.749 --> 00:35:29.049
堆非常重要，如果您这样做

00:35:26.259 --> 00:35:31.239
不进行分析就得到完整的收藏

00:35:29.049 --> 00:35:33.839
只是为什么会发生，而且

00:35:31.239 --> 00:35:35.759
该照片集的结果

00:35:33.839 --> 00:35:38.619
特别是如果完整的收藏

00:35:35.759 --> 00:35:40.509
没有释放任何内存，这意味着

00:35:38.619 --> 00:35:42.460
要么堆太小，要么

00:35:40.509 --> 00:35:44.559
而是你有太多的

00:35:42.460 --> 00:35:47.680
没有大小的堆的活动对象

00:35:44.559 --> 00:35:49.630
您可能在您的内存泄漏

00:35:47.680 --> 00:35:51.730
应用程序填满了我们所有人

00:35:49.630 --> 00:35:55.089
是学生绒毛，但你有些

00:35:51.730 --> 00:35:56.890
坚持他们在Java中寻找

00:35:55.089 --> 00:36:00.789
任务控制在这里我们看到一个例子

00:35:56.890 --> 00:36:03.940
引入的自动化分析

00:36:00.789 --> 00:36:06.430
詹姆斯的6.0，我们看到了完整

00:36:03.940 --> 00:36:08.920
集合的严重程度为100 

00:36:06.430 --> 00:36:11.650
分数意味着这是严重的

00:36:08.920 --> 00:36:13.059
问题，它也说g1垃圾

00:36:11.650 --> 00:36:15.160
集合将使用，但JVM也将使用

00:36:13.059 --> 00:36:18.130
这里的旧收藏多种多样，我们看到了

00:36:15.160 --> 00:36:20.739
那里GC停滞了，你

00:36:18.130 --> 00:36:23.109
如果您认为这需要调查一下

00:36:20.739 --> 00:36:25.269
您可能有内存泄漏，并且

00:36:23.109 --> 00:36:26.650
不确定是否看到结果

00:36:25.269 --> 00:36:29.049
大部分堆都装满了

00:36:26.650 --> 00:36:33.849
真的不应该是鲁布克斯吗

00:36:29.049 --> 00:36:36.430
转到JMC中的“分配”选项卡

00:36:33.849 --> 00:36:38.710
它将告诉您哪些对象具有

00:36:36.430 --> 00:36:40.329
被分配了哪种类型的

00:36:38.710 --> 00:36:42.999
给你堆栈的痕迹在哪里

00:36:40.329 --> 00:36:44.559
从中分配的那些对象

00:36:42.999 --> 00:36:49.089
进行深入分析并了解

00:36:44.559 --> 00:36:52.980
你为什么要堆满

00:36:49.089 --> 00:36:55.320
可能会产生记忆，所以我们看了看

00:36:52.980 --> 00:36:57.600
三种力量，我们使用

00:36:55.320 --> 00:36:59.640
在所有这些情况下，我们使用相同的方法

00:36:57.600 --> 00:37:02.730
使用日志记录或Java测量

00:36:59.640 --> 00:37:04.800
飞行记录仪，我们有了更好的

00:37:02.730 --> 00:37:05.970
了解它是如何工作的

00:37:04.800 --> 00:37:08.760
你们看了这个演讲

00:37:05.970 --> 00:37:10.320
或者您可以阅读该联盟准则，以便

00:37:08.760 --> 00:37:12.930
你知道发生了什么，为什么可以

00:37:10.320 --> 00:37:14.640
花了更长的停顿时间，然后我们

00:37:12.930 --> 00:37:19.830
调整以解决它并实现

00:37:14.640 --> 00:37:22.109
更好的性能，所以我们已经看到了一些

00:37:19.830 --> 00:37:24.210
关于免费属性吞吐量

00:37:22.109 --> 00:37:27.330
延迟和占用空间，我们研究了如何

00:37:24.210 --> 00:37:29.640
从JVM仪器获取数据

00:37:27.330 --> 00:37:31.740
看到了我们如何调整和调整

00:37:29.640 --> 00:37:35.550
降低所有球的潜伏期

00:37:31.740 --> 00:37:36.750
年轻的混合和全力，现在我们

00:37:35.550 --> 00:37:39.330
想谈一点

00:37:36.750 --> 00:37:42.300
社区，因此，如果您想参与

00:37:39.330 --> 00:37:43.830
我们是GCC开发人员，还有许多

00:37:42.300 --> 00:37:46.200
表演专家和人

00:37:43.830 --> 00:37:48.300
工作将随着收集而增加， 

00:37:46.200 --> 00:37:50.970
编排调整，请注册

00:37:48.300 --> 00:37:54.180
显示了Oprah上的主机端口GC费用

00:37:50.970 --> 00:37:56.220
 java.net，也感谢所有

00:37:54.180 --> 00:37:58.369
那些帮助更多人的人

00:37:56.220 --> 00:38:00.930
经验丰富的帮助新移民和

00:37:58.369 --> 00:38:02.220
分析我们看到的日志

00:38:00.930 --> 00:38:04.290
开发人员我们自己也是

00:38:02.220 --> 00:38:07.350
阅读了这份清单，但不幸的是我们

00:38:04.290 --> 00:38:10.050
可能并不总是有时间回答你

00:38:07.350 --> 00:38:13.230
也可以加入OpenJDK RC频道

00:38:10.050 --> 00:38:16.470
如果要聊天，可以在c.net上进行IRC 

00:38:13.230 --> 00:38:18.630
和我们在一起，而当你在黄色的时候

00:38:16.470 --> 00:38:21.240
一个请甲骨文开发人员来

00:38:18.630 --> 00:38:23.730
长链是坎耶·韦斯特，我通常是

00:38:21.240 --> 00:38:26.130
您可以在DevOps角落附近

00:38:23.730 --> 00:38:28.740
了解更多关于开放教育的java.net或

00:38:26.130 --> 00:38:30.780
在java上工作，如果你在推特上

00:38:28.740 --> 00:38:34.410
请在打开衰减处或在

00:38:30.780 --> 00:38:35.350
 Java和DevOps的工作人员，非常感谢

00:38:34.410 --> 00:38:40.340
许多

00:38:35.350 --> 00:38:40.340
 [掌声] 

