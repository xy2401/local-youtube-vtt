WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.159 --> 00:00:09.160
下午好，欢迎光临

00:00:05.580 --> 00:00:11.410
大家都非常欢迎

00:00:09.160 --> 00:00:13.720
从《星际迷航》中被错误引用

00:00:11.410 --> 00:00:16.090
是Java Jim，但不是我们所知道的

00:00:13.720 --> 00:00:17.800
因为原来的报价人

00:00:16.090 --> 00:00:19.090
喜欢说这是吉姆的生活，但不是

00:00:17.800 --> 00:00:21.789
我们知道这实际上是一个

00:00:19.090 --> 00:00:23.859
无论如何都会引用错误，但是无论如何

00:00:21.789 --> 00:00:27.730
这个演讲的背后是谈论

00:00:23.859 --> 00:00:30.579
关于lambda表达式等等

00:00:27.730 --> 00:00:32.070
我已经完成的议程是

00:00:30.579 --> 00:00:34.540
分为三部分

00:00:32.070 --> 00:00:37.840
第一部分，我们将讨论

00:00:34.540 --> 00:00:42.100
 lambda表达式的详细信息是谁

00:00:37.840 --> 00:00:43.420
这里使用的是JDK 8，好的，所以我们将

00:00:42.100 --> 00:00:44.860
谈谈lambda的细节

00:00:43.420 --> 00:00:46.720
从以下观点看

00:00:44.860 --> 00:00:50.380
它们是什么以及如何使用

00:00:46.720 --> 00:00:52.390
然后，我们将讨论一些有关

00:00:50.380 --> 00:00:54.400
 lambda表达式的性能

00:00:52.390 --> 00:00:58.180
因为它们的实施方式

00:00:54.400 --> 00:01:00.370
不完全是您所期望的

00:00:58.180 --> 00:01:02.860
所以有一些有趣的细节

00:01:00.370 --> 00:01:05.619
我们可以讨论何时

00:01:02.860 --> 00:01:08.590
 lambdas与

00:01:05.619 --> 00:01:10.359
等效的匿名内部类和

00:01:08.590 --> 00:01:14.799
然后是演讲的最后一部分

00:01:10.359 --> 00:01:17.049
我们可以带lambdas多远

00:01:14.799 --> 00:01:19.450
我们进入的是Java Jim， 

00:01:17.049 --> 00:01:21.159
不是我们所知道的和我的方式

00:01:19.450 --> 00:01:22.689
这种划分的一种是

00:01:21.159 --> 00:01:26.079
我描述的前两部分是

00:01:22.689 --> 00:01:29.020
有趣而有用的最后一部分是

00:01:26.079 --> 00:01:32.380
有趣但不太有用，因为

00:01:29.020 --> 00:01:33.850
没有人会用Java编程

00:01:32.380 --> 00:01:35.649
我将向您展示的方式

00:01:33.850 --> 00:01:40.539
如果您这样做，本演示文稿的结尾

00:01:35.649 --> 00:01:43.899
你做错了对吧，让我们

00:01:40.539 --> 00:01:46.779
然后从lambda表达式开始

00:01:43.899 --> 00:01:48.789
因为您使用的是JDK，所以我会吃

00:01:46.779 --> 00:01:50.380
知道其中一些东西，但是

00:01:48.789 --> 00:01:54.490
值得谈论一下

00:01:50.380 --> 00:01:57.789
细节，所以我们在jdk 8之前拥有的是

00:01:54.490 --> 00:01:59.139
匿名内部类的思想和

00:01:57.789 --> 00:02:02.020
我们在那里可以做的是

00:01:59.139 --> 00:02:04.359
创建对一个实例的引用

00:02:02.020 --> 00:02:06.159
实现了特定的类

00:02:04.359 --> 00:02:08.229
界面，在这种情况下

00:02:06.159 --> 00:02:10.899
这是一个匿名类

00:02:08.229 --> 00:02:12.940
单一方法需要

00:02:10.899 --> 00:02:14.740
如此实施而不是实际实施

00:02:12.940 --> 00:02:16.020
必须创建一个新类

00:02:14.740 --> 00:02:18.690
这实现了

00:02:16.020 --> 00:02:20.610
面对然后实例化它我们可以

00:02:18.690 --> 00:02:23.460
我们可以简单地说创建新的

00:02:20.610 --> 00:02:26.400
可运行的是接口和我

00:02:23.460 --> 00:02:28.770
希望该接口的方法是

00:02:26.400 --> 00:02:30.720
通过运行并以这种方式实现

00:02:28.770 --> 00:02:32.820
然后我们要做一些事情， 

00:02:30.720 --> 00:02:35.460
然后我们将在

00:02:32.820 --> 00:02:37.230
通常的方式问题是

00:02:35.460 --> 00:02:39.450
相当冗长，因为我们必须

00:02:37.230 --> 00:02:41.010
明确表示， 

00:02:39.450 --> 00:02:43.500
我们要实现的接口是

00:02:41.010 --> 00:02:45.420
可运行的，我们必须在方括号中

00:02:43.500 --> 00:02:48.030
我们必须明确地指出

00:02:45.420 --> 00:02:50.280
方法称为运行，它是一个类型为void 

00:02:48.030 --> 00:02:51.720
返回，然后我们有一些东西

00:02:50.280 --> 00:02:55.260
我们想要这样做，其中有很多东西

00:02:51.720 --> 00:02:56.490
那里我们并不需要

00:02:55.260 --> 00:02:58.080
那就是lambda表达式的全部

00:02:56.490 --> 00:03:00.210
关于这是一种新的做事方式

00:02:58.080 --> 00:03:03.150
这种事情，但简单得多

00:03:00.210 --> 00:03:04.980
表格，所以现在我们知道我们可以使用

00:03:03.150 --> 00:03:06.960
 lambda表达式可以做到这一点

00:03:04.980 --> 00:03:09.210
现在一行而不是

00:03:06.960 --> 00:03:12.600
有所有多余的东西编译器

00:03:09.210 --> 00:03:15.870
从我们使用该特定位置的地方推断

00:03:12.600 --> 00:03:17.880
 lambda表达式的类型是什么

00:03:15.870 --> 00:03:20.640
编译器知道线程需要一个

00:03:17.880 --> 00:03:21.930
作为参数运行，因此它知道

00:03:20.640 --> 00:03:24.720
它必须创建的类型是

00:03:21.930 --> 00:03:26.580
一个可运行的，然后我们告诉它什么

00:03:24.720 --> 00:03:29.220
该方法的实现是

00:03:26.580 --> 00:03:31.200
没有明确说出它是什么

00:03:29.220 --> 00:03:31.530
返回参数是什么，等等

00:03:31.200 --> 00:03:34.080
上

00:03:31.530 --> 00:03:38.250
清洁得多，容易得多

00:03:34.080 --> 00:03:40.500
如果我们更详细地使用，请使用

00:03:38.250 --> 00:03:43.700
关于什么才真正意味着我们

00:03:40.500 --> 00:03:47.640
在这里做的是一种简化的方法

00:03:43.700 --> 00:03:50.209
代表Java中的行为

00:03:47.640 --> 00:03:53.820
比我们可以分配的状态

00:03:50.209 --> 00:03:57.060
行为到变量，我们可以通过

00:03:53.820 --> 00:03:59.850
行为作为另一个参数

00:03:57.060 --> 00:04:03.600
方法，因此在

00:03:59.850 --> 00:04:05.310
我们想做的事情

00:04:03.600 --> 00:04:07.500
我们可以在哪里使用lambda表达式

00:04:05.310 --> 00:04:09.810
我们可以在任何地方使用lambda表达式

00:04:07.500 --> 00:04:12.350
类型是什么

00:04:09.810 --> 00:04:15.510
表示是一个函数式接口

00:04:12.350 --> 00:04:19.230
函数式接口是具有

00:04:15.510 --> 00:04:21.390
现在只有一种抽象方法

00:04:19.230 --> 00:04:23.370
 JDK八很容易发现

00:04:21.390 --> 00:04:27.840
函数式接口，因为它只有

00:04:23.370 --> 00:04:29.639
 JDK中定义的一种方法八

00:04:27.840 --> 00:04:31.860
除了介绍Lander 

00:04:29.639 --> 00:04:34.340
表达式有静态的想法

00:04:31.860 --> 00:04:37.470
中的方法和默认方法

00:04:34.340 --> 00:04:39.600
接口意味着你

00:04:37.470 --> 00:04:42.000
现在的行为包含在

00:04:39.600 --> 00:04:44.520
界面和净效果的种类

00:04:42.000 --> 00:04:46.530
那就是你有多个

00:04:44.520 --> 00:04:48.780
行为的继承以及

00:04:46.530 --> 00:04:50.160
类型的多重继承，因为

00:04:48.780 --> 00:04:53.580
介面可让您拥有多个

00:04:50.160 --> 00:04:55.169
与变量相关的类型

00:04:53.580 --> 00:04:56.520
在Java中没有多个

00:04:55.169 --> 00:04:58.380
国家的继承，这就是

00:04:56.520 --> 00:05:00.570
重要的是它不像C ++ 

00:04:58.380 --> 00:05:02.190
您拥有真正的模型继承Java 

00:05:00.570 --> 00:05:04.590
你有多个类型的继承

00:05:02.190 --> 00:05:09.150
行为的多重继承，但不是

00:05:04.590 --> 00:05:11.820
状态的多重继承因此在jdk中

00:05:09.150 --> 00:05:13.950
 8，如果您有一个抽象方法

00:05:11.820 --> 00:05:16.590
然后您可以使用Lambda表达式

00:05:13.950 --> 00:05:19.770
代表那个和关键的事情

00:05:16.590 --> 00:05:22.169
那就是lambda的身体

00:05:19.770 --> 00:05:26.130
表达是那个的实现

00:05:22.169 --> 00:05:27.750
单一抽象方法另一件事

00:05:26.130 --> 00:05:29.790
关于这一点，就

00:05:27.750 --> 00:05:32.760
设计这实际上要简单得多

00:05:29.790 --> 00:05:34.710
让人们有行为的方式

00:05:32.760 --> 00:05:36.990
分配给变量并作为

00:05:34.710 --> 00:05:39.030
参数，而不必

00:05:36.990 --> 00:05:40.680
向该功能引入新的功能类型

00:05:39.030 --> 00:05:42.000
语言，因为那是另一种

00:05:40.680 --> 00:05:44.220
其他的替代方法

00:05:42.000 --> 00:05:46.950
语言确实具有真正的功能类型

00:05:44.220 --> 00:05:48.330
但是在Java中，因为它已经存在

00:05:46.950 --> 00:05:50.340
他们不想添加新的语言

00:05:48.330 --> 00:05:55.080
功能类型，所以他们做到了

00:05:50.340 --> 00:05:58.470
通过lambdas的想法

00:05:55.080 --> 00:06:01.530
 lambda表达式的语法

00:05:58.470 --> 00:06:04.200
就像一种方法，但非常重要的是

00:06:01.530 --> 00:06:06.990
不是一种方法，所以它没有关联

00:06:04.200 --> 00:06:09.150
班级非常重要

00:06:06.990 --> 00:06:10.800
点，我们会回到

00:06:09.150 --> 00:06:14.460
片刻之后，只是一个lambda表情

00:06:10.800 --> 00:06:18.979
是函数式接口类型，不是

00:06:14.460 --> 00:06:21.780
与类别相关的

00:06:18.979 --> 00:06:23.760
我们所拥有的语法是左手

00:06:21.780 --> 00:06:26.280
 lambda运算符的一面是

00:06:23.760 --> 00:06:28.830
我们传递给我们的参数

00:06:26.280 --> 00:06:30.930
像对象和右手这样的方法

00:06:28.830 --> 00:06:32.669
侧面是我们方法的主体

00:06:30.930 --> 00:06:35.909
对象，但与类无关

00:06:32.669 --> 00:06:38.159
所以就其结构而言

00:06:35.909 --> 00:06:40.610
与方法类似，因此它具有一组

00:06:38.159 --> 00:06:42.319
它具有正文的键入的参数

00:06:40.610 --> 00:06:44.000
返回类型，它可能引发异常

00:06:42.319 --> 00:06:46.009
所以所有这些都是

00:06:44.000 --> 00:06:47.750
与方法相同，但不是

00:06:46.009 --> 00:06:51.319
与课程相关的我们不称其为

00:06:47.750 --> 00:06:55.340
方法与此有关的另一件事是

00:06:51.319 --> 00:06:58.550
它是对价值的封闭而不是

00:06:55.340 --> 00:07:00.650
对类型的封闭意味着

00:06:58.550 --> 00:07:02.689
如果您看看如何使用

00:07:00.650 --> 00:07:05.870
您可以参考的lambda表达式

00:07:02.689 --> 00:07:07.490
来自周围范围的变量

00:07:05.870 --> 00:07:09.259
您可以从外部引用变量

00:07:07.490 --> 00:07:11.930
并使用那些表达式

00:07:09.259 --> 00:07:14.389
在你的lambda表达式中，但是有一个

00:07:11.930 --> 00:07:16.400
如果你回到

00:07:14.389 --> 00:07:17.930
匿名内部类的方式

00:07:16.400 --> 00:07:19.909
可以访问

00:07:17.930 --> 00:07:22.099
周围的范围只有

00:07:19.909 --> 00:07:23.509
明确标记为最终，因此他们

00:07:22.099 --> 00:07:25.189
值只能设置一次，而您不能

00:07:23.509 --> 00:07:27.199
以无法更改的方式进行更改

00:07:25.189 --> 00:07:30.650
匿名中的值

00:07:27.199 --> 00:07:32.569
与lambda表达式相同的类

00:07:30.650 --> 00:07:35.689
事情适用，但规则已经

00:07:32.569 --> 00:07:38.120
放松一点，所以现在变量

00:07:35.689 --> 00:07:40.819
必须有效地最终确定

00:07:38.120 --> 00:07:42.830
可以将其标记为最终的，或者

00:07:40.819 --> 00:07:45.560
没有标记为final，它必须表现得像

00:07:42.830 --> 00:07:50.089
原来只能设置一次

00:07:45.560 --> 00:07:51.440
它无法正确更改，所以让我们

00:07:50.089 --> 00:07:54.139
谈谈捕捉

00:07:51.440 --> 00:07:57.169
 lambda，所以捕获lambda是一个

00:07:54.139 --> 00:07:59.180
它使用来自

00:07:57.169 --> 00:08:01.490
范围和我何时开始

00:07:59.180 --> 00:08:04.129
使用lambdas我写了一段代码

00:08:01.490 --> 00:08:06.259
这非常相似，所以我有一个

00:08:04.129 --> 00:08:09.589
我称之为数据处理器的类

00:08:06.259 --> 00:08:11.689
具有当前值int，然后我

00:08:09.589 --> 00:08:13.610
想处理一些东西，所以我用了

00:08:11.689 --> 00:08:16.159
 lambda表达式，我当前

00:08:13.610 --> 00:08:17.659
价值加我编译它我运行它

00:08:16.159 --> 00:08:20.839
它确实做了我想要的事情

00:08:17.659 --> 00:08:22.069
以为是，我的代码很好，然后我

00:08:20.839 --> 00:08:25.039
我多想了一下

00:08:22.069 --> 00:08:29.389
我以为自己坚持不应该

00:08:25.039 --> 00:08:31.699
工作，因为当前值不是

00:08:29.389 --> 00:08:33.860
实际上，我刚刚告诉你

00:08:31.699 --> 00:08:36.110
我们对价值没有封闭

00:08:33.860 --> 00:08:38.269
对类型的封闭，这如何工作

00:08:36.110 --> 00:08:41.329
编译器如何做我不做的事情

00:08:38.269 --> 00:08:42.529
期望它能做到，事实证明我做了一个

00:08:41.329 --> 00:08:43.969
对此进行了一点研究

00:08:42.529 --> 00:08:46.040
找出正在发生的事情

00:08:43.969 --> 00:08:48.140
原来编译器确实

00:08:46.040 --> 00:08:49.520
代表你的东西我不是

00:08:48.140 --> 00:08:52.100
实际上相信这是一个很好的选择

00:08:49.520 --> 00:08:53.470
想法，因为实际上发生了什么

00:08:52.100 --> 00:08:56.350
插入

00:08:53.470 --> 00:08:59.680
在您面前引用此

00:08:56.350 --> 00:09:00.970
变量现在要记住，着陆器

00:08:59.680 --> 00:09:02.530
表达式与

00:09:00.970 --> 00:09:04.750
在课堂上不像匿名的类

00:09:02.530 --> 00:09:07.090
有一个实例的类

00:09:04.750 --> 00:09:08.770
在课堂上匿名，如果您使用此

00:09:07.090 --> 00:09:12.400
它指的是那个

00:09:08.770 --> 00:09:14.500
使用此表达式时的类

00:09:12.400 --> 00:09:16.570
它指的是

00:09:14.500 --> 00:09:19.300
在这种情况下，范围会

00:09:16.570 --> 00:09:23.050
是数据处理器，所以如果我们插入

00:09:19.300 --> 00:09:25.180
这是当前值前面的

00:09:23.050 --> 00:09:27.010
一个有效的最终变量，因此我们可以

00:09:25.180 --> 00:09:29.200
然后使用有效的最终变量

00:09:27.010 --> 00:09:31.240
我们可以通过它间接访问

00:09:29.200 --> 00:09:34.330
到当前值，我们可以增加

00:09:31.240 --> 00:09:34.810
所以是的，这是老问题了

00:09:34.330 --> 00:09:36.970
我们

00:09:34.810 --> 00:09:39.550
但我不认为我们要这个问题

00:09:36.970 --> 00:09:40.900
解决了，因为整个lambda的想法

00:09:39.550 --> 00:09:42.250
表达式是我们正在处理的

00:09:40.900 --> 00:09:44.410
函数式编程

00:09:42.250 --> 00:09:45.850
不应该修改状态，这允许

00:09:44.410 --> 00:09:48.040
你摆脱修改状态

00:09:45.850 --> 00:09:49.930
当你不应该这样做的时候

00:09:48.040 --> 00:09:52.630
就像我说的，我认为这有点

00:09:49.930 --> 00:09:54.370
嗯，如果他打电话，是因为

00:09:52.630 --> 00:09:56.710
引入您看不到的代码

00:09:54.370 --> 00:09:58.270
在你写的实际代码中

00:09:56.710 --> 00:10:03.730
你不知道那个参考是

00:09:58.270 --> 00:10:05.200
插入的方法引用，所以这是

00:10:03.730 --> 00:10:08.260
你在哪里有lambda的想法

00:10:05.200 --> 00:10:10.000
表达式只是使用一个

00:10:08.260 --> 00:10:13.360
参数的方法

00:10:10.000 --> 00:10:15.460
传递给它或其他形式的

00:10:13.360 --> 00:10:17.860
我们稍后会谈到的

00:10:15.460 --> 00:10:21.550
可以消除一些

00:10:17.860 --> 00:10:24.400
额外的代码，所以在这种情况下，我有

00:10:21.550 --> 00:10:25.840
文件过滤器X，我想代表

00:10:24.400 --> 00:10:27.940
使用lambda表达式的地方

00:10:25.840 --> 00:10:31.300
拿文件F，我要打电话给

00:10:27.940 --> 00:10:33.940
可以读取方法可以读取FI上的方法

00:10:31.300 --> 00:10:36.640
只需说出文件即可简化

00:10:33.940 --> 00:10:39.300
这是补药结肠结肠，然后

00:10:36.640 --> 00:10:43.720
可以阅读，相当于

00:10:39.300 --> 00:10:45.010
上面的lambda表达式

00:10:43.720 --> 00:10:46.410
使用方法的方式

00:10:45.010 --> 00:10:49.000
引用他们实际上是三个

00:10:46.410 --> 00:10:51.730
在其中使用它们的独特方式

00:10:49.000 --> 00:10:53.170
形成它们的条件等等

00:10:51.730 --> 00:10:54.940
这是你有一个目标

00:10:53.170 --> 00:10:56.830
参考双冒号，然后

00:10:54.940 --> 00:10:59.620
方法名称，因此方法名称将

00:10:56.830 --> 00:11:01.270
我被目标参考所吸引

00:10:59.620 --> 00:11:04.030
说这三种

00:11:01.270 --> 00:11:05.740
与静态方法有关之一是

00:11:04.030 --> 00:11:08.260
您正在调用实例方法

00:11:05.740 --> 00:11:09.790
在任意类型上

00:11:08.260 --> 00:11:14.020
您正在调用一个实例方法

00:11:09.790 --> 00:11:17.440
现有对象，如果我们看一下

00:11:14.020 --> 00:11:18.910
那些大多数建筑的规则

00:11:17.440 --> 00:11:20.350
这非常简单，因此在

00:11:18.910 --> 00:11:22.030
第一种情况，如果我们正在处理

00:11:20.350 --> 00:11:23.440
静态方法您将拥有的是

00:11:22.030 --> 00:11:25.000
一个lambda表达式

00:11:23.440 --> 00:11:26.680
一些争论，然后你有一个

00:11:25.000 --> 00:11:28.930
类名，然后调用静态

00:11:26.680 --> 00:11:30.490
这些参数的方法

00:11:28.930 --> 00:11:32.530
转换成我们的方法参考

00:11:30.490 --> 00:11:35.890
您只需使用类名double 

00:11:32.530 --> 00:11:40.030
冒号静态方法名称很棒

00:11:35.890 --> 00:11:42.640
我们使用现有的底部

00:11:40.030 --> 00:11:43.750
对象引用我们可以做的是一样的

00:11:42.640 --> 00:11:45.730
我们可以说的好吧，我们有一些

00:11:43.750 --> 00:11:47.830
参数，我们有一个表达式

00:11:45.730 --> 00:11:49.540
代表我们现有的对象

00:11:47.830 --> 00:11:51.790
调用实例方法

00:11:49.540 --> 00:11:53.710
论据，所以我们构造的方式

00:11:51.790 --> 00:11:55.600
方法参考基本上是

00:11:53.710 --> 00:11:59.170
除了使用类型以外，其他均相同

00:11:55.600 --> 00:12:00.700
我们在

00:11:59.170 --> 00:12:03.370
中间稍微复杂一些

00:12:00.700 --> 00:12:05.140
因为在这种情况下，我们有一组

00:12:03.370 --> 00:12:07.240
第一个参数是的参数

00:12:05.140 --> 00:12:09.370
我们将称之为的类型

00:12:07.240 --> 00:12:11.290
方法，然后我们有

00:12:09.370 --> 00:12:13.480
在那之后可能会有更多的争论

00:12:11.290 --> 00:12:15.520
这是其余的论点

00:12:13.480 --> 00:12:18.640
我们作为参数传递给实例

00:12:15.520 --> 00:12:20.080
第一个参数类型的方法现在确定

00:12:18.640 --> 00:12:21.430
一切看起来都很复杂，所以我

00:12:20.080 --> 00:12:24.970
给你看一些例子，它使它成为现实

00:12:21.430 --> 00:12:27.400
至少我希望它更清晰

00:12:24.970 --> 00:12:29.590
第一次调用静态方法

00:12:27.400 --> 00:12:32.070
将字符串s作为我们的参数，我们

00:12:29.590 --> 00:12:34.360
在s上调用整数点parseint 

00:12:32.070 --> 00:12:35.800
非常简单，我们可以将其转换为

00:12:34.360 --> 00:12:38.830
说整数的方法引用

00:12:35.800 --> 00:12:39.850
双冒号解析int第二个是

00:12:38.830 --> 00:12:41.920
事情多一点

00:12:39.850 --> 00:12:44.250
复杂，所以我们有字符串s和

00:12:41.920 --> 00:12:46.420
我们已经了解了买家参数， 

00:12:44.250 --> 00:12:48.310
我们想要实际实现的

00:12:46.420 --> 00:12:51.400
 lambda表达式的意思是说点

00:12:48.310 --> 00:12:54.490
我的子字符串，我们可以将其转换为

00:12:51.400 --> 00:12:55.930
使用字符串转换为方法引用

00:12:54.490 --> 00:12:58.900
因为那是第一种

00:12:55.930 --> 00:13:01.420
参数S并在其上调用子字符串

00:12:58.900 --> 00:13:04.180
这会将I作为参数传递给

00:13:01.420 --> 00:13:06.280
通话，然后就最后一个而言

00:13:04.180 --> 00:13:08.590
一个，如果我们有一个现有的对象，如果

00:13:06.280 --> 00:13:10.360
我们希望在这种情况下，我们有一个轴a 

00:13:08.590 --> 00:13:12.490
然后我们打电话给获取长度

00:13:10.360 --> 00:13:15.550
这是我们所在的班级

00:13:12.490 --> 00:13:17.530
实际运行中，我们可以将其用作

00:13:15.550 --> 00:13:18.760
参考，因为再次lambda 

00:13:17.530 --> 00:13:21.010
表达式与

00:13:18.760 --> 00:13:22.990
这个类代表周围

00:13:21.010 --> 00:13:24.310
范围，我们可以调用获取长度

00:13:22.990 --> 00:13:29.740
所以这是三种不同的方式

00:13:24.310 --> 00:13:31.750
我们可以使用方法引用正确

00:13:29.740 --> 00:13:34.480
所以现在让我们谈谈lambda 

00:13:31.750 --> 00:13:35.890
表达表现，因为有

00:13:34.480 --> 00:13:38.980
一些有趣的事情要理解

00:13:35.890 --> 00:13:40.870
关于那好吧，第一件事是

00:13:38.980 --> 00:13:44.200
正如我们已经讨论过的那样

00:13:40.870 --> 00:13:47.620
在功能上等效

00:13:44.200 --> 00:13:50.980
三种不同类型的方式中

00:13:47.620 --> 00:13:52.900
我们可以用Java表示一个函数

00:13:50.980 --> 00:13:54.640
我们可以有一个lambda表达式，例如

00:13:52.900 --> 00:13:57.430
所以我想为每个然后说

00:13:54.640 --> 00:13:59.710
我只是以W为代表

00:13:57.430 --> 00:14:02.770
例子，然后打印出来就可以了

00:13:59.710 --> 00:14:04.840
那是一个lambda表达式被我们使用

00:14:02.770 --> 00:14:06.670
也可以使用方法参考

00:14:04.840 --> 00:14:08.500
您已经看过了，所以我们只需

00:14:06.670 --> 00:14:09.610
说系统点出双冒号打印

00:14:08.500 --> 00:14:11.440
线大

00:14:09.610 --> 00:14:13.930
在功能上等同于上述一种

00:14:11.440 --> 00:14:16.390
我们也可以用

00:14:13.930 --> 00:14:18.640
课堂上的匿名者更加冗长

00:14:16.390 --> 00:14:20.020
但现在完全一样

00:14:18.640 --> 00:14:21.730
我们是说我们必须创建一个新的

00:14:20.020 --> 00:14:23.710
字符串类型的使用者的实例

00:14:21.730 --> 00:14:25.630
我们将覆盖接受

00:14:23.710 --> 00:14:27.550
方法，我们将打印出

00:14:25.630 --> 00:14:29.290
对吧，重要的事情

00:14:27.550 --> 00:14:31.360
这是这些都不做任何事

00:14:29.290 --> 00:14:36.300
不同，他们都做的完全一样

00:14:31.360 --> 00:14:38.470
事情，但是他们如何编译是不同的

00:14:36.300 --> 00:14:40.930
所以我们在课堂上看匿名

00:14:38.470 --> 00:14:43.630
顾名思义，这里的关键

00:14:40.930 --> 00:14:46.420
是因为我们正在处理一个类

00:14:43.630 --> 00:14:48.730
因此，当该代码被编译时

00:14:46.420 --> 00:14:50.980
编译器会查看您所做的事情， 

00:14:48.730 --> 00:14:53.980
它说啊，你试图代表

00:14:50.980 --> 00:14:56.260
一个界面，但是你不能那样做

00:14:53.980 --> 00:14:58.360
因为你需要一个具体的课程

00:14:56.260 --> 00:15:01.270
为了生成该类型的对象

00:14:58.360 --> 00:15:03.880
所以编译器会生成一个类

00:15:01.270 --> 00:15:06.010
为你和匿名班，如果

00:15:03.880 --> 00:15:07.300
你有一个像foo这样的课程，那么你就是

00:15:06.010 --> 00:15:09.070
会看到一个名为

00:15:07.300 --> 00:15:10.690
像食物美元1到

00:15:09.070 --> 00:15:13.870
代表班级中的匿名者

00:15:10.690 --> 00:15:15.130
食物问题正在使用

00:15:13.870 --> 00:15:16.810
这就是你最后的所谓

00:15:15.130 --> 00:15:18.910
污染的类型，因此您正在产生

00:15:16.810 --> 00:15:20.770
您的应用程序中的类型比

00:15:18.910 --> 00:15:23.680
你真的需要你真正想要的是

00:15:20.770 --> 00:15:25.820
功能的另一个缺点是

00:15:23.680 --> 00:15:27.890
那是因为这是一堂课

00:15:25.820 --> 00:15:29.480
在运行时，您必须加载该类

00:15:27.890 --> 00:15:31.130
因此，在

00:15:29.480 --> 00:15:32.630
加载课程有一个开销

00:15:31.130 --> 00:15:35.090
初始化该类的条件，以及

00:15:32.630 --> 00:15:37.940
然后从使用它的角度

00:15:35.090 --> 00:15:40.010
必须实例化

00:15:37.940 --> 00:15:41.990
给您的堆增加额外的负担

00:15:40.010 --> 00:15:43.970
空间可能会增加额外的负载

00:15:41.990 --> 00:15:47.690
在你的垃圾收集器上，因为你

00:15:43.970 --> 00:15:49.160
生成对象，这可能会导致

00:15:47.690 --> 00:15:50.630
在更多的垃圾收集中，你实际上

00:15:49.160 --> 00:15:52.760
想要，所以有很多事情

00:15:50.630 --> 00:15:56.510
没有匿名内部类的地方

00:15:52.760 --> 00:15:57.500
如果一定是最好的方法

00:15:56.510 --> 00:15:59.410
你看一下lambda表达式

00:15:57.500 --> 00:16:02.450
由于这种功能上的等效

00:15:59.410 --> 00:16:04.730
你可以简单地实现一个lambda 

00:16:02.450 --> 00:16:06.830
表示为等效的匿名

00:16:04.730 --> 00:16:08.750
内部类，以便编译器可以使用

00:16:06.830 --> 00:16:10.490
该lambda表达式将其转换为

00:16:08.750 --> 00:16:12.590
类代码中的匿名者

00:16:10.490 --> 00:16:14.840
然后将其完全

00:16:12.590 --> 00:16:17.240
与在jdk 7和

00:16:14.840 --> 00:16:19.280
实际上，如果您先看一下

00:16:17.240 --> 00:16:21.500
 lambdas的开发方式

00:16:19.280 --> 00:16:23.780
第一次实现确实做到了

00:16:21.500 --> 00:16:25.520
所以你看过战术糖lambda 

00:16:23.780 --> 00:16:27.490
表达式将其转换为匿名

00:16:25.520 --> 00:16:29.660
上课就编译吧

00:16:27.490 --> 00:16:32.000
可能这样做是因为

00:16:29.660 --> 00:16:33.680
在代码上强制使用内部类

00:16:32.000 --> 00:16:36.740
你实际上不想要什么

00:16:33.680 --> 00:16:38.390
您真正想要的是一个功能， 

00:16:36.740 --> 00:16:41.360
显然是不给他的决定

00:16:38.390 --> 00:16:43.490
在...中没有功能类型

00:16:41.360 --> 00:16:46.030
语言，但是如果我们

00:16:43.490 --> 00:16:48.320
没有涉及所有额外的工作

00:16:46.030 --> 00:16:52.580
试图做一个函数类型，但是

00:16:48.320 --> 00:16:53.600
最后有很多额外的课，所以

00:16:52.580 --> 00:16:55.940
必须有更好的方法

00:16:53.600 --> 00:16:59.540
这个和那里以及它的方式

00:16:55.940 --> 00:17:01.880
在jdk 8中完成的操作是通过使用

00:16:59.540 --> 00:17:04.699
 invokedynamic字节码和方法

00:17:01.880 --> 00:17:06.650
处理这个背后的原因是

00:17:04.699 --> 00:17:08.420
如果你看看历史

00:17:06.650 --> 00:17:11.689
 invokedynamic这是第一个字节

00:17:08.420 --> 00:17:15.589
自Java以来​​引入的代码

00:17:11.689 --> 00:17:17.810
它开始了，目标是

00:17:15.589 --> 00:17:19.880
帮助正在使用的语言

00:17:17.810 --> 00:17:23.329
开发并编译成字节码

00:17:19.880 --> 00:17:25.370
不是静态输入的，所以如果您

00:17:23.329 --> 00:17:27.949
看看像JRuby这样的语言

00:17:25.370 --> 00:17:30.260
非静态输入，因此您可以更改

00:17:27.949 --> 00:17:33.950
参数的类型和返回

00:17:30.260 --> 00:17:35.740
运行时和顺序中的方法类型

00:17:33.950 --> 00:17:38.670
用静态类型做到这一点

00:17:35.740 --> 00:17:39.990
虚拟机指令集

00:17:38.670 --> 00:17:41.430
做很多额外的工作，因为你

00:17:39.990 --> 00:17:42.630
打电话之前必须测试所有内容

00:17:41.430 --> 00:17:44.750
您必须确定哪种方法

00:17:42.630 --> 00:17:47.280
您实际上要打电话的方法

00:17:44.750 --> 00:17:49.740
所以在jar中引入了invoke dynamic 

00:17:47.280 --> 00:17:52.380
 se7使编译器的工作更轻松

00:17:49.740 --> 00:17:56.010
编写代码的作家

00:17:52.380 --> 00:17:58.620
 JDK 8中的JVM实际上是由他使用的

00:17:56.010 --> 00:18:02.550
 Java，因为未使用JDK 7 Java 

00:17:58.620 --> 00:18:05.550
在JDK 8 lambda表达式中使用

00:18:02.550 --> 00:18:09.510
 invokedynamic字节码和想法

00:18:05.550 --> 00:18:11.040
这背后是说好，我们想做

00:18:09.510 --> 00:18:13.650
关于使用lambda的一些东西

00:18:11.040 --> 00:18:16.880
表达，而不是固定我们的方式

00:18:13.650 --> 00:18:19.500
做到这一点到编译的字节码

00:18:16.880 --> 00:18:21.690
将使用invokedynamic字节码和

00:18:19.500 --> 00:18:24.330
我们将说出如何

00:18:21.690 --> 00:18:26.940
这是在运行时实现的

00:18:24.330 --> 00:18:29.520
 JVM可以决定它想怎么做

00:18:26.940 --> 00:18:31.440
该lambda的实现

00:18:29.520 --> 00:18:35.010
实际运行时的表情

00:18:31.440 --> 00:18:36.960
如果发现新方法

00:18:35.010 --> 00:18:38.700
如何做到表现更好

00:18:36.960 --> 00:18:40.140
我们很容易改变

00:18:38.700 --> 00:18:41.880
运行时无法在JVM中更改它

00:18:40.140 --> 00:18:43.350
而不需要重新编译

00:18:41.880 --> 00:18:50.310
代码并生成新的字节集

00:18:43.350 --> 00:18:52.200
我告诉你没有固定的二进制代码

00:18:50.310 --> 00:18:54.770
格式JVM可以提供不同的方式

00:18:52.200 --> 00:18:56.670
现在，如果我们看看如何

00:18:54.770 --> 00:18:59.640
事情就lambda而言有效

00:18:56.670 --> 00:19:02.580
编译的第一件事就是身体

00:18:59.640 --> 00:19:05.130
 lambda表达式的

00:19:02.580 --> 00:19:06.360
转换成我现在知道的方法

00:19:05.130 --> 00:19:07.770
我已经说过你知道这是一个

00:19:06.360 --> 00:19:09.990
功能不是方法，不是

00:19:07.770 --> 00:19:12.690
与班级相关，但顺序

00:19:09.990 --> 00:19:15.390
使其能够被使用

00:19:12.690 --> 00:19:18.180
它转换成一个JVM 

00:19:15.390 --> 00:19:20.600
现在就其编译方法

00:19:18.180 --> 00:19:22.950
这是通过以下三种方式之一完成的

00:19:20.600 --> 00:19:25.860
所以首先是如果你有一个非

00:19:22.950 --> 00:19:28.110
捕获指挥官不捕获lambda 

00:19:25.860 --> 00:19:29.910
是您不参考任何

00:19:28.110 --> 00:19:31.800
来自周围范围的变量

00:19:29.910 --> 00:19:34.080
所以你知道你在做什么

00:19:31.800 --> 00:19:36.090
像打印线，那可能是

00:19:34.080 --> 00:19:38.880
不是一个很好的例子，但是如果你这样做

00:19:36.090 --> 00:19:40.110
有些东西没有引用变量

00:19:38.880 --> 00:19:43.500
周围的范围是一个非

00:19:40.110 --> 00:19:45.150
捕捉到做到这一点非常简单

00:19:43.500 --> 00:19:47.010
对于编译器，因为它只需要

00:19:45.150 --> 00:19:48.660
要做的是在中生成一个新的静态方法

00:19:47.010 --> 00:19:52.110
 lambda表达式所在的类

00:19:48.660 --> 00:19:54.120
在通过的地方使用

00:19:52.110 --> 00:19:56.040
 Lambda表达式的文档为

00:19:54.120 --> 00:19:58.170
静态方法的参数

00:19:56.040 --> 00:20:00.120
生成和相同的返回类型

00:19:58.170 --> 00:20:01.590
所以要做的就是插入身体

00:20:00.120 --> 00:20:05.660
将lambda表达式转化为新的

00:20:01.590 --> 00:20:09.540
方法非常简单的转换为

00:20:05.660 --> 00:20:12.059
捕获lambda（如果捕获） 

00:20:09.540 --> 00:20:14.250
像静态变量和

00:20:12.059 --> 00:20:16.440
这样的事情再一次是相当

00:20:14.250 --> 00:20:18.210
易于使用，因为它将

00:20:16.440 --> 00:20:19.830
编译器将生成一个静态

00:20:18.210 --> 00:20:21.780
方法与我们对非

00:20:19.830 --> 00:20:24.120
捕获一个，但是这次而不是

00:20:21.780 --> 00:20:26.070
只是传递参数

00:20:24.120 --> 00:20:28.730
 lambda表达式的参数吧

00:20:26.070 --> 00:20:30.540
将在任何参数之前添加这些参数

00:20:28.730 --> 00:20:32.700
您从中引用的变量

00:20:30.540 --> 00:20:35.309
周围的范围是静态的，因此

00:20:32.700 --> 00:20:38.580
表达式主体运行的方式

00:20:35.309 --> 00:20:40.140
它具有即时的变量

00:20:38.580 --> 00:20:43.010
参数被传递给

00:20:40.140 --> 00:20:46.530
方法，因此它能够以这种方式工作

00:20:43.010 --> 00:20:48.960
第三种形式是您拥有

00:20:46.530 --> 00:20:50.940
实例捕获lambda，所以lambda 

00:20:48.960 --> 00:20:53.040
实际上是指一个对象

00:20:50.940 --> 00:20:54.840
而不是静态的非常静态的方法

00:20:53.040 --> 00:20:57.540
所以在这种情况下

00:20:54.840 --> 00:20:59.070
 Rawdon在

00:20:57.540 --> 00:21:02.220
 lambda表达式所在的类

00:20:59.070 --> 00:21:04.470
用它创造了一种真正的合成方法

00:21:02.220 --> 00:21:07.200
与之相关的一个

00:21:04.470 --> 00:21:09.600
特定的类，然后当对象

00:21:07.200 --> 00:21:13.320
被创建有一种方法

00:21:09.600 --> 00:21:15.450
在这种情况下，因为这是一个

00:21:13.320 --> 00:21:18.090
使用的类中的实例方法

00:21:15.450 --> 00:21:20.850
一个lambda表达式，它能够引用

00:21:18.090 --> 00:21:23.429
到周围的物体上

00:21:20.850 --> 00:21:24.990
以这种方式访问​​变量

00:21:23.429 --> 00:21:27.120
这就是我们生成方法一的方式

00:21:24.990 --> 00:21:28.799
我们现在有三种方法

00:21:27.120 --> 00:21:32.190
使用lambda的类

00:21:28.799 --> 00:21:36.210
使用lambda的表达式

00:21:32.190 --> 00:21:38.640
表示调用动态的表达式是

00:21:36.210 --> 00:21:41.400
生成的，这就是所谓的

00:21:38.640 --> 00:21:44.190
 lambda工厂，所以这个主意是

00:21:41.400 --> 00:21:47.610
您调用动态调用

00:21:44.190 --> 00:21:51.750
这将返回对

00:21:47.610 --> 00:21:53.040
类型为的对象的实例

00:21:51.750 --> 00:21:55.799
 lambda的函数式接口

00:21:53.040 --> 00:21:57.090
表情代表那种

00:21:55.799 --> 00:21:59.190
很有道理，所以我们需要某种方式

00:21:57.090 --> 00:22:02.030
得到对对象的引用

00:21:59.190 --> 00:22:05.160
然后我们可以在上面调用该方法

00:22:02.030 --> 00:22:06.840
实际上，我们也有一个东西

00:22:05.160 --> 00:22:10.290
称为引导程序方法

00:22:06.840 --> 00:22:12.180
 lambda meta Factory，并使用

00:22:10.290 --> 00:22:14.520
 Java声明或调用lambda元

00:22:12.180 --> 00:22:17.370
工厂课重要的是

00:22:14.520 --> 00:22:20.040
这是根据

00:22:17.370 --> 00:22:21.450
 lambda表达式工作很酷

00:22:20.040 --> 00:22:23.760
 Lambda表达式科学在哪里

00:22:21.450 --> 00:22:27.780
我们使用meta工厂，或者如果他们

00:22:23.760 --> 00:22:29.760
懒惰地评估，这意味着

00:22:27.780 --> 00:22:32.010
如果您不使用该lambda表达式

00:22:29.760 --> 00:22:33.360
您没有任何相关的间接费用

00:22:32.010 --> 00:22:35.460
有了它，所以这很重要

00:22:33.360 --> 00:22:37.350
从不同的角度来看

00:22:35.460 --> 00:22:39.780
课堂上的巨大

00:22:37.350 --> 00:22:41.670
创建并加载类

00:22:39.780 --> 00:22:43.380
从这样的角度来看

00:22:41.670 --> 00:22:45.810
如果您不使用Lambda表达式

00:22:43.380 --> 00:22:47.790
那你就没有

00:22:45.810 --> 00:22:50.550
实际上叫lambda Mehta 

00:22:47.790 --> 00:22:52.980
工厂，所以它被忽略，这意味着

00:22:50.550 --> 00:22:58.680
通过使用您可以获得更好的性能

00:22:52.980 --> 00:23:00.110
从这个意义上讲，lambda表达式

00:22:58.680 --> 00:23:02.250
接下来的事情是，如果我们看

00:23:00.110 --> 00:23:05.010
实施方面的差异

00:23:02.250 --> 00:23:08.190
在lambda和匿名内部之间

00:23:05.010 --> 00:23:10.110
上课，您可以了解两者

00:23:08.190 --> 00:23:13.890
这些事情分为三个不同的

00:23:10.110 --> 00:23:17.100
在lambdas的情况下

00:23:13.890 --> 00:23:20.100
首先是您如何链接到

00:23:17.100 --> 00:23:21.600
引用的类是

00:23:20.100 --> 00:23:22.620
要给你的方法是

00:23:21.600 --> 00:23:25.080
被称为lambda 

00:23:22.620 --> 00:23:27.300
匿名中的表达主体

00:23:25.080 --> 00:23:30.300
类相当于加载

00:23:27.300 --> 00:23:32.700
您需要调用的课程

00:23:30.300 --> 00:23:35.550
为了执行匿名方法

00:23:32.700 --> 00:23:38.640
现在从一个类方法

00:23:35.550 --> 00:23:40.890
比较这两个Oracle的观点

00:23:38.640 --> 00:23:42.870
大量的性能分析和

00:23:40.890 --> 00:23:44.820
有一个在线视频

00:23:42.870 --> 00:23:47.550
您可以找到有关此的话题

00:23:44.820 --> 00:23:49.950
在相当长的时间内，所以团队

00:23:47.550 --> 00:23:51.420
在俄罗斯做了很多工作， 

00:23:49.950 --> 00:23:53.820
他们发现的是，如果你看

00:23:51.420 --> 00:23:56.760
这两种的比较从

00:23:53.820 --> 00:23:58.590
一旦获得，就可以得出lambda的观点

00:23:56.760 --> 00:23:59.790
通过所谓的热路径

00:23:58.590 --> 00:24:02.210
一旦一切都安顿下来

00:23:59.790 --> 00:24:05.100
你会用这些东西几次

00:24:02.210 --> 00:24:07.730
类加载中的链接是关于

00:24:05.100 --> 00:24:10.230
一样，所以使用的效果

00:24:07.730 --> 00:24:11.670
 lambda表达式的性能明智的是

00:24:10.230 --> 00:24:13.740
与匿名内部大致相同

00:24:11.670 --> 00:24:15.149
类，所以你没有任何优势

00:24:13.740 --> 00:24:17.580
用于使用

00:24:15.149 --> 00:24:19.589
但是从寒冷的道路上

00:24:17.580 --> 00:24:21.359
您会启动，因此，如果您仅使用

00:24:19.589 --> 00:24:22.499
 lambda表达几次

00:24:21.359 --> 00:24:25.139
经历了冷酷的道路

00:24:22.499 --> 00:24:27.089
而不是热门路径，然后是lambdas 

00:24:25.139 --> 00:24:29.070
赢了，所以lambdas实际上要好得多

00:24:27.089 --> 00:24:30.869
在第一方面的表现

00:24:29.070 --> 00:24:33.269
启动位，因为类加载是

00:24:30.869 --> 00:24:34.739
唤醒操作比

00:24:33.269 --> 00:24:37.739
呼叫站点所需的链接

00:24:34.739 --> 00:24:39.239
 Lambda表达式的净值

00:24:37.739 --> 00:24:41.999
这样做的结果是lambdas获胜

00:24:39.239 --> 00:24:44.489
因为在第一个启动位中

00:24:41.999 --> 00:24:45.989
更好，然后一旦您进入排序

00:24:44.489 --> 00:24:50.309
处于稳定状态时，它们大致相同

00:24:45.989 --> 00:24:54.239
作为匿名内部类第二部分

00:24:50.309 --> 00:24:56.190
是捕获和实例化，所以捕获

00:24:54.239 --> 00:24:58.019
对于lambdas，我们如何处理捕获

00:24:56.190 --> 00:25:00.899
的变量实例化

00:24:58.019 --> 00:25:03.719
在课堂上匿名，他们发现了什么

00:25:00.899 --> 00:25:06.629
如果你看两个

00:25:03.719 --> 00:25:09.419
如果您使用的是

00:25:06.629 --> 00:25:11.940
单线程环境，所以两者都会

00:25:09.419 --> 00:25:13.320
如果开始的话，大约相等

00:25:11.940 --> 00:25:15.119
使用多个线程，您已经

00:25:13.320 --> 00:25:17.279
您所做的事情更多

00:25:15.119 --> 00:25:20.219
尽管那部分

00:25:17.279 --> 00:25:22.139
 lambdas会赢，所以lambdas会执行

00:25:20.219 --> 00:25:25.019
线程数更好

00:25:22.139 --> 00:25:27.239
内核数增加匿名

00:25:25.019 --> 00:25:29.219
内部类不会获得相同的好处

00:25:27.239 --> 00:25:32.429
就斯坦语而言

00:25:29.219 --> 00:25:35.729
他们捕捉另一件事

00:25:32.429 --> 00:25:37.710
我们被发现的方式

00:25:35.729 --> 00:25:39.690
与匿名相比，lambdas的工作

00:25:37.710 --> 00:25:44.309
内部类是，如果你有一个

00:25:39.690 --> 00:25:46.289
非静态匿名类，然后您

00:25:44.309 --> 00:25:48.389
实际需要50％以上的空间

00:25:46.289 --> 00:25:49.919
表示对捕获的引用

00:25:48.389 --> 00:25:51.629
比在lambda中可变

00:25:49.919 --> 00:25:53.219
再次表达，这是一个很小的

00:25:51.629 --> 00:25:55.469
东西，但这意味着又是lambdas 

00:25:53.219 --> 00:25:57.899
就...而言

00:25:55.469 --> 00:26:00.419
性能，最后一点是

00:25:57.899 --> 00:26:02.580
两种不同的方式

00:26:00.419 --> 00:26:03.509
服务器调用该方法，因为

00:26:02.580 --> 00:26:05.159
他们在做同样的事情

00:26:03.509 --> 00:26:07.409
调用方法没有区别

00:26:05.159 --> 00:26:09.359
在这两个之间，总的来说

00:26:07.409 --> 00:26:12.539
发现是lambda表达式来的

00:26:09.359 --> 00:26:16.379
在性能方面领先

00:26:12.539 --> 00:26:18.239
您现在希望的是

00:26:16.379 --> 00:26:20.669
就像经验法则无法捕捉

00:26:18.239 --> 00:26:22.259
 lambdas会自动优化

00:26:20.669 --> 00:26:25.349
他们工作的方式是

00:26:22.259 --> 00:26:26.940
在优化第二方面更好

00:26:25.349 --> 00:26:28.270
问题是方法引用是

00:26:26.940 --> 00:26:31.420
稍微多一点

00:26:28.270 --> 00:26:32.650
原因是因为我

00:26:31.420 --> 00:26:34.240
向您介绍了其中一项

00:26:32.650 --> 00:26:36.550
必须发生的第一件事

00:26:34.240 --> 00:26:38.350
 lambda已编译，您必须

00:26:36.550 --> 00:26:41.410
产生一种具有主体的新方法

00:26:38.350 --> 00:26:43.300
其中的lambda表达式

00:26:41.410 --> 00:26:44.470
使用不需要的方法引用

00:26:43.300 --> 00:26:45.970
这样做是因为您已经有一个

00:26:44.470 --> 00:26:47.770
方法参考，因此您不需要

00:26:45.970 --> 00:26:50.080
创建一个新的来拨打电话

00:26:47.770 --> 00:26:52.390
另一个方法，所以编译器

00:26:50.080 --> 00:26:54.100
只会忽略必须创建一个

00:26:52.390 --> 00:26:56.440
新方法，我们将只使用该方法

00:26:54.100 --> 00:26:57.730
直接引用，这样，如果您

00:26:56.440 --> 00:27:00.700
使用实际上是一个方法引用

00:26:57.730 --> 00:27:04.080
比使用相同的代码更有效

00:27:00.700 --> 00:27:06.580
作为lambda显式lambda表达式

00:27:04.080 --> 00:27:09.070
他们发现的另一件事

00:27:06.580 --> 00:27:11.410
做他们的分析是分层的

00:27:09.070 --> 00:27:13.720
编译给出了更好的结果

00:27:11.410 --> 00:27:15.390
 lambda表达式现在的重点是

00:27:13.720 --> 00:27:18.910
默认情况下，层编译处于打开状态

00:27:15.390 --> 00:27:20.920
所以建议真的不使用- 

00:27:18.910 --> 00:27:22.840
分层编译不分层

00:27:20.920 --> 00:27:25.380
如果您想要更好的编译

00:27:22.840 --> 00:27:28.720
 lambda表达式的效果

00:27:25.380 --> 00:27:30.820
对，所以表现还可以，所以现在

00:27:28.720 --> 00:27:32.590
我们有有趣而有用的

00:27:30.820 --> 00:27:35.760
现在，我们将继续

00:27:32.590 --> 00:27:38.650
有趣但又有用的部分

00:27:35.760 --> 00:27:41.020
对，所以这里的想法是我们能走多远

00:27:38.650 --> 00:27:43.870
现在我要拿lambda 

00:27:41.020 --> 00:27:46.600
给别人给我

00:27:43.870 --> 00:27:49.750
因为这是最后的灵感

00:27:46.600 --> 00:27:51.460
年在瑞士的会议上

00:27:49.750 --> 00:27:54.010
是一个叫Jarek的人

00:27:51.460 --> 00:27:55.840
谁在lambda上做演讲的关键

00:27:54.010 --> 00:27:57.940
我坐在那里看的表情

00:27:55.840 --> 00:27:58.870
他在一个IDE中做到了

00:27:57.940 --> 00:28:02.200
吓死我了

00:27:58.870 --> 00:28:03.880
所以他把它做到了IDE，他做了

00:28:02.200 --> 00:28:05.710
屏幕上所有这些Java 

00:28:03.880 --> 00:28:08.290
看起来我以为我不知道

00:28:05.710 --> 00:28:10.420
他在干，我不得不考虑一下

00:28:08.290 --> 00:28:12.400
很多，我不得不走了，我说话了

00:28:10.420 --> 00:28:14.710
之后给他，我有点

00:28:12.400 --> 00:28:17.860
我和它聊天，所以这是

00:28:14.710 --> 00:28:20.590
这是我们来自正确的地方，所以

00:28:17.860 --> 00:28:22.179
首先是我们将所有这些称为

00:28:20.590 --> 00:28:23.890
 lambda表达式为什么我们称它们为

00:28:22.179 --> 00:28:26.860
 lambda表达式，原因是

00:28:23.890 --> 00:28:29.350
因为阿隆佐教堂所以阿隆佐

00:28:26.860 --> 00:28:30.010
教会提出了lambda的想法

00:28:29.350 --> 00:28:32.740
结石

00:28:30.010 --> 00:28:34.240
早在1930年代中期

00:28:32.740 --> 00:28:35.980
显然你对自己想

00:28:34.240 --> 00:28:37.780
好，这与Java有什么关系

00:28:35.980 --> 00:28:41.710
直到实际上才出来

00:28:37.780 --> 00:28:42.380
 1995年，您知道60年后的Java 

00:28:41.710 --> 00:28:44.270
出来

00:28:42.380 --> 00:28:45.830
那几乎是另一种感觉

00:28:44.270 --> 00:28:49.340
拉姆达之前20年

00:28:45.830 --> 00:28:50.660
现在的表情是阿隆索

00:28:49.340 --> 00:28:53.030
选择了λ演算是

00:28:50.660 --> 00:28:56.450
数学表示方式

00:28:53.030 --> 00:29:00.320
一种处理事物的方式

00:28:56.450 --> 00:29:02.990
功能等等有趣的事情

00:29:00.320 --> 00:29:05.750
关于阿隆佐教堂，他也是这个

00:29:02.990 --> 00:29:07.730
艾伦·图灵当主管

00:29:05.750 --> 00:29:09.320
图灵在剑桥获得博士学位

00:29:07.730 --> 00:29:11.330
是一种有趣的联系

00:29:09.320 --> 00:29:13.520
在lambda表达式之间

00:29:11.330 --> 00:29:16.340
函数式编程现在可以确保谁

00:29:13.520 --> 00:29:20.720
显然，在

00:29:16.340 --> 00:29:22.130
现代计算机的设计，这是

00:29:20.720 --> 00:29:26.330
我们进入所谓的爆炸

00:29:22.130 --> 00:29:28.730
作为Java程序员，我们是lambda头

00:29:26.330 --> 00:29:30.380
非常习惯命令

00:29:28.730 --> 00:29:32.690
编程，所以我们喜欢处理

00:29:30.380 --> 00:29:34.640
循环，我们非常想处理

00:29:32.690 --> 00:29:36.500
状态，所以我们有变量

00:29:34.640 --> 00:29:39.380
我们有for循环的程序

00:29:36.500 --> 00:29:42.560
循环等等，但是问题是

00:29:39.380 --> 00:29:44.480
函数式编程不是必须的

00:29:42.560 --> 00:29:46.520
所以我想问这个问题

00:29:44.480 --> 00:29:48.710
我敢肯定，这是一个工作计划

00:29:46.520 --> 00:29:51.710
所以谁还会认为自己是

00:29:48.710 --> 00:29:53.540
功能程序员，是的，您看到了

00:29:51.710 --> 00:29:56.510
有几个人，但不是每个人

00:29:53.540 --> 00:29:58.070
这真的告诉了我所有人

00:29:56.510 --> 00:29:59.930
我正在与之交谈的观众非常

00:29:58.070 --> 00:30:01.100
常见的有一些人

00:29:59.930 --> 00:30:03.080
完成其他函数式编程

00:30:01.100 --> 00:30:05.120
语言，但很多Java程序员

00:30:03.080 --> 00:30:06.620
不是函数式程序员，它

00:30:05.120 --> 00:30:08.840
确实采取了不同的思维方式

00:30:06.620 --> 00:30:10.580
关于实际起作用的事情

00:30:08.840 --> 00:30:13.460
正确编程，我相信你

00:30:10.580 --> 00:30:16.100
我了解到如果你来的话很难

00:30:13.460 --> 00:30:18.050
在我的小溪和Lambdas上谈论这个

00:30:16.100 --> 00:30:19.790
与斯图尔特·马克思的早晨，你会看到

00:30:18.050 --> 00:30:22.970
糟糕的是我可以使用功能编写代码

00:30:19.790 --> 00:30:24.590
编程还是很有趣

00:30:22.970 --> 00:30:27.080
关于lambda表达式和

00:30:24.590 --> 00:30:29.210
 lambda演算就是lambda演算

00:30:27.080 --> 00:30:31.700
和咀嚼机是完全

00:30:29.210 --> 00:30:34.790
现在等效的图灵机

00:30:31.700 --> 00:30:38.330
具有图灵完整语言Java C 

00:30:34.790 --> 00:30:41.420
 C ++甚至JavaScript都完成了图灵

00:30:38.330 --> 00:30:44.620
那么任何可以解决的问题

00:30:41.420 --> 00:30:48.140
电脑可以用这种语言解决

00:30:44.620 --> 00:30:51.740
 Lambda微积分在术语上是等效的

00:30:48.140 --> 00:30:53.330
他们在图灵工作的方式

00:30:51.740 --> 00:30:54.730
机器，这意味着任何问题

00:30:53.330 --> 00:30:59.590
您可以通过计算解决

00:30:54.730 --> 00:31:01.540
可以使用lambda演算来解决，但是

00:30:59.590 --> 00:31:04.180
这会让你头疼相信我

00:31:01.540 --> 00:31:07.240
至少对我有用，我会解释

00:31:04.180 --> 00:31:11.230
随着我们经历的更多

00:31:07.240 --> 00:31:14.590
现在的想法是，如果我们

00:31:11.230 --> 00:31:17.200
只使用lambda表达式，所以我们不

00:31:14.590 --> 00:31:18.670
将要使用的任何原始类型

00:31:17.200 --> 00:31:20.290
不会使用任何我们不会的运算符

00:31:18.670 --> 00:31:22.180
现在将要使用的任何东西我们都不会使用

00:31:20.290 --> 00:31:23.700
任何对象

00:31:22.180 --> 00:31:26.470
将使用lambda表达式

00:31:23.700 --> 00:31:27.790
我们将有一个函数式接口

00:31:26.470 --> 00:31:30.490
必须有一个函数式接口

00:31:27.790 --> 00:31:33.520
为了创建一个lambda表达式

00:31:30.490 --> 00:31:35.410
我们可以用这项权利做什么？ 

00:31:33.520 --> 00:31:37.480
首先是我们的函数式接口

00:31:35.410 --> 00:31:40.450
所以我们最初将其称为

00:31:37.480 --> 00:31:43.330
 lambda好的，lambda将会有

00:31:40.450 --> 00:31:46.090
一种方法一种抽象方法称为

00:31:43.330 --> 00:31:48.430
 apply Apply将参数a 

00:31:46.090 --> 00:31:50.230
 lambda表达式并返回一个lambda 

00:31:48.430 --> 00:31:53.470
表达，以便我们可以将它们链接起来

00:31:50.230 --> 00:31:55.750
在一起非常容易，所以现在我们有了

00:31:53.470 --> 00:31:57.640
开始思考，我们如何

00:31:55.750 --> 00:31:58.960
如果我们不仅在Java中做事情， 

00:31:57.640 --> 00:32:02.230
我们将不使用的原始类型

00:31:58.960 --> 00:32:04.330
操作员很好，第一件事是我们

00:32:02.230 --> 00:32:06.880
需要一个lambda表达式来代表我

00:32:04.330 --> 00:32:08.020
密度，所以身份是您通过的地方

00:32:06.880 --> 00:32:11.320
和你得到相同的东西

00:32:08.020 --> 00:32:12.550
回到伟大，所以我们可以代表，我们

00:32:11.320 --> 00:32:14.500
可以创建一个名为的lambda表达式

00:32:12.550 --> 00:32:16.480
身份，并返回一个lambda 

00:32:14.500 --> 00:32:18.550
您在其中传递参数的表达式

00:32:16.480 --> 00:32:20.890
它返回相同的参数，所以它

00:32:18.550 --> 00:32:24.100
就是把你给的东西还给你

00:32:20.890 --> 00:32:25.810
如此简单和红色，我实际上

00:32:24.100 --> 00:32:27.730
使用lambda表示法是因为

00:32:25.810 --> 00:32:29.200
有时候他实际上变得容易得多

00:32:27.730 --> 00:32:32.200
在表示法领域理解

00:32:29.200 --> 00:32:34.870
而不是Java代码，所以

00:32:32.200 --> 00:32:35.980
我们第一个拥有lambda身份

00:32:34.870 --> 00:32:37.240
几张幻灯片，我也要告诉你

00:32:35.980 --> 00:32:38.560
类中的等效匿名

00:32:37.240 --> 00:32:40.600
因为有时候这会使它有点

00:32:38.560 --> 00:32:41.680
有点容易理解，所以在这种情况下

00:32:40.600 --> 00:32:44.680
我们正在创建一个称为身份的lambda 

00:32:41.680 --> 00:32:46.240
这是一个新的lambda，然后有一个

00:32:44.680 --> 00:32:48.730
 apply方法的实现

00:32:46.240 --> 00:32:52.060
接受一个λX并返回X好吧

00:32:48.730 --> 00:32:53.710
好，所以接下来我们需要一些原始的

00:32:52.060 --> 00:32:56.320
类型，所以我们要创建布尔值

00:32:53.710 --> 00:32:58.720
表示是非，所以我们将

00:32:56.320 --> 00:33:00.880
以false开头，在这种情况下为false 

00:32:58.720 --> 00:33:03.070
是一个lambda表达式，它总是

00:33:00.880 --> 00:33:04.940
返回我们的lambda表达式

00:33:03.070 --> 00:33:07.039
有身份

00:33:04.940 --> 00:33:08.119
好吧，我们会得到更多

00:33:07.039 --> 00:33:09.979
复杂，所以我们有一个lambda 

00:33:08.119 --> 00:33:11.840
表达式F返回另一个

00:33:09.979 --> 00:33:15.649
 lambda表达式是身份

00:33:11.840 --> 00:33:16.879
 lambda表达式，如果我们只是

00:33:15.649 --> 00:33:18.590
看看等效的匿名内部

00:33:16.879 --> 00:33:20.989
上课我们只有两层

00:33:18.590 --> 00:33:23.419
 lambda表达式在那里什么都没有

00:33:20.989 --> 00:33:24.440
非常令人兴奋，但我不会

00:33:23.419 --> 00:33:26.419
向您显示更多匿名内部

00:33:24.440 --> 00:33:30.559
上课，因为它确实也有办法

00:33:26.419 --> 00:33:33.109
相反的布尔假的很多代码是

00:33:30.559 --> 00:33:34.879
显然是布尔型，所以在这种情况下

00:33:33.109 --> 00:33:37.279
我们将有一个lambda表达式

00:33:34.879 --> 00:33:40.999
返回一个永远不会去的lambda 

00:33:37.279 --> 00:33:43.729
是身份，在这种情况下，我们可以说

00:33:40.999 --> 00:33:45.830
好吧，这与真实的相反

00:33:43.729 --> 00:33:48.229
相反的力量真的很棒，所以我们有

00:33:45.830 --> 00:33:51.139
一个lambda表达式这样做

00:33:48.229 --> 00:33:52.909
现在我们接下来有数十亿美元

00:33:51.139 --> 00:33:56.749
需要数字，所以有些事情叫做

00:33:52.909 --> 00:33:58.159
教堂数字教堂数字我们可以

00:33:56.749 --> 00:34:00.409
可以有点数学

00:33:58.159 --> 00:34:03.470
灵感在这里，我们可以说

00:34:00.409 --> 00:34:05.299
如果添加一个标识，则添加标识为0 

00:34:03.470 --> 00:34:08.539
从任何数字中减去0 

00:34:05.299 --> 00:34:11.119
后面的数字相同，因此与

00:34:08.539 --> 00:34:13.309
身份，我们已经知道lambda是什么

00:34:11.119 --> 00:34:15.200
身份的表达就是我们要做的

00:34:13.309 --> 00:34:17.809
在这种情况下，将使用lambda 

00:34:15.200 --> 00:34:20.629
表示身份的表达式

00:34:17.809 --> 00:34:22.480
数字0很有意思

00:34:20.629 --> 00:34:25.490
从...的角度来看

00:34:22.480 --> 00:34:27.440
如果您使用我们的布尔值true和false 

00:34:25.490 --> 00:34:29.929
考虑一下C编程C语言

00:34:27.440 --> 00:34:32.569
如果您没有在C中看到您，则不会

00:34:29.929 --> 00:34:36.980
布尔类型，因此如果您评估if 

00:34:32.569 --> 00:34:39.889
语句，则假值为0 

00:34:36.980 --> 00:34:41.659
 true是除0以外的任何值，因此在此

00:34:39.889 --> 00:34:45.500
区分大小写与身份相同

00:34:41.659 --> 00:34:47.629
表达，所以也是，所以我们

00:34:45.500 --> 00:34:50.059
最终以0结束，因此有种联系

00:34:47.629 --> 00:34:51.679
在一起很棒的另一件事是

00:34:50.059 --> 00:34:54.289
你可以这样想

00:34:51.679 --> 00:34:57.139
函数f正在应用于

00:34:54.289 --> 00:34:58.849
 lambda表达式0次，现在可能

00:34:57.139 --> 00:35:01.309
看芒果好吧，那是什么意思

00:34:58.849 --> 00:35:04.130
如果我指的不是0次，而是

00:35:01.309 --> 00:35:06.289
如果我们看1还好，那么

00:35:04.130 --> 00:35:08.240
 1的lambda表达式是lambda 

00:35:06.289 --> 00:35:12.230
表达式，我们取X，然后我们

00:35:08.240 --> 00:35:14.390
将X应用于函数f 

00:35:12.230 --> 00:35:16.039
像我所说的已经过去了

00:35:14.390 --> 00:35:17.750
得到一点Java程序

00:35:16.039 --> 00:35:20.600
已经开始有点

00:35:17.750 --> 00:35:23.300
这里很复杂，这就是我们所做的

00:35:20.600 --> 00:35:25.430
我们将函数f应用于X并

00:35:23.300 --> 00:35:28.520
成为我们lambda表达的一部分

00:35:25.430 --> 00:35:30.140
关键是如果你看

00:35:28.520 --> 00:35:32.240
 lambda演算lambda演算不

00:35:30.140 --> 00:35:34.610
使用循环，所以我们永远不会使用for 

00:35:32.240 --> 00:35:37.000
 Lambda演算中的循环Lambda演算中的循环

00:35:34.610 --> 00:35:40.940
反复做事

00:35:37.000 --> 00:35:42.620
递归调用相同的函数

00:35:40.940 --> 00:35:45.260
如果我们看一下lambda表达式

00:35:42.620 --> 00:35:48.830
 2我们要做的就是应用功能

00:35:45.260 --> 00:35:52.730
递归两次，所以现在我们有X去

00:35:48.830 --> 00:35:54.260
到F点的应用X的F点的应用

00:35:52.730 --> 00:35:55.880
设置，您可以继续

00:35:54.260 --> 00:35:58.160
你想代表很多次

00:35:55.880 --> 00:36:01.220
大于2的数字我不会

00:35:58.160 --> 00:36:04.400
这样做是因为我认为你已经足够了

00:36:01.220 --> 00:36:07.790
现在知道这个主意，我们需要看看

00:36:04.400 --> 00:36:09.770
我们如何去做一些数学

00:36:07.790 --> 00:36:12.410
关于我们是否要增加数量

00:36:09.770 --> 00:36:13.970
实际上，我们拥有一口井

00:36:12.410 --> 00:36:15.620
不太困难，因为如果您认为

00:36:13.970 --> 00:36:18.130
关于它，我们需要做的就是

00:36:15.620 --> 00:36:21.490
需要再次将该功能应用于该功能

00:36:18.130 --> 00:36:24.320
所以lambda表示法表明

00:36:21.490 --> 00:36:27.620
这样，就后继者而言

00:36:24.320 --> 00:36:29.510
 lambda表达式以n结束

00:36:27.620 --> 00:36:31.820
是我们的电话号码，然后我们要申请

00:36:29.510 --> 00:36:34.700
函数f到那一次

00:36:31.820 --> 00:36:38.200
我们得到F点适用n点适用F 

00:36:34.700 --> 00:36:40.340
 X的点适用，所以后继者是

00:36:38.200 --> 00:36:42.640
如果我们只想简单地说

00:36:40.340 --> 00:36:46.250
再次应用该功能

00:36:42.640 --> 00:36:48.050
前辈比较棘手

00:36:46.250 --> 00:36:50.330
因为我们在做的是

00:36:48.050 --> 00:36:52.430
实际上删除了对

00:36:50.330 --> 00:36:54.380
功能，使生活成为

00:36:52.430 --> 00:36:56.720
有点难，我不会

00:36:54.380 --> 00:36:58.130
解释一下，我只是要告诉你

00:36:56.720 --> 00:37:00.229
这是什么

00:36:58.130 --> 00:37:01.880
这就是lambda音符

00:37:00.229 --> 00:37:03.349
永远是lambda表示法，因为那时我们

00:37:01.880 --> 00:37:06.049
开始得到各种各样的多余字母

00:37:03.349 --> 00:37:10.160
因此涉及GH和U以及X 

00:37:06.049 --> 00:37:12.200
等效的Java代码变成这样

00:37:10.160 --> 00:37:15.200
它变得很讨厌

00:37:12.200 --> 00:37:17.569
我们的大门n FX并在

00:37:15.200 --> 00:37:19.069
我们不会使用它，所以我

00:37:17.569 --> 00:37:21.200
认为那是相当

00:37:19.069 --> 00:37:22.729
如果您真的遵循它，将会很复杂

00:37:21.200 --> 00:37:26.900
通过它确实有效， 

00:37:22.729 --> 00:37:29.420
保证，那么让我们看看如何

00:37:26.900 --> 00:37:31.789
我们几乎可以将两个数字相加

00:37:29.420 --> 00:37:33.349
变成我们所处的那种

00:37:31.789 --> 00:37:36.470
要做一些有趣的事情

00:37:33.349 --> 00:37:39.799
加法只是重复递增

00:37:36.470 --> 00:37:43.700
所以如果我想在M上加上n 

00:37:39.799 --> 00:37:46.220
就像说加1到M n次，所以你

00:37:43.700 --> 00:37:47.960
已经知道如何向函数加1 

00:37:46.220 --> 00:37:51.619
所以我们在这种情况下要做的就是

00:37:47.960 --> 00:37:54.079
 n次加1到函数结束

00:37:51.619 --> 00:37:56.239
这种更复杂的方式

00:37:54.079 --> 00:37:59.839
做我们有百万外汇和

00:37:56.239 --> 00:38:01.369
所有适用权减去

00:37:59.839 --> 00:38:03.049
再次，我们不会去打扰

00:38:01.369 --> 00:38:04.700
过多的细节我们将使用

00:38:03.049 --> 00:38:06.619
缩小功能

00:38:04.700 --> 00:38:08.509
一些代码，但我们可以做同样的事情

00:38:06.619 --> 00:38:14.479
反复应用

00:38:08.509 --> 00:38:16.369
递减操作来装饰好吧

00:38:14.479 --> 00:38:18.739
然后我想我们想做的对

00:38:16.369 --> 00:38:25.339
用lambdas做些简单的事情，让我们添加一下

00:38:18.739 --> 00:38:28.369
 2加2仅使用lambdas，所以我们

00:38:25.339 --> 00:38:30.440
知道2的lambda适用

00:38:28.369 --> 00:38:31.369
函数两次递归

00:38:30.440 --> 00:38:34.700
就是这么简单

00:38:31.369 --> 00:38:36.829
 FXF点应用F点应用基础和

00:38:34.700 --> 00:38:42.799
我们知道lambda表达式用于

00:38:36.829 --> 00:38:44.049
加号是MN FX，但我们有很多建议

00:38:42.799 --> 00:38:46.910
需要结合这两个

00:38:44.049 --> 00:38:48.349
有趣的是，我们可以这样说

00:38:46.910 --> 00:38:51.349
很简单，这是Java代码

00:38:48.349 --> 00:38:53.420
 lambda 4等于Plus，这就是我们的lambda 

00:38:51.349 --> 00:38:55.430
表达式，然后我们将其应用于2 

00:38:53.420 --> 00:38:57.589
而且我们也对此适用

00:38:55.430 --> 00:39:00.380
递归两次调用两次

00:38:57.589 --> 00:39:03.529
也有价值观，如果你写那种

00:39:00.380 --> 00:39:06.170
就像你结束的数学一样

00:39:03.529 --> 00:39:08.479
等于4等于2 2 

00:39:06.170 --> 00:39:09.790
所谓的波兰语符号

00:39:08.479 --> 00:39:11.020
知道你知道

00:39:09.790 --> 00:39:13.450
对于你们这些足以记住的人

00:39:11.020 --> 00:39:17.470
像很早就计算出P计算器

00:39:13.450 --> 00:39:18.880
我认为使用了反向抛光，所以这是

00:39:17.470 --> 00:39:20.590
正向抛光而不是反向抛光

00:39:18.880 --> 00:39:23.350
波兰符号，但你明白了

00:39:20.590 --> 00:39:24.880
为了添加东西，我们可以

00:39:23.350 --> 00:39:26.710
实际上只能使用lambda做到这一点

00:39:24.880 --> 00:39:30.460
表达式，所以我们可以说lambda 

00:39:26.710 --> 00:39:33.400
是加号申请写申请如何

00:39:30.460 --> 00:39:34.630
我们知道那行得通吗

00:39:33.400 --> 00:39:35.800
是有趣的地方，因为

00:39:34.630 --> 00:39:37.600
我们将要做的是

00:39:35.800 --> 00:39:40.030
如何实际显示这个阶段

00:39:37.600 --> 00:39:41.800
我必须说，其中一件事

00:39:40.030 --> 00:39:44.020
当我这样做的时候，我坐在

00:39:41.800 --> 00:39:46.570
在桌子上，我儿子十岁

00:39:44.020 --> 00:39:48.460
他跌倒的时候我在外面乱涂乱画

00:39:46.570 --> 00:39:49.870
东西，我尝试解决问题， 

00:39:48.460 --> 00:39:51.670
他对我说你爸爸我在做什么

00:39:49.870 --> 00:39:55.660
说我正在尝试找出两个

00:39:51.670 --> 00:39:56.890
再加上两个他看着你看着我

00:39:55.660 --> 00:39:59.640
就像我很蠢，他说的很好

00:39:56.890 --> 00:40:02.410
易爸爸，四岁

00:39:59.640 --> 00:40:04.150
所以我说我想用lambda 

00:40:02.410 --> 00:40:06.280
为此，我向他展示了

00:40:04.150 --> 00:40:11.530
我一直在看的写作没有

00:40:06.280 --> 00:40:14.440
不，现在是四个，所以我们会

00:40:11.530 --> 00:40:16.570
要做的是，我们将采用Edition lambda 

00:40:14.440 --> 00:40:18.310
表达式，所以我们有M而我们有n 

00:40:16.570 --> 00:40:20.050
我们将要加在一起

00:40:18.310 --> 00:40:23.410
在M的情况下，我们将替换M 

00:40:20.050 --> 00:40:25.540
有两个的lambda表达式，所以我们

00:40:23.410 --> 00:40:27.160
获得稍长的lambda表达式

00:40:25.540 --> 00:40:31.360
我用红色突出显示了我们要替换的地方

00:40:27.160 --> 00:40:33.430
 M用lambda表达式表示两个

00:40:31.360 --> 00:40:34.900
我们也把他们从前面带走

00:40:33.430 --> 00:40:38.590
因为现在我们实际上正在申请

00:40:34.900 --> 00:40:40.570
该功能，然后什么

00:40:38.590 --> 00:40:42.940
我们需要为n做同样的事情

00:40:40.570 --> 00:40:44.920
 n也为2，所以我们替换N 

00:40:42.940 --> 00:40:47.110
我们在那里有lambda 

00:40:44.920 --> 00:40:50.080
 2的表达式，最后得到

00:40:47.110 --> 00:40:52.990
 Lambda表达式很长，但它

00:40:50.080 --> 00:40:55.960
看起来还不太适合，所以我们

00:40:52.990 --> 00:40:58.930
必须对此做一些减少，如果

00:40:55.960 --> 00:41:00.940
我们切换了我们现在需要说的

00:40:58.930 --> 00:41:03.580
没关系，所以我们有外汇，然后我们

00:41:00.940 --> 00:41:06.220
有了这个，我们在这里有了蓝色

00:41:03.580 --> 00:41:08.530
我们在说f是lambda 

00:41:06.220 --> 00:41:10.510
返回X的表达式转到

00:41:08.530 --> 00:41:13.630
 F点适用F点适用X点适用

00:41:10.510 --> 00:41:17.050
 F的好处是F 

00:41:13.630 --> 00:41:19.390
是我们正在应用F，但F是

00:41:17.050 --> 00:41:21.670
如果您愿意的话，可以选择一个变量

00:41:19.390 --> 00:41:25.510
简单的还原，我们实质上

00:41:21.670 --> 00:41:27.960
关闭应用并删除F，所以现在X 

00:41:25.510 --> 00:41:32.109
转到F点X的F点应用

00:41:27.960 --> 00:41:34.059
如果我们在这里做同样的事情，我们已经

00:41:32.109 --> 00:41:36.549
这里有一个lambda表达式，我们有F 

00:41:34.059 --> 00:41:38.710
我们想将F应用于该lambda 

00:41:36.549 --> 00:41:41.950
表达，然后我们可以做同样的事情

00:41:38.710 --> 00:41:45.760
减少，所以我们得到X到F 

00:41:41.950 --> 00:41:47.859
点应用F的5x点，那么我们

00:41:45.760 --> 00:41:49.599
我们需要做的是

00:41:47.859 --> 00:41:51.730
被压缩，但我们仍然得到F 

00:41:49.599 --> 00:41:54.040
转到X转到X转到我们的f 

00:41:51.730 --> 00:41:56.890
申请等等，但我们需要申请

00:41:54.040 --> 00:41:59.290
这整个蓝色，它实际上在

00:41:56.890 --> 00:42:02.859
在申请范围内，我们将申请X 

00:41:59.290 --> 00:42:05.290
再次，X是一个容易消除的

00:42:02.859 --> 00:42:06.910
因为它是相同的变量，所以我们结束

00:42:05.290 --> 00:42:08.500
由F点套用X的F点套用

00:42:06.910 --> 00:42:10.230
但现在事情有点多了

00:42:08.500 --> 00:42:12.910
复杂，因为我们必须申请

00:42:10.230 --> 00:42:14.950
我们有X整个这个lambda 

00:42:12.910 --> 00:42:21.040
表达式F点适用F点适用X 

00:42:14.950 --> 00:42:25.210
然后减少到是，所以我们得到

00:42:21.040 --> 00:42:27.190
我们减少X改变是的

00:42:25.210 --> 00:42:29.589
然后我们减少它，最后得到F 

00:42:27.190 --> 00:42:31.569
转到X转到F 

00:42:29.589 --> 00:42:35.559
 F的适用F的适用F的适用

00:42:31.569 --> 00:42:38.589
 X是四个，我们证明了两个

00:42:35.559 --> 00:42:43.109
加两个是四，我们证明了我们

00:42:38.589 --> 00:42:43.109
只能做到新的热情表达

00:42:46.770 --> 00:42:52.480
就像我说过花了我一段时间

00:42:49.240 --> 00:42:57.490
弄直我的脑袋

00:42:52.480 --> 00:43:00.910
然后非常总结lambda表达式

00:42:57.490 --> 00:43:03.099
非常有用的非常简洁的方法

00:43:00.910 --> 00:43:04.930
代表行为，以便您可以通过

00:43:03.099 --> 00:43:06.630
作为变量，您可以分配给

00:43:04.930 --> 00:43:08.980
可变电容器作为参数

00:43:06.630 --> 00:43:11.260
比匿名内部更好的性能

00:43:08.980 --> 00:43:13.059
上课，所以如果您认为自己知道

00:43:11.260 --> 00:43:14.920
就类似性能编程而言

00:43:13.059 --> 00:43:16.299
那么lambda表达式是更好的方法

00:43:14.920 --> 00:43:18.339
做事比不内在的内在

00:43:16.299 --> 00:43:21.520
类方法的引用是偶数

00:43:18.339 --> 00:43:23.109
比后来的lambda好一点

00:43:21.520 --> 00:43:25.690
表达式显式lambda表达式

00:43:23.109 --> 00:43:27.520
正如我在这里所说，您可以使用它们很奇怪

00:43:25.690 --> 00:43:28.809
以奇妙的方式，但我当然

00:43:27.520 --> 00:43:30.849
不建议尝试全部写

00:43:28.809 --> 00:43:32.980
您的代码仅使用lambda表达式

00:43:30.849 --> 00:43:35.799
如果您想用Java做2加2 

00:43:32.980 --> 00:43:39.670
使用原始int类型使用加号

00:43:35.799 --> 00:43:43.299
操作员要容易得多

00:43:39.670 --> 00:43:44.170
信息就像我说的那样

00:43:43.299 --> 00:43:46.210
来自埃里克的演讲

00:43:44.170 --> 00:43:49.210
有一个视频，他在

00:43:46.210 --> 00:43:52.839
 devoxx在苏黎世的一个盒子里， 

00:43:49.210 --> 00:43:55.299
 Jarek的工作基于什么

00:43:52.839 --> 00:43:58.029
是Dickson Yang的博客，为

00:43:55.299 --> 00:44:01.029
微软和他在C震惊中做到了这一点，所以

00:43:58.029 --> 00:44:02.500
这是类似的事情，但他是

00:44:01.029 --> 00:44:05.740
关于这一切的更多细节

00:44:02.500 --> 00:44:07.260
这样的工作，所以谢谢

00:44:05.740 --> 00:44:11.969
非常

00:44:07.260 --> 00:44:11.969
 [掌声] 

