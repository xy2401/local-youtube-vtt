WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.690 --> 00:00:06.790
好吧，我认为现在是时候

00:00:06.040 --> 00:00:08.800
在路上展示

00:00:06.790 --> 00:00:11.950
感谢您显示何时加载

00:00:08.800 --> 00:00:13.809
测试今天的话题当然是简

00:00:11.950 --> 00:00:16.869
在五个，新的机会是

00:00:13.809 --> 00:00:18.220
在JVM上测试我叫Sam 

00:00:16.869 --> 00:00:19.359
布兰南我是Java的春天

00:00:18.220 --> 00:00:22.240
一家名为Swift的公司的顾问

00:00:19.359 --> 00:00:24.550
瑞士苏黎世的矿山教练教练

00:00:22.240 --> 00:00:26.650
等，但是内心很努力

00:00:24.550 --> 00:00:27.730
我曾经是约

00:00:26.650 --> 00:00:29.230
 20年

00:00:27.730 --> 00:00:31.749
自从春季游民通勤以来

00:00:29.230 --> 00:00:33.520
 2007年，当我最初重写时

00:00:31.749 --> 00:00:34.870
整体的弹簧测试支持

00:00:33.520 --> 00:00:37.750
基于注释的东西支持

00:00:34.870 --> 00:00:41.230
测试GJ和for etc，我一直

00:00:37.750 --> 00:00:45.370
自10月以来，j25的核心提交者

00:00:41.230 --> 00:00:48.130
 Swift矿山专家在2015年春季和

00:00:45.370 --> 00:00:50.110
 Java您可以在网上找到我们

00:00:48.130 --> 00:00:52.840
一些关于如何使用设计的咨询

00:00:50.110 --> 00:00:55.030
五个更好的也许春天等所以

00:00:52.840 --> 00:00:57.130
我们谈论推动动力的议程

00:00:55.030 --> 00:00:58.420
像我们为什么那样改变

00:00:57.130 --> 00:01:00.280
那我五点钟谈简

00:00:58.420 --> 00:01:04.030
详细介绍春季五

00:01:00.280 --> 00:01:06.640
然后如果有时间允许进行问答

00:01:04.030 --> 00:01:07.750
您对45分钟的格式不满意

00:01:06.640 --> 00:01:09.430
就像我听到其他发言者说的那样

00:01:07.750 --> 00:01:10.990
随时抱怨这会很好

00:01:09.430 --> 00:01:13.480
如果不幸的是我们有一个小时

00:01:10.990 --> 00:01:15.730
赶了45分钟但没有

00:01:13.480 --> 00:01:16.990
担心我们今晚要在简的

00:01:15.730 --> 00:01:18.430
五，如果他们还有更多问题， 

00:01:16.990 --> 00:01:19.840
如果你想见我的话

00:01:18.430 --> 00:01:21.520
现场代码更多的东西在这里答案

00:01:19.840 --> 00:01:22.990
还有更多问题，请到

00:01:21.520 --> 00:01:26.530
也会很好

00:01:22.990 --> 00:01:29.409
所以先写出谁写的手

00:01:26.530 --> 00:01:33.970
测试没事

00:01:29.409 --> 00:01:36.280
谁使用J单位谁可以使用任何人

00:01:33.970 --> 00:01:40.270
除了珍妮特以外，是的

00:01:36.280 --> 00:01:42.159
测试G也许是Spock的2％ 

00:01:40.270 --> 00:01:43.870
像其他一些

00:01:42.159 --> 00:01:46.960
像是学者考试或其他任何东西

00:01:43.870 --> 00:01:49.270
没有人可以，所以每个人都Java 

00:01:46.960 --> 00:01:51.490
 Java Jane我没问过维珍

00:01:49.270 --> 00:01:54.880
简，因为我想对任何人都还对

00:01:51.490 --> 00:01:57.729
三点钟使用简哦，对不起，对不起

00:01:54.880 --> 00:01:59.920
灵魂也是如此，我们有我们有

00:01:57.729 --> 00:02:01.780
你实际上涵盖了，为什么我们有一个

00:01:59.920 --> 00:02:03.640
简的新版本，如果您的

00:02:01.780 --> 00:02:04.840
经历过简，而你已经尝试过

00:02:03.640 --> 00:02:08.229
在你身上实施东西，你可能

00:02:04.840 --> 00:02:09.369
知道一些原因，但刚刚结束

00:02:08.229 --> 00:02:11.349
对于那些不知道的人

00:02:09.369 --> 00:02:13.510
所以珍妮被释放了十多年

00:02:11.349 --> 00:02:15.129
从那以后，我们发生了很多变化

00:02:13.510 --> 00:02:15.730
测试社区的需求

00:02:15.129 --> 00:02:17.830
成熟

00:02:15.730 --> 00:02:19.810
和我们的期望已经增长

00:02:17.830 --> 00:02:21.489
从她的框架中期望，所以我经常说

00:02:19.810 --> 00:02:23.200
 J dude是个可怕的名字，因为它有

00:02:21.489 --> 00:02:24.489
单词单元融入其中，人们

00:02:23.200 --> 00:02:25.540
认为这仅与单元测试有关

00:02:24.489 --> 00:02:26.970
显然现在已经不是了

00:02:25.540 --> 00:02:29.310
正确的集成测试系统测试

00:02:26.970 --> 00:02:31.840
打算测试各种东西

00:02:29.310 --> 00:02:34.120
贾纳（Jana）的另外四件事

00:02:31.840 --> 00:02:35.769
他们实际上是模块化的，数量不多

00:02:34.120 --> 00:02:39.489
那里有种大泥球

00:02:35.769 --> 00:02:41.200
只是珍妮特罐子和磁盘上

00:02:39.489 --> 00:02:42.510
测试发现并执行那些

00:02:41.200 --> 00:02:44.530
问题紧密耦合

00:02:42.510 --> 00:02:46.090
扩展性很大的空间

00:02:44.530 --> 00:02:48.849
那里的改善，我们希望有

00:02:46.090 --> 00:02:50.799
实现了这一点，但最后但并非最不重要的一点

00:02:48.849 --> 00:02:52.900
让我们不要忘记现代版本

00:02:50.799 --> 00:02:55.540
 JVM的正确性，所以我们有Java 8和

00:02:52.900 --> 00:02:58.299
甚至Java 9，当然也只有Jana 

00:02:55.540 --> 00:03:02.380
理论上支持Java 5，因此

00:02:58.299 --> 00:03:03.880
用API来表达，所以在Jana 4中

00:03:02.380 --> 00:03:06.310
这是一个主要的概念

00:03:03.880 --> 00:03:07.690
跑步者api的功能非常强大

00:03:06.310 --> 00:03:09.790
其实你可以做任何可以做的事

00:03:07.690 --> 00:03:10.959
它，但您不能合并跑步者，所以

00:03:09.790 --> 00:03:12.280
例如，如果您尝试使用

00:03:10.959 --> 00:03:13.989
参数化来自简单位的跑步者和

00:03:12.280 --> 00:03:16.209
春天的春天赛跑者

00:03:13.989 --> 00:03:18.099
不行对某事不起作用

00:03:16.209 --> 00:03:20.680
我们在这里的下一张幻灯片有点

00:03:18.099 --> 00:03:22.780
这么开玩笑，你可能会以为

00:03:20.680 --> 00:03:23.799
对于超酷的规则，否则您可能会

00:03:22.780 --> 00:03:26.620
阅读它，因为规则注定要被打破

00:03:23.799 --> 00:03:27.940
我想说规则是为了

00:03:26.620 --> 00:03:30.790
被打破，实际上总是

00:03:27.940 --> 00:03:32.440
不幸的是，在贾登47 

00:03:30.790 --> 00:03:33.700
您可以注释此方法规则

00:03:32.440 --> 00:03:34.900
遵守该规则并进行注册

00:03:33.700 --> 00:03:36.940
然后他们想出了一个

00:03:34.900 --> 00:03:39.940
带有测试演练的班级支持和

00:03:36.940 --> 00:03:41.200
 Jana 4/9您可以善加利用

00:03:39.940 --> 00:03:43.900
像方法级别或类

00:03:41.200 --> 00:03:45.670
水平，这很容易使用

00:03:43.900 --> 00:03:47.980
他们甚至可以结合在一起的情况是

00:03:45.670 --> 00:03:49.920
很好，但这是单条规则

00:03:47.980 --> 00:03:53.319
用于方法级别和

00:03:49.920 --> 00:03:55.269
类级别的回调加零

00:03:53.319 --> 00:03:57.940
支持我所谓的实例级别

00:03:55.269 --> 00:03:59.530
回调，例如

00:03:57.940 --> 00:04:02.049
曾经使用过弹簧支撑和规则

00:03:59.530 --> 00:04:03.400
我必须将其作为两个规则实施

00:04:02.049 --> 00:04:04.989
不幸的是，这很丑陋

00:04:03.400 --> 00:04:06.910
您必须说出样板代码

00:04:04.989 --> 00:04:08.260
想要春季班规则和

00:04:06.910 --> 00:04:11.819
弹簧方法规则

00:04:08.260 --> 00:04:14.530
想说我只想要春天吧

00:04:11.819 --> 00:04:16.570
发生了什么事

00:04:14.530 --> 00:04:18.130
关于我们，我们先到了简五

00:04:16.570 --> 00:04:19.950
我们开展了一项名为

00:04:18.130 --> 00:04:22.090
简·兰达

00:04:19.950 --> 00:04:24.310
人员-在这里列为主要人员之一

00:04:22.090 --> 00:04:26.470
他们是由一些人发起的

00:04:24.310 --> 00:04:28.390
德国人以前对简的提交者

00:04:26.470 --> 00:04:29.240
四岁时还有其他一些德国人加入

00:04:28.390 --> 00:04:30.919
和

00:04:29.240 --> 00:04:31.940
真的，我们所有人都在说话

00:04:30.919 --> 00:04:33.889
德国人只是一种

00:04:31.940 --> 00:04:37.250
巧合，我不知道可能只是

00:04:33.889 --> 00:04:38.900
因为德国人喜欢测试我

00:04:37.250 --> 00:04:41.270
不知道，我们最新的提交者是

00:04:38.900 --> 00:04:42.500
也是德国的，所以我们需要一些

00:04:41.270 --> 00:04:45.349
来自其他州的人们

00:04:42.500 --> 00:04:47.270
国家，无论如何，所以这是从

00:04:45.349 --> 00:04:49.970
 2015年7月至10月

00:04:47.270 --> 00:04:51.860
筹集了很多钱

00:04:49.970 --> 00:04:54.410
所在公司捐赠了六周的

00:04:51.860 --> 00:04:57.590
专职开发人员时间，包括

00:04:54.410 --> 00:04:59.449
药-谁也贡献了更多

00:04:57.590 --> 00:05:01.580
关键不仅是弹簧还支持

00:04:59.449 --> 00:05:03.889
 6月5日的倡议，因此，如果您

00:05:01.580 --> 00:05:05.630
在这里命名或您的公司，然后谢谢

00:05:03.889 --> 00:05:07.250
非常感谢您帮助我们入门

00:05:05.630 --> 00:05:08.720
什么可以帮助我们做到这一点帮助我们

00:05:07.250 --> 00:05:10.789
开工会议，我们有一些知名人士

00:05:08.720 --> 00:05:13.220
在Gradle的社区开发人员中

00:05:10.789 --> 00:05:15.500
 Ellijay和剪辑以及这些核心

00:05:13.220 --> 00:05:19.190
提交者聚集在一起，我们开始了

00:05:15.500 --> 00:05:21.409
开球，J和5开始，所以首先

00:05:19.190 --> 00:05:24.590
我们有一个原型，我们做了回发行

00:05:21.409 --> 00:05:27.860
在2015年12月，我们有了一个alpha 

00:05:24.590 --> 00:05:29.840
几个月后又迈出了一大步

00:05:27.860 --> 00:05:32.150
到介于两者之间的m1里程碑

00:05:29.840 --> 00:05:33.710
一年多的时间，情侣发布

00:05:32.150 --> 00:05:35.389
去加拿大是说2到3，因为

00:05:33.710 --> 00:05:36.800
第一个是snafu没有

00:05:35.389 --> 00:05:40.190
确实存在，所以我们真的不得不

00:05:36.800 --> 00:05:41.599
您可以使用然后5个Ogier这样

00:05:40.190 --> 00:05:45.139
希望你听说过

00:05:41.599 --> 00:05:47.870
 2017年9月10日至今

00:05:45.139 --> 00:05:50.120
几个小时前，我们发布了501， 

00:05:47.870 --> 00:05:52.880
一些小错误修复，以防万一您准备好了

00:05:50.120 --> 00:05:55.940
继续5哦，那是我们的位置

00:05:52.880 --> 00:05:57.560
简而言之，链接到5个是模块化的

00:05:55.940 --> 00:06:00.860
对，所以我们有很多模块

00:05:57.560 --> 00:06:02.360
看到它非常可扩展，我们

00:06:00.860 --> 00:06:04.219
喜欢认为它是现代的，很愚蠢

00:06:02.360 --> 00:06:05.599
 Java 8中的字符串，并具有一些现代

00:06:04.219 --> 00:06:09.380
土地表达和事物之类的功能

00:06:05.599 --> 00:06:11.060
像那样，另一个非常关键的事情

00:06:09.380 --> 00:06:13.099
我们很多考虑的是

00:06:11.060 --> 00:06:16.099
兼容性既向前又

00:06:13.099 --> 00:06:17.449
同时向后兼容

00:06:16.099 --> 00:06:18.650
那意味着初中

00:06:17.449 --> 00:06:21.110
平台，我将在

00:06:18.650 --> 00:06:23.509
分钟支持Jana 3/8和

00:06:21.110 --> 00:06:25.759
与我们所说的同时

00:06:23.509 --> 00:06:28.159
 Jana 5或新的Jupiter编程

00:06:25.759 --> 00:06:30.409
模型以及新的测试框架

00:06:28.159 --> 00:06:32.150
基于平台的可以

00:06:30.409 --> 00:06:33.530
与Jana港口基础设施一起运行，因此

00:06:32.150 --> 00:06:35.180
这意味着您可以使用旧的ID和

00:06:33.530 --> 00:06:36.229
您的旧账单工具，如果您想

00:06:35.180 --> 00:06:39.020
我们将看到我们正在获得支持

00:06:36.229 --> 00:06:40.490
在此过程中建立工具和想法

00:06:39.020 --> 00:06:42.650
每次使用燃油的方式

00:06:40.490 --> 00:06:43.100
特定跑步者的链

00:06:42.650 --> 00:06:44.990
平台

00:06:43.100 --> 00:06:46.760
叫简到平台，所以你只说

00:06:44.990 --> 00:06:48.170
我与简一起运行一个可以运行的平台

00:06:46.760 --> 00:06:51.710
在旧版本的Eclipse中

00:06:48.170 --> 00:06:53.600
 NetBeans IntelliJ等版本

00:06:51.710 --> 00:06:55.670
 um版本支持的条款显然

00:06:53.600 --> 00:06:58.070
工作八对吧，否则就不会

00:06:55.670 --> 00:06:59.390
现代是基线的权利，所以

00:06:58.070 --> 00:07:00.950
全部使用柠檬在Java 8中编译

00:06:59.390 --> 00:07:02.000
这样的表情，但是你

00:07:00.950 --> 00:07:03.830
当然可以用它来测试

00:07:02.000 --> 00:07:04.850
应用程序代码针对

00:07:03.830 --> 00:07:08.480
以前的版本不一样

00:07:04.850 --> 00:07:10.280
目标版本Java 9版本也

00:07:08.480 --> 00:07:13.550
支持您可能已经看到的所有权利

00:07:10.280 --> 00:07:15.140
在主题演讲中，马克将所有评论都公开了

00:07:13.550 --> 00:07:17.180
在那里建立源代码项目

00:07:15.140 --> 00:07:20.300
 5岁的简实际上就是其中一位

00:07:17.180 --> 00:07:22.340
在JDK 9上很好，如果每个

00:07:20.300 --> 00:07:23.540
文物具有稳定的自动模块

00:07:22.340 --> 00:07:25.750
为我们的单位命名，以便您可以使用它

00:07:23.540 --> 00:07:28.970
如果您选择并在模块路径上

00:07:25.750 --> 00:07:30.650
我们将支持扫描模块

00:07:28.970 --> 00:07:33.560
测试课程和内容的路径

00:07:30.650 --> 00:07:35.060
像5.1这样的计划

00:07:33.560 --> 00:07:36.710
现在我们有类路径扫描和

00:07:35.060 --> 00:07:41.750
支持，我们将添加模块路径和

00:07:36.710 --> 00:07:44.810
皮肤和支撑，所以这是

00:07:41.750 --> 00:07:47.090
非常关键，我会说几次

00:07:44.810 --> 00:07:49.190
没有勺子好吧没有J单元5 

00:07:47.090 --> 00:07:50.840
你不能说我四岁时有简

00:07:49.190 --> 00:07:52.010
将版本更改为5不会

00:07:50.840 --> 00:07:53.630
工作，因为我们实际上重写了

00:07:52.010 --> 00:07:56.600
一切，我们实际上在

00:07:53.630 --> 00:07:58.190
过程最终发明了三种

00:07:56.600 --> 00:07:59.360
我们一起没有意识到的项目

00:07:58.190 --> 00:08:01.400
开始，但一段时间后，我们意识到

00:07:59.360 --> 00:08:03.290
并分开，我们给他们起名字

00:08:01.400 --> 00:08:05.600
所以我们发布了Jaina平台

00:08:03.290 --> 00:08:07.220
在1.0版中，这是

00:08:05.600 --> 00:08:08.840
在...上启动测试框架

00:08:07.220 --> 00:08:10.130
 JVM，我说任何测试帧率

00:08:08.840 --> 00:08:11.480
并不意味着它必须使用Java 

00:08:10.130 --> 00:08:11.840
并不意味着一定要来自合资企业

00:08:11.480 --> 00:08:14.330
球队

00:08:11.840 --> 00:08:16.940
可能是Scala groovy Kotlin 

00:08:14.330 --> 00:08:18.440
您可以拥有，因此我们拥有

00:08:16.940 --> 00:08:20.930
被称为启动器和测试引擎

00:08:18.440 --> 00:08:23.420
 API是我们将它们内置在控制台中

00:08:20.930 --> 00:08:25.610
启动器内置对Gradle和

00:08:23.420 --> 00:08:27.470
专家，然后下一部分就是你

00:08:25.610 --> 00:08:29.480
可能实际上认为是J单元5 

00:08:27.470 --> 00:08:30.530
这是新的编程模型， 

00:08:29.480 --> 00:08:33.020
您将使用的扩展模型

00:08:30.530 --> 00:08:34.160
主要是如果您专注于J 

00:08:33.020 --> 00:08:37.539
正确的单位，因此称为Jana 

00:08:34.160 --> 00:08:40.570
木星很多人问为什么木星

00:08:37.539 --> 00:08:43.219
太阳的第五颗行星是什么

00:08:40.570 --> 00:08:45.050
木星碰巧也以J开头

00:08:43.219 --> 00:08:46.910
你喜欢J unit，所以很酷

00:08:45.050 --> 00:08:49.280
太好了

00:08:46.910 --> 00:08:51.590
你可以说j单位木星

00:08:49.280 --> 00:08:55.160
像这样发音，所以接下来

00:08:51.590 --> 00:08:57.170
部分，我们将其遗留在一些想法上

00:08:55.160 --> 00:08:58.400
嗯，我们认为可能会被填补的人

00:08:57.170 --> 00:09:01.400
感到侮辱，所以我说也许

00:08:58.400 --> 00:09:03.380
当他们决定年份是复古时

00:09:01.400 --> 00:09:05.390
支持以前发生的事情

00:09:03.380 --> 00:09:07.760
意味着我们有一个测试引擎

00:09:05.390 --> 00:09:09.860
如果可以，则支持运行Jane III 

00:09:07.760 --> 00:09:11.240
不幸的是，简也四点钟

00:09:09.860 --> 00:09:12.470
同时，实际上我们并非旨在

00:09:11.240 --> 00:09:13.910
支持简，你三个刚好碰巧

00:09:12.470 --> 00:09:16.280
简在四点支持两个三

00:09:13.910 --> 00:09:19.310
所以我们不能支持任何三个

00:09:16.280 --> 00:09:21.800
那个方面是这样，然后一些

00:09:19.310 --> 00:09:23.390
这里有些要点很重要，所以

00:09:21.800 --> 00:09:24.950
第一部分是革命权利

00:09:23.390 --> 00:09:26.750
这从来没有真正存在过

00:09:24.950 --> 00:09:28.520
平台真的是一个新的平台

00:09:26.750 --> 00:09:30.260
编写任何类型的测试框架

00:09:28.520 --> 00:09:32.450
在JVM上运行，每个人都可以受益

00:09:30.260 --> 00:09:35.240
由此您可以放入测试成帧器

00:09:32.450 --> 00:09:36.980
接下来的东西是进化的

00:09:35.240 --> 00:09:38.360
对，所以现在有货真价实

00:09:36.980 --> 00:09:40.670
木星有这个简

00:09:38.360 --> 00:09:42.260
简至五个但相似的程序模型

00:09:40.670 --> 00:09:44.510
只是一种进化而已

00:09:42.260 --> 00:09:46.370
我要说的最后一部分是必要的

00:09:44.510 --> 00:09:52.520
支持现有的呃测试代码

00:09:46.370 --> 00:09:54.950
因此，像Jane这样的启动器API 

00:09:52.520 --> 00:09:57.260
 core和Jane Fortran或已使用

00:09:54.950 --> 00:09:58.760
通过ID和启动框架的工具

00:09:57.260 --> 00:10:00.020
所以你自己可能不会用

00:09:58.760 --> 00:10:01.910
但是如果你想玩就可以

00:10:00.020 --> 00:10:04.400
它是基本的API 

00:10:01.910 --> 00:10:07.310
用于通过发现和执行测试

00:10:04.400 --> 00:10:08.600
一个或多个注册的测试引擎，以及

00:10:07.310 --> 00:10:10.910
为此，有一个所谓的

00:10:08.600 --> 00:10:12.400
启动器发现请求具有支持

00:10:10.910 --> 00:10:14.380
我们称之为选择器和过滤器

00:10:12.400 --> 00:10:17.900
选择器，您可以选择类似

00:10:14.380 --> 00:10:19.070
从课程路径中选择这个

00:10:17.900 --> 00:10:21.080
您可以选择的班级路径路线

00:10:19.070 --> 00:10:22.850
要扫描的软件包可以选择测试

00:10:21.080 --> 00:10:24.530
例如，您还可以选择

00:10:22.850 --> 00:10:26.150
个别测试方法

00:10:24.530 --> 00:10:29.800
可以过滤的东西和过滤

00:10:26.150 --> 00:10:31.970
根据类似um测试引擎ID或

00:10:29.800 --> 00:10:33.590
根据这样的类名进行过滤

00:10:31.970 --> 00:10:36.080
你知道像上课的模式

00:10:33.590 --> 00:10:37.520
标签和类似的东西很多

00:10:36.080 --> 00:10:39.590
实际上不支持Beacher的版本

00:10:37.520 --> 00:10:42.860
在IDE中，但我们认为这将会实现

00:10:39.590 --> 00:10:44.750
有时间获得反馈的条件，如果

00:10:42.860 --> 00:10:46.340
您想拥有自己的领带

00:10:44.750 --> 00:10:48.440
报告您可以的基础架构

00:10:46.340 --> 00:10:50.030
实现一个文本执行监听器，并

00:10:48.440 --> 00:10:51.800
获取有关所有事件的反馈

00:10:50.030 --> 00:10:53.930
在执行测试计划时发生

00:10:51.800 --> 00:10:55.730
然后再次是这个控制台启动器

00:10:53.930 --> 00:10:57.290
允许您实际运行测试

00:10:55.730 --> 00:10:58.580
如果需要，可以从控制台进行设置

00:10:57.290 --> 00:10:59.570
或从Java main之类运行它

00:10:58.580 --> 00:11:02.360
像那样

00:10:59.570 --> 00:11:04.730
因此，您可能会考虑测试引擎API 

00:11:02.360 --> 00:11:06.529
这个类似于跑步者API的人

00:11:04.730 --> 00:11:09.649
来自Jane接受测试引擎

00:11:06.529 --> 00:11:12.670
 API是通用的，不限于Java 

00:11:09.649 --> 00:11:16.250
本身，因此测试引擎会发现并

00:11:12.670 --> 00:11:19.459
在这里执行特定测试键

00:11:16.250 --> 00:11:21.199
编程模型，这些东西可以

00:11:19.459 --> 00:11:22.730
被自动注册到

00:11:21.199 --> 00:11:24.139
 Java服务层机制这么久

00:11:22.730 --> 00:11:25.699
因为他们在那里有正确的信息

00:11:24.139 --> 00:11:26.870
在罐子里，他们在上课的路上

00:11:25.699 --> 00:11:30.139
他们会自动注册

00:11:26.870 --> 00:11:31.730
对Jana Jupiter来说很酷

00:11:30.139 --> 00:11:34.040
我们有一个木星测试引擎，然后

00:11:31.730 --> 00:11:35.269
年份我们也有一个，你可以

00:11:34.040 --> 00:11:37.100
实现自己拥有的人

00:11:35.269 --> 00:11:38.750
实际这样做，这是直截了当的

00:11:37.100 --> 00:11:41.149
从这个页面我们有一个维基页面，我们

00:11:38.750 --> 00:11:42.769
允许人们发布他们的帖子

00:11:41.149 --> 00:11:44.779
他们编写的第三方扩展

00:11:42.769 --> 00:11:47.029
用于巨型平台或Gianna Jupiter 

00:11:44.779 --> 00:11:50.540
我们至少可以看到五个

00:11:47.029 --> 00:11:52.009
现有的外部测试引擎

00:11:50.540 --> 00:11:53.810
我提到的两个来自巨人

00:11:52.009 --> 00:11:56.000
团队本身，例如这样

00:11:53.810 --> 00:11:56.959
在顶部列出一些家伙网格

00:11:56.000 --> 00:11:58.670
一些基于的测试框架

00:11:56.959 --> 00:12:00.980
闭包之类的东西

00:11:58.670 --> 00:12:03.290
可在Scala Java中工作并遵循规范

00:12:00.980 --> 00:12:06.170
一个是给科特林的，是的，你可以检查一下

00:12:03.290 --> 00:12:08.779
如果需要的话也可以排除其他人

00:12:06.170 --> 00:12:10.819
这是全局，因为

00:12:08.779 --> 00:12:12.410
人们喜欢大图片，所以在这里

00:12:10.819 --> 00:12:14.209
我们在右中间有平台

00:12:12.410 --> 00:12:16.880
和一些除了ID和建立

00:12:14.209 --> 00:12:18.260
我们使用的工具以及您所从事的工作

00:12:16.880 --> 00:12:19.430
在顶部，你要写你的

00:12:18.260 --> 00:12:21.170
像这样的核心材料的旧测试更改

00:12:19.430 --> 00:12:23.660
它将使用老式的基础设施

00:12:21.170 --> 00:12:24.769
如果您使用的是吉安娜·朱庇特，我们会使用

00:12:23.660 --> 00:12:26.750
该基础架构或其中之一

00:12:24.769 --> 00:12:27.680
我提到的第三方测试引擎

00:12:26.750 --> 00:12:29.420
在上一张幻灯片上，或者如果您写

00:12:27.680 --> 00:12:30.769
你自己的，然后其他一切都是

00:12:29.420 --> 00:12:32.420
平台中间，所以如果你看

00:12:30.769 --> 00:12:35.420
在幕后，我们将看到

00:12:32.420 --> 00:12:37.130
旧的测试只是使用JUnit 4 12对

00:12:35.420 --> 00:12:39.019
我们在老式引擎上有这个简

00:12:37.130 --> 00:12:42.709
知道如何适应4岁时的Jane 

00:12:39.019 --> 00:12:44.209
到平台测试引擎API，然后

00:12:42.709 --> 00:12:45.889
我们有新的东西Jupiter API 

00:12:44.209 --> 00:12:47.420
这就是您针对的代码， 

00:12:45.889 --> 00:12:48.920
引擎是什么支持它，然后

00:12:47.420 --> 00:12:50.959
其他所有第三方都有

00:12:48.920 --> 00:12:52.639
在自己的引擎邀请中拥有自己的API 

00:12:50.959 --> 00:12:54.079
以及然后然后内部

00:12:52.639 --> 00:12:55.880
对，所以他们要使用的ID 

00:12:54.079 --> 00:12:57.139
这个这个发射器，我们有不同

00:12:55.880 --> 00:12:58.970
跑着跑的东西

00:12:57.139 --> 00:13:01.069
为Jana谈论，因为

00:12:58.970 --> 00:13:02.899
在那里，我们得到了Surefire的支持

00:13:01.069 --> 00:13:05.420
 Gradle支持和控制台启动器

00:13:02.899 --> 00:13:06.529
所有人都在使用相同的API，所以这是

00:13:05.420 --> 00:13:08.689
我说的是新的

00:13:06.529 --> 00:13:10.339
 JVM的机会，我们谈到了

00:13:08.689 --> 00:13:12.709
如果我们专注于5点左右的简

00:13:10.339 --> 00:13:13.350
那个权利就这么少

00:13:12.709 --> 00:13:15.300
绿色部分

00:13:13.350 --> 00:13:17.580
在这里，其他一切都更像

00:13:15.300 --> 00:13:18.840
平台权利，其他任何人都可以

00:13:17.580 --> 00:13:21.710
实现自己的东西，这就是为什么

00:13:18.840 --> 00:13:24.860
我说这是一个改变游戏规则的人

00:13:21.710 --> 00:13:26.670
因此，ID和构建支持条款

00:13:24.860 --> 00:13:28.770
 IntelliJ一直在支持我们

00:13:26.670 --> 00:13:29.850
很长一段时间，所以正如我提到的

00:13:28.770 --> 00:13:30.960
有一位核心开发者

00:13:29.850 --> 00:13:32.760
参加我们的启动会议，我们一直

00:13:30.960 --> 00:13:36.540
从那时起与她沟通

00:13:32.760 --> 00:13:37.560
自从Idea 2016 2以上

00:13:36.540 --> 00:13:39.630
他们有支持，他们有

00:13:37.560 --> 00:13:41.490
最近也支持ga 

00:13:39.630 --> 00:13:43.260
 Eclipse有点加入了游戏

00:13:41.490 --> 00:13:46.740
后来，但他们实际上非常好

00:13:43.260 --> 00:13:49.140
支持日食拍卖4.7那一个

00:13:46.740 --> 00:13:51.690
应该在下周发布

00:13:49.140 --> 00:13:53.280
我认为是第11个

00:13:51.690 --> 00:13:55.200
而实际上我正在使用发行版

00:13:53.280 --> 00:13:56.400
演示中的候选人之一

00:13:55.200 --> 00:13:59.100
今天

00:13:56.400 --> 00:14:00.920
我认为猴子说的是NetBeans 

00:13:59.100 --> 00:14:04.230
这个故事我会留在那

00:14:00.920 --> 00:14:05.700
 Gradle我们有一个临时解决方案

00:14:04.230 --> 00:14:07.080
我们自己编写的数据团队

00:14:05.700 --> 00:14:08.490
不是Gradle或写作方面的专家

00:14:07.080 --> 00:14:10.890
我们写了一个Gradle插件就可以了

00:14:08.490 --> 00:14:12.680
我们自己使用它和Gradle 

00:14:10.890 --> 00:14:15.450
团队将接管

00:14:12.680 --> 00:14:17.610
希望在年底之前有时间

00:14:15.450 --> 00:14:18.330
今年，他们最近宣称

00:14:17.610 --> 00:14:20.970
问题追踪器

00:14:18.330 --> 00:14:23.010
还有第三方支持

00:14:20.970 --> 00:14:24.060
 Android的好绅士

00:14:23.010 --> 00:14:25.500
社区已撰写，因此您可以检查

00:14:24.060 --> 00:14:27.840
如果您需要与简一起工作

00:14:25.500 --> 00:14:29.670
在5:00和Android Maven，我们也有

00:14:27.840 --> 00:14:31.860
我们有一个临时解决方案

00:14:29.670 --> 00:14:33.690
使用了植入物，目前

00:14:31.860 --> 00:14:35.250
被行家接管了

00:14:33.690 --> 00:14:37.470
团队，所以我们捐赠了我们拥有的代码

00:14:35.250 --> 00:14:40.950
从那里前进

00:14:37.470 --> 00:14:42.720
这个想法，我们没有蚂蚁的支持，我们

00:14:40.950 --> 00:14:45.300
有一个开放的问题，如果你想

00:14:42.720 --> 00:14:46.350
在如何实现方面感到自由

00:14:45.300 --> 00:14:47.790
设置东西我不会

00:14:46.350 --> 00:14:49.500
时间今天展示，所以如果你想

00:14:47.790 --> 00:14:51.510
看看如何取出用户指南

00:14:49.500 --> 00:14:53.310
文档我们也提供一些样本

00:14:51.510 --> 00:14:55.170
展示如何获取Gradle和

00:14:53.310 --> 00:14:57.330
使用平台进行Maven运行

00:14:55.170 --> 00:15:01.080
本身以及与Jana Jupiter或与

00:14:57.330 --> 00:15:03.720
贾娜（Jana）也有优势，所以现在我们

00:15:01.080 --> 00:15:05.580
要跳进贾娜，我要给

00:15:03.720 --> 00:15:06.810
您对扩展模型的概述

00:15:05.580 --> 00:15:08.640
如果您还有其他问题，我们可以

00:15:06.810 --> 00:15:11.070
今晚在Boff谈论

00:15:08.640 --> 00:15:14.190
所以我们有一个扩展是标记

00:15:11.070 --> 00:15:16.770
在Jupiter API上将它与Jane界面

00:15:14.190 --> 00:15:18.390
扩展程序包与我们不同

00:15:16.770 --> 00:15:20.070
曾在赖特堡的简中，所以有

00:15:18.390 --> 00:15:24.330
任何冲突也是设计

00:15:20.070 --> 00:15:25.620
那里的决定和是限制

00:15:24.330 --> 00:15:26.590
你喜欢对，所以我说你不能

00:15:25.620 --> 00:15:27.700
结合规则

00:15:26.590 --> 00:15:30.010
否则你的课程水平不能超过

00:15:27.700 --> 00:15:32.500
方法级别规则Jana 4和Jana 

00:15:30.010 --> 00:15:34.030
木星，您可以根据需要将它们组合

00:15:32.500 --> 00:15:37.240
以及您注册其中之一的方式

00:15:34.030 --> 00:15:39.610
而不是在j2 40s中运行

00:15:37.240 --> 00:15:41.290
并指定一个或多个

00:15:39.610 --> 00:15:43.180
派你去上课

00:15:41.290 --> 00:15:45.850
级别方法级别或第一个

00:15:43.180 --> 00:15:46.420
甚至在正确的接口上，所以

00:15:45.850 --> 00:15:48.100
有点酷

00:15:46.420 --> 00:15:51.310
即使在接口默认方法上

00:15:48.100 --> 00:15:53.590
这样的东西也好吧

00:15:51.310 --> 00:15:55.150
谁曾经用过弹簧？ 

00:15:53.590 --> 00:15:58.030
你知道元注释支持很酷

00:15:55.150 --> 00:16:00.880
注释支持，所以我在Jana 5中放了

00:15:58.030 --> 00:16:02.730
真的很难说服团队

00:16:00.880 --> 00:16:05.470
我们支持

00:16:02.730 --> 00:16:10.690
这是一个元注释，可以正常工作

00:16:05.470 --> 00:16:10.960
关于我在做什么

00:16:10.690 --> 00:16:17.320
错误

00:16:10.960 --> 00:16:21.340
没有，我将停止扩展

00:16:17.320 --> 00:16:23.230
 API就是这里

00:16:21.340 --> 00:16:25.720
每个我们之前和之后的

00:16:23.230 --> 00:16:27.760
各个级别，所以都是一个班级

00:16:25.720 --> 00:16:29.260
我们喜欢上课前

00:16:27.760 --> 00:16:31.030
就像第四代之前的那种

00:16:29.260 --> 00:16:33.070
在执行测试之前，这是

00:16:31.030 --> 00:16:35.080
测试方法之前

00:16:33.070 --> 00:16:36.700
之后被处决或吃饭

00:16:35.080 --> 00:16:38.260
是所谓的生命周期回调

00:16:36.700 --> 00:16:40.120
但是这些是扩展名，所以

00:16:38.260 --> 00:16:42.700
扩展映射到用户

00:16:40.120 --> 00:16:43.990
扩展点以及超越我们

00:16:42.700 --> 00:16:45.850
中间有些东西

00:16:43.990 --> 00:16:47.350
方法执行完之后

00:16:45.850 --> 00:16:48.940
有一个测试执行异常

00:16:47.350 --> 00:16:50.260
允许您处理的处理程序

00:16:48.940 --> 00:16:51.820
异常，如果你想实现

00:16:50.260 --> 00:16:53.430
诸如预期的感受或

00:16:51.820 --> 00:16:54.970
记录异常之类的东西

00:16:53.430 --> 00:16:56.530
我们有另一件事叫做

00:16:54.970 --> 00:16:58.960
执行条件更多讨论

00:16:56.530 --> 00:17:01.240
测试实例文章中的详细信息

00:16:58.960 --> 00:17:02.730
处理器和参数解析器

00:17:01.240 --> 00:17:05.920
很酷，这是对

00:17:02.730 --> 00:17:07.330
 j单位木星中的依赖注入

00:17:05.920 --> 00:17:10.120
比我们翡翠的好多了

00:17:07.330 --> 00:17:11.590
对于最后一个要复杂一点

00:17:10.120 --> 00:17:13.390
我们有一个测试模板调用

00:17:11.590 --> 00:17:14.860
上下文提供者，这就是我们正在做的

00:17:13.390 --> 00:17:16.690
很酷的东西，例如反复测试

00:17:14.860 --> 00:17:19.750
参数测试测试矩阵和东西

00:17:16.690 --> 00:17:22.540
这样，现在编程模型

00:17:19.750 --> 00:17:24.310
您将最常使用的是什么

00:17:22.540 --> 00:17:26.709
东西位于组织简中

00:17:24.310 --> 00:17:28.180
 Jupiter API程序包，因此它们不在

00:17:26.709 --> 00:17:29.920
简，请不要混淆， 

00:17:28.180 --> 00:17:31.300
选择错误的测试注释，如果

00:17:29.920 --> 00:17:33.280
您正在使用参数支持

00:17:31.300 --> 00:17:34.870
如果使用

00:17:33.280 --> 00:17:35.830
简支持迁移，我们将看到

00:17:34.870 --> 00:17:37.840
你以后也有不同

00:17:35.830 --> 00:17:40.740
包装，但大多数东西是在

00:17:37.840 --> 00:17:43.620
 api包所以滚

00:17:40.740 --> 00:17:45.840
功能集我们支持注释和

00:17:43.620 --> 00:17:47.520
发誓我们有一个网络注释

00:17:45.840 --> 00:17:49.680
有断言和假设习惯

00:17:47.520 --> 00:17:51.540
显示名称可见性不是全部

00:17:49.680 --> 00:17:53.160
必须再公开，所以您可以输入

00:17:51.540 --> 00:17:55.070
再加上我们对

00:17:53.160 --> 00:17:56.880
标记条件测试执行

00:17:55.070 --> 00:17:59.940
依赖注入都

00:17:56.880 --> 00:18:01.260
我们支持的构造函数和方法

00:17:59.940 --> 00:18:03.150
 Lambda表达式和方法

00:18:01.260 --> 00:18:05.550
各个地方，例如断言

00:18:03.150 --> 00:18:07.650
和类似的东西，我们允许您使用

00:18:05.550 --> 00:18:09.840
故障方法可以完成八件事

00:18:07.650 --> 00:18:11.580
新的嵌套测试类支持

00:18:09.840 --> 00:18:14.310
然后还要反复测试永久性

00:18:11.580 --> 00:18:16.320
胸部和动态测试，因此

00:18:14.310 --> 00:18:17.790
这些是主要的注释

00:18:16.320 --> 00:18:19.950
测试我们无法提出更好的

00:18:17.790 --> 00:18:22.620
名称，因此我们将其保留为动态

00:18:19.950 --> 00:18:24.180
测试我们有测试工厂

00:18:22.620 --> 00:18:25.590
灰色是可以测试的，所以如果你是

00:18:24.180 --> 00:18:26.790
编写一个您实际上会使用的测试引擎

00:18:25.590 --> 00:18:29.940
想要使用该注释

00:18:26.790 --> 00:18:31.740
接下来的测试变化，所以我们有

00:18:29.940 --> 00:18:33.120
重复测试并参数化测试

00:18:31.740 --> 00:18:35.100
这些是专长还是什么

00:18:33.120 --> 00:18:37.380
我提到的称为测试模板

00:18:35.100 --> 00:18:40.920
之前在嵌套测试类之前

00:18:37.380 --> 00:18:42.180
在tes实例上，所以我要做一个

00:18:40.920 --> 00:18:42.690
声明，您可以看到实际上是谁

00:18:42.180 --> 00:18:45.900
知道这个

00:18:42.690 --> 00:18:48.030
所以在JUnit一到四个Jane中

00:18:45.900 --> 00:18:50.100
总是恢复您的测试课程

00:18:48.030 --> 00:18:55.020
知道的每种测试方法之间

00:18:50.100 --> 00:18:56.820
所以大约有10％的肠道G 

00:18:55.020 --> 00:19:00.240
正好相反，它可以保持您的测试

00:18:56.820 --> 00:19:01.470
因为一直以来，我经常

00:19:00.240 --> 00:19:03.300
重量测试G的粉丝做到了

00:19:01.470 --> 00:19:05.370
我在原型中有这个，然后

00:19:03.300 --> 00:19:06.930
被投票但我被投票回

00:19:05.370 --> 00:19:09.630
并为TA重新实现

00:19:06.930 --> 00:19:10.770
所以在珍妮特·朱庇特，你可以选择

00:19:09.630 --> 00:19:12.900
您想要的模特可以说我想要

00:19:10.770 --> 00:19:14.760
根据类别或方法安装活塞

00:19:12.900 --> 00:19:15.840
这也是我之所以能够做到的原因之一

00:19:14.760 --> 00:19:17.430
说服团队是因为

00:19:15.840 --> 00:19:18.870
其实预先做好是因为

00:19:17.430 --> 00:19:20.580
支持场景测试

00:19:18.870 --> 00:19:23.280
我们希望在以后支持

00:19:20.580 --> 00:19:24.540
释放，所以我们毕竟拥有

00:19:23.280 --> 00:19:26.460
就像上课之前和课后一样

00:19:24.540 --> 00:19:28.140
在每个之前和之后，就像

00:19:26.460 --> 00:19:30.060
显示名称之前和之后

00:19:28.140 --> 00:19:31.560
那是海关打名字标签的地方

00:19:30.060 --> 00:19:34.200
种替换Jana中的类别以

00:19:31.560 --> 00:19:35.880
现在禁用替换为忽略

00:19:34.200 --> 00:19:37.020
人们说你为什么不把它保持好

00:19:35.880 --> 00:19:38.160
当我谈论这件事时会更有意义

00:19:37.020 --> 00:19:39.930
执行的东西，但

00:19:38.160 --> 00:19:42.330
基本上我无法提出

00:19:39.930 --> 00:19:44.280
与忽略相反，因为我们不

00:19:42.330 --> 00:19:45.210
忽略它不被忽略，它使

00:19:44.280 --> 00:19:47.310
说测试更有意义

00:19:45.210 --> 00:19:49.350
启用或禁用，并且

00:19:47.310 --> 00:19:52.050
通过，API将在以后看到

00:19:49.350 --> 00:19:54.240
如果您想迁移，我们有一些

00:19:52.050 --> 00:19:56.700
实验性的有限支持

00:19:54.240 --> 00:19:58.500
珍妮特为您准备的几种规则类型

00:19:56.700 --> 00:20:00.510
可以像弹簧靴吗，但是

00:19:58.500 --> 00:20:02.340
不是在海军农村迁移

00:20:00.510 --> 00:20:06.270
支持，所以如果您用

00:20:02.340 --> 00:20:08.640
您将获得三个扩展

00:20:06.270 --> 00:20:09.780
外部资源支持是

00:20:08.640 --> 00:20:11.880
支持类似临时文件夹和

00:20:09.780 --> 00:20:13.890
验证者链支持诸如

00:20:11.880 --> 00:20:15.540
巨大的空气收集器

00:20:13.890 --> 00:20:17.100
对异常预期的异常支持

00:20:15.540 --> 00:20:19.380
异常权限，因此您可以实际使用

00:20:17.100 --> 00:20:21.300
简和

00:20:19.380 --> 00:20:26.610
木星，因为它们映射到UM 

00:20:21.300 --> 00:20:27.690
新的扩展API，我们可以吗？ 

00:20:26.610 --> 00:20:29.070
没有介意一个错误，但它得到了

00:20:27.690 --> 00:20:32.760
今天发布并修复，还有五个

00:20:29.070 --> 00:20:35.160
一个这样的断言，但我们有一个局限性

00:20:32.760 --> 00:20:37.140
紧身胸衣我复制了一些基础知识

00:20:35.160 --> 00:20:38.880
简在4岁时，我们再做一些工作

00:20:37.140 --> 00:20:39.929
并扩展了一切，所以我们仍然得到了

00:20:38.880 --> 00:20:42.090
像剑一样的东西肯定

00:20:39.929 --> 00:20:43.860
未知等等，但是每次看到

00:20:42.090 --> 00:20:45.510
一个绿色的lambda罐子是什至绿色的我

00:20:43.860 --> 00:20:46.260
不知道这些是层压板的东西

00:20:45.510 --> 00:20:48.059
这意味着您可以使用lambda 

00:20:46.260 --> 00:20:49.950
 J的表达式或方法引用

00:20:48.059 --> 00:20:51.870
和木星，所以断言是很酷的

00:20:49.950 --> 00:20:53.340
期待异常断言的新方法

00:20:51.870 --> 00:20:56.490
超时和断言面板超时

00:20:53.340 --> 00:20:57.690
抢先断言超时

00:20:56.490 --> 00:20:59.790
就像你可能有超时规则

00:20:57.690 --> 00:21:02.160
以前的区别是超时

00:20:59.790 --> 00:21:03.809
将在同一线程中执行，然后

00:21:02.160 --> 00:21:05.250
测试停止后停止并告诉您

00:21:03.809 --> 00:21:06.809
是否及时完成

00:21:05.250 --> 00:21:08.490
第三次在原始对象上运行

00:21:06.809 --> 00:21:10.770
您的代码和新线程，他们将

00:21:08.490 --> 00:21:13.320
如果可以的话，尽早杀死它吧

00:21:10.770 --> 00:21:14.670
我需要注意的是，如果使用

00:21:13.320 --> 00:21:16.860
像Spring这样的框架

00:21:14.670 --> 00:21:18.510
具有交易支持的地方

00:21:16.860 --> 00:21:20.540
事务上下文绑定到线程

00:21:18.510 --> 00:21:22.950
当前线程本地，你说

00:21:20.540 --> 00:21:24.360
摘录超时最初是Springs 

00:21:22.950 --> 00:21:25.470
交易支持将被破坏， 

00:21:24.360 --> 00:21:26.730
如果您有其他框架在做

00:21:25.470 --> 00:21:28.650
类似的东西，你只需要保持

00:21:26.730 --> 00:21:30.660
请记住，因此再次可能

00:21:28.650 --> 00:21:33.090
会更快结束，但可能会破坏您的

00:21:30.660 --> 00:21:35.640
其他框架代码使用我全部开始

00:21:33.090 --> 00:21:37.970
这就是所谓的内部断言

00:21:35.640 --> 00:21:39.450
或分组的断言或类似的内容

00:21:37.970 --> 00:21:41.730
他们叫什么

00:21:39.450 --> 00:21:43.500
软断言和正确的权限，因此您可以

00:21:41.730 --> 00:21:45.420
将一束束与末端结合在一起

00:21:43.500 --> 00:21:46.980
表达式，然后Jana将报告

00:21:45.420 --> 00:21:50.220
支持所有失败而不是

00:21:46.980 --> 00:21:53.250
重新运行那些测试

00:21:50.220 --> 00:21:55.890
指出现在是一团糟

00:21:53.250 --> 00:21:56.880
所以你的信息为什么失败了

00:21:55.890 --> 00:21:58.980
这应该是一个可选参数

00:21:56.880 --> 00:22:01.860
另外它可以提供

00:21:58.980 --> 00:22:03.540
您作为供应商的失败信息

00:22:01.860 --> 00:22:04.679
带有lambda表达式的字符串

00:22:03.540 --> 00:22:06.840
表示如果要花很长时间

00:22:04.679 --> 00:22:07.389
计算它或可能很长时间， 

00:22:06.840 --> 00:22:09.190
没有

00:22:07.389 --> 00:22:10.599
生成错误消息，如果

00:22:09.190 --> 00:22:13.539
外科医生不会失败，所以这就是为什么

00:22:10.599 --> 00:22:15.909
我们做到了，如果您想获得更多动力

00:22:13.539 --> 00:22:17.649
我们不强迫您使用我们的

00:22:15.909 --> 00:22:19.119
断言，如果您不希望他们感到

00:22:17.649 --> 00:22:20.709
免费使用sergej hamcrest真相

00:22:19.119 --> 00:22:22.029
只要那些东西有权利

00:22:20.709 --> 00:22:24.219
你在抛出断言领域

00:22:22.029 --> 00:22:27.399
可以和简和木星一起工作

00:22:24.219 --> 00:22:28.989
和平台一样

00:22:27.399 --> 00:22:31.450
假设有人曾经使用过那些

00:22:28.989 --> 00:22:32.589
在耶拿（Jena）有几个人，所以你

00:22:31.450 --> 00:22:33.669
可以说我认为这是真的， 

00:22:32.589 --> 00:22:35.799
否则不要执行其余的

00:22:33.669 --> 00:22:37.719
测试，所以我们只有有限的一组

00:22:35.799 --> 00:22:39.700
从J和4接管，那是为了

00:22:37.719 --> 00:22:41.799
中途中止测试意味着

00:22:39.700 --> 00:22:43.299
测试已经正确开始了

00:22:41.799 --> 00:22:45.009
方法正在执行，但是你可以说我

00:22:43.299 --> 00:22:46.479
检查一些我不想要的东西

00:22:45.009 --> 00:22:47.789
继续下去，它将不会有市场

00:22:46.479 --> 00:22:50.379
失败，我只是说它被跳过了

00:22:47.789 --> 00:22:52.029
否则，如果您想实际跳过

00:22:50.379 --> 00:22:53.469
整个事情我都还没开始

00:22:52.029 --> 00:22:55.629
那么你可以实现自己的

00:22:53.469 --> 00:22:57.489
我们将讨论的执行条件

00:22:55.629 --> 00:23:00.429
后来，我们有一些假设

00:22:57.489 --> 00:23:02.440
假设为true，则为false，表示布尔值或

00:23:00.429 --> 00:23:04.509
布尔供应商供应商字符串

00:23:02.440 --> 00:23:06.159
对于消息等，我们还有另一个

00:23:04.509 --> 00:23:08.019
所谓的假设是

00:23:06.159 --> 00:23:09.339
如果你有一个假设就荣耀

00:23:08.019 --> 00:23:11.529
通过下面的一些代码

00:23:09.339 --> 00:23:15.159
否则请不要继续

00:23:11.529 --> 00:23:21.629
执行测试方法，所以这是

00:23:15.159 --> 00:23:27.969
我希望演示之神与我同在

00:23:21.629 --> 00:23:30.729
好吧好吧，所以我们有一个

00:23:27.969 --> 00:23:32.349
很棒的计算器类，它增加了一些

00:23:30.729 --> 00:23:34.359
轨迹乘以除法并计算

00:23:32.349 --> 00:23:36.549
斐波那契斐波那契可能需要一段时间

00:23:34.359 --> 00:23:37.959
提示也许超时可以除以

00:23:36.549 --> 00:23:42.899
 0在这里，所以你可以有一些

00:23:37.959 --> 00:23:42.899
字体错误

00:23:46.679 --> 00:23:59.440
基本文本字体编辑24将会非常庞大

00:23:53.019 --> 00:24:02.950
它编织得更好，是的，很酷

00:23:59.440 --> 00:24:04.779
是的，我们有一些猫人， 

00:24:02.950 --> 00:24:12.399
严格的计算工具

00:24:04.779 --> 00:24:14.529
回文，所以我们有一个基于

00:24:12.399 --> 00:24:16.419
珍妮特（Janet）实例化了

00:24:14.529 --> 00:24:18.219
计算的实质性测试使用

00:24:16.419 --> 00:24:19.629
预期例外规则和时间

00:24:18.219 --> 00:24:21.249
 JUnit 4的安装规则有一些

00:24:19.629 --> 00:24:23.739
断言我希望这些是正确的

00:24:21.249 --> 00:24:27.519
是的，他们都是简的。 

00:24:23.739 --> 00:24:29.649
断言然后进行异常测试

00:24:27.519 --> 00:24:30.999
对，所以它开始不说

00:24:29.649 --> 00:24:32.979
预期的异常，然后为此

00:24:30.999 --> 00:24:34.299
特殊情况除以零表示

00:24:32.979 --> 00:24:35.469
它在消息中期望的类型

00:24:34.299 --> 00:24:37.690
然后做应该做的事情

00:24:35.469 --> 00:24:38.649
炸毁，超时我没有

00:24:37.690 --> 00:24:40.239
在这里评论掉了，所以你可以

00:24:38.649 --> 00:24:42.279
像以前那样做旧派

00:24:40.239 --> 00:24:43.899
你会与全球

00:24:42.279 --> 00:24:45.789
超时毫秒一千

00:24:43.899 --> 00:24:47.859
第二，然后执行该事情

00:24:45.789 --> 00:24:50.379
看看它是否爆炸了，让我们运行

00:24:47.859 --> 00:24:52.450
这个测试，看看它是否运行

00:24:50.379 --> 00:24:55.679
如果我们

00:24:52.450 --> 00:24:58.389
选择像这样的大东西

00:24:55.679 --> 00:24:59.849
 42那么那应该炸掉它

00:24:58.389 --> 00:25:03.369
确实，这给了我们一些错误

00:24:59.849 --> 00:25:05.169
像测试之后超时

00:25:03.369 --> 00:25:07.359
一月的毫秒数

00:25:05.169 --> 00:25:09.249
是否先发制人

00:25:07.359 --> 00:25:14.049
 jenefor中的超时抢占模式

00:25:09.249 --> 00:25:16.649
除非我们期望

00:25:14.049 --> 00:25:16.649
如果我们没有

00:25:17.809 --> 00:25:21.960
并运行那个然后会炸毁

00:25:19.919 --> 00:25:24.090
有例外的权利，所以它通过

00:25:21.960 --> 00:25:25.620
例外，现在我们要做什么

00:25:24.090 --> 00:25:29.549
您是否想看看我们如何实现

00:25:25.620 --> 00:25:33.029
简在五点钟的东西

00:25:29.549 --> 00:25:36.779
是演示之神可能真的没有的地方

00:25:33.029 --> 00:25:41.539
和我在一起我们会给我一个机会

00:25:36.779 --> 00:25:45.809
甚至会输入大视角

00:25:41.539 --> 00:25:48.149
好吧，现在我们有新班了

00:25:45.809 --> 00:25:49.919
我们要做什么我们要说

00:25:48.149 --> 00:25:51.419
除掉J和其他东西

00:25:49.919 --> 00:25:53.669
我们会把那些人留在那里的规则

00:25:51.419 --> 00:25:55.440
好一秒钟，现在是

00:25:53.669 --> 00:25:58.470
抱怨我要选择测试API 

00:25:55.440 --> 00:26:02.779
来自J和木星的注释

00:25:58.470 --> 00:26:02.779
我说过事情不必公开

00:26:03.440 --> 00:26:08.510
她将能够删除所有干净的

00:26:07.559 --> 00:26:11.279
一点点

00:26:08.510 --> 00:26:13.309
没有断言没有让我

00:26:11.279 --> 00:26:19.350
从正确的包装中选择其中之一

00:26:13.309 --> 00:26:23.010
是它从

00:26:19.350 --> 00:26:25.770
初级API外科医生，所以现在我们已经

00:26:23.010 --> 00:26:27.960
刚转换了AHA，这是为什么

00:26:25.770 --> 00:26:30.090
没有任何人注意

00:26:27.960 --> 00:26:32.730
消息是在开头

00:26:30.090 --> 00:26:35.159
我说的对不对了

00:26:32.730 --> 00:26:38.100
开始，所以他把它们放在最后

00:26:35.159 --> 00:26:42.240
那样做，如果这是一些

00:26:38.100 --> 00:26:45.240
有点复杂，你想

00:26:42.240 --> 00:26:47.039
很好地建立它，只需使

00:26:45.240 --> 00:26:48.690
它是这样的供应商，所以要使用lambda 

00:26:47.039 --> 00:26:50.520
表达式，效果很好，所以如果

00:26:48.690 --> 00:26:54.240
我们现在运行这个，你要做什么

00:26:50.520 --> 00:26:55.950
除以零失败了吧，我们

00:26:54.240 --> 00:26:59.549
预计会发生，我提到

00:26:55.950 --> 00:27:01.830
有这种农村移民的支持

00:26:59.549 --> 00:27:05.309
它支持预期的异常，所以

00:27:01.830 --> 00:27:09.140
如果我现在再次运行它，它仍然分裂

00:27:05.309 --> 00:27:09.140
零，让我们看看这里发生了什么

00:27:13.620 --> 00:27:27.400
 2905你知道的邻里迁移

00:27:18.360 --> 00:27:28.870
期望没有异常，应该在

00:27:27.400 --> 00:27:32.980
这里就在这里

00:27:28.870 --> 00:27:37.870
异常支持让我给一个

00:27:32.980 --> 00:27:48.520
弹枪这是正确的空间

00:27:37.870 --> 00:27:54.880
参加特定聚会的权利

00:27:48.520 --> 00:27:55.770
是的，有一个观众很高兴

00:27:54.880 --> 00:28:01.530
注意

00:27:55.770 --> 00:28:03.460
非常感谢你看到那群人

00:28:01.530 --> 00:28:05.320
朱纳为什么要一切都必须

00:28:03.460 --> 00:28:07.180
公开是的，没错，但是

00:28:05.320 --> 00:28:08.260
让我们摆脱这种权利，我们不是

00:28:07.180 --> 00:28:11.100
不想这样做，我们正在

00:28:08.260 --> 00:28:14.050
迁移，所以现在这个东西不存在

00:28:11.100 --> 00:28:20.280
这也是空气，让您开始

00:28:14.050 --> 00:28:22.930
像这样断言抛出，类型是

00:28:20.280 --> 00:28:28.290
那一个和我们想要的东西

00:28:22.930 --> 00:28:32.650
这是执行，那么我们怎么惊讶

00:28:28.290 --> 00:28:35.520
这样命名的表达式好吧

00:28:32.650 --> 00:28:35.520
到目前为止很好

00:28:36.340 --> 00:28:44.600
如果您现在运行它并保存，那么

00:28:42.410 --> 00:28:47.420
一切正常，如果我们没有

00:28:44.600 --> 00:28:55.630
检查消息很好，不是

00:28:47.420 --> 00:28:55.630
困难等于很多等于预期

00:28:58.780 --> 00:29:07.700
谁认为这行得通

00:29:05.630 --> 00:29:11.030
有效，所以这就是您的预期

00:29:07.700 --> 00:29:12.530
 Jayne现在5 J和

00:29:11.030 --> 00:29:15.980
木星和摆脱的最后一部分

00:29:12.530 --> 00:29:18.650
这是这个超时的事情，所以是42 

00:29:15.980 --> 00:29:19.940
当它比我们更长时

00:29:18.650 --> 00:29:21.830
想要和不支持超时

00:29:19.940 --> 00:29:23.870
可以通过任何方式删除

00:29:21.830 --> 00:29:26.750
这个，现在，如果我们运行这个，这个应该

00:29:23.870 --> 00:29:28.730
嗯，这需要一点时间

00:29:26.750 --> 00:29:30.799
我们会花多长时间

00:29:28.730 --> 00:29:32.600
在第二个权利，所以你想

00:29:30.799 --> 00:29:38.330
确保不会花费一秒钟

00:29:32.600 --> 00:29:44.890
对，我们这样做的方式是超时

00:29:38.330 --> 00:29:44.890
例如米莉的一千

00:29:51.250 --> 00:30:00.340
所以谁认为这行得通呢

00:29:56.530 --> 00:30:03.159
会说人们可以读懂它

00:30:00.340 --> 00:30:05.740
说执行看到时间超过了1,000 

00:30:03.159 --> 00:30:07.720
 390毫秒，这是

00:30:05.740 --> 00:30:09.400
非抢占式的它可以让它运行

00:30:07.720 --> 00:30:13.090
查看整个运行时间

00:30:09.400 --> 00:30:15.640
如果我们想完成该怎么办

00:30:13.090 --> 00:30:17.110
先行地做到这一点，我们只能说

00:30:15.640 --> 00:30:19.000
李的照片，然后我们将停止

00:30:17.110 --> 00:30:20.440
一秒钟后立即给我们

00:30:19.000 --> 00:30:25.179
与我们看到的类似的错误

00:30:20.440 --> 00:30:27.340
正确摆放它，以便执行时间

00:30:25.179 --> 00:30:29.230
 1000毫秒后点

00:30:27.340 --> 00:30:30.520
顺便说一下，如果

00:30:29.230 --> 00:30:33.280
你想知道这是什么

00:30:30.520 --> 00:30:34.510
 Java持续时间（以毫秒为单位） 

00:30:33.280 --> 00:30:41.799
秒之类的东西真好

00:30:34.510 --> 00:30:46.110
是的，有点线性路径

00:30:41.799 --> 00:30:46.110
哦，你的意思是我们可能会正确杀死它吗

00:30:48.929 --> 00:30:55.330
它尝试它可能不会在

00:30:53.919 --> 00:30:56.740
在所有情况下，如果真的是

00:30:55.330 --> 00:31:01.419
猖ant的事情，我们将使用

00:30:56.740 --> 00:31:03.549
遗嘱执行人服务，我们的确做到了

00:31:01.419 --> 00:31:08.620
问题是它是否会继续

00:31:03.549 --> 00:31:13.539
永远与先发制人之一

00:31:08.620 --> 00:31:15.429
非一个非一个没有它会

00:31:13.539 --> 00:31:17.799
继续运行它将永远运行

00:31:15.429 --> 00:31:19.120
是的，如果你知道那是什么

00:31:17.799 --> 00:31:20.380
因此，如果您想计时，那就知道了

00:31:19.120 --> 00:31:21.789
要完成，你只想做

00:31:20.380 --> 00:31:22.750
确保不会花太长时间，然后您

00:31:21.789 --> 00:31:24.640
如果您想使用正常的时间

00:31:22.750 --> 00:31:26.620
确保它可能有一些

00:31:24.640 --> 00:31:28.120
无限循环，随心所欲

00:31:26.620 --> 00:31:29.230
避免这种情况并杀死它

00:31:28.120 --> 00:31:30.730
抢先做，但再次

00:31:29.230 --> 00:31:32.380
点，你必须知道你的

00:31:30.730 --> 00:31:34.120
其他框架代码，例如spring或

00:31:32.380 --> 00:31:35.950
然后他正在使用线程局部变量

00:31:34.120 --> 00:31:38.320
那是行不通的，所以你必须

00:31:35.950 --> 00:31:40.570
找出一些东西，但这就是

00:31:38.320 --> 00:31:43.390
您必须处理的线程问题

00:31:40.570 --> 00:31:48.270
无论如何，我认为仅此而已

00:31:43.390 --> 00:31:50.740
没关系的基础知识，所以标记

00:31:48.270 --> 00:31:52.360
嗯，我们一直往前走，所以我们有

00:31:50.740 --> 00:31:55.240
您可以清除的标记外标签

00:31:52.360 --> 00:31:57.730
接口类或方法类似

00:31:55.240 --> 00:32:00.789
这个添加标签快速测试方法我

00:31:57.730 --> 00:32:02.409
快速测试，默认情况下所有标签

00:32:00.789 --> 00:32:03.290
已启用，因此实际上并没有

00:32:02.409 --> 00:32:06.110
任何

00:32:03.290 --> 00:32:07.580
任何输入或对运行的任何影响

00:32:06.110 --> 00:32:10.190
您必须实际指定的测试计划

00:32:07.580 --> 00:32:12.380
包括标签或明确排除

00:32:10.190 --> 00:32:14.450
标签，否则标签或被忽略

00:32:12.380 --> 00:32:16.070
所以你可以拿出自定义标签

00:32:14.450 --> 00:32:17.929
因为我们支持中间注释

00:32:16.070 --> 00:32:19.309
只是声明添加标签添加一个元

00:32:17.929 --> 00:32:21.350
注释，因此元注释意味着

00:32:19.309 --> 00:32:23.419
在另一个顶部声明的注释

00:32:21.350 --> 00:32:25.520
源代码中的注释，所以在这里我们

00:32:23.419 --> 00:32:27.740
有我们自己的注释，名为fast和

00:32:25.520 --> 00:32:29.059
它使用该标签快速注释， 

00:32:27.740 --> 00:32:30.710
它可以用在方法上

00:32:29.059 --> 00:32:32.179
保留在运行时，这样我们就可以

00:32:30.710 --> 00:32:35.299
像这样重写上一张幻灯片

00:32:32.179 --> 00:32:38.030
快速测试，您同意快速重复使用

00:32:35.299 --> 00:32:40.280
如果要在代码库中标记

00:32:38.030 --> 00:32:42.740
更进一步，您可以撰写标签

00:32:40.280 --> 00:32:44.330
一个非常酷的功能，在

00:32:42.740 --> 00:32:46.880
春天，现在可以用j-unit 

00:32:44.330 --> 00:32:48.860
这样你就可以将Eclair标记与

00:32:46.880 --> 00:32:51.110
其他注释可能是其他

00:32:48.860 --> 00:32:53.240
来自吉安娜（Jaina）或我在

00:32:51.110 --> 00:32:55.160
春季测试运动我结合弹簧

00:32:53.240 --> 00:32:56.900
注释和Jade注释

00:32:55.160 --> 00:32:59.299
确实简化了配置，所以

00:32:56.900 --> 00:33:02.000
在这里，我们看到了快速标记组合

00:32:59.299 --> 00:33:03.799
并从简和木星进行测试

00:33:02.000 --> 00:33:06.200
是一个快速测试，所以我们可以重写

00:33:03.799 --> 00:33:07.640
最后一个是快速测试，而您

00:33:06.200 --> 00:33:09.140
可能有集成测试烟雾测试

00:33:07.640 --> 00:33:10.460
诸如此类的不同事物

00:33:09.140 --> 00:33:13.070
同样，您也可以将其与

00:33:10.460 --> 00:33:14.390
弹簧支持事务性SQL 

00:33:13.070 --> 00:33:17.780
脚本之类的东西真漂亮

00:33:14.390 --> 00:33:20.240
功能强大的东西测试名称，因此默认情况下

00:33:17.780 --> 00:33:21.650
默认为类名或方法

00:33:20.240 --> 00:33:24.320
名字是你熟悉的东西

00:33:21.650 --> 00:33:25.880
例如测试G＆J及其它，等等

00:33:24.320 --> 00:33:28.490
 Java上不限制的字符

00:33:25.880 --> 00:33:29.600
语法，但显示名称和J 

00:33:28.490 --> 00:33:32.059
和木星定律，你有一个习惯

00:33:29.600 --> 00:33:35.780
显示名称可以包含特殊空格

00:33:32.059 --> 00:33:37.100
人物甚至表情符号是的，所以有些

00:33:35.780 --> 00:33:38.390
家伙在互联网上抱怨

00:33:37.100 --> 00:33:39.830
我们愚蠢的Twittersphere 

00:33:38.390 --> 00:33:41.000
有哦geez的支持，我不得不

00:33:39.830 --> 00:33:43.040
说的好，我们实际上并非旨在

00:33:41.000 --> 00:33:44.660
我们想要支持的支持表情符号

00:33:43.040 --> 00:33:46.610
支持前两个特殊字符

00:33:44.660 --> 00:33:49.010
和空间之类的东西，然后

00:33:46.610 --> 00:33:50.360
有一天，我想如果可以的话

00:33:49.010 --> 00:33:52.880
实际上在其中使用表情符号

00:33:50.360 --> 00:33:55.700
正确的字符，我们没有

00:33:52.880 --> 00:33:56.809
旨在但确实有效，我会告诉你

00:33:55.700 --> 00:33:58.910
无论如何

00:33:56.809 --> 00:34:00.260
依赖注入这是

00:33:58.910 --> 00:34:02.360
扩展模型满足编程要求

00:34:00.260 --> 00:34:04.669
模特也想说，所以我们有一个

00:34:02.360 --> 00:34:06.799
参数解析器扩展API，这是

00:34:04.669 --> 00:34:08.840
有点类似于Spring MVC支持

00:34:06.799 --> 00:34:10.820
用于参数解析器之类的东西

00:34:08.840 --> 00:34:12.889
可以解析参数

00:34:10.820 --> 00:34:13.570
猜测是构造函数还是

00:34:12.889 --> 00:34:15.370
方法

00:34:13.570 --> 00:34:19.150
而不仅仅是测试方法

00:34:15.370 --> 00:34:20.560
生命周期方法，但也是

00:34:19.150 --> 00:34:22.990
构造函数，以便您可以注册

00:34:20.560 --> 00:34:24.520
他们同时竞争多个，但

00:34:22.990 --> 00:34:26.679
只有一个赢，因为问你是否

00:34:24.520 --> 00:34:28.630
支持它并使用案例之类的东西

00:34:26.679 --> 00:34:29.860
如果有，则将服务器URL注入数据源

00:34:28.630 --> 00:34:31.840
您已连接到数据库

00:34:29.860 --> 00:34:34.780
 Spring应用程序上下文示例

00:34:31.840 --> 00:34:36.850
诸如此类的东西或Mocs还有另一个

00:34:34.780 --> 00:34:38.410
另一个流行的测试将其调用

00:34:36.850 --> 00:34:40.690
您可以将其注入

00:34:38.410 --> 00:34:41.800
构造函数在每个J等进行测试之前

00:34:40.690 --> 00:34:44.140
木星可以让您访问

00:34:41.800 --> 00:34:46.060
显示名称标签类meth和东西

00:34:44.140 --> 00:34:47.950
这样我们都有自己的参数

00:34:46.060 --> 00:34:49.720
被自动注册在

00:34:47.950 --> 00:34:51.580
这就是我们说吃自己的场景

00:34:49.720 --> 00:34:53.530
狗粮实际上是一种设计

00:34:51.580 --> 00:34:55.990
我们整体的原则

00:34:53.530 --> 00:34:57.370
简2：5的努力是，如果我们有一个

00:34:55.990 --> 00:34:59.020
扩展点或我们想要的东西

00:34:57.370 --> 00:35:00.160
实施，然后我们创建一个必要的

00:34:59.020 --> 00:35:01.600
为此，我们必须将其弯曲

00:35:00.160 --> 00:35:04.960
和其他人也可以实施

00:35:01.600 --> 00:35:06.490
相同的扩展点，因此也请参见

00:35:04.960 --> 00:35:08.590
使用您的PT测试，您可以在

00:35:06.490 --> 00:35:10.900
插入重复信息，您可以

00:35:08.590 --> 00:35:12.340
测试记者注入创建一些

00:35:10.900 --> 00:35:14.290
其他测试报告信息

00:35:12.340 --> 00:35:16.270
 maketo扩展名是我们

00:35:14.290 --> 00:35:18.310
作为示例和Makua团队实施

00:35:16.270 --> 00:35:19.750
接手我写了春天的延伸

00:35:18.310 --> 00:35:24.630
并且已经在 spring 5发布了

00:35:19.750 --> 00:35:27.190
我们稍后会看到

00:35:24.630 --> 00:35:34.620
实时编码标签在大头针中显示名称

00:35:27.190 --> 00:35:34.620
看注射我们在这里有什么所以我

00:35:36.330 --> 00:35:44.560
有一个初中5次测试，你知道我想要

00:35:39.730 --> 00:35:49.900
做一个测试，这是一个测试

00:35:44.560 --> 00:35:52.590
我现在想用快速标记

00:35:49.900 --> 00:35:52.590
这是一个快速的测试

00:35:54.810 --> 00:35:59.710
 licky称这缓慢或正常，或

00:35:57.220 --> 00:36:03.640
其实并不重要，所以如果我现在

00:35:59.710 --> 00:36:05.170
运行这个，他们都将运行两个

00:36:03.640 --> 00:36:07.150
测试一个通常快的是因为

00:36:05.170 --> 00:36:08.980
我说的我们没有指定任何标签

00:36:07.150 --> 00:36:11.380
默认情况下，所有内容都包括在内

00:36:08.980 --> 00:36:15.220
在Eclipse中，我开始运行

00:36:11.380 --> 00:36:17.440
 Eclipse的配置和参数

00:36:15.220 --> 00:36:19.600
四七一八的支持

00:36:17.440 --> 00:36:22.060
您可以说快速包含标签

00:36:19.600 --> 00:36:24.220
那并运行，然后我们应该看到哈

00:36:22.060 --> 00:36:26.800
哈现在它只进行了一项测试

00:36:24.220 --> 00:36:28.510
事实上，快速测试是正确的，所以你可以来

00:36:26.800 --> 00:36:30.160
在Eclipse中执行此操作，我不确定是否

00:36:28.510 --> 00:36:31.450
您可以获得IntelliJ，因此您可以

00:36:30.160 --> 00:36:33.190
这是从您的Gradle版本开始的， 

00:36:31.450 --> 00:36:34.720
从您的Maven构建以及

00:36:33.190 --> 00:36:35.260
控制台启动器，以便工作

00:36:34.720 --> 00:36:37.530
像那样

00:36:35.260 --> 00:36:39.609
现在我再次提到你可能想要

00:36:37.530 --> 00:36:41.200
创建类似我已经进行的快速测试

00:36:39.609 --> 00:36:45.820
已经为你写了这是这个

00:36:41.200 --> 00:36:47.650
拥有标签ves ves快速，测试可以

00:36:45.820 --> 00:36:51.040
用于保留运行时的方法，所以我

00:36:47.650 --> 00:36:51.720
应该能够取代那摆脱

00:36:51.040 --> 00:36:54.760
在那

00:36:51.720 --> 00:36:56.320
重新运行测试，我们再次看到

00:36:54.760 --> 00:36:58.540
那个实际上是在进行快速测试

00:36:56.320 --> 00:37:01.270
这就是这个很棒的自定义注解

00:36:58.540 --> 00:37:03.270
结合标签和测试，我提到

00:37:01.270 --> 00:37:06.160
您还可以获取诸如

00:37:03.270 --> 00:37:08.140
依赖注入，所以你可以说我会

00:37:06.160 --> 00:37:13.900
这样，请给我，只是

00:37:08.140 --> 00:37:17.590
为了好玩，我会把它打印出来

00:37:13.900 --> 00:37:19.060
那什么样的小团队呢？ 

00:37:17.590 --> 00:37:21.070
现在，如果我们运行它，您可以看到一些

00:37:19.060 --> 00:37:23.530
填充控制台，我们看到了显示

00:37:21.070 --> 00:37:24.850
这个快速测试标签的名称是

00:37:23.530 --> 00:37:26.530
这是我们的班级

00:37:24.850 --> 00:37:28.060
在这里运行的测试方法

00:37:26.530 --> 00:37:30.400
我们是对的，所以我们得到了他的帮助

00:37:28.060 --> 00:37:33.220
信息，但显示名称为

00:37:30.400 --> 00:37:36.040
那是什么名字

00:37:33.220 --> 00:37:38.700
参数列表的方法是什么

00:37:36.040 --> 00:37:44.440
如果我们想定制一些东西

00:37:38.700 --> 00:37:47.140
显示名称与一些快速测试

00:37:44.440 --> 00:37:49.119
现在我们看到特殊字符

00:37:47.140 --> 00:37:53.520
包含在信息中，但

00:37:49.119 --> 00:38:00.150
更重要的是这里的快速测试

00:37:53.520 --> 00:38:03.330
好吧，看到快速测试是很酷的， 

00:38:00.150 --> 00:38:04.920
现在这是我必须回去的地方

00:38:03.330 --> 00:38:07.230
从无法键入的地方复制

00:38:04.920 --> 00:38:14.640
 Eclipse中的表情符号，我不知道为什么，但是

00:38:07.230 --> 00:38:17.040
您可以将其复制并粘贴到其中

00:38:14.640 --> 00:38:18.630
会发生现在这是我得到的地方

00:38:17.040 --> 00:38:25.950
最大的掌声我保证

00:38:18.630 --> 00:38:26.970
在报告中，哇，但是

00:38:25.950 --> 00:38:32.070
你甚至没有在显示屏上看到它

00:38:26.970 --> 00:38:35.220
好吧，现在这是最酷的部分

00:38:32.070 --> 00:38:36.720
在那里，如果我们要运行它

00:38:35.220 --> 00:38:37.170
从命令行不，我是什么

00:38:36.720 --> 00:38:41.280
在做

00:38:37.170 --> 00:38:44.580
我在哪里，这不是我的乐趣

00:38:41.280 --> 00:38:47.520
在我使用Gradle构建之前

00:38:44.580 --> 00:38:53.810
插件会输出一个

00:38:47.520 --> 00:38:57.560
理论上的结果是，哇

00:38:53.810 --> 00:39:02.960
所以那里的东西非常非常好

00:38:57.560 --> 00:39:04.740
那就是你们所有人都想要的表情符号

00:39:02.960 --> 00:39:09.980
是的，不客气

00:39:04.740 --> 00:39:09.980
哦，不，我撞到了那个错误的地方

00:39:15.540 --> 00:39:25.540
哦，我的天哪

00:39:20.230 --> 00:39:27.640
很好，我们看到了所有的东西

00:39:25.540 --> 00:39:28.960
继续前进，我现在必须快走

00:39:27.640 --> 00:39:30.610
如果您还有其他问题

00:39:28.960 --> 00:39:33.610
今晚我们会用buff覆盖它

00:39:30.610 --> 00:39:35.650
有条件的测试执行高度

00:39:33.610 --> 00:39:37.450
是改变游戏规则的灵感来源

00:39:35.650 --> 00:39:39.310
就像事实是忽略贾达

00:39:37.450 --> 00:39:41.050
因为然后在春天，我们得到了支持

00:39:39.310 --> 00:39:43.000
如果配置文件值和弹出

00:39:41.050 --> 00:39:44.890
支持诸如条件和

00:39:43.000 --> 00:39:46.420
个人资料之类的东西，所以

00:39:44.890 --> 00:39:48.130
真的很酷，没有也存在

00:39:46.420 --> 00:39:50.110
珍妮特（Janet） 

00:39:48.130 --> 00:39:51.670
条件，如果您无法实施

00:39:50.110 --> 00:39:52.900
禁用是我实施的第一个

00:39:51.670 --> 00:39:54.220
为此，有一个残疾人

00:39:52.900 --> 00:39:56.020
实际支持的条件

00:39:54.220 --> 00:39:56.890
您可以签出代码， 

00:39:56.020 --> 00:39:59.020
就像我说的这是改变游戏规则的人

00:39:56.890 --> 00:40:00.670
因为这不仅是我们要做的

00:39:59.020 --> 00:40:02.350
和Jana，您可以编写自己的

00:40:00.670 --> 00:40:05.860
人们这样做，我真的认为那是

00:40:02.350 --> 00:40:07.390
将会是一个非常受欢迎的功能，为什么

00:40:05.860 --> 00:40:09.400
你可能想做你想做的

00:40:07.390 --> 00:40:10.960
在当前操作系统的基础上使用

00:40:09.400 --> 00:40:13.120
当前Java版本或当前日期

00:40:10.960 --> 00:40:14.440
或类似的东西

00:40:13.120 --> 00:40:15.310
不同的想法系统属性

00:40:14.440 --> 00:40:16.450
这些环境变量

00:40:15.310 --> 00:40:17.950
你可以自己写的东西

00:40:16.450 --> 00:40:19.720
条件，然后将其共享

00:40:17.950 --> 00:40:21.220
您的代码库，会有一些

00:40:19.720 --> 00:40:23.260
正在实施的其他项目

00:40:21.220 --> 00:40:25.510
像这样的东西我做得很酷

00:40:23.260 --> 00:40:27.550
支持和为此

00:40:25.510 --> 00:40:29.230
因此您可以在以下情况下停用这些功能

00:40:27.550 --> 00:40:31.000
你想看看也许我们的测试

00:40:29.230 --> 00:40:32.140
现在仍在工作或正在工作

00:40:31.000 --> 00:40:34.510
我们被禁用了，也许他们坏了

00:40:32.140 --> 00:40:36.220
也许他们现在可以工作了，您可以禁用该功能

00:40:34.510 --> 00:40:38.260
说出6月的激活条件

00:40:36.220 --> 00:40:39.910
以及条件的名称

00:40:38.260 --> 00:40:40.990
包装和图案是如此

00:40:39.910 --> 00:40:43.120
您将其混合在此处运行所有测试

00:40:40.990 --> 00:40:47.230
也许我们在炫酷功能之前就被打破了

00:40:43.120 --> 00:40:49.720
这样，接下来的默认方法

00:40:47.230 --> 00:40:52.120
嗯，嗯，所以八对介绍

00:40:49.720 --> 00:40:54.100
测试界面的概念基本上是

00:40:52.120 --> 00:40:55.960
新泽西和木星，所以你基本上可以

00:40:54.100 --> 00:40:58.930
多重继承和测试

00:40:55.960 --> 00:41:01.150
测试特征，您可以使用一堆

00:40:58.930 --> 00:41:02.680
默认方法中的注释

00:41:01.150 --> 00:41:04.300
毕竟毕竟，但要注意这里

00:41:02.680 --> 00:41:06.130
仅当您在测试中使用它时

00:41:04.300 --> 00:41:08.080
否则每个类的实例生命周期

00:41:06.130 --> 00:41:09.550
这些方法必须是静态的

00:41:08.080 --> 00:41:11.890
每次测试后这些都不一样

00:41:09.550 --> 00:41:15.270
变体标签扩展了所有这些

00:41:11.890 --> 00:41:18.310
那些东西可以包括在那些

00:41:15.270 --> 00:41:24.370
可以这么说测试接口

00:41:18.310 --> 00:41:28.540
我将快速向您展示字符串测试

00:41:24.370 --> 00:41:31.780
如果我要跑步，那就没有测试

00:41:28.540 --> 00:41:34.330
您在这里看到的任何测试方法

00:41:31.780 --> 00:41:37.060
它有测试，所以它们来自哪里

00:41:34.330 --> 00:41:39.280
好吧，我们可以双击它们来自

00:41:37.060 --> 00:41:40.930
默认方法和接口，所以在这里

00:41:39.280 --> 00:41:42.610
我们有一个舒适的合同， 

00:41:40.930 --> 00:41:44.320
等于合同之类的东西

00:41:42.610 --> 00:41:45.760
您可以拥有可重复使用的合同，或者

00:41:44.320 --> 00:41:47.290
测试特质并实施它们

00:41:45.760 --> 00:41:53.080
在测试类中实现它们

00:41:47.290 --> 00:41:55.330
接下来就是重点了

00:41:53.080 --> 00:41:56.590
所以在j和

00:41:55.330 --> 00:41:57.790
负担得起比你多两个跑步者

00:41:56.590 --> 00:41:59.740
知道世界上的自定义跑步者

00:41:57.790 --> 00:42:01.570
基本上允许对此提供支持

00:41:59.740 --> 00:42:04.540
启用逻辑层次分组

00:42:01.570 --> 00:42:06.040
谢里丹的考试课程

00:42:04.540 --> 00:42:07.900
外部的初始化状态

00:42:06.040 --> 00:42:10.090
实例，而您无需

00:42:07.900 --> 00:42:11.890
清除嵌套在非静态上的

00:42:10.090 --> 00:42:13.810
嵌套类也称为内部

00:42:11.890 --> 00:42:16.180
上课权利，你甚至可以结合

00:42:13.810 --> 00:42:18.220
嵌套类和测试接口中

00:42:16.180 --> 00:42:21.580
可以看到测试堆栈的例子

00:42:18.220 --> 00:42:25.420
这在用户指南中很酷

00:42:21.580 --> 00:42:26.830
好测试一个股票演示，所以如果我们看

00:42:25.420 --> 00:42:29.290
在这里，我们看到它利用了um 

00:42:26.830 --> 00:42:31.570
显示名称，它具有此嵌套

00:42:29.290 --> 00:42:33.670
在这里上课，然后有

00:42:31.570 --> 00:42:35.020
在里面自己测试，然后等待哦

00:42:33.670 --> 00:42:36.040
还有更多的嵌套，那是什么

00:42:35.020 --> 00:42:41.770
这看起来像当我们运行它时

00:42:36.040 --> 00:42:46.140
现在有点像BDD风格

00:42:41.770 --> 00:42:48.640
我看这全部展开并放大

00:42:46.140 --> 00:42:50.680
然后我们看到像这样的好东西

00:42:48.640 --> 00:42:52.690
所以你有很多不同的水平

00:42:50.680 --> 00:42:54.280
那里有各种测试方法和

00:42:52.690 --> 00:42:55.960
类以及使用该显示

00:42:54.280 --> 00:42:57.520
您可以使用具有以下名称的自定义名称

00:42:55.960 --> 00:43:00.120
更加BDD风格，这很酷

00:42:57.520 --> 00:43:00.120
以及新功能

00:43:01.880 --> 00:43:06.410
好的重复测试，你只是在说

00:43:04.670 --> 00:43:08.510
重复测试指定您的号码

00:43:06.410 --> 00:43:10.460
可以注入重复信息，如果

00:43:08.510 --> 00:43:11.870
您要立即覆盖自定义显示

00:43:10.460 --> 00:43:13.760
如果你想它看起来像

00:43:11.870 --> 00:43:15.710
我再说一遍，它有五个做到了

00:43:13.760 --> 00:43:17.180
你甚至可以像我一样更改名字

00:43:15.710 --> 00:43:18.560
提到所以如果你这是一个例子

00:43:17.180 --> 00:43:20.420
如果您想将其更改为德语

00:43:18.560 --> 00:43:22.490
说而不是重复两个你之一

00:43:20.420 --> 00:43:23.870
可以说Peter Hold'em了为什么

00:43:22.490 --> 00:43:25.790
如果你会说德语

00:43:23.870 --> 00:43:28.550
所以不同的语言会改变诸如

00:43:25.790 --> 00:43:29.930
那使我们的胸部变得更好

00:43:28.550 --> 00:43:31.460
我们四点钟在周杰伦遇到的一切

00:43:29.930 --> 00:43:34.520
使用参数化测试代替测试

00:43:31.460 --> 00:43:35.690
指定参数来源

00:43:34.520 --> 00:43:37.640
我们有很多东西可以结帐

00:43:35.690 --> 00:43:39.740
用户指南，因此我们很有价值

00:43:37.640 --> 00:43:41.780
直接值字符串的来源

00:43:39.740 --> 00:43:43.280
等获取枚举的枚举源

00:43:41.780 --> 00:43:45.800
常量方法源，因此您可以

00:43:43.280 --> 00:43:47.120
实际上委托给静态方法

00:43:45.800 --> 00:43:50.540
可以作为您工厂的方法

00:43:47.120 --> 00:43:51.740
参数还支持CSV内联

00:43:50.540 --> 00:43:54.230
注释也来自文件系统

00:43:51.740 --> 00:43:55.970
或者你可以有我们的论点来源和

00:43:54.230 --> 00:43:58.730
敲定和自定义参数提供程序

00:43:55.970 --> 00:44:01.370
所以对于转换隐式转换

00:43:58.730 --> 00:44:02.720
适用于大多数基本类型的基因组Java x 

00:44:01.370 --> 00:44:04.340
这样的东西你也可以

00:44:02.720 --> 00:44:07.760
如果实现，则进行显式转换

00:44:04.340 --> 00:44:09.290
这些API实际上是这里的首要HSN 

00:44:07.760 --> 00:44:11.690
看起来像这样，所以添加

00:44:09.290 --> 00:44:14.060
参数化测试值来源列表

00:44:11.690 --> 00:44:15.440
在这里字符串数组这样的事情

00:44:14.060 --> 00:44:17.510
回文是向前读吗？ 

00:44:15.440 --> 00:44:19.970
向后他们工作，并且此测试通过

00:44:17.510 --> 00:44:21.170
在示例代码中，我可以

00:44:19.970 --> 00:44:24.260
今晚显示更多，或者您可以退房

00:44:21.170 --> 00:44:28.070
网上我以后有一个链接这么动态

00:44:24.260 --> 00:44:30.320
测试这是正常的静态写入

00:44:28.070 --> 00:44:31.820
该测试在编译时已知，但

00:44:30.320 --> 00:44:34.340
动态测试在运行时注册

00:44:31.820 --> 00:44:36.020
带着lambda表情参加

00:44:34.340 --> 00:44:40.040
该测试工厂的方法，我们

00:44:36.020 --> 00:44:41.690
有一些不同的方法可以做到这一点

00:44:40.040 --> 00:44:43.790
基本上就像你说的是在测试工厂

00:44:41.690 --> 00:44:45.050
然后返回动态流

00:44:43.790 --> 00:44:46.670
测试或收集列表，例如

00:44:45.050 --> 00:44:47.900
然后，您只需创建自己的

00:44:46.670 --> 00:44:49.010
流式传输，您可以动态构建所有内容

00:44:47.900 --> 00:44:51.200
但是你想以编程方式

00:44:49.010 --> 00:44:53.780
有条件等我们在这里说

00:44:51.200 --> 00:44:55.850
前十个偶数整数，所以从

00:44:53.780 --> 00:44:57.890
零n等于n加2得到第一个

00:44:55.850 --> 00:44:59.390
十取每个数字并创建一个

00:44:57.890 --> 00:45:01.610
动态测试，所以这是一个

00:44:59.390 --> 00:45:03.410
静态工厂从动态测试

00:45:01.610 --> 00:45:04.850
课，我们给它起一个名字，所以测试

00:45:03.410 --> 00:45:06.800
在那被测试的零等等等等

00:45:04.850 --> 00:45:08.690
然后断言真正的表现很紧急

00:45:06.800 --> 00:45:10.010
所以你可以做超级动态的东西

00:45:08.690 --> 00:45:12.079
也可以有容器和si 

00:45:10.010 --> 00:45:14.209
容器也可以

00:45:12.079 --> 00:45:16.459
所以今晚我可能会演示

00:45:14.209 --> 00:45:18.079
我们想缺少什么场景测试

00:45:16.459 --> 00:45:19.189
带入未来

00:45:18.079 --> 00:45:20.420
发布您当前无法订购的订单

00:45:19.189 --> 00:45:22.819
订购测试方法或类似的东西

00:45:20.420 --> 00:45:24.890
尚不支持并行

00:45:22.819 --> 00:45:26.660
在框架本身中执行

00:45:24.890 --> 00:45:27.859
可能会有例如

00:45:26.660 --> 00:45:30.259
甚至可能会确保生火，但这在外面

00:45:27.859 --> 00:45:32.900
平台执行和用户定义

00:45:30.259 --> 00:45:34.939
线程可能针对基于GUI的东西

00:45:32.900 --> 00:45:36.199
还没有，并宣布

00:45:34.939 --> 00:45:38.179
用于Jaina平台的测试套件

00:45:36.199 --> 00:45:41.449
支持使用以下内容的测试套件

00:45:38.179 --> 00:45:43.069
如果您是Jain的平台跑步者

00:45:41.449 --> 00:45:43.459
想要这样做但不适合平台

00:45:43.069 --> 00:45:46.309
本身

00:45:43.459 --> 00:45:47.599
这是一种通用的方式，正如我提到的

00:45:46.309 --> 00:45:49.400
在成为Java 9模块路径之前

00:45:47.599 --> 00:45:51.650
扫描，我们也会尽快添加

00:45:49.400 --> 00:45:54.049
所以我只是简单地谈谈

00:45:51.650 --> 00:45:55.819
这是他们在春天以来的支持

00:45:54.049 --> 00:45:56.929
 Spring Framework 500发布时间

00:45:55.819 --> 00:45:58.999
我知道那个家伙的背

00:45:56.929 --> 00:46:00.979
知道上周吧

00:45:58.999 --> 00:46:03.380
因此支持所有核心测试

00:46:00.979 --> 00:46:05.989
 Spring Plus中的集成支持

00:46:03.380 --> 00:46:08.089
支持依赖注入

00:46:05.989 --> 00:46:10.160
构造函数和方法也很酷

00:46:08.089 --> 00:46:11.829
通过咒语有条件地执行测试

00:46:10.160 --> 00:46:14.989
表达式，所以动态负载表达式

00:46:11.829 --> 00:46:17.179
也可以和spring一起使用

00:46:14.989 --> 00:46:19.699
如果您在我的github仓库中的项目

00:46:17.179 --> 00:46:22.699
想在春季4尝试吉安娜5，并且

00:46:19.699 --> 00:46:23.890
您还没有在5年春季参加，所以

00:46:22.699 --> 00:46:25.939
春天的延伸

00:46:23.890 --> 00:46:27.920
使用med注释简化

00:46:25.939 --> 00:46:29.989
春天简和配置和春天简

00:46:27.920 --> 00:46:33.859
它web.config，然后启用这些

00:46:29.989 --> 00:46:35.179
并禁用，如果注释，所以我会

00:46:33.859 --> 00:46:36.559
必须在抛光期间显示那些

00:46:35.179 --> 00:46:39.289
想我也想指出

00:46:36.559 --> 00:46:40.549
春季靴子也可以在5点钟与Jane合作

00:46:39.289 --> 00:46:42.229
你只是说在春天做测试

00:46:40.549 --> 00:46:43.009
用spring注释扩展，所以我们

00:46:42.229 --> 00:46:45.229
这里有一个例子

00:46:43.009 --> 00:46:48.019
请在春季使用简和木星

00:46:45.229 --> 00:46:49.249
然后你用弹簧靴测试其他东西

00:46:48.019 --> 00:46:51.619
来自春季的靴子来自春季的靴子

00:46:49.249 --> 00:46:53.839
创建一个自定义注释，然后我

00:46:51.619 --> 00:46:55.489
可以像这样超级短

00:46:53.839 --> 00:46:57.259
来自我拥有的所有示例应用程序

00:46:55.489 --> 00:46:59.239
该配置一个注释我

00:46:57.259 --> 00:47:01.189
事件控制器测试自定义显示

00:46:59.239 --> 00:47:03.019
在模拟MVC中命名自动接线

00:47:01.189 --> 00:47:04.880
由Spring Boot自动创建并

00:47:03.019 --> 00:47:09.140
然后用春天嘲笑我看到

00:47:04.880 --> 00:47:11.179
测试，以便在平仓信息中

00:47:09.140 --> 00:47:12.199
在Web上从JDI org开始检查

00:47:11.179 --> 00:47:13.029
查阅用户指南，查看

00:47:12.199 --> 00:47:17.449
参考手册

00:47:13.029 --> 00:47:21.549
 Javadoc等反馈获取您的github堆栈

00:47:17.449 --> 00:47:21.549
溢泉资源

00:47:21.680 --> 00:47:25.529
正如我提到的，请今晚到

00:47:23.970 --> 00:47:28.940
鲍夫，还有另一个话题

00:47:25.529 --> 00:47:39.630
明天更多关于可扩展性和

00:47:28.940 --> 00:47:41.520
这是演示，仅此而已

00:47:39.630 --> 00:47:43.349
为了巡回演出，我会出去

00:47:41.520 --> 00:47:44.780
之后提出问题，并在

00:47:43.349 --> 00:47:50.199
今晚下班，谢谢您的光临

00:47:44.780 --> 00:47:50.199
 [掌声] 

