WEBVTT
Kind: captions
Language: zh-Hans

00:00:04.170 --> 00:00:08.740
就在我们开始作为背景之前

00:00:06.550 --> 00:00:11.320
这样我就不会烧掉一些

00:00:08.740 --> 00:00:14.500
紧张的45分钟，我们有很多

00:00:11.320 --> 00:00:16.920
很多人都知道的幻灯片

00:00:14.500 --> 00:00:16.920
图片

00:00:18.160 --> 00:00:22.750
好，对于你们这些人来说，知道

00:00:21.279 --> 00:00:25.599
那很酷

00:00:22.750 --> 00:00:33.809
以前没有看过的人

00:00:25.599 --> 00:00:36.129
我想这是什么

00:00:33.809 --> 00:00:40.290
终极风管文件

00:00:36.129 --> 00:00:44.280
磁带工程这是阿波罗13号

00:00:40.290 --> 00:00:47.050
二氧化碳洗涤器，或者您实际上有一个

00:00:44.280 --> 00:00:50.460
需要固定在上方的方形钉

00:00:47.050 --> 00:00:55.390
带胶带的圆孔和

00:00:50.460 --> 00:00:57.100
工程师必须从数百人中做到这一点

00:00:55.390 --> 00:01:00.759
千里之外保存

00:00:57.100 --> 00:01:03.759
人们的生活是惊人的

00:01:00.759 --> 00:01:05.950
就像一个真正的英雄行为和事实

00:01:03.759 --> 00:01:07.570
他们必须使这些东西起作用

00:01:05.950 --> 00:01:09.490
一起弄清楚

00:01:07.570 --> 00:01:12.820
上面的小东西

00:01:09.490 --> 00:01:15.790
宇宙飞船很棒，但我喜欢用

00:01:12.820 --> 00:01:17.829
它既是一个真正英雄的例子

00:01:15.790 --> 00:01:19.869
采取我们都会做的那种工程

00:01:17.829 --> 00:01:22.450
自豪地去做，如果你去做

00:01:19.869 --> 00:01:25.420
一辈子很酷的东西

00:01:22.450 --> 00:01:27.429
你这太神奇了，但这也是

00:01:25.420 --> 00:01:29.049
随时随地学习

00:01:27.429 --> 00:01:32.140
这些东西你应该主要

00:01:29.049 --> 00:01:35.049
认为这是我的工作就是做到这一点

00:01:32.140 --> 00:01:37.060
不需要胶带

00:01:35.049 --> 00:01:39.670
工程真的很棒，这很棒

00:01:37.060 --> 00:01:42.429
技巧，如果可以用它来挽救一天

00:01:39.670 --> 00:01:44.979
但是大部分应该是

00:01:42.429 --> 00:01:47.319
避免，只要你看着

00:01:44.979 --> 00:01:49.149
每天要做的事情等于

00:01:47.319 --> 00:01:51.659
将胶带贴在东西上

00:01:49.149 --> 00:01:54.459
问题消失只是记住这一点

00:01:51.659 --> 00:01:58.630
尝试尝试是一件很有用的事情

00:01:54.459 --> 00:02:00.880
避免吧，我将从

00:01:58.630 --> 00:02:05.319
我们要讨论的实际站点

00:02:00.880 --> 00:02:07.450
关于Java的速度，着重于现代

00:02:05.319 --> 00:02:09.520
硬件，现代硬件似乎

00:02:07.450 --> 00:02:13.420
以及我们如何充分利用它

00:02:09.520 --> 00:02:15.459
根据定义，这将是过时的

00:02:13.420 --> 00:02:17.490
谈论几年，因为现代

00:02:15.459 --> 00:02:19.810
那时的硬件将不再是现代的

00:02:17.490 --> 00:02:21.220
但我会尝试着重于一些

00:02:19.810 --> 00:02:24.190
先进的硬件，您可以获得

00:02:21.220 --> 00:02:25.990
今天作为高层议程来处理

00:02:24.190 --> 00:02:29.040
我们将做一些介绍性的动机

00:02:25.990 --> 00:02:31.049
谈论硬件传输功能

00:02:29.040 --> 00:02:33.420
谈论一些编译器的东西，因为

00:02:31.049 --> 00:02:35.459
获得编译器的实际有用性

00:02:33.420 --> 00:02:38.129
去做他们的工作，我们将从

00:02:35.459 --> 00:02:39.870
基础知识并以此为基础

00:02:38.129 --> 00:02:42.329
稍微绕开了微型基准

00:02:39.870 --> 00:02:45.299
例子，希望有时间

00:02:42.329 --> 00:02:46.920
然后再有一些编译器的东西

00:02:45.299 --> 00:02:48.870
有点酷的编译器之类的东西

00:02:46.920 --> 00:02:51.420
只是要做的事情

00:02:48.870 --> 00:02:53.430
真的很酷，然后再说

00:02:51.420 --> 00:02:55.049
关于其他问题的一点点

00:02:53.430 --> 00:02:57.750
现代硬件和现代编译器

00:02:55.049 --> 00:02:59.760
喜欢热身，然后把它全部

00:02:57.750 --> 00:03:02.489
在一起，也许一点点

00:02:59.760 --> 00:03:05.040
吹牛然后我会努力保持

00:03:02.489 --> 00:03:08.639
吹牛直到那时，但在

00:03:05.040 --> 00:03:11.250
最后，我要打破我是吉尔·泰纳（Gill tena）， 

00:03:08.639 --> 00:03:13.859
 CTO与Oh系统，我们制作JVM 

00:03:11.250 --> 00:03:16.709
认为世界上最好的JVM 

00:03:13.859 --> 00:03:19.230
我一直在做垃圾

00:03:16.709 --> 00:03:20.730
收藏约十四年

00:03:19.230 --> 00:03:22.590
十三年

00:03:20.730 --> 00:03:26.280
这实际上是我的文件

00:03:22.590 --> 00:03:28.439
那样做那是垃圾

00:03:26.280 --> 00:03:30.150
我厨房的压实机坏了

00:03:28.439 --> 00:03:31.829
垃圾压实机应该做的

00:03:30.150 --> 00:03:34.169
一周内收集少量垃圾

00:03:31.829 --> 00:03:36.000
因此完整的GC仅每周发生一次

00:03:34.169 --> 00:03:38.970
这就是我们一直使用Java所做的

00:03:36.000 --> 00:03:40.889
无论如何，它被打破了

00:03:38.970 --> 00:03:42.389
碎片整理功能不起作用

00:03:40.889 --> 00:03:44.819
对，你可以看到碎片掉落

00:03:42.389 --> 00:03:47.519
从后面我不得不修复它，这

00:03:44.819 --> 00:03:51.199
是在2004年拍摄的，当时只有十三岁

00:03:47.519 --> 00:03:54.030
年前，所以我真的需要新照片

00:03:51.199 --> 00:03:56.340
我建造了很多东西，这意味着

00:03:54.030 --> 00:03:58.079
我犯了很多错误，我

00:03:56.340 --> 00:04:00.540
从其中一些中学到的，我尝试

00:03:58.079 --> 00:04:02.040
那种你知道的告诉别人

00:04:00.540 --> 00:04:04.579
他们可能会学到的错误

00:04:02.040 --> 00:04:07.799
他们也一样，因为我们使JVM 

00:04:04.579 --> 00:04:10.709
专注于速度专注于延迟

00:04:07.799 --> 00:04:14.609
专注于一致性，所以我们知道

00:04:10.709 --> 00:04:16.229
关于它的一些，我也知道

00:04:14.609 --> 00:04:18.000
作为副主题喜欢谈论

00:04:16.229 --> 00:04:19.620
人们如何衡量事物

00:04:18.000 --> 00:04:22.740
以及响应时间和延迟，这样您就可以

00:04:19.620 --> 00:04:25.550
在网上找到有关我的谈话

00:04:22.740 --> 00:04:28.919
在那个不是这个的租金

00:04:25.550 --> 00:04:32.039
这是关于速度，这是速度

00:04:28.919 --> 00:04:34.639
绝对没有好处

00:04:32.039 --> 00:04:34.639
再说一遍

00:04:35.020 --> 00:04:40.789
但是当我们说

00:04:37.789 --> 00:04:44.289
说我们的意思，所以你知道我们

00:04:40.789 --> 00:04:47.300
我们快慢是一个有效的问题

00:04:44.289 --> 00:04:51.500
但是它必须要有一定的背景

00:04:47.300 --> 00:04:53.210
例如我们什么时候快？ 

00:04:51.500 --> 00:04:55.460
晚上没有人使用时或

00:04:53.210 --> 00:04:57.530
重要的是我们要斋戒吗

00:04:55.460 --> 00:04:59.810
当我们推出新代码时，您知道

00:04:57.530 --> 00:05:02.060
一天20次，我们还是快

00:04:59.810 --> 00:05:04.460
发生这种情况，或者我们放慢了速度

00:05:02.060 --> 00:05:07.360
我们确实死了很慢15 

00:05:04.460 --> 00:05:10.430
分钟，然后大家都开心

00:05:07.360 --> 00:05:13.190
高峰时间怎么样呢？ 

00:05:10.430 --> 00:05:15.949
当什么时候是黑色真的很重要

00:05:13.190 --> 00:05:18.319
星期五或市场开盘或您

00:05:15.949 --> 00:05:22.190
知道什么时候真正重要什么时候慢

00:05:18.319 --> 00:05:26.870
快速不仅在

00:05:22.190 --> 00:05:29.090
平均，你知道你什么时候真正

00:05:26.870 --> 00:05:31.219
做一些交易，例如

00:05:29.090 --> 00:05:35.539
或或在线购买商品

00:05:31.219 --> 00:05:37.479
你在那个时间点快吗

00:05:35.539 --> 00:05:41.389
另一个问题是您可靠吗

00:05:37.479 --> 00:05:43.699
这么快真的很好但是有时候你

00:05:41.389 --> 00:05:46.550
可能很快，但是非常不可靠，并且

00:05:43.699 --> 00:05:48.169
现在的结果有点

00:05:46.550 --> 00:05:49.909
重要的事情要牢记

00:05:48.169 --> 00:05:52.310
真的快可能很危险

00:05:49.909 --> 00:05:54.770
真的非常快然后完全

00:05:52.310 --> 00:05:58.460
停滞一分钟通常不是

00:05:54.770 --> 00:06:00.620
真的很好，所以我们希望速度

00:05:58.460 --> 00:06:02.360
看起来像这样，这就是我们的想法

00:06:00.620 --> 00:06:03.590
速度，当我们说您有多快时

00:06:02.360 --> 00:06:05.800
想对此问题有一个答案

00:06:03.590 --> 00:06:10.789
但这不是正确的问题

00:06:05.800 --> 00:06:13.840
因为没有现实看起来像那样

00:06:10.789 --> 00:06:16.430
 Java现实看起来像这样

00:06:13.840 --> 00:06:18.289
速度无处不在

00:06:16.430 --> 00:06:20.479
慢，你快走，然后你慢走，然后

00:06:18.289 --> 00:06:23.240
你走得快，走得又慢又快， 

00:06:20.479 --> 00:06:25.370
了解什么快慢

00:06:23.240 --> 00:06:26.810
过渡是由它们组成的

00:06:25.370 --> 00:06:29.180
是我们会尝试谈论的事情之一

00:06:26.810 --> 00:06:30.919
关于今天，我将谈论两个或

00:06:29.180 --> 00:06:32.930
影响它的三个主要方面

00:06:30.919 --> 00:06:33.529
然后我们将深入探讨

00:06:32.930 --> 00:06:36.409
速度

00:06:33.529 --> 00:06:39.319
所以Java世界的速度看起来像

00:06:36.409 --> 00:06:40.669
那是因为例如我们的代码

00:06:39.319 --> 00:06:43.880
实际执行通过

00:06:40.669 --> 00:06:45.380
进化我们从慢开始

00:06:43.880 --> 00:06:47.020
解释的代码从字面上看

00:06:45.380 --> 00:06:48.490
解释酒的字节码

00:06:47.020 --> 00:06:51.370
从类中加载它们并

00:06:48.490 --> 00:06:53.770
真的很慢，然后温暖

00:06:51.370 --> 00:06:55.750
足够的JVM决定哦，也许我应该

00:06:53.770 --> 00:06:58.240
对它做一些事情编译它，但是

00:06:55.750 --> 00:07:00.009
尚未完全优化，它将对其进行编译

00:06:58.240 --> 00:07:02.590
与分析代码，以便您可以学习

00:07:00.009 --> 00:07:04.900
这是怎么回事

00:07:02.590 --> 00:07:07.090
它比解释的要快得多，但是

00:07:04.900 --> 00:07:09.310
几乎没有你能走的快

00:07:07.090 --> 00:07:11.830
一旦你弄清楚什么代码

00:07:09.310 --> 00:07:13.629
其实你会抛出一个实际的

00:07:11.830 --> 00:07:15.460
在它上优化JIT编译器并制作

00:07:13.629 --> 00:07:16.960
它运行很快，那就是蓝色代码

00:07:15.460 --> 00:07:18.550
你希望大多数东西在那里

00:07:16.960 --> 00:07:20.259
实际运行，随着时间的流逝， 

00:07:18.550 --> 00:07:21.819
稳定你大部分的东西或

00:07:20.259 --> 00:07:25.870
热门的东西实际上将运行良好

00:07:21.819 --> 00:07:27.599
蓝色代码，但您不从那里开始

00:07:25.870 --> 00:07:31.060
当你看这是什么意思

00:07:27.599 --> 00:07:33.520
行为速度随时间的响应时间

00:07:31.060 --> 00:07:35.409
随着时间的推移，随着时间的推移，响应时间看起来

00:07:33.520 --> 00:07:36.849
之所以这样，是因为我们正在运行

00:07:35.409 --> 00:07:40.120
当我们开始时，代码真的很慢

00:07:36.849 --> 00:07:41.949
真的很慢，然后我们开始替换它

00:07:40.120 --> 00:07:44.740
更快的代码但还不是

00:07:41.949 --> 00:07:47.500
仍然不是真的很快只是更好

00:07:44.740 --> 00:07:49.780
而不是将其解释为绿色的东西

00:07:47.500 --> 00:07:52.900
然后最终，蓝色的东西会

00:07:49.780 --> 00:07:54.550
占主导地位，并会迅速走红

00:07:52.900 --> 00:07:56.469
中间的尖峰是其他东西

00:07:54.550 --> 00:07:58.000
让我们慢下来，就像暂停

00:07:56.469 --> 00:08:01.060
垃圾收集暂停

00:07:58.000 --> 00:08:03.849
优化暂停执行任何操作

00:08:01.060 --> 00:08:05.740
如果我们继续看下去

00:08:03.849 --> 00:08:06.250
以这种速度而不是回应

00:08:05.740 --> 00:08:08.259
时间

00:08:06.250 --> 00:08:10.870
它基本上是一个逆，看起来

00:08:08.259 --> 00:08:12.909
像那样当你真的很慢

00:08:10.870 --> 00:08:15.340
开始那就是你有多慢我们

00:08:12.909 --> 00:08:17.759
谈论30倍的比例而不是

00:08:15.340 --> 00:08:20.650
你知道这是很好的效果的东西

00:08:17.759 --> 00:08:22.389
那么你会更快，但实际上没有

00:08:20.650 --> 00:08:24.550
真的那么快，然后您就可以开始了

00:08:22.389 --> 00:08:26.050
最终真的非常快，但是你

00:08:24.550 --> 00:08:28.500
这些下降到绝对零

00:08:26.050 --> 00:08:32.110
因为停顿而一直加速

00:08:28.500 --> 00:08:36.000
这就是速度的行为

00:08:32.110 --> 00:08:39.550
在Java应用程序中几乎总是

00:08:36.000 --> 00:08:41.440
所以这只是要记住的事情

00:08:39.550 --> 00:08:42.969
我们会回到图片，但是你

00:08:41.440 --> 00:08:45.670
知道我们什么时候看零件以及什么

00:08:42.969 --> 00:08:47.770
我们可以影响速度的哪一部分

00:08:45.670 --> 00:08:49.860
影响不同的技术

00:08:47.770 --> 00:08:52.570
他们每个人都有不同的能力

00:08:49.860 --> 00:08:54.040
让我们看看什么是现代服务器

00:08:52.570 --> 00:08:55.880
我们正在运行的是什么

00:08:54.040 --> 00:08:58.910
机器正在运行

00:08:55.880 --> 00:09:00.890
这主要是英特尔服务器， 

00:08:58.910 --> 00:09:03.620
谈论服务器空间以及这些

00:09:00.890 --> 00:09:06.290
是英特尔的最后一代

00:09:03.620 --> 00:09:11.210
我们现在使用的服务器芯片

00:09:06.290 --> 00:09:12.890
周围的天空SP出来了Brad Wells 

00:09:11.210 --> 00:09:15.530
布朗利已经存在一年了， 

00:09:12.890 --> 00:09:17.330
如果您使用的是现代设备则需要一半

00:09:15.530 --> 00:09:19.190
最近购买的机器或

00:09:17.330 --> 00:09:20.630
您正在EWS或云端上运行

00:09:19.190 --> 00:09:21.860
 Google或Azure或其他之一

00:09:20.630 --> 00:09:23.510
您可能正在其中之一上运行

00:09:21.860 --> 00:09:25.070
两个，如果不是，那你真的应该

00:09:23.510 --> 00:09:27.410
转到这两个之一，为什么你为什么

00:09:25.070 --> 00:09:30.440
特别为旧硬件付费

00:09:27.410 --> 00:09:32.090
在云中，您所拥有的

00:09:30.440 --> 00:09:34.940
右边是一些有趣的东西

00:09:32.090 --> 00:09:36.610
不仅仅是更多的内核和更多的缓存

00:09:34.940 --> 00:09:40.100
那种东西你可以

00:09:36.610 --> 00:09:42.020
期待有新功能的新CPU 

00:09:40.100 --> 00:09:44.540
有了新功能

00:09:42.020 --> 00:09:46.190
在最后几个的甲板上

00:09:44.540 --> 00:09:48.590
世代和那些功能可以

00:09:46.190 --> 00:09:52.250
用于极限速度

00:09:48.590 --> 00:09:53.120
如果任务是

00:09:52.250 --> 00:09:54.860
实际上在它们上运行的代码

00:09:53.120 --> 00:09:56.900
了解那里的那些功能并且可以

00:09:54.860 --> 00:09:58.700
被使用，我会给你一些例子

00:09:56.900 --> 00:10:01.400
这些当我们看功能时

00:09:58.700 --> 00:10:03.260
矢量化AVX avx2 

00:10:01.400 --> 00:10:05.270
和avx-512真的很酷

00:10:03.260 --> 00:10:08.510
进化的矢量化功能

00:10:05.270 --> 00:10:10.270
最近几代人的BMI和

00:10:08.510 --> 00:10:12.110
 BMI的两个是Bittman仿真

00:10:10.270 --> 00:10:13.910
说明包括

00:10:12.110 --> 00:10:17.090
散布善良的收集点

00:10:13.910 --> 00:10:20.300
 TSX的凉爽与欢乐

00:10:17.090 --> 00:10:22.880
具有的事务存储功能

00:10:20.300 --> 00:10:26.180
来了，现在每个新CPU都是商品

00:10:22.880 --> 00:10:30.620
使用它们将它们放在服务器上

00:10:26.180 --> 00:10:33.320
功能可以提供超越

00:10:30.620 --> 00:10:35.780
 CPU本身就是功能

00:10:33.320 --> 00:10:37.220
变得更好，他们已经真的

00:10:35.780 --> 00:10:38.690
真的很好，他们只是不断

00:10:37.220 --> 00:10:42.500
越来越好，你可以看到一些

00:10:38.690 --> 00:10:44.270
趋势这里有多少条指令

00:10:42.500 --> 00:10:45.920
 CPU可以保留的订购说明

00:10:44.270 --> 00:10:48.470
没有他们同时玩杂耍

00:10:45.920 --> 00:10:50.150
但完成的过程却越来越多

00:10:48.470 --> 00:10:52.520
已经非常非常令人印象深刻，但是

00:10:50.150 --> 00:10:54.530
我们一直在不断上升，CPU 

00:10:52.520 --> 00:10:56.300
这些天不是这个简单的系列

00:10:54.530 --> 00:10:58.700
在某处做指令的东西

00:10:56.300 --> 00:11:00.740
时间或其中的四个或八个

00:10:58.700 --> 00:11:02.510
交错的字面意思是吐

00:11:00.740 --> 00:11:03.860
空中捕捉200条指令

00:11:02.510 --> 00:11:06.180
他们，然后当他们完成时，和

00:11:03.860 --> 00:11:08.730
保持了松狮犬的出没

00:11:06.180 --> 00:11:12.990
不去，那里有什么

00:11:08.730 --> 00:11:14.850
像96或72个不同的负载

00:11:12.990 --> 00:11:17.610
在56家不同商店中表现出色

00:11:14.850 --> 00:11:19.500
尚无未完成的订单

00:11:17.610 --> 00:11:21.899
去记忆只是为了保持

00:11:19.500 --> 00:11:23.520
管道已满，这意味着

00:11:21.899 --> 00:11:26.880
发生的事情的心理模型

00:11:23.520 --> 00:11:28.649
 CPU很难投影，因为您

00:11:26.880 --> 00:11:30.630
可能认为这发生在那之前

00:11:28.649 --> 00:11:32.010
但CPU会做任何可以做的事

00:11:30.630 --> 00:11:35.160
接好工作，然后按部就班

00:11:32.010 --> 00:11:38.550
只是为了完成工作，那就是

00:11:35.160 --> 00:11:42.029
这么大的地方是一扇窗户

00:11:38.550 --> 00:11:44.790
很好地订购的能力

00:11:42.029 --> 00:11:48.450
不存在的编译器也很难

00:11:44.790 --> 00:11:50.040
时间做得好，你需要思考

00:11:48.450 --> 00:11:52.800
在操作基础上

00:11:50.040 --> 00:11:55.140
而不是如何对CPU进行微优化

00:11:52.800 --> 00:11:57.839
这是一些漂亮的图片，以及如何

00:11:55.140 --> 00:12:00.120
东西从体系结构分解

00:11:57.839 --> 00:12:02.850
观点和一些演变

00:12:00.120 --> 00:12:09.240
他们这样，例如

00:12:02.850 --> 00:12:12.950
我们拥有的数据资料的前端

00:12:09.240 --> 00:12:14.940
有东西进来，我们有

00:12:12.950 --> 00:12:18.209
调度程序进入不同的

00:12:14.940 --> 00:12:20.880
操作以及缓存中的其余部分

00:12:18.209 --> 00:12:23.459
继续，但我们可以看到进化

00:12:20.880 --> 00:12:25.920
一个半桥的例子

00:12:23.459 --> 00:12:28.830
几代人回到Haswell 

00:12:25.920 --> 00:12:30.570
只是拥有更多的带宽

00:12:28.830 --> 00:12:32.459
巴士的单位更大

00:12:30.570 --> 00:12:34.589
缓存操作数量增加

00:12:32.459 --> 00:12:36.810
因此，如果您有更多带宽

00:12:34.589 --> 00:12:38.520
看一下实际的执行单位

00:12:36.810 --> 00:12:40.890
那么头盔是最古老的

00:12:38.520 --> 00:12:43.110
在桑迪桥的最下方

00:12:40.890 --> 00:12:45.060
我们得到了更多的执行单元

00:12:43.110 --> 00:12:47.940
同时做事更广泛

00:12:45.060 --> 00:12:50.579
他们可以做更广泛的操作CPU 

00:12:47.940 --> 00:12:53.070
随着时间的流逝和缓存的不断完善

00:12:50.579 --> 00:12:54.930
自己看起来像这样

00:12:53.070 --> 00:12:58.230
每个核心都有相当长的一段时间

00:12:54.930 --> 00:13:02.130
总共30 TK数据中的32k 

00:12:58.230 --> 00:13:04.050
指令缓存256 K of 2和a 

00:13:02.130 --> 00:13:05.730
跨所有内核共享缓存

00:13:04.050 --> 00:13:07.950
一起放在一个插座中，这样更多的核心

00:13:05.730 --> 00:13:09.839
你有更多的现金

00:13:07.950 --> 00:13:11.790
最新的Skylake SP 

00:13:09.839 --> 00:13:13.770
一代你现在就可以得到

00:13:11.790 --> 00:13:15.009
您可以在Google Cloud引擎上运行

00:13:13.770 --> 00:13:16.930
运行它们

00:13:15.009 --> 00:13:18.430
已经改变了这种模式

00:13:16.930 --> 00:13:21.040
缓存转移

00:13:18.430 --> 00:13:22.509
另一个巨大的改进

00:13:21.040 --> 00:13:24.910
最近发生在

00:13:22.509 --> 00:13:28.060
 Haswell代的增长

00:13:24.910 --> 00:13:31.839
 TLB缓存TLB缓存是CPU缓存

00:13:28.060 --> 00:13:34.959
保持周围和最多的映射

00:13:31.839 --> 00:13:38.829
 Haswell非小页数

00:13:34.959 --> 00:13:40.750
低几十度的地图很小

00:13:38.829 --> 00:13:43.029
与以及广泛的井和天空

00:13:40.750 --> 00:13:45.670
我们现在有成千上万的条目

00:13:43.029 --> 00:13:47.579
缓存两个兆字节的页面映射

00:13:45.670 --> 00:13:50.199
表示并发缓存

00:13:47.579 --> 00:13:54.040
虚拟内存的映射已经消失了

00:13:50.199 --> 00:13:55.839
上升了多个数量级

00:13:54.040 --> 00:13:58.029
最终我们实际上可以访问大

00:13:55.839 --> 00:14:00.490
堆和数据，而不破坏TLB和

00:13:58.029 --> 00:14:03.939
一直以来，密森都迈出了巨大的一步

00:14:00.490 --> 00:14:05.470
在常春藤桥和哈斯韦尔之间

00:14:03.939 --> 00:14:06.879
没被谈论很多，但是我们

00:14:05.470 --> 00:14:08.129
可以在结果中看到它，特别是在

00:14:06.879 --> 00:14:10.839
大型数据集

00:14:08.129 --> 00:14:13.149
看着道歉，这些怎么做

00:14:10.839 --> 00:14:14.910
汇集大多数服务器

00:14:13.149 --> 00:14:18.579
最终会像这样运行

00:14:14.910 --> 00:14:20.550
两个插槽，每个插槽上有多个内核

00:14:18.579 --> 00:14:22.569
和每个上的内存控制器

00:14:20.550 --> 00:14:25.360
两个插座之间互连

00:14:22.569 --> 00:14:27.880
带有一些高速qpi或其他种类的

00:14:25.360 --> 00:14:30.880
每个插座的互连

00:14:27.880 --> 00:14:33.100
如果我们看一个核心

00:14:30.880 --> 00:14:34.600
您要查看的特定示例

00:14:33.100 --> 00:14:37.209
他们坐在那里的核心

00:14:34.600 --> 00:14:39.579
高速环上的插座

00:14:37.209 --> 00:14:41.649
缓存被本地化为

00:14:39.579 --> 00:14:44.350
环周围的分布式通用缓存

00:14:41.649 --> 00:14:46.120
这是一个很好的默认值，您可以考虑一下

00:14:44.350 --> 00:14:48.250
你想到一个插座有一堆

00:14:46.120 --> 00:14:51.009
当然在环上共用钥匙

00:14:48.250 --> 00:14:52.449
这不再是有效的模型，因为

00:14:51.009 --> 00:14:54.519
过去肯定是好的

00:14:52.449 --> 00:14:56.529
当然可以，但是我们可以

00:14:54.519 --> 00:14:58.209
知道合适，戒指上有很多芯

00:14:56.529 --> 00:15:00.519
不再那么所以我们现在看起来像这样

00:14:58.209 --> 00:15:04.029
它们在一个环上是多个环

00:15:00.519 --> 00:15:05.920
从一个插座到L3的插座

00:15:04.029 --> 00:15:08.079
在同一个套接字上缓存

00:15:05.920 --> 00:15:10.329
过竖琴，做各种

00:15:08.079 --> 00:15:14.319
实际上，您可以配置其他东西

00:15:10.329 --> 00:15:16.959
今天的配置说

00:15:14.319 --> 00:15:18.699
对待这是一个对称的扁平插座

00:15:16.959 --> 00:15:20.649
或者是所谓的集群，我

00:15:18.699 --> 00:15:22.360
那说这就像两个分开的

00:15:20.649 --> 00:15:24.370
在窗口中插入新的Mono Darren 

00:15:22.360 --> 00:15:26.550
他们每个都是缓存的一半，但我们不

00:15:24.370 --> 00:15:28.980
跨越他们之间的这种联系

00:15:26.550 --> 00:15:31.590
因为它有更高的延迟

00:15:28.980 --> 00:15:33.660
配置偏差级别

00:15:31.590 --> 00:15:35.070
如果你真的不，你可能不会

00:15:33.660 --> 00:15:37.290
了解你是否真的不是

00:15:35.070 --> 00:15:39.660
很好理解，但是四个人

00:15:37.290 --> 00:15:42.330
想要微调延迟性能

00:15:39.660 --> 00:15:44.630
发挥每一分的性能

00:15:42.330 --> 00:15:46.890
这些是要记住的事情

00:15:44.630 --> 00:15:49.020
现在要记住的另一件事是

00:15:46.890 --> 00:15:51.570
这是一个完整的插座

00:15:49.020 --> 00:15:55.500
所有的核心，但您有选择

00:15:51.570 --> 00:16:01.200
可以买八八核12核14 16 

00:15:55.500 --> 00:16:05.760
 18 24有时候你买这个，你买一个

00:16:01.200 --> 00:16:07.560
像是不是真的响了一半

00:16:05.760 --> 00:16:09.030
所有汽车的制造都相等

00:16:07.560 --> 00:16:10.730
那些等于一个的是

00:16:09.030 --> 00:16:13.980
某些尺寸在中间

00:16:10.730 --> 00:16:16.020
现在也经常发生这种情况

00:16:13.980 --> 00:16:18.270
与天空之湖带环的这张照片

00:16:16.020 --> 00:16:19.970
你也看到了巨大的变化

00:16:18.270 --> 00:16:22.590
左侧的先前架构

00:16:19.970 --> 00:16:24.510
 Skylake转向网状架构

00:16:22.590 --> 00:16:27.450
在芯片上有点像二维矩阵

00:16:24.510 --> 00:16:29.730
你去哪里而不是环

00:16:27.450 --> 00:16:32.370
向下看似互连的矩阵

00:16:29.730 --> 00:16:35.700
像那样，在那种情况下

00:16:32.370 --> 00:16:38.760
有趣的水平，你可以

00:16:35.700 --> 00:16:40.590
看看什么是小帐篷的核心东西

00:16:38.760 --> 00:16:42.330
看起来像是18个更大的核心

00:16:40.590 --> 00:16:43.950
看起来像在那边，这些都是

00:16:42.330 --> 00:16:45.870
您可以找到的东西都知道

00:16:43.950 --> 00:16:47.730
关于微信的各种文章

00:16:45.870 --> 00:16:52.080
 Skylake和Broadwell的体系结构

00:16:47.730 --> 00:16:53.900
和网上的东西，这有点

00:16:52.080 --> 00:16:57.930
上下文以及我们正在运行的内容

00:16:53.900 --> 00:16:59.550
现在让我们降低一点，如果

00:16:57.930 --> 00:17:01.200
就像机器代码一样

00:16:59.550 --> 00:17:02.820
如果您不喜欢看，请享受

00:17:01.200 --> 00:17:03.750
机器代码深呼吸一下

00:17:02.820 --> 00:17:07.530
不会花很长时间

00:17:03.750 --> 00:17:09.360
好吧，诺言不会伤害我喜欢看的

00:17:07.530 --> 00:17:11.580
根据实际指示，我们要求

00:17:09.360 --> 00:17:13.230
 CPU一起玩耍并观看

00:17:11.580 --> 00:17:15.540
这是怎么回事，因为我们都有

00:17:13.230 --> 00:17:17.700
这些不同的CPU真的很酷

00:17:15.540 --> 00:17:19.230
关于准时制的事情是它可以选择

00:17:17.700 --> 00:17:21.630
针对实际的CPU进行优化

00:17:19.230 --> 00:17:24.720
运行在没有二进制代码， 

00:17:21.630 --> 00:17:26.430
预先发货，所以专用的JVM 

00:17:24.720 --> 00:17:27.780
它可以在较旧的硬件上运行

00:17:26.430 --> 00:17:30.300
较新的硬件，它可能会产生

00:17:27.780 --> 00:17:31.740
每个都有不同的说明，所以让我们

00:17:30.300 --> 00:17:35.400
看看我们做什么时实际发生了什么

00:17:31.740 --> 00:17:37.620
这样，当我放大机器代码时

00:17:35.400 --> 00:17:39.240
使用zing的功能就是

00:17:37.620 --> 00:17:39.500
认为真的很酷，它是内置的

00:17:39.240 --> 00:17:41.660
在

00:17:39.500 --> 00:17:43.400
分析器，基本上，如果您把

00:17:41.660 --> 00:17:45.650
您的代码在像我这样的热循环中

00:17:43.400 --> 00:17:48.110
我有几个基准和循环

00:17:45.650 --> 00:17:49.910
弹出基于网络的屏幕，看看如何

00:17:48.110 --> 00:17:52.070
我花了很多时间

00:17:49.910 --> 00:17:54.590
单击其中之一，然后查看实际

00:17:52.070 --> 00:17:56.180
机器指令看起来像

00:17:54.590 --> 00:17:57.650
这是非常可读的权利

00:17:56.180 --> 00:17:59.900
我可以去弄清楚每个

00:17:57.650 --> 00:18:02.560
指令的功能以及它如何映射到我的

00:17:59.900 --> 00:18:05.810
编写代码有点困难

00:18:02.560 --> 00:18:07.820
这是代码，这是Java代码，这是

00:18:05.810 --> 00:18:10.790
实际循环和基准

00:18:07.820 --> 00:18:12.800
知道我们对一个数组求和

00:18:10.790 --> 00:18:17.690
简单地将数组中的所有内容相加， 

00:18:12.800 --> 00:18:20.060
这是现在生成的代码

00:18:17.690 --> 00:18:22.670
这本身不是很可读

00:18:20.060 --> 00:18:25.100
不要试图读一个很酷的东西

00:18:22.670 --> 00:18:28.010
我使用探查器读取的原因

00:18:25.100 --> 00:18:31.730
代码是个人资料还告诉我

00:18:28.010 --> 00:18:34.910
我在那里度过时光，你会看到

00:18:31.730 --> 00:18:36.080
在那边的那些百分比

00:18:34.910 --> 00:18:38.020
我关心的代码

00:18:36.080 --> 00:18:40.700
这实际上是需要时间的代码

00:18:38.020 --> 00:18:42.410
由于上的小百分比

00:18:40.700 --> 00:18:44.240
网站告诉我我现在正在执行该代码

00:18:42.410 --> 00:18:45.980
我知道这是实际的循环

00:18:44.240 --> 00:18:48.590
否则我真的不需要阅读

00:18:45.980 --> 00:18:50.240
它正在进入循环并退出

00:18:48.590 --> 00:18:54.080
在特殊条件下循环执行

00:18:50.240 --> 00:18:57.100
循环是不重要的

00:18:54.080 --> 00:19:01.390
我们在这里看到的是

00:18:57.100 --> 00:19:04.220
相对较旧的Westmere处理器

00:19:01.390 --> 00:19:05.960
 128位矢量化SOC以及我们可以做到的

00:19:04.220 --> 00:19:08.420
看到这里是那个循环不

00:19:05.960 --> 00:19:11.600
转换为让我们在一个整数

00:19:08.420 --> 00:19:16.460
时间，但我们有这些抱歉，我们有

00:19:11.600 --> 00:19:20.030
这些向量化指令

00:19:16.460 --> 00:19:22.250
基本上说读取128位是4 

00:19:20.030 --> 00:19:23.810
整数到一个寄存器4个整数

00:19:22.250 --> 00:19:26.570
到另一个八的寄存器中

00:19:23.810 --> 00:19:29.930
然后将不同的整数存入寄存器

00:19:26.570 --> 00:19:31.670
做那些广告并循环

00:19:29.930 --> 00:19:34.540
最终他们将添加矢量

00:19:31.670 --> 00:19:36.860
在一起，这是一个很好的向量化

00:19:34.540 --> 00:19:39.020
通过最有效的方式进行优化

00:19:36.860 --> 00:19:40.910
会做这个热点会做这个rjv 

00:19:39.020 --> 00:19:43.430
并会做到这一点，这是少

00:19:40.910 --> 00:19:45.590
很久很久很简单

00:19:43.430 --> 00:19:47.150
这正是向量的优点

00:19:45.590 --> 00:19:50.090
循环数组之类的事情

00:19:47.150 --> 00:19:51.590
是的，但是如果我们看完全一样的话

00:19:50.090 --> 00:19:52.080
比您的硬件更重要的是

00:19:51.590 --> 00:19:53.730
墙网

00:19:52.080 --> 00:19:56.760
它有矢量指令

00:19:53.730 --> 00:19:58.320
两倍宽，在这里您知道我们的喷气式飞机

00:19:56.760 --> 00:20:00.179
例如，编译器会认识到

00:19:58.320 --> 00:20:02.730
这有能力做到这一点， 

00:20:00.179 --> 00:20:05.039
生成既是

00:20:02.730 --> 00:20:07.409
两倍宽，但更重要的是

00:20:05.039 --> 00:20:09.090
有加载和添加的说明

00:20:07.409 --> 00:20:10.710
在一个指令中而不是

00:20:09.090 --> 00:20:13.890
分开加载并添加说明，以便

00:20:10.710 --> 00:20:15.980
我们给每一个更多的整数

00:20:13.890 --> 00:20:18.570
循环的迭代

00:20:15.980 --> 00:20:20.130
 AVX的两个说明也很广泛

00:20:18.570 --> 00:20:22.380
每个周期执行两次

00:20:20.130 --> 00:20:24.899
比以前更多了，所以我们得到了很多

00:20:22.380 --> 00:20:26.399
更快，所以这些都是不错的示范

00:20:24.899 --> 00:20:27.929
只是简单的向量，我们

00:20:26.399 --> 00:20:31.500
可以处理它们，但简单的向量

00:20:27.929 --> 00:20:33.679
有点无聊，因为是的，男人

00:20:31.500 --> 00:20:35.909
你只是把这些东西汇总成一个数组

00:20:33.679 --> 00:20:37.919
如果您正在寻找东西怎么办

00:20:35.909 --> 00:20:40.679
如果您只想添加某些内容

00:20:37.919 --> 00:20:43.740
数字在一起，如果你坚持如果

00:20:40.679 --> 00:20:46.950
在您的循环中，这是一个很好的例子

00:20:43.740 --> 00:20:51.720
我在阵列上运行的位置，但我在

00:20:46.950 --> 00:20:53.519
只会加上我测试的偶数

00:20:51.720 --> 00:20:56.370
如果是偶数，我将其添加

00:20:53.519 --> 00:20:58.559
否则，现在跳过它会出现一个

00:20:56.370 --> 00:21:00.000
向量的问题，因为我们没有

00:20:58.559 --> 00:21:01.590
想添加我们只想添加的所有内容

00:21:00.000 --> 00:21:04.620
仅在有选择地添加内容时

00:21:01.590 --> 00:21:06.690
匹配，如果我们看看传统

00:21:04.620 --> 00:21:08.730
 JIT会做到这一点，我们得到此代码

00:21:06.690 --> 00:21:11.250
你实际上可以看到它的展开

00:21:08.730 --> 00:21:14.970
代码两次逻辑，但是

00:21:11.250 --> 00:21:17.970
从字面上接受它跳过的整数测试

00:21:14.970 --> 00:21:19.649
如果它甚至没有做添加，如果

00:21:17.970 --> 00:21:22.500
每个循环有两个，但是

00:21:19.649 --> 00:21:25.309
这里根本没有向量化，为什么

00:21:22.500 --> 00:21:29.700
因为有一个F权利，我们不能只是

00:21:25.309 --> 00:21:32.070
盲目地去做这件事x86中的V x2 

00:21:29.700 --> 00:21:35.570
增加了一个非常酷的功能

00:21:32.070 --> 00:21:38.460
向量是一种掩盖能力， 

00:21:35.570 --> 00:21:41.490
这就是我们最新的JIT所提供的

00:21:38.460 --> 00:21:44.190
我们在Xing中拥有的Falcon JIT 

00:21:41.490 --> 00:21:46.350
是相同的代码，但它映射并

00:21:44.190 --> 00:21:49.760
认识到它正在支持avx2的系统上运行

00:21:46.350 --> 00:21:52.799
硬件及其实际作用是

00:21:49.760 --> 00:21:55.889
此代码有四个交错

00:21:52.799 --> 00:21:58.980
条带化的操作集，但有

00:21:55.889 --> 00:22:02.360
没有分支在这里加载数据

00:21:58.980 --> 00:22:05.350
然后测试向量中的所有数据

00:22:02.360 --> 00:22:07.929
然后使用该测试的结果

00:22:05.350 --> 00:22:10.029
屏蔽负载以屏蔽广告和屏蔽

00:22:07.929 --> 00:22:12.130
因此只存储实际

00:22:10.029 --> 00:22:13.480
在其中有一个是实际应用

00:22:12.130 --> 00:22:16.509
在向量中，因为指令

00:22:13.480 --> 00:22:18.070
无法做到这一点，因为

00:22:16.509 --> 00:22:20.039
指示现在可以做到

00:22:18.070 --> 00:22:23.409
在循环中运行大约快六倍

00:22:20.039 --> 00:22:25.630
现在，这令人印象深刻

00:22:23.409 --> 00:22:29.080
是avx2，您知道这是最新的

00:22:25.630 --> 00:22:31.570
直到几个月前最大

00:22:29.080 --> 00:22:34.950
现在最伟大的是天空湖

00:22:31.570 --> 00:22:39.429
转到avx-512，它再次出现两次

00:22:34.950 --> 00:22:45.549
 512位向量是很多

00:22:39.429 --> 00:22:48.509
提示正确，所以它是64字节，它是16 

00:22:45.549 --> 00:22:51.220
单个向量指令中的整数

00:22:48.509 --> 00:22:52.809
这是相同代码的样子

00:22:51.220 --> 00:22:56.220
最新的Scylla护理速度和

00:22:52.809 --> 00:22:56.220
我今天早上做了的Google引擎

00:22:56.429 --> 00:23:02.350
此循环每个执行64个元素

00:23:00.370 --> 00:23:04.210
处理器的循环迭代

00:23:02.350 --> 00:23:07.629
超标量，将执行两个

00:23:04.210 --> 00:23:09.490
每个周期的指令以及

00:23:07.629 --> 00:23:13.000
令人印象深刻的事情是我计时

00:23:09.490 --> 00:23:16.690
这个特定循环的速度有多快

00:23:13.000 --> 00:23:19.480
大约有16或170亿

00:23:16.690 --> 00:23:21.299
 CPU的每秒操作数

00:23:19.480 --> 00:23:23.679
以2.3 GHz的频率运行

00:23:21.299 --> 00:23:27.519
当我说十亿操作时

00:23:23.679 --> 00:23:29.350
每秒十亿个广告，如果您认为

00:23:27.519 --> 00:23:31.419
关于单个广告中涉及的内容

00:23:29.350 --> 00:23:32.649
必须绕过一个循环

00:23:31.419 --> 00:23:38.590
你知道的操作

00:23:32.649 --> 00:23:41.620
好计数不要运行循环测试负载

00:23:38.590 --> 00:23:43.149
整数测试整数决定

00:23:41.620 --> 00:23:44.950
是否对

00:23:43.149 --> 00:23:48.490
整数我正在阅读代码

00:23:44.950 --> 00:23:52.210
你知道然后把那个整数加到

00:23:48.490 --> 00:23:53.889
求和并存储到另一个

00:23:52.210 --> 00:23:56.350
您正在查看的数组

00:23:53.889 --> 00:24:00.190
像8或9个独立逻辑

00:23:56.350 --> 00:24:02.379
每次迭代的操作，我们

00:24:00.190 --> 00:24:06.730
在运行2.3的CPU上运行

00:24:02.379 --> 00:24:09.639
千兆赫，但它增加了约17 

00:24:06.730 --> 00:24:11.649
每秒十亿个

00:24:09.639 --> 00:24:13.210
因为向量存在而这一切

00:24:11.649 --> 00:24:15.159
因为那里的说明和

00:24:13.210 --> 00:24:16.899
能够将代码与CPU匹配

00:24:15.159 --> 00:24:18.220
然后说哦，你困了，你可以

00:24:16.899 --> 00:24:20.840
做得更好

00:24:18.220 --> 00:24:24.020
所以这给人一种现代感

00:24:20.840 --> 00:24:26.480
硬件最终可以做到这一点

00:24:24.020 --> 00:24:28.820
归结为一件非常简单的事情

00:24:26.480 --> 00:24:31.490
这个东西，并使其更快

00:24:28.820 --> 00:24:34.190
对，所以更快的代码意味着解除

00:24:31.490 --> 00:24:37.070
事情的右边走得更快

00:24:34.190 --> 00:24:40.370
这就是更好的硬件的大部分

00:24:37.070 --> 00:24:43.790
所有这些都会带来更好的优化

00:24:40.370 --> 00:24:45.260
我们这样，因为通常就是这些

00:24:43.790 --> 00:24:47.150
大多数人都感兴趣，我要

00:24:45.260 --> 00:24:48.980
进入一些特定的编译器

00:24:47.150 --> 00:24:50.750
优化，我们已经完成了

00:24:48.980 --> 00:24:54.100
机器代码（如果要离开的话），因为

00:24:50.750 --> 00:24:54.100
你可以回来的机器代码

00:24:55.000 --> 00:24:59.570
我将从非常简单的开始

00:24:57.410 --> 00:25:01.100
 ABC的编译器优化排序

00:24:59.570 --> 00:25:03.140
并从那里建立不需要的东西

00:25:01.100 --> 00:25:05.480
此发行版的任何背景，让我们

00:25:03.140 --> 00:25:07.130
从简单的编译器技巧开始

00:25:05.480 --> 00:25:08.840
允许编译器接受您的代码

00:25:07.130 --> 00:25:10.370
并将其变形为

00:25:08.840 --> 00:25:12.410
在逻辑上等效

00:25:10.370 --> 00:25:13.730
在语义上做同样的事情

00:25:12.410 --> 00:25:15.860
只要允许同样的事情

00:25:13.730 --> 00:25:18.260
这样执行，让我们变得愚蠢

00:25:15.860 --> 00:25:20.900
这里的代码愚蠢的代码可以

00:25:18.260 --> 00:25:22.790
例如，编译器可以这样做

00:25:20.900 --> 00:25:24.530
改变操作顺序吧

00:25:22.790 --> 00:25:26.690
不必按照您的顺序进行操作

00:25:24.530 --> 00:25:29.450
只要你看不到就写

00:25:26.690 --> 00:25:34.100
我可以移动的那个和那个的区别

00:25:29.450 --> 00:25:36.380
你周围的那条线我也可以

00:25:34.100 --> 00:25:38.660
对我的结果没有影响的代码

00:25:36.380 --> 00:25:41.240
杀死那就是所谓的

00:25:38.660 --> 00:25:43.910
无效代码，例如该行

00:25:41.240 --> 00:25:45.559
无论我是否运行都没有

00:25:43.910 --> 00:25:48.200
不会影响编译器的结果

00:25:45.559 --> 00:25:50.000
弄清楚这并没有做你

00:25:48.200 --> 00:25:51.830
无法衡量我是否这样做

00:25:50.000 --> 00:25:55.910
我不这样做真的真的很快

00:25:51.830 --> 00:25:58.100
快不做我也可以取值

00:25:55.910 --> 00:25:59.600
并在操作中传播它们

00:25:58.100 --> 00:26:02.690
而不是像你写的那样做

00:25:59.600 --> 00:26:05.000
他们，例如，我可以接受和

00:26:02.690 --> 00:26:06.530
将其翻译成我没有的代码

00:26:05.000 --> 00:26:09.290
实际上必须创建临时

00:26:06.530 --> 00:26:11.210
变量把东西放进去

00:26:09.290 --> 00:26:12.650
最后，您不需要它们

00:26:11.210 --> 00:26:15.530
他们会被扔掉，我可以

00:26:12.650 --> 00:26:17.420
只是做数学，在那个数学里我

00:26:15.530 --> 00:26:21.920
也可以简化数学，请参阅

00:26:17.420 --> 00:26:26.419
加y减y所以我只能说

00:26:21.920 --> 00:26:28.669
 X加X这是一个非常简单的人

00:26:26.419 --> 00:26:31.130
该代码的优化不是很好

00:26:28.669 --> 00:26:33.830
智能代码编译器会做到这一点

00:26:31.130 --> 00:26:36.530
不是这个，实际上所有编译器都是

00:26:33.830 --> 00:26:38.450
会为您做任何编译器

00:26:36.530 --> 00:26:42.290
你被告知要尝试优化，就是这样

00:26:38.450 --> 00:26:44.320
现在看到这种东西并不稀奇

00:26:42.290 --> 00:26:47.630
让我们看看一些技巧

00:26:44.320 --> 00:26:50.300
传播数据信息

00:26:47.630 --> 00:26:54.230
计算实际上可以影响流量，因此

00:26:50.300 --> 00:26:57.740
以这个例子为例

00:26:54.230 --> 00:26:59.990
如果这个值很大，我们有一个if 

00:26:57.740 --> 00:27:02.510
做一些小事，我们做

00:26:59.990 --> 00:27:05.210
其他的东西，但我们知道

00:27:02.510 --> 00:27:07.720
值为5，允许编译器执行

00:27:05.210 --> 00:27:10.190
采取该代码并将其简化为此

00:27:07.720 --> 00:27:11.660
因为它是if的第一部分

00:27:10.190 --> 00:27:13.970
如果第二部分不会发生

00:27:11.660 --> 00:27:16.070
表示偏差为1，我们可以很好地返回偏差

00:27:13.970 --> 00:27:19.300
表示我们返回1我们实际上没有

00:27:16.070 --> 00:27:21.860
执行其中的任何东西

00:27:19.300 --> 00:27:23.750
影响值的传播

00:27:21.860 --> 00:27:25.070
我是否会流动并杀死

00:27:23.750 --> 00:27:27.680
部分代码，因为它在

00:27:25.070 --> 00:27:30.290
传播优化，我们也可以

00:27:27.680 --> 00:27:32.330
如果我从

00:27:30.290 --> 00:27:34.010
数组中的字段，我不必阅读

00:27:32.330 --> 00:27:36.230
每次您写来阅读它时，我

00:27:34.010 --> 00:27:38.330
可以阅读一次并多次使用

00:27:36.230 --> 00:27:40.660
例如，如果我有这段代码

00:27:38.330 --> 00:27:43.400
说读XY z-我被允许

00:27:40.660 --> 00:27:46.760
有效地将点X一次读入一个

00:27:43.400 --> 00:27:48.710
临时并现在多次使用

00:27:46.760 --> 00:27:50.780
这似乎很简单，我会得到一个

00:27:48.710 --> 00:27:55.100
为此赢得一点点，但让我们

00:27:50.780 --> 00:28:01.010
对他们来说，如果更高

00:27:55.100 --> 00:28:03.350
我们有这个循环，你知道

00:28:01.010 --> 00:28:06.500
可以缓存读取，您知道我正在运行

00:28:03.350 --> 00:28:09.110
只要未设置标志就循环

00:28:06.500 --> 00:28:12.190
但是我读过一次国旗，但我没有

00:28:09.110 --> 00:28:14.450
再读一遍，那会发生什么

00:28:12.190 --> 00:28:17.300
即使您将标志设置为

00:28:14.450 --> 00:28:20.150
无限循环这就是这个词

00:28:17.300 --> 00:28:23.060
 volatile是很好的，这意味着不要

00:28:20.150 --> 00:28:24.290
缓存此读取，我的意思是你

00:28:23.060 --> 00:28:26.990
需要每次阅读

00:28:24.290 --> 00:28:29.680
循环不正确，但没有它

00:28:26.990 --> 00:28:32.030
你会得到一个非常快速的无限循环

00:28:29.680 --> 00:28:35.000
每秒有很多东西，但是

00:28:32.030 --> 00:28:37.340
你永远不会失去权利

00:28:35.000 --> 00:28:39.650
消除了，例如你拿这些

00:28:37.340 --> 00:28:42.560
操作并将其写入点X 3 

00:28:39.650 --> 00:28:43.820
很好，我只需要做最后一件事

00:28:42.560 --> 00:28:46.010
写我实际上不是

00:28:43.820 --> 00:28:47.300
必须全部做，因为我可能

00:28:46.010 --> 00:28:50.180
他们做得这么快，你看不到

00:28:47.300 --> 00:28:52.400
差异真的很快，你不能

00:28:50.180 --> 00:28:55.460
看到您无法主张的区别

00:28:52.400 --> 00:28:56.870
错了，因为你疯了，我可能会

00:28:55.460 --> 00:28:59.240
如此之快，你将永远不会看到

00:28:56.870 --> 00:29:02.740
这些指示，所以如果我没有其他

00:28:59.240 --> 00:29:07.610
做了他们，所以这是一个有效的优化

00:29:02.740 --> 00:29:09.860
你可以做的更大

00:29:07.610 --> 00:29:14.150
采取这种行动，说

00:29:09.860 --> 00:29:17.060
让我们做一百万写认为它抛出

00:29:14.150 --> 00:29:18.680
走出循环不只是三个

00:29:17.060 --> 00:29:20.600
我可以摆脱的操作

00:29:18.680 --> 00:29:22.580
如果下一次写我可以循环

00:29:20.600 --> 00:29:24.020
带走整个循环并进行写入

00:29:22.580 --> 00:29:27.020
在循环中，如果循环后我

00:29:24.020 --> 00:29:28.790
再次写它，我可以运行它

00:29:27.020 --> 00:29:32.180
循环真的非常快，看看我有多快

00:29:28.790 --> 00:29:36.020
零时间运行它，所以您不会观察

00:29:32.180 --> 00:29:38.270
中间值还可以

00:29:36.020 --> 00:29:40.970
好简单的事情现在让我们来看一下

00:29:38.270 --> 00:29:43.070
内联是非常强大的

00:29:40.970 --> 00:29:44.330
实际上，内联的优化是

00:29:43.070 --> 00:29:46.550
可能是最强大的东西

00:29:44.330 --> 00:29:48.650
优化器不会因为

00:29:46.550 --> 00:29:50.330
内联自身而不是去除

00:29:48.650 --> 00:29:52.010
调用它的开销

00:29:50.330 --> 00:29:53.750
因为当您使用行代码时，您会得到

00:29:52.010 --> 00:29:56.620
应用所有其他酷技术

00:29:53.750 --> 00:29:59.240
在更广泛的范围内，让我们举个例子

00:29:56.620 --> 00:30:01.970
内联的简单示例

00:29:59.240 --> 00:30:04.130
我现在将不会更改其最终方法

00:30:01.970 --> 00:30:06.020
路由返回X，我在这里打电话

00:30:04.130 --> 00:30:08.510
得到X的东西很简单

00:30:06.020 --> 00:30:12.400
编译器可以简单地说我不需要

00:30:08.510 --> 00:30:14.780
为此调用所有方法X 

00:30:12.400 --> 00:30:18.140
 X很快，我们实际上并没有

00:30:14.780 --> 00:30:20.180
跟他们打来电话，但让我们看一下

00:30:18.140 --> 00:30:22.340
这和其他东西一起玩

00:30:20.180 --> 00:30:23.990
与我以前使用的方法类似，但

00:30:22.340 --> 00:30:27.590
这次我不知道有什么价值

00:30:23.990 --> 00:30:29.420
这是一个参数，所以我无法优化

00:30:27.590 --> 00:30:31.010
此方法并丢弃其中一半或

00:30:29.420 --> 00:30:31.940
传播其中的任何东西，因为我不

00:30:31.010 --> 00:30:37.700
知道会发生什么

00:30:31.940 --> 00:30:39.860
但是如果我的话，来电者会通过5 

00:30:37.700 --> 00:30:42.650
在呼叫站点上内联该方法

00:30:39.860 --> 00:30:44.150
可以优化它，如果我不这样做

00:30:42.650 --> 00:30:47.060
内联它实际上我必须全部运行

00:30:44.150 --> 00:30:49.340
衬里的代码就是它的原因

00:30:47.060 --> 00:30:52.310
可以优化大部分

00:30:49.340 --> 00:30:54.080
调用函数中的代码，然后

00:30:52.310 --> 00:30:56.420
很深入，您会看到JIT编译器

00:30:54.080 --> 00:30:57.049
内在垂死的九个深处得到这个

00:30:56.420 --> 00:31:00.860
最多

00:30:57.049 --> 00:31:03.759
范围很广，所以有

00:31:00.860 --> 00:31:06.230
总是很简单的步骤，你知道很简单

00:31:03.759 --> 00:31:09.679
几乎所有的编译器都会做这些

00:31:06.230 --> 00:31:11.690
没什么特别的两架喷气式飞机，实际上我是

00:31:09.679 --> 00:31:13.549
这里要走一点路

00:31:11.690 --> 00:31:14.720
进入微基准测试只是毁了

00:31:13.549 --> 00:31:17.929
如果您认为自己可以衡量自己的一天

00:31:14.720 --> 00:31:19.759
这些东西很容易让我们看一些

00:31:17.929 --> 00:31:22.730
简单的循环并测量它们的速度

00:31:19.759 --> 00:31:24.559
这是一个非常简单的循环

00:31:22.730 --> 00:31:29.090
那是我的基准运行

00:31:24.559 --> 00:31:31.279
一直花费多长时间

00:31:29.090 --> 00:31:33.470
它是否增加了基本上有一个加号

00:31:31.279 --> 00:31:36.200
加上时间很对，但是很多

00:31:33.470 --> 00:31:38.869
我告诉我这样做的时间证明

00:31:36.200 --> 00:31:41.899
这段代码真的真的非常快我

00:31:38.869 --> 00:31:47.259
意思是如果我衡量这进行得有多快

00:31:41.899 --> 00:31:47.259
走得快得快

00:31:47.499 --> 00:31:54.049
好吧，当你在这里有些奇怪

00:31:50.659 --> 00:31:55.909
得到数字，我快三倍

00:31:54.049 --> 00:31:57.590
咨询数量级六个数量级

00:31:55.909 --> 00:31:59.149
比CPU的频率

00:31:57.590 --> 00:32:00.470
问题意味着它什么都不做

00:31:59.149 --> 00:32:04.609
代码，只是发现您没有

00:32:00.470 --> 00:32:09.529
需要运行它，为什么它这么快

00:32:04.609 --> 00:32:10.970
好吧，不太清楚

00:32:09.529 --> 00:32:12.769
优化发生了我们不想

00:32:10.970 --> 00:32:18.649
如果我们想计算多快发生了

00:32:12.769 --> 00:32:24.080
我们循环正确哦，所以没人用总和

00:32:18.649 --> 00:32:25.879
好吧，让我们实际修复

00:32:24.080 --> 00:32:27.409
让我们做两个尝试来解决这个问题

00:32:25.879 --> 00:32:31.070
让我们使其更加复杂

00:32:27.409 --> 00:32:32.749
循环，我将添加而不是添加一个

00:32:31.070 --> 00:32:35.600
也许那会帮助证明

00:32:32.749 --> 00:32:37.399
快速仍然是不可能的，那是

00:32:35.600 --> 00:32:41.210
因为这证明是死代码

00:32:37.399 --> 00:32:43.279
您的观点没有人使用总和，这是一个

00:32:41.210 --> 00:32:45.109
无效的净功能，它没有副作用

00:32:43.279 --> 00:32:46.389
我说过我可以立即使用的功能

00:32:45.109 --> 00:32:49.669
返回我不需要运行此循环

00:32:46.389 --> 00:32:52.190
这就是为什么它这么快所以我们该如何解决

00:32:49.669 --> 00:32:54.409
我们返回正确的总和，所以我们这样做

00:32:52.190 --> 00:32:56.509
现在我们已经很久很久了

00:32:54.409 --> 00:32:59.509
我们将返回一些传播

00:32:56.509 --> 00:33:02.059
事情，所以我们必须做正确的数学运算

00:32:59.509 --> 00:33:06.400
更好吗，它仍然

00:33:02.059 --> 00:33:08.540
太快了，为什么呢？ 

00:33:06.400 --> 00:33:10.040
事实证明编译器很聪明

00:33:08.540 --> 00:33:14.030
足以知道如果您执行该循环

00:33:10.040 --> 00:33:16.600
总和等于不等于

00:33:14.030 --> 00:33:18.730
必须运行一个循环来解决这个问题

00:33:16.600 --> 00:33:21.049
太好了

00:33:18.730 --> 00:33:23.390
让我们使其复杂化

00:33:21.049 --> 00:33:25.490
更难的是让它做一些实际的数学运算

00:33:23.390 --> 00:33:27.919
而不是只加一遍

00:33:25.490 --> 00:33:30.260
算是好吧，加我，所有这些都是

00:33:27.919 --> 00:33:32.120
更好的结果是

00:33:30.260 --> 00:33:35.660
更好，因为那时候你要

00:33:32.120 --> 00:33:37.520
在以前的JIT编译器上计时

00:33:35.660 --> 00:33:40.490
不幸的是，JIT编译器越来越

00:33:37.520 --> 00:33:43.070
更好的例如我们最新的猎鹰

00:33:40.490 --> 00:33:44.809
看那个代码，说那是

00:33:43.070 --> 00:33:46.970
算术级数我知道该怎么做

00:33:44.809 --> 00:33:48.559
数学，它算出它是计数

00:33:46.970 --> 00:33:52.309
乘以负一乘二，然后

00:33:48.559 --> 00:33:53.929
不做循环，那么你可以

00:33:52.309 --> 00:33:56.929
还说让我们变得更复杂

00:33:53.929 --> 00:33:59.390
以其他方式，你知道你走了

00:33:56.929 --> 00:34:01.610
运行这个东西，而不是我

00:33:59.390 --> 00:34:02.809
并证明您可以传播

00:34:01.610 --> 00:34:04.309
零并显示循环不

00:34:02.809 --> 00:34:06.290
发生的事情很多

00:34:04.309 --> 00:34:09.530
杀死你的循环我只是想展示

00:34:06.290 --> 00:34:11.690
你在这里，现在现在

00:34:09.530 --> 00:34:13.490
我编写的使循环发生的代码看起来

00:34:11.690 --> 00:34:15.889
这样，重要的是要指出

00:34:13.490 --> 00:34:17.810
现在是因为有人

00:34:15.889 --> 00:34:19.340
要阅读这张幻灯片进行优化

00:34:17.810 --> 00:34:20.899
假设我知道他在做什么

00:34:19.340 --> 00:34:22.429
可能只有七八种

00:34:20.899 --> 00:34:23.840
如何进行选择，我们将

00:34:22.429 --> 00:34:26.179
写一些可以弄清楚什么的东西

00:34:23.840 --> 00:34:30.379
你知道模数县和

00:34:26.179 --> 00:34:32.510
答案是正确的，所以我们可以

00:34:30.379 --> 00:34:35.419
总是让编译器破坏代码

00:34:32.510 --> 00:34:37.010
后来他们变得更聪明

00:34:35.419 --> 00:34:39.440
关于算术级数的事情

00:34:37.010 --> 00:34:41.419
没有写我们使用LVM和一些

00:34:39.440 --> 00:34:43.399
聪明的人决定优化

00:34:41.419 --> 00:34:45.590
算术级数加法为

00:34:43.399 --> 00:34:47.690
有趣，我不知道为什么

00:34:45.590 --> 00:34:51.679
意味着它唯一的用途是杀死

00:34:47.690 --> 00:34:53.000
基准是正确的，但您知道学者

00:34:51.679 --> 00:34:55.790
做很多很酷的事情

00:34:53.000 --> 00:34:57.950
正确地继承它们，所以那是我们的

00:34:55.790 --> 00:34:59.420
绕过微观基准测试以及什么

00:34:57.950 --> 00:35:01.670
是我们在外卖的麦克吗

00:34:59.420 --> 00:35:03.830
检查很难，您尝试编写代码

00:35:01.670 --> 00:35:05.270
衡量你放东西的速度

00:35:03.830 --> 00:35:08.450
围绕它的循环可能您没有在做

00:35:05.270 --> 00:35:10.070
太多的东西，你可能不会

00:35:08.450 --> 00:35:11.450
衡量自己在做什么

00:35:10.070 --> 00:35:13.580
你可能正在测量另一面

00:35:11.450 --> 00:35:16.180
效果就像进入功能

00:35:13.580 --> 00:35:18.730
一次执行

00:35:16.180 --> 00:35:20.530
技巧会随着时间而改变

00:35:18.730 --> 00:35:24.910
今天工作可能明天就不能工作

00:35:20.530 --> 00:35:27.940
向您表明这一权利，您需要

00:35:24.910 --> 00:35:30.040
基本上是健康检查和检查

00:35:27.940 --> 00:35:31.780
一切都怀疑一切

00:35:30.040 --> 00:35:34.030
不相信数字会检查

00:35:31.780 --> 00:35:35.470
如果他们说得通的话

00:35:34.030 --> 00:35:38.290
工作量是你的两倍

00:35:35.470 --> 00:35:39.790
好吧，如果我加倍计数，我

00:35:38.290 --> 00:35:42.700
同时获得相同的完美

00:35:39.790 --> 00:35:44.380
可能是错误的，如果你

00:35:42.700 --> 00:35:46.630
真的想做得好然后使用

00:35:44.380 --> 00:35:48.940
出色的工具gmh确实是

00:35:46.630 --> 00:35:52.660
做微基准测试的好工具

00:35:48.940 --> 00:35:55.480
嗯，那是你的外卖，但是

00:35:52.660 --> 00:35:59.080
即使您使用J队友，您仍然需要

00:35:55.480 --> 00:36:00.520
怀疑一切，为什么所有

00:35:59.080 --> 00:36:03.580
基准测试表明您将运行

00:36:00.520 --> 00:36:05.140
与jmh J帮不上忙

00:36:03.580 --> 00:36:07.660
有这些错误，对您没有多大帮助

00:36:05.140 --> 00:36:09.099
没有其他错误，但我的一切

00:36:07.660 --> 00:36:10.869
刚刚表明您是用J测量的

00:36:09.099 --> 00:36:13.810
图像，它只是优化程序优化的

00:36:10.869 --> 00:36:17.040
好了，让我们回到一些

00:36:13.810 --> 00:36:20.380
编译器提示我们如何按时完成

00:36:17.040 --> 00:36:24.369
我有几分钟的投机性

00:36:20.380 --> 00:36:26.020
 JIT编译器在运行时得到的东西

00:36:24.369 --> 00:36:28.480
做你做不到的事情

00:36:26.020 --> 00:36:32.410
静态地主要是你可以

00:36:28.480 --> 00:36:35.320
推测您实际上可以决定说

00:36:32.410 --> 00:36:37.000
我想相信某些事情是真的， 

00:36:35.320 --> 00:36:40.960
我会优化代码，假设它是

00:36:37.000 --> 00:36:42.339
是的，但是我不能证明它是真的

00:36:40.960 --> 00:36:45.730
不再是真的，我会抛出代码

00:36:42.339 --> 00:36:47.830
离开，但只要它是真的，我

00:36:45.730 --> 00:36:49.960
开始运行不正确的快速代码

00:36:47.830 --> 00:36:52.150
在某些情况下，但由于我

00:36:49.960 --> 00:36:53.880
检查条件，我可以运行它

00:36:52.150 --> 00:36:57.880
在静态优化中无法做到这一点

00:36:53.880 --> 00:37:00.670
让我们以简单的例子

00:36:57.880 --> 00:37:03.220
正确的道路，所以我有这个

00:37:00.670 --> 00:37:07.450
方法我获得了价值，但我没有

00:37:03.220 --> 00:37:09.430
知道价值是我能做什么

00:37:07.450 --> 00:37:10.660
关于那好，我可以对此进行剖析

00:37:09.430 --> 00:37:12.280
说你知道我一直在运行这个

00:37:10.660 --> 00:37:15.160
百万次，我从未见过

00:37:12.280 --> 00:37:16.540
值大于10我想相信

00:37:15.160 --> 00:37:19.180
永远不会大于10 

00:37:16.540 --> 00:37:21.220
让我们现在执行以下代码

00:37:19.180 --> 00:37:24.760
在以下代码中验证我的假设

00:37:21.220 --> 00:37:26.920
这种情况对，但我基本上是说

00:37:24.760 --> 00:37:28.829
它比薄更大，只是不运行

00:37:26.920 --> 00:37:32.670
这个罕见的陷阱去运行解释

00:37:28.829 --> 00:37:35.279
相反，如果不是，那么我们有一个

00:37:32.670 --> 00:37:37.170
为您优化有一个有效的

00:37:35.279 --> 00:37:38.819
问题我可以做一个如果

00:37:37.170 --> 00:37:40.289
并放入其他经过优化的代码

00:37:38.819 --> 00:37:42.209
没有办法，但是一旦你这样做

00:37:40.289 --> 00:37:44.700
组合李代码指数得到

00:37:42.209 --> 00:37:46.349
缓慢的不常见陷阱和什至不

00:37:44.700 --> 00:37:48.119
考虑代码不生成

00:37:46.349 --> 00:37:50.459
并假设它永远不会杀死它

00:37:48.119 --> 00:37:53.729
发生然后处理非常缓慢

00:37:50.459 --> 00:37:56.430
如果真的发生的话另一种酷

00:37:53.729 --> 00:37:58.440
示例是Java中的隐式恶意检查

00:37:56.430 --> 00:38:00.869
每个领域的每个领域的每一次访问

00:37:58.440 --> 00:38:03.299
数组，它需要JVM去执行

00:38:00.869 --> 00:38:05.519
当你说从出口获得那个领域

00:38:03.299 --> 00:38:07.079
实际上意味着检查foo是否不是

00:38:05.519 --> 00:38:08.940
 null，如果不为null，请执行

00:38:07.079 --> 00:38:11.459
在每个地方都这样做

00:38:08.940 --> 00:38:14.400
如果实际上每次

00:38:11.459 --> 00:38:15.749
会很慢，所以JVM想

00:38:14.400 --> 00:38:19.140
相信你不会给

00:38:15.749 --> 00:38:21.450
跟随一次，相信无法证明

00:38:19.140 --> 00:38:23.660
有时候你给我们钉子，但是

00:38:21.450 --> 00:38:27.420
它是不是生成了代码，如果

00:38:23.660 --> 00:38:30.479
现在不会发生什么了

00:38:27.420 --> 00:38:32.849
可以给我们一个空，我们要

00:38:30.479 --> 00:38:34.949
很好地解决JVM崩溃问题

00:38:32.849 --> 00:38:36.509
拦截这个丑陋的说，它在哪里做

00:38:34.949 --> 00:38:38.369
发生在我应该有的地方

00:38:36.509 --> 00:38:41.519
有一个，如果有，让我们喜欢

00:38:38.369 --> 00:38:43.410
你是否有一个很棒的作品

00:38:41.519 --> 00:38:45.959
它确实非常强大

00:38:43.410 --> 00:38:47.819
优化，但当您拥有全部

00:38:45.959 --> 00:38:50.190
大概十万次

00:38:47.819 --> 00:38:51.719
如果这样做的话，比这样做要慢

00:38:50.190 --> 00:38:52.739
进入该代码并看到很多次

00:38:51.719 --> 00:38:53.789
那一个扔一个

00:38:52.739 --> 00:38:55.739
空指针异常

00:38:53.789 --> 00:38:57.180
您基本上将代码更改回

00:38:55.739 --> 00:38:59.249
通过旧代码将其丢弃

00:38:57.180 --> 00:39:02.670
这是镜面反射的一个例子

00:38:59.249 --> 00:39:05.249
自适应优化类奥术

00:39:02.670 --> 00:39:10.039
分析是非常强大的优化

00:39:05.249 --> 00:39:13.440
它基本上采用这种方法

00:39:10.039 --> 00:39:15.809
现在在世界上我可以看到课程

00:39:13.440 --> 00:39:18.150
有这种关系我无法证明

00:39:15.809 --> 00:39:20.069
将来会如此，但除非

00:39:18.150 --> 00:39:23.279
我可以优化某些变化

00:39:20.069 --> 00:39:25.079
这是一个具体的例子

00:39:23.279 --> 00:39:27.539
记得我给你看过衬里

00:39:25.079 --> 00:39:29.459
最后的方法很丑陋

00:39:27.539 --> 00:39:30.900
完善方法以使它们走

00:39:29.459 --> 00:39:33.420
速度很快，您不必那样做

00:39:30.900 --> 00:39:36.119
这是相同的方法，没有最终决定

00:39:33.420 --> 00:39:38.369
这是动物，这就是你如何得到

00:39:36.119 --> 00:39:40.229
来自动物的颜色有狗

00:39:38.369 --> 00:39:41.280
和猫和鸟，但它们都没有

00:39:40.229 --> 00:39:44.580
覆盖了这个烂摊子

00:39:41.280 --> 00:39:46.320
在目前的宇宙中，如果我有

00:39:44.580 --> 00:39:47.850
那个打电话的人，我可以证明

00:39:46.320 --> 00:39:51.030
只有一个实施者

00:39:47.850 --> 00:39:53.310
动物变色我可以内联它不

00:39:51.030 --> 00:39:56.190
条件不检查什么都没有

00:39:53.310 --> 00:39:58.380
加载时，这是否停止为真？ 

00:39:56.190 --> 00:39:59.790
一门课打破了我的假设

00:39:58.380 --> 00:40:01.470
每次上课时我们都会检查

00:39:59.790 --> 00:40:04.860
假设是否仍然正确

00:40:01.470 --> 00:40:07.950
如果我不需要放慢代码

00:40:04.860 --> 00:40:09.630
加载变色龙和变色龙

00:40:07.950 --> 00:40:12.150
根据分支计算颜色

00:40:09.630 --> 00:40:14.370
现在我必须坐在

00:40:12.150 --> 00:40:17.160
实施者，我必须扔掉

00:40:14.370 --> 00:40:21.390
此优化并使用

00:40:17.160 --> 00:40:23.280
实际的虚拟可能因此

00:40:21.390 --> 00:40:25.170
这就是为什么吸气剂和二传手是

00:40:23.280 --> 00:40:27.240
 Java速度很快，这就是为什么您可以编写

00:40:25.170 --> 00:40:30.120
没有这个的干净的面向对象的代码

00:40:27.240 --> 00:40:32.130
优化你会有丑陋的代码或

00:40:30.120 --> 00:40:34.020
你会暴露你的领域或你的工作

00:40:32.130 --> 00:40:35.760
最终的吸气剂没有替代，他

00:40:34.020 --> 00:40:37.710
不能写变色龙，这让你

00:40:35.760 --> 00:40:42.390
编写干净的面向对象的代码

00:40:37.710 --> 00:40:44.940
真的很快非常强大现在如果我

00:40:42.390 --> 00:40:47.580
有一个变色龙所以我得到了这个变色龙

00:40:44.940 --> 00:40:49.710
现在我有了一个虚拟方法

00:40:47.580 --> 00:40:51.420
不能做那件事，但你知道

00:40:49.710 --> 00:40:53.670
是的，那里有一只变色龙

00:40:51.420 --> 00:40:55.470
和猫，但是我正在运行的代码是

00:40:53.670 --> 00:40:56.940
狗窝，由于某种原因人们

00:40:55.470 --> 00:40:59.790
从来没有在狗身上放过变色龙

00:40:56.940 --> 00:41:02.610
狗窝，所以我正在运行的循环

00:40:59.790 --> 00:41:04.380
除了狗我们再也没有见过

00:41:02.610 --> 00:41:07.980
剖析了我们找出答案，然后

00:41:04.380 --> 00:41:09.450
如果不是狗，则生成此代码

00:41:07.980 --> 00:41:10.950
不知道在这里做什么

00:41:09.450 --> 00:41:14.000
周围的口译员，但如果是狗

00:41:10.950 --> 00:41:16.740
繁荣优化了它的心脏

00:41:14.000 --> 00:41:18.660
它没有我什至没有那么快

00:41:16.740 --> 00:41:21.540
检查，但是真的非常快

00:41:18.660 --> 00:41:23.730
与虚拟通话相比，我可以

00:41:21.540 --> 00:41:25.410
并优化一切

00:41:23.730 --> 00:41:29.670
如果它是我不能做的方法

00:41:25.410 --> 00:41:33.200
虚拟通话好，这些都很酷

00:41:29.670 --> 00:41:35.310
那里有很棒的东西

00:41:33.200 --> 00:41:37.500
投机的东西有一个完整的列表

00:41:35.310 --> 00:41:39.690
其他猜测，但

00:41:37.500 --> 00:41:41.520
投机取决于非常

00:41:39.690 --> 00:41:45.120
重要的是，JVM必须能够

00:41:41.520 --> 00:41:47.460
这是我们的优化

00:41:45.120 --> 00:41:50.160
根据以下假设进行优化

00:41:47.460 --> 00:41:52.030
无法证明他们被观察到

00:41:50.160 --> 00:41:55.119
希望他们是真的

00:41:52.030 --> 00:41:57.700
我们真的希望他们是真实的，但经常

00:41:55.119 --> 00:41:59.320
他们不会，所以我们必须能够

00:41:57.700 --> 00:42:02.140
把我们生成的代码丢掉

00:41:59.320 --> 00:42:04.900
回到其他代码慢代码，然后

00:42:02.140 --> 00:42:07.119
再来一次，这就是优化

00:42:04.900 --> 00:42:09.910
没有优化，您将无法获得

00:42:07.119 --> 00:42:11.290
要做这样的推测

00:42:09.910 --> 00:42:14.680
您需要能够进行优化， 

00:42:11.290 --> 00:42:16.840
记住这张照片的原因是

00:42:14.680 --> 00:42:19.270
黄色到绿色到蓝色都不平滑

00:42:16.840 --> 00:42:21.730
东西，我们那里有尖峰

00:42:19.270 --> 00:42:23.220
是因为有时我们的优化

00:42:21.730 --> 00:42:25.750
错了

00:42:23.220 --> 00:42:27.310
有时我们推测我们发现自己

00:42:25.750 --> 00:42:29.560
错误的，我们必须扔掉代码去

00:42:27.310 --> 00:42:32.200
回到黄色或绿色，然后再走一次

00:42:29.560 --> 00:42:34.030
那就是这些尖峰的地方

00:42:32.200 --> 00:42:35.770
它是蓝色的，但是又变回绿色

00:42:34.030 --> 00:42:37.780
或黄色，并最终再次返回

00:42:35.770 --> 00:42:40.330
它会稳定它会学习它

00:42:37.780 --> 00:42:42.160
推测是错误的它将稳定

00:42:40.330 --> 00:42:45.130
并且只有能够幸存的代码

00:42:42.160 --> 00:42:47.590
长期以来的猜测

00:42:45.130 --> 00:42:50.520
优化是另一回事

00:42:47.590 --> 00:42:52.480
你认为迈克尔替补排名很难

00:42:50.520 --> 00:42:54.130
处理热身和

00:42:52.480 --> 00:42:56.349
优化要困难得多

00:42:54.130 --> 00:42:58.839
弄清楚，特别是如果你真的跑步

00:42:56.349 --> 00:43:02.109
基准很短或很小

00:42:58.839 --> 00:43:03.790
数据集，所以这个想法是，你知道

00:43:02.109 --> 00:43:05.440
人们常常看着这个说好

00:43:03.790 --> 00:43:07.930
优化使我真正走了

00:43:05.440 --> 00:43:10.410
慢一点，我怎么热身，所以我不会

00:43:07.930 --> 00:43:13.030
有慢代码让我们练习一下

00:43:10.410 --> 00:43:16.270
给它一些真实的东西，然后运行

00:43:13.030 --> 00:43:18.520
真实代码我想要的真实音符以及

00:43:16.270 --> 00:43:19.560
问题是你经常想

00:43:18.520 --> 00:43:22.300
你很温暖

00:43:19.560 --> 00:43:24.760
但是世界的行为

00:43:22.300 --> 00:43:26.410
只是改变数字，如果

00:43:24.760 --> 00:43:29.589
小包中某处发生了什么

00:43:26.410 --> 00:43:30.700
我们的信息突然间事情变得不顺利

00:43:29.589 --> 00:43:31.930
你认为正确的他们不

00:43:30.700 --> 00:43:35.440
必须在前几分钟内发生

00:43:31.930 --> 00:43:36.700
他们可能在下午3:00发生

00:43:35.440 --> 00:43:39.760
许多潜在的原因

00:43:36.700 --> 00:43:42.550
优化和预热的原因

00:43:39.760 --> 00:43:44.619
不削减，很容易证明

00:43:42.550 --> 00:43:46.960
具有具体的现实世界动机

00:43:44.619 --> 00:43:50.410
想象您正在编写交易系统

00:43:46.960 --> 00:43:53.410
它在Java中，因为您可以编写

00:43:50.410 --> 00:43:55.450
快速并快速进入市场，但是当您

00:43:53.410 --> 00:43:59.410
交易市场开放，每个人

00:43:55.450 --> 00:44:01.089
急于波动， 

00:43:59.410 --> 00:44:03.339
那是最酷的东西所在的地方

00:44:01.089 --> 00:44:04.020
发生了，您刚刚启动了JVM 

00:44:03.339 --> 00:44:07.380
而你遇到

00:44:04.020 --> 00:44:09.120
信用代码，它仍然在分析

00:44:07.380 --> 00:44:10.860
你想热身，你想

00:44:09.120 --> 00:44:12.840
在开始这个之前，你要

00:44:10.860 --> 00:44:14.520
你会跑东西，我们会说好的

00:44:12.840 --> 00:44:16.350
你知道我不想等什么

00:44:14.520 --> 00:44:18.750
在我得到10,000次操作之前

00:44:16.350 --> 00:44:21.840
鼠标代码，让我们运行它

00:44:18.750 --> 00:44:24.680
你知道20,000件假货

00:44:21.840 --> 00:44:26.790
我昨天记录的流量

00:44:24.680 --> 00:44:28.500
练习代码，这样很好

00:44:26.790 --> 00:44:30.270
准备在进行第一笔交易

00:44:28.500 --> 00:44:32.850
市场开放，已经很热

00:44:30.270 --> 00:44:34.800
教它，它做对了，所以

00:44:32.850 --> 00:44:36.630
你热身只是去他们一会儿

00:44:34.800 --> 00:44:39.720
推测他们弄错了

00:44:36.630 --> 00:44:43.470
不管他们解决了什么，做什么

00:44:39.720 --> 00:44:45.210
实际上发生在这里你在做什么

00:44:43.470 --> 00:44:47.040
正在通过您进行虚假流量

00:44:45.210 --> 00:44:50.310
其实并不意味着要进行20,000笔交易

00:44:47.040 --> 00:44:52.500
用别人的钱吧

00:44:50.310 --> 00:44:54.060
通常，假逻辑中包含某些内容

00:44:52.500 --> 00:44:57.720
它说去另一个但

00:44:54.060 --> 00:44:59.900
这是假的，所以不要真正发送它

00:44:57.720 --> 00:45:04.280
 JIT编译器将针对以下内容进行优化

00:44:59.900 --> 00:45:06.600
它会针对不交易进行优化

00:45:04.280 --> 00:45:08.310
因为运行了两万件事

00:45:06.600 --> 00:45:11.430
从来没有交易过，也许从来没有

00:45:08.310 --> 00:45:14.400
发生和第一次发生的事情

00:45:11.430 --> 00:45:16.290
直，我们做优化回到

00:45:14.400 --> 00:45:18.900
开始并开始收集东西

00:45:16.290 --> 00:45:21.060
从头开始，它看起来像这样

00:45:18.900 --> 00:45:23.130
你加热了它，你真的知道

00:45:21.060 --> 00:45:28.470
快速的繁荣市场打开你走慢

00:45:23.130 --> 00:45:30.600
再次如此，实际上在这种热身

00:45:28.470 --> 00:45:33.090
学习积极的优化

00:45:30.600 --> 00:45:34.860
优化发生在这里

00:45:33.090 --> 00:45:36.000
在这里，您可以使用真实的

00:45:34.860 --> 00:45:39.030
进化的知识

00:45:36.000 --> 00:45:42.570
好的事情就是热身

00:45:39.030 --> 00:45:46.050
优化我们可以对此做些什么

00:45:42.570 --> 00:45:48.000
我们实际建立的一项功能

00:45:46.050 --> 00:45:51.840
进入JVM是否有构建？您是否登录

00:45:48.000 --> 00:45:53.760
在运行记录中重播优化

00:45:51.840 --> 00:45:55.560
来自优化的输入

00:45:53.760 --> 00:45:57.720
昨天从今天开始

00:45:55.560 --> 00:46:02.010
昨天学到的东西包括

00:45:57.720 --> 00:46:05.460
因此，只要您告诉一个

00:46:02.010 --> 00:46:07.530
 JVM记录为什么以及如何编译

00:46:05.460 --> 00:46:09.870
事情，明天你告诉体育馆

00:46:07.530 --> 00:46:12.060
首先从录音开始

00:46:09.870 --> 00:46:13.380
它会启动所有的JIT编译器

00:46:12.060 --> 00:46:15.360
一切准备就绪

00:46:13.380 --> 00:46:19.350
交易要快而不是10 

00:46:15.360 --> 00:46:22.350
千人或购买或交易

00:46:19.350 --> 00:46:23.820
变慢，然后再变快，然后你

00:46:22.350 --> 00:46:25.860
实际上可以建立一个工作流程

00:46:23.820 --> 00:46:27.450
向你证明你没有任何东西

00:46:25.860 --> 00:46:30.570
昨天申请还没有

00:46:27.450 --> 00:46:33.030
应用的影响是

00:46:30.570 --> 00:46:35.790
优化并将其展平

00:46:33.030 --> 00:46:38.250
你知道让它快乐但也要

00:46:35.790 --> 00:46:40.320
实际需要的预热时间

00:46:38.250 --> 00:46:42.660
您训练事物并将其降低

00:46:40.320 --> 00:46:44.040
几乎什么都没有，因为你没有

00:46:42.660 --> 00:46:46.140
必须通过它运行流量

00:46:44.040 --> 00:46:49.080
需要初始化东西，所以你得到

00:46:46.140 --> 00:46:52.260
这个好的平面操作这是什么

00:46:49.080 --> 00:46:55.220
意思是这张照片，所以我已经展示了

00:46:52.260 --> 00:46:58.850
你说更好的轧花提高了标准

00:46:55.220 --> 00:47:01.470
这将其移到左侧， 

00:46:58.850 --> 00:47:04.380
把它弄平就可以了

00:47:01.470 --> 00:47:06.750
预热曲线，这样更好

00:47:04.380 --> 00:47:10.560
现在剩下的还有什么

00:47:06.750 --> 00:47:12.720
留着做这件事缺少的事情

00:47:10.560 --> 00:47:16.250
仍然每次下降到零速度

00:47:12.720 --> 00:47:18.570
一会儿，那是最后一个组成部分

00:47:16.250 --> 00:47:20.520
如果我们不能让它下降到

00:47:18.570 --> 00:47:22.350
零速不时

00:47:20.520 --> 00:47:24.420
然后我们得到这个不错的平速关闭

00:47:22.350 --> 00:47:26.760
到我们真正想要看到的是

00:47:24.420 --> 00:47:28.950
 C4垃圾收集器到那里， 

00:47:26.760 --> 00:47:33.720
这是你真正骄傲的眉头

00:47:28.950 --> 00:47:36.300
只是打我要说的东西c4 

00:47:33.720 --> 00:47:38.370
在zing JVM中，您可以运行任何一个

00:47:36.300 --> 00:47:40.590
应用程序基本上消除了GC 

00:47:38.370 --> 00:47:41.970
作为一个问题，它需要看起来像东西

00:47:40.590 --> 00:47:43.680
就像左边那个小故障

00:47:41.970 --> 00:47:45.300
一直以来，它们看起来像

00:47:43.680 --> 00:47:47.850
在右边的东西，他们只是小故障

00:47:45.300 --> 00:47:49.380
这些时间的故障不是

00:47:47.850 --> 00:47:51.420
由于JVM，还有许多其他

00:47:49.380 --> 00:47:53.850
您紧紧抓住我们的理由

00:47:51.420 --> 00:47:55.980
故障的原因，我们也带走了所有

00:47:53.850 --> 00:47:57.990
调整GC的原因，因此您可能有

00:47:55.980 --> 00:48:00.030
公认，其中一些标志

00:47:57.990 --> 00:48:02.370
有时您可能想要做这些

00:48:00.030 --> 00:48:04.440
想要快速运行而没有

00:48:02.370 --> 00:48:06.870
您想延迟一下暂停，这样

00:48:04.440 --> 00:48:08.760
你调整东西，你需要调整

00:48:06.870 --> 00:48:10.320
对这个应用程序的正确处理

00:48:08.760 --> 00:48:13.230
该应用程序截然相反

00:48:10.320 --> 00:48:14.880
标志X的值，表示您已经

00:48:13.230 --> 00:48:16.320
尝试了很多事情，你想通了

00:48:14.880 --> 00:48:18.990
了解如何针对当前情况进行调整

00:48:16.320 --> 00:48:21.390
如果您认为这些工作量很大

00:48:18.990 --> 00:48:23.400
标志这里还有一些其他标志

00:48:21.390 --> 00:48:25.290
选择如何调整任何身份

00:48:23.400 --> 00:48:26.220
与我们调和的现代方式是

00:48:25.290 --> 00:48:29.910
这个

00:48:26.220 --> 00:48:30.900
你给它很大的热量，它现在可以工作

00:48:29.910 --> 00:48:32.490
那是浪费

00:48:30.900 --> 00:48:33.810
所以你缩小堆并缩小

00:48:32.490 --> 00:48:36.359
他一直保持体形，你想通

00:48:33.810 --> 00:48:38.280
你能走多小

00:48:36.359 --> 00:48:40.349
打破你的三倍堆，你去

00:48:38.280 --> 00:48:45.630
 GC优化的家

00:48:40.349 --> 00:48:48.960
今天在实践中，我在想

00:48:45.630 --> 00:48:51.480
不像卡桑德拉那样交易

00:48:48.960 --> 00:48:53.760
在普通的Broadwell机器上，那是

00:48:51.480 --> 00:48:56.760
一毫秒通过级别

00:48:53.760 --> 00:48:59.580
在基准的全部压力下，如果

00:48:56.760 --> 00:49:02.430
你在乎400微秒的毛刺

00:48:59.580 --> 00:49:03.630
是的，我们确实有故障，但是Linux Fletch是

00:49:02.430 --> 00:49:05.250
比Cassandra好吃

00:49:03.630 --> 00:49:06.780
您的I / O故障大于

00:49:05.250 --> 00:49:10.800
这是其余的噪音

00:49:06.780 --> 00:49:13.290
信号，所以您实际上知道我们可以

00:49:10.800 --> 00:49:17.820
做这样的事情Cassandra EWS 

00:49:13.290 --> 00:49:19.530
在SLA下，我需要一个简单的问题

00:49:17.820 --> 00:49:21.240
用那么多节点满足该SLA 

00:49:19.530 --> 00:49:24.000
他们可以通过多少流量

00:49:21.240 --> 00:49:26.130
你用G一的热点来运行它

00:49:24.000 --> 00:49:28.619
两个月的调音和咨询

00:49:26.130 --> 00:49:31.260
你得到的速度，这是一个实际的真实

00:49:28.619 --> 00:49:33.990
来自实际客户的案例，您可以运行它

00:49:31.260 --> 00:49:36.930
没有调整就可以得到

00:49:33.990 --> 00:49:38.849
这些是实数

00:49:36.930 --> 00:49:40.740
今天在AWS上的Cassandra最新

00:49:38.849 --> 00:49:42.180
现在最大的例子不是

00:49:40.740 --> 00:49:45.900
因为我们运行了五次代码

00:49:42.180 --> 00:49:49.050
更快地运行代码约11％ 

00:49:45.900 --> 00:49:51.869
更快，我们启动更快，但是

00:49:49.050 --> 00:49:53.730
不会影响这是因为你

00:49:51.869 --> 00:49:56.609
可以更努力地压这东西

00:49:53.730 --> 00:50:00.810
小故障打破了这种东西

00:49:56.609 --> 00:50:03.180
关于消除毛刺以及什么

00:50:00.810 --> 00:50:05.280
转化为现实就是事物

00:50:03.180 --> 00:50:08.250
如果您实际上监视负载，则这样

00:50:05.280 --> 00:50:10.230
超时，错误或现场成功

00:50:08.250 --> 00:50:12.450
利率，这就是这个橙色

00:50:10.230 --> 00:50:15.869
线是每次浸入

00:50:12.450 --> 00:50:17.580
失败100％是重击98％ 

00:50:15.869 --> 00:50:20.339
在此情况下，您最多会失败2％ 

00:50:17.580 --> 00:50:22.650
如果您将其打开并运行

00:50:20.339 --> 00:50:26.070
顺畅地获得所需的速度

00:50:22.650 --> 00:50:27.660
得到这样的速度，以便成为我

00:50:26.070 --> 00:50:29.430
最后吹牛我为此表示歉意

00:50:27.660 --> 00:50:31.200
希望它的开始更多

00:50:29.430 --> 00:50:32.849
具有教育意义，如果您真的想知道

00:50:31.200 --> 00:50:35.460
有关它的更多信息，您可以到我们的展位

00:50:32.849 --> 00:50:37.869
来跟我说话，但在这一点上我

00:50:35.460 --> 00:50:41.109
认为我们按时完成了

00:50:37.869 --> 00:50:43.469
我很高兴在包装时接受一些问答

00:50:41.109 --> 00:50:45.460
并清理下一个房间

00:50:43.469 --> 00:50:48.910
演讲者，我会在这里闲逛

00:50:45.460 --> 00:50:51.400
只要你们想要，随时

00:50:48.910 --> 00:50:53.290
当我开始总结时问一些问题

00:50:51.400 --> 00:50:58.530
这东西谢谢

00:50:53.290 --> 00:50:58.530
 [掌声] 

