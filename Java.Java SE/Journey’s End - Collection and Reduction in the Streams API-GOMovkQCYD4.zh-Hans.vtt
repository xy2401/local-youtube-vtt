WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.149 --> 00:00:07.979
早上好，谢谢您的耐心配合

00:00:05.870 --> 00:00:09.950
感谢您今天参加本次演讲

00:00:07.979 --> 00:00:12.719
好，所以我今天要谈

00:00:09.950 --> 00:00:14.820
流中的收集和减少

00:00:12.719 --> 00:00:18.000
在流API中，这是关于

00:00:14.820 --> 00:00:19.619
基本上是关于Java 8的

00:00:18.000 --> 00:00:21.689
如果您一直在使用流API 

00:00:19.619 --> 00:00:23.160
或者如果您尚未使用流

00:00:21.689 --> 00:00:24.840
 API，但您不是

00:00:23.160 --> 00:00:29.910
但是无论哪种方式你都不是很

00:00:24.840 --> 00:00:31.649
对相当大的子集充满信心

00:00:29.910 --> 00:00:33.930
与该API有关的

00:00:31.649 --> 00:00:35.789
收藏家，那么这个谈话本来是

00:00:33.930 --> 00:00:38.100
给你，所以我不会花很多钱

00:00:35.789 --> 00:00:40.710
从整体上看，我不是

00:00:38.100 --> 00:00:42.449
我将主要假设

00:00:40.710 --> 00:00:43.559
我们知道我们大致了解发生了什么

00:00:42.449 --> 00:00:45.239
在那里，我们将集中精力

00:00:43.559 --> 00:00:47.789
特别是在这一点上

00:00:45.239 --> 00:00:49.170
操作证明，这是一个相当

00:00:47.789 --> 00:00:50.550
大型API，它实际上值得

00:00:49.170 --> 00:00:52.289
钻研，因为你可以做很多事情

00:00:50.550 --> 00:00:55.769
用它，我希望表明

00:00:52.289 --> 00:00:58.170
在这次谈话中，所以只是

00:00:55.769 --> 00:01:00.569
如果你听说过我，那我就是谁

00:00:58.170 --> 00:01:02.969
因为我已经将这些书写在

00:01:00.569 --> 00:01:04.260
几本关于Java的书，如果您

00:01:02.969 --> 00:01:06.180
还没有，那还不完全是

00:01:04.260 --> 00:01:09.150
令人惊讶的是我喜欢说Java 5书

00:01:06.180 --> 00:01:12.480
是印刷中最好的书

00:01:09.150 --> 00:01:14.310
完全致力于我的仿制药

00:01:12.480 --> 00:01:16.320
担心而不必担心

00:01:14.310 --> 00:01:18.180
笑话持续了10年的矛盾

00:01:16.320 --> 00:01:19.410
年显然是我唯一的

00:01:18.180 --> 00:01:21.000
不能说不能那么确定

00:01:19.410 --> 00:01:23.070
否则我就写了一本书

00:01:21.000 --> 00:01:24.630
 Java和本书中的

00:01:23.070 --> 00:01:26.010
真的关于流，尽管它有

00:01:24.630 --> 00:01:27.540
标题中的lambdas确实很多

00:01:26.010 --> 00:01:33.630
关于lambdas中的流的更多信息是

00:01:27.540 --> 00:01:36.780
这次谈话的依据是

00:01:33.630 --> 00:01:40.590
那我是冠军，我是Java 

00:01:36.780 --> 00:01:42.720
摇滚明星和诸如此类的东西，所以

00:01:40.590 --> 00:01:44.160
今天的议程是我要谈的

00:01:42.720 --> 00:01:45.330
关于我们为什么要收藏家以及什么

00:01:44.160 --> 00:01:46.710
那就是实际上占用了

00:01:45.330 --> 00:01:48.120
相当多的顶部，因为我认为

00:01:46.710 --> 00:01:50.400
因为我认为有一些背景

00:01:48.120 --> 00:01:52.320
在发生的事情上很有用

00:01:50.400 --> 00:01:55.170
我将谈论预定义的

00:01:52.320 --> 00:01:58.350
由...提供的收集器

00:01:55.170 --> 00:02:00.360
框架，然后我们将

00:01:58.350 --> 00:02:01.830
如果我不习惯的话，可能会休息一下

00:02:00.360 --> 00:02:04.470
摆弄我所有的时间

00:02:01.830 --> 00:02:05.790
用电缆，我们需要五分钟

00:02:04.470 --> 00:02:08.399
休息，然后我们将做一些工作

00:02:05.790 --> 00:02:10.319
例子和想法，这是

00:02:08.399 --> 00:02:12.269
你将要去

00:02:10.319 --> 00:02:15.090
如果可以的话，请为我编写代码

00:02:12.269 --> 00:02:16.360
不用触摸即可启动IntelliJ 

00:02:15.090 --> 00:02:18.340
电缆那么好

00:02:16.360 --> 00:02:19.990
下半年进行一些现场编码

00:02:18.340 --> 00:02:22.450
并实际看到这些的一些用途

00:02:19.990 --> 00:02:24.430
收藏家，然后终于有一个

00:02:22.450 --> 00:02:26.470
有一个很短的部分，也许10或

00:02:24.430 --> 00:02:29.170
 15分钟只是为了结束谈话

00:02:26.470 --> 00:02:32.410
关于你如何以及为什么会

00:02:29.170 --> 00:02:35.530
写你自己的收藏家，所以这个例子

00:02:32.410 --> 00:02:38.710
讨论的领域变得如此简单

00:02:35.530 --> 00:02:42.250
可能我们只有一个价值对象

00:02:38.710 --> 00:02:44.080
我的三个城市的人

00:02:42.250 --> 00:02:45.550
假定是一个枚举，但我们从未

00:02:44.080 --> 00:02:49.360
实际上从来没有真正看到它的定义

00:02:45.550 --> 00:02:51.520
和一个字符串字段和一个int 

00:02:49.360 --> 00:02:54.310
领域，所以有一个想法

00:02:51.520 --> 00:02:55.660
几个参考字段和

00:02:54.310 --> 00:02:57.250
原始字段是因为

00:02:55.660 --> 00:02:59.500
工作方式不同，这给了我们一些

00:02:57.250 --> 00:03:01.000
不同的问题和代码种类

00:02:59.500 --> 00:03:02.770
我们将看到的真的很简单

00:03:01.000 --> 00:03:04.480
因为这可能是合理的，我们要

00:03:02.770 --> 00:03:07.560
建立一个新的人，我们要

00:03:04.480 --> 00:03:09.610
我们将要列出

00:03:07.560 --> 00:03:10.959
人对象，然后我们将

00:03:09.610 --> 00:03:13.660
看到可以

00:03:10.959 --> 00:03:15.340
如果您将其用作来源

00:03:13.660 --> 00:03:17.530
流，本质上是我们要去的

00:03:15.340 --> 00:03:19.330
要做的就是在那上面进行操作

00:03:17.530 --> 00:03:21.190
以这种方式产生的溪流

00:03:19.330 --> 00:03:22.330
然后我们将要

00:03:21.190 --> 00:03:24.760
收集它们，我们将看到

00:03:22.330 --> 00:03:26.380
集体就是要接受它

00:03:24.760 --> 00:03:28.420
一会儿只是为了一种

00:03:26.380 --> 00:03:29.950
更高级别的视图发生了什么

00:03:28.420 --> 00:03:34.330
流中发生了什么

00:03:29.950 --> 00:03:37.959
流元素的生命是开始吗

00:03:34.330 --> 00:03:39.670
以这样的速度分配

00:03:37.959 --> 00:03:41.890
出生，所以分离器的想法是

00:03:39.670 --> 00:03:43.330
这是一个可爱的名字

00:03:41.890 --> 00:03:45.190
既可以迭代又可以

00:03:43.330 --> 00:03:46.600
分裂，因此，如果它是迭代

00:03:45.190 --> 00:03:48.280
按顺序处理流

00:03:46.600 --> 00:03:51.190
因为它养活了

00:03:48.280 --> 00:03:53.410
流中的饲料元素

00:03:51.190 --> 00:03:56.080
源流一个接一个地流

00:03:53.410 --> 00:03:58.570
这就是我们所知道的迭代，并且

00:03:56.080 --> 00:04:01.269
在某些情况下也可以

00:03:58.570 --> 00:04:05.739
在这种情况下它也会分裂

00:04:01.269 --> 00:04:08.260
它的来源想象说一个数组

00:04:05.739 --> 00:04:10.330
或射线列表，那么您可以看到

00:04:08.260 --> 00:04:12.700
你可以处理更多

00:04:10.330 --> 00:04:16.410
如果您有并行硬件，则效率很高

00:04:12.700 --> 00:04:20.940
首先将其分解为

00:04:16.410 --> 00:04:23.229
每个部分都适合

00:04:20.940 --> 00:04:25.630
直到你有尽可能多的部分

00:04:23.229 --> 00:04:27.280
基本上是因为您有执行的理由

00:04:25.630 --> 00:04:29.050
在这种情况下，我在想

00:04:27.280 --> 00:04:31.539
我们有一个

00:04:29.050 --> 00:04:33.610
 ArrayList或数组并将其拆分

00:04:31.539 --> 00:04:36.009
一分为二

00:04:33.610 --> 00:04:37.660
 4件，因为它在4件上执行

00:04:36.009 --> 00:04:39.820
核心硬件这一切都完成了

00:04:37.660 --> 00:04:41.860
由by自动为您

00:04:39.820 --> 00:04:44.050
如果您希望流API发生

00:04:41.860 --> 00:04:45.190
如果需要，您需要做的所有事情

00:04:44.050 --> 00:04:47.680
想要得到一个之间的区别

00:04:45.190 --> 00:04:49.750
顺序流，在这种情况下

00:04:47.680 --> 00:04:51.970
分离器ATAR只是在迭代您而已

00:04:49.750 --> 00:04:54.009
说我想直播，如果你想

00:04:51.970 --> 00:04:55.690
如果你想并行流作为

00:04:54.009 --> 00:04:58.240
我们将在这里看到，因为每个

00:04:55.690 --> 00:05:00.580
这些黄色的东西是一条管道， 

00:04:58.240 --> 00:05:02.139
在本质上是不同的线程

00:05:00.580 --> 00:05:05.020
依附于每个不同的原因

00:05:02.139 --> 00:05:07.300
它正在执行for的代码

00:05:05.020 --> 00:05:09.990
每个流媒体流上的流水线

00:05:07.300 --> 00:05:13.090
数据集每个子集和

00:05:09.990 --> 00:05:14.710
如果你想做到这一点，你会说

00:05:13.090 --> 00:05:16.060
我想要并行流而不是

00:05:14.710 --> 00:05:18.250
说我想直播，这真的

00:05:16.060 --> 00:05:20.590
就这么简单，无论您是否真的

00:05:18.250 --> 00:05:21.370
通过这样做可以真正获得收益

00:05:20.590 --> 00:05:24.729
另一件事

00:05:21.370 --> 00:05:26.979
因为为了获得重大

00:05:24.729 --> 00:05:29.349
通过不断改进性能

00:05:26.979 --> 00:05:31.479
正如我们所说，并行要求

00:05:29.349 --> 00:05:34.139
需要一些条件，可能

00:05:31.479 --> 00:05:39.070
并非在许多常见情况下都无法满足

00:05:34.139 --> 00:05:41.320
但这就是建筑的想法

00:05:39.070 --> 00:05:43.300
并行性是应该

00:05:41.320 --> 00:05:45.400
明确但不引人注目的是

00:05:43.300 --> 00:05:47.590
流的口号

00:05:45.400 --> 00:05:49.780
设计师以及他们与他们

00:05:47.590 --> 00:05:52.360
成功的是它是并行的

00:05:49.780 --> 00:05:54.310
明确的是，它并不引人注目

00:05:52.360 --> 00:05:55.449
易于使用，可能太容易使用了

00:05:54.310 --> 00:05:59.039
因为很多人

00:05:55.449 --> 00:06:01.960
感到失望的是没有充分

00:05:59.039 --> 00:06:04.509
了解您会遇到的情况

00:06:01.960 --> 00:06:06.880
获得他们有时曾经获得的利益

00:06:04.509 --> 00:06:09.009
失望，那么接下来会发生什么

00:06:06.880 --> 00:06:11.199
元素归结为这些元素

00:06:09.009 --> 00:06:12.940
通过这些不同的渠道

00:06:11.199 --> 00:06:15.460
然后他们被一个

00:06:12.940 --> 00:06:18.759
终端操作，所以这三个

00:06:15.460 --> 00:06:20.440
所以生命的三个阶段

00:06:18.759 --> 00:06:22.599
流元素的样式生存期是

00:06:20.440 --> 00:06:24.220
分离器ATAR在哪里

00:06:22.599 --> 00:06:26.349
他们出生于中间阶段

00:06:24.220 --> 00:06:27.610
他们在哪里转变，他们在

00:06:26.349 --> 00:06:29.979
最终由码头收集

00:06:27.610 --> 00:06:31.270
操作，我们要去，我们要

00:06:29.979 --> 00:06:33.460
将专注于

00:06:31.270 --> 00:06:35.169
收藏家我应该说

00:06:33.460 --> 00:06:36.849
虽然我有点

00:06:35.169 --> 00:06:40.150
一点介绍，我不是很

00:06:36.849 --> 00:06:42.099
对并行执行持肯定态度

00:06:40.150 --> 00:06:42.700
并行执行的想法仍然存在

00:06:42.099 --> 00:06:45.280
非常

00:06:42.700 --> 00:06:46.750
给流API设计者，因为

00:06:45.280 --> 00:06:48.130
他们想要确保

00:06:46.750 --> 00:06:50.700
您编写的代码您编写的代码

00:06:48.130 --> 00:06:52.750
写流应该相等

00:06:50.700 --> 00:06:54.280
可并行执行或

00:06:52.750 --> 00:06:56.410
依次地，您可能会变得非常不同

00:06:54.280 --> 00:06:58.960
性能取决于

00:06:56.410 --> 00:07:01.540
您特定的硬件设置和其他

00:06:58.960 --> 00:07:03.130
东西，但在功能上

00:07:01.540 --> 00:07:05.170
应该以完全相同的方式工作

00:07:03.130 --> 00:07:07.090
这是非常重要的设计

00:07:05.170 --> 00:07:08.800
动力，有时你认为

00:07:07.090 --> 00:07:10.690
流API缺少什么

00:07:08.800 --> 00:07:12.160
为什么我为什么不能这样做

00:07:10.690 --> 00:07:13.960
答案是因为你不能

00:07:12.160 --> 00:07:16.420
并行执行，如果无法执行

00:07:13.960 --> 00:07:19.270
并行，那么你做不到

00:07:16.420 --> 00:07:23.110
根本无法在流API中做到这一点，因此

00:07:19.270 --> 00:07:24.910
我称这本书为

00:07:23.110 --> 00:07:26.800
我称之为并行准备代码

00:07:24.910 --> 00:07:28.240
所以即使你的代码不会

00:07:26.800 --> 00:07:29.920
可以并行执行

00:07:28.240 --> 00:07:33.010
准备并行执行

00:07:29.920 --> 00:07:36.490
他们认为这是前进的道路

00:07:33.010 --> 00:07:38.290
用Java处理集合好吗

00:07:36.490 --> 00:07:39.850
所以现在我将专注于

00:07:38.290 --> 00:07:41.140
终端操作有点三

00:07:39.850 --> 00:07:42.790
这些种类，我只会去

00:07:41.140 --> 00:07:44.470
通过他们中的两个非常简短，因为

00:07:42.790 --> 00:07:45.640
我对我真的不感兴趣

00:07:44.470 --> 00:07:49.420
对第三个非常感兴趣

00:07:45.640 --> 00:07:51.580
搜索操作就是

00:07:49.420 --> 00:07:54.220
全部匹配和任何匹配并找到任何和

00:07:51.580 --> 00:07:55.570
找到第一个C这些这些终端

00:07:54.220 --> 00:07:57.760
操作实际上是

00:07:55.570 --> 00:07:59.470
下拉数据流

00:07:57.760 --> 00:08:01.690
它中的流，因此您可以设置一个

00:07:59.470 --> 00:08:03.520
说我要我要我要

00:08:01.690 --> 00:08:05.680
一条小溪，但是直到你真正说出

00:08:03.520 --> 00:08:07.210
直到您实际提供一个终端

00:08:05.680 --> 00:08:09.730
操作开始执行

00:08:07.210 --> 00:08:12.130
没有任何动静，所以我们在说什么

00:08:09.730 --> 00:08:14.230
是我们想要我们想要回来

00:08:12.130 --> 00:08:16.720
布尔值对应于是否

00:08:14.230 --> 00:08:19.180
所有的成年人都对不起

00:08:16.720 --> 00:08:22.810
人的对象在

00:08:19.180 --> 00:08:25.510
人员列表中有年龄字段

00:08:22.810 --> 00:08:26.860
大于21，如果他们这样做

00:08:25.510 --> 00:08:29.230
那将是真的，如果不是，那将会是

00:08:26.860 --> 00:08:30.250
虚假发现任何问题，并且可以优先工作

00:08:29.230 --> 00:08:31.930
就像他们一样

00:08:30.250 --> 00:08:32.979
返回一个可选的，因为它们是

00:08:31.930 --> 00:08:35.680
寻找符合

00:08:32.979 --> 00:08:36.970
条件，它可能不存在， 

00:08:35.680 --> 00:08:38.440
可能有这些东西

00:08:36.970 --> 00:08:39.910
这些叫做短路

00:08:38.440 --> 00:08:41.890
操作，它们非常重要

00:08:39.910 --> 00:08:44.320
从加工的角度

00:08:41.890 --> 00:08:46.870
由于所有这些，无限的流

00:08:44.320 --> 00:08:48.730
搜索操作将停止

00:08:46.870 --> 00:08:52.060
当他们感到满意时

00:08:48.730 --> 00:08:53.320
例如在例子中

00:08:52.060 --> 00:08:56.050
那里的示例代码

00:08:53.320 --> 00:08:57.430
如果

00:08:56.050 --> 00:08:59.680
你能拥有一个吗

00:08:57.430 --> 00:09:01.870
真的很长的人名单

00:08:59.680 --> 00:09:03.820
对象，您可能正在处理它们

00:09:01.870 --> 00:09:06.610
按顺序，如果第一个不是

00:09:03.820 --> 00:09:09.459
第一个成年人的年龄为

00:09:06.610 --> 00:09:11.830
少于21的第二课

00:09:09.459 --> 00:09:13.810
处理将停止，因此不需要

00:09:11.830 --> 00:09:15.490
处理整个流以便

00:09:13.810 --> 00:09:16.899
为了评估病情

00:09:15.490 --> 00:09:18.160
这些短路操作非常

00:09:16.899 --> 00:09:19.600
没有他们，你实际上很有用

00:09:18.160 --> 00:09:23.410
无法做任何有用的事情

00:09:19.600 --> 00:09:25.329
无限流第二种

00:09:23.410 --> 00:09:27.100
终端操作我们这边影响

00:09:25.329 --> 00:09:29.290
每个人都喜欢这些操作，因为

00:09:27.100 --> 00:09:29.649
他们看起来像你知道你用了什么

00:09:29.290 --> 00:09:31.180
至

00:09:29.649 --> 00:09:33.430
所以如果你看到你有，但是你有

00:09:31.180 --> 00:09:35.950
每个人都有说的好

00:09:33.430 --> 00:09:37.149
好吧，我真的可以在这里做到

00:09:35.950 --> 00:09:38.860
我要提出的观点之一

00:09:37.149 --> 00:09:40.600
在这个谈话中，你真的做不到

00:09:38.860 --> 00:09:44.140
每个人看到的同盟

00:09:40.600 --> 00:09:46.829
认为我可以做到，所以对于

00:09:44.140 --> 00:09:48.459
这里到达的示例需要一个

00:09:46.829 --> 00:09:50.440
消费者就是

00:09:48.459 --> 00:09:51.579
取值，不取而代之

00:09:50.440 --> 00:09:54.160
有东西但不返回

00:09:51.579 --> 00:09:55.660
任何东西，我们来到这里，我们

00:09:54.160 --> 00:09:57.579
要打印出每个人

00:09:55.660 --> 00:09:59.440
反对每个个人对象

00:09:57.579 --> 00:10:03.130
流，所以第一个问题是

00:09:59.440 --> 00:10:05.260
我们可以使用这些吗

00:10:03.130 --> 00:10:06.209
终端操作这些方面的影响

00:10:05.260 --> 00:10:08.320
运作

00:10:06.209 --> 00:10:10.029
它们被称为侧面影响操作

00:10:08.320 --> 00:10:12.579
因为他们做了一些事情以结束

00:10:10.029 --> 00:10:15.970
流之外的价值可以

00:10:12.579 --> 00:10:18.760
我们也许可以通过计算得出

00:10:15.970 --> 00:10:23.459
该人的总年龄

00:10:18.760 --> 00:10:23.459
该列表中的对象将起作用

00:10:28.340 --> 00:10:32.330
顺序或并行工作

00:10:33.680 --> 00:10:40.590
好吧，那是那样的

00:10:38.910 --> 00:10:41.910
有趣，所以答案是连续的

00:10:40.590 --> 00:10:45.150
 II它将并行运行，不会

00:10:41.910 --> 00:10:49.620
自然工作，这有点不对劲

00:10:45.150 --> 00:10:51.570
实际上这不会编译信标

00:10:49.620 --> 00:10:53.820
因为因为有些是一些不是

00:10:51.570 --> 00:10:54.900
最后就是那种

00:10:53.820 --> 00:10:56.370
琐碎的答案，因为

00:10:54.900 --> 00:10:57.930
你会说你会交叉双臂

00:10:56.370 --> 00:11:00.000
你会说哈他们为什么把这个

00:10:57.930 --> 00:11:01.500
对某些事物的愚蠢限制

00:11:00.000 --> 00:11:04.440
最后或实际上我们现在说的

00:11:01.500 --> 00:11:05.910
有效地决赛，那为什么呢？ 

00:11:04.440 --> 00:11:08.400
他们做得很好吗

00:11:05.910 --> 00:11:09.810
他们这样做是因为我说的

00:11:08.400 --> 00:11:12.390
刚才是应该的

00:11:09.810 --> 00:11:13.650
并行正常工作，您

00:11:12.390 --> 00:11:15.000
一种权利，它不会起作用

00:11:13.650 --> 00:11:17.730
并行将无法并行工作

00:11:15.000 --> 00:11:19.830
因为不是因为我的意思是假设我们

00:11:17.730 --> 00:11:21.660
我们做了一些技巧来绕过

00:11:19.830 --> 00:11:23.790
实际上，我们可以做的最后一件事

00:11:21.660 --> 00:11:25.350
一些进入一个领域，或者我们可以使用1 

00:11:23.790 --> 00:11:27.150
元素数组技巧或类似的东西

00:11:25.350 --> 00:11:28.350
那，即使你可以写这个

00:11:27.150 --> 00:11:30.330
你不想

00:11:28.350 --> 00:11:33.960
而你不想的原因是

00:11:30.330 --> 00:11:36.780
因为有些，如果你想象它正在执行

00:11:33.960 --> 00:11:39.420
并行地，该变量和为

00:11:36.780 --> 00:11:42.090
很热，必须由

00:11:39.420 --> 00:11:45.800
每个线程都正确，所以每个

00:11:42.090 --> 00:11:48.840
单线程将不得不

00:11:45.800 --> 00:11:50.010
掌握它以及原因

00:11:48.840 --> 00:11:51.690
你是说这行不通，我猜是

00:11:50.010 --> 00:11:53.640
因为这里没有有人看守

00:11:51.690 --> 00:11:55.530
必须同步它，这将

00:11:53.640 --> 00:11:57.300
将会是巨大的开销

00:11:55.530 --> 00:11:58.770
真的会完全删除

00:11:57.300 --> 00:12:00.630
进行并行处理的要点

00:11:58.770 --> 00:12:02.460
首先，如果有的话

00:12:00.630 --> 00:12:05.010
必须在每次访问时进行同步

00:12:02.460 --> 00:12:08.490
一些，所以我们真的不应该计算

00:12:05.010 --> 00:12:10.470
像这样的年龄不只是

00:12:08.490 --> 00:12:12.990
不只是这个例子

00:12:10.470 --> 00:12:14.580
任何使用蓄电池的东西

00:12:12.990 --> 00:12:17.370
有效地，我们将必须获得

00:12:14.580 --> 00:12:20.040
我们将不得不停止这样做

00:12:17.370 --> 00:12:23.730
和流的和参数

00:12:20.040 --> 00:12:24.960
设计师，这不仅是我们

00:12:23.730 --> 00:12:26.580
不应该感到我们不应该感到难过

00:12:24.960 --> 00:12:27.780
关于这一点，我们应该感到高兴，因为

00:12:26.580 --> 00:12:29.310
我们将找到一种更好的方法

00:12:27.780 --> 00:12:31.290
编码，所以他们有一个相当

00:12:29.310 --> 00:12:33.300
传福音的态度

00:12:31.290 --> 00:12:35.340
流API的设计有一个推动

00:12:33.300 --> 00:12:37.440
进行函数式编程和

00:12:35.340 --> 00:12:40.410
你会看到我希望它真的能

00:12:37.440 --> 00:12:42.630
结果如此

00:12:40.410 --> 00:12:44.760
所以我们要使用减少测试

00:12:42.630 --> 00:12:46.230
现在我进入那种终端

00:12:44.760 --> 00:12:47.760
操作我真的很感兴趣

00:12:46.230 --> 00:12:51.000
是减少，所以有什么区别

00:12:47.760 --> 00:12:53.640
在减少和使用之间

00:12:51.000 --> 00:12:57.360
为什么我们想要它，我想是

00:12:53.640 --> 00:12:58.620
这里的问题，所以我在这里

00:12:57.360 --> 00:13:01.590
您会想到的那种代码

00:12:58.620 --> 00:13:04.260
如果您想计算

00:13:01.590 --> 00:13:06.260
数组中所有值的总和

00:13:04.260 --> 00:13:09.750
我到这里了我被处死了

00:13:06.260 --> 00:13:10.980
它的图形只是非常非常粗略的你

00:13:09.750 --> 00:13:13.710
可以看到将要发生的是

00:13:10.980 --> 00:13:15.450
这种执行的方式

00:13:13.710 --> 00:13:17.550
那条蓝色的语句将

00:13:15.450 --> 00:13:18.780
涉及重复添加相同的

00:13:17.550 --> 00:13:20.610
变量，所以首先我们得到

00:13:18.780 --> 00:13:23.100
值0我们将其加1然后得到

00:13:20.610 --> 00:13:25.170
值2现在我们已经到

00:13:23.100 --> 00:13:27.540
我们积累的价值，依此类推

00:13:25.170 --> 00:13:29.670
那，那当然是要

00:13:27.540 --> 00:13:31.500
将会给这个巨大的

00:13:29.670 --> 00:13:35.550
我提到我们的问题

00:13:31.500 --> 00:13:36.960
就是没有同步

00:13:35.550 --> 00:13:39.180
这是错误的，并与

00:13:36.960 --> 00:13:41.280
同步会很慢，而且

00:13:39.180 --> 00:13:42.660
反正真的很优雅

00:13:41.280 --> 00:13:44.520
您将要避免使用累加器

00:13:42.660 --> 00:13:46.320
可以使用它，我们可以使用所谓的减少

00:13:44.520 --> 00:13:49.260
操作我要看的那个

00:13:46.320 --> 00:13:52.050
这是的两个重载

00:13:49.260 --> 00:13:54.990
减少四英寸流之一

00:13:52.050 --> 00:13:57.330
这需要int和

00:13:54.990 --> 00:13:59.310
其中之一需要哪个

00:13:57.330 --> 00:14:00.720
需要一个基本值和一个二进制

00:13:59.310 --> 00:14:02.010
对其进行操作，我们将看到差异

00:14:00.720 --> 00:14:04.170
他们之间，但我要去

00:14:02.010 --> 00:14:05.940
看是现在的第一个，所以避免

00:14:04.170 --> 00:14:07.770
一个蓄能器，你会纠正你的

00:14:05.940 --> 00:14:10.200
可以写这样的东西，所以在这里

00:14:07.770 --> 00:14:12.120
我们正在做的是我们正在采取的

00:14:10.200 --> 00:14:15.090
价值观，我们把它们

00:14:12.120 --> 00:14:16.820
进入流，而不是使用

00:14:15.090 --> 00:14:18.750
在这里列出我只是在使用一个数组， 

00:14:16.820 --> 00:14:20.340
我们将要减少

00:14:18.750 --> 00:14:23.670
他们超过这个总和

00:14:20.340 --> 00:14:25.190
操作是什么意思

00:14:23.670 --> 00:14:27.540
意味着我们要说

00:14:25.190 --> 00:14:30.060
操作将需要两个

00:14:27.540 --> 00:14:31.980
它会返回它们的总和，所以

00:14:30.060 --> 00:14:33.270
执行图将如下所示

00:14:31.980 --> 00:14:35.880
看起来像右边的东西

00:14:33.270 --> 00:14:37.320
现在，您可以看到，如果

00:14:35.880 --> 00:14:39.480
你扩大规模，因为这是

00:14:37.320 --> 00:14:41.520
很小，但如果有的话

00:14:39.480 --> 00:14:43.380
有更大的阵列，您可以看到

00:14:41.520 --> 00:14:45.810
你会得到你会得到一个

00:14:43.380 --> 00:14:49.560
他们专注于

00:14:45.810 --> 00:14:51.420
在一个变量上是单变量，那是什么

00:14:49.560 --> 00:14:53.910
工作所需的条件

00:14:51.420 --> 00:14:56.100
答案是

00:14:53.910 --> 00:14:59.670
虽然那是一种可能的执行

00:14:56.100 --> 00:15:02.420
该代码的图形不是

00:14:59.670 --> 00:15:05.160
唯一可能的一个

00:15:02.420 --> 00:15:08.310
分割器ATAR致力于将

00:15:05.160 --> 00:15:09.540
划分数组结构是

00:15:08.310 --> 00:15:10.770
你真的不知道的东西

00:15:09.540 --> 00:15:12.870
前进，所以您不必知道

00:15:10.770 --> 00:15:16.470
细节，而你应该定义一个

00:15:12.870 --> 00:15:18.510
即将进行的操作是否

00:15:16.470 --> 00:15:22.500
它分裂了，并且条件

00:15:18.510 --> 00:15:23.940
发生的是，例如我们

00:15:22.500 --> 00:15:26.370
可能会得到我们可能会得到这个而不是这个

00:15:23.940 --> 00:15:29.040
不同的这个不同的执行图

00:15:26.370 --> 00:15:30.990
这也是可能的，当然

00:15:29.040 --> 00:15:32.490
如果可能的话，可能会很清楚

00:15:30.990 --> 00:15:35.370
正在与顺序

00:15:32.490 --> 00:15:38.520
流，所以它的条件

00:15:35.370 --> 00:15:40.530
为此所需的条件

00:15:38.520 --> 00:15:42.870
对于减少工作是二进制

00:15:40.530 --> 00:15:45.990
运算符必须是关联的

00:15:42.870 --> 00:15:48.450
表示加B加C 

00:15:45.990 --> 00:15:49.650
与aa加B加C相同

00:15:48.450 --> 00:15:51.330
换句话说，我们如何都没关系

00:15:49.650 --> 00:15:53.580
整理东西仍然是顺序

00:15:51.330 --> 00:15:55.110
重要的是我们不是在谈论

00:15:53.580 --> 00:15:57.690
那个东西就是

00:15:55.110 --> 00:15:59.910
可逆或可交换，但我们

00:15:57.690 --> 00:16:02.670
谈论我们在谈论那个

00:15:59.910 --> 00:16:05.220
我们将操作数分组到的方式

00:16:02.670 --> 00:16:08.670
我们提供的减少操作

00:16:05.220 --> 00:16:10.950
一定要不要紧不要紧

00:16:08.670 --> 00:16:12.720
您可以看到，如果我们现在扩大规模

00:16:10.950 --> 00:16:14.250
我们知道了，我们得到了更好的画面

00:16:12.720 --> 00:16:16.470
假设我们想将一个

00:16:14.250 --> 00:16:18.150
很多不同的东西，那么你可以看到

00:16:16.470 --> 00:16:19.500
假设你在这里

00:16:18.150 --> 00:16:21.270
我们不是在想象这有

00:16:19.500 --> 00:16:22.950
正在两个执行的两个线程

00:16:21.270 --> 00:16:25.110
线程，他们可以继续

00:16:22.950 --> 00:16:26.130
直到最后他们独立

00:16:25.110 --> 00:16:27.840
他们将不得不

00:16:26.130 --> 00:16:30.180
结果是必须的

00:16:27.840 --> 00:16:32.160
现在在一起，你可能会想

00:16:30.180 --> 00:16:34.170
好吧，这是巨大的开销，而且很多

00:16:32.160 --> 00:16:35.790
为了做而浪费时间

00:16:34.170 --> 00:16:37.380
另外，你会很正确的

00:16:35.790 --> 00:16:39.810
瑞吉斯（Regis），所以没有减少的方法

00:16:37.380 --> 00:16:41.340
实际上是要战胜

00:16:39.810 --> 00:16:44.760
在以下方面使用累加器

00:16:41.340 --> 00:16:47.190
效率仅用于添加，但

00:16:44.760 --> 00:16:49.440
如果你有中级水平

00:16:47.190 --> 00:16:51.330
超过

00:16:49.440 --> 00:16:52.650
只要记住，记住

00:16:51.330 --> 00:16:54.630
我们在这里基本上是

00:16:52.650 --> 00:16:56.780
这是一条管道，我的意思是我只是

00:16:54.630 --> 00:16:59.730
简化为非常简单

00:16:56.780 --> 00:17:01.260
对于这个非常简单的情况，但是如果您有

00:16:59.730 --> 00:17:02.820
经过计算的管道

00:17:01.260 --> 00:17:05.190
沉重的，这是重要的

00:17:02.820 --> 00:17:06.960
那么在计算上就很昂贵

00:17:05.190 --> 00:17:07.420
案例分发出去

00:17:06.960 --> 00:17:09.900
不同

00:17:07.420 --> 00:17:12.940
导致并允许他们继续前进

00:17:09.900 --> 00:17:14.350
他们的处理可能会收获很大

00:17:12.940 --> 00:17:16.390
因此，例如，如果您

00:17:14.350 --> 00:17:18.280
进行密码计算或

00:17:16.390 --> 00:17:19.420
你在写象棋程序或一些

00:17:18.280 --> 00:17:22.060
另一件事需要一个

00:17:19.420 --> 00:17:24.550
很多繁重的计算，然后

00:17:22.060 --> 00:17:26.920
最大限度地利用并行核

00:17:24.550 --> 00:17:28.360
现在几乎所有机器都具有并行

00:17:26.920 --> 00:17:30.730
当然还是服务器机器

00:17:28.360 --> 00:17:31.810
这将是给

00:17:30.730 --> 00:17:33.550
你会给你很大的

00:17:31.810 --> 00:17:35.950
游戏，那就是那种

00:17:33.550 --> 00:17:38.380
潜在的建筑动机

00:17:35.950 --> 00:17:43.210
朝着这种

00:17:38.380 --> 00:17:46.600
没关系，所以这就是减少

00:17:43.210 --> 00:17:48.280
适用于手臂原始体

00:17:46.600 --> 00:17:50.440
简单的案例和还原工作

00:17:48.280 --> 00:17:53.890
不变值到参考值

00:17:50.440 --> 00:17:56.560
很好，它是在API中定义的

00:17:53.890 --> 00:17:58.900
我已经证明我给你减少了定义

00:17:56.560 --> 00:18:01.660
在流中，现在我要展示

00:17:58.900 --> 00:18:03.070
您减少了对流的定义，而您

00:18:01.660 --> 00:18:05.620
知道我们有这四个不同

00:18:03.070 --> 00:18:07.360
原始流的种类

00:18:05.620 --> 00:18:10.540
加倍又长，然后我们得到

00:18:07.360 --> 00:18:13.300
参考流，所以他们确实定义了

00:18:10.540 --> 00:18:15.880
减少参考流，您

00:18:13.300 --> 00:18:18.220
可以看到它可以正常工作

00:18:15.880 --> 00:18:20.650
不变的价值不是很多

00:18:18.220 --> 00:18:23.590
平台中的表引用类型

00:18:20.650 --> 00:18:25.630
 API，但其中之一是大十进制

00:18:23.590 --> 00:18:28.750
你不能实际上不能改变其中之一

00:18:25.630 --> 00:18:32.650
这些等等，例如，如果您想要

00:18:28.750 --> 00:18:34.510
加上一个大十进制的列表，然后

00:18:32.650 --> 00:18:35.920
一个大十进制数组，那么你可以

00:18:34.510 --> 00:18:39.550
减少然后您可以减少它们

00:18:35.920 --> 00:18:41.230
那种方式，那是怎么回事

00:18:39.550 --> 00:18:42.760
不变的价值，那又如何

00:18:41.230 --> 00:18:47.520
集合不是

00:18:42.760 --> 00:18:49.600
一成不变的好，我们怎样才能减少

00:18:47.520 --> 00:18:52.210
我们可以用

00:18:49.600 --> 00:18:53.620
 API给您的集合

00:18:52.210 --> 00:18:55.420
明白，因为毕竟

00:18:53.620 --> 00:18:57.220
他们已经定义了reduce操作

00:18:55.420 --> 00:18:59.380
参考参考值，所以

00:18:57.220 --> 00:19:03.300
看起来应该工作，实际上

00:18:59.380 --> 00:19:05.950
事实是他们不是他们

00:19:03.300 --> 00:19:07.660
有很多时间的压力

00:19:05.950 --> 00:19:09.850
流的定义

00:19:07.660 --> 00:19:11.170
框架，这是

00:19:09.850 --> 00:19:13.060
如果他们有更多时间考虑

00:19:11.170 --> 00:19:14.710
可能没有，可能没有

00:19:13.060 --> 00:19:17.020
溜走不是因为不是你

00:19:14.710 --> 00:19:18.550
不是因为像我这样完全没用

00:19:17.020 --> 00:19:20.700
在十进制示例中向您展示了您

00:19:18.550 --> 00:19:22.860
可以使用它，但是因为它是

00:19:20.700 --> 00:19:24.810
误导很多人

00:19:22.860 --> 00:19:27.690
掉下来掉进陷阱

00:19:24.810 --> 00:19:29.340
这种情况下，有一种方法

00:19:27.690 --> 00:19:31.290
你可以减少收藏

00:19:29.340 --> 00:19:35.340
工作，这种方式很漂亮

00:19:31.290 --> 00:19:39.120
可怕的是你可能会接受

00:19:35.340 --> 00:19:41.070
你的流，你可以和在

00:19:39.120 --> 00:19:43.050
客户代码，您可以创建一个新的空白

00:19:41.070 --> 00:19:44.730
收集，然后您可以提交

00:19:43.050 --> 00:19:50.220
那你可以提交那些

00:19:44.730 --> 00:19:52.590
收集到的只是一个

00:19:50.220 --> 00:19:55.260
归约和归约运算

00:19:52.590 --> 00:19:57.660
会是一个天窗娃娃

00:19:55.260 --> 00:19:59.400
将两个集合合并在一起

00:19:57.660 --> 00:20:01.170
有可能做到这一点，我将展示

00:19:59.400 --> 00:20:02.580
你是一个例子的结尾

00:20:01.170 --> 00:20:04.290
这样做，但这不是你的事

00:20:02.580 --> 00:20:05.430
会想在实践中做到的

00:20:04.290 --> 00:20:06.450
真的，真的，真的很漂亮

00:20:05.430 --> 00:20:08.640
严峻

00:20:06.450 --> 00:20:09.900
这是极端的，如果要

00:20:08.640 --> 00:20:11.190
效率极低，因为您

00:20:09.900 --> 00:20:12.690
将不得不创造很多

00:20:11.190 --> 00:20:14.760
多余的东西，你将不得不

00:20:12.690 --> 00:20:16.140
使用通常是所有的门

00:20:14.760 --> 00:20:18.360
时间通常要多得多

00:20:16.140 --> 00:20:22.460
比添加操作效率低

00:20:18.360 --> 00:20:30.980
收集，基本上是可怕的

00:20:22.460 --> 00:20:33.720
所以我们可以做得更好

00:20:30.980 --> 00:20:35.520
好吧，我只想说那是

00:20:33.720 --> 00:20:36.690
就在我继续谈论之前

00:20:35.520 --> 00:20:39.210
收集，所以我只想看看

00:20:36.690 --> 00:20:42.990
在我谈论过的另一个超载

00:20:39.210 --> 00:20:45.000
关于约简法

00:20:42.990 --> 00:20:47.070
只需一个操作员

00:20:45.000 --> 00:20:50.610
关于一个具有基本值的

00:20:47.070 --> 00:20:51.840
和handin运算符，以便

00:20:50.610 --> 00:20:53.040
对于我们采取的措施很重要

00:20:51.840 --> 00:20:55.950
我们接下来要谈的是

00:20:53.040 --> 00:20:58.320
两者都适用于原始流

00:20:55.950 --> 00:21:02.310
如顶部和参考流

00:20:58.320 --> 00:21:05.670
就像下面的例子一样

00:21:02.310 --> 00:21:08.390
您可以在此处看到一个示例

00:21:05.670 --> 00:21:10.920
我正在计算代码的总和

00:21:08.390 --> 00:21:12.570
在一个十进制数组上

00:21:10.920 --> 00:21:16.500
而我做的方式是

00:21:12.570 --> 00:21:18.930
减少大十进制零作为

00:21:16.500 --> 00:21:21.390
基本值，然后再分别

00:21:18.930 --> 00:21:25.110
然后每个后续操作将

00:21:21.390 --> 00:21:28.470
将将被添加，现在可以正常工作

00:21:25.110 --> 00:21:29.670
它在特别是

00:21:28.470 --> 00:21:33.450
有用的方法，因为这意味着您不会

00:21:29.670 --> 00:21:34.290
必须返回一个可选的，你知道

00:21:33.450 --> 00:21:36.630
即使流

00:21:34.290 --> 00:21:38.820
空，过去我们有一个可选的

00:21:36.630 --> 00:21:40.320
来自的上一个示例

00:21:38.820 --> 00:21:43.260
其他重载，您可以看到可选的int 

00:21:40.320 --> 00:21:44.280
和可选的幻灯片上的T，但

00:21:43.260 --> 00:21:46.110
这个你不需要

00:21:44.280 --> 00:21:48.090
可选，因为即使流是

00:21:46.110 --> 00:21:49.830
空的你知道你知道那里

00:21:48.090 --> 00:21:51.570
将至少是一个值一个值

00:21:49.830 --> 00:21:53.520
会回来的，因为你

00:21:51.570 --> 00:21:57.900
因为你有大十进制零

00:21:53.520 --> 00:22:00.000
以这样开始

00:21:57.900 --> 00:22:02.880
这适用于不可变的对象

00:22:00.000 --> 00:22:04.440
这就是它的样子

00:22:02.880 --> 00:22:06.720
减少身份看起来像

00:22:04.440 --> 00:22:09.810
现在，所以我们有一个我们有我们要

00:22:06.720 --> 00:22:11.370
潜在的两半

00:22:09.810 --> 00:22:14.580
超过两个，但两个半

00:22:11.370 --> 00:22:16.830
数组在这里，我们和每个线程都是

00:22:14.580 --> 00:22:18.690
它在操作上将要做什么

00:22:16.830 --> 00:22:21.180
单独的核心，它将开始于

00:22:18.690 --> 00:22:22.560
在我们大的情况下

00:22:21.180 --> 00:22:24.030
小数点在这里开始

00:22:22.560 --> 00:22:25.770
与零，然后将其添加

00:22:24.030 --> 00:22:27.720
当它是

00:22:25.770 --> 00:22:29.160
完成时就完成了

00:22:27.720 --> 00:22:30.120
什么时候完成的

00:22:29.160 --> 00:22:33.480
所有的威胁已经完成了

00:22:30.120 --> 00:22:34.710
他们可以将结果合并在一起

00:22:33.480 --> 00:22:37.410
这项工作与收藏

00:22:34.710 --> 00:22:43.280
很好地简化身份不会

00:22:37.410 --> 00:22:43.280
完全与馆藏合作，为什么不呢？ 

00:22:45.140 --> 00:22:49.710
不是不是一成不变的，但我只是但我是

00:22:48.150 --> 00:22:51.510
那个说这应该只

00:22:49.710 --> 00:22:54.360
如果您尝试与他们一起工作

00:22:51.510 --> 00:22:55.860
减少您不会收集的收藏

00:22:54.360 --> 00:22:57.240
出现编译错误或其他任何错误

00:22:55.860 --> 00:23:00.540
不得到你就不会被执行

00:22:57.240 --> 00:23:03.480
我们知道它不会抛出错误的错误

00:23:00.540 --> 00:23:06.830
例外或类似的东西，但

00:23:03.480 --> 00:23:06.830
你只会得到错误的答案

00:23:17.200 --> 00:23:21.070
好吧，假设我提供

00:23:19.510 --> 00:23:23.050
假设和提供者等问题

00:23:21.070 --> 00:23:24.220
所以问题是

00:23:23.050 --> 00:23:26.560
没有确定性，因为我没有

00:23:24.220 --> 00:23:29.050
初始值，但假设我提供了一个

00:23:26.560 --> 00:23:31.390
空集合我提供的方式相同

00:23:29.050 --> 00:23:39.190
大十进制零那里然后

00:23:31.390 --> 00:23:41.500
起点集合

00:23:39.190 --> 00:23:43.900
订购事项订购命令

00:23:41.500 --> 00:23:45.340
绝对会影响结果，但是

00:23:43.900 --> 00:23:47.680
其实这不是关键

00:23:45.340 --> 00:23:50.560
所以根据什么顺序

00:23:47.680 --> 00:23:52.420
执行线程，您将得到

00:23:50.560 --> 00:23:55.930
在相当不同的结果

00:23:52.420 --> 00:24:01.720
变幻莫测的方式我摸了索哦

00:23:55.930 --> 00:24:02.860
不，我触摸了我们完成的电缆，但是在

00:24:01.720 --> 00:24:05.020
至少至少我有一个讨论

00:24:02.860 --> 00:24:11.470
无论如何要继续我所做的一切

00:24:05.020 --> 00:24:17.350
这只是一个最简单的刷子，所以

00:24:11.470 --> 00:24:21.250
问题是这是一个真实的

00:24:17.350 --> 00:24:24.040
我可以做多处理的例子

00:24:21.250 --> 00:24:27.490
这就是为什么它不会的原因

00:24:24.040 --> 00:24:32.220
工作是因为背后的假设

00:24:27.490 --> 00:24:35.920
减少的是基础

00:24:32.220 --> 00:24:37.840
基本值是

00:24:35.920 --> 00:24:45.750
假设基值是不变的

00:24:37.840 --> 00:24:45.750
我只是认真阅读

00:24:46.720 --> 00:24:52.400
这是一个游戏，不是吗

00:24:49.420 --> 00:24:55.160
该基础的假设

00:24:52.400 --> 00:24:56.660
基本值是不可变的，因此

00:24:55.160 --> 00:24:58.760
关于不变性真的很重要

00:24:56.660 --> 00:25:02.990
所以基本上每个线程都会尝试

00:24:58.760 --> 00:25:07.370
使用相同的基本值

00:25:02.990 --> 00:25:11.120
它将尝试使用相同的基数

00:25:07.370 --> 00:25:12.830
计算的价值，那么

00:25:11.120 --> 00:25:15.470
会发生的是，如果你说我要

00:25:12.830 --> 00:25:17.210
如果你提供它，你提供它

00:25:15.470 --> 00:25:18.530
如果您说的是空集合

00:25:17.210 --> 00:25:20.270
收集将是这个的开始

00:25:18.530 --> 00:25:22.549
减少，那么每个线程都会占用

00:25:20.270 --> 00:25:24.049
和我开始时一样的收藏

00:25:22.549 --> 00:25:25.220
减少，开始将是空的

00:25:24.049 --> 00:25:26.990
关闭，但当第二个线程

00:25:25.220 --> 00:25:28.820
随之而来的将不再是空的

00:25:26.990 --> 00:25:30.590
但是第二个线程不知道

00:25:28.820 --> 00:25:32.809
线程会变得很混乱， 

00:25:30.590 --> 00:25:35.840
我将让他们进行并发访问

00:25:32.809 --> 00:25:43.820
到那个集合，所以它不起作用

00:25:35.840 --> 00:25:45.320
不会工作没关系吧

00:25:43.820 --> 00:25:46.640
可能会起作用，让我想起来

00:25:45.320 --> 00:25:54.460
让我想在家中可以使用

00:25:46.640 --> 00:25:54.460
我们在一个线程上不是吗

00:25:55.780 --> 00:26:00.320
它可能会在一个

00:25:58.400 --> 00:26:02.510
单线程，如果您很幸运，但是如果

00:26:00.320 --> 00:26:04.640
但绝对是这样的

00:26:02.510 --> 00:26:06.260
指定的API是说

00:26:04.640 --> 00:26:08.420
绝对您不保证拥有它

00:26:06.260 --> 00:26:09.950
您无法保证工作，所以在某些情况下

00:26:08.420 --> 00:26:11.420
指向未来，当有人说

00:26:09.950 --> 00:26:13.280
嗯，这个程序看起来好像可以运行

00:26:11.420 --> 00:26:15.260
在程序的并行硬件上更好

00:26:13.280 --> 00:26:17.630
会打破我的意思是你的程序是

00:26:15.260 --> 00:26:20.720
绝对不是线程安全的，它将

00:26:17.630 --> 00:26:22.790
在如何做方面几乎没有改变

00:26:20.720 --> 00:26:24.260
它的均匀性以及如何部署

00:26:22.790 --> 00:26:25.580
在未来并部署大量

00:26:24.260 --> 00:26:28.610
不同的硬件，它可能会因此中断

00:26:25.580 --> 00:26:30.590
你，所以这不是，不是，不是

00:26:28.610 --> 00:26:32.180
走下去的路我们必须做

00:26:30.590 --> 00:26:33.950
比这更好，所以答案

00:26:32.180 --> 00:26:36.080
这就是答案，这就是收藏家

00:26:33.950 --> 00:26:38.780
这里的想法是，而不是

00:26:36.080 --> 00:26:41.510
为身份提供基本价值

00:26:38.780 --> 00:26:43.280
提供功能，因此该功能是

00:26:41.510 --> 00:26:45.530
由每个线程执行，并产生

00:26:43.280 --> 00:26:49.340
每个都有一个新的新鲜空集合

00:26:45.530 --> 00:26:51.680
有时所以在这种情况下是

00:26:49.340 --> 00:26:54.920
我在想像中的lambda 

00:26:51.680 --> 00:26:56.900
对于此特定的可收集代码

00:26:54.920 --> 00:26:59.630
不管它是lambda 

00:26:56.900 --> 00:27:02.900
毫无疑问，他们是供应商

00:26:59.630 --> 00:27:06.530
用流API的语言

00:27:02.900 --> 00:27:08.360
 lambda函数API它说这是一个

00:27:06.530 --> 00:27:10.970
没有争议的供应商

00:27:08.360 --> 00:27:12.350
在这种情况下返回空

00:27:10.970 --> 00:27:15.020
和空的收藏，如果你吃

00:27:12.350 --> 00:27:17.120
线程在启动时调用它

00:27:15.020 --> 00:27:19.880
工作，那么每个人显然都会去

00:27:17.120 --> 00:27:23.150
获得自己的单独新线程

00:27:19.880 --> 00:27:25.490
新的新系列，所以没有

00:27:23.150 --> 00:27:27.080
减少看起来像这样的过载，但是

00:27:25.490 --> 00:27:29.540
它使用身份而不是供应商

00:27:27.080 --> 00:27:31.610
这非常相似，但这只是一个

00:27:29.540 --> 00:27:33.830
警告您，如果您曾经

00:27:31.610 --> 00:27:36.500
曾经试图减少

00:27:33.830 --> 00:27:40.430
过流不，而您正在尝试

00:27:36.500 --> 00:27:42.080
减少到可变值

00:27:40.430 --> 00:27:44.930
减少无效，这确实是

00:27:42.080 --> 00:27:46.100
 API应该具有的原因

00:27:44.930 --> 00:27:48.740
警告或类似的东西

00:27:46.100 --> 00:27:50.570
但是嘿，我们不和Java家伙一起做

00:27:48.740 --> 00:27:52.520
而且我们不会在API中添加警告

00:27:50.570 --> 00:27:55.340
文档，但我们确实但我们

00:27:52.520 --> 00:27:57.530
在这种情况下真的应该如此

00:27:55.340 --> 00:28:00.260
这就是答案，现在我们有了这些

00:27:57.530 --> 00:28:01.670
现在我们已经看到了组件

00:28:00.260 --> 00:28:03.710
这里的收藏家

00:28:01.670 --> 00:28:07.040
蓝色的供应商，我们有一个

00:28:03.710 --> 00:28:08.300
所谓哪个蓄电池

00:28:07.040 --> 00:28:12.440
添加

00:28:08.300 --> 00:28:14.990
元素到容器，然后

00:28:12.440 --> 00:28:17.450
当我们结束时，我们已经结束了

00:28:14.990 --> 00:28:18.620
当我们计算每个线程时

00:28:17.450 --> 00:28:20.210
它要计算的所有值

00:28:18.620 --> 00:28:22.730
结果必须结合在一起

00:28:20.210 --> 00:28:24.440
在所谓的组合器中

00:28:22.730 --> 00:28:26.510
那就是我们所要的

00:28:24.440 --> 00:28:28.010
看着是定义一个收藏家

00:28:26.510 --> 00:28:29.870
需要提供所有这三样东西

00:28:28.010 --> 00:28:32.150
提供累加器和组合器

00:28:29.870 --> 00:28:33.590
这听起来像是

00:28:32.150 --> 00:28:35.060
真的很努力，已经很合理了

00:28:33.590 --> 00:28:38.300
想这对我来说太多了

00:28:35.060 --> 00:28:39.530
不要以为是因为我有点

00:28:38.300 --> 00:28:41.890
我违反了规则

00:28:39.530 --> 00:28:44.840
真的在这里，这是一个规则

00:28:41.890 --> 00:28:45.890
我那时，布莱恩（Brian）非常强调

00:28:44.840 --> 00:28:47.630
写他说不告诉的书

00:28:45.890 --> 00:28:49.070
人们对这个东西他说，因为

00:28:47.630 --> 00:28:50.750
他非常担心它看起来

00:28:49.070 --> 00:28:52.400
努力，他说我要他们

00:28:50.750 --> 00:28:55.280
明白我们真的很容易

00:28:52.400 --> 00:28:56.660
实际上不必定义收集器

00:28:55.280 --> 00:29:00.620
我们自己经常有一个

00:28:56.660 --> 00:29:03.110
大量的

00:29:00.620 --> 00:29:05.290
收藏家按工厂提供给我们的

00:29:03.110 --> 00:29:07.100
收藏家类中的方法和

00:29:05.290 --> 00:29:09.110
这些是我要花费最多的

00:29:07.100 --> 00:29:11.510
今天谈论，因为他们是

00:29:09.110 --> 00:29:12.860
真的很有用，它们可以使您免受

00:29:11.510 --> 00:29:14.870
几乎必须要做这项工作

00:29:12.860 --> 00:29:16.250
时间，我将在最后谈论

00:29:14.870 --> 00:29:18.020
写自己的收藏家，但不是

00:29:16.250 --> 00:29:23.600
你必须要做的事情

00:29:18.020 --> 00:29:25.370
通常很多，所以这就是

00:29:23.600 --> 00:29:27.890
背后的基本动机

00:29:25.370 --> 00:29:29.000
藏家现在怎么回事

00:29:27.890 --> 00:29:30.770
我将谈论一些有关

00:29:29.000 --> 00:29:33.890
使用预定义的收集器

00:29:30.770 --> 00:29:35.870
这真的是

00:29:33.890 --> 00:29:37.100
说话与实际不符

00:29:35.870 --> 00:29:39.320
我们要做的工作是这样的

00:29:37.100 --> 00:29:43.610
是信息的心脏，所以

00:29:39.320 --> 00:29:45.230
收藏家API提供了这些

00:29:43.610 --> 00:29:47.570
收藏家类中的工厂方法

00:29:45.230 --> 00:29:49.520
他们生产独立的收藏家， 

00:29:47.570 --> 00:29:51.260
我要去的不是所有的收藏家

00:29:49.520 --> 00:29:53.000
是独立的，其中一些仅用于

00:29:51.260 --> 00:29:55.550
用作下游收藏家，我会

00:29:53.000 --> 00:29:56.840
解释一下，但是在

00:29:55.550 --> 00:29:58.250
首先让我们看看这些

00:29:56.840 --> 00:30:00.820
独立收藏家的东西

00:29:58.250 --> 00:30:04.160
因为它们更容易理解

00:30:00.820 --> 00:30:05.950
他们是，尽管我要说

00:30:04.160 --> 00:30:08.810
他们分为三类

00:30:05.950 --> 00:30:10.850
一旦将收集到

00:30:08.810 --> 00:30:12.920
框架提供的容器

00:30:10.850 --> 00:30:14.600
全部收集到自定义收藏中

00:30:12.920 --> 00:30:16.430
您在哪里提供

00:30:14.600 --> 00:30:18.170
收集自己并认为

00:30:16.430 --> 00:30:19.400
我称之为分类的东西

00:30:18.170 --> 00:30:21.950
那些是

00:30:19.400 --> 00:30:24.740
实际上最通用，最有用

00:30:21.950 --> 00:30:28.010
所以预定义的收集器是

00:30:24.740 --> 00:30:29.420
他们直接来自工厂

00:30:28.010 --> 00:30:30.740
方法以及工厂方法

00:30:29.420 --> 00:30:32.030
收藏家给这些工厂上课

00:30:30.740 --> 00:30:33.950
我不会写的方法

00:30:32.030 --> 00:30:35.630
收藏家博士名单和收藏家博士。 

00:30:33.950 --> 00:30:38.660
设置，因为它将使幻灯片

00:30:35.630 --> 00:30:40.400
不可读，但任何时候看到

00:30:38.660 --> 00:30:41.840
像这样的方法，这就是

00:30:40.400 --> 00:30:47.840
他们是他们来自他们

00:30:41.840 --> 00:30:50.120
从那一类，他们和

00:30:47.840 --> 00:30:51.560
对不起，顶行

00:30:50.120 --> 00:30:53.360
这些就是这些

00:30:51.560 --> 00:30:56.440
框架向供应商提供

00:30:53.360 --> 00:30:59.300
在两个列表的情况下，它将是

00:30:56.440 --> 00:31:01.490
目前它将收集到一个

00:30:59.300 --> 00:31:03.260
 ArrayList不保证总是

00:31:01.490 --> 00:31:05.030
将不属于规范的一部分，但

00:31:03.260 --> 00:31:07.760
这就是它的作用，还有一个哈希集和一个

00:31:05.030 --> 00:31:09.910
哈希图再次不是没有定义

00:31:07.760 --> 00:31:12.980
加盟略有不同

00:31:09.910 --> 00:31:14.960
加入的好处是可以有帮助

00:31:12.980 --> 00:31:17.860
连接字符串，以便执行操作

00:31:14.960 --> 00:31:19.910
喜欢它把字符串连接在一起

00:31:17.860 --> 00:31:22.130
如果您之间插入逗号， 

00:31:19.910 --> 00:31:23.900
想要或其他分隔符而不是

00:31:22.130 --> 00:31:24.920
你必须做这笨拙的事情

00:31:23.900 --> 00:31:26.870
我们过去经常要做的

00:31:24.920 --> 00:31:29.450
遍历他们然后拿最后一个

00:31:26.870 --> 00:31:31.370
分离出它，然后这样做

00:31:29.450 --> 00:31:33.590
将允许您指定前缀和

00:31:31.370 --> 00:31:35.180
后缀，依此类推

00:31:33.590 --> 00:31:36.740
进入这个类别，我就是这样

00:31:35.180 --> 00:31:38.540
谈论容器而不是

00:31:36.740 --> 00:31:40.430
集合，因为一个想法

00:31:38.540 --> 00:31:42.290
收藏家正在收集东西

00:31:40.430 --> 00:31:44.090
这将真正保持结果

00:31:42.290 --> 00:31:46.910
而不是总是收藏它

00:31:44.090 --> 00:31:50.210
通常是在地图和

00:31:46.910 --> 00:31:52.190
集合将允许您指定

00:31:50.210 --> 00:31:54.890
你自己的地图，但是你想要一个

00:31:52.190 --> 00:31:56.510
树图或链接的哈希图说或

00:31:54.890 --> 00:32:01.190
这样的事情或假设你

00:31:56.510 --> 00:32:02.810
希望您将收集到甲板或一些

00:32:01.190 --> 00:32:05.420
其他一些其他的东西

00:32:02.810 --> 00:32:07.420
其他实现数组平台

00:32:05.420 --> 00:32:10.010
实现java.util的东西

00:32:07.420 --> 00:32:11.810
收集，因此用户可能会这样

00:32:10.010 --> 00:32:13.400
您可以提供给供应商

00:32:11.810 --> 00:32:15.020
这种情况，然后是所有这些的最后

00:32:13.400 --> 00:32:17.930
产生分类图的东西

00:32:15.020 --> 00:32:19.400
将会非常关注这些

00:32:17.930 --> 00:32:22.730
我将说明这些事情

00:32:19.400 --> 00:32:26.360
处理善良的动画

00:32:22.730 --> 00:32:27.710
开始看起来有点过头了

00:32:26.360 --> 00:32:28.970
简单，你会觉得我很侮辱

00:32:27.710 --> 00:32:31.310
你的智慧，但他们确实有一点

00:32:28.970 --> 00:32:34.040
更难的是这是一个例子

00:32:31.310 --> 00:32:35.790
如果您想收集全部，就会发生

00:32:34.040 --> 00:32:40.170
人流的元素

00:32:35.790 --> 00:32:41.460
变成一个成一个这样的代码

00:32:40.170 --> 00:32:45.930
代码在底部的收集器中

00:32:41.460 --> 00:32:47.850
医生设置和我的想法

00:32:45.930 --> 00:32:49.590
动画是左边的东西

00:32:47.850 --> 00:32:51.360
这将是一条小溪， 

00:32:49.590 --> 00:32:53.490
人对象会随之而来， 

00:32:51.360 --> 00:32:54.600
然后，在

00:32:53.490 --> 00:32:56.580
右边就是我们要尝试的

00:32:54.600 --> 00:32:59.940
在这种情况下很漂亮

00:32:56.580 --> 00:33:03.090
收集器创建的简单，因此

00:32:59.940 --> 00:33:05.430
创建一个哈希集对象并在内部

00:33:03.090 --> 00:33:07.440
那，它把每个

00:33:05.430 --> 00:33:09.360
顺流而下的元素

00:33:07.440 --> 00:33:12.300
进入那个哈希集对象

00:33:09.360 --> 00:33:14.940
然后当流在

00:33:12.300 --> 00:33:16.620
当它自动感知时结束

00:33:14.940 --> 00:33:18.800
溪流已耗尽，然后

00:33:16.620 --> 00:33:20.760
然后集合然后发出集合

00:33:18.800 --> 00:33:23.850
所以这很简单

00:33:20.760 --> 00:33:25.350
嗯，我不会侮辱你的

00:33:23.850 --> 00:33:27.510
通过向您展示相同的知识

00:33:25.350 --> 00:33:30.180
之所以要列出，是因为

00:33:27.510 --> 00:33:32.340
明显，但也许到地图稍微

00:33:30.180 --> 00:33:37.140
更有趣，因为地图需要

00:33:32.340 --> 00:33:41.340
有两个功能

00:33:37.140 --> 00:33:43.350
将提供用于的密钥

00:33:41.340 --> 00:33:44.940
地图条目和函数

00:33:43.350 --> 00:33:49.290
这将提供值，因此

00:33:44.940 --> 00:33:51.860
在这种情况下，我们想要一张来自城市的地图

00:33:49.290 --> 00:33:54.540
对于所有的人

00:33:51.860 --> 00:33:57.360
对于所有的人对象和人，我们

00:33:54.540 --> 00:33:59.190
想要一张要去的地图就是

00:33:57.360 --> 00:34:01.410
去每个城市给

00:33:59.190 --> 00:34:03.000
通讯员给出一个人的名字

00:34:01.410 --> 00:34:06.480
这样住在那里的人

00:34:03.000 --> 00:34:07.950
再次起作用是这样的

00:34:06.480 --> 00:34:11.220
这种简单的账单

00:34:07.950 --> 00:34:13.409
进账单生活在哪里住账单

00:34:11.220 --> 00:34:18.060
他住在伦敦，所以伦敦成为

00:34:13.409 --> 00:34:21.000
该条目的密钥，并且

00:34:18.060 --> 00:34:23.970
比尔的名字叫比尔

00:34:21.000 --> 00:34:26.490
这样就成为了

00:34:23.970 --> 00:34:29.730
该条目，现在是我和

00:34:26.490 --> 00:34:31.980
艾米住在雅典，她的名字叫

00:34:29.730 --> 00:34:35.370
还有艾米，所以我们用这种方式

00:34:31.980 --> 00:34:37.980
我们建立了地图，并在适当的时候

00:34:35.370 --> 00:34:39.480
这些流用尽了，那张地图

00:34:37.980 --> 00:34:42.870
出来后，我们会得到一张从城市到

00:34:39.480 --> 00:34:45.510
字符串，因为因为键映射器

00:34:42.870 --> 00:34:47.840
制片人带一个人给了一个城市

00:34:45.510 --> 00:34:50.450
价值映射花了一个人， 

00:34:47.840 --> 00:34:51.700
并给出一个字符串，这似乎是

00:34:50.450 --> 00:34:54.560
看起来很简单

00:34:51.700 --> 00:34:56.420
但是会发生什么，尽管我是说你可以

00:34:54.560 --> 00:34:58.280
可能看到蛇有肉

00:34:56.420 --> 00:35:04.340
马上，如果两个

00:34:58.280 --> 00:35:05.480
人们住在同一个城市双关语

00:35:04.340 --> 00:35:07.700
会得到的，你的确会得到的

00:35:05.480 --> 00:35:10.220
发生冲突，这里是约翰，现在约翰

00:35:07.700 --> 00:35:13.280
搬到雅典将会发生什么事

00:35:10.220 --> 00:35:15.350
那里你不可能有两个地图

00:35:13.280 --> 00:35:18.230
具有相同键的条目

00:35:15.350 --> 00:35:23.480
显然，因此默认情况下您会

00:35:18.230 --> 00:35:24.980
 get是一个非法的州例外

00:35:23.480 --> 00:35:26.630
可能不会对此感到困扰，因为

00:35:24.980 --> 00:35:27.710
毕竟您实际上可能有数据

00:35:26.630 --> 00:35:29.120
设定您实际知道的地方

00:35:27.710 --> 00:35:31.340
每个人都将融入其中

00:35:29.120 --> 00:35:33.380
按键将是不同的，但

00:35:31.340 --> 00:35:35.930
它，但是还有另一个过载

00:35:33.380 --> 00:35:37.400
允许这种可能性

00:35:35.930 --> 00:35:40.760
情况可能会出现，您可能想要

00:35:37.400 --> 00:35:42.260
处理它，所以这个需要

00:35:40.760 --> 00:35:44.080
像以前一样将键映射到值映射上

00:35:42.260 --> 00:35:47.660
但现在它也想要合并功能

00:35:44.080 --> 00:35:49.640
合并功能需要两个

00:35:47.660 --> 00:35:51.680
值和值中的两个值

00:35:49.640 --> 00:35:53.090
域，并与他们做一些事情， 

00:35:51.680 --> 00:35:55.850
给您带来价值中的价值

00:35:53.090 --> 00:35:57.260
域，所以在这种情况下，我非常简单地

00:35:55.850 --> 00:35:59.660
我所做的是我拿了两个两个

00:35:57.260 --> 00:36:01.970
字符串，我将它们串联在一起

00:35:59.660 --> 00:36:04.010
在一起只是为了

00:36:01.970 --> 00:36:06.560
简单的例子，现在你

00:36:04.010 --> 00:36:10.190
可以看到该代码是否已执行

00:36:06.560 --> 00:36:12.980
事实证明，艾米和

00:36:10.190 --> 00:36:14.570
约翰和这里住在同一地方

00:36:12.980 --> 00:36:16.970
来这里来约翰，现在我们有

00:36:14.570 --> 00:36:19.310
同样的碰撞，在这种情况下， 

00:36:16.970 --> 00:36:22.040
发生的是因为我们有了

00:36:19.310 --> 00:36:23.690
底部有两个lambda 

00:36:22.040 --> 00:36:26.270
字符串值并将它们连接在一起

00:36:23.690 --> 00:36:28.370
这就是要放入的内容

00:36:26.270 --> 00:36:29.780
达到该条目的值

00:36:28.370 --> 00:36:35.090
碰撞的原因就是这样

00:36:29.780 --> 00:36:36.980
出现，所以我应该说原因

00:36:35.090 --> 00:36:38.690
我经历所有这些的原因是

00:36:36.980 --> 00:36:40.310
当您首先看到

00:36:38.690 --> 00:36:42.410
像顶部的签名

00:36:40.310 --> 00:36:43.730
他们得到了我的意思是这有点

00:36:42.410 --> 00:36:45.230
复杂，他们得到更多

00:36:43.730 --> 00:36:47.330
复杂，如果您不习惯

00:36:45.230 --> 00:36:49.220
我第一次见面时就知道了

00:36:47.330 --> 00:36:52.520
有些不，有很多尖括号

00:36:49.220 --> 00:36:54.710
确实存在，并且有一个

00:36:52.520 --> 00:36:55.640
自然就在真正的API中

00:36:54.710 --> 00:36:58.190
有很多问号

00:36:55.640 --> 00:37:00.440
我已经录音的内容

00:36:58.190 --> 00:37:01.550
为了简单起见， 

00:37:00.440 --> 00:37:03.110
颇有争议

00:37:01.550 --> 00:37:05.450
我认为这是一个很好的主意

00:37:03.110 --> 00:37:07.400
只要你知道也许可以克服

00:37:05.450 --> 00:37:08.810
你那背后发生了什么

00:37:07.400 --> 00:37:13.250
场景实际上要多得多

00:37:08.810 --> 00:37:14.690
简单，这就是正确，所以

00:37:13.250 --> 00:37:18.050
就是那个框架

00:37:14.690 --> 00:37:19.430
框架提供了容器和

00:37:18.050 --> 00:37:20.360
就是他们，他们是自定义收藏

00:37:19.430 --> 00:37:23.960
很漂亮很简单

00:37:20.360 --> 00:37:25.160
这里有一个映射方法

00:37:23.960 --> 00:37:29.210
这将要去哪

00:37:25.160 --> 00:37:31.850
允许您收集与自定义的对话

00:37:29.210 --> 00:37:34.430
地图我在这里以一个例子

00:37:31.850 --> 00:37:36.200
树状图，您注意到，因为

00:37:34.430 --> 00:37:38.060
他们都是我们现在遇到的困难

00:37:36.200 --> 00:37:40.820
遇到过载过载

00:37:38.060 --> 00:37:42.440
产生更多方法重载

00:37:40.820 --> 00:37:44.390
产生越来越多的困难

00:37:42.440 --> 00:37:45.890
时间流逝，语言是

00:37:44.390 --> 00:37:47.930
扩展，所以带来了很多问题

00:37:45.890 --> 00:37:51.830
带有lambda和方法引用，以及

00:37:47.930 --> 00:37:55.850
所以现在它们在API中很流行

00:37:51.830 --> 00:37:57.800
不定义不定义两种方法

00:37:55.850 --> 00:37:59.600
具有相同数量的参数

00:37:57.800 --> 00:38:01.280
这样，例如这里

00:37:59.600 --> 00:38:02.990
你可能你可能不想

00:38:01.280 --> 00:38:04.340
您仍然要合并的功能

00:38:02.990 --> 00:38:09.470
如果您必须提供电动机功能

00:38:04.340 --> 00:38:13.340
想要提供地图供应商，因为它

00:38:09.470 --> 00:38:15.200
因为如果我们忽略合并

00:38:13.340 --> 00:38:16.580
功能只是让您提供它们

00:38:15.200 --> 00:38:18.140
在Map函数上，我们只需要

00:38:16.580 --> 00:38:23.110
遇到两个过载，每个过载四个

00:38:18.140 --> 00:38:25.760
参数，然后方法重载

00:38:23.110 --> 00:38:27.410
开始变得非常困难，所以我们

00:38:25.760 --> 00:38:29.030
现在玩一个简单的方法，所以您必须

00:38:27.410 --> 00:38:31.400
提供新兴功能，但当然

00:38:29.030 --> 00:38:32.870
如果你真的不想要一个

00:38:31.400 --> 00:38:34.430
真的不想要一个那么你可以

00:38:32.870 --> 00:38:37.070
只需返回默认值即可

00:38:34.430 --> 00:38:39.260
抛出非法状态异常

00:38:37.070 --> 00:38:41.450
关于这张地图我还没有工厂

00:38:39.260 --> 00:38:43.280
为此有一个动画，但是这个主意

00:38:41.450 --> 00:38:45.440
基本上是完全可以

00:38:43.280 --> 00:38:47.780
和我以前一样

00:38:45.440 --> 00:38:51.740
地图示例衬衫没有，但在这种情况下

00:38:47.780 --> 00:38:54.470
你告诉收藏家

00:38:51.740 --> 00:38:56.960
作为容器放置什么

00:38:54.470 --> 00:38:58.820
收集到所以你看到你给

00:38:56.960 --> 00:39:01.490
它会做什么它被称为

00:38:58.820 --> 00:39:05.090
您在这种情况下提供的供应商

00:39:01.490 --> 00:39:06.800
我们提供了我们给的供应商

00:39:05.090 --> 00:39:09.680
那是一个无参数的构造函数

00:39:06.800 --> 00:39:11.510
树图的地图，因此它将调用

00:39:09.680 --> 00:39:12.770
树状图，它将并且将使用

00:39:11.510 --> 00:39:16.300
作为盒子

00:39:12.770 --> 00:39:16.300
将会收集到

00:39:22.109 --> 00:39:25.420
它的确确实很抱歉，因为这样

00:39:24.339 --> 00:39:27.130
问题是到底有没有必要

00:39:25.420 --> 00:39:29.440
结合多个多个树图

00:39:27.130 --> 00:39:31.480
它是绝对创建的，所以它

00:39:29.440 --> 00:39:33.160
最后没有地图合并，并且有

00:39:31.480 --> 00:39:34.900
以线程安全的方式做到这一点，因为

00:39:33.160 --> 00:39:38.230
树形图当然不是，不是

00:39:34.900 --> 00:39:40.599
这是安全的，所以其中的一大奖励

00:39:38.230 --> 00:39:42.309
流API的特征在于

00:39:40.599 --> 00:39:44.609
允许您使用并行流和

00:39:42.309 --> 00:39:47.079
做并行处理收集到

00:39:44.609 --> 00:39:48.789
不收集容器

00:39:47.079 --> 00:39:51.249
自己线程安全，并且可以管理

00:39:48.789 --> 00:39:53.529
线程安全为您服务，但显然

00:39:51.249 --> 00:39:55.630
有一个成本，我的意思是成本是

00:39:53.529 --> 00:39:57.430
真的很高，例如新兴

00:39:55.630 --> 00:40:00.190
树形地图非常

00:39:57.430 --> 00:40:03.940
昂贵的操作，但是很安全

00:40:00.190 --> 00:40:06.220
它会安全地定义

00:40:03.940 --> 00:40:08.680
所以两个有两个字符

00:40:06.220 --> 00:40:10.180
收集两个自定义方法

00:40:08.680 --> 00:40:12.099
容器之一是其中之一

00:40:10.180 --> 00:40:14.890
它们用于自定义地图，因为

00:40:12.099 --> 00:40:17.109
课程地图未实现Java 

00:40:14.890 --> 00:40:18.940
 util收集界面，但一切

00:40:17.109 --> 00:40:21.849
否则做或排队和设置，这

00:40:18.940 --> 00:40:25.299
全部实现集合

00:40:21.849 --> 00:40:28.869
界面等等，方法

00:40:25.299 --> 00:40:31.779
为您提供的将允许

00:40:28.869 --> 00:40:33.730
您要收集到一个集合看起来

00:40:31.779 --> 00:40:37.989
像这样是签名，但是

00:40:33.730 --> 00:40:39.849
但是参数类型看到的是

00:40:37.989 --> 00:40:46.900
被定义为必须

00:40:39.849 --> 00:40:49.660
是collection的子类型，并且and 

00:40:46.900 --> 00:40:51.400
返回的是一个收集器

00:40:49.660 --> 00:40:53.170
需要我拥有

00:40:51.400 --> 00:40:55.089
说了一些论点

00:40:53.170 --> 00:40:57.460
的类型参数

00:40:55.089 --> 00:41:00.190
收藏家的第一个是类型

00:40:57.460 --> 00:41:03.130
被收集的最后一个是

00:41:00.190 --> 00:41:04.690
这样收集的类型也是如此

00:41:03.130 --> 00:41:07.660
所以我的意思是通常对我们来说

00:41:04.690 --> 00:41:09.549
就像一个人和一个人的名单

00:41:07.660 --> 00:41:11.039
中间的一个是

00:41:09.549 --> 00:41:14.019
使用的中间类型

00:41:11.039 --> 00:41:16.119
内部内部

00:41:14.019 --> 00:41:17.619
收藏家那里有一个

00:41:16.119 --> 00:41:20.950
我没有告诉过你的额外舞台

00:41:17.619 --> 00:41:22.749
关于这一点发生在

00:41:20.950 --> 00:41:24.460
值被发射出来，所以叫做

00:41:22.749 --> 00:41:25.900
整理器，一旦所有值都具有

00:41:24.460 --> 00:41:27.610
被收集在一起的东西

00:41:25.900 --> 00:41:29.980
有时必须要做

00:41:27.610 --> 00:41:30.640
为了他们

00:41:29.980 --> 00:41:32.800
被发射

00:41:30.640 --> 00:41:34.600
最简单的例子

00:41:32.800 --> 00:41:36.460
立即想到的是，如果您

00:41:34.600 --> 00:41:38.770
如果您使用的是stringbuilder，则有一个

00:41:36.460 --> 00:41:39.820
内部建立一个字符串，但

00:41:38.770 --> 00:41:41.920
你实际上就是你想要的

00:41:39.820 --> 00:41:43.330
返回是一个字符串，所以完成是

00:41:41.920 --> 00:41:45.400
在那里，那将会做到

00:41:43.330 --> 00:41:46.990
会做你通常没有的工作

00:41:45.400 --> 00:41:48.820
担心那个中间

00:41:46.990 --> 00:41:50.020
类型参数，因为除非您

00:41:48.820 --> 00:41:52.510
写自己的收藏家不是

00:41:50.020 --> 00:41:55.480
通常很重要，所以我的原因

00:41:52.510 --> 00:41:57.550
布局就是方法

00:41:55.480 --> 00:41:59.530
对集合的定义是因为

00:41:57.550 --> 00:42:01.750
如果您在API中看到了

00:41:59.530 --> 00:42:04.090
如果有人还在看文档

00:42:01.750 --> 00:42:07.000
我当然是API文档

00:42:04.090 --> 00:42:09.220
老式的人，然后看起来

00:42:07.000 --> 00:42:12.280
险恶，但实际上很合适

00:42:09.220 --> 00:42:14.830
它确实适合在一起的

00:42:12.280 --> 00:42:16.600
使用两个集合的示例

00:42:14.830 --> 00:42:18.820
假设我们想不收集

00:42:16.600 --> 00:42:20.650
树图，但树设置为树

00:42:18.820 --> 00:42:24.490
设置只是一种设置，所以它

00:42:20.650 --> 00:42:26.950
实施收集工作

00:42:24.490 --> 00:42:28.870
 util收集界面，这里是什么

00:42:26.950 --> 00:42:32.470
我们正在做的就是我们正在做

00:42:28.870 --> 00:42:34.390
将要获得的一组命名为

00:42:32.470 --> 00:42:36.130
名称集，但我们希望对其进行排序

00:42:34.390 --> 00:42:37.960
我们想被创建排序如果

00:42:36.130 --> 00:42:40.030
把东西放到树上然后他们会

00:42:37.960 --> 00:42:41.770
按其自然顺序排序

00:42:40.030 --> 00:42:43.750
通常在字符串的情况下

00:42:41.770 --> 00:42:45.550
他们的字母顺序通常

00:42:43.750 --> 00:42:49.360
的东西，所以这段代码会给你

00:42:45.550 --> 00:42:51.240
背一组一组

00:42:49.360 --> 00:42:57.810
人员对象的名称和

00:42:51.240 --> 00:43:00.220
人们按字母顺序排序

00:42:57.810 --> 00:43:01.450
那是前两种类型的框架

00:43:00.220 --> 00:43:05.250
提供的容器和定制和

00:43:01.450 --> 00:43:08.680
自定义集合，第三个类型是

00:43:05.250 --> 00:43:11.350
分类图，这些是

00:43:08.680 --> 00:43:13.300
全部通过分组也通过分组

00:43:11.350 --> 00:43:15.580
按并发和和分组

00:43:13.300 --> 00:43:17.410
通过两者进行分区不是

00:43:15.580 --> 00:43:18.700
非常重要的分组依据是

00:43:17.410 --> 00:43:20.650
那真的是我们重要的

00:43:18.700 --> 00:43:22.240
有三种我们有简单的

00:43:20.650 --> 00:43:23.560
与下游或下游

00:43:22.240 --> 00:43:23.950
和地图工厂让我们看一下

00:43:23.560 --> 00:43:26.620
这些

00:43:23.950 --> 00:43:29.440
所以这里是用

00:43:26.620 --> 00:43:31.240
分类器的想法，这将使

00:43:29.440 --> 00:43:33.580
分类映射有点像

00:43:31.240 --> 00:43:35.650
映射，除了

00:43:33.580 --> 00:43:37.770
放在地图上的是我们的清单

00:43:35.650 --> 00:43:40.500
元素我们的清单

00:43:37.770 --> 00:43:42.150
我应该说大名单

00:43:40.500 --> 00:43:44.280
对应于每个分类键

00:43:42.150 --> 00:43:48.510
例如，如果您使用person get 

00:43:44.280 --> 00:43:50.640
城市作为分类器

00:43:48.510 --> 00:43:52.560
然后您会得到一张从城市到城市的地图

00:43:50.640 --> 00:43:54.330
与之相关的人的清单

00:43:52.560 --> 00:43:56.070
每个会联系每个人的人

00:43:54.330 --> 00:43:57.990
放着生活的人的城市

00:43:56.070 --> 00:43:59.370
在那个城市和代码的代码

00:43:57.990 --> 00:44:00.450
这样做看起来就像您看到的一样

00:43:59.370 --> 00:44:02.640
在底部

00:44:00.450 --> 00:44:04.770
人们得到流点击收藏家

00:44:02.640 --> 00:44:05.520
分组，这意味着什么

00:44:04.770 --> 00:44:08.460
我们要做的是

00:44:05.520 --> 00:44:11.100
将该函数应用于该方法

00:44:08.460 --> 00:44:12.660
人得到城市，我要申请

00:44:11.100 --> 00:44:14.550
面对每个人的对象

00:44:12.660 --> 00:44:16.350
通过，然后我们将去

00:44:14.550 --> 00:44:18.240
我们将使用结果作为关键

00:44:16.350 --> 00:44:19.680
我们将采取我们要

00:44:18.240 --> 00:44:21.360
拿人对象并将其添加到

00:44:19.680 --> 00:44:23.030
名单的人， 

00:44:21.360 --> 00:44:28.830
对应于此，所以这里有点

00:44:23.030 --> 00:44:31.290
他如何在一个

00:44:28.830 --> 00:44:33.020
动画，所以我们和Bill住在一起

00:44:31.290 --> 00:44:37.050
伦敦和艾米现在住在雅典

00:44:33.020 --> 00:44:39.870
他们正在四处寻找这些人

00:44:37.050 --> 00:44:42.570
账单，所以账单进来

00:44:39.870 --> 00:44:44.250
伦敦，所以他被投入

00:44:42.570 --> 00:44:47.730
放入人员对象列表

00:44:44.250 --> 00:44:50.490
与伦敦和艾米相关的进来

00:44:47.730 --> 00:44:52.740
艾米（Amy）前往并被添加到

00:44:50.490 --> 00:44:54.450
与他们相关的人

00:44:52.740 --> 00:44:56.220
雅典和约翰进来，有点

00:44:54.450 --> 00:44:58.050
显然乔安娜将被添加到

00:44:56.220 --> 00:45:00.660
帐单所在的清单，现在

00:44:58.050 --> 00:45:03.630
流已经精疲力尽，而我们

00:45:00.660 --> 00:45:08.670
得到了，我们得到了从城市到

00:45:03.630 --> 00:45:10.830
听人的名单，以便

00:45:08.670 --> 00:45:12.780
似乎很简单， 

00:45:10.830 --> 00:45:15.240
可能非常有用，我们将在

00:45:12.780 --> 00:45:17.430
这是非常有用的，但是

00:45:15.240 --> 00:45:18.900
有限，所以就像如果你不想那样

00:45:17.430 --> 00:45:20.130
每次都将它们放入列表

00:45:18.900 --> 00:45:21.840
假设你想做更多的事情

00:45:20.130 --> 00:45:24.690
和他们在一起，我曾经做过的一件事

00:45:21.840 --> 00:45:26.910
说了我没说过的

00:45:24.690 --> 00:45:30.660
收藏家API的优点

00:45:26.910 --> 00:45:32.460
是非常可组合的，所以您可以

00:45:30.660 --> 00:45:34.380
我们将看看你如何适应

00:45:32.460 --> 00:45:36.210
不同的收藏家一起建立

00:45:34.380 --> 00:45:39.350
相当复杂相当复杂

00:45:36.210 --> 00:45:42.510
并精心制作处理流程

00:45:39.350 --> 00:45:45.780
通过将它们放在一起，我们将看到

00:45:42.510 --> 00:45:49.130
这是怎么工作的这是这个

00:45:45.780 --> 00:45:51.180
假设您想开始

00:45:49.130 --> 00:45:53.040
假设你想

00:45:51.180 --> 00:45:54.300
做出除清单以外的内容

00:45:53.040 --> 00:45:56.490
你想做到，也许你想

00:45:54.300 --> 00:45:59.430
做一个集，而不是好有这个

00:45:56.490 --> 00:46:01.290
下游收集器的想法

00:45:59.430 --> 00:46:03.480
下游收集器是需要

00:46:01.290 --> 00:46:07.109
一直以来的价值

00:46:03.480 --> 00:46:09.780
从收集器发射出来的

00:46:07.109 --> 00:46:12.990
在同一个收集器中做一些

00:46:09.780 --> 00:46:16.200
对它们进行进一步的工作，使您有年龄

00:46:12.990 --> 00:46:18.390
收集工作的片段，所以如果您

00:46:16.200 --> 00:46:19.710
分组的重载

00:46:18.390 --> 00:46:21.869
这需要一个分类器和

00:46:19.710 --> 00:46:23.490
下游收集器使用分类器

00:46:21.869 --> 00:46:25.380
进行分类的功能

00:46:23.490 --> 00:46:26.940
映射到一个容器中

00:46:25.380 --> 00:46:29.579
由下游收集者定义

00:46:26.940 --> 00:46:31.109
下一阶段正在进行，所以如此

00:46:29.579 --> 00:46:32.730
放置在地图中的值是容器

00:46:31.109 --> 00:46:34.230
元素和一个容器

00:46:32.730 --> 00:46:37.680
对应于每个分类键

00:46:34.230 --> 00:46:40.170
所以如果我们想找一个人

00:46:37.680 --> 00:46:43.079
而不是我们会列出的人

00:46:40.170 --> 00:46:45.119
将使用我们将使用下游

00:46:43.079 --> 00:46:47.250
收藏家设置记得设置是一个

00:46:45.119 --> 00:46:50.460
收藏家的工厂方法

00:46:47.250 --> 00:46:52.079
这为您创建了一个收集器

00:46:50.460 --> 00:46:54.210
所以就像有收藏家一样

00:46:52.079 --> 00:46:56.400
嵌入此收集器的内部

00:46:54.210 --> 00:46:57.660
这是图，您看到了吗

00:46:56.400 --> 00:46:59.970
下游收集器实际上是

00:46:57.660 --> 00:47:01.980
嵌入此外部的内部

00:46:59.970 --> 00:47:04.470
收藏家和他的情况

00:47:01.980 --> 00:47:07.680
工作法案进来，他去了， 

00:47:04.470 --> 00:47:10.470
他和他变得手足无措

00:47:07.680 --> 00:47:12.180
不像以前那样不是一个列表

00:47:10.470 --> 00:47:14.549
这是自动的

00:47:12.180 --> 00:47:16.650
自动默认，但无论如何

00:47:14.549 --> 00:47:19.230
放入已定义的任何容器中

00:47:16.650 --> 00:47:21.150
由下游收集器和

00:47:19.230 --> 00:47:23.130
在这种情况下，要进行设置，以便您可以看到

00:47:21.150 --> 00:47:24.900
这些就像小小的版本

00:47:23.130 --> 00:47:28.109
我开始的设置收集器

00:47:24.900 --> 00:47:30.780
然后再然后再以

00:47:28.109 --> 00:47:34.290
他们其余的人叫伊恩和

00:47:30.780 --> 00:47:38.250
约翰，所以实际上你可能会说得很好

00:47:34.290 --> 00:47:41.069
这与到的关系如何

00:47:38.250 --> 00:47:44.400
默认的只是剪辑

00:47:41.069 --> 00:47:46.859
到列表中，答案是

00:47:44.400 --> 00:47:48.690
完全相同，默认值是

00:47:46.859 --> 00:47:50.700
完全一样

00:47:48.690 --> 00:47:52.470
除了没有设置

00:47:50.700 --> 00:47:54.299
嵌入了收集器，但是它有

00:47:52.470 --> 00:47:56.790
嵌入其中的两个列表收集器

00:47:54.299 --> 00:47:58.410
所以它的工作原理与

00:47:56.790 --> 00:48:01.170
他们显然以为

00:47:58.410 --> 00:48:02.309
方便您默认但

00:48:01.170 --> 00:48:02.630
您不必考虑它在哪里

00:48:02.309 --> 00:48:05.029
原为

00:48:02.630 --> 00:48:11.559
去，那就是你的方式

00:48:05.029 --> 00:48:16.089
嗯嗯，所以最后这些

00:48:11.559 --> 00:48:19.549
在这部分有弹性

00:48:16.089 --> 00:48:23.539
有一个收集器

00:48:19.549 --> 00:48:25.609
在处理值之前起作用

00:48:23.539 --> 00:48:27.769
你可能会想为什么我要

00:48:25.609 --> 00:48:29.450
那是不是听起来像一个

00:48:27.769 --> 00:48:32.569
非常明智的事情，因为之后

00:48:29.450 --> 00:48:34.819
最常见的一种

00:48:32.569 --> 00:48:37.880
操作中间操作

00:48:34.819 --> 00:48:40.759
流是地图操作权

00:48:37.880 --> 00:48:43.099
因此，如果哪一个功能适用于每个

00:48:40.759 --> 00:48:44.480
值，所以如果可以的话，如果我可以申请的话

00:48:43.099 --> 00:48:46.190
每个值的功能

00:48:44.480 --> 00:48:48.529
顺流而下我为什么要

00:48:46.190 --> 00:48:53.150
收集器将要做的确切

00:48:48.529 --> 00:48:55.250
同样的事情，也许也许你

00:48:53.150 --> 00:48:57.230
可以思考为什么我们要

00:48:55.250 --> 00:49:00.519
鉴于我刚才所说的

00:48:57.230 --> 00:49:00.519
关于下游的收集者

00:49:03.490 --> 00:49:06.980
绝对你可能需要一张地图

00:49:05.390 --> 00:49:08.630
下游收集器，因为你

00:49:06.980 --> 00:49:10.339
可能想做的是在第一次之后

00:49:08.630 --> 00:49:12.920
您可能会进行收集

00:49:10.339 --> 00:49:14.690
想要对进行一些处理

00:49:12.920 --> 00:49:16.279
在你面前出现的元素

00:49:14.690 --> 00:49:17.839
再次收集它们，我们将看到

00:49:16.279 --> 00:49:19.250
这样的例子是真的

00:49:17.839 --> 00:49:21.079
您想这样做的共同点

00:49:19.250 --> 00:49:22.190
假设你想要例如

00:49:21.079 --> 00:49:25.000
对某一片感兴趣

00:49:22.190 --> 00:49:27.170
远离我们价值的信息

00:49:25.000 --> 00:49:29.240
但你也想拥有整个

00:49:27.170 --> 00:49:30.680
以及后续处理的价值

00:49:29.240 --> 00:49:32.690
你会做的是你会做

00:49:30.680 --> 00:49:34.640
对该首字母进行分类

00:49:32.690 --> 00:49:36.589
您通过价值传递的一块

00:49:34.640 --> 00:49:38.750
然后你会提取其他任何东西

00:49:36.589 --> 00:49:40.940
以后需要的就是这样

00:49:38.750 --> 00:49:43.670
实际上非常有用，我的意思是如果我做

00:49:40.940 --> 00:49:45.500
如果我把它放进去的话

00:49:43.670 --> 00:49:48.559
这种方式看起来很愚蠢

00:49:45.500 --> 00:49:50.329
因为您可以获得与

00:49:48.559 --> 00:49:52.339
这只是通过将地图操作

00:49:50.329 --> 00:49:54.589
溪流怎么办，但我是这样做的

00:49:52.339 --> 00:49:55.970
对于动画，因为动画

00:49:54.589 --> 00:49:58.339
如果我这样做真的很复杂

00:49:55.970 --> 00:50:00.230
还有别的，然后我告诉你

00:49:58.339 --> 00:50:01.759
我会给你展示更现实的例子

00:50:00.230 --> 00:50:04.069
在这里，这是一个映射

00:50:01.759 --> 00:50:06.769
运算符，它具有下游

00:50:04.069 --> 00:50:09.440
收藏家是由它的外观设置

00:50:06.769 --> 00:50:12.049
映射是人获取城市， 

00:50:09.440 --> 00:50:15.079
设置下游运算符

00:50:12.049 --> 00:50:16.250
我们要去这里是一组

00:50:15.079 --> 00:50:21.140
城市的

00:50:16.250 --> 00:50:22.400
人们住在那里，显然你

00:50:21.140 --> 00:50:25.100
可以在那里做同样的事情

00:50:22.400 --> 00:50:27.440
只是将人映射到城市中

00:50:25.100 --> 00:50:29.480
流，但在下一个示例中

00:50:27.440 --> 00:50:30.710
我告诉你，你不能

00:50:29.480 --> 00:50:32.740
不能得到相同的东西，那是

00:50:30.710 --> 00:50:37.610
那是动画的例子，但是哦

00:50:32.740 --> 00:50:39.260
出现问题了，那是

00:50:37.610 --> 00:50:41.120
好吧，仅此而已

00:50:39.260 --> 00:50:45.290
感觉是一个更明智的例子

00:50:41.120 --> 00:50:48.080
所以在这里我们可能有

00:50:45.290 --> 00:50:50.000
不是很明智，我们在哪里

00:50:48.080 --> 00:50:54.830
要按城市分组

00:50:50.000 --> 00:51:00.230
然后我们要映射的名称

00:50:54.830 --> 00:51:01.580
我们会后悔的人

00:51:00.230 --> 00:51:03.530
我们要映射那个人

00:51:01.580 --> 00:51:05.000
人反对他们的名字， 

00:51:03.530 --> 00:51:06.350
然后我们将它们收集在

00:51:05.000 --> 00:51:08.090
下游收集器

00:51:06.350 --> 00:51:10.910
加入所以我们将从中得到什么

00:51:08.090 --> 00:51:12.440
这是名称的串联

00:51:10.910 --> 00:51:15.230
住在每个城市的所有人

00:51:12.440 --> 00:51:16.760
伦敦将有约翰和比尔

00:51:15.230 --> 00:51:19.100
无论过去是什么，都可以削减

00:51:16.760 --> 00:51:20.660
一起分类，有一个

00:51:19.100 --> 00:51:24.530
这些便利中有大量

00:51:20.660 --> 00:51:27.020
这些不同的收藏家中

00:51:24.530 --> 00:51:31.910
与其他操作相对应

00:51:27.020 --> 00:51:33.590
在中间

00:51:31.910 --> 00:51:35.660
像映射这样的操作

00:51:33.590 --> 00:51:38.980
对应于地图中间

00:51:35.660 --> 00:51:42.710
操作和很多很多

00:51:38.980 --> 00:51:45.170
对应的工厂收藏家

00:51:42.710 --> 00:51:46.640
您想要的终端操作

00:51:45.170 --> 00:51:48.830
您想纳入收藏家

00:51:46.640 --> 00:51:50.390
以后，例如，您可能会有所不同

00:51:48.830 --> 00:51:53.690
您可以计算插播广告的数量

00:51:50.390 --> 00:51:55.160
元素就可以了

00:51:53.690 --> 00:51:57.050
您想要下游收集器

00:51:55.160 --> 00:51:59.120
可以做同样的事情

00:51:57.050 --> 00:52:01.130
的计数工厂方法

00:51:59.120 --> 00:52:03.080
收藏家类，与Max和

00:52:01.130 --> 00:52:04.790
最小，这将为您带来最大的和

00:52:03.080 --> 00:52:06.620
和分钟，这些是这些

00:52:04.790 --> 00:52:08.900
方法做完全一样的事情，但是

00:52:06.620 --> 00:52:10.670
你可以把它们放入你可以使用它们

00:52:08.900 --> 00:52:14.630
创建可以使用的收集器

00:52:10.670 --> 00:52:17.090
您可以用于下游收集器

00:52:14.630 --> 00:52:19.010
一些平均摘要统计摘要

00:52:17.090 --> 00:52:21.470
统计信息给您总和计数

00:52:19.010 --> 00:52:23.450
最小，最大和平均值

00:52:21.470 --> 00:52:25.190
所以这是一种有用的

00:52:23.450 --> 00:52:27.920
对象，你可以再次得到

00:52:25.190 --> 00:52:30.400
方式，甚至减少

00:52:27.920 --> 00:52:30.400
可以做到

00:52:30.579 --> 00:52:38.660
好，所以我想谈的最后一件事

00:52:36.890 --> 00:52:40.940
大约在休息之前

00:52:38.660 --> 00:52:44.480
我们只是到了一个小时

00:52:40.940 --> 00:52:46.460
并发收集，所以并发

00:52:44.480 --> 00:52:49.549
线程安全我说过线程安全是

00:52:46.460 --> 00:52:51.710
由框架保证，即使对于非

00:52:49.549 --> 00:52:54.019
线程安全组件，所以我的意思是

00:52:51.710 --> 00:52:57.769
这是一个很大的优点，因为

00:52:54.019 --> 00:52:59.539
很多时候，如果你在写

00:52:57.769 --> 00:53:03.259
您的代码，因此它将是并行的

00:52:59.539 --> 00:53:04.309
准备好了，那么你原则上不知道

00:53:03.259 --> 00:53:06.500
你不知道是否会

00:53:04.309 --> 00:53:08.450
从现在开始你不知道你是否

00:53:06.500 --> 00:53:10.970
代码将要执行

00:53:08.450 --> 00:53:12.440
顺序或并行

00:53:10.970 --> 00:53:14.750
它可能会被执行

00:53:12.440 --> 00:53:17.210
连续一段时间来

00:53:14.750 --> 00:53:18.890
正确开始没有多大意义

00:53:17.210 --> 00:53:20.299
开始编写两个并发集合

00:53:18.890 --> 00:53:21.740
但是你有一个更大的

00:53:20.299 --> 00:53:24.890
很大的开销只是因为他们

00:53:21.740 --> 00:53:26.750
线程安全的，所以您想使用非

00:53:24.890 --> 00:53:28.430
安全非抛出安全集合

00:53:26.750 --> 00:53:31.910
将继续使用哈希集和

00:53:28.430 --> 00:53:34.430
哈希图和所有类似的东西

00:53:31.910 --> 00:53:37.009
这是一大优点

00:53:34.430 --> 00:53:38.900
框架说我不在乎

00:53:37.009 --> 00:53:39.559
你是什​​么时候改变的

00:53:38.900 --> 00:53:40.579
发生

00:53:39.559 --> 00:53:44.029
你会顺序和并行

00:53:40.579 --> 00:53:45.440
处决你不会，你不会

00:53:44.029 --> 00:53:47.619
不用担心我会照顾的

00:53:45.440 --> 00:53:50.720
所以我会照顾线程安全

00:53:47.619 --> 00:53:52.039
无论是顺序的还是连续的

00:53:50.720 --> 00:53:55.009
与此平行，这实际上是

00:53:52.039 --> 00:53:57.589
几年来确实是一大笔红利

00:53:55.009 --> 00:54:00.380
作为技术来

00:53:57.589 --> 00:54:01.759
并行化代码会变得更好

00:54:00.380 --> 00:54:04.039
为此我真的很感激，因为你

00:54:01.759 --> 00:54:05.660
因为越来越多的你只是去

00:54:04.039 --> 00:54:08.599
得到并行的好处

00:54:05.660 --> 00:54:10.609
免费执行或不完全执行

00:54:08.599 --> 00:54:12.500
免费，但真的很便宜

00:54:10.609 --> 00:54:14.059
要做的就是将流更改为并行

00:54:12.500 --> 00:54:16.430
流，一切仍将正常

00:54:14.059 --> 00:54:19.549
完美，这就是相当

00:54:16.430 --> 00:54:22.700
大加，但在某些情况下，您实际上

00:54:19.549 --> 00:54:24.410
知道你是内在的

00:54:22.700 --> 00:54:27.109
必须使用线程安全的容器

00:54:24.410 --> 00:54:30.799
从一开始就已经正确，所以您

00:54:27.109 --> 00:54:33.619
所以也许你正在收集到一个

00:54:30.799 --> 00:54:35.480
收集到并发映射中

00:54:33.619 --> 00:54:37.789
已经被其他人使用

00:54:35.480 --> 00:54:40.160
其他线程，因此需要管理

00:54:37.789 --> 00:54:42.230
它自己的线程安全性，因此在这种情况下

00:54:40.160 --> 00:54:45.650
你是

00:54:42.230 --> 00:54:47.359
该框架仍将有效

00:54:45.650 --> 00:54:49.940
如果您使用分组方式，例如

00:54:47.359 --> 00:54:51.950
或映射它仍然可以正常工作，但是

00:54:49.940 --> 00:54:54.770
会增加线程安全的开销

00:54:51.950 --> 00:54:56.000
执行到你的

00:54:54.770 --> 00:54:57.589
收藏和您的收藏已经

00:54:56.000 --> 00:54:59.240
线程安全的，所以现在您将成为

00:54:57.589 --> 00:55:01.579
两次为线程安全付费

00:54:59.240 --> 00:55:04.700
这似乎是一笔可怜的交易， 

00:55:01.579 --> 00:55:07.700
所以按地图分组

00:55:04.700 --> 00:55:09.619
这些都有这些额外的过载

00:55:07.700 --> 00:55:11.839
允许，允许

00:55:09.619 --> 00:55:13.609
并发性的每个重载映射和

00:55:11.839 --> 00:55:16.700
分组具有双重两个并发

00:55:13.609 --> 00:55:19.940
通过并发和进行映射和分组

00:55:16.700 --> 00:55:22.670
这样，您就不必

00:55:19.940 --> 00:55:23.780
如果您已经知道自己的付款，请支付两次

00:55:22.670 --> 00:55:26.720
集合将是线程安全的

00:55:23.780 --> 00:55:30.829
然后你可以然后你可以拿走

00:55:26.720 --> 00:55:33.500
你可以利用那好吧

00:55:30.829 --> 00:55:36.380
对，所以我们已经达到了930分

00:55:33.500 --> 00:55:40.730
时间甚至考虑到

00:55:36.380 --> 00:55:42.740
电缆有问题，所以我就这样

00:55:40.730 --> 00:55:43.940
知道很长一段时间是两个

00:55:42.740 --> 00:55:45.950
坐了很长时间

00:55:43.940 --> 00:55:47.810
通过某人和你聊天

00:55:45.950 --> 00:55:49.310
所以我想休息五分钟

00:55:47.810 --> 00:55:50.930
虽然停下来之前还是个好主意

00:55:49.310 --> 00:55:53.770
首先有什么问题吗

00:55:50.930 --> 00:55:53.770
一半是

00:56:25.590 --> 00:56:29.740
对，所以问题很好

00:56:28.120 --> 00:56:32.470
你知道你在集合中的位置

00:56:29.740 --> 00:56:33.640
假设你想你想

00:56:32.470 --> 00:56:36.180
对第三个元素做某事

00:56:33.640 --> 00:56:38.410
如果您开始考虑流

00:56:36.180 --> 00:56:39.970
所以里面有些办法

00:56:38.410 --> 00:56:41.440
您可以做到这一点，但主要是

00:56:39.970 --> 00:56:44.740
他们实际上涉及附加

00:56:41.440 --> 00:56:46.450
将索引值附加到该值

00:56:44.740 --> 00:56:49.120
在它开始流之前，如果

00:56:46.450 --> 00:56:51.190
你，如果你觉得这听起来很粗糙

00:56:49.120 --> 00:56:53.260
而且你不明白为什么流

00:56:51.190 --> 00:56:56.290
 API不提供这种考虑

00:56:53.260 --> 00:56:58.150
试图用

00:56:56.290 --> 00:57:00.330
正在执行的收集

00:56:58.150 --> 00:57:02.410
它正在并行处理

00:57:00.330 --> 00:57:05.380
假设我有一百万

00:57:02.410 --> 00:57:09.490
元素数组，我想把它切碎

00:57:05.380 --> 00:57:12.460
碎成碎片我和我，现在你告诉我

00:57:09.490 --> 00:57:15.130
您想如何知道总数

00:57:12.460 --> 00:57:16.750
排列每个要发生的元素

00:57:15.130 --> 00:57:19.510
有一些方法可以做到，所以有一个

00:57:16.750 --> 00:57:20.770
提供您所需的巨大开销

00:57:19.510 --> 00:57:22.210
必须提供初始值

00:57:20.770 --> 00:57:24.700
其实我会做一些相当

00:57:22.210 --> 00:57:27.340
就像例子中的

00:57:24.700 --> 00:57:29.040
在最后的示例中，但您会看到

00:57:27.340 --> 00:57:31.420
有开销， 

00:57:29.040 --> 00:57:33.340
因为这不是人们的事

00:57:31.420 --> 00:57:34.630
最常想做的，因为

00:57:33.340 --> 00:57:36.520
用并行很难做到

00:57:34.630 --> 00:57:41.130
处理他们不提供它

00:57:36.520 --> 00:57:41.130
盒子是

00:57:46.140 --> 00:57:49.140
抱歉

00:57:56.960 --> 00:58:02.370
好吧，你可以运行它们

00:57:59.400 --> 00:58:04.530
通过一个过滤器可能是

00:58:02.370 --> 00:58:06.240
那就是通用解决方案

00:58:04.530 --> 00:58:08.130
那个流很抱歉的问题是

00:58:06.240 --> 00:58:11.040
您如何验证它们和答案

00:58:08.130 --> 00:58:12.900
是一种通用的解决方案

00:58:11.040 --> 00:58:14.640
流API提供的是过滤器

00:58:12.900 --> 00:58:18.500
过滤操作确实没有

00:58:14.640 --> 00:58:22.860
任何其他可以让您

00:58:18.500 --> 00:58:24.510
是的，我想是的，我的意思是

00:58:22.860 --> 00:58:28.160
我想我选择了您的答案

00:58:24.510 --> 00:58:28.160
是的

00:58:40.980 --> 00:58:45.430
所以问题是如果你想要

00:58:43.870 --> 00:58:46.780
做事情本质上是想

00:58:45.430 --> 00:58:50.800
为流元素做两次

00:58:46.780 --> 00:58:52.780
这基本上是一个II 

00:58:50.800 --> 00:58:55.090
这是这个的设计目标

00:58:52.780 --> 00:58:56.650
流设计师，因此您无法完成大部分工作

00:58:55.090 --> 00:58:58.660
那些东西有扩展

00:58:56.650 --> 00:59:00.090
流库，我看看是否可以

00:58:58.660 --> 00:59:02.230
在结束之前找到一些参考

00:59:00.090 --> 00:59:05.560
人们实际上已经添加了新的

00:59:02.230 --> 00:59:07.180
我没有提到的库

00:59:05.560 --> 00:59:08.260
这可以帮助您做到这一点，但这是

00:59:07.180 --> 00:59:12.040
不属于它，不属于

00:59:08.260 --> 00:59:14.370
基本流API好，最后一个，然后

00:59:12.040 --> 00:59:14.370
我们会休息

00:59:31.440 --> 00:59:34.619
这个

00:59:35.130 --> 00:59:40.570
我正在使用下游设备，正在使用

00:59:38.110 --> 00:59:42.850
下游收集器，我正在使用

00:59:40.570 --> 00:59:44.890
下游收集器在这里

00:59:42.850 --> 00:59:56.920
与我以前列出的方式相同

00:59:44.890 --> 00:59:59.470
第一个例子，对不起，我有

00:59:56.920 --> 01:00:01.990
好吧，所以是的，有错别字

00:59:59.470 --> 01:00:04.570
是的，对不起，谢谢你的投入

01:00:01.990 --> 01:00:07.930
出去休息五分钟

01:00:04.570 --> 01:00:09.100
请回来，或者如果你不去的话

01:00:07.930 --> 01:00:12.030
不想回来只是打

01:00:09.100 --> 01:00:12.030
我手上的绿色按钮

01:00:30.430 --> 01:00:33.430
耶稣

01:00:38.770 --> 01:00:55.280
对不起，我把它们放在幻灯片上，不，我

01:00:53.690 --> 01:01:02.690
知道我从来没有做过那个

01:00:55.280 --> 01:01:10.190
他可能是斯图尔特·马克思谢谢谢谢

01:01:02.690 --> 01:01:11.900
你很好，学生也很好

01:01:10.190 --> 01:01:14.079
对不起，我只是说斯图尔特很好

01:01:11.900 --> 01:01:16.130
然后也是我的

01:01:14.079 --> 01:01:18.670
是的，请注意他的演讲

01:01:16.130 --> 01:01:18.670
肯定的

01:01:44.590 --> 01:01:52.500
所以你不会得到

01:01:47.400 --> 01:01:52.500
超过生产的身份

01:09:35.149 --> 01:09:37.749
不

01:09:47.549 --> 01:09:50.540
那个更好吗

01:10:19.580 --> 01:10:27.900
没错，树上的东西你好

01:10:22.140 --> 01:10:30.630
但这是有效的是的是的是的

01:10:27.900 --> 01:10:33.750
是的，不，我认为还可以，很酷

01:10:30.630 --> 01:10:35.670
好的，是的，所以你要去做这项工作

01:10:33.750 --> 01:10:37.440
猫头鹰哦，让我们让我们有一个

01:10:35.670 --> 01:10:39.330
例子，所以第一个例子

01:10:37.440 --> 01:10:40.710
选择是我们要对人进行分类

01:10:39.330 --> 01:10:43.380
按年龄，因为那是正确的

01:10:40.710 --> 01:10:46.980
年龄很简单的人

01:10:43.380 --> 01:10:49.410
这取决于你，所以我们怎么办

01:10:46.980 --> 01:10:53.610
按年龄分类他们为什么要

01:10:49.410 --> 01:11:00.920
想从整数映射到人哦

01:10:53.610 --> 01:11:00.920
是按年龄划分的整数

01:11:01.190 --> 01:11:09.180
年龄相等的人，我给你

01:11:07.140 --> 01:11:14.840
线索人点流是因为

01:11:09.180 --> 01:11:14.840
他们都将以这种方式开始

01:11:15.350 --> 01:11:22.380
哇

01:11:16.590 --> 01:11:24.750
拜托，是的，这是一个好主意

01:11:22.380 --> 01:11:27.660
谢谢，我不是很擅长

01:11:24.750 --> 01:11:29.820
东西，所以我通常通常是这样

01:11:27.660 --> 01:11:32.940
不是，这真的有点

01:11:29.820 --> 01:11:34.320
让你去做工作，因为喜欢

01:11:32.940 --> 01:11:34.710
然后你会告诉我我要去哪里

01:11:34.320 --> 01:11:43.500
错误

01:11:34.710 --> 01:11:49.910
我希望谢谢你不要点击它

01:11:43.500 --> 01:11:49.910
也许博士。点收集分组依据

01:11:56.469 --> 01:12:06.340
对不起，人双不能继续得到它

01:12:00.910 --> 01:12:09.820
年龄合适吧，看看是否可行

01:12:06.340 --> 01:12:12.940
哦，可能是做某事的主意

01:12:09.820 --> 01:12:21.880
它的输出结果就是

01:12:12.940 --> 01:12:25.360
年龄还可以，所以我们在那里有一张地图

01:12:21.880 --> 01:12:28.510
 33到包含Bill和Eric的列表

01:12:25.360 --> 01:12:33.000
 21对艾米（Amy）和42对约翰（John） 

01:12:28.510 --> 01:12:36.100
是的，数据是最酷的

01:12:33.000 --> 01:12:41.980
好吧，所以我们需要选择

01:12:36.100 --> 01:12:43.719
有点难一点

01:12:41.980 --> 01:12:48.969
好吧，我再给你一个

01:12:43.719 --> 01:12:52.530
按年龄命名，因此将成为一张地图

01:12:48.969 --> 01:12:52.530
好吧，你应该真的告诉我

01:12:57.430 --> 01:13:01.480
整数2字符串列表

01:13:07.790 --> 01:13:15.610
年龄流的名字

01:13:45.410 --> 01:13:50.450
所以如果我们去下游收集

01:13:47.720 --> 01:13:51.230
他们我们已经正确分组，所以

01:13:50.450 --> 01:13:55.610
上升将是什么

01:13:51.230 --> 01:14:05.480
分类喜欢它的人

01:13:55.610 --> 01:14:06.680
年龄又是不是很抱歉映射还可以

01:14:05.480 --> 01:14:09.460
因为有什么好想做的

01:14:06.680 --> 01:14:09.460
一些更多的处理

01:14:15.010 --> 01:14:18.090
好哒。谢谢你们

01:14:19.219 --> 01:14:22.219
没有

01:14:31.229 --> 01:14:40.479
好的，对不起，但这不只是一个

01:14:39.129 --> 01:14:42.280
缺少了肢体综合症

01:14:40.479 --> 01:14:46.179
抱怨这样的东西映射

01:14:42.280 --> 01:14:49.300
想要没事吧，是的， 

01:14:46.179 --> 01:14:54.749
没有默认值，没有默认值

01:14:49.300 --> 01:14:59.050
我们要对列表说的地图

01:14:54.749 --> 01:15:05.229
那更好，为什么没有默认值

01:14:59.050 --> 01:15:07.449
好吧，因为他们没有想到那里

01:15:05.229 --> 01:15:14.050
将是一个普通的情况， 

01:15:07.449 --> 01:15:16.539
为了这个权利，所以我们有名字

01:15:14.050 --> 01:15:17.949
出来就是那样看起来

01:15:16.539 --> 01:15:19.689
实际上看起来非常像

01:15:17.949 --> 01:15:21.999
像第一个一样，但在第一种情况下

01:15:19.689 --> 01:15:23.590
对不起，我应该说第一个

01:15:21.999 --> 01:15:27.639
我们有点欺骗了两个字符串方法

01:15:23.590 --> 01:15:29.499
的人会打印人的名字

01:15:27.639 --> 01:15:30.729
以逗号分隔，这就是你

01:15:29.499 --> 01:15:32.379
得到的就是你得到的

01:15:30.729 --> 01:15:33.309
第一行第二行

01:15:32.379 --> 01:15:35.649
得到了他们的真名

01:15:33.309 --> 01:15:37.090
也许我应该也许我应该也许我

01:15:35.649 --> 01:15:44.159
应该使两个字符串方法

01:15:37.090 --> 01:15:44.159
多一点看起来更明显是的

01:15:56.309 --> 01:16:01.119
是的，这就是为什么

01:15:59.559 --> 01:16:02.710
你想要马特，为什么要下游

01:16:01.119 --> 01:16:04.420
像小睡的收藏家都没有用

01:16:02.710 --> 01:16:06.250
在他们自己，因为你因为什么

01:16:04.420 --> 01:16:10.389
您已经完成的就是您想要的是我们

01:16:06.250 --> 01:16:13.360
想得到我们想要的地图

01:16:10.389 --> 01:16:16.449
不好意思，一个人想要一张年龄的地图

01:16:13.360 --> 01:16:18.940
从一个属性的一个到一个

01:16:16.449 --> 01:16:20.739
一个人到另一个财产，而你不

01:16:18.940 --> 01:16:23.980
实际工作，但您需要保持

01:16:20.739 --> 01:16:25.719
整个第一个人对象

01:16:23.980 --> 01:16:27.760
过去的第一个分类，以便

01:16:25.719 --> 01:16:30.429
您可以稍后使用它来提取

01:16:27.760 --> 01:16:31.889
我可能在正确的地方第二个

01:16:30.429 --> 01:16:41.099
真的很不好解释

01:16:31.889 --> 01:16:43.630
好吧，让我们有任何想法好吧，我有两个

01:16:41.099 --> 01:16:47.559
对，所以我们走吧，让我们来

01:16:43.630 --> 01:16:50.020
有点难，因为这是一个人口

01:16:47.559 --> 01:16:54.460
按年龄，还不算太难

01:16:50.020 --> 01:17:00.059
人口的年龄，这将是

01:16:54.460 --> 01:17:00.059
来自的地图

01:17:03.290 --> 01:17:10.430
我是说我是对不起好吧，那不是

01:17:08.000 --> 01:17:13.430
我很清楚我的年龄

01:17:10.430 --> 01:17:18.140
意思是让我们单击让我们从中获取地图

01:17:13.430 --> 01:17:22.910
每个年龄段的人数

01:17:18.140 --> 01:17:26.150
那个年龄的双关语很好

01:17:22.910 --> 01:17:28.820
认为很长很对

01:17:26.150 --> 01:17:30.710
因为好吧，我们将看到我的意思是

01:17:28.820 --> 01:17:33.470
我可以把它留在那里，然后我们得到

01:17:30.710 --> 01:17:35.930
一个非常令人困惑的编译错误，但是

01:17:33.470 --> 01:17:37.850
因为它实际上是流

01:17:35.930 --> 01:17:40.070
来自流的编译错误和

01:17:37.850 --> 01:17:43.010
并非总是那么容易

01:17:40.070 --> 01:17:45.200
实际上不是那么容易构建

01:17:43.010 --> 01:17:46.430
正确输入类型会有所帮助，但这是

01:17:45.200 --> 01:17:48.830
将会很长，因为我们

01:17:46.430 --> 01:17:51.500
需要做的，因为我们不

01:17:48.830 --> 01:17:54.200
知道其中有多少可能没问题

01:17:51.500 --> 01:17:56.180
人口的年龄，您会看到

01:17:54.200 --> 01:18:02.270
看到你会看到我们如何得到那个

01:17:56.180 --> 01:18:04.360
价值，因为人们不会流所有

01:18:02.270 --> 01:18:04.360
对

01:18:06.820 --> 01:18:15.930
按现在的工厂分组

01:18:24.250 --> 01:18:38.630
抱歉，我有个喃喃自语的人，年龄还可以

01:18:34.130 --> 01:18:39.679
而我们和您希望您只想

01:18:38.630 --> 01:18:41.540
算是他们就在那里

01:18:39.679 --> 01:18:46.159
是的，这看起来就在那里

01:18:41.540 --> 01:18:48.949
我怎么算他们有一个

01:18:46.159 --> 01:18:51.409
计数收藏家不是她还是黏土

01:18:48.949 --> 01:18:53.480
我们谈论过会计收集员，但是

01:18:51.409 --> 01:18:56.989
实际上这是一种工厂方法，称为

01:18:53.480 --> 01:18:58.310
计算哪个产生哪个

01:18:56.989 --> 01:19:02.870
产生一个没有

01:18:58.310 --> 01:19:05.719
按年龄命名好人口，好吧

01:19:02.870 --> 01:19:09.550
只是检查它是否正常，所以

01:19:05.719 --> 01:19:11.000
我们有33我们有两个人

01:19:09.550 --> 01:19:14.770
二十一个我们有一个人

01:19:11.000 --> 01:19:14.770
四十二个，我们只有一个人

01:19:30.340 --> 01:19:36.790
所以我感动了对不起，对不起，随身携带

01:19:34.670 --> 01:19:36.790
上

01:19:43.420 --> 01:19:50.540
当然可以，所以你可以做什么

01:19:46.460 --> 01:19:51.950
你可以提供你可以

01:19:50.540 --> 01:19:53.810
实际上我做的不只是我的平均水平

01:19:51.950 --> 01:19:58.430
表示您绝对可以做到，但是

01:19:53.810 --> 01:20:01.160
你可以用在

01:19:58.430 --> 01:20:02.390
汇总统计信息将为您提供

01:20:01.160 --> 01:20:03.500
这将为您带来很多

01:20:02.390 --> 01:20:07.580
其他信息

01:20:03.500 --> 01:20:20.260
摘要统计数据给您

01:20:07.580 --> 01:20:23.860
你，我真的需要一个遥控器

01:20:20.260 --> 01:20:28.160
一些统计数据可以让您

01:20:23.860 --> 01:20:30.170
将平均最小值与最小值相加

01:20:28.160 --> 01:20:31.700
以及最大，但如果您只是想

01:20:30.170 --> 01:20:32.900
让我们看看让我们看看

01:20:31.700 --> 01:20:37.280
如果我们只想得到就会发生

01:20:32.900 --> 01:20:43.160
平均的结果是相当

01:20:37.280 --> 01:20:45.110
很好，那不是很好吗

01:20:43.160 --> 01:20:48.739
现在，让我们来定义

01:20:45.110 --> 01:20:52.960
这个问题按城市的平均年龄还可以

01:20:48.739 --> 01:20:58.750
各城市的平均年龄各城市的平均年龄

01:20:52.960 --> 01:20:58.750
好吧，那将是一张地图

01:21:03.550 --> 01:21:14.710
我想将城市平均年龄翻一番

01:21:12.350 --> 01:21:14.710
市

01:21:30.550 --> 01:21:36.690
哦，对，不一定，我的意思是

01:21:34.630 --> 01:21:39.580
我们之所以很久的原因

01:21:36.690 --> 01:21:41.380
我们长期从事的原因

01:21:39.580 --> 01:21:44.440
最后一个例子是因为计数

01:21:41.380 --> 01:21:45.760
计数收集器就是

01:21:44.440 --> 01:21:48.250
将返回很长一段时间，因为它不会

01:21:45.760 --> 01:21:49.630
知道我的意思是他们为什么要大

01:21:48.250 --> 01:21:52.860
写不到的东西

01:21:49.630 --> 01:21:54.910
当他们不知道自己在做什么

01:21:52.860 --> 01:21:57.400
当他们不知道的时候

01:21:54.910 --> 01:21:59.380
价值将是我们的

01:21:57.400 --> 01:22:00.550
如果我们知道我的意思是在这种情况下

01:21:59.380 --> 01:22:03.250
哦，平均年龄不是

01:22:00.550 --> 01:22:10.330
将是这个没有意义

01:22:03.250 --> 01:22:14.680
有一个大的十进制可能是

01:22:10.330 --> 01:22:17.350
在右边，所以在这种情况下，是

01:22:14.680 --> 01:22:18.280
是我们可以，我们可以削弱我们可以

01:22:17.350 --> 01:22:20.170
争取双打，我们可以

01:22:18.280 --> 01:22:25.960
如果我们不愿意解决的话

01:22:20.170 --> 01:22:27.520
如果我们绝对关心您，您可以

01:22:25.960 --> 01:22:28.930
使用它是的，我的意思是我的意思是

01:22:27.520 --> 01:22:30.310
参考类型，我们可以拥有

01:22:28.930 --> 01:22:31.260
任何引用类型都依赖

01:22:30.310 --> 01:22:37.180
绝对

01:22:31.260 --> 01:22:39.190
好吧，我们该怎么办，我们

01:22:37.180 --> 01:22:40.420
我们要点击我们毕竟

01:22:39.190 --> 01:22:44.730
这是关于集体的话题，为什么

01:22:40.420 --> 01:22:50.170
我们还能做其他常规吗

01:22:44.730 --> 01:22:51.790
百岁男孩很好，看起来我的意思是我

01:22:50.170 --> 01:22:54.730
首先切成这样你怎么办

01:22:51.790 --> 01:22:55.840
认为是的，一个人得到城市我的意思是

01:22:54.730 --> 01:23:00.520
看起来这行不通

01:22:55.840 --> 01:23:06.880
它或它将成为一个开始的东西

01:23:00.520 --> 01:23:08.500
而不是我们想要正确执行的操作

01:23:06.880 --> 01:23:10.870
现在我们要做的就是我们想要得到

01:23:08.500 --> 01:23:11.890
我们所有人的总年龄

01:23:10.870 --> 01:23:13.960
会得到所有的总年龄

01:23:11.890 --> 01:23:16.360
在城市中的人，然后再

01:23:13.960 --> 01:23:18.160
他们的数量也许是总结

01:23:16.360 --> 01:23:23.610
统计数据可能是

01:23:18.160 --> 01:23:23.610
一个好主意写在抱歉

01:23:25.869 --> 01:23:30.769
嗯，有一个平均函数

01:23:28.880 --> 01:23:33.769
我认为这是一个平均函数

01:23:30.769 --> 01:23:35.150
在梦中我不知道

01:23:33.769 --> 01:23:39.110
其实那真的很好

01:23:35.150 --> 01:23:41.809
问题，让我们看看平均值

01:23:39.110 --> 01:23:43.099
诠释它的意思是平均

01:23:41.809 --> 01:23:45.800
收集器或它的平均值

01:23:43.099 --> 01:23:48.050
是的，我想我想

01:23:45.800 --> 01:23:50.690
平均是实际上是

01:23:48.050 --> 01:23:53.539
该功能让我就让我就

01:23:50.690 --> 01:23:55.909
停下来说，因为它，因为我说我

01:23:53.539 --> 01:23:59.829
不记得了，那将是

01:23:55.909 --> 01:23:59.829
值得知道什么时候int流我

01:24:02.409 --> 01:24:19.219
好的，所以我不是veräj，所以

01:24:12.949 --> 01:24:21.559
一般吧，所以我们需要

01:24:19.219 --> 01:24:23.929
得到我们需要做的就是得到

01:24:21.559 --> 01:24:26.300
古往今来，然后

01:24:23.929 --> 01:24:29.590
平均流的权利，这就是我们

01:24:26.300 --> 01:24:29.590
现在需要做M怎么做

01:24:37.730 --> 01:24:44.310
正确的平均，让我们尝试平均

01:24:41.070 --> 01:24:46.590
将int平均为int函数，因此它

01:24:44.310 --> 01:24:49.139
听起来不错，不是需要花一个

01:24:46.590 --> 01:24:51.540
取T，这是一张地图，取一个

01:24:49.139 --> 01:24:53.429
映射器我喜欢这样，那会是什么

01:24:51.540 --> 01:24:59.400
我们希望在那里放什么

01:24:53.429 --> 01:25:07.770
然后有人点你的年龄人

01:24:59.400 --> 01:25:11.310
有点年纪了，好吧，也是

01:25:07.770 --> 01:25:14.520
正是这给了我们我们的答案，似乎

01:25:11.310 --> 01:25:16.320
可以说是这样做的

01:25:14.520 --> 01:25:18.150
这就是为什么我喜欢做这个东西

01:25:16.320 --> 01:25:19.489
交互式的，因为通常有人

01:25:18.150 --> 01:25:23.000
知道比我更好的答案

01:25:19.489 --> 01:25:23.000
这让我们看一下

01:25:28.220 --> 01:25:43.350
伦敦33塔尔萨42号和雅典27号伦敦

01:25:33.920 --> 01:25:46.220
 40伦敦33好的雅典27塔尔萨

01:25:43.350 --> 01:25:46.220
 42看起来不错

01:25:47.060 --> 01:25:50.060
抱歉

01:25:57.370 --> 01:26:07.760
对不起，我没听清楚你能说什么

01:25:59.330 --> 01:26:09.410
因为我们没有

01:26:07.760 --> 01:26:10.910
我的意思是说就像

01:26:09.410 --> 01:26:13.940
在这种情况下，我们平均而言

01:26:10.910 --> 01:26:15.260
平均每个城市的年龄

01:26:13.940 --> 01:26:17.390
一般来说，我指的是现实生活

01:26:15.260 --> 01:26:18.469
问题，我的意思是现实生活

01:26:17.390 --> 01:26:19.760
问题，您正在做一些数据

01:26:18.469 --> 01:26:23.469
处理您将要拥有的

01:26:19.760 --> 01:26:27.770
每个城市多于一个人，但

01:26:23.469 --> 01:26:29.960
你的想法是多少工作

01:26:27.770 --> 01:26:31.580
我们做太多的工作，因为

01:26:29.960 --> 01:26:34.699
有时他们会是只有

01:26:31.580 --> 01:26:36.620
一个人或其中没有人，但如果

01:26:34.699 --> 01:26:37.820
那时没有人

01:26:36.620 --> 01:26:39.469
不会再有任何事

01:26:37.820 --> 01:26:40.910
如果有的话，额外的工作

01:26:39.469 --> 01:26:42.980
人是的，那里会有一些

01:26:40.910 --> 01:26:46.460
是一些工作，但是你知道

01:26:42.980 --> 01:26:50.570
它正在编程，所以很酷

01:26:46.460 --> 01:26:54.980
好吧，那是个好问题

01:26:50.570 --> 01:26:56.090
其他人我们现在在转弯

01:26:54.980 --> 01:26:59.050
还有一点，我们还有一点

01:26:56.090 --> 01:27:01.760
再过十分钟左右

01:26:59.050 --> 01:27:10.040
好吧，让我来提供一些东西

01:27:01.760 --> 01:27:12.910
那这个城市怎么样

01:27:10.040 --> 01:27:15.910
多于一多于一

01:27:12.910 --> 01:27:15.910
居民

01:27:22.329 --> 01:27:25.719
稍微不一样

01:27:31.170 --> 01:27:33.830
抱歉

01:27:38.309 --> 01:27:41.900
我肯定要说

01:27:40.590 --> 01:27:44.369
需要在那里有一个过滤器

01:27:41.900 --> 01:27:46.110
我的技术是什么类型

01:27:44.369 --> 01:27:51.420
前往这里的城市

01:27:46.110 --> 01:27:55.489
一个居民艾丽莎（Elissa） 

01:27:51.420 --> 01:27:55.489
城市是一些已建立的城市

01:28:02.430 --> 01:28:07.890
或纵排热门城市

01:28:06.630 --> 01:28:11.070
其实他们不是，你不必

01:28:07.890 --> 01:28:26.820
今天的民粹主义者比

01:28:11.070 --> 01:28:30.150
一个居民好吧，我们要

01:28:26.820 --> 01:28:31.440
需要我们做不到的我们不能把

01:28:30.150 --> 01:28:32.700
立即过滤，因为我们不

01:28:31.440 --> 01:28:33.870
拥有我们现在需要的信息

01:28:32.700 --> 01:28:35.160
首先，我们要做一个

01:28:33.870 --> 01:28:38.600
收集不是我们要

01:28:35.160 --> 01:28:38.600
我们要去一个集体

01:28:39.380 --> 01:28:55.260
分组，那么我们要做什么

01:28:41.520 --> 01:29:00.120
我们将按正确的城市分组，以便

01:28:55.260 --> 01:29:06.900
然后我们要进行计数

01:29:00.120 --> 01:29:10.010
现在我们有什么我们有什么

01:29:06.900 --> 01:29:16.110
所以我们在这一点上是

01:29:10.010 --> 01:29:17.790
从人到实际映射

01:29:16.110 --> 01:29:19.380
真正有用的清单是

01:29:17.790 --> 01:29:23.450
实际写出你现在在哪里

01:29:19.380 --> 01:29:27.090
点，所以我们也有一张城市地图

01:29:23.450 --> 01:29:31.500
没错，所以对于每个城市，我都有

01:29:27.090 --> 01:29:33.810
我有我到达的城市

01:29:31.500 --> 01:29:34.920
我有另一张地图

01:29:33.810 --> 01:29:41.810
每个城市的居民人数

01:29:34.920 --> 01:29:43.700
在那对不起

01:29:41.810 --> 01:29:44.960
我必须要做你必须要做

01:29:43.700 --> 01:29:46.220
另一个流，但我要去

01:29:44.960 --> 01:29:47.480
现在流这是我没有的东西

01:29:46.220 --> 01:29:48.890
告诉你这是你的事

01:29:47.480 --> 01:29:50.600
必须经常做这些

01:29:48.890 --> 01:29:53.500
我要打破这个问题

01:29:50.600 --> 01:29:55.610
向下地图我无法直接流式地图

01:29:53.500 --> 01:29:59.960
我将不得不拿空套

01:29:55.610 --> 01:30:02.540
你知道所以现在就是现在

01:29:59.960 --> 01:30:04.670
我有一组条目，每个条目

01:30:02.540 --> 01:30:06.080
他们将城市与之联系在一起

01:30:04.670 --> 01:30:16.310
现在我可以做过滤器的事情你

01:30:06.080 --> 01:30:21.320
想要对不起，所以我走了，所以我已经

01:30:16.310 --> 01:30:27.320
有一个条目，并且和，而我想

01:30:21.320 --> 01:30:28.780
检查值是否还可以

01:30:27.320 --> 01:30:32.270
可能会正确

01:30:28.780 --> 01:30:34.100
什么时候什么时候什么时候我们有了

01:30:32.270 --> 01:30:36.380
如果不是的话，我们都写了

01:30:34.100 --> 01:30:42.280
回去，我可以给一个明确的

01:30:36.380 --> 01:30:47.480
输入我该怎么办才对不起哦

01:30:42.280 --> 01:30:55.760
是的，谢谢，哦，所有的红军都来了

01:30:47.480 --> 01:30:58.400
离开那太棒了，所以现在我们

01:30:55.760 --> 01:30:59.930
现在我们有一组条目

01:30:58.400 --> 01:31:01.070
得到了条目流

01:30:59.930 --> 01:31:03.590
我们已经淘汰了所有我们

01:31:01.070 --> 01:31:05.540
不想那么所有，所以我认为我们需要

01:31:03.590 --> 01:31:08.840
现在要做的只是恢复名称

01:31:05.540 --> 01:31:11.630
城市是正确的，所以我们想要

01:31:08.840 --> 01:31:17.350
到哦，我不应该那样做

01:31:11.630 --> 01:31:17.350
我们怎么去把那些收集起来

01:31:18.580 --> 01:31:23.780
意思是这里的收藏家

01:31:21.490 --> 01:31:25.850
好吧，我愿意，我想要

01:31:23.780 --> 01:31:28.370
坐好，但目前我所拥有的

01:31:25.850 --> 01:31:30.170
我仍然有条目

01:31:28.370 --> 01:31:31.640
我还没有真正打破过我

01:31:30.170 --> 01:31:34.850
并没有真正使这座城市脱离

01:31:31.640 --> 01:31:36.830
我需要的是

01:31:34.850 --> 01:31:47.570
需要在地图上放置反图，所以我要

01:31:36.830 --> 01:31:49.860
需要映射来映射我的条目

01:31:47.570 --> 01:31:53.310
他们当中哪些我想要

01:31:49.860 --> 01:31:57.230
是关键吗好吗

01:31:53.310 --> 01:31:57.230
现在我想收集它来断言

01:31:59.300 --> 01:32:02.630
那个怎么样

01:32:09.120 --> 01:32:12.110
看看是否可行

01:32:12.900 --> 01:32:18.270
好吧，所以只有雅典有一个以上

01:32:15.420 --> 01:32:25.850
启示录之后的人

01:32:18.270 --> 01:32:29.460
对，是的，所以工作正常

01:32:25.850 --> 01:32:34.310
好吧，我们还有时间再做一次

01:32:29.460 --> 01:32:34.310
有时间再来一次

01:32:39.930 --> 01:32:47.050
如果它在流中的地图和地图中

01:32:43.630 --> 01:32:49.270
因为这是一种工厂方法

01:32:47.050 --> 01:32:51.280
收藏家阶层，所以区别

01:32:49.270 --> 01:32:53.020
在这些之间是地图是

01:32:51.280 --> 01:32:54.520
中间操作

01:32:53.020 --> 01:32:56.920
跌落到每个价值

01:32:54.520 --> 01:32:58.960
流改变了它下降的每个值

01:32:56.920 --> 01:33:01.000
流，如果你想做一次

01:32:58.960 --> 01:33:04.030
你实际上是想收集的人

01:33:01.000 --> 01:33:05.470
那要先做

01:33:04.030 --> 01:33:06.970
换句话说，如果它是

01:33:05.470 --> 01:33:09.940
将采取传入流和

01:33:06.970 --> 01:33:11.230
对您进行操作

01:33:09.940 --> 01:33:13.180
需要有一种不同的

01:33:11.230 --> 01:33:15.130
收藏家，所以你宁愿你需要

01:33:13.180 --> 01:33:16.660
修改您需要的收集器

01:33:15.130 --> 01:33:18.280
你下游的收藏家，你说我

01:33:16.660 --> 01:33:21.790
想要在那之前做点什么， 

01:33:18.280 --> 01:33:23.290
映射需要下游收集器

01:33:21.790 --> 01:33:25.030
还有你想做的事情

01:33:23.290 --> 01:33:33.000
在那之前，它们把它们放在一起

01:33:25.030 --> 01:33:36.520
再找一个新的收藏家

01:33:33.000 --> 01:33:37.960
他们变得越来越难了

01:33:36.520 --> 01:33:40.900
的方式，我们有动手

01:33:37.960 --> 01:33:43.000
明天进行实验

01:33:40.900 --> 01:33:44.380
你真的远不止于此

01:33:43.000 --> 01:33:47.670
比这更远的是

01:33:44.380 --> 01:33:50.200
很有意思，但这是一个

01:33:47.670 --> 01:33:52.300
溪流和着陆器的动手实验室以及

01:33:50.200 --> 01:33:54.250
真的很好，而且评分真的很好

01:33:52.300 --> 01:33:58.630
这是Oracle的Stewart Stewart标记

01:33:54.250 --> 01:34:00.970
使那个实验室合作了

01:33:58.630 --> 01:34:02.140
和他在一起，但是他已经做了很多

01:34:00.970 --> 01:34:03.970
大量的工作，所以我坚决

01:34:02.140 --> 01:34:07.350
建议您，如果不满

01:34:03.970 --> 01:34:09.040
已经是正确的，所以最受欢迎的年龄

01:34:07.350 --> 01:34:11.550
来自的回应实际上是

01:34:09.040 --> 01:34:11.550
有趣

01:34:20.310 --> 01:34:24.670
是的，更难得到

01:34:22.810 --> 01:34:28.480
我的意思是我们可能没有时间

01:34:24.670 --> 01:34:30.540
让他们知道你只想要你

01:34:28.480 --> 01:34:35.190
只是想要一个整数我

01:34:30.540 --> 01:34:37.570
意味着我们真的很我们

01:34:35.190 --> 01:34:38.320
在这里谈论我们的情况

01:34:37.570 --> 01:34:39.760
要出去

01:34:38.320 --> 01:34:43.590
实际上，我们会发现这是不对的

01:34:39.760 --> 01:34:43.590
要么，但让我们看看为什么

01:34:50.780 --> 01:35:01.199
对不起，谋杀就像你

01:34:58.800 --> 01:35:03.659
有十个人33岁

01:35:01.199 --> 01:35:10.170
 42岁的12个人42是

01:35:03.659 --> 01:35:12.349
您想要分组的最流行年龄

01:35:10.170 --> 01:35:12.349
通过

01:35:22.720 --> 01:35:26.930
对，所以现在我们有了

01:35:25.670 --> 01:35:34.970
以我喜欢写的方式

01:35:26.930 --> 01:35:43.520
我们有一张地图，我有一张地图

01:35:34.970 --> 01:35:45.890
从年龄开始以整数表示

01:35:43.520 --> 01:35:55.840
到目前为止的人员，但显然这是

01:35:45.890 --> 01:36:00.860
我们将需要更改对不起

01:35:55.840 --> 01:36:03.200
是的，是的，你绝对

01:36:00.860 --> 01:36:05.560
对的是一个人的名单

01:36:03.200 --> 01:36:05.560
谢谢

01:36:15.849 --> 01:36:20.809
所以我们是对的，我的想法

01:36:19.190 --> 01:36:21.860
数数声音数数声音很好

01:36:20.809 --> 01:36:24.889
因为那将使我们能够

01:36:21.860 --> 01:36:26.989
找到最大值，不是最大值

01:36:24.889 --> 01:36:30.199
所以在哪里算呢

01:36:26.989 --> 01:36:35.150
数数要去这里，我们可以把

01:36:30.199 --> 01:36:39.050
我们可以马上把你放进去

01:36:35.150 --> 01:36:43.429
别这么想，所以我们会得到一个

01:36:39.050 --> 01:36:46.520
从整数到整数的映射太长，并且

01:36:43.429 --> 01:36:47.989
那将是，实际上正在

01:36:46.520 --> 01:36:48.650
拥有我们需要的信息

01:36:47.989 --> 01:36:55.369
没有

01:36:48.650 --> 01:36:56.389
因为是的，没错

01:36:55.369 --> 01:36:57.559
因为它实际上将具有

01:36:56.389 --> 01:36:58.520
算是要有年龄了

01:36:57.559 --> 01:37:00.650
每一个都有计数

01:36:58.520 --> 01:37:07.900
一个，所以我喜欢，所以我想如果我只是

01:37:00.650 --> 01:37:13.579
说现在算，那我想

01:37:07.900 --> 01:37:16.480
那我想我们可能是

01:37:13.579 --> 01:37:16.480
不是我的本意

01:37:20.239 --> 01:37:26.510
所以我们现在需要做的是

01:37:22.520 --> 01:37:28.100
现在我们有一张地图了

01:37:26.510 --> 01:37:30.140
我应该现在将其更改为

01:37:28.100 --> 01:37:34.340
从被列出的人到被

01:37:30.140 --> 01:37:35.810
好久了，现在我们要做的是

01:37:34.340 --> 01:37:40.900
我们必须分析其中的条目

01:37:35.810 --> 01:37:52.100
映射某种程度上将其反转真的是因为

01:37:40.900 --> 01:37:57.380
好最大的价值，我想你知道我想

01:37:52.100 --> 01:38:02.090
那里有某种

01:37:57.380 --> 01:38:03.500
我认为在功能上最大

01:38:02.090 --> 01:38:06.080
流是正确的

01:38:03.500 --> 01:38:08.120
也许我知道，但是如果我们

01:38:06.080 --> 01:38:09.800
有了一个流，您获得了最大的收益，而您

01:38:08.120 --> 01:38:11.540
提供一个比较器，它将

01:38:09.800 --> 01:38:13.040
根据

01:38:11.540 --> 01:38:14.660
列，然后您可以获取

01:38:13.040 --> 01:38:16.489
那会给你你想要的那个

01:38:14.660 --> 01:38:22.640
它，但我们需要有这些

01:38:16.489 --> 01:38:24.290
这些条目的这些，所以我需要我

01:38:22.640 --> 01:38:38.110
需要我需要再次输入条目集

01:38:24.290 --> 01:38:41.390
没事吧，点输入设置点流

01:38:38.110 --> 01:38:43.460
现在为什么现在不喜欢

01:38:41.390 --> 01:38:45.380
最大列表，它不被称为max 

01:38:43.460 --> 01:38:47.210
它称为max max by是

01:38:45.380 --> 01:38:49.219
该方法的功能

01:38:47.210 --> 01:38:52.580
产生家的工厂方法

01:38:49.219 --> 01:38:56.270
一个收集者沙漠，所以比较者

01:38:52.580 --> 01:38:58.969
我们想要这里现在有一些聪明

01:38:56.270 --> 01:39:00.530
 Java 8中的东西，他们给了我们什么

01:38:58.969 --> 01:39:02.660
可以做的是，我们可以显然可以

01:39:00.530 --> 01:39:07.460
定义我们说过的羔羊

01:39:02.660 --> 01:39:10.910
进入那个一个或一个

01:39:07.460 --> 01:39:12.410
返回比较结果

01:39:10.910 --> 01:39:14.210
价值观，这就是我们

01:39:12.410 --> 01:39:17.950
可能对这里感兴趣不是吗

01:39:14.210 --> 01:39:17.950
好但是

01:39:21.440 --> 01:39:29.190
在地图输入中有一种方法

01:39:24.890 --> 01:39:31.140
因此它是地图输入点按值进行比较

01:39:29.190 --> 01:39:31.469
太棒了，我们想要的不是

01:39:31.140 --> 01:39:33.630
它

01:39:31.469 --> 01:39:34.770
因为我们要比较

01:39:33.630 --> 01:39:37.860
比较理事会的，它已经不存在了

01:39:34.770 --> 01:39:38.760
再次，不，不，不，不，必须

01:39:37.860 --> 01:39:40.080
我什至无法触摸的地方

01:39:38.760 --> 01:39:43.620
可以做到的机器

01:39:40.080 --> 01:39:50.489
很难，好吧，我想就是这样

01:39:43.620 --> 01:39:51.630
是的，我会得到一个可选的

01:39:50.489 --> 01:39:53.850
是的，我在等那件事

01:39:51.630 --> 01:39:56.010
作为编译器，是的，所以我需要我

01:39:53.850 --> 01:40:00.719
实际上需要得到我需要得到

01:39:56.010 --> 01:40:08.910
我需要地图我需要

01:40:00.719 --> 01:40:10.949
映射它不行，所以我想

01:40:08.910 --> 01:40:14.280
我现在拥有的就是我现在拥有的

01:40:10.949 --> 01:40:18.900
是一个条目是不是所以我所以我

01:40:14.280 --> 01:40:26.400
想获得价值不是吗？ 

01:40:18.900 --> 01:40:29.010
我们不应该获得价值，你知道那不是

01:40:26.400 --> 01:40:32.040
不是不是没有提供我啊，因为

01:40:29.010 --> 01:40:34.770
它还没有提供我的原因

01:40:32.040 --> 01:40:36.449
它没有提供我，因为它

01:40:34.770 --> 01:40:37.920
知道它知道会返回一个

01:40:36.449 --> 01:40:39.679
可选，我的意思是我知道它将要

01:40:37.920 --> 01:40:43.170
返回一个我不想的可选

01:40:39.679 --> 01:40:44.790
破坏你的乐趣

01:40:43.170 --> 01:40:46.440
它要返回的原因

01:40:44.790 --> 01:40:47.699
可选的是因为我正在做的是

01:40:46.440 --> 01:40:51.239
我正在努力获取最大的价值

01:40:47.699 --> 01:40:53.280
使用max方法的流

01:40:51.239 --> 01:40:54.300
当然我们不知道我们不能告诉他们

01:40:53.280 --> 01:40:58.590
前进，它将是任何东西

01:40:54.300 --> 01:41:01.590
在那个流中，所以，如果是这样， 

01:40:58.590 --> 01:41:03.030
结果的结果是

01:41:01.590 --> 01:41:08.989
然后我们将得到我们所得到的

01:41:03.030 --> 01:41:08.989
要回来是一个可选的诠释乐趣

01:41:09.170 --> 01:41:12.530
那么第二

01:41:13.120 --> 01:41:18.110
如果我必须介绍一个最大的

01:41:15.920 --> 01:41:19.510
特别是这段代码不会

01:41:18.110 --> 01:41:21.500
将只选择其中之一

01:41:19.510 --> 01:41:24.500
绝对有一个更复杂的

01:41:21.500 --> 01:41:26.120
该代码的版本，我们没有

01:41:24.500 --> 01:41:29.780
我们没有时间去做

01:41:26.120 --> 01:41:32.570
但这是在书中

01:41:29.780 --> 01:41:34.730
实际上让你得到

01:41:32.570 --> 01:41:37.100
返回和完整的地图，我会选择这个

01:41:34.730 --> 01:41:40.550
或选择一组最

01:41:37.100 --> 01:41:43.090
受欢迎的，所以我需要什么

01:41:40.550 --> 01:41:55.220
为此选择此选项以获取

01:41:43.090 --> 01:41:56.630
拉D，这样我在哪里穿

01:41:55.220 --> 01:41:59.200
映射在那里我将空映射到哪里

01:41:56.630 --> 01:42:03.620
我要去做的关键

01:41:59.200 --> 01:42:05.210
在最大之后我不这么认为

01:42:03.620 --> 01:42:13.730
其实我想我可能不会

01:42:05.210 --> 01:42:14.630
如果我不告诉我，我的生活会更轻松

01:42:13.730 --> 01:42:16.760
你是什​​么让我的生活真正

01:42:14.630 --> 01:42:18.500
实际上会更容易

01:42:16.760 --> 01:42:19.640
我的意思是我可以做到，但是

01:42:18.500 --> 01:42:21.830
实际上会让我的生活更轻松

01:42:19.640 --> 01:42:26.330
将此映射到获取获取

01:42:21.830 --> 01:42:28.360
价值我只需要不需要

01:42:26.330 --> 01:42:30.320
需要正确的钥匙好吧，我是

01:42:28.360 --> 01:42:33.320
按价值比较，但现在我需要

01:42:30.320 --> 01:42:38.350
关键我不映射我是，所以我要

01:42:33.320 --> 01:42:38.350
说地图入口

01:42:42.010 --> 01:42:57.100
您正确地获得了钥匙

01:42:49.480 --> 01:42:59.620
好吧，我想说，否则，否则，或者

01:42:57.100 --> 01:43:02.410
其他-一项权利

01:42:59.620 --> 01:43:04.090
哎呀，现在，现在，这是

01:43:02.410 --> 01:43:05.770
不会是对的，因为实际上我是

01:43:04.090 --> 01:43:06.910
惊讶我知道是对的

01:43:05.770 --> 01:43:08.110
我以为我会做得更糟

01:43:06.910 --> 01:43:10.210
也可以将其定义为

01:43:08.110 --> 01:43:12.160
可选的int这就是我

01:43:10.210 --> 01:43:18.040
被邀请到右边，让我们看看

01:43:12.160 --> 01:43:19.120
作品效果不佳，可能

01:43:18.040 --> 01:43:21.540
打印出来是一个好主意

01:43:19.120 --> 01:43:21.540
谢谢

01:43:23.580 --> 01:43:28.260
这是一个受欢迎的时代，让我们看看

01:43:26.380 --> 01:43:30.910
发生

01:43:28.260 --> 01:43:34.660
我最流行的年龄其实

01:43:30.910 --> 01:43:39.310
数据中的30到33很好，所以我们已经

01:43:34.660 --> 01:43:43.810
有两个33岁的人，你怎么看

01:43:39.310 --> 01:43:47.440
前面的可行的人认为这是

01:43:43.810 --> 01:43:51.640
你们在后面做得好，我知道

01:43:47.440 --> 01:43:52.900
房间很大不是吗

01:43:51.640 --> 01:43:55.570
需要一点头

01:43:52.900 --> 01:43:57.220
围绕它，但它却是你

01:43:55.570 --> 01:43:59.530
可以看到这是可行的，我做到了

01:43:57.220 --> 01:44:01.150
看起来比那时容易一些

01:43:59.530 --> 01:44:03.040
因为你会变得很愚蠢

01:44:01.150 --> 01:44:04.720
编译错误，它们并不愚蠢

01:44:03.040 --> 01:44:06.340
真的很难排序

01:44:04.720 --> 01:44:09.130
出去，你必须做一些你必须做的

01:44:06.340 --> 01:44:10.960
做一些相当聪明的事情来喜欢

01:44:09.130 --> 01:44:12.400
我的意思是例如提取变量

01:44:10.960 --> 01:44:14.440
真的有很大帮助

01:44:12.400 --> 01:44:16.060
有时编译错误是

01:44:14.440 --> 01:44:17.080
很有误导性，所以您必须拥有

01:44:16.060 --> 01:44:19.480
思考一下自己的方式

01:44:17.080 --> 01:44:21.580
一点，但是你会看到你会得到它

01:44:19.480 --> 01:44:24.460
我们得到了很多很多

01:44:21.580 --> 01:44:26.470
力量相当复杂的功能

01:44:24.460 --> 01:44:28.450
做漂亮的事情

01:44:26.470 --> 01:44:31.450
简单的事情现在你的想法

01:44:28.450 --> 01:44:33.430
知道UNIX工具的放置原理

01:44:31.450 --> 01:44:35.440
简单的事情一起做大

01:44:33.430 --> 01:44:38.350
在这里效果很好，这是一个

01:44:35.440 --> 01:44:40.630
它是如何工作的

01:44:38.350 --> 01:44:42.670
不同的组成

01:44:40.630 --> 01:44:44.290
收藏家，在某种程度上

01:44:42.670 --> 01:44:46.120
组成的组成

01:44:44.290 --> 01:44:48.790
中间操作进入

01:44:46.120 --> 01:44:51.880
流好吧，我要回到

01:44:48.790 --> 01:44:53.800
幻灯片现在只是为了解决问题

01:44:51.880 --> 01:44:54.160
离开，因为他们几乎没有了

01:44:53.800 --> 01:44:55.750
时间

01:44:54.160 --> 01:45:02.550
哦，我们对我有把握

01:44:55.750 --> 01:45:02.550
正确的时间仍然只是我的意思不是镜像

01:45:03.300 --> 01:45:08.100
所以我只是要去

01:45:05.560 --> 01:45:13.480
简单地向您展示一些有关

01:45:08.100 --> 01:45:16.450
写自己的收藏家，然后

01:45:13.480 --> 01:45:17.290
我们完成了，好吧，所以问为什么

01:45:16.450 --> 01:45:19.720
你想写自己的吗

01:45:17.290 --> 01:45:21.370
收藏家很好答案通常是你

01:45:19.720 --> 01:45:23.380
我不是说我认为你现在已经见过

01:45:21.370 --> 01:45:25.090
那里只有大量的神经丛

01:45:23.380 --> 01:45:27.010
我的意思是真正的问题实际上是

01:45:25.090 --> 01:45:28.660
了解各种各样的

01:45:27.010 --> 01:45:30.970
收藏家课里有东西

01:45:28.660 --> 01:45:32.380
而不是离开

01:45:30.970 --> 01:45:34.330
自己写，你真的需要得到

01:45:32.380 --> 01:45:36.670
你的脑袋围绕着以前提供的东西

01:45:34.330 --> 01:45:38.020
你开始重新发明轮子，但是

01:45:36.670 --> 01:45:39.340
有时您可能想要例如

01:45:38.020 --> 01:45:40.840
如果你想积累到一个

01:45:39.340 --> 01:45:42.790
未实现的容器

01:45:40.840 --> 01:45:45.040
图书馆没有为您提供的收藏

01:45:42.790 --> 01:45:45.910
对此有很多支持

01:45:45.040 --> 01:45:47.680
我们现在要看

01:45:45.910 --> 01:45:49.260
假设你想分享状态

01:45:47.680 --> 01:45:51.820
在收集的值和

01:45:49.260 --> 01:45:54.220
那就是那就是那就是我们

01:45:51.820 --> 01:45:56.530
现在来看一个例子

01:45:54.220 --> 01:45:56.920
图书馆没有提供的

01:45:56.530 --> 01:46:00.220
要么

01:45:56.920 --> 01:46:01.750
所以问题解决了我无法解决的问题

01:46:00.220 --> 01:46:03.220
记住我是否不认为我

01:46:01.750 --> 01:46:04.660
在书中这样描述它，但是

01:46:03.220 --> 01:46:07.900
没关系，这是奥普拉的

01:46:04.660 --> 01:46:09.940
问题开放者的问题是，这些

01:46:07.900 --> 01:46:12.000
是她选择的十本书

01:46:09.940 --> 01:46:16.780
过去十年最好的十本书

01:46:12.000 --> 01:46:18.220
现在她的问题是我选择的她

01:46:16.780 --> 01:46:19.390
这个图，因为我在看

01:46:18.220 --> 01:46:21.220
买一套书，我想哦

01:46:19.390 --> 01:46:23.680
好的，她可能在这里遇到一些问题

01:46:21.220 --> 01:46:24.730
从她的收藏中找到一本书，所以

01:46:23.680 --> 01:46:28.680
我想我们应该给她一个

01:46:24.730 --> 01:46:30.940
与此手和的想法是

01:46:28.680 --> 01:46:35.800
我们将如何解决奥普拉的问题

01:46:30.940 --> 01:46:38.500
是我们要给她提供一张地图吗

01:46:35.800 --> 01:46:41.020
书名从

01:46:38.500 --> 01:46:44.200
预定到书架上的起点

01:46:41.020 --> 01:46:45.940
是的，所以我们将通过

01:46:44.200 --> 01:46:47.620
计算累积厚度

01:46:45.940 --> 01:46:49.450
所有在它之前的书

01:46:47.620 --> 01:46:50.790
因为那是你知道的开始

01:46:49.450 --> 01:46:55.870
架子上的点很明显

01:46:50.790 --> 01:46:57.640
 Eckhart Tolle的新世界

01:46:55.870 --> 01:47:00.610
那就是在左手边

01:46:57.640 --> 01:47:03.910
架子上，然后继续336页

01:47:00.610 --> 01:47:06.610
她要去寻找毒木圣经

01:47:03.910 --> 01:47:07.570
现在336页，她当然不会

01:47:06.610 --> 01:47:08.980
知道那个的度量但是

01:47:07.570 --> 01:47:10.690
我们会给她一个很好的转换

01:47:08.980 --> 01:47:12.640
我们将其转换为英寸或

01:47:10.690 --> 01:47:15.580
毫米之类的东西，以便她可以

01:47:12.640 --> 01:47:18.100
然后战斗，以便她可以找到它， 

01:47:15.580 --> 01:47:20.830
这样她就会有一个

01:47:18.100 --> 01:47:24.190
查找所有书籍的简单方法

01:47:20.830 --> 01:47:26.290
在她最后十佳的架子上

01:47:24.190 --> 01:47:27.700
最近十年，你不认为有

01:47:26.290 --> 01:47:27.880
对此有什么奇怪的事情吗

01:47:27.700 --> 01:47:34.840
您

01:47:27.880 --> 01:47:37.030
我有一个特定的请求远程探针

01:47:34.840 --> 01:47:41.860
为此用这段代码，所以她

01:47:37.030 --> 01:47:44.710
需要的是一张来自的地图

01:47:41.860 --> 01:47:46.840
这本书以其累积到

01:47:44.710 --> 01:47:49.510
之前的累积页数

01:47:46.840 --> 01:47:51.460
在架子上，所以既然新地球在

01:47:49.510 --> 01:47:53.230
在最左侧

01:47:51.460 --> 01:47:56.680
在此之前的累积页数是

01:47:53.230 --> 01:47:58.660
零，但其中有336页，因此

01:47:56.680 --> 01:48:03.900
之前的累积页数

01:47:58.660 --> 01:48:05.950
毒木圣经是336，因此

01:48:03.900 --> 01:48:07.239
我们要去做的是

01:48:05.950 --> 01:48:08.830
我们将一路构建

01:48:07.239 --> 01:48:11.220
我当时想过

01:48:08.830 --> 01:48:14.500
在那里建立这本书

01:48:11.220 --> 01:48:15.730
是我们在寻找数据

01:48:14.500 --> 01:48:17.110
可以容纳这个的结构

01:48:15.730 --> 01:48:18.160
信息确实有一种

01:48:17.110 --> 01:48:19.960
当然，这样做的明显方式

01:48:18.160 --> 01:48:21.640
使用蓄能器，但我们知道

01:48:19.960 --> 01:48:23.350
蓄电池没电了

01:48:21.640 --> 01:48:25.510
流的累加器

01:48:23.350 --> 01:48:27.960
 API，我们必须找到一种方法

01:48:25.510 --> 01:48:32.230
那将会是

01:48:27.960 --> 01:48:34.930
并行准备好了，所以想法是

01:48:32.230 --> 01:48:37.750
找到一个我们可以的数据结构

01:48:34.930 --> 01:48:39.370
视作提供了部分解决方案

01:48:37.750 --> 01:48:41.350
问题，然后我们看如何

01:48:39.370 --> 01:48:43.120
将这些数据的较小部分合并在一起

01:48:41.350 --> 01:48:44.350
制作更大的结构，直到

01:48:43.120 --> 01:48:45.880
最终我们拥有了整个东西

01:48:44.350 --> 01:48:47.380
那将是那将是

01:48:45.880 --> 01:48:49.840
想法这里是这里的数据

01:48:47.380 --> 01:48:51.970
我们正在研究的结构

01:48:49.840 --> 01:48:54.190
大方括号将一个

01:48:51.970 --> 01:48:56.200
我制作的顺序数据结构

01:48:54.190 --> 01:48:58.120
我曾经用过

01:48:56.200 --> 01:48:59.800
书中的数组卡片组，但实际上我

01:48:58.120 --> 01:49:01.780
认为ArrayList会很好并且

01:48:59.800 --> 01:49:03.880
有轻微的表现

01:49:01.780 --> 01:49:05.140
数组和想法的改进

01:49:03.880 --> 01:49:07.210
是我们你知道我们知道我们要去

01:49:05.140 --> 01:49:10.870
需要累加器的组合器

01:49:07.210 --> 01:49:12.310
对于收藏家，我们

01:49:10.870 --> 01:49:14.410
当然需要供应商

01:49:12.310 --> 01:49:16.090
供应商很明显这是一个新的ArrayList 

01:49:14.410 --> 01:49:18.460
或每当我们要去一个新的阵列甲板

01:49:16.090 --> 01:49:20.590
使用，但累加器很漂亮

01:49:18.460 --> 01:49:22.840
简单明了-需要一本新书

01:49:20.590 --> 01:49:25.530
地球，然后它是做什么的

01:49:22.840 --> 01:49:29.889
它把标题放在那里

01:49:25.530 --> 01:49:32.050
它放入页数和

01:49:29.889 --> 01:49:33.400
它把累积位移

01:49:32.050 --> 01:49:34.929
但这还不知道，因为

01:49:33.400 --> 01:49:36.250
这就是我们试图找出的

01:49:34.929 --> 01:49:38.650
开始将是零

01:49:36.250 --> 01:49:41.590
与然后然后的方式

01:49:38.650 --> 01:49:44.380
累加器将工作的是单

01:49:41.590 --> 01:49:45.699
线程累积前几个

01:49:44.380 --> 01:49:47.290
这些书将首先崭新的地球

01:49:45.699 --> 01:49:49.150
所有这将使数据结构

01:49:47.290 --> 01:49:51.790
包含它，然后将其放入

01:49:49.150 --> 01:49:53.110
这个数组甲板ArrayList然后

01:49:51.790 --> 01:49:55.239
去到那累加器将采取

01:49:53.110 --> 01:49:56.889
另一本《毒木圣经》 

01:49:55.239 --> 01:49:59.679
将其包装在数据结构中， 

01:49:56.889 --> 01:50:01.330
它将会并且现在它实际上可以

01:49:59.679 --> 01:50:03.550
说出累积页数是多少

01:50:01.330 --> 01:50:05.650
还有可以说的右侧格

01:50:03.550 --> 01:50:08.469
那是因为那是因为

01:50:05.650 --> 01:50:10.960
显然只是累积页面

01:50:08.469 --> 01:50:13.090
从前一个计数再加上

01:50:10.960 --> 01:50:14.710
加上前一页的页数

01:50:13.090 --> 01:50:16.599
一个，所以将这两个加在一起

01:50:14.710 --> 01:50:17.889
这就是蓄能器的工作原理，现在

01:50:16.599 --> 01:50:20.139
如果我们想想我们将如何

01:50:17.889 --> 01:50:22.449
得到整个事情

01:50:20.139 --> 01:50:24.730
所以想象这是一个

01:50:22.449 --> 01:50:26.290
代表顺序数据

01:50:24.730 --> 01:50:28.750
包含所有

01:50:26.290 --> 01:50:31.510
书中你可以看到，这可以是

01:50:28.750 --> 01:50:32.739
由两个部分组成，假设我们

01:50:31.510 --> 01:50:34.300
将具有两个部分数据结构

01:50:32.739 --> 01:50:35.139
像这样的建筑

01:50:34.300 --> 01:50:37.179
我向您展示的方式

01:50:35.139 --> 01:50:39.670
上一张幻灯片的左侧是

01:50:37.179 --> 01:50:41.440
它是使用蓄能器建造的

01:50:39.670 --> 01:50:42.489
右边的一个是使用

01:50:41.440 --> 01:50:44.530
现在我们必须结合起来

01:50:42.489 --> 01:50:46.449
他们在一起，组合是

01:50:44.530 --> 01:50:49.320
很简单，我们要做的是

01:50:46.449 --> 01:50:52.150
组合器只需要

01:50:49.320 --> 01:50:55.480
最右边的累积页数

01:50:52.150 --> 01:50:57.310
左半部分的元素加上

01:50:55.480 --> 01:50:59.139
最右边元素的页数

01:50:57.310 --> 01:51:01.900
左半部分，这样您就可以看到

01:50:59.139 --> 01:51:03.909
那两个红色箭头，使976 

01:51:01.900 --> 01:51:06.369
那是

01:51:03.909 --> 01:51:08.980
整个左侧，然后

01:51:06.369 --> 01:51:12.969
只是将其添加到

01:51:08.980 --> 01:51:15.400
到的每个页数

01:51:12.969 --> 01:51:17.290
右侧依次如此结合

01:51:15.400 --> 01:51:18.699
这两个数据结构不

01:51:17.290 --> 01:51:20.260
不需要您参与，而不必

01:51:18.699 --> 01:51:22.179
我们根本没有蓄能器

01:51:20.260 --> 01:51:24.369
积累这一点

01:51:22.179 --> 01:51:26.980
累积页数是

01:51:24.369 --> 01:51:28.239
我们想要什么，所以现在我们

01:51:26.980 --> 01:51:29.980
我们会做的就是

01:51:28.239 --> 01:51:32.409
我们会通过流运行它吗

01:51:29.980 --> 01:51:36.170
我们会预测

01:51:32.409 --> 01:51:39.590
使用Map函数进行地图操作

01:51:36.170 --> 01:51:43.310
投影出书名

01:51:39.590 --> 01:51:45.170
和和的页面

01:51:43.310 --> 01:51:48.020
累积页数，然后我们将

01:51:45.170 --> 01:51:49.429
用它制作一张地图，这样的

01:51:48.020 --> 01:51:52.460
这就是全部的原则

01:51:49.429 --> 01:51:54.710
我想要的书中的代码

01:51:52.460 --> 01:51:55.969
我的意思是我认为这是

01:51:54.710 --> 01:51:58.130
有用的例子，因为它展示了

01:51:55.969 --> 01:52:00.230
看起来像的东西

01:51:58.130 --> 01:52:02.360
成为一个积累者

01:52:00.230 --> 01:52:05.420
不必成为我们的累加器

01:52:02.360 --> 01:52:08.570
只是让我们的思想如此融合

01:52:05.420 --> 01:52:10.100
我们不做的迭代和累加器

01:52:08.570 --> 01:52:11.239
看到其他的做事方式，即使

01:52:10.100 --> 01:52:14.000
他们实际上很漂亮

01:52:11.239 --> 01:52:16.130
直截了当，所以只是为了结束我

01:52:14.000 --> 01:52:18.500
意思是我确实在想你

01:52:16.130 --> 01:52:19.699
可以使用减少来做到这一点，但我

01:52:18.500 --> 01:52:22.489
猜猜我可以跳过这个漂亮的

01:52:19.699 --> 01:52:24.080
轻松地以您可以的方式

01:52:22.489 --> 01:52:26.480
使用减少得到相同的东西

01:52:24.080 --> 01:52:28.460
把每个人的想法，我

01:52:26.480 --> 01:52:29.660
关于您是否曾经使用过

01:52:28.460 --> 01:52:31.870
减少功能

01:52:29.660 --> 01:52:34.160
给你编程，所以嘿，我不需要这个

01:52:31.870 --> 01:52:35.660
收藏家的东西，我要做

01:52:34.160 --> 01:52:37.489
在那里，我要去尝试

01:52:35.660 --> 01:52:39.170
经过测试的方式，您必须采取每个

01:52:37.489 --> 01:52:41.620
在这些中，您必须将每个

01:52:39.170 --> 01:52:43.850
这些元素，你需要做一个新的

01:52:41.620 --> 01:52:45.350
您必须创建一个新的数据结构

01:52:43.850 --> 01:52:48.440
从它，你必须把它放在一个

01:52:45.350 --> 01:52:50.030
顺序，您必须将其放入

01:52:48.440 --> 01:52:52.100
顺序的事情就像当你

01:52:50.030 --> 01:52:53.989
从蓄电池开始，然后

01:52:52.100 --> 01:52:56.390
你将不得不减少

01:52:53.989 --> 01:52:58.460
遍及所有这些

01:52:56.390 --> 01:53:00.380
真的很昂贵而且笨拙

01:52:58.460 --> 01:53:03.199
而且其中很大一部分将是

01:53:00.380 --> 01:53:06.679
在客户端代码中完成，实际上是这样

01:53:03.199 --> 01:53:09.050
收藏家的确不是很好

01:53:06.679 --> 01:53:11.810
是一项创新，实际上

01:53:09.050 --> 01:53:14.060
有别于什么

01:53:11.810 --> 01:53:15.710
在我第一次做之前

01:53:14.060 --> 01:53:17.780
认为减少量用于

01:53:15.710 --> 01:53:19.730
在某种语言中确实非常重要

01:53:17.780 --> 01:53:21.410
取决于突变java不是

01:53:19.730 --> 01:53:23.179
功能语言功能语言

01:53:21.410 --> 01:53:25.910
基本上使用不可变数据

01:53:23.179 --> 01:53:28.250
结构和java不是功能

01:53:25.910 --> 01:53:31.580
语言，而且不会是一种语言

01:53:28.250 --> 01:53:34.160
因此，调整这边的想法

01:53:31.580 --> 01:53:36.770
减少这种功能性想法的适应

01:53:34.160 --> 01:53:38.810
变成不可变的容器是

01:53:36.770 --> 01:53:41.449
实际上真的很安静

01:53:38.810 --> 01:53:45.230
突破，我认为这很漂亮

01:53:41.449 --> 01:53:49.090
聪明的东西好吧，那就是

01:53:45.230 --> 01:53:51.580
他们知道这就是推销

01:53:49.090 --> 01:53:54.250
现在只是为了我的机器

01:53:51.580 --> 01:53:56.349
正在进行，所以我要说说，我只是说说

01:53:54.250 --> 01:54:01.960
非常简短地总结一下

01:53:56.349 --> 01:54:04.960
等待它唤醒你知道

01:54:01.960 --> 01:54:10.690
没有回应很酷，我是说

01:54:04.960 --> 01:54:14.849
非常简短地谈论性能，因此

01:54:10.690 --> 01:54:18.820
收藏家的表现是

01:54:14.849 --> 01:54:20.590
通常很大程度上取决于

01:54:18.820 --> 01:54:22.119
蓄能器要去

01:54:20.590 --> 01:54:25.780
如果你想像我们的话

01:54:22.119 --> 01:54:27.820
 10,000个元素数组，然后

01:54:25.780 --> 01:54:29.500
蓄能器将被可怕地使用

01:54:27.820 --> 01:54:30.639
比合并的要多得多

01:54:29.500 --> 01:54:36.790
将相对使用的组合

01:54:30.639 --> 01:54:38.080
相对较少，所以我只是

01:54:36.790 --> 01:54:44.320
找到并找到我的地方

01:54:38.080 --> 01:54:45.790
再次如此，所以表演

01:54:44.320 --> 01:54:47.920
蓄能器非常关键， 

01:54:45.790 --> 01:54:49.420
实际上真的将会是

01:54:47.920 --> 01:54:50.260
取决于

01:54:49.420 --> 01:54:52.480
特定的蓄能器

01:54:50.260 --> 01:54:54.550
所以一般来说收集是

01:54:52.480 --> 01:54:58.719
使用添加不同的添加方法

01:54:54.550 --> 01:55:00.310
收集它，所以这就是我们

01:54:58.719 --> 01:55:02.199
不是很看任何东西

01:55:00.310 --> 01:55:05.260
与我们所拥有的不同

01:55:02.199 --> 01:55:07.060
与迭代代码，我们正在看

01:55:05.260 --> 01:55:10.420
改进，因为很多时候

01:55:07.060 --> 01:55:13.659
编译器可以更好地与

01:55:10.420 --> 01:55:15.099
流代码，因为它是

01:55:13.659 --> 01:55:18.969
使用类似的技术

01:55:15.099 --> 01:55:21.099
循环卡入进来

01:55:18.969 --> 01:55:23.380
常规常规代码

01:55:21.099 --> 01:55:25.599
商业迭代代码的作用

01:55:23.380 --> 01:55:27.489
是您实际上可以看到的吗？ 

01:55:25.599 --> 01:55:31.150
结合在一起的循环，它得到

01:55:27.489 --> 01:55:34.599
更好地获得更好的优化

01:55:31.150 --> 01:55:36.130
这个问题最大的问题

01:55:34.599 --> 01:55:38.230
我发现在观察

01:55:36.130 --> 01:55:40.090
大数据收集者

01:55:38.230 --> 01:55:42.730
结构我是指那种

01:55:40.090 --> 01:55:44.739
最简单的事情是

01:55:42.730 --> 01:55:46.599
说地图比较难

01:55:44.739 --> 01:55:49.119
特别是因为他们需要

01:55:46.599 --> 01:55:51.429
调整大小，因此调整地图的尺寸​​非常昂贵

01:55:49.119 --> 01:55:53.409
和地图合并，必须完成

01:55:51.429 --> 01:55:55.750
合成器的战斗非常

01:55:53.409 --> 01:55:57.790
操作昂贵，所以调整大小

01:55:55.750 --> 01:55:59.050
如果您有，请先调整地图大小

01:55:57.790 --> 01:56:00.460
如果你要投入很多

01:55:59.050 --> 01:56:02.899
数据进入地图获取初始

01:56:00.460 --> 01:56:06.590
大小的游乐设施实际上很有价值

01:56:02.899 --> 01:56:09.820
所以那又是一个有用的

01:56:06.590 --> 01:56:11.629
提示好的结论收集者

01:56:09.820 --> 01:56:13.579
归纳式

01:56:11.629 --> 01:56:15.379
其实就像减少只有更好

01:56:13.579 --> 01:56:16.969
他们允许一种函数式风格

01:56:15.379 --> 01:56:18.199
你正在继续用一种语言工作

01:56:16.969 --> 01:56:21.320
实际上这不会是一个

01:56:18.199 --> 01:56:23.479
他们真正的功能性语言

01:56:21.320 --> 01:56:25.429
精心设计，可以组合在一起

01:56:23.479 --> 01:56:28.519
你实际上可以做一些漂亮的事情

01:56:25.429 --> 01:56:31.489
只需将它们一起改变即可

01:56:28.519 --> 01:56:33.050
我真的很爱上他们

01:56:31.489 --> 01:56:35.059
如你所见，我知道你什么时候

01:56:33.050 --> 01:56:36.349
我真的很了解他们，我

01:56:35.059 --> 01:56:37.909
想，我想他们真的

01:56:36.349 --> 01:56:42.760
很棒，他们需要一点时间来适应

01:56:37.909 --> 01:56:45.619
但是那值得做的一切

01:56:42.760 --> 01:56:48.250
好，那就是我今天的发言

01:56:45.619 --> 01:56:53.030
我希望你喜欢它，谢谢

01:56:48.250 --> 01:56:53.030
 [掌声] 

