WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.180 --> 00:00:08.790
好吧，这是开始之前的四分之一

00:00:06.840 --> 00:00:11.789
这些较短的会议将有

00:00:08.790 --> 00:00:14.129
保持快速移动，因此

00:00:11.789 --> 00:00:16.170
今天谈论lambda和方式

00:00:14.129 --> 00:00:19.650
您可以使用它们来简化您的

00:00:16.170 --> 00:00:21.929
代码快速议程，以便您可以决定是否

00:00:19.650 --> 00:00:24.150
你想马上离开我们就开始

00:00:21.929 --> 00:00:26.759
快速评估lambdas 

00:00:24.150 --> 00:00:29.699
我假设这里的大多数人

00:00:26.759 --> 00:00:30.990
希望这里的每个人都看到过lambdas 

00:00:29.699 --> 00:00:33.090
在Java中与他们一起工作了一点

00:00:30.990 --> 00:00:35.700
八，但我们会做一个非常快速的回顾

00:00:33.090 --> 00:00:37.950
首先，然后我们将展示一些简洁

00:00:35.700 --> 00:00:40.200
您可以使用它们的技巧

00:00:37.950 --> 00:00:43.110
有点时间谈论如何

00:00:40.200 --> 00:00:45.330
处理检查的异常，然后

00:00:43.110 --> 00:00:47.370
谈论一些你可以采取的方法

00:00:45.330 --> 00:00:50.460
设计模式并将其转化为

00:00:47.370 --> 00:00:52.170
库方法，然后最后显示一个

00:00:50.460 --> 00:00:54.540
几种可能可以增加

00:00:52.170 --> 00:00:57.600
您的代码的静态类型检查添加

00:00:54.540 --> 00:01:00.810
现在使用lambda进行某种类型的安全性I 

00:00:57.600 --> 00:01:02.880
想强调一点，这里的想法不是

00:01:00.810 --> 00:01:04.530
你与特定的走开

00:01:02.880 --> 00:01:06.150
我所展示的技术我所展示的

00:01:04.530 --> 00:01:08.670
虽然当然欢迎您这样做

00:01:06.150 --> 00:01:10.800
我真正想要你做的是

00:01:08.670 --> 00:01:13.800
受到启发并考虑其他方式

00:01:10.800 --> 00:01:16.740
在您做日常工作时

00:01:13.800 --> 00:01:19.140
你知道你每天晚上黑客运行

00:01:16.740 --> 00:01:22.290
进入事物，并认为嘿lambdas可以

00:01:19.140 --> 00:01:25.490
让它变得更好，以便快速地说一下

00:01:22.290 --> 00:01:28.580
我在无数的遗传学工作

00:01:25.490 --> 00:01:31.260
测试基因以确定一个人的

00:01:28.580 --> 00:01:33.110
易患癌症

00:01:31.260 --> 00:01:36.360
在Java中工作约17年

00:01:33.110 --> 00:01:38.400
我偶尔会发推文

00:01:36.360 --> 00:01:42.840
我提交代码，偶尔我会

00:01:38.400 --> 00:01:45.479
在JavaOne上讲一下最后一件事

00:01:42.840 --> 00:01:48.540
在我们开始滚动之前，我要做到

00:01:45.479 --> 00:01:51.090
清楚不一定是所有

00:01:48.540 --> 00:01:54.150
我向您展示的是表现最好的

00:01:51.090 --> 00:01:57.570
如果您正在写一个做某事的方法

00:01:54.150 --> 00:02:00.330
实时救生应用这些

00:01:57.570 --> 00:02:03.869
这可能不是正确的策略

00:02:00.330 --> 00:02:05.400
尽管在大多数情况下可能会使用

00:02:03.869 --> 00:02:07.619
情况，例如，如果您处于

00:02:05.400 --> 00:02:09.810
也必须与

00:02:07.619 --> 00:02:12.870
数据库或其他任何类型的I / O 

00:02:09.810 --> 00:02:14.609
等待可能会产生的额外罚款

00:02:12.870 --> 00:02:15.120
通过这些方式使用lambda引起的

00:02:14.609 --> 00:02:19.379
是

00:02:15.120 --> 00:02:21.239
会很小，但是你知道

00:02:19.379 --> 00:02:24.599
您担心要进行一些基准测试

00:02:21.239 --> 00:02:27.780
检查出来好吧，首先

00:02:24.599 --> 00:02:30.200
是lambdas，他们显然是

00:02:27.780 --> 00:02:33.209
是在Java 8中引入的

00:02:30.200 --> 00:02:34.709
他们不只是匿名内心

00:02:33.209 --> 00:02:37.319
一些语法糖的课程

00:02:34.709 --> 00:02:39.540
虽然如果它可以帮助您考虑

00:02:37.319 --> 00:02:41.069
他们那样前进，因为它将

00:02:39.540 --> 00:02:44.190
给你一个合理准确的模型

00:02:41.069 --> 00:02:45.959
事情最终如何解决的关键是

00:02:44.190 --> 00:02:48.420
他们代表一个lambda 

00:02:45.959 --> 00:02:51.540
表达式由接口表示

00:02:48.420 --> 00:02:53.010
只有一种非默认方法

00:02:51.540 --> 00:02:54.269
您可以将默认方法添加到

00:02:53.010 --> 00:02:56.310
全天候界面

00:02:54.269 --> 00:02:59.160
但是它必须有一种方法

00:02:56.310 --> 00:03:00.989
否则将引入单个lambda 

00:02:59.160 --> 00:03:02.549
不去做把戏就不会知道

00:03:00.989 --> 00:03:06.150
您在说哪种接口方法

00:03:02.549 --> 00:03:07.620
大概如此，他们

00:03:06.150 --> 00:03:09.599
他们说，嘿，我有一个

00:03:07.620 --> 00:03:11.430
从字符串到整数的函数

00:03:09.599 --> 00:03:12.810
在字符串s中，然后我该怎么办

00:03:11.430 --> 00:03:15.239
得到了这段代码以获取长度

00:03:12.810 --> 00:03:17.370
但是我们当然可以知道摆脱

00:03:15.239 --> 00:03:18.780
那里的字符串重复，我们

00:03:17.370 --> 00:03:21.180
为此可以摆脱卷曲

00:03:18.780 --> 00:03:22.319
大括号和返回和我们

00:03:21.180 --> 00:03:24.269
已经感觉好一点了，然后

00:03:22.319 --> 00:03:28.200
我们意识到S没有目的

00:03:24.269 --> 00:03:31.139
在那里，我们可以这样说，如果这

00:03:28.200 --> 00:03:33.030
对您来说是新手，对不起

00:03:31.139 --> 00:03:38.090
谈话可能会有点困难

00:03:33.030 --> 00:03:42.209
跟着走

00:03:38.090 --> 00:03:44.940
最有可能在您第一次看到Lambda时

00:03:42.209 --> 00:03:49.919
介绍您看到他们介绍

00:03:44.940 --> 00:03:51.989
以流的形式，你

00:03:49.919 --> 00:03:53.790
大概看到这样的例子你

00:03:51.989 --> 00:03:56.370
看到是的，我说我有一堆

00:03:53.790 --> 00:03:58.379
员工，我想找到

00:03:56.370 --> 00:03:59.340
只是我和工程师的薪水

00:03:58.379 --> 00:04:02.010
想做

00:03:59.340 --> 00:04:04.799
平均城市，所以你写

00:04:02.010 --> 00:04:06.480
这样的东西我可以过滤

00:04:04.799 --> 00:04:07.829
我的工程师，所以我只是看着

00:04:06.480 --> 00:04:10.440
我的员工，所以我只是看

00:04:07.829 --> 00:04:12.889
工程师，然后我可以按

00:04:10.440 --> 00:04:16.709
员工城市，最后我可以

00:04:12.889 --> 00:04:18.060
平均他们的工资，这是

00:04:16.709 --> 00:04:21.090
真的很好，我是说我们要看五个

00:04:18.060 --> 00:04:23.219
前面的代码行

00:04:21.090 --> 00:04:24.880
 Java版本会很容易

00:04:23.219 --> 00:04:28.840
线的两到三倍

00:04:24.880 --> 00:04:30.280
现在编码唯一的好处

00:04:28.840 --> 00:04:31.960
虽然你本来不得不写更多

00:04:30.280 --> 00:04:33.520
代码，它也将更难

00:04:31.960 --> 00:04:36.250
阅读，这样您的工作安全就可以了

00:04:33.520 --> 00:04:38.080
增加，但至少至少现在

00:04:36.250 --> 00:04:39.640
如果我们对工作感到满意

00:04:38.080 --> 00:04:41.350
安全我们可以一点点

00:04:39.640 --> 00:04:43.960
更具表现力，也更容易看到

00:04:41.350 --> 00:04:47.380
是否存在错误和

00:04:43.960 --> 00:04:49.750
当然，最初的动机是

00:04:47.380 --> 00:04:52.660
添加所有这些都是为了支持

00:04:49.750 --> 00:04:54.580
并行处理，因为

00:04:52.660 --> 00:04:58.620
在这里什么都做不了

00:04:54.580 --> 00:05:01.690
你应该选择平行吗

00:04:58.620 --> 00:05:02.740
流很好，但是那真的不是

00:05:01.690 --> 00:05:04.540
今天我们要谈论的是

00:05:02.740 --> 00:05:08.070
相反，我想谈谈其他

00:05:04.540 --> 00:05:10.360
第一件事使安全导航无效

00:05:08.070 --> 00:05:13.930
你们有多少人编程过

00:05:10.360 --> 00:05:16.990
杂乱无章，所以您可能会意识到

00:05:13.930 --> 00:05:19.510
这是这里看起来

00:05:16.990 --> 00:05:20.860
像Java代码一样，我正在调用get 

00:05:19.510 --> 00:05:22.570
地址方法，但有那么一点

00:05:20.860 --> 00:05:25.090
点前面的问号和

00:05:22.570 --> 00:05:26.650
然后使用每个后续方法

00:05:25.090 --> 00:05:29.410
连锁电话有那个问号

00:05:26.650 --> 00:05:31.540
这意味着请调用

00:05:29.410 --> 00:05:33.850
我要在上调用的方法

00:05:31.540 --> 00:05:35.560
我刚才提到的对象，除非那样

00:05:33.850 --> 00:05:38.470
在这种情况下，对象恰好为null 

00:05:35.560 --> 00:05:40.960
没关系，只要不给我任何回报，等等

00:05:38.470 --> 00:05:43.390
这个想法是，如果你在一个空间里

00:05:40.960 --> 00:05:44.860
那里什么都可能为空，而你

00:05:43.390 --> 00:05:48.790
需要小心，然后才能使用此

00:05:44.860 --> 00:05:50.170
您知道获取数据的方式，并且

00:05:48.790 --> 00:05:53.260
不用担心会得到null 

00:05:50.170 --> 00:05:55.030
当然，如果您现在指针异常

00:05:53.260 --> 00:05:56.350
如果您还没有编程过

00:05:55.030 --> 00:05:58.510
但您也喜欢Java，以为您

00:05:56.350 --> 00:05:59.770
知道实际上并没有那么大

00:05:58.510 --> 00:06:01.210
优势，因为在Java中它很漂亮

00:05:59.770 --> 00:06:04.780
简单，我只需要检查的是

00:06:01.210 --> 00:06:06.580
员工是否为null，如果

00:06:04.780 --> 00:06:08.230
员工不是吗，我应该检查一下

00:06:06.580 --> 00:06:10.840
以及，然后我应该

00:06:08.230 --> 00:06:15.130
可能检查地址的城市

00:06:10.840 --> 00:06:16.630
员工，然后一旦我确定

00:06:15.130 --> 00:06:19.750
我想通了所有这些

00:06:16.630 --> 00:06:21.430
安全地调用它，所以你知道之后

00:06:19.750 --> 00:06:25.330
你写完这类东西之后

00:06:21.430 --> 00:06:26.560
你会难过，然后你会难过

00:06:25.330 --> 00:06:28.470
因为我是说你在看这个

00:06:26.560 --> 00:06:31.510
你有很多重复

00:06:28.470 --> 00:06:33.220
你当然知道我的意思是

00:06:31.510 --> 00:06:34.930
您链接的更多方法实际上是

00:06:33.220 --> 00:06:37.570
的N个平方代码

00:06:34.930 --> 00:06:39.669
 -是的，除非您做了其他技巧

00:06:37.570 --> 00:06:43.300
与临时变量无论哪种方式

00:06:39.669 --> 00:06:44.800
不开心，所以在Java 8中第一个想法

00:06:43.300 --> 00:06:46.570
您可能拥有的是让我们重构

00:06:44.800 --> 00:06:48.850
域完全可以使用任意位置

00:06:46.570 --> 00:06:50.500
可能为空，如果可以的话

00:06:48.850 --> 00:06:52.600
那太好了，那可能是

00:06:50.500 --> 00:06:54.460
最好的路线，但是如果你做不到

00:06:52.600 --> 00:06:56.620
如果您要处理

00:06:54.460 --> 00:06:59.800
我们可以有空值的域

00:06:56.620 --> 00:07:02.229
仍然使用可选或至少可能

00:06:59.800 --> 00:07:04.449
虐待它，我还没有决定

00:07:02.229 --> 00:07:06.460
这是否构成滥用，但是

00:07:04.449 --> 00:07:08.110
当然很方便，基本上我们

00:07:06.460 --> 00:07:10.090
我们是否使用nullable的可选

00:07:08.110 --> 00:07:11.889
一开始的方法，这样

00:07:10.090 --> 00:07:14.080
要么给我一个礼物可选

00:07:11.889 --> 00:07:16.270
雇员或空的可选

00:07:14.080 --> 00:07:18.310
员工为空，然后我们开始

00:07:16.270 --> 00:07:20.259
指示哪些方法可以调用此方法

00:07:18.310 --> 00:07:22.000
是可选的map方法，它将

00:07:20.259 --> 00:07:24.039
如果存在，则调用该方法

00:07:22.000 --> 00:07:25.930
可选的，如果不是

00:07:24.039 --> 00:07:29.710
空可选，然后当我们完成时

00:07:25.930 --> 00:07:31.419
我们会说或者不知道那是什么

00:07:29.710 --> 00:07:33.430
你想你可能想说其他

00:07:31.419 --> 00:07:37.810
如果是大问题就扔

00:07:33.430 --> 00:07:40.000
但是这里的想法是，现在我们有了

00:07:37.810 --> 00:07:42.039
键入安全导航以及原因

00:07:40.000 --> 00:07:44.889
这行得通是因为我们不再

00:07:42.039 --> 00:07:47.229
说好，这就是我想要做的

00:07:44.889 --> 00:07:48.669
现在我需要调用此方法

00:07:47.229 --> 00:07:50.919
而不是这种方法

00:07:48.669 --> 00:07:52.419
这是我想做的一些事情，但是

00:07:50.919 --> 00:07:55.060
我不会去问他们

00:07:52.419 --> 00:07:57.580
为我和他们做的可选班

00:07:55.060 --> 00:07:58.659
它可以明智地决定是否

00:07:57.580 --> 00:08:01.449
做他们，那有点像

00:07:58.659 --> 00:08:04.720
贯穿整个主题

00:08:01.449 --> 00:08:08.650
这个，但是无论如何你都知道

00:08:04.720 --> 00:08:11.080
我们很高兴，所以这是另一个好

00:08:08.650 --> 00:08:12.789
的例子，我为搬家表示歉意

00:08:11.080 --> 00:08:14.680
新的45分钟很快在这里

00:08:12.789 --> 00:08:19.900
试图通过一切的长度

00:08:14.680 --> 00:08:21.669
如果可能的话，有时候你

00:08:19.900 --> 00:08:23.500
有一个对象列表，你想

00:08:21.669 --> 00:08:25.870
拿第一个不是的

00:08:23.500 --> 00:08:27.370
 null，您知道第一个更好

00:08:25.870 --> 00:08:29.770
比第二要好

00:08:27.370 --> 00:08:32.409
第三，但空值总比没有好

00:08:29.770 --> 00:08:34.120
 null，所以您知道有各种各样

00:08:32.409 --> 00:08:35.950
可以做到这一点的图书馆Lang 

00:08:34.120 --> 00:08:38.229
是其中之一，它具有对象utils 

00:08:35.950 --> 00:08:41.020
具有第一个非null方法的类

00:08:38.229 --> 00:08:44.760
它确实可以满足您的需求

00:08:41.020 --> 00:08:47.200
认为这样做会花费很多

00:08:44.760 --> 00:08:48.279
引用并说第一个是

00:08:47.200 --> 00:08:48.760
不是null那是我要去的那个

00:08:48.279 --> 00:08:50.350
还给你

00:08:48.760 --> 00:08:54.940
如果他们都不是，我不会给你

00:08:50.350 --> 00:08:56.500
返回，所以只要所有

00:08:54.940 --> 00:08:58.570
您提供的数据或至少

00:08:56.500 --> 00:09:01.690
第一个实例之后的所有数据

00:08:58.570 --> 00:09:03.220
便宜，只要它便宜

00:09:01.690 --> 00:09:05.709
提前计算，但这不是

00:09:03.220 --> 00:09:09.279
总是这样，例如，如果您

00:09:05.709 --> 00:09:11.230
运行一个电子商务网站，您说

00:09:09.279 --> 00:09:12.730
好吧，我想得到一些

00:09:11.230 --> 00:09:14.980
给客户的建议

00:09:12.730 --> 00:09:17.050
说服他们买更多的东西

00:09:14.980 --> 00:09:18.130
他们不需要，所以第一件事

00:09:17.050 --> 00:09:19.389
我要做的就是看看他们的内在

00:09:18.130 --> 00:09:21.820
购物车，看看我能不能得到一些

00:09:19.389 --> 00:09:23.740
基于此的建议，如果

00:09:21.820 --> 00:09:25.029
那不起作用，然后让我看看我是否

00:09:23.740 --> 00:09:26.470
可以根据

00:09:25.029 --> 00:09:27.940
客户历史记录，如果没有

00:09:26.470 --> 00:09:30.519
现在工作，让我放弃并展示

00:09:27.940 --> 00:09:33.130
他们一些我们的畅销书，所以

00:09:30.519 --> 00:09:35.170
一切都很好，但问题是

00:09:33.130 --> 00:09:39.339
这些活动可能是

00:09:35.170 --> 00:09:40.930
做起来相当昂贵，而且

00:09:39.339 --> 00:09:42.699
我的意思是，如果我们试图

00:09:40.930 --> 00:09:45.010
减少我们要做的工作量

00:09:42.699 --> 00:09:47.380
如果事实证明购物车能够

00:09:45.010 --> 00:09:48.990
给我们建议，然后我们浪费了

00:09:47.380 --> 00:09:52.899
时间计算其他事情

00:09:48.990 --> 00:09:54.610
相反，如果事实证明购物车

00:09:52.899 --> 00:09:58.389
推荐过程需要很长时间

00:09:54.610 --> 00:10:00.430
回来说不好那么你

00:09:58.389 --> 00:10:02.170
知道所有的时间，如果我想给

00:10:00.430 --> 00:10:04.480
我的客户一个很好的经历

00:10:02.170 --> 00:10:06.550
本来已经在计算

00:10:04.480 --> 00:10:10.839
其他可能的来源

00:10:06.550 --> 00:10:12.339
建议如此反复

00:10:10.839 --> 00:10:14.560
这里的问题是我们做了所有这一切

00:10:12.339 --> 00:10:16.660
在我们将其称为可选之前工作

00:10:14.560 --> 00:10:18.220
当您在Java中执行此操作时

00:10:16.660 --> 00:10:22.500
参数将要计算

00:10:18.220 --> 00:10:22.500
定义序列中的参数值

00:10:23.430 --> 00:10:30.699
所以你知道这让我们伤心

00:10:27.690 --> 00:10:33.010
但是我们可以做的就是说

00:10:30.699 --> 00:10:35.290
好吧，我想先不为空

00:10:33.010 --> 00:10:37.420
是将lambda引入

00:10:35.290 --> 00:10:40.779
在这种情况下，这些将是供应商

00:10:37.420 --> 00:10:42.790
所以现在我们只说这是工作

00:10:40.779 --> 00:10:45.519
我想完成，我想得到

00:10:42.790 --> 00:10:48.279
第一个非null的东西，这开始

00:10:45.519 --> 00:10:50.199
更有意义，因为我们有

00:10:48.279 --> 00:10:52.029
我们可以说不做的供应商

00:10:50.199 --> 00:10:53.709
工作，如果我不需要，或者我们可以说我

00:10:52.029 --> 00:10:56.640
想让它瘫痪

00:10:53.709 --> 00:10:59.680
同时最大化响应速度和

00:10:56.640 --> 00:11:02.439
方法是真的

00:10:59.680 --> 00:11:05.410
直率的我是说我确定

00:11:02.439 --> 00:11:07.209
有它的图书馆，但几乎没有

00:11:05.410 --> 00:11:09.459
值得为此寻找图书馆

00:11:07.209 --> 00:11:11.709
基本上，您需要使用大量的代码

00:11:09.459 --> 00:11:14.890
传入的值流

00:11:11.709 --> 00:11:16.959
真正是供应商，然后

00:11:14.890 --> 00:11:19.750
你要做的第一件事就是你说我想要

00:11:16.959 --> 00:11:20.890
我想调用get方法，然后

00:11:19.750 --> 00:11:23.589
我想过滤掉那些

00:11:20.890 --> 00:11:26.260
不知道，然后最终采取

00:11:23.589 --> 00:11:28.300
第一个元素，如果没有的话

00:11:26.260 --> 00:11:30.880
现在，我就回去

00:11:28.300 --> 00:11:33.430
 null，当然是因为

00:11:30.880 --> 00:11:35.199
如果我串行执行此流

00:11:33.430 --> 00:11:38.260
它实际上不会做任何额外的操作

00:11:35.199 --> 00:11:40.810
工作超出了我必须要做的

00:11:38.260 --> 00:11:42.790
它并行，那么你知道的一切

00:11:40.810 --> 00:11:45.399
如果fork / join符合我们想要的方式

00:11:42.790 --> 00:11:49.839
等等一切都可以得到

00:11:45.399 --> 00:11:55.630
很快就做好了，所以你再次知道

00:11:49.839 --> 00:11:58.269
我们很高兴你可以解决一个问题

00:11:55.630 --> 00:11:59.740
有时会遇到

00:11:58.269 --> 00:12:01.630
关于Java我应该说的很棒的事情是

00:11:59.740 --> 00:12:04.269
随着介绍

00:12:01.630 --> 00:12:06.040
 lambdas仅有一个接口的任何接口

00:12:04.269 --> 00:12:09.670
单一方法自动成为

00:12:06.040 --> 00:12:12.730
有资格成为lambda眼睛或

00:12:09.670 --> 00:12:15.399
不管那个词是什么，但有些

00:12:12.730 --> 00:12:17.019
方法当然有更多或一些

00:12:15.399 --> 00:12:19.149
接口对不起，我有多个

00:12:17.019 --> 00:12:20.800
他们指定的方法，所以如果我已经

00:12:19.149 --> 00:12:22.959
有这样的事情，你知道

00:12:20.800 --> 00:12:27.850
我真的无能为力

00:12:22.959 --> 00:12:31.269
我不能做一个lambda表达式来

00:12:27.850 --> 00:12:33.880
创建此接口的实例，但是

00:12:31.269 --> 00:12:36.430
您可以做的是创建辅助方法

00:12:33.880 --> 00:12:38.350
这些辅助方法可以合而为一

00:12:36.430 --> 00:12:40.600
或更多的lambda，并构造一个

00:12:38.350 --> 00:12:42.279
接口实例为您服务

00:12:40.600 --> 00:12:45.399
您不必回到

00:12:42.279 --> 00:12:47.170
匿名内部类的过去，所以

00:12:45.399 --> 00:12:49.389
这种方法看起来的方式

00:12:47.170 --> 00:12:52.300
我们一对一的例子

00:12:49.389 --> 00:12:55.329
说好游客

00:12:52.300 --> 00:12:57.610
界面需要文件访问者

00:12:55.329 --> 00:12:59.800
界面需要四种方法

00:12:57.610 --> 00:13:01.480
我想递归到

00:12:59.800 --> 00:13:03.100
目录，然后访问目录

00:13:01.480 --> 00:13:06.309
好的，这是我想要的文件

00:13:03.100 --> 00:13:07.839
看着它，然后我该怎么办

00:13:06.309 --> 00:13:09.459
试图查看文件，但失败了

00:13:07.839 --> 00:13:11.829
以及如果我尝试看看

00:13:09.459 --> 00:13:13.329
目录，它失败了，这些是

00:13:11.829 --> 00:13:13.870
所有功能，因为在每个阶段

00:13:13.329 --> 00:13:16.300
有

00:13:13.870 --> 00:13:17.950
返回常量，指示您是否

00:13:16.300 --> 00:13:22.150
想继续寻找更多的东西或

00:13:17.950 --> 00:13:23.440
如果创建这样的方法则不是

00:13:22.150 --> 00:13:25.600
一旦写完就知道

00:13:23.440 --> 00:13:27.520
签名方法的

00:13:25.600 --> 00:13:29.410
实现自己写

00:13:27.520 --> 00:13:31.690
我们知道我们需要创建的地方

00:13:29.410 --> 00:13:33.550
一些新的匿名内部类， 

00:13:31.690 --> 00:13:35.500
然后你知道的第一种方法

00:13:33.550 --> 00:13:39.520
预先访问目录我该怎么办

00:13:35.500 --> 00:13:42.070
天哪，我只是给了一条路和一些

00:13:39.520 --> 00:13:44.020
文件属性，我有一个lambda 

00:13:42.070 --> 00:13:46.540
表达将接受两个

00:13:44.020 --> 00:13:49.300
这些，它将返回我需要的一切

00:13:46.540 --> 00:13:51.400
返回，所以只需调用它和

00:13:49.300 --> 00:13:53.080
您要进行的其他四种其他三种方法

00:13:51.400 --> 00:13:54.250
完全一样的方式，只是不

00:13:53.080 --> 00:13:58.000
将它们放到幻灯片上，因为它们不

00:13:54.250 --> 00:14:01.000
合适，所以很好，但是很多

00:13:58.000 --> 00:14:02.740
在典型的用例中工作

00:14:01.000 --> 00:14:04.720
只是想递归地经历一个

00:14:02.740 --> 00:14:06.430
您要查看的整个文件树

00:14:04.720 --> 00:14:08.200
一切，你一直想保持

00:14:06.430 --> 00:14:10.960
去，在这种情况下访问文件

00:14:08.200 --> 00:14:12.580
方法是唯一有趣的方法

00:14:10.960 --> 00:14:17.200
相反，我们可以做这样的事情

00:14:12.580 --> 00:14:18.400
我们只接受一个lambda 

00:14:17.200 --> 00:14:20.320
表达我们关心的事情

00:14:18.400 --> 00:14:21.820
然后其他人可以具有默认值

00:14:20.320 --> 00:14:23.470
行为证明有一个简单的

00:14:21.820 --> 00:14:25.839
文件访问者类，可以轻松实现

00:14:23.470 --> 00:14:27.279
具有方法的默认行为

00:14:25.839 --> 00:14:30.700
你不想重写的

00:14:27.279 --> 00:14:34.120
像这样的东西，这是一个

00:14:30.700 --> 00:14:35.529
很好的改进，因为您又回来了

00:14:34.120 --> 00:14:38.560
能够让你知道表达

00:14:35.529 --> 00:14:42.310
自己在功能上有一个

00:14:38.560 --> 00:14:44.830
隐藏在其中的问题和

00:14:42.310 --> 00:14:50.080
问题是有很大的机会

00:14:44.830 --> 00:14:52.690
当有人得到文件或路径时

00:14:50.080 --> 00:14:55.260
我很抱歉这是一个

00:14:52.690 --> 00:14:57.279
泛型真的几乎总是路径

00:14:55.260 --> 00:14:59.110
当您获得以下之一时

00:14:57.279 --> 00:15:00.490
那些很有可能是你

00:14:59.110 --> 00:15:02.830
想要做一些可能

00:15:00.490 --> 00:15:06.430
涉及IO，这意味着那里有IO 

00:15:02.830 --> 00:15:09.010
可以抛出异常，但是我们做了什么

00:15:06.430 --> 00:15:11.920
在我们使用标准之前

00:15:09.010 --> 00:15:14.650
 Java util函数中的Java接口

00:15:11.920 --> 00:15:17.160
功能和其中的所有接口

00:15:14.650 --> 00:15:19.690
 Java util Java util功能包

00:15:17.160 --> 00:15:22.300
他们都没有宣布他们扔

00:15:19.690 --> 00:15:25.720
例外，所以我们会遇到

00:15:22.300 --> 00:15:27.610
麻烦，这就是这种去

00:15:25.720 --> 00:15:32.560
被称为接受的问题

00:15:27.610 --> 00:15:34.420
和透明度例外透明度

00:15:32.560 --> 00:15:37.209
本来可以工作的是

00:15:34.420 --> 00:15:39.070
做这样的事情我想做

00:15:37.209 --> 00:15:40.779
为每个文件创建一个文件

00:15:39.070 --> 00:15:42.970
新文件可以引发I / O异常，但

00:15:40.779 --> 00:15:45.370
没关系，因为我说我可以

00:15:42.970 --> 00:15:49.269
抛出一个I / O异常

00:15:45.370 --> 00:15:52.240
方法，这样很好

00:15:49.269 --> 00:15:54.190
很好，但不幸的是，如果您尝试

00:15:52.240 --> 00:15:55.660
编译它，如果您将其写入

00:15:54.190 --> 00:15:56.649
您的IDE，您会弯腰弯腰

00:15:55.660 --> 00:16:00.610
它可以尝试编译它

00:15:56.649 --> 00:16:02.950
会因为我们在

00:16:00.610 --> 00:16:06.700
说我们想抛出一个I / O 

00:16:02.950 --> 00:16:08.709
例外，但与

00:16:06.700 --> 00:16:10.120
 lambda的lambda接口

00:16:08.709 --> 00:16:12.269
我们正在尝试功能界面

00:16:10.120 --> 00:16:15.970
我们正在尝试将其转换为

00:16:12.269 --> 00:16:17.170
天哪，这真是一个无赖

00:16:15.970 --> 00:16:18.820
如果您与

00:16:17.170 --> 00:16:21.010
 lambdas，您可能会遇到

00:16:18.820 --> 00:16:23.410
您正在尝试播放此问题

00:16:21.010 --> 00:16:26.589
处理，突然间，您运行了

00:16:23.410 --> 00:16:28.420
进入这个问题，第一个很好

00:16:26.589 --> 00:16:30.220
你可以做的是你可以的哦

00:16:28.420 --> 00:16:33.100
我应该提到他们确实尝试修复

00:16:30.220 --> 00:16:34.570
这个但严格的理论很难

00:16:33.100 --> 00:16:35.649
特别难，因为

00:16:34.570 --> 00:16:38.019
他们既不是协变也不是

00:16:35.649 --> 00:16:39.760
相反，它们是联合类型

00:16:38.019 --> 00:16:41.199
真的是因为你可能会抛出

00:16:39.760 --> 00:16:42.940
 I / O异常或

00:16:41.199 --> 00:16:44.829
中断的异常，它是

00:16:42.940 --> 00:16:46.360
引人入胜的阅读清单

00:16:44.829 --> 00:16:47.980
邮件列表，看看他们如何

00:16:46.360 --> 00:16:50.550
试图解决这个问题并最终解决

00:16:47.980 --> 00:16:53.620
只是真的不会发生，所以

00:16:50.550 --> 00:16:56.380
我们该怎么做才能做好一件事

00:16:53.620 --> 00:16:58.390
我们能做的就是说得好

00:16:56.380 --> 00:17:01.360
我们将在lambda中捕获异常

00:16:58.390 --> 00:17:02.910
表达，如果我们得到它，我们将

00:17:01.360 --> 00:17:05.410
将其转换为运行时异常

00:17:02.910 --> 00:17:07.059
您知道的标准技巧

00:17:05.410 --> 00:17:10.900
随时在整个Java中加入胡椒

00:17:07.059 --> 00:17:13.000
您检查了我不知道的异常

00:17:10.900 --> 00:17:14.350
关于你，但我感觉不太好

00:17:13.000 --> 00:17:16.720
这个

00:17:14.350 --> 00:17:19.380
这花了我的一线，炸毁了

00:17:16.720 --> 00:17:21.520
变成了我不知道的七八班轮

00:17:19.380 --> 00:17:23.679
我有一堆东西

00:17:21.520 --> 00:17:25.419
不在乎你知道某个地方

00:17:23.679 --> 00:17:28.990
埋在里面是我创建新文件

00:17:25.419 --> 00:17:32.650
电话，但其他一切就是

00:17:28.990 --> 00:17:34.330
只是让我悲惨，所以你开始

00:17:32.650 --> 00:17:35.620
好想这是不幸的，并且

00:17:34.330 --> 00:17:38.470
那么你认为接下来的事情很好

00:17:35.620 --> 00:17:40.120
也许他们没有尽力

00:17:38.470 --> 00:17:40.990
异常透明性，如果我们

00:17:40.120 --> 00:17:43.630
使用泛型

00:17:40.990 --> 00:17:46.510
所以我们说嘿，而不是使用消费者

00:17:43.630 --> 00:17:50.050
让我们尝试一个可以抛出的电子消费者

00:17:46.510 --> 00:17:52.330
一些例外类型e 

00:17:50.050 --> 00:17:53.650
无法捕获通用异常类型

00:17:52.330 --> 00:17:57.010
您当然可以声明

00:17:53.650 --> 00:17:58.750
你把它扔出去，这样就解决了，然后

00:17:57.010 --> 00:18:00.700
我们甚至可以想象嘿，如果Java有

00:17:58.750 --> 00:18:02.110
在某种奇怪的工作中做到了这一点

00:18:00.700 --> 00:18:03.340
然后是可迭代的接口

00:18:02.110 --> 00:18:05.440
每个方法都有一个

00:18:03.340 --> 00:18:07.360
消费者本来可以

00:18:05.440 --> 00:18:09.309
消费者，然后一切都会

00:18:07.360 --> 00:18:13.330
只是想出了我们想要的方式

00:18:09.309 --> 00:18:17.530
到和有趣的是，这

00:18:13.330 --> 00:18:19.540
确实有效，但是你会

00:18:17.530 --> 00:18:20.890
立即通知每个人的签名

00:18:19.540 --> 00:18:22.929
只是有点混乱

00:18:20.890 --> 00:18:27.250
因为我突然不得不把这个

00:18:22.929 --> 00:18:29.500
额外的通用参数信息，但

00:18:27.250 --> 00:18:32.290
你知道我的意思是

00:18:29.500 --> 00:18:34.150
工作，如果你有更多的东西就行不通

00:18:32.290 --> 00:18:36.190
而不是您需要的一种例外

00:18:34.150 --> 00:18:37.929
才能宣布你丢了你

00:18:36.190 --> 00:18:39.580
可以尝试使您的事情变得通用

00:18:37.929 --> 00:18:42.940
和两个参数和类型推断

00:18:39.580 --> 00:18:45.910
会完全为您纾困， 

00:18:42.940 --> 00:18:47.559
所以那并不快乐

00:18:45.910 --> 00:18:50.770
通常到最后你就决定了

00:18:47.559 --> 00:18:52.690
这可能不值得，并且

00:18:50.770 --> 00:18:54.730
所以你很难过，然后你以为你

00:18:52.690 --> 00:18:57.460
知道为什么我难过我难过是因为

00:18:54.730 --> 00:18:59.320
检查异常，现在您认为

00:18:57.460 --> 00:19:02.380
天哪检查异常，以及如何

00:18:59.320 --> 00:19:05.170
你很生气，当我们生气时

00:19:02.380 --> 00:19:07.150
有时会做些轻率的事情，其中​​之一

00:19:05.170 --> 00:19:10.210
那些轻率的事情可能只是为了摆脱

00:19:07.150 --> 00:19:14.170
问题和解决方案是

00:19:10.210 --> 00:19:15.970
只是摆脱问题，所以有

00:19:14.170 --> 00:19:18.970
多个库可以做到这一点

00:19:15.970 --> 00:19:21.330
我喜欢Juke lambda库或

00:19:18.970 --> 00:19:23.590
只是珠宝库，你可以称之为

00:19:21.330 --> 00:19:25.420
他们所做的每一件事

00:19:23.590 --> 00:19:27.370
功能接口和java.util 

00:19:25.420 --> 00:19:29.740
他们已经创建了一个功能包

00:19:27.370 --> 00:19:32.500
随播介面名称

00:19:29.740 --> 00:19:34.809
在它和那个同伴之前检查

00:19:32.500 --> 00:19:37.480
界面具有相同的方法，但是

00:19:34.809 --> 00:19:39.100
允许扔任何东西，然后

00:19:37.480 --> 00:19:43.750
他们提供了一系列静态

00:19:39.100 --> 00:19:46.929
例如

00:19:43.750 --> 00:19:48.910
受检查的消费者，它将调用

00:19:46.929 --> 00:19:51.340
检查消费者，如有异常

00:19:48.910 --> 00:19:54.100
被扔掉，它将作为一个罚球

00:19:51.340 --> 00:19:54.610
运行一个运行时异常否则

00:19:54.100 --> 00:19:57.010
携带

00:19:54.610 --> 00:19:59.460
所以这意味着现在你

00:19:57.010 --> 00:20:02.350
可以编写如下代码

00:19:59.460 --> 00:20:04.450
我所要做的就是说不受限制

00:20:02.350 --> 00:20:07.480
消费者和我的lambda 

00:20:04.450 --> 00:20:09.700
这样表达，我回到- 

00:20:07.480 --> 00:20:11.529
你知道我可以实际使用的地方

00:20:09.700 --> 00:20:15.039
现在有点问题

00:20:11.529 --> 00:20:17.769
因为我不再是我了

00:20:15.039 --> 00:20:19.419
抛出或声明抛出I / O 

00:20:17.769 --> 00:20:21.880
例外，我的意思是我可以说我愿意

00:20:19.419 --> 00:20:23.470
但是我真的不再了，所以

00:20:21.880 --> 00:20:26.740
除非你想，否则这是一个问题

00:20:23.470 --> 00:20:28.210
抓住并重新转换它，以便您知道是否

00:20:26.740 --> 00:20:30.340
你认为其中有价值

00:20:28.210 --> 00:20:32.049
检查异常，那不是

00:20:30.340 --> 00:20:34.960
太好了，还有一点

00:20:32.049 --> 00:20:37.389
冗长，所以也许不快乐，但至少

00:20:34.960 --> 00:20:42.760
你知道我们不再难过，我们很友善

00:20:37.389 --> 00:20:44.679
接下来我想谈的是

00:20:42.760 --> 00:20:46.299
设计模式是什么设计

00:20:44.679 --> 00:20:48.820
模式，如果你去维基百科说

00:20:46.299 --> 00:20:51.279
天哪，这是一个通用的可重复解决方案

00:20:48.820 --> 00:20:53.289
常见问题哇

00:20:51.279 --> 00:20:55.419
通常这是一种解决方案

00:20:53.289 --> 00:20:57.669
听起来很棒，而且很适合

00:20:55.419 --> 00:20:59.830
通常发生什么是什么

00:20:57.669 --> 00:21:03.309
不喜欢斯图尔特·霍洛威

00:20:59.830 --> 00:21:05.500
另一只手说这是一种代码气味

00:21:03.309 --> 00:21:08.620
倾向于指出缺陷

00:21:05.500 --> 00:21:09.940
语言及其气味的原因是

00:21:08.620 --> 00:21:12.940
因为第三个字和

00:21:09.940 --> 00:21:15.880
定义在您执行时可重复

00:21:12.940 --> 00:21:17.799
您重复一些的设计模式

00:21:15.880 --> 00:21:20.460
别人做过的代码

00:21:17.799 --> 00:21:23.380
你要一遍又一遍地重复

00:21:20.460 --> 00:21:26.320
很多图案都是形式

00:21:23.380 --> 00:21:27.610
在这里，这个样板代码然后

00:21:26.320 --> 00:21:29.470
你实际上想做的事情

00:21:27.610 --> 00:21:32.200
然后再写一些样板代码

00:21:29.470 --> 00:21:34.510
如果你用lambdas看看

00:21:32.200 --> 00:21:35.230
你介意啊，我想我们有一个

00:21:34.510 --> 00:21:38.070
解

00:21:35.230 --> 00:21:40.179
所以先举几个例子

00:21:38.070 --> 00:21:42.190
资源管理有时称为

00:21:40.179 --> 00:21:44.620
布置图案，以便追溯到

00:21:42.190 --> 00:21:46.539
 Java 6或更早版本

00:21:44.620 --> 00:21:47.889
说一个输入流

00:21:46.539 --> 00:21:49.510
完成所有这些工作

00:21:47.889 --> 00:21:51.880
首先得到它，然后你必须做一个

00:21:49.510 --> 00:21:53.679
尝试阻止，然后记得关闭

00:21:51.880 --> 00:21:55.179
最终块不在try块中

00:21:53.679 --> 00:21:56.380
因为你不能保证你会

00:21:55.179 --> 00:21:57.730
关闭声明，否则您将拥有

00:21:56.380 --> 00:22:01.630
资源泄漏，然后每个人的

00:21:57.730 --> 00:22:04.270
不开心，还可以，那很糟糕， 

00:22:01.630 --> 00:22:07.690
试图都解决这个问题

00:22:04.270 --> 00:22:08.350
减轻痛苦，也预防

00:22:07.690 --> 00:22:10.600
介绍

00:22:08.350 --> 00:22:12.549
 lambdas融入语言josh bloch 

00:22:10.600 --> 00:22:14.950
说得好为什么我们不为什么我们没有

00:22:12.549 --> 00:22:17.890
最后尝试我们的问题的新尝试

00:22:14.950 --> 00:22:20.620
尝试使用资源语法，所以这

00:22:17.890 --> 00:22:22.690
当我这样做时，Java 7会变得更好

00:22:20.620 --> 00:22:26.260
这我不必担心关闭

00:22:22.690 --> 00:22:28.390
流，但有一个问题

00:22:26.260 --> 00:22:31.360
那很好，我对你一无所知

00:22:28.390 --> 00:22:33.840
但是我变老了，健忘了，所以

00:22:31.360 --> 00:22:37.270
我可能会写这样的东西

00:22:33.840 --> 00:22:39.400
我只是说嘿，让我过去

00:22:37.270 --> 00:22:41.530
打开流并进入流程

00:22:39.400 --> 00:22:44.620
完成它，但现在我没有关闭它

00:22:41.530 --> 00:22:48.539
而且我有资源泄漏，这是

00:22:44.620 --> 00:22:52.240
糟糕的API会让人们犯错误

00:22:48.539 --> 00:22:53.470
所以让我们看一下我的意思是

00:22:52.240 --> 00:22:55.419
不好，实际上有

00:22:53.470 --> 00:22:57.970
另一个问题也是

00:22:55.419 --> 00:23:01.210
整个语言介绍

00:22:57.970 --> 00:23:03.789
仅当您实现自动时才有效

00:23:01.210 --> 00:23:06.220
可以关闭，例如，如果我想

00:23:03.789 --> 00:23:07.809
用它来管理我要处理的锁

00:23:06.220 --> 00:23:09.730
有一些银行帐户，我需要

00:23:07.809 --> 00:23:13.000
确保我专门访问

00:23:09.730 --> 00:23:15.370
当我很好的时候我就搞砸了，我说

00:23:13.000 --> 00:23:19.030
嘿，让我们尝试使用资源

00:23:15.370 --> 00:23:22.360
为此，我被告知锁不能

00:23:19.030 --> 00:23:23.890
转换为自动关闭

00:23:22.360 --> 00:23:25.900
表示该语言功能

00:23:23.890 --> 00:23:32.830
被介绍来帮助我没有帮助

00:23:25.900 --> 00:23:35.860
所以我很伤心，但是如果你停下来思考

00:23:32.830 --> 00:23:37.330
关于这个，即使这是

00:23:35.860 --> 00:23:40.809
有问题的，因为我不仅可以

00:23:37.330 --> 00:23:42.370
忘记在某种意义上关闭锁

00:23:40.809 --> 00:23:43.659
你不应该掌握

00:23:42.370 --> 00:23:46.750
一个帐户并对其进行处理

00:23:43.659 --> 00:23:49.929
除非可以安全访问，否则

00:23:46.750 --> 00:23:50.890
也许不用考虑锁

00:23:49.929 --> 00:23:53.380
每时每刻

00:23:50.890 --> 00:23:55.870
让我们让别人来管理

00:23:53.380 --> 00:23:58.780
对我们来说，我们得到类似

00:23:55.870 --> 00:24:01.120
这是我们的客户经理

00:23:58.780 --> 00:24:02.740
上课，里面有一把锁

00:24:01.120 --> 00:24:05.020
里面有一个帐户，但请注意

00:24:02.740 --> 00:24:06.970
他们是私人的，我们的公共事物

00:24:05.020 --> 00:24:09.280
提供我们提供的API是

00:24:06.970 --> 00:24:12.280
能够使用该帐户并

00:24:09.280 --> 00:24:14.770
该API将处理获取锁

00:24:12.280 --> 00:24:17.020
然后做的是

00:24:14.770 --> 00:24:18.790
指定，然后最终为您解锁

00:24:17.020 --> 00:24:20.799
可以做完全一样的事情

00:24:18.790 --> 00:24:21.940
与iostream示例来自

00:24:20.799 --> 00:24:23.740
较早

00:24:21.940 --> 00:24:25.660
你已经完成了

00:24:23.740 --> 00:24:27.280
意思是冬眠在会议上这样做

00:24:25.660 --> 00:24:29.800
 API，如果您想获取基础

00:24:27.280 --> 00:24:32.830
续集连接你做点什么

00:24:29.800 --> 00:24:34.570
类似于这种技巧和

00:24:32.830 --> 00:24:36.670
现在写的代码实际上看起来

00:24:34.570 --> 00:24:38.770
真的很甜蜜，因为我不得不说

00:24:36.670 --> 00:24:40.270
我想做的事

00:24:38.770 --> 00:24:43.360
帐户以及我想做什么

00:24:40.270 --> 00:24:46.660
想借记更多

00:24:43.360 --> 00:24:51.280
少出错的地方，一切都很好，我们

00:24:46.660 --> 00:24:52.390
快乐好吧，所以你知道我们很高兴我们

00:24:51.280 --> 00:24:54.700
认为天哪，也许我想服用

00:24:52.390 --> 00:24:57.250
休息，因为我感到懒惰，并且

00:24:54.700 --> 00:24:59.680
懒惰是另一回事， 

00:24:57.250 --> 00:25:01.300
模式是有的

00:24:59.680 --> 00:25:04.750
仔细检查您的锁定模式

00:25:01.300 --> 00:25:07.000
可能看过你要去的地方

00:25:04.750 --> 00:25:08.560
想要评估懒惰，如果您

00:25:07.000 --> 00:25:11.140
想懒惰地评价你

00:25:08.560 --> 00:25:12.130
您首先获得锁或先检查

00:25:11.140 --> 00:25:14.890
看看它是否已经被评估

00:25:12.130 --> 00:25:17.290
如果还没有，你就抓住一把锁，然后

00:25:14.890 --> 00:25:19.810
您再次检查，因为内存型号

00:25:17.290 --> 00:25:21.700
然后如果你仍然没有

00:25:19.810 --> 00:25:23.020
进行任何计算并

00:25:21.700 --> 00:25:24.460
您需要确保将其存储在

00:25:23.020 --> 00:25:27.280
易失性变量或实际上不是

00:25:24.460 --> 00:25:28.660
工作，所以要做很多工作

00:25:27.280 --> 00:25:30.910
希望能够将其放入

00:25:28.660 --> 00:25:34.030
库，实际上这已经完成了

00:25:30.910 --> 00:25:36.100
所以还有一个好的图书馆

00:25:34.030 --> 00:25:37.990
处理lambda表达式是

00:25:36.100 --> 00:25:40.360
 Babri库，它以前被称为Java 

00:25:37.990 --> 00:25:42.070
 Oracle语，但后来Oracle说Java lang语

00:25:40.360 --> 00:25:44.440
其中包含Java一词

00:25:42.070 --> 00:25:47.860
是受版权保护的，所以他们一字不漏

00:25:44.440 --> 00:25:49.860
 Java颠倒了，让Barbara成功了

00:25:47.860 --> 00:25:52.930
当您更好地看他们的徽标时，它可以工作

00:25:49.860 --> 00:25:55.090
而且有一个很好的懒惰实现

00:25:52.930 --> 00:25:58.450
这样我们就可以看到它是如何工作的

00:25:55.090 --> 00:26:00.400
真的很快，所以我可以解雇杰伊

00:25:58.450 --> 00:26:01.870
如果您没有用过杰伊，请给我壳

00:26:00.400 --> 00:26:03.970
应该使用Jay Shell，即使您

00:26:01.870 --> 00:26:06.490
仍在Java 8上安装Java 9 

00:26:03.970 --> 00:26:10.720
周围，​​以便您可以使用JCL，然后让我们

00:26:06.490 --> 00:26:13.990
看到我最好做一些进口，所以进口

00:26:10.720 --> 00:26:16.720
我需要的一切，然后我将创建一个

00:26:13.990 --> 00:26:17.890
懒惰的字符串在这里和作品

00:26:16.720 --> 00:26:19.870
计算这个字符串是我要

00:26:17.890 --> 00:26:21.040
打印一些东西说我

00:26:19.870 --> 00:26:23.410
思考，所以我们可以看看是否有效

00:26:21.040 --> 00:26:25.000
完成后最后返回一些

00:26:23.410 --> 00:26:26.740
价值，因为我们正努力变得懒惰

00:26:25.000 --> 00:26:29.800
它说回信给我们，我们是流浪汉，但是

00:26:26.740 --> 00:26:32.530
没关系，我实际上可以说懒

00:26:29.800 --> 00:26:34.060
这个懒惰的方法实际评估过吗

00:26:32.530 --> 00:26:35.770
但我会说不，不是

00:26:34.060 --> 00:26:38.320
但是如果我说懒

00:26:35.770 --> 00:26:39.790
得到它说我在想，然后

00:26:38.320 --> 00:26:41.620
它给了我答案，那就是

00:26:39.790 --> 00:26:43.540
很好，如果我问过

00:26:41.620 --> 00:26:45.880
现在评估它说它当然有

00:26:43.540 --> 00:26:49.780
曾经，如果我说再来一次

00:26:45.880 --> 00:26:52.450
不必再次计算它，因此您

00:26:49.780 --> 00:26:53.950
知道某事的另一个好例子

00:26:52.450 --> 00:26:55.840
那是以前的模式，现在是

00:26:53.950 --> 00:26:57.670
库方法以及何时考虑

00:26:55.840 --> 00:27:00.490
使用的所有代码

00:26:57.670 --> 00:27:02.290
之前的双重检查锁定模式

00:27:00.490 --> 00:27:04.090
人们意识到它没有用

00:27:02.290 --> 00:27:05.770
除非它不稳定，然后人们

00:27:04.090 --> 00:27:07.930
必须去改变所有的代码，如果

00:27:05.770 --> 00:27:10.030
在这里发生了同样的事情

00:27:07.930 --> 00:27:14.590
一种需要的库方法

00:27:10.030 --> 00:27:16.330
改变了这么大的进步

00:27:14.590 --> 00:27:18.460
设计模式承认相似

00:27:16.330 --> 00:27:20.230
接近但我接下来的事情

00:27:18.460 --> 00:27:23.640
想谈谈的是我们可以

00:27:20.230 --> 00:27:26.860
通过lambdas提高类型安全性

00:27:23.640 --> 00:27:30.520
 Java中有很多api 

00:27:26.860 --> 00:27:32.080
依赖这些API通常是

00:27:30.520 --> 00:27:34.840
在某些情况下使用反射的

00:27:32.080 --> 00:27:37.690
方式，他们可能会依靠使用

00:27:34.840 --> 00:27:40.750
告诉他们要反映什么的字符串

00:27:37.690 --> 00:27:43.090
这不是一个强类型的代码，它是一个

00:27:40.750 --> 00:27:45.460
字符串输入，我不记得是谁

00:27:43.090 --> 00:27:48.280
首先说，但这是一个完美的方法

00:27:45.460 --> 00:27:51.760
措辞，这是一个问题

00:27:48.280 --> 00:27:53.380
因为重构工具并不是真的

00:27:51.760 --> 00:27:56.140
知道你在说一种方法

00:27:53.380 --> 00:27:57.610
名称，如果您用引号引起来， 

00:27:56.140 --> 00:27:59.620
编译器不知道，所以不会

00:27:57.610 --> 00:28:00.970
能够在编译时捕捉错别字

00:27:59.620 --> 00:28:03.190
时间，这意味着你推迟了事情

00:28:00.970 --> 00:28:04.960
到运行时，通常可能会发生

00:28:03.190 --> 00:28:06.430
您在向老板演示时知道

00:28:04.960 --> 00:28:09.810
那样的东西或你知道的东西

00:28:06.430 --> 00:28:12.250
实际的现场制作不是很好

00:28:09.810 --> 00:28:14.520
但是lambda表达式提供了很好的

00:28:12.250 --> 00:28:17.950
在这里，实际上是第一个

00:28:14.520 --> 00:28:19.990
这个例子让我们看一下

00:28:17.950 --> 00:28:22.000
做一个比较器需要什么

00:28:19.990 --> 00:28:24.910
如果您还记得合同

00:28:22.000 --> 00:28:26.680
比较器有点复杂

00:28:24.910 --> 00:28:28.570
因为你需要确保

00:28:26.680 --> 00:28:29.920
这种反对称性

00:28:28.570 --> 00:28:31.900
有这种一致性，有一个

00:28:29.920 --> 00:28:33.790
一堆东​​西，所以很容易

00:28:31.900 --> 00:28:35.500
写一个比较器，弄错了，所以

00:28:33.790 --> 00:28:38.680
拥有某种图书馆是很好的

00:28:35.500 --> 00:28:41.410
让您做到这一点

00:28:38.680 --> 00:28:43.630
你原谅我，所以普通人

00:28:41.410 --> 00:28:47.250
 Apache Commons的beans utils软件包

00:28:43.630 --> 00:28:49.080
有一个API，可让您执行

00:28:47.250 --> 00:28:50.910
你必须建立一个比较器链

00:28:49.080 --> 00:28:53.280
然后你可以说很好，让我们

00:28:50.910 --> 00:28:56.340
说我在比较人让我比较

00:28:53.280 --> 00:28:58.170
在姓氏上，如果我得到领带， 

00:28:56.340 --> 00:29:01.080
我会根据第一个

00:28:58.170 --> 00:29:03.090
名称，不幸的是这样做

00:29:01.080 --> 00:29:05.220
无需过多关注泛型

00:29:03.090 --> 00:29:06.810
大概是在仿制药之前完成的，所以我

00:29:05.220 --> 00:29:09.240
实际上必须投下它才能得到我

00:29:06.810 --> 00:29:11.550
想要这样看起来不太好但是

00:29:09.240 --> 00:29:13.890
很多不是Java的错

00:29:11.550 --> 00:29:17.280
那只是我们本来可以拥有的API 

00:29:13.890 --> 00:29:20.160
一个看起来更好的API，在这里我可以说

00:29:17.280 --> 00:29:22.410
只想要比较器链

00:29:20.160 --> 00:29:25.020
人类，我想你知道用

00:29:22.410 --> 00:29:28.260
姓和名的抢七游戏

00:29:25.020 --> 00:29:30.570
这绝对是一个进步，但是

00:29:28.260 --> 00:29:34.470
它仍然是字符串输入，仍然

00:29:30.570 --> 00:29:37.560
问题的机会和问题

00:29:34.470 --> 00:29:41.520
让我们伤心的是，这是

00:29:37.560 --> 00:29:44.040
实际上在jdk本身解决了

00:29:41.520 --> 00:29:46.010
比较器类添加了一些新方法

00:29:44.040 --> 00:29:48.120
最有趣的是

00:29:46.010 --> 00:29:49.740
比较或最有趣的一对

00:29:48.120 --> 00:29:53.010
猜测是第一个是比较

00:29:49.740 --> 00:29:55.290
我要创建的静态方法

00:29:53.010 --> 00:29:58.680
比较器，基于

00:29:55.290 --> 00:30:00.510
一些映射我的存在或我的存在的函数

00:29:58.680 --> 00:30:02.970
对已经存在的东西

00:30:00.510 --> 00:30:04.590
实施可比性，然后

00:30:02.970 --> 00:30:07.080
另一个很棒的方法是

00:30:04.590 --> 00:30:09.390
说的方法，如果不是

00:30:07.080 --> 00:30:10.980
那你不知道区分两者

00:30:09.390 --> 00:30:13.500
然后让我们尝试，让我们尝试一下

00:30:10.980 --> 00:30:15.450
其他方法，因此您现在可以创建一个

00:30:13.500 --> 00:30:18.150
比较器仅需几行

00:30:15.450 --> 00:30:20.760
代码，这几行代码是

00:30:18.150 --> 00:30:22.140
完全保护您要输入的ID 

00:30:20.760 --> 00:30:23.340
了解它的重构工具

00:30:22.140 --> 00:30:25.080
将要了解它的代码分析

00:30:23.340 --> 00:30:26.730
假设他们在那里的工具

00:30:25.080 --> 00:30:28.080
他们要加快lambda的速度

00:30:26.730 --> 00:30:30.840
将能够处理这个

00:30:28.080 --> 00:30:34.890
很好，所以你又知道

00:30:30.840 --> 00:30:39.420
那很棒，它看起来像

00:30:34.890 --> 00:30:41.040
在另一个例子中，这个是我

00:30:39.420 --> 00:30:42.330
将会谈论J单元5，因为

00:30:41.040 --> 00:30:45.840
它刚出来，看起来

00:30:42.330 --> 00:30:47.700
实际上是波士顿，而他们

00:30:45.840 --> 00:30:51.990
有几种方法

00:30:47.700 --> 00:30:53.730
参数化测试的一种方法是

00:30:51.990 --> 00:30:56.190
在您的测试上方有一个注释

00:30:53.730 --> 00:30:57.930
一系列的字符串，每个字符串是

00:30:56.190 --> 00:31:00.460
应该以某种方式代表

00:30:57.930 --> 00:31:01.840
您想要的各种数据

00:31:00.460 --> 00:31:03.760
提供给您的测试我应该提到

00:31:01.840 --> 00:31:07.240
参数化测试基本上就是测试

00:31:03.760 --> 00:31:09.340
以不同的值运行，而您

00:31:07.240 --> 00:31:10.870
一点一点地提供值

00:31:09.340 --> 00:31:13.150
这是编写大量测试的一种方式

00:31:10.870 --> 00:31:16.750
无需编写大量代码，因此

00:31:13.150 --> 00:31:18.310
注释方法很好

00:31:16.750 --> 00:31:20.080
您在其中列出了所有参数

00:31:18.310 --> 00:31:22.300
注释不是那么灵活

00:31:20.080 --> 00:31:23.920
如果您有一个参数，则可以正常工作

00:31:22.300 --> 00:31:25.960
更普遍地说，他们有这个东西

00:31:23.920 --> 00:31:29.710
你可以说你有一些方法

00:31:25.960 --> 00:31:31.600
返回说一堆参数

00:31:29.710 --> 00:31:35.410
其中参数基本上是某种形式

00:31:31.600 --> 00:31:37.030
元组，然后你可以写你的

00:31:35.410 --> 00:31:38.770
参数化看起来像这样的测试

00:31:37.030 --> 00:31:41.680
你说我是参数测试

00:31:38.770 --> 00:31:43.570
而不是常规测试和数据

00:31:41.680 --> 00:31:46.050
将来自此方法字符串

00:31:43.570 --> 00:31:48.190
整数值，然后我进行了测试

00:31:46.050 --> 00:31:52.750
我确实要确认

00:31:48.190 --> 00:31:54.910
如果我解析了或者对不起

00:31:52.750 --> 00:31:56.170
我取一个整数，然后将其旋转

00:31:54.910 --> 00:31:58.060
变成我所得到的字符串

00:31:56.170 --> 00:32:01.270
期望得到这样，那就是

00:31:58.060 --> 00:32:03.250
很好，这很好，但是

00:32:01.270 --> 00:32:05.050
字符串类型，所以有一些

00:32:03.250 --> 00:32:07.570
问题首先是我可能拼错了

00:32:05.050 --> 00:32:09.250
字符串值很明显，但是有

00:32:07.570 --> 00:32:13.530
另一个更深层次的问题是

00:32:09.250 --> 00:32:16.810
那当我测试方法的int值时

00:32:13.530 --> 00:32:18.550
需要一个字符串和一个我没有的整数

00:32:16.810 --> 00:32:20.200
保证那实际上是什么

00:32:18.550 --> 00:32:21.850
从字符串和值返回

00:32:20.200 --> 00:32:25.540
方法，它只是一个参数流

00:32:21.850 --> 00:32:27.070
这些参数实例可能不会

00:32:25.540 --> 00:32:29.380
有一个字符串和一个整数，他们可能没有

00:32:27.070 --> 00:32:32.770
甚至只有两个元素

00:32:29.380 --> 00:32:36.220
一或三片叶子

00:32:32.770 --> 00:32:37.990
被期望，但事实证明

00:32:36.220 --> 00:32:39.640
第五单元的另一件事是

00:32:37.990 --> 00:32:42.790
真棒，可以修复

00:32:39.640 --> 00:32:45.400
这就是所谓的动态

00:32:42.790 --> 00:32:48.610
测试，所以以J为单位的动态测试是

00:32:45.400 --> 00:32:50.800
基本上是在

00:32:48.610 --> 00:32:53.170
运行时而不是完全指定

00:32:50.800 --> 00:32:56.560
他们在编译时和有趣的事情

00:32:53.170 --> 00:32:59.230
在这种特殊情况下，我们可以

00:32:56.560 --> 00:33:02.560
将事情推迟到运行时

00:32:59.230 --> 00:33:04.480
给我们更多的编译时类型安全性

00:33:02.560 --> 00:33:06.790
我只是喜欢而具有讽刺意味的是， 

00:33:04.480 --> 00:33:09.400
我们可以做到的方式对

00:33:06.790 --> 00:33:11.230
首先我们之前的例子

00:33:09.400 --> 00:33:13.340
我将使用元组类

00:33:11.230 --> 00:33:14.660
再次从乔克·拉姆达

00:33:13.340 --> 00:33:17.750
许多不同的库提供

00:33:14.660 --> 00:33:19.820
这些天的元组，但这是一个不错的类型

00:33:17.750 --> 00:33:21.680
安全类，它在

00:33:19.820 --> 00:33:23.030
一般以以下类型进行参数化

00:33:21.680 --> 00:33:26.420
您的第一个和第二个元素

00:33:23.030 --> 00:33:29.630
元组，所以我有一个元组流

00:33:26.420 --> 00:33:30.890
字符串和整数，然后是我想要的

00:33:29.630 --> 00:33:33.500
我要做的是把

00:33:30.890 --> 00:33:35.270
那些，第一张地图是一张地图

00:33:33.500 --> 00:33:37.040
从流类第二张地图

00:33:35.270 --> 00:33:39.470
您在这里看到的是来自

00:33:37.040 --> 00:33:41.960
元组类有点奇怪

00:33:39.470 --> 00:33:44.840
并尽量不要担心太多

00:33:41.960 --> 00:33:46.070
现在，但是结果是我

00:33:44.840 --> 00:33:48.380
下降到需要弦的东西

00:33:46.070 --> 00:33:50.420
然后一个整数建立我的动态

00:33:48.380 --> 00:33:52.940
测试，当我建立动态测试时

00:33:50.420 --> 00:33:55.760
首先要说的是测试

00:33:52.940 --> 00:33:57.410
应该被调用，以便它通过时

00:33:55.760 --> 00:33:59.450
或失败，它很好地显示在

00:33:57.410 --> 00:34:04.100
输出，然后进行实际测试

00:33:59.450 --> 00:34:07.270
这很有效，很好

00:34:04.100 --> 00:34:10.850
类型安全，但有点混乱

00:34:07.270 --> 00:34:12.650
因为有这个奇怪的地图元组地图

00:34:10.850 --> 00:34:15.830
我不想发生的事情

00:34:12.650 --> 00:34:17.780
要考虑，我不知道

00:34:15.830 --> 00:34:21.740
我感觉不太干净

00:34:17.780 --> 00:34:24.350
对我来说，但如果我们创造一个小

00:34:21.740 --> 00:34:26.780
静态助手方法，我们可以做的事情

00:34:24.350 --> 00:34:30.380
好多了，这是一种方法

00:34:26.780 --> 00:34:32.930
参数，这是一个

00:34:30.380 --> 00:34:34.520
有两个参数的函数，然后

00:34:32.930 --> 00:34:36.200
您可以为创建一个类似的版本

00:34:34.520 --> 00:34:38.240
三，四，五等等

00:34:36.200 --> 00:34:42.530
论据，但它的运作方式是你

00:34:38.240 --> 00:34:44.180
你说好我参加了一个考试

00:34:42.530 --> 00:34:46.130
想排序还是我的测试创建者

00:34:44.180 --> 00:34:48.530
想跑步，我拿了一些数据

00:34:46.130 --> 00:34:52.580
而且我做那个时髦的双重地图

00:34:48.530 --> 00:34:54.470
我以前做过的，想法是你

00:34:52.580 --> 00:34:56.210
编写一次，将其编译并

00:34:54.470 --> 00:34:59.390
然后再也不用担心了

00:34:56.210 --> 00:35:01.190
而是使用它编写测试，所以现在如果我

00:34:59.390 --> 00:35:04.790
我想写一个参数化测试

00:35:01.190 --> 00:35:07.160
我有我的测试方法，这是一个

00:35:04.790 --> 00:35:09.200
测试工厂，我将使用

00:35:07.160 --> 00:35:12.530
参数化的方法让一切

00:35:09.200 --> 00:35:14.600
锻炼得很好，我只是要

00:35:12.530 --> 00:35:17.840
首先说一下测试是什么

00:35:14.600 --> 00:35:19.910
基于s的动态测试，但我不是

00:35:17.840 --> 00:35:22.070
甚至在这里指定类型

00:35:19.910 --> 00:35:24.890
编译器推断正在完成所有这些工作

00:35:22.070 --> 00:35:26.560
为我做正确的事情

00:35:24.890 --> 00:35:28.510
在我要做的第一件事之前，先给我

00:35:26.560 --> 00:35:31.930
命名，然后我说我实际上

00:35:28.510 --> 00:35:34.090
想在测试中做，然后最后

00:35:31.930 --> 00:35:37.660
我要做的最后一件事是我提供一些

00:35:34.090 --> 00:35:41.800
现在测试数据我不了解你，但是

00:35:37.660 --> 00:35:43.270
这让我这就是你想要的方式

00:35:41.800 --> 00:35:46.180
如果您正在编写测试，就可以编写测试

00:35:43.270 --> 00:35:48.250
参数化测试，因为现在您

00:35:46.180 --> 00:35:50.080
只是说你想做什么而你

00:35:48.250 --> 00:35:52.990
没有任何类型的字符串

00:35:50.080 --> 00:35:54.910
之前和之中发生的混乱

00:35:52.990 --> 00:35:57.340
事实上我非常喜欢这个东西

00:35:54.910 --> 00:35:58.930
甚至在第五单元J想要之前

00:35:57.340 --> 00:36:01.390
真的被建造，所以我最终

00:35:58.930 --> 00:36:03.610
为J单元4编写一个快速库

00:36:01.390 --> 00:36:06.040
这是一个名为Lam的测试跑步者

00:36:03.610 --> 00:36:07.360
 data Runner我没有网址，但是如果

00:36:06.040 --> 00:36:10.720
你谷歌它将是唯一的

00:36:07.360 --> 00:36:12.400
在它下面出现的东西

00:36:10.720 --> 00:36:14.830
基本上有一个API，可以让您

00:36:12.400 --> 00:36:16.630
几乎一样的事情

00:36:14.830 --> 00:36:19.720
需要使用特殊的测试运行器

00:36:16.630 --> 00:36:20.680
这可能会导致问题，并且由于

00:36:19.720 --> 00:36:22.780
工作方式

00:36:20.680 --> 00:36:25.750
某些J单位规则行不通，所以

00:36:22.780 --> 00:36:27.220
很好，所以它不是完美的，但是它是

00:36:25.750 --> 00:36:30.370
一个很好的方法，我实际上已经找到了

00:36:27.220 --> 00:36:32.890
很有用，再次没有很多代码

00:36:30.370 --> 00:36:34.120
服用一些痛苦的东西

00:36:32.890 --> 00:36:38.520
把它变成真正的东西

00:36:34.120 --> 00:36:40.630
更好的类型安全性还可以

00:36:38.520 --> 00:36:45.430
我想谈的最后一件事是

00:36:40.630 --> 00:36:48.370
 API设计的最佳做法

00:36:45.430 --> 00:36:51.400
首先是，这回到文件

00:36:48.370 --> 00:36:54.970
如果您要创建新的访客示例

00:36:51.400 --> 00:36:56.680
接口（如果可能）创建它们

00:36:54.970 --> 00:36:58.840
他们只有一种方法

00:36:56.680 --> 00:37:01.000
其实有四个更好

00:36:58.840 --> 00:37:03.190
接口各取一个

00:37:01.000 --> 00:37:05.760
比一个大接口的方法，如果您

00:37:03.190 --> 00:37:07.990
可以逃脱并禁止

00:37:05.760 --> 00:37:09.370
考虑提供人工厂

00:37:07.990 --> 00:37:11.260
创建您的实例的方法

00:37:09.370 --> 00:37:16.360
界面，以便他们可以使用lambdas 

00:37:11.260 --> 00:37:19.570
并享受他们的下一条规则

00:37:16.360 --> 00:37:21.790
根本不使用任何接口

00:37:19.570 --> 00:37:23.890
那些已经存在的Java 

00:37:21.790 --> 00:37:27.100
 util函数有很多很棒的功能

00:37:23.890 --> 00:37:28.900
接口，因为它们都是

00:37:27.100 --> 00:37:31.900
类型当前通用参数化

00:37:28.900 --> 00:37:35.920
他们可能会为80％ 

00:37:31.900 --> 00:37:37.870
您的用例，然后再用10％ 

00:37:35.920 --> 00:37:39.250
您的用例，除了

00:37:37.870 --> 00:37:40.000
您已经检查了例外情况

00:37:39.250 --> 00:37:42.460
需要担心

00:37:40.000 --> 00:37:44.350
所以你可以用说Juke 

00:37:42.460 --> 00:37:47.320
 lamda图书馆再次管理那些

00:37:44.350 --> 00:37:49.420
检查异常，这很好，您知道

00:37:47.320 --> 00:37:51.010
更少的类可以在更少的东西中加载

00:37:49.420 --> 00:37:53.260
人们想一想他们会说哦

00:37:51.010 --> 00:37:54.850
功能是的，我知道那是什么我不知道

00:37:53.260 --> 00:37:55.900
需要回到绘图板， 

00:37:54.850 --> 00:37:58.240
尝试找出这个新东西

00:37:55.900 --> 00:38:03.100
你给我的界面已经是我了

00:37:58.240 --> 00:38:07.750
确切了解这是什么

00:38:03.100 --> 00:38:09.430
东西，所以有时候你想要你拥有

00:38:07.750 --> 00:38:12.220
一种方法，假设我有一个API 

00:38:09.430 --> 00:38:14.770
里面有做一些工作的方法

00:38:12.220 --> 00:38:18.190
它需要一个可运行的，然后我

00:38:14.770 --> 00:38:20.350
以为您知道检查的异常

00:38:18.190 --> 00:38:23.290
会让人伤心，所以也让我

00:38:20.350 --> 00:38:24.970
接受一个不会被检查的可运行的

00:38:23.290 --> 00:38:26.620
抛出任何检查的异常

00:38:24.970 --> 00:38:29.470
我认为奇怪的命名约定

00:38:26.620 --> 00:38:31.330
但是无论如何，这似乎是一个不错的选择

00:38:29.470 --> 00:38:33.220
要做的事情，但问题是两者

00:38:31.330 --> 00:38:35.440
从编译器角度来看这些lambda 

00:38:33.220 --> 00:38:37.630
两者的形状相同

00:38:35.440 --> 00:38:41.620
不接受参数，不返回

00:38:37.630 --> 00:38:43.990
不是参数和throws子句

00:38:41.620 --> 00:38:46.330
考虑到这意味着如果我想

00:38:43.990 --> 00:38:48.250
将任何东西作为lambda传递给

00:38:46.330 --> 00:38:52.540
编译器会说它是模棱两可的

00:38:48.250 --> 00:38:54.550
这将迫使我反而抛弃我的

00:38:52.540 --> 00:38:56.500
 lambda表达式可运行

00:38:54.550 --> 00:38:59.710
或感觉到的已检查可运行

00:38:56.500 --> 00:39:02.260
荒谬的，所以我们知道重载方法

00:38:59.710 --> 00:39:04.270
确保您不重载方法

00:39:02.260 --> 00:39:08.020
一种可能迫使您的来电者

00:39:04.270 --> 00:39:10.300
实际指定哪种lambda 

00:39:08.020 --> 00:39:11.920
土地传来的味道

00:39:10.300 --> 00:39:14.200
确实有不同的形状

00:39:11.920 --> 00:39:15.820
很好，例如，如果其中之一

00:39:14.200 --> 00:39:17.800
是可运行的，其中之一是

00:39:15.820 --> 00:39:19.660
可召唤的那些有不同的

00:39:17.800 --> 00:39:22.450
形状，因为可调用实际上返回

00:39:19.660 --> 00:39:23.950
某种东西，而可运行的不是

00:39:22.450 --> 00:39:29.890
让您知道不同的参数等等

00:39:23.950 --> 00:39:33.100
来回但尽量避免最后

00:39:29.890 --> 00:39:36.040
我可以推荐的最佳做法是

00:39:33.100 --> 00:39:37.480
始终填写会话调查

00:39:36.040 --> 00:39:39.580
非常感谢我的反馈

00:39:37.480 --> 00:39:42.070
显然如果你喜欢的话

00:39:39.580 --> 00:39:43.810
聊聊，然后我很高兴得知

00:39:42.070 --> 00:39:45.040
但我也想听听

00:39:43.810 --> 00:39:47.050
不喜欢我本可以做的

00:39:45.040 --> 00:39:49.930
更好，我什至想听听

00:39:47.050 --> 00:39:51.670
如果你真的很生气，那么我们

00:39:49.930 --> 00:40:01.119
有几分钟的时间

00:39:51.670 --> 00:40:02.619
问题是，问题是我曾经吗

00:40:01.119 --> 00:40:05.250
认为Java将移动所有已检查的

00:40:02.619 --> 00:40:07.540
运行时异常

00:40:05.250 --> 00:40:09.520
理论上他们可以，因为在某些情况下

00:40:07.540 --> 00:40:13.030
感觉不会破坏任何现有的

00:40:09.520 --> 00:40:15.609
代码，但据我所知

00:40:13.030 --> 00:40:18.010
像马克·罗恩·马克·莱因霍尔德和布莱恩

00:40:15.609 --> 00:40:22.630
得到，现在它是降压，我们在各种

00:40:18.010 --> 00:40:25.569
论坛可能会很冷

00:40:22.630 --> 00:40:27.819
在发生这种情况之前下降到下面

00:40:25.569 --> 00:40:29.920
幸运的是，越来越知道

00:40:27.819 --> 00:40:31.660
人们创建新的异常类型

00:40:29.920 --> 00:40:34.119
扩展运行时异常，以便您知道

00:40:31.660 --> 00:40:52.180
并没有恶化很多，是的

00:40:34.119 --> 00:40:53.829
问题好吧，如果

00:40:52.180 --> 00:40:56.109
我正在处理数据流， 

00:40:53.829 --> 00:40:57.609
流中只有一条数据

00:40:56.109 --> 00:40:59.799
这是一种毒药

00:40:57.609 --> 00:41:01.960
会导致运行时异常，现在

00:40:59.799 --> 00:41:05.619
我的整个流处理都颠倒了

00:41:01.960 --> 00:41:08.049
然后扔出去，我该如何处理

00:41:05.619 --> 00:41:10.270
这么好有点棘手

00:41:08.049 --> 00:41:13.510
我的意思是显然你可以做的一件事是

00:41:10.270 --> 00:41:15.130
吞下例外，但那

00:41:13.510 --> 00:41:17.740
感觉不对，所以也许

00:41:15.130 --> 00:41:20.200
你想做的就是如果它是一张地图

00:41:17.740 --> 00:41:22.299
例如操作而不是映射

00:41:20.200 --> 00:41:23.890
对您感兴趣的结果

00:41:22.299 --> 00:41:26.650
可以映射到

00:41:23.890 --> 00:41:28.089
结果或异常，以便您可以

00:41:26.650 --> 00:41:30.700
积累所有这些例外

00:41:28.089 --> 00:41:32.380
最后我想我觉得浮子可能

00:41:30.700 --> 00:41:34.900
有一种您可以用于的类型

00:41:32.380 --> 00:41:37.270
这样的事情，是的，如果那是

00:41:34.900 --> 00:41:38.710
你担心的事情

00:41:37.270 --> 00:41:41.680
我建议的是

00:41:38.710 --> 00:41:43.260
一些收集异常的方法

00:41:41.680 --> 00:41:48.540
从那里

00:41:43.260 --> 00:41:51.460
其他问题都很好我

00:41:48.540 --> 00:41:52.690
抱歉，我的谈话太快了

00:41:51.460 --> 00:41:54.250
担心无法完成

00:41:52.690 --> 00:41:56.200
及时地完成了

00:41:54.250 --> 00:41:58.119
提前几分钟，但这意味着

00:41:56.200 --> 00:41:59.500
你们所有人都可以进入等待

00:41:58.119 --> 00:42:01.710
下一个您喜欢的演讲的清单行

00:41:59.500 --> 00:42:02.360
谢谢你

00:42:01.710 --> 00:42:05.499
您

00:42:02.360 --> 00:42:05.499
 [音乐] 

