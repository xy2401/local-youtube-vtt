WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.030 --> 00:00:04.040
您好，欢迎来到我们的主题演讲

00:00:02.669 --> 00:00:07.170
懒惰终极复杂

00:00:04.040 --> 00:00:08.820
无论是生活还是编程，我的名字是

00:00:07.170 --> 00:00:10.650
我要谈谈Becca Subramanyam 

00:00:08.820 --> 00:00:12.599
我对函数式风格的兴奋

00:00:10.650 --> 00:00:14.730
编程对它有多实用

00:00:12.599 --> 00:00:16.859
真正做到这一点，以及语言如何

00:00:14.730 --> 00:00:19.020
像Java这样对我们来说真的很容易

00:00:16.859 --> 00:00:21.630
好吧，我们一直在

00:00:19.020 --> 00:00:23.550
命令式风格最主要

00:00:21.630 --> 00:00:25.890
主流语言提供动力

00:00:23.550 --> 00:00:27.869
 Tylar编程很长时间

00:00:25.890 --> 00:00:30.000
很好地推动了编程

00:00:27.869 --> 00:00:32.969
我们专注于做什么，但不幸的是

00:00:30.000 --> 00:00:35.309
主要是关于怎么做，让我们来谈谈

00:00:32.969 --> 00:00:37.500
这有一个很小的例子

00:00:35.309 --> 00:00:39.270
一个琐碎的例子，但仍然存在

00:00:37.500 --> 00:00:40.860
很好地说明了这一点

00:00:39.270 --> 00:00:43.320
所以让我们开始一点

00:00:40.860 --> 00:00:45.390
例子这里是一个名字列表

00:00:43.320 --> 00:00:48.030
其中我们看不到，但我很好奇

00:00:45.390 --> 00:00:50.250
清单中的朋友Nemo怎么办

00:00:48.030 --> 00:00:52.829
我们必须很好地解决这个问题

00:00:50.250 --> 00:00:55.739
风格以仪式开始

00:00:52.829 --> 00:00:58.530
脱颖而出，所以首先说布尔

00:00:55.739 --> 00:01:01.980
在这种情况下，千等于false 

00:00:58.530 --> 00:01:04.409
然后我们想说要在

00:01:01.980 --> 00:01:06.600
从清单中选择一个时间，然后

00:01:04.409 --> 00:01:09.180
我们将检查给出的每个名称

00:01:06.600 --> 00:01:12.720
我们要问你名字相等

00:01:09.180 --> 00:01:14.580
当然很好的话Nemo这个词，如果

00:01:12.720 --> 00:01:16.950
发现我们宣告胜利

00:01:14.580 --> 00:01:18.990
发现设置等于true但不是这样

00:01:16.950 --> 00:01:21.509
快，你最好记得突围

00:01:18.990 --> 00:01:23.250
这也一样，否则我们将被切成

00:01:21.509 --> 00:01:25.380
即使找到结果也要处理

00:01:23.250 --> 00:01:27.119
这对性能不是很好

00:01:25.380 --> 00:01:30.090
特别是当我们有一个很大的

00:01:27.119 --> 00:01:31.590
收集但尚未完成

00:01:30.090 --> 00:01:33.479
仍然必须回来检查

00:01:31.590 --> 00:01:36.780
找到，然后我们必须说输出

00:01:33.479 --> 00:01:39.420
 Nemo发现并为此庆祝

00:01:36.780 --> 00:01:42.119
当然可惜我们找不到尼莫

00:01:39.420 --> 00:01:44.970
然后宣布说哦，也许那尼莫

00:01:42.119 --> 00:01:47.430
在这种情况下在这里找不到

00:01:44.970 --> 00:01:49.350
我们会说找不到Nemo可能会伤心

00:01:47.430 --> 00:01:51.829
音乐，让我们继续运行此代码

00:01:49.350 --> 00:01:54.380
看到好消息，我们发现了尼莫

00:01:51.829 --> 00:01:57.540
这是势在必行的编程风格

00:01:54.380 --> 00:02:01.799
好吧，我称之为偶然的复杂性

00:01:57.540 --> 00:02:05.670
因为在命令式风格中我们专注于

00:02:01.799 --> 00:02:08.819
在做什么上，也在如何做上

00:02:05.670 --> 00:02:12.180
我们可以将详细信息拖入

00:02:08.819 --> 00:02:12.930
必须考虑我们拥有的每个要素

00:02:12.180 --> 00:02:15.329
比较

00:02:12.930 --> 00:02:17.609
元素，我们必须设置一个标志，不要

00:02:15.329 --> 00:02:20.370
记得每次都要打破循环

00:02:17.609 --> 00:02:22.079
单件是您的责任，我们

00:02:20.370 --> 00:02:24.959
编码方面的责任

00:02:22.079 --> 00:02:27.030
以编程风格介绍

00:02:24.959 --> 00:02:29.219
编程风格是我们的目标

00:02:27.030 --> 00:02:31.500
抽出的细节

00:02:29.219 --> 00:02:34.049
引入意外的复杂性

00:02:31.500 --> 00:02:34.500
代码真的很难改变

00:02:34.049 --> 00:02:36.719
过去

00:02:34.500 --> 00:02:39.150
每一种主流语言都做到了

00:02:36.719 --> 00:02:41.189
这对我们来说，但这不是我们的错

00:02:39.150 --> 00:02:43.290
程序员，但我们必须真正工作

00:02:41.189 --> 00:02:46.709
提供给我们的工具，主要是

00:02:43.290 --> 00:02:48.840
可用和受欢迎，但

00:02:46.709 --> 00:02:51.450
好消息是未来正在前进

00:02:48.840 --> 00:02:53.819
几乎每个新的方向都不同

00:02:51.450 --> 00:02:56.040
今天的主流语言在移动

00:02:53.819 --> 00:02:58.109
朝着

00:02:56.040 --> 00:03:00.329
做好编程，未来不是

00:02:58.109 --> 00:03:02.849
声明式风格和函数式风格

00:03:00.329 --> 00:03:05.489
让我们先谈谈技术文件

00:03:02.849 --> 00:03:08.280
回到这个例子，这是一个

00:03:05.489 --> 00:03:11.459
大量的仪式找到很多噪音

00:03:08.280 --> 00:03:14.519
 Nemo让我们摆脱所有的噪音和

00:03:11.459 --> 00:03:16.709
这段代码中的仪式

00:03:14.519 --> 00:03:19.739
只会归结为发现的权利

00:03:16.709 --> 00:03:22.709
在这里并将其更改为假设名称

00:03:19.739 --> 00:03:26.190
开始包含，然后当然问

00:03:22.709 --> 00:03:28.709
对于Nemo，我们要做的所有努力

00:03:26.190 --> 00:03:31.489
放进去了，我们可以很快来这里

00:03:28.709 --> 00:03:35.010
得到的结果就是一个例子

00:03:31.489 --> 00:03:38.010
声明式风格的程序设计怎么样

00:03:35.010 --> 00:03:42.359
是Tecla中的声明式风格盐

00:03:38.010 --> 00:03:47.970
相对风格，我们可以专注于

00:03:42.359 --> 00:03:51.120
而不是如何去做，所以我们专注

00:03:47.970 --> 00:03:53.459
关于该做什么是我们的主要重点

00:03:51.120 --> 00:03:57.060
无论我们感兴趣的是什么

00:03:53.459 --> 00:03:58.439
怎么做就不好做

00:03:57.060 --> 00:04:01.019
声明式风格消除了所有

00:03:58.439 --> 00:04:02.849
代码中的意外共谋

00:04:01.019 --> 00:04:04.680
可能会问这个问题

00:04:02.849 --> 00:04:07.259
容器确实可以完成工作

00:04:04.680 --> 00:04:09.569
答案可能是什么

00:04:07.259 --> 00:04:11.609
正是这一点，我们提出了所有其他建议

00:04:09.569 --> 00:04:13.560
关于如何包含作品的各种想法

00:04:11.609 --> 00:04:15.900
并且可能会使用不同的语言

00:04:13.560 --> 00:04:19.500
包含不同但我喜欢更好

00:04:15.900 --> 00:04:21.150
回答，那是我不在乎

00:04:19.500 --> 00:04:22.830
也许有点不礼貌，但是

00:04:21.150 --> 00:04:25.169
比说我不在乎我们可以说

00:04:22.830 --> 00:04:26.639
封装得好，听起来好多

00:04:25.169 --> 00:04:29.159
更好的含义

00:04:26.639 --> 00:04:31.590
我不在乎，我们都可以同意

00:04:29.159 --> 00:04:33.780
有时候我们绝对在乎

00:04:31.590 --> 00:04:36.330
但宣言的美丽

00:04:33.780 --> 00:04:39.029
编程是我们可以得到的细节

00:04:36.330 --> 00:04:41.969
当我们关心它时，我们不在乎

00:04:39.029 --> 00:04:44.219
关于它，它不在我们的脸上

00:04:41.969 --> 00:04:46.830
势在必行的风格我们别无选择

00:04:44.219 --> 00:04:48.990
任何细节都摆在面前

00:04:46.830 --> 00:04:51.840
我们，不管我们喜欢与否

00:04:48.990 --> 00:04:53.879
绝对无法逃避细节，所以

00:04:51.840 --> 00:04:57.270
在声明式风格上，我们专注于

00:04:53.879 --> 00:04:59.460
不要去做得很好

00:04:57.270 --> 00:05:02.400
装饰，所以认为装饰假

00:04:59.460 --> 00:05:05.009
第一个功能进来

00:05:02.400 --> 00:05:08.310
我们编程的函数式风格

00:05:05.009 --> 00:05:10.379
还使用声明式风格功能

00:05:08.310 --> 00:05:12.240
样式编程不是新的谢谢

00:05:10.379 --> 00:05:14.729
天哪，这不是新的，不是

00:05:12.240 --> 00:05:16.259
昨晚发明的新想法

00:05:14.729 --> 00:05:18.419
已经存在很长时间了

00:05:16.259 --> 00:05:20.789
经过尝试，经过测试， 

00:05:18.419 --> 00:05:23.159
练习了很多，只是没有

00:05:20.789 --> 00:05:25.430
在主流语言中很流行，但是

00:05:23.159 --> 00:05:27.180
现在几乎所有主流语言都是

00:05:25.430 --> 00:05:28.999
提供函数式风格

00:05:27.180 --> 00:05:32.219
编程真的很棒

00:05:28.999 --> 00:05:34.139
所以这是一个非常古老的想法

00:05:32.219 --> 00:05:36.599
重新产生的兴趣是什么

00:05:34.139 --> 00:05:38.610
我们生活的世界之所以很好

00:05:36.599 --> 00:05:41.069
已经改变了很多类型

00:05:38.610 --> 00:05:43.560
应用我们开发的数据类型

00:05:41.069 --> 00:05:45.629
我们处理并处理了很多这些

00:05:43.560 --> 00:05:48.449
情况与应用不同

00:05:45.629 --> 00:05:50.250
我们发展20-30年前，但是

00:05:48.449 --> 00:05:52.710
函数式风格的魅力

00:05:50.250 --> 00:05:54.719
编程让我们谈谈这个权利

00:05:52.710 --> 00:05:56.849
为此，让我们稍微

00:05:54.719 --> 00:05:59.460
与名称不同的示例

00:05:56.849 --> 00:06:02.310
让我们从数字列表开始

00:05:59.460 --> 00:06:05.939
给这些数字说一到十

00:06:02.310 --> 00:06:08.250
说最后总的偶数

00:06:05.939 --> 00:06:10.560
数字很​​好，我想找到

00:06:08.250 --> 00:06:13.379
偶数双精度标题

00:06:10.560 --> 00:06:14.849
它击败的命令式风格是什么

00:06:13.379 --> 00:06:18.089
你从一开始就失望了，不是吗

00:06:14.849 --> 00:06:19.770
结果等于零（整数） 

00:06:18.089 --> 00:06:22.889
来自数字的元素

00:06:19.770 --> 00:06:25.919
然后我们说元素3月2日的集合

00:06:22.889 --> 00:06:29.879
等于0那么我们当然会说

00:06:25.919 --> 00:06:31.919
结果加等于，然后e乘以2 

00:06:29.879 --> 00:06:34.769
当我们完成这一切时

00:06:31.919 --> 00:06:38.009
我们可以显示的输出

00:06:34.769 --> 00:06:40.060
结果就在最后，所以我们

00:06:38.009 --> 00:06:41.890
可以看到结果是60 

00:06:40.060 --> 00:06:44.710
再次需要大量的工作

00:06:41.890 --> 00:06:47.920
势在必行的编程风格

00:06:44.710 --> 00:06:50.590
在这里切换到相当实用的功能

00:06:47.920 --> 00:06:53.200
编程风格或

00:06:50.590 --> 00:06:55.270
世界是函数式风格，并非全部

00:06:53.200 --> 00:06:57.700
声明代码声明代码是

00:06:55.270 --> 00:06:59.710
功能记住contains方法

00:06:57.700 --> 00:07:02.110
包含方法是声明性的，但

00:06:59.710 --> 00:07:04.740
不是功能，而是所有功能代码

00:07:02.110 --> 00:07:08.740
是声明性的，所以这是声明性的

00:07:04.740 --> 00:07:11.380
再加上高阶函数，那么

00:07:08.740 --> 00:07:13.270
世界是高阶函数

00:07:11.380 --> 00:07:15.370
装饰是我们说要做什么的地方， 

00:07:13.270 --> 00:07:17.710
不是怎么做，让我们去

00:07:15.370 --> 00:07:19.900
很快，请看示例

00:07:17.710 --> 00:07:23.050
一开始就从输出开始

00:07:19.900 --> 00:07:25.480
每个流的起始流数是

00:07:23.050 --> 00:07:28.600
花哨的内部迭代器是什么

00:07:25.480 --> 00:07:33.040
给定元素element ma du的过滤器

00:07:28.600 --> 00:07:35.140
等于0，所以我们只得到偶数值

00:07:33.040 --> 00:07:38.500
从集合中，然后我们执行

00:07:35.140 --> 00:07:40.660
映射到这里说双重

00:07:38.500 --> 00:07:42.880
然后在这种情况下我们的入侵者地图

00:07:40.660 --> 00:07:45.850
计划结束，我们将继续前进， 

00:07:42.880 --> 00:07:47.500
将元素加倍两次，然后我们

00:07:45.850 --> 00:07:50.080
当然，将值加倍会调用

00:07:47.500 --> 00:07:52.930
总结一下，得到的总数

00:07:50.080 --> 00:07:54.430
运行时偶数的两倍

00:07:52.930 --> 00:07:56.920
代码注意结果仍然是

00:07:54.430 --> 00:07:59.620
在此代码示例中相同

00:07:56.920 --> 00:08:01.780
装饰，因为我们告诉该怎么办

00:07:59.620 --> 00:08:04.390
爷爷从一些手术表演

00:08:01.780 --> 00:08:06.670
过滤器执行映射或转换

00:08:04.390 --> 00:08:09.490
数据，但顺序较高

00:08:06.670 --> 00:08:11.770
因为我们要传递一个函数给

00:08:09.490 --> 00:08:14.020
另一个功能突出显示的代码

00:08:11.770 --> 00:08:16.270
当然是lambda表达式， 

00:08:14.020 --> 00:08:18.430
表达式是lambda或匿名

00:08:16.270 --> 00:08:21.040
函数，我们将一个函数传递给

00:08:18.430 --> 00:08:23.410
这种过滤方法或过滤功能

00:08:21.040 --> 00:08:25.690
在更高阶的函数中，我们可以通过

00:08:23.410 --> 00:08:27.910
我们周围的功能可以传递一个功能

00:08:25.690 --> 00:08:30.040
用我们的函数创建函数

00:08:27.910 --> 00:08:32.590
函数甚至从

00:08:30.040 --> 00:08:35.830
那些使更高阶的功能

00:08:32.590 --> 00:08:39.790
这行代码是功能性含义

00:08:35.830 --> 00:08:42.550
它被宣布为

00:08:39.790 --> 00:08:45.280
另一方面，这是

00:08:42.550 --> 00:08:49.000
以及功能，但这一是

00:08:45.280 --> 00:08:51.250
纯粹是声明性的，所以这当然是

00:08:49.000 --> 00:08:52.990
专注于告诉我们该怎么做

00:08:51.250 --> 00:08:53.870
将任何功能传递给这些功能

00:08:52.990 --> 00:08:55.370
和

00:08:53.870 --> 00:08:57.950
基本上是函数式风格

00:08:55.370 --> 00:09:00.500
编程，但是一个程序的魅力是什么

00:08:57.950 --> 00:09:02.150
编程的函数式风格

00:09:00.500 --> 00:09:05.000
函数式编程的魅力是

00:09:02.150 --> 00:09:07.220
高表现力的代码，所以代码

00:09:05.000 --> 00:09:09.589
变得更容易使用

00:09:07.220 --> 00:09:12.260
更容易写让我们看一个

00:09:09.589 --> 00:09:14.690
这个例子看看有多漂亮

00:09:12.260 --> 00:09:16.339
我开始教的代码开始流行

00:09:14.690 --> 00:09:18.830
 Java客户端的八个核心

00:09:16.339 --> 00:09:20.300
他们已经在使用Java 8了， 

00:09:18.830 --> 00:09:21.710
如果开发人员说您可以接受该怎么办

00:09:20.300 --> 00:09:23.870
看看我们的代码并对其进行批判

00:09:21.710 --> 00:09:25.490
通常当人们问我时我会害怕

00:09:23.870 --> 00:09:27.470
这个问题，如果代码真的是

00:09:25.490 --> 00:09:28.850
非常复杂，我听不懂

00:09:27.470 --> 00:09:30.770
我不想通过说来侮辱他们

00:09:28.850 --> 00:09:32.990
在这种情况下代码很好

00:09:30.770 --> 00:09:35.180
我只是用Java 8流编写的

00:09:32.990 --> 00:09:36.710
开始阅读代码，甚至我谁

00:09:35.180 --> 00:09:39.080
对他们没有任何了解

00:09:36.710 --> 00:09:40.790
域能够快速了解

00:09:39.080 --> 00:09:42.589
他们正在做的事情就是其中之一

00:09:40.790 --> 00:09:44.570
函数式风格的最大魅力

00:09:42.589 --> 00:09:47.360
编程让我们从创建开始

00:09:44.570 --> 00:09:49.550
人们在这里列出并给出列表

00:09:47.360 --> 00:09:52.310
有人说我想继续前进

00:09:49.550 --> 00:09:55.900
并将其存储在列表中

00:09:52.310 --> 00:09:59.110
人等于创造人

00:09:55.900 --> 00:10:03.770
但我想找个名字

00:09:59.110 --> 00:10:08.150
让名字全部大写

00:10:03.770 --> 00:10:12.140
当然，每个人

00:10:08.150 --> 00:10:14.480
不到18岁哦，应该很容易

00:10:12.140 --> 00:10:17.600
不是全部用大写字母

00:10:14.480 --> 00:10:19.730
每个18岁以下的人

00:10:17.600 --> 00:10:23.630
可以从列表字符串重新开始

00:10:19.730 --> 00:10:25.880
在这里，所以我们可以说字符串，我们

00:10:23.630 --> 00:10:28.760
可以说大三生只是称呼他们为

00:10:25.880 --> 00:10:31.610
大三或小孩，如果你想打电话给他们

00:10:28.760 --> 00:10:33.560
虽然17岁的孩子可能真的

00:10:31.610 --> 00:10:37.160
反对它，但让我们称之为孩子

00:10:33.560 --> 00:10:39.260
等于新数组，在这种情况下

00:10:37.160 --> 00:10:41.600
 ArrayList，我们创建一个空列表

00:10:39.260 --> 00:10:43.730
再看一次仪式，我们

00:10:41.600 --> 00:10:47.180
花时间告诉他们如何做事

00:10:43.730 --> 00:10:49.160
然后一个人又给一个人

00:10:47.180 --> 00:10:50.660
来自人们的收藏

00:10:49.160 --> 00:10:53.630
我们将与每个人做什么

00:10:50.660 --> 00:10:56.630
我们说单身的人

00:10:53.630 --> 00:11:00.170
年龄大于小于

00:10:56.630 --> 00:11:03.410
 18然后我们当然要说一个

00:11:00.170 --> 00:11:06.260
孩子开始，然后当然得到

00:11:03.410 --> 00:11:07.790
该人的名字得到名字，然后

00:11:06.260 --> 00:11:09.800
大写

00:11:07.790 --> 00:11:11.870
然后当然添加到孩子们

00:11:09.800 --> 00:11:13.430
完成后收集

00:11:11.870 --> 00:11:16.550
我们会继续，我不把

00:11:13.430 --> 00:11:19.040
孩子们的价值观并迅速浏览

00:11:16.550 --> 00:11:20.930
这我们看到有杰克杰克

00:11:19.040 --> 00:11:23.570
杰克和吉尔少一些

00:11:20.930 --> 00:11:25.610
超过18岁，让我们看看法院是否产生

00:11:23.570 --> 00:11:27.640
结果肯定是杰克

00:11:25.610 --> 00:11:30.200
和吉尔，但如果您看这段代码

00:11:27.640 --> 00:11:32.000
有一些不同，有一些

00:11:30.200 --> 00:11:33.560
这段代码中的不同问题是

00:11:32.000 --> 00:11:37.399
冗长的开头

00:11:33.560 --> 00:11:39.589
其次，它缺乏凝聚力

00:11:37.399 --> 00:11:42.500
我正在谈论的世界好看

00:11:39.589 --> 00:11:44.959
这一行代码也正在做一件事

00:11:42.500 --> 00:11:47.149
它得名的许多事情

00:11:44.959 --> 00:11:49.399
演员把我变成大写

00:11:47.149 --> 00:11:51.110
到帽子到很多

00:11:49.399 --> 00:11:52.970
工作，当然有人来

00:11:51.110 --> 00:11:55.220
并说这是一个很长的清单

00:11:52.970 --> 00:11:57.560
使它平行，您将找到

00:11:55.220 --> 00:11:59.510
最近的出口要去做很多工作

00:11:57.560 --> 00:12:01.700
当然让这个和弦平行

00:11:59.510 --> 00:12:04.779
我们可以通过以下方式节省很多精力

00:12:01.700 --> 00:12:08.180
在这方面的功能是

00:12:04.779 --> 00:12:10.820
功能的风格是什么

00:12:08.180 --> 00:12:14.450
在这个例子中，我们现在可以再次魅力

00:12:10.820 --> 00:12:15.800
再一次开始输出，但这

00:12:14.450 --> 00:12:18.200
我们从人开始的时间

00:12:15.800 --> 00:12:18.770
收藏我不看流

00:12:18.200 --> 00:12:21.620
再次

00:12:18.770 --> 00:12:24.649
给定一个人的意愿，我们将进行过滤

00:12:21.620 --> 00:12:27.529
只是说人点年龄变小

00:12:24.649 --> 00:12:30.440
超过18，但我们将执行地图

00:12:27.529 --> 00:12:34.130
会说给定一个人给我

00:12:30.440 --> 00:12:35.899
人点在这里或我们的名字

00:12:34.130 --> 00:12:37.970
可以将其重构为使用

00:12:35.899 --> 00:12:40.579
只需一分钟，方法引用

00:12:37.970 --> 00:12:44.480
然后可以说出名字，我们将说出名字

00:12:40.579 --> 00:12:46.370
在这里大写，然后一旦我们

00:12:44.480 --> 00:12:48.649
得到大写，我们可以说收集

00:12:46.370 --> 00:12:51.800
我们将其收集到一个漂亮的

00:12:48.649 --> 00:12:54.260
小清单，如果您愿意，这里是

00:12:51.800 --> 00:12:58.279
列表，当然列表来自

00:12:54.260 --> 00:13:00.980
实用方法的收集者

00:12:58.279 --> 00:13:03.079
我们说收藏家，就在那里

00:13:00.980 --> 00:13:05.209
来自收藏家的清单

00:13:03.079 --> 00:13:07.490
让我们继续运行此代码，看看

00:13:05.209 --> 00:13:09.230
它做什么，当然在这种情况下

00:13:07.490 --> 00:13:11.779
给一个人我应该拼写

00:13:09.230 --> 00:13:13.220
合适的是一个人，当然

00:13:11.779 --> 00:13:15.860
继续运行此代码，看看

00:13:13.220 --> 00:13:18.440
那是杰克和吉尔，但看看

00:13:15.860 --> 00:13:20.990
我们在这里看到的功能组合

00:13:18.440 --> 00:13:23.360
给它一个人的集合

00:13:20.990 --> 00:13:26.240
我们让所有人都超过了18岁

00:13:23.360 --> 00:13:28.880
得到他们的名字转换为大写和

00:13:26.240 --> 00:13:32.270
把它放回一个清单就变成一个

00:13:28.880 --> 00:13:34.460
从上到下流，我们不必

00:13:32.270 --> 00:13:36.590
来回去了解那里

00:13:34.460 --> 00:13:38.750
无需休息并继续

00:13:36.590 --> 00:13:41.090
我们做的所有事情变得很多

00:13:38.750 --> 00:13:43.640
当然，我们可以轻松一点

00:13:41.090 --> 00:13:46.700
并说字符串冒号冒号，并使用

00:13:43.640 --> 00:13:49.400
方法参考，同样，我们

00:13:46.700 --> 00:13:51.260
可以在这里使用方法参考

00:13:49.400 --> 00:13:53.480
我们可以节省很多精力， 

00:13:51.260 --> 00:13:55.610
阅读这段代码并使之真正成为现实

00:13:53.480 --> 00:13:58.280
优雅，如果您想在这种情况下

00:13:55.610 --> 00:14:00.770
当然给了我们要去的人

00:13:58.280 --> 00:14:02.930
得到这个人的名字，然后我们

00:14:00.770 --> 00:14:05.240
将其转换为大写并得到

00:14:02.930 --> 00:14:08.000
该函数组成的结果是

00:14:05.240 --> 00:14:09.410
非常引人注目，所以这是一个

00:14:08.000 --> 00:14:11.300
我们最大的好处

00:14:09.410 --> 00:14:13.160
这当然是问题

00:14:11.300 --> 00:14:15.170
有什么收获

00:14:13.160 --> 00:14:17.780
那就是聪明的程序员

00:14:15.170 --> 00:14:19.700
总是问有什么收获，让我们

00:14:17.780 --> 00:14:23.030
谈论房间里的大象

00:14:19.700 --> 00:14:26.510
我从未走进客户网站

00:14:23.030 --> 00:14:29.360
我谈论Java 8的那一刻

00:14:26.510 --> 00:14:31.280
立即进行功能编程

00:14:29.360 --> 00:14:33.560
问题是天哪，那又怎么样

00:14:31.280 --> 00:14:37.250
性能表现

00:14:33.560 --> 00:14:39.380
非常重要，但事实并非如此

00:14:37.250 --> 00:14:42.440
所有语言都是平等的

00:14:39.380 --> 00:14:45.110
让我们绕道看看

00:14:42.440 --> 00:14:47.360
在开始之前，很快就在Ruby上学习

00:14:45.110 --> 00:14:50.990
尽管在此我想强调一个

00:14:47.360 --> 00:14:52.460
我爱Ruby的事我不想我说

00:14:50.990 --> 00:14:55.700
关于一种语言的消极事物

00:14:52.460 --> 00:14:57.590
被视为仇恨言论，我是

00:14:55.700 --> 00:14:59.480
我想要展示美好的事物， 

00:14:57.590 --> 00:15:01.490
我想展示不太好的东西

00:14:59.480 --> 00:15:04.070
其实我什至会指出

00:15:01.490 --> 00:15:06.080
关于Java 8到底我爱Ruby I 

00:15:04.070 --> 00:15:07.970
广泛使用Ruby我们的上帝

00:15:06.080 --> 00:15:10.190
我在生产中维护的应用程序

00:15:07.970 --> 00:15:12.350
使用Ruby以及很多

00:15:10.190 --> 00:15:14.390
但是其他语言

00:15:12.350 --> 00:15:15.980
我想要的语言观点

00:15:14.390 --> 00:15:17.840
从长处学习

00:15:15.980 --> 00:15:20.680
语言的弱点是

00:15:17.840 --> 00:15:21.860
 Ruby的优点是纯粹的优雅

00:15:20.680 --> 00:15:24.650
美丽

00:15:21.860 --> 00:15:27.500
没有仪式，所以真的很好

00:15:24.650 --> 00:15:30.410
某种事物的语言

00:15:27.500 --> 00:15:31.940
做得像单车还是发球

00:15:30.410 --> 00:15:33.900
火箭，如果你想考虑一下

00:15:31.940 --> 00:15:36.570
这样有飞机的时候

00:15:33.900 --> 00:15:39.360
火箭也许是使用的正确工具

00:15:36.570 --> 00:15:41.340
很多时候自行车很棒

00:15:39.360 --> 00:15:43.320
我希望能够选择

00:15:41.340 --> 00:15:46.200
什么可能有意义，让我们来谈谈

00:15:43.320 --> 00:15:48.920
 Ruby非常快，所以我在Ruby中

00:15:46.200 --> 00:15:51.960
源代码让我们谈一点

00:15:48.920 --> 00:15:55.320
我想做的转变让我们做

00:15:51.960 --> 00:15:57.990
数字等于，我要保存

00:15:55.320 --> 00:16:00.230
一二三也许是几个数字

00:15:57.990 --> 00:16:03.240
在这里我不想取这些数字

00:16:00.230 --> 00:16:07.260
但是我要说的是什么

00:16:03.240 --> 00:16:11.070
找到第一个，说说找到E 

00:16:07.260 --> 00:16:13.380
比方说双倍都

00:16:11.070 --> 00:16:15.540
数字，所以我想找到

00:16:13.380 --> 00:16:18.360
所有偶数都不应该是

00:16:15.540 --> 00:16:19.710
如果我想真的很难做

00:16:18.360 --> 00:16:21.930
找出所有偶数的双数

00:16:19.710 --> 00:16:23.850
我要把每个数字都罚款

00:16:21.930 --> 00:16:26.820
甚至是它的两倍

00:16:23.850 --> 00:16:28.740
当然，你知道这一切还好吧

00:16:26.820 --> 00:16:31.170
其实并不难，但要

00:16:28.740 --> 00:16:33.390
稍微改变问题，如果

00:16:31.170 --> 00:16:36.690
这个集合，我们要有我们的

00:16:33.390 --> 00:16:39.300
一路上的不同价值观也许

00:16:36.690 --> 00:16:42.000
我会遵循这些思路

00:16:39.300 --> 00:16:43.950
将其更改为一些任意值

00:16:42.000 --> 00:16:45.900
我将为此工作

00:16:43.950 --> 00:16:48.630
我当然有很多

00:16:45.900 --> 00:16:53.460
不同的值，但发现

00:16:48.630 --> 00:16:58.760
找到你一个双重的，让我们说双重和

00:16:53.460 --> 00:17:01.830
偏离第一个数字大于o 

00:16:58.760 --> 00:17:04.290
让我们说在这种情况下大于

00:17:01.830 --> 00:17:06.810
的50，所以我想找到

00:17:04.290 --> 00:17:09.240
第一个大于50的数字

00:17:06.810 --> 00:17:10.860
我会做得好吗，我们就像

00:17:09.240 --> 00:17:13.110
编程风格的功能是

00:17:10.860 --> 00:17:15.360
迷人，美丽，优雅

00:17:13.110 --> 00:17:17.490
很容易理解代码

00:17:15.360 --> 00:17:19.170
 Ruby一直支持该功能

00:17:17.490 --> 00:17:21.270
编程方面

00:17:19.170 --> 00:17:24.089
从今天起势在必行的编程风格

00:17:21.270 --> 00:17:26.370
因此，从这个意义上讲，Ruby是

00:17:24.089 --> 00:17:28.380
做Java最近做的事情

00:17:26.370 --> 00:17:30.540
提供命令性和功能性

00:17:28.380 --> 00:17:35.040
好的编程风格，让我们给它

00:17:30.540 --> 00:17:37.260
试试看，数字飞镖地图就像

00:17:35.040 --> 00:17:39.660
我们在这里使用了Map函数

00:17:37.260 --> 00:17:41.820
转换我们可以使用Map函数

00:17:39.660 --> 00:17:44.910
哦，等等，我们要数字

00:17:41.820 --> 00:17:46.830
大于50是不是所以我们可以说

00:17:44.910 --> 00:17:49.800
我们可以说过滤器

00:17:46.830 --> 00:17:52.050
并在此处给出一个元素，所以这里是

00:17:49.800 --> 00:17:55.080
这是我们可以使用的Ruby语法的元素

00:17:52.050 --> 00:17:58.620
说更大比说更大

00:17:55.080 --> 00:18:01.080
比这还好

00:17:58.620 --> 00:18:02.490
案例50，我们要问是否

00:18:01.080 --> 00:18:04.440
大于50 

00:18:02.490 --> 00:18:06.390
元素，所以我们继续写

00:18:04.440 --> 00:18:09.210
给定a，函数e大于50 

00:18:06.390 --> 00:18:11.970
我想简单地返回这个

00:18:09.210 --> 00:18:12.690
值将表示return n大于

00:18:11.970 --> 00:18:15.180
 50 

00:18:12.690 --> 00:18:17.430
那太好了，然后我们会说

00:18:15.180 --> 00:18:20.160
当然在这种情况下的Map函数

00:18:17.430 --> 00:18:21.810
给定一个元素，我们会说我们想要

00:18:20.160 --> 00:18:23.610
加倍元素，所以我们加倍

00:18:21.810 --> 00:18:25.710
元素就在后面，所以这

00:18:23.610 --> 00:18:28.170
需要我们写一个双重函数

00:18:25.710 --> 00:18:30.600
这需要一个数字n和所有的

00:18:28.170 --> 00:18:33.240
要做的是返回n倍2 

00:18:30.600 --> 00:18:35.340
到目前为止很棒，但请记住我所没有的

00:18:33.240 --> 00:18:37.590
我不想要所有的价值观

00:18:35.340 --> 00:18:39.330
只是第一个值，我们将

00:18:37.590 --> 00:18:41.700
当然，当我们

00:18:39.330 --> 00:18:44.880
就在这里完成，所以我们说看跌期权和

00:18:41.700 --> 00:18:46.530
要求它打印结果，让我们开始吧

00:18:44.880 --> 00:18:48.360
继续尝试，我的13号有一个

00:18:46.530 --> 00:18:50.400
错误，我们将对此进行修复

00:18:48.360 --> 00:18:53.040
在这种情况下，数字我们当然会

00:18:50.400 --> 00:18:55.200
说找到就是我们要的全部

00:18:53.040 --> 00:18:57.360
每个值，然后将其加倍

00:18:55.200 --> 00:18:59.670
找出等于等于进入我们的过滤器

00:18:57.360 --> 00:19:02.520
就在Ruby中，第一个数字

00:18:59.670 --> 00:19:05.400
大于50是54，所以

00:19:02.520 --> 00:19:07.710
 2是108，我们可以看到

00:19:05.400 --> 00:19:11.130
做工作，但要记住

00:19:07.710 --> 00:19:13.410
例子，我们真的想要第一个值

00:19:11.130 --> 00:19:16.050
满足只是符合条件，但

00:19:13.410 --> 00:19:18.990
 Ruby在这方面实际上做了多少工作

00:19:16.050 --> 00:19:22.170
很好的案例证明是红宝石

00:19:18.990 --> 00:19:25.020
非常渴望它做了很多工作，所以

00:19:22.170 --> 00:19:27.720
如果你去这里打印，如果你

00:19:25.020 --> 00:19:30.000
在这种情况下，我们会说e更大

00:19:27.720 --> 00:19:32.100
比，然后我们将输出

00:19:30.000 --> 00:19:34.590
我们要的，然后我们去

00:19:32.100 --> 00:19:36.720
双，然后要求它打印

00:19:34.590 --> 00:19:39.140
当然是两倍的结果

00:19:36.720 --> 00:19:42.570
指定值是什么

00:19:39.140 --> 00:19:45.060
注意我们所做的所有处理

00:19:42.570 --> 00:19:47.160
计算我们检查是否每一个

00:19:45.060 --> 00:19:49.680
一路大于50 

00:19:47.160 --> 00:19:51.720
从一个到最后20 

00:19:49.680 --> 00:19:57.350
将所有大于50的值加倍

00:19:51.720 --> 00:20:00.480
 54 61 77 98，最后我们丢弃了

00:19:57.350 --> 00:20:03.419
一切，只是获得第一价值

00:20:00.480 --> 00:20:06.600
浪费性能什么都没有

00:20:03.419 --> 00:20:09.330
伟大的事，但如果我是

00:20:06.600 --> 00:20:11.070
处理大量数据

00:20:09.330 --> 00:20:13.590
我正在合作的一些项目

00:20:11.070 --> 00:20:15.660
处理数以百万计的

00:20:13.590 --> 00:20:18.510
数百万个数据将无法正常工作

00:20:15.660 --> 00:20:21.960
在这种情况下真的很好，不是吗

00:20:18.510 --> 00:20:24.809
所以真正吸引我使用Java 8的是

00:20:21.960 --> 00:20:26.669
不是事实，它实际上有

00:20:24.809 --> 00:20:29.700
全部编程风格的功能

00:20:26.669 --> 00:20:32.190
诚实我有点舍弃了Java 

00:20:29.700 --> 00:20:34.500
提供开始，因为我说

00:20:32.190 --> 00:20:37.020
其他语言有什么大不了的

00:20:34.500 --> 00:20:40.500
 lambdas Java现在有lambdas为什么

00:20:37.020 --> 00:20:43.710
我在乎，但我发现还有更多

00:20:40.500 --> 00:20:47.070
比Java 8中的lambda更重要

00:20:43.710 --> 00:20:50.040
确实使我着迷于Java 8的优雅

00:20:47.070 --> 00:20:52.410
非常有用，我们不会丢弃它们

00:20:50.040 --> 00:20:54.000
漂亮的代码就是很棒的代码

00:20:52.410 --> 00:20:55.799
易于表达的代码

00:20:54.000 --> 00:20:59.730
与很棒的人交流

00:20:55.799 --> 00:21:01.380
但是性能很关键，请给我四个

00:20:59.730 --> 00:21:04.410
饥荒或给我死亡可能是一个

00:21:01.380 --> 00:21:07.230
口号，我们都可以说得如此优雅

00:21:04.410 --> 00:21:10.860
表现的管理员不会扩大规模

00:21:07.230 --> 00:21:13.080
真的很好，所以我们能做的是

00:21:10.860 --> 00:21:14.700
我们注定要这种编程

00:21:13.080 --> 00:21:17.760
然后我们可以在其中

00:21:14.700 --> 00:21:20.220
性能或我们可以有优雅，但

00:21:17.760 --> 00:21:21.059
两者都不好，事实证明那不是

00:21:20.220 --> 00:21:23.190
完全正确

00:21:21.059 --> 00:21:25.740
让我们看看其他语言来学习

00:21:23.190 --> 00:21:28.799
从我们转向真正的功能

00:21:25.740 --> 00:21:31.049
编程语言Haskell我真的

00:21:28.799 --> 00:21:33.990
爱Haskell所做的事让我们接受

00:21:31.049 --> 00:21:36.270
如果您很快就能快速了解Haskell 

00:21:33.990 --> 00:21:37.740
看看Haskell就在这里

00:21:36.270 --> 00:21:41.610
写一个方法调用一个函数

00:21:37.740 --> 00:21:44.010
加B等于加B因此在这种情况下

00:21:41.610 --> 00:21:47.280
它会返回结果的总数

00:21:44.010 --> 00:21:50.309
加B但这些功能和旅馆

00:21:47.280 --> 00:21:52.710
现在被称为纯函数

00:21:50.309 --> 00:21:55.530
需要一个

00:21:52.710 --> 00:21:57.120
值并返回值，当然

00:21:55.530 --> 00:21:58.020
我要写一个主要功能

00:21:57.120 --> 00:22:00.179
有副作用

00:21:58.020 --> 00:22:03.240
我在那放平等的权利，然后

00:22:00.179 --> 00:22:06.210
要说租金和印刷品

00:22:03.240 --> 00:22:08.190
打印评估，让我们去打印添加一个

00:22:06.210 --> 00:22:11.970
和三个我当然会运行它

00:22:08.190 --> 00:22:14.130
说四个，但是在这个例子中我有

00:22:11.970 --> 00:22:17.160
仍然必须做所有的工作

00:22:14.130 --> 00:22:21.060
与许多其他语言不同

00:22:17.160 --> 00:22:25.770
正常命令所称的是

00:22:21.060 --> 00:22:28.520
许多其他语言是语言

00:22:25.770 --> 00:22:31.410
包括Java使用所谓的

00:22:28.520 --> 00:22:33.110
应用顺序，这到底是什么

00:22:31.410 --> 00:22:36.570
两者之间的区别是什么

00:22:33.110 --> 00:22:38.490
你的正常秩序很不正常

00:22:36.570 --> 00:22:40.830
看不出很多语言能做到这一点

00:22:38.490 --> 00:22:43.590
是功能的评估是

00:22:40.830 --> 00:22:46.380
推迟到那个值

00:22:43.590 --> 00:22:48.180
对此实际上需要评估

00:22:46.380 --> 00:22:51.450
示例广告将不会被调用

00:22:48.180 --> 00:22:53.610
直到我们介入评估，以便确定广告是否

00:22:51.450 --> 00:22:56.310
根本不需要它永远不会得到

00:22:53.610 --> 00:22:58.470
在这种情况下，让我们证明一下

00:22:56.310 --> 00:23:01.350
我要展示的是广告将会

00:22:58.470 --> 00:23:03.000
真的打得好，我不能打印

00:23:01.350 --> 00:23:05.220
那里的声明，因为打印

00:23:03.000 --> 00:23:07.170
副作用，我们该怎么办

00:23:05.220 --> 00:23:09.540
在这里，我们将通过的方式

00:23:07.170 --> 00:23:11.790
这是为了提起GHC I 

00:23:09.540 --> 00:23:14.520
编译器，我要加载

00:23:11.790 --> 00:23:16.860
 Haskell文件放进去，我要放一个

00:23:14.520 --> 00:23:20.340
第一行字符上的断点

00:23:16.860 --> 00:23:24.360
 16我要请我接受评估

00:23:20.340 --> 00:23:27.030
注意它在第1行停止

00:23:24.360 --> 00:23:29.460
我说现在继续可以看到它

00:23:27.030 --> 00:23:32.310
产生4的结果，所以我证明了

00:23:29.460 --> 00:23:34.620
它执行添加功能忽略

00:23:32.310 --> 00:23:36.930
我们将回到现在开始

00:23:34.620 --> 00:23:39.840
回到分数，然后返回

00:23:36.930 --> 00:23:43.200
 42现在，当我运行它产生的代码时

00:23:39.840 --> 00:23:45.780
 42但是怎么还聪明是正常的

00:23:43.200 --> 00:23:48.570
命令说我不必评估

00:23:45.780 --> 00:23:51.060
毕竟是因为您从未使用过广告

00:23:48.570 --> 00:23:52.650
仅可能的广告结果

00:23:51.060 --> 00:23:54.990
当函数是纯函数时，我将讨论

00:23:52.650 --> 00:23:57.510
一分钟之内

00:23:54.990 --> 00:24:00.000
在此示例中从未评估过

00:23:57.510 --> 00:24:03.600
证明一下，让我们回到这里运行

00:24:00.000 --> 00:24:06.090
 Haskell GHz I Rapala增益开始吧

00:24:03.600 --> 00:24:08.310
提前说在这种情况下

00:24:06.090 --> 00:24:11.550
第一行字符上的断点

00:24:08.310 --> 00:24:14.520
 16，但这次称为主通知

00:24:11.550 --> 00:24:17.970
它从未涉足功能， 

00:24:14.520 --> 00:24:20.850
那是因为敌意说没有

00:24:17.970 --> 00:24:22.710
评估该方法的理由

00:24:20.850 --> 00:24:23.610
功能，因为您从未使用过

00:24:22.710 --> 00:24:27.210
结果

00:24:23.610 --> 00:24:27.870
效率就是效率

00:24:27.210 --> 00:24:29.970
是

00:24:27.870 --> 00:24:31.799
避免不应做的工作

00:24:29.970 --> 00:24:34.470
你不想成为的第一名

00:24:31.799 --> 00:24:35.730
快要高效时

00:24:34.470 --> 00:24:37.500
你有效率，你会自动

00:24:35.730 --> 00:24:40.049
会有更好的表现，因为

00:24:37.500 --> 00:24:41.940
您没有做不必要的工作，如何

00:24:40.049 --> 00:24:44.250
这甚至可能如何

00:24:41.940 --> 00:24:47.220
这样做是因为我们拥有

00:24:44.250 --> 00:24:49.860
叫做纯函数，所以真正的是

00:24:47.220 --> 00:24:52.529
我们提供的纯函数

00:24:49.860 --> 00:24:54.929
只要结果完全相同

00:24:52.529 --> 00:24:57.779
每个输入都完全相同

00:24:54.929 --> 00:24:59.340
时间纯函数永远不会给我们一个

00:24:57.779 --> 00:25:01.470
给定子集的不同结果

00:24:59.340 --> 00:25:03.870
输入我们是函数没有任何

00:25:01.470 --> 00:25:06.179
副作用，所以当您运行

00:25:03.870 --> 00:25:09.270
您不知道它们是否运行的功能

00:25:06.179 --> 00:25:11.429
还是无论如何你都不知道

00:25:09.270 --> 00:25:13.860
他们的效果如何，因为他们

00:25:11.429 --> 00:25:15.659
没有副作用，所以他们服用了

00:25:13.860 --> 00:25:17.520
输入，如果没有，它们会提供输出

00:25:15.659 --> 00:25:20.340
使用输出没关系，因为

00:25:17.520 --> 00:25:22.740
如果他们从未真正运行过

00:25:20.340 --> 00:25:25.860
首先是纯函数的好处

00:25:22.740 --> 00:25:28.529
好处是他们可以等幂

00:25:25.860 --> 00:25:29.850
他们很多次，例如你

00:25:28.529 --> 00:25:31.890
打电话给你的银行，说我的余额是多少

00:25:29.850 --> 00:25:33.899
然后马上你的余额是多少

00:25:31.890 --> 00:25:35.130
假设它没有真正存放任何东西

00:25:33.899 --> 00:25:37.679
我会提取余额的钱将是

00:25:35.130 --> 00:25:39.149
通常在这种情况下是一样的

00:25:37.679 --> 00:25:41.340
那不是幂等的运算

00:25:39.149 --> 00:25:43.559
因为银行里的钱不断

00:25:41.340 --> 00:25:45.480
在很多情况下不断变化

00:25:43.559 --> 00:25:47.419
令人沮丧地下降，但是重点

00:25:45.480 --> 00:25:49.860
真的是在不断变化，所以

00:25:47.419 --> 00:25:51.929
幂等是您可以做的相同的事情

00:25:49.860 --> 00:25:53.990
反复工作并给出相同的结果

00:25:51.929 --> 00:25:57.000
结果类似于添加功能

00:25:53.990 --> 00:25:59.580
可以透明地打电话给你

00:25:57.000 --> 00:26:02.970
功能，您可以替换

00:25:59.580 --> 00:26:05.039
函数或表达式及其值

00:26:02.970 --> 00:26:07.140
例如在这个鸡蛋在这个

00:26:05.039 --> 00:26:10.350
特殊情况下我必须

00:26:07.140 --> 00:26:13.020
决定用替换此加法1/3 

00:26:10.350 --> 00:26:14.760
如果它想做的话，值为4 

00:26:13.020 --> 00:26:17.640
这就是参考透明

00:26:14.760 --> 00:26:19.950
实际上Java编译器可以做到

00:26:17.640 --> 00:26:22.350
知道功能是评估

00:26:19.950 --> 00:26:24.570
表达式很纯净，很容易

00:26:22.350 --> 00:26:26.700
记住结果记住

00:26:24.570 --> 00:26:29.190
存储它们，以便您可以将它们放入

00:26:26.700 --> 00:26:30.990
缓存并在下次致电时说

00:26:29.190 --> 00:26:33.330
这个功能我不会评估，我会

00:26:30.990 --> 00:26:35.669
只是给你这个结果，这是

00:26:33.330 --> 00:26:37.649
用于所谓的动态

00:26:35.669 --> 00:26:39.299
算法编程问题

00:26:37.649 --> 00:26:41.320
我们使用过量的方法

00:26:39.299 --> 00:26:44.470
递归，但我们保存

00:26:41.320 --> 00:26:46.720
记忆代码可提高性能

00:26:44.470 --> 00:26:48.970
只要输入相同就进行测试

00:26:46.720 --> 00:26:51.340
输出是一样的没有任何

00:26:48.970 --> 00:26:53.560
外部依赖很棒

00:26:51.340 --> 00:26:55.590
那是真正拥有的理想国

00:26:53.560 --> 00:26:57.820
可以很容易地测试它的能力

00:26:55.590 --> 00:27:00.760
最后当然更容易

00:26:57.820 --> 00:27:03.670
也可以使代码麻痹

00:27:00.760 --> 00:27:05.770
并发成为纯函数，因为

00:27:03.670 --> 00:27:07.390
它没有副作用，不会

00:27:05.770 --> 00:27:09.190
遇到任何比赛条件和混乱

00:27:07.390 --> 00:27:11.500
具有一些共享的全局可变状态

00:27:09.190 --> 00:27:14.350
而且不会受到国家的影响

00:27:11.500 --> 00:27:16.960
以及外部，但出于我们的目的

00:27:14.350 --> 00:27:20.650
这里最有趣的部分是

00:27:16.960 --> 00:27:23.850
懒惰，这样可以轻松并等待

00:27:20.650 --> 00:27:26.550
直到不必执行它为止

00:27:23.850 --> 00:27:29.560
直到最后一个负责任的时刻

00:27:26.550 --> 00:27:32.500
在这种情况下，懒惰才是真正的魅力

00:27:29.560 --> 00:27:34.420
你在这里看到的是Haskell 

00:27:32.500 --> 00:27:38.260
懒于实现添加

00:27:34.420 --> 00:27:39.850
评估功能，因此推迟了

00:27:38.260 --> 00:27:42.280
足够长的时间，它不必做

00:27:39.850 --> 00:27:44.590
所有其他使用的语言

00:27:42.280 --> 00:27:47.440
应用顺序急切地评估那些

00:27:44.590 --> 00:27:50.290
事情，但就像我说的不喜欢法律

00:27:47.440 --> 00:27:52.540
怪异的Haskell错误的语言

00:27:50.290 --> 00:27:54.730
在我所说的保存错误上

00:27:52.540 --> 00:27:57.400
假设所有功能都是纯函数

00:27:54.730 --> 00:28:02.350
除非另有说明，就像我们只是

00:27:57.400 --> 00:28:04.180
像Java Scala等依赖于您

00:28:02.350 --> 00:28:07.240
知道担心功能易变

00:28:04.180 --> 00:28:09.910
除非另有说明，否则让我们谈谈

00:28:07.240 --> 00:28:12.160
关于Scala只是让我们

00:28:09.910 --> 00:28:13.990
去我要去的Scala真实硬币

00:28:12.160 --> 00:28:17.440
在这里创建一个函数，称为和

00:28:13.990 --> 00:28:21.070
计算这需要一个值int并且它是

00:28:17.440 --> 00:28:23.740
打算返回n乘以2 

00:28:21.070 --> 00:28:29.110
我要说Val X等于

00:28:23.740 --> 00:28:33.100
如果X大于5则为4，然后计算

00:28:29.110 --> 00:28:36.400
假设大于10我

00:28:33.100 --> 00:28:39.430
想要进行输出打印1让我们

00:28:36.400 --> 00:28:42.790
说结果1否则我要去

00:28:39.430 --> 00:28:45.310
打印出来，当我说结果2 

00:28:42.790 --> 00:28:48.910
运行这段代码真正要问的问题

00:28:45.310 --> 00:28:51.700
我们有颜色会运行计算方法

00:28:48.910 --> 00:28:55.050
我们都知道答案国外计算

00:28:51.700 --> 00:28:58.600
不会运行Y，所以称为

00:28:55.050 --> 00:29:00.820
短路，嘿，好球

00:28:58.600 --> 00:29:04.330
是懒惰的另一个例子

00:29:00.820 --> 00:29:06.940
除非这不评估计算

00:29:04.330 --> 00:29:09.550
毕竟是真的

00:29:06.940 --> 00:29:12.700
所以我们知道有条件的人会出手

00:29:09.550 --> 00:29:15.880
排队和懒惰的地方，如果我

00:29:12.700 --> 00:29:17.830
回到这里说在这里叫

00:29:15.880 --> 00:29:21.430
您会注意到它实际上是

00:29:17.830 --> 00:29:24.880
从来没有说过很棒，但是如果

00:29:21.430 --> 00:29:28.360
我们把它从这里拿出来叫他

00:29:24.880 --> 00:29:32.290
我们说这里的有效温度等于

00:29:28.360 --> 00:29:35.620
可悲的是，尽管这次如何

00:29:32.290 --> 00:29:37.930
当您运行此Scala时，是什么意思

00:29:35.620 --> 00:29:40.720
计算方法应该已经调用

00:29:37.930 --> 00:29:43.180
不，当然不是，我们不使用

00:29:40.720 --> 00:29:46.660
计算结果，但Scala评估了

00:29:43.180 --> 00:29:49.390
渴望计算为什么它真的做到了

00:29:46.660 --> 00:29:51.760
原因是Scala担心

00:29:49.390 --> 00:29:52.180
计算可能会有副作用，但请等待

00:29:51.760 --> 00:29:54.760
一分钟

00:29:52.180 --> 00:29:57.910
一分钟前有副作用

00:29:54.760 --> 00:30:00.910
我们在这里用计算来称呼它，所以

00:29:57.910 --> 00:30:03.550
为什么不在这里称呼它，为什么呢

00:30:00.910 --> 00:30:05.890
现在说出来，答案很简单

00:30:03.550 --> 00:30:08.230
语言规范语言

00:30:05.890 --> 00:30:10.990
规格规则语言

00:30:08.230 --> 00:30:13.900
规格说即使功能

00:30:10.990 --> 00:30:16.780
会有副作用，我们将使

00:30:13.900 --> 00:30:20.260
如果这些内容位于

00:30:16.780 --> 00:30:22.600
短路情况，因此语言规范

00:30:20.260 --> 00:30:24.280
语言说，你知道吗？ 

00:30:22.600 --> 00:30:26.200
如果有方法会调用方法

00:30:24.280 --> 00:30:28.570
在这里的影响有时是我们可能不会

00:30:26.200 --> 00:30:31.330
即使有副作用也可以称呼它

00:30:28.570 --> 00:30:33.580
所以真的可以归结为语言

00:30:31.330 --> 00:30:37.030
规格，并在Scala中选择

00:30:33.580 --> 00:30:40.120
调用方法，除非您在

00:30:37.030 --> 00:30:45.070
短路情况是你吗

00:30:40.120 --> 00:30:49.000
主要告诉Scala没关系， 

00:30:45.070 --> 00:30:51.160
通过说你懒将其标记为懒

00:30:49.000 --> 00:30:53.560
说不要打扰如果

00:30:51.160 --> 00:30:56.730
如您所见，您真的不需要它

00:30:53.560 --> 00:31:00.520
在这个例子中，如果我将其更改为一个

00:30:56.730 --> 00:31:03.340
您会注意到它确实调用了它，但是

00:31:00.520 --> 00:31:06.460
如果我在这里放一个五，就不会这样

00:31:03.340 --> 00:31:08.770
就像我们看到的那样，这很懒

00:31:06.460 --> 00:31:10.510
美丽如初，所以你

00:31:08.770 --> 00:31:12.850
有这些调整和语言

00:31:10.510 --> 00:31:14.620
您可以用来控制是否

00:31:12.850 --> 00:31:16.780
语言会锻炼某些东西或

00:31:14.620 --> 00:31:19.570
它不会运动

00:31:16.780 --> 00:31:22.000
如您所见，功能非常强大，但是

00:31:19.570 --> 00:31:24.700
关于Java真的很特别

00:31:22.000 --> 00:31:26.440
 Java已成为当务之急

00:31:24.700 --> 00:31:28.660
风格化

00:31:26.440 --> 00:31:31.300
编程语言，所以这一直是

00:31:28.660 --> 00:31:34.920
我们过去的经验，所以当它

00:31:31.300 --> 00:31:38.620
来到Java 7之前，我们做了

00:31:34.920 --> 00:31:41.350
势在必行加上面向对象和

00:31:38.620 --> 00:31:46.210
那是编程的真实模式

00:31:41.350 --> 00:31:50.440
 Java本身，但从Java 8开始

00:31:46.210 --> 00:31:53.740
我们能做的是确保您可以编程

00:31:50.440 --> 00:31:56.890
然后让我们说Sheree可以编程

00:31:53.740 --> 00:31:59.820
互动风格，如果您想

00:31:56.890 --> 00:32:03.040
您也可以执行功能+ 

00:31:59.820 --> 00:32:05.680
面向对象，希望我们

00:32:03.040 --> 00:32:08.430
将主要做功能

00:32:05.680 --> 00:32:11.710
而不是对象而不是

00:32:08.430 --> 00:32:14.080
当务之急是真正的罪魁祸首

00:32:11.710 --> 00:32:16.390
这里不是面向对象的真实

00:32:14.080 --> 00:32:18.820
罪魁祸首是命令式

00:32:16.390 --> 00:32:20.560
通过替换命令来编程

00:32:18.820 --> 00:32:22.480
具有功能，我们仍然可以使用

00:32:20.560 --> 00:32:24.910
红外，如果你想，但我们有

00:32:22.480 --> 00:32:26.950
在我们可以更换港口的能力

00:32:24.910 --> 00:32:28.690
得到一些非常好的好处， 

00:32:26.950 --> 00:32:32.200
您在这种情况下看到的好处是

00:32:28.690 --> 00:32:34.810
我们该如何做的迷人特征

00:32:32.200 --> 00:32:37.180
在函数组成风格上

00:32:34.810 --> 00:32:39.640
但是在我们谈论这个之前

00:32:37.180 --> 00:32:42.130
让我们谈谈一种好处，以及我们如何

00:32:39.640 --> 00:32:45.340
可以实现这一利益，所以真正的

00:32:42.130 --> 00:32:48.220
 Java 8的魅力在于Java 8 

00:32:45.340 --> 00:32:51.160
实际上做的事情远不止于此

00:32:48.220 --> 00:32:53.320
提供只是一种函数式风格

00:32:51.160 --> 00:32:56.470
编程Java并没有走开

00:32:53.320 --> 00:32:58.480
说这是lambdas，祝你好运

00:32:56.470 --> 00:33:00.520
在我不了解的Java 8书中是正确的

00:32:58.480 --> 00:33:02.290
书中的某些内容

00:33:00.520 --> 00:33:04.660
令我惊讶的是，即使我写了它，但我的

00:33:02.290 --> 00:33:07.090
声明是

00:33:04.660 --> 00:33:09.330
门户毒品，但流才是真正的

00:33:07.090 --> 00:33:12.490
瘾，所以重点是

00:33:09.330 --> 00:33:14.080
 Lambda真的吸引了您

00:33:12.490 --> 00:33:15.940
但是流是

00:33:14.080 --> 00:33:17.080
要留住你，因为如果你

00:33:15.940 --> 00:33:19.780
没有表现，你会

00:33:17.080 --> 00:33:22.090
一进来就离开，但是怎么办

00:33:19.780 --> 00:33:22.600
流让我们表现出色

00:33:22.090 --> 00:33:24.880
关于

00:33:22.600 --> 00:33:28.059
真快，让我们回到这个

00:33:24.880 --> 00:33:30.520
快速真实的例子，并理解一个

00:33:28.059 --> 00:33:33.400
关键差异请注意

00:33:30.520 --> 00:33:36.400
这个例子我们有一个流

00:33:33.400 --> 00:33:38.380
跟清单有很大的不同，让我们来谈谈

00:33:36.400 --> 00:33:41.679
关于这两个一分钟，把

00:33:38.380 --> 00:33:46.330
单词列表下来一秒钟，也

00:33:41.679 --> 00:33:50.080
单词流列表是具体的

00:33:46.330 --> 00:33:51.370
另一手是抽象的耶

00:33:50.080 --> 00:33:55.750
那个的真实意义是什么

00:33:51.370 --> 00:33:58.299
清单是一个容器，这是一个

00:33:55.750 --> 00:34:01.059
一系列仍然没有的功能

00:33:58.299 --> 00:34:03.490
敲钟想起我这个词桶

00:34:01.059 --> 00:34:06.549
可以有一个桶和一堆水

00:34:03.490 --> 00:34:09.940
桶里装着水，我可以

00:34:06.549 --> 00:34:13.060
把水放在桶里我可以来

00:34:09.940 --> 00:34:16.389
返回并使用储存在

00:34:13.060 --> 00:34:19.510
桶列表是我们存储的容器

00:34:16.389 --> 00:34:23.470
另一方面塞入其中

00:34:19.510 --> 00:34:26.260
是液体流过的管道

00:34:23.470 --> 00:34:28.929
数据流经此管道不是

00:34:26.260 --> 00:34:31.780
用于存储东西，用于转换

00:34:28.929 --> 00:34:34.300
将清单移动到容器中

00:34:31.780 --> 00:34:37.270
像水桶一样，溪流是一系列的

00:34:34.300 --> 00:34:40.000
转换功能的管道

00:34:37.270 --> 00:34:42.369
在这方面的数据

00:34:40.000 --> 00:34:45.100
这到底是什么意思

00:34:42.369 --> 00:34:47.830
我们对我们意味着什么

00:34:45.100 --> 00:34:49.480
一系列了解的转变

00:34:47.830 --> 00:34:51.550
好一点，让我们回去

00:34:49.480 --> 00:34:54.070
另一个我们之前看到的例子

00:34:51.550 --> 00:34:57.190
那么我们将回到这个真实的

00:34:54.070 --> 00:35:00.070
快速让我们带回我们的样本点RB 

00:34:57.190 --> 00:35:03.250
代码在这里，看看

00:35:00.070 --> 00:35:06.280
如果您查看Ruby代码，请再读一遍

00:35:03.250 --> 00:35:09.580
这个例子要仔细观察

00:35:06.280 --> 00:35:13.950
法院采取的执行路径

00:35:09.580 --> 00:35:18.810
执行大于功能

00:35:13.950 --> 00:35:24.700
每个值，那么Ruby做了什么

00:35:18.810 --> 00:35:29.350
将第一个功能应用于整个

00:35:24.700 --> 00:35:33.790
收藏然后说第二

00:35:29.350 --> 00:35:36.010
在结果集合上起作用

00:35:33.790 --> 00:35:38.440
渴望的其他话

00:35:36.010 --> 00:35:41.260
记住这一点，我们将了解Java 

00:35:38.440 --> 00:35:47.650
在这种情况下事情有很大不同

00:35:41.260 --> 00:35:50.829
 Java的假设是lambda 

00:35:47.650 --> 00:35:53.980
表情很纯正这是一大

00:35:50.829 --> 00:35:56.710
 Haskell和Java之间的区别是

00:35:53.980 --> 00:35:58.990
我认为Haskell有点无聊

00:35:56.710 --> 00:36:01.359
会回来打败你并说

00:35:58.990 --> 00:36:02.109
你不会变异，你不会

00:36:01.359 --> 00:36:05.170
副作用

00:36:02.109 --> 00:36:08.589
 Haskell将强调并验证和

00:36:05.170 --> 00:36:11.230
确认并跟随您回家坐在旁边

00:36:08.589 --> 00:36:13.990
你盯着你说最好

00:36:11.230 --> 00:36:16.839
我认为纯Java更好

00:36:13.990 --> 00:36:19.780
因此，因为Java假设

00:36:16.839 --> 00:36:22.630
 Lambda是纯净的

00:36:19.780 --> 00:36:26.829
当您和

00:36:22.630 --> 00:36:28.329
 Java不同意你知道谁赢了，所以这

00:36:26.829 --> 00:36:30.940
是为什么如果你的原因之一

00:36:28.329 --> 00:36:33.760
在Haskell中编程，您将继续

00:36:30.940 --> 00:36:36.970
时间，你的孩子问你怎么做

00:36:33.760 --> 00:36:39.010
工作妈妈，你会说这是

00:36:36.970 --> 00:36:41.980
倒所有我写的单词

00:36:39.010 --> 00:36:44.619
另一方面，你已经没有乐趣了

00:36:41.980 --> 00:36:48.640
 Java代码，也许您忘记了

00:36:44.619 --> 00:36:52.480
这些lambda很纯粹，你迟到了

00:36:48.640 --> 00:36:54.220
在工作很累的一天之后，您

00:36:52.480 --> 00:36:57.250
回家，孩子们问你过得怎么样

00:36:54.220 --> 00:37:00.160
工作一天过得怎么样，你说让我

00:36:57.250 --> 00:37:02.260
告诉你一切，我们有一个怪物

00:37:00.160 --> 00:37:03.400
我们不得不解决其他故事

00:37:02.260 --> 00:37:05.500
告诉我，这就是为什么我的原因之一

00:37:03.400 --> 00:37:07.540
喜欢这些语言，好吧，我是

00:37:05.500 --> 00:37:10.390
这里有点开玩笑，但

00:37:07.540 --> 00:37:12.760
重点虽然是不要忘记Java 

00:37:10.390 --> 00:37:16.060
可能不会真正警告您，可能不会给您

00:37:12.760 --> 00:37:19.359
如果您在lambda中进行了变异，则会出现错误

00:37:16.060 --> 00:37:22.089
因为Java假设lambda是纯的

00:37:19.359 --> 00:37:25.810
纯洁使我们说话变得懒惰

00:37:22.089 --> 00:37:27.310
左右流本质上是懒惰的

00:37:25.810 --> 00:37:30.460
这种方法的好处是什么

00:37:27.310 --> 00:37:33.700
让我们现在谈论这个与众不同

00:37:30.460 --> 00:37:37.930
 Java与Ruby之类的语言

00:37:33.700 --> 00:37:43.290
 Java的情况下

00:37:37.930 --> 00:37:48.820
函数作为每个元素应用

00:37:43.290 --> 00:37:54.730
根据需要

00:37:48.820 --> 00:38:00.790
的功能是飞行

00:37:54.730 --> 00:38:04.480
被应用到每个

00:38:00.790 --> 00:38:07.470
整个收藏，所以让我们重新回顾一下

00:38:04.480 --> 00:38:09.910
如果是Ruby，则再重复一次

00:38:07.470 --> 00:38:13.690
功能被整体应用

00:38:09.910 --> 00:38:17.860
集合不是Java中的集合

00:38:13.690 --> 00:38:21.460
的功能应用于每个元素

00:38:17.860 --> 00:38:25.140
必要时Java会做什么

00:38:21.460 --> 00:38:28.840
采取这些功能，这些被称为

00:38:25.140 --> 00:38:31.510
中间操作如此中间

00:38:28.840 --> 00:38:32.110
操作，这些当然是

00:38:31.510 --> 00:38:35.830
叫

00:38:32.110 --> 00:38:37.990
我们的终端操作，因此

00:38:35.830 --> 00:38:40.090
 Java的

00:38:37.990 --> 00:38:44.740
它会花所有的中间

00:38:40.090 --> 00:38:48.280
操作和功能融合在一起

00:38:44.740 --> 00:38:51.070
在一起，所以它将占据所有

00:38:48.280 --> 00:38:53.520
这些中间操作， 

00:38:51.070 --> 00:38:56.920
将它们融合在一起

00:38:53.520 --> 00:38:59.440
它所应用的功能的集合

00:38:56.920 --> 00:39:03.250
每个功能的集合

00:38:59.440 --> 00:39:04.770
元素，但仅在必要时

00:39:03.250 --> 00:39:06.670
更好地理解这一点

00:39:04.770 --> 00:39:09.430
让我们来看看

00:39:06.670 --> 00:39:13.210
在这里使用不同的示例并使用它

00:39:09.430 --> 00:39:15.880
因此，而不是要求所有人

00:39:13.210 --> 00:39:18.160
 18岁以下的年轻人及其名字

00:39:15.880 --> 00:39:20.860
用大写字母来说，我们只想要

00:39:18.160 --> 00:39:24.970
第一个，所以我们回到这里，我们

00:39:20.860 --> 00:39:27.010
只会说dart首先找到什么

00:39:24.970 --> 00:39:30.160
如果我们没有价值，那我们是什么

00:39:27.010 --> 00:39:33.040
会说我们的精灵会说不

00:39:30.160 --> 00:39:35.770
一个发现，所以当我运行这个小代码

00:39:33.040 --> 00:39:38.560
现在您可以看到它产生了Jack 

00:39:35.770 --> 00:39:40.570
在这种情况下，我们当然可以得到结果

00:39:38.560 --> 00:39:41.140
返回并正确删除此操作

00:39:40.570 --> 00:39:43.570
这里

00:39:41.140 --> 00:39:46.060
这是当务之急的风格，我们将

00:39:43.570 --> 00:39:49.150
只需使用样式代码的功能

00:39:46.060 --> 00:39:52.390
就在这里，除了杰克， 

00:39:49.150 --> 00:39:54.850
此集合中的第一个值

00:39:52.390 --> 00:39:57.190
此输出让我们返回并删除

00:39:54.850 --> 00:40:01.150
注释掉代码并运行此方法

00:39:57.190 --> 00:40:03.160
这个去真的很好，想象你是

00:40:01.150 --> 00:40:05.980
在工作中

00:40:03.160 --> 00:40:07.060
老板给你打电话说15 

00:40:05.980 --> 00:40:09.850
为你生产

00:40:07.060 --> 00:40:14.680
你有一个项目要开始

00:40:09.850 --> 00:40:16.900
它应该在4月15日到期

00:40:14.680 --> 00:40:19.720
一月份从老板办公室出来

00:40:16.900 --> 00:40:21.220
 15号，马上就开始

00:40:19.720 --> 00:40:23.770
当然不是

00:40:21.220 --> 00:40:25.390
您将在四月立即开始

00:40:23.770 --> 00:40:26.230
第十四不是吗，因为它应该在

00:40:25.390 --> 00:40:29.080
 15 

00:40:26.230 --> 00:40:32.050
那就是所谓的效率点

00:40:29.080 --> 00:40:34.600
真的是我们不做那些事

00:40:32.050 --> 00:40:36.310
变得相关和迫在眉睫

00:40:34.600 --> 00:40:38.680
你知道你要在3月1日辞职

00:40:36.310 --> 00:40:41.560
你为什么还要开始这个

00:40:38.680 --> 00:40:43.720
早于这一点，真正的是我们

00:40:41.560 --> 00:40:46.390
通过不做你没有的事情而拥有

00:40:43.720 --> 00:40:48.310
现在就可以专注于

00:40:46.390 --> 00:40:50.380
现在必须要做的事情

00:40:48.310 --> 00:40:52.180
如果事情不相关

00:40:50.380 --> 00:40:55.030
最终，您不必这样做， 

00:40:52.180 --> 00:40:56.800
这就是所谓的效率，我会发现

00:40:55.030 --> 00:40:58.720
有人真的很忙，付出

00:40:56.800 --> 00:41:01.720
他们工作，他们就完成了，但是如何

00:40:58.720 --> 00:41:03.160
因为他们优先考虑而他们没有

00:41:01.720 --> 00:41:06.370
浪费时间做事情

00:41:03.160 --> 00:41:08.290
没必要，这才是重点

00:41:06.370 --> 00:41:11.650
您想要在什么方面高效

00:41:08.290 --> 00:41:14.680
您不仅会更快，所以两者

00:41:11.650 --> 00:41:16.300
明智的是，在编程中，懒惰是

00:41:14.680 --> 00:41:19.090
如我们所见，终极成熟

00:41:16.300 --> 00:41:20.800
现在让我们证明一下

00:41:19.090 --> 00:41:23.380
您运行代码，看到杰克

00:41:20.800 --> 00:41:26.950
但让我们去真正的人课堂

00:41:23.380 --> 00:41:29.530
我记得我们在人际班上快

00:41:26.950 --> 00:41:32.290
先问年龄，然后问

00:41:29.530 --> 00:41:35.820
名称，让我们转到年龄函数，然后

00:41:32.290 --> 00:41:39.190
我们将在这里输出，将年龄称为

00:41:35.820 --> 00:41:41.830
为此，在这种情况下，我们将输出

00:41:39.190 --> 00:41:44.440
这个人的名字我们也要去

00:41:41.830 --> 00:41:47.770
向前说在这种情况下，然后说出名字

00:41:44.440 --> 00:41:51.700
自己会说得到这样的名字

00:41:47.770 --> 00:41:53.800
当然，这将是名字

00:41:51.700 --> 00:41:56.860
我们将打印出整齐的细节

00:41:53.800 --> 00:41:58.600
那但如果这很切记

00:41:56.860 --> 00:42:00.550
 Ruby这样的语言发生了什么

00:41:58.600 --> 00:42:03.880
渴望并执行了第一个

00:42:00.550 --> 00:42:06.610
约翰每件事的方法

00:42:03.880 --> 00:42:10.150
渴望能问到年龄

00:42:06.610 --> 00:42:13.720
每个人，包括这个杰克

00:42:10.150 --> 00:42:16.930
而这个吉尔在这个特殊的

00:42:13.720 --> 00:42:19.420
案例，因为杰克是我们的结果

00:42:16.930 --> 00:42:21.910
寻找它，我们将永远不必碰

00:42:19.420 --> 00:42:24.400
这样的笑话和这个笑话可能不是这样

00:42:21.910 --> 00:42:27.220
在这种情况下很重要，但是如果这

00:42:24.400 --> 00:42:29.650
是一百万个元素

00:42:27.220 --> 00:42:32.020
在此之后的元素我们不想

00:42:29.650 --> 00:42:35.050
找到结果后对它们进行评估，以便

00:42:32.020 --> 00:42:37.950
在这种情况下，年龄将是

00:42:35.050 --> 00:42:41.280
调用了将要调用的内容

00:42:37.950 --> 00:42:44.319
莎拉（Sarah） 

00:42:41.280 --> 00:42:47.920
但是有一个很大的不同

00:42:44.319 --> 00:42:51.670
尽管它不会调用get 

00:42:47.920 --> 00:42:53.470
约翰，如果你再把所有要素都放在首位

00:42:51.670 --> 00:42:57.369
回到这个例子并运行

00:42:53.470 --> 00:43:00.339
请注意，评估后的YZ g t-54全部

00:42:57.369 --> 00:43:03.069
元素才开始

00:43:00.339 --> 00:43:06.250
评估double函数不是这样

00:43:03.069 --> 00:43:09.550
 Java评估这些组

00:43:06.250 --> 00:43:12.700
根据需要在一个元素上起作用

00:43:09.550 --> 00:43:15.430
一段时间，所以我运行此代码，请注意

00:43:12.700 --> 00:43:18.040
叫萨拉（Sarah）变老Sarab Bob Paula 

00:43:15.430 --> 00:43:20.349
保罗·杰克（Paul Jack），但随后电话打响

00:43:18.040 --> 00:43:23.530
杰克，但从未触及第二

00:43:20.349 --> 00:43:25.150
杰克和B和吉尔（Jill）嗯

00:43:23.530 --> 00:43:27.190
很好地说明了我想展示的内容

00:43:25.150 --> 00:43:29.799
这里不是吗，让我们尝试一下

00:43:27.190 --> 00:43:34.690
举例来说，我想要

00:43:29.799 --> 00:43:38.710
 20岁以上但第一人称

00:43:34.690 --> 00:43:42.730
也是一位年龄超过20岁的女性

00:43:38.710 --> 00:43:46.180
那是莎拉，也是一位女性

00:43:42.730 --> 00:43:49.270
莎拉-让我们一起成为男人30 

00:43:46.180 --> 00:43:50.290
那将是宝拉很棒，所以让我们

00:43:49.270 --> 00:43:54.819
评估

00:43:50.290 --> 00:43:58.299
所以得到H大于30然后我

00:43:54.819 --> 00:44:01.450
想说在这种情况下的过滤器

00:43:58.299 --> 00:44:06.520
当然，我们想说给一个人

00:44:01.450 --> 00:44:08.710
会说人黑暗得到性别

00:44:06.520 --> 00:44:11.740
这种情况当然等于性别

00:44:08.710 --> 00:44:13.359
当我运行这个小代码时，点女性

00:44:11.740 --> 00:44:15.040
让我们继续进行评论

00:44:13.359 --> 00:44:17.770
请稍等一下

00:44:15.040 --> 00:44:19.720
我们将继续进行打印

00:44:17.770 --> 00:44:23.799
也让孩子们有性别，所以我们可以

00:44:19.720 --> 00:44:27.609
看着它到这里，所以这里是乔得到

00:44:23.799 --> 00:44:29.470
性别，所以我们说让性别呼吁

00:44:27.609 --> 00:44:32.349
所以

00:44:29.470 --> 00:44:34.210
然后当然要走了

00:44:32.349 --> 00:44:37.450
继续并运行这个真实的例子是

00:44:34.210 --> 00:44:40.569
宝拉（Paula）是否急于要求您

00:44:37.450 --> 00:44:43.750
每个人的年龄

00:44:40.569 --> 00:44:46.990
或30岁以上所有人的名字

00:44:43.750 --> 00:44:49.930
 30和女性仅转换所有名称

00:44:46.990 --> 00:44:52.480
丢掉大部分工作，但没有

00:44:49.930 --> 00:44:55.329
所以在这个例子中，如果我回到

00:44:52.480 --> 00:44:58.930
取消注释这些打印语句

00:44:55.329 --> 00:45:00.790
您在这里注意到的是

00:44:58.930 --> 00:45:04.420
我们想知道的顺序

00:45:00.790 --> 00:45:06.700
输出它叫得到约翰·萨拉

00:45:04.420 --> 00:45:10.270
在第二个Sarah叫get 8 

00:45:06.700 --> 00:45:13.510
拜访鲍勃和宝拉，然后性别

00:45:10.270 --> 00:45:16.810
宝拉的名字是帕拉，如果我是

00:45:13.510 --> 00:45:19.630
把这个翻过来，要求所有

00:45:16.810 --> 00:45:22.420
首先是女性，然后是年龄

00:45:19.630 --> 00:45:25.270
注意它要求在Sarah和

00:45:22.420 --> 00:45:27.490
萨拉（Sarah）的年龄马上就性别先天

00:45:25.270 --> 00:45:30.700
第二个莎拉马上就性别

00:45:27.490 --> 00:45:33.670
 Bob和Paula的性别，Paula和

00:45:30.700 --> 00:45:37.060
 Mayman Paula只看前四个

00:45:33.670 --> 00:45:40.089
对我而言，注意事项变性别变年龄

00:45:37.060 --> 00:45:42.670
然后再次获得性别并获得年龄

00:45:40.089 --> 00:45:46.030
换句话说，再次获得性别

00:45:42.670 --> 00:45:48.700
 Ruby其中所有方法之一

00:45:46.030 --> 00:45:51.760
线被急切地执行，这是

00:45:48.700 --> 00:45:54.940
绝对懒惰，它有点评估

00:45:51.760 --> 00:45:57.670
第一个功能和第二个功能的位

00:45:54.940 --> 00:46:01.079
只要它可以进入其他地方

00:45:57.670 --> 00:46:03.730
文字融合了这些功能

00:46:01.079 --> 00:46:06.310
功能集合适用于一个

00:46:03.730 --> 00:46:08.470
元素莎拉，如果需要的话

00:46:06.310 --> 00:46:11.530
第二和第三但一分钟

00:46:08.470 --> 00:46:14.770
找到答案不再适用

00:46:11.530 --> 00:46:17.200
实际上，让我们进入下一个层次

00:46:14.770 --> 00:46:19.900
看看懒惰如何真正在

00:46:17.200 --> 00:46:23.020
如果我们要回到这里

00:46:19.900 --> 00:46:26.020
例子，让我们删除打印行

00:46:23.020 --> 00:46:29.109
一秒钟，在这种情况下，我要去

00:46:26.020 --> 00:46:30.790
继续说在这里什么时候完成

00:46:29.109 --> 00:46:33.849
我执行代码，您可以看到所有

00:46:30.790 --> 00:46:37.550
输出，但是如果我完成了

00:46:33.849 --> 00:46:41.330
会回去只评论

00:46:37.550 --> 00:46:44.240
最后两行，那么我们不是

00:46:41.330 --> 00:46:47.660
调用终端方法，我们有这个

00:46:44.240 --> 00:46:50.210
该终端功能的集合

00:46:47.660 --> 00:46:52.460
融合在一起，但我们从不称之为

00:46:50.210 --> 00:46:54.680
终端方法这是一种终端方法

00:46:52.460 --> 00:46:57.800
可以触发评估

00:46:54.680 --> 00:47:01.250
看到这里的结果就完成了

00:46:57.800 --> 00:47:02.600
并没有真正执行所有

00:47:01.250 --> 00:47:06.380
中间功能

00:47:02.600 --> 00:47:08.390
我一直在偷懒

00:47:06.380 --> 00:47:11.450
在我们正在处理的项目中

00:47:08.390 --> 00:47:13.700
数以百万计的

00:47:11.450 --> 00:47:15.620
我们一直在运行的数据

00:47:13.700 --> 00:47:19.480
通过功能管道

00:47:15.620 --> 00:47:21.680
 lambdas实际上很多lambdas和

00:47:19.480 --> 00:47:24.440
我们没有看到任何表现

00:47:21.680 --> 00:47:26.990
由于lambda或由于

00:47:24.440 --> 00:47:29.300
管道实际上是有好处的

00:47:26.990 --> 00:47:31.430
马上行动，我们不仅可以

00:47:29.300 --> 00:47:33.980
通过花边评估提高效率

00:47:31.430 --> 00:47:37.070
我们也可以使得分麻痹

00:47:33.980 --> 00:47:39.890
更容易到达那里，如果

00:47:37.070 --> 00:47:42.860
我们有很多数据需要处理

00:47:39.890 --> 00:47:45.500
换句话说，风格的功能

00:47:42.860 --> 00:47:46.700
编程很迷人

00:47:45.500 --> 00:47:50.780
功能流水线

00:47:46.700 --> 00:47:53.690
很漂亮，它消除了意外

00:47:50.780 --> 00:47:56.120
代码的复杂度与

00:47:53.690 --> 00:47:58.880
命令式代码的功能

00:47:56.120 --> 00:48:00.770
样式代码是一次通过

00:47:58.880 --> 00:48:02.960
代码开始像问题一样读

00:48:00.770 --> 00:48:05.300
声明我们可以关联什么代码

00:48:02.960 --> 00:48:07.520
正在做，我们可以快速了解

00:48:05.300 --> 00:48:09.410
它消除了意外的复杂性

00:48:07.520 --> 00:48:12.740
使代码更容易理解

00:48:09.410 --> 00:48:15.890
代码是Cookie的每一行

00:48:12.740 --> 00:48:18.740
仅此行的代码

00:48:15.890 --> 00:48:21.590
检查一个人是女性还是男性

00:48:18.740 --> 00:48:24.560
这会检查年龄是否大于

00:48:21.590 --> 00:48:26.420
 30这得到转换的名称

00:48:24.560 --> 00:48:28.550
大写的名字比较

00:48:26.420 --> 00:48:30.320
我们之前编写的代码在一行

00:48:28.550 --> 00:48:33.200
在做很多事情缺乏

00:48:30.320 --> 00:48:36.410
凝聚力这更容易消除

00:48:33.200 --> 00:48:38.720
一些碎片或添加一些碎片

00:48:36.410 --> 00:48:41.420
内聚的内聚的代码更容易

00:48:38.720 --> 00:48:44.120
修改代码以消除阻抗

00:48:41.420 --> 00:48:46.370
试图弄清楚和不匹配

00:48:44.120 --> 00:48:48.560
提取业务逻辑的细节

00:48:46.370 --> 00:48:50.690
从代码中，代码变成

00:48:48.560 --> 00:48:50.860
商业逻辑，代码变得更容易

00:48:50.690 --> 00:48:53.650
至

00:48:50.860 --> 00:48:55.720
了解并看到它在做什么，但是

00:48:53.650 --> 00:48:59.020
当然我们不能声称所有这一切

00:48:55.720 --> 00:49:02.470
美丽是伟大的，但我们不能放弃

00:48:59.020 --> 00:49:05.620
性能对我来说真的很抢手

00:49:02.470 --> 00:49:08.740
我对Java的关注不是事实

00:49:05.620 --> 00:49:10.840
 Java有lambda表达式

00:49:08.740 --> 00:49:15.250
你猛烈抨击其他语言Ruby 

00:49:10.840 --> 00:49:17.890
时髦的Python等等

00:49:15.250 --> 00:49:21.610
当然是关闭，依此类推

00:49:17.890 --> 00:49:24.310
所有这些漂亮的功能

00:49:21.610 --> 00:49:26.320
这些的流水线和表达代码

00:49:24.310 --> 00:49:29.230
我们只能构架和庆祝的事情

00:49:26.320 --> 00:49:32.950
但不能真正在大型项目中使用

00:49:29.230 --> 00:49:36.610
如果语言支持，则可以进行大数据项目

00:49:32.950 --> 00:49:39.220
不支持懒惰的评估，所以事实

00:49:36.610 --> 00:49:41.680
 Java支持懒惰是其中之一

00:49:39.220 --> 00:49:43.540
最迷人的功能流是

00:49:41.680 --> 00:49:45.250
真的很强大，但是有

00:49:43.540 --> 00:49:47.590
 Java中流式传输的限制

00:49:45.250 --> 00:49:50.200
不幸的是，Java流无法处理

00:49:47.590 --> 00:49:52.450
例外真的很好，如果真的

00:49:50.200 --> 00:49:54.520
想做强大的流媒体

00:49:52.450 --> 00:49:56.740
您可以做的其他事情，例如

00:49:54.520 --> 00:49:59.470
反应式编程模型可观察

00:49:56.740 --> 00:50:01.630
并流动那些想法不是很

00:49:59.470 --> 00:50:03.160
与溪流不同的只是溪流

00:50:01.630 --> 00:50:05.260
用Java实现的有一些

00:50:03.160 --> 00:50:07.240
限制我们确实使用流

00:50:05.260 --> 00:50:09.160
当我们不需要的时候

00:50:07.240 --> 00:50:12.550
担心这些限制取决于

00:50:09.160 --> 00:50:14.890
的情况，但就像我说的语言

00:50:12.550 --> 00:50:17.290
被创造出不同的原因之一

00:50:14.890 --> 00:50:20.320
我为Java感到非常兴奋

00:50:17.290 --> 00:50:23.140
 Java有lambdas的事实

00:50:20.320 --> 00:50:26.800
真正让我懂Java的人是

00:50:23.140 --> 00:50:29.050
流很懒，实际上是

00:50:26.800 --> 00:50:31.270
懒惰吸引了我进入Java 8和

00:50:29.050 --> 00:50:33.840
从那以后我一直在赞美它

00:50:31.270 --> 00:50:37.510
如果Java没有实现懒惰

00:50:33.840 --> 00:50:39.520
到流API，我们不会谈论

00:50:37.510 --> 00:50:43.330
关于Java 8并感到兴奋

00:50:39.520 --> 00:50:46.390
所以我最后会说懒惰

00:50:43.330 --> 00:50:49.720
两者的终极复杂性

00:50:46.390 --> 00:50:52.800
编程和生活中的希望是

00:50:49.720 --> 00:50:52.800
有用的谢谢

00:50:57.770 --> 00:50:59.830
您

00:51:10.609 --> 00:51:12.670
您

00:51:14.720 --> 00:51:16.780
您

00:51:49.960 --> 00:51:52.020
您

00:51:54.540 --> 00:51:56.600
您

00:51:57.980 --> 00:52:00.040
您

00:52:01.359 --> 00:52:03.420
您

00:52:10.840 --> 00:52:12.900
您

00:52:15.730 --> 00:52:17.790
您

00:53:13.540 --> 00:53:15.600
您

00:53:27.420 --> 00:53:29.480
您

00:56:21.430 --> 00:56:23.490
您

00:56:49.920 --> 00:56:51.980
您

00:57:40.829 --> 00:57:42.890
您

00:57:46.840 --> 00:57:48.900
您

00:57:51.490 --> 00:57:53.550
您

00:57:58.270 --> 00:58:00.330
您

00:59:07.460 --> 00:59:09.520
您

00:59:24.059 --> 00:59:26.119
您

00:59:26.799 --> 00:59:28.859
您

00:59:30.040 --> 00:59:32.100
您

00:59:49.260 --> 00:59:51.320
您

00:59:52.150 --> 00:59:54.210
您

00:59:57.970 --> 01:00:00.030
您

