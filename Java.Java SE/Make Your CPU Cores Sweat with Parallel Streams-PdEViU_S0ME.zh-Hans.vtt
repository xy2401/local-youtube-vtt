WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.220 --> 00:00:09.160
早上好，我想大家

00:00:06.340 --> 00:00:13.450
可以听见我，我听得很好

00:00:09.160 --> 00:00:14.950
我是卢卡斯黄油，接下来的45岁

00:00:13.450 --> 00:00:17.410
分钟，我想告诉你什么

00:00:14.950 --> 00:00:20.470
当你邪恶时发生在引擎盖下

00:00:17.410 --> 00:00:21.820
调用并行流，这样的想法是

00:00:20.470 --> 00:00:23.980
告诉你幕后发生的事情

00:00:21.820 --> 00:00:27.130
并以此为基础

00:00:23.980 --> 00:00:30.189
何时可以得出一些结论

00:00:27.130 --> 00:00:32.890
您的应用程序在不运行时运行得更快

00:00:30.189 --> 00:00:37.930
我是CERN的软件工程师

00:00:32.890 --> 00:00:41.110
过去九年了，好的，CERN是什么

00:00:37.930 --> 00:00:43.989
简而言之，这是一个词

00:00:41.110 --> 00:00:45.610
基本上是最大的物理实验室

00:00:43.989 --> 00:00:48.610
我们研究像

00:00:45.610 --> 00:00:51.850
大自然，我们将尝试像

00:00:48.610 --> 00:00:53.739
严重的问题，例如什么时候

00:00:51.850 --> 00:00:57.370
大学是什么起源的

00:00:53.739 --> 00:00:58.960
等等，在物理学上

00:00:57.370 --> 00:01:00.879
有点有趣，因为对于较小的

00:00:58.960 --> 00:01:01.480
你看你需要更大的东西，怎么

00:01:00.879 --> 00:01:02.980
我们会做吗

00:01:01.480 --> 00:01:06.370
通过建立和维护很好

00:01:02.980 --> 00:01:08.020
运行巨大的粒子加速器和

00:01:06.370 --> 00:01:09.730
也许您知道的其中一个是大型

00:01:08.020 --> 00:01:15.280
强子对撞机最大的机器

00:01:09.730 --> 00:01:17.950
曾经由一个人建造过，就像17英里

00:01:15.280 --> 00:01:22.960
对17英里长

00:01:17.950 --> 00:01:24.880
地下300米，是的

00:01:22.960 --> 00:01:26.410
它真的放在法国和

00:01:24.880 --> 00:01:27.670
瑞士边境在

00:01:26.410 --> 00:01:29.410
背景你会发现一个美丽的

00:01:27.670 --> 00:01:31.630
最好的滑雪美丽的阿尔卑斯山

00:01:29.410 --> 00:01:35.050
在欧洲度假，所以其中的关键要素

00:01:31.630 --> 00:01:37.330
地图，当然也可以这样做

00:01:35.050 --> 00:01:40.240
通过推动的前沿

00:01:37.330 --> 00:01:45.400
有时知识非常

00:01:40.240 --> 00:01:47.050
创造了很好的分拆，所以也许很好

00:01:45.400 --> 00:01:50.680
欧洲核子研究组织也是网络的所在地

00:01:47.050 --> 00:01:55.510
天生的你可能听说过

00:01:50.680 --> 00:01:57.790
蒂姆·伯纳斯·李（Tim berners-lee）在89年发明的

00:01:55.510 --> 00:02:00.220
如果我没记错的话，就像

00:01:57.790 --> 00:02:02.050
有史以来第一台工作的Web服务器

00:02:00.220 --> 00:02:04.270
显然这位先生不是很

00:02:02.050 --> 00:02:05.410
喜欢关闭它，因为

00:02:04.270 --> 00:02:09.129
关闭它，您将切换

00:02:05.410 --> 00:02:12.460
这样的整个网络不是最好的

00:02:09.129 --> 00:02:14.020
这个主意，但我愿意

00:02:12.460 --> 00:02:15.060
谈论更多关于我们可以很快

00:02:14.020 --> 00:02:18.060
之后聊天

00:02:15.060 --> 00:02:22.020
我们不要让我们的CPU少一点

00:02:18.060 --> 00:02:23.700
所以我们走吧，我们直接去

00:02:22.020 --> 00:02:25.560
您实际上不需要的业务

00:02:23.700 --> 00:02:29.340
遵循代码的作用

00:02:25.560 --> 00:02:32.150
首先要开始，所以我认为

00:02:29.340 --> 00:02:34.140
你们每个人都同意

00:02:32.150 --> 00:02:36.920
收藏是最重的收藏之一

00:02:34.140 --> 00:02:38.819
 api是Java的，但实际上尽管

00:02:36.920 --> 00:02:41.430
几乎所有工作都需要

00:02:38.819 --> 00:02:44.040
操纵它们的应用程序

00:02:41.430 --> 00:02:45.720
总是有点痛苦，所以每当你

00:02:44.040 --> 00:02:48.720
必须做一些你总是喜欢的事情

00:02:45.720 --> 00:02:51.150
那个男人为什么我实际上很好

00:02:48.720 --> 00:02:52.950
再次为此挣扎，所以你知道

00:02:51.150 --> 00:02:54.480
你最了解自己多少次

00:02:52.950 --> 00:02:56.780
您是否发现自己可以自由实施

00:02:54.480 --> 00:02:58.739
遍历相同的数据库

00:02:56.780 --> 00:03:01.890
使用所有这些控件的操作

00:02:58.739 --> 00:03:08.040
像所有斜坡一样的块ifs等等

00:03:01.890 --> 00:03:10.019
而这正是流API 

00:03:08.040 --> 00:03:13.040
试图在这里基本上解决

00:03:10.019 --> 00:03:16.049
幻灯片完全一样

00:03:13.040 --> 00:03:19.019
功能，真的很好

00:03:16.049 --> 00:03:20.940
读起来像问题陈述

00:03:19.019 --> 00:03:23.609
这实际上就是

00:03:20.940 --> 00:03:25.739
流是关于，所以他们是一个更新

00:03:23.609 --> 00:03:28.590
到让您轻松使用的Java API 

00:03:25.739 --> 00:03:30.450
不仅善于操作收藏

00:03:28.590 --> 00:03:33.600
集合实际上就像一个序列

00:03:30.450 --> 00:03:36.060
以声明的方式设置一组值

00:03:33.600 --> 00:03:39.150
你说你说你想要什么而不是

00:03:36.060 --> 00:03:40.980
实际上，如果您

00:03:39.150 --> 00:03:42.150
你寻找一个比喻，就像什么时候

00:03:40.980 --> 00:03:44.040
您在看电影时

00:03:42.150 --> 00:03:46.109
互联网就像流一样， 

00:03:44.040 --> 00:03:47.970
框架流保持的元素

00:03:46.109 --> 00:03:50.579
如果你喜欢在电影上

00:03:47.970 --> 00:03:53.220
 DVD如果更像是收藏

00:03:50.579 --> 00:03:54.930
你如果你间隔Asif II流

00:03:53.220 --> 00:03:57.870
就像一组传播的价值观

00:03:54.930 --> 00:03:59.459
随着时间的流逝，而一个收集会

00:03:57.870 --> 00:04:00.060
就像设置一个值

00:03:59.459 --> 00:04:05.010
空间

00:04:00.060 --> 00:04:07.260
在我们的情况下，计算机空间又多了

00:04:05.010 --> 00:04:09.209
流很好的例子

00:04:07.260 --> 00:04:11.730
我们在这里做什么我们有一堆

00:04:09.209 --> 00:04:13.560
我们将它们映射的数量进行过滤

00:04:11.730 --> 00:04:15.510
只有那些素数，然后我们检查

00:04:13.560 --> 00:04:18.150
我们将它们转换为二进制字符串

00:04:15.510 --> 00:04:20.729
然后我们检查是否是回文

00:04:18.150 --> 00:04:23.039
因此，是否从左至右阅读

00:04:20.729 --> 00:04:25.360
左右或从右到左

00:04:23.039 --> 00:04:27.669
将是相同的，我们算我们的

00:04:25.360 --> 00:04:29.439
我们有几个，实际上

00:04:27.669 --> 00:04:30.580
虽然这可能是这个例子

00:04:29.439 --> 00:04:32.259
完全没有道理

00:04:30.580 --> 00:04:34.389
仍然需要像五个一样

00:04:32.259 --> 00:04:37.330
几秒钟就能弄清楚它到底是什么

00:04:34.389 --> 00:04:41.620
确实，这正是什么

00:04:37.330 --> 00:04:44.770
溪流是关于但那怎么办

00:04:41.620 --> 00:04:46.719
它的性能怎么样

00:04:44.770 --> 00:04:49.030
素数计算素数

00:04:46.719 --> 00:04:51.430
好困难的事情，它必须

00:04:49.030 --> 00:04:53.800
很难，因为否则

00:04:51.430 --> 00:04:58.960
对称密码学会因此中断

00:04:53.800 --> 00:05:00.879
这是CPOE first e，如果您

00:04:58.960 --> 00:05:03.580
考虑一下

00:05:00.879 --> 00:05:06.069
芯片制造，所以当你看着你

00:05:03.580 --> 00:05:08.889
回头看，特性如何

00:05:06.069 --> 00:05:12.009
主要睡眠芯片的变化

00:05:08.889 --> 00:05:15.310
年，因为我不知道二三

00:05:12.009 --> 00:05:18.939
几十年来，我们度过了一段美好的时光， 

00:05:15.310 --> 00:05:22.210
基本上每年我们都有

00:05:18.939 --> 00:05:24.159
这个指数行增长和

00:05:22.210 --> 00:05:26.529
时钟速度，所以基本上您只需要

00:05:24.159 --> 00:05:28.150
使此应用程序更快的方法是

00:05:26.529 --> 00:05:30.969
去的就是去商店买一个

00:05:28.150 --> 00:05:34.419
每年或每18个月购买一台新PC， 

00:05:30.969 --> 00:05:35.680
瞧，速度快了两倍

00:05:34.419 --> 00:05:38.860
生活就是那样美好

00:05:35.680 --> 00:05:41.080
直到2000年左右

00:05:38.860 --> 00:05:43.659
当摩尔定律可以给出

00:05:41.080 --> 00:05:45.759
你实际上并不快

00:05:43.659 --> 00:05:47.710
当然要有更多核心

00:05:45.759 --> 00:05:50.440
实际上要加快

00:05:47.710 --> 00:05:54.219
应用程序确实必须利用

00:05:50.440 --> 00:05:56.349
多核架构，我认为

00:05:54.219 --> 00:05:58.180
 Java特别好看

00:05:56.349 --> 00:06:01.960
他们的硬件趋势是

00:05:58.180 --> 00:06:05.080
真正塑造了软件趋势

00:06:01.960 --> 00:06:08.560
所以如果你想什么时候再去

00:06:05.080 --> 00:06:11.710
有点时光倒流，所以从

00:06:08.560 --> 00:06:14.020
在很早的时候，您就拥有了frets API 

00:06:11.710 --> 00:06:16.719
很好，它基本上是做什么的

00:06:14.020 --> 00:06:18.849
从主执行线分叉

00:06:16.719 --> 00:06:19.389
你可以简单地执行一些东西

00:06:18.849 --> 00:06:22.139
的背景

00:06:19.389 --> 00:06:25.689
这不是关于多核的

00:06:22.139 --> 00:06:29.460
 90年代的开始和结束

00:06:25.689 --> 00:06:32.379
更多的使您的用户界面不

00:06:29.460 --> 00:06:34.599
响应性等等，我认为那是

00:06:32.379 --> 00:06:37.029
演示文稿中的消息是

00:06:34.599 --> 00:06:38.689
好的弗雷德，仍然很好

00:06:37.029 --> 00:06:39.979
对于某些任务，如果您有

00:06:38.689 --> 00:06:43.369
你会很少的东西

00:06:39.979 --> 00:06:45.949
喜欢在后台做你

00:06:43.369 --> 00:06:47.479
看到它会烦恼，因为如果你

00:06:45.949 --> 00:06:50.089
在所有地方应用并行流

00:06:47.479 --> 00:06:52.279
好吧，你只是非常快

00:06:50.089 --> 00:06:55.429
结论是Java 8完全

00:06:52.279 --> 00:06:57.229
很烂，绝对不是你

00:06:55.429 --> 00:07:00.759
只是他们拥有的平行流

00:06:57.229 --> 00:07:05.329
这种分立的责任

00:07:00.759 --> 00:07:08.899
如果我们移动一个CPU饥饿的任务

00:07:05.329 --> 00:07:11.959
在JDK是JDK 5的时候有点向前

00:07:08.899 --> 00:07:14.059
我们很慷慨，因为

00:07:11.959 --> 00:07:18.739
多核CPU越来越多

00:07:14.059 --> 00:07:20.239
受欢迎，所以你有并发

00:07:18.739 --> 00:07:23.050
收集了您的信号量

00:07:20.239 --> 00:07:25.610
有阻塞队列，你也有一个

00:07:23.050 --> 00:07:27.979
执行程序服务和烦人的线程

00:07:25.610 --> 00:07:29.659
池我刚刚在这里列出，因为我们

00:07:27.979 --> 00:07:33.069
知道我们会参考并返回

00:07:29.659 --> 00:07:35.179
所以执行者服务的想法

00:07:33.069 --> 00:07:37.549
嗯，很简单，你就像

00:07:35.179 --> 00:07:39.289
容器只是一堆线程

00:07:37.549 --> 00:07:42.349
那些等你工作的人

00:07:39.289 --> 00:07:44.089
所以你只提交那里的工作

00:07:42.349 --> 00:07:47.779
会为您完成的，所以确实是

00:07:44.089 --> 00:07:50.269
要照顾这个创造

00:07:47.779 --> 00:07:52.459
创建管理和执行

00:07:50.269 --> 00:07:55.729
威胁，你可以拥有

00:07:52.459 --> 00:07:57.469
的不同变化

00:07:55.729 --> 00:07:59.149
遗嘱执行人服务和烦躁的

00:07:57.469 --> 00:08:01.119
例如，您可以将其固定

00:07:59.149 --> 00:08:03.409
您可以拥有的线程数

00:08:01.119 --> 00:08:06.139
预定一个基本同意的

00:08:03.409 --> 00:08:08.929
东西说嘿执行这个东西

00:08:06.139 --> 00:08:12.319
在半小时内或执行它

00:08:08.929 --> 00:08:15.079
每五分钟定期进行一次

00:08:12.319 --> 00:08:20.509
很不错的补充

00:08:15.079 --> 00:08:24.349
 api好的，如果我们再次前进

00:08:20.509 --> 00:08:26.059
随着时间的流逝，我们会按照意愿着陆

00:08:24.349 --> 00:08:28.610
将与平行降落

00:08:26.059 --> 00:08:31.309
流，因此在前一个

00:08:28.610 --> 00:08:34.699
滑动这个漂亮而甜美的声明

00:08:31.309 --> 00:08:36.919
处理您的数据的语法

00:08:34.699 --> 00:08:40.039
收藏只是好东西之一

00:08:36.919 --> 00:08:43.159
这些流是关于它们的

00:08:40.039 --> 00:08:46.759
他们还让您做到了什么

00:08:43.159 --> 00:08:50.450
你可以执行那些

00:08:46.759 --> 00:08:53.540
几乎免费为您串流

00:08:50.450 --> 00:08:56.150
核心CPU，所以基本上您只需要

00:08:53.540 --> 00:08:57.560
要做的就是将游泳变成平行运动

00:08:56.150 --> 00:08:59.840
流，如您所见

00:08:57.560 --> 00:09:02.240
在那口井上的代码是可见的

00:08:59.840 --> 00:09:04.250
在后面我不确定什么

00:09:02.240 --> 00:09:07.340
如果不是，我会这样做，但很可能是

00:09:04.250 --> 00:09:09.380
基本上也要礼貌地问

00:09:07.340 --> 00:09:12.950
在左侧

00:09:09.380 --> 00:09:15.920
再次是我们荒谬的素数

00:09:12.950 --> 00:09:18.500
回文示例，如果

00:09:15.920 --> 00:09:21.350
溪流按顺序运行

00:09:18.500 --> 00:09:26.570
大概不到九秒

00:09:21.350 --> 00:09:28.820
如果我做到就执行

00:09:26.570 --> 00:09:32.180
指示应在以下位置执行

00:09:28.820 --> 00:09:37.730
平行它会很好的是

00:09:32.180 --> 00:09:39.470
上升了五倍，怎么回事

00:09:37.730 --> 00:09:41.210
这可能是什么是什么

00:09:39.470 --> 00:09:43.450
这个技巧很好，主要的技巧是

00:09:41.210 --> 00:09:46.220
使用Java Streams API时， 

00:09:43.450 --> 00:09:48.590
如果我们认为内部迭代又一次

00:09:46.220 --> 00:09:51.230
关于未婚妻告诉我的隐喻

00:09:48.590 --> 00:09:52.940
我要去洗碗她可以

00:09:51.230 --> 00:09:54.830
可以做到，她可以申请外部

00:09:52.940 --> 00:09:57.320
迭代，所以她可以告诉我是

00:09:54.830 --> 00:09:59.240
叉子是刀子还是盘子

00:09:57.320 --> 00:10:01.280
真的可以，只要她对我有信任

00:09:59.240 --> 00:10:03.080
她可以说洗碗

00:10:01.280 --> 00:10:05.630
将会是谁来选择

00:10:03.080 --> 00:10:08.060
把盘子放到刀子上，也许我可以

00:10:05.630 --> 00:10:10.130
引入一些优化，所以这是

00:10:08.060 --> 00:10:12.740
喜欢主要的主要技巧

00:10:10.130 --> 00:10:14.870
它确实和间隔，并在

00:10:12.740 --> 00:10:16.640
它使用此fork / join的背景

00:10:14.870 --> 00:10:20.780
框架和分割器作者，以及

00:10:16.640 --> 00:10:26.170
这正是我们将要看到的

00:10:20.780 --> 00:10:29.120
细节，但在此之前我告诉过您

00:10:26.170 --> 00:10:30.980
将流变成并行的流

00:10:29.120 --> 00:10:33.560
这到底是什么意思

00:10:30.980 --> 00:10:36.920
你如何做到的，所以我们基本上有

00:10:33.560 --> 00:10:40.430
两个选择第一个是如果流

00:10:36.920 --> 00:10:45.050
我们所说的来源基本上是一个集合

00:10:40.430 --> 00:10:47.690
您要做的就是唤起

00:10:45.050 --> 00:10:49.310
如果您的源上并行游泳方法

00:10:47.690 --> 00:10:50.750
这就像一个生成器函数或

00:10:49.310 --> 00:10:55.220
其他的东西，但仍然可以

00:10:50.750 --> 00:10:56.960
实际上，您可以随时收藏

00:10:55.220 --> 00:10:57.950
在您的流管道中拥有这个

00:10:56.960 --> 00:10:59.510
有这个平行

00:10:57.950 --> 00:11:01.130
方法并不重要

00:10:59.510 --> 00:11:04.160
是不是真的在哪里都没关系

00:11:01.130 --> 00:11:07.880
这种方法实际上是

00:11:04.160 --> 00:11:10.190
我们在您的管道中，因此放置

00:11:07.880 --> 00:11:13.010
是否将其像印地一样放在

00:11:10.190 --> 00:11:16.220
结束或您将其放在中间

00:11:13.010 --> 00:11:17.780
并不重要，为什么，因为何时

00:11:16.220 --> 00:11:20.450
您考虑的解​​剖

00:11:17.780 --> 00:11:22.190
所有这些操作的流

00:11:20.450 --> 00:11:24.980
除了最后一个是那些

00:11:22.190 --> 00:11:26.930
中间操作，就是这样

00:11:24.980 --> 00:11:29.030
非常类似于Builder模式

00:11:26.930 --> 00:11:31.460
你只是一直说些什么

00:11:29.030 --> 00:11:34.580
想做，但什么都不会真的

00:11:31.460 --> 00:11:36.230
发生直到终端操作

00:11:34.580 --> 00:11:39.200
真的会被终端调用

00:11:36.230 --> 00:11:41.420
操作是老板，所以实际上

00:11:39.200 --> 00:11:47.690
直到我们做任何事情

00:11:41.420 --> 00:11:49.430
调用终端操作好吧，所以我

00:11:47.690 --> 00:11:50.930
之前说过，我们专注于

00:11:49.430 --> 00:11:53.210
框架是核心

00:11:50.930 --> 00:11:55.640
平行游泳这是什么

00:11:53.210 --> 00:11:59.990
做到这一点是在雇用

00:11:55.640 --> 00:12:01.850
背景，让我们来看看

00:11:59.990 --> 00:12:03.980
那是我做了一点时间的时候

00:12:01.850 --> 00:12:06.230
在我稍稍走过去之前旅行

00:12:03.980 --> 00:12:10.670
故意超过，所以这被添加到一个

00:12:06.230 --> 00:12:12.530
 JDK 5，是的，但也许是

00:12:10.670 --> 00:12:14.030
那不是很有名吗，因为

00:12:12.530 --> 00:12:16.100
这是一种低水平的，我认为

00:12:14.030 --> 00:12:19.730
夸大其词有点夸张

00:12:16.100 --> 00:12:22.550
框架，但不是我

00:12:19.730 --> 00:12:24.410
没事做，那是什么

00:12:22.550 --> 00:12:26.240
 fork / join框架也是

00:12:24.410 --> 00:12:28.840
执行服务的实施

00:12:26.240 --> 00:12:32.180
所以实际上只不过是

00:12:28.840 --> 00:12:34.610
再然后是一堆线程池

00:12:32.180 --> 00:12:36.950
您刚发送给您的线程数

00:12:34.610 --> 00:12:40.220
只是发送那是你可以的

00:12:36.950 --> 00:12:43.100
使您可以在

00:12:40.220 --> 00:12:45.080
平行，所以主要区别

00:12:43.100 --> 00:12:48.170
与我们看到的执行者服务相比

00:12:45.080 --> 00:12:52.100
他看到的几张幻灯片

00:12:48.170 --> 00:12:55.130
专为CPU饥饿而设计

00:12:52.100 --> 00:13:01.600
任务，所以它真的旨在

00:12:55.130 --> 00:13:07.660
递归拆分井分叉过程和

00:13:01.600 --> 00:13:09.790
最终加入，结果如此

00:13:07.660 --> 00:13:12.310
如果我们考虑如果您考虑

00:13:09.790 --> 00:13:15.310
示例它是如何工作的

00:13:12.310 --> 00:13:17.889
想象这可以是数字数组

00:13:15.310 --> 00:13:19.630
我们想做的所有事情

00:13:17.889 --> 00:13:21.639
加上这些数字，因为我们有很多

00:13:19.630 --> 00:13:23.560
这些数字中，我们希望

00:13:21.639 --> 00:13:26.050
并行执行，基本上

00:13:23.560 --> 00:13:29.019
你正在做的只是著名的鸿沟

00:13:26.050 --> 00:13:31.000
征服你只是跳过你而已

00:13:29.019 --> 00:13:33.069
分割阵列，直到将

00:13:31.000 --> 00:13:34.810
足够小，您将得出结论

00:13:33.069 --> 00:13:37.329
其实不值得了

00:13:34.810 --> 00:13:41.800
被执行以使其进一步瘫痪

00:13:37.329 --> 00:13:43.509
我依次执行，然后是

00:13:41.800 --> 00:13:46.180
步骤跳到哪里，然后

00:13:43.509 --> 00:13:48.550
当然你做了分步

00:13:46.180 --> 00:13:54.069
现在我们只需征服你

00:13:48.550 --> 00:13:57.220
加入这些任务以继续

00:13:54.069 --> 00:13:59.620
这个例子是我认为不是

00:13:57.220 --> 00:14:01.389
甚至至关重要的Toto都遵循所有

00:13:59.620 --> 00:14:02.649
编码，这再次是关于如何

00:14:01.389 --> 00:14:05.889
它如何运作

00:14:02.649 --> 00:14:07.509
正如我所说的，我们有一个Fortran框架

00:14:05.889 --> 00:14:09.819
这是一个关键的实现图

00:14:07.509 --> 00:14:12.579
执行者服务，所以我们必须发送它

00:14:09.819 --> 00:14:15.490
我们必须发送任务给我

00:14:12.579 --> 00:14:20.680
它，当然首先，我们必须

00:14:15.490 --> 00:14:22.899
完成任务，基本上就是你

00:14:20.680 --> 00:14:25.540
总是应该可以实施

00:14:22.899 --> 00:14:27.459
它必须在那里发生事件询问必须

00:14:25.540 --> 00:14:29.889
是递归任务的实例，或者

00:14:27.459 --> 00:14:33.370
每个递归操作的区别是

00:14:29.889 --> 00:14:36.310
如果是递归任务，则返回结果

00:14:33.370 --> 00:14:37.930
如果不是递归的话

00:14:36.310 --> 00:14:39.519
递归操作不会返回

00:14:37.930 --> 00:14:41.319
结果，就像消费者一样

00:14:39.519 --> 00:14:43.720
做某事但没有做

00:14:41.319 --> 00:14:45.430
我在Oracle网站上看到的任何内容

00:14:43.720 --> 00:14:47.230
当您想发表有关

00:14:45.430 --> 00:14:49.769
并行流他们有一个非常好的

00:14:47.230 --> 00:14:53.290
例如，他们基本上有一个

00:14:49.769 --> 00:14:55.329
像图片一样的一些数字的数组

00:14:53.290 --> 00:14:57.220
他们模糊了图片，这会

00:14:55.329 --> 00:14:58.810
像递归动作，因为你

00:14:57.220 --> 00:15:02.860
只是我们不退还任何东西而已

00:14:58.810 --> 00:15:05.380
过程，他们排列还可以，但是在我们的

00:15:02.860 --> 00:15:07.870
与数字的情况下，我们会

00:15:05.380 --> 00:15:10.149
喜欢总结一下，所以只有一个

00:15:07.870 --> 00:15:12.550
我们需要实现的方法

00:15:10.149 --> 00:15:15.430
是我们覆盖的工具

00:15:12.550 --> 00:15:19.209
需要覆盖的是计算方法

00:15:15.430 --> 00:15:20.950
这是一种简单的方法

00:15:19.209 --> 00:15:24.790
首先我们看什么是

00:15:20.950 --> 00:15:26.700
完成我们的任务，然后我们就拥有了

00:15:24.790 --> 00:15:30.130
如果足够小则选择

00:15:26.700 --> 00:15:33.820
好吧，我不会再将其分开

00:15:30.130 --> 00:15:35.920
但是如果它还足够大的话

00:15:33.820 --> 00:15:38.470
值得-沃尔托布使我瘫痪

00:15:35.920 --> 00:15:41.139
这样做，所以基本上我们刚刚创建了

00:15:38.470 --> 00:15:42.279
我们通过相同的两个任务

00:15:41.139 --> 00:15:46.389
数字

00:15:42.279 --> 00:15:49.149
但是，左边和左边的任务将

00:15:46.389 --> 00:15:52.440
拥有阵列的左半部分

00:15:49.149 --> 00:15:56.380
正确的任务，数组的右半部分

00:15:52.440 --> 00:15:58.570
然后我们简单地执行它

00:15:56.380 --> 00:16:01.089
我们的左手任务，我们称之为正式任务

00:15:58.570 --> 00:16:04.779
方法的意思叫这个叫这个

00:16:01.089 --> 00:16:06.550
与我们同步执行正确的任务

00:16:04.779 --> 00:16:08.860
可以再次调用第四个方法

00:16:06.550 --> 00:16:11.529
但实际上就像我们已经在

00:16:08.860 --> 00:16:14.290
印度担心，我们知道我们不需要做

00:16:11.529 --> 00:16:17.019
暂时没有了，我们

00:16:14.290 --> 00:16:19.540
也可以同步计算

00:16:17.019 --> 00:16:24.010
然后我们等待，当他们两个

00:16:19.540 --> 00:16:25.449
我们完成并合并结果了吗

00:16:24.010 --> 00:16:27.790
同样，它对

00:16:25.449 --> 00:16:30.760
了解了解这只是

00:16:27.790 --> 00:16:34.510
这个想法，所以我们有我们我们有我们的

00:16:30.760 --> 00:16:36.459
任务，所以现在我们需要提交它

00:16:34.510 --> 00:16:38.709
某个地方，这是他们的证人

00:16:36.459 --> 00:16:42.579
这是分叉/联接，这是

00:16:38.709 --> 00:16:45.130
叉子/联接池，好吧，该怎么办

00:16:42.579 --> 00:16:49.449
我们在这里做，所以我们实例化我们的

00:16:45.130 --> 00:16:51.100
我们创建的实例的一些方法

00:16:49.449 --> 00:16:53.829
叉子/联接池，这是一种

00:16:51.100 --> 00:16:55.510
对于并行流已经至关重要

00:16:53.829 --> 00:16:58.120
所以你有两个选择

00:16:55.510 --> 00:17:00.310
在您的身上制造锻造拉力

00:16:58.120 --> 00:17:02.110
拥有你的斯坦，她吃了一个

00:17:00.310 --> 00:17:04.110
您提供多少个构造函数

00:17:02.110 --> 00:17:06.939
担心会有多少人

00:17:04.110 --> 00:17:10.569
为你做这份工作应该是

00:17:06.939 --> 00:17:12.189
在那里，或者您可以使用普通饱餐

00:17:10.569 --> 00:17:15.429
实例非常像

00:17:12.189 --> 00:17:17.169
像是一个单音，那又是什么

00:17:15.429 --> 00:17:21.910
并行流的特性

00:17:17.169 --> 00:17:23.949
是他们总是使用相同的共同点

00:17:21.910 --> 00:17:27.819
极点实例，所以他们实际上他们总是

00:17:23.949 --> 00:17:29.830
一直都无所谓

00:17:27.819 --> 00:17:30.970
您运行的并行流如何

00:17:29.830 --> 00:17:32.799
许多人

00:17:30.970 --> 00:17:37.659
他们总是在后台运行

00:17:32.799 --> 00:17:39.460
使用与您可能相同的线程池

00:17:37.659 --> 00:17:41.409
可能会问自己好吗

00:17:39.460 --> 00:17:43.270
默认会加入什么

00:17:41.409 --> 00:17:46.650
框架，因为基本上我们都做了

00:17:43.270 --> 00:17:49.750
我们自己的工作是一种

00:17:46.650 --> 00:17:51.159
低水平的东西，但是很少

00:17:49.750 --> 00:17:54.700
至关重要的特征

00:17:51.159 --> 00:17:56.140
对于并行流也至关重要

00:17:54.700 --> 00:17:58.090
首先是您看到的，然后才有了这个

00:17:56.140 --> 00:18:02.669
分叉并加入一种我们可以

00:17:58.090 --> 00:18:05.289
很好地分叉并加入

00:18:02.669 --> 00:18:07.179
这一切都提供了这个，实际上

00:18:05.289 --> 00:18:09.370
像毛坯一样的主要特点

00:18:07.179 --> 00:18:12.309
和fork join pool应用他们的

00:18:09.370 --> 00:18:13.690
仍然在卡尔加里工作，所以基本上

00:18:12.309 --> 00:18:16.690
你的叉子巨池，你就像

00:18:13.690 --> 00:18:17.799
一堆的烦恼我们会看到多少

00:18:16.690 --> 00:18:21.700
一会儿

00:18:17.799 --> 00:18:24.039
那些家伙好，他们每个人都吃

00:18:21.700 --> 00:18:28.270
每个弗雷德的家伙都有一个任务队列

00:18:24.039 --> 00:18:32.230
必须执行，如果某个弗雷德

00:18:28.270 --> 00:18:34.059
运行运行可以很好地完成任务

00:18:32.230 --> 00:18:36.039
贪婪，所以它只是在寻找其他

00:18:34.059 --> 00:18:38.620
在其他线程里找借口

00:18:36.039 --> 00:18:40.360
要做的事情，如果你

00:18:38.620 --> 00:18:42.250
在想像以前

00:18:40.360 --> 00:18:44.559
例如，如果我的左手或

00:18:42.250 --> 00:18:46.330
正确的任务将在一天之前完成

00:18:44.559 --> 00:18:48.190
在另一口井之前不是很大

00:18:46.330 --> 00:18:50.590
处理，因为如果将完成的方式

00:18:48.190 --> 00:18:52.539
以前会很无聊，不是

00:18:50.590 --> 00:19:01.419
将会是仍然的任务

00:18:52.539 --> 00:19:04.030
从其他弗雷德好吧再次所有

00:19:01.419 --> 00:19:09.250
并行流通常是一个

00:19:04.030 --> 00:19:12.309
您可能会使用的相同的普通提取实例

00:19:09.250 --> 00:19:15.130
想知道我们有多少个品格

00:19:12.309 --> 00:19:19.200
那里的数字

00:19:15.130 --> 00:19:22.809
这是您的CPU数减去一

00:19:19.200 --> 00:19:24.730
好吧，为什么实际上-1为什么是什么

00:19:22.809 --> 00:19:28.360
最后两个发生在另外两个

00:19:24.730 --> 00:19:29.980
最后一个CA上的最后一个电话

00:19:28.360 --> 00:19:33.250
事实是，这就是

00:19:29.980 --> 00:19:37.230
库的设计还

00:19:33.250 --> 00:19:39.909
调用的品格

00:19:37.230 --> 00:19:42.159
提交任务到例如

00:19:39.909 --> 00:19:44.029
也成为工人，以便最终

00:19:42.159 --> 00:19:46.609
这是一减一

00:19:44.029 --> 00:19:49.219
从技术上讲，您拥有

00:19:46.609 --> 00:19:52.460
号码，你的公共游泳池会工作

00:19:49.219 --> 00:19:57.259
与您拥有的CPU一样多的线程

00:19:52.460 --> 00:20:01.779
如果您想更换新电脑

00:19:57.259 --> 00:20:05.149
那些很好，您可以使用此属性

00:20:01.779 --> 00:20:07.729
进行设置，但是如果您考虑过

00:20:05.149 --> 00:20:10.820
他们应该并行流

00:20:07.729 --> 00:20:13.429
被很好地执行，他们应该真正采取

00:20:10.820 --> 00:20:15.259
照顾我不是CPU饥饿的任务

00:20:13.429 --> 00:20:17.629
真的确定这是否有意义

00:20:15.259 --> 00:20:20.029
因为如果您创建的内容超过

00:20:17.629 --> 00:20:24.619
你有很好的CPU，就像

00:20:20.029 --> 00:20:26.649
一定的成本也打了一些开销

00:20:24.619 --> 00:20:29.299
作为公共游泳池，这是一种

00:20:26.649 --> 00:20:30.739
当然，当您这样做时， 

00:20:29.299 --> 00:20:33.049
在您实际操作之前必须始终这样做

00:20:30.739 --> 00:20:34.940
调用您的第一个并行流，这样您

00:20:33.049 --> 00:20:37.129
找不到颗粒好吧，让我们

00:20:34.940 --> 00:20:38.719
用两个执行此并行流

00:20:37.129 --> 00:20:40.399
核心将此参数更改为八个

00:20:38.719 --> 00:20:41.869
让我们以八个核心执行它

00:20:40.399 --> 00:20:44.210
不，这是行不通的

00:20:41.869 --> 00:20:47.269
一旦您调用了第一个并行

00:20:44.210 --> 00:20:48.649
流这不会被认为是任何

00:20:47.269 --> 00:20:54.440
更可能是您应该通过它

00:20:48.649 --> 00:20:56.749
在评论行上，好，我已经

00:20:54.440 --> 00:20:58.969
我一直重复五次

00:20:56.749 --> 00:21:00.710
他们并行流的一百倍

00:20:58.969 --> 00:21:02.809
始终使用的相同实例

00:21:00.710 --> 00:21:06.080
问题是可以的fork / join pool 

00:21:02.809 --> 00:21:08.269
您可以使用您可以使用的您自己的可以

00:21:06.080 --> 00:21:09.950
你说好，这个并行流应该

00:21:08.269 --> 00:21:14.029
包括这应该真的执行

00:21:09.950 --> 00:21:17.359
与此有关，例如

00:21:14.029 --> 00:21:19.219
答案是可以的，但是我只是显示一下

00:21:17.359 --> 00:21:21.969
为了完整起见，因为

00:21:19.219 --> 00:21:25.639
我不会，我不会真的

00:21:21.969 --> 00:21:28.129
这样做，如果你看起来很好

00:21:25.639 --> 00:21:29.899
在fork方法中它的确切作用

00:21:28.129 --> 00:21:31.879
这个家伙是上下文相关的一种

00:21:29.899 --> 00:21:34.759
这样就可以知道它是否正在运行

00:21:31.879 --> 00:21:36.859
在某个游泳池里跑，它只会

00:21:34.759 --> 00:21:44.239
只会坚持在那里

00:21:36.859 --> 00:21:48.739
基本上，诀窍是创建您的

00:21:44.239 --> 00:21:53.059
叉接头池的线程数与

00:21:48.739 --> 00:21:55.440
您想要然后提交

00:21:53.059 --> 00:21:59.970
您的并行流执行以及

00:21:55.440 --> 00:22:01.890
为了完整起见，肖恩又一次

00:21:59.970 --> 00:22:03.750
这与我的意愿无关

00:22:01.890 --> 00:22:06.410
你可能真的会拥有

00:22:03.750 --> 00:22:09.330
好，如果您寻找这样做的理由

00:22:06.410 --> 00:22:10.980
好吧，我反对，但我想成为

00:22:09.330 --> 00:22:14.040
尽可能客观地

00:22:10.980 --> 00:22:15.570
律师之类的话，如果您认为

00:22:14.040 --> 00:22:20.040
你为什么要这样做

00:22:15.570 --> 00:22:21.900
首先，你当然身体不好

00:22:20.040 --> 00:22:23.640
你有一个你有一个单独的游泳池

00:22:21.900 --> 00:22:24.960
你不会在普通的游泳池

00:22:23.640 --> 00:22:27.770
它不会受到它的影响

00:22:24.960 --> 00:22:30.270
也许如果您有个案例是

00:22:27.770 --> 00:22:32.340
因为这种威胁共享，你知道

00:22:30.270 --> 00:22:33.600
所谓的威胁也是

00:22:32.340 --> 00:22:35.640
想要你参与

00:22:33.600 --> 00:22:38.190
不同生命周期的威胁

00:22:35.640 --> 00:22:41.070
可能会想到一些问题

00:22:38.190 --> 00:22:44.130
与交易等

00:22:41.070 --> 00:22:45.930
第二个原因是，如果您

00:22:44.130 --> 00:22:48.930
调用并行流和以下之一

00:22:45.930 --> 00:22:52.940
线程被卡住了

00:22:48.930 --> 00:22:55.530
征税它永远卡住，所以

00:22:52.940 --> 00:22:59.130
这是你可以看的东西

00:22:55.530 --> 00:23:01.410
影响在这种情况下，因为你好

00:22:59.130 --> 00:23:03.540
可以真正定义一个平行的超时

00:23:01.410 --> 00:23:07.680
流请帮我做，但实际上

00:23:03.540 --> 00:23:09.840
最多只等待十秒钟，所以再次

00:23:07.680 --> 00:23:17.850
就像原因可能是

00:23:09.840 --> 00:23:20.100
真正去做的理由好吧，如果

00:23:17.850 --> 00:23:23.280
我们试图从中得出一些结论

00:23:20.100 --> 00:23:24.480
再次从fork fork / join框架

00:23:23.280 --> 00:23:27.390
无非就是一个像

00:23:24.480 --> 00:23:31.590
递归分治法

00:23:27.390 --> 00:23:33.600
所以我们有一个短暂的拉力

00:23:31.590 --> 00:23:36.000
很多线程或基本上一样多

00:23:33.600 --> 00:23:40.410
 CPU得分为

00:23:36.000 --> 00:23:42.390
虚拟过程是避免IO，因为

00:23:40.410 --> 00:23:44.790
每次您等待时当然

00:23:42.390 --> 00:23:48.350
有点像磁盘或网络

00:23:44.790 --> 00:23:52.980
资源将消耗所有这些CPU 

00:23:48.350 --> 00:23:56.070
周期再次用于密集型CPU 

00:23:52.980 --> 00:23:58.560
繁重的任务，所以当您在

00:23:56.070 --> 00:24:00.500
坚持下去，然后所有公共池

00:23:58.560 --> 00:24:04.500
默认值是非常完美的

00:24:00.500 --> 00:24:07.230
完美，如果你有头脑的话

00:24:04.500 --> 00:24:08.550
之所以喜欢并行流，是因为

00:24:07.230 --> 00:24:10.680
如果您喜欢并行流

00:24:08.550 --> 00:24:12.420
也许每个人都有一个

00:24:10.680 --> 00:24:14.310
对于每一个你有另一个力量

00:24:12.420 --> 00:24:15.930
其他流，因为这样你可以看

00:24:14.310 --> 00:24:18.210
然后你可能会有一些

00:24:15.930 --> 00:24:21.870
我们可以很明显地聊天

00:24:18.210 --> 00:24:23.940
后来我在那里做了一些测试

00:24:21.870 --> 00:24:26.310
并不是没有足够的时间来展示它

00:24:23.940 --> 00:24:28.380
但是，是的，你可以，你可以

00:24:26.310 --> 00:24:32.250
真正发现自己，我认为

00:24:28.380 --> 00:24:34.770
将会很慢，因为

00:24:32.250 --> 00:24:37.980
工人拉，所以他们是关键

00:24:34.770 --> 00:24:42.540
 for连接框架实际上存在

00:24:37.980 --> 00:24:44.670
总是喜欢有更多的任务

00:24:42.540 --> 00:24:47.820
然后有必要，因为如果您认为

00:24:44.670 --> 00:24:51.180
如果您有128门课程，但是您喜欢

00:24:47.820 --> 00:24:55.190
兆丰80兆丰的任务，你只能

00:24:51.180 --> 00:24:58.530
使用就像我不知道你的CPU 60 70 

00:24:55.190 --> 00:25:01.680
我是说你拥有的力量

00:24:58.530 --> 00:25:05.550
再一次坚持普通

00:25:01.680 --> 00:25:10.490
苹果，因为它只是使

00:25:05.550 --> 00:25:13.170
感觉还可以，所以这是fork / join 

00:25:10.490 --> 00:25:14.970
框架，现在在示例中

00:25:13.170 --> 00:25:18.120
当我们加上您看到的数字时

00:25:14.970 --> 00:25:20.820
我们友善，平分秋色

00:25:18.120 --> 00:25:23.490
我们左边的数字数组和

00:25:20.820 --> 00:25:27.150
正确的部分

00:25:23.490 --> 00:25:29.370
但是如您所知，流可以有很多

00:25:27.150 --> 00:25:32.040
实际上，许多来源也可以

00:25:29.370 --> 00:25:38.460
创建自己的流，所以一些

00:25:32.040 --> 00:25:40.740
有时我们需要一种方法来影响

00:25:38.460 --> 00:25:42.930
这东西怎么样这东西怎么样

00:25:40.740 --> 00:25:45.780
实际的烦人和分裂，所以当我们

00:25:42.930 --> 00:25:48.180
在这个叉子部分，我们需要

00:25:45.780 --> 00:25:50.670
以某种方式指示或必须以某种方式

00:25:48.180 --> 00:25:54.870
足够聪明地指示自己如何

00:25:50.670 --> 00:25:57.720
东西应该分开，这是

00:25:54.870 --> 00:25:59.940
新东西中引入的一些东西

00:25:57.720 --> 00:26:02.480
 Java 8中引入的接口

00:25:59.940 --> 00:26:06.360
这是一个分裂作家， 

00:26:02.480 --> 00:26:06.920
拆分表迭代器，它甚至可以站在这里

00:26:06.360 --> 00:26:10.590
好

00:26:06.920 --> 00:26:13.220
它基本上是设计用来

00:26:10.590 --> 00:26:16.530
并行浏览您的元素，以便

00:26:13.220 --> 00:26:19.980
是的，可以应用迭代器

00:26:16.530 --> 00:26:21.660
无论你有多少， 

00:26:19.980 --> 00:26:23.310
如何运作

00:26:21.660 --> 00:26:26.100
它的确有很多

00:26:23.310 --> 00:26:29.070
方法，但那些是主要的免费方法

00:26:26.100 --> 00:26:31.770
如您所知，经典的迭代器

00:26:29.070 --> 00:26:34.860
有这个过去和下一个过去了吗

00:26:31.770 --> 00:26:37.200
只是如果我有什么我仍然

00:26:34.860 --> 00:26:38.340
有东西，如果是，请给

00:26:37.200 --> 00:26:40.290
对我来说

00:26:38.340 --> 00:26:43.380
尝试先进的那种

00:26:40.290 --> 00:26:45.060
合并这两种方法

00:26:43.380 --> 00:26:48.080
返回一个布尔值，告诉您是否

00:26:45.060 --> 00:26:51.270
里面还有东西

00:26:48.080 --> 00:26:53.700
在您的拆分器作家中

00:26:51.270 --> 00:26:55.440
拿一个简单地做的消费者

00:26:53.700 --> 00:26:58.350
与您的元素有关

00:26:55.440 --> 00:27:00.510
目前正在迭代

00:26:58.350 --> 00:27:02.820
当你考虑它的时候

00:27:00.510 --> 00:27:04.590
真的很好，激励是有道理的

00:27:02.820 --> 00:27:06.330
一切如何联系在一起，因为

00:27:04.590 --> 00:27:08.430
当您使用流时，您会

00:27:06.330 --> 00:27:11.550
过去，您可以使用Lambda 

00:27:08.430 --> 00:27:13.080
通过传递行为，如果

00:27:11.550 --> 00:27:16.560
你有一个消费者，等等

00:27:13.080 --> 00:27:17.790
最初通过那里另一种方法

00:27:16.560 --> 00:27:22.170
就像分裂的心脏

00:27:17.790 --> 00:27:22.620
曝气机是Tri分裂的，所以它做两个

00:27:22.170 --> 00:27:24.540
东西

00:27:22.620 --> 00:27:25.920
它返回一个新的拆分器作家， 

00:27:24.540 --> 00:27:28.730
它正在改变

00:27:25.920 --> 00:27:31.560
目前我们也有

00:27:28.730 --> 00:27:34.890
加快速度时的特性

00:27:31.560 --> 00:27:36.690
像环境加速的一些提示

00:27:34.890 --> 00:27:39.450
来介绍一些乐观的看法

00:27:36.690 --> 00:27:41.910
优化等等，让我们来看看

00:27:39.450 --> 00:27:44.280
尝试分裂行动的原因很少

00:27:41.910 --> 00:27:46.650
再次有一些后果，你如何

00:27:44.280 --> 00:27:47.850
请问您什么时候可以考虑

00:27:46.650 --> 00:27:53.460
考虑一下你的表现

00:27:47.850 --> 00:27:56.670
并行流，所以我们有分离器

00:27:53.460 --> 00:27:59.040
作家再次击败巨大

00:27:56.670 --> 00:28:02.790
数字数组，因此当我们调用

00:27:59.040 --> 00:28:05.550
 Tri在这个家伙身上分裂了两件事

00:28:02.790 --> 00:28:07.650
所以首先它要返回一个新的分离器

00:28:05.550 --> 00:28:09.030
作家，那会很好，我不

00:28:07.650 --> 00:28:11.340
知道数字是否从一到

00:28:09.030 --> 00:28:15.750
百，它将从1终止到50 

00:28:11.340 --> 00:28:18.360
但同时它正在改变

00:28:15.750 --> 00:28:20.160
分离器作家的报道

00:28:18.360 --> 00:28:23.250
从1到50这将是从

00:28:20.160 --> 00:28:27.900
 51至100 

00:28:23.250 --> 00:28:32.260
实际上是整个技巧

00:28:27.900 --> 00:28:34.000
你再做一次，它确实做了

00:28:32.260 --> 00:28:36.640
同样的事情在我们的分离器上

00:28:34.000 --> 00:28:39.520
评分者一返回新的拆分器

00:28:36.640 --> 00:28:41.590
作家将是1到25，这是

00:28:39.520 --> 00:28:44.860
改变这些家伙的报道

00:28:41.590 --> 00:28:46.990
从26到50是多少，所以这是

00:28:44.860 --> 00:28:49.690
整个和整个技巧

00:28:46.990 --> 00:28:53.950
实际上并行流被分叉了

00:28:49.690 --> 00:28:56.260
我们一遍又一遍地做这件事，直到

00:28:53.950 --> 00:28:58.120
直到三速返回通道

00:28:56.260 --> 00:28:59.890
然后我们知道好了

00:28:58.120 --> 00:29:03.370
现在分叉的步骤，我们可以再

00:28:59.890 --> 00:29:07.120
并行流可以在

00:29:03.370 --> 00:29:09.790
先后顺序加入，所以当

00:29:07.120 --> 00:29:11.920
你看一个分流器是

00:29:09.790 --> 00:29:14.650
真的这个家伙一直在

00:29:11.920 --> 00:29:15.220
同一个对象

00:29:14.650 --> 00:29:18.070
次

00:29:15.220 --> 00:29:24.750
三重分割调用它，所以它的覆盖范围

00:29:18.070 --> 00:29:28.090
在缩小问题是

00:29:24.750 --> 00:29:31.240
使用自己的分离器评分器进行流

00:29:28.090 --> 00:29:33.429
您可以这样就可以得到流支持

00:29:31.240 --> 00:29:39.670
类就像一个低级的类

00:29:33.429 --> 00:29:41.260
您可以构建为流，是的，所以

00:29:39.670 --> 00:29:43.030
基本上你有这个流方法

00:29:41.260 --> 00:29:46.120
您通过了拆分器作者

00:29:43.030 --> 00:29:47.920
我不确定你是否真的去过

00:29:46.120 --> 00:29:49.120
您需要再次做一次

00:29:47.920 --> 00:29:51.190
很高兴了解这件事是怎么回事

00:29:49.120 --> 00:29:52.990
在幕后工作，如果你有

00:29:51.190 --> 00:29:55.660
像枚举，我不确定你是否

00:29:52.990 --> 00:29:57.070
可以创建一个枚举

00:29:55.660 --> 00:30:00.370
通过枚举创建流

00:29:57.070 --> 00:30:02.230
我们可能会是其中一种情况

00:30:00.370 --> 00:30:04.900
如果您正在编写新收藏

00:30:02.230 --> 00:30:08.170
而且您不太喜欢默认值

00:30:04.900 --> 00:30:10.630
三速的实施将是

00:30:08.170 --> 00:30:13.750
一个也喜欢这种情况或简单地

00:30:10.630 --> 00:30:16.120
流中的元素

00:30:13.750 --> 00:30:18.940
某些默认的语义

00:30:16.120 --> 00:30:23.080
默认的拆分过程不会

00:30:18.940 --> 00:30:25.450
对你而言，那么你就可以影响

00:30:23.080 --> 00:30:30.330
过程，但再次可能你不是

00:30:25.450 --> 00:30:30.330
真的需要它

00:30:30.630 --> 00:30:36.640
好的，所以当我们再次坚持到

00:30:33.790 --> 00:30:38.860
显示拆分器的作者

00:30:36.640 --> 00:30:39.970
基本上想象我们有一个

00:30:38.860 --> 00:30:43.000
链表

00:30:39.970 --> 00:30:45.490
我们称其为分离器评分器

00:30:43.000 --> 00:30:49.120
好吧，它返回一个链接列表拆分器

00:30:45.490 --> 00:30:52.509
我当然是作家

00:30:49.120 --> 00:30:55.809
列表中的元素，现在

00:30:52.509 --> 00:30:57.789
我们首先对我们的分离器作家进行

00:30:55.809 --> 00:31:02.529
许多真的是最重要的一个

00:30:57.789 --> 00:31:05.740
如果我们尝试，它有10 K 10 K个元素

00:31:02.529 --> 00:31:10.539
再次拆分，它做两件事

00:31:05.740 --> 00:31:12.909
它是否返回一个新的，所以这是

00:31:10.539 --> 00:31:15.519
一个被退回，所以它的大小

00:31:12.909 --> 00:31:17.590
就像1k，所以您可以在

00:31:15.519 --> 00:31:21.429
图片，它正在改变覆盖范围

00:31:17.590 --> 00:31:25.990
本身就这么基本

00:31:21.429 --> 00:31:28.210
这就是发生了什么，如果我们

00:31:25.990 --> 00:31:30.820
为做完全相同的事情

00:31:28.210 --> 00:31:33.429
对于数组列表，我们有一个

00:31:30.820 --> 00:31:35.799
现实的分裂作家，我们看到的

00:31:33.429 --> 00:31:37.360
他叫什么尺寸

00:31:35.799 --> 00:31:39.519
三分，然后我们看什么是

00:31:37.360 --> 00:31:43.299
新的和所有的大小

00:31:39.519 --> 00:31:47.110
想知道覆盖范围得到了

00:31:43.299 --> 00:31:49.750
改变了，如果你看一下数组

00:31:47.110 --> 00:31:53.019
列出它均匀均匀地划分

00:31:49.750 --> 00:31:54.850
但是如果你看着

00:31:53.019 --> 00:32:00.399
在链表上，就像这样

00:31:54.850 --> 00:32:04.360
所创建的迷你迷你列表的种类

00:32:00.399 --> 00:32:06.730
为什么会这样，因为

00:32:04.360 --> 00:32:09.549
每当我们开始每当我们开始

00:32:06.730 --> 00:32:11.919
我们要并行执行的问题

00:32:09.549 --> 00:32:14.230
我们总是从一个核心开始

00:32:11.919 --> 00:32:18.850
问题是它永远不会是多色的

00:32:14.230 --> 00:32:21.820
从一开始就如此

00:32:18.850 --> 00:32:24.070
实际上我们称之为三分

00:32:21.820 --> 00:32:25.840
而且您知道为了拆分链接

00:32:24.070 --> 00:32:28.299
列出你确实必须去的

00:32:25.840 --> 00:32:31.659
通过元素，所以当我们实际上

00:32:28.299 --> 00:32:34.000
即使我们有500门课程， 

00:32:31.659 --> 00:32:35.799
像499课程将滑倒

00:32:34.000 --> 00:32:37.690
因为这只是一个核心

00:32:35.799 --> 00:32:41.080
它正在调用该右拆分，因此

00:32:37.690 --> 00:32:43.000
人在甲骨文看到他们

00:32:41.080 --> 00:32:45.070
提供了一些聪明

00:32:43.000 --> 00:32:47.649
实现取决于

00:32:45.070 --> 00:32:49.899
如果我有一个数据结构就好了

00:32:47.649 --> 00:32:51.930
链接列表，我想实际

00:32:49.899 --> 00:32:54.690
尽快叉

00:32:51.930 --> 00:32:57.170
尽快咳嗽，这是

00:32:54.690 --> 00:33:02.010
其实不是这样的原因

00:32:57.170 --> 00:33:05.090
以及没有平均分配和这个

00:33:02.010 --> 00:33:12.390
当然，对于一个

00:33:05.090 --> 00:33:15.090
并行流某些来源更多

00:33:12.390 --> 00:33:18.150
比其他人更友好

00:33:15.090 --> 00:33:19.590
当您创建时，您拥有此

00:33:18.150 --> 00:33:22.710
当您离开时创建树

00:33:19.590 --> 00:33:26.070
枫叶的根源很重要

00:33:22.710 --> 00:33:27.179
你在做什么，如果

00:33:26.070 --> 00:33:31.260
我们有一个链表

00:33:27.179 --> 00:33:33.330
你已经再次看到它是一个结你

00:33:31.260 --> 00:33:35.640
需要迭代地穿过那个家伙

00:33:33.330 --> 00:33:38.520
因此，当您使用

00:33:35.640 --> 00:33:39.780
生成器函数很好，这是一个迭代

00:33:38.520 --> 00:33:43.530
具有相同的发电机

00:33:39.780 --> 00:33:46.860
特征产生

00:33:43.530 --> 00:33:48.929
元素作为我设置的链接列表

00:33:46.860 --> 00:33:51.570
净重置，但类似

00:33:48.929 --> 00:33:53.990
中间可能不是哦

00:33:51.570 --> 00:33:57.780
哦，就像一切

00:33:53.990 --> 00:34:00.780
对数，当然我也发布了

00:33:57.780 --> 00:34:03.000
所有阶段的发电机都很好

00:34:00.780 --> 00:34:05.100
就像上一课一样

00:34:03.000 --> 00:34:08.490
每当您创建时

00:34:05.100 --> 00:34:15.629
一个流并行的流思考

00:34:08.490 --> 00:34:18.450
流流源几个例子

00:34:15.629 --> 00:34:21.000
所以基本上我们在这里拥有什么

00:34:18.450 --> 00:34:23.460
我们有10亿个元素好吧，让我们

00:34:21.000 --> 00:34:26.040
让我们大胆一点，为什么不全部

00:34:23.460 --> 00:34:28.919
喜欢做的是计算他们的计算机

00:34:26.040 --> 00:34:30.780
他们的总和，所以首先我们不是

00:34:28.919 --> 00:34:34.560
并行执行是一个很好的顺序

00:34:30.780 --> 00:34:38.490
像我们一样的处决

00:34:34.560 --> 00:34:40.669
第二，如果我们只是我们在这里所做的一切， 

00:34:38.490 --> 00:34:43.919
只是尝试并行并行

00:34:40.669 --> 00:34:45.960
这个家伙的默认

00:34:43.919 --> 00:34:49.919
启动JVM时的默认堆大小

00:34:45.960 --> 00:34:51.389
它爆炸时，实际上爆炸时

00:34:49.919 --> 00:34:54.690
你当你尝试当你尝试

00:34:51.389 --> 00:34:57.930
在on上调用try speed方法

00:34:54.690 --> 00:34:59.550
最高来源甚至更多

00:34:57.930 --> 00:35:01.590
一般来说，如果您创建一个

00:34:59.550 --> 00:35:03.270
有十亿个元素的链表

00:35:01.590 --> 00:35:05.340
尝试尝试，请尝试拆分- 

00:35:03.270 --> 00:35:06.630
它爆炸了，是的，因为

00:35:05.340 --> 00:35:09.930
再次考虑开销时

00:35:06.630 --> 00:35:15.110
如果我们去一个很重的地方

00:35:09.930 --> 00:35:20.340
无状态发电机功能是

00:35:15.110 --> 00:35:22.980
友好，您可以按顺序进行

00:35:20.340 --> 00:35:24.810
大概需要600毫秒

00:35:22.980 --> 00:35:27.240
您可能实际上想知道好吗

00:35:24.810 --> 00:35:29.370
他们应该有的两个家伙

00:35:27.240 --> 00:35:32.190
一种类似的表现，因为

00:35:29.370 --> 00:35:34.320
他们关闭，这是一个顺序运行，以便

00:35:32.190 --> 00:35:37.140
我按顺序进行是指

00:35:34.320 --> 00:35:41.400
范围不应该给我任何好处

00:35:37.140 --> 00:35:44.220
它这样做是因为它有迭代方法

00:35:41.400 --> 00:35:45.780
返回装箱的对象，所以你像1 

00:35:44.220 --> 00:35:46.830
需要装箱的十亿个对象和

00:35:45.780 --> 00:35:51.210
狩猎盒

00:35:46.830 --> 00:35:52.590
所以是的，这真的可以

00:35:51.210 --> 00:35:56.700
改善预览效果

00:35:52.590 --> 00:35:58.560
如果不这样做，性能提高两倍

00:35:56.700 --> 00:36:00.660
即使这样做可能也不要这样做

00:35:58.560 --> 00:36:01.890
有点令人困惑，好吧，我有一个

00:36:00.660 --> 00:36:03.600
漫长的溪流让我松了一口气

00:36:01.890 --> 00:36:06.690
专业流这是我读的

00:36:03.600 --> 00:36:08.430
在堆栈溢出上做，但仍然

00:36:06.690 --> 00:36:10.980
迭代器功能或重新生成框

00:36:08.430 --> 00:36:13.530
对象和一些期望

00:36:10.980 --> 00:36:17.490
未装箱的物品，您喜欢装箱

00:36:13.530 --> 00:36:19.350
拆箱非常不必要

00:36:17.490 --> 00:36:21.660
这正是这个扳手

00:36:19.350 --> 00:36:23.520
情况已经改变，如果我们现在

00:36:21.660 --> 00:36:26.790
如果我们在调用并行方法，则调用

00:36:23.520 --> 00:36:36.480
还是我们有不同的感觉

00:36:26.790 --> 00:36:43.410
执行速度快五倍好吗

00:36:36.480 --> 00:36:45.330
所以找到任何无序的也许

00:36:43.410 --> 00:36:47.430
这个例子可能解释了最好的

00:36:45.330 --> 00:36:50.490
所以想像我们有这种非常

00:36:47.430 --> 00:36:54.090
六个元素的简化流

00:36:50.490 --> 00:36:57.270
我们在这里所做的一切只是在打印之前

00:36:54.090 --> 00:36:59.610
它的元素仅此而已。和的

00:36:57.270 --> 00:37:02.310
就像我们并行执行一样

00:36:59.610 --> 00:37:05.130
这就是它做的那样

00:37:02.310 --> 00:37:07.260
只要执行它就可以

00:37:05.130 --> 00:37:10.140
如果产生其他明显的东西

00:37:07.260 --> 00:37:12.090
如果我们取消并联电源

00:37:10.140 --> 00:37:16.020
离开这里就像1 2 3 

00:37:12.090 --> 00:37:18.030
 4 5 6但是，如果它是并行的

00:37:16.020 --> 00:37:18.650
流得很好，您无法真正预测

00:37:18.030 --> 00:37:22.610
的

00:37:18.650 --> 00:37:26.390
订购，如果您愿意的话

00:37:22.610 --> 00:37:29.720
找到一个首先定义一个方法的调用

00:37:26.390 --> 00:37:31.580
这个梦想很好，它将是API 

00:37:29.720 --> 00:37:33.770
聪明，如果我们调用，它将永远

00:37:31.580 --> 00:37:35.390
首先查找，它将始终返回一个

00:37:33.770 --> 00:37:37.700
所以它真的会服从你想要的

00:37:35.390 --> 00:37:40.400
到您想要的东西，但这是开销

00:37:37.700 --> 00:37:43.040
因为当你考虑好了

00:37:40.400 --> 00:37:45.110
这种平行的自然顺序

00:37:43.040 --> 00:37:48.260
流是随机的，所以如果我

00:37:45.110 --> 00:37:51.070
告诉这个家伙给我第一个他

00:37:48.260 --> 00:37:54.110
他必须做他必须做些努力

00:37:51.070 --> 00:37:57.290
好吧，实际上你的第一个

00:37:54.110 --> 00:37:58.970
元素，所以只喜欢只喜欢

00:37:57.290 --> 00:38:00.590
如果您真的不担心，请使用

00:37:58.970 --> 00:38:03.800
真的不在乎哪一个

00:38:00.590 --> 00:38:07.160
轮到我们找到任何东西了，因为找到了

00:38:03.800 --> 00:38:08.810
首先就像永远是一个

00:38:07.160 --> 00:38:10.700
但是如果您调用一个细小的

00:38:08.810 --> 00:38:12.470
如果你不喜欢的话，AK四四六二

00:38:10.700 --> 00:38:17.570
真的很在乎它会

00:38:12.470 --> 00:38:19.700
在相同的极限下更快

00:38:17.570 --> 00:38:25.790
方法，因此，如果您调用无限制

00:38:19.700 --> 00:38:27.440
在这一流上，它会像一个

00:38:25.790 --> 00:38:29.090
二三左右不会是一二

00:38:27.440 --> 00:38:31.760
将是一二三不设置

00:38:29.090 --> 00:38:35.660
真的完全按照这个顺序

00:38:31.760 --> 00:38:37.940
它将始终是1 2 3 2 3 1 3 2 1和

00:38:35.660 --> 00:38:40.160
因此，这又是开销

00:38:37.940 --> 00:38:42.320
因为流的自然顺序

00:38:40.160 --> 00:38:47.210
前三个元素，例如四个六个

00:38:42.320 --> 00:38:49.430
一四四六四有五等

00:38:47.210 --> 00:38:51.590
每当您达到极限并有一个

00:38:49.430 --> 00:38:55.100
像这样的并行流考虑一下

00:38:51.590 --> 00:38:58.160
也许我真的不需要第一个

00:38:55.100 --> 00:39:00.440
和元素，所以只要给它一个

00:38:58.160 --> 00:39:02.390
暗示这实际上是无序的

00:39:00.440 --> 00:39:10.870
不在乎订单，所以给

00:39:02.390 --> 00:39:15.410
我只要给我任何要素就好

00:39:10.870 --> 00:39:18.110
是的，作为扎实的证明，所以我们有

00:39:15.410 --> 00:39:19.790
我们有一堆数字，我们只是

00:39:18.110 --> 00:39:24.320
过滤那些比

00:39:19.790 --> 00:39:28.190
 500好，如果我先调用查找

00:39:24.320 --> 00:39:30.110
这个家伙很聪明，它服从它

00:39:28.190 --> 00:39:31.440
刚好返回第一个

00:39:30.110 --> 00:39:34.760
那个

00:39:31.440 --> 00:39:38.100
符合这个条件

00:39:34.760 --> 00:39:41.730
如果我真的不在乎

00:39:38.100 --> 00:39:45.510
如果我对此感兴趣的话

00:39:41.730 --> 00:39:47.550
我在这里做什么对我们四个人来说

00:39:45.510 --> 00:39:49.560
倍快，但它当然会返回

00:39:47.550 --> 00:39:50.850
基本上每次的元素

00:39:49.560 --> 00:39:53.210
您调用它会有所不同

00:39:50.850 --> 00:39:57.360
一个，但要取决于您保留多长时间

00:39:53.210 --> 00:40:02.690
再次调用所有者无序

00:39:57.360 --> 00:40:02.690
并找到任何人也可以成为您的朋友

00:40:03.110 --> 00:40:12.150
好吧，是的，避免短路状态

00:40:10.050 --> 00:40:14.430
想一想你这样的例子

00:40:12.150 --> 00:40:17.430
想象我们有一个累加器类

00:40:14.430 --> 00:40:19.500
好吧，这是它的全部

00:40:17.430 --> 00:40:22.290
蓄电池，所以基本上它有这个

00:40:19.500 --> 00:40:25.140
您将保留的一些方法

00:40:22.290 --> 00:40:27.620
您一直在调用，这仅仅是

00:40:25.140 --> 00:40:32.370
增加它只是增加

00:40:27.620 --> 00:40:34.650
结果，现在就去做吧

00:40:32.370 --> 00:40:39.690
如果你做这种事情，你

00:40:34.650 --> 00:40:42.330
实例化累加器，然后尝试

00:40:39.690 --> 00:40:43.830
调用并行调用此

00:40:42.330 --> 00:40:46.680
基本上是从1到

00:40:43.830 --> 00:40:48.210
 100你将拥有不同

00:40:46.680 --> 00:40:50.280
一直都是数字，因为你

00:40:48.210 --> 00:40:53.640
到处都有比赛条件

00:40:50.280 --> 00:40:56.460
这个地方再次与平行流

00:40:53.640 --> 00:41:00.960
这也是一种尝试

00:40:56.460 --> 00:41:02.370
取消学习某些特定​​模式，因为

00:41:00.960 --> 00:41:05.640
在这种情况下，当我们有一个功能

00:41:02.370 --> 00:41:08.820
保持状态不会这样

00:41:05.640 --> 00:41:11.190
与溪流一样好

00:41:08.820 --> 00:41:12.750
当然可以做的是

00:41:11.190 --> 00:41:16.020
使它成为这种方法

00:41:12.750 --> 00:41:17.850
同步但实际上一切都很好

00:41:16.020 --> 00:41:19.260
全天全力以赴

00:41:17.850 --> 00:41:21.300
平行流不会是水，因为

00:41:19.260 --> 00:41:22.620
他们知道秘密同步

00:41:21.300 --> 00:41:23.940
当你有多的时候非常昂贵

00:41:22.620 --> 00:41:26.790
他们彼此沟通的过程

00:41:23.940 --> 00:41:28.710
其他说好吧做不做不做

00:41:26.790 --> 00:41:30.600
因为我正在做某件事，这非常

00:41:28.710 --> 00:41:33.060
昂贵，所以您的所有好处

00:41:30.600 --> 00:41:34.710
并行流将丢失

00:41:33.060 --> 00:41:37.800
所以基本上输掉了

00:41:34.710 --> 00:41:41.700
函数，如果有并行则再次

00:41:37.800 --> 00:41:44.770
溪流坚持纯净的坚持

00:41:41.700 --> 00:41:46.550
功能，我敢肯定有很多

00:41:44.770 --> 00:41:48.440
关于功能的讲座

00:41:46.550 --> 00:41:54.280
编程，所以无论你学那些

00:41:48.440 --> 00:41:54.280
在那里将其应用于并行流

00:41:56.859 --> 00:42:03.290
好吧，几乎在最后是顺序

00:42:00.859 --> 00:42:08.450
顺序和并行，如前所述

00:42:03.290 --> 00:42:10.160
我们有这个我们有这样的流

00:42:08.450 --> 00:42:13.760
基本上就像一个建造者

00:42:10.160 --> 00:42:15.290
模式，所以它实际上什么也没做

00:42:13.760 --> 00:42:16.970
当你介入的最后时刻

00:42:15.290 --> 00:42:20.510
你在打电话给老板的时候

00:42:16.970 --> 00:42:24.230
终端操作请执行

00:42:20.510 --> 00:42:26.750
我和你可能会被吸引

00:42:24.230 --> 00:42:28.190
这两种方法给一个

00:42:26.750 --> 00:42:30.250
当您到达时提示好

00:42:28.190 --> 00:42:35.359
终端操作虽然

00:42:30.250 --> 00:42:37.520
顺序执行并行操作

00:42:35.359 --> 00:42:39.260
它并行执行，所以您可能会

00:42:37.520 --> 00:42:41.119
像诱惑一样好吧，也许我可以

00:42:39.260 --> 00:42:42.619
有些事情可以做这样的事情我

00:42:41.119 --> 00:42:46.220
有很多我还有另一种

00:42:42.619 --> 00:42:47.840
如果我有一个数字是如果我

00:42:46.220 --> 00:42:50.600
计算素数昂贵

00:42:47.840 --> 00:42:54.290
花费时间让我们做吧

00:42:50.600 --> 00:42:56.510
让我们并行进行

00:42:54.290 --> 00:42:58.460
我当我有我的蓄能器，所以你看到了

00:42:56.510 --> 00:43:00.050
累积者邪恶之前的一张幻灯片

00:42:58.460 --> 00:43:01.580
你真的不能做你不应该做的事

00:43:00.050 --> 00:43:03.740
做到这一点，让我们变得聪明起来吧

00:43:01.580 --> 00:43:05.840
依序不，它不会真正起作用

00:43:03.740 --> 00:43:07.670
很好，但是整个

00:43:05.840 --> 00:43:11.140
流将按顺序调用

00:43:07.670 --> 00:43:17.180
这样您将失去的好处

00:43:11.140 --> 00:43:20.140
并行性好吗

00:43:17.180 --> 00:43:20.140
我可以回去吗

00:43:25.110 --> 00:43:29.770
这是一个很好的问题

00:43:27.940 --> 00:43:32.050
嗯，这只是事实， 

00:43:29.770 --> 00:43:34.240
就是这样，但是他们是

00:43:32.050 --> 00:43:36.040
但是您可以使用的库

00:43:34.240 --> 00:43:38.590
克服它，你可以，你可以

00:43:36.040 --> 00:43:41.530
达到优雅的目的

00:43:38.590 --> 00:43:44.650
控制什么是并行什么是什么

00:43:41.530 --> 00:43:54.010
是不是我们可以高兴地谈论这件事， 

00:43:44.650 --> 00:44:05.920
其实我根本不认识你

00:43:54.010 --> 00:44:08.140
是的，如果你真的很好

00:44:05.920 --> 00:44:10.150
坚持纯JDK 8，所以不

00:44:08.140 --> 00:44:13.690
我上面的其他图书馆

00:44:10.150 --> 00:44:15.100
可能会分裂或摆脱

00:44:13.690 --> 00:44:17.650
蓄能器的像

00:44:15.100 --> 00:44:19.210
减少之类的东西，但是是的

00:44:17.650 --> 00:44:26.440
这也是我个人的东西

00:44:19.210 --> 00:44:28.440
失踪了，所以我们可以没事了，几乎在

00:44:26.440 --> 00:44:30.580
结束

00:44:28.440 --> 00:44:32.020
很抱歉，一直在检查时间

00:44:30.580 --> 00:44:33.460
我们来自瑞士很多

00:44:32.020 --> 00:44:39.190
手表的长度如此之好，你必须

00:44:33.460 --> 00:44:41.560
继续检查它，所以我认为

00:44:39.190 --> 00:44:44.290
主要结论是因为

00:44:41.560 --> 00:44:46.030
并行流是如此简单

00:44:44.290 --> 00:44:48.430
好吧，平行转动很容易

00:44:46.030 --> 00:44:50.560
流到并行流

00:44:48.430 --> 00:44:53.080
并不意味着您应该在

00:44:50.560 --> 00:44:57.760
相反，总是明智地做

00:44:53.080 --> 00:44:59.770
如果您有喜欢的应用程序

00:44:57.760 --> 00:45:01.300
好像我不知道这有多大

00:44:59.770 --> 00:45:03.610
它的很大一部分是并行流

00:45:01.300 --> 00:45:07.510
是否有一些东西总是适用于那些

00:45:03.610 --> 00:45:09.490
三个步骤是衡量措施和

00:45:07.510 --> 00:45:11.920
衡量是否真的

00:45:09.490 --> 00:45:13.320
表现得应该是因为你

00:45:11.920 --> 00:45:15.460
也许你会觉得还好

00:45:13.320 --> 00:45:18.340
表现不佳或完全做到了

00:45:15.460 --> 00:45:21.190
出现问题，因此将其用于CPU 

00:45:18.340 --> 00:45:23.290
密集任务选择数据结构

00:45:21.190 --> 00:45:27.550
容易分解的例子

00:45:23.290 --> 00:45:29.260
链接被链接列表不是选择数据

00:45:27.550 --> 00:45:31.330
也很容易组成的结构

00:45:29.260 --> 00:45:33.070
我的意思是链接列表很容易撰写

00:45:31.330 --> 00:45:34.510
但是如果你考虑一下心脏

00:45:33.070 --> 00:45:36.820
你就像一个收集者sc着

00:45:34.510 --> 00:45:39.370
他们不是那么琐碎

00:45:36.820 --> 00:45:41.500
再次撰写，请三思而后行

00:45:39.370 --> 00:45:43.270
宁愿使用它来获取大量数据

00:45:41.500 --> 00:45:45.280
所以你就像我不知道十

00:45:43.270 --> 00:45:46.810
流中的元素不会打扰

00:45:45.280 --> 00:45:48.790
好，非常感谢您成为

00:45:46.810 --> 00:45:51.450
真棒观众，并在

00:45:48.790 --> 00:45:51.450
直接先井

