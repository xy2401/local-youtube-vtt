WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.139 --> 00:00:07.580
好吧，至少让我开始

00:00:06.290 --> 00:00:09.650
无论如何，如果他们必须

00:00:07.580 --> 00:00:11.599
调整，他们将进行调整

00:00:09.650 --> 00:00:13.429
标题是并行流

00:00:11.599 --> 00:00:15.709
可完备的期货及所有

00:00:13.429 --> 00:00:17.690
想法是看并发

00:00:15.709 --> 00:00:19.010
机制和并行机制

00:00:17.690 --> 00:00:21.680
 Java内部

00:00:19.010 --> 00:00:23.420
现在我专门指的是Java 

00:00:21.680 --> 00:00:26.000
八，当然一切都会延续

00:00:23.420 --> 00:00:28.220
 Java 9的权利，他们增加了一些

00:00:26.000 --> 00:00:30.470
 Java中API的方法九但

00:00:28.220 --> 00:00:32.739
基本上是一样的东西，所以

00:00:30.470 --> 00:00:36.890
我现在要谈论的是

00:00:32.739 --> 00:00:38.870
既适用于10-9，也适用于

00:00:36.890 --> 00:00:41.930
运行此代码，我将显示的代码

00:00:38.870 --> 00:00:43.760
您在Java 8和Java下都可以工作

00:00:41.930 --> 00:00:47.300
 Java 9，我给你

00:00:43.760 --> 00:00:49.250
信息，现在我叫肯

00:00:47.300 --> 00:00:50.630
表哥，就像

00:00:49.250 --> 00:00:52.790
亲戚，即使它看起来不

00:00:50.630 --> 00:00:56.660
喜欢它，我们认为这是埃利斯岛的工作

00:00:52.790 --> 00:00:59.570
或我公司的表亲IT 

00:00:56.660 --> 00:01:02.149
堂兄IT称呼它，我的妻子指的是它

00:00:59.570 --> 00:01:02.870
作为表亲，就像亚当斯一家一样

00:01:02.149 --> 00:01:04.939
是她的主意

00:01:02.870 --> 00:01:07.850
你能做什么呢？ 

00:01:04.939 --> 00:01:10.130
电子邮件地址网站博客和Twitter 

00:01:07.850 --> 00:01:12.620
请随时与我联系

00:01:10.130 --> 00:01:16.670
我的删除密钥与任何人的都一样有效

00:01:12.620 --> 00:01:18.710
好吧，几年前我写了一篇

00:01:16.670 --> 00:01:20.479
这本书叫把工作变成时髦

00:01:18.710 --> 00:01:22.880
 Java Groovy集成书出版

00:01:20.479 --> 00:01:25.729
去年通过曼宁我写了一本书

00:01:22.880 --> 00:01:27.680
被称为Android的Gradle食谱

00:01:25.729 --> 00:01:29.630
如果您是

00:01:27.680 --> 00:01:31.760
去Gradle dot org并注册你

00:01:29.630 --> 00:01:34.760
可以免费得到那本书

00:01:31.760 --> 00:01:36.740
这样显示了我的谈判能力

00:01:34.760 --> 00:01:38.930
我就一本书商定了版税

00:01:36.740 --> 00:01:40.970
知道他们会放弃，所以你

00:01:38.930 --> 00:01:44.240
不想让我跟你谈判

00:01:40.970 --> 00:01:45.170
合同这是我拥有的书

00:01:44.240 --> 00:01:47.210
现在出来

00:01:45.170 --> 00:01:48.770
现代Java食谱以及我所拥有的一切

00:01:47.210 --> 00:01:51.650
要和你谈很多

00:01:48.770 --> 00:01:53.869
在这本书中，我们实际上有一个

00:01:51.650 --> 00:01:57.259
在O'Reilly签署书

00:01:53.869 --> 00:01:59.420
参展商我认为它们是一层楼

00:01:57.259 --> 00:02:01.340
明天在墙下

00:01:59.420 --> 00:02:03.470
如果你在下午两点

00:02:01.340 --> 00:02:05.090
现在有兴趣我提出来的原因

00:02:03.470 --> 00:02:07.189
部分原因是我的编辑确实

00:02:05.090 --> 00:02:09.579
如果我不生气，那也是因为

00:02:07.189 --> 00:02:12.050
这些是github的URL 

00:02:09.579 --> 00:02:14.720
我要去的代码库

00:02:12.050 --> 00:02:16.310
向您展示整个图书库

00:02:14.720 --> 00:02:19.099
在github下平静

00:02:16.310 --> 00:02:22.010
我的姓氏，然后是Java 

00:02:19.099 --> 00:02:24.950
下划线现在我有8个下划线食谱

00:02:22.010 --> 00:02:26.060
我有几个小例子

00:02:24.950 --> 00:02:28.130
带你去那里

00:02:26.060 --> 00:02:29.870
但是我需要一个更大的例子

00:02:28.130 --> 00:02:31.430
展示如何完成未来的工作

00:02:29.870 --> 00:02:33.380
放在一起我平行

00:02:31.430 --> 00:02:36.140
流，也有人在

00:02:33.380 --> 00:02:39.560
我称为CF盒分数的单独回购

00:02:36.140 --> 00:02:42.590
要从中下载盒分数数据

00:02:39.560 --> 00:02:44.599
美国职棒大联盟线上，所以我

00:02:42.590 --> 00:02:46.790
可能对我们的Wi-Fi提出了很多要求

00:02:44.599 --> 00:02:48.350
但嘿，你知道你是否不知道

00:02:46.790 --> 00:02:50.060
尝试知道让我们看看会发生什么

00:02:48.350 --> 00:02:52.790
对，如果这很容易，任何人都可以做到

00:02:50.060 --> 00:02:54.500
所以无论如何我有两个github仓库

00:02:52.790 --> 00:02:56.360
参与其中，欢迎您参加

00:02:54.500 --> 00:02:58.340
您想要的任何东西

00:02:56.360 --> 00:03:00.799
这本书我也有一个叫做Java的仓库

00:02:58.340 --> 00:03:03.080
下划线的9下划线食谱

00:03:00.799 --> 00:03:06.349
少数几个Java 9，但我

00:03:03.080 --> 00:03:08.569
如果您有这个话，请不要使用它

00:03:06.349 --> 00:03:10.519
一个野生动物园帐户，我有一堆

00:03:08.569 --> 00:03:12.920
 Safari图书在线上的视频课程I 

00:03:10.519 --> 00:03:14.330
还在那里教训练课程

00:03:12.920 --> 00:03:16.970
当然所有的书都在那里

00:03:14.330 --> 00:03:18.500
也是，这更多是自我营销

00:03:16.970 --> 00:03:21.410
比我能忍受的多，所以让我们继续前进

00:03:18.500 --> 00:03:22.459
现在是的，让我们摆脱它

00:03:21.410 --> 00:03:24.380
因为任何时候你谈论

00:03:22.459 --> 00:03:26.209
并发和并行性

00:03:24.380 --> 00:03:28.850
变得烦恼，他们变得非常精确

00:03:26.209 --> 00:03:30.890
关于它，我这样定义它

00:03:28.850 --> 00:03:33.290
我是如何理解货币的

00:03:30.890 --> 00:03:35.540
您正在为自己设计的内容

00:03:33.290 --> 00:03:37.940
关于拥有多个可以

00:03:35.540 --> 00:03:40.459
可以同时运行

00:03:37.940 --> 00:03:41.840
正如他们所说的那样，但是

00:03:40.459 --> 00:03:43.280
并不代表他们在跑步

00:03:41.840 --> 00:03:45.560
同时意味着我们试图

00:03:43.280 --> 00:03:47.989
设计时要牢记这一点

00:03:45.560 --> 00:03:49.910
而并行性是当我们实际上

00:03:47.989 --> 00:03:52.010
同时运行两件事

00:03:49.910 --> 00:03:53.450
所以原则上你必须有

00:03:52.010 --> 00:03:55.430
多核做并行

00:03:53.450 --> 00:03:57.109
虽然我会争论你是否愿意

00:03:55.430 --> 00:03:59.090
多线程有效

00:03:57.109 --> 00:04:00.530
平行，但这就是灰色

00:03:59.090 --> 00:04:02.389
将会有很多辩论的领域

00:04:00.530 --> 00:04:04.459
碰巧我要尝试使用那些

00:04:02.389 --> 00:04:06.500
记住这些话是

00:04:04.459 --> 00:04:08.569
您倾向于在网上看到的定义，所以我

00:04:06.500 --> 00:04:10.850
以为我会把它们带到这里好

00:04:08.569 --> 00:04:12.620
现在我要定义

00:04:10.850 --> 00:04:15.019
提出一些你可能知道的东西

00:04:12.620 --> 00:04:16.669
富有的Hickey的创造者

00:04:15.019 --> 00:04:20.000
闭包编程语言闭包

00:04:16.669 --> 00:04:22.100
与基本上在JVM上的Lisp给

00:04:20.000 --> 00:04:23.720
几年前的主题演讲

00:04:22.100 --> 00:04:25.280
在会议上被称为怪圈

00:04:23.720 --> 00:04:27.919
你们当中有些人可能知道路易

00:04:25.280 --> 00:04:29.750
它被称为简单变得容易，现在

00:04:27.919 --> 00:04:33.500
引人入胜的主题演讲，但只有你

00:04:29.750 --> 00:04:35.210
从我的角度来看，出于一个原因

00:04:33.500 --> 00:04:37.580
概念是一些东西

00:04:35.210 --> 00:04:40.280
概念上固有的简单含义

00:04:37.580 --> 00:04:42.760
简单甚至简单执行

00:04:40.280 --> 00:04:47.060
确切地知道该怎么做一步一步

00:04:42.760 --> 00:04:48.740
而easy的概念是

00:04:47.060 --> 00:04:50.540
这是库中的方法调用， 

00:04:48.740 --> 00:04:53.840
下可能会有大量的复杂性

00:04:50.540 --> 00:04:56.420
引擎盖，但很容易做到

00:04:53.840 --> 00:04:58.940
 Java 8中的并行流

00:04:56.420 --> 00:05:01.280
使实验变得非常容易

00:04:58.940 --> 00:05:03.410
并行性，但这并不意味着

00:05:01.280 --> 00:05:05.560
从中获得出色的性能

00:05:03.410 --> 00:05:08.570
并发并行应用程序是

00:05:05.560 --> 00:05:11.060
简单看，这可能非常复杂

00:05:08.570 --> 00:05:13.640
我将谈论一般

00:05:11.060 --> 00:05:15.500
一般接受的要求是

00:05:13.640 --> 00:05:17.960
这对它的工作很有好处

00:05:15.500 --> 00:05:19.820
出来，但我不想假装

00:05:17.960 --> 00:05:22.280
即使他们添加了很多

00:05:19.820 --> 00:05:24.680
方便实验的课程

00:05:22.280 --> 00:05:27.050
这仍然不是一个简单的现象

00:05:24.680 --> 00:05:29.420
平行的东西在这里我想结合

00:05:27.050 --> 00:05:32.210
那个想法是我的一种

00:05:29.420 --> 00:05:35.660
最喜欢的示范或插图

00:05:32.210 --> 00:05:38.150
容易这个词的意思是我记得

00:05:35.660 --> 00:05:40.550
曾为Star呈现过剧本

00:05:38.150 --> 00:05:42.800
跋涉着下一代

00:05:40.550 --> 00:05:45.110
今年的周年纪念日，他们

00:05:42.800 --> 00:05:47.000
作家已经写出了这个精心制作的

00:05:45.110 --> 00:05:48.410
皮卡德船长的指令集

00:05:47.000 --> 00:05:50.540
告诉他如何进入轨道

00:05:48.410 --> 00:05:52.880
一个星球，他把它全部划掉了， 

00:05:50.540 --> 00:05:55.970
当标准轨道少尉，那是

00:05:52.880 --> 00:05:58.040
它很容易，没有必要

00:05:55.970 --> 00:06:00.080
很简单，这就是这种想法

00:05:58.040 --> 00:06:02.450
我现在正在寻找，我也想

00:06:00.080 --> 00:06:04.190
提到Brian的评论让我成为

00:06:02.450 --> 00:06:05.810
确定您熟悉Brian，如果

00:06:04.190 --> 00:06:07.550
他在这个房间里，请不要告诉我

00:06:05.810 --> 00:06:10.640
我实在太吓人了，无法完成

00:06:07.550 --> 00:06:14.720
好的谈话，布莱恩得到的是

00:06:10.640 --> 00:06:17.090
在实践中他也有Java并发

00:06:14.720 --> 00:06:19.640
是Java的首席设计师之一

00:06:17.090 --> 00:06:21.860
在儿子和现在的甲骨文你知道其中之一

00:06:19.640 --> 00:06:23.990
业内真正的巨人

00:06:21.860 --> 00:06:26.000
当他谈论并发时

00:06:23.990 --> 00:06:28.610
当他谈论任何事情时，我在听

00:06:26.000 --> 00:06:31.790
通常不了解，但我知道

00:06:28.610 --> 00:06:34.340
听他说过很多次

00:06:31.790 --> 00:06:37.190
并行严格来说是一种优化

00:06:34.340 --> 00:06:39.080
这是最近发生的一个

00:06:37.190 --> 00:06:41.870
他在Java上写的一系列文章

00:06:39.080 --> 00:06:43.070
在developerWorks IBM网站上流

00:06:41.870 --> 00:06:46.160
开发人员

00:06:43.070 --> 00:06:48.260
在此处链接到第四条

00:06:46.160 --> 00:06:49.790
在五个系列中，只有一个

00:06:48.260 --> 00:06:51.830
他谈论并行流

00:06:49.790 --> 00:06:53.810
当然欢迎您

00:06:51.830 --> 00:06:56.300
演示文稿已上传，但如果

00:06:53.810 --> 00:06:58.700
在联系我之前，您需要它

00:06:56.300 --> 00:07:00.950
我很乐意将其发送给您

00:06:58.700 --> 00:07:03.380
这样的想法与所有并行性和

00:07:00.950 --> 00:07:05.630
 Java中的并发机制是为了

00:07:03.380 --> 00:07:08.660
您的代码首先按顺序工作

00:07:05.630 --> 00:07:10.430
使用顺序流，然后

00:07:08.660 --> 00:07:11.840
一旦工作，那么您可以

00:07:10.430 --> 00:07:14.210
试验并行性并具有

00:07:11.840 --> 00:07:15.770
有信心，你可以画一些

00:07:14.210 --> 00:07:16.730
结论并从中获得一些好处

00:07:15.770 --> 00:07:20.210
没关系

00:07:16.730 --> 00:07:23.090
这就是所有的豁免，让我们继续

00:07:20.210 --> 00:07:25.310
是所有工厂方法吗

00:07:23.090 --> 00:07:27.830
我们在Java中使用的机制

00:07:25.310 --> 00:07:29.180
创建流有stream方法

00:07:27.830 --> 00:07:31.730
这是一个默认的方法

00:07:29.180 --> 00:07:33.920
添加到集合中的是

00:07:31.730 --> 00:07:35.960
 method用于的工厂方法

00:07:33.920 --> 00:07:36.530
 Java 8中的许多类产生一个

00:07:35.960 --> 00:07:38.510
宾语

00:07:36.530 --> 00:07:40.280
有一个迭代方法需要一个

00:07:38.510 --> 00:07:43.100
种子，然后是一元运算符， 

00:07:40.280 --> 00:07:44.840
通过应用提供连续值

00:07:43.100 --> 00:07:47.090
一元运算符一遍又一遍

00:07:44.840 --> 00:07:48.440
到现有的价值，然后有

00:07:47.090 --> 00:07:50.540
生成方法需要一个

00:07:48.440 --> 00:07:51.710
供应商，它只是调用供应商

00:07:50.540 --> 00:07:54.920
一遍又一遍地

00:07:51.710 --> 00:07:58.970
当我们进行所有这些操作时检索结果

00:07:54.920 --> 00:08:01.130
默认情况下会产生顺序流

00:07:58.970 --> 00:08:02.660
每当你不放的时候

00:08:01.130 --> 00:08:05.810
这样如果你不特别说

00:08:02.660 --> 00:08:08.150
并行是顺序的

00:08:05.810 --> 00:08:10.220
现在有几种方法可以使

00:08:08.150 --> 00:08:12.980
并行流之一是那个集合

00:08:10.220 --> 00:08:14.810
也有并行流方法

00:08:12.980 --> 00:08:16.970
我们也有选择

00:08:14.810 --> 00:08:19.040
我经常要做的就是创造

00:08:16.970 --> 00:08:21.110
一个带有流的应用程序，然后

00:08:19.040 --> 00:08:23.120
将其更改为并行流以查看是否

00:08:21.110 --> 00:08:24.410
可以改善我所需要的一切

00:08:23.120 --> 00:08:27.170
调整以便从中受益

00:08:24.410 --> 00:08:30.140
还有一种方法叫做

00:08:27.170 --> 00:08:32.720
现在从技术上讲并行流内

00:08:30.140 --> 00:08:34.790
在父流中

00:08:32.720 --> 00:08:37.340
流的接口也有一个

00:08:34.790 --> 00:08:39.950
称为顺序的方法以及

00:08:37.340 --> 00:08:42.530
 Java Doc对此非常含糊，但是

00:08:39.950 --> 00:08:45.260
这个想法是并行将返回一个

00:08:42.530 --> 00:08:47.630
并行流或现有流

00:08:45.260 --> 00:08:49.520
如果已经是并行和顺序的

00:08:47.630 --> 00:08:51.320
对于顺序的将执行相同的操作

00:08:49.520 --> 00:08:53.600
这些都是中间操作

00:08:51.320 --> 00:08:56.420
投放中意味着他们产生了新的

00:08:53.600 --> 00:08:59.660
从我们正在处理的内容中

00:08:56.420 --> 00:09:01.339
然后我们没有任何价值

00:08:59.660 --> 00:09:03.110
直到我们在终端表达式上

00:09:01.339 --> 00:09:05.779
就像我们处理流一样

00:09:03.110 --> 00:09:08.810
通常，如果您想找出是否

00:09:05.779 --> 00:09:10.579
流是顺序的还是并行的，然后

00:09:08.810 --> 00:09:12.800
有一种叫做并行的方法

00:09:10.579 --> 00:09:14.029
返回一个布尔值尼斯和简单容易

00:09:12.800 --> 00:09:15.920
找出你是否正在与

00:09:14.029 --> 00:09:17.990
连续的一个或并行的一个，但是

00:09:15.920 --> 00:09:21.500
一般来说，除非它说平行

00:09:17.990 --> 00:09:24.200
现在连续的事情之一是

00:09:21.500 --> 00:09:26.540
从API来看不是很明显

00:09:24.200 --> 00:09:29.240
重要的是要知道你做不到

00:09:26.540 --> 00:09:31.459
管道的一部分，然后

00:09:29.240 --> 00:09:34.010
并行部分，现在我们将讨论

00:09:31.459 --> 00:09:35.600
您想按顺序执行哪些操作

00:09:34.010 --> 00:09:37.700
您想并行执行哪些操作

00:09:35.600 --> 00:09:40.339
一分钟，但关键是你

00:09:37.700 --> 00:09:42.680
不能仅仅从

00:09:40.339 --> 00:09:44.510
顺序平行并返回并具有

00:09:42.680 --> 00:09:46.339
管道中间的变化

00:09:44.510 --> 00:09:48.589
现在，如果您知道流处理的方式

00:09:46.339 --> 00:09:51.290
作品，这不足为奇，但正如

00:09:48.589 --> 00:09:54.170
我在上课的快速插图

00:09:51.290 --> 00:09:57.890
我的仓库叫连续两个平行

00:09:54.170 --> 00:10:01.070
测试，如果我在这里和我一起去IntelliJ 

00:09:57.890 --> 00:10:02.930
去了，这是我想要的那个

00:10:01.070 --> 00:10:04.670
而且我显然必须要做

00:10:02.930 --> 00:10:08.449
字体较大，但让我先打开

00:10:04.670 --> 00:10:12.680
所以这是顺序的两个并行测试

00:10:08.449 --> 00:10:14.959
让我妈妈改善字体大小

00:10:12.680 --> 00:10:18.140
因为我们在这里改变了一切

00:10:14.959 --> 00:10:21.680
我只需要一点时间就可以

00:10:18.140 --> 00:10:23.570
我不知道35或36 

00:10:21.680 --> 00:10:27.890
可读性您在

00:10:23.570 --> 00:10:30.490
回来，很好，它没有做到，但是

00:10:27.890 --> 00:10:30.490
希望它将

00:10:32.920 --> 00:10:38.660
好吧，我会这样做，然后我会

00:10:35.990 --> 00:10:41.210
稍后再解决，所以这里的想法是

00:10:38.660 --> 00:10:44.090
只是有一系列的测试用例

00:10:41.210 --> 00:10:47.150
说明机制，所以我在这里说

00:10:44.090 --> 00:10:48.710
如果我在流上使用of方法

00:10:47.150 --> 00:10:50.300
断言当我叫点是

00:10:48.710 --> 00:10:52.820
并行将是错误的

00:10:50.300 --> 00:10:55.730
迭代上的同一件事与

00:10:52.820 --> 00:10:57.710
用数学冒号冒号生成错误

00:10:55.730 --> 00:10:59.960
随机，有我的供应商专门

00:10:57.710 --> 00:11:03.290
也不是双重供应商

00:10:59.960 --> 00:11:05.540
如果我创建了一个列表

00:11:03.290 --> 00:11:07.940
元素，然后调用stream方法

00:11:05.540 --> 00:11:10.070
同样，这不是平行的，但当然

00:11:07.940 --> 00:11:11.810
显然，如果我先调用并行

00:11:10.070 --> 00:11:14.630
因此，我将其更改为true， 

00:11:11.810 --> 00:11:16.610
然后在这里，如果我叫并行流

00:11:14.630 --> 00:11:18.470
当然是真的，所以一切都很好

00:11:16.610 --> 00:11:20.420
很好，这并不奇怪

00:11:18.470 --> 00:11:22.300
事情变得有趣的是，如果您尝试

00:11:20.420 --> 00:11:25.220
并行然后顺序

00:11:22.300 --> 00:11:27.560
连续，甚至即使您输入值

00:11:25.220 --> 00:11:29.840
在这之间我说我们走吧

00:11:27.560 --> 00:11:31.250
并行，因为我想做的就是

00:11:29.840 --> 00:11:33.830
加倍元素，这是一个

00:11:31.250 --> 00:11:35.780
独立的联合行动

00:11:33.830 --> 00:11:37.580
对于平行我会很好

00:11:35.780 --> 00:11:39.980
观察价值流逝并

00:11:37.580 --> 00:11:41.480
然后我要进行排序和排序

00:11:39.980 --> 00:11:44.780
想顺序执行，因为那是一个

00:11:41.480 --> 00:11:47.480
状态操作，它已经

00:11:44.780 --> 00:11:49.130
自己的并行机制

00:11:47.480 --> 00:11:51.590
我内置的并发机制

00:11:49.130 --> 00:11:53.810
表示这不是真正的并行排序，但

00:11:51.590 --> 00:11:55.700
这只是一个现有的排序，所以这是一个

00:11:53.810 --> 00:11:57.380
你很想做得好

00:11:55.700 --> 00:11:59.600
事实证明，平行和

00:11:57.380 --> 00:12:01.820
顺序基本上是设置或

00:11:59.600 --> 00:12:03.200
取消设置标志，因为什么也没有

00:12:01.820 --> 00:12:05.360
直到我击中终点站

00:12:03.200 --> 00:12:07.490
在这里表达收集你的东西

00:12:05.360 --> 00:12:09.050
会发现，一旦我击中

00:12:07.490 --> 00:12:10.910
终端表达会很好

00:12:09.050 --> 00:12:13.340
开始并行我们切换到顺序

00:12:10.910 --> 00:12:16.520
整个流将被视为

00:12:13.340 --> 00:12:18.470
顺序流好，所以您无法打开

00:12:16.520 --> 00:12:20.450
将其打开一部分然后关闭

00:12:18.470 --> 00:12:21.950
你基本上必须做两个

00:12:20.450 --> 00:12:24.770
分开流没有简单的方法

00:12:21.950 --> 00:12:26.390
好吧，如果你要走的话

00:12:24.770 --> 00:12:28.010
返回流，然后调用

00:12:26.390 --> 00:12:30.200
你知道的东西尝试把它们放进去

00:12:28.010 --> 00:12:31.730
再次分离方法，因为什么也没有

00:12:30.200 --> 00:12:33.080
直到您到达终端为止

00:12:31.730 --> 00:12:35.750
表达不会有帮助

00:12:33.080 --> 00:12:38.180
您也可以并行进行

00:12:35.750 --> 00:12:41.060
部分返回具有双打的集合

00:12:38.180 --> 00:12:43.550
如果您愿意，然后按顺序进行

00:12:41.060 --> 00:12:45.950
与排序有关的部分

00:12:43.550 --> 00:12:46.310
最接近你可以做到的，所以我可以

00:12:45.950 --> 00:12:47.930
只是

00:12:46.310 --> 00:12:50.750
为了争辩我可以执行

00:12:47.930 --> 00:12:52.910
这整个课，你会看到

00:12:50.750 --> 00:12:54.440
测试通过，因此所有这些

00:12:52.910 --> 00:12:57.470
关于顺序和并行的断言

00:12:54.440 --> 00:12:58.850
是真的，没有什么大的意外，所以再次

00:12:57.470 --> 00:13:00.410
这是您需要注意的

00:12:58.850 --> 00:13:03.620
但是，如果您不知道这一点

00:13:00.410 --> 00:13:06.230
平行的时候可以咬你好吗

00:13:03.620 --> 00:13:08.000
值得在这里做的是基本

00:13:06.230 --> 00:13:10.400
我首先提到的要求

00:13:08.000 --> 00:13:13.670
操作必须独立

00:13:10.400 --> 00:13:15.680
和联系他们不必

00:13:13.670 --> 00:13:18.680
可交换的，因为它不会

00:13:15.680 --> 00:13:20.779
尝试将顺序切换为B与

00:13:18.680 --> 00:13:23.000
 B次a不会那样做

00:13:20.779 --> 00:13:25.339
并行是关于或并发的

00:13:23.000 --> 00:13:27.310
是关于分组的全部内容，而不是

00:13:25.339 --> 00:13:29.390
处理一百个元素

00:13:27.310 --> 00:13:32.000
依次地，我们将它们分开

00:13:29.390 --> 00:13:34.310
分为二十五和过程

00:13:32.000 --> 00:13:36.080
他们在各个小组中，所以这就是全部

00:13:34.310 --> 00:13:38.690
关于...的关联性质

00:13:36.080 --> 00:13:40.550
操作不是可交换性

00:13:38.690 --> 00:13:43.040
只要不介意

00:13:40.550 --> 00:13:45.620
你如何将他们分组的候选人

00:13:43.040 --> 00:13:48.320
对于并行性，我们也希望它是

00:13:45.620 --> 00:13:50.360
如果可以的话，我是无状态的

00:13:48.320 --> 00:13:52.280
说独立，使每个

00:13:50.360 --> 00:13:54.500
元素不依赖于周围环境

00:13:52.280 --> 00:13:56.120
元素或类似的任何其他元素

00:13:54.500 --> 00:13:58.670
加倍操作很明显

00:13:56.120 --> 00:14:00.800
独立且明确的关联性

00:13:58.670 --> 00:14:02.480
这是最低要求

00:14:00.800 --> 00:14:03.890
如果您在做并行操作

00:14:02.480 --> 00:14:05.960
有状态的或具有

00:14:03.890 --> 00:14:08.180
其他依赖关系没有

00:14:05.960 --> 00:14:10.190
为了给您带来任何好处

00:14:08.180 --> 00:14:13.100
要求是这件事，你会看到

00:14:10.190 --> 00:14:15.620
在各个网站上表示为n次

00:14:13.100 --> 00:14:17.660
 Q大于10,000，其中n是

00:14:15.620 --> 00:14:19.610
基本上是数据元素的数量

00:14:17.660 --> 00:14:22.160
 Q是花费的时间

00:14:19.610 --> 00:14:24.230
现在处理每个元素的问题

00:14:22.160 --> 00:14:26.690
该测量结果n乘以Q 

00:14:24.230 --> 00:14:29.150
超过10,000是他们从未将单位放在

00:14:26.690 --> 00:14:31.370
问，所以我不是说你如何衡量

00:14:29.150 --> 00:14:34.040
所以我们这样说吧

00:14:31.370 --> 00:14:36.860
 Q的n乘积必须大于某个

00:14:34.040 --> 00:14:39.650
引入开销的阈值

00:14:36.860 --> 00:14:40.940
通过并行，您基本上

00:14:39.650 --> 00:14:43.760
默认情况下，因为我们将看到

00:14:40.940 --> 00:14:45.709
引入叉叉池拆分

00:14:43.760 --> 00:14:47.450
工作和各个部分

00:14:45.709 --> 00:14:50.180
然后再将他们重新组合在一起

00:14:47.450 --> 00:14:53.330
一旦完成，就会介绍

00:14:50.180 --> 00:14:55.760
因此，您要么

00:14:53.330 --> 00:14:56.420
需要足够的数据来增加开销

00:14:55.760 --> 00:14:58.370
值得

00:14:56.420 --> 00:15:00.080
否则每个时间需要足够的时间

00:14:58.370 --> 00:15:02.960
那个开销的元素

00:15:00.080 --> 00:15:05.300
是值得的，诸如乘法或

00:15:02.960 --> 00:15:08.620
相加数字相信或

00:15:05.300 --> 00:15:11.240
不，基本的Java很少值得

00:15:08.620 --> 00:15:13.430
处理器速度极快

00:15:11.240 --> 00:15:15.650
处理原语，我会回来

00:15:13.430 --> 00:15:18.350
举例来说，我的意思是

00:15:15.650 --> 00:15:20.810
只是加起来，我做了很多

00:15:18.350 --> 00:15:22.640
一千万个数字的测试用例

00:15:20.810 --> 00:15:24.710
而且还远远不够

00:15:22.640 --> 00:15:27.110
值得去并行顺序

00:15:24.710 --> 00:15:29.420
如此之快以至于几乎不值得

00:15:27.110 --> 00:15:31.430
并行，我给你一些

00:15:29.420 --> 00:15:33.170
我们现在就此进行更好的指导

00:15:31.430 --> 00:15:35.450
人们不要的另一个要求

00:15:33.170 --> 00:15:37.810
经常谈论的是数据

00:15:35.450 --> 00:15:39.980
还需要易于分区

00:15:37.810 --> 00:15:41.000
记得当我们去平行

00:15:39.980 --> 00:15:43.640
 Java流

00:15:41.000 --> 00:15:46.220
我们在下面使用这个fork / join池

00:15:43.640 --> 00:15:48.800
引擎盖，我们只是分开

00:15:46.220 --> 00:15:50.660
分成相等大小的部分并做

00:15:48.800 --> 00:15:54.110
每个部分的处理，然后

00:15:50.660 --> 00:15:56.210
如果机器很好地合并它们

00:15:54.110 --> 00:15:58.640
不知道从哪里开始

00:15:56.210 --> 00:16:01.310
到底哪里不那么容易

00:15:58.640 --> 00:16:04.250
把它们分开，所以如果你说

00:16:01.310 --> 00:16:05.960
具有范围井的int流是

00:16:04.250 --> 00:16:07.550
很容易知道从哪里开始

00:16:05.960 --> 00:16:09.530
知道终点在哪里或范围

00:16:07.550 --> 00:16:12.140
关闭，但如果您有流点

00:16:09.530 --> 00:16:14.330
也要问一个限制

00:16:12.140 --> 00:16:15.920
很多不一定现在知道

00:16:14.330 --> 00:16:17.840
当然从机械角度来看

00:16:15.920 --> 00:16:19.910
查看您是否正在处理数组

00:16:17.840 --> 00:16:22.490
您的数据来源非常好

00:16:19.910 --> 00:16:24.650
连续的内存位置是

00:16:22.490 --> 00:16:25.940
梦想的场景，而如果

00:16:24.650 --> 00:16:29.030
你正在处理一个链表

00:16:25.940 --> 00:16:32.030
祝你好运，所以这个想法是

00:16:29.030 --> 00:16:34.880
数据应来自以下情况： 

00:16:32.030 --> 00:16:37.280
如果有的话，很容易分区

00:16:34.880 --> 00:16:39.170
那值得你期待

00:16:37.280 --> 00:16:42.950
从中获得重大收益

00:16:39.170 --> 00:16:44.930
现在并行并行化

00:16:42.950 --> 00:16:48.170
展示一个演示，我将展示一个简单的

00:16:44.930 --> 00:16:50.420
演示将只运行一个主

00:16:48.170 --> 00:16:52.730
方法并说明这一点，但当然

00:16:50.420 --> 00:16:54.440
所有这样的示威都应该

00:16:52.730 --> 00:16:57.110
有点怀疑，因为

00:16:54.440 --> 00:16:58.550
您已经有了JVM的热启动

00:16:57.110 --> 00:17:01.820
不知道这是怎么回事

00:16:58.550 --> 00:17:04.280
系统等，有一个项目来了

00:17:01.820 --> 00:17:07.280
来自名为的开放JDK项目

00:17:04.280 --> 00:17:09.830
 Java Micro基准测试利用了许多人

00:17:07.280 --> 00:17:11.540
可能听说过它是一个

00:17:09.830 --> 00:17:13.910
基于的Java项目

00:17:11.540 --> 00:17:17.660
注释，它允许您

00:17:13.910 --> 00:17:19.790
尽可能多地运行一种方法

00:17:17.660 --> 00:17:22.370
指定它进行一系列的热身

00:17:19.790 --> 00:17:25.570
迭代它将创建一个分叉的JVM 

00:17:22.370 --> 00:17:27.950
只是执行，你可以做各种

00:17:25.570 --> 00:17:31.400
优化，这是一个

00:17:27.950 --> 00:17:33.800
我不说显示器的好方法

00:17:31.400 --> 00:17:36.740
基本上衡量

00:17:33.800 --> 00:17:40.340
个别的方法，所以我把

00:17:36.740 --> 00:17:42.470
链接到jmh项目

00:17:40.340 --> 00:17:44.720
没有真正有据可查的，但他们确实

00:17:42.470 --> 00:17:46.730
有很多样本，这很有帮助

00:17:44.720 --> 00:17:49.340
现在我以两种不同的方式运行它

00:17:46.730 --> 00:17:51.200
一个是摇篮，我会用摇篮

00:17:49.340 --> 00:17:53.900
为我所做的一切构建工具

00:17:51.200 --> 00:17:55.670
 Gradle有一个不错的jmh插件， 

00:17:53.900 --> 00:17:57.530
工作正常，这就是我所拥有的

00:17:55.670 --> 00:18:00.410
仓库，如果你要看看

00:17:57.530 --> 00:18:03.440
代码库或IntelliJ IDEA 

00:18:00.410 --> 00:18:06.320
还有一个jmh插件，可让您

00:18:03.440 --> 00:18:08.810
只是作为方法运行，并且它

00:18:06.320 --> 00:18:11.210
将在那里进行基准测试，因此

00:18:08.810 --> 00:18:13.100
我建议这是一个不错的工具

00:18:11.210 --> 00:18:14.750
给您您实际上可以拥有的数据

00:18:13.100 --> 00:18:16.640
对你的某些信念知道那可能

00:18:14.750 --> 00:18:20.030
实际上是可以做的事

00:18:16.640 --> 00:18:22.850
现在重现以再次显示此内容

00:18:20.030 --> 00:18:25.880
在进行并行流时要提及

00:18:22.850 --> 00:18:27.950
您默认情况下委派给叉子

00:18:25.880 --> 00:18:31.550
现在加入池fork加入池是一个类

00:18:27.950 --> 00:18:33.470
 Java 1.7中添加的它是执行程序

00:18:31.550 --> 00:18:36.370
服务，如果您习惯使用

00:18:33.470 --> 00:18:40.580
执行器服务或执行器snoo已缓存

00:18:36.370 --> 00:18:42.830
池或固定大小的池或其他

00:18:40.580 --> 00:18:45.680
只是另一个而已

00:18:42.830 --> 00:18:49.760
他们默认使用它现在做

00:18:45.680 --> 00:18:51.380
公共池，这是一种内部方法

00:18:49.760 --> 00:18:54.260
 fork / join池的静态方法调用

00:18:51.380 --> 00:18:57.320
公共池返回用于的公共池

00:18:54.260 --> 00:18:59.390
 JVM现在这有好坏参半

00:18:57.320 --> 00:19:01.040
因为如果有其他事情，人们会很顺利

00:18:59.390 --> 00:19:03.260
在我正在使用的系统中进行

00:19:01.040 --> 00:19:05.780
同一个游泳池，那是不好的，你可以

00:19:03.260 --> 00:19:07.520
争论它，但它是高度优化的

00:19:05.780 --> 00:19:10.370
他们也称呼的游泳池

00:19:07.520 --> 00:19:12.560
偷工的意思是，如果额外

00:19:10.370 --> 00:19:14.840
作业已提交，一个线程

00:19:12.560 --> 00:19:17.060
碰巧闲着，它会去抓住

00:19:14.840 --> 00:19:19.940
工作正常，所以确实有

00:19:17.060 --> 00:19:21.320
我要说的是出色的性能

00:19:19.940 --> 00:19:23.840
如果没有给你

00:19:21.320 --> 00:19:25.520
您想要的性能然后

00:19:23.840 --> 00:19:27.470
我可以完成的未来方法

00:19:25.520 --> 00:19:30.580
要显示允许您指定

00:19:27.470 --> 00:19:33.950
遗嘱执行人服务或更准确地说是

00:19:30.580 --> 00:19:35.570
如果你想也很酷，我有一个

00:19:33.950 --> 00:19:38.270
现在的说明

00:19:35.570 --> 00:19:41.120
你专门制作叉叉池

00:19:38.270 --> 00:19:43.760
的默认池大小等于

00:19:41.120 --> 00:19:47.660
到此计算运行时获取运行时

00:19:43.760 --> 00:19:49.280
点实际可用的处理器

00:19:47.660 --> 00:19:51.710
认为我的意思是那里加一

00:19:49.280 --> 00:19:54.320
而不是减号，我会解决的

00:19:51.710 --> 00:19:56.360
但是这是我在笔记本电脑上的东西

00:19:54.320 --> 00:20:00.800
我想这些天我应该打电话给

00:19:56.360 --> 00:20:02.960
是一个私有云服务器，对

00:20:00.800 --> 00:20:05.540
只是一台笔记本电脑，这台笔记本电脑的价格是多少

00:20:02.960 --> 00:20:07.130
大约四岁，我在等

00:20:05.540 --> 00:20:08.900
对于他们，我仍然希望他们释放

00:20:07.130 --> 00:20:11.240
更好的Mac，我真的希望你知道

00:20:08.900 --> 00:20:14.480
但无论如何，我对此都有一个课程

00:20:11.240 --> 00:20:16.940
机器，所以当我创建这个共同点时

00:20:14.480 --> 00:20:19.160
池并获取池大小

00:20:16.940 --> 00:20:23.180
计算运行时点获取运行时

00:20:19.160 --> 00:20:25.520
点可用处理器返回七

00:20:23.180 --> 00:20:27.560
但随后您添加了一个，因为该池

00:20:25.520 --> 00:20:30.200
大小可能是七个，但主要仍然

00:20:27.560 --> 00:20:32.030
运作良好，所以我想到了

00:20:30.200 --> 00:20:34.220
因为工作被分配给所有人

00:20:32.030 --> 00:20:37.160
八个核心，实际上就是这样

00:20:34.220 --> 00:20:39.050
可以在实践中工作了，我会告诉你

00:20:37.160 --> 00:20:41.660
稍微改变一下数字

00:20:39.050 --> 00:20:44.090
线程数，如果您想要的话，但是首先

00:20:41.660 --> 00:20:46.310
我想演示一下，所以我有一个

00:20:44.090 --> 00:20:53.660
叫并行演示的课让我走

00:20:46.310 --> 00:20:56.060
回到这里，我将其打开

00:20:53.660 --> 00:20:58.220
我在这里做的是我有这个

00:20:56.060 --> 00:21:01.070
将数字加倍的方法

00:20:58.220 --> 00:21:02.990
这显然是一个功能， 

00:21:01.070 --> 00:21:05.180
我把它放在单独的方法中的原因是

00:21:02.990 --> 00:21:07.790
所以我可以手动引入睡眠

00:21:05.180 --> 00:21:09.140
在里面，我也要去做

00:21:07.790 --> 00:21:11.330
我通常会在尝试时做

00:21:09.140 --> 00:21:13.550
任何带有并行化的东西是我

00:21:11.330 --> 00:21:16.040
喜欢打印当前

00:21:13.550 --> 00:21:18.140
线程名称，以便我知道哪个线程

00:21:16.040 --> 00:21:19.520
正在操作以确保我用光了

00:21:18.140 --> 00:21:21.710
所有线程和事物都在工作

00:21:19.520 --> 00:21:23.240
现在这里的主要方法开始了

00:21:21.710 --> 00:21:25.640
具有非常小的数组列表

00:21:23.240 --> 00:21:28.580
六个要素以及我要做什么

00:21:25.640 --> 00:21:30.590
让我跳过这里，我要

00:21:28.580 --> 00:21:32.600
让我在流中做这个

00:21:30.590 --> 00:21:34.430
就在这里，我将从它开始

00:21:32.600 --> 00:21:36.830
按顺序让我关闭

00:21:34.430 --> 00:21:38.630
平行部分，我将其映射到

00:21:36.830 --> 00:21:41.610
将其翻倍，以便每次翻倍

00:21:38.630 --> 00:21:44.549
数字，但它将

00:21:41.610 --> 00:21:47.220
现在介绍一下睡眠

00:21:44.549 --> 00:21:50.070
减少到只有六个元素

00:21:47.220 --> 00:21:52.860
现在，我每个人都有足够的核心

00:21:50.070 --> 00:21:54.870
核心得到一个元素好，所以我的n是

00:21:52.860 --> 00:21:56.220
很小但是我受够了

00:21:54.870 --> 00:21:57.960
处理器来处理所有这些

00:21:56.220 --> 00:22:00.629
这就是为什么我不得不

00:21:57.960 --> 00:22:02.249
引入延迟，否则我不会

00:22:00.629 --> 00:22:04.080
从看到任何变化

00:22:02.249 --> 00:22:05.759
并行的，所以我要把它们全部加倍

00:22:04.080 --> 00:22:07.350
然后总结一下，我实际上不在乎

00:22:05.759 --> 00:22:09.240
关于太阳，但我需要一个终端

00:22:07.350 --> 00:22:11.309
操作以使流

00:22:09.240 --> 00:22:13.289
实际工作，我将在这里使用

00:22:11.309 --> 00:22:14.340
即时点现在在其他之间

00:22:13.289 --> 00:22:16.919
我将要打印出的单词

00:22:14.340 --> 00:22:18.929
花费的时间还可以，所以现在如果

00:22:16.919 --> 00:22:20.970
我依次执行此操作，我有六个

00:22:18.929 --> 00:22:23.100
我介绍了一百个数字

00:22:20.970 --> 00:22:26.129
毫秒延迟很好

00:22:23.100 --> 00:22:28.950
应该花大约六秒钟，如果我

00:22:26.129 --> 00:22:31.470
看一下这里的输出

00:22:28.950 --> 00:22:33.539
我介绍了600多个毫秒

00:22:31.470 --> 00:22:35.549
每一个都延迟一百毫秒

00:22:33.539 --> 00:22:37.590
花了600多毫秒

00:22:35.549 --> 00:22:40.200
这是我的期望，然后，如果我

00:22:37.590 --> 00:22:44.549
依次打开并行并

00:22:40.200 --> 00:22:48.330
再次运行它，您首先会看到

00:22:44.549 --> 00:22:51.659
这里有工人池1 

00:22:48.330 --> 00:22:54.419
通过5加主要看到，所以我仍然数

00:22:51.659 --> 00:22:56.549
那和主要将被重用，这

00:22:54.419 --> 00:22:59.249
花了一百多毫秒

00:22:56.549 --> 00:23:02.159
现在这是梦想的场景

00:22:59.249 --> 00:23:03.659
并行化，如果您在现场

00:23:02.159 --> 00:23:05.700
美好的生活，一切顺利

00:23:03.659 --> 00:23:07.529
这就是您将要知道的

00:23:05.700 --> 00:23:10.080
不会经常发生，但是它

00:23:07.529 --> 00:23:11.730
可能非常有益，这是一个

00:23:10.080 --> 00:23:12.840
你向你的经理展示你知道的顺序

00:23:11.730 --> 00:23:15.419
让他们让你继续工作

00:23:12.840 --> 00:23:17.460
关于这一点，你现在就知道了，但问题是

00:23:15.419 --> 00:23:19.710
我只是做了我说过的不做的事情

00:23:17.460 --> 00:23:21.960
对，我用主要方法租东西

00:23:19.710 --> 00:23:24.509
只是为了证明这是可行的

00:23:21.960 --> 00:23:29.460
考虑到这一点，我也有这个

00:23:24.509 --> 00:23:33.570
将jmh包中的演示翻倍

00:23:29.460 --> 00:23:35.850
您可以看到这是使用注释

00:23:33.570 --> 00:23:38.580
来自jmh的我正在寻找

00:23:35.850 --> 00:23:40.799
我希望时间单位是

00:23:38.580 --> 00:23:43.559
毫秒范围内

00:23:40.799 --> 00:23:46.049
我正在执行的每个计算都使用单线程

00:23:43.559 --> 00:23:48.899
派生我试图设置内存的JVM 

00:23:46.049 --> 00:23:50.519
尽可能地大

00:23:48.899 --> 00:23:53.369
内存不是这个问题

00:23:50.519 --> 00:23:54.630
计算，然后有我的相同

00:23:53.369 --> 00:23:57.420
加倍，但这

00:23:54.630 --> 00:23:59.850
一次我在这里输入两种方法

00:23:57.420 --> 00:24:02.400
与顺序并行与我

00:23:59.850 --> 00:24:04.320
在的顶部添加了基准注释

00:24:02.400 --> 00:24:06.090
他们现在我可以运行它，但它将

00:24:04.320 --> 00:24:08.850
花点时间运行，因为它会

00:24:06.090 --> 00:24:10.950
做20次热身迭代，然后进行20次

00:24:08.850 --> 00:24:13.800
平均的实际迭代

00:24:10.950 --> 00:24:15.750
并且会对每个

00:24:13.800 --> 00:24:17.670
他们，所以我将所有这些运行

00:24:15.750 --> 00:24:19.710
加上我的拖延， 

00:24:17.670 --> 00:24:21.390
而相反，我要做的是

00:24:19.710 --> 00:24:24.360
复制结果并将其放入

00:24:21.390 --> 00:24:26.370
这是顺序的， 

00:24:24.360 --> 00:24:29.550
您可以看到的是

00:24:26.370 --> 00:24:32.340
 40刚好超过600毫秒

00:24:29.550 --> 00:24:34.200
每次操作并并行

00:24:32.340 --> 00:24:36.600
每百毫秒

00:24:34.200 --> 00:24:39.570
操作和我相信的那些价值观

00:24:36.600 --> 00:24:41.820
好吧，这是一个非常好的工具， 

00:24:39.570 --> 00:24:43.830
确实让您对

00:24:41.820 --> 00:24:45.240
您正在执行的计算是

00:24:43.830 --> 00:24:46.860
真的，您需要了解的所有信息

00:24:45.240 --> 00:24:48.420
从并行流的东西开始

00:24:46.860 --> 00:24:50.820
我想给你那个背景

00:24:48.420 --> 00:24:52.920
现在人们总是一回事

00:24:50.820 --> 00:24:56.310
问问你如何改变数量

00:24:52.920 --> 00:24:58.290
线程有没有，这已列出

00:24:56.310 --> 00:25:00.270
在Java Docs本身中

00:24:58.290 --> 00:25:03.270
进入Java文档的fork / join池

00:25:00.270 --> 00:25:05.370
有一个设置叫做“相信它”或

00:25:03.270 --> 00:25:07.440
不是Java点util点并发点

00:25:05.370 --> 00:25:11.070
 fork / join池命令点并行

00:25:07.440 --> 00:25:13.740
那满口的，你可以把它放在

00:25:11.070 --> 00:25:16.950
您在命令行上用破折号

00:25:13.740 --> 00:25:19.290
大写D标志或您可以做系统

00:25:16.950 --> 00:25:21.510
点设置属性并选择另一个数字

00:25:19.290 --> 00:25:24.000
我实际上已经做了一个计算

00:25:21.510 --> 00:25:28.310
也像这样

00:25:24.000 --> 00:25:28.310
游泳池的大小只是为了告诉你我的意思

00:25:29.700 --> 00:25:35.970
所以在这里我只是试着做一个

00:25:33.480 --> 00:25:37.890
从一百万到三百万不等

00:25:35.970 --> 00:25:40.230
他们并行，然后我可以

00:25:37.890 --> 00:25:42.090
打印出池的大小，然后我可以

00:25:40.230 --> 00:25:44.430
说哦，我可以做一个手工

00:25:42.090 --> 00:25:46.380
无论我想要什么尺寸，然后我都可以

00:25:44.430 --> 00:25:48.750
使用常规的旧提交方法

00:25:46.380 --> 00:25:50.250
将要返回叉叉任务

00:25:48.750 --> 00:25:52.500
这意味着最终我将不得不打电话

00:25:50.250 --> 00:25:54.840
得到并抛出所有这些异常

00:25:52.500 --> 00:25:57.270
我们会在一分钟内解决这个问题

00:25:54.840 --> 00:25:59.520
是不改变基础的基础

00:25:57.270 --> 00:26:02.370
默认我要做的就是

00:25:59.520 --> 00:26:05.250
更改系统点获取属性并

00:26:02.370 --> 00:26:08.070
设置这个值，我可以运行它

00:26:05.250 --> 00:26:08.790
现在，如果您更改

00:26:08.070 --> 00:26:11.100
尺寸

00:26:08.790 --> 00:26:13.260
游泳池的面积比

00:26:11.100 --> 00:26:14.730
您磁盘上的处理器数量

00:26:13.260 --> 00:26:17.340
不太可能看到很多

00:26:14.730 --> 00:26:19.710
改善还可以，公共游泳池

00:26:17.340 --> 00:26:21.630
选择基于处理器还是

00:26:19.710 --> 00:26:23.670
基于线程池的数量

00:26:21.630 --> 00:26:26.280
您拥有的处理器非常不错

00:26:23.670 --> 00:26:28.170
猜猜你知道，但是你确实有

00:26:26.280 --> 00:26:30.180
您应该这样做的机制

00:26:28.170 --> 00:26:32.550
它是可用的，当然值得

00:26:30.180 --> 00:26:35.120
如果可以的话尝试一下

00:26:32.550 --> 00:26:41.220
足够那个

00:26:35.120 --> 00:26:44.730
现在在Java 8中添加的是

00:26:41.220 --> 00:26:48.570
已完成，但这是基于未来的

00:26:44.730 --> 00:26:50.430
 Java 1.5中添加了将来的接口

00:26:48.570 --> 00:26:51.810
好的，自从

00:26:50.430 --> 00:26:54.060
 Java点util点的添加

00:26:51.810 --> 00:26:56.520
并发包和关于

00:26:54.060 --> 00:26:59.010
未来的界面是，当您

00:26:56.520 --> 00:27:01.440
使用Submit方法返回未来

00:26:59.010 --> 00:27:03.930
接受执行人服务

00:27:01.440 --> 00:27:06.030
然后该方法立即返回

00:27:03.930 --> 00:27:08.700
那你可以去做其他的

00:27:06.030 --> 00:27:11.400
计算未来的问题

00:27:08.700 --> 00:27:13.470
未来的一个问题是

00:27:11.400 --> 00:27:15.510
为了从未来获得价值

00:27:13.470 --> 00:27:18.330
您必须致电get and get as 

00:27:15.510 --> 00:27:20.580
阻止通话，所以最终您得到了

00:27:18.330 --> 00:27:22.800
打电话给get，希望你完成了，或者

00:27:20.580 --> 00:27:25.470
你准备好等待它成为

00:27:22.800 --> 00:27:27.210
现在完成就可以了，但是那是

00:27:25.470 --> 00:27:29.550
生活成为生活的事实

00:27:27.210 --> 00:27:31.470
困难的是，如果我想拥有

00:27:29.550 --> 00:27:33.900
如果要先说多个期货

00:27:31.470 --> 00:27:36.870
做这个然后做那个然后做另一个

00:27:33.900 --> 00:27:38.880
现在我有一个问题，因为现在我在

00:27:36.870 --> 00:27:41.490
他们叫回地狱或我已经

00:27:38.880 --> 00:27:43.500
还有其他方法我必须等待

00:27:41.490 --> 00:27:45.030
信标完成的一切， 

00:27:43.500 --> 00:27:47.520
现在我觉得我要回到封锁

00:27:45.030 --> 00:27:49.800
再次，这是可以完成的未来

00:27:47.520 --> 00:27:52.740
在可完成的未来中实现

00:27:49.800 --> 00:27:54.570
非常容易协调多个任务

00:27:52.740 --> 00:27:58.410
这样它就等待一个完成

00:27:54.570 --> 00:28:00.630
在下一次执行之前，依此类推

00:27:58.410 --> 00:28:03.450
人们过去尝试过的方式

00:28:00.630 --> 00:28:05.310
协调常规的旧期货是

00:28:03.450 --> 00:28:07.350
未来有一种方法叫做完成

00:28:05.310 --> 00:28:09.270
你可以做这个忙的事情

00:28:07.350 --> 00:28:10.620
等待放一个while循环

00:28:09.270 --> 00:28:12.330
一直问你做完了吗

00:28:10.620 --> 00:28:14.340
我们在那儿吗我们在那儿吗

00:28:12.330 --> 00:28:17.040
在那里，那真是烦人

00:28:14.340 --> 00:28:19.740
好的，问题是那可以

00:28:17.040 --> 00:28:21.060
产生数十亿个电话

00:28:19.740 --> 00:28:22.530
知道特别快

00:28:21.060 --> 00:28:25.080
处理器是现在

00:28:22.530 --> 00:28:27.900
所以虽然这可行，我有一个演示

00:28:25.080 --> 00:28:30.120
我不一定推荐它

00:28:27.900 --> 00:28:33.090
这真的很痛苦，这又是

00:28:30.120 --> 00:28:34.410
部分原因是可完成的未来

00:28:33.090 --> 00:28:37.200
被创建了，我要跳到

00:28:34.410 --> 00:28:39.690
现在如此可完成的未来是

00:28:37.200 --> 00:28:42.860
所有关于协调的课程

00:28:39.690 --> 00:28:45.810
实现将来的两个接口

00:28:42.860 --> 00:28:47.850
完成阶段，这意味着

00:28:45.810 --> 00:28:50.220
涉及很多方法，我想

00:28:47.850 --> 00:28:52.200
向您展示基本思想

00:28:50.220 --> 00:28:54.450
虽然是如何完成一个

00:28:52.200 --> 00:28:56.370
如果我不想完成的未来

00:28:54.450 --> 00:28:58.410
打电话给我，如果我可以

00:28:56.370 --> 00:29:00.570
只是想完成它，有三个

00:28:58.410 --> 00:29:03.630
内置方式可以完成

00:29:00.570 --> 00:29:05.910
取得价值，甚至是未来

00:29:03.630 --> 00:29:07.650
我走之前现在特别完成

00:29:05.910 --> 00:29:10.500
这里的代码让我给你一个想法

00:29:07.650 --> 00:29:14.280
它们如何一起使用，所以这是

00:29:10.500 --> 00:29:16.320
想法说我有一些现金

00:29:14.280 --> 00:29:18.630
我使用并发的产品的整数

00:29:16.320 --> 00:29:20.370
哈希映射在这里，所以整数的缓存

00:29:18.630 --> 00:29:22.620
产品，现在我有一个方法叫做

00:29:20.370 --> 00:29:25.200
获取将要使用ID的本地

00:29:22.620 --> 00:29:28.170
在这里从中取出价值

00:29:25.200 --> 00:29:31.020
缓存，但我也有这个旧代码

00:29:28.170 --> 00:29:33.540
来自其他地方的

00:29:31.020 --> 00:29:36.030
获取远程方法需要一个ID 

00:29:33.540 --> 00:29:38.310
介绍我对网络的仿真

00:29:36.030 --> 00:29:41.280
如果您愿意，请延迟，否则将延迟

00:29:38.310 --> 00:29:42.810
那我也有这样的情况

00:29:41.280 --> 00:29:44.790
可能会引发异常

00:29:42.810 --> 00:29:47.700
出错了，我需要它是可预测的

00:29:44.790 --> 00:29:51.600
所以我可以喜欢我选择的ID 

00:29:47.700 --> 00:29:54.540
是的，不，我不会做任何事情

00:29:51.600 --> 00:29:56.010
开玩笑，所以我想要一些东西

00:29:54.540 --> 00:29:59.580
可预测的，所以我可以写一个测试用例

00:29:56.010 --> 00:30:00.690
为此，我选择了一个ID，然后在这里

00:29:59.580 --> 00:30:04.910
我最终将返回价值

00:30:00.690 --> 00:30:06.990
现在这是按顺序完成的

00:30:04.910 --> 00:30:08.970
让我们看看如何使用它们

00:30:06.990 --> 00:30:10.770
如果我有本地和获得

00:30:08.970 --> 00:30:12.930
远程，这些是私有方法

00:30:10.770 --> 00:30:15.630
然后将公共方法称为get 

00:30:12.930 --> 00:30:17.850
现在具有普通Java ID的产品

00:30:15.630 --> 00:30:19.680
您不会编写的并发代码

00:30:17.850 --> 00:30:22.500
得到我带有您想要的ID的产品

00:30:19.680 --> 00:30:24.480
在这种情况下，我要退货

00:30:22.500 --> 00:30:25.770
返回一个可完成的未来

00:30:24.480 --> 00:30:28.950
产品，因此将立即返回

00:30:25.770 --> 00:30:31.380
所以你尝试本地的，当你

00:30:28.950 --> 00:30:33.390
打电话到地图上，那里不是

00:30:31.380 --> 00:30:35.650
在那儿你得到一个空值，所以我会说

00:30:33.390 --> 00:30:38.680
看它是否不为null是否有效

00:30:35.650 --> 00:30:39.790
然后我用完整的未来说

00:30:38.680 --> 00:30:42.520
有我的产品

00:30:39.790 --> 00:30:45.460
期货完成了，我们准备好了

00:30:42.520 --> 00:30:48.400
如果基本上不在缓存中，将失败

00:30:45.460 --> 00:30:50.770
现在我必须使用我的旧系统

00:30:48.400 --> 00:30:53.130
我将在这里创造一个美好的未来

00:30:50.770 --> 00:30:55.510
致电获取远程退回产品

00:30:53.130 --> 00:30:57.580
最终将其放入缓存中

00:30:55.510 --> 00:30:59.680
我已经完成的通话时间

00:30:57.580 --> 00:31:02.890
实例化的可完成的未来和

00:30:59.680 --> 00:31:05.380
最后，如果有事情返回

00:31:02.890 --> 00:31:07.810
在所有这一切中，我都非常错误

00:31:05.380 --> 00:31:10.300
创造一个可完成的未来

00:31:07.810 --> 00:31:13.360
调用异常完成

00:31:10.300 --> 00:31:15.190
异常本身，以便我可以检查

00:31:13.360 --> 00:31:17.080
出现的异常，我可以

00:31:15.190 --> 00:31:19.030
检查其来源并找出原因

00:31:17.080 --> 00:31:20.860
它发生了，所有的工作

00:31:19.030 --> 00:31:22.510
这就是为什么这三个原因

00:31:20.860 --> 00:31:24.520
不同的方法，这是一个不错的选择

00:31:22.510 --> 00:31:26.110
鉴于我们的工作说明

00:31:24.520 --> 00:31:27.940
时间限制我只想说

00:31:26.110 --> 00:31:29.110
我相信这是可行的

00:31:27.940 --> 00:31:35.500
我将继续另一个例子

00:31:29.110 --> 00:31:37.780
好吧，现在跑步

00:31:35.500 --> 00:31:39.610
异步，因为所有这些都是

00:31:37.780 --> 00:31:41.350
同步，除了

00:31:39.610 --> 00:31:44.440
产品立即返回的方法

00:31:41.350 --> 00:31:46.120
可以很好地完成的未来工具

00:31:44.440 --> 00:31:48.850
都是未来，这就是为什么你拥有

00:31:46.120 --> 00:31:50.590
方法和其他人加入等

00:31:48.850 --> 00:31:53.050
实施完成阶段

00:31:50.590 --> 00:31:55.180
我去了大约38种方法

00:31:53.050 --> 00:31:57.340
计算意味着未来的发展

00:31:55.180 --> 00:31:59.530
超过50，看起来很漂亮

00:31:57.340 --> 00:32:01.930
幸运的是，这里有

00:31:59.530 --> 00:32:03.790
模式，我们可以遵循模式

00:32:01.930 --> 00:32:07.900
看起来像这样的方法

00:32:03.790 --> 00:32:10.360
单词适用于他们，就像适用得很好

00:32:07.900 --> 00:32:12.580
我们将看到它适用作为一个参数

00:32:10.360 --> 00:32:13.990
功能，因为助记符是

00:32:12.580 --> 00:32:17.230
记得你看过这个功能

00:32:13.990 --> 00:32:19.540
界面内部作为应用方法还可以

00:32:17.230 --> 00:32:21.280
所以这连接功能适用两个

00:32:19.540 --> 00:32:23.680
具有单词的功能方法

00:32:21.280 --> 00:32:25.180
再次接受消费者

00:32:23.680 --> 00:32:27.940
在使用者介面内

00:32:25.180 --> 00:32:29.320
单个抽象方法被接受，因此

00:32:27.940 --> 00:32:31.330
试图使其更容易记住

00:32:29.320 --> 00:32:32.980
运行方法需要一个可运行的

00:32:31.330 --> 00:32:35.290
这很容易，供应方法需要

00:32:32.980 --> 00:32:37.660
供应商，所以当您看到这些方法时

00:32:35.290 --> 00:32:39.490
您可以从中识别出的名称

00:32:37.660 --> 00:32:40.330
马上分类

00:32:39.490 --> 00:32:43.420
他们适合

00:32:40.330 --> 00:32:44.710
现在有那样的方法

00:32:43.420 --> 00:32:47.320
是如何结束它们的链接

00:32:44.710 --> 00:32:49.180
在一起所以看到有适用

00:32:47.320 --> 00:32:50.740
 apply需要一个我要使用的功能

00:32:49.180 --> 00:32:53.080
每个元素，我要平方它

00:32:50.740 --> 00:32:55.270
说这个例子是正确的

00:32:53.080 --> 00:32:56.560
我甚至没有运行过Java文档

00:32:55.270 --> 00:32:59.860
这就是Java文档

00:32:56.560 --> 00:33:01.180
然后除了带一个消费者

00:32:59.860 --> 00:33:03.100
点，我要打印它，看看我只是

00:33:01.180 --> 00:33:06.370
使用方法参考，但事实并非如此

00:33:03.100 --> 00:33:08.710
然后运行，这需要一个可运行的

00:33:06.370 --> 00:33:11.560
适用于谁知道为什么要打印马车

00:33:08.710 --> 00:33:15.160
返回好吧，但这是通过使用

00:33:11.560 --> 00:33:17.980
这些方法然后每个方法将

00:33:15.160 --> 00:33:20.710
等待未来完成

00:33:17.980 --> 00:33:22.720
现在自动转到下一个

00:33:20.710 --> 00:33:25.120
他们可以异步运行，但是

00:33:22.720 --> 00:33:26.440
有点像加入线程

00:33:25.120 --> 00:33:28.870
等待完成

00:33:26.440 --> 00:33:31.120
之前，它在每个方向上前进，并且

00:33:28.870 --> 00:33:33.280
通过像这样链接方法

00:33:31.120 --> 00:33:36.700
您可以完成更复杂的工作

00:33:33.280 --> 00:33:38.650
任务，所以您看到了还有一些

00:33:36.700 --> 00:33:40.810
方法名称中的模式

00:33:38.650 --> 00:33:43.090
说这一个或那个

00:33:40.810 --> 00:33:45.790
以先完成者为准

00:33:43.090 --> 00:33:47.770
等待两者结合在一起

00:33:45.790 --> 00:33:50.470
说等待这个然后提供

00:33:47.770 --> 00:33:51.910
一个按功能，将采取

00:33:50.470 --> 00:33:53.340
第一个结果和一个

00:33:51.910 --> 00:33:55.750
可完成的未来，并将它们放在一起

00:33:53.340 --> 00:33:57.400
所以它即将结束，您可以

00:33:55.750 --> 00:34:00.610
结合结果，我再告诉你

00:33:57.400 --> 00:34:02.530
一个例子，另一个模式

00:34:00.610 --> 00:34:05.380
就是在许多方法中

00:34:02.530 --> 00:34:07.330
他们以异步这个词结尾，然后

00:34:05.380 --> 00:34:10.210
有没有的超载

00:34:07.330 --> 00:34:12.940
不能与

00:34:10.210 --> 00:34:16.470
来电者回到这里

00:34:12.940 --> 00:34:19.690
这些都没有对他们说异步

00:34:16.470 --> 00:34:21.880
委托给猪肉接头中的一根线

00:34:19.690 --> 00:34:24.040
池，但是所有这三种方法都是

00:34:21.880 --> 00:34:27.370
完全在同一线程中运行

00:34:24.040 --> 00:34:29.650
而如果我用过，那么除了水槽或

00:34:27.370 --> 00:34:31.750
然后运行异步，那么它将需要

00:34:29.650 --> 00:34:34.570
工作，然后将其重新提交到分叉

00:34:31.750 --> 00:34:36.430
游泳池可以去下一个

00:34:34.570 --> 00:34:37.750
非常有用，但再次介绍

00:34:36.430 --> 00:34:39.550
开销，所以有点像

00:34:37.750 --> 00:34:42.430
不得不尝试它可能不会

00:34:39.550 --> 00:34:44.830
一定会帮助所有这些

00:34:42.430 --> 00:34:46.660
我们讨论过的其他因素，但

00:34:44.830 --> 00:34:48.700
关键是要知道哪个是那个

00:34:46.660 --> 00:34:50.950
具有异步功能的人确实会在

00:34:48.700 --> 00:34:52.690
单独的线程可能是因为

00:34:50.950 --> 00:34:55.420
重新提交到池和那些

00:34:52.690 --> 00:34:57.790
没有它，所以让我们来看一些

00:34:55.420 --> 00:35:00.220
这些东西再次全部完成

00:34:57.790 --> 00:35:01.700
还有另一类方法

00:35:00.220 --> 00:35:03.380
那里有超载

00:35:01.700 --> 00:35:06.290
所有几乎所有的方法

00:35:03.380 --> 00:35:08.960
提交工作需要额外的论点

00:35:06.290 --> 00:35:10.730
键入执行程序，那会说如果我

00:35:08.960 --> 00:35:13.339
不想使用普通的fork / join 

00:35:10.730 --> 00:35:15.800
然后我提供我自己的执行者

00:35:13.339 --> 00:35:18.349
遗嘱执行人服务好，所以如果你想

00:35:15.800 --> 00:35:20.329
只使用公共fork / join池

00:35:18.349 --> 00:35:22.700
你用过载没有

00:35:20.329 --> 00:35:25.780
否则你用它，我有

00:35:22.700 --> 00:35:28.760
一整套的测试用例

00:35:25.780 --> 00:35:31.339
例如可完成的未来测试

00:35:28.760 --> 00:35:33.290
例如将在这里显示您

00:35:31.339 --> 00:35:35.780
可以看到我做了一个修复线程池

00:35:33.290 --> 00:35:37.910
我确实提供了一个水槽

00:35:35.780 --> 00:35:40.070
采取一个供应商，但它将

00:35:37.910 --> 00:35:42.619
分别提交给我

00:35:40.070 --> 00:35:44.510
为第三个参数提供或

00:35:42.619 --> 00:35:46.700
与池本身的第二个参数，但

00:35:44.510 --> 00:35:48.440
然后申请，然后申请，然后除了

00:35:46.700 --> 00:35:51.200
所有将在与同一线程中运行

00:35:48.440 --> 00:35:53.750
我在游泳池中使用的那个

00:35:51.200 --> 00:35:57.109
你可以做什么的想法

00:35:53.750 --> 00:35:58.640
现在，如果我回到那个

00:35:57.109 --> 00:36:01.220
产品一，我以前展示过的

00:35:58.640 --> 00:36:04.339
我在远程查找中拥有了所有内容

00:36:01.220 --> 00:36:06.050
顺序发生遗留系统

00:36:04.339 --> 00:36:09.500
将很容易替换它

00:36:06.050 --> 00:36:11.960
与供应异步的一部分，所以我把这个

00:36:09.500 --> 00:36:14.390
进入我称之为远程的供应商

00:36:11.960 --> 00:36:16.700
放，一切都完成了

00:36:14.390 --> 00:36:18.770
未来可完成经营的一部分

00:36:16.700 --> 00:36:20.869
异步，然后完成

00:36:18.770 --> 00:36:22.640
其余的会发生，所以这是一个非常

00:36:20.869 --> 00:36:24.680
可以进行的简单更改

00:36:22.640 --> 00:36:29.599
希望能改善

00:36:24.680 --> 00:36:32.119
这个系统一般好吧，现在我们仍然

00:36:29.599 --> 00:36:34.910
有一个get方法，我们还有一个联接

00:36:32.119 --> 00:36:36.560
方法有趣的是

00:36:34.910 --> 00:36:38.420
 Java初期做出的决定

00:36:36.560 --> 00:36:40.760
我们仍在为其中之一付费

00:36:38.420 --> 00:36:42.050
被检查的异常对吧，我们仍然

00:36:40.760 --> 00:36:43.369
必须处理那些，如果你写

00:36:42.050 --> 00:36:44.390
您处理的许多流式代码

00:36:43.369 --> 00:36:47.869
一直

00:36:44.390 --> 00:36:49.910
好的get方法声明它可以

00:36:47.869 --> 00:36:52.250
同时抛出执行异常和

00:36:49.910 --> 00:36:53.839
中断的异常以及那些需要

00:36:52.250 --> 00:36:55.609
这些是检查异常

00:36:53.839 --> 00:36:58.190
需要try-catch块或抛出

00:36:55.609 --> 00:37:00.140
子句或其他东西也有联接

00:36:58.190 --> 00:37:01.849
完全相同的方法

00:37:00.140 --> 00:37:03.530
它唯一抛出的是

00:37:01.849 --> 00:37:05.630
未检查的完成异常

00:37:03.530 --> 00:37:07.849
因此，如果您想放入尝试

00:37:05.630 --> 00:37:10.040
块，您可以放入get，如果您

00:37:07.849 --> 00:37:11.960
你不加入加入，基本上

00:37:10.040 --> 00:37:14.060
当然，如果您现在也做同样的事情

00:37:11.960 --> 00:37:14.820
不要把异常抛在脑后

00:37:14.060 --> 00:37:17.100
你懂

00:37:14.820 --> 00:37:20.070
很好，但是如果您想管理它

00:37:17.100 --> 00:37:22.320
呼叫获取，否则您呼叫加入，但是

00:37:20.070 --> 00:37:24.780
就像将来那些方法阻塞一样

00:37:22.320 --> 00:37:27.090
等到事情完成

00:37:24.780 --> 00:37:29.100
另一方面，这是另一种

00:37:27.090 --> 00:37:31.320
人们不会经常看到你

00:37:29.100 --> 00:37:33.860
可以等待池报价

00:37:31.320 --> 00:37:37.710
静止有一个词适合你

00:37:33.860 --> 00:37:39.570
在fork / join池上有一个方法

00:37:37.710 --> 00:37:43.200
在这里，我将公用池称为

00:37:39.570 --> 00:37:46.560
等待静止，需要一段时间

00:37:43.200 --> 00:37:49.380
单位和我们的时间是整数，然后是

00:37:46.560 --> 00:37:52.710
表示要等待多长时间的时间单位

00:37:49.380 --> 00:37:56.820
游泳池安顿下来，不再

00:37:52.710 --> 00:37:58.260
忙，你能做的是，如果看到

00:37:56.820 --> 00:38:01.650
这是我应该说的概念

00:37:58.260 --> 00:38:03.900
当您说供应异步或任何

00:38:01.650 --> 00:38:06.090
您已经开始的那些方法

00:38:03.900 --> 00:38:07.950
过程中，您不必然后就不需要

00:38:06.090 --> 00:38:10.800
必须做一个开始方法或类似的事情

00:38:07.950 --> 00:38:13.140
它会自动运行，但是

00:38:10.800 --> 00:38:15.750
普通的分叉/连接池由

00:38:13.140 --> 00:38:18.420
恶魔线程，所以如果什么都不是

00:38:15.750 --> 00:38:20.370
运行它们都被终止，看看是否

00:38:18.420 --> 00:38:22.380
没有其他操作，只是关闭

00:38:20.370 --> 00:38:24.720
所以如果你有一个主要方法

00:38:22.380 --> 00:38:26.520
只是调用它然后它是main方法

00:38:24.720 --> 00:38:28.140
完成则没有任何结果

00:38:26.520 --> 00:38:31.320
因为所有的恶魔线程都是

00:38:28.140 --> 00:38:32.940
终止，您可以致电获取

00:38:31.320 --> 00:38:35.070
它将阻止并等待哪一点

00:38:32.940 --> 00:38:37.290
要完成的事情，或者您可以简单地

00:38:35.070 --> 00:38:39.510
更改公共池上的超时

00:38:37.290 --> 00:38:42.900
消除静态并使之变长

00:38:39.510 --> 00:38:45.660
足够它不会完成之前

00:38:42.900 --> 00:38:48.030
您的计算完成，并且其中一个

00:38:45.660 --> 00:38:50.160
这些工作的实际概念是

00:38:48.030 --> 00:38:52.470
在您要提交的真实系统中

00:38:50.160 --> 00:38:54.000
泳池一直都在工作

00:38:52.470 --> 00:38:56.640
静止不存在问题

00:38:54.000 --> 00:38:57.960
但这是直到

00:38:56.640 --> 00:39:00.390
你看到它，你甚至可能不认识

00:38:57.960 --> 00:39:02.640
它在那里，在那些地方非常有用

00:39:00.390 --> 00:39:05.070
池将具有的简单情况

00:39:02.640 --> 00:39:06.330
走了，你想知道你在找

00:39:05.070 --> 00:39:07.560
在某人的密码下，您被抓住了

00:39:06.330 --> 00:39:08.670
他们没有打电话给他们为什么不

00:39:07.560 --> 00:39:10.710
打电话说这里发生了什么

00:39:08.670 --> 00:39:13.800
完成它反正只是完成了

00:39:10.710 --> 00:39:15.390
因为他们等了我一件事

00:39:13.800 --> 00:39:18.120
在我告诉你之前要指出

00:39:15.390 --> 00:39:20.310
更大的例子中有很多方法

00:39:18.120 --> 00:39:22.890
该可完成的未来课程之一

00:39:20.310 --> 00:39:25.260
他们被称为所有需要一个可变参数

00:39:22.890 --> 00:39:27.750
任何种类的可完成期货清单

00:39:25.260 --> 00:39:28.650
这是一个静态方法的问题

00:39:27.750 --> 00:39:30.660
这种方法

00:39:28.650 --> 00:39:33.569
它返回可完成的未来向上类型

00:39:30.660 --> 00:39:35.220
现在无效，如果我不这样做会很好

00:39:33.569 --> 00:39:37.230
不在乎任何结果

00:39:35.220 --> 00:39:38.670
这些家伙，如果我真的在乎

00:39:37.230 --> 00:39:42.029
结果问题是我怎么得到

00:39:38.670 --> 00:39:43.920
他们最简单的方法是

00:39:42.029 --> 00:39:46.500
此可完成的未来var Arg列表

00:39:43.920 --> 00:39:48.599
将其分开收集，然后

00:39:46.500 --> 00:39:51.390
将其转换为数组，以便您

00:39:48.599 --> 00:39:54.260
可以呼叫这个，然后在

00:39:51.390 --> 00:39:57.660
所有这些，现在您知道他们已经完成了

00:39:54.260 --> 00:39:59.400
然后您可以进行流处理

00:39:57.660 --> 00:40:02.750
提取结果，看起来

00:39:59.400 --> 00:40:07.440
基本上像这样，这就是全部

00:40:02.750 --> 00:40:10.020
演示在这里，让我们来看看这里

00:40:07.440 --> 00:40:12.569
这就是我要称呼的就是获得价值

00:40:10.020 --> 00:40:15.059
我想返回一个整数，但我换行了

00:40:12.569 --> 00:40:16.799
它在可完成的未来，但如果

00:40:15.059 --> 00:40:18.480
我要睡觉了

00:40:16.799 --> 00:40:20.760
在其中，这就是我要做的

00:40:18.480 --> 00:40:22.770
这需要一些时间， 

00:40:20.760 --> 00:40:25.200
例外，这确实很尴尬

00:40:22.770 --> 00:40:27.510
管道中的异常处理代码

00:40:25.200 --> 00:40:29.940
我在这里用另一种方法制作的

00:40:27.510 --> 00:40:32.760
随机睡眠约100 

00:40:29.940 --> 00:40:34.349
毫秒或少返回42 I 

00:40:32.760 --> 00:40:36.839
实际上并不在乎价值， 

00:40:34.349 --> 00:40:39.359
然后在这里我将其称为

00:40:36.839 --> 00:40:41.670
次数，这是我的演示是

00:40:39.359 --> 00:40:44.430
我将生成调用该

00:40:41.670 --> 00:40:47.069
获得价值10个可完成流

00:40:44.430 --> 00:40:48.930
期货并将其转换为数组，以便

00:40:47.069 --> 00:40:50.970
这是正常的流处理代码

00:40:48.930 --> 00:40:53.130
使用某些方法，您可能不会使用

00:40:50.970 --> 00:40:54.029
通常喜欢生成或数组是

00:40:53.130 --> 00:40:57.270
真的很方便

00:40:54.029 --> 00:40:59.160
有我的数组构造函数参考

00:40:57.270 --> 00:41:00.569
你知道那种会创造一个

00:40:59.160 --> 00:41:03.630
数组，所以现在我有一个数组

00:41:00.569 --> 00:41:05.549
可完成的期货，我可以在

00:41:03.630 --> 00:41:08.400
所有这些都是因为数组与VAR相匹配

00:41:05.549 --> 00:41:10.920
 arg参数并调用join和now 

00:41:08.400 --> 00:41:13.289
他们完成了，我可以回头

00:41:10.920 --> 00:41:14.849
到流中并使用

00:41:13.289 --> 00:41:16.410
加入方法不要等到他们

00:41:14.849 --> 00:41:19.770
完成但要从中获取价值

00:41:16.410 --> 00:41:22.049
所以现在通过联接调用map 

00:41:19.770 --> 00:41:24.059
把我的转变变成了

00:41:22.049 --> 00:41:26.819
可完成的期货变成了

00:41:24.059 --> 00:41:28.680
无论价值来自何方

00:41:26.819 --> 00:41:31.230
可完成的期货本身以及

00:41:28.680 --> 00:41:32.880
然后我可以一张一张地打印出来

00:41:31.230 --> 00:41:36.539
这种情况下，我只会给你一堆

00:41:32.880 --> 00:41:38.490
 42岁，我知道吗，这很好

00:41:36.539 --> 00:41:40.230
可以用来的小机制

00:41:38.490 --> 00:41:42.390
从集合中提取值

00:41:40.230 --> 00:41:43.950
这样我现在有一个

00:41:42.390 --> 00:41:46.289
更大的例子，我主要只是去

00:41:43.950 --> 00:41:48.329
必须向您展示，但这是

00:41:46.289 --> 00:41:50.609
这里的想法是大联盟

00:41:48.329 --> 00:41:53.220
棒球提供他们的得分

00:41:50.609 --> 00:41:55.650
免费在线我认为自己的工具

00:41:53.220 --> 00:41:58.260
实际使用这些和这些盒子分数

00:41:55.650 --> 00:41:59.670
不断更新，现在您不需要

00:41:58.260 --> 00:42:01.049
需要了解棒球知识

00:41:59.670 --> 00:42:02.490
了解这一点，您只需要知道

00:42:01.049 --> 00:42:04.619
有两个团队，他们保持

00:42:02.490 --> 00:42:06.450
玩直到有赢家，这些

00:42:04.619 --> 00:42:07.950
统计数据汇总在

00:42:06.450 --> 00:42:10.109
所谓的盒子分数就是全部

00:42:07.950 --> 00:42:11.549
在这种情况下，我们需要

00:42:10.109 --> 00:42:13.410
你不知道游戏是否会

00:42:11.549 --> 00:42:15.359
播放直到它实际播放

00:42:13.410 --> 00:42:17.010
因为可能会下雨好

00:42:15.359 --> 00:42:20.460
现在就足够了

00:42:17.010 --> 00:42:24.599
例如，这是我的网页

00:42:20.460 --> 00:42:27.839
在这里提到美国职业棒球大联盟，如果我钻

00:42:24.599 --> 00:42:31.470
直到今年

00:42:27.839 --> 00:42:34.049
 2017年，然后按月组织

00:42:31.470 --> 00:42:36.750
我选5月5日是我儿子的生日

00:42:34.049 --> 00:42:39.450
你知道，这些是玩过的游戏

00:42:36.750 --> 00:42:41.609
那天你可以看到他们一年

00:42:39.450 --> 00:42:44.069
一个月的一天，然后离开团队和主场

00:42:41.609 --> 00:42:45.960
团队和一个或两个意味着第一

00:42:44.069 --> 00:42:47.460
或秒给双头任何速率

00:42:45.960 --> 00:42:49.440
这些是实际玩过的游戏

00:42:47.460 --> 00:42:53.160
如果你看其中一个

00:42:49.440 --> 00:42:55.799
你会看到有一个文件看起来他

00:42:53.160 --> 00:42:58.349
就在这里被称为盒式得分的杰森和

00:42:55.799 --> 00:43:00.539
这是拥有所有

00:42:58.349 --> 00:43:02.339
其中的信息谁在玩什么

00:43:00.539 --> 00:43:05.640
分数就是结果

00:43:02.339 --> 00:43:07.829
一切，所以这是一个系统

00:43:05.640 --> 00:43:10.470
待了很久我可能会

00:43:07.829 --> 00:43:13.109
想在我的申请中做的是

00:43:10.470 --> 00:43:16.289
访问该网站的日期范围

00:43:13.109 --> 00:43:18.509
然后找出游戏连结

00:43:16.289 --> 00:43:20.460
现在每个日期都要做

00:43:18.509 --> 00:43:24.079
我要使用的网络

00:43:20.460 --> 00:43:26.609
 HTTP非常受欢迎的网络客户端

00:43:24.079 --> 00:43:30.539
下载每个的JSON盒分数

00:43:26.609 --> 00:43:34.500
游戏，我正在使用解析器

00:43:30.539 --> 00:43:36.930
 HTTP我忘了它的名字吧

00:43:34.500 --> 00:43:38.549
现在，但这是一个非常常见的HTTP标准

00:43:36.930 --> 00:43:41.549
当我看到要执行的代码时，您会看到

00:43:38.549 --> 00:43:45.029
将每个JSON对象转换为Java 

00:43:41.549 --> 00:43:47.009
使用JSON的对象使用Google的JSON，因此

00:43:45.029 --> 00:43:50.369
我写了类来映射

00:43:47.009 --> 00:43:52.859
然后看到这就是我想要的所有东西

00:43:50.369 --> 00:43:54.779
喜欢发生在一个线程中，除了我会

00:43:52.859 --> 00:43:56.700
喜欢同时为所有

00:43:54.779 --> 00:43:59.550
游戏或许多类似的游戏

00:43:56.700 --> 00:44:01.859
一旦我有可能会超出范围

00:43:59.550 --> 00:44:04.050
数据但是我有几件事

00:44:01.859 --> 00:44:06.510
我喜欢同时做

00:44:04.050 --> 00:44:08.099
想要将结果保存到文件

00:44:06.510 --> 00:44:09.810
这将是一个IO 

00:44:08.099 --> 00:44:11.609
比我想要的一切都要慢

00:44:09.810 --> 00:44:13.500
只需确定每个游戏的得分

00:44:11.609 --> 00:44:15.450
我想弄清楚哪个游戏玩过

00:44:13.500 --> 00:44:17.430
总分最高，我想

00:44:15.450 --> 00:44:19.410
将它们全部写入控制台

00:44:17.430 --> 00:44:21.000
游戏得分最高的游戏

00:44:19.410 --> 00:44:23.550
最大分数，所有这些都在于

00:44:21.000 --> 00:44:24.859
其他回购向您出售，所以这里是

00:44:23.550 --> 00:44:27.720
基本思想

00:44:24.859 --> 00:44:30.060
这是在单独的存储库中

00:44:27.720 --> 00:44:34.500
我把这个变大，我得到这个

00:44:30.060 --> 00:44:38.040
游戏在这里，这个主意是我的方法

00:44:34.500 --> 00:44:40.770
纸质游戏，我创造了美好的未来

00:44:38.040 --> 00:44:43.770
与供应异步获取游戏

00:44:40.770 --> 00:44:45.180
链接，所以我写了我自己的供应商， 

00:44:43.770 --> 00:44:47.280
这是你看不到的所有东西

00:44:45.180 --> 00:44:49.380
时间是你实际上要上一堂课

00:44:47.280 --> 00:44:51.119
在供应商接口I上实施

00:44:49.380 --> 00:44:53.130
不想为此做一个lambda 

00:44:51.119 --> 00:44:54.240
我要进入某种状态

00:44:53.130 --> 00:44:56.130
基本位置

00:44:54.240 --> 00:44:58.050
有我的当地日期和

00:44:56.130 --> 00:44:59.820
天，我要去做三天

00:44:58.050 --> 00:45:01.770
 Jabba 9使得此操作更容易的原因是

00:44:59.820 --> 00:45:05.000
您实际上可以在

00:45:01.770 --> 00:45:08.760
现在范围，而您不能使用Java 8 

00:45:05.000 --> 00:45:10.500
这实际上是我的

00:45:08.760 --> 00:45:12.750
计算很好，让我从这里开始

00:45:10.500 --> 00:45:15.450
再次得到将要遍历

00:45:12.750 --> 00:45:18.540
每一天的日期

00:45:15.450 --> 00:45:21.060
日期获取该页面上的链接，然后

00:45:18.540 --> 00:45:22.770
如果我有一个空列表，我会把

00:45:21.060 --> 00:45:24.810
空流，否则我将放入

00:45:22.770 --> 00:45:27.690
流列表，这就是为什么我使用

00:45:24.810 --> 00:45:31.710
平面图，这将使我整体上

00:45:27.690 --> 00:45:33.569
我们的游戏时长列表，所以我

00:45:31.710 --> 00:45:34.980
将它们收集到列表中，这就是全部

00:45:33.569 --> 00:45:37.680
用LJ汤，这就是为什么我不能

00:45:34.980 --> 00:45:40.829
想到这就是全部用J汤

00:45:37.680 --> 00:45:43.619
好的HTTP去找到那些链接，然后

00:45:40.829 --> 00:45:47.880
好吧，这是第一步，然后

00:45:43.619 --> 00:45:51.210
接下来的事情是我想找回盒子

00:45:47.880 --> 00:45:54.450
分数很抱歉那是在这里

00:45:51.210 --> 00:45:57.690
因此提供异步，然后应用此框

00:45:54.450 --> 00:45:59.910
得分猎犬，这个家伙要

00:45:57.690 --> 00:46:02.460
再次实现功能并使用

00:45:59.910 --> 00:46:04.200
 Google与客户的关系

00:46:02.460 --> 00:46:06.540
在这里，可能更容易看到它

00:46:04.200 --> 00:46:09.090
在这里并行，因为为什么不

00:46:06.540 --> 00:46:12.870
映射每个

00:46:09.090 --> 00:46:15.120
链接到获取实际盒子的链接

00:46:12.870 --> 00:46:16.500
现在得分，这是

00:46:15.120 --> 00:46:18.750
有趣的部分发生或一个

00:46:16.500 --> 00:46:21.450
有趣的部分900毫升，但我会

00:46:18.750 --> 00:46:24.030
很快完成它的想法现在是

00:46:21.450 --> 00:46:26.100
我可以放雨了，如果

00:46:24.030 --> 00:46:28.680
如果发生这种情况，则没有盒子得分， 

00:46:26.100 --> 00:46:30.600
没有办法知道，所以我要去

00:46:28.680 --> 00:46:32.730
用可选点过滤它们是

00:46:30.600 --> 00:46:35.280
存在于该游戏模式中以产生

00:46:32.730 --> 00:46:37.350
我返回一个可选的机制

00:46:35.280 --> 00:46:38.790
有一个降雨C，所以如果有一个

00:46:37.350 --> 00:46:40.890
如果没有的话，请放雨

00:46:38.790 --> 00:46:42.840
发现我会返回一个空的否则我

00:46:40.890 --> 00:46:45.600
确实有可为空的东西，我让他们回来了， 

00:46:42.840 --> 00:46:48.440
然后打电话给get，然后把它们变成

00:46:45.600 --> 00:46:52.260
这里的列表和其他的比较简单

00:46:48.440 --> 00:46:54.450
其他人我要保存

00:46:52.260 --> 00:46:58.860
结果列表，这只是一种方法

00:46:54.450 --> 00:47:00.840
在这里为每个保存结果

00:46:58.860 --> 00:47:03.660
将归档，我正在写出如何使用

00:47:00.840 --> 00:47:05.280
吉桑这样做，然后有

00:47:03.660 --> 00:47:07.710
如果出问题了

00:47:05.280 --> 00:47:09.780
这是获得最高分的人

00:47:07.710 --> 00:47:12.000
并获得未来以及所有这些东西

00:47:09.780 --> 00:47:13.860
一切都在这里，我和他们一起加入

00:47:12.000 --> 00:47:19.770
然后将它们打印出来，如果我执行

00:47:13.860 --> 00:47:22.380
这个在这里让我在这里运行这个执行

00:47:19.770 --> 00:47:25.380
而且您会发现，如果我们

00:47:22.380 --> 00:47:27.510
 Wi-Fi在这里弹出，我选择

00:47:25.380 --> 00:47:29.550
一场有一场大雨的比赛

00:47:27.510 --> 00:47:31.890
不存在，其余的

00:47:29.550 --> 00:47:33.960
你去那里那里有

00:47:31.890 --> 00:47:35.280
一切都在重新计算

00:47:33.960 --> 00:47:38.370
这就是代码中的全部

00:47:35.280 --> 00:47:41.280
仓库，以便总结

00:47:38.370 --> 00:47:43.710
并行很容易使用completable 

00:47:41.280 --> 00:47:45.360
期货很容易从中获利

00:47:43.710 --> 00:47:46.260
这是你的时间会在哪里

00:47:45.360 --> 00:47:48.480
实际花费

00:47:46.260 --> 00:47:50.130
并行流委托给公共

00:47:48.480 --> 00:47:52.290
 fork / join池，但是您可以更改

00:47:50.130 --> 00:47:54.360
该库的可完成未来规模

00:47:52.290 --> 00:47:56.310
让您协调多个

00:47:54.360 --> 00:47:59.310
有很多可用的方法

00:47:56.310 --> 00:48:00.480
做协调，如果你，我会出去玩

00:47:59.310 --> 00:48:03.290
有任何疑问，否则谢谢

00:48:00.480 --> 00:48:05.350
你非常来

00:48:03.290 --> 00:48:05.350
您

