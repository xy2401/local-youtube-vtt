WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.200 --> 00:00:07.529
好吧，让我们开始吧，欢迎来到

00:00:06.120 --> 00:00:09.030
重构功能会议

00:00:07.529 --> 00:00:11.130
风格，我叫Venkat Subramanyam 

00:00:09.030 --> 00:00:12.990
我们将要谈论一些

00:00:11.130 --> 00:00:14.759
实例和红外线样式，然后

00:00:12.990 --> 00:00:16.710
努力实现功能

00:00:14.759 --> 00:00:18.330
风格，我会谈一些

00:00:16.710 --> 00:00:20.220
这样做的动机

00:00:18.330 --> 00:00:21.570
我们需要关注的事情

00:00:20.220 --> 00:00:23.279
然后我们进入一些例子

00:00:21.570 --> 00:00:25.800
开始看一些如何

00:00:23.279 --> 00:00:27.300
我们可以做到这一点，并一路走来

00:00:25.800 --> 00:00:30.390
谈论我们可以采取的一些方法

00:00:27.300 --> 00:00:32.790
所以要考虑的一件事是

00:00:30.390 --> 00:00:34.440
实际上大多数主流语言

00:00:32.790 --> 00:00:36.300
我们已经拥有的主流语言

00:00:34.440 --> 00:00:38.460
在过去20至30年中一直在使用

00:00:36.300 --> 00:00:40.170
一直在倡导命令式的

00:00:38.460 --> 00:00:42.300
命令式编程

00:00:40.170 --> 00:00:44.789
编程我们谈到了怎么做

00:00:42.300 --> 00:00:47.609
但我们也继续编写代码以

00:00:44.789 --> 00:00:50.309
表达如何做到这样势在必行

00:00:47.609 --> 00:00:51.749
专注于什么以及如何以及它

00:00:50.309 --> 00:00:53.100
真正陷入困境的房子

00:00:51.749 --> 00:00:56.489
因为这给我们带来麻烦

00:00:53.100 --> 00:00:59.039
它与意外复杂性有关

00:00:56.489 --> 00:01:01.739
我们关注的声明式编程

00:00:59.039 --> 00:01:04.140
说什么该做什么，但不那么反复

00:01:01.739 --> 00:01:06.540
如何做好功能风格

00:01:04.140 --> 00:01:08.580
本质上是声明式的

00:01:06.540 --> 00:01:10.110
并非所有的声明性代码都起作用

00:01:08.580 --> 00:01:11.910
但是所有功能代码实际上都是

00:01:10.110 --> 00:01:13.560
说明性的是最

00:01:11.910 --> 00:01:16.110
编程和

00:01:13.560 --> 00:01:18.750
功能风格是我们可以专注于

00:01:16.110 --> 00:01:21.210
疣，让底层库

00:01:18.750 --> 00:01:23.130
照顾如何实际去做，但是

00:01:21.210 --> 00:01:24.900
 Java 8的挑战之一是

00:01:23.130 --> 00:01:28.050
不像以前的Java版本

00:01:24.900 --> 00:01:30.180
 Java 8与语法更改无关

00:01:28.050 --> 00:01:31.950
这实际上是一种范式转变

00:01:30.180 --> 00:01:34.290
要求我们以不同的方式思考

00:01:31.950 --> 00:01:36.390
和程序完全不同，我会

00:01:34.290 --> 00:01:38.520
老实说我花了几个

00:01:36.390 --> 00:01:40.260
数十年编程势在必行

00:01:38.520 --> 00:01:42.210
我可以告诉你，我度过了我的青春

00:01:40.260 --> 00:01:43.380
在一段时期内编程

00:01:42.210 --> 00:01:45.780
告诉你我过得很糟糕

00:01:43.380 --> 00:01:47.280
童年，现在我正试图恢复

00:01:45.780 --> 00:01:49.170
从那开始编程

00:01:47.280 --> 00:01:51.720
功能风格，这是不自然的

00:01:49.170 --> 00:01:54.030
对我来说，我必须加倍努力

00:01:51.720 --> 00:01:56.040
以功能风格思考，我有

00:01:54.030 --> 00:01:58.620
说我大概是50％ 

00:01:56.040 --> 00:02:00.810
如果您遇到问题，现在就进入它

00:01:58.620 --> 00:02:02.940
我大概有50％的时间在想我

00:02:00.810 --> 00:02:04.800
从功能上来说，我还需要50％ 

00:02:02.940 --> 00:02:06.930
奋斗中最有趣的事情之一

00:02:04.800 --> 00:02:09.149
体验飞行时间不长

00:02:06.930 --> 00:02:10.950
以前是穿越大西洋的

00:02:09.149 --> 00:02:12.420
我花了大约九个小时的时间

00:02:10.950 --> 00:02:13.920
从问题开始

00:02:12.420 --> 00:02:16.379
飞行开始并挣扎

00:02:13.920 --> 00:02:16.930
用了七个小时试图写

00:02:16.379 --> 00:02:18.370
在功能上

00:02:16.930 --> 00:02:20.260
风格我会告诉你的

00:02:18.370 --> 00:02:22.329
您可以享受的机上娱乐

00:02:20.260 --> 00:02:23.709
然后当我做完那件事时

00:02:22.329 --> 00:02:26.290
很好，为什么我有这么多

00:02:23.709 --> 00:02:28.780
这样做很困难，因为事后看来

00:02:26.290 --> 00:02:31.030
当我在解决方案上找到20/20 

00:02:28.780 --> 00:02:33.129
七个小时结束了，为什么

00:02:31.030 --> 00:02:35.079
我有那么多麻烦吗？ 

00:02:33.129 --> 00:02:37.420
我真的很难受

00:02:35.079 --> 00:02:38.409
我的舒适水平到底是谁

00:02:37.420 --> 00:02:40.090
让我很难思考

00:02:38.409 --> 00:02:42.489
不一样，所以这就是我想要的

00:02:40.090 --> 00:02:44.230
专注于范式转变

00:02:42.489 --> 00:02:45.939
可能以一种可以

00:02:44.230 --> 00:02:47.950
让事情变得更容易

00:02:45.939 --> 00:02:49.900
当我们考虑转向功能

00:02:47.950 --> 00:02:52.480
我不建议服用

00:02:49.900 --> 00:02:53.650
现有代码并将其全部更改为

00:02:52.480 --> 00:02:54.159
我想要使​​功能风格

00:02:53.650 --> 00:02:56.709
非常清楚

00:02:54.159 --> 00:02:59.139
我相信创造价值，所以有

00:02:56.709 --> 00:03:01.120
好的代码工作就像

00:02:59.139 --> 00:03:03.129
现在的样子，但是当你来的时候

00:03:01.120 --> 00:03:05.889
修正错误以增强功能

00:03:03.129 --> 00:03:08.019
或者您正在尝试改造主要部件

00:03:05.889 --> 00:03:10.900
对我们来说这是一个非常美好的时光

00:03:08.019 --> 00:03:13.060
重新访问并可能更改代码，但是

00:03:10.900 --> 00:03:14.769
当我们坐下来编写代码时，我们也可以

00:03:13.060 --> 00:03:17.530
清楚地写得很快

00:03:14.769 --> 00:03:19.540
命令性的新代码，但也许

00:03:17.530 --> 00:03:21.489
转换它的功能风格

00:03:19.540 --> 00:03:22.900
和我们一样，是一个非常好的学习方式

00:03:21.489 --> 00:03:24.400
变得非常自在

00:03:22.900 --> 00:03:26.409
编程，让我们进入一些

00:03:24.400 --> 00:03:28.540
练习和玩一些例子

00:03:26.409 --> 00:03:30.430
我想从头开始

00:03:28.540 --> 00:03:32.560
例子我将专注于五个

00:03:30.430 --> 00:03:34.810
本演示文稿中的不同示例

00:03:32.560 --> 00:03:36.639
给定时间，让我们看看我们能做什么

00:03:34.810 --> 00:03:38.799
首先我要从

00:03:36.639 --> 00:03:40.540
势在必行的编程代码

00:03:38.799 --> 00:03:42.430
首先我提到

00:03:40.540 --> 00:03:44.560
命令式的风格是我们说什么

00:03:42.430 --> 00:03:45.939
做，但我们也说如何做，让我们

00:03:44.560 --> 00:03:46.659
快速看一个例子

00:03:45.939 --> 00:03:48.310
这里

00:03:46.659 --> 00:03:51.400
我在这里有一个小功能

00:03:48.310 --> 00:03:53.470
遍历并讲述的主要

00:03:51.400 --> 00:03:55.989
数字1到7是否为

00:03:53.470 --> 00:03:57.609
素数还是不好，他们说永不

00:03:55.989 --> 00:03:59.530
重构效果不佳的代码

00:03:57.609 --> 00:04:01.239
这笔款项似乎运作理想

00:03:59.530 --> 00:04:02.500
会有自动化测试，但是

00:04:01.239 --> 00:04:04.419
这种情况足以满足

00:04:02.500 --> 00:04:06.250
我们当然是在这种情况下

00:04:04.419 --> 00:04:08.889
它正在工作并给我们结果

00:04:06.250 --> 00:04:10.810
但这是东方的主要方法

00:04:08.889 --> 00:04:12.729
尝试对这种方法非常聪明

00:04:10.810 --> 00:04:15.579
我不是想使其变得非常有效

00:04:12.729 --> 00:04:17.139
我只是说一个非常简单的循环4 

00:04:15.579 --> 00:04:19.840
然后我当然循环

00:04:17.139 --> 00:04:22.780
 for循环询问数字是否可被整数整除

00:04:19.840 --> 00:04:24.520
该数字范围，如果可以的话

00:04:22.780 --> 00:04:26.710
可能的变量，然后我退出

00:04:24.520 --> 00:04:28.840
现在，如果你看这个，这是一个

00:04:26.710 --> 00:04:30.870
非常让人想起我们做的很多事情

00:04:28.840 --> 00:04:31.800
乡里有一些椅子

00:04:30.870 --> 00:04:33.449
对，如果你只是想穿过

00:04:31.800 --> 00:04:35.070
前台请随时这样做

00:04:33.449 --> 00:04:37.770
前面有很多座位

00:04:35.070 --> 00:04:39.060
在这里，如果旁边有座位

00:04:37.770 --> 00:04:40.290
你只要举起手就更容易了

00:04:39.060 --> 00:04:42.449
人们可以-很好，非常感谢

00:04:40.290 --> 00:04:44.100
非常感谢，好吧，让我们来看一下

00:04:42.449 --> 00:04:46.860
这段代码一秒钟，看看它是什么

00:04:44.100 --> 00:04:48.810
说真的，我有一个挑战

00:04:46.860 --> 00:04:53.040
你星期一回去上班时

00:04:48.810 --> 00:04:56.310
为我做这个，为我们做些什么

00:04:53.040 --> 00:04:58.710
您的源代码，并害怕多少

00:04:56.310 --> 00:05:00.120
我们使用的四个循环就像有人

00:04:58.710 --> 00:05:01.830
敲门II打开门

00:05:00.120 --> 00:05:03.419
你问有一个人用锤子

00:05:01.830 --> 00:05:05.760
他在那儿，因为他说我在这里

00:05:03.419 --> 00:05:07.590
修理你的厨房，你说不是吗

00:05:05.760 --> 00:05:09.419
你会不会使用任何他说的工具

00:05:07.590 --> 00:05:11.280
我有锤子，我不需要任何其他东西

00:05:09.419 --> 00:05:12.870
可能会让您发臭的工具

00:05:11.280 --> 00:05:14.310
这个家伙进去出去叫警察

00:05:12.870 --> 00:05:16.290
呆在家里不安全了

00:05:14.310 --> 00:05:17.610
好吧，这就是我们一直在做的

00:05:16.290 --> 00:05:20.130
一直用这个锤子

00:05:17.610 --> 00:05:21.690
我们所做的一切，而且很疯狂

00:05:20.130 --> 00:05:23.700
一切都是为了偶尔

00:05:21.690 --> 00:05:25.710
我们使用的while循环

00:05:23.700 --> 00:05:27.810
案例我们做了什么，我们遍历了

00:05:25.710 --> 00:05:30.210
然后检查条件，然后设置

00:05:27.810 --> 00:05:32.430
布尔值是可见的，并且为真

00:05:30.210 --> 00:05:33.870
然后我们必须控制循环

00:05:32.430 --> 00:05:36.419
让我们用英语写这是什么

00:05:33.870 --> 00:05:37.620
真的很好，为什么我们要投入

00:05:36.419 --> 00:05:39.780
用英语我把它放进去的原因

00:05:37.620 --> 00:05:42.120
英语真的让我们思考

00:05:39.780 --> 00:05:44.039
关于我们在做什么，那可以

00:05:42.120 --> 00:05:46.020
帮助我们把握精髓

00:05:44.039 --> 00:05:47.970
麦汁，然后我们可以寻找方法

00:05:46.020 --> 00:05:50.220
实际上将英语翻译成代码

00:05:47.970 --> 00:05:53.099
所以让我们看一下我们在做什么

00:05:50.220 --> 00:05:56.669
我们要查找的范围数

00:05:53.099 --> 00:05:59.250
数字，因此范围内没有值

00:05:56.669 --> 00:06:00.780
除以给定的数字，所以这是一个

00:05:59.250 --> 00:06:02.310
实际上很少的配方

00:06:00.780 --> 00:06:04.080
帮助我们考虑一下

00:06:02.310 --> 00:06:06.570
更好，让我们尝试一下

00:06:04.080 --> 00:06:08.520
我们如何在更多内容中重写此代码

00:06:06.570 --> 00:06:10.950
一种实用的风格，所以我要开始

00:06:08.520 --> 00:06:14.130
在这种情况下导入Java dot util 

00:06:10.950 --> 00:06:16.800
假设飞镖梦见了星星，而我

00:06:14.130 --> 00:06:18.960
说数字范围很好这个词

00:06:16.800 --> 00:06:21.720
范围立即促使我们思考

00:06:18.960 --> 00:06:24.389
关于一个int流，所以我要去

00:06:21.720 --> 00:06:26.970
向前并称其为流中

00:06:24.389 --> 00:06:30.630
我们会说返回数大于

00:06:26.970 --> 00:06:33.510
一和成流点范围从

00:06:30.630 --> 00:06:35.430
给定数字两个，请注意

00:06:33.510 --> 00:06:37.320
 for循环从两个列表变为一个列表， 

00:06:35.430 --> 00:06:39.810
确切的数字范围

00:06:37.320 --> 00:06:42.000
它也从第二开始

00:06:39.810 --> 00:06:42.770
的数量减去闭合范围的一

00:06:42.000 --> 00:06:44.930
会包括

00:06:42.770 --> 00:06:46.460
数字，但范围不大，所以我们有

00:06:44.930 --> 00:06:49.160
数字范围让我们再次回到

00:06:46.460 --> 00:06:52.069
我说英语给定一个数字

00:06:49.160 --> 00:06:53.900
给定范围内的已知数除

00:06:52.069 --> 00:06:56.419
换句话说，给定的数字很好

00:06:53.900 --> 00:06:58.909
没有什么比我们的除数更合适

00:06:56.419 --> 00:07:01.490
我们正在寻找的标准和方法

00:06:58.909 --> 00:07:04.280
因为这里叫做不匹配，然后

00:07:01.490 --> 00:07:07.159
给定范围Mart中的数字

00:07:04.280 --> 00:07:10.099
我感兴趣的等于

00:07:07.159 --> 00:07:14.120
零，以便表中的代码

00:07:10.099 --> 00:07:16.370
看到这里转化为很小

00:07:14.120 --> 00:07:18.530
我在底部提到的一段代码

00:07:16.370 --> 00:07:21.919
我们一直在用锤子

00:07:18.530 --> 00:07:24.650
过去很多，但是这个正在使用

00:07:21.919 --> 00:07:26.750
非常专业的方法

00:07:24.650 --> 00:07:28.250
方法小工具，就像您打了一个

00:07:26.750 --> 00:07:29.810
再次敲门，您打开

00:07:28.250 --> 00:07:31.580
门上有一个有小书包的家伙， 

00:07:29.810 --> 00:07:33.710
你问他他在那里要修理什么

00:07:31.580 --> 00:07:34.909
厨房，他放好工具，你

00:07:33.710 --> 00:07:36.560
说哇，看看有一个真正的

00:07:34.909 --> 00:07:38.690
扳手有一把小螺丝刀

00:07:36.560 --> 00:07:40.789
有一些凿子

00:07:38.690 --> 00:07:43.550
你问他交易权的工具

00:07:40.789 --> 00:07:45.199
你会用所有这些工具吗

00:07:43.550 --> 00:07:47.360
说使用所有工具的人是

00:07:45.199 --> 00:07:49.190
叫顾问不，我要用

00:07:47.360 --> 00:07:51.020
只有对项目有意义的

00:07:49.190 --> 00:07:52.789
关键是我们要使用

00:07:51.020 --> 00:07:54.740
这些小小的专业工具

00:07:52.789 --> 00:07:56.360
我们的工作完成了，这就是

00:07:54.740 --> 00:07:58.969
范围函数和不匹配

00:07:56.360 --> 00:08:00.500
功能将像您一样为我们做

00:07:58.969 --> 00:08:02.900
可以看到该代码的结果是

00:08:00.500 --> 00:08:05.779
和以前完全一样，但是我们

00:08:02.900 --> 00:08:07.849
是我们翻译了蓬松的代码吗

00:08:05.779 --> 00:08:10.370
在我们面前变得非常

00:08:07.849 --> 00:08:12.740
表现力很强我不是在寻找

00:08:10.370 --> 00:08:15.259
短的代码不是

00:08:12.740 --> 00:08:18.349
客观的我想要的是

00:08:15.259 --> 00:08:21.020
简洁但又很有表现力的是

00:08:18.349 --> 00:08:22.789
你少花钱之后我到底在想什么

00:08:21.020 --> 00:08:24.680
努力阅读此代码并理解

00:08:22.789 --> 00:08:26.870
一旦我们知道范围和不匹配

00:08:24.680 --> 00:08:28.669
当然意味着很多

00:08:26.870 --> 00:08:31.039
更容易使用，所以这是一个

00:08:28.669 --> 00:08:33.500
我们如何使用其中一些示例

00:08:31.039 --> 00:08:35.029
创建一个小功能的想法

00:08:33.500 --> 00:08:37.550
可以告诉我们数字是否为质数

00:08:35.029 --> 00:08:39.349
但更重要的是要真正遍历

00:08:37.550 --> 00:08:41.839
取值范围并得到结果

00:08:39.349 --> 00:08:44.000
正在寻找，以减少噪音

00:08:41.839 --> 00:08:46.010
 garbetts变量是可除的

00:08:44.000 --> 00:08:48.260
我们不介绍的垃圾变量

00:08:46.010 --> 00:08:50.060
这里，当然还有不必要的变量

00:08:48.260 --> 00:08:51.199
我们使用了高阶函数

00:08:50.060 --> 00:08:53.600
将函数传递给函数

00:08:51.199 --> 00:08:56.000
这是无与伦比的功能

00:08:53.600 --> 00:08:56.960
真的帮助了我们很多，让我们

00:08:56.000 --> 00:09:00.290
继续下一个

00:08:56.960 --> 00:09:01.700
例子再次从命令，但

00:09:00.290 --> 00:09:04.130
在这种情况下，我们要去

00:09:01.700 --> 00:09:07.550
功能代码的风格，我想

00:09:04.130 --> 00:09:10.520
知道我的文字中包含多少行

00:09:07.550 --> 00:09:12.500
现在一定要这样做

00:09:10.520 --> 00:09:14.990
我们将如何在其中编写代码

00:09:12.500 --> 00:09:16.760
传统的Java让我们看一下

00:09:14.990 --> 00:09:18.890
在这里的一个例子，所以我有一点

00:09:16.760 --> 00:09:21.410
您可以在这里看到的主要功能和

00:09:18.890 --> 00:09:23.779
该主要功能启动并首先

00:09:21.410 --> 00:09:26.240
所有这些都会打开一个bufferedreader， 

00:09:23.779 --> 00:09:29.810
如您所见，连接到文件阅读器

00:09:26.240 --> 00:09:31.550
它正在打开我的ADC主机文件

00:09:29.810 --> 00:09:33.740
有兴趣寻找这个词

00:09:31.550 --> 00:09:36.800
本地主机，我想知道多少

00:09:33.740 --> 00:09:39.050
行包含单词localhost，那么

00:09:36.800 --> 00:09:41.540
我在这里做什么我首先创建一个

00:09:39.050 --> 00:09:44.300
行并将其设置为null，我们都知道

00:09:41.540 --> 00:09:46.850
那空是一种气味，然后我们去

00:09:44.300 --> 00:09:49.190
前面说，而线等于

00:09:46.850 --> 00:09:50.120
 bufferedreader点读取行不是

00:09:49.190 --> 00:09:52.520
等于null 

00:09:50.120 --> 00:09:54.589
像这样的代码我们不应该显示

00:09:52.520 --> 00:09:56.750
孩子们，因为他们一刻

00:09:54.589 --> 00:09:58.339
看着他们，他们说我永远不会

00:09:56.750 --> 00:09:59.450
再次进入这个行业，他们会

00:09:58.339 --> 00:10:01.610
宁愿有其他事情

00:09:59.450 --> 00:10:03.470
会计师比做这项权利，所以

00:10:01.610 --> 00:10:05.390
重点确实是

00:10:03.470 --> 00:10:06.890
无论如何都要当会计师，但是我

00:10:05.390 --> 00:10:08.990
宁愿写得清楚， 

00:10:06.890 --> 00:10:11.900
简洁的代码，所以重点在此

00:10:08.990 --> 00:10:13.700
情况是我真的不想真的

00:10:11.900 --> 00:10:16.100
编写代码很笨拙，所以

00:10:13.700 --> 00:10:18.350
当务之急和嘈杂，然后我们该怎么办

00:10:16.100 --> 00:10:20.029
我们检查行是否包含

00:10:18.350 --> 00:10:22.160
特定的词，然后我们递增

00:10:20.029 --> 00:10:24.589
再次计数，然后我们继续循环

00:10:22.160 --> 00:10:27.370
通过它，很多仪式在

00:10:24.589 --> 00:10:30.020
我们的代码，最后完成后，我们

00:10:27.370 --> 00:10:32.839
宣布获胜并举报

00:10:30.020 --> 00:10:35.450
包含多次发生

00:10:32.839 --> 00:10:37.580
文件很好，那么我们如何真正工作

00:10:35.450 --> 00:10:38.930
通过这个非常不同的是

00:10:37.580 --> 00:10:41.120
真正让我兴奋的一件事

00:10:38.930 --> 00:10:43.490
关于Java八，他们只是没有

00:10:41.120 --> 00:10:45.880
交付lambda，然后走开

00:10:43.490 --> 00:10:49.130
采取了非常果断的方法

00:10:45.880 --> 00:10:51.020
增强JDK以改善所有

00:10:49.130 --> 00:10:53.089
可能确实是不同的方法

00:10:51.020 --> 00:10:54.920
本质上是功能性的，让我们看看

00:10:53.089 --> 00:10:57.589
我现在要在这里做

00:10:54.920 --> 00:10:59.240
这段代码就在这里，让我们继续

00:10:57.589 --> 00:11:00.800
然后将此代码注释掉

00:10:59.240 --> 00:11:03.260
分钟，以便我们实际进行重构

00:11:00.800 --> 00:11:05.480
我称这个变量为count 

00:11:03.260 --> 00:11:07.670
所以我要说的是

00:11:05.480 --> 00:11:09.740
等于但我将如何找到

00:11:07.670 --> 00:11:11.930
算是很好

00:11:09.740 --> 00:11:15.800
我要在这里做的是我要去

00:11:11.930 --> 00:11:18.350
并导入一个Java dot n io dart 

00:11:15.800 --> 00:11:20.810
文件，然后在这种情况下，我将使用

00:11:18.350 --> 00:11:22.100
属于文件类的类

00:11:20.810 --> 00:11:23.930
事实上，让我们带一点儿孩子

00:11:22.100 --> 00:11:25.580
采取步骤，请原谅我

00:11:23.930 --> 00:11:27.500
继续并先运行这个

00:11:25.580 --> 00:11:29.120
尝试修改它，我会回到

00:11:27.500 --> 00:11:31.040
只需一秒钟，然后当然

00:11:29.120 --> 00:11:32.420
当我回去运行它时，我们确实想要

00:11:31.040 --> 00:11:34.730
确保结果实际上是

00:11:32.420 --> 00:11:36.380
它说我想发生过三次

00:11:34.730 --> 00:11:39.590
完成此操作后得到相同的结果

00:11:36.380 --> 00:11:41.450
太好了，让我们回到这里

00:11:39.590 --> 00:11:43.430
注释掉这段代码

00:11:41.450 --> 00:11:45.590
第二，让我们带一个孩子

00:11:43.430 --> 00:11:48.230
迈向这一步，让我们开始吧

00:11:45.590 --> 00:11:51.530
提前并引入Java点IO点文件

00:11:48.230 --> 00:11:55.220
点星，在这种情况下，让我们继续

00:11:51.530 --> 00:11:58.100
然后在这里说文件然后飞镖

00:11:55.220 --> 00:12:01.190
行，然后这将是

00:11:58.100 --> 00:12:03.590
线法，这需要一条路径

00:12:01.190 --> 00:12:05.330
我对通往什么的道路感兴趣

00:12:03.590 --> 00:12:06.920
是我感兴趣的文件

00:12:05.330 --> 00:12:08.780
这就是我感兴趣的道路

00:12:06.920 --> 00:12:11.360
我将在此处使用path变量

00:12:08.780 --> 00:12:13.430
所以我要请你给我

00:12:11.360 --> 00:12:16.040
该特定代码的路径就是

00:12:13.430 --> 00:12:17.810
我要的是这样的开始

00:12:16.040 --> 00:12:19.100
真正给我们带来了什么？ 

00:12:17.810 --> 00:12:21.800
快看看这是什么

00:12:19.100 --> 00:12:24.140
函数返回给我们，谢天谢地

00:12:21.800 --> 00:12:26.930
这是在做什么

00:12:24.140 --> 00:12:29.450
我们流真的很好，所以现在

00:12:26.930 --> 00:12:31.010
我们手边有一条小溪，我们可以

00:12:29.450 --> 00:12:33.140
使用流API进行进一步操作

00:12:31.010 --> 00:12:35.360
处理，所以我现在要做的是

00:12:33.140 --> 00:12:38.840
现在我已经将所有行

00:12:35.360 --> 00:12:40.910
我会在这里说过滤器

00:12:38.840 --> 00:12:41.420
我会说给定一条线

00:12:40.910 --> 00:12:43.850
我

00:12:41.420 --> 00:12:46.430
假设线点正好包含

00:12:43.850 --> 00:12:48.500
我们在这里所做的代码，但我们削减了

00:12:46.430 --> 00:12:50.720
通过所有其他的绒毛现在

00:12:48.500 --> 00:12:53.300
然后我们要求搜索词

00:12:50.720 --> 00:12:55.820
感兴趣，这真的给了我们

00:12:53.300 --> 00:12:58.250
符合的所有行数

00:12:55.820 --> 00:13:00.380
标准，然后我们将其设置为一个计数

00:12:58.250 --> 00:13:02.990
然后我们当然可以简单地说

00:13:00.380 --> 00:13:05.420
多头账户等于，然后我们可以

00:13:02.990 --> 00:13:07.640
马上将其设置到该变量中

00:13:05.420 --> 00:13:10.190
蝙蝠在那里，然后当我们

00:13:07.640 --> 00:13:12.560
现在运行此代码，我们可以看到它

00:13:10.190 --> 00:13:14.060
给我们和以前一样的结果，但是

00:13:12.560 --> 00:13:16.790
我们不必付出太多的努力

00:13:14.060 --> 00:13:19.250
为此，狮子的文件方法

00:13:16.790 --> 00:13:21.590
确实给了我们很好的能力

00:13:19.250 --> 00:13:23.000
得到一个流并对其进行处理

00:13:21.590 --> 00:13:25.460
这样我们可以再次

00:13:23.000 --> 00:13:27.230
代码中所有的仪式，我们

00:13:25.460 --> 00:13:29.480
可以使用功能性的编码方式

00:13:27.230 --> 00:13:31.700
这样行就给我们一个流， 

00:13:29.480 --> 00:13:33.410
给定流，我们得到所有的线条

00:13:31.700 --> 00:13:35.810
符合这个标准的

00:13:33.410 --> 00:13:37.520
标准是，最后我们做了一个计数

00:13:35.810 --> 00:13:39.260
并从中获得结果

00:13:37.520 --> 00:13:41.540
这正是我们所做的

00:13:39.260 --> 00:13:43.310
例子，这是另一种看待方式

00:13:41.540 --> 00:13:45.560
所以我们在里面看到了修女比赛

00:13:43.310 --> 00:13:48.110
流，我们正在看文件

00:13:45.560 --> 00:13:50.780
文件中的行

00:13:48.110 --> 00:13:52.790
上课本身，这些都在帮助

00:13:50.780 --> 00:13:53.720
我们把工作做好一点

00:13:52.790 --> 00:13:56.240
更有效地

00:13:53.720 --> 00:13:57.740
再次没有明确的变量

00:13:56.240 --> 00:14:00.980
使用流和过滤方法

00:13:57.740 --> 00:14:03.230
在这种情况下完成我们的工作，让我们

00:14:00.980 --> 00:14:05.360
现在可以走得更远

00:14:03.230 --> 00:14:07.220
当我们尝试做一点时真的很丑

00:14:05.360 --> 00:14:09.560
我们要看的更复杂的东西

00:14:07.220 --> 00:14:11.840
用固定的冗长代码来做某事

00:14:09.560 --> 00:14:14.090
真的很简单，这是当你意识到

00:14:11.840 --> 00:14:16.310
问题很简单，但是解决方法

00:14:14.090 --> 00:14:17.720
变得过于复杂，那时候

00:14:16.310 --> 00:14:19.760
你知道我们走错了方向

00:14:17.720 --> 00:14:21.410
您不想要解决方案的方向

00:14:19.760 --> 00:14:23.300
比问题真正复杂

00:14:21.410 --> 00:14:25.160
我们认为那是偶然的

00:14:23.300 --> 00:14:27.470
复杂性让我们看一个例子

00:14:25.160 --> 00:14:29.920
看看这到底意味着什么，所以我

00:14:27.470 --> 00:14:33.020
这些有一些主要的

00:14:29.920 --> 00:14:35.000
您在这里看到的分数

00:14:33.020 --> 00:14:38.150
本课程正在做的是

00:14:35.000 --> 00:14:39.980
一堆名字和分数值变成

00:14:38.150 --> 00:14:42.260
这张地图以卡人的名字命名

00:14:39.980 --> 00:14:44.870
可能和分数值，但我

00:14:42.260 --> 00:14:48.080
真正想做的是打印出谁拥有

00:14:44.870 --> 00:14:49.490
所有的人都有共同的分数，所以让我们

00:14:48.080 --> 00:14:51.589
继续并运行此代码以采取

00:14:49.490 --> 00:14:54.560
看它，汤姆和南希的得分为

00:14:51.589 --> 00:14:57.470
 11杰克是12岁的唯一人

00:14:54.560 --> 00:15:00.230
达拉（Darla）的尼克（Nick）和吉尔（Jill）得分为15 

00:14:57.470 --> 00:15:02.780
但问题是我们如何真正做到

00:15:00.230 --> 00:15:05.000
以命令式的风格可以

00:15:02.780 --> 00:15:08.120
想像一下我们要付出多少努力

00:15:05.000 --> 00:15:11.030
为此，您首先创建一张地图

00:15:08.120 --> 00:15:13.430
当然还有分数值和

00:15:11.030 --> 00:15:16.070
麻烦的名字列表

00:15:13.430 --> 00:15:18.470
开始就结束了，那么你得到一个

00:15:16.070 --> 00:15:21.080
分数值是否存在于地图中

00:15:18.470 --> 00:15:23.060
已经没有它不会创建一个空的

00:15:21.080 --> 00:15:24.740
列表插入空列表插入

00:15:23.060 --> 00:15:27.200
有人想这样做的名字

00:15:24.740 --> 00:15:28.520
绝对是荒谬的，但是

00:15:27.200 --> 00:15:31.459
这就是我们一直以来的代码

00:15:28.520 --> 00:15:33.410
多年写作

00:15:31.459 --> 00:15:35.100
一开始就让我们感到烦恼

00:15:33.410 --> 00:15:37.079
编写此代码

00:15:35.100 --> 00:15:39.360
非常聪明的开发人员永远不会写这个

00:15:37.079 --> 00:15:41.610
我们雇用实习生来做这些事情的代码

00:15:39.360 --> 00:15:44.009
这就是为什么这变得真正

00:15:41.610 --> 00:15:44.430
工作很乏味，而且在

00:15:44.009 --> 00:15:46.380
所有

00:15:44.430 --> 00:15:48.540
随着时间的推移做这样的事情

00:15:46.380 --> 00:15:51.360
我们可以做些什么来改善它

00:15:48.540 --> 00:15:54.660
疯狂，因为记住什么功能

00:15:51.360 --> 00:15:56.610
风格会告诉你做什么，你

00:15:54.660 --> 00:15:58.740
让底层库找出如何

00:15:56.610 --> 00:16:00.750
做到这一点，所以你可以看看所有这些

00:15:58.740 --> 00:16:03.209
我们面前的十行

00:16:00.750 --> 00:16:03.630
代码只会消失在

00:16:03.209 --> 00:16:06.240
我们的眼睛

00:16:03.630 --> 00:16:08.160
现在几秒钟​​之内，让我们开始吧

00:16:06.240 --> 00:16:11.009
回到这里这个小代码吧

00:16:08.160 --> 00:16:12.810
在这里，然后抓住整个功能

00:16:11.009 --> 00:16:14.819
评论出来，然后我们是什么

00:16:12.810 --> 00:16:17.250
要做的就是回报我们要

00:16:14.819 --> 00:16:19.470
从即将出现的分数开始

00:16:17.250 --> 00:16:21.779
作为输入，所以我们要

00:16:19.470 --> 00:16:24.089
从这里的分数开始，但是

00:16:21.779 --> 00:16:26.160
在这种情况下，我们要说的是

00:16:24.089 --> 00:16:28.740
我要简单地从

00:16:26.160 --> 00:16:31.350
这个特定的分数，然后再次

00:16:28.740 --> 00:16:33.810
要求流出来，然后我们

00:16:31.350 --> 00:16:36.060
我要去之前先问个收藏

00:16:33.810 --> 00:16:39.180
进一步进入我想花的钱

00:16:36.060 --> 00:16:40.769
几秒钟谈论一个

00:16:39.180 --> 00:16:42.750
非常重要的事情

00:16:40.769 --> 00:16:45.779
如果您还没有的话，被称为收藏家

00:16:42.750 --> 00:16:48.149
有机会我强烈推荐你

00:16:45.779 --> 00:16:50.550
与收藏家度过一个星期五晚上

00:16:48.149 --> 00:16:53.639
我保证你的夜晚会很棒

00:16:50.550 --> 00:16:56.670
你，因为收藏家是如此的富有

00:16:53.639 --> 00:16:58.949
在JDK中，我不断发现力量

00:16:56.670 --> 00:17:00.839
的收藏家一次又一次

00:16:58.949 --> 00:17:03.240
有很多很棒的方法

00:17:00.839 --> 00:17:05.010
收藏家，这是其中之一

00:17:03.240 --> 00:17:07.169
这些API的功能与

00:17:05.010 --> 00:17:09.569
任何其他可能是，所以它给

00:17:07.169 --> 00:17:11.819
您很多这些api都很方便

00:17:09.569 --> 00:17:13.350
在某处执行某些操作的方法

00:17:11.819 --> 00:17:16.049
收集东西，所以收藏家是其中之一

00:17:13.350 --> 00:17:18.630
我最喜欢的类实用程序

00:17:16.049 --> 00:17:20.790
 JDK中的课程，所以我要来

00:17:18.630 --> 00:17:24.569
到收集器方法，我

00:17:20.790 --> 00:17:27.299
在这种情况下会说分组

00:17:24.569 --> 00:17:30.330
我想要的特定人的名字

00:17:27.299 --> 00:17:33.360
根据分数将值分组

00:17:30.330 --> 00:17:35.309
得到名字或得到分数

00:17:33.360 --> 00:17:37.500
自己命名，您可以看到

00:17:35.309 --> 00:17:39.720
研究就像你一样

00:17:37.500 --> 00:17:41.309
见过较早，但当然有人

00:17:39.720 --> 00:17:43.320
不太开心，因为我也写了

00:17:41.309 --> 00:17:46.110
这里很多代码甚至会减少它

00:17:43.320 --> 00:17:48.210
现在更远，所以我现在可以说接受这个

00:17:46.110 --> 00:17:50.669
一个说好吧，我们可以采取行动

00:17:48.210 --> 00:17:53.880
我们利用Java中的方法引用

00:17:50.669 --> 00:17:56.580
 8所以我们可以拿这个说分数

00:17:53.880 --> 00:17:59.370
 double：获取，我们可以写很多东西

00:17:56.580 --> 00:18:01.620
还要更简洁，为什么还要写更多

00:17:59.370 --> 00:18:03.299
代码超过必要，您可以看到

00:18:01.620 --> 00:18:05.490
因此，如果您想进入

00:18:03.299 --> 00:18:07.320
竞争问你的一位同事

00:18:05.490 --> 00:18:09.059
编写代码，而他们

00:18:07.320 --> 00:18:10.890
还在启动，你可以写这个

00:18:09.059 --> 00:18:12.090
编码并吃午餐，这是一个

00:18:10.890 --> 00:18:14.429
关于如何美丽的事情

00:18:12.090 --> 00:18:16.830
简而言之，这很疯狂

00:18:14.429 --> 00:18:18.960
你说这有多强大

00:18:16.830 --> 00:18:21.210
所有的分数都给我他们的关键

00:18:18.960 --> 00:18:23.399
然后在

00:18:21.210 --> 00:18:25.799
使用密钥集上的流

00:18:23.399 --> 00:18:28.470
然后开始根据它们进行分组

00:18:25.799 --> 00:18:31.649
这些名称的得分值和

00:18:28.470 --> 00:18:34.320
那就是我们把那些你知道的10 

00:18:31.649 --> 00:18:36.510
几行代码会争论3 

00:18:34.320 --> 00:18:38.159
代码行，但我总是争辩因为

00:18:36.510 --> 00:18:40.200
只有一个分号

00:18:38.159 --> 00:18:42.000
一行代码，所以基本上

00:18:40.200 --> 00:18:44.760
您实际上可以多么简洁

00:18:42.000 --> 00:18:47.279
如我们所见，它变得非常强大

00:18:44.760 --> 00:18:48.679
那又是一件很棒的事情

00:18:47.279 --> 00:18:51.000
可以使用功能库

00:18:48.679 --> 00:18:53.010
提供给我们，这很漂亮

00:18:51.000 --> 00:18:54.929
很好，所以代码非常高

00:18:53.010 --> 00:18:57.029
富有表现力的

00:18:54.929 --> 00:18:59.309
自然，但在这种情况下，我们当然使用

00:18:57.029 --> 00:19:00.419
一些非常专业的功能

00:18:59.309 --> 00:19:02.220
这将需要一个

00:19:00.419 --> 00:19:04.559
一点时间和习惯

00:19:02.220 --> 00:19:06.929
因为当涉及到其中一些

00:19:04.559 --> 00:19:09.270
我们必须花一些时间来完成的功能

00:19:06.929 --> 00:19:11.460
找出可用的功能

00:19:09.270 --> 00:19:13.409
所以我认为有两种方法

00:19:11.460 --> 00:19:15.870
应该有点理解

00:19:13.409 --> 00:19:17.309
一种是您在制定问题时

00:19:15.870 --> 00:19:19.710
英语，你可以回去问

00:19:17.309 --> 00:19:21.659
问题是我知道的功能吗

00:19:19.710 --> 00:19:23.610
这种匹配这些类型的

00:19:21.659 --> 00:19:25.529
行动，你可以做到这一点

00:19:23.610 --> 00:19:27.360
我通常要做的是你知道

00:19:25.529 --> 00:19:28.860
每个人只有有限的亲戚

00:19:27.360 --> 00:19:31.080
记住我们无法记住的事情的能力

00:19:28.860 --> 00:19:33.570
不幸的是，记住一切

00:19:31.080 --> 00:19:35.490
我有点像漫步JDK 

00:19:33.570 --> 00:19:37.740
通过图书馆带来的

00:19:35.490 --> 00:19:39.480
浏览到我会来的文档

00:19:37.740 --> 00:19:41.760
我可能从来没有跨过方法

00:19:39.480 --> 00:19:43.380
看到，我马上记下

00:19:41.760 --> 00:19:45.330
我会通过一分钟

00:19:43.380 --> 00:19:47.279
看一看，说嘿

00:19:45.330 --> 00:19:49.020
它正在做的世界，就在

00:19:47.279 --> 00:19:50.850
我的后脑和另一天

00:19:49.020 --> 00:19:52.470
我正在做其他事情

00:19:50.850 --> 00:19:54.750
说哦，是的，我记得看到过

00:19:52.470 --> 00:19:56.730
那时的小方法然后我会

00:19:54.750 --> 00:19:58.980
去看那个时候，否则我会

00:19:56.730 --> 00:20:01.710
收起来进行实验

00:19:58.980 --> 00:20:03.210
过了一周的空闲时间

00:20:01.710 --> 00:20:04.770
我会和其中一些一起玩

00:20:03.210 --> 00:20:06.960
看他们做什么的方法

00:20:04.770 --> 00:20:09.450
成为你的一部分，你知道

00:20:06.960 --> 00:20:11.220
毛细管在您编程时就像

00:20:09.450 --> 00:20:13.950
我的方法之一

00:20:11.220 --> 00:20:17.040
最喜欢的方法是可以

00:20:13.950 --> 00:20:18.390
帮助我们将集合拆分为

00:20:17.040 --> 00:20:20.220
例如几个不同的东西

00:20:18.390 --> 00:20:22.230
你知道我在讲

00:20:20.220 --> 00:20:24.960
最近有人说嘿我

00:20:22.230 --> 00:20:28.410
如果我有很清楚地了解过滤器

00:20:24.960 --> 00:20:31.080
我可以过滤掉的收藏集

00:20:28.410 --> 00:20:33.360
一定值的对象

00:20:31.080 --> 00:20:34.680
一分钟，作为一个粗略的例子，如果我

00:20:33.360 --> 00:20:37.230
想要把这个房间分成两部分

00:20:34.680 --> 00:20:39.270
我想要的部分比

00:20:37.230 --> 00:20:42.120
我和比我年轻的人

00:20:39.270 --> 00:20:43.800
好吧，如果我说那将是一个过滤器

00:20:42.120 --> 00:20:45.750
只有别人比我生气

00:20:43.800 --> 00:20:47.700
过滤器以及该收集的内容

00:20:45.750 --> 00:20:49.530
有比我年轻的人，但是

00:20:47.700 --> 00:20:51.330
如果我真的想收藏那些

00:20:49.530 --> 00:20:53.670
比我和那些年纪大的人生气

00:20:51.330 --> 00:20:55.860
我进一步不会帮助你

00:20:53.670 --> 00:20:59.100
那是美丽的是你可以

00:20:55.860 --> 00:21:01.380
在这种情况下实际使用分区

00:20:59.100 --> 00:21:03.690
方法和分区将给您

00:21:01.380 --> 00:21:06.240
此收藏将要去的地图

00:21:03.690 --> 00:21:07.950
在这个例子中只有一部分

00:21:06.240 --> 00:21:09.540
比我和其他人年轻的人

00:21:07.950 --> 00:21:11.310
比我年龄大的一部分

00:21:09.540 --> 00:21:13.950
所以你可以使用一些类似的东西

00:21:11.310 --> 00:21:16.620
非常好的实现这一点，让我们来看

00:21:13.950 --> 00:21:19.950
另一方面，这个例子实际上

00:21:16.620 --> 00:21:21.990
我不得不说实际上

00:21:19.950 --> 00:21:24.120
受到参加我的人的启发

00:21:21.990 --> 00:21:26.190
他们参加的先前的演讲

00:21:24.120 --> 00:21:28.350
谈话，他们给我发电子邮件说我来了

00:21:26.190 --> 00:21:31.980
真的很高兴

00:21:28.350 --> 00:21:33.390
看到这个，但我的问题是什么

00:21:31.980 --> 00:21:35.820
我正在尝试做，但我不知道

00:21:33.390 --> 00:21:38.160
从您给我的例子中

00:21:35.820 --> 00:21:39.600
世界实现这一目标，所以我非常感谢

00:21:38.160 --> 00:21:42.240
有问题的人给了

00:21:39.600 --> 00:21:43.560
回答，我有点说那很棒

00:21:42.240 --> 00:21:45.390
例子，所以我要替换其中之一

00:21:43.560 --> 00:21:46.890
我的例子来使用这个特殊的

00:21:45.390 --> 00:21:49.650
例子，让我们看一下

00:21:46.890 --> 00:21:53.460
这个人要我一起工作

00:21:49.650 --> 00:21:56.190
这是欧几里得的一个小例子

00:21:53.460 --> 00:21:59.100
算法，这一切都在给出

00:21:56.190 --> 00:22:01.830
一个想要给你的收藏家编号

00:21:59.100 --> 00:22:04.530
一组数字

00:22:01.830 --> 00:22:07.470
一个正方形加B的属性

00:22:04.530 --> 00:22:09.720
平方等于C平方，因此

00:22:07.470 --> 00:22:12.060
举例给我所有的数字

00:22:09.720 --> 00:22:14.750
该属性的平方加B 

00:22:12.060 --> 00:22:16.220
满足等于C平方的平方，如果

00:22:14.750 --> 00:22:18.140
例如当我运行此代码时

00:22:16.220 --> 00:22:20.180
会看到三四五米

00:22:18.140 --> 00:22:23.210
标准三平方加四平方

00:22:20.180 --> 00:22:25.190
等于25等于5平方所以

00:22:23.210 --> 00:22:27.050
 b和c是三个四和五个，依此类推

00:22:25.190 --> 00:22:29.210
上，但这是无限的

00:22:27.050 --> 00:22:31.070
您实际上可以寻找的数字，但是

00:22:29.210 --> 00:22:32.150
该人要我展示如何

00:22:31.070 --> 00:22:34.190
解决这个问题

00:22:32.150 --> 00:22:36.650
这位先生实际上给我发了密码

00:22:34.190 --> 00:22:38.750
当命令式和说嘿我

00:22:36.650 --> 00:22:41.420
可以这样做，我有一个功能

00:22:38.750 --> 00:22:42.800
叫得到三倍，你可以使事情

00:22:41.420 --> 00:22:44.930
有点容易，这是返回一个

00:22:42.800 --> 00:22:48.140
字符串在这里，所以获得三倍只是

00:22:44.930 --> 00:22:50.420
返回为其的B和C值

00:22:48.140 --> 00:22:52.640
符合这个标准，那就是

00:22:50.420 --> 00:22:54.710
这你可以算法做到这一点，但

00:22:52.640 --> 00:22:56.690
我希望所有数字都达到一定

00:22:54.710 --> 00:22:59.390
这么说吧，在这种情况下，您

00:22:56.690 --> 00:23:02.720
注意我拥有的是非常传统的

00:22:59.390 --> 00:23:06.190
我们从M上的for循环开始的代码

00:23:02.720 --> 00:23:09.370
从2到M加1然后是

00:23:06.190 --> 00:23:13.190
对不起，m等于2 2 

00:23:09.370 --> 00:23:16.190
递增M加递增m 

00:23:13.190 --> 00:23:18.740
 n当然从1开始但下降

00:23:16.190 --> 00:23:21.200
按此顺序一次拍摄M，然后

00:23:18.740 --> 00:23:23.090
我们打电话给M和n取三倍

00:23:21.200 --> 00:23:25.370
然后将其添加到三元组中

00:23:23.090 --> 00:23:27.140
增加计数，如果计数是

00:23:25.370 --> 00:23:27.950
大于我们的价值

00:23:27.140 --> 00:23:30.050
预期

00:23:27.950 --> 00:23:32.060
然后我们跳出循环，然后

00:23:30.050 --> 00:23:34.090
当然，这真的很可悲，不是吗

00:23:32.060 --> 00:23:36.770
你必须再做一次检查

00:23:34.090 --> 00:23:38.660
这就是命令性代码如何惩罚您

00:23:36.770 --> 00:23:40.550
两次，所以你必须真正检查

00:23:38.660 --> 00:23:42.680
再一次，然后你打破我们

00:23:40.550 --> 00:23:45.140
确定的在那里三倍，所以问题

00:23:42.680 --> 00:23:47.900
您实际上是如何做到这一点的

00:23:45.140 --> 00:23:50.570
在这段代码中我们有两个for循环

00:23:47.900 --> 00:23:52.160
这有点令人困惑

00:23:50.570 --> 00:23:54.110
有两个for循环，我知道如何处理

00:23:52.160 --> 00:23:56.000
与一个for循环，我可以使用一个范围

00:23:54.110 --> 00:23:58.490
我可以使用过滤器的方法

00:23:56.000 --> 00:24:00.350
流，我可以使用地图，但在这里

00:23:58.490 --> 00:24:02.240
两个for循环我该如何处理

00:24:00.350 --> 00:24:03.680
很好理解我

00:24:02.240 --> 00:24:06.050
将以一个稍微不同的例子

00:24:03.680 --> 00:24:08.510
说明我们将如何合作

00:24:06.050 --> 00:24:11.180
所以想像一下

00:24:08.510 --> 00:24:13.340
我有一个人带的集合

00:24:11.180 --> 00:24:15.530
这个房间里的人的例子

00:24:13.340 --> 00:24:17.360
这个房间里的人很棒，所以我有

00:24:15.530 --> 00:24:20.150
房间里的人，所以我有一个

00:24:17.360 --> 00:24:22.640
和我在一起的人和我的收藏

00:24:20.150 --> 00:24:27.260
想要每个人都有功能

00:24:22.640 --> 00:24:29.240
打电话给主邮件，这样每个人

00:24:27.260 --> 00:24:31.490
这个房间有一封电子邮件和一封主要电子邮件

00:24:29.240 --> 00:24:33.920
对不起，我不要你，但我

00:24:31.490 --> 00:24:36.110
想要您的电子邮件地址，以便我可以发送垃圾邮件

00:24:33.920 --> 00:24:38.300
您好主意，我们该怎么做

00:24:36.110 --> 00:24:40.250
很好，这里的功能是

00:24:38.300 --> 00:24:43.160
一对一映射

00:24:40.250 --> 00:24:45.140
意味着给某人一个电子邮件

00:24:43.160 --> 00:24:48.050
该人的，所以你用什么

00:24:45.140 --> 00:24:50.570
你说人点图，然后你

00:24:48.050 --> 00:24:53.240
说人，你可以说人点

00:24:50.570 --> 00:24:55.340
得到主要的电子邮件，基本上

00:24:53.240 --> 00:24:57.140
您将如何在代码中执行此操作

00:24:55.340 --> 00:24:59.750
你可以得到主要的电子邮件

00:24:57.140 --> 00:25:02.060
很好，所以和你一样很好

00:24:59.750 --> 00:25:05.300
可以看到我们的状况如何

00:25:02.060 --> 00:25:08.630
如果我还有另一个功能

00:25:05.300 --> 00:25:10.640
所有的电子邮件地址，让我们只说全部

00:25:08.630 --> 00:25:12.920
电子邮件这将返回一个

00:25:10.640 --> 00:25:15.320
您所有电子邮件地址的集合

00:25:12.920 --> 00:25:16.610
你们中有些人可能只有一封电子邮件我-有些人

00:25:15.320 --> 00:25:18.950
你们当中可能有人-你们当中有人

00:25:16.610 --> 00:25:20.870
七，我的意思是，垃圾邮件非常有趣

00:25:18.950 --> 00:25:23.420
所有的地址不只是其中之一

00:25:20.870 --> 00:25:26.630
是不是所以我想将人们映射到所有人

00:25:23.420 --> 00:25:29.570
他们的电子邮件地址很遗憾，这是一个

00:25:26.630 --> 00:25:33.710
一对多，因为我来自一个人

00:25:29.570 --> 00:25:36.680
获取所有电子邮件的电子邮件，所以这是

00:25:33.710 --> 00:25:39.980
如果我说，电子邮件不再发送电子邮件了

00:25:36.680 --> 00:25:43.780
一个人或一个人宁愿点

00:25:39.980 --> 00:25:47.090
给某人的地图d'art获得所有

00:25:43.780 --> 00:25:50.240
很好地向您发送电子邮件，结果

00:25:47.090 --> 00:25:53.210
你来自一个人的集合，所以

00:25:50.240 --> 00:25:56.530
这是人的集合

00:25:53.210 --> 00:26:00.620
一方面，这样收集人

00:25:56.530 --> 00:26:02.660
这是电子邮件列表的集合

00:26:00.620 --> 00:26:04.670
可能不是我想要的是

00:26:02.660 --> 00:26:06.890
我希望我们有一个赢家，但这不是

00:26:04.670 --> 00:26:11.260
我想要的是我真正想要的是

00:26:06.890 --> 00:26:14.420
收集人做

00:26:11.260 --> 00:26:17.900
电子邮件，所以我真的想要收集

00:26:14.420 --> 00:26:20.390
所有电子邮件中的一个单独列出

00:26:17.900 --> 00:26:22.760
我会去做那让我们画画吗

00:26:20.390 --> 00:26:24.230
 groovy的一些启发

00:26:22.760 --> 00:26:27.740
因为Java并没有

00:26:24.230 --> 00:26:30.740
所以在时髦方面，我要说的是

00:26:27.740 --> 00:26:33.530
说一二，但我要说三四

00:26:30.740 --> 00:26:36.890
然后说五个，然后走

00:26:33.530 --> 00:26:39.260
前面说六点七点

00:26:36.890 --> 00:26:40.669
我想知道八点

00:26:39.260 --> 00:26:43.070
我有的元素

00:26:40.669 --> 00:26:45.169
所以我要说列表艺术的大小

00:26:43.070 --> 00:26:48.139
元素的数量，它告诉我

00:26:45.169 --> 00:26:50.119
我有六个要素，我们知道我们有

00:26:48.139 --> 00:26:52.429
六个元素，但实际上我们有八个

00:26:50.119 --> 00:26:55.399
元素，但我们有一个列表清单

00:26:52.429 --> 00:26:59.210
我们的手，所以一和二是一

00:26:55.399 --> 00:27:01.970
元素3 4是1 5是你知道的

00:26:59.210 --> 00:27:04.009
第四和第五六个结合我们的六个

00:27:01.970 --> 00:27:06.379
七合一是一个，但我真的不是

00:27:04.009 --> 00:27:08.749
想要那些收藏我

00:27:06.379 --> 00:27:11.570
想要整理一个单一的收藏

00:27:08.749 --> 00:27:13.700
我怎样才能真正得到它，如果您注意到

00:27:11.570 --> 00:27:15.769
这是我的清单清单

00:27:13.700 --> 00:27:18.350
在我手上，但我要

00:27:15.769 --> 00:27:21.109
说让我们开始展平，然后我

00:27:18.350 --> 00:27:23.389
要说飞镖II，现在注意

00:27:21.109 --> 00:27:25.879
这种情况，当我把它弄平

00:27:23.389 --> 00:27:28.340
我得到的价值是八

00:27:25.879 --> 00:27:30.830
同样，如果我只是打印出

00:27:28.340 --> 00:27:33.139
公寓，它是一个公寓的集合

00:27:30.830 --> 00:27:35.600
该集合不是一个集合

00:27:33.139 --> 00:27:37.100
如此扁平化的收藏集

00:27:35.600 --> 00:27:39.169
是一个相当

00:27:37.100 --> 00:27:40.940
 Java的不同语言数量

00:27:39.169 --> 00:27:42.679
没有它，但好消息是

00:27:40.940 --> 00:27:44.840
而Java没有功能

00:27:42.679 --> 00:27:47.330
展平列表，它确实有办法

00:27:44.840 --> 00:27:49.489
几乎将流平整

00:27:47.330 --> 00:27:51.559
所以我们真正想要做的是

00:27:49.489 --> 00:27:54.590
执行地图操作，让我们返回

00:27:51.559 --> 00:27:57.139
我们在一分钟前看到的例子

00:27:54.590 --> 00:27:59.149
想执行地图操作，但是

00:27:57.139 --> 00:28:01.609
在执行地图操作时， 

00:27:59.149 --> 00:28:04.970
也想从技术上压扁你

00:28:01.609 --> 00:28:07.309
本可以称它为地图展平，但

00:28:04.970 --> 00:28:08.960
听起来不太好，所以听起来

00:28:07.309 --> 00:28:11.090
像绕口令，所以他们称之为

00:28:08.960 --> 00:28:11.570
平面图，所以现在您知道什么是平面图

00:28:11.090 --> 00:28:13.279
是

00:28:11.570 --> 00:28:16.009
当你有一个平面图

00:28:13.279 --> 00:28:18.080
换句话说，集合的集合

00:28:16.009 --> 00:28:20.989
有一对多关系时

00:28:18.080 --> 00:28:23.119
您的候选人很可能是平面地图

00:28:20.989 --> 00:28:24.980
这就是我所有的想法

00:28:23.119 --> 00:28:27.289
每当我有一对一的时候

00:28:24.980 --> 00:28:29.840
转换如果我也想使用地图

00:28:27.289 --> 00:28:31.789
许多转变我问一个问题

00:28:29.840 --> 00:28:34.730
也许这是一个使用平板的应用程序

00:28:31.789 --> 00:28:37.129
在这种特殊情况下的地图，让我们

00:28:34.730 --> 00:28:38.600
看看我们如何从平面地图中受益

00:28:37.129 --> 00:28:40.970
在这种情况下

00:28:38.600 --> 00:28:43.489
一个特殊的例子，让我们来看这里

00:28:40.970 --> 00:28:45.590
到我们正在处理的代码的通知

00:28:43.489 --> 00:28:47.809
我们有这个收藏集

00:28:45.590 --> 00:28:50.239
但是如果你真的考虑一下

00:28:47.809 --> 00:28:52.099
这个集合产生这个内部循环

00:28:50.239 --> 00:28:53.600
正在产生一个集合

00:28:52.099 --> 00:28:55.460
三倍，我们

00:28:53.600 --> 00:28:57.320
将这些收藏放到一个单元中

00:28:55.460 --> 00:28:59.180
这就是我们想要的收藏

00:28:57.320 --> 00:29:02.330
让我们继续并真正运行代码

00:28:59.180 --> 00:29:04.460
快速3 4 5 8 6 10我们想要一样

00:29:02.330 --> 00:29:07.100
完成后输出，但我们如何进行

00:29:04.460 --> 00:29:09.230
再做一次，让我们

00:29:07.100 --> 00:29:11.270
突出显示所有代码，让我们重写

00:29:09.230 --> 00:29:14.750
这是功能性风格，所以我们可以说

00:29:11.270 --> 00:29:17.180
在这种情况下返回字符串点迭代

00:29:14.750 --> 00:29:19.310
我们从值2开始，为什么

00:29:17.180 --> 00:29:20.960
从2开始，因为此循环

00:29:19.310 --> 00:29:24.170
可以从2开始

00:29:20.960 --> 00:29:26.480
看到这里，但请注意没有结束

00:29:24.170 --> 00:29:28.580
对于这种情况下的特定列表

00:29:26.480 --> 00:29:30.440
经历了其他地方的突破

00:29:28.580 --> 00:29:33.800
正是我们要做的

00:29:30.440 --> 00:29:36.560
元素e给我元素E +1 

00:29:33.800 --> 00:29:38.720
被称为无限流，所以无限

00:29:36.560 --> 00:29:41.090
溪流无边无际

00:29:38.720 --> 00:29:43.640
继续前进，因此，我们已经

00:29:41.090 --> 00:29:46.370
开始2然后2加1是3 3加

00:29:43.640 --> 00:29:46.760
 1是4 4加1是5，依此类推

00:29:46.370 --> 00:29:49.370
去

00:29:46.760 --> 00:29:52.640
当然，这是懒惰，不是要这么做

00:29:49.370 --> 00:29:54.680
直到我们索要数据，以便按需

00:29:52.640 --> 00:29:57.830
所以我接下来要做的是

00:29:54.680 --> 00:29:59.960
一个是我要在这个上叫平面图

00:29:57.830 --> 00:30:03.590
在这种情况下，我要说的是

00:29:59.960 --> 00:30:06.260
我现在要说的是M的值

00:30:03.590 --> 00:30:07.940
飞镖射程，我要开始

00:30:06.260 --> 00:30:11.450
与范围记住这是怎么回事

00:30:07.940 --> 00:30:15.830
从n到1是1，但害羞

00:30:11.450 --> 00:30:19.160
 M嘿，这很容易，我可以从M one开始

00:30:15.830 --> 00:30:21.110
随手害羞的M 

00:30:19.160 --> 00:30:23.420
给我for范围的循环

00:30:21.110 --> 00:30:26.330
价值观，但我该怎么办

00:30:23.420 --> 00:30:28.400
说在这里映射到对象，那就是

00:30:26.330 --> 00:30:30.080
因为插播中期望返回一个

00:30:28.400 --> 00:30:32.510
整数，但我要返回一个

00:30:30.080 --> 00:30:34.970
在这种情况下是对象

00:30:32.510 --> 00:30:37.520
我要映射到的是一个

00:30:34.970 --> 00:30:40.460
 n的值，但我要返回得到

00:30:37.520 --> 00:30:43.520
价值的三倍

00:30:40.460 --> 00:30:46.280
无论m和n为何M逗号n 

00:30:43.520 --> 00:30:48.790
从这里给我们带来价值

00:30:46.280 --> 00:30:51.470
这将返回给我们

00:30:48.790 --> 00:30:53.090
从这个特定的对象，我们不是

00:30:51.470 --> 00:30:55.640
当然可以，但是最后

00:30:53.090 --> 00:30:58.010
这是极限，我们将要

00:30:55.640 --> 00:31:00.860
将其限制为我们的值数

00:30:58.010 --> 00:31:03.350
预期，然后再次是我们的

00:31:00.860 --> 00:31:05.690
优秀的收藏家进来，我们

00:31:03.350 --> 00:31:06.690
将使用收集器，然后

00:31:05.690 --> 00:31:08.820
收藏家来

00:31:06.690 --> 00:31:12.179
在这种情况下列出方法，所以我们要

00:31:08.820 --> 00:31:14.849
要说的是这里的to list方法

00:31:12.179 --> 00:31:16.529
最终全部归还给清单

00:31:14.849 --> 00:31:17.789
串流从哪里来

00:31:16.529 --> 00:31:20.399
继续说这是流

00:31:17.789 --> 00:31:22.859
来自流，所以在这种情况下

00:31:20.399 --> 00:31:25.320
那就是我们最终得到的代码是

00:31:22.859 --> 00:31:28.619
简单地循环并打印所有

00:31:25.320 --> 00:31:30.899
值，以便您可以再次看到代码是

00:31:28.619 --> 00:31:33.059
非常实用和容易，但是窍门

00:31:30.899 --> 00:31:34.679
这里是在这种情况下使用平面地图

00:31:33.059 --> 00:31:37.349
知道我们正在处理

00:31:34.679 --> 00:31:38.999
一对多关系平面图

00:31:37.349 --> 00:31:41.070
整理列表并给我们结果

00:31:38.999 --> 00:31:43.049
最终，这正是我们

00:31:41.070 --> 00:31:45.960
在这个特定的例子中做了

00:31:43.049 --> 00:31:48.869
关于如何做到这一点的想法

00:31:45.960 --> 00:31:50.580
我使用平面地图非常有效

00:31:48.869 --> 00:31:52.769
不得不说，平面地图是其中之一

00:31:50.580 --> 00:31:54.450
功能上的迷人特征

00:31:52.769 --> 00:31:56.489
编程，我有点

00:31:54.450 --> 00:31:58.559
在平面图上发现问题

00:31:56.489 --> 00:32:00.119
传统上变得有用

00:31:58.559 --> 00:32:01.889
每周至少发送一次电子邮件

00:32:00.119 --> 00:32:03.989
有人说我该怎么解决

00:32:01.889 --> 00:32:05.909
问题，我的大脑就像是这样吗

00:32:03.989 --> 00:32:07.289
另一个平面图问题和

00:32:05.909 --> 00:32:08.849
总是变成至少一个

00:32:07.289 --> 00:32:10.559
每个星期人们仍然在

00:32:08.849 --> 00:32:13.019
努力真正了解这一点

00:32:10.559 --> 00:32:16.259
平面图我想展示的最后一件事

00:32:13.019 --> 00:32:18.960
你这是一件事是很普遍的

00:32:16.259 --> 00:32:21.929
问题，但会变得很烦人

00:32:18.960 --> 00:32:23.970
解决随着时间的推移，让我们实际解决

00:32:21.929 --> 00:32:26.070
用手看看这有多痛苦

00:32:23.970 --> 00:32:28.080
可以变成所以我要我接受

00:32:26.070 --> 00:32:30.299
问题在这里，然后我们将尝试

00:32:28.080 --> 00:32:32.460
实施它，看看有多奇怪

00:32:30.299 --> 00:32:34.379
当我们试图

00:32:32.460 --> 00:32:36.479
以功能命令式的方式执行此操作

00:32:34.379 --> 00:32:38.460
所以让我们摆脱所有这些

00:32:36.479 --> 00:32:40.349
快速到达主要功能

00:32:38.460 --> 00:32:42.809
在主要功能中，我要去

00:32:40.349 --> 00:32:45.570
要做的是尝试为此实现代码

00:32:42.809 --> 00:32:49.019
找到这个来找到平方和

00:32:45.570 --> 00:32:51.330
以n开头的K个质数的根

00:32:49.019 --> 00:32:54.029
假设n等于让我们抛出一个

00:32:51.330 --> 00:32:57.059
数字43然后让我们说K等于

00:32:54.029 --> 00:32:59.580
到2 41让我们说一些随机数

00:32:57.059 --> 00:33:01.950
但是我们如何实现此代码以

00:32:59.580 --> 00:33:04.379
计算所有平方根的和

00:33:01.950 --> 00:33:07.289
 K数字很好，让我们尝试一下

00:33:04.379 --> 00:33:11.190
我们可以说int索引等于n成

00:33:07.289 --> 00:33:14.909
计数等于0，然后我们可以

00:33:11.190 --> 00:33:17.399
说双重结果，所以双重结果是

00:33:14.909 --> 00:33:19.140
完成后等于0 

00:33:17.399 --> 00:33:21.750
毕竟想打印结果

00:33:19.140 --> 00:33:24.270
但是到目前为止我们到底做了什么

00:33:21.750 --> 00:33:25.860
没什么用，我们只是创建一堆

00:33:24.270 --> 00:33:28.320
这些垃圾变量就是我们

00:33:25.860 --> 00:33:31.380
做了，然后当然结束了

00:33:28.320 --> 00:33:33.750
下一步，我们要说一会儿，然后

00:33:31.380 --> 00:33:37.170
那我们说完之后我们该怎么办

00:33:33.750 --> 00:33:39.360
而计数小于K且您的

00:33:37.170 --> 00:33:41.760
大脑突然停止

00:33:39.360 --> 00:33:44.670
问题是小于或小于

00:33:41.760 --> 00:33:48.270
等于或等于你有没有问过

00:33:44.670 --> 00:33:50.580
每次都只有一个问题

00:33:48.270 --> 00:33:53.190
这样的代码的一个目的就是使我们

00:33:50.580 --> 00:33:55.560
感到愚蠢，因为每次您写

00:33:53.190 --> 00:33:57.720
这是你的心，说吧，他们是

00:33:55.560 --> 00:34:00.180
试图找出是极限还是极限

00:33:57.720 --> 00:34:01.620
加一，这是最令人烦恼的

00:34:00.180 --> 00:34:04.080
我们一直在做的事情， 

00:34:01.620 --> 00:34:06.060
每一天，这就像

00:34:04.080 --> 00:34:07.950
工作，让我们自以为是

00:34:06.060 --> 00:34:10.200
对，因为我们永远都做不到

00:34:07.950 --> 00:34:12.570
直总是让人困惑，我们

00:34:10.200 --> 00:34:15.030
总是写一个修女奇迹我

00:34:12.570 --> 00:34:17.220
弄对了，所以跟你一样很烦

00:34:15.030 --> 00:34:19.590
可以看到然后我该怎么做，然后我就

00:34:17.220 --> 00:34:21.030
要问他素数好吗，我

00:34:19.590 --> 00:34:23.610
可以为每个素数编写函数

00:34:21.030 --> 00:34:27.659
很容易，所以说公共静态

00:34:23.610 --> 00:34:29.909
在这种情况下，布尔值是素数

00:34:27.659 --> 00:34:32.310
之后应该很容易做到

00:34:29.909 --> 00:34:35.159
这样我们就可以简单地说出退货号码

00:34:32.310 --> 00:34:38.429
大于1并且在流中

00:34:35.159 --> 00:34:40.830
从o2到数字范围，我将

00:34:38.429 --> 00:34:44.100
只需说不匹配，然后给出一个

00:34:40.830 --> 00:34:46.260
数I数mod I等于零

00:34:44.100 --> 00:34:47.580
嘿，那真的很简单

00:34:46.260 --> 00:34:49.380
那就是我们一开始所做的

00:34:47.580 --> 00:34:51.179
例子，所以我们可以把它引入

00:34:49.380 --> 00:34:55.260
好了，现在我们做了什么

00:34:51.179 --> 00:34:58.410
下一步，我要说的是

00:34:55.260 --> 00:35:00.750
数字是素数，因此如果是

00:34:58.410 --> 00:35:03.390
尝试然后我会做什么结果

00:35:00.750 --> 00:35:07.230
此加等于数学点平方根

00:35:03.390 --> 00:35:11.550
的价值指数和做的工作

00:35:07.230 --> 00:35:12.930
这是正确的不，我听到有人说

00:35:11.550 --> 00:35:14.940
点点头说不，不是

00:35:12.930 --> 00:35:17.280
纠正我想念的东西

00:35:14.940 --> 00:35:19.890
现在增加索引不是吗

00:35:17.280 --> 00:35:21.840
正确，我看到我们必须增加

00:35:19.890 --> 00:35:27.240
算，所以现在是增量帐户

00:35:21.840 --> 00:35:29.000
纠正它必须在外面不是吗

00:35:27.240 --> 00:35:32.160
伯爵你对此有何看法

00:35:29.000 --> 00:35:32.530
索引计数应在此处

00:35:32.160 --> 00:35:33.880
计数

00:35:32.530 --> 00:35:35.800
在这里被评论但索引

00:35:33.880 --> 00:35:38.380
应该在这里这是偶然的

00:35:35.800 --> 00:35:40.450
复杂性不是很多工作

00:35:38.380 --> 00:35:42.610
编写这段代码，当然

00:35:40.450 --> 00:35:44.320
问题是它是否运作良好，我们可以

00:35:42.610 --> 00:35:46.420
只本着诚信经营

00:35:44.320 --> 00:35:48.400
看看它做了什么，给了我们一些结果

00:35:46.420 --> 00:35:50.140
但这要写很多工作

00:35:48.400 --> 00:35:52.150
简单的一段代码，我们可以尝试一下

00:35:50.140 --> 00:35:54.730
再次让我们继续尝试这个

00:35:52.150 --> 00:35:57.910
好一点的时间，我们可以利用我们的

00:35:54.730 --> 00:36:00.490
这里也有无限的流，所以我们可以

00:35:57.910 --> 00:36:04.390
回到这段代码再说一遍

00:36:00.490 --> 00:36:06.580
结果等于流dart迭代

00:36:04.390 --> 00:36:10.840
我们对数字n感兴趣

00:36:06.580 --> 00:36:14.140
给定一个元素给我+1个元素

00:36:10.840 --> 00:36:16.270
可以从流中开始迭代

00:36:14.140 --> 00:36:18.550
像我一样被称为无限流

00:36:16.270 --> 00:36:20.740
提到的lambda使得它有可能

00:36:18.550 --> 00:36:23.380
创建无限流

00:36:20.740 --> 00:36:25.240
流绝对没有界限，我知道

00:36:23.380 --> 00:36:27.550
你在想什么，如果它是无限的

00:36:25.240 --> 00:36:30.190
它要走多久

00:36:27.550 --> 00:36:32.800
无限哦，我的天哪，如果无限

00:36:30.190 --> 00:36:35.050
您会将其存储在哪里

00:36:32.800 --> 00:36:37.630
当然，关键是

00:36:35.050 --> 00:36:39.340
绝对无限大小是不是

00:36:37.630 --> 00:36:41.380
在这种情况下当然会屈服

00:36:39.340 --> 00:36:43.630
结果以及当您要求

00:36:41.380 --> 00:36:47.950
结果，但是我们可以去做

00:36:43.630 --> 00:36:49.780
说飞镖过滤器样品是主要的，我们

00:36:47.950 --> 00:36:53.560
只问素数

00:36:49.780 --> 00:36:56.230
但是我们可以在此说好地图

00:36:53.560 --> 00:36:58.420
情况下我们可以说地图加倍并给

00:36:56.230 --> 00:37:02.020
它给了我一个平方根

00:36:58.420 --> 00:37:04.930
该值，那么我们可以说在

00:37:02.020 --> 00:37:07.990
这种情况下，我们会说好的，问题是

00:37:04.930 --> 00:37:10.090
小于K小于等于

00:37:07.990 --> 00:37:11.650
连锁是K时间让你动起来

00:37:10.090 --> 00:37:13.450
不必浪费时间在这样的

00:37:11.650 --> 00:37:16.120
琐碎的事情，然后您执行

00:37:13.450 --> 00:37:17.920
现在对它求和运算看一下代码

00:37:16.120 --> 00:37:20.200
与顶部的代码相比

00:37:17.920 --> 00:37:22.480
顶部的代码充满

00:37:20.200 --> 00:37:24.610
意外的复杂性

00:37:22.480 --> 00:37:26.980
底部清除所有意外

00:37:24.610 --> 00:37:28.750
如我们所见，复杂性非常好

00:37:26.980 --> 00:37:31.240
不必在

00:37:28.750 --> 00:37:32.860
所以我们在这里所做的就是

00:37:31.240 --> 00:37:35.860
遍历所有值

00:37:32.860 --> 00:37:38.350
从n懒惰开始，我们当然得到

00:37:35.860 --> 00:37:40.180
来自n的所有素数

00:37:38.350 --> 00:37:42.640
所有素数的平方根

00:37:40.180 --> 00:37:45.580
从N开始，然后当然是什么

00:37:42.640 --> 00:37:49.180
我们在这里所做的只是提取

00:37:45.580 --> 00:37:50.800
 kVAL每次都用完

00:37:49.180 --> 00:37:53.200
这些突出显示的代码是懒惰的

00:37:50.800 --> 00:37:55.690
他们不急着进行的操作

00:37:53.200 --> 00:37:58.090
包括限制，它不会做任何事情

00:37:55.690 --> 00:38:00.640
急切地然后有一些

00:37:58.090 --> 00:38:02.650
作为终端操作是

00:38:00.640 --> 00:38:05.020
在这种情况下触发执行

00:38:02.650 --> 00:38:07.420
的流总是尾巴

00:38:05.020 --> 00:38:10.300
摇狗直到有终端

00:38:07.420 --> 00:38:12.430
方法流引擎不会

00:38:10.300 --> 00:38:14.800
开始踢，直到等到

00:38:12.430 --> 00:38:16.540
那一点开始真正地滴答作响

00:38:14.800 --> 00:38:19.060
这种情况当然是这个美丽

00:38:16.540 --> 00:38:21.250
方法是看顶部的代码

00:38:19.060 --> 00:38:23.320
这就是我所说的偶然

00:38:21.250 --> 00:38:25.720
复杂性我有一点挑战

00:38:23.320 --> 00:38:28.540
你把这段代码放在别人面前

00:38:25.720 --> 00:38:31.300
并请他们阅读并坐在前面

00:38:28.540 --> 00:38:33.490
他们，看着他们的眼球

00:38:31.300 --> 00:38:35.350
眼球这样做，然后这样做

00:38:33.490 --> 00:38:37.210
然后它在这里发抖

00:38:35.350 --> 00:38:38.440
叫做混乱点

00:38:37.210 --> 00:38:40.840
仍在试图找出这是什么

00:38:38.440 --> 00:38:43.210
代码做对了，如果一项业务

00:38:40.840 --> 00:38:44.619
分析师来找你，说，嘿，我明白了

00:38:43.210 --> 00:38:46.840
您正在查看我们的代码，这是什么

00:38:44.619 --> 00:38:48.310
女孩在干，你的反应通常是

00:38:46.840 --> 00:38:50.500
那就是我要弄清楚你的

00:38:48.310 --> 00:38:52.480
闭嘴，这就是我们的感受

00:38:50.500 --> 00:38:54.250
很沮丧，但是你可以

00:38:52.480 --> 00:38:56.560
与他们进行健康对话

00:38:54.250 --> 00:38:58.930
是的，花花公子让我们谈论一下

00:38:56.560 --> 00:39:00.790
我得到的所有n的值

00:38:58.930 --> 00:39:03.040
我得到的素数

00:39:00.790 --> 00:39:05.020
值的平方，但只有K 

00:39:03.040 --> 00:39:06.970
总结起来就是你

00:39:05.020 --> 00:39:09.070
真的想要，这变得非常容易

00:39:06.970 --> 00:39:11.200
同时执行代码

00:39:09.070 --> 00:39:13.450
讨论起来变得非常方便

00:39:11.200 --> 00:39:15.790
代码并与之交互

00:39:13.450 --> 00:39:17.740
总结我们在这里谈论的内容

00:39:15.790 --> 00:39:20.320
我们从一个非常神秘的代码中

00:39:17.740 --> 00:39:22.480
例子很简洁，但我们

00:39:20.320 --> 00:39:25.570
真的能够使用无限流

00:39:22.480 --> 00:39:27.340
和懒惰的评价，如果你问我什么

00:39:25.570 --> 00:39:30.280
功能风格有多重要

00:39:27.340 --> 00:39:31.810
编程，我一直在尝试

00:39:30.280 --> 00:39:34.090
努力学习功能

00:39:31.810 --> 00:39:35.619
编程很多时间，而我

00:39:34.090 --> 00:39:37.570
包括很多演讲者会

00:39:35.619 --> 00:39:39.280
告诉你，哦，天哪，如果你在做

00:39:37.570 --> 00:39:42.460
您应该尊重的函数式编程

00:39:39.280 --> 00:39:44.080
不变性你真的不应该

00:39:42.460 --> 00:39:46.030
知道你应该使用高阶

00:39:44.080 --> 00:39:47.980
您应该真正关注的功能

00:39:46.030 --> 00:39:50.980
编写这样的代码，但我认为那些

00:39:47.980 --> 00:39:53.320
是你重要的东西，但这不是

00:39:50.980 --> 00:39:54.970
真正的主要实际利益或

00:39:53.320 --> 00:39:58.550
函数编程时的兴奋

00:39:54.970 --> 00:40:01.130
对我来说，真正的兴奋是

00:39:58.550 --> 00:40:02.870
功能纯度和编程

00:40:01.130 --> 00:40:05.900
永恒不变

00:40:02.870 --> 00:40:09.380
带领我们来到这一激动人心的现实

00:40:05.900 --> 00:40:12.110
懒惰的特征，因为如果你

00:40:09.380 --> 00:40:14.540
在生活和编程上都懒惰

00:40:12.110 --> 00:40:16.760
最有效率的最好的人

00:40:14.540 --> 00:40:18.350
人们曾经是懒惰的人，所以你

00:40:16.760 --> 00:40:21.320
只是说嘿，我要推迟

00:40:18.350 --> 00:40:23.270
执行，直到我不再推迟

00:40:21.320 --> 00:40:25.340
然后等到那一点

00:40:23.270 --> 00:40:27.500
可以真正有效，那就是

00:40:25.340 --> 00:40:30.350
这段代码向我们展示了多么懒

00:40:27.500 --> 00:40:33.350
评估可以为不敞开大门

00:40:30.350 --> 00:40:35.570
只有运行时效率高，但它也可以

00:40:33.350 --> 00:40:37.760
打开无限之门

00:40:35.570 --> 00:40:40.010
流为我们提供了编程工具

00:40:37.760 --> 00:40:42.410
当我们

00:40:40.010 --> 00:40:44.180
用Java编写代码，但这打开了

00:40:42.410 --> 00:40:45.560
门的一些非常好的方式

00:40:44.180 --> 00:40:48.200
一路实现

00:40:45.560 --> 00:40:51.620
所以从本质上讲，这导致我们

00:40:48.200 --> 00:40:53.720
我们可以用Java表达代码

00:40:51.620 --> 00:40:56.690
有点像你知道回到

00:40:53.720 --> 00:40:58.520
 Java并为此感到兴奋

00:40:56.690 --> 00:41:00.230
再过一次，这是其中之一

00:40:58.520 --> 00:41:03.170
老实说让我兴奋的事情

00:41:00.230 --> 00:41:05.720
在所有这些几十年后的每一个人

00:41:03.170 --> 00:41:07.340
早上我起来写代码给我

00:41:05.720 --> 00:41:09.560
编码不是专业编码是一种

00:41:07.340 --> 00:41:11.600
成瘾，对我来说，编码的原因是

00:41:09.560 --> 00:41:13.190
令人兴奋的是，成为一名程序员就像

00:41:11.600 --> 00:41:14.660
每次在糖果店当小孩

00:41:13.190 --> 00:41:16.220
一天，那才是真正的

00:41:14.660 --> 00:41:17.990
让我兴奋的是能够写这个

00:41:16.220 --> 00:41:20.270
类型的代码并能够表达

00:41:17.990 --> 00:41:21.980
他们以我们没有过的方式

00:41:20.270 --> 00:41:24.380
有机会用Java之类的语言表达

00:41:21.980 --> 00:41:26.870
以前，但我们能够做到这一点

00:41:24.380 --> 00:41:29.270
非常强大，就像你一样

00:41:26.870 --> 00:41:30.350
继续您的旅程

00:41:29.270 --> 00:41:32.930
命令式功能风格

00:41:30.350 --> 00:41:34.730
编程以总结可以

00:41:32.930 --> 00:41:37.430
帮助您，您知道思考

00:41:34.730 --> 00:41:39.590
用英语写单词问

00:41:37.430 --> 00:41:40.970
问我在做什么，那是一个

00:41:39.590 --> 00:41:42.530
挣扎，我们必须尝试一点

00:41:40.970 --> 00:41:44.600
更难，当你制定

00:41:42.530 --> 00:41:46.610
英语的问题，说这是什么

00:41:44.600 --> 00:41:48.800
我在做然后你开始寻找

00:41:46.610 --> 00:41:51.350
可能与之紧密匹配的方法

00:41:48.800 --> 00:41:53.540
您的英文描述，可能需要

00:41:51.350 --> 00:41:56.390
在这些功能上，并使用它

00:41:53.540 --> 00:41:58.640
第二部分是你的旅程

00:41:56.390 --> 00:42:00.860
遍历JDK库和

00:41:58.640 --> 00:42:03.320
功能记下您可能会使用的功能

00:42:00.860 --> 00:42:04.760
以前没看过，看看

00:42:03.320 --> 00:42:06.770
嘿，这很有趣，我没有

00:42:04.760 --> 00:42:08.960
看到这可能是什么问题

00:42:06.770 --> 00:42:11.630
解决那可能是一个非常好的方法

00:42:08.960 --> 00:42:12.180
也要学习到第三点

00:42:11.630 --> 00:42:14.940
我会

00:42:12.180 --> 00:42:17.190
我从中学到了很多东西，因此受到极大的鼓励

00:42:14.940 --> 00:42:19.319
被批评要坐下

00:42:17.190 --> 00:42:21.510
对某人说嘿我在写

00:42:19.319 --> 00:42:23.130
在功能风格上，为什么不

00:42:21.510 --> 00:42:25.319
看一下我在做什么

00:42:23.130 --> 00:42:28.170
一个想法，即使他们可能没有

00:42:25.319 --> 00:42:30.119
真的只是和某人说话

00:42:28.170 --> 00:42:33.660
可以帮助我们您对某些事情不感兴趣

00:42:30.119 --> 00:42:36.210
我们知道一个卡在

00:42:33.660 --> 00:42:37.920
特殊的舒适区，可能会打开

00:42:36.210 --> 00:42:39.839
真正思考解决方案的方法

00:42:37.920 --> 00:42:41.490
您可能没有机会的方式

00:42:39.839 --> 00:42:42.809
考虑一下，这可能是一个真正的

00:42:41.490 --> 00:42:45.210
共享的良好学习经验

00:42:42.809 --> 00:42:46.650
学习经验也是如此

00:42:45.210 --> 00:42:48.140
基本上我希望那是

00:42:46.650 --> 00:42:53.590
有用的谢谢

00:42:48.140 --> 00:42:53.590
 [掌声] 

