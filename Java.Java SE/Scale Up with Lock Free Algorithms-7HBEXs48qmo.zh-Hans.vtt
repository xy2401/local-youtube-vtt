WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.570 --> 00:00:10.390
所以大家好，我们来谈谈

00:00:08.890 --> 00:00:14.950
运气好的算法

00:00:10.390 --> 00:00:16.660
今天，让我介绍自己，我和

00:00:14.950 --> 00:00:18.460
因此，这里有趣的事情

00:00:16.660 --> 00:00:20.650
教并发，我为您服务

00:00:18.460 --> 00:00:23.769
程序在圣。彼得斯堡IT但是

00:00:20.650 --> 00:00:27.220
我们不会去深入理论

00:00:23.769 --> 00:00:28.599
今天的并发计算

00:00:27.220 --> 00:00:32.560
我们将讨论可伸缩性

00:00:28.599 --> 00:00:35.050
问题，我们将看到一些

00:00:32.560 --> 00:00:37.450
我也在Kaplan工作的东西

00:00:35.050 --> 00:00:38.860
如果您对不起我的编码

00:00:37.450 --> 00:00:41.350
例子是棉花，但我

00:00:38.860 --> 00:00:45.520
希望他们会更容易激励

00:00:41.350 --> 00:00:48.899
对于每个人，我真的很笨

00:00:45.520 --> 00:00:53.050
关于你们，谁首先

00:00:48.899 --> 00:00:55.390
谁有明显的机会，如果你来这里

00:00:53.050 --> 00:00:59.039
可能正在写一些并发

00:00:55.390 --> 00:01:02.440
代码，请举手

00:00:59.039 --> 00:01:05.830
好吧好吧，所以我看到了，所以你们大多数人

00:01:02.440 --> 00:01:08.410
一年不是这样，你来看看

00:01:05.830 --> 00:01:10.960
发生了什么事，所以我今天会帮助您

00:01:08.410 --> 00:01:14.230
所以今天我们要谈分享

00:01:10.960 --> 00:01:18.100
它是易变的状态， 

00:01:14.230 --> 00:01:21.760
三个让人们真正恐惧的词

00:01:18.100 --> 00:01:25.660
真的知道这是因为什么时候

00:01:21.760 --> 00:01:28.000
为许多人编程的人

00:01:25.660 --> 00:01:30.730
他们听到这个词的岁月

00:01:28.000 --> 00:01:32.710
会留下来，他们变得与众不同

00:01:30.730 --> 00:01:34.930
协会也许是这样的

00:01:32.710 --> 00:01:38.260
你知道什么时候所有的崩溃和蓝色

00:01:34.930 --> 00:01:40.900
屏幕，或者听起来像你

00:01:38.260 --> 00:01:42.220
知道那种你知道交往

00:01:40.900 --> 00:01:43.960
与这里的人，因为分享

00:01:42.220 --> 00:01:47.170
三件事你永远都不要

00:01:43.960 --> 00:01:50.560
曾经在一起，你知道你可以拥有

00:01:47.170 --> 00:01:52.270
可变性，但您分别知道

00:01:50.560 --> 00:01:52.870
单独共享，但在您共享时

00:01:52.270 --> 00:01:55.770
全部一起

00:01:52.870 --> 00:01:59.440
是的，这变得非常困难

00:01:55.770 --> 00:02:01.360
所以如果那是那么糟糕，那么为什么人们

00:01:59.440 --> 00:02:04.690
这样做是为什么我们要共享

00:02:01.360 --> 00:02:06.400
中间状态以及Java为什么支持它

00:02:04.690 --> 00:02:09.879
当许多其他现代语言

00:02:06.400 --> 00:02:12.010
支持它，为什么不为什么我们不喜欢

00:02:09.879 --> 00:02:14.560
并禁止它像有一些

00:02:12.010 --> 00:02:15.800
完全禁止的语言

00:02:14.560 --> 00:02:18.020
你来自哈里

00:02:15.800 --> 00:02:20.120
哦，状态，实际上有这个

00:02:18.020 --> 00:02:22.910
真的很简单，就像你看着

00:02:20.120 --> 00:02:25.670
早晨的世界，你知道这个

00:02:22.910 --> 00:02:27.590
废话周数据，所以我把

00:02:25.670 --> 00:02:31.700
大数据，你必须做点什么

00:02:27.590 --> 00:02:34.390
有了它，你知道很多次

00:02:31.700 --> 00:02:37.100
您要解决的问题是

00:02:34.390 --> 00:02:38.930
你不能用这种模式代表它

00:02:37.100 --> 00:02:42.230
您拥有这些大数据，您可以将其拆分

00:02:38.930 --> 00:02:44.900
两批然后您做一些处理

00:02:42.230 --> 00:02:47.600
带有战利品的数据，然后您收集

00:02:44.900 --> 00:02:50.150
得到答案的结果是

00:02:47.600 --> 00:02:51.350
我喜欢的大多数问题和

00:02:50.150 --> 00:02:53.060
我喜欢的问题被称为

00:02:51.350 --> 00:02:54.980
令人尴尬的是，实际上

00:02:53.060 --> 00:02:57.050
实际技术术语存在的问题

00:02:54.980 --> 00:02:59.840
在同时叫尴尬和

00:02:57.050 --> 00:03:04.400
因为要解决它们，我的意思是容易

00:02:59.840 --> 00:03:07.010
意识到，你不必走进

00:03:04.400 --> 00:03:09.410
共享可变状态的可怕世界

00:03:07.010 --> 00:03:12.440
因为你知道没有共享

00:03:09.410 --> 00:03:14.720
在这里您可以将它放大二极管

00:03:12.440 --> 00:03:17.600
您可以编写常规DNA的簇

00:03:14.720 --> 00:03:19.720
处理代码让我们建立一个框架

00:03:17.600 --> 00:03:22.250
这是底部照顾

00:03:19.720 --> 00:03:24.530
仅安排操作，如果

00:03:22.250 --> 00:03:27.170
如果你的问题是那样的

00:03:24.530 --> 00:03:31.760
一个快乐的人，你不必

00:03:27.170 --> 00:03:34.640
在这里但是有时候你有这么大

00:03:31.760 --> 00:03:36.830
大数据，但它也像实时

00:03:34.640 --> 00:03:39.230
或半实时哦，它会改变所有

00:03:36.830 --> 00:03:41.560
时间，例如股票报价

00:03:39.230 --> 00:03:44.420
一直改变你知道的时间

00:03:41.560 --> 00:03:49.220
大公司的存货

00:03:44.420 --> 00:03:51.220
您知道用户在社交网络中的状态

00:03:49.220 --> 00:03:54.250
网络就像有很多数据一样

00:03:51.220 --> 00:03:57.200
不断变化，你有很多

00:03:54.250 --> 00:03:58.340
同时进行的请求

00:03:57.200 --> 00:04:02.060
与此数据有关的东西

00:03:58.340 --> 00:04:03.170
你知道计算你的投资组合吗

00:04:02.060 --> 00:04:05.180
还不知道

00:04:03.170 --> 00:04:07.040
您的用户的实时状态

00:04:05.180 --> 00:04:10.610
社交网络做类似的事情

00:04:07.040 --> 00:04:13.580
当您开始尝试解决这个问题时

00:04:10.610 --> 00:04:16.549
可扩展性和

00:04:13.580 --> 00:04:19.850
高效的方式根本没有办法

00:04:16.549 --> 00:04:21.890
解决最有效的问题

00:04:19.850 --> 00:04:24.440
无需实际共享即可扩展

00:04:21.890 --> 00:04:26.390
改变的大数据是

00:04:24.440 --> 00:04:28.730
在所有当前之间最小

00:04:26.390 --> 00:04:32.090
并发进程，那么你有

00:04:28.730 --> 00:04:34.400
我的意思是如果您采取其他方法

00:04:32.090 --> 00:04:37.070
你就好吧，我们不要分享任何东西

00:04:34.400 --> 00:04:38.300
你知道然后它变得巨大

00:04:37.070 --> 00:04:40.850
以后复制

00:04:38.300 --> 00:04:42.710
我的意思是SEO，如果数据真实变化

00:04:40.850 --> 00:04:44.960
时间，你必须在所有

00:04:42.710 --> 00:04:47.390
复制等资源的巨大浪费，所以

00:04:44.960 --> 00:04:50.560
这类问题可能仅仅是

00:04:47.390 --> 00:04:54.530
如果您实际使用此Beta数据，则添加盐

00:04:50.560 --> 00:04:57.320
放入一些内存并访问它

00:04:54.530 --> 00:05:00.590
同时处理所有的请求

00:04:57.320 --> 00:05:02.930
你有，这当然是职责

00:05:00.590 --> 00:05:04.760
像这样的东西真的很阴暗

00:05:02.930 --> 00:05:07.370
但我的意思是我们必须拥抱这个黑暗

00:05:04.760 --> 00:05:09.100
一边当我们与我们合作时

00:05:07.370 --> 00:05:11.540
根本没有其他方法，所以让我们

00:05:09.100 --> 00:05:16.070
让我们来到这黑暗的一面， 

00:05:11.540 --> 00:05:18.170
为此使用它

00:05:16.070 --> 00:05:18.710
我们必须向我做的特别介绍

00:05:18.170 --> 00:05:21.320
不得不

00:05:18.710 --> 00:05:23.420
它会带给你一些例子

00:05:21.320 --> 00:05:24.950
所以我们必须选择一些玩具问题

00:05:23.420 --> 00:05:27.200
这是最难的部分

00:05:24.950 --> 00:05:28.640
我的意思是偷看一个问题

00:05:27.200 --> 00:05:31.010
展示并发是因为

00:05:28.640 --> 00:05:33.440
程序从来没有真正的问题， 

00:05:31.010 --> 00:05:36.410
永远不会告诉你两个问题

00:05:33.440 --> 00:05:38.900
你会遇到现实生活，但对于

00:05:36.410 --> 00:05:43.310
那些我已经建立的特殊问题

00:05:38.900 --> 00:05:46.580
一大堆人并不简单

00:05:43.310 --> 00:05:49.280
不知道堆栈如何工作，你知道吗

00:05:46.580 --> 00:05:52.670
让我们展示一些核心概念

00:05:49.280 --> 00:05:54.530
他们将与之合作是

00:05:52.670 --> 00:05:56.660
简单会得到林肯堆栈，所以

00:05:54.530 --> 00:05:59.570
我们将在一个具有一个

00:05:56.660 --> 00:06:01.970
下一个参考和一些价值

00:05:59.570 --> 00:06:04.280
输入T，然后按我说的做

00:06:01.970 --> 00:06:05.330
 Kotlin的例子仅仅是因为棉花

00:06:04.280 --> 00:06:07.850
你知道特殊的英语吗

00:06:05.330 --> 00:06:10.130
因此发明或代码适合您

00:06:07.850 --> 00:06:12.230
知道，因为如果我用Java做，你

00:06:10.130 --> 00:06:15.320
知道这是代码的全部内容，而您

00:06:12.230 --> 00:06:17.240
知道威斯康星州三世可以容纳

00:06:15.320 --> 00:06:19.700
除此之外，还有

00:06:17.240 --> 00:06:21.680
这就是我所需要的，所以我不会

00:06:19.700 --> 00:06:26.050
担心它不再是Java 

00:06:21.680 --> 00:06:28.870
所以秒很简单，它是如何工作的

00:06:26.050 --> 00:06:31.490
任何人都以一个空栈开始

00:06:28.870 --> 00:06:34.190
一些具有null的顶级变量

00:06:31.490 --> 00:06:37.130
指针，然后我们向其中添加一个元素， 

00:06:34.190 --> 00:06:40.400
它停下来一次参加下一个是

00:06:37.130 --> 00:06:40.950
现在，我们可以添加另一个元素

00:06:40.400 --> 00:06:44.220
至

00:06:40.950 --> 00:06:46.830
然后切换顶部推文，这是一个堆栈

00:06:44.220 --> 00:06:49.080
我内含两个元素，所以

00:06:46.830 --> 00:06:51.210
那真的很容易，所以推元素

00:06:49.080 --> 00:06:53.820
堆栈很容易，我们可以轻松地

00:06:51.210 --> 00:06:56.310
写这段代码我是说我们可以

00:06:53.820 --> 00:06:59.940
为堆栈声明类，我们可以声明

00:06:56.310 --> 00:07:06.630
顶部变量，我将推只是一个

00:06:59.940 --> 00:07:13.020
班轮容易不是视频，这就是我们的

00:07:06.630 --> 00:07:14.100
顶部是一个推动，所以我们如何弹出

00:07:13.020 --> 00:07:17.310
电路中的项目

00:07:14.100 --> 00:07:19.740
所以我们检查一下当前

00:07:17.310 --> 00:07:21.750
元素是顶部，然后我们翻转

00:07:19.740 --> 00:07:24.030
回到下一个，我们阅读了

00:07:21.750 --> 00:07:24.420
结果并获得一个简单的方法

00:07:24.030 --> 00:07:27.030
看起来

00:07:24.420 --> 00:07:28.800
这就是它的工作方式，这就是

00:07:27.030 --> 00:07:32.460
特别是您知道简洁和结合

00:07:28.800 --> 00:07:35.040
因为你知道我可以折叠我的不

00:07:32.460 --> 00:07:36.960
检查这个漂亮的句法癌症

00:07:35.040 --> 00:07:39.450
所以真的很喜欢

00:07:36.960 --> 00:07:42.780
可以放在一张非常简单的幻灯片上

00:07:39.450 --> 00:07:45.720
第二种植园也是如此

00:07:42.780 --> 00:07:48.420
当然，如果我按顺序执行它会起作用

00:07:45.720 --> 00:07:51.090
如果我只有一次线程化时间有效

00:07:48.420 --> 00:07:52.950
与我的统计信息，如果我不同意的话

00:07:51.090 --> 00:07:55.500
一切正常，但我说

00:07:52.950 --> 00:07:57.090
如果我真的同意，就可以工作

00:07:55.500 --> 00:08:00.780
如果堆栈是共享的中间状态

00:07:57.090 --> 00:08:05.790
伙伴关系也许我正在做也许我正在

00:08:00.780 --> 00:08:07.950
做例如四人池

00:08:05.790 --> 00:08:09.840
大物件或用于我的数据和拉动

00:08:07.950 --> 00:08:10.560
堆栈很容易实现对象

00:08:09.840 --> 00:08:12.840
堆栈很好

00:08:10.560 --> 00:08:15.510
绝对不错的数据结构

00:08:12.840 --> 00:08:17.790
对象池，假设我有一个池

00:08:15.510 --> 00:08:20.370
一些缓冲区或卖方放在堆栈中

00:08:17.790 --> 00:08:22.860
现在我有这么大的平行

00:08:20.370 --> 00:08:26.610
处理，我的许多线程需要

00:08:22.860 --> 00:08:29.700
从游泳池拿东西，放回去

00:08:26.610 --> 00:08:32.070
物品放到游泳池里怎么办

00:08:29.700 --> 00:08:34.440
如果两个线程尝试推入堆栈

00:08:32.070 --> 00:08:37.830
对，所以其中之一来了，你知道

00:08:34.440 --> 00:08:40.080
杂草顶端尝试增加值B，然后

00:08:37.830 --> 00:08:43.320
另一个随之而来尝试添加

00:08:40.080 --> 00:08:45.750
元素C，但现在只有其中一个会

00:08:43.320 --> 00:08:49.320
成功更新顶部和

00:08:45.750 --> 00:08:52.050
另一个将重写

00:08:49.320 --> 00:08:53.089
第一个，所以我们最终会得到

00:08:52.050 --> 00:08:54.829
只得到

00:08:53.089 --> 00:08:57.980
同时推动两个威胁

00:08:54.829 --> 00:09:00.680
其中只有一个添加到堆栈中， 

00:08:57.980 --> 00:09:03.110
这是一个普遍的问题，是我

00:09:00.680 --> 00:09:06.230
认为你称它为冲突，这是

00:09:03.110 --> 00:09:07.579
容易在Java Ya Kotlin中解决

00:09:06.230 --> 00:09:13.100
只是市场同步工作，这是一个

00:09:07.579 --> 00:09:14.569
您在棉花中知道的关键字是

00:09:13.100 --> 00:09:18.100
注解，但概念相同

00:09:14.569 --> 00:09:20.559
通过标记它同步您

00:09:18.100 --> 00:09:23.480
确保彼此之间的互斥

00:09:20.559 --> 00:09:26.480
试图不同的线程

00:09:23.480 --> 00:09:29.779
推和弹出，这样可以防止

00:09:26.480 --> 00:09:32.360
我们看到的问题，但

00:09:29.779 --> 00:09:34.459
我们来这里了解这个问题

00:09:32.360 --> 00:09:37.970
它可以缩放吗，所以我看到了问题

00:09:34.459 --> 00:09:40.540
现在可以工作，但是可以熟练操作

00:09:37.970 --> 00:09:42.649
弄清楚它是否可以扩展，我们必须

00:09:40.540 --> 00:09:45.259
了解所谓的能力和

00:09:42.649 --> 00:09:48.410
一些测量它的人记得我们会

00:09:45.259 --> 00:09:51.019
运行基准，我们将使用此

00:09:48.410 --> 00:09:53.139
不错的一个框架，我会

00:09:51.019 --> 00:09:56.959
推荐任何正在写作的人

00:09:53.139 --> 00:09:58.429
基准测试是开源的

00:09:56.959 --> 00:10:04.309
我将在所有链接的末尾

00:09:58.429 --> 00:10:08.120
它在Java方面是D上的开源

00:10:04.309 --> 00:10:11.269
所以这是男人GDK的一部分，所以我

00:10:08.120 --> 00:10:13.459
可以宣布我的基准

00:10:11.269 --> 00:10:15.559
有一个共享棒，我将有

00:10:13.459 --> 00:10:18.290
多个线程只是试图推动

00:10:15.559 --> 00:10:21.920
弹出项目集以确保它们弹出

00:10:18.290 --> 00:10:24.439
因此我的工作量是真实的

00:10:21.920 --> 00:10:25.879
简单，只是我制作的序列推送弹出

00:10:24.439 --> 00:10:27.470
确保问题出在推挤过程中

00:10:25.879 --> 00:10:30.139
堆栈不会无限增长，而是

00:10:27.470 --> 00:10:30.829
只是大小有限并且要衡量

00:10:30.139 --> 00:10:34.370
它缩放

00:10:30.829 --> 00:10:36.230
我希望通过连接

00:10:34.370 --> 00:10:39.079
威胁数量不断增加

00:10:36.230 --> 00:10:43.459
为了使它变得现实，我去了

00:10:39.079 --> 00:10:45.740
租了这个最大的亚马逊实例

00:10:43.459 --> 00:10:48.740
我可以多花些钱

00:10:45.740 --> 00:10:52.120
您知道的大型计算实例

00:10:48.740 --> 00:10:55.879
至强处理器32个硬件线程

00:10:52.120 --> 00:10:57.889
就像我认为这就是您运行自己的方式

00:10:55.879 --> 00:10:59.629
车轮应用程序，如果您愿意

00:10:57.889 --> 00:11:02.240
有很多数据，你有这么大

00:10:59.629 --> 00:11:04.279
机器大量的内存和大量的

00:11:02.240 --> 00:11:04.880
您将加载数据的硬件线程

00:11:04.279 --> 00:11:09.230
内

00:11:04.880 --> 00:11:10.880
机器，您将开始所有数据

00:11:09.230 --> 00:11:12.889
处理威胁将开始起作用

00:11:10.880 --> 00:11:14.630
与此数据同时存在

00:11:12.889 --> 00:11:17.120
整个模型基本上就是这个

00:11:14.630 --> 00:11:19.190
那个模型的轮巡实例

00:11:17.120 --> 00:11:21.290
一种现实生活中的处理方式

00:11:19.190 --> 00:11:25.130
运行这种真实的外观

00:11:21.290 --> 00:11:28.670
机器，这就是我得到的

00:11:25.130 --> 00:11:30.259
是因为它确实像两千万

00:11:28.670 --> 00:11:33.740
这些操作每秒合二为一

00:11:30.259 --> 00:11:35.360
线程，但是如果我添加更多线程， 

00:11:33.740 --> 00:11:38.120
并没有变好，实际上

00:11:35.360 --> 00:11:39.800
变得更糟，你知道这尤其

00:11:38.120 --> 00:11:41.630
工作两个线程哪种

00:11:39.800 --> 00:11:43.610
当我们有两个时，有趣的效果

00:11:41.630 --> 00:11:45.560
线程就像最坏的情况一样

00:11:43.610 --> 00:11:47.569
但是作为哪种线程数

00:11:45.560 --> 00:11:49.970
稳定，但仍然没有

00:11:47.569 --> 00:11:52.670
表现和运行一样

00:11:49.970 --> 00:11:54.980
只是一个线程，所以与此不同

00:11:52.670 --> 00:11:57.319
解决方案中的一种问题是

00:11:54.980 --> 00:12:00.740
我们添加更多线程不会

00:11:57.319 --> 00:12:03.259
它不会使它变得更好，它不会让

00:12:00.740 --> 00:12:05.750
它每秒推送更多操作，因此

00:12:03.259 --> 00:12:07.639
这就是所谓的不懂为什么

00:12:05.750 --> 00:12:10.699
不会杀死，因为我想

00:12:07.639 --> 00:12:12.800
那是因为它的技术争议

00:12:10.699 --> 00:12:15.350
当一个线程执行说

00:12:12.800 --> 00:12:17.300
例如流行音乐和其他线程

00:12:15.350 --> 00:12:20.209
流行音乐的中间来了，并试图

00:12:17.300 --> 00:12:21.860
做它不能做它必须等待，因为

00:12:20.209 --> 00:12:23.449
同步是互斥的

00:12:21.860 --> 00:12:25.519
你知道我们必须等待的概念

00:12:23.449 --> 00:12:28.839
直到第一个流行音乐完成并且只有

00:12:25.519 --> 00:12:32.209
然后我们可以从堆栈中弹出一个项目

00:12:28.839 --> 00:12:35.689
所以那是一个问题

00:12:32.209 --> 00:12:38.089
同步所有通常的解决方案

00:12:35.689 --> 00:12:40.699
并发的是

00:12:38.089 --> 00:12:42.920
争执，我们开始等待我们

00:12:40.699 --> 00:12:44.870
不能同时做某事

00:12:42.920 --> 00:12:48.860
确实看到过同步关键字和

00:12:44.870 --> 00:12:50.899
锁定它们限制了我们的并发性，因为

00:12:48.860 --> 00:12:54.589
我们必须这样做

00:12:50.899 --> 00:12:58.339
串行更多，因此增加了开销

00:12:54.589 --> 00:13:00.560
因为每次我偶然发现

00:12:58.339 --> 00:13:03.230
我必须联系其他线程记录

00:13:00.560 --> 00:13:05.000
 tsu，这就是为什么它跌倒

00:13:03.230 --> 00:13:07.459
当我们有多个说法不只是

00:13:05.000 --> 00:13:09.500
保持平稳，就像我们只能推动更多

00:13:07.459 --> 00:13:11.839
实际每秒操作数

00:13:09.500 --> 00:13:13.760
当我们有很多事情要做的时候

00:13:11.839 --> 00:13:16.040
我们正在减少每秒的操作

00:13:13.760 --> 00:13:17.379
因为涉及X的开销

00:13:16.040 --> 00:13:20.290
管理

00:13:17.379 --> 00:13:21.850
但这只是锁的一个问题

00:13:20.290 --> 00:13:24.279
另一个问题是，当黄牛死锁时

00:13:21.850 --> 00:13:28.089
我们开始写我们的耙子

00:13:24.279 --> 00:13:30.550
我们与锁同步的应用程序

00:13:28.089 --> 00:13:33.370
我们在放大器中添加了越来越多的锁

00:13:30.550 --> 00:13:35.379
我们添加内容风险内含子， 

00:13:33.370 --> 00:13:37.720
匕首锁在什么情况下

00:13:35.379 --> 00:13:40.089
你知道我不能接受很多，因为

00:13:37.720 --> 00:13:42.250
这需要但是其他一些线程

00:13:40.089 --> 00:13:45.220
原来是在等待日志

00:13:42.250 --> 00:13:47.230
我保留的就是那

00:13:45.220 --> 00:13:50.199
这是另一个可扩展性问题

00:13:47.230 --> 00:13:53.560
带锁的不是可扩展性

00:13:50.199 --> 00:13:54.939
我有多少硬件课程，但是

00:13:53.560 --> 00:13:56.620
我的头骨有多大

00:13:54.939 --> 00:14:00.160
项目是我的项目成为的逻辑

00:13:56.620 --> 00:14:03.449
如果我变得更难维持

00:14:00.160 --> 00:14:05.850
在其中使用锁，这就是为什么我们

00:14:03.449 --> 00:14:07.779
因为这些问题之一

00:14:05.850 --> 00:14:09.670
将目光锁定

00:14:07.779 --> 00:14:13.750
不使用的算法

00:14:09.670 --> 00:14:15.790
锁来解决同样的问题， 

00:14:13.750 --> 00:14:19.269
了解如何锁定算法

00:14:15.790 --> 00:14:21.639
工作如何不碰到

00:14:19.269 --> 00:14:24.910
并发问题，但没有

00:14:21.639 --> 00:14:28.600
使用锁，让我们考虑一下防止

00:14:24.910 --> 00:14:31.420
我们不能同时推动两个项目

00:14:28.600 --> 00:14:36.730
进入堆栈的问题是

00:14:31.420 --> 00:14:40.959
我们已经准备好推出我们期望的产品

00:14:36.730 --> 00:14:45.759
顶部仍然指向

00:14:40.959 --> 00:14:47.410
旧项目，我们想将其更新为

00:14:45.759 --> 00:14:50.040
穿着短的新物品离开这个甲板

00:14:47.410 --> 00:14:52.959
如果可以的话

00:14:50.040 --> 00:14:57.040
从原子上确保其他人不能

00:14:52.959 --> 00:14:59.290
干扰并更快地添加其元素

00:14:57.040 --> 00:15:02.980
比我们做的就是这

00:14:59.290 --> 00:15:05.290
从预期参考到的原子更新

00:15:02.980 --> 00:15:06.939
新的叫做

00:15:05.290 --> 00:15:09.430
有没有要搜索的A 

00:15:06.939 --> 00:15:11.829
操作名称进行比较和设置

00:15:09.430 --> 00:15:14.410
 Java中有一个叫做

00:15:11.829 --> 00:15:16.480
提供给我们这样的原子参考

00:15:14.410 --> 00:15:18.220
功能是一类

00:15:16.480 --> 00:15:20.079
实际上你知道这是它的一部分

00:15:18.220 --> 00:15:23.620
 GDK，因此我们可以从任何给定中使用它

00:15:20.079 --> 00:15:26.110
在此示例中，我们将使用

00:15:23.620 --> 00:15:28.910
从代码行开始使用幻灯片

00:15:26.110 --> 00:15:31.850
因为这只是我们可以使用的类

00:15:28.910 --> 00:15:34.490
它里面包含两个volatile变量

00:15:31.850 --> 00:15:36.560
你可以得到它，或者你可以比较和

00:15:34.490 --> 00:15:40.180
设置它，您可以说是

00:15:36.560 --> 00:15:44.529
我正在更新变量的原子更新

00:15:40.180 --> 00:15:46.910
在没有其他人拥有的情况下

00:15:44.529 --> 00:15:50.120
变化仍然等于预期

00:15:46.910 --> 00:15:53.690
重视自从

00:15:50.120 --> 00:15:57.759
 1.5，我的意思是，这是很长时间的真实监狱

00:15:53.690 --> 00:16:00.649
之前1.5，工作是第一

00:15:57.759 --> 00:16:02.990
语言专业语言是谁的

00:16:00.649 --> 00:16:06.560
标准化操作比较

00:16:02.990 --> 00:16:08.959
就像在c plus中说的那样，他曾经是

00:16:06.560 --> 00:16:11.089
被迫像特定于供应商一样使用

00:16:08.959 --> 00:16:12.709
扩展了部分库

00:16:11.089 --> 00:16:16.430
语言中的成为伙伴

00:16:12.709 --> 00:16:18.680
 C ++语言只是最近才有的

00:16:16.430 --> 00:16:22.220
为什么当你开始阅读文学

00:16:18.680 --> 00:16:24.620
和对数并发计算

00:16:22.220 --> 00:16:27.380
您经常在Java中找到示例，因为

00:16:24.620 --> 00:16:31.279
因为Java让我标准化了

00:16:27.380 --> 00:16:35.480
这种代码比

00:16:31.279 --> 00:16:37.459
任何其他语言，所以我的意思是很容易

00:16:35.480 --> 00:16:41.870
所以我们有，你可以

00:16:37.459 --> 00:16:46.459
比较并说，这始终是我们的方式

00:16:41.870 --> 00:16:49.880
使用它，我们通过替换顶部使用它

00:16:46.459 --> 00:16:51.259
变量而不是变量

00:16:49.880 --> 00:16:52.970
我们将要改变的是

00:16:51.259 --> 00:16:55.430
是有价值的，我们不会达到

00:16:52.970 --> 00:16:58.189
顶部本身，它将包含

00:16:55.430 --> 00:16:59.930
原子引用，我们将使用它

00:16:58.189 --> 00:17:02.180
原子引用本身就是一种改变

00:16:59.930 --> 00:17:04.490
但是我们会更新它以及您的方式

00:17:02.180 --> 00:17:06.679
算法的写锁由

00:17:04.490 --> 00:17:11.110
按照这种模式，所以我们阅读

00:17:06.679 --> 00:17:14.120
当前值，我们正在使用，但我们

00:17:11.110 --> 00:17:15.970
决定在这种情况下我们如何更新

00:17:14.120 --> 00:17:18.559
我们要创建一个新节点

00:17:15.970 --> 00:17:21.409
指向你刚刚读的井

00:17:18.559 --> 00:17:23.240
用我们的价值，我们将尽力执行

00:17:21.409 --> 00:17:26.209
通过比较集的原子更新

00:17:23.240 --> 00:17:28.520
如果成功，我们会返回

00:17:26.209 --> 00:17:30.620
不成功，只是循环慢

00:17:28.520 --> 00:17:33.620
通过或成功，我们只是重试

00:17:30.620 --> 00:17:36.110
直到我们成功推动它

00:17:33.620 --> 00:17:38.059
模式几乎可以在每个

00:17:36.110 --> 00:17:40.820
锁树算法真的很强大

00:17:38.059 --> 00:17:41.300
模式，因为它可以让我们解决

00:17:40.820 --> 00:17:42.860
问题

00:17:41.300 --> 00:17:46.520
同时修改的数据结构

00:17:42.860 --> 00:17:49.520
我没有说任何法律

00:17:46.520 --> 00:17:53.590
那才是真正的自由行走的力量

00:17:49.520 --> 00:17:58.670
你知道，但是模式很简单

00:17:53.590 --> 00:18:01.429
我们可以类似的流行音乐，我的意思是

00:17:58.670 --> 00:18:02.990
我不会在这里一步一步走，但是

00:18:01.429 --> 00:18:04.730
这与我们当前的想法相同

00:18:02.990 --> 00:18:07.570
值，我们尝试更新

00:18:04.730 --> 00:18:11.360
成功的回报很好，如果你不尝试

00:18:07.570 --> 00:18:16.400
但请注意，在这里写下这个

00:18:11.360 --> 00:18:18.440
使用原子引用类，我的意思是

00:18:16.400 --> 00:18:20.570
让我们记住为什么我们开始做

00:18:18.440 --> 00:18:22.760
无锁，因此我们的最终目标

00:18:20.570 --> 00:18:25.130
演示是为了使可伸缩性

00:18:22.760 --> 00:18:28.580
应用程序，然后稍微扩展

00:18:25.130 --> 00:18:29.900
暗示它会很快，但是

00:18:28.580 --> 00:18:33.080
使用原子引用，我们可以创建

00:18:29.900 --> 00:18:35.000
方向的另一层而不是

00:18:33.080 --> 00:18:36.710
只是使用顶部变量

00:18:35.000 --> 00:18:38.390
我们直接创建了另一个

00:18:36.710 --> 00:18:43.760
对象原子引用，我们

00:18:38.390 --> 00:18:45.350
不断地间接去那里

00:18:43.760 --> 00:18:47.030
引用到另一个对象

00:18:45.350 --> 00:18:49.040
可能是这个小例子的关键

00:18:47.030 --> 00:18:51.200
但在更大的应用程序中，我们将有一个

00:18:49.040 --> 00:18:54.470
许多并发选项可能是

00:18:51.200 --> 00:18:56.990
可能是性能问题，所以

00:18:54.470 --> 00:18:59.300
这是一个陷阱，那么我们需要我们

00:18:56.990 --> 00:19:01.850
需要以某种方式解决它有两个

00:18:59.300 --> 00:19:04.610
解决方案首先我们会

00:19:01.850 --> 00:19:07.460
我们要做的就是

00:19:04.610 --> 00:19:09.500
直接修改节点（如果有） 

00:19:07.460 --> 00:19:12.170
实际的挥发物可能已经在

00:19:09.500 --> 00:19:14.780
您的Java或挥发性棉

00:19:12.170 --> 00:19:17.660
可以用来指定我要

00:19:14.780 --> 00:19:20.630
从多个线程修改变量

00:19:17.660 --> 00:19:22.670
这将确保所有

00:19:20.630 --> 00:19:25.220
为您查询内存语义，但我如何

00:19:22.670 --> 00:19:27.710
实际上比较并设置我可以阅读

00:19:25.220 --> 00:19:28.880
并写出来，但我怎么理解

00:19:27.710 --> 00:19:32.450
他们为此需要的操作

00:19:28.880 --> 00:19:34.820
原子更新一个解决方案是一类

00:19:32.450 --> 00:19:38.750
称为原子引用更新器

00:19:34.820 --> 00:19:42.290
也用五和约翰定义了这个Java 

00:19:38.750 --> 00:19:44.420
 1.5，这是一个非常丑陋的课程

00:19:42.290 --> 00:19:47.900
你知道它甚至是它的感觉

00:19:44.420 --> 00:19:50.030
签名看起来很吓人，使用时

00:19:47.900 --> 00:19:52.250
你必须在

00:19:50.030 --> 00:19:53.450
 Java，因为没有丑陋的代码， 

00:19:52.250 --> 00:19:56.450
这就是为什么他们在

00:19:53.450 --> 00:19:57.590
 Java，因此您必须反抗

00:19:56.450 --> 00:20:01.070
多变量

00:19:57.590 --> 00:20:03.740
而且您必须定义静态填充

00:20:01.070 --> 00:20:06.620
这就是使用此新更新或获取

00:20:03.740 --> 00:20:08.059
您的第一份工作数据很大

00:20:06.620 --> 00:20:10.580
样板甚至不适合

00:20:08.059 --> 00:20:12.799
在我的幻灯片上水平然后在

00:20:10.580 --> 00:20:15.169
代码，当您匆忙说相反

00:20:12.799 --> 00:20:17.419
像我想要的那样自然地编写它

00:20:15.169 --> 00:20:19.730
更新顶部我写得很自然

00:20:17.419 --> 00:20:21.350
我有使用此常量调用的样式

00:20:19.730 --> 00:20:22.970
比较并说出程度，就这样

00:20:21.350 --> 00:20:26.539
看起来不像

00:20:22.970 --> 00:20:30.019
样板不是真正的代码，但可以工作

00:20:26.539 --> 00:20:32.899
它让我避免了这个额外的额外领域

00:20:30.019 --> 00:20:36.019
而另一个解决方案已经出现

00:20:32.899 --> 00:20:38.120
最近在Joanna中以Java 9内置

00:20:36.019 --> 00:20:42.080
有一个叫做战争手柄的东西

00:20:38.120 --> 00:20:44.090
新的新抽象乔，我是

00:20:42.080 --> 00:20:45.919
有点类似于原子参考

00:20:44.090 --> 00:20:48.529
您也可以更新

00:20:45.919 --> 00:20:50.210
比较设置并非常使用它

00:20:48.529 --> 00:20:51.950
类似的方式只是代码

00:20:50.210 --> 00:20:54.460
争论以后，你必须写更多

00:20:51.950 --> 00:20:56.450
使用它的样板，所以我的意思是

00:20:54.460 --> 00:20:59.510
不幸的是，这是

00:20:56.450 --> 00:21:01.100
这种尊重，但你已经尝试过

00:20:59.510 --> 00:21:03.590
移动播放以初始化它的外观

00:21:01.100 --> 00:21:05.299
类似更多样板，但然后你

00:21:03.590 --> 00:21:09.860
以同样的丑陋方式再次使用它

00:21:05.299 --> 00:21:11.570
自从我写以来看起来并不自然

00:21:09.860 --> 00:21:13.519
许多无锁代码

00:21:11.570 --> 00:21:16.070
并发代码和我日常工作的一部分

00:21:13.519 --> 00:21:19.549
我不能说何时开始编码

00:21:16.070 --> 00:21:21.289
打电话给你，你开始，你开始

00:21:19.549 --> 00:21:22.789
注意所有您知道的样板

00:21:21.289 --> 00:21:24.769
因为你少了很多样板

00:21:22.789 --> 00:21:27.080
在编码中，所以您尝试

00:21:24.769 --> 00:21:28.880
尽可能地发行它，所以我写了

00:21:27.080 --> 00:21:31.100
这个非常简单的库称为atom 

00:21:28.880 --> 00:21:32.600
电话，而不是通过这个

00:21:31.100 --> 00:21:36.559
我可以写的样板

00:21:32.600 --> 00:21:39.500
好像它是原子引用一样

00:21:36.559 --> 00:21:42.529
只是有一个叫做原子的好函数

00:21:39.500 --> 00:21:45.320
相信我的感觉是真实的

00:21:42.529 --> 00:21:47.299
声明顶部事实的紧凑方法

00:21:45.320 --> 00:21:49.549
应该是包含的原子变量

00:21:47.299 --> 00:21:52.309
请注意，现在可能是现在

00:21:49.549 --> 00:21:55.850
内部就像我一样使用它

00:21:52.309 --> 00:21:58.760
与原子参考，所以我停下来

00:21:55.850 --> 00:22:01.039
比较集，仅此而已

00:21:58.760 --> 00:22:03.679
诀窍是我像原子一样编码

00:22:01.039 --> 00:22:06.590
参考，并将其编译为Java 

00:22:03.679 --> 00:22:08.809
字节码就像道一样，但是在那里

00:22:06.590 --> 00:22:12.140
一个字节码传递处理器，实际上

00:22:08.809 --> 00:22:14.120
选择此代码以使用原子编码

00:22:12.140 --> 00:22:15.740
参考资料已填满，因此在其后面

00:22:14.120 --> 00:22:18.080
因为是这样，我不必写这个

00:22:15.740 --> 00:22:19.820
样板，我让写这个

00:22:18.080 --> 00:22:21.710
对我来说就是样板

00:22:19.820 --> 00:22:23.720
那是什么样的

00:22:21.710 --> 00:22:26.090
你知道计算机的进步

00:22:23.720 --> 00:22:27.890
像你一样编程

00:22:26.090 --> 00:22:30.110
知道你进入高水平

00:22:27.890 --> 00:22:31.850
断言你让工具做样板

00:22:30.110 --> 00:22:33.200
为你，他们不写你自己

00:22:31.850 --> 00:22:35.570
好东西，没有

00:22:33.200 --> 00:22:37.549
改变我的来源，我可以翻转和

00:22:35.570 --> 00:22:40.429
切换并发出代码

00:22:37.549 --> 00:22:42.429
使用更多的手柄，所以我不必

00:22:40.429 --> 00:22:45.230
为此更改一行代码

00:22:42.429 --> 00:22:45.950
当然，问题是

00:22:45.230 --> 00:22:48.049
值得

00:22:45.950 --> 00:22:50.809
好的，所以我们做的所有步骤都会学到

00:22:48.049 --> 00:22:53.330
怎么写无锁堆栈

00:22:50.809 --> 00:22:55.669
甚至学习如何写，所以很好

00:22:53.330 --> 00:23:00.770
你知道并且可以解决不同的问题

00:22:55.669 --> 00:23:03.610
 api的但阿迪喜欢为什么我们做了什么

00:23:00.770 --> 00:23:06.559
赢什么，让我们衡量一下， 

00:23:03.610 --> 00:23:10.549
当我们测量它时，您知道结果

00:23:06.559 --> 00:23:13.399
想要看起来他们有点混杂，所以

00:23:10.549 --> 00:23:15.590
单线程的情况下肯定有

00:23:13.399 --> 00:23:19.299
赢了，这是我们的优势之一

00:23:15.590 --> 00:23:22.130
他们拥有更多的算法

00:23:19.299 --> 00:23:24.020
没有的时候他们会表现得更好

00:23:22.130 --> 00:23:25.669
争用单线程情况，但

00:23:24.020 --> 00:23:28.490
不幸的是，这有点争执

00:23:25.669 --> 00:23:30.890
情况下，随着您

00:23:28.490 --> 00:23:36.860
我们正在努力，如果不做得更糟

00:23:30.890 --> 00:23:39.679
比它与日志工作的原因，为什么呢？ 

00:23:36.860 --> 00:23:41.659
快三分之一的情况是

00:23:39.679 --> 00:23:45.440
很明显，因为我们没有锁

00:23:41.659 --> 00:23:48.950
开销要少得多，但为什么我们要

00:23:45.440 --> 00:23:51.770
结果像几个

00:23:48.950 --> 00:23:53.779
每秒减少的操作次数

00:23:51.770 --> 00:23:55.279
事工的原因是

00:23:53.779 --> 00:23:56.960
水算法也遭受

00:23:55.279 --> 00:23:59.840
竞争，但他们遭受

00:23:56.960 --> 00:24:02.390
不同的方式，因为当锁自由

00:23:59.840 --> 00:24:05.000
日志准备与第二个准备工作重叠

00:24:02.390 --> 00:24:07.159
不只是等到第一个

00:24:05.000 --> 00:24:09.740
完成它浪费了整个工作

00:24:07.159 --> 00:24:12.049
尝试这样做，因为它试图

00:24:09.740 --> 00:24:14.029
更新，但随后遇到

00:24:12.049 --> 00:24:17.030
其他线程想要比赛并且做到了

00:24:14.029 --> 00:24:19.240
之前做过，所以必须尝试整个

00:24:17.030 --> 00:24:21.130
操作，所以

00:24:19.240 --> 00:24:24.250
关于日志准备的争论事实是

00:24:21.130 --> 00:24:27.400
当然更明显

00:24:24.250 --> 00:24:28.840
橄榄有很多技术

00:24:27.400 --> 00:24:31.059
这个问题有很多论文

00:24:28.840 --> 00:24:33.790
如何为算法赚钱

00:24:31.059 --> 00:24:36.880
基本上是通过做一些你知道的技巧

00:24:33.790 --> 00:24:39.220
指数回退适当的旋转

00:24:36.880 --> 00:24:42.490
 ceteris更好的其他人更糟糕的组合器

00:24:39.220 --> 00:24:45.880
许多适用这些的论文是

00:24:42.490 --> 00:24:48.220
在某些情况下的技巧

00:24:45.880 --> 00:24:50.830
可以真正获得

00:24:48.220 --> 00:24:53.950
对数与全部同步

00:24:50.830 --> 00:24:56.650
然后在保持这种情况下

00:24:53.950 --> 00:24:59.230
在非集装箱敲门

00:24:56.650 --> 00:25:01.480
情况下，但我们不打算讨论

00:24:59.230 --> 00:25:03.010
我的意思是因为通常练习

00:25:01.480 --> 00:25:05.940
你永远不需要这种前进

00:25:03.010 --> 00:25:09.120
技术，现在我将向您展示为什么

00:25:05.940 --> 00:25:12.760
首先让我们看看我们是否有

00:25:09.120 --> 00:25:14.080
我们的问题是先像我们一样玩

00:25:12.760 --> 00:25:16.179
我们所看到的所有问题

00:25:14.080 --> 00:25:19.750
从堆栈开始不是什么

00:25:16.179 --> 00:25:21.910
您通常会与您的

00:25:19.750 --> 00:25:23.530
数据结构更复杂， 

00:25:21.910 --> 00:25:25.780
他们只是一堆，你也许有一些

00:25:23.530 --> 00:25:28.240
你知道代码数据库就是你的

00:25:25.780 --> 00:25:32.679
同时更新或其他

00:25:28.240 --> 00:25:35.050
那就是更新它需要

00:25:32.679 --> 00:25:39.670
更多的时间，让我们尝试模拟

00:25:35.050 --> 00:25:43.420
让我们来添加让我们来更多

00:25:39.670 --> 00:25:45.070
真实，但您知道人为膨胀

00:25:43.420 --> 00:25:47.380
我们目前的运营时间

00:25:45.070 --> 00:25:50.710
只是花一些时间和地点，我们会

00:25:47.380 --> 00:25:53.260
为我们的算法轮做这两个

00:25:50.710 --> 00:25:55.570
锁和锁的相同更改

00:25:53.260 --> 00:25:59.429
实施，让我们看看他们如何

00:25:55.570 --> 00:26:04.300
表现那就是我们所看到的，因为我们已经

00:25:59.429 --> 00:26:06.309
我们的运营时间更长了我们不是

00:26:04.300 --> 00:26:07.750
我们在那里看不出太大的区别

00:26:06.309 --> 00:26:11.740
单线程性能不再

00:26:07.750 --> 00:26:15.100
因为这里的锁现在是

00:26:11.740 --> 00:26:18.340
与运营成本相比较小

00:26:15.100 --> 00:26:21.520
本身，但我们仍然看到那个锁三

00:26:18.340 --> 00:26:24.100
算法在这里不闪耀

00:26:21.520 --> 00:26:26.230
争夺同样的规则

00:26:24.100 --> 00:26:28.600
知道在竞争锁度下，但是

00:26:26.230 --> 00:26:33.170
现在它们像没有这个一样退化

00:26:28.600 --> 00:26:35.060
奇怪的D垫到线程情况下，但

00:26:33.170 --> 00:26:36.260
他们保持不变的退化

00:26:35.060 --> 00:26:38.570
相当稳定且无锁

00:26:36.260 --> 00:26:41.090
算法在竞争下退化

00:26:38.570 --> 00:26:43.220
因为他们又遇到了同样的问题

00:26:41.090 --> 00:26:45.680
重试现在已成为的操作

00:26:43.220 --> 00:26:47.330
更复杂，但顺便说一句

00:26:45.680 --> 00:26:52.820
他们的表现差异较小

00:26:47.330 --> 00:26:54.350
有人，所以我保证在这里是

00:26:52.820 --> 00:26:55.190
无锁应该很好，那是什么

00:26:54.350 --> 00:26:57.800
什么原因

00:26:55.190 --> 00:27:00.140
让我们尝试为这

00:26:57.800 --> 00:27:04.790
工作量真的代表什么

00:27:00.140 --> 00:27:07.100
我们处理我们的数据结构

00:27:04.790 --> 00:27:08.990
当然不是因为通常当我们

00:27:07.100 --> 00:27:10.340
有这样的大数据问题

00:27:08.990 --> 00:27:12.890
实时更新

00:27:10.340 --> 00:27:15.920
通常它偶尔会更新

00:27:12.890 --> 00:27:17.740
与查询数量相比

00:27:15.920 --> 00:27:21.710
在那儿读书-您正在反对

00:27:17.740 --> 00:27:25.010
那是很常见的模式

00:27:21.710 --> 00:27:27.230
当您在大数据中面对这种能力时

00:27:25.010 --> 00:27:29.600
问题是因为如果数据很大，您

00:27:27.230 --> 00:27:33.050
只知道其中的一小部分

00:27:29.600 --> 00:27:36.020
更新，以便每条数据都更新

00:27:33.050 --> 00:27:38.510
与数量相比相对稀有

00:27:36.020 --> 00:27:42.800
病毒报告和读取操作

00:27:38.510 --> 00:27:45.320
拥有-必须看到什么

00:27:42.800 --> 00:27:48.290
当前值是，所以我们将工作量

00:27:45.320 --> 00:27:54.140
主要是为了模拟

00:27:48.290 --> 00:27:57.800
这将添加我们将添加我们的操作

00:27:54.140 --> 00:27:59.810
将被扭曲推和流行会做

00:27:57.800 --> 00:28:02.600
一些杂草会在顶部

00:27:59.810 --> 00:28:03.020
堆栈测量是一个，将执行十

00:28:02.600 --> 00:28:06.130
次

00:28:03.020 --> 00:28:10.400
所以这基本上是十比一

00:28:06.130 --> 00:28:12.820
实际上有十个耳语扰动日期

00:28:10.400 --> 00:28:15.140
我们在高峰运营中的工作量

00:28:12.820 --> 00:28:17.660
同步实现很容易

00:28:15.140 --> 00:28:21.340
我们只是达到您的战争而已

00:28:17.660 --> 00:28:23.600
如果为null，请立即返回以获取无锁

00:28:21.340 --> 00:28:26.720
实现起来也很容易

00:28:23.600 --> 00:28:30.470
同样的变化，你知道枯萎， 

00:28:26.720 --> 00:28:33.680
实现锁读取的峰值，特别是

00:28:30.470 --> 00:28:37.040
简单的植入，让我们看看是什么

00:28:33.680 --> 00:28:37.580
现在，图片完全是

00:28:37.040 --> 00:28:42.050
不同

00:28:37.580 --> 00:28:43.940
首先锁的吞吐量

00:28:42.050 --> 00:28:46.130
从现在开始到现在

00:28:43.940 --> 00:28:48.620
表现优于

00:28:46.130 --> 00:28:51.230
他们现在仅次于

00:28:48.620 --> 00:28:54.050
在越来越多的情况下赶上

00:28:51.230 --> 00:28:56.060
威胁威胁，这很明显

00:28:54.050 --> 00:28:58.730
演示被锁定的免费算法

00:28:56.060 --> 00:29:01.100
编钟劳弗算法在杂草中闪耀

00:28:58.730 --> 00:29:03.800
阅读您的工作负载时

00:29:01.100 --> 00:29:07.700
数据比您更新的频率要高得多

00:29:03.800 --> 00:29:11.030
他们，因为无锁杂草不会

00:29:07.700 --> 00:29:13.070
永远没有循环，没有理由

00:29:11.030 --> 00:29:14.750
储物柜算法永远不会遭受

00:29:13.070 --> 00:29:16.460
他们可以除草

00:29:14.750 --> 00:29:18.350
杂草的当前值

00:29:16.460 --> 00:29:20.900
同步的数据结构

00:29:18.350 --> 00:29:24.290
受日志保护，他们必须受苦

00:29:20.900 --> 00:29:26.390
他们必须等到作家

00:29:24.290 --> 00:29:29.330
改变他们的修改，不是

00:29:26.390 --> 00:29:30.860
你看到的不是你知道一些

00:29:29.330 --> 00:29:33.950
人们认为哦，没问题，我只是

00:29:30.860 --> 00:29:37.190
从莫里斯删除同步不是

00:29:33.950 --> 00:29:38.900
这么简单，因为删除的能力

00:29:37.190 --> 00:29:40.370
这个罪恶问题或可能

00:29:38.900 --> 00:29:42.530
取决于它是什么数据结构

00:29:40.370 --> 00:29:45.080
基本上取决于您是否可以做

00:29:42.530 --> 00:29:46.610
它至少半免费，然后可以再次

00:29:45.080 --> 00:29:48.680
您拍摄原木进行除草

00:29:46.610 --> 00:29:51.710
例如，如果您使用常规哈希图

00:29:48.680 --> 00:29:53.960
在GDK中，您认为哦，您

00:29:51.710 --> 00:29:55.970
知道每个哈希最大同步

00:29:53.960 --> 00:29:58.310
越来越贵，让我们听听

00:29:55.970 --> 00:30:00.110
当我放入哈希图时的翻译

00:29:58.310 --> 00:30:01.610
并留下我所有的哈希图不

00:30:00.110 --> 00:30:04.270
纯格式的惊喜，因为您

00:30:01.610 --> 00:30:08.210
知道，因为那不会让我缩放

00:30:04.270 --> 00:30:11.210
然后您会发现它并没有

00:30:08.210 --> 00:30:12.800
工作，我是说我看过

00:30:11.210 --> 00:30:15.800
人们忘记的生产

00:30:12.800 --> 00:30:18.770
同步读取，您知道哈希

00:30:15.800 --> 00:30:21.130
将您的手映射到某个时刻

00:30:18.770 --> 00:30:24.050
开始阅读而没有

00:30:21.130 --> 00:30:26.780
同步你最终会陷入疯狂

00:30:24.050 --> 00:30:29.030
指出读取的不是

00:30:26.780 --> 00:30:31.640
只同步一次

00:30:29.030 --> 00:30:34.370
无限循环，所以不是每个结构

00:30:31.640 --> 00:30:36.800
除非数据旨在允许

00:30:34.370 --> 00:30:40.700
锁定杂草，你可以调整说好吧

00:30:36.800 --> 00:30:42.470
不需要锁定就可以阅读，但是

00:30:40.700 --> 00:30:44.570
让我们看看有兴趣看看会发生什么

00:30:42.470 --> 00:30:47.210
如果您阅读更多

00:30:44.570 --> 00:30:49.850
有一百次阅读，您认为

00:30:47.210 --> 00:30:53.389
洛克瑞变得更好，就像它

00:30:49.850 --> 00:30:57.440
现在明显胜过明显

00:30:53.389 --> 00:30:59.959
限制，但请参阅我将深入了解

00:30:57.440 --> 00:31:00.529
还是一个线程，速度越快

00:30:59.959 --> 00:31:02.419
威胁

00:31:00.529 --> 00:31:05.779
你知道慢一点，但是在哪里

00:31:02.419 --> 00:31:08.899
可扩展性，所以整个主题

00:31:05.779 --> 00:31:11.269
谈话是Caleb，在这里我向您展示

00:31:08.899 --> 00:31:13.219
大多数情况下，您添加的速度会变慢

00:31:11.269 --> 00:31:16.879
起作用，那么什么是重点

00:31:13.219 --> 00:31:19.669
具有如此庞大的32个硬件线程

00:31:16.879 --> 00:31:21.909
计算机运行此代码（如果有） 

00:31:19.669 --> 00:31:25.609
更大的压力只会使一切变得艰难

00:31:21.909 --> 00:31:26.659
原因是我们的工作量

00:31:25.609 --> 00:31:31.099
有人造的

00:31:26.659 --> 00:31:34.339
实际上，您永远不会喜欢所有的

00:31:31.099 --> 00:31:36.469
 badge到一天

00:31:34.339 --> 00:31:39.739
永远不会出现这种情况的失真

00:31:36.469 --> 00:31:42.279
知道您是否有共享数据

00:31:39.739 --> 00:31:44.779
在代码中共享可变数据

00:31:42.279 --> 00:31:46.429
通常带有一些东西，那么你

00:31:44.779 --> 00:31:49.070
用它做点事

00:31:46.429 --> 00:31:51.139
计算处理不像你

00:31:49.070 --> 00:31:52.969
读它读它不断读它是

00:31:51.139 --> 00:31:56.229
从来没有那样，你不更新

00:31:52.969 --> 00:31:58.579
控制台永远不会像你一样

00:31:56.229 --> 00:32:01.159
从网络解析接收一些数据

00:31:58.579 --> 00:32:04.940
更新后，您会提出一些要求

00:32:01.159 --> 00:32:07.459
读一些数据做一些处理回复

00:32:04.940 --> 00:32:09.739
你知道它永远不会Unicode永远不会更好

00:32:07.459 --> 00:32:11.479
罪恶你知道的单身一天

00:32:09.739 --> 00:32:13.009
一直在搜索一些工作规律

00:32:11.479 --> 00:32:14.899
到目前为止，我们将进行测量

00:32:13.009 --> 00:32:17.029
完全不代表

00:32:14.899 --> 00:32:19.190
实际的亲密接触

00:32:17.029 --> 00:32:20.269
练习练习，你的衣服会

00:32:19.190 --> 00:32:22.579
看起来像这样

00:32:20.269 --> 00:32:26.059
这是我们可以建模的最好的方法

00:32:22.579 --> 00:32:28.639
现实生活中的工作量

00:32:26.059 --> 00:32:31.009
微测试，所以我们只消耗一些

00:32:28.639 --> 00:32:32.839
您之间的CPU知道我们要做的每一件事

00:32:31.009 --> 00:32:34.779
模拟真实的事实

00:32:32.839 --> 00:32:37.519
您正在执行的应用程序

00:32:34.779 --> 00:32:41.929
不只是读书，当然

00:32:37.519 --> 00:32:48.190
我们会尽力做到这一点

00:32:41.929 --> 00:32:53.149
免费锁定并链接实现和

00:32:48.190 --> 00:32:55.639
让我们看看会发生什么，那就是

00:32:53.149 --> 00:32:59.419
我们可以清楚地看到这个规模

00:32:55.639 --> 00:33:03.829
我最初答应你是因为你

00:32:59.419 --> 00:33:05.869
看到这里，现在实际上都是链接

00:33:03.829 --> 00:33:07.450
堆栈，随着我的增加而无锁

00:33:05.869 --> 00:33:09.789
的数量

00:33:07.450 --> 00:33:14.200
当我运行代码时，我得到了更多的特权

00:33:09.789 --> 00:33:16.030
每秒，因为您知道他们可以做到

00:33:14.200 --> 00:33:19.150
更多的同时处理

00:33:16.030 --> 00:33:21.840
你会看到更多的

00:33:19.150 --> 00:33:24.700
错误加剧了无锁的可扩展性

00:33:21.840 --> 00:33:26.860
明显优于链接的可伸缩性

00:33:24.700 --> 00:33:29.440
如果他们现在开始，他们将从某个地方开始

00:33:26.860 --> 00:33:31.840
点，因为相比于成本

00:33:29.440 --> 00:33:35.039
其他的其他CPU费用

00:33:31.840 --> 00:33:39.700
操作是相同的，他们的未成年人

00:33:35.039 --> 00:33:43.210
与你知道的相比

00:33:39.700 --> 00:33:45.460
我们添加的但作为第一的数量

00:33:43.210 --> 00:33:48.340
增加，我们看到拉的争吵

00:33:45.460 --> 00:33:49.600
法洛德尔的床很干净

00:33:48.340 --> 00:33:51.309
其实，是

00:33:49.600 --> 00:33:53.950
我们的机器有多少个硬件线程

00:33:51.309 --> 00:33:56.500
有，因为你看到它在增加

00:33:53.950 --> 00:33:59.679
直到我们有32个线程为止

00:33:56.500 --> 00:34:01.510
然后说公寓，因为我的意思是

00:33:59.679 --> 00:34:04.780
没有理由再有更多了

00:34:01.510 --> 00:34:07.780
威胁比我以前的机器要好

00:34:04.780 --> 00:34:10.359
运行它只有32个线程，所以

00:34:07.780 --> 00:34:11.679
添加物理您知道的硬件

00:34:10.359 --> 00:34:15.280
线程如此

00:34:11.679 --> 00:34:18.399
你知道线程，因为我们所有的威胁

00:34:15.280 --> 00:34:20.470
正在消耗他们需要的CPU 

00:34:18.399 --> 00:34:24.700
没有任何好处，但好处是

00:34:20.470 --> 00:34:26.470
不会损害实际尺寸

00:34:24.700 --> 00:34:29.710
看不到的线程数

00:34:26.470 --> 00:34:31.300
当我们过度订阅时下降

00:34:29.710 --> 00:34:33.730
机器，这对于

00:34:31.300 --> 00:34:35.770
实际应用，因为您知道

00:34:33.730 --> 00:34:39.460
在实践中，如果你特别是如果你

00:34:35.770 --> 00:34:42.790
异常世界中带有线程的程序

00:34:39.460 --> 00:34:45.580
您可能出于病毒原因可能有

00:34:42.790 --> 00:34:48.040
比您拥有的CPU核心更多的威胁

00:34:45.580 --> 00:34:49.419
例如在工作时的贝因

00:34:48.040 --> 00:34:51.609
精通其余应用程序

00:34:49.419 --> 00:34:54.790
看到运行数百个应用程序

00:34:51.609 --> 00:34:58.270
在支持的机器上大量线程化

00:34:54.790 --> 00:35:00.160
只有64个硬件线程，那就是

00:34:58.270 --> 00:35:01.869
正常，因为您可能需要

00:35:00.160 --> 00:35:03.880
那数百个人使用数据库或

00:35:01.869 --> 00:35:07.060
与其他阻止操作，但

00:35:03.880 --> 00:35:08.380
同时在我的应用程序中，我有一些

00:35:07.060 --> 00:35:10.420
共享的数据结构，例如

00:35:08.380 --> 00:35:11.589
不断更新，我想阅读

00:35:10.420 --> 00:35:13.630
他们要做

00:35:11.589 --> 00:35:17.170
 baris分析，例如找出问题所在

00:35:13.630 --> 00:35:20.770
当前的股价以及那些

00:35:17.170 --> 00:35:23.320
你知道我想扩大规模

00:35:20.770 --> 00:35:27.370
希望访问共享数据的速度变慢

00:35:23.320 --> 00:35:31.060
剩下的工作我想

00:35:27.370 --> 00:35:33.580
尽可能少的障碍，并且

00:35:31.060 --> 00:35:35.440
那是很好，那是你知道的

00:35:33.580 --> 00:35:44.530
数字，我认为你做到了，并没有成为

00:35:35.440 --> 00:35:47.530
更糟糕的是，这里的教训

00:35:44.530 --> 00:35:49.840
是我们测量时需要的

00:35:47.530 --> 00:35:51.730
我们需要确保性能

00:35:49.840 --> 00:35:54.250
问正确的问题是最

00:35:51.730 --> 00:35:55.750
挑战实际任务进行衡量

00:35:54.250 --> 00:35:58.060
性能，尤其是并发代码

00:35:55.750 --> 00:36:00.460
特别是如果您要

00:35:58.060 --> 00:36:03.100
评估这种短暂的特征

00:36:00.460 --> 00:36:05.590
就像可扩展性一样

00:36:03.100 --> 00:36:09.010
问题，喜欢建模

00:36:05.590 --> 00:36:13.840
工作量真的是锻炼，它值得

00:36:09.010 --> 00:36:15.610
因此，如果您沉迷于

00:36:13.840 --> 00:36:21.610
确保你有秤

00:36:15.610 --> 00:36:24.880
我的意思是永远不要你不知道

00:36:21.610 --> 00:36:26.440
就像你可以知道你吃这个

00:36:24.880 --> 00:36:28.030
尝试为您的模型建模

00:36:26.440 --> 00:36:29.590
我的工作流程是对工作流程进行建模

00:36:28.030 --> 00:36:31.780
很重要，因为如果您不建模

00:36:29.590 --> 00:36:32.950
您的流程正确，您没有得到

00:36:31.780 --> 00:36:34.930
正确答案

00:36:32.950 --> 00:36:37.600
测量，然后当你有一个

00:36:34.930 --> 00:36:39.340
您认识的工作流程的绝佳模型

00:36:37.600 --> 00:36:40.960
那你可以比较一下

00:36:39.340 --> 00:36:42.760
实现，看看是否有

00:36:40.960 --> 00:36:44.400
阅读器管理员的工作量和实际

00:36:42.760 --> 00:36:47.410
生活条件无锁

00:36:44.400 --> 00:36:49.840
算法通常胜过

00:36:47.410 --> 00:36:52.390
谁有原木，如果想要的话

00:36:49.840 --> 00:36:55.140
进一步了解这是真的

00:36:52.390 --> 00:36:58.470
我会推荐的一本好书是

00:36:55.140 --> 00:37:02.830
 Brian的Java并发和实践

00:36:58.470 --> 00:37:05.050
对从业者来说真的是一本好书

00:37:02.830 --> 00:37:06.880
它唯一的缺点

00:37:05.050 --> 00:37:10.270
 Java中的示例，这也有点

00:37:06.880 --> 00:37:13.390
冗长，但我的意思是容易

00:37:10.270 --> 00:37:15.520
翻译成加泰罗尼亚语II，你知道

00:37:13.390 --> 00:37:17.530
为您节省了很多打字时间，但是

00:37:15.520 --> 00:37:19.990
另一本书更多是从理论上讲的

00:37:17.530 --> 00:37:22.450
立场，他们是最处理器

00:37:19.990 --> 00:37:25.020
你好编程这里有一点，它

00:37:22.450 --> 00:37:26.290
深入研究

00:37:25.020 --> 00:37:28.660
并发

00:37:26.290 --> 00:37:29.410
解释了很多有趣的

00:37:28.660 --> 00:37:32.900
不平凡的

00:37:29.410 --> 00:37:36.529
深入了解无锁算法

00:37:32.900 --> 00:37:38.690
因此，对于任何有兴趣的人或- 

00:37:36.529 --> 00:37:40.430
三阶是两块钱

00:37:38.690 --> 00:37:41.839
可以从任何一个开始，具体取决于

00:37:40.430 --> 00:37:44.019
你的想法像你一样

00:37:41.839 --> 00:37:47.239
理论上或实践上倾向于

00:37:44.019 --> 00:37:51.859
在那里-很好的互补

00:37:47.239 --> 00:37:54.410
非常好，非常好阅读， 

00:37:51.859 --> 00:37:57.469
最后一些链接，所以我希望

00:37:54.410 --> 00:38:00.049
幻灯片将被张贴，以适应健身年龄

00:37:57.469 --> 00:38:01.609
我用来基准测试

00:38:00.049 --> 00:38:04.460
引用我使用的内容

00:38:01.609 --> 00:38:06.920
例子和原子食物让我

00:38:04.460 --> 00:38:09.880
简明扼要地写下来

00:38:06.920 --> 00:38:19.519
方式，我很开放

00:38:09.880 --> 00:38:20.930
是的，您可以在工作台管理的图像上运行它

00:38:19.519 --> 00:38:24.410
以及您想要的威胁数量

00:38:20.930 --> 00:38:27.650
它将与威胁一样多

00:38:24.410 --> 00:38:29.749
你问它是因为我的状态

00:38:27.650 --> 00:38:31.729
被称为每个基准有一个范围

00:38:29.749 --> 00:38:34.940
基准注释，因此它将共享

00:38:31.729 --> 00:38:39.440
所有压力和它之间的这种状态

00:38:34.940 --> 00:38:41.660
只是他们很好地使用了操作

00:38:39.440 --> 00:38:43.849
第二，在我的假期中，这是

00:38:41.660 --> 00:38:46.249
这是我的基准测试方法， 

00:38:43.849 --> 00:38:50.289
我显示的指标是向上操作

00:38:46.249 --> 00:38:52.670
是对此功能的一次调用

00:38:50.289 --> 00:38:54.769
成功完成的方法数量

00:38:52.670 --> 00:38:57.349
每秒的医疗数据就是

00:38:54.769 --> 00:38:59.180
在Gmail中只是默认值

00:38:57.349 --> 00:39:01.700
您可以配置要查看的内容

00:38:59.180 --> 00:39:04.059
你可以看到大概九秒钟

00:39:01.700 --> 00:39:07.599
或微秒，但默认值为

00:39:04.059 --> 00:39:07.599
每秒操作

00:39:11.289 --> 00:39:14.839
是的，当然有很多没有

00:39:13.430 --> 00:39:17.180
我实际上有很多方法

00:39:14.839 --> 00:39:19.190
如果你读这本书，那么整个

00:39:17.180 --> 00:39:21.440
关于病毒技术的章节

00:39:19.190 --> 00:39:24.500
最好有一整章，我是说我

00:39:21.440 --> 00:39:27.680
只是这个监狱太小了而已

00:39:24.500 --> 00:39:29.180
我的目标是如果你感兴趣的话

00:39:27.680 --> 00:39:44.059
如果你想知道怎么做

00:39:29.180 --> 00:39:46.490
看过这本书，对不起，是的

00:39:44.059 --> 00:39:48.049
 Java首先是很多库

00:39:46.490 --> 00:39:49.880
库包含一些用于

00:39:48.049 --> 00:39:52.490
标准库中的算法，例如

00:39:49.880 --> 00:39:56.630
并发哈希阶段图和

00:39:52.490 --> 00:39:59.059
其他并发跳过列表，所以

00:39:56.630 --> 00:40:01.190
我从实践中发现的井

00:39:59.059 --> 00:40:03.140
经验，如果你面对现实生活

00:40:01.190 --> 00:40:06.039
问题问题是锁定算法

00:40:03.140 --> 00:40:08.390
他们不写作，所以有人给了我

00:40:06.039 --> 00:40:10.280
你知道准备使用并发哈希

00:40:08.390 --> 00:40:13.220
地图和我有一点不同

00:40:10.280 --> 00:40:15.140
像某些操作一样的问题

00:40:13.220 --> 00:40:17.150
天生的支持，我不能不像我

00:40:15.140 --> 00:40:18.710
不能只是扩展它，我没有办法

00:40:17.150 --> 00:40:20.569
必须重写整个数据结构

00:40:18.710 --> 00:40:22.490
从头开始，所以在实践中

00:40:20.569 --> 00:40:25.400
真正面对可扩展性挑战

00:40:22.490 --> 00:40:28.069
生活中，你几乎总是发现没有

00:40:25.400 --> 00:40:30.470
现有的控制器可以解决您的问题

00:40:28.069 --> 00:40:31.970
你想要的方式还是要写

00:40:30.470 --> 00:40:33.529
从头开始，它又一次没有

00:40:31.970 --> 00:40:35.270
经常发生，因为大部分损害

00:40:33.529 --> 00:40:37.130
编写代码就可以了

00:40:35.270 --> 00:40:39.020
并发症类型大多数代码

00:40:37.130 --> 00:40:41.329
只是对性能完全不敏感

00:40:39.020 --> 00:40:43.579
最多只有您代码的百分之一

00:40:41.329 --> 00:40:46.039
需要对可伸缩性的关注

00:40:43.579 --> 00:40:48.920
表演和平时写作

00:40:46.039 --> 00:40:50.960
特别是如果再次

00:40:48.920 --> 00:40:52.549
您的业​​务领域在哪里

00:40:50.960 --> 00:40:54.920
如果您在乎公车，性能很重要

00:40:52.549 --> 00:40:57.020
代码，如果您想分析这个真实的

00:40:54.920 --> 00:40:59.569
术语大数据工作服，那么

00:40:57.020 --> 00:41:03.130
通常以书面形式还清

00:40:59.569 --> 00:41:03.130
您自己的自定义无效

00:41:08.089 --> 00:41:13.009
哦，那是一个非常困难的问题

00:41:09.829 --> 00:41:15.739
我的意思是那里是一个繁荣的地区

00:41:13.009 --> 00:41:18.670
研究，我们有很多

00:41:15.739 --> 00:41:21.140
产生这些证明的正式方法

00:41:18.670 --> 00:41:23.299
问题是所有形式上的方法

00:41:21.140 --> 00:41:25.640
首先，他们没有扩大规模

00:41:23.299 --> 00:41:27.829
信标复杂算法第二

00:41:25.640 --> 00:41:30.920
问题就像你写一些

00:41:27.829 --> 00:41:32.479
使用特殊语言编写代码

00:41:30.920 --> 00:41:34.609
批准将证明您的代码，但

00:41:32.479 --> 00:41:37.489
那么复杂的问题你怎么

00:41:34.609 --> 00:41:39.380
将此经过验证的算法转换为

00:41:37.489 --> 00:41:41.839
实际代码如何确保您拥有

00:41:39.380 --> 00:41:45.109
没有引入任何背景错误

00:41:41.839 --> 00:41:47.329
同时进行切换，所以这是什么

00:41:45.109 --> 00:41:50.689
一个更实际的实用问题是

00:41:47.329 --> 00:41:51.979
我该如何测试正确和正确的

00:41:50.689 --> 00:41:53.630
这个目的有一堆

00:41:51.979 --> 00:41:55.489
性框架我没有

00:41:53.630 --> 00:41:59.539
如果您使用google链接

00:41:55.489 --> 00:42:01.339
例子有链接检查打开

00:41:59.539 --> 00:42:03.410
来源ELISA，例如检查单板

00:42:01.339 --> 00:42:06.170
您的数据结构的能力和

00:42:03.410 --> 00:42:07.579
多线程，不是，不是

00:42:06.170 --> 00:42:10.880
向您证明一切，但可以让您

00:42:07.579 --> 00:42:13.130
快速找到您常见的常见错误

00:42:10.880 --> 00:42:14.719
做到了，我会证明这是

00:42:13.130 --> 00:42:17.089
我们其余的人我一直在参与

00:42:14.719 --> 00:42:20.719
在其设计中，您知道并创造了

00:42:17.089 --> 00:42:22.489
这个工具，所以不是工具

00:42:20.719 --> 00:42:24.829
没什么，你知道的

00:42:22.489 --> 00:42:26.689
设计不幸的是，这仍然

00:42:24.829 --> 00:42:29.679
希望有人解决这个问题

00:42:26.689 --> 00:42:32.679
在未来的某个时候

00:42:29.679 --> 00:42:32.679
是的

00:42:39.540 --> 00:42:48.990
如果您要替换的是Java 

00:42:44.520 --> 00:42:50.250
与我的口哨声同步

00:42:48.990 --> 00:42:53.100
正确的下沉，所以你尿尿是的，你可以

00:42:50.250 --> 00:42:55.620
替换与javis租用同步

00:42:53.100 --> 00:42:57.360
锁你会得到大致相同

00:42:55.620 --> 00:42:59.280
性能我的意思是因为里面

00:42:57.360 --> 00:43:03.930
他们非常相似，我是说

00:42:59.280 --> 00:43:05.700
同步，只需更少的代码

00:43:03.930 --> 00:43:07.950
棉花中的再烧结块

00:43:05.700 --> 00:43:09.750
有一个很好的扩展，所以你可以做

00:43:07.950 --> 00:43:11.580
它与锁模型，所以它实际上是

00:43:09.750 --> 00:43:13.890
使用互锁方式更多

00:43:11.580 --> 00:43:15.810
 DSL使棉质穿着舒适

00:43:13.890 --> 00:43:17.610
棉花的性质，所以你写的少得多

00:43:15.810 --> 00:43:19.290
代码，因为在Java中

00:43:17.610 --> 00:43:21.120
广泛的样板，所以在Java中， 

00:43:19.290 --> 00:43:23.100
通常使用同步只是因为

00:43:21.120 --> 00:43:25.530
使用您输入的储物柜只会产生

00:43:23.100 --> 00:43:29.130
线和点燃棉花样板

00:43:25.530 --> 00:43:31.670
不是什么大问题，但从

00:43:29.130 --> 00:43:34.200
可扩展性的观点没有成功

00:43:31.670 --> 00:43:35.820
人们使用房租的原因

00:43:34.200 --> 00:43:37.770
锁是完全不同的原因

00:43:35.820 --> 00:43:40.680
人们会使用您的终止锁，如果

00:43:37.770 --> 00:43:42.720
他们想要的是他们非常复杂

00:43:40.680 --> 00:43:44.010
具有很多锁的数据结构

00:43:42.720 --> 00:43:45.840
设计是一个挑战，因为您

00:43:44.010 --> 00:43:47.670
必须确保您不要尝试

00:43:45.840 --> 00:43:50.370
僵局，他们想移交

00:43:47.670 --> 00:43:51.690
锁定他们想要一把锁，但是

00:43:50.370 --> 00:43:53.430
然后另一个然后是真的

00:43:51.690 --> 00:43:54.720
一个没有办法可以做到

00:43:53.430 --> 00:43:56.130
 Java已同步但与您的

00:43:54.720 --> 00:43:58.470
可以互锁，因为您可以

00:43:56.130 --> 00:44:00.300
控制输入​​您的锁定邀请

00:43:58.470 --> 00:44:02.340
并锁定，但从性能开始

00:44:00.300 --> 00:44:04.700
那里没有风

00:44:02.340 --> 00:44:04.700
讲台

00:44:09.410 --> 00:44:14.010
是的，你可以做到的

00:44:12.030 --> 00:44:15.450
有办法，是的，有

00:44:14.010 --> 00:44:16.110
其实有东西叫达到

00:44:15.450 --> 00:44:19.290
辫子

00:44:16.110 --> 00:44:20.910
所以你可以单独使用

00:44:19.290 --> 00:44:23.100
读锁，但问题是

00:44:20.910 --> 00:44:24.810
 dreadlocks这是它的来源

00:44:23.100 --> 00:44:26.790
在这里，所以我们仍然可以锁定

00:44:24.810 --> 00:44:28.080
即使你在水晶上

00:44:26.790 --> 00:44:28.770
 dreadlocks货币，这是另一种

00:44:28.080 --> 00:44:30.840
技术

00:44:28.770 --> 00:44:32.790
所以基本上当你跑到

00:44:30.840 --> 00:44:34.620
由于锁定一个而雕刻您的问题

00:44:32.790 --> 00:44:35.940
事情是去锁自由，其他去读

00:44:34.620 --> 00:44:38.070
读锁，所以有两个不同

00:44:35.940 --> 00:44:40.680
有时候你知道是不是数据

00:44:38.070 --> 00:44:42.420
结构非常复杂，可以补偿

00:44:40.680 --> 00:44:44.730
搜索难于实现的锁

00:44:42.420 --> 00:44:47.040
我的意思是，我的意思是

00:44:44.730 --> 00:44:49.500
复杂的结构如何

00:44:47.040 --> 00:44:50.700
使其自由锁定，因此通常是

00:44:49.500 --> 00:44:51.900
如果您的结构是

00:44:50.700 --> 00:44:54.270
非常简单，因此您可以使其外观

00:44:51.900 --> 00:44:56.190
如果无法将其锁定， 

00:44:54.270 --> 00:44:58.410
让它自由走走，但你仍然

00:44:56.190 --> 00:45:01.760
必须先扩大规模，然后你

00:44:58.410 --> 00:45:01.760
会和ruh dreadlocks一起去

