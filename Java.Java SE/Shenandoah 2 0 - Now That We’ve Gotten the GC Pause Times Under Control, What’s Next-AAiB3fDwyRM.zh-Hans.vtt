WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.190 --> 00:00:09.250
好吧，现在是5:30，所以我开始

00:00:05.990 --> 00:00:11.990
我是Christine Flood，我在Red Hat工作

00:00:09.250 --> 00:00:16.779
我们开发了低停顿垃圾

00:00:11.990 --> 00:00:18.949
收藏家，这是关于

00:00:16.779 --> 00:00:21.160
垃圾收集很多

00:00:18.949 --> 00:00:24.039
雪兰多厄，然后关于

00:00:21.160 --> 00:00:27.529
我们在雪兰多ah 2.0中做什么

00:00:24.039 --> 00:00:30.230
 Shenandoah 1.0在那里

00:00:27.529 --> 00:00:32.329
每个使用rail或Fedora或

00:00:30.230 --> 00:00:36.500
任何基于Linux构建的发行版

00:00:32.329 --> 00:00:39.530
那些，但是还没有开放的JDK，所以

00:00:36.500 --> 00:00:42.199
我有这些小星星幻灯片，如果你

00:00:39.530 --> 00:00:43.460
喜欢迷路，等待下一颗星星

00:00:42.199 --> 00:00:45.140
您可以回到正轨，而且

00:00:43.460 --> 00:00:48.800
排我呼吸，因为

00:00:45.140 --> 00:00:50.300
否则我讲得太快了，所以如果你

00:00:48.800 --> 00:00:51.949
在这里是我们要进行的最后一次谈话

00:00:50.300 --> 00:00:53.899
谈一些传统的半

00:00:51.949 --> 00:00:55.670
太空收藏家，然后我们要

00:00:53.899 --> 00:00:58.219
谈论基于区域的收藏家，例如

00:00:55.670 --> 00:00:59.539
智元和雪兰多我们要谈谈

00:00:58.219 --> 00:01:01.640
关于雪兰多

00:00:59.539 --> 00:01:03.649
我们要给你一些结果，我

00:01:01.640 --> 00:01:05.540
给一个可视化工具的简短演示

00:01:03.649 --> 00:01:07.189
让您一边看守

00:01:05.540 --> 00:01:09.619
你正在分配和垃圾收集

00:01:07.189 --> 00:01:11.900
它可以为您提供有关如何

00:01:09.619 --> 00:01:14.090
更好地优化您的垃圾收集

00:01:11.900 --> 00:01:16.280
您的应用程序的算法，然后

00:01:14.090 --> 00:01:17.600
我要说的是下一个什么

00:01:16.280 --> 00:01:22.040
现在我们正在努力吗

00:01:17.600 --> 00:01:23.360
如此传统的半空间

00:01:22.040 --> 00:01:25.340
垃圾收集算法，如果您

00:01:23.360 --> 00:01:26.810
在这里为吉尔的演讲你看到了很多

00:01:25.340 --> 00:01:30.110
我会再给你一点

00:01:26.810 --> 00:01:34.430
我认为细节，所以他们把堆弄碎了

00:01:30.110 --> 00:01:36.740
进入年轻一代和老一代，他们

00:01:34.430 --> 00:01:39.829
使用卡片表来跟踪

00:01:36.740 --> 00:01:42.079
从旧到新的指针，所以在这里

00:01:39.829 --> 00:01:44.750
您可以看到我们已经创建了一个对象

00:01:42.079 --> 00:01:46.610
上一代的foo及其指向

00:01:44.750 --> 00:01:49.310
写完指针后立即禁止

00:01:46.610 --> 00:01:51.770
禁止进入，我们必须在

00:01:49.310 --> 00:01:54.310
牌桌，这就是我们保持追踪的方式

00:01:51.770 --> 00:01:58.250
在所有这些中，从老年到青年的指针

00:01:54.310 --> 00:02:01.549
这是用于串行并行部分

00:01:58.250 --> 00:02:02.869
新的CMS，他们都跟踪卡片

00:02:01.549 --> 00:02:05.030
用这种方式来记录

00:02:02.869 --> 00:02:07.520
指针，以便他们可以只收集

00:02:05.030 --> 00:02:09.440
孤立的年轻一代，所以如果你

00:02:07.520 --> 00:02:11.810
对象快要死了，这很棒

00:02:09.440 --> 00:02:13.099
因为你正在收集所有

00:02:11.810 --> 00:02:15.200
死了的东西

00:02:13.099 --> 00:02:18.730
一代无需看

00:02:15.200 --> 00:02:18.730
在这个大老一辈

00:02:21.340 --> 00:02:26.930
但是我们已经转向基于区域

00:02:23.930 --> 00:02:29.629
智元这样的收藏家而不是

00:02:26.930 --> 00:02:32.060
有敬业的老一辈

00:02:29.629 --> 00:02:37.480
年轻的一代，他们把堆分开

00:02:32.060 --> 00:02:39.469
进入区域，然后在区域中进行分配

00:02:37.480 --> 00:02:41.510
有时我们也有物体

00:02:39.469 --> 00:02:42.469
大到适合该地区的那些

00:02:41.510 --> 00:02:44.209
巨大，他们被处理

00:02:42.469 --> 00:02:46.549
特别但主要是我们分配对象

00:02:44.209 --> 00:02:49.189
和地区，然后是时候

00:02:46.549 --> 00:02:50.959
垃圾收集我们可以复制现场

00:02:49.189 --> 00:02:53.419
反对一个新的地区，所以我们在这里

00:02:50.959 --> 00:02:55.370
有两个充满物体的区域

00:02:53.419 --> 00:02:59.359
那些死了的我们复制现场

00:02:55.370 --> 00:03:01.040
对象结束，然后我们可以拥有那些

00:02:59.359 --> 00:03:03.109
这两个区域可以自由活动的两个物体

00:03:01.040 --> 00:03:05.329
继续分配，我们所有

00:03:03.109 --> 00:03:08.569
对象已经被压缩，所以我们不

00:03:05.329 --> 00:03:11.120
一定要有50％ 

00:03:08.569 --> 00:03:17.389
 70个太空收集器会产生的开销

00:03:11.120 --> 00:03:20.030
有g1这是我所知

00:03:17.389 --> 00:03:21.379
我最后一次看的时候

00:03:20.030 --> 00:03:24.019
感觉正确，我应该应该有

00:03:21.379 --> 00:03:26.299
不久前我做了一个警告，我研究了g1 

00:03:24.019 --> 00:03:28.090
当它是原始的只是一个想法， 

00:03:26.299 --> 00:03:31.220
我最近还没真正看过

00:03:28.090 --> 00:03:34.009
那时候我们有一张桌子

00:03:31.220 --> 00:03:35.479
跟踪从老到小的参考文献，我们

00:03:34.009 --> 00:03:38.209
记得记得跟踪

00:03:35.479 --> 00:03:41.000
旧到旧参考，所以如果您有一个

00:03:38.209 --> 00:03:42.769
从食物指针在旧酒吧

00:03:41.000 --> 00:03:44.959
一代，你必须做标记

00:03:42.769 --> 00:03:46.189
像我说的卡片表，这说

00:03:44.959 --> 00:03:47.540
我们可以收集所有的年轻人

00:03:46.189 --> 00:03:50.049
只是看着年轻人

00:03:47.540 --> 00:03:53.479
区域或根集以及卡表

00:03:50.049 --> 00:03:55.430
但是如果我们将它们设为区域指针

00:03:53.479 --> 00:03:57.439
从一个古老的地区到一个古老的地区

00:03:55.430 --> 00:03:59.689
必须将该位置存储在

00:03:57.439 --> 00:04:01.189
纪念套装，这就是我们可以做到的

00:03:59.689 --> 00:04:03.319
只收集旧的地区

00:04:01.189 --> 00:04:08.269
收集foo而无需查看

00:04:03.319 --> 00:04:09.650
整个希巴，所以这有点

00:04:08.269 --> 00:04:11.150
你的背景，所以当我和你说话时

00:04:09.650 --> 00:04:14.750
关于我们在中国如何做到这一点

00:04:11.150 --> 00:04:18.459
这将是另一种看待方式

00:04:14.750 --> 00:04:19.909
这是这个

00:04:18.459 --> 00:04:21.889
展示什么垃圾

00:04:19.909 --> 00:04:23.449
收藏家在做，所以我们有这些

00:04:21.889 --> 00:04:25.789
牌桌和这些纪念套

00:04:23.449 --> 00:04:28.729
这样我们就可以做像我们这样的事情

00:04:25.789 --> 00:04:30.289
可以让年轻一代停下来

00:04:28.729 --> 00:04:30.680
另一个年轻一代停下来，然后我们

00:04:30.289 --> 00:04:32.870
可以做到

00:04:30.680 --> 00:04:34.310
并发标记并找出所有

00:04:32.870 --> 00:04:36.620
不年轻的生活中的东西

00:04:34.310 --> 00:04:41.570
生成区域，然后我们可以

00:04:36.620 --> 00:04:45.020
 g1中的混合集合，所以雪兰多是

00:04:41.570 --> 00:04:47.479
不同的是我们仍然做并发

00:04:45.020 --> 00:04:49.729
标记他们这样做，但我们复制了

00:04:47.479 --> 00:04:51.500
所有Java线程的对象是

00:04:49.729 --> 00:04:53.570
运行，所以在这里你可以说我们仍然

00:04:51.500 --> 00:04:57.979
已经停止了世界的停顿，但是

00:04:53.570 --> 00:05:01.610
它们要短得多，所以并发

00:04:57.979 --> 00:05:02.900
标记很难，我想如果

00:05:01.610 --> 00:05:05.419
在吉尔的演讲中，他形容为

00:05:02.900 --> 00:05:07.550
我要描述的是你身后的指针

00:05:05.419 --> 00:05:10.580
有点一样，所以如果

00:05:07.550 --> 00:05:13.639
你有一个和一个点，你要标记一个

00:05:10.580 --> 00:05:15.440
如果标记为a，则标记为B 

00:05:13.639 --> 00:05:18.289
指针向下移动以指向D 

00:05:15.440 --> 00:05:20.780
指向D点的点

00:05:18.289 --> 00:05:22.880
到B我们现在在这里有这个物体D 

00:05:20.780 --> 00:05:27.349
那是活的，永远不会得到

00:05:22.880 --> 00:05:28.880
标记是因为标记在前面

00:05:27.349 --> 00:05:31.729
标记线已移过它

00:05:28.880 --> 00:05:34.970
那么一开始的快照是什么

00:05:31.729 --> 00:05:36.789
是不是说那是什么

00:05:34.970 --> 00:05:43.250
刚开始还活着

00:05:36.789 --> 00:05:45.139
所以我们知道D还在世，我们

00:05:43.250 --> 00:05:47.300
知道D还活着，所以我们将D添加到Q 

00:05:45.139 --> 00:05:49.970
而且我们知道我们可以回来

00:05:47.300 --> 00:05:52.820
之后，每当您覆盖一个

00:05:49.970 --> 00:05:53.990
您将旧值存储在aq上的指针

00:05:52.820 --> 00:05:57.289
这样您可以确保

00:05:53.990 --> 00:05:58.849
您已经标记了整个堆

00:05:57.289 --> 00:06:04.789
新分配的被认为

00:05:58.849 --> 00:06:06.380
生活得很好，所以这里有东西

00:06:04.789 --> 00:06:10.639
这是雪伦多亚所独有的

00:06:06.380 --> 00:06:12.770
同时撤离，所以你有一个

00:06:10.639 --> 00:06:15.409
问题和并发问题

00:06:12.770 --> 00:06:16.759
疏散是你在竞争

00:06:15.409 --> 00:06:19.070
想要的垃圾收集器之间

00:06:16.759 --> 00:06:21.800
复制对象和Java线程

00:06:19.070 --> 00:06:23.900
要写两个对象，所以在这里

00:06:21.800 --> 00:06:28.370
您可以看到GC线程想要

00:06:23.900 --> 00:06:30.229
复制带有Fred和其字段的

00:06:28.370 --> 00:06:31.580
 javathread要写入对象

00:06:30.229 --> 00:06:34.130
它想将线程更新为

00:06:31.580 --> 00:06:36.380
指向鲍勃，所以如果你不小心的话

00:06:34.130 --> 00:06:38.719
你不小心做事

00:06:36.380 --> 00:06:40.039
可以得到对象的副本

00:06:38.719 --> 00:06:44.330
不包括最新的文章

00:06:40.039 --> 00:06:47.300
以及我们在雪兰多解决问题的方式

00:06:44.330 --> 00:06:49.310
是我们首先复制对象，然后

00:06:47.300 --> 00:06:52.009
然后我们执行正确的

00:06:49.310 --> 00:06:55.069
所以在这里javathread必须复制一个和

00:06:52.009 --> 00:06:57.050
然后执行正确的，所以另一个

00:06:55.069 --> 00:06:59.840
同时疏散的问题是

00:06:57.050 --> 00:07:02.360
跟踪哪个副本是真实的

00:06:59.840 --> 00:07:05.569
权利的副本，因为我现在有两个

00:07:02.360 --> 00:07:09.169
的副本在我的热火中，所以我有一个

00:07:05.569 --> 00:07:11.150
间接指针，这可能是

00:07:09.169 --> 00:07:12.800
申南多最有争议的部分

00:07:11.150 --> 00:07:15.770
好吧，也许他们不是

00:07:12.800 --> 00:07:17.270
完全是世代相传的，但是添加了

00:07:15.770 --> 00:07:19.699
指向对象的额外指针，它允许我们

00:07:17.270 --> 00:07:22.400
在Java中移动对象

00:07:19.699 --> 00:07:27.020
线程仅通过更新

00:07:22.400 --> 00:07:29.659
间接指针，所以我可以有17 

00:07:27.020 --> 00:07:31.810
指向的东西，一旦我投放

00:07:29.659 --> 00:07:33.680
指向新素数的指针

00:07:31.810 --> 00:07:35.090
其他所有内容都将通过

00:07:33.680 --> 00:07:39.680
交互指针并获取新副本

00:07:35.090 --> 00:07:43.279
一下子就发生了

00:07:39.680 --> 00:07:49.639
有阅读障碍，所以在常规

00:07:43.279 --> 00:07:51.139
编译器您将读取位置

00:07:49.639 --> 00:07:52.430
 foo，所以您知道foo生活在

00:07:51.139 --> 00:07:54.289
某个地址，然后说好，我要去

00:07:52.430 --> 00:07:57.919
读那个地址加上任何

00:07:54.289 --> 00:08:01.069
场偏移量是哪个shenandoah什么

00:07:57.919 --> 00:08:03.409
发生的情况是您在阅读之前

00:08:01.069 --> 00:08:05.240
指向foo的指针，它告诉您在哪里

00:08:03.409 --> 00:08:06.620
 foo大部分时间都活着

00:08:05.240 --> 00:08:09.440
指向下方的对象

00:08:06.620 --> 00:08:11.210
并为您预热缓存，但是

00:08:09.440 --> 00:08:12.740
有时候，这意味着你必须去

00:08:11.210 --> 00:08:14.150
在其他地方找到foo然后你

00:08:12.740 --> 00:08:21.710
必须去抵消那个地方

00:08:14.150 --> 00:08:23.330
否则结果是

00:08:21.710 --> 00:08:25.250
我写的elasticsearch基准

00:08:23.330 --> 00:08:28.339
不是所有人都可以尝试的

00:08:25.250 --> 00:08:34.699
所以你可能会有些怀疑，但是我

00:08:28.339 --> 00:08:37.070
老实说我索引了一个大数据

00:08:34.699 --> 00:08:39.050
常见的爬网是大来源

00:08:37.070 --> 00:08:41.360
我看过所有维基百科的数据

00:08:39.050 --> 00:08:45.769
查询，我使用弹性索引它们

00:08:41.360 --> 00:08:48.199
搜索，您可以在这里看到

00:08:45.769 --> 00:08:50.810
 shenandoah与g1我不想

00:08:48.199 --> 00:08:52.310
向我扔东西给你

00:08:50.810 --> 00:08:56.149
原装g1纸g1很棒

00:08:52.310 --> 00:08:57.680
收集者对其所做的事情，但就其而言

00:08:56.149 --> 00:08:59.930
的Enda和它击败的运行时间

00:08:57.680 --> 00:09:01.310
它会永远打败我们，因为我们

00:08:59.930 --> 00:09:04.700
通过该交互指针

00:09:01.310 --> 00:09:08.770
除了非常专业的工作负载外， 

00:09:04.700 --> 00:09:11.270
就总暂停时间而言

00:09:08.770 --> 00:09:13.550
明显缩短了，我们暂停了

00:09:11.270 --> 00:09:15.350
五百二十的世界

00:09:13.550 --> 00:09:18.320
毫秒，而他们暂停工作

00:09:15.350 --> 00:09:19.670
我们平均停顿了四秒钟

00:09:18.320 --> 00:09:24.380
时间好多了

00:09:19.670 --> 00:09:26.560
我们最大的过去时间，您可以在这里看到679 

00:09:24.380 --> 00:09:30.140
毫秒与30毫秒

00:09:26.560 --> 00:09:34.209
我们已经成功解决了

00:09:30.140 --> 00:09:37.220
 positon问题，我们确实有更多的停顿

00:09:34.209 --> 00:09:39.830
所以现在该节省点时间了

00:09:37.220 --> 00:09:43.640
盖尔在说的是一个问题

00:09:39.830 --> 00:09:47.450
我们在某些情况下发现

00:09:43.640 --> 00:09:48.980
保存时间比

00:09:47.450 --> 00:09:50.750
我们实际进行GC工作的时间

00:09:48.980 --> 00:09:54.740
我们对如何

00:09:50.750 --> 00:09:56.660
可能会解决这个问题，但我认为

00:09:54.740 --> 00:10:01.730
你到那个点，你知道

00:09:56.660 --> 00:10:04.250
你成功了，这是我的最爱

00:10:01.730 --> 00:10:05.360
基准，而吉尔说他从来没有

00:10:04.250 --> 00:10:07.670
在生产中看到过类似的东西

00:10:05.360 --> 00:10:10.370
可能不是，但我已经与

00:10:07.670 --> 00:10:12.200
有这个问题的人，如果

00:10:10.370 --> 00:10:14.779
他们有一个，至少最近有

00:10:12.200 --> 00:10:16.490
使用了网络缓存，所以他们会

00:10:14.779 --> 00:10:18.589
有一个指向像

00:10:16.490 --> 00:10:21.470
千兆字节的数据，它们会填满

00:10:18.589 --> 00:10:23.300
带有网址的表格，然后

00:10:21.470 --> 00:10:27.140
在没有更多空间时添加一个

00:10:23.300 --> 00:10:29.420
他们摆脱了最古老的

00:10:27.140 --> 00:10:32.450
那样的世代垃圾

00:10:29.420 --> 00:10:34.130
收款损失是其中之一

00:10:32.450 --> 00:10:36.620
习惯于此工具的情况

00:10:34.130 --> 00:10:39.440
为你工作，然后你进入

00:10:36.620 --> 00:10:42.050
弱势一代的情况

00:10:39.440 --> 00:10:44.839
假设不成立，那么你

00:10:42.050 --> 00:10:47.060
就像发生了什么事，哦，天哪，所以

00:10:44.839 --> 00:10:49.730
这种情况下shenandoah真的可以踢

00:10:47.060 --> 00:10:52.459
对接，因为我们不承担任何责任

00:10:49.730 --> 00:10:55.149
关于我们物体的寿命

00:10:52.459 --> 00:10:58.149
在这里，我们的运行时间明显更快

00:10:55.149 --> 00:11:01.279
我们的暂停时间明显更快

00:10:58.149 --> 00:11:02.930
总GC暂停时间为17秒

00:11:01.279 --> 00:11:07.010
与210毫秒

00:11:02.930 --> 00:11:09.829
我们的最大GC暂停时间为235毫秒

00:11:07.010 --> 00:11:11.070
与12毫秒相比，我们甚至拥有

00:11:09.829 --> 00:11:13.590
更少的停顿，因为

00:11:11.070 --> 00:11:15.120
我们的难题更有效

00:11:13.590 --> 00:11:16.590
拥有所有已死的东西

00:11:15.120 --> 00:11:19.770
我们可以摆脱的猎户座地区

00:11:16.590 --> 00:11:24.960
很快，我们不必做太多

00:11:19.770 --> 00:11:26.700
为了公平起见，我写了一个

00:11:24.960 --> 00:11:28.890
做世代树的基准

00:11:26.700 --> 00:11:30.960
在其中分配一兆字节的树

00:11:28.890 --> 00:11:33.450
抛弃它们，这是完美的

00:11:30.960 --> 00:11:34.950
对于世代假设，因为

00:11:33.450 --> 00:11:38.210
这些东西在年轻时正在消亡

00:11:34.950 --> 00:11:38.210
一代，永不升职

00:11:39.440 --> 00:11:43.860
我们并没有那么糟糕

00:11:41.430 --> 00:11:46.080
我们的GC差了几秒钟

00:11:43.860 --> 00:11:48.300
停顿还是更好，因为我们

00:11:46.080 --> 00:11:50.160
同时进行疏散，但

00:11:48.300 --> 00:11:52.250
这对我们来说是最坏的情况， 

00:11:50.160 --> 00:11:55.400
您可以看到我们的最大暂停时间是

00:11:52.250 --> 00:12:01.500
只比他们少一点

00:11:55.400 --> 00:12:02.730
我们做更多的事情，所以我们的平均值是

00:12:01.500 --> 00:12:05.100
降低这就是我们最终得到的结果

00:12:02.730 --> 00:12:09.870
总数较少，但基本上这是

00:12:05.100 --> 00:12:13.290
对我们来说，最糟糕的情况是

00:12:09.870 --> 00:12:16.290
如果您有rel 74或更高的价格，或者

00:12:13.290 --> 00:12:19.820
 Fedora 24或更高的功能

00:12:16.290 --> 00:12:25.140
是加破折号XX冒号+ u shenandoah GC 

00:12:19.820 --> 00:12:30.060
记录下来好吗，你是我的吗

00:12:25.140 --> 00:12:32.160
嗯，您可以进入我们的Wiki页面来

00:12:30.060 --> 00:12:34.320
获得有关它的更多信息

00:12:32.160 --> 00:12:36.840
玩它，有很多

00:12:34.320 --> 00:12:38.610
阿列克谢·沙夫列夫（Alexey Shavelev）提交的信息

00:12:36.840 --> 00:12:41.310
如果您想了解如何调整它

00:12:38.610 --> 00:12:44.630
调整它，但是它运行得很好

00:12:41.310 --> 00:12:47.580
开箱即用

00:12:44.630 --> 00:12:51.080
好，可视化器让我们看看是否可以

00:12:47.580 --> 00:12:51.080
做到这一点而不会失去一切

00:12:59.250 --> 00:13:04.100
好吧，那没有拿到毛衣

00:13:01.889 --> 00:13:04.100
那里

00:13:13.620 --> 00:13:18.790
好的，它在我的屏幕上非常漂亮，但是

00:13:16.959 --> 00:13:20.620
那对你没有帮助

00:13:18.790 --> 00:13:22.180
一个可视化工具在那里，你可以去

00:13:20.620 --> 00:13:26.160
如果您访问我们的网站并进行查看

00:13:22.180 --> 00:13:29.639
你可以下载它，你可以看

00:13:26.160 --> 00:13:29.639
这是怎么回事

00:13:37.860 --> 00:13:43.440
所以接下来是所谓的话题

00:13:41.160 --> 00:13:44.910
在我的演讲中，可能会成为

00:13:43.440 --> 00:13:50.200
有点短随时问任何

00:13:44.910 --> 00:13:53.309
问题你仍然不会是我

00:13:50.200 --> 00:13:53.309
 [音乐] 

00:13:56.149 --> 00:14:00.329
你一直可以帮我吗

00:13:58.890 --> 00:14:04.170
弄清楚为什么我丢了显示器而我

00:14:00.329 --> 00:14:06.990
会说这个我让我被淘汰了

00:14:04.170 --> 00:14:09.300
我最初说的是在木棚上

00:14:06.990 --> 00:14:12.290
用于16兆字节的堆以及更多，但是

00:14:09.300 --> 00:14:15.390
我目前的语言是一样的

00:14:12.290 --> 00:14:23.850
可预测的两次暂停时间

00:14:15.390 --> 00:14:25.860
千兆字节到200千兆字节

00:14:23.850 --> 00:14:27.600
当你看着暂停时会怎样

00:14:25.860 --> 00:14:30.420
倍率是每千兆字节每秒

00:14:27.600 --> 00:14:32.940
也许这只是一个经验法则

00:14:30.420 --> 00:14:36.120
在上一次谈话中，但如果可以

00:14:32.940 --> 00:14:37.560
保持暂停时间为

00:14:36.120 --> 00:14:39.570
如果您有250，那么您的堆就对了

00:14:37.560 --> 00:14:41.640
兆字节的热量，您可以在

00:14:39.570 --> 00:14:42.810
该堆以毫秒为单位，因此您不必

00:14:41.640 --> 00:14:45.149
真的很想支付

00:14:42.810 --> 00:14:47.550
 shenandoah所以这一切都取决于哪里

00:14:45.149 --> 00:14:49.350
你的痛点是在什么时候

00:14:47.550 --> 00:14:51.209
暂停时间过长，您无法忍受

00:14:49.350 --> 00:14:53.959
那就是当你想看看

00:14:51.209 --> 00:14:53.959
像雪兰多

00:15:16.820 --> 00:15:23.900
 CMS不是我们的压缩收集器

00:15:21.830 --> 00:15:26.420
我们正在压缩东西

00:15:23.900 --> 00:15:29.150
同时发生，所以我们没有那个

00:15:26.420 --> 00:15:35.450
问题我不能说我们从不打

00:15:29.150 --> 00:15:37.640
完整的GC，但我们还可以，所以这是另一个

00:15:35.450 --> 00:15:39.680
我拥有这个我赢得了我们的争论

00:15:37.640 --> 00:15:43.040
有能力做一个完整的GC，如果你

00:15:39.680 --> 00:15:44.510
如果一切都死了就需要它，但是如果

00:15:43.040 --> 00:15:45.830
您正在同时进行

00:15:44.510 --> 00:15:47.870
标记，您几乎完成了

00:15:45.830 --> 00:15:49.580
我们将完成并发标记开始

00:15:47.870 --> 00:15:55.090
同时疏散，然后让你

00:15:49.580 --> 00:15:57.590
伙计们去，所以停止世界只是一个

00:15:55.090 --> 00:16:00.620
最坏的情况或您致电

00:15:57.590 --> 00:16:02.270
 GC的系统，那么我们将为您提供

00:16:00.620 --> 00:16:04.430
能够阻止世界并拥有

00:16:02.270 --> 00:16:06.650
想要之前完全干净的堆

00:16:04.430 --> 00:16:11.510
开始一个基准之类的，但是

00:16:06.650 --> 00:16:13.820
完整的G C应该是他们可以拥有的

00:16:11.510 --> 00:16:15.170
否则我们本可以把他们排除在外

00:16:13.820 --> 00:16:18.700
本可以把他们排除在外而节流

00:16:15.170 --> 00:16:21.050
分配器，并继续前进，但我们我

00:16:18.700 --> 00:16:24.080
个人认为您宁愿拥有

00:16:21.050 --> 00:16:25.160
完整的GC比限制分配器

00:16:24.080 --> 00:16:28.450
如果您想节制

00:16:25.160 --> 00:16:28.450
分配器说出来，让我知道

00:16:40.870 --> 00:16:43.350
在

00:16:48.180 --> 00:16:52.470
好吧，我们有一个标志可以让您

00:16:51.240 --> 00:16:54.900
我不记得它的顶部

00:16:52.470 --> 00:16:56.970
我的头，但有一个标志说

00:16:54.900 --> 00:16:59.190
你看到的傻瓜不是你看到的褶皱

00:16:56.970 --> 00:17:01.050
这是一个并发的追逐，它将

00:16:59.190 --> 00:17:02.970
阻止你的变种人，因为你的美丽

00:17:01.050 --> 00:17:05.160
脚趾被卡住了，无法分配，但我

00:17:02.970 --> 00:17:09.300
会争辩说，如果您的增变者不能

00:17:05.160 --> 00:17:10.440
分配你知道他们可能也是

00:17:09.300 --> 00:17:11.550
如果他们停在一个

00:17:10.440 --> 00:17:13.970
他们停止分配点

00:17:11.550 --> 00:17:13.970
而不管

00:17:29.130 --> 00:17:34.559
如果我们的并发标记正在进行中，那么

00:17:32.610 --> 00:17:36.660
我们已经有一些数据

00:17:34.559 --> 00:17:39.150
我们不会抛弃我们

00:17:36.660 --> 00:17:41.850
完成我们的并发标记并保留

00:17:39.150 --> 00:17:44.460
只有在这种情况下

00:17:41.850 --> 00:17:44.940
现在出于某种原因我在说我的话

00:17:44.460 --> 00:17:47.760
眼睛

00:17:44.940 --> 00:17:50.370
我们不需要做完整的GCS，但是

00:17:47.760 --> 00:17:52.380
在那里，如果您可以禁用它们

00:17:50.370 --> 00:17:54.500
我想因为底部是

00:17:52.380 --> 00:17:54.500
线

00:18:21.390 --> 00:18:27.750
是的，但是你说你没有

00:18:26.010 --> 00:18:29.700
你们不要做她见过的傻瓜

00:18:27.750 --> 00:18:31.080
我想知道这是否会伤害您

00:18:29.700 --> 00:18:40.549
基准数字，因为您从不

00:18:31.080 --> 00:18:40.549
有一个完全压缩的堆好吗

00:18:50.110 --> 00:18:56.380
好吧，我在哪里

00:19:01.080 --> 00:19:04.370
您会转到正确的幻灯片

00:19:07.890 --> 00:19:17.460
所以我又丢了我很抱歉我不能

00:19:11.250 --> 00:19:20.940
我们不能停留在正确的幻灯片上，而我

00:19:17.460 --> 00:19:21.990
有11分钟，所以不要解决这个问题

00:19:20.940 --> 00:19:24.240
我们会和您谈谈

00:19:21.990 --> 00:19:26.220
除了让我展示一个

00:19:24.240 --> 00:19:28.309
在一分钟内的图片，但是

00:19:26.220 --> 00:19:32.790
比拥有卡牌桌

00:19:28.309 --> 00:19:35.760
我希望这张幻灯片成为我们的幻灯片

00:19:32.790 --> 00:19:37.320
知道了，这是当您带来时

00:19:35.760 --> 00:19:38.490
在它进入内部之前，所以我

00:19:37.320 --> 00:19:40.020
回到这里去找我

00:19:38.490 --> 00:19:43.220
去，然后我就把它丢了

00:19:40.020 --> 00:19:43.220
这张幻灯片在那里

00:19:43.260 --> 00:19:53.160
我们拥有的是非常非常

00:19:46.530 --> 00:19:54.809
我们保留的一项粗略条目

00:19:53.160 --> 00:19:57.000
跟踪之间的指针

00:19:54.809 --> 00:20:00.090
地区，我们称之为联系

00:19:57.000 --> 00:20:02.640
矩阵，所以我们没有指定旧

00:20:00.090 --> 00:20:06.270
地区和青年地区我们做什么

00:20:02.640 --> 00:20:08.280
在这里，我们走到这里，当我说话时

00:20:06.270 --> 00:20:10.620
关于g1我谈到了想起的

00:20:08.280 --> 00:20:11.820
设置在卡片表中以及您的状态

00:20:10.620 --> 00:20:14.910
跟踪不同的事物

00:20:11.820 --> 00:20:17.580
什么指向我们拥有的一件事，我们

00:20:14.910 --> 00:20:20.280
调用连接矩阵等

00:20:17.580 --> 00:20:22.860
跟踪来自区域的指针

00:20:20.280 --> 00:20:24.690
到区域，所以我们仍然有一个费率

00:20:22.860 --> 00:20:26.640
障碍率a 

00:20:24.690 --> 00:20:29.760
连接矩阵中的单个条目

00:20:26.640 --> 00:20:32.700
告诉你这些区域是相连的

00:20:29.760 --> 00:20:35.820
在这里您可以看到该区域3指向

00:20:32.700 --> 00:20:38.100
区域1，我刚刚写了一个指针

00:20:35.820 --> 00:20:39.570
进入区域5，这意味着

00:20:38.100 --> 00:20:41.330
我们必须在连接中写一些

00:20:39.570 --> 00:20:45.929
表示他们已连接的矩阵， 

00:20:41.330 --> 00:20:47.490
这使我们能够选择

00:20:45.929 --> 00:20:50.160
我们要收集的区域和

00:20:47.490 --> 00:20:52.679
独立收集它们，所以如果我们想要

00:20:50.160 --> 00:20:54.690
收集区域3我们必须去

00:20:52.679 --> 00:20:56.850
通过我们的路线设置，我们必须

00:20:54.690 --> 00:21:01.290
扫描区域5作为路由的一部分

00:20:56.850 --> 00:21:02.549
路线设置为收集区域3，所以我们

00:21:01.290 --> 00:21:05.280
有我们的新术语

00:21:02.549 --> 00:21:07.799
介绍我仍然记得

00:21:05.280 --> 00:21:09.390
 1998年，史蒂夫·海勒（Steve Heller）说这是

00:21:07.799 --> 00:21:11.220
并行，甚至是并发的

00:21:09.390 --> 00:21:13.919
虽然汉斯·鲍曼（Hans Bowman）则相反

00:21:11.220 --> 00:21:14.790
大约几年前，但这就是我们

00:21:13.919 --> 00:21:16.320
想打电话给我们想打电话给我们

00:21:14.790 --> 00:21:18.390
地区收集我们的收藏集

00:21:16.320 --> 00:21:20.250
地区，我们想告诉我们的地区

00:21:18.390 --> 00:21:21.330
扫描我们的根源我们的地区等等

00:21:20.250 --> 00:21:22.980
我们只是我们只是

00:21:21.330 --> 00:21:24.420
将我们的地区视为另一部分

00:21:22.980 --> 00:21:30.540
路线设置，以便我们可以做更多

00:21:24.420 --> 00:21:33.720
收集，所以在这里我们要做的是

00:21:30.540 --> 00:21:36.120
为每个分配一个时期

00:21:33.720 --> 00:21:38.300
我们的地区说，当最后

00:21:36.120 --> 00:21:42.420
分配发生在该地区， 

00:21:38.300 --> 00:21:45.270
让我们有能力做漂亮的

00:21:42.420 --> 00:21:47.310
几乎任何种类的收集和策略

00:21:45.270 --> 00:21:50.940
如果我们想做一个年轻的我们

00:21:47.310 --> 00:21:52.440
在这里收集您可以看到地区，如果我们

00:21:50.940 --> 00:21:54.210
想把第七区

00:21:52.440 --> 00:21:56.940
我们最近分配的区域

00:21:54.210 --> 00:21:59.130
收藏集，我们可以做到，我们有

00:21:56.940 --> 00:22:03.030
从它指向它的一个指针

00:21:59.130 --> 00:22:05.640
区域六，所以我们要做的就是扫描

00:22:03.030 --> 00:22:10.680
区域6然后我们可以收集区域

00:22:05.640 --> 00:22:12.360
 7现在，与

00:22:10.680 --> 00:22:15.030
那只是一个区域的纸牌桌

00:22:12.360 --> 00:22:16.770
比卡片大，但很多

00:22:15.030 --> 00:22:18.570
更灵活，因为它使我们能够

00:22:16.770 --> 00:22:21.120
准确地对待老旧地区

00:22:18.570 --> 00:22:23.610
一样，它允许我们定义

00:22:21.120 --> 00:22:26.640
适合年轻人的策略

00:22:23.610 --> 00:22:28.980
为需要的应用程序生成

00:22:26.640 --> 00:22:30.330
年轻的一代，或者我们也可以做

00:22:28.980 --> 00:22:33.510
对于一代人来说，我们可以

00:22:30.330 --> 00:22:37.130
只需收集最老的一代

00:22:33.510 --> 00:22:37.130
扫描一个区域到它的点

00:22:37.610 --> 00:22:43.830
所以我们可以选择地区

00:22:42.480 --> 00:22:45.950
引用数量最少的

00:22:43.830 --> 00:22:48.870
最少我们需要更新的地方

00:22:45.950 --> 00:22:51.350
所以这给了我们灵活性

00:22:48.870 --> 00:22:54.690
探索新的俗气政策和启发式

00:22:51.350 --> 00:22:56.400
这不是你做得不好

00:22:54.690 --> 00:23:00.780
在福多尔，但这仍然在

00:22:56.400 --> 00:23:03.060
实验阶段，但我们确实有一个

00:23:00.780 --> 00:23:05.550
停止世界局部收藏

00:23:03.060 --> 00:23:07.230
工作，我们非常接近

00:23:05.550 --> 00:23:07.710
增量部分收集工作

00:23:07.230 --> 00:23:09.710
抱歉

00:23:07.710 --> 00:23:11.880
并发部分收集工作

00:23:09.710 --> 00:23:13.440
我们使用的相同转发指针

00:23:11.880 --> 00:23:15.570
对于大集合，我们可以使用

00:23:13.440 --> 00:23:17.460
并发部分收集，所以我们

00:23:15.570 --> 00:23:20.100
不会停止做俊俊

00:23:17.460 --> 00:23:21.420
集合只会停止

00:23:20.100 --> 00:23:25.320
世界选择我们的收藏集和

00:23:21.420 --> 00:23:27.180
再次开始，另一件事

00:23:25.320 --> 00:23:28.170
我在最后一分钟添加了这个

00:23:27.180 --> 00:23:30.840
因为我怕我不会

00:23:28.170 --> 00:23:33.780
有足够的时间，但看起来我

00:23:30.840 --> 00:23:35.049
那些时间用完了五个

00:23:33.780 --> 00:23:39.429
五点六点，我们

00:23:35.049 --> 00:23:41.409
跳过这一部分，所以这基本上是一个

00:23:39.429 --> 00:23:44.950
看看雪兰多亚2.0将会做什么

00:23:41.409 --> 00:23:47.649
看起来像是因为我们正在做这些

00:23:44.950 --> 00:23:49.989
我们可以执行部分​​收集

00:23:47.649 --> 00:23:52.509
没有并发标记的收集

00:23:49.989 --> 00:23:55.269
信息，所以我们不必等待

00:23:52.509 --> 00:23:56.739
完整的并发标记，就是我

00:23:55.269 --> 00:23:58.090
就像当你用完空间

00:23:56.739 --> 00:23:59.259
你做不到，你做不到

00:23:58.090 --> 00:24:02.249
完整的收藏，因为你永远不会做饭

00:23:59.259 --> 00:24:06.070
正在标记数据，我们可以做到这些

00:24:02.249 --> 00:24:08.590
所以我们可以做一个局部的

00:24:06.070 --> 00:24:11.230
可以做一个并发的部分，我们可以

00:24:08.590 --> 00:24:12.909
也做一个并发标记，然后

00:24:11.230 --> 00:24:19.539
同时疏散

00:24:12.909 --> 00:24:21.639
如果您要收集的生产区域

00:24:19.539 --> 00:24:25.809
想要更多信息，我们有我们的

00:24:21.639 --> 00:24:27.519
打开具有Wiki Java的JDK网页

00:24:25.809 --> 00:24:28.899
 Red Hat的GC可随时发送

00:24:27.519 --> 00:24:30.970
问题在那里，我们将回到

00:24:28.899 --> 00:24:32.649
整个团队的你还是你

00:24:30.970 --> 00:24:40.419
可以直接向我发送CHF红发

00:24:32.649 --> 00:24:42.989
通讯，我正在寻找我正在努力

00:24:40.419 --> 00:24:45.399
时间，我在一个集装箱世界里

00:24:42.989 --> 00:24:47.619
每个人都想以200兆字节运行

00:24:45.399 --> 00:24:49.899
这些天，所以如果你有申请

00:24:47.619 --> 00:24:52.720
以千兆字节运行，并且您有一个GC 

00:24:49.899 --> 00:24:54.100
问题，请与我们联系

00:24:52.720 --> 00:24:55.330
想要为您工作，我们希望能够

00:24:54.100 --> 00:24:57.999
告诉你我们可以做到

00:24:55.330 --> 00:25:04.590
停下来不止几个

00:24:57.999 --> 00:25:04.590
毫秒任何问题是

00:25:05.970 --> 00:25:13.150
我们将在74中作为技术预览发布

00:25:09.810 --> 00:25:15.160
我们没有问题，所以我们应该

00:25:13.150 --> 00:25:16.750
我们得到了支持

00:25:15.160 --> 00:25:18.550
我们没有实验性的背后

00:25:16.750 --> 00:25:22.170
 options标志，因此Red Hat将支持

00:25:18.550 --> 00:25:24.340
雪兰多和rel和浅顶软呢帽和

00:25:22.170 --> 00:25:26.380
基本上，如果您有Linux 

00:25:24.340 --> 00:25:28.870
从中获取RPM的分布

00:25:26.380 --> 00:25:30.070
他们仍然会支持

00:25:28.870 --> 00:25:32.320
雪兰多亚团队仍然希望听到

00:25:30.070 --> 00:25:35.710
你我们想要我们想要一些

00:25:32.320 --> 00:25:38.220
真实的用户故事

00:25:35.710 --> 00:25:38.220
问题是

00:25:48.320 --> 00:25:53.070
好吧，我们还没有测量连接

00:25:50.670 --> 00:25:55.310
现在我们仍然在打矩阵

00:25:53.070 --> 00:25:58.770
我们有办法使它变小

00:25:55.310 --> 00:26:03.120
但就shenandoah 1.0而言

00:25:58.770 --> 00:26:07.230
只有开销是一个单词项目，所以我们

00:26:03.120 --> 00:26:08.970
如果你说的话绝对诚实-xmx port 

00:26:07.230 --> 00:26:11.310
演出，您得到四场演出

00:26:08.970 --> 00:26:13.320
空间没有了

00:26:11.310 --> 00:26:17.610
边数据结构，除了

00:26:13.320 --> 00:26:18.750
位图，但是没有卡

00:26:17.610 --> 00:26:27.060
桌子上不记得它说

00:26:18.750 --> 00:26:28.620
没有什么我不能说

00:26:27.060 --> 00:26:32.280
它实际上更紧凑了

00:26:28.620 --> 00:26:33.750
有更多空间写，但我不能告诉你

00:26:32.280 --> 00:26:36.090
除非我知道你还有多少空间

00:26:33.750 --> 00:26:38.070
对象大小分布权，如果您

00:26:36.090 --> 00:26:39.480
有三个非常大的物体，你

00:26:38.070 --> 00:26:43.020
知道我们占据的空间

00:26:39.480 --> 00:26:46.020
如果你所有的对象都是你，那就最少

00:26:43.020 --> 00:26:51.860
知道其中有一种价值，然后

00:26:46.020 --> 00:26:51.860
我们的开销很大

00:27:05.360 --> 00:27:10.910
如果您选择收藏集

00:27:08.330 --> 00:27:14.690
在我们进入疏散阶段之前

00:27:10.910 --> 00:27:16.460
如果您写入的对象是

00:27:14.690 --> 00:27:18.980
这些地区之一选择

00:27:16.460 --> 00:27:20.720
撤离垃圾收集器

00:27:18.980 --> 00:27:30.380
首先撤离对象，然后编写

00:27:20.720 --> 00:27:31.940
对此，不，不是，这不是最重要的

00:27:30.380 --> 00:27:34.370
世界上轻量级的利率障碍

00:27:31.940 --> 00:27:36.020
但我们很快检查了

00:27:34.370 --> 00:27:38.360
线程局部变量说我们

00:27:36.020 --> 00:27:41.870
在疏散阶段，如果你不这样做

00:27:38.360 --> 00:27:43.429
然后它不会这样做，所以这只是大多数

00:27:41.870 --> 00:27:45.410
在时间上非常快， 

00:27:43.429 --> 00:27:51.669
只有当你疏散时

00:27:45.410 --> 00:27:51.669
您必须复制对象是

00:27:55.260 --> 00:28:02.470
这是我们无法控制的

00:27:58.210 --> 00:28:06.910
 10:00，但鉴于发生了什么

00:28:02.470 --> 00:28:08.710
现在使用OpenJDK，您知道那里

00:28:06.910 --> 00:28:11.830
我不记得什么是公开的

00:28:08.710 --> 00:28:15.309
什么不是，但我们定于10:00 

00:28:11.830 --> 00:28:17.110
我不知道十点什么时候会这样

00:28:15.309 --> 00:28:20.500
我不能说我们什么时候被放

00:28:17.110 --> 00:28:22.450
回到上游，我们在10:00 

00:28:20.500 --> 00:28:31.090
工作空间，我们在那里

00:28:22.450 --> 00:28:34.330
希望别的什么，所以我告诉你

00:28:31.090 --> 00:28:35.180
我会早点完成的，非常感谢

00:28:34.330 --> 00:28:40.709
在你的时间

00:28:35.180 --> 00:28:40.709
 [掌声] 

