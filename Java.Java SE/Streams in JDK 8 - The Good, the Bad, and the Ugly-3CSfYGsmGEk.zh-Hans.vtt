WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.149 --> 00:00:08.790
好的，好的，早上好，欢迎光临

00:00:06.660 --> 00:00:10.170
这么多以后真的很高兴

00:00:08.790 --> 00:00:10.559
这里的人八点半

00:00:10.170 --> 00:00:12.630
早上

00:00:10.559 --> 00:00:16.080
昨晚我有点早起

00:00:12.630 --> 00:00:19.020
参加人数，但我们能做些什么

00:00:16.080 --> 00:00:21.540
今天早上正在谈论溪流

00:00:19.020 --> 00:00:24.540
 JDK八，我们以此命名

00:00:21.540 --> 00:00:26.070
好，坏，丑， 

00:00:24.540 --> 00:00:29.250
这个演讲的想法真的是为了

00:00:26.070 --> 00:00:33.480
您从我的错误中学到的帮助

00:00:29.250 --> 00:00:34.350
不是斯图亚特的错误，也是我们的错误

00:00:33.480 --> 00:00:37.350
我们要做的就是看一些

00:00:34.350 --> 00:00:39.390
流代码示例，实际上这

00:00:37.350 --> 00:00:43.440
有点跟踪我的学习情况

00:00:39.390 --> 00:00:45.480
关于流和理解的过程

00:00:43.440 --> 00:00:50.070
您需要如何思考

00:00:45.480 --> 00:00:51.510
因为作为Java程序员，我们非常

00:00:50.070 --> 00:00:53.579
非常关注命令式编程

00:00:51.510 --> 00:00:56.489
我们了解循环的想法

00:00:53.579 --> 00:00:58.890
了解可变状态的想法

00:00:56.489 --> 00:01:00.929
我们把东西放在变量中，所以如果我问

00:00:58.890 --> 00:01:04.199
在这里以为自己是举手的人

00:01:00.929 --> 00:01:05.790
 Java程序员，好的，我们有

00:01:04.199 --> 00:01:07.260
合适的听众

00:01:05.790 --> 00:01:10.080
将自己描述为功能

00:01:07.260 --> 00:01:12.510
程序员，是的，你看到只有一个

00:01:10.080 --> 00:01:13.830
这里的人很少，那就是

00:01:12.510 --> 00:01:15.630
这里的关键是功能

00:01:13.830 --> 00:01:17.880
编程与

00:01:15.630 --> 00:01:19.440
命令式编程，您确实需要

00:01:17.880 --> 00:01:22.680
换个角度思考，所以我们要

00:01:19.440 --> 00:01:25.160
给你一些不怎么做的例子

00:01:22.680 --> 00:01:27.300
事情以及如何去做， 

00:01:25.160 --> 00:01:29.250
真的是这个背后的想法

00:01:27.300 --> 00:01:31.680
因为我写了演讲

00:01:29.250 --> 00:01:33.120
一个博客条目，我在其中解释了如何

00:01:31.680 --> 00:01:35.940
我用流做了一些事情， 

00:01:33.120 --> 00:01:37.230
有人不喜欢我的代码，他很友善

00:01:35.940 --> 00:01:39.570
被批评了，所以我们有一个

00:01:37.230 --> 00:01:41.280
关于这个的讨论，所以这是

00:01:39.570 --> 00:01:45.770
我们是怎么想到的

00:01:41.280 --> 00:01:48.680
介绍，所以首先我应该介绍

00:01:45.770 --> 00:01:51.750
所以我是我工作的Simon Ritter 

00:01:48.680 --> 00:01:54.450
我是Stuart标志着我在Oracle工作

00:01:51.750 --> 00:01:55.860
是在JDK核心库上，所以Stuart 

00:01:54.450 --> 00:01:59.250
显然与

00:01:55.860 --> 00:02:01.680
我还没有开发流

00:01:59.250 --> 00:02:03.570
好吧，所以第一件事就是

00:02:01.680 --> 00:02:06.150
有例外，因为这实际上是

00:02:03.570 --> 00:02:09.470
在什么时候可能会非常棘手

00:02:06.150 --> 00:02:14.340
我们将看到使用屏幕

00:02:09.470 --> 00:02:16.320
现在我的问题是

00:02:14.340 --> 00:02:17.790
试图处理一些原本是

00:02:16.320 --> 00:02:20.550
像网络一样穿越

00:02:17.790 --> 00:02:22.890
界面，所以您的想法就是

00:02:20.550 --> 00:02:24.750
一个非常简单的键值集

00:02:22.890 --> 00:02:28.050
您要提取信息的

00:02:24.750 --> 00:02:31.860
从这么简单的事情，很少采取行动是

00:02:28.050 --> 00:02:36.150
验证键是10键是22键是10 

00:02:31.860 --> 00:02:37.950
关键是33，所以我想要的是结果

00:02:36.150 --> 00:02:40.050
以行动和验证的形式

00:02:37.950 --> 00:02:43.050
然后键，我有一组值10 

00:02:40.050 --> 00:02:44.940
 22 10和33所以重要的是

00:02:43.050 --> 00:02:46.740
我可以在其中重复值

00:02:44.940 --> 00:02:48.709
我所拥有的那个

00:02:46.740 --> 00:02:51.540
实际上是很重要的一点

00:02:48.709 --> 00:02:53.820
所以我要做的第一件事当然是

00:02:51.540 --> 00:02:56.100
去堆栈溢出，我说有

00:02:53.820 --> 00:02:57.420
任何人以前都遇到过这个问题，我

00:02:56.100 --> 00:02:59.400
环顾四周，我发现是的

00:02:57.420 --> 00:03:02.490
有人生产了一个很好的泥炭

00:02:59.400 --> 00:03:03.570
现在执行此操作的一段代码

00:03:02.490 --> 00:03:06.800
不打算谈论这个，因为

00:03:03.570 --> 00:03:09.030
这显然很小，而且

00:03:06.800 --> 00:03:10.530
这实际上不是一个很好的部分

00:03:09.030 --> 00:03:11.880
代码，甚至我不得不承认

00:03:10.530 --> 00:03:13.980
这段代码中有很多东西

00:03:11.880 --> 00:03:16.620
可以整理和改善

00:03:13.980 --> 00:03:17.850
我们除了谈论别的

00:03:16.620 --> 00:03:19.470
说我已经看过了，我

00:03:17.850 --> 00:03:23.340
对自己想，不，我不想做

00:03:19.470 --> 00:03:26.130
这样我想使用流，所以我

00:03:23.340 --> 00:03:27.480
想出了这个和那个东西

00:03:26.130 --> 00:03:29.700
我真的很专注于

00:03:27.480 --> 00:03:32.310
不应该一直这样

00:03:29.700 --> 00:03:34.560
尽可能紧凑，所以我要你

00:03:32.310 --> 00:03:37.410
将我们挤进字面上的三行

00:03:34.560 --> 00:03:41.310
代码，如您所见，我来了

00:03:37.410 --> 00:03:43.739
与Perl联系起来，因为它非常密集

00:03:41.310 --> 00:03:44.160
这实际上不是最好的

00:03:43.739 --> 00:03:46.530
码

00:03:44.160 --> 00:03:48.150
所以这有三个问题

00:03:46.530 --> 00:03:50.070
实际上，第二个想出了两个

00:03:48.150 --> 00:03:51.510
问题，然后斯图尔特指出

00:03:50.070 --> 00:03:54.049
还有第三个问题

00:03:51.510 --> 00:03:57.510
与此相关的三个问题是

00:03:54.049 --> 00:03:58.980
这可以返回空值，就是你

00:03:57.510 --> 00:04:00.480
永远不知道一个好主意，因为如果你

00:03:58.980 --> 00:04:02.190
返回，现在您将不得不

00:04:00.480 --> 00:04:05.070
当您得到

00:04:02.190 --> 00:04:06.209
结果并适当处理

00:04:05.070 --> 00:04:07.920
回来，我不是一个好主意

00:04:06.209 --> 00:04:10.030
特别是因为我们有一个可选的

00:04:07.920 --> 00:04:13.130
 JDK 8 

00:04:10.030 --> 00:04:14.330
第二件事是拆分这是

00:04:13.130 --> 00:04:16.730
斯图尔特向我指出的那个

00:04:14.330 --> 00:04:17.540
最近被分割了两次，所以我们

00:04:16.730 --> 00:04:19.790
做同样的事情

00:04:17.540 --> 00:04:22.070
叫两次分裂，这是非常

00:04:19.790 --> 00:04:25.160
效率低下，所以我们需要解决

00:04:22.070 --> 00:04:28.850
问题，然后是第三件事

00:04:25.160 --> 00:04:30.950
不调用URL解码解码

00:04:28.850 --> 00:04:34.310
原来使用的方法

00:04:30.950 --> 00:04:36.470
代码，其原因是因为

00:04:34.310 --> 00:04:38.450
我不想面对

00:04:36.470 --> 00:04:41.990
例外，因为问题是

00:04:38.450 --> 00:04:43.760
解码抛出一个检查异常，如果

00:04:41.990 --> 00:04:46.250
您正在使用流，并使用

00:04:43.760 --> 00:04:49.310
流API，您不能抛出异常

00:04:46.250 --> 00:04:51.770
流方法之外，您要

00:04:49.310 --> 00:04:53.810
只是在这上面几件事

00:04:51.770 --> 00:04:55.610
所以是的，所以原始代码有

00:04:53.810 --> 00:04:57.500
这个有这个有趣的东西，这个

00:04:55.610 --> 00:05:00.889
不是特别关于流，但是

00:04:57.500 --> 00:05:02.419
这是关于通用代码的

00:05:00.889 --> 00:05:04.700
我们一般会改进代码

00:05:02.419 --> 00:05:06.830
实际上使流更好

00:05:04.700 --> 00:05:09.710
处理，但在这种情况下

00:05:06.830 --> 00:05:12.020
原始代码接受了null 

00:05:09.710 --> 00:05:15.289
它必须测试它，如果

00:05:12.020 --> 00:05:17.539
输入为null，返回null，并且

00:05:15.289 --> 00:05:19.010
就像每个人都那样

00:05:17.539 --> 00:05:20.210
如果这是一件奇怪的事情

00:05:19.010 --> 00:05:22.190
您考虑一下，因为您想要什么

00:05:20.210 --> 00:05:24.260
是一个值，它是从字符串到

00:05:22.190 --> 00:05:26.840
字符串Kalista字符串，你想

00:05:24.260 --> 00:05:29.240
处理那些，所以如果你有这个我

00:05:26.840 --> 00:05:31.280
认为这是一种不良的编码习惯Trisha gee 

00:05:29.240 --> 00:05:32.380
几周前在

00:05:31.280 --> 00:05:34.820
 JetBrains 

00:05:32.380 --> 00:05:37.460
她有一个关于代码气味的博客系列

00:05:34.820 --> 00:05:38.870
她说不的地方就变成了

00:05:37.460 --> 00:05:42.650
在代码库中，她是

00:05:38.870 --> 00:05:45.440
尝试每种方法都说哦，如果我明白了

00:05:42.650 --> 00:05:46.910
 null返回null，即使没有

00:05:45.440 --> 00:05:48.560
完全是有道理的

00:05:46.910 --> 00:05:49.970
在整个世界传播的习惯

00:05:48.560 --> 00:05:52.370
代码库，我认为这是

00:05:49.970 --> 00:05:53.930
这是怎么回事，因为如果你

00:05:52.370 --> 00:05:56.210
考虑一下这里的背景

00:05:53.930 --> 00:05:57.560
你有一个URL，你想

00:05:56.210 --> 00:06:01.150
抓住论点的末尾

00:05:57.560 --> 00:06:04.729
 URL，因此如果有任何参数

00:06:01.150 --> 00:06:06.680
您有一个非空字符串，如果

00:06:04.729 --> 00:06:08.479
然后没有任何争论

00:06:06.680 --> 00:06:09.830
你应该有一个空字符串，但是你

00:06:08.479 --> 00:06:12.530
永远不应该为null，所以在哪里

00:06:09.830 --> 00:06:14.300
 null来自右，然后如果您

00:06:12.530 --> 00:06:16.070
如果您考虑摆脱空值

00:06:14.300 --> 00:06:17.810
你永远不会返回null应该返回一个

00:06:16.070 --> 00:06:19.520
空的地图，而不是然后

00:06:17.810 --> 00:06:21.380
符合将要处理的流程

00:06:19.520 --> 00:06:24.020
空图的每个条目

00:06:21.380 --> 00:06:26.840
我们什么也不会做，所以你就是这样

00:06:24.020 --> 00:06:28.910
你真的会想想你什么时候

00:06:26.840 --> 00:06:30.590
真的需要处理null和何时

00:06:28.910 --> 00:06:34.160
这只是一个坏习惯，哦，我更好

00:06:30.590 --> 00:06:35.420
检查null并返回null哦，然后

00:06:34.160 --> 00:06:38.150
然后在这里快速做一件事

00:06:35.420 --> 00:06:41.120
原始代码有一个正则表达式

00:06:38.150 --> 00:06:42.680
在split命令中

00:06:41.120 --> 00:06:44.090
放慢了速度，因为

00:06:42.680 --> 00:06:45.620
它要做的就是匹配一个

00:06:44.090 --> 00:06:47.690
角色，所以实际上有一个快

00:06:45.620 --> 00:06:49.430
 split方法中的路径需要一个

00:06:47.690 --> 00:06:51.200
正则表达式，但是如果它说哦，如果

00:06:49.430 --> 00:06:52.490
我正在分裂一个角色

00:06:51.200 --> 00:06:54.890
通过完全不同的部分

00:06:52.490 --> 00:06:56.720
绕过所有昂贵的代码

00:06:54.890 --> 00:07:00.440
正则表达式处理

00:06:56.720 --> 00:07:02.180
快很多，知道就可以了

00:07:00.440 --> 00:07:04.130
经过一番讨论之后

00:07:02.180 --> 00:07:08.690
斯图尔特我想出了一个更好的

00:07:04.130 --> 00:07:10.490
方法，所以这里的想法是

00:07:08.690 --> 00:07:12.920
提取一些代码到一个

00:07:10.490 --> 00:07:14.450
方法，我们要做的是

00:07:12.920 --> 00:07:17.390
我们将拆分密钥和

00:07:14.450 --> 00:07:20.150
值，这样我们就可以使用网址

00:07:17.390 --> 00:07:21.620
解码的解码方法，我们可以处理

00:07:20.150 --> 00:07:23.180
除了例外，我们必须做

00:07:21.620 --> 00:07:25.130
在方法中，所以我们必须以某种方式

00:07:23.180 --> 00:07:28.400
处理检查的异常

00:07:25.130 --> 00:07:30.500
该方法中的异常，所以你知道

00:07:28.400 --> 00:07:32.690
这取决于设计

00:07:30.500 --> 00:07:35.300
流API，我和Brian谈过

00:07:32.690 --> 00:07:39.590
关于这个过去的数字

00:07:35.300 --> 00:07:41.540
是的，是括号，是的，关于您

00:07:39.590 --> 00:07:44.270
知道你没有的方式

00:07:41.540 --> 00:07:46.100
从一个异常中抛出异常的能力

00:07:44.270 --> 00:07:47.960
流，因为理想情况下我们想要

00:07:46.100 --> 00:07:49.430
能够做的是有一个流，然后

00:07:47.960 --> 00:07:50.540
在某个时候

00:07:49.430 --> 00:07:52.280
兰博Xpression您抛出异常

00:07:50.540 --> 00:07:53.600
然后将其扔出

00:07:52.280 --> 00:07:56.540
整个流，但这只是行不通

00:07:53.600 --> 00:07:58.220
这样我们要做的就是

00:07:56.540 --> 00:08:00.110
我们必须要有一种方法

00:07:58.220 --> 00:08:01.580
情况下，我们必须做一些事情

00:08:00.110 --> 00:08:03.890
处理该异常，所以我们称

00:08:01.580 --> 00:08:05.120
 dqo方法可能

00:08:03.890 --> 00:08:08.090
在这种情况下抛出异常

00:08:05.120 --> 00:08:11.210
从记录器发出警告

00:08:08.090 --> 00:08:14.870
我们将返回null另一件事

00:08:11.210 --> 00:08:18.200
这是因为它使用了JDK 9增强功能

00:08:14.870 --> 00:08:20.840
遇到地图点输入，因此地图点

00:08:18.200 --> 00:08:22.550
条目将为您返回一张地图条目

00:08:20.840 --> 00:08:25.540
那件事的好处是你

00:08:22.550 --> 00:08:28.230
不必使用有一种

00:08:25.540 --> 00:08:31.000
埋葬的类是抽象的

00:08:28.230 --> 00:08:33.280
简单的不可变条目的抽象映射

00:08:31.000 --> 00:08:35.380
是的，抽象的地图点简单不可变

00:08:33.280 --> 00:08:39.600
进入而不是我们的阶级

00:08:35.380 --> 00:08:41.800
应该有所谓的元组等等

00:08:39.600 --> 00:08:43.600
所以我们最终在这里

00:08:41.800 --> 00:08:45.820
实际返回地图教导的条目，并且

00:08:43.600 --> 00:08:47.770
我们得到一个字符串中的一个字符串

00:08:45.820 --> 00:08:49.120
所以我们提取出需要的代码

00:08:47.770 --> 00:08:53.290
处理异常

00:08:49.120 --> 00:08:56.440
分开的方法，然后就

00:08:53.290 --> 00:08:58.120
实际上使我们的代码更好，我们最终

00:08:56.440 --> 00:09:00.280
有了这个，显然我们做到了

00:08:58.120 --> 00:09:02.530
更大一点，但是要容易得多

00:09:00.280 --> 00:09:04.870
阅读，所以现在我们有了主意

00:09:02.530 --> 00:09:06.520
要暂停查询，我们创建一个

00:09:04.870 --> 00:09:10.510
流基于拆分

00:09:06.520 --> 00:09:13.240
 ＆符，然后我们进行过滤以确保

00:09:10.510 --> 00:09:15.220
我们不会得到任何非null或任何

00:09:13.240 --> 00:09:18.840
空对象，这是一种简单的方法

00:09:15.220 --> 00:09:21.070
消除了null问题

00:09:18.840 --> 00:09:23.800
显然在那个时候，因为我们

00:09:21.070 --> 00:09:25.270
调用对象点要求非null 

00:09:23.800 --> 00:09:26.950
这是一个空病，抛出空指针

00:09:25.270 --> 00:09:28.780
例外，但这至少是一个更好的选择

00:09:26.950 --> 00:09:29.890
潜在的处理方式

00:09:28.780 --> 00:09:32.680
因为你想说什么

00:09:29.890 --> 00:09:33.820
关于那是的，哦，是的，当你

00:09:32.680 --> 00:09:37.000
完成后，我将回到先前

00:09:33.820 --> 00:09:38.920
好吧，相反，所以我们消除了

00:09:37.000 --> 00:09:41.320
关于我们的null问题

00:09:38.920 --> 00:09:42.700
值，然后我们调用地图，然后使用

00:09:41.320 --> 00:09:44.350
我们的分割键值是

00:09:42.700 --> 00:09:46.330
我们已经提取了代码

00:09:44.350 --> 00:09:48.670
处理异常，然后我们

00:09:46.330 --> 00:09:50.410
发现污秽的东西说

00:09:48.670 --> 00:09:51.730
返回我们的null，然后我们忽略

00:09:50.410 --> 00:09:53.200
任何事情，因为显然那不是

00:09:51.730 --> 00:09:55.500
我们需要的信息，以便我们可以

00:09:53.200 --> 00:09:58.960
消除它，然后我们使用收集

00:09:55.500 --> 00:10:00.700
减少，所以我们按键分组

00:09:58.960 --> 00:10:03.220
和价值

00:10:00.700 --> 00:10:03.970
并生成一个列表，所以很多

00:10:03.220 --> 00:10:07.090
更清晰

00:10:03.970 --> 00:10:08.590
哦尼塔很多整理者范三行

00:10:07.090 --> 00:10:10.440
我最初尝试编写的代码

00:10:08.590 --> 00:10:12.880
所以如果我回到上一张幻灯片

00:10:10.440 --> 00:10:15.820
好吧，对此有几个评论

00:10:12.880 --> 00:10:17.290
正如西蒙指出的

00:10:15.820 --> 00:10:19.420
这里有一个问题，因为

00:10:17.290 --> 00:10:21.370
 AP之间存在不匹配

00:10:19.420 --> 00:10:26.050
抛出检查异常的JDK和

00:10:21.370 --> 00:10:28.270
在流中使用这些api 

00:10:26.050 --> 00:10:30.490
通常不允许检查

00:10:28.270 --> 00:10:32.230
例外，所以关于

00:10:30.490 --> 00:10:34.450
这是我回去回顾这个

00:10:32.230 --> 00:10:36.579
这实际上完全没有必要

00:10:34.450 --> 00:10:39.249
在这种情况下具有检查异常

00:10:36.579 --> 00:10:41.769
但是错误实际上是缺失的

00:10:39.249 --> 00:10:44.379
 api在jdk中，所以如果您深入研究

00:10:41.769 --> 00:10:46.360
这是怎么回事，所以这是URL 

00:10:44.379 --> 00:10:48.429
解码或解码方法抛出此

00:10:46.360 --> 00:10:49.720
不支持的编码异常是

00:10:48.429 --> 00:10:52.569
因为你必须告诉它什么

00:10:49.720 --> 00:10:55.149
对其使用的编码以及告诉方式

00:10:52.569 --> 00:10:59.559
给它使用什么编码

00:10:55.149 --> 00:11:02.350
编码的字符串名称等等

00:10:59.559 --> 00:11:04.869
有可能

00:11:02.350 --> 00:11:07.209
该字符串名称的编码

00:11:04.869 --> 00:11:08.889
给它不存在，那是

00:11:07.209 --> 00:11:10.569
实际上是一种老式的API 

00:11:08.889 --> 00:11:13.029
那些很早被介绍的

00:11:10.569 --> 00:11:15.819
最近在JDK中

00:11:13.029 --> 00:11:18.489
的api的已添加

00:11:15.819 --> 00:11:21.749
有一个字符集对象，还有

00:11:18.489 --> 00:11:25.269
像charset utf-8这样的char设置常量

00:11:21.749 --> 00:11:27.220
那无处不在，所以

00:11:25.269 --> 00:11:31.959
哦，是的，有人指出

00:11:27.220 --> 00:11:34.239
标准字符集是的，所以还是这样

00:11:31.959 --> 00:11:36.610
所以那些保证是

00:11:34.239 --> 00:11:40.720
存在于JDK中，因此如果您使用

00:11:36.610 --> 00:11:43.059
字符集对象，那么您可以经常调用

00:11:40.720 --> 00:11:44.910
一个API并传递char set对象，然后

00:11:43.059 --> 00:11:47.199
它不会引发检查异常

00:11:44.910 --> 00:11:50.259
不幸的是，没有这样的超载

00:11:47.199 --> 00:11:52.299
用于URL解码或解码，也用于

00:11:50.259 --> 00:11:54.220
如此编码，实际上我们需要做的是

00:11:52.299 --> 00:11:56.019
修复api，然后这个

00:11:54.220 --> 00:11:58.329
问题的整个部分都应该走

00:11:56.019 --> 00:12:02.439
离开，然后还有另一个问题

00:11:58.329 --> 00:12:04.989
我不确定哪一个，但是

00:12:02.439 --> 00:12:08.769
如果我们要解码网址，则实际

00:12:04.989 --> 00:12:12.309
我认为字符编码是正式的

00:12:08.769 --> 00:12:13.899
未指定，但通常是utf-8，因此

00:12:12.309 --> 00:12:15.309
如果有的话，您也许可以逃脱

00:12:13.899 --> 00:12:17.619
您可能可以获得更好的API 

00:12:15.309 --> 00:12:19.299
在这里指定utf-8，然后您

00:12:17.619 --> 00:12:20.619
避免整个检查异常

00:12:19.299 --> 00:12:22.720
事实上，您可以重构整个

00:12:20.619 --> 00:12:24.910
东西，它将变得更好

00:12:22.720 --> 00:12:26.919
但是我们今天没有那个选择，但是

00:12:24.910 --> 00:12:28.050
有人提醒我为

00:12:26.919 --> 00:12:31.600
那

00:12:28.050 --> 00:12:35.260
好吧，再一件事哦，然后

00:12:31.600 --> 00:12:37.210
有这种拆分方法，所以

00:12:35.260 --> 00:12:39.280
基本上，您本质上想要钥匙

00:12:37.210 --> 00:12:42.100
值对，我们在等号和

00:12:39.280 --> 00:12:44.590
所以这里有一个问题

00:12:42.100 --> 00:12:46.990
我们使用split的重载

00:12:44.590 --> 00:12:49.090
接受一个极限参数，这意味着如果

00:12:46.990 --> 00:12:52.240
他们是多个等号

00:12:49.090 --> 00:12:54.100
字符串，我们将第一个块

00:12:52.240 --> 00:12:56.230
第一个等号的左侧和

00:12:54.100 --> 00:12:59.110
称钥匙和其余的

00:12:56.230 --> 00:13:01.570
字符串是值，即使它包含

00:12:59.110 --> 00:13:03.760
等号，但这里仍然有错误

00:13:01.570 --> 00:13:06.250
如果我们得到的块没有

00:13:03.760 --> 00:13:08.470
等号，这将返回一个数组

00:13:06.250 --> 00:13:10.690
长度一，实际上我们会吐

00:13:08.470 --> 00:13:12.400
数组索引超出范围异常

00:13:10.690 --> 00:13:13.690
所以无论如何，有很多

00:13:12.400 --> 00:13:15.700
这段代码中发生的事情

00:13:13.690 --> 00:13:17.530
想一想，但是很好，但是我们

00:13:15.700 --> 00:13:20.500
你应该继续前进吗？ 

00:13:17.530 --> 00:13:23.500
说说第二张幻灯片

00:13:20.500 --> 00:13:25.960
我确定他会没事的，所以接下来

00:13:23.500 --> 00:13:29.200
如果可以的话，当务之急是尖叫

00:13:25.960 --> 00:13:31.000
一直等到最后，你知道是否

00:13:29.200 --> 00:13:32.620
我们将问题一直保留到最后，因为

00:13:31.000 --> 00:13:34.720
我们有很多事情要做，所以我们

00:13:32.620 --> 00:13:36.790
不要太停顿

00:13:34.720 --> 00:13:38.560
好吧，当务之急现在这

00:13:36.790 --> 00:13:41.410
回到我在说什么

00:13:38.560 --> 00:13:43.420
作为Java开发人员，我们倾向于如何思考

00:13:41.410 --> 00:13:47.260
我们必须从循环的角度进行思考

00:13:43.420 --> 00:13:50.020
所以当JDK 8第一次问世时

00:13:47.260 --> 00:13:51.940
决定写一些代码

00:13:50.020 --> 00:13:54.430
扫描所有Java文档并查找

00:13:51.940 --> 00:13:56.800
您有办法的所有地方

00:13:54.430 --> 00:13:59.530
返回了一条小溪和所有地方

00:13:56.800 --> 00:14:01.270
你有办法采取的方法

00:13:59.530 --> 00:14:02.800
一个功能性的论点

00:14:01.270 --> 00:14:04.330
界面，因此我可以使用

00:14:02.800 --> 00:14:05.920
 lambda表达式，因为没有

00:14:04.330 --> 00:14:07.839
那种病态的水槽清单

00:14:05.920 --> 00:14:09.490
可用，所以我做到了，我想

00:14:07.839 --> 00:14:11.560
对，我要用流写

00:14:09.490 --> 00:14:13.900
此代码和代码的位I 

00:14:11.560 --> 00:14:17.740
最后是我想数的地方

00:14:13.900 --> 00:14:18.940
抱歉，有多少个新班或多少个班

00:14:17.740 --> 00:14:22.690
有多少种方法

00:14:18.940 --> 00:14:26.800
返回了一条小溪，所以我有一张地图

00:14:22.690 --> 00:14:27.880
类两个方法，所以我想要什么

00:14:26.800 --> 00:14:30.220
能够做的就是经历

00:14:27.880 --> 00:14:32.740
数一数所以我来了

00:14:30.220 --> 00:14:35.530
这段代码，我说

00:14:32.740 --> 00:14:37.330
好吧，我们拿出地图，然后

00:14:35.530 --> 00:14:40.160
我们将从中得到课程，我们将

00:14:37.330 --> 00:14:42.199
从中创建一个流，然后

00:14:40.160 --> 00:14:43.639
每个人我都需要这样做

00:14:42.199 --> 00:14:47.089
我要做的是打印

00:14:43.639 --> 00:14:50.569
出方法，然后我想

00:14:47.089 --> 00:14:52.399
数一下这是否是一种新方法，所以我

00:14:50.569 --> 00:14:54.019
自以为还好，所以我知道

00:14:52.399 --> 00:14:56.240
这可能是多线程的

00:14:54.019 --> 00:14:57.589
所以我要使用一个长加法器

00:14:56.240 --> 00:14:59.839
专为此类型设计

00:14:57.589 --> 00:15:01.879
你经常去的情况

00:14:59.839 --> 00:15:03.290
写和不常读，所以每个

00:15:01.879 --> 00:15:04.370
线程获取自己的实例

00:15:03.290 --> 00:15:05.990
变量，您可以更新它们

00:15:04.370 --> 00:15:07.790
独立没有争执

00:15:05.990 --> 00:15:09.410
那里锁定，然后当您需要

00:15:07.790 --> 00:15:10.670
结果将所有东西都融合在一起，所以我

00:15:09.410 --> 00:15:13.370
认为这是一件非常好的事

00:15:10.670 --> 00:15:14.509
它是新的，JDK 8将使用它，所以我

00:15:13.370 --> 00:15:15.860
最终得到了非常不错的

00:15:14.509 --> 00:15:18.319
我说好的代码流

00:15:15.860 --> 00:15:20.540
为每个做，然后我会采取我的方法

00:15:18.319 --> 00:15:22.850
名称，然后我打印出一张支票

00:15:20.540 --> 00:15:25.699
它的新方法，然后我将增加

00:15:22.850 --> 00:15:27.259
没关系，所以我跟管家谈了一下

00:15:25.699 --> 00:15:29.930
这个，他说啊，你看那是

00:15:27.259 --> 00:15:31.550
没有函数式编程这是非常

00:15:29.930 --> 00:15:33.949
不好，这不是函数式编程

00:15:31.550 --> 00:15:37.189
所以我想我会和我一起去

00:15:33.949 --> 00:15:37.639
还有另一件事，所以我想

00:15:37.189 --> 00:15:39.829
对

00:15:37.639 --> 00:15:41.540
我不需要以

00:15:39.829 --> 00:15:42.439
外部状态，所以我要做的是

00:15:41.540 --> 00:15:45.680
使它更加复杂

00:15:42.439 --> 00:15:47.990
然后我会想到

00:15:45.680 --> 00:15:49.339
创建我的流，显然我应该

00:15:47.990 --> 00:15:50.449
已经将其转移到方法中，但是

00:15:49.339 --> 00:15:52.819
我把它放在这里只是为了

00:15:50.449 --> 00:15:54.709
更容易在一张幻灯片上看到，我会说

00:15:52.819 --> 00:15:57.079
采取方法，然后我将有一个

00:15:54.709 --> 00:16:00.230
我的lambda表达式中的变量

00:15:57.079 --> 00:16:02.000
这是新的方法是零然后我会

00:16:00.230 --> 00:16:03.980
打印出方法，然后我将检查

00:16:02.000 --> 00:16:06.019
看看这是否是一种新方法

00:16:03.980 --> 00:16:08.209
设定一种新方法我就是说

00:16:06.019 --> 00:16:12.110
返回一个新方法，所以我得到了

00:16:08.209 --> 00:16:13.670
一和零，我加起来，我

00:16:12.110 --> 00:16:18.680
计算出多少种新方法

00:16:13.670 --> 00:16:20.300
有哪些我想再做一次

00:16:18.680 --> 00:16:22.399
我告诉斯图尔特他说得很好

00:16:20.300 --> 00:16:24.290
是的，你看到这是一种

00:16:22.399 --> 00:16:27.110
有点功能，但不是

00:16:24.290 --> 00:16:29.059
起作用，因为我们仍然有状态

00:16:27.110 --> 00:16:31.699
即使我们采取了

00:16:29.059 --> 00:16:33.589
在内部说明我们仍在修改

00:16:31.699 --> 00:16:35.750
这么严格地说我的意思是你

00:16:33.589 --> 00:16:37.490
知道它会起作用，因为

00:16:35.750 --> 00:16:39.079
您可以应用相同的输入并

00:16:37.490 --> 00:16:40.970
不管有多少，都得到相同的输出

00:16:39.079 --> 00:16:43.870
时代，但仍然有状态

00:16:40.970 --> 00:16:46.250
修改，所以这不是做到这一点的方法

00:16:43.870 --> 00:16:50.440
所以我以为我会很好

00:16:46.250 --> 00:16:52.990
另一个去，所以我想出了

00:16:50.440 --> 00:16:56.230
一种更好的方法，几乎

00:16:52.990 --> 00:16:57.430
功能正常，但事实并非如此

00:16:56.230 --> 00:16:58.960
走流，然后我们用这个

00:16:57.430 --> 00:17:01.090
这个方便的小方法称为Peak 

00:16:58.960 --> 00:17:03.970
峰值让您看一下元素

00:17:01.090 --> 00:17:05.140
流过时的水流等

00:17:03.970 --> 00:17:06.280
只要不修改它们，就可以

00:17:05.140 --> 00:17:07.959
你可以看着他们，你可以做

00:17:06.280 --> 00:17:09.790
像打印出来的东西，所以我可以

00:17:07.959 --> 00:17:11.920
打印出方法名称

00:17:09.790 --> 00:17:15.579
过去了，然后我过去了

00:17:11.920 --> 00:17:17.530
映射色调，不涉及任何状态

00:17:15.579 --> 00:17:19.060
就拥有变量而言，我

00:17:17.530 --> 00:17:20.860
认为正确，我将使用条件

00:17:19.060 --> 00:17:23.589
运算符，我会说是不是新的

00:17:20.860 --> 00:17:24.970
方法返回1，否则返回0，所以我

00:17:23.589 --> 00:17:27.630
仍然得到我的零和一流

00:17:24.970 --> 00:17:30.160
我总结这些，我得到了结果

00:17:27.630 --> 00:17:31.390
然后斯图尔特指出得很好

00:17:30.160 --> 00:17:33.910
其实有一个更好的方法

00:17:31.390 --> 00:17:36.700
使用过滤器的过程

00:17:33.910 --> 00:17:39.010
所以而不是你知道如果

00:17:36.700 --> 00:17:40.450
映射到int内的语句为什么不

00:17:39.010 --> 00:17:42.160
使用过滤器，因为我认为这需要

00:17:40.450 --> 00:17:43.990
predicate和predicate是if 

00:17:42.160 --> 00:17:46.060
声明，这样我们就可以做到

00:17:43.990 --> 00:17:48.460
我们最终将过滤器M转到新的

00:17:46.060 --> 00:17:51.430
方法，然后将其传递给计数

00:17:48.460 --> 00:17:53.050
而不是总和，所以一切正常

00:17:51.430 --> 00:17:54.520
这一切都很好，所以看起来我

00:17:53.050 --> 00:17:56.650
认为这是我自己的样子

00:17:54.520 --> 00:18:00.040
我们做得很好的功能代码

00:17:56.650 --> 00:18:02.260
在这里，然后斯图亚特说不，不是

00:18:00.040 --> 00:18:05.920
他说的功能代码

00:18:02.260 --> 00:18:07.780
严格来说，打印线是侧面

00:18:05.920 --> 00:18:10.300
效果，如果你是纯粹的

00:18:07.780 --> 00:18:13.590
功能，你不会有副作用

00:18:10.300 --> 00:18:15.970
所以我要交给斯图尔特-好的

00:18:13.590 --> 00:18:17.980
好的，是的，那是相当不错的

00:18:15.970 --> 00:18:20.080
那里的演变，我认为那是

00:18:17.980 --> 00:18:22.390
是的，我认为我使用了

00:18:20.080 --> 00:18:24.250
打印输出日志的高峰很好

00:18:22.390 --> 00:18:26.710
要做的事情是一种调试

00:18:24.250 --> 00:18:28.420
我想如果你真的想

00:18:26.710 --> 00:18:29.920
将结果存储在您可能所在的位置

00:18:28.420 --> 00:18:32.080
应该将它们建立在数据结构中

00:18:29.920 --> 00:18:34.990
使用收集器或类似的东西

00:18:32.080 --> 00:18:37.090
我们以后会有例子

00:18:34.990 --> 00:18:38.170
只是想反省

00:18:37.090 --> 00:18:39.850
开始我不知道你是否

00:18:38.170 --> 00:18:41.070
想介意回到第一个

00:18:39.850 --> 00:18:42.720
这个幻灯片

00:18:41.070 --> 00:18:44.820
所以你看到有很多

00:18:42.720 --> 00:18:47.100
流在这里演变

00:18:44.820 --> 00:18:50.550
那还好

00:18:47.100 --> 00:18:53.460
所以西蒙开始时各有四个

00:18:50.550 --> 00:18:56.010
每个有四个的问题是

00:18:53.460 --> 00:18:58.230
这是最简单的流功能

00:18:56.010 --> 00:19:02.330
了解，但实际上可能

00:18:58.230 --> 00:19:05.580
最不有用的之一，因为我

00:19:02.330 --> 00:19:06.840
认为我也不想对你竖琴

00:19:05.580 --> 00:19:08.910
很多，但我认为西蒙陷入了这个

00:19:06.840 --> 00:19:10.290
陷阱就是所有这一切

00:19:08.910 --> 00:19:11.400
所有这些奇怪的东西都很好

00:19:10.290 --> 00:19:13.080
我知道会做什么，所以我将开始

00:19:11.400 --> 00:19:14.790
与每个问题一起写作

00:19:13.080 --> 00:19:18.210
与每个是和立即

00:19:14.790 --> 00:19:19.320
导致你产生副作用

00:19:18.210 --> 00:19:21.300
你陷入了陷阱

00:19:19.320 --> 00:19:23.670
副作用，那么您真的必须

00:19:21.300 --> 00:19:24.990
对如何解脱有所不同的思考

00:19:23.670 --> 00:19:26.850
从那自己，所以这就是

00:19:24.990 --> 00:19:28.560
这个练习是关于，所以我想我们

00:19:26.850 --> 00:19:30.590
每个人还有更多

00:19:28.560 --> 00:19:33.690
稍后在演示中

00:19:30.590 --> 00:19:35.280
是的，这就是斯图尔特制造的

00:19:33.690 --> 00:19:36.510
真正的好处是因为

00:19:35.280 --> 00:19:38.790
整体思考的想法

00:19:36.510 --> 00:19:40.140
因为我看的方式是

00:19:38.790 --> 00:19:41.160
说好吧，所以我有这些要素

00:19:40.140 --> 00:19:42.900
通过，然后为每个

00:19:41.160 --> 00:19:44.490
那些我想做的事

00:19:42.900 --> 00:19:45.750
我马上有了这两个字

00:19:44.490 --> 00:19:47.220
我想要做的每个人

00:19:45.750 --> 00:19:49.410
哦，看起来每个都有一个

00:19:47.220 --> 00:19:51.570
方法我将对每种方法使用

00:19:49.410 --> 00:19:52.950
那不是做到这一点的方式

00:19:51.570 --> 00:19:55.080
当我与之交谈时，我有点解释

00:19:52.950 --> 00:19:57.120
使用其他lambda的人和

00:19:55.080 --> 00:19:58.830
流的东西，我做的就像你

00:19:57.120 --> 00:20:01.110
想想如果你看每个

00:19:58.830 --> 00:20:03.090
想想我会在每个停靠站使用

00:20:01.110 --> 00:20:04.950
认为我真的应该使用那个

00:20:03.090 --> 00:20:06.810
因为有合理的情况

00:20:04.950 --> 00:20:09.030
您可以在其中使用每个但有

00:20:06.810 --> 00:20:10.980
许多你不应该去的地方，所以用它

00:20:09.030 --> 00:20:12.930
以更实用的方式

00:20:10.980 --> 00:20:14.880
这样做是为了让您一想到

00:20:12.930 --> 00:20:16.590
使用每一站和思考

00:20:14.880 --> 00:20:17.690
关于它非常仔细地决定

00:20:16.590 --> 00:20:25.050
这是否真的有意义

00:20:17.690 --> 00:20:27.540
好吧，所以正确混合内部和

00:20:25.050 --> 00:20:29.160
外部迭代，所以再次看到

00:20:27.540 --> 00:20:31.830
是Java程序员的问题

00:20:29.160 --> 00:20:34.440
而不是函数式程序员，所以这里

00:20:31.830 --> 00:20:36.690
是背面，所以我想做的是

00:20:34.440 --> 00:20:38.670
我有一组数据是

00:20:36.690 --> 00:20:40.410
每天的值数

00:20:38.670 --> 00:20:43.140
年，我想做的是

00:20:40.410 --> 00:20:44.940
将它们分成几个月，以便我可以

00:20:43.140 --> 00:20:46.980
建立每个月的图表，然后

00:20:44.940 --> 00:20:48.360
每天都有一个酒吧，所以我

00:20:46.980 --> 00:20:50.610
可以看到有多少数据

00:20:48.360 --> 00:20:51.990
那一天，所以我去了，我需要

00:20:50.610 --> 00:20:52.380
一些我们按月将它们分组， 

00:20:51.990 --> 00:20:55.460
然后

00:20:52.380 --> 00:20:57.900
具有该月中每一天的值

00:20:55.460 --> 00:20:59.430
所以我从一个非常简单的开始

00:20:57.900 --> 00:21:02.880
我为int所说的一段代码

00:20:59.430 --> 00:21:05.730
等于0我少于12我加好

00:21:02.880 --> 00:21:07.680
 Java代码简单循环然后我想

00:21:05.730 --> 00:21:09.990
对，所以我要循环

00:21:07.680 --> 00:21:11.880
使用流，所以我将流放入我的

00:21:09.990 --> 00:21:14.910
循环，我会说一个月的日子

00:21:11.880 --> 00:21:16.920
那个月的数据是我得到的

00:21:14.910 --> 00:21:19.440
我们的小动物流我是说我有一个

00:21:16.920 --> 00:21:21.990
过滤它，以便我说得到月份

00:21:19.440 --> 00:21:24.990
并检查是否比较

00:21:21.990 --> 00:21:26.970
当然，在那种情况下

00:21:24.990 --> 00:21:29.970
知道它是从0开始

00:21:26.970 --> 00:21:31.770
从1开始，所以我们必须加1 

00:21:29.970 --> 00:21:33.120
为了得到适当的月份

00:21:31.770 --> 00:21:34.890
数字这是东西有点

00:21:33.120 --> 00:21:36.900
有点复杂，所以我们检查看看

00:21:34.890 --> 00:21:38.640
这是合适的月份，然后我们说

00:21:36.900 --> 00:21:41.490
进行过滤以仅获取数据

00:21:38.640 --> 00:21:43.200
那个月，然后我们使用收集

00:21:41.490 --> 00:21:45.000
根据我们得到的分组

00:21:43.200 --> 00:21:47.310
一个月中的某天，然后进行计数

00:21:45.000 --> 00:21:49.380
与该月的某天相关，因此

00:21:47.310 --> 00:21:52.620
产生了我们所需要的

00:21:49.380 --> 00:21:55.110
我们现在创建的地图，如果

00:21:52.620 --> 00:21:57.150
你看着那好一点

00:21:55.110 --> 00:21:58.920
有点奇怪，但是你觉得

00:21:57.150 --> 00:22:01.050
好的，您自己会工作的， 

00:21:58.920 --> 00:22:04.170
答案是不，这不会简单

00:22:01.050 --> 00:22:05.430
我们现在使用我加1的原因

00:22:04.170 --> 00:22:07.440
因为我们在直播中，我们正在使用

00:22:05.430 --> 00:22:10.620
 lambda表达式和我们的表达式

00:22:07.440 --> 00:22:12.120
只能引用来自

00:22:10.620 --> 00:22:14.310
如果它们是周围的范围

00:22:12.120 --> 00:22:16.860
现在有效地结束了，因为我们

00:22:14.310 --> 00:22:19.650
给我加1这是无效的

00:22:16.860 --> 00:22:22.230
最后，也是因为我正在改变

00:22:19.650 --> 00:22:24.510
并不是有效的最终决定，所以我们不能做

00:22:22.230 --> 00:22:26.220
所以我看着那个，我想

00:22:24.510 --> 00:22:28.770
对我自己，我们该如何解决

00:22:26.220 --> 00:22:32.250
问题，我知道我会再增加一行

00:22:28.770 --> 00:22:34.260
代码我将设置一个名为I的新变量

00:22:32.250 --> 00:22:37.890
然后我改变循环

00:22:34.260 --> 00:22:40.770
变量名，我将其设置为BM 

00:22:37.890 --> 00:22:42.840
那么我实际上是最终的，我可以

00:22:40.770 --> 00:22:44.160
逃脱，你可以注意到

00:22:42.840 --> 00:22:47.010
你知道我不是一个真正的功能

00:22:44.160 --> 00:22:49.620
此时的程序员如此清晰

00:22:47.010 --> 00:22:52.050
我现在实际上是决赛，我们可以

00:22:49.620 --> 00:22:57.720
实际上要加1 

00:22:52.050 --> 00:22:59.370
在那种情况下，那真的不是

00:22:57.720 --> 00:23:03.420
正确的方法去做，所以我们应该

00:22:59.370 --> 00:23:05.490
做的是使用内部迭代

00:23:03.420 --> 00:23:06.450
两者的重量都

00:23:05.490 --> 00:23:09.930
循环，我们

00:23:06.450 --> 00:23:13.320
在这里做什么，为什么我们不使用流

00:23:09.930 --> 00:23:14.010
进行迭代，所以我能做的是

00:23:13.320 --> 00:23:16.560
我可以做的很好

00:23:14.010 --> 00:23:19.560
让我们从int流创建一个流

00:23:16.560 --> 00:23:21.450
我们将从0转到12 

00:23:19.560 --> 00:23:23.700
以相同的方式给我们一个流

00:23:21.450 --> 00:23:26.340
我们的循环从0到12 

00:23:23.700 --> 00:23:27.960
将创建一个intz流

00:23:26.340 --> 00:23:28.950
从0到12，然后我们将使用每个

00:23:27.960 --> 00:23:30.150
啊哈

00:23:28.950 --> 00:23:31.370
我们在这里使用正确的东西吗

00:23:30.150 --> 00:23:35.040
立即我们必须问自己

00:23:31.370 --> 00:23:38.100
可能不是，然后我们要做的是

00:23:35.040 --> 00:23:40.650
说好吧带我，然后我们说几天

00:23:38.100 --> 00:23:42.510
我一个月，然后我们回到我们的

00:23:40.650 --> 00:23:44.850
流数据，所以现在我们循环

00:23:42.510 --> 00:23:46.590
通过内部数据，然后我们

00:23:44.850 --> 00:23:49.290
做我们以前做过的事情，所以我们

00:23:46.590 --> 00:23:53.310
过滤月份为我的R加1 

00:23:49.290 --> 00:23:55.800
收集相同的收集器，所以在这种情况下，我

00:23:53.310 --> 00:23:58.580
是有效的参考，所以我们可以逃脱

00:23:55.800 --> 00:24:01.020
这样，我们就可以知道一些

00:23:58.580 --> 00:24:03.870
我们正在使用迭代内部迭代

00:24:01.020 --> 00:24:06.660
对于两个循环，但仍然很漂亮

00:24:03.870 --> 00:24:10.070
丑陋的代码，所以你想见我走吗

00:24:06.660 --> 00:24:10.070
一直到最后

00:24:10.160 --> 00:24:14.670
所以斯图尔特不得不看这个

00:24:13.260 --> 00:24:16.050
你们好，那里有一些

00:24:14.670 --> 00:24:17.940
我们可以在这里做的更好的事情

00:24:16.050 --> 00:24:20.190
首先是要消除每个

00:24:17.940 --> 00:24:21.680
所以这就是我们不想成为的东西

00:24:20.190 --> 00:24:23.850
在这样的情况下使用每个

00:24:21.680 --> 00:24:25.680
所以我们实际上是在说好

00:24:23.850 --> 00:24:28.650
我们将创建一个从

00:24:25.680 --> 00:24:31.290
月到整数和Long的映射

00:24:28.650 --> 00:24:33.780
这是第二张内部图

00:24:31.290 --> 00:24:35.910
是一个月中的第几天

00:24:33.780 --> 00:24:38.070
与该月相关联，我们将

00:24:35.910 --> 00:24:40.890
创建结果，以便我们获取数据并

00:24:38.070 --> 00:24:44.730
我们流它可以，我们要去

00:24:40.890 --> 00:24:46.410
要做的是我们有一张日期地图

00:24:44.730 --> 00:24:48.840
一切都很好，所以我们知道了

00:24:46.410 --> 00:24:50.220
那个特定的数据，然后

00:24:48.840 --> 00:24:54.930
我们要收集，但收集

00:24:50.220 --> 00:24:56.730
变化，因此我们使用了更好的方法

00:24:54.930 --> 00:24:59.550
做收集者，所以我们说收集

00:24:56.730 --> 00:25:01.470
我们想分组，在这种情况下

00:24:59.550 --> 00:25:03.840
我们将使用自己的日期/时间获取月份

00:25:01.470 --> 00:25:06.060
所以我们得到与之相关的月份

00:25:03.840 --> 00:25:08.010
所以按月分组，然后我们

00:25:06.060 --> 00:25:11.250
要在每月的一天分组

00:25:08.010 --> 00:25:13.170
然后我们要数一下

00:25:11.250 --> 00:25:15.510
给我们确切我们想要的

00:25:13.170 --> 00:25:16.860
从一个月到

00:25:15.510 --> 00:25:18.580
每月的日期和帐户

00:25:16.860 --> 00:25:22.140
与该月相关

00:25:18.580 --> 00:25:28.330
所以这显然更好

00:25:22.140 --> 00:25:29.919
流解决方案，所以乔纳斯好吧，这我

00:25:28.330 --> 00:25:31.870
我马上告诉你，但是

00:25:29.919 --> 00:25:33.610
让我看一下这段代码

00:25:31.870 --> 00:25:35.409
认为这是嵌套分组

00:25:33.610 --> 00:25:37.240
我认为有很多人参加， 

00:25:35.409 --> 00:25:39.580
很难拿出来

00:25:37.240 --> 00:25:47.950
您知道的嵌套分组

00:25:39.580 --> 00:25:49.269
你的头顶，但是我想

00:25:47.950 --> 00:25:50.799
思考的方法是建立

00:25:49.269 --> 00:25:52.510
事情逐渐增加，为什么我们不

00:25:50.799 --> 00:25:56.039
回到第一张幻灯片

00:25:52.510 --> 00:25:56.039
没有数组

00:26:00.129 --> 00:26:03.979
好的，那很好，因为

00:26:02.629 --> 00:26:05.419
是的，在逻辑上是相同的

00:26:03.979 --> 00:26:07.129
是的，这是第一次

00:26:05.419 --> 00:26:08.869
第一个有效的代码是因为

00:26:07.129 --> 00:26:12.379
有效的最终发行权

00:26:08.869 --> 00:26:14.959
所以这张幻灯片上没有的是

00:26:12.379 --> 00:26:17.690
这个数组的声明是

00:26:14.959 --> 00:26:20.450
被分配给，所以如果你，如果你

00:26:17.690 --> 00:26:22.759
如果你仔细看这是

00:26:20.450 --> 00:26:24.769
一个必须去的数组

00:26:22.759 --> 00:26:28.279
必须有十二十二个元素

00:26:24.769 --> 00:26:29.659
那是我认为数组是

00:26:28.279 --> 00:26:32.239
实际上错过了命名，但基本上

00:26:29.659 --> 00:26:34.789
每个月的数组元素，因此

00:26:32.239 --> 00:26:36.289
数组的索引为0 

00:26:34.789 --> 00:26:37.399
到11点，因为那就是我们

00:26:36.289 --> 00:26:39.109
摆脱for循环，我们

00:26:37.399 --> 00:26:41.149
给每个数组分配一些东西

00:26:39.109 --> 00:26:43.459
基于月份的元素，这样

00:26:41.149 --> 00:26:46.279
应该考虑一下

00:26:43.459 --> 00:26:48.739
如果你有一个O然后是元素

00:26:46.279 --> 00:26:50.629
数组的类型就是你得到的

00:26:48.739 --> 00:26:53.359
从那条溪流回来，所以我们

00:26:50.629 --> 00:26:56.869
我们正在使用分组进行收集

00:26:53.359 --> 00:26:59.209
通过，所以结果是每个元素是

00:26:56.869 --> 00:27:02.779
正确的地图，这就是我们的

00:26:59.209 --> 00:27:05.299
我们从一个月的天算起

00:27:02.779 --> 00:27:08.899
抱歉，那是从那天起的地图

00:27:05.299 --> 00:27:11.599
一个月来计数，以此类推

00:27:08.899 --> 00:27:14.450
内在，所以已经是你

00:27:11.599 --> 00:27:16.070
看到那里的内部分组等等

00:27:14.450 --> 00:27:18.109
假设我们正在开发一个

00:27:16.070 --> 00:27:20.570
正确的一个月

00:27:18.109 --> 00:27:23.179
通过该月的每一天

00:27:20.570 --> 00:27:26.989
该月份使用当月的日期作为

00:27:23.179 --> 00:27:29.089
作为分组键，然后是计数

00:27:26.989 --> 00:27:31.009
最终得出的值就是

00:27:29.089 --> 00:27:34.609
你得到那变成你的

00:27:31.009 --> 00:27:36.979
内部分组依据，但我们包装了一些东西

00:27:34.609 --> 00:27:40.299
围绕它是一​​个for循环是

00:27:36.979 --> 00:27:46.519
每个月，但结果是

00:27:40.299 --> 00:27:48.320
每月的条目数组是

00:27:46.519 --> 00:27:50.479
这张地图，所以如果您考虑

00:27:48.320 --> 00:27:53.329
用不同的方式排列

00:27:50.479 --> 00:27:54.829
这是一组地图

00:27:53.329 --> 00:27:56.329
所有混合数组和泛型是

00:27:54.829 --> 00:27:57.709
通常很糟糕，我想你

00:27:56.329 --> 00:27:59.599
没有在

00:27:57.709 --> 00:28:00.769
数组，因为它真的很丑，因为

00:27:59.599 --> 00:28:03.149
因为你必须使用

00:28:00.769 --> 00:28:05.820
为了分配它不安全的演员，但是

00:28:03.149 --> 00:28:07.859
但实际上这应该开始

00:28:05.820 --> 00:28:09.989
告诉你，也许数组不是

00:28:07.859 --> 00:28:11.549
正确的数据结构，因为如果

00:28:09.989 --> 00:28:14.309
你有一个从0到11的数组

00:28:11.549 --> 00:28:17.219
其中每个数组索引代表一个

00:28:14.309 --> 00:28:19.979
月，然后您存储了一个值

00:28:17.219 --> 00:28:23.429
在那个实际上是地图的数组中

00:28:19.979 --> 00:28:25.950
从一个月到某个值的地图等等

00:28:23.429 --> 00:28:28.259
那就是我们得到外部地图的地方

00:28:25.950 --> 00:28:29.879
而不是遍历数组

00:28:28.259 --> 00:28:31.559
其实这是另一回事

00:28:29.879 --> 00:28:33.210
难道这是想象中的很大

00:28:31.559 --> 00:28:37.049
数据集实际上在

00:28:33.210 --> 00:28:39.479
整个数据集12次等等

00:28:37.049 --> 00:28:41.669
我们真正想做的就是拿一个

00:28:39.479 --> 00:28:43.619
越过数组，然后说“好吧” 

00:28:41.669 --> 00:28:46.409
这个月属于和分类

00:28:43.619 --> 00:28:51.269
现在我们有了一些数据

00:28:46.409 --> 00:28:54.749
这个月说几号

00:28:51.269 --> 00:28:59.369
是这个，所以我们将其分类

00:28:54.749 --> 00:29:01.229
再次，然后与该项目加1 

00:28:59.369 --> 00:29:03.690
这很重要，所以我们正在做这两个

00:29:01.229 --> 00:29:06.599
首先按月分类

00:29:03.690 --> 00:29:08.700
第一次咬人，然后第二天

00:29:06.599 --> 00:29:12.210
这个月，这就是我们得到我们的地方

00:29:08.700 --> 00:29:13.919
两个分组购买，因此，如果你

00:29:12.210 --> 00:29:16.409
从数组更改数据结构

00:29:13.919 --> 00:29:17.969
到地图，然后你可以说，哦，我们

00:29:16.409 --> 00:29:19.739
按月分类，并随时进行分类

00:29:17.969 --> 00:29:21.570
您通过某种价值进行分类

00:29:19.739 --> 00:29:23.729
在那变成一个分组

00:29:21.570 --> 00:29:25.200
最外面的分组依据来自和

00:29:23.729 --> 00:29:27.419
所以你为什么不回头

00:29:25.200 --> 00:29:30.289
到那里的最后一张幻灯片，您

00:29:27.419 --> 00:29:30.289
你能看到吗

00:29:32.330 --> 00:29:37.920
所以我想这就是你

00:29:36.180 --> 00:29:40.320
一旦知道就明白了

00:29:37.920 --> 00:29:43.350
接受了按分组的想法

00:29:40.320 --> 00:29:44.460
然后将事物分类为地图

00:29:43.350 --> 00:29:46.980
我们知道你看到第一个

00:29:44.460 --> 00:29:49.650
分组是按月第二分组

00:29:46.980 --> 00:29:53.000
按是按月的天数，然后是计数

00:29:49.650 --> 00:29:55.110
是第三件事，所以你明白了

00:29:53.000 --> 00:29:57.300
意思是有点复杂，但是

00:29:55.110 --> 00:29:59.160
这种嵌套的地图结构，但很多

00:29:57.300 --> 00:30:03.090
比拥有一张地图要好

00:29:59.160 --> 00:30:04.620
告诉你，还有另一件事

00:30:03.090 --> 00:30:07.440
如果你还记得以前的话

00:30:04.620 --> 00:30:09.240
幻灯片，我们很好，幻灯片上没有

00:30:07.440 --> 00:30:12.720
是数组的初始分配

00:30:09.240 --> 00:30:15.470
然后是什么

00:30:12.720 --> 00:30:18.660
中间代码是对

00:30:15.470 --> 00:30:20.610
单个数组元素等等

00:30:18.660 --> 00:30:22.830
每个内部都有副作用

00:30:20.610 --> 00:30:27.390
对，所以如果我们继续这个主题，我们

00:30:22.830 --> 00:30:29.640
想要我们想要我们想要避免的一面

00:30:27.390 --> 00:30:31.770
可能的话说效果好吧

00:30:29.640 --> 00:30:33.809
我们构造一个具有正确的价值

00:30:31.770 --> 00:30:36.720
我们想要的属性，这就是

00:30:33.809 --> 00:30:38.220
收集做到了，所以我们拥有了我们所有的

00:30:36.720 --> 00:30:39.960
流元素通过它们运行

00:30:38.220 --> 00:30:41.910
嵌套的收集器

00:30:39.960 --> 00:30:44.370
分类并建立这个

00:30:41.910 --> 00:30:46.520
两级地图，这就是

00:30:44.370 --> 00:30:52.800
我们的方法，所以这里没有副作用

00:30:46.520 --> 00:30:54.690
很好，所以下一个是其中之一

00:30:52.800 --> 00:30:56.429
我们在动手实验室中所做的事情

00:30:54.690 --> 00:30:59.640
斯图尔特和我曾经是

00:30:56.429 --> 00:31:01.740
今天昨天我已经进行了动手实验

00:30:59.640 --> 00:31:02.850
用于人们锻炼的溪流

00:31:01.740 --> 00:31:05.340
他们可以通过努力，他们可以

00:31:02.850 --> 00:31:08.580
看看他们是如何工作的，所以其中之一

00:31:05.340 --> 00:31:11.190
去年我跑了，我认为那是

00:31:08.580 --> 00:31:12.750
一个简单的练习就是你有

00:31:11.190 --> 00:31:14.820
连接的第一个字符

00:31:12.750 --> 00:31:16.980
列表中的每个字符串生成一个新的

00:31:14.820 --> 00:31:19.080
字符串，因此输入为alpha Bravo 

00:31:16.980 --> 00:31:20.390
查理·德尔塔（Charlie Delta）回响了狐步舞（Foxtrot），所以我们

00:31:19.080 --> 00:31:25.040
在寻找是一种获得

00:31:20.390 --> 00:31:28.260
 ABCDEF好的，答案是

00:31:25.040 --> 00:31:31.800
不使用它实际上使用的流

00:31:28.260 --> 00:31:34.500
对于每种方法在可迭代

00:31:31.800 --> 00:31:36.809
界面，所以我们要做的是创建一个

00:31:34.500 --> 00:31:38.309
字符串生成器，然后我们说输入点

00:31:36.809 --> 00:31:41.640
对于每个人，这是一个合法用户

00:31:38.309 --> 00:31:43.020
对于每个，我们说追加字符

00:31:41.640 --> 00:31:47.100
在我们的零

00:31:43.020 --> 00:31:48.720
米勒是的，然后结果很简单

00:31:47.100 --> 00:31:49.140
从中提取字符串

00:31:48.720 --> 00:31:51.179
字符串生成器

00:31:49.140 --> 00:31:53.940
三行代码完全符合其要求

00:31:51.179 --> 00:31:55.650
应该可以，并且效果很好，所以

00:31:53.940 --> 00:31:57.990
发生的事情是我在做

00:31:55.650 --> 00:31:59.340
这门课，有人问一个

00:31:57.990 --> 00:32:00.660
问题他们说很好，这样

00:31:59.340 --> 00:32:03.120
使用可以做到的

00:32:00.660 --> 00:32:04.559
溪流，我说很好，是的，我想我们

00:32:03.120 --> 00:32:07.200
可以用流做到这一点，让我们去做

00:32:04.559 --> 00:32:08.910
这样的正确结果，我们

00:32:07.200 --> 00:32:11.990
接受他们的意见我们接受信息流我们

00:32:08.910 --> 00:32:14.550
映射我们使用的子字符串0 1 

00:32:11.990 --> 00:32:17.220
所以我们映射到中的第一个字符

00:32:14.550 --> 00:32:19.140
字符串，然后我们减少它

00:32:17.220 --> 00:32:21.540
我们将使用减少量减少

00:32:19.140 --> 00:32:23.160
我们取一个初始值是

00:32:21.540 --> 00:32:25.950
一个空字符串，然后我们使用

00:32:23.160 --> 00:32:28.410
累加器说

00:32:25.950 --> 00:32:30.860
部分结果a和中的下一个元素

00:32:28.410 --> 00:32:33.150
流是E并应用一些

00:32:30.860 --> 00:32:36.090
在这种情况下积累到那些

00:32:33.150 --> 00:32:38.070
我们只是在进行字符串连接，所以

00:32:36.090 --> 00:32:39.660
看着那个，还好吧

00:32:38.070 --> 00:32:41.280
那并不能解决问题，但是

00:32:39.660 --> 00:32:43.860
这样做不是很好，因为

00:32:41.280 --> 00:32:45.210
甚至我看到我们在做弦乐

00:32:43.860 --> 00:32:47.100
串联在一起，所以有很多

00:32:45.210 --> 00:32:49.559
正在创建的中间对象和

00:32:47.100 --> 00:32:50.700
我们会遇到这样的情况

00:32:49.559 --> 00:32:52.140
大数据集

00:32:50.700 --> 00:32:55.200
这肯定是非常低效的

00:32:52.140 --> 00:32:56.460
与上一个相比，那么

00:32:55.200 --> 00:32:58.860
问题很好，我们可以用

00:32:56.460 --> 00:33:00.450
使用字符串生成器还原

00:32:58.860 --> 00:33:01.890
而不是您知道使用字符串

00:33:00.450 --> 00:33:04.380
串联操作，让我们使用

00:33:01.890 --> 00:33:06.390
字符串生成器，所以我认为正确，让我们

00:33:04.380 --> 00:33:09.990
看看我们能否做到，我想出了

00:33:06.390 --> 00:33:11.640
一段代码来做那种

00:33:09.990 --> 00:33:14.640
有趣，所以我们创建了一个新字符串

00:33:11.640 --> 00:33:16.380
建造者，然后我们说输入

00:33:14.640 --> 00:33:18.570
流，然后将其映射到我们的

00:33:16.380 --> 00:33:20.100
子串，然后我们减少它，但是

00:33:18.570 --> 00:33:23.250
这次我们将使用我们的字符串生成器

00:33:20.100 --> 00:33:25.770
在减少，我们会说

00:33:23.250 --> 00:33:27.510
累加器将附加B，然后

00:33:25.770 --> 00:33:31.140
以字符串形式返回，以便

00:33:27.510 --> 00:33:35.220
通过挂起创建新的穿刺结果

00:33:31.140 --> 00:33:36.510
 B到我们的字符串，那么我们得到的结果

00:33:35.220 --> 00:33:38.640
因为它是可选的，我们不需要

00:33:36.510 --> 00:33:41.850
返回期权的价值

00:33:38.640 --> 00:33:44.370
是这样的，谁认为这行得通

00:33:41.850 --> 00:33:45.800
是的，很好，我显然不会

00:33:44.370 --> 00:33:48.690
问这个问题我是否有用

00:33:45.800 --> 00:33:52.730
好的，这样失败了，每个人

00:33:48.690 --> 00:33:52.730
想猜出实际结果是什么

00:33:52.820 --> 00:34:00.330
不，第二个没有不同的顺序

00:33:57.780 --> 00:34:03.870
现在收到的信件实际上是不列颠哥伦比亚省

00:34:00.330 --> 00:34:05.340
 def的原因是，如果你

00:34:03.870 --> 00:34:08.040
看看那里的减少

00:34:05.340 --> 00:34:10.950
和b，而我已经方便地忽略了a 

00:34:08.040 --> 00:34:13.260
现在a是部分结果，当您

00:34:10.950 --> 00:34:15.510
首先开始处理流

00:34:13.260 --> 00:34:17.640
第一个部分结果是第一个

00:34:15.510 --> 00:34:20.130
流中的元素，所以如果您忽略

00:34:17.640 --> 00:34:22.560
第一个部分结果，那么你就不会

00:34:20.130 --> 00:34:25.320
在流中直奔

00:34:22.560 --> 00:34:27.960
你没有得到你所需要的，所以我

00:34:25.320 --> 00:34:29.820
自以为我不会

00:34:27.960 --> 00:34:31.440
被此打败有办法

00:34:29.820 --> 00:34:35.400
这使用字符串生成器，所以我

00:34:31.440 --> 00:34:38.070
想出了这个，所以我说好吧

00:34:35.400 --> 00:34:40.260
偷偷摸摸的说，如果

00:34:38.070 --> 00:34:42.450
这是我们的部分结果有一个长度

00:34:40.260 --> 00:34:44.730
的1表示它是第一个元素

00:34:42.450 --> 00:34:46.919
因为那时只有一个字符

00:34:44.730 --> 00:34:48.960
我们将a附加到我们的字符串生成器

00:34:46.919 --> 00:34:52.710
否则我们会忽略这一点，而我们只是

00:34:48.960 --> 00:34:54.870
返回那里速度追加B到字符串

00:34:52.710 --> 00:34:57.570
很棒，实际上给了你

00:34:54.870 --> 00:34:58.530
正确的结果显然是

00:34:57.570 --> 00:35:00.720
不是最好的方法

00:34:58.530 --> 00:35:02.220
所以我们来讨论一下

00:35:00.720 --> 00:35:04.860
在课堂上进一步，我们说很好

00:35:02.220 --> 00:35:08.070
而不是使用显式减少

00:35:04.860 --> 00:35:10.920
让我们使用一种减少形式

00:35:08.070 --> 00:35:13.020
好的，现在可以创建您的收藏了

00:35:10.920 --> 00:35:14.910
自己的收藏家，所以我们能做的就是

00:35:13.020 --> 00:35:16.860
可以说让我们收集，然后我们将

00:35:14.910 --> 00:35:18.870
说收集点关闭，我们将创建一个

00:35:16.860 --> 00:35:20.970
新收藏家和创建方式

00:35:18.870 --> 00:35:23.390
收藏家，您需要提供一个号码

00:35:20.970 --> 00:35:25.650
如果您喜欢

00:35:23.390 --> 00:35:27.840
收集器，所以第一个是

00:35:25.650 --> 00:35:30.000
供应商我们要收集什么

00:35:27.840 --> 00:35:31.800
因此，在这种情况下，我们会说

00:35:30.000 --> 00:35:33.000
 stringbuilder，所以我们要使用

00:35:31.800 --> 00:35:37.410
继续生成一个新的字符串

00:35:33.000 --> 00:35:38.660
生成器，所以我们使用构造器

00:35:37.410 --> 00:35:42.180
这就是我要寻找的参考

00:35:38.660 --> 00:35:43.560
那你需要一个累加器

00:35:42.180 --> 00:35:45.120
也许我们正在减少，所以我们需要

00:35:43.560 --> 00:35:47.250
一个累加器，在这种情况下，我们要

00:35:45.120 --> 00:35:49.980
将字符串追加到字符串

00:35:47.250 --> 00:35:51.690
建设者伟大然后第三个论点

00:35:49.980 --> 00:35:54.420
有点奇怪，因为你需要一个

00:35:51.690 --> 00:35:57.270
合并器和合并器在这种情况下是

00:35:54.420 --> 00:35:59.070
与蓄电池相同的原因

00:35:57.270 --> 00:36:01.440
具有组合器和累加器

00:35:59.070 --> 00:36:04.260
可能会被拆分

00:36:01.440 --> 00:36:05.010
分成多个线程，所以每个线程

00:36:04.260 --> 00:36:06.750
将

00:36:05.010 --> 00:36:09.180
使用累加器生成其

00:36:06.750 --> 00:36:11.070
特定的结果，然后是组合器

00:36:09.180 --> 00:36:15.050
用于合并每个结果

00:36:11.070 --> 00:36:17.580
线程成单个结果

00:36:15.050 --> 00:36:18.540
收集，因此它们可能是

00:36:17.580 --> 00:36:20.460
不同，但在这种情况下，它们是

00:36:18.540 --> 00:36:22.560
他们是一样的，然后你需要一个

00:36:20.460 --> 00:36:24.900
整理器，这就是您生成

00:36:22.560 --> 00:36:26.520
从您所做的工作中得到的结果

00:36:24.900 --> 00:36:29.490
一直在做，在这种情况下，我们只是

00:36:26.520 --> 00:36:32.790
现在调用to字符串

00:36:29.490 --> 00:36:34.710
显然有效并且很好，但是有

00:36:32.790 --> 00:36:36.960
实际上是一种更简单的方法

00:36:34.710 --> 00:36:39.360
这只是使用收集器

00:36:36.960 --> 00:36:40.740
加入，所以使用现有的收集器

00:36:39.360 --> 00:36:42.120
实际上，如果您查看源代码

00:36:40.740 --> 00:36:43.620
收集者加入您的代码

00:36:42.120 --> 00:36:47.160
发现它与

00:36:43.620 --> 00:36:51.510
上一张幻灯片，所以我最终做了

00:36:47.160 --> 00:36:52.950
本质上是一样的东西，所以可以

00:36:51.510 --> 00:36:56.790
你回头开始

00:36:52.950 --> 00:37:05.700
场景只是几个简短的评论

00:36:56.790 --> 00:37:08.340
好的，所以代码段位于

00:37:05.700 --> 00:37:09.810
底部和西蒙一样正确

00:37:08.340 --> 00:37:12.810
观察到，但是效率很低

00:37:09.810 --> 00:37:15.570
因为这是这个字符串

00:37:12.810 --> 00:37:18.120
串联反模式等

00:37:15.570 --> 00:37:20.460
问题是当您减少这种方式

00:37:18.120 --> 00:37:22.290
中间结果被复制

00:37:20.460 --> 00:37:24.600
多次，因为它正在产生

00:37:22.290 --> 00:37:27.360
每次都是字符串，所以如果您有n 

00:37:24.600 --> 00:37:29.220
正在输入的字符串

00:37:27.360 --> 00:37:31.710
通过这种方式串联起来， 

00:37:29.220 --> 00:37:33.870
有序和平方问题，所以这是

00:37:31.710 --> 00:37:35.850
一种非常非常昂贵的方式

00:37:33.870 --> 00:37:37.800
连接字符串，这就是为什么我们

00:37:35.850 --> 00:37:39.570
添加了加入方法，因为

00:37:37.800 --> 00:37:41.550
这是很平常的事情，我们不想

00:37:39.570 --> 00:37:43.860
人们不得不写昂贵的东西

00:37:41.550 --> 00:37:45.930
这样的算法还可以

00:37:43.860 --> 00:37:48.570
一旦你去了真正的

00:37:45.930 --> 00:37:49.980
一对夫妇真的很复杂哦

00:37:48.570 --> 00:37:53.670
这样我就可以

00:37:49.980 --> 00:37:54.930
西蒙在这里重申，如果

00:37:53.670 --> 00:37:56.340
你有一个减少功能

00:37:54.930 --> 00:37:59.400
不使用其参数之一

00:37:56.340 --> 00:38:00.960
很可能是错误的，而实际上

00:37:59.400 --> 00:38:02.910
但是你想做什么

00:38:00.960 --> 00:38:03.740
我以前也看过

00:38:02.910 --> 00:38:06.490
用其他代码

00:38:03.740 --> 00:38:08.660
那是引导你去的东西吗

00:38:06.490 --> 00:38:10.790
不使用参数之一是

00:38:08.660 --> 00:38:13.100
你正在做副作用吗

00:38:10.790 --> 00:38:15.230
对，如此再次消除

00:38:13.100 --> 00:38:16.490
副作用或避免副作用

00:38:15.230 --> 00:38:20.750
是我们需要注意的事情

00:38:16.490 --> 00:38:23.270
好吧，再来一张幻灯片，这样

00:38:20.750 --> 00:38:25.030
关于另一点

00:38:23.270 --> 00:38:27.350
归约函数是必须

00:38:25.030 --> 00:38:29.150
联想，当我们到达

00:38:27.350 --> 00:38:33.440
并行性将是

00:38:29.150 --> 00:38:35.119
问题，但没有时间讨论

00:38:33.440 --> 00:38:36.200
关于某事是否的完整解释

00:38:35.119 --> 00:38:38.150
联想的，但有很多

00:38:36.200 --> 00:38:39.619
是的东西，如果你有

00:38:38.150 --> 00:38:41.750
有点复杂的东西

00:38:39.619 --> 00:38:45.170
实际使您通过证明

00:38:41.750 --> 00:38:48.320
是否具有关联性以及是否

00:38:45.170 --> 00:38:50.720
你的减少有副作用

00:38:48.320 --> 00:38:54.110
证明变得极端的功能

00:38:50.720 --> 00:38:56.090
困难，即使不是不可能，所以一次

00:38:54.110 --> 00:38:58.010
再次避免副作用

00:38:56.090 --> 00:39:01.130
好吧，为什么我们不继续下一个

00:38:58.010 --> 00:39:01.940
场景好吧，是的，我想我们是

00:39:01.130 --> 00:39:05.450
可能不会通过

00:39:01.940 --> 00:39:08.630
最后一切都好，所以我们将

00:39:05.450 --> 00:39:11.900
做一些快速的性能示例，以便

00:39:08.630 --> 00:39:14.000
一个是极好的复用的好坏

00:39:11.900 --> 00:39:17.090
我们这里有1英寸的流

00:39:14.000 --> 00:39:19.310
十个打印出来，为什么我们不

00:39:17.090 --> 00:39:22.100
重用它，你知道创造生活吗

00:39:19.310 --> 00:39:24.170
任何人都认为有效的井再利用

00:39:22.100 --> 00:39:25.369
那会再次工作，我问一个

00:39:24.170 --> 00:39:26.840
你可能不会去的问题

00:39:25.369 --> 00:39:28.369
答案是肯定的，因为

00:39:26.840 --> 00:39:30.290
会抛出非法状态异常

00:39:28.369 --> 00:39:33.290
因为流已经

00:39:30.290 --> 00:39:35.030
已开启或关闭，因此您可以

00:39:33.290 --> 00:39:38.090
只使用流

00:39:35.030 --> 00:39:40.850
关于第二个重要的事情

00:39:38.090 --> 00:39:42.530
哪个更好，为什么我们有

00:39:40.850 --> 00:39:45.710
点流，然后我们做一个

00:39:42.530 --> 00:39:46.970
过滤器地图，以及每个等等

00:39:45.710 --> 00:39:48.530
我们正在使用显式lambda 

00:39:46.970 --> 00:39:50.750
在这里表达我们要

00:39:48.530 --> 00:39:53.140
得到的是这一观点倒置

00:39:50.750 --> 00:39:55.280
点，然后打印出来一样

00:39:53.140 --> 00:39:57.470
有效的代码在功能上

00:39:55.280 --> 00:39:59.359
相同的流过滤器，但是这次

00:39:57.470 --> 00:40:02.660
我们正在使用方法参考

00:39:59.359 --> 00:40:06.530
比lambda表达式更重要

00:40:02.660 --> 00:40:07.820
最重要的是更有效的

00:40:06.530 --> 00:40:11.279
认为最底层的效率更高

00:40:07.820 --> 00:40:13.739
好吧，谁以为他们是一样的

00:40:11.279 --> 00:40:16.439
好的，答案是最底层

00:40:13.739 --> 00:40:18.179
一个稍微更有效， 

00:40:16.439 --> 00:40:19.259
实际上，如果您想这样做的原因

00:40:18.179 --> 00:40:20.939
了解更多有关您可以来找我的信息

00:40:19.259 --> 00:40:22.739
会议今天下午我在说什么

00:40:20.939 --> 00:40:25.079
关于lambdas是明确的，但

00:40:22.739 --> 00:40:28.619
关键是当lambda 

00:40:25.079 --> 00:40:30.239
编译它在

00:40:28.619 --> 00:40:32.609
 Lambda表达式的主体需要

00:40:30.239 --> 00:40:34.619
放入关联的方法

00:40:32.609 --> 00:40:36.839
与使用它的地方

00:40:34.619 --> 00:40:39.659
所以如果我们已经有方法参考

00:40:36.839 --> 00:40:41.099
那你就不用放进去了

00:40:39.659 --> 00:40:43.619
另一个方法参考或另一个

00:40:41.099 --> 00:40:45.959
方法，这样可以节省

00:40:43.619 --> 00:40:47.869
间接，如果您本质上知道的话

00:40:45.959 --> 00:40:50.509
这就是为什么它多一点的原因

00:40:47.869 --> 00:40:53.759
在性能方面略胜一筹

00:40:50.509 --> 00:40:56.519
然后可以进行多种排序，所以这是

00:40:53.759 --> 00:40:57.869
做事的方式不好，所以我们是

00:40:56.519 --> 00:41:00.089
看起来我们有一些耐心

00:40:57.869 --> 00:41:02.039
得到了一些关于他们的信息，所以

00:41:00.089 --> 00:41:04.109
我们说这是否有效

00:41:02.039 --> 00:41:05.459
记录然后我们要按药物排序

00:41:04.109 --> 00:41:07.169
那我们想通过身体说话

00:41:05.459 --> 00:41:10.259
医生，我们排序想要排序

00:41:07.169 --> 00:41:11.459
名称，所以我们在某种意义上做到了

00:41:10.259 --> 00:41:14.759
实际情况是

00:41:11.459 --> 00:41:16.499
如果我们这样做，那就更好了

00:41:14.759 --> 00:41:18.089
比较，所以我们在做同样的事情

00:41:16.499 --> 00:41:19.769
效果，因此我们仍在根据

00:41:18.089 --> 00:41:22.619
但是我们也必须颠倒顺序

00:41:19.769 --> 00:41:27.599
命名医生药物，所以要

00:41:22.619 --> 00:41:29.969
说并行流好吧，我们只是

00:41:27.599 --> 00:41:32.609
这么简短地谈论一下

00:41:29.969 --> 00:41:34.319
流肯定更快，因为我们

00:41:32.609 --> 00:41:37.469
并行做事，我们必须

00:41:34.319 --> 00:41:39.239
不幸的是，更快更好的结果是

00:41:37.469 --> 00:41:41.579
不能保证，原因是

00:41:39.239 --> 00:41:43.380
是可以并行流

00:41:41.579 --> 00:41:45.539
确保永远

00:41:43.380 --> 00:41:46.799
参与更多的工作，因为您有

00:41:45.539 --> 00:41:49.589
使用的fork / join框架

00:41:46.799 --> 00:41:52.529
下面以及您必须设置的内容

00:41:49.589 --> 00:41:53.969
您必须创建的框架

00:41:52.529 --> 00:41:55.829
与队列关联的作业

00:41:53.969 --> 00:41:57.809
对于那些线程，您必须做所有

00:41:55.829 --> 00:42:00.419
工作，然后您必须收集

00:41:57.809 --> 00:42:02.459
最后的结果，所以绝对

00:42:00.419 --> 00:42:05.489
可能会做更多的工作，或者

00:42:02.459 --> 00:42:06.929
可能会更快完成

00:42:05.489 --> 00:42:09.869
关于并行流的重要事实

00:42:06.929 --> 00:42:12.569
是他们使用共同点的事实

00:42:09.869 --> 00:42:14.279
叉/连接池，所以有一个叉/连接

00:42:12.569 --> 00:42:17.039
 JVM启动时创建的池

00:42:14.279 --> 00:42:18.539
起来，他们会在

00:42:17.039 --> 00:42:20.849
他们将始终使用的并行流

00:42:18.539 --> 00:42:22.409
分叉/联接池

00:42:20.849 --> 00:42:24.779
使用它的CPU数量

00:42:22.409 --> 00:42:25.200
默认为内核或CPU的数量

00:42:24.779 --> 00:42:26.940
那

00:42:25.200 --> 00:42:28.710
操作系统报告的一些

00:42:26.940 --> 00:42:30.150
人们说这是这个数字的两倍

00:42:28.710 --> 00:42:31.860
有人说这是另一个优点

00:42:30.150 --> 00:42:33.420
一个，如果你看一下源代码就是

00:42:31.860 --> 00:42:35.760
实际报告的CPU数量

00:42:33.420 --> 00:42:37.020
操作系统的一点是

00:42:35.760 --> 00:42:40.170
有趣的是，如果你是

00:42:37.020 --> 00:42:41.310
使用JDK 8我不确定这是否是

00:42:40.170 --> 00:42:45.210
被反向移植，但如果您使用的是

00:42:41.310 --> 00:42:46.890
 JDK 8无法识别组

00:42:45.210 --> 00:42:49.650
表示如果您使用的是Docker容器

00:42:46.890 --> 00:42:51.690
然后您在该docker中运行JVM 

00:42:49.650 --> 00:42:53.490
设置完整关节时的容器

00:42:51.690 --> 00:42:55.320
池，这对于内存是相同的

00:42:53.490 --> 00:42:56.550
它也用于堆

00:42:55.320 --> 00:42:59.130
将获得整个结果

00:42:56.550 --> 00:43:01.710
机器不是用于容器JDK 9的

00:42:59.130 --> 00:43:05.760
进行了一些更改，因此Linux上的JDK 9是

00:43:01.710 --> 00:43:07.440
现在容器知道了，所以最后

00:43:05.760 --> 00:43:10.620
最后一个例子很快，因为我们已经

00:43:07.440 --> 00:43:13.020
大约嵌套了两分钟

00:43:10.620 --> 00:43:15.330
流这是一个非常糟糕的主意

00:43:13.020 --> 00:43:18.960
因为我们使用相同的fork / join 

00:43:15.330 --> 00:43:20.490
池，这意味着尽管我们有

00:43:18.960 --> 00:43:22.770
单独的队列，所以我们什么也没得到

00:43:20.490 --> 00:43:24.900
我们试图使用的数据损坏

00:43:22.770 --> 00:43:27.950
同一套线程来做嵌套

00:43:24.900 --> 00:43:29.970
并行流，您最终得到

00:43:27.950 --> 00:43:31.650
实际上是最差的性能，因为

00:43:29.970 --> 00:43:33.600
您正在尝试重用这些线程，但是

00:43:31.650 --> 00:43:35.310
因此，不要将它们分开

00:43:33.600 --> 00:43:38.010
与不同的线程相关联

00:43:35.310 --> 00:43:40.040
并行流会变得更糟

00:43:38.010 --> 00:43:43.590
在表演的情况下

00:43:40.040 --> 00:43:46.650
有办法解决

00:43:43.590 --> 00:43:48.720
这是您创建自己的fork / join 

00:43:46.650 --> 00:43:51.570
池，以便您实际上可以为

00:43:48.720 --> 00:43:53.130
使用如何

00:43:51.570 --> 00:43:55.590
你想要很多线程，然后你

00:43:53.130 --> 00:43:58.080
提交并行任务

00:43:55.590 --> 00:43:59.550
这将使用单独的一组

00:43:58.080 --> 00:44:00.690
线程，因此您可能会得到

00:43:59.550 --> 00:44:02.280
更好的表现，但是你有一些东西

00:44:00.690 --> 00:44:04.200
可以这样说吗

00:44:02.280 --> 00:44:06.150
这种技术的事情在这里如此

00:44:04.200 --> 00:44:07.740
一种是如果您发现自己想要

00:44:06.150 --> 00:44:09.510
用你自己的fork / join池，我想如果

00:44:07.740 --> 00:44:12.300
您会非常仔细地考虑

00:44:09.510 --> 00:44:14.490
首先是这真的是

00:44:12.300 --> 00:44:16.050
具体实施行为

00:44:14.490 --> 00:44:18.720
是如果您将任务提交给

00:44:16.050 --> 00:44:21.780
派生/加入池任何流处理

00:44:18.720 --> 00:44:24.420
那就是在该任务中完成的

00:44:21.780 --> 00:44:25.950
将在同一fork / join中执行

00:44:24.420 --> 00:44:27.660
池，这就是它的工作原理，但是

00:44:25.950 --> 00:44:30.110
规范并不能保证

00:44:27.660 --> 00:44:32.730
今天的实施方式

00:44:30.110 --> 00:44:34.050
当然，对于所有JDK代理来说，我的意思是

00:44:32.730 --> 00:44:35.480
这样工作，就在此时

00:44:34.050 --> 00:44:37.670
它不会改变，但是可能

00:44:35.480 --> 00:44:39.650
将来的变化发布第二

00:44:37.670 --> 00:44:41.150
事情是这样，你也许会

00:44:39.650 --> 00:44:42.290
可能会觉得很好，我要

00:44:41.150 --> 00:44:44.060
控制这个，所以我要创建我的

00:44:42.290 --> 00:44:45.800
拥有自己的fork / join池，但是您应该

00:44:44.060 --> 00:44:47.450
非常小心，因为如果您开始

00:44:45.800 --> 00:44:49.670
在您的整个范围内创建派生/联接池

00:44:47.450 --> 00:44:51.200
代码，并且它们具有硬编码的常量

00:44:49.670 --> 00:44:53.000
在这里，你知道有人会跑

00:44:51.200 --> 00:44:56.890
这在24核计算机上并说为什么

00:44:53.000 --> 00:44:59.240
我只会得到4倍的速度吗？ 

00:44:56.890 --> 00:45:01.430
有人在一些核心机器上运行它

00:44:59.240 --> 00:45:02.840
并且正在进行线程争用

00:45:01.430 --> 00:45:04.850
因为每个人都创造了自己的

00:45:02.840 --> 00:45:07.070
每个人都认为的fork / join池

00:45:04.850 --> 00:45:09.560
拥有整个机器或容器，或

00:45:07.070 --> 00:45:11.330
不管怎样，我的意思是这是有效的

00:45:09.560 --> 00:45:12.619
技术，如果您正在尝试，并且

00:45:11.330 --> 00:45:15.710
您对自己的做法非常谨慎

00:45:12.619 --> 00:45:18.800
部署它，但是太多了

00:45:15.710 --> 00:45:20.060
这里要注意的事情还可以

00:45:18.800 --> 00:45:23.990
所以基本上就是这样

00:45:20.060 --> 00:45:26.390
因此总的来说，信息流非常

00:45:23.990 --> 00:45:29.330
强大但强大

00:45:26.390 --> 00:45:30.710
责任重大

00:45:29.330 --> 00:45:32.840
希望你从那里得到的东西

00:45:30.710 --> 00:45:34.400
这是试图不要命令式地思考

00:45:32.840 --> 00:45:36.440
尽量不要以循环的方式思考

00:45:34.400 --> 00:45:39.410
因为每当你想到每个

00:45:36.440 --> 00:45:41.060
您需要退后一步说

00:45:39.410 --> 00:45:42.560
你应该做的方式以及

00:45:41.060 --> 00:45:44.810
斯图尔特在

00:45:42.560 --> 00:45:47.840
演示文稿的副作用是东西

00:45:44.810 --> 00:45:51.440
如果可以避免的话可以避免

00:45:47.840 --> 00:45:54.020
然后所有的费用都要做

00:45:51.440 --> 00:45:56.030
流的力量在于

00:45:54.020 --> 00:45:57.859
该代码不要像我那样被诱惑

00:45:56.030 --> 00:45:59.440
去尝试把所有东西都塞进去

00:45:57.859 --> 00:46:01.790
尽可能少的行数

00:45:59.440 --> 00:46:03.950
使其可读性使其易于理解

00:46:01.790 --> 00:46:05.950
由其他人，正如我们刚才解释的

00:46:03.950 --> 00:46:08.119
并行不一定意味着更快

00:46:05.950 --> 00:46:10.430
所以我认为那是你知道你已经

00:46:08.119 --> 00:46:12.230
如果您有几个关键要点

00:46:10.430 --> 00:46:17.690
发现自己一边写一边

00:46:12.230 --> 00:46:18.900
效果看收藏家，谢谢

00:46:17.690 --> 00:46:20.960
非常

00:46:18.900 --> 00:46:20.960
您

