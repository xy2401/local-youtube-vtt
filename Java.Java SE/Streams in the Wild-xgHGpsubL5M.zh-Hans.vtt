WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.500 --> 00:00:10.140
好吧，我想我们可以开始欢迎了

00:00:08.430 --> 00:00:13.800
在一段时间内转到这些谈话流

00:00:10.140 --> 00:00:18.660
谢谢您的光临，希望您会喜欢

00:00:13.800 --> 00:00:21.360
您接下来的45分钟在这个房间里我

00:00:18.660 --> 00:00:22.920
想和你谈谈今天是

00:00:21.360 --> 00:00:26.100
当然关于流API 

00:00:22.920 --> 00:00:27.210
在Java 8中引入，尤其是在

00:00:26.100 --> 00:00:29.750
给你看

00:00:27.210 --> 00:00:32.489
流API的高级模式

00:00:29.750 --> 00:00:35.880
基本上基于分离器

00:00:32.489 --> 00:00:39.630
 API，它是来自内部的API 

00:00:35.880 --> 00:00:43.170
流API，这将大部分是实时直播

00:00:39.630 --> 00:00:46.890
编码会议，希望大家都喜欢直播

00:00:43.170 --> 00:00:49.469
编码是做您以前的内容，但是

00:00:46.890 --> 00:00:51.450
在很多时候要点很多

00:00:49.469 --> 00:00:53.969
很多墨西哥卷饼，我为您准备了一些东西

00:00:51.450 --> 00:00:56.250
因为这表明这项工作是

00:00:53.969 --> 00:01:00.809
主要是基于我发表的作品

00:00:56.250 --> 00:01:03.870
在github上的YouTube上巨大，对不起

00:01:00.809 --> 00:01:07.970
几个月，如果不超过一年

00:01:03.870 --> 00:01:10.590
之前一个称为stream utils的API 

00:01:07.970 --> 00:01:12.510
基本上是扩展我们

00:01:10.590 --> 00:01:16.920
要显示我要显示的内容

00:01:12.510 --> 00:01:19.710
一分钟后你来，我叫乔西

00:01:16.920 --> 00:01:22.229
住在巴黎地区，这里有些

00:01:19.710 --> 00:01:24.960
与我的一些作品链接，您可以

00:01:22.229 --> 00:01:28.470
在互联网上找到包括

00:01:24.960 --> 00:01:31.650
 youtube Botox我也是

00:01:28.470 --> 00:01:34.020
巴黎Java用户组，以防您

00:01:31.650 --> 00:01:36.299
有问题只是举手

00:01:34.020 --> 00:01:39.990
喊叫声使他们可以

00:01:36.299 --> 00:01:41.700
听见和见到你，问一个问题

00:01:39.990 --> 00:01:43.350
毫不犹豫地打扰不要不要

00:01:41.700 --> 00:01:45.810
等待谈话结束，如果

00:01:43.350 --> 00:01:48.180
你有问题，如果你有

00:01:45.810 --> 00:01:50.670
之后的问题，您可以使用此

00:01:48.180 --> 00:01:52.530
标签我一直在监视它，所以如果

00:01:50.670 --> 00:01:55.790
你有一个很好的互动方式

00:01:52.530 --> 00:01:59.430
会议结束后离线

00:01:55.790 --> 00:02:01.290
现在就是幻灯片了，我知道

00:01:59.430 --> 00:02:03.119
你们中有些人可能喜欢要点

00:02:01.290 --> 00:02:05.070
我不想创建任何种类的

00:02:03.119 --> 00:02:07.049
观众的沮丧让我

00:02:05.070 --> 00:02:08.640
在这里收集了一堆子弹点

00:02:07.049 --> 00:02:13.350
给你们

00:02:08.640 --> 00:02:17.880
就是任何Oracle OpenWorld 

00:02:13.350 --> 00:02:23.540
房间里的人不应该

00:02:17.880 --> 00:02:26.250
说想像答案是正确的

00:02:23.540 --> 00:02:32.300
我正在看的是的，这是我需要

00:02:26.250 --> 00:02:35.850
切换此权限并切换到此处

00:02:32.300 --> 00:02:37.800
这是一个ID，您能看到它吗，我会

00:02:35.850 --> 00:02:38.459
最喜欢的工具是手机足够大

00:02:37.800 --> 00:02:43.709
为了每一个

00:02:38.459 --> 00:02:47.420
是的，它可以更大吗，我可以做到吗

00:02:43.709 --> 00:02:50.239
打印到模式也许在这里

00:02:47.420 --> 00:02:55.459
演示模式更大

00:02:50.239 --> 00:02:58.830
真的不是吗，每个人都可以吗

00:02:55.459 --> 00:03:01.980
好的，那我们在这里有什么

00:02:58.830 --> 00:03:05.160
有基本的字符串列表Java 8 

00:03:01.980 --> 00:03:08.340
我们可以使用的样式

00:03:05.160 --> 00:03:10.380
列表中很棒的工厂方法

00:03:08.340 --> 00:03:13.739
接口，但这仍然是Java 

00:03:10.380 --> 00:03:16.650
 8个代码，所以不是所有人都知道

00:03:13.739 --> 00:03:19.350
为此创建一个字符串，我们需要调用

00:03:16.650 --> 00:03:21.450
流媒体方法就可以了

00:03:19.350 --> 00:03:28.470
我们可以为每个实例打电话

00:03:21.450 --> 00:03:30.080
打印出该流的内容

00:03:28.470 --> 00:03:35.280
那个流

00:03:30.080 --> 00:03:37.950
好吧，让我们很好地运行此代码

00:03:35.280 --> 00:03:40.680
我们期望它在哪里做

00:03:37.950 --> 00:03:42.269
流方法来自它来

00:03:40.680 --> 00:03:46.049
从默认方法

00:03:42.269 --> 00:03:49.019
实际上的收集接口

00:03:46.049 --> 00:03:51.650
两件事在这里创建了一个分割器评分器

00:03:49.019 --> 00:03:54.720
通过调用另一个默认方法

00:03:51.650 --> 00:03:56.700
将此彼得评分者传递给信息流

00:03:54.720 --> 00:04:00.510
流支持的工厂方法

00:03:56.700 --> 00:04:03.120
可以创建流的类以及什么

00:04:00.510 --> 00:04:05.940
这个流支持类做到了吗

00:04:03.120 --> 00:04:08.430
再次做几件事

00:04:05.940 --> 00:04:11.250
创建此引用的实例

00:04:08.430 --> 00:04:13.560
实际上是管道点添加类

00:04:11.250 --> 00:04:17.220
的实施和实施

00:04:13.560 --> 00:04:19.890
流接口本身并传递

00:04:17.220 --> 00:04:22.680
我们刚刚创建的分割器评分器对象

00:04:19.890 --> 00:04:24.120
这个实现如果

00:04:22.680 --> 00:04:26.100
如果我向您显示此代码， 

00:04:24.120 --> 00:04:28.500
向您展示实际上是流

00:04:26.100 --> 00:04:31.710
对象作为运行时的实现

00:04:28.500 --> 00:04:33.990
对象实际上是在两个对象上创建的

00:04:31.710 --> 00:04:36.270
首先至少要有两个物体

00:04:33.990 --> 00:04:39.000
引用管道对象

00:04:36.270 --> 00:04:42.110
所有复杂算法的事实

00:04:39.000 --> 00:04:45.479
地图过滤器减少收集东西

00:04:42.110 --> 00:04:47.400
生活在另一个对象分裂器上

00:04:45.479 --> 00:04:49.740
对作为

00:04:47.400 --> 00:04:51.840
参数作为对此的协作者

00:04:49.740 --> 00:04:57.509
这个实现，实际上

00:04:51.840 --> 00:05:01.620
如果我去的话应该被覆盖

00:04:57.509 --> 00:05:05.639
回到我的分裂演说者方法

00:05:01.620 --> 00:05:18.210
流支持嘿对不起我

00:05:05.639 --> 00:05:21.120
这个主持人模式的麻烦，如果

00:05:18.210 --> 00:05:24.240
我如果回到这个分离器

00:05:21.120 --> 00:05:27.270
这里的作家对象，看看它做什么

00:05:24.240 --> 00:05:29.520
这确实是

00:05:27.270 --> 00:05:32.789
从收集框架，但那

00:05:29.520 --> 00:05:34.710
在几乎所有课程中都被覆盖

00:05:32.789 --> 00:05:38.580
收集框架的是

00:05:34.710 --> 00:05:40.740
此拆分演说者方法的重写

00:05:38.580 --> 00:05:43.979
从ArrayList类，例如

00:05:40.740 --> 00:05:46.110
返回的ASP文献是

00:05:43.979 --> 00:05:48.599
已经对此特有的

00:05:46.110 --> 00:05:50.669
主题，实际上这是什么

00:05:48.599 --> 00:05:53.550
预处理对象的作用相同

00:05:50.669 --> 00:05:55.979
就像迭代器所做的那样

00:05:53.550 --> 00:05:57.990
您知道的集合实现

00:05:55.979 --> 00:06:00.720
我们有一个发布和一个迭代器

00:05:57.990 --> 00:06:03.479
对于我们的列表，对于我们的集合和

00:06:00.720 --> 00:06:05.190
设置流API的迭代器

00:06:03.479 --> 00:06:07.530
作品有点一样，我们有

00:06:05.190 --> 00:06:09.300
在所有复杂的地方执行

00:06:07.530 --> 00:06:12.990
是，我们不想调查

00:06:09.300 --> 00:06:15.389
和实际上持有

00:06:12.990 --> 00:06:17.729
逻辑访问数据，这很少

00:06:15.389 --> 00:06:19.830
评价者对象稍微复杂一点

00:06:17.729 --> 00:06:22.530
比迭代器对象，但它仍然

00:06:19.830 --> 00:06:25.229
也很容易实现自己

00:06:22.530 --> 00:06:27.840
将您的流连接到特定

00:06:25.229 --> 00:06:29.940
提供非标准数据来源

00:06:27.840 --> 00:06:33.659
可能在您的应用程序中

00:06:29.940 --> 00:06:36.120
一次创建其他流的流

00:06:33.659 --> 00:06:37.110
我们已经看到我们可以开始比赛了

00:06:36.120 --> 00:06:42.930
与

00:06:37.110 --> 00:06:47.800
例如好吧，我要带我

00:06:42.930 --> 00:06:51.970
需要采取此代码采取迭代器

00:06:47.800 --> 00:06:56.229
的主题将此迭代器放在

00:06:51.970 --> 00:06:59.910
变量，然后调用创建另一个

00:06:56.229 --> 00:07:05.560
通过调用此流支持

00:06:59.910 --> 00:07:08.319
点流迭代器并传递false 

00:07:05.560 --> 00:07:10.240
第二个参数是一个布尔值

00:07:08.319 --> 00:07:12.160
如果您想要此字符串，则布尔值为true 

00:07:10.240 --> 00:07:14.169
平行，如果不这样做则为假

00:07:12.160 --> 00:07:16.449
希望这个梦想成为他的一部分，我不是

00:07:14.169 --> 00:07:19.780
想到这种事情

00:07:16.449 --> 00:07:23.620
我只是将其保留为

00:07:19.780 --> 00:07:30.150
假或假值，所以这是一个流

00:07:23.620 --> 00:07:33.210
字符串为什么不满意

00:07:30.150 --> 00:07:38.080
从那我只想抓住那个

00:07:33.210 --> 00:07:48.750
我真的在这里有什么问题

00:07:38.080 --> 00:07:52.150
看不到，谢谢

00:07:48.750 --> 00:07:53.800
这是一个分割器返回而不是

00:07:52.150 --> 00:08:02.199
迭代器，我要称呼它

00:07:53.800 --> 00:08:04.659
分配器Reiter Reiter好的

00:08:02.199 --> 00:08:07.330
让我们运行这段代码，实际上它可以运行

00:08:04.659 --> 00:08:11.440
与上一个完全相同

00:08:07.330 --> 00:08:13.719
一个还可以，我们如何创建另一个

00:08:11.440 --> 00:08:16.509
从此开始的分流评估者

00:08:13.719 --> 00:08:19.630
在该流上创建的小Reiter让

00:08:16.509 --> 00:08:21.969
我们要做的是，我将首先创建一个

00:08:19.630 --> 00:08:23.770
实际上非常简单的分离器ATAR 

00:08:21.969 --> 00:08:25.630
什么也没做，应该很好

00:08:23.770 --> 00:08:28.479
只是为了访问我们的界面

00:08:25.630 --> 00:08:31.120
需要实现并查看方法

00:08:28.479 --> 00:08:33.339
我们需要执行工作，所以我要去

00:08:31.120 --> 00:08:38.469
创建一个没有操作的分割器

00:08:33.339 --> 00:08:42.039
字符串无操作拆分器的ATAR 

00:08:38.469 --> 00:08:45.649
 Ater让我们快速快速地创建此类

00:08:42.039 --> 00:08:52.339
我想在那个包中创建它

00:08:45.649 --> 00:08:57.209
伟大的它实现了茶演讲家

00:08:52.339 --> 00:08:59.070
对，我们在这里拥有什么

00:08:57.209 --> 00:09:01.170
事实是方法的集合

00:08:59.070 --> 00:09:03.990
实现它们是抽象方法

00:09:01.170 --> 00:09:06.120
是针对他们和其他方法的

00:09:03.990 --> 00:09:08.940
是我们不需要的默认方法

00:09:06.120 --> 00:09:10.949
第一步实施好

00:09:08.940 --> 00:09:13.290
我们将更精确地调查

00:09:10.949 --> 00:09:16.589
因为那里有一个陷阱

00:09:13.290 --> 00:09:20.009
好的，这是我们的基本

00:09:16.589 --> 00:09:21.930
实现我只是要做一个

00:09:20.009 --> 00:09:24.420
再往前走一点

00:09:21.930 --> 00:09:27.870
因为这个旋钮让彼得·雷特（Peter Reiter） 

00:09:24.420 --> 00:09:28.290
事实将在拆分器上创建

00:09:27.870 --> 00:09:31.110
瑞特

00:09:28.290 --> 00:09:34.680
底层的流，所以我要

00:09:31.110 --> 00:09:37.860
创建这个构造函数很棒，这是一个

00:09:34.680 --> 00:09:41.970
确实是T的分离器根，我想

00:09:37.860 --> 00:09:45.269
创建那个领域，这个想法是

00:09:41.970 --> 00:09:48.180
真的很棒，我的意思是对的

00:09:45.269 --> 00:09:50.760
所以现在我有了这个无操作分配器

00:09:48.180 --> 00:09:52.860
在另一个分割器上创建的草皮

00:09:50.760 --> 00:09:56.220
粪便本身在传入时创建

00:09:52.860 --> 00:09:59.459
流或上游的权利，我该怎么办

00:09:56.220 --> 00:10:01.800
必须实施，我有四个

00:09:59.459 --> 00:10:03.630
我需要实现的抽象方法

00:10:01.800 --> 00:10:06.720
当然，如果我不这样做，它将

00:10:03.630 --> 00:10:09.360
不起作用尝试高级尝试拆分估计

00:10:06.720 --> 00:10:11.870
大小和特征，现在您可以

00:10:09.360 --> 00:10:16.199
认为那些方法有

00:10:11.870 --> 00:10:18.240
尝试拆分时使用奇怪的名称-估算

00:10:16.199 --> 00:10:19.860
大小和集合我有一个大小方法

00:10:18.240 --> 00:10:22.680
但我没有估计的大小

00:10:19.860 --> 00:10:24.360
方法，这实际上是很正常的

00:10:22.680 --> 00:10:27.569
它来自于

00:10:24.360 --> 00:10:29.939
在以下位置创建流时，流会起作用

00:10:27.569 --> 00:10:32.130
你不应该做的对象的来源

00:10:29.939 --> 00:10:34.170
不一定知道你有多少个对象

00:10:32.130 --> 00:10:36.149
将要处理

00:10:34.170 --> 00:10:37.920
流你不知道什么时候

00:10:36.149 --> 00:10:40.439
您在数组列表上创建一个集合

00:10:37.920 --> 00:10:41.819
例如，您知道的一组对象

00:10:40.439 --> 00:10:43.829
您到底有多少个物件

00:10:41.819 --> 00:10:45.779
这个ArrayList，但事实并非如此

00:10:43.829 --> 00:10:48.660
如果您创建一个第一流的我们

00:10:45.779 --> 00:10:50.040
在ArrayList上流式传输好吧，你知道

00:10:48.660 --> 00:10:52.410
您将要对象的数量

00:10:50.040 --> 00:10:54.389
消费，但如果您为创建流

00:10:52.410 --> 00:10:56.240
文本文件上的实例， 

00:10:54.389 --> 00:10:59.250
该方法在bufferedreader类上

00:10:56.240 --> 00:11:01.350
这就是所谓的线

00:10:59.250 --> 00:11:03.600
此方法在

00:11:01.350 --> 00:11:06.120
即使您知道此文本文件的行

00:11:03.600 --> 00:11:07.590
有两兆字节的内容

00:11:06.120 --> 00:11:09.690
在此文本文件中，您不知道

00:11:07.590 --> 00:11:12.120
前进其中的行数

00:11:09.690 --> 00:11:14.400
可能有一条线或一百万条线

00:11:12.120 --> 00:11:16.380
或十行您需要分析

00:11:14.400 --> 00:11:19.170
文本文件，所以它实际上是一个

00:11:16.380 --> 00:11:21.450
方法估算站点

00:11:19.170 --> 00:11:23.910
估算河流两岸

00:11:21.450 --> 00:11:26.160
在某些情况下，这种估计可能是

00:11:23.910 --> 00:11:29.370
在其他情况下可能是准确的

00:11:26.160 --> 00:11:32.850
目前我还不准确

00:11:29.370 --> 00:11:36.060
要做的就是将这种方法

00:11:32.850 --> 00:11:38.340
基础的分流曝气器

00:11:36.060 --> 00:11:40.740
估计大小将返回相同

00:11:38.340 --> 00:11:44.310
结果作为估计的大小

00:11:40.740 --> 00:11:47.100
我在此三级上创建的分割器评分器

00:11:44.310 --> 00:11:49.680
如果我想的话，将调用split方法

00:11:47.100 --> 00:11:53.190
并行并行意味着我需要

00:11:49.680 --> 00:11:55.980
将我的信息流分为两部分， 

00:11:53.190 --> 00:11:58.020
第一部分到给定的Cove我的CPU 

00:11:55.980 --> 00:12:00.720
第二部分到另一个核心我的CPU 

00:11:58.020 --> 00:12:03.090
如果我不并行处理东西

00:12:00.720 --> 00:12:05.370
想去平行我们战斗我确定我

00:12:03.090 --> 00:12:08.600
不会并行我可以返回nil 

00:12:05.370 --> 00:12:08.600
用这个尝试拆分方法

00:12:08.930 --> 00:12:13.770
我现在的特征

00:12:10.950 --> 00:12:15.690
在此方法中我们不详细介绍

00:12:13.770 --> 00:12:17.880
我暂时要一分钟

00:12:15.690 --> 00:12:19.920
只会继续返回

00:12:17.880 --> 00:12:22.890
底层流的特征

00:12:19.920 --> 00:12:27.450
现在有这个试运行方法

00:12:22.890 --> 00:12:29.730
这真的是我需要写我的地方

00:12:27.450 --> 00:12:31.410
代码，如果我想做一些琐碎的事情

00:12:29.730 --> 00:12:34.350
东西以后让我们这样说

00:12:31.410 --> 00:12:37.530
这种尝试高级方法可以看作是

00:12:34.350 --> 00:12:39.630
等价于下一个方法

00:12:37.530 --> 00:12:42.710
迭代器对象，但可以工作

00:12:39.630 --> 00:12:45.720
不同的是，它首先返回一个布尔值

00:12:42.710 --> 00:12:50.160
对，这个布尔值可以是

00:12:45.720 --> 00:12:52.860
真假十亿

00:12:50.160 --> 00:12:55.350
假意味着我没有任何

00:12:52.860 --> 00:12:57.900
分离器可生产更多物体

00:12:55.350 --> 00:13:01.710
评估者，如果返回true，则表示

00:12:57.900 --> 00:13:03.480
我应该执行

00:13:01.710 --> 00:13:06.930
继续调用此权利随机数方法

00:13:03.480 --> 00:13:09.690
因为更多的物体都可以了

00:13:06.930 --> 00:13:12.440
现在它也将消费者作为

00:13:09.690 --> 00:13:14.300
参数动作

00:13:12.440 --> 00:13:16.340
我们需要了解这种尝试

00:13:14.300 --> 00:13:19.460
入口方法将被调用

00:13:16.340 --> 00:13:21.440
提供的参考管道对象

00:13:19.460 --> 00:13:22.850
分配器评级器被提供给

00:13:21.440 --> 00:13:25.280
对象，因此它将被调用

00:13:22.850 --> 00:13:27.620
实施和实施

00:13:25.280 --> 00:13:30.560
将检查是否还有更多对象

00:13:27.620 --> 00:13:32.300
被消耗，如果他们被我们期待

00:13:30.560 --> 00:13:34.520
这些对象会在某个时候出现，但是

00:13:32.300 --> 00:13:36.890
不一定在此刻

00:13:34.520 --> 00:13:39.140
销毁的方法称为我们

00:13:36.890 --> 00:13:42.170
以后再看例子

00:13:39.140 --> 00:13:44.480
所以这个消费者是由这个提供的

00:13:42.170 --> 00:13:46.670
引用管道对象，我应该

00:13:44.480 --> 00:13:50.180
调用此使用者的accept方法

00:13:46.670 --> 00:13:53.810
我要消耗的物体还可以

00:13:50.180 --> 00:13:57.140
所以我在分离器评分器上表现不错

00:13:53.810 --> 00:13:59.330
在其他拆分器评分器上创建，因此如果

00:13:57.140 --> 00:14:02.660
我想知道什么东西要去

00:13:59.330 --> 00:14:05.900
流II消耗掉意味着我需要

00:14:02.660 --> 00:14:07.190
调用基础拆分器评估器

00:14:05.900 --> 00:14:10.820
其实也叫

00:14:07.190 --> 00:14:14.150
这个分离器评分器点尝试一次

00:14:10.820 --> 00:14:17.750
方法，并做的是提供一个

00:14:14.150 --> 00:14:19.550
这项交易的消费者想要获得

00:14:17.750 --> 00:14:23.660
底层产生的对象

00:14:19.550 --> 00:14:26.810
分配器评分器，让我们提供

00:14:23.660 --> 00:14:30.740
消费者，这是消费者不做的

00:14:26.810 --> 00:14:33.590
这个消费者将被

00:14:30.740 --> 00:14:36.470
基本的拆分器评分器我是

00:14:33.590 --> 00:14:40.340
在此对象上构建和创建

00:14:36.470 --> 00:14:42.410
这将必须传递给

00:14:40.340 --> 00:14:44.540
到参考管道的

00:14:42.410 --> 00:14:48.530
打电话给我，所以我需要做的就是

00:14:44.540 --> 00:14:51.590
在这里呼叫除T以外的动作点

00:14:48.530 --> 00:14:53.810
我什么都没打电话

00:14:51.590 --> 00:14:56.690
底层拆分器嘿，你呢

00:14:53.810 --> 00:14:59.690
有东西给我，如果是这样，只需致电

00:14:56.690 --> 00:15:01.250
消费者我给你，如果我

00:14:59.690 --> 00:15:04.790
消费者被称为然后我

00:15:01.250 --> 00:15:07.430
反对并致电给定的其他消费者

00:15:04.790 --> 00:15:09.470
对我来说就是那个

00:15:07.430 --> 00:15:11.930
从一个物体传输物体的方式

00:15:09.470 --> 00:15:15.260
通过调用将分割器评级器流化

00:15:11.930 --> 00:15:19.030
这个消费者现在这个想要

00:15:15.260 --> 00:15:23.270
方法方法将要返回一个品牌

00:15:19.030 --> 00:15:24.980
我将其称为购物中心

00:15:23.270 --> 00:15:25.880
如果它们更多，则布尔值将为真

00:15:24.980 --> 00:15:28.490
消费对象

00:15:25.880 --> 00:15:30.649
如果不是，则为false，因为

00:15:28.490 --> 00:15:34.639
这个文学我什么也没做

00:15:30.649 --> 00:15:37.089
可以将其作为更多对象返回

00:15:34.639 --> 00:15:42.170
完成要完成的过程

00:15:37.089 --> 00:15:45.410
现在如果我检查我的呼叫代码

00:15:42.170 --> 00:15:49.100
分离器Reiter我可以提供

00:15:45.410 --> 00:15:51.529
在这里，这个流现在在我的

00:15:49.100 --> 00:15:53.269
操作拆分器作者，我应该

00:15:51.529 --> 00:15:55.759
没有观察到任何差异

00:15:53.269 --> 00:15:59.269
因为我没有闭塞者没有做

00:15:55.759 --> 00:16:03.529
任何事情，让我们运行这段代码， 

00:15:59.269 --> 00:16:05.870
实际上，我的行为与

00:16:03.529 --> 00:16:09.199
以前较小的运算分配器不是

00:16:05.870 --> 00:16:11.029
做任何事情，但是我可以去

00:16:09.199 --> 00:16:13.730
通过创建例如

00:16:11.029 --> 00:16:16.430
将要阻塞的分配器评分器

00:16:13.730 --> 00:16:20.470
一些对象没有传输全部

00:16:16.430 --> 00:16:22.990
他们假设我们在

00:16:20.470 --> 00:16:27.110
分配器评分器

00:16:22.990 --> 00:16:30.470
现在，让我们收集过滤条件

00:16:27.110 --> 00:16:35.529
分割器评分器，我要创建它

00:16:30.470 --> 00:16:41.089
就像这个包中的上一个一样

00:16:35.529 --> 00:16:45.410
我将实施

00:16:41.089 --> 00:16:50.029
 T，基本上我只会

00:16:45.410 --> 00:16:52.160
与无操作拆分器相同的代码

00:16:50.029 --> 00:16:56.470
评价者，所以我要复制粘贴

00:16:52.160 --> 00:17:02.269
所有这些是的，这是一个消费者可以

00:16:56.470 --> 00:17:08.839
我要顺便也复制这个

00:17:02.269 --> 00:17:11.030
构造函数这是构造函数

00:17:08.839 --> 00:17:13.039
的过滤分离器评分器，我是

00:17:11.030 --> 00:17:16.640
也将通过predicate作为

00:17:13.039 --> 00:17:20.990
 T的参数predicate，我要去

00:17:16.640 --> 00:17:23.240
调用过滤器并执行此操作

00:17:20.990 --> 00:17:30.900
过滤

00:17:23.240 --> 00:17:34.110
等于过滤器过滤器创建字段

00:17:30.900 --> 00:17:36.990
就像那样，现在在我的尝试中

00:17:34.110 --> 00:17:40.290
我想做的高级方法是说

00:17:36.990 --> 00:17:43.260
好吧，我看到有物体从我的身上冒出来

00:17:40.290 --> 00:17:45.390
底层分配器评分器，只要我

00:17:43.260 --> 00:17:47.400
可以看到我将继续返回的对象

00:17:45.390 --> 00:17:50.430
正确，因为这意味着我可以生产

00:17:47.400 --> 00:17:52.800
更多的对象，但我不想

00:17:50.430 --> 00:17:54.420
传输不通过的对象

00:17:52.800 --> 00:18:02.250
这个过滤器在这里

00:17:54.420 --> 00:18:05.040
所以如果过滤器T的检验为真，则

00:18:02.250 --> 00:18:09.450
如果它是假的，我将传输该对象

00:18:05.040 --> 00:18:11.210
我不传送物件吧

00:18:09.450 --> 00:18:15.050
我们看看它做什么

00:18:11.210 --> 00:18:20.430
所以这个过滤分离器评分器是

00:18:15.050 --> 00:18:23.160
婴儿床已创建，让我们来看看

00:18:20.430 --> 00:18:24.570
知道操作分离器评估器，它需要一个

00:18:23.160 --> 00:18:28.620
字符串predicate

00:18:24.570 --> 00:18:37.980
让我们只选择带有

00:18:28.620 --> 00:18:40.410
长度3并运行代码，所以我需要

00:18:37.980 --> 00:18:42.890
在这里创建通过我的流

00:18:40.410 --> 00:18:45.930
彼得·阿特（Peter ater） 

00:18:42.890 --> 00:18:48.780
而且您看到这次只有

00:18:45.930 --> 00:18:50.970
具有3个字符的对象已

00:18:48.780 --> 00:18:52.950
传递给做

00:18:50.970 --> 00:18:57.000
我们在过滤上创建的下游

00:18:52.950 --> 00:18:58.920
分配器评分器，以便您看到如果我

00:18:57.000 --> 00:19:02.040
给你看这个例子只是为了展示

00:18:58.920 --> 00:19:04.650
你不是因为我回来了

00:19:02.040 --> 00:19:07.650
是的，我需要传送一个物体

00:19:04.650 --> 00:19:10.860
到下游去做

00:19:07.650 --> 00:19:12.900
如果我，下游分流器就对了

00:19:10.860 --> 00:19:15.600
返回true，这意味着我有

00:19:12.900 --> 00:19:18.360
有更多对象要发送，但现在可能不发送

00:19:15.600 --> 00:19:20.460
也许以后，如果您检查

00:19:18.360 --> 00:19:22.770
流API至少有两个

00:19:20.460 --> 00:19:25.020
像第一个那样的例子

00:19:22.770 --> 00:19:28.080
最明显的一种是排序

00:19:25.020 --> 00:19:30.540
排序一组对象的示例

00:19:28.080 --> 00:19:33.990
需要看到他们所有你不能开始

00:19:30.540 --> 00:19:35.789
产生物体直到你看到

00:19:33.990 --> 00:19:38.399
所有由此产生的物体

00:19:35.789 --> 00:19:40.049
梦想，所以这种接受方法将保持

00:19:38.399 --> 00:19:40.889
回答真实而不产生

00:19:40.049 --> 00:19:43.409
任何东西

00:19:40.889 --> 00:19:45.299
一旦上行流是

00:19:43.409 --> 00:19:47.279
完全消耗掉然后分类

00:19:45.299 --> 00:19:49.859
将发生，然后产生

00:19:47.279 --> 00:19:52.529
对象的传输将是

00:19:49.859 --> 00:19:55.139
完成，第二个例子

00:19:52.529 --> 00:19:58.249
这些东西也很明显

00:19:55.139 --> 00:19:59.429
与心理指数，如果一个对象

00:19:58.249 --> 00:20:01.470
树脂

00:19:59.429 --> 00:20:03.720
我们是否已经看过该主题，如果

00:20:01.470 --> 00:20:06.119
不，那么我会传输它

00:20:03.720 --> 00:20:09.299
解锁它是一种自适应

00:20:06.119 --> 00:20:11.369
在这种情况下像您一样进行过滤

00:20:09.299 --> 00:20:14.789
事实上，这是一种非常经典的方式

00:20:11.369 --> 00:20:19.879
使用此分离器Reiter Reiter Reiter 

00:20:14.789 --> 00:20:24.179
东西ASP文献也可以用来

00:20:19.879 --> 00:20:34.229
修改传输的对象让我们

00:20:24.179 --> 00:20:39.239
创建映射拆分器评分器映射

00:20:34.229 --> 00:20:42.359
分割一点我要保留的字符串

00:20:39.239 --> 00:20:45.239
很简单，所以我要创建

00:20:42.359 --> 00:20:51.570
在拆分器中再次上课

00:20:45.239 --> 00:20:59.869
包我要复制所有内容

00:20:51.570 --> 00:21:03.960
实际上这不是这个

00:20:59.869 --> 00:21:06.599
很棒，所以这是一个映射翻转迭代器

00:21:03.960 --> 00:21:08.940
实际上，第二个要素不是

00:21:06.599 --> 00:21:11.580
将会是一个predicate，但假设

00:21:08.940 --> 00:21:17.879
一元运算符，我将其称为

00:21:11.580 --> 00:21:20.389
映射器，此映射器将是一个映射器

00:21:17.879 --> 00:21:26.720
所以我需要再改变一次

00:21:20.389 --> 00:21:31.919
现在我要做的实际上是

00:21:26.720 --> 00:21:36.090
实际上是使用

00:21:31.919 --> 00:21:39.239
这个映射器，这是我使用这些地图

00:21:36.090 --> 00:21:44.789
映射器，我要打电话给映射器

00:21:39.239 --> 00:21:46.529
我正在更改的T的点适用

00:21:44.789 --> 00:21:48.720
我没有改变主题的性质

00:21:46.529 --> 00:21:49.200
类型，但我可以将类型更改为

00:21:48.720 --> 00:21:51.660
好

00:21:49.200 --> 00:21:54.900
并发送此并发送此

00:21:51.660 --> 00:22:00.390
将对象转化为对我的转化为对我的转化

00:21:54.900 --> 00:22:03.150
下游，让我们继续努力

00:22:00.390 --> 00:22:06.470
例子我要过滤

00:22:03.150 --> 00:22:11.700
分割器评分器传递实例字符串

00:22:06.470 --> 00:22:14.520
像这样大写

00:22:11.700 --> 00:22:15.210
映射分配器评分器，然后在此

00:22:14.520 --> 00:22:17.940
小评分者

00:22:15.210 --> 00:22:21.480
我创建了一个流，看看它能给什么

00:22:17.940 --> 00:22:24.260
您会看到过滤和

00:22:21.480 --> 00:22:26.970
已经应用了映射

00:22:24.260 --> 00:22:31.500
我刚刚更换了不同的分配器

00:22:26.970 --> 00:22:34.260
老连锁店的评价员还可以，但是我

00:22:31.500 --> 00:22:35.790
也可以这样做，所以无论我在这里

00:22:34.260 --> 00:22:38.640
我已经挡住了我拥有的物体

00:22:35.790 --> 00:22:41.640
转换对象，但我也可以创建

00:22:38.640 --> 00:22:44.190
下游分配器中有更多物体

00:22:41.640 --> 00:22:48.410
比我上游上游的要差

00:22:44.190 --> 00:22:53.720
评分者让我们创建第四个想要的

00:22:48.410 --> 00:23:01.680
重复分配器评分器

00:22:53.720 --> 00:23:05.420
流重复拆分器返回让

00:23:01.680 --> 00:23:05.420
我们让我们创建这个类

00:23:08.870 --> 00:23:21.210
这里将复制此代码粘贴到

00:23:17.580 --> 00:23:23.520
使事情更快我实现了拆分器

00:23:21.210 --> 00:23:28.620
评价者，这是​​一个重复的分割器

00:23:23.520 --> 00:23:33.590
评分者，例如，我可以通过

00:23:28.620 --> 00:23:40.010
整数作为此重复操作的参数

00:23:33.590 --> 00:23:44.190
等于重复是的，请创建该字段

00:23:40.010 --> 00:23:47.550
谢谢，然后每次我得到一个

00:23:44.190 --> 00:23:49.230
反对我想做的是重复

00:23:47.550 --> 00:23:51.600
反对我没有的时间

00:23:49.230 --> 00:23:54.330
通过它，所以如果重复等于三

00:23:51.600 --> 00:23:57.240
例如我想重复对象

00:23:54.330 --> 00:23:57.660
传入对象三遍，所以我可以做

00:23:57.240 --> 00:24:01.620
那

00:23:57.660 --> 00:24:08.570
我猜在流点范围内

00:24:01.620 --> 00:24:16.050
从零到n，所以您重复然后

00:24:08.570 --> 00:24:16.850
对于每个索引实际上接受

00:24:16.050 --> 00:24:21.630
应该做到的

00:24:16.850 --> 00:24:25.290
好吧，如果我回到这些东西，是的，我

00:24:21.630 --> 00:24:27.390
需要实例化它新的重复

00:24:25.290 --> 00:24:33.540
稍后在过滤分离器上分离

00:24:27.390 --> 00:24:37.590
以两倍的回报创建

00:24:33.540 --> 00:24:38.660
流上运行代码，您会看到

00:24:37.590 --> 00:24:41.429
这次喔

00:24:38.660 --> 00:24:42.960
我是怎么了哦，是的，我没有

00:24:41.429 --> 00:24:47.640
映射拆分器

00:24:42.960 --> 00:24:50.070
映射分配器以后可以，所以在这里

00:24:47.640 --> 00:24:55.429
看到每个元素都被重复

00:24:50.070 --> 00:24:55.429
两次，所以你真的问一个问题

00:25:02.340 --> 00:25:04.940
是的

00:25:07.420 --> 00:25:10.800
你的意思是提前尝试

00:25:14.010 --> 00:25:19.499
是的

00:25:16.390 --> 00:25:19.499
 [音乐] 

00:25:19.700 --> 00:25:26.070
是的，这没关系，这是

00:25:23.400 --> 00:25:27.180
不是医生不赞成的

00:25:26.070 --> 00:25:30.080
对此表示不同意

00:25:27.180 --> 00:25:30.080
为什么不

00:25:54.160 --> 00:26:05.890
所以是的，你只可以打电话给

00:25:56.470 --> 00:26:21.100
消费者一旦我保证，这是一个

00:26:05.890 --> 00:26:23.200
我真的要讨论更多

00:26:21.100 --> 00:26:25.540
想知道您如何对方法进行排序

00:26:23.200 --> 00:26:35.950
如果你不允许这种事情

00:26:25.540 --> 00:26:38.380
因此，如果您不允许这样做， 

00:26:35.950 --> 00:26:46.410
您更改了10中的行为

00:26:38.380 --> 00:26:49.860
 21 10 10.3很好，它正常工作

00:26:46.410 --> 00:26:49.860
很好

00:26:56.070 --> 00:27:02.469
是的，我们没有在那里清楚地供电

00:26:59.039 --> 00:27:04.209
显然我还有一点

00:27:02.469 --> 00:27:06.999
喜欢在这个分裂的演说家那里提出来

00:27:04.209 --> 00:27:09.549
在这里估算尺寸，因为显然我是

00:27:06.999 --> 00:27:12.820
乘以这个的大小

00:27:09.549 --> 00:27:15.279
捕食者的重复因子是

00:27:12.820 --> 00:27:18.639
一个人，估计大小可能是

00:27:15.279 --> 00:27:23.379
在某些情况下将最大值设置为最大值

00:27:18.639 --> 00:27:23.799
我只是返回这个分割器的重复时间

00:27:23.379 --> 00:27:26.259
阿塔

00:27:23.799 --> 00:27:28.869
在此重复此拆分器Reiter的时间

00:27:26.259 --> 00:27:31.359
估计这里的大小我会麻烦吗

00:27:28.869 --> 00:27:36.759
因为这很久可能会变成负面

00:27:31.359 --> 00:27:39.489
如果这个估算值本身来自我

00:27:36.759 --> 00:27:41.499
长点最大值，所以我不会

00:27:39.489 --> 00:27:44.709
写这个，我要保留它，这是

00:27:41.499 --> 00:27:52.059
无论如何只是一个估计，所以我只是

00:27:44.709 --> 00:27:54.879
我要告诉我

00:27:52.059 --> 00:27:58.049
几分钟前你就是

00:27:54.879 --> 00:28:02.079
对不起，实施这四个

00:27:58.049 --> 00:28:04.569
方法足以实施

00:28:02.079 --> 00:28:08.139
分配器评分器实际上并不完全

00:28:04.569 --> 00:28:13.679
该案例假设此分配器评分器

00:28:08.139 --> 00:28:18.489
这里变成正确的可以做到这一点

00:28:13.679 --> 00:28:20.859
运行此代码，在这里我会得到它

00:28:18.489 --> 00:28:23.169
来自的非法国家例外

00:28:20.859 --> 00:28:25.539
分离器的门比较器方法

00:28:23.169 --> 00:28:27.609
 Reiter界面以及是否检查

00:28:25.539 --> 00:28:30.009
确实是

00:28:27.609 --> 00:28:33.609
 splitter Reiter接口抛出此错误

00:28:30.009 --> 00:28:35.469
非法国家例外现在这扇门

00:28:33.609 --> 00:28:37.929
比较方法由

00:28:35.469 --> 00:28:42.729
引用管道对象仅在

00:28:37.929 --> 00:28:45.129
排序流的情况下，我可以

00:28:42.729 --> 00:28:48.159
我可以在这里做两件事

00:28:45.129 --> 00:28:51.329
无论我是否对此流进行排序

00:28:48.159 --> 00:28:54.579
提供该流的比较器

00:28:51.329 --> 00:28:56.319
请注意，在这里我对我的信息流进行了排序

00:28:54.579 --> 00:28:59.349
明确地但我想有一个方法

00:28:56.319 --> 00:29:01.149
需要进行任何更正的集合

00:28:59.349 --> 00:29:03.700
我把这个修正称为流

00:29:01.149 --> 00:29:07.570
更正也可能是为了

00:29:03.700 --> 00:29:17.850
重置实例让我们做到这一点

00:29:07.570 --> 00:29:17.850
快速重置在此创建的字符串

00:29:19.230 --> 00:29:32.800
对不起，这个释放的字符串他们通过

00:29:29.440 --> 00:29:35.440
此重置，这里和现在，因为此重置

00:29:32.800 --> 00:29:37.540
实际上是一个有序集

00:29:35.440 --> 00:29:40.180
产生的内容会自动分类

00:29:37.540 --> 00:29:43.510
我有完全一样的鸟伊利甘

00:29:40.180 --> 00:29:46.420
声明异常权，在这里我该怎么办

00:29:43.510 --> 00:29:49.690
我要去了解我的分流器吗

00:29:46.420 --> 00:29:52.150
在这里，如果基础流

00:29:49.690 --> 00:29:54.760
此节点拆分器本身已排序

00:29:52.150 --> 00:29:57.850
有各种各样的beta是很正常的

00:29:54.760 --> 00:30:01.000
测试版，所以我需要提供一个

00:29:57.850 --> 00:30:03.340
比较器让我覆盖此门

00:30:01.000 --> 00:30:04.500
通过提供此比较器方法

00:30:03.340 --> 00:30:09.070
披萨评分器

00:30:04.500 --> 00:30:10.990
在这里获取比较器方法对象

00:30:09.070 --> 00:30:14.920
实际上，所有人都必须做同样的事情

00:30:10.990 --> 00:30:17.980
我的比较器分配器评分器让我复制

00:30:14.920 --> 00:30:19.210
粘贴此分离器评分器，对不起

00:30:17.980 --> 00:30:21.730
过滤分离器评分器

00:30:19.210 --> 00:30:24.910
很显然不会改变

00:30:21.730 --> 00:30:29.590
流光的盐渍性质，所以我可以

00:30:24.910 --> 00:30:34.990
做同样提供一个比较器

00:30:29.590 --> 00:30:37.140
这里是映射拆分器评估程序，因为它

00:30:34.990 --> 00:30:40.030
可以改变物体的性质

00:30:37.140 --> 00:30:42.640
可能将字符串更改为整数

00:30:40.030 --> 00:30:44.830
或某人的名字

00:30:42.640 --> 00:30:47.500
它很可能会改变盐味

00:30:44.830 --> 00:30:49.900
该流的性质，所以这次要注意

00:30:47.500 --> 00:30:52.330
我要为这个土豆保存的是

00:30:49.900 --> 00:30:55.480
产生的流没有排序

00:30:52.330 --> 00:30:59.230
无论如何，要做到这一点，我需要

00:30:55.480 --> 00:31:02.850
在这里触摸这些特征方法

00:30:59.230 --> 00:31:07.360
实际上，这个特色学科是

00:31:02.850 --> 00:31:10.060
位的字字段，每个位每个位

00:31:07.360 --> 00:31:13.210
这个词的意思是有一个

00:31:10.060 --> 00:31:16.450
那是排序的位，所以如果我想

00:31:13.210 --> 00:31:19.380
说这个特性不是

00:31:16.450 --> 00:31:22.770
排序了，我需要

00:31:19.380 --> 00:31:25.800
在逻辑上设置它

00:31:22.770 --> 00:31:28.950
排序为零，这是正确的

00:31:25.800 --> 00:31:32.930
重复速度的方法

00:31:28.950 --> 00:31:36.870
发电机可能不会改变

00:31:32.930 --> 00:31:40.110
因此改变了这个的性质

00:31:36.870 --> 00:31:44.310
微调，我想就是这样

00:31:40.110 --> 00:31:48.000
现在我已经修复了所有问题，再次运行此代码

00:31:44.310 --> 00:31:50.190
我的信息流不是那么没有排序

00:31:48.000 --> 00:31:52.140
它可以被排序并且可以提供

00:31:50.190 --> 00:31:55.410
比较器，所以现在我没有

00:31:52.140 --> 00:31:57.900
回来了，但我还有另一个

00:31:55.410 --> 00:32:01.200
除了以下事实外，此代码中的错误

00:31:57.900 --> 00:32:06.150
我真的想过两次打电话接受

00:32:01.200 --> 00:32:08.430
我可以是以下哪个

00:32:06.150 --> 00:32:12.450
当我关闭流中的时候

00:32:08.430 --> 00:32:16.770
其实让我在这里我能做什么让我

00:32:12.450 --> 00:32:19.050
暂时评论一下这段代码

00:32:16.770 --> 00:32:24.060
这样我们以后会再讲

00:32:19.050 --> 00:32:26.940
然后在这里产生流，我就是

00:32:24.060 --> 00:32:31.400
只是为了打印出结果

00:32:26.940 --> 00:32:31.400
我想要的那个流系统

00:32:31.670 --> 00:32:36.780
打印机，所以如果我运行此代码，它将

00:32:35.190 --> 00:32:40.830
打印结果，我们都知道

00:32:36.780 --> 00:32:43.410
但我能做的是在

00:32:40.830 --> 00:32:49.010
 close调用时的close方法

00:32:43.410 --> 00:32:55.230
抱歉，让我将此变量放入变量中

00:32:49.010 --> 00:33:03.830
正确的呼叫流在更近处提供

00:32:55.230 --> 00:33:11.460
可运行，例如系统关闭

00:33:03.830 --> 00:33:13.050
好的，更明确地联系，然后致电

00:33:11.460 --> 00:33:16.860
如果我运行，则在该流上关闭方法

00:33:13.050 --> 00:33:18.990
这段代码，我将拥有所有

00:33:16.860 --> 00:33:22.230
此处显示的流媒体内容

00:33:18.990 --> 00:33:24.360
和关闭方法关闭

00:33:22.230 --> 00:33:28.710
此回调之后出现的消息

00:33:24.360 --> 00:33:30.509
如果我保留这个，现在被叫到这里了

00:33:28.710 --> 00:33:33.719
现在在这里回调

00:33:30.509 --> 00:33:50.070
我们摆脱了这段代码，然后继续

00:33:33.719 --> 00:33:51.769
没事，所以我要跌倒了

00:33:50.070 --> 00:33:54.599
回到这里

00:33:51.769 --> 00:34:01.440
科拉流到流下

00:33:54.599 --> 00:34:03.269
如果我将流关闭到此处，我会在那里

00:34:01.440 --> 00:34:05.190
设置了回调吗？ 

00:34:03.269 --> 00:34:07.559
是的，设置回调

00:34:05.190 --> 00:34:10.740
这里不再使用这个树集

00:34:07.559 --> 00:34:13.889
我只是在创建这个掠食者

00:34:10.740 --> 00:34:16.200
此流在这里，并呼吁关闭

00:34:13.889 --> 00:34:19.190
我建立的流的方法

00:34:16.200 --> 00:34:22.139
关于这一点，但如果我运行这段代码

00:34:19.190 --> 00:34:25.169
实际上这段代码的回调

00:34:22.139 --> 00:34:27.059
第一流不再冷，它

00:34:25.169 --> 00:34:28.649
应该是因为这是一个回调，所有

00:34:27.059 --> 00:34:30.869
流应该调用

00:34:28.649 --> 00:34:33.929
自己关闭方法，所以每次我

00:34:30.869 --> 00:34:36.299
正在创建一个像这样的流

00:34:33.929 --> 00:34:43.079
我应该怎么做

00:34:36.299 --> 00:34:49.259
真的是一个叫关闭的流

00:34:43.079 --> 00:34:52.470
并调用流的close方法

00:34:49.259 --> 00:34:55.230
我的拆分器另一条流

00:34:52.470 --> 00:34:57.690
在此拆分器上创建的Reiter是

00:34:55.230 --> 00:34:59.400
在流上创建，然后所有其他

00:34:57.690 --> 00:35:02.430
分配器评分者在此创建

00:34:59.400 --> 00:35:06.539
对，所以这是我需要的信息流

00:35:02.430 --> 00:35:09.240
到回调已定义

00:35:06.539 --> 00:35:10.890
在这个梦想家并关闭那条小溪

00:35:09.240 --> 00:35:12.990
在另一个上创建的还应该

00:35:10.890 --> 00:35:18.150
调用这个的回调，所以现在如果

00:35:12.990 --> 00:35:21.230
我运行我的代码我有关闭方法

00:35:18.150 --> 00:35:24.539
正确地称呼它，事实上，当

00:35:21.230 --> 00:35:26.759
实施分离机

00:35:24.539 --> 00:35:29.400
实施的技术部分

00:35:26.759 --> 00:35:32.519
好的抽象方法，我们看到了

00:35:29.400 --> 00:35:35.190
但我还需要确保

00:35:32.519 --> 00:35:37.829
 close方法应为on close方法

00:35:35.190 --> 00:35:40.230
那么关闭回调是正确的

00:35:37.829 --> 00:35:42.839
在关闭新流时调用

00:35:40.230 --> 00:35:44.450
在分离机上创建，我也

00:35:42.839 --> 00:35:47.119
需要确保

00:35:44.450 --> 00:35:50.150
我可能是正确的并链接咸

00:35:47.119 --> 00:35:53.420
可能上升的咸流

00:35:50.150 --> 00:35:56.119
如果我不处理它们，则为例外

00:35:53.420 --> 00:36:00.619
正确的，所以这是三个两个

00:35:56.119 --> 00:36:11.540
处理这些流的主要陷阱

00:36:00.619 --> 00:36:14.329
其实是的，是的，有时候你

00:36:11.540 --> 00:36:16.010
可以在我们的资源上打开流

00:36:14.329 --> 00:36:18.710
是针对的bufferedreader的情况

00:36:16.010 --> 00:36:21.410
实例，所以关闭调用关闭

00:36:18.710 --> 00:36:23.900
流上的方法应关闭

00:36:21.410 --> 00:36:27.020
还有你的I / O通过哪些资源

00:36:23.900 --> 00:36:29.240
实际上，您一直在使用的您

00:36:27.020 --> 00:36:31.520
流扩展了自动坩埚，因此您

00:36:29.240 --> 00:36:35.839
可以尝试使用流

00:36:31.520 --> 00:36:37.579
只需调用资源API 

00:36:35.839 --> 00:36:40.160
流在ArrayList上，您不调用

00:36:37.579 --> 00:36:43.640
您自己的关闭方法不会

00:36:40.160 --> 00:36:46.070
非常非常有害，但是如果您使用io 

00:36:43.640 --> 00:36:52.060
资源，那么你绝对应该做

00:36:46.070 --> 00:36:52.060
还有其他问题

00:36:53.900 --> 00:36:58.440
分离器返回是否需要

00:36:56.190 --> 00:37:03.000
线程安全，这实际上取决于是否

00:36:58.440 --> 00:37:05.010
您是否并行使用它，如果

00:37:03.000 --> 00:37:08.190
您正在并行使用它，API将

00:37:05.010 --> 00:37:09.930
叫这个三分裂的方法，你

00:37:08.190 --> 00:37:13.710
应该返回另一个拆分器

00:37:09.930 --> 00:37:17.340
稍后在该流的一部分中

00:37:13.710 --> 00:37:19.170
本身取决于您是否共享

00:37:17.340 --> 00:37:20.730
是否声明但丹尼斯本身

00:37:19.170 --> 00:37:22.260
所有其他不需要的方法

00:37:20.730 --> 00:37:27.240
要同步，不应

00:37:22.260 --> 00:37:30.270
默认情况下同步我

00:37:27.240 --> 00:37:34.140
认为我们有点用光了

00:37:30.270 --> 00:37:36.870
时间，所以我只是添加了几张幻灯片作为

00:37:34.140 --> 00:37:38.850
引用不同的含义

00:37:36.870 --> 00:37:42.470
这种特性的不同之处

00:37:38.850 --> 00:37:45.210
我们刚刚在

00:37:42.470 --> 00:37:48.690
这些东西的实时编码部分

00:37:45.210 --> 00:37:51.960
他们基本上是不言而喻的， 

00:37:48.690 --> 00:37:54.930
也许叹息着你的意思

00:37:51.960 --> 00:37:57.630
稍后在结构上打开拆分器

00:37:54.930 --> 00:37:59.970
知道元素的数量

00:37:57.630 --> 00:38:02.610
将要创建一个数组

00:37:59.970 --> 00:38:04.200
列出实例或设置和子

00:38:02.610 --> 00:38:06.900
调整大小，这是另一个

00:38:04.200 --> 00:38:10.590
也许不平凡意味着，如果你

00:38:06.900 --> 00:38:13.830
分割您的来源

00:38:10.590 --> 00:38:15.960
流光如果你去平行然后

00:38:13.830 --> 00:38:18.720
分裂也会产生元素

00:38:15.960 --> 00:38:20.700
而子流的大小，如果您

00:38:18.720 --> 00:38:23.190
可以将ArrayList分成两部分

00:38:20.700 --> 00:38:25.440
可以计算每个元素的数量

00:38:23.190 --> 00:38:27.990
如果拆分一个数组列表的一部分

00:38:25.440 --> 00:38:30.540
通过削减基础资产

00:38:27.990 --> 00:38:33.450
资产或资产中的数组

00:38:30.540 --> 00:38:35.250
纳什映射到您无法预见

00:38:33.450 --> 00:38:37.440
他们在正确的道路上有很多要素

00:38:35.250 --> 00:38:39.720
在这个数组的左边

00:38:37.440 --> 00:38:44.130
例如我们布景的边是

00:38:39.720 --> 00:38:46.560
错误，而擦除则为真，我

00:38:44.130 --> 00:38:50.370
还给您提示河流责任

00:38:46.560 --> 00:38:54.020
您可以在github上找到的API 

00:38:50.370 --> 00:38:57.030
还有很多更复杂的

00:38:54.020 --> 00:38:59.970
操作比映射过滤没有

00:38:57.030 --> 00:39:02.730
 op，这真的很容易

00:38:59.970 --> 00:39:06.150
就像分组滚动拉链一样

00:39:02.730 --> 00:39:08.160
他们是20或19 

00:39:06.150 --> 00:39:11.640
不同的操作，你有

00:39:08.160 --> 00:39:13.529
也是一个

00:39:11.640 --> 00:39:15.660
在移动窗口上收集

00:39:13.529 --> 00:39:18.240
当您拥有大量商品时非常有用

00:39:15.660 --> 00:39:20.069
元素流，您想

00:39:18.240 --> 00:39:21.630
计算平均值，例如

00:39:20.069 --> 00:39:25.829
平均而言，移动窗口只是

00:39:21.630 --> 00:39:28.319
皮草收藏的特例

00:39:25.829 --> 00:39:30.660
你可以做到，你也可以

00:39:28.319 --> 00:39:33.539
结果我也把高效

00:39:30.660 --> 00:39:36.329
提取a的N个最大值的算法

00:39:33.539 --> 00:39:40.319
给定的流在许多情况下都是有用的

00:39:36.329 --> 00:39:43.260
案例，所以这是到流的链接

00:39:40.319 --> 00:39:47.279
 API结论是，如果您想

00:39:43.260 --> 00:39:50.369
连接您的流算法并继续

00:39:47.279 --> 00:39:52.020
您自己可以做的数据源

00:39:50.369 --> 00:39:54.329
通过摆弄分离器

00:39:52.020 --> 00:39:56.490
费率或API并非易事， 

00:39:54.329 --> 00:39:59.309
有点棘手，但功能非常强大， 

00:39:56.490 --> 00:40:01.520
它将真的允许它真的

00:39:59.309 --> 00:40:04.049
使您可以利用所有强大的功能

00:40:01.520 --> 00:40:06.329
后面的算法

00:40:04.049 --> 00:40:08.700
流API，这实际上是

00:40:06.329 --> 00:40:11.549
很好，我还提供了链接

00:40:08.700 --> 00:40:13.619
我的github帐户，我认为

00:40:11.549 --> 00:40:15.510
我们不感谢您的关注我

00:40:13.619 --> 00:40:17.339
不知道我们还有几分钟

00:40:15.510 --> 00:40:23.390
询问是否有

00:40:17.339 --> 00:40:23.390
是的，请

00:40:31.960 --> 00:40:36.849
我不知道是否真的有任何门槛

00:40:35.109 --> 00:40:44.410
确实取决于您的需求

00:40:36.849 --> 00:40:45.880
这样我就永远不会来

00:40:44.410 --> 00:40:48.880
遇到任何与此有关的问题

00:40:45.880 --> 00:40:51.490
这些东西，我真的不得不

00:40:48.880 --> 00:40:54.070
用不大的数量管理大量数据

00:40:51.490 --> 00:40:56.589
数据端TB级的数据，但在

00:40:54.070 --> 00:40:58.839
存储大量数据，我可以做

00:40:56.589 --> 00:41:02.980
那很容易并行

00:40:58.839 --> 00:41:05.230
总是更加复杂，我不会

00:41:02.980 --> 00:41:07.960
建议您并行使用

00:41:05.230 --> 00:41:11.170
真的确定你在做什么

00:41:07.960 --> 00:41:13.839
留在一个非平行世界

00:41:11.170 --> 00:41:16.180
只要你可以，因为平行

00:41:13.839 --> 00:41:18.730
实际上可能会降低您的表现

00:41:16.180 --> 00:41:22.210
而不是增加他们

00:41:18.730 --> 00:41:24.599
与其他任何东西都非常小心

00:41:22.210 --> 00:41:24.599
问题

00:41:25.230 --> 00:41:28.960
好的，谢谢，我将制作这张幻灯片

00:41:27.609 --> 00:41:31.540
在我的SlideShare帐户上的变量上

00:41:28.960 --> 00:41:32.360
很快，您可以检查一下，我

00:41:31.540 --> 00:41:37.969
将发布有关

00:41:32.360 --> 00:41:37.969
 [掌声] 

