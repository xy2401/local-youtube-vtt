WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.290 --> 00:00:07.160
好吧，让我们开始吧，欢迎来到

00:00:05.660 --> 00:00:08.809
会议上的粉和珍珠

00:00:07.160 --> 00:00:10.940
尖叫声我叫文卡特

00:00:08.809 --> 00:00:12.440
 Subramanyam我们要谈一些

00:00:10.940 --> 00:00:14.420
我们可以做的美丽的事情

00:00:12.440 --> 00:00:15.890
并行流是什么

00:00:14.420 --> 00:00:18.740
我们应该记住的事情

00:00:15.890 --> 00:00:20.600
开始使用并行流和

00:00:18.740 --> 00:00:22.750
这样的事情，让我们开始吧， 

00:00:20.600 --> 00:00:25.640
谈论编程并发

00:00:22.750 --> 00:00:27.650
编程并发是令人难以置信的

00:00:25.640 --> 00:00:29.949
很难做

00:00:27.650 --> 00:00:32.629
我们很多人包括我自己

00:00:29.949 --> 00:00:34.460
开始编程并发，没有

00:00:32.629 --> 00:00:36.109
充分了解Java内存

00:00:34.460 --> 00:00:38.600
模型，事实证明，如果我们不这样做

00:00:36.109 --> 00:00:41.479
了解它所在的Java内存模型

00:00:38.600 --> 00:00:43.879
荒诞的艺术使它成为正确的之一

00:00:41.479 --> 00:00:44.479
可能是有史以来最恐怖的书

00:00:43.879 --> 00:00:47.690
书面

00:00:44.479 --> 00:00:50.870
 Java是Brian的编程并发

00:00:47.690 --> 00:00:53.059
在我读过那本书之前

00:00:50.870 --> 00:00:55.219
以为您无法获得并发

00:00:53.059 --> 00:00:57.379
完全正确，我读完这本书之后

00:00:55.219 --> 00:00:59.569
我完全相信你现在不能

00:00:57.379 --> 00:01:01.819
获得并发正确

00:00:59.569 --> 00:01:04.250
实际上是完全复杂的，因为

00:01:01.819 --> 00:01:06.619
这只是太多事情可以做的一种方式

00:01:04.250 --> 00:01:07.760
事实证明可能出错

00:01:06.619 --> 00:01:10.520
实际上有两个不同

00:01:07.760 --> 00:01:12.980
我们处理并发的方法之一

00:01:10.520 --> 00:01:14.870
它们就是我们所说的鸿沟

00:01:12.980 --> 00:01:16.790
征服问题，所以你有问题

00:01:14.870 --> 00:01:18.410
你把n分为两部分

00:01:16.790 --> 00:01:20.060
然后把这两个小部分

00:01:18.410 --> 00:01:22.070
然后决定是否要

00:01:20.060 --> 00:01:23.630
解决较小的部分或您想要

00:01:22.070 --> 00:01:25.550
进行进一步划分

00:01:23.630 --> 00:01:27.800
您可以继续按顺序进行

00:01:25.550 --> 00:01:29.600
通过这个，其他当然是什么

00:01:27.800 --> 00:01:31.760
我们通常将其称为并行数组，因此

00:01:29.600 --> 00:01:33.110
你有一个数据集合，你

00:01:31.760 --> 00:01:33.860
想要执行那些数据收集

00:01:33.110 --> 00:01:36.500
在平行下

00:01:33.860 --> 00:01:37.940
并行流真的很合适

00:01:36.500 --> 00:01:39.980
进入第二自然

00:01:37.940 --> 00:01:41.720
比第一个合适

00:01:39.980 --> 00:01:43.670
您可以尝试使用并行流来

00:01:41.720 --> 00:01:46.370
确实做到分而治之不是

00:01:43.670 --> 00:01:48.530
那个方便或真正的账单

00:01:46.370 --> 00:01:50.570
轻松做到这一点，这真的是为了

00:01:48.530 --> 00:01:52.040
当您遇到并行竞赛问题时

00:01:50.570 --> 00:01:54.290
您可以轻松收集数据

00:01:52.040 --> 00:01:55.880
将它们投入并行执行

00:01:54.290 --> 00:01:58.490
很好，这就是您真正得到的地方

00:01:55.880 --> 00:02:00.229
为什么要这样并行流

00:01:58.490 --> 00:02:01.760
非常适合你有一个收藏

00:02:00.229 --> 00:02:03.890
数据，您想执行一些

00:02:01.760 --> 00:02:05.420
操作，您想真正加快速度

00:02:03.890 --> 00:02:07.159
完成计算，您想做

00:02:05.420 --> 00:02:08.720
同时让我们看一下

00:02:07.159 --> 00:02:10.280
我们如何才能真正做到这一点

00:02:08.720 --> 00:02:12.109
一个简单的例子，我们将从右边开始

00:02:10.280 --> 00:02:14.450
这里说我们有一个

00:02:12.109 --> 00:02:16.280
在这种情况下，我们只说1 

00:02:14.450 --> 00:02:17.719
通过6分钟，我想

00:02:16.280 --> 00:02:18.920
表现非常微不足道

00:02:17.719 --> 00:02:20.719
变革，我要坚持下去

00:02:18.920 --> 00:02:22.790
非常简单，所以我们不必

00:02:20.719 --> 00:02:24.079
打破你知道一个头试图

00:02:22.790 --> 00:02:25.939
了解代码到底是什么

00:02:24.079 --> 00:02:28.129
在这种情况下，我将简单地

00:02:25.939 --> 00:02:29.749
执行数学运算，我们得到了

00:02:28.129 --> 00:02:32.389
我要简单地称一个

00:02:29.749 --> 00:02:34.279
转换元素，然后

00:02:32.389 --> 00:02:36.499
当然，我要简单地打印

00:02:34.279 --> 00:02:38.209
排除给我们的元素，所以在这

00:02:36.499 --> 00:02:40.519
当然我要打印

00:02:38.209 --> 00:02:42.349
将其列为系统，例如打印

00:02:40.519 --> 00:02:44.359
伊兰，请它打印好我们

00:02:42.349 --> 00:02:45.409
我再次需要变换方法

00:02:44.359 --> 00:02:47.959
要保持转变，但他们是

00:02:45.409 --> 00:02:50.029
非常简单，所以非常明显

00:02:47.959 --> 00:02:51.739
我们在这里实际上正在做什么

00:02:50.029 --> 00:02:53.840
我要说的是转变将要发生

00:02:51.739 --> 00:02:55.609
我们说一个数字及其所有作用

00:02:53.840 --> 00:02:57.829
只是返回给定的数字，所以

00:02:55.609 --> 00:02:59.659
如您所见，这根本不重要

00:02:57.829 --> 00:03:01.519
我们在右边打印了数字1到6 

00:02:59.659 --> 00:03:03.829
在这里，但是当然这是在

00:03:01.519 --> 00:03:05.629
就像我们期望的那样，所以我要

00:03:03.829 --> 00:03:08.029
让我们在这里稍微睡一下

00:03:05.629 --> 00:03:09.859
一秒钟的间隔，当然要睡觉

00:03:08.029 --> 00:03:12.409
只是我要在这里写的一种方法

00:03:09.859 --> 00:03:14.629
这只会给我们

00:03:12.409 --> 00:03:16.340
要睡多少毫秒呢

00:03:14.629 --> 00:03:18.409
当我们在这段代码中会发生什么

00:03:16.340 --> 00:03:19.879
运行这个小例子，让我们开始吧

00:03:18.409 --> 00:03:22.010
向前并从以下命令运行

00:03:19.879 --> 00:03:23.840
只是看一看，是的，就像你一样

00:03:22.010 --> 00:03:25.819
预计大约需要一秒钟

00:03:23.840 --> 00:03:27.439
运行这些值中的每个值， 

00:03:25.819 --> 00:03:29.359
一次打印这些值

00:03:27.439 --> 00:03:31.639
顺序e，这很简单

00:03:29.359 --> 00:03:33.319
您可以看到一个简单的例子，但我

00:03:31.639 --> 00:03:36.109
想运行这个，我们可以说是快速或

00:03:33.319 --> 00:03:38.029
想象一下转换实际上是真实的

00:03:36.109 --> 00:03:40.159
计算不是虚拟的，那是

00:03:38.029 --> 00:03:41.510
返回数字也许正在尝试

00:03:40.159 --> 00:03:43.219
弄清楚生命的意义

00:03:41.510 --> 00:03:44.809
要花很多时间，如果

00:03:43.219 --> 00:03:46.669
您必须传递这些值并获得

00:03:44.809 --> 00:03:49.069
结果如何呢？ 

00:03:46.669 --> 00:03:50.599
真的从这些操作中也许你

00:03:49.069 --> 00:03:53.150
想要通过在其中运行来加快速度

00:03:50.599 --> 00:03:54.950
平行，以便使它真正平行

00:03:53.150 --> 00:03:58.400
确实有两种方法可以

00:03:54.950 --> 00:04:01.459
实际上采取，其中之一是转向

00:03:58.400 --> 00:04:03.919
流变成并行流

00:04:01.459 --> 00:04:05.779
通过使用单词并行流和

00:04:03.919 --> 00:04:07.909
当然，在这种情况下，它将在

00:04:05.779 --> 00:04:10.159
蝙蝠并行，让我们看看

00:04:07.909 --> 00:04:12.169
它确实可以继续运行并运行

00:04:10.159 --> 00:04:13.909
您会看到它实际打印的繁荣

00:04:12.169 --> 00:04:15.680
结果在那之后一枪

00:04:13.909 --> 00:04:18.440
第二个，它并行运行

00:04:15.680 --> 00:04:21.019
如果什么时候您会很好地使用这种方法

00:04:18.440 --> 00:04:23.180
你是流的源头

00:04:21.019 --> 00:04:25.400
使用并行流很有意义

00:04:23.180 --> 00:04:27.800
在源头上，因为您拥有

00:04:25.400 --> 00:04:29.510
能够创建流并同时

00:04:27.800 --> 00:04:30.560
创建它，你可以说

00:04:29.510 --> 00:04:32.480
您是否打算运行它

00:04:30.560 --> 00:04:34.190
顺序运行或并行运行

00:04:32.480 --> 00:04:37.220
如果你不是那个灵魂

00:04:34.190 --> 00:04:39.920
流想象您真的收到了

00:04:37.220 --> 00:04:42.290
你手上的溪流，你是

00:04:39.920 --> 00:04:44.120
中间之间的某个中间

00:04:42.290 --> 00:04:46.940
你做得好，好消息是你

00:04:44.120 --> 00:04:49.520
可以在这里做暗平行

00:04:46.940 --> 00:04:52.100
您可以将流转换为并行

00:04:49.520 --> 00:04:54.020
尽力做到这一点

00:04:52.100 --> 00:04:56.570
在这里看到所以这又是另一个

00:04:54.020 --> 00:04:58.550
介于两者之间的方法

00:04:56.570 --> 00:05:00.020
管道的中间，说你

00:04:58.550 --> 00:05:01.910
想要真正将其转换为

00:05:00.020 --> 00:05:03.410
并行流，您可以执行此操作

00:05:01.910 --> 00:05:05.300
再次让我们确保这实际上是

00:05:03.410 --> 00:05:07.870
工作，然后返回并运行代码，然后

00:05:05.300 --> 00:05:09.830
你可以看到它一枪就跑了Rylee 

00:05:07.870 --> 00:05:11.720
在我们走得更远之前

00:05:09.830 --> 00:05:14.060
一个小平行，你必须非常

00:05:11.720 --> 00:05:15.890
非常小心，因为有点

00:05:14.060 --> 00:05:17.750
当你是误导你知道

00:05:15.890 --> 00:05:21.470
不真正在想什么

00:05:17.750 --> 00:05:23.720
例如发生的事情，您可能想知道是否

00:05:21.470 --> 00:05:26.720
可能有并行呼叫

00:05:23.720 --> 00:05:29.690
也应该是一个顺序调用

00:05:26.720 --> 00:05:31.550
事实证明，就像你所说的那样

00:05:29.690 --> 00:05:34.190
您实际上可以使用，让我们删除

00:05:31.550 --> 00:05:36.170
从这里平行一分钟

00:05:34.190 --> 00:05:37.580
是流的顺序团队

00:05:36.170 --> 00:05:40.100
导致你知道你刚才说的

00:05:37.580 --> 00:05:41.840
顺序运行是否顺利

00:05:40.100 --> 00:05:43.850
很好，您可以看到它是

00:05:41.840 --> 00:05:46.640
连续运行我不会等待

00:05:43.850 --> 00:05:47.330
所以这里的诱惑就是这样

00:05:46.640 --> 00:05:50.300
很棒

00:05:47.330 --> 00:05:52.790
我们可以拍摄这张地图并在其中运行

00:05:50.300 --> 00:05:56.210
并行并为每个顺序执行

00:05:52.790 --> 00:06:00.050
嗯，不太好，最后一个

00:05:56.210 --> 00:06:01.940
实际上赢了，所以在这个例子中

00:06:00.050 --> 00:06:04.670
整个管道将要运行

00:06:01.940 --> 00:06:06.770
即使我们设置了

00:06:04.670 --> 00:06:08.660
在开始时平行，所以您必须

00:06:06.770 --> 00:06:10.460
在这种情况下要非常小心

00:06:08.660 --> 00:06:12.710
并行流或

00:06:10.460 --> 00:06:15.260
流你没有能力

00:06:12.710 --> 00:06:16.820
在各段之间来回翻转

00:06:15.260 --> 00:06:19.250
并行运行的管道是

00:06:16.820 --> 00:06:22.010
顺序地，这完全是完全

00:06:19.250 --> 00:06:24.170
并行或完全顺序

00:06:22.010 --> 00:06:26.390
示例通知，我确实在

00:06:24.170 --> 00:06:28.370
开始，但我是说连续的

00:06:26.390 --> 00:06:31.010
紧接着在中间

00:06:28.370 --> 00:06:32.660
但是当我运行代码时，尽管

00:06:31.010 --> 00:06:35.210
这个例子仍然在运行

00:06:32.660 --> 00:06:37.700
完全顺序的II地图不是

00:06:35.210 --> 00:06:40.130
并行运行，这是因为

00:06:37.700 --> 00:06:43.280
这实际上影响了整个

00:06:40.130 --> 00:06:43.789
因此从一开始就不只是管道

00:06:43.280 --> 00:06:45.710
从那个

00:06:43.789 --> 00:06:47.779
开始，所以我们必须非常小心

00:06:45.710 --> 00:06:50.479
我们如何使用并行是顺序的

00:06:47.779 --> 00:06:54.159
但也要问的是

00:06:50.479 --> 00:06:56.990
创建并行流真的很容易

00:06:54.159 --> 00:06:58.909
那他们为什么不真正做

00:06:56.990 --> 00:07:00.559
所有平行的问题

00:06:58.909 --> 00:07:02.809
我被问过几次了

00:07:00.559 --> 00:07:04.490
开发人员我的天哪，你可以

00:07:02.809 --> 00:07:07.309
只是说并行流并使其运行

00:07:04.490 --> 00:07:09.199
如果很容易的话为什么不

00:07:07.309 --> 00:07:12.409
他们只是为我所做的一切

00:07:09.199 --> 00:07:14.569
称其为总开关和原因

00:07:12.409 --> 00:07:17.809
我称它为总开关

00:07:14.569 --> 00:07:19.309
如此容易，直到他们

00:07:17.809 --> 00:07:21.110
本来可以完成竞标的

00:07:19.309 --> 00:07:23.509
没有做，然后给你

00:07:21.110 --> 00:07:26.210
转身对你说一个字， 

00:07:23.509 --> 00:07:27.830
这个词叫做思考，所以他们想要

00:07:26.210 --> 00:07:29.809
你转身之前要考虑一下

00:07:27.830 --> 00:07:31.729
在该开关上，因为打开了

00:07:29.809 --> 00:07:33.169
切换真的很容易，但是

00:07:31.729 --> 00:07:35.240
后果可能真是灾难性的

00:07:33.169 --> 00:07:36.499
如果你不是很小心的话

00:07:35.240 --> 00:07:38.240
我们需要做些什么

00:07:36.499 --> 00:07:40.399
小心一点，我们来看一下

00:07:38.240 --> 00:07:43.129
所以在这种情况下我想知道

00:07:40.399 --> 00:07:44.689
线程正在运行我们的小代码，所以

00:07:43.129 --> 00:07:46.399
了解正在运行的线程

00:07:44.689 --> 00:07:48.349
我们的代码让我们继续运行

00:07:46.399 --> 00:07:50.629
一点点代码再次顺序

00:07:48.349 --> 00:07:52.490
但我要观察的是

00:07:50.629 --> 00:07:55.399
运行这个，所以我要来这里

00:07:52.490 --> 00:07:57.740
输出，在这种情况下，我们将说

00:07:55.399 --> 00:08:00.289
转变，然后我们当然会说

00:07:57.740 --> 00:08:02.569
我们正在变换的数字加上我们

00:08:00.289 --> 00:08:04.729
会输出，比如说dart线程

00:08:02.569 --> 00:08:06.080
当前线程，我们可以看一下

00:08:04.729 --> 00:08:08.029
正在执行此的线程

00:08:06.080 --> 00:08:09.589
特定的一段代码，当然

00:08:08.029 --> 00:08:11.569
当我回去运行这个小代码

00:08:09.589 --> 00:08:13.219
正如我们想象的那样，它告诉您

00:08:11.569 --> 00:08:14.749
该代码的每一段都是

00:08:13.219 --> 00:08:17.240
由主线程执行

00:08:14.749 --> 00:08:19.249
像你一样毫无惊喜

00:08:17.240 --> 00:08:20.870
可以看到我要压制这个

00:08:19.249 --> 00:08:22.849
特定的输出，因此我们不必

00:08:20.870 --> 00:08:24.169
真的看着它，所以给定元素

00:08:22.849 --> 00:08:25.909
我只想说不做

00:08:24.169 --> 00:08:27.830
任何东西，所以我们可以看到

00:08:25.909 --> 00:08:30.259
仅转换输出一点

00:08:27.830 --> 00:08:31.699
在这一点上更清楚，所以我们可以看到

00:08:30.259 --> 00:08:33.709
整个事情都在

00:08:31.699 --> 00:08:36.349
主线程一点也不奇怪

00:08:33.709 --> 00:08:38.349
但是另一方面，如果

00:08:36.349 --> 00:08:41.810
我要回去这里

00:08:38.349 --> 00:08:43.699
并行执行这个，所以如果

00:08:41.810 --> 00:08:45.470
然后我要做一个黑暗的平行

00:08:43.699 --> 00:08:47.240
无论是平行飞镖还是

00:08:45.470 --> 00:08:49.459
在源头创建并行流

00:08:47.240 --> 00:08:51.199
真的没关系，就像你会

00:08:49.459 --> 00:08:53.000
期望当我返回并运行此代码

00:08:51.199 --> 00:08:54.769
您注意到所有这些都将

00:08:53.000 --> 00:08:56.569
并发运行，但处于运行线程

00:08:54.769 --> 00:08:57.100
他们在参加加入拉

00:08:56.569 --> 00:08:59.500
线

00:08:57.100 --> 00:09:02.110
如您所见，但请注意， 

00:08:59.500 --> 00:09:03.820
他们全都在全联接池中运行，但是

00:09:02.110 --> 00:09:06.040
另一方面，第一个确实在

00:09:03.820 --> 00:09:07.570
 Maine Maine是一个非常不错的线程

00:09:06.040 --> 00:09:09.640
不坐在那里说你们都做

00:09:07.570 --> 00:09:11.680
我看着你参加的时候工作

00:09:09.640 --> 00:09:13.090
实际上，这是

00:09:11.680 --> 00:09:15.880
四个加入的原因之一

00:09:13.090 --> 00:09:17.920
池中的线程通常少于

00:09:15.880 --> 00:09:19.810
课程数，因为缅因州是

00:09:17.920 --> 00:09:21.460
实际上也是一个参与者

00:09:19.810 --> 00:09:23.320
但是你有点像

00:09:21.460 --> 00:09:25.120
真的为什么我们这么严格

00:09:23.320 --> 00:09:28.060
算一下，我们再谈一点

00:09:25.120 --> 00:09:30.130
稍后，让我们讨论一下

00:09:28.060 --> 00:09:32.020
执行我想给你这些

00:09:30.130 --> 00:09:34.420
并打印结果

00:09:32.020 --> 00:09:36.160
回到这个例子，我们开始吧

00:09:34.420 --> 00:09:38.710
并抑制此输出

00:09:36.160 --> 00:09:40.750
分钟，让我们回到这说我

00:09:38.710 --> 00:09:42.850
想要真正打印出结果，所以

00:09:40.750 --> 00:09:44.710
系统点出来，比如说打印学习和

00:09:42.850 --> 00:09:46.840
然后我要打印结果

00:09:44.710 --> 00:09:48.550
显然在这里

00:09:46.840 --> 00:09:50.770
这种情况下，当我继续运行

00:09:48.550 --> 00:09:53.470
顺序e它将真的

00:09:50.770 --> 00:09:56.320
保持秩序良好，切记不要

00:09:53.470 --> 00:09:58.060
所有流都有订购一些流

00:09:56.320 --> 00:10:00.220
订购一些流没有

00:09:58.060 --> 00:10:03.400
订购如何知道流是否有

00:10:00.220 --> 00:10:05.530
点菜还是不好请原谅我

00:10:03.400 --> 00:10:07.600
知道什么是你的来源

00:10:05.530 --> 00:10:09.220
屏幕，如果您从列表开始

00:10:07.600 --> 00:10:11.290
知道列表是有序的，我们知道是

00:10:09.220 --> 00:10:12.820
没有排序，因此流的来源

00:10:11.290 --> 00:10:15.100
可以决定流是否已排序

00:10:12.820 --> 00:10:18.190
或者你也可以在

00:10:15.100 --> 00:10:20.500
之间可能会强制要求

00:10:18.190 --> 00:10:22.330
例如流，这取决于

00:10:20.500 --> 00:10:23.980
流是否有序

00:10:22.330 --> 00:10:26.230
这个例子当然是流

00:10:23.980 --> 00:10:28.420
命令我们知道，所以当我回去时

00:10:26.230 --> 00:10:30.310
并运行此小代码，您可以看到

00:10:28.420 --> 00:10:31.960
从输出中我们得到的是

00:10:30.310 --> 00:10:34.420
当然是连续的，但是它在

00:10:31.960 --> 00:10:36.250
与您期望的顺序相同，因此

00:10:34.420 --> 00:10:38.620
保留订单，因为我们有

00:10:36.250 --> 00:10:40.120
下令收藏一至六，但

00:10:38.620 --> 00:10:42.010
问题是将会发生什么

00:10:40.120 --> 00:10:44.170
当我们把它变成平行的

00:10:42.010 --> 00:10:47.560
因为它将并行运行

00:10:44.170 --> 00:10:49.450
不能保证订购

00:10:47.560 --> 00:10:51.700
您可以看到这种情况给了我们

00:10:49.450 --> 00:10:52.230
如果您运行它，则完全是任意命令

00:10:51.700 --> 00:10:56.950
再次

00:10:52.230 --> 00:11:00.520
 5 4 3 1 8 2 1 3 5好，这很好

00:10:56.950 --> 00:11:03.370
新闻您得到结果的速度很快，但是

00:11:00.520 --> 00:11:05.830
坏消息是端点真的

00:11:03.370 --> 00:11:08.050
不连续地想象您正在创建一个

00:11:05.830 --> 00:11:09.889
报告它没有帮助客户告诉

00:11:08.050 --> 00:11:11.779
他们是个好消息

00:11:09.889 --> 00:11:13.429
坏消息全都混了

00:11:11.779 --> 00:11:15.470
弄清楚那不会邀请一个

00:11:13.429 --> 00:11:17.779
好客户，你真的如何

00:11:15.470 --> 00:11:19.970
好好管理这是一个主意

00:11:17.779 --> 00:11:22.879
某些方法会强加

00:11:19.970 --> 00:11:25.309
在执行顺序如此

00:11:22.879 --> 00:11:27.589
情况下，我要为每个命令说

00:11:25.309 --> 00:11:30.350
在运行之前，让我们真正地谈论

00:11:27.589 --> 00:11:32.629
我绝不建议

00:11:30.350 --> 00:11:35.149
想像这些正在运行

00:11:32.629 --> 00:11:37.429
依次没有，实际上不是

00:11:35.149 --> 00:11:40.549
实际并发运行

00:11:37.429 --> 00:11:43.100
最后一步说我不会跑

00:11:40.549 --> 00:11:46.519
直到我之前的那个人

00:11:43.100 --> 00:11:48.859
执行，因此强加了订购

00:11:46.519 --> 00:11:51.079
并不意味着它们可以连续运行

00:11:48.859 --> 00:11:53.059
同时执行，但强制执行

00:11:51.079 --> 00:11:55.220
在那个特定点

00:11:53.059 --> 00:11:57.769
这里真正重要的是，地图

00:11:55.220 --> 00:11:59.839
实际上，我们将并行运行

00:11:57.769 --> 00:12:02.269
只需一分钟，所以如果我回去跑步

00:11:59.839 --> 00:12:03.709
现在这个小代码示例

00:12:02.269 --> 00:12:06.319
会注意到它们都在运行

00:12:03.709 --> 00:12:08.480
但不管我多少次

00:12:06.319 --> 00:12:09.949
运行此结果是完全

00:12:08.480 --> 00:12:12.259
即使正在运行也下令

00:12:09.949 --> 00:12:14.419
同时进行，那真的很好

00:12:12.259 --> 00:12:16.399
有邮递员订单的消息

00:12:14.419 --> 00:12:18.739
好，让我们确保实际上

00:12:16.399 --> 00:12:20.480
是的，所以如果我回去打开

00:12:18.739 --> 00:12:22.669
 map方法上的那个print语句

00:12:20.480 --> 00:12:24.319
并再次运行它，您会注意到

00:12:22.669 --> 00:12:27.619
他们实际上以不同的方式运行

00:12:24.319 --> 00:12:31.279
订单注意从输出1 4 6 

00:12:27.619 --> 00:12:34.009
 2但从输出中您有1 2 3所以

00:12:31.279 --> 00:12:36.529
订购在最后一步

00:12:34.009 --> 00:12:38.929
不是在执行地图本身

00:12:36.529 --> 00:12:40.999
他们确实同时运行，而且都

00:12:38.929 --> 00:12:43.429
有点停下来说

00:12:40.999 --> 00:12:45.049
好吧，我要等到我之前的那个家伙

00:12:43.429 --> 00:12:47.089
去，那时候他们真的

00:12:45.049 --> 00:12:48.949
被你顺序知道是否

00:12:47.089 --> 00:12:50.839
所以这真的是个好消息

00:12:48.949 --> 00:12:52.819
可以点菜吗

00:12:50.839 --> 00:12:55.369
施加那种

00:12:52.819 --> 00:12:56.749
订购您是否要使用它们

00:12:55.369 --> 00:12:58.720
这样你就可以拥有最好的

00:12:56.749 --> 00:13:01.699
在那种情况下的两个世界

00:12:58.720 --> 00:13:03.889
但是我们控制顺序但是

00:13:01.699 --> 00:13:06.230
问题真的是真的如何

00:13:03.889 --> 00:13:09.319
并行应用时的工作

00:13:06.230 --> 00:13:12.230
您已经看到了这个例子，我能够

00:13:09.319 --> 00:13:14.389
平行使用地图

00:13:12.230 --> 00:13:16.970
过滤器将并行工作，但随后我们

00:13:14.389 --> 00:13:19.429
有点像奇迹会减少

00:13:16.970 --> 00:13:21.079
并行工作以及

00:13:19.429 --> 00:13:23.690
了解这一点，让我们回到这

00:13:21.079 --> 00:13:26.210
例子让我们做顺序e1 

00:13:23.690 --> 00:13:28.340
更多的时间，但是这次我要

00:13:26.210 --> 00:13:30.560
继续并在此处调用输出

00:13:28.340 --> 00:13:34.220
但在这种情况下，我会问

00:13:30.560 --> 00:13:36.380
最后一步执行归约运算

00:13:34.220 --> 00:13:38.300
我们会说零逗号

00:13:36.380 --> 00:13:41.060
在这种情况下，让我们继续前进， 

00:13:38.300 --> 00:13:42.920
说总逗号元素，我们将调用

00:13:41.060 --> 00:13:45.110
称为提前的方法

00:13:42.920 --> 00:13:47.330
总逗号元素并返回

00:13:45.110 --> 00:13:49.460
结果很好，此添加方法将

00:13:47.330 --> 00:13:51.650
取两个数字并加在我之前

00:13:49.460 --> 00:13:53.990
特别讨论一下，让我们

00:13:51.650 --> 00:13:56.210
了解减少实际工作量的因素

00:13:53.990 --> 00:13:58.910
假设我要累计

00:13:56.210 --> 00:14:00.380
这个房间里的每个人都从他开始

00:13:58.910 --> 00:14:02.030
这不是在微笑吗？ 

00:14:00.380 --> 00:14:03.200
不会问你的真实年龄，所以说

00:14:02.030 --> 00:14:05.000
我们将从他开始，所以我们是什么

00:14:03.200 --> 00:14:07.550
我要给他一个零

00:14:05.000 --> 00:14:10.190
重视每个人的年龄

00:14:07.550 --> 00:14:12.440
对，他把自己的年龄定为零

00:14:10.190 --> 00:14:14.210
它传递给他接任的下一位先生

00:14:12.440 --> 00:14:16.190
给他的价值增加了​​他自己的年龄

00:14:14.210 --> 00:14:18.710
传给下一位先生，然后我作为

00:14:16.190 --> 00:14:21.440
这些数据通过房间

00:14:18.710 --> 00:14:23.480
我从最后一个人身上得到的价值

00:14:21.440 --> 00:14:24.830
在房间里的总年龄是

00:14:23.480 --> 00:14:26.570
房间里的每个人或溢出

00:14:24.830 --> 00:14:29.030
根据我们这个房间的年龄

00:14:26.570 --> 00:14:31.010
但关键是我们确实

00:14:29.030 --> 00:14:32.420
将有此顺序e 

00:14:31.010 --> 00:14:34.400
价值将在此滴流

00:14:32.420 --> 00:14:36.380
房间，我们在那里得到结果

00:14:34.400 --> 00:14:37.910
那是一种减少做的事情

00:14:36.380 --> 00:14:40.940
收集结果并将我们带回

00:14:37.910 --> 00:14:43.130
到一个单一的价值，但我很好奇

00:14:40.940 --> 00:14:46.070
看一下广告本身，让我们继续

00:14:43.130 --> 00:14:48.380
再次从

00:14:46.070 --> 00:14:50.810
地图方法，但在这种情况下，我要

00:14:48.380 --> 00:14:53.750
创建一个方法，这是添加方法

00:14:50.810 --> 00:14:56.540
它取值1和int值2 

00:14:53.750 --> 00:14:59.210
我要做的就是输出，让我们

00:14:56.540 --> 00:15:01.190
继续说添加+在这种情况下会

00:14:59.210 --> 00:15:03.830
输出值1，然后我们将

00:15:01.190 --> 00:15:06.170
输出我们说值2和

00:15:03.830 --> 00:15:08.540
最后，我们将继续进行输出

00:15:06.170 --> 00:15:10.850
我们也说一下线程信息

00:15:08.540 --> 00:15:13.730
所以线程点说当前线程

00:15:10.850 --> 00:15:16.520
并很好地打印它，如果我们这样做

00:15:13.730 --> 00:15:18.320
在这一点上，我们顺序执行

00:15:16.520 --> 00:15:20.060
像我说的那样从0开始

00:15:18.320 --> 00:15:22.130
他要把自己的年龄加到0 

00:15:20.060 --> 00:15:24.770
然后把它传下来

00:15:22.130 --> 00:15:27.140
你会在这里看到的是

00:15:24.770 --> 00:15:28.400
基本上，当您运行此代码时，您可以

00:15:27.140 --> 00:15:29.960
看到实际上在这种情况下

00:15:28.400 --> 00:15:32.089
完成一个错误，但我们会解决

00:15:29.960 --> 00:15:34.310
所以在这种情况下，如您所见

00:15:32.089 --> 00:15:36.530
它要顺序运行

00:15:34.310 --> 00:15:37.580
这些中的每一个，并让您

00:15:36.530 --> 00:15:39.290
结果出来

00:15:37.580 --> 00:15:41.180
最终，让我们继续进行修复

00:15:39.290 --> 00:15:43.250
向右箭头很高兴返回

00:15:41.180 --> 00:15:46.550
结果不是吗，所以说返回

00:15:43.250 --> 00:15:48.710
在这种情况下，值1加值2 

00:15:46.550 --> 00:15:50.810
是add函数的结果，让我们

00:15:48.710 --> 00:15:52.280
继续尝试这个，这样

00:15:50.810 --> 00:15:54.500
在这种情况下，您可以看到广告是

00:15:52.280 --> 00:15:57.140
在主线程中被调用

00:15:54.500 --> 00:15:59.390
值0加1，然后是

00:15:57.140 --> 00:16:01.550
那是一个落在这里1加2 

00:15:59.390 --> 00:16:03.560
结果是3在这里下降3 

00:16:01.550 --> 00:16:04.430
加3的结果是6，然后

00:16:03.560 --> 00:16:07.010
您可以看到它经历了

00:16:04.430 --> 00:16:08.750
顺序II，但问题是

00:16:07.010 --> 00:16:10.700
并行执行此操作很有意义

00:16:08.750 --> 00:16:13.280
让我们回到刚才的例子

00:16:10.700 --> 00:16:15.560
刚刚谈到我要

00:16:13.280 --> 00:16:17.660
给他0，说总数

00:16:15.560 --> 00:16:19.850
这个房间里每个人的年龄顺序

00:16:17.660 --> 00:16:22.160
 II但后来我很快意识到

00:16:19.850 --> 00:16:24.860
不必真正做到这一点，我要

00:16:22.160 --> 00:16:28.070
给每个人在左上角

00:16:24.860 --> 00:16:30.320
我在该行的左侧值为0， 

00:16:28.070 --> 00:16:32.870
同样，我在这个角落里的每个人

00:16:30.320 --> 00:16:36.200
要给0，然后说为什么不

00:16:32.870 --> 00:16:38.510
每行总计您的年龄并发

00:16:36.200 --> 00:16:40.730
在第一步结束时，我要

00:16:38.510 --> 00:16:42.710
有一个，你知道几行

00:16:40.730 --> 00:16:46.220
正如我们在这个房间里所拥有的

00:16:42.710 --> 00:16:48.320
一方面有很多总数， 

00:16:46.220 --> 00:16:51.530
在另一边，我可以

00:16:48.320 --> 00:16:53.240
说，嘿，这一排的人总共

00:16:51.530 --> 00:16:55.760
重视这种方式，人们对此

00:16:53.240 --> 00:16:58.040
列以这种方式总计值

00:16:55.760 --> 00:16:59.900
第二步，我将有两个值

00:16:58.040 --> 00:17:01.520
将它们放在一起并获得价值削减

00:16:59.900 --> 00:17:03.620
换句话说，您立即知道

00:17:01.520 --> 00:17:05.570
可以做到这一点的分而治之

00:17:03.620 --> 00:17:07.730
不必真正执行顺序

00:17:05.570 --> 00:17:11.180
在这种情况下，如果我回去的话

00:17:07.730 --> 00:17:12.980
在这里，并尝试并行运行

00:17:11.180 --> 00:17:15.260
我运行此程序时会立即注意到

00:17:12.980 --> 00:17:17.449
代码，您可以看到它实际上是

00:17:15.260 --> 00:17:19.790
尽可能并行运行

00:17:17.449 --> 00:17:21.980
查看所有正在调用的广告

00:17:19.790 --> 00:17:23.810
多线程，您可能会注意到

00:17:21.980 --> 00:17:26.480
有更多的通话要添加

00:17:23.810 --> 00:17:29.390
正如我在案例中所说

00:17:26.480 --> 00:17:31.340
我要打电话给不同的组

00:17:29.390 --> 00:17:34.100
人，然后收集在一起

00:17:31.340 --> 00:17:36.440
作为什么，结果是使用是否

00:17:34.100 --> 00:17:39.200
您按顺序或并发运行

00:17:36.440 --> 00:17:41.030
结果仍然是21还可以，这真棒

00:17:39.200 --> 00:17:44.330
是不是因为我可以运行这段代码

00:17:41.030 --> 00:17:46.700
顺序II，结果是21和I 

00:17:44.330 --> 00:17:49.160
可以同时运行代码，并且

00:17:46.700 --> 00:17:51.410
结果仍然是21，这是很棒的

00:17:49.160 --> 00:17:53.270
并行性，您无法快速获得结果

00:17:51.410 --> 00:17:54.860
搅拌一下，如果没有的话就可以了

00:17:53.270 --> 00:17:56.840
正确的权利没有任何意义

00:17:54.860 --> 00:17:59.210
该结果必须仍然正确，因为

00:17:56.840 --> 00:18:01.130
很好，当您这样做时，但是

00:17:59.210 --> 00:18:03.830
您必须非常小心

00:18:01.130 --> 00:18:05.990
您在此处提供的价值不是

00:18:03.830 --> 00:18:07.250
初始值必须非常非常

00:18:05.990 --> 00:18:10.730
小心一点

00:18:07.250 --> 00:18:13.310
它实际上是一个身份值，而不是

00:18:10.730 --> 00:18:15.430
初始值，例如或加法

00:18:13.310 --> 00:18:18.740
零是的标识值

00:18:15.430 --> 00:18:20.030
乘法之一是一个身份值

00:18:18.740 --> 00:18:21.890
请记住这一点很重要

00:18:20.030 --> 00:18:24.110
因为假设我对

00:18:21.890 --> 00:18:26.060
总计我自己的年龄到

00:18:24.110 --> 00:18:27.950
这个房间里的每个人，我要说

00:18:26.060 --> 00:18:30.080
 20对，所以你不相信这样

00:18:27.950 --> 00:18:32.660
所以我将从那个数字开始

00:18:30.080 --> 00:18:34.760
 20加21是我们真正想要的结果

00:18:32.660 --> 00:18:36.200
最后，当它运行时

00:18:34.760 --> 00:18:39.290
当然你可以看到结果应该是

00:18:36.200 --> 00:18:41.960
 41，因为初始结果是21 

00:18:39.290 --> 00:18:44.570
我们看到它实际上是41，但是我们

00:18:41.960 --> 00:18:47.300
现在真的很麻烦，因为我做了

00:18:44.570 --> 00:18:48.020
不给一个身份值20不是一个

00:18:47.300 --> 00:18:50.210
值

00:18:48.020 --> 00:18:53.210
我必须将其误认为是初始值

00:18:50.210 --> 00:18:55.940
当我跑步时，结果是灾难性的

00:18:53.210 --> 00:18:59.180
这段代码这次打不了

00:18:55.940 --> 00:19:00.740
更长的41它是141不要打赌

00:18:59.180 --> 00:19:03.710
接下来可能会完全不同

00:19:00.740 --> 00:19:05.720
时间，因为它满足了所有这些

00:19:03.710 --> 00:19:07.880
值为20的并行值

00:19:05.720 --> 00:19:09.470
真的没有任何意义

00:19:07.880 --> 00:19:11.990
这是我们必须非常重视的事情

00:19:09.470 --> 00:19:13.880
当我们使用并行时再次小心

00:19:11.990 --> 00:19:16.040
我真的必须说这是无可替代的

00:19:13.880 --> 00:19:17.330
知道我们一般会做什么，但是

00:19:16.040 --> 00:19:19.070
特别是在平行的情况下

00:19:17.330 --> 00:19:21.230
重要，没有意义

00:19:19.070 --> 00:19:22.940
得到一个错误的结果

00:19:21.230 --> 00:19:23.690
如果您真的想获得一个真正的

00:19:22.940 --> 00:19:25.730
快速

00:19:23.690 --> 00:19:28.430
如果您真的想要获得结果，则为真

00:19:25.730 --> 00:19:30.200
真的很快，你不在乎

00:19:28.430 --> 00:19:32.120
不管是不是真的

00:19:30.200 --> 00:19:34.340
想回去用C ++编程不是

00:19:32.120 --> 00:19:36.020
所以这绝对不是原因

00:19:34.340 --> 00:19:38.450
做到这一点，所以我们真的想确保

00:19:36.020 --> 00:19:40.400
我们也可以正确得到结果

00:19:38.450 --> 00:19:42.770
在这种情况下不仅更快

00:19:40.400 --> 00:19:44.060
所以当我们返回并运行

00:19:42.770 --> 00:19:45.650
当然，在这种情况下结果仍然是

00:19:44.060 --> 00:19:47.870
会一样，因为我

00:19:45.650 --> 00:19:49.400
然后提供一个身份值

00:19:47.870 --> 00:19:51.710
问题是我是否真的要添加

00:19:49.400 --> 00:19:54.080
我的八个为什么要做好那不是

00:19:51.710 --> 00:19:56.540
没关系，因为我可以回到这里

00:19:54.080 --> 00:19:58.670
并在此末尾添加

00:19:56.540 --> 00:20:01.580
在这种情况下当然特别好

00:19:58.670 --> 00:20:03.140
纠正一些事情要记住什么

00:20:01.580 --> 00:20:05.140
您将作为初始值发送

00:20:03.140 --> 00:20:07.030
有很大的不同

00:20:05.140 --> 00:20:08.440
但这引出了我们一直以来的疑问

00:20:07.030 --> 00:20:10.540
看着这些线程

00:20:08.440 --> 00:20:12.310
这些线程到底在做什么？ 

00:20:10.540 --> 00:20:14.410
他们真的使用我们真的想要

00:20:12.310 --> 00:20:17.740
了解它，所以我们有多少个线程

00:20:14.410 --> 00:20:20.020
一劳永逸

00:20:17.740 --> 00:20:21.970
了解这一点，让我们看一下

00:20:20.020 --> 00:20:24.640
一点输出就在这里

00:20:21.970 --> 00:20:27.130
回到这个小数学函数，我

00:20:24.640 --> 00:20:27.880
在这种情况下，每个人都会说

00:20:27.130 --> 00:20:29.590
元件

00:20:27.880 --> 00:20:32.290
我只想简单地压制

00:20:29.590 --> 00:20:34.840
输出让我们回到map方法

00:20:32.290 --> 00:20:36.460
转换方法并打印结果

00:20:34.840 --> 00:20:38.440
出来，这样可以给我们一点点

00:20:36.460 --> 00:20:41.470
一个想法，将要运行多少个线程

00:20:38.440 --> 00:20:43.300
现在回到我们这里去吧

00:20:41.470 --> 00:20:46.180
向前并通过一个价值观

00:20:43.300 --> 00:20:48.160
七个，比方说八个九个和十个

00:20:46.180 --> 00:20:51.880
我将再重复一次

00:20:48.160 --> 00:20:54.850
在这里，假设我具有这些值

00:20:51.880 --> 00:20:56.680
重复，所以我有这些价值观，即使

00:20:54.850 --> 00:20:59.800
我们要说的真的是

00:20:56.680 --> 00:21:03.070
 11和12和13我可以拥有这些小东西

00:20:59.800 --> 00:21:04.330
提供值，以便我们可以看到

00:21:03.070 --> 00:21:07.000
要运行多少个线程

00:21:04.330 --> 00:21:10.030
同时很好的结果

00:21:07.000 --> 00:21:13.300
这实际上是默认情况下

00:21:10.030 --> 00:21:15.970
您得到的线程数与

00:21:13.300 --> 00:21:18.580
核心在您的计算机上，所以我想知道

00:21:15.970 --> 00:21:20.080
我的机器上有多少个核心

00:21:18.580 --> 00:21:22.180
让我们继续删除此

00:21:20.080 --> 00:21:26.470
暂时，我要回到这里

00:21:22.180 --> 00:21:29.650
并说输出运行时dart运行时

00:21:26.470 --> 00:21:31.450
在这种情况下，我们说运行时间以及什么

00:21:29.650 --> 00:21:32.860
在这种情况下我们要问我吗

00:21:31.450 --> 00:21:35.920
现在不记得这种方法了，但是

00:21:32.860 --> 00:21:37.810
可用的处理器，所以我想

00:21:35.920 --> 00:21:39.580
知道有多少个处理器可用

00:21:37.810 --> 00:21:42.310
告诉我有八个

00:21:39.580 --> 00:21:44.710
机器上可用的处理器，因此

00:21:42.310 --> 00:21:47.850
这是您了解如何

00:21:44.710 --> 00:21:50.320
有很多核心可用，这是公然的

00:21:47.850 --> 00:21:53.080
虚假信息很多

00:21:50.320 --> 00:21:55.240
我的机器上没有八个核心

00:21:53.080 --> 00:21:56.680
但这就是它告诉我的

00:21:55.240 --> 00:21:58.990
当然，这告诉我

00:21:56.680 --> 00:22:00.760
八个核心我实际上有四个，但是

00:21:58.990 --> 00:22:02.050
只想算八

00:22:00.760 --> 00:22:03.820
很好，但这会给我一个

00:22:02.050 --> 00:22:05.770
共有八个线程还记得

00:22:03.820 --> 00:22:08.740
主要也是其中的一部分，所以

00:22:05.770 --> 00:22:11.140
形成的公共分叉/联接池包含一个

00:22:08.740 --> 00:22:13.570
当我的机器共有七个线程

00:22:11.140 --> 00:22:15.370
有八个核心我该如何注意

00:22:13.570 --> 00:22:17.830
这是一个小例子，我们可以

00:22:15.370 --> 00:22:19.030
只是继续说在这里

00:22:17.830 --> 00:22:21.970
加入puh 

00:22:19.030 --> 00:22:24.160
飞镖公共游泳池就是你的方式

00:22:21.970 --> 00:22:26.620
可以访问公共池，并且

00:22:24.160 --> 00:22:28.870
然后您可以从中索取详细信息

00:22:26.620 --> 00:22:31.000
显然您要使用这个我需要

00:22:28.870 --> 00:22:33.550
 java.util并发，所以我要带

00:22:31.000 --> 00:22:35.620
在这里，所以这里是并发的

00:22:33.550 --> 00:22:37.570
我现在要做什么

00:22:35.620 --> 00:22:39.610
注意我要问他细节

00:22:37.570 --> 00:22:41.350
关于我回去时的公共泳池

00:22:39.610 --> 00:22:44.410
运行这个小代码，它告诉我有8 

00:22:41.350 --> 00:22:46.300
核心，但请注意这里

00:22:44.410 --> 00:22:48.490
并行度是7 

00:22:46.300 --> 00:22:49.870
那是因为7加1是8 

00:22:48.490 --> 00:22:52.120
是我的课程总数

00:22:49.870 --> 00:22:54.850
机器主体是其他参与者

00:22:52.120 --> 00:22:57.010
这个特定俱乐部的

00:22:54.850 --> 00:22:59.350
基本上我们在这里看到的是4 

00:22:57.010 --> 00:23:01.420
现在正在使用连接池，这是一种方法

00:22:59.350 --> 00:23:04.210
考虑自然

00:23:01.420 --> 00:23:06.370
这些东西以这种方式工作的方式

00:23:04.210 --> 00:23:08.980
这将被安排在

00:23:06.370 --> 00:23:12.010
那些不同的线程

00:23:08.980 --> 00:23:14.560
想象我手上有20个元素

00:23:12.010 --> 00:23:18.100
我要安排这20个元素

00:23:14.560 --> 00:23:19.690
我机器上有8个以上的内核

00:23:18.100 --> 00:23:23.320
我们正在分批查看

00:23:19.690 --> 00:23:25.270
给或取三批，所以8 16和

00:23:23.320 --> 00:23:27.400
剩下的要达到20 

00:23:25.270 --> 00:23:30.100
实际上可以在这里看到它的运动

00:23:27.400 --> 00:23:33.490
让我们继续运行并爆发

00:23:30.100 --> 00:23:35.590
的通话，这是通话后的第一个通话

00:23:33.490 --> 00:23:37.330
实际上，如果它可以编译，那就让我们

00:23:35.590 --> 00:23:39.340
继续并正确删除此输出

00:23:37.330 --> 00:23:41.320
在这里，再试一次，我们要

00:23:39.340 --> 00:23:43.390
在这里看到第一通电话

00:23:41.320 --> 00:23:47.500
所以让我们看看这是真的，所以这是

00:23:43.390 --> 00:23:50.110
爆破1爆破2经文3 

00:23:47.500 --> 00:23:52.060
可以看到3个突发

00:23:50.110 --> 00:23:53.620
来了，三个原因

00:23:52.060 --> 00:23:55.990
事实上，如果我突然爆发

00:23:53.620 --> 00:23:57.850
为您删除线程详细信息，以便

00:23:55.990 --> 00:23:59.710
我在这儿请稍等一下

00:23:57.850 --> 00:24:02.170
一点点就更容易看到

00:23:59.710 --> 00:24:05.560
简洁的输出，所以我们在这里

00:24:02.170 --> 00:24:07.480
爆破一首2节经文3首

00:24:05.560 --> 00:24:09.820
那显然是跨那些安排的

00:24:07.480 --> 00:24:12.070
那八个不同是

00:24:09.820 --> 00:24:14.920
在我的系统上可用，但这带来了

00:24:12.070 --> 00:24:17.170
提出问题，为什么要如此小心

00:24:14.920 --> 00:24:18.100
默认线程为什么我们不能走

00:24:17.170 --> 00:24:20.170
疯狂

00:24:18.100 --> 00:24:22.090
我们将看到为什么只有一个原因

00:24:20.170 --> 00:24:25.480
第二，所以当你做并行时

00:24:22.090 --> 00:24:27.850
流你必须非常小心他们

00:24:25.480 --> 00:24:29.860
没有选择等于的内核数

00:24:27.850 --> 00:24:32.480
默认情况下任意线程数

00:24:29.860 --> 00:24:35.030
他们非常非常聪明

00:24:32.480 --> 00:24:36.799
说如果有什么毛病，他们

00:24:35.030 --> 00:24:38.450
希望你不要责怪他们

00:24:36.799 --> 00:24:40.370
对的，这只是我要做的

00:24:38.450 --> 00:24:42.410
在设计我不想的库

00:24:40.370 --> 00:24:44.540
我做的决定要怪我

00:24:42.410 --> 00:24:46.730
我做的决定非常安全，所以

00:24:44.540 --> 00:24:48.410
我能做出的最安全的决定是

00:24:46.730 --> 00:24:50.240
您与课程数量一样多的线程

00:24:48.410 --> 00:24:52.340
但这引出了一个问题，为什么在

00:24:50.240 --> 00:24:55.190
我会给世界那么安全

00:24:52.340 --> 00:24:57.110
你是一个非常愚蠢的例子，想象在那里

00:24:55.190 --> 00:24:59.450
是和尚，你知道和尚如何

00:24:57.110 --> 00:25:01.280
最有礼貌的人对吗？ 

00:24:59.450 --> 00:25:03.890
有四个和尚，有两个

00:25:01.280 --> 00:25:06.590
跑步机，所以四个决定去

00:25:03.890 --> 00:25:08.299
健身房，所以他们去健身房和两个月

00:25:06.590 --> 00:25:09.830
上跑步机，你知道如何

00:25:08.299 --> 00:25:11.600
和尚非常有礼貌他们上

00:25:09.830 --> 00:25:13.669
跑步机，他们低头说哦

00:25:11.600 --> 00:25:15.350
亲爱的上帝，你们俩都在等待

00:25:13.669 --> 00:25:16.640
我在跑步机上无礼

00:25:15.350 --> 00:25:18.710
他们立即从

00:25:16.640 --> 00:25:20.390
跑步机上，其他两个和尚上

00:25:18.710 --> 00:25:22.130
跑步机，他们说什么

00:25:20.390 --> 00:25:24.110
你在等我时多么无礼

00:25:22.130 --> 00:25:26.360
他们在跑步机上

00:25:24.110 --> 00:25:28.010
和尚从不运动，这就是为什么

00:25:26.360 --> 00:25:28.880
生活中有时会表现出无礼的好习惯

00:25:28.010 --> 00:25:31.070
这不只是在开玩笑

00:25:28.880 --> 00:25:32.690
但关键是这确实是

00:25:31.070 --> 00:25:34.970
如果您的威胁会做什么

00:25:32.690 --> 00:25:36.440
线程是计算密集型的

00:25:34.970 --> 00:25:38.870
像那些和尚一样

00:25:36.440 --> 00:25:40.400
他们将在这个CPU上

00:25:38.870 --> 00:25:41.540
情况如下

00:25:40.400 --> 00:25:43.460
它下来所以有点

00:25:41.540 --> 00:25:45.620
在这种情况下有争议，但

00:25:43.460 --> 00:25:47.750
线程等待说嘿，你下车了

00:25:45.620 --> 00:25:49.970
轮到我了，线程在

00:25:47.750 --> 00:25:53.120
 CPU说，但我有工作要做，我没有

00:25:49.970 --> 00:25:55.520
关心轮到我下车了，所以

00:25:53.120 --> 00:25:57.230
他们只为这两个吃掉CPU 

00:25:55.520 --> 00:25:59.240
继续猜测下车的是什么

00:25:57.230 --> 00:26:01.160
他们转过身说你现在下车吗

00:25:59.240 --> 00:26:02.780
他们会互相浪费

00:26:01.160 --> 00:26:04.790
我们会失去表现，我们不会

00:26:02.780 --> 00:26:07.880
小心，所以故事的模式是

00:26:04.790 --> 00:26:10.820
这样线程数就可以了

00:26:07.880 --> 00:26:13.220
总是想给小于或

00:26:10.820 --> 00:26:15.710
等于然后你可以做一点

00:26:13.220 --> 00:26:19.700
你可以在上面说的小快速公式

00:26:15.710 --> 00:26:21.799
分子是您的核心数

00:26:19.700 --> 00:26:25.070
机器，我们将从此开始，然后

00:26:21.799 --> 00:26:28.400
一个-好吧，我要说的是

00:26:25.070 --> 00:26:31.549
叫做阻碍因素，所以说

00:26:28.400 --> 00:26:33.350
什么是阻碍因素，所以如果我是

00:26:31.549 --> 00:26:36.830
阻塞因子小于零或

00:26:33.350 --> 00:26:39.470
等于阻塞因子小于

00:26:36.830 --> 00:26:41.990
如果我是计算密集型的人

00:26:39.470 --> 00:26:43.610
线程然后如果我是

00:26:41.990 --> 00:26:45.020
根据Ted我的比赛项目

00:26:43.610 --> 00:26:46.100
运行，运行，运行

00:26:45.020 --> 00:26:47.539
我没有

00:26:46.100 --> 00:26:49.580
我有休息的机会

00:26:47.539 --> 00:26:52.429
没有什么好睡觉的

00:26:49.580 --> 00:26:54.799
如果我是I / O密集型，系数为零

00:26:52.429 --> 00:26:56.299
我想写入数据库的线程

00:26:54.799 --> 00:26:58.309
想从数据库中读取我想

00:26:56.299 --> 00:27:00.169
拨打我要的远程系统

00:26:58.309 --> 00:27:02.570
写入日志文件我要打开文件

00:27:00.169 --> 00:27:05.480
这些机会中的每一个都是

00:27:02.570 --> 00:27:07.850
当我要说CPU时，请放轻松

00:27:05.480 --> 00:27:10.010
我正在等待这个文件的开始

00:27:07.850 --> 00:27:11.660
带给我数据，什么是CPU 

00:27:10.010 --> 00:27:13.880
要去做CPU就像我不喜欢

00:27:11.660 --> 00:27:15.230
你有什么事要做

00:27:13.880 --> 00:27:17.299
轮子，现在你要走了

00:27:15.230 --> 00:27:18.710
很好地获取数据，您可能会工作得很好

00:27:17.299 --> 00:27:20.720
在另一个需要的线程上

00:27:18.710 --> 00:27:23.840
当我没有什么要处理时

00:27:20.720 --> 00:27:26.929
如果您有I / O线程，请执行此操作

00:27:23.840 --> 00:27:29.630
您可以使用CPU拥有更多线程

00:27:26.929 --> 00:27:33.020
届时将使用您的CPU执行更多任务

00:27:29.630 --> 00:27:34.850
所以如果我有一个正在睡觉的任务

00:27:33.020 --> 00:27:37.370
因为在这种情况下，让我们工作

00:27:34.850 --> 00:27:39.730
我需要大量计算的公式

00:27:37.370 --> 00:27:42.590
线程，这意味着阻塞因素

00:27:39.730 --> 00:27:45.470
阻塞因子等于零

00:27:42.590 --> 00:27:47.570
是不是然后我的线程数

00:27:45.470 --> 00:27:50.150
要真正创建小于或

00:27:47.570 --> 00:27:53.179
等于核心数，因为1减

00:27:50.150 --> 00:27:56.210
分母中的0是1，但如果我是

00:27:53.179 --> 00:27:59.630
 I / O密集型让我们一起说

00:27:56.210 --> 00:28:01.490
假设阻挡因子为0.5 

00:27:59.630 --> 00:28:04.250
您可以使用的线程数

00:28:01.490 --> 00:28:08.059
只要我小于或等于2 

00:28:04.250 --> 00:28:10.610
乘以实际的核数，如果

00:28:08.059 --> 00:28:12.830
我大部分时间都在睡觉

00:28:10.610 --> 00:28:14.390
当然给我更多的核心

00:28:12.830 --> 00:28:16.190
有足够的工作要做正确的事

00:28:14.390 --> 00:28:18.470
当然，如果阻碍因素是

00:28:16.190 --> 00:28:20.720
 1那是您不想去的僵局

00:28:18.470 --> 00:28:22.340
那里绝对可以给你更多

00:28:20.720 --> 00:28:24.559
如果我是I / O密集的线程

00:28:22.340 --> 00:28:27.169
如果我在计算，线程数更少

00:28:24.559 --> 00:28:29.210
精读现在你知道他们为什么选择

00:28:27.169 --> 00:28:31.100
默认的线程数等于

00:28:29.210 --> 00:28:33.770
当然，因为那是一个

00:28:31.100 --> 00:28:35.390
非常安全的赌注，因为他们不知道

00:28:33.770 --> 00:28:37.280
你在做什么，他们无法预测

00:28:35.390 --> 00:28:39.260
您正在做的最安全的选择是

00:28:37.280 --> 00:28:41.210
说嘿你的计算量大

00:28:39.260 --> 00:28:42.710
但是如果我不舒服怎么办

00:28:41.210 --> 00:28:44.720
改变您想要的线程数

00:28:42.710 --> 00:28:46.190
很好地使用这是我们刚才的公式

00:28:44.720 --> 00:28:48.530
看着决定数量

00:28:46.190 --> 00:28:50.299
线程，但您如何真正配置

00:28:48.530 --> 00:28:52.880
您想要的线程数

00:28:50.299 --> 00:28:55.100
在您的应用程序中使用这是一个

00:28:52.880 --> 00:28:58.549
危险环境请小心使用

00:28:55.100 --> 00:28:59.500
但此设置只是说- 

00:28:58.549 --> 00:29:02.049
 JVM级别

00:28:59.500 --> 00:29:05.169
 Java点util点并发点

00:29:02.049 --> 00:29:08.049
联合我们共同的点并行性

00:29:05.169 --> 00:29:10.450
我终于爱上了这家酒店

00:29:08.049 --> 00:29:13.000
比我的名字长，如你所见

00:29:10.450 --> 00:29:15.490
在这里您可以指定此属性， 

00:29:13.000 --> 00:29:17.530
请它在这里使用此权限，怎么办

00:29:15.490 --> 00:29:19.570
我用这个我有点懒惰

00:29:17.530 --> 00:29:21.460
不会真的将所有这些手动收紧

00:29:19.570 --> 00:29:24.010
所以我要给你看这个例子

00:29:21.460 --> 00:29:26.770
在我要使用的地方使用小脚本

00:29:24.010 --> 00:29:29.049
这个线程，所以这是一个运行配置

00:29:26.770 --> 00:29:30.760
为自己写的那是哪里

00:29:29.049 --> 00:29:32.470
设置该属性，如您所见

00:29:30.760 --> 00:29:34.750
运行配置这样做，所以我没有

00:29:32.470 --> 00:29:37.419
如果我运行

00:29:34.750 --> 00:29:38.919
就像我们看到的那样运行方法

00:29:37.419 --> 00:29:40.659
默认线程数

00:29:38.919 --> 00:29:43.570
那是一胎二胎三胎

00:29:40.659 --> 00:29:45.010
如您所见，但如果我确实在

00:29:43.570 --> 00:29:47.260
另一方面，给它一百

00:29:45.010 --> 00:29:49.120
爆裂的线程，我完成了

00:29:47.260 --> 00:29:52.690
你可以看到，因为它给了我们一百

00:29:49.120 --> 00:29:55.450
不仅要运行一组线程

00:29:52.690 --> 00:29:57.309
八个线程使用时要非常小心

00:29:55.450 --> 00:29:59.980
功能，因为它会更改设置

00:29:57.309 --> 00:30:02.650
在整个JVM上，而不是您

00:29:59.980 --> 00:30:04.659
想要如此迅速地做而没有

00:30:02.650 --> 00:30:06.340
还考虑是否正在使用或一个

00:30:04.659 --> 00:30:08.230
我从客户那里听到的另一件事

00:30:06.340 --> 00:30:10.960
通常是他们会使用第三方

00:30:08.230 --> 00:30:11.590
容器不要在这个时候弄乱

00:30:10.960 --> 00:30:14.230
您正在与第三方打交道

00:30:11.590 --> 00:30:16.539
容器第三方容器是

00:30:14.230 --> 00:30:18.520
主要是为了让他们可以带走

00:30:16.539 --> 00:30:20.350
来自我们的线程，所以这有点

00:30:18.520 --> 00:30:21.760
与之相反的是要小心

00:30:20.350 --> 00:30:24.100
你也可以配置它

00:30:21.760 --> 00:30:26.409
以编程方式以及您如何

00:30:24.100 --> 00:30:28.299
如果需要，以编程方式更改此设置

00:30:26.409 --> 00:30:30.970
以编程方式更改此内容

00:30:28.299 --> 00:30:34.570
可以在这里做的是，您可以创建自己的

00:30:30.970 --> 00:30:37.900
拥有加入池，因此加入连接让我们

00:30:34.570 --> 00:30:40.450
说在这里池等于新的

00:30:37.900 --> 00:30:41.559
加入游泳池，让我们说50，然后我

00:30:40.450 --> 00:30:43.480
要说池镖

00:30:41.559 --> 00:30:45.700
关闭这是我的事情之一

00:30:43.480 --> 00:30:47.530
通常我想尽快将其关闭

00:30:45.700 --> 00:30:49.539
当我创建它，这将

00:30:47.530 --> 00:30:50.890
要求您处理例外情况，我们将

00:30:49.539 --> 00:30:53.799
再过一分钟再说

00:30:50.890 --> 00:30:56.710
那我要在这里说一个游泳池

00:30:53.799 --> 00:31:00.100
飞镖等待终止，然后我

00:30:56.710 --> 00:31:02.950
要说一次10次逗号

00:31:00.100 --> 00:31:04.450
一支飞镖，说几秒钟，所以我

00:31:02.950 --> 00:31:06.730
要给它10秒钟

00:31:04.450 --> 00:31:08.409
现在完成所有这些工作

00:31:06.730 --> 00:31:11.350
我能做的就是说可以飞镖

00:31:08.409 --> 00:31:12.940
提交，在提交中，我可以

00:31:11.350 --> 00:31:14.650
只是继续说

00:31:12.940 --> 00:31:18.310
我想要执行该操作

00:31:14.650 --> 00:31:20.800
当然在那里平行，但是

00:31:18.310 --> 00:31:23.410
注意对这个并行的调用

00:31:20.800 --> 00:31:26.050
从这里，在这里

00:31:23.410 --> 00:31:28.900
结果，因为我在

00:31:26.050 --> 00:31:31.060
四个连接杆，这将在

00:31:28.900 --> 00:31:32.920
那是本地的

00:31:31.060 --> 00:31:34.390
特别的电话，它将要做

00:31:32.920 --> 00:31:36.430
那当然不会在

00:31:34.390 --> 00:31:38.620
当它抱怨我必须处理

00:31:36.430 --> 00:31:40.510
除间断异常外， 

00:31:38.620 --> 00:31:42.220
我们一直都在用Java玩的游戏

00:31:40.510 --> 00:31:43.990
你用Java写一些代码说你

00:31:42.220 --> 00:31:45.730
将处理异常，您作为

00:31:43.990 --> 00:31:47.590
程序员展示谁在掌权

00:31:45.730 --> 00:31:49.900
放抛出异常权，所以这

00:31:47.590 --> 00:31:51.580
真的很棒，所以基本上

00:31:49.900 --> 00:31:53.710
如果你说好吧，我是

00:31:51.580 --> 00:31:55.900
处理这种情况，这是什么

00:31:53.710 --> 00:31:58.360
线程注意到它不再是

00:31:55.900 --> 00:32:00.730
公共游泳池，这是我们的四线游泳池

00:31:58.360 --> 00:32:02.740
刚创建就在这里

00:32:00.730 --> 00:32:04.510
我们现在确实在做，所以

00:32:02.740 --> 00:32:06.460
这是您可以编程方式之一

00:32:04.510 --> 00:32:08.680
控制关于此的书面意见

00:32:06.460 --> 00:32:10.750
你可以有不同的计算

00:32:08.680 --> 00:32:12.610
在任何给定时间执行，您可以

00:32:10.750 --> 00:32:15.040
量身定制这些计算的需求

00:32:12.610 --> 00:32:16.870
单独进行，没有一个全局设置

00:32:15.040 --> 00:32:18.790
您的应用程序才能真正起作用

00:32:16.870 --> 00:32:20.530
对你来说好取决于你

00:32:18.790 --> 00:32:22.750
努力做好，让我们走一点

00:32:20.530 --> 00:32:24.490
进一步讨论一些方法

00:32:22.750 --> 00:32:26.770
我们应该再次非常小心

00:32:24.490 --> 00:32:28.600
因为如果我们真的可以搞砸

00:32:26.770 --> 00:32:30.190
你不是很小心所以让我们切换

00:32:28.600 --> 00:32:32.410
齿轮稍微

00:32:30.190 --> 00:32:34.900
我想在这里有不同的问题

00:32:32.410 --> 00:32:37.180
更快地运行但并行时

00:32:34.900 --> 00:32:39.010
这样做可能并不是一件真正的好事

00:32:37.180 --> 00:32:40.450
了解这一点，我提到你

00:32:39.010 --> 00:32:42.610
必须非常小心

00:32:40.450 --> 00:32:44.290
线程来说明这一点允许

00:32:42.610 --> 00:32:46.060
我在这里输入一些代码， 

00:32:44.290 --> 00:32:48.520
我要去带一个

00:32:46.060 --> 00:32:50.230
在此处和此处的并发示例

00:32:48.520 --> 00:32:52.570
在这种情况下，我会继续说

00:32:50.230 --> 00:32:54.640
假设这是一个计算

00:32:52.570 --> 00:32:56.110
我想称呼为什么，我将要

00:32:54.640 --> 00:32:59.290
引入这个小的计算代码

00:32:56.110 --> 00:33:02.410
我在做的只是一个纯粹的例子

00:32:59.290 --> 00:33:04.840
调用计算时的简单示例

00:33:02.410 --> 00:33:07.180
打开多达四个循环并执行

00:33:04.840 --> 00:33:11.020
然后对其进行平方根运算

00:33:07.180 --> 00:33:12.850
当然在这里我总和找到

00:33:11.020 --> 00:33:14.980
所有这些的平方根之和

00:33:12.850 --> 00:33:16.870
简而言之，这是一种计算

00:33:14.980 --> 00:33:18.640
我只是在进行密集操作

00:33:16.870 --> 00:33:21.730
通过这些循环并运行

00:33:18.640 --> 00:33:23.320
如您所见，它们按顺序排列

00:33:21.730 --> 00:33:25.480
在这里，这几乎是一个

00:33:23.320 --> 00:33:26.710
顺序代码需要多少时间

00:33:25.480 --> 00:33:28.090
要跑去做

00:33:26.710 --> 00:33:30.340
工作，所以我要运行

00:33:28.090 --> 00:33:32.380
顺序代码，我不知道它是

00:33:30.340 --> 00:33:34.750
可能要花几秒钟才能运行

00:33:32.380 --> 00:33:36.159
我不希望它太长，这是

00:33:34.750 --> 00:33:37.840
会回来给我们结果

00:33:36.159 --> 00:33:39.309
最后，这样你就可以看到

00:33:37.840 --> 00:33:41.380
实际上需要一点时间

00:33:39.309 --> 00:33:43.450
是时候执行它了，但我想

00:33:41.380 --> 00:33:45.279
我想跑得更快

00:33:43.450 --> 00:33:47.559
忘了说时间，对此我表示歉意

00:33:45.279 --> 00:33:49.240
所以我现在要运行这个，但是我会

00:33:47.559 --> 00:33:50.529
不想等待它，但是当它是

00:33:49.240 --> 00:33:52.360
完成它会告诉我们多少时间

00:33:50.529 --> 00:33:54.610
在此期间，让我们

00:33:52.360 --> 00:33:56.950
并行运行它，所以我要去

00:33:54.610 --> 00:33:59.260
前面说在这里平行飞镖

00:33:56.950 --> 00:34:01.120
现在该怎么办

00:33:59.260 --> 00:34:03.370
要并行运行，但有多少

00:34:01.120 --> 00:34:05.559
线程数与

00:34:03.370 --> 00:34:07.809
在我的机器上学习课程，因为我正在使用

00:34:05.559 --> 00:34:09.730
默认设置，所以我们希望

00:34:07.809 --> 00:34:13.899
这将比顺序的要快

00:34:09.730 --> 00:34:15.909
运行实际上花费了大约13秒

00:34:13.899 --> 00:34:17.619
这就是大约13 14的意思

00:34:15.909 --> 00:34:19.419
请记住几秒钟

00:34:17.619 --> 00:34:21.700
所以我想继续进行

00:34:19.419 --> 00:34:23.619
现在平行运行，看看有多少时间

00:34:21.700 --> 00:34:25.869
现在要采取的措施是平行的

00:34:23.619 --> 00:34:27.669
多个线程会运行这个嘿

00:34:25.869 --> 00:34:30.339
请注意，我们在大约三分钟内完成了

00:34:27.669 --> 00:34:32.290
秒，而不是13秒

00:34:30.339 --> 00:34:34.990
说这很不错，因为我们做了

00:34:32.290 --> 00:34:38.109
它更快，但现在我要成为那个

00:34:34.990 --> 00:34:41.440
那个嫉妒的人我很抱歉

00:34:38.109 --> 00:34:45.429
需要更多这样的东西，所以我要运行这个

00:34:41.440 --> 00:34:47.770
用一千个线程配置为什么不我

00:34:45.429 --> 00:34:49.419
有能力创建线程，所以我

00:34:47.770 --> 00:34:52.030
继续创建这些线程

00:34:49.419 --> 00:34:53.440
毕竟我们走了三秒钟

00:34:52.030 --> 00:34:55.270
在这种情况下，它怎么说

00:34:53.440 --> 00:34:57.220
我忘了再做一次，所以我们会

00:34:55.270 --> 00:34:59.470
花点时间做些什么

00:34:57.220 --> 00:35:01.720
三秒钟后运行

00:34:59.470 --> 00:35:04.300
之前花了大约四个

00:35:01.720 --> 00:35:06.460
如您所见，实际上是几秒钟

00:35:04.300 --> 00:35:07.750
在这种情况下并没有花费更少的时间

00:35:06.460 --> 00:35:09.490
实际上花了更多时间

00:35:07.750 --> 00:35:12.010
我实际上已经在项目中

00:35:09.490 --> 00:35:13.869
顺序代码需要一个小时才能运行

00:35:12.010 --> 00:35:15.880
并行代码甚至没有完成

00:35:13.869 --> 00:35:17.920
我们从午餐回来，我们真的

00:35:15.880 --> 00:35:19.540
实际上吃了很长的午餐，所以

00:35:17.920 --> 00:35:21.430
关键是你真的可能搞砸了

00:35:19.540 --> 00:35:22.839
我们对此不小心的事情

00:35:21.430 --> 00:35:24.400
有控制的理由

00:35:22.839 --> 00:35:26.980
我想快速做的另一件事

00:35:24.400 --> 00:35:30.070
这里提到的是我们真的必须

00:35:26.980 --> 00:35:32.859
了解某些事情可能不会

00:35:30.070 --> 00:35:34.810
并行地支持我们，以便

00:35:32.859 --> 00:35:36.910
了解这一点，让我们稍微

00:35:34.810 --> 00:35:38.619
不同的例子，但在我进入之前

00:35:36.910 --> 00:35:39.880
这个例子让我们有点说话

00:35:38.619 --> 00:35:41.559
宽广地

00:35:39.880 --> 00:35:43.750
您需要先问几件事

00:35:41.559 --> 00:35:46.210
您将代码转换为并行

00:35:43.750 --> 00:35:48.940
第一个问题是你有很多吗

00:35:46.210 --> 00:35:51.099
真正要处理许多并行的数据是

00:35:48.940 --> 00:35:52.269
那样的话你有很多吗

00:35:51.099 --> 00:35:53.859
工作要做

00:35:52.269 --> 00:35:55.720
在这种情况下也许并行是一个答案

00:35:53.859 --> 00:35:57.940
想象你有两个孩子

00:35:55.720 --> 00:35:59.769
回家，你的糖快用完了

00:35:57.940 --> 00:36:01.839
所以你大声说嘿我在跑步

00:35:59.769 --> 00:36:04.630
从糖中取出一些糖

00:36:01.839 --> 00:36:06.819
邻居一个孩子出去得到那个

00:36:04.630 --> 00:36:09.069
你知道骑自行车，所以他可以

00:36:06.819 --> 00:36:11.529
他或她可以给邻居写信

00:36:09.069 --> 00:36:12.970
其他孩子跳篱笆吗

00:36:11.529 --> 00:36:14.950
哪个孩子会给你糖

00:36:12.970 --> 00:36:17.619
真的很快就跳了

00:36:14.950 --> 00:36:19.660
围栏显然是因为邻居

00:36:17.619 --> 00:36:22.000
只是对面的邻居

00:36:19.660 --> 00:36:24.039
栅栏，你不必经历很多

00:36:22.000 --> 00:36:27.339
努力到达那儿跳过篱笆

00:36:24.039 --> 00:36:29.619
另一方面，你说我真的

00:36:27.339 --> 00:36:32.440
需要一袋米去商店或

00:36:29.619 --> 00:36:34.000
五公里远，好起来一

00:36:32.440 --> 00:36:36.339
孩子跳栅栏，另一个人带

00:36:34.000 --> 00:36:37.630
自行车跳的

00:36:36.339 --> 00:36:38.140
栅栏可能最终会在

00:36:37.630 --> 00:36:39.910
监狱

00:36:38.140 --> 00:36:41.890
所以你不想要那种行为

00:36:39.910 --> 00:36:44.049
在这一点上，所以你真的必须问

00:36:41.890 --> 00:36:45.880
这个问题我有多远

00:36:44.049 --> 00:36:48.369
涵盖我正在处理多少数据

00:36:45.880 --> 00:36:50.440
任务的强度是多少

00:36:48.369 --> 00:36:52.329
一直以我为基准哦

00:36:50.440 --> 00:36:54.369
永远不要相信别人的基准

00:36:52.329 --> 00:36:56.500
创建它一定是我要做的事情

00:36:54.369 --> 00:36:58.210
我的项目以及相关信息

00:36:56.500 --> 00:36:59.740
在我的团队中，这是其中之一

00:36:58.210 --> 00:37:01.390
我从来不相信任何人的原因是

00:36:59.740 --> 00:37:03.670
一个基准，包括我自己的基准

00:37:01.390 --> 00:37:05.710
当我在项目状态之间切换时

00:37:03.670 --> 00:37:07.240
所以你必须真的尝试一下看看

00:37:05.710 --> 00:37:09.339
如果有道理但话虽如此

00:37:07.240 --> 00:37:11.470
让我再举一个我想要的例子

00:37:09.339 --> 00:37:13.750
快速指出我想带的

00:37:11.470 --> 00:37:16.299
举个例子，说工作

00:37:13.750 --> 00:37:18.880
与一群人，所以在这个

00:37:16.299 --> 00:37:21.250
我想在这里做的事就是

00:37:18.880 --> 00:37:24.759
拿这个创造人们来说

00:37:21.250 --> 00:37:26.650
假设创建人员列表超过

00:37:24.759 --> 00:37:28.480
在这里，我有一堆人

00:37:26.650 --> 00:37:31.359
手和不同的名字不同

00:37:28.480 --> 00:37:33.700
性别和年龄不同，但我

00:37:31.359 --> 00:37:36.789
我想在这里做的是以下我想要的

00:37:33.700 --> 00:37:38.710
在这里说给一个人一个街

00:37:36.789 --> 00:37:41.500
集合，所以我们说创造人我

00:37:38.710 --> 00:37:44.680
想说飞镖流然后我会说

00:37:41.500 --> 00:37:48.460
给人一个过滤器，让我得到这个人

00:37:44.680 --> 00:37:52.030
 dart让我们说年龄大于

00:37:48.460 --> 00:37:55.270
 25好，我想要一个年长的人

00:37:52.030 --> 00:37:58.030
 25然后我会说过滤人和我

00:37:55.270 --> 00:38:00.850
会说人点变得性别，我会

00:37:58.030 --> 00:38:03.700
说在这种情况下性别飞镖女和

00:38:00.850 --> 00:38:06.340
那我说点地图给一个人

00:38:03.700 --> 00:38:08.590
给我取名字的人

00:38:06.340 --> 00:38:11.200
这个人，如果你愿意，然后最后

00:38:08.590 --> 00:38:12.970
我要在这里说的是你

00:38:11.200 --> 00:38:15.190
知道也许将其转换为大写

00:38:12.970 --> 00:38:16.060
让我们继续说

00:38:15.190 --> 00:38:18.910
大写

00:38:16.060 --> 00:38:20.950
所以在这种情况下我当然有

00:38:18.910 --> 00:38:23.590
完成是我已经采取了第一人称

00:38:20.950 --> 00:38:25.630
 25岁以上的女性

00:38:23.590 --> 00:38:29.140
命名并转换第一个大写

00:38:25.630 --> 00:38:31.420
但最后我说先找到

00:38:29.140 --> 00:38:33.970
我想知道我要找到谁

00:38:31.420 --> 00:38:37.180
真的，然后我们当然会

00:38:33.970 --> 00:38:39.040
说找不到人，所以我只想打印

00:38:37.180 --> 00:38:41.500
看看输出是什么样子

00:38:39.040 --> 00:38:43.210
在这种情况下，让我们输出

00:38:41.500 --> 00:38:45.610
就在这里，看看我们得到了什么

00:38:43.210 --> 00:38:47.530
所以在这个例子中我

00:38:45.610 --> 00:38:48.340
要四舍五入这个小代码，它说

00:38:47.530 --> 00:38:50.530
保罗

00:38:48.340 --> 00:38:51.550
好吧，那是Paulo，因为如果你去

00:38:50.530 --> 00:38:54.580
通过列表是有序的

00:38:51.550 --> 00:38:57.250
收集和塞拉和撒拉不是

00:38:54.580 --> 00:38:59.170
比鲍勃（Bob）年龄大25岁

00:38:57.250 --> 00:39:01.030
第一个年龄超过25岁的人

00:38:59.170 --> 00:39:03.400
也是女性，所以我们得到了，但

00:39:01.030 --> 00:39:04.810
问题是我们要做的是

00:39:03.400 --> 00:39:06.580
再过一分钟再说

00:39:04.810 --> 00:39:09.010
但是让我们回去运行比分

00:39:06.580 --> 00:39:11.110
好几次好快

00:39:09.010 --> 00:39:11.890
在这里，让我们继续说“运行飞镖SH” 

00:39:11.110 --> 00:39:13.990
就一次

00:39:11.890 --> 00:39:16.750
它说Paulo但我要运行这个

00:39:13.990 --> 00:39:18.580
很多很多很多次，所以我们在这里去

00:39:16.750 --> 00:39:20.470
我要继续运行这个，你知道

00:39:18.580 --> 00:39:22.300
几次，所以我可以保持

00:39:20.470 --> 00:39:24.400
在这里走了好几次

00:39:22.300 --> 00:39:26.170
我说全部运行，这将

00:39:24.400 --> 00:39:27.760
反复保罗是不是

00:39:26.170 --> 00:39:29.560
不管我跑步多少次，我都知道

00:39:27.760 --> 00:39:31.120
运行它，这不是它的证明

00:39:29.560 --> 00:39:33.520
但只要相信我，一切都会一样

00:39:31.120 --> 00:39:35.410
运行多次，但在

00:39:33.520 --> 00:39:37.090
另一方面还有一个功能

00:39:35.410 --> 00:39:39.850
叫找到任何

00:39:37.090 --> 00:39:42.340
会发现什么说我不在乎谁

00:39:39.850 --> 00:39:43.990
只是找到其中之一而已

00:39:42.340 --> 00:39:46.060
如果有的话，任何人都会给我们一个

00:39:43.990 --> 00:39:48.250
可用，所以在这种情况下，我回去时

00:39:46.060 --> 00:39:50.470
并运行这个我会得到什么

00:39:48.250 --> 00:39:52.900
原来是Paulo-为什么不公平

00:39:50.470 --> 00:39:55.360
因为它是按顺序执行的II 

00:39:52.900 --> 00:39:57.430
它是因为它是第一个顺序的

00:39:55.360 --> 00:39:59.380
总是在那里也好吧

00:39:57.430 --> 00:40:02.260
这很容易看到，但让我们开始吧

00:39:59.380 --> 00:40:04.900
退回现在放回去，先找到

00:40:02.260 --> 00:40:05.700
再一次，但在这种情况下，我要转身

00:40:04.900 --> 00:40:08.309
这个在

00:40:05.700 --> 00:40:10.710
黑暗平行好怎么办

00:40:08.309 --> 00:40:13.049
现在发生，记住这是有序的

00:40:10.710 --> 00:40:15.720
收藏，还记得我们谈论过

00:40:13.049 --> 00:40:17.670
某些方法在

00:40:15.720 --> 00:40:18.869
过去记得我们谈论过

00:40:17.670 --> 00:40:21.540
每个命令

00:40:18.869 --> 00:40:23.640
很好，首先是那些家伙之一

00:40:21.540 --> 00:40:25.140
没有名称顺序，但

00:40:23.640 --> 00:40:27.089
它会在

00:40:25.140 --> 00:40:29.280
非常结束，所以您将在其中执行此操作

00:40:27.089 --> 00:40:31.650
并行很棒但不幸的是

00:40:29.280 --> 00:40:33.089
尽管您将并行执行此操作

00:40:31.650 --> 00:40:35.849
很棒，但是你会怎么做

00:40:33.089 --> 00:40:37.589
得到你会一直得到Paulo 

00:40:35.849 --> 00:40:39.990
你最好做对，因为你想要

00:40:37.589 --> 00:40:41.730
首先，订购对

00:40:39.990 --> 00:40:43.500
你让我们看看那是真的吧

00:40:41.730 --> 00:40:45.540
继续并运行它，看看是Paulo 

00:40:43.500 --> 00:40:47.460
再一次不是

00:40:45.540 --> 00:40:49.109
证明只是因为我跑了70次

00:40:47.460 --> 00:40:51.569
并不代表再次正确，请相信我

00:40:49.109 --> 00:40:53.910
在这个搜索上，但是如果我

00:40:51.569 --> 00:40:55.980
把这个变成另一个

00:40:53.910 --> 00:40:58.650
立即运行并运行此代码

00:40:55.980 --> 00:40:59.790
好吧，这次通知它仍然是Paulo 

00:40:58.650 --> 00:41:02.430
但我希望情况会有所不同

00:40:59.790 --> 00:41:04.140
有时候好吧，这对我不利

00:41:02.430 --> 00:41:06.089
是这是这的危险

00:41:04.140 --> 00:41:07.950
演示不是吗，但希望有一些演示

00:41:06.089 --> 00:41:11.250
点，您将运行足够数量的

00:41:07.950 --> 00:41:19.040
好的，所以再次相信我

00:41:11.250 --> 00:41:19.040
一个太正确了，那是什么

00:41:21.390 --> 00:41:27.660
哦，这是肯定的答案

00:41:25.769 --> 00:41:28.499
你说的很好，知道了

00:41:27.660 --> 00:41:38.099
没有别的脚

00:41:28.499 --> 00:41:41.130
我怪你了好吧，谢谢

00:41:38.099 --> 00:41:43.559
让它如您所愿让我们说哦

00:41:41.130 --> 00:41:46.559
 Jill什么是Jill Jill我的朋友让我们

00:41:43.559 --> 00:41:49.410
只是让吉尔变老就好，所以我们去了

00:41:46.559 --> 00:41:51.839
所以可以再尝试一次

00:41:49.410 --> 00:41:54.150
时间我什至没有注意到好

00:41:51.839 --> 00:41:57.059
好猫，你去那里，谢谢大家

00:41:54.150 --> 00:41:59.700
是的，谢谢您的调试

00:41:57.059 --> 00:42:02.190
我对付费编程的信念是

00:41:59.700 --> 00:42:03.630
刚好恢复就好了

00:42:02.190 --> 00:42:05.609
我们得到了正确的结果

00:42:03.630 --> 00:42:07.799
是的，但是如果我回到这个问题上

00:42:05.609 --> 00:42:10.799
并说这会很好的

00:42:07.799 --> 00:42:12.299
另一方面，你会的

00:42:10.799 --> 00:42:14.519
这次最好擦亮

00:42:12.299 --> 00:42:16.170
对，所以在这种情况下，当然

00:42:14.519 --> 00:42:19.349
每次完全相同的值

00:42:16.170 --> 00:42:23.779
到目前为止，你和我在一起，但是有一个

00:42:19.349 --> 00:42:26.940
我喜欢溪流的一件事是

00:42:23.779 --> 00:42:28.799
懒惰好吧，让我们谈谈真正的

00:42:26.940 --> 00:42:31.410
快速，让我们继续删除它

00:42:28.799 --> 00:42:33.749
并行一分钟，让我们做的很好

00:42:31.410 --> 00:42:35.519
首先，如果您愿意，我想知道谁

00:42:33.749 --> 00:42:37.980
我要说的就是我们的吉尔

00:42:35.519 --> 00:42:40.980
刚长大，但我们有宝拉

00:42:37.980 --> 00:42:42.930
年龄超过30至25岁，但我是谁

00:42:40.980 --> 00:42:45.450
如果我去的话，要反复交谈

00:42:42.930 --> 00:42:48.029
门口的人班

00:42:45.450 --> 00:42:50.940
我要在这里打印的年龄

00:42:48.029 --> 00:42:53.460
不好意思长大的时候会说名字

00:42:50.940 --> 00:42:56.309
然后加上名称，然后当然

00:42:53.460 --> 00:42:58.349
我也要出名，我

00:42:56.309 --> 00:43:00.839
在这种情况下我也要输出

00:42:58.349 --> 00:43:02.249
我也想要性别，不是吗

00:43:00.839 --> 00:43:04.440
我要去问那个

00:43:02.249 --> 00:43:05.759
也要在这里打印，所以我去

00:43:04.440 --> 00:43:08.220
向前说这将成为现实

00:43:05.759 --> 00:43:10.200
性别并打印该信息就可以了

00:43:08.220 --> 00:43:13.170
到目前为止很好，我正在做两个

00:43:10.200 --> 00:43:14.819
如您在此处看到的顺序e 

00:43:13.170 --> 00:43:16.799
我将继续运行此代码，然后

00:43:14.819 --> 00:43:18.779
我会做一次的美丽

00:43:16.799 --> 00:43:20.970
我要按顺序运行此代码， 

00:43:18.779 --> 00:43:23.549
如您所料，它没有碰到

00:43:20.970 --> 00:43:26.099
除了宝拉之后，其他任何人都说得通

00:43:23.549 --> 00:43:28.200
对，因为它很懒，它说我不

00:43:26.099 --> 00:43:30.989
需要快速运行，我只是

00:43:28.200 --> 00:43:33.690
哦，今天我得到了Sara Bob Paula 

00:43:30.989 --> 00:43:35.160
我的结果是我永远不必与任何人交谈

00:43:33.690 --> 00:43:37.440
除了宝拉

00:43:35.160 --> 00:43:40.680
永远不会碰到Paul Jack Jack和Jill 

00:43:37.440 --> 00:43:44.280
另一方面，我要进去说一个

00:43:40.680 --> 00:43:47.160
点平行现在是什么

00:43:44.280 --> 00:43:48.900
要做它说哇看这个

00:43:47.160 --> 00:43:51.000
让我们开始获取数据的业务

00:43:48.900 --> 00:43:54.120
我们前面要做工作，它将成为

00:43:51.000 --> 00:43:56.360
着火了吗，结果是什么

00:43:54.120 --> 00:43:59.940
结果将在最后

00:43:56.360 --> 00:44:02.640
仍然是宝拉，但事实并非如此

00:43:59.940 --> 00:44:05.490
像我们认为的那样懒惰

00:44:02.640 --> 00:44:06.960
注意到还有很多工作要做

00:44:05.490 --> 00:44:09.180
总结一下

00:44:06.960 --> 00:44:11.970
举例来说，我刚上吊

00:44:09.180 --> 00:44:15.360
在这里，我正在四处走动

00:44:11.970 --> 00:44:17.340
汤姆·托马斯先生，你叫什么名字，我让

00:44:15.360 --> 00:44:20.040
说我把手机留在托马斯旁边

00:44:17.340 --> 00:44:21.900
所以这就是我能说的

00:44:20.040 --> 00:44:23.640
对不起，我是你旁边的手机，他

00:44:21.900 --> 00:44:25.590
说不对不起，我在手机x2中说

00:44:23.640 --> 00:44:28.320
不，我的手机在你旁边吗

00:44:25.590 --> 00:44:31.020
谢谢你，他说是的，那么多少

00:44:28.320 --> 00:44:33.960
我曾经拿过三个单位多少钱

00:44:31.020 --> 00:44:36.720
我花了三个时间单位

00:44:33.960 --> 00:44:38.340
那之后我拿了电话，但是那

00:44:36.720 --> 00:44:40.350
需要更多的努力

00:44:38.340 --> 00:44:42.900
我可以做的其他事

00:44:40.350 --> 00:44:44.010
只是说进入这个房间，说人们

00:44:42.900 --> 00:44:46.680
请帮我一个忙

00:44:44.010 --> 00:44:47.940
这是我旁边的手机多少钱

00:44:46.680 --> 00:44:51.210
我要花些时间

00:44:47.940 --> 00:44:54.660
结果一个时间单位有多少人

00:44:51.210 --> 00:44:57.540
我打扰了数百个人，所以

00:44:54.660 --> 00:45:00.540
好消息，我更快地得到了结果

00:44:57.540 --> 00:45:04.230
坏消息我困扰所有人

00:45:00.540 --> 00:45:06.390
不在乎，这就是这个的美丽

00:45:04.230 --> 00:45:09.240
所以这是这里的模型

00:45:06.390 --> 00:45:12.300
这里的模型是我不介意抛出更多

00:45:09.240 --> 00:45:14.550
硬件在这个问题上有希望

00:45:12.300 --> 00:45:15.950
更快获得结果的希望

00:45:14.550 --> 00:45:20.770
很有用，谢谢

00:45:15.950 --> 00:45:20.770
 [掌声] 

