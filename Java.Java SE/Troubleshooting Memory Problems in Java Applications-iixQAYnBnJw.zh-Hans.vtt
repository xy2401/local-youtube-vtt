WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.110 --> 00:00:09.380
好的，你好，欢迎光临，我是维尼

00:00:06.799 --> 00:00:11.919
我在JVM中工作的人数占一半

00:00:09.380 --> 00:00:14.990
甲骨文公司的可持续工程团队

00:00:11.919 --> 00:00:17.060
绅士在这里问你知道什么

00:00:14.990 --> 00:00:18.140
 JVM维护工程师

00:00:17.060 --> 00:00:22.100
有趣的标题

00:00:18.140 --> 00:00:25.010
有趣的标题，使JVM得以维持

00:00:22.100 --> 00:00:27.650
在Oracle中作为一个团队进行工程设计

00:00:25.010 --> 00:00:29.900
我们非常努力地解决

00:00:27.650 --> 00:00:34.190
客户针对的问题升级

00:00:29.900 --> 00:00:38.000
热点JVM，所以这里有一些关于

00:00:34.190 --> 00:00:39.950
我是Java一书的合著者

00:00:38.000 --> 00:00:43.070
我去过的表演伙伴

00:00:39.950 --> 00:00:46.460
在Java上讲了两次

00:00:43.070 --> 00:00:49.460
多年，我去过Java的摇滚明星

00:00:46.460 --> 00:00:53.149
在其他Java大会上发言

00:00:49.460 --> 00:00:56.630
好吧，我在此链接上维护一个博客

00:00:53.149 --> 00:01:00.470
我发表了许多关于

00:00:56.630 --> 00:01:06.229
如何解决热点问题

00:01:00.470 --> 00:01:09.640
 JVM，好的，你们有多少人

00:01:06.229 --> 00:01:13.940
看到此内存不足错误异常

00:01:09.640 --> 00:01:17.390
大家还好，所以你在对的地方

00:01:13.940 --> 00:01:20.390
房间，所以只要我们看到此异常

00:01:17.390 --> 00:01:22.820
你知道我们有点害怕哦

00:01:20.390 --> 00:01:25.159
意味着有某种记忆

00:01:22.820 --> 00:01:27.790
与我的应用程序相关的问题

00:01:25.159 --> 00:01:30.380
我将不得不日日夜夜

00:01:27.790 --> 00:01:32.479
找出我的问题是什么

00:01:30.380 --> 00:01:34.189
应用程序，您知道为什么会出现此异常

00:01:32.479 --> 00:01:37.490
正在发生，所以这有点

00:01:34.189 --> 00:01:41.630
有相关的症状

00:01:37.490 --> 00:01:44.150
记住那是你的记忆

00:01:41.630 --> 00:01:47.270
这与应用程序不正确

00:01:44.150 --> 00:01:50.350
所以不仅仅是内存不足错误

00:01:47.270 --> 00:01:54.080
例外还有其他症状

00:01:50.350 --> 00:01:56.140
由于我们的内存意外增长

00:01:54.080 --> 00:02:00.920
应用或不良应用

00:01:56.140 --> 00:02:03.380
性能表明

00:02:00.920 --> 00:02:06.070
我们的应用程序正在努力

00:02:03.380 --> 00:02:09.920
内存问题，我们应该

00:02:06.070 --> 00:02:12.860
调查，并经常这些

00:02:09.920 --> 00:02:15.690
症状与GC活动有关

00:02:12.860 --> 00:02:18.210
在Java应用程序中

00:02:15.690 --> 00:02:21.200
而你所知道的可以通过

00:02:18.210 --> 00:02:24.600
查看GC日志或监视我们的

00:02:21.200 --> 00:02:27.330
应用程序并在那里进行验证

00:02:24.600 --> 00:02:30.090
是否有长时间的GC暂停是他们的

00:02:27.330 --> 00:02:32.820
过多的GCS和我的申请

00:02:30.090 --> 00:02:35.520
可能是由于错过

00:02:32.820 --> 00:02:38.070
内存池配置过多

00:02:35.520 --> 00:02:41.070
使用最终错误的显式GC 

00:02:38.070 --> 00:02:43.440
调用甚至内存泄漏

00:02:41.070 --> 00:02:45.920
应用程序，因此在本节中我们的目标

00:02:43.440 --> 00:02:49.980
是了解我们如何去做

00:02:45.920 --> 00:02:53.490
从特定的症状或行为

00:02:49.980 --> 00:02:56.370
行为及其对我们的应用

00:02:53.490 --> 00:03:00.420
底盒是什么原因造成的

00:02:56.370 --> 00:03:02.640
我们的应用程序中的症状是什么

00:03:00.420 --> 00:03:05.700
议程看起来就像我们要谈论的

00:03:02.640 --> 00:03:08.310
关于与Java有关的内存问题

00:03:05.700 --> 00:03:12.420
永久生成元空间代码

00:03:08.310 --> 00:03:14.610
缓存本机内存和您所知道的

00:03:12.420 --> 00:03:16.620
是什么导致了这些问题，以及如何做

00:03:14.610 --> 00:03:19.470
我们对它们进行故障排除，我们还将采取

00:03:16.620 --> 00:03:23.820
查看与内存不足相关的问题

00:03:19.470 --> 00:03:28.739
最终确定，以便Java堆内存

00:03:23.820 --> 00:03:32.730
问题，当我们看着那些

00:03:28.739 --> 00:03:34.650
你知道的症状相当

00:03:32.730 --> 00:03:37.230
而不是仅仅得出结论

00:03:34.650 --> 00:03:39.150
我所有的应用程序都有内存

00:03:37.230 --> 00:03:41.100
泄漏，因为我在那里看到那些症状

00:03:39.150 --> 00:03:43.530
出现意外的内存增长

00:03:41.100 --> 00:03:45.480
糟糕的应用程序性能

00:03:43.530 --> 00:03:48.510
或我的应用失败

00:03:45.480 --> 00:03:50.610
之前做的内存错误

00:03:48.510 --> 00:03:52.680
得出结论认为

00:03:50.610 --> 00:03:55.080
我们首先应该确认内存泄漏

00:03:52.680 --> 00:03:57.810
是否有内存泄漏，我们应该

00:03:55.080 --> 00:04:00.000
随时间监视我们的Java堆使用情况

00:03:57.810 --> 00:04:02.070
在此期间发生了完整的G C 

00:04:00.000 --> 00:04:05.820
应用程序的运行时

00:04:02.070 --> 00:04:09.450
那些富士C能够要求回收

00:04:05.820 --> 00:04:11.790
 Java的老一代中的空间

00:04:09.450 --> 00:04:14.489
如果不是，那就堆

00:04:11.790 --> 00:04:17.070
只是配置问题，我们的Java堆

00:04:14.489 --> 00:04:20.220
尺寸可能未正确配置

00:04:17.070 --> 00:04:22.650
它的大小可能太小，因此第一个

00:04:20.220 --> 00:04:26.470
步骤是增加堆大小测试

00:04:22.650 --> 00:04:30.040
再次申请，如果还有

00:04:26.470 --> 00:04:33.010
可以使

00:04:30.040 --> 00:04:35.140
然后在我们的流程中应用

00:04:33.010 --> 00:04:37.300
也许你知道有可能

00:04:35.140 --> 00:04:41.260
在内存泄漏

00:04:37.300 --> 00:04:44.710
应用程序，因此我们可以使用各种工具

00:04:41.260 --> 00:04:46.570
监视应用程序的堆使用情况

00:04:44.710 --> 00:04:49.090
例如，在这种情况下，这是J 

00:04:46.570 --> 00:04:52.120
控制台连接到实时应用程序

00:04:49.090 --> 00:04:54.490
并在此监视堆使用情况

00:04:52.120 --> 00:04:57.640
情况很明显，永久

00:04:54.490 --> 00:05:04.600
代住人数正在增长

00:04:57.640 --> 00:05:06.760
时间，如果不可能做生活

00:05:04.600 --> 00:05:09.700
我们可以监控应用程序

00:05:06.760 --> 00:05:13.630
收集GC日志，我们可以对其进行分析

00:05:09.700 --> 00:05:17.680
这些GC日志以查看堆是什么

00:05:13.630 --> 00:05:22.120
您知道我们应用程序的用途吗

00:05:17.680 --> 00:05:25.510
尺寸合适吗？ 

00:05:22.120 --> 00:05:28.330
足够大吗？ 

00:05:25.510 --> 00:05:31.150
例如我们的应用程序的数据集

00:05:28.330 --> 00:05:34.420
在这种情况下，您可以从GC日志中看到

00:05:31.150 --> 00:05:38.590
即使在完全GCS之后，堆使用情况

00:05:34.420 --> 00:05:41.260
持续增长，所以我们选择

00:05:38.590 --> 00:05:45.730
应该使用适当的大小

00:05:41.260 --> 00:05:49.840
我们的Java堆是-X MX，它设置了

00:05:45.730 --> 00:05:53.140
 Java堆的最大堆大小，以及

00:05:49.840 --> 00:05:55.840
我们建议将此值设置为等于

00:05:53.140 --> 00:06:01.990
负X ms的值，用于设置

00:05:55.840 --> 00:06:03.970
 Java堆的初始值，所以在那里

00:06:01.990 --> 00:06:07.090
是排除任何故障的三个步骤

00:06:03.970 --> 00:06:09.250
你知道的问题明白什么

00:06:07.090 --> 00:06:12.250
问题是在这种情况下

00:06:09.250 --> 00:06:14.680
我们正在看内存不足或

00:06:12.250 --> 00:06:17.650
 Java堆的内存相关问题

00:06:14.680 --> 00:06:21.190
第二步是深入了解

00:06:17.650 --> 00:06:22.840
从中收集诊断数据的问题

00:06:21.190 --> 00:06:25.150
系统，第三步是

00:06:22.840 --> 00:06:27.640
分析该数据以了解为什么

00:06:25.150 --> 00:06:31.600
问题发生了，找到

00:06:27.640 --> 00:06:34.060
解决方案，所以让我们继续下一步

00:06:31.600 --> 00:06:35.560
诊断数据的收集

00:06:34.060 --> 00:06:39.430
我们应该收集的诊断数据

00:06:35.560 --> 00:06:41.070
解决与Java堆相关的问题

00:06:39.430 --> 00:06:44.380
记忆问题

00:06:41.070 --> 00:06:47.530
到目前为止，与Java堆相关

00:06:44.380 --> 00:06:51.040
我们应该收集GC的内存问题

00:06:47.530 --> 00:06:53.860
记录堆转储堆直方图，所以让我们

00:06:51.040 --> 00:06:57.310
看一看你所知道的详细

00:06:53.860 --> 00:07:00.520
一个我们如何使用哪些工具

00:06:57.310 --> 00:07:02.500
收集这些数据以及每个数据如何

00:07:00.520 --> 00:07:05.320
每个诊断数据都可以帮助我们

00:07:02.500 --> 00:07:06.910
故障排除GC锁，它们非常

00:07:05.320 --> 00:07:10.540
有助于确定堆

00:07:06.910 --> 00:07:13.450
要求他们告诉我们什么是

00:07:10.540 --> 00:07:14.680
你知道合适的Java大小

00:07:13.450 --> 00:07:17.620
堆

00:07:14.680 --> 00:07:20.020
他们告诉我们是否有过多的GCS 

00:07:17.620 --> 00:07:24.340
或者如果有很长的GC暂停

00:07:20.020 --> 00:07:26.290
应用程序执行这些是GC 

00:07:24.340 --> 00:07:31.180
日志记录选项，可用于

00:07:26.290 --> 00:07:36.520
收集我们可以使用的Java 9的GC日志

00:07:31.180 --> 00:07:40.030
我的新JVM选项减去X log GC即可

00:07:36.520 --> 00:07:43.600
收集GC日志，您知道这些

00:07:40.030 --> 00:07:46.630
前两行告诉我们GC 

00:07:43.600 --> 00:07:48.850
 G 1和非1使用的日志选项

00:07:46.630 --> 00:07:50.889
 G 1收集器和以前的Java 

00:07:48.850 --> 00:07:53.710
我们可以使用打印GC详细信息的版本

00:07:50.889 --> 00:07:56.380
打印GC时间戳，日期戳和

00:07:53.710 --> 00:07:58.810
减X log GC，这些选项不是

00:07:56.380 --> 00:08:01.599
在Jellico 9中可用，他们已经

00:07:58.810 --> 00:08:03.849
你知道你会看到一个警告

00:08:01.599 --> 00:08:08.160
这些已过时，但内部

00:08:03.849 --> 00:08:10.720
使用减X日志选项映射到

00:08:08.160 --> 00:08:15.070
所以在这个例子中我们可以看到

00:08:10.720 --> 00:08:18.940
从GC日志中，我们可以看到堆使用情况

00:08:15.070 --> 00:08:22.060
这个例子有一个完整的GC，它

00:08:18.940 --> 00:08:25.599
无法收集任何备用

00:08:22.060 --> 00:08:28.450
你知道它无法释放任何

00:08:25.599 --> 00:08:30.520
世代相传的空间

00:08:28.450 --> 00:08:33.240
大概老一代不大

00:08:30.520 --> 00:08:38.320
足以保存数据或保存实时数据

00:08:33.240 --> 00:08:40.690
我们的应用程序GC日志的数据集

00:08:38.320 --> 00:08:42.580
可以告诉我们是否有过多的G C 

00:08:40.690 --> 00:08:45.520
在这种情况下，背靠背

00:08:42.580 --> 00:08:49.829
您知道影响的频繁完整GC 

00:08:45.520 --> 00:08:52.720
应用程序性能很差

00:08:49.829 --> 00:08:53.920
 GC岩石可以告诉我们是否有很长的时间

00:08:52.720 --> 00:08:55.600
 GC暂停

00:08:53.920 --> 00:08:59.500
在这种情况下，有一个完整的GC 

00:08:55.600 --> 00:09:02.350
花费50秒的时间

00:08:59.500 --> 00:09:04.450
很长一段时间，所以我们应该调查并

00:09:02.350 --> 00:09:07.720
找出为什么这些长抄送是

00:09:04.450 --> 00:09:10.680
发生以及如何避免全G 

00:09:07.720 --> 00:09:12.940
调味我们的应用程序，以便下一个

00:09:10.680 --> 00:09:15.389
诊断数据最多

00:09:12.940 --> 00:09:18.160
重要的诊断数据

00:09:15.389 --> 00:09:21.070
解决与内存相关的问题是

00:09:18.160 --> 00:09:24.820
可以使用J收集堆转储

00:09:21.070 --> 00:09:27.100
命令J map J控制台Java任务

00:09:24.820 --> 00:09:29.709
控制，还有一个选择，他

00:09:27.100 --> 00:09:32.949
泵出内存不足错误是你

00:09:29.709 --> 00:09:35.230
知道很方便，因为你有这个

00:09:32.949 --> 00:09:38.290
在启动Java时就位

00:09:35.230 --> 00:09:40.449
申请，如果您的

00:09:38.290 --> 00:09:43.060
应用程序失败，内存不足

00:09:40.449 --> 00:09:46.329
错误，您将有可用的堆转储

00:09:43.060 --> 00:09:49.180
和您一起来解决问题

00:09:46.329 --> 00:09:52.089
你知道为什么你的申请失败了

00:09:49.180 --> 00:09:54.579
有内存不足错误，所以在此

00:09:52.089 --> 00:09:57.279
快照，希望您能清楚看到

00:09:54.579 --> 00:10:03.040
后面，这是J控制台显示

00:09:57.279 --> 00:10:05.470
在这种情况下有n个豆子很热

00:10:03.040 --> 00:10:09.040
现场诊断M Bean，它具有

00:10:05.470 --> 00:10:13.120
使用该操作的操作转储堆

00:10:09.040 --> 00:10:17.140
我们可以从现场收集堆转储

00:10:13.120 --> 00:10:19.600
运行应用程序，因此此屏幕截图

00:10:17.140 --> 00:10:21.790
通过Java显示Java任务控制

00:10:19.600 --> 00:10:25.050
任务控制也是可能的

00:10:21.790 --> 00:10:28.420
再次收集堆转储有两个

00:10:25.050 --> 00:10:30.370
是豆类热点诊断和

00:10:28.420 --> 00:10:32.920
使用他们的诊断命令

00:10:30.370 --> 00:10:36.010
在这种情况下的操作转储堆

00:10:32.920 --> 00:10:39.310
热点诊断操作和

00:10:36.010 --> 00:10:41.230
豆，我们可以收集堆转储，所以我

00:10:39.310 --> 00:10:43.779
提到有一个JVM选项堆

00:10:41.230 --> 00:10:47.680
转储出内存错误，可能是

00:10:43.779 --> 00:10:50.670
用于收集堆转储，以防在那里

00:10:47.680 --> 00:10:54.399
是JVM失败并显示内存不足错误

00:10:50.670 --> 00:10:56.649
所以在这里我们可以看到您知道

00:10:54.399 --> 00:10:58.300
在GC日志的左侧

00:10:56.649 --> 00:11:01.150
我们可以看到该应用程序是

00:10:58.300 --> 00:11:04.330
出现GC开销失败

00:11:01.150 --> 00:11:08.380
超出内存限制错误，并且

00:11:04.330 --> 00:11:12.130
在那之后，它正在创造

00:11:08.380 --> 00:11:14.560
堆转储，所以有方案

00:11:12.130 --> 00:11:19.000
你知道特别平行的地方

00:11:14.560 --> 00:11:23.200
收集器可以连续放入

00:11:19.000 --> 00:11:26.050
努力收集您知道或回收的

00:11:23.200 --> 00:11:28.210
 Java堆中甚至还有一些空间

00:11:26.050 --> 00:11:31.570
虽然那的回报非常

00:11:28.210 --> 00:11:33.940
最小，所以在这种情况下，您知道我们

00:11:31.570 --> 00:11:36.790
必须指示垃圾收集器

00:11:33.940 --> 00:11:40.840
你不知道不要投入那么多

00:11:36.790 --> 00:11:43.840
当收获是

00:11:40.840 --> 00:11:46.770
不重要，你应该退出出来

00:11:43.840 --> 00:11:50.680
它，你知道让应用程序

00:11:46.770 --> 00:11:53.290
停下或让如果有的话

00:11:50.680 --> 00:11:57.150
是托管的应用服务器吗

00:11:53.290 --> 00:12:00.880
应用程序让它自己重启

00:11:57.150 --> 00:12:03.250
在这种情况下，它实际上可能会延迟

00:12:00.880 --> 00:12:06.280
退出或重新启动应用程序

00:12:03.250 --> 00:12:10.690
并且延迟了堆转储的创建

00:12:06.280 --> 00:12:13.000
以及这样的延迟实际上可以

00:12:10.690 --> 00:12:16.540
对我们的性能有影响

00:12:13.000 --> 00:12:19.690
首先针对此类情况

00:12:16.540 --> 00:12:22.990
我们可以使用两个JVM选项GC时间限制

00:12:19.690 --> 00:12:25.060
和GC堆可用限制，因此GC时间限制

00:12:22.990 --> 00:12:28.690
设置数量上限

00:12:25.060 --> 00:12:32.590
 GCS可以花费的时间百分比

00:12:28.690 --> 00:12:35.740
总时间和GC堆可用限制设置程序

00:12:32.590 --> 00:12:37.840
下限的空间

00:12:35.740 --> 00:12:40.960
垃圾收集后应该免费

00:12:37.840 --> 00:12:43.600
因此GC时间限制的默认值为

00:12:40.960 --> 00:12:45.820
 GC默认值的98％ 

00:12:43.600 --> 00:12:49.450
堆可用限制为百分之二

00:12:45.820 --> 00:12:51.850
意味着如果垃圾收集是

00:12:49.450 --> 00:12:53.380
能够满足这两个条件

00:12:51.850 --> 00:12:56.290
你知道垃圾收集是

00:12:53.380 --> 00:12:58.600
允许占用高达98％的

00:12:56.290 --> 00:13:01.750
时间，如果至少有两个

00:12:58.600 --> 00:13:03.580
之后的可用堆空间百分比

00:13:01.750 --> 00:13:05.860
垃圾收集将

00:13:03.580 --> 00:13:07.510
继续他们他们不会退出你知道的

00:13:05.860 --> 00:13:13.060
将会有频繁的背靠背

00:13:07.510 --> 00:13:14.680
 GCS，因此我们可以调整这两个选项

00:13:13.060 --> 00:13:16.779
可以尝试

00:13:14.680 --> 00:13:20.140
 Cree的GC时间限制，我们可以尝试

00:13:16.779 --> 00:13:22.839
增加GC堆的可用限制，以便我们

00:13:20.140 --> 00:13:25.330
没有这个问题

00:13:22.839 --> 00:13:27.490
背靠背频繁的完整G C 

00:13:25.330 --> 00:13:30.490
贴花期望的情况

00:13:27.490 --> 00:13:33.730
申请退出而不是退出

00:13:30.490 --> 00:13:36.130
徘徊在那里，所以

00:13:33.730 --> 00:13:39.430
完整的GC后引发内存错误

00:13:36.130 --> 00:13:42.670
如果前五个连续的GCS是

00:13:39.430 --> 00:13:46.720
无法达到设定的值

00:13:42.670 --> 00:13:49.450
这两个JVM选项，所以接下来

00:13:46.720 --> 00:13:51.520
诊断数据是堆直方图

00:13:49.450 --> 00:13:54.310
格雷厄姆手枪快速浏览

00:13:51.520 --> 00:13:55.779
 Java堆中的对象，因此您没有

00:13:54.310 --> 00:13:57.640
您不必遵循两个步骤

00:13:55.779 --> 00:14:00.839
知道收集堆转储，然后分析

00:13:57.640 --> 00:14:04.690
他们使用一些工具，所以这些是

00:14:00.839 --> 00:14:07.510
你知道的文本输出在哪里可以

00:14:04.690 --> 00:14:11.050
快速查看哪些对象是哪种

00:14:07.510 --> 00:14:13.120
堆中的对象数量正在增长

00:14:11.050 --> 00:14:16.420
可以收集此堆直方图

00:14:13.120 --> 00:14:19.480
使用印刷类直方图J 

00:14:16.420 --> 00:14:23.589
命令J地图，并且有一个新工具J 

00:14:19.480 --> 00:14:26.640
将HSD添加到可以使用的jdk 9中

00:14:23.589 --> 00:14:29.800
从代码文件收集堆转储或

00:14:26.640 --> 00:14:31.839
以及无响应的流程，我们

00:14:29.800 --> 00:14:33.730
可以在Java中使用诊断命令

00:14:31.839 --> 00:14:36.100
任务控制收集堆

00:14:33.730 --> 00:14:39.670
直方图让我们在这里看一些例子

00:14:36.100 --> 00:14:44.430
我们可以在其中看到Java Mission Control 

00:14:39.670 --> 00:14:46.150
我们可以执行GC点类直方图

00:14:44.430 --> 00:14:49.300
运作

00:14:46.150 --> 00:14:52.660
你知道实时诊断命令

00:14:49.300 --> 00:14:54.970
收集堆直方图的过程及其

00:14:52.660 --> 00:14:59.770
在底部显示堆直方图

00:14:54.970 --> 00:15:02.050
 Java Mission Control的窗格，所以一旦我们

00:14:59.770 --> 00:15:04.300
收集了数据，我们有GC日志， 

00:15:02.050 --> 00:15:06.160
有堆条件，我们有直方图

00:15:04.300 --> 00:15:08.560
应该使用工具来分析

00:15:06.160 --> 00:15:12.550
数据看你知道什么样的

00:15:08.560 --> 00:15:15.579
我遇到GC日志的内存问题

00:15:12.550 --> 00:15:17.230
和GC日志分析，因此在GC日志中

00:15:15.579 --> 00:15:19.420
我们想要寻找什么我们想要

00:15:17.230 --> 00:15:22.060
看富士是否看得太多

00:15:19.420 --> 00:15:24.670
是那些G看到的

00:15:22.060 --> 00:15:26.920
那些停顿很长的时间

00:15:24.670 --> 00:15:29.110
发生得太频繁，我们可以做

00:15:26.920 --> 00:15:31.720
手动检查GC日志是

00:15:29.110 --> 00:15:34.590
有自动分析工具

00:15:31.720 --> 00:15:39.010
我们可以使用的可用信息

00:15:34.590 --> 00:15:40.630
了解发生了什么事

00:15:39.010 --> 00:15:44.170
我的记忆怎么了

00:15:40.630 --> 00:15:46.000
配置就是为什么这些GCS 

00:15:44.170 --> 00:15:50.290
发生得太频繁或为什么

00:15:46.000 --> 00:15:52.810
花费太多时间，所以这是一个

00:15:50.290 --> 00:15:56.170
如果我们看本周的GC查看器工具

00:15:52.810 --> 00:16:00.120
紧密地有GC暂停，您知道

00:15:56.170 --> 00:16:03.190
空间耗尽事件有两个

00:16:00.120 --> 00:16:06.580
完整的GCS集合

00:16:03.190 --> 00:16:10.030
每个人大概花了四秒钟

00:16:06.580 --> 00:16:12.670
不是每个人总花费了

00:16:10.030 --> 00:16:16.300
大约四秒钟，你知道吗

00:16:12.670 --> 00:16:19.600
长时间的等待响应和

00:16:16.300 --> 00:16:24.100
密集应用

00:16:19.600 --> 00:16:28.480
这样的情况，你知道这是一个这是一个

00:16:24.100 --> 00:16:31.180
 G个收集器和两个空间的GC日志

00:16:28.480 --> 00:16:34.030
用尽GC me DC的意思是

00:16:31.180 --> 00:16:37.750
旧空间不足

00:16:34.030 --> 00:16:41.140
促进对象从

00:16:37.750 --> 00:16:43.960
年轻的地区，所以里面就是这样

00:16:41.140 --> 00:16:47.170
场景，我们必须确保您知道

00:16:43.960 --> 00:16:49.750
我们旧地区的老一代

00:16:47.170 --> 00:16:52.180
调整年轻一代的大小

00:16:49.750 --> 00:16:56.020
有足够的空间

00:16:52.180 --> 00:16:56.890
老一辈，在g1中混合在一起

00:16:56.020 --> 00:17:00.160
馆藏

00:16:56.890 --> 00:17:02.110
你知道其中一些收藏

00:17:00.160 --> 00:17:04.600
的旧区域是沿着

00:17:02.110 --> 00:17:07.720
与年轻的地区，所以我们必须

00:17:04.600 --> 00:17:08.470
确保那些混合的GCS正在运行

00:17:07.720 --> 00:17:11.790
有效

00:17:08.470 --> 00:17:15.069
如果我们仔细观察，有一个选择

00:17:11.790 --> 00:17:17.770
你知道我们可以在底部

00:17:15.069 --> 00:17:21.670
看到初始占用率

00:17:17.770 --> 00:17:24.760
这是一个值，该值指示

00:17:21.670 --> 00:17:27.670
分数的同时标记周期

00:17:24.760 --> 00:17:31.030
 g1收集器应该开始进行准备

00:17:27.670 --> 00:17:33.760
老一代地区

00:17:31.030 --> 00:17:34.450
这样就可以将它们混合在一起

00:17:33.760 --> 00:17:37.840
地区

00:17:34.450 --> 00:17:42.549
你知道混合收藏是否

00:17:37.840 --> 00:17:46.090
没有旧的地区作为

00:17:42.549 --> 00:17:47.890
其中一部分旧数据无法获取

00:17:46.090 --> 00:17:49.960
收集了唯一具有

00:17:47.890 --> 00:17:52.450
更新了，已经转移到所有人

00:17:49.960 --> 00:17:55.150
一代人没有被收集，所以这里

00:17:52.450 --> 00:18:00.159
我们可以看到这个占用

00:17:55.150 --> 00:18:03.370
如果我们将分数设置为87％ 

00:18:00.159 --> 00:18:06.309
减少这个百分比，你会知道吗

00:18:03.370 --> 00:18:08.559
开始并发标记周期

00:18:06.309 --> 00:18:10.600
较早的g1收集器

00:18:08.559 --> 00:18:13.150
这将确保旧的

00:18:10.600 --> 00:18:15.250
地区准备好进行混合收集

00:18:13.150 --> 00:18:18.460
并会留出足够的空间

00:18:15.250 --> 00:18:24.190
代促销活动

00:18:18.460 --> 00:18:27.340
来自年轻地区的物品，所以接下来

00:18:24.190 --> 00:18:30.750
要寻找的是我们是否明确

00:18:27.340 --> 00:18:34.179
富士看到，因为明确的富士看到可以

00:18:30.750 --> 00:18:37.179
导致我们的应用程序长时间停顿，并且

00:18:34.179 --> 00:18:39.940
如果很容易在GC日志中发现它们

00:18:37.179 --> 00:18:42.820
您在GC中寻找系统优势

00:18:39.940 --> 00:18:46.090
日志条目，这意味着有

00:18:42.820 --> 00:18:48.730
显式完整GC正在调用这些

00:18:46.090 --> 00:18:52.929
显式完整GC可以使用调用

00:18:48.730 --> 00:18:57.970
系统点GC调用（如果使用的是RM I） 

00:18:52.929 --> 00:19:00.130
并且您知道RM I应用程序位于

00:18:57.970 --> 00:19:04.120
指定的特定间隔

00:19:00.130 --> 00:19:08.289
这些属性调用显式

00:19:04.120 --> 00:19:11.380
完整的GCS，如果需要，我们需要

00:19:08.289 --> 00:19:13.539
确保我们使用的诊断工具

00:19:11.380 --> 00:19:17.380
正在用于收集诊断数据

00:19:13.539 --> 00:19:19.690
他们不是你不知不觉中他们

00:19:17.380 --> 00:19:21.400
没有在我们的系统中调用完整的GCS 

00:19:19.690 --> 00:19:24.309
例如，如果我们有

00:19:21.400 --> 00:19:27.250
我们的选项打印类直方图

00:19:24.309 --> 00:19:29.020
启用了应用程序，如果我们生病了

00:19:27.250 --> 00:19:31.419
中断或秘密信号

00:19:29.020 --> 00:19:34.690
应用程序，它将调用完整的GC 

00:19:31.419 --> 00:19:38.169
在收集班级直方图之前或

00:19:34.690 --> 00:19:40.690
对象直方图

00:19:38.169 --> 00:19:43.389
我们必须注意的场景

00:19:40.690 --> 00:19:46.869
我们的应用程序没有

00:19:43.389 --> 00:19:49.149
显式完整GCS在那里被调用

00:19:46.869 --> 00:19:53.499
是一个选项，禁用显式GC 

00:19:49.149 --> 00:19:55.720
你知道完全禁用

00:19:53.499 --> 00:19:59.379
我们的显式GC调用

00:19:55.720 --> 00:20:02.229
应用程序，所以一旦我们有了堆转储

00:19:59.379 --> 00:20:04.299
收集了我们如何分析堆转储

00:20:02.229 --> 00:20:08.619
你知道很多工具

00:20:04.299 --> 00:20:11.799
可用于堆转储分析，直到

00:20:08.619 --> 00:20:14.109
在JDK 8中，我们拥有了Java虚拟机J ha 

00:20:11.799 --> 00:20:16.149
已从JDK 9中删除，但是您

00:20:14.109 --> 00:20:18.999
知道Java的开源项目

00:20:16.149 --> 00:20:21.369
如果以下情况，可视VM仍然可用

00:20:18.999 --> 00:20:23.799
您希望运行JDK 9应用程序

00:20:21.369 --> 00:20:26.440
你知道你是否想分析堆

00:20:23.799 --> 00:20:29.409
从您的JDK 9应用程序转储

00:20:26.440 --> 00:20:31.690
你还能使用Java visual vm吗

00:20:29.409 --> 00:20:33.970
而且有一个很好的日食

00:20:31.690 --> 00:20:36.639
社区开发的垫子

00:20:33.970 --> 00:20:39.489
开源工具，它知道

00:20:36.639 --> 00:20:42.479
惊人的功能，让您探索

00:20:39.489 --> 00:20:46.289
深入研究堆堆，看看

00:20:42.479 --> 00:20:52.809
什么可能会消耗您的内存

00:20:46.289 --> 00:20:55.389
堆所以在这里我有一个堆转储打开

00:20:52.809 --> 00:20:58.479
在这种情况下，我们可以看到

00:20:55.389 --> 00:21:01.149
字节数组的实例正在

00:20:58.479 --> 00:21:04.899
高达460兆字节

00:21:01.149 --> 00:21:07.749
我们可以在Eclipse遮罩中去

00:21:04.899 --> 00:21:10.450
看一下这个的实例

00:21:07.749 --> 00:21:13.029
字节数组，在这里我们可以看到一个模式

00:21:10.450 --> 00:21:16.599
你知道长度为一的字节数组

00:21:13.029 --> 00:21:19.029
零二四在那儿重复

00:21:16.599 --> 00:21:25.690
一零二的对象太多

00:21:19.029 --> 00:21:29.440
 eclipse mat中的四个长度的字节数组

00:21:25.690 --> 00:21:31.929
可以看到这些参考链

00:21:29.440 --> 00:21:35.169
反对他们的GC根

00:21:31.929 --> 00:21:37.570
 JVM中的根

00:21:35.169 --> 00:21:40.869
在这些对象上，哪些不是

00:21:37.570 --> 00:21:43.210
让他们被垃圾收集

00:21:40.869 --> 00:21:46.090
收集器，所以在这种情况下，我们可以看到

00:21:43.210 --> 00:21:49.089
有一个向量寿命长的物体

00:21:46.090 --> 00:21:51.519
在记忆里的李课，实际上

00:21:49.089 --> 00:21:54.280
负责坚持这些

00:21:51.519 --> 00:21:58.280
字节数组实例

00:21:54.280 --> 00:22:01.970
所以永久世代中期记忆

00:21:58.280 --> 00:22:04.250
问题，在这种情况下，就像我们一样

00:22:01.970 --> 00:22:06.470
用Java堆内存在Java堆中完成

00:22:04.250 --> 00:22:08.270
在这种情况下，我们也需要相关的问题

00:22:06.470 --> 00:22:10.640
首先确认是否有记忆

00:22:08.270 --> 00:22:13.430
泄漏监控您的永久一代

00:22:10.640 --> 00:22:16.610
或随着时间推移的元空间使用情况，以及

00:22:13.430 --> 00:22:19.400
完整的G C无法声明任何

00:22:16.610 --> 00:22:20.840
从元空间或约翰形成的空间

00:22:19.400 --> 00:22:23.210
可能意味着你的永久

00:22:20.840 --> 00:22:25.880
世代或元空间的大小不正确

00:22:23.210 --> 00:22:28.340
适当增加尺寸测试

00:22:25.880 --> 00:22:30.080
您的应用程序再次，如果仍然

00:22:28.340 --> 00:22:32.900
您知道申请到达后

00:22:30.080 --> 00:22:37.130
如果它仍然保持稳定状态

00:22:32.900 --> 00:22:39.230
在规模上它的占有率仍然保持

00:22:37.130 --> 00:22:42.890
增长表明

00:22:39.230 --> 00:22:52.340
可能有内存泄漏

00:22:42.890 --> 00:22:56.360
配置它是本地的，但是它是

00:22:52.340 --> 00:22:58.820
因此被垃圾收集器收集

00:22:56.360 --> 00:23:00.950
配置以配置我们的永久

00:22:58.820 --> 00:23:02.600
一代我们可以使用两种选择

00:23:00.950 --> 00:23:06.170
永久的一代

00:23:02.600 --> 00:23:07.940
手掌大小和最大手掌大小来设置

00:23:06.170 --> 00:23:10.820
初始和最大永久

00:23:07.940 --> 00:23:13.340
代大小这里要注意的一点是

00:23:10.820 --> 00:23:16.430
那永久的一代已经

00:23:13.340 --> 00:23:19.010
已在JDK 8中删除，因此我们没有

00:23:16.430 --> 00:23:23.240
从JDK 8开始，有很多代

00:23:19.010 --> 00:23:26.800
我们存储类元数据的元空间

00:23:23.240 --> 00:23:30.080
信息，以便配置元空间

00:23:26.800 --> 00:23:34.520
元空间大小和最大元空间大小

00:23:30.080 --> 00:23:38.120
 JVM选项，如果最大元空间大小为

00:23:34.520 --> 00:23:40.550
不使用JVM，您知道免费吗

00:23:38.120 --> 00:23:43.730
使用所有本机内存

00:23:40.550 --> 00:23:46.580
可用，因为元空间

00:23:43.730 --> 00:23:51.890
与分配永久代不同

00:23:46.580 --> 00:23:54.350
来自本机内存，所以我们谈到了

00:23:51.890 --> 00:23:56.870
关于内存不足错误或内存泄漏

00:23:54.350 --> 00:23:57.710
元空间的情况以及什么

00:23:56.870 --> 00:23:59.870
这是

00:23:57.710 --> 00:24:02.060
你知道另一个空间压缩类

00:23:59.870 --> 00:24:05.960
空间，所以压缩的类空间是

00:24:02.060 --> 00:24:07.880
实际上是元空间的一部分

00:24:05.960 --> 00:24:10.650
你知道逻辑区域

00:24:07.880 --> 00:24:13.530
它实际上不是元空间的一部分

00:24:10.650 --> 00:24:15.800
这是合乎逻辑的，这是一个区域

00:24:13.530 --> 00:24:19.800
逻辑上包含在元空间中

00:24:15.800 --> 00:24:22.020
我们有元空间，你知道元

00:24:19.800 --> 00:24:24.690
具有压缩类空间的空间，如果

00:24:22.020 --> 00:24:27.120
该选项使用压缩的类指针

00:24:24.690 --> 00:24:28.980
已启用，如果使用则启用

00:24:27.120 --> 00:24:32.520
压缩oops已启用，这是

00:24:28.980 --> 00:24:34.410
对于64位平台为true，因此默认情况下

00:24:32.520 --> 00:24:39.809
你会用压缩类

00:24:34.410 --> 00:24:44.070
和您的64位JVM上的指针

00:24:39.809 --> 00:24:47.429
在64位类上的此选项

00:24:44.070 --> 00:24:49.500
指针由32位表示

00:24:47.429 --> 00:24:53.820
抵消，所以有一个你知道分开

00:24:49.500 --> 00:24:56.220
分配一个单独的内存池， 

00:24:53.820 --> 00:24:58.800
该内存池中的类元数据可以

00:24:56.220 --> 00:25:02.460
被32位偏移量代替

00:24:58.800 --> 00:25:04.410
默认情况下64位指针的1gb 

00:25:02.460 --> 00:25:06.540
地址空间为

00:25:04.410 --> 00:25:09.270
当您知道压缩的类空间时

00:25:06.540 --> 00:25:11.460
 JVM初始化，但这可以是

00:25:09.270 --> 00:25:15.480
使用选项压缩类配置

00:25:11.460 --> 00:25:18.270
空间大小和这里的重点

00:25:15.480 --> 00:25:21.870
是选项最大元

00:25:18.270 --> 00:25:24.570
空间大小为

00:25:21.870 --> 00:25:28.980
这两个空间的承诺大小

00:25:24.570 --> 00:25:32.340
元空间和压缩类空间

00:25:28.980 --> 00:25:35.400
如果我们不了解的话会更好

00:25:32.340 --> 00:25:38.280
启用了压缩的类指针

00:25:35.400 --> 00:25:40.559
我们让您知道对象的Java堆

00:25:38.280 --> 00:25:42.900
在对象中，我们有这些类指针

00:25:40.559 --> 00:25:46.770
所以这些类指针在64位上

00:25:42.900 --> 00:25:50.190
平台是64位64位平台

00:25:46.770 --> 00:25:52.950
我们的64位指针和这些64位

00:25:50.190 --> 00:25:55.830
然后使用指针来引用

00:25:52.950 --> 00:25:58.380
在元空间中对元数据进行分类，但是当我们

00:25:55.830 --> 00:26:02.040
使用了压缩的类指针

00:25:58.380 --> 00:26:04.470
启用这些下划线类指针

00:26:02.040 --> 00:26:08.280
 Java堆中的Java对象是

00:26:04.470 --> 00:26:12.000
实际上是32位偏移，所以它说您

00:26:08.280 --> 00:26:15.390
知道我们Java堆中的空间（如果有） 

00:26:12.000 --> 00:26:17.850
 32位指针而不是64位指针

00:26:15.390 --> 00:26:20.820
这些32位偏移量可用于

00:26:17.850 --> 00:26:24.870
引用此类中的元数据

00:26:20.820 --> 00:26:28.410
压玻璃空间，当我们有

00:26:24.870 --> 00:26:31.680
使用了压缩玻璃指针，如果

00:26:28.410 --> 00:26:33.450
我们看一下GC日志条目

00:26:31.680 --> 00:26:35.430
你知道两行

00:26:33.450 --> 00:26:40.110
骨髓空间，另一个是

00:26:35.430 --> 00:26:43.290
用于压缩的课堂空间，请在此处注意

00:26:40.110 --> 00:26:48.000
您知道meta的承诺大小

00:26:43.290 --> 00:26:50.340
空间是4 8 6 4 K，其中包括

00:26:48.000 --> 00:26:55.290
压缩类空间的已承诺大小

00:26:50.340 --> 00:26:59.640
所以512 K不是一个单独的

00:26:55.290 --> 00:27:05.010
它包含在4 8 6 4 k中的空间

00:26:59.640 --> 00:27:06.930
元空间诊断数据收集

00:27:05.010 --> 00:27:09.720
和分析，用于永久生成

00:27:06.930 --> 00:27:11.640
和元空间，所以我们应该

00:27:09.720 --> 00:27:14.100
收集GC日志，这些可以是

00:27:11.640 --> 00:27:16.230
用详细的类或跟踪收集

00:27:14.100 --> 00:27:18.900
类加载跟踪类卸载

00:27:16.230 --> 00:27:22.290
我们可以收集的选项，我们应该

00:27:18.900 --> 00:27:26.520
用J map收集数据-pom stat 

00:27:22.290 --> 00:27:30.450
用于JDK的版本取决于JDK 7和J映射-CL 

00:27:26.520 --> 00:27:33.660
从JDK 8开始，他提示

00:27:30.450 --> 00:27:35.580
帮助诊断或调查

00:27:33.660 --> 00:27:40.290
元空间上的永久生成

00:27:35.580 --> 00:27:42.540
相关问题以及JDK 8及更高版本

00:27:40.290 --> 00:27:46.140
班级统计信息可以是

00:27:42.540 --> 00:27:53.460
用J命令GC点类收集

00:27:46.140 --> 00:27:56.040
下划线stats命令，以便您知道

00:27:53.460 --> 00:27:58.530
在调查班级或班级时

00:27:56.040 --> 00:28:00.660
加载程序相关的内存问题，我们应该

00:27:58.530 --> 00:28:03.510
我们需要确保课程

00:28:00.660 --> 00:28:07.290
正在卸货，请确保我们您

00:28:03.510 --> 00:28:10.020
知道那里的选项-X没有类GC 

00:28:07.290 --> 00:28:11.520
如果您的课程在那里，请不要使用

00:28:10.020 --> 00:28:15.810
不会被卸载

00:28:11.520 --> 00:28:18.570
你知道JVM会继续加载

00:28:15.810 --> 00:28:21.930
类，没有一个类得到

00:28:18.570 --> 00:28:24.900
卸载后，您会at肿元数据

00:28:21.930 --> 00:28:28.380
空间或永久性发电用途以及

00:28:24.900 --> 00:28:32.670
确保启用CMS类卸载

00:28:28.380 --> 00:28:34.050
在Java 6或更高版本上使用CMS时，此选项打开

00:28:32.670 --> 00:28:36.540
 Java 7- 

00:28:34.050 --> 00:28:39.060
确保正在卸载类

00:28:36.540 --> 00:28:41.220
在并发标记周期中

00:28:39.060 --> 00:28:47.700
否则，它们只能全部卸载

00:28:41.220 --> 00:28:50.310
 GCS，所以这是收集的日志

00:28:47.700 --> 00:28:52.350
与-对于类和这些日志都是

00:28:50.310 --> 00:28:53.670
告诉我们很重要

00:28:52.350 --> 00:28:56.160
你知道上课了吗

00:28:53.670 --> 00:28:59.910
从正确的软件包或jar文件加载

00:28:56.160 --> 00:29:06.330
如果他们在我们卸货的时候

00:28:59.910 --> 00:29:08.010
期望他们在这个特定的GC中如此

00:29:06.330 --> 00:29:11.940
日志条目，我们可以看到有一个

00:29:08.010 --> 00:29:16.410
完整的GC，它之所以发生是因为meta 

00:29:11.940 --> 00:29:18.780
空间已达到高水位线， 

00:29:16.410 --> 00:29:21.990
在这里我们可以看到你知道有

00:29:18.780 --> 00:29:25.860
 meta空间中有足够的可用空间meta 

00:29:21.990 --> 00:29:28.920
空间容量为6 GB，但使用率

00:29:25.860 --> 00:29:31.380
只有4 GB，仍然是您知道的

00:29:28.920 --> 00:29:33.900
如果您看，抛出内存不足错误

00:29:31.380 --> 00:29:36.960
接近内存不足错误

00:29:33.900 --> 00:29:40.170
抛出是为了压缩类空间而不是

00:29:36.960 --> 00:29:43.140
元空间，以便您知道

00:29:40.170 --> 00:29:45.930
我们讨论过的另一个地区

00:29:43.140 --> 00:29:47.670
上一张幻灯片的压缩类

00:29:45.930 --> 00:29:50.070
作为元空间一部分的空间

00:29:47.670 --> 00:29:53.160
没有足够的空间来加载更多

00:29:50.070 --> 00:29:55.140
类，所以我们应该使用您知道的

00:29:53.160 --> 00:29:59.250
压缩类空间大小选项

00:29:55.140 --> 00:30:05.250
配置压缩类的大小

00:29:59.250 --> 00:30:08.370
我们可以看到类加载器统计信息的空间

00:30:05.250 --> 00:30:11.970
随手掌收集到的JDK是

00:30:08.370 --> 00:30:16.080
您知道多达JDK 7的

00:30:11.970 --> 00:30:20.390
永久一代和JDK 8起

00:30:16.080 --> 00:30:23.040
我们可以使用J map有CL统计

00:30:20.390 --> 00:30:25.760
选择收集类加载器的选项压力很大

00:30:23.040 --> 00:30:28.110
统计信息，因此类加载器统计信息是

00:30:25.760 --> 00:30:30.480
重要，因为它给了我们

00:30:28.110 --> 00:30:33.090
有关类加载器的信息

00:30:30.480 --> 00:30:35.700
可用实例和类

00:30:33.090 --> 00:30:37.920
他们是否加载了这些类

00:30:35.700 --> 00:30:40.830
装载机是活着的还是死的

00:30:37.920 --> 00:30:42.900
记忆或你知道的数量

00:30:40.830 --> 00:30:46.590
它们加载的类或字节

00:30:42.900 --> 00:30:50.580
在Metis P中被那些班级占用

00:30:46.590 --> 00:30:52.650
永久生成，因此堆转储帮助

00:30:50.580 --> 00:30:54.600
在这种情况下，我们也应该

00:30:52.650 --> 00:30:57.780
寻找应该有的课程

00:30:54.600 --> 00:30:59.610
被卸载，日食哑光有一个

00:30:57.780 --> 00:31:02.430
非常好的功能，称为重复

00:30:59.610 --> 00:31:04.440
可以向我们显示重复项的类

00:31:02.430 --> 00:31:09.320
你知道已经加载的类

00:31:04.440 --> 00:31:12.960
通过类加载器的多个实例

00:31:09.320 --> 00:31:16.170
在这种情况下，你知道这个例子

00:31:12.960 --> 00:31:19.280
显示重复的类，在这里我们可以

00:31:16.170 --> 00:31:21.840
看到千斤顶被生成类

00:31:19.280 --> 00:31:23.760
有那些的多个实例

00:31:21.840 --> 00:31:26.310
由不同的类加载

00:31:23.760 --> 00:31:30.960
类加载器实例，在这种情况下

00:31:26.310 --> 00:31:33.210
问题是您知道我们有

00:31:30.960 --> 00:31:36.110
报告此问题的客户

00:31:33.210 --> 00:31:38.550
有不同版本的杰克B 

00:31:36.110 --> 00:31:42.180
类路径上的库以及

00:31:38.550 --> 00:31:45.390
导致类链接错误，并且

00:31:42.180 --> 00:31:48.990
导致加载多个

00:31:45.390 --> 00:31:52.260
类由不同的类加载器

00:31:48.990 --> 00:31:54.720
你知道重复的课可以给我们

00:31:52.260 --> 00:31:56.790
我们应该在哪里寻找线索

00:31:54.720 --> 00:32:01.140
这些课让你知道

00:31:56.790 --> 00:32:04.710
加载了多次，所以

00:32:01.140 --> 00:32:07.350
由于完成而导致的内存错误

00:32:04.710 --> 00:32:11.310
众所周知，终结是一个功能

00:32:07.350 --> 00:32:13.860
在Java中，您的班级可以有一个

00:32:11.310 --> 00:32:16.280
确定方法并指示JVM 

00:32:13.860 --> 00:32:21.170
你知道不要收集我的东西直到

00:32:16.280 --> 00:32:25.430
我的最终方法已执行，因此

00:32:21.170 --> 00:32:28.200
即使你是

00:32:25.430 --> 00:32:30.660
具有特定类别的优惠

00:32:28.200 --> 00:32:33.030
最终方法有资格

00:32:30.660 --> 00:32:36.150
直到他们才会被收集

00:32:33.030 --> 00:32:39.690
终结器线程有机会

00:32:36.150 --> 00:32:43.020
对那些执行最终方法

00:32:39.690 --> 00:32:45.300
实例，所以我们只有一个

00:32:43.020 --> 00:32:48.540
您知道的线程终结器线程

00:32:45.300 --> 00:32:51.330
有执行的责任

00:32:48.540 --> 00:32:55.320
最终确定对象的方法

00:32:51.330 --> 00:32:58.050
待定案，如果这单

00:32:55.320 --> 00:32:58.630
线程无法跟上

00:32:58.050 --> 00:33:00.600
宽度

00:32:58.630 --> 00:33:04.000
已添加到队列中的主

00:33:00.600 --> 00:33:07.090
你知道如果它落后了，那么我们会

00:33:04.000 --> 00:33:09.760
你知道物体清单吗

00:33:07.090 --> 00:33:11.530
否则是垃圾，如果他们

00:33:09.760 --> 00:33:14.050
被收集，我们将有空间

00:33:11.530 --> 00:33:16.930
在Java堆中可用，或者您知道

00:33:14.050 --> 00:33:18.880
本机内存中的相应空间，但是

00:33:16.930 --> 00:33:22.330
他们仍然在那里，因为他们

00:33:18.880 --> 00:33:24.880
 finalize方法需要执行，因此

00:33:22.330 --> 00:33:28.420
这可能会浪费很多内存

00:33:24.880 --> 00:33:30.670
好消息是定稿有

00:33:28.420 --> 00:33:35.710
在Java 9中已弃用，这是

00:33:30.670 --> 00:33:37.930
您知道的更改的CR ID 

00:33:35.710 --> 00:33:40.480
已不推荐使用

00:33:37.930 --> 00:33:43.900
 Java 9和此错误报告实际上

00:33:40.480 --> 00:33:45.720
谈论替代解决方案

00:33:43.900 --> 00:33:50.470
应该使用而不是使用

00:33:45.720 --> 00:33:53.740
最终确定哪些诊断数据

00:33:50.470 --> 00:33:55.960
工具可以帮助我们看到物体

00:33:53.740 --> 00:34:00.220
使用J Console进行挂起的终结处理

00:33:55.960 --> 00:34:03.420
使用j map-finalizar信息，我们可以

00:34:00.220 --> 00:34:07.090
看到您知道有关定稿的信息

00:34:03.420 --> 00:34:11.050
待完成的对象使用

00:34:07.090 --> 00:34:12.909
堆转储也是如此，因此在J控制台中

00:34:11.050 --> 00:34:15.639
我们可以看到您知道未决

00:34:12.909 --> 00:34:18.070
最终确定对象的计数为0 

00:34:15.639 --> 00:34:20.590
但是如果这个数字很高，那就意味着

00:34:18.070 --> 00:34:23.260
待处理的对象

00:34:20.590 --> 00:34:25.810
最终确定浪费了我们的Java堆

00:34:23.260 --> 00:34:27.550
内存，以及那些对象是否在保存

00:34:25.810 --> 00:34:29.830
如果他们有本机内存中的某些内容

00:34:27.550 --> 00:34:32.610
然后在本机内存中分配缓冲区

00:34:29.830 --> 00:34:35.500
这些资源也被保留

00:34:32.610 --> 00:34:39.970
因为有待处理的对象

00:34:35.500 --> 00:34:43.870
最终确定，我们可以看到信息

00:34:39.970 --> 00:34:44.560
关于月食遮罩的最终错误

00:34:43.870 --> 00:34:50.830
好

00:34:44.560 --> 00:34:52.990
通过分析堆转储，以便代码缓存是

00:34:50.830 --> 00:34:55.899
已满，编译器已被禁用，因此

00:34:52.990 --> 00:34:59.260
有一个单独的内存池

00:34:55.899 --> 00:35:02.500
存储已编译代码的JVM 

00:34:59.260 --> 00:35:06.780
由JIT编译器生成的

00:35:02.500 --> 00:35:10.750
您知道的内存池具有定义的大小

00:35:06.780 --> 00:35:11.920
指定的大小，它也可以得到

00:35:10.750 --> 00:35:14.770
充满和何时

00:35:11.920 --> 00:35:17.230
该内存池已满，您会

00:35:14.770 --> 00:35:18.970
看到此消息，代码缓存是

00:35:17.230 --> 00:35:21.250
已满，编译器已被禁用

00:35:18.970 --> 00:35:24.579
虽然您不会看到这只是一个警告

00:35:21.250 --> 00:35:28.480
您的申请不会退出您

00:35:24.579 --> 00:35:31.270
不会看到任何内存不足错误，但是

00:35:28.480 --> 00:35:35.440
你知道那里有缺点

00:35:31.270 --> 00:35:37.630
是您的性能损失

00:35:35.440 --> 00:35:40.630
或者当您在自己的

00:35:37.630 --> 00:35:43.030
应用程序运行，以便当代码缓存时

00:35:40.630 --> 00:35:45.640
变满，紧急代码缓存

00:35:43.030 --> 00:35:48.250
清理实际上被调用

00:35:45.640 --> 00:35:50.950
丢弃几乎一半的已编译

00:35:48.250 --> 00:35:56.290
代码，如果该编译代码是

00:35:50.950 --> 00:35:58.150
很快知道就需要

00:35:56.290 --> 00:36:02.559
丢弃然后编译器必须工作

00:35:58.150 --> 00:36:05.049
再次编译这些方法，以便您

00:36:02.559 --> 00:36:07.859
会降低性能

00:36:05.049 --> 00:36:11.170
因为您的编译代码不见了

00:36:07.859 --> 00:36:13.630
虽然编译这些方法会

00:36:11.170 --> 00:36:16.049
现在运行解释模式， 

00:36:13.630 --> 00:36:20.200
编译器将占用资源

00:36:16.049 --> 00:36:22.930
重新编译这些方法，所以我们应该

00:36:20.200 --> 00:36:25.059
努力避免这种情况，并

00:36:22.930 --> 00:36:27.490
我们应该确保代码缓存

00:36:25.059 --> 00:36:29.589
大小足以容纳我们的

00:36:27.490 --> 00:36:32.799
编译的代码，有一个选择

00:36:29.589 --> 00:36:37.510
保留的代码缓存大小

00:36:32.799 --> 00:36:41.319
可以配置我们的代码缓存大小

00:36:37.510 --> 00:36:44.290
本机内存的内存错误，因此

00:36:41.319 --> 00:36:49.000
这两个例子表明JVM是

00:36:44.290 --> 00:36:50.890
用完本机内存，所以当我们

00:36:49.000 --> 00:36:53.799
当我们看到此错误消息时

00:36:50.890 --> 00:36:56.319
表示JVM无法分配

00:36:53.799 --> 00:36:59.140
从不受管理的本机内存中

00:36:56.319 --> 00:37:02.980
由JVM而不直接由JVM管理

00:36:59.140 --> 00:37:05.319
 JVM，所以这个过程就是我们当前的过程

00:37:02.980 --> 00:37:08.770
或系统上的其他进程可能

00:37:05.319 --> 00:37:11.290
消耗本机内存，我们可以

00:37:08.770 --> 00:37:14.710
让更多的空间让您知道本地人

00:37:11.290 --> 00:37:16.930
通过减少Java堆大小来增加内存

00:37:14.710 --> 00:37:19.329
正在减少永久世代或

00:37:16.930 --> 00:37:23.140
元空间大小减少了

00:37:19.329 --> 00:37:25.630
活动线程在那里有堆栈大小

00:37:23.140 --> 00:37:27.970
通过终止一些减少

00:37:25.630 --> 00:37:30.819
我们系统上没有的流程

00:37:27.970 --> 00:37:33.579
当时需要，如果以上

00:37:30.819 --> 00:37:36.789
对我们可能面对的本地人没有帮助

00:37:33.579 --> 00:37:39.970
例如内存泄漏，你知道j'ni 

00:37:36.789 --> 00:37:42.099
代码可能是j'ni或JVM Ti Coal 

00:37:39.970 --> 00:37:46.319
分配本机缓冲区，并可能

00:37:42.099 --> 00:37:50.529
不必D根据需要分配它们

00:37:46.319 --> 00:37:53.319
因此哪些诊断数据可以帮助我们

00:37:50.529 --> 00:37:56.710
解决本机内存问题

00:37:53.319 --> 00:37:58.930
内存泄漏你知道两种

00:37:56.710 --> 00:38:03.099
本机内存泄漏可能在

00:37:58.930 --> 00:38:06.549
 JVM或它可能在JVM之外

00:38:03.099 --> 00:38:09.190
 JVM之外的一些代码可能是

00:38:06.549 --> 00:38:11.619
泄漏本机内存，以便进行跟踪

00:38:09.190 --> 00:38:13.539
 JVM中的本机内存泄漏

00:38:11.619 --> 00:38:16.539
我们称为本机内存跟踪器的工具

00:38:13.539 --> 00:38:21.730
应该使用这个工具来了解

00:38:16.539 --> 00:38:24.430
 JVM对本机内存的使用

00:38:21.730 --> 00:38:27.099
或者我们可以用你知道的

00:38:24.430 --> 00:38:29.980
跟踪JVM外的本机内存泄漏

00:38:27.099 --> 00:38:33.130
我们需要您知道依靠平台

00:38:29.980 --> 00:38:35.440
本机操作系统级别的工具，例如豌豆

00:38:33.130 --> 00:38:38.829
映射以查看流程图

00:38:35.440 --> 00:38:42.609
了解您知道哪里的哪个部分

00:38:38.829 --> 00:38:46.390
您知道哪个消耗了内存

00:38:42.609 --> 00:38:48.369
来自本地的分配和结果

00:38:46.390 --> 00:38:52.259
内存泄漏工具泄漏工具，例如

00:38:48.369 --> 00:38:54.670
利比亚mam valgrind等，当然

00:38:52.259 --> 00:38:56.680
检查不同部分

00:38:54.670 --> 00:39:01.180
核心文件还可以显示信息

00:38:56.680 --> 00:39:04.900
关于什么样的本机内存

00:39:01.180 --> 00:39:08.190
分配造成了Nitin和

00:39:04.900 --> 00:39:11.410
观察到的本机内存不足错误

00:39:08.190 --> 00:39:14.230
我们可以使用本机内存-跟踪器

00:39:11.410 --> 00:39:18.309
我所说的跟踪本机内存的工具

00:39:14.230 --> 00:39:20.799
由JVM完成的分配

00:39:18.309 --> 00:39:25.140
并且它无法跟踪分配的内存

00:39:20.799 --> 00:39:29.890
 JVM外部或本地库

00:39:25.140 --> 00:39:33.519
所以要使用nmt，我们可以使用本机选项

00:39:29.890 --> 00:39:35.380
内存跟踪，我们需要您知道

00:39:33.519 --> 00:39:37.020
使用此选项启动我们的应用程序

00:39:35.380 --> 00:39:39.030
在和

00:39:37.020 --> 00:39:41.910
此选项可以在两个级别上使用

00:39:39.030 --> 00:39:45.480
某人和细节取决于

00:39:41.910 --> 00:39:47.790
信息的详细程度

00:39:45.480 --> 00:39:49.829
喜欢看，然后我们可以使用J 

00:39:47.790 --> 00:39:53.010
命令连接到进程

00:39:49.829 --> 00:39:55.470
提取使用中的本机内存

00:39:53.010 --> 00:40:00.210
使用VM dot native的信息

00:39:55.470 --> 00:40:03.660
下划线内存命令这是

00:40:00.210 --> 00:40:07.470
 VM点本机下划线的输出

00:40:03.660 --> 00:40:11.309
内存看起来像这样，您知道

00:40:07.470 --> 00:40:14.160
 JVM内部使用的内存，由

00:40:11.309 --> 00:40:18.240
 JVM的不同组件

00:40:14.160 --> 00:40:21.690
知道Java堆线程编译器GC这样

00:40:18.240 --> 00:40:25.559
这为我们提供了一个线索，您知道

00:40:21.690 --> 00:40:28.410
 JVM的哪个部分消耗更多

00:40:25.559 --> 00:40:32.270
内存还是您知道使用率在增长

00:40:28.410 --> 00:40:35.730
内存，我们可以收集基线

00:40:32.270 --> 00:40:39.720
使用nmt输出，该基线可以

00:40:35.730 --> 00:40:41.220
与您知道的输出进行比较

00:40:39.720 --> 00:40:43.770
在不同阶段收集

00:40:41.220 --> 00:40:47.640
应用程序运行并查看哪些部分

00:40:43.770 --> 00:40:52.500
内存使用量的增长，因此对于本机

00:40:47.640 --> 00:40:55.859
我们需要使用的JVM外部内存泄漏

00:40:52.500 --> 00:40:58.680
本机平台本机内存泄漏

00:40:55.859 --> 00:41:05.329
例如我们可以使用的检测工具

00:40:58.680 --> 00:41:05.329
 dbx laboum m valgrind纯化等

00:41:05.790 --> 00:41:11.910
所以总结一下与记忆有关的原因

00:41:09.809 --> 00:41:14.549
问题可能是你知道小姐

00:41:11.910 --> 00:41:17.849
内存池配置过多

00:41:14.549 --> 00:41:21.450
使用最终错误，例如显式GC 

00:41:17.849 --> 00:41:23.549
调用或内存泄漏，我们

00:41:21.450 --> 00:41:25.770
第一步了解或

00:41:23.549 --> 00:41:29.280
解决与内存相关的问题是

00:41:25.770 --> 00:41:31.799
适当地调整我们的内存池大小

00:41:29.280 --> 00:41:34.770
以及我们可以用来

00:41:31.799 --> 00:41:37.200
解决内存问题是堆

00:41:34.770 --> 00:41:40.140
转储出内存错误并打印

00:41:37.200 --> 00:41:44.220
类直方图选项J控制台J 

00:41:40.140 --> 00:41:48.390
命令J map GC记录Eclipse mat和MT 

00:41:44.220 --> 00:41:52.650
是本机内存检测工具

00:41:48.390 --> 00:41:55.289
这些是您可以参考的

00:41:52.650 --> 00:41:58.559
知道看参考故障排除

00:41:55.289 --> 00:42:01.529
此处的指南我提供了JDK 9的链接

00:41:58.559 --> 00:42:04.140
和我拥有的JDK 8故障排除指南

00:42:01.529 --> 00:42:06.539
我分享我的疑难解答的博客

00:42:04.140 --> 00:42:10.369
你经常知道的经历

00:42:06.539 --> 00:42:13.079
正在进行免费的在线课程

00:42:10.369 --> 00:42:15.359
用于解决内存中的问题

00:42:13.079 --> 00:42:18.150
注册的Java应用程序是

00:42:15.359 --> 00:42:19.859
仍然开放到10月11日，所以您可以

00:42:18.150 --> 00:42:21.989
报名参加那门课程，你知道

00:42:19.859 --> 00:42:25.109
详细了解如何进行故障排除

00:42:21.989 --> 00:42:27.210
内存问题，有一篇关于

00:42:25.109 --> 00:42:29.900
对Java内存问题进行故障排除

00:42:27.210 --> 00:42:33.500
信息立方体链接在这里给出，所以

00:42:29.900 --> 00:42:38.409
这就是我要分享的全部，谢谢

00:42:33.500 --> 00:42:38.409
 [掌声] 

