WEBVTT
Kind: captions
Language: zh-Hans

00:00:04.009 --> 00:00:12.630
嘿，我是克里斯，我在Twitter工作，是的

00:00:09.150 --> 00:00:15.780
 VM团队，因此Twitter拥有自己的VM 

00:00:12.630 --> 00:00:18.330
团队，如果您在此发表推文， 

00:00:15.780 --> 00:00:23.849
如果您有该标签，那将很好

00:00:18.330 --> 00:00:26.669
给我们的团队一些帮助，所以

00:00:23.849 --> 00:00:28.259
讲这个演讲的目的是什么

00:00:26.669 --> 00:00:30.779
基本上告诉你我们在做什么

00:00:28.259 --> 00:00:33.149
 Twitter与咆哮和什么

00:00:30.779 --> 00:00:36.920
结果是，而我们的目标是

00:00:33.149 --> 00:00:41.670
总是为了省钱，因为

00:00:36.920 --> 00:00:46.379
 Twitter是很多机器的重要服务

00:00:41.670 --> 00:00:49.199
服务，如果你能剃光一堆

00:00:46.379 --> 00:00:53.100
 CPU时间，您将节省很多钱

00:00:49.199 --> 00:00:55.649
对，所以我想每个人都知道

00:00:53.100 --> 00:00:58.769
 Twitter是只有您知道

00:00:55.649 --> 00:01:01.170
这是一个庞大的分布式系统

00:00:58.769 --> 00:01:05.640
我什至不知道很多服务

00:01:01.170 --> 00:01:07.020
很多，但有一些主要服务

00:01:05.640 --> 00:01:08.640
就像读的推特服务权利

00:01:07.020 --> 00:01:10.830
并写推文，他们使用

00:01:08.640 --> 00:01:12.510
向您显示数据的服务

00:01:10.830 --> 00:01:14.400
个人资料和类似的东西，以及

00:01:12.510 --> 00:01:16.680
你知道的时间线服务

00:01:14.400 --> 00:01:19.380
为您提供时间表

00:01:16.680 --> 00:01:21.390
您知道所有的客户端应用社交图

00:01:19.380 --> 00:01:26.160
这些东西是重要的服务

00:01:21.390 --> 00:01:29.580
并且我们运行它们的许多实例

00:01:26.160 --> 00:01:31.520
我们有很多电视服务目标

00:01:29.580 --> 00:01:34.500
只是说了主要的

00:01:31.520 --> 00:01:36.390
一项服务的数千个实例

00:01:34.500 --> 00:01:38.550
我们有数千台机器

00:01:36.390 --> 00:01:41.190
运行数千个gvm，所以我们知道

00:01:38.550 --> 00:01:43.800
每次都节省一点点

00:01:41.190 --> 00:01:46.410
你可以成千上万倍

00:01:43.800 --> 00:01:48.630
是的，然后最重要的是

00:01:46.410 --> 00:01:53.100
您知道的多个数据中心

00:01:48.630 --> 00:01:57.530
一个大系统，我们也确实开放

00:01:53.100 --> 00:02:00.510
来源，我们使用了大量的开源资源， 

00:01:57.530 --> 00:02:02.340
那里有这个我们有的链接

00:02:00.510 --> 00:02:06.810
很多开源项目和github 

00:02:02.340 --> 00:02:08.490
所以当我们考虑尝试罗利时

00:02:06.810 --> 00:02:09.840
很合适，因为它是开放的

00:02:08.490 --> 00:02:11.430
您知道您去得到的源项目

00:02:09.840 --> 00:02:14.819
帮助您下载它，尝试一下

00:02:11.430 --> 00:02:17.880
看看它是如何工作的，所以很合适

00:02:14.819 --> 00:02:21.270
对我们来说，对我们来说也很容易

00:02:17.880 --> 00:02:26.400
贡献我们实际所做的

00:02:21.270 --> 00:02:31.500
我们有自己的基于

00:02:26.400 --> 00:02:35.160
在开放的JDK 8上，您基本上做了什么

00:02:31.500 --> 00:02:37.860
所以有243个是JVM CI 

00:02:35.160 --> 00:02:40.950
我们从9移植到8 

00:02:37.860 --> 00:02:42.209
我们的JDK，然后在其中有Grall 

00:02:40.950 --> 00:02:44.910
然后我们有一个叫做

00:02:42.209 --> 00:02:46.860
转换轨迹是我们的志气

00:02:44.910 --> 00:02:49.500
事物的替代类型，并且我们

00:02:46.860 --> 00:02:53.250
有很多CMS改进，所以这

00:02:49.500 --> 00:02:57.420
是我们正在使用的JDK，这个JDK 

00:02:53.250 --> 00:03:01.680
运行我们所有的服务，为什么要咆哮

00:02:57.420 --> 00:03:04.200
一般是C-我不知道有多少

00:03:01.680 --> 00:03:06.480
这个房间里的人知道C-而不是

00:03:04.200 --> 00:03:10.610
你们很多人都知道C的源代码- 

00:03:06.480 --> 00:03:14.459
但是它确实很老很复杂

00:03:10.610 --> 00:03:16.950
逐渐增加C语言-花费数年

00:03:14.459 --> 00:03:19.440
对，所以很难雇用

00:03:16.950 --> 00:03:21.299
人们很难训练他们， 

00:03:19.440 --> 00:03:23.250
有时他们甚至不留多久

00:03:21.299 --> 00:03:24.959
足以达到他们所处的位置

00:03:23.250 --> 00:03:28.829
实际上非常有用，可以做一些事情

00:03:24.959 --> 00:03:30.600
所以这就是为什么在那里原地

00:03:28.829 --> 00:03:32.370
过去没有重大优化

00:03:30.600 --> 00:03:33.900
几年就在那里

00:03:32.370 --> 00:03:35.940
是小的改进，尤其是

00:03:33.900 --> 00:03:38.630
内在的改进，直到做了很多

00:03:35.940 --> 00:03:42.390
那里的工作，但是没有专业哦

00:03:38.630 --> 00:03:44.340
我们重做整个内联，否则我们

00:03:42.390 --> 00:03:47.730
重新实现它无所不能

00:03:44.340 --> 00:03:49.500
那是正确的，我自己

00:03:47.730 --> 00:03:52.549
认为它已经寿终正寝了哦

00:03:49.500 --> 00:03:55.049
好吧，几年前

00:03:52.549 --> 00:03:57.140
再次可能在我看来，我认为

00:03:55.049 --> 00:04:00.260
这么广泛更容易理解

00:03:57.140 --> 00:04:02.670
它具有模块化设计

00:04:00.260 --> 00:04:04.769
模块与

00:04:02.670 --> 00:04:06.419
构建系统会确保您不会

00:04:04.769 --> 00:04:07.980
打破这些依赖关系，你

00:04:06.419 --> 00:04:08.470
不引入循环依赖

00:04:07.980 --> 00:04:10.470
东西

00:04:08.470 --> 00:04:12.040
他们的模块是

00:04:10.470 --> 00:04:13.840
平台无关

00:04:12.040 --> 00:04:16.090
他们不能依赖平台

00:04:13.840 --> 00:04:19.840
取决于这样的模块的东西，所以它

00:04:16.090 --> 00:04:22.330
它的设计非常好，非常

00:04:19.840 --> 00:04:24.910
重要的是内联非常重要

00:04:22.330 --> 00:04:27.280
更好并且可以逃脱的分析-那就是

00:04:24.910 --> 00:04:32.110
我们大部分会在后面看到

00:04:27.280 --> 00:04:34.300
那就是我们获得的地方，所以当我们

00:04:32.110 --> 00:04:37.900
当我加入Twitter时， 

00:04:34.300 --> 00:04:40.500
一年前第一件事是好的，让我们

00:04:37.900 --> 00:04:43.840
把它带到我们的Twitter jdk， 

00:04:40.500 --> 00:04:46.570
看看它是否正确，你知道启动

00:04:43.840 --> 00:04:48.520
服务，看看它是否有效

00:04:46.570 --> 00:04:51.520
一些错误，我将重点介绍其中一些

00:04:48.520 --> 00:04:54.340
那会不会你不知道

00:04:51.520 --> 00:04:56.170
这基本上是整个列表

00:04:54.340 --> 00:04:57.280
 -没有一百个错误，我是

00:04:56.170 --> 00:04:59.320
向您展示三个最

00:04:57.280 --> 00:05:02.470
重要的，这或多或少是什么

00:04:59.320 --> 00:05:05.620
我们发现这就是这种情况

00:05:02.470 --> 00:05:09.280
更换堆栈的东西

00:05:05.620 --> 00:05:12.130
编译无效，因为抓取

00:05:09.280 --> 00:05:13.270
不支持或沙皇与锁

00:05:12.130 --> 00:05:15.640
同步化

00:05:13.270 --> 00:05:17.110
因此，我们为此解决了错误

00:05:15.640 --> 00:05:21.700
有些东西看起来很奇怪

00:05:17.110 --> 00:05:23.050
像这样的权利，然后我们讨论了

00:05:21.700 --> 00:05:25.360
这一点我与

00:05:23.050 --> 00:05:28.780
汤姆·罗德里格斯（Tom Rodriguez），我们决定了这一点

00:05:25.360 --> 00:05:30.880
差不多一年前的时间

00:05:28.780 --> 00:05:32.770
说这不是什么大问题，因为

00:05:30.880 --> 00:05:34.419
基本上grogg会使一堆失败

00:05:32.770 --> 00:05:36.250
次，然后它会说可以

00:05:34.419 --> 00:05:36.820
编译这个，然后看一个

00:05:36.250 --> 00:05:40.229
照顾它

00:05:36.820 --> 00:05:43.060
而且你不知道

00:05:40.229 --> 00:05:46.720
对我们来说很重要的方法，所以我们没有

00:05:43.060 --> 00:05:51.270
太在乎了，但是在某些时候

00:05:46.720 --> 00:05:54.220
有人实际上将其固定在那里

00:05:51.270 --> 00:05:56.680
从那以后它就可以正常工作了128 

00:05:54.220 --> 00:05:58.510
亲密，但不是真的，因为当我

00:05:56.680 --> 00:05:59.770
试图验证它实际上是

00:05:58.510 --> 00:06:03.190
工作还有很多其他的

00:05:59.770 --> 00:06:05.950
像这样弹出

00:06:03.190 --> 00:06:08.290
没有关于分泌酶Monteux的产生， 

00:06:05.950 --> 00:06:11.740
然后有另一个没有或

00:06:08.290 --> 00:06:12.740
是我们的进入循环，我认为这意味着我

00:06:11.740 --> 00:06:15.110
不能

00:06:12.740 --> 00:06:17.560
所以汤姆要一堆图

00:06:15.110 --> 00:06:21.680
然后我认为前两个

00:06:17.560 --> 00:06:25.630
是的，他发现有一个微小的

00:06:21.680 --> 00:06:29.270
原地的一小段代码

00:06:25.630 --> 00:06:32.120
基本上可以确保您是否正在访问

00:06:29.270 --> 00:06:35.510
构造函数中的静态final字段

00:06:32.120 --> 00:06:37.430
您实际上可以做到，因为

00:06:35.510 --> 00:06:39.830
否则，如果不能编译

00:06:37.430 --> 00:06:41.150
尽快进行优化的代码

00:06:39.830 --> 00:06:43.670
您执行了它，所以不会有

00:06:41.150 --> 00:06:48.200
点不会有一点

00:06:43.670 --> 00:06:52.670
这样做只是时间到了

00:06:48.200 --> 00:06:54.830
这就是c2的等效方法

00:06:52.670 --> 00:06:56.390
这样做正确，所以最好检查一下

00:06:54.830 --> 00:06:59.720
现在我们尽快进行优化

00:06:56.390 --> 00:07:01.910
处决你当然知道，所以一个

00:06:59.720 --> 00:07:05.180
修复起来非常容易，只是

00:07:01.910 --> 00:07:07.070
就像一个文件基本上改变了

00:07:05.180 --> 00:07:11.630
该方法的chava版本并执行该操作

00:07:07.070 --> 00:07:16.730
一切都很好，我们有这个

00:07:11.630 --> 00:07:19.190
我只能长时间运行才看到的错误

00:07:16.730 --> 00:07:20.780
程序，我很烦

00:07:19.190 --> 00:07:23.030
因为我以为我的天哪

00:07:20.780 --> 00:07:24.530
您知道这些编译器错误之一

00:07:23.030 --> 00:07:25.580
你会在几天后找到你

00:07:24.530 --> 00:07:30.410
甚至不知道它来自哪里

00:07:25.580 --> 00:07:33.020
所以我会挖一点

00:07:30.410 --> 00:07:40.000
然后我发现我们正在使用它

00:07:33.020 --> 00:07:43.730
代理人称为赶时髦的人，它是做什么的

00:07:40.000 --> 00:07:45.950
它进行一些热分析，并且

00:07:43.730 --> 00:07:49.480
表示必须检测字节码

00:07:45.950 --> 00:07:53.780
并更改了一些字节码

00:07:49.480 --> 00:07:57.260
特别是分配网站格拉茨写的

00:07:53.780 --> 00:08:00.790
在Java中，有一种您

00:07:57.260 --> 00:08:04.190
知道亚圆引导问题

00:08:00.790 --> 00:08:06.620
所以事实证明那是

00:08:04.190 --> 00:08:09.140
问题叫做字节码

00:08:06.620 --> 00:08:11.330
片段是非常特殊的

00:08:09.140 --> 00:08:12.920
它不是常规的Java代码类型

00:08:11.330 --> 00:08:15.680
 Java编译下来的东西

00:08:12.920 --> 00:08:19.100
 C然后运行它就可以了

00:08:15.680 --> 00:08:21.200
特别是通过图它就像

00:08:19.100 --> 00:08:24.050
本质上这样说

00:08:21.200 --> 00:08:25.700
这是一个问题，因为突然之间

00:08:24.050 --> 00:08:29.780
该代码段的字节码已更改

00:08:25.700 --> 00:08:33.200
那把它弄坏了，所以这个被关闭了

00:08:29.780 --> 00:08:37.730
用杆很大的改变吧，但是

00:08:33.200 --> 00:08:41.390
现在可以正常工作了，我们有

00:08:37.730 --> 00:08:44.300
这项服务启动正常， 

00:08:41.390 --> 00:08:45.620
突然，日志会越来越大， 

00:08:44.300 --> 00:08:47.240
我以为发生了什么事

00:08:45.620 --> 00:08:49.850
都在疯狂地抛出异常

00:08:47.240 --> 00:08:52.100
时间，我不知道它在哪里

00:08:49.850 --> 00:08:54.140
从右边来，这正在

00:08:52.100 --> 00:08:56.360
至少持续几个星期，我

00:08:54.140 --> 00:08:57.860
真的不知道从哪里开始

00:08:56.360 --> 00:09:00.260
看看我在哪里挖

00:08:57.860 --> 00:09:01.970
在核心库代码中看到

00:09:00.260 --> 00:09:04.580
异常来自何处

00:09:01.970 --> 00:09:06.770
如此反复，然后在某一时刻，你知道

00:09:04.580 --> 00:09:08.780
有时要帮助你放东西

00:09:06.770 --> 00:09:10.580
一边做其他事情等等

00:09:08.780 --> 00:09:13.240
那就是我所做的，那时我就是

00:09:10.580 --> 00:09:16.280
在测试套件上运行nettie测试

00:09:13.240 --> 00:09:21.860
我发现缓冲区之一

00:09:16.280 --> 00:09:27.230
失败了，原因在那里

00:09:21.860 --> 00:09:29.120
在大多数情况下就像一个优化

00:09:27.230 --> 00:09:30.410
编译器，当您进行反向购买时

00:09:29.120 --> 00:09:32.780
你知道可以交换吗

00:09:30.410 --> 00:09:35.840
带着一条机器指令

00:09:32.780 --> 00:09:39.080
一个被打破了，它没有交换

00:09:35.840 --> 00:09:40.940
字节，这是令人惊讶的，因为它

00:09:39.080 --> 00:09:45.530
应该一直失败，但是

00:09:40.940 --> 00:09:48.320
并非如此，我们确定那是真的

00:09:45.530 --> 00:09:52.070
简单的五个更改文件，因此

00:09:48.320 --> 00:09:54.140
好吧，真的就是这些

00:09:52.070 --> 00:09:55.670
是我们发现的所有错误，并且

00:09:54.140 --> 00:09:57.500
然后我们基本上跑起来

00:09:55.670 --> 00:09:59.120
我们的服务，至少是我们提供的服务

00:09:57.500 --> 00:10:02.750
我们不是全部用灌浆

00:09:59.120 --> 00:10:04.760
我们做的很好

00:10:02.750 --> 00:10:07.250
我们开始回馈一点

00:10:04.760 --> 00:10:09.280
有点，这仍在进行中

00:10:07.250 --> 00:10:12.470
所以我开始做的一件事是因为

00:10:09.280 --> 00:10:14.840
你知道我什么时候幻灯片9不是

00:10:12.470 --> 00:10:17.060
出来，但现在是这样

00:10:14.840 --> 00:10:20.810
好的，如果我们有那9有东西

00:10:17.060 --> 00:10:22.850
称为紧凑型紧凑型琴弦， 

00:10:20.810 --> 00:10:27.560
实现是很多内在的

00:10:22.850 --> 00:10:30.650
代码很不幸，因为C 2 

00:10:27.560 --> 00:10:33.590
特别是C 1和某些

00:10:30.650 --> 00:10:36.740
学位无法保证安全

00:10:33.590 --> 00:10:39.050
实施并以一种很好的方式，所以他

00:10:36.740 --> 00:10:41.660
如果您要实施

00:10:39.050 --> 00:10:42.890
不安全的方法

00:10:41.660 --> 00:10:44.960
如果您曾经

00:10:42.890 --> 00:10:48.310
对它来说是内在的

00:10:44.960 --> 00:10:51.940
不幸的是，事实就是这样

00:10:48.310 --> 00:10:56.210
他们是一堆就地方法

00:10:51.940 --> 00:10:58.940
手动优化的SSE AVX avx-512 

00:10:56.210 --> 00:11:01.250
所以我们需要将其移植到

00:10:58.940 --> 00:11:03.650
获得相同的性能，以便我

00:11:01.250 --> 00:11:06.830
开始做，我从

00:11:03.650 --> 00:11:07.130
到目前为止，第一个是

00:11:06.830 --> 00:11:11.510
它

00:11:07.130 --> 00:11:15.530
哦是的字符串比较方法和

00:11:11.510 --> 00:11:16.970
你可以看到那仍然是

00:11:15.530 --> 00:11:19.880
案件，因为我还没有推

00:11:16.970 --> 00:11:21.680
所以如果你下载啊，你会得到这些

00:11:19.880 --> 00:11:23.480
得分，然后在底部看到

00:11:21.680 --> 00:11:24.950
特别是你知道第三行

00:11:23.480 --> 00:11:26.930
您看到的最大尺寸

00:11:24.950 --> 00:11:29.240
更快，那正是你的目的

00:11:26.930 --> 00:11:31.490
和C一起做，所以我刚刚展示了这个

00:11:29.240 --> 00:11:35.240
告诉你C 2是一样的表现

00:11:31.490 --> 00:11:37.490
我需要分开所有这些

00:11:35.240 --> 00:11:41.330
仍在为此工作，我需要添加

00:11:37.490 --> 00:11:44.330
当然是一个测试用例，我们可能想要

00:11:41.330 --> 00:11:48.040
使它与JDK两个一起工作，所以我们将

00:11:44.330 --> 00:11:50.210
看，然后他们就像三四

00:11:48.040 --> 00:11:54.500
他们更多，但他们在那里

00:11:50.210 --> 00:11:59.890
较小的井，我们会到达那里，所以数字

00:11:54.500 --> 00:12:05.570
我认为那是我有趣的部分

00:11:59.890 --> 00:12:07.730
选择了请客之一

00:12:05.570 --> 00:12:09.380
我们更大的不是最大的服务

00:12:07.730 --> 00:12:11.810
但这就像我第一个

00:12:09.380 --> 00:12:14.390
尝试过，所以我只是用那个

00:12:11.810 --> 00:12:17.270
并不重要，这是一个

00:12:14.390 --> 00:12:18.560
 finagle节俭服务，所以finagle是一个

00:12:17.270 --> 00:12:20.030
您可以的开源项目

00:12:18.560 --> 00:12:21.860
下载并签出

00:12:20.030 --> 00:12:23.210
我无法确切地告诉你这是什么

00:12:21.860 --> 00:12:27.020
因为我真的不知道，但是

00:12:23.210 --> 00:12:28.340
您知道的一些HTTP可以节省我很多钱

00:12:27.020 --> 00:12:33.770
请求，我会给你一些东西

00:12:28.340 --> 00:12:35.780
事物的类型，因此这100％ 

00:12:33.770 --> 00:12:38.170
像所有

00:12:35.780 --> 00:12:42.560
我们今天在熟料上跑的实例

00:12:38.170 --> 00:12:44.780
包括一堆其他服务

00:12:42.560 --> 00:12:46.010
仅限于DS，但也包括它们

00:12:44.780 --> 00:12:48.640
使用服务器参与社交活动

00:12:46.010 --> 00:12:51.320
服务或您所做的几乎所有事情

00:12:48.640 --> 00:12:53.780
在网络上还是在您的

00:12:51.320 --> 00:12:57.110
 Twitter客户端通过斗殴运行

00:12:53.780 --> 00:13:04.220
今天生成的代码，我认为

00:12:57.110 --> 00:13:06.440
可以正常工作，就像

00:13:04.220 --> 00:13:08.750
测试它特别棘手

00:13:06.440 --> 00:13:11.210
在数据中心，您首先了解

00:13:08.750 --> 00:13:13.610
有不同类型的机器

00:13:11.210 --> 00:13:16.040
不同的硬件，那么你有

00:13:13.610 --> 00:13:18.200
显然，不仅有一个进程在运行

00:13:16.040 --> 00:13:20.990
在机器上，所以你很吵

00:13:18.200 --> 00:13:24.140
邻居和类似的事情，所以

00:13:20.990 --> 00:13:27.230
我的测试设置是专用的

00:13:24.140 --> 00:13:32.630
一台机器完全一样

00:13:27.230 --> 00:13:36.590
我在30上使用JVM CI糖浆运行的硬件

00:13:32.630 --> 00:13:38.870
和Gras VM 0.22，这有点旧

00:13:36.590 --> 00:13:41.030
现在我想这是你的30年

00:13:38.870 --> 00:13:44.810
这样的事情我不记得了

00:13:41.030 --> 00:13:48.500
它仍然与我们的性能差不多

00:13:44.810 --> 00:13:51.530
我们做到了，您知道非常标准的分层

00:13:48.500 --> 00:13:55.730
设置，所以我们用c1进行编译，然后

00:13:51.530 --> 00:13:58.910
我们用咆哮作为

00:13:55.730 --> 00:14:02.000
顶级编译器与您的编译器对话

00:13:58.910 --> 00:14:03.380
而且就好像是什么

00:14:02.000 --> 00:14:07.250
你今天有下载吗

00:14:03.380 --> 00:14:11.630
甲骨文或OpenJDK，我们只是取代我们

00:14:07.250 --> 00:14:13.880
用那里的所有东西换掉CT 

00:14:11.630 --> 00:14:17.740
这是我不详述的事情

00:14:13.880 --> 00:14:20.360
在这里，但是因为Grodd是用Java编写的

00:14:17.740 --> 00:14:23.300
当您开始编译您的

00:14:20.360 --> 00:14:25.100
应用程序，然后开始编译您的

00:14:23.300 --> 00:14:28.310
顶级的第一个热门方法

00:14:25.100 --> 00:14:29.780
提款本身爬网将执行为

00:14:28.310 --> 00:14:35.240
 Java代码，然后将其编译

00:14:29.780 --> 00:14:37.610
本身就是你知道不能接受

00:14:35.240 --> 00:14:39.290
可以花一些时间来启动

00:14:37.610 --> 00:14:41.570
叫做Agora bootstrap的东西

00:14:39.290 --> 00:14:43.250
通常需要的命令行选项

00:14:41.570 --> 00:14:44.630
取决于您的机器和数量

00:14:43.250 --> 00:14:46.880
您正在使用的线程，但这需要

00:14:44.630 --> 00:14:48.110
您知道我们之间是十五岁还是

00:14:46.880 --> 00:14:51.980
三十秒钟左右

00:14:48.110 --> 00:14:56.420
所以如果你随它去就知道

00:14:51.980 --> 00:14:58.820
跑进去吃了二十秒钟

00:14:56.420 --> 00:15:00.980
您刚刚阅读的应用程序启动

00:14:58.820 --> 00:15:01.860
在您的第一分钟内

00:15:00.980 --> 00:15:04.200
某事

00:15:01.860 --> 00:15:06.840
但是对我们来说真的没关系

00:15:04.200 --> 00:15:09.210
因为我们启动了他们的服务

00:15:06.840 --> 00:15:10.830
无论如何都要热身

00:15:09.210 --> 00:15:12.600
与一群邻居交谈建立

00:15:10.830 --> 00:15:15.480
所有你知道的路线和联系

00:15:12.600 --> 00:15:17.910
什么都没有，所以从来没有，不是

00:15:15.480 --> 00:15:21.300
不像以前那样是一个问题

00:15:17.910 --> 00:15:23.130
因为有某种看门狗

00:15:21.300 --> 00:15:26.250
超时，以确保该服务

00:15:23.130 --> 00:15:28.290
实际上出现了，他们有一个很小的

00:15:26.250 --> 00:15:30.360
一点利润然后我们就推

00:15:28.290 --> 00:15:33.320
它超过边缘，但我们增加了

00:15:30.360 --> 00:15:36.240
几秒钟，一切都很酷，所以

00:15:33.320 --> 00:15:39.000
如果这对您来说对我们来说是一个问题

00:15:36.240 --> 00:15:41.100
目前还没有，但是在JDK 9中，您可以

00:15:39.000 --> 00:15:43.410
你可以编译ghrelin和所有这些

00:15:41.100 --> 00:15:48.090
消失了，但是因为我们在8跑

00:15:43.410 --> 00:15:51.060
我们不能这样做，所以这是一个

00:15:48.090 --> 00:15:54.540
每秒请求的天数，所以我

00:15:51.060 --> 00:15:56.970
只显示这张幻灯片，以便您可以

00:15:54.540 --> 00:15:58.680
相信我，他们所有人都能得到准确的

00:15:56.970 --> 00:16:00.600
同样的要求非常重要

00:15:58.680 --> 00:16:03.390
因为如果您知道一条推文，那就算了

00:16:00.600 --> 00:16:08.040
三个请求，并且该推文有一个

00:16:03.390 --> 00:16:11.160
字符或140个字符-80至80 

00:16:08.040 --> 00:16:12.600
字符差异很大

00:16:11.160 --> 00:16:15.120
您必须分配多少内存

00:16:12.600 --> 00:16:17.790
对，所以他们所有人都完全一样

00:16:15.120 --> 00:16:20.790
请求相同的推特ID等

00:16:17.790 --> 00:16:25.280
在专用机器上保存请求

00:16:20.790 --> 00:16:27.870
有24小时哦，是的，我不能

00:16:25.280 --> 00:16:31.500
您会注意到没有y轴

00:16:27.870 --> 00:16:35.040
因为我不能告诉你确切的

00:16:31.500 --> 00:16:39.180
明显的数字，但我们会讲一些

00:16:35.040 --> 00:16:41.880
相对数字，然后这样

00:16:39.180 --> 00:16:45.060
特定服务运行并行GC，并且

00:16:41.880 --> 00:16:47.310
这是底部的c2，您会看到

00:16:45.060 --> 00:16:52.020
颜色和编译器对，这是

00:16:47.310 --> 00:16:54.950
 c2这就是我们执行的清除周期

00:16:52.020 --> 00:16:58.260
这是16的移动平均线

00:16:54.950 --> 00:16:59.940
分钟，因为否则

00:16:58.260 --> 00:17:00.720
跳来跳去，但它给你一个

00:16:59.940 --> 00:17:04.560
好主意吧

00:17:00.720 --> 00:17:06.360
这已经长了，所以我们已经在保存

00:17:04.560 --> 00:17:12.000
这里相当多

00:17:06.360 --> 00:17:14.660
我也投了JDK 9只是为了展示

00:17:12.000 --> 00:17:16.520
你那差不多

00:17:14.660 --> 00:17:18.290
我必须没有把它放在

00:17:16.520 --> 00:17:22.130
幻灯片，但是当您得到什么

00:17:18.290 --> 00:17:24.170
下载带有Oracle JDK 9的打开JDK 9是

00:17:22.130 --> 00:17:26.950
不是我使用的畜栏版本

00:17:24.170 --> 00:17:30.200
我基本上在这里使用，因为当

00:17:26.950 --> 00:17:32.930
 JDK 9已准备就绪，您知道其中有一个

00:17:30.200 --> 00:17:33.680
有很长时间的下降阶段

00:17:32.930 --> 00:17:36.080
依此类推

00:17:33.680 --> 00:17:39.380
我认为它实际上是专业版

00:17:36.080 --> 00:17:41.300
在JDK 9中是从去年12月开始的，所以

00:17:39.380 --> 00:17:42.890
然后有一堆

00:17:41.300 --> 00:17:46.430
前几个月的改善

00:17:42.890 --> 00:17:47.960
所以今年我一直在用的是

00:17:46.430 --> 00:17:50.420
比你会得到的更好

00:17:47.960 --> 00:17:53.750
您今天就下载了，但是您可以转到

00:17:50.420 --> 00:17:57.650
 github转到内置的Groth下载

00:17:53.750 --> 00:17:59.000
该模块添加了一堆时髦

00:17:57.650 --> 00:18:01.280
命令行参数，您将获得

00:17:59.000 --> 00:18:02.630
这真的只是为了展示同样的事情

00:18:01.280 --> 00:18:06.380
八个之间没有区别

00:18:02.630 --> 00:18:09.800
和九，咆哮，正如你所看到的

00:18:06.380 --> 00:18:12.200
一样，所以我们已经保存在那里

00:18:09.800 --> 00:18:14.780
因此，如果我们不必这样做，这意味着

00:18:12.200 --> 00:18:17.840
首先有两件事，我们是

00:18:14.780 --> 00:18:19.820
节省垃圾收集时间，但是

00:18:17.840 --> 00:18:21.920
更重要的是

00:18:19.820 --> 00:18:24.620
因为我们实际上没有生产

00:18:21.920 --> 00:18:26.090
我们生产了多少垃圾

00:18:24.620 --> 00:18:28.640
更好的代码和转义分析工作

00:18:26.090 --> 00:18:32.150
更好的是这是我们真正想要的

00:18:28.640 --> 00:18:36.260
所以我们得到的时候就像负载很高

00:18:32.150 --> 00:18:42.620
我们的清理周期减少了2.7％ 

00:18:36.260 --> 00:18:46.250
底部是2.5，比方说2.5 

00:18:42.620 --> 00:18:49.820
下巴是这个问题，我

00:18:46.250 --> 00:18:53.480
让他们受益匪浅，我想吉姆

00:18:49.820 --> 00:18:54.770
做到了，我也做到了

00:18:53.480 --> 00:18:56.510
没有非常好的指标可显示

00:18:54.770 --> 00:18:58.160
那只是我告诉你和你

00:18:56.510 --> 00:19:00.920
必须相信我，但就是这样

00:18:58.160 --> 00:19:02.660
对元数据来说也是一样的

00:19:00.920 --> 00:19:04.100
加载一堆类中有一个

00:19:02.660 --> 00:19:06.860
一堆你必须分配的方法

00:19:04.100 --> 00:19:10.520
一些元数据，但不是让人发狂

00:19:06.860 --> 00:19:14.180
正确，他们说等待下一张幻灯片是

00:19:10.520 --> 00:19:16.820
大约40 40兆字节，但人

00:19:14.180 --> 00:19:18.980
吓坏了，因为他们认为这一切

00:19:16.820 --> 00:19:21.590
会长大，不，是这样，是

00:19:18.980 --> 00:19:23.600
 40如果老下巴永远不会改变

00:19:21.590 --> 00:19:25.640
是200兆，将是40兆

00:19:23.600 --> 00:19:26.800
下巴是10演出，将是40 

00:19:25.640 --> 00:19:29.380
没有区别

00:19:26.800 --> 00:19:32.110
而且咆哮不会突然增长

00:19:29.380 --> 00:19:37.000
里面什么都只有它

00:19:32.110 --> 00:19:38.559
状态，就是这样，这就是

00:19:37.000 --> 00:19:41.770
重要的一项权利是

00:19:38.559 --> 00:19:46.510
关于CP q10的整个话题，让我们来看看

00:19:41.770 --> 00:19:50.260
这个爬行现在有一个原地

00:19:46.510 --> 00:19:52.450
令人惊讶的是，您知道可以

00:19:50.260 --> 00:19:58.210
发生的是，特别是当你

00:19:52.450 --> 00:20:00.340
奔跑着，在对线的决定中可以

00:19:58.210 --> 00:20:02.620
每次跑都不同，所以我认为

00:20:00.340 --> 00:20:04.840
那就是我不认为c2是

00:20:02.620 --> 00:20:08.679
实际上在GT k9中更好，我认为

00:20:04.840 --> 00:20:10.480
对此做出了更明智的决定

00:20:08.679 --> 00:20:14.320
实例-在一行上然后

00:20:10.480 --> 00:20:18.460
之前和那是卡尔·猎豹k9一样

00:20:14.320 --> 00:20:24.730
现在我可以告诉你为什么X是正确的- 

00:20:18.460 --> 00:20:29.590
就是这样，我们节省了11％ 

00:20:24.730 --> 00:20:30.970
 CPU的数量巨大，我的意思是我不知道

00:20:29.590 --> 00:20:33.460
有多少个编译器工程师

00:20:30.970 --> 00:20:35.080
房间，但如果您曾经在

00:20:33.460 --> 00:20:38.230
编译器并尝试做点什么

00:20:35.080 --> 00:20:41.080
更快更好地了解你

00:20:38.230 --> 00:20:42.820
你在那儿爬来爬去

00:20:41.080 --> 00:20:46.860
百分比范围，你就是超级

00:20:42.820 --> 00:20:50.020
如果很高兴-正确的11是荒谬的

00:20:46.860 --> 00:20:52.210
所以我从没想到我会这样

00:20:50.020 --> 00:20:55.690
当我加入Twitter时，我提出了这个建议

00:20:52.210 --> 00:20:58.630
哦，看起来有一个可以编译的想法

00:20:55.690 --> 00:21:00.100
这是一个Oracle实验室研究项目，否

00:20:58.630 --> 00:21:02.679
一个人曾经在生产中使用过它

00:21:00.100 --> 00:21:04.980
以前，但我认为这会帮助我们

00:21:02.679 --> 00:21:07.480
美国让我们一起尝试

00:21:04.980 --> 00:21:10.840
超级累了，否则就解决了

00:21:07.480 --> 00:21:15.180
那将是现在没有工作

00:21:10.840 --> 00:21:19.140
那么多少

00:21:15.180 --> 00:21:20.640
我显然不能告诉你，但我们不能

00:21:19.140 --> 00:21:21.990
你知道只是随机组成

00:21:20.640 --> 00:21:24.870
数字，至少可以体会到

00:21:21.990 --> 00:21:27.420
没错，所以假设您有一个

00:21:24.870 --> 00:21:30.210
公司，而您正在托管您的

00:21:27.420 --> 00:21:33.809
在云中的东西，所以我当时

00:21:30.210 --> 00:21:36.000
输入云托管服务价格

00:21:33.809 --> 00:21:38.640
可能进入了Google及其他人

00:21:36.000 --> 00:21:40.830
弹出，他们都有不同的价格

00:21:38.640 --> 00:21:42.630
以及计算它们的不同方法

00:21:40.830 --> 00:21:46.670
并展示给你，基本上我做了

00:21:42.630 --> 00:21:51.150
您的计算就像

00:21:46.670 --> 00:21:55.920
每年每对$ 170，一个CPU内核-否

00:21:51.150 --> 00:21:58.290
等到72到210左右

00:21:55.920 --> 00:21:59.850
选择您的云提供商副李，这是

00:21:58.290 --> 00:22:02.250
有很大的不同

00:21:59.850 --> 00:22:08.190
所以说平均数

00:22:02.250 --> 00:22:12.150
是每个CPU每年100 $ 27，因此

00:22:08.190 --> 00:22:15.750
显然你有多少夸脱

00:22:12.150 --> 00:22:20.190
我说过您较早了解Twitter 

00:22:15.750 --> 00:22:23.730
有很多你可能没有，但实际上

00:22:20.190 --> 00:22:26.370
没关系，因为哦，等等

00:22:23.730 --> 00:22:30.179
不，我不想去那里，因为

00:22:26.370 --> 00:22:33.450
公司的规模也与

00:22:30.179 --> 00:22:35.610
您的收入是否正确，如果

00:22:33.450 --> 00:22:38.190
你有两个服务器，你必须

00:22:35.610 --> 00:22:41.040
好吧-我的结局够了，但说

00:22:38.190 --> 00:22:43.980
您有10个，您必须花费$ 2,000 

00:22:41.040 --> 00:22:47.190
如果他们可以节省10％，一年

00:22:43.980 --> 00:22:50.130
 200美元，如果它在你会很高兴

00:22:47.190 --> 00:22:53.550
数以百万计的是很多钱

00:22:50.130 --> 00:22:55.860
对我们而言，但对公司而言，仍然

00:22:53.550 --> 00:22:58.350
只有百分之十的权利，所以它不是

00:22:55.860 --> 00:23:03.690
真的很重要，但是你知道

00:22:58.350 --> 00:23:05.880
感受事物有多大， 

00:23:03.690 --> 00:23:08.490
老实说我什至不知道有多大

00:23:05.880 --> 00:23:10.440
推特是，但有一篇文章

00:23:08.490 --> 00:23:12.030
我发现这是你可以的

00:23:10.440 --> 00:23:13.620
谷歌，也许甚至有一篇文章

00:23:12.030 --> 00:23:14.700
关于Twitter，我们有多少台服务器

00:23:13.620 --> 00:23:16.890
不知道

00:23:14.700 --> 00:23:19.590
那是从2014年开始的，所以已经是三个

00:23:16.890 --> 00:23:21.270
岁，他们在谈论两个

00:23:19.590 --> 00:23:24.090
一百万台服务器，他们说了些什么

00:23:21.270 --> 00:23:25.639
从数据中心五十到八十

00:23:24.090 --> 00:23:33.339
千台服务器和

00:23:25.639 --> 00:23:33.339
我不知道24核那么多

00:23:33.489 --> 00:23:39.769
您的公司肯定比

00:23:35.749 --> 00:23:41.539
 Google，我认为是，所以我会选择

00:23:39.769 --> 00:23:43.669
随机，但有10,000台服务器

00:23:41.539 --> 00:23:46.999
认为这是合理的

00:23:43.669 --> 00:23:48.559
每个通常是24核，或者您乘以

00:23:46.999 --> 00:23:52.369
那三百万美元

00:23:48.559 --> 00:23:55.579
付钱只是为了经营自己的东西

00:23:52.369 --> 00:23:56.019
有权利，您可以节省11％ 

00:23:55.579 --> 00:23:58.099
那

00:23:56.019 --> 00:24:00.349
这比这里的薪水还多

00:23:58.099 --> 00:24:08.799
湾区，所以您知道您可以租一个

00:24:00.349 --> 00:24:14.149
更多的人，所以我们可以节省更多

00:24:08.799 --> 00:24:15.950
可能我只是你知道

00:24:14.149 --> 00:24:17.659
花了一个下午真的在玩弄

00:24:15.950 --> 00:24:20.509
格罗斯（Groth）有很多着陆点

00:24:17.659 --> 00:24:25.940
参数，就像c2一样，所以我正在巡回演出

00:24:20.509 --> 00:24:29.089
到处都是我最好的一面

00:24:25.940 --> 00:24:30.859
要求，我做了一个实验

00:24:29.089 --> 00:24:35.599
你知道这只是

00:24:30.859 --> 00:24:38.629
我的专用集群，所以这

00:24:35.599 --> 00:24:41.779
是我们以前见过的，这是我的

00:24:38.629 --> 00:24:46.869
实验，这样我们就可以减少清理工作

00:24:41.779 --> 00:24:52.399
再次循环，减少约1.5％ 

00:24:46.869 --> 00:24:58.070
这是相当多的时间和CPU时间

00:24:52.399 --> 00:25:04.909
等于这一点，在

00:24:58.070 --> 00:25:07.940
比率我们不是2％，那

00:25:04.909 --> 00:25:10.700
真的只有四个小时

00:25:07.940 --> 00:25:14.359
只是随机选择衬里号码

00:25:10.700 --> 00:25:18.019
对，所以我认为有很多

00:25:14.359 --> 00:25:20.779
更多，您可以获得，您可能无法

00:25:18.019 --> 00:25:23.479
至少要得到它

00:25:20.779 --> 00:25:26.059
这是我目前的想法

00:25:23.479 --> 00:25:28.289
在这里提到，但我想我忘了我只是

00:25:26.059 --> 00:25:31.029
现在提到

00:25:28.289 --> 00:25:33.399
 Twitter VN团队中我团队中的人

00:25:31.029 --> 00:25:35.349
他们实际上正在努力，如果得到

00:25:33.399 --> 00:25:39.879
礼物做了演讲，我想

00:25:35.349 --> 00:25:44.080
将其链接到称为自动调谐的内容

00:25:39.879 --> 00:25:47.459
那你可以告诉机器

00:25:44.080 --> 00:25:49.749
要学习的东西，尝试不同

00:25:47.459 --> 00:25:51.609
 cbn参数并告诉您哪个

00:25:49.749 --> 00:25:53.859
最好的，这就是我们想要的

00:25:51.609 --> 00:25:55.419
尝试告诉你哦

00:25:53.859 --> 00:25:57.639
尝试这些方法来学习从A到

00:25:55.419 --> 00:25:59.229
 B，你知道玩

00:25:57.639 --> 00:26:00.999
机器学习一点，然后

00:25:59.229 --> 00:26:03.429
还给我什么是最好的

00:26:00.999 --> 00:26:06.849
我们想做什么，但在这一点上，我

00:26:03.429 --> 00:26:10.119
觉得内联政策

00:26:06.849 --> 00:26:12.329
那不是Gras的默认值

00:26:10.119 --> 00:26:16.779
正确的选择，我认为我们必须

00:26:12.329 --> 00:26:22.419
可能写我们自己来变得更好

00:26:16.779 --> 00:26:28.389
数字，这可能对

00:26:22.419 --> 00:26:32.769
你在某种程度上很重要

00:26:28.389 --> 00:26:34.570
我们也是，但在这一点上，你知道我们是

00:26:32.769 --> 00:26:37.239
很高兴，我们有一个编译器

00:26:34.570 --> 00:26:39.249
我们有自己的VM团队，我们有一个

00:26:37.239 --> 00:26:42.729
一群可以解决问题的人

00:26:39.249 --> 00:26:45.519
如果他们出现了，我想你们所有人都有

00:26:42.729 --> 00:26:48.059
您自己的VM团队，因此您可能会

00:26:45.519 --> 00:26:54.759
对官方支持感兴趣

00:26:48.059 --> 00:26:58.570
是的，我们会看到你知道JD犬有

00:26:54.759 --> 00:27:04.079
 Gras因为JDK 9中的ante解决方案

00:26:58.570 --> 00:27:07.359
实际使用Gras而不是

00:27:04.079 --> 00:27:09.759
甲骨文宣布，您可以

00:27:07.359 --> 00:27:11.019
实际使用那个咆哮声

00:27:09.759 --> 00:27:14.799
那实际上是在切诺基

00:27:11.019 --> 00:27:17.320
用它作为鸡肉拼盘

00:27:14.799 --> 00:27:19.869
一个实验性的选择，这就是为什么他们

00:27:17.320 --> 00:27:25.029
没有宣布，甚至没有宣布

00:27:19.869 --> 00:27:27.580
所以嘿，你不能用它

00:27:25.029 --> 00:27:32.679
指出它不受支持

00:27:27.580 --> 00:27:36.269
但是，这封电子邮件上有

00:27:32.679 --> 00:27:37.539
邮件列表看起来完全天真

00:27:36.269 --> 00:27:40.570
对

00:27:37.539 --> 00:27:42.730
只是说好吧，让我们建立交叉我们

00:27:40.570 --> 00:27:45.070
不管您是否建造它都爬行

00:27:42.730 --> 00:27:46.779
是否有一个重要的

00:27:45.070 --> 00:27:50.799
这里的句子让我放大

00:27:46.779 --> 00:27:52.330
他们想做的一种

00:27:50.799 --> 00:27:56.499
实验鸡酱下一个

00:27:52.330 --> 00:27:59.499
释放当时是

00:27:56.499 --> 00:28:02.830
发送甲骨文没有宣布新

00:27:59.499 --> 00:28:05.169
释放节奏，所以这句话会

00:28:02.830 --> 00:28:09.429
是切尼的意思，我很确定

00:28:05.169 --> 00:28:12.129
如果今天意味着18.3，那么今天意味着什么

00:28:09.429 --> 00:28:15.309
不然我们会看到我唯一的

00:28:12.129 --> 00:28:18.190
知道是我的JDK 9版本

00:28:15.309 --> 00:28:20.529
会在JDK 9中看到合唱版本

00:28:18.190 --> 00:28:22.149
我使用的基本上回来了

00:28:20.529 --> 00:28:25.809
移植了所有猎豹的戒烟改变

00:28:22.149 --> 00:28:27.249
从上游出发我没有

00:28:25.809 --> 00:28:28.600
想要自己说，我只是拿了

00:28:27.249 --> 00:28:30.549
像他们一样去欧洲

00:28:28.600 --> 00:28:33.850
干净地涂抹，就是这样

00:28:30.549 --> 00:28:36.009
现在打开JDK的主线是

00:28:33.850 --> 00:28:39.669
我正在使用的咆哮版本

00:28:36.009 --> 00:28:42.190
可能是18.3或18.9，所以您

00:28:39.669 --> 00:28:45.269
可能要等一年，但是我

00:28:42.190 --> 00:28:48.789
想说的是我想我们会得到

00:28:45.269 --> 00:28:52.919
官方支持很快，所以如果你

00:28:48.789 --> 00:28:55.509
想今天一起玩

00:28:52.919 --> 00:28:58.690
我们在生产中运行它，我们没有

00:28:55.509 --> 00:29:00.820
问题可能是您知道较小

00:28:58.690 --> 00:29:02.919
您遇到的错误，但是有一个

00:29:00.820 --> 00:29:06.730
为此，您提交了一个错误，并且

00:29:02.919 --> 00:29:09.220
 github，将被修复，所以你呢

00:29:06.730 --> 00:29:12.340
想省些钱就可以做到

00:29:09.220 --> 00:29:14.830
这样我不是说每个人都会

00:29:12.340 --> 00:29:17.350
得到10％的权利我不是说那

00:29:14.830 --> 00:29:20.379
有可能你

00:29:17.350 --> 00:29:22.590
可以，我认为那不是我的最后一次

00:29:20.379 --> 00:29:26.100
实际如此滑动

00:29:22.590 --> 00:29:28.740
试试看，这真的是这个

00:29:26.100 --> 00:29:30.899
不是我的讯息我要去找你

00:29:28.740 --> 00:29:33.629
我知道我会跟那个路演

00:29:30.899 --> 00:29:36.029
希望人们知道它实际上

00:29:33.629 --> 00:29:39.419
我不知道

00:29:36.029 --> 00:29:41.009
据我所知，李是我们唯一的

00:29:39.419 --> 00:29:42.299
在生产中实际使用它的人

00:29:41.009 --> 00:29:44.100
可能有公司在那里

00:29:42.299 --> 00:29:46.980
我不知道的地方

00:29:44.100 --> 00:29:48.419
较小的公司，但我认为

00:29:46.980 --> 00:29:51.179
更大的规模是我们唯一的

00:29:48.419 --> 00:29:56.759
正在这样做，对我们很有用

00:29:51.179 --> 00:29:58.769
而且我们是我们想要移动我们所有的

00:29:56.759 --> 00:30:01.200
服务增长我不确定

00:29:58.769 --> 00:30:02.700
什么时候会发生，但你知道那里

00:30:01.200 --> 00:30:06.360
将是一个奇怪的，将无法正常工作

00:30:02.700 --> 00:30:10.830
或会慢一些，或者谁知道，但是

00:30:06.360 --> 00:30:13.379
我们想到达那里，因为到目前为止

00:30:10.830 --> 00:30:15.059
就像我之前说的，我们有成千上万

00:30:13.379 --> 00:30:19.350
到目前为止我不知道有多少台服务器

00:30:15.059 --> 00:30:20.879
我们已经转换了，甚至可能还不到20 

00:30:19.350 --> 00:30:23.429
我们从大公司开始，因为

00:30:20.879 --> 00:30:26.460
在那里您可以获得最多的节省，但仍然

00:30:23.429 --> 00:30:29.279
较小的加起来，所以

00:30:26.460 --> 00:30:31.789
我们每年节省的美元将

00:30:29.279 --> 00:30:34.619
完成后变成两倍或三倍

00:30:31.789 --> 00:30:39.919
如果你发推特，那就是整件事

00:30:34.619 --> 00:30:39.919
关于这一点，请让我的团队知道谢谢

00:30:39.990 --> 00:30:48.750
 [掌声] 

00:30:45.750 --> 00:30:48.750
题

00:31:01.980 --> 00:31:06.250
如果内联取决于cpu否否

00:31:05.380 --> 00:31:08.110
真的不

00:31:06.250 --> 00:31:10.090
我知道我们之前聊过一点

00:31:08.110 --> 00:31:14.410
一点点，所以我想我知道

00:31:10.090 --> 00:31:21.310
你的目标是让咆哮声有支持

00:31:14.410 --> 00:31:27.340
对于某些矢量指令集

00:31:21.310 --> 00:31:29.980
不是我该怎么说一件事

00:31:27.340 --> 00:31:32.290
至少在咆哮中缺少

00:31:29.980 --> 00:31:35.500
开源版本不是

00:31:32.290 --> 00:31:38.590
 c2具有的所有向量

00:31:35.500 --> 00:31:40.090
对我们来说，到目前为止没有关系

00:31:38.590 --> 00:31:43.060
可能是我不知道的服务

00:31:40.090 --> 00:31:44.920
但这将需要它，然后我们有了

00:31:43.060 --> 00:31:46.900
做一些事情，但今天

00:31:44.920 --> 00:31:50.680
不进行矢量化，但是

00:31:46.900 --> 00:31:52.390
并不意味着它没有使用向量

00:31:50.680 --> 00:31:56.130
其他类型的说明

00:31:52.390 --> 00:31:56.130
事情不是矢量化循环

00:32:00.770 --> 00:32:02.800
哦

00:32:04.899 --> 00:32:11.359
是的，它通常可以以某种方式

00:32:08.659 --> 00:32:14.559
不，但是你知道衬里是

00:32:11.359 --> 00:32:17.359
只是这条路在

00:32:14.559 --> 00:32:20.059
将其推到方法的边缘

00:32:17.359 --> 00:32:21.369
变得太大了吧，因为

00:32:20.059 --> 00:32:25.970
指令缓存基本上是

00:32:21.369 --> 00:32:28.549
因此，但我并没有真正

00:32:25.970 --> 00:32:30.350
遵循指令缓存的方式

00:32:28.549 --> 00:32:33.549
今天，但他们都为

00:32:30.350 --> 00:32:33.549
我身上的尺码一样

00:32:41.160 --> 00:32:44.160
对

00:32:44.520 --> 00:32:54.179
我不是没有我的原因是

00:32:50.250 --> 00:32:54.920
因为你知道我基本上是最后一个

00:32:54.179 --> 00:32:57.480
年

00:32:54.920 --> 00:32:59.220
除了您知道准备JDK和

00:32:57.480 --> 00:33:00.720
我把东西放进去，包括

00:32:59.220 --> 00:33:03.120
把它放在鸡里会让你知道测试它

00:33:00.720 --> 00:33:04.980
为了确保它能正常工作，我花了

00:33:03.120 --> 00:33:08.340
我大部分时间都是手工服务

00:33:04.980 --> 00:33:10.500
业主，就好像您去了

00:33:08.340 --> 00:33:12.360
服务器zona，他负责

00:33:10.500 --> 00:33:14.700
事情要起来，你会进入

00:33:12.360 --> 00:33:16.230
麻烦，当Twitter关闭，然后

00:33:14.700 --> 00:33:18.540
你去找他们说嘿，我有

00:33:16.230 --> 00:33:21.750
记住没有人使用过它

00:33:18.540 --> 00:33:24.360
在你想尝试之前，是的，我

00:33:21.750 --> 00:33:28.380
花大部分时间进行社会工程

00:33:24.360 --> 00:33:29.970
比实际工程要多，所以我没有

00:33:28.380 --> 00:33:32.420
没有时间，但是应该

00:33:29.970 --> 00:33:32.420
做完了

00:33:40.220 --> 00:33:49.350
对，我也不太了解，但我

00:33:47.759 --> 00:33:51.299
可以肯定的是，大部分节省

00:33:49.350 --> 00:33:54.090
我们看到的是因为我们只是

00:33:51.299 --> 00:33:55.470
分配更少的内存并添加

00:33:54.090 --> 00:33:59.490
意味着您可以获得更严格的代码

00:33:55.470 --> 00:34:01.379
不必知道您要致电到

00:33:59.490 --> 00:34:03.360
运行时分配代码，依此类推

00:34:01.379 --> 00:34:05.850
依此类推，这样您的代码就可以

00:34:03.360 --> 00:34:07.470
我当时有点紧

00:34:05.850 --> 00:34:11.129
想着我不应该跑步

00:34:07.470 --> 00:34:12.750
这个实验真的关闭了逃生

00:34:11.129 --> 00:34:29.819
分析两个竞争对手，看看是否

00:34:12.750 --> 00:34:31.260
改变了我所能拥有的一切

00:34:29.819 --> 00:34:33.000
不确定是否还有其他谈论

00:34:31.260 --> 00:34:38.819
企业今年在JavaOne上进行爬网

00:34:33.000 --> 00:34:41.010
但基本上是Oracle实验室

00:34:38.819 --> 00:34:45.780
这是开源的纯附件

00:34:41.010 --> 00:34:49.349
版本，据我所知

00:34:45.780 --> 00:34:52.079
知道矢量化支持，它具有

00:34:49.349 --> 00:34:55.980
据我所知，更好的内联

00:34:52.079 --> 00:34:59.670
尝试过我没有提供数字

00:34:55.980 --> 00:35:01.619
在这次演讲中，但我之前已经做过

00:34:59.670 --> 00:35:03.480
我以前的演讲在某个地方

00:35:01.619 --> 00:35:06.270
实际显示的价格在价格范围内

00:35:03.480 --> 00:35:09.900
爬行也很令人印象深刻

00:35:06.270 --> 00:35:11.490
所以我上周刚尝试过

00:35:09.900 --> 00:35:13.859
其实又是因为我想看

00:35:11.490 --> 00:35:17.430
今天的位置，但我认为那是

00:35:13.859 --> 00:35:23.549
就像您看到的11％的企业爬网一样

00:35:17.430 --> 00:35:27.530
认为是22岁，这也意味着我

00:35:23.549 --> 00:35:32.090
知道我们还能得到更多

00:35:27.530 --> 00:35:39.770
这样您之前看到的$ 300,000 

00:35:32.090 --> 00:35:41.660
现在是600还是可以的，是的

00:35:39.770 --> 00:35:44.660
它不是开源的，这是一个

00:35:41.660 --> 00:35:49.520
您必须付费的商业产品

00:35:44.660 --> 00:35:51.670
但是，是的，我取决于

00:35:49.520 --> 00:35:54.530
您从Oracle um获得的许可证

00:35:51.670 --> 00:35:56.780
您的谈判技巧更多

00:35:54.530 --> 00:35:59.390
那对你很重要，我想但是

00:35:56.780 --> 00:36:01.340
如果您所付的钱少

00:35:59.390 --> 00:36:03.400
比省下的钱要多

00:36:01.340 --> 00:36:03.400
它

00:36:20.750 --> 00:36:27.680
反对工作量哦，是的，那是

00:36:25.560 --> 00:36:27.680
真正

00:36:34.800 --> 00:36:39.730
这是一个很好的问题，我不能

00:36:37.960 --> 00:36:44.890
真的回答，因为Twitter是

00:36:39.730 --> 00:36:48.610
像95％的Scala，我一无所知

00:36:44.890 --> 00:36:50.800
实际写成100％的服务

00:36:48.610 --> 00:36:53.830
 Java，因为我们的大多数服务都在运行

00:36:50.800 --> 00:36:57.640
在finagle上，这只是基本框架

00:36:53.830 --> 00:37:01.150
那是用Scala写的，所以你知道我

00:36:57.640 --> 00:37:05.080
不知道可能不会那么多

00:37:01.150 --> 00:37:08.080
我真的不是学者专家，但来自

00:37:05.080 --> 00:37:10.510
谣言在这里是它分配

00:37:08.080 --> 00:37:13.780
比Scala还要更多的临时对象

00:37:10.510 --> 00:37:17.200
除了Java之外， 

00:37:13.780 --> 00:37:18.880
解释为什么我们看到你了解得更少

00:37:17.200 --> 00:37:20.350
清理周期，我们分配更少的内存

00:37:18.880 --> 00:37:23.670
因为因为所有这些临时的

00:37:20.350 --> 00:37:31.530
内联更好的一天

00:37:23.670 --> 00:37:33.220
秤已更换，所以我不确定是否可以

00:37:31.530 --> 00:37:35.620
可能不是棕褐色

00:37:33.220 --> 00:37:37.830
但是如果你得到5，我的意思是

00:37:35.620 --> 00:37:37.830
惊人

00:37:47.990 --> 00:37:52.980
是的，我提起了一堆

00:37:50.490 --> 00:37:56.850
就像其他所有语言一样

00:37:52.980 --> 00:37:59.160
我们用它们还不够大

00:37:56.850 --> 00:38:01.980
使用其他语言处理不同的事情

00:37:59.160 --> 00:38:03.930
但它没有什么比它大

00:38:01.980 --> 00:38:06.530
一切都在

00:38:03.930 --> 00:38:11.700
像Scala这样的JVM有点Java 

00:38:06.530 --> 00:38:15.270
所以我不这么认为

00:38:11.700 --> 00:38:18.090
你的想法知道我们有时

00:38:15.270 --> 00:38:21.390
这些奇怪的语言只运行

00:38:18.090 --> 00:38:23.250
我们可能在

00:38:21.390 --> 00:38:23.880
某个时间点就是

00:38:23.250 --> 00:38:26.760
过时的

00:38:23.880 --> 00:38:29.610
谁知道什么版本的Python 

00:38:26.760 --> 00:38:30.360
如果我们能知道的话会很好

00:38:29.610 --> 00:38:31.830
我的曾父

00:38:30.360 --> 00:38:34.850
到JVM，然后我们可以利用

00:38:31.830 --> 00:38:34.850
像松露耶

00:38:42.960 --> 00:38:45.960
是的

00:38:49.470 --> 00:38:56.830
没错，所以我故意把它排除在外

00:38:54.610 --> 00:38:58.570
因为那是另一个霍尔特

00:38:56.830 --> 00:39:01.450
谈论这个所以有

00:38:58.570 --> 00:39:03.820
拥有编译器的两个主要问题

00:39:01.450 --> 00:39:05.620
用Java编写的，一个是

00:39:03.820 --> 00:39:08.140
我简要介绍的自举问题

00:39:05.620 --> 00:39:12.100
感动，另一个是

00:39:08.140 --> 00:39:15.510
 Java堆分配问题

00:39:12.100 --> 00:39:18.460
一个人的主要问题是你什么时候

00:39:15.510 --> 00:39:20.770
稍后在您的运行和应用程序中

00:39:18.460 --> 00:39:23.020
已经完全使用了所有

00:39:20.770 --> 00:39:24.610
你的堆，因为每个人都紧紧地

00:39:23.020 --> 00:39:26.320
调整应用程序的堆

00:39:24.610 --> 00:39:28.570
恰好适合堆

00:39:26.320 --> 00:39:31.060
如果你那么每个人都会做什么

00:39:28.570 --> 00:39:32.740
突然会得到我不知道是否

00:39:31.060 --> 00:39:34.900
每个人都知道什么是去优化

00:39:32.740 --> 00:39:36.580
但是如果你突然不得不踢出一个

00:39:34.900 --> 00:39:39.430
编译方法并重新编译

00:39:36.580 --> 00:39:41.380
它可能会把你踢过来

00:39:39.430 --> 00:39:46.060
边界，让您记忆犹新

00:39:41.380 --> 00:39:48.520
以及今天的方式

00:39:46.060 --> 00:39:51.370
记忆时代可能会结束他的任何地方

00:39:48.520 --> 00:39:53.650
如果您在编译器中很幸运，可以

00:39:51.370 --> 00:39:54.730
但是通常你不想结束

00:39:53.650 --> 00:39:58.510
在应用程序和应用程序中

00:39:54.730 --> 00:40:00.250
下降，所以这是一个问题，原因

00:39:58.510 --> 00:40:02.740
为什么你在这里什么都看不到

00:40:00.250 --> 00:40:04.840
因为所有这些通常都在编译

00:40:02.740 --> 00:40:07.720
发生在最初的几分钟

00:40:04.840 --> 00:40:12.370
我们至少要运行一天的服务

00:40:07.720 --> 00:40:14.770
或游戏稍后的几天

00:40:12.370 --> 00:40:18.340
你真的有汇编

00:40:14.770 --> 00:40:23.500
有时候，但对我们来说，这并不大

00:40:18.340 --> 00:40:26.620
问题，我们的意思是像Twitter这样

00:40:23.500 --> 00:40:30.670
您知道的完美的温床

00:40:26.620 --> 00:40:32.920
试试这个编译器，因为几乎

00:40:30.670 --> 00:40:34.690
 Twitter所做的一切，除了

00:40:32.920 --> 00:40:37.900
后台数据库是无状态的

00:40:34.690 --> 00:40:39.630
对，您必须处理您加载的请求

00:40:37.900 --> 00:40:43.090
把它放回原处

00:40:39.630 --> 00:40:46.630
安全一些状态，所以一切

00:40:43.090 --> 00:40:49.240
发生在年轻一代中

00:40:46.630 --> 00:40:51.160
如果你分配一点

00:40:49.240 --> 00:40:53.980
那你必须做个收藏耶

00:40:51.160 --> 00:40:55.840
好吧，对我们来说从来没有

00:40:53.980 --> 00:40:58.200
问题，是的，这是值得思考的

00:40:55.840 --> 00:40:58.200
关于耶

00:41:00.000 --> 00:41:05.770
还有更多问题

00:41:02.940 --> 00:41:08.860
好哒。谢谢你们

00:41:05.770 --> 00:41:08.860
 [掌声] 

