WEBVTT
Kind: captions
Language: zh-Hans

00:00:03.210 --> 00:00:09.330
看到我们还有大约30秒

00:00:05.970 --> 00:00:12.629
在时间之前但只是出于兴趣

00:00:09.330 --> 00:00:14.789
你们几个是多少个

00:00:12.629 --> 00:00:18.810
你有这是第一个Java人

00:00:14.789 --> 00:00:24.119
他们曾经去冷却过多少

00:00:18.810 --> 00:00:29.609
以前去过另一个人所以

00:00:24.119 --> 00:00:34.099
音频，您可以测试后盖吗

00:00:29.609 --> 00:00:34.099
你们现在在后面听到我更好

00:00:35.210 --> 00:00:41.610
我会大声说一声达到

00:00:39.290 --> 00:00:43.050
好吧，我会尝试大声一点

00:00:41.610 --> 00:00:46.820
声音，但是如果你能接听的话

00:00:43.050 --> 00:00:46.820
那里很少，因为那高于正常水平

00:00:51.380 --> 00:00:57.750
好，看到这么多新鲜

00:00:54.360 --> 00:01:01.020
第一次使用Java是一个

00:00:57.750 --> 00:01:04.559
通常为观众带来有趣的组合

00:01:01.020 --> 00:01:07.740
我们得到大约3/4到1/4的比例，但是

00:01:04.559 --> 00:01:09.480
是我们要谈论的好话题

00:01:07.740 --> 00:01:10.260
就在那儿，希望你在

00:01:09.480 --> 00:01:13.230
合适的房间

00:01:10.260 --> 00:01:17.310
我很内na，我们在谈论垃圾

00:01:13.230 --> 00:01:20.820
 Java中的集合，仅用于设置

00:01:17.310 --> 00:01:23.730
对顶部的正确期望

00:01:20.820 --> 00:01:27.540
至少有一点回声

00:01:23.730 --> 00:01:34.370
给我树立正确​​的期望

00:01:27.540 --> 00:01:38.820
谈论这不是一个如何调整GC 

00:01:34.370 --> 00:01:43.170
谈论本演讲重点在于GC 

00:01:38.820 --> 00:01:46.380
工作机器的工作方式或

00:01:43.170 --> 00:01:47.970
机制起作用，想法是，如果

00:01:46.380 --> 00:01:50.790
你能明白什么垃圾

00:01:47.970 --> 00:01:53.510
集合在

00:01:50.790 --> 00:01:56.220
各个阶段和技术

00:01:53.510 --> 00:01:59.850
术语，然后您可以申请

00:01:56.220 --> 00:02:04.240
您自己的大脑进行调音练习

00:01:59.850 --> 00:02:07.210
真的是这样，而不是给你一套

00:02:04.240 --> 00:02:09.399
给出的对2017年有利的标志

00:02:07.210 --> 00:02:11.410
对于一个特定的集体

00:02:09.399 --> 00:02:14.200
 Java版本和特定版本

00:02:11.410 --> 00:02:16.000
您将要尝试的

00:02:14.200 --> 00:02:17.530
让您感觉什么垃圾

00:02:16.000 --> 00:02:19.209
集合实际上就像这样

00:02:17.530 --> 00:02:21.849
可以定期做这项工作

00:02:19.209 --> 00:02:24.550
现在这才是真正的目的

00:02:21.849 --> 00:02:26.140
学会足够的危险，然后

00:02:24.550 --> 00:02:27.090
你会变得危险，那会来

00:02:26.140 --> 00:02:30.730
后来痛苦

00:02:27.090 --> 00:02:33.489
现在我在一家公司工作

00:02:30.730 --> 00:02:35.410
 JVM和垃圾收集器，所以我

00:02:33.489 --> 00:02:37.930
我为此感到非常自豪

00:02:35.410 --> 00:02:39.549
保证我会保留那一部分

00:02:37.930 --> 00:02:42.400
使地球上收集的最好的垃圾

00:02:39.549 --> 00:02:45.610
到最后几乎会有一个

00:02:42.400 --> 00:02:48.250
这里有很多普通的有用的教育

00:02:45.610 --> 00:02:51.910
这对任何GPM或任何垃圾都是有好处的

00:02:48.250 --> 00:02:53.410
收集器实际上是在运行时

00:02:51.910 --> 00:02:55.390
议程为什么这就是我们要去的方式

00:02:53.410 --> 00:02:58.349
涵盖这是我们将从

00:02:55.390 --> 00:03:01.209
基本原理术语和机制

00:02:58.349 --> 00:03:03.790
然后将其分类

00:03:01.209 --> 00:03:07.989
当前可用的生产垃圾

00:03:03.790 --> 00:03:10.540
杰米（Jamie）的收藏家大部分

00:03:07.989 --> 00:03:11.890
那么我们将谈论停止世界

00:03:10.540 --> 00:03:14.109
问题谢谢你这不是

00:03:11.890 --> 00:03:16.450
处方，没有谈论你

00:03:14.109 --> 00:03:18.329
知道那个盐人的世界

00:03:16.450 --> 00:03:22.690
不再有

00:03:18.329 --> 00:03:25.269
就像我说的那样，我会将其保留在

00:03:22.690 --> 00:03:28.150
关于我的中间我的名字叫吉尔·蒂米我

00:03:25.269 --> 00:03:29.769
我曾经去过的所有系统的CTO 

00:03:28.150 --> 00:03:35.400
从事垃圾收集工作

00:03:29.769 --> 00:03:39.720
大约15年以来的问题

00:03:35.400 --> 00:03:39.720
这是我工作的一些证据

00:03:41.160 --> 00:03:45.640
对于那些谁不知道

00:03:43.270 --> 00:03:48.220
那是我里面的垃圾压实机

00:03:45.640 --> 00:03:49.870
厨房垃圾压实机的工作

00:03:48.220 --> 00:03:53.170
如果你认为这是执行

00:03:49.870 --> 00:03:55.720
在一周内进行少量的GC压实，因此

00:03:53.170 --> 00:04:00.460
您一次只能进行一次完全的GC疏散

00:03:55.720 --> 00:04:03.460
切点在这里效果很好的一周

00:04:00.460 --> 00:04:05.620
至少然后这不会停止工作

00:04:03.460 --> 00:04:08.080
有一个错误，您可以看到

00:04:05.620 --> 00:04:16.420
碎片从建筑物上掉下来

00:04:08.080 --> 00:04:17.799
打开实际上发生的事，我以为是

00:04:16.420 --> 00:04:20.470
拍张照片会很有趣

00:04:17.799 --> 00:04:21.850
实际的垃圾收集书，但是

00:04:20.470 --> 00:04:30.190
最重要的是

00:04:21.850 --> 00:04:33.070
图片是它是偷懒地拍摄的

00:04:30.190 --> 00:04:38.140
我回收并需要使用的新照片

00:04:33.070 --> 00:04:40.690
看起来更好，所以我从事过各种工作

00:04:38.140 --> 00:04:42.960
垃圾收集器，包括我们的垃圾

00:04:40.690 --> 00:04:47.650
收藏家叫c4 

00:04:42.960 --> 00:04:49.990
和一个过程收集器，我建立了很多

00:04:47.650 --> 00:04:52.090
物联网虚拟机

00:04:49.990 --> 00:04:55.150
有助于设计CPU的机器

00:04:52.090 --> 00:04:58.180
指令集和操作系统

00:04:55.150 --> 00:05:01.900
和驱动程序ISM运行时显然都是

00:04:58.180 --> 00:05:03.640
通往全国规模企业的道路

00:05:01.900 --> 00:05:11.680
数以千万计的应用程序

00:05:03.640 --> 00:05:13.630
订户附带的所有内容

00:05:11.680 --> 00:05:16.510
我犯了很多错误， 

00:05:13.630 --> 00:05:18.820
那些我教过的人

00:05:16.510 --> 00:05:22.410
不幸的是你不认识别人

00:05:18.820 --> 00:05:22.410
通常从自己的错误中学习

00:05:23.760 --> 00:05:28.150
找到我的不同主题

00:05:25.960 --> 00:05:29.860
谈论很多是

00:05:28.150 --> 00:05:32.080
延迟和响应时间如何

00:05:29.860 --> 00:05:34.210
测量它的行为，你可以找到一个

00:05:32.080 --> 00:05:39.190
一堆东​​西在网上和我聊天

00:05:34.210 --> 00:05:43.440
关于这个，再做一点

00:05:39.190 --> 00:05:46.390
在开始时进行手工调查

00:05:43.440 --> 00:05:48.070
我希望您能开始提高它

00:05:46.390 --> 00:05:52.720
并跟着我保持联系

00:05:48.070 --> 00:05:55.480
你认识或后悔抚养他们

00:05:52.720 --> 00:05:58.120
放下他们的笑声你们有多少人在用

00:05:55.480 --> 00:06:03.010
 Java的堆大小为半GB 

00:05:58.120 --> 00:06:05.950
还是更好，让我们先进入房间

00:06:03.010 --> 00:06:07.720
你们其余的人现在真的很小

00:06:05.950 --> 00:06:09.990
有多少人超过了千兆字节

00:06:07.720 --> 00:06:14.260
如果不放手，请保持双手举起

00:06:09.990 --> 00:06:20.790
大约超过2 GB 

00:06:14.260 --> 00:06:20.790
 4 GB超过10 GB 

00:06:20.940 --> 00:06:34.150
超过20 50万不想

00:06:29.530 --> 00:06:36.610
现在再和你说话，但是

00:06:34.150 --> 00:06:39.730
现实是这些让我告诉你

00:06:36.610 --> 00:06:43.090
我猜这是一个魔术

00:06:39.730 --> 00:06:44.980
是我们要把这个猜测分组的地方

00:06:43.090 --> 00:06:47.200
在过去十年中是正确的

00:06:44.980 --> 00:06:51.190
我一直在为此进行讨论

00:06:47.200 --> 00:06:54.750
大约十年了，并不是大多数

00:06:51.190 --> 00:06:54.750
这排放手

00:06:55.410 --> 00:06:59.830
这是一个有趣的观察

00:06:57.940 --> 00:07:02.110
我们实际上没有利用的事实

00:06:59.830 --> 00:07:05.140
的记忆和记忆的增长

00:07:02.110 --> 00:07:07.330
事实上，在过去的十年中，我们实际上

00:07:05.140 --> 00:07:09.790
拥有相同内存的100倍

00:07:07.330 --> 00:07:13.750
价格，但我们仍然可以得到

00:07:09.790 --> 00:07:16.680
同样，这是一个很大的发现，一个巨大的发现

00:07:13.750 --> 00:07:16.680
他们的理由

00:07:17.400 --> 00:07:24.220
好吧，背景为什么你应该知道

00:07:22.090 --> 00:07:25.810
垃圾收集器的工作方式不只是如何

00:07:24.220 --> 00:07:27.970
调整它们以及使用什么标记

00:07:25.810 --> 00:07:30.460
你是否应该对单词有所了解

00:07:27.970 --> 00:07:33.520
我喜欢用实际的故事

00:07:30.460 --> 00:07:36.310
实际上发生在我身上，然后称之为

00:07:33.520 --> 00:07:43.840
好小建筑师的故事

00:07:36.310 --> 00:07:45.700
马克·吐温（Mark Twain）鸽友，我定义了一个很好的

00:07:43.840 --> 00:07:47.710
建筑师不是靠质量

00:07:45.700 --> 00:07:50.350
建筑，但他们的能力

00:07:47.710 --> 00:07:52.660
真正使人们建立一个

00:07:50.350 --> 00:07:54.669
建筑，如果你想出

00:07:52.660 --> 00:07:56.590
可以的最好的美丽建筑

00:07:54.669 --> 00:07:58.810
想起但没有人真正坚持

00:07:56.590 --> 00:08:00.780
你不是建筑师，你是一个

00:07:58.810 --> 00:08:03.160
哲学家

00:08:00.780 --> 00:08:05.199
建筑师实际上得到了

00:08:03.160 --> 00:08:07.780
建立自己的东西或至少

00:08:05.199 --> 00:08:09.720
成功者和我们职业生涯的早期

00:08:07.780 --> 00:08:12.400
是一尘不染的垃圾收集器，我们

00:08:09.720 --> 00:08:14.800
真正成功了

00:08:12.400 --> 00:08:16.900
建筑师，并与他们一起奔跑

00:08:14.800 --> 00:08:18.539
停顿18秒，然后停顿一下

00:08:16.900 --> 00:08:24.550
收藏家很尴尬

00:08:18.539 --> 00:08:27.610
那是在2006年左右，所以我们去了

00:08:24.550 --> 00:08:28.990
看看这里发生了什么事，什么时候

00:08:27.610 --> 00:08:30.099
我们进入应用程序以查看

00:08:28.990 --> 00:08:32.500
这是怎么回事

00:08:30.099 --> 00:08:34.599
我们发现了一些令人惊讶的行为

00:08:32.500 --> 00:08:37.029
应用程序具有我们的行为

00:08:34.599 --> 00:08:39.099
通常没有看到，每次我们

00:08:37.029 --> 00:08:41.140
做一个垃圾收集，我们发现

00:08:39.099 --> 00:08:45.790
我们不得不执行数千万

00:08:41.140 --> 00:08:49.300
最终确定每次至少

00:08:45.790 --> 00:08:51.160
时间很不正常，不是因为

00:08:49.300 --> 00:08:53.230
很不正常，我们没有打扰

00:08:51.160 --> 00:08:57.760
当时的并发操作

00:08:53.230 --> 00:09:00.130
从那以后我们就解决了

00:08:57.760 --> 00:09:01.420
不会造成，但很好奇我们

00:09:00.130 --> 00:09:02.860
试图弄清楚这在哪里

00:09:01.420 --> 00:09:05.500
因为我们只是没有看到

00:09:02.860 --> 00:09:07.510
通常，所以我们进入应用程序

00:09:05.500 --> 00:09:09.640
与客户我们发现

00:09:07.510 --> 00:09:13.180
项目中编写的每个类

00:09:09.640 --> 00:09:17.410
过去十个月运行了大约18个月

00:09:13.180 --> 00:09:19.329
人们如何找到一个单身

00:09:17.410 --> 00:09:21.220
这个团队写的课有一个

00:09:19.329 --> 00:09:22.630
终结者有一个非常好的

00:09:21.220 --> 00:09:26.020
在这里玩的建筑师

00:09:22.630 --> 00:09:28.750
没有人逃避此事，但更多

00:09:26.020 --> 00:09:31.600
有趣的是完成了什么

00:09:28.750 --> 00:09:38.380
有人想猜最后

00:09:31.600 --> 00:09:40.390
残留物就是这样

00:09:38.380 --> 00:09:42.220
最终的答案是将所有内容都设为空

00:09:40.390 --> 00:09:43.899
帮助收藏家的参考

00:09:42.220 --> 00:09:45.550
因为你不想如果这个对象

00:09:43.899 --> 00:09:47.649
您不想保留参考的汽车

00:09:45.550 --> 00:09:49.420
对其他物体，让我们来帮助

00:09:47.649 --> 00:09:52.600
通过把那些收集出去

00:09:49.420 --> 00:09:54.670
到处都好，这是最糟糕的

00:09:52.600 --> 00:09:58.390
你可能会问收藏家

00:09:54.670 --> 00:10:00.339
这样做无济于事，但是

00:09:58.390 --> 00:10:04.300
有一个世界，这正是

00:10:00.339 --> 00:10:06.550
在C ++中要做的正确的事情是这样的

00:10:04.300 --> 00:10:09.520
你写你的设置代码吗

00:10:06.550 --> 00:10:12.040
毁灭者相当于你什么

00:10:09.520 --> 00:10:13.450
确保如果你死了就杀了

00:10:12.040 --> 00:10:14.920
你碰的一切都那么粗糙

00:10:13.450 --> 00:10:17.710
扫描将收集这两个

00:10:14.920 --> 00:10:19.570
你还在做什么，如果你

00:10:17.710 --> 00:10:21.970
实际上不坚持这种

00:10:19.570 --> 00:10:24.160
您将拥有记忆的架构

00:10:21.970 --> 00:10:25.530
泄漏和腐败以及各种

00:10:24.160 --> 00:10:28.240
其他不好的事情正在发生

00:10:25.530 --> 00:10:30.790
所以你需要的结构和

00:10:28.240 --> 00:10:32.740
一切都是平等的，假设您在Java中

00:10:30.790 --> 00:10:34.900
从不想要析构函数或终结器

00:10:32.740 --> 00:10:37.030
除非你绝对无法摆脱

00:10:34.900 --> 00:10:40.960
从做，甚至它应该认为

00:10:37.030 --> 00:10:43.510
三遍，所以这是错误的

00:10:40.960 --> 00:10:45.340
 Java或任何垃圾收集的东西

00:10:43.510 --> 00:10:46.960
语言，这是正确的

00:10:45.340 --> 00:10:51.010
参考计数语言

00:10:46.960 --> 00:10:53.080
酒被破坏，因为收藏家的工作

00:10:51.010 --> 00:10:57.360
以某些方式，我们将进入

00:10:53.080 --> 00:10:57.360
希望能证明这是为什么

00:10:57.720 --> 00:11:03.430
这么糟糕的做法，就像一千

00:11:01.510 --> 00:11:09.640
出口使收集者更昂贵

00:11:03.430 --> 00:11:11.560
视频还好吧，这有点

00:11:09.640 --> 00:11:13.480
一般来说，我发现有一个

00:11:11.560 --> 00:11:16.180
关于许多误解和误解

00:11:13.480 --> 00:11:17.950
收集了很多人的想法

00:11:16.180 --> 00:11:19.420
关于收集垃圾收集是

00:11:17.950 --> 00:11:21.160
错误的，大多数建议你会

00:11:19.420 --> 00:11:24.790
找到一个与之相反的实习生

00:11:21.160 --> 00:11:27.520
正确，所以即使你读我的东西

00:11:24.790 --> 00:11:29.350
你应该怀疑它，但学术

00:11:27.520 --> 00:11:31.000
工作往往是相当不错的同行

00:11:29.350 --> 00:11:33.130
评论的学术论文往往是

00:11:31.000 --> 00:11:35.410
不错，但是一般的互联网建议

00:11:33.130 --> 00:11:38.920
往往很糟糕，尤其是三个

00:11:35.410 --> 00:11:41.200
这么多年后，谷歌

00:11:38.920 --> 00:11:42.640
不会忘记，所以这里有一些基本

00:11:41.200 --> 00:11:44.260
那里的事情不同于你

00:11:42.640 --> 00:11:45.940
可能会这样想，例如鲍勃

00:11:44.260 --> 00:11:48.750
描述并不比什么更好

00:11:45.940 --> 00:11:51.070
人们以为有几件事

00:11:48.750 --> 00:11:52.900
垃圾收集实际上是最

00:11:51.070 --> 00:11:56.170
高效可行的管理方式

00:11:52.900 --> 00:11:58.150
内存比其他任何便宜

00:11:56.170 --> 00:12:00.340
周期选择

00:11:58.150 --> 00:12:01.380
用于分配和删除

00:12:00.340 --> 00:12:05.080
动态的东西

00:12:01.380 --> 00:12:07.180
 GC比mono便宜，我们

00:12:05.080 --> 00:12:07.720
可以证明我会证明

00:12:07.180 --> 00:12:10.060
后来

00:12:07.720 --> 00:12:12.270
我不知道这是有争议的

00:12:10.060 --> 00:12:12.270
精细

00:12:12.550 --> 00:12:19.870
另一个是垃圾收集器

00:12:15.660 --> 00:12:21.640
基本上没有花高效率

00:12:19.870 --> 00:12:24.310
碳脚本的花费不足

00:12:21.640 --> 00:12:24.980
寻找和思考的实际工作

00:12:24.310 --> 00:12:27.770
该对象

00:12:24.980 --> 00:12:28.910
这就是为什么要求完成对象

00:12:27.770 --> 00:12:30.500
是一件可怕的事情，因为你

00:12:28.910 --> 00:12:32.000
要求你花一些钱

00:12:30.500 --> 00:12:35.660
它什么也没有做，实际上是在做手术

00:12:32.000 --> 00:12:37.970
对于对象，然后最后一部分是

00:12:35.660 --> 00:12:40.270
至少在Java和

00:12:37.970 --> 00:12:42.680
最现代的运行时

00:12:40.270 --> 00:12:44.510
绝对会找到所有死者

00:12:42.680 --> 00:12:46.520
他们不需要的物体，他们不需要帮助

00:12:44.510 --> 00:12:47.960
需要你打破周期，他们不是你

00:12:46.520 --> 00:12:49.460
不必担心链接列表

00:12:47.960 --> 00:12:51.680
指向自己和怪异

00:12:49.460 --> 00:12:53.240
对象图如果死了就死了

00:12:51.680 --> 00:12:54.290
您不必担心，他们会

00:12:53.240 --> 00:12:56.150
完美的工作

00:12:54.290 --> 00:12:58.430
寻找死者的精确工作

00:12:56.150 --> 00:13:00.820
对象并帮助它放在那里

00:12:58.430 --> 00:13:03.260
旋钮只是阻碍

00:13:00.820 --> 00:13:05.990
并没有使它更正确

00:13:03.260 --> 00:13:07.550
更多的东西，但有很多东西

00:13:05.990 --> 00:13:10.970
比人们可能会更糟

00:13:07.550 --> 00:13:12.980
想想如果你很垃圾

00:13:10.970 --> 00:13:15.230
收集器有任何形式的停止

00:13:12.980 --> 00:13:19.520
世界行动，以履行其职责我

00:13:15.230 --> 00:13:21.650
难得都可以解决

00:13:19.520 --> 00:13:23.720
将按以下顺序暂停

00:13:21.650 --> 00:13:26.420
一秒钟我的东西

00:13:23.720 --> 00:13:30.260
你有你无法摆脱的

00:13:26.420 --> 00:13:33.380
您可以延迟，是的，有一些

00:13:30.260 --> 00:13:35.360
收集者实际上不会这样做

00:13:33.380 --> 00:13:40.700
那件事是一个例子，还有其他

00:13:35.360 --> 00:13:43.100
在作品中，但phenom和我，如果你是

00:13:40.700 --> 00:13:44.960
做压实，停止世界你

00:13:43.100 --> 00:13:46.430
会看到你无法摆脱的产卵

00:13:44.960 --> 00:13:48.200
从这里我不在乎其他人

00:13:46.430 --> 00:13:49.910
告诉你现在也许可以

00:13:48.200 --> 00:13:53.210
花一个小时或一天或一个

00:13:49.910 --> 00:13:57.950
周，但在那里，就在斯威夫特

00:13:53.210 --> 00:13:59.390
超越那条路，不是所有的记忆

00:13:57.950 --> 00:14:01.490
泄漏大风和垃圾

00:13:59.390 --> 00:14:03.770
收藏家，我们照顾很多

00:14:01.490 --> 00:14:05.270
常见的错误是内存泄漏

00:14:03.770 --> 00:14:07.700
在其他环境中发生的错误

00:14:05.270 --> 00:14:10.070
但是基本的泄漏正在忘记

00:14:07.700 --> 00:14:11.720
忘记了，如果你只是我们仍然在那里

00:14:10.070 --> 00:14:15.110
不断积累东西

00:14:11.720 --> 00:14:17.140
成长不是最后一个魔术点

00:14:15.110 --> 00:14:20.360
这对稳定非常重要

00:14:17.140 --> 00:14:22.310
垃圾收集的东西在

00:14:20.360 --> 00:14:25.670
人们想要的相反方向

00:14:22.310 --> 00:14:28.100
来自可测试系统的大部分调整

00:14:25.670 --> 00:14:31.160
和垃圾字符垃圾收集器

00:14:28.100 --> 00:14:32.750
一直专注于解决严重问题

00:14:31.160 --> 00:14:34.790
未来使它们越来越多

00:14:32.750 --> 00:14:37.059
难得的是不消除它们，而是推动

00:14:34.790 --> 00:14:39.099
他们前进，那个

00:14:37.059 --> 00:14:41.919
意味着当您调整系统后

00:14:39.099 --> 00:14:44.199
最终通过了20分钟的压力测试

00:14:41.919 --> 00:14:45.549
你实际上并没有摆脱任何

00:14:44.199 --> 00:14:49.599
您刚刚将问题移至

00:14:45.549 --> 00:14:52.089
第21分钟免费质量检查，这太糟糕了

00:14:49.599 --> 00:14:54.249
之所以这样，是因为一个经过良好调整的GC系统

00:14:52.089 --> 00:14:57.099
通常需要几天或几周才能真正

00:14:54.249 --> 00:15:00.219
测试这是为什么有些有趣

00:14:57.099 --> 00:15:01.749
帮助您造成不良GC的工具

00:15:00.219 --> 00:15:03.239
像跑步一样发生的事情

00:15:01.749 --> 00:15:07.629
有趣的名字

00:15:03.239 --> 00:15:09.909
好吧，让我们谈谈基本的术语

00:15:07.629 --> 00:15:11.679
术语始于对

00:15:09.909 --> 00:15:15.099
收藏家，你们当中有多少人知道

00:15:11.679 --> 00:15:17.049
一对垃圾收集器还可以

00:15:15.099 --> 00:15:20.499
你们当中有多少人知道

00:15:17.049 --> 00:15:23.109
现在并发垃圾收集器

00:15:20.499 --> 00:15:26.649
比服装少

00:15:23.109 --> 00:15:29.799
为什么这两个词在

00:15:26.649 --> 00:15:31.209
英语我成长了一些语言

00:15:29.799 --> 00:15:34.419
讲希伯来语的地方

00:15:31.209 --> 00:15:35.979
这些都一个字，但在

00:15:34.419 --> 00:15:37.659
垃圾收集分类

00:15:35.979 --> 00:15:40.149
他们是正交的，这并不意味着

00:15:37.659 --> 00:15:43.809
他们可以制造垃圾的同一件事

00:15:40.149 --> 00:15:46.989
收集者在您的工作

00:15:43.809 --> 00:15:49.119
应用程序正在运行垃圾

00:15:46.989 --> 00:15:52.239
收集器和您的应用程序是

00:15:49.119 --> 00:15:54.639
我们经常互相称呼

00:15:52.239 --> 00:15:56.369
你们你们正在变异的变异者

00:15:54.639 --> 00:15:58.869
您正在改变其形状的堆

00:15:56.369 --> 00:16:00.789
并行垃圾收集器是一个

00:15:58.869 --> 00:16:03.039
使用多个线程的收集器

00:16:00.789 --> 00:16:05.259
亲密垃圾，它可以使用多个

00:16:03.039 --> 00:16:08.349
线程多个CPU做任何事情

00:16:05.259 --> 00:16:09.129
它正在做这些事情没有什么可做的

00:16:08.349 --> 00:16:12.069
互相做

00:16:09.129 --> 00:16:13.629
你可能是并发的，但不是好朋友

00:16:12.069 --> 00:16:17.019
可能是力量，但没有电流

00:16:13.629 --> 00:16:19.649
可能两者都不是

00:16:17.019 --> 00:16:22.239
只是术语的定义

00:16:19.649 --> 00:16:24.039
不幸的是，如果您阅读了30年

00:16:22.239 --> 00:16:25.959
回到垃圾密林顿文件，你会

00:16:24.039 --> 00:16:28.419
发现这些术语实际上互换了

00:16:25.959 --> 00:16:30.189
曾经被称为危险的东西

00:16:28.419 --> 00:16:32.519
称为并发，但这可能是

00:16:30.189 --> 00:16:34.629
对过去的20 25年有利

00:16:32.519 --> 00:16:37.059
至少学术工作和垃圾

00:16:34.629 --> 00:16:38.709
收藏家，所以要记住

00:16:37.059 --> 00:16:42.159
收集电流有很大不同

00:16:38.709 --> 00:16:44.649
现在的事情是什么阻止了世界

00:16:42.159 --> 00:16:47.379
收藏家将制止世界

00:16:44.649 --> 00:16:49.749
与并发相反，而不是运行

00:16:47.379 --> 00:16:50.910
与您的应用程序同时进行

00:16:49.749 --> 00:16:53.720
停止世界

00:16:50.910 --> 00:16:57.290
提前，然后再运行

00:16:53.720 --> 00:16:59.880
所以这些是直接相反的

00:16:57.290 --> 00:17:04.020
单片收集器或一部分

00:16:59.880 --> 00:17:08.160
收藏家我认为这个模式是

00:17:04.020 --> 00:17:10.319
一站式完成所有工作

00:17:08.160 --> 00:17:14.130
你无法从事的工作

00:17:10.319 --> 00:17:18.270
碎，也许碎，然后磨合

00:17:14.130 --> 00:17:21.060
中间只要增量

00:17:18.270 --> 00:17:23.189
收藏家是可以接受的收藏家

00:17:21.060 --> 00:17:25.860
您需要做的工作将其缩小为

00:17:23.189 --> 00:17:27.839
较小的部分可以做到这一点

00:17:25.860 --> 00:17:29.880
也许停止世界做一点

00:17:27.839 --> 00:17:32.130
然后它停止停止世界，但是你

00:17:29.880 --> 00:17:34.500
跑然后做下一个旅程下一个

00:17:32.130 --> 00:17:37.680
您可能会说与之交织

00:17:34.500 --> 00:17:39.810
应用程序，但不能同时使用

00:17:37.680 --> 00:17:42.380
阻止你做一点跑步

00:17:39.810 --> 00:17:45.360
它不会干预的事情

00:17:42.380 --> 00:17:48.930
增量收集器通常会停止

00:17:45.360 --> 00:17:50.850
世界增量跑步者，但

00:17:48.930 --> 00:17:53.940
有一项非常重要的技术

00:17:50.850 --> 00:17:56.910
垃圾收集器分类中的单词

00:17:53.940 --> 00:17:58.740
它被诚实地用于学术界

00:17:56.910 --> 00:18:00.510
大部分是术语，但这是一种滥用

00:17:58.740 --> 00:18:04.440
从营销角度来看， 

00:18:00.510 --> 00:18:06.570
简单的英语单词主要是指

00:18:04.440 --> 00:18:08.700
确实是您认为的意思，但您

00:18:06.570 --> 00:18:12.020
需要仔细仔细阅读任何

00:18:08.700 --> 00:18:15.540
大部分带有单词的句子

00:18:12.020 --> 00:18:19.290
多数情况下并发表示

00:18:15.540 --> 00:18:20.730
被认为以平行方式补习

00:18:19.290 --> 00:18:23.240
有时是单线程，大部分是

00:18:20.730 --> 00:18:25.350
增量意味着有时是整体的

00:18:23.240 --> 00:18:27.240
通常是你放的东西

00:18:25.350 --> 00:18:32.460
说我很高兴的话

00:18:27.240 --> 00:18:34.560
不这样做或我通常做的任何事情

00:18:32.460 --> 00:18:37.770
那但我对你说实话

00:18:34.560 --> 00:18:41.460
大多数情况下，您会发现

00:18:37.770 --> 00:18:45.960
分类好了，让我们来谈谈

00:18:41.460 --> 00:18:48.930
其他一些精确的术语和

00:18:45.960 --> 00:18:51.900
保守的收藏是精确的

00:18:48.930 --> 00:18:53.610
收藏家好，让我们开始

00:18:51.900 --> 00:18:55.260
保守的收藏家是

00:18:53.610 --> 00:18:58.080
一个不确定的收藏家在哪里

00:18:55.260 --> 00:19:00.750
所有的指针都很好， 

00:18:58.080 --> 00:19:02.790
找到垃圾堆，但不确定

00:19:00.750 --> 00:19:05.790
指向一切的所有指针都在哪里

00:19:02.790 --> 00:19:08.130
没有一些，但不是全部，它需要它

00:19:05.790 --> 00:19:10.020
结果有些保守

00:19:08.130 --> 00:19:12.270
可能是指针，可能不是指针

00:19:10.020 --> 00:19:14.580
我需要处理

00:19:12.270 --> 00:19:16.320
精确的收藏家就是

00:19:14.580 --> 00:19:18.930
实际上知道它何时收集

00:19:16.320 --> 00:19:20.940
所有指针都在哪里

00:19:18.930 --> 00:19:22.500
差异非常根本，因为

00:19:20.940 --> 00:19:23.640
有些事情你做不到

00:19:22.500 --> 00:19:26.520
除非你精确

00:19:23.640 --> 00:19:28.620
例如他必须成为的收藏家

00:19:26.520 --> 00:19:30.900
精确，如果要移动旋钮

00:19:28.620 --> 00:19:35.580
从一个地方到另一个地方

00:19:30.900 --> 00:19:37.820
一个物体点A到点B 

00:19:35.580 --> 00:19:39.930
修复所有指向它的指针

00:19:37.820 --> 00:19:43.830
但是如果您不确定他们在哪里

00:19:39.930 --> 00:19:45.870
也许你留下了一个悬空，或者

00:19:43.830 --> 00:19:47.550
更糟糕的是，我认为

00:19:45.870 --> 00:19:50.130
可能是一个指针，但我实际上不是

00:19:47.550 --> 00:19:51.900
确定它是否是一个整数指针

00:19:50.130 --> 00:19:53.760
它只是一个整数

00:19:51.900 --> 00:19:55.710
具有看起来像指针的值

00:19:53.760 --> 00:19:57.870
我将更改整数值，因为

00:19:55.710 --> 00:19:59.970
后来反对这两个都是致命的

00:19:57.870 --> 00:20:01.830
错误使你无力承担

00:19:59.970 --> 00:20:05.730
他们，这就是为什么不精确

00:20:01.830 --> 00:20:07.560
您将看不到任何运动物体

00:20:05.730 --> 00:20:10.380
努力使收集器精确

00:20:07.560 --> 00:20:12.540
不在收藏家本身中

00:20:10.380 --> 00:20:14.880
收集者提供的信息

00:20:12.540 --> 00:20:16.710
收集器只需要在运行时

00:20:14.880 --> 00:20:18.450
知道指针在哪里，但是

00:20:16.710 --> 00:20:20.640
诸如JIT编译器和

00:20:18.450 --> 00:20:21.900
任何时候都需要知道的运行时

00:20:20.640 --> 00:20:24.750
在收集器可能会使用的代码中

00:20:21.900 --> 00:20:27.630
收集所有指针的位置

00:20:24.750 --> 00:20:29.400
如果我在堆栈中的这一点上的示例

00:20:27.630 --> 00:20:31.590
停下来收集我需要知道所有

00:20:29.400 --> 00:20:33.450
如果所有的指针

00:20:31.590 --> 00:20:35.960
调用栈，如果它们是该指针

00:20:33.450 --> 00:20:38.520
如果我移动一条更改的代码行

00:20:35.960 --> 00:20:40.050
信息随身携带

00:20:38.520 --> 00:20:42.540
所谓的蓝色热点也许是

00:20:40.050 --> 00:20:44.130
还有其他几次

00:20:42.540 --> 00:20:46.620
 JIT优惠券的编译器

00:20:44.130 --> 00:20:48.270
生产，下次您需要准时生产

00:20:46.620 --> 00:20:50.640
编译器作者认为这样做

00:20:48.270 --> 00:20:52.920
只需要它的所有辛勤工作

00:20:50.640 --> 00:20:54.360
对于这种东西，因为没有

00:20:52.920 --> 00:20:55.890
它不会有远见的垃圾

00:20:54.360 --> 00:21:00.480
我们不会压实的集合

00:20:55.890 --> 00:21:03.330
我们将记录我们拥有的所有JVM 

00:21:00.480 --> 00:21:07.070
今天新闻精确的收藏家，他们都

00:21:03.330 --> 00:21:07.070
在一个点或另一个点上移动对象

00:21:07.760 --> 00:21:14.940
安全点是这些有趣的事情

00:21:10.560 --> 00:21:17.370
我们在执行过程中允许这些

00:21:14.940 --> 00:21:20.310
让尺寸收集器工作，所以我们可以

00:21:17.370 --> 00:21:22.290
理论上有任何程序计数器

00:21:20.310 --> 00:21:27.000
在任何时候都指向什么

00:21:22.290 --> 00:21:30.600
是，但这既困难又痛苦

00:21:27.000 --> 00:21:32.730
优化，以便插入安全点

00:21:30.600 --> 00:21:34.560
在执行过程中，我们在这里说我们

00:21:32.730 --> 00:21:36.270
知道所有指针在哪里

00:21:34.560 --> 00:21:38.880
知道所有指针是安全的

00:21:36.270 --> 00:21:40.650
点是执行范围

00:21:38.880 --> 00:21:42.290
我们完整描述的线程

00:21:40.650 --> 00:21:45.650
指针是什么东西

00:21:42.290 --> 00:21:48.240
他们之间我们可能不会，但我们在那里

00:21:45.650 --> 00:21:50.370
有各种各样的安全点， 

00:21:48.240 --> 00:21:51.870
我正在使用的GCC点和安全点

00:21:50.370 --> 00:21:54.930
可互换的这里还有其他

00:21:51.870 --> 00:21:57.240
当我安全点的原因

00:21:54.930 --> 00:21:59.220
说我们通过一个线程

00:21:57.240 --> 00:22:00.900
安全点，这意味着我们可以做到

00:21:59.220 --> 00:22:02.760
我们拥有的执行范围

00:22:00.900 --> 00:22:05.460
很好的描述，不要放过

00:22:02.760 --> 00:22:07.160
超过这一点，这听起来很多

00:22:05.460 --> 00:22:09.270
像树桩一样， 

00:22:07.160 --> 00:22:11.730
停止此事件是一种方法

00:22:09.270 --> 00:22:15.420
有一个关键的例外

00:22:11.730 --> 00:22:18.720
例如您随时致电J Michaels 

00:22:15.420 --> 00:22:23.550
 j9功能包括阻止套接字

00:22:18.720 --> 00:22:25.950
或阅读或其他任何东西

00:22:23.550 --> 00:22:27.300
实际上进入一个安全点，现在进入

00:22:25.950 --> 00:22:29.130
安全的人并不意味着你不是

00:22:27.300 --> 00:22:32.610
运行，您可能正在反转矩阵

00:22:29.130 --> 00:22:34.710
在接下来的三个小时中使用C ++，但是您

00:22:32.610 --> 00:22:36.600
没有改变任何指针状态

00:22:34.710 --> 00:22:39.480
你没有改变指针的位置

00:22:36.600 --> 00:22:43.440
所以你是一个信号，我们有一个

00:22:39.480 --> 00:22:45.330
我们需要在哪里的好描述

00:22:43.440 --> 00:22:47.070
否则经常去的安全地方

00:22:45.330 --> 00:22:48.840
我们将拥有我所说的安全时间

00:22:47.070 --> 00:22:50.460
白色的问题不在这里

00:22:48.840 --> 00:22:52.530
但这很重要

00:22:50.460 --> 00:22:54.330
每个人都在等待，这个家伙

00:22:52.530 --> 00:22:55.790
最近三天没回来

00:22:54.330 --> 00:22:58.080
小时

00:22:55.790 --> 00:23:00.630
看起来像是一个很大的停顿，但什么也没有

00:22:58.080 --> 00:23:02.760
开始工作，但有一个本地

00:23:00.630 --> 00:23:04.320
安全点，我们将所有

00:23:02.760 --> 00:23:06.060
线程到一个共同的安全点，那

00:23:04.320 --> 00:23:08.640
是他们阻止世界的方式

00:23:06.060 --> 00:23:10.850
暂停全局安全点并停止

00:23:08.640 --> 00:23:14.730
与什么法律是同一回事

00:23:10.850 --> 00:23:17.580
所以我们讨论了一些术语

00:23:14.730 --> 00:23:19.980
关于一些行为，这是三个

00:23:17.580 --> 00:23:22.260
所有精确的收藏家都喜欢的东西

00:23:19.980 --> 00:23:24.330
实际条件会做其中之一

00:23:22.260 --> 00:23:27.630
他们会识别所有现场

00:23:24.330 --> 00:23:28.679
他们将回收的物体

00:23:27.630 --> 00:23:31.889
所有的

00:23:28.679 --> 00:23:33.990
他们可以证明已经死了，他们

00:23:31.889 --> 00:23:36.749
将物体从一个地方移到

00:23:33.990 --> 00:23:39.059
这些东西中的每一个都会

00:23:36.749 --> 00:23:40.710
发生在一个精确的收集器中，没有

00:23:39.059 --> 00:23:43.409
如果你不做的话，准确就是要点

00:23:40.710 --> 00:23:46.309
完成这三个步骤，但让我们看一下具体的

00:23:43.409 --> 00:23:49.379
示例和经典的简单算法

00:23:46.309 --> 00:23:51.919
做这些步骤的第一个是

00:23:49.379 --> 00:23:54.210
打标机

00:23:51.919 --> 00:23:57.240
标记是找到所有线的地方

00:23:54.210 --> 00:23:58.950
第一步的对象是

00:23:57.240 --> 00:24:00.720
您确定所有死者的东西， 

00:23:58.950 --> 00:24:03.740
不知何故，只有三个循环

00:24:00.720 --> 00:24:06.659
第二步，然后压实第三步

00:24:03.740 --> 00:24:08.249
一二三一二三但是

00:24:06.659 --> 00:24:09.899
分别有一个单独的命令

00:24:08.249 --> 00:24:12.450
收集器称为副本收集器

00:24:09.899 --> 00:24:13.980
这不是三个步骤

00:24:12.450 --> 00:24:15.990
从疯狂的副本收集器

00:24:13.980 --> 00:24:19.200
所有物体都来自一个空间并调用

00:24:15.990 --> 00:24:22.710
从太空说，让我们移动所有

00:24:19.200 --> 00:24:25.139
一站式将活物带到两个空间

00:24:22.710 --> 00:24:27.809
当我完成后，其他的一切

00:24:25.139 --> 00:24:28.529
东西在两个空间中，所以从

00:24:27.809 --> 00:24:30.929
空间是空的

00:24:28.529 --> 00:24:32.759
这是一次通过所有三个步骤

00:24:30.929 --> 00:24:34.559
这些东西发现物体移动

00:24:32.759 --> 00:24:37.769
他们，因此每个要求

00:24:34.559 --> 00:24:39.929
业务，所以我要打破它

00:24:37.769 --> 00:24:42.090
我只是那些人的真实面孔

00:24:39.929 --> 00:24:45.990
谈论作为解释，所以我们可以

00:24:42.090 --> 00:24:49.740
在复杂性标记中谈论它们或

00:24:45.990 --> 00:24:53.999
跟踪涉及从什么开始

00:24:49.740 --> 00:24:57.749
我们称根根是静态变量

00:24:53.999 --> 00:25:00.869
线程及其堆栈本身

00:24:57.749 --> 00:25:02.610
可见性的根源

00:25:00.869 --> 00:25:04.580
我可以从那里开始的指针，我们开始

00:25:02.610 --> 00:25:08.009
从这些群体中我们做我们所谓的

00:25:04.580 --> 00:25:10.830
追踪或绘画任何他们可以

00:25:08.009 --> 00:25:13.619
达到并没有将它们标记为I 

00:25:10.830 --> 00:25:15.960
到达我标记，然后他们看向里面

00:25:13.619 --> 00:25:17.700
它，并不断达到，所以我让

00:25:15.960 --> 00:25:20.789
绘画并遵循我所看到的一切

00:25:17.700 --> 00:25:22.259
在我走过的任何地方，我都标记为

00:25:20.789 --> 00:25:23.669
我去过那里

00:25:22.259 --> 00:25:26.399
已经标记为他们需要走

00:25:23.669 --> 00:25:30.629
再次出现，所以我从根开始

00:25:26.399 --> 00:25:32.850
实际上我现在可以到达

00:25:30.629 --> 00:25:34.529
这些追踪的精髓之一的结尾

00:25:32.850 --> 00:25:37.499
从根开始的通行证

00:25:34.529 --> 00:25:39.629
可以到达的物体

00:25:37.499 --> 00:25:40.470
从我的根本出发到达你

00:25:39.629 --> 00:25:43.020
被标记为线

00:25:40.470 --> 00:25:46.320
还有我无法到达的任何东西

00:25:43.020 --> 00:25:49.260
根源，我将不值得拥有

00:25:46.320 --> 00:25:51.690
如果不能的话，这里非常重要的品质

00:25:49.260 --> 00:25:53.550
现在从根目录到达它

00:25:51.690 --> 00:25:57.020
永远无法从根源到达它

00:25:53.550 --> 00:25:59.700
再次设置以能够表达

00:25:57.020 --> 00:26:01.680
引用我需要的对象

00:25:59.700 --> 00:26:03.300
在表达之前达到它，所以

00:26:01.680 --> 00:26:04.140
复制参考，而仅仅是

00:26:03.300 --> 00:26:06.270
可触及的东西

00:26:04.140 --> 00:26:08.490
所以一旦我证明有些东西不是

00:26:06.270 --> 00:26:11.850
可以到达的地方

00:26:08.490 --> 00:26:13.590
这又是为什么还活着

00:26:11.850 --> 00:26:15.780
链接列表不必标记

00:26:13.590 --> 00:26:18.420
和破碎，因为如果我无法达到

00:26:15.780 --> 00:26:19.700
它会死的，不必

00:26:18.420 --> 00:26:22.770
分开

00:26:19.700 --> 00:26:25.770
所以这是详尽无遗的

00:26:22.770 --> 00:26:27.900
从复杂性的角度来看

00:26:25.770 --> 00:26:30.090
工作随着现场的发展而增长

00:26:27.900 --> 00:26:32.310
活物和类似参考文献的人

00:26:30.090 --> 00:26:35.820
我们必须经历，但是

00:26:32.310 --> 00:26:37.500
如果我有二十的话，热量的大小

00:26:35.820 --> 00:26:39.570
千兆字节的热量高达一百英尺

00:26:37.500 --> 00:26:41.520
保持只有100兆字节的

00:26:39.570 --> 00:26:43.290
活东西，我只标记100兆字节

00:26:41.520 --> 00:26:45.510
堆大小的活东西

00:26:43.290 --> 00:26:48.300
与复杂性无关

00:26:45.510 --> 00:26:51.170
市场，但如果我把生活加倍

00:26:48.300 --> 00:26:53.340
会变身到我这里

00:26:51.170 --> 00:26:55.440
清扫是一个非常简单的机制

00:26:53.340 --> 00:26:57.680
想象我只是做了一个记号，一切

00:26:55.440 --> 00:27:00.900
那还活着就是活着，如果不是，那不是

00:26:57.680 --> 00:27:03.120
我们席卷整个团队

00:27:00.900 --> 00:27:05.790
在所有物体上，如果不是

00:27:03.120 --> 00:27:08.670
生活中，我们以某种方式处理它们的回收

00:27:05.790 --> 00:27:12.030
他们每秒钟将它们放入

00:27:08.670 --> 00:27:13.470
自由是一种通行的方式

00:27:12.030 --> 00:27:14.990
一切都放进去

00:27:13.470 --> 00:27:18.990
我们的手指，我们稍后会处理

00:27:14.990 --> 00:27:21.540
这显然是我们可以通过的简单通行证

00:27:18.990 --> 00:27:23.310
瘫痪与否，但它的工作是

00:27:21.540 --> 00:27:25.800
与堆大小成线性关系，但之后

00:27:23.310 --> 00:27:29.190
您管理和访问每个对象

00:27:25.800 --> 00:27:31.430
无论我活着的事件如何

00:27:29.190 --> 00:27:33.480
将堆大小加倍我将工作加倍

00:27:31.430 --> 00:27:35.670
改变没有的灯

00:27:33.480 --> 00:27:39.150
在工作中很有效

00:27:35.670 --> 00:27:40.500
重要的领导人好吧，所以一旦我们

00:27:39.150 --> 00:27:42.600
标记并扫过

00:27:40.500 --> 00:27:44.910
我们知道所有好东西都在哪里

00:27:42.600 --> 00:27:45.900
紧凑，这是一个简单的标记，甜蜜

00:27:44.910 --> 00:27:48.120
补全

00:27:45.900 --> 00:27:51.570
让我们开始，为什么我们需要

00:27:48.120 --> 00:27:53.570
紧凑的人经常为此争论

00:27:51.570 --> 00:27:56.299
但我认为争论是如此

00:27:53.570 --> 00:27:58.250
大概二十年前或更早

00:27:56.299 --> 00:28:00.770
我们紧凑的原因是，如果您

00:27:58.250 --> 00:28:02.600
不要随着时间的流逝你的堆会变得瑞士

00:28:00.770 --> 00:28:04.909
奶酪，你会以大厅结束

00:28:02.600 --> 00:28:07.669
到处都是，即使堆是

00:28:04.909 --> 00:28:11.000
 90％为空，您无处可放

00:28:07.669 --> 00:28:14.450
 11 KB的字符串，因为最大

00:28:11.000 --> 00:28:16.220
大厅是9千字节，那里有100 

00:28:14.450 --> 00:28:17.750
 GB的可用内存，但不是全部

00:28:16.220 --> 00:28:19.789
在您的11个图书馆中足够大

00:28:17.750 --> 00:28:21.529
如果这会很尴尬

00:28:19.789 --> 00:28:25.850
我们在以下位置抛出了内存不足异常

00:28:21.529 --> 00:28:28.789
那一点，因此，我们必须

00:28:25.850 --> 00:28:30.890
现在紧凑，现实是真实的

00:28:28.789 --> 00:28:33.110
大小可变时的世界

00:28:30.890 --> 00:28:34.940
大小可变的对象

00:28:33.110 --> 00:28:37.640
随着时间的流逝，您将威胁他们

00:28:34.940 --> 00:28:40.820
加热是不可避免的，没有真正的

00:28:37.640 --> 00:28:42.320
关于这个的争论是

00:28:40.820 --> 00:28:44.419
只是你能活多久的问题

00:28:42.320 --> 00:28:48.950
在您必须执行此操作之前

00:28:44.419 --> 00:28:50.720
很多或变化，但无论如何我们都会

00:28:48.950 --> 00:28:53.450
需要压实，所以这种压实

00:28:50.720 --> 00:28:55.730
我压实意味着移动物体

00:28:53.450 --> 00:28:57.320
一起做更大的大厅

00:28:55.730 --> 00:29:00.110
种类繁多-感谢您这样做

00:28:57.320 --> 00:29:01.789
例如，您可以将其压缩到位

00:29:00.110 --> 00:29:04.070
是我们紧紧收集的标记

00:29:01.789 --> 00:29:06.409
在拓扑中看到的是什么想到的

00:29:04.070 --> 00:29:08.120
当我们标记一切尊重时

00:29:06.409 --> 00:29:08.950
一切都将所有生命的东西转移到

00:29:08.120 --> 00:29:11.390
左边

00:29:08.950 --> 00:29:12.710
然后将其压缩到左侧

00:29:11.390 --> 00:29:16.520
我将所有空的东西放在上面

00:29:12.710 --> 00:29:19.039
正确，它将进行配置，所以我们

00:29:16.520 --> 00:29:21.490
基本上会一起搬东西

00:29:19.039 --> 00:29:24.890
让所有空的东西变大

00:29:21.490 --> 00:29:26.929
它基本上必须不只是移动

00:29:24.890 --> 00:29:28.250
物体，但我们移动物体

00:29:26.929 --> 00:29:31.250
必须修复所有指向这些指针的指针

00:29:28.250 --> 00:29:32.919
对象，所以我们让我们吸引一些对象

00:29:31.250 --> 00:29:35.330
并通过并修复它们

00:29:32.919 --> 00:29:39.049
那是一个紧凑的地方

00:29:35.330 --> 00:29:40.669
疏散压实机

00:29:39.049 --> 00:29:42.140
一个记忆区域，并移动所有活动

00:29:40.669 --> 00:29:45.409
里面的东西，现在该地区是

00:29:42.140 --> 00:29:48.049
从标记中清空类似的技术

00:29:45.409 --> 00:29:53.299
并修正参考文献-但这是

00:29:48.049 --> 00:29:54.980
不是行为上的差异

00:29:53.299 --> 00:29:58.279
如果我搬家，这点很重要

00:29:54.980 --> 00:30:01.010
一个对象可能具有一个对象

00:29:58.279 --> 00:30:03.020
十亿东西指向它，所以我有

00:30:01.010 --> 00:30:05.630
扫描堆中所有可能的东西

00:30:03.020 --> 00:30:07.149
指向此对象并修复它的原因

00:30:05.630 --> 00:30:09.580
永不动

00:30:07.149 --> 00:30:12.169
因为那将是非常低效的

00:30:09.580 --> 00:30:13.880
所以我们倾向于移动很多物体

00:30:12.169 --> 00:30:16.789
在一起或大多数对象在一起

00:30:13.880 --> 00:30:20.690
因为这样我们就可以通过

00:30:16.789 --> 00:30:23.929
解决所有问题的复杂性

00:30:20.690 --> 00:30:25.760
明智的做法，即使这在

00:30:23.929 --> 00:30:27.890
繁重的操作仅与

00:30:25.760 --> 00:30:29.750
生活，所以我们必须搬家

00:30:27.890 --> 00:30:32.240
对象，只给修复线

00:30:29.750 --> 00:30:35.000
引用，因此堆大小不

00:30:32.240 --> 00:30:38.419
真正改变了工作却带来了

00:30:35.000 --> 00:30:39.889
光的一面绝对可以

00:30:38.419 --> 00:30:44.750
我说过的另一种收藏家

00:30:39.889 --> 00:30:46.820
关于一个咖啡收集器，这需要

00:30:44.750 --> 00:30:49.610
来自前方空间的物体并移动

00:30:46.820 --> 00:30:51.350
他们从

00:30:49.610 --> 00:30:53.809
扎根移动您可以找到的一切

00:30:51.350 --> 00:30:56.269
放在一个新的空间，最后我们

00:30:53.809 --> 00:30:58.399
实际上是空的

00:30:56.269 --> 00:31:00.980
非常有效非常有效

00:30:58.399 --> 00:31:03.740
单程线性移动到生活

00:31:00.980 --> 00:31:08.210
方面，实际上是一个非常普遍的新闻

00:31:03.740 --> 00:31:10.340
一些机制的收集

00:31:08.210 --> 00:31:14.269
这里要记住的事情是它需要一个

00:31:10.340 --> 00:31:16.399
在一个简单的空间

00:31:14.269 --> 00:31:19.010
没想到其他事情会发生

00:31:16.399 --> 00:31:20.659
周围的收集器需要一样大

00:31:19.010 --> 00:31:22.610
作为太空，因为我们不知道

00:31:20.659 --> 00:31:23.990
每件事都是我们可能必须

00:31:22.610 --> 00:31:26.570
移动一切，这通常是

00:31:23.990 --> 00:31:30.740
整体式，您开始移动一切

00:31:26.570 --> 00:31:32.389
你不敢相信任何东西，所以

00:31:30.740 --> 00:31:35.659
空间需要我所有的空间

00:31:32.389 --> 00:31:36.980
与目前的热量一样大的东西

00:31:35.659 --> 00:31:40.700
因为我不知道那是多少

00:31:36.980 --> 00:31:43.700
就是这么简单，所以看着

00:31:40.700 --> 00:31:46.340
一些质量复制要求

00:31:43.700 --> 00:31:48.289
因为我刚才说的标记是2倍

00:31:46.340 --> 00:31:50.929
紧凑而不扫地

00:31:48.289 --> 00:31:53.299
疏散我的8 2 X 

00:31:50.929 --> 00:31:54.799
进行完全压缩的内存，但是

00:31:53.299 --> 00:31:57.620
可能会停在中间，因为

00:31:54.799 --> 00:31:59.539
一次打扫区域

00:31:57.620 --> 00:32:01.610
接触压实的地方不

00:31:59.539 --> 00:32:04.820
需要额外的内存来压缩，这是一个

00:32:01.610 --> 00:32:07.789
咖啡和马克都不错的公共汽车

00:32:04.820 --> 00:32:09.559
紧致仅线性于量

00:32:07.789 --> 00:32:14.539
活的东西，是增长的甜蜜

00:32:09.559 --> 00:32:17.359
与热麦克风扫击

00:32:14.539 --> 00:32:19.279
并且对堆也是线性的，然后

00:32:17.359 --> 00:32:20.959
打标，有时紧凑I 

00:32:19.279 --> 00:32:23.209
没有太多谈论，但这是一个

00:32:20.959 --> 00:32:26.239
常见的试图与

00:32:23.209 --> 00:32:29.329
素食主义者然后我谈论了整体

00:32:26.239 --> 00:32:31.609
公司的一部分，让我们谈谈

00:32:29.329 --> 00:32:33.499
分代收集带来一些

00:32:31.609 --> 00:32:35.719
我一起谈论这些事情

00:32:33.499 --> 00:32:38.629
这些线性的效率

00:32:35.719 --> 00:32:40.729
原因生成算法

00:32:38.629 --> 00:32:45.379
收藏是一件很酷的事情

00:32:40.729 --> 00:32:46.129
在此基础上引入1984年

00:32:45.379 --> 00:32:49.190
观察

00:32:46.129 --> 00:32:51.349
这就是所谓的弱代假设

00:32:49.190 --> 00:32:54.379
如果是最乐观的对象

00:32:51.349 --> 00:32:57.139
年轻的意思是我看后不久

00:32:54.379 --> 00:32:59.649
大多数人死于那种

00:32:57.139 --> 00:33:05.690
不要等同于大多数生命对象

00:32:59.649 --> 00:33:08.719
是我认为大多数生活对象

00:33:05.690 --> 00:33:10.819
他们都是幸存下来的人， 

00:33:08.719 --> 00:33:14.119
动态地每十个对象我

00:33:10.819 --> 00:33:15.799
看九美元，这是非常

00:33:14.119 --> 00:33:20.209
强烈的观察通常会更多

00:33:15.799 --> 00:33:22.969
比知道这是工作

00:33:20.209 --> 00:33:24.949
真实或相信这是真实的，我们

00:33:22.969 --> 00:33:27.289
可以运用我们在

00:33:24.949 --> 00:33:29.509
提高效率的效率

00:33:27.289 --> 00:33:31.519
当我们这样做的世代收藏家

00:33:29.509 --> 00:33:33.049
当我们专注于所谓的弱点

00:33:31.519 --> 00:33:35.469
年轻一代的地区

00:33:33.049 --> 00:33:38.179
最近分配的内存

00:33:35.469 --> 00:33:41.179
相信绝大多数

00:33:38.179 --> 00:33:43.369
是绝大多数的意思是

00:33:41.179 --> 00:33:46.279
寿命设定的比例很小

00:33:43.369 --> 00:33:48.229
堆大小，所以我想选择一个

00:33:46.279 --> 00:33:50.089
仅与实时线性相关的算法

00:33:48.229 --> 00:33:52.549
设置而不是堆大小

00:33:50.089 --> 00:33:56.089
只要他们有效率

00:33:52.549 --> 00:33:59.479
大小相似，您在这里知道2倍，或者

00:33:56.089 --> 00:34:02.059
但如果我认为只有1％或

00:33:59.479 --> 00:34:04.099
 0.1％还活着，我申请了一份副本

00:34:02.059 --> 00:34:05.209
那个收藏家的一百倍

00:34:04.099 --> 00:34:10.669
睡觉更有效率

00:34:05.209 --> 00:34:13.190
收藏家如果这东西死了怎么办

00:34:10.669 --> 00:34:15.309
我们保持真实，我们如何做

00:34:13.190 --> 00:34:18.169
确保这个假设是正确的

00:34:15.309 --> 00:34:20.000
事情确实存在，如果我们坚持下去

00:34:18.169 --> 00:34:23.240
他们会不断积累的东西， 

00:34:20.000 --> 00:34:24.740
这种稀疏将不再是真的，所以

00:34:23.240 --> 00:34:26.790
已经存在了一段时间的事情

00:34:24.740 --> 00:34:28.679
我们必须放在其他地方

00:34:26.790 --> 00:34:30.720
我们需要年轻一代去做

00:34:28.679 --> 00:34:33.710
因为这个假设是正确的

00:34:30.720 --> 00:34:35.669
年轻的东西，那就是晋升

00:34:33.710 --> 00:34:37.860
已经存在了足够长的时间

00:34:35.669 --> 00:34:40.200
在其他地方，所以我们一直在

00:34:37.860 --> 00:34:41.940
现在那里的一代人

00:34:40.200 --> 00:34:45.960
在我见过人们调整的地方

00:34:41.940 --> 00:34:47.880
你也认识的年轻一代

00:34:45.960 --> 00:34:50.610
规模和晋升门槛从未达到

00:34:47.880 --> 00:34:52.710
促进尝试真的很难

00:34:50.610 --> 00:34:54.300
促进他们正在做的所有事情就是

00:34:52.710 --> 00:34:55.950
单代收藏家在哪里

00:34:54.300 --> 00:34:58.220
没有弱小的世代相传

00:34:55.950 --> 00:35:00.840
而所有的效率都在窗外

00:34:58.220 --> 00:35:04.650
你必须摆脱那把大汤匙

00:35:00.840 --> 00:35:06.120
一旦摆脱，效率就在那里

00:35:04.650 --> 00:35:07.650
他们，并把它们放在其他地方

00:35:06.120 --> 00:35:11.010
在其他地方收集事件

00:35:07.650 --> 00:35:12.780
充满时的一代

00:35:11.010 --> 00:35:16.260
任何收藏家会为他们使用

00:35:12.780 --> 00:35:19.350
这往往是一个顺序

00:35:16.260 --> 00:35:21.300
幅度加滤波器，所以今天和大多数时候

00:35:19.350 --> 00:35:23.430
我的意思是说工作量最大

00:35:21.300 --> 00:35:25.800
大部分工作负载

00:35:23.430 --> 00:35:27.960
看我们正在看的GC长格式

00:35:25.800 --> 00:35:29.520
两者之间的比例为十比十二

00:35:27.960 --> 00:35:31.380
如果我们有一个工作，我们需要做的工作

00:35:29.520 --> 00:35:33.420
分代收藏家，如果我们做到了

00:35:31.380 --> 00:35:37.410
同样尴尬的是

00:35:33.420 --> 00:35:40.260
有效过滤器很少

00:35:37.410 --> 00:35:41.910
做这个魔术所需的事情

00:35:40.260 --> 00:35:43.440
维持我们称为我的东西

00:35:41.910 --> 00:35:45.300
记得第二件事，我们需要知道

00:35:43.440 --> 00:35:46.890
通往年轻一代的途径

00:35:45.300 --> 00:35:50.040
我们只能看看年轻人吗

00:35:46.890 --> 00:35:53.040
世代相传或根本不相传

00:35:50.040 --> 00:35:55.650
整个团队比赛都结束了，所以我们做到了

00:35:53.040 --> 00:35:57.270
让我们知道的东西

00:35:55.650 --> 00:35:59.190
从所有人到他们的所有指针

00:35:57.270 --> 00:36:03.570
为此纪念他们的各种技巧

00:35:59.190 --> 00:36:07.560
克拉克标志就是其中之一， 

00:36:03.570 --> 00:36:09.510
我会谈一点

00:36:07.560 --> 00:36:10.740
关于世代的其他好处

00:36:09.510 --> 00:36:13.230
收集是我们可以使用类似

00:36:10.740 --> 00:36:15.770
一代人集体复制，但

00:36:13.230 --> 00:36:19.440
那里没有2倍的内存，因为

00:36:15.770 --> 00:36:21.060
如果我们不能容纳整个

00:36:19.440 --> 00:36:23.820
首先的空间只会溢出

00:36:21.060 --> 00:36:25.440
它到了比利时，但是年轻

00:36:23.820 --> 00:36:28.560
代不一定是两倍

00:36:25.440 --> 00:36:30.120
大小，这就是为什么如果您查看热点

00:36:28.560 --> 00:36:33.600
例如伊甸园坑很多

00:36:30.120 --> 00:36:35.160
更大的幸存者空间不是你

00:36:33.600 --> 00:36:37.610
知道它会适合那里，只是

00:36:35.160 --> 00:36:37.610
它没有

00:36:38.759 --> 00:36:48.460
好吧，请记住它是这些

00:36:45.519 --> 00:36:51.039
我们想要涵盖的重要内容

00:36:48.460 --> 00:36:53.650
我会说一些关于他们的事情

00:36:51.039 --> 00:36:54.700
为了跟踪所有的点

00:36:53.650 --> 00:36:56.769
老一辈到年轻一代

00:36:54.700 --> 00:36:59.710
我们必须拦截任何

00:36:56.769 --> 00:37:01.210
存储这样的指针或扫描是另一个

00:36:59.710 --> 00:37:03.099
路由器效率降低的方式

00:37:01.210 --> 00:37:05.049
这就是为什么在

00:37:03.099 --> 00:37:07.029
大多数收藏家都是世代相传的

00:37:05.049 --> 00:37:09.309
跟踪所有指针的权限，因此

00:37:07.029 --> 00:37:10.839
它可以跟踪设置

00:37:09.309 --> 00:37:13.989
基本假设是这个集合非常

00:37:10.839 --> 00:37:16.119
稀疏，如果大部分拍卖

00:37:13.989 --> 00:37:18.519
指向引擎中的几周

00:37:16.119 --> 00:37:21.640
原始假设可能是错误的

00:37:18.519 --> 00:37:23.019
开始，所以它往往是非常好的

00:37:21.640 --> 00:37:25.029
以这种方式非常有效地工作

00:37:23.019 --> 00:37:27.579
卡标记是一种技术

00:37:25.029 --> 00:37:29.680
所有JVM都使用它似乎工作良好

00:37:27.579 --> 00:37:31.960
现在，如果我们把所有这些东西放在一起

00:37:29.680 --> 00:37:33.369
我们讨论了术语和机制

00:37:31.960 --> 00:37:35.890
让我们看看他们如何在一起

00:37:33.369 --> 00:37:39.640
成为真正的收藏家的年轻人

00:37:35.890 --> 00:37:41.140
产生所有的收藏家

00:37:39.640 --> 00:37:43.690
当前的生产收藏家是

00:37:41.140 --> 00:37:45.190
世代相传

00:37:43.690 --> 00:37:46.539
法律神圣的世代，我非常

00:37:45.190 --> 00:37:47.710
以后对你的演讲感兴趣

00:37:46.539 --> 00:37:51.339
解释了您必须如何做

00:37:47.710 --> 00:37:53.499
那一代不是，但在

00:37:51.339 --> 00:37:55.509
生产系统这绝对是

00:37:53.499 --> 00:37:57.730
真正的年轻人

00:37:55.509 --> 00:38:00.430
浓度通常是复制

00:37:57.730 --> 00:38:04.539
收藏家，通常是一个整体

00:38:00.430 --> 00:38:06.489
停止世界复制每个单词

00:38:04.539 --> 00:38:08.710
现在已经定义了这张幻灯片， 

00:38:06.489 --> 00:38:12.609
这些是我们谈论的术语

00:38:08.710 --> 00:38:15.759
不只是整个世代的话

00:38:12.609 --> 00:38:19.930
通常某种形式的商标契约可能

00:38:15.759 --> 00:38:21.999
甜蜜的不是老一辈

00:38:19.930 --> 00:38:23.680
像并发一样停止了世界

00:38:21.999 --> 00:38:25.269
可能是部分并发的

00:38:23.680 --> 00:38:27.160
增量将阻止世界

00:38:25.269 --> 00:38:28.569
通常结合使用

00:38:27.160 --> 00:38:35.170
那里很多有趣的地方

00:38:28.569 --> 00:38:38.589
如果我们超越未来，现在是不同的

00:38:35.170 --> 00:38:39.819
只是那些分类停止了

00:38:38.589 --> 00:38:41.529
世界，并停止了一个将是

00:38:39.819 --> 00:38:42.579
很简单，有一些已知的东西

00:38:41.529 --> 00:38:45.309
所有已经存在的技术

00:38:42.579 --> 00:38:47.000
一会儿，例如，如果我想

00:38:45.309 --> 00:38:50.130
标记不停止世界

00:38:47.000 --> 00:38:54.180
 g1收集器，CMS收集器

00:38:50.130 --> 00:38:56.490
做到这一点的一种方法是应对

00:38:54.180 --> 00:38:59.040
如果您这样做，就会发生简单的比赛

00:38:56.490 --> 00:39:00.420
并将其插入简单的种族

00:38:59.040 --> 00:39:03.450
如果我要走的话，将会发生

00:39:00.420 --> 00:39:06.420
标记画我所能看到的一切

00:39:03.450 --> 00:39:08.130
而且你知道变种人正在捡起

00:39:06.420 --> 00:39:09.990
我还没看过的物体

00:39:08.130 --> 00:39:11.839
在我后面提到了它

00:39:09.990 --> 00:39:15.030
我去过的地方，以后不会再去

00:39:11.839 --> 00:39:17.400
然后摆脱对它的所有引用

00:39:15.030 --> 00:39:19.440
我可能看不到对象

00:39:17.400 --> 00:39:21.180
标记为活着甚至可以收集它

00:39:19.440 --> 00:39:23.700
虽然还活着，那将是

00:39:21.180 --> 00:39:25.680
令人尴尬的，所以我们必须塞住

00:39:23.700 --> 00:39:27.450
不正确的打标比赛，只有

00:39:25.680 --> 00:39:29.040
一场真正的并发工作竞赛

00:39:27.450 --> 00:39:31.140
需要以某种方式插入

00:39:29.040 --> 00:39:32.700
防止传播

00:39:31.140 --> 00:39:35.250
有些东西不只是

00:39:32.700 --> 00:39:37.579
访客常用的方式之一

00:39:35.250 --> 00:39:45.540
要做到这一点是与多遍字幕

00:39:37.579 --> 00:39:47.369
想法有你跟踪的每一个

00:39:45.540 --> 00:39:49.290
内存中每个指针的变异

00:39:47.369 --> 00:39:51.690
成为您跟踪的指针的权利

00:39:49.290 --> 00:39:53.490
那然后当你完成你的

00:39:51.690 --> 00:39:55.349
并发通行证，你说的很好

00:39:53.490 --> 00:39:57.510
可能不错，但是我错过了一些东西

00:39:55.349 --> 00:39:59.579
所以我们走吧，让我们看看一切

00:39:57.510 --> 00:40:02.910
一切变异的东西

00:39:59.579 --> 00:40:04.740
当你看完所有

00:40:02.910 --> 00:40:07.319
您标记为我感动的东西

00:40:04.740 --> 00:40:09.750
这也许你完成了，但也许你

00:40:07.319 --> 00:40:11.760
感觉良好时需要再次做

00:40:09.750 --> 00:40:13.230
当您认为列表是

00:40:11.760 --> 00:40:16.380
小，你可能会阻止世界， 

00:40:13.230 --> 00:40:18.780
根据算法完成工作

00:40:16.380 --> 00:40:20.880
您已经使用过，也许可以做到这一点

00:40:18.780 --> 00:40:23.940
是否收敛

00:40:20.880 --> 00:40:25.950
 CMS仅收集了三个

00:40:23.940 --> 00:40:27.540
尝试，我们将有一些未知数

00:40:25.950 --> 00:40:29.310
十个工作集，但g1 

00:40:27.540 --> 00:40:30.869
收集器使用快照

00:40:29.310 --> 00:40:33.930
可以证明的开始标记

00:40:30.869 --> 00:40:37.050
这会聚，但这是技巧

00:40:33.930 --> 00:40:39.869
该示例涉及跟踪

00:40:37.050 --> 00:40:44.849
当您将所有权利写入

00:40:39.869 --> 00:40:47.160
热量现在使您失去了其他兴趣

00:40:44.849 --> 00:40:49.020
你可以做的就是尽量不要紧凑

00:40:47.160 --> 00:40:51.450
如果您一次将整个宇宙

00:40:49.020 --> 00:40:52.980
同意压实抢它，然后

00:40:51.450 --> 00:40:55.400
您尝试做增量压缩

00:40:52.980 --> 00:40:58.500
这基本上就是你想要的

00:40:55.400 --> 00:40:59.820
这意味着我们追踪十字架

00:40:58.500 --> 00:41:03.930
地区的东西

00:40:59.820 --> 00:41:06.180
区域之间的指针作为

00:41:03.930 --> 00:41:08.460
不同类型的记忆，然后

00:41:06.180 --> 00:41:10.350
我们尝试找到只有一个

00:41:08.460 --> 00:41:12.720
指向他们的其他一些地区或

00:41:10.350 --> 00:41:16.110
区域集仅指向一个

00:41:12.720 --> 00:41:17.940
一小部分区域，我们将

00:41:16.110 --> 00:41:19.860
知道我只需要的目标区域

00:41:17.940 --> 00:41:21.300
将指针固定在一小部分中

00:41:19.860 --> 00:41:23.340
地区而不是弘基，但我

00:41:21.300 --> 00:41:25.710
希望我能找到这些设置

00:41:23.340 --> 00:41:27.960
实际上效果很好，但是可以

00:41:25.710 --> 00:41:29.850
遇到堕落的行为

00:41:27.960 --> 00:41:31.710
最后是一个非常空的区域

00:41:29.850 --> 00:41:33.510
非常受欢迎的物品，所以您不会

00:41:31.710 --> 00:41:35.160
将其压缩，然后您将

00:41:33.510 --> 00:41:36.900
最终其他地区也一样

00:41:35.160 --> 00:41:41.060
必须压缩偶数的微小部分

00:41:36.900 --> 00:41:43.500
韧带，所以那些基本上

00:41:41.060 --> 00:41:46.080
改进，但它们是我的一部分

00:41:43.500 --> 00:41:48.150
称之为否认的必然趋势

00:41:46.080 --> 00:41:51.360
一般我们开始垃圾收集

00:41:48.150 --> 00:41:53.610
有了一些了解，你不能

00:41:51.360 --> 00:41:56.490
摆脱压实，然后我们

00:41:53.610 --> 00:41:58.800
基本上说让我们去空之后

00:41:56.490 --> 00:42:00.240
空间或更便宜的空间来获得

00:41:58.800 --> 00:42:01.770
从头开始，我们应用

00:42:00.240 --> 00:42:04.080
一代代的收藏家很棒

00:42:01.770 --> 00:42:06.930
效率技术，但也减少了

00:42:04.080 --> 00:42:09.960
停下来直到我们要做祭坛

00:42:06.930 --> 00:42:11.100
但最终你必须发展

00:42:09.960 --> 00:42:12.540
然后你看着道尔顿说

00:42:11.100 --> 00:42:15.420
好吧，我不想压缩整个

00:42:12.540 --> 00:42:17.220
也许我可以避免将其压缩

00:42:15.420 --> 00:42:20.270
也许我可以把东西放在免费清单上

00:42:17.220 --> 00:42:25.230
一段时间，直到我不得不将其压缩

00:42:20.270 --> 00:42:26.730
 CMS就是这么做的，但最终如此

00:42:25.230 --> 00:42:28.590
你看着那个压实说

00:42:26.730 --> 00:42:30.240
我不必一次做，也许我

00:42:28.590 --> 00:42:33.480
一次可以做一件，那就是

00:42:30.240 --> 00:42:35.490
她想要我们，但最终你是

00:42:33.480 --> 00:42:37.650
将不得不处理受欢迎的物品

00:42:35.490 --> 00:42:40.680
其他压力只需要出现

00:42:37.650 --> 00:42:42.560
如果我们看看自然

00:42:40.680 --> 00:42:45.720
您今天处理的收藏家

00:42:42.560 --> 00:42:48.450
我最常说的分类

00:42:45.720 --> 00:42:52.320
首先，我们先来看一下

00:42:48.450 --> 00:42:56.730
您看到LTC是经典的桶装

00:42:52.320 --> 00:42:58.530
收集器有危险的整体停止

00:42:56.730 --> 00:42:59.940
世界复制代理几乎

00:42:58.530 --> 00:43:03.600
我所说的一切都与

00:42:59.940 --> 00:43:06.270
它也有整体停止的方式

00:43:03.600 --> 00:43:08.520
世界标记的睡眠紧凑好吧

00:43:06.270 --> 00:43:13.420
很像顶

00:43:08.520 --> 00:43:18.250
高效，快速停止世界

00:43:13.420 --> 00:43:20.440
对于它所做的一切，我们来看一下

00:43:18.250 --> 00:43:23.260
 CMS并发标记清除收集器

00:43:20.440 --> 00:43:26.410
普通收集器用于热敏

00:43:23.260 --> 00:43:28.630
你们怎么看待

00:43:26.410 --> 00:43:34.840
牛顿给年轻的收藏家

00:43:28.630 --> 00:43:37.500
 CMS收集器的分类

00:43:34.840 --> 00:43:37.500
种公司

00:43:38.040 --> 00:43:43.840
这是一个单块的世界

00:43:40.660 --> 00:43:45.730
复制收集器是完全一样的

00:43:43.840 --> 00:43:48.280
算法分类是奇偶校验

00:43:45.730 --> 00:43:51.010
看看与CMS有什么关系

00:43:48.280 --> 00:43:54.160
嗯，CMS并没有以其古老的名字命名

00:43:51.010 --> 00:43:56.110
一代人的行为

00:43:54.160 --> 00:43:59.100
是一个整体的世界收藏家

00:43:56.110 --> 00:44:02.250
它不是并发的，也不是三月

00:43:59.100 --> 00:44:05.050
老一代是他们大多数并发

00:44:02.250 --> 00:44:08.230
在学术论文中如此描述

00:44:05.050 --> 00:44:10.150
描述算法主要不是

00:44:08.230 --> 00:44:11.680
压实沃尔顿，它有很多

00:44:10.150 --> 00:44:13.590
通过标记，该标记几乎是并发的

00:44:11.680 --> 00:44:16.980
它有一个完全并行的卧铺

00:44:13.590 --> 00:44:20.530
将内容保存在Sweetman和免费列表中

00:44:16.980 --> 00:44:24.400
然后它有这个不紧凑

00:44:20.530 --> 00:44:26.230
这是最主要的部分

00:44:24.400 --> 00:44:28.930
因为你无法摆脱

00:44:26.230 --> 00:44:31.120
压缩，所以这就是当

00:44:28.930 --> 00:44:36.820
它必须紧凑它做一个整体

00:44:31.120 --> 00:44:38.800
停止世界标记甜蜜紧凑型CMS 

00:44:36.820 --> 00:44:40.840
除了是中子之间的过滤器

00:44:38.800 --> 00:44:42.190
而你看到的折叠是有效的

00:44:40.840 --> 00:44:45.790
过滤器，但最终您必须

00:44:42.190 --> 00:44:47.260
关注这是一个存在的重要原因

00:44:45.790 --> 00:44:48.700
作为收藏家，因为

00:44:47.260 --> 00:44:52.720
意识到你无法摆脱

00:44:48.700 --> 00:44:56.650
上下文，所以让我们看一下G 1是什么

00:44:52.720 --> 00:44:59.100
 G 1加G 1的新代是

00:44:56.650 --> 00:45:02.770
增量垃圾优先

00:44:59.100 --> 00:45:05.320
李，这是一个整体的东西

00:45:02.770 --> 00:45:10.390
世界复制收藏家，你知道这个

00:45:05.320 --> 00:45:13.840
凯文这就是简所有的一切

00:45:10.390 --> 00:45:16.090
并发标记，但这要好得多

00:45:13.840 --> 00:45:16.820
主要是比其他工人

00:45:16.090 --> 00:45:23.450
可证明地

00:45:16.820 --> 00:45:25.040
它会证明收敛，所以您不能

00:45:23.450 --> 00:45:29.770
运行一个应用程序，它将使其运行

00:45:25.040 --> 00:45:34.040
永远，但是它阻止了世界

00:45:29.770 --> 00:45:36.680
主要是增量对流，它不会

00:45:34.040 --> 00:45:39.380
同时比较，它停止了世界

00:45:36.680 --> 00:45:41.000
唯一的压缩方式

00:45:39.380 --> 00:45:42.470
释放内存是为了进行比较，因此

00:45:41.000 --> 00:45:43.970
到达内存的唯一方法是停止

00:45:42.470 --> 00:45:48.260
世界，但它试图做到这一点

00:45:43.970 --> 00:45:50.360
小增量，我实际上有一个

00:45:48.260 --> 00:45:53.810
引用目标设计

00:45:50.360 --> 00:45:56.150
说我们的收藏家的目标

00:45:53.810 --> 00:45:58.250
尽量避免

00:45:56.150 --> 00:46:04.850
完整的TC会告诉您什么

00:45:58.250 --> 00:46:07.040
那里有按设计的HEC设计

00:46:04.850 --> 00:46:10.190
这是您负担得起的网站

00:46:07.040 --> 00:46:12.830
跌倒以试图摆脱

00:46:10.190 --> 00:46:15.680
用增量做正确的事情，但是

00:46:12.830 --> 00:46:17.660
你最终可能不会花更长的时间

00:46:15.680 --> 00:46:19.040
也许您可以使用它们，以便您

00:46:17.660 --> 00:46:34.210
应用程序不会持续很长时间

00:46:19.040 --> 00:46:36.350
时间，但由设计师Fugees可以，所以我

00:46:34.210 --> 00:46:37.880
分类正常热点

00:46:36.350 --> 00:46:39.950
收集您今天可以使用的

00:46:37.880 --> 00:46:41.630
我要谈一点

00:46:39.950 --> 00:46:43.460
单片停止世界的看到

00:46:41.630 --> 00:46:45.500
问题或停止整个世界

00:46:43.460 --> 00:46:48.470
但是有很多方法可以应对

00:46:45.500 --> 00:46:53.840
世界上一些最大的GC 

00:46:48.470 --> 00:46:55.400
普通的方式，所以你知道你可以走了

00:46:53.840 --> 00:46:58.160
在其他谈话中谈论如何

00:46:55.400 --> 00:47:00.980
您合适吧，想象这不是一个

00:46:58.160 --> 00:47:03.110
问题之一可能是对其进行调整，以便

00:47:00.980 --> 00:47:05.930
在没有GC声明的情况下运行了这么长时间

00:47:03.110 --> 00:47:08.120
成功，您知道40分钟没有GC游戏

00:47:05.930 --> 00:47:09.590
但是你看起来更长一些，你会看到

00:47:08.120 --> 00:47:11.060
他们是小故障，你看看

00:47:09.590 --> 00:47:15.170
天，你会发现有规律

00:47:11.060 --> 00:47:18.830
小故障的另一种方法是使用创意

00:47:15.170 --> 00:47:20.660
使自己感觉更好的语言

00:47:18.830 --> 00:47:22.280
关于您已经停止的事实

00:47:20.660 --> 00:47:23.900
您所看到的将冻结您的

00:47:22.280 --> 00:47:25.460
没有充分的理由整个申请

00:47:23.900 --> 00:47:27.250
除了收藏家想要的

00:47:25.460 --> 00:47:30.590
召集

00:47:27.250 --> 00:47:33.350
这些是营销的实际句子

00:47:30.590 --> 00:47:35.420
网络上的材料和设计目标

00:47:33.350 --> 00:47:39.140
弥补这些是从

00:47:35.420 --> 00:47:41.240
 GVM I的实际营销材料

00:47:39.140 --> 00:47:45.310
无法命名，但我可以说它有

00:47:41.240 --> 00:47:47.510
与确定性有关

00:47:45.310 --> 00:47:50.450
辉煌的一句话说我会

00:47:47.510 --> 00:47:53.320
保证5毫秒的更坏情况

00:47:50.450 --> 00:47:56.240
百分之十九的时间

00:47:53.320 --> 00:47:59.210
听起来不是很好，这是一个

00:47:56.240 --> 00:48:02.990
保证我会指出

00:47:59.210 --> 00:48:05.540
一小时的百分比是36秒

00:48:02.990 --> 00:48:12.530
一次可以暂停36秒

00:48:05.540 --> 00:48:21.650
小时，我已经达到了保证金或360 

00:48:12.530 --> 00:48:23.900
毫秒是没有意义的

00:48:21.650 --> 00:48:25.940
能让您感觉良好的陈述，但

00:48:23.900 --> 00:48:28.310
正如我所说，主要还有其他人

00:48:25.940 --> 00:48:32.859
大多在东西前面让人

00:48:28.310 --> 00:48:35.359
感觉到他们的意思就是这样

00:48:32.859 --> 00:48:36.890
这就是它的字面意思

00:48:35.359 --> 00:48:38.210
告诉你就对了你很诚实

00:48:36.890 --> 00:48:39.560
只想以另一种方式阅读它

00:48:38.210 --> 00:48:43.670
想要它，您不想听到关于

00:48:39.560 --> 00:48:45.830
我听说过的餐厅非常一致

00:48:43.670 --> 00:48:47.990
很多你知道这是一个电话

00:48:45.830 --> 00:48:50.570
实际上是未来版本的Jekyll 

00:48:47.990 --> 00:48:53.390
的g1始终低于

00:48:50.570 --> 00:48:55.130
 500毫秒，字面意思是

00:48:53.390 --> 00:48:57.890
有时候我们会比

00:48:55.130 --> 00:49:00.080
这是正确的方式

00:48:57.890 --> 00:49:02.180
而典型的积极因素将在

00:49:00.080 --> 00:49:03.920
数十毫秒的字面意思是我们

00:49:02.180 --> 00:49:05.570
将有典当它在更大

00:49:03.920 --> 00:49:08.990
如此密集的毫秒

00:49:05.570 --> 00:49:10.790
对，所以这些都是让你成功的好方法

00:49:08.990 --> 00:49:12.530
感觉很好但是如果你真的有

00:49:10.790 --> 00:49:14.690
使应用程序真实存在

00:49:12.530 --> 00:49:20.330
您可能想要实际测量的世界

00:49:14.690 --> 00:49:22.640
这是怎么回事，并获得足够的开放

00:49:20.330 --> 00:49:25.000
采购一切，如果您

00:49:22.640 --> 00:49:29.119
您的实际Higa事物行为

00:49:25.000 --> 00:49:29.630
应用程序哦，我们不是15 

00:49:29.119 --> 00:49:32.510
分钟

00:49:29.630 --> 00:49:33.890
我要快两分钟

00:49:32.510 --> 00:49:36.680
为此事道歉

00:49:33.890 --> 00:49:40.670
所以c4是一个收集器，我们已经解决了

00:49:36.680 --> 00:49:43.160
这个问题解决你的问题

00:49:40.670 --> 00:49:45.230
可以稍后在线查找幻灯片，但是

00:49:43.160 --> 00:49:47.690
从根本上说，如果对它进行分类

00:49:45.230 --> 00:49:50.690
极好的保证单程标记

00:49:47.690 --> 00:49:54.350
无法完成并发压缩

00:49:50.690 --> 00:49:56.150
分类为压缩并发

00:49:54.350 --> 00:49:58.550
收集选项和并发

00:49:56.150 --> 00:50:01.760
压榨玉金这是唯一的非

00:49:58.550 --> 00:50:04.220
现在暂停新性别，JVM 

00:50:01.760 --> 00:50:06.140
或运行时间通常没有

00:50:04.220 --> 00:50:09.410
后退以阻止我们所没有的世界

00:50:06.140 --> 00:50:11.390
知道如何执行此操作的代码

00:50:09.410 --> 00:50:13.100
没有傻瓜TC没有停止

00:50:11.390 --> 00:50:15.550
没有我做不到的，所以我们会

00:50:13.100 --> 00:50:18.200
停下来坚持

00:50:15.550 --> 00:50:20.480
在设计方面，它是围绕该概念构建的

00:50:18.200 --> 00:50:22.490
总是做同样的事情，从不

00:50:20.480 --> 00:50:26.470
急着很多算法

00:50:22.490 --> 00:50:26.470
设计是要确保这是真的

00:50:34.450 --> 00:50:42.740
算法很酷的东西你可以看到这个

00:50:38.000 --> 00:50:50.930
在线，但让我们谈谈它的作用

00:50:42.740 --> 00:50:53.090
对您的应用程序而言

00:50:50.930 --> 00:50:55.010
事情是我们照顾像GC这样的事情

00:50:53.090 --> 00:50:57.620
进行调整，因此您不再需要这样做

00:50:55.010 --> 00:51:00.230
或者这只是你做这种

00:50:57.620 --> 00:51:02.420
填充并调整堆大小，直到

00:51:00.230 --> 00:51:06.410
它会破裂，然后将其放大三倍然后回家

00:51:02.420 --> 00:51:08.930
对，所以您知道调整GC的样子

00:51:06.410 --> 00:51:10.760
这样你就可以得到真实的行为

00:51:08.930 --> 00:51:12.680
这是Cassandra的应用程序

00:51:10.760 --> 00:51:17.660
运行一个不规则的服务器

00:51:12.680 --> 00:51:20.480
一秒钟，你就可以跑步了

00:51:17.660 --> 00:51:22.990
具有更高吞吐量的应用程序

00:51:20.480 --> 00:51:25.580
每台机器，如果您在乎我们

00:51:22.990 --> 00:51:27.140
如果从机器中获得更多收益， 

00:51:25.580 --> 00:51:28.850
您将更多机器投入使用的原因

00:51:27.140 --> 00:51:33.280
因为如果您投入过多，SLA就不好

00:51:28.850 --> 00:51:35.870
从根本上进行工作就是

00:51:33.280 --> 00:51:38.830
 c4确实是并发的

00:51:35.870 --> 00:51:41.420
并发倾倒在超级收集器中

00:51:38.830 --> 00:51:43.579
你可以来我们的展位，你可以来

00:51:41.420 --> 00:51:45.890
能够听到我是否清除了一个

00:51:43.579 --> 00:51:47.780
下一位发言者，对不起

00:51:45.890 --> 00:51:50.319
我以为当时的惊喜

00:51:47.780 --> 00:51:50.319
我在另一个

