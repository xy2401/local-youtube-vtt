WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.900 --> 00:00:08.750
 [音乐] 

00:00:04.779 --> 00:00:12.679
大家好

00:00:08.750 --> 00:00:14.750
我要去的时候很少

00:00:12.679 --> 00:00:17.329
一如既往，我们只有很少的时间，所以我们

00:00:14.750 --> 00:00:18.949
首先放弃重要的业务

00:00:17.329 --> 00:00:20.960
然后我们去谈我想要的

00:00:18.949 --> 00:00:23.149
得到自拍照，我需要你们所有人假装

00:00:20.960 --> 00:00:25.369
就像你很快乐，公正，只是说

00:00:23.149 --> 00:00:26.630
当我说开源和

00:00:25.369 --> 00:00:28.909
我们一起拍张照片

00:00:26.630 --> 00:00:34.039
会很棒的，好吧，好吧，好吧

00:00:28.909 --> 00:00:38.510
准备好稳定的疮和奥萨尔这

00:00:34.039 --> 00:00:40.160
疮疮，谢谢你，我的朋友们，我

00:00:38.510 --> 00:00:45.910
非常感谢你

00:00:40.160 --> 00:00:45.910
来你好吗哦，那太好了

00:00:46.030 --> 00:00:53.089
你在我的那种II 

00:00:49.609 --> 00:00:56.719
意思是你在天堂之外见过

00:00:53.089 --> 00:00:59.170
在这里我们你知道我爱我爱

00:00:56.719 --> 00:01:02.359
尽可能多的软件，但是

00:00:59.170 --> 00:01:05.030
美丽的巴塞罗那在我们身边

00:01:02.359 --> 00:01:06.500
我们是我们只有很少的时间，所以我

00:01:05.030 --> 00:01:08.030
想鼓励您注意

00:01:06.500 --> 00:01:10.610
您可以在顶部看到此幻灯片

00:01:08.030 --> 00:01:14.090
有一个git仓库

00:01:10.610 --> 00:01:16.100
实际上是在线八个小时

00:01:14.090 --> 00:01:18.350
我训练的时间是八个小时

00:01:16.100 --> 00:01:19.790
培训，那里有很多东西

00:01:18.350 --> 00:01:22.490
包括我们要谈论的内容

00:01:19.790 --> 00:01:23.960
今天，还有更多，所以你知道

00:01:22.490 --> 00:01:26.990
你可以免费得到所有这些

00:01:23.960 --> 00:01:28.579
你会很像你知道的

00:01:26.990 --> 00:01:30.110
了解我们要讲的基础知识

00:01:28.579 --> 00:01:32.390
关于测试，我们将要通过

00:01:30.110 --> 00:01:34.880
今天有很多东西可以，目标是

00:01:32.390 --> 00:01:36.469
经历很多东西，但有些

00:01:34.880 --> 00:01:38.659
我们要覆盖的重要部分

00:01:36.469 --> 00:01:40.250
实际上只有几分钟

00:01:38.659 --> 00:01:42.649
将被更深入地覆盖

00:01:40.250 --> 00:01:44.960
由安迪·威尔金森（Andy Wilkinson）发表

00:01:42.649 --> 00:01:46.490
在春季进行测试，这是一个

00:01:44.960 --> 00:01:48.710
很好的谈话，我想你知道

00:01:46.490 --> 00:01:50.450
如果我们可以合并这个话题

00:01:48.710 --> 00:01:52.340
在一起，包括他的然后

00:01:50.450 --> 00:01:54.740
然后将我的周围包括在内

00:01:52.340 --> 00:01:56.119
是个好故事，但我推荐你

00:01:54.740 --> 00:01:57.320
享受这个，然后我们要

00:01:56.119 --> 00:01:58.850
要经历很多事情，然后

00:01:57.320 --> 00:02:01.100
你去看看安迪·威尔金森的演讲

00:01:58.850 --> 00:02:04.280
上面会有关于特定细节的信息

00:02:01.100 --> 00:02:05.780
这段讨论还可以

00:02:04.280 --> 00:02:07.850
关于我的一点名字我叫乔希

00:02:05.780 --> 00:02:09.640
在春季团队中，我在Twitter上如何

00:02:07.850 --> 00:02:12.550
你们很多人只是好奇不是推特

00:02:09.640 --> 00:02:14.840
 2019我一直想知道这个推特

00:02:12.550 --> 00:02:18.500
 2009年推特

00:02:14.840 --> 00:02:22.340
 kiin twitter twitter其余的一切都很好

00:02:18.500 --> 00:02:24.230
你在做什么你就得到它

00:02:22.340 --> 00:02:26.239
在Twitter上，这是个好地方

00:02:24.230 --> 00:02:27.620
新的IRC是针对开发人员的

00:02:26.239 --> 00:02:29.690
驱动开源，您的力量

00:02:27.620 --> 00:02:31.640
生意很好，我也很好

00:02:29.690 --> 00:02:35.209
可以通过电子邮件获取有多少人

00:02:31.640 --> 00:02:37.310
电子邮件电子邮件是您使用的东西

00:02:35.209 --> 00:02:39.890
电子邮件，我不是，我不是很大的电子邮件

00:02:37.310 --> 00:02:42.319
人，但另一方面我更喜欢

00:02:39.890 --> 00:02:47.150
放松吧，我有一个全新的

00:02:42.319 --> 00:02:49.370
 MacBook Pro配备32个演出，32个演出

00:02:47.150 --> 00:02:53.569
公羊的那是足以运行

00:02:49.370 --> 00:02:55.760
几乎是松弛，这很重要

00:02:53.569 --> 00:02:57.950
那仍然令我兴奋

00:02:55.760 --> 00:03:00.860
偏爱电子邮件一点点写

00:02:57.950 --> 00:03:02.750
关于我，我在 The Spring Team 工作

00:03:00.860 --> 00:03:04.340
知道那很酷，我在那里很幸运

00:03:02.750 --> 00:03:06.470
去了中国，他们做了一个小玩具

00:03:04.340 --> 00:03:08.690
从我身上出来很好

00:03:06.470 --> 00:03:10.099
我在Safari上有这些培训视频

00:03:08.690 --> 00:03:12.739
在线，您可以找到各种各样的

00:03:10.099 --> 00:03:15.079
这些是不同的内容

00:03:12.739 --> 00:03:16.790
不同的深入讨论

00:03:15.079 --> 00:03:18.290
话题，这些通常是你知道的

00:03:16.790 --> 00:03:20.329
四或五六七八小时的

00:03:18.290 --> 00:03:21.670
内容我有一本书叫云

00:03:20.329 --> 00:03:23.630
本机Java关于如何构建

00:03:21.670 --> 00:03:26.120
能够在其中生存和发展的应用程序

00:03:23.630 --> 00:03:28.010
我有一个叫做a的播客

00:03:26.120 --> 00:03:30.680
您可以在每个星期五进行美丽的播客

00:03:28.010 --> 00:03:33.260
转到Google Play或iTunes或

00:03:30.680 --> 00:03:36.010
不论发现什么播客

00:03:33.260 --> 00:03:38.209
下载您可以找到他们的

00:03:36.010 --> 00:03:39.859
每个星期三都进行截屏

00:03:38.209 --> 00:03:42.230
星期三，我看了一个新的截屏视频

00:03:39.859 --> 00:03:44.840
在春季生态系统的某个部分

00:03:42.230 --> 00:03:47.209
我们昨天做的事情就是全部

00:03:44.840 --> 00:03:49.389
关于从Spring Batch处理中使用Kafka 

00:03:47.209 --> 00:03:51.680
我认为这非常有趣， 

00:03:49.389 --> 00:03:54.319
我有一本新书哦，你想要那本书

00:03:51.680 --> 00:03:56.060
照片还可以，我们有一本新书

00:03:54.319 --> 00:03:58.130
新书叫做反应性Spring 

00:03:56.060 --> 00:03:59.569
是自我发布的，它在您的精益酒吧中

00:03:58.130 --> 00:04:00.709
现在可以在那里找到它

00:03:59.569 --> 00:04:02.989
已经开始阅读它了

00:04:00.709 --> 00:04:04.819
 200页的内容，我要添加

00:04:02.989 --> 00:04:06.739
如果您现在购买，价格还会更高，而且

00:04:04.819 --> 00:04:08.599
那么你可以知道当最后

00:04:06.739 --> 00:04:10.340
书出来了，你得到了最终版

00:04:08.599 --> 00:04:11.900
但您不支付任何额外费用

00:04:10.340 --> 00:04:13.250
便宜的价格，然后它是

00:04:11.900 --> 00:04:16.400
比最终版便宜

00:04:13.250 --> 00:04:18.169
后来所有这些东西所有这些东西

00:04:16.400 --> 00:04:19.729
那我今天为什么要和你在一起

00:04:18.169 --> 00:04:21.799
如果我能花时间谈论

00:04:19.729 --> 00:04:24.260
什么我为什么要谈论测试

00:04:21.799 --> 00:04:26.150
我认为测试是其中之一

00:04:24.260 --> 00:04:27.290
频谱的一部分

00:04:26.150 --> 00:04:29.060
我们的连续体

00:04:27.290 --> 00:04:30.800
必须处理我们不是真的

00:04:29.060 --> 00:04:32.690
考虑一下，直到我们到达一个地方

00:04:30.800 --> 00:04:34.970
我们需要测试我的意思的地方

00:04:32.690 --> 00:04:36.830
那就是我们一直在谈论微

00:04:34.970 --> 00:04:39.290
服务和云计算以及

00:04:36.830 --> 00:04:42.500
持续交付和所有这些东西

00:04:39.290 --> 00:04:44.870
激励或更确切地说，他们支持

00:04:42.500 --> 00:04:47.210
更快构建软件的目标

00:04:44.870 --> 00:04:49.580
始终从概念中转移价值

00:04:47.210 --> 00:04:51.830
更快地服务于客户，这已经

00:04:49.580 --> 00:04:53.120
人们普遍拥有的东西

00:04:51.830 --> 00:04:54.620
最近十年来一直在谈论

00:04:53.120 --> 00:04:55.130
我当然一直在谈论

00:04:54.620 --> 00:04:56.960
很多

00:04:55.130 --> 00:05:00.170
微服务和持续交付

00:04:56.960 --> 00:05:02.870
和敏捷，所有这些东西都在

00:05:00.170 --> 00:05:05.630
将软件部署到

00:05:02.870 --> 00:05:08.000
您对部署业务了解的业务

00:05:05.630 --> 00:05:11.090
获得价值时更快地实现生产价值

00:05:08.000 --> 00:05:13.340
沿着那条路，你非常

00:05:11.090 --> 00:05:14.720
很快发现是为了做

00:05:13.340 --> 00:05:17.900
为了真正利用

00:05:14.720 --> 00:05:20.690
这种快速运动需要

00:05:17.900 --> 00:05:22.400
任何人都可以安全

00:05:20.690 --> 00:05:25.160
开一辆真正的快车

00:05:22.400 --> 00:05:27.050
墙不是很有用的速度

00:05:25.160 --> 00:05:28.820
本身不是很有用，您需要什么

00:05:27.050 --> 00:05:31.490
是某种可以校准的东西

00:05:28.820 --> 00:05:33.770
要测量以计量它，这是一个

00:05:31.490 --> 00:05:36.320
在我们想要的情况下测试线束

00:05:33.770 --> 00:05:38.300
每次我们介绍的验证

00:05:36.320 --> 00:05:40.280
改变并尽快介绍

00:05:38.300 --> 00:05:42.290
我们知道这种变化的变化

00:05:40.280 --> 00:05:45.020
没有破坏我们所要做的

00:05:42.290 --> 00:05:47.360
意味着拥有安全性，所以我们想要

00:05:45.020 --> 00:05:49.580
快速安全地进行生产

00:05:47.360 --> 00:05:51.950
我认为测试确实是最重要的

00:05:49.580 --> 00:05:54.340
最后一句话的重要部分

00:05:51.950 --> 00:05:56.390
安全，所以当我们谈论测试时

00:05:54.340 --> 00:05:59.740
认为我们大多数人都很熟悉

00:05:56.390 --> 00:06:02.630
绝对的基础

00:05:59.740 --> 00:06:04.340
测试整体应用程序权限

00:06:02.630 --> 00:06:05.480
但我认为事情变得越来越多

00:06:04.340 --> 00:06:07.460
当你开始进入一个有趣的

00:06:05.480 --> 00:06:09.710
您所见的分布式系统世界

00:06:07.460 --> 00:06:11.660
现在事情变得分散了

00:06:09.710 --> 00:06:13.610
现在他们需要整合， 

00:06:11.660 --> 00:06:15.590
问题在于当您移至

00:06:13.610 --> 00:06:17.180
一个微服务世界，您会发现

00:06:15.590 --> 00:06:20.750
您的数量越来越多

00:06:17.180 --> 00:06:23.090
代码库成为集成测试

00:06:20.750 --> 00:06:25.310
很难验证您在做什么

00:06:23.090 --> 00:06:27.200
这个新世界，所以我们想做什么

00:06:25.310 --> 00:06:29.180
是我们要获得快速反馈的目标吗

00:06:27.200 --> 00:06:31.820
这是为了快速反馈而优化

00:06:29.180 --> 00:06:33.530
我能多快部署一个想法并获得

00:06:31.820 --> 00:06:34.940
这个想法的结果，然后

00:06:33.530 --> 00:06:38.450
结合他们的反馈

00:06:34.940 --> 00:06:40.729
进入下一个迭代，如果我是

00:06:38.450 --> 00:06:42.740
花我所有的时间，我们

00:06:40.729 --> 00:06:44.839
为应用服务器启动或

00:06:42.740 --> 00:06:47.300
如果我花所有的时间等待

00:06:44.839 --> 00:06:51.430
我花钱时要编译的C ++代码

00:06:47.300 --> 00:06:55.219
我所有的时间都在等待整合

00:06:51.430 --> 00:06:57.020
在CI上运行的代码

00:06:55.219 --> 00:06:59.180
环境，那我就不会

00:06:57.020 --> 00:07:02.240
会很快移动，我会

00:06:59.180 --> 00:07:04.279
踢出区域，这是一个

00:07:02.240 --> 00:07:06.620
问题权，我们想要，我们想要留下

00:07:04.279 --> 00:07:08.539
永久在该地区想享受

00:07:06.620 --> 00:07:10.550
感觉我们正在前进

00:07:08.539 --> 00:07:12.439
我们正在进步，而随着我们

00:07:10.550 --> 00:07:14.719
向前迈进，我们取得良好的结果

00:07:12.439 --> 00:07:17.270
顺便说一下，这使我们进入了下一个

00:07:14.719 --> 00:07:19.610
指出留在该区域的愿望

00:07:17.270 --> 00:07:20.960
这种渴望不断

00:07:19.610 --> 00:07:23.990
反馈而不是拥有这些

00:07:20.960 --> 00:07:25.879
生产力之河，然后漫长

00:07:23.990 --> 00:07:28.460
只是等待和等待的时期

00:07:25.879 --> 00:07:32.990
等待那个目标，那种感觉

00:07:28.460 --> 00:07:35.240
我们正在迅速行动，而不仅仅是

00:07:32.990 --> 00:07:37.159
希望这是一个要求

00:07:35.240 --> 00:07:39.139
对方式绝对关键

00:07:37.159 --> 00:07:41.270
您使用软件，这就是为什么

00:07:39.139 --> 00:07:42.379
我们还将讨论测试

00:07:41.270 --> 00:07:44.449
我们将谈论测试驱动

00:07:42.379 --> 00:07:45.830
发展很好，今天我们要谈

00:07:44.449 --> 00:07:47.300
关于测试驱动的开发和

00:07:45.830 --> 00:07:49.370
测试驱动开发背后的想法是

00:07:47.300 --> 00:07:50.930
很简单，您之前编写测试

00:07:49.370 --> 00:07:53.180
您编写业务逻辑，这是

00:07:50.930 --> 00:07:54.439
重要，因为我希望您的大多数

00:07:53.180 --> 00:07:57.620
写作测试都是你们写作

00:07:54.439 --> 00:08:02.270
测试谁在写谁，测试我好

00:07:57.620 --> 00:08:06.050
没有看到所有的手，所以你也许知道

00:08:02.270 --> 00:08:08.089
你有像我这样的工作

00:08:06.050 --> 00:08:09.909
在舞台上写一些简单的东西

00:08:08.089 --> 00:08:12.830
主要是关于您知道的ASCII艺术作品

00:08:09.909 --> 00:08:15.020
也许我不知道，但是你应该

00:08:12.830 --> 00:08:17.990
除非你像查克一样，否则就写测试

00:08:15.020 --> 00:08:19.279
诺里斯（Norris）或您应有的权利

00:08:17.990 --> 00:08:23.149
编写测试，写起来很好

00:08:19.279 --> 00:08:24.949
之后进行测试，但可能会有点

00:08:23.149 --> 00:08:27.319
有点压抑的感觉就像是家务

00:08:24.949 --> 00:08:29.899
所以我们想要去的地方

00:08:27.319 --> 00:08:32.300
在这里我们可以编写代码并交付

00:08:29.899 --> 00:08:35.060
重视生产，我们可以留在

00:08:32.300 --> 00:08:36.110
该区域，所以当我们谈论

00:08:35.060 --> 00:08:38.029
当我们谈论测试驱动时

00:08:36.110 --> 00:08:39.860
开发测试员Mandela男人

00:08:38.029 --> 00:08:42.349
一个简单的想法，你先写测试，然后

00:08:39.860 --> 00:08:44.420
然后编写生产代码， 

00:08:42.349 --> 00:08:46.699
满足测试，所以您写了一个破

00:08:44.420 --> 00:08:49.069
测试，然后您写一点

00:08:46.699 --> 00:08:51.620
生产代码可以满足该测试

00:08:49.069 --> 00:08:52.910
测试变绿这通常是

00:08:51.620 --> 00:08:54.649
如果您看到正在结伴的人

00:08:52.910 --> 00:08:56.749
他们称这种射线为编程

00:08:54.649 --> 00:08:58.639
绿色重构你写某人

00:08:56.749 --> 00:09:00.230
编写破损的代码破损的测试

00:08:58.639 --> 00:09:02.180
然后有人写绿色

00:09:00.230 --> 00:09:04.699
使测试顺利进行的生产代码

00:09:02.180 --> 00:09:06.529
绿色的权利，你乒乓球回来， 

00:09:04.699 --> 00:09:07.819
第四，我写了一个破碎的单元测试你

00:09:06.529 --> 00:09:09.649
编写一些生产代码以修复

00:09:07.819 --> 00:09:11.720
单元测试，然后我们继续正确

00:09:09.649 --> 00:09:13.879
通常你也不想写

00:09:11.720 --> 00:09:15.410
很多测试，因为它会破坏

00:09:13.879 --> 00:09:17.149
如果您再写一封，请立即

00:09:15.410 --> 00:09:18.529
断言会断，所以你写

00:09:17.149 --> 00:09:20.209
多一点生产代码

00:09:18.529 --> 00:09:21.709
现在是绿色，然后又是绿色

00:09:20.209 --> 00:09:23.569
然后你回去，最终你得到

00:09:21.709 --> 00:09:24.980
进入这个循环，你不断

00:09:23.569 --> 00:09:27.589
之间来回乒乓

00:09:24.980 --> 00:09:31.850
生产代码和测试代码以及​​此

00:09:27.589 --> 00:09:34.459
看起来非常，你知道它是湍流的

00:09:31.850 --> 00:09:36.529
像起初的颠簸飞机一样

00:09:34.459 --> 00:09:37.610
可能会使工作非常混乱

00:09:36.529 --> 00:09:39.619
这样，因为你不断

00:09:37.610 --> 00:09:43.309
在两块之间来回移动

00:09:39.619 --> 00:09:45.559
代码，但是一旦习惯了

00:09:43.309 --> 00:09:47.269
可以非常非常满意地工作

00:09:45.559 --> 00:09:49.579
这样，原因是因为你

00:09:47.269 --> 00:09:51.319
最终通过写来做几件事

00:09:49.579 --> 00:09:54.199
在编写您的测试时首先要进行测试

00:09:51.319 --> 00:09:57.230
首先测试您编写的代码可以

00:09:54.199 --> 00:09:58.579
测试这很重要，如果您

00:09:57.230 --> 00:10:00.679
写满私人的代码

00:09:58.579 --> 00:10:02.629
静态类，那么你就不会

00:10:00.679 --> 00:10:04.399
享受测试该代码的过程

00:10:02.629 --> 00:10:07.490
很难测试

00:10:04.399 --> 00:10:08.689
代码，所以您不会这样做，因为

00:10:07.490 --> 00:10:10.309
你知道你要写

00:10:08.689 --> 00:10:11.360
测试会测试这个东西，所以你

00:10:10.309 --> 00:10:13.339
不会做这些事情

00:10:11.360 --> 00:10:15.290
很难让您完成工作， 

00:10:13.339 --> 00:10:17.809
当您编写可测试的代码时

00:10:15.290 --> 00:10:20.720
就是说你写的很干净

00:10:17.809 --> 00:10:21.589
包含可测试部分的代码

00:10:20.720 --> 00:10:23.029
隔离

00:10:21.589 --> 00:10:26.029
那不是真的好吗

00:10:23.029 --> 00:10:27.529
面向对象的设计能够考虑

00:10:26.029 --> 00:10:29.449
摆脱不变的事物

00:10:27.529 --> 00:10:31.100
变种的东西写在

00:10:29.449 --> 00:10:32.720
测试您是否有想要的东西

00:10:31.100 --> 00:10:34.339
测试，然后围绕的事物

00:10:32.720 --> 00:10:37.129
你想成为不变的

00:10:34.339 --> 00:10:38.809
能够隔离以便做到这一点

00:10:37.129 --> 00:10:40.429
需要能够交换出部分

00:10:38.809 --> 00:10:42.350
您需要具备的对象图

00:10:40.429 --> 00:10:44.629
替换亲笔签名的部分

00:10:42.350 --> 00:10:46.879
当然什么是好的方法

00:10:44.629 --> 00:10:50.470
编写支持该目标的代码

00:10:46.879 --> 00:10:53.540
清除代码库中的边界

00:10:50.470 --> 00:10:55.429
依赖注入权好干净

00:10:53.540 --> 00:10:57.589
可测试的代码是依赖注入

00:10:55.429 --> 00:10:59.749
友好的代码，所以这些东西都有

00:10:57.589 --> 00:11:00.860
一直是春天和测试的朋友

00:10:59.749 --> 00:11:03.350
一直是朋友，一直都是

00:11:00.860 --> 00:11:05.959
进行更多测试的目标

00:11:03.350 --> 00:11:08.030
春季代替生产权

00:11:05.959 --> 00:11:11.360
部署这个巨大的应用服务器，然后

00:11:08.030 --> 00:11:13.040
通过在EJB中运行代码来测试代码

00:11:11.360 --> 00:11:14.690
服务器或任何你可以采取的

00:11:13.040 --> 00:11:17.720
小pojo一个常规的Java对象， 

00:11:14.690 --> 00:11:19.460
只是孤立地戳它，所以当你

00:11:17.720 --> 00:11:21.560
首先编写测试，然后编写代码

00:11:19.460 --> 00:11:24.050
更清洁，它更面向对象

00:11:21.560 --> 00:11:26.060
更具有明确的界限

00:11:24.050 --> 00:11:27.440
忘了还有另一个好处

00:11:26.060 --> 00:11:29.240
关于技术的东西忘了

00:11:27.440 --> 00:11:30.950
架构和代码清洁度

00:11:29.240 --> 00:11:33.350
还有一个更重要的一点

00:11:30.950 --> 00:11:35.600
这是非常令人满意的

00:11:33.350 --> 00:11:37.010
首先写你的测试，我的意思是

00:11:35.600 --> 00:11:38.690
大脑的水平

00:11:37.010 --> 00:11:41.180
大脑中的化学物质令人满意

00:11:38.690 --> 00:11:45.500
就像我说的人类一样

00:11:41.180 --> 00:11:49.430
我们的大脑被连接起来以识别和

00:11:45.500 --> 00:11:52.970
寻求与成就相关的奖励

00:11:49.430 --> 00:11:54.710
所以我敢肯定你们中的一些人会

00:11:52.970 --> 00:11:58.100
感谢你们有多少人在玩

00:11:54.710 --> 00:12:00.740
好的，你们有多少电子游戏

00:11:58.100 --> 00:12:02.210
我是说我喜欢代码，所以

00:12:00.740 --> 00:12:03.740
一种选择，你们当中有多少人喜欢

00:12:02.210 --> 00:12:06.830
编码，您就可以回家了

00:12:03.740 --> 00:12:08.960
在自己的空闲时间好吧

00:12:06.830 --> 00:12:10.730
关于慢跑和跑步等运动

00:12:08.960 --> 00:12:14.450
这些K你知道那种

00:12:10.730 --> 00:12:17.180
好的，所以我要继续

00:12:14.450 --> 00:12:19.040
在这里走一走，我要继续

00:12:17.180 --> 00:12:23.180
并说那些说他们的人

00:12:19.040 --> 00:12:25.100
慢跑爱说谎没有人

00:12:23.180 --> 00:12:26.930
其实喜欢慢跑，他们喜欢得到

00:12:25.100 --> 00:12:30.440
到终点线那是

00:12:26.930 --> 00:12:31.670
不同，我不想伤害我

00:12:30.440 --> 00:12:33.470
想去终点线然后走

00:12:31.670 --> 00:12:35.930
对电子游戏做了同样的事情吗

00:12:33.470 --> 00:12:37.600
为什么我们为什么人们花那么多钱

00:12:35.930 --> 00:12:39.350
坐在视频游戏中的时间，或者

00:12:37.600 --> 00:12:42.680
进行编程，有多少人

00:12:39.350 --> 00:12:44.300
在9点钟坐下

00:12:42.680 --> 00:12:45.620
早上，你正在做某事

00:12:44.300 --> 00:12:46.820
并且您正在取得良好的进步， 

00:12:45.620 --> 00:12:48.050
你在工作，你在工作， 

00:12:46.820 --> 00:12:50.840
你在工作，下一件事

00:12:48.050 --> 00:12:54.350
知道现在是晚上六点或九点

00:12:50.840 --> 00:12:56.450
还是明天或以后

00:12:54.350 --> 00:12:58.520
那样的日子或你认识多个日子

00:12:56.450 --> 00:12:59.870
好的日子，我确定你们有多少人

00:12:58.520 --> 00:13:02.300
有这样的事情，我们迷路了

00:12:59.870 --> 00:13:04.760
随着时间的流逝，我们称之为进入

00:13:02.300 --> 00:13:06.260
正确的区域是一个非常重要的方面

00:13:04.760 --> 00:13:08.120
我们在这里尝试做的事情

00:13:06.260 --> 00:13:10.280
进入区域以及我们进入的原因

00:13:08.120 --> 00:13:12.980
带有代码和慢跑的区域，以及

00:13:10.280 --> 00:13:14.060
电子游戏是因为这些

00:13:12.980 --> 00:13:17.360
我们做得正确

00:13:14.060 --> 00:13:20.900
我们达到流程，达到状态

00:13:17.360 --> 00:13:21.810
有一个恒定的小视野

00:13:20.900 --> 00:13:24.960
在做

00:13:21.810 --> 00:13:26.910
如果我们能取得缓慢而稳定的进步

00:13:24.960 --> 00:13:28.440
我们感到向着地平线前进

00:13:26.910 --> 00:13:31.410
就像我们要移动到某个地方

00:13:28.440 --> 00:13:33.090
我们的大脑喜欢它渴望的

00:13:31.410 --> 00:13:35.220
所以当您使用测试驱动程序时

00:13:33.090 --> 00:13:37.230
您正在为此优化的开发

00:13:35.220 --> 00:13:39.900
多巴胺打击大脑的那种感觉

00:13:37.230 --> 00:13:41.610
说哦，这太棒了

00:13:39.900 --> 00:13:43.380
当你通过绿色测试时

00:13:41.610 --> 00:13:46.230
它的反馈感觉就像你在

00:13:43.380 --> 00:13:47.640
到达某个地方，那太棒了

00:13:46.230 --> 00:13:49.260
因为如果您进行绿色测试， 

00:13:47.640 --> 00:13:50.580
您正在进行测试驱动的开发

00:13:49.260 --> 00:13:52.080
进行绿色测试也意味着您已经

00:13:50.580 --> 00:13:54.660
附带了您拥有的软件

00:13:52.080 --> 00:13:56.760
这是正确的比较

00:13:54.660 --> 00:13:58.050
反之亦然

00:13:56.760 --> 00:13:59.850
先写代码，然后再写

00:13:58.050 --> 00:14:02.160
如果我有代码，则测试良好

00:13:59.850 --> 00:14:03.630
第一次工作就可以了

00:14:02.160 --> 00:14:05.580
太好了，这就像哦，太棒了

00:14:03.630 --> 00:14:09.089
代码有效，但现在我必须去写

00:14:05.580 --> 00:14:11.670
测试是一件琐事

00:14:09.089 --> 00:14:13.770
对，我要去写

00:14:11.670 --> 00:14:16.230
文档，也许我接下来会做

00:14:13.770 --> 00:14:18.120
你知道的时间，那是另一个

00:14:16.230 --> 00:14:19.560
事情是你，你感觉很好，不是

00:14:18.120 --> 00:14:22.770
重要的是它已经在

00:14:19.560 --> 00:14:27.750
我的机器对，我们都说过

00:14:22.770 --> 00:14:29.250
著名的遗言，所以如果您有

00:14:27.750 --> 00:14:31.110
纪律要先写测试

00:14:29.250 --> 00:14:33.150
不会陷入那种情况，你会

00:14:31.110 --> 00:14:35.880
写更干净的代码

00:14:33.150 --> 00:14:37.980
有测试，这是你知道的你可以

00:14:35.880 --> 00:14:39.600
那些测试可以做的事情

00:14:37.980 --> 00:14:41.670
你可以带你有信心

00:14:39.600 --> 00:14:44.610
这些测试的结果

00:14:41.670 --> 00:14:45.930
就像我说的那样，多巴胺受到打击等等

00:14:44.610 --> 00:14:48.830
您至少可以更快地移动

00:14:45.930 --> 00:14:51.900
感觉会更快，所以所有这些原因

00:14:48.830 --> 00:14:53.730
我认为所有这些原因都很重要

00:14:51.900 --> 00:14:56.070
在考虑测试驱动的开发时

00:14:53.730 --> 00:14:57.540
好吧，我们要编写测试只是

00:14:56.070 --> 00:15:00.150
今天我们要写很多测试

00:14:57.540 --> 00:15:04.320
使用spring的代码，当然我是

00:15:00.150 --> 00:15:07.220
我第二次当然要这么做

00:15:04.320 --> 00:15:07.220
互联网上最喜欢的地方

00:15:10.160 --> 00:15:17.330
今天春天开始，哦，这是我的

00:15:15.980 --> 00:15:19.400
互联网上第二受欢迎的地方

00:15:17.330 --> 00:15:21.620
生产后一如既往

00:15:19.400 --> 00:15:23.630
我爱你应该爱的作品

00:15:21.620 --> 00:15:24.890
你应该去的生产是早

00:15:23.630 --> 00:15:26.930
经常

00:15:24.890 --> 00:15:28.250
带孩子带家人

00:15:26.930 --> 00:15:29.690
天气太神奇了，这是最快乐的一天

00:15:28.250 --> 00:15:32.870
地球上比欧元还好

00:15:29.690 --> 00:15:33.860
迪士尼，但如果您没有去过

00:15:32.870 --> 00:15:34.970
生产即可开始您的旅程

00:15:33.860 --> 00:15:40.610
开始这里

00:15:34.970 --> 00:15:42.140
如果需要的话，那就是春天

00:15:40.610 --> 00:15:46.780
灵感来自清晨

00:15:42.140 --> 00:15:48.760
那个春天开始喝杯茶或咖啡

00:15:46.780 --> 00:15:52.370
那个IO 

00:15:48.760 --> 00:15:58.220
如果你的孩子们躁动不安，他们

00:15:52.370 --> 00:16:03.500
无法入睡的那个春天开始

00:15:58.220 --> 00:16:09.760
如果你以后消化不良

00:16:03.500 --> 00:16:09.760
一整夜的酗酒和PHP 

00:16:17.679 --> 00:16:26.540
从那个春天开始，我哦，好吧

00:16:25.699 --> 00:16:28.129
我们将建立一个新的应用程序

00:16:26.540 --> 00:16:29.600
我们将其称为生产者， 

00:16:28.129 --> 00:16:31.279
我们只会带来一些反应

00:16:29.600 --> 00:16:32.509
的东西，所以我想我大部分

00:16:31.279 --> 00:16:34.249
在这一点上你应该很熟悉

00:16:32.509 --> 00:16:36.079
有一些反应性的支持和

00:16:34.249 --> 00:16:37.730
春天，我们要创造一个反应

00:16:36.079 --> 00:16:40.040
应用程序，一个Web应用程序

00:16:37.730 --> 00:16:42.259
到反应性的MongoDB数据库

00:16:40.040 --> 00:16:44.059
使用Spring 切割合同验证器

00:16:42.259 --> 00:16:45.649
好吧，这里只是一堆东西

00:16:44.059 --> 00:16:47.899
我们要点击generate，我要

00:16:45.649 --> 00:16:50.989
在我的下载中打开此项目

00:16:47.899 --> 00:16:52.549
目录，所以ueo生产者在那里

00:16:50.989 --> 00:16:54.379
这将打开IntelliJ 

00:16:52.549 --> 00:16:55.699
不管您使用什么工具

00:16:54.379 --> 00:16:57.079
使用我要使用我喜欢的IntelliJ 

00:16:55.699 --> 00:16:59.299
聪明，但任何支持

00:16:57.079 --> 00:17:00.739
 Java 8或更高版本可以在

00:16:59.299 --> 00:17:02.569
这种情况下，我们将建立一个

00:17:00.739 --> 00:17:05.000
从测试开始的应用程序

00:17:02.569 --> 00:17:10.449
总是这样，让我们​​结束这就是

00:17:05.000 --> 00:17:13.220
错误的项目告别你

00:17:10.449 --> 00:17:14.329
现在这里的目标只是现在

00:17:13.220 --> 00:17:15.350
将数据写入到的应用程序

00:17:14.329 --> 00:17:17.419
数据库，所以我们要做的第一件事

00:17:15.350 --> 00:17:19.610
要做的就是忽略生产代码

00:17:17.419 --> 00:17:21.380
并直接进行测试，您会注意到

00:17:19.610 --> 00:17:23.029
当您使用 spring boot 和

00:17:21.380 --> 00:17:25.159
春天的初始化，你得到一种

00:17:23.029 --> 00:17:27.110
测试的空存根，这是一个

00:17:25.159 --> 00:17:28.429
有趣的是，它很好

00:17:27.110 --> 00:17:30.470
提醒我们应该做的

00:17:28.429 --> 00:17:32.000
某些事情，但老实说，我永远不会

00:17:30.470 --> 00:17:33.740
保持这个测试，我总是只丢这个

00:17:32.000 --> 00:17:35.059
马上我想开始一个不同的

00:17:33.740 --> 00:17:36.769
方式，这是第一件事，但这是

00:17:35.059 --> 00:17:38.000
很高兴我们有那个

00:17:36.769 --> 00:17:39.559
重要的是要知道我们确实有

00:17:38.000 --> 00:17:40.760
我们之所以拥有那是因为

00:17:39.559 --> 00:17:42.380
您在

00:17:40.760 --> 00:17:44.840
具有测试支持的初始值设定项

00:17:42.380 --> 00:17:46.460
建立依赖关系没有

00:17:44.840 --> 00:17:50.779
复选框，我不必选择

00:17:46.460 --> 00:17:52.130
在2019年之前假设

00:17:50.779 --> 00:17:54.320
您将正确编写测试

00:17:52.130 --> 00:17:56.360
没有办法选择退出，所以我们

00:17:54.320 --> 00:17:57.590
有默认情况下，所以现在我想

00:17:56.360 --> 00:17:59.000
写测试，我第一件事

00:17:57.590 --> 00:18:00.799
会做，因为我们知道我会

00:17:59.000 --> 00:18:02.480
将数据写入数据库

00:18:00.799 --> 00:18:04.190
使用我要创建一个实体或

00:18:02.480 --> 00:18:05.809
现在有两个不同的对象

00:18:04.190 --> 00:18:07.940
讨论有两种不同的火车

00:18:05.809 --> 00:18:10.669
关于您应该如何做的想法

00:18:07.940 --> 00:18:12.799
测试你应该从内到外做

00:18:10.669 --> 00:18:14.990
你为最小的事情写测试

00:18:12.799 --> 00:18:16.940
在系统中，然后解决问题

00:18:14.990 --> 00:18:18.620
从基本到最大

00:18:16.940 --> 00:18:20.720
一直反对服务或

00:18:18.620 --> 00:18:22.669
内在的用户界面权限

00:18:20.720 --> 00:18:24.710
还是应该去外面的地方

00:18:22.669 --> 00:18:26.870
当你从外面工作时说话

00:18:24.710 --> 00:18:27.500
界面，用户界面或

00:18:26.870 --> 00:18:29.420
 REST API 

00:18:27.500 --> 00:18:30.830
然后开始向内编写代码

00:18:29.420 --> 00:18:32.540
向内写一些小东西， 

00:18:30.830 --> 00:18:34.960
有两种不同的思考方式

00:18:32.540 --> 00:18:37.100
如果你从内部开始

00:18:34.960 --> 00:18:38.810
从底部开始，如果您考虑一下

00:18:37.100 --> 00:18:40.220
更具体的事情，如果你在

00:18:38.810 --> 00:18:43.820
最小的水平然后开始

00:18:40.220 --> 00:18:46.460
向外测试，那么你可以

00:18:43.820 --> 00:18:48.800
不同的团队在正确地工作

00:18:46.460 --> 00:18:50.450
不同的团队可以从不同的角度出发

00:18:48.800 --> 00:18:52.520
服务，他们可以从

00:18:50.450 --> 00:18:54.080
底部，他们可以并行工作，所以

00:18:52.520 --> 00:18:56.000
这可能对那很有好处

00:18:54.080 --> 00:18:58.400
更适合较大的团队

00:18:56.000 --> 00:19:00.970
如果您知道您的系统有一个

00:18:58.400 --> 00:19:03.320
集成层存在很大风险

00:19:00.970 --> 00:19:05.690
那对你来说可能更有价值

00:19:03.320 --> 00:19:06.950
从外面开始，因为那是

00:19:05.690 --> 00:19:08.330
风险就是你想要得到的

00:19:06.950 --> 00:19:11.420
那就是你要确定的

00:19:08.330 --> 00:19:13.460
对，所以你可以有一个像

00:19:11.420 --> 00:19:15.170
整体而言，这只是其中之一

00:19:13.460 --> 00:19:16.430
像制表符与空格之类的方式

00:19:15.170 --> 00:19:17.720
答案当然是空格，但是

00:19:16.430 --> 00:19:19.550
无论如何

00:19:17.720 --> 00:19:20.720
这就像您可以使用空格的制表符

00:19:19.550 --> 00:19:21.950
有一个完整的长期讨论

00:19:20.720 --> 00:19:24.470
这和两者都有充分的理由

00:19:21.950 --> 00:19:26.540
双方，我不在乎，好吧，我要

00:19:24.470 --> 00:19:29.080
会因为它而从内而外开始

00:19:26.540 --> 00:19:31.400
让我演示某些事情

00:19:29.080 --> 00:19:33.500
以自然顺序至少

00:19:31.400 --> 00:19:34.700
我好，所以首先要先

00:19:33.500 --> 00:19:36.200
创建一个实体，我要坚持下去

00:19:34.700 --> 00:19:37.700
在数据库中将其称为

00:19:36.200 --> 00:19:39.560
保留，所以我要创建一个

00:19:37.700 --> 00:19:41.450
只是为了证明那个

00:19:39.560 --> 00:19:42.800
对象在自身内部有效，所以我

00:19:41.450 --> 00:19:47.150
会创建一个像这样的简单测试

00:19:42.800 --> 00:19:49.370
公共无效创建，所以我们开始

00:19:47.150 --> 00:19:52.310
抛出那些不是编辑者的异常

00:19:49.370 --> 00:19:53.480
随便装什么，我们去

00:19:52.310 --> 00:19:57.440
只是成为对象所以我要去

00:19:53.480 --> 00:19:59.480
说保留R等于新

00:19:57.440 --> 00:20:01.070
预订，您可以看到我们已经

00:19:59.480 --> 00:20:02.270
没有实体

00:20:01.070 --> 00:20:04.280
我们没有类型，所以我要打

00:20:02.270 --> 00:20:06.050
创建类我有我的生产代码

00:20:04.280 --> 00:20:08.210
好，测试又是绿色的，可以这么说

00:20:06.050 --> 00:20:11.180
如果您遇到编译器错误

00:20:08.210 --> 00:20:13.100
测试失败，是红色，算作是

00:20:11.180 --> 00:20:15.020
现在测试失败了，我想创建一个

00:20:13.100 --> 00:20:17.930
具有有效状态的对象，我要去

00:20:15.020 --> 00:20:19.250
创建一个接受ID的构造函数

00:20:17.930 --> 00:20:21.470
一个参数，所以我将回到我的

00:20:19.250 --> 00:20:23.210
生产代码并在那里创建

00:20:21.470 --> 00:20:26.750
现在我可以创建构造函数，但是我

00:20:23.210 --> 00:20:29.180
我宁愿使用龙目岛，所以我

00:20:26.750 --> 00:20:33.020
只是要这样做，然后我们去

00:20:29.180 --> 00:20:34.970
现在有我的构造函数，等等，我去

00:20:33.020 --> 00:20:36.590
回到现在，我想证明

00:20:34.970 --> 00:20:39.850
这会工作，我要说断言

00:20:36.590 --> 00:20:42.880
等于你知道重新命名

00:20:39.850 --> 00:20:44.050
我想说简好吧，如果

00:20:42.880 --> 00:20:45.910
我进行了这项测试，您认为那会

00:20:44.050 --> 00:20:47.170
我希望它可能会全部工作

00:20:45.910 --> 00:20:48.790
我证明的是，如果我放点东西

00:20:47.170 --> 00:20:50.680
在构造函数中，我可以将其取回

00:20:48.790 --> 00:20:52.390
现在，这是测试您事物的一种方法

00:20:50.680 --> 00:20:54.850
在J中当然知道J 

00:20:52.390 --> 00:20:57.700
我可以做的是，如果我还有更多

00:20:54.850 --> 00:20:59.790
复杂的测试，我可以使用匹配器

00:20:57.700 --> 00:21:04.540
我可以说让我们使用匹配器

00:20:59.790 --> 00:21:08.860
你知道的床垫点等于忽略

00:21:04.540 --> 00:21:10.330
情况简好，这很简单

00:21:08.860 --> 00:21:11.950
表达的东西我也可以创造我的

00:21:10.330 --> 00:21:13.150
自己的床垫，这是这里

00:21:11.950 --> 00:21:15.490
这是一件好事

00:21:13.150 --> 00:21:17.800
我可以创建自己的匹配器，但是

00:21:15.490 --> 00:21:19.630
事情是你必须要小心

00:21:17.800 --> 00:21:22.390
非常诱人，因为那是

00:21:19.630 --> 00:21:23.920
应该在这里是一个匹配器，而遮罩是

00:21:22.390 --> 00:21:26.050
一个非常诱人的界面

00:21:23.920 --> 00:21:28.120
好吧，我将创建一个自己的匹配器

00:21:26.050 --> 00:21:30.460
知道如果您创建它将会发生

00:21:28.120 --> 00:21:33.000
你自己没读过地铁

00:21:30.460 --> 00:21:33.000
文件资料

00:21:37.450 --> 00:21:45.560
我认为他们正在尝试

00:21:41.600 --> 00:21:48.890
沟通，我认为他们正在努力

00:21:45.560 --> 00:21:53.570
告诉我们一些事情，所以不要这样做

00:21:48.890 --> 00:21:56.060
这样做很清楚，所以您

00:21:53.570 --> 00:21:57.740
得到一个新的低音捣碎器和低音

00:21:56.060 --> 00:21:59.360
匹配器只是一个非常简单的

00:21:57.740 --> 00:22:00.860
界面，您知道您可能没有

00:21:59.360 --> 00:22:03.320
做到这一点就可以了

00:22:00.860 --> 00:22:05.120
有一个低音匹配器，想法是

00:22:03.320 --> 00:22:08.930
你说好的，给定一个对象

00:22:05.120 --> 00:22:10.210
输入对象，我要说出一个点

00:22:08.930 --> 00:22:19.940
知道弦乐

00:22:10.210 --> 00:22:22.130
字符串项点护理为0等于或

00:22:19.940 --> 00:22:22.490
更好的是，我们可以做的是大写

00:22:22.130 --> 00:22:25.160
我们去

00:22:22.490 --> 00:22:27.800
字符是大写，所以我说

00:22:25.160 --> 00:22:30.290
给字符串一个名字，名字

00:22:27.800 --> 00:22:32.330
应该是大写的，如果有的话

00:22:30.290 --> 00:22:35.540
现在有一个错误我有一个地方你知道

00:22:32.330 --> 00:22:36.620
名称应为大写字母

00:22:35.540 --> 00:22:39.050
我应该写点生意

00:22:36.620 --> 00:22:40.370
强制执行此逻辑，但您得到

00:22:39.050 --> 00:22:42.350
现在我可以描述一个想法

00:22:40.370 --> 00:22:43.670
复杂的事情，更好的是我

00:22:42.350 --> 00:22:45.560
实际上可以将其提取到

00:22:43.670 --> 00:22:47.900
单独的班级和其他拥有

00:22:45.560 --> 00:22:50.000
相同的测试场景可以重用

00:22:47.900 --> 00:22:51.230
而不是每次都重新编码

00:22:50.000 --> 00:22:54.340
我们想写一次测试

00:22:51.230 --> 00:22:58.720
非常简单的例子，我们开始运行

00:22:54.340 --> 00:23:02.510
现在消息也是内置的

00:22:58.720 --> 00:23:04.790
好东西好吧现在好了

00:23:02.510 --> 00:23:08.140
你可以使用搜索我喜欢断言

00:23:04.790 --> 00:23:18.280
 J所以我在这里说断言不应该是真的

00:23:08.140 --> 00:23:22.750
 e点得到名称，而我断言为真

00:23:18.280 --> 00:23:25.000
断言，谢谢您，先生

00:23:22.750 --> 00:23:28.130
那

00:23:25.000 --> 00:23:31.059
还是不搜索

00:23:28.130 --> 00:23:36.380
 [音乐] 

00:23:31.059 --> 00:23:38.750
谢尔吉，gee-whiz等于

00:23:36.380 --> 00:23:40.549
忽略简，好吧，现在我明白了

00:23:38.750 --> 00:23:41.780
这种不错的类型可以节省完成次数

00:23:40.549 --> 00:23:43.549
你们这些人免费获得所有这些东西

00:23:41.780 --> 00:23:45.470
类路径已经不可行了

00:23:43.549 --> 00:23:47.210
有一些基本的东西，我们现在可以使用

00:23:45.470 --> 00:23:48.919
接下来要测试的是我的

00:23:47.210 --> 00:23:50.120
将该对象持久化到

00:23:48.919 --> 00:23:53.539
数据库，所以我要创建一个

00:23:50.120 --> 00:23:55.640
我要去预订实体测试

00:23:53.539 --> 00:23:57.590
将对象持久保存到MongoDB中

00:23:55.640 --> 00:23:59.510
为了坚持下去，我要

00:23:57.590 --> 00:24:01.280
会证明映射是正确的

00:23:59.510 --> 00:24:02.929
好吧，我要创建一个实体

00:24:01.280 --> 00:24:04.370
测试以证明这一点，我将创建一个

00:24:02.929 --> 00:24:07.309
保留我会说保留R 

00:24:04.370 --> 00:24:08.960
等于新的保留，我将通过

00:24:07.309 --> 00:24:11.990
 ID为null，然后Jane为

00:24:08.960 --> 00:24:14.210
名字，我想证明我可以说话

00:24:11.990 --> 00:24:17.330
到MongoDB，所以我要注入一个自动

00:24:14.210 --> 00:24:19.340
有线反应式MongoDB模板还可以

00:24:17.330 --> 00:24:21.650
而且我没有去写他们

00:24:19.340 --> 00:24:23.539
模板，我知道那是可行的

00:24:21.650 --> 00:24:24.950
现在下面的东西是我需要

00:24:23.539 --> 00:24:26.390
从某个地方得到这个春天

00:24:24.950 --> 00:24:27.770
已经知道如何创建它，所以我

00:24:26.390 --> 00:24:29.960
可以带来春天，但我不想

00:24:27.770 --> 00:24:31.700
测试我不想启动所有我的

00:24:29.960 --> 00:24:34.490
春季申请只是为了

00:24:31.700 --> 00:24:36.559
相反，我将使用测试切片

00:24:34.490 --> 00:24:38.120
说让我们使用Spring 渲染启动

00:24:36.559 --> 00:24:40.429
春天来了，然后我会用

00:24:38.120 --> 00:24:43.880
数据Mongo测试，所以这可以告诉我们

00:24:40.429 --> 00:24:45.980
春天嘿春天不要打扰所有

00:24:43.880 --> 00:24:47.720
自动配置只需使用自动

00:24:45.980 --> 00:24:49.490
与中的东西相关的配置

00:24:47.720 --> 00:24:51.440
数据库对，所以MongoDB在这

00:24:49.490 --> 00:24:52.909
案例安迪说话会做得很好

00:24:51.440 --> 00:24:55.520
关于这种测试的东西

00:24:52.909 --> 00:24:56.390
稍后会详细介绍，但我们

00:24:55.520 --> 00:24:59.030
需要知道的是我要说的是

00:24:56.390 --> 00:25:01.309
模板点保存预订，这就是

00:24:59.030 --> 00:25:02.780
现在要给我反应的结果

00:25:01.309 --> 00:25:04.520
编程给你这些东西

00:25:02.780 --> 00:25:06.380
叫做发布者mano是一种

00:25:04.520 --> 00:25:08.840
发布者发布者是异步的

00:25:06.380 --> 00:25:10.850
好的，所以测试变得非常困难

00:25:08.840 --> 00:25:12.500
当您执行异步反应数据时

00:25:10.850 --> 00:25:14.480
因为你没有数据

00:25:12.500 --> 00:25:16.490
保证数据将到来

00:25:14.480 --> 00:25:18.980
最终，所以有一个不错的

00:25:16.490 --> 00:25:21.799
在反应堆中抽象一个不错的API 

00:25:18.980 --> 00:25:25.100
是我们的反应式API，可让我们戳

00:25:21.799 --> 00:25:28.010
对结果持肯定态度

00:25:25.100 --> 00:25:30.049
在这里我可以说给这个出版商

00:25:28.010 --> 00:25:32.059
让我们断言保留

00:25:30.049 --> 00:25:37.370
回来的名字等于

00:25:32.059 --> 00:25:39.890
简，让我们断言ID不是

00:25:37.370 --> 00:25:41.510
知道是正确的，所以我们发送给no，但是当它

00:25:39.890 --> 00:25:42.509
从数据库返回它应该

00:25:41.510 --> 00:25:44.519
不知道

00:25:42.509 --> 00:25:47.609
好了，所以有反应性测试

00:25:44.519 --> 00:25:49.969
那里的机制好吧，让我们看看

00:25:47.609 --> 00:25:49.969
这样可行

00:25:51.469 --> 00:25:56.489
现在这是我们认为我认为这是

00:25:53.940 --> 00:25:58.499
如果我做了，可能会工作正常

00:25:56.489 --> 00:26:00.479
有些不同，也许我已经命名了我的

00:25:58.499 --> 00:26:01.979
例如，您知道的实体不同

00:26:00.479 --> 00:26:04.469
如果未命名为ID 

00:26:01.979 --> 00:26:05.820
 Mikey然后我不得不

00:26:04.469 --> 00:26:07.499
绑院长，我要确保

00:26:05.820 --> 00:26:10.409
正确工作，但按照惯例

00:26:07.499 --> 00:26:11.820
那个关键的领域命名思想命名

00:26:10.409 --> 00:26:13.469
正确地，如果我有不同的话

00:26:11.820 --> 00:26:14.849
证明你知道我可以做点什么

00:26:13.469 --> 00:26:16.079
在这里我实际上可以看

00:26:14.849 --> 00:26:17.879
注释，看看是否有效

00:26:16.079 --> 00:26:20.369
正确地工作MongoDB是

00:26:17.879 --> 00:26:22.709
显然工作正常，现在速度很快

00:26:20.369 --> 00:26:23.879
关于自定义查询权限的查询是

00:26:22.709 --> 00:26:25.859
字符串，你想做些什么

00:26:23.879 --> 00:26:28.259
测试，所以我要测试我的存储库

00:26:25.859 --> 00:26:29.940
我要创建一个存储库，但是

00:26:28.259 --> 00:26:32.489
我不用去测试我的

00:26:29.940 --> 00:26:34.199
我大部分的资料库都会

00:26:32.489 --> 00:26:37.709
工作就好了，那是春天

00:26:34.199 --> 00:26:40.139
数据团队在测试方面做得很好

00:26:37.709 --> 00:26:41.849
存储库的实现

00:26:40.139 --> 00:26:45.509
真正需要测试的唯一时间

00:26:41.849 --> 00:26:46.769
是当您使用自定义查询时

00:26:45.509 --> 00:26:50.190
我要注入我的预订

00:26:46.769 --> 00:26:51.539
仓库在这里好吧，我没有

00:26:50.190 --> 00:26:53.759
是的，这是生产代码，所以

00:26:51.539 --> 00:26:56.519
我们将创建它，它将成为

00:26:53.759 --> 00:26:59.639
接口，以便接口扩展

00:26:56.519 --> 00:27:02.249
反应堆存储库管理

00:26:59.639 --> 00:27:03.809
那里的预订你还可以，我

00:27:02.249 --> 00:27:07.859
想要创建一个自定义查询，说

00:27:03.809 --> 00:27:10.159
要求所有保留

00:27:07.859 --> 00:27:12.059
按名称，其中名称等于名称

00:27:10.159 --> 00:27:14.129
返回了那些结果，它将返回

00:27:12.059 --> 00:27:16.049
包含所有

00:27:14.129 --> 00:27:18.509
其预订名称的预订

00:27:16.049 --> 00:27:20.369
属性等于名称，所以有我的

00:27:18.509 --> 00:27:21.389
资料库，我想证明

00:27:20.369 --> 00:27:23.879
工作，所以我要做的就是我要去

00:27:21.389 --> 00:27:27.959
插入我要删除的所有内容

00:27:23.879 --> 00:27:31.469
该数据库我要写四个

00:27:27.959 --> 00:27:35.249
记录，然后我要按名称查询

00:27:31.469 --> 00:27:39.239
好吧，断言计数，这就是我的逻辑

00:27:35.249 --> 00:27:44.309
在这里，我要说的是通量，而不仅仅是ab 

00:27:39.239 --> 00:27:46.229
 cc点图名称等于新的保留

00:27:44.309 --> 00:27:48.209
传递一个null传递那个和什么

00:27:46.229 --> 00:27:50.579
我要保存的平面地图是

00:27:48.209 --> 00:27:52.979
像这样传入数据库

00:27:50.579 --> 00:27:55.410
在那里，那时候我要去

00:27:52.979 --> 00:27:57.840
说找到所有

00:27:55.410 --> 00:28:00.600
在数据库中与此字符串匹配

00:27:57.840 --> 00:28:02.850
在我这样做之前，我想说这个

00:28:00.600 --> 00:28:05.490
不是存储库，不要全部删除，然后

00:28:02.850 --> 00:28:07.470
好多，所以我要在一起

00:28:05.490 --> 00:28:10.320
这些我正在使用的反应流

00:28:07.470 --> 00:28:11.700
反应堆中的操作员这样做

00:28:10.320 --> 00:28:14.070
那我们去那是我的反应

00:28:11.700 --> 00:28:15.300
流，我想戳一下结果

00:28:14.070 --> 00:28:18.780
我要说的是步骤验证器

00:28:15.300 --> 00:28:21.810
创建预留流量期望下一个

00:28:18.780 --> 00:28:25.080
伯爵等于二我应该有两个

00:28:21.810 --> 00:28:29.030
类型为C或名称为C的结果

00:28:25.080 --> 00:28:29.030
让我们运行这段代码，看看我们得到了什么

00:28:30.770 --> 00:28:35.880
有时候似乎还可以

00:28:34.350 --> 00:28:38.040
虽然只是为了健康

00:28:35.880 --> 00:28:41.940
确保问自己总是好事

00:28:38.040 --> 00:28:43.440
我的测试不正确，结果是

00:28:41.940 --> 00:28:45.090
我得到了错误的结果，所以有时

00:28:43.440 --> 00:28:47.130
你可以测试负面的你

00:28:45.090 --> 00:28:48.570
打破测试，以便它应该显示一个

00:28:47.130 --> 00:28:52.950
失败只是让你知道

00:28:48.570 --> 00:28:54.420
一切正常，有时候我

00:28:52.950 --> 00:28:55.920
写这么多测试，它总是

00:28:54.420 --> 00:28:57.090
作品我觉得那是不对的

00:28:55.920 --> 00:28:59.010
不能那么好吧

00:28:57.090 --> 00:29:00.690
没办法，所以总是很好

00:28:59.010 --> 00:29:02.220
特别是深夜总是休息

00:29:00.690 --> 00:29:03.990
测试以确保您没有做

00:29:02.220 --> 00:29:04.620
疯狂的东西掩盖了

00:29:03.990 --> 00:29:06.360
真正的问题

00:29:04.620 --> 00:29:07.800
所以这就是我们期望的

00:29:06.360 --> 00:29:10.440
好吧，我们要放回两个

00:29:07.800 --> 00:29:11.970
而且我们知道现在情况很好，我想

00:29:10.440 --> 00:29:14.970
再向上移动一层

00:29:11.970 --> 00:29:18.540
创建一个保留HTTP API可以

00:29:14.970 --> 00:29:20.100
保留HTTP测试，这将

00:29:18.540 --> 00:29:23.520
成为可以测试网络的东西

00:29:20.100 --> 00:29:31.470
层，所以我要说查询还是没有得到

00:29:23.520 --> 00:29:36.270
所有的预订都可以，所以

00:29:31.470 --> 00:29:37.560
没关系，我要使用run with但

00:29:36.270 --> 00:29:39.360
我要在这里测试他们的鞭打

00:29:37.560 --> 00:29:41.820
不是我不想要的数据层

00:29:39.360 --> 00:29:43.500
测试我们已经做过的MongoDB东西

00:29:41.820 --> 00:29:45.390
那已经在工作，所以

00:29:43.500 --> 00:29:46.950
我要用一个网片和这个片

00:29:45.390 --> 00:29:49.260
会激活与

00:29:46.950 --> 00:29:51.750
网络层并为了测试我的

00:29:49.260 --> 00:29:55.950
反应性的HTTP API，我要注入

00:29:51.750 --> 00:29:58.440
网络测试客户端可以，这是

00:29:55.950 --> 00:30:02.070
打电话预约

00:29:58.440 --> 00:30:03.480
我期望数据会到来

00:30:02.070 --> 00:30:07.440
返回我会期待状态

00:30:03.480 --> 00:30:09.149
是HTTP 200，并且希望该正文

00:30:07.440 --> 00:30:11.190
或者标题包含内容

00:30:09.149 --> 00:30:13.229
与媒体类型兼容的类型

00:30:11.190 --> 00:30:16.080
应用程序JSON，我期待

00:30:13.229 --> 00:30:17.369
该主体具有JSON路径，如何

00:30:16.080 --> 00:30:19.139
你们很多人都知道JSON路径

00:30:17.369 --> 00:30:21.029
 Jason路径就像是一种查询语言

00:30:19.139 --> 00:30:23.369
深入文档

00:30:21.029 --> 00:30:26.519
 JSON对象（如exit）的结构

00:30:23.369 --> 00:30:29.489
 XPath从几年前还可以，所以等于

00:30:26.519 --> 00:30:31.739
简好吧，我要说的是

00:30:29.489 --> 00:30:34.379
我期待第一个结果回来

00:30:31.739 --> 00:30:36.389
第一个结果是要有一个名字

00:30:34.379 --> 00:30:40.679
等于简，我有第二个

00:30:36.389 --> 00:30:43.529
一个等于Jo好的，所以我们走了

00:30:40.679 --> 00:30:45.179
有我的两个记录，那是我的

00:30:43.529 --> 00:30:46.559
简单的测试，现在当然是什么

00:30:45.179 --> 00:30:48.960
这段代码首先是错误的

00:30:46.559 --> 00:30:50.940
当然可以，但不是

00:30:48.960 --> 00:30:53.279
编写任何生产代码，所以让我们

00:30:50.940 --> 00:30:57.149
这样做我可以看到已经有一个

00:30:53.279 --> 00:30:59.879
重要的部分好吧好吧这是一个

00:30:57.149 --> 00:31:01.469
配置类很棒，我要

00:30:59.879 --> 00:31:05.519
在此处使用功能性反应性端点

00:31:01.469 --> 00:31:07.349
我会说服务器响应和服务器

00:31:05.519 --> 00:31:11.519
反应只会产生一个简单的

00:31:07.349 --> 00:31:12.830
来吧，它试图告诉我使用

00:31:11.519 --> 00:31:18.479
Kotlin你看到了吗

00:31:12.830 --> 00:31:22.759
这些是Kotlin类型的，所以路线点

00:31:18.479 --> 00:31:28.109
建立我要说向前斜线

00:31:22.759 --> 00:31:31.289
保留新的处理程序功能

00:31:28.109 --> 00:31:34.349
所以我的工作将是注入

00:31:31.289 --> 00:31:36.779
预订库，这是我们的工作

00:31:34.349 --> 00:31:40.229
说服务器响应没问题， 

00:31:36.779 --> 00:31:41.609
找到所有预订舱位的RR如此

00:31:40.229 --> 00:31:44.309
有一个用lambda替换它

00:31:41.609 --> 00:31:47.159
静态导入非常简单的HTTP端点

00:31:44.309 --> 00:31:48.570
没什么大不了的，我现在要测试

00:31:47.159 --> 00:31:50.759
为了测试它，我当然

00:31:48.570 --> 00:31:53.639
需要引入配置类，所以我

00:31:50.759 --> 00:31:57.509
将使用该值，它将是

00:31:53.639 --> 00:32:01.289
保留HTTP测试等

00:31:57.509 --> 00:32:03.719
工作当然没有，有一对

00:32:01.289 --> 00:32:06.450
首先有明显的原因

00:32:03.719 --> 00:32:10.200
你看到我和简一起创造了两条记录

00:32:06.450 --> 00:32:11.519
和乔在里面，即使我做到了

00:32:10.200 --> 00:32:14.099
看起来我们甚至还没走得那么远

00:32:11.519 --> 00:32:16.320
首先看得好吗

00:32:14.099 --> 00:32:18.610
它说404找不到那是完全

00:32:16.320 --> 00:32:21.159
不同的问题

00:32:18.610 --> 00:32:24.960
我想你想让我做什么

00:32:21.159 --> 00:32:24.960
它希望我这样做，让我们尝试一下

00:32:25.890 --> 00:32:37.590
是的，所以那没用

00:32:31.620 --> 00:32:37.590
导入它已经存在

00:32:40.419 --> 00:32:55.580
值等于那个哦

00:32:45.919 --> 00:33:00.710
保留HTTP配置ha HTTP还是我

00:32:55.580 --> 00:33:02.419
甚至称它为保留，我写了

00:33:00.710 --> 00:33:05.020
我称之为测试的生产代码

00:33:02.419 --> 00:33:07.840
我已经对大脑朋友进行了测试哦

00:33:05.020 --> 00:33:13.600
太令人困惑了，所以我们开始

00:33:07.840 --> 00:33:17.419
配置名称很重要

00:33:13.600 --> 00:33:18.950
好吧，这就是我的想法

00:33:17.419 --> 00:33:20.899
要测试这段代码好吗

00:33:18.950 --> 00:33:32.899
所以这次让我们再试一次

00:33:20.899 --> 00:33:41.419
很少有人能感觉到我只是哦，不，不

00:33:32.899 --> 00:33:43.880
是配置，是的，好的

00:33:41.419 --> 00:33:46.179
惠普配置很好，这次可以

00:33:43.880 --> 00:33:49.279
更多的热情

00:33:46.179 --> 00:33:50.000
没有可运行的方法，您很困惑

00:33:49.279 --> 00:33:53.360
我知道了

00:33:50.000 --> 00:33:56.539
保留，应该测试我们怎么样

00:33:53.360 --> 00:33:57.830
做得很好，所以我们去了

00:33:56.539 --> 00:33:59.779
需要击败类型保留

00:33:57.830 --> 00:34:01.880
再次如此，因为它是一个网络

00:33:59.779 --> 00:34:03.890
切片，因为它使用的是Web Flex 

00:34:01.880 --> 00:34:05.390
在数据库层中切东西

00:34:03.890 --> 00:34:07.520
不存在不是不是没有

00:34:05.390 --> 00:34:09.530
创建，所以我需要注入我需要

00:34:07.520 --> 00:34:12.260
创建版本库的模拟版本

00:34:09.530 --> 00:34:14.480
这样我现在可以创建自己的

00:34:12.260 --> 00:34:16.190
实现，你知道那种

00:34:14.480 --> 00:34:17.030
东西，但这将是很多工作，所以

00:34:16.190 --> 00:34:19.369
我想做的是使用

00:34:17.030 --> 00:34:22.339
我现在要模拟对象

00:34:19.369 --> 00:34:24.139
我有春天，春天知道所有

00:34:22.339 --> 00:34:26.119
我想让Spring使用模拟对象

00:34:24.139 --> 00:34:30.169
反对并替换我想要的东西

00:34:26.119 --> 00:34:32.990
用那个模拟游戏，这样就可以了，我

00:34:30.169 --> 00:34:34.940
可以做模拟 bean 好吗模拟 bean 告诉

00:34:32.990 --> 00:34:36.710
春天在

00:34:34.940 --> 00:34:39.500
应用程序上下文（如果存在）以及

00:34:36.710 --> 00:34:40.879
创建一个模拟版本（如果有） 

00:34:39.500 --> 00:34:42.500
如果存在，请替换

00:34:40.879 --> 00:34:44.570
已经存在，如果存在，是否存在

00:34:42.500 --> 00:34:46.369
不存在，然后添加此模仿

00:34:44.570 --> 00:34:48.679
版本，因为它是牧田

00:34:46.369 --> 00:34:51.679
模拟记住，模拟只是一个对象

00:34:48.679 --> 00:34:53.960
有空，你知道默认值

00:34:51.679 --> 00:34:55.280
没有错误的0等

00:34:53.960 --> 00:34:58.099
但是我想要的不是嘲笑我

00:34:55.280 --> 00:35:00.109
想要是一个存根，一个存根是一个模拟

00:34:58.099 --> 00:35:01.880
一些预先设定的值

00:35:00.109 --> 00:35:06.559
预先设定的行为，所以我要说

00:35:01.880 --> 00:35:10.540
当这个点存储库到

00:35:06.559 --> 00:35:18.020
找到所有然后返回的磁通点只是新的

00:35:10.540 --> 00:35:21.230
对我说的话保留一位简

00:35:18.020 --> 00:35:26.150
好的，我已经预先设定好了

00:35:21.230 --> 00:35:28.700
结果还好，让我们看看是否可行

00:35:26.150 --> 00:35:30.890
看起来很好，所以现在很好

00:35:28.700 --> 00:35:32.750
想建立一个客户，我要回去

00:35:30.890 --> 00:35:33.800
实际上我会继续前进

00:35:32.750 --> 00:35:37.099
摆脱一些我不需要的东西

00:35:33.800 --> 00:35:40.280
 MongoDB不需要这个，我想要一个

00:35:37.099 --> 00:35:42.200
消费者，我希望验证者可以

00:35:40.280 --> 00:35:45.230
让我们燃烧或好吧，所以我打

00:35:42.200 --> 00:35:46.790
生成，我现在想做的是

00:35:45.230 --> 00:35:49.069
想要建立一个与之对话的消费者

00:35:46.790 --> 00:35:51.740
 API，所以我要做的就是

00:35:49.069 --> 00:35:57.160
打算在我的电脑上打开这个应用程序

00:35:51.740 --> 00:35:59.299
 IDE使用者，好的，我去看一下代码

00:35:57.160 --> 00:36:00.980
消费者方面，我将创建一个

00:35:59.299 --> 00:36:02.569
您基本了解客户的微服务

00:36:00.980 --> 00:36:05.119
人们想要使用的东西

00:36:02.569 --> 00:36:08.119
这可以用来和我的API通讯，所以我会

00:36:05.119 --> 00:36:09.559
说预订客户测试和

00:36:08.119 --> 00:36:12.470
量产到底测试代码

00:36:09.559 --> 00:36:14.480
它将以春季运行或

00:36:12.470 --> 00:36:18.680
上课，这将是一个 spring boot 测试， 

00:36:14.480 --> 00:36:21.349
我要去做的是

00:36:18.680 --> 00:36:23.119
打电话给我的微服务

00:36:21.349 --> 00:36:25.099
提供人们可以使用的客户

00:36:23.119 --> 00:36:28.280
拨打我正在使用的微服务

00:36:25.099 --> 00:36:29.630
会消耗微服务，所以在

00:36:28.280 --> 00:36:30.920
为了做到这一点，我将注入参考

00:36:29.630 --> 00:36:33.680
给我的预订客户

00:36:30.920 --> 00:36:34.069
我们还没有写一半，所以在这里

00:36:33.680 --> 00:36:36.650
我们是

00:36:34.069 --> 00:36:39.020
我将在其中添加客户端代码， 

00:36:36.650 --> 00:36:41.450
这将是

00:36:39.020 --> 00:36:43.730
当然会有终点

00:36:41.450 --> 00:36:45.290
知道这样，所以我们知道

00:36:43.730 --> 00:36:50.349
我们在这里要做什么，所以不要

00:36:45.290 --> 00:36:56.589
客户的想法得到所有保留和

00:36:50.349 --> 00:37:00.799
它将成为保留资源的发布者

00:36:56.589 --> 00:37:02.569
等于那个，显然我需要这个

00:37:00.799 --> 00:37:04.130
在类路径上输入内容，以便我创建

00:37:02.569 --> 00:37:07.810
这个班这个生产代码

00:37:04.130 --> 00:37:12.349
这是DTO，所以

00:37:07.810 --> 00:37:15.349
和ID，我想获取所有弧线处的数据

00:37:12.349 --> 00:37:17.780
我和norc的构造函数的构造函数

00:37:15.349 --> 00:37:19.520
希望这种方法可以，所以我们进入

00:37:17.780 --> 00:37:22.250
为了创建我将要使用的

00:37:19.520 --> 00:37:23.780
我要使用的反应式网络客户端

00:37:22.250 --> 00:37:25.880
注入我可以创建一个构造函数

00:37:23.780 --> 00:37:27.650
但是我喜欢龙目岛龙目岛

00:37:25.880 --> 00:37:29.720
容易，所以我可以通过一个通路注入

00:37:27.650 --> 00:37:35.109
为我写的构造函数

00:37:29.720 --> 00:37:37.460
我会说这个客户端得到点URI HTTP 

00:37:35.109 --> 00:37:40.160
本地主机8080正斜杠

00:37:37.460 --> 00:37:42.380
保留检索到该机构

00:37:40.160 --> 00:37:42.680
探索Ezzor vation doc类，我们

00:37:42.380 --> 00:37:46.579
走

00:37:42.680 --> 00:37:49.070
现在在我想要的测试代码中很简单

00:37:46.579 --> 00:37:51.140
证明我想断言有关

00:37:49.070 --> 00:37:54.230
数据到时我会说的数据

00:37:51.140 --> 00:37:56.210
返回我想说我看着

00:37:54.230 --> 00:37:58.190
我将在此处使用谓词的数据

00:37:56.210 --> 00:37:59.450
我将使用这个谓词，我们知道

00:37:58.190 --> 00:38:01.040
你可以想象自己写的是

00:37:59.450 --> 00:38:04.460
非常简单，我要说一个清单

00:38:01.040 --> 00:38:09.619
字符串名称等于数组点作为列表

00:38:04.460 --> 00:38:11.500
简和乔好吧，这是我的清单， 

00:38:09.619 --> 00:38:17.270
我要说数据何时输入

00:38:11.500 --> 00:38:20.930
保留名字我要说名字

00:38:17.270 --> 00:38:24.319
点包含此内容，因此应为以下内容之一

00:38:20.930 --> 00:38:26.540
那些有效的名字验证完全可以

00:38:24.319 --> 00:38:27.920
非常简单，我要去做

00:38:26.540 --> 00:38:30.200
这两次，因为有两个不同

00:38:27.920 --> 00:38:31.730
结果他们要回来的每个

00:38:30.200 --> 00:38:34.880
这将与这些名称之一匹配，因此

00:38:31.730 --> 00:38:36.349
现在让我们看看我是否运行此代码

00:38:34.880 --> 00:38:38.450
我做了我想做的一切

00:38:36.349 --> 00:38:40.430
我们会失败的，但我不会

00:38:38.450 --> 00:38:41.599
知道为什么为什么我有一个想法为什么但是我

00:38:40.430 --> 00:38:44.510
还是不知道为什么我让我们看看

00:38:41.599 --> 00:38:48.020
如果失败会发生

00:38:44.510 --> 00:38:49.760
第一次失败好预订客户端

00:38:48.020 --> 00:38:52.609
需要一类类型的网络客户公平

00:38:49.760 --> 00:38:55.460
够了，所以我要出厂一束

00:38:52.609 --> 00:38:57.770
响应式Web客户端可以访问Web 

00:38:55.460 --> 00:39:00.290
客户，我要注入网络

00:38:57.770 --> 00:39:01.609
客户构建者，因为春季将

00:39:00.290 --> 00:39:02.780
用我想要的任何东西进行配置

00:39:01.609 --> 00:39:04.490
配置安全性和

00:39:02.780 --> 00:39:06.050
客户端负载平衡等

00:39:04.490 --> 00:39:07.700
种东西，然后我只提供

00:39:06.050 --> 00:39:10.010
好的，我只是打电话给build并且得到

00:39:07.700 --> 00:39:11.510
最后的结果现在会怎样

00:39:10.010 --> 00:39:14.530
发生，让我们看看如果我们跑步

00:39:11.510 --> 00:39:14.530
这个测试再一次

00:39:15.220 --> 00:39:23.560
哦，哦，我们有问题吗

00:39:20.550 --> 00:39:25.359
 Jabba网络连接异常是

00:39:23.560 --> 00:39:28.359
试图致电该服务，但当然

00:39:25.359 --> 00:39:29.349
服务没有运行，这有点

00:39:28.359 --> 00:39:31.000
是不是有问题

00:39:29.349 --> 00:39:32.920
我们已经转向了我拥有的微服务

00:39:31.000 --> 00:39:34.630
生产者，消费者客户和服务

00:39:32.920 --> 00:39:37.840
现在一个正在呼叫另一个

00:39:34.630 --> 00:39:40.210
网络，我没有，我没有

00:39:37.840 --> 00:39:42.070
服务正在运行，我不知道我在

00:39:40.210 --> 00:39:43.300
在这里，我们在欧洲和欧洲

00:39:42.070 --> 00:39:45.700
事情和哪里有些不同

00:39:43.300 --> 00:39:47.470
我来自旧金山的II 

00:39:45.700 --> 00:39:50.650
美国湾区

00:39:47.470 --> 00:39:54.820
虽然在旧金山还可以

00:39:50.650 --> 00:39:56.410
一个非常友好的礼貌问候

00:39:54.820 --> 00:39:57.910
来和你一起工作的人

00:39:56.410 --> 00:39:59.859
组织中的组织

00:39:57.910 --> 00:40:02.140
新员工有礼貌的话

00:39:59.859 --> 00:40:03.760
向他们问好或欢迎或请

00:40:02.140 --> 00:40:05.740
你知道这里有位子加入我们吧

00:40:03.760 --> 00:40:08.740
知道这是一个非常欢迎的包容性

00:40:05.740 --> 00:40:12.160
很有礼貌

00:40:08.740 --> 00:40:13.420
庸俗的东西，非常非常庸俗，好一个

00:40:12.160 --> 00:40:15.070
你可以说的话

00:40:13.420 --> 00:40:17.680
人们有时候会做，这是我非常

00:40:15.070 --> 00:40:19.510
看到人们因为

00:40:17.680 --> 00:40:21.040
这只是很粗鲁的一件事

00:40:19.510 --> 00:40:25.420
人们有时会说你应该

00:40:21.040 --> 00:40:27.430
永远不要说对，欢迎来

00:40:25.420 --> 00:40:30.099
并部署此kubernetes集群，以便

00:40:27.430 --> 00:40:32.560
你可以测试任何东西，没什么是

00:40:30.099 --> 00:40:35.710
更侮辱或无礼我什么也没说

00:40:32.560 --> 00:40:37.210
不喜欢你，不必

00:40:35.710 --> 00:40:40.450
部署整个生产系统只是为了

00:40:37.210 --> 00:40:41.680
能够喜欢我不能懈怠吗

00:40:40.450 --> 00:40:44.710
认为我可以运行您的kubernetes集群

00:40:41.680 --> 00:40:47.410
不，不，不，不，不，所以那不是

00:40:44.710 --> 00:40:49.510
选择不是选择，而是我

00:40:47.410 --> 00:40:51.520
想要是某种可以嘲笑对方的方法

00:40:49.510 --> 00:40:54.460
服务我正在做的服务

00:40:51.520 --> 00:40:59.130
呼吁做某事的一种方法是

00:40:54.460 --> 00:41:02.140
使用电线模拟，所以我可以在测试中说

00:40:59.130 --> 00:41:07.349
自动配置的线马赫端口等于

00:41:02.140 --> 00:41:12.460
 8080，在这里我将说一下线模拟点

00:41:07.349 --> 00:41:16.530
电线模拟点存根

00:41:12.460 --> 00:41:21.040
这不是我们的API，我们没有构建

00:41:16.530 --> 00:41:24.040
点，我们将返回电线模拟一个

00:41:21.040 --> 00:41:27.220
响应点与身体，我们将创建

00:41:24.040 --> 00:41:29.260
一秒钟用HTTP标头

00:41:27.220 --> 00:41:32.720
标头

00:41:29.260 --> 00:41:37.089
点应用内容类型等于媒体类型

00:41:32.720 --> 00:41:39.859
状态为200的应用程序Jason值

00:41:37.089 --> 00:41:42.200
那就是然后我们需要身体

00:41:39.859 --> 00:41:44.119
所以我们将在那里提供尸体

00:41:42.200 --> 00:41:48.670
身体将是一个字符串，现在我要

00:41:44.119 --> 00:41:52.369
创建我要使用自动配置

00:41:48.670 --> 00:41:54.950
 JSON对，所以我自动配置JSON 

00:41:52.369 --> 00:41:57.680
将注入一个Jackson对象映射器

00:41:54.950 --> 00:41:59.420
它会更长一点，所以我们

00:41:57.680 --> 00:42:01.369
要在这里注入对象映射器

00:41:59.420 --> 00:42:05.240
我们将使用对象映射器

00:42:01.369 --> 00:42:09.339
创建我们的记录实例好吧， 

00:42:05.240 --> 00:42:14.740
为了做到这一点，我要传递

00:42:09.339 --> 00:42:22.430
这里有两笔新预订记录

00:42:14.740 --> 00:42:24.800
简（Jane）对乔（Joe）的新保留，好吧，我已经

00:42:22.430 --> 00:42:29.960
那里有一些JSON，而我要

00:42:24.800 --> 00:42:33.800
使用这样的JSON，您是否注意到

00:42:29.960 --> 00:42:35.780
我称之为JSON，因为JSON是

00:42:33.800 --> 00:42:37.550
有两个JSON，然后

00:42:35.780 --> 00:42:43.580
有杰森（Jason）杰森（Jason）是某人的名字

00:42:37.550 --> 00:42:46.490
对，这是一个非常有趣的约会

00:42:43.580 --> 00:42:48.910
亨妮弗，我觉得疯了

00:42:46.490 --> 00:42:51.440
 Python社区一个非常有趣的家伙

00:42:48.910 --> 00:42:58.480
任何人Doe所以我们要走了

00:42:51.440 --> 00:43:03.550
运行这个好吧

00:42:58.480 --> 00:43:05.260
和期望匹配保留哦我

00:43:03.550 --> 00:43:09.869
猜错是不是

00:43:05.260 --> 00:43:09.869
是啊

00:43:10.290 --> 00:43:20.950
一两个我们去

00:43:18.150 --> 00:43:27.359
如果我修复的话可能会更好

00:43:20.950 --> 00:43:30.359
所以这是一致的哇，好吧，现在

00:43:27.359 --> 00:43:30.359
一

00:43:31.750 --> 00:43:39.750
 -始终保持一致很好

00:43:37.290 --> 00:43:43.270
三，让我们再试一次

00:43:39.750 --> 00:43:45.070
所以看起来好像是绿色的正确的事情

00:43:43.270 --> 00:43:46.660
这里是绿色，事物是绿色的

00:43:45.070 --> 00:43:50.050
生产者方面一切都应该

00:43:46.660 --> 00:43:51.730
很好，但还有一点

00:43:50.050 --> 00:43:53.410
没有皱纹

00:43:51.730 --> 00:43:55.660
软膏不在那里，因为如果你

00:43:53.410 --> 00:43:58.330
看看这个，你看到我有这个领域

00:43:55.660 --> 00:43:59.740
叫保留名，但我没有

00:43:58.330 --> 00:44:03.930
生产者方的保留名称

00:43:59.740 --> 00:44:06.310
在服务器上，我只有名字和

00:44:03.930 --> 00:44:07.780
那是非常危险的情况

00:44:06.310 --> 00:44:10.270
我们有两个不同的团队在工作

00:44:07.780 --> 00:44:12.099
在不同的事情上，一方面是

00:44:10.270 --> 00:44:14.050
工作正常，一切都绿了

00:44:12.099 --> 00:44:16.900
另一边的一切

00:44:14.050 --> 00:44:18.160
也是绿色的，所以有终点

00:44:16.900 --> 00:44:20.260
看起来我们所有的一切

00:44:18.160 --> 00:44:21.780
很好，我们只是部署它

00:44:20.260 --> 00:44:24.640
没事的吧

00:44:21.780 --> 00:44:28.300
这不是PHP，我们不能仅仅发现

00:44:24.640 --> 00:44:30.880
我们需要的生产权中的东西

00:44:28.300 --> 00:44:32.200
做得更好，一件事，人们

00:44:30.880 --> 00:44:34.000
他们是创建集成测试吗

00:44:32.200 --> 00:44:35.380
那就是你知道你开始的地方

00:44:34.000 --> 00:44:36.400
部署公司集群和

00:44:35.380 --> 00:44:39.250
当然你不能在本地运行

00:44:36.400 --> 00:44:41.170
机器，因此您拥有共享服务器或

00:44:39.250 --> 00:44:42.880
您的服务或云集群

00:44:41.170 --> 00:44:44.200
组织用于集成

00:44:42.880 --> 00:44:46.540
测试，然后当然必须

00:44:44.200 --> 00:44:47.920
等待人们自由或完成

00:44:46.540 --> 00:44:49.240
用它，或者你可以吐自己的

00:44:47.920 --> 00:44:51.250
在这种情况下，您要为此付出疯狂的代价

00:44:49.240 --> 00:44:52.630
不，不，非常痛苦

00:44:51.250 --> 00:44:54.339
快速正确，尤其是如果每个人

00:44:52.630 --> 00:44:57.339
有一个整体的孤立副本

00:44:54.339 --> 00:44:59.530
多租户分布式云，所以我想要

00:44:57.339 --> 00:45:01.210
获得快速反馈，但我想避免

00:44:59.530 --> 00:45:03.670
花太多时间在

00:45:01.210 --> 00:45:05.440
集成测试层记得当你

00:45:03.670 --> 00:45:07.390
有一个测试金字塔80％应该

00:45:05.440 --> 00:45:08.980
反馈很快，却像单位

00:45:07.390 --> 00:45:10.690
测试和模拟测试，然后

00:45:08.980 --> 00:45:12.450
在顶部，你应该慢一点，但是

00:45:10.690 --> 00:45:15.130
更详尽，更全面

00:45:12.450 --> 00:45:16.450
集成测试，您知道最终

00:45:15.130 --> 00:45:18.520
最终测试之类的东西冒出来

00:45:16.450 --> 00:45:19.720
测试，所以我们需要快速反馈，我

00:45:18.520 --> 00:45:21.430
不想放弃那种有生产力的

00:45:19.720 --> 00:45:23.500
生产力，但我发现了

00:45:21.430 --> 00:45:26.020
这里的问题，如果这是一个整体

00:45:23.500 --> 00:45:27.910
我改变了整体的领域

00:45:26.020 --> 00:45:30.099
编译器会告诉我，但我没有

00:45:27.910 --> 00:45:31.480
网络API的编译器等

00:45:30.099 --> 00:45:34.089
我想要的是某种捕获方式

00:45:31.480 --> 00:45:36.520
然后在其中定义不兼容

00:45:34.089 --> 00:45:39.099
我的测试执行此操作的好方法是

00:45:36.520 --> 00:45:40.210
签订以消费者为导向的合同

00:45:39.099 --> 00:45:42.040
我要做的是回去

00:45:40.210 --> 00:45:45.220
给我的制片人，我将使用

00:45:42.040 --> 00:45:48.280
春季云合约描述如何

00:45:45.220 --> 00:45:54.339
该API应该与合同

00:45:48.280 --> 00:45:57.339
签订合同

00:45:54.339 --> 00:46:02.430
一个变成正确的测试，所以我

00:45:57.339 --> 00:46:04.990
要说应该退还所有保留

00:46:02.430 --> 00:46:06.640
时髦，这将是一件事情

00:46:04.990 --> 00:46:11.700
我有一个地图位置

00:46:06.640 --> 00:46:13.349
说合同点制造，我会说

00:46:11.700 --> 00:46:16.240
描述

00:46:13.349 --> 00:46:19.210
预订，所以我也在这里用傻瓜

00:46:16.240 --> 00:46:22.780
作为DSL，我正在描述数据应如何

00:46:19.210 --> 00:46:24.790
讨论应该基本上看起来如何

00:46:22.780 --> 00:46:27.780
与我的API的交互应该看起来

00:46:24.790 --> 00:46:31.329
我是说有人提出要求时

00:46:27.780 --> 00:46:34.450
到服务器到的生产者

00:46:31.329 --> 00:46:38.079
使用HTTP方法的此类保留get' 

00:46:34.450 --> 00:46:40.690
那么我希望状态为200， 

00:46:38.079 --> 00:46:42.730
期望包含的标头包括

00:46:40.690 --> 00:46:45.670
内容类型，我想要内容类型

00:46:42.730 --> 00:46:48.490
等于应用Jason值

00:46:45.670 --> 00:46:51.280
对的，我希望身体拥有

00:46:48.490 --> 00:46:53.470
跟随形状好，以便身体

00:46:51.280 --> 00:46:55.599
将成为JSON结构，我可以

00:46:53.470 --> 00:46:57.849
如果我想在这里使用一个字符串，但我

00:46:55.599 --> 00:47:00.490
有这个不错的对象字面量语法和

00:46:57.849 --> 00:47:02.819
看起来像JSON的高飞，所以我

00:47:00.490 --> 00:47:08.050
可以代替它，所以我们开始

00:47:02.819 --> 00:47:09.760
好吧，然后乔和瞧，好吧

00:47:08.050 --> 00:47:12.069
有我的合同，现在有

00:47:09.760 --> 00:47:14.220
合同仅在某些情况下有用

00:47:12.069 --> 00:47:16.869
强制它记住这将是

00:47:14.220 --> 00:47:19.720
编译成测试会

00:47:16.869 --> 00:47:21.910
转换成单元测试好了，所以我

00:47:19.720 --> 00:47:24.609
将使用插件来完成这项工作， 

00:47:21.910 --> 00:47:27.010
强制该测试每次执行

00:47:24.609 --> 00:47:32.260
一次建立生产台

00:47:27.010 --> 00:47:34.990
杂项深度合同春天云

00:47:32.260 --> 00:47:37.800
合同深度还可以

00:47:34.990 --> 00:47:40.450
我要去这里我的构建部分

00:47:37.800 --> 00:47:42.310
构建插件，我要添加Spring 

00:47:40.450 --> 00:47:44.380
代码合同Maven插件，我也是

00:47:42.310 --> 00:47:46.960
每次创建时告诉此插件

00:47:44.380 --> 00:47:48.849
我的合同中的一项测试扩展了

00:47:46.960 --> 00:47:51.599
从基类测试和原因

00:47:48.849 --> 00:47:53.770
我们需要这样做是因为哦

00:47:51.599 --> 00:47:55.270
抱歉，这不在生产者方面

00:47:53.770 --> 00:47:58.809
消费者我们想要做的原因

00:47:55.270 --> 00:48:01.959
那是因为我们想知道

00:47:58.809 --> 00:48:04.299
我们正在做的实际上是

00:48:01.959 --> 00:48:06.849
具有我们之前看到的设置逻辑

00:48:04.299 --> 00:48:08.909
我在这里有合同吗

00:48:06.849 --> 00:48:13.209
源代码测试喘息，我还没来

00:48:08.909 --> 00:48:15.369
在这里，我们把它放在这里

00:48:13.209 --> 00:48:17.709
测试资源合同，我们去了

00:48:15.369 --> 00:48:19.839
好吧，现在我要担任制片人

00:48:17.709 --> 00:48:22.119
在服务器端，我有这个

00:48:19.839 --> 00:48:25.059
合同，它将扩展该课程

00:48:22.119 --> 00:48:27.429
我配置的称为基类

00:48:25.059 --> 00:48:28.659
在这里的基础类的插件中，我需要

00:48:27.429 --> 00:48:32.499
在测试文件夹中创建它

00:48:28.659 --> 00:48:34.119
所以基类，这个基类是

00:48:32.499 --> 00:48:35.769
只是要成为我做的地方

00:48:34.119 --> 00:48:37.539
您看到的那种设置逻辑

00:48:35.769 --> 00:48:40.749
我以前做过，但它将可用

00:48:37.539 --> 00:48:43.209
对于这个生成的测试，所以它将

00:48:40.749 --> 00:48:46.419
参加春季跑步者班

00:48:43.209 --> 00:48:47.949
做一个 spring boot 测试，确定它会

00:48:46.419 --> 00:48:50.559
一些属性，包括服务器类型

00:48:47.949 --> 00:48:55.569
端口等于0，我要说一个网

00:48:50.559 --> 00:48:57.969
环境等于随机好吧，我们

00:48:55.569 --> 00:49:00.299
要说的是配置类

00:48:57.969 --> 00:49:02.169
使用保留HTTP 

00:49:00.299 --> 00:49:04.719
配置类以及其他

00:49:02.169 --> 00:49:08.739
对的或者实际上我们甚至不需要

00:49:04.719 --> 00:49:11.589
那样，那样就可以了， 

00:49:08.739 --> 00:49:14.109
然后我们将像以前一样做

00:49:11.589 --> 00:49:16.900
我们使用模拟 bean 来创建

00:49:14.109 --> 00:49:20.109
预订资料库，我们要去

00:49:16.900 --> 00:49:21.579
注入本地服务器端口并

00:49:20.109 --> 00:49:25.630
我们将进行一些基本设置，以便

00:49:21.579 --> 00:49:29.499
这是我的HTTP测试，与

00:49:25.630 --> 00:49:32.499
在把它放进去之前，我们要

00:49:29.499 --> 00:49:37.239
说放心，基本URI等于

00:49:32.499 --> 00:49:39.369
 HTTP本地主机加上此点端口，所以我

00:49:37.239 --> 00:49:41.109
现在配置所有基本逻辑所有代码

00:49:39.369 --> 00:49:42.219
延伸到我错过了什么

00:49:41.109 --> 00:49:49.179
确保我没有错过任何事情

00:49:42.219 --> 00:49:52.599
我们没有后悔哦，是的，谢谢

00:49:49.179 --> 00:49:55.209
谁好，我想念好东西

00:49:52.599 --> 00:49:57.489
我觉得这里很重要

00:49:55.209 --> 00:50:00.579
喜欢，所以只是百分之一百

00:49:57.489 --> 00:50:04.209
确定我会作弊

00:50:00.579 --> 00:50:06.309
上课你有进口，好吧，我没有

00:50:04.209 --> 00:50:08.439
需要足够的公平

00:50:06.309 --> 00:50:09.789
我曾经拥有过那个，我就像我

00:50:08.439 --> 00:50:11.740
不知道这是真的还是我需要

00:50:09.789 --> 00:50:13.849
那但你知道

00:50:11.740 --> 00:50:15.859
如果我在那之前做过

00:50:13.849 --> 00:50:18.770
原因好吧，现在让我们尝试吧

00:50:15.859 --> 00:50:20.660
给制作人下载制作人可以

00:50:18.770 --> 00:50:25.490
甚至在我之前干净安装

00:50:20.660 --> 00:50:40.160
那点m2仓库平静的例子可能

00:50:25.490 --> 00:50:43.990
即使干净安装也可以喝点咖啡

00:50:40.160 --> 00:50:43.990
找不到什么存根

00:50:45.040 --> 00:50:55.810
源测试资源合同还可以

00:51:05.530 --> 00:51:11.140
手指交叉的眼睛交叉的好东西

00:51:09.190 --> 00:51:12.670
好吧，我们可以看到它已编译

00:51:11.140 --> 00:51:14.500
一切都很好，你可以看到

00:51:12.670 --> 00:51:16.540
安装了罐子和Maven手掌

00:51:14.500 --> 00:51:18.280
该xml，最重要的是

00:51:16.540 --> 00:51:20.980
安装了这个叫做存根的东西， 

00:51:18.280 --> 00:51:22.930
存根包含一个文件， 

00:51:20.980 --> 00:51:26.250
消费者会消费，您可以看到

00:51:22.930 --> 00:51:28.720
它为我们创建了一个假测试，所以

00:51:26.250 --> 00:51:32.560
验证程序，我想让我这样看

00:51:28.720 --> 00:51:43.150
验证者测试点Java 

00:51:32.560 --> 00:51:44.500
好吧，找到CD目标，找到它了

00:51:43.150 --> 00:51:51.580
当制作人仍然正确时

00:51:44.500 --> 00:51:51.940
在生产者好的合同验证器中

00:51:51.580 --> 00:51:57.609
测试

00:51:51.940 --> 00:52:01.090
好吧，所以合同验证者好吧Yahveh 

00:51:57.609 --> 00:52:02.770
很好，如果我们在

00:52:01.090 --> 00:52:03.940
生产者方面，您可以看到

00:52:02.770 --> 00:52:06.010
实际上只是一个单元测试

00:52:03.940 --> 00:52:08.020
由我们为它创建的编译器

00:52:06.010 --> 00:52:09.640
与我们的规格相同

00:52:08.020 --> 00:52:12.160
合同说要200 

00:52:09.640 --> 00:52:13.750
应用程序Azon的ID等于

00:52:12.160 --> 00:52:15.730
一个名字等于简的名字

00:52:13.750 --> 00:52:17.470
叫乔，依此类推

00:52:15.730 --> 00:52:18.820
沟通现在在行家中

00:52:17.470 --> 00:52:20.440
可能是Nexus或

00:52:18.820 --> 00:52:23.290
人工制品或其他任何东西，但它在我的

00:52:20.440 --> 00:52:26.440
客户端上的本地m2存储库

00:52:23.290 --> 00:52:27.849
我可以摆脱这种困扰，我是

00:52:26.440 --> 00:52:29.530
会摆脱电线马赫，因为我

00:52:27.849 --> 00:52:31.690
不需要运气，因为就是这样

00:52:29.530 --> 00:52:34.150
我正在测试错误的东西

00:52:31.690 --> 00:52:36.040
要使用存根转轮，我在这里

00:52:34.150 --> 00:52:38.500
告诉存根赛跑者去行尸走肉

00:52:36.040 --> 00:52:40.990
找到生产者工件找到

00:52:38.500 --> 00:52:43.450
它的最新版本加上意味着最新

00:52:40.990 --> 00:52:46.599
版本并运行结果定义

00:52:43.450 --> 00:52:49.540
在8080端口上，我也想让你看看

00:52:46.599 --> 00:52:52.420
在本地类路径中而不在人工环境中

00:52:49.540 --> 00:52:54.609
不是在你的课堂上，而是在

00:52:52.420 --> 00:52:57.730
本地M2存储库，如果我们这样做

00:52:54.609 --> 00:52:59.980
一切都正确，如果合同

00:52:57.730 --> 00:53:02.290
与我们的客户端API具有相同的形状

00:52:59.980 --> 00:53:10.589
期望然后这应该工作，让我们看看

00:53:02.290 --> 00:53:10.589
如果它赶上了我们的错误，让我们看看

00:53:11.380 --> 00:53:17.450
有我们得到名字的数据

00:53:14.440 --> 00:53:19.519
期待下一场比赛说预订

00:53:17.450 --> 00:53:21.619
名称等于null，所以它失败了，我们

00:53:19.519 --> 00:53:24.380
知道为什么失败了，让我们去解决这个问题

00:53:21.619 --> 00:53:30.380
客户端应该说名称重建

00:53:24.380 --> 00:53:40.519
现在好了，我们必须修复该问题

00:53:30.380 --> 00:53:42.499
名字取名字，我们开始测试很酷

00:53:40.519 --> 00:53:43.880
好吧，我的朋友们，希望你

00:53:42.499 --> 00:53:46.190
对写什么意味着一种感觉

00:53:43.880 --> 00:53:47.690
可测试的代码可以快速获得

00:53:46.190 --> 00:53:49.609
移到我们可以使用的地方

00:53:47.690 --> 00:53:51.289
测试驱动的开发以隔离零件

00:53:49.609 --> 00:53:52.789
我们的系统包括分布式

00:53:51.289 --> 00:53:54.709
包括分布式服务的系统

00:53:52.789 --> 00:53:56.359
有关于春季云合约的会谈

00:53:54.709 --> 00:53:57.920
关于与Andy进行测试的讲座

00:53:56.359 --> 00:53:59.029
威尔金森（Wilkinson）有很多关于

00:53:57.920 --> 00:54:00.650
这些东西深入互动

00:53:59.029 --> 00:54:02.359
当然编程，所以去看看那些

00:54:00.650 --> 00:54:04.900
非常感谢您的光临我

00:54:02.359 --> 00:54:04.900
欣赏它

00:54:06.460 --> 00:54:12.780
 [音乐] 

