WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.970 --> 00:00:09.049
 [音乐] 

00:00:05.410 --> 00:00:11.449
大家好，我叫Mathura Vevey， 

00:00:09.049 --> 00:00:12.049
我是Spring Bootie Mat的开发人员

00:00:11.449 --> 00:00:14.119
贫民窟

00:00:12.049 --> 00:00:17.660
我希望你会谈愉快

00:00:14.119 --> 00:00:19.789
到目前为止，在今天的演讲中，我们要

00:00:17.660 --> 00:00:21.800
仔细看看

00:00:19.789 --> 00:00:24.380
 spring boot 真的发生了

00:00:21.800 --> 00:00:26.869
应用程序将运行

00:00:24.380 --> 00:00:29.599
很多次我们听到的场景

00:00:26.869 --> 00:00:31.970
就像 spring boot 有太多的魔力，我们

00:00:29.599 --> 00:00:34.539
知道开箱即用，但是我们

00:00:31.970 --> 00:00:36.770
真的不知道发生了什么

00:00:34.539 --> 00:00:38.870
开发人员，即使事情不起作用

00:00:36.770 --> 00:00:41.449
他们贴上一些注释并离开

00:00:38.870 --> 00:00:43.640
他们在那里，如果一切正常，然后新的

00:00:41.449 --> 00:00:45.590
开发人员加入他们没有的团队

00:00:43.640 --> 00:00:48.170
敢于触摸注释，因为

00:00:45.590 --> 00:00:50.390
他们太害怕打破东西，所以我

00:00:48.170 --> 00:00:51.500
只想告诉你没有

00:00:50.390 --> 00:00:55.039
诸如魔术之类的东西

00:00:51.500 --> 00:00:59.420
都是代码，大家都可以看一下

00:00:55.039 --> 00:01:02.510
调试它并使其有意义

00:00:59.420 --> 00:01:04.940
在开始演示之前，我

00:01:02.510 --> 00:01:06.560
想告诉你这有什么

00:01:04.940 --> 00:01:09.200
开始谈论我的经历

00:01:06.560 --> 00:01:11.690
你们大多数人实际上都很熟悉

00:01:09.200 --> 00:01:14.450
与 Spring 初学者或iOS，所以我只是

00:01:11.690 --> 00:01:19.250
将使用它来创建一个新的

00:01:14.450 --> 00:01:21.290
我正在使用IntelliJ的应用程序，但是你

00:01:19.250 --> 00:01:23.630
可以使用任何其他IDE，甚至可以转到

00:01:21.290 --> 00:01:27.820
启动Spring获得了IO 

00:01:23.630 --> 00:01:30.530
您的项目，我将其命名为

00:01:27.820 --> 00:01:35.360
他们多21岁，因为我还有20岁

00:01:30.530 --> 00:01:42.250
演示，我要选择网络

00:01:35.360 --> 00:01:42.250
这个简单的演示的入门和完成

00:01:42.640 --> 00:01:46.490
所以你们很多人都熟悉

00:01:45.110 --> 00:01:48.590
这种Spring 的结构很好

00:01:46.490 --> 00:01:53.140
应用我们有Spring 木

00:01:48.590 --> 00:01:56.060
入门网站，并有一个演示

00:01:53.140 --> 00:01:58.040
为之创建的应用程序类

00:01:56.060 --> 00:02:01.250
您从中生成项目时

00:01:58.040 --> 00:02:03.830
 Spring 或IO的开始，所以 Spring 好

00:02:01.250 --> 00:02:05.810
应用程序注释基本上是什么

00:02:03.830 --> 00:02:08.149
给你很多的好处

00:02:05.810 --> 00:02:10.609
当您运行

00:02:08.149 --> 00:02:13.299
 spring boot 应用程序，我只是

00:02:10.609 --> 00:02:13.299
要运行这个

00:02:16.489 --> 00:02:23.639
如预期的那样，它在Tomcat上通过

00:02:20.340 --> 00:02:25.260
默认在端口8080上，这意味着

00:02:23.639 --> 00:02:28.469
您的应用程序已启动并正在运行， 

00:02:25.260 --> 00:02:30.299
准备服务于网络请求

00:02:28.469 --> 00:02:32.519
有趣，因为我们实际上并没有

00:02:30.299 --> 00:02:35.219
必须做很多事情，我们正在跑步

00:02:32.519 --> 00:02:37.980
 Tomcat上的应用程序显然不是

00:02:35.219 --> 00:02:39.269
将发布任何有用的东西

00:02:37.980 --> 00:02:42.719
那一刻因为我们没有任何东西

00:02:39.269 --> 00:02:44.879
控制器或其他任何东西，但这是一个

00:02:42.719 --> 00:02:49.739
无需运行应用程序

00:02:44.879 --> 00:02:51.989
我觉得这太神奇了

00:02:49.739 --> 00:02:56.549
假设你不是很了解

00:02:51.989 --> 00:03:01.109
幕后发生了什么，所以

00:02:56.549 --> 00:03:03.510
想法是重建这个应用程序

00:03:01.109 --> 00:03:05.430
我们刚刚看到跑步，我们拥有了所有

00:03:03.510 --> 00:03:08.250
我们将要开始构建的技术

00:03:05.430 --> 00:03:10.889
从头开始的应用程序

00:03:08.250 --> 00:03:12.750
重建它，你会看到什么

00:03:10.889 --> 00:03:16.199
 Spring 实际上是 spring boot 

00:03:12.750 --> 00:03:18.209
在幕后为您做些什么

00:03:16.199 --> 00:03:22.500
使用Spring 时不需要做

00:03:18.209 --> 00:03:26.069
启动以使应用程序运行，以便

00:03:22.500 --> 00:03:27.689
我说从头开始

00:03:26.069 --> 00:03:30.329
从头开始，我还是会用一些

00:03:27.689 --> 00:03:31.859
 spring boot 的组件，因为我只

00:03:30.329 --> 00:03:34.340
有50分钟，所以我仍然要

00:03:31.859 --> 00:03:39.629
使用spring应用程序运行方法

00:03:34.340 --> 00:03:42.689
但我不会使用任何

00:03:39.629 --> 00:03:44.819
 Spring Boot应用程序注释或

00:03:42.689 --> 00:03:47.609
任何自动配置的东西

00:03:44.819 --> 00:03:49.500
你从 spring boot 开始

00:03:47.609 --> 00:03:50.989
然后我们将开始构建应用

00:03:49.500 --> 00:03:54.870
当我们开始构建应用程序时

00:03:50.989 --> 00:03:56.900
您会看到需要添加的内容，然后

00:03:54.870 --> 00:04:00.079
有点看思维过程是什么

00:03:56.900 --> 00:04:04.590
在一些 spring boot 后面

00:04:00.079 --> 00:04:07.139
注释和功能是字体

00:04:04.590 --> 00:04:13.109
好吧，我想我真的看不到你

00:04:07.139 --> 00:04:15.509
我认为这还可以，所以不是真的

00:04:13.109 --> 00:04:17.699
实时编码，我有很多提交

00:04:15.509 --> 00:04:20.459
排队，所以我们将检查每个

00:04:17.699 --> 00:04:22.919
提交并添加所需的东西

00:04:20.459 --> 00:04:24.730
添加它们，以便快速浏览一下

00:04:22.919 --> 00:04:26.830
 Palm D'Or XML 

00:04:24.730 --> 00:04:28.840
它类似于以前的应用程序

00:04:26.830 --> 00:04:32.830
从星星的手指产生的

00:04:28.840 --> 00:04:34.630
 Spring 将开始网络和

00:04:32.830 --> 00:04:36.580
应用程序类有点不同

00:04:34.630 --> 00:04:39.340
仍然使用spring应用程序，并且

00:04:36.580 --> 00:04:43.150
主要方法，但 Spring 不使用

00:04:39.340 --> 00:04:50.590
启动应用程序，所以现在如果我们运行此程序

00:04:43.150 --> 00:04:52.960
应用程序失败，失败是

00:04:50.590 --> 00:04:54.850
无法启动servlet网站

00:04:52.960 --> 00:04:57.760
服务器应用程序联系人由于

00:04:54.850 --> 00:05:02.230
缺少Servlet Web服务器工厂

00:04:57.760 --> 00:05:03.940
所以在我们实际进行修复之前

00:05:02.230 --> 00:05:06.070
这个失败我想给你

00:05:03.940 --> 00:05:10.030
关于什么的一点看法

00:05:06.070 --> 00:05:12.370
这意味着，为此，让我们采取

00:05:10.030 --> 00:05:14.830
快速查看之前的情况

00:05:12.370 --> 00:05:16.480
有一个嵌入式的servlet容器

00:05:14.830 --> 00:05:18.970
通常是 Spring 

00:05:16.480 --> 00:05:20.820
良好的应用程序及其含义

00:05:18.970 --> 00:05:24.040
现在有一个嵌入式servlet容器

00:05:20.820 --> 00:05:27.220
所以以前你曾经拥有这个网站

00:05:24.040 --> 00:05:30.160
容器或诸如Tomcat之类的

00:05:27.220 --> 00:05:32.740
将部署war文件和servlet 

00:05:30.160 --> 00:05:34.900
然后容器将寻找一个servlet 

00:05:32.740 --> 00:05:38.740
那场战争中的容器初始化器

00:05:34.900 --> 00:05:42.310
 Spring有自己的服务器容器

00:05:38.740 --> 00:05:46.120
初始化器实现

00:05:42.310 --> 00:05:49.300
寻找一个Web应用程序初始化程序

00:05:46.120 --> 00:05:52.690
和其中一个Web应用程序

00:05:49.300 --> 00:05:55.510
初始值设定项是注册一个

00:05:52.690 --> 00:05:59.320
带有servlet的调度程序servlet 

00:05:55.510 --> 00:06:01.570
容器，所以这东西过去

00:05:59.320 --> 00:06:03.190
注册调度程序servlet 

00:06:01.570 --> 00:06:06.550
然后可以访问Web应用程序

00:06:03.190 --> 00:06:09.250
上下文和所有bean，所以这用了

00:06:06.550 --> 00:06:13.240
当还是仍然如此时

00:06:09.250 --> 00:06:16.960
如果您部署战争文件以在

00:06:13.240 --> 00:06:18.460
嵌入式servlet容器现在在

00:06:16.960 --> 00:06:21.040
 spring boot 的当今世界

00:06:18.460 --> 00:06:24.070
您拥有嵌入式应用程序

00:06:21.040 --> 00:06:27.070
我一直认为服务器容器

00:06:24.070 --> 00:06:30.460
 Springwood 1.5这实际上曾经是

00:06:27.070 --> 00:06:32.590
称为嵌入式Web应用程序

00:06:30.460 --> 00:06:34.840
上下文，但是我们在 Spring 改变了它

00:06:32.590 --> 00:06:36.580
路由2成为servlet Web服务器

00:06:34.840 --> 00:06:37.400
应用程序上下文，因为有一个

00:06:36.580 --> 00:06:39.740
反应堆

00:06:37.400 --> 00:06:42.169
 Spring 添加的对应物

00:06:39.740 --> 00:06:44.870
 Muthu所以这个Servlet Web服务器

00:06:42.169 --> 00:06:47.030
应用程序上下文实际上是

00:06:44.870 --> 00:06:51.460
知道如何

00:06:47.030 --> 00:06:54.770
通过寻找服务器来引导自己

00:06:51.460 --> 00:06:57.470
 servlet Web服务器工厂bean 

00:06:54.770 --> 00:07:00.320
应用程序上下文本身和

00:06:57.470 --> 00:07:04.970
 servlet Web服务器工厂bean将

00:07:00.320 --> 00:07:07.460
然后使用一些

00:07:04.970 --> 00:07:09.169
 servlet上下文初始化程序

00:07:07.460 --> 00:07:11.600
在应用程序中可用

00:07:09.169 --> 00:07:14.030
上下文本身，因此Web服务器是

00:07:11.600 --> 00:07:17.840
像猫一样强壮的东西

00:07:14.030 --> 00:07:21.740
可以启动和停止的码头

00:07:17.840 --> 00:07:24.680
就像我在网络上提到的

00:07:21.740 --> 00:07:27.050
创建服务器时，它将获得一个插件

00:07:24.680 --> 00:07:29.000
 servlet上下文初始化程序

00:07:27.050 --> 00:07:31.699
存在于应用程序上下文中

00:07:29.000 --> 00:07:35.060
然后按原样应用到Web服务器

00:07:31.699 --> 00:07:39.949
启动，所以又有那些

00:07:35.060 --> 00:07:43.370
注册为 bean 好，所以现在我们

00:07:39.949 --> 00:07:44.720
对事实有一些看法

00:07:43.370 --> 00:07:47.660
因为这是一个Web应用程序

00:07:44.720 --> 00:07:50.570
此Servlet Web服务器应用程序

00:07:47.660 --> 00:07:53.000
上下文正在寻找这个servlet网站

00:07:50.570 --> 00:07:56.030
服务器工厂Bean自行引导

00:07:53.000 --> 00:08:01.190
并启动嵌入式servlet 

00:07:56.030 --> 00:08:03.580
容器，所以我们继续添加

00:08:01.190 --> 00:08:03.580
 bean 角，扁 bean 

00:08:08.690 --> 00:08:12.920
所以我只是为

00:08:10.850 --> 00:08:14.840
 Web服务器工厂的Tomcat，以便

00:08:12.920 --> 00:08:18.800
它匹配我们得到的默认值

00:08:14.840 --> 00:08:23.960
与我们从中看到的应用程序

00:08:18.800 --> 00:08:27.590
从I / O开始 Spring ，然后重新运行

00:08:23.960 --> 00:08:32.990
应用程序，因此它确实在Tomcat上启动

00:08:27.590 --> 00:08:34.550
端口8080现在是我们要的

00:08:32.990 --> 00:08:36.410
期望，因为我们的应用程序

00:08:34.550 --> 00:08:38.120
应用程序上下文能够找到

00:08:36.410 --> 00:08:43.510
这是创建Web服务器， 

00:08:38.120 --> 00:08:46.310
启动它，即使我们有

00:08:43.510 --> 00:08:47.960
像我一样有一个正在运行的服务器

00:08:46.310 --> 00:08:50.300
之前提到它不会做

00:08:47.960 --> 00:08:53.260
任何真正有用的东西都会

00:08:50.300 --> 00:08:55.460
给我们一个404，因为我们没有

00:08:53.260 --> 00:09:00.050
控制器映射来处理这些

00:08:55.460 --> 00:09:05.720
请求，所以我们将开始构建它

00:09:00.050 --> 00:09:08.060
我要一一检查

00:09:05.720 --> 00:09:10.970
提交，添加一个rec rest控制器

00:09:08.060 --> 00:09:12.440
这是一个非常简单的餐厅滚筒

00:09:10.970 --> 00:09:16.490
你们大多数人可能都很熟悉

00:09:12.440 --> 00:09:19.900
它只有一个请求映射到

00:09:16.490 --> 00:09:24.830
斜线并返回HelloWorld 

00:09:19.900 --> 00:09:26.450
所以如果我运行这个，你们中有多少人认为

00:09:24.830 --> 00:09:35.350
这实际上会工作并服务

00:09:26.450 --> 00:09:35.350
 HelloWorld一个人的东西河还好

00:09:35.860 --> 00:09:43.130
所以对不起，它也没有

00:09:41.150 --> 00:09:45.590
工作，因为我们仍然没有很多

00:09:43.130 --> 00:09:49.070
您需要获得的管道

00:09:45.590 --> 00:09:52.130
 MVC Spring MVC的东西只是工作

00:09:49.070 --> 00:09:53.720
添加一个 rest controller ，它在一个

00:09:52.130 --> 00:09:55.160
 Spring 很好的应用，因为 Spring 

00:09:53.720 --> 00:09:57.320
引导实际上在做很多

00:09:55.160 --> 00:09:58.940
为您服务，但现在因为我们

00:09:57.320 --> 00:10:03.710
从头开始构建，我们必须这样做

00:09:58.940 --> 00:10:07.250
自己，所以我的第一件事

00:10:03.710 --> 00:10:10.130
要做的就是在启用网站上添加

00:10:07.250 --> 00:10:13.250
 MVC在注释上，这将

00:10:10.130 --> 00:10:17.120
基本上导入所有Web MVC 

00:10:13.250 --> 00:10:20.730
您需要处理的配置

00:10:17.120 --> 00:10:30.510
这个要求

00:10:20.730 --> 00:10:35.250
让我们再次运行它，以便它仍然不会

00:10:30.510 --> 00:10:38.400
工作和最后一件事

00:10:35.250 --> 00:10:41.520
您需要做的是添加一个调度程序

00:10:38.400 --> 00:10:43.350
 servlet，所以调度程序servlet我们

00:10:41.520 --> 00:10:46.410
稍微看一下

00:10:43.350 --> 00:10:51.090
在幻灯片的后面是中心

00:10:46.410 --> 00:10:53.130
 HTTP请求的调度程序

00:10:51.090 --> 00:10:54.980
知道如何处理您的请求，并且

00:10:53.130 --> 00:11:00.230
然后将它们路由到正确的控制器

00:10:54.980 --> 00:11:00.230
所以一旦我们添加了调度员实心光束

00:11:04.310 --> 00:11:10.890
它确实起作用，并且给您打招呼

00:11:07.950 --> 00:11:13.370
世界，所以实际上

00:11:10.890 --> 00:11:15.930
我们要做的基础工作

00:11:13.370 --> 00:11:17.910
只是一个简单的 rest controller 工作

00:11:15.930 --> 00:11:21.090
但你真的不必考虑

00:11:17.910 --> 00:11:22.770
如果您正在使用添加 spring boot 

00:11:21.090 --> 00:11:24.930
应用程序注释

00:11:22.770 --> 00:11:26.850
自动为您完成，但这

00:11:24.930 --> 00:11:29.250
实际上是正在发生的事情

00:11:26.850 --> 00:11:35.550
当幕后应用

00:11:29.250 --> 00:11:39.000
作为一个网络应用程序启动，所以我们看起来

00:11:35.550 --> 00:11:42.920
一点点介绍如何在servlet Web上运行

00:11:39.000 --> 00:11:45.600
服务器应用程序上下文启动它

00:11:42.920 --> 00:11:48.960
应用Servlet上下文初始化器

00:11:45.600 --> 00:11:51.900
 bean 到Web服务器，它也

00:11:48.960 --> 00:11:54.540
注册现有的servlet和过滤器

00:11:51.900 --> 00:11:58.020
在应用程序中找到的bean 

00:11:54.540 --> 00:12:00.510
 Web服务器的上下文

00:11:58.020 --> 00:12:03.780
调度程序servlet基本上是一个

00:12:00.510 --> 00:12:05.700
 servlet实现和我一样

00:12:03.780 --> 00:12:09.030
提到这是中央调度员

00:12:05.700 --> 00:12:11.910
对于所有HTTP请求，它知道如何

00:12:09.030 --> 00:12:15.180
处理您的HTTP请求和路由

00:12:11.910 --> 00:12:17.700
它基于正确的处理程序

00:12:15.180 --> 00:12:19.890
处理程序映射，所以当你有

00:12:17.700 --> 00:12:22.260
类似映射foo的请求之类的东西

00:12:19.890 --> 00:12:24.150
或将条形图映射到您的请求

00:12:22.260 --> 00:12:28.080
控制器或您的一个控制器上

00:12:24.150 --> 00:12:30.320
方法，您会收到一个请求， 

00:12:28.080 --> 00:12:32.870
通过浏览器请求

00:12:30.320 --> 00:12:34.519
任何其他客户都会经历

00:12:32.870 --> 00:12:36.350
调度程序servlet和调度程序

00:12:34.519 --> 00:12:39.320
 servlet，因为它知道所有

00:12:36.350 --> 00:12:44.930
它知道正确的控制器的映射

00:12:39.320 --> 00:12:46.940
将其路由到正确的位置，所以我们有一个

00:12:44.930 --> 00:12:50.120
运行Web应用程序，这很棒

00:12:46.940 --> 00:12:52.009
接下来我们要做的是

00:12:50.120 --> 00:12:55.370
我们在这一切

00:12:52.009 --> 00:12:57.290
应用程序类在这里，而不是

00:12:55.370 --> 00:12:59.509
将压力控制器置于

00:12:57.290 --> 00:13:01.850
应用程序类本身，我们应该尝试

00:12:59.509 --> 00:13:03.829
并将其移出应用程序类

00:13:01.850 --> 00:13:05.480
因为当您想添加更多

00:13:03.829 --> 00:13:07.639
请求映射和更多功能

00:13:05.480 --> 00:13:12.139
到您不想要的控制器

00:13:07.639 --> 00:13:15.319
都在应用程序类中

00:13:12.139 --> 00:13:17.990
我要提取控制器

00:13:15.319 --> 00:13:20.899
进入自己的班级，基本上

00:13:17.990 --> 00:13:23.449
坐在一个单独的地方也一样

00:13:20.899 --> 00:13:30.319
类，但是如果我运行此应用程序

00:13:23.449 --> 00:13:33.790
再次，你会认为它会工作，但我

00:13:30.319 --> 00:13:37.430
回到我的404，那是因为

00:13:33.790 --> 00:13:39.769
因为我已经将其移出字符串

00:13:37.430 --> 00:13:41.870
真的知道它需要注册

00:13:39.769 --> 00:13:44.029
该控制器作为bean，因为我

00:13:41.870 --> 00:13:49.089
没有组件扫描

00:13:44.029 --> 00:13:53.839
注释，让我们继续添加

00:13:49.089 --> 00:13:56.569
组件扫描以及添加的内容

00:13:53.839 --> 00:14:00.110
组件扫描将默认情况下执行

00:13:56.569 --> 00:14:02.720
将从中扫描所有软件包

00:14:00.110 --> 00:14:05.889
该类的包装

00:14:02.720 --> 00:14:08.120
之所以声明注解，是因为

00:14:05.889 --> 00:14:10.370
该应用程序在示例中

00:14:08.120 --> 00:14:12.829
包和hello控制器在其中

00:14:10.370 --> 00:14:14.959
应该可以找到的相同包装

00:14:12.829 --> 00:14:17.899
该控制器使用组件扫描

00:14:14.959 --> 00:14:20.649
我们应该回到我们的工作网

00:14:17.899 --> 00:14:20.649
应用

00:14:24.870 --> 00:14:32.800
是的，我们又回到了世界

00:14:30.880 --> 00:14:34.720
这就像当您添加添加

00:14:32.800 --> 00:14:36.460
组件以及添加时

00:14:34.720 --> 00:14:38.500
 Spring Boot应用程序注释您

00:14:36.460 --> 00:14:40.360
不一定需要考虑一下

00:14:38.500 --> 00:14:43.270
因为这又是其中的一部分

00:14:40.360 --> 00:14:45.160
注解，因此您不一定

00:14:43.270 --> 00:14:47.710
自己添加了

00:14:45.160 --> 00:14:49.180
在您的应用程序上，但这是一个

00:14:47.710 --> 00:14:57.970
后面发生的事情

00:14:49.180 --> 00:15:00.190
默认情况下，场景还可以

00:14:57.970 --> 00:15:02.110
接下来我们要做的是

00:15:00.190 --> 00:15:05.050
也宣布这些 Bean type 在

00:15:02.110 --> 00:15:07.120
应用程序类，让我们尝试

00:15:05.050 --> 00:15:10.810
将它们提取到自己的

00:15:07.120 --> 00:15:17.860
配置类，以便更多

00:15:10.810 --> 00:15:21.130
如此结构化，而不是具有

00:15:17.860 --> 00:15:22.870
所有这些配置 bean 

00:15:21.130 --> 00:15:25.630
应用程序类已将它们移入

00:15:22.870 --> 00:15:29.290
这个配置包也许这个配置

00:15:25.630 --> 00:15:30.970
包可以稍后共享，因为这

00:15:29.290 --> 00:15:34.290
确实看起来很普通

00:15:30.970 --> 00:15:37.860
大多数Web应用程序的配置

00:15:34.290 --> 00:15:41.050
声明一个调度程序servlet 

00:15:37.860 --> 00:15:44.740
启用Web MVC并具有servlet 

00:15:41.050 --> 00:15:46.900
网络服务器工厂就像我一样

00:15:44.740 --> 00:15:50.350
在组件扫描之前提到

00:15:46.900 --> 00:15:52.330
仅可从

00:15:50.350 --> 00:15:54.400
注释所在的类

00:15:52.330 --> 00:15:58.060
宣布进入，因为我们已经搬家了

00:15:54.400 --> 00:16:01.480
我们的配置类不同

00:15:58.060 --> 00:16:06.040
包我希望我们的应用程序

00:16:01.480 --> 00:16:08.410
将回到错误，因为就是这样

00:16:06.040 --> 00:16:11.980
找不到Servlet Web服务器工厂

00:16:08.410 --> 00:16:14.050
再次使用Bean，因此Servlet Web服务器

00:16:11.980 --> 00:16:16.270
工厂bean在这里声明

00:16:14.050 --> 00:16:18.550
不同的配置

00:16:16.270 --> 00:16:21.870
从一个正在包装

00:16:18.550 --> 00:16:24.490
扫描，所以我们需要明确地告诉

00:16:21.870 --> 00:16:26.590
我们要导入这些的字符串

00:16:24.490 --> 00:16:28.810
配置类，因为它们是

00:16:26.590 --> 00:16:35.460
默认情况下不进行扫描

00:16:28.810 --> 00:16:35.460
那一刻，让我快点做

00:16:38.019 --> 00:16:43.069
因此，因为我们已将其移至

00:16:41.180 --> 00:16:45.350
我刚刚添加了一个不同的软件包

00:16:43.069 --> 00:16:48.829
明确的导入声明

00:16:45.350 --> 00:16:51.529
告诉它注册的应用程序类

00:16:48.829 --> 00:16:55.420
此配置中的bean 

00:16:51.529 --> 00:16:59.060
这些配置类中的类

00:16:55.420 --> 00:17:07.520
那应该带我们回到我们的

00:16:59.060 --> 00:17:09.169
运行应用程序，所以如果我运行它

00:17:07.520 --> 00:17:12.970
没有失败的错误

00:17:09.169 --> 00:17:15.740
缺少工厂bean和Web服务器

00:17:12.970 --> 00:17:20.360
这也给我们打招呼

00:17:15.740 --> 00:17:22.250
这是我们期望的一点

00:17:20.360 --> 00:17:24.470
关于组件可以

00:17:22.250 --> 00:17:27.500
注释基本上是一种告诉

00:17:24.470 --> 00:17:30.010
 Spring 在哪里寻找您的组件

00:17:27.500 --> 00:17:33.530
所以像您的控制器或

00:17:30.010 --> 00:17:37.280
您的配置类将那些

00:17:33.530 --> 00:17:39.679
自动扫描，默认为

00:17:37.280 --> 00:17:41.809
该类的包装

00:17:39.679 --> 00:17:44.270
注释可以声明

00:17:41.809 --> 00:17:46.909
显然使用

00:17:44.270 --> 00:17:49.970
基本包或基本包类

00:17:46.909 --> 00:17:53.510
属性，但如果您有东西

00:17:49.970 --> 00:17:55.490
看起来像这样，所以您的应用程序

00:17:53.510 --> 00:17:58.370
以这种方式结构化

00:17:55.490 --> 00:18:01.669
演示包，然后是核心域

00:17:58.370 --> 00:18:05.059
和配置让我们在演示下说，然后

00:18:01.669 --> 00:18:07.730
假设您的应用程序类在

00:18:05.059 --> 00:18:09.980
演示包和应用程序具有

00:18:07.730 --> 00:18:12.650
添加组件扫描注释，以便

00:18:09.980 --> 00:18:15.740
该演示包下的所有内容

00:18:12.650 --> 00:18:19.090
默认情况下会被扫描，但假设您

00:18:15.740 --> 00:18:23.270
将您的配置包移到外面

00:18:19.090 --> 00:18:26.450
演示的内容

00:18:23.270 --> 00:18:28.460
那个下的东西

00:18:26.450 --> 00:18:30.380
配置包将不会被扫描

00:18:28.460 --> 00:18:34.299
不再是我们所看到的

00:18:30.380 --> 00:18:34.299
这就是为什么我们必须手动导入

00:18:38.400 --> 00:18:46.680
好吧，我们已经运行了很多

00:18:41.760 --> 00:18:49.320
现在申请，其中之一

00:18:46.680 --> 00:18:52.740
您注意到这里是此应用程序

00:18:49.320 --> 00:18:54.750
该类现在有很多注释

00:18:52.740 --> 00:18:58.200
看起来不干净

00:18:54.750 --> 00:19:00.300
这些注释也都看起来

00:18:58.200 --> 00:19:03.270
就像其他人可以分享

00:19:00.300 --> 00:19:05.340
应用程序其他Web应用程序

00:19:03.270 --> 00:19:08.100
因为这似乎很普遍

00:19:05.340 --> 00:19:11.310
 Web应用程序要做的模式

00:19:08.100 --> 00:19:14.160
我们所做的一切，所以我们

00:19:11.310 --> 00:19:18.090
我们要做的是创建一个元

00:19:14.160 --> 00:19:20.700
注释，元注释是

00:19:18.090 --> 00:19:22.830
只不过是注释

00:19:20.700 --> 00:19:28.110
由这三个组成

00:19:22.830 --> 00:19:30.870
注释，所以我称之为魔术

00:19:28.110 --> 00:19:33.360
应用程序，正如你所知道的

00:19:30.870 --> 00:19:36.600
非常类似于添加 spring boot 

00:19:33.360 --> 00:19:39.120
带有注释的应用程序

00:19:36.600 --> 00:19:41.670
我们拥有的三个注释

00:19:39.120 --> 00:19:43.890
以前应用程序上的所有内容

00:19:41.670 --> 00:19:47.040
信任，所以我只是将他们移至

00:19:43.890 --> 00:19:49.770
这个魔术应用程序注释和

00:19:47.040 --> 00:19:58.820
事情应该照原样工作，但

00:19:49.770 --> 00:20:02.930
无论如何，我都会运行它，以便应用程序启动并

00:19:58.820 --> 00:20:02.930
我们仍然看到你好世界

00:20:07.320 --> 00:20:13.560
所以我想谈的下一件事

00:20:10.740 --> 00:20:15.660
大约是元注释

00:20:13.560 --> 00:20:17.370
这不是 Spring 吗

00:20:15.660 --> 00:20:20.010
好东西，但我们使用它相当多

00:20:17.370 --> 00:20:22.730
在 spring boot 内和Spring 内

00:20:20.010 --> 00:20:24.780
框架本身，所以如果您要调试

00:20:22.730 --> 00:20:26.790
你的事情出了问题

00:20:24.780 --> 00:20:30.180
应用程序，您会发现有一个

00:20:26.790 --> 00:20:32.910
在您的应用程序中添加注释

00:20:30.180 --> 00:20:34.590
可能想进一步挖掘并查看

00:20:32.910 --> 00:20:37.710
还有什么其他注释

00:20:34.590 --> 00:20:40.590
注释拉入，以便您可以看到

00:20:37.710 --> 00:20:43.440
发生了什么事，所以我认为大多数 Spring 

00:20:40.590 --> 00:20:45.750
应用程序可以用作元

00:20:43.440 --> 00:20:48.540
您也可以在其中使用注释

00:20:45.750 --> 00:20:52.830
如果您想编写自己的代码

00:20:48.540 --> 00:20:56.190
批注合并为一个批注Spring 

00:20:52.830 --> 00:20:58.050
框架大量使用它们，所以一个

00:20:56.190 --> 00:20:59.340
例子是服装控制器

00:20:58.050 --> 00:21:01.470
我们刚刚使用的

00:20:59.340 --> 00:21:03.480
还有可能会映射的

00:21:01.470 --> 00:21:06.660
熟悉所以获取映射是

00:21:03.480 --> 00:21:09.450
实际上带有添加请求的元注释

00:21:06.660 --> 00:21:11.730
映射，但是它有一种获取方法

00:21:09.450 --> 00:21:15.830
这是我想表达的一种便捷方式

00:21:11.730 --> 00:21:19.230
使用get方法请求映射

00:21:15.830 --> 00:21:23.040
还有一些高级配置

00:21:19.230 --> 00:21:26.870
通过元注释获得的

00:21:23.040 --> 00:21:29.670
 compose注释想要

00:21:26.870 --> 00:21:31.890
暴露来自

00:21:29.670 --> 00:21:35.940
基础注释可以使用

00:21:31.890 --> 00:21:38.670
属性上注释的别名

00:21:35.940 --> 00:21:42.810
然后将其映射到该属性

00:21:38.670 --> 00:21:44.640
在基础注释中

00:21:42.810 --> 00:21:47.130
这个例子我们有 spring boot 

00:21:44.640 --> 00:21:50.070
应用注释是元

00:21:47.130 --> 00:21:53.370
假设在启用自动

00:21:50.070 --> 00:21:56.490
配置，组件可以这样做

00:21:53.370 --> 00:21:58.920
 exclude属性是的别名

00:21:56.490 --> 00:22:01.260
启用自动配置排除和

00:21:58.920 --> 00:22:04.920
在Spring Boot上扫描基本软件包

00:22:01.260 --> 00:22:08.990
应用程序是组件的别名

00:22:04.920 --> 00:22:08.990
并扫描基本软件包

00:22:13.460 --> 00:22:21.060
好吧，所以我认为如果你看这个

00:22:18.840 --> 00:22:25.590
配置包现在开始看起来

00:22:21.060 --> 00:22:27.020
很像 spring boot 给你的

00:22:25.590 --> 00:22:29.910
你有你的魔术应用程序

00:22:27.020 --> 00:22:32.220
可以映射到Spring 的注释

00:22:29.910 --> 00:22:34.230
启动应用程序注释，然后您

00:22:32.220 --> 00:22:36.630
有这些配置类

00:22:34.230 --> 00:22:38.940
也许您可以将地图映射到自动

00:22:36.630 --> 00:22:42.630
您获得的配置类

00:22:38.940 --> 00:22:46.730
 spring boot ，但那是一件事

00:22:42.630 --> 00:22:50.100
您会看到这里仍然是

00:22:46.730 --> 00:22:51.450
在这里进行硬编码，因此仍然有Tomcat 

00:22:50.100 --> 00:22:54.540
太阳能配置调度程序

00:22:51.450 --> 00:22:58.010
配置我的MVC配置

00:22:54.540 --> 00:23:00.810
在导入批注中进行了硬编码，因此

00:22:58.010 --> 00:23:03.620
我实际上要做什么

00:23:00.810 --> 00:23:06.500
删除硬编码让我告诉你

00:23:03.620 --> 00:23:09.480
与自动配置有关的内容

00:23:06.500 --> 00:23:12.870
所以代替这个导入注释

00:23:09.480 --> 00:23:16.200
这是我做的关于魔术的事情

00:23:12.870 --> 00:23:18.420
我遇到的带有此注释的应用程序

00:23:16.200 --> 00:23:22.080
新注释启用魔术自动

00:23:18.420 --> 00:23:25.140
配置，基本上

00:23:22.080 --> 00:23:27.060
 Tomcat配置的导入和

00:23:25.140 --> 00:23:30.990
我们拥有的所有其他配置

00:23:27.060 --> 00:23:33.630
我在这里做这个的原因是

00:23:30.990 --> 00:23:37.980
因为如果你想使用

00:23:33.630 --> 00:23:39.900
组件扫描但不使用我的意思是如果

00:23:37.980 --> 00:23:42.380
您要使用自动配置

00:23:39.900 --> 00:23:44.880
位，但不使用组件扫描

00:23:42.380 --> 00:23:47.190
在启用魔术自动之前

00:23:44.880 --> 00:23:50.490
配置注释的唯一方法

00:23:47.190 --> 00:23:53.910
要做那就是要知道

00:23:50.490 --> 00:23:56.940
通过它导入的所有内容

00:23:53.910 --> 00:23:59.970
否则，此导入注释正确

00:23:56.940 --> 00:24:02.790
你被限制使用魔法

00:23:59.970 --> 00:24:04.470
应用程序注释将带来

00:24:02.790 --> 00:24:06.360
在包括组件在内的所有事物中

00:24:04.470 --> 00:24:09.990
扫描，这为您提供了一种不错的方法

00:24:06.360 --> 00:24:12.570
将组件扫描与自动分开

00:24:09.990 --> 00:24:17.010
配置，这就是为什么有

00:24:12.570 --> 00:24:19.230
像我这样的单独注释

00:24:17.010 --> 00:24:21.840
之前仍然提到过

00:24:19.230 --> 00:24:23.910
这里无法添加任何形式的

00:24:21.840 --> 00:24:24.659
此导入语句中的逻辑，所以我

00:24:23.910 --> 00:24:27.419
无能为力

00:24:24.659 --> 00:24:30.090
如果Tomcat存在于

00:24:27.419 --> 00:24:32.580
然后将classpath导入此Tomcat 

00:24:30.090 --> 00:24:34.830
配置和类似的东西

00:24:32.580 --> 00:24:37.289
导入批注实际上很漂亮

00:24:34.830 --> 00:24:41.129
方便，因为它不仅可以让您

00:24:37.289 --> 00:24:44.009
导入配置类，但也可以

00:24:41.129 --> 00:24:47.580
给你一种导入东西的方法

00:24:44.009 --> 00:24:50.399
叫做导入选择器

00:24:47.580 --> 00:24:52.619
有一个进口，需要所有

00:24:50.399 --> 00:24:55.229
配置类，我们可以有这个

00:24:52.619 --> 00:24:57.330
导入选择器，基本上

00:24:55.229 --> 00:24:58.919
你一个字符串数组，然后在这里

00:24:57.330 --> 00:25:01.200
您可以添加任何逻辑

00:24:58.919 --> 00:25:04.769
有条件的，如果你想

00:25:01.200 --> 00:25:08.340
选择导入我显示的原因

00:25:04.769 --> 00:25:10.529
你这是我想告诉你如何

00:25:08.340 --> 00:25:12.739
这种思想过程落后了

00:25:10.529 --> 00:25:13.979
一些 spring boot 

00:25:12.739 --> 00:25:17.129
自动配置

00:25:13.979 --> 00:25:23.609
可用的功能，所以这是

00:25:17.129 --> 00:25:28.320
只是通向那条路，即使

00:25:23.609 --> 00:25:30.389
你可以在这里添加逻辑

00:25:28.320 --> 00:25:32.549
这个导入选择器没有办法

00:25:30.389 --> 00:25:35.340
其他人贡献自己的力量

00:25:32.549 --> 00:25:37.940
此注释的配置类

00:25:35.340 --> 00:25:41.249
所以如果你曾经写过自己的

00:25:37.940 --> 00:25:43.649
您可能使用的自动配置

00:25:41.249 --> 00:25:45.840
Spring 点工厂文件按顺序

00:25:43.649 --> 00:25:48.419
贡献您的自动配置

00:25:45.840 --> 00:25:51.989
 Spring 使用的良好应用

00:25:48.419 --> 00:25:54.169
所以让我们来看看

00:25:51.989 --> 00:25:54.169
作品

00:25:58.640 --> 00:26:02.880
所以导入选择现在是

00:26:01.050 --> 00:26:06.090
返回的硬编码列表

00:26:02.880 --> 00:26:09.360
它正在使用的配置类

00:26:06.090 --> 00:26:12.210
 Spring 工厂装载机寻找

00:26:09.360 --> 00:26:15.300
它需要的配置类

00:26:12.210 --> 00:26:17.520
再次与导入方式非常相似

00:26:15.300 --> 00:26:20.130
 spring boot 是所有汽车的

00:26:17.520 --> 00:26:22.470
配置类，我们在下面列出它们

00:26:20.130 --> 00:26:25.080
Spring 载荷中的Spring 载荷系数

00:26:22.470 --> 00:26:28.770
给定键名的工厂和

00:26:25.080 --> 00:26:30.900
这就是它们的装载方式，所以如果我们看

00:26:28.770 --> 00:26:34.250
在 Spring 的工厂里

00:26:30.900 --> 00:26:36.060
 meta ins您可以看到这三个

00:26:34.250 --> 00:26:38.730
正在配置的类

00:26:36.060 --> 00:26:42.090
导入被硬编码的我

00:26:38.730 --> 00:26:45.360
现在已经转移到此启用魔术

00:26:42.090 --> 00:26:47.300
自动配置键和导入

00:26:45.360 --> 00:26:56.760
选择器然后寻找

00:26:47.300 --> 00:26:59.130
钥匙下的任何东西都可以，所以我们

00:26:56.760 --> 00:27:01.230
有点关于Impa的样子

00:26:59.130 --> 00:27:03.060
一点点进口就可以进口

00:27:01.230 --> 00:27:05.430
直接常规配置类

00:27:03.060 --> 00:27:08.670
如果那是你现在想要做的

00:27:05.430 --> 00:27:11.430
可能大多数用例

00:27:08.670 --> 00:27:13.560
您正在编写应用程序，但更多

00:27:11.430 --> 00:27:16.170
您可能要使用的高级用例

00:27:13.560 --> 00:27:18.900
导入选择器，甚至更多

00:27:16.170 --> 00:27:21.480
如果您想处理高级用例

00:27:18.900 --> 00:27:25.080
您可以直接使用Bean定义

00:27:21.480 --> 00:27:27.900
还要导入和导入bean定义

00:27:25.080 --> 00:27:32.880
注册并直接注册bean 

00:27:27.900 --> 00:27:35.400
通过该定义和跳板

00:27:32.880 --> 00:27:37.350
事实上，字符串点工厂基本上是

00:27:35.400 --> 00:27:39.500
一种非常简单的发现方式

00:27:37.350 --> 00:27:44.730
实现，所以有点像

00:27:39.500 --> 00:27:47.490
 Java服务加载器，基本上是

00:27:44.730 --> 00:27:50.220
非常简单的属性文件，始终

00:27:47.490 --> 00:27:53.460
生活在 Spring 点工厂的meta下

00:27:50.220 --> 00:27:57.690
所以所有的自动配置

00:27:53.460 --> 00:28:00.960
现在在 Spring 腐烂工厂和你

00:27:57.690 --> 00:28:02.730
可以把它放在启用我的钥匙下

00:28:00.960 --> 00:28:05.220
自动配置的意思是

00:28:02.730 --> 00:28:06.630
在启用自动配置下

00:28:05.220 --> 00:28:10.250
将是所有需要的清单

00:28:06.630 --> 00:28:10.250
要配置

00:28:13.679 --> 00:28:16.679
大

00:28:18.540 --> 00:28:27.050
好，所以非常重要的事情之一

00:28:24.300 --> 00:28:31.230
关于 spring boot 的自动配置是

00:28:27.050 --> 00:28:33.390
有条件的和很多次我们听到

00:28:31.230 --> 00:28:35.040
诸如如何启动Spring 之类的事情知道什么

00:28:33.390 --> 00:28:37.560
自动配置或如何弹跳

00:28:35.040 --> 00:28:39.900
开机知道它需要启动

00:28:37.560 --> 00:28:43.230
 Tomcat，如果Tomcat不在上面怎么办

00:28:39.900 --> 00:28:45.420
课堂路径之类的东西，所以我们

00:28:43.230 --> 00:28:50.220
来看一个例子

00:28:45.420 --> 00:28:51.990
这通过添加此拖曳在这里工作

00:28:50.220 --> 00:28:56.040
配置，因此此配置

00:28:51.990 --> 00:28:58.560
基本上添加了一个Undertow Servlet Web 

00:28:56.040 --> 00:29:03.920
服务器工厂bean我们仍然有我们的

00:28:58.560 --> 00:29:07.680
 Tomcat的servlet的Web服务器工厂 bean 所以

00:29:03.920 --> 00:29:12.450
现在我们有两个Web服务器来服务它

00:29:07.680 --> 00:29:20.040
工作我们的工厂 bean ，如果我们运行

00:29:12.450 --> 00:29:22.020
此应用程序失败，并且失败

00:29:20.040 --> 00:29:24.360
因为不是因为找不到

00:29:22.020 --> 00:29:26.700
 servlet Web服务器工厂bean，但它

00:29:24.360 --> 00:29:30.510
失败，因为它发现了多个servlet 

00:29:26.700 --> 00:29:33.420
 Web服务器工厂bean，所以我们需要

00:29:30.510 --> 00:29:37.440
告诉我们的应用程序仅配置

00:29:33.420 --> 00:29:42.840
其中一种基于某些条件， 

00:29:37.440 --> 00:29:45.750
您可以使用的方法是

00:29:42.840 --> 00:29:48.120
字符串的条件接口

00:29:45.750 --> 00:29:52.080
框架，所以我们添加了一个条件

00:29:48.120 --> 00:29:54.690
基本上是说

00:29:52.080 --> 00:29:59.400
如果在课堂上出现了undertow 

00:29:54.690 --> 00:30:01.350
然后添加此配置，因此我们已经

00:29:59.400 --> 00:30:03.090
编写了这个自定义配置

00:30:01.350 --> 00:30:06.180
检查是否存在拖曳

00:30:03.090 --> 00:30:08.460
类路径并注释

00:30:06.180 --> 00:30:10.940
带有add的underwow配置

00:30:08.460 --> 00:30:13.860
有条件的

00:30:10.940 --> 00:30:15.570
同样对于tomcat，我们添加了一个

00:30:13.860 --> 00:30:19.920
检查是否存在的条件

00:30:15.570 --> 00:30:23.810
在类路径上的tomcat并添加了一个

00:30:19.920 --> 00:30:23.810
以tomcat配置为条件

00:30:24.440 --> 00:30:28.650
所以现在如果我运行应用程序

00:30:26.940 --> 00:30:29.580
应该工作，因为其中只有一个

00:30:28.650 --> 00:30:31.680
将

00:30:29.580 --> 00:30:35.090
那是从猫那里来的，因为我们有

00:30:31.680 --> 00:30:37.740
 Tomcat在我们的类路径上，这就是

00:30:35.090 --> 00:30:40.020
 spring boot 做很多汽车

00:30:37.740 --> 00:30:42.630
通过寻找条件配置

00:30:40.020 --> 00:30:44.880
在课堂上，所以说你有

00:30:42.630 --> 00:30:48.300
 Spring 会议的自动配置

00:30:44.880 --> 00:30:51.180
只有在 Spring 会议上才会开始

00:30:48.300 --> 00:31:00.660
在你上课的路上，否则

00:30:51.180 --> 00:31:04.530
会像我们刚刚看到的那样爆炸

00:31:00.660 --> 00:31:07.320
虽然我们这里有条件

00:31:04.530 --> 00:31:09.570
理想情况下，应该将这些移动

00:31:07.320 --> 00:31:14.490
条件到一个条件，因为

00:31:09.570 --> 00:31:16.320
他们是重复的代码，所以

00:31:14.490 --> 00:31:20.010
只是检查是否存在

00:31:16.320 --> 00:31:24.480
在课程路径上的课程

00:31:20.010 --> 00:31:29.340
让我们在上添加自定义条件

00:31:24.480 --> 00:31:31.620
类注释，所以再次

00:31:29.340 --> 00:31:33.990
类似于

00:31:31.620 --> 00:31:36.290
 Spring ，但是-向您展示什么情况

00:31:33.990 --> 00:31:39.450
在幕后花名册上

00:31:36.290 --> 00:31:42.150
有条件的安提拉课程

00:31:39.450 --> 00:31:44.160
这是在我们的课堂条件下， 

00:31:42.150 --> 00:31:46.290
基本上做我们在做的事

00:31:44.160 --> 00:31:50.280
我们对底色的单独条件

00:31:46.290 --> 00:31:53.160
和Tomcat，但正在上课

00:31:50.280 --> 00:31:55.170
注释中的名称属性，以及

00:31:53.160 --> 00:31:58.620
然后检查那个

00:31:55.170 --> 00:32:00.930
课堂上的课程，所以如果你看

00:31:58.620 --> 00:32:04.410
现在是Tomcat配置

00:32:00.930 --> 00:32:07.400
这里没有这种自定义条件

00:32:04.410 --> 00:32:10.890
它只是在一个类上使用条件

00:32:07.400 --> 00:32:11.790
注释，并说该类

00:32:10.890 --> 00:32:15.030
名字是

00:32:11.790 --> 00:32:18.120
 Tomcat，所以如果tom上课

00:32:15.030 --> 00:32:21.230
路径用于其他方式

00:32:18.120 --> 00:32:21.230
这是同一件事

00:32:26.309 --> 00:32:32.500
所以条件注释就是

00:32:29.980 --> 00:32:35.140
 Spring Framework中的接口和您

00:32:32.500 --> 00:32:37.330
甚至可以使用条件注释

00:32:35.140 --> 00:32:39.850
在您的代码中，如果您愿意，我们

00:32:37.330 --> 00:32:42.100
在 Spring 相当广泛地使用它

00:32:39.850 --> 00:32:44.350
靴子自动配置有

00:32:42.100 --> 00:32:47.950
诸如条件上课之类的事情

00:32:44.350 --> 00:32:50.100
有条件的话，让我们说

00:32:47.950 --> 00:32:52.809
自动配置提供光束

00:32:50.100 --> 00:32:56.559
 spring boot 将 spring boot 自动

00:32:52.809 --> 00:32:58.809
如果用户退出配置

00:32:56.559 --> 00:33:01.720
提供光束，因此如果您的应用程序

00:32:58.809 --> 00:33:04.480
提供一个梁 spring boot 会像

00:33:01.720 --> 00:33:06.100
这件事是有条件的

00:33:04.480 --> 00:33:07.600
我不会提供我的汽车

00:33:06.100 --> 00:33:11.320
配置，因为用户有

00:33:07.600 --> 00:33:13.720
已经提供了条件

00:33:11.320 --> 00:33:16.480
在Spring Framework中用在

00:33:13.720 --> 00:33:20.049
添加配置文件，因此添加配置文件实际上是

00:33:16.480 --> 00:33:21.610
下面的条件和条件

00:33:20.049 --> 00:33:23.500
至少在 spring boot 内

00:33:21.610 --> 00:33:26.140
条件是有序的，所以我们尝试

00:33:23.500 --> 00:33:28.510
订购它们，以便最快的运行

00:33:26.140 --> 00:33:31.960
首先，我认为条件是

00:33:28.510 --> 00:33:34.419
第一类的优先级最高

00:33:31.960 --> 00:33:37.240
将首先运行，如果该类是

00:33:34.419 --> 00:33:41.970
在该汽车下根本找不到任何东西

00:33:37.240 --> 00:33:41.970
配置将需要配置

00:33:46.570 --> 00:33:52.690
还有我想要的最后一件事

00:33:50.320 --> 00:33:56.340
我想在 Spring 展示的作品

00:33:52.690 --> 00:33:59.350
引导应用程序添加了一个属性，因此

00:33:56.340 --> 00:34:01.630
在 spring boot 里你有这个东西

00:33:59.350 --> 00:34:05.140
称为配置属性，其中

00:34:01.630 --> 00:34:07.600
您可以在

00:34:05.140 --> 00:34:09.760
外部配置以及那个

00:34:07.600 --> 00:34:13.090
绑定到您的配置

00:34:09.760 --> 00:34:30.220
属性类，以便向

00:34:13.090 --> 00:34:34.030
假设我们有这个Tomcat 

00:34:30.220 --> 00:34:36.910
配置，以便初学者之前

00:34:34.030 --> 00:34:39.340
添加任何东西

00:34:36.910 --> 00:34:41.380
配置属性可以完成我的工作

00:34:39.340 --> 00:34:44.140
完成只是使用值注释

00:34:41.380 --> 00:34:46.540
来自Spring Framework，它将看起来

00:34:44.140 --> 00:34:48.250
对于称为端口的属性，如果

00:34:46.540 --> 00:34:52.440
想要配置您的端口或其他东西

00:34:48.250 --> 00:34:55.870
除了8080以外，您还可以使用

00:34:52.440 --> 00:35:01.750
这样就可以了，如果我运行该应用程序

00:34:55.870 --> 00:35:03.280
实际上我没有指定

00:35:01.750 --> 00:35:08.560
应用程序属性，所以让我

00:35:03.280 --> 00:35:13.480
在下一次提交之前签出

00:35:08.560 --> 00:35:20.080
如果我运行此应用程序，它将失败

00:35:13.480 --> 00:35:26.620
有数字格式异常，我

00:35:20.080 --> 00:35:28.780
认为那是因为我没有

00:35:26.620 --> 00:35:34.530
财产来源占位符

00:35:28.780 --> 00:35:34.530
这样配置

00:35:36.950 --> 00:35:41.870
我已经为

00:35:39.680 --> 00:35:44.090
属性来源占位符配置

00:35:41.870 --> 00:35:45.590
再次，这是你不需要的东西

00:35:44.090 --> 00:35:47.810
通常会发生这种情况

00:35:45.590 --> 00:35:49.490
幕后，只是为了给你

00:35:47.810 --> 00:35:58.760
关于背后发生的事情的想法

00:35:49.490 --> 00:36:00.590
场景现在应该可以工作了，所以

00:35:58.760 --> 00:36:03.560
应用程序启动并且仍在运行

00:36:00.590 --> 00:36:05.990
在端口8080上，这是默认设置

00:36:03.560 --> 00:36:09.110
再次是我们使用的默认值

00:36:05.990 --> 00:36:22.280
如果端口不是，则在值注释中

00:36:09.110 --> 00:36:24.710
发现，如果我们要改变这一点

00:36:22.280 --> 00:36:30.290
我已经添加了这个名为magic tor的文件

00:36:24.710 --> 00:36:33.350
属性并指定端口9090，因此

00:36:30.290 --> 00:36:35.750
如果我跑了，我也许你们中的一些人

00:36:33.350 --> 00:36:38.780
预计它将在1990年开始运行

00:36:35.750 --> 00:36:40.580
因为我已经将其添加为属性，但是

00:36:38.780 --> 00:36:46.760
它实际上仍在港口启动

00:36:40.580 --> 00:36:49.220
 8080所以有更多配置

00:36:46.760 --> 00:36:51.260
处理属性，所以我们添加了一个文件

00:36:49.220 --> 00:36:53.570
但实际上并没有真正处理它

00:36:51.260 --> 00:36:55.760
 Spring Boot应用程序中的那一刻

00:36:53.570 --> 00:36:58.520
如果添加应用程序或属性

00:36:55.760 --> 00:37:00.260
文件或应用程序或EML文件

00:36:58.520 --> 00:37:03.410
自动为您处理

00:37:00.260 --> 00:37:10.790
在幕后，但在这里我们需要

00:37:03.410 --> 00:37:13.430
自己添加该配置，以便

00:37:10.790 --> 00:37:16.130
有这个环境后处理器

00:37:13.430 --> 00:37:18.770
那是一种可用的方式

00:37:16.130 --> 00:37:21.860
与任何 spring boot 应用程序，你

00:37:18.770 --> 00:37:23.810
可以实现将东西添加到

00:37:21.860 --> 00:37:25.880
环境，如果您想在这种情况下

00:37:23.810 --> 00:37:29.270
我们只是要读魔术点

00:37:25.880 --> 00:37:31.970
来自类路径的属性文件和

00:37:29.270 --> 00:37:34.010
从该文件获取属性，然后

00:37:31.970 --> 00:37:36.670
将其存储为属性源

00:37:34.010 --> 00:37:36.670
环境

00:37:42.890 --> 00:37:49.260
所以现在终于这一切了

00:37:45.240 --> 00:37:52.680
服务器已启动的配置

00:37:49.260 --> 00:37:55.710
端口90 90这是我们在中指定的

00:37:52.680 --> 00:37:57.650
我们的属性文件，但再次值

00:37:55.710 --> 00:38:00.150
注释不是类型安全的， 

00:37:57.650 --> 00:38:03.150
配置属性很好

00:38:00.150 --> 00:38:06.150
价值的替代选择

00:38:03.150 --> 00:38:11.310
注释，所以即使我们有我们的

00:38:06.150 --> 00:38:14.010
服务器在端口90 90上，我们应该

00:38:11.310 --> 00:38:21.510
继续并添加一些使

00:38:14.010 --> 00:38:23.760
使用类型安全功能，以便

00:38:21.510 --> 00:38:27.150
而不是使用增加值

00:38:23.760 --> 00:38:29.760
现在我们正在使用此类

00:38:27.150 --> 00:38:32.640
服务器中的服务器属性

00:38:29.760 --> 00:38:34.950
属性，我们有一个端口，您可以

00:38:32.640 --> 00:38:38.310
然后设置为您想要的任何值

00:38:34.950 --> 00:38:42.720
所以在 Spring 的神奇特性

00:38:38.310 --> 00:38:45.270
我们还有4 90 90，我们已经使用了

00:38:42.720 --> 00:38:49.350
 Tomcat中的服务器属性

00:38:45.270 --> 00:38:56.760
配置类，但是如果我再次运行

00:38:49.350 --> 00:38:59.130
这失败了，因为它说

00:38:56.760 --> 00:39:02.910
 Tomcat配置需要

00:38:59.130 --> 00:39:04.710
键入配置点服务器属性，但是

00:39:02.910 --> 00:39:06.420
找不到那个 bean ，那是

00:39:04.710 --> 00:39:11.580
因为没有什么能真正创造出

00:39:06.420 --> 00:39:14.630
 bean在这个应用程序中为您服务，所以我们

00:39:11.580 --> 00:39:14.630
需要自己做

00:39:22.070 --> 00:39:26.600
我在这里做的方式是

00:39:24.650 --> 00:39:32.480
有点类似于 Spring 

00:39:26.600 --> 00:39:36.320
 spring boot 是使用对不起我

00:39:32.480 --> 00:39:39.230
只需要找这个班

00:39:36.320 --> 00:39:41.720
启用魔术属性注册，所以我们

00:39:39.230 --> 00:39:44.390
看起来有点进口

00:39:41.720 --> 00:39:47.840
您可以使用光束定义寄存器

00:39:44.390 --> 00:39:49.910
在您的导入注释中使用

00:39:47.840 --> 00:39:53.390
安娜这启用魔术属性

00:39:49.910 --> 00:39:57.620
 register是导入bean注册，并且

00:39:53.390 --> 00:40:05.740
它所做的基本上是注册

00:39:57.620 --> 00:40:08.740
按住不放注释的任何光束

00:40:05.740 --> 00:40:08.740
抱歉

00:40:12.760 --> 00:40:19.130
所以在我们启用魔术属性

00:40:16.910 --> 00:40:21.350
我们指定了我们想要的注释

00:40:19.130 --> 00:40:25.010
启用服务器属性类

00:40:21.350 --> 00:40:26.840
这意味着启用魔法

00:40:25.010 --> 00:40:30.530
属性导入梁定义

00:40:26.840 --> 00:40:32.690
注册服务商将对此光束进行注册

00:40:30.530 --> 00:40:40.430
还将绑定来自

00:40:32.690 --> 00:40:43.550
属性文件到此类，因此

00:40:40.430 --> 00:40:45.920
基本上在

00:40:43.550 --> 00:40:50.210
说它正在导入启用

00:40:45.920 --> 00:40:52.820
魔术属性注册商和

00:40:50.210 --> 00:40:55.580
注册商的所有逻辑

00:40:52.820 --> 00:40:58.130
对于那时候进行的绑定

00:40:55.580 --> 00:41:02.180
梁已创建，因此我使用了该活页夹

00:40:58.130 --> 00:41:04.520
从 spring boot ，当你有

00:41:02.180 --> 00:41:07.400
 Spring 的配置属性

00:41:04.520 --> 00:41:09.110
引导应用程序有一个启用或

00:41:07.400 --> 00:41:11.480
启用配置属性

00:41:09.110 --> 00:41:14.990
您可能曾经使用过的注释

00:41:11.480 --> 00:41:17.180
启用自己的属性

00:41:14.990 --> 00:41:19.670
属性和幕后这是

00:41:17.180 --> 00:41:21.770
发生了什么事，有进口光束

00:41:19.670 --> 00:41:24.500
定义注册商将注册

00:41:21.770 --> 00:41:26.750
束并绑定属性

00:41:24.500 --> 00:41:33.270
它从应用程序门中找到

00:41:26.750 --> 00:41:35.220
该光束的特性

00:41:33.270 --> 00:41:38.160
如果我们现在运行它，我们应该拥有

00:41:35.220 --> 00:41:40.340
正在创建的服务器属性及其

00:41:38.160 --> 00:41:42.900
应该已经绑定了9090端口

00:41:40.340 --> 00:41:49.710
这将在中指定

00:41:42.900 --> 00:41:52.020
属性文件，以便快速浏览

00:41:49.710 --> 00:41:54.210
在这个配置配置包这里

00:41:52.020 --> 00:41:56.940
这些事情很多，例如有条件的

00:41:54.210 --> 00:41:59.280
在课堂上启用自动魔术

00:41:56.940 --> 00:42:01.590
配置启用魔术属性

00:41:59.280 --> 00:42:05.310
魔术应用程序和我们要做的事情

00:42:01.590 --> 00:42:07.710
刚刚添加，它们看起来与

00:42:05.310 --> 00:42:09.750
跳板为您提供的注释

00:42:07.710 --> 00:42:12.930
所以我们基本上创建了一个

00:42:09.750 --> 00:42:15.300
从头开始添加应用程序

00:42:12.930 --> 00:42:17.310
一件一件地走出去

00:42:15.300 --> 00:42:19.590
装有 spring boot 的包装盒，但

00:42:17.310 --> 00:42:22.380
希望这给你一个想法

00:42:19.590 --> 00:42:24.600
 hap需要在后面配置什么

00:42:22.380 --> 00:42:27.510
场景，以便您运行

00:42:24.600 --> 00:42:29.630
应用程序和更快的入门

00:42:27.510 --> 00:42:29.630
经验

00:42:31.040 --> 00:42:37.530
所以再次回顾一下条件

00:42:34.770 --> 00:42:39.600
他们以班级为条件

00:42:37.530 --> 00:42:42.030
魔术应用是元

00:42:39.600 --> 00:42:44.640
注释，因此 Spring 良好的应用是

00:42:42.030 --> 00:42:46.530
如果发现

00:42:44.640 --> 00:42:50.400
您的组件有问题

00:42:46.530 --> 00:42:52.890
扫描您可以随时查看挖掘

00:42:50.400 --> 00:42:55.200
更深入地了解组件扫描方面

00:42:52.890 --> 00:42:57.600
您可以更深入地研究

00:42:55.200 --> 00:43:00.990
Spring 的自动配置方面

00:42:57.600 --> 00:43:03.000
引导应用程序注释启用魔术

00:43:00.990 --> 00:43:05.460
自动配置是注释

00:43:03.000 --> 00:43:08.250
那是导入我们的配置

00:43:05.460 --> 00:43:10.290
 Spring 该应用程序中的类

00:43:08.250 --> 00:43:13.109
启动它映射以启用自动

00:43:10.290 --> 00:43:15.810
配置带来了所有

00:43:13.109 --> 00:43:17.280
已注册的自动配置

00:43:15.810 --> 00:43:20.760
Spring 负载中有寄存器

00:43:17.280 --> 00:43:22.680
工厂和起点星

00:43:20.760 --> 00:43:24.660
像Tomcat这样的配置类

00:43:22.680 --> 00:43:27.450
配置承担了责任

00:43:24.660 --> 00:43:32.010
我们基本添加的配置

00:43:27.450 --> 00:43:34.560
映射到自动配置，例如

00:43:32.010 --> 00:43:36.960
 servlet的自动配置

00:43:34.560 --> 00:43:39.240
 servlet自动配置

00:43:36.960 --> 00:43:44.040
添加Tomcat bean和undertow 

00:43:39.240 --> 00:43:46.140
 bean 给你，所以基本上这个想法是

00:43:44.040 --> 00:43:46.990
告诉你没有这样的事情

00:43:46.140 --> 00:43:49.590
作为魔术

00:43:46.990 --> 00:43:52.030
从头开始构建所有内容， 

00:43:49.590 --> 00:43:54.280
我们能够用

00:43:52.030 --> 00:43:57.610
代码，所以没有魔法

00:43:54.280 --> 00:43:59.590
一切都在代码中并用于调试

00:43:57.610 --> 00:44:01.810
Spring 应用或Spring buta 

00:43:59.590 --> 00:44:04.690
应用程序只是跟随面包屑

00:44:01.810 --> 00:44:07.510
看一下什么是注释

00:44:04.690 --> 00:44:10.030
应用程序看看什么是进口

00:44:07.510 --> 00:44:13.330
正在使用或什么是导入选择器

00:44:10.030 --> 00:44:15.460
被使用，然后你可以把

00:44:13.330 --> 00:44:17.800
断点并调试它，如果您

00:44:15.460 --> 00:44:20.410
需要涌出工厂是一种方法

00:44:17.800 --> 00:44:23.250
为您贡献更多的汽车

00:44:20.410 --> 00:44:26.110
配置，如果您正在编写和

00:44:23.250 --> 00:44:28.000
条件是Spring 启动方式

00:44:26.110 --> 00:44:29.980
配置知道何时退出

00:44:28.000 --> 00:44:32.440
何时贡献某些 Bean type 和

00:44:29.980 --> 00:44:36.610
这样的事情也都开放

00:44:32.440 --> 00:44:39.010
源，因此如果需要，请使用源

00:44:36.610 --> 00:44:41.940
进行调试，希望它将

00:44:39.010 --> 00:44:43.890
帮助您开发更好的应用程序

00:44:41.940 --> 00:44:46.110
谢谢

00:44:43.890 --> 00:44:52.499
 [掌声] 

00:44:46.110 --> 00:44:52.499
 [音乐] 

