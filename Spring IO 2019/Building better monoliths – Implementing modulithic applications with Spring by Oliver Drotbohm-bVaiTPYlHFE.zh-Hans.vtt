WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.900 --> 00:00:11.600
 [音乐] 

00:00:07.760 --> 00:00:16.160
让我们用这个额外的方法打招呼

00:00:11.600 --> 00:00:18.180
欢迎从我的网站春季到I / O 

00:00:16.160 --> 00:00:19.830
有趣的是，有很多人出现

00:00:18.180 --> 00:00:23.369
我当时以为每个人

00:00:19.830 --> 00:00:26.100
这几天建立微服务是

00:00:23.369 --> 00:00:29.000
那你在说什么哦

00:00:26.100 --> 00:00:33.089
不是我今天要谈论的

00:00:29.000 --> 00:00:36.539
我想说的基本上是

00:00:33.089 --> 00:00:38.760
您可以做些什么来保持结构的活力

00:00:36.539 --> 00:00:41.809
在你说更单片

00:00:38.760 --> 00:00:44.039
我想开始的应用程序

00:00:41.809 --> 00:00:46.409
情境化好了我怎么想

00:00:44.039 --> 00:00:48.979
追求是值得的， 

00:00:46.409 --> 00:00:52.920
我们将要进入​​一点点

00:00:48.979 --> 00:00:54.749
微软的优势和劣势

00:00:52.920 --> 00:00:56.999
应用程序，但随后

00:00:54.749 --> 00:00:59.489
变得非常技术我有一个小小的

00:00:56.999 --> 00:01:01.100
我要显示的启动扩展名

00:00:59.489 --> 00:01:04.140
你会帮助你实际上

00:01:01.100 --> 00:01:05.580
保持结构并实现

00:01:04.140 --> 00:01:08.670
人们还有很多其他目标

00:01:05.580 --> 00:01:10.800
当他们去微型时通常

00:01:08.670 --> 00:01:13.170
服务，所以可能是

00:01:10.800 --> 00:01:15.540
你甚至没有，甚至没有

00:01:13.170 --> 00:01:19.710
转向微服务

00:01:15.540 --> 00:01:21.080
真正实现这些目标，但首先

00:01:19.710 --> 00:01:24.450
事情首先我的名字只有妈妈

00:01:21.080 --> 00:01:26.520
我一直以工作着称

00:01:24.450 --> 00:01:27.930
花费数据项目，他们一直在总结

00:01:26.520 --> 00:01:29.910
组织和团队结构

00:01:27.930 --> 00:01:33.300
最近，但我仍然是团队的一员

00:01:29.910 --> 00:01:35.940
仍然这样做，但要集中一点

00:01:33.300 --> 00:01:38.310
在所有其他的东西上

00:01:35.940 --> 00:01:40.470
在Spring数据中包围了我的工作

00:01:38.310 --> 00:01:46.890
作为模数的东西建筑

00:01:40.470 --> 00:01:49.140
框架的东西我很快就拥有了

00:01:46.890 --> 00:01:52.200
想总结一些交易

00:01:49.140 --> 00:01:55.110
你得到这两个不同的或

00:01:52.200 --> 00:01:57.390
反对我不是的建筑风格

00:01:55.110 --> 00:01:59.580
试图掩盖一切或有一个

00:01:57.390 --> 00:02:03.360
我比较想要详细的比较

00:01:59.580 --> 00:02:05.490
专注于某些方面

00:02:03.360 --> 00:02:09.569
认为采用这种替代方法

00:02:05.490 --> 00:02:11.639
非常吸引人和有趣，所以

00:02:09.569 --> 00:02:12.530
基本思想是我们有四个

00:02:11.639 --> 00:02:15.260
我们的概念

00:02:12.530 --> 00:02:18.230
必须考虑一个是保税区

00:02:15.260 --> 00:02:21.500
某种逻辑上的上下文

00:02:18.230 --> 00:02:24.500
你内在的结构

00:02:21.500 --> 00:02:26.240
应用一些逻辑单元

00:02:24.500 --> 00:02:29.390
订单管理客户管理

00:02:26.240 --> 00:02:31.700
货运供应我们所拥有的

00:02:29.390 --> 00:02:32.959
部署单位的问题

00:02:31.700 --> 00:02:35.390
种类的部署

00:02:32.959 --> 00:02:37.010
实际上构成了我们的整体系统

00:02:35.390 --> 00:02:39.520
在这些内部有内部调用

00:02:37.010 --> 00:02:42.680
部署单位，我们有外部

00:02:39.520 --> 00:02:43.940
跨部署单元的调用

00:02:42.680 --> 00:02:46.640
对，因为这是不同的

00:02:43.940 --> 00:02:49.760
麦克风或列表处理

00:02:46.640 --> 00:02:52.430
这基本上是一个有限的上下文

00:02:49.760 --> 00:02:54.260
一个部署单元，我们都是

00:02:52.430 --> 00:02:57.680
调用Ross模块的调用是

00:02:54.260 --> 00:02:59.959
内部与微

00:02:57.680 --> 00:03:03.050
我们将服务与

00:02:59.959 --> 00:03:05.330
部署单元到有限的上下文

00:03:03.050 --> 00:03:07.010
这是基本的想法

00:03:05.330 --> 00:03:08.840
也意味着我们现在这些

00:03:07.010 --> 00:03:12.319
互动现在突然变得

00:03:08.840 --> 00:03:14.840
所有人都可以跨项目调用

00:03:12.319 --> 00:03:18.140
他们的起伏不定

00:03:14.840 --> 00:03:21.049
可能不太可能

00:03:18.140 --> 00:03:23.269
事故只是通过调用一些组件

00:03:21.049 --> 00:03:25.579
 HTTP和微服务世界

00:03:23.269 --> 00:03:27.320
整体上很容易做到

00:03:25.579 --> 00:03:29.390
你只有一个安排

00:03:27.320 --> 00:03:31.489
Spring 梁，而您只投放广告或

00:03:29.390 --> 00:03:32.750
两个连接到其他班级和一些

00:03:31.489 --> 00:03:34.610
其他模块，然后您就像

00:03:32.750 --> 00:03:35.030
连接这个东西，可以调用一个方法

00:03:34.610 --> 00:03:37.010
在上面

00:03:35.030 --> 00:03:38.660
好吧，这就是这些

00:03:37.010 --> 00:03:41.829
这些架构，特别是在

00:03:38.660 --> 00:03:44.359
左侧很快退化，我们

00:03:41.829 --> 00:03:46.940
真的想看看我们

00:03:44.359 --> 00:03:49.250
我们实际上可以做些什么来保持这一点

00:03:46.940 --> 00:03:52.940
这个结构在

00:03:49.250 --> 00:03:54.829
左侧左右，所以我看到的好处

00:03:52.940 --> 00:03:57.230
在一个更整体的方法上

00:03:54.829 --> 00:03:59.420
是我们再次抓住了这个主意

00:03:57.230 --> 00:04:01.579
从根本上部署多个边界

00:03:59.420 --> 00:04:03.829
单个部署单元中的上下文

00:04:01.579 --> 00:04:05.359
受益，特别是当您开始新的

00:04:03.829 --> 00:04:07.910
当您探索新项目时

00:04:05.359 --> 00:04:09.590
理由是有限的上下文

00:04:07.910 --> 00:04:12.590
边界更容易重构

00:04:09.590 --> 00:04:15.170
然后，如果您以

00:04:12.590 --> 00:04:17.510
您所处的微服务项目

00:04:15.170 --> 00:04:19.160
基本上将api放在适当的位置

00:04:17.510 --> 00:04:21.140
第一次部署这些东西

00:04:19.160 --> 00:04:22.530
你现在必须突然安排

00:04:21.140 --> 00:04:24.030
喜欢打破变化

00:04:22.530 --> 00:04:26.040
总体变化或您有什么变化

00:04:24.030 --> 00:04:30.600
在一个环境中移动代码要容易得多

00:04:26.040 --> 00:04:33.090
在同一个整体的代码库中，它是

00:04:30.600 --> 00:04:34.650
总体上非常容易测试系统

00:04:33.090 --> 00:04:36.389
就像使用spring集成一样

00:04:34.650 --> 00:04:40.080
测试功能，我们只是引导

00:04:36.389 --> 00:04:42.419
事情只是调用方法调用REST API 

00:04:40.080 --> 00:04:46.710
你是对的，就是

00:04:42.419 --> 00:04:50.340
正如我所说的那样，这很容易

00:04:46.710 --> 00:04:53.700
给出了退化，这是

00:04:50.340 --> 00:04:54.720
实际到位是原因之一

00:04:53.700 --> 00:04:56.810
这么多人关注

00:04:54.720 --> 00:04:58.620
像这样的微服务

00:04:56.810 --> 00:05:01.110
我们大家定义良好的结构

00:04:58.620 --> 00:05:03.650
在整个过程中开始

00:05:01.110 --> 00:05:06.150
时间基本上会退化， 

00:05:03.650 --> 00:05:09.780
使之进一步发展

00:05:06.150 --> 00:05:13.500
系统要复杂得多，这是什么

00:05:09.780 --> 00:05:15.030
也不是很容易，或者像我还没有

00:05:13.500 --> 00:05:17.850
看到有人真正接近这个

00:05:15.030 --> 00:05:20.940
之前是如何实际测试的

00:05:17.850 --> 00:05:25.410
我们可以进入的各个模块

00:05:20.940 --> 00:05:27.120
像构造你的你的问题

00:05:25.410 --> 00:05:28.979
您当然可以使用单片应用程序

00:05:27.120 --> 00:05:31.050
使用类似Maven模块之类的东西

00:05:28.979 --> 00:05:34.440
更大的模块或您拥有什么

00:05:31.050 --> 00:05:36.870
内部构造您的整体

00:05:34.440 --> 00:05:39.300
但是就像引导一样

00:05:36.870 --> 00:05:41.340
其中两个或三个一起

00:05:39.300 --> 00:05:43.500
无需太多努力的组合

00:05:41.340 --> 00:05:45.960
真的不是一流的公民

00:05:43.500 --> 00:05:47.669
在Spring的测试支持中

00:05:45.960 --> 00:05:50.610
框架或垃圾邮件赃物框架或

00:05:47.669 --> 00:05:53.190
实际上到目前为止还没有

00:05:50.610 --> 00:05:55.470
我看到微服务的缺点

00:05:53.190 --> 00:05:57.900
真正实现了我的目标

00:05:55.470 --> 00:06:01.680
想用我喜欢的东西实现

00:05:57.900 --> 00:06:03.450
这里准备的是

00:06:01.680 --> 00:06:05.580
上下文交互是远程的，这意味着

00:06:03.450 --> 00:06:07.860
而不是可以

00:06:05.580 --> 00:06:10.200
无论成功还是抛出异常，我们

00:06:07.860 --> 00:06:12.270
现在可以拥有我们现在必须序列化

00:06:10.200 --> 00:06:16.110
我们需要调用网络的有效负载

00:06:12.270 --> 00:06:19.169
通话费用高得多

00:06:16.110 --> 00:06:21.360
其他更多的故障场景

00:06:19.169 --> 00:06:22.830
系统无法使用

00:06:21.360 --> 00:06:24.419
可能可用，但网络可以

00:06:22.830 --> 00:06:25.950
无法获得你有什么

00:06:24.419 --> 00:06:27.510
有很多事情要做

00:06:25.950 --> 00:06:29.789
您实际上要提防的

00:06:27.510 --> 00:06:32.710
然后添加一些额外的代码

00:06:29.789 --> 00:06:35.380
缓解这些问题

00:06:32.710 --> 00:06:38.830
这些具有讽刺意味的事情

00:06:35.380 --> 00:06:42.310
首先是您的实际关注点

00:06:38.830 --> 00:06:44.020
从编写业务代码到我需要

00:06:42.310 --> 00:06:46.270
把这个历史性的东西放在这里

00:06:44.020 --> 00:06:47.980
你有没有，所以你基本上专注于

00:06:46.270 --> 00:06:51.280
基础架构级别的集成

00:06:47.980 --> 00:06:54.760
 um测试单个模块

00:06:51.280 --> 00:06:56.920
很好很好的原因是我

00:06:54.760 --> 00:06:58.630
用黄色标记的是当您

00:06:56.920 --> 00:07:01.120
之间有很多互动

00:06:58.630 --> 00:07:03.580
不仅是一个指标

00:07:01.120 --> 00:07:05.950
您的设置类型或您的

00:07:03.580 --> 00:07:08.560
您的粒度也许是

00:07:05.950 --> 00:07:09.970
你应该在你身上工作

00:07:08.560 --> 00:07:12.220
也遇到你的情况

00:07:09.970 --> 00:07:14.490
必须引导其他系统停止或

00:07:12.220 --> 00:07:16.420
模拟其他系统以实际

00:07:14.490 --> 00:07:19.270
集成测试那些可以

00:07:16.420 --> 00:07:22.770
保持安静或可以引入很多

00:07:19.270 --> 00:07:25.060
以及我所说的努力

00:07:22.770 --> 00:07:27.610
重构上下文边界抱歉

00:07:25.060 --> 00:07:29.980
这是相当大的努力，因为

00:07:27.610 --> 00:07:32.140
曾经的API如此公开，特别是如果您

00:07:29.980 --> 00:07:33.910
管理这些个人服务

00:07:32.140 --> 00:07:36.070
由不同的团队，这不仅是

00:07:33.910 --> 00:07:37.840
技术决策和政治决策

00:07:36.070 --> 00:07:40.180
决定可以由其他团队实际完成

00:07:37.840 --> 00:07:42.520
为您更改该API 

00:07:40.180 --> 00:07:44.230
管理其他依赖的客户

00:07:42.520 --> 00:07:46.600
以前的API是的，它们是

00:07:44.230 --> 00:07:48.160
你说的就像互动

00:07:46.600 --> 00:07:51.220
在完全不同的水平上

00:07:48.160 --> 00:07:53.080
而不是像使用

00:07:51.220 --> 00:07:55.120
您的重构能力

00:07:53.080 --> 00:07:57.670
 IDE就像更改方法名称或

00:07:55.120 --> 00:07:59.640
财产名称或您有什么

00:07:57.670 --> 00:08:01.960
还有一个挑战是

00:07:59.640 --> 00:08:04.450
您如何实际测试系统

00:08:01.960 --> 00:08:07.030
总的来说，我们如何实际测试像

00:08:04.450 --> 00:08:08.680
我们需要从头到尾的业务流程

00:08:07.030 --> 00:08:12.040
引导我们必须拥有的所有系统

00:08:08.680 --> 00:08:14.230
有他们在附近，是的，我们可以

00:08:12.040 --> 00:08:17.350
只是我们还需要跟踪电话

00:08:14.230 --> 00:08:20.850
这可能发生在系统之间

00:08:17.350 --> 00:08:23.800
那就是很大的挑战，所以

00:08:20.850 --> 00:08:26.650
尤其喜欢测试

00:08:23.800 --> 00:08:29.820
各个模块和方面是

00:08:26.650 --> 00:08:32.590
人们通常从开始

00:08:29.820 --> 00:08:33.850
和迈克在一起那就是原因

00:08:32.590 --> 00:08:34.900
他们从微服务开始

00:08:33.850 --> 00:08:36.940
因为他们想实现第一名

00:08:34.900 --> 00:08:39.760
那是不可能的，你真的可以

00:08:36.940 --> 00:08:40.610
很好地引导Spring 的一部分

00:08:39.760 --> 00:08:44.690
应用

00:08:40.610 --> 00:08:46.760
我的意思是这样会如何工作， 

00:08:44.690 --> 00:08:49.520
这是我基本上采取的

00:08:46.760 --> 00:08:51.890
仔细看看，原来变成了

00:08:49.520 --> 00:08:54.650
它实际上变成了这个

00:08:51.890 --> 00:08:56.690
我想展示的特定项目

00:08:54.650 --> 00:08:59.450
您和我已通过

00:08:56.690 --> 00:09:02.780
本身或实习生的示例代码库

00:08:59.450 --> 00:09:05.000
是在我所从事的项目中开发的

00:09:02.780 --> 00:09:05.720
在我当地的大学里

00:09:05.000 --> 00:09:08.000
家乡

00:09:05.720 --> 00:09:09.830
他们基本上是让学生进入

00:09:08.000 --> 00:09:12.470
软件工程学期

00:09:09.830 --> 00:09:15.620
使用Spring Boot构建Web应用程序

00:09:12.470 --> 00:09:17.660
他们可能会出什么问题

00:09:15.620 --> 00:09:19.790
没有，我是说半个学期

00:09:17.660 --> 00:09:22.640
 Java专业知识，无数据库讲座

00:09:19.790 --> 00:09:26.090
观看之前真的很有趣

00:09:22.640 --> 00:09:28.490
有趣，但我们基本上提供

00:09:26.090 --> 00:09:32.540
它们具有基本的应用程序

00:09:28.490 --> 00:09:37.250
以电子商务为中心

00:09:32.540 --> 00:09:40.040
应用程序框架有一个

00:09:37.250 --> 00:09:42.530
业务模块集，所以我们有

00:09:40.040 --> 00:09:47.000
有用户抽象我们有订单

00:09:42.530 --> 00:09:49.460
摘要我们有一个目录和一个

00:09:47.000 --> 00:09:51.860
目录基本具有的库存

00:09:49.460 --> 00:09:55.280
产品权的一般描述

00:09:51.860 --> 00:09:57.290
价格清单包含产品加

00:09:55.280 --> 00:10:01.610
一定数量，所以我们基本上停止了

00:09:57.290 --> 00:10:03.470
保持和订单指的是产品

00:10:01.610 --> 00:10:05.690
和目录，所以他们有一个或行

00:10:03.470 --> 00:10:07.820
基本上可以放入的物品

00:10:05.690 --> 00:10:08.210
订单以及每当您完成

00:10:07.820 --> 00:10:11.770
订购

00:10:08.210 --> 00:10:14.960
有用于库存更新的API 

00:10:11.770 --> 00:10:17.810
股票的权利，所以如果我要订购

00:10:14.960 --> 00:10:20.950
五台电视机的库存必须减少

00:10:17.810 --> 00:10:23.060
该特定产品的五个项目

00:10:20.950 --> 00:10:26.120
我们也有商业的概念

00:10:23.060 --> 00:10:27.950
时间实际上是怎么回事

00:10:26.120 --> 00:10:30.200
从商业角度来看

00:10:27.950 --> 00:10:32.840
对此并不重要

00:10:30.200 --> 00:10:34.520
对于此演示文稿，只有一个

00:10:32.840 --> 00:10:36.890
我想要的几件事

00:10:34.520 --> 00:10:39.080
你要专注，所以我有扎实的

00:10:36.890 --> 00:10:43.540
线或实心箭头是组件

00:10:39.080 --> 00:10:45.480
依赖关系意味着在那个模块中

00:10:43.540 --> 00:10:48.149
有

00:10:45.480 --> 00:10:50.250
Spring 梁参考

00:10:48.149 --> 00:10:54.959
库存模块中的Spring 梁

00:10:50.250 --> 00:10:56.940
对或订单模块有Spring 

00:10:54.959 --> 00:10:59.130
本身具有依赖性的组件

00:10:56.940 --> 00:11:01.410
在工作时间，我要去

00:10:59.130 --> 00:11:02.820
一秒钟回来，因为那是

00:11:01.410 --> 00:11:05.149
真的很重要

00:11:02.820 --> 00:11:07.260
值得一看的东西

00:11:05.149 --> 00:11:09.300
当你真正在意

00:11:07.260 --> 00:11:12.209
不断发展这些系统

00:11:09.300 --> 00:11:14.399
依赖关系是平面类型的依赖关系

00:11:12.209 --> 00:11:16.410
对的，所以我们说库存

00:11:14.399 --> 00:11:18.449
有一个库存项目是

00:11:16.410 --> 00:11:21.120
有效地加上一定数量的产品

00:11:18.449 --> 00:11:23.850
好的，所以在这种情况下让我们的JPA是JPA 

00:11:21.120 --> 00:11:25.649
实体，那只是一个普通的类型

00:11:23.850 --> 00:11:26.910
依赖它不像秋千

00:11:25.649 --> 00:11:28.889
组件，您可以看到为什么

00:11:26.910 --> 00:11:31.260
重要的是我要回到

00:11:28.889 --> 00:11:33.600
第二，你已经看到像人

00:11:31.260 --> 00:11:35.490
也许更高级或更喜欢

00:11:33.600 --> 00:11:37.110
就像他们的应用设计师一样

00:11:35.490 --> 00:11:39.570
他们已经看到有一个

00:11:37.110 --> 00:11:43.709
此代码中的问题

00:11:39.570 --> 00:11:45.449
基地，我没事，所以我们

00:11:43.709 --> 00:11:47.310
我只想看一点代码

00:11:45.449 --> 00:11:50.250
从我要去的东西开始

00:11:47.310 --> 00:11:53.130
告诉你它叫做模数

00:11:50.250 --> 00:11:55.920
学期我知道我没有投币，我没有

00:11:53.130 --> 00:11:58.290
真的找到了它的最终来源

00:11:55.920 --> 00:12:00.269
最初是在我的另一个演讲中使用的

00:11:58.290 --> 00:12:02.490
认为我去年或两年间举办的研讨会

00:12:00.269 --> 00:12:05.069
多年前这里被称为

00:12:02.490 --> 00:12:08.430
重构到一个系统的系统

00:12:05.069 --> 00:12:11.490
我基本上建议但要建立一个mod 

00:12:08.430 --> 00:12:13.319
整体以某种方式准备

00:12:11.490 --> 00:12:15.540
提取到微服务中

00:12:13.319 --> 00:12:18.720
这是很多反馈

00:12:15.540 --> 00:12:20.880
好的，没有真正的框架

00:12:18.720 --> 00:12:22.230
对这种发展的支持

00:12:20.880 --> 00:12:24.600
活跃的一天，我的意思是什么都没有

00:12:22.230 --> 00:12:25.980
两者之间没有任何关系

00:12:24.600 --> 00:12:28.410
框架和您实际构建

00:12:25.980 --> 00:12:30.990
像这样的东西，但出于

00:12:28.410 --> 00:12:35.130
盒子里没有可用的东西，所以

00:12:30.990 --> 00:12:37.350
是什么主意，所以主意是

00:12:35.130 --> 00:12:40.980
首先从问题开始，如何

00:12:37.350 --> 00:12:43.350
我们是否映射那些有界的逻辑模块

00:12:40.980 --> 00:12:46.319
上下文或您如何使用我们的代码

00:12:43.350 --> 00:12:49.649
因为橡胶碰到

00:12:46.319 --> 00:12:52.050
路，我们的意思是这是PowerPoint 

00:12:49.649 --> 00:12:55.690
演讲很好，但在某些时候

00:12:52.050 --> 00:12:58.060
我们必须找到一种方法来代表

00:12:55.690 --> 00:13:00.010
客户或订单模块

00:12:58.060 --> 00:13:01.690
农村与基本面

00:13:00.010 --> 00:13:03.610
假设是

00:13:01.690 --> 00:13:05.740
春季申请，您通常有

00:13:03.610 --> 00:13:10.810
顶层的应用程序类

00:13:05.740 --> 00:13:13.410
包，然后你有业务

00:13:10.810 --> 00:13:16.240
封装在其下方，因此

00:13:13.410 --> 00:13:17.680
这基本上就是这里的事情，所以

00:13:16.240 --> 00:13:19.480
你可以继续把你的

00:13:17.680 --> 00:13:22.180
最顶层的应用程序类

00:13:19.480 --> 00:13:24.520
模数封装，然后在我的示例中

00:13:22.180 --> 00:13:26.860
如果他有点订单，我们会

00:13:24.520 --> 00:13:31.180
已经完成库存点你有什么

00:13:26.860 --> 00:13:35.070
对，所以只按组件包装是

00:13:31.180 --> 00:13:38.170
如果您在西蒙·布朗斯（Simon Browns）谈论它

00:13:35.070 --> 00:13:41.710
他有很多的条件

00:13:38.170 --> 00:13:43.360
谈到我有五个

00:13:41.710 --> 00:13:44.920
或六年前，我可以旅行

00:13:43.360 --> 00:13:46.600
会议是当时的话题

00:13:44.920 --> 00:13:49.540
叫哎呀，我的建筑去了哪里

00:13:46.600 --> 00:13:51.460
如果您用谷歌搜索爸爸， 

00:13:49.540 --> 00:13:53.980
关于为什么我认为的博客文章

00:13:51.460 --> 00:13:56.530
至少是一种顶层结构

00:13:53.980 --> 00:14:00.250
良好的开端有很多后果

00:13:56.530 --> 00:14:02.530
关于残疾规则，因为我们可以

00:14:00.250 --> 00:14:04.210
在这里使用java包范围隐藏

00:14:02.530 --> 00:14:05.950
从外部来的组件

00:14:04.210 --> 00:14:07.330
有趣的是，我要回到

00:14:05.950 --> 00:14:09.550
一秒钟，但这就是

00:14:07.330 --> 00:14:17.410
基本概念正确，然后我们可以

00:14:09.550 --> 00:14:20.710
利用这一点，但只有一点点

00:14:17.410 --> 00:14:22.930
交换阿司匹林的变化

00:14:20.710 --> 00:14:26.020
启动应用程序，添加模数和

00:14:22.930 --> 00:14:28.060
基本上是针对

00:14:26.020 --> 00:14:30.880
到您选择的图书馆

00:14:28.060 --> 00:14:32.740
这个包的结构有很多

00:14:30.880 --> 00:14:35.080
旋钮和其他注释

00:14:32.740 --> 00:14:36.580
在这里你也可以使用不同的种类

00:14:35.080 --> 00:14:39.010
数据包结构以使其正常工作

00:14:36.580 --> 00:14:42.010
使用这种系统，但默认情况下

00:14:39.010 --> 00:14:44.950
除了改变，你什么都不需要做

00:14:42.010 --> 00:14:47.410
该注释，实际上是在系统上

00:14:44.950 --> 00:14:49.510
当然，运行时

00:14:47.410 --> 00:14:52.000
在Springwood应用程序中注释

00:14:49.510 --> 00:14:54.940
在生产时一次运行

00:14:52.000 --> 00:14:58.090
没有什么不同，仅此而已

00:14:54.940 --> 00:15:00.130
基本上只是说好，我选择加入

00:14:58.090 --> 00:15:03.160
这种包装结构，因为我们可以

00:15:00.130 --> 00:15:06.670
然后在测试中确定

00:15:03.160 --> 00:15:08.089
要做的事情，或者我们可以通过

00:15:06.670 --> 00:15:12.800
分析那个结构

00:15:08.089 --> 00:15:16.730
你说得对，所以我给你看

00:15:12.800 --> 00:15:18.079
在心理上，所以我们有这种

00:15:16.730 --> 00:15:21.470
这个包结构你应该在这里

00:15:18.079 --> 00:15:25.759
看到你应该看到我希望大家

00:15:21.470 --> 00:15:27.649
在后面可以看到你看到的

00:15:25.759 --> 00:15:29.959
很像很多商务套餐

00:15:27.649 --> 00:15:31.759
不仅仅是我拥有的

00:15:29.959 --> 00:15:34.490
幻灯片像会计

00:15:31.759 --> 00:15:35.059
有付款支持用户帐户

00:15:34.490 --> 00:15:37.490
你有什么

00:15:35.059 --> 00:15:39.319
只是它的基本思想是

00:15:37.490 --> 00:15:41.480
你有这些包对我们

00:15:39.319 --> 00:15:44.120
网上也有分包

00:15:41.480 --> 00:15:47.930
在那里，我们可以使用它，但是我们

00:15:44.120 --> 00:15:50.569
现在可以在那里执行API 

00:15:47.930 --> 00:15:56.720
基本上可以说我想我

00:15:50.569 --> 00:15:59.600
应该在某个地方

00:15:56.720 --> 00:16:02.779
你从这样的东西开始

00:15:59.600 --> 00:16:05.120
测试，这里的第一行模块

00:16:02.779 --> 00:16:08.389
销售点样本就是

00:16:05.120 --> 00:16:10.879
基本应用程序类

00:16:08.389 --> 00:16:14.269
继续并基本分析

00:16:10.879 --> 00:16:17.870
包装内的类型和Spring 

00:16:14.269 --> 00:16:20.689
组件之间的依赖关系

00:16:17.870 --> 00:16:23.589
Spring 组件和隐式

00:16:20.689 --> 00:16:25.699
创建一棵树或至少图

00:16:23.589 --> 00:16:29.870
模块之间的依赖关系

00:16:25.699 --> 00:16:32.300
然后，我们可以与并使用

00:16:29.870 --> 00:16:33.620
真正帮助您分析并做到

00:16:32.300 --> 00:16:37.009
某些事情，这就是我

00:16:33.620 --> 00:16:41.870
想要我想前进

00:16:37.009 --> 00:16:43.790
在这里正确，因为当我们现在

00:16:41.870 --> 00:16:46.519
了解之间的依赖关系图

00:16:43.790 --> 00:16:49.129
您的模块，我们可以执行以下操作

00:16:46.519 --> 00:16:51.559
可以让你基本表达我

00:16:49.129 --> 00:16:56.480
想引导那个模块

00:16:51.559 --> 00:16:58.129
模块只对，这很漂亮

00:16:56.480 --> 00:17:00.740
很简单，这就是

00:16:58.129 --> 00:17:03.379
建立在Spring Boot支持测试上

00:17:00.740 --> 00:17:06.260
已经存在的支持

00:17:03.379 --> 00:17:09.319
我们已经有一段时间了

00:17:06.260 --> 00:17:12.500
对层的支持

00:17:09.319 --> 00:17:14.059
正确的注释，就是这样

00:17:12.500 --> 00:17:16.610
基本上我们的 spring boot 测试

00:17:14.059 --> 00:17:17.730
批注数据JPA测试数据Mongo 

00:17:16.610 --> 00:17:19.949
我认为是测试

00:17:17.730 --> 00:17:23.610
在那只是想从你那里

00:17:19.949 --> 00:17:26.160
在启动中测试中的spring应用程序

00:17:23.610 --> 00:17:28.559
只引导它会存储的存储库

00:17:26.160 --> 00:17:32.240
不引导任何服务或

00:17:28.559 --> 00:17:35.000
组件你没有Spring 的MVC 

00:17:32.240 --> 00:17:37.799
主要是为了进行优化的原因

00:17:35.000 --> 00:17:39.990
为了提高速度，所以-对于引导

00:17:37.799 --> 00:17:41.429
 Web MVC测试的时间相同

00:17:39.990 --> 00:17:44.010
将阻止杰克逊，它将

00:17:41.429 --> 00:17:45.809
引导春天，我们看到但所有

00:17:44.010 --> 00:17:48.540
控制器将不得不被模拟

00:17:45.809 --> 00:17:51.179
所以问题是当我们这样做时

00:17:48.540 --> 00:17:53.700
阻止我们做的事情

00:17:51.179 --> 00:17:57.570
用于业务的垂直切片

00:17:53.700 --> 00:18:01.950
大小合适，在那个水平上，那是

00:17:57.570 --> 00:18:04.530
基本上在

00:18:01.950 --> 00:18:06.929
模块测试注释基本上是这样

00:18:04.530 --> 00:18:09.750
您将继续进行整合

00:18:06.929 --> 00:18:11.580
测试让我们继续吧，我们有这个

00:18:09.750 --> 00:18:13.110
集成测试在模块中

00:18:11.580 --> 00:18:15.510
包在业务之一

00:18:13.110 --> 00:18:18.809
软件包，并说添加模块测试

00:18:15.510 --> 00:18:21.720
基本上就可以进行测试了

00:18:18.809 --> 00:18:25.380
引导程序开始对

00:18:21.720 --> 00:18:27.750
模块的结构，然后找出

00:18:25.380 --> 00:18:30.330
好吧，所有的组件都在里面

00:18:27.750 --> 00:18:33.360
该软件包并重新配置启动

00:18:30.330 --> 00:18:35.730
 spring boot 只能看到

00:18:33.360 --> 00:18:38.790
有效包装正确的组件

00:18:35.730 --> 00:18:42.059
让JPA实体扫描所有内容

00:18:38.790 --> 00:18:45.390
好东西，让我们来看看

00:18:42.059 --> 00:18:47.400
在目录中起作用，因为为什么

00:18:45.390 --> 00:18:48.900
为什么我们从目录开始

00:18:47.400 --> 00:18:50.850
最简单的事情，因为它没有

00:18:48.900 --> 00:18:54.780
有任何传出的依赖，所以

00:18:50.850 --> 00:19:01.530
让我们看看它是如何工作的

00:18:54.780 --> 00:19:04.650
不在这里，我们对该目录感到抱歉

00:19:01.530 --> 00:19:09.270
集成测试，所以现在

00:19:04.650 --> 00:19:11.250
 spring boot 测试，我可以运行它，然后

00:19:09.270 --> 00:19:12.650
我希望每个人都可以看到

00:19:11.250 --> 00:19:15.480
后面没有什么特别的

00:19:12.650 --> 00:19:17.280
只是十个测试

00:19:15.480 --> 00:19:20.070
已全部执行

00:19:17.280 --> 00:19:22.020
应用程序是像所有

00:19:20.070 --> 00:19:24.150
无关的东西

00:19:22.020 --> 00:19:26.130
与目录有关

00:19:24.150 --> 00:19:28.919
也被捆绑，当然

00:19:26.130 --> 00:19:30.090
检查这是一个缺点

00:19:28.919 --> 00:19:32.190
即使因为

00:19:30.090 --> 00:19:33.690
如果你现在打破某种

00:19:32.190 --> 00:19:35.549
像Spring Beam这样的依赖

00:19:33.690 --> 00:19:38.009
依赖或某物

00:19:35.549 --> 00:19:40.259
不相关的程序包，这些测试将失败

00:19:38.009 --> 00:19:42.840
因为因为那个权利所以

00:19:40.259 --> 00:19:45.779
不是它不是真的孤立，所以我们

00:19:42.840 --> 00:19:48.659
可以代替的是我们可以切换到

00:19:45.779 --> 00:19:50.969
添加模块测试注释不要介意

00:19:48.659 --> 00:19:52.769
验证程序自动落在这里

00:19:50.969 --> 00:19:55.200
再过一秒钟

00:19:52.769 --> 00:19:57.779
但我要重新运行测试， 

00:19:55.200 --> 00:20:03.389
那么您会看到略有不同

00:19:57.779 --> 00:20:05.789
输出，您将被告知，好的，我们

00:20:03.389 --> 00:20:09.690
开始对销售点进行模块测试

00:20:05.789 --> 00:20:11.399
目录geez屏幕分辨率是

00:20:09.690 --> 00:20:14.489
有点辛苦

00:20:11.399 --> 00:20:16.109
那是那个模块

00:20:14.489 --> 00:20:19.559
引导程序，所以它有一个逻辑名称

00:20:16.109 --> 00:20:22.200
有一个基本包装，我们检查所有

00:20:19.559 --> 00:20:24.119
那个里面的Spring bean 

00:20:22.200 --> 00:20:26.549
非常包装，并找出有关

00:20:24.119 --> 00:20:28.499
参考其他Spring bean ，我们

00:20:26.549 --> 00:20:30.899
还没找到，所以我们在这里说

00:20:28.499 --> 00:20:32.669
我们这里有一个Spring bean 

00:20:30.899 --> 00:20:34.950
这是一个公共的，这就是为什么我们有一个

00:20:32.669 --> 00:20:36.570
再加上一年的公共课，我可以回来

00:20:34.950 --> 00:20:38.549
一秒钟，我们有很多

00:20:36.570 --> 00:20:40.379
几个共享模块

00:20:38.549 --> 00:20:42.539
我已经设置的东西我不想

00:20:40.379 --> 00:20:44.460
基本上是一种机制

00:20:42.539 --> 00:20:47.190
从我们拥有的所有模块中

00:20:44.460 --> 00:20:49.229
可随时将其引导为

00:20:47.190 --> 00:20:51.149
好，而不必显式

00:20:49.229 --> 00:20:53.609
声明那些是可以的

00:20:51.149 --> 00:20:56.969
在添加模块中进行调整是一种表示法

00:20:53.609 --> 00:20:57.809
但让我们暂时将其保留下来

00:20:56.969 --> 00:21:00.210
为了简单

00:20:57.809 --> 00:21:04.289
所以它基本上会告诉您

00:21:00.210 --> 00:21:07.440
模块被引导，您会看到

00:21:04.289 --> 00:21:09.330
用户帐户模块引导核心

00:21:07.440 --> 00:21:11.219
模块，但引导并支持一个

00:21:09.330 --> 00:21:13.259
然后告诉您重新配置

00:21:11.219 --> 00:21:15.599
自动配置和实体

00:21:13.259 --> 00:21:19.169
扫描到那些包，那就是

00:21:15.599 --> 00:21:24.239
就像以前一样

00:21:19.169 --> 00:21:25.950
任何类似箭头的好处

00:21:24.239 --> 00:21:28.859
或引导错误

00:21:25.950 --> 00:21:31.769
并非由其他模块实际调用

00:21:28.859 --> 00:21:34.320
打破这个测试的权利就是

00:21:31.769 --> 00:21:39.600
差不多

00:21:34.320 --> 00:21:41.810
到目前为止一切顺利，让我们开始吧

00:21:39.600 --> 00:21:47.060
向前看一下

00:21:41.810 --> 00:21:49.080
盘点您在这里看到的是什么

00:21:47.060 --> 00:21:51.110
也许你们当中有些人已经意识到

00:21:49.080 --> 00:21:54.480
已经是我们有一个循环

00:21:51.110 --> 00:21:59.910
订单包之间的关系

00:21:54.480 --> 00:22:02.130
和库存，实际上是

00:21:59.910 --> 00:22:05.580
建筑违规，我们要去

00:22:02.130 --> 00:22:10.100
得到我们想要的报告

00:22:05.580 --> 00:22:12.470
尝试如果我们尝试引导

00:22:10.100 --> 00:22:15.680
库存测试

00:22:12.470 --> 00:22:15.680
我们去

00:22:16.360 --> 00:22:25.290
 [音乐] 

00:22:18.410 --> 00:22:27.590
那很奇怪，我应该失败，我希望

00:22:25.290 --> 00:22:27.590
它失败

00:22:28.720 --> 00:22:42.489
不，不好，我可能检查过

00:22:31.899 --> 00:22:48.489
错了一秒钟，是的，我迷路了

00:22:42.489 --> 00:22:51.159
我需要检查的历史

00:22:48.489 --> 00:22:52.539
我的光标在哪里，我需要这个

00:22:51.159 --> 00:22:58.690
签出正确的

00:22:52.539 --> 00:23:04.809
哦，很好，对了，不错

00:22:58.690 --> 00:23:07.450
什么是销售点命令状态

00:23:04.809 --> 00:23:10.200
我们需要检查一个，所以我

00:23:07.450 --> 00:23:10.200
对此感到抱歉

00:23:10.320 --> 00:23:15.669
你好吗

00:23:11.950 --> 00:23:17.320
好像我进去看看

00:23:15.669 --> 00:23:18.340
看起来应该还可以吗

00:23:17.320 --> 00:23:21.519
现在不同

00:23:18.340 --> 00:23:23.590
嗯，只是快速刷新，希望

00:23:21.519 --> 00:23:29.930
我希望一切

00:23:23.590 --> 00:23:33.500
打破预期，没有

00:23:29.930 --> 00:23:35.740
哦，是的，这不是应该的

00:23:33.500 --> 00:23:39.050
给你看，我们有这个验证

00:23:35.740 --> 00:23:41.030
自动设置为false 

00:23:39.050 --> 00:23:43.460
因为我有这个建筑

00:23:41.030 --> 00:23:45.380
违规行为始终存在

00:23:43.460 --> 00:23:47.600
实际在第一时间运行

00:23:45.380 --> 00:23:50.090
放在第一位还是不在第一位

00:23:47.600 --> 00:23:52.340
我必须禁用验证，所以如果

00:23:50.090 --> 00:23:54.610
我现在继续将其切换为

00:23:52.340 --> 00:23:57.200
这基本上使

00:23:54.610 --> 00:24:01.340
验证然后手指越过这个

00:23:57.200 --> 00:24:03.500
不应该失败，好吧，所以

00:24:01.340 --> 00:24:08.030
基本上说我们有一个

00:24:03.500 --> 00:24:10.190
库存之间的架构周期

00:24:08.030 --> 00:24:13.100
命令这是从哪里来的

00:24:10.190 --> 00:24:17.090
来自我们需要走的事实

00:24:13.100 --> 00:24:21.500
回到这里，我们的订单执行

00:24:17.090 --> 00:24:26.180
我基本上不得不打破它耶稣

00:24:21.500 --> 00:24:28.760
我不得不打破它来介绍这个

00:24:26.180 --> 00:24:31.940
违反当然是因为如果你喜欢

00:24:28.760 --> 00:24:34.640
我准备了这个应该有的场外

00:24:31.940 --> 00:24:36.170
不是吗，实际上不应该

00:24:34.640 --> 00:24:38.540
首先有违规行为

00:24:36.170 --> 00:24:40.760
但只是向您展示我想要的

00:24:38.540 --> 00:24:42.710
射击，所以我必须介绍一下

00:24:40.760 --> 00:24:46.160
这种事情在做什么

00:24:42.710 --> 00:24:49.640
我们积极完成订单

00:24:46.160 --> 00:24:51.440
调用清单以更新

00:24:49.640 --> 00:24:54.080
库存，您会看到该方法

00:24:51.440 --> 00:24:56.270
签名在这里接受命令

00:24:54.080 --> 00:24:58.010
库存生活在另一个

00:24:56.270 --> 00:25:00.590
其他包装，这意味着没有

00:24:58.010 --> 00:25:02.180
存货之间的周期性关系

00:25:00.590 --> 00:25:04.970
订购正确的订单需要了解

00:25:02.180 --> 00:25:07.160
它需要拥有的库存组件

00:25:04.970 --> 00:25:09.680
当我想引导

00:25:07.160 --> 00:25:12.020
订购需要的订单模块

00:25:09.680 --> 00:25:14.300
访问该库存光束，但在

00:25:12.020 --> 00:25:19.000
同时我们对

00:25:14.300 --> 00:25:19.000
在此方法中订购

00:25:20.690 --> 00:25:26.780
是的，就是那个确切的

00:25:25.160 --> 00:25:28.580
事情在这里，所以我们能做的就是

00:25:26.780 --> 00:25:31.880
为什么我基本上这就是为什么我已经

00:25:28.580 --> 00:25:36.290
签出另一个耶稣那个箭头

00:25:31.880 --> 00:25:43.960
是一种口香糖，我会退房

00:25:36.290 --> 00:25:43.960
再次提交签出并完成该工作

00:25:46.990 --> 00:25:55.700
现在很难去检查春天

00:25:52.850 --> 00:26:01.970
我们走了，是的，走了

00:25:55.700 --> 00:26:04.940
嗯，这让我耳目一新，为什么

00:26:01.970 --> 00:26:08.170
真正的枪，所以我固定了

00:26:04.940 --> 00:26:13.670
实施或那个问题

00:26:08.170 --> 00:26:16.960
使用的东西仅仅是

00:26:13.670 --> 00:26:20.030
之前在谈话中显示，所以我们有

00:26:16.960 --> 00:26:23.330
支持在以下位置发布应用程序事件

00:26:20.030 --> 00:26:25.400
Spring Spring 数据我们在dis 

00:26:23.330 --> 00:26:26.750
支持已经有一段时间了

00:26:25.400 --> 00:26:30.080
意味着我们可以改变

00:26:26.750 --> 00:26:32.270
实现实际上只是看

00:26:30.080 --> 00:26:35.840
这样的事情，所以而不是

00:26:32.270 --> 00:26:38.840
积极调用

00:26:35.840 --> 00:26:41.840
其他在其他模块中，我们只是葡萄干

00:26:38.840 --> 00:26:45.400
事件，我们通过使用

00:26:41.840 --> 00:26:47.780
 spring data 摘要聚合根

00:26:45.400 --> 00:26:50.270
注册事件的能力

00:26:47.780 --> 00:26:53.180
订单完成，然后发布

00:26:50.270 --> 00:26:56.570
事件到春季申请事件

00:26:53.180 --> 00:27:00.410
然后在这种情况下在这里调用的总线

00:26:56.570 --> 00:27:02.690
 ITA清单上的事件侦听器

00:27:00.410 --> 00:27:06.020
在这里订购这东西基本上

00:27:02.690 --> 00:27:08.390
事件监听器是它的触发器，为什么

00:27:06.020 --> 00:27:15.230
如此重要，让我回到

00:27:08.390 --> 00:27:18.110
滑盖，所以我们基本上更换了

00:27:15.230 --> 00:27:21.560
该组件对库存的依赖性

00:27:18.110 --> 00:27:24.590
与发布和事件以及

00:27:21.560 --> 00:27:27.410
只是听那个事件的清单

00:27:24.590 --> 00:27:30.860
这很重要，因为我们现在我们进行排序

00:27:27.410 --> 00:27:32.640
打破了依赖周期，我们

00:27:30.860 --> 00:27:35.010
不需要采取行动

00:27:32.640 --> 00:27:37.110
当我们运行订单时启动

00:27:35.010 --> 00:27:41.280
系统的权利，所以它或命令

00:27:37.110 --> 00:27:45.810
模块，让我们回到库存

00:27:41.280 --> 00:27:47.520
测试，现在应该可以在没有

00:27:45.810 --> 00:27:48.570
它确实有效，您已经看到了

00:27:47.520 --> 00:27:51.630
之前

00:27:48.570 --> 00:27:54.030
现在应该可以正常工作了，而不是报告

00:27:51.630 --> 00:27:56.700
违反了底线

00:27:54.030 --> 00:27:59.520
这有两个底线

00:27:56.700 --> 00:28:02.600
一个是你应该批判

00:27:59.520 --> 00:28:05.670
复习所有交叉模块

00:28:02.600 --> 00:28:06.450
组分注射，因为更多

00:28:05.670 --> 00:28:08.610
你有那个

00:28:06.450 --> 00:28:10.500
您实际需要的更多东西

00:28:08.610 --> 00:28:12.180
如果你想喜欢bootstrap 

00:28:10.500 --> 00:28:14.550
该单个模块，例如，如果您有一个

00:28:12.180 --> 00:28:16.050
假设订单对此具有依赖性

00:28:14.550 --> 00:28:17.670
库存，所以我们要运行，我们要

00:28:16.050 --> 00:28:21.270
自举命令，我们必须自举

00:28:17.670 --> 00:28:23.550
库存也一样

00:28:21.270 --> 00:28:25.050
连接变得更容易

00:28:23.550 --> 00:28:29.720
开始测试那个东西

00:28:25.050 --> 00:28:32.520
隔离，另一件事是

00:28:29.720 --> 00:28:35.250
这通常可以通过

00:28:32.520 --> 00:28:37.620
发布事件，甚至没有

00:28:35.250 --> 00:28:40.080
例如涉及任何种类的卡夫卡或

00:28:37.620 --> 00:28:42.060
跨流程事件发布

00:28:40.080 --> 00:28:46.620
只是使用它一个巨大的机制

00:28:42.060 --> 00:28:47.850
内部阿姨确实是第三个

00:28:46.620 --> 00:28:50.040
其实这就是我想要的

00:28:47.850 --> 00:28:52.560
提及是让我们看到你

00:28:50.040 --> 00:28:54.930
想知道如果

00:28:52.560 --> 00:28:59.160
您实际上引入了循环

00:28:54.930 --> 00:29:03.060
偶然地建立您的依赖

00:28:59.160 --> 00:29:05.190
基本上这样的测试

00:29:03.060 --> 00:29:08.280
揭示那个权利，所以不是他们

00:29:05.190 --> 00:29:14.850
被忽视通常是

00:29:08.280 --> 00:29:18.030
退化的原因

00:29:14.850 --> 00:29:18.840
系统20中的结构

00:29:18.030 --> 00:29:22.050
分钟还可以

00:29:18.840 --> 00:29:25.320
所以事情是这样的模块是

00:29:22.050 --> 00:29:27.930
基本了解和区分

00:29:25.320 --> 00:29:31.230
在三种类型的依赖之间

00:29:27.930 --> 00:29:33.150
今天我还没有真正找到

00:29:31.230 --> 00:29:35.280
重要的第三只猫或第四类

00:29:33.150 --> 00:29:36.840
如果您碰巧玩过它， 

00:29:35.280 --> 00:29:40.350
认为应该有东西应该

00:29:36.840 --> 00:29:42.570
改善了，请提供反馈

00:29:40.350 --> 00:29:44.400
并不总是很欣赏如此简单的类型

00:29:42.570 --> 00:29:48.460
依赖是

00:29:44.400 --> 00:29:51.970
就像我说的库存物品一样

00:29:48.460 --> 00:29:52.930
以产品为例简单

00:29:51.970 --> 00:29:55.090
类型依赖

00:29:52.930 --> 00:29:59.260
存在组件依赖性，所以我们

00:29:55.090 --> 00:30:01.510
分析在中声明的Spring bean 

00:29:59.260 --> 00:30:04.240
构造函数参数的模块

00:30:01.510 --> 00:30:08.130
是的，即使是现场注入，虽然

00:30:04.240 --> 00:30:10.690
那当然也被拒绝了，你

00:30:08.130 --> 00:30:13.810
打开验证或

00:30:10.690 --> 00:30:17.140
默认情况下启用，并且有事件

00:30:13.810 --> 00:30:19.240
和事件监听器，因为是事件

00:30:17.140 --> 00:30:21.910
聆听者通常与其他人完全一样

00:30:19.240 --> 00:30:24.960
如果您的库存是正确的

00:30:21.910 --> 00:30:27.280
听订单事件没有

00:30:24.960 --> 00:30:29.830
依赖之间没有模块依赖

00:30:27.280 --> 00:30:32.320
库存和订单，但它相当

00:30:29.830 --> 00:30:34.840
另一种方法是我们发布

00:30:32.320 --> 00:30:37.390
另一个事件

00:30:34.840 --> 00:30:39.130
听你想听的

00:30:37.390 --> 00:30:42.660
严格审查其他组件

00:30:39.130 --> 00:30:45.910
依赖，因为它们实际上使

00:30:42.660 --> 00:30:47.620
使您的测试生活相当长

00:30:45.910 --> 00:30:51.040
复杂，我将向您展示

00:30:47.620 --> 00:30:56.080
为什么通过实际尝试移动

00:30:51.040 --> 00:30:57.940
从测试到模量测试

00:30:56.080 --> 00:31:00.400
基础设施，所以我们想要我们想要

00:30:57.940 --> 00:31:04.680
单独测试这个东西

00:31:00.400 --> 00:31:07.330
我将向您展示模量如何

00:31:04.680 --> 00:31:10.450
报告有一些成分

00:31:07.330 --> 00:31:14.020
那不是自举的，那是

00:31:10.450 --> 00:31:22.360
运行测试所需的，所以我们开始吧

00:31:14.020 --> 00:31:25.720
订购正确的测试，所以这是

00:31:22.360 --> 00:31:28.810
是命令再次对其进行测试

00:31:25.720 --> 00:31:31.720
开始使用Spring 展台

00:31:28.810 --> 00:31:34.390
测试，以便您看到它们正在起作用，我们正在

00:31:31.720 --> 00:31:36.580
在这里使用抽象基类

00:31:34.390 --> 00:31:39.970
说摊位测试yada-yada-yada时

00:31:36.580 --> 00:31:43.630
现在又是自举

00:31:39.970 --> 00:31:50.680
完整的应用程序，所以我们

00:31:43.630 --> 00:31:53.390
想要更改为使用

00:31:50.680 --> 00:31:57.590
模块测试注解I 

00:31:53.390 --> 00:32:03.380
我可以进入额外的内容

00:31:57.590 --> 00:32:05.179
现在包括我们可以做到的

00:32:03.380 --> 00:32:07.220
跳过我认为我可以在

00:32:05.179 --> 00:32:11.049
第二，所以我现在要表达的是

00:32:07.220 --> 00:32:14.330
要引导订单模块，并

00:32:11.049 --> 00:32:18.170
我偶然地想引导

00:32:14.330 --> 00:32:20.390
目录，但让我们看看

00:32:18.170 --> 00:32:23.770
如果我们这样做就会发生，然后我得到

00:32:20.390 --> 00:32:23.770
一秒钟到达你

00:32:24.220 --> 00:32:32.030
所以打破了，我们可以取消

00:32:27.410 --> 00:32:34.850
那是因为G是的

00:32:32.030 --> 00:32:39.140
输出应该是应该告诉

00:32:34.850 --> 00:32:41.299
在第一个测试用例上就足够了

00:32:39.140 --> 00:32:45.049
你基本上得到的是没有

00:32:41.299 --> 00:32:49.280
合格的营业时间

00:32:45.049 --> 00:32:52.850
如果您记得在

00:32:49.280 --> 00:32:54.650
我曾经有一个幻灯片甲板

00:32:52.850 --> 00:32:56.360
依赖于业务时间模块

00:32:54.650 --> 00:32:58.940
这是通过

00:32:56.360 --> 00:33:01.790
私人最后的营业时间

00:32:58.940 --> 00:33:04.940
然后它基本上就被暴露了

00:33:01.790 --> 00:33:08.270
龙目岛在这里创建的构造函数

00:33:04.940 --> 00:33:10.549
实际上，我们已经建立了一个模块

00:33:08.270 --> 00:33:12.290
订单与

00:33:10.549 --> 00:33:14.510
时间包，这是营业时间

00:33:12.290 --> 00:33:15.919
生活，有一个春天的组成部分

00:33:14.510 --> 00:33:17.840
为此，默认情况下

00:33:15.919 --> 00:33:21.710
营业时间是EDD服务，所以

00:33:17.840 --> 00:33:24.200
这意味着我们当然不能自举

00:33:21.710 --> 00:33:26.330
孤立地订购测试，因为它

00:33:24.200 --> 00:33:28.610
需要那个特别的四季 bean 

00:33:26.330 --> 00:33:31.100
它需要其他模块来运行

00:33:28.610 --> 00:33:32.570
满足全局依赖图

00:33:31.100 --> 00:33:34.850
您现在可以做两件事

00:33:32.570 --> 00:33:36.559
首先是，实际上

00:33:34.850 --> 00:33:38.960
内置于 spring boot 

00:33:36.559 --> 00:33:42.010
开箱即用的是，您可以定义一个

00:33:38.960 --> 00:33:45.590
该特定组件的模拟bean 

00:33:42.010 --> 00:33:48.290
然后您可以运行它运行测试，然后

00:33:45.590 --> 00:33:51.320
你应该看到像东西

00:33:48.290 --> 00:33:53.120
工作正常，这实际上是我喜欢的

00:33:51.320 --> 00:33:56.720
那很多，因为你要做的是

00:33:53.120 --> 00:34:00.320
你说我想开始下订单

00:33:56.720 --> 00:34:02.630
模块，因为这是一个模块测试

00:34:00.320 --> 00:34:05.320
真正使我不得不做的工作

00:34:02.630 --> 00:34:06.880
煮这个成分和那个成分

00:34:05.320 --> 00:34:09.550
这个组件，所以你很清楚

00:34:06.880 --> 00:34:11.440
像模块一样描述

00:34:09.550 --> 00:34:13.000
外部依赖权和

00:34:11.440 --> 00:34:14.319
取决于你想做什么

00:34:13.000 --> 00:34:17.050
当然可以像然后继续

00:34:14.319 --> 00:34:19.240
设定营业时间以真正喜欢

00:34:17.050 --> 00:34:22.810
模拟互动或你有什么

00:34:19.240 --> 00:34:24.909
另一种方法不是

00:34:22.810 --> 00:34:30.849
另一种是，你可以继续

00:34:24.909 --> 00:34:34.240
说好吧，我可能不只是想要

00:34:30.849 --> 00:34:38.409
引导此特定模块，但所有

00:34:34.240 --> 00:34:41.589
该模块的直接依赖权

00:34:38.409 --> 00:34:45.339
所以现在这包括正在发生的事情

00:34:41.589 --> 00:34:52.470
它正在运行，现在我刚运行了

00:34:45.339 --> 00:34:52.470
这是怎么回事

00:34:53.370 --> 00:35:05.040
保存那是云计算的话，所以

00:35:02.820 --> 00:35:06.780
你在这里看到什么让我们看一下

00:35:05.040 --> 00:35:09.270
在耶和华的输出，因为现在

00:35:06.780 --> 00:35:14.640
变得有趣起来，所以我们发现

00:35:09.270 --> 00:35:18.900
订单模块有

00:35:14.640 --> 00:35:19.440
用户帐户和

00:35:18.900 --> 00:35:22.410
时间

00:35:19.440 --> 00:35:23.940
因此，通过此持久性订单经理， 

00:35:22.410 --> 00:35:25.680
可能有类似用户的东西

00:35:23.940 --> 00:35:27.750
客户经理注入了一个

00:35:25.680 --> 00:35:29.340
订单存储库，您可以看到那里

00:35:27.750 --> 00:35:31.740
都像一个受包保护的类

00:35:29.340 --> 00:35:35.160
那就是那里的那个小哦

00:35:31.740 --> 00:35:37.380
如果您还记得我们之前的加号，我们

00:35:35.160 --> 00:35:39.720
还额外包括目录

00:35:37.380 --> 00:35:42.360
引导阶段，然后实际上

00:35:39.720 --> 00:35:44.490
意味着这些引导这些模块

00:35:42.360 --> 00:35:45.840
实际上是自举

00:35:44.490 --> 00:35:50.040
对的所以你可以得到一个很好的

00:35:45.840 --> 00:35:52.410
概述实际运行的内容

00:35:50.040 --> 00:35:54.180
可以帮助您立即好起来

00:35:52.410 --> 00:35:56.280
业务模块实际业务

00:35:54.180 --> 00:36:02.820
在这种情况下，时间部分将具有

00:35:56.280 --> 00:36:04.770
已经可以运行了，如果怎么办

00:36:02.820 --> 00:36:06.570
如果默认情况下显示为独立

00:36:04.770 --> 00:36:09.450
基本上就像运行此模块一样

00:36:06.570 --> 00:36:11.610
只是，无论哪种参考

00:36:09.450 --> 00:36:14.340
您需要模拟的模块

00:36:11.610 --> 00:36:16.080
他们是做到这一点的一种方法

00:36:14.340 --> 00:36:17.460
可以使用直接依赖

00:36:16.080 --> 00:36:21.770
引导模式，就像

00:36:17.460 --> 00:36:24.390
包括一层以上或一层

00:36:21.770 --> 00:36:27.270
传递依存关系越来越多

00:36:24.390 --> 00:36:29.280
还有所有依赖模式

00:36:27.270 --> 00:36:31.770
基本上从整个模块图

00:36:29.280 --> 00:36:35.220
只是选择节点并运行

00:36:31.770 --> 00:36:38.790
下游需要的一切，但

00:36:35.220 --> 00:36:40.500
不是所有无关的东西都可以

00:36:38.790 --> 00:36:42.690
那也将很好地工作

00:36:40.500 --> 00:36:44.640
这几乎是

00:36:42.690 --> 00:36:46.710
最接近Spring 启动测试的地方

00:36:44.640 --> 00:36:48.690
但避免全部自举

00:36:46.710 --> 00:36:49.910
您不需要的其他模块

00:36:48.690 --> 00:36:53.130
这个案例

00:36:49.910 --> 00:36:57.380
好的，这就是测试支持

00:36:53.130 --> 00:36:59.690
我认为已经很有帮助

00:36:57.380 --> 00:37:03.300
可能需要一点习惯

00:36:59.690 --> 00:37:05.270
喜欢管理这些模块

00:37:03.300 --> 00:37:07.010
依赖关系

00:37:05.270 --> 00:37:09.020
首先当你当你没有

00:37:07.010 --> 00:37:10.940
就像习惯了那种东西

00:37:09.020 --> 00:37:14.060
感觉还可以，我不断

00:37:10.940 --> 00:37:16.610
我脸上的系统结构

00:37:14.060 --> 00:37:19.250
基本上或以前举行过

00:37:16.610 --> 00:37:22.820
我，但很整洁

00:37:19.250 --> 00:37:26.650
实际上避免引入任何形式的

00:37:22.820 --> 00:37:30.050
有害的有害依赖权

00:37:26.650 --> 00:37:34.760
我们在验证步骤中也做了什么

00:37:30.050 --> 00:37:40.030
是基于模块包

00:37:34.760 --> 00:37:42.800
确保它们无循环，因此

00:37:40.030 --> 00:37:45.650
这就是为什么为什么那那些为什么

00:37:42.800 --> 00:37:48.050
那些没有那个的引导

00:37:45.650 --> 00:37:51.080
自动验证等于假标志

00:37:48.050 --> 00:37:53.540
首先失败了，那

00:37:51.080 --> 00:37:57.020
实际上给你很多像

00:37:53.540 --> 00:38:00.470
相信自己有一种健康

00:37:57.020 --> 00:38:02.090
结构化模块设置是因为

00:38:00.470 --> 00:38:05.270
如果那里没有循环

00:38:02.090 --> 00:38:06.710
像有向无环图，而你

00:38:05.270 --> 00:38:09.080
有点知道你会有叶子

00:38:06.710 --> 00:38:12.020
模块，您将拥有根模块

00:38:09.080 --> 00:38:13.640
那将取决于其他人，所以

00:38:12.020 --> 00:38:16.910
如果您有一个机会

00:38:13.640 --> 00:38:18.440
那么无周期的模块布置

00:38:16.910 --> 00:38:20.120
您的系统相当不错

00:38:18.440 --> 00:38:22.700
首先没有任何结构

00:38:20.120 --> 00:38:25.540
您定义显式依赖项，并且

00:38:22.700 --> 00:38:28.280
你还好吗

00:38:25.540 --> 00:38:30.950
还有更多我们可以分类的东西

00:38:28.280 --> 00:38:33.260
其他模块的隐藏组件

00:38:30.950 --> 00:38:34.550
您可以定义，假设这是API 

00:38:33.260 --> 00:38:37.520
包这是一个实现

00:38:34.550 --> 00:38:43.640
我想跳过的包裹

00:38:37.520 --> 00:38:45.290
现在只是因为保存一个

00:38:43.640 --> 00:38:50.480
有点时间，想去点什么

00:38:45.290 --> 00:38:53.060
我觉得很有趣

00:38:50.480 --> 00:38:57.170
文档方面，因为通常

00:38:53.060 --> 00:39:00.410
你从那组盒子开始

00:38:57.170 --> 00:39:02.630
在PowerPoint卡座上和之后

00:39:00.410 --> 00:39:07.160
只是通过某种方式将其放入代码中

00:39:02.630 --> 00:39:10.150
以及什么时候

00:39:07.160 --> 00:39:10.150
进化

00:39:10.680 --> 00:39:15.569
跟上我很难跟上

00:39:12.660 --> 00:39:16.849
文档是最新的，如果

00:39:15.569 --> 00:39:18.930
假设您介绍了另一个

00:39:16.849 --> 00:39:21.930
从一个模块到

00:39:18.930 --> 00:39:24.329
另一个，事情就像

00:39:21.930 --> 00:39:26.849
所有我们得到的都是这种结构

00:39:24.329 --> 00:39:28.529
分析并没有做太多事情

00:39:26.849 --> 00:39:30.960
该应用程序，除了更改那个

00:39:28.529 --> 00:39:32.999
注释，我们可以使用

00:39:30.960 --> 00:39:36.390
你的结构信息

00:39:32.999 --> 00:39:39.059
提供隐式提供

00:39:36.390 --> 00:39:42.619
像反映了

00:39:39.059 --> 00:39:45.960
系统权限的实际状态和

00:39:42.619 --> 00:39:49.230
那里只有一个很小的API 

00:39:45.960 --> 00:39:52.650
您可以用来创建这些

00:39:49.230 --> 00:39:57.660
通常在测试中再次绘制图表， 

00:39:52.650 --> 00:40:01.230
看起来像这样我可以

00:39:57.660 --> 00:40:04.200
把它拉起来，所以你再说一遍

00:40:01.230 --> 00:40:06.420
继续，请分析模块

00:40:04.200 --> 00:40:09.900
结构，然后您使用该文档

00:40:06.420 --> 00:40:11.789
模块，还有一些

00:40:09.900 --> 00:40:14.519
您可以定义的选项

00:40:11.789 --> 00:40:19.589
进入图表中不应该的， 

00:40:14.519 --> 00:40:21.420
然后只有一个很小的

00:40:19.589 --> 00:40:23.970
这里的方法基本上说好吧

00:40:21.420 --> 00:40:29.569
将所有模块转储为工厂UML 

00:40:23.970 --> 00:40:33.839
图或只是采取每个模块和

00:40:29.569 --> 00:40:36.269
为每种模块方式创建图表

00:40:33.839 --> 00:40:38.880
您为每个模块说一个图表

00:40:36.269 --> 00:40:42.480
这里的那些实际上包括

00:40:38.880 --> 00:40:46.739
基本上像怀疑的模块

00:40:42.480 --> 00:40:48.569
只是其中包含的图

00:40:46.739 --> 00:40:50.220
所有传入的依赖项

00:40:48.569 --> 00:40:52.380
特定的模块和所有传出的

00:40:50.220 --> 00:40:54.779
依赖关系，基本上就是这样

00:40:52.380 --> 00:40:56.609
在焦点上，像是什么联系

00:40:54.779 --> 00:40:58.499
该模块位于什么环境中

00:40:56.609 --> 00:40:59.999
前者在哪里

00:40:58.499 --> 00:41:03.779
基本上厨房洗碗

00:40:59.999 --> 00:41:05.249
并按照您在

00:41:03.779 --> 00:41:06.960
我们就像把它们写出来的项目

00:41:05.249 --> 00:41:09.359
您当然可以定义这些东西在哪里

00:41:06.960 --> 00:41:11.400
将要写什么文件什么

00:41:09.359 --> 00:41:15.839
文件名模式是什么，但是

00:41:11.400 --> 00:41:17.970
最终这些东西最终植入

00:41:15.839 --> 00:41:19.910
我通常建议的UML模块

00:41:17.970 --> 00:41:22.970
纳入asciidoctor 

00:41:19.910 --> 00:41:24.680
文档，然后我们就像

00:41:22.970 --> 00:41:27.350
这样的东西然后正确的是

00:41:24.680 --> 00:41:31.070
有点像是

00:41:27.350 --> 00:41:33.740
订单模块图

00:41:31.070 --> 00:41:36.320
成分，并再次与众不同

00:41:33.740 --> 00:41:38.840
像杯子一样依赖

00:41:36.320 --> 00:41:41.150
类型说用户，用户

00:41:38.840 --> 00:41:43.730
依赖类型基本上是Spring 

00:41:41.150 --> 00:41:46.340
组件被引用一切

00:41:43.730 --> 00:41:49.700
其他取决于只是一种

00:41:46.340 --> 00:41:53.450
依赖也有事件在

00:41:49.700 --> 00:41:59.030
结束，整体图也

00:41:53.450 --> 00:42:02.440
显示监听依赖

00:41:59.030 --> 00:42:04.550
就像你看到的那样

00:42:02.440 --> 00:42:06.920
这基本上就是我们所要

00:42:04.550 --> 00:42:08.990
有点像重构当我们

00:42:06.920 --> 00:42:11.230
基本上消除了破损

00:42:08.990 --> 00:42:14.630
被引入是为了

00:42:11.230 --> 00:42:17.090
显示这些东西，让我们看看

00:42:14.630 --> 00:42:20.240
故意破坏，所以

00:42:17.090 --> 00:42:23.030
假设您喜欢的东西

00:42:20.240 --> 00:42:25.430
现有代码安排免费

00:42:23.030 --> 00:42:31.940
基本上是一种整洁的我

00:42:25.430 --> 00:42:34.520
认为没事，那么什么样的背景

00:42:31.940 --> 00:42:35.960
现在是否存在模块列表，因为

00:42:34.520 --> 00:42:39.620
他们是这不是第一次

00:42:35.960 --> 00:42:41.570
有人试图放一些结构

00:42:39.620 --> 00:42:43.520
在这些新系统中就位

00:42:41.570 --> 00:42:47.210
您可以开始的另一种选择

00:42:43.520 --> 00:42:49.280
与是多个文物，这意味着我

00:42:47.210 --> 00:42:53.470
可以继续，并可能已经创造了一个

00:42:49.280 --> 00:42:53.470
适用于所有这些个人的Maven模块

00:42:53.620 --> 00:42:59.000
正确的业务模块，然后拥有

00:42:56.660 --> 00:43:02.480
定义了我惊人的依赖

00:42:59.000 --> 00:43:04.970
依赖描述符，然后有

00:43:02.480 --> 00:43:06.830
或使用它来基本控制

00:43:04.970 --> 00:43:10.640
依赖，因为甚至

00:43:06.830 --> 00:43:12.590
已经防止循环依赖

00:43:10.640 --> 00:43:14.600
在模块之间，这样很整洁

00:43:12.590 --> 00:43:16.790
对的，那本来是

00:43:14.600 --> 00:43:18.920
很好的替代方法

00:43:16.790 --> 00:43:21.910
你可以做到，你仍然可以做到

00:43:18.920 --> 00:43:27.350
即使有模数，我们也不在乎

00:43:21.910 --> 00:43:29.390
这些东西都是人造的

00:43:27.350 --> 00:43:30.330
重要的是你上课的路径

00:43:29.390 --> 00:43:31.740
看起来像

00:43:30.330 --> 00:43:34.110
对的包裹就是包裹

00:43:31.740 --> 00:43:37.800
在您的课程计划中进行结构调整，我们

00:43:34.110 --> 00:43:40.200
有点检查，这也很好

00:43:37.800 --> 00:43:42.300
是我可以实际测试一个

00:43:40.200 --> 00:43:44.430
孤立模块，因为我有

00:43:42.300 --> 00:43:47.130
那里的一切就是

00:43:44.430 --> 00:43:49.530
我需要引入其他模块时

00:43:47.130 --> 00:43:51.180
当我拉入

00:43:49.530 --> 00:43:53.280
订单测试中的目录模块

00:43:51.180 --> 00:43:55.200
因为我想设置一些产品

00:43:53.280 --> 00:43:56.790
实际输入订单并

00:43:55.200 --> 00:43:58.500
这变得有点复杂，因为

00:43:56.790 --> 00:44:01.170
模块中的依存关系安排

00:43:58.500 --> 00:44:03.270
通常是静态权利，所以您

00:44:01.170 --> 00:44:04.920
一遍又一遍地宣布

00:44:03.270 --> 00:44:08.280
测试有点必须忍受

00:44:04.920 --> 00:44:11.570
编曲，实际上是

00:44:08.280 --> 00:44:14.310
还有两个缺点

00:44:11.570 --> 00:44:15.930
每个业务包都有一个模块I 

00:44:14.310 --> 00:44:18.900
最终会是什么

00:44:15.930 --> 00:44:20.730
十二个主要模块和十二个pom文件

00:44:18.900 --> 00:44:23.280
那种彼此相关

00:44:20.730 --> 00:44:27.410
我去过一个项目，甚至

00:44:23.280 --> 00:44:30.630
简单的模块设置将以36结尾

00:44:27.410 --> 00:44:32.820
一些Maven模块，因此可以是

00:44:30.630 --> 00:44:34.680
有点不知所措，所以为什么不保持

00:44:32.820 --> 00:44:40.140
他们在一起，因为我们要

00:44:34.680 --> 00:44:42.450
无论如何立即部署它们

00:44:40.140 --> 00:44:44.340
喜欢尝试维护

00:44:42.450 --> 00:44:46.860
结构以不同的方式及其作用

00:44:44.340 --> 00:44:48.810
也意味着不同于内部

00:44:46.860 --> 00:44:51.840
结构突然变得可见

00:44:48.810 --> 00:44:53.790
给外面的人，因为

00:44:51.840 --> 00:44:55.440
罐子可能被发布到

00:44:53.790 --> 00:44:57.360
一些行家回购权，所以别人

00:44:55.440 --> 00:44:59.640
试图用你的

00:44:57.360 --> 00:45:02.820
然后必须要做的软件

00:44:59.640 --> 00:45:07.530
基本上聚在一起并选择一个

00:45:02.820 --> 00:45:09.090
几个指控一起

00:45:07.530 --> 00:45:11.190
您可以尝试的是Java 

00:45:09.090 --> 00:45:12.840
我认为甚至有模块系统

00:45:11.190 --> 00:45:16.680
关于它的谈话我以后要看

00:45:12.840 --> 00:45:19.320
今天效果还不错

00:45:16.680 --> 00:45:22.290
我发现有一些缺点

00:45:19.320 --> 00:45:24.410
尤其是对于

00:45:22.290 --> 00:45:29.100
这种东西

00:45:24.410 --> 00:45:32.310
 Java模块从根本上假设

00:45:29.100 --> 00:45:33.510
每个模块都有一个工件，所以

00:45:32.310 --> 00:45:35.940
你不可能有多个

00:45:33.510 --> 00:45:39.390
工件中的模块至少正确

00:45:35.940 --> 00:45:41.070
现在我把这个放在

00:45:39.390 --> 00:45:42.990
在邮件列表中，他们已经

00:45:41.070 --> 00:45:45.660
看着它可能不是

00:45:42.990 --> 00:45:47.640
他们需要什么，因为记住Java 

00:45:45.660 --> 00:45:51.210
模块系统实际上是发明的

00:45:47.640 --> 00:45:53.820
能够正确构建JDK 

00:45:51.210 --> 00:45:56.010
至少现在不是我的意思

00:45:53.820 --> 00:45:58.140
每个人都认为这有两件事

00:45:56.010 --> 00:46:00.390
 Java模块系统应该是

00:45:58.140 --> 00:46:02.280
用于您的应用程序就是

00:46:00.390 --> 00:46:04.410
那不是它原本的目的

00:46:02.280 --> 00:46:07.410
至少不是最初的，我可以看到

00:46:04.410 --> 00:46:10.170
其他一些类似的事情

00:46:07.410 --> 00:46:11.640
这些基本上是进入

00:46:10.170 --> 00:46:14.330
如果您真的想

00:46:11.640 --> 00:46:16.140
将其带入现实世界的应用程序

00:46:14.330 --> 00:46:19.400
打开关键字的语义是

00:46:16.140 --> 00:46:21.690
那是一些反思的东西，因为

00:46:19.400 --> 00:46:23.910
你基本上有一个包装，或

00:46:21.690 --> 00:46:25.590
基本声明API的软件包

00:46:23.910 --> 00:46:29.250
但没有细粒度的控制

00:46:25.590 --> 00:46:31.470
过度暴露的东西，所以人们

00:46:29.250 --> 00:46:34.260
开始制作单独的包装， 

00:46:31.470 --> 00:46:36.630
公共类型，如果需要的话

00:46:34.260 --> 00:46:39.660
可以随时获得有关该细节的信息

00:46:36.630 --> 00:46:42.780
以后抓我，没有支持

00:46:39.660 --> 00:46:45.450
动态组装模块

00:46:42.780 --> 00:46:50.100
测试正确，所以这就是

00:46:45.450 --> 00:46:51.900
我之前描述过的东西

00:46:50.100 --> 00:46:56.640
可以使用事物的外部工具

00:46:51.900 --> 00:46:58.670
就像JQ辅助超声检查图J取决于

00:46:56.640 --> 00:47:01.470
我建议您这样做，因为

00:46:58.670 --> 00:47:03.360
特别是我对JQ有点熟悉

00:47:01.470 --> 00:47:06.420
助手，这是一个工具

00:47:03.360 --> 00:47:08.130
基本上把你所有的拉

00:47:06.420 --> 00:47:10.140
代码库到新的伪造图中

00:47:08.130 --> 00:47:11.880
数据库，并允许您查询

00:47:10.140 --> 00:47:14.910
数据库并通过查询

00:47:11.880 --> 00:47:17.190
实际上定义了难以置信的规则

00:47:14.910 --> 00:47:19.560
功能强大，当然不是

00:47:17.190 --> 00:47:22.020
会压缩到源代码，但是

00:47:19.560 --> 00:47:24.090
也可以检查您的提交并

00:47:22.020 --> 00:47:26.910
关联这些东西，所以有很多

00:47:24.090 --> 00:47:29.550
这些工具的力量

00:47:26.910 --> 00:47:33.060
通常运行起来比较昂贵，他们

00:47:29.550 --> 00:47:35.250
通常在构建权期间运行

00:47:33.060 --> 00:47:37.980
如果我在构建过程中运行东西

00:47:35.250 --> 00:47:40.920
辛苦或者如果我延迟这些检查

00:47:37.980 --> 00:47:42.780
构建没有办法我可以使用它

00:47:40.920 --> 00:47:46.050
我可以的结构信息

00:47:42.780 --> 00:47:48.210
也许从测试用例中受益

00:47:46.050 --> 00:47:50.820
对，所以我想早一点

00:47:48.210 --> 00:47:53.070
理想情况下，我希望看到反馈

00:47:50.820 --> 00:47:55.260
那些由

00:47:53.070 --> 00:47:58.530
关系，甚至通过编译器

00:47:55.260 --> 00:48:01.500
那是一个很酷的工具，叫做侦探一

00:47:58.530 --> 00:48:05.730
认为在古纳早上他们会建造一个

00:48:01.500 --> 00:48:08.210
基于JSON文件排序的处理器

00:48:05.730 --> 00:48:10.560
我们所做的类似事情

00:48:08.210 --> 00:48:12.270
这不是像强加那些

00:48:10.560 --> 00:48:14.370
打包的约束，因此您必须

00:48:12.270 --> 00:48:17.280
多一点，但同时

00:48:14.370 --> 00:48:19.470
基本上导致编译器或获取

00:48:17.280 --> 00:48:23.160
您的应用中的红色下划线

00:48:19.470 --> 00:48:24.620
在您的编辑器中已经

00:48:23.160 --> 00:48:27.660
要研究的东西是

00:48:24.620 --> 00:48:30.180
就像我说的那样，杰克是你的助手

00:48:27.660 --> 00:48:33.440
你可以用它做更多的事情

00:48:30.180 --> 00:48:36.390
我基本上尝试使用模数

00:48:33.440 --> 00:48:39.210
与开发流程的距离我

00:48:36.390 --> 00:48:41.010
意思是你什么时候真正得到

00:48:39.210 --> 00:48:43.620
反馈，这意味着什么

00:48:41.010 --> 00:48:45.480
像

00:48:43.620 --> 00:48:47.850
正确执行某些事情，这样

00:48:45.480 --> 00:48:49.860
首先是编译器第二

00:48:47.850 --> 00:48:51.780
第二个遥远的东西是测试和

00:48:49.860 --> 00:48:55.770
第三个遥远的东西是这是构建

00:48:51.780 --> 00:48:57.960
系统正确，所以三个迭代

00:48:55.770 --> 00:49:00.570
将上下文映射到包的约定

00:48:57.960 --> 00:49:02.730
这使我们能够对

00:49:00.570 --> 00:49:06.270
模块您的模块化结构

00:49:02.730 --> 00:49:08.430
系统，我们可以在此基础上建立支持

00:49:06.270 --> 00:49:11.400
最重要的是实际引导

00:49:08.430 --> 00:49:13.560
系统的更多部分

00:49:11.400 --> 00:49:15.270
就好像更复杂

00:49:13.560 --> 00:49:18.060
包装安排权安排

00:49:15.270 --> 00:49:21.530
与的软件包具有内部

00:49:18.060 --> 00:49:24.630
有关的软件包和访问规则，以及

00:49:21.530 --> 00:49:27.390
你实际上可以继续推导

00:49:24.630 --> 00:49:28.890
从中得到的文档

00:49:27.390 --> 00:49:31.770
您隐式排序的结构

00:49:28.890 --> 00:49:34.170
创建了项目网站

00:49:31.770 --> 00:49:37.620
 github，我有两个演讲

00:49:34.170 --> 00:49:41.330
建议类似的讨论

00:49:37.620 --> 00:49:44.250
想法模块化整体是西蒙·布朗

00:49:41.330 --> 00:49:48.900
大概我的意思是我不必讲话

00:49:44.250 --> 00:49:50.880
关于他的讨论太多了

00:49:48.900 --> 00:49:53.100
按组件包装的想法主要在

00:49:50.880 --> 00:49:55.260
那里说雄伟的模块化模型是我

00:49:53.100 --> 00:49:58.349
必须添加来自

00:49:55.260 --> 00:49:58.349
 [音乐] 

00:49:58.510 --> 00:50:10.010
你看到我不，不，不，这些背后的家伙

00:50:06.770 --> 00:50:13.820
这个数据库的东西飞起来

00:50:10.010 --> 00:50:14.210
谁是最合适的轻量级对不起

00:50:13.820 --> 00:50:17.900
关于那个

00:50:14.210 --> 00:50:19.760
嗯，点击链接谢谢

00:50:17.900 --> 00:50:21.440
您会发现重构SIS 

00:50:19.760 --> 00:50:25.839
系统的系统有几个

00:50:21.440 --> 00:50:28.250
录音就是我的话题

00:50:25.839 --> 00:50:29.990
基本上是动人的想法

00:50:28.250 --> 00:50:33.290
我刚刚展示过您在

00:50:29.990 --> 00:50:35.839
就是几个地方

00:50:33.290 --> 00:50:37.820
我会一直待到明天下午

00:50:35.839 --> 00:50:40.310
感谢您的关注，如果您有

00:50:37.820 --> 00:50:42.670
发生任何问题都乐于回答

00:50:40.310 --> 00:50:42.670
他们

00:50:43.350 --> 00:50:52.020
 [掌声] 

00:50:45.640 --> 00:50:52.020
 [音乐] 

