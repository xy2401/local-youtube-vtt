WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.900 --> 00:00:07.980
 [音乐] 

00:00:08.240 --> 00:00:13.410
好吧，我想是时候开始了，我知道

00:00:11.640 --> 00:00:15.599
这是最后一次会议，谢谢你

00:00:13.410 --> 00:00:18.270
来参加这个演讲，我很高兴

00:00:15.599 --> 00:00:20.430
这么多人听我的演讲， 

00:00:18.270 --> 00:00:23.150
如您所见，我今天将谈论

00:00:20.430 --> 00:00:25.860
如何在分布式中进行调度

00:00:23.150 --> 00:00:27.090
系统，尤其是

00:00:25.860 --> 00:00:28.859
使用编写的应用程序

00:00:27.090 --> 00:00:30.810
Spring 

00:00:28.859 --> 00:00:32.969
我的名字叫马拉喀什犯罪，来自

00:00:30.810 --> 00:00:36.149
波兰，但目前我在为

00:00:32.969 --> 00:00:38.339
 26在柏林，我们附近还有办公室

00:00:36.149 --> 00:00:40.319
在巴塞罗那，在

00:00:38.339 --> 00:00:42.300
维也纳，因此公司发展迅速

00:00:40.319 --> 00:00:44.699
但我们当然也做一些

00:00:42.300 --> 00:00:46.670
有趣的技术问题，这是

00:00:44.699 --> 00:00:49.229
我要介绍的主题之一

00:00:46.670 --> 00:00:53.219
所以让我们开始看看是什么

00:00:49.229 --> 00:00:56.039
今天的议程，所以一开始我

00:00:53.219 --> 00:00:58.049
将谈论有关的背景

00:00:56.039 --> 00:01:01.440
我们想要什么样的过程

00:00:58.049 --> 00:01:04.409
解决以及为什么我们引入这一

00:01:01.440 --> 00:01:06.540
你很快会看到什么然后我会显示

00:01:04.409 --> 00:01:08.700
两种不同的方法，因为我们

00:01:06.540 --> 00:01:10.950
认为通常问题应该

00:01:08.700 --> 00:01:13.050
以进化的方式解决，所以我们

00:01:10.950 --> 00:01:14.910
通常尝试一些简单的事情，我们检查是否

00:01:13.050 --> 00:01:16.830
它是否有效，然后我们继续

00:01:14.910 --> 00:01:19.980
如果需要改进

00:01:16.830 --> 00:01:22.620
在此期间以及最后

00:01:19.980 --> 00:01:24.540
我将显示一些结果

00:01:22.620 --> 00:01:27.300
工作什么没有，什么是

00:01:24.540 --> 00:01:30.810
结论和潜在的方法是什么

00:01:27.300 --> 00:01:35.760
改善事情，让我们跳进

00:01:30.810 --> 00:01:38.070
我们之前试图解决的问题

00:01:35.760 --> 00:01:41.760
实际上进入整体

00:01:38.070 --> 00:01:45.060
我想告诉你的问题让我

00:01:41.760 --> 00:01:47.159
简要介绍如何

00:01:45.060 --> 00:01:50.880
我们公司的系统基本上是

00:01:47.159 --> 00:01:53.610
发达，以及我们如何尝试这样做

00:01:50.880 --> 00:01:55.710
在过去的开始

00:01:53.610 --> 00:01:57.840
我们一直在做的公司的一生

00:01:55.710 --> 00:01:59.880
大多数事情与同步

00:01:57.840 --> 00:02:02.010
通讯如此传统的HTTP 

00:01:59.880 --> 00:02:07.080
沟通，但我们知道这是

00:02:02.010 --> 00:02:09.629
不是我们也尝试做的最好方法

00:02:07.080 --> 00:02:12.959
交了很多流量，所以我们做到了

00:02:09.629 --> 00:02:14.140
与事件有关的事情，这就是为什么我们

00:02:12.959 --> 00:02:16.270
有实习生

00:02:14.140 --> 00:02:18.550
我们公司的教育

00:02:16.270 --> 00:02:22.360
我是说我们之间发送事件

00:02:18.550 --> 00:02:24.220
服务之间的关系不是

00:02:22.360 --> 00:02:25.959
当然总是可能的，所以我们仍然

00:02:24.220 --> 00:02:28.600
一些同步的方式来处理

00:02:25.959 --> 00:02:31.600
特别是如果流程像业务

00:02:28.600 --> 00:02:34.030
案例要求有必要

00:02:31.600 --> 00:02:36.640
立即收到回应，但如果

00:02:34.030 --> 00:02:38.640
你可以在经销商那里做一些事情

00:02:36.640 --> 00:02:42.520
经销商然后这个，但这基本上是

00:02:38.640 --> 00:02:47.650
使用事件是最好的方式

00:02:42.520 --> 00:02:49.480
还有一个额外的好处

00:02:47.650 --> 00:02:52.360
同步通讯正在处理中

00:02:49.480 --> 00:02:54.970
现在更可靠了，因为我们

00:02:52.360 --> 00:02:57.730
使用AWS及其解决方案有四个

00:02:54.970 --> 00:03:00.130
溪流被称为金丝雀

00:02:57.730 --> 00:03:01.810
这保证了每个事件都会

00:03:00.130 --> 00:03:05.980
至少一次交付给服务

00:03:01.810 --> 00:03:07.810
所以这意味着你有点推

00:03:05.980 --> 00:03:10.420
对不同的责任

00:03:07.810 --> 00:03:12.610
服务于另一种解决方案， 

00:03:10.420 --> 00:03:14.440
他们保证您不会

00:03:12.610 --> 00:03:16.500
失去的东西并不总是

00:03:14.440 --> 00:03:20.140
在同步通信中

00:03:16.500 --> 00:03:22.420
我也喜欢

00:03:20.140 --> 00:03:27.160
事件交流之所以提供，是因为

00:03:22.420 --> 00:03:29.260
现在我们可以在一些屏幕上

00:03:27.160 --> 00:03:32.730
我们可以显示多少个事件

00:03:29.260 --> 00:03:37.120
将由生物服务处理， 

00:03:32.730 --> 00:03:40.299
例如如何服务

00:03:37.120 --> 00:03:41.950
他正在快速处理通讯，所以

00:03:40.299 --> 00:03:43.840
如果它落后于

00:03:41.950 --> 00:03:46.900
沟通落后于

00:03:43.840 --> 00:03:49.090
处理事件，因此

00:03:46.900 --> 00:03:51.160
请记住，这就是我们如何尝试

00:03:49.090 --> 00:03:54.040
解决我们公司里的事情

00:03:51.160 --> 00:03:58.480
在我们一直遇到的问题上

00:03:54.040 --> 00:04:00.100
在这里您可以看到的简化视图

00:03:58.480 --> 00:04:02.290
我们试图解决的问题

00:04:00.100 --> 00:04:04.209
所以从左侧开始

00:04:02.290 --> 00:04:08.440
流，所以在我们的情况下，这是一条运河

00:04:04.209 --> 00:04:11.040
流，我们有我们有一些

00:04:08.440 --> 00:04:13.720
来自流的事件

00:04:11.040 --> 00:04:16.299
现在让我们考虑一下

00:04:13.720 --> 00:04:18.280
摘要事件被接收

00:04:16.299 --> 00:04:19.780
应用程序，我们有一个组件

00:04:18.280 --> 00:04:22.120
我们称为流的应用程序

00:04:19.780 --> 00:04:24.880
消费者，它基本上是阅读商品

00:04:22.120 --> 00:04:26.460
从信息流中过滤出

00:04:24.880 --> 00:04:28.780
发生的事件

00:04:26.460 --> 00:04:30.670
服务的重要父亲，因为

00:04:28.780 --> 00:04:33.130
他们当然可以是不同的事件

00:04:30.670 --> 00:04:36.190
对我们来说不重要

00:04:33.130 --> 00:04:38.590
应用程序，我们所做的就是我们

00:04:36.190 --> 00:04:40.240
将每个事件存储到数据库中

00:04:38.590 --> 00:04:42.310
服务的每个重要事件

00:04:40.240 --> 00:04:43.750
存储到数据库中，您可以问为什么

00:04:42.310 --> 00:04:47.140
在这样做实际上是为什么数据库

00:04:43.750 --> 00:04:49.470
需要，我们认为阅读

00:04:47.140 --> 00:04:51.670
流应该尽可能快

00:04:49.470 --> 00:04:54.070
存储我们想要的所有事件

00:04:51.670 --> 00:04:56.710
进入数据库的过程

00:04:54.070 --> 00:04:58.690
阅读的消费者的过程

00:04:56.710 --> 00:05:02.020
流中的事件

00:04:58.690 --> 00:05:04.660
快速，如果有逻辑的话

00:05:02.020 --> 00:05:06.880
需要处理事件

00:05:04.660 --> 00:05:08.470
取下来，在这种情况下，如果我们存储

00:05:06.880 --> 00:05:11.590
它进入数据库通常是超级

00:05:08.470 --> 00:05:13.630
很快，流消费者就可以移动

00:05:11.590 --> 00:05:17.080
转发并可以处理每个事件

00:05:13.630 --> 00:05:20.200
所以这就是我们改进改进的方式

00:05:17.080 --> 00:05:23.260
我们如何处理流的方式

00:05:20.200 --> 00:05:25.330
现在我们可以将数据存储到

00:05:23.260 --> 00:05:26.830
数据库，如果相同的事件将

00:05:25.330 --> 00:05:29.680
第二次收到可以

00:05:26.830 --> 00:05:31.930
发生了，那么现在我们有一个真实的来源

00:05:29.680 --> 00:05:34.420
好的，我们不需要存储此事件

00:05:31.930 --> 00:05:36.360
再次处理它，我们可以继续

00:05:34.420 --> 00:05:39.760
流的含义和

00:05:36.360 --> 00:05:42.190
右侧的第二部分有一个

00:05:39.760 --> 00:05:43.630
调度程序，所以有这项工作

00:05:42.190 --> 00:05:45.580
在此期间，我将主要谈论

00:05:43.630 --> 00:05:47.140
谈论我们从

00:05:45.580 --> 00:05:49.750
数据库存储的事件

00:05:47.140 --> 00:05:51.340
在那里，我们处理它们也许执行

00:05:49.750 --> 00:05:52.810
现在执行一些逻辑

00:05:51.340 --> 00:05:54.130
执行逻辑，因为我们没有

00:05:52.810 --> 00:05:56.950
在流媒体消费者上执行此操作

00:05:54.130 --> 00:05:58.900
因为思想很快，什么时候

00:05:56.950 --> 00:06:02.320
我们处理这个，我们需要存储这个

00:05:58.900 --> 00:06:04.390
基本上就是进入外部服务

00:06:02.320 --> 00:06:05.890
这是用例事件

00:06:04.390 --> 00:06:06.780
并将其存储到外部

00:06:05.890 --> 00:06:09.880
服务

00:06:06.780 --> 00:06:12.430
让我们来看看如何

00:06:09.880 --> 00:06:14.380
在 Spring 应用中完成，所以大概

00:06:12.430 --> 00:06:17.170
这是你们大多数人的代码的一部分

00:06:14.380 --> 00:06:19.030
已经写过或者至少看过了

00:06:17.170 --> 00:06:21.900
我们有一个简单的服务，我们用

00:06:19.030 --> 00:06:25.690
我们Spring 上的符号组件可以

00:06:21.900 --> 00:06:27.310
可以在其中找到服务

00:06:25.690 --> 00:06:29.800
注入不同的组件

00:06:27.310 --> 00:06:31.570
而且我们有一种方法可以很好地运行

00:06:29.800 --> 00:06:35.140
经常处理事件

00:06:31.570 --> 00:06:37.690
在数据库中，我们可以对其进行标记

00:06:35.140 --> 00:06:40.220
好吧不是现在我们想要它

00:06:37.690 --> 00:06:42.230
很多时候，所以我们用另一个标记

00:06:40.220 --> 00:06:44.660
从Spring 和

00:06:42.230 --> 00:06:46.610
我们说好吧，让我们经常运行

00:06:44.660 --> 00:06:48.500
 cron表达式设置为cron 

00:06:46.610 --> 00:06:50.750
表达可能也很出名

00:06:48.500 --> 00:06:52.370
对于你们所有人之前的事情，但这只是

00:06:50.750 --> 00:06:54.350
来自UNIX的表达式

00:06:52.370 --> 00:06:56.810
环境，您基本上可以定义

00:06:54.350 --> 00:06:59.180
应该多久发生一次

00:06:56.810 --> 00:07:01.310
这种情况下第一个数字第一个

00:06:59.180 --> 00:07:04.700
零位只是说什么时候

00:07:01.310 --> 00:07:07.130
时钟到达零的时间

00:07:04.700 --> 00:07:09.380
秒和任何其他数字仅仅是

00:07:07.130 --> 00:07:10.820
与您应该有的不同

00:07:09.380 --> 00:07:12.770
触发，所以基本上它将触发

00:07:10.820 --> 00:07:16.910
在零秒的每一分钟

00:07:12.770 --> 00:07:18.860
时钟，但您可以想象这很简单

00:07:16.910 --> 00:07:21.980
解决方案仅在您拥有一个时才有效

00:07:18.860 --> 00:07:23.840
单机和我们公司的数量

00:07:21.980 --> 00:07:26.900
的客户数量和流量

00:07:23.840 --> 00:07:29.780
系统真的很高，所以我们需要

00:07:26.900 --> 00:07:33.470
我们需要扩展规模，我们需要

00:07:29.780 --> 00:07:35.419
应用程序增长，所以这就是为什么

00:07:33.470 --> 00:07:37.340
谈论分布式系统以及

00:07:35.419 --> 00:07:40.190
分布式系统有两种方式

00:07:37.340 --> 00:07:43.160
缩放旧的称为水平的

00:07:40.190 --> 00:07:45.410
或垂直缩放，因此上升意味着

00:07:43.160 --> 00:07:47.840
您基本上是在提供服务

00:07:45.410 --> 00:07:50.630
正在使流量更强大

00:07:47.840 --> 00:07:52.190
 CPU，您增加了内存并增加了内存

00:07:50.630 --> 00:07:56.210
更强大，现在可以处理更多

00:07:52.190 --> 00:07:58.790
交通，但实际上当您与

00:07:56.210 --> 00:08:00.110
这个解决方案大家可能都在

00:07:58.790 --> 00:08:02.870
知道这行不通

00:08:00.110 --> 00:08:05.270
特别是在云中

00:08:02.870 --> 00:08:07.669
您可以限制的服务器数量

00:08:05.270 --> 00:08:10.130
购买，总是有最高的

00:08:07.669 --> 00:08:13.340
您可以购买的最好的服务器，它的成本是

00:08:10.130 --> 00:08:15.830
很多钱，但这仍然可能

00:08:13.340 --> 00:08:17.600
有一段时间效率不高，所以我们

00:08:15.830 --> 00:08:20.419
可以说垂直扫描还可以

00:08:17.600 --> 00:08:22.010
不能缩放，所以另一种方法

00:08:20.419 --> 00:08:23.870
当然是水平缩放

00:08:22.010 --> 00:08:27.229
左右移动并添加更多

00:08:23.870 --> 00:08:30.740
同一台机器的节点，可能

00:08:27.229 --> 00:08:32.659
在解决方案中这是众所周知的

00:08:30.740 --> 00:08:35.419
在社区中为什么我们这样做，但是

00:08:32.659 --> 00:08:38.210
让我们先列举几个好处

00:08:35.419 --> 00:08:40.669
效率通常很少几个节点

00:08:38.210 --> 00:08:42.979
较小的便宜得多的表演

00:08:40.669 --> 00:08:45.110
或至少在以下方面表现更好

00:08:42.979 --> 00:08:47.540
和一台大机器一样，所以这是

00:08:45.110 --> 00:08:50.000
先受益再高

00:08:47.540 --> 00:08:52.160
可靠性，我们有多个节点

00:08:50.000 --> 00:08:53.379
掉下来其他可以处理

00:08:52.160 --> 00:08:56.180
交通

00:08:53.379 --> 00:08:58.430
当然也更容易扩展

00:08:56.180 --> 00:09:00.290
三个笔记为什么不加三个

00:08:58.430 --> 00:09:03.470
然后加载酒吧直到后面的

00:09:00.290 --> 00:09:06.170
交通，因此请记住

00:09:03.470 --> 00:09:08.240
看看对方在我们的问题上，所以我们

00:09:06.170 --> 00:09:11.360
问题是我们有预定的工作

00:09:08.240 --> 00:09:13.459
现在我们要在多点运行它

00:09:11.360 --> 00:09:15.920
它会在多个音符上运行

00:09:13.459 --> 00:09:18.019
通常不是您想要达到的目标

00:09:15.920 --> 00:09:21.199
这就是为什么我们有这个问题的原因

00:09:18.019 --> 00:09:26.269
一次运行此计划的逻辑

00:09:21.199 --> 00:09:28.399
注意，为什么，因为你不想

00:09:26.269 --> 00:09:30.620
从资源使用情况也重复

00:09:28.399 --> 00:09:34.279
但也许只是商业案例

00:09:30.620 --> 00:09:37.069
不允许您重复解决

00:09:34.279 --> 00:09:39.379
单音符运行的问题

00:09:37.069 --> 00:09:43.279
您需要两个信息或类似信息

00:09:39.379 --> 00:09:44.899
要解决两个问题，因为我们有

00:09:43.279 --> 00:09:47.420
现在您必须选择多个音符

00:09:44.899 --> 00:09:49.999
一个将解决的将运行此

00:09:47.420 --> 00:09:51.410
预定的工作，你还需要

00:09:49.999 --> 00:09:53.329
这些信息存储在某个地方

00:09:51.410 --> 00:09:55.459
因为其他笔记需要知道

00:09:53.329 --> 00:09:57.410
好的，我不再需要运行

00:09:55.459 --> 00:10:01.429
调度程序，所以我将过去

00:09:57.410 --> 00:10:04.129
多睡一会，让我们看看另一个

00:10:01.429 --> 00:10:06.199
整个系统看起来像这样

00:10:04.129 --> 00:10:09.259
我们有三个实例

00:10:06.199 --> 00:10:10.519
仅出于示例和

00:10:09.259 --> 00:10:12.850
实例实际上可以交流

00:10:10.519 --> 00:10:17.379
彼此之间，他们可以说

00:10:12.850 --> 00:10:20.300
也许我们可以在我们之间达成共识

00:10:17.379 --> 00:10:22.759
我们中的一个应该成为领导者，但是

00:10:20.300 --> 00:10:25.459
 Spring 来了，我想也是

00:10:22.759 --> 00:10:28.519
其他框架是，注意事项

00:10:25.459 --> 00:10:32.480
相当无状态，所以基本上

00:10:28.519 --> 00:10:33.679
独自站立，他们

00:10:32.480 --> 00:10:36.589
甚至不知道还有其他

00:10:33.679 --> 00:10:38.559
实例处理相同，如果

00:10:36.589 --> 00:10:41.870
会认为他们现在应该

00:10:38.559 --> 00:10:43.429
变得像网络一样

00:10:41.870 --> 00:10:45.259
交流，如果你有不同

00:10:43.429 --> 00:10:47.629
虚拟机也许你有

00:10:45.259 --> 00:10:49.339
不同的Docker容器，它们如何

00:10:47.629 --> 00:10:53.120
可以沟通是同一台机器

00:10:49.339 --> 00:10:54.980
也许是一个不同的网络，所以

00:10:53.120 --> 00:10:58.579
简化说，沟通

00:10:54.980 --> 00:11:00.110
在这个节点之间不是一个案例

00:10:58.579 --> 00:11:02.449
对我们来说，特别是如果我们想

00:11:00.110 --> 00:11:03.709
快速提供东西，简单

00:11:02.449 --> 00:11:06.620
效果很好的解决方案

00:11:03.709 --> 00:11:07.420
工作，所以我们没有这样走

00:11:06.620 --> 00:11:09.640
为什么我们尝试

00:11:07.420 --> 00:11:11.680
我们介绍一些

00:11:09.640 --> 00:11:15.760
其他一些解决方案将

00:11:11.680 --> 00:11:17.830
基本上为我们解决了

00:11:15.760 --> 00:11:19.900
因此引入了另一个组件

00:11:17.830 --> 00:11:21.760
这就是为什么我们认为现在需要

00:11:19.900 --> 00:11:25.120
一个将存储此信息的地方

00:11:21.760 --> 00:11:27.910
对我们来说，它可能是缓存

00:11:25.120 --> 00:11:29.320
可能是我在听过的数据库

00:11:27.910 --> 00:11:32.320
人们正在解决的会议

00:11:29.320 --> 00:11:33.700
这与Mongo可能会有所不同

00:11:32.320 --> 00:11:36.640
不同的解决方案，但

00:11:33.700 --> 00:11:38.110
基本上这个地方必须可靠

00:11:36.640 --> 00:11:40.900
当然是因为我们不想

00:11:38.110 --> 00:11:42.880
引入更多的失败点，它

00:11:40.900 --> 00:11:45.160
首先会做两件事

00:11:42.880 --> 00:11:47.950
将存储没有的信息

00:11:45.160 --> 00:11:50.800
应该是一个领导者，但也会

00:11:47.950 --> 00:11:53.740
允许

00:11:50.800 --> 00:11:56.140
一个实例和一个Orchestrator 

00:11:53.740 --> 00:11:58.090
用不同的方式称呼它并提供

00:11:56.140 --> 00:12:01.540
我是领导者的问题的答案是

00:11:58.090 --> 00:12:03.640
只是一个实例

00:12:01.540 --> 00:12:05.590
由王冠触发的慢性经

00:12:03.640 --> 00:12:07.950
预定运行过程

00:12:05.590 --> 00:12:11.410
活动是领导者，且仅当

00:12:07.950 --> 00:12:14.920
这则笔记只会得到答案

00:12:11.410 --> 00:12:18.130
然后它将处理事件

00:12:14.920 --> 00:12:21.160
在彩票中

00:12:18.130 --> 00:12:26.410
让我们考虑一下如何才能

00:12:21.160 --> 00:12:28.720
可以解决这个问题，所以回到

00:12:26.410 --> 00:12:31.450
最初的问题，因为我们在

00:12:28.720 --> 00:12:33.790
Spring 基于Spring 的应用程序所以

00:12:31.450 --> 00:12:35.590
指定更多，我们有多个

00:12:33.790 --> 00:12:37.330
注意所有的应用都是 Spring 

00:12:35.590 --> 00:12:41.500
应用程序，我们要选择一个

00:12:37.330 --> 00:12:44.440
作为领导者，让我们来看看

00:12:41.500 --> 00:12:47.890
再次编写代码，所以我们有了这个简单的方法

00:12:44.440 --> 00:12:50.770
服务已经在这里可见，我们有

00:12:47.890 --> 00:12:53.110
它正在工作，现在让我们看看它如何

00:12:50.770 --> 00:12:55.420
可以在分布式世界中完成

00:12:53.110 --> 00:12:57.520
我们已经在使用了一个注释

00:12:55.420 --> 00:13:00.340
预定的，所以也许我们可以使用另一个

00:12:57.520 --> 00:13:03.820
这次我们的习俗之一，让我们命名

00:13:00.340 --> 00:13:05.860
它运行，如果领导者，这在这个

00:13:03.820 --> 00:13:08.440
感觉我们现在有一种方法是

00:13:05.860 --> 00:13:10.420
如果可以，请清楚清楚

00:13:08.440 --> 00:13:12.760
看着好吧，它做了一些预定的

00:13:10.420 --> 00:13:14.830
工作，但前提是有

00:13:12.760 --> 00:13:18.640
这不是此代码将运行的是

00:13:14.830 --> 00:13:20.680
领导者，让我们进入

00:13:18.640 --> 00:13:22.749
详细说明如何实现

00:13:20.680 --> 00:13:25.779
所以写自己的注释很漂亮

00:13:22.749 --> 00:13:27.910
很简单，在许多对话中都可以看到

00:13:25.779 --> 00:13:29.860
今天和昨天，但实际上没有人

00:13:27.910 --> 00:13:32.470
至少我没有听说没有人参加

00:13:29.860 --> 00:13:33.910
详细情况这是什么两个

00:13:32.470 --> 00:13:36.550
您需要添加到的属性

00:13:33.910 --> 00:13:39.970
接口，所以称为接口，但是

00:13:36.550 --> 00:13:42.519
这只是Java上的术语

00:13:39.970 --> 00:13:44.110
您需要创建一个类

00:13:42.519 --> 00:13:46.509
这个添加界面，你基本上

00:13:44.110 --> 00:13:48.449
需要提供这两个属性

00:13:46.509 --> 00:13:51.850
第一个属性是保留权， 

00:13:48.449 --> 00:13:54.519
基本上告诉Java JVM或

00:13:51.850 --> 00:13:58.389
注释应在哪里编译

00:13:54.519 --> 00:14:00.100
留下来，我们在这里使用的保留

00:13:58.389 --> 00:14:02.139
是运行时，基本上它说

00:14:00.100 --> 00:14:04.300
这种保留应该保留整个

00:14:02.139 --> 00:14:06.670
应用程序的生命周期，直到

00:14:04.300 --> 00:14:09.429
运行时，所以说编译器可以

00:14:06.670 --> 00:14:11.709
删除一些注释，但是这个没有

00:14:09.429 --> 00:14:13.329
它必须声明一生，因为

00:14:11.709 --> 00:14:15.670
我们的情况当然会

00:14:13.329 --> 00:14:19.029
由编译器删除如何运行代码

00:14:15.670 --> 00:14:21.839
可以检查是否在

00:14:19.029 --> 00:14:24.759
我们正在运行的东西是领导者，所以

00:14:21.839 --> 00:14:27.069
考虑到这一点，保留是

00:14:24.759 --> 00:14:30.160
第一个目标是第二个目标是

00:14:27.069 --> 00:14:32.079
马克说的很简单

00:14:30.160 --> 00:14:34.509
您可以放置​​此注释，并为我们

00:14:32.079 --> 00:14:36.309
这是一个方法，所以它可能是一个类，但是

00:14:34.509 --> 00:14:38.050
当然这就是我们想要的

00:14:36.309 --> 00:14:39.970
没事

00:14:38.050 --> 00:14:42.939
让我们更深入，因为这是

00:14:39.970 --> 00:14:45.370
只是一个注释，现在我们需要

00:14:42.939 --> 00:14:48.759
以某种方式理解这个注释

00:14:45.370 --> 00:14:49.870
可以被 Spring 理解

00:14:48.759 --> 00:14:51.759
这就是为什么我们需要介绍

00:14:49.870 --> 00:14:55.389
面向方面的程序设计

00:14:51.759 --> 00:14:57.550
面向切面的编程仅仅是

00:14:55.389 --> 00:15:00.370
一个名字，但基本上说的是

00:14:57.550 --> 00:15:02.259
一个方面是削减的关注点

00:15:00.370 --> 00:15:06.279
通过整个应用程序

00:15:02.259 --> 00:15:08.019
关注所有

00:15:06.279 --> 00:15:10.870
可以附属于所有业务

00:15:08.019 --> 00:15:12.850
应用程序旁边的逻辑

00:15:10.870 --> 00:15:15.399
服务旁边的数据库

00:15:12.850 --> 00:15:19.629
控制器，所以一个漂亮的例子

00:15:15.399 --> 00:15:21.879
通常在有人解释AOP时说

00:15:19.629 --> 00:15:24.100
它正在记录日志，因为日志记录是

00:15:21.879 --> 00:15:25.929
我们每天做的事情，我们

00:15:24.100 --> 00:15:28.209
放在应用程序的每个部分

00:15:25.929 --> 00:15:32.139
所以这就是为什么跨领域

00:15:28.209 --> 00:15:33.720
关注这里也俗称

00:15:32.139 --> 00:15:36.360
交易管理这是

00:15:33.720 --> 00:15:38.189
我认为我们从事不同的业务

00:15:36.360 --> 00:15:40.769
处理，所以这不是什么

00:15:38.189 --> 00:15:43.199
附加到特定问题上也可以减少

00:15:40.769 --> 00:15:46.500
整个应用程序如何

00:15:43.199 --> 00:15:48.709
考虑到这一点，我们现在该如何

00:15:46.500 --> 00:15:51.540
 Spring 在公众场合启用

00:15:48.709 --> 00:15:54.810
毫不奇怪，我们只需添加新

00:15:51.540 --> 00:15:59.610
依赖，因此 Spring 将启动AOP 

00:15:54.810 --> 00:16:01.709
现在 Spring 可以找到我们的注释

00:15:59.610 --> 00:16:02.730
并可以处理他们这样做的原因

00:16:01.709 --> 00:16:06.689
像那样

00:16:02.730 --> 00:16:10.680
我想 Spring 的想法

00:16:06.689 --> 00:16:12.990
好吧，也许我们可以使人们

00:16:10.680 --> 00:16:14.970
介绍他们的注释，但这是

00:16:12.990 --> 00:16:17.519
不是那么常见的东西，所以核心

00:16:14.970 --> 00:16:19.500
 Spring 没有这个，所以你可以使用

00:16:17.519 --> 00:16:21.829
当然是注解，但是如果您想

00:16:19.500 --> 00:16:24.959
创建自己的需要这种依赖

00:16:21.829 --> 00:16:27.660
好吧，那会工作的

00:16:24.959 --> 00:16:31.980
可以启用该应用程序，但是如何

00:16:27.660 --> 00:16:33.540
其实我们真的可以教 Spring 

00:16:31.980 --> 00:16:35.639
有一个注释及其内容

00:16:33.540 --> 00:16:38.939
应该了解我们需要

00:16:35.639 --> 00:16:40.920
介绍建议的概念，以便

00:16:38.939 --> 00:16:42.930
免费的建议，他们实际上更多，但

00:16:40.920 --> 00:16:47.339
让我们专注于最简单的三个

00:16:42.930 --> 00:16:50.430
因此，建议是说

00:16:47.339 --> 00:16:52.559
请在运行时过程中

00:16:50.430 --> 00:16:55.889
在特定时间的注释

00:16:52.559 --> 00:16:58.649
在我们的情况下是一种方法，所以我们说

00:16:55.889 --> 00:17:00.839
也许我们会写的这个建议

00:16:58.649 --> 00:17:03.720
那将检查我们是否

00:17:00.839 --> 00:17:05.549
请注意，领导者可以追赶

00:17:03.720 --> 00:17:07.650
对我们来说当然也已经

00:17:05.549 --> 00:17:10.409
迟到了，因为工作会执行，所以我们

00:17:07.650 --> 00:17:12.329
可以把它划掉，所以也许可以

00:17:10.409 --> 00:17:14.850
可以用于我们，但在此之前

00:17:12.329 --> 00:17:18.870
一个无条件的建议

00:17:14.850 --> 00:17:21.929
说这段代码将消失将运行

00:17:18.870 --> 00:17:24.510
永远都不知道这段代码会发生什么

00:17:21.929 --> 00:17:28.319
将运行，我们可以添加一些逻辑是

00:17:24.510 --> 00:17:30.570
一些代码，例如登录之前，所以

00:17:28.319 --> 00:17:32.909
日志记录也可以由

00:17:30.570 --> 00:17:35.280
按方面，你可以在此之前说

00:17:32.909 --> 00:17:37.679
方法总是看起来，但不幸的是

00:17:35.280 --> 00:17:39.750
无条件的，就我们而言，我们需要

00:17:37.679 --> 00:17:43.649
使用周围增加了这种可能性

00:17:39.750 --> 00:17:46.470
仅在特定条件下进行

00:17:43.649 --> 00:17:47.250
满足，让我们看看最终如何

00:17:46.470 --> 00:17:51.810
实现这个

00:17:47.250 --> 00:17:53.880
副主席-我们如何使用这个顾问

00:17:51.810 --> 00:17:56.660
要拥有这个，我们必须创造我们自己的

00:17:53.880 --> 00:18:00.540
方面，最初是在 Spring 

00:17:56.660 --> 00:18:02.850
方面是用XML定义的，可能

00:18:00.540 --> 00:18:04.770
你们大多数人不再使用了，所以我们

00:18:02.850 --> 00:18:08.370
可以使用注释注释

00:18:04.770 --> 00:18:10.490
来自aspectj框架，所以这是

00:18:08.370 --> 00:18:13.350
为什么您可以看到这两个注释

00:18:10.490 --> 00:18:17.340
方面和这两个即将到来

00:18:13.350 --> 00:18:19.320
从这个框架，基本上什么时候

00:18:17.340 --> 00:18:21.570
你在这个班上有这个方法

00:18:19.320 --> 00:18:23.460
需要创建一种方法并注释

00:18:21.570 --> 00:18:26.790
它与您已经提出的建议之一

00:18:23.460 --> 00:18:29.760
在上一张幻灯片和内部看到

00:18:26.790 --> 00:18:32.070
你周围的这个基本上定义了它如何

00:18:29.760 --> 00:18:34.140
应该匹配，首先您可以看到

00:18:32.070 --> 00:18:36.720
在幻灯片上的是它必须匹配

00:18:34.140 --> 00:18:39.840
具有我们定义的名称的注释

00:18:36.720 --> 00:18:41.460
几张幻灯片之前，它也必须

00:18:39.840 --> 00:18:43.560
匹配执行方法

00:18:41.460 --> 00:18:46.070
什么也不返回，这就是为什么虚无的原因

00:18:43.560 --> 00:18:49.590
有任何名称和任何参数列表

00:18:46.070 --> 00:18:51.090
好吧，现在这将匹配

00:18:49.590 --> 00:18:54.510
我们将放置在

00:18:51.090 --> 00:18:56.640
代码的特定部分，但

00:18:54.510 --> 00:19:00.230
逻辑必须放在里面这就是为什么我们

00:18:56.640 --> 00:19:02.460
需要介绍op2的最后一部分

00:19:00.230 --> 00:19:04.710
关闭整个主题

00:19:02.460 --> 00:19:07.470
注释，我们需要加入

00:19:04.710 --> 00:19:09.870
点和连接点是一个点

00:19:07.470 --> 00:19:11.670
应用程序四舍五入时的代码和

00:19:09.870 --> 00:19:13.950
当应用程序运行时，因此

00:19:11.670 --> 00:19:15.330
应用程序运行然后执行一些操作

00:19:13.950 --> 00:19:19.080
是重点，然后是下一步

00:19:15.330 --> 00:19:21.270
运行等等等，然后我们的代码将

00:19:19.080 --> 00:19:24.000
运行会有一个连接点

00:19:21.270 --> 00:19:26.220
在运行它之前及时

00:19:24.000 --> 00:19:28.770
这是该注释将启动的时间

00:19:26.220 --> 00:19:31.290
在您所看到的代码中

00:19:28.770 --> 00:19:33.900
我们将基本上检查该节点是否为

00:19:31.290 --> 00:19:37.620
一个领导者，我们只会继续

00:19:33.900 --> 00:19:40.770
连接点，在其他情况下

00:19:37.620 --> 00:19:44.190
不那么我们只会通过

00:19:40.770 --> 00:19:45.980
跳过执行，然后再次在这里

00:19:44.190 --> 00:19:49.440
不要过多地关注有关的细节

00:19:45.980 --> 00:19:52.320
领导如何选择

00:19:49.440 --> 00:19:54.540
之所以实现，是因为它取决于

00:19:52.320 --> 00:19:58.380
您选择的解决方案

00:19:54.540 --> 00:19:59.850
所以在我们的情况下，这是一个说明

00:19:58.380 --> 00:20:02.669
我们基本上可以使用

00:19:59.850 --> 00:20:06.450
 HTTP调用，但也可以是其他任何一种

00:20:02.669 --> 00:20:08.130
您决定使用那里，所以

00:20:06.450 --> 00:20:10.500
考虑到那解决了

00:20:08.130 --> 00:20:12.179
问题是它为我们工作，但我们

00:20:10.500 --> 00:20:14.010
发现几乎没有东西

00:20:12.179 --> 00:20:17.419
我们不喜欢它，所以让我们谈谈

00:20:14.010 --> 00:20:20.070
关于此解决方案的缺点

00:20:17.419 --> 00:20:24.030
我想提的第一件事

00:20:20.070 --> 00:20:26.820
是业务逻辑的分离和

00:20:24.030 --> 00:20:28.950
调度逻辑，以便您尽可能

00:20:26.820 --> 00:20:31.679
您在幻灯片上看到我们有这则广告

00:20:28.950 --> 00:20:35.309
排在上方的预定注释

00:20:31.679 --> 00:20:37.740
做某人的方法

00:20:35.309 --> 00:20:40.440
会说，以扎实的原则

00:20:37.740 --> 00:20:41.909
你有一个单一的责任

00:20:40.440 --> 00:20:44.970
原理

00:20:41.909 --> 00:20:47.640
你不应该不混合我们

00:20:44.970 --> 00:20:50.789
对此表示同意，我们认为也许

00:20:47.640 --> 00:20:53.100
我们可以找到更好的解决方案

00:20:50.789 --> 00:20:56.370
出来测试不是那么容易，所以

00:20:53.100 --> 00:20:58.559
我们有这个注释，但是写了一个

00:20:56.370 --> 00:21:01.140
简单的单元测试，以验证

00:20:58.559 --> 00:21:03.270
代码的一部分已经安排好了

00:21:01.140 --> 00:21:07.770
代码的一部分会像我们一样经常运行

00:21:03.270 --> 00:21:09.600
想要并不明显，最后我们

00:21:07.770 --> 00:21:12.690
发现当申请

00:21:09.600 --> 00:21:14.789
开始增长，我们有越来越多的工作

00:21:12.690 --> 00:21:16.919
预定，变得有点

00:21:14.789 --> 00:21:18.900
很大程度上是因为工作分散了

00:21:16.919 --> 00:21:21.090
通过应用程序，如果有人

00:21:18.900 --> 00:21:23.880
想验证什么任务

00:21:21.090 --> 00:21:25.559
在后台发生的不是

00:21:23.880 --> 00:21:26.880
如此简单，您将不需要

00:21:25.559 --> 00:21:33.720
基本上可以搜索整个

00:21:26.880 --> 00:21:35.970
我之前也想谈的应用程序

00:21:33.720 --> 00:21:37.650
切换到我想要的第二种方法

00:21:35.970 --> 00:21:39.150
谈论一个问题

00:21:37.650 --> 00:21:44.730
我们遇到的具体问题

00:21:39.150 --> 00:21:46.650
解决方案，因此我们也可以从AWS使用

00:21:44.730 --> 00:21:50.970
云中有一个称为队列的解决方案

00:21:46.650 --> 00:21:54.210
 sqs，此队列可以与

00:21:50.970 --> 00:21:57.360
由AWS提供的客户端和客户端

00:21:54.210 --> 00:21:58.970
那里的见解将其用作平方

00:21:57.360 --> 00:22:05.010
侦听器另一个注释

00:21:58.970 --> 00:22:07.230
一切都是注释，因此

00:22:05.010 --> 00:22:10.590
我们可以实现类似

00:22:07.230 --> 00:22:12.900
您在此处使用的非事件方法

00:22:10.590 --> 00:22:14.130
你基本上可以看到

00:22:12.900 --> 00:22:16.920
这样的条件很容易

00:22:14.130 --> 00:22:18.780
只是说好，这就是价值

00:22:16.920 --> 00:22:20.400
您的队列的这种情况名称

00:22:18.780 --> 00:22:22.170
想听，这是

00:22:20.400 --> 00:22:24.450
什么时候应该删除政策

00:22:22.170 --> 00:22:26.220
从队列中删除此不成功

00:22:24.450 --> 00:22:29.850
表示如果该方法继续进行

00:22:26.220 --> 00:22:32.220
毫无例外，一切都很好，所以

00:22:29.850 --> 00:22:35.790
现在可以删除该消息以及如何

00:22:32.220 --> 00:22:39.210
这是有效的是，注意

00:22:35.790 --> 00:22:42.120
运行此命令会从

00:22:39.210 --> 00:22:46.560
队列使其对其他节点不可见

00:22:42.120 --> 00:22:48.900
并处理它，但在这种情况下

00:22:46.560 --> 00:22:51.240
节点会抓住它并赢得市场

00:22:48.900 --> 00:22:54.120
看不见，会检查它是否是

00:22:51.240 --> 00:22:55.950
前导标记，使其无法阅读

00:22:54.120 --> 00:22:59.370
由其他节点，这很漂亮

00:22:55.950 --> 00:23:01.230
效率低下的人

00:22:59.370 --> 00:23:04.200
不确定发生了什么

00:23:01.230 --> 00:23:06.210
因为使用一些可能出了什么问题

00:23:04.200 --> 00:23:07.710
注释正确，但实际上看起来

00:23:06.210 --> 00:23:09.600
像注解的顺序

00:23:07.710 --> 00:23:12.360
可能应该与您不同

00:23:09.600 --> 00:23:16.290
难道你不应该读任何东西

00:23:12.360 --> 00:23:17.970
从SQL，因为因为没有

00:23:16.290 --> 00:23:20.450
甚至尝试阅读任何东西

00:23:17.970 --> 00:23:23.970
从SQL，如果您不是领导者，并且

00:23:20.450 --> 00:23:26.550
如果您只是跟随，如果您是新手

00:23:23.970 --> 00:23:27.660
团队，你不知道是什么

00:23:26.550 --> 00:23:29.490
发生，而你只是在跟随

00:23:27.660 --> 00:23:31.920
代码的其他部分，基本上

00:23:29.490 --> 00:23:33.180
复制您不粘贴的SQL侦听器

00:23:31.920 --> 00:23:34.710
进入细节也许你不

00:23:33.180 --> 00:23:37.110
知道实际上

00:23:34.710 --> 00:23:39.240
某些消息将不可见

00:23:37.110 --> 00:23:43.710
时间是否如果检查领导

00:23:39.240 --> 00:23:48.720
需要一些时间，这就是为什么

00:23:43.710 --> 00:23:50.310
我们尝试了其他事情，我们决定

00:23:48.720 --> 00:23:52.320
也许我们应该切换到另一个

00:23:50.310 --> 00:23:55.320
称为程序化的方法

00:23:52.320 --> 00:23:57.060
以程序方式进行处理意味着您

00:23:55.320 --> 00:24:01.290
需要多写一些代码，但是

00:23:57.060 --> 00:24:03.270
您可以更好地控制

00:24:01.290 --> 00:24:07.170
我们想要如何安排的方式

00:24:03.270 --> 00:24:09.720
让我们看看如何做到这一点

00:24:07.170 --> 00:24:12.240
有这个，我们不知道我们都切换了

00:24:09.720 --> 00:24:15.750
在注释之外，所以也许是

00:24:12.240 --> 00:24:19.860
已经为我们中的一些人受益，我们

00:24:15.750 --> 00:24:21.240
现在需要实现与

00:24:19.860 --> 00:24:23.220
名称调度配置即

00:24:21.240 --> 00:24:26.370
可从此包装中获得，这是

00:24:23.220 --> 00:24:29.370
Spring 的标准代码

00:24:26.370 --> 00:24:31.740
并记住这是

00:24:29.370 --> 00:24:34.980
这很简单，因为界面

00:24:31.740 --> 00:24:37.170
方法只有一种

00:24:34.980 --> 00:24:39.330
将配置任务，并提供

00:24:37.170 --> 00:24:41.280
您是注册商，并且在此注册商

00:24:39.330 --> 00:24:42.990
你基本上会把所有的东西

00:24:41.280 --> 00:24:45.120
您想要缩放的一个

00:24:42.990 --> 00:24:48.180
我将展示的其他好处

00:24:45.120 --> 00:24:51.510
几张幻灯片，让我们看一下代码

00:24:48.180 --> 00:24:54.090
如何做到这一点，所以这次我们

00:24:51.510 --> 00:24:55.440
创建一个配置类，这就是为什么

00:24:54.090 --> 00:24:58.950
我们需要在

00:24:55.440 --> 00:25:01.760
配置我们还需要配置

00:24:58.950 --> 00:25:05.520
默认启用调度

00:25:01.760 --> 00:25:07.140
 Spring 没有安排任何

00:25:05.520 --> 00:25:10.350
应用时间表注释也不会

00:25:07.140 --> 00:25:13.110
没有这个注释就可以工作，但是在这个

00:25:10.350 --> 00:25:14.940
当我们有一个班级的时候

00:25:13.110 --> 00:25:16.590
可以配置

00:25:14.940 --> 00:25:18.510
调度应用程序的一部分

00:25:16.590 --> 00:25:20.100
把这个放在

00:25:18.510 --> 00:25:22.830
规模和一些调度在这里

00:25:20.100 --> 00:25:25.250
放置而不是例如在主要

00:25:22.830 --> 00:25:27.300
申请类别

00:25:25.250 --> 00:25:29.309
我已经实现了这种方法

00:25:27.300 --> 00:25:31.860
已经提到的也很容易

00:25:29.309 --> 00:25:35.220
因为您有此对象注册商

00:25:31.860 --> 00:25:36.570
你基本上在那儿调用一个方法

00:25:35.220 --> 00:25:39.330
对此的几种方法

00:25:36.570 --> 00:25:41.520
注册商之一是cron at cron 

00:25:39.330 --> 00:25:43.500
基本上完成的任务

00:25:41.520 --> 00:25:45.990
与我们在添加项中看到的相同

00:25:43.500 --> 00:25:49.559
安排注释，以便您创建一个新的

00:25:45.990 --> 00:25:52.500
 chrome任务的另一个对象

00:25:49.559 --> 00:25:55.500
需要两个参数，第一个参数

00:25:52.500 --> 00:25:58.559
只是我们的代码块

00:25:55.500 --> 00:26:00.390
想要以某种时间表方式运行

00:25:58.559 --> 00:26:02.490
所以我们只是在处理事件

00:26:00.390 --> 00:26:05.700
情况，第二个参数是

00:26:02.490 --> 00:26:07.500
你想说的cron表达

00:26:05.700 --> 00:26:09.480
它通常应该运行，所以此代码

00:26:07.500 --> 00:26:11.160
基本上和我们看到的一样

00:26:09.480 --> 00:26:15.900
上一个与第一个

00:26:11.160 --> 00:26:18.420
好的，让我们来看更多

00:26:15.900 --> 00:26:21.809
详细说明了如何进行改进，因此我们

00:26:18.420 --> 00:26:23.790
相信在这之上，我已经

00:26:21.809 --> 00:26:26.580
提到单一责任原则

00:26:23.790 --> 00:26:28.440
所以这就是为什么我们认为可以

00:26:26.580 --> 00:26:30.030
事件的处理或

00:26:28.440 --> 00:26:31.980
定义事件应该如何

00:26:30.030 --> 00:26:34.140
处理后应放在其他地方

00:26:31.980 --> 00:26:36.120
在这里，我们正在编写一个类

00:26:34.140 --> 00:26:38.040
负责安排另一个

00:26:36.120 --> 00:26:40.200
班级应该负责说

00:26:38.040 --> 00:26:43.530
当什么时候怎么做

00:26:40.200 --> 00:26:46.940
什么时候工作会完成

00:26:43.530 --> 00:26:49.440
并要求做某事，这就是为什么我们

00:26:46.940 --> 00:26:50.760
理想情况下至少应该是我们认为

00:26:49.440 --> 00:26:53.880
这个想法应该这样做

00:26:50.760 --> 00:26:56.190
您创建的注入和方法

00:26:53.880 --> 00:26:58.380
基本上向物体注入光束

00:26:56.190 --> 00:27:00.300
是可运行的，但由于网络

00:26:58.380 --> 00:27:02.640
有一个名字匹配它会

00:27:00.300 --> 00:27:04.440
您也可以使用而不是

00:27:02.640 --> 00:27:07.920
可以使用适当的适当的

00:27:04.440 --> 00:27:10.980
班级名称为双季，然后

00:27:07.920 --> 00:27:13.560
您现在可用的这个对象

00:27:10.980 --> 00:27:16.200
在您安排的课程中，您可以使用它

00:27:13.560 --> 00:27:18.270
内部所需的方法

00:27:16.200 --> 00:27:19.650
基本上这样覆盖

00:27:18.270 --> 00:27:22.500
与您在

00:27:19.650 --> 00:27:24.900
上一张幻灯片，但现在拆分很大

00:27:22.500 --> 00:27:27.120
更清晰，我们需要的课程

00:27:24.900 --> 00:27:28.920
安排我们需要的工作

00:27:27.120 --> 00:27:31.680
时间表现在可以在

00:27:28.920 --> 00:27:33.600
不同的组件，这是一个任务

00:27:31.680 --> 00:27:36.660
我们，我们只是说好，它必须

00:27:33.600 --> 00:27:38.790
实现可运行的接口，因为

00:27:36.660 --> 00:27:42.030
它需要运行一些东西，所以这是

00:27:38.790 --> 00:27:45.330
为什么在其中运行代码

00:27:42.030 --> 00:27:48.090
您需要实现的一种方法

00:27:45.330 --> 00:27:50.880
有了我们，我们可以继续前进， 

00:27:48.090 --> 00:27:53.780
看看这有什么好处

00:27:50.880 --> 00:27:56.400
这种方法，所以首先我们已经看到

00:27:53.780 --> 00:27:58.500
现在将所有税务任务安排在一处

00:27:56.400 --> 00:28:01.260
我们有一堂课，一切都在里面

00:27:58.500 --> 00:28:02.640
新来的人来看清楚

00:28:01.260 --> 00:28:04.980
这些是我们要完成的任务

00:28:02.640 --> 00:28:08.400
很容易理解是什么

00:28:04.980 --> 00:28:11.010
发生在后台

00:28:08.400 --> 00:28:13.290
额外的好处是自定义执行器

00:28:11.010 --> 00:28:15.330
服务这是完全没有

00:28:13.290 --> 00:28:17.610
在第一种方法上讨论，因为

00:28:15.330 --> 00:28:18.930
没有办法只能解决

00:28:17.610 --> 00:28:21.450
使用程序化方法，您可以

00:28:18.930 --> 00:28:23.610
创建您的自定义执行器服务

00:28:21.450 --> 00:28:26.100
应该运行您拥有的任务

00:28:23.610 --> 00:28:28.170
后台以及何时应用

00:28:26.100 --> 00:28:29.370
成长，也许您有很多任务

00:28:28.170 --> 00:28:32.550
特别是在后台运行

00:28:29.370 --> 00:28:35.400
任务，但要花很多时间，也许

00:28:32.550 --> 00:28:38.010
您需要多个线程来处理

00:28:35.400 --> 00:28:39.750
这些任务以及预定的时间

00:28:38.010 --> 00:28:41.820
那里的第一种方法

00:28:39.750 --> 00:28:43.530
只有一个线程，所以如果你有

00:28:41.820 --> 00:28:44.580
基本上证明了这个问题

00:28:43.530 --> 00:28:47.100
需要切换到程序化

00:28:44.580 --> 00:28:50.960
方法让我们看看这是怎么回事

00:28:47.100 --> 00:28:53.400
实施，所以现在我们有了这个

00:28:50.960 --> 00:28:54.029
注册服务商再次配置任务方法

00:28:53.400 --> 00:28:56.759
我们需要

00:28:54.029 --> 00:29:00.330
现在，而不是呼吁

00:28:56.759 --> 00:29:02.159
 cron的注册服务商称为集合调度程序

00:29:00.330 --> 00:29:05.299
所以现在我们说好

00:29:02.159 --> 00:29:08.639
不要使用默认的单线程

00:29:05.299 --> 00:29:10.739
执行服务，但使用这一新服务

00:29:08.639 --> 00:29:13.139
我们会为您提供一遍又一遍的

00:29:10.739 --> 00:29:14.639
一些洗牌和推杆

00:29:13.139 --> 00:29:17.279
这可能是单独的方法

00:29:14.639 --> 00:29:19.259
如果有人喜欢新的课程

00:29:17.279 --> 00:29:22.259
任务计划程序方法将为您提供

00:29:19.259 --> 00:29:23.999
执行者服务执行者服务由

00:29:22.259 --> 00:29:28.529
如果您不熟悉的方式

00:29:23.999 --> 00:29:31.200
那只是一个讲述它如何的类

00:29:28.529 --> 00:29:33.119
将处理工作将如何创建

00:29:31.200 --> 00:29:36.899
线程将有多少个线程

00:29:33.119 --> 00:29:38.969
有，是的，基本上会处理

00:29:36.899 --> 00:29:41.909
在后台的东西

00:29:38.969 --> 00:29:45.119
我们作为执行者创建的案例

00:29:41.909 --> 00:29:47.369
静态方法的类新计划

00:29:45.119 --> 00:29:49.889
线程池，所以我们会说请创建

00:29:47.369 --> 00:29:52.889
对我们来说，一个线程池将与

00:29:49.889 --> 00:29:55.649
预定的物品，它将有

00:29:52.889 --> 00:29:58.979
示例四个线程，现在我们可以设置它

00:29:55.649 --> 00:30:01.830
这样，我们也可以

00:29:58.979 --> 00:30:04.619
额外的好处为

00:30:01.830 --> 00:30:07.649
对于这些线程， 

00:30:04.619 --> 00:30:09.359
将由该执行者使用，所以这里

00:30:07.649 --> 00:30:12.599
不幸的是这段代码没有来

00:30:09.359 --> 00:30:15.889
来自JDK本身的

00:30:12.599 --> 00:30:18.179
需要使用番石榴才能使用此生成器

00:30:15.889 --> 00:30:20.450
但这只是实现细节

00:30:18.179 --> 00:30:24.149
但是正如您所看到的，我们可以创建一个

00:30:20.450 --> 00:30:27.389
此线程的名称格式，以及

00:30:24.149 --> 00:30:29.190
也以百分比D结尾

00:30:27.389 --> 00:30:31.349
这意味着将会有所不同

00:30:29.190 --> 00:30:34.519
这四个线程中每个线程的编号

00:30:31.349 --> 00:30:37.739
以及何时进行调试或

00:30:34.519 --> 00:30:39.779
检查生活应用程序如何

00:30:37.739 --> 00:30:41.849
后台发生的事情

00:30:39.779 --> 00:30:43.919
您可以在日志中看到这是

00:30:41.849 --> 00:30:46.679
实际发生在

00:30:43.919 --> 00:30:48.389
在计划的过程中，所以这给

00:30:46.679 --> 00:30:52.019
你增加了一点

00:30:48.389 --> 00:30:54.450
具有这两个好处的可观察性

00:30:52.019 --> 00:30:55.889
考虑到我的另一点

00:30:54.450 --> 00:30:59.879
想谈的是

00:30:55.889 --> 00:31:02.220
以前测试方便

00:30:59.879 --> 00:31:03.830
根本没有看测试，我们没有

00:31:02.220 --> 00:31:06.050
有什么

00:31:03.830 --> 00:31:08.180
这就是为什么我不想发现

00:31:06.050 --> 00:31:16.190
任何东西，但在这里我们实际上

00:31:08.180 --> 00:31:19.520
可以做很好的测试，所以现在我们

00:31:16.190 --> 00:31:21.680
可以创建预定的配置测试

00:31:19.520 --> 00:31:25.310
基本上将测试是否

00:31:21.680 --> 00:31:27.290
这就是我们要配置的

00:31:25.310 --> 00:31:29.300
首先安排这是可能的

00:31:27.290 --> 00:31:32.030
完成，所以我在这里使用传统

00:31:29.300 --> 00:31:34.370
的方法，所以我在上面说的麦田

00:31:32.030 --> 00:31:36.620
第一行，这个课程这个测试

00:31:34.370 --> 00:31:39.890
应该在模拟J单元跑步者中运行，所以

00:31:36.620 --> 00:31:41.450
我们可以使用模拟和类

00:31:39.890 --> 00:31:43.910
被测当然是排定的

00:31:41.450 --> 00:31:45.950
配置我们正在标记它将会

00:31:43.910 --> 00:31:48.320
可以在此类上注入模拟

00:31:45.950 --> 00:31:51.470
我们需要两个模拟来拥有它

00:31:48.320 --> 00:31:53.960
验证了第一个模拟是注册器

00:31:51.470 --> 00:31:56.990
我们将放在

00:31:53.960 --> 00:31:59.240
称这些为我们想要的逻辑

00:31:56.990 --> 00:32:01.070
时间表，第二部分将是

00:31:59.240 --> 00:32:03.710
我们要实际安排的任务

00:32:01.070 --> 00:32:06.200
以及可以验证的简单测试

00:32:03.710 --> 00:32:08.390
一切都如我们所愿

00:32:06.200 --> 00:32:12.680
只会调用此配置任务

00:32:08.390 --> 00:32:14.870
此任务注册器传递的方法

00:32:12.680 --> 00:32:17.360
模拟，在测试结束时我们需要

00:32:14.870 --> 00:32:19.520
当然要验证一些东西

00:32:17.360 --> 00:32:21.920
我们将验证只是我们将检查

00:32:19.520 --> 00:32:24.800
在这个模拟和方法的咕gr声中

00:32:21.920 --> 00:32:27.200
成本，如果没有租赁，基本上

00:32:24.800 --> 00:32:29.420
在这个方法上，这两个参数是

00:32:27.200 --> 00:32:32.030
通过了，所以第一个遇到了第一个

00:32:29.420 --> 00:32:34.190
参数将由类匹配

00:32:32.030 --> 00:32:38.090
类型和第二个将基本匹配

00:32:34.190 --> 00:32:41.000
通过字符串，现在如果有人改变

00:32:38.090 --> 00:32:43.700
更改了cron表达式，因为

00:32:41.000 --> 00:32:46.280
我现在都不知道错别字

00:32:43.700 --> 00:32:50.420
测试，我们将验证它是

00:32:46.280 --> 00:32:53.210
我们想要再进行一次测试，所以我们

00:32:50.420 --> 00:32:55.700
介绍我们介绍和使用的

00:32:53.210 --> 00:32:58.040
遗嘱执行人服务，这也可以

00:32:55.700 --> 00:32:59.840
经过测试，这就是力量

00:32:58.040 --> 00:33:02.170
程序化方法，您需要更多

00:32:59.840 --> 00:33:05.540
代码，但您拥有更多控制权，因此

00:33:02.170 --> 00:33:07.970
这里再次牧田赛跑者使用

00:33:05.540 --> 00:33:09.800
在测试中使用相同的类进行模拟

00:33:07.970 --> 00:33:12.530
注入模拟，这里我们需要

00:33:09.800 --> 00:33:15.600
只有一个模拟课，因为当

00:33:12.530 --> 00:33:18.600
你会输掉另一把戏

00:33:15.600 --> 00:33:20.670
在测试之前进行测试

00:33:18.600 --> 00:33:23.100
通常是兼职

00:33:20.670 --> 00:33:24.690
准备测试，以便

00:33:23.100 --> 00:33:27.900
测试的准备阶段，我们将

00:33:24.690 --> 00:33:30.690
创建抓捕者抓捕者是一种

00:33:27.900 --> 00:33:33.030
可以检查是否有东西的对象

00:33:30.690 --> 00:33:34.860
用这些参数执行

00:33:33.030 --> 00:33:36.900
可以在最后验证，我们只是

00:33:34.860 --> 00:33:39.750
为我们创建的班级创建一个捕获器

00:33:36.900 --> 00:33:41.130
要检查，所以我们知道我们是

00:33:39.750 --> 00:33:43.290
期待一个预定的线程池

00:33:41.130 --> 00:33:46.950
执行者，这就是为什么要上课的原因

00:33:43.290 --> 00:33:49.860
参数与此一起使用

00:33:46.950 --> 00:33:52.590
在这种情况下，再次测试代码

00:33:49.860 --> 00:33:55.010
您需要像在我们上一样运行它

00:33:52.590 --> 00:33:58.410
先前的测试配置任务和

00:33:55.010 --> 00:34:01.530
通过这烟雾，最后我们

00:33:58.410 --> 00:34:03.990
首先验证并断言我们需要什么

00:34:01.530 --> 00:34:05.310
要做的就是将价值捕捉到

00:34:03.990 --> 00:34:07.260
我们在

00:34:05.310 --> 00:34:10.170
测试的开始，所以我们说

00:34:07.260 --> 00:34:13.470
好吧，请确认此模拟是

00:34:10.170 --> 00:34:15.810
用方法集调用了

00:34:13.470 --> 00:34:17.580
调度程序，此参数已传递

00:34:15.810 --> 00:34:20.760
从这个意义上讲，这只是一个

00:34:17.580 --> 00:34:23.460
俘虏，只有有了我们，我们才能

00:34:20.760 --> 00:34:25.620
断言此绑架者包含

00:34:23.460 --> 00:34:27.780
值，这就是我们调用门值的原因

00:34:25.620 --> 00:34:30.630
所以我们从中获取价值

00:34:27.780 --> 00:34:33.180
绑架者，我们断言

00:34:30.630 --> 00:34:36.360
那里传递的价值有一个池

00:34:33.180 --> 00:34:38.790
大小等于四再增加

00:34:36.360 --> 00:34:41.280
如果有人更换游泳池或

00:34:38.790 --> 00:34:44.190
也许完全删除该方法， 

00:34:41.280 --> 00:34:46.740
使此调度程序成为单线程

00:34:44.190 --> 00:34:52.160
作为默认实现

00:34:46.740 --> 00:34:55.650
测试会在这里找到它，我们终于到了

00:34:52.160 --> 00:34:57.810
回到原来的问题原来

00:34:55.650 --> 00:34:59.670
您记得的问题是我们有多个

00:34:57.810 --> 00:35:02.700
节点，我们希望有一个

00:34:59.670 --> 00:35:05.820
请注意，当它唤醒时会告诉我们

00:35:02.700 --> 00:35:08.580
好的，这是节点

00:35:05.820 --> 00:35:10.650
领导，所以你可以想象有

00:35:08.580 --> 00:35:12.960
完全控制我们不执行的代码

00:35:10.650 --> 00:35:14.970
需要添加任何注释动画

00:35:12.960 --> 00:35:17.850
在我们刚刚编写的代码中

00:35:14.970 --> 00:35:20.010
可以在这里写代码是

00:35:17.850 --> 00:35:22.410
为什么当您在

00:35:20.010 --> 00:35:24.840
这个寄存器上的调度程序实际上是您

00:35:22.410 --> 00:35:26.550
只需传入可执行文件即可

00:35:24.840 --> 00:35:28.690
在cron的第一个参数内

00:35:26.550 --> 00:35:30.640
您可以做任何事情

00:35:28.690 --> 00:35:34.240
所以我们可以在这种情况下做

00:35:30.640 --> 00:35:35.710
如果这位领导人现在又要展示

00:35:34.240 --> 00:35:36.400
你有点改善

00:35:35.710 --> 00:35:39.520
可以做到

00:35:36.400 --> 00:35:42.220
不再像 Spring 一样，所以这就是为什么

00:35:39.520 --> 00:35:46.059
我们可以介绍其他课程

00:35:42.220 --> 00:35:47.910
可以分离所有逻辑

00:35:46.059 --> 00:35:50.380
分成不同的部分，并保持

00:35:47.910 --> 00:35:51.970
责任分开了，所以在这里我们

00:35:50.380 --> 00:35:53.859
说好，这是安排冲突

00:35:51.970 --> 00:35:56.170
类，因此该类仅应

00:35:53.859 --> 00:35:58.599
负责调度部分

00:35:56.170 --> 00:36:00.220
这就是为什么我们在这里再次注入

00:35:58.599 --> 00:36:03.369
与上一个一样处理事件任务

00:36:00.220 --> 00:36:06.880
幻灯片和内部配置任务

00:36:03.369 --> 00:36:09.700
正在创建一个新的类，我们可以

00:36:06.880 --> 00:36:12.250
知道名称领导者的任务装饰器，所以

00:36:09.700 --> 00:36:16.000
装饰器，将创建一个

00:36:12.250 --> 00:36:18.609
反对超越我们的任务

00:36:16.000 --> 00:36:21.640
要运行，它将检查逻辑

00:36:18.609 --> 00:36:24.910
本身，只有这可运行的我们

00:36:21.640 --> 00:36:26.980
将会排在最后

00:36:24.910 --> 00:36:28.539
注册商，所以现在我们有三个

00:36:26.980 --> 00:36:31.000
第一部分是调度， 

00:36:28.539 --> 00:36:32.890
您看到第三部分是，我们

00:36:31.000 --> 00:36:34.420
已经有这是过程

00:36:32.890 --> 00:36:37.299
活动任务，中间有

00:36:34.420 --> 00:36:39.220
这个领导意识的装饰师，这是

00:36:37.299 --> 00:36:42.640
它看起来如何很简单

00:36:39.220 --> 00:36:45.539
至少对我们的这一部分进行编码

00:36:42.640 --> 00:36:48.220
还有另一个可运行的

00:36:45.539 --> 00:36:52.720
另一个可运行的，因为我们可以传递给

00:36:48.220 --> 00:36:55.000
 cron任务，它将需要成员

00:36:52.720 --> 00:36:56.589
基本上它将在一个

00:36:55.000 --> 00:36:58.630
这是为什么我们的特定条件

00:36:56.589 --> 00:37:00.510
需要这个私人可运行委托

00:36:58.630 --> 00:37:04.480
将委托给的代码

00:37:00.510 --> 00:37:06.880
构造函数当然需要通过它

00:37:04.480 --> 00:37:09.760
传递给的方法

00:37:06.880 --> 00:37:12.970
字段和内部运行方法

00:37:09.760 --> 00:37:15.460
现在可以把检查

00:37:12.970 --> 00:37:18.910
该节点仅在此处是领导者

00:37:15.460 --> 00:37:20.799
在这里处理任务，然后我们

00:37:18.910 --> 00:37:23.700
只会调用委托运行到最后

00:37:20.799 --> 00:37:28.270
整个图片的一部分

00:37:23.700 --> 00:37:29.950
好的，所以我们采用了这种方法

00:37:28.270 --> 00:37:32.049
第二种方法是

00:37:29.950 --> 00:37:35.890
很好，那是它正在工作，但是

00:37:32.049 --> 00:37:37.809
实际上我们发现它仍然是

00:37:35.890 --> 00:37:39.880
仍然不完美，这仍然是一个问题

00:37:37.809 --> 00:37:42.220
特别是在有网络的情况下

00:37:39.880 --> 00:37:43.839
分区或有人称它

00:37:42.220 --> 00:37:46.660
有人称它为裂脑

00:37:43.839 --> 00:37:49.869
问题，这就是为什么我想给你看

00:37:46.660 --> 00:37:51.819
这个看起来可能很复杂，但是

00:37:49.869 --> 00:37:55.780
一会儿会清楚吗

00:37:51.819 --> 00:37:57.280
这个问题可能会出现直到

00:37:55.780 --> 00:38:01.329
时间表是时间如何

00:37:57.280 --> 00:38:05.109
通过和垂直线

00:38:01.329 --> 00:38:06.579
基本上是不同的组件

00:38:05.109 --> 00:38:09.250
系统的，所以我们有这个

00:38:06.579 --> 00:38:11.710
保留信息的协调器

00:38:09.250 --> 00:38:13.960
哪个实例是领导者，我们有

00:38:11.710 --> 00:38:16.299
两个实例，让我们说一些

00:38:13.960 --> 00:38:18.520
在某个时刻实例是谁醒来的

00:38:16.299 --> 00:38:22.150
因为它想运行某些东西而

00:38:18.520 --> 00:38:23.650
因为我们使用它是说如果

00:38:22.150 --> 00:38:26.260
领导者标注或第二种方法

00:38:23.650 --> 00:38:28.410
它在处理某些东西之前会询问

00:38:26.260 --> 00:38:30.670
问Orchestrator好吧，我应该继续吗

00:38:28.410 --> 00:38:33.549
协调响应是的，你是一个

00:38:30.670 --> 00:38:36.099
现在是领导者，因此实例一开始， 

00:38:33.549 --> 00:38:37.690
开始处理事件，但在

00:38:36.099 --> 00:38:39.549
在此之前

00:38:37.690 --> 00:38:41.619
正在处理网络分区

00:38:39.549 --> 00:38:43.930
金属隔板基本上意味着

00:38:41.619 --> 00:38:45.039
这两个节点无法通信

00:38:43.930 --> 00:38:48.849
彼此在一起

00:38:45.039 --> 00:38:51.510
和Orchestrator的逻辑如何

00:38:48.849 --> 00:38:53.950
保持不装备

00:38:51.510 --> 00:38:55.809
注释是否为领导者的信息是

00:38:53.950 --> 00:38:58.270
基本上保持公开会议

00:38:55.809 --> 00:39:00.849
在这些节点之间，通常

00:38:58.270 --> 00:39:06.039
需要检查健康终点

00:39:00.849 --> 00:39:09.130
的节点是好的，它坏了，让我们

00:39:06.039 --> 00:39:10.809
说在这种情况下，然后Orchestrator 

00:39:09.130 --> 00:39:13.210
它当然需要选择一个新的

00:39:10.809 --> 00:39:15.309
领导者，这就是这里发生的

00:39:13.210 --> 00:39:17.260
会话破坏了Orchestrator的内容

00:39:15.309 --> 00:39:19.329
好吧，让我们注意到它不可能是

00:39:17.260 --> 00:39:21.279
领导者了，我们需要一个新的，所以

00:39:19.329 --> 00:39:24.549
选择一个新的领导者，无论如何

00:39:21.279 --> 00:39:26.950
通常是最旧的节点，但是在此

00:39:24.549 --> 00:39:29.220
情况并不重要，因此选择

00:39:26.950 --> 00:39:32.109
实例二不时

00:39:29.220 --> 00:39:34.180
几秒钟后再说实例

00:39:32.109 --> 00:39:36.700
现在两个想要在一个

00:39:34.180 --> 00:39:38.200
预定的方式并询问Orchestrator我是

00:39:36.700 --> 00:39:40.270
领导者，当然还有收银员

00:39:38.200 --> 00:39:42.010
是的，因为他只是选择了它

00:39:40.270 --> 00:39:44.289
实例二处理事件

00:39:42.010 --> 00:39:47.230
将其存储到外部服务中

00:39:44.289 --> 00:39:48.880
最后也突然实例一

00:39:47.230 --> 00:39:51.579
真的很慢，但是不是

00:39:48.880 --> 00:39:54.640
下来也会唤醒并将其保存到

00:39:51.579 --> 00:39:56.080
外部服务现在会发生什么

00:39:54.640 --> 00:39:59.110
有两个事件

00:39:56.080 --> 00:40:01.540
通常在外部服务上

00:39:59.110 --> 00:40:04.360
如果你不应该这样

00:40:01.540 --> 00:40:07.120
不应该这样，所以我们怎么可以

00:40:04.360 --> 00:40:09.400
我们可以处理如何改进

00:40:07.120 --> 00:40:13.360
我喜欢的弹性解决方案

00:40:09.400 --> 00:40:16.480
当然，甚至还有上一张幻灯片

00:40:13.360 --> 00:40:18.480
可能有点复杂，但是我们

00:40:16.480 --> 00:40:20.860
可以想到更简单的事情

00:40:18.480 --> 00:40:23.020
假设我们有这份预定的工作

00:40:20.860 --> 00:40:24.940
试图保存一些东西到

00:40:23.020 --> 00:40:27.280
外部服务和响应

00:40:24.940 --> 00:40:28.900
没来，只是普通的HTTP调用

00:40:27.280 --> 00:40:31.150
比方说，回应没有来

00:40:28.900 --> 00:40:33.250
所以节点可以知道什么

00:40:31.150 --> 00:40:35.410
节点可以做什么就可以了

00:40:33.250 --> 00:40:38.230
可以重复，如果他们重复那么我们

00:40:35.410 --> 00:40:40.090
必须复制条目正确，所以可以

00:40:38.230 --> 00:40:42.820
我们甚至安全地重复我们的制作方法

00:40:40.090 --> 00:40:47.350
确保重复不会

00:40:42.820 --> 00:40:49.240
整个业务逻辑破裂了

00:40:47.350 --> 00:40:51.010
从根本上确保没有

00:40:49.240 --> 00:40:54.070
在中创建的重复条目

00:40:51.010 --> 00:40:56.830
外部服务及解决方案

00:40:54.070 --> 00:41:02.580
通常是某种ID 

00:40:56.830 --> 00:41:05.470
主要是命名这是一个身份

00:41:02.580 --> 00:41:07.120
幂等ID，这就是为什么我们需要

00:41:05.470 --> 00:41:08.710
确保我们所采取的行动

00:41:07.120 --> 00:41:12.040
表演不是幂等的

00:41:08.710 --> 00:41:15.700
在这种情况下，幂等

00:41:12.040 --> 00:41:18.100
意味着我们将通过的行动

00:41:15.700 --> 00:41:19.960
我们将执行的动作或

00:41:18.100 --> 00:41:22.630
传递给外部的物品

00:41:19.960 --> 00:41:25.270
服务将包含一些唯一的ID， 

00:41:22.630 --> 00:41:27.490
具有此ID的外部服务可以

00:41:25.270 --> 00:41:29.860
说好，我已经处理了，所以我会

00:41:27.490 --> 00:41:32.500
跳过它并将其发送回给您

00:41:29.860 --> 00:41:37.830
这是重复的，但没有伤害

00:41:32.500 --> 00:41:40.180
什么都没有存储两次，这就是为什么我们

00:41:37.830 --> 00:41:42.760
通过实施，我们现在可以

00:41:40.180 --> 00:41:46.090
说一个或多个相同的请求

00:41:42.760 --> 00:41:48.820
给出相同的结果，所以即使您现在

00:41:46.090 --> 00:41:51.370
当然重复100次

00:41:48.820 --> 00:41:53.650
您每次都提供相同的ID 

00:41:51.370 --> 00:41:55.480
现在，外部服务将确保

00:41:53.650 --> 00:41:58.870
它将不会发生，并且

00:41:55.480 --> 00:42:00.340
此网络的先前案例

00:41:58.870 --> 00:42:03.910
分区将无法正确处理

00:42:00.340 --> 00:42:07.640
因为如果我们提供相同的ID- 

00:42:03.910 --> 00:42:10.340
 -两个音符的音调相同

00:42:07.640 --> 00:42:16.400
同一条目只能创建一次

00:42:10.340 --> 00:42:17.900
因为我们将其拆分，所以我希望

00:42:16.400 --> 00:42:19.820
您从一开始就记得我们存储

00:42:17.900 --> 00:42:21.560
数据库中的所有内容，所以这是

00:42:19.820 --> 00:42:24.140
当你应该创建一个

00:42:21.560 --> 00:42:26.120
项目效用ID，因此只要有

00:42:24.140 --> 00:42:29.720
需要处理的东西会产生一个新的

00:42:26.120 --> 00:42:32.680
 ID和事件的发送时间

00:42:29.720 --> 00:42:35.690
它使用此ID的任何节点，然后使用此

00:42:32.680 --> 00:42:40.820
可以确定，我们可以确定

00:42:35.690 --> 00:42:44.600
对我们来说不是问题好吧

00:42:40.820 --> 00:42:46.640
关于我们也想要的不同解决方案

00:42:44.600 --> 00:42:48.740
总是谈论一些改进

00:42:46.640 --> 00:42:52.010
什么可能是可以处理的

00:42:48.740 --> 00:42:53.930
更好，所以我们先做了改进

00:42:52.010 --> 00:42:56.360
谈论的是

00:42:53.930 --> 00:42:59.330
也许我们可以分配工作，如果

00:42:56.360 --> 00:43:03.170
待处理的项目数量突然增加

00:42:59.330 --> 00:43:04.700
成长也许我们应该通过

00:43:03.170 --> 00:43:06.650
不同的节点多个

00:43:04.700 --> 00:43:10.310
多个节点基本相同

00:43:06.650 --> 00:43:12.500
时间，第一个想到的主意

00:43:10.310 --> 00:43:14.540
对我的同事来说，也许我们可以

00:43:12.500 --> 00:43:16.010
只需使用我们已经有PostgreSQL的

00:43:14.540 --> 00:43:19.100
事件真相的来源

00:43:16.010 --> 00:43:21.590
过程，所以也许我们可以用它来

00:43:19.100 --> 00:43:23.210
基本上说好，这就是你的方式

00:43:21.590 --> 00:43:26.450
可以处理，这就是来源

00:43:23.210 --> 00:43:28.790
如果节点是否为真，则为true 

00:43:26.450 --> 00:43:31.580
应该处理还是不处理，就我们而言

00:43:28.790 --> 00:43:33.320
我们有一个进度SQL数据库，所以您

00:43:31.580 --> 00:43:35.420
可以使用for更新子句

00:43:33.320 --> 00:43:37.700
所以每当一个节点拿东西时

00:43:35.420 --> 00:43:41.030
从数据库中对其进行处理可以标记

00:43:37.700 --> 00:43:43.940
要处理的行

00:43:41.030 --> 00:43:45.770
用于更新和另一个节点

00:43:43.940 --> 00:43:48.260
是否会经历事件

00:43:45.770 --> 00:43:50.480
检查节点是否项目

00:43:48.260 --> 00:43:54.170
应该处理还是不可以

00:43:50.480 --> 00:43:57.980
跳过锁定的项目，但就像一个

00:43:54.170 --> 00:43:59.750
盖在这里看起来不错，但实际上

00:43:57.980 --> 00:44:03.620
可能存在性能问题

00:43:59.750 --> 00:44:07.250
因为如果您用

00:44:03.620 --> 00:44:08.720
更新然后另一个节点需要

00:44:07.250 --> 00:44:12.170
基本上任何一个都通过

00:44:08.720 --> 00:44:14.090
他们并跳过所有跳过这些

00:44:12.170 --> 00:44:16.250
也许然后性能会提高

00:44:14.090 --> 00:44:20.530
但最后可能是

00:44:16.250 --> 00:44:23.690
一个问题，所以这不是

00:44:20.530 --> 00:44:25.940
发现了可能解决我们的方法

00:44:23.690 --> 00:44:28.400
需要考虑更好的方法来

00:44:25.940 --> 00:44:30.559
处理这个，因为另一个解决方案

00:44:28.400 --> 00:44:33.260
我们在思考和工作的

00:44:30.559 --> 00:44:36.440
 sq SQ是我们系统之一

00:44:33.260 --> 00:44:37.970
这是一个队列解决方案或任何其他解决方案

00:44:36.440 --> 00:44:40.760
基本上，您会排队

00:44:37.970 --> 00:44:42.440
想想，SQS队列可能是一个

00:44:40.760 --> 00:44:44.839
项目真实来源

00:44:42.440 --> 00:44:46.640
因此，只要流消费者

00:44:44.839 --> 00:44:49.010
消耗将被放入的东西

00:44:46.640 --> 00:44:51.980
桌上USQ，它可以由

00:44:49.010 --> 00:44:54.079
不同的实例和过程可以

00:44:51.980 --> 00:44:57.140
工作，因为我们知道我提到

00:44:54.079 --> 00:45:00.200
实例（如果有）标记

00:44:57.140 --> 00:45:02.210
它对其他人不可见，但是在这里

00:45:00.200 --> 00:45:06.619
另一个问题是sqs队列是

00:45:02.210 --> 00:45:09.290
不是完整的数据库，只是一个队列

00:45:06.619 --> 00:45:12.740
以及一个项目可以使用的最长时间

00:45:09.290 --> 00:45:14.540
在SQL中存储是14天，因此在最坏的情况下

00:45:12.740 --> 00:45:16.819
事件确实发生的情况

00:45:14.540 --> 00:45:19.849
真的很慢，或者有问题

00:45:16.819 --> 00:45:21.559
应用程序，或者我不知道

00:45:19.849 --> 00:45:23.180
有人在度假，不会看起来

00:45:21.559 --> 00:45:25.940
在队列中，事件只会

00:45:23.180 --> 00:45:27.859
消失了，所以也许它将扩大

00:45:25.940 --> 00:45:31.250
正确，但也许不会执行

00:45:27.859 --> 00:45:33.230
这是合乎逻辑的，那是什么

00:45:31.250 --> 00:45:37.040
经验教训，我们与

00:45:33.230 --> 00:45:39.680
这个简短的短期会议注释

00:45:37.040 --> 00:45:43.579
始终谨慎地驱动开发

00:45:39.680 --> 00:45:44.839
看起来很简单很方便，但是您需要

00:45:43.579 --> 00:45:49.220
要知道有一些

00:45:44.839 --> 00:45:52.460
代码一致性的缺点是

00:45:49.220 --> 00:45:55.970
确保重要的事情我们

00:45:52.460 --> 00:45:58.010
喜欢使用相同的方法或

00:45:55.970 --> 00:46:00.140
这肯定是您创建自己的方式

00:45:58.010 --> 00:46:02.030
然后你可以注入它

00:46:00.140 --> 00:46:04.280
考虑到这一点使代码

00:46:02.030 --> 00:46:05.750
易于维护且易于维护

00:46:04.280 --> 00:46:10.250
了解团队的新成员

00:46:05.750 --> 00:46:13.040
我们也可以考虑弹性

00:46:10.250 --> 00:46:16.309
这里多次提到，例如

00:46:13.040 --> 00:46:16.849
这里的一般想法激酶

00:46:16.309 --> 00:46:18.890
流

00:46:16.849 --> 00:46:20.359
这增加了弹性，因为我们

00:46:18.890 --> 00:46:21.859
不再同步

00:46:20.359 --> 00:46:24.140
服务之间的沟通，但我们

00:46:21.859 --> 00:46:28.430
只是发送事件和可预测性

00:46:24.140 --> 00:46:31.250
也会增长，因为ServiceNow可以说确定

00:46:28.430 --> 00:46:33.740
我处理了这个事件，我就完成了

00:46:31.250 --> 00:46:34.020
没有问题的响应没有问题

00:46:33.740 --> 00:46:37.140
平静

00:46:34.020 --> 00:46:40.140
和事情，我们也可以考虑

00:46:37.140 --> 00:46:42.900
可观察性是这里的一个例子

00:46:40.140 --> 00:46:44.310
我提到了这种线程化的命名方式

00:46:42.900 --> 00:46:47.400
你特别看你的锁

00:46:44.310 --> 00:46:50.280
在大型应用程序中可以是

00:46:47.400 --> 00:46:53.630
当您当您

00:46:50.280 --> 00:46:56.100
有标有适当螺纹的锁

00:46:53.630 --> 00:46:57.780
非常感谢您的henshin和

00:46:56.100 --> 00:47:13.620
如果您可能需要几分钟的时间

00:46:57.780 --> 00:47:22.470
问题我有问题的麦克风是

00:47:13.620 --> 00:47:26.520
基本上我想问为什么问

00:47:22.470 --> 00:47:29.100
我们q而不是别的，如果你

00:47:26.520 --> 00:47:33.360
问题是您无法启动

00:47:29.100 --> 00:47:34.980
数据超过40天，因此您认为

00:47:33.360 --> 00:47:37.740
其他一些完整的解决方案或类似

00:47:34.980 --> 00:47:40.980
其他问或你的意思是对的

00:47:37.740 --> 00:47:45.690
是的，为什么不选择卡夫卡呢？ 

00:47:40.980 --> 00:47:46.980
是的，我认为卡夫卡在我们

00:47:45.690 --> 00:47:50.310
公司，我们还没有使用它

00:47:46.980 --> 00:47:52.710
所以也许可以说是第三次迭代

00:47:50.310 --> 00:47:54.900
那行得通，我同意卡夫卡是一个

00:47:52.710 --> 00:47:57.150
很好的解决方案，但是因为我们

00:47:54.900 --> 00:48:00.570
我们公司还没有

00:47:57.150 --> 00:48:02.910
所以首先是安装它的问题

00:48:00.570 --> 00:48:06.570
维护并基本拥有

00:48:02.910 --> 00:48:08.880
我们的系统，现在的人们

00:48:06.570 --> 00:48:11.550
需要学习，是的，因为我们

00:48:08.880 --> 00:48:13.080
在AWS上，我们通常尝试使用

00:48:11.550 --> 00:48:15.840
那里可用的组件

00:48:13.080 --> 00:48:18.420
但我同意卡夫卡可能会

00:48:15.840 --> 00:48:20.480
将在这里解决很多问题，谢谢

00:48:18.420 --> 00:48:20.480
您

00:48:25.730 --> 00:48:32.759
您如何解决该问题？ 

00:48:28.230 --> 00:48:36.869
协调员不好的问题

00:48:32.759 --> 00:48:39.450
所以在我们的情况下，我们有一个解决方案

00:48:36.869 --> 00:48:41.579
具有的其他解决方案也是

00:48:39.450 --> 00:48:42.779
基本上分布在

00:48:41.579 --> 00:48:46.259
您需要分发的第三个系统

00:48:42.779 --> 00:48:48.630
一切，而这个笔记是

00:48:46.259 --> 00:48:50.430
也缩放，所以没有单个音符

00:48:48.630 --> 00:48:52.740
因此没有单点故障

00:48:50.430 --> 00:48:55.170
当然，也许所有笔记都可以

00:48:52.740 --> 00:48:57.480
缩小，但理想情况下，您希望按比例缩小

00:48:55.170 --> 00:48:59.910
出来，所以应该有，如果您使用

00:48:57.480 --> 00:49:02.549
没有Mongo或Reddy的例子

00:48:59.910 --> 00:49:05.009
一些辅助节点可以帮助

00:49:02.549 --> 00:49:09.329
这种情况，是的，不应该这样，我

00:49:05.009 --> 00:49:11.279
也许我的照片有点不在

00:49:09.329 --> 00:49:14.220
细节，但基本上不是一个

00:49:11.279 --> 00:49:16.079
请注意，这就像

00:49:14.220 --> 00:49:18.329
系统，但可以有所不同

00:49:16.079 --> 00:49:20.400
请注意，该操作相同并且可以

00:49:18.329 --> 00:49:23.009
可以在它们之间切换，所以你的意思是

00:49:20.400 --> 00:49:25.920
理想情况下，协调器集群

00:49:23.009 --> 00:49:27.509
编排哦，是的，所有人都喜欢

00:49:25.920 --> 00:49:29.819
如果这是redis那边，那么你

00:49:27.509 --> 00:49:36.599
基本上已经分发到

00:49:29.819 --> 00:49:40.259
数据库谢谢，我想知道

00:49:36.599 --> 00:49:42.269
 ESB是否可以帮助您保持现状

00:49:40.259 --> 00:49:45.599
在整个过程中订购物品

00:49:42.269 --> 00:49:47.789
你考虑过可以重复吗

00:49:45.599 --> 00:49:50.460
问题的开始，我当时

00:49:47.789 --> 00:49:52.920
想知道ESB企业服务是否

00:49:50.460 --> 00:49:55.319
巴士将帮助您保持秩序

00:49:52.920 --> 00:49:58.710
世界上的事情如此

00:49:55.319 --> 00:50:02.609
 Orchestrator项目计划和项目

00:49:58.710 --> 00:50:05.400
等等，所以我不得不说我不

00:50:02.609 --> 00:50:07.230
知道这是我们没有的东西

00:50:05.400 --> 00:50:11.789
考虑一下，我不知道

00:50:07.230 --> 00:50:13.739
有一些解决方案，但也许

00:50:11.789 --> 00:50:15.779
我们还没有达到这个水平吗

00:50:13.739 --> 00:50:17.339
这里的复杂度

00:50:15.779 --> 00:50:20.700
交通还不存在，我们需要

00:50:17.339 --> 00:50:22.559
介绍一些复杂的东西

00:50:20.700 --> 00:50:23.700
究竟是什么样的解决方案

00:50:22.559 --> 00:50:27.089
你有没有想过

00:50:23.700 --> 00:50:31.499
你能给什么命名，例如m子

00:50:27.089 --> 00:50:32.790
正在使用连接器，一个连接器用于

00:50:31.499 --> 00:50:36.480
每

00:50:32.790 --> 00:50:38.520
在我们执行者的任务将是一个

00:50:36.480 --> 00:50:39.960
协调器显然是班级设置

00:50:38.520 --> 00:50:44.220
解决方案这个叫什么名字

00:50:39.960 --> 00:50:47.130
 ESB解决方案，例如a子

00:50:44.220 --> 00:50:49.020
发生例子是的，所以又是另一个

00:50:47.130 --> 00:50:51.150
改善可能是到什么时候

00:50:49.020 --> 00:50:55.260
当工作量是

00:50:51.150 --> 00:51:02.520
它的增加和处理

00:50:55.260 --> 00:51:05.870
高，那么肯定谢谢你看起来像

00:51:02.520 --> 00:51:05.870
非常感谢您的问题

00:51:08.450 --> 00:51:13.980
 [音乐] 

