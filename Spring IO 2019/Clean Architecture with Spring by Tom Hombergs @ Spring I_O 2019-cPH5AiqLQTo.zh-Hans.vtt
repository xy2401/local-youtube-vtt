WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.900 --> 00:00:10.900
 [音乐] 

00:00:07.230 --> 00:00:12.070
是的，谢谢你能听到我好吗，谢谢

00:00:10.900 --> 00:00:14.530
为介绍

00:00:12.070 --> 00:00:16.900
马克在宣告我的发音方面做得很好

00:00:14.530 --> 00:00:20.080
我没想到他能做到

00:00:16.900 --> 00:00:23.290
他是的，我要谈论清洁

00:00:20.080 --> 00:00:25.240
今天的建筑有点话

00:00:23.290 --> 00:00:27.940
关于我，我是

00:00:25.240 --> 00:00:29.950
德国的adesso是软件

00:00:27.940 --> 00:00:32.349
顾问，所以我去过

00:00:29.950 --> 00:00:36.249
最近十二年的咨询业务

00:00:32.349 --> 00:00:39.579
年做java主要做一点

00:00:36.249 --> 00:00:43.829
一点开源，我就用了

00:00:39.579 --> 00:00:46.870
今天早上有这张截图

00:00:43.829 --> 00:00:48.879
让它保持最新状态我只是看这里

00:00:46.870 --> 00:00:51.519
四月这里出事了

00:00:48.879 --> 00:00:55.839
我认为github有错误或其他问题

00:00:51.519 --> 00:00:58.019
如果我考虑一下的话

00:00:55.839 --> 00:01:01.089
那是我目前的项目时间

00:00:58.019 --> 00:01:04.089
开始进入热销阶​​段

00:01:01.089 --> 00:01:06.910
而且没有时间开放

00:01:04.089 --> 00:01:08.770
来源，然后好，这样就足够了

00:01:06.910 --> 00:01:11.770
我我要谈论清洁

00:01:08.770 --> 00:01:14.200
一般而言，架构

00:01:11.770 --> 00:01:16.150
要激励什么干净

00:01:14.200 --> 00:01:18.310
建筑大约是六角形

00:01:16.150 --> 00:01:22.240
建筑作为清洁的实例

00:01:18.310 --> 00:01:24.670
建筑，但首先我要谈

00:01:22.240 --> 00:01:29.920
关于分层的建筑风格

00:01:24.670 --> 00:01:34.030
我们都很喜欢谁做了

00:01:29.920 --> 00:01:35.160
项目手中的分层体系结构

00:01:34.030 --> 00:01:37.900
上

00:01:35.160 --> 00:01:41.080
是的，我猜几乎每个人

00:01:37.900 --> 00:01:43.150
显然我正在展示这个

00:01:41.080 --> 00:01:44.770
仅滑动以设置分层

00:01:43.150 --> 00:01:47.430
与其他建筑进行比较

00:01:44.770 --> 00:01:51.670
更好的建筑风格

00:01:47.430 --> 00:01:54.220
所以请随身携带烂番茄

00:01:51.670 --> 00:01:58.740
我要扑的时候把它们扔给我

00:01:54.220 --> 00:02:02.590
在分层架构上，但首先

00:01:58.740 --> 00:02:06.430
在我们讨论利弊之前

00:02:02.590 --> 00:02:10.829
不同的建筑风格让我们

00:02:06.430 --> 00:02:14.810
谈论什么是架构

00:02:10.829 --> 00:02:17.150
那么为什么我们实际上要打扰

00:02:14.810 --> 00:02:23.189
根本不是我们的建筑

00:02:17.150 --> 00:02:25.950
编码并投入生产

00:02:23.189 --> 00:02:29.090
他们做到了，所有的工作都对我有效

00:02:25.950 --> 00:02:29.090
机器，所以它应该在那里工作

00:02:29.239 --> 00:02:33.959
什么是架构

00:02:31.799 --> 00:02:35.969
任何人的建筑目标为何

00:02:33.959 --> 00:02:40.219
我们在做什么为什么我们在考虑

00:02:35.969 --> 00:02:47.629
建筑就把它扔给我

00:02:40.219 --> 00:02:51.030
那可读性还可以的可用性是什么

00:02:47.629 --> 00:02:54.379
实际上，您可以找到的任何灵活性

00:02:51.030 --> 00:02:58.230
对，是的，你是完全正确的

00:02:54.379 --> 00:03:03.359
有些人认为建筑是

00:02:58.230 --> 00:03:06.510
关于使它工作

00:03:03.359 --> 00:03:09.150
我们正在构建的软件显然

00:03:06.510 --> 00:03:12.569
当我们在思考何时做

00:03:09.150 --> 00:03:14.939
架构不应该成为障碍

00:03:12.569 --> 00:03:18.689
制作我们正在构建的软件

00:03:14.939 --> 00:03:21.299
工作，所以我们的架构应该启用

00:03:18.689 --> 00:03:25.340
实际实施的软件

00:03:21.299 --> 00:03:28.650
给我们的要求，但是

00:03:25.340 --> 00:03:31.409
那里有一个软件

00:03:28.650 --> 00:03:36.329
糟糕的架构，但仍然

00:03:31.409 --> 00:03:41.579
最有效的101个很好的例子是

00:03:36.329 --> 00:03:42.930
我们在阿德索购买了自己的ERP系统

00:03:41.579 --> 00:03:46.199
它不是我们自己建造的

00:03:42.930 --> 00:03:51.000
没有，我们没有做错任何事情

00:03:46.199 --> 00:03:53.659
除了买它，但是它有一个

00:03:51.000 --> 00:03:56.569
糟糕的架构，当您将其用作

00:03:53.659 --> 00:03:59.459
软件工程师跟踪您的时间并

00:03:56.569 --> 00:04:02.159
跟踪发票和类似您的东西

00:03:59.459 --> 00:04:04.139
只是觉得这是一个糟糕的架构

00:04:02.159 --> 00:04:07.949
在你下面有相同的形式

00:04:04.139 --> 00:04:13.439
每个页面上的每个页面都有一个非常

00:04:07.949 --> 00:04:16.979
用户体验不好，所以，但是我们

00:04:13.439 --> 00:04:18.989
工作，我们就盈利，我们就

00:04:16.979 --> 00:04:22.340
通过该系统创建发票

00:04:18.989 --> 00:04:24.340
发票甚至被支付

00:04:22.340 --> 00:04:26.590
有用

00:04:24.340 --> 00:04:29.560
但这只能工作，因为我们必须使用

00:04:26.590 --> 00:04:31.780
所以那里有软件

00:04:29.560 --> 00:04:35.740
架构不好，就是这样

00:04:31.780 --> 00:04:40.210
尽管如此，所以这不是

00:04:35.740 --> 00:04:43.000
建筑的主要目标是正确的

00:04:40.210 --> 00:04:45.040
具有所有能力的是

00:04:43.000 --> 00:04:48.040
质量决定了质量

00:04:45.040 --> 00:04:50.050
对我们架构的要求

00:04:48.040 --> 00:04:54.070
这就是架构的意义所在

00:04:50.050 --> 00:04:56.370
关于促进整体发展

00:04:54.070 --> 00:04:59.470
促进发展的经验

00:04:56.370 --> 00:05:01.180
促进部署到生产或

00:04:59.470 --> 00:05:03.460
甚至测试环境

00:05:01.180 --> 00:05:06.340
是为了方便维护

00:05:03.460 --> 00:05:07.960
因为维护更昂贵

00:05:06.340 --> 00:05:13.780
比实际构建软件

00:05:07.960 --> 00:05:15.790
最初，有了这些T，我们

00:05:13.780 --> 00:05:19.330
试图用建筑来实现

00:05:15.790 --> 00:05:24.460
我们正在努力使软件保持软性

00:05:19.330 --> 00:05:27.490
所以这三个词是

00:05:24.460 --> 00:05:29.890
罗伯特·马丁（Robert Martin）干净书中的名言

00:05:27.490 --> 00:05:32.860
建筑，所以我们要保持

00:05:29.890 --> 00:05:34.419
软件软，因为软件

00:05:32.860 --> 00:05:37.660
软件的含义是

00:05:34.419 --> 00:05:40.500
灵活，我们可以，我们可以推动

00:05:37.660 --> 00:05:43.900
我们可以戳它，它会改变

00:05:40.500 --> 00:05:46.440
与您所使用的硬件相比

00:05:43.900 --> 00:05:50.590
实际上必须打破事物， 

00:05:46.440 --> 00:05:52.930
重新组装它们，我们要保留

00:05:50.590 --> 00:05:56.710
框架相距不远，所以我们不

00:05:52.930 --> 00:05:58.389
想要建立在

00:05:56.710 --> 00:06:00.370
我们不想绑定到的框架

00:05:58.389 --> 00:06:03.310
框架太多，因为如果

00:06:00.370 --> 00:06:06.870
框架变更我们必须改变我们的

00:06:03.310 --> 00:06:10.210
商业二氧化碳，我们希望避免这种情况

00:06:06.870 --> 00:06:13.300
我们想要保持选项打开

00:06:10.210 --> 00:06:16.750
让我们想在

00:06:13.300 --> 00:06:21.669
最轻的时刻，并保持我们

00:06:16.750 --> 00:06:22.990
选项打开，直到那时目标

00:06:21.669 --> 00:06:25.690
软件的最终目标

00:06:22.990 --> 00:06:28.780
体系结构是为了最大限度地减少寿命

00:06:25.690 --> 00:06:31.690
软件成本终生成本

00:06:28.780 --> 00:06:33.070
当然意味着开发成本，但是

00:06:31.690 --> 00:06:37.000
这也意味着维护成本

00:06:33.070 --> 00:06:38.129
之后，因为那是我不知道

00:06:37.000 --> 00:06:41.819
数字但是

00:06:38.129 --> 00:06:44.009
维修是我不知道的因素

00:06:41.819 --> 00:06:50.339
比实际贵多少

00:06:44.009 --> 00:06:52.349
建立它，所以现在我们知道目标

00:06:50.339 --> 00:06:55.249
软件体系结构的目的是最大程度地减少

00:06:52.349 --> 00:06:58.709
保持期权开放及一切所需的成本

00:06:55.249 --> 00:07:03.199
我介绍了层架构， 

00:06:58.709 --> 00:07:03.199
开始，所以层怎么了

00:07:05.209 --> 00:07:09.539
首先，在我开始扑扑之前

00:07:07.679 --> 00:07:12.929
分层架构并被抛出

00:07:09.539 --> 00:07:14.969
与烂番茄一起

00:07:12.929 --> 00:07:18.719
免责声明层是坚实的

00:07:14.969 --> 00:07:21.929
建筑模式，我们有一个理由

00:07:18.719 --> 00:07:25.289
为什么我们都这样做，如果您做对了

00:07:21.929 --> 00:07:26.999
那是一个完美的完美决定

00:07:25.289 --> 00:07:33.800
做一个分层的架构

00:07:26.999 --> 00:07:33.800
我自己在当前项目中，但之前

00:07:34.129 --> 00:07:42.990
但是根据我的经验

00:07:39.239 --> 00:07:46.469
没有更多限制的架构

00:07:42.990 --> 00:07:48.589
不仅可以调用一层

00:07:46.469 --> 00:07:50.999
第二层第二层可以调用第三层

00:07:48.589 --> 00:07:52.529
这是唯一的限制

00:07:50.999 --> 00:07:55.349
分层架构，如果您不放

00:07:52.529 --> 00:07:58.139
对此有更多限制

00:07:55.349 --> 00:08:03.809
很容易出现设计缺陷

00:07:58.139 --> 00:08:09.300
随着时间的流逝，请保持这一状态

00:08:03.809 --> 00:08:16.649
如果我正在扑打，请记住免责声明

00:08:09.300 --> 00:08:17.879
在分层架构上，所以很好

00:08:16.649 --> 00:08:21.829
分层架构是一个很好的

00:08:17.879 --> 00:08:25.829
建筑，但我有一件事

00:08:21.829 --> 00:08:31.159
在中观察到很多项目

00:08:25.829 --> 00:08:34.949
我实际所做的经验

00:08:31.159 --> 00:08:37.949
数据库驱动的设计在我们很多

00:08:34.949 --> 00:08:40.469
分层架构是什么意思

00:08:37.949 --> 00:08:43.979
这意味着我们有一个服务层

00:08:40.469 --> 00:08:46.110
 regice或业务领域层

00:08:43.979 --> 00:08:48.149
里面是红色的

00:08:46.110 --> 00:08:49.080
幻灯片，我们有一个持久层

00:08:48.149 --> 00:08:53.490
这是

00:08:49.080 --> 00:08:56.130
在域层，我们有

00:08:53.490 --> 00:08:58.529
无状态服务

00:08:56.130 --> 00:09:01.310
实施业务的东西

00:08:58.529 --> 00:09:05.990
实现主要逻辑的逻辑

00:09:01.310 --> 00:09:09.930
在我们的持久层中，通常

00:09:05.990 --> 00:09:13.649
实体类，例如

00:09:09.930 --> 00:09:17.399
 JPA实体是一个存储库

00:09:13.649 --> 00:09:21.120
 spring data JP一个存储库，也许

00:09:17.399 --> 00:09:23.610
这使得这耦合域

00:09:21.120 --> 00:09:26.940
我们服务中的逻辑对

00:09:23.610 --> 00:09:31.470
数据库为什么是因为

00:09:26.940 --> 00:09:35.490
实体具有所有JPA批注

00:09:31.470 --> 00:09:39.860
诸如此类的东西以及我们的服务

00:09:35.490 --> 00:09:43.230
如果我们直接使用JPA实体

00:09:39.860 --> 00:09:47.370
我们必须照顾懒惰

00:09:43.230 --> 00:09:51.630
加载以及可以进行的所有操作

00:09:47.370 --> 00:09:54.390
使用像JP这样的JPA III是非常错误的

00:09:51.630 --> 00:09:58.260
我经常使用它我非常喜欢使用它

00:09:54.390 --> 00:10:00.930
但根据我的经验， 

00:09:58.260 --> 00:10:03.690
实际解决我们领域中的问题

00:10:00.930 --> 00:10:07.890
应在

00:10:03.690 --> 00:10:10.770
持久层，所以这些夫妇是

00:10:07.890 --> 00:10:12.839
数据库或数据库的主要逻辑

00:10:10.770 --> 00:10:15.600
至少到数据库到

00:10:12.839 --> 00:10:19.860
数据库之前的持久层

00:10:15.600 --> 00:10:21.959
通常我们是从安装开始

00:10:19.860 --> 00:10:23.760
当我们开发一个

00:10:21.959 --> 00:10:25.980
某些用例，我们从

00:10:23.760 --> 00:10:27.510
底层，我们开始创建

00:10:25.980 --> 00:10:30.149
我们从创建一个实体开始

00:10:27.510 --> 00:10:31.890
创建一个存储库

00:10:30.149 --> 00:10:35.310
数据库表数据库结构

00:10:31.890 --> 00:10:38.209
只有这样我们才能进入域

00:10:35.310 --> 00:10:40.170
层并构建我们的应用程序逻辑

00:10:38.209 --> 00:10:41.970
什么时候应该相反

00:10:40.170 --> 00:10:46.589
我们应该先建立业务逻辑

00:10:41.970 --> 00:10:48.839
然后关心那些

00:10:46.589 --> 00:10:51.690
数据库和持久性在那里，因为

00:10:48.839 --> 00:10:54.199
业务逻辑更重要

00:10:51.690 --> 00:10:54.199
码

00:10:54.980 --> 00:10:59.940
关于分层的下一件事

00:10:57.090 --> 00:11:02.100
架构是我们通常

00:10:59.940 --> 00:11:07.800
在这个域中拥有此服务层

00:11:02.100 --> 00:11:10.320
层，如果我们有某些类

00:11:07.800 --> 00:11:13.440
通过我们的倍数使用

00:11:10.320 --> 00:11:15.150
层，我们只是将它们推到底部

00:11:13.440 --> 00:11:18.860
因为每个人都可以访问

00:11:15.150 --> 00:11:21.540
他们，所以我们有一个实用程序类， 

00:11:18.860 --> 00:11:23.610
也许需要其他班级

00:11:21.540 --> 00:11:25.740
应该访问的每个地方

00:11:23.610 --> 00:11:28.710
到处我们都将它们推到

00:11:25.740 --> 00:11:31.520
最下层，所以每隔一层

00:11:28.710 --> 00:11:35.550
上面可以使用它

00:11:31.520 --> 00:11:39.270
这使边界成为我们的边界

00:11:35.550 --> 00:11:42.510
如果不这样做，它们是否容易变得模糊

00:11:39.270 --> 00:11:43.800
如果你没有纪律，或者

00:11:42.510 --> 00:11:49.350
你没有合适的东西

00:11:43.800 --> 00:11:54.120
抓住了它，所以没有真正的

00:11:49.350 --> 00:11:55.830
边界，如果不，如果不， 

00:11:54.120 --> 00:12:00.930
您不会特别将其内置到您的

00:11:55.830 --> 00:12:05.310
体系结构的下一步是分层

00:12:00.930 --> 00:12:07.740
体系结构允许像图层一样的快捷方式

00:12:05.310 --> 00:12:09.900
桥接我们正在访问

00:12:07.740 --> 00:12:14.760
 Web层的持久层

00:12:09.900 --> 00:12:15.870
这个例子本身还不错，但是如果

00:12:14.760 --> 00:12:18.000
我们这样做

00:12:15.870 --> 00:12:19.830
然后测试会有点

00:12:18.000 --> 00:12:22.560
至少如果我们在做单位的话更难

00:12:19.830 --> 00:12:24.540
测试，以便进行测试

00:12:22.560 --> 00:12:26.400
控制器在这里，我们将不得不嘲笑

00:12:24.540 --> 00:12:28.040
业务层消失了，我们将

00:12:26.400 --> 00:12:30.390
尤其要嘲笑

00:12:28.040 --> 00:12:32.490
仓库，所以我们有很多

00:12:30.390 --> 00:12:35.670
嘲笑是否有新人加入团队

00:12:32.490 --> 00:12:39.270
并看到您可能获得的测试代码

00:12:35.670 --> 00:12:41.160
困惑的测试越来越难了

00:12:39.270 --> 00:12:42.959
我们必须要模拟更多吗

00:12:41.160 --> 00:12:47.430
模拟不同的不同层

00:12:42.959 --> 00:12:49.740
不同的技术将

00:12:47.430 --> 00:12:54.870
比我们只有一点点困难

00:12:49.740 --> 00:12:59.370
嘲笑下一个

00:12:54.870 --> 00:13:01.500
我已经观察到很多重要的事情

00:12:59.370 --> 00:13:03.240
项目的功能是

00:13:01.500 --> 00:13:05.610
我们正在建立用例

00:13:03.240 --> 00:13:08.170
建立在我们的应用程序中实际上

00:13:05.610 --> 00:13:10.000
隐藏在我们提供服务的地方

00:13:08.170 --> 00:13:13.570
这是业务服务或域

00:13:10.000 --> 00:13:17.440
服务或其他什么，它正在做很多事情

00:13:13.570 --> 00:13:19.060
不同的用例，所以例如

00:13:17.440 --> 00:13:22.300
有关心的服务

00:13:19.060 --> 00:13:24.730
订单，以便创建要更新的订单

00:13:22.300 --> 00:13:29.380
为了我不知道下订单

00:13:24.730 --> 00:13:33.639
随便，这项服务

00:13:29.380 --> 00:13:36.449
一切为了订单和一切

00:13:33.639 --> 00:13:39.160
围绕实体的

00:13:36.449 --> 00:13:41.440
围绕订单实体，您不会

00:13:39.160 --> 00:13:44.949
真的，如果您正在寻找某个

00:13:41.440 --> 00:13:46.660
您知道代码库中的用例

00:13:44.949 --> 00:13:48.610
在这个顺序的某个地方

00:13:46.660 --> 00:13:50.980
服务，但您不必

00:13:48.610 --> 00:13:54.510
通过服务搜索到实际

00:13:50.980 --> 00:13:56.949
找到它，这就是使用例

00:13:54.510 --> 00:13:59.500
通常很难找到用例

00:13:56.949 --> 00:14:03.970
我们提供以下广泛的服务

00:13:59.500 --> 00:14:05.889
跨越多个用例，它

00:14:03.970 --> 00:14:09.040
也让努力变得困难

00:14:05.889 --> 00:14:14.100
在同一功能上并行工作，因此

00:14:09.040 --> 00:14:16.329
如果两个开发人员正在开发

00:14:14.100 --> 00:14:18.940
在相同或相似的位置上工作

00:14:16.329 --> 00:14:21.579
他们必须具备的功能

00:14:18.940 --> 00:14:28.199
从事这项服务，可能有

00:14:21.579 --> 00:14:33.310
合并冲突等问题

00:14:28.199 --> 00:14:39.130
有什么治疗方法，而不是分层

00:14:33.310 --> 00:14:43.839
只是做圈，所以我们只包装

00:14:39.130 --> 00:14:46.199
彼此和所有事物的层次

00:14:43.839 --> 00:14:46.199
那更好

00:14:48.760 --> 00:14:57.200
我还没完成呢

00:14:50.990 --> 00:14:59.890
好吧，这就是鲍伯叔叔

00:14:57.200 --> 00:15:02.420
罗伯特·马丁称清洁建筑

00:14:59.890 --> 00:15:05.870
我要详细一点

00:15:02.420 --> 00:15:09.470
稍后，但首先让我们看一下固体

00:15:05.870 --> 00:15:13.010
每个人都知道的坚实原则

00:15:09.470 --> 00:15:14.720
对，如果你是，就可以

00:15:13.010 --> 00:15:18.310
在中间醒来

00:15:14.720 --> 00:15:23.690
晚上你可以说oli D是对的

00:15:18.310 --> 00:15:26.780
谁能做到这一点哦，我知道你

00:15:23.690 --> 00:15:29.690
可以吗，我不会去问

00:15:26.780 --> 00:15:32.410
你现在我要打开这个

00:15:29.690 --> 00:15:34.430
因此，单一责任原则

00:15:32.410 --> 00:15:36.050
开闭原理

00:15:34.430 --> 00:15:37.700
替代原理接口

00:15:36.050 --> 00:15:39.410
隔离原则依赖性

00:15:37.700 --> 00:15:42.110
反演原理，我们只会

00:15:39.410 --> 00:15:46.150
看两个我认为是的

00:15:42.110 --> 00:15:49.670
最重要的

00:15:46.150 --> 00:15:54.290
激发我的建筑风格

00:15:49.670 --> 00:15:58.960
要介绍一下，让我们先来看

00:15:54.290 --> 00:16:01.250
在依赖倒置原则

00:15:58.960 --> 00:16:03.290
这显然意味着什么

00:16:01.250 --> 00:16:11.480
我们可以在某些情况下反转依赖关系

00:16:03.290 --> 00:16:13.730
这意味着这是我们的

00:16:11.480 --> 00:16:15.530
左侧是我们的数据库驱动设计

00:16:13.730 --> 00:16:17.780
现在我们有服务，我们有

00:16:15.530 --> 00:16:19.910
实体和存储库以及服务

00:16:17.780 --> 00:16:23.180
依赖于

00:16:19.910 --> 00:16:26.180
持久层，所以我们必须

00:16:23.180 --> 00:16:30.470
通过耦合到数据库

00:16:26.180 --> 00:16:33.200
实体，如果我们应用依赖项

00:16:30.470 --> 00:16:36.080
反转原理，我们把这个

00:16:33.200 --> 00:16:38.300
周围的依赖，这样就不再

00:16:36.080 --> 00:16:40.460
域层不再具有

00:16:38.300 --> 00:16:42.980
依赖于持久层，但是

00:16:40.460 --> 00:16:47.560
另一种解决方法是

00:16:42.980 --> 00:16:50.210
右边，我们看到我们有，是的，我

00:16:47.560 --> 00:16:53.210
在这里也用用例替换了服务

00:16:50.210 --> 00:16:54.530
但这没关系，这意味着

00:16:53.210 --> 00:16:56.480
右边我们正在使用依赖

00:16:54.530 --> 00:16:59.630
倒置意味着我们已经移动了

00:16:56.480 --> 00:17:01.420
实体进入域层，以便

00:16:59.630 --> 00:17:03.160
我们的域实体

00:17:01.420 --> 00:17:06.910
现在实际上是域实体

00:17:03.160 --> 00:17:11.140
使JPA或休眠状态或更长的时间更长

00:17:06.910 --> 00:17:13.990
实体，并且在域层中我们添加了

00:17:11.140 --> 00:17:16.270
我称为存储库的接口

00:17:13.990 --> 00:17:19.210
在这里，但不一定

00:17:16.270 --> 00:17:22.360
被这样命名

00:17:19.210 --> 00:17:26.710
持久层只是实现了这一点

00:17:22.360 --> 00:17:31.110
仓库接口与任何

00:17:26.710 --> 00:17:36.970
技术在项目中是明智的

00:17:31.110 --> 00:17:39.540
 JPA spring数据JDBC不管怎样

00:17:36.970 --> 00:17:41.380
这意味着我们可以选择

00:17:39.540 --> 00:17:43.960
取决于任何方向

00:17:41.380 --> 00:17:46.660
只要我们有控制权

00:17:43.960 --> 00:17:51.400
代码，如果我们有一个依赖

00:17:46.660 --> 00:17:54.130
一些第三方框架

00:17:51.400 --> 00:17:56.560
图书馆显然我们不能改变

00:17:54.130 --> 00:18:01.620
依赖，因为我们无法更改

00:17:56.560 --> 00:18:05.620
教练，这对一个人意味着什么

00:18:01.620 --> 00:18:08.520
体系结构级别，这就是

00:18:05.620 --> 00:18:14.500
干净的建筑ID发挥作用

00:18:08.520 --> 00:18:16.780
干净的体系结构作为流行语是

00:18:14.500 --> 00:18:20.230
不那么年轻，它就在我身边

00:18:16.780 --> 00:18:23.560
知道了十年左右，所以我不是

00:18:20.230 --> 00:18:25.780
真的很确定，但是罗伯特·马丁有

00:18:23.560 --> 00:18:28.270
最近出版的清洁书

00:18:25.780 --> 00:18:30.370
关于这个的架构说明

00:18:28.270 --> 00:18:32.770
这种建筑风格，但是非常

00:18:30.370 --> 00:18:35.860
通用，但我要去的是

00:18:32.770 --> 00:18:39.880
实际上只是滑行所以我

00:18:35.860 --> 00:18:44.380
不会在这里详细介绍

00:18:39.880 --> 00:18:46.980
但是要回顾主要的主要事实

00:18:44.380 --> 00:18:52.480
我们在这里吗我们在中间吗

00:18:46.980 --> 00:18:55.570
域层，周围有层

00:18:52.480 --> 00:19:00.780
那主要规则是

00:18:55.570 --> 00:19:05.590
依赖只能指向单词，所以

00:19:00.780 --> 00:19:08.620
例如我们有一个蓝色圆圈

00:19:05.590 --> 00:19:12.909
 UI代码UI的代码或代码

00:19:08.620 --> 00:19:15.820
用于访问数据库，它可能会起作用

00:19:12.909 --> 00:19:17.889
作为绿色层和绿色层

00:19:15.820 --> 00:19:20.889
可能会像这样访问红色层

00:19:17.889 --> 00:19:23.169
我们已经应用了依赖

00:19:20.889 --> 00:19:34.479
实际允许的反演原理

00:19:23.169 --> 00:19:36.509
这种依赖关系的变化是的，这

00:19:34.479 --> 00:19:41.049
其实我们有领域逻辑

00:19:36.509 --> 00:19:44.409
实际上是核心，一切都在

00:19:41.049 --> 00:19:47.499
外面只是一个细节，所以如果你

00:19:44.409 --> 00:19:50.200
相信Bob叔叔的数据库和

00:19:47.499 --> 00:19:53.649
网络实际上只是向我们详细

00:19:50.200 --> 00:19:57.639
应用程序的重要内容是

00:19:53.649 --> 00:19:59.229
在中间的红色东西，我看到一个

00:19:57.639 --> 00:20:00.999
多一点务实，我认为这是

00:19:59.229 --> 00:20:03.489
我们拥有一个网络非常重要

00:20:00.999 --> 00:20:06.879
层，然后我们有一个数据库层

00:20:03.489 --> 00:20:09.669
因为否则数据只会

00:20:06.879 --> 00:20:13.330
迷失了，但这意味着我们可以

00:20:09.669 --> 00:20:17.580
稍后实际更改数据库

00:20:13.330 --> 00:20:19.659
和我不知道存储交换

00:20:17.580 --> 00:20:22.840
将文件存储在硬盘上或

00:20:19.659 --> 00:20:25.059
像这样的东西是

00:20:22.840 --> 00:20:28.809
依赖倒置依赖我们倒置

00:20:25.059 --> 00:20:31.710
我们的领域层没有依赖关系

00:20:28.809 --> 00:20:35.009
不再依赖持久层

00:20:31.710 --> 00:20:37.330
因为我们改变了依赖

00:20:35.009 --> 00:20:42.909
通过引入一个界面和

00:20:37.330 --> 00:20:44.679
从外部实施

00:20:42.909 --> 00:20:46.840
我想谈的下一个坚实原则

00:20:44.679 --> 00:20:48.789
关于单一责任

00:20:46.840 --> 00:20:52.090
单一责任原则

00:20:48.789 --> 00:20:57.399
知道这意味着什么，是的，只是我

00:20:52.090 --> 00:21:00.960
仍然可以看到你告诉我什么

00:20:57.399 --> 00:21:00.960
单一责任是什么意思

00:21:03.790 --> 00:21:10.580
在这里，你在作弊，是我所期待的

00:21:07.400 --> 00:21:12.710
类似类或模块的东西

00:21:10.580 --> 00:21:15.670
只做一件事，但你说的是

00:21:12.710 --> 00:21:18.920
完全正确的类或模块

00:21:15.670 --> 00:21:21.320
实际上应该只有一个理由

00:21:18.920 --> 00:21:23.330
变化，所以这是常见的

00:21:21.320 --> 00:21:25.280
对单身的误解

00:21:23.330 --> 00:21:28.520
只负责的原则

00:21:25.280 --> 00:21:31.300
实际上应该做一件事

00:21:28.520 --> 00:21:34.760
应该只有一个改变的理由

00:21:31.300 --> 00:21:36.380
这是细微的差别，不是

00:21:34.760 --> 00:21:39.500
差别不大，但是

00:21:36.380 --> 00:21:42.830
有意义的差异，因为如果

00:21:39.500 --> 00:21:45.530
某些模块或类有一个

00:21:42.830 --> 00:21:48.610
东西，但是有多种原因

00:21:45.530 --> 00:21:52.820
变化，因为有不同

00:21:48.610 --> 00:21:55.190
具有那个的要求

00:21:52.820 --> 00:21:57.590
在这个模块中产生了变化

00:21:55.190 --> 00:22:00.170
类，那么它将改变所有

00:21:57.590 --> 00:22:04.250
某个模块化课程的时间

00:22:00.170 --> 00:22:05.840
只有一个改变的理由

00:22:04.250 --> 00:22:08.900
将因为这个原因而被改变

00:22:05.840 --> 00:22:13.370
这使得代码库更加丰富

00:22:08.900 --> 00:22:15.650
所以稳定，而不是我把模块

00:22:13.370 --> 00:22:17.630
这里的单词模块而不是模块

00:22:15.650 --> 00:22:21.500
您可以阅读课程包组件

00:22:17.630 --> 00:22:26.780
任何元素架构或代码

00:22:21.500 --> 00:22:29.030
您想要的元素，那么什么单

00:22:26.780 --> 00:22:31.430
责任是宏观上的意思

00:22:29.030 --> 00:22:33.380
如果我们在建筑水平上

00:22:31.430 --> 00:22:37.390
看看我们的分层架构

00:22:33.380 --> 00:22:40.280
业务层或我们的域层具有

00:22:37.390 --> 00:22:42.650
改变它不应该的一个理由

00:22:40.280 --> 00:22:44.720
有，那就是持久层

00:22:42.650 --> 00:22:46.820
下面，如果我们在

00:22:44.720 --> 00:22:49.520
蓝色层的持久层和

00:22:46.820 --> 00:22:51.170
最底层有一定的

00:22:49.520 --> 00:22:53.300
我们必须改变的可能性

00:22:51.170 --> 00:22:58.070
业务层中的事情也是因为

00:22:53.300 --> 00:23:01.240
依赖性显示点向下，所以

00:22:58.070 --> 00:23:06.760
持久性的变化可能会影响

00:23:01.240 --> 00:23:09.830
我们不想要的商业代码

00:23:06.760 --> 00:23:13.130
在这个干净的建筑圈里

00:23:09.830 --> 00:23:15.140
当我们应用圆形样式

00:23:13.130 --> 00:23:16.280
依赖性反转原理这是

00:23:15.140 --> 00:23:18.770
不再如此

00:23:16.280 --> 00:23:22.490
因为依赖性指向

00:23:18.770 --> 00:23:25.400
我们的业务层，如果有的话

00:23:22.490 --> 00:23:27.650
外层改变业务

00:23:25.400 --> 00:23:31.820
层不必更改，所以这

00:23:27.650 --> 00:23:34.520
使业务代码更稳定

00:23:31.820 --> 00:23:37.130
意味着改变单一原因

00:23:34.520 --> 00:23:42.320
高层的责任

00:23:37.130 --> 00:23:44.390
在体系结构级别上的宏

00:23:42.320 --> 00:23:49.400
意味着我们可以自由地做任何事情

00:23:44.390 --> 00:23:51.830
我们认为适合我们认为的一切

00:23:49.400 --> 00:23:54.830
在我们可以做到的领域层中是很好的

00:23:51.830 --> 00:23:58.750
一切都无需思考

00:23:54.830 --> 00:24:02.680
关于持久性效果持久性

00:23:58.750 --> 00:24:05.930
问题懒惰加载这样的东西

00:24:02.680 --> 00:24:08.720
我走到很远，说只有一个

00:24:05.930 --> 00:24:11.650
以领域为中心的架构在哪

00:24:08.720 --> 00:24:13.550
中间有一个领域层

00:24:11.650 --> 00:24:15.700
独立指向

00:24:13.550 --> 00:24:21.260
域层允许域驱动设计

00:24:15.700 --> 00:24:23.090
因为只有这样我们才能设计

00:24:21.260 --> 00:24:26.230
可以自由设计而无需

00:24:23.090 --> 00:24:31.880
考虑某些技术问题

00:24:26.230 --> 00:24:37.850
只走了这么远，但要旨是

00:24:31.880 --> 00:24:42.080
这是真的，这意味着什么

00:24:37.850 --> 00:24:45.440
在微观水平上，在单班水平上

00:24:42.080 --> 00:24:48.230
我们层架构中的责任

00:24:45.440 --> 00:24:49.640
我们经常遇到这样的情况

00:24:48.230 --> 00:24:53.780
我谈到的这些广泛的服务

00:24:49.640 --> 00:24:55.820
早些时候，我们有多个演员

00:24:53.780 --> 00:24:58.910
使用此服务，例如

00:24:55.820 --> 00:25:01.790
这是提供使用的订单服务

00:24:58.910 --> 00:25:04.900
下订单案例

00:25:01.790 --> 00:25:08.080
随便，我们有三个不同

00:25:04.900 --> 00:25:11.480
实际上是三个不同的用户角色

00:25:08.080 --> 00:25:14.990
使用该服务中的用例

00:25:11.480 --> 00:25:17.210
服务我们有三个参与者

00:25:14.990 --> 00:25:19.790
因此，如果这些参与者之一

00:25:17.210 --> 00:25:21.950
这些用户角色之一需要

00:25:19.790 --> 00:25:24.380
更改为我们拥有的应用程序

00:25:21.950 --> 00:25:27.440
改变这项服务，我们必须

00:25:24.380 --> 00:25:29.720
再次测试其中的所有其他内容

00:25:27.440 --> 00:25:34.610
即使其他两个演员

00:25:29.720 --> 00:25:39.410
其实并不认为

00:25:34.610 --> 00:25:42.350
一切都变了，我们该怎么办

00:25:39.410 --> 00:25:46.600
在这里我们可以将我们的服务分为

00:25:42.350 --> 00:25:51.710
用例命名的实际类

00:25:46.600 --> 00:25:54.500
 XY z-用例和每个服务或

00:25:51.710 --> 00:25:57.110
用例无论您叫什么

00:25:54.500 --> 00:26:00.200
对一个用户负责一个演员

00:25:57.110 --> 00:26:02.929
角色，如果您将其发挥到极致

00:26:00.200 --> 00:26:11.240
这些课程实际上只是

00:26:02.929 --> 00:26:15.760
因此，一个用例负责

00:26:11.240 --> 00:26:20.960
带我进入下一个建筑风格

00:26:15.760 --> 00:26:23.210
这是六边形，所以我们在谈论很多

00:26:20.960 --> 00:26:27.530
我们谈论的是很多形状

00:26:23.210 --> 00:26:29.990
今天我觉得六角形更性感

00:26:27.530 --> 00:26:34.610
比圆，因为它有这些边缘

00:26:29.990 --> 00:26:41.299
但这只是个人含义

00:26:34.610 --> 00:26:43.039
这是否意味着如果我们钻进一个

00:26:41.299 --> 00:26:44.690
六角形的建筑，这是我的

00:26:43.039 --> 00:26:47.450
六角形的解释

00:26:44.690 --> 00:26:52.000
我们看起来像这样的建筑

00:26:47.450 --> 00:26:57.020
六边形六边六

00:26:52.000 --> 00:27:00.049
角和六边形内

00:26:57.020 --> 00:27:03.890
我们的域层或域代码使用

00:27:00.049 --> 00:27:05.990
案例实体在我们的边缘

00:27:03.890 --> 00:27:08.390
我们应用核心的六边形

00:27:05.990 --> 00:27:10.490
我们在左侧的端口输入

00:27:08.390 --> 00:27:15.530
端口，在右侧， 

00:27:10.490 --> 00:27:19.480
输出端口输入意味着我们提供了

00:27:15.530 --> 00:27:22.909
接口，我们提供向外的API 

00:27:19.480 --> 00:27:25.100
我们称它们为向外代码的适配器

00:27:22.909 --> 00:27:28.100
想调用我们的应用程序逻辑

00:27:25.100 --> 00:27:31.669
在右侧的输出端口

00:27:28.100 --> 00:27:34.340
提供功能，例如

00:27:31.669 --> 00:27:40.400
持久性我们称之为应用程序

00:27:34.340 --> 00:27:42.210
核心叫别的东西，为什么呢

00:27:40.400 --> 00:27:46.010
这个六角形

00:27:42.210 --> 00:27:49.350
我真的不知道，我也不认为

00:27:46.010 --> 00:27:53.070
先生。冠以“ Cockburn”字样的人

00:27:49.350 --> 00:27:56.430
我想我读的六角形建筑

00:27:53.070 --> 00:28:00.750
他说男人只是在某个地方

00:27:56.430 --> 00:28:03.780
因为有四个角的盒子是

00:28:00.750 --> 00:28:05.430
很无聊，他想表明

00:28:03.780 --> 00:28:08.430
架构实际上可以拥有超过

00:28:05.430 --> 00:28:11.940
我不知道他的四个方面

00:28:08.430 --> 00:28:14.460
意思是，但如果你认为这六个方面

00:28:11.940 --> 00:28:22.530
对您来说太多了，您可以选择

00:28:14.460 --> 00:28:27.030
您想要的任何多边形，例如

00:28:22.530 --> 00:28:28.590
顾客说哦，六个六面

00:28:27.030 --> 00:28:33.240
对我来说太多了，你可以去

00:28:28.590 --> 00:28:34.890
三角形的建筑，但是你

00:28:33.240 --> 00:28:36.540
应该为顾客做好准备

00:28:34.890 --> 00:28:39.570
只想为它付出一半，因为它

00:28:36.540 --> 00:28:42.480
只有边数的一半，所以

00:28:39.570 --> 00:28:45.330
小心一点，所以实际上

00:28:42.480 --> 00:28:47.490
六角形实际上并不意味着什么

00:28:45.330 --> 00:28:53.580
看起来很酷，所以我们会坚持

00:28:47.490 --> 00:28:56.430
我提到的六角形用例

00:28:53.580 --> 00:28:57.690
在那之前，用例应该是

00:28:56.430 --> 00:28:59.750
服务应该切入

00:28:57.690 --> 00:29:05.940
多个用例，以便每个用例

00:28:59.750 --> 00:29:07.680
只有一个演员，所以用例我们

00:29:05.940 --> 00:29:12.060
应将用例视为一流

00:29:07.680 --> 00:29:14.010
市民在我们的建筑和

00:29:12.060 --> 00:29:16.500
六角形的建筑

00:29:14.010 --> 00:29:18.990
更干净的

00:29:16.500 --> 00:29:23.160
介绍干净的建筑

00:29:18.990 --> 00:29:24.990
较早的时候，如果您用谷歌搜索干净

00:29:23.160 --> 00:29:27.930
建筑和六角形建筑

00:29:24.990 --> 00:29:32.040
你对巴哈伊有很多了解

00:29:27.930 --> 00:29:33.360
级别的概念，但至少如果

00:29:32.040 --> 00:29:34.530
您正在寻找干净的建筑，如果

00:29:33.360 --> 00:29:37.290
您正在寻找六角形

00:29:34.530 --> 00:29:39.870
架构，您甚至可以获得一些代码

00:29:37.290 --> 00:29:43.160
例子，因为干净的架构

00:29:39.870 --> 00:29:45.810
只是一个概念而已

00:29:43.160 --> 00:29:47.670
六角形的建筑只是一个

00:29:45.810 --> 00:29:51.540
清洁建筑的实例

00:29:47.670 --> 00:29:55.880
实际上把概念放在

00:29:51.540 --> 00:29:55.880
更容易变成实际的代码

00:29:58.029 --> 00:30:04.789
那么用例做什么用例

00:30:00.980 --> 00:30:08.570
类实现输入端口的输入

00:30:04.789 --> 00:30:11.509
端口只是一个Java接口，然后

00:30:08.570 --> 00:30:14.320
用例类修改域模型

00:30:11.509 --> 00:30:18.049
领域实体以某种方式

00:30:14.320 --> 00:30:20.179
并在途中可能会

00:30:18.049 --> 00:30:22.789
输出端口，例如加载数据

00:30:20.179 --> 00:30:25.519
从数据库或将数据发送到

00:30:22.789 --> 00:30:32.120
数据库或从其他数据库加载数据

00:30:25.519 --> 00:30:37.129
外部系统，不管我们拥有

00:30:32.120 --> 00:30:39.289
看这个这个的影响

00:30:37.129 --> 00:30:44.779
此架构文件的样式

00:30:39.289 --> 00:30:47.120
具有特定的用例类，因此

00:30:44.779 --> 00:30:51.769
这是一个小小的包装结构

00:30:47.120 --> 00:30:55.899
没有实际用例的应用程序可以

00:30:51.769 --> 00:30:55.899
有人告诉这个应用程序做什么

00:30:57.370 --> 00:31:04.990
原谅它记录时间是的，非常聪明

00:31:05.139 --> 00:31:11.539
任何其他人都猜对了

00:31:09.649 --> 00:31:14.179
显然在做一些事情

00:31:11.539 --> 00:31:16.759
时间，所以你完全正确

00:31:14.179 --> 00:31:20.029
除了记录时间，别无所求

00:31:16.759 --> 00:31:24.529
所以对你我没有冒犯

00:31:20.029 --> 00:31:25.730
反正看到它要么做某事

00:31:24.529 --> 00:31:27.590
我们有我们提供的服务

00:31:25.730 --> 00:31:29.210
有时间记录但

00:31:27.590 --> 00:31:30.740
什么时间记录我不知道

00:31:29.210 --> 00:31:33.200
我们如何处理这些时间记录

00:31:30.740 --> 00:31:37.820
不知道我们是否分开使用

00:31:33.200 --> 00:31:44.390
情况下，我们得到这个告诉任何人

00:31:37.820 --> 00:31:46.670
现在，此应用程序可以做些什么

00:31:44.390 --> 00:31:49.220
是的，经理们甚至可以记录时间

00:31:46.670 --> 00:31:52.940
可能更深一层，我们看到

00:31:49.220 --> 00:31:54.920
我们有多个用例，我们可以提交

00:31:52.940 --> 00:31:56.990
我们可以批准时间记录

00:31:54.920 --> 00:32:03.320
我们可以拒绝时间记录，所以

00:31:56.990 --> 00:32:07.280
实际上可能有多个用户

00:32:03.320 --> 00:32:09.080
我们已经证明了多种角色

00:32:07.280 --> 00:32:12.260
这种情况可能是由另一个

00:32:09.080 --> 00:32:14.270
角色，所以可能是时候

00:32:12.260 --> 00:32:16.520
跟踪您跟踪的应用程序

00:32:14.270 --> 00:32:20.660
您的时间，以后再创建

00:32:16.520 --> 00:32:21.740
发票并跟踪您的时间

00:32:20.660 --> 00:32:25.730
可以在分层架构中做到这一点

00:32:21.740 --> 00:32:28.850
也是，这当然是一个很好的方法

00:32:25.730 --> 00:32:32.360
去，但在这个六角形

00:32:28.850 --> 00:32:34.580
体系结构，它甚至更强大

00:32:32.360 --> 00:32:37.070
因为依赖倒置和

00:32:34.580 --> 00:32:43.309
我们不必更改用例

00:32:37.070 --> 00:32:46.850
因为持久性代码可以更改

00:32:43.309 --> 00:32:50.330
让我们看一下我承诺的一些代码

00:32:46.850 --> 00:32:55.510
显示一些代码，您可以找到代码

00:32:50.330 --> 00:32:55.510
此链接或幻灯片中的示例

00:32:56.860 --> 00:33:05.270
你可以看到吗，代码是什么

00:33:01.820 --> 00:33:06.730
看起来就像这只是一个

00:33:05.270 --> 00:33:10.309
免责声明，这是我的解释

00:33:06.730 --> 00:33:12.320
有一定的我们一定可以做到

00:33:10.309 --> 00:33:15.169
它以不同的风格只是一个

00:33:12.320 --> 00:33:20.660
一个可以用来创建的模板

00:33:15.169 --> 00:33:22.820
带有或

00:33:20.660 --> 00:33:25.070
没有春天，我要指出

00:33:22.820 --> 00:33:28.640
途中的弹簧零件

00:33:25.070 --> 00:33:31.490
这就是我们要实施的

00:33:28.640 --> 00:33:35.630
用例，称为注册簿

00:33:31.490 --> 00:33:37.880
用例，因此该应用程序是关于

00:33:35.630 --> 00:33:41.600
书评申请，因此，如果您

00:33:37.880 --> 00:33:44.690
写一本书，你可以上传这本书

00:33:41.600 --> 00:33:48.080
 Mactan或其他格式，您

00:33:44.690 --> 00:33:50.500
可以提供给其他可以

00:33:48.080 --> 00:33:53.929
然后查看本书并进行编辑和

00:33:50.500 --> 00:33:56.059
建议编辑和类似的东西，所以

00:33:53.929 --> 00:33:57.990
此应用程序的第一个用例是

00:33:56.059 --> 00:34:00.210
注册一本书，所以我全是

00:33:57.990 --> 00:34:06.779
一本书，我想注册我的书

00:34:00.210 --> 00:34:11.129
那里实际上是一个简单的创建用途

00:34:06.779 --> 00:34:13.260
情况下，我们只是创作一本书，但我没有

00:34:11.129 --> 00:34:13.859
称它为创造书，因为那也是

00:34:13.260 --> 00:34:16.800
通用的

00:34:13.859 --> 00:34:21.780
我称它为注册书，所以我们应该尝试

00:34:16.800 --> 00:34:24.780
用最多的调用我们的用例

00:34:21.780 --> 00:34:26.669
最好的动词并创造它

00:34:24.780 --> 00:34:28.859
太普通了，所以我们有这个

00:34:26.669 --> 00:34:32.099
注册书籍用例

00:34:28.859 --> 00:34:35.520
接口，这是我们在

00:34:32.099 --> 00:34:39.290
六角形的建筑，它只有一个

00:34:35.520 --> 00:34:41.970
当前的方法是注册簿

00:34:39.290 --> 00:34:45.599
这需要一个注册簿命令

00:34:41.970 --> 00:34:48.869
包含所有的数据

00:34:45.599 --> 00:34:50.639
需要执行此用例

00:34:48.869 --> 00:34:53.129
注册书命令，我把它放在这里

00:34:50.639 --> 00:34:58.460
也进入这个界面

00:34:53.129 --> 00:35:03.000
它只有两个字段和一个

00:34:58.460 --> 00:35:09.119
将这些字段用作的构造函数

00:35:03.000 --> 00:35:14.150
输入这是第一个问题

00:35:09.119 --> 00:35:17.130
关于验证，我选择验证

00:35:14.150 --> 00:35:20.670
该级别的输入，因此寄存器

00:35:17.130 --> 00:35:22.859
 book命令实际上实现和/或

00:35:20.670 --> 00:35:29.330
扩展了一个自我验证类

00:35:22.859 --> 00:35:32.460
只是做了一些创建一个Java Bean 

00:35:29.330 --> 00:35:37.500
验证验证器，称为

00:35:32.460 --> 00:35:39.420
验证，因此其结果

00:35:37.500 --> 00:35:42.470
评估这些Bean验证

00:35:39.420 --> 00:35:45.359
注释，因此我们只能创建一个

00:35:42.470 --> 00:35:48.480
在中有效的命令对象

00:35:45.359 --> 00:35:51.420
感觉到业务逻辑期望如此

00:35:48.480 --> 00:35:54.000
然后，业务逻辑本身可以工作

00:35:51.420 --> 00:35:57.480
具有这些属性，并且没有

00:35:54.000 --> 00:35:59.790
进行验证本身也有

00:35:57.480 --> 00:36:02.339
我不知道是否有例外

00:35:59.790 --> 00:36:04.800
这是一个好主意非唯一书名

00:36:02.339 --> 00:36:08.910
例外，也许更好的方法是

00:36:04.800 --> 00:36:11.360
不使用它不创建一个

00:36:08.910 --> 00:36:15.080
在这种情况下例外，但是

00:36:11.360 --> 00:36:18.050
调用注册簿方法之前

00:36:15.080 --> 00:36:23.180
实际检查是否已经有一个

00:36:18.050 --> 00:36:25.190
书，但是那只是一点味道

00:36:23.180 --> 00:36:27.770
我们有此注册簿用例

00:36:25.190 --> 00:36:32.930
到目前为止，即使有春天

00:36:27.770 --> 00:36:35.720
和弹簧图标，那么实际上是什么

00:36:32.930 --> 00:36:37.280
实现这个我调用的接口

00:36:35.720 --> 00:36:39.080
它注册图书服务，所以这是一个

00:36:37.280 --> 00:36:41.900
仅为此服务的服务

00:36:39.080 --> 00:36:45.800
这个实际的用例，它

00:36:41.900 --> 00:36:47.420
实现此方法，所以我们

00:36:45.800 --> 00:36:49.010
当我们开始

00:36:47.420 --> 00:36:51.020
实现我们的注册簿方法

00:36:49.010 --> 00:36:54.470
只需键入并实施我们的

00:36:51.020 --> 00:36:59.300
业务逻辑，我们发现我们需要

00:36:54.470 --> 00:37:03.620
作者实体，所以我们只创建一个

00:36:59.300 --> 00:37:07.910
我称为查找作者的输出端口

00:37:03.620 --> 00:37:11.800
被只有这一项的驱逐出境

00:37:07.910 --> 00:37:15.590
方法通过ID查找作者，我们

00:37:11.800 --> 00:37:18.290
高兴地编码得更好，然后我们

00:37:15.590 --> 00:37:20.510
觉得还可以，我们需要坚持这本书

00:37:18.290 --> 00:37:23.510
以某种方式，我们创建了另一个输出端口

00:37:20.510 --> 00:37:27.020
拿书并坚持下去

00:37:23.510 --> 00:37:30.800
在数据库中仍然很少的春天

00:37:27.020 --> 00:37:34.790
在这里，但我们在使用Springs 

00:37:30.800 --> 00:37:38.600
注释以将该服务声明为

00:37:34.790 --> 00:37:41.600
作为Spring bean ，一件事

00:37:38.600 --> 00:37:44.210
如果您要制作

00:37:41.600 --> 00:37:49.810
建筑在

00:37:44.210 --> 00:37:53.270
您可以创建自己的注释的代码

00:37:49.810 --> 00:37:54.830
并注释此meta注释此

00:37:53.270 --> 00:37:57.800
带添加组件的注释

00:37:54.830 --> 00:38:00.140
注释注释，然后您

00:37:57.800 --> 00:38:05.210
其实知道当你看着这个

00:38:00.140 --> 00:38:07.070
这是一个用例弹簧用作

00:38:05.210 --> 00:38:10.340
依赖注入机制在这里

00:38:07.070 --> 00:38:12.820
填写这些字段，我在这里使用龙目岛

00:38:10.340 --> 00:38:14.840
会自动创建一个

00:38:12.820 --> 00:38:17.320
全部所需的构造函数

00:38:14.840 --> 00:38:20.420
最终属性和春天

00:38:17.320 --> 00:38:23.930
自动注入的实现

00:38:20.420 --> 00:38:25.820
这些端口，所以如果我们创建了一个测试

00:38:23.930 --> 00:38:28.400
之前

00:38:25.820 --> 00:38:30.710
我们现在就可以进行测试

00:38:28.400 --> 00:38:34.720
已经实现了这些端口

00:38:30.710 --> 00:38:37.280
弹簧容器不会起火

00:38:34.720 --> 00:38:39.910
它会告诉我们有一个港口

00:38:37.280 --> 00:38:43.100
错过了那是很酷的

00:38:39.910 --> 00:38:47.270
因为有春天检查我们

00:38:43.100 --> 00:38:49.400
对我们的体系结构好吧，这就是

00:38:47.270 --> 00:38:51.980
这里的业务逻辑很少

00:38:49.400 --> 00:38:54.290
春天唯一要做的就是

00:38:51.980 --> 00:38:57.560
依赖注入就是这样

00:38:54.290 --> 00:39:01.250
应该是这样，春天是非常无创的

00:38:57.560 --> 00:39:03.410
我们可以春天在后面

00:39:01.250 --> 00:39:05.740
场景，然后做后面的工作

00:39:03.410 --> 00:39:08.510
场景，我们不必实际

00:39:05.740 --> 00:39:12.260
使用任何春季代码，除了

00:39:08.510 --> 00:39:16.460
一两个注解，这就是我们的

00:39:12.260 --> 00:39:19.730
我实际上没有解释的商业代码

00:39:16.460 --> 00:39:22.460
包装结构，所以我们有一个

00:39:19.730 --> 00:39:25.100
应用程序包结构与

00:39:22.460 --> 00:39:27.560
一个端口包输入端口输出端口

00:39:25.100 --> 00:39:29.570
这些只是接口，我们

00:39:27.560 --> 00:39:31.870
内有一个服务包

00:39:29.570 --> 00:39:36.500
具有我们的应用程序包

00:39:31.870 --> 00:39:39.350
注册图书服务，所以现在我们有人

00:39:36.500 --> 00:39:44.060
必须实现这些端口

00:39:39.350 --> 00:39:46.820
端口由我们的持久性实现

00:39:44.060 --> 00:39:49.370
适配器，所以我们六角结构

00:39:46.820 --> 00:39:52.340
在中间和中间有核心

00:39:49.370 --> 00:39:56.120
外层，我们有调用的适配器

00:39:52.340 --> 00:40:00.380
我们的核心或被我们称为

00:39:56.120 --> 00:40:01.910
在这里，我再次创建了一个自定义

00:40:00.380 --> 00:40:04.580
您不需要的注释

00:40:01.910 --> 00:40:07.690
也可以用这个，但是

00:40:04.580 --> 00:40:11.000
它更明显，这实现了一些

00:40:07.690 --> 00:40:14.360
自己的输出端口

00:40:11.000 --> 00:40:16.040
包和该包中的每个类

00:40:14.360 --> 00:40:19.310
实际上是打包的，我们不打包

00:40:16.040 --> 00:40:22.220
需要将其发布到外部

00:40:19.310 --> 00:40:25.310
这个包装是因为弹簧允许

00:40:22.220 --> 00:40:27.470
将beans注入春天

00:40:25.310 --> 00:40:30.410
没有他们实际上是公开的

00:40:27.470 --> 00:40:32.620
很酷，因为我们不能，我们不能

00:40:30.410 --> 00:40:34.640
意外地

00:40:32.620 --> 00:40:36.910
我们业务层的持久性代码

00:40:34.640 --> 00:40:36.910
然后

00:40:36.980 --> 00:40:44.180
所以这是非常简单的代码

00:40:39.349 --> 00:40:48.380
拿一本书并保存下来

00:40:44.180 --> 00:40:55.670
是一个Spring数据JDBC存储库

00:40:48.380 --> 00:40:59.000
简单的东西是这个

00:40:55.670 --> 00:41:01.940
读书课读书课在我们的

00:40:59.000 --> 00:41:03.710
域包，所以它实际上在

00:41:01.940 --> 00:41:06.470
在我们中间

00:41:03.710 --> 00:41:09.820
我不会忘记的六角形建筑

00:41:06.470 --> 00:41:13.970
一定要跟踪您的时间

00:41:09.820 --> 00:41:16.400
我们在这里选择添加此ID 

00:41:13.970 --> 00:41:19.190
注解这是对

00:41:16.400 --> 00:41:21.320
弹簧数据弹簧数据JDBC或实际上

00:41:19.190 --> 00:41:26.960
我认为这甚至不是JDBC，而只是

00:41:21.320 --> 00:41:30.440
春天的数据，所以我选择

00:41:26.960 --> 00:41:32.839
只是为了在我的身上使用相同的对象

00:41:30.440 --> 00:41:37.099
像我在我中使用的持久性

00:41:32.839 --> 00:41:38.839
业务层，但

00:41:37.099 --> 00:41:42.230
持久层需要此ID 

00:41:38.839 --> 00:41:44.119
注解，所以我现在选择只放它

00:41:42.230 --> 00:41:47.570
这是一种捷径

00:41:44.119 --> 00:41:49.060
因为再次在我的业务代码中

00:41:47.570 --> 00:41:51.470
其实不想要任何东西

00:41:49.060 --> 00:41:56.210
坚持任何对

00:41:51.470 --> 00:41:59.210
持久性代码，但我认为如果

00:41:56.210 --> 00:42:02.720
开始建立许多用例

00:41:59.210 --> 00:42:04.730
案例始于简单

00:42:02.720 --> 00:42:06.740
克罗蒂用例我们创建一些实体或

00:42:04.730 --> 00:42:11.300
这样的事情我们可以开始

00:42:06.740 --> 00:42:13.190
这样我们可以添加一些JPA或spring 

00:42:11.300 --> 00:42:15.800
实体中的数据注释

00:42:13.190 --> 00:42:20.660
实际在业务层中

00:42:15.800 --> 00:42:22.849
然后我们就可以传递这个实体

00:42:20.660 --> 00:42:28.550
到持久层然后持久

00:42:22.849 --> 00:42:32.210
在任何数据库中，但是一旦我们得到

00:42:28.550 --> 00:42:35.470
到用例演变为

00:42:32.210 --> 00:42:38.750
更复杂的事情，我们开始

00:42:35.470 --> 00:42:42.589
我们正在考虑哦，我们正在做一些

00:42:38.750 --> 00:42:44.810
持久性相关代码在

00:42:42.589 --> 00:42:50.089
业务层，然后我们可以选择

00:42:44.810 --> 00:42:50.860
从我们的网域中删除此注释

00:42:50.089 --> 00:42:54.340
宾语

00:42:50.860 --> 00:42:57.820
然后做一个介绍映射

00:42:54.340 --> 00:42:59.850
在这里，所以我们将这本书映射到

00:42:57.820 --> 00:43:04.330
一些JPA 

00:42:59.850 --> 00:43:08.470
实体，或者我们只是将其移至

00:43:04.330 --> 00:43:10.270
数据库/通过普通的JDBC，所以

00:43:08.470 --> 00:43:12.700
这就是我想带给我们的

00:43:10.270 --> 00:43:15.220
实际上不必从此开始

00:43:12.700 --> 00:43:17.590
两者之间的界限非常严格

00:43:15.220 --> 00:43:19.840
我们可以移动的层，我们可以开始没有

00:43:17.590 --> 00:43:23.410
这些映射步骤，因为那是一个

00:43:19.840 --> 00:43:24.910
关于六角形的主要批评

00:43:23.410 --> 00:43:27.040
建筑或清洁建筑

00:43:24.910 --> 00:43:30.310
一般而言，我们必须在每一层中

00:43:27.040 --> 00:43:32.980
有我们自己的模型，我们必须映射

00:43:30.310 --> 00:43:35.020
在这些模型之间，但我们没有

00:43:32.980 --> 00:43:37.150
一定要这样做

00:43:35.020 --> 00:43:40.420
如果我们应该开始这样做

00:43:37.150 --> 00:43:44.580
认为我们在做代码，如果我们

00:43:40.420 --> 00:43:47.200
将代码放在业务层中

00:43:44.580 --> 00:43:52.330
与持久性和东西有关

00:43:47.200 --> 00:43:55.980
这样，还有一个网络适配器

00:43:52.330 --> 00:44:00.120
在适配器包中，它只是一个

00:43:55.980 --> 00:44:03.250
休息控制，我不会

00:44:00.120 --> 00:44:05.640
那里的细节，因为它很漂亮

00:44:03.250 --> 00:44:05.640
直截了当

00:44:07.530 --> 00:44:16.120
好的，所以我们已经看到了

00:44:13.200 --> 00:44:18.250
总结一下春天的作用

00:44:16.120 --> 00:44:20.560
我们在我们的架构中，春天没有

00:44:18.250 --> 00:44:21.940
真正在乎我们的架构

00:44:20.560 --> 00:44:24.820
实施这是一件好事

00:44:21.940 --> 00:44:26.800
春天总是在后台

00:44:24.820 --> 00:44:32.130
从第一天起我就一直在后台

00:44:26.800 --> 00:44:36.550
如果我们考虑一下架构，那就猜猜

00:44:32.130 --> 00:44:38.980
春天不在乎，我们可以建立任何

00:44:36.550 --> 00:44:42.880
与春天的建筑，所以我们

00:44:38.980 --> 00:44:45.120
确实有很多选择

00:44:42.880 --> 00:44:45.120
东西

00:44:45.570 --> 00:44:50.590
弹簧还有助于测试孤立的零件

00:44:48.460 --> 00:44:54.430
我们已经在

00:44:50.590 --> 00:44:57.220
先谈一下组件

00:44:54.430 --> 00:45:00.190
扫描之类的东西，但是我们可以

00:44:57.220 --> 00:45:04.330
也做特定的java配置

00:45:00.190 --> 00:45:05.950
只旋转一部分的文件

00:45:04.330 --> 00:45:08.860
应用程序，以便我们可以对此进行测试

00:45:05.950 --> 00:45:13.420
孤立地应用程序的一部分

00:45:08.860 --> 00:45:15.790
奥利弗掉下沃尔玛给的东西

00:45:13.420 --> 00:45:19.570
昨天谈论模数，这是一个

00:45:15.790 --> 00:45:22.150
选择我们可以，我们也可以在这里和

00:45:19.570 --> 00:45:26.680
总结弹簧很容易放在手臂上

00:45:22.150 --> 00:45:29.350
长度，所以我们真的不必购买

00:45:26.680 --> 00:45:33.910
使用弹簧，因为弹簧在

00:45:29.350 --> 00:45:36.730
好的背景，我要跳过

00:45:33.910 --> 00:45:39.610
映射策略，因为我刚刚

00:45:36.730 --> 00:45:43.540
告诉我我刚刚告诉过你

00:45:39.610 --> 00:45:47.140
可以使用不同的映射策略

00:45:43.540 --> 00:45:49.060
不能做任何映射，所以端口

00:45:47.140 --> 00:45:51.400
输出端口和持久设置

00:45:49.060 --> 00:45:53.950
他们使用与域相同的实体

00:45:51.400 --> 00:45:58.210
层，或者我们可以做这样的事情

00:45:53.950 --> 00:46:00.850
在界面的最前面

00:45:58.210 --> 00:46:03.940
使用命令模式的Web适配器

00:46:00.850 --> 00:46:08.380
这是一个更精细的映射

00:46:03.940 --> 00:46:12.720
策略我们如何执行架构

00:46:08.380 --> 00:46:16.210
真的很快，我们可以建立多个

00:46:12.720 --> 00:46:19.150
 jar文件将构建工件分开，因此

00:46:16.210 --> 00:46:22.150
依赖关系已解决

00:46:19.150 --> 00:46:26.440
由Maven或Gradle自动或

00:46:22.150 --> 00:46:29.730
不管我们可以使用方舟之类的东西

00:46:26.440 --> 00:46:32.650
单元是一个框架，可以

00:46:29.730 --> 00:46:33.850
实施某些软件包结构或

00:46:32.650 --> 00:46:35.680
甚至比封装结构

00:46:33.850 --> 00:46:38.110
其实我只是在这里用

00:46:35.680 --> 00:46:42.250
执行包结构

00:46:38.110 --> 00:46:46.870
依赖关系，或者我们可以使用

00:46:42.250 --> 00:46:49.150
他的奥利模量法

00:46:46.870 --> 00:46:53.380
昨天介绍的我只是编辑这个

00:46:49.150 --> 00:46:56.770
讲完幻灯片我们可以使用Java 

00:46:53.380 --> 00:46:59.560
模块也可能会工作，但

00:46:56.770 --> 00:47:01.840
我习惯有更多时间

00:46:59.560 --> 00:47:06.400
学习新的Java知识，所以我没有看过

00:47:01.840 --> 00:47:07.840
是的，是的，关于执行

00:47:06.400 --> 00:47:10.000
重要的八度

00:47:07.840 --> 00:47:11.820
加强架构有点

00:47:10.000 --> 00:47:14.680
重要，因为如果您不这样做

00:47:11.820 --> 00:47:16.440
微服务是我设置了微服务

00:47:14.680 --> 00:47:18.420
这是本次演讲中的第一次

00:47:16.440 --> 00:47:20.940
如果你不做那很棒

00:47:18.420 --> 00:47:23.970
微服务，如果您正在构建

00:47:20.940 --> 00:47:26.250
在巨石中的应用

00:47:23.970 --> 00:47:28.860
代码库，这对于

00:47:26.250 --> 00:47:32.580
实施架构规则，因为

00:47:28.860 --> 00:47:37.500
否则某些设计缺陷会滑倒

00:47:32.580 --> 00:47:39.150
可以得出什么结论

00:47:37.500 --> 00:47:42.330
以领域为中心的好处

00:47:39.150 --> 00:47:49.220
像干净的建筑或

00:47:42.330 --> 00:47:52.590
我们有独立的六角形建筑

00:47:49.220 --> 00:47:55.620
出于不同变化原因的课程

00:47:52.590 --> 00:47:58.080
因此我们没有将此磁盘放入

00:47:55.620 --> 00:48:00.330
数据库，我们可以找到我们的用例

00:47:58.080 --> 00:48:03.270
更好，因为我们将它们分开

00:48:00.330 --> 00:48:06.150
可以在不同的班级工作

00:48:03.270 --> 00:48:10.380
并行更好，因为我们削减了

00:48:06.150 --> 00:48:12.090
东西变成更多的小块

00:48:10.380 --> 00:48:14.550
更容易测试，因为依赖项

00:48:12.090 --> 00:48:19.080
是清楚的，没有界限

00:48:14.550 --> 00:48:21.840
不再模糊所以容易有

00:48:19.080 --> 00:48:24.750
某些缺点当然与我一样

00:48:21.840 --> 00:48:27.840
说如果有的话就做

00:48:24.750 --> 00:48:30.240
硬边界

00:48:27.840 --> 00:48:32.880
边界很贵，只是问唐纳德

00:48:30.240 --> 00:48:36.240
特朗普，我认为他是他的一个问题

00:48:32.880 --> 00:48:38.130
目前的边界，所以我们每个都有

00:48:36.240 --> 00:48:39.270
边界要求，如果你想做

00:48:38.130 --> 00:48:41.760
心脏边界，你必须做一个

00:48:39.270 --> 00:48:45.780
映射，因此可能会感觉到您

00:48:41.760 --> 00:48:48.210
必须映射很多，我们有一些感知

00:48:45.780 --> 00:48:50.190
冗余，因为如果我们减少使用

00:48:48.210 --> 00:48:51.720
我们将用例分开的情况

00:48:50.190 --> 00:48:55.320
彼此

00:48:51.720 --> 00:48:56.760
我们必须重复一些事情，所以如果

00:48:55.320 --> 00:48:59.580
我们改变一个用例，另一个

00:48:56.760 --> 00:49:03.660
无需更改，我们需要真正的

00:48:59.580 --> 00:49:06.420
业务逻辑，如果您很难

00:49:03.660 --> 00:49:08.280
只是做一个简单的应用程序

00:49:06.420 --> 00:49:10.620
不需要这种建筑风格

00:49:08.280 --> 00:49:12.870
这只有在您拥有真正的

00:49:10.620 --> 00:49:14.760
您可以放入的业务逻辑

00:49:12.870 --> 00:49:17.040
你的中间到你的中心

00:49:14.760 --> 00:49:20.760
建筑，那么你有真正的

00:49:17.040 --> 00:49:23.280
价值，就是这样，谢谢您

00:49:20.760 --> 00:49:24.960
我已经总结了一些耐心

00:49:23.280 --> 00:49:28.190
一本书多一点

00:49:24.960 --> 00:49:30.299
您可以在此链接下下载

00:49:28.190 --> 00:49:33.120
感谢您的耐心等待

00:49:30.299 --> 00:49:38.030
对我来说很有趣

00:49:33.120 --> 00:49:38.030
 [掌声] 

00:49:39.050 --> 00:49:42.300
 [音乐] 

