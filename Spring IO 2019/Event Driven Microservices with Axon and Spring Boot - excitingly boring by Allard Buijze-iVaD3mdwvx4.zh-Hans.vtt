WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.900 --> 00:00:07.990
 [音乐] 

00:00:05.439 --> 00:00:09.580
看到这么多，我感到非常兴奋

00:00:07.990 --> 00:00:12.190
你们中的一个参加会议

00:00:09.580 --> 00:00:14.230
一定会很无聊，所以我会离开

00:00:12.190 --> 00:00:16.150
让我兴奋，给你

00:00:14.230 --> 00:00:18.939
无聊的东西，我们会看到我们去哪里

00:00:16.150 --> 00:00:21.369
从现在开始我很确定你

00:00:18.939 --> 00:00:23.439
所有人中都有这些时刻

00:00:21.369 --> 00:00:27.670
您的事业或您的希望

00:00:23.439 --> 00:00:30.939
你做了一些的日常生活

00:00:27.670 --> 00:00:32.470
应用程序，并且您想要

00:00:30.939 --> 00:00:34.480
测试一些您想尝试的东西

00:00:32.470 --> 00:00:36.190
找出一些新技术并尝试

00:00:34.480 --> 00:00:37.300
您发现的所有东西

00:00:36.190 --> 00:00:39.370
您可能已经看过很多讲座

00:00:37.300 --> 00:00:41.590
今天和昨天你想尝试

00:00:39.370 --> 00:00:43.510
出来，所以你要做的就是你建立

00:00:41.590 --> 00:00:45.250
你运行它的东西，它结合了

00:00:43.510 --> 00:00:48.760
您可以找到的所有正确功能

00:00:45.250 --> 00:00:51.070
面部识别找出心情

00:00:48.760 --> 00:00:52.900
您当前拥有的然后扫描

00:00:51.070 --> 00:00:54.670
整个互联网流所有页面

00:00:52.900 --> 00:00:57.310
他们可以找到的信息和信息

00:00:54.670 --> 00:00:59.080
什么样的问候最适合

00:00:57.310 --> 00:01:00.840
您当前所处的心情， 

00:00:59.080 --> 00:01:03.910
您正在尝试放入一些

00:01:00.840 --> 00:01:06.689
为此，一些春季湿润的助焊剂

00:01:03.910 --> 00:01:11.109
只是因为你可以然后它输出

00:01:06.689 --> 00:01:12.490
是的，您好，HelloWorld很自豪， 

00:01:11.109 --> 00:01:16.679
你真的很兴奋，你已经准备好了

00:01:12.490 --> 00:01:19.119
使它顺利进入生产

00:01:16.679 --> 00:01:21.820
不幸的是，生产并不是真正的

00:01:19.119 --> 00:01:23.350
兴奋权生产的地方是

00:01:21.820 --> 00:01:26.560
一个一切都必须存在的地方

00:01:23.350 --> 00:01:28.329
无聊，否则就是你的电话响了

00:01:26.560 --> 00:01:30.969
在半夜兴奋

00:01:28.329 --> 00:01:35.890
当有火灾准备发生时

00:01:30.969 --> 00:01:37.359
熄灭之类的东西，所以这

00:01:35.890 --> 00:01:39.640
是您需要的无聊的东西吗

00:01:37.359 --> 00:01:41.679
无聊的东西让它运行

00:01:39.640 --> 00:01:45.609
生产并确保其停留

00:01:41.679 --> 00:01:47.710
如果您已经看到，现在可以在生产中运行

00:01:45.609 --> 00:01:50.469
与我的其他谈话你知道我爱

00:01:47.710 --> 00:01:52.749
分层架构，最近我来了

00:01:50.469 --> 00:01:54.909
略有不同的名称

00:01:52.749 --> 00:01:57.939
我以为我喜欢

00:01:54.909 --> 00:01:59.889
它的名称是通用BBC 

00:01:57.939 --> 00:02:01.810
建筑，它无关

00:01:59.889 --> 00:02:05.469
与广播组织在

00:02:01.810 --> 00:02:08.080
我希望是英国，基本上是书籍

00:02:05.469 --> 00:02:11.080
书筒右筒存放

00:02:08.080 --> 00:02:13.120
东西，前面有一些盒子

00:02:11.080 --> 00:02:15.270
因为我们要分开关注点

00:02:13.120 --> 00:02:17.070
对，所以我们不想把它放

00:02:15.270 --> 00:02:20.610
我们把一个盒子放进去-因为那

00:02:17.070 --> 00:02:24.210
帮助我们构建更好的软件

00:02:20.610 --> 00:02:26.310
我猜很不幸，事实并非如此， 

00:02:24.210 --> 00:02:29.700
我们构建的软件最终出现在

00:02:26.310 --> 00:02:36.600
臭名昭著的大泥球

00:02:29.700 --> 00:02:38.940
如今当然显然现在不泥泞

00:02:36.600 --> 00:02:41.010
你不可能拿出一个大球

00:02:38.940 --> 00:02:43.410
泥浆，所以我们今天要做的是

00:02:41.010 --> 00:02:46.250
微观的建筑风格

00:02:43.410 --> 00:02:49.620
服务我们微服务一切

00:02:46.250 --> 00:02:51.600
所以我们有我们的小英国广播公司，我们

00:02:49.620 --> 00:02:54.090
他们有点小，我部署很多

00:02:51.600 --> 00:02:57.810
其中可能会出问题的地方

00:02:54.090 --> 00:02:59.850
现在我们的BBC小盒子

00:02:57.810 --> 00:03:03.690
连接，我们分开了一些

00:02:59.850 --> 00:03:07.740
根据我的经验看来

00:03:03.690 --> 00:03:09.150
随机，但所有这些担忧都是

00:03:07.740 --> 00:03:12.060
分裂全部，那就是

00:03:09.150 --> 00:03:15.270
太棒了，现在的问题是，如果您服用

00:03:12.060 --> 00:03:18.150
为您提供设计理念

00:03:15.270 --> 00:03:20.520
大碗泥然后增加

00:03:18.150 --> 00:03:26.540
该部署单元的数量

00:03:20.520 --> 00:03:29.790
设计原理你会很乱

00:03:26.540 --> 00:03:34.290
让我们称它为“拉屎吧” 

00:03:29.790 --> 00:03:36.360
叫它是什么，让我们不要这样

00:03:34.290 --> 00:03:39.750
我们要做的是专注于

00:03:36.360 --> 00:03:41.850
首先增加模块化，现在有

00:03:39.750 --> 00:03:45.450
关于模块化的一些讨论或

00:03:41.850 --> 00:03:47.070
模数之前有一些谈话

00:03:45.450 --> 00:03:48.780
所以这不是一个新话题

00:03:47.070 --> 00:03:51.270
这是我们应该真正做到的

00:03:48.780 --> 00:03:54.020
专注于所以我们首先尝试建立

00:03:51.270 --> 00:03:56.730
结构良好的东西

00:03:54.020 --> 00:03:58.440
显然不是一大碗泥

00:03:56.730 --> 00:04:01.530
一旦我们向自己证明

00:03:58.440 --> 00:04:04.020
我们可以做到，然后我们可以增加

00:04:01.530 --> 00:04:07.560
部署单元的数量并去那里

00:04:04.020 --> 00:04:12.120
这是微妙的美丽土地

00:04:07.560 --> 00:04:13.890
我们都想成为的服务是

00:04:12.120 --> 00:04:16.709
没有兑现承诺的地方

00:04:13.890 --> 00:04:19.350
不幸的是最下面的一个

00:04:16.709 --> 00:04:22.530
我们项目中一些邪恶的黑暗力量

00:04:19.350 --> 00:04:25.090
迫使我们回到了大世界

00:04:22.530 --> 00:04:28.000
在角落里的一堆

00:04:25.090 --> 00:04:31.870
这些通常是技术债务

00:04:28.000 --> 00:04:33.730
一般经理说我

00:04:31.870 --> 00:04:36.880
希望到明天所有这些东西， 

00:04:33.730 --> 00:04:39.910
你不只是更快地工作只是想

00:04:36.880 --> 00:04:41.590
变得更聪明我不知道只是尝试

00:04:39.910 --> 00:04:44.440
有些东西，但是明天我需要

00:04:41.590 --> 00:04:46.930
这些是各种各样的力量

00:04:44.440 --> 00:04:49.210
你陷入困境，我们需要战斗

00:04:46.930 --> 00:04:52.330
这些力量对，我们需要所有工具

00:04:49.210 --> 00:04:59.290
我们可以提供帮助的工具箱

00:04:52.330 --> 00:05:01.540
我们现在待在那里我非常坚定

00:04:59.290 --> 00:05:03.790
微服务之旅的信徒

00:05:01.540 --> 00:05:05.620
那旅程总是以

00:05:03.790 --> 00:05:06.820
想法正确，您有想要的概念

00:05:05.620 --> 00:05:09.250
建立一些东西可能是

00:05:06.820 --> 00:05:11.800
现有的应用程序终于

00:05:09.250 --> 00:05:13.210
如果你可能很幸运，因为你

00:05:11.800 --> 00:05:16.389
或多或少地知道您想要建造什么

00:05:13.210 --> 00:05:17.979
而你的志向通常是

00:05:16.389 --> 00:05:20.650
可以看到微服务

00:05:17.979 --> 00:05:22.419
服务已经存在，但是那段旅程

00:05:20.650 --> 00:05:25.000
那里很危险

00:05:22.419 --> 00:05:27.610
介于两者之间的危险土地

00:05:25.000 --> 00:05:31.090
很可能迷路并陷入困境

00:05:27.610 --> 00:05:33.220
散布泥球的东西，所以

00:05:31.090 --> 00:05:35.440
旅程应该去这个

00:05:33.220 --> 00:05:36.850
结构化整体结构首先证明

00:05:35.440 --> 00:05:39.669
你自己，你可以建立

00:05:36.850 --> 00:05:41.680
应用程序，然后您可以拆分出一些

00:05:39.669 --> 00:05:44.260
组件或新建

00:05:41.680 --> 00:05:46.870
组件分开缓慢

00:05:44.260 --> 00:05:48.550
稳步前进，然后前进

00:05:46.870 --> 00:05:50.950
也许那你真的可以去这个

00:05:48.550 --> 00:05:55.000
希望通过服务承诺的土地

00:05:50.950 --> 00:05:59.470
那么它的构造很好，除非

00:05:55.000 --> 00:06:01.090
比现在更好

00:05:59.470 --> 00:06:04.630
要实现有这个概念

00:06:01.090 --> 00:06:07.169
我们喜欢在我们的外显子位置

00:06:04.630 --> 00:06:09.820
透明度，这是原则

00:06:07.169 --> 00:06:13.030
我们应用程序中的组件是

00:06:09.820 --> 00:06:14.470
完全不知道位置

00:06:13.030 --> 00:06:17.560
它的其他组件

00:06:14.470 --> 00:06:19.539
与权利沟通，因为在那

00:06:17.560 --> 00:06:21.910
在这种情况下，我们无需更改任何

00:06:19.539 --> 00:06:24.600
我们要采取的逻辑

00:06:21.910 --> 00:06:27.820
这些组件之一将其拆分或

00:06:24.600 --> 00:06:29.200
将其从整体中分离出来

00:06:27.820 --> 00:06:31.120
有一些技术胶水

00:06:29.200 --> 00:06:33.880
需要做的正确一些

00:06:31.120 --> 00:06:35.380
配置问题可能是你

00:06:33.880 --> 00:06:36.020
需要做的是确保

00:06:35.380 --> 00:06:38.349
通讯

00:06:36.020 --> 00:06:40.669
可以实际发生

00:06:38.349 --> 00:06:43.340
单个JVM中的通信是

00:06:40.669 --> 00:06:45.680
很简单，我们都知道它倾向于

00:06:43.340 --> 00:06:50.960
拥有时变得更加困难

00:06:45.680 --> 00:06:53.720
跨越JVM边界，因此消息传递是

00:06:50.960 --> 00:06:56.449
微观上非常重要的概念

00:06:53.720 --> 00:06:59.360
服务权利，我们都知道事件

00:06:56.449 --> 00:07:03.710
正确的事件通常被解释为

00:06:59.360 --> 00:07:06.229
通知某事

00:07:03.710 --> 00:07:08.120
他们一般都有相关的经历

00:07:06.229 --> 00:07:10.039
过去式，然后他们只描述一个

00:07:08.120 --> 00:07:12.229
事实上，您无法否认

00:07:10.039 --> 00:07:14.479
事实上发生了，你最好

00:07:12.229 --> 00:07:17.569
用它，他们跟随一个典型的酒吧

00:07:14.479 --> 00:07:19.639
商店的模式，但它们不是

00:07:17.569 --> 00:07:21.409
仅有的消息类型

00:07:19.639 --> 00:07:22.490
在微资源之间，它不会

00:07:21.409 --> 00:07:25.069
很重要，真的很重要

00:07:22.490 --> 00:07:27.860
从概念上实施它们，您还将

00:07:25.069 --> 00:07:30.440
有命令和查询，你也有

00:07:27.860 --> 00:07:32.509
表示一个的消息

00:07:30.440 --> 00:07:35.270
我希望你的另一个组成部分

00:07:32.509 --> 00:07:37.940
去做我期望你做的事情

00:07:35.270 --> 00:07:40.430
之后的系统状态会发生变化

00:07:37.940 --> 00:07:43.159
您执行了相反的命令

00:07:40.430 --> 00:07:44.840
到现在是什么，然后有

00:07:43.159 --> 00:07:46.280
另一个有查询和

00:07:44.840 --> 00:07:48.590
查询是我需要信息

00:07:46.280 --> 00:07:56.360
我知道另一个组件具有

00:07:48.590 --> 00:07:58.130
我需要的信息，所以要非常小心

00:07:56.360 --> 00:08:00.500
事件和消息不是

00:07:58.130 --> 00:08:03.919
同一件事写一条消息是

00:08:00.500 --> 00:08:05.569
所有的父母的刻板印象

00:08:03.919 --> 00:08:06.949
他们所命令的消息类型

00:08:05.569 --> 00:08:08.599
事件和您可以拥有的查询

00:08:06.949 --> 00:08:10.250
现在，这三个消息如下

00:08:08.599 --> 00:08:12.909
不同的路由模式时

00:08:10.250 --> 00:08:15.169
命令转到单个目标

00:08:12.909 --> 00:08:16.969
有一个副作用是

00:08:15.169 --> 00:08:19.009
你可能想得到的那个指挥官

00:08:16.969 --> 00:08:23.360
正常或不正常的一些通知

00:08:19.009 --> 00:08:25.940
回到以让您知道您是否

00:08:23.360 --> 00:08:28.779
意图已经跟进并遵循

00:08:25.940 --> 00:08:32.560
甚至是英语也不确定

00:08:28.779 --> 00:08:35.270
另一方面，它们是

00:08:32.560 --> 00:08:37.849
有发送到某个地方，然后

00:08:35.270 --> 00:08:39.709
发送者可能正在等待

00:08:37.849 --> 00:08:41.570
没有线程在等待，但至少

00:08:39.709 --> 00:08:44.120
从概念上讲，它在等待回应

00:08:41.570 --> 00:08:45.199
它需要信息，所以它在等待

00:08:44.120 --> 00:08:47.630
该信息变得可用

00:08:45.199 --> 00:08:49.279
在继续前进之前

00:08:47.630 --> 00:08:50.630
还有一些有趣的事情

00:08:49.279 --> 00:08:52.940
可以做你可以做的查询

00:08:50.630 --> 00:08:55.699
您可以一起向许多人发送查询

00:08:52.940 --> 00:08:58.310
组件收集所有答案

00:08:55.699 --> 00:09:01.910
一些减少功能，并采取

00:08:58.310 --> 00:09:03.649
您最喜欢的答案

00:09:01.910 --> 00:09:05.630
例如我想得到的价格

00:09:03.649 --> 00:09:08.420
您可以得到各种价格的产品

00:09:05.630 --> 00:09:10.250
鉴于我自然是荷兰人

00:09:08.420 --> 00:09:11.060
还原功能是取

00:09:10.250 --> 00:09:13.579
最便宜的

00:09:11.060 --> 00:09:17.720
那就是产品的价格

00:09:13.579 --> 00:09:19.550
因此，让我们去做一个小演示， 

00:09:17.720 --> 00:09:20.839
我不打算全部编写代码

00:09:19.550 --> 00:09:22.579
事情，因为那不是

00:09:20.839 --> 00:09:25.940
令人兴奋的无聊只是

00:09:22.579 --> 00:09:28.279
平淡无聊，所以我所做的就是我

00:09:25.940 --> 00:09:31.459
确实为此准备了所有代码，而我

00:09:28.279 --> 00:09:34.459
要无聊地重置我的

00:09:31.459 --> 00:09:36.819
通过代码的方式-然后步行

00:09:34.459 --> 00:09:39.620
通过它，所以这是一个应用程序

00:09:36.819 --> 00:09:41.180
这将是可用的

00:09:39.620 --> 00:09:44.720
 github也一样，所以你可以检查出来

00:09:41.180 --> 00:09:47.449
从字面上看，有几个

00:09:44.720 --> 00:09:49.750
 API类的类别是

00:09:47.449 --> 00:09:54.220
主要的有很多命令

00:09:49.750 --> 00:09:57.800
让我们转到有几个

00:09:54.220 --> 00:10:00.050
这里定义的命令

00:09:57.800 --> 00:10:01.790
注册自行车命令，这是一辆自行车出租

00:10:00.050 --> 00:10:03.980
自从我申请以来

00:10:01.790 --> 00:10:05.480
荷兰人，我们拥有的自行车会做的一切

00:10:03.980 --> 00:10:08.839
通常一个，所以我们不需要租

00:10:05.480 --> 00:10:11.380
但是，谁在乎我当时要注册一辆自行车

00:10:08.839 --> 00:10:16.100
我可以租那辆自行车，还可以归还

00:10:11.380 --> 00:10:17.720
右边有一辆自行车

00:10:16.100 --> 00:10:20.089
这种情况是合计的

00:10:17.720 --> 00:10:23.269
动作概念是一致的

00:10:20.089 --> 00:10:24.889
在这种情况下，只有一个实体的边界

00:10:23.269 --> 00:10:27.920
但总体上有许多实体

00:10:24.889 --> 00:10:29.930
一起我也用

00:10:27.920 --> 00:10:30.589
标识这是在

00:10:29.930 --> 00:10:34.100
冬眠的

00:10:30.589 --> 00:10:36.410
对不起，JP，是一个实体，这是一个

00:10:34.100 --> 00:10:39.319
通知还要求轴突说得好我

00:10:36.410 --> 00:10:41.779
只想将此聚合存储为

00:10:39.319 --> 00:10:44.360
 JPA实体仅位于数据库中的某个位置

00:10:41.779 --> 00:10:46.970
它具有许多作为

00:10:44.360 --> 00:10:49.639
标识一个地点，无论谁租了

00:10:46.970 --> 00:10:52.759
如果不租自行车，自行车可能为空

00:10:49.639 --> 00:10:55.100
当下有一堆命令

00:10:52.759 --> 00:10:56.720
处理程序，以便我可以注册

00:10:55.100 --> 00:10:59.839
自行车是构造函数，因此它可以创建

00:10:56.720 --> 00:11:00.529
一辆新自行车，然后如果我有一辆自行车我

00:10:59.839 --> 00:11:03.049
可以租

00:11:00.529 --> 00:11:05.269
或将其退回，并检查是否

00:11:03.049 --> 00:11:08.269
已经被出租或不出租

00:11:05.269 --> 00:11:10.339
确保逻辑有效，然后我们

00:11:08.269 --> 00:11:13.309
有一个查询服务，说我有一个

00:11:10.339 --> 00:11:15.319
查询处理程序我可以发送查询，如

00:11:13.309 --> 00:11:18.889
有人想知道给我所有

00:11:15.319 --> 00:11:21.289
自行车，那么我将尽一切所能

00:11:18.889 --> 00:11:23.289
只是把一切委托给春天

00:11:21.289 --> 00:11:27.219
数据JPA存储库

00:11:23.289 --> 00:11:29.689
没有比我更无聊的了

00:11:27.219 --> 00:11:33.349
我能找到一个很好的

00:11:29.689 --> 00:11:36.559
应用程序为空，存储库为

00:11:33.349 --> 00:11:38.479
空，然后我们有一个控制器

00:11:36.559 --> 00:11:40.279
确保我们可以与

00:11:38.479 --> 00:11:41.989
这个应用程序，但控制器

00:11:40.279 --> 00:11:44.209
并没有真正调用任何

00:11:41.989 --> 00:11:46.849
组件直接不同

00:11:44.209 --> 00:11:49.759
这是该组件说我想要

00:11:46.849 --> 00:11:53.449
发送命令，所以当我穿上

00:11:49.759 --> 00:11:56.839
自行车ID我做了一个命令网关点

00:11:53.449 --> 00:12:02.299
并用该ID注册一辆自行车，并

00:11:56.839 --> 00:12:04.369
那个位置对

00:12:02.299 --> 00:12:07.129
毫无用处的地步

00:12:04.369 --> 00:12:09.229
这样的消息传递，但是我们可以

00:12:07.129 --> 00:12:11.599
在途中做一些更酷的事情，所以不要

00:12:09.229 --> 00:12:13.159
暂时放弃，这样我就可以运行

00:12:11.599 --> 00:12:16.399
您只需要信任我的应用程序

00:12:13.159 --> 00:12:18.909
它会很好的运行不要相信我

00:12:16.399 --> 00:12:18.909
让我们运行它

00:12:27.740 --> 00:12:37.820
我喜欢完成完成是一个

00:12:32.720 --> 00:12:45.820
在舞台上比在舞台上慢很多

00:12:37.820 --> 00:12:50.210
准备好就可以拿走我的

00:12:45.820 --> 00:12:52.010
 SP要求在这里，我可以做到

00:12:50.210 --> 00:12:57.590
可以创造一个贝克，让我们把它放进去

00:12:52.010 --> 00:13:00.170
巴塞罗那循环现在在那儿运行

00:12:57.590 --> 00:13:01.970
它说1 2 3 4它返回

00:13:00.170 --> 00:13:02.600
我们刚才的自行车的标识符

00:13:01.970 --> 00:13:04.640
被创造

00:13:02.600 --> 00:13:06.860
太好了，现在我们可以租出去了

00:13:04.640 --> 00:13:08.350
对，所以我们可以租它，假设我选择

00:13:06.860 --> 00:13:11.590
它起来

00:13:08.350 --> 00:13:16.250
好的自行车租了一个很大的幻想

00:13:11.590 --> 00:13:18.380
让我们尝试由史蒂芬租它是我的

00:13:16.250 --> 00:13:22.970
同事哈我来不及了自行车

00:13:18.380 --> 00:13:28.880
已经让我退回它-放手

00:13:22.970 --> 00:13:30.440
乘车返回阿姆斯特丹

00:13:28.880 --> 00:13:32.270
现在，斯蒂芬对

00:13:30.440 --> 00:13:33.790
让自行车不确定他的状态

00:13:32.270 --> 00:13:37.190
给他们时间是他的问题

00:13:33.790 --> 00:13:38.900
所以那辆自行车什么都没租

00:13:37.190 --> 00:13:40.310
真的很特别，我们可以执行

00:13:38.900 --> 00:13:44.660
一个查询，你可以说你是什么自行车

00:13:40.310 --> 00:13:46.820
很棒，有一辆自行车

00:13:44.660 --> 00:13:49.760
当时在阿姆斯特丹，现在被租了

00:13:46.820 --> 00:13:56.450
斯蒂芬说的没错

00:13:49.760 --> 00:13:58.850
这些东西令人兴奋哦

00:13:56.450 --> 00:14:00.650
我那里没事，所以

00:13:58.850 --> 00:14:03.410
明确提及明确讯息

00:14:00.650 --> 00:14:05.600
只是给了我们我不的承诺

00:14:03.410 --> 00:14:09.260
知道位置的透明度，但不是

00:14:05.600 --> 00:14:13.000
那些知道的人真的很有价值

00:14:09.260 --> 00:14:16.760
轴突或那些不偶然的人是

00:14:13.000 --> 00:14:18.440
可以帮助您建立很大的框架

00:14:16.760 --> 00:14:20.390
规模或小规模并不是真的

00:14:18.440 --> 00:14:21.890
如此重要，但应用程序使用

00:14:20.390 --> 00:14:25.070
域驱动设计原理

00:14:21.890 --> 00:14:28.490
现在最安全的事件采购

00:14:25.070 --> 00:14:33.230
 CQRS是不熟悉CQRS的人

00:14:28.490 --> 00:14:35.350
让我们快速检查一下那些

00:14:33.230 --> 00:14:37.940
几个很好

00:14:35.350 --> 00:14:40.700
所以看爱抚是一个很简单的原则

00:14:37.940 --> 00:14:41.240
你说我在哪里申请

00:14:40.700 --> 00:14:43.040
不错

00:14:41.240 --> 00:14:45.230
该应用程序的责任

00:14:43.040 --> 00:14:47.929
分为两个部分

00:14:45.230 --> 00:14:49.699
用于处理我的命令更改

00:14:47.929 --> 00:14:53.089
应用程序，另一部分是

00:14:49.699 --> 00:14:54.949
负责处理哪些查询

00:14:53.089 --> 00:14:57.519
是为了提供有关

00:14:54.949 --> 00:15:00.740
申请权的当前状态

00:14:57.519 --> 00:15:02.660
实际上有某种形式的CQRS 

00:15:00.740 --> 00:15:04.579
在您拥有的任何应用程序中

00:15:02.660 --> 00:15:08.389
如果您使用搜索引擎，就在那里

00:15:04.579 --> 00:15:10.490
这是您正在执行的查询模型

00:15:08.389 --> 00:15:13.220
正确处理作为模型的查询

00:15:10.490 --> 00:15:15.889
设计用于处理特定类型的

00:15:13.220 --> 00:15:17.809
通常对富文本进行查询

00:15:15.889 --> 00:15:19.480
搜索，但还有其他类型的

00:15:17.809 --> 00:15:21.769
克鲁兹，你可以和他们一起做

00:15:19.480 --> 00:15:24.019
因此，这些区域中的每个区域都会有一个

00:15:21.769 --> 00:15:26.389
不同的模型对一个模型

00:15:24.019 --> 00:15:28.279
专注于做那是

00:15:26.389 --> 00:15:30.589
负责，因此命令模型是

00:15:28.279 --> 00:15:32.839
负责验证传入

00:15:30.589 --> 00:15:34.639
要求并决定要做什么，而

00:15:32.839 --> 00:15:36.410
投影负责

00:15:34.639 --> 00:15:38.929
处理查询并提供

00:15:36.410 --> 00:15:42.019
信息有效

00:15:38.929 --> 00:15:45.050
您想要我们的可能和原因

00:15:42.019 --> 00:15:46.850
 M我们通常使用事件来

00:15:45.050 --> 00:15:49.009
确保当我们执行命令时

00:15:46.850 --> 00:15:51.889
省略事件以使投影

00:15:49.009 --> 00:15:53.959
更新自己为什么我们

00:15:51.889 --> 00:15:55.490
通常想这样做

00:15:53.959 --> 00:15:58.579
因为无功能的沙皇相当

00:15:55.490 --> 00:16:02.509
在任何地方的任何地方都不同

00:15:58.579 --> 00:16:04.490
像紫色部分一样的系统

00:16:02.509 --> 00:16:06.679
离开也许是真的

00:16:04.490 --> 00:16:09.319
复杂的权利，这是一个非常复杂的部分

00:16:06.679 --> 00:16:11.600
系统的部署， 

00:16:09.319 --> 00:16:13.670
通常不是一个很好的组合

00:16:11.600 --> 00:16:15.949
有，所以你想绝对隔离

00:16:13.670 --> 00:16:17.509
其余的还有一些

00:16:15.949 --> 00:16:19.519
例子和右边的一个可能

00:16:17.509 --> 00:16:21.610
成为非常不稳定的组件

00:16:19.519 --> 00:16:24.499
而且它使用大量的内存

00:16:21.610 --> 00:16:26.089
无论出于何种原因，您可能想要

00:16:24.499 --> 00:16:28.399
能够将其分开

00:16:26.089 --> 00:16:31.399
那如果崩溃的话就不用了

00:16:28.399 --> 00:16:33.920
顺理成章地尝试其他一切

00:16:31.399 --> 00:16:37.879
解决稳定性问题，但这就是我

00:16:33.920 --> 00:16:41.749
我在这个例子中现在猜想很明显

00:16:37.879 --> 00:16:43.970
之前那绝对是微不足道的

00:16:41.749 --> 00:16:46.069
正确的例子，这是最简单的

00:16:43.970 --> 00:16:48.410
我能想到的应用程序显示

00:16:46.069 --> 00:16:50.959
 CQRS甚至在该应用程序中

00:16:48.410 --> 00:16:53.410
我们已经看到一些意外

00:16:50.959 --> 00:16:53.410
复杂

00:16:54.380 --> 00:16:59.720
因此，想象一下您需要工作五分钟

00:16:57.860 --> 00:17:03.260
遇到第一次意外的复杂性

00:16:59.720 --> 00:17:05.270
想象一下如果开始

00:17:03.260 --> 00:17:07.490
继续为此工作

00:17:05.270 --> 00:17:11.180
连续几天，问题出在

00:17:07.490 --> 00:17:13.310
自行车课，如果我们看一下自行车

00:17:11.180 --> 00:17:15.200
它的结构方式非常好

00:17:13.310 --> 00:17:16.940
正确的视图信息，这是

00:17:15.200 --> 00:17:19.790
查询时需要的信息

00:17:16.940 --> 00:17:22.550
我们想知道自行车在哪里以及谁

00:17:19.790 --> 00:17:24.590
目前已将其出租，但

00:17:22.550 --> 00:17:26.930
执行命令以验证是否

00:17:24.590 --> 00:17:29.390
现在是否可以租用自行车

00:17:26.930 --> 00:17:31.310
信息太多了

00:17:29.390 --> 00:17:35.560
这样信息对

00:17:31.310 --> 00:17:35.560
查询但不用于执行命令

00:17:35.740 --> 00:17:40.130
所以我们能做的就是可以申请寻求

00:17:38.480 --> 00:17:43.300
我们到刚才的应用程序

00:17:40.130 --> 00:17:46.760
内置的，为此我们需要做的是

00:17:43.300 --> 00:17:49.210
重设，您可以自己做

00:17:46.760 --> 00:17:55.250
项目当然不是

00:17:49.210 --> 00:17:56.840
在那里，我们走了，我在作弊，我知道我在做

00:17:55.250 --> 00:18:00.950
答应我确实写了所有代码

00:17:56.840 --> 00:18:02.360
就在这里，所以我们要做的是拆分

00:18:00.950 --> 00:18:04.070
命令和查询，所以有

00:18:02.360 --> 00:18:05.870
现在有不同的包装

00:18:04.070 --> 00:18:08.000
命令包，嘿，有我们的自行车

00:18:05.870 --> 00:18:09.830
再次看起来像现在

00:18:08.000 --> 00:18:12.500
稍有不同，仍然

00:18:09.830 --> 00:18:15.110
实体，这是一个聚合，但现在有

00:18:12.500 --> 00:18:18.740
只是布尔值，布尔值是

00:18:15.110 --> 00:18:22.520
最简单的数据形式是

00:18:18.740 --> 00:18:24.110
我们数据的原子一切

00:18:22.520 --> 00:18:28.780
否则只是一堆欺凌

00:18:24.110 --> 00:18:30.920
在我们的API中，我们添加了一些事件

00:18:28.780 --> 00:18:32.750
因为现在作为我们的一部分

00:18:30.920 --> 00:18:34.280
我们开始发出事件的命令

00:18:32.750 --> 00:18:37.610
因为这很简单

00:18:34.280 --> 00:18:41.750
应用程序aa命令结果为aa 

00:18:37.610 --> 00:18:44.540
发生事件，但产量更高

00:18:41.750 --> 00:18:46.730
像系统更有价值的系统

00:18:44.540 --> 00:18:50.870
空中指挥和事件趋于分歧

00:18:46.730 --> 00:18:52.610
有点，我们有一些查询模型

00:18:50.870 --> 00:18:54.530
这给了我们一个状态

00:18:52.610 --> 00:18:56.330
骑自行车，这是我们拥有的数据

00:18:54.530 --> 00:18:59.300
较早的自行车ID的位置和

00:18:56.330 --> 00:19:02.240
承租人，这现在也是一个实体

00:18:59.300 --> 00:19:03.920
我们有我们的投影班

00:19:02.240 --> 00:19:06.570
做一些有趣的事情让我

00:19:03.920 --> 00:19:10.899
想拿到

00:19:06.570 --> 00:19:13.559
一些更多的空间，所以它是做什么的

00:19:10.899 --> 00:19:17.140
在存储库中使用spring数据API 

00:19:13.559 --> 00:19:18.730
这很无聊

00:19:17.140 --> 00:19:21.970
它为您提供了所有可能的东西

00:19:18.730 --> 00:19:23.559
需要，它对事件做出反应，并说

00:19:21.970 --> 00:19:27.490
当我注册自行车时，我想

00:19:23.559 --> 00:19:30.460
当我得到一个新的状态项

00:19:27.490 --> 00:19:32.679
租了辆自行车我要去找自行车

00:19:30.460 --> 00:19:36.240
那是租来的，我把租人

00:19:32.679 --> 00:19:38.980
在那里，这只是简单的

00:19:36.240 --> 00:19:40.389
简单的更新，然后有一些

00:19:38.980 --> 00:19:42.250
如果需要的话，查询处理程序说的很好

00:19:40.389 --> 00:19:44.799
所有这些我们都做一个仓库

00:19:42.250 --> 00:19:46.840
发现所有逻辑都差不多

00:19:44.799 --> 00:19:48.990
相同，但我们将两种模型分开

00:19:46.840 --> 00:19:51.070
现在有一个专注于命令模型

00:19:48.990 --> 00:19:52.960
验证您是否被允许

00:19:51.070 --> 00:19:56.529
租那辆自行车，有一个查询模型

00:19:52.960 --> 00:20:00.460
告诉你自行车在哪里还是

00:19:56.529 --> 00:20:03.279
目前拥有它的人都很棒

00:20:00.460 --> 00:20:06.909
但是还有更多，让我们继续前进

00:20:03.279 --> 00:20:11.710
在你要我运行的

00:20:06.909 --> 00:20:21.130
我不知道你说什么

00:20:11.710 --> 00:20:23.850
我只是将其解释为是

00:20:21.130 --> 00:20:23.850
另一个仍在运行

00:20:28.760 --> 00:20:32.630
现在，如果您期望其他任何行为， 

00:20:31.040 --> 00:20:35.900
真的要让你失望，因为我们

00:20:32.630 --> 00:20:38.000
现在还没有改变任何行为

00:20:35.900 --> 00:20:40.490
事情是因为更改配置

00:20:38.000 --> 00:20:42.020
这里有我们所有的基础设施

00:20:40.490 --> 00:20:44.090
需要获得命令给他们

00:20:42.020 --> 00:20:45.740
将事件发布到的目的地

00:20:44.090 --> 00:20:48.350
他们的目的地，甚至是查询

00:20:45.740 --> 00:20:50.090
到他们的目的地，什么都没有

00:20:48.350 --> 00:20:52.190
我们的应用程序具有

00:20:50.090 --> 00:20:54.260
基础设施对基础设施

00:20:52.190 --> 00:20:58.790
也都已配置并接线

00:20:54.260 --> 00:21:00.470
对我们而言，基于糟糕，基于

00:20:58.790 --> 00:21:02.660
其他的可用性

00:21:00.470 --> 00:21:04.940
到底我是说依赖

00:21:02.660 --> 00:21:11.330
 spring boot 大部分是XML编程

00:21:04.940 --> 00:21:13.880
正确，它会退回给人们

00:21:11.330 --> 00:21:15.830
回到春天的那一天

00:21:13.880 --> 00:21:17.419
只是做了很多XML然后就可以了

00:21:15.830 --> 00:21:21.260
春季书也一样，但是你

00:21:17.419 --> 00:21:26.540
在这里，我们去做我们发出一个

00:21:21.260 --> 00:21:29.660
我们对使用的自行车不感兴趣

00:21:26.540 --> 00:21:33.169
这些演示的内存数据库，因此

00:21:29.660 --> 00:21:36.040
我发行了我的自行车正在出租

00:21:33.169 --> 00:21:39.740
梦幻般的史蒂芬想租它

00:21:36.040 --> 00:21:42.049
万万没用，所以没事

00:21:39.740 --> 00:21:44.929
没有什么真正的改变，只是

00:21:42.049 --> 00:21:49.520
再次使用同一应用程序，让我们尝试停止

00:21:44.929 --> 00:21:51.559
没关系，所以我们更改了很多代码

00:21:49.520 --> 00:21:54.230
真的什么都没发生

00:21:51.559 --> 00:21:55.940
真的没有什么改变，好极了，我们已经

00:21:54.230 --> 00:21:57.470
我们有世界上最好的样本

00:21:55.940 --> 00:21:59.660
对，有很多令人兴奋的东西

00:21:57.470 --> 00:22:02.600
发生了，但我们看不到

00:21:59.660 --> 00:22:04.790
还在外面，因为现在我们在

00:22:02.600 --> 00:22:07.850
发布事件，有一些东西

00:22:04.790 --> 00:22:10.250
关于命令和

00:22:07.850 --> 00:22:15.559
查询没有的是，它们仍然存在

00:22:10.250 --> 00:22:17.870
随着时间的推移它们代表着宝贵的价值

00:22:15.559 --> 00:22:19.669
他们描述了一个事实， 

00:22:17.870 --> 00:22:21.980
记住这一点可能很有价值

00:22:19.669 --> 00:22:24.559
我们的事实发生了几天

00:22:21.980 --> 00:22:27.590
从现在起几个月甚至几年

00:22:24.559 --> 00:22:30.919
还有一些挑战，我们如何

00:22:27.590 --> 00:22:34.100
保证该出版物的发布

00:22:30.919 --> 00:22:37.130
事件和我们实体的存储新

00:22:34.100 --> 00:22:39.620
实体国家是一个原子操作

00:22:37.130 --> 00:22:41.360
我们能否保证我们做到了

00:22:39.620 --> 00:22:41.600
回滚数据库事务

00:22:41.360 --> 00:22:44.330
一些

00:22:41.600 --> 00:22:46.309
你把事件发布了吗

00:22:44.330 --> 00:22:48.410
有一些解决方案

00:22:46.309 --> 00:22:50.630
是的，但是还有另一件事

00:22:48.410 --> 00:22:53.510
事件是你怎么能保证

00:22:50.630 --> 00:22:55.130
您忽略的事件是真实的

00:22:53.510 --> 00:22:59.000
发生的事情的表示

00:22:55.130 --> 00:23:00.470
过去基本上我们想要的是事实

00:22:59.000 --> 00:23:03.950
整个事实，除了

00:23:00.470 --> 00:23:05.840
事实，以及事件是否是

00:23:03.950 --> 00:23:10.520
你在做什么，你不能保证

00:23:05.840 --> 00:23:13.130
这是事件的来源

00:23:10.520 --> 00:23:14.720
一切正常，如果有的话

00:23:13.130 --> 00:23:17.870
发生在源中，如果发生

00:23:14.720 --> 00:23:22.130
没有发生，不是那样的事情

00:23:17.870 --> 00:23:24.830
我们想要这样的事件说

00:23:22.130 --> 00:23:26.450
不要将状态存储为示例

00:23:24.830 --> 00:23:28.909
左派我们不存储以下事实

00:23:26.450 --> 00:23:31.970
目前该订单已退回

00:23:28.909 --> 00:23:35.630
正如您在底部看到的那样

00:23:31.970 --> 00:23:37.340
一件豪华椅子，但

00:23:35.630 --> 00:23:40.520
采购活动时您会得到手轮胎

00:23:37.340 --> 00:23:42.440
历史，你得到它被创建两个

00:23:40.520 --> 00:23:43.820
项目已添加，其中一项已删除

00:23:42.440 --> 00:23:47.510
订单已确认并已发货

00:23:43.820 --> 00:23:48.919
然后它被取消了，这就是为什么我们

00:23:47.510 --> 00:23:51.559
必须等待回运

00:23:48.919 --> 00:23:53.299
因为之后有人取消了

00:23:51.559 --> 00:23:56.090
被运了，然后我们得到了

00:23:53.299 --> 00:23:57.919
现在发货中有一些信息

00:23:56.090 --> 00:24:00.770
在那边我们迷路了

00:23:57.919 --> 00:24:02.480
当然，我们可以将其生成为

00:24:00.770 --> 00:24:06.169
信息在某处的副作用

00:24:02.480 --> 00:24:07.909
例如在日志中，但是很难

00:24:06.169 --> 00:24:11.510
以确保这些日志是

00:24:07.909 --> 00:24:13.130
绝对正确，因此

00:24:11.510 --> 00:24:14.690
活动采购我们没有东西

00:24:13.130 --> 00:24:16.370
如果您想知道就在左侧

00:24:14.690 --> 00:24:25.010
聚合的当前状态是什么

00:24:16.370 --> 00:24:27.110
是我们需要重播它的历史，所以

00:24:25.010 --> 00:24:28.850
事实上，事件来源的价值

00:24:27.110 --> 00:24:30.110
您已经了解了审计线索

00:24:28.850 --> 00:24:32.659
你到底发生了什么

00:24:30.110 --> 00:24:36.710
应用程序，功能非常强大

00:24:32.659 --> 00:24:39.799
稍后再进行分析也有帮助

00:24:36.710 --> 00:24:41.960
如果您愿意，可以改善建模

00:24:39.799 --> 00:24:44.059
掌握事件或说你​​会

00:24:41.960 --> 00:24:47.059
发现更多很多

00:24:44.059 --> 00:24:48.890
关于逻辑的自然推理方式

00:24:47.059 --> 00:24:51.710
一个应用程序，特别是在命令中

00:24:48.890 --> 00:24:53.510
模型，说得好得多

00:24:51.710 --> 00:24:54.930
在这种情况下，我进行验证，然后

00:24:53.510 --> 00:24:58.620
我决定这个

00:24:54.930 --> 00:25:00.420
碰巧就是你拥有了

00:24:58.620 --> 00:25:02.430
明确的记录

00:25:00.420 --> 00:25:03.840
发生而不是隐式记录

00:25:02.430 --> 00:25:06.300
你说得好地方状态会改变

00:25:03.840 --> 00:25:08.910
这些变化意味着发生了这种情况

00:25:06.300 --> 00:25:11.690
对，这一切变得非常明确， 

00:25:08.910 --> 00:25:14.490
他们很好测试可以使用

00:25:11.690 --> 00:25:16.530
在进行事件样式测试时给出

00:25:14.490 --> 00:25:19.170
采购说在

00:25:16.530 --> 00:25:22.320
当我执行某个命令时，过去

00:25:19.170 --> 00:25:23.880
希望有更多事件，或者我没有事件

00:25:22.320 --> 00:25:26.010
期望验证例外

00:25:23.880 --> 00:25:29.250
像这样的例外

00:25:26.010 --> 00:25:31.950
还有一件事

00:25:29.250 --> 00:25:36.210
而事件源给您

00:25:31.950 --> 00:25:39.570
现在的力量，这是一个非常

00:25:36.210 --> 00:25:42.120
强大的东西，因为我们一直想要

00:25:39.570 --> 00:25:44.550
一切都做完了，否则我们被迫去做

00:25:42.120 --> 00:25:46.170
在某个时候完成的所有事情

00:25:44.550 --> 00:25:49.680
好吧，如果我们只能说

00:25:46.170 --> 00:25:51.420
是的，我们可以做到这一点，但我们不必

00:25:49.680 --> 00:25:55.800
现在就做，当它变成

00:25:51.420 --> 00:25:58.590
重要的是我之前有一个客户

00:25:55.800 --> 00:26:00.710
他说我们需要确保我们

00:25:58.590 --> 00:26:02.970
捕获所有数据以进行报告哦

00:26:00.710 --> 00:26:04.890
有趣的是什么样的报告

00:26:02.970 --> 00:26:07.350
你想跑步吗我不知道

00:26:04.890 --> 00:26:10.290
那我要怎么准备

00:26:07.350 --> 00:26:12.510
对于那些报告，但我说不要担心

00:26:10.290 --> 00:26:14.250
你可以去找出什么样的报告

00:26:12.510 --> 00:26:18.210
你想你可以回到我身边

00:26:14.250 --> 00:26:21.060
这些信息我什么也不会做

00:26:18.210 --> 00:26:23.130
就像你是什么意思我不在乎我

00:26:21.060 --> 00:26:24.390
不在乎你在想什么信息

00:26:23.130 --> 00:26:26.600
您会想要的，因为我们捕获了

00:26:24.390 --> 00:26:29.250
我们必须捕获的一切， 

00:26:26.600 --> 00:26:31.800
我们现在捕获的任何东西我们都可以

00:26:29.250 --> 00:26:33.690
可以从

00:26:31.800 --> 00:26:36.750
那天我们在

00:26:33.690 --> 00:26:39.180
生产，他不相信我，他

00:26:36.750 --> 00:26:40.530
检查了几次，然后在那里

00:26:39.180 --> 00:26:42.960
终于在这一刻，他们

00:26:40.530 --> 00:26:46.500
想要一些数据转储

00:26:42.960 --> 00:26:48.630
稍后用于分析的特定格式

00:26:46.500 --> 00:26:52.920
我们当然能够提供

00:26:48.630 --> 00:26:54.540
所以现在我们有了一个应用程序

00:26:52.920 --> 00:26:58.910
冒犯了我们看看

00:26:54.540 --> 00:27:03.020
需要进行事件采购是的，我知道

00:26:58.910 --> 00:27:03.020
这就是您在采购中的做法

00:27:04.380 --> 00:27:14.140
让我们看看发生了什么变化，让我们开始

00:27:12.010 --> 00:27:16.690
这里的API没什么改变吧

00:27:14.140 --> 00:27:18.310
命令相同的事件或一半关闭

00:27:16.690 --> 00:27:22.330
屏幕，但您必须信任我

00:27:18.310 --> 00:27:24.430
通过投影得知自行车的状态

00:27:22.330 --> 00:27:27.070
没有改变，这些仍然依靠

00:27:24.430 --> 00:27:30.460
同一事件中唯一真正的变化是

00:27:27.070 --> 00:27:34.330
自行车的结构

00:27:30.460 --> 00:27:35.980
自行车，我们还有那个布尔值

00:27:34.330 --> 00:27:39.190
字段可用，但您可以看到

00:27:35.980 --> 00:27:42.610
现在有@实体注释

00:27:39.190 --> 00:27:44.800
缺失足以告诉我行动

00:27:42.610 --> 00:27:47.650
有意图事件来源

00:27:44.800 --> 00:27:50.830
你不需要存储其状态的东西

00:27:47.650 --> 00:27:53.260
任何地方，它成为默认使用

00:27:50.830 --> 00:27:54.970
事件采购我们使用汇总

00:27:53.260 --> 00:27:58.060
标识符，我们本可以留在

00:27:54.970 --> 00:28:02.260
 JPA ID，但是我们不需要JPA 

00:27:58.060 --> 00:28:05.830
上课了，所以当我们注册自行车时

00:28:02.260 --> 00:28:07.720
我们将应用一个事件，因为

00:28:05.830 --> 00:28:10.690
这种情况下没有验证

00:28:07.720 --> 00:28:13.270
可能是自行车的注册

00:28:10.690 --> 00:28:15.340
不现实，但我们坚持

00:28:13.270 --> 00:28:18.010
一个例子，在这里我们只做一个

00:28:15.340 --> 00:28:20.260
好的，我们要处理租金

00:28:18.010 --> 00:28:23.320
根据命令，我们要出租

00:28:20.260 --> 00:28:25.960
自行车，我们唯一需要做的就是

00:28:23.320 --> 00:28:28.240
如果不是，请检查是否可用

00:28:25.960 --> 00:28:31.480
如果是的话抛出一个异常

00:28:28.240 --> 00:28:33.610
决定把自行车租出去

00:28:31.480 --> 00:28:35.920
然后你把这两件事

00:28:33.610 --> 00:28:39.220
将此事件发布到

00:28:35.920 --> 00:28:41.740
舞台上没有其他组件

00:28:39.220 --> 00:28:45.460
还没到那里就可以出去了

00:28:41.740 --> 00:28:47.290
并且还会调用以下方法

00:28:45.460 --> 00:28:50.410
这是事件源处理程序

00:28:47.290 --> 00:28:52.300
这是一个非常重要的概念

00:28:50.410 --> 00:28:54.940
一个事件源，它没有什么可做的

00:28:52.300 --> 00:28:56.610
从概念上讲，使用轴突

00:28:54.940 --> 00:29:01.060
活动采购，您必须能够

00:28:56.610 --> 00:29:03.460
如果自行车在

00:29:01.060 --> 00:29:06.190
本案基于其历史

00:29:03.460 --> 00:29:08.320
事件没事就没事了

00:29:06.190 --> 00:29:10.120
碰巧你什么都不验证

00:29:08.320 --> 00:29:12.040
过去发生过的你可以

00:29:10.120 --> 00:29:15.220
不喜欢它，但这并不意味着

00:29:12.040 --> 00:29:17.470
您不必对此采取行动，因此，如果

00:29:15.220 --> 00:29:20.110
自行车是注册成绩，然后我们说

00:29:17.470 --> 00:29:22.179
自行车ID到自行车ID，我们将

00:29:20.110 --> 00:29:23.950
如果有自行车就可以使用

00:29:22.179 --> 00:29:27.850
已注册，可用于

00:29:23.950 --> 00:29:30.250
如果退还那辆自行车，租金是

00:29:27.850 --> 00:29:33.100
可用，如果租了一辆自行车

00:29:30.250 --> 00:29:34.720
不可用，这是我们唯一的事情

00:29:33.100 --> 00:29:37.330
关心可能有数百个

00:29:34.720 --> 00:29:42.940
其他我们不在乎的事件

00:29:37.330 --> 00:29:44.889
这个特定的总和，因此适用

00:29:42.940 --> 00:29:48.340
不仅为该事件上演了

00:29:44.889 --> 00:29:49.899
发布它还将确保

00:29:48.340 --> 00:29:52.450
方法被调用并且被调用

00:29:49.899 --> 00:29:55.509
直接在代码行之后

00:29:52.450 --> 00:29:58.480
应用你有状态改变

00:29:55.509 --> 00:30:00.759
在apply方法中进行了说明

00:29:58.480 --> 00:30:05.350
没有异步困难的编程

00:30:00.759 --> 00:30:07.720
现在涉及到的还有一件事

00:30:05.350 --> 00:30:09.100
我改变了那种隐藏在那里

00:30:07.720 --> 00:30:12.250
有一些依赖关系，这里有一个

00:30:09.100 --> 00:30:14.710
轴突弹簧启动启动器在另一个

00:30:12.250 --> 00:30:17.440
我只是排除了轴突服务器

00:30:14.710 --> 00:30:20.350
连接器中有一个新组件

00:30:17.440 --> 00:30:21.159
自去年下半年以来，我们已经致电

00:30:20.350 --> 00:30:23.950
轴突服务器

00:30:21.159 --> 00:30:26.350
就像是轴突，那里有一个开放的地方

00:30:23.950 --> 00:30:29.019
您可以的原始版本

00:30:26.350 --> 00:30:30.789
可以得到一个码头集装箱

00:30:29.019 --> 00:30:33.700
为此，我正在这里运行

00:30:30.789 --> 00:30:35.169
演示以及在这种情况下，我没有

00:30:33.700 --> 00:30:37.000
排除连接器，以便

00:30:35.169 --> 00:30:40.600
 spring boot 的作者配置

00:30:37.000 --> 00:30:43.360
将应用程序连接到轴突

00:30:40.600 --> 00:30:45.009
服务器在本地主机上运行，​​因为

00:30:43.360 --> 00:30:53.590
从现在开始，我不想失去

00:30:45.009 --> 00:30:56.039
我的应用程序的状态了，所以让我们

00:30:53.590 --> 00:30:56.039
开始这个

00:31:02.789 --> 00:31:11.980
很好，它可能正在运行，让我们

00:31:08.009 --> 00:31:14.649
那是重置的缺点

00:31:11.980 --> 00:31:16.360
做出更改，我们该怎么做

00:31:14.649 --> 00:31:24.490
时间马德里

00:31:16.360 --> 00:31:27.369
哎呀，为什么不在那里，我们去了，我们发出了

00:31:24.490 --> 00:31:28.899
现在骑自行车，当然，行为是

00:31:27.369 --> 00:31:32.019
没什么不同我还是可以租这个

00:31:28.899 --> 00:31:34.330
自行车，这辆自行车在

00:31:32.019 --> 00:31:36.009
行为改变，这就是我们的方式

00:31:34.330 --> 00:31:38.440
执行该行为，仍然存在

00:31:36.009 --> 00:31:41.740
在这里进行一些验证，让我们返回它

00:31:38.440 --> 00:31:43.690
在哪里我们还车好

00:31:41.740 --> 00:31:46.809
我们在巴塞罗那骑自行车，为什么不

00:31:43.690 --> 00:31:49.450
然后史蒂芬把它带到巴塞罗那

00:31:46.809 --> 00:31:52.210
太好了，现在我们有一些活动， 

00:31:49.450 --> 00:31:54.100
每次我执行命令

00:31:52.210 --> 00:31:56.049
应用程序加载所有这些事件

00:31:54.100 --> 00:32:00.850
重新生成自行车以检查是否

00:31:56.049 --> 00:32:04.629
新命令是正确的，所以

00:32:00.850 --> 00:32:07.179
我们可以转到此页面，这是

00:32:04.629 --> 00:32:08.679
轴突服务器仪表板，我们可以看到

00:32:07.179 --> 00:32:10.990
有一个正在运行的应用程序

00:32:08.679 --> 00:32:14.980
它已连接到此服务器， 

00:32:10.990 --> 00:32:17.350
我们去那里我们可以搜索

00:32:14.980 --> 00:32:20.679
我们在这里看到的事件有四个

00:32:17.350 --> 00:32:23.730
发生的事情非常好

00:32:20.679 --> 00:32:26.919
 XML结构，我们暂时将其忽略

00:32:23.730 --> 00:32:29.440
但是我们可以看到发生了一些事情

00:32:26.919 --> 00:32:34.090
这个特定的自行车一二三四在

00:32:29.440 --> 00:32:39.759
过去好吧，现在我们已经

00:32:34.090 --> 00:32:42.369
进行活动采购我们可以做一些

00:32:39.759 --> 00:32:45.309
更令人兴奋的东西，所以再次没有

00:32:42.369 --> 00:32:47.139
我必须要做的很多基础架构代码

00:32:45.309 --> 00:32:49.389
只是因为我想在

00:32:47.139 --> 00:32:52.600
采购我只需要阅读结构

00:32:49.389 --> 00:32:54.399
我的自行车和其余的

00:32:52.600 --> 00:32:56.619
应用程序的工作方式相同， 

00:32:54.399 --> 00:32:59.980
一切都是自动线

00:32:56.619 --> 00:33:03.610
没有令人兴奋的配置

00:32:59.980 --> 00:33:05.679
我们现在需要做的其中一项

00:33:03.610 --> 00:33:07.810
优点，所以我告诉你有关力量

00:33:05.679 --> 00:33:11.950
现在不正确

00:33:07.810 --> 00:33:14.230
所以这与事实有关

00:33:11.950 --> 00:33:15.790
具有已存储的事件并作为

00:33:14.230 --> 00:33:18.220
新事件存储，你有这个

00:33:15.790 --> 00:33:20.800
事件处理程序对此做出正确的反应，所以我

00:33:18.220 --> 00:33:22.030
我可以查询自行车的状态吗？ 

00:33:20.800 --> 00:33:25.600
会让他们给我更新

00:33:22.030 --> 00:33:28.120
自行车的状态，所以每一个

00:33:25.600 --> 00:33:30.100
时间有一个事件，我们只是更新它

00:33:28.120 --> 00:33:33.070
但是我们现在可以做的是

00:33:30.100 --> 00:33:35.380
一个新的事件处理程序，我们可以创建一个新的

00:33:33.070 --> 00:33:37.660
如果我们想要并拥有投影

00:33:35.380 --> 00:33:40.240
从零开始，然后继续前进

00:33:37.660 --> 00:33:45.850
向前，希望有一天它将

00:33:40.240 --> 00:33:49.120
赶上，让我们做到这一点，让我们

00:33:45.850 --> 00:33:54.190
实施新的预测，是的，我是

00:33:49.120 --> 00:33:56.080
再次这样做，我会

00:33:54.190 --> 00:33:59.560
只是通过具有

00:33:56.080 --> 00:34:02.980
改变了，所以现在我们刚刚创建了一个

00:33:59.560 --> 00:34:05.680
新的包装历史，还有一个新的

00:34:02.980 --> 00:34:08.500
投影，它非常相似，但是

00:34:05.680 --> 00:34:10.060
仍然有信息

00:34:08.500 --> 00:34:13.000
仍然有自行车ID，还有一个

00:34:10.060 --> 00:34:15.730
关于发生了什么的描述

00:34:13.000 --> 00:34:18.250
正确的时间戳记

00:34:15.730 --> 00:34:22.629
现在我们没有在我们的记录时间戳

00:34:18.250 --> 00:34:24.790
事件，让我们希望能解决这个问题， 

00:34:22.629 --> 00:34:28.000
然后我们有一个预测

00:34:24.790 --> 00:34:31.690
处理所有这些事件，这是一个

00:34:28.000 --> 00:34:33.250
春季部分有一些事件

00:34:31.690 --> 00:34:35.620
经理说哦，如果自行车是

00:34:33.250 --> 00:34:38.080
注册，我们可以加盖时间戳

00:34:35.620 --> 00:34:42.190
因为我们有兴趣知道何时

00:34:38.080 --> 00:34:43.629
实际上这发生的太好了，我们

00:34:42.190 --> 00:34:46.800
可以启动这个应用程序

00:34:43.629 --> 00:34:46.800
让我们停止这个

00:34:51.990 --> 00:34:57.720
现在因为那里仍然是真实的

00:34:56.609 --> 00:34:59.339
服务器在后台运行

00:34:57.720 --> 00:35:01.530
仍然有这些事件，所以现在

00:34:59.339 --> 00:35:04.560
应用程序正在启动，它将具有

00:35:01.530 --> 00:35:06.740
这些历史信息仍在

00:35:04.560 --> 00:35:11.480
在那里，这个组件将

00:35:06.740 --> 00:35:18.750
立即追赶溪流的头

00:35:11.480 --> 00:35:21.720
所以我们可以做的就是在我们的请求中

00:35:18.750 --> 00:35:26.820
历史悠久的自行车一二三

00:35:21.720 --> 00:35:29.580
四，我们可以确切地看到

00:35:26.820 --> 00:35:31.800
发生了，所以这是新的模型

00:35:29.580 --> 00:35:33.720
我们已经创建了，是的

00:35:31.800 --> 00:35:36.960
在这种情况下很无聊，但我答应过你

00:35:33.720 --> 00:35:40.170
很无聊，我们可以看到自行车1 2 3 4是

00:35:36.960 --> 00:35:43.500
在马德里注册的哦

00:35:40.170 --> 00:35:45.330
几分钟前好，然后被租了

00:35:43.500 --> 00:35:47.400
是的，我们去了它返回了

00:35:45.330 --> 00:35:50.190
巴塞罗那，然后斯蒂芬租了下来

00:35:47.400 --> 00:35:51.960
对，所以我们可以创建一个新模型， 

00:35:50.190 --> 00:35:55.619
不用担心我们需要做的任何事情

00:35:51.960 --> 00:36:01.080
重看这仅仅是它本身

00:35:55.619 --> 00:36:07.260
只是无所事事就可以重播

00:36:01.080 --> 00:36:08.940
免费，好吧，让我们快速前往

00:36:07.260 --> 00:36:11.880
最后一个条目，所以现在我们有了这个

00:36:08.940 --> 00:36:14.310
真正令人兴奋的报价-取消报价系统

00:36:11.880 --> 00:36:16.320
好吧，我们有命令和事件， 

00:36:14.310 --> 00:36:18.000
查询到处都是

00:36:16.320 --> 00:36:20.820
这些消息浮动，一切

00:36:18.000 --> 00:36:24.270
很好，流媒体，然后我们有

00:36:20.820 --> 00:36:25.950
这个愚蠢的HTTP调用来获得那个

00:36:24.270 --> 00:36:28.619
诸如轮询信息之类的信息

00:36:25.950 --> 00:36:30.570
对吧，说得好不好

00:36:28.619 --> 00:36:33.900
让我们把这些东西一直流到

00:36:30.570 --> 00:36:35.880
前端对，我是说我们有

00:36:33.900 --> 00:36:39.210
如今春季湿润的助焊剂，为什么不使用

00:36:35.880 --> 00:36:43.380
要使其流式传输，现在有一个

00:36:39.210 --> 00:36:46.080
几种方法和我最初的

00:36:43.380 --> 00:36:47.880
开始流式传输时幼稚的反应

00:36:46.080 --> 00:36:49.530
用户界面的意思是说我们已经

00:36:47.880 --> 00:36:52.380
有一个事件处理程序接收

00:36:49.530 --> 00:36:54.000
事件为什么不只是流所有事件

00:36:52.380 --> 00:36:57.089
使用界面的方式，并让

00:36:54.000 --> 00:36:58.619
更新自身存在一些问题

00:36:57.089 --> 00:37:00.810
在那里，因为事件处理程序是

00:36:58.619 --> 00:37:02.820
可能会更新一些信息， 

00:37:00.810 --> 00:37:04.950
它具有有关如何更新

00:37:02.820 --> 00:37:06.870
基于事件的信息

00:37:04.950 --> 00:37:11.460
现在我们将不得不重复

00:37:06.870 --> 00:37:13.350
用户界面中的逻辑非常

00:37:11.460 --> 00:37:14.910
用户界面可能是

00:37:13.350 --> 00:37:17.880
用另一种编程语言编写

00:37:14.910 --> 00:37:19.950
那么您的后端，因为我们是

00:37:17.880 --> 00:37:25.650
春季会议，这不是nodejs 

00:37:19.950 --> 00:37:27.630
 IO是正确的，所以既然该事件处理程序是

00:37:25.650 --> 00:37:30.750
已经更新了信息

00:37:27.630 --> 00:37:33.210
自行车ID位置出租物业和

00:37:30.750 --> 00:37:36.870
这更新了一个事实，斯蒂芬

00:37:33.210 --> 00:37:40.680
现在是巴塞罗那的房客，为什么不呢

00:37:36.870 --> 00:37:43.170
流式传输我们正在使用的消息

00:37:40.680 --> 00:37:46.980
无论如何查询结构

00:37:43.170 --> 00:37:49.260
不发送作为更新，并且有

00:37:46.980 --> 00:37:51.810
轴突中的一个概念称为订阅

00:37:49.260 --> 00:37:54.930
查询您可以查询说些什么

00:37:51.810 --> 00:38:01.620
给我或让我保持最新

00:37:54.930 --> 00:38:05.190
自行车1 2 3 4，所以让我们来看看

00:38:01.620 --> 00:38:11.610
我们需要做些什么才能做到这一点

00:38:05.190 --> 00:38:15.120
工作，所以最大的区别是

00:38:11.610 --> 00:38:16.890
现在在我们对自行车的投影中

00:38:15.120 --> 00:38:19.500
我们想要订阅的历史记录

00:38:16.890 --> 00:38:21.570
对自行车的历史，所以如果

00:38:19.500 --> 00:38:24.330
我们想要的那辆自行车发生了什么

00:38:21.570 --> 00:38:27.570
立即得到通知，因此我们有一个

00:38:24.330 --> 00:38:30.120
更新我们可以连接的发射器

00:38:27.570 --> 00:38:36.450
进入我们的投影，然后我们说

00:38:30.120 --> 00:38:38.040
租自行车时，如果

00:38:36.450 --> 00:38:40.980
某人感兴趣的东西

00:38:38.040 --> 00:38:44.400
我们忽略此事件的位置记录

00:38:40.980 --> 00:38:47.850
我们说如果自行车ID等于

00:38:44.400 --> 00:38:55.170
消息的有效负载为此M 

00:38:47.850 --> 00:38:58.260
太好了我迷路了

00:38:55.170 --> 00:38:59.940
所以你真的很棒吗

00:38:58.260 --> 00:39:04.470
发射，我们说如果

00:38:59.940 --> 00:39:08.250
有人对自行车真的很感兴趣

00:39:04.470 --> 00:39:10.080
当前事件代表的ID 

00:39:08.250 --> 00:39:12.810
然后我们将发送给他们

00:39:10.080 --> 00:39:14.700
通过查询方式更新M 

00:39:12.810 --> 00:39:17.310
查询的有效载荷是自行车

00:39:14.700 --> 00:39:18.609
本例中的ID，如果我们查看

00:39:17.310 --> 00:39:22.329
另一边

00:39:18.609 --> 00:39:27.819
我们的控制器，我们添加了一个方法

00:39:22.329 --> 00:39:32.680
叫做神秘手表，我们可以看自行车

00:39:27.819 --> 00:39:34.930
 ID并说您得到了

00:39:32.680 --> 00:39:37.839
订阅查询得到响应

00:39:34.930 --> 00:39:39.730
然后您可以说我想要

00:39:37.839 --> 00:39:42.069
到初始结果，然后

00:39:39.730 --> 00:39:44.140
最初的结果是氨，它

00:39:42.069 --> 00:39:48.849
包含一个列表或至少一个可迭代的

00:39:44.140 --> 00:39:51.400
最初的自行车或最初的自行车

00:39:48.849 --> 00:39:54.640
我们在这辆自行车上的历史，我们

00:39:51.400 --> 00:39:56.319
希望将其转化为流量，以便我们

00:39:54.640 --> 00:39:59.619
可以将通量与任何

00:39:56.319 --> 00:40:02.680
我们得到的更新，我们只是返回

00:39:59.619 --> 00:40:05.140
我们刚刚返回的通量

00:40:02.680 --> 00:40:09.849
自行车历史元素，我们这样说

00:40:05.140 --> 00:40:12.269
产生一个事件流，那么

00:40:09.849 --> 00:40:12.269
我们可以做的

00:40:17.870 --> 00:40:24.070
糟糕，我们需要启动该应用程序

00:40:20.290 --> 00:40:24.070
时间不多了

00:40:43.309 --> 00:40:48.679
是的，所以现在我们有了信息，这是

00:40:46.009 --> 00:40:51.079
还在那附近摇摆所以我们需要

00:40:48.679 --> 00:40:54.859
一二三四回到某个地方

00:40:51.079 --> 00:40:59.630
快让我们转到我们的HTTP请求

00:40:54.859 --> 00:41:02.569
并找到return return return 

00:40:59.630 --> 00:41:04.449
让我们回到巴塞罗那吧

00:41:02.569 --> 00:41:06.589
返回巴塞罗那让我们回去是

00:41:04.449 --> 00:41:10.279
返回巴塞罗那，所以

00:41:06.589 --> 00:41:13.819
实时流化此信息以做

00:41:10.279 --> 00:41:19.279
这个前端，这相当

00:41:13.819 --> 00:41:21.859
到目前为止，到目前为止，我们只有八个

00:41:19.279 --> 00:41:25.359
还剩几分钟，这是很多时间

00:41:21.859 --> 00:41:28.759
拿一大碗整体的东西

00:41:25.359 --> 00:41:31.630
微服务，因为在那段旅程中

00:41:28.759 --> 00:41:36.499
我几乎花了我们所有的时间

00:41:31.630 --> 00:41:38.089
到达那里，所以请坚持

00:41:36.499 --> 00:41:41.719
因为我们要完成整个

00:41:38.089 --> 00:41:43.579
幸运的是，这样做是

00:41:41.719 --> 00:41:45.529
在概念上不是很复杂

00:41:43.579 --> 00:41:47.539
我们现在拥有的是一个整体

00:41:45.529 --> 00:41:48.739
有一个出色的框架可以处理所有

00:41:47.539 --> 00:41:51.349
这些组件之间的消息传递

00:41:48.739 --> 00:41:54.890
我们需要做的就是扩大规模

00:41:51.349 --> 00:42:00.109
我去年在这个舞台上做的

00:41:54.890 --> 00:42:01.999
 -是的，去年我做到了

00:42:00.109 --> 00:42:06.829
基于我的续集的事件服务器

00:42:01.999 --> 00:42:09.589
和Netflix Spring Cloud Netflix for 

00:42:06.829 --> 00:42:12.380
发现，我们使用RabbitMQ和信任

00:42:09.589 --> 00:42:14.239
不无聊的我

00:42:12.380 --> 00:42:15.499
观点很令人兴奋，因为我

00:42:14.239 --> 00:42:18.079
还有两分钟

00:42:15.499 --> 00:42:20.359
修理不是那种东西

00:42:18.079 --> 00:42:22.669
我们想要生产的东西

00:42:20.359 --> 00:42:24.229
我现在要做的是

00:42:22.669 --> 00:42:27.679
这是我们最后没有的东西

00:42:24.229 --> 00:42:31.969
在其实际使用服务器的年份

00:42:27.679 --> 00:42:35.919
的地方，所以我们现在就可以分发

00:42:31.969 --> 00:42:35.919
这实际上是一个非常简单的更改

00:42:36.099 --> 00:42:43.130
因为我们唯一要做的就是

00:42:40.269 --> 00:42:44.869
使用弹簧型材我不是

00:42:43.130 --> 00:42:47.900
将逻辑分为不同的

00:42:44.869 --> 00:42:49.669
组件，但您都是春季专家

00:42:47.900 --> 00:42:52.429
所以你要相信我，如果我放

00:42:49.669 --> 00:42:55.610
在配置文件命令中，该光束将

00:42:52.429 --> 00:42:57.670
仅在以下情况下考虑

00:42:55.610 --> 00:43:00.320
命令配置文件处于活动状态

00:42:57.670 --> 00:43:03.680
还有另一类这些课程

00:43:00.320 --> 00:43:06.980
他们的历史档案正确的历史

00:43:03.680 --> 00:43:11.900
配置文件，我们在查询配置文件

00:43:06.980 --> 00:43:14.450
这些，现在我们能做的就是

00:43:11.900 --> 00:43:16.670
退出演示模式，否则我

00:43:14.450 --> 00:43:21.460
找不到我的跑步配置

00:43:16.670 --> 00:43:21.460
将开始所有这些组件

00:43:21.550 --> 00:43:27.290
所以我要开始命令部分

00:43:24.110 --> 00:43:29.330
查询部分和UI部分为

00:43:27.290 --> 00:43:31.820
单独的应用程序

00:43:29.330 --> 00:43:33.800
如您所见，启动三个应用程序

00:43:31.820 --> 00:43:35.930
在底部，他们都有

00:43:33.800 --> 00:43:38.680
不同的责任，所以这

00:43:35.930 --> 00:43:44.080
通常是真正的

00:43:38.680 --> 00:43:44.080
本地主机上的分布式系统，但是

00:43:46.060 --> 00:43:52.520
至少存在过程间

00:43:47.900 --> 00:43:54.190
沟通正在进行中，所以让我们来看看

00:43:52.520 --> 00:43:56.270
怎么了

00:43:54.190 --> 00:44:03.460
应该能够进行订阅

00:43:56.270 --> 00:44:03.460
再次查询是否一切开始

00:44:07.370 --> 00:44:10.570
好吧，这就是你得到的

00:44:14.200 --> 00:44:22.900
太棒了，这就是我喜欢的

00:44:17.050 --> 00:44:25.840
演示这是其中令人兴奋的部分

00:44:22.900 --> 00:44:31.420
应该很无聊

00:44:25.840 --> 00:44:33.370
而且我不知道我想做什么

00:44:31.420 --> 00:44:38.400
保存在我的机器上工作，但这是

00:44:33.370 --> 00:44:38.400
还有我的机器，所以它应该可以正常工作

00:44:40.770 --> 00:44:46.780
好的，让我们再试一次

00:44:44.530 --> 00:44:51.490
更简单的方法就是执行HTTP 

00:44:46.780 --> 00:44:53.200
请求，所以我也有生成它

00:44:51.490 --> 00:44:55.300
只是说生成它们全部二十就是一个

00:44:53.200 --> 00:44:57.340
让我们生成两个

00:44:55.300 --> 00:45:04.060
租了三遍的自行车

00:44:57.340 --> 00:45:07.540
每个工作都希望不会

00:45:04.060 --> 00:45:11.610
例外，没有例外，很棒，现在

00:45:07.540 --> 00:45:14.260
我们应该可以看到自行车了

00:45:11.610 --> 00:45:16.210
所以我们仍然有消息传递

00:45:14.260 --> 00:45:17.800
现在有一辆自行车， 

00:45:16.210 --> 00:45:20.740
较早创建，有两个

00:45:17.800 --> 00:45:22.510
自行车刚刚产生，让我们开始

00:45:20.740 --> 00:45:25.540
很快就开始了，因为还有一个

00:45:22.510 --> 00:45:27.360
我保证我真的很无聊

00:45:25.540 --> 00:45:30.100
这是所有事情中最无聊的

00:45:27.360 --> 00:45:31.780
现在我们想要这样做

00:45:30.100 --> 00:45:34.030
分布式系统

00:45:31.780 --> 00:45:35.410
组件进行交流和想象

00:45:34.030 --> 00:45:37.450
我们将要扩展这一点

00:45:35.410 --> 00:45:39.610
像我们承诺的那样成为更多组件

00:45:37.450 --> 00:45:41.860
本来会去

00:45:39.610 --> 00:45:44.290
微服务，然后会有

00:45:41.860 --> 00:45:48.070
这些组件的更多实例，以及

00:45:44.290 --> 00:45:49.630
他们将无处不在，我们已经

00:45:48.070 --> 00:45:51.220
他们收到了请求

00:45:49.630 --> 00:45:53.140
发送给某些组件的命令

00:45:51.220 --> 00:45:55.090
其他组件做出反应的事件

00:45:53.140 --> 00:45:57.730
向其他组件发送查询

00:45:55.090 --> 00:45:59.320
然后发送命令给其他人

00:45:57.730 --> 00:46:02.140
发送查询的组件，我们得到

00:45:59.320 --> 00:46:05.740
这真好事会导致事情

00:46:02.140 --> 00:46:07.660
导致我们需要一些东西

00:46:05.740 --> 00:46:10.600
从这个烂摊子中获取信息吧

00:46:07.660 --> 00:46:13.750
需要找到一种方法来概述

00:46:10.600 --> 00:46:18.120
我们如何跟踪电话

00:46:13.750 --> 00:46:18.120
对，那我们该怎么做哦

00:46:18.520 --> 00:46:25.450
跟踪正确，所以让我们实现它

00:46:22.830 --> 00:46:27.550
我本可以手工完成的，但是

00:46:25.450 --> 00:46:30.790
鉴于只有两分钟五十

00:46:27.550 --> 00:46:36.910
时钟，我要再次作弊，但我

00:46:30.790 --> 00:46:43.860
保证我只改变了什么

00:46:36.910 --> 00:46:47.410
我在这里改变了吗我只改变​​了我

00:46:43.860 --> 00:46:49.330
如果不添加两个依赖项

00:46:47.410 --> 00:46:51.670
相信我，春天佛陀的XML 

00:46:49.330 --> 00:46:53.650
编程我认为这就是证明

00:46:51.670 --> 00:46:55.780
我让Jaeger在docker中运行

00:46:53.650 --> 00:46:58.300
容器在背景和右边

00:46:55.780 --> 00:47:02.890
现在我可以使用重新启动我的应用程序

00:46:58.300 --> 00:47:10.090
并非所有这些喝的追踪

00:47:02.890 --> 00:47:12.840
我想做的是重新启动所有

00:47:10.090 --> 00:47:12.840
我的申请

00:47:16.890 --> 00:47:20.490
如果你想像那些事情，你会

00:47:18.510 --> 00:47:23.670
需要做的才能跟踪工作

00:47:20.490 --> 00:47:25.470
正确地设置各种标题

00:47:23.670 --> 00:47:26.910
在请求中，并确保这些

00:47:25.470 --> 00:47:28.440
头传递，然后

00:47:26.910 --> 00:47:30.660
在您需要的另一面进行解释

00:47:28.440 --> 00:47:32.610
报告跨度，您需要开始

00:47:30.660 --> 00:47:38.490
阻止他们，所以有很多东西

00:47:32.610 --> 00:47:43.170
继续，但我们不在乎不，我不

00:47:38.490 --> 00:47:47.400
想要你走开我爱它的时候

00:47:43.170 --> 00:47:52.380
您可以进行演示，让我们生成

00:47:47.400 --> 00:47:56.040
再来一些东西，并确保

00:47:52.380 --> 00:48:02.510
一些痕迹是贾纳创建的

00:47:56.040 --> 00:48:02.510
对的，所以我们可以去当地的寄宿单

00:48:05.450 --> 00:48:14.460
所以Jaeger UI是的， 

00:48:10.980 --> 00:48:17.310
数据操作，那里

00:48:14.460 --> 00:48:20.970
 1261跨度

00:48:17.310 --> 00:48:22.830
我想我做了一点，但这是一个

00:48:20.970 --> 00:48:24.510
不错的踪迹

00:48:22.830 --> 00:48:26.880
你有这样的痕迹吗

00:48:24.510 --> 00:48:28.650
我希望不要生产

00:48:26.880 --> 00:48:30.330
为什么你可以看到这里有一个

00:48:28.650 --> 00:48:31.650
一堆并行指令和

00:48:30.330 --> 00:48:33.830
那是因为我没有改变

00:48:31.650 --> 00:48:37.680
我的git reset之后设置

00:48:33.830 --> 00:48:39.360
产生了20辆自行车，每辆十辆

00:48:37.680 --> 00:48:41.130
并且每笔租金都发生在

00:48:39.360 --> 00:48:44.130
上一个，但这全是因为这个

00:48:41.130 --> 00:48:46.440
我做了一个API调用，现在您得到了

00:48:44.130 --> 00:48:48.990
可以完全跟踪所有命令

00:48:46.440 --> 00:48:51.240
看到查询组件处理

00:48:48.990 --> 00:48:53.670
从中产生的事件

00:48:51.240 --> 00:49:01.830
一切都在改变

00:48:53.670 --> 00:49:04.710
无聊自动为您配置，以便

00:49:01.830 --> 00:49:07.080
是追踪，并持续了十分钟

00:49:04.710 --> 00:49:08.760
我要说的时钟请尝试一下

00:49:07.080 --> 00:49:11.400
你自己，你可以签出代码

00:49:08.760 --> 00:49:13.260
你可以作弊的github存储库

00:49:11.400 --> 00:49:16.590
就像我刚得到的那样

00:49:13.260 --> 00:49:18.630
重置您的方式，如果您有

00:49:16.590 --> 00:49:21.230
任何问题，我将在

00:49:18.630 --> 00:49:24.450
演示文稿谢谢

00:49:21.230 --> 00:49:29.980
 [掌声] 

00:49:24.450 --> 00:49:29.980
 [音乐] 

