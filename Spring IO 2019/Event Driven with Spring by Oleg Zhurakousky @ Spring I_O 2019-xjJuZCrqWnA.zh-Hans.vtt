WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.900 --> 00:00:14.220
 [音乐] 

00:00:07.760 --> 00:00:16.980
好的，欢迎参加我的会议

00:00:14.220 --> 00:00:21.570
我叫Allegra Kowski 

00:00:16.980 --> 00:00:24.390
关键，这是我第二次

00:00:21.570 --> 00:00:26.130
去年春季I / O，第二次在

00:00:24.390 --> 00:00:30.300
布鲁塞尔就此事美丽

00:00:26.130 --> 00:00:32.909
这么快就我自己的城市

00:00:30.300 --> 00:00:35.909
我原来是从乌克兰搬到

00:00:32.909 --> 00:00:38.399
 90年代左右的美国在那里居住

00:00:35.909 --> 00:00:40.979
一点点，然后去年搬到

00:00:38.399 --> 00:00:42.769
法国，所以我有点像

00:00:40.979 --> 00:00:47.510
边界

00:00:42.769 --> 00:00:51.239
我在春季组织的历史是

00:00:47.510 --> 00:00:57.420
有趣的是我加入了Spring Source 

00:00:51.239 --> 00:00:59.069
 2008年一直致力于工程设计

00:00:57.420 --> 00:01:01.499
通过我们的方式实现 Spring Integration 

00:00:59.069 --> 00:01:03.389
今天要谈论很多，或者

00:01:01.499 --> 00:01:06.000
谈到它，你们中有多少人熟悉

00:01:03.389 --> 00:01:07.140
与spring集成框架一起

00:01:06.000 --> 00:01:08.760
对的好

00:01:07.140 --> 00:01:09.870
所以我在春季当工程师

00:01:08.760 --> 00:01:13.830
整合框架，然后围绕

00:01:09.870 --> 00:01:17.250
 2012年，我决定让大家记住

00:01:13.830 --> 00:01:21.660
 Hadoop大数据让我措手不及

00:01:17.250 --> 00:01:23.250
决定在那个地区尝试我自己

00:01:21.660 --> 00:01:24.000
去一家叫公司的公司工作

00:01:23.250 --> 00:01:27.720
霍顿工厂

00:01:24.000 --> 00:01:30.330
现在是云时代和几年

00:01:27.720 --> 00:01:32.970
以前认为那真的不是我的那杯

00:01:30.330 --> 00:01:40.410
茶，决定回来回来

00:01:32.970 --> 00:01:42.090
 The Spring Team 重新加入，我们有

00:01:40.410 --> 00:01:44.190
这个有趣的角色

00:01:42.090 --> 00:01:45.990
对你们很重要，我们有任何作用

00:01:44.190 --> 00:01:49.409
叫做春季咨询建筑师

00:01:45.990 --> 00:01:51.120
实际的工程师也都来了吗

00:01:49.409 --> 00:01:53.790
领域，所以他们是提交者

00:01:51.120 --> 00:01:56.940
各种不同的框架等等

00:01:53.790 --> 00:01:57.990
什么时候进行业务交易

00:01:56.940 --> 00:02:00.479
你在关键行业

00:01:57.990 --> 00:02:03.030
您可能想了解的组织

00:02:00.479 --> 00:02:04.320
我们确实有这样的事实

00:02:03.030 --> 00:02:07.590
不像您的定期顾问

00:02:04.320 --> 00:02:10.469
性春天工程师，他还会去

00:02:07.590 --> 00:02:11.930
客户，所以我做了大约六个

00:02:10.469 --> 00:02:14.870
几个月前

00:02:11.930 --> 00:02:17.730
领导者撒队

00:02:14.870 --> 00:02:19.680
决定离开，他们正在寻找

00:02:17.730 --> 00:02:22.500
让某人去领导

00:02:19.680 --> 00:02:24.780
框架，所以他们为我提供了

00:02:22.500 --> 00:02:26.220
它，然后后来发生了同样的事情

00:02:24.780 --> 00:02:28.290
具有春季法院职能，所以我

00:02:26.220 --> 00:02:30.510
目前导致项目实力

00:02:28.290 --> 00:02:31.890
流洒功能如何

00:02:30.510 --> 00:02:37.500
这就是我们要谈论的

00:02:31.890 --> 00:02:40.980
大约今天也一样

00:02:37.500 --> 00:02:43.610
协议我不想等到

00:02:40.980 --> 00:02:46.530
问题的结局很深，所以我会

00:02:43.610 --> 00:02:48.270
定期停止我会说如果有人

00:02:46.530 --> 00:02:50.610
有任何问题请这样做，因为我

00:02:48.270 --> 00:02:52.950
相信这个问题更相关

00:02:50.610 --> 00:02:55.380
在什么情况下被问到

00:02:52.950 --> 00:02:57.900
只是被呈现而不是等待

00:02:55.380 --> 00:02:59.640
直到最后等等，但是如果

00:02:57.900 --> 00:03:00.840
例如，你有点向前迈

00:02:59.640 --> 00:03:06.959
会说要坚持，我要说

00:03:00.840 --> 00:03:09.239
关于它等等，让我们开始这里

00:03:06.959 --> 00:03:11.790
我们的Amenia议程只有一个

00:03:09.239 --> 00:03:14.220
一些认识我的人的幻灯片

00:03:11.790 --> 00:03:16.799
我大部分时间都花在现场编码上

00:03:14.220 --> 00:03:20.100
所以这就是我今天要做的

00:03:16.799 --> 00:03:21.140
我用几张幻灯片设置了背景

00:03:20.100 --> 00:03:23.640
我们要谈论云

00:03:21.140 --> 00:03:24.720
事件驱动架构带来的

00:03:23.640 --> 00:03:27.600
我们一起谈论的一切

00:03:24.720 --> 00:03:29.850
关于主要是什么

00:03:27.600 --> 00:03:33.330
来是什么，来了，新来了

00:03:29.850 --> 00:03:40.410
春天的云流进来了什么

00:03:33.330 --> 00:03:43.709
管道，使我们生活在云中

00:03:40.410 --> 00:03:46.620
行业充满流行语吧

00:03:43.709 --> 00:03:49.650
今天我们有云倒带10年前

00:03:46.620 --> 00:03:51.720
我们有SOA，然后我们可以提醒

00:03:49.650 --> 00:03:55.170
再过十年，可能还会来

00:03:51.720 --> 00:03:57.150
还有一些其他流行词，但有

00:03:55.170 --> 00:03:59.970
为什么我有点讽刺评论

00:03:57.150 --> 00:04:01.950
关于这是因为没有

00:03:59.970 --> 00:04:04.310
没有什么SOA的定义

00:04:01.950 --> 00:04:08.850
每个人都对云的定义

00:04:04.310 --> 00:04:12.360
以与之相关的方式感知它

00:04:08.850 --> 00:04:14.220
所以当我谈论云时

00:04:12.360 --> 00:04:16.470
我至少想设置上下文

00:04:14.220 --> 00:04:18.150
对我来说，这意味着云是

00:04:16.470 --> 00:04:20.549
整合平台的生态系统

00:04:18.150 --> 00:04:24.210
中间件成为一个内聚的混合体

00:04:20.549 --> 00:04:25.110
运行时正确，所以我们将外包

00:04:24.210 --> 00:04:26.789
基础设施我们

00:04:25.110 --> 00:04:30.650
采购品种不同

00:04:26.789 --> 00:04:33.240
连接和业务流程

00:04:30.650 --> 00:04:35.009
到云，因为我们是

00:04:33.240 --> 00:04:38.879
我们主要想要的开发人员

00:04:35.009 --> 00:04:40.229
专心执行功能

00:04:38.879 --> 00:04:42.539
要求，不想打扰

00:04:40.229 --> 00:04:47.550
具有某种样板性质

00:04:42.539 --> 00:04:49.500
当今的IT环境以及

00:04:47.550 --> 00:04:51.240
你已经和春天在一起了一段时间

00:04:49.500 --> 00:04:53.129
你知道那真的是我们的信息

00:04:51.240 --> 00:04:55.259
那就是我们那就是历史

00:04:53.129 --> 00:04:57.810
消息，我们总是有我们担心

00:04:55.259 --> 00:05:03.740
关于样板代码离开你

00:04:57.810 --> 00:05:03.740
仅在功能方面如此

00:05:05.180 --> 00:05:09.330
事件，因此本次会议的讨论是

00:05:08.129 --> 00:05:12.629
主要是谈论

00:05:09.330 --> 00:05:15.590
事件驱动的架构和我的目标

00:05:12.629 --> 00:05:21.629
实际上是两个项目的牵头人

00:05:15.590 --> 00:05:23.400
主要展示一种

00:05:21.629 --> 00:05:25.550
实质性技术方面可以做什么

00:05:23.400 --> 00:05:28.289
您必须使用框架

00:05:25.550 --> 00:05:30.620
偏离了什么是什么

00:05:28.289 --> 00:05:32.909
实际上它的实际含义

00:05:30.620 --> 00:05:34.409
 jakob Gilliam对我的一位同事

00:05:32.909 --> 00:05:35.940
谁会在之后出现

00:05:34.409 --> 00:05:38.430
这是他的大力倡导者

00:05:35.940 --> 00:05:40.830
他有很多事件驱动的架构

00:05:38.430 --> 00:05:42.300
实用演示和演示文稿以及

00:05:40.830 --> 00:05:45.300
之所以这样，是因为他是开发者的拥护者

00:05:42.300 --> 00:05:46.860
他去现场，他做的很酷

00:05:45.300 --> 00:05:48.389
东西，换句话说，这是一种

00:05:46.860 --> 00:05:50.550
很好的过渡，以了解什么是什么

00:05:48.389 --> 00:05:53.909
在内部研究事物的运作方式

00:05:50.550 --> 00:05:57.930
在一起，然后你知道如何

00:05:53.909 --> 00:06:01.080
实际上在实践中起作用

00:05:57.930 --> 00:06:03.509
事件是事件，事件是

00:06:01.080 --> 00:06:06.060
状态变化的表示，所以什么时候

00:06:03.509 --> 00:06:07.889
您收到事件事件

00:06:06.060 --> 00:06:08.310
已经发生了，它总是过去

00:06:07.889 --> 00:06:12.379
紧张

00:06:08.310 --> 00:06:15.979
正确，因此事件在

00:06:12.379 --> 00:06:20.759
某种形式的协议专用

00:06:15.979 --> 00:06:23.669
消息和各种不同

00:06:20.759 --> 00:06:26.219
中间件，这样我们就可以知道

00:06:23.669 --> 00:06:29.250
邮件系统HTTP我的意思是你可以

00:06:26.219 --> 00:06:31.919
争辩说，实际上任何可以

00:06:29.250 --> 00:06:33.100
传输一条信息是

00:06:31.919 --> 00:06:36.220
消息传递中途

00:06:33.100 --> 00:06:41.680
因此不一定必须像JMS或

00:06:36.220 --> 00:06:43.450
 MVP或Kafka或其他任何东西

00:06:41.680 --> 00:06:45.430
是关于事件的，为什么呢

00:06:43.450 --> 00:06:46.840
为什么我们会提出不同的建议

00:06:45.430 --> 00:06:50.230
名称而不只是数据

00:06:46.840 --> 00:06:51.790
因为发生在我身上的事件至少意味着

00:06:50.230 --> 00:06:53.050
会有一块

00:06:51.790 --> 00:06:54.820
信息，将会有一个

00:06:53.050 --> 00:06:56.050
一条元信息就这样

00:06:54.820 --> 00:06:58.180
就像电子邮件一样

00:06:56.050 --> 00:07:00.670
就像有一封普通信件一样

00:06:58.180 --> 00:07:01.630
内容的有效负载权

00:07:00.670 --> 00:07:03.540
那你还有一些额外的

00:07:01.630 --> 00:07:05.530
诸如属性标题之类的信息

00:07:03.540 --> 00:07:09.040
地址信息等等

00:07:05.530 --> 00:07:10.960
如此，春季事件是

00:07:09.040 --> 00:07:15.150
一般表示为消息

00:07:10.960 --> 00:07:17.800
正如您所看到的，这是一个非常

00:07:15.150 --> 00:07:20.080
简单的结构基本上是一个元组

00:07:17.800 --> 00:07:21.760
可以这么说两个，但这是通过

00:07:20.080 --> 00:07:23.410
您所在的地方越有条理

00:07:21.760 --> 00:07:24.940
有效载荷实际上是一个对象

00:07:23.410 --> 00:07:26.680
可以是任何东西，然后你有一个

00:07:24.940 --> 00:07:27.790
标头地图，基本上是

00:07:26.680 --> 00:07:29.770
您想要的物质信息

00:07:27.790 --> 00:07:33.490
用您的有效载荷传输，我们

00:07:29.770 --> 00:07:39.610
稍后再来看它，所以

00:07:33.490 --> 00:07:42.550
让我们开始编写一些代码，然后

00:07:39.610 --> 00:07:44.710
再一次我没有真正投入

00:07:42.550 --> 00:07:46.090
极端但我想展示

00:07:44.710 --> 00:07:48.520
你一点点，然后开始说话

00:07:46.090 --> 00:07:52.030
关于一些细节，所以在我之前

00:07:48.520 --> 00:07:53.590
甚至去你们当中有多少人正在使用弹簧

00:07:52.030 --> 00:07:57.070
云流或熟悉春天

00:07:53.590 --> 00:08:00.040
云流还可以

00:07:57.070 --> 00:08:01.360
公平份额和什么是公平份额

00:08:00.040 --> 00:08:04.540
不知道的人哪个好

00:08:01.360 --> 00:08:05.800
所以那些适合你们的人

00:08:04.540 --> 00:08:06.880
使用它，我将显示正确的内容

00:08:05.800 --> 00:08:08.860
现在可能会非常

00:08:06.880 --> 00:08:10.360
很无聊，因为您已经看过，或者

00:08:08.860 --> 00:08:14.050
您已经使用它实际上不利于

00:08:10.360 --> 00:08:21.340
那些不受欢迎的人

00:08:14.050 --> 00:08:22.540
所以我所做的基本上是

00:08:21.340 --> 00:08:25.030
一张空白的纸

00:08:22.540 --> 00:08:26.350
没有人不理会这个人

00:08:25.030 --> 00:08:28.000
这只是我的偷猎者

00:08:26.350 --> 00:08:31.180
稍后使用只是为了保存

00:08:28.000 --> 00:08:33.219
时间，你所看到的只是一个平原

00:08:31.180 --> 00:08:36.910
香草弹簧的好应用

00:08:33.219 --> 00:08:39.280
绝对没有对的东西怎么办

00:08:36.910 --> 00:08:42.550
我们想要做的是我们想要能够

00:08:39.280 --> 00:08:46.030
做正确的事，我们希望成为

00:08:42.550 --> 00:08:46.760
能够根据……的到来做某事

00:08:46.030 --> 00:08:49.010
的

00:08:46.760 --> 00:08:51.110
 -我有点想说Usk是基于

00:08:49.010 --> 00:08:52.790
在邮件的竞争对手上-RabbitMQ 

00:08:51.110 --> 00:08:54.260
在这种情况下，可能是卡夫卡

00:08:52.790 --> 00:08:56.060
可以是任何东西，所以我们有活页夹

00:08:54.260 --> 00:08:59.690
稍后我们将讨论

00:08:56.060 --> 00:09:01.010
情况下我要用Rabbitmq好吧

00:08:59.690 --> 00:09:02.990
我希望能够向发送消息

00:09:01.010 --> 00:09:06.440
 RabbitMQ和我希望能够

00:09:02.990 --> 00:09:10.070
该消息以某种方式被发送到

00:09:06.440 --> 00:09:12.350
并立即调用我的代码

00:09:10.070 --> 00:09:14.830
想想过去的美好时光

00:09:12.350 --> 00:09:17.030
你需要做正确的事吗

00:09:14.830 --> 00:09:18.350
配置连接工厂会话

00:09:17.030 --> 00:09:20.060
工厂各种不同的东西

00:09:18.350 --> 00:09:22.640
消息转换器等等

00:09:20.060 --> 00:09:26.950
正确，所以我要做的是

00:09:22.640 --> 00:09:26.950
只是要写简单的方法

00:09:58.320 --> 00:10:03.900
所以我待会再解释

00:10:01.630 --> 00:10:03.900
在做

00:10:20.940 --> 00:10:27.190
所以我写的很简单

00:10:24.070 --> 00:10:37.300
基本的春季封闭申请

00:10:27.190 --> 00:10:40.120
那会收到一块

00:10:37.300 --> 00:10:41.350
数据，在这种情况下

00:10:40.120 --> 00:10:44.110
一条数据将是一个字符串是

00:10:41.350 --> 00:10:45.850
将其大写正确，以便您

00:10:44.110 --> 00:10:49.750
可以看到在这个时间点

00:10:45.850 --> 00:10:52.300
绝对不用等你说

00:10:49.750 --> 00:10:53.500
这将是一个应用程序

00:10:52.300 --> 00:10:56.200
将会收到来自的消息

00:10:53.500 --> 00:10:57.520
即将发生的rabbitmq 

00:10:56.200 --> 00:10:59.590
从我要说的活页夹中

00:10:57.520 --> 00:11:06.910
大约几分钟后，所以我

00:10:59.590 --> 00:11:12.240
要开始了，所以我以为我

00:11:06.910 --> 00:11:12.240
想停下来

00:11:15.139 --> 00:11:23.549
所以我要开始了，它开始了

00:11:21.119 --> 00:11:25.439
成功，我要去我的

00:11:23.549 --> 00:11:28.229
 RabbitMQ控制台，您可以看到

00:11:25.439 --> 00:11:31.229
巴塞罗那巴塞罗那小组现在排队

00:11:28.229 --> 00:11:33.749
让我快速告诉你为什么如此

00:11:31.229 --> 00:11:36.179
我想告诉你的是

00:11:33.749 --> 00:11:38.249
确实是您要做的一切

00:11:36.179 --> 00:11:40.859
一切正常，但我又做了一个

00:11:38.249 --> 00:11:42.779
我为我定义的是

00:11:40.859 --> 00:11:45.299
我决定输入的目的地和组

00:11:42.779 --> 00:11:47.309
找到我为什么这样做的明确名称

00:11:45.299 --> 00:11:48.029
这对演示更好，因为如果我

00:11:47.309 --> 00:11:49.649
没有那样做

00:11:48.029 --> 00:11:50.939
它将创建一个动画倾斜

00:11:49.649 --> 00:11:53.939
表示每次我重新启动

00:11:50.939 --> 00:11:55.979
应用程序将正确更改，因此

00:11:53.939 --> 00:11:57.329
开发，您几乎不必这样做

00:11:55.979 --> 00:11:58.410
实际上对于您来说发展并不重要

00:11:57.329 --> 00:12:00.179
想要这样做，因为你不想

00:11:58.410 --> 00:12:02.429
担心清理队列， 

00:12:00.179 --> 00:12:04.919
清除等等，诸如此类

00:12:02.429 --> 00:12:07.229
用于演示或现实生活

00:12:04.919 --> 00:12:08.850
您可能想要成为的应用程序

00:12:07.229 --> 00:12:10.379
能够拥有这样的权利

00:12:08.850 --> 00:12:12.299
所以但这就像我说的那样

00:12:10.379 --> 00:12:15.029
您还需要这样做

00:12:12.299 --> 00:12:18.479
现在我们已经开始申请了

00:12:15.029 --> 00:12:21.139
要去巴塞罗那排队，我只是

00:12:18.479 --> 00:12:25.109
要打招呼

00:12:21.139 --> 00:12:26.579
 Bricil Ona编写并发送消息

00:12:25.109 --> 00:12:28.859
我们收到了

00:12:26.579 --> 00:12:33.329
你好巴塞罗那，我也可以

00:12:28.859 --> 00:12:35.249
进入这样的消息来了， 

00:12:33.329 --> 00:12:37.019
粘合剂完成了我要做的所有工作

00:12:35.249 --> 00:12:41.009
解释一切正常

00:12:37.019 --> 00:12:43.649
并基本上调用了我的方法

00:12:41.009 --> 00:12:45.629
然后一旦我返回输出

00:12:43.649 --> 00:12:48.149
输出暂停再次转到活页夹

00:12:45.629 --> 00:12:50.149
谁是我申请的一部分

00:12:48.149 --> 00:12:53.429
发送到输出队列

00:12:50.149 --> 00:12:54.929
最终输出通道

00:12:53.429 --> 00:12:57.569
最终去了输出交流

00:12:54.929 --> 00:12:59.850
绑定到此输出队列

00:12:57.569 --> 00:13:04.259
我手动完成的，我可以去

00:12:59.850 --> 00:13:09.689
说好，我们去这里，这是我的

00:13:04.259 --> 00:13:12.749
口径cilona大写正确，所以你

00:13:09.689 --> 00:13:14.789
那些熟悉rabbitmq的人

00:13:12.749 --> 00:13:17.579
谁不喜欢RabbitMQ的工作方式

00:13:14.789 --> 00:13:18.809
我正在发送给您，当您

00:13:17.579 --> 00:13:20.220
发送您要发送给的消息

00:13:18.809 --> 00:13:21.839
交换到达队列是

00:13:20.220 --> 00:13:23.429
具有内部消息传递系统

00:13:21.839 --> 00:13:25.649
路由您发送一条消息到

00:13:23.429 --> 00:13:27.029
在其路由交换内交换

00:13:25.649 --> 00:13:28.800
基于的特定队列

00:13:27.029 --> 00:13:30.420
在我的情况下的说明

00:13:28.800 --> 00:13:34.679
指令将其发送到

00:13:30.420 --> 00:13:38.100
提示正确，然后当您提示时

00:13:34.679 --> 00:13:40.769
消息如何以我的方法结束

00:13:38.100 --> 00:13:42.029
然后当我结果通过

00:13:40.769 --> 00:13:45.089
它被发送到相同的过程

00:13:42.029 --> 00:13:48.600
交换的名称被发送到

00:13:45.089 --> 00:13:50.189
通过名称输出交换您

00:13:48.600 --> 00:13:52.079
可以看到绑定到出队列，并且

00:13:50.189 --> 00:13:54.360
这就是我们看到信息的方式

00:13:52.079 --> 00:13:59.220
排队，这真的是一个完整的圈子

00:13:54.360 --> 00:14:02.220
好吧，现在有几个有趣的问题

00:13:59.220 --> 00:14:03.389
的功能，所以很明显我没有

00:14:02.220 --> 00:14:05.959
做任何我刚刚写的

00:14:03.389 --> 00:14:09.179
应用程序编写了一个简单的代码， 

00:14:05.959 --> 00:14:12.869
只是不只是开始向您展示

00:14:09.179 --> 00:14:14.459
事情再次如此，我们生活在

00:14:12.869 --> 00:14:16.649
 spring boot 的世界，所以现在我们很友善

00:14:14.459 --> 00:14:18.629
依赖和事物的管理

00:14:16.649 --> 00:14:21.569
通过自动配置，因此通过

00:14:18.629 --> 00:14:24.480
正确地泵送或通过Gradle构建，因此

00:14:21.569 --> 00:14:29.040
我包括春天云的事实

00:14:24.480 --> 00:14:32.279
将狂热的粘合剂流到我的手掌中，这是

00:14:29.040 --> 00:14:35.549
是什么使RabbitMQ可以使用此功能

00:14:32.279 --> 00:14:39.119
如果我一直在使用Kafka，我会需要

00:14:35.549 --> 00:14:40.740
不更改代码，不更改

00:14:39.119 --> 00:14:43.049
属性，我们需要做的只是改变

00:14:40.740 --> 00:14:44.490
来自春天云流的这种依赖

00:14:43.049 --> 00:14:46.379
活页夹兔子或春天的云流

00:14:44.490 --> 00:14:48.869
活页夹卡夫卡，我们有一堆

00:14:46.379 --> 00:14:50.549
不同的粘合剂，实际上我很友善

00:14:48.869 --> 00:14:52.319
前进，我们现在

00:14:50.549 --> 00:14:54.660
规范实际的约束框架

00:14:52.319 --> 00:14:56.399
因为我们刚刚意识到有一个

00:14:54.660 --> 00:14:58.439
对社区发展的兴趣

00:14:56.399 --> 00:15:01.860
其他消息传递的其他活页夹和

00:14:58.439 --> 00:15:04.670
非消息传递中间件，所以

00:15:01.860 --> 00:15:07.499
真的是现在的要旨

00:15:04.670 --> 00:15:09.720
到目前为止，这是一种简单的方法

00:15:07.499 --> 00:15:11.819
申请但我想怎么办

00:15:09.720 --> 00:15:15.269
更复杂的事情，如果我想

00:15:11.819 --> 00:15:18.829
实际上很好地接受那个家伙

00:15:15.269 --> 00:15:21.629
在我们去那之前，我要说我

00:15:18.829 --> 00:15:23.879
想要正确接收消息，因为

00:15:21.629 --> 00:15:25.529
当您收到

00:15:23.879 --> 00:15:27.660
来自Spring Cloud的消息来自

00:15:25.529 --> 00:15:29.669
土匪内部的RabbitMQ 

00:15:27.660 --> 00:15:31.949
表示为以下事实： 

00:15:29.669 --> 00:15:33.689
我的方法签名定义是字符串

00:15:31.949 --> 00:15:36.119
那是内部，那是美丽

00:15:33.689 --> 00:15:37.649
我们按照惯例认识的框架

00:15:36.119 --> 00:15:38.970
你真的不想要消息

00:15:37.649 --> 00:15:39.930
你想要消息的有效载荷

00:15:38.970 --> 00:15:42.180
有一个约定

00:15:39.930 --> 00:15:43.290
他们说，如果你宣布一些

00:15:42.180 --> 00:15:46.410
一种偷猎者，那么我们要

00:15:43.290 --> 00:15:49.590
假设它是那个的有效载荷

00:15:46.410 --> 00:15:50.850
消息，但如果您想接收

00:15:49.590 --> 00:15:53.400
您想接收整个消息

00:15:50.850 --> 00:15:54.480
那么你可以声明，因为你

00:15:53.400 --> 00:15:56.910
您可能感兴趣的示例

00:15:54.480 --> 00:16:00.450
某种类型的元数据就可以了

00:15:56.910 --> 00:16:10.820
说出在这种情况下获得有效载荷的值

00:16:00.450 --> 00:16:14.630
大写，但消息还可以

00:16:10.820 --> 00:16:14.630
现在我要重启它

00:16:30.320 --> 00:16:35.329
您可以在控制台中看到

00:16:33.769 --> 00:16:37.399
收到整个邮件，所以现在您

00:16:35.329 --> 00:16:38.990
可以看到有效载荷你好，但是你可以

00:16:37.399 --> 00:16:41.740
也看到各种相关的

00:16:38.990 --> 00:16:45.769
信息，尤其是涉及到

00:16:41.740 --> 00:16:47.389
像渠道一样工作

00:16:45.769 --> 00:16:53.329
 rabbitmq属性等等

00:16:47.389 --> 00:16:55.940
现在再说一次，如果我想

00:16:53.329 --> 00:16:57.470
说听我不想留言

00:16:55.940 --> 00:16:59.060
接待一个我想要的人

00:16:57.470 --> 00:17:01.759
处理特定于域的对象

00:16:59.060 --> 00:17:13.939
我要你担心某种类型

00:17:01.759 --> 00:17:16.549
我可以对我的人做到这一点

00:17:13.939 --> 00:17:17.980
有一个名字属性，所以我

00:17:16.549 --> 00:17:21.140
我要重新启动一次

00:17:17.980 --> 00:17:22.669
对，但现在我必须将其表示为

00:17:21.140 --> 00:17:27.530
一个人，显然我要送人

00:17:22.669 --> 00:17:30.189
 JSON字符串，必须是您知道的

00:17:27.530 --> 00:17:30.189
一些东西

00:17:34.910 --> 00:17:41.520
所以我收到了一个正确的人，所以

00:17:37.530 --> 00:17:43.650
突然之间，如您所见， 

00:17:41.520 --> 00:17:46.560
我有点希望你能够

00:17:43.650 --> 00:17:48.600
观察到您只担心

00:17:46.560 --> 00:17:50.700
它的功能方面会照顾

00:17:48.600 --> 00:17:52.500
现在谈到它的其余部分

00:17:50.700 --> 00:17:54.690
您所进行的转换

00:17:52.500 --> 00:17:56.280
观察事实发生

00:17:54.690 --> 00:17:58.170
我们包含了大约七个消息

00:17:56.280 --> 00:18:00.600
我们相信并基于

00:17:58.170 --> 00:18:03.090
来自社区的反馈最多

00:18:00.600 --> 00:18:04.380
相关是的你可以有一个案例

00:18:03.090 --> 00:18:07.080
我们所有的消息都不会出错

00:18:04.380 --> 00:18:09.330
能够处理好吧，猜猜是什么

00:18:07.080 --> 00:18:11.100
如果您经历了

00:18:09.330 --> 00:18:13.560
文档，我们实际上进行了修改

00:18:11.100 --> 00:18:16.050
我们的文档中

00:18:13.560 --> 00:18:18.030
很好看的领域，还有很多

00:18:16.050 --> 00:18:19.770
不同的形式，但如果你去

00:18:18.030 --> 00:18:21.720
队中有一条流消息

00:18:19.770 --> 00:18:23.340
转换器，您可以定义自己的存在

00:18:21.720 --> 00:18:25.170
放入您的配置，它将是

00:18:23.340 --> 00:18:26.670
添加为第一个，这样您将获得

00:18:25.170 --> 00:18:30.570
转换东西的第一个裂缝

00:18:26.670 --> 00:18:33.270
所以如果基本上在90％的情况下

00:18:30.570 --> 00:18:35.100
您可以依靠消息转换器

00:18:33.270 --> 00:18:36.450
由Ask提供，但在其他情况下，您

00:18:35.100 --> 00:18:37.830
可以简单地通过扩展框架

00:18:36.450 --> 00:18:42.890
提供您自己的消息转换器，以及

00:18:37.830 --> 00:18:46.950
所以就回到这张幻灯片

00:18:42.890 --> 00:18:49.340
如此之多，然后

00:18:46.950 --> 00:18:51.840
我们将要去真正酷的东西

00:18:49.340 --> 00:18:54.450
所以我提到春天整合

00:18:51.840 --> 00:18:57.600
较早所以对我来说这是一个非常

00:18:54.450 --> 00:19:02.040
有点怀旧和非常相关

00:18:57.600 --> 00:19:03.960
今天的话题，因为看看为什么

00:19:02.040 --> 00:19:05.340
当我谈论喷头时，你喜欢

00:19:03.960 --> 00:19:06.840
流应用程序好，所以您已经

00:19:05.340 --> 00:19:09.000
开发了一个应用程序

00:19:06.840 --> 00:19:10.470
真正生活在现实世界中

00:19:09.000 --> 00:19:11.940
您没有一个应用程序

00:19:10.470 --> 00:19:13.830
很少有一个应用程序

00:19:11.940 --> 00:19:16.800
有多个应用程序

00:19:13.830 --> 00:19:19.410
通过消息传递中间件连接，因此

00:19:16.800 --> 00:19:20.670
你在这里有一些过程，然后有

00:19:19.410 --> 00:19:22.020
某种消息传递中间件

00:19:20.670 --> 00:19:23.580
中间然后另一个过程

00:19:22.020 --> 00:19:24.630
中间件中的另一个谜

00:19:23.580 --> 00:19:27.930
中间，所以你本质上是

00:19:24.630 --> 00:19:29.940
建立正确的流程，那就是

00:19:27.930 --> 00:19:32.040
真正的 Spring Integration 让我们

00:19:29.940 --> 00:19:33.540
要做的基本上是执行

00:19:32.040 --> 00:19:35.760
企业集成部分模式

00:19:33.540 --> 00:19:41.310
每个人都读那本书或知道

00:19:35.760 --> 00:19:42.770
书，或者我会写的很好

00:19:41.310 --> 00:19:45.210
绝对推荐它

00:19:42.770 --> 00:19:46.640
概述各种不同的企业

00:19:45.210 --> 00:19:48.170
那种整合模式

00:19:46.640 --> 00:19:49.730
这是观点，所以现在

00:19:48.170 --> 00:19:51.830
你看代码或讨论

00:19:49.730 --> 00:19:53.570
和你的同事一起，你真的

00:19:51.830 --> 00:19:55.040
几乎像你一样的行话

00:19:53.570 --> 00:19:57.290
说好，这是一个过滤器，或者这是一个

00:19:55.040 --> 00:19:59.420
变压器或这是路由器或此

00:19:57.290 --> 00:20:00.860
这是一个不同的地方吗

00:19:59.420 --> 00:20:02.360
模式，因此消息实际上是

00:20:00.860 --> 00:20:04.700
企业定义的模式

00:20:02.360 --> 00:20:06.340
整合模式，但非常

00:20:04.700 --> 00:20:08.720
核心模式称为管道和过滤器

00:20:06.340 --> 00:20:10.550
这就是我刚才描述的

00:20:08.720 --> 00:20:12.050
你有管道这是消息

00:20:10.550 --> 00:20:13.310
中间件，您有一个过滤器

00:20:12.050 --> 00:20:15.050
基本上是一个过程

00:20:13.310 --> 00:20:16.670
东西，然后将其发送给另一个

00:20:15.050 --> 00:20:18.470
管道和过程重复重复

00:20:16.670 --> 00:20:20.300
重复，它的美丽是

00:20:18.470 --> 00:20:21.710
一切都与您的生产者脱钩

00:20:20.300 --> 00:20:23.870
消费者并不真正了解

00:20:21.710 --> 00:20:26.300
除非你想让他们知道

00:20:23.870 --> 00:20:29.030
关于彼此，你确实可以交流

00:20:26.300 --> 00:20:35.390
通过元信息获取信息

00:20:29.030 --> 00:20:38.930
像标题这样的消息，是的，问题

00:20:35.390 --> 00:20:40.840
春天的整合是

00:20:38.930 --> 00:20:43.580
您可以配置的框架

00:20:40.840 --> 00:20:45.170
在单个应用程序中流动

00:20:43.580 --> 00:20:46.880
上下文权

00:20:45.170 --> 00:20:48.080
所以换句话说，你可以做同样的事情

00:20:46.880 --> 00:20:50.120
我形容你的东西，但这是

00:20:48.080 --> 00:20:51.320
在单个应用程序上下文中

00:20:50.120 --> 00:20:52.850
问题是威利现在在

00:20:51.320 --> 00:20:55.220
分散的世界，所以我们需要更好的

00:20:52.850 --> 00:20:58.250
字面上相同的方式，但

00:20:55.220 --> 00:21:00.350
分布式环境就这样

00:20:58.250 --> 00:21:01.760
洒水流有效吸收

00:21:00.350 --> 00:21:03.380
 Spring Integration 到全新

00:21:01.760 --> 00:21:04.640
级别或采用定义的概念

00:21:03.380 --> 00:21:07.250
企业整合模式内

00:21:04.640 --> 00:21:10.850
和 Spring Integration 到全新

00:21:07.250 --> 00:21:14.090
如此水平，实际上是粘合剂

00:21:10.850 --> 00:21:16.070
还有很多内部细节

00:21:14.090 --> 00:21:18.260
实际使用弹簧流出

00:21:16.070 --> 00:21:19.910
集成为图书馆的权利，因为

00:21:18.260 --> 00:21:23.090
有很多代码是

00:21:19.910 --> 00:21:25.910
可重复使用，不只是一流

00:21:23.090 --> 00:21:28.340
框架，但也作为实用程序库

00:21:25.910 --> 00:21:32.140
在构建时可以使用的

00:21:28.340 --> 00:21:35.420
您自己的框架，少一件

00:21:32.140 --> 00:21:37.400
只是为了强调我有多爱

00:21:35.420 --> 00:21:39.020
与弹簧集成我通常在什么时候

00:21:37.400 --> 00:21:40.790
我在外地或正在尝试

00:21:39.020 --> 00:21:43.280
原型要求哪种墨水

00:21:40.790 --> 00:21:45.140
其中包含某种流程

00:21:43.280 --> 00:21:47.120
从 Spring Integration 开始

00:21:45.140 --> 00:21:49.250
用spring集成从字面上映射它

00:21:47.120 --> 00:21:52.640
你知道为什么吗，因为我实际上可以

00:21:49.250 --> 00:21:54.950
运行它，我可以运行整个过程

00:21:52.640 --> 00:21:56.630
实现我的整个数据流

00:21:54.950 --> 00:21:58.580
企业尝试并尝试为数据定价

00:21:56.630 --> 00:22:00.200
只需一个弹簧即可流动

00:21:58.580 --> 00:22:01.789
集成应用程序上下文

00:22:00.200 --> 00:22:03.980
当我这样做的时候

00:22:01.789 --> 00:22:05.119
几次在客户那里，想要这样

00:22:03.980 --> 00:22:07.309
换句话说，现在他们不能只是

00:22:05.119 --> 00:22:10.369
一种绘制图，说看起来

00:22:07.309 --> 00:22:12.230
好的，他们实际上可以设想什么是

00:22:10.369 --> 00:22:14.649
将会发生怎么回事

00:22:12.230 --> 00:22:16.820
知道重试路由你知道

00:22:14.649 --> 00:22:18.649
发布/订阅等等

00:22:16.820 --> 00:22:20.960
然后我说好，现在我们可以

00:22:18.649 --> 00:22:23.570
实际采取并提取这些

00:22:20.960 --> 00:22:25.249
件，每个这些盒子都有

00:22:23.570 --> 00:22:26.960
有效地成为单洒

00:22:25.249 --> 00:22:29.539
流出地图，海盗变成

00:22:26.960 --> 00:22:33.769
远程消息传递系统如此出色

00:22:29.539 --> 00:22:35.809
推荐没事，这样撒

00:22:33.769 --> 00:22:37.609
流，所以我们有点快速预览

00:22:35.809 --> 00:22:40.669
那么这是一个构建框架

00:22:37.609 --> 00:22:42.799
高度可扩展的事件驱动流

00:22:40.669 --> 00:22:44.450
微服务权提供启动

00:22:42.799 --> 00:22:46.789
驱动与消息代理的集成

00:22:44.450 --> 00:22:49.879
使用目标资料夹

00:22:46.789 --> 00:22:51.559
已经提到我什至

00:22:49.879 --> 00:22:53.960
改写春天的云流是

00:22:51.559 --> 00:22:56.059
真正具有约束力的框架，因为所有

00:22:53.960 --> 00:22:57.499
您所拥有的内部条件

00:22:56.059 --> 00:23:00.679
传递消息和其他所有信息

00:22:57.499 --> 00:23:02.210
这是通过利用弹簧来完成的

00:23:00.679 --> 00:23:05.059
集成和其他春季消息传递

00:23:02.210 --> 00:23:06.859
正确的库，因此可以利用本机

00:23:05.059 --> 00:23:08.499
经纪人的功能，同时还提供

00:23:06.859 --> 00:23:10.789
不支持的功能的解决方法

00:23:08.499 --> 00:23:14.720
这实际上非常重要，因此对于

00:23:10.789 --> 00:23:18.320
举例说明你们中有多少人使用Kafka 

00:23:14.720 --> 00:23:19.730
所以卡夫卡伟大的卡夫卡概念，所以你

00:23:18.320 --> 00:23:23.590
熟悉消费者的概念

00:23:19.730 --> 00:23:27.799
组和分区的权利，所以兔子

00:23:23.590 --> 00:23:30.529
没有开箱即用，但

00:23:27.799 --> 00:23:33.679
因为Rabbit提供了内部路由

00:23:30.529 --> 00:23:35.960
我们能够建立消费者的功能

00:23:33.679 --> 00:23:37.609
兔子内部的分组和分区

00:23:35.960 --> 00:23:39.859
换句话说，它基本上在

00:23:37.609 --> 00:23:41.299
活页夹，所以我们有点模仿

00:23:39.859 --> 00:23:43.999
换句话说，卡夫卡是正确的

00:23:41.299 --> 00:23:45.379
这实际上很酷，因为即使

00:23:43.999 --> 00:23:46.549
虽然那就是那

00:23:45.379 --> 00:23:48.080
那才是我真正想要的

00:23:46.549 --> 00:23:49.850
说，即使底层

00:23:48.080 --> 00:23:53.330
邮件系统不提供

00:23:49.850 --> 00:23:55.879
开箱即用，您实际上可以

00:23:53.330 --> 00:23:57.320
撒出流兔粘合剂你

00:23:55.879 --> 00:23:59.960
实际上具有该功能，因此

00:23:57.320 --> 00:24:02.619
建立该活页夹的功能

00:23:59.960 --> 00:24:04.730
在内部基于某些

00:24:02.619 --> 00:24:06.649
可用的功能

00:24:04.730 --> 00:24:09.710
基础消息传递框架

00:24:06.649 --> 00:24:11.480
案例rabbitmq因此，它很荣幸

00:24:09.710 --> 00:24:13.039
应用程序配置

00:24:11.480 --> 00:24:13.790
我要去的基础框架

00:24:13.039 --> 00:24:17.780
快速切换

00:24:13.790 --> 00:24:19.220
 -我不会运行任何代码，但是

00:24:17.780 --> 00:24:21.860
例如我使用流监听器

00:24:19.220 --> 00:24:23.090
明确最后一条消息的含义

00:24:21.860 --> 00:24:24.380
对于那些谁的春天整合

00:24:23.090 --> 00:24:26.300
知道还有一个叫做

00:24:24.380 --> 00:24:28.910
该服务激活器或变压器

00:24:26.300 --> 00:24:30.500
我可以轻松地用它代替

00:24:28.910 --> 00:24:33.590
服务激活器，一切都会

00:24:30.500 --> 00:24:37.010
以相同的方式工作好吧，我要去做

00:24:33.590 --> 00:24:39.050
就像在服务激活器上一样

00:24:37.010 --> 00:24:40.880
定义输入通道和输出通道

00:24:39.050 --> 00:24:44.510
一切都会一样的

00:24:40.880 --> 00:24:46.610
换句话说，如果您

00:24:44.510 --> 00:24:48.050
尊重那些就是这样的框架

00:24:46.610 --> 00:24:50.060
在内部，我们将尊重那些

00:24:48.050 --> 00:24:51.470
配置，并会迅速提升， 

00:24:50.060 --> 00:24:53.570
换句话说，如果您要迁移春季

00:24:51.470 --> 00:24:55.070
集成到Spring中的应用程序

00:24:53.570 --> 00:24:57.110
云流，你不舒服

00:24:55.070 --> 00:24:58.670
使用两个您只想要的注释

00:24:57.110 --> 00:25:01.840
使用一个服务激活器，因为您

00:24:58.670 --> 00:25:03.610
熟悉它然后继续使用它

00:25:01.840 --> 00:25:07.430
好的

00:25:03.610 --> 00:25:09.460
几张幻灯片如此透明

00:25:07.430 --> 00:25:11.570
和谈判我们已经看到

00:25:09.460 --> 00:25:13.310
将微服务连接到的能力

00:25:11.570 --> 00:25:16.250
通过粘合剂的外部系统，我们已经

00:25:13.310 --> 00:25:17.540
那种灵活的感动

00:25:16.250 --> 00:25:18.710
编程模型，这就是我们

00:25:17.540 --> 00:25:22.250
现在要为

00:25:18.710 --> 00:25:24.650
演示文稿的其余部分，请全部构建

00:25:22.250 --> 00:25:29.470
春季习语等等

00:25:24.650 --> 00:25:32.300
我有点想冲过去

00:25:29.470 --> 00:25:34.880
它像其他所有东西一样启动

00:25:32.300 --> 00:25:37.400
现在就可以使用春天了

00:25:34.880 --> 00:25:38.900
可以使用的灵活配置

00:25:37.400 --> 00:25:41.060
仍然提到XML，因为您知道

00:25:38.900 --> 00:25:44.690
我还是不喜欢XML的人

00:25:41.060 --> 00:25:47.390
有人说什么，但又一次

00:25:44.690 --> 00:25:50.810
你可以我想说的是

00:25:47.390 --> 00:25:51.920
您可以提供注释

00:25:50.810 --> 00:25:53.830
我们提供的启动配置

00:25:51.920 --> 00:25:56.420
配置，但我们从来没有真正

00:25:53.830 --> 00:25:58.670
不推荐使用或从XML移开，因此

00:25:56.420 --> 00:25:59.000
不管你做什么浮标

00:25:58.670 --> 00:26:03.140
你的船

00:25:59.000 --> 00:26:05.050
所以粘合剂，我们有卡夫卡兔子，然后

00:26:03.140 --> 00:26:14.440
很多社区驱动的活页夹

00:26:05.050 --> 00:26:17.330
谷歌一张桌子是你的比目鱼

00:26:14.440 --> 00:26:20.360
我还有其他一些活页夹

00:26:17.330 --> 00:26:22.190
要求从Microsoft进行审查，因此

00:26:20.360 --> 00:26:24.320
还有更多的活页夹

00:26:22.190 --> 00:26:26.180
管道，我们实际上正在计划

00:26:24.320 --> 00:26:27.380
现在在我们的早期阶段

00:26:26.180 --> 00:26:28.730
清酒粘结剂

00:26:27.380 --> 00:26:32.690
这将使我们完全反应

00:26:28.730 --> 00:26:33.830
背压支撑等等

00:26:32.690 --> 00:26:35.270
无缝集成，因为

00:26:33.830 --> 00:26:38.150
美化无缝整合

00:26:35.270 --> 00:26:40.040
其余的弹簧叠像

00:26:38.150 --> 00:26:44.900
指标Luth配置断路器

00:26:40.040 --> 00:26:48.320
无论您要使用什么，所以这

00:26:44.900 --> 00:26:51.260
确实是这种较少的滑动

00:26:48.320 --> 00:26:54.290
真的春天的云流是如此

00:26:51.260 --> 00:26:56.360
你最核心的是

00:26:54.290 --> 00:26:58.340
目的地活页夹，所以这个国家活页夹

00:26:56.360 --> 00:27:01.640
是要包装的包装纸

00:26:58.340 --> 00:27:03.290
向右滑动您的应用程序，以便您可以

00:27:01.640 --> 00:27:06.440
交换至少是

00:27:03.290 --> 00:27:08.900
想法一次正确然后调用

00:27:06.440 --> 00:27:11.330
它可以从任何类型的事物中获取，所以

00:27:08.900 --> 00:27:12.890
然后活页夹允许您连接一个

00:27:11.330 --> 00:27:15.290
各种不同的消息传递系统

00:27:12.890 --> 00:27:16.400
所以再次在这张幻灯片中，我有点

00:27:15.290 --> 00:27:18.980
告诉你你真的没有

00:27:16.400 --> 00:27:20.480
使用单一消息系统，您可以

00:27:18.980 --> 00:27:22.970
从兔子接收消息并发送

00:27:20.480 --> 00:27:24.290
卡夫卡，反之亦然，或使用各种

00:27:22.970 --> 00:27:28.040
不同的消息传递系统

00:27:24.290 --> 00:27:31.690
所以这就是春天的云

00:27:28.040 --> 00:27:39.140
流，所以让我们回到

00:27:31.690 --> 00:27:41.510
编程模型和爪子我很失望

00:27:39.140 --> 00:27:47.060
滑动，让我们回到代码中

00:27:41.510 --> 00:27:50.050
然后开始谈论新功能， 

00:27:47.060 --> 00:27:56.090
令人兴奋，所以如果你看看这个

00:27:50.050 --> 00:28:00.130
申请权似乎不是

00:27:56.090 --> 00:28:00.130
有点冗长

00:28:00.750 --> 00:28:06.780
我的意思是，如果您考虑过，我已经

00:28:04.400 --> 00:28:09.299
我已经告诉过你我

00:28:06.780 --> 00:28:13.620
把活页夹带进了我的手掌

00:28:09.299 --> 00:28:16.049
依赖关系以及启用的发送和

00:28:13.620 --> 00:28:24.049
正确接收消息，为什么我要

00:28:16.049 --> 00:28:26.820
真的需要这个为什么我也需要这个

00:28:24.049 --> 00:28:28.350
因为实际上我在这里做什么

00:28:26.820 --> 00:28:30.120
如果你看看是什么，那么这是一个

00:28:28.350 --> 00:28:31.950
能够绑定处理器基本上

00:28:30.120 --> 00:28:35.179
基于绑定接口

00:28:31.950 --> 00:28:37.830
将要创建一个消息通道

00:28:35.179 --> 00:28:39.539
我们将为其创建代理，以便

00:28:37.830 --> 00:28:41.820
他们是我们的信息渠道，所以现在所有

00:28:39.539 --> 00:28:43.650
突然之间，您作为开发人员必须

00:28:41.820 --> 00:28:45.690
了解消息通道，现在作为

00:28:43.650 --> 00:28:47.970
开发人员突然间暴露于

00:28:45.690 --> 00:28:50.429
消息来自的事实

00:28:47.970 --> 00:28:52.590
 RabbitMQ或Kafka将被发送到

00:28:50.429 --> 00:28:54.390
消息到内部消息通道

00:28:52.590 --> 00:28:55.830
在那个时间点

00:28:54.390 --> 00:28:58.650
 Spring Integration 将接管

00:28:55.830 --> 00:29:00.270
并在您的计算机上调用您的消息处理程序

00:28:58.650 --> 00:29:03.179
只代表您自己拥有

00:29:00.270 --> 00:29:06.330
你为什么真的需要知道让

00:29:03.179 --> 00:29:08.940
我考虑一下整体覆盖

00:29:06.330 --> 00:29:10.890
你想写一个函数的撒谎故事

00:29:08.940 --> 00:29:12.750
你写地址功能

00:29:10.890 --> 00:29:14.580
要求，并且您希望能够

00:29:12.750 --> 00:29:16.890
框架会照顾您的其余部分

00:29:14.580 --> 00:29:18.840
不想在内部知道

00:29:16.890 --> 00:29:21.000
它处理渠道，因为在某些情况下

00:29:18.840 --> 00:29:22.620
一些粘合剂，他们不是，他们不是

00:29:21.000 --> 00:29:24.770
没有类似的渠道，因为我戳了一个

00:29:22.620 --> 00:29:28.530
流活页夹将您直接绑定到

00:29:24.770 --> 00:29:30.600
消息处理程序正确，对我来说就像

00:29:28.530 --> 00:29:33.390
当我接管框架时

00:29:30.600 --> 00:29:35.130
好像有点太冗长

00:29:33.390 --> 00:29:37.620
太多的信息，你

00:29:35.130 --> 00:29:42.299
我作为开发人员不愿意

00:29:37.620 --> 00:29:46.650
知道所以我决定我要删除

00:29:42.299 --> 00:29:49.080
没关系，我们要回去

00:29:46.650 --> 00:29:51.470
空白的纸，我们要去

00:29:49.080 --> 00:29:51.470
去做这个

00:30:16.320 --> 00:30:19.640
好吧，你现在看到了什么

00:30:22.300 --> 00:30:27.880
那是相关的美元符号

00:30:24.130 --> 00:30:30.760
春天来了，你现在看到了什么

00:30:27.880 --> 00:30:32.410
只不过是 spring boot 

00:30:30.760 --> 00:30:38.260
光束类型的应用

00:30:32.410 --> 00:30:40.830
功能正常，现在让我们开始吧，让我们

00:30:38.260 --> 00:30:40.830
先说

00:31:01.640 --> 00:31:05.929
一切正常，那又怎样

00:31:04.610 --> 00:31:10.850
你认为这比

00:31:05.929 --> 00:31:15.790
上一个我认为是对的

00:31:10.850 --> 00:31:21.230
我要开放的是

00:31:15.790 --> 00:31:22.670
洒水装置的功能如此年轻

00:31:21.230 --> 00:31:26.179
比起撒流

00:31:22.670 --> 00:31:29.360
只有大约两岁，也许你和

00:31:26.179 --> 00:31:32.090
一半，但洒水功能做什么

00:31:29.360 --> 00:31:37.070
它基本上带来了Java函数

00:31:32.090 --> 00:31:39.620
进入春季生态系统

00:31:37.070 --> 00:31:42.770
我会去的，你会看到一些

00:31:39.620 --> 00:31:46.630
它的特点，但重点

00:31:42.770 --> 00:31:49.400
是你现在可以代表你的

00:31:46.630 --> 00:31:51.890
使用功能的功能需求

00:31:49.400 --> 00:31:54.950
消费者或供应商或实施它们

00:31:51.890 --> 00:31:57.080
并且我们例如在喷头内

00:31:54.950 --> 00:31:59.299
极端会有效地知道该怎么办

00:31:57.080 --> 00:32:01.520
现在想想知识量

00:31:59.299 --> 00:32:04.460
我能够从中提取到

00:32:01.520 --> 00:32:06.620
避免您提供的额外配置

00:32:04.460 --> 00:32:10.549
有一个类型函数的我

00:32:06.620 --> 00:32:13.610
好吧公平，这意味着我没有

00:32:10.549 --> 00:32:16.010
我知道在概念中存在冲突

00:32:13.610 --> 00:32:18.500
如果我喷水流的上下文

00:32:16.010 --> 00:32:20.480
看到必须是消息的功能

00:32:18.500 --> 00:32:21.710
处理程序有点像鸭子，如果正确

00:32:20.480 --> 00:32:25.309
它看起来像鸭子，像鸭子一样嘎嘎叫

00:32:21.710 --> 00:32:27.410
一定是鸭子，对吧，同样的事情

00:32:25.309 --> 00:32:29.510
这里是因为我知道的功能

00:32:27.410 --> 00:32:31.640
它有输入和输出发生我可以

00:32:29.510 --> 00:32:33.650
消费者也会做

00:32:31.640 --> 00:32:36.230
只能输入，这样我就没有了

00:32:33.650 --> 00:32:38.720
声明它是否是处理器

00:32:36.230 --> 00:32:42.559
源或汇，我可以将其提取出来

00:32:38.720 --> 00:32:47.510
从你的功能签名好吗

00:32:42.559 --> 00:32:51.260
而且基本上我不需要

00:32:47.510 --> 00:32:55.419
提供任何配置好吧，现在

00:32:51.260 --> 00:33:01.429
如果我做一个人，同样的事情会起作用

00:32:55.419 --> 00:33:04.990
对，我必须要做正确的名字

00:33:01.429 --> 00:33:04.990
所以现在我要

00:33:19.520 --> 00:33:25.190
对，所以相同类型的转换

00:33:21.230 --> 00:33:27.620
现在一切都以相同的方式进行

00:33:25.190 --> 00:33:28.730
到酷的东西，如果我你呢

00:33:27.620 --> 00:33:33.700
知道这只是公牛的写作功能

00:33:28.730 --> 00:33:35.300
你们中有多少人是被动的

00:33:33.700 --> 00:33:37.040
几行

00:33:35.300 --> 00:33:39.290
所以你可能更喜欢正确的

00:33:37.040 --> 00:33:42.280
可能以不同的方式起作用

00:33:39.290 --> 00:33:42.280
喜欢写它

00:33:48.830 --> 00:33:53.289
然后我们必须改变这个

00:34:19.340 --> 00:34:23.630
对，所以现在您可以实际构建

00:34:22.010 --> 00:34:25.640
内部的内部反应管道

00:34:23.630 --> 00:34:30.610
在函数本身中，所以我再次

00:34:25.640 --> 00:34:30.610
要开始了

00:34:38.419 --> 00:34:43.460
一切正常

00:34:41.569 --> 00:34:46.059
所以现在我要去做另一个

00:34:43.460 --> 00:34:46.059
功能

00:35:11.690 --> 00:35:20.539
现在也有两个光束

00:35:18.770 --> 00:35:22.970
功能，所以现在我有冲突权

00:35:20.539 --> 00:35:27.770
所以我需要能够以某种方式解决

00:35:22.970 --> 00:35:30.530
冲突，但是现在我可以做

00:35:27.770 --> 00:35:33.170
换句话说，我现在有点

00:35:30.530 --> 00:35:35.030
所以我离开 spring boot 时

00:35:33.170 --> 00:35:36.799
当我重新启动时不存在

00:35:35.030 --> 00:35:38.510
存在，我决定完全

00:35:36.799 --> 00:35:40.369
至少在我的思想中拥抱它

00:35:38.510 --> 00:35:43.670
过程，所以我真的很想

00:35:40.369 --> 00:35:45.289
仅在以下情况下强迫您进行配置

00:35:43.670 --> 00:35:46.940
在这种情况下，您绝对需要

00:35:45.289 --> 00:35:49.609
有一条领带，你有两个功能

00:35:46.940 --> 00:35:51.740
一个你想找到两个

00:35:49.609 --> 00:35:53.450
邮件系统，让您拥有

00:35:51.740 --> 00:35:55.579
所以现在必须告诉我

00:35:53.450 --> 00:35:59.809
会要求您提供财产

00:35:55.579 --> 00:36:02.059
如此春天现在为什么财产为什么不

00:35:59.809 --> 00:36:03.349
注解，因为我在置物

00:36:02.059 --> 00:36:04.670
通过代码可以提供

00:36:03.349 --> 00:36:06.470
为它提供属性文件

00:36:04.670 --> 00:36:08.150
 llamo或or的正确应用

00:36:06.470 --> 00:36:09.319
无论是正确的权利还是仅来自命令

00:36:08.150 --> 00:36:16.369
行，以便您实际上可以使它更多

00:36:09.319 --> 00:36:21.440
动态Spring Cloud云流

00:36:16.369 --> 00:36:27.370
完成定义的功能

00:36:21.440 --> 00:36:29.320
人的大写

00:36:27.370 --> 00:36:34.060
撒在流函数定义上

00:36:29.320 --> 00:36:35.320
大写还可以，所以现在我说还可以

00:36:34.060 --> 00:36:37.060
好吧，我有两个功能

00:36:35.320 --> 00:36:43.440
将两个bean装入功能目录

00:36:37.060 --> 00:36:45.430
但是，当我很好地发送信息时， 

00:36:43.440 --> 00:36:50.910
并没有让系统绝版

00:36:45.430 --> 00:36:50.910
行，让我们确保我没有说谎

00:36:53.640 --> 00:36:56.640
然而

00:36:57.650 --> 00:37:09.079
这是我你好，所以有任何问题

00:37:03.890 --> 00:37:11.990
到目前为止，还可以，现在这里是

00:37:09.079 --> 00:37:15.200
另一个洒水功能好，所以你

00:37:11.990 --> 00:37:18.980
很好地发挥了功能

00:37:15.200 --> 00:37:20.599
我现在所能做的就是

00:37:18.980 --> 00:37:22.970
洒水喷头运行之前的好处

00:37:20.599 --> 00:37:23.720
你甚至首先去那里

00:37:22.970 --> 00:37:26.029
允许的BOTS 

00:37:23.720 --> 00:37:27.890
函数式编程或实际上

00:37:26.029 --> 00:37:30.769
三个接口分别作用于消费者和

00:37:27.890 --> 00:37:32.269
供应商是因为我总是这样做

00:37:30.769 --> 00:37:34.220
总是问这个问题

00:37:32.269 --> 00:37:36.769
修辞学的修辞学，却使你

00:37:34.220 --> 00:37:38.839
认为有业务需要

00:37:36.769 --> 00:37:40.970
您已经处理的要求

00:37:38.839 --> 00:37:44.210
处理或将要处理

00:37:40.970 --> 00:37:51.319
无法映射到任何一个供应商

00:37:44.210 --> 00:37:52.759
功能或消费者考虑它的

00:37:51.319 --> 00:37:55.670
就像我们有这三个界面一样

00:37:52.759 --> 00:37:59.200
回到Java的早期

00:37:55.670 --> 00:38:03.739
 API现在要简单得多

00:37:59.200 --> 00:38:06.289
好的，但是Java的功能之一

00:38:03.739 --> 00:38:08.739
功能是功能构成的权利

00:38:06.289 --> 00:38:11.960
所以我们总是谈论我们如何

00:38:08.739 --> 00:38:13.339
你知道你怎么写我们的代码

00:38:11.960 --> 00:38:15.319
在代码质量方面有多少

00:38:13.339 --> 00:38:17.920
需求仍然很少或太少

00:38:15.319 --> 00:38:20.749
大等等等等，假设我们

00:38:17.920 --> 00:38:21.950
终于得出结论，现在你

00:38:20.749 --> 00:38:24.529
决定我要实施

00:38:21.950 --> 00:38:27.410
使用功能的那些要求，但是

00:38:24.529 --> 00:38:30.489
至少我实现了那些

00:38:27.410 --> 00:38:32.749
需求实际上是

00:38:30.489 --> 00:38:34.099
我记得喜欢更大的要求

00:38:32.749 --> 00:38:35.420
罗德·约翰逊一直在说

00:38:34.099 --> 00:38:37.369
绝不是一个复杂的问题

00:38:35.420 --> 00:38:38.660
每个复杂的问题都没有

00:38:37.369 --> 00:38:41.390
不仅仅是一系列简单的问题

00:38:38.660 --> 00:38:42.289
是的，所以这里的意思是我

00:38:41.390 --> 00:38:43.489
希望能够看看你的

00:38:42.289 --> 00:38:46.369
需求

00:38:43.489 --> 00:38:47.599
通过很小的碎片将其分解

00:38:46.369 --> 00:38:49.489
可管理的

00:38:47.599 --> 00:38:51.589
这样理解的实现

00:38:49.489 --> 00:38:53.989
经过这样的测试，但然后您想

00:38:51.589 --> 00:38:57.289
将其重新组装成一个有凝聚力的大块

00:38:53.989 --> 00:38:59.210
要求正确，所以我想做什么

00:38:57.289 --> 00:39:00.739
这里简单地说我

00:38:59.210 --> 00:39:04.690
希望能够大写，然后

00:39:00.739 --> 00:39:04.690
正确地回声

00:39:05.490 --> 00:39:11.500
我刚刚完成的工作就是为什么

00:39:08.500 --> 00:39:13.840
该属性不是名称，而是

00:39:11.500 --> 00:39:16.510
定义，因为我可以指向一个名称

00:39:13.840 --> 00:39:17.830
单一功能或可以指向

00:39:16.510 --> 00:39:19.570
定义是组成

00:39:17.830 --> 00:39:24.460
编写多个指令

00:39:19.570 --> 00:39:25.930
功能进入消息处理程序，因此

00:39:24.460 --> 00:39:27.760
这种情况下，我们应该应该能够

00:39:25.930 --> 00:39:29.890
看到值是大写的

00:39:27.760 --> 00:39:32.600
因为我们首先要调用大写

00:39:29.890 --> 00:39:35.750
然后我们要调用正确的回声

00:39:32.600 --> 00:39:35.750
 [音乐] 

00:39:36.780 --> 00:39:44.110
是的，因为它与

00:39:42.430 --> 00:39:47.170
我提出功能的原因

00:39:44.110 --> 00:39:49.240
组成是因为在纯Java中

00:39:47.170 --> 00:39:52.240
您可以说功能a和

00:39:49.240 --> 00:39:54.730
然后是功能B然后是功能C 

00:39:52.240 --> 00:39:56.830
那正是我们所要的

00:39:54.730 --> 00:39:58.270
在这里做，是的，但是很好

00:39:56.830 --> 00:40:02.020
问题是给那些谁

00:39:58.270 --> 00:40:04.030
没听见这个管道暗示

00:40:02.020 --> 00:40:06.460
委派回到兔子并来

00:40:04.030 --> 00:40:07.930
返回还是内部公正的组成

00:40:06.460 --> 00:40:08.260
那是内部的构成

00:40:07.930 --> 00:40:10.360
回答

00:40:08.260 --> 00:40:13.620
所以我们基本上组成了一个

00:40:10.360 --> 00:40:13.620
两个功能中的一个功能

00:40:30.329 --> 00:40:38.099
我们打个招呼好十分钟

00:40:35.299 --> 00:40:40.679
足够的时间来使用最酷的功能

00:40:38.099 --> 00:40:42.569
所以现在这些是

00:40:40.679 --> 00:40:44.069
当前可用，还有更多

00:40:42.569 --> 00:40:46.859
就像我说的，我只是你知道15分钟

00:40:44.069 --> 00:40:50.279
我还不够

00:40:46.859 --> 00:40:53.009
选择我想谈论的话题

00:40:50.279 --> 00:40:54.299
已有的新功能

00:40:53.009 --> 00:40:56.969
发布，还有更多

00:40:54.299 --> 00:41:03.689
我实际上所做的改进

00:40:56.969 --> 00:41:05.630
昨天路由很多次

00:41:03.689 --> 00:41:11.209
撒奇功能

00:41:05.630 --> 00:41:12.719
你很清楚忘记功能方面

00:41:11.209 --> 00:41:16.170
我特别要谈论

00:41:12.719 --> 00:41:18.449
喷头流在这里，所以在这种情况下，我

00:41:16.170 --> 00:41:21.150
需要提供说明以前往此处

00:41:18.449 --> 00:41:25.049
在那里，但让我们假装你有用

00:41:21.150 --> 00:41:27.709
根据您想要的消息的情况

00:41:25.049 --> 00:41:30.479
它去这个处理程序或那个处理程序

00:41:27.709 --> 00:41:35.329
对的，所以您希望能够做一些

00:41:30.479 --> 00:41:38.369
一种路由，所以您可以做的是

00:41:35.329 --> 00:41:40.349
使用功能的路由功能

00:41:38.369 --> 00:41:43.549
这基本上是什么

00:41:40.349 --> 00:41:46.589
弹簧关闭功能，我们已经定义了

00:41:43.549 --> 00:41:49.410
单个功能称为路由器权

00:41:46.589 --> 00:41:51.959
这是一个众所周知的名字

00:41:49.410 --> 00:41:53.640
而所有您需要做的就是

00:41:51.959 --> 00:41:55.410
例如，有几种方法

00:41:53.640 --> 00:41:59.089
启用路由器，所以我要做什么

00:41:55.410 --> 00:41:59.089
就是说Spring Cloud

00:42:10.460 --> 00:42:13.599
我只是想

00:42:14.940 --> 00:42:21.210
所以我要在这里做什么

00:42:17.940 --> 00:42:22.680
我说喷水功能路由

00:42:21.210 --> 00:42:24.150
正确启用，因此此功能不是

00:42:22.680 --> 00:42:26.460
默认情况下将启用

00:42:24.150 --> 00:42:27.569
仅在您提供

00:42:26.460 --> 00:42:29.670
指导，因为我们不想

00:42:27.569 --> 00:42:31.109
污染环境，甚至万一

00:42:29.670 --> 00:42:32.819
您决定创建自己的功能

00:42:31.109 --> 00:42:35.819
邻居或类似的东西

00:42:32.819 --> 00:42:37.319
在这种情况下，路由功能将

00:42:35.819 --> 00:42:39.089
需要额外的元信息

00:42:37.319 --> 00:42:41.670
给它它将收到消息

00:42:39.089 --> 00:42:42.420
代表你说的很好，谁

00:42:41.670 --> 00:42:45.990
我打电话吗

00:42:42.420 --> 00:42:49.619
所以在这种情况下，因为我们记得我

00:42:45.990 --> 00:42:51.030
必须不断启动和停止服务器

00:42:49.619 --> 00:42:55.010
每当我想改变一些东西

00:42:51.030 --> 00:42:57.299
在这种情况下，我要开始

00:42:55.010 --> 00:43:02.520
我的目录中有两个功能

00:42:57.299 --> 00:43:03.869
现在，我要去这里，现在我需要

00:43:02.520 --> 00:43:05.640
现在提供其他信息

00:43:03.869 --> 00:43:08.099
再次是粘结剂的特征之一

00:43:05.640 --> 00:43:11.789
是像HTTP这样的信息

00:43:08.099 --> 00:43:14.280
 RabbitMQ的标题或消息标题

00:43:11.789 --> 00:43:15.660
或来自Kafka主题的邮件标题

00:43:14.280 --> 00:43:17.760
他们将被翻译成

00:43:15.660 --> 00:43:19.859
内部邮件头

00:43:17.760 --> 00:43:21.660
消息表示，这又是

00:43:19.859 --> 00:43:26.190
我们为您做的事情基本上

00:43:21.660 --> 00:43:32.039
我能做的是说功能

00:43:26.190 --> 00:43:39.510
我也知道它的名字函数名称

00:43:32.039 --> 00:43:46.160
将是回声和内容类型是

00:43:39.510 --> 00:43:46.160
将要解释写功能

00:43:53.010 --> 00:43:58.699
好的

00:43:54.809 --> 00:43:58.699
我们打对了

00:44:01.849 --> 00:44:14.559
如果我想做大写或大写

00:44:09.529 --> 00:44:14.559
大写右

00:44:15.680 --> 00:44:22.760
巴塞罗那显然我们不会看到

00:44:18.680 --> 00:44:24.380
它在议会中，但我们可以因为

00:44:22.760 --> 00:44:32.450
我们如何实现它，但我可以去

00:44:24.380 --> 00:44:34.400
输出队列，这是

00:44:32.450 --> 00:44:37.040
巴塞罗那吧，突然之间我是

00:44:34.400 --> 00:44:39.290
能够这样，现在您可以想象可以

00:44:37.040 --> 00:44:41.660
正在发送消息，并且在

00:44:39.290 --> 00:44:43.280
上游将注入一个标题

00:44:41.660 --> 00:44:46.130
呼叫说书功能或

00:44:43.280 --> 00:44:47.420
无论我们在做什么

00:44:46.130 --> 00:44:48.890
最有可能您将不必

00:44:47.420 --> 00:44:51.080
这样做是因为我们正在努力的是

00:44:48.890 --> 00:44:53.390
提供表达的能力

00:44:51.080 --> 00:44:54.680
将评估任何标头，并基于

00:44:53.390 --> 00:44:56.720
也就是说，您可以拥有一些

00:44:54.680 --> 00:44:58.820
本机消息传入并基于

00:44:56.720 --> 00:45:00.860
一些值，例如帐户或其他任何值

00:44:58.820 --> 00:45:05.420
可以路由您知道的特定功能

00:45:00.860 --> 00:45:08.360
使用表达式好吧，现在再次

00:45:05.420 --> 00:45:11.900
回到整个春季引导心态

00:45:08.360 --> 00:45:14.990
除非您不想在哪里进行配置

00:45:11.900 --> 00:45:16.820
你绝对要这样写

00:45:14.990 --> 00:45:19.820
显然在这种情况下，我有两个

00:45:16.820 --> 00:45:21.380
换句话说，功能如何

00:45:19.820 --> 00:45:23.540
这种情况下，我有两个功能，我

00:45:21.380 --> 00:45:26.470
启用路由另一种启用方式

00:45:23.540 --> 00:45:31.810
路由基本上是回到使用

00:45:26.470 --> 00:45:38.600
春天的云流功能

00:45:31.810 --> 00:45:40.610
定义等于路由器正确，所以您

00:45:38.600 --> 00:45:42.530
通过说有效地启用路由器

00:45:40.610 --> 00:45:44.330
好吧，我要使用路由器作为

00:45:42.530 --> 00:45:46.610
功能，这是启用的两种方式

00:45:44.330 --> 00:45:49.040
它之所以重要的原因是

00:45:46.610 --> 00:45:53.450
因为如果您希望能够

00:45:49.040 --> 00:45:56.900
路由到某个东西，然后结果

00:45:53.450 --> 00:46:02.150
它必须被输送到某些东西

00:45:56.900 --> 00:46:06.040
否则对，这有点酷

00:46:02.150 --> 00:46:11.870
再次这样做，所以我们要

00:46:06.040 --> 00:46:14.110
我们要调用的路线

00:46:11.870 --> 00:46:17.110
大写，然后我们将要做

00:46:14.110 --> 00:46:17.110
回声

00:46:21.250 --> 00:46:27.140
所以我想我就是我希望你

00:46:24.080 --> 00:46:30.410
观察到您现在可以建立

00:46:27.140 --> 00:46:35.270
复杂的管道内散布

00:46:30.410 --> 00:46:37.400
通过简单地解决可管理流

00:46:35.270 --> 00:46:40.430
规模可控的要求，以及

00:46:37.400 --> 00:46:44.570
然后组成它们，路由它们，依此类推

00:46:40.430 --> 00:46:51.470
等等，所以我们现在开始

00:46:44.570 --> 00:46:58.240
要去排队，我要去

00:46:51.470 --> 00:47:08.090
说同样的话，我们要做

00:46:58.240 --> 00:47:11.210
函数点名称等于大写

00:47:08.090 --> 00:47:18.160
路由到大写，然后内容类型

00:47:11.210 --> 00:47:22.690
解释，然后回声

00:47:18.160 --> 00:47:22.690
你好巴塞罗那好吗

00:47:22.800 --> 00:47:29.010
最后一个演示是如果您喜欢我的话

00:47:27.150 --> 00:47:30.930
说那是你知道的

00:47:29.010 --> 00:47:32.550
您希望能够拥有的管道

00:47:30.930 --> 00:47:33.960
该功能实际上是因为您

00:47:32.550 --> 00:47:35.340
可能无法知道哪个功能

00:47:33.960 --> 00:47:38.090
你想调用但有一个

00:47:35.340 --> 00:47:41.280
在上游或内部某处起作用

00:47:38.090 --> 00:47:43.560
您的一项功能，对不起其中一项

00:47:41.280 --> 00:47:45.869
您的功能将基于一些

00:47:43.560 --> 00:47:48.180
内部信息使用哪种方法

00:47:45.869 --> 00:47:49.920
调用，这样我就可以称之为丰富或

00:47:48.180 --> 00:48:00.619
功能，所以让我写它真实

00:47:49.920 --> 00:48:00.619
这么快，这将是消息

00:48:04.940 --> 00:48:17.560
而我们要做的是

00:48:07.760 --> 00:48:17.560
会说好吧我会说

00:48:17.590 --> 00:48:26.800
用有效载荷值设置的构建器

00:48:24.080 --> 00:48:26.800
标头

00:49:09.090 --> 00:49:11.120
哦

00:49:14.300 --> 00:49:19.020
好的，所以基本上我们有一个功能

00:49:17.370 --> 00:49:25.760
叫做丰富，所以我要做的是

00:49:19.020 --> 00:49:33.090
我很好谢谢

00:49:25.760 --> 00:49:35.040
所以我要做丰富的，所以我们

00:49:33.090 --> 00:49:36.840
会打电话给我们

00:49:35.040 --> 00:49:40.020
功能基本上创建管道

00:49:36.840 --> 00:49:42.480
我们要去哪里，所以当我调用

00:49:40.020 --> 00:49:44.550
当我发送邮件时

00:49:42.480 --> 00:49:46.170
创建了这一大功能， 

00:49:44.550 --> 00:49:48.480
第一个要被调用的功能是

00:49:46.170 --> 00:49:50.250
在丰富的功能，然后显然在

00:49:48.480 --> 00:49:52.920
时间点它会注入

00:49:50.250 --> 00:49:54.300
标头知道它要去哪条路线

00:49:52.920 --> 00:49:55.470
发送到路由器功能

00:49:54.300 --> 00:49:59.060
已经要有标题和

00:49:55.470 --> 00:49:59.060
它会进入回声， 

00:50:07.660 --> 00:50:15.070
而且我们还好，所以是9:50 

00:50:12.700 --> 00:50:16.480
非常感谢你，我会在这里

00:50:15.070 --> 00:50:18.490
任何问题我也要

00:50:16.480 --> 00:50:21.580
像我说的yaku推荐一样推荐

00:50:18.490 --> 00:50:23.680
接下来他是一个非常酷的演示

00:50:21.580 --> 00:50:24.660
非常酷的内容，非常感谢

00:50:23.680 --> 00:50:26.830
很多参加

00:50:24.660 --> 00:50:33.340
 [掌声] 

00:50:26.830 --> 00:50:33.340
 [音乐] 

