WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.900 --> 00:00:08.500
 [音乐] 

00:00:04.470 --> 00:00:10.570
谢谢，早上好，谢谢

00:00:08.500 --> 00:00:14.370
简介是的，我们要谈谈

00:00:10.570 --> 00:00:16.929
关于咆哮嗯，我们将有非常

00:00:14.370 --> 00:00:18.730
紧张的15分钟，我们这里有很多

00:00:16.929 --> 00:00:22.810
内容，所以我们将直接进入

00:00:18.730 --> 00:00:24.759
就像我们要跑步一样快

00:00:22.810 --> 00:00:26.710
时间要快，真正开始

00:00:24.759 --> 00:00:28.449
如果您有任何问题，请快

00:00:26.710 --> 00:00:30.880
没有时间在这里问你

00:00:28.449 --> 00:00:31.539
找不到我relator你可以找到我

00:00:30.880 --> 00:00:33.250
互联网

00:00:31.539 --> 00:00:38.890
我几乎都过着灰烬的生活

00:00:33.250 --> 00:00:41.320
给我发推特给我发电子邮件，在github上找到我

00:00:38.890 --> 00:00:43.360
可以回答有关软件的问题

00:00:41.320 --> 00:00:46.300
工程也许有些无关

00:00:43.360 --> 00:00:49.240
问题，最近我30岁了，所以我

00:00:46.300 --> 00:00:50.830
觉得我现在已经老了，很聪明，所以我可以

00:00:49.240 --> 00:00:54.370
回答有关生活在上升的问题

00:00:50.830 --> 00:00:55.660
一般也请不要

00:00:54.370 --> 00:00:57.730
做任何向前的业务

00:00:55.660 --> 00:01:00.670
根据什么内容做出决定

00:00:57.730 --> 00:01:03.070
你在这里听到人们说这是一个非常

00:01:00.670 --> 00:01:06.310
重要信息，让我们越过这一点

00:01:03.070 --> 00:01:07.149
谈论1200万这是非常令人兴奋的

00:01:06.310 --> 00:01:10.450
技术

00:01:07.149 --> 00:01:12.609
这是一款高性能的智能套装

00:01:10.450 --> 00:01:14.499
具有以下功能的多语言虚拟机： 

00:01:12.609 --> 00:01:17.039
以不同的语言运行程序

00:01:14.499 --> 00:01:19.630
我们旨在支持所有语言

00:01:17.039 --> 00:01:21.939
最终，目前我们有一个非常

00:01:19.630 --> 00:01:25.899
一组最受欢迎的

00:01:21.939 --> 00:01:28.810
生态系统你们当中有多少人听说过

00:01:25.899 --> 00:01:30.039
 bravia只是为了它快速测试出色

00:01:28.810 --> 00:01:32.799
你们当中有多少人感觉可以

00:01:30.039 --> 00:01:37.810
解释和描述它是什么和喜欢

00:01:32.799 --> 00:01:41.259
为什么为什么存在两只手优秀

00:01:37.810 --> 00:01:43.959
去过我以前的课程

00:01:41.259 --> 00:01:46.359
将会是那个成长中的虚拟机

00:01:43.959 --> 00:01:47.979
图片是这样的

00:01:46.359 --> 00:01:50.950
运行时，它是一个虚拟机

00:01:47.979 --> 00:01:53.950
这是您可以执行运行的东西

00:01:50.950 --> 00:01:55.719
您的程序，您可以用任何方式编写

00:01:53.950 --> 00:01:59.249
支持的语言，因此目前

00:01:55.719 --> 00:02:01.450
 Java语言Java Scala Kotlin groovy 

00:01:59.249 --> 00:02:03.700
编译成JVM的任何东西

00:02:01.450 --> 00:02:06.909
字节码我们支持

00:02:03.700 --> 00:02:09.069
 JavaScript是一种非常流行的语言

00:02:06.909 --> 00:02:11.110
包括实际运行的node.js 

00:02:09.069 --> 00:02:14.140
应用程序，我们对

00:02:11.110 --> 00:02:16.960
 Ruby或Python等

00:02:14.140 --> 00:02:19.270
 LLVM工具链正确，因此任何本机

00:02:16.960 --> 00:02:21.130
通过LLVM编译的代码，我们可以

00:02:19.270 --> 00:02:25.270
取中间表示

00:02:21.130 --> 00:02:28.090
 LLVM位代码并运行它，然后在

00:02:25.270 --> 00:02:29.800
运行时，我们努力成为高性能

00:02:28.090 --> 00:02:32.800
我们要执行的虚拟机

00:02:29.800 --> 00:02:34.990
程序具有良好的峰值性能，我们

00:02:32.800 --> 00:02:37.660
希望它像可能的一样快

00:02:34.990 --> 00:02:39.880
您希望您的运行时快生活是

00:02:37.660 --> 00:02:43.480
太短，无法等待程序执行

00:02:39.880 --> 00:02:45.489
完成，然后我们可以执行程序

00:02:43.480 --> 00:02:49.540
这些语言在不同的上下文中

00:02:45.489 --> 00:02:51.280
我们可以在JVM中运行它

00:02:49.540 --> 00:02:54.000
就像一个适当的普通Java 

00:02:51.280 --> 00:02:57.780
处理它将启动JVM，它将

00:02:54.000 --> 00:03:00.370
通常我们的构建使用Java热点VM 

00:02:57.780 --> 00:03:02.320
所以它将做所有的事情

00:03:00.370 --> 00:03:04.000
 Java通常会访问

00:03:02.320 --> 00:03:05.980
到Java的垃圾回收

00:03:04.000 --> 00:03:07.660
通常它会降低班级

00:03:05.980 --> 00:03:11.380
动态地这将是你的正常

00:03:07.660 --> 00:03:13.600
可以在

00:03:11.380 --> 00:03:15.220
节点应用程序的上下文

00:03:13.600 --> 00:03:17.019
如果没有，将是正常的应用程序

00:03:15.220 --> 00:03:18.489
你对那些事情很感兴趣

00:03:17.019 --> 00:03:19.780
将会有事件循环

00:03:18.489 --> 00:03:22.600
注意的信号处理程序

00:03:19.780 --> 00:03:24.519
应用一半，它只是一个

00:03:22.600 --> 00:03:28.390
正常应用只是引擎

00:03:24.519 --> 00:03:31.140
在该平台上运行代码

00:03:28.390 --> 00:03:33.190
被我们的技术所取代， 

00:03:31.140 --> 00:03:35.620
从一开始就

00:03:33.190 --> 00:03:37.870
我认为地面VM项目已经启动

00:03:35.620 --> 00:03:41.079
大约七年前

00:03:37.870 --> 00:03:43.260
开始的想法也许我们可以

00:03:41.079 --> 00:03:47.709
为Java编写即时编译器

00:03:43.260 --> 00:03:50.829
正确地使用Java本身

00:03:47.709 --> 00:03:53.140
该编译器的其他一切

00:03:50.829 --> 00:03:55.510
接下来是格雷厄姆现在可以做的事情， 

00:03:53.140 --> 00:03:57.160
从一开始的想法是

00:03:55.510 --> 00:03:58.959
我们想要一个可插拔的系统

00:03:57.160 --> 00:04:01.660
你可以嵌入到不同的

00:03:58.959 --> 00:04:04.150
场景，所以现在您可以使用图表

00:04:01.660 --> 00:04:06.310
在运行时，并将其放入您的本机

00:04:04.150 --> 00:04:08.739
或Java应用程序，如果您有

00:04:06.310 --> 00:04:10.780
大型平台，您想增强

00:04:08.739 --> 00:04:14.430
具有评估能力

00:04:10.780 --> 00:04:19.209
用Java Script或Python输入代码

00:04:14.430 --> 00:04:21.700
您可以这样做，例如

00:04:19.209 --> 00:04:23.940
存在一些实验性构建

00:04:21.700 --> 00:04:26.430
 Oracle数据库

00:04:23.940 --> 00:04:29.250
因为Oracle数据库是一个相当

00:04:26.430 --> 00:04:30.690
大型本机应用程序，所以有

00:04:29.250 --> 00:04:34.380
可在其中使用的实验性构建

00:04:30.690 --> 00:04:36.060
地面虚拟机运行时间来存储

00:04:34.380 --> 00:04:38.640
程序和通常定义的功能

00:04:36.060 --> 00:04:41.430
使用JavaScript，所以通常你会

00:04:38.640 --> 00:04:45.420
做PL续集，但在那些账单中，您可以

00:04:41.430 --> 00:04:46.350
使用可能更容易理解语言

00:04:45.420 --> 00:04:49.080
为了你

00:04:46.350 --> 00:04:51.480
 JavaScript权利和最终推动力

00:04:49.080 --> 00:04:55.140
在角落是独立的

00:04:51.480 --> 00:04:57.000
他们成长的应用程序VM 

00:04:55.140 --> 00:04:58.440
当前的本机图像

00:04:57.000 --> 00:05:02.190
可作为早期采用者

00:04:58.440 --> 00:05:05.010
技术，这就是我们采用您的

00:05:02.190 --> 00:05:07.110
 Java字节码，我们对此进行分析，然后我们

00:05:05.010 --> 00:05:10.080
提前将其编译为本机

00:05:07.110 --> 00:05:12.150
适用于您的平台和

00:05:10.080 --> 00:05:15.000
结果它有几个优点

00:05:12.150 --> 00:05:18.390
快速启动，占用更少的内存

00:05:15.000 --> 00:05:21.540
在运行时，它的体积很小

00:05:18.390 --> 00:05:23.820
所以有非常有用的背景

00:05:21.540 --> 00:05:26.640
你只想专心

00:05:23.820 --> 00:05:29.220
这种模式，但总的来说，咆哮的VM是

00:05:26.640 --> 00:05:30.870
大型项目可以做很多事情

00:05:29.220 --> 00:05:33.300
它支持不同的语言

00:05:30.870 --> 00:05:37.980
我相信您可以找到以下用例

00:05:33.300 --> 00:05:40.560
这里的各种场景和主要场景

00:05:37.980 --> 00:05:43.140
通过与人交谈而发现

00:05:40.560 --> 00:05:45.270
通过评估他们对我们说的话

00:05:43.140 --> 00:05:47.820
看他们想用什么

00:05:45.270 --> 00:05:50.030
的重力如下： 

00:05:47.820 --> 00:05:52.680
更快的运行时间，真的很好

00:05:50.030 --> 00:05:54.990
虚拟机对编译器的

00:05:52.680 --> 00:05:58.680
地面vm内的即时编译器

00:05:54.990 --> 00:06:00.750
是最先进的技术

00:05:58.680 --> 00:06:02.880
编译器，所以有很多很多

00:06:00.750 --> 00:06:05.820
可以为您带来更好工作的工作量

00:06:02.880 --> 00:06:08.490
结果比其他JVM实现

00:06:05.820 --> 00:06:11.400
因此，如果您想更快地运行

00:06:08.490 --> 00:06:14.430
您一个JVM应用程序Scala 

00:06:11.400 --> 00:06:17.850
 Java咳嗽等等，那么你应该

00:06:14.430 --> 00:06:19.980
看着增长，然后他们增长虚拟机

00:06:17.850 --> 00:06:21.930
他们为您提供即时的本地图像

00:06:19.980 --> 00:06:24.120
他们提供的应用程序的启动

00:06:21.930 --> 00:06:26.550
如果部署

00:06:24.120 --> 00:06:28.350
应用程序启动到云中

00:06:26.550 --> 00:06:29.669
和内存消耗很重要

00:06:28.350 --> 00:06:32.490
因为那些就是你

00:06:29.669 --> 00:06:34.830
实际支付然后咆哮的VM本机

00:06:32.490 --> 00:06:35.860
图像可能是一个解决方案

00:06:34.830 --> 00:06:38.370
你至少应该

00:06:35.860 --> 00:06:41.830
看看它在哪里为您服务

00:06:38.370 --> 00:06:44.550
这是一个可嵌入的虚拟机，所以如果您有一个

00:06:41.830 --> 00:06:47.020
您可能想要的大型应用程序

00:06:44.550 --> 00:06:49.659
提供利用代码的能力

00:06:47.020 --> 00:06:52.300
如果您在

00:06:49.659 --> 00:06:54.340
大型企业甚至

00:06:52.300 --> 00:06:56.590
你可能有中型公司

00:06:54.340 --> 00:06:58.449
基于不同语言的代码

00:06:56.590 --> 00:07:01.840
您想在一个

00:06:58.449 --> 00:07:03.819
像调味一样的单一过程

00:07:01.840 --> 00:07:06.669
一些机器学习的应用

00:07:03.819 --> 00:07:08.979
用Python写的位，因为

00:07:06.669 --> 00:07:09.400
机器学习专家通常使用

00:07:08.979 --> 00:07:12.340
皮滕

00:07:09.400 --> 00:07:14.860
为您可能想要的一切写东西

00:07:12.340 --> 00:07:17.080
在单个过程中运行它，或者也许

00:07:14.860 --> 00:07:20.110
您只想编写您的应用程序

00:07:17.080 --> 00:07:22.650
并利用不同的生态系统

00:07:20.110 --> 00:07:25.449
语言，因为您只是喜欢

00:07:22.650 --> 00:07:28.150
所以这些是主要的价值

00:07:25.449 --> 00:07:32.080
字素现在至少可以为您提供

00:07:28.150 --> 00:07:34.300
是我们与人交谈时发现的

00:07:32.080 --> 00:07:36.129
谁评估了它，在本次会议中，我是

00:07:34.300 --> 00:07:38.620
要尝试通过所有这些

00:07:36.129 --> 00:07:40.479
快速解释它们以及我们如何实现

00:07:38.620 --> 00:07:42.250
这些结果，给您更多

00:07:40.479 --> 00:07:45.159
有关PI发生的情况的信息

00:07:42.250 --> 00:07:46.930
当dravyam试图在后台

00:07:45.159 --> 00:07:50.770
实现那些，当然看到一些

00:07:46.930 --> 00:07:52.750
演示，因为总能看到更好

00:07:50.770 --> 00:07:55.259
比听别人说话更重要

00:07:52.750 --> 00:07:58.779
下载gravia时的注意事项

00:07:55.259 --> 00:08:01.060
您得到以下图片是

00:07:58.779 --> 00:08:04.210
一个zip存档，我们在存档中， 

00:08:01.060 --> 00:08:06.099
您将其解压缩，然后看到此内容，并且您

00:08:04.210 --> 00:08:08.259
可以看到，这与

00:08:06.099 --> 00:08:10.620
您拥有的正常JDK分布

00:08:08.259 --> 00:08:13.300
有所有普通的Java命令

00:08:10.620 --> 00:08:17.650
角落里有Java 

00:08:13.300 --> 00:08:20.710
 Java C Java T等，因此您可以使用

00:08:17.650 --> 00:08:23.650
它只是您的Java Runtime，因此您可以

00:08:20.710 --> 00:08:26.560
下载它解压缩它更改您的路径

00:08:23.650 --> 00:08:28.539
这个，然后看看是否带来

00:08:26.560 --> 00:08:30.430
您可以获得任何性能上的好处

00:08:28.539 --> 00:08:32.079
还请注意，还有更多命令

00:08:30.430 --> 00:08:34.930
您通常不会在

00:08:32.079 --> 00:08:39.029
以Java发行版为例

00:08:34.930 --> 00:08:42.849
命令或例如红宝石或

00:08:39.029 --> 00:08:45.100
那些是发射器的

00:08:42.849 --> 00:08:46.690
地面虚拟机运行并开始执行

00:08:45.100 --> 00:08:48.810
您用其他语言编写的程序

00:08:46.690 --> 00:08:50.820
不一定需要

00:08:48.810 --> 00:08:53.430
将所有语言混合在一起

00:08:50.820 --> 00:08:55.110
过程中，您可以执行它们

00:08:53.430 --> 00:08:57.450
通常，如果您有一些代码，我们

00:08:55.110 --> 00:09:02.240
用Ruby编写，您只需使用Ruby 

00:08:57.450 --> 00:09:04.710
希望能成功，我们会看到

00:09:02.240 --> 00:09:06.740
对，所以这就是你得到的

00:09:04.710 --> 00:09:09.510
你怎么知道这很简单

00:09:06.740 --> 00:09:11.430
首先从什么开始

00:09:09.510 --> 00:09:16.110
建筑，当你

00:09:11.430 --> 00:09:18.390
执行我们的Java命令，我们开始

00:09:16.110 --> 00:09:22.470
正常的杰米自己的过程，我们建立在

00:09:18.390 --> 00:09:24.900
 Java热点VM，这是正常现象

00:09:22.470 --> 00:09:28.050
 genium，我们做了什么，我们取代了

00:09:24.900 --> 00:09:32.070
顶级即时编译器

00:09:28.050 --> 00:09:34.260
地面vm编译器这是一个编译器

00:09:32.070 --> 00:09:38.010
用Java编写，并且使用害羞的JVM 

00:09:34.260 --> 00:09:40.170
与Virtual集成的界面

00:09:38.010 --> 00:09:42.060
机器JVM Shina接口，如果您

00:09:40.170 --> 00:09:45.720
不知道是Java虚拟机

00:09:42.060 --> 00:09:47.250
接口da中的编译器，这是

00:09:45.720 --> 00:09:49.560
您实现时实现的接口

00:09:47.250 --> 00:09:55.080
想要提供第三方编译器

00:09:49.560 --> 00:09:59.430
 JVM意味着它已添加到Java 9中

00:09:55.080 --> 00:10:03.420
通过Jap 243进行的任何操作

00:09:59.430 --> 00:10:06.600
在开放的JDK中，它是可用的

00:10:03.420 --> 00:10:09.660
在那里，通过整合画图

00:10:06.600 --> 00:10:12.960
带有JVM的EM编译器

00:10:09.660 --> 00:10:15.330
基础设施的两层

00:10:12.960 --> 00:10:18.330
运行时，我们可以运行普通的Java 

00:10:15.330 --> 00:10:21.089
通常在JVM上运行的程序

00:10:18.330 --> 00:10:23.160
找到您的课程，它将查看

00:10:21.089 --> 00:10:24.990
字节码，它将验证它是否为JVM 

00:10:23.160 --> 00:10:26.850
通常会加载开始吗

00:10:24.990 --> 00:10:28.980
回火，并在某个时间点

00:10:26.850 --> 00:10:30.990
将给出的字节码

00:10:28.980 --> 00:10:32.820
应用到编译器

00:10:30.990 --> 00:10:34.709
即时编译器，请说

00:10:32.820 --> 00:10:36.300
为我优化它，然后它将

00:10:34.709 --> 00:10:37.830
接收机器代码和一切

00:10:36.300 --> 00:10:40.290
将会很棒，而我们

00:10:37.830 --> 00:10:43.200
应用程序会突然运行得更快，所以

00:10:40.290 --> 00:10:43.800
通常通常会有

00:10:43.200 --> 00:10:45.839
不同

00:10:43.800 --> 00:10:47.910
顶级编译器（如果您只是下载） 

00:10:45.839 --> 00:10:51.510
例如打开JDK，然后运行

00:10:47.910 --> 00:10:55.310
使C 2最优化

00:10:51.510 --> 00:10:58.740
即时编译器集成VM 

00:10:55.310 --> 00:11:01.770
处理顶级编译器是

00:10:58.740 --> 00:11:02.490
由小时数CT替代仍然存在

00:11:01.770 --> 00:11:05.190
因为

00:11:02.490 --> 00:11:07.649
普通的JVM，因此您可以禁用

00:11:05.190 --> 00:11:10.380
危地马拉编译器并正常运行

00:11:07.649 --> 00:11:13.380
我们只是向

00:11:10.380 --> 00:11:15.120
 Java发行版，那不是

00:11:13.380 --> 00:11:18.360
足够，如果您愿意，那很好

00:11:15.120 --> 00:11:20.220
只运行大多数的jvm语言

00:11:18.360 --> 00:11:21.990
大概就是你最

00:11:20.220 --> 00:11:25.970
有趣的是你们写了多少

00:11:21.990 --> 00:11:28.260
爪哇每天都喜欢，周末除外

00:11:25.970 --> 00:11:28.800
你们有多少人使用其他基因组

00:11:28.260 --> 00:11:31.470
语言

00:11:28.800 --> 00:11:35.700
斯卡拉拍拍棉花在这里很漂亮

00:11:31.470 --> 00:11:39.350
好很好相当如何

00:11:35.700 --> 00:11:42.720
你们中许多人说没有js的应用程序

00:11:39.350 --> 00:11:45.899
出人意料的是，不是很多优秀的

00:11:42.720 --> 00:11:48.270
如果您只在语言上运行JD，这是

00:11:45.899 --> 00:11:51.660
够了，但是如果您想要其他的支持

00:11:48.270 --> 00:11:53.640
语言，这通常是不够的

00:11:51.660 --> 00:11:55.920
您希望获得其他支持

00:11:53.640 --> 00:11:58.950
语言的运行时一种方法

00:11:55.920 --> 00:12:00.839
人们通常会采用

00:11:58.950 --> 00:12:03.959
优化编译器本身以

00:12:00.839 --> 00:12:06.089
将结构和代码翻译成

00:12:03.959 --> 00:12:08.579
高级动态语言，说Java 

00:12:06.089 --> 00:12:11.490
脚本到基础中间件

00:12:08.579 --> 00:12:13.589
语言说他们的JVM字节码

00:12:11.490 --> 00:12:15.630
手动创建此映射

00:12:13.589 --> 00:12:18.720
编译器，然后运行字节码

00:12:15.630 --> 00:12:21.810
通常通过这就是我

00:12:18.720 --> 00:12:24.510
认为masteren是这样工作的，Jason就是这样

00:12:21.810 --> 00:12:27.570
为Python工作

00:12:24.510 --> 00:12:29.339
 JVM和那些

00:12:27.570 --> 00:12:31.980
实现的共同点是

00:12:29.339 --> 00:12:34.950
您的维护负担很高

00:12:31.980 --> 00:12:37.579
必须手动翻译高级

00:12:34.950 --> 00:12:39.930
语言变成相当有限的

00:12:37.579 --> 00:12:43.140
 JVM字节码的低级词汇

00:12:39.930 --> 00:12:45.570
这不是一件容易的事，当

00:12:43.140 --> 00:12:46.950
语言发展，甚至变得更加困难

00:12:45.570 --> 00:12:49.500
保持这种舒适感

00:12:46.950 --> 00:12:53.790
语言，因为我们想要支持

00:12:49.500 --> 00:12:57.240
所有语言显然是我们

00:12:53.790 --> 00:12:59.459
需要一种不同的方法，所以我们创建了

00:12:57.240 --> 00:13:01.200
今天称为松露的框架

00:12:59.459 --> 00:13:04.529
框架这是一个创建框架

00:13:01.200 --> 00:13:06.750
托管语言，这是一个框架

00:13:04.529 --> 00:13:09.149
为您提供描述该API的API 

00:13:06.750 --> 00:13:12.180
您语言的语义，因此我们需要

00:13:09.149 --> 00:13:13.550
使用该API来实现解释器

00:13:12.180 --> 00:13:16.090
用于您的编程语言

00:13:13.550 --> 00:13:18.280
实施口译员

00:13:16.090 --> 00:13:20.560
这是一个非常简单的过程

00:13:18.280 --> 00:13:22.570
想像你有一个程序

00:13:20.560 --> 00:13:24.970
您以抽象方式解析该程序

00:13:22.570 --> 00:13:27.460
语法树每个节点都有节点

00:13:24.970 --> 00:13:29.170
指定一个操作，您只需

00:13:27.460 --> 00:13:31.300
描述该操作的语义

00:13:29.170 --> 00:13:34.300
在像高级语言一样

00:13:31.300 --> 00:13:37.420
 Java，可以说是JavaScript plus操作

00:13:34.300 --> 00:13:39.550
将是左操作数加右操作数

00:13:37.420 --> 00:13:42.490
对，您不必弄清楚如何

00:13:39.550 --> 00:13:44.320
转换规则确实对您有效

00:13:42.490 --> 00:13:46.360
不必在低层映射

00:13:44.320 --> 00:13:49.120
您使用高级字节码语言

00:13:46.360 --> 00:13:52.060
您描述的语言，您指定了

00:13:49.120 --> 00:13:54.220
几个注释来提示

00:13:52.060 --> 00:13:56.650
松露框架怎么办

00:13:54.220 --> 00:13:59.230
特定的节点实现，然后

00:13:56.650 --> 00:14:01.420
你完成了，这是什么

00:13:59.230 --> 00:14:02.860
人们通常会喜欢什么

00:14:01.420 --> 00:14:04.690
第一个编译器得分或其他

00:14:02.860 --> 00:14:07.750
为语言构建口译员

00:14:04.690 --> 00:14:09.760
比这要少得多的努力

00:14:07.750 --> 00:14:12.790
实际构建运行时或

00:14:09.760 --> 00:14:14.500
优化编译器的缺点

00:14:12.790 --> 00:14:16.930
方法当然是这样的

00:14:14.500 --> 00:14:20.430
那里的口译员天生就很慢

00:14:16.930 --> 00:14:23.110
之所以慢，是因为它们令人难以置信

00:14:20.430 --> 00:14:25.180
动态的，因为每次都

00:14:23.110 --> 00:14:27.520
操作他们必须做一个评估

00:14:25.180 --> 00:14:29.970
他们需要打电话给某个班级的

00:14:27.520 --> 00:14:33.160
某些方法，例如我的节点

00:14:29.970 --> 00:14:34.750
评估只是找出每个

00:14:33.160 --> 00:14:37.000
操作，所以如果您有少量液体

00:14:34.750 --> 00:14:38.740
请注意，您需要将两个整数相加

00:14:37.000 --> 00:14:40.720
您需要进行三个虚拟通话

00:14:38.740 --> 00:14:43.300
评估左边的操作数，右边的

00:14:40.720 --> 00:14:45.490
操作数，然后加上这将是

00:14:43.300 --> 00:14:48.130
太慢了，我们不想要那样

00:14:45.490 --> 00:14:54.190
那么松露如何解决这个问题

00:14:48.130 --> 00:14:56.020
我们在那里运行专业化，我们合并

00:14:54.190 --> 00:14:58.840
在运行时，我们收集配置文件，我们

00:14:56.020 --> 00:15:00.310
合并实际的申请人申请

00:14:58.840 --> 00:15:02.860
您正在运行的程序和代码

00:15:00.310 --> 00:15:05.650
口译员我们内联了所有内容

00:15:02.860 --> 00:15:09.340
然后该代码变得更多

00:15:05.650 --> 00:15:11.290
高效，然后我们将其传递给

00:15:09.340 --> 00:15:14.890
 Veeam地面编译器，它进行了优化

00:15:11.290 --> 00:15:17.620
在JIT编译器级别再次

00:15:14.890 --> 00:15:19.870
机器代码变得非常优化

00:15:17.620 --> 00:15:22.600
并且我们在性能方面取得了不错的成绩

00:15:19.870 --> 00:15:24.760
对于那些母语的人

00:15:22.600 --> 00:15:27.190
语言，因为我们不能只运行

00:15:24.760 --> 00:15:27.880
本机代码处于解释模式

00:15:27.190 --> 00:15:29.950
我们做什么

00:15:27.880 --> 00:15:32.590
我们为LLVM创建了一个解释器

00:15:29.950 --> 00:15:35.500
位代码，通过它我们可以运行

00:15:32.590 --> 00:15:39.550
本机代码，用于支持

00:15:35.500 --> 00:15:41.860
本机部分的本机扩展

00:15:39.550 --> 00:15:43.780
使用它们的动态语言

00:15:41.860 --> 00:15:45.730
说你在某些机器上运行Python 

00:15:43.780 --> 00:15:49.510
学习，然后有一个麻木

00:15:45.730 --> 00:15:52.780
模块是您如何计算的

00:15:49.510 --> 00:15:54.580
它有一些Python代码，但它也

00:15:52.780 --> 00:15:58.810
就像编写了相当大的代码库

00:15:54.580 --> 00:16:02.050
我认为C或C ++正确的名称，我们

00:15:58.810 --> 00:16:04.330
希望通过LLVM解释器

00:16:02.050 --> 00:16:06.850
相同的过程，因为所有这些

00:16:04.330 --> 00:16:09.100
他们从运行时的角度

00:16:06.850 --> 00:16:12.400
他们看起来都一样，都是

00:16:09.100 --> 00:16:14.200
只是使用相同的树

00:16:12.400 --> 00:16:15.550
框架，因此从运行时

00:16:14.200 --> 00:16:17.110
查看是否没有区别

00:16:15.550 --> 00:16:20.620
您正在使用Python或

00:16:17.110 --> 00:16:22.930
 JavaScript或Ruby，我们可以优化

00:16:20.620 --> 00:16:26.020
并跨越语言障碍进行编译

00:16:22.930 --> 00:16:27.760
好的，所以我们可以内联您的母语

00:16:26.020 --> 00:16:29.920
扩展代码进入动态

00:16:27.760 --> 00:16:31.810
语言代码，因此目前是Java和

00:16:29.920 --> 00:16:35.380
 Scala和jvm语言有点

00:16:31.810 --> 00:16:40.510
不同的是更复杂

00:16:35.380 --> 00:16:43.480
 jvm之间需要Interop协议

00:16:40.510 --> 00:16:46.090
语言和其他语言，但最终我们

00:16:43.480 --> 00:16:48.790
将使它们在

00:16:46.090 --> 00:16:51.430
松露框架，然后他们

00:16:48.790 --> 00:16:54.430
在这三个方面将绝对相等

00:16:51.430 --> 00:16:56.680
没错，这就是它的外观

00:16:54.430 --> 00:16:59.950
您运行这些东西如何运行

00:16:56.680 --> 00:17:00.430
这些东西是开源的

00:16:59.950 --> 00:17:04.480
项目

00:17:00.430 --> 00:17:06.280
 Grahame是它的开源软件

00:17:04.480 --> 00:17:09.160
 github你可以去那里写

00:17:06.280 --> 00:17:12.010
很大程度上是用Java开发的

00:17:09.160 --> 00:17:13.839
觉得我们可以体会到这一点

00:17:12.010 --> 00:17:16.480
正常加载到您的ID 

00:17:13.839 --> 00:17:18.160
工具将使您不需要

00:17:16.480 --> 00:17:20.680
找出复杂的编译方式

00:17:18.160 --> 00:17:22.720
只是您了解代码

00:17:20.680 --> 00:17:25.510
您可以点击该课程的作品

00:17:22.720 --> 00:17:28.780
定义和感觉像您了解

00:17:25.510 --> 00:17:30.370
发生了什么仍然需要

00:17:28.780 --> 00:17:33.010
一点经验和

00:17:30.370 --> 00:17:35.470
了解你，我不知道

00:17:33.010 --> 00:17:38.410
一点补丁，并以此方式做出贡献

00:17:35.470 --> 00:17:39.560
因为它仍然是编译器

00:17:38.410 --> 00:17:42.810
工程如此

00:17:39.560 --> 00:17:44.550
至少我认为我平均而言

00:17:42.810 --> 00:17:46.350
您需要至少放入一个

00:17:44.550 --> 00:17:49.890
开始贡献之前的周末

00:17:46.350 --> 00:17:51.690
可能更多，但这是用Java编写的

00:17:49.890 --> 00:17:53.940
您可以了解正在做什么， 

00:17:51.690 --> 00:17:57.300
您可以查看是否有任何错误

00:17:53.940 --> 00:17:59.640
你会得到正常的正常例外

00:17:57.300 --> 00:18:01.890
而不是段错误，这是

00:17:59.640 --> 00:18:03.390
更容易使用，您可以

00:18:01.890 --> 00:18:05.190
自己建造它，你可以

00:18:03.390 --> 00:18:07.290
打包就可以了

00:18:05.190 --> 00:18:09.990
您也没有随机分布

00:18:07.290 --> 00:18:13.650
因为您只能使用我们的二进制文件

00:18:09.990 --> 00:18:15.630
因此团队可以提供他可以

00:18:13.650 --> 00:18:17.670
仅使用您可以使用的那些zip存档

00:18:15.630 --> 00:18:21.630
解压那里是社区版

00:18:17.670 --> 00:18:25.470
这是当你得到的神器

00:18:21.630 --> 00:18:26.010
您构建了开放源代码， 

00:18:25.470 --> 00:18:28.050
非常好

00:18:26.010 --> 00:18:30.360
它具有良好的性能，它是完全

00:18:28.050 --> 00:18:33.090
功能将运行所有程序

00:18:30.360 --> 00:18:34.710
字素可以运行，并且还有一个

00:18:33.090 --> 00:18:37.770
企业版是

00:18:34.710 --> 00:18:39.780
 Oracle及其专有产品

00:18:37.770 --> 00:18:42.060
具有更好的性能，所以

00:18:39.780 --> 00:18:45.240
编译器经过优化，有更多

00:18:42.060 --> 00:18:46.920
更多的编译器阶段并通过它

00:18:45.240 --> 00:18:48.840
会花更多的时间

00:18:46.920 --> 00:18:52.350
尝试优化代码，但通常是

00:18:48.840 --> 00:18:55.650
将为您带来更好的结果

00:18:52.350 --> 00:18:58.590
性能，所以目前我们有Linux 

00:18:55.650 --> 00:19:00.990
和Mac OS作为支持平台

00:18:58.590 --> 00:19:03.750
我们有一个实验性的二进制文件

00:19:00.990 --> 00:19:05.760
 Windows内置的功能可以做到

00:19:03.750 --> 00:19:09.870
事情，所以我们可以尝试一下

00:19:05.760 --> 00:19:12.890
但大多数情况下，我们有用于

00:19:09.870 --> 00:19:17.550
 linux和Mac的好，因为

00:19:12.890 --> 00:19:19.890
生产通常在Linux上运行，因此我们

00:19:17.550 --> 00:19:22.500
可以得到我的那一点

00:19:19.890 --> 00:19:26.850
早些时候对此感到非常兴奋

00:19:22.500 --> 00:19:28.770
本月，我们推出了成长虚拟机19.0和

00:19:26.850 --> 00:19:31.800
一起在工作中的发射dravyam 

00:19:28.770 --> 00:19:34.290
甲骨文IAM企业级产品

00:19:31.800 --> 00:19:36.120
这意味着工人将提供

00:19:34.290 --> 00:19:39.270
支持它，这意味着如果您

00:19:36.120 --> 00:19:41.310
想用你可以的你可以转向

00:19:39.270 --> 00:19:42.870
甲骨文代表和谈

00:19:41.310 --> 00:19:46.620
那也意味着

00:19:42.870 --> 00:19:49.640
这个项目真的有很好的机会

00:19:46.620 --> 00:19:52.500
生活很长一段时间

00:19:49.640 --> 00:19:53.040
所以你可以调查一下

00:19:52.500 --> 00:19:54.870
你要

00:19:53.040 --> 00:19:57.690
但是社区版完全

00:19:54.870 --> 00:19:59.250
功能，您可以运行它，如果您

00:19:57.690 --> 00:20:01.400
只想要额外的性能就可以

00:19:59.250 --> 00:20:04.020
以后再弄清楚

00:20:01.400 --> 00:20:06.240
一起走吧，让我们看一些

00:20:04.020 --> 00:20:08.480
演示，让我们看看

00:20:06.240 --> 00:20:11.850
我正在谈论的性能影响

00:20:08.480 --> 00:20:13.740
让我们看看我有这么简单

00:20:11.850 --> 00:20:16.650
基准，通常我会显示一些

00:20:13.740 --> 00:20:18.660
有点不同也可以合成

00:20:16.650 --> 00:20:21.060
因为我们在 Spring 会议上

00:20:18.660 --> 00:20:23.430
在这里，我觉得我应该

00:20:21.060 --> 00:20:26.400
使用项目运行一个小型基准

00:20:23.430 --> 00:20:28.620
反应器API对其进行基准测试

00:20:26.400 --> 00:20:30.720
所以让我告诉你如何运行它， 

00:20:28.620 --> 00:20:34.170
然后我们会稍微看一下代码

00:20:30.720 --> 00:20:39.240
正确一点，我做了什么

00:20:34.170 --> 00:20:41.340
我下载我的Graham我有我的工具

00:20:39.240 --> 00:20:43.650
和命令在这里，如果我叫哪个

00:20:41.340 --> 00:20:45.780
 Java您可以看到这是我的Java 

00:20:43.650 --> 00:20:48.330
从地面vm分发，如果我

00:20:45.780 --> 00:20:52.350
调用Java-您可以看到的版本

00:20:48.330 --> 00:20:54.510
这是基于Java 8构建的，所以

00:20:52.350 --> 00:20:57.240
当我运行Java命令时

00:20:54.510 --> 00:20:59.580
这个Java一直在我的路上吗

00:20:57.240 --> 00:21:02.490
正确，当我运行任何Java时，这是

00:20:59.580 --> 00:21:04.470
运行什么应该给你足够的

00:21:02.490 --> 00:21:07.590
有信心放进去

00:21:04.470 --> 00:21:10.530
生产不考虑你

00:21:07.590 --> 00:21:12.930
的过程，因为我在笔记本电脑上运行它

00:21:10.530 --> 00:21:15.240
你应该评估，但你应该知道

00:21:12.930 --> 00:21:17.730
我们运行内部Java 

00:21:15.240 --> 00:21:21.900
 Oracle应用程序上的应用程序

00:21:17.730 --> 00:21:23.910
地面虚拟机，我们看不到

00:21:21.900 --> 00:21:25.320
看到很多问题，我想要什么

00:21:23.910 --> 00:21:30.090
我要您运行基准测试

00:21:25.320 --> 00:21:32.220
为您服务，所以我将运行

00:21:30.090 --> 00:21:34.470
以下文件我将在没有

00:21:32.220 --> 00:21:36.510
土拨鼠编译器首先向您展示

00:21:34.470 --> 00:21:38.550
差异对吧，我将从

00:21:36.510 --> 00:21:40.830
地面虚拟机，但我将禁用JVM 

00:21:38.550 --> 00:21:42.840
所以我编译对，这就是我的意思

00:21:40.830 --> 00:21:45.210
当它说你可以演戏

00:21:42.840 --> 00:21:47.790
绝对正常，我可以禁用

00:21:45.210 --> 00:21:48.740
编译器我只能说不要使用

00:21:47.790 --> 00:21:53.310
授权编译器

00:21:48.740 --> 00:21:55.590
而且它将正常运行，所以

00:21:53.310 --> 00:21:57.570
我将开始它，我们不使用JVM 

00:21:55.590 --> 00:22:00.630
状态编译器将花费40秒

00:21:57.570 --> 00:22:03.060
并在4秒内看到结果

00:22:00.630 --> 00:22:06.210
让我们看一下代码是做什么的

00:22:03.060 --> 00:22:08.910
它需要一些对象

00:22:06.210 --> 00:22:13.590
在这种情况下的整数，然后有

00:22:08.910 --> 00:22:16.470
我们检查的一种测试方法

00:22:13.590 --> 00:22:19.020
延迟，因此较低的结果将是

00:22:16.470 --> 00:22:21.210
更好的平均执行时间

00:22:19.020 --> 00:22:23.280
方法以及我们所做的事情

00:22:21.210 --> 00:22:25.140
这些价值观，我们适用一些

00:22:23.280 --> 00:22:27.570
转化为他们，我们将它们减少为

00:22:25.140 --> 00:22:30.480
一个数字，我们只是收集这个

00:22:27.570 --> 00:22:32.850
带有块的管道可能是

00:22:30.480 --> 00:22:35.610
而不是您每天编写的代码

00:22:32.850 --> 00:22:39.510
除非您编写的应用程序

00:22:35.610 --> 00:22:42.060
像一百个整数一样转换

00:22:39.510 --> 00:22:44.580
这个MZ训练某些密码通过

00:22:42.060 --> 00:22:47.460
实际上为

00:22:44.580 --> 00:22:49.620
整个电抗弦乐

00:22:47.460 --> 00:22:52.500
项目或演员的问题是

00:22:49.620 --> 00:22:55.110
 Spring 跑步时酵母

00:22:52.500 --> 00:22:58.890
应用程序和该基准之一

00:22:55.110 --> 00:23:01.110
至少是合成的，至少你知道

00:22:58.890 --> 00:23:04.290
它实际上使用了您的代码

00:23:01.110 --> 00:23:06.330
也可用于生产40 

00:23:04.290 --> 00:23:08.010
秒过去了，所以我们得到了

00:23:06.330 --> 00:23:10.470
数字，这是一个相当大的数字

00:23:08.010 --> 00:23:12.690
因为它需要经历所有

00:23:10.470 --> 00:23:14.730
一百个元素，它需要创建

00:23:12.690 --> 00:23:16.740
订阅订户以及所有这些

00:23:14.730 --> 00:23:18.920
元素并通过它推送数据

00:23:16.740 --> 00:23:21.690
管道，所以我们得到像

00:23:18.920 --> 00:23:24.780
每秒24400纳秒

00:23:21.690 --> 00:23:28.680
操作，所以现在我会做，我会

00:23:24.780 --> 00:23:31.200
运行版本而不禁用

00:23:28.680 --> 00:23:32.520
 Grove am编译器正确，因此使用我们的Java 

00:23:31.200 --> 00:23:34.920
你从地面游戏中得到的

00:23:32.520 --> 00:23:36.930
分发地面VM编译器

00:23:34.920 --> 00:23:38.850
默认情况下启用，所以现在我不会

00:23:36.930 --> 00:23:41.160
手动禁用它，我将运行它

00:23:38.850 --> 00:23:42.660
我们会看到结果不会变质

00:23:41.160 --> 00:23:47.910
结果，我们将搅动基准

00:23:42.660 --> 00:23:52.110
多一点正确的人认为

00:23:47.910 --> 00:23:55.230
会更快地举手

00:23:52.110 --> 00:23:57.180
我了解您的怀疑态度JVM是

00:23:55.230 --> 00:24:00.450
最先进的虚拟机

00:23:57.180 --> 00:24:03.420
要比JDM更快并不容易，但是

00:24:00.450 --> 00:24:05.100
希望它会更快，因为这

00:24:03.420 --> 00:24:06.420
是演示，这将是愚蠢的

00:24:05.100 --> 00:24:10.890
向您展示我们的基准

00:24:06.420 --> 00:24:12.870
慢一点，但老实说我通常在

00:24:10.890 --> 00:24:15.060
舞台做一个不同的，所以我真的

00:24:12.870 --> 00:24:17.250
有点紧张我很公平

00:24:15.060 --> 00:24:19.350
有能力确保这将是

00:24:17.250 --> 00:24:20.580
但我们会看到结果多少

00:24:19.350 --> 00:24:25.500
您认为谁会更快

00:24:20.580 --> 00:24:27.299
更快达到10％或更多可以

00:24:25.500 --> 00:24:30.840
相当乐观的人二十

00:24:27.299 --> 00:24:33.000
百分之十或更多十

00:24:30.840 --> 00:24:34.799
百分比的JVM可以买到你

00:24:33.000 --> 00:24:36.750
像低延迟的垃圾收集器

00:24:34.799 --> 00:24:41.419
什么时候介绍你想看我

00:24:36.750 --> 00:24:45.600
认为这个想法是10％ 

00:24:41.419 --> 00:24:47.549
吞吐量下降最多就是你

00:24:45.600 --> 00:24:49.019
当您说出哪个会收到

00:24:47.549 --> 00:24:51.269
你想看到吗，我想其他

00:24:49.019 --> 00:24:54.870
低延迟垃圾收集器也尝试

00:24:51.269 --> 00:24:56.909
这样的开销不超过10 

00:24:54.870 --> 00:24:59.580
 ％，按城市低位计算，为10％ 

00:24:56.909 --> 00:25:01.970
延迟20％的GC会让您觉得便宜

00:24:59.580 --> 00:25:04.889
延迟GCS等

00:25:01.970 --> 00:25:09.450
其他任何东西都是肉汁吧

00:25:04.889 --> 00:25:12.120
否则，你得到的就是你纯粹保存的东西

00:25:09.450 --> 00:25:14.279
钱，如果你在某个云上说

00:25:12.120 --> 00:25:17.220
您为计算实例付费，所以让我们

00:25:14.279 --> 00:25:19.649
看，让我们看看这有多快

00:25:17.220 --> 00:25:22.320
哦，看它有多慢

00:25:19.649 --> 00:25:30.889
运行一次迭代的分数

00:25:22.320 --> 00:25:32.120
这个测试方法是89秒1824 

00:25:30.889 --> 00:25:35.429
 2,580 

00:25:32.120 --> 00:25:40.980
我的质量不好，但如果你分裂

00:25:35.429 --> 00:25:42.840
那是30倍

00:25:40.980 --> 00:25:45.330
不断增长的vm编译器启用了此功能

00:25:42.840 --> 00:25:51.120
基准比30倍快

00:25:45.330 --> 00:25:54.690
通常那是一个惊人的结果

00:25:51.120 --> 00:25:56.429
显然也没有代表性

00:25:54.690 --> 00:25:58.980
都是您要承担的工作量

00:25:56.429 --> 00:26:01.730
运行，所以如果您运行应用程序我

00:25:58.980 --> 00:26:04.710
不要以为你会看到百分之三十

00:26:01.730 --> 00:26:07.169
性能提升三倍，这是

00:26:04.710 --> 00:26:09.269
只是荒谬的期望，这是

00:26:07.169 --> 00:26:11.070
这是舞台上显示的基准

00:26:09.269 --> 00:26:12.870
所以你应该用一个

00:26:11.070 --> 00:26:15.600
一粒盐，因为我们在我的

00:26:12.870 --> 00:26:17.789
可怜的MacBook在这里，这显然不是

00:26:15.600 --> 00:26:20.789
最科学的基准

00:26:17.789 --> 00:26:23.399
环境，所以你应该你应该

00:26:20.789 --> 00:26:25.889
不应该相信这个号码

00:26:23.399 --> 00:26:28.350
甚至看到下面的数字仅仅是

00:26:25.889 --> 00:26:30.020
数据，您必须将其解释为

00:26:28.350 --> 00:26:31.659
有意义和合理的方式

00:26:30.020 --> 00:26:34.940
你必须了解发生了什么

00:26:31.659 --> 00:26:36.830
所以这是悲观的观点

00:26:34.940 --> 00:26:38.899
在这个结果中泛泛乐观的看法

00:26:36.830 --> 00:26:40.760
这就是我想要你做的

00:26:38.899 --> 00:26:44.870
从这个数字你知道

00:26:40.760 --> 00:26:47.960
编写的程序是否可能

00:26:44.870 --> 00:26:50.720
在JVM上运行的Java将

00:26:47.960 --> 00:26:52.159
如果在它们上运行，速度会大大提高

00:26:50.720 --> 00:26:54.740
地面虚拟机

00:26:52.159 --> 00:26:57.880
对，不必像三个

00:26:54.740 --> 00:27:02.000
快一倍，但即使您得到20％ 

00:26:57.880 --> 00:27:06.380
性能提升非常正确，因此

00:27:02.000 --> 00:27:09.020
如果这至少不能说服您

00:27:06.380 --> 00:27:12.289
评估能力，然后我会告诉你

00:27:09.020 --> 00:27:14.630
我想说更多有关此的幻灯片

00:27:12.289 --> 00:27:16.940
什么都不愿意，但实际上也许有些

00:27:14.630 --> 00:27:20.990
其他事情很好，所以在内部

00:27:16.940 --> 00:27:23.929
我们有大量的基准，我们得到

00:27:20.990 --> 00:27:28.340
结果是我们的基准种子

00:27:23.929 --> 00:27:30.620
最近出版的大书，我的意思是

00:27:28.340 --> 00:27:33.320
实际执行性能的工程师

00:27:30.620 --> 00:27:36.620
是我们想要的文艺复兴时期

00:27:33.320 --> 00:27:39.620
这样做是为了收集船尾号

00:27:36.620 --> 00:27:42.799
代表现代Java的用例

00:27:39.620 --> 00:27:46.100
是的，所以我们运行正常的基准测试

00:27:42.799 --> 00:27:48.710
我们运行规范JVM规范jbb all 

00:27:46.100 --> 00:27:50.510
其中我们看到了这些数字，但我们

00:27:48.710 --> 00:27:52.159
常常觉得他们可能不是

00:27:50.510 --> 00:27:54.760
现代最有代表性的

00:27:52.159 --> 00:27:58.100
你有多少人喜欢正确的工作量

00:27:54.760 --> 00:28:01.220
分形为生活多少人

00:27:58.100 --> 00:28:03.380
低级数学显然可以得到代码

00:28:01.220 --> 00:28:05.840
运行正确，因为这就是我们

00:28:03.380 --> 00:28:07.610
在它运行的基础上建立

00:28:05.840 --> 00:28:10.909
基础架构就是这样的代码

00:28:07.610 --> 00:28:13.309
在JDK的JVM本身中运行

00:28:10.909 --> 00:28:15.080
图书馆的标准，但也许我们

00:28:13.309 --> 00:28:18.020
只需使用更高级别的库

00:28:15.080 --> 00:28:20.570
也许我们使用一些反应式代码，也许我们

00:28:18.020 --> 00:28:24.980
使用一些反应性扩展，也许我们

00:28:20.570 --> 00:28:27.679
用一些阿卡也许我们做一些贝叶斯

00:28:24.980 --> 00:28:29.630
先生，也许我们可以做点什么

00:28:27.679 --> 00:28:31.580
对于J而言较新，也许我们需要处理工作负载

00:28:29.630 --> 00:28:33.770
内存中有大量物体

00:28:31.580 --> 00:28:35.779
他们是他们是他们只是坐在

00:28:33.770 --> 00:28:37.429
那里和编译器需要不同

00:28:35.779 --> 00:28:40.639
一组优化以显示良好

00:28:37.429 --> 00:28:42.680
性能和O，所以我们研究了

00:28:40.639 --> 00:28:44.810
这些数字和

00:28:42.680 --> 00:28:47.480
文艺复兴时期的基准座位

00:28:44.810 --> 00:28:50.570
很好地代表了现代工作量

00:28:47.480 --> 00:28:52.670
所以这里重要的一点是要注意

00:28:50.570 --> 00:28:56.060
我是社区版的引力

00:28:52.670 --> 00:29:00.290
经常有点不稳定

00:28:56.060 --> 00:29:03.920
它比openjdk更快，有时

00:29:00.290 --> 00:29:05.960
慢一点，我们跑很多

00:29:03.920 --> 00:29:08.110
基准，如果我们将其折叠成一个

00:29:05.960 --> 00:29:11.180
单号Grand Am Community Edition 

00:29:08.110 --> 00:29:15.470
快约百分之一

00:29:11.180 --> 00:29:17.840
比打开JDK好，这是一个平均水平

00:29:15.470 --> 00:29:19.820
那个医院的温度那个数字

00:29:17.840 --> 00:29:22.040
告诉你什么都不需要你清楚

00:29:19.820 --> 00:29:25.190
评估您的工作量

00:29:22.040 --> 00:29:27.830
您的应用程序代码上的硬件

00:29:25.190 --> 00:29:30.620
模式和我们看到的非常

00:29:27.830 --> 00:29:34.340
通常它会给你很好的表现

00:29:30.620 --> 00:29:36.020
提高开放的JDK，所以如果您了解

00:29:34.340 --> 00:29:37.580
如果您了解

00:29:36.020 --> 00:29:40.400
应用程序的性能模式

00:29:37.580 --> 00:29:42.440
欢迎您使用社区

00:29:40.400 --> 00:29:45.140
版，它可能会给你

00:29:42.440 --> 00:29:46.960
相当大的性能提升了企业

00:29:45.140 --> 00:29:50.360
当然是产品的版本

00:29:46.960 --> 00:29:52.130
可能会给你带来更好的效果

00:29:50.360 --> 00:29:55.670
性能提升，并且普遍存在

00:29:52.130 --> 00:29:57.620
比打开JDK更快，所以如果您不这样做

00:29:55.670 --> 00:30:02.270
对性能一无所知

00:29:57.620 --> 00:30:04.460
您可以调查一下我们的运行情况

00:30:02.270 --> 00:30:08.300
其他基准，我们经常

00:30:04.460 --> 00:30:10.910
关于旁边发生了什么的博客

00:30:08.300 --> 00:30:13.580
与地面虚拟机一起在幕后

00:30:10.910 --> 00:30:16.030
我们如果您使用Java 8及更高版本

00:30:13.580 --> 00:30:19.010
您使用运行Java在生产中

00:30:16.030 --> 00:30:22.370
几乎每个人都非常好

00:30:19.010 --> 00:30:23.630
你们中的许多人都运行Java 9，而且还不错

00:30:22.370 --> 00:30:25.790
认为这是最大的百分比

00:30:23.630 --> 00:30:27.980
他们从会议上看到非常好

00:30:25.790 --> 00:30:31.640
你非常了解普通人

00:30:27.980 --> 00:30:33.320
现代Java，因此，如果您运行那些现代

00:30:31.640 --> 00:30:34.790
你可能会使用lambdas 

00:30:33.320 --> 00:30:37.250
您可能在任何地方流式传输API 

00:30:34.790 --> 00:30:39.620
所以你尝试使用也许不变的数据

00:30:37.250 --> 00:30:41.110
这些代码模式的结构

00:30:39.620 --> 00:30:43.850
应该真正提高性能

00:30:41.110 --> 00:30:46.430
您可以在medium.com上了解到

00:30:43.850 --> 00:30:48.620
斜线嗯，我们表现得很好

00:30:46.430 --> 00:30:50.180
学者的数字，因为斯卡拉

00:30:48.620 --> 00:30:51.680
字节码模式有点

00:30:50.180 --> 00:30:53.450
与普通字节码不同

00:30:51.680 --> 00:30:55.670
 Java程序创建的模式

00:30:53.450 --> 00:30:56.630
因为团结翻译得更高

00:30:55.670 --> 00:30:59.810
的水平

00:30:56.630 --> 00:31:01.490
字节码的指令，所以它们

00:30:59.810 --> 00:31:05.840
有所不同，我们

00:31:01.490 --> 00:31:08.570
在Scala上显示出非常好的结果，但是我们

00:31:05.840 --> 00:31:11.510
我们也想成为一个好人

00:31:08.570 --> 00:31:14.750
开源项目，所以现在在地下

00:31:11.510 --> 00:31:18.320
 VM我们有开放的JDK Java热点

00:31:14.750 --> 00:31:21.500
 vm实施和打开JDK项目

00:31:18.320 --> 00:31:23.840
用灰色的vm编译器，他们拉

00:31:21.500 --> 00:31:27.250
它进入他们的资源，因为它很开放

00:31:23.840 --> 00:31:30.950
源并将其打包，因此如果您运行

00:31:27.250 --> 00:31:34.250
 Java我认为十加九

00:31:30.950 --> 00:31:36.890
你可以做什么，你可以启用某些

00:31:34.250 --> 00:31:39.860
公用线路参数一些选项和

00:31:36.890 --> 00:31:43.610
你可以得到爷爷的版本

00:31:39.860 --> 00:31:45.050
打开JDK里面的编译器，然后

00:31:43.610 --> 00:31:46.610
您不需要下载其他任何内容

00:31:45.050 --> 00:31:48.830
那将是开源的

00:31:46.610 --> 00:31:51.110
版本的编译器可能没有

00:31:48.830 --> 00:31:53.360
像最新的和最伟大的

00:31:51.110 --> 00:31:55.250
从灰色层主控器接地，但它

00:31:53.360 --> 00:31:57.620
当他们拉这些将是一个

00:31:55.250 --> 00:32:00.950
来源进入开放式JDK林时

00:31:57.620 --> 00:32:02.900
他们打了补丁，以便您需要

00:32:00.950 --> 00:32:07.550
解锁实验机选项

00:32:02.900 --> 00:32:08.810
使用JVM Sai编译器，并与您一起使用

00:32:07.550 --> 00:32:12.640
将会经营Grand Am 

00:32:08.810 --> 00:32:12.640
编译器，您将成为

00:32:13.000 --> 00:32:17.750
经历不同的表现

00:32:15.110 --> 00:32:19.700
您的应用程序中的模式

00:32:17.750 --> 00:32:23.420
问那有多好

00:32:19.700 --> 00:32:25.220
这取决于工作量，所以我们

00:32:23.420 --> 00:32:29.500
记住基准应该在哪里

00:32:25.220 --> 00:32:31.880
真正获得结果的其中之一是

00:32:29.500 --> 00:32:37.160
哪个人合适基准

00:32:31.880 --> 00:32:40.040
当他们想解释什么时显示

00:32:37.160 --> 00:32:41.270
值值类型将为您带来

00:32:40.040 --> 00:32:44.090
这是您倍增的基准

00:32:41.270 --> 00:32:45.800
矩阵和复数a 

00:32:44.090 --> 00:32:47.420
复数是一个数字，由

00:32:45.800 --> 00:32:49.270
两个部分有两个双打

00:32:47.420 --> 00:32:51.470
在里面，特别是

00:32:49.270 --> 00:32:52.670
基准复数是

00:32:51.470 --> 00:32:54.830
实现为不可变数据

00:32:52.670 --> 00:32:56.840
结构很好，因为

00:32:54.830 --> 00:32:58.790
开发人员这就是我们想要的

00:32:56.840 --> 00:33:00.740
他们容易推理的程序

00:32:58.790 --> 00:33:02.750
关于这很容易调试和

00:33:00.740 --> 00:33:05.180
不可变的数据结构经常

00:33:02.750 --> 00:33:08.210
确切地告诉我们这很难

00:33:05.180 --> 00:33:10.130
弄清楚什么会改变全球状态，但是

00:33:08.210 --> 00:33:12.230
不变的数据结构是

00:33:10.130 --> 00:33:14.600
善于推理和理解

00:33:12.230 --> 00:33:16.010
他们不擅长的是

00:33:14.600 --> 00:33:19.640
不变数据的操作

00:33:16.010 --> 00:33:24.350
通常会创建新结构的结构

00:33:19.640 --> 00:33:27.260
当我们做任何移动时对象正确

00:33:24.350 --> 00:33:29.540
我们在那里做任何数学运算都很好

00:33:27.260 --> 00:33:31.820
对，我们一直在创建新对象

00:33:29.540 --> 00:33:34.610
所以格兰迪我是编译器

00:33:31.820 --> 00:33:36.050
真正好的逃脱分析，它可以

00:33:34.610 --> 00:33:39.800
消除几乎所有这些分配

00:33:36.050 --> 00:33:44.300
比CT好很多，所以当我们跑步时

00:33:39.800 --> 00:33:47.780
在jdk 11上再次在这个穷人身上

00:33:44.300 --> 00:33:51.140
 Macbook不相信这些数字，但是

00:33:47.780 --> 00:33:53.180
您可以相信我们之间的差异

00:33:51.140 --> 00:33:55.550
从地面获得vm编译器

00:33:53.180 --> 00:33:58.490
打开JDK，我们得到大约2倍

00:33:55.550 --> 00:34:00.050
再次提速那将不是你的

00:33:58.490 --> 00:34:02.120
任何正常速度下的典型速度

00:34:00.050 --> 00:34:04.790
应用程序，但这是要

00:34:02.120 --> 00:34:07.910
看看企业版是

00:34:04.790 --> 00:34:10.159
还是快一点，但是

00:34:07.910 --> 00:34:13.280
大am社区版真的

00:34:10.159 --> 00:34:15.409
真的也很好，所以你可以你可以

00:34:13.280 --> 00:34:16.730
应该研究一下正确的Twitter是

00:34:15.409 --> 00:34:18.169
一家正在使用地面的公司

00:34:16.730 --> 00:34:20.870
 viim编译器的运行有两种常见

00:34:18.169 --> 00:34:22.909
他们在各地旅行的微服务

00:34:20.870 --> 00:34:25.520
世界，谈论这件事，因为他们

00:34:22.909 --> 00:34:27.950
希望您运行编译器

00:34:25.520 --> 00:34:30.200
也因为这意味着编译器

00:34:27.950 --> 00:34:32.179
将确保更快，如果更多

00:34:30.200 --> 00:34:34.850
人们运行他们的代码，我们使用这个

00:34:32.179 --> 00:34:36.860
技术越稳定，越成熟

00:34:34.850 --> 00:34:39.050
他们会变得如此一段时间

00:34:36.860 --> 00:34:41.600
没有任何错误可以报告给我们，所以我

00:34:39.050 --> 00:34:43.940
认为他们还算幸福，他们

00:34:41.600 --> 00:34:46.610
显示它们在cpu中都显示减少

00:34:43.940 --> 00:34:49.100
用户时间，并且显示出

00:34:46.610 --> 00:34:51.200
延迟，因为逃脱更好

00:34:49.100 --> 00:34:53.270
分析他们的程序没有分配

00:34:51.200 --> 00:34:57.350
尽可能多的数据，因此它们不会给

00:34:53.270 --> 00:34:59.440
垃圾收集器有一些新的

00:34:57.350 --> 00:35:02.570
我们投入的发展

00:34:59.440 --> 00:35:04.160
最近宣布地面上午19一

00:35:02.570 --> 00:35:07.250
事情是，我们编译了重力M 

00:35:04.160 --> 00:35:09.860
编译器与grand-am编译器一起使用

00:35:07.250 --> 00:35:12.080
在获得衬衫库代码之前

00:35:09.860 --> 00:35:14.810
一个jar文件，它必须在以下位置编译

00:35:12.080 --> 00:35:18.470
运行时，它给某些部分施加压力

00:35:14.810 --> 00:35:20.950
像这样的JDM基础架构

00:35:18.470 --> 00:35:23.880
需要自己编译，这不是

00:35:20.950 --> 00:35:26.970
超快速热身，所以现在

00:35:23.880 --> 00:35:29.279
预编译的机器代码，它将

00:35:26.970 --> 00:35:31.829
立即快速预热，应该

00:35:29.279 --> 00:35:36.119
展现所有运行时特征

00:35:31.829 --> 00:35:40.440
 CT的普通JDM 

00:35:36.119 --> 00:35:42.509
结果代码可能更快

00:35:40.440 --> 00:35:44.970
让我们真正地谈论多边形

00:35:42.509 --> 00:35:47.670
快，因为我想到达下一个

00:35:44.970 --> 00:35:49.559
话题，没有超级分钟

00:35:47.670 --> 00:35:52.079
好多时间，让我告诉你

00:35:49.559 --> 00:35:55.710
 Spring 应用的例子

00:35:52.079 --> 00:35:58.710
评估我们的代码，这是其中的代码

00:35:55.710 --> 00:36:01.140
如果您不是艺术开发商，那么我们

00:35:58.710 --> 00:36:03.059
可以看到这显然是外国语法

00:36:01.140 --> 00:36:05.819
对你来说，这就是你得到的

00:36:03.059 --> 00:36:08.819
让普通的Java开发人员编写代码

00:36:05.819 --> 00:36:11.039
最可能不是最

00:36:08.819 --> 00:36:13.440
愚蠢的，但这是我们的功能

00:36:11.039 --> 00:36:15.960
代码我们这里有一个典型的

00:36:13.440 --> 00:36:18.299
字符串启动应用程序启动

00:36:15.960 --> 00:36:21.500
它注册了一些beans，我要

00:36:18.299 --> 00:36:24.660
运行它，我们真的希望不会崩溃

00:36:21.500 --> 00:36:26.640
对，我运行这个重要的位子

00:36:24.660 --> 00:36:28.740
我们看到这里是我们创建一个bean 

00:36:26.640 --> 00:36:33.720
称为联系人，这来自

00:36:28.740 --> 00:36:36.990
地面iam API地面iam提供API 

00:36:33.720 --> 00:36:39.109
创建多语言应用程序，我们

00:36:36.990 --> 00:36:41.599
需要建立一个环境来评估

00:36:39.109 --> 00:36:44.700
其中的其他语言的脚本

00:36:41.599 --> 00:36:48.390
然后我们评估来源

00:36:44.700 --> 00:36:50.069
从一个文件属性，我们得到

00:36:48.390 --> 00:36:53.369
通过有效的那个来源，然后我们

00:36:50.069 --> 00:36:54.839
将其转换为Java函数

00:36:53.369 --> 00:36:56.990
某些API做正常的事情

00:36:54.839 --> 00:36:59.369
像整数到整数的转换

00:36:56.990 --> 00:37:00.599
字符串到字符串集合

00:36:59.369 --> 00:37:02.700
我们尝试提供的收藏

00:37:00.599 --> 00:37:04.910
做出合理的抽象

00:37:02.700 --> 00:37:07.259
语言之间的互操作性

00:37:04.910 --> 00:37:10.680
跨不同语言统一

00:37:07.259 --> 00:37:13.829
也足够合理地与之合作

00:37:10.680 --> 00:37:16.079
所以在这里我们知道这个脚本

00:37:13.829 --> 00:37:19.170
文件只给我们一个功能，所以我们

00:37:16.079 --> 00:37:21.660
可以轻松地将其转换为

00:37:19.170 --> 00:37:23.309
那是什么功能

00:37:21.660 --> 00:37:23.819
函数这是Java util函数

00:37:23.309 --> 00:37:26.039
功能

00:37:23.819 --> 00:37:28.319
这甚至不是我们的API了

00:37:26.039 --> 00:37:30.900
是您的普通Java最好的是

00:37:28.319 --> 00:37:34.529
在那之后，我们通常使用

00:37:30.900 --> 00:37:37.740
将Java对象正确传递给它

00:37:34.529 --> 00:37:38.040
我们应用Java基本值

00:37:37.740 --> 00:37:40.200
得到

00:37:38.040 --> 00:37:42.620
结果是一个Java字符串，我们

00:37:40.200 --> 00:37:45.570
只需在屏幕上呈现该字符串， 

00:37:42.620 --> 00:37:51.410
让我们看看它是否开始是的，我认为

00:37:45.570 --> 00:37:55.230
启动它启动了localhost：8080加载

00:37:51.410 --> 00:37:57.240
对，我们看看它是否有效

00:37:55.230 --> 00:37:59.400
该应用程序不执行任何操作

00:37:57.240 --> 00:38:01.950
通过随机数据一些系统负载

00:37:59.400 --> 00:38:04.500
平均到我们的代码，它使用了

00:38:01.950 --> 00:38:07.890
我们的设施将代码绘制到

00:38:04.500 --> 00:38:10.380
 SVG图像可能不是最令人兴奋的

00:38:07.890 --> 00:38:12.690
示例，但您可以看到它清除了

00:38:10.380 --> 00:38:15.060
单词，它最初会加载一点

00:38:12.690 --> 00:38:17.160
慢一点，因为它需要加载

00:38:15.060 --> 00:38:18.780
他们的图书馆标准和需要

00:38:17.160 --> 00:38:20.670
编译代码，因此需要

00:38:18.780 --> 00:38:23.880
收集个人资料，但随后得到

00:38:20.670 --> 00:38:26.850
真的越来越快，所以数据

00:38:23.880 --> 00:38:29.340
从Java普通Java对象到

00:38:26.850 --> 00:38:31.620
我们的代码没有转换或

00:38:29.340 --> 00:38:34.860
序列化发生在同一

00:38:31.620 --> 00:38:38.220
过程，然后在我们的代码中，这是

00:38:34.860 --> 00:38:39.660
相当有趣，我们可以在

00:38:38.220 --> 00:38:41.010
我说我们的代码可以是任何

00:38:39.660 --> 00:38:45.240
我们支持的语言可能是

00:38:41.010 --> 00:38:49.170
 JavaScript Python Ruby R或其他任何东西

00:38:45.240 --> 00:38:51.360
我们可以使用Java类型

00:38:49.170 --> 00:38:53.760
并正常使用它们，所以在这里我们将

00:38:51.360 --> 00:38:58.260
有记录器，我们将记录一些数据

00:38:53.760 --> 00:39:01.410
 Jama值和其中的一些数据

00:38:58.260 --> 00:39:03.660
有内部类型数字的权利

00:39:01.410 --> 00:39:05.880
您会看到他们正在记录和

00:39:03.660 --> 00:39:07.650
他们通常没有任何记录

00:39:05.880 --> 00:39:10.200
转化，如果您实际上是否

00:39:07.650 --> 00:39:12.990
看看这里，这个方法有一个

00:39:10.200 --> 00:39:16.530
 double的签名和一个数组

00:39:12.990 --> 00:39:18.990
加倍，所以我们甚至都不会像

00:39:16.530 --> 00:39:20.730
两个物体然后对你施展

00:39:18.990 --> 00:39:23.430
可以正常使用您可以提供的代码

00:39:20.730 --> 00:39:25.410
您的Java代码到其他程序

00:39:23.430 --> 00:39:27.330
语言，您可以使用程序

00:39:25.410 --> 00:39:30.390
现在到Java中的其他语言

00:39:27.330 --> 00:39:34.200
代码通常不是那么神奇

00:39:30.390 --> 00:39:36.270
我会停止这个，然后我们会尽快

00:39:34.200 --> 00:39:38.340
回去展示几张幻灯片

00:39:36.270 --> 00:39:40.350
关于这个权利我们的JavaScript 

00:39:38.340 --> 00:39:41.790
图表的兼容性，如果您

00:39:40.350 --> 00:39:43.830
跟随现代JavaScript开发

00:39:41.790 --> 00:39:46.440
语言有标准

00:39:43.830 --> 00:39:49.770
不断发展，因此我们处于可计算性

00:39:46.440 --> 00:39:51.020
类似于普通音符的水平

00:39:49.770 --> 00:39:54.530
浏览器

00:39:51.020 --> 00:39:56.480
包括即将到来的2019马术之旅

00:39:54.530 --> 00:39:58.340
起草还没有开始，但是我们

00:39:56.480 --> 00:39:59.660
兼容，因为我们不需要

00:39:58.340 --> 00:40:02.740
手动将javascript转换为

00:39:59.660 --> 00:40:05.600
字节码，我们只需要一个解释器

00:40:02.740 --> 00:40:07.790
我们的javascript超级快

00:40:05.600 --> 00:40:09.530
比以前更快

00:40:07.790 --> 00:40:12.740
可以在

00:40:09.530 --> 00:40:15.170
 JVM（例如，如果您使用阿司匹林） 

00:40:12.740 --> 00:40:18.680
我们的JavaScript实际上是一点

00:40:15.170 --> 00:40:20.210
在峰值性能下比v8慢

00:40:18.680 --> 00:40:22.070
很遗憾，但我们会到达那里

00:40:20.210 --> 00:40:24.050
问题团队致力于做gravia 

00:40:22.070 --> 00:40:26.450
所有班级中最佳的运行时间

00:40:24.050 --> 00:40:29.930
支持的语言，因此我们希望成为

00:40:26.450 --> 00:40:32.210
最快的红宝石最快的python 

00:40:29.930 --> 00:40:35.450
 jvm语言最快的运行时间

00:40:32.210 --> 00:40:38.869
等等，您也可以将其用作

00:40:35.450 --> 00:40:43.840
 Java jar文件和插件的集合

00:40:38.869 --> 00:40:43.840
将它们放入正常的开放JDK流程中

00:40:44.200 --> 00:40:49.100
老实说语言前景

00:40:47.420 --> 00:40:51.260
利亚姆会在场上表现最好

00:40:49.100 --> 00:40:53.330
地面vm编译器的松露

00:40:51.260 --> 00:40:55.760
运行时需要从

00:40:53.330 --> 00:40:57.980
来自编译器的某些内在函数和

00:40:55.760 --> 00:41:01.880
某些优化，其中

00:40:57.980 --> 00:41:03.980
编译器意外提供了惊喜

00:41:01.880 --> 00:41:06.260
惊喜和其他编译器没有

00:41:03.980 --> 00:41:08.540
提供，但他们可以写和其他

00:41:06.260 --> 00:41:10.340
 JVM scoot提供JVM Sai接口

00:41:08.540 --> 00:41:12.980
也许，他们将能够工作

00:41:10.340 --> 00:41:15.890
与地面编译器，以便您可以运行

00:41:12.980 --> 00:41:18.500
咆哮VMs JavaScript引擎

00:41:15.890 --> 00:41:20.030
普通的JDK没有其他问题

00:41:18.500 --> 00:41:22.550
我认为有些本地语言

00:41:20.030 --> 00:41:24.590
可能无法很好运行的零件

00:41:22.550 --> 00:41:27.920
这个设置还可以，但是我们不同

00:41:24.590 --> 00:41:33.680
 Ruby的兼容阶段

00:41:27.920 --> 00:41:36.080
快，我们的Python快

00:41:33.680 --> 00:41:38.630
最年轻，所以可能还没有

00:41:36.080 --> 00:41:40.850
速度非常快，我们大部分时间都在工作

00:41:38.630 --> 00:41:43.010
关于回声的兼容性

00:41:40.850 --> 00:41:45.380
系统专门用于运行机器

00:41:43.010 --> 00:41:49.460
学习工作量我知道

00:41:45.380 --> 00:41:51.350
那里有一个开发商的机器

00:41:49.460 --> 00:41:53.780
是我们的某些补丁版本

00:41:51.350 --> 00:41:58.220
 Python实现和numpy在哪里

00:41:53.780 --> 00:42:00.619
某些特定的工作量实际上可以正常工作

00:41:58.220 --> 00:42:02.319
我们正在那里取得进展，但是如果您

00:42:00.619 --> 00:42:04.479
想尝试我们的Python 

00:42:02.319 --> 00:42:06.640
请睁开眼睛，保持

00:42:04.479 --> 00:42:09.249
您的期望达到合理水平

00:42:06.640 --> 00:42:10.599
我不想告诉你我们的专利

00:42:09.249 --> 00:42:12.249
很棒，然后您将尝试

00:42:10.599 --> 00:42:15.069
灰心丧气，永远不会尝试

00:42:12.249 --> 00:42:18.669
再次尝试，但答应我尝试

00:42:15.069 --> 00:42:21.519
明年再来一次哦，好赌

00:42:18.669 --> 00:42:23.709
您将获得所需的工具，因为一切

00:42:21.519 --> 00:42:26.619
我们只是树木，您可以获得

00:42:23.709 --> 00:42:28.900
可以使用旧语言

00:42:26.619 --> 00:42:31.059
不需要特别的开发人员

00:42:28.900 --> 00:42:33.849
任何特定语言的工具

00:42:31.059 --> 00:42:35.890
因为到平台的运行时

00:42:33.849 --> 00:42:38.829
他们都只是口译员

00:42:35.890 --> 00:42:40.569
使用相同的API编写的

00:42:38.829 --> 00:42:42.160
可以得到你可以得到调试器

00:42:40.569 --> 00:42:45.429
得到探查器，你可以得到热量

00:42:42.160 --> 00:42:48.160
查看器免费提供一种语言，因此您

00:42:45.429 --> 00:42:51.069
可以在中使用例如chrome inspector 

00:42:48.160 --> 00:42:53.410
在浏览器中调试Ruby或Python 

00:42:51.069 --> 00:42:55.539
可以使用je visual VM找出什么

00:42:53.410 --> 00:42:57.939
发生在您的Python应用程序中

00:42:55.539 --> 00:43:00.849
什么分配内存或JavaScript 

00:42:57.939 --> 00:43:03.039
应用程序，您可以使用采样器

00:43:00.849 --> 00:43:05.410
弄清楚你需要什么时间

00:43:03.039 --> 00:43:08.559
您的程序和所有语言

00:43:05.410 --> 00:43:09.849
这些只是通过实施而获得

00:43:08.559 --> 00:43:13.209
地面上的语言

00:43:09.849 --> 00:43:17.349
练习系统，所以这是多语种

00:43:13.209 --> 00:43:19.659
 3我期待听到人们的声音

00:43:17.349 --> 00:43:22.029
尝试更多，并找到我们

00:43:19.659 --> 00:43:24.339
告诉我们需要改进的地方，但让我们

00:43:22.029 --> 00:43:28.239
谈论格兰维亚本地形象

00:43:24.339 --> 00:43:30.099
爪哇人房间里的大象

00:43:28.239 --> 00:43:32.529
生态系统最近是一个非常热门的话题

00:43:30.099 --> 00:43:36.189
越来越多的本机图像可作为

00:43:32.529 --> 00:43:37.809
早期采用者技术的作用

00:43:36.189 --> 00:43:41.349
可以提前编译您的应用程序

00:43:37.809 --> 00:43:47.259
时间到本地二进制文件你会得到什么

00:43:41.349 --> 00:43:49.659
是我的完全编译的Blob本机

00:43:47.259 --> 00:43:52.599
本机代码正确，您得到一个文件

00:43:49.659 --> 00:43:54.759
没有依赖OGG他们会

00:43:52.599 --> 00:43:57.669
仍然运行您的应用程序，它将仍然

00:43:54.759 --> 00:43:59.229
与虚拟的某些组件一起运行

00:43:57.669 --> 00:44:01.449
您期望正确的机器

00:43:59.229 --> 00:44:03.219
写你的程序，你期望

00:44:01.449 --> 00:44:05.380
运行时为您提供垃圾

00:44:03.219 --> 00:44:08.739
收藏家，您希望您的程序

00:44:05.380 --> 00:44:11.109
会像记忆无限一样工作

00:44:08.739 --> 00:44:13.150
你得到的即使在

00:44:11.109 --> 00:44:14.769
编译版本仍然是安全的

00:44:13.150 --> 00:44:15.430
执行，所以我们得到了约束检查

00:44:14.769 --> 00:44:18.280
将有

00:44:15.430 --> 00:44:23.349
否否否随机指针指向

00:44:18.280 --> 00:44:25.359
具有各自的随机存储位置

00:44:23.349 --> 00:44:27.099
没有错误或没有

00:44:25.359 --> 00:44:29.410
错误，所以通常你有

00:44:27.099 --> 00:44:32.260
预编译的JVM，然后执行

00:44:29.410 --> 00:44:33.640
您的Java代码动态地位于

00:44:32.260 --> 00:44:35.470
您在运行时加载这些类

00:44:33.640 --> 00:44:38.260
然后您及时编译它们

00:44:35.470 --> 00:44:40.839
因此，使用本机图像可以

00:44:38.260 --> 00:44:43.960
你只能得到一个预编译的blob吗

00:44:40.839 --> 00:44:45.970
就像这样，我们看到了

00:44:43.960 --> 00:44:47.970
这些课程实际上就是

00:44:45.970 --> 00:44:50.950
将会执行的字节码

00:44:47.970 --> 00:44:53.619
在您的程序中，我们会静态地

00:44:50.950 --> 00:44:56.440
分析我们发现哪些代码调用

00:44:53.619 --> 00:44:58.720
哪些代码，我们看看

00:44:56.440 --> 00:45:00.790
然后我们编译我们预初始化

00:44:58.720 --> 00:45:02.680
一些数据我们全部写入

00:45:00.790 --> 00:45:05.380
二进制格式，然后我们只提供

00:45:02.680 --> 00:45:07.660
操作系统的一些包装器

00:45:05.380 --> 00:45:09.430
能够执行，你也可以

00:45:07.660 --> 00:45:11.740
如果需要，编译为有保证的库

00:45:09.430 --> 00:45:14.470
只能是本机独立可执行文件

00:45:11.740 --> 00:45:16.210
可能会更有趣，所以

00:45:14.470 --> 00:45:18.190
这里重要的是静态

00:45:16.210 --> 00:45:20.650
分析我们看一下代码，我们

00:45:18.190 --> 00:45:23.020
进行静态分析意味着

00:45:20.650 --> 00:45:25.329
我们实际上并没有执行

00:45:23.020 --> 00:45:27.609
只要看看它，就可以确定

00:45:25.329 --> 00:45:29.920
挑战与权衡

00:45:27.609 --> 00:45:32.079
确实是我们的程序可以

00:45:29.920 --> 00:45:35.380
动态发生，例如，您可以

00:45:32.079 --> 00:45:36.690
使用反射，我们不可能

00:45:35.380 --> 00:45:39.359
找出反思电话

00:45:36.690 --> 00:45:42.430
静态上不可能总是不可能

00:45:39.359 --> 00:45:43.630
一般普遍可能

00:45:42.430 --> 00:45:46.420
你需要做的事你需要提供一些

00:45:43.630 --> 00:45:48.670
提示一些配置，说哦

00:45:46.420 --> 00:45:50.710
我要通过以下方式使用此功能

00:45:48.670 --> 00:45:52.960
反思我要修补那些课程

00:45:50.710 --> 00:45:54.730
在运行时，然后我们可以看看那些

00:45:52.960 --> 00:45:57.579
类，我们可以将它们放入

00:45:54.730 --> 00:45:59.079
最终的可执行树提供

00:45:57.579 --> 00:46:01.210
您需要编写JSON的配置

00:45:59.079 --> 00:46:04.150
文件可能会有点

00:46:01.210 --> 00:46:06.309
讨厌写JSON文件，我们知道

00:46:04.150 --> 00:46:07.960
知道但有可能

00:46:06.309 --> 00:46:11.520
所以代理配置j'ni 

00:46:07.960 --> 00:46:13.270
配置反射需要一些

00:46:11.520 --> 00:46:15.010
来自的其他配置

00:46:13.270 --> 00:46:19.210
开发人员的好处是

00:46:15.010 --> 00:46:21.609
开发人员，您是该产品的唯一所有者

00:46:19.210 --> 00:46:24.190
您可以正确运行的代码

00:46:21.609 --> 00:46:25.930
做任何你想像不到的事

00:46:24.190 --> 00:46:28.150
可以用代码做

00:46:25.930 --> 00:46:30.850
那是...的力量和特权

00:46:28.150 --> 00:46:35.710
作为开发人员，所以我们可以完全做到

00:46:30.850 --> 00:46:39.130
自从地面viim 19我们

00:46:35.710 --> 00:46:41.290
另一种提供方式

00:46:39.130 --> 00:46:44.980
配置我们可以运行你的java 

00:46:41.290 --> 00:46:46.930
通常使用Java代理和

00:46:44.980 --> 00:46:48.850
每次您通过

00:46:46.930 --> 00:46:52.960
反思会收集到

00:46:48.850 --> 00:46:55.540
信息，它将建立那些

00:46:52.960 --> 00:46:58.390
适合您的配置文件，因此您

00:46:55.540 --> 00:47:00.580
可以使用此辅助配置运行

00:46:58.390 --> 00:47:03.280
您的测试正常运行您的应用程序

00:47:00.580 --> 00:47:05.920
然后使用这些输出文件

00:47:03.280 --> 00:47:09.430
他们到编译器来构建

00:47:05.920 --> 00:47:11.530
最终映像，因此配置应用程序

00:47:09.430 --> 00:47:13.060
变得更加轻松，您仍然需要

00:47:11.530 --> 00:47:16.990
可能会耗尽所有代码路径

00:47:13.060 --> 00:47:18.640
但是如果您运行测试可能

00:47:16.990 --> 00:47:21.610
你的状态要比

00:47:18.640 --> 00:47:24.210
您只是尝试收集这些JSON文件

00:47:21.610 --> 00:47:26.830
并用手写

00:47:24.210 --> 00:47:28.900
结果结果是相当

00:47:26.830 --> 00:47:31.270
优秀的那些

00:47:28.900 --> 00:47:34.180
申请时间以毫秒为单位

00:47:31.270 --> 00:47:36.700
它可以从典型的网络开始

00:47:34.180 --> 00:47:39.370
在不到20毫秒内

00:47:36.700 --> 00:47:41.500
是本机的启动号

00:47:39.370 --> 00:47:43.300
要重写的语言

00:47:41.500 --> 00:47:46.030
您的系统并获得更好的启动

00:47:43.300 --> 00:47:48.700
也许您不应该运行时内存

00:47:46.030 --> 00:47:51.220
开销也相当有限的东西

00:47:48.700 --> 00:47:52.960
是我们不需要机械来装载

00:47:51.220 --> 00:47:55.660
动态地有额外的类

00:47:52.960 --> 00:47:57.940
那里没有编译器，所以我们不需要

00:47:55.660 --> 00:47:59.950
初始化所有这些数据结构，以便

00:47:57.940 --> 00:48:02.920
我们可以只使用一些

00:47:59.950 --> 00:48:04.570
可用的兆字节内存，这是

00:48:02.920 --> 00:48:06.670
在某些情况下真的很好

00:48:04.570 --> 00:48:08.170
您干扰LS功能的服务或

00:48:06.670 --> 00:48:12.600
只是所有规模和微服务

00:48:08.170 --> 00:48:15.550
这是要注意的事情，所以

00:48:12.600 --> 00:48:17.620
 Spring 应用最重要

00:48:15.550 --> 00:48:19.870
这里的问题是，目前

00:48:17.620 --> 00:48:24.250
并非所有 Spring 应用都可以

00:48:19.870 --> 00:48:26.950
据称工作中有一些支持

00:48:24.250 --> 00:48:28.540
 Spring ，所以现在一年了

00:48:26.950 --> 00:48:31.150
自从我们宣布要获得

00:48:28.540 --> 00:48:33.130
我们一直在努力解决这个问题

00:48:31.150 --> 00:48:35.890
问题，我们正在努力并与之交谈

00:48:33.130 --> 00:48:37.780
工程师，他们做了很多

00:48:35.890 --> 00:48:38.490
编写框架代码的努力

00:48:37.780 --> 00:48:40.830
更多

00:48:38.490 --> 00:48:43.440
面向本地图像生成和

00:48:40.830 --> 00:48:46.020
支持，全力支持和

00:48:43.440 --> 00:48:48.119
即将提供更好的支持

00:48:46.020 --> 00:48:48.480
版本，我们期待着

00:48:48.119 --> 00:48:49.740
那

00:48:48.480 --> 00:48:52.500
我知道社区正在寻找

00:48:49.740 --> 00:48:55.410
转发到当前，但如果您尝试

00:48:52.500 --> 00:48:57.119
只是知道还没有完全存在

00:48:55.410 --> 00:48:58.589
您需要摆弄配置

00:48:57.119 --> 00:49:01.290
您可能需要使用某些

00:48:58.589 --> 00:49:04.680
 dravyam和字符串的版本，或

00:49:01.290 --> 00:49:08.280
入门文件正确，所以有

00:49:04.680 --> 00:49:10.530
问题，但工作仍在进行中， 

00:49:08.280 --> 00:49:13.349
到目前为止已经取得了进展， 

00:49:10.530 --> 00:49:16.410
进步将使您更进一步

00:49:13.349 --> 00:49:18.150
可以检查一下，你可以

00:49:16.410 --> 00:49:21.390
试试看，你也可以建立其他

00:49:18.150 --> 00:49:25.349
应用程序可能会有点

00:49:21.390 --> 00:49:29.280
我们正在努力工作的更轻松但 Spring 的工作

00:49:25.349 --> 00:49:31.640
正确的Windows位工作的Java 11 

00:49:29.280 --> 00:49:34.940
基于版本的作品

00:49:31.640 --> 00:49:37.980
当我们有他们时，我们将宣布他们

00:49:34.940 --> 00:49:39.390
 valium可以做更多的事情，也许有点

00:49:37.980 --> 00:49:42.900
对于Java开发人员而言，有趣程度降低了

00:49:39.390 --> 00:49:44.700
但肯定可以解决他们

00:49:42.900 --> 00:49:46.140
时间量，不想你

00:49:44.700 --> 00:49:47.940
记得地面iam是一个

00:49:46.140 --> 00:49:50.160
高性能保罗血液虚拟

00:49:47.940 --> 00:49:52.530
机器可嵌入不同

00:49:50.160 --> 00:49:54.810
应用程序，您应该尝试这样做

00:49:52.530 --> 00:49:55.619
如果你做任何事情，如果你

00:49:54.810 --> 00:49:57.900
对那个感兴趣

00:49:55.619 --> 00:50:00.080
这是一个项目，非常感谢

00:49:57.900 --> 00:50:00.080
许多

00:50:01.910 --> 00:50:08.180
您

00:50:02.650 --> 00:50:08.180
 [音乐] 

