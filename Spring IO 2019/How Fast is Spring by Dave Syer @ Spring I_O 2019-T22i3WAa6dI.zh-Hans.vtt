WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.900 --> 00:00:12.750
 [音乐] 

00:00:06.109 --> 00:00:15.510
好吧，我准备好了，谢谢

00:00:12.750 --> 00:00:16.859
真的很高兴看到这么多

00:00:15.510 --> 00:00:19.310
在一天结束时你肯定

00:00:16.859 --> 00:00:22.939
你和我一样累

00:00:19.310 --> 00:00:22.939
啤酒来了

00:00:23.940 --> 00:00:31.060
别担心，我不会，我不会留住你

00:00:28.060 --> 00:00:34.870
从你的啤酒中，所以我在

00:00:31.060 --> 00:00:39.220
去年春天我在这个房间里

00:00:34.870 --> 00:00:42.730
想想关于春天的云

00:00:39.220 --> 00:00:46.260
功能和主题出现，当我

00:00:42.730 --> 00:00:49.559
正在从事春季功能

00:00:46.260 --> 00:00:53.530
 Java的jvm的冷启动时间

00:00:49.559 --> 00:00:55.210
流程往往需要一点时间

00:00:53.530 --> 00:00:58.780
有时间开始

00:00:55.210 --> 00:01:02.110
一旦他们开始，当然是JVM 

00:00:58.780 --> 00:01:05.410
是一个很棒的地方，让您快速了解

00:01:02.110 --> 00:01:07.479
高效的代码，但创业公司有

00:01:05.410 --> 00:01:10.840
总是有点

00:01:07.479 --> 00:01:13.509
迷恋我的，所以我在那段话中

00:01:10.840 --> 00:01:15.610
去年给的有点开端

00:01:13.509 --> 00:01:18.850
我曾经做过的一些研究

00:01:15.610 --> 00:01:21.910
大概在过去一年左右，所以这

00:01:18.850 --> 00:01:24.330
是关于状态更新的话题

00:01:21.910 --> 00:01:27.909
有点像我们在这里

00:01:24.330 --> 00:01:30.640
我想你会看到我们已经做了很多

00:01:27.909 --> 00:01:41.759
在过去的12年中实际上有很多工作

00:01:30.640 --> 00:01:45.880
几个月的时间，所以您知道

00:01:41.759 --> 00:01:50.080
 JVM是一个复杂的复杂

00:01:45.880 --> 00:01:54.040
机器我不明白

00:01:50.080 --> 00:01:55.900
我的意思是我不假装没有

00:01:54.040 --> 00:01:58.060
开始尝试了解它，但是我有

00:01:55.900 --> 00:01:59.530
试图衡量它好吧，那是

00:01:58.060 --> 00:02:00.880
我一时的位置

00:01:59.530 --> 00:02:04.150
那就是我在旅途中

00:02:00.880 --> 00:02:10.239
也许有一天我真的可以

00:02:04.150 --> 00:02:12.310
贡献其他东西，但是有

00:02:10.239 --> 00:02:17.890
之间的阻抗不匹配

00:02:12.310 --> 00:02:20.890
在JVM上工作的人

00:02:17.890 --> 00:02:24.100
在雨和春天等应用上工作的人

00:02:20.890 --> 00:02:26.170
我们实际上并不共享的开发者

00:02:24.100 --> 00:02:27.970
他们所做的事情同样令人担忧

00:02:26.170 --> 00:02:31.330
但他们不知道如何构建应用

00:02:27.970 --> 00:02:32.920
我们所做的同样令人敬畏

00:02:31.330 --> 00:02:35.209
不同的方式，所以我们不知道如何

00:02:32.920 --> 00:02:38.000
 JVM正常工作，我们必须

00:02:35.209 --> 00:02:40.000
在中间相遇，所以希望你

00:02:38.000 --> 00:02:43.280
知道这会有所贡献

00:02:40.000 --> 00:02:47.299
朝着那个努力前进

00:02:43.280 --> 00:02:51.980
这当然是非常重要的

00:02:47.299 --> 00:02:55.069
其中有很多

00:02:51.980 --> 00:02:59.989
重要的工作不是我在

00:02:55.069 --> 00:03:01.790
今年的春季队，我希望

00:02:59.989 --> 00:03:03.439
其中一些受到我的影响

00:03:01.790 --> 00:03:05.720
我一直在这里

00:03:03.439 --> 00:03:09.170
所以我想带你通过

00:03:05.720 --> 00:03:10.489
旅程有点告诉你什么

00:03:09.170 --> 00:03:13.940
我一直在测量我一直在做

00:03:10.489 --> 00:03:15.829
关于JVM启动时间的大量工作，但这

00:03:13.940 --> 00:03:17.900
并不意味着没有其他

00:03:15.829 --> 00:03:19.129
我们遇到的性能和资源问题

00:03:17.900 --> 00:03:21.889
可以学习还有其他人

00:03:19.129 --> 00:03:25.250
实际上在春季工程团队

00:03:21.889 --> 00:03:28.310
做更多的运行时基准测试

00:03:25.250 --> 00:03:30.680
那些东西也很有价值

00:03:28.310 --> 00:03:31.879
我只是没有时间谈论

00:03:30.680 --> 00:03:35.420
今天的一切，我要谈谈

00:03:31.879 --> 00:03:36.769
关于我的启动时间工作，所以我要去

00:03:35.420 --> 00:03:38.930
说话，因为那是你知道这是一个

00:03:36.769 --> 00:03:41.000
痛点对每个有

00:03:38.930 --> 00:03:48.379
集成测试套件，有点

00:03:41.000 --> 00:03:51.199
有点慢，所以这对

00:03:48.379 --> 00:03:52.730
知道为什么至少不会，即使我们

00:03:51.199 --> 00:03:56.840
不能改善它，但事实证明我们可以

00:03:52.730 --> 00:03:58.790
改善它，所以请继续关注，以便

00:03:56.840 --> 00:04:01.489
谈论你知道如果你想

00:03:58.790 --> 00:04:03.680
一个讨厌的集成测试套件

00:04:01.489 --> 00:04:06.680
您希望运行速度更快是什么

00:04:03.680 --> 00:04:08.540
这就是为什么为什么它慢了什么

00:04:06.680 --> 00:04:10.430
可以吗？ 

00:04:08.540 --> 00:04:12.229
怪罪于春天

00:04:10.430 --> 00:04:13.959
我可以责怪其中的一些

00:04:12.229 --> 00:04:16.130
你可以，但不能尽你所能

00:04:13.959 --> 00:04:17.930
有时以为你知道你什么时候

00:04:16.130 --> 00:04:20.150
扯头发，你想

00:04:17.930 --> 00:04:22.820
把电脑丢到窗外

00:04:20.150 --> 00:04:24.560
可能不是春天

00:04:22.820 --> 00:04:27.110
从根本上负责

00:04:24.560 --> 00:04:29.180
我遇到的问题

00:04:27.110 --> 00:04:31.099
现在想想我能知道你站在这里吗

00:04:29.180 --> 00:04:32.919
并声称我们已经对其进行了测量

00:04:31.099 --> 00:04:35.810
我们已经尽力做到了

00:04:32.919 --> 00:04:37.750
尽我们所能改善我

00:04:35.810 --> 00:04:41.240
谈谈我使用的一些工具

00:04:37.750 --> 00:04:44.090
我做这个测量练习

00:04:41.240 --> 00:04:46.639
谈谈您拥有的各种选择

00:04:44.090 --> 00:04:48.860
如果有的话，可以改善生活

00:04:46.639 --> 00:04:53.310
这个缓慢的启动

00:04:48.860 --> 00:04:57.539
每次我给他们一些

00:04:53.310 --> 00:05:00.210
谈话我很高兴地说我必须信任

00:04:57.539 --> 00:05:03.900
不在名单上，因为每次

00:05:00.210 --> 00:05:06.389
测量可以识别的东西

00:05:03.900 --> 00:05:09.419
春季框架中有人聪明

00:05:06.389 --> 00:05:11.520
或春季B队解决了一些问题， 

00:05:09.419 --> 00:05:12.509
那我就不用说了

00:05:11.520 --> 00:05:14.520
不再

00:05:12.509 --> 00:05:15.990
但我会在其中提及一些

00:05:14.520 --> 00:05:17.580
一直以来，因为他们并不全都在

00:05:15.990 --> 00:05:19.020
生产，所以他们是新的

00:05:17.580 --> 00:05:21.210
他们可能值得知道的事情

00:05:19.020 --> 00:05:24.780
关于，所以我将谈论如何加快

00:05:21.210 --> 00:05:27.150
那个时间和开始的时间非常

00:05:24.780 --> 00:05:31.650
与整合测试相关

00:05:27.150 --> 00:05:33.870
套件，我将谈论正在进行的工作

00:05:31.650 --> 00:05:37.110
我们仍在做什么以及我们可能会做什么

00:05:33.870 --> 00:05:39.509
看到未来，所以只有几个

00:05:37.110 --> 00:05:44.190
图片开始这是现在

00:05:39.509 --> 00:05:46.979
一个超过六个月大的老

00:05:44.190 --> 00:05:51.810
你认为，但这仍然说明一个体面的

00:05:46.979 --> 00:05:55.020
故事，所以它是不同的示例应用程序

00:05:51.810 --> 00:06:00.900
它们都是相同的功能集

00:05:55.020 --> 00:06:03.479
整个春季的大nettie一个HTTP 

00:06:00.900 --> 00:06:08.370
端点，所以就像一个世界

00:06:03.479 --> 00:06:11.250
与您知道完整的HTTP集和这些

00:06:08.370 --> 00:06:13.620
从我腿上开始启动的时间

00:06:11.250 --> 00:06:19.409
在我的笔记本电脑上测得不是

00:06:13.620 --> 00:06:21.330
知道特别强大或快速或

00:06:19.409 --> 00:06:23.250
所以当我开始这些

00:06:21.330 --> 00:06:26.460
测量我们有一个可以

00:06:23.250 --> 00:06:30.090
从一千三百毫秒开始

00:06:26.460 --> 00:06:33.229
认为那是与春天2.0和

00:06:30.090 --> 00:06:36.690
我们调整了一些东西，然后

00:06:33.229 --> 00:06:39.029
 Springle 2.1我们开始看到

00:06:36.690 --> 00:06:41.009
改善，就像从

00:06:39.029 --> 00:06:44.639
 1300至少于一千二百

00:06:41.009 --> 00:06:47.639
毫秒，我可以告诉你

00:06:44.639 --> 00:06:49.020
差异，我将成为

00:06:47.639 --> 00:06:50.219
当我显示另一个时，实际上清除

00:06:49.020 --> 00:06:52.650
图片，所以我将进一步讨论

00:06:50.219 --> 00:06:56.580
后来我开始玩

00:06:52.650 --> 00:06:58.560
当时有新功能

00:06:56.580 --> 00:07:00.750
无论如何欢迎springle和春天

00:06:58.560 --> 00:07:03.030
功能性框架五

00:07:00.750 --> 00:07:05.580
定义，我将详细说明

00:07:03.030 --> 00:07:06.870
上面有一个弹簧提示视频

00:07:05.580 --> 00:07:10.680
如果您想从中学到更多

00:07:06.870 --> 00:07:14.879
 Josh和我能够运行相同的应用程序

00:07:10.680 --> 00:07:17.159
在基本上一半的时间内

00:07:14.879 --> 00:07:18.960
看起来很有希望，我看起来有点

00:07:17.159 --> 00:07:21.120
调查了更多

00:07:18.960 --> 00:07:23.819
其中一个使用的两个版本

00:07:21.120 --> 00:07:25.590
我要提到的春风

00:07:23.819 --> 00:07:28.199
稍后上铺，其中之一不使用

00:07:25.590 --> 00:07:31.800
春拍，所以如果你在

00:07:28.199 --> 00:07:34.349
现在这个差距现在几乎被消除了

00:07:31.800 --> 00:07:36.630
断掉实际上是因为弹簧靴

00:07:34.349 --> 00:07:37.530
开销，我们调查了

00:07:36.630 --> 00:07:39.210
研究了很多

00:07:37.530 --> 00:07:42.300
没有瑞典的弹簧靴

00:07:39.210 --> 00:07:44.250
春季靴子大约有15 

00:07:42.300 --> 00:07:47.819
毫秒或并非如此

00:07:44.250 --> 00:07:49.259
真的那么多，但是我的原因

00:07:47.819 --> 00:07:51.419
喜欢显示该网站是这样的

00:07:49.259 --> 00:07:56.639
这是相同的启动时间

00:07:51.419 --> 00:07:59.520
类加载器是

00:07:56.639 --> 00:08:02.069
 JVM已经预热了，所以

00:07:59.520 --> 00:08:03.960
我已经启动了应用程序，并关闭了

00:08:02.069 --> 00:08:07.169
应用程序上下文，然后启动它

00:08:03.960 --> 00:08:11.219
再次关闭运行，关闭运行，关闭运行，像

00:08:07.169 --> 00:08:12.960
那不是戏剧性的

00:08:11.219 --> 00:08:17.520
好的，如果这是一个适当的因素

00:08:12.960 --> 00:08:20.490
 10的速度更快，这告诉了我一些东西

00:08:17.520 --> 00:08:22.800
我的意思是告诉我一些有关

00:08:20.490 --> 00:08:25.550
这是方法的基本性质

00:08:22.800 --> 00:08:29.419
目前设计的JVM 

00:08:25.550 --> 00:08:32.490
它们都像此类加载一样工作

00:08:29.419 --> 00:08:39.390
像是80 90％ 

00:08:32.490 --> 00:08:41.339
启动时间是类加载，如果

00:08:39.390 --> 00:08:43.680
你从这个谈话中走了一条信息

00:08:41.339 --> 00:08:46.320
这就是类加载您得到什么

00:08:43.680 --> 00:08:50.430
因为当您加载课程时，您会得到一个

00:08:46.320 --> 00:08:52.890
功能，如果您的应用具有功能

00:08:50.430 --> 00:08:55.440
必须加载类需要一点时间

00:08:52.890 --> 00:08:56.370
有点冷的时候还可以

00:08:55.440 --> 00:08:58.920
温暖不

00:08:56.370 --> 00:09:02.579
所以有人用过开发工具

00:08:58.920 --> 00:09:04.230
通过足够的开发人员工具

00:09:02.579 --> 00:09:05.160
知道我要告诉你的意思

00:09:04.230 --> 00:09:06.490
告诉你这意味着什么

00:09:05.160 --> 00:09:09.670
基本上我们

00:09:06.490 --> 00:09:11.500
这里的开发工具只是一个温暖的JVM 

00:09:09.670 --> 00:09:13.540
在应用程序上下文中重启

00:09:11.500 --> 00:09:15.070
扔掉班级，以后再建一个新的

00:09:13.540 --> 00:09:20.260
实际上完全一样的一个

00:09:15.070 --> 00:09:25.089
我在那里做过同样的实验

00:09:20.260 --> 00:09:27.040
这个图有趣的观察

00:09:25.089 --> 00:09:29.709
的意思稍微偏离主题

00:09:27.040 --> 00:09:31.930
启动时间，但仍然存在

00:09:29.709 --> 00:09:34.390
这实际上告诉你为什么春天

00:09:31.930 --> 00:09:39.399
是两点一和两点二是

00:09:34.390 --> 00:09:43.060
好得多，所以在y轴上

00:09:39.399 --> 00:09:46.500
启动时间是相同的应用程序

00:09:43.060 --> 00:09:48.430
蓝色是从先到先的蓝色

00:09:46.500 --> 00:09:50.680
滑动到一千三百

00:09:48.430 --> 00:09:53.860
毫秒然后我要做的是

00:09:50.680 --> 00:09:58.390
压缩最大堆大小减去XMX 

00:09:53.860 --> 00:10:01.000
对100兆欧的50兆欧的10兆欧和我

00:09:58.390 --> 00:10:03.339
挤压直到你得到

00:10:01.000 --> 00:10:05.920
这个曲棍球棒，基本上

00:10:03.339 --> 00:10:08.380
除此之外，该应用程序可以启动并

00:10:05.920 --> 00:10:11.380
垃圾收集赢了，你得到了

00:10:08.380 --> 00:10:13.480
启动时出现内存不足错误

00:10:11.380 --> 00:10:15.040
尤其是对于旧版本的

00:10:13.480 --> 00:10:19.360
春天花花公子，这是一个很有特色

00:10:15.040 --> 00:10:21.910
而且曲线很陡，好吧，所以

00:10:19.360 --> 00:10:25.060
那么红色是春假二

00:10:21.910 --> 00:10:28.390
点一，那就是我们所在的地方

00:10:25.060 --> 00:10:29.800
去年十月真是太神奇了

00:10:28.390 --> 00:10:31.130
我的确有很大的不同，所以我们

00:10:29.800 --> 00:10:35.030
从下降

00:10:31.130 --> 00:10:39.740
带有Nettie的应用（大约25兆字节） 

00:10:35.030 --> 00:10:42.080
堆减少到十个甚至更少，现在

00:10:39.740 --> 00:10:43.400
在春季靴子2.2中，他们推了它

00:10:42.080 --> 00:10:45.590
非法甚至进一步

00:10:43.400 --> 00:10:49.340
所以你可以愉快地用十个腿跑

00:10:45.590 --> 00:10:52.340
你甚至可以下降到八六点

00:10:49.340 --> 00:10:53.930
你知道六六兆字节的热量

00:10:52.340 --> 00:10:57.500
仍然可以运行它不会

00:10:53.930 --> 00:11:02.300
很高兴，但是您仍然可以运行它，并且

00:10:57.500 --> 00:11:05.300
线是底部，这是我们的铺位

00:11:02.300 --> 00:11:07.550
因此启动应用程序具有功能

00:11:05.300 --> 00:11:09.410
光束定义，甚至更多

00:11:07.550 --> 00:11:10.820
令人印象深刻的权利，所以我可以开车

00:11:09.410 --> 00:11:13.220
下来真的没有那个

00:11:10.820 --> 00:11:16.100
曲棍球棒甚至有一个

00:11:13.220 --> 00:11:18.410
是-我无法检测到它，因为我无法

00:11:16.100 --> 00:11:21.890
看看跑步和跑步之间的区别

00:11:18.410 --> 00:11:23.510
没有运行就没有逐渐的变化

00:11:21.890 --> 00:11:26.480
在两者之间突然停止

00:11:23.510 --> 00:11:27.980
运行，所以有两点一

00:11:26.480 --> 00:11:30.710
弹簧是两点一弹簧B到

00:11:27.980 --> 00:11:35.330
点C及其原因

00:11:30.710 --> 00:11:37.340
信息丰富是因为好班

00:11:35.330 --> 00:11:38.990
我刚才解释的加载必须

00:11:37.340 --> 00:11:41.210
仍然发生不，你永远不会

00:11:38.990 --> 00:11:43.280
如果您预定了整个JVM，请远离人

00:11:41.210 --> 00:11:45.740
您需要开始上课

00:11:43.280 --> 00:11:47.620
应用程序在那里需要加载程序类

00:11:45.740 --> 00:11:50.840
是我们可以在框架中做的事情

00:11:47.620 --> 00:11:53.210
我们可以停止的优化

00:11:50.840 --> 00:11:55.400
垃圾收集从需要到

00:11:53.210 --> 00:11:57.760
发生了很多，实际上

00:11:55.400 --> 00:12:03.050
获得了巨大的进步

00:11:57.760 --> 00:12:07.120
 Springville 2.1和2.2，那就是

00:12:03.050 --> 00:12:09.350
用不同的方式讲那个故事，所以我

00:12:07.120 --> 00:12:12.440
没有2.2图片，但是

00:12:09.350 --> 00:12:15.290
与2.1基本相同，这是这些

00:12:12.440 --> 00:12:15.800
是由工具生成的火焰图

00:12:15.290 --> 00:12:17.990
叫

00:12:15.800 --> 00:12:20.390
水槽轮廓仪，如果

00:12:17.990 --> 00:12:23.000
任何人之前都使用过水槽轮廓仪

00:12:20.390 --> 00:12:25.490
很好，您可以将其附加到

00:12:23.000 --> 00:12:28.010
运行Java进程，几乎没有

00:12:25.490 --> 00:12:30.830
影响运行时性能，但您

00:12:28.010 --> 00:12:33.740
从中获得漂亮的漂亮火焰图

00:12:30.830 --> 00:12:35.480
喜欢免费，所以他不会，他们是

00:12:33.740 --> 00:12:37.139
不错，您可以单击它们并放大

00:12:35.480 --> 00:12:41.239
您可以在

00:12:37.139 --> 00:12:44.999
无论如何在其中输入文字，以便每个火焰都是

00:12:41.239 --> 00:12:47.759
本质上方法调用和堆栈

00:12:44.999 --> 00:12:49.109
上面是为此的嵌套方法调用

00:12:47.759 --> 00:12:50.819
方法调用一个退出， 

00:12:49.109 --> 00:12:53.999
拉那个拉那个那个

00:12:50.819 --> 00:12:56.819
火焰的宽度是多少

00:12:53.999 --> 00:13:00.059
在探查器中采样，因此大致

00:12:56.819 --> 00:13:03.179
与花费的时间成正比

00:13:00.059 --> 00:13:05.369
无论他在做什么， 

00:13:03.179 --> 00:13:08.100
这些都是在启动时，所以

00:13:05.369 --> 00:13:11.669
首先像你知道的第二

00:13:08.100 --> 00:13:12.899
应用程序的生命和重要

00:13:11.669 --> 00:13:17.730
事实是它们实际上非常相似

00:13:12.899 --> 00:13:19.470
除了这个愤怒的小红色

00:13:17.730 --> 00:13:24.059
和黄色的斑点在这里，那是什么

00:13:19.470 --> 00:13:26.939
是红色和黄色表示不是

00:13:24.059 --> 00:13:29.220
表示生气，实际上意味着不在用户中

00:13:26.939 --> 00:13:31.980
记忆，所以这是服装，这是

00:13:29.220 --> 00:13:34.739
 JVM进行垃圾收集，您可以

00:13:31.980 --> 00:13:38.129
看到春天是两点一二

00:13:34.739 --> 00:13:41.309
尖尖的，我们只是挤压那

00:13:38.129 --> 00:13:44.489
你挤压到更远

00:13:41.309 --> 00:13:50.129
曲棍球棒走了就是这样

00:13:44.489 --> 00:13:54.689
我们知道很多吗？ 

00:13:50.129 --> 00:13:58.049
通过避免使用api 

00:13:54.689 --> 00:14:01.319
实际上在dDK中，因此dk有很多

00:13:58.049 --> 00:14:03.179
里面有用的东西，但是他们

00:14:01.319 --> 00:14:04.860
有时也必须非常谨慎

00:14:03.179 --> 00:14:08.910
当他们必须让你知道你做的时候

00:14:04.860 --> 00:14:15.059
让我们说类东西的方法调用

00:14:08.910 --> 00:14:18.989
获取声明的方法，其中列出了所有方法

00:14:15.059 --> 00:14:21.539
类中方法的拍手声

00:14:18.989 --> 00:14:22.980
为您准备的副本，在那里

00:14:21.539 --> 00:14:24.720
垃圾来自所以有一个

00:14:22.980 --> 00:14:26.579
每次上课时不要喝咖啡

00:14:24.720 --> 00:14:29.970
获得云方法，您可以获得额外收益

00:14:26.579 --> 00:14:32.699
复制并堆积垃圾，如果可以的话

00:14:29.970 --> 00:14:36.089
避免这样做，我们发现了几个

00:14:32.699 --> 00:14:37.649
春季大的方法2.1 2.2如果

00:14:36.089 --> 00:14:39.389
你可以避免这样做，你可以避免

00:14:37.649 --> 00:14:41.569
这里的垃圾收集是

00:14:39.389 --> 00:14:45.630
那是怎么回事

00:14:41.569 --> 00:14:50.480
所以通常最好的方式是

00:14:45.630 --> 00:14:54.480
一个很好的演示，所以我要做的是

00:14:50.480 --> 00:14:55.620
可以像

00:14:54.480 --> 00:14:58.140
我只是展示而已

00:14:55.620 --> 00:15:01.670
会很高兴展示出一种真实的

00:14:58.140 --> 00:15:05.010
现在申请这是宠物诊所

00:15:01.670 --> 00:15:08.280
您已经看到了宠物Finnick每个人的

00:15:05.010 --> 00:15:10.520
看到他们的宠物清理，这有点

00:15:08.280 --> 00:15:13.680
一个真正的应用是弹簧靴

00:15:10.520 --> 00:15:16.170
他们是JPA应用程式， 

00:15:13.680 --> 00:15:19.530
像三个实体或类似的东西

00:15:16.170 --> 00:15:23.280
并以百里香叶作为UI 

00:15:19.530 --> 00:15:27.080
数据库，这还可以，所以这是宠物

00:15:23.280 --> 00:15:31.430
春季项目负责人的诊所

00:15:27.080 --> 00:15:34.380
我实际上会使情况变得更糟

00:15:31.430 --> 00:15:36.840
将Spring Boot降级到2.0 

00:15:34.380 --> 00:15:41.310
您可以看到变化是多么巨大

00:15:36.840 --> 00:15:43.890
所以这甚至可能会重建

00:15:41.310 --> 00:15:45.480
很高兴，然后我要进入我的

00:15:43.890 --> 00:15:47.700
宠物诊所的应用程序是

00:15:45.480 --> 00:15:51.380
应用只是标准弹簧深

00:15:47.700 --> 00:15:53.430
很少的代码作为

00:15:51.380 --> 00:15:57.300
 Java应用程序

00:15:53.430 --> 00:15:58.710
而且我已经为

00:15:57.300 --> 00:16:00.770
这在IDE中，所以给了我一个

00:15:58.710 --> 00:16:05.610
选择

00:16:00.770 --> 00:16:08.280
这是我笨拙的笔记本电脑，这是我的

00:16:05.610 --> 00:16:14.990
体验发射宠物的春天

00:16:08.280 --> 00:16:17.610
诊所98.7秒我要说98.7 

00:16:14.990 --> 00:16:22.140
感觉不错，是的，我是说人

00:16:17.610 --> 00:16:24.210
习惯了这种废话，但让我们

00:16:22.140 --> 00:16:26.190
看看会发生什么，所以我要去做

00:16:24.210 --> 00:16:31.250
我要改变的几件事

00:16:26.190 --> 00:16:31.250
这个到2.2 

00:16:31.280 --> 00:16:38.330
你只活过一次你不说我可以

00:16:34.500 --> 00:16:45.800
快照也一样

00:16:38.330 --> 00:16:49.730
帐单-看起来正确的快照

00:16:45.800 --> 00:16:54.830
我之前一样的小舞者

00:16:49.730 --> 00:16:56.150
当我经历

00:16:54.830 --> 00:16:59.080
演讲中，我将解释一些

00:16:56.150 --> 00:17:01.250
我现在正在做的事情

00:16:59.080 --> 00:17:05.350
从中排除几件事

00:17:01.250 --> 00:17:07.490
 classpath，因此宠物诊所不使用JSON 

00:17:05.350 --> 00:17:09.980
他们没有理由需要它- 

00:17:07.490 --> 00:17:11.930
在那里，我将改变

00:17:09.980 --> 00:17:14.840
从默认日志记录实现

00:17:11.930 --> 00:17:17.780
因此默认情况下， 

00:17:14.840 --> 00:17:19.790
春季靴子登录回来，我要去

00:17:17.780 --> 00:17:22.520
只是切换一下，所以我要

00:17:19.790 --> 00:17:25.120
排除这两件事，然后我

00:17:22.520 --> 00:17:27.200
会进入依赖关系

00:17:25.120 --> 00:17:36.200
每个人都跟着我在这里做什么

00:17:27.200 --> 00:17:38.150
我要插入SL f4j JDK 

00:17:36.200 --> 00:17:40.970
最快的小叶不是

00:17:38.150 --> 00:17:46.400
最好的是，这是一个糟糕的徽标jdk 

00:17:40.970 --> 00:17:48.860
日志记录，但速度更快，但不多

00:17:46.400 --> 00:17:50.660
你知道一点所以它不会

00:17:48.860 --> 00:17:52.760
差异，然后我就跑

00:17:50.660 --> 00:17:55.280
这个应用程序又可以了，所以现在我们准备好了

00:17:52.760 --> 00:17:56.540
我们将使其以Java运行

00:17:55.280 --> 00:17:57.980
这次我要去申请

00:17:56.540 --> 00:18:00.440
请选择一个称为标志

00:17:57.980 --> 00:18:02.090
因为我在上面放了一些命令行标志

00:18:00.440 --> 00:18:09.140
 JVM，我会告诉你这些是什么

00:18:02.090 --> 00:18:11.270
一分钟内准备好健康的鼻子

00:18:09.140 --> 00:18:12.740
我认为如果超过30秒

00:18:11.270 --> 00:18:15.650
几次你可能会看到两点

00:18:12.740 --> 00:18:17.820
七个二点八就可以了

00:18:15.650 --> 00:18:24.809
是男人

00:18:17.820 --> 00:18:27.049
我会说那不是我做的

00:18:24.809 --> 00:18:29.309
对，我是说我以为我只是

00:18:27.049 --> 00:18:31.559
有人提到过几次

00:18:29.309 --> 00:18:34.850
因为你可以使其更快

00:18:31.559 --> 00:18:38.729
可以使其更快，他们做到了

00:18:34.850 --> 00:18:40.499
是的，所以旗帜会升到

00:18:38.729 --> 00:18:43.229
在一分钟内滑动，所以我该怎么做， 

00:18:40.499 --> 00:18:45.419
那些东西中有多少

00:18:43.229 --> 00:18:46.950
对春天影响最大

00:18:45.419 --> 00:18:50.070
春假两点你有很大

00:18:46.950 --> 00:18:51.989
影响其中的某些功能

00:18:50.070 --> 00:18:53.609
弹簧靴也要指出

00:18:51.989 --> 00:18:58.259
我打开那里，所以我们可以有一个

00:18:53.609 --> 00:19:00.059
看，所以我怎么让它更快

00:18:58.259 --> 00:19:02.340
我做了一些课堂路径排除

00:19:00.059 --> 00:19:05.580
以后再说说细节

00:19:02.340 --> 00:19:06.899
使用春季行为上下文索引器

00:19:05.580 --> 00:19:08.549
有没有人尝试过

00:19:06.899 --> 00:19:11.899
我今天在床上睡觉，他

00:19:08.549 --> 00:19:14.369
这样做，我知道有人使用它

00:19:11.899 --> 00:19:17.190
这是一个应用程序

00:19:14.369 --> 00:19:20.190
这是一个注释处理器

00:19:17.190 --> 00:19:23.599
在春天，因为我认为四点

00:19:20.190 --> 00:19:26.129
春天对你有好处

00:19:23.599 --> 00:19:29.279
你只是把它放在课堂上

00:19:26.129 --> 00:19:31.470
生成您的组件的索引

00:19:29.279 --> 00:19:33.059
知道何时进行组件扫描及其

00:19:31.470 --> 00:19:35.369
在您的所有包裹中查找

00:19:33.059 --> 00:19:38.190
组件注释的应用

00:19:35.369 --> 00:19:39.989
它只是做一个索引，所以它

00:19:38.190 --> 00:19:43.739
不必再做一次

00:19:39.989 --> 00:19:45.149
春季从来没有做得很好

00:19:43.739 --> 00:19:47.009
你应该说很多工作

00:19:45.149 --> 00:19:48.419
组件扫描昂贵的组件

00:19:47.009 --> 00:19:51.259
东西很贵，所以我们称之为

00:19:48.419 --> 00:19:54.599
在那里向他们证明不是

00:19:51.259 --> 00:19:57.419
豆越多，速度就快一点

00:19:54.599 --> 00:20:00.419
你有更多的影响力

00:19:57.419 --> 00:20:05.700
在宠物诊所，我不知道有没有

00:20:00.419 --> 00:20:08.580
一打豆顶组件就可以

00:20:05.700 --> 00:20:10.499
存在，你也许可以衡量

00:20:08.580 --> 00:20:13.200
那样的区别就是你知道

00:20:10.499 --> 00:20:15.119
 10毫秒或您想要的东西

00:20:13.200 --> 00:20:18.179
通常是10毫秒，或者

00:20:15.119 --> 00:20:20.429
肯定有一个包含10,000个bean的应用程序

00:20:18.179 --> 00:20:23.789
值得

00:20:20.429 --> 00:20:25.769
我曾经说过，这让我很伤心

00:20:23.789 --> 00:20:26.480
说如果您不使用执行器

00:20:25.769 --> 00:20:29.419
买得起坚果

00:20:26.480 --> 00:20:33.410
因为那是如果您开始使用

00:20:29.419 --> 00:20:37.450
 Spring boo 2.0中的执行器

00:20:33.410 --> 00:20:41.000
你知道超过半秒吗

00:20:37.450 --> 00:20:43.669
也许一秒钟你就知道七点八分

00:20:41.000 --> 00:20:45.200
一百毫秒，如果可以的话

00:20:43.669 --> 00:20:47.750
负担不起你，那么你知道你得到

00:20:45.200 --> 00:20:49.910
那回不过当你知道我们

00:20:47.750 --> 00:20:51.230
春天更详细地看了一下

00:20:49.910 --> 00:20:55.850
引导团队决定进行一些更改

00:20:51.230 --> 00:20:58.220
自从春天以来我们2.0 

00:20:55.850 --> 00:21:01.940
大多数网络端点不是

00:20:58.220 --> 00:21:03.679
无论如何默认情况下都没有启用

00:21:01.940 --> 00:21:05.809
实际上创建所有这些点

00:21:03.679 --> 00:21:08.330
豆，所以他们只是关闭它们， 

00:21:05.809 --> 00:21:10.460
除非他们启用，然后每

00:21:08.330 --> 00:21:12.380
问题消失了，所以我没有那样做

00:21:10.460 --> 00:21:14.750
只是对它有不同的影响

00:21:12.380 --> 00:21:17.330
我本来可能会挤在另一个附近

00:21:14.750 --> 00:21:18.710
大概二十毫秒或

00:21:17.330 --> 00:21:23.330
东西，但比它好得多

00:21:18.710 --> 00:21:26.330
是在春季新2.2，所以使用春季

00:21:23.330 --> 00:21:28.190
突破C点，不是GAA GAA I 

00:21:26.330 --> 00:21:32.419
知道所以如果你不能做到这一点，请使用两个

00:21:28.190 --> 00:21:34.850
我说的第一点还是更好

00:21:32.419 --> 00:21:38.720
认为他们也付出了很多努力

00:21:34.850 --> 00:21:41.000
改善，因此仍然有帮助，但作用不大

00:21:38.720 --> 00:21:43.630
好吧，所以你可能会得到另一个你知道的

00:21:41.000 --> 00:21:46.400
几十毫秒

00:21:43.630 --> 00:21:48.350
弹簧点配置点位置在哪里

00:21:46.400 --> 00:21:51.530
您的应用程序点属性文件是

00:21:48.350 --> 00:21:53.330
如果你知道它在哪里，你可以告诉

00:21:51.530 --> 00:21:55.160
春季靴子哪里去哪里忘了

00:21:53.330 --> 00:21:57.080
看，它不必去搜索

00:21:55.160 --> 00:21:59.690
为此，因为它将搜索

00:21:57.080 --> 00:22:01.640
你知道应用程序类型的属性

00:21:59.690 --> 00:22:03.169
应用山药在

00:22:01.640 --> 00:22:05.660
在文件系统中查找的分类器

00:22:03.169 --> 00:22:07.520
它会在子目录中查找

00:22:05.660 --> 00:22:11.570
您可以阻止它执行以节省费用

00:22:07.520 --> 00:22:13.790
我也常说一点时间

00:22:11.570 --> 00:22:16.010
如果您不使用它，请关闭它

00:22:13.790 --> 00:22:19.100
因为它是默认启用的

00:22:16.010 --> 00:22:23.540
确实花费了一些正确的MX 

00:22:19.100 --> 00:22:27.620
 MB管理器需要花费一些时间

00:22:23.540 --> 00:22:29.570
在JDK中启动，他们使

00:22:27.620 --> 00:22:31.970
在弹簧B中默认为C点

00:22:29.570 --> 00:22:33.650
您现在必须默认启用它，因此

00:22:31.970 --> 00:22:35.770
我不再需要建议

00:22:33.650 --> 00:22:38.590
但是如果他现在正在寻找

00:22:35.770 --> 00:22:40.920
天气JMX终点就是你

00:22:38.590 --> 00:22:42.970
需要重新打开它们

00:22:40.920 --> 00:22:45.910
春天发生的另一件事

00:22:42.970 --> 00:22:49.030
 Break 3.2是懒惰的光束定义，所以

00:22:45.910 --> 00:22:53.380
这一直是春天的特征

00:22:49.030 --> 00:22:56.440
该框架有效，因为我认为

00:22:53.380 --> 00:22:58.600
春天-有人知道

00:22:56.440 --> 00:23:01.540
在那个懒惰的留置权定义之前

00:22:58.600 --> 00:23:07.330
您曾经懒惰的XML 

00:23:01.540 --> 00:23:10.120
在XML上等于true，但不是

00:23:07.330 --> 00:23:13.120
真的用了很多，但是没有

00:23:10.120 --> 00:23:16.120
很多点，因为尤其是在旧的

00:23:13.120 --> 00:23:19.210
您拥有该XML文件的日子

00:23:16.120 --> 00:23:21.760
 X取决于Y，Y取决于

00:23:19.210 --> 00:23:23.140
一切都取决于某件事，即使

00:23:21.760 --> 00:23:25.360
如果他们一早就懒惰

00:23:23.140 --> 00:23:27.760
创建整个对象之一

00:23:25.360 --> 00:23:30.910
图必须创建，所以没有

00:23:27.760 --> 00:23:34.840
有很多要点，但我注意到一件事

00:23:30.910 --> 00:23:36.940
这项工作是因为春季跳动

00:23:34.840 --> 00:23:38.380
配置，任您选择

00:23:36.940 --> 00:23:39.810
就像你在上面放了一些东西

00:23:38.380 --> 00:23:42.370
你会被击败的classpath 

00:23:39.810 --> 00:23:43.540
因为您知道其他模板

00:23:42.370 --> 00:23:44.740
上课更快，你会休息

00:23:43.540 --> 00:23:46.810
模板实际上不是休息

00:23:44.740 --> 00:23:50.320
模板休息模板生成器，但是

00:23:46.810 --> 00:23:50.940
你知道我的意思，如果你不知道

00:23:50.320 --> 00:23:53.620
用它

00:23:50.940 --> 00:23:56.650
当没有人拥有时，那是一种浪费

00:23:53.620 --> 00:23:59.350
加载该类的类加载是

00:23:56.650 --> 00:24:03.100
昂贵的人无须创造你

00:23:59.350 --> 00:24:05.590
知道实例，所以我们看着那个

00:24:03.100 --> 00:24:07.990
我们认为这很有趣

00:24:05.590 --> 00:24:09.700
要做的只是设置所有光束

00:24:07.990 --> 00:24:12.880
懒惰的定义，看看什么

00:24:09.700 --> 00:24:15.480
发生了什么事，我想

00:24:12.880 --> 00:24:17.980
在宠物诊所里

00:24:15.480 --> 00:24:19.990
大概一秒钟好一点

00:24:17.980 --> 00:24:22.480
比一点一点一点

00:24:19.990 --> 00:24:25.450
你知道一千多秒

00:24:22.480 --> 00:24:27.910
延迟光束定义的毫秒数

00:24:25.450 --> 00:24:29.830
你可能最终会知道的东西

00:24:27.910 --> 00:24:32.380
假设您知道健康

00:24:29.830 --> 00:24:34.150
如果存在端点，则运行状况端点存在

00:24:32.380 --> 00:24:37.620
您将需要ping通

00:24:34.150 --> 00:24:40.630
它，然后它将被懒惰地创建

00:24:37.620 --> 00:24:41.070
现在春季组队非常明智

00:24:40.630 --> 00:24:42.539
那里

00:24:41.070 --> 00:24:44.460
我认为Andy为此写了一个博客， 

00:24:42.539 --> 00:24:46.769
指出他们宣布这一点时

00:24:44.460 --> 00:24:48.929
功能可能不是你

00:24:46.769 --> 00:24:49.649
想要生产，因为

00:24:48.929 --> 00:24:52.440
生产

00:24:49.649 --> 00:24:54.899
如果出现以下情况，您宁愿启动失败

00:24:52.440 --> 00:24:57.090
可能会成为一个问题

00:24:54.899 --> 00:25:01.169
我还是愿意这样做，所以我们离开了

00:24:57.090 --> 00:25:02.639
默认为不偷懒，但在

00:25:01.169 --> 00:25:04.710
适时的开发时间

00:25:02.639 --> 00:25:06.480
进行变更测试并进行变更

00:25:04.710 --> 00:25:07.769
这就是改变的全部

00:25:06.480 --> 00:25:09.419
然后，您想要的速度与

00:25:07.769 --> 00:25:12.389
可能，当你写那些

00:25:09.419 --> 00:25:14.549
集成测试（如果您仅使用

00:25:12.389 --> 00:25:16.679
你知道的一小部分

00:25:14.549 --> 00:25:18.059
该应用程序为什么需要

00:25:16.679 --> 00:25:20.070
麻烦加载其他所有豆子

00:25:18.059 --> 00:25:23.629
那绝对是一个很好的选择

00:25:20.070 --> 00:25:27.600
开发时间要做的事情

00:25:23.629 --> 00:25:30.090
另一件事已经改善，但

00:25:27.600 --> 00:25:34.110
不至于我可以跨越这个范围

00:25:30.090 --> 00:25:36.450
脱掉胖子罐子，撒上胖子爵士乐

00:25:34.110 --> 00:25:39.840
辉煌就在那里

00:25:36.450 --> 00:25:41.070
采取可执行的二进制代码

00:25:39.840 --> 00:25:44.399
随便把它给别人

00:25:41.070 --> 00:25:48.179
并说这是jar文件运行它，但是如果

00:25:44.399 --> 00:25:51.570
你做贾巴尔-罐子它有点慢

00:25:48.179 --> 00:25:54.570
比您解压缩然后再使用Java的情况- 

00:25:51.570 --> 00:25:57.809
 CP创建了类路径，我的意思是你知道

00:25:54.570 --> 00:25:59.700
指定主域类

00:25:57.809 --> 00:26:02.669
由于我需要间接

00:25:59.700 --> 00:26:05.190
 Java-约翰必须进入罐子

00:26:02.669 --> 00:26:07.080
找到罐子，所以只有你

00:26:05.190 --> 00:26:10.919
知道罐子里的东西有点

00:26:07.080 --> 00:26:12.330
效率低下，只有一种改变

00:26:10.919 --> 00:26:14.399
他们提出了春季大两点

00:26:12.330 --> 00:26:15.929
两个改善了这是哪个

00:26:14.399 --> 00:26:18.779
如果您用于

00:26:15.929 --> 00:26:20.340
实例Cloud Foundry，因为如何

00:26:18.779 --> 00:26:22.500
铸造他们所拥有的

00:26:20.340 --> 00:26:24.509
已经为您打开了包装

00:26:22.500 --> 00:26:27.120
但他们不是你，他们没有使用

00:26:24.509 --> 00:26:28.919
您购物车中的主要方法

00:26:27.120 --> 00:26:31.350
他们正在使用弹簧的应用程序

00:26:28.919 --> 00:26:33.899
启动ja启动器，这样

00:26:31.350 --> 00:26:36.840
现在我们没有的情况下我们不去

00:26:33.899 --> 00:26:39.539
罐子罐子，我们直接去文件

00:26:36.840 --> 00:26:41.429
系统，这是一个改进

00:26:39.539 --> 00:26:45.830
实际上在春假期间-所以第二点

00:26:41.429 --> 00:26:47.420
这是打开包装的罐子总是更快

00:26:45.830 --> 00:26:51.910
它的

00:26:47.420 --> 00:26:54.799
如果您使用

00:26:51.910 --> 00:27:00.260
应用拥有自己的主类而不是

00:26:54.799 --> 00:27:02.059
 Spring Boop好的，这是我的地方

00:27:00.260 --> 00:27:04.160
如果有的话会一直流连忘返

00:27:02.059 --> 00:27:05.480
他们始终是观众中的JVM专家

00:27:04.160 --> 00:27:07.309
之后来找我说不要

00:27:05.480 --> 00:27:14.360
去做

00:27:07.309 --> 00:27:15.590
但我还是做对了，因为你好

00:27:14.360 --> 00:27:18.410
知道你看到技术发生了什么

00:27:15.590 --> 00:27:21.140
诊所吧，所以如果您使用

00:27:18.410 --> 00:27:24.500
一些额外的标志-没有验证是真的

00:27:21.140 --> 00:27:28.010
好人不仅会接受

00:27:24.500 --> 00:27:33.890
你知道几微秒

00:27:28.010 --> 00:27:36.770
就像任何应用程式的30％一样，将会是30％40％ 

00:27:33.890 --> 00:27:40.400
如果您只是，则可以更快-无需验证

00:27:36.770 --> 00:27:43.880
这意味着它允许JVM 

00:27:40.400 --> 00:27:45.490
只是加载类数据并读取

00:27:43.880 --> 00:27:51.160
字节读取字节码不带

00:27:45.490 --> 00:27:53.150
检查它是有效的字节码，以便

00:27:51.160 --> 00:27:54.679
你知道也许你不想做

00:27:53.150 --> 00:27:56.929
在生产中很好是你的

00:27:54.679 --> 00:27:59.540
选择，但你知道我要去做

00:27:56.929 --> 00:28:01.520
我刚刚下载的笔记本电脑上的IDE 

00:27:59.540 --> 00:28:03.650
我知道的Java文件来自我知道

00:28:01.520 --> 00:28:06.140
字节很好，您不需要

00:28:03.650 --> 00:28:09.710
告诉我字节很好

00:28:06.140 --> 00:28:11.480
很快就可以了，那就是那个

00:28:09.710 --> 00:28:12.320
你可以条件你可以

00:28:11.480 --> 00:28:14.179
你知道你是否正在跑步

00:28:12.320 --> 00:28:15.440
容器，如果你建立了罐子

00:28:14.179 --> 00:28:17.360
建立了你知道里面有什么容器

00:28:15.440 --> 00:28:19.460
它可以验证一切

00:28:17.360 --> 00:28:21.620
提前那是我不认为的

00:28:19.460 --> 00:28:23.150
坦白说，这是一个糟糕的选择，但是

00:28:21.620 --> 00:28:25.460
确实发生的最糟糕的事情是

00:28:23.150 --> 00:28:29.150
你知道你有没有不好

00:28:25.460 --> 00:28:31.000
像代理这样的字节码会产生一些问题

00:28:29.150 --> 00:28:35.090
不在您控制范围内的字节码

00:28:31.000 --> 00:28:36.500
 JVM将崩溃，您知道它只会

00:28:35.090 --> 00:28:39.590
该过程将消失， 

00:28:36.500 --> 00:28:43.820
您将无法获得任何信息

00:28:39.590 --> 00:28:45.919
发生了，所以如果你准备面对

00:28:43.820 --> 00:28:49.340
这样的结果，那么你可以做到

00:28:45.919 --> 00:28:53.270
玩另一场比赛

00:28:49.340 --> 00:28:57.559
与编译器的JIT编译器，所以在

00:28:53.270 --> 00:28:59.340
 JVM在运行时会进行优化

00:28:57.559 --> 00:29:00.930
高度优化

00:28:59.340 --> 00:29:04.860
将字节码变成机器

00:29:00.930 --> 00:29:06.960
代码，您可以控制多少工作

00:29:04.860 --> 00:29:10.160
它与各种

00:29:06.960 --> 00:29:12.870
这个说我的命令行选项

00:29:10.160 --> 00:29:15.890
不知道细节停在一些

00:29:12.870 --> 00:29:18.660
正确的水平不要全力以赴

00:29:15.890 --> 00:29:20.160
对设置有很大影响

00:29:18.660 --> 00:29:22.890
意味着它不需要做很多事情

00:29:20.160 --> 00:29:25.950
的代码路径分析

00:29:22.890 --> 00:29:28.080
在启动时运行，这与另一个

00:29:25.950 --> 00:29:32.010
百分比的事情大约是另外10％ 

00:29:28.080 --> 00:29:34.650
所以这两件事之间30 

00:29:32.010 --> 00:29:36.480
 50％的改善几乎可以

00:29:34.650 --> 00:29:38.610
应用程序，所以我可以做到这一点

00:29:36.480 --> 00:29:41.310
春天做2.0，你会看到一个

00:29:38.610 --> 00:29:43.410
实际上会有很大的改善

00:29:41.310 --> 00:29:47.340
从9秒下降到你

00:29:43.410 --> 00:29:50.010
知道五年半左右，但

00:29:47.340 --> 00:29:52.200
还有另外两个半秒

00:29:50.010 --> 00:29:54.750
其他所有的东西都可以吗

00:29:52.200 --> 00:29:56.940
是所有其他东西，在

00:29:54.750 --> 00:30:01.170
这张幻灯片的底部是我

00:29:56.940 --> 00:30:03.330
还没有做，所以我会自动配置

00:30:01.170 --> 00:30:04.980
来吧，我会回到那就是你

00:30:03.330 --> 00:30:06.540
可以在enable auto吃饭

00:30:04.980 --> 00:30:08.760
配置是一个不错的弹簧靴

00:30:06.540 --> 00:30:11.580
我喜欢使用的应用程序是你

00:30:08.760 --> 00:30:12.780
知道花鸟以一种方式

00:30:11.580 --> 00:30:15.360
不必去想什么

00:30:12.780 --> 00:30:18.420
发生了，但是对某些人来说

00:30:15.360 --> 00:30:21.300
不喜欢那样，这确实意味着他

00:30:18.420 --> 00:30:23.280
可能包括一些东西功能

00:30:21.300 --> 00:30:24.780
您没有使用，如果可以的话

00:30:23.280 --> 00:30:27.750
单独选择自动

00:30:24.780 --> 00:30:29.910
您可能会有的配置

00:30:27.750 --> 00:30:31.860
性能取决于更好的一面

00:30:29.910 --> 00:30:33.870
您的应用取决于您知道哪个

00:30:31.860 --> 00:30:36.740
他正在使用的那些，以及是否

00:30:33.870 --> 00:30:38.910
启动时需要的东西

00:30:36.740 --> 00:30:41.190
功能存在定义也

00:30:38.910 --> 00:30:44.250
非常有趣，我告诉你

00:30:41.190 --> 00:30:45.750
红色斑点明显快于

00:30:44.250 --> 00:30:49.050
蓝野猪是第一但第一

00:30:45.750 --> 00:30:51.420
首先滑动图片不清晰

00:30:49.050 --> 00:30:52.950
我不再，所以我喜欢功能性的存在

00:30:51.420 --> 00:30:55.230
定义，我将向您详细介绍

00:30:52.950 --> 00:30:58.980
他们以后，但不一定

00:30:55.230 --> 00:31:00.120
改善创业的唯一途径

00:30:58.980 --> 00:31:03.630
性能，他们是一个

00:31:00.120 --> 00:31:05.910
重大的

00:31:03.630 --> 00:31:07.920
编写一只鸟并进行实际转换

00:31:05.910 --> 00:31:12.870
所有的感觉配置到功能

00:31:07.920 --> 00:31:15.230
不便宜也不容易，而且反过来

00:31:12.870 --> 00:31:18.720
在方括号中，我将构建本机图像

00:31:15.230 --> 00:31:22.110
您可能听说过咆哮的虚拟机

00:31:18.720 --> 00:31:23.880
他们刚刚发布了ga版本19.0 

00:31:22.110 --> 00:31:26.730
 Ralphie并具有此新功能，其中

00:31:23.880 --> 00:31:29.730
您可以使用Java程序进行编译

00:31:26.730 --> 00:31:33.210
像使用go一样将其转换为二进制图像

00:31:29.730 --> 00:31:35.550
说谎或生锈或其他东西

00:31:33.210 --> 00:31:38.400
您创建的图像很小

00:31:35.550 --> 00:31:41.750
相比于

00:31:38.400 --> 00:31:44.990
大型JVM，它们很快启动，因此

00:31:41.750 --> 00:31:46.679
那可能很有趣， 

00:31:44.990 --> 00:31:50.370
于尔根今天早上提到了它

00:31:46.679 --> 00:31:52.080
我们已经肯定会

00:31:50.370 --> 00:31:54.300
用spring应用程序做到这一点

00:31:52.080 --> 00:31:58.679
可能有一些限制，但没有

00:31:54.300 --> 00:32:00.870
太繁重但是有两个

00:31:58.679 --> 00:32:02.190
进行中的方式放在方括号中

00:32:00.870 --> 00:32:03.660
我认为没有人真的准备好

00:32:02.190 --> 00:32:06.950
今年开始生产， 

00:32:03.660 --> 00:32:10.260
本机图像功能实际上不是

00:32:06.950 --> 00:32:12.150
 GA还是这样，所以他们释放了松鼠

00:32:10.260 --> 00:32:14.280
 VM，他们拍摄了本机映像

00:32:12.150 --> 00:32:16.950
在最后一刻精选出来，所以他们

00:32:14.280 --> 00:32:22.679
留在他们称之为“开发人员预览”中

00:32:16.950 --> 00:32:24.270
所以不是GAA，所以另一个

00:32:22.679 --> 00:32:27.000
摘要屏幕，然后基本上是您

00:32:24.270 --> 00:32:28.440
可以离开还是去睡觉我

00:32:27.000 --> 00:32:29.700
别以为啤酒还没有准备好

00:32:28.440 --> 00:32:33.450
如果您想了解更多，请坚持

00:32:29.700 --> 00:32:35.640
关于细节，所以春天是春天

00:32:33.450 --> 00:32:37.350
总是很轻巧

00:32:35.640 --> 00:32:40.950
我上次在演示中所做的一件事

00:32:37.350 --> 00:32:43.140
那一年我只是被剥夺了

00:32:40.950 --> 00:32:44.640
从春季开始申请

00:32:43.140 --> 00:32:46.140
离开一些功能带走养活他们

00:32:44.640 --> 00:32:48.990
或带走更多带走更多，直到

00:32:46.140 --> 00:32:50.250
那只是春天，只是春天的开始

00:32:48.990 --> 00:32:52.920
一无所有

00:32:50.250 --> 00:32:56.010
我知道新业务还是很多

00:32:52.920 --> 00:32:57.660
逻辑上没有任何东西，而且速度非常快

00:32:56.010 --> 00:33:00.690
率，我的意思是就像你可以开始一个春天

00:32:57.660 --> 00:33:04.470
您知道10岁以下的应用程序上下文

00:33:00.690 --> 00:33:06.240
毫秒没什么，所以春天是

00:33:04.470 --> 00:33:09.600
本身就很轻巧

00:33:06.240 --> 00:33:11.160
你用春天做，你知道为什么

00:33:09.600 --> 00:33:13.140
这就是为什么你使用它

00:33:11.160 --> 00:33:16.200
所以这就是为什么你想成为那个

00:33:13.140 --> 00:33:18.300
一个人在这里，但我们确实在乎

00:33:16.200 --> 00:33:19.860
性能很好吧，这不是

00:33:18.300 --> 00:33:22.740
对我来说我是新事物

00:33:19.860 --> 00:33:25.020
多年来迷恋这个

00:33:22.740 --> 00:33:27.300
我们做出了一些真正令人惊奇的事情

00:33:25.020 --> 00:33:29.580
去年取得了进展，但我们已经

00:33:27.300 --> 00:33:31.230
一直在乎

00:33:29.580 --> 00:33:33.450
有很多可选功能

00:33:31.230 --> 00:33:35.940
功能是需要

00:33:33.450 --> 00:33:38.030
已加载，因此如果您不使用它们

00:33:35.940 --> 00:33:40.470
不会花你任何钱

00:33:38.030 --> 00:33:44.550
我提到的战争开支爆炸

00:33:40.470 --> 00:33:46.200
我已经尽力寻找

00:33:44.550 --> 00:33:47.430
 tomcat Jesse和

00:33:46.200 --> 00:33:50.700
因为我知道人们有

00:33:47.430 --> 00:33:54.990
我认为观点差不多

00:33:50.700 --> 00:33:57.870
有奖，但是你不知道

00:33:54.990 --> 00:34:01.230
非常像它的边缘，特别是

00:33:57.870 --> 00:34:03.900
 tomcat 9这样最新

00:34:01.230 --> 00:34:06.420
版本的tom在启动时不能做不到

00:34:03.900 --> 00:34:07.590
比他们过去的习惯

00:34:06.420 --> 00:34:12.210
之间的差异很小

00:34:07.590 --> 00:34:14.820
服务器容器Nettie快一点

00:34:12.210 --> 00:34:16.740
在启动时，但是你知道你在说话

00:34:14.820 --> 00:34:18.659
你不说话约50毫秒

00:34:16.740 --> 00:34:19.860
关于，这是一个常数，不是

00:34:18.659 --> 00:34:21.899
会上升或下降的东西

00:34:19.860 --> 00:34:23.820
取决于你有多少豆子

00:34:21.899 --> 00:34:26.970
所以实际上并没有那么多

00:34:23.820 --> 00:34:31.950
区别，但实际上这就是

00:34:26.970 --> 00:34:33.810
更多功能，更多类加载90 

00:34:31.950 --> 00:34:35.580
百分之80 90 

00:34:33.810 --> 00:34:36.990
创业是穿上班服的，所以

00:34:35.580 --> 00:34:39.030
那就是你要去的地方

00:34:36.990 --> 00:34:42.480
差异功能存在定义

00:34:39.030 --> 00:34:44.520
我应该说很有趣，我改变了

00:34:42.480 --> 00:34:46.169
手，但也许我不是

00:34:44.520 --> 00:34:48.389
有趣，但他们不会

00:34:46.169 --> 00:34:51.360
一次解决您的问题

00:34:48.389 --> 00:34:53.550
认为他们将是下一个

00:34:51.360 --> 00:34:55.860
下一步，但我不确定是否很好

00:34:53.550 --> 00:34:57.180
他们在那里，有一个

00:34:55.860 --> 00:34:58.740
选项，我们可以测量它，但我不是

00:34:57.180 --> 00:35:01.260
确保这真的很有趣

00:34:58.740 --> 00:35:03.510
无论如何，我可以在一天结束时开始

00:35:01.260 --> 00:35:06.570
一个带有HTTP的春季食品应用程序

00:35:03.510 --> 00:35:08.740
端点全栈JSON呈现

00:35:06.570 --> 00:35:10.540
不到一秒钟的一切

00:35:08.740 --> 00:35:14.440
是的，使用少于十兆字节的

00:35:10.540 --> 00:35:17.339
加热才是他们的重点

00:35:14.440 --> 00:35:22.000
我一直在使用的工具

00:35:17.339 --> 00:35:24.640
基准jmh，这是唯一明智的选择

00:35:22.000 --> 00:35:27.520
用于JDK基准测试的东西

00:35:24.640 --> 00:35:30.880
微型基准框架，但最重要的是

00:35:27.520 --> 00:35:33.430
哈卢来自某处

00:35:30.880 --> 00:35:37.599
春季队率，即j单位

00:35:33.430 --> 00:35:42.160
 jmh的集成，所以不是在

00:35:37.599 --> 00:35:45.220
根据您所选择的测试方法进行测试

00:35:42.160 --> 00:35:47.589
基准，这很酷吧

00:35:45.220 --> 00:35:49.270
所以它需要您的方法进行测试

00:35:47.589 --> 00:35:52.270
本质上讲，将其变成

00:35:49.270 --> 00:35:53.890
一个基准，所以我一直都在用

00:35:52.270 --> 00:35:57.310
我显示的尺寸

00:35:53.890 --> 00:36:00.880
启动时间基本上是这样，然后

00:35:57.310 --> 00:36:03.640
在测试方法内，他们开始一个新的

00:36:00.880 --> 00:36:05.680
 JVM具有新类路径的新过程

00:36:03.640 --> 00:36:07.890
你知道我在玩

00:36:05.680 --> 00:36:10.990
我玩过不同游戏的课堂路径

00:36:07.890 --> 00:36:13.119
通过使用应用程序中的功能

00:36:10.990 --> 00:36:15.940
跳动或采取配置

00:36:13.119 --> 00:36:18.280
本质上来说，我使用了

00:36:15.940 --> 00:36:24.310
一堆东​​西异步探查器很棒

00:36:18.280 --> 00:36:25.869
你得到那些火焰图，这是一个非常

00:36:24.310 --> 00:36:28.050
有人告诉我整洁的小工具

00:36:25.869 --> 00:36:31.589
另一个非常相似的叫做

00:36:28.050 --> 00:36:35.950
诚实的剖析器，我认为这很酷，但是

00:36:31.589 --> 00:36:38.890
当我已经

00:36:35.950 --> 00:36:40.869
看到那些名望图，我需要更多

00:36:38.890 --> 00:36:42.520
有关何处的详细信息

00:36:40.869 --> 00:36:43.930
垃圾收集压力是

00:36:42.520 --> 00:36:47.290
是我发现的唯一工具

00:36:43.930 --> 00:36:49.800
可以做到的就是JMC Java 

00:36:47.290 --> 00:36:55.960
任务控制飞行控制器具有

00:36:49.800 --> 00:37:00.070
在其中具有特定视图的UI 

00:36:55.960 --> 00:37:02.349
你可以看看本地的tlad线程

00:37:00.070 --> 00:37:05.130
分配缓冲区就是这样

00:37:02.349 --> 00:37:09.430
在那些火焰图中显示出来的是

00:37:05.130 --> 00:37:12.130
一种暂时的物体

00:37:09.430 --> 00:37:13.740
搅动本质上我在堆栈中，但是

00:37:12.130 --> 00:37:17.820
他们需要成为一个

00:37:13.740 --> 00:37:19.410
在下一轮之前

00:37:17.820 --> 00:37:20.970
垃圾收集，所以你可以看到

00:37:19.410 --> 00:37:24.119
认为事情基本上发生在

00:37:20.970 --> 00:37:25.619
我创建了一个飞行控制器

00:37:24.119 --> 00:37:28.470
我不知道是否有人

00:37:25.619 --> 00:37:32.520
使用它，但您会发现很多

00:37:28.470 --> 00:37:34.260
在github中进行各种研究

00:37:32.520 --> 00:37:37.290
他们中的一个叫做春季跳动启动

00:37:34.260 --> 00:37:40.650
在我个人的github空间中， 

00:37:37.290 --> 00:37:42.599
在那儿有一个子项目

00:37:40.650 --> 00:37:45.480
实际上有一个应用程序，所以它是一个

00:37:42.599 --> 00:37:47.190
您可以使用的Spring bleed应用程序- 

00:37:45.480 --> 00:37:50.160
不是弹簧Roo，就是这样，这是一个

00:37:47.190 --> 00:37:53.400
您可以用来运行另一个的Java应用程序

00:37:50.160 --> 00:37:55.050
 jar文件，您知道它会反复运行

00:37:53.400 --> 00:37:56.369
启动它，然后停止它的样式， 

00:37:55.050 --> 00:38:00.240
停在那里，所以我可以停下来

00:37:56.369 --> 00:38:02.400
基本上是重现基准

00:38:00.240 --> 00:38:05.400
图，以便您可以获取计时器槽

00:38:02.400 --> 00:38:09.240
修复了我曾经用过的启动

00:38:05.400 --> 00:38:12.089
我的东西叫做春天大

00:38:09.240 --> 00:38:15.180
瘦启动器，我用它来计算

00:38:12.089 --> 00:38:17.010
从根本上来说是类路径

00:38:15.180 --> 00:38:20.040
最初写成是

00:38:17.010 --> 00:38:21.390
包装罐子的另一种方法

00:38:20.040 --> 00:38:24.650
文件，以便它们很薄，但

00:38:21.390 --> 00:38:27.240
可执行文件，它也具有此类路径

00:38:24.650 --> 00:38:30.210
我认为我具有的计算功能

00:38:27.240 --> 00:38:32.210
用于基本上改变班级路径

00:38:30.210 --> 00:38:35.670
并且启用了更多功能

00:38:32.210 --> 00:38:40.500
基准，我也使用了规格J 

00:38:35.670 --> 00:38:42.660
超过一些数字，我可以将它们刷新

00:38:40.500 --> 00:38:45.000
真的没有时间去研究所有

00:38:42.660 --> 00:38:47.670
这里的细节，还有一些要

00:38:45.000 --> 00:38:50.700
注意蓝色的演示样本

00:38:47.670 --> 00:38:53.490
第一张幻灯片上的一个，所以它在

00:38:50.700 --> 00:38:54.720
我从中绘制该图的时间

00:38:53.490 --> 00:38:56.790
滑到一千三百

00:38:54.720 --> 00:38:58.830
毫秒，这是九百

00:38:56.790 --> 00:39:00.869
九百三十五

00:38:58.830 --> 00:39:05.220
那就是

00:39:00.869 --> 00:39:08.220
弹簧是两点零热量记忆13 

00:39:05.220 --> 00:39:10.369
兆字节的总内存

00:39:08.220 --> 00:39:15.720
估计有点困难，但是

00:39:10.369 --> 00:39:17.760
总内存76兆字节，您知道

00:39:15.720 --> 00:39:18.700
五千课，那是

00:39:17.760 --> 00:39:21.280
那基本的东西

00:39:18.700 --> 00:39:24.190
在启动时产生所有这些热量

00:39:21.280 --> 00:39:26.859
几乎是900毫秒

00:39:24.190 --> 00:39:30.460
加载5600学时所需的时间

00:39:26.859 --> 00:39:32.140
所以一般来说，随着你的改变

00:39:30.460 --> 00:39:35.079
我有一个使用JDBC，另一个有

00:39:32.140 --> 00:39:37.839
执行器，因为您可以增加数量

00:39:35.079 --> 00:39:39.150
增加启动功能

00:39:37.839 --> 00:39:42.310
你增加课程数量

00:39:39.150 --> 00:39:44.349
这个序列在这里说，所以这是

00:39:42.310 --> 00:39:46.839
演示样本，然后我开始剥离

00:39:44.349 --> 00:39:49.359
当我给你进一步介绍时

00:39:46.839 --> 00:39:52.359
这里越来越多的功能被删除

00:39:49.359 --> 00:39:53.680
从那个应用程序直到我到达

00:39:52.359 --> 00:39:58.170
指出它完全起作用的地方

00:39:53.680 --> 00:40:02.920
那时它在700 

00:39:58.170 --> 00:40:04.540
毫秒，但是有很多

00:40:02.920 --> 00:40:07.390
就你知道那里的开销

00:40:04.540 --> 00:40:09.520
维护应用程序代码

00:40:07.390 --> 00:40:16.630
我会告诉你这是什么意思

00:40:09.520 --> 00:40:18.130
有趣，所以你很紧张

00:40:16.630 --> 00:40:19.900
相关性不完全是直的

00:40:18.130 --> 00:40:21.430
线更像是两个直线

00:40:19.900 --> 00:40:23.770
线条之间的紧密联系

00:40:21.430 --> 00:40:27.490
加载和启动的类数

00:40:23.770 --> 00:40:29.079
时间，我通过更改

00:40:27.490 --> 00:40:30.609
基本上是班级路径，所以几乎

00:40:29.079 --> 00:40:31.660
相同的应用程序，但是运行了

00:40:30.609 --> 00:40:34.869
结束，还有一些在底部

00:40:31.660 --> 00:40:36.339
这里不是同一应用程序

00:40:34.869 --> 00:40:38.380
他们是我开始的地方

00:40:36.339 --> 00:40:40.150
手动删除内容并创建

00:40:38.380 --> 00:40:42.280
功能Bean定义和

00:40:40.150 --> 00:40:43.990
这样的东西，但他们都在

00:40:42.280 --> 00:40:45.849
相同的曲线非常紧

00:40:43.990 --> 00:40:47.680
相关性，我发现的任何地方

00:40:45.849 --> 00:40:50.170
他们偏离了我去看了看

00:40:47.680 --> 00:40:51.579
然后我发现了问题并解决了

00:40:50.170 --> 00:40:53.050
你可以用你的应用程序做到这一点

00:40:51.579 --> 00:40:56.050
可以将其绘制在上面，您可以查看是否

00:40:53.050 --> 00:40:57.550
它在这里，如果你会赢

00:40:56.050 --> 00:40:59.290
在这里，你会以为你

00:40:57.550 --> 00:41:02.560
可能会发现一个问题

00:40:59.290 --> 00:41:06.760
解决这个有趣的问题

00:41:02.560 --> 00:41:10.569
一个是Spring Boot应用程序

00:41:06.760 --> 00:41:12.880
休眠JPA，因此休眠是成功的

00:41:10.569 --> 00:41:15.520
大家都认为冬眠是

00:41:12.880 --> 00:41:18.040
慢，它不与数量相比

00:41:15.520 --> 00:41:18.880
您必须加载超过8000个课程

00:41:18.040 --> 00:41:20.980
其实还不错

00:41:18.880 --> 00:41:23.530
所以事实证明，休眠团队

00:41:20.980 --> 00:41:26.190
非常了解这些垃圾收集

00:41:23.530 --> 00:41:28.070
问题，他们已经对其进行了高度优化

00:41:26.190 --> 00:41:31.530
所以他们在那里做得很好

00:41:28.070 --> 00:41:35.190
需要更快地移动韦伯通量和

00:41:31.530 --> 00:41:39.090
 Nettie像我一样快一点

00:41:35.190 --> 00:41:40.950
说这又是演示应用程序

00:41:39.090 --> 00:41:43.050
有一个通常的规范样本，所以

00:41:40.950 --> 00:41:46.290
您的时间不到800毫秒

00:41:43.050 --> 00:41:50.370
 J日志是一回事，但我做到了

00:41:46.290 --> 00:41:52.410
类路径的排除，所以JSON和日志

00:41:50.370 --> 00:41:54.210
背部基本被移除并冬眠

00:41:52.410 --> 00:41:56.850
验证程序我已经完成了验证程序我

00:41:54.210 --> 00:41:59.040
忘了是的，所以胃蛋白酶

00:41:56.850 --> 00:42:01.650
它需要-我无法接受的验证器

00:41:59.040 --> 00:42:04.140
如果您不使用它，那就把它拿走

00:42:01.650 --> 00:42:07.190
出来，因为那是你知道这是一个

00:42:04.140 --> 00:42:09.510
几乎恒定60 70毫秒

00:42:07.190 --> 00:42:11.100
也许没有那么多50 

00:42:09.510 --> 00:42:12.450
平台上的朋友以及其他一切

00:42:11.100 --> 00:42:14.580
你兴旺

00:42:12.450 --> 00:42:16.860
所以在这里我谈到了JVM的调整

00:42:14.580 --> 00:42:20.610
九分球没有验证，孩子们的水平

00:42:16.860 --> 00:42:22.320
我会很快提到的一个

00:42:20.610 --> 00:42:25.020
查看一些博客，尤其是较旧的博客

00:42:22.320 --> 00:42:27.000
关于开发随机，你不需要做

00:42:25.020 --> 00:42:28.260
总的来说，但我是

00:42:27.000 --> 00:42:30.540
放在那只是提醒你

00:42:28.260 --> 00:42:32.780
这曾经是所有的问题

00:42:30.540 --> 00:42:35.430
版本的Tomcat，现在已经不存在了

00:42:32.780 --> 00:42:37.620
你可以分享九个真的很有趣

00:42:35.430 --> 00:42:40.680
所以有一个叫做类数据的功能

00:42:37.620 --> 00:42:43.050
分享我认为是发明的CDF 

00:42:40.680 --> 00:42:44.640
对于像WebSphere这样的应用服务器，我们会

00:42:43.050 --> 00:42:45.870
喜欢WebLogic，但我不确定

00:42:44.640 --> 00:42:49.740
不再是真的，因为有人告诉我

00:42:45.870 --> 00:42:51.300
最近有不同的故事，但无论如何，ICD 

00:42:49.740 --> 00:42:54.390
它试图参加一些这样的课程

00:42:51.300 --> 00:42:55.640
浮动开销并缓存它，以便

00:42:54.390 --> 00:43:00.150
听起来不错

00:42:55.640 --> 00:43:02.340
原来它已经在Oracle中了

00:43:00.150 --> 00:43:05.340
 JDK很久了，我可能不知道

00:43:02.340 --> 00:43:09.480
自从Java 7人类以来，我还有另外六个

00:43:05.340 --> 00:43:11.700
不确定，现在可以通过

00:43:09.480 --> 00:43:14.490
 openjdk中的默认设置，因此您可以获得

00:43:11.700 --> 00:43:16.950
在11个版本上工作并使用CDF，如果

00:43:14.490 --> 00:43:20.130
您会看到Java的性能基准

00:43:16.950 --> 00:43:23.370
 11个JDK人员，他们总是将其打开

00:43:20.130 --> 00:43:25.710
因为它有帮助，但这是一个痛苦

00:43:23.370 --> 00:43:27.270
真的很难产生所有的

00:43:25.710 --> 00:43:29.130
缓存您需要的数据

00:43:27.270 --> 00:43:30.789
经过漫长的多步骤

00:43:29.130 --> 00:43:34.509
到达第一行的过程

00:43:30.789 --> 00:43:36.309
运行它打开j9是他们的IBM JVM 

00:43:34.509 --> 00:43:37.569
捐给日食，并与你

00:43:36.309 --> 00:43:42.039
只需玩这三个

00:43:37.569 --> 00:43:45.400
命令行选项只会更快， 

00:43:42.039 --> 00:43:47.109
它确实很棒，因为它不是

00:43:45.400 --> 00:43:51.339
戏剧性的他们说红色和

00:43:47.109 --> 00:43:54.150
蓝色是JDK，标准是JDK八， 

00:43:51.339 --> 00:43:56.919
打开j9，它的速度要快一些

00:43:54.150 --> 00:44:00.279
大约是百分之十

00:43:56.919 --> 00:44:03.189
如果幸运的话，大概十五岁

00:44:00.279 --> 00:44:05.859
值得拥有，然后他们爆炸了

00:44:03.189 --> 00:44:08.709
快嘴明显的类路径排斥

00:44:05.859 --> 00:44:11.499
没关系，我经常提到杰克逊

00:44:08.709 --> 00:44:14.229
一定要打开验证器

00:44:11.499 --> 00:44:15.699
执行器我不是那么愚蠢我是如此

00:44:14.229 --> 00:44:18.309
看空了我想你可以

00:44:15.699 --> 00:44:19.599
把那些留在里面可能很好

00:44:18.309 --> 00:44:21.219
可能会发现其他东西，所以

00:44:19.599 --> 00:44:24.400
要注意的事情是

00:44:21.219 --> 00:44:28.539
静态初始化程序发生的事情

00:44:24.400 --> 00:44:30.759
当类正确加载时，这些

00:44:28.539 --> 00:44:32.650
事情都是关于可怕的静态的

00:44:30.759 --> 00:44:36.779
他们中的初始化器实际上不是

00:44:32.650 --> 00:44:36.779
执行器是三件事

00:44:37.019 --> 00:44:42.279
懒惰的存在，所以有两个功能

00:44:40.390 --> 00:44:44.919
春季靴子的最新版本是

00:44:42.279 --> 00:44:48.880
 Spring Data JPA存储库

00:44:44.919 --> 00:44:50.289
引导节点等于懒惰

00:44:48.880 --> 00:44:52.839
实际上在春天是两点一

00:44:50.289 --> 00:44:54.339
是在宠物诊所做的

00:44:52.839 --> 00:44:58.869
对于宠物诊所，其中三个

00:44:54.339 --> 00:45:00.729
实体可能是一半

00:44:58.869 --> 00:45:02.789
秒也许是七百毫秒

00:45:00.729 --> 00:45:05.589
这样的东西值得拥有

00:45:02.789 --> 00:45:07.839
如果您有大量实体

00:45:05.589 --> 00:45:09.729
它按比例上升，这太神奇了

00:45:07.839 --> 00:45:11.380
所以我知道你可以制造疯狂

00:45:09.729 --> 00:45:14.799
四百个实体的应用程序

00:45:11.380 --> 00:45:16.719
他们花了您一分钟时间来开始

00:45:14.799 --> 00:45:18.459
在我的笔记本电脑上，然后您将

00:45:16.719 --> 00:45:23.579
存储库懒惰，它下降到

00:45:18.459 --> 00:45:23.579
两秒钟惊人的权利

00:45:25.170 --> 00:45:28.780
有时人们会怀念Densham 

00:45:27.070 --> 00:45:30.190
曲解这只是一个

00:45:28.780 --> 00:45:32.260
当我看着时观察

00:45:30.190 --> 00:45:34.390
在人们的实际应用中，他们

00:45:32.260 --> 00:45:35.860
很慢，我发现他们在滥用

00:45:34.390 --> 00:45:38.560
他们正在做的她的帖子构造

00:45:35.860 --> 00:45:40.930
昂贵的东西，他们知道他们是

00:45:38.560 --> 00:45:42.640
这样做，你知道吗

00:45:40.930 --> 00:45:44.920
文件并转到数据库

00:45:42.640 --> 00:45:46.240
阻止发布的压力和

00:45:44.920 --> 00:45:48.520
一定会让你慢下来

00:45:46.240 --> 00:45:51.130
当您启动时，然后系统

00:45:48.520 --> 00:45:53.170
现在春季2.2春季主要懒惰

00:45:51.130 --> 00:45:55.390
初始化等于true我在

00:45:53.170 --> 00:46:00.310
宠物诊所也可能

00:45:55.390 --> 00:46:04.840
我应该再想一秒钟

00:46:00.310 --> 00:46:06.460
值得拥有，所以现在我们在

00:46:04.840 --> 00:46:08.710
您可以做的事情清单的底部

00:46:06.460 --> 00:46:11.290
这样做一件事，你可以尝试我读一本

00:46:08.710 --> 00:46:12.610
关于此的博客，您也可以在

00:46:11.290 --> 00:46:15.220
而不是使用启用自动

00:46:12.610 --> 00:46:17.760
配置你可以试试这个

00:46:15.220 --> 00:46:21.160
导入自动配置时添加注释

00:46:17.760 --> 00:46:23.020
然后你必须列出你必须

00:46:21.160 --> 00:46:25.860
知道列出哪些是很难的

00:46:23.020 --> 00:46:30.550
没错，这只是一个标准

00:46:25.860 --> 00:46:32.800
带有错误处理的nettie HTTP应用程序

00:46:30.550 --> 00:46:35.020
我的演示应用程序基本上

00:46:32.800 --> 00:46:39.310
您需要运行的最少材料集

00:46:35.020 --> 00:46:45.250
宠物诊所的出口网伸缩

00:46:39.310 --> 00:46:46.600
还有另一个用于更多缓存的知识

00:46:45.250 --> 00:46:51.430
比缓存还多

00:46:46.600 --> 00:46:53.350
休眠JPA数据源

00:46:51.430 --> 00:46:56.020
是的，大概还有六点左右

00:46:53.350 --> 00:46:58.090
所以你必须自己整理

00:46:56.020 --> 00:47:02.860
这是一种痛苦，我正在尝试

00:46:58.090 --> 00:47:04.930
我和塞巴斯蒂安的经销商

00:47:02.860 --> 00:47:07.380
在今天早上讨论代码

00:47:04.930 --> 00:47:10.630
我们都在努力思考美好

00:47:07.380 --> 00:47:12.460
用于识别的编程模型

00:47:10.630 --> 00:47:14.470
如果有人的话，这样做更容易

00:47:12.460 --> 00:47:16.300
想手动配置

00:47:14.470 --> 00:47:18.130
我相信应该并且应该

00:47:16.300 --> 00:47:21.010
比这更好做，但这是

00:47:18.130 --> 00:47:24.550
这个作品曾经很大

00:47:21.010 --> 00:47:26.860
事情，事实证明， 

00:47:24.550 --> 00:47:30.330
蓝色和蓝色之间的巨大差异

00:47:26.860 --> 00:47:32.800
我原始幻灯片中的红色主要是这个

00:47:30.330 --> 00:47:35.380
主要是我缩小了范围

00:47:32.800 --> 00:47:37.690
配置以及您何时

00:47:35.380 --> 00:47:38.890
是否也懒惰初始化和

00:47:37.690 --> 00:47:40.750
一堆他们没有冒出来的东西

00:47:38.890 --> 00:47:43.300
指出它不是那么大

00:47:40.750 --> 00:47:45.580
如果你有一张照片就不同

00:47:43.300 --> 00:47:50.430
或显示一些宠物诊所

00:47:45.580 --> 00:47:51.730
基准是春天

00:47:50.430 --> 00:47:54.490
自动配置

00:47:51.730 --> 00:47:57.130
所有你可以吃一个只是

00:47:54.490 --> 00:48:00.970
顺便说一句，这是宠物诊所

00:47:57.130 --> 00:48:03.670
这不是你好世界标准

00:48:00.970 --> 00:48:06.430
宠物诊所，并带有执行器

00:48:03.670 --> 00:48:08.800
执行器关闭

00:48:06.430 --> 00:48:10.810
执行器关闭我可以减少到更少

00:48:08.800 --> 00:48:16.300
不到一秒半的时间开始

00:48:10.810 --> 00:48:21.820
宠物诊所，然后我得到了黄色

00:48:16.300 --> 00:48:26.380
这是手动光束定义，但我

00:48:21.820 --> 00:48:29.290
猜不偷懒，就是那个

00:48:26.380 --> 00:48:30.790
点九秒左右或红色

00:48:29.290 --> 00:48:32.560
是功能性的，所以功能性光束

00:48:30.790 --> 00:48:34.780
定义让我有点

00:48:32.560 --> 00:48:36.460
但在这边不是很多

00:48:34.780 --> 00:48:37.870
几乎没有区别，如果相同

00:48:36.460 --> 00:48:39.940
功能光束定义和

00:48:37.870 --> 00:48:43.840
没有功能就没有了

00:48:39.940 --> 00:48:46.540
真的有它的学术

00:48:43.840 --> 00:48:47.890
自动配置又有点

00:48:46.540 --> 00:48:52.570
有点慢，因为光束很懒

00:48:47.890 --> 00:48:55.150
具有功能性的定义

00:48:52.570 --> 00:48:56.170
定义肯定很有趣

00:48:55.150 --> 00:48:58.300
有趣，因为它不使用

00:48:56.170 --> 00:49:00.490
反射正确，所以这是标准

00:48:58.300 --> 00:49:02.980
和配置我们有春天的主题

00:49:00.490 --> 00:49:05.230
不得不看这些豆子，看看这些

00:49:02.980 --> 00:49:07.420
类分析所有方法看

00:49:05.230 --> 00:49:10.000
注释会查看

00:49:07.420 --> 00:49:11.590
一切都使用反射和

00:49:10.000 --> 00:49:13.810
反射速度快，不是

00:49:11.590 --> 00:49:15.700
一定是一件坏事，但是如果你想

00:49:13.810 --> 00:49:17.620
为了避免反射，您可以，我们已经

00:49:15.700 --> 00:49:20.350
从春季五开始就知道了

00:49:17.620 --> 00:49:22.360
我们有这个模型，您可以

00:49:20.350 --> 00:49:25.360
编写应用程序上下文初始化器

00:49:22.360 --> 00:49:27.910
您可以致电通用

00:49:25.360 --> 00:49:29.350
您可以调用API的应用程序上下文

00:49:27.910 --> 00:49:31.900
注册是注册bean 

00:49:29.350 --> 00:49:34.630
注册bean，这是相同的代码

00:49:31.900 --> 00:49:36.610
基本上是上一张幻灯片，所以

00:49:34.630 --> 00:49:39.520
这个过程，然后你会明白为什么

00:49:36.610 --> 00:49:40.790
它是无反射的，您也可以

00:49:39.520 --> 00:49:42.350
看看为什么有点痛苦

00:49:40.790 --> 00:49:44.900
如果您必须转换所有

00:49:42.350 --> 00:49:47.900
您的配置实际上

00:49:44.900 --> 00:49:50.170
我认为它更容易阅读

00:49:47.900 --> 00:49:53.420
我有点喜欢这样的注释

00:49:50.170 --> 00:49:55.670
我们还没有准备好让您知道推人

00:49:53.420 --> 00:49:56.990
进入功能存在的定义

00:49:55.670 --> 00:50:00.710
一切，但这很有趣

00:49:56.990 --> 00:50:03.140
选择弹簧云功能有一些

00:50:00.710 --> 00:50:05.690
功能光束定义功能

00:50:03.140 --> 00:50:09.140
真的非常快而且效果很好

00:50:05.690 --> 00:50:12.830
在AWS等受限环境中

00:50:09.140 --> 00:50:14.750
例如lambda或春天

00:50:12.830 --> 00:50:19.340
我只是食物春天的云功能

00:50:14.750 --> 00:50:20.960
提到这里有微生物地图

00:50:19.340 --> 00:50:21.770
的应用程序中有基准

00:50:20.960 --> 00:50:24.110
还有

00:50:21.770 --> 00:50:25.640
那就是乐趣可以来自的地方

00:50:24.110 --> 00:50:27.650
如果您对源代码感兴趣

00:50:25.640 --> 00:50:31.280
当然还有春季foo 

00:50:27.650 --> 00:50:33.470
值得一提的是我看过的另一件事

00:50:31.280 --> 00:50:35.900
当你约束

00:50:33.470 --> 00:50:37.130
 CPU，所以这几天经常发生

00:50:35.900 --> 00:50:38.720
因为人们在奔跑

00:50:37.130 --> 00:50:40.070
他们正在运行的虚拟环境

00:50:38.720 --> 00:50:42.080
在古巴Nettie，他们正在

00:50:40.070 --> 00:50:45.020
受到约束的容器

00:50:42.080 --> 00:50:51.860
 CPU，我们从Rif获得了这个应用

00:50:45.020 --> 00:50:54.470
运行的项目即兴服务平台

00:50:51.860 --> 00:50:56.210
一个功能，并具有四个CPU 

00:50:54.470 --> 00:50:58.460
在不到三秒钟的时间内样式化

00:50:56.210 --> 00:51:01.340
他去了一个CPU，它几乎增加了

00:50:58.460 --> 00:51:05.120
 17秒刺客真恐怖

00:51:01.340 --> 00:51:07.670
糟糕，但完全相同的应用或

00:51:05.120 --> 00:51:11.690
相同的功能将在600中运行

00:51:07.670 --> 00:51:14.840
 CPU前一千毫秒

00:51:11.690 --> 00:51:17.260
一个CPU的毫秒数和

00:51:14.840 --> 00:51:23.090
两者之间的区别是

00:51:17.260 --> 00:51:26.210
最初的烂货是Tomcat和auto 

00:51:23.090 --> 00:51:28.160
配置，你知道配置

00:51:26.210 --> 00:51:30.080
还是那个不

00:51:28.160 --> 00:51:34.520
烂是内蒂

00:51:30.080 --> 00:51:35.440
更少的线程，更少的负载

00:51:34.520 --> 00:51:38.720
 CPU 

00:51:35.440 --> 00:51:40.240
 Nettie功能Bean定义，但是

00:51:38.720 --> 00:51:43.610
完全相同的功能

00:51:40.240 --> 00:51:44.810
所以很有意思的是

00:51:43.610 --> 00:51:46.690
那里有一些里程，这是其中之一

00:51:44.810 --> 00:51:50.080
我见过最戏剧性的结果

00:51:46.690 --> 00:51:53.770
最后一张幻灯片，所以提前编译

00:51:50.080 --> 00:51:55.780
即将到来的LVM并生成本机映像

00:51:53.770 --> 00:51:57.610
适用于Java应用程序，包括spring 

00:51:55.780 --> 00:52:00.360
启动应用程序，这是铺

00:51:57.610 --> 00:52:02.680
我在这里显示的应用程序开始于

00:52:00.360 --> 00:52:04.510
 40毫秒，这就是您要的

00:52:02.680 --> 00:52:07.480
看着正确不仅仅是一个因素

00:52:04.510 --> 00:52:12.660
十分之一的速度提高了一百倍

00:52:07.480 --> 00:52:15.250
比您知道的原始JVM启动时间

00:52:12.660 --> 00:52:17.860
那是承诺，我们知道我们会得到

00:52:15.250 --> 00:52:19.870
我想我们现在很接近

00:52:17.860 --> 00:52:22.150
带有大量春季食品

00:52:19.870 --> 00:52:25.020
应用程序的缺点是您将失去各种各样

00:52:22.150 --> 00:52:29.280
调试JMX可管理性

00:52:25.020 --> 00:52:31.600
动态编译，因此运行时

00:52:29.280 --> 00:52:35.080
优化不见了

00:52:31.600 --> 00:52:36.490
垃圾收集不会发生，所以

00:52:35.080 --> 00:52:39.160
他们正在模拟所有这些东西，但是

00:52:36.490 --> 00:52:41.920
他们基本上是你知道他们是

00:52:39.160 --> 00:52:43.660
从很远的地方开始

00:52:41.920 --> 00:52:46.360
有很多工程上的努力

00:52:43.660 --> 00:52:47.500
这些年来，您进入了JVM 

00:52:46.360 --> 00:52:49.530
无法利用

00:52:47.500 --> 00:52:52.150
运行这种应用程序的

00:52:49.530 --> 00:52:54.430
许多问题已经售出，所以我们

00:52:52.150 --> 00:52:57.220
与Oracle紧密合作

00:52:54.430 --> 00:52:59.380
他们想带动的团队

00:52:57.220 --> 00:53:00.790
成长的一年，我们希望他们如此努力

00:52:59.380 --> 00:53:05.280
它仍在工作，但我

00:53:00.790 --> 00:53:07.450
认为yogam预测春季5.3 

00:53:05.280 --> 00:53:09.340
我认为这可能是目标

00:53:07.450 --> 00:53:11.620
那可能是相当公平的

00:53:09.340 --> 00:53:14.020
准确的会在那之前发生，但是

00:53:11.620 --> 00:53:16.870
你知道我什至不认为那个本地人

00:53:14.020 --> 00:53:19.900
图像将在此之前制作

00:53:16.870 --> 00:53:21.070
无论如何，这就是一堆的结局

00:53:19.900 --> 00:53:24.030
链接在那里，以便您可以拍照

00:53:21.070 --> 00:53:28.330
我会尽量将幻灯片发送出去

00:53:24.030 --> 00:53:29.770
每个人都有一个指向所有链接的链接

00:53:28.330 --> 00:53:31.990
指向未来，所以我必须停下来

00:53:29.770 --> 00:53:34.500
在那里，是时候喝啤酒了

00:53:31.990 --> 00:53:36.310
我可以问啤酒问题

00:53:34.500 --> 00:53:39.410
听起来合理吗

00:53:36.310 --> 00:53:40.690
妥协谢谢

00:53:39.410 --> 00:53:47.220
您

00:53:40.690 --> 00:53:47.220
 [音乐] 

