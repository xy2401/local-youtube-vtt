WEBVTT
Kind: captions
Language: zh-Hans

00:00:02.450 --> 00:00:07.470
 [音乐] 

00:00:05.130 --> 00:00:09.750
所以我想我们必须开始，因为这

00:00:07.470 --> 00:00:12.570
正是他们想要的正确时间

00:00:09.750 --> 00:00:14.730
在合适的时间开始并欢迎

00:00:12.570 --> 00:00:17.369
参加会议的所有人

00:00:14.730 --> 00:00:19.470
如何在其中构建反应服务器引擎

00:00:17.369 --> 00:00:22.140
为了节省您的时间，因为之前

00:00:19.470 --> 00:00:23.850
其他准备和介绍

00:00:22.140 --> 00:00:26.210
我要保存什么

00:00:23.850 --> 00:00:28.710
你的时间，因为我想让你知道

00:00:26.210 --> 00:00:30.660
让您尽可能多地学习

00:00:28.710 --> 00:00:33.360
为什么我要分享一点

00:00:30.660 --> 00:00:35.100
谁在说这话，你就可以去

00:00:33.360 --> 00:00:37.500
到另一个房间或另一个会话

00:00:35.100 --> 00:00:40.350
并学到更好的东西

00:00:37.500 --> 00:00:42.719
适用于想要学习新知识的人

00:00:40.350 --> 00:00:46.050
工作，并了解更多有关

00:00:42.719 --> 00:00:49.829
最低水平的新型GDK 

00:00:46.050 --> 00:00:52.260
与非阻塞I / O集成，如果您

00:00:49.829 --> 00:00:55.710
想了解一些有关项目的信息

00:00:52.260 --> 00:00:57.239
反应堆在行动这也是

00:00:55.710 --> 00:00:59.520
对您真的有用，因为我们

00:00:57.239 --> 00:01:03.539
去我们要讨论一个

00:00:59.520 --> 00:01:06.210
关于一些运营商的一点点

00:01:03.539 --> 00:01:07.860
项目反应堆，当然，如果您

00:01:06.210 --> 00:01:10.740
想了解反应式方法

00:01:07.860 --> 00:01:13.500
饲料到服务器端引擎

00:01:10.740 --> 00:01:15.869
较低的最低层，那么这将

00:01:13.500 --> 00:01:19.229
对您也真的很有用，所以如果您

00:01:15.869 --> 00:01:21.600
仍然和我在一起然后我们走吧

00:01:19.229 --> 00:01:24.360
让我自我介绍一下我的名字

00:01:21.600 --> 00:01:26.729
是亚历克（Alec）我来自乌克兰，来自基辅

00:01:24.360 --> 00:01:29.909
如果我在哪里工作，我会为网工作

00:01:26.729 --> 00:01:31.560
正在建立惊人的产品，称之为我们的

00:01:29.909 --> 00:01:34.200
套接字下一个会话将是

00:01:31.560 --> 00:01:36.720
致力于该产品并

00:01:34.200 --> 00:01:38.670
实际上我是项目的贡献者

00:01:36.720 --> 00:01:40.500
反应堆，所以我知道一切

00:01:38.670 --> 00:01:42.960
它在反应堆内部进行的过程

00:01:40.500 --> 00:01:46.110
等等，所以如果你只有n个方程

00:01:42.960 --> 00:01:48.030
和我在一起，我也在组织一些

00:01:46.110 --> 00:01:51.420
会议在乌克兰，所以如果你想

00:01:48.030 --> 00:01:53.430
学习和去学习技术是

00:01:51.420 --> 00:01:55.229
与Java有关并喜欢Kiev和

00:01:53.430 --> 00:01:57.570
乌克兰请参加那些会议

00:01:55.229 --> 00:01:59.909
或ping我，我会分享一些

00:01:57.570 --> 00:02:01.469
打折给你好吧我也写过

00:01:59.909 --> 00:02:03.390
与反应式编程有关的书

00:02:01.469 --> 00:02:06.509
春天的速度，但这有点

00:02:03.390 --> 00:02:08.819
营销，现在我们的主要目标是

00:02:06.509 --> 00:02:11.610
议程，所以我们将从

00:02:08.819 --> 00:02:13.100
理解我们想要看到的

00:02:11.610 --> 00:02:15.740
反应服务器

00:02:13.100 --> 00:02:18.320
那将是开始，然后为什么

00:02:15.740 --> 00:02:20.180
我们需要拖拉机服务器引擎，或者为什么

00:02:18.320 --> 00:02:23.060
现有阻塞技术示例

00:02:20.180 --> 00:02:26.240
感觉不到现实世界的问题， 

00:02:23.060 --> 00:02:28.310
最后，我们将对

00:02:26.240 --> 00:02:30.800
实现反应式服务器引擎

00:02:28.310 --> 00:02:35.030
那是我们的计划，听起来不错

00:02:30.800 --> 00:02:36.950
太好了，让我们首先开始

00:02:35.030 --> 00:02:39.050
想在反应式服务器下看到

00:02:36.950 --> 00:02:41.450
我们要查看服务器的引擎，这是

00:02:39.050 --> 00:02:43.490
主要我们的主要部分

00:02:41.450 --> 00:02:46.430
实施，该服务器应该是

00:02:43.490 --> 00:02:49.160
能够接受连接，我们必须

00:02:46.430 --> 00:02:51.380
提供一些处理能力

00:02:49.160 --> 00:02:53.300
那些非常，这样的连接使用

00:02:51.380 --> 00:02:56.390
例如反应式编程模型

00:02:53.300 --> 00:02:58.400
这是重要的部分，然后我们

00:02:56.390 --> 00:03:01.280
想要拥有一些泳池

00:02:58.400 --> 00:03:03.710
工人或线程池将

00:03:01.280 --> 00:03:05.480
附加到每个新连接，并

00:03:03.710 --> 00:03:09.170
例如，此连接将共享

00:03:05.480 --> 00:03:11.240
几个有价值的工人，然后一旦

00:03:09.170 --> 00:03:12.650
碰巧我们想要一些但是

00:03:11.240 --> 00:03:14.810
压力控制，因为这是

00:03:12.650 --> 00:03:17.000
重要的反应式编程，这是

00:03:14.810 --> 00:03:18.650
约和反应流约回来

00:03:17.000 --> 00:03:21.260
压力控制，我们要保留

00:03:18.650 --> 00:03:23.300
我们的资源在正常情况下

00:03:21.260 --> 00:03:25.310
陈述并保持应用程序正常运行

00:03:23.300 --> 00:03:27.830
这就是为什么我们要控制但祈祷

00:03:25.310 --> 00:03:30.140
如果我们想要，如果我们不能写

00:03:27.830 --> 00:03:32.930
对我们的输出到我们的东西

00:03:30.140 --> 00:03:36.370
连接，然后我们可以要求新的

00:03:32.930 --> 00:03:39.200
日期，而不是其他方式，所以一旦我们

00:03:36.370 --> 00:03:41.120
例如接收但压力请求

00:03:39.200 --> 00:03:44.510
或流程控制或过去例如

00:03:41.120 --> 00:03:46.400
我还会再给我几个服务器

00:03:44.510 --> 00:03:48.830
开始发送我们的数据，我们将适用

00:03:46.400 --> 00:03:52.040
给他们一些转变， 

00:03:48.830 --> 00:03:55.160
发回我们想要的东西

00:03:52.040 --> 00:03:57.290
代码中的反应式服务器引擎

00:03:55.160 --> 00:04:00.530
透视它可能看起来像

00:03:57.290 --> 00:04:02.780
这样，我们想用几句话

00:04:00.530 --> 00:04:04.930
接受或我们要创建服务器

00:04:02.780 --> 00:04:08.090
通过这样定义主机和端口

00:04:04.930 --> 00:04:10.730
那么我们想定义我们的

00:04:08.090 --> 00:04:13.250
这样的连接处理程序是

00:04:10.730 --> 00:04:15.770
如果你参加那很相似

00:04:13.250 --> 00:04:17.840
 r2 DBC谈话，您看到了类似的内容

00:04:15.770 --> 00:04:21.350
因为这是一种常见的模式

00:04:17.840 --> 00:04:23.750
处理新的连接，然后我们想要

00:04:21.350 --> 00:04:26.630
有种

00:04:23.750 --> 00:04:28.430
读取某些数据的直接方法

00:04:26.630 --> 00:04:31.250
从此连接使用例如

00:04:28.430 --> 00:04:34.250
接收方法并发送一些数据

00:04:31.250 --> 00:04:36.830
返回使用共同的通用名称添加

00:04:34.250 --> 00:04:39.170
方法，在两种情况下都是

00:04:36.830 --> 00:04:41.150
我们想要使用项目的反应流

00:04:39.170 --> 00:04:44.630
采取行动，因为这是一种常见的方式

00:04:41.150 --> 00:04:47.210
送一些死去送抗议

00:04:44.630 --> 00:04:49.190
反应性的一些数据，但是如何

00:04:47.210 --> 00:04:52.520
你们中的许多人都熟悉项目

00:04:49.190 --> 00:04:54.740
几手之前就用过它

00:04:52.520 --> 00:04:57.020
您是否听说过Eric的Java 

00:04:54.740 --> 00:04:58.940
也许之前或使用它，所以我猜

00:04:57.020 --> 00:05:01.070
同一个人没事，所以一点点

00:04:58.940 --> 00:05:02.960
你听说过那个项目

00:05:01.070 --> 00:05:04.640
基本上是关于反应式编程

00:05:02.960 --> 00:05:07.250
反应流保持，所以我们想要

00:05:04.640 --> 00:05:09.680
以这种方式使用它，当然

00:05:07.250 --> 00:05:11.690
为了启动这个引擎你想

00:05:09.680 --> 00:05:13.490
呼叫开始，当然要保持主要

00:05:11.690 --> 00:05:15.080
线程正在运行，我们要阻止

00:05:13.490 --> 00:05:16.970
几句话就说明整个执行过程

00:05:15.080 --> 00:05:20.750
一切都写成反应式

00:05:16.970 --> 00:05:23.630
正如您所看到的主要问题

00:05:20.750 --> 00:05:25.400
你应该问我为什么我们需要

00:05:23.630 --> 00:05:27.830
那为什么我们需要反应式服务器

00:05:25.400 --> 00:05:30.050
引擎以证明这一点或

00:05:27.830 --> 00:05:32.390
为了表明我们为什么要做，我们需要

00:05:30.050 --> 00:05:36.830
将向您展示为什么出了什么问题

00:05:32.390 --> 00:05:39.140
阻止I / O，让我们做一些小演示

00:05:36.830 --> 00:05:42.110
为了了解什么是错

00:05:39.140 --> 00:05:45.979
阻止一个小点提议我要去

00:05:42.110 --> 00:05:48.919
运行普通套接字服务器，所以这是一个

00:05:45.979 --> 00:05:51.350
最简单的最低层实现

00:05:48.919 --> 00:05:55.100
套接字服务器，仅在以下位置启动

00:05:51.350 --> 00:05:57.620
端口8080，除了连接，这是一个

00:05:55.100 --> 00:06:01.490
接受连接的常规方法

00:05:57.620 --> 00:06:04.820
在GDK中以最低的价格处理数据

00:06:01.490 --> 00:06:07.160
在GDK级别上，所以我们想要拥有

00:06:04.820 --> 00:06:10.220
我们想要一个我们想要阅读的SAP连接

00:06:07.160 --> 00:06:12.830
输入流中的一些数据，我们

00:06:10.220 --> 00:06:15.410
想通过说一些来抗议

00:06:12.830 --> 00:06:18.950
回显消息，所以让我们开始吧

00:06:15.410 --> 00:06:21.919
这个简单的应用程序，让我们看看如何

00:06:18.950 --> 00:06:24.350
它起作用了，所以它开始是的，如果你

00:06:21.919 --> 00:06:26.390
通知以便运行每个

00:06:24.350 --> 00:06:29.240
我使用时真的很快开始一切

00:06:26.390 --> 00:06:31.910
在这里咆哮，因为咆哮快了

00:06:29.240 --> 00:06:35.270
启动和快速数据处理，所以我

00:06:31.910 --> 00:06:37.370
在这里使用它，现在让我们连接到

00:06:35.270 --> 00:06:40.850
我的应用程序使用telnet，因此我可以

00:06:37.370 --> 00:06:43.460
现在我可以写你好世界了

00:06:40.850 --> 00:06:47.419
打个招呼，有消息你看到吗

00:06:43.460 --> 00:06:50.270
我收到回显消息，因此基本上可以正常工作

00:06:47.419 --> 00:06:52.850
所以我要去写一些

00:06:50.270 --> 00:06:55.130
数据并观察到一些回声

00:06:52.850 --> 00:06:58.669
所以总的来说，这是怎么回事

00:06:55.130 --> 00:07:01.550
首先是当我尝试打开

00:06:58.669 --> 00:07:03.800
另一个连接不是杀死Java，而是

00:07:01.550 --> 00:07:04.479
打开其他连接什么也不会

00:07:03.800 --> 00:07:07.460
发生

00:07:04.479 --> 00:07:09.290
什么都不会发生，因为你认为

00:07:07.460 --> 00:07:13.729
那你什么都不知道的答案

00:07:09.290 --> 00:07:15.770
发生的答案很简单，我们

00:07:13.729 --> 00:07:19.520
只有一个线程抗议

00:07:15.770 --> 00:07:22.280
抗议数据，并且该线程是否友好

00:07:19.520 --> 00:07:24.380
先前连接所占用的

00:07:22.280 --> 00:07:27.139
它被先前的连接占用

00:07:24.380 --> 00:07:29.450
新的将无法开始

00:07:27.139 --> 00:07:31.160
处理数据，这就是为什么它是

00:07:29.450 --> 00:07:32.990
当然有一点问题

00:07:31.160 --> 00:07:35.270
为此，我们将创建一些解决方案

00:07:32.990 --> 00:07:39.229
这样的线程池，所以这是一个

00:07:35.270 --> 00:07:41.740
创建用于的线程池的常规方法

00:07:39.229 --> 00:07:44.870
在这种情况下的例子

00:07:41.740 --> 00:07:47.240
我机器上的处理器用于演示

00:07:44.870 --> 00:07:49.310
目的，让我们举四个例子

00:07:47.240 --> 00:07:52.190
线程来处理所有数据并

00:07:49.310 --> 00:07:55.789
让我们替换这个简单的连接

00:07:52.190 --> 00:07:57.470
逻辑是相同的，但是在

00:07:55.789 --> 00:08:00.080
螺纹形式的主要区别

00:07:57.470 --> 00:08:00.740
现在，一旦我接受了

00:08:00.080 --> 00:08:03.260
连接

00:08:00.740 --> 00:08:05.539
我想具体执行

00:08:03.260 --> 00:08:08.810
线程池或在特定线程上

00:08:05.539 --> 00:08:10.940
清楚好吧，这是最简单的

00:08:08.810 --> 00:08:13.130
主要逻辑非常相似，所以一旦我

00:08:10.940 --> 00:08:16.729
抗议一切联系

00:08:13.130 --> 00:08:20.889
被释放，让我们重新启动，让我们看看

00:08:16.729 --> 00:08:25.760
无论是否有效，让我们连接

00:08:20.889 --> 00:08:28.849
是的，这有效，让我们再次连接

00:08:25.760 --> 00:08:32.779
至少可以再凉爽

00:08:28.849 --> 00:08:35.270
让我们不要杀死Java，但可以这样工作

00:08:32.779 --> 00:08:41.030
一个不杀死Java的人

00:08:35.270 --> 00:08:44.000
请保存Java是

00:08:41.030 --> 00:08:46.730
而且这个效果很好，看起来像

00:08:44.000 --> 00:08:50.180
很好，但是另一个呢

00:08:46.730 --> 00:08:53.900
连接哦，这个不起作用

00:08:50.180 --> 00:08:56.660
因为我们耗尽了所有线程

00:08:53.900 --> 00:08:59.900
池，我们没有任何可用

00:08:56.660 --> 00:09:01.880
处理数据的线程，如果您愿意， 

00:08:59.900 --> 00:09:04.610
将要停止该程序或操作

00:09:01.880 --> 00:09:06.680
它会看到我们有一些任务

00:09:04.610 --> 00:09:09.800
队列，如果我们尝试打开

00:09:06.680 --> 00:09:12.230
更多的连接最终我们将获得Q 

00:09:09.800 --> 00:09:14.750
超出尺寸异常或类似

00:09:12.230 --> 00:09:17.240
那意味着我们没有任何

00:09:14.750 --> 00:09:20.210
或中的可用线程和内存

00:09:17.240 --> 00:09:22.220
队列中的空间，所以另一个明显

00:09:20.210 --> 00:09:25.040
您将提供的解决方案

00:09:22.220 --> 00:09:27.290
当我们想要处理时我们做什么

00:09:25.040 --> 00:09:31.460
很多请求锁定

00:09:27.290 --> 00:09:33.410
请求将其安排在缓存线程上

00:09:31.460 --> 00:09:36.200
池权为什么不使用例如

00:09:33.410 --> 00:09:38.240
缓存线程池以便处理所有

00:09:36.200 --> 00:09:41.000
连接，因为您可能会注意到我

00:09:38.240 --> 00:09:43.160
知道缓存的读取池使您能够

00:09:41.000 --> 00:09:47.330
根据需要创建尽可能多的线程

00:09:43.160 --> 00:09:50.360
所以让我们尝试一下，看看发生了什么

00:09:47.330 --> 00:09:53.210
当然在这种情况下，我们会有很多

00:09:50.360 --> 00:09:56.300
的线程，我们将能够打开

00:09:53.210 --> 00:09:59.090
尽可能多的连接，但是我们

00:09:56.300 --> 00:10:01.490
不会尝试使用我的

00:09:59.090 --> 00:10:04.340
在我的终端中进行控制台以进行测试

00:10:01.490 --> 00:10:09.710
这样的应用程序可能具有多大的弹性

00:10:04.340 --> 00:10:12.110
我创造了一个小恶魔剂量药

00:10:09.710 --> 00:10:14.210
这个小应用门先生，还有什么

00:10:12.110 --> 00:10:16.970
该应用程序基本上是打开的

00:10:14.210 --> 00:10:19.940
万个连接，并试图

00:10:16.970 --> 00:10:22.580
用尽可能多的数据向我的服务器发送垃圾邮件

00:10:19.940 --> 00:10:26.480
拥有它，所以最简单的就是

00:10:22.580 --> 00:10:31.340
尝试是否可以，我猜它可行

00:10:26.480 --> 00:10:34.160
因此，让我们尝试运行我的应用并查看

00:10:31.340 --> 00:10:37.970
我的主服务器是否在

00:10:34.160 --> 00:10:40.400
这样的方式可以生存或不生存

00:10:37.970 --> 00:10:45.490
由于某种原因它停止了您的想法

00:10:40.400 --> 00:10:50.089
你的主意发生了什么

00:10:45.490 --> 00:10:52.790
对，我们走出了记忆，因为

00:10:50.089 --> 00:10:55.670
威胁在某些方面确实非常昂贵

00:10:52.790 --> 00:10:58.279
 Java通常需要一兆字节的

00:10:55.670 --> 00:11:00.860
你的记忆，真的，真的

00:10:58.279 --> 00:11:03.829
跑步很贵

00:11:00.860 --> 00:11:06.320
在新线程上的所有内容都是

00:11:03.829 --> 00:11:08.779
为什么这是一个非常糟糕的连接模型

00:11:06.320 --> 00:11:10.519
真的很糟糕的处理模型

00:11:08.779 --> 00:11:13.130
每个连接只有一个线程，并且

00:11:10.519 --> 00:11:16.010
这就是为什么阻止无法生存

00:11:13.130 --> 00:11:18.949
要么你必须限制你的数量

00:11:16.010 --> 00:11:21.380
线程，在这种情况下，数量限制

00:11:18.949 --> 00:11:24.079
的同时连接的处理数量

00:11:21.380 --> 00:11:26.329
您的服务器旁边，或者您必须

00:11:24.079 --> 00:11:28.639
处理很多线程，这就是为什么

00:11:26.329 --> 00:11:31.100
你必须要付出很多钱

00:11:28.639 --> 00:11:33.589
对于数量巨大的真正大型机器

00:11:31.100 --> 00:11:37.160
的内存和大量的处理器

00:11:33.589 --> 00:11:39.320
这就是为什么阻止效果不好，所以让我们

00:11:37.160 --> 00:11:42.260
回到我们的幻灯片，让我们尝试做

00:11:39.320 --> 00:11:43.100
一些总结，看看一些缺点

00:11:42.260 --> 00:11:45.050
阻止I / O 

00:11:43.100 --> 00:11:47.420
首先，这是一种有效的资源

00:11:45.050 --> 00:11:49.519
用法，因为你必须吐以防万一

00:11:47.420 --> 00:11:52.339
每个连接模型的线程数

00:11:49.519 --> 00:11:54.860
需要大量的内存增加

00:11:52.339 --> 00:11:58.550
增加延迟，因为在这种情况下

00:11:54.860 --> 00:12:00.560
您想要一种想要的过程

00:11:58.550 --> 00:12:02.690
抗议真正的事情

00:12:00.560 --> 00:12:05.420
并发环境几乎不会

00:12:02.690 --> 00:12:07.310
可能真正做到一些

00:12:05.420 --> 00:12:11.300
正确安排一切，这就是为什么

00:12:07.310 --> 00:12:13.399
 11c将显着增加， 

00:12:11.300 --> 00:12:15.680
最终，这样做很容易

00:12:13.399 --> 00:12:17.600
申请，因为有人可以

00:12:15.680 --> 00:12:20.269
了解多少内存

00:12:17.600 --> 00:12:22.670
为您的应用分配并做一些

00:12:20.269 --> 00:12:26.240
这样的事情像万岁连接

00:12:22.670 --> 00:12:28.970
它会粉碎一个人真正能够做到的- 

00:12:26.240 --> 00:12:31.399
您的服务器，这就是为什么我们需要

00:12:28.970 --> 00:12:33.680
非阻塞I / O，让我们尝试

00:12:31.399 --> 00:12:36.110
了解什么不阻止I / O和

00:12:33.680 --> 00:12:38.510
依靠阻止I / O看起来像这样

00:12:36.110 --> 00:12:41.959
首先在非阻塞I / O 

00:12:38.510 --> 00:12:44.540
最主要的是一切

00:12:41.959 --> 00:12:47.209
服务器套接字通道服务器套接字

00:12:44.540 --> 00:12:50.870
频道还有另一种文化成分

00:12:47.209 --> 00:12:54.050
或非阻塞执行的一部分

00:12:50.870 --> 00:12:55.910
被称为选择器，所以使用选择器

00:12:54.050 --> 00:12:57.379
例如可以开始听

00:12:55.910 --> 00:13:00.859
进来的罐头

00:12:57.379 --> 00:13:03.049
动作，例如使用操作

00:13:00.859 --> 00:13:05.149
除非如此，一旦您有了新的

00:13:03.049 --> 00:13:08.689
连接服务器通道将

00:13:05.149 --> 00:13:12.019
关于新用户或新连接的问题

00:13:08.689 --> 00:13:13.819
用几句话打开它，接下来一次

00:13:12.019 --> 00:13:16.069
您与服务器建立了新连接

00:13:13.819 --> 00:13:19.069
你必须听一些数据

00:13:16.069 --> 00:13:21.679
但我想强调的是

00:13:19.069 --> 00:13:24.499
在这里你不能只对服务器说

00:13:21.679 --> 00:13:27.470
现在服务服务器套接字通道

00:13:24.499 --> 00:13:30.049
想听操作现在读

00:13:27.470 --> 00:13:32.209
你必须去连接使用

00:13:30.049 --> 00:13:34.189
相同的选择器，但现在您有了

00:13:32.209 --> 00:13:36.379
将此选择器注册到此套接字

00:13:34.189 --> 00:13:38.929
引导您的作品的这个房屋插座

00:13:36.379 --> 00:13:41.509
你不能只在同一个地方做

00:13:38.929 --> 00:13:43.939
您必须拆分的所有内容

00:13:41.509 --> 00:13:46.220
做更多的动作和更多的锻炼

00:13:43.939 --> 00:13:48.319
为了开始听特定的

00:13:46.220 --> 00:13:51.319
此连接和此事件

00:13:48.319 --> 00:13:53.869
 SS对我来说不是很好的设计

00:13:51.319 --> 00:13:57.679
好的，但是接下来呢

00:13:53.869 --> 00:14:00.709
好吧，假设您有一些字节

00:13:57.679 --> 00:14:02.569
当然要开始的数据

00:14:00.709 --> 00:14:04.339
正常阅读它们

00:14:02.569 --> 00:14:06.499
操作，所以你想开始

00:14:04.339 --> 00:14:08.689
处理您抗议的数据的日期

00:14:06.499 --> 00:14:10.489
他们，你想写回去

00:14:08.689 --> 00:14:12.709
对，这是通常的操作，或者

00:14:10.489 --> 00:14:16.459
操作流程，因此您想发送

00:14:12.709 --> 00:14:18.619
这些数据返回，但会发生什么

00:14:16.459 --> 00:14:22.069
可能会发生，只有一部分

00:14:18.619 --> 00:14:24.589
数据可以写入清酒通道

00:14:22.069 --> 00:14:27.709
因为在非阻塞世界中

00:14:24.589 --> 00:14:30.189
不保证连接是TCP 

00:14:27.709 --> 00:14:33.109
连接可以处理所有数据

00:14:30.189 --> 00:14:35.449
这就是为什么它不会阻止以防万一

00:14:33.109 --> 00:14:37.819
例如，您只写了一部分

00:14:35.449 --> 00:14:39.859
您的字节缓冲区，例如您

00:14:37.819 --> 00:14:42.350
必须将此字节缓冲区存储到

00:14:39.859 --> 00:14:44.269
某个地方，然后你必须听

00:14:42.350 --> 00:14:46.819
另一类与

00:14:44.269 --> 00:14:49.429
写，在这种情况下，套接字通道

00:14:46.819 --> 00:14:52.879
一旦有价值就将通知您

00:14:49.429 --> 00:14:53.720
一种空间来写一些数据来做

00:14:52.879 --> 00:14:56.659
再来一次

00:14:53.720 --> 00:14:58.369
它将通知有关写操作

00:14:56.659 --> 00:15:01.999
然后只有在那之后

00:14:58.369 --> 00:15:04.239
能够尝试再次编写它，所以这是

00:15:01.999 --> 00:15:07.940
非阻塞的主要流程

00:15:04.239 --> 00:15:09.950
互动在这里

00:15:07.940 --> 00:15:13.100
从代码看起来如何

00:15:09.950 --> 00:15:15.620
观点，这基本上是主要的

00:15:13.100 --> 00:15:17.480
首先设置非阻塞服务器

00:15:15.620 --> 00:15:20.360
创建开放式套接字所需要做的一切

00:15:17.480 --> 00:15:24.020
通道到特定地址

00:15:20.360 --> 00:15:26.120
类似于阻止I / O，但是

00:15:24.020 --> 00:15:28.520
重要的部分，你必须这样说

00:15:26.120 --> 00:15:29.960
没有阻碍交流，所以您

00:15:28.520 --> 00:15:33.490
必须配置非阻塞

00:15:29.960 --> 00:15:36.830
显然，这是另一个缺点

00:15:33.490 --> 00:15:38.450
您必须打开选择器，这是

00:15:36.830 --> 00:15:41.540
另一部分，你必须开始听

00:15:38.450 --> 00:15:43.370
例如在汁液需求上，然后

00:15:41.540 --> 00:15:46.100
你必须遍历它

00:15:43.370 --> 00:15:48.200
当然这部分你会阻止

00:15:46.100 --> 00:15:50.780
循环执行不仅会旋转您的

00:15:48.200 --> 00:15:52.820
 CPU，但会一直阻塞直到新

00:15:50.780 --> 00:15:55.220
连接，所以一旦你给我一个

00:15:52.820 --> 00:15:57.080
连接选择器将执行

00:15:55.220 --> 00:15:59.990
里面的代码，然后您将能够

00:15:57.080 --> 00:16:02.120
做一些动作好吧，让我们尝试看看

00:15:59.990 --> 00:16:04.370
一旦获得，我们可以在其中做什么

00:16:02.120 --> 00:16:07.250
新连接，例如设置新

00:16:04.370 --> 00:16:09.230
联系我们不得不说，除了

00:16:07.250 --> 00:16:12.170
以非阻塞方式配置它

00:16:09.230 --> 00:16:14.000
再一次，然后我们必须把它放在一些

00:16:12.170 --> 00:16:16.820
收集，因为没有其他方法

00:16:14.000 --> 00:16:18.860
存储我们必须做的连接

00:16:16.820 --> 00:16:20.600
自己管理他们，这是

00:16:18.860 --> 00:16:23.420
发生的另一个挑战是

00:16:20.600 --> 00:16:25.940
无阻塞挂断最后我们要

00:16:23.420 --> 00:16:27.830
注册您已经准备好

00:16:25.940 --> 00:16:30.230
向您表明您已准备好

00:16:27.830 --> 00:16:32.030
从此连接读取一些数据，然后

00:16:30.230 --> 00:16:36.140
只有在那之后你才能

00:16:32.030 --> 00:16:38.180
这个例子开始处理数据

00:16:36.140 --> 00:16:40.340
是另一部分，这是相关的一部分

00:16:38.180 --> 00:16:42.710
进行数据读取，因此一旦获得

00:16:40.340 --> 00:16:45.590
关于您可用数据的通知

00:16:42.710 --> 00:16:48.020
必须再次获得频道分配

00:16:45.590 --> 00:16:50.090
一些缓冲区，用于读取数据和

00:16:48.020 --> 00:16:52.640
当然要放一天缓冲

00:16:50.090 --> 00:16:56.180
某个地方，因为目前尚不清楚

00:16:52.640 --> 00:16:58.460
如何将那些缓冲区发送到这些数据

00:16:56.180 --> 00:17:00.790
例如用户逻辑，因为我们

00:16:58.460 --> 00:17:03.650
要建立你想建立一些

00:17:00.790 --> 00:17:05.870
一些普通的服务器，它允许每个人

00:17:03.650 --> 00:17:08.840
放置一个列表节点，放置一个侦听器， 

00:17:05.870 --> 00:17:10.790
然后抗议每个字节缓冲区

00:17:08.840 --> 00:17:12.890
来自连接和

00:17:10.790 --> 00:17:15.860
如何在这个模型中做到这一点

00:17:12.890 --> 00:17:19.100
我不知道的另一个挑战

00:17:15.860 --> 00:17:20.530
如何-正确地解决这个问题，因为

00:17:19.100 --> 00:17:22.570
需要使用

00:17:20.530 --> 00:17:24.850
定性编程，因为发音

00:17:22.570 --> 00:17:28.000
一切都在命令式编程中

00:17:24.850 --> 00:17:33.220
它可能很少而且经常很清楚

00:17:28.000 --> 00:17:34.900
至于我，最后一次，我们写了一次

00:17:33.220 --> 00:17:37.420
我们从

00:17:34.900 --> 00:17:40.180
你想说的联系好吧让我

00:17:37.420 --> 00:17:42.850
知道什么时候可以回写一些数据

00:17:40.180 --> 00:17:45.700
到这个频道，一旦我们得到另一个

00:17:42.850 --> 00:17:48.400
 K通知，我们将可以开始

00:17:45.700 --> 00:17:50.950
将数据写入通道是的，我们有

00:17:48.400 --> 00:17:53.170
定义与此相关的视图

00:17:50.950 --> 00:17:55.930
渠道，然后我们将

00:17:53.170 --> 00:17:57.970
不得不迭代地活写这个

00:17:55.930 --> 00:17:59.860
数据返回到通道，所以这是

00:17:57.970 --> 00:18:02.800
基本上这样会发生什么

00:17:59.860 --> 00:18:04.840
写完之后执行

00:18:02.800 --> 00:18:07.150
你所拥有的一切，你不得不说

00:18:04.840 --> 00:18:10.000
同样，我不会听数据

00:18:07.150 --> 00:18:13.270
这基本上是他们的第四个工作流程

00:18:10.000 --> 00:18:15.160
在非阻塞I / O中，您认为这是一个

00:18:13.270 --> 00:18:18.370
你同意一点点复杂

00:18:15.160 --> 00:18:20.500
是的，这真的很复杂，我

00:18:18.370 --> 00:18:23.650
其实不想解决

00:18:20.500 --> 00:18:25.570
所有这些基础架构代码

00:18:23.650 --> 00:18:28.750
让我们总结一下复杂性在哪里

00:18:25.570 --> 00:18:31.390
首先，尼尔一般是

00:18:28.750 --> 00:18:36.040
它真的设计得很复杂

00:18:31.390 --> 00:18:38.350
那种普通的开发商，只有那种

00:18:36.040 --> 00:18:42.010
可以与异常人一起工作

00:18:38.350 --> 00:18:44.650
没有任何问题的选择器

00:18:42.010 --> 00:18:46.990
和数据绝对无关

00:18:44.650 --> 00:18:49.780
您想要处理数据，您必须

00:18:46.990 --> 00:18:52.630
做很多运动和锻炼来

00:18:49.780 --> 00:18:55.300
使其正确且易于拍摄

00:18:52.630 --> 00:18:58.390
你自己在腿上，这就是为什么

00:18:55.300 --> 00:19:01.450
另一个复杂点

00:18:58.390 --> 00:19:03.370
是的，正确的理由也很复杂

00:19:01.450 --> 00:19:06.070
操作，因为你必须数

00:19:03.370 --> 00:19:08.800
一切都完成了

00:19:06.070 --> 00:19:11.620
好的，现在让我们谈谈如何实施

00:19:08.800 --> 00:19:14.040
我刚才提到的那个设计

00:19:11.620 --> 00:19:17.200
开始如何创造这个美丽

00:19:14.040 --> 00:19:20.700
功能和反应性解决方案位于顶部

00:19:17.200 --> 00:19:24.630
我们的功能性反应新

00:19:20.700 --> 00:19:28.540
实施或API之上

00:19:24.630 --> 00:19:30.880
首先我们要关心回来

00:19:28.540 --> 00:19:33.460
压力和我们想要拥有的

00:19:30.880 --> 00:19:34.420
想要，我们想要一些

00:19:33.460 --> 00:19:36.790
多线程

00:19:34.420 --> 00:19:39.400
当然在先前的解决方案中

00:19:36.790 --> 00:19:43.450
难道这很难解决吗

00:19:39.400 --> 00:19:47.350
一般来说，一旦您开始工作

00:19:43.450 --> 00:19:48.210
你会喜欢在反应堆前面的荷马

00:19:47.350 --> 00:19:52.210
厂

00:19:48.210 --> 00:19:55.360
好吧，总的来说三好

00:19:52.210 --> 00:19:58.750
向知名人士传达好词， 

00:19:55.360 --> 00:20:00.850
说不要从复杂性运行中投票

00:19:58.750 --> 00:20:02.920
从它开始，所以如果您想我们想要

00:20:00.850 --> 00:20:05.770
从中投票要逃避

00:20:02.920 --> 00:20:08.290
这样我们就可以开始运行了

00:20:05.770 --> 00:20:10.480
反应两个流，让我们尝试

00:20:08.290 --> 00:20:12.190
使用同步来实现一切

00:20:10.480 --> 00:20:14.580
非阻塞专业和流

00:20:12.190 --> 00:20:17.440
因为反应堆似乎就是这样

00:20:14.580 --> 00:20:19.690
流模型对于

00:20:17.440 --> 00:20:21.700
谷屋，因为你读什么

00:20:19.690 --> 00:20:24.040
来自连接和连接中的字节

00:20:21.700 --> 00:20:28.570
 general是正确的字节流，所以它

00:20:24.040 --> 00:20:31.240
自然地互相喂食，让我们尝试

00:20:28.570 --> 00:20:33.480
这样做是因为反应性流

00:20:31.240 --> 00:20:37.060
给我们增加背压

00:20:33.480 --> 00:20:39.250
反过来，我们将使用哪一个

00:20:37.060 --> 00:20:41.740
项目因素，因为项目拖拉机

00:20:39.250 --> 00:20:43.270
是第10条的超集

00:20:41.740 --> 00:20:45.430
指令流库this 

00:20:43.270 --> 00:20:49.180
为我们提供的实现

00:20:45.430 --> 00:20:51.910
大量的运营商，它具有

00:20:49.180 --> 00:20:56.020
内置模型非常有用并且

00:20:51.910 --> 00:20:59.260
通过trans进行简单操作，让我们开始

00:20:56.020 --> 00:21:03.250
最后让我们称之为它，然后转到

00:20:59.260 --> 00:21:05.920
我们的代码让我们首先杀死Java 

00:21:03.250 --> 00:21:10.260
这对于杀死Java很重要

00:21:05.920 --> 00:21:14.590
在任何事情之前，让我关闭它， 

00:21:10.260 --> 00:21:18.100
说杀死Java很棒我杀死Java现在

00:21:14.590 --> 00:21:21.190
让我们尝试重写这个家伙，让我们

00:21:18.100 --> 00:21:23.490
首先从我们的反应式API开始

00:21:21.190 --> 00:21:26.680
我们想要实现我们想要写什么

00:21:23.490 --> 00:21:29.110
每次迭代之后，我们都会尝试

00:21:26.680 --> 00:21:30.910
运行这段代码，我们将

00:21:29.110 --> 00:21:31.150
尝试找出它是否有效或

00:21:30.910 --> 00:21:35.230
不

00:21:31.150 --> 00:21:37.930
好吧，希望这样做没有道理

00:21:35.230 --> 00:21:40.870
这里是这里，只是必不可少的

00:21:37.930 --> 00:21:43.090
这只是API的实现

00:21:40.870 --> 00:21:45.040
会说我们的反应式服务器

00:21:43.090 --> 00:21:45.670
引擎盖我们什么都没有，所以如果

00:21:45.040 --> 00:21:48.010
你要去

00:21:45.670 --> 00:21:50.530
这是实现，我们将看到空的

00:21:48.010 --> 00:21:52.929
空的实现和

00:21:50.530 --> 00:21:55.840
我们将要开始的那一点

00:21:52.929 --> 00:21:58.840
实施一切，以便

00:21:55.840 --> 00:22:02.230
因为我们所有的东西都是反应性的，所以我们

00:21:58.840 --> 00:22:04.120
必须返回我们的那种服务器

00:22:02.230 --> 00:22:06.790
必须启动服务器或

00:22:04.120 --> 00:22:08.020
同步，我们必须写每个

00:22:06.790 --> 00:22:10.420
在同步中说出一切

00:22:08.020 --> 00:22:15.549
时尚，这就是为什么我要去做

00:22:10.420 --> 00:22:19.540
从写那个不是那个开始

00:22:15.549 --> 00:22:21.340
是一些启动操作，所以该怎么办

00:22:19.540 --> 00:22:24.160
我们首先在这里做，我们写了一个

00:22:21.340 --> 00:22:27.030
听一些方便的方法

00:22:24.160 --> 00:22:29.799
订户，所以我们想创建一些

00:22:27.030 --> 00:22:32.590
在这种情况下的数据源

00:22:29.799 --> 00:22:34.299
将新的连接推送到下游

00:22:32.590 --> 00:22:38.320
当然我们会忽略他们，因为

00:22:34.299 --> 00:22:42.100
是不是首先我们不重要

00:22:38.320 --> 00:22:44.169
顶部，但这就是我们开始的方式，然后我们

00:22:42.100 --> 00:22:46.240
想要拥有你想要拥有我们想要

00:22:44.169 --> 00:22:49.480
运行我们的主要业务逻辑

00:22:46.240 --> 00:22:52.840
隐藏在我们的推送或我们的内部

00:22:49.480 --> 00:22:54.850
在不同线程上的一种来源

00:22:52.840 --> 00:22:56.770
为此，我们创建另一个调度程序

00:22:54.850 --> 00:22:58.630
所以调度程序是项目的一部分

00:22:56.770 --> 00:23:01.120
反应堆，使我们能够创建一个

00:22:58.630 --> 00:23:04.179
好的线程池

00:23:01.120 --> 00:23:08.350
这部分逻辑将运行将

00:23:04.179 --> 00:23:10.690
跑得好吗，然后我们就忽略了

00:23:08.350 --> 00:23:13.210
一切并转换我们的通量来

00:23:10.690 --> 00:23:15.730
继续，下一步就是

00:23:13.210 --> 00:23:19.570
当然写和执行一些

00:23:15.730 --> 00:23:21.669
普通的新互动，因此开始

00:23:19.570 --> 00:23:23.950
工作这个新的，你只需要

00:23:21.669 --> 00:23:30.150
像这样停止几行代码

00:23:23.950 --> 00:23:32.950
真的很容易，是的，我决定

00:23:30.150 --> 00:23:35.470
简化并牺牲解释和

00:23:32.950 --> 00:23:37.450
我自己写东西

00:23:35.470 --> 00:23:39.669
所以我要解释发生了什么

00:23:37.450 --> 00:23:40.299
这与您在

00:23:39.669 --> 00:23:42.669
滑梯

00:23:40.299 --> 00:23:44.350
这是套接字通道的启动

00:23:42.669 --> 00:23:46.750
将其标记为非阻塞

00:23:44.350 --> 00:23:49.660
然后我打开选择器以听

00:23:46.750 --> 00:23:52.780
给您执行此操作

00:23:49.660 --> 00:23:55.480
选择器键，然后执行一些操作

00:23:52.780 --> 00:23:57.700
为了听例如

00:23:55.480 --> 00:23:59.260
取消流，所以有一个

00:23:57.700 --> 00:24:01.830
方便的聆听方式

00:23:59.260 --> 00:24:04.900
在处置时同步的取消

00:24:01.830 --> 00:24:07.000
处理程序，以这种方式，一旦我得到

00:24:04.900 --> 00:24:10.000
取消实际上我只会关闭

00:24:07.000 --> 00:24:12.160
我的服务器，就是这样，我们有了

00:24:10.000 --> 00:24:14.710
循环将一直运行到

00:24:12.160 --> 00:24:15.910
某些东西被取消了，这是

00:24:14.710 --> 00:24:19.390
您以前见过的选择

00:24:15.910 --> 00:24:22.660
正确的代码，现在我们要

00:24:19.390 --> 00:24:25.900
只是尝试实现部分逻辑

00:24:22.660 --> 00:24:28.150
在这里，但我们必须了解做什么

00:24:25.900 --> 00:24:30.700
我们想在这里有我们只想

00:24:28.150 --> 00:24:32.860
通过这个动作我们在这个B 

00:24:30.700 --> 00:24:35.260
只需接受新的连接权限

00:24:32.860 --> 00:24:37.090
所以这个家伙又回到了另一个插座

00:24:35.260 --> 00:24:39.640
表示连接的通道

00:24:37.090 --> 00:24:41.860
在我们的客户和我们之间

00:24:39.640 --> 00:24:44.260
我们在服务器端处理它

00:24:41.860 --> 00:24:47.590
现在将其标记为非阻塞

00:24:44.260 --> 00:24:49.420
另一种表示形式或

00:24:47.590 --> 00:24:52.090
围绕它的实现

00:24:49.420 --> 00:24:54.400
为我们提供反应式API， 

00:24:52.090 --> 00:24:56.530
应该听起来有点像

00:24:54.400 --> 00:24:58.450
连接权，你想一些

00:24:56.530 --> 00:25:00.670
套接字通道周围的包装器将

00:24:58.450 --> 00:25:02.830
被命名为连接，所以我在这里

00:25:00.670 --> 00:25:05.470
该接口有色连接

00:25:02.830 --> 00:25:07.810
我只提到了两种方法

00:25:05.470 --> 00:25:09.790
在幻灯片上，第一个允许我们

00:25:07.810 --> 00:25:12.850
聆听缓冲区的增量

00:25:09.790 --> 00:25:15.670
第二个将简单地允许我们

00:25:12.850 --> 00:25:16.330
将那些数据发送回流是

00:25:15.670 --> 00:25:19.060
很清楚

00:25:16.330 --> 00:25:21.970
简单的界面，让我们转到

00:25:19.060 --> 00:25:24.100
占位符的实现

00:25:21.970 --> 00:25:26.230
没有任何东西的类

00:25:24.100 --> 00:25:27.970
到目前为止的实现

00:25:26.230 --> 00:25:30.460
点，我们将执行其余的

00:25:27.970 --> 00:25:33.430
同步，所以首先我们必须

00:25:30.460 --> 00:25:36.580
提供一点数据或信息

00:25:33.430 --> 00:25:39.700
关于外界的这种联系

00:25:36.580 --> 00:25:42.460
首先要提什么经文

00:25:39.700 --> 00:25:44.860
是那种联系会是

00:25:42.460 --> 00:25:47.470
您将负责数据读取

00:25:44.860 --> 00:25:49.840
和写作日期，我们不想

00:25:47.470 --> 00:25:52.500
将此责任转移到主要

00:25:49.840 --> 00:25:56.170
服务器引擎，因为它将

00:25:52.500 --> 00:25:59.140
这些让我们感到困惑的每一个

00:25:56.170 --> 00:26:02.590
与此代码一起轻松使用

00:25:59.140 --> 00:26:06.070
这就是为什么我们要问主要

00:26:02.590 --> 00:26:08.650
服务器需要某种主要的

00:26:06.070 --> 00:26:11.470
例如某些领域的领域

00:26:08.650 --> 00:26:12.760
与套接字通道有关，所以我们会问

00:26:11.470 --> 00:26:15.010
用于连接

00:26:12.760 --> 00:26:19.090
或电路的实际表示

00:26:15.010 --> 00:26:21.580
来自GDK neo的频道，我们也是

00:26:19.090 --> 00:26:25.810
要问，以便那种

00:26:21.580 --> 00:26:28.030
分离服务器引擎和我们的引擎

00:26:25.810 --> 00:26:30.550
从我们的选择或选择的来源

00:26:28.030 --> 00:26:33.340
连接我们想要一些

00:26:30.550 --> 00:26:36.850
通知或聆听方式

00:26:33.340 --> 00:26:39.280
来自的一些新通知或操作

00:26:36.850 --> 00:26:43.060
主机，因为这是善良的

00:26:39.280 --> 00:26:46.390
我们可以使用相同的更新流

00:26:43.060 --> 00:26:49.240
使用项目的一种编程模型

00:26:46.390 --> 00:26:51.730
使用项目反应堆，基本上什么时候

00:26:49.240 --> 00:26:54.670
我们想听听你的声音，例如

00:26:51.730 --> 00:26:57.070
阅读更新或阅读能力

00:26:54.670 --> 00:26:59.560
从我们要订阅的连接

00:26:57.070 --> 00:27:01.810
对某些数据流相同

00:26:59.560 --> 00:27:03.220
如果您也想阅读的话

00:27:01.810 --> 00:27:06.280
你想听一些写

00:27:03.220 --> 00:27:08.980
更新或关于我们的一些通知

00:27:06.280 --> 00:27:10.570
可以向您写入数据

00:27:08.980 --> 00:27:14.290
你想听洪水的连接

00:27:10.570 --> 00:27:15.880
另一个性选择键的

00:27:14.290 --> 00:27:19.360
我们想要拥有什么，这里有一些

00:27:15.880 --> 00:27:22.260
这个这个的基础建设

00:27:19.360 --> 00:27:25.240
部分我们不想深入探讨

00:27:22.260 --> 00:27:28.270
更深入，但现在我们想尝试

00:27:25.240 --> 00:27:30.760
工具正在接收和发送逻辑

00:27:28.270 --> 00:27:33.400
为了接收数据，我们必须

00:27:30.760 --> 00:27:35.740
听阅读通知--和阅读种类

00:27:33.400 --> 00:27:37.480
正确的通知，所以一旦我们得到

00:27:35.740 --> 00:27:40.600
我们可以阅读的通知

00:27:37.480 --> 00:27:43.180
从这个东西

00:27:40.600 --> 00:27:46.360
连接，我们应该从中读取

00:27:43.180 --> 00:27:48.160
基本上我们必须使用我们的阅读

00:27:46.360 --> 00:27:51.630
在火上开始听

00:27:48.160 --> 00:27:55.150
另一方面开始听

00:27:51.630 --> 00:27:56.830
阅读事件，我们必须注册某种

00:27:55.150 --> 00:27:59.050
听众，我们必须记住

00:27:56.830 --> 00:28:03.220
他们已经在

00:27:59.050 --> 00:28:06.280
与两个Z有关的幻灯片让我

00:28:03.220 --> 00:28:10.000
再次向您展示以获取新的

00:28:06.280 --> 00:28:12.640
您必须定义更新才能看到它

00:28:10.000 --> 00:28:14.890
不得不说我想听阅读

00:28:12.640 --> 00:28:17.620
更新正确，但主要问题

00:28:14.890 --> 00:28:20.280
因为我们所有的东西都是反应性的，如果

00:28:17.620 --> 00:28:22.660
我们将看看我们的

00:28:20.280 --> 00:28:24.520
业务逻辑和此业务逻辑

00:28:22.660 --> 00:28:25.890
可以用完全不同的方式写

00:28:24.520 --> 00:28:27.540
很生气

00:28:25.890 --> 00:28:29.760
例如，我们可以延迟我们的

00:28:27.540 --> 00:28:32.040
订阅我们可以做一些同步

00:28:29.760 --> 00:28:33.960
我们可以发送的动作我们可以创建一些

00:28:32.040 --> 00:28:36.420
代理服务器将数据发送到

00:28:33.960 --> 00:28:39.390
另一个服务器，当然我们不

00:28:36.420 --> 00:28:41.910
知道我们什么时候得到例如

00:28:39.390 --> 00:28:44.520
端点或消费者逻辑

00:28:41.910 --> 00:28:46.470
能够开始监听数据

00:28:44.520 --> 00:28:48.720
这就是为什么我们不想开始

00:28:46.470 --> 00:28:51.890
听得太早了，所以我们不想

00:28:48.720 --> 00:28:54.600
太早注册，无法读取

00:28:51.890 --> 00:28:57.330
通知，这就是为什么我们想要一个

00:28:54.600 --> 00:28:59.700
仅当且仅当

00:28:57.330 --> 00:29:02.100
我们的业务逻辑给我们带来了

00:28:59.700 --> 00:29:04.920
订阅或通知

00:29:02.100 --> 00:29:08.400
准备方便的聆听方式

00:29:04.920 --> 00:29:11.750
您采取这种行动当然是通过

00:29:08.400 --> 00:29:14.670
通过听或通过添加运算符

00:29:11.750 --> 00:29:17.430
订阅取消订阅及其内容

00:29:14.670 --> 00:29:21.120
给我们，所以一旦有人订阅

00:29:17.430 --> 00:29:23.040
我们绝对是

00:29:21.120 --> 00:29:26.010
准备开始做某事，这

00:29:23.040 --> 00:29:29.030
将是重点和主要种类

00:29:26.010 --> 00:29:31.800
我们聆听的起点

00:29:29.030 --> 00:29:34.170
阅读通知，所以我们要去

00:29:31.800 --> 00:29:37.230
我们将要做的是

00:29:34.170 --> 00:29:43.200
实现类似的东西

00:29:37.230 --> 00:29:45.570
抱歉，我们在这里吃了接收器，我们

00:29:43.200 --> 00:29:47.940
去，这是我们首先要写的

00:29:45.570 --> 00:29:50.040
我们必须添加一种处理

00:29:47.940 --> 00:29:52.770
因为不要订阅动作，所以一旦我们

00:29:50.040 --> 00:29:55.410
得到订户，我们将尝试找到我们的

00:29:52.770 --> 00:29:58.260
选择器，我们将要注册

00:29:55.410 --> 00:30:00.900
我们的套接字通道的选择器和

00:29:58.260 --> 00:30:03.570
这样就唤醒了整个执行过程

00:30:00.900 --> 00:30:07.110
说好吧，我们已经准备好向您

00:30:03.570 --> 00:30:09.240
读取数据我们可以，然后为了

00:30:07.110 --> 00:30:10.980
保留最新的选择键，因为

00:30:09.240 --> 00:30:13.170
这很重要，这是另一个技巧

00:30:10.980 --> 00:30:15.600
您不能使用相同的选择键

00:30:13.170 --> 00:30:18.120
到处都必须听新歌

00:30:15.600 --> 00:30:21.480
更新，以防万一您将尝试

00:30:18.120 --> 00:30:23.250
使用较旧的

00:30:21.480 --> 00:30:25.770
在其他事件中注册，这是

00:30:23.250 --> 00:30:29.010
这个新人的另一个问题

00:30:25.770 --> 00:30:32.190
每次新更新每次新选择键

00:30:29.010 --> 00:30:34.920
通知，您必须将其存储在

00:30:32.190 --> 00:30:36.720
当然，这部分

00:30:34.920 --> 00:30:39.750
代码允许我们清理连接

00:30:36.720 --> 00:30:42.570
例如取消动作

00:30:39.750 --> 00:30:45.690
这是逻辑的主要部分

00:30:42.570 --> 00:30:48.600
允许我们从

00:30:45.690 --> 00:30:50.700
引导茶种子，然后以防万一

00:30:48.600 --> 00:30:53.010
通道中有一些数据，我们将

00:30:50.700 --> 00:30:56.220
尝试打磨它，我想付你

00:30:53.010 --> 00:30:58.140
注意，我们当然可以写

00:30:56.220 --> 00:31:01.740
这样的事情让我告诉你我们

00:30:58.140 --> 00:31:05.520
可以写像这样的东西

00:31:01.740 --> 00:31:11.000
写这样的东西，当然

00:31:05.520 --> 00:31:11.000
我们可以这样写

00:31:15.140 --> 00:31:20.580
但我想引起您的注意

00:31:17.610 --> 00:31:22.320
现在交互式流是一个滞后哦

00:31:20.580 --> 00:31:26.490
可能会尝试这样做

00:31:22.320 --> 00:31:28.440
一旦获得，立即将其返回给您

00:31:26.490 --> 00:31:30.690
您的地图运营商，我们将获得

00:31:28.440 --> 00:31:32.820
异常将关闭您的反应

00:31:30.690 --> 00:31:38.130
记住重要的一点是

00:31:32.820 --> 00:31:40.890
 null是一种禁止的结果

00:31:38.130 --> 00:31:43.980
例如映射，您就无法发送

00:31:40.890 --> 00:31:46.080
数据发布期间的任何公告

00:31:43.980 --> 00:31:49.160
这很重要，这就是为什么

00:31:46.080 --> 00:31:53.040
还有另一种可以方便的方法

00:31:49.160 --> 00:31:55.860
在句柄运算符中实现它以及什么

00:31:53.040 --> 00:31:58.230
如果有一些数据就必须要做

00:31:55.860 --> 00:32:00.090
为您提供一些让我满意的东西

00:31:58.230 --> 00:32:02.430
用in匿名替换lambda 

00:32:00.090 --> 00:32:04.860
它为您提供同步的类

00:32:02.430 --> 00:32:08.070
以及在此期间您需要做什么

00:32:04.860 --> 00:32:11.460
执行，你必须要么

00:32:08.070 --> 00:32:14.640
接下来执行此同步，否则您可以

00:32:11.460 --> 00:32:16.920
轻松完成同一执行

00:32:14.640 --> 00:32:19.140
东西，所以你有种可以保留的东西

00:32:16.920 --> 00:32:20.760
掌握我所见过的一切

00:32:19.140 --> 00:32:23.370
流里面发生了什么

00:32:20.760 --> 00:32:26.070
是重要的部分，这使我们能够

00:32:23.370 --> 00:32:29.220
发送一些数据或只是过滤或

00:32:26.070 --> 00:32:31.710
跳过事件，这是重要的部分

00:32:29.220 --> 00:32:34.710
你必须记住的反应堆

00:32:31.710 --> 00:32:36.360
好的，让我们去发送数据

00:32:34.710 --> 00:32:39.600
基本上要在数据上做

00:32:36.360 --> 00:32:41.970
您必须订阅的被判刑部分

00:32:39.600 --> 00:32:44.190
您到小溪，因为我们想像我

00:32:41.970 --> 00:32:46.020
提到我们必须保持所有逻辑

00:32:44.190 --> 00:32:48.360
在里面阅读和写作

00:32:46.020 --> 00:32:51.330
连接，因为连接是一部分

00:32:48.360 --> 00:32:52.820
负责各种互动

00:32:51.330 --> 00:32:55.160
这是真正的联系

00:32:52.820 --> 00:32:57.350
这就是为什么我们要做所有这些事情

00:32:55.160 --> 00:32:59.600
内部连接，当然我们有

00:32:57.350 --> 00:33:04.520
创建订户，但如您所见

00:32:59.600 --> 00:33:06.460
订户是我们的一种

00:33:04.520 --> 00:33:08.450
必须写一点

00:33:06.460 --> 00:33:10.610
这就是为什么实现

00:33:08.450 --> 00:33:12.590
也许想使用一些方便的等待

00:33:10.610 --> 00:33:16.250
用于项目反应堆到达的项目

00:33:12.590 --> 00:33:18.200
基本订户，但总的来说我不

00:33:16.250 --> 00:33:20.540
要创建另一个对象，因为

00:33:18.200 --> 00:33:23.630
给您更多对象垃圾回收器

00:33:20.540 --> 00:33:25.490
越多，获得的性能就越少

00:33:23.630 --> 00:33:28.520
想要减少对您的对象

00:33:25.490 --> 00:33:31.220
这就是为什么我们的环境更加友善

00:33:28.520 --> 00:33:36.350
方便的方法就是

00:33:31.220 --> 00:33:38.330
扩展这样的订户并

00:33:36.350 --> 00:33:40.220
在内部实现这种简单的逻辑

00:33:38.330 --> 00:33:42.410
同一壁橱，这不会是

00:33:40.220 --> 00:33:47.180
禁止，所以我们想要拥有我们

00:33:42.410 --> 00:33:49.460
想要拥有字节缓冲区订户

00:33:47.180 --> 00:33:52.580
在这里实施，我们正在寻找

00:33:49.460 --> 00:33:54.500
我们需要的两种主要方法

00:33:52.580 --> 00:33:57.290
我们的实现第一个是谁

00:33:54.500 --> 00:34:00.170
退订，这使我们可以覆盖

00:33:57.290 --> 00:34:03.980
对底层的一种操纵

00:34:00.170 --> 00:34:06.410
订阅并立即用于订阅

00:34:03.980 --> 00:34:08.750
我们可以说多少个对象或多少个

00:34:06.410 --> 00:34:11.900
我们准备好阅读的元素

00:34:08.750 --> 00:34:14.780
是一种开始控制的方式

00:34:11.900 --> 00:34:17.480
在上游之间进行流量控制

00:34:14.780 --> 00:34:20.330
和下游，在这一点上， 

00:34:17.480 --> 00:34:22.310
从头开始一切

00:34:20.330 --> 00:34:26.060
我们只想要求一个死刑犯

00:34:22.310 --> 00:34:28.460
从连接缓冲，这将

00:34:26.060 --> 00:34:30.560
另一方面，我们开始执行

00:34:28.460 --> 00:34:32.990
想听一些传入的字节

00:34:30.560 --> 00:34:35.980
缓冲，所以我们想覆盖谁来

00:34:32.990 --> 00:34:38.960
接下来你想听你的

00:34:35.980 --> 00:34:40.610
我们想要做什么的传入缓冲区

00:34:38.960 --> 00:34:47.169
想写一些简单的代码

00:34:40.610 --> 00:34:50.990
像这样不是像这样而是对的

00:34:47.169 --> 00:34:53.120
你想写一些简单的作品

00:34:50.990 --> 00:34:55.669
像这样的代码

00:34:53.120 --> 00:34:59.840
将其写入八个到电路通道

00:34:55.669 --> 00:35:02.270
情况下，我们得到了一些-1 

00:34:59.840 --> 00:35:04.400
这意味着有些事情

00:35:02.270 --> 00:35:06.290
我们的联系，所以我们只需要

00:35:04.400 --> 00:35:09.920
取消执行

00:35:06.290 --> 00:35:12.140
那你想做什么

00:35:09.920 --> 00:35:14.630
万一一切都很好，我们已经

00:35:12.140 --> 00:35:16.160
写下了我们必须简单地完成的所有数据

00:35:14.630 --> 00:35:18.170
要求另一种自然

00:35:16.160 --> 00:35:20.090
对，这是最简单的执行

00:35:18.170 --> 00:35:22.820
你写了一些约会，我们

00:35:20.090 --> 00:35:23.930
请求它再获取几个字节的数据

00:35:22.820 --> 00:35:26.120
就是这样

00:35:23.930 --> 00:35:29.000
当然有一些极端的情况

00:35:26.120 --> 00:35:31.760
例如，在这里想象一下你

00:35:29.000 --> 00:35:34.100
你不能写东西吗

00:35:31.760 --> 00:35:36.230
一次连接一切

00:35:34.100 --> 00:35:39.500
当然，您必须将其存储

00:35:36.230 --> 00:35:41.900
缓冲，因为现在我们必须听

00:35:39.500 --> 00:35:44.870
写更新，所以我们必须存储接收

00:35:41.900 --> 00:35:48.950
通过缓冲区将其移至此处的字段

00:35:44.870 --> 00:35:51.710
我打了他，我打了，现在我们必须

00:35:48.950 --> 00:35:53.780
通过缓冲区将其存储在这里，我们必须

00:35:51.710 --> 00:35:56.330
再次与选择键进行交互， 

00:35:53.780 --> 00:35:58.820
定义我们的倾听意图

00:35:56.330 --> 00:36:02.240
更新，但现在的问题是我们将如何

00:35:58.820 --> 00:36:05.330
收到有关此写入更新的通知，我们

00:36:02.240 --> 00:36:08.660
有此通知流，所以我们

00:36:05.330 --> 00:36:11.060
必须以某种方式使用它，我们必须使用它

00:36:08.660 --> 00:36:12.830
在执行的开始

00:36:11.060 --> 00:36:15.860
从一开始

00:36:12.830 --> 00:36:17.360
执行当然是退订的

00:36:15.860 --> 00:36:19.460
方法，因为一旦我们得到

00:36:17.360 --> 00:36:21.520
订阅运行时具有的所有内容

00:36:19.460 --> 00:36:24.080
开始，这就是为什么我们必须把

00:36:21.520 --> 00:36:26.450
我们正在听写的互动

00:36:24.080 --> 00:36:29.210
在这里更新，它将看起来像

00:36:26.450 --> 00:36:31.240
所以我们做什么我们做什么

00:36:29.210 --> 00:36:33.760
基本上我们在这里听

00:36:31.240 --> 00:36:36.530
在这种情况下有关权利的通知

00:36:33.760 --> 00:36:38.540
关于正确的选择键，这将是

00:36:36.530 --> 00:36:41.870
正确的选择键，一旦我们得到它

00:36:38.540 --> 00:36:43.780
我们现在只需要再说一次

00:36:41.870 --> 00:36:45.920
停下来让你找到我的恐惧

00:36:43.780 --> 00:36:48.470
可用性，因为万一您不会

00:36:45.920 --> 00:36:52.040
这样做只会旋转处理器

00:36:48.470 --> 00:36:54.290
每秒发送一次

00:36:52.040 --> 00:36:55.970
准备写我可以写一些

00:36:54.290 --> 00:36:58.130
数据，我能够写一些数据， 

00:36:55.970 --> 00:37:01.310
这是我们不想拥有的

00:36:58.130 --> 00:37:03.470
这就是为什么我们一旦

00:37:01.310 --> 00:37:05.930
收到有关阅读类型的通知

00:37:03.470 --> 00:37:08.150
他们说的写能力好吧，现在我们要

00:37:05.930 --> 00:37:10.280
阅读听阅读不要让你

00:37:08.150 --> 00:37:14.570
找到我关于写更新，然后

00:37:10.280 --> 00:37:16.420
他们必须仍然是，这部分应该

00:37:14.570 --> 00:37:18.700
隐藏起来，我们也会回到这个

00:37:16.420 --> 00:37:23.110
稍后，但基本上我们要做的是

00:37:18.700 --> 00:37:25.810
我们必须发送我们的尝试，我们将

00:37:23.110 --> 00:37:28.900
以前在缓冲区发送相同的存储

00:37:25.810 --> 00:37:31.440
二要执行的主要逻辑是

00:37:28.900 --> 00:37:34.270
之后我们要做什么，所以一旦我们

00:37:31.440 --> 00:37:37.570
收到有关恐惧能力的通知

00:37:34.270 --> 00:37:39.850
这意味着我们有一些数据要写

00:37:37.570 --> 00:37:42.640
我们必须尝试将其写回

00:37:39.850 --> 00:37:44.680
一次又一次，如果一切都

00:37:42.640 --> 00:37:47.950
成功的我们将要求一些

00:37:44.680 --> 00:37:50.530
来自评论流中的新字节，因此

00:37:47.950 --> 00:37:52.570
这是整个执行模型，所以

00:37:50.530 --> 00:37:55.330
让我们检查是否是

00:37:52.570 --> 00:37:57.130
订阅这里，我们必须写一些

00:37:55.330 --> 00:37:59.320
代码行，因为一切都应该

00:37:57.130 --> 00:38:02.230
成为同步和被动的，所以我们有

00:37:59.320 --> 00:38:05.800
仅当有人时才开始每个场景

00:38:02.230 --> 00:38:09.130
订阅我们的沙子模型，所以

00:38:05.800 --> 00:38:11.170
为什么我们必须使用可运行的

00:38:09.130 --> 00:38:13.390
做这样的事情，然后我们

00:38:11.170 --> 00:38:15.700
必须打开它之后，我们必须

00:38:13.390 --> 00:38:18.580
订阅我们的数据流

00:38:15.700 --> 00:38:22.390
黑色应该看起来像这样

00:38:18.580 --> 00:38:25.480
让我们尝试最终确定一切

00:38:22.390 --> 00:38:27.610
尝试在这里放置一些逻辑

00:38:25.480 --> 00:38:30.330
我们现在必须要做的是

00:38:27.610 --> 00:38:32.830
做一些过程

00:38:30.330 --> 00:38:35.080
通知或通知流

00:38:32.830 --> 00:38:37.990
管理，以便提供我们的

00:38:35.080 --> 00:38:42.100
连接，所以在这里我们有我们的双X 

00:38:37.990 --> 00:38:44.800
我们在这里提供的连接

00:38:42.100 --> 00:38:47.200
用某种方式通知

00:38:44.800 --> 00:38:49.510
读取流的实现方式

00:38:47.200 --> 00:38:51.760
然后写入，其中之一是

00:38:49.510 --> 00:38:54.190
手动，因此很容易流

00:38:51.760 --> 00:38:57.790
因为我们要手动将数据推送到

00:38:54.190 --> 00:39:00.280
我们想要基本用于的流

00:38:57.790 --> 00:39:02.400
示例处理器，因为处理器是

00:39:00.280 --> 00:39:05.110
反应性流的一部分

00:39:02.400 --> 00:39:09.030
它为您提供的规格

00:39:05.110 --> 00:39:11.710
实施我们的保护

00:39:09.030 --> 00:39:14.710
发布者和订阅者如此基本

00:39:11.710 --> 00:39:16.960
下游可以做什么？ 

00:39:14.710 --> 00:39:19.330
到小溪，你可以做什么

00:39:16.960 --> 00:39:21.610
您可以使用示例方法，例如on 

00:39:19.330 --> 00:39:24.400
接下来为了将数据推送到您的

00:39:21.610 --> 00:39:29.140
手动订阅者，因此这是一种方法

00:39:24.400 --> 00:39:30.309
做到这一点，一旦我们提供了一切

00:39:29.140 --> 00:39:32.859
存放在一些

00:39:30.309 --> 00:39:35.199
在地图中这是必填部分

00:39:32.859 --> 00:39:37.599
管理所有汇，因为我们有

00:39:35.199 --> 00:39:40.269
以某种方式联想到特定

00:39:37.599 --> 00:39:43.479
具有特定种类的处理器

00:39:40.269 --> 00:39:44.670
频道，然后我们必须听

00:39:43.479 --> 00:39:48.339
读

00:39:44.670 --> 00:39:50.829
通知，当然，一旦我们得到

00:39:48.339 --> 00:39:53.739
我们必须找出到哪个

00:39:50.829 --> 00:39:56.019
那种联系有那些

00:39:53.739 --> 00:39:58.150
处理器，然后我们必须发送一个

00:39:56.019 --> 00:40:00.400
对此的特别通知

00:39:58.150 --> 00:40:03.569
处理器，当然我们必须编写

00:40:00.400 --> 00:40:06.880
正确的逻辑完全相同

00:40:03.569 --> 00:40:09.839
为了通知有关写入更新

00:40:06.880 --> 00:40:12.369
或将数据写入通道的能力

00:40:09.839 --> 00:40:14.229
到目前为止还好吗

00:40:12.369 --> 00:40:17.049
清楚一点吗

00:40:14.229 --> 00:40:19.390
信息和标准，但暂时

00:40:17.049 --> 00:40:21.579
是的，这当然很复杂

00:40:19.390 --> 00:40:24.279
部分，但现在我们必须尝试

00:40:21.579 --> 00:40:27.519
当然，我们必须尝试运行此

00:40:24.279 --> 00:40:30.279
起来看看它是否有效

00:40:27.519 --> 00:40:31.869
为了弄清楚我们是否

00:40:30.279 --> 00:40:35.799
带些东西

00:40:31.869 --> 00:40:40.829
首先可以理解和更多的补鞋匠

00:40:35.799 --> 00:40:44.679
因此，让我们尝试打开一个连接

00:40:40.829 --> 00:40:47.829
是的，这似乎很有效

00:40:44.679 --> 00:40:52.809
有点可以理解

00:40:47.829 --> 00:40:55.390
称为Borges的代码，让我们写到

00:40:52.809 --> 00:40:57.189
验证它是否比某种更好

00:40:55.390 --> 00:40:58.719
阻止，你知道这是主要的

00:40:57.189 --> 00:41:02.229
展示所有这些的想法

00:40:58.719 --> 00:41:04.449
更好的API的演示

00:41:02.229 --> 00:41:08.019
让我们尝试运行我们的剂量仪，看看

00:41:04.449 --> 00:41:11.289
是否可以，但我们走吧-哦

00:41:08.019 --> 00:41:13.269
这个家伙的作品很棒，但是我们

00:41:11.289 --> 00:41:16.509
错过了另一点，所以总的来说

00:41:13.269 --> 00:41:19.179
它可以使我们处理所有

00:41:16.509 --> 00:41:22.660
数据，但现在如果您要查看

00:41:19.179 --> 00:41:25.539
我们的显示器，以找出如何

00:41:22.660 --> 00:41:28.329
许多处理器忙于做一些

00:41:25.539 --> 00:41:30.759
工作，我们必须看到哪里在哪里

00:41:28.329 --> 00:41:34.359
是我的CPU在这里，我们将看到

00:41:30.759 --> 00:41:36.489
只有很少的处理器会首先忙

00:41:34.359 --> 00:41:40.539
毕竟是因为整个实施

00:41:36.489 --> 00:41:42.470
我们的业务逻辑是单线程的

00:41:40.539 --> 00:41:46.010
让我告诉你

00:41:42.470 --> 00:41:49.250
现在就来，如果你要去这个

00:41:46.010 --> 00:41:51.800
伙计，我们将看到只有一次抗议

00:41:49.250 --> 00:41:54.140
这里只是一个威胁而已

00:41:51.800 --> 00:41:55.579
一切正常，如果我们要

00:41:54.140 --> 00:41:58.670
我们的联系我们将看到

00:41:55.579 --> 00:42:00.980
基本上所有事情都发生在相同的地方

00:41:58.670 --> 00:42:03.619
威胁我什么都不做

00:42:00.980 --> 00:42:06.349
重新安排每个场景的动作

00:42:03.619 --> 00:42:08.450
在与您不同的威胁下执行

00:42:06.349 --> 00:42:11.960
有什么，所以我们让我们做一个

00:42:08.450 --> 00:42:15.890
几个调试操作让我们将

00:42:11.960 --> 00:42:18.589
这里和这里的几个断点，让我们

00:42:15.890 --> 00:42:21.010
只是尝试运行这个家伙并对其进行调试

00:42:18.589 --> 00:42:26.380
一点点

00:42:21.010 --> 00:42:29.510
来吧伙伴吧，是的，我们走了

00:42:26.380 --> 00:42:32.510
开始一点营销

00:42:29.510 --> 00:42:34.849
为了运行你的咆哮声

00:42:32.510 --> 00:42:41.510
只使用两个选项都喜欢

00:42:34.849 --> 00:42:45.770
我要做的就是吵闹的家伙，现在让我们

00:42:41.510 --> 00:42:48.140
只是尝试打开我们的控制台终端

00:42:45.770 --> 00:42:48.470
意思是并连接到这个家伙，在这里我们

00:42:48.140 --> 00:42:50.750
走

00:42:48.470 --> 00:42:53.750
在这里，我们要取消订阅，所以我们

00:42:50.750 --> 00:42:56.089
接受连接，我们订阅

00:42:53.750 --> 00:42:58.910
它到流，所以我们得到这个不要

00:42:56.089 --> 00:43:00.530
订阅执行，我们只是说

00:42:58.910 --> 00:43:04.280
我们想听就是想读

00:43:00.530 --> 00:43:08.170
一些数据并唤醒，如您所见

00:43:04.280 --> 00:43:11.690
我要打开一点

00:43:08.170 --> 00:43:14.480
广泛地说，我们正在使用默认反应式

00:43:11.690 --> 00:43:19.640
在此线程DC上的服务器一

00:43:14.480 --> 00:43:23.720
记住它，然后让我们去不喜欢

00:43:19.640 --> 00:43:27.230
那是的，是的，不喜欢我在哪里

00:43:23.720 --> 00:43:28.670
是的，我现在在这里尝试发送

00:43:27.230 --> 00:43:31.099
我们去的东西

00:43:28.670 --> 00:43:33.050
我们有另一个断点，您可以

00:43:31.099 --> 00:43:36.200
看到一样的线程是一样的吗

00:43:33.050 --> 00:43:39.560
你看到它的线程是相同的，如果

00:43:36.200 --> 00:43:42.230
您将在此处放置断点

00:43:39.560 --> 00:43:45.980
线程将基本相同

00:43:42.230 --> 00:43:48.109
每次执行每个数据处理都会

00:43:45.980 --> 00:43:50.720
在同一线程上，所以我们必须

00:43:48.109 --> 00:43:53.900
实施一些逻辑，使我们能够

00:43:50.720 --> 00:43:56.030
附加我们的梦想附加我们的梦想

00:43:53.900 --> 00:43:58.490
与特定罐头的连接

00:43:56.030 --> 00:44:00.980
为此而设的踏板池或工人

00:43:58.490 --> 00:44:04.100
我们将使用调度程序，我们将

00:44:00.980 --> 00:44:06.350
创建我们将使用一种预定义的方法

00:44:04.100 --> 00:44:09.080
在反应堆好朋友的并行池中

00:44:06.350 --> 00:44:12.200
调度员或工人，我们会说

00:44:09.080 --> 00:44:14.810
好吧，我们只选择一名工人

00:44:12.200 --> 00:44:17.240
该池以便执行所有操作

00:44:14.810 --> 00:44:19.340
处决了这个工人，因为

00:44:17.240 --> 00:44:21.890
在一个线程上执行最多

00:44:19.340 --> 00:44:24.050
高效率的执行力，这就是我们为什么

00:44:21.890 --> 00:44:26.690
只能在一个工人上使用一个

00:44:24.050 --> 00:44:29.540
但这与

00:44:26.690 --> 00:44:32.510
主要执行逻辑，所以现在让我们开始

00:44:29.540 --> 00:44:34.790
我们为此使用一个运算符

00:44:32.510 --> 00:44:37.970
我们只需要在操作符上发布

00:44:34.790 --> 00:44:38.720
在这里，我们将使用这个

00:44:37.970 --> 00:44:41.240
调度器

00:44:38.720 --> 00:44:43.490
你看到它是不是很容易

00:44:41.240 --> 00:44:45.410
同样，我们必须在这里做，因为现在

00:44:43.490 --> 00:44:47.750
一切都会受到不同的威胁

00:44:45.410 --> 00:44:50.750
我们的品种分化将

00:44:47.750 --> 00:44:53.450
发生在主线程上

00:44:50.750 --> 00:44:56.090
我们命名它还是在服务器主服务器上

00:44:53.450 --> 00:44:59.060
服务器线程，现在我们必须执行

00:44:56.090 --> 00:45:01.580
各种字节写在同一

00:44:59.060 --> 00:45:03.650
螺纹连接到连接所以

00:45:01.580 --> 00:45:07.430
我们将使用相同的运算符

00:45:03.650 --> 00:45:10.070
现在，让我们重新启动

00:45:07.430 --> 00:45:12.290
服务器并确保一切正常

00:45:10.070 --> 00:45:17.530
在另一种上工作

00:45:12.290 --> 00:45:17.530
不同的线程，所以让我们稍等一下

00:45:20.020 --> 00:45:26.500
是的，它开始了，让我们尝试连接

00:45:23.810 --> 00:45:29.420
再次在这里，我们去这里，我们得到了

00:45:26.500 --> 00:45:32.600
现在在主线程上连接

00:45:29.420 --> 00:45:34.520
让我们尝试在此处发送一些数据

00:45:32.600 --> 00:45:37.670
我们还有另一个话题吗

00:45:34.520 --> 00:45:40.540
并行一个伟大的，所以如果你要

00:45:37.670 --> 00:45:43.340
看看写在哪里发生哦

00:45:40.540 --> 00:45:46.220
出问题了太多

00:45:43.340 --> 00:45:49.730
通知，所以我们就删除它

00:45:46.220 --> 00:45:50.200
调试点，看看是的还是

00:45:49.730 --> 00:45:54.890
工作中

00:45:50.200 --> 00:45:57.890
是的，我们得到了回应，它看起来不错

00:45:54.890 --> 00:46:00.550
所以我们试着去跑我们的女儿

00:45:57.890 --> 00:46:04.520
再次让我们尝试运行它，看看

00:46:00.550 --> 00:46:06.080
我们的应用程序是否会

00:46:04.520 --> 00:46:08.900
毕竟不被打破

00:46:06.080 --> 00:46:12.230
让我们来看看哇

00:46:08.900 --> 00:46:14.210
错误刚刚打开了几个连接

00:46:12.230 --> 00:46:18.620
用药过量出事了

00:46:14.210 --> 00:46:21.130
 er sec sec一切都没有

00:46:18.620 --> 00:46:24.440
出问题了

00:46:21.130 --> 00:46:26.990
我们溢出了怎么回事

00:46:24.440 --> 00:46:28.280
你知道吗让我快速解释一下

00:46:26.990 --> 00:46:31.430
这里发生了什么

00:46:28.280 --> 00:46:33.820
所以因为在鸡蛋之前

00:46:31.430 --> 00:46:36.710
抗议一切都在同一根

00:46:33.820 --> 00:46:40.850
只有一个线程参与了

00:46:36.710 --> 00:46:43.790
主线程的处理方式

00:46:40.850 --> 00:46:46.280
电源类型的反应式服务器将不会

00:46:43.790 --> 00:46:48.110
能够让你听另一种

00:46:46.280 --> 00:46:52.150
阅读有关的其他通知

00:46:48.110 --> 00:46:55.310
关键，我来自

00:46:52.150 --> 00:46:57.650
从它的连接

00:46:55.310 --> 00:47:00.170
准备发送一些准备就绪的数据

00:46:57.650 --> 00:47:03.590
发送一些数据，因为我们做了一些

00:47:00.170 --> 00:47:07.040
重新安排可能需要几种

00:47:03.590 --> 00:47:09.110
十亿分之一秒或更多

00:47:07.040 --> 00:47:12.410
通知将会发生

00:47:09.110 --> 00:47:15.320
会发生得太频繁了

00:47:12.410 --> 00:47:18.380
溢出在缓冲区上发布

00:47:15.320 --> 00:47:19.730
过去常常用来存储一些事件， 

00:47:18.380 --> 00:47:22.940
然后在不同的地方阅读它们

00:47:19.730 --> 00:47:24.770
线程，这就是我们在这里发生的事情

00:47:22.940 --> 00:47:27.470
只是溢出购买太多

00:47:24.770 --> 00:47:30.830
通知我们的队列，我们​​崩溃了

00:47:27.470 --> 00:47:32.720
我们的执行，所以为了避免它，我们

00:47:30.830 --> 00:47:35.300
只需要使用一个操作员

00:47:32.720 --> 00:47:38.780
最新的压力，它将跳过

00:47:35.300 --> 00:47:41.120
全部冗余或全部浮动

00:47:38.780 --> 00:47:43.190
通知，我们将仅保留最新消息

00:47:41.120 --> 00:47:45.620
对我们来说最重要的是我们不

00:47:43.190 --> 00:47:47.840
关心他们的默认设置

00:47:45.620 --> 00:47:51.320
需要采取一个，只是从读取数据

00:47:47.840 --> 00:47:54.020
是的，您不需要所有

00:47:51.320 --> 00:47:57.530
仅使用这个人，我们将

00:47:54.020 --> 00:48:02.540
能够生存下来的我们的应用程序，所以让我们

00:47:57.530 --> 00:48:05.530
刚开始就开始吧

00:48:02.540 --> 00:48:09.470
开始让我们重新启动这个家伙

00:48:05.530 --> 00:48:14.359
伙伴刚刚重新启动，它开始启动

00:48:09.470 --> 00:48:17.210
发生了，所以让我们看看它是否有效

00:48:14.359 --> 00:48:18.720
除了新的连接

00:48:17.210 --> 00:48:21.480
来吧哥们

00:48:18.720 --> 00:48:26.190
好吧，让我们停止一切，让我们

00:48:21.480 --> 00:48:29.400
使用魔术世界，让我们运行它

00:48:26.190 --> 00:48:31.579
再次以确保它

00:48:29.400 --> 00:48:37.609
按预期工作

00:48:31.579 --> 00:48:41.000
等待发生了什么事

00:48:37.609 --> 00:48:43.200
示范神再次发生在我身上

00:48:41.000 --> 00:48:47.400
让我仔细检查一下

00:48:43.200 --> 00:48:51.500
一切都正确，来吧

00:48:47.400 --> 00:48:51.500
好吧，它正在运行

00:48:59.600 --> 00:49:04.100
不好，我很快就走了

00:49:01.400 --> 00:49:07.160
去你去正确的

00:49:04.100 --> 00:49:10.190
在tzitzit的同一地点实施

00:49:07.160 --> 00:49:13.130
抱歉，我必须这样做才能

00:49:10.190 --> 00:49:17.300
避免在期间发生错误

00:49:13.130 --> 00:49:20.410
演示，让我们检查确定

00:49:17.300 --> 00:49:27.110
是的，我必须在这里使用分配和

00:49:20.410 --> 00:49:32.600
让我们再次运行它吧好吧，杀死Java 

00:49:27.110 --> 00:49:38.930
 Java再次是，它已经开始运作了

00:49:32.600 --> 00:49:48.650
和服务器好，它运行良好，我

00:49:38.930 --> 00:49:50.690
知道了，现在我们可以打开另一个

00:49:48.650 --> 00:49:52.310
从我们的终端连接，看看

00:49:50.690 --> 00:49:55.130
甚至一切都在运转

00:49:52.310 --> 00:49:57.170
所以我们得到了一千个OpenID 

00:49:55.130 --> 00:49:59.720
从服务器过量连接

00:49:57.170 --> 00:50:02.090
只是将垃圾邮件作为垃圾邮件发送者，如果您

00:49:59.720 --> 00:50:05.060
要看我们的忙碌

00:50:02.090 --> 00:50:07.160
 CPU，我们将看到整个CPU 

00:50:05.060 --> 00:50:09.190
忙着工作吗，你看到了吗

00:50:07.160 --> 00:50:11.960
开始收集数据，但是

00:50:09.190 --> 00:50:15.890
显然每个CPU都是

00:50:11.960 --> 00:50:18.680
为我们工作这真是太好了

00:50:15.890 --> 00:50:20.390
我们去另一个决赛

00:50:18.680 --> 00:50:22.400
背压的证明

00:50:20.390 --> 00:50:25.130
可以控制，但实际压力

00:50:22.400 --> 00:50:26.660
现在我要停止那件事了

00:50:25.130 --> 00:50:28.850
证明背压真的

00:50:26.660 --> 00:50:31.850
作品我要删除这条线

00:50:28.850 --> 00:50:34.070
要求每一种新的数据

00:50:31.850 --> 00:50:37.490
一旦得到它，所以我要

00:50:34.070 --> 00:50:41.240
恢复此人，让我们重新启动

00:50:37.490 --> 00:50:46.040
是的，现在我要从

00:50:41.240 --> 00:50:50.000
我的控制台，我们将在此处发送数据

00:50:46.040 --> 00:50:53.000
发送给我，我得到了回应，但你知道吗

00:50:50.000 --> 00:50:56.540
如果您在某个时候我发送了数据

00:50:53.000 --> 00:50:59.090
阻止它将禁止我发送给

00:50:56.540 --> 00:51:00.770
从控制台发送数据，但在

00:50:59.090 --> 00:51:03.410
一般我不会得到回应，因为

00:51:00.770 --> 00:51:04.850
我的服务器不再请求门和

00:51:03.410 --> 00:51:08.420
这就是背压可能的样子

00:51:04.850 --> 00:51:10.460
也控制它，这很酷

00:51:08.420 --> 00:51:13.719
让我们回到幻灯片

00:51:10.460 --> 00:51:19.519
让我们做一些总结

00:51:13.719 --> 00:51:22.910
并提醒这是最重要的

00:51:19.519 --> 00:51:25.759
在这里所以为了运行一切

00:51:22.910 --> 00:51:28.880
几个工人反应堆的例子

00:51:25.759 --> 00:51:31.940
为我们提供了并行的时间表

00:51:28.880 --> 00:51:34.420
基本上允许运行使用

00:51:31.940 --> 00:51:36.589
执行以在

00:51:34.420 --> 00:51:39.769
在可用的一项上指定

00:51:36.589 --> 00:51:42.549
工作人员并处理其中的所有数据

00:51:39.769 --> 00:51:44.930
这样的方式

00:51:42.549 --> 00:51:46.359
只会从中选择一个

00:51:44.930 --> 00:51:50.210
他们的游泳池

00:51:46.359 --> 00:51:52.160
总而言之，我们仍然会霓虹灯复杂

00:51:50.210 --> 00:51:54.259
但是如果有很多的话，就采用尺寸设计

00:51:52.160 --> 00:51:57.710
更好，它将简化我们的生产线

00:51:54.259 --> 00:51:59.989
生活很多，因为直肠流是

00:51:57.710 --> 00:52:03.049
设计用于简化排队

00:51:59.989 --> 00:52:05.539
种简化生活时的流

00:52:03.049 --> 00:52:07.219
是执行权的自然组成部分

00:52:05.539 --> 00:52:09.499
因为你知道和联系

00:52:07.219 --> 00:52:12.410
一般是一个流另一个流所以

00:52:09.499 --> 00:52:16.039
这两个你互相喂食吗

00:52:12.410 --> 00:52:17.930
真正的井，最终反应流带来了

00:52:16.039 --> 00:52:20.269
背压让我们可以控制

00:52:17.930 --> 00:52:22.940
当然在TCP级别上的背压

00:52:20.269 --> 00:52:24.829
不幸的是字节级，但这是

00:52:22.940 --> 00:52:26.719
总比没有好，当然使用

00:52:24.829 --> 00:52:31.339
项目反应堆，您将能够

00:52:26.719 --> 00:52:33.410
最终写出非常漂亮的逻辑

00:52:31.339 --> 00:52:36.680
我们实施的基本上是

00:52:33.410 --> 00:52:39.619
几乎会发生什么，反应堆网

00:52:36.680 --> 00:52:41.960
所以我在这里主要开发

00:52:39.619 --> 00:52:44.749
反应堆的本机流量是您的后者

00:52:41.960 --> 00:52:47.029
他他将能够告诉你一点

00:52:44.749 --> 00:52:49.039
关于内部的更多信息，但在

00:52:47.029 --> 00:52:51.769
一般而言，API有点类似于

00:52:49.039 --> 00:52:55.009
所以请使用项目反应堆

00:52:51.769 --> 00:52:57.349
并了解更多关于新的

00:52:55.009 --> 00:53:00.859
一些有用的链接，有一个视频来自

00:52:57.349 --> 00:53:03.200
我启发去做的henskee靴子

00:53:00.859 --> 00:53:05.479
这个演讲我也要了解更多

00:53:03.200 --> 00:53:08.059
项目反应堆并了解更多信息

00:53:05.479 --> 00:53:11.269
项目反应堆净值只是跟随那些

00:53:08.059 --> 00:53:13.910
链接最后，您必须转到下一个

00:53:11.269 --> 00:53:16.940
与真实背有关的思想

00:53:13.910 --> 00:53:21.289
降低运输压力

00:53:16.940 --> 00:53:23.539
无论是TCP还是I RON，以及此产品

00:53:21.289 --> 00:53:25.969
或这项技术叫你

00:53:23.539 --> 00:53:27.290
以前从未听说过我们的赛道

00:53:25.969 --> 00:53:29.660
如果没有

00:53:27.290 --> 00:53:31.520
关于那去这个不要去禁止

00:53:29.660 --> 00:53:34.130
并听他讲关于

00:53:31.520 --> 00:53:36.140
旨在减轻压力和

00:53:34.130 --> 00:53:37.940
微服务之间的指令流

00:53:36.140 --> 00:53:39.380
谢谢你的源代码是

00:53:37.940 --> 00:53:42.080
在这里可用

00:53:39.380 --> 00:53:48.660
 [掌声] 

00:53:42.080 --> 00:53:48.660
 [音乐] 

