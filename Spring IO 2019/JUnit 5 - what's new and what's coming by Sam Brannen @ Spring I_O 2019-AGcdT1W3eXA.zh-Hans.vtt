WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.900 --> 00:00:10.650
 [音乐] 

00:00:07.880 --> 00:00:14.760
好吧，欢迎今天的演讲

00:00:10.650 --> 00:00:16.379
我五岁的简是我的名字是山姆·布伦南

00:00:14.760 --> 00:00:18.720
关键的首席自我工程师

00:00:16.379 --> 00:00:20.910
几个月以来

00:00:18.720 --> 00:00:23.130
我已经有20多个Java开发人员

00:00:20.910 --> 00:00:24.510
好多年了，我一直

00:00:23.130 --> 00:00:27.539
 Spring Framework 的提交者

00:00:24.510 --> 00:00:29.100
自从2007年我最初重写

00:00:27.539 --> 00:00:30.720
到基于的测试框架

00:00:29.100 --> 00:00:33.239
 Jane Doe批注以测试D 

00:00:30.720 --> 00:00:35.969
等，我坚持到今天

00:00:33.239 --> 00:00:38.339
我一直是Jane的核心提交者

00:00:35.969 --> 00:00:40.409
自2015年10月起在5点

00:00:38.339 --> 00:00:42.929
组合就是为什么我在这里聊天

00:00:40.409 --> 00:00:44.219
今天是你，我们今天要谈

00:00:42.929 --> 00:00:46.920
您在五个总体上看到什么

00:00:44.219 --> 00:00:48.870
简和木星到底是什么

00:00:46.920 --> 00:00:50.280
我会给你一些迁移的技巧

00:00:48.870 --> 00:00:52.109
来自福特的简（如果您愿意的话） 

00:00:50.280 --> 00:00:53.489
谈论一些较新的

00:00:52.109 --> 00:00:55.709
自最初的五个功能以来

00:00:53.489 --> 00:00:57.780
发布有关路线图的一些信息，但我们

00:00:55.709 --> 00:01:00.469
已经计划，然后再使用

00:00:57.780 --> 00:01:02.999
吉娜·朱庇特（Gina Jupiter） 

00:01:00.469 --> 00:01:05.600
所以在你想看到一个

00:01:02.999 --> 00:01:10.280
举手示意有多少人写

00:01:05.600 --> 00:01:13.380
希望测试一个是的单元测试

00:01:10.280 --> 00:01:16.470
集成测试或人员参与

00:01:13.380 --> 00:01:18.360
测试您是否在更少的条件下

00:01:16.470 --> 00:01:21.240
框架如何称为

00:01:18.360 --> 00:01:24.840
珍妮特，谁看着你

00:01:21.240 --> 00:01:26.510
三手无动的人仍然在简上

00:01:24.840 --> 00:01:31.350
好的，这是谁在Jana上

00:01:26.510 --> 00:01:33.480
是的，最新的最多，只有12个

00:01:31.350 --> 00:01:34.800
人们还好吧，所以最新发布的

00:01:33.480 --> 00:01:36.050
 Jana 4可能会在

00:01:34.800 --> 00:01:39.000
下个月左右，那将是简做的

00:01:36.050 --> 00:01:41.460
 413五点钟就已经进入简

00:01:39.000 --> 00:01:43.140
改变你已经走了三四个人

00:01:41.460 --> 00:01:47.610
任何人使用像苔丝一样的东西

00:01:43.140 --> 00:01:51.000
在G中，一个人好，有人用

00:01:47.610 --> 00:01:53.280
 Spock是的，像Kotlin一样

00:01:51.000 --> 00:01:54.110
测试和诸如此类的内容

00:01:53.280 --> 00:01:57.200
人们还好

00:01:54.110 --> 00:01:59.820
越来越少，那么什么是小。五

00:01:57.200 --> 00:02:01.290
好在这里，我们有大局，所以我们

00:01:59.820 --> 00:02:03.870
在底部看到我们有这个新

00:02:01.290 --> 00:02:05.640
平台，这是一个新主意

00:02:03.870 --> 00:02:07.350
我们集成的IDS和构建工具

00:02:05.640 --> 00:02:08.909
与您可以单独使用它

00:02:07.350 --> 00:02:10.769
好吧，如果你想但不会很

00:02:08.909 --> 00:02:12.350
相反，您可能正在使用

00:02:10.769 --> 00:02:14.360
我们所谓的测试引擎

00:02:12.350 --> 00:02:15.950
不同的，我们一个星期

00:02:14.360 --> 00:02:18.290
全年份而不是传统

00:02:15.950 --> 00:02:19.940
支持简与旧的细胞测试

00:02:18.290 --> 00:02:21.920
四和吉娜三，我们有新

00:02:19.940 --> 00:02:23.330
是简·木星和你的东西

00:02:21.920 --> 00:02:25.340
可能正在使用其他一些第三方

00:02:23.330 --> 00:02:28.610
实现或您可以编写您的

00:02:25.340 --> 00:02:30.680
拥有五个珍妮，我有点喜欢

00:02:28.610 --> 00:02:31.370
根据那里的矩阵来开玩笑

00:02:30.680 --> 00:02:33.200
不是汤匙

00:02:31.370 --> 00:02:34.970
没有五个珍妮，你不能只是

00:02:33.200 --> 00:02:36.650
升级您的乌鸦手掌

00:02:34.970 --> 00:02:38.990
 Gradle没有说单位换算

00:02:36.650 --> 00:02:40.220
样式五实际上不起作用

00:02:38.990 --> 00:02:41.930
与五岁的简一起重写了所有内容

00:02:40.220 --> 00:02:44.540
现在我们有三种主要

00:02:41.930 --> 00:02:45.920
我们拥有平台的事物类别

00:02:44.540 --> 00:02:48.170
我们有木星，我们有

00:02:45.920 --> 00:02:49.880
优势，这是什么平台

00:02:48.170 --> 00:02:51.880
是启动测试的基础

00:02:49.880 --> 00:02:54.200
 JVM上的框架有点新想法

00:02:51.880 --> 00:02:55.820
我们有一个启动器API 

00:02:54.200 --> 00:02:57.920
您可以实现的测试引擎API 

00:02:55.820 --> 00:02:59.600
我们有一个控制台启动器

00:02:57.920 --> 00:03:01.850
从控制台运行此方法的方式

00:02:59.600 --> 00:03:03.560
也有独立的控制台启动

00:03:01.850 --> 00:03:06.530
您可以下载的jar，如果您

00:03:03.560 --> 00:03:08.270
想要这样的木星实际上是新的

00:03:06.530 --> 00:03:09.950
编程模型及其扩展

00:03:08.270 --> 00:03:11.930
五人的简

00:03:09.950 --> 00:03:13.610
或者当您阅读博客时，我正在写

00:03:11.930 --> 00:03:15.590
大三测试这可能是什么

00:03:13.610 --> 00:03:18.340
他们的意思是他们在使用Jane 

00:03:15.590 --> 00:03:20.900
木星并在平台上运行和

00:03:18.340 --> 00:03:22.130
作为测试引擎的年份

00:03:20.900 --> 00:03:24.380
允许您使用的实现

00:03:22.130 --> 00:03:25.520
 Jaina 3和Jane You四个基础测试或

00:03:24.380 --> 00:03:28.370
其他诸如旧版本的

00:03:25.520 --> 00:03:29.840
 Spock other也基于Gina 4 

00:03:28.370 --> 00:03:31.280
我想指出的一件事是

00:03:29.840 --> 00:03:33.200
这第一个街区实际上是

00:03:31.280 --> 00:03:36.590
以前不存在的革命者

00:03:33.200 --> 00:03:37.640
人们确实为简4写过跑步者，但是

00:03:36.590 --> 00:03:39.710
他们被迫与

00:03:37.640 --> 00:03:41.620
 Java模型和新平台非常

00:03:39.710 --> 00:03:44.030
通用的，并且在许多方面都支持

00:03:41.620 --> 00:03:46.280
文件和目录之类的东西

00:03:44.030 --> 00:03:48.530
除了Java类和结束

00:03:46.280 --> 00:03:49.850
方法，所以下一部分是

00:03:48.530 --> 00:03:51.800
进化权就是您想要的

00:03:49.850 --> 00:03:53.330
做事比做的更好或不同

00:03:51.800 --> 00:03:55.190
事情在简中来回完成， 

00:03:53.330 --> 00:03:56.270
最后的必要部分，因为我们想要

00:03:55.190 --> 00:03:58.250
每个人都将继续运行

00:03:56.270 --> 00:04:00.560
 Janie 3测试，Jane测试和

00:03:58.250 --> 00:04:02.390
同时进行Spock测试或

00:04:00.560 --> 00:04:05.690
在运行Jani G的同时

00:04:02.390 --> 00:04:08.570
简而言之，抗议者只有五个人

00:04:05.690 --> 00:04:10.820
是对Jane的完整改写，来自

00:04:08.570 --> 00:04:12.350
不断完善什么基因

00:04:10.820 --> 00:04:14.690
已经不得不提供但与

00:04:12.350 --> 00:04:17.030
可扩展性和思想，这是

00:04:14.690 --> 00:04:18.459
模块化可扩展的现代权利

00:04:17.030 --> 00:04:20.620
基于Java 8 

00:04:18.459 --> 00:04:22.180
我们想到的另一件事

00:04:20.620 --> 00:04:23.980
牢记要成为

00:04:22.180 --> 00:04:25.900
向前和向后兼容

00:04:23.980 --> 00:04:28.660
同时基本上是平台

00:04:25.900 --> 00:04:30.580
支持jayna 3 8和4 

00:04:28.660 --> 00:04:33.160
老式引擎和简和木星与

00:04:30.580 --> 00:04:34.960
木星引擎以及任何支持

00:04:33.160 --> 00:04:36.370
某人拥有的其他测试引擎

00:04:34.960 --> 00:04:38.260
或您可以在自己的书上写

00:04:36.370 --> 00:04:40.090
自己的，实际上人们已经

00:04:38.260 --> 00:04:41.620
如果愿意的话，写一些测试引擎

00:04:40.090 --> 00:04:43.630
看看看看有什么

00:04:41.620 --> 00:04:45.040
只需在5的wiki页面上找到简（Jane） 

00:04:43.630 --> 00:04:46.750
并转到第三方中心页面

00:04:45.040 --> 00:04:49.420
你在那里看到清单，我不仅

00:04:46.750 --> 00:04:51.670
测试引擎，但也有大约20或30 

00:04:49.420 --> 00:04:53.080
 G和木星的不同扩展

00:04:51.670 --> 00:04:56.470
像春天和莫吉托之类的东西

00:04:53.080 --> 00:04:59.410
其他类似Java的术语

00:04:56.470 --> 00:05:02.920
版本，这是诗歌我

00:04:59.410 --> 00:05:05.440
在Twitter上发布了一段时间

00:05:02.920 --> 00:05:08.710
因此在J十年中表现出色，因此

00:05:05.440 --> 00:05:11.050
 um jeito 5的基准工作正常jdk 9 

00:05:08.710 --> 00:05:13.900
我在自动模块上说的所有

00:05:11.050 --> 00:05:16.600
罐子里的名字，我们要添加或

00:05:13.900 --> 00:05:18.880
移入5/5，增加了对

00:05:16.600 --> 00:05:20.590
真实的模块信息，如果我们能得到的话

00:05:18.880 --> 00:05:21.790
工作，我们也支持模块路径

00:05:20.590 --> 00:05:23.980
扫描除分类

00:05:21.790 --> 00:05:25.270
扫描一切再次在jdk上工作

00:05:23.980 --> 00:05:28.090
 10和11 

00:05:25.270 --> 00:05:30.790
是的，当我发布但现在我们正在构建

00:05:28.090 --> 00:05:32.350
针对JDK 11进行测试

00:05:30.790 --> 00:05:34.630
 12，我们正在尝试13，但我们有

00:05:32.350 --> 00:05:36.040
一些不是我们代码中的问题，而是

00:05:34.630 --> 00:05:38.770
第三方和构建之类的东西

00:05:36.040 --> 00:05:40.900
这样的想法和未建

00:05:38.770 --> 00:05:42.220
支持对您很重要，因为

00:05:40.900 --> 00:05:44.680
您实际上希望能够使用此

00:05:42.220 --> 00:05:46.780
东西和好消息是所有主要思想

00:05:44.680 --> 00:05:50.140
和构建工具支持它，所以告诉

00:05:46.780 --> 00:05:52.930
杰森（Jason）的想法2016年以来黯然失色

00:05:50.140 --> 00:05:54.760
多给七个NetBeans供氧

00:05:52.930 --> 00:05:57.669
从Apache到NetBeans 10以来的最新情况

00:05:54.760 --> 00:06:00.729
 dotto Gradle，所以我们最初写了我们的

00:05:57.669 --> 00:06:03.250
自己的插件，我是年级警报骑手

00:06:00.729 --> 00:06:04.900
在Gradle 4.6中提供全面的一流支持

00:06:03.250 --> 00:06:07.930
也许以后再来

00:06:04.900 --> 00:06:10.570
 surefire 2.22，他们已经对其进行了改进

00:06:07.930 --> 00:06:12.360
最近允许Springview采纳

00:06:10.570 --> 00:06:16.270
过去几天里的五个珍妮

00:06:12.360 --> 00:06:18.400
所以嗯嗯姨

00:06:16.270 --> 00:06:21.350
团队出奇的是，他们有支持

00:06:18.400 --> 00:06:23.180
自10.3阿姨以来

00:06:21.350 --> 00:06:24.290
所以我不会显示任何例子

00:06:23.180 --> 00:06:26.750
如果您想看到这些东西

00:06:24.290 --> 00:06:28.280
查阅jana的用户指南

00:06:26.750 --> 00:06:30.920
 5以及一些样本

00:06:28.280 --> 00:06:33.410
我们链接到条款的应用程序

00:06:30.920 --> 00:06:35.630
发行，所以5.0重新发行了

00:06:33.410 --> 00:06:37.940
从那时起2017年9月

00:06:35.630 --> 00:06:40.490
五点一二三和四发行

00:06:37.940 --> 00:06:42.470
最近被开除了4.2 

00:06:40.490 --> 00:06:47.300
那就是你应该使用的

00:06:42.470 --> 00:06:50.450
我们在讲话时正在研究5.5，所以

00:06:47.300 --> 00:06:54.230
是木星的简什么是木星

00:06:50.450 --> 00:06:54.710
这不是一个技巧性的问题，而是

00:06:54.230 --> 00:06:58.610
行星

00:06:54.710 --> 00:07:00.560
是的，哪颗行星是第五颗行星，是的

00:06:58.610 --> 00:07:02.270
所以我们五岁的简不想

00:07:00.560 --> 00:07:03.710
它简而充满活力，因为可能

00:07:02.270 --> 00:07:04.790
版本六，我们认为

00:07:03.710 --> 00:07:07.040
傻傻地拥有简

00:07:04.790 --> 00:07:09.260
二五版本六，所以我们想出了

00:07:07.040 --> 00:07:11.360
一种代号，木星开始

00:07:09.260 --> 00:07:14.150
和J一起，你喜欢Junior J单位， 

00:07:11.360 --> 00:07:15.500
也v，所以我们认为这是个好名字

00:07:14.150 --> 00:07:17.480
万一你想知道名字在哪里

00:07:15.500 --> 00:07:19.970
简而言之来自Jana Jupiter 

00:07:17.480 --> 00:07:22.490
是新程序模型的子项，并且

00:07:19.970 --> 00:07:23.750
简的五个扩展模型

00:07:22.490 --> 00:07:25.730
程序模型就是您编写代码的方式

00:07:23.750 --> 00:07:27.860
测试您使用的注释

00:07:25.730 --> 00:07:29.510
断言的使用和假设以及

00:07:27.860 --> 00:07:31.460
测试类型或测试样式

00:07:29.510 --> 00:07:32.870
您可以编写扩展模型

00:07:31.460 --> 00:07:35.780
那基本上就是你和第三个人

00:07:32.870 --> 00:07:37.610
各方可以扩展框架本身

00:07:35.780 --> 00:07:42.170
所以像spring和maketo之类的东西

00:07:37.610 --> 00:07:43.520
硒等，因此在Jane中，您解雇了J和

00:07:42.170 --> 00:07:46.280
木星我们确实有更强大的

00:07:43.520 --> 00:07:47.300
编程模型基本上要问自己

00:07:46.280 --> 00:07:49.430
你能做什么改变木星你

00:07:47.300 --> 00:07:51.740
简与简无法相处

00:07:49.430 --> 00:07:53.450
有些事情更简单，例如能见度

00:07:51.740 --> 00:07:54.950
我们不要求公开事物

00:07:53.450 --> 00:07:57.050
他们只是一些不能私下

00:07:54.950 --> 00:07:58.880
但您可以选择受保护的软件包

00:07:57.050 --> 00:08:01.190
少输入您的测试类， 

00:07:58.880 --> 00:08:03.170
方法名称和类似的东西

00:08:01.190 --> 00:08:04.310
支持自定义显示名称，因此

00:08:03.170 --> 00:08:06.470
而不是基于

00:08:04.310 --> 00:08:07.580
您可以使用Java中的技术名称

00:08:06.470 --> 00:08:09.800
这是最新的名称注释，并具有

00:08:07.580 --> 00:08:12.290
空格特殊字符甚至表情符号

00:08:09.800 --> 00:08:13.520
和您的显示名称（如果需要） 

00:08:12.290 --> 00:08:15.730
启发了这一点，因为我们有了新的展示

00:08:13.520 --> 00:08:17.540
内置一些名称生成器

00:08:15.730 --> 00:08:20.690
开箱即用的支持，您可以

00:08:17.540 --> 00:08:22.670
还可以编写自己的标签

00:08:20.690 --> 00:08:25.430
从测试小组中知道这个想法

00:08:22.670 --> 00:08:26.960
 Z或来自J的类别在4点如此

00:08:25.430 --> 00:08:28.940
 Dana Jupiter，我们有帽子标签，那个

00:08:26.960 --> 00:08:30.409
取代实验类别

00:08:28.940 --> 00:08:32.810
在那里的支持和改变

00:08:30.409 --> 00:08:34.459
或者除此之外，我们还有一个标签

00:08:32.810 --> 00:08:35.959
语言，所以你可以说这样的事情

00:08:34.459 --> 00:08:37.610
这个东西或这个东西而不是这个

00:08:35.959 --> 00:08:40.060
东西，你可以建立一个标签

00:08:37.610 --> 00:08:43.000
选择要运行的测试的表达式

00:08:40.060 --> 00:08:44.990
所以这是一个示例um计算器测试

00:08:43.000 --> 00:08:46.339
这里没有什么太疯狂的，只有一件事

00:08:44.990 --> 00:08:47.750
您马上注意到， 

00:08:46.339 --> 00:08:50.120
这里没有公共关键字

00:08:47.750 --> 00:08:51.620
类或方法以及其他

00:08:50.120 --> 00:08:52.970
我们看到这个显示名称注释

00:08:51.620 --> 00:08:54.410
这是可选的，您不必做

00:08:52.970 --> 00:08:56.629
你可以做什么，所以你可以给予有意义的

00:08:54.410 --> 00:08:59.329
名称，您可以使用我提到的

00:08:56.629 --> 00:09:00.529
在表情符号和类似的东西之前

00:08:59.329 --> 00:09:01.790
这里要注意的是，我们有

00:09:00.529 --> 00:09:03.740
几乎等于，所以该方法看起来

00:09:01.790 --> 00:09:05.480
差不多，但是我们有

00:09:03.740 --> 00:09:07.879
通知失败消息以防万一

00:09:05.480 --> 00:09:09.439
最终在现在失败了

00:09:07.879 --> 00:09:11.329
结束而不是首先，所以如果你是

00:09:09.439 --> 00:09:12.589
迁移您无疑会使用一些工具

00:09:11.329 --> 00:09:14.660
会帮你做另一件事

00:09:12.589 --> 00:09:16.490
注意这里是作为lambda 

00:09:14.660 --> 00:09:18.439
在这里表达，所以基本上我们懒惰

00:09:16.490 --> 00:09:19.310
建立异常消息，如果

00:09:18.439 --> 00:09:20.569
你在做一些高弦

00:09:19.310 --> 00:09:21.800
串联或其他花费

00:09:20.569 --> 00:09:23.980
很长一段时间吧，因为你想要你的

00:09:21.800 --> 00:09:26.660
测试套件以尽可能快的速度运行

00:09:23.980 --> 00:09:27.740
在这里，我们再次使用另一个示例

00:09:26.660 --> 00:09:30.019
该剧中一些特殊人物

00:09:27.740 --> 00:09:31.879
名字，但是这里有些不同

00:09:30.019 --> 00:09:33.199
也将在413年6月降临，但我们

00:09:31.879 --> 00:09:35.120
从一开始就写

00:09:33.199 --> 00:09:37.459
木星，所以它开始抛出这是如何

00:09:35.120 --> 00:09:39.589
我们对它们进行异常处理测试

00:09:37.459 --> 00:09:41.269
现代世界的例外

00:09:39.589 --> 00:09:42.410
说话，所以我们说得很好，我们希望它能够

00:09:41.269 --> 00:09:44.029
抛出，然后我们有一个lambda 

00:09:42.410 --> 00:09:45.380
表达式或方法引用

00:09:44.029 --> 00:09:46.970
应该抛出这种异常

00:09:45.380 --> 00:09:48.680
如果没有，那么你会失败

00:09:46.970 --> 00:09:49.850
否则您将获得对

00:09:48.680 --> 00:09:51.709
异常，然后您可以检查其他

00:09:49.850 --> 00:09:57.290
关于它的事情像

00:09:51.709 --> 00:09:59.209
消息等类似的超时

00:09:57.290 --> 00:10:00.350
也有类似的方法

00:09:59.209 --> 00:10:01.670
 lambda表达式，所以我们有两个

00:10:00.350 --> 00:10:03.680
断言类中的方法

00:10:01.670 --> 00:10:05.089
断言超时和超时

00:10:03.680 --> 00:10:07.880
所以这第一个要休息

00:10:05.089 --> 00:10:10.100
那将要做的基本上是

00:10:07.880 --> 00:10:12.470
等待代码完成，以便代码

00:10:10.100 --> 00:10:13.550
永远不会完成，它可以永远运行，但是

00:10:12.470 --> 00:10:15.199
如果没有，那么基本上我们只是

00:10:13.550 --> 00:10:16.970
检查之后花了多长时间， 

00:10:15.199 --> 00:10:18.559
并通过测试，如果需要你

00:10:16.970 --> 00:10:20.870
长，另一种选择是说

00:10:18.559 --> 00:10:22.160
抢先断言超时，并且

00:10:20.870 --> 00:10:23.630
情况将要发生的是代码是

00:10:22.160 --> 00:10:25.130
要在一个单独的线程中运行

00:10:23.630 --> 00:10:27.019
意味着如果需要它将会被杀死

00:10:25.130 --> 00:10:29.000
你很久，所以你可能想要你可能

00:10:27.019 --> 00:10:29.779
更喜欢那个，但是有了梯子

00:10:29.000 --> 00:10:31.670
要记住，如果您正在使用

00:10:29.779 --> 00:10:33.529
框架或任何种类的工具

00:10:31.670 --> 00:10:34.939
一些与线程绑定

00:10:33.529 --> 00:10:37.069
与像本地线程一样

00:10:34.939 --> 00:10:38.630
春天你有交易管理

00:10:37.069 --> 00:10:40.519
它绑定到您的当前线程

00:10:38.630 --> 00:10:42.350
测试您是否有交易

00:10:40.519 --> 00:10:43.030
测试，这意味着您的

00:10:42.350 --> 00:10:44.140
在这里运行的代码

00:10:43.030 --> 00:10:45.760
没有运行此环管理

00:10:44.140 --> 00:10:52.450
交易，这就是你所拥有的

00:10:45.760 --> 00:10:54.640
牢记这一基本演示

00:10:52.450 --> 00:10:58.330
只是为了展示一切，你应该

00:10:54.640 --> 00:11:00.520
有适当的计算测试

00:10:58.330 --> 00:11:03.010
运行它不应该太令人兴奋，但是

00:11:00.520 --> 00:11:04.840
例如，我们会看到

00:11:03.010 --> 00:11:06.910
与他们一起跑的叫吉安娜5他们

00:11:04.840 --> 00:11:07.870
表示它在平台上运行，然后

00:11:06.910 --> 00:11:09.700
看起来非常我们所拥有的

00:11:07.870 --> 00:11:11.740
见过但我们看到我们有一些

00:11:09.700 --> 00:11:13.150
合成在这里，所以这是必须的

00:11:11.740 --> 00:11:14.620
一直是自定义显示名称，或者您

00:11:13.150 --> 00:11:15.760
可以双击它去

00:11:14.620 --> 00:11:17.050
直接使用方法

00:11:15.760 --> 00:11:18.760
背景在技术上与

00:11:17.050 --> 00:11:19.960
方法和类，但显示

00:11:18.760 --> 00:11:21.910
名字只是人类可读的东西

00:11:19.960 --> 00:11:23.470
如果需要，可以在这里使用

00:11:21.910 --> 00:11:24.040
我们有一个例子，如果它开始

00:11:23.470 --> 00:11:25.870
本来

00:11:24.040 --> 00:11:28.680
并在这里抛出异常

00:11:25.870 --> 00:11:31.300
例如，如果我们花了更长的时间

00:11:28.680 --> 00:11:32.650
猜猜这里是否需要我们说

00:11:31.300 --> 00:11:34.570
大约45会花太长时间

00:11:32.650 --> 00:11:36.310
如果我们再次运行测试，那么我们应该

00:11:34.570 --> 00:11:37.690
希望看到失败，但是

00:11:36.310 --> 00:11:38.440
先发制人地实际上停止了

00:11:37.690 --> 00:11:40.120
因此他们是一千

00:11:38.440 --> 00:11:42.220
毫秒，所以我们不知道如何

00:11:40.120 --> 00:11:46.720
需要多长时间，但我们看到了

00:11:42.220 --> 00:11:48.640
失败了，所以我们有这样的选择， 

00:11:46.720 --> 00:11:50.410
再次，不必上课

00:11:48.640 --> 00:11:52.720
公开的方法不必

00:11:50.410 --> 00:11:53.950
公众要注意的一件事是

00:11:52.720 --> 00:11:57.870
测试注释位于不同的位置

00:11:53.950 --> 00:12:02.200
包装，以防您措手不及

00:11:57.870 --> 00:12:04.600
好吧，所以我们有更多的力量

00:12:02.200 --> 00:12:06.310
表达此元注释支持

00:12:04.600 --> 00:12:08.320
因此，元注解是对

00:12:06.310 --> 00:12:09.970
在另一个注释的顶部

00:12:08.320 --> 00:12:11.920
像Java中的继承或注释

00:12:09.970 --> 00:12:13.660
当我们说我们

00:12:11.920 --> 00:12:16.240
支持，您可以使用任何

00:12:13.660 --> 00:12:18.340
 JUnit中的注释作为元注释

00:12:16.240 --> 00:12:20.290
因此您可以像

00:12:18.340 --> 00:12:22.060
你可能已经在春天见过

00:12:20.290 --> 00:12:24.460
这些年来，您可以创建自己的

00:12:22.060 --> 00:12:26.230
您可以自定义组成的注释

00:12:24.460 --> 00:12:27.910
也把它们和春天结合起来

00:12:26.230 --> 00:12:29.760
支持它，而初级支持它

00:12:27.910 --> 00:12:31.360
表示您可以一起使用此功能

00:12:29.760 --> 00:12:33.430
我们也有一个叫做

00:12:31.360 --> 00:12:35.980
有条件的测试执行，所以贾娜

00:12:33.430 --> 00:12:37.290
伪造帽子哈达德忽略写和

00:12:35.980 --> 00:12:39.130
你会看到我们还有更多

00:12:37.290 --> 00:12:41.320
我们有另一件事是依赖

00:12:39.130 --> 00:12:42.670
构造函数和方法的注入

00:12:41.320 --> 00:12:44.470
您的测试方法以及您的

00:12:42.670 --> 00:12:46.660
像您之前和之后那样的生命周期方法

00:12:44.470 --> 00:12:48.370
之后的方法和类似的东西

00:12:46.660 --> 00:12:50.350
陆地表达式和方法参考可以

00:12:48.370 --> 00:12:52.540
正如我们刚刚在各个地方使用

00:12:50.350 --> 00:12:53.840
看到一些断言也为

00:12:52.540 --> 00:12:57.080
假设和

00:12:53.840 --> 00:12:58.160
动态测试另一件事

00:12:57.080 --> 00:12:59.540
与Java 8一起做了很多

00:12:58.160 --> 00:13:01.250
人们回家实际上不会

00:12:59.540 --> 00:13:03.050
大概是我们自己有

00:13:01.250 --> 00:13:04.820
新事物，除非这里有新的木工

00:13:03.050 --> 00:13:06.320
我们拥有所有方法和接口， 

00:13:04.820 --> 00:13:08.330
当你拥有的时候，你基本上可以

00:13:06.320 --> 00:13:09.529
有多重继承，我喜欢

00:13:08.330 --> 00:13:11.450
称它为测试特质，所以你可以

00:13:09.529 --> 00:13:13.550
实现某些功能的测试类

00:13:11.450 --> 00:13:15.290
接口，这些接口可以

00:13:13.550 --> 00:13:17.360
已经定义了第十种方法或

00:13:15.290 --> 00:13:19.610
配置设置和拆卸

00:13:17.360 --> 00:13:22.100
找到，以便您基本上可以实施

00:13:19.610 --> 00:13:24.160
一些测试特征，然后覆盖

00:13:22.100 --> 00:13:26.650
一些抽象的方法，并有一种

00:13:24.160 --> 00:13:29.300
 TCK或类似的测试套件

00:13:26.650 --> 00:13:30.440
另一个功能，嗯，有一些

00:13:29.300 --> 00:13:32.630
对此的支持正在改变

00:13:30.440 --> 00:13:34.070
我们拥有的外部跑步者第三方

00:13:32.630 --> 00:13:36.320
支持顺序称为嵌套测试类

00:13:34.070 --> 00:13:38.360
这样您就可以在测试中包含测试类

00:13:36.320 --> 00:13:41.060
类，它添加了一个不错的方法，或者

00:13:38.360 --> 00:13:43.550
介绍了一种对测试进行分组的好方法

00:13:41.060 --> 00:13:47.990
类别和术语

00:13:43.550 --> 00:13:49.850
保存共享财产和设置我们

00:13:47.990 --> 00:13:52.250
也有反复测试参数

00:13:49.850 --> 00:13:53.500
测试和测试工厂的动态

00:13:52.250 --> 00:13:55.250
测试，所以我们来看看那些

00:13:53.500 --> 00:13:58.270
很多人不知道的另一件事

00:13:55.250 --> 00:14:00.920
关于珍妮特的原因是珍妮特一直

00:13:58.270 --> 00:14:03.230
实例化坚持新的课程

00:14:00.920 --> 00:14:05.660
实例每次运行测试方法

00:14:03.230 --> 00:14:07.580
和测试框架（如会话G） 

00:14:05.660 --> 00:14:09.710
他们兑现了相反的结果

00:14:07.580 --> 00:14:10.970
所以我们在贾纳木星中所拥有的

00:14:09.710 --> 00:14:13.339
给你一个选择，所以默认情况下

00:14:10.970 --> 00:14:15.290
使用新实例可以全面工作

00:14:13.339 --> 00:14:16.880
每次您可以说每个测试实例

00:14:15.290 --> 00:14:20.710
上课并获得，他们获得了一笔现金

00:14:16.880 --> 00:14:23.330
这也有一些好处

00:14:20.710 --> 00:14:24.620
标记和自定义注释

00:14:23.330 --> 00:14:26.390
标记所有您要做的就是写

00:14:24.620 --> 00:14:29.510
接口类或方法上的那个标签

00:14:26.390 --> 00:14:32.570
并快速给它一个像这个标签的字符串

00:14:29.510 --> 00:14:33.589
这是我的快速测试，但也许不

00:14:32.570 --> 00:14:34.580
想在整个地方重复

00:14:33.589 --> 00:14:36.020
也许您想在以下位置更改名称

00:14:34.580 --> 00:14:38.000
有一点，所以你实际上可以

00:14:36.020 --> 00:14:39.800
使用自定义标签，您可以使用标签

00:14:38.000 --> 00:14:41.450
来自Janet的注解，作为对

00:14:39.800 --> 00:14:43.550
您自己的注释，所以在这里

00:14:41.450 --> 00:14:46.670
编写我们自己的快速注释

00:14:43.550 --> 00:14:48.820
然后用那个标签快速注释

00:14:46.670 --> 00:14:51.410
我们可以说快速添加和测试

00:14:48.820 --> 00:14:53.750
在我们的代码库中，我们有点

00:14:51.410 --> 00:14:54.950
重用它，但我们甚至可以迈出一步

00:14:53.750 --> 00:14:57.410
进一步提交，您可以合并

00:14:54.950 --> 00:14:59.779
我们称这些为不同的注释

00:14:57.410 --> 00:15:01.760
撰写注释，在这里我们看到一个

00:14:59.779 --> 00:15:03.440
具有两个不同注释的示例

00:15:01.760 --> 00:15:05.690
来自Dana Jupiter，我们有ID 

00:15:03.440 --> 00:15:07.580
标签注释，我们进行了测试

00:15:05.690 --> 00:15:10.850
注释，现在我们说添加五个

00:15:07.580 --> 00:15:11.930
测试正确，这样您就可以跨

00:15:10.850 --> 00:15:14.720
我们的代码库您可能会做的另一件事

00:15:11.930 --> 00:15:16.370
有CI测试或集成测试，或

00:15:14.720 --> 00:15:17.690
缓慢的测试或类似的东西

00:15:16.370 --> 00:15:19.220
有一些方法可以对您的测试进行分类

00:15:17.690 --> 00:15:21.020
并有一个标准的方法来做到

00:15:19.220 --> 00:15:26.270
然后是您使用的一组标准标签

00:15:21.020 --> 00:15:28.760
用于您的构建和本地，因此下一步

00:15:26.270 --> 00:15:29.960
如果您有更高级的重复测试

00:15:28.760 --> 00:15:31.310
有些东西可能会剥落您

00:15:29.960 --> 00:15:32.750
想要确定或确定某事

00:15:31.310 --> 00:15:34.610
是幂等的

00:15:32.750 --> 00:15:36.380
您可以在重复测试中说

00:15:34.610 --> 00:15:39.440
然后给它一个号码，您可以选择

00:15:36.380 --> 00:15:41.240
接受重复

00:15:39.440 --> 00:15:42.500
可以让您找到总数的信息

00:15:41.240 --> 00:15:44.870
请愿数或当前

00:15:42.500 --> 00:15:46.880
重复是否对您有帮助，但这是

00:15:44.870 --> 00:15:49.280
不需要，他们真的没有例子

00:15:46.880 --> 00:15:51.590
您还可以覆盖

00:15:49.280 --> 00:15:53.270
测试这是一分为二的翻译

00:15:51.590 --> 00:15:54.860
德语，因此我们可以访问

00:15:53.270 --> 00:15:56.990
当前重复次数和总数

00:15:54.860 --> 00:15:59.480
重复，我们会看到实际上

00:15:56.990 --> 00:16:01.340
接下来在IDE中运行

00:15:59.480 --> 00:16:03.410
简的测试已经存在

00:16:01.340 --> 00:16:05.000
因为在Jana中有些不同

00:16:03.410 --> 00:16:07.250
木星和我实际上更多

00:16:05.000 --> 00:16:08.780
在很多方面都很强大，所以基本上您

00:16:07.250 --> 00:16:10.910
用@param尝试注释方法

00:16:08.780 --> 00:16:12.440
测试而不是测试，您可以指定

00:16:10.910 --> 00:16:14.630
争论的来历

00:16:12.440 --> 00:16:16.460
从您可以选择覆盖

00:16:14.630 --> 00:16:18.800
显示名称，就像我们刚才看到的一样

00:16:16.460 --> 00:16:20.720
经过反复测试，因此

00:16:18.800 --> 00:16:23.660
多个或下方的来源

00:16:20.720 --> 00:16:25.820
价值来源的方框最简单

00:16:23.660 --> 00:16:27.920
允许您指定基本

00:16:25.820 --> 00:16:30.560
基本类型字符串或类，以及

00:16:27.920 --> 00:16:32.930
在下一版本中，布尔值也为

00:16:30.560 --> 00:16:34.340
嗯，也支持null 

00:16:32.930 --> 00:16:37.520
事物的来源和空来源

00:16:34.340 --> 00:16:40.550
如列表或字符串和数组等等

00:16:37.520 --> 00:16:43.400
像这样的枚举源可以让您使用UM 

00:16:40.550 --> 00:16:45.530
从以下位置获取枚举常量

00:16:43.400 --> 00:16:47.570
特定的枚举方法的来源是

00:16:45.530 --> 00:16:49.280
基本上是工厂方法

00:16:47.570 --> 00:16:51.380
自行编写代码以生成

00:16:49.280 --> 00:16:53.360
到列表或参数集

00:16:51.380 --> 00:16:55.040
想使用，然后我们有另一个

00:16:53.360 --> 00:16:57.440
所谓的我是CSV来源，因此使用

00:16:55.040 --> 00:16:59.540
逗号分隔值列表，该样式

00:16:57.440 --> 00:17:00.890
您可以根据CSV源中的

00:16:59.540 --> 00:17:03.320
该代码，或者您可以实际引用

00:17:00.890 --> 00:17:03.950
类文件中添加CSV文件

00:17:03.320 --> 00:17:06.350
档案来源

00:17:03.950 --> 00:17:08.150
注释，如果那些东西没有

00:17:06.350 --> 00:17:09.470
找出可以写自己的地方

00:17:08.150 --> 00:17:10.970
实现自己的参数提供程序

00:17:09.470 --> 00:17:14.810
并配置我们要声明的

00:17:10.970 --> 00:17:17.330
全部没有参数来源

00:17:14.810 --> 00:17:18.530
汇总中的转化条件

00:17:17.330 --> 00:17:20.329
我们支持的论点

00:17:18.530 --> 00:17:22.309
首先我们有隐式罐头

00:17:20.329 --> 00:17:23.480
版本四非常普通的事情，像

00:17:22.309 --> 00:17:25.519
包装器中的原始类型，因此

00:17:23.480 --> 00:17:26.899
来自一个字符串，它是一个字符串

00:17:25.519 --> 00:17:28.220
那是你知道的42那么你可以

00:17:26.899 --> 00:17:30.110
转换为int或long并

00:17:28.220 --> 00:17:31.700
类似的东西，我们也支持

00:17:30.110 --> 00:17:34.340
从您知道的常量名称变为

00:17:31.700 --> 00:17:37.250
你知道常量之类的文件

00:17:34.340 --> 00:17:37.549
 URL货币语言环境之类的东西

00:17:37.250 --> 00:17:41.149
好

00:17:37.549 --> 00:17:42.980
也是时间，认为切换时间，所以

00:17:41.149 --> 00:17:45.440
您可能想要的本地日期时间

00:17:42.980 --> 00:17:47.630
转换并用作参数的

00:17:45.440 --> 00:17:49.309
为您的方法，然后是最近

00:17:47.630 --> 00:17:51.289
我们对um工厂有支持

00:17:49.309 --> 00:17:52.549
构造函数和静态工厂方法

00:17:51.289 --> 00:17:54.440
在特定类中作为后备

00:17:52.549 --> 00:17:57.110
机制，您可以查看

00:17:54.440 --> 00:17:58.370
现在的文档

00:17:57.110 --> 00:17:59.600
明确的转换

00:17:58.370 --> 00:18:01.340
不起作用，您可以随时提供您的

00:17:59.600 --> 00:18:02.630
自己的转换，您可以通过

00:18:01.340 --> 00:18:04.429
实现自己的论点

00:18:02.630 --> 00:18:07.490
转换器，然后进行配置

00:18:04.429 --> 00:18:09.860
与at转换一起，我们也有

00:18:07.490 --> 00:18:11.389
支持Java时间模式

00:18:09.860 --> 00:18:12.740
转换，因此您可以指定特定

00:18:11.389 --> 00:18:15.200
日期格式的模式

00:18:12.740 --> 00:18:16.760
来自欧洲的时间格式

00:18:15.200 --> 00:18:19.100
从您的CSV文件中获取

00:18:16.760 --> 00:18:20.450
例子，最近我们有

00:18:19.100 --> 00:18:22.130
支持所谓的论点

00:18:20.450 --> 00:18:23.899
因此，基本上，如果您

00:18:22.130 --> 00:18:26.630
从CSV文件读取它，也许在

00:18:23.899 --> 00:18:28.610
这条线代表一个特定的订单

00:18:26.630 --> 00:18:29.750
或一个人写下您所有的字段

00:18:28.610 --> 00:18:31.970
可能只想拥有那个人

00:18:29.750 --> 00:18:33.799
对象将其注入您的测试方法

00:18:31.970 --> 00:18:35.480
你可以写我使用聚合

00:18:33.799 --> 00:18:37.700
那你做的方式就是你

00:18:35.480 --> 00:18:40.010
可以使用参数API或实现

00:18:37.700 --> 00:18:43.700
一个参数聚合器

00:18:40.010 --> 00:18:45.679
然后取给定集合的所有输入

00:18:43.700 --> 00:18:47.389
值，然后创建一个对象

00:18:45.679 --> 00:18:49.820
这有点像原始的

00:18:47.389 --> 00:18:53.000
您知道Spring JDBC支持中的mapper 

00:18:49.820 --> 00:18:56.049
在这里，我们有一个具体的例子

00:18:53.000 --> 00:18:58.190
当你有一个参数化的测试

00:18:56.049 --> 00:18:59.600
说我们希望这是一个参数化

00:18:58.190 --> 00:19:01.549
测试，我们选择来源

00:18:59.600 --> 00:19:03.769
在这种情况下，您可以增加价值来源

00:19:01.549 --> 00:19:05.360
挑选字符串，所以只是一组字符串

00:19:03.769 --> 00:19:07.490
在这里，这种方法将是

00:19:05.360 --> 00:19:09.230
每次被调用五次

00:19:07.490 --> 00:19:10.429
这些字符串，字符串就可以了

00:19:09.230 --> 00:19:12.620
通过作为候选人，我们可以

00:19:10.429 --> 00:19:14.350
例如检查我们的回文

00:19:12.620 --> 00:19:16.460
方法工作正常

00:19:14.350 --> 00:19:18.649
我提到的另一种选择是让你的

00:19:16.460 --> 00:19:20.000
自己的工厂方法，而不是使用

00:19:18.649 --> 00:19:22.370
您可以说增值方法的价值来源

00:19:20.000 --> 00:19:24.679
原始来源，您必须指定

00:19:22.370 --> 00:19:26.450
名称，但在最新版本中，我们

00:19:24.679 --> 00:19:28.639
如果测试也支持约定

00:19:26.450 --> 00:19:29.299
方法名称与工厂相同

00:19:28.639 --> 00:19:31.309
方法

00:19:29.299 --> 00:19:32.749
必须清除我们指定的内容，这样

00:19:31.309 --> 00:19:34.999
实际上会在这里调用此方法

00:19:32.749 --> 00:19:37.129
以及它返回的任何流

00:19:34.999 --> 00:19:38.659
这些将是为此的输入

00:19:37.129 --> 00:19:42.649
这种方法只需要一点点

00:19:38.659 --> 00:19:44.809
参数化的动态测试是

00:19:42.649 --> 00:19:47.269
真正全新的东西

00:19:44.809 --> 00:19:48.710
可能使用lambda表达式和

00:19:47.269 --> 00:19:50.720
方法参考以及Java和更高版本

00:19:48.710 --> 00:19:52.580
所以基本上我们有一个不同

00:19:50.720 --> 00:19:55.009
说明该方法不是

00:19:52.580 --> 00:19:57.169
测试自己或者说是一个紧张的工厂

00:19:55.009 --> 00:20:00.190
它生成测试并生成

00:19:57.169 --> 00:20:03.320
以这种动态测试的形式进行测试

00:20:00.190 --> 00:20:05.419
接口在这里，这样的实例

00:20:03.320 --> 00:20:06.889
动态测试与

00:20:05.419 --> 00:20:09.200
静态导入将为

00:20:06.889 --> 00:20:11.179
您基于的名字不给这个

00:20:09.200 --> 00:20:13.249
在这里进行测试，这将是

00:20:11.179 --> 00:20:15.169
实际测试是这里的身体

00:20:13.249 --> 00:20:16.879
此lambda表达式或方法

00:20:15.169 --> 00:20:18.919
在底部参考这里

00:20:16.879 --> 00:20:20.899
这个例子只是为了展示它是如何工作的

00:20:18.919 --> 00:20:22.399
基本上，但是你想创建

00:20:20.899 --> 00:20:24.289
我们正在迭代某种流

00:20:22.399 --> 00:20:26.149
我正在获取前十个偶数整数

00:20:24.289 --> 00:20:28.070
然后我们通过这些来映射您

00:20:26.149 --> 00:20:29.929
进行这些动态测试之一， 

00:20:28.070 --> 00:20:31.309
作为动态测试流返回

00:20:29.929 --> 00:20:33.980
然后每一个都会得到

00:20:31.309 --> 00:20:35.989
分别调用并报告，就好像

00:20:33.980 --> 00:20:38.739
他们是独立测试，我们将

00:20:35.989 --> 00:20:38.739
在IDE中看到

00:20:39.879 --> 00:20:45.289
说到这里，我们已经重复了

00:20:43.009 --> 00:20:47.659
就像我之前提到的那样测试

00:20:45.289 --> 00:20:49.100
运行了五次，我们看到的是

00:20:47.659 --> 00:20:51.049
我们在这里有另一个层次

00:20:49.100 --> 00:20:52.220
重复测试现在是一个容器， 

00:20:51.049 --> 00:20:54.379
以下是实际情况

00:20:52.220 --> 00:20:56.720
每个重复的指示

00:20:54.379 --> 00:20:58.399
在这里，我们可以看到另一个

00:20:56.720 --> 00:21:01.249
您可以有一个自定义的显示名称

00:20:58.399 --> 00:21:02.509
所以我们在这里看到这台德国电表

00:21:01.249 --> 00:21:03.590
一部手机很长，所以就像

00:21:02.509 --> 00:21:06.049
重复一二五

00:21:03.590 --> 00:21:07.940
刚刚翻译成德语

00:21:06.049 --> 00:21:09.889
参数化测试，我们有这些

00:21:07.940 --> 00:21:11.809
我之前提到的回文

00:21:09.889 --> 00:21:14.559
是源，这是流

00:21:11.809 --> 00:21:19.629
妈妈死了雷达等，如果我们运行这个

00:21:14.559 --> 00:21:19.629
我们看到的是

00:21:21.310 --> 00:21:25.460
好吧，所以我们看到每个

00:21:23.450 --> 00:21:26.780
调用它们出现在下面

00:21:25.460 --> 00:21:28.490
并且默认情况下我们有索引显示

00:21:26.780 --> 00:21:30.890
但如果您可以覆盖它

00:21:28.490 --> 00:21:32.150
不想显示索引，并且

00:21:30.890 --> 00:21:34.250
您实际上可以

00:21:32.150 --> 00:21:38.300
应该能够重新运行个人

00:21:34.250 --> 00:21:40.010
希望这是一个不错的功能

00:21:38.300 --> 00:21:42.050
之所以有效，是因为有一个过滤器

00:21:40.010 --> 00:21:45.020
机制，所以我们看到它实际上只运行了

00:21:42.050 --> 00:21:48.230
我问错了的那个

00:21:45.020 --> 00:21:50.770
在类似我们的动态测试中流到那里

00:21:48.230 --> 00:21:52.940
有前十个整数和一些

00:21:50.770 --> 00:21:55.040
字符串在这里，如果我们运行，我们看到一些

00:21:52.940 --> 00:21:57.950
类似的结果，所以动态测试是

00:21:55.040 --> 00:21:59.540
类字符串基本上是

00:21:57.950 --> 00:22:01.760
出厂后再实际指示

00:21:59.540 --> 00:22:04.250
正常测试中列出的正常

00:22:01.760 --> 00:22:05.690
在报告中进行测试，以及是否要

00:22:04.250 --> 00:22:07.040
双击其中一个

00:22:05.690 --> 00:22:09.350
实际上去工厂是因为

00:22:07.040 --> 00:22:10.520
那里没有实际的方法，但是

00:22:09.350 --> 00:22:13.490
理论上你也应该能够重新运行

00:22:10.520 --> 00:22:17.810
测试B，我们看看它是否可以像

00:22:13.490 --> 00:22:19.550
是的，这样也很好

00:22:17.810 --> 00:22:23.990
您拥有的过滤功能全部支持

00:22:19.550 --> 00:22:25.640
内置到所有IDS中

00:22:23.990 --> 00:22:27.170
过去的并行测试执行

00:22:25.640 --> 00:22:28.550
你可能已经用你的

00:22:27.170 --> 00:22:31.010
构建工具或其他一些第三方

00:22:28.550 --> 00:22:33.800
从那以后我们内置支持的库

00:22:31.010 --> 00:22:35.180
 5.3和j单位木星

00:22:33.800 --> 00:22:36.680
基本上你必须设置它

00:22:35.180 --> 00:22:39.530
木星执行平行的简

00:22:36.680 --> 00:22:42.470
如果您想将启用的标志设置为true 

00:22:39.530 --> 00:22:44.450
默认情况下它不处于启用状态，因为您

00:22:42.470 --> 00:22:45.710
可能不希望它会使您

00:22:44.450 --> 00:22:46.550
测试不能很好地进行，如果

00:22:45.710 --> 00:22:48.320
您还没有准备好运行它

00:22:46.550 --> 00:22:50.780
您也可以在

00:22:48.320 --> 00:22:53.090
我们的Jade平台属性文件

00:22:50.780 --> 00:22:54.830
查看启动器API或您的IDE或

00:22:53.090 --> 00:22:57.320
一些构建工具在哪里

00:22:54.830 --> 00:22:59.120
系统属性，因此您可以做的另一件事

00:22:57.320 --> 00:23:00.530
您可以将策略配置为

00:22:59.120 --> 00:23:02.600
用于如何使用它们

00:23:00.530 --> 00:23:04.280
实际上默认情况下并行

00:23:02.600 --> 00:23:06.590
只是根据数量来动态

00:23:04.280 --> 00:23:08.990
如果您设置了CPU和核心

00:23:06.590 --> 00:23:11.000
固定号码或自定义策略（如果您

00:23:08.990 --> 00:23:13.040
想记住另一件事

00:23:11.000 --> 00:23:14.390
虽然是同步，所以你

00:23:13.040 --> 00:23:16.490
可能想选择或更改

00:23:14.390 --> 00:23:18.170
执行模式可以禁用视差

00:23:16.490 --> 00:23:21.500
每次测试提示ssin 

00:23:18.170 --> 00:23:23.360
每个类别的基础或使用

00:23:21.500 --> 00:23:24.530
例如添加执行注释

00:23:23.360 --> 00:23:26.960
将其设置为同一线程，我会

00:23:24.530 --> 00:23:28.250
说不要同时运行，但是你

00:23:26.960 --> 00:23:30.530
也可以为

00:23:28.250 --> 00:23:32.420
明确地特定

00:23:30.530 --> 00:23:33.680
并控制同步，以便

00:23:32.420 --> 00:23:35.270
有时候事情不应该在

00:23:33.680 --> 00:23:36.530
同时你可能会想

00:23:35.270 --> 00:23:38.420
关于数据库和类似的

00:23:36.530 --> 00:23:40.010
锁，所以我们对

00:23:38.420 --> 00:23:42.620
称为资源锁，它只需要

00:23:40.010 --> 00:23:44.390
字符串，基本上是事物的名称

00:23:42.620 --> 00:23:45.860
那是你的资源，这可能是我的

00:23:44.390 --> 00:23:47.740
资源中有一些默认的东西

00:23:45.860 --> 00:23:50.300
内置类似系统输出的系统错误

00:23:47.740 --> 00:23:51.920
语言环境之类的东西，所以您可以

00:23:50.300 --> 00:23:53.750
您可以将其切换，也可以

00:23:51.920 --> 00:23:57.110
将其从读写模式更改为

00:23:53.750 --> 00:23:59.450
阅读模式，所以这一切学说，然后

00:23:57.110 --> 00:24:00.920
参考期刊，但您可以

00:23:59.450 --> 00:24:03.230
好主意，这里支持什么

00:24:00.920 --> 00:24:05.450
所以让我们快速看一下

00:24:03.230 --> 00:24:09.230
看起来像我们有

00:24:05.450 --> 00:24:10.640
参数化测试，所以现在如果我运行

00:24:09.230 --> 00:24:12.560
它正在计算斐波那契数

00:24:10.640 --> 00:24:19.190
有一些日志输出，我会看看

00:24:12.560 --> 00:24:21.710
大概需要多长时间

00:24:19.190 --> 00:24:23.510
有点长，它仍然在运行

00:24:21.710 --> 00:24:27.170
出现，所以他们都完成了

00:24:23.510 --> 00:24:29.330
 11 11测试一直执行到斐波那契

00:24:27.170 --> 00:24:33.020
 44，如果我们在控制台中查看

00:24:29.330 --> 00:24:35.300
看到它从大约8点开始

00:24:33.020 --> 00:24:38.270
降到18，所以我大约是10秒

00:24:35.300 --> 00:24:40.840
如果我们想的话，大约现在

00:24:38.270 --> 00:24:42.950
开启对所有事物的支持

00:24:40.840 --> 00:24:44.120
并行运行，我们可以设置这个

00:24:42.950 --> 00:24:46.160
标记我已经在初中做到了

00:24:44.120 --> 00:24:48.680
平台属性文件已启用true 

00:24:46.160 --> 00:24:52.840
如果我重新运行它，将会发生什么

00:24:48.680 --> 00:24:56.660
现在我们看到了什么

00:24:52.840 --> 00:24:58.250
您会看到全部运行11，现在，如果我们看一下

00:24:56.660 --> 00:25:01.580
大概开始的时间

00:24:58.250 --> 00:25:03.350
在43岁时升至47岁， 

00:25:01.580 --> 00:25:04.670
大约4秒，所以快很多

00:25:03.350 --> 00:25:06.560
我们在这里看到的另一件事

00:25:04.670 --> 00:25:07.700
日志输出是我已经显示了线程

00:25:06.560 --> 00:25:09.530
如果他们在继续前进，那么你会看到

00:25:07.700 --> 00:25:10.700
 fork / join池用于运行

00:25:09.530 --> 00:25:12.680
这些东西并行，我们看到多个

00:25:10.700 --> 00:25:14.780
不同的工人在同一时间执行

00:25:12.680 --> 00:25:17.330
时间，这是加快您的速度的一种方法

00:25:14.780 --> 00:25:19.310
测试和您的构建以及其中的构建

00:25:17.330 --> 00:25:24.290
使用IDE，这非常漂亮

00:25:19.310 --> 00:25:25.430
从5.3开始很简单

00:25:24.290 --> 00:25:27.830
关于詹姆斯·朱庇特的事情真的会

00:25:25.430 --> 00:25:28.940
真正专注于可扩展性

00:25:27.830 --> 00:25:30.890
对我来说最重要的事情

00:25:28.940 --> 00:25:33.170
春天来了

00:25:30.890 --> 00:25:34.880
在Springs扩展上受支持

00:25:33.170 --> 00:25:36.650
集成会话支持，现在我们

00:25:34.880 --> 00:25:39.020
类似的有点舒服

00:25:36.650 --> 00:25:41.210
模特和贾娜·朱庇特（Jana Jupiter），所以我们有一个

00:25:39.020 --> 00:25:42.300
新模型全新，不是

00:25:41.210 --> 00:25:45.030
规则

00:25:42.300 --> 00:25:47.340
从小就知道。因为我们有什么

00:25:45.030 --> 00:25:48.570
我们称其为扩展API扩展

00:25:47.340 --> 00:25:50.430
本身就是一个接口

00:25:48.570 --> 00:25:52.590
标记界面实际上并没有

00:25:50.430 --> 00:25:54.570
除了我们所有的扩展

00:25:52.590 --> 00:25:57.810
已驻留在该组织的Jane Jupiter API中

00:25:54.570 --> 00:25:59.940
扩展包，您可以实施

00:25:57.810 --> 00:26:01.350
随便你多

00:25:59.940 --> 00:26:03.270
您可以选择一个扩展名

00:26:01.350 --> 00:26:05.190
 API统一实现

00:26:03.270 --> 00:26:07.500
实施，您注册

00:26:05.190 --> 00:26:09.330
与扩展与注册

00:26:07.500 --> 00:26:11.190
同时一个或多个扩展

00:26:09.330 --> 00:26:12.930
所以你知道简，因为你可能知道

00:26:11.190 --> 00:26:14.280
你不能有多个跑步者

00:26:12.930 --> 00:26:15.870
同时支持多个扩展

00:26:14.280 --> 00:26:17.910
自从Jane和

00:26:15.870 --> 00:26:19.890
木星，你可以注册这些

00:26:17.910 --> 00:26:22.800
通过接口上的东西

00:26:19.890 --> 00:26:24.720
它是元的类或方法级别

00:26:22.800 --> 00:26:26.460
注解和您想要的最后一部分

00:26:24.720 --> 00:26:27.960
以编程方式执行此操作，以便您可以

00:26:26.460 --> 00:26:29.760
使用在字段上注册扩展名

00:26:27.960 --> 00:26:31.980
这有点类似于

00:26:29.760 --> 00:26:36.090
规则支持网教室支持您

00:26:31.980 --> 00:26:38.280
从简到四点

00:26:36.090 --> 00:26:39.960
首先是生命周期回调

00:26:38.280 --> 00:26:42.660
在我回电之前，我们有

00:26:39.960 --> 00:26:44.250
一会儿我会回电，所以在一切之前

00:26:42.660 --> 00:26:46.260
就像上课前一样

00:26:44.250 --> 00:26:47.520
下课后，简到四，然后

00:26:46.260 --> 00:26:49.770
下次我们每个人都拥有

00:26:47.520 --> 00:26:51.000
回调，然后每次

00:26:49.770 --> 00:26:53.010
紧接在之前的事物和

00:26:51.000 --> 00:26:54.960
您执行后立即

00:26:53.010 --> 00:26:58.550
测试方法，这些是报告

00:26:54.960 --> 00:27:00.480
和测试执行后的回调

00:26:58.550 --> 00:27:02.520
所以要记住的是，这些

00:27:00.480 --> 00:27:04.500
他们包装用户提供的扩展

00:27:02.520 --> 00:27:06.870
生命周期方法和测试方法

00:27:04.500 --> 00:27:09.060
所以如果我们看一下

00:27:06.870 --> 00:27:10.260
所有方法都不可见

00:27:09.060 --> 00:27:11.550
而这些毕竟是

00:27:10.260 --> 00:27:13.650
方法和见解将是

00:27:11.550 --> 00:27:15.120
在每种方法之前，以及

00:27:13.650 --> 00:27:17.780
每两种方法，然后在这里

00:27:15.120 --> 00:27:20.540
将是实际的行为测试方法或

00:27:17.780 --> 00:27:22.800
参数测试和类似的东西

00:27:20.540 --> 00:27:23.550
接下来，我们还有其他各种API，因此我们

00:27:22.800 --> 00:27:25.590
也支持

00:27:23.550 --> 00:27:28.170
执行条件，然后我们再谈

00:27:25.590 --> 00:27:30.630
详细说明测试工厂

00:27:28.170 --> 00:27:32.070
最近您实际上可以创建CD进行测试

00:27:30.630 --> 00:27:35.370
自己实例而不是让

00:27:32.070 --> 00:27:37.410
跳动它，我为你遮荫测试

00:27:35.370 --> 00:27:39.150
感觉是后处理器，因此您可以

00:27:37.410 --> 00:27:42.020
在其中设置内容

00:27:39.150 --> 00:27:45.030
参数Oliver可以解决

00:27:42.020 --> 00:27:47.400
构造函数和方法的参数

00:27:45.030 --> 00:27:49.140
这最后三个基本上总结

00:27:47.400 --> 00:27:51.510
支持依赖注入和

00:27:49.140 --> 00:27:53.820
春天实际上利用了

00:27:51.510 --> 00:27:55.979
后一颗牙齿炸弹，但不是个人

00:27:53.820 --> 00:27:57.960
这是一口测试模板

00:27:55.979 --> 00:27:59.190
指示上下文提供者大多数人

00:27:57.960 --> 00:28:00.419
不会实现它，但这就是我们的方式

00:27:59.190 --> 00:28:02.489
可以发酵对诸如此类的支持

00:28:00.419 --> 00:28:04.979
重复的测试和参数化

00:28:02.489 --> 00:28:07.109
测试那些更高级的

00:28:04.979 --> 00:28:08.100
还支持处理异常，因此

00:28:07.109 --> 00:28:11.970
如果你想自己写

00:28:08.100 --> 00:28:13.559
您可以预期的异常扩展

00:28:11.970 --> 00:28:16.200
那样说你会期望某种

00:28:13.559 --> 00:28:18.419
测试观察者抛出异常

00:28:16.200 --> 00:28:20.399
全新，因此灵感来自于

00:28:18.419 --> 00:28:22.619
 JT 4基本上可以让您看到它

00:28:20.399 --> 00:28:25.950
当测试被禁用时

00:28:22.619 --> 00:28:27.960
跳过，类似的东西也很新

00:28:25.950 --> 00:28:29.249
在显示器和发电机上，您可以

00:28:27.960 --> 00:28:31.080
以编程方式决定显示什么

00:28:29.249 --> 00:28:32.700
名称应为，方法顺序应为

00:28:31.080 --> 00:28:34.109
让我们看一下最后两个

00:28:32.700 --> 00:28:35.309
更多细节，这些实际上是

00:28:34.109 --> 00:28:37.559
与所有其他扩展名不同

00:28:35.309 --> 00:28:39.599
因为应用了最后两个

00:28:37.559 --> 00:28:41.789
在发现阶段之前

00:28:39.599 --> 00:28:45.929
测试实际上我很可爱，所以

00:28:41.789 --> 00:28:47.129
当一个单位正在寻找测试时， 

00:28:45.929 --> 00:28:48.809
源一解释生成器

00:28:47.129 --> 00:28:51.119
基本上可以让您生成自定义

00:28:48.809 --> 00:28:52.349
显示您的类和方法的名称

00:28:51.119 --> 00:28:54.419
可以配置一个我正在的视图

00:28:52.349 --> 00:28:56.190
可以解释世代注释

00:28:54.419 --> 00:28:57.059
如果想在哪里实现自己的

00:28:56.190 --> 00:28:59.159
您可以使用内置的之一

00:28:57.059 --> 00:29:00.960
现在我们有一个标准的

00:28:59.159 --> 00:29:02.279
只是默认行为，我们有

00:29:00.960 --> 00:29:05.009
一种叫做替换下划线

00:29:02.279 --> 00:29:06.840
并不奇怪，它取代了

00:29:05.009 --> 00:29:09.210
下划线带有空格，所以很多

00:29:06.840 --> 00:29:11.639
人们喜欢写基于骆驼的

00:29:09.210 --> 00:29:12.779
测试方法名称或下划线

00:29:11.639 --> 00:29:14.399
他们，这将自动

00:29:12.779 --> 00:29:19.259
替换它们，以便您拥有这些不错的

00:29:14.399 --> 00:29:22.139
可读的名称并报告

00:29:19.259 --> 00:29:23.429
方法顺序可让您控制

00:29:22.139 --> 00:29:25.849
测试方法的顺序

00:29:23.429 --> 00:29:28.349
在单个测试类中执行

00:29:25.849 --> 00:29:30.479
有些争议，但这不是

00:29:28.349 --> 00:29:32.220
无论如何这里有时辩论

00:29:30.479 --> 00:29:33.840
您可能需要单元测试

00:29:32.220 --> 00:29:34.889
不应该使用这个，但是如果你有

00:29:33.840 --> 00:29:36.090
这样的东西

00:29:34.889 --> 00:29:37.679
集成测试或功能测试

00:29:36.090 --> 00:29:39.690
在某种程度上顺序很重要的地方

00:29:37.679 --> 00:29:40.710
有状态的东西或数据库，那么它

00:29:39.690 --> 00:29:42.149
将它们运行在一个

00:29:40.710 --> 00:29:44.279
特定的订单和您可以做的方式

00:29:42.149 --> 00:29:45.389
即使用该测试方法命令您

00:29:44.279 --> 00:29:48.029
可以实现自己使用之一

00:29:45.389 --> 00:29:50.220
内置的我们有字母数字什么

00:29:48.029 --> 00:29:53.460
按名称对方法进行排序，然后

00:29:50.220 --> 00:29:55.470
可选地通过参数（如果有） 

00:29:53.460 --> 00:29:56.820
订单名称相同

00:29:55.470 --> 00:29:58.619
注释一，使您能够

00:29:56.820 --> 00:30:00.330
指定警戒线，指定号码，以便

00:29:58.619 --> 00:30:02.279
像一二三四说并运行它们

00:30:00.330 --> 00:30:04.379
正是这个顺序，然后我们有一个

00:30:02.279 --> 00:30:05.830
进行伪随机排序

00:30:04.379 --> 00:30:07.690
如果您要确保

00:30:05.830 --> 00:30:09.279
您的测试之间没有依赖关系

00:30:07.690 --> 00:30:12.820
方法，那只是一个好主意

00:30:09.279 --> 00:30:14.169
您可以为此随机设置

00:30:12.820 --> 00:30:16.330
禁用的注释前面提到过

00:30:14.169 --> 00:30:18.419
这是什么意思

00:30:16.330 --> 00:30:20.529
条件测试执行的想法和

00:30:18.419 --> 00:30:22.090
基本上这是一个地方

00:30:20.529 --> 00:30:25.630
扩展模型符合Bergeron模型

00:30:22.090 --> 00:30:27.250
我们有这个执行条件API 

00:30:25.630 --> 00:30:28.269
可以在禁用时实现

00:30:27.250 --> 00:30:29.980
注释，我们有那个

00:30:28.269 --> 00:30:31.840
实际上是用

00:30:29.980 --> 00:30:34.149
残疾状况，这并不难

00:30:31.840 --> 00:30:36.279
编码或仅对贾达木星特别

00:30:34.149 --> 00:30:38.260
任何人都可以写这些东西之一， 

00:30:36.279 --> 00:30:39.940
这实际上是一个改变游戏规则的人

00:30:38.260 --> 00:30:41.679
因为任何人都可以再写一次

00:30:39.940 --> 00:30:43.120
简为可能的唯一方式

00:30:41.679 --> 00:30:44.200
某些东西被禁用或忽略

00:30:43.120 --> 00:30:47.500
说出来忽略，你不可能

00:30:44.200 --> 00:30:48.700
任何形式的动态条件

00:30:47.500 --> 00:30:50.260
我们拥有的另一个功能是您可以打开

00:30:48.700 --> 00:30:52.600
如果您想看到

00:30:50.260 --> 00:30:54.250
被禁用的东西也许你

00:30:52.600 --> 00:30:56.289
现在应该运行，然后您可以在空间上

00:30:54.250 --> 00:30:57.549
指定一个模式，指定哪个

00:30:56.289 --> 00:31:01.330
条件不为此而运行

00:30:57.549 --> 00:31:03.370
特定的测试计划构建条件

00:31:01.330 --> 00:31:05.110
所以我们有一个五岁以下的残障人士

00:31:03.370 --> 00:31:06.340
哦，五个，我们介绍了一个

00:31:05.110 --> 00:31:08.559
战争次数，因此增加了能力和

00:31:06.340 --> 00:31:09.669
如果可能不推荐使用，则禁用

00:31:08.559 --> 00:31:10.870
学生们也许你不想看

00:31:09.669 --> 00:31:14.529
那基本上是让你

00:31:10.870 --> 00:31:16.360
使用JavaScript决定测试是否

00:31:14.529 --> 00:31:18.730
应该运行还是更受欢迎

00:31:16.360 --> 00:31:21.909
你有能力说的事情

00:31:18.730 --> 00:31:24.429
在给定的JDK（例如JDK 8 9 10）上进行此测试

00:31:21.909 --> 00:31:26.559
还是不给Mac这样的操作系统

00:31:24.429 --> 00:31:29.230
或Linux，或者如果我给它系统属性

00:31:26.559 --> 00:31:30.880
或是否设置了环境变量

00:31:29.230 --> 00:31:32.649
这会给您很大的动力

00:31:30.880 --> 00:31:34.690
您只需在这些注解中放入框

00:31:32.649 --> 00:31:38.409
然后我说启用或禁用您的

00:31:34.690 --> 00:31:41.409
进行测试，以便您是否经常使用jana 

00:31:38.409 --> 00:31:42.519
人们有一些疑问我必须

00:31:41.409 --> 00:31:45.970
迁移jana 5或

00:31:42.519 --> 00:31:49.600
贾纳·朱庇特（Jana Jupiter）还是我想答案

00:31:45.970 --> 00:31:52.120
是的，没有，基本上您可以运行

00:31:49.600 --> 00:31:53.830
 Jana用于在Jana平台上进行测试

00:31:52.120 --> 00:31:55.450
老式测试引擎，无需更改

00:31:53.830 --> 00:31:58.240
他们他们会这样工作

00:31:55.450 --> 00:31:59.769
不，但是您也可以运行jan 

00:31:58.240 --> 00:32:01.630
与Juvia一起再次抗议

00:31:59.769 --> 00:32:02.980
相同的测试报告也相当

00:32:01.630 --> 00:32:05.889
很好，这是它的好处之一

00:32:02.980 --> 00:32:08.019
平台构想与同一项目相同

00:32:05.889 --> 00:32:09.789
想法相同的建立，你也可以逐渐

00:32:08.019 --> 00:32:11.620
如果您想在1月进行迁移

00:32:09.789 --> 00:32:13.809
您需要参加6月的测试

00:32:11.620 --> 00:32:15.610
木星，但你不必纠正你

00:32:13.809 --> 00:32:17.810
可以保持您的旧测试不变

00:32:15.610 --> 00:32:21.710
然后和詹姆斯一起写新的测试

00:32:17.810 --> 00:32:24.320
这就是很多项目所做的，但是

00:32:21.710 --> 00:32:27.500
如果您确实想移植一些想法或

00:32:24.320 --> 00:32:29.270
有些事情请记住注释，因此

00:32:27.500 --> 00:32:31.520
测试仍然称为测试，但是它在

00:32:29.270 --> 00:32:33.560
我现在忽略的新包装现在在

00:32:31.520 --> 00:32:35.390
残疾人或其他残疾人之一

00:32:33.560 --> 00:32:36.620
上课前的变体和一半

00:32:35.390 --> 00:32:38.510
毕竟现在在岛上的教室

00:32:36.620 --> 00:32:40.580
相同或之前和之后

00:32:38.510 --> 00:32:41.960
在每个断言之前和之后

00:32:40.580 --> 00:32:43.910
在新的班级里上了新班

00:32:41.960 --> 00:32:46.070
包装相同的假设

00:32:43.910 --> 00:32:47.360
从Jane那里记住的任何事情

00:32:46.070 --> 00:32:49.340
这是此失败消息

00:32:47.360 --> 00:32:51.950
最后一次在您迁移时，如果您有

00:32:49.340 --> 00:32:53.660
一个字符串，然后你可能会

00:32:51.950 --> 00:32:56.690
必须确保你做对了

00:32:53.660 --> 00:32:58.900
这就是论点，所以我们确实有一些

00:32:56.690 --> 00:33:01.070
支持迁移Jana以获得规则

00:32:58.900 --> 00:33:04.190
有一个海军的农村移民

00:33:01.070 --> 00:33:05.750
支持这是在特定项目中

00:33:04.190 --> 00:33:08.750
你必须包括J和木星

00:33:05.750 --> 00:33:10.010
 Gatien支持其可选的实验

00:33:08.750 --> 00:33:12.230
它可能不会改变，但是

00:33:10.010 --> 00:33:13.340
它更多是可选功能，但如果

00:33:12.230 --> 00:33:14.660
你有那个然后你把它放在

00:33:13.340 --> 00:33:16.250
你的课然后

00:33:14.660 --> 00:33:19.160
自动注册三个扩展

00:33:16.250 --> 00:33:21.080
来自木星的这三个，所以你

00:33:19.160 --> 00:33:23.180
得到诸如Jana之类的支持

00:33:21.080 --> 00:33:25.760
强制临时文件夹错误收集器

00:33:23.180 --> 00:33:27.620
如果您想做的话，一个预期的例外

00:33:25.760 --> 00:33:29.960
那件事我们增加了更多

00:33:27.620 --> 00:33:31.880
最近在以下位置支持JUnit 4 

00:33:29.960 --> 00:33:33.140
忽略注释，所以如果您想

00:33:31.880 --> 00:33:34.910
继续使用，您可以使用此

00:33:33.140 --> 00:33:36.830
启用了单位的不同注释

00:33:34.910 --> 00:33:38.540
对于迁移支持，它将忽略

00:33:36.830 --> 00:33:39.860
很抱歉为您注册一个条件

00:33:38.540 --> 00:33:41.870
支持此添加方向

00:33:39.860 --> 00:33:43.610
简4就这样禁用了一个

00:33:41.870 --> 00:33:45.380
包含木星，我的意思是

00:33:43.610 --> 00:33:47.840
包括我们在

00:33:45.380 --> 00:33:50.750
上一张幻灯片，另一件事是，如果

00:33:47.840 --> 00:33:52.970
您使用的是Jane it orga Janet， 

00:33:50.750 --> 00:33:54.890
这些假设来自Jane在4岁及以下

00:33:52.970 --> 00:33:56.810
这些迁移的过程将全部

00:33:54.890 --> 00:33:58.880
自从Jane和

00:33:56.810 --> 00:34:01.250
木星5.4所以这意味着任何

00:33:58.880 --> 00:34:03.620
将简扔向违反

00:34:01.250 --> 00:34:06.650
异常将被视为已中止

00:34:03.620 --> 00:34:07.880
在Jane和Jupiter 5.4中测试一个bug 

00:34:06.650 --> 00:34:09.470
而以前它会

00:34:07.880 --> 00:34:14.150
实际上没有通过测试，那是一个

00:34:09.470 --> 00:34:16.670
有些人感到困惑，那是什么

00:34:14.150 --> 00:34:19.220
自从主要主要版本发布以来新增

00:34:16.670 --> 00:34:20.810
简与我一样有5项功能

00:34:19.220 --> 00:34:22.760
我没有提到的时候提到的是我们

00:34:20.810 --> 00:34:23.810
介绍给珍妮特·梅文炸弹，如果

00:34:22.760 --> 00:34:24.890
你不使用 spring boot ，你可能

00:34:23.810 --> 00:34:26.770
想调查炸弹

00:34:24.890 --> 00:34:29.210
简化依赖关系管理

00:34:26.770 --> 00:34:30.889
在执行前奏时，我们看到有

00:34:29.210 --> 00:34:33.019
还支持捕获系统

00:34:30.889 --> 00:34:35.029
他们伴随的系统错误

00:34:33.019 --> 00:34:37.099
我们提到的并行测试执行

00:34:35.029 --> 00:34:40.159
自定义测试源的动态

00:34:37.099 --> 00:34:41.809
测试您是否要进行动态测试

00:34:40.159 --> 00:34:43.760
你在棉花里

00:34:41.809 --> 00:34:45.440
随着时间的推移从外部改善

00:34:43.760 --> 00:34:49.309
真正的贡献者

00:34:45.440 --> 00:34:51.559
热衷于使用棉花登记册扩展名

00:34:49.309 --> 00:34:53.169
肠工厂等等

00:34:51.559 --> 00:34:55.460
最近有些事情要强调

00:34:53.169 --> 00:34:58.010
木星现在有一个新的简

00:34:55.460 --> 00:35:00.500
基本上可以使用的依赖

00:34:58.010 --> 00:35:02.029
可以说是对所有主要事物进行了评分

00:35:00.500 --> 00:35:03.230
来自简和木星，你可以

00:35:02.029 --> 00:35:05.059
说你依靠简和木星

00:35:03.230 --> 00:35:07.369
而不是单个文物

00:35:05.059 --> 00:35:08.809
它只会使xml变得更容易

00:35:07.369 --> 00:35:10.730
报告他们在那里制作的清单

00:35:08.809 --> 00:35:11.930
那个公众最近有一个新的测试

00:35:10.730 --> 00:35:14.299
工具包，如果您正在编写自己的测试

00:35:11.930 --> 00:35:16.039
引擎，如果你想走那条路或者

00:35:14.299 --> 00:35:17.599
如果您想测试扩展程序

00:35:16.039 --> 00:35:19.490
在木星上为简写的话，你可以

00:35:17.599 --> 00:35:21.380
传统上使用新的测试套件， 

00:35:19.490 --> 00:35:25.279
 504，这样更容易

00:35:21.380 --> 00:35:27.559
测试温度支持的那些东西

00:35:25.279 --> 00:35:29.539
那很受欢迎，要求他们

00:35:27.559 --> 00:35:31.609
支持简在四点钟

00:35:29.539 --> 00:35:33.619
规则，现在我们对此表示支持

00:35:31.609 --> 00:35:36.049
从5.4开始，简和木星就如此

00:35:33.619 --> 00:35:38.359
基本上可以将温度注入

00:35:36.049 --> 00:35:39.680
文件所在的路径，您可以在其中工作

00:35:38.359 --> 00:35:41.569
在您的构造函数中进行测试

00:35:39.680 --> 00:35:43.160
方法等，然后贾登会清理它

00:35:41.569 --> 00:35:44.230
之后为您服务，所以基本上

00:35:43.160 --> 00:35:47.750
删除目录

00:35:44.230 --> 00:35:49.039
这些就是所有测试顺序

00:35:47.750 --> 00:35:50.029
也可以订购扩展

00:35:49.039 --> 00:35:52.700
无需注册即可注册

00:35:50.029 --> 00:35:55.150
通过at顺序通过字段扩展

00:35:52.700 --> 00:35:55.150
注解

00:35:58.540 --> 00:36:07.460
嗯，好吧，我要怎么了

00:36:05.390 --> 00:36:10.550
真正的5.5我们已经有一些

00:36:07.460 --> 00:36:13.250
里程碑，我们将为

00:36:10.550 --> 00:36:15.200
布尔值和这些值的来源

00:36:13.250 --> 00:36:17.210
内置条件，例如运行

00:36:15.200 --> 00:36:18.950
特定的操作系统，所以我很安全，属于JD案件

00:36:17.210 --> 00:36:20.270
就像你必须使用可重复的

00:36:18.950 --> 00:36:28.040
注释，以便它们如何声明

00:36:20.270 --> 00:36:28.700
关于超时我多次

00:36:28.040 --> 00:36:30.680
告诉你怎么做

00:36:28.700 --> 00:36:32.240
以编程方式没有证书超时

00:36:30.680 --> 00:36:33.620
我们将介绍对

00:36:32.240 --> 00:36:35.990
声明您想要一个特定的

00:36:33.620 --> 00:36:39.430
您所有测试方法的超时时间

00:36:35.990 --> 00:36:41.630
特殊的班级之类的东西

00:36:39.430 --> 00:36:44.690
还有一个新的调用

00:36:41.630 --> 00:36:46.250
拦截器扩展API，允许

00:36:44.690 --> 00:36:47.900
您要做诸如建立

00:36:46.250 --> 00:36:49.640
代码和用户神圣的线程

00:36:47.900 --> 00:36:53.390
如果使用某些东西可能会很好地工作

00:36:49.640 --> 00:36:54.590
例如SWT，如果您正在做某事

00:36:53.390 --> 00:36:56.810
更底层的喜欢自己写

00:36:54.590 --> 00:36:59.210
测试引擎，我们将有一个新的配置

00:36:56.810 --> 00:37:00.770
只是测试发现基础的实现

00:36:59.210 --> 00:37:03.890
你可以建立和扩展，如果你

00:37:00.770 --> 00:37:05.750
想要在积压中有一些

00:37:03.890 --> 00:37:07.070
未来我们正在寻找的东西

00:37:05.750 --> 00:37:10.340
想在某个时候增加支持

00:37:07.070 --> 00:37:12.290
使用自定义类加载器获得支持

00:37:10.340 --> 00:37:13.190
用于程序扩展管理

00:37:12.290 --> 00:37:15.440
而不是仅仅用

00:37:13.190 --> 00:37:17.020
我们希望我们支持的注释

00:37:15.440 --> 00:37:19.100
对测试套件的一流支持

00:37:17.020 --> 00:37:21.530
参数测试类，所以我提到

00:37:19.100 --> 00:37:23.000
我们有参数化的测试方法

00:37:21.530 --> 00:37:25.070
现在，但我们正在考虑增加支持

00:37:23.000 --> 00:37:26.420
家长设定测试班并

00:37:25.070 --> 00:37:29.750
同一测试类可以运行多次

00:37:26.420 --> 00:37:31.580
使用不同的输入方案测试是

00:37:29.750 --> 00:37:33.500
我们正在寻找其他东西

00:37:31.580 --> 00:37:37.190
你有多个步骤，他们进入一个

00:37:33.500 --> 00:37:38.600
特定顺序和新报告

00:37:37.190 --> 00:37:40.670
格式，所以我已经显示了一些东西

00:37:38.600 --> 00:37:42.260
像自定义显示名称之类的

00:37:40.670 --> 00:37:44.060
动态测试，我们有不同的

00:37:42.260 --> 00:37:46.310
最终的层次结构

00:37:44.060 --> 00:37:48.080
测试，我们需要一种新的报告格式

00:37:46.310 --> 00:37:51.650
支持这些事情，所以

00:37:48.080 --> 00:37:53.030
我们希望在下一个

00:37:51.650 --> 00:37:54.230
几个月左右，但可能

00:37:53.030 --> 00:37:56.290
花了一段时间让整个世界

00:37:54.230 --> 00:37:58.340
赶上，所以我们可能正在使用

00:37:56.290 --> 00:38:01.520
一段时间内使用不同的格式，或同时使用

00:37:58.340 --> 00:38:02.900
同时是核心

00:38:01.520 --> 00:38:05.090
关于基因，我们将稍作讨论

00:38:02.900 --> 00:38:08.530
春天和木星的基因

00:38:05.090 --> 00:38:12.170
自从红军春季运动会开始

00:38:08.530 --> 00:38:15.710
所以谁真正使用过简·木星

00:38:12.170 --> 00:38:18.230
到了春天，任何人都可以，六个七个人

00:38:15.710 --> 00:38:18.920
我希望它能顺利进行

00:38:18.230 --> 00:38:21.380
关于我

00:38:18.920 --> 00:38:23.420
好吧，所以它已经完全集成在

00:38:21.380 --> 00:38:25.940
 Spring Framework自从五死

00:38:23.420 --> 00:38:28.010
春天，它支持所有核心

00:38:25.940 --> 00:38:29.390
您拥有的集成测试功能

00:38:28.010 --> 00:38:32.059
认识，我爱春天， 

00:38:29.390 --> 00:38:33.260
 spring boot ，但除此之外

00:38:32.059 --> 00:38:36.010
不可能的新事物

00:38:33.260 --> 00:38:37.880
 Jana Fortis和G，所以我们对

00:38:36.010 --> 00:38:39.950
构造函数和方法注入

00:38:37.880 --> 00:38:41.450
使用注解进行依赖注入

00:38:39.950 --> 00:38:43.880
来自Spring的注释，例如在Auto处

00:38:41.450 --> 00:38:45.650
有线的限定词和价值，我们也

00:38:43.880 --> 00:38:49.130
支持条件测试

00:38:45.650 --> 00:38:52.130
用咒语表达来执行

00:38:49.130 --> 00:38:53.630
稍等一下，我们有

00:38:52.130 --> 00:38:55.609
我们可以使用一些特殊的注释

00:38:53.630 --> 00:38:57.260
简化它也可以使用的东西

00:38:55.609 --> 00:38:59.630
如果碰巧是Spring Framework 4.3 

00:38:57.260 --> 00:39:01.579
卡住了三个，无法升级到

00:38:59.630 --> 00:39:03.319
五五一或即将到来的五二

00:39:01.579 --> 00:39:04.130
那是在我的身边

00:39:03.319 --> 00:39:05.809
存放处和指示

00:39:04.130 --> 00:39:07.280
那里有如何使用它的方法

00:39:05.809 --> 00:39:10.130
人们确实想去那里

00:39:07.280 --> 00:39:11.660
继续使用，现在使用Jana Jupiter 

00:39:10.130 --> 00:39:12.890
春天的框架，但三个保持

00:39:11.660 --> 00:39:16.190
请记住，它没有新功能

00:39:12.890 --> 00:39:22.099
因此新功能全部加入5.2 

00:39:16.190 --> 00:39:23.839
即将到来的Spring 5.2的示例

00:39:22.099 --> 00:39:25.549
在Jana 4设置它，我们有了春天

00:39:23.839 --> 00:39:27.349
亚军和贾纳·朱庇特，我们有一个春天

00:39:25.549 --> 00:39:28.700
延伸可以说是用弹簧延伸

00:39:27.349 --> 00:39:30.589
扩展名，如果您想手动执行

00:39:28.700 --> 00:39:32.180
但我们有一些不错的组成

00:39:30.589 --> 00:39:34.760
批注，这样就可以实现Jana配置

00:39:32.180 --> 00:39:36.890
结合了浓度

00:39:34.760 --> 00:39:39.109
记号加上春天的注册

00:39:36.890 --> 00:39:41.210
以及类似的网络支持

00:39:39.109 --> 00:39:43.160
结合以前的网站

00:39:41.210 --> 00:39:44.960
应用程序配置，因此可以简化

00:39:43.160 --> 00:39:46.730
配置它使您键入的内容更少， 

00:39:44.960 --> 00:39:48.770
这些在启用不同的禁用

00:39:46.730 --> 00:39:50.930
批注与它们具有相同的名称

00:39:48.770 --> 00:39:52.430
不幸的是来自木星的那个

00:39:50.930 --> 00:39:54.530
但是这两个来自春季包

00:39:52.430 --> 00:39:55.460
使用咒语表达，因此您可以

00:39:54.530 --> 00:39:57.470
与您的咖啡豆互动

00:39:55.460 --> 00:39:58.869
应用程序上下文并执行类似的操作

00:39:57.470 --> 00:40:02.540
那

00:39:58.869 --> 00:40:03.829
所以大约一个星期以来是全新的

00:40:02.540 --> 00:40:05.030
人们一直在要求你

00:40:03.829 --> 00:40:06.890
可能知道那是春天

00:40:05.030 --> 00:40:08.630
历史上不得不写在自动有线

00:40:06.890 --> 00:40:10.880
在构造函数上选择它，但是

00:40:08.630 --> 00:40:12.890
从4.3版本开始，您不再需要

00:40:10.880 --> 00:40:14.119
如果在构造函数的自动连线上写

00:40:12.890 --> 00:40:15.950
只有一个春天，我们来挑选

00:40:14.119 --> 00:40:17.839
并执行依赖注入

00:40:15.950 --> 00:40:19.099
你基本上就是这样

00:40:17.839 --> 00:40:21.250
这是允许您具有相同的功能

00:40:19.099 --> 00:40:23.950
在Jana Jupiter去了

00:40:21.250 --> 00:40:25.720
带弹簧，因此默认情况下如前所述

00:40:23.950 --> 00:40:27.670
您必须对其进行注释，但这

00:40:25.720 --> 00:40:29.680
默认可以更改，这是一个地球仪

00:40:27.670 --> 00:40:31.240
小毛病，现在你可以做到这一点

00:40:29.680 --> 00:40:34.180
设置弹簧测试构造函数自动

00:40:31.240 --> 00:40:37.180
是true的标志，默认情况下

00:40:34.180 --> 00:40:38.710
假，您可以通过JVM系统执行此操作

00:40:37.180 --> 00:40:40.330
财产或这带来财产

00:40:38.710 --> 00:40:41.500
弹簧点的机制

00:40:40.330 --> 00:40:45.070
类根目录中的属性文件

00:40:41.500 --> 00:40:48.010
浴室，也可以在

00:40:45.070 --> 00:40:49.990
特殊等级的垫子测试

00:40:48.010 --> 00:40:51.970
构造函数自动连线为true或Auto 

00:40:49.990 --> 00:40:55.990
无线假改变任何

00:40:51.970 --> 00:40:58.240
默认为此特定类，因此

00:40:55.990 --> 00:40:59.950
从spring boot 2.1开始的spring boot 

00:40:58.240 --> 00:41:01.630
有很好的支持

00:40:59.950 --> 00:41:03.220
对于简和超级，我在这里

00:41:01.630 --> 00:41:05.950
例如一些自定义配置，所以我想要

00:41:03.220 --> 00:41:07.990
用add编写spring be test 

00:41:05.950 --> 00:41:08.980
春天被测试恰当地命名为我想

00:41:07.990 --> 00:41:10.840
有自动

00:41:08.980 --> 00:41:13.060
妈的社区支持，我想用

00:41:10.840 --> 00:41:15.760
简和木星，所以我用这三个

00:41:13.060 --> 00:41:17.530
这里的注释我是说我想要

00:41:15.760 --> 00:41:19.240
可以在我的课上声明

00:41:17.530 --> 00:41:20.680
并且不要忘记在运行时保存它

00:41:19.240 --> 00:41:22.840
否则它不在字节码中， 

00:41:20.680 --> 00:41:24.130
框架看不到

00:41:22.840 --> 00:41:26.140
从历史上讲，您不得不说

00:41:24.130 --> 00:41:28.090
用弹簧延伸来延伸，但是由于

00:41:26.140 --> 00:41:30.370
 spring boo到那个 spring boot 测试

00:41:28.090 --> 00:41:33.100
和其他切片注释

00:41:30.370 --> 00:41:34.660
可能知道某些测试，例如

00:41:33.100 --> 00:41:36.520
 JSON测试类似的东西

00:41:34.660 --> 00:41:38.020
在此扩展的meta带有

00:41:36.520 --> 00:41:39.820
春天的延伸，所以你可以删除

00:41:38.020 --> 00:41:41.500
从春天开始就成为

00:41:39.820 --> 00:41:43.360
即将到来的 spring boot 2.2的过程

00:41:41.500 --> 00:41:45.520
所以这里我有屏幕测试自动

00:41:43.360 --> 00:41:47.530
配置，我说过交易

00:41:45.520 --> 00:41:49.180
有一个名为spring的示例应用程序

00:41:47.530 --> 00:41:52.860
事件，这只是为了测试

00:41:49.180 --> 00:41:54.970
网络层，例如

00:41:52.860 --> 00:41:56.830
想用这种方法来证明

00:41:54.970 --> 00:41:57.970
从Spring注入级别依赖

00:41:56.830 --> 00:41:59.350
它是模拟的，我们看到了

00:41:57.970 --> 00:42:01.600
从 spring boot 为我们自动配置

00:41:59.350 --> 00:42:03.520
所以我只能在春季活动网站上说

00:42:01.600 --> 00:42:05.940
在我的各种控制器测试上进行测试

00:42:03.520 --> 00:42:08.020
专为我的项目而设计

00:42:05.940 --> 00:42:09.820
 （可选）使用自定义显示名称和

00:42:08.020 --> 00:42:10.270
这里列出事件，我是说我会自动

00:42:09.820 --> 00:42:12.910
有线

00:42:10.270 --> 00:42:15.220
嘲笑我，让我被注入

00:42:12.910 --> 00:42:17.140
可以在本地使用它，这个概念

00:42:15.220 --> 00:42:18.940
这里使用在特定的

00:42:17.140 --> 00:42:20.080
方法，这可能是一个好习惯，但是

00:42:18.940 --> 00:42:21.310
如果这也是最糟糕的做法

00:42:20.080 --> 00:42:23.500
你要在整个地方做

00:42:21.310 --> 00:42:24.880
如果您不对构造函数执行此操作

00:42:23.500 --> 00:42:26.680
在每种方法之前都想要或要做

00:42:24.880 --> 00:42:29.290
所以你只需要设置一次就可以了

00:42:26.680 --> 00:42:31.270
基本上可以体会到这一点，但是

00:42:29.290 --> 00:42:33.029
在测试中可以选择

00:42:31.270 --> 00:42:35.499
水平也

00:42:33.029 --> 00:42:38.109
所以我是人的一件事

00:42:35.499 --> 00:42:39.999
最近几个月相当频繁

00:42:38.109 --> 00:42:41.410
使用各种版本的人

00:42:39.999 --> 00:42:43.059
想要升级到的 spring boot 

00:42:41.410 --> 00:42:45.609
简的最新最好的版本

00:42:43.059 --> 00:42:46.779
五分之一的版本比

00:42:45.609 --> 00:42:48.309
和他一起运动的那个人

00:42:46.779 --> 00:42:49.509
他们不知道该怎么办

00:42:48.309 --> 00:42:52.450
所以这是一个非常受欢迎的问题

00:42:49.509 --> 00:42:53.709
例如在各种论坛中

00:42:52.450 --> 00:42:56.529
我回答的堆栈溢出问题

00:42:53.709 --> 00:42:58.029
答案很简单，请阅读

00:42:56.529 --> 00:43:00.459
它告诉了Spring Boot文档

00:42:58.029 --> 00:43:01.930
您如何升级依赖关系，但要

00:43:00.459 --> 00:43:03.489
为你拼出来，你必须找到

00:43:01.930 --> 00:43:05.140
指出版本的名称是什么

00:43:03.489 --> 00:43:07.420
 spring boot 认为是一个名字， 

00:43:05.140 --> 00:43:09.339
五分之一的简是木星上的简

00:43:07.420 --> 00:43:11.380
您将设置为Gradle的版本

00:43:09.339 --> 00:43:13.089
这和行家，你会喜欢

00:43:11.380 --> 00:43:14.440
这样，在您的主掌上，您就可以

00:43:13.089 --> 00:43:16.469
确保使用最新的

00:43:14.440 --> 00:43:16.469
最伟大的

00:43:17.190 --> 00:43:21.969
现在即将到来或最近

00:43:20.170 --> 00:43:23.529
至少两天前的 spring boot 

00:43:21.969 --> 00:43:24.640
两英里，所以三个已经

00:43:23.529 --> 00:43:26.709
版本集，因为那是

00:43:24.640 --> 00:43:28.900
简和木星的最新版本，但

00:43:26.709 --> 00:43:32.019
木星5.5可能就是简

00:43:28.900 --> 00:43:33.459
在最高引导决赛之后出现

00:43:32.019 --> 00:43:35.229
 GA发布，因此您可能仍然希望

00:43:33.459 --> 00:43:40.690
知道如何然后升级或在任何点

00:43:35.229 --> 00:43:44.680
以未来为例，我们将看看

00:43:40.690 --> 00:43:51.150
这个作品我去了约书亚

00:43:44.680 --> 00:43:55.119
黄说开始春天的闪闪发亮， 

00:43:51.150 --> 00:43:57.130
选择了tu-22m3，然后um与

00:43:55.119 --> 00:43:58.269
伟大的像默认值和什么

00:43:57.130 --> 00:44:03.009
发生的是我下载并解压缩了

00:43:58.269 --> 00:44:07.059
它将其导入到我的IDE中，这就是

00:44:03.009 --> 00:44:09.279
这个抱歉的演示，如果我们看看

00:44:07.059 --> 00:44:12.249
我们在那里看到的版本

00:44:09.279 --> 00:44:13.809
屏幕启动2.0，如M3，如果

00:44:12.249 --> 00:44:15.549
我们来看简两个版本

00:44:13.809 --> 00:44:17.229
那里有简25.4纹身， 

00:44:15.549 --> 00:44:19.900
春天的东西，它有女士们和

00:44:17.229 --> 00:44:22.449
最佳弹簧测试5-om-所有

00:44:19.900 --> 00:44:25.869
我在那儿谈论的新功能

00:44:22.449 --> 00:44:27.759
你能用那些吗，它能做什么

00:44:25.869 --> 00:44:29.650
它创建了一个基本的应用程序

00:44:27.759 --> 00:44:31.509
曾经用来启动屏幕吗

00:44:29.650 --> 00:44:33.369
知道它是在四点钟与简一起创造的

00:44:31.509 --> 00:44:34.569
默认使用SpringRunner spring boot 

00:44:33.369 --> 00:44:36.779
测试，这是什么小技巧

00:44:34.569 --> 00:44:39.219
告诉你我说过啊哈 spring boot 

00:44:36.779 --> 00:44:41.109
已经用扩展注释

00:44:39.219 --> 00:44:43.299
春天扩展，因此您可以使用简

00:44:41.109 --> 00:44:44.949
和木星的议程在任何你

00:44:43.299 --> 00:44:45.650
选择，这里的注释是

00:44:44.949 --> 00:44:47.599
奥丁抵押

00:44:45.650 --> 00:44:49.849
测试是珍妮特四，然后这个

00:44:47.599 --> 00:44:52.369
当然会运行不应该

00:44:49.849 --> 00:44:57.589
惊喜跑得很快，但是如果我们

00:44:52.369 --> 00:45:00.619
想摆脱贾纳的东西

00:44:57.589 --> 00:45:02.420
然后，对于初学者，我们必须

00:45:00.619 --> 00:45:05.420
确保我们得到正确的注释

00:45:02.420 --> 00:45:06.619
来自珍妮特·朱庇特（Janet Jupiter），这件事是

00:45:05.420 --> 00:45:10.789
已经注册了延伸力

00:45:06.619 --> 00:45:12.559
所以它应该应该现在就运行

00:45:10.789 --> 00:45:14.359
与Jana 5一起运行正常

00:45:12.559 --> 00:45:17.480
只是为了向你证明

00:45:14.359 --> 00:45:21.079
如果愿意，可以让公众脱颖而出

00:45:17.480 --> 00:45:24.349
到然后它仍然会运行，就像

00:45:21.079 --> 00:45:25.910
一些人喜欢的例子

00:45:24.349 --> 00:45:27.740
事物是私有的，如果不可变

00:45:25.910 --> 00:45:30.619
你想我没有豆

00:45:27.740 --> 00:45:34.869
我的应用程序环境a 

00:45:30.619 --> 00:45:37.119
春季环境中的拼写者

00:45:34.869 --> 00:45:40.660
为什么偷看使资本成为资本

00:45:37.119 --> 00:45:42.650
没人知道，所以我现在有这个私人的

00:45:40.660 --> 00:45:46.640
我想成为的最终可变字段

00:45:42.650 --> 00:45:49.069
是的，我可以做一个

00:45:46.640 --> 00:45:52.900
您开始支持的构造函数

00:45:49.069 --> 00:45:55.910
您的四个领域都应该全部起作用

00:45:52.900 --> 00:46:03.559
对，如果我跑步，那会发生什么

00:45:55.910 --> 00:46:04.940
现在测试中没有任何猜测

00:46:03.559 --> 00:46:07.039
奥利弗我找不到它，所以我做了什么

00:46:04.940 --> 00:46:10.819
在默认值之前说

00:46:07.039 --> 00:46:13.460
从春天开始的电线上的ID 

00:46:10.819 --> 00:46:14.960
应该正确地工作，这是一个选择

00:46:13.460 --> 00:46:16.549
然后我很好地说，如果你不这样做

00:46:14.960 --> 00:46:22.720
想这样做，如果你想

00:46:16.549 --> 00:46:22.720
覆盖本地测试构造函数

00:46:26.330 --> 00:46:31.020
那也应该工作，我们进行测试

00:46:28.530 --> 00:46:32.730
再次有效，但是如果您想

00:46:31.020 --> 00:46:34.290
为了我们的心理在全球范围内改变它

00:46:32.730 --> 00:46:36.000
这种超类或接口

00:46:34.290 --> 00:46:37.950
就像那样，如果我们想这样做

00:46:36.000 --> 00:46:39.180
在全球范围内

00:46:37.950 --> 00:46:41.250
再次围绕着足够的项目

00:46:39.180 --> 00:46:43.410
失败的一种选择就是采取

00:46:41.250 --> 00:46:47.190
我希望我已经有权利

00:46:43.410 --> 00:46:49.380
在这里设置配置，如果我们

00:46:47.190 --> 00:46:51.090
如果说春季测试，不要称它为X 

00:46:49.380 --> 00:46:52.380
构造函数硬件等于true我是

00:46:51.090 --> 00:46:53.550
为此设置今年的虚拟机

00:46:52.380 --> 00:46:55.140
当前测试，但您可以将其设置为

00:46:53.550 --> 00:46:57.240
您的整个构建，无论您的其中一个

00:46:55.140 --> 00:47:00.000
属性文件（如果现在运行） 

00:46:57.240 --> 00:47:01.859
还将看到它运行，所以这是

00:47:00.000 --> 00:47:04.410
这种想法，你可以有

00:47:01.859 --> 00:47:07.140
您的私人最终和可变字段

00:47:04.410 --> 00:47:08.310
测试并使用基本的依赖注入

00:47:07.140 --> 00:47:09.480
就像你和你的正常人一样

00:47:08.310 --> 00:47:13.530
像这样的弹簧组件

00:47:09.480 --> 00:47:15.300
在控制器等服务，所以我很高兴

00:47:13.530 --> 00:47:17.790
该演示有效，您从未了解过

00:47:15.300 --> 00:47:20.849
这些事情好吗

00:47:17.790 --> 00:47:23.340
参与进来，如果你想帮忙

00:47:20.849 --> 00:47:26.130
您可以在github上参与

00:47:23.340 --> 00:47:27.990
链5报告问题提示新问题

00:47:26.130 --> 00:47:29.700
参与讨论的功能

00:47:27.990 --> 00:47:31.380
当然您也可以回答有关的问题

00:47:29.700 --> 00:47:33.440
堆栈溢出或混乱

00:47:31.380 --> 00:47:35.580
您也可以参加的频道

00:47:33.440 --> 00:47:38.310
如果您愿意，可以支持

00:47:35.580 --> 00:47:39.750
吉安娜团队通过研究总部捐款

00:47:38.310 --> 00:47:42.000
有助于进一步发展

00:47:39.750 --> 00:47:43.070
在他们为自己做贡献之前

00:47:42.000 --> 00:47:46.440
空余时间

00:47:43.070 --> 00:47:48.359
所以在结束时我有一些资源

00:47:46.440 --> 00:47:50.730
这里基本上是为了访问基因

00:47:48.359 --> 00:47:51.839
开始Jenny org获得一个JUnit 5 

00:47:50.730 --> 00:47:53.460
一堆链接，您可以看到

00:47:51.839 --> 00:47:55.560
有指向参考指南的链接

00:47:53.460 --> 00:47:57.109
 Java文档并获得帮助，就像这样

00:47:55.560 --> 00:47:59.070
我也得到她，堆栈溢出

00:47:57.109 --> 00:48:01.800
他们与那些链接，然后是用户

00:47:59.070 --> 00:48:04.530
指南以及戴蒙的使用演示

00:48:01.800 --> 00:48:06.930
或我在github jane上的帐户的brandon 

00:48:04.530 --> 00:48:09.720
到五个演示，我还使用了一些示例

00:48:06.930 --> 00:48:11.730
直接来自Jane中的用户指南

00:48:09.720 --> 00:48:13.020
五分之一，我们要做的是

00:48:11.730 --> 00:48:14.820
该示例实际上在用户指南中

00:48:13.020 --> 00:48:16.619
在构建中执行，因此您

00:48:14.820 --> 00:48:17.940
保证他们工作

00:48:16.619 --> 00:48:19.859
那里的例子，你可以复制它们

00:48:17.940 --> 00:48:23.700
从文档项目中，如果您

00:48:19.859 --> 00:48:25.410
想要，所以你有几分钟的时间

00:48:23.700 --> 00:48:27.780
是我可以回答的问题

00:48:25.410 --> 00:48:32.150
我有更多的演示可以通过

00:48:27.780 --> 00:48:32.150
如果先问两个问题，我将打开两个

00:48:34.220 --> 00:48:41.339
没有问题

00:48:35.960 --> 00:48:43.079
是的，你知道你说的方式

00:48:41.339 --> 00:48:45.990
不必在测试中宣布公开

00:48:43.079 --> 00:48:48.720
是的，那也能给你带来什么

00:48:45.990 --> 00:48:50.339
优势意味着您可以少打字

00:48:48.720 --> 00:48:52.859
就是这样，是的，另一件事

00:48:50.339 --> 00:48:54.839
是有些人不喜欢看到

00:48:52.859 --> 00:48:57.060
当他们搜索时，测试就是公共类型

00:48:54.839 --> 00:48:58.079
用于类型和不同包装的东西

00:48:57.060 --> 00:49:00.420
这样可能是一个优势

00:48:58.079 --> 00:49:02.490
但是主要是因为少即是多

00:49:00.420 --> 00:49:04.050
如果您正在，请不要再键入它

00:49:02.490 --> 00:49:05.550
使用您的IDE，并且在之前进行辅导

00:49:04.050 --> 00:49:07.650
我们公开一些我不会的

00:49:05.550 --> 00:49:08.730
如果我输入一个，我个人会担心

00:49:07.650 --> 00:49:17.599
新的，我只是不输入单词

00:49:08.730 --> 00:49:17.599
公开，但仅此而已

00:49:18.200 --> 00:49:29.160
是的版本4至5如何影响他们的

00:49:27.030 --> 00:49:33.150
性能说我们的应用

00:49:29.160 --> 00:49:36.569
在我们的测试中需要15分钟，就像我们

00:49:33.150 --> 00:49:41.630
大约15分钟到一半之间

00:49:36.569 --> 00:49:44.369
小时，所以如果您迁移到5版本

00:49:41.630 --> 00:49:46.500
你在想什么

00:49:44.369 --> 00:49:47.760
像我们认为的那样影响性能

00:49:46.500 --> 00:49:49.109
如果您考虑过性能

00:49:47.760 --> 00:49:51.480
你就是我在想这个

00:49:49.109 --> 00:49:52.980
并行执行，因此其类型很好

00:49:51.480 --> 00:49:54.510
如果您的代码有效，它将使速度更快

00:49:52.980 --> 00:49:57.180
非常适合并行运行

00:49:54.510 --> 00:49:59.069
当然可以，但是总的来说有一些

00:49:57.180 --> 00:50:01.440
我们有一些错误的方式

00:49:59.069 --> 00:50:03.210
我们必须优化的东西

00:50:01.440 --> 00:50:05.490
你知道目前不应该

00:50:03.210 --> 00:50:07.619
真的有任何性能差异吗

00:50:05.490 --> 00:50:09.210
应该加入以上大致相同

00:50:07.619 --> 00:50:11.310
但有了平行的东西，你可以做

00:50:09.210 --> 00:50:12.240
它更快，这很好，所以过去

00:50:11.310 --> 00:50:14.010
您可以通过构建完成

00:50:12.240 --> 00:50:14.960
甚至可能喜欢在我工作的地方

00:50:14.010 --> 00:50:18.060
桶或摇篮

00:50:14.960 --> 00:50:19.380
但是Gradle的做法与众不同

00:50:18.060 --> 00:50:25.220
这是在像

00:50:19.380 --> 00:50:25.220
类或任何人的方法

00:50:29.500 --> 00:50:33.589
比赛结束就是标志说的

00:50:32.119 --> 00:50:36.080
感谢您的光临

00:50:33.589 --> 00:50:37.240
你可以在外面捉住我的问题

00:50:36.080 --> 00:50:44.980
 [掌声] 

00:50:37.240 --> 00:50:44.980
 [音乐] 

