WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.900 --> 00:00:05.499
 [音乐] 

00:00:05.569 --> 00:00:12.930
晚上好，大家见到一些人

00:00:10.440 --> 00:00:14.280
还在坐着，所以请坐

00:00:12.930 --> 00:00:16.860
时间

00:00:14.280 --> 00:00:20.010
晚上好，今天最后一堂

00:00:16.860 --> 00:00:25.020
希望大家今天过得愉快

00:00:20.010 --> 00:00:26.279
你学到了很多很棒的东西

00:00:25.020 --> 00:00:28.220
我想和你谈谈

00:00:26.279 --> 00:00:32.009
和我的同事在这里

00:00:28.220 --> 00:00:35.339
服务，所以现在大约两年了

00:00:32.009 --> 00:00:38.909
以前我认为我是第一次被介绍的

00:00:35.339 --> 00:00:41.069
隐性基础设施一词

00:00:38.909 --> 00:00:42.809
在我们参加的会议上

00:00:41.069 --> 00:00:45.510
谈论什么是新事物

00:00:42.809 --> 00:00:48.690
关于新的热门话题是关于

00:00:45.510 --> 00:00:51.719
来年，我真的很好奇

00:00:48.690 --> 00:00:53.309
关于当时的学期

00:00:51.719 --> 00:00:55.979
知道一些有关功能的知识

00:00:53.309 --> 00:00:59.459
服务我尝试了一些世界

00:00:55.979 --> 00:01:02.010
经验，但是这个想法

00:00:59.459 --> 00:01:03.749
帮助或得到一些帮助

00:01:02.010 --> 00:01:05.880
在我们可以的地方创建我们的应用程序

00:01:03.749 --> 00:01:08.850
真正专注于业务逻辑和

00:01:05.880 --> 00:01:11.910
我们需要的是附加值

00:01:08.850 --> 00:01:15.450
因为我们公司真的吸引了我， 

00:01:11.910 --> 00:01:18.450
所以在这种情况下，我们作为一个

00:01:15.450 --> 00:01:21.750
公司还做了更多调查

00:01:18.450 --> 00:01:24.330
在我们比利时公司的这个主题中，我们

00:01:21.750 --> 00:01:28.380
主要集中在Spring 技术上

00:01:24.330 --> 00:01:31.290
我们真的有很多人是专家

00:01:28.380 --> 00:01:34.020
在这个领域，所以真的很好

00:01:31.290 --> 00:01:36.630
看看 Spring 能做什么

00:01:34.020 --> 00:01:38.850
同样在本主题中，关于无服务器

00:01:36.630 --> 00:01:41.510
好，所以这也是

00:01:38.850 --> 00:01:47.070
我们试图找出这一点

00:01:41.510 --> 00:01:48.870
现在就像我之前所说的那样

00:01:47.070 --> 00:01:50.520
一个有趣的话题，因为它可以帮助我们

00:01:48.870 --> 00:01:53.220
它可以帮助我们作为开发人员来创建

00:01:50.520 --> 00:01:56.190
新应用也很多公司

00:01:53.220 --> 00:01:59.010
已经或多或少对

00:01:56.190 --> 00:02:01.290
这个，目前大约是10％ 

00:01:59.010 --> 00:02:04.010
公司已经有事要做

00:02:01.290 --> 00:02:06.990
具有功能或服务架构

00:02:04.010 --> 00:02:09.780
关于一些数字

00:02:06.990 --> 00:02:11.180
 Gartner明年在未来的几年中，我们

00:02:09.780 --> 00:02:14.040
只会看到越来越多的公司

00:02:11.180 --> 00:02:16.500
对这个话题感兴趣

00:02:14.040 --> 00:02:20.040
所以这里一定有事

00:02:16.500 --> 00:02:21.630
现在的事情是我们不认为

00:02:20.040 --> 00:02:24.090
服务将是您所需要的

00:02:21.630 --> 00:02:26.220
用于每个应用程序，但它将

00:02:24.090 --> 00:02:29.130
就像工具上的工具一样

00:02:26.220 --> 00:02:32.400
在某些情况下可以使用的皮带

00:02:29.130 --> 00:02:35.010
所以实际上这就是这个话题

00:02:32.400 --> 00:02:38.370
关于我们的全部要调查

00:02:35.010 --> 00:02:41.250
一点什么是合适的地方

00:02:38.370 --> 00:02:42.930
使用这种工具，所以我们

00:02:41.250 --> 00:02:45.300
真的很想现在弄脏我们的手

00:02:42.930 --> 00:02:48.030
并不需要真的意味着你

00:02:45.300 --> 00:02:50.610
现在应该回家并立即开始

00:02:48.030 --> 00:02:52.740
将您的应用程序迁移到服务

00:02:50.610 --> 00:02:55.950
环境，因为那可能不是

00:02:52.740 --> 00:02:58.350
最适合这里的每种情况

00:02:55.950 --> 00:03:01.260
如果没有，不要在家尝试

00:02:58.350 --> 00:03:03.630
真的考虑过这个和经验

00:03:01.260 --> 00:03:05.550
分享当然可以

00:03:03.630 --> 00:03:07.290
这样可以帮助您做出决定，所以我

00:03:05.550 --> 00:03:09.870
希望大家从中得到一些东西

00:03:07.290 --> 00:03:12.150
今天以后再说，也许已经

00:03:09.870 --> 00:03:14.730
介绍了它也许在某些特定的

00:03:12.150 --> 00:03:16.920
项目或也许您已经在做

00:03:14.730 --> 00:03:19.170
目前正在监视，所以刚出来

00:03:16.920 --> 00:03:20.970
好奇心的人已经在做

00:03:19.170 --> 00:03:25.900
生产中的服务应用程序

00:03:20.970 --> 00:03:29.829
这一刻好吧，有人

00:03:25.900 --> 00:03:32.470
现在我们开始之前

00:03:29.829 --> 00:03:33.989
有一个良好的基准开始很好

00:03:32.470 --> 00:03:36.069
从什么是服务架构

00:03:33.989 --> 00:03:37.900
因为有很多条款

00:03:36.069 --> 00:03:40.120
术语和和不同

00:03:37.900 --> 00:03:42.700
我们的定义很好

00:03:40.120 --> 00:03:46.000
意见服务架构真的

00:03:42.700 --> 00:03:48.849
关于两件事，即第一件事

00:03:46.000 --> 00:03:51.579
一种是作为服务的功能

00:03:48.849 --> 00:03:54.189
将只创建一些代码， 

00:03:51.579 --> 00:03:55.870
只是让它在没有

00:03:54.189 --> 00:03:57.670
不必担心

00:03:55.870 --> 00:03:59.920
有关的基础架构

00:03:57.670 --> 00:04:03.730
服务器和必须设置的东西

00:03:59.920 --> 00:04:05.079
使您的代码第二次运行

00:04:03.730 --> 00:04:07.510
东西，那不是

00:04:05.079 --> 00:04:09.430
我认为总是很清楚的是

00:04:07.510 --> 00:04:11.349
这也意味着您要尝试

00:04:09.430 --> 00:04:14.470
充分利用平台

00:04:11.349 --> 00:04:16.930
可能，但是因为如果你

00:04:14.470 --> 00:04:19.829
仍然必须建立很多

00:04:16.930 --> 00:04:22.419
额外的东西做安全和其他

00:04:19.829 --> 00:04:24.039
您可能需要的支持服务

00:04:22.419 --> 00:04:25.900
在您的应用程序中，然后您再次

00:04:24.039 --> 00:04:27.400
真正摆脱焦点

00:04:25.900 --> 00:04:29.620
再次是您的业务逻辑

00:04:27.400 --> 00:04:31.180
应用程序，因此被视为服务

00:04:29.620 --> 00:04:34.000
是我中非常重要的一部分

00:04:31.180 --> 00:04:36.400
意见也要充分

00:04:34.000 --> 00:04:38.349
现在的服务架构

00:04:36.400 --> 00:04:40.780
伴随着很多成本，因为它

00:04:38.349 --> 00:04:42.190
意味着，这可能意味着你会打成平手

00:04:40.780 --> 00:04:45.610
您的应用程序多一点

00:04:42.190 --> 00:04:47.050
对某个平台，所以你有

00:04:45.610 --> 00:04:49.330
当然可以决定是否

00:04:47.050 --> 00:04:51.699
你想要的东西，如果可以的话

00:04:49.330 --> 00:04:57.340
可能对您的决定有影响

00:04:51.699 --> 00:04:59.020
或您现在的业务，我们说我们可以

00:04:57.340 --> 00:05:02.470
继续并继续执行这些

00:04:59.020 --> 00:05:04.389
 HelloWorld示例，但确实如此

00:05:02.470 --> 00:05:06.580
并没有给您真正的价值

00:05:04.389 --> 00:05:08.860
当然创建一个可以

00:05:06.580 --> 00:05:10.720
运行可能基于

00:05:08.860 --> 00:05:12.610
我们想要的现有应用程序

00:05:10.720 --> 00:05:15.520
具有所有功能

00:05:12.610 --> 00:05:17.199
转化为服务，所以真的

00:05:15.520 --> 00:05:19.210
弄脏了我们的手，我们说为什么不

00:05:17.199 --> 00:05:21.039
尝试迁移现有的应用程序

00:05:19.210 --> 00:05:22.930
我们有，看看什么样的

00:05:21.039 --> 00:05:24.940
我们遇到的问题如何克服

00:05:22.930 --> 00:05:26.889
他们，也许其中一些不是

00:05:24.940 --> 00:05:30.220
非常合适，这就是全部

00:05:26.889 --> 00:05:32.050
关于我们拥有的这个ID 

00:05:30.220 --> 00:05:33.340
具有某些Web的典型Web应用程序

00:05:32.050 --> 00:05:35.860
那里的插座

00:05:33.340 --> 00:05:37.510
数据库一些安全设置等等

00:05:35.860 --> 00:05:39.580
所以我们待会儿讨论

00:05:37.510 --> 00:05:42.280
有关体系结构的更多信息

00:05:39.580 --> 00:05:44.319
当然我们也要注意

00:05:42.280 --> 00:05:46.030
那里是什么，那是什么样的

00:05:44.319 --> 00:05:47.680
我们有什么样的平台

00:05:46.030 --> 00:05:49.330
工具出什么样的框架

00:05:47.680 --> 00:05:50.319
在那里，所以我们希望您也可以

00:05:49.330 --> 00:05:52.900
从中利用一点点

00:05:50.319 --> 00:05:56.050
今天的经验，所以我们要

00:05:52.900 --> 00:05:58.150
说说其中的一些当然

00:05:56.050 --> 00:05:59.949
可扩展性是我们将要提出的想法之一

00:05:58.150 --> 00:06:02.620
在

00:05:59.949 --> 00:06:04.689
分钟，我们可以简要讨论

00:06:02.620 --> 00:06:06.310
那当然也是因为

00:06:04.689 --> 00:06:08.469
我们是一家专门从事

00:06:06.310 --> 00:06:10.030
我们要关注的Spring 技术

00:06:08.469 --> 00:06:13.919
有什么支持， Spring 可以帮助您

00:06:10.030 --> 00:06:17.469
我们一起创建这样的应用程序

00:06:13.919 --> 00:06:20.830
好吧，我们当然有风险

00:06:17.469 --> 00:06:22.719
要进行迁移，这样您就可以

00:06:20.830 --> 00:06:24.759
也许以为我要一对一地做

00:06:22.719 --> 00:06:26.469
迁移并承担一切

00:06:24.759 --> 00:06:28.060
我有并确保它运行

00:06:26.469 --> 00:06:29.650
某个功能可能只是

00:06:28.060 --> 00:06:31.599
一个功能，我就把所有东西

00:06:29.650 --> 00:06:35.080
在那当然不是很好

00:06:31.599 --> 00:06:36.699
这个想法，所以我们真的很想

00:06:35.080 --> 00:06:38.770
确保我们充分利用一切

00:06:36.699 --> 00:06:41.289
在那里，所以我们尝试释放我们的

00:06:38.770 --> 00:06:43.210
稍微思考一下，看看我们可以

00:06:41.289 --> 00:06:45.279
做一些调查那里有什么

00:06:43.210 --> 00:06:48.039
什么可以帮助我们如何翻译一个

00:06:45.279 --> 00:06:50.919
从另一个东西等等，所以请

00:06:48.039 --> 00:06:53.440
如果我们继续下去，请和我们一起忍受

00:06:50.919 --> 00:06:56.469
一些实验性的话题可能会出现

00:06:53.440 --> 00:06:59.159
在这里玩，好吧，你必须

00:06:56.469 --> 00:07:01.569
打开它，当然要确保

00:06:59.159 --> 00:07:04.509
看看您将如何实现它

00:07:01.569 --> 00:07:07.330
您的公司现在我们要谈什么

00:07:04.509 --> 00:07:09.580
今天大约是一个应用程序

00:07:07.330 --> 00:07:11.469
插槽预订系统

00:07:09.580 --> 00:07:14.169
关于你可能已经读过的猪

00:07:11.469 --> 00:07:15.580
同样在这个谈话的描述中

00:07:14.169 --> 00:07:18.580
实际上，我们有某种想法

00:07:15.580 --> 00:07:22.089
可以预订的网站

00:07:18.580 --> 00:07:24.490
在这里查看供应商可以感染的地方

00:07:22.089 --> 00:07:29.110
预留一些插槽将猪运送到

00:07:24.490 --> 00:07:31.330
食品供应公司和这个想法

00:07:29.110 --> 00:07:34.330
预订很特别，因为

00:07:31.330 --> 00:07:36.039
它每天从10点的10点开始

00:07:34.330 --> 00:07:38.169
凌晨有人登录系统， 

00:07:36.039 --> 00:07:41.379
能够开始为

00:07:38.169 --> 00:07:43.180
在那之后的第二天

00:07:41.379 --> 00:07:45.490
我们因为人们想要而匆忙

00:07:43.180 --> 00:07:47.289
获得最佳插槽最佳插槽的含义

00:07:45.490 --> 00:07:50.500
在他们的业务中显然是

00:07:47.289 --> 00:07:52.959
白天尽快等等

00:07:50.500 --> 00:07:53.490
您会立即看到该应用程序

00:07:52.959 --> 00:07:55.979
开始

00:07:53.490 --> 00:07:58.110
在10:00保留第一批货物

00:07:55.979 --> 00:08:01.979
立即，其他人可能会得到

00:07:58.110 --> 00:08:04.080
当然没那么有趣了

00:08:01.979 --> 00:08:06.180
如果您别无选择，那么

00:08:04.080 --> 00:08:08.699
你必须要拿，但这就是ID 

00:08:06.180 --> 00:08:11.160
然后大概是10 

00:08:08.699 --> 00:08:12.870
分钟的预订，然后

00:08:11.160 --> 00:08:15.060
之后，应用程序更多或

00:08:12.870 --> 00:08:17.009
少了一天不习惯

00:08:15.060 --> 00:08:20.400
这实际上是一个非常有趣的用途

00:08:17.009 --> 00:08:21.780
在其他情况下通常

00:08:20.400 --> 00:08:24.720
应用程序将始终

00:08:21.780 --> 00:08:26.400
这段时间可以启动并运行

00:08:24.720 --> 00:08:28.139
只是在不使用应用程序时

00:08:26.400 --> 00:08:30.090
再也可以缩小规模

00:08:28.139 --> 00:08:32.459
只是说可能只是缩小规模

00:08:30.090 --> 00:08:34.409
我们拥有的无服务器功能

00:08:32.459 --> 00:08:35.880
只是当时不付款

00:08:34.409 --> 00:08:37.770
因为大多数时候不是

00:08:35.880 --> 00:08:40.229
一定有可能只是

00:08:37.770 --> 00:08:43.770
一个或多个仍在访问的人

00:08:40.229 --> 00:08:45.630
它，就是这样，这就是ID，我们

00:08:43.770 --> 00:08:49.470
考虑好了可能是

00:08:45.630 --> 00:08:51.270
如果现在就开始使用的好用例

00:08:49.470 --> 00:08:53.520
你看一下这个架构

00:08:51.270 --> 00:08:54.959
这是一种典型的架构

00:08:53.520 --> 00:08:57.180
您可能会在很多地方找到

00:08:54.959 --> 00:08:59.610
这些天的应用程序，所以我们有一个

00:08:57.180 --> 00:09:02.070
运行应用程序的服务器

00:08:59.610 --> 00:09:03.990
通常是分层的，我们有Valene 

00:09:02.070 --> 00:09:07.860
在前端，我们有一些服务

00:09:03.990 --> 00:09:10.320
这样的存储库等等

00:09:07.860 --> 00:09:12.959
数据存储在后续数据库中

00:09:10.320 --> 00:09:16.560
好，那就是那个应用

00:09:12.959 --> 00:09:20.130
现在我们在这里有了第一件事

00:09:16.560 --> 00:09:22.740
首先是我们想搬家

00:09:20.130 --> 00:09:25.170
淘汰应用程序的所有前端

00:09:22.740 --> 00:09:29.130
该应用程序，所以我们所做的就是移动

00:09:25.170 --> 00:09:32.070
从Vardhan到前端厚

00:09:29.130 --> 00:09:37.620
客户技术与我们

00:09:32.070 --> 00:09:39.360
开始托管在AWS s3上，以便能够

00:09:37.620 --> 00:09:41.220
单独实施一点

00:09:39.360 --> 00:09:44.220
后端和前端我们也使用JSON 

00:09:41.220 --> 00:09:46.860
前端的服务器，以便我们可以

00:09:44.220 --> 00:09:48.450
模拟出后端服务器，以便

00:09:46.860 --> 00:09:50.839
我们可以开始发展前沿的方式

00:09:48.450 --> 00:09:53.670
端独立于后端服务

00:09:50.839 --> 00:09:55.140
现在当然可以开始服务了

00:09:53.670 --> 00:09:57.450
我们不考虑的架构

00:09:55.140 --> 00:09:59.520
服务器了，但是我们不得不

00:09:57.450 --> 00:10:02.640
担心我们要如何解决

00:09:59.520 --> 00:10:03.839
我们拥有的这些层

00:10:02.640 --> 00:10:06.260
服务和存储库层

00:10:03.839 --> 00:10:08.630
那里有很多班

00:10:06.260 --> 00:10:11.870
我们必须考虑什么是

00:10:08.630 --> 00:10:14.839
我们想要的最少的代码

00:10:11.870 --> 00:10:16.250
放入一个功能，我们要去

00:10:14.839 --> 00:10:18.430
稍后再详细一点

00:10:16.250 --> 00:10:20.839
但这是一个有趣的想法，因为

00:10:18.430 --> 00:10:23.660
 servlets体系结构已经使您

00:10:20.839 --> 00:10:25.850
考虑一下小的单个零件

00:10:23.660 --> 00:10:27.139
可以使用

00:10:25.850 --> 00:10:31.040
事件驱动架构的说明

00:10:27.139 --> 00:10:33.550
我们都知道这种模式

00:10:31.040 --> 00:10:36.560
他们可以帮助我们创造可重复使用的

00:10:33.550 --> 00:10:37.699
反过来又很好的组件

00:10:36.560 --> 00:10:41.779
当然如果你想放松

00:10:37.699 --> 00:10:44.690
耦合和高内聚性

00:10:41.779 --> 00:10:46.699
是一件有趣的事情，但当然

00:10:44.690 --> 00:10:48.079
这些功能可能必须运行

00:10:46.699 --> 00:10:50.660
彼此之间有些功能可能

00:10:48.079 --> 00:10:53.060
调用其他函数，因此我们使用了AWS 

00:10:50.660 --> 00:10:56.449
步骤功能来组合它们，我们将

00:10:53.060 --> 00:10:58.760
稍后再回到下方

00:10:56.449 --> 00:11:01.790
您可以看到那里我们使用了Terraform 

00:10:58.760 --> 00:11:03.709
作为基础架构S代码，我们还

00:11:01.790 --> 00:11:06.380
稍后再谈

00:11:03.709 --> 00:11:09.589
这部分的细节，但它非常

00:11:06.380 --> 00:11:11.089
那样容易上手，我也会

00:11:09.589 --> 00:11:13.310
看到那个操作部分是真的

00:11:11.089 --> 00:11:16.040
如果您要开发这些至关重要

00:11:13.310 --> 00:11:18.709
类型的应用程序，然后当然

00:11:16.040 --> 00:11:20.540
有这个后端即服务

00:11:18.709 --> 00:11:24.380
我们还整合了许多其他

00:11:20.540 --> 00:11:27.740
在这种情况下，由AWS提供的服务

00:11:24.380 --> 00:11:32.600
诸如安全之类的东西

00:11:27.740 --> 00:11:35.329
数据库访问WebSockets等等

00:11:32.600 --> 00:11:39.440
再看一下我们的例子

00:11:35.329 --> 00:11:42.920
在迁移之前，我们有一个门面

00:11:39.440 --> 00:11:45.890
依次调用一个或多个

00:11:42.920 --> 00:11:49.790
服务方法，然后可能

00:11:45.890 --> 00:11:51.890
调用多个存储库，所以这是

00:11:49.790 --> 00:11:54.410
当然，立面就像

00:11:51.890 --> 00:11:56.000
编曲家，如果我们现在可以说

00:11:54.410 --> 00:11:57.949
翻译我们想到的

00:11:56.000 --> 00:12:00.319
我们如何将其转换为AWS 

00:11:57.949 --> 00:12:01.760
服务架构和第一件事

00:12:00.319 --> 00:12:04.490
我们想到的当然是我们

00:12:01.760 --> 00:12:06.860
有这个界面，所以我们要

00:12:04.490 --> 00:12:08.149
为此使用API​​网关

00:12:06.860 --> 00:12:10.459
接口本身翻译

00:12:08.149 --> 00:12:14.000
一对一，所以对API这么说

00:12:10.459 --> 00:12:17.510
网关现在执行

00:12:14.000 --> 00:12:19.119
立面方法本身实际上是

00:12:17.510 --> 00:12:22.299
编排和

00:12:19.119 --> 00:12:23.919
我们为此使用了AWS step函数

00:12:22.299 --> 00:12:25.509
这将管理所有这些步骤

00:12:23.919 --> 00:12:28.149
我们在这种方法中拥有的

00:12:25.509 --> 00:12:30.969
确保提供了一切

00:12:28.149 --> 00:12:33.669
从一项服务到另一项服务

00:12:30.969 --> 00:12:35.919
我们的案例从一个功能转移到另一个功能

00:12:33.669 --> 00:12:37.959
那就是我们在这里看到的

00:12:35.919 --> 00:12:40.359
当然我们有我们的数据层和

00:12:37.959 --> 00:12:42.519
数据层很好，你有多个

00:12:40.359 --> 00:12:45.039
选项，你可以说我们要去

00:12:42.519 --> 00:12:48.669
我们将为此使用lambda 

00:12:45.039 --> 00:12:51.309
但是我们实际上决定打包

00:12:48.669 --> 00:12:53.649
一个和多个jar中的数据层

00:12:51.309 --> 00:12:57.639
每个我们拥有的存储库一个

00:12:53.649 --> 00:12:59.229
将其作为图书馆提供给

00:12:57.639 --> 00:13:02.849
我们的脚步朝我们的方向发展

00:12:59.229 --> 00:13:05.169
使用AWS层功能的功能

00:13:02.849 --> 00:13:07.479
这样我们就可以拥有一个中央

00:13:05.169 --> 00:13:12.669
我们可以共享共同之处的位置

00:13:07.479 --> 00:13:14.619
现在与我们的校友一起图书馆

00:13:12.669 --> 00:13:17.439
必须考虑编程

00:13:14.619 --> 00:13:18.789
语言以及应用程序本身

00:13:17.439 --> 00:13:22.119
是用Spring用J​​ava编写的

00:13:18.789 --> 00:13:25.359
技术，所以我们最初的想法也是

00:13:22.119 --> 00:13:27.429
我们不要试图使事情复杂化

00:13:25.359 --> 00:13:29.289
更进一步，让我们也开始

00:13:27.429 --> 00:13:31.959
使用Java这样我们也可以重用

00:13:29.289 --> 00:13:34.479
一些代码非常容易

00:13:31.959 --> 00:13:37.839
当然也因为我们想要

00:13:34.479 --> 00:13:39.339
使用Spring 技术和Spring 

00:13:37.839 --> 00:13:44.409
云功能为此特别

00:13:39.339 --> 00:13:46.509
我们确实做了一点切换

00:13:44.409 --> 00:13:50.889
支持服务，因为那些

00:13:46.509 --> 00:13:52.239
我们没有GS编写的功能， 

00:13:50.889 --> 00:13:53.499
那当然是

00:13:52.239 --> 00:13:55.419
你有这些功能，你可以

00:13:53.499 --> 00:13:56.769
只是非常容易地选择

00:13:55.419 --> 00:13:59.619
符合您需求的语言

00:13:56.769 --> 00:14:01.509
取决于哪种功能

00:13:59.619 --> 00:14:04.389
你内在的知识

00:14:01.509 --> 00:14:06.549
您的公司等等，这就是

00:14:04.389 --> 00:14:08.529
我们在这里选择的方法也是

00:14:06.549 --> 00:14:10.659
事情通常是当你说话时

00:14:08.529 --> 00:14:14.469
关于Java和无服务器或功能

00:14:10.659 --> 00:14:16.149
服务，然后冷启动是

00:14:14.469 --> 00:14:19.869
通常是一个问题，因为这需要很多时间

00:14:16.149 --> 00:14:22.119
有时间启动它，但是一旦启动

00:14:19.869 --> 00:14:25.839
起来实际上是更快的速度

00:14:22.119 --> 00:14:27.909
有一个良好的开始，这就是为什么我们选择

00:14:25.839 --> 00:14:31.419
为此，我们也可以

00:14:27.909 --> 00:14:32.620
轻松实现应用程序预加载功能

00:14:31.419 --> 00:14:34.360
在10点

00:14:32.620 --> 00:14:36.310
早上确保他们很热

00:14:34.360 --> 00:14:38.350
开始，人们可以开始使用

00:14:36.310 --> 00:14:39.610
效果，然后如果需要

00:14:38.350 --> 00:14:42.340
这个或两个更长一点

00:14:39.610 --> 00:14:46.510
用例您所擅长的不是

00:14:42.340 --> 00:14:51.250
一次这么大的问题，然后

00:14:46.510 --> 00:14:53.050
简而言之，我们还选择了AWS 

00:14:51.250 --> 00:14:54.730
可以看到平台很多

00:14:53.050 --> 00:14:58.060
其他可能性

00:14:54.730 --> 00:15:00.880
许多内部部署的可能性

00:14:58.060 --> 00:15:03.730
他们专注于kubernetes和Kay native 

00:15:00.880 --> 00:15:12.220
技术，但我们选择了公众

00:15:03.730 --> 00:15:14.560
云在这种情况下AWS正确，因此可以移动

00:15:12.220 --> 00:15:16.300
继续我们的实际实施，所以我

00:15:14.560 --> 00:15:18.700
一般来说，主要有三个

00:15:16.300 --> 00:15:21.460
零件或老板后端作为服务，但

00:15:18.700 --> 00:15:24.820
快速的服务功能，最后

00:15:21.460 --> 00:15:27.010
操作，在这种情况下，我将开始

00:15:24.820 --> 00:15:28.570
快速，因为那是主要部分

00:15:27.010 --> 00:15:29.710
的应用程序，当然

00:15:28.570 --> 00:15:34.390
所有代码所在的主要位置

00:15:29.710 --> 00:15:37.960
发生，所以一个的基本定义

00:15:34.390 --> 00:15:41.530
骆驼，所以我们从骆马开始

00:15:37.960 --> 00:15:44.110
 AWS上的功能，因此

00:15:41.530 --> 00:15:47.800
本质上是一段代码， 

00:15:44.110 --> 00:15:50.430
根据杰森的输入运行

00:15:47.800 --> 00:15:52.720
依次再次返回jason的输出

00:15:50.430 --> 00:15:56.860
而且实际上没有一个是正确的

00:15:52.720 --> 00:16:00.070
事件来源可能是一个整体

00:15:56.860 --> 00:16:02.860
一大堆其他触发器等等

00:16:00.070 --> 00:16:06.490
是的，你有动态数据库

00:16:02.860 --> 00:16:08.530
触发您具有的Astri api网关

00:16:06.490 --> 00:16:12.910
当然，一般来说美洲驼是

00:16:08.530 --> 00:16:15.580
始终只是jason in json out，是的

00:16:12.910 --> 00:16:17.200
校友实际上是由一块

00:16:15.580 --> 00:16:21.400
的代码，然后将其定义

00:16:17.200 --> 00:16:22.840
通过一个简单的处理程序是字符串

00:16:21.400 --> 00:16:25.450
在这种情况下功能不保留

00:16:22.840 --> 00:16:26.590
没有获取处理程序基本上只是一个

00:16:25.450 --> 00:16:29.910
很简单

00:16:26.590 --> 00:16:29.910
类定义

00:16:30.150 --> 00:16:36.360
因此至少要实施我们的lambda 

00:16:33.900 --> 00:16:39.390
我们使用的洒水功能

00:16:36.360 --> 00:16:42.360
所以Spring 卡功能，它是

00:16:39.390 --> 00:16:44.730
选择它是因为它为我们提供了基本

00:16:42.360 --> 00:16:47.850
与任何特定的浴室分离，因此

00:16:44.730 --> 00:16:50.940
双重肯定或肯定或开放在哪里

00:16:47.850 --> 00:16:53.100
扫也受支持，我们可以

00:16:50.940 --> 00:16:56.880
基本上独立于

00:16:53.100 --> 00:16:59.640
另一方面，任何平台

00:16:56.880 --> 00:17:02.730
还提供了非常非常统一的

00:16:59.640 --> 00:17:04.740
编程模型，当然还有

00:17:02.730 --> 00:17:07.410
提供我们独立运行的功能，因此我们可以

00:17:04.740 --> 00:17:11.540
从某种意义上讲，就可以按照我们的职能运行

00:17:07.410 --> 00:17:16.380
一个简单的spring boot应用程序，并使用它来

00:17:11.540 --> 00:17:17.819
是的，以这种方式在本地对其进行测试， 

00:17:16.380 --> 00:17:20.130
当然还有其他 spring boot 功能

00:17:17.819 --> 00:17:24.660
也将由于以下原因而被启用

00:17:20.130 --> 00:17:27.000
当然，我们正在使用Spring ，所以只是去

00:17:24.660 --> 00:17:29.059
再来一次，所以我们有了基本的

00:17:27.000 --> 00:17:32.340
函数定义，可能是一个bean 

00:17:29.059 --> 00:17:34.530
然后我们这里有几个案例

00:17:32.340 --> 00:17:36.630
我们有一个适配器，这是一个额外的

00:17:34.530 --> 00:17:39.179
您包括以支持

00:17:36.630 --> 00:17:41.670
特定的平台，或者我们有一个基本的

00:17:39.179 --> 00:17:44.010
 Spring 的设置将成为

00:17:41.670 --> 00:17:48.750
带有启动支持的Spring Boot应用

00:17:44.010 --> 00:17:50.700
或任务或流或其他任何东西

00:17:48.750 --> 00:17:52.350
谈到我们的依赖

00:17:50.700 --> 00:17:55.050
这些是您需要的，所以

00:17:52.350 --> 00:17:57.630
你有基本的 Spring 飞行

00:17:55.050 --> 00:17:59.850
函数上下文是

00:17:57.630 --> 00:18:02.730
 Spring Cloud 功能，将基本上

00:17:59.850 --> 00:18:04.500
使您可以同时运行一个功能

00:18:02.730 --> 00:18:07.950
 Spring 类功能适配器

00:18:04.500 --> 00:18:10.050
情况下，DES适配器将开始

00:18:07.950 --> 00:18:11.910
迎合特定平台，因此

00:18:10.050 --> 00:18:13.980
会有一口小井

00:18:11.910 --> 00:18:16.500
总是很小的植入成本，但是

00:18:13.980 --> 00:18:21.809
通常只是简单地实现一个接口

00:18:16.500 --> 00:18:24.420
现在当我们谈论很多工作时

00:18:21.809 --> 00:18:27.030
课程建设的实施是

00:18:24.420 --> 00:18:30.330
这也是更大的问题之一

00:18:27.030 --> 00:18:33.450
情况我们有两个选择，所以第一个

00:18:30.330 --> 00:18:38.850
将是基本的Wellspring选项，并且

00:18:33.450 --> 00:18:42.179
使用Maven构建一个罐子，这样做

00:18:38.850 --> 00:18:43.720
好吧，我们最好建一个罐子

00:18:42.179 --> 00:18:46.660
使用 spring boot 

00:18:43.720 --> 00:18:48.250
甚至可能开始

00:18:46.660 --> 00:18:51.750
我们来创造一个罐子是

00:18:48.250 --> 00:18:54.790
与Java一样可立即运行

00:18:51.750 --> 00:18:58.150
 AWS实际上还需要的东西

00:18:54.790 --> 00:19:00.550
但是阴影是因为

00:18:58.150 --> 00:19:02.260
通常可以缩短启动时间

00:19:00.550 --> 00:19:04.000
最好你实际上遮蔽了我们所有的人

00:19:02.260 --> 00:19:05.890
依赖项并将它们直接放在

00:19:04.000 --> 00:19:10.930
类路径，所以这只是一个额外的

00:19:05.890 --> 00:19:14.800
专门针对此步骤的步骤

00:19:10.930 --> 00:19:16.240
再次为Atos构建

00:19:14.800 --> 00:19:18.070
实际上是山姆，这实际上是

00:19:16.240 --> 00:19:20.740
我们最终选择了什么，但是

00:19:18.070 --> 00:19:24.760
将随着业务扩展

00:19:20.740 --> 00:19:27.640
所以山姆实际上被实际使用了

00:19:24.760 --> 00:19:29.650
将我们的功能打包为zip，所以Sam 

00:19:27.640 --> 00:19:32.830
也与

00:19:29.650 --> 00:19:34.900
实际上是Maven的 Spring 编译

00:19:32.830 --> 00:19:37.900
编译过程，因为它实际上并没有

00:19:34.900 --> 00:19:40.780
允许我们将zip作为文件运行，这非常

00:19:37.900 --> 00:19:43.480
这样Adel yes就会解释该邮编

00:19:40.780 --> 00:19:45.970
存档并注意

00:19:43.480 --> 00:19:49.330
我们之前为

00:19:45.970 --> 00:19:52.570
 lambda以及它的入口

00:19:49.330 --> 00:19:54.280
功能再次使它

00:19:52.570 --> 00:19:57.190
实际使用 Spring ，我们还需要

00:19:54.280 --> 00:19:59.670
主类的额外变量

00:19:57.190 --> 00:20:06.010
只是定义 Spring 的背景

00:19:59.670 --> 00:20:08.050
再次存在，因此此图像现在

00:20:06.010 --> 00:20:09.640
实际上是向上移动一层，所以我们

00:20:08.050 --> 00:20:12.240
从校友那里走了，现在我们实际上

00:20:09.640 --> 00:20:15.880
上一步是D 

00:20:12.240 --> 00:20:19.090
以及我们的美洲驼的编排

00:20:15.880 --> 00:20:23.140
进入一个过程，所以实际上

00:20:19.090 --> 00:20:25.210
有我们的例子，所以子功能是

00:20:23.140 --> 00:20:27.510
定义为一个简单的定义，所以它

00:20:25.210 --> 00:20:30.550
基本上是指

00:20:27.510 --> 00:20:33.160
操作流程的状态机

00:20:30.550 --> 00:20:35.020
不同的lambda和过程

00:20:33.160 --> 00:20:36.580
您将按顺序执行，甚至

00:20:35.020 --> 00:20:39.700
平行的，这里有很多选择

00:20:36.580 --> 00:20:42.130
是的，有多种模式

00:20:39.700 --> 00:20:44.400
在这里允许诸如控制

00:20:42.130 --> 00:20:47.950
您可以选择的逻辑和

00:20:44.400 --> 00:20:51.040
服务，因此在我们的示例中，您

00:20:47.950 --> 00:20:54.040
实际看到预处理框

00:20:51.040 --> 00:20:56.690
只会做一个小的改变

00:20:54.040 --> 00:20:58.399
输入数据的转换

00:20:56.690 --> 00:20:59.779
比盛行版

00:20:58.399 --> 00:21:01.909
减少一些我们需要的数据

00:20:59.779 --> 00:21:04.419
通过有效验证进行验证

00:21:01.909 --> 00:21:07.549
而不是选择状态评估验证

00:21:04.419 --> 00:21:11.149
那我会选择的很好

00:21:07.549 --> 00:21:13.009
无效，或者我去创建作品

00:21:11.149 --> 00:21:15.320
这将创造我们有效的

00:21:13.009 --> 00:21:17.690
我们的预订或软预订

00:21:15.320 --> 00:21:19.549
系统，然后您会通知

00:21:17.690 --> 00:21:24.619
然后将通知连接的客户端

00:21:19.549 --> 00:21:27.200
发生的变化，在这里你

00:21:24.619 --> 00:21:30.080
看到我们有效的流量之一，如此动人

00:21:27.200 --> 00:21:34.210
直接通知但仅

00:21:30.080 --> 00:21:36.799
遵循一条道路，最后进行测试

00:21:34.210 --> 00:21:38.899
测试当然也很重要

00:21:36.799 --> 00:21:42.379
大家都知道很好的基础测试

00:21:38.899 --> 00:21:44.720
微服务，因此可在一般Java中使用

00:21:42.379 --> 00:21:49.759
代码，以便您使用单元测试服务测试

00:21:44.720 --> 00:21:51.320
并希望进行UI测试，是的， 

00:21:49.759 --> 00:21:53.989
一般而言，您将进行单元测试

00:21:51.320 --> 00:21:56.690
除了这个测试，每个课

00:21:53.989 --> 00:21:59.029
实际上变得更多

00:21:56.690 --> 00:22:01.190
偏斜，所以我们在这里有金字塔

00:21:59.029 --> 00:22:04.039
成为您所看到的歪斜的路由器

00:22:01.190 --> 00:22:04.729
在这里，因为我们正在思考

00:22:04.039 --> 00:22:06.409
无服务器

00:22:04.729 --> 00:22:08.389
功能，尤其是那些

00:22:06.409 --> 00:22:10.999
必须在实际运行的平台上运行

00:22:08.389 --> 00:22:13.580
发生的频率更高，我们将使用

00:22:10.999 --> 00:22:16.220
功能，尤其是测试功能

00:22:13.580 --> 00:22:17.869
以及我们的系统处于更高的水平

00:22:16.220 --> 00:22:19.809
所以我们实际上已经在哪里

00:22:17.869 --> 00:22:22.999
将它们部署到系统，然后

00:22:19.809 --> 00:22:26.419
在此测试其井中的整个流程

00:22:22.999 --> 00:22:28.039
完全完整，这实际上有帮助

00:22:26.419 --> 00:22:29.629
好吧，因为一般来说

00:22:28.039 --> 00:22:32.570
这里还有更多的问题

00:22:29.629 --> 00:22:33.950
实际托管，或者不是那么多

00:22:32.570 --> 00:22:35.989
托管实际上正在照顾

00:22:33.950 --> 00:22:38.389
对我们来说，但是实际的合作

00:22:35.989 --> 00:22:41.559
这些系统是额外的步骤

00:22:38.389 --> 00:22:41.559
需要微妙的

00:22:42.409 --> 00:22:47.599
如此有效地发生了范式转变

00:22:44.479 --> 00:22:50.450
在这里，我们将本地编码，我们

00:22:47.599 --> 00:22:54.919
可以进行远程测试，甚至

00:22:50.450 --> 00:22:57.919
说生产测试，所以现在

00:22:54.919 --> 00:23:00.950
简短的演示，所以我们就去

00:22:57.919 --> 00:23:03.259
通过我们的一些代码

00:23:00.950 --> 00:23:04.909
功能，所以我有基本的

00:23:03.259 --> 00:23:06.830
预订功能，所以我们当然

00:23:04.909 --> 00:23:08.869
应用程序需要很好地检索

00:23:06.830 --> 00:23:10.400
保留，这将是做什么

00:23:08.869 --> 00:23:15.440
所以

00:23:10.400 --> 00:23:20.500
是的，我要一秒钟

00:23:15.440 --> 00:23:23.140
这样你就可以看到更好的权利

00:23:20.500 --> 00:23:26.000
它有效吗

00:23:23.140 --> 00:23:30.290
好吧，我在后面看到竖起大拇指

00:23:26.000 --> 00:23:32.150
对，所以最初我们很好

00:23:30.290 --> 00:23:33.710
基本的 Spring 班，不，这看起来非常

00:23:32.150 --> 00:23:36.350
基本的，但实际上有两个选择

00:23:33.710 --> 00:23:38.059
再一次，我们可以像这样运行

00:23:36.350 --> 00:23:40.400
一个Spring Boot应用程序，现在您看到

00:23:38.059 --> 00:23:41.630
在这里，如果配置意味着它

00:23:40.400 --> 00:23:43.880
实际上将无法以

00:23:41.630 --> 00:23:49.490
 Spring 申请权

00:23:43.880 --> 00:23:50.900
正确的时刻，所以我们有了一个基本的起点

00:23:49.490 --> 00:23:52.610
现在这也有所不同

00:23:50.900 --> 00:23:54.590
通常你会看到你的 Spring 申请

00:23:52.610 --> 00:23:56.059
现在这不仅仅是一个 Spring 应用

00:23:54.590 --> 00:23:58.820
这是功能性的Spring应用程序

00:23:56.059 --> 00:24:01.550
这意味着它是专门为

00:23:58.820 --> 00:24:03.559
一个功能，别无所求

00:24:01.550 --> 00:24:05.030
在我们当中，这意味着很好

00:24:03.559 --> 00:24:07.460
实际上会定义我们的上下文

00:24:05.030 --> 00:24:09.230
我们自己，因为它很小

00:24:07.460 --> 00:24:12.500
实际上很好，对于

00:24:09.230 --> 00:24:14.150
启动我们实际上并不启动的启动

00:24:12.500 --> 00:24:16.640
依靠组件扫描和

00:24:14.150 --> 00:24:20.270
任何初始化我们上下文的东西

00:24:16.640 --> 00:24:22.429
毕竟，这只是我们的一项功能

00:24:20.270 --> 00:24:26.090
在这里找到，是的，这是一些

00:24:22.429 --> 00:24:27.770
技术魔力，但是的，所以基本上

00:24:26.090 --> 00:24:29.690
减少一个功能

00:24:27.770 --> 00:24:31.820
注册，然后将通过

00:24:29.690 --> 00:24:35.170
我们实习生的实际职能是

00:24:31.820 --> 00:24:37.720
保留库更快

00:24:35.170 --> 00:24:40.100
定义输入和输出类型

00:24:37.720 --> 00:24:42.410
那么我们有自己的功能

00:24:40.100 --> 00:24:44.179
只会打电话给我们

00:24:42.410 --> 00:24:47.960
预订库获取预订

00:24:44.179 --> 00:24:50.570
根据尚未输入的信息

00:24:47.960 --> 00:24:52.580
是预订查询，然后终于

00:24:50.570 --> 00:24:56.059
是的，只是我们的预订的定义

00:24:52.580 --> 00:24:58.070
现在查询本身实际上不是

00:24:56.059 --> 00:25:00.200
足以在说骆驼上运行

00:24:58.070 --> 00:25:02.300
任何其他平台，所以我们需要

00:25:00.200 --> 00:25:04.910
实现我们的适配器是什么

00:25:02.300 --> 00:25:08.780
现在在处理程序类中发生

00:25:04.910 --> 00:25:10.880
这是变焦镜头，非常小， 

00:25:08.780 --> 00:25:13.780
实际上并不需要什么

00:25:10.880 --> 00:25:18.140
因此，我们刚刚实施了

00:25:13.780 --> 00:25:19.910
提供者接口或来自的类

00:25:18.140 --> 00:25:22.100
 Spring ，所以成为 Spring 引导请求处理程序

00:25:19.910 --> 00:25:24.559
然后依次实施

00:25:22.100 --> 00:25:29.240
 Lambda所需的接口

00:25:24.559 --> 00:25:32.330
 Edelen睡眠系统然后是的

00:25:29.240 --> 00:25:34.370
走过去，所以我们再次在这里看到的是

00:25:32.330 --> 00:25:36.769
现在调用存储库

00:25:34.370 --> 00:25:39.139
好吧。您使用图书馆范式

00:25:36.769 --> 00:25:41.629
每个存储库都变成一个

00:25:39.139 --> 00:25:43.580
单独的库，然后我们导入

00:25:41.629 --> 00:25:47.299
该图书馆，所以我们在这里是

00:25:43.580 --> 00:25:50.539
实际上只是基本的Spring gdb再次看到

00:25:47.299 --> 00:25:52.580
我们使用gdb在这里查看模板

00:25:50.539 --> 00:25:55.009
仅用于减少依赖

00:25:52.580 --> 00:25:56.509
因为毕竟有一个功能运行

00:25:55.009 --> 00:26:01.340
并且必须加载很多库

00:25:56.509 --> 00:26:02.869
再次是启动的成本，所以我们

00:26:01.340 --> 00:26:04.789
有一些基本的知识，所以创建

00:26:02.869 --> 00:26:07.700
预订并获取预订方法

00:26:04.789 --> 00:26:09.799
这里的实现没有什么特别的

00:26:07.700 --> 00:26:14.899
然后是一个基本定义

00:26:09.799 --> 00:26:19.309
到目前为止的实际预订舱位

00:26:14.899 --> 00:26:22.190
进行代码演示，然后我们将继续

00:26:19.309 --> 00:26:27.019
到后端作为我的服务

00:26:22.190 --> 00:26:29.210
会留给你好吧，所以我们已经看到

00:26:27.019 --> 00:26:30.889
我们现在如何创建功能

00:26:29.210 --> 00:26:32.509
正如我之前所说的，当然

00:26:30.889 --> 00:26:35.029
与很多服务集成

00:26:32.509 --> 00:26:37.009
大概也是，第一件事

00:26:35.029 --> 00:26:40.039
我们要做的当然是看看

00:26:37.009 --> 00:26:42.559
在数据库中，我们待续

00:26:40.039 --> 00:26:45.440
我们开始使用Postgres的数据库

00:26:42.559 --> 00:26:48.559
在云端本身使用

00:26:45.440 --> 00:26:50.299
 Amazon RDS，这是我们的第一步

00:26:48.559 --> 00:26:53.110
当然做了迁移本身

00:26:50.299 --> 00:26:55.490
数据本身非常顺利

00:26:53.110 --> 00:26:57.529
当然，另一件事是我们

00:26:55.490 --> 00:26:58.759
必须连接到该数据库，所以我们

00:26:57.529 --> 00:27:01.159
必须确保我们得到了

00:26:58.759 --> 00:27:03.529
我们也必须使用的凭据

00:27:01.159 --> 00:27:05.749
或者我们可以通过秘密管理器使用它

00:27:03.529 --> 00:27:08.389
或者我们当然有一些事情

00:27:05.749 --> 00:27:10.369
像这样的 Vault 和东西

00:27:08.389 --> 00:27:14.509
当然选择任何你喜欢的但是

00:27:10.369 --> 00:27:16.789
再次不要被管理

00:27:14.509 --> 00:27:19.820
我们自己开始使用托管

00:27:16.789 --> 00:27:21.649
也在这里服务，然后连接

00:27:19.820 --> 00:27:23.869
所有的一切都来了

00:27:21.649 --> 00:27:26.779
进入lambda函数和步骤

00:27:23.869 --> 00:27:28.730
我们选择使用API​​的函数

00:27:26.779 --> 00:27:31.850
安全网关

00:27:28.730 --> 00:27:34.700
当然，我们也利用了

00:27:31.850 --> 00:27:37.009
 Amazon Cognito实际上也是

00:27:34.700 --> 00:27:38.419
确保我们的WebSockets安全

00:27:37.009 --> 00:27:41.029
安全地

00:27:38.419 --> 00:27:42.829
如您所见，客户端本身就是

00:27:41.029 --> 00:27:44.659
要从其请求令牌

00:27:42.829 --> 00:27:46.759
服务，然后当然

00:27:44.659 --> 00:27:48.259
要求我们提供此令牌，该令牌为

00:27:46.759 --> 00:27:52.969
然后要对照

00:27:48.259 --> 00:27:54.979
唯一有效的服务本身

00:27:52.969 --> 00:27:57.919
我们剩下要做的是保持

00:27:54.979 --> 00:28:01.009
正如我们在之前所说的那样

00:27:57.919 --> 00:28:04.489
无服务器应用程序本身可以是

00:28:01.009 --> 00:28:06.169
非常容易，非常迅速地开始，但是

00:28:04.489 --> 00:28:08.389
也可以关闭，所以我们不能真正

00:28:06.169 --> 00:28:10.339
酷存储任何东西在他们等等

00:28:08.389 --> 00:28:12.139
能够存储所有

00:28:10.339 --> 00:28:13.759
与我们联系的客户

00:28:12.139 --> 00:28:16.399
应用程序，以便我们可以发送更新

00:28:13.759 --> 00:28:19.309
等待从外部存储它们

00:28:16.399 --> 00:28:22.609
功能，我们选择了Amazon DynamoDB 

00:28:19.309 --> 00:28:26.749
为此，并与薄板一起

00:28:22.609 --> 00:28:28.819
本身在节点GS中，所以每次我们得到一个

00:28:26.749 --> 00:28:29.989
预订它将要检查

00:28:28.819 --> 00:28:31.909
动物是所有连接的

00:28:29.989 --> 00:28:34.939
客户，它将与

00:28:31.909 --> 00:28:41.529
 API网关发送WebSockets和

00:28:34.939 --> 00:28:44.029
现在向这些客户发送消息

00:28:41.529 --> 00:28:46.309
有关操作的一切，也许之前

00:28:44.029 --> 00:28:48.229
我们继续，因为您可能会认为

00:28:46.309 --> 00:28:49.939
现在的服务意味着我们没有任何服务

00:28:48.229 --> 00:28:52.639
完全没有操作，但这当然是

00:28:49.939 --> 00:28:54.319
事实并非如此，有时它可以使

00:28:52.639 --> 00:28:56.089
有点难

00:28:54.319 --> 00:28:57.379
当然，您不必在乎

00:28:56.089 --> 00:28:59.629
关于服务的管理

00:28:57.379 --> 00:29:01.099
不再是分布式应用程序

00:28:59.629 --> 00:29:02.989
附带了很多额外的东西

00:29:01.099 --> 00:29:04.189
你必须照顾好所以

00:29:02.989 --> 00:29:05.869
确保您已分发

00:29:04.189 --> 00:29:07.239
监视例如

00:29:05.869 --> 00:29:10.279
出问题了，您可以很容易地

00:29:07.239 --> 00:29:12.679
找出故障所在

00:29:10.279 --> 00:29:15.049
当然发生了所有类似的事情

00:29:12.679 --> 00:29:17.419
安全，您有很多事情要做

00:29:15.049 --> 00:29:18.349
关于日志记录等等，等等

00:29:17.419 --> 00:29:20.629
有很多事情要做

00:29:18.349 --> 00:29:22.309
照顾那些仍然是你的

00:29:20.629 --> 00:29:25.869
责任，您当然可以使用

00:29:22.309 --> 00:29:30.709
一些工具，但是那当然

00:29:25.869 --> 00:29:32.449
现在并没有消失

00:29:30.709 --> 00:29:34.549
某种意义上的操作

00:29:32.449 --> 00:29:37.069
我们开始的基础设施代码

00:29:34.549 --> 00:29:38.479
地形，这实际上在帮助我们

00:29:37.069 --> 00:29:40.789
建立我们的基础设施

00:29:38.479 --> 00:29:44.229
为此我们需要的资源

00:29:40.789 --> 00:29:46.489
环境，这是一个多平台

00:29:44.229 --> 00:29:49.549
基础架构作为代码意味着您

00:29:46.489 --> 00:29:51.050
可以有一个包含以下内容的模板

00:29:49.549 --> 00:29:53.470
不同平台的资源

00:29:51.050 --> 00:29:55.730
并且还将存储状态

00:29:53.470 --> 00:29:57.740
独立于平台的含义

00:29:55.730 --> 00:29:59.480
当然要检查什么的课程

00:29:57.740 --> 00:30:02.300
已经部署了一种资源

00:29:59.480 --> 00:30:05.120
在那个时候，所以不好

00:30:02.300 --> 00:30:06.650
他只会做的很聪明

00:30:05.120 --> 00:30:10.730
更新，而不必重新部署

00:30:06.650 --> 00:30:13.010
现在所有的一切都一个问题

00:30:10.730 --> 00:30:14.540
我们在这里遇到的是

00:30:13.010 --> 00:30:16.460
某一刻我们开始实施

00:30:14.540 --> 00:30:19.220
 WebSocket支持，所以我们不得不

00:30:16.460 --> 00:30:21.250
为此使用API​​网关

00:30:19.220 --> 00:30:23.600
实际上还不支持

00:30:21.250 --> 00:30:24.830
当时的地形

00:30:23.600 --> 00:30:26.420
当然是因为有坚定的需要

00:30:24.830 --> 00:30:28.070
与所有平台保持同步

00:30:26.420 --> 00:30:30.440
以及随之而来的新功能

00:30:28.070 --> 00:30:33.050
在那里，他们可以在后面跑

00:30:30.440 --> 00:30:35.510
一点点，这就是问题之一

00:30:33.050 --> 00:30:36.590
我们用terraform发现的

00:30:35.510 --> 00:30:38.450
稍后的效果

00:30:36.590 --> 00:30:41.000
好吧，我们一个解决方案当然是

00:30:38.450 --> 00:30:42.620
大多数情况下只有一个terraform文件

00:30:41.000 --> 00:30:44.630
的东西，然后只想要云

00:30:42.620 --> 00:30:45.860
例如形成，但

00:30:44.630 --> 00:30:48.200
那当然不是真的

00:30:45.860 --> 00:30:51.080
对，所以后来我们实际上

00:30:48.200 --> 00:30:55.030
转向云形成

00:30:51.080 --> 00:30:59.090
完全是为了做我们基础架构的代码

00:30:55.030 --> 00:31:00.860
我之前说过的一些

00:30:59.090 --> 00:31:02.750
帮助我们建造一座建筑物

00:31:00.860 --> 00:31:04.760
内置的自动化系统，但它做的很多

00:31:02.750 --> 00:31:07.580
不仅如此，它还可以帮助我们做

00:31:04.760 --> 00:31:10.010
本地测试与一些本地测试

00:31:07.580 --> 00:31:12.320
嘲笑不多，但你可以嘲笑

00:31:10.010 --> 00:31:14.660
例如API网关，您可以

00:31:12.320 --> 00:31:18.680
也有一个本地DynamoDB实例，如果

00:31:14.660 --> 00:31:20.930
你想最终我们不是真的

00:31:18.680 --> 00:31:22.040
由于这个事实，经常使用

00:31:20.930 --> 00:31:24.590
是欧文

00:31:22.040 --> 00:31:27.110
仅在您的API网关有效时

00:31:24.590 --> 00:31:28.970
很简单，但就我们而言

00:31:27.110 --> 00:31:30.860
定义我们自己的API网关设置

00:31:28.970 --> 00:31:34.250
因为我们有了WebSocket支持

00:31:30.860 --> 00:31:36.770
等等都需要

00:31:34.250 --> 00:31:38.750
一些内置的最佳做法，例如

00:31:36.770 --> 00:31:42.380
您可以进行逐步部署，也可以

00:31:38.750 --> 00:31:44.530
说我要指挥10％的

00:31:42.380 --> 00:31:46.880
流量向我的新版本

00:31:44.530 --> 00:31:49.850
功能，如果一切正常

00:31:46.880 --> 00:31:52.280
那么我们可以做更多，但如果有的话

00:31:49.850 --> 00:31:53.630
警报弹出然后我们可以

00:31:52.280 --> 00:31:57.160
回滚到以前的版本

00:31:53.630 --> 00:32:00.980
我们可以找出正在发生的事情

00:31:57.160 --> 00:32:04.370
所以实际上有些使用了自己的模板

00:32:00.980 --> 00:32:04.809
 CloudFormation上方的ID表示

00:32:04.370 --> 00:32:06.999
即将

00:32:04.809 --> 00:32:10.049
将他的相同模板转换成云

00:32:06.999 --> 00:32:12.009
可以在左侧编队一

00:32:10.049 --> 00:32:13.840
区分相同的模板，因为

00:32:12.009 --> 00:32:17.139
那里有一个变换元素

00:32:13.840 --> 00:32:18.549
意味着AWS必须要做

00:32:17.139 --> 00:32:20.799
迈向云的一步

00:32:18.549 --> 00:32:22.990
阵型，然后你就可以拥有你的

00:32:20.799 --> 00:32:25.840
如您所见，我们在此处定义了资源

00:32:22.990 --> 00:32:29.230
获取预订的功能

00:32:25.840 --> 00:32:32.139
它基于运行时Java 8， 

00:32:29.230 --> 00:32:35.169
有一个指向API网关的链接

00:32:32.139 --> 00:32:37.570
路径斜线保留和HTTP方法

00:32:35.169 --> 00:32:39.700
这样我们就定义了所有

00:32:37.570 --> 00:32:44.049
资源，我们可以开始部署

00:32:39.700 --> 00:32:47.440
实际上，这已经进入我们的环境

00:32:44.049 --> 00:32:48.879
对于我们这里的简单示例

00:32:47.440 --> 00:32:51.309
可以看到已经有很多

00:32:48.879 --> 00:32:53.200
这里发生的事情和主要的事情

00:32:51.309 --> 00:32:54.820
我要你注意的是

00:32:53.200 --> 00:32:57.220
当然你真的不想设置这个

00:32:54.820 --> 00:32:58.779
通过控制台设置自己

00:32:57.220 --> 00:33:01.119
需要尽可能地自动化

00:32:58.779 --> 00:33:02.679
可能这是一个小应用程序，但

00:33:01.119 --> 00:33:04.659
如果您开始使用这个更大的

00:33:02.679 --> 00:33:06.789
应用程序，那么这真的

00:33:04.659 --> 00:33:09.820
强制使其尽可能自动化

00:33:06.789 --> 00:33:13.659
尽可能看到一些数字

00:33:09.820 --> 00:33:15.789
关于我们的东西，然后

00:33:13.659 --> 00:33:20.919
当然，一个规则或

00:33:15.789 --> 00:33:22.720
管理他们另外两个

00:33:20.919 --> 00:33:24.940
我们不会去做的事情

00:33:22.720 --> 00:33:27.700
这里有很多细节，但是当然你也

00:33:24.940 --> 00:33:30.369
需要照顾CI CD 

00:33:27.700 --> 00:33:32.289
此刻还在AWS上寻找

00:33:30.369 --> 00:33:34.929
在那方面有些支持，因为它有

00:33:32.289 --> 00:33:37.269
与SEM的良好集成

00:33:34.929 --> 00:33:39.100
监控当然我们有默认值

00:33:37.269 --> 00:33:40.749
使用Cloud Watch进行监视，但是您

00:33:39.100 --> 00:33:44.230
也正在研究更详细的日志记录

00:33:40.749 --> 00:33:48.190
对AWS X射线有帮助

00:33:44.230 --> 00:33:52.330
我们也一样，我认为那是

00:33:48.190 --> 00:33:54.340
将我们带到最终演示版，以便

00:33:52.330 --> 00:33:56.080
我实际上要拿的最后一个演示

00:33:54.340 --> 00:33:58.059
大家通过控制台显示

00:33:56.080 --> 00:34:00.190
一些本质上很好的资源

00:33:58.059 --> 00:34:07.119
现在我们已经使用Sam进行了部署

00:34:00.190 --> 00:34:08.859
平板电脑是的，所以让我们从

00:34:07.119 --> 00:34:11.260
底部，所以我们有一个功能

00:34:08.859 --> 00:34:13.599
本质上是这里，所以这是校友

00:34:11.260 --> 00:34:15.700
控制台，我们在这里有几个功能

00:34:13.599 --> 00:34:17.740
其中大多数实际上是节点yes 

00:34:15.700 --> 00:34:19.450
你可以看到，但我们已经

00:34:17.740 --> 00:34:22.510
几个数字，我只是

00:34:19.450 --> 00:34:24.280
抢一把，你就可以预约

00:34:22.510 --> 00:34:26.649
之间显示较早

00:34:24.280 --> 00:34:28.570
嗯，这实际上就是全部

00:34:26.649 --> 00:34:30.490
所以在这里你实际上有很多

00:34:28.570 --> 00:34:34.000
选项，以便您可以在以下位置执行测试

00:34:30.490 --> 00:34:36.040
此时，如果您也可以运行

00:34:34.000 --> 00:34:38.080
改变一些参数，但这

00:34:36.040 --> 00:34:40.810
都是为我们管理的，所以现在我们已经

00:34:38.080 --> 00:34:43.659
实际上只是把这个看跌期权

00:34:40.810 --> 00:34:46.030
所有这些都在我们的模板或Sam中

00:34:43.659 --> 00:34:48.190
模板，就这样出现

00:34:46.030 --> 00:34:50.320
在这里对我们来说这当然是有用的

00:34:48.190 --> 00:34:52.270
你必须调试或有一个和任何

00:34:50.320 --> 00:34:53.649
错误或发生的任何事情

00:34:52.270 --> 00:34:57.310
当然，这是去的地方

00:34:53.649 --> 00:35:01.390
真正找到正在发生的事情

00:34:57.310 --> 00:35:04.930
注意一些具体的事情，所以首先

00:35:01.390 --> 00:35:06.400
就像我之前说的，有一些

00:35:04.930 --> 00:35:09.700
我们需要的特定需求，因为我们

00:35:06.400 --> 00:35:15.550
与Sam一起构建spring应用程序之一

00:35:09.700 --> 00:35:17.920
这些将通过电子邮件发送给我们，因此其中之一

00:35:15.550 --> 00:35:19.840
这些将是现在的主要阶层

00:35:17.920 --> 00:35:22.090
德文郡实际上定义了哪个类

00:35:19.840 --> 00:35:23.830
包含我们的 Spring 背景和另一个

00:35:22.090 --> 00:35:25.480
将实际上是函数名称

00:35:23.830 --> 00:35:28.330
需要定义那个 Spring 的bean 

00:35:25.480 --> 00:35:30.450
被认为是一个函数

00:35:28.330 --> 00:35:32.680
跑夏天，所以它会

00:35:30.450 --> 00:35:35.020
本质上是可能的，例如

00:35:32.680 --> 00:35:36.700
在一个罐子里结合多种功能

00:35:35.020 --> 00:35:38.800
然后将它们全部部署在一起

00:35:36.700 --> 00:35:41.410
定义哪个应该与此一起运行

00:35:38.800 --> 00:35:43.090
参数还一些其他的东西，所以

00:35:41.410 --> 00:35:44.890
序列的秘密名称

00:35:43.090 --> 00:35:51.010
被提到的经理，然后

00:35:44.890 --> 00:35:53.410
是的，只是一个用于移动数据库的Dec URL 

00:35:51.010 --> 00:35:57.540
继续执行功能，所以在这里您

00:35:53.410 --> 00:36:01.750
实际上只看到了我们的整个过程

00:35:57.540 --> 00:36:03.160
就是这个，这就是

00:36:01.750 --> 00:36:05.560
状态机，所以你看到一大堆

00:36:03.160 --> 00:36:07.900
州现在再次定义这可能

00:36:05.560 --> 00:36:10.420
平台的差异很大

00:36:07.900 --> 00:36:12.010
功能使用此，但再次谷歌切

00:36:10.420 --> 00:36:15.580
功能或您可能有的功能

00:36:12.010 --> 00:36:17.560
的实现，是的，所以

00:36:15.580 --> 00:36:22.290
这是定义的保留流程

00:36:17.560 --> 00:36:22.290
有效地评估为

00:36:22.540 --> 00:36:29.500
这个图，所以嗯，所以我们得到了

00:36:27.880 --> 00:36:31.660
我又去了

00:36:29.500 --> 00:36:34.150
所以我们要进行评估

00:36:31.660 --> 00:36:36.520
验证等等，我实际上会

00:36:34.150 --> 00:36:41.170
执行快速运行也显示

00:36:36.520 --> 00:36:43.330
还有其他事情，让我们看看是否

00:36:41.170 --> 00:36:46.150
这里看看我们的执行情况

00:36:43.330 --> 00:36:48.490
我们有一堆我要复制

00:36:46.150 --> 00:36:49.870
这一改变一个参数，因为

00:36:48.490 --> 00:36:51.790
事情需要有所不同

00:36:49.870 --> 00:36:53.770
验证工作，我们将

00:36:51.790 --> 00:36:58.090
开始这个，我们实际上会看到

00:36:53.770 --> 00:37:00.700
直播现在如何运行，是的

00:36:58.090 --> 00:37:02.530
现在有效了，所以我们已经

00:37:00.700 --> 00:37:04.510
有一个功能运行我们的几个

00:37:02.530 --> 00:37:07.240
功能，您实际上可以看到

00:37:04.510 --> 00:37:09.040
在这里启动的过程，所以有

00:37:07.240 --> 00:37:13.000
实际上阿拉纳有两个州

00:37:09.040 --> 00:37:16.690
是热还是冷都可以，不是凯蒂

00:37:13.000 --> 00:37:18.460
佩里的歌，可是，某某有多好

00:37:16.690 --> 00:37:21.790
意味着Alana实际上已经活跃

00:37:18.460 --> 00:37:23.260
并在现有机器上运行

00:37:21.790 --> 00:37:25.030
 Colton表示目前

00:37:23.260 --> 00:37:27.900
无效，需要先启动

00:37:25.030 --> 00:37:30.790
杰西卡所谓的冷启动和

00:37:27.900 --> 00:37:33.250
如您所见，现在正在发生

00:37:30.790 --> 00:37:35.320
这个lambda花了一段时间我的意思是

00:37:33.250 --> 00:37:37.540
用Java编写的意思是冷

00:37:35.320 --> 00:37:40.510
开始将花费比例如更长的时间

00:37:37.540 --> 00:37:43.900
写成的解释语言lambda 

00:37:40.510 --> 00:37:46.390
在节点或Python或任何东西，但然后

00:37:43.900 --> 00:37:47.890
再次，我们有优势，因为

00:37:46.390 --> 00:37:51.820
它实际上是编译语言

00:37:47.890 --> 00:37:55.120
一旦开始运行就更快，是的，我们会

00:37:51.820 --> 00:37:57.580
看到现在流过，所以是的

00:37:55.120 --> 00:38:00.070
我们是真正的验证者，现在创建

00:37:57.580 --> 00:38:02.200
再次启动，这是

00:38:00.070 --> 00:38:03.850
实际上也非常有用的UI，因为我们

00:38:02.200 --> 00:38:05.950
实际上可以点击每个

00:38:03.850 --> 00:38:11.800
状态，看看输入了什么， 

00:38:05.950 --> 00:38:14.590
在这里工作，所以创建有

00:38:11.800 --> 00:38:16.600
完成，现在通知运行和

00:38:14.590 --> 00:38:19.720
通知黎明，她的流程已经完成

00:38:16.600 --> 00:38:21.670
然后我实际上要跑了

00:38:19.720 --> 00:38:24.910
相同的代码，所以现在应该失败

00:38:21.670 --> 00:38:27.400
并显示我们的失败失败流程为

00:38:24.910 --> 00:38:29.590
这样，你会看到它实际上是

00:38:27.400 --> 00:38:31.090
已经完成了，因为每个

00:38:29.590 --> 00:38:32.830
这些美洲驼之一实际上是

00:38:31.090 --> 00:38:34.450
已经活跃，因此可能只是

00:38:32.830 --> 00:38:37.839
立即访问

00:38:34.450 --> 00:38:39.700
最后我们有了我们的API网关

00:38:37.839 --> 00:38:41.500
 API网关，也许不是

00:38:39.700 --> 00:38:43.779
解释得很好，但本质上是

00:38:41.500 --> 00:38:45.670
我们的互联网端口，如果

00:38:43.779 --> 00:38:48.960
我们的前端应用程序想要

00:38:45.670 --> 00:38:52.119
访问，这实际上

00:38:48.960 --> 00:38:56.440
是的，到达这里然后从这里开始

00:38:52.119 --> 00:38:58.599
出来我们可以发送我们的发送消息H条

00:38:56.440 --> 00:39:01.200
 HTTP请求并将其发送到

00:38:58.599 --> 00:39:05.410
适当的功能或步进功能

00:39:01.200 --> 00:39:08.230
他们必须经历这样，是的， 

00:39:05.410 --> 00:39:10.510
然后最后，我实际上忘记了

00:39:08.230 --> 00:39:13.059
打开这个，你会看到更多

00:39:10.510 --> 00:39:15.430
内部在这里，我们有我们的实际

00:39:13.059 --> 00:39:20.859
托管在其中的前端应用程序

00:39:15.430 --> 00:39:27.910
流两个简单的桶

00:39:20.859 --> 00:39:30.539
此处和此处的属性

00:39:27.910 --> 00:39:33.430
保留，然后我们实际上有

00:39:30.539 --> 00:39:38.680
现成的应用程序就在这里，如果

00:39:33.430 --> 00:39:42.549
我们说很好就可以使用

00:39:38.680 --> 00:39:45.339
按钮验证没事， 

00:39:42.549 --> 00:39:50.079
保留，然后应该返回接收

00:39:45.339 --> 00:39:56.859
消息在这里我希望演示是

00:39:50.079 --> 00:39:58.210
一个永远不会再正确了，所以

00:39:56.859 --> 00:40:01.420
显然，这个人不想工作

00:39:58.210 --> 00:40:01.869
现在，但是我想有些事情

00:40:01.420 --> 00:40:04.690
出问题了

00:40:01.869 --> 00:40:08.279
所以无论如何，那将是结束

00:40:04.690 --> 00:40:12.450
我希望大家都喜欢这个演示

00:40:08.279 --> 00:40:12.450
让我们继续您的结论

00:40:15.570 --> 00:40:21.820
 [音乐] 

00:40:19.320 --> 00:40:24.100
好的，所以我们仍然有一个结论

00:40:21.820 --> 00:40:25.450
但是你可以看到他们已经

00:40:24.100 --> 00:40:28.450
剪裁，所以您可以在

00:40:25.450 --> 00:40:31.030
结论没问题，只是为了

00:40:28.450 --> 00:40:32.800
在这里总结一些事情是

00:40:31.030 --> 00:40:35.440
也许不是在公园里散步

00:40:32.800 --> 00:40:37.510
我们本来希望它在那里

00:40:35.440 --> 00:40:39.730
这里和这发生了很多事情

00:40:37.510 --> 00:40:41.440
是我们知道的分布式应用程序

00:40:39.730 --> 00:40:42.910
当然来自微服务

00:40:41.440 --> 00:40:45.490
发生了很多事情

00:40:42.910 --> 00:40:47.590
当然，当您使它更多时

00:40:45.490 --> 00:40:49.510
细化并放在函数上

00:40:47.590 --> 00:40:51.790
然后当然可以使复杂度

00:40:49.510 --> 00:40:53.350
只会增加，因为您现在有更多

00:40:51.790 --> 00:40:54.790
要管理的事情，实际上是

00:40:53.350 --> 00:40:56.800
管理仍然是事情之一

00:40:54.790 --> 00:40:58.840
用于这种应用

00:40:56.800 --> 00:41:01.240
很简单，但是如果您有很多

00:40:58.840 --> 00:41:02.590
应用程序弄清楚什么是

00:41:01.240 --> 00:41:04.630
您拥有的功能

00:41:02.590 --> 00:41:07.210
应用程序有点像真实的

00:41:04.630 --> 00:41:08.470
你必须关心的事情

00:41:07.210 --> 00:41:10.210
特别是如果你有一个大

00:41:08.470 --> 00:41:11.710
每个人都知道的开发团队

00:41:10.210 --> 00:41:13.480
你有什么样的功能

00:41:11.710 --> 00:41:15.550
可用的功能是什么

00:41:13.480 --> 00:41:18.580
在那边我们怎么找他们

00:41:15.550 --> 00:41:21.250
我们可以找到他们吗，等等

00:41:18.580 --> 00:41:22.480
有好的经验

00:41:21.250 --> 00:41:25.090
当然有一些文档

00:41:22.480 --> 00:41:27.780
但是其中没有太多指导

00:41:25.090 --> 00:41:29.920
最佳做法以及处理方式

00:41:27.780 --> 00:41:32.320
当然有一些框架， 

00:41:29.920 --> 00:41:35.140
已经有一些想法

00:41:32.320 --> 00:41:36.490
这个嘛，我们实际上并没有看

00:41:35.140 --> 00:41:38.560
无服务器框架，但它是其中之一

00:41:36.490 --> 00:41:41.200
我们想要看的东西

00:41:38.560 --> 00:41:43.840
当然，我们只是看了sem 

00:41:41.200 --> 00:41:45.280
已经给了我们一些指导，但是

00:41:43.840 --> 00:41:46.900
仍然有很多工作要做

00:41:45.280 --> 00:41:49.630
那里有很多东西可以

00:41:46.900 --> 00:41:51.220
我认为也有所改善

00:41:49.630 --> 00:41:52.870
操作，尤其是用于部署

00:41:51.220 --> 00:41:55.350
多个版本之类的东西

00:41:52.870 --> 00:41:59.140
这是SEM可以处理的

00:41:55.350 --> 00:42:01.210
但仍在传播变化

00:41:59.140 --> 00:42:03.310
针对不同的环境和事物

00:42:01.210 --> 00:42:07.930
就像你大多数时候

00:42:03.310 --> 00:42:10.810
现在仍然进行很多手动设置

00:42:07.930 --> 00:42:13.330
这种架构的想法是

00:42:10.810 --> 00:42:15.400
正如我们之前所说的那样，它迫使您

00:42:13.330 --> 00:42:18.630
考虑一下这些小单位

00:42:15.400 --> 00:42:20.740
互相交流，但同时

00:42:18.630 --> 00:42:22.570
有一些，你有一些

00:42:20.740 --> 00:42:23.890
还有责任

00:42:22.570 --> 00:42:25.720
当然可以肯定的是

00:42:23.890 --> 00:42:27.520
对符合以下条件的分布式应用程序有效

00:42:25.720 --> 00:42:30.370
您也可以在这里应用它们，例如

00:42:27.520 --> 00:42:32.140
幂等无状态链

00:42:30.370 --> 00:42:34.780
这样的东西，我们也必须思考

00:42:32.140 --> 00:42:37.330
关于这一点，因为这不是很容易

00:42:34.780 --> 00:42:41.140
你，如果你只是忽略这些

00:42:37.330 --> 00:42:42.550
事情，但话又说回来，你可以利用

00:42:41.140 --> 00:42:44.410
可重用性，因为现在您有了

00:42:42.550 --> 00:42:45.940
您可以使用这些不同的功能

00:42:44.410 --> 00:42:47.920
只是开始在不同的步骤中使用

00:42:45.940 --> 00:42:53.350
功能，例如使用这些状态

00:42:47.920 --> 00:42:55.390
机加工我们的身份证，如果你想去

00:42:53.350 --> 00:42:57.970
看这个尝试专注于一个

00:42:55.390 --> 00:43:00.820
平台开始，因为它很容易

00:42:57.970 --> 00:43:03.340
迷路了，我们也在准备中

00:43:00.820 --> 00:43:04.690
这个谈话开始在所有

00:43:03.340 --> 00:43:06.760
各种各样的东西，我们真的很想

00:43:04.690 --> 00:43:09.070
涉及整个架构

00:43:06.760 --> 00:43:11.830
好吧，你无论如何都会迷路

00:43:09.070 --> 00:43:13.930
那个时候从一个开始

00:43:11.830 --> 00:43:16.030
平台使用一种工具来构建您的

00:43:13.930 --> 00:43:19.290
的东西，然后从那里去

00:43:16.030 --> 00:43:21.730
我想也是一个很好的主意

00:43:19.290 --> 00:43:23.620
就像我之前说过的

00:43:21.730 --> 00:43:25.780
如果不是，请考虑一下操作

00:43:23.620 --> 00:43:27.850
现在就做手术，否则就不做

00:43:25.780 --> 00:43:30.850
真的融入了DevOps部分

00:43:27.850 --> 00:43:32.890
将被迫这样做，如果你

00:43:30.850 --> 00:43:34.900
您不必或如果您不处理

00:43:32.890 --> 00:43:36.730
您此时的微服务

00:43:34.900 --> 00:43:38.470
所有操作的正确方式

00:43:36.730 --> 00:43:41.110
伴随它，你不会

00:43:38.470 --> 00:43:43.060
发挥服务的作用

00:43:41.110 --> 00:43:46.420
平台，因为它会变得平整

00:43:43.060 --> 00:43:48.460
更糟糕的是，所以开始调查那些

00:43:46.420 --> 00:43:50.290
事情，然后当然是政府

00:43:48.460 --> 00:43:52.270
语言本身就是很好的代码

00:43:50.290 --> 00:43:55.030
当然取决于您

00:43:52.270 --> 00:43:56.830
你习惯了，但又有一次

00:43:55.030 --> 00:43:58.600
这种非常灵活的定义方式

00:43:56.830 --> 00:44:01.030
多种语言，您可以结合

00:43:58.600 --> 00:44:04.090
他们就是您喜欢的方式，所以开始

00:44:01.030 --> 00:44:07.480
也要利用它，如果您混合使用

00:44:04.090 --> 00:44:09.790
当然需要

00:44:07.480 --> 00:44:11.980
专注于Java语言，这是一个不错的选择

00:44:09.790 --> 00:44:13.870
语言，但请记住这一点

00:44:11.980 --> 00:44:18.220
冷启动的想法可能是

00:44:13.870 --> 00:44:22.060
一些应用程序的问题，所以我

00:44:18.220 --> 00:44:28.980
认为这结束了我们的谈话

00:44:22.060 --> 00:44:28.980
此刻有任何问题是

00:44:30.130 --> 00:44:37.520
所以你可以再重复一次吗

00:44:35.600 --> 00:44:40.580
 X射线了解发生了什么

00:44:37.520 --> 00:44:42.410
应用程序给我们，但我们实际上

00:44:40.580 --> 00:44:44.060
现在还没有配置X射线

00:44:42.410 --> 00:44:46.400
但我可以检查滑行一卡手表

00:44:44.060 --> 00:44:50.600
看看那里发生了什么

00:44:46.400 --> 00:44:51.650
哦，如果您绝对希望这样的话

00:44:50.600 --> 00:44:53.450
这是我们要做的事情之一

00:44:51.650 --> 00:44:54.770
仍在寻找更多细节，因此

00:44:53.450 --> 00:44:57.920
此刻，我们主要使用云

00:44:54.770 --> 00:45:01.070
很好地监控一切

00:44:57.920 --> 00:45:02.810
 Landis的基础知识，但X射线是

00:45:01.070 --> 00:45:04.610
让我们走得更远，所以我们

00:45:02.810 --> 00:45:06.200
简要调查了一下，但我们没有

00:45:04.610 --> 00:45:24.500
为此真的推出了

00:45:06.200 --> 00:45:28.760
现在的应用程序问题在这里

00:45:24.500 --> 00:45:37.430
为什么AWS是技术决定或

00:45:28.760 --> 00:45:40.040
如果给予得当，或多或少

00:45:37.430 --> 00:45:41.600
像是先决定多件事

00:45:40.040 --> 00:45:43.520
我们已经有了一些经验

00:45:41.600 --> 00:45:45.110
该平台，因为去年我们还

00:45:43.520 --> 00:45:47.420
使用应用程序在那里做了一个应用程序

00:45:45.110 --> 00:45:50.690
引人入胜的效果和抽象

00:45:47.420 --> 00:45:52.510
服务以及其他原因

00:45:50.690 --> 00:45:54.980
那里有一个好的社区， 

00:45:52.510 --> 00:45:55.700
大多数时候，好的文档

00:45:54.980 --> 00:45:57.890
涉及

00:45:55.700 --> 00:45:59.570
好吧，有时候你碰到一些

00:45:57.890 --> 00:46:01.400
麻烦，但我认为其他平台

00:45:59.570 --> 00:46:04.660
那里甚至可能更困难

00:46:01.400 --> 00:46:08.420
这就是两个主要原因

00:46:04.660 --> 00:46:11.960
我们在此调查了AWS 

00:46:08.420 --> 00:46:13.970
时间，但是现在使用抽象

00:46:11.960 --> 00:46:15.830
在 Spring 我们应该能够

00:46:13.970 --> 00:46:18.890
轻松转移功能

00:46:15.830 --> 00:46:20.300
传染，所以如果有一次我们发现

00:46:18.890 --> 00:46:22.280
另一个平台可能会更好

00:46:20.300 --> 00:46:24.200
时间，您可以非常轻松地交换

00:46:22.280 --> 00:46:26.120
当然，服务可能是

00:46:24.200 --> 00:46:27.290
更大的问题，因为他们当然

00:46:26.120 --> 00:46:29.950
将必须是

00:46:27.290 --> 00:46:32.870
弄清楚它，看看我们在那里

00:46:29.950 --> 00:46:37.670
对，以便回答上一个问题

00:46:32.870 --> 00:46:39.290
我现在就开始运作，是的，我们有

00:46:37.670 --> 00:46:42.020
早些时候有通知

00:46:39.290 --> 00:46:44.300
有时会发生疮，实际

00:46:42.020 --> 00:46:46.460
前端的响应不起作用

00:46:44.300 --> 00:46:49.520
这样很好，它不被处理为

00:46:46.460 --> 00:46:51.800
这样的，但是总体来说我们

00:46:49.520 --> 00:46:53.300
功能确实运作良好，但

00:46:51.800 --> 00:46:56.360
功能正常工作，但前端可能

00:46:53.300 --> 00:46:59.810
再次需要一些没有的改进

00:46:56.360 --> 00:47:02.800
焦点我还有一个问题，为什么

00:46:59.810 --> 00:47:05.300
我们是否被迫测试Lambda函数

00:47:02.800 --> 00:47:08.060
如果我们使用的是直接在基地

00:47:05.300 --> 00:47:11.180
 Spring 的框架，我们可以创建一种

00:47:08.060 --> 00:47:12.830
集成或独特的测试，我猜是

00:47:11.180 --> 00:47:15.950
可以执行某些嘲笑

00:47:12.830 --> 00:47:18.350
并进行实际整合和测试

00:47:15.950 --> 00:47:21.110
是的，只是在本地，这是真的

00:47:18.350 --> 00:47:22.640
但最后主要是因为

00:47:21.110 --> 00:47:25.910
我们正在运行的实际环境

00:47:22.640 --> 00:47:27.920
可能会对我们有所改变

00:47:25.910 --> 00:47:30.230
实际上是我们实际上拥有的

00:47:27.920 --> 00:47:33.620
很好地进行反复试验

00:47:30.230 --> 00:47:35.780
实际上得到了山姆内置的Spring 功能

00:47:33.620 --> 00:47:38.000
确实在那里工作

00:47:35.780 --> 00:47:39.350
可能没有想到的事情

00:47:38.000 --> 00:47:41.450
如上课环境

00:47:39.350 --> 00:47:43.970
变量，我们需要它才能正常工作

00:47:41.450 --> 00:47:46.610
我们实际上很好，我们没有找到

00:47:43.970 --> 00:47:47.990
它记录在任何地方，所以那是一个

00:47:46.610 --> 00:47:50.480
这些东西，可能只是

00:47:47.990 --> 00:47:52.490
发生的事情，如果你不这样做

00:47:50.480 --> 00:48:10.910
在平台上测试它然后是的

00:47:52.490 --> 00:48:12.620
可能会遇到惊喜，所以

00:48:10.910 --> 00:48:14.030
那里你要注意，但我

00:48:12.620 --> 00:48:15.800
认为这当然是一个好习惯

00:48:14.030 --> 00:48:17.450
你可以尝试做尽可能多的整合

00:48:15.800 --> 00:48:20.150
在本地测试，因为它们相当

00:48:17.450 --> 00:48:22.250
便宜当然可以，但是你会再次

00:48:20.150 --> 00:48:24.560
必须使用我们的销钉，您必须部署它

00:48:22.250 --> 00:48:26.540
一次到那个形式然后当然

00:48:24.560 --> 00:48:27.410
确保一切都在那里运行，所以

00:48:26.540 --> 00:48:29.270
这些是什么

00:48:27.410 --> 00:48:30.820
这些改变什么是

00:48:29.270 --> 00:48:33.140
有点模糊

00:48:30.820 --> 00:48:35.090
像什么会真正拥有什么

00:48:33.140 --> 00:48:37.310
 WS实际可以改变什么

00:48:35.090 --> 00:48:39.710
对于您的功能来说不是很多

00:48:37.310 --> 00:48:42.410
 AWS改变了功能

00:48:39.710 --> 00:48:44.450
所以它如何运行，所以我在哪里

00:48:42.410 --> 00:48:46.250
 Spring 会产生好，甚至可能

00:48:44.450 --> 00:48:47.090
生成一个罐子，然后将其运行

00:48:46.250 --> 00:48:50.240
在平台上

00:48:47.090 --> 00:48:52.880
它甚至可以双倍运行，是的

00:48:50.240 --> 00:48:55.130
这样山姆如何建造好81 

00:48:52.880 --> 00:48:57.890
山姆建立我们的职能是形式

00:48:55.130 --> 00:49:00.650
拉链，实际上滴得很好

00:48:57.890 --> 00:49:03.860
我们的课程相当简单

00:49:00.650 --> 00:49:06.470
格式化成zip以及所有格式

00:49:03.860 --> 00:49:09.500
需要依赖的方式是

00:49:06.470 --> 00:49:11.660
以这种形式设置的很好

00:49:09.500 --> 00:49:14.390
 AWS实际上会寻找我们的处理程序

00:49:11.660 --> 00:49:16.340
我们在中为功能定义的

00:49:14.390 --> 00:49:18.560
在那里，然后处理程序将

00:49:16.340 --> 00:49:20.300
初始化启动，然后

00:49:18.560 --> 00:49:21.860
现在开始寻找 Spring 背景

00:49:20.300 --> 00:49:23.750
那才是真正出问题的地方

00:49:21.860 --> 00:49:26.150
因为从那以后他们找不到一个

00:49:23.750 --> 00:49:29.090
没有作为正常的JavaSpring 启动

00:49:26.150 --> 00:49:32.210
应用程序，所以这是错误的地方

00:49:29.090 --> 00:49:35.480
我们，是的，这是主要问题

00:49:32.210 --> 00:49:37.730
此时此刻我会丢弃

00:49:35.480 --> 00:49:42.830
看起来真的很好测试

00:49:37.730 --> 00:49:44.960
首先是本地代码

00:49:42.830 --> 00:49:47.090
还是一样，更是如此

00:49:44.960 --> 00:49:50.480
运行以及什么是入口

00:49:47.090 --> 00:49:53.450
代码是如此，它是如何启动的

00:49:50.480 --> 00:49:57.640
这种感觉还可以，所以也许只有一个

00:49:53.450 --> 00:49:57.640
更多问题，是的，请

00:50:00.770 --> 00:50:06.870
是的，所以我们只使用一个存储库

00:50:03.900 --> 00:50:08.520
主要是为了缓解

00:50:06.870 --> 00:50:18.800
我们有版本控制和

00:50:08.520 --> 00:50:22.290
尽管我们确实有权利

00:50:18.800 --> 00:50:23.970
继续，是的，所以是的，正如我所说的那样

00:50:22.290 --> 00:50:26.250
我们确实拥有一切

00:50:23.970 --> 00:50:29.160
仓库，但我们确实在

00:50:26.250 --> 00:50:31.170
这种情况下，而一个maven的亲子

00:50:29.160 --> 00:50:35.610
实际组织我们的结构

00:50:31.170 --> 00:50:37.170
功能还可以，所以我们没时间了

00:50:35.610 --> 00:50:38.970
看到所以非常感谢你

00:50:37.170 --> 00:50:41.810
如果您还有其他问题，请来

00:50:38.970 --> 00:50:41.810
然后说

00:50:42.450 --> 00:50:51.100
 [掌声] 

00:50:43.870 --> 00:50:51.100
 [音乐] 

