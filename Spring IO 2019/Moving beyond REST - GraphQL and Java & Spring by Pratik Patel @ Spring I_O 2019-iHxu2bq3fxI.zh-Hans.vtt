WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.900 --> 00:00:05.499
 [音乐] 

00:00:06.019 --> 00:00:12.089
大家下午好，谢谢

00:00:09.000 --> 00:00:15.780
参加本次会议的休息和图表

00:00:12.089 --> 00:00:16.920
 QL，Java和Spring，我认为他是

00:00:15.780 --> 00:00:19.500
已经做了介绍，所以我不

00:00:16.920 --> 00:00:21.210
我需要做任何事情，因为我说我

00:00:19.500 --> 00:00:23.520
也是Java冠军

00:00:21.210 --> 00:00:24.900
最后一颗是我最喜欢的珍珠

00:00:23.520 --> 00:00:28.560
恢复组还有多少人

00:00:24.900 --> 00:00:30.990
今天在Perl中编写代码的人还可以

00:00:28.560 --> 00:00:33.660
是的，我们要在6:30见面

00:00:30.990 --> 00:00:36.809
专业恢复组中的啤酒

00:00:33.660 --> 00:00:39.239
楼下所以反正一件事我

00:00:36.809 --> 00:00:41.219
想说的是，如果你不

00:00:39.239 --> 00:00:43.079
熟悉IBM在

00:00:41.219 --> 00:00:45.539
春季世界，我们做了很多

00:00:43.079 --> 00:00:48.890
春天真的起作用了

00:00:45.539 --> 00:00:51.510
在IBM Cloud上很好，我们有一个了不起的

00:00:48.890 --> 00:00:54.589
称为open j9的运行时

00:00:51.510 --> 00:00:59.249
代替采用开放式JDK和

00:00:54.589 --> 00:01:01.289
热点VM，因此它们特别开放

00:00:59.249 --> 00:01:03.359
 j9它使用较少的内存并启动

00:01:01.289 --> 00:01:05.430
更快，还有很多其他的东西

00:01:03.359 --> 00:01:07.649
但是在IBM展位前来免费

00:01:05.430 --> 00:01:09.200
像这样的T恤，可以和他们一起出去玩

00:01:07.649 --> 00:01:11.899
我们，显然我们将拥有

00:01:09.200 --> 00:01:14.939
 IBM今天晚些时候赞助的饮料

00:01:11.899 --> 00:01:16.350
所以在我开始之前，我只想

00:01:14.939 --> 00:01:19.439
快速调查有多少人

00:01:16.350 --> 00:01:20.909
当前使用图QL好的，所以一些

00:01:19.439 --> 00:01:24.090
人们有多少人正在使用它

00:01:20.909 --> 00:01:26.939
后端图QL服务器上的Java正常

00:01:24.090 --> 00:01:28.950
现在我要做的是快速

00:01:26.939 --> 00:01:31.649
图QL的介绍，然后看看

00:01:28.950 --> 00:01:33.600
在图QL的实现中编写

00:01:31.649 --> 00:01:37.140
有两个不同的库可以提供帮助

00:01:33.600 --> 00:01:41.280
您建立了一个图QL解决方案

00:01:37.140 --> 00:01:43.170
服务器端的Java，让我们谈谈

00:01:41.280 --> 00:01:45.420
关于图QL首先

00:01:43.170 --> 00:01:47.100
关于图QL的事情是

00:01:45.420 --> 00:01:49.619
实际上是一种查询语言权利

00:01:47.100 --> 00:01:51.929
 QL代表什么图形查询

00:01:49.619 --> 00:01:54.390
语言，这与我们的方式非常相似

00:01:51.929 --> 00:01:56.219
在Java世界中进行编程

00:01:54.390 --> 00:01:57.810
我们正在使用建立继承模型

00:01:56.219 --> 00:01:59.999
我们本质上正在构建的Java类

00:01:57.810 --> 00:02:02.249
出一个对象图，有时候我们

00:01:59.999 --> 00:02:03.810
称它为树，但实际上是

00:02:02.249 --> 00:02:06.210
面向对象时的图形

00:02:03.810 --> 00:02:07.560
进行编程，因此图QL实际上可以

00:02:06.210 --> 00:02:10.080
反映我们的建设方式

00:02:07.560 --> 00:02:12.330
具有域驱动设计的应用程序

00:02:10.080 --> 00:02:14.220
并进入域驱动

00:02:12.330 --> 00:02:16.470
发展很好，因为它是马特

00:02:14.220 --> 00:02:18.390
取决于我们已经建立的方式

00:02:16.470 --> 00:02:19.740
使用o的Java世界中的应用程序

00:02:18.390 --> 00:02:24.180
设计还可以

00:02:19.740 --> 00:02:25.970
现在你可能在想我们有

00:02:24.180 --> 00:02:28.530
学习另一种语言

00:02:25.970 --> 00:02:30.240
幸运的是，图杀死非常简单

00:02:28.530 --> 00:02:31.710
直截了当

00:02:30.240 --> 00:02:34.290
在方式上的差异

00:02:31.710 --> 00:02:36.090
认为是面向对象的Java 

00:02:34.290 --> 00:02:38.100
开发人员已经是，但是是新的

00:02:36.090 --> 00:02:39.870
语言，这是一个新规范

00:02:38.100 --> 00:02:41.760
所以要花一点时间

00:02:39.870 --> 00:02:43.650
了解周围的一些细微差别

00:02:41.760 --> 00:02:45.960
以及如何用它来构建东西

00:02:43.650 --> 00:02:50.130
在接下来的47分钟内在此处执行此操作

00:02:45.960 --> 00:02:53.310
今天好，所以要注意的另一件事是

00:02:50.130 --> 00:02:57.570
该图qaul是一种API查询语言

00:02:53.310 --> 00:02:59.250
还有关键词，API还可以，所以

00:02:57.570 --> 00:03:02.280
关于图QL的重点是

00:02:59.250 --> 00:03:03.840
建立api，随着我们的经历， 

00:03:02.280 --> 00:03:06.900
做一些演示，您将希望看到如何

00:03:03.840 --> 00:03:08.790
就去和

00:03:06.900 --> 00:03:10.410
建立图QL查询以及如何

00:03:08.790 --> 00:03:14.700
它们与您所使用的API有关

00:03:10.410 --> 00:03:16.500
在它后面建好，所以图QL是

00:03:14.700 --> 00:03:19.200
由Facebook创建并开源

00:03:16.500 --> 00:03:20.820
在2015年，它一直保持为

00:03:19.200 --> 00:03:23.070
本质上是社区的一部分

00:03:20.820 --> 00:03:26.810
现在付出努力，这比什么都重要

00:03:23.070 --> 00:03:28.709
否则这是一个规范，没有

00:03:26.810 --> 00:03:31.680
实施或参考

00:03:28.709 --> 00:03:33.120
图QL的实现还可以，所以

00:03:31.680 --> 00:03:36.269
规格多于

00:03:33.120 --> 00:03:38.040
实施以及我们进行一些演示时

00:03:36.269 --> 00:03:40.019
并在几分钟内在这里编码

00:03:38.040 --> 00:03:42.120
我们将看到的是

00:03:40.019 --> 00:03:43.739
上的图形规范

00:03:42.120 --> 00:03:45.989
服务器端，因为那是一回事

00:03:43.739 --> 00:03:50.459
重要的是要注意，它实际上是一个

00:03:45.989 --> 00:03:52.049
规范，而不是实现，如何

00:03:50.459 --> 00:03:54.690
很多人在这里看硅谷

00:03:52.049 --> 00:03:57.120
那样好吗，我不确定是否

00:03:54.690 --> 00:03:58.470
只是我们在美国观看

00:03:57.120 --> 00:04:01.650
无论如何，这是硅的一幕

00:03:58.470 --> 00:04:06.299
山谷，所以您可能会认为我们只是

00:04:01.650 --> 00:04:08.700
重写了我们所有的API Zoar端点，或者

00:04:06.299 --> 00:04:09.930
无论使用休息，现在我在这里

00:04:08.700 --> 00:04:12.180
告诉你应该看

00:04:09.930 --> 00:04:13.320
像图QL这样的东西，也许

00:04:12.180 --> 00:04:14.519
你感觉就像这个家伙

00:04:13.320 --> 00:04:18.989
图片，我们应该把它全部烧掉

00:04:14.519 --> 00:04:20.790
为什么我们要打扰好了，是的，你

00:04:18.989 --> 00:04:23.880
可能已经重写了所有静止的内容，或者

00:04:20.790 --> 00:04:26.250
也许你正在搬家

00:04:23.880 --> 00:04:27.000
转到基于更宁静的API 

00:04:26.250 --> 00:04:29.160
建筑

00:04:27.000 --> 00:04:31.800
但是关于图QL的好处是

00:04:29.160 --> 00:04:34.050
它不是纯粹的替代品

00:04:31.800 --> 00:04:36.270
休息我喜欢的思考方式

00:04:34.050 --> 00:04:37.950
 QL图只是另一个工具

00:04:36.270 --> 00:04:40.500
在您的工具带中进行建造

00:04:37.950 --> 00:04:41.910
应用程序，因此您不必抛出

00:04:40.500 --> 00:04:45.240
丢掉你写的所有东西， 

00:04:41.910 --> 00:04:47.970
休息，你可以快乐地与休息共存

00:04:45.240 --> 00:04:50.040
并在同一服务器上使用图QL或

00:04:47.970 --> 00:04:51.540
在相同的架构中，您可以使用

00:04:50.040 --> 00:04:54.300
如果你想两者都很好

00:04:51.540 --> 00:04:56.310
好吧，我们将进入

00:04:54.300 --> 00:04:57.540
几分钟之内就可以完成

00:04:56.310 --> 00:04:58.920
你实际上可以做的是

00:04:57.540 --> 00:05:00.120
您已经有一个宁静的api是

00:04:58.920 --> 00:05:03.090
尤其是如果您休息

00:05:00.120 --> 00:05:04.410
多个分布式API 

00:05:03.090 --> 00:05:06.870
多个端点

00:05:04.410 --> 00:05:09.270
不同的服务器或服务

00:05:06.870 --> 00:05:11.610
您已经设计了架构， 

00:05:09.270 --> 00:05:15.900
实际上可以包装您的基础

00:05:11.610 --> 00:05:17.850
带有图QL的Restful API 

00:05:15.900 --> 00:05:20.160
这实际上是非常强大的

00:05:17.850 --> 00:05:24.210
提取，因为您可以有多个

00:05:20.160 --> 00:05:26.460
正在构建事物的团队

00:05:24.210 --> 00:05:29.910
他们已经在布雷斯特建造了东西

00:05:26.460 --> 00:05:31.410
他们的api已暴露，您可以休息

00:05:29.910 --> 00:05:33.390
实际去包装它们

00:05:31.410 --> 00:05:35.880
像元api一样创建

00:05:33.390 --> 00:05:37.919
现有的api，以便您的前端

00:05:35.880 --> 00:05:39.900
应用程序或您的移动应用程序

00:05:37.919 --> 00:05:42.540
有一个统一的入口

00:05:39.900 --> 00:05:44.550
所有这些不同的api和

00:05:42.540 --> 00:05:48.060
数据源，我们将再次探讨

00:05:44.550 --> 00:05:50.520
几分钟后就可以了

00:05:48.060 --> 00:05:52.740
所以如上所述，我们可以有任何

00:05:50.520 --> 00:05:54.210
数据源在下面，实际上是

00:05:52.740 --> 00:05:56.100
图QL，因为它只是一个

00:05:54.210 --> 00:05:58.950
前端或从

00:05:56.100 --> 00:06:00.510
前端到后端不是

00:05:58.950 --> 00:06:02.370
甚至不必成为一个数据源

00:06:00.510 --> 00:06:04.290
必须是你背后的数据库

00:06:02.370 --> 00:06:06.450
可以在其中运行其他内容

00:06:04.290 --> 00:06:08.340
背景并用图形包装

00:06:06.450 --> 00:06:09.000
提示所有实际上超级的API 

00:06:08.340 --> 00:06:11.580
强大

00:06:09.000 --> 00:06:13.410
好吧，我们也将在

00:06:11.580 --> 00:06:15.600
分钟，一件事是不同的

00:06:13.410 --> 00:06:17.610
关于图QL与宁静

00:06:15.600 --> 00:06:19.650
端点是一个单一的

00:06:17.610 --> 00:06:21.630
端点，所以当您设置图形QL时

00:06:19.650 --> 00:06:23.910
实例只会去一个地方

00:06:21.630 --> 00:06:25.500
可以全部使用斜线图形或

00:06:23.910 --> 00:06:27.180
随便你怎么称呼它

00:06:25.500 --> 00:06:29.250
关于图形的其他有趣的事情

00:06:27.180 --> 00:06:31.919
你们所有人与休息相比，它是

00:06:29.250 --> 00:06:33.270
基于模式的权利，我们来看一下

00:06:31.919 --> 00:06:35.729
我们在一分钟内完成图杀死计划

00:06:33.270 --> 00:06:37.500
去探索它的实际外观

00:06:35.729 --> 00:06:39.000
就像，但这是两个关键

00:06:37.500 --> 00:06:40.559
差异，我们将讨论更多

00:06:39.000 --> 00:06:43.949
但是两个主要区别

00:06:40.559 --> 00:06:46.349
在图QL和标准休止点之间是

00:06:43.949 --> 00:06:48.089
而是有一个端点

00:06:46.349 --> 00:06:49.229
您知道何时的多个端点

00:06:48.089 --> 00:06:51.479
您正在建立一个宁静的终点

00:06:49.229 --> 00:06:53.909
您可能有一个斜线用户端点，并且

00:06:51.479 --> 00:06:55.679
您可能有大幅削减购物车或

00:06:53.909 --> 00:06:57.539
削减项目或其他

00:06:55.679 --> 00:06:59.249
图QL的不同端点

00:06:57.539 --> 00:07:01.259
只有一个端点，您发送一个

00:06:59.249 --> 00:07:03.599
查询以获取您的确切数据

00:07:01.259 --> 00:07:05.609
需要，背后有一个架构，所以

00:07:03.599 --> 00:07:07.829
而不是只是你

00:07:05.609 --> 00:07:09.449
快速构建，你说的很好

00:07:07.829 --> 00:07:12.269
这是我们的用户端点，我们有

00:07:09.449 --> 00:07:15.779
要获取的四个动词HTTP动词和

00:07:12.269 --> 00:07:18.899
 QL可以采取的放置等条件图

00:07:15.779 --> 00:07:21.179
获取或发布，但单个端点

00:07:18.899 --> 00:07:22.109
我们向它传递查询以查看它是什么

00:07:21.179 --> 00:07:26.039
看起来像，我们将这样做

00:07:22.109 --> 00:07:27.089
现在好了，是时候进行快速演示了

00:07:26.039 --> 00:07:29.999
你知道演示如何工作

00:07:27.089 --> 00:07:32.729
所以希望这一切正常

00:07:29.999 --> 00:07:35.399
让我们快速浏览一下

00:07:32.729 --> 00:07:37.469
在这里查询，希望很大

00:07:35.399 --> 00:07:39.149
足够让我们仔细检查是的

00:07:37.469 --> 00:07:41.399
很好，所以我在这里

00:07:39.149 --> 00:07:43.529
首先我们从查询开始，然后说全部

00:07:41.399 --> 00:07:46.469
飞船让我飞船

00:07:43.529 --> 00:07:47.729
下面和模型中的名称以及

00:07:46.469 --> 00:07:49.289
你可以看到印在这里，但是

00:07:47.729 --> 00:07:52.259
我们走吧，实际上等于

00:07:49.289 --> 00:07:54.539
让我们看看我们能做什么让我们说什么

00:07:52.259 --> 00:07:57.959
星际飞船的一类就是，让我们开始吧

00:07:54.539 --> 00:07:59.639
运行它，您可以看到现在我们得到了

00:07:57.959 --> 00:08:01.169
星舰级的护卫舰和这个

00:07:59.639 --> 00:08:02.999
是驱逐舰，当然这是

00:08:01.169 --> 00:08:05.489
星球大战，但让我们看看还有哪些其他数据

00:08:02.999 --> 00:08:06.749
点，我们可以在这里添加好，你可以

00:08:05.489 --> 00:08:08.849
看到我正在为此工作，这是

00:08:06.749 --> 00:08:12.059
所谓的图形或图形方程式

00:08:08.849 --> 00:08:14.789
这是底层浏览器

00:08:12.059 --> 00:08:18.229
图QL端点确定，所以我们可以说

00:08:14.789 --> 00:08:20.189
让我们看看不同类型的

00:08:18.229 --> 00:08:22.439
星舰是，所以你可以看到这些是

00:08:20.189 --> 00:08:26.569
当然，“星际驱逐舰”的长度是

00:08:22.439 --> 00:08:29.879
现在比ACR 90 Corvette大得多

00:08:26.569 --> 00:08:31.769
让我们看看如何去看

00:08:29.879 --> 00:08:33.449
这一点更多的细节，所以我们

00:08:31.769 --> 00:08:35.159
实际能做的是因为图QL 

00:08:33.449 --> 00:08:36.870
产生一个我们可以实际去的模式

00:08:35.159 --> 00:08:38.819
查看模式，如果有

00:08:36.870 --> 00:08:41.099
不在后端的开发人员

00:08:38.819 --> 00:08:42.599
图QL实际上所在的团队

00:08:41.099 --> 00:08:44.339
生产了您的前端开发人员

00:08:42.599 --> 00:08:48.179
移动或网络开发人员可以

00:08:44.339 --> 00:08:50.399
实际来到这里这个图形

00:08:48.179 --> 00:08:52.949
图QL端点的资源管理器和

00:08:50.399 --> 00:08:53.870
看看实际上是什么

00:08:52.949 --> 00:08:56.900
裸露

00:08:53.870 --> 00:08:58.010
通过您的图QL API，这样您

00:08:56.900 --> 00:09:00.710
可以看到在这个具体

00:08:58.010 --> 00:09:02.270
到目前为止，我们已经使用了演示API 

00:09:00.710 --> 00:09:04.490
看着飞船，所以如果我去

00:09:02.270 --> 00:09:07.370
星际飞船这是星际飞船的关系

00:09:04.490 --> 00:09:10.220
我可以点击这里，我们可以去

00:09:07.370 --> 00:09:12.080
看看有哪些不同类型的

00:09:10.220 --> 00:09:14.390
一切都好，所以我们有

00:09:12.080 --> 00:09:17.000
星际飞船和所有的架构

00:09:14.390 --> 00:09:19.100
与那个特定的关联

00:09:17.000 --> 00:09:20.960
好吧，所以我们可以看到

00:09:19.100 --> 00:09:23.060
这是所有的描述

00:09:20.960 --> 00:09:24.830
制成的不同领域

00:09:23.060 --> 00:09:27.140
可供我们使用，所以我们有名称模型

00:09:24.830 --> 00:09:29.720
谁是制造商，我们走吧

00:09:27.140 --> 00:09:32.750
看看谁使制造商正确

00:09:29.720 --> 00:09:35.060
再次因为我们有一个预定义

00:09:32.750 --> 00:09:37.070
关于这个模式，我们有这个工具

00:09:35.060 --> 00:09:40.400
允许我们去浏览和检查

00:09:37.070 --> 00:09:41.840
并查看这个特定的图QL 

00:09:40.400 --> 00:09:43.820
我们拥有的终点，因此我们可以来

00:09:41.840 --> 00:09:45.230
进入这里，我们可以说谁是

00:09:43.820 --> 00:09:47.480
那不同的制造商

00:09:45.230 --> 00:09:50.600
如果我们现在就暂时摆脱这个

00:09:47.480 --> 00:09:52.700
去运行这个，你会看到我们可以去

00:09:50.600 --> 00:09:55.010
并看到这些是不同的

00:09:52.700 --> 00:09:57.110
进行《星球大战》的人的类型

00:09:55.010 --> 00:10:01.010
星河吧，但让我们回到这里

00:09:57.110 --> 00:10:05.270
很快，我们应该也可以

00:10:01.010 --> 00:10:07.850
看看那部特定的飞船电影

00:10:05.270 --> 00:10:10.040
出现了，所以我们再次进入

00:10:07.850 --> 00:10:13.550
在此处浏览图QL模式

00:10:10.040 --> 00:10:16.070
此工具称为图形QL或图形

00:10:13.550 --> 00:10:17.600
我们可以看到所有不同的东西

00:10:16.070 --> 00:10:19.610
其中包含但如果我们

00:10:17.600 --> 00:10:20.930
向下滚动一点我们也可以看到

00:10:19.610 --> 00:10:22.910
有所谓的电影

00:10:20.930 --> 00:10:24.920
连接，所以现在如果我去看电影

00:10:22.910 --> 00:10:28.520
连接，我们可以看到

00:10:24.920 --> 00:10:31.310
基本上不同类型的电影

00:10:28.520 --> 00:10:34.190
与每个飞船相关，所以我

00:10:31.310 --> 00:10:36.200
可以进入这里，我不会尝试

00:10:34.190 --> 00:10:39.200
马上输入所有内容

00:10:36.200 --> 00:10:40.730
所以我要去运行这个特定的

00:10:39.200 --> 00:10:43.010
事情跟以前一样让我们

00:10:40.730 --> 00:10:48.260
查询所有的星际飞船，让我们

00:10:43.010 --> 00:10:50.210
名称和型号称为philip connect to 

00:10:48.260 --> 00:10:52.580
在这种情况下有很多关系记得

00:10:50.210 --> 00:10:54.710
图QL是一个架构，不是

00:10:52.580 --> 00:10:57.560
与续集不同这是不一样的

00:10:54.710 --> 00:10:59.300
作为SQL或续集的东西更多

00:10:57.560 --> 00:11:01.430
基于图的模式而不是

00:10:59.300 --> 00:11:03.320
关系模式，但在这种情况下，我们

00:11:01.430 --> 00:11:05.420
有两个来自星际飞船的关系

00:11:03.320 --> 00:11:07.640
电影就在这里，让我们去运行这个

00:11:05.420 --> 00:11:10.280
我们会看到

00:11:07.640 --> 00:11:12.200
 90 Corvette出现了第一部电影

00:11:10.280 --> 00:11:13.910
出现是一个新的希望，然后

00:11:12.200 --> 00:11:15.860
星际驱逐舰也出现在新的

00:11:13.910 --> 00:11:17.300
希望，让我们向下滚动以查看是否

00:11:15.860 --> 00:11:20.420
可以找到另一种权利，所以

00:11:17.300 --> 00:11:22.430
皇家航天飞机首先出现在

00:11:20.420 --> 00:11:24.140
帝国反击

00:11:22.430 --> 00:11:25.940
只有我能够获得第一个的方式

00:11:24.140 --> 00:11:28.010
一个是我在这里使用了一个称为

00:11:25.940 --> 00:11:30.980
首先说给我第一部电影

00:11:28.010 --> 00:11:33.860
那个飞船出现了，所以我可以

00:11:30.980 --> 00:11:36.710
在这里放两个，然后立即运行

00:11:33.860 --> 00:11:38.870
我们将看到例如星

00:11:36.710 --> 00:11:41.150
驱逐舰出现了新的希望

00:11:38.870 --> 00:11:42.320
在《帝国反击战》中

00:11:41.150 --> 00:11:43.820
一起摆脱这一切

00:11:42.320 --> 00:11:47.000
你可能会猜到会发生什么

00:11:43.820 --> 00:11:50.140
发生吧，它将带我看所有电影

00:11:47.000 --> 00:11:53.300
那个特定的飞船出现在

00:11:50.140 --> 00:11:55.730
好吧，我们要做的就是

00:11:53.300 --> 00:11:58.100
非常简单地使用图QL查询

00:11:55.730 --> 00:12:00.350
探索我们可以做什么的语言

00:11:58.100 --> 00:12:02.090
图QL端点好了，让我们

00:12:00.350 --> 00:12:03.770
在这里多做几个，所以我们做了

00:12:02.090 --> 00:12:06.080
第一个与电影的联系

00:12:03.770 --> 00:12:08.750
我们也可以去计数，以便我可以

00:12:06.080 --> 00:12:10.370
说查询所有的飞船计数，我是

00:12:08.750 --> 00:12:12.230
去跑那个，你可以看到

00:12:10.370 --> 00:12:16.100
没用吧，那为什么没用

00:12:12.230 --> 00:12:18.620
它说，如果

00:12:16.100 --> 00:12:21.080
你会指望星际飞船

00:12:18.620 --> 00:12:23.060
总连接数，所以让我们去

00:12:21.080 --> 00:12:24.170
进入，实际上我不需要去

00:12:23.060 --> 00:12:25.910
看我可能有的错误信息

00:12:24.170 --> 00:12:28.100
刚到这里，当我打

00:12:25.910 --> 00:12:29.930
控制空间，它向我展示了所有

00:12:28.100 --> 00:12:31.610
属性或我拥有的字段

00:12:29.930 --> 00:12:33.950
访问哪个真的很好

00:12:31.610 --> 00:12:35.840
因此，如果您有一个新的开发人员

00:12:33.950 --> 00:12:37.520
进入您的项目进入公司

00:12:35.840 --> 00:12:39.050
他们是前端开发人员，或者

00:12:37.520 --> 00:12:40.760
即使他们是后端开发人员

00:12:39.050 --> 00:12:42.560
可以说迪斯科浏览图形QL 

00:12:40.760 --> 00:12:45.200
端点学习所有不同

00:12:42.560 --> 00:12:47.510
我们可以以某种方式公开的东西

00:12:45.200 --> 00:12:49.340
也可以作为文档

00:12:47.510 --> 00:12:52.610
人们喜欢在其中编写文档

00:12:49.340 --> 00:12:54.530
这里任何人都一定有这个

00:12:52.610 --> 00:12:56.090
房间里必须满是开发商，因为

00:12:54.530 --> 00:12:58.250
我是一个我讨厌写的开发人员

00:12:56.090 --> 00:13:00.980
文档，但您必须这样做

00:12:58.250 --> 00:13:02.600
是的，但这很好，因为从

00:13:00.980 --> 00:13:04.040
模式，我们可以获取此文档

00:13:02.600 --> 00:13:07.850
本质上是免费的

00:13:04.040 --> 00:13:10.070
好的，无论如何，让我们看看并开始跑步

00:13:07.850 --> 00:13:13.670
这个，这个数据库共有37个

00:13:10.070 --> 00:13:14.660
里面的星舰好吧

00:13:13.670 --> 00:13:17.480
我们可以做的另一件事是

00:13:14.660 --> 00:13:19.160
有趣的是，我们可以去得到

00:13:17.480 --> 00:13:20.649
来自一个集合的东西

00:13:19.160 --> 00:13:22.959
星际飞船系列

00:13:20.649 --> 00:13:24.519
在同一个电话中也得到了一些东西

00:13:22.959 --> 00:13:26.829
那是完全无关的

00:13:24.519 --> 00:13:28.990
所以星中不同的物种

00:13:26.829 --> 00:13:30.279
战争世界与

00:13:28.990 --> 00:13:32.319
他们是不同的飞船

00:13:30.279 --> 00:13:34.809
完全不同，所以我可以去跑步

00:13:32.319 --> 00:13:36.610
这个，在顶部，我将全力以赴

00:13:34.809 --> 00:13:38.740
星际飞船，让我们将所有

00:13:36.610 --> 00:13:41.079
星际飞船，然后在它下面

00:13:38.740 --> 00:13:43.959
您会看到我有所有列表

00:13:41.079 --> 00:13:45.459
星球大战宇宙中的物种，所以我

00:13:43.959 --> 00:13:48.610
基本上去取两个

00:13:45.459 --> 00:13:52.059
同一数据库或同一数据库中的集合

00:13:48.610 --> 00:13:53.649
相同的图qo调用权，我将

00:13:52.059 --> 00:13:55.360
告诉你为什么这很重要

00:13:53.649 --> 00:13:57.300
几分钟，但基本上我可以

00:13:55.360 --> 00:14:00.759
去得到两个不同的无关

00:13:57.300 --> 00:14:03.369
 I模式内部的集合

00:14:00.759 --> 00:14:04.899
在相同的API调用中，好的，我们已经

00:14:03.369 --> 00:14:07.629
看了我们如何做收藏

00:14:04.899 --> 00:14:09.189
从飞船到电影的穿越

00:14:07.629 --> 00:14:10.600
对，这是一对多关系

00:14:09.189 --> 00:14:13.089
当然，也许是多对多

00:14:10.600 --> 00:14:14.769
关系，因为可能不同

00:14:13.089 --> 00:14:15.490
星际飞船出现在不同的电影中

00:14:14.769 --> 00:14:18.550
反之亦然

00:14:15.490 --> 00:14:21.129
好吧，所以我们可以做的另一件事是

00:14:18.550 --> 00:14:22.720
当我们构建这个好吧

00:14:21.129 --> 00:14:24.519
我们只是查询只是一个字符串

00:14:22.720 --> 00:14:25.839
就是说我们正在使用

00:14:24.519 --> 00:14:27.279
 JavaScript前端有多少人

00:14:25.839 --> 00:14:28.749
建立前端和JavaScript 

00:14:27.279 --> 00:14:31.059
出于好奇

00:14:28.749 --> 00:14:32.499
所以对于很多人来说，当我们

00:14:31.059 --> 00:14:33.730
在JavaScript中构建该代码

00:14:32.499 --> 00:14:36.579
这有一些帮助的图书馆

00:14:33.730 --> 00:14:38.379
您在建立图QL查询

00:14:36.579 --> 00:14:41.649
 JavaScript，以及类似的iOS和

00:14:38.379 --> 00:14:43.540
 Android，但我们不想这么做

00:14:41.649 --> 00:14:45.639
字符串连接和字符串

00:14:43.540 --> 00:14:47.199
当我们想重用一个

00:14:45.639 --> 00:14:49.449
一遍又一遍地查询，所以您可能

00:14:47.199 --> 00:14:51.069
在我的应用程序内部说

00:14:49.449 --> 00:14:53.559
去多次获得星舰

00:14:51.069 --> 00:14:55.929
是的，但我想换一个

00:14:53.559 --> 00:14:58.660
而且我们不想进来做

00:14:55.929 --> 00:14:59.860
字符串连接或例如让

00:14:58.660 --> 00:15:02.319
我去找合适的，我在这里

00:14:59.860 --> 00:15:04.929
某个地方，或者我不正确，所以我

00:15:02.319 --> 00:15:06.790
可能不想去实际上得到

00:15:04.929 --> 00:15:10.149
硬编码实际名称

00:15:06.790 --> 00:15:12.579
我的应用中的星际飞船

00:15:10.149 --> 00:15:14.889
当然我找不到我写的

00:15:12.579 --> 00:15:18.459
早些时候哦，好吧

00:15:14.889 --> 00:15:21.069
无论如何，所以我们可以做的就是可以使用

00:15:18.459 --> 00:15:23.740
本质上查询像我们这样的参数

00:15:21.069 --> 00:15:26.410
在这个例子中，所以我们要做的是

00:15:23.740 --> 00:15:28.629
当我们在客户端上构造图QL时

00:15:26.410 --> 00:15:30.399
我们可以在这里说我的查询变量

00:15:28.629 --> 00:15:33.129
用这个来称它为星际ID 

00:15:30.399 --> 00:15:34.030
具体ID，然后在我的图形QL中

00:15:33.129 --> 00:15:36.280
查询我

00:15:34.030 --> 00:15:39.070
再说一遍美元星际身份证就是这样

00:15:36.280 --> 00:15:42.790
事情就在这里，这是我们给的

00:15:39.070 --> 00:15:44.200
它是一种ID感叹号

00:15:42.790 --> 00:15:47.350
这是关于图QL的另一件事

00:15:44.200 --> 00:15:48.970
有趣的是，不仅

00:15:47.350 --> 00:15:51.880
我们定义数据的结构或

00:15:48.970 --> 00:15:55.360
在我们的架构中，我们还将

00:15:51.880 --> 00:15:57.580
每个字段和每个字段的特定类型

00:15:55.360 --> 00:15:59.920
数据元素是这样，在这种情况下

00:15:57.580 --> 00:16:02.530
说这是我的飞船ID 

00:15:59.920 --> 00:16:04.840
输入ID，然后我们就可以

00:16:02.530 --> 00:16:09.550
用它去获取一个特定的

00:16:04.840 --> 00:16:11.230
像这样的星际飞船，所以我们看着

00:16:09.550 --> 00:16:14.050
如何遍历关系如何使用

00:16:11.230 --> 00:16:16.210
查询参数如何使用分页

00:16:14.050 --> 00:16:17.980
和第一个修饰符，这样我们就可以

00:16:16.210 --> 00:16:20.260
如果需要的话，只获取一页数据

00:16:17.980 --> 00:16:23.590
像这样的其他事情

00:16:20.260 --> 00:16:24.810
糟糕，让我们回到这里

00:16:23.590 --> 00:16:26.890
现在不要

00:16:24.810 --> 00:16:28.510
好吧，让我们确保我们覆盖了

00:16:26.890 --> 00:16:31.060
我们谈论过的一切

00:16:28.510 --> 00:16:33.450
遍历像这样的关系

00:16:31.060 --> 00:16:35.770
谈到我们如何获得计数

00:16:33.450 --> 00:16:37.420
我们怎么做查询，这就是我

00:16:35.770 --> 00:16:40.330
寻找更早的权利，所以我们不

00:16:37.420 --> 00:16:42.820
想要像我们一样对ID进行硬编码

00:16:40.330 --> 00:16:46.960
这里我们宁愿使用查询变量

00:16:42.820 --> 00:16:49.960
我们可以重复使用相同的字符串

00:16:46.960 --> 00:16:51.460
并从中得到结果， 

00:16:49.960 --> 00:16:54.820
然后我们也这样做了

00:16:51.460 --> 00:16:58.690
如果您发现现在使用查询变量

00:16:54.820 --> 00:17:00.400
当我们进入图QL时

00:16:58.690 --> 00:17:03.340
查询让我们回到这一权利

00:17:00.400 --> 00:17:06.100
好的，让我们找到一个简单的权利

00:17:03.340 --> 00:17:07.390
像这样或如果我们看着这个你

00:17:06.100 --> 00:17:09.300
可以看到我必须键入所有内容

00:17:07.390 --> 00:17:11.350
我们说一下结构类

00:17:09.300 --> 00:17:14.470
制造商哎呀

00:17:11.350 --> 00:17:17.550
而且我一直按错了按钮

00:17:14.470 --> 00:17:21.700
出于某种原因，对不起

00:17:17.550 --> 00:17:25.750
花费信用额，也许我们会做

00:17:21.700 --> 00:17:28.720
长度等等等，但是在图QL中

00:17:25.750 --> 00:17:31.420
你必须去打字每一个

00:17:28.720 --> 00:17:34.060
您想要的字段，您不能只说

00:17:31.420 --> 00:17:38.050
开始没有通配符参数

00:17:34.060 --> 00:17:41.020
对QL进行图形绘制，这样就可以休息了

00:17:38.050 --> 00:17:43.510
只是说去给我所有的用户信息， 

00:17:41.020 --> 00:17:45.940
您正确获得所有用户信息

00:17:43.510 --> 00:17:47.860
您得到对象中的每个字段

00:17:45.940 --> 00:17:50.890
简而言之，就是嫁接

00:17:47.860 --> 00:17:53.799
你可以不必明确

00:17:50.890 --> 00:17:58.390
您要从哪个特定字段

00:17:53.799 --> 00:18:00.100
具体对象，现在实际上是

00:17:58.390 --> 00:18:02.799
故意有野外的事情

00:18:00.100 --> 00:18:05.200
卡获得所需的一切

00:18:02.799 --> 00:18:08.440
在一个字段中指定所需的每个字段

00:18:05.200 --> 00:18:12.490
模式中的图形QL对象

00:18:08.440 --> 00:18:15.309
这实际上是设计使然，而不是

00:18:12.490 --> 00:18:19.529
目的，所以此时您可能

00:18:15.309 --> 00:18:22.840
如果我们要去并得到

00:18:19.529 --> 00:18:25.059
每次我们都要输入每个字段

00:18:22.840 --> 00:18:27.100
想去得到它是一件好事

00:18:25.059 --> 00:18:29.590
还是反模式还是仅仅是

00:18:27.100 --> 00:18:32.559
不好，或者他只是准备离开而已

00:18:29.590 --> 00:18:34.450
保持良好休息的原因

00:18:32.559 --> 00:18:36.610
他们关灯了你还能吗

00:18:34.450 --> 00:18:38.110
在黑暗中看到我，好吗

00:18:36.610 --> 00:18:39.820
对，所以我不想站在那儿

00:18:38.110 --> 00:18:42.639
一直没事，所以这实际上是

00:18:39.820 --> 00:18:45.330
好东西，因为有一对

00:18:42.639 --> 00:18:47.860
它强制执行第一件事

00:18:45.330 --> 00:18:50.320
你只会得到你想要的

00:18:47.860 --> 00:18:51.639
所以你不会得到一切都说你

00:18:50.320 --> 00:18:54.220
有一个很大的东西，你

00:18:51.639 --> 00:18:56.409
暴露于宁静的端点

00:18:54.220 --> 00:18:58.570
不要去让一切都好

00:18:56.409 --> 00:19:00.429
这实际上是一件好事

00:18:58.570 --> 00:19:02.950
如您所见，还有图QL的另一件事

00:19:00.429 --> 00:19:04.990
以前是我可以去拿东西

00:19:02.950 --> 00:19:05.470
来自同一个中两个不相关的对象

00:19:04.990 --> 00:19:07.600
呼叫

00:19:05.470 --> 00:19:11.100
有时候，当您建造

00:19:07.600 --> 00:19:13.389
应用程序的前端，您

00:19:11.100 --> 00:19:14.799
需要两个不同的东西

00:19:13.389 --> 00:19:16.210
不同的地方，你会休息

00:19:14.799 --> 00:19:18.399
端点你怎么去得到那两个

00:19:16.210 --> 00:19:20.620
你要做两个不同的事情

00:19:18.399 --> 00:19:22.840
您必须回溯到API调用权

00:19:20.620 --> 00:19:25.149
到服务器，说我想要所有

00:19:22.840 --> 00:19:26.620
用户信息，现在我想要所有商品

00:19:25.149 --> 00:19:28.149
信息，但您必须使两个不同

00:19:26.620 --> 00:19:30.519
打电话，因为他们在两个不同的地方

00:19:28.149 --> 00:19:31.840
可以使用图QL的宁静端点

00:19:30.519 --> 00:19:37.360
只要打个电话就可以得到一切

00:19:31.840 --> 00:19:40.570
很好，所以这两个具体

00:19:37.360 --> 00:19:42.610
 QL图形在以下方面的功能

00:19:40.570 --> 00:19:44.500
胜于休息的优势是两件事

00:19:42.610 --> 00:19:47.380
我刚才说的第一件事是

00:19:44.500 --> 00:19:49.779
我们所谓的获取只是我想要的

00:19:47.380 --> 00:19:51.549
用户对象的这三个字段

00:19:49.779 --> 00:19:53.380
而不是其他十个领域

00:19:51.549 --> 00:19:55.899
在图QL中，您必须

00:19:53.380 --> 00:19:58.750
明确地说去获取我的用户信息

00:19:55.899 --> 00:19:59.710
去获取我的用户信息，然后去获取

00:19:58.750 --> 00:20:01.540
我这两件事

00:19:59.710 --> 00:20:03.610
好吧，休息吧

00:20:01.540 --> 00:20:05.710
这个问题被称为过度获取

00:20:03.610 --> 00:20:07.480
也动荡不安

00:20:05.710 --> 00:20:08.980
在获取下，我需要从

00:20:07.480 --> 00:20:10.690
星际飞船系列和

00:20:08.980 --> 00:20:12.790
物种收集，他们不是

00:20:10.690 --> 00:20:15.400
相关的，所以在休息时我必须去做一个

00:20:12.790 --> 00:20:17.530
呼唤我的飞船，呼唤我的飞船

00:20:15.400 --> 00:20:20.620
种，所以我打了两个电话

00:20:17.530 --> 00:20:22.090
因此，图QL通过

00:20:20.620 --> 00:20:24.760
让您获取不同

00:20:22.090 --> 00:20:27.280
同一查询内的集合即

00:20:24.760 --> 00:20:29.130
可以解决获取不足的问题

00:20:27.280 --> 00:20:33.310
这些是以下两个主要优点

00:20:29.130 --> 00:20:35.020
宁静端点上的图QL 

00:20:33.310 --> 00:20:37.330
另一件事是对于那些

00:20:35.020 --> 00:20:40.570
举起你的手谁是JavaScript 

00:20:37.330 --> 00:20:42.010
前端人员，您知道，当您

00:20:40.570 --> 00:20:43.810
拨打网络电话，您立即

00:20:42.010 --> 00:20:46.780
让网络呼叫您的嵌套两个

00:20:43.810 --> 00:20:48.460
网络通话以及JavaScript的增长

00:20:46.780 --> 00:20:50.410
那是异步的，所以你必须嵌套

00:20:48.460 --> 00:20:52.330
他们，你开始进入我们

00:20:50.410 --> 00:20:54.250
异步调用回调地狱

00:20:52.330 --> 00:20:55.660
尽你所能的环境和图形

00:20:54.250 --> 00:20:57.400
避免那样，因为你只是打电话

00:20:55.660 --> 00:21:00.040
从两个中得到两个不同的东西

00:20:57.400 --> 00:21:02.800
如果需要，可以使用不同的数据集

00:21:00.040 --> 00:21:05.980
就像我们能够去

00:21:02.800 --> 00:21:08.860
从两个不同的未连接获取

00:21:05.980 --> 00:21:10.600
我们也可以去更新两个对象

00:21:08.860 --> 00:21:13.510
同一网络中的未连接对象

00:21:10.600 --> 00:21:15.490
打电话，这是下的变化

00:21:13.510 --> 00:21:17.320
提取问题，我们可以使

00:21:15.490 --> 00:21:19.510
进行变异的图形调用查询

00:21:17.320 --> 00:21:22.390
这就是在图QL中被称为

00:21:19.510 --> 00:21:24.520
去改变里面的物体

00:21:22.390 --> 00:21:27.310
端点说去改变这个

00:21:24.520 --> 00:21:32.800
对象，并同时更改此

00:21:27.310 --> 00:21:34.660
其他对象还可以，所以抢QL是

00:21:32.800 --> 00:21:36.790
 quote-unquote更快，图QL为

00:21:34.660 --> 00:21:39.340
报价-取消报价的简单，现在我有

00:21:36.790 --> 00:21:41.530
引用，因为这不一定

00:21:39.340 --> 00:21:43.330
总是有这样的情况

00:21:41.530 --> 00:21:45.820
当图QL实际上比

00:21:43.330 --> 00:21:47.890
宁静的终点，有时

00:21:45.820 --> 00:21:50.590
生锈实际上比

00:21:47.890 --> 00:21:52.480
图QL端点，但通常为

00:21:50.590 --> 00:21:55.030
您正在构建并进行API设计

00:21:52.480 --> 00:21:57.790
您会发现整个图的质量QL 

00:21:55.030 --> 00:22:01.210
快一点，有时快很多

00:21:57.790 --> 00:22:06.040
比休息更快，也更简单，但是

00:22:01.210 --> 00:22:11.090
并不总是好的，让我们来谈谈

00:22:06.040 --> 00:22:14.660
通配符更正确一点

00:22:11.090 --> 00:22:17.870
它实际上很好的另一个原因

00:22:14.660 --> 00:22:19.940
对你具体要明确

00:22:17.870 --> 00:22:22.400
从端点得到说

00:22:19.940 --> 00:22:26.030
团队中有人在这里

00:22:22.400 --> 00:22:27.620
从对象右侧删除字段

00:22:26.030 --> 00:22:28.880
你当时没想到

00:22:27.620 --> 00:22:31.460
您正在与另一个团队合作，或者

00:22:28.880 --> 00:22:33.020
您正在前端工作，或者

00:22:31.460 --> 00:22:34.340
也许您是服务器端工程师， 

00:22:33.020 --> 00:22:36.890
你想开个玩笑

00:22:34.340 --> 00:22:39.890
前端工程师或其他合适的人

00:22:36.890 --> 00:22:42.800
如果删除字段，将发生什么情况

00:22:39.890 --> 00:22:45.530
休息就不再了

00:22:42.800 --> 00:22:48.260
正确，或者添加一个

00:22:45.530 --> 00:22:51.500
放在静止的物体上

00:22:48.260 --> 00:22:53.810
现在自动显示正确，因此

00:22:51.500 --> 00:22:56.920
如果我回去的话，现在有问题了

00:22:53.810 --> 00:23:00.860
到我的图形QL编辑器这里哦图形

00:22:56.920 --> 00:23:02.870
好吧，假设这个领域的成本

00:23:00.860 --> 00:23:05.270
抵免额已删除，或者我们只赚

00:23:02.870 --> 00:23:11.420
假设一个字段

00:23:05.270 --> 00:23:13.790
原行星从我们的

00:23:11.420 --> 00:23:16.700
现在后端，当我去运行此查询

00:23:13.790 --> 00:23:19.040
你会发现它给了我一些怪异

00:23:16.700 --> 00:23:20.660
反正因为某种原因还可以

00:23:19.040 --> 00:23:21.890
这里的重点是它实际上给

00:23:20.660 --> 00:23:25.490
你是一个错误，让我们实际尝试

00:23:21.890 --> 00:23:28.790
让我们摆脱这种简化的东西

00:23:25.490 --> 00:23:29.540
这有点我缺少括号

00:23:28.790 --> 00:23:31.040
还是九点谢谢

00:23:29.540 --> 00:23:34.070
好吧，让我们现在尝试那里，我们去谢谢

00:23:31.040 --> 00:23:36.140
好吧，所以我们说我们曾经

00:23:34.070 --> 00:23:37.700
我有一个叫做家星球的领域

00:23:36.140 --> 00:23:39.740
看看我在图上正在看什么

00:23:37.700 --> 00:23:41.570
图形，你可以看到它实际上说

00:23:39.740 --> 00:23:44.990
那但是如果我真的运行它，我们该怎么办

00:23:41.570 --> 00:23:47.120
得到我们实际上得到一个错误，所以如果我们

00:23:44.990 --> 00:23:49.640
有某种单位或整合

00:23:47.120 --> 00:23:52.880
测试多少人不写测试

00:23:49.640 --> 00:23:54.620
他们的软件还可以，有几个

00:23:52.880 --> 00:23:58.010
在那边的我赞扬你的风格

00:23:54.620 --> 00:24:00.110
我有一件T恤说我没有

00:23:58.010 --> 00:24:04.280
通常测试，但是当我测试时

00:24:00.110 --> 00:24:06.080
生产，没错，这是一个，这是一个

00:24:04.280 --> 00:24:10.430
无论如何，在会议上大获成功

00:24:06.080 --> 00:24:12.650
这是因为我们有一个模式

00:24:10.430 --> 00:24:14.150
该模式在某些方面是僵化的

00:24:12.650 --> 00:24:16.310
僵硬的词不是正确的词

00:24:14.150 --> 00:24:18.350
如果删除字段，定义非常好

00:24:16.310 --> 00:24:20.600
你会在前端得到一个错误

00:24:18.350 --> 00:24:22.400
您的图形QL查询将不再起作用

00:24:20.600 --> 00:24:23.810
因为它会给你这个错误

00:24:22.400 --> 00:24:24.620
服务器端将返回一些信息， 

00:24:23.810 --> 00:24:26.630
说我不知道​​感觉如何

00:24:24.620 --> 00:24:30.680
你说的还好，另一个

00:24:26.630 --> 00:24:32.840
这部分是当我们添加一个字段时

00:24:30.680 --> 00:24:34.820
我们可能不想去得到它

00:24:32.840 --> 00:24:38.120
现有的查询都可以，所以在我之前

00:24:34.820 --> 00:24:40.309
例如显示了这个电影连接

00:24:38.120 --> 00:24:42.470
在这里，这个电影联系可能

00:24:40.309 --> 00:24:44.390
就像一个很大的物体

00:24:42.470 --> 00:24:47.150
嵌入另一个对象的内部

00:24:44.390 --> 00:24:48.650
说服务器端工程师添加了新的

00:24:47.150 --> 00:24:50.360
有大量数据的领域

00:24:48.650 --> 00:24:52.070
在它后面，现在突然之间

00:24:50.360 --> 00:24:53.930
您刚刚想要的宁静端点

00:24:52.070 --> 00:24:55.820
用户信息，现在您正在

00:24:53.930 --> 00:24:58.220
整个商品目录或任何

00:24:55.820 --> 00:24:59.840
与此相关的领域

00:24:58.220 --> 00:25:02.410
不好，因为那会导致很大

00:24:59.840 --> 00:25:05.240
性能问题或其他问题

00:25:02.410 --> 00:25:06.380
实际上在字段中是明确的

00:25:05.240 --> 00:25:07.700
在那里和领域

00:25:06.380 --> 00:25:09.170
删除，感觉是添加的是

00:25:07.700 --> 00:25:12.260
实际上是一件好事，因为它

00:25:09.170 --> 00:25:19.880
实施良好的设计，实施良好的设计

00:25:12.260 --> 00:25:21.470
 API设计好了很多

00:25:19.880 --> 00:25:24.140
我们在休息时做的事情是

00:25:21.470 --> 00:25:25.760
就像魔术一样，我们走吧

00:25:24.140 --> 00:25:29.570
获取用户信息，让我们开始吧， 

00:25:25.760 --> 00:25:31.520
那无论如何我们是我们的一件事

00:25:29.570 --> 00:25:33.170
避免与图QL的图一起使用

00:25:31.520 --> 00:25:35.750
避免这种魔力

00:25:33.170 --> 00:25:37.970
具体我们正在做什么

00:25:35.750 --> 00:25:40.130
没有与通配符

00:25:37.970 --> 00:25:42.050
应用中断和明显的方式，我们不会

00:25:40.130 --> 00:25:43.970
过度获取可能会带来的新关系

00:25:42.050 --> 00:25:46.250
非常大，这非常重要

00:25:43.970 --> 00:25:47.960
是的，但您可能会想哦

00:25:46.250 --> 00:25:51.080
我必须忍受这种痛苦

00:25:47.960 --> 00:25:53.090
我想去的每个领域都得到

00:25:51.080 --> 00:25:55.400
该用户信息或项目对象，或

00:25:53.090 --> 00:25:57.710
无论它有20或30或50 

00:25:55.400 --> 00:25:59.900
里面的田野，如此痛苦

00:25:57.710 --> 00:26:01.640
一遍又一遍地打字

00:25:59.900 --> 00:26:03.020
我们可以做的就是可以使用

00:26:01.640 --> 00:26:05.990
所谓的碎片帮助

00:26:03.020 --> 00:26:07.220
缓解图QL中的所有疼痛

00:26:05.990 --> 00:26:09.650
片段看起来像什么

00:26:07.220 --> 00:26:11.660
说我们有类似用户的东西，所以我们

00:26:09.650 --> 00:26:13.700
将创建一个片段呼叫用户

00:26:11.660 --> 00:26:16.309
包含一些基本内容的片段

00:26:13.700 --> 00:26:18.020
我们想要获取的现场数据

00:26:16.309 --> 00:26:19.580
每次我们使用它，以便您可以看到我

00:26:18.020 --> 00:26:23.150
有一个片段叫做用户片段

00:26:19.580 --> 00:26:24.740
在这里，然后当我想去使用

00:26:23.150 --> 00:26:27.710
您可以在底部看到的用户片段

00:26:24.740 --> 00:26:30.380
我说用它来获取用户用户并

00:26:27.710 --> 00:26:31.940
然后我做点点用户片段

00:26:30.380 --> 00:26:33.890
使用该用户片段，然后您

00:26:31.940 --> 00:26:35.690
可以在不同的地方重用该片段

00:26:33.890 --> 00:26:36.950
你需要去的地方也一样

00:26:35.690 --> 00:26:38.470
每次都使用一组字段，这样您就不会

00:26:36.950 --> 00:26:42.340
必须把它们打出来

00:26:38.470 --> 00:26:44.200
再说一遍好吧，我们会

00:26:42.340 --> 00:26:46.150
稍后再讨论这个，但是我们该如何

00:26:44.200 --> 00:26:48.070
到目前为止，我们实际上一直在更改数据

00:26:46.150 --> 00:26:51.100
只花了两周的查询数据

00:26:48.070 --> 00:26:52.840
 QL图，这就是您要做的

00:26:51.100 --> 00:26:53.080
突变，我们将在一个

00:26:52.840 --> 00:26:54.429
分钟

00:26:53.080 --> 00:26:57.070
好吧，实际上我们要跳到我们的

00:26:54.429 --> 00:26:59.590
在这里编码并讨论图QL和

00:26:57.070 --> 00:27:01.270
 Java，因此有两个主要的库

00:26:59.590 --> 00:27:04.900
做的事情有一个叫做图QL 

00:27:01.270 --> 00:27:06.669
 Java是一个非常低级的库

00:27:04.900 --> 00:27:07.870
用于构建图很酷的东西

00:27:06.669 --> 00:27:10.480
一秒钟看看

00:27:07.870 --> 00:27:12.610
还有一个叫做图QL SPQR的图

00:27:10.480 --> 00:27:14.080
或发音明显的说话者

00:27:12.610 --> 00:27:16.090
图形库有点

00:27:14.080 --> 00:27:19.600
建立一个更复杂的

00:27:16.090 --> 00:27:21.159
图QL服务器，我喜欢图，所以我

00:27:19.600 --> 00:27:23.740
放在一起，向您展示如何

00:27:21.159 --> 00:27:25.330
你做图或做图

00:27:23.740 --> 00:27:27.340
杀死它或说出来的地方，这样就存根

00:27:25.330 --> 00:27:29.980
数据库或其他任何东西

00:27:27.340 --> 00:27:31.539
您仍然可以使用JDBC和JPA，然后

00:27:29.980 --> 00:27:33.520
你有图队列在上面

00:27:31.539 --> 00:27:35.980
使您的端点是您的

00:27:33.520 --> 00:27:38.140
客户实际上会使用ok和

00:27:35.980 --> 00:27:41.169
数据可能是正确的，所以

00:27:38.140 --> 00:27:43.960
我们将使用它只是一个H2 

00:27:41.169 --> 00:27:45.429
为该演示存储我们的DBMS，但可以

00:27:43.960 --> 00:27:47.440
做任何你可以暴露的东西

00:27:45.429 --> 00:27:48.970
文件系统（如果需要）还是

00:27:47.440 --> 00:27:52.390
有某种网络服务器，如果您

00:27:48.970 --> 00:27:54.549
有一个Redis服务器

00:27:52.390 --> 00:27:56.289
暂时性信息，如刚刚存储的

00:27:54.549 --> 00:27:57.909
在内存中，您可以通过

00:27:56.289 --> 00:27:59.200
图很酷，您可以暴露任何东西

00:27:57.909 --> 00:28:02.620
希望它不一定只是一个

00:27:59.200 --> 00:28:04.539
后面的数据库还可以，所以当我们

00:28:02.620 --> 00:28:06.429
定义一个API，我们可以包装任何东西

00:28:04.539 --> 00:28:08.289
你想好吧，那是伟大的之一

00:28:06.429 --> 00:28:09.150
关于图队列的事情再次让我们

00:28:08.289 --> 00:28:12.460
进入我们的演示

00:28:09.150 --> 00:28:13.750
大约21分钟怎么办，我要加快速度

00:28:12.460 --> 00:28:16.299
事情有点，这是我们的

00:28:13.750 --> 00:28:18.610
第一次演示在这里，所以在这个

00:28:16.299 --> 00:28:20.500
只是使用标准图QL Java 

00:28:18.610 --> 00:28:21.820
 API，所以我们需要几个

00:28:20.500 --> 00:28:25.090
不同的事情，但让我们开始

00:28:21.820 --> 00:28:27.820
我们的域对象，以便您可以看到我有

00:28:25.090 --> 00:28:31.270
我的蚂蚁身份，这就是

00:28:27.820 --> 00:28:32.650
标准的JPA，这是我的注释

00:28:31.270 --> 00:28:36.510
对于所有这些不同的事情都可以

00:28:32.650 --> 00:28:40.710
标准实体对象书和作者

00:28:36.510 --> 00:28:45.520
好，所以我们有两个不同

00:28:40.710 --> 00:28:48.730
注释或实体在这里可以

00:28:45.520 --> 00:28:51.100
确保正确，每本书都有

00:28:48.730 --> 00:28:52.929
作者，所以我们说这是我们的作者

00:28:51.100 --> 00:28:56.980
关系

00:28:52.929 --> 00:28:59.140
从书中，这些只是标准

00:28:56.980 --> 00:29:00.640
仓库，所以您可能会猜到

00:28:59.140 --> 00:29:03.490
如果我打开这个，这是什么

00:29:00.640 --> 00:29:05.080
只是一个原始库，再一次

00:29:03.490 --> 00:29:08.020
卡存储库来自每个人

00:29:05.080 --> 00:29:11.080
熟悉Spring数据存储库

00:29:08.020 --> 00:29:13.740
就像JPN信用库一样，是的

00:29:11.080 --> 00:29:15.580
我最主要的意思是这是春季会议

00:29:13.740 --> 00:29:17.050
好，只要确保

00:29:15.580 --> 00:29:18.640
所以你可能知道这是什么

00:29:17.050 --> 00:29:20.590
不会花任何时间在正确的地方

00:29:18.640 --> 00:29:24.970
我想花时间去让我们

00:29:20.590 --> 00:29:26.530
看一下实际的应用

00:29:24.970 --> 00:29:27.640
我们有这是一个空气处理器

00:29:26.530 --> 00:29:29.380
看看这个空气处理器

00:29:27.640 --> 00:29:30.640
第二，但是你可以看看我们是否在这里

00:29:29.380 --> 00:29:33.190
这是标准的 spring boot 

00:29:30.640 --> 00:29:35.200
应用程序就可以了，现在我

00:29:33.190 --> 00:29:38.080
在这里定义了几个豆书

00:29:35.200 --> 00:29:40.300
解析器查询解析器的一个突变

00:29:38.080 --> 00:29:42.340
解析器，这只是一个命令行

00:29:40.300 --> 00:29:43.600
亚军进行一些测试，但让我们

00:29:42.340 --> 00:29:44.800
去看看这些

00:29:43.600 --> 00:29:47.410
同样，这些只是他们得到的豆子

00:29:44.800 --> 00:29:50.400
注入到我们的图QL服务器中

00:29:47.410 --> 00:29:53.440
让我们从查询开始，我们将

00:29:50.400 --> 00:29:55.360
这样的存储库，我们发现

00:29:53.440 --> 00:29:57.520
所有书籍，找到所有作者， 

00:29:55.360 --> 00:29:59.620
去查询存储库，我们

00:29:57.520 --> 00:30:01.780
有书本和作者数没关系

00:29:59.620 --> 00:30:04.510
所以我们的查询基本上实现了这个

00:30:01.780 --> 00:30:06.190
图QL图QL查询解决我们

00:30:04.510 --> 00:30:08.559
对象，所以这是当您使用

00:30:06.190 --> 00:30:11.200
这个特定的库，这是条目

00:30:08.559 --> 00:30:13.420
点为我们的图QL服务器，所以我们

00:30:11.200 --> 00:30:15.640
基本上创建这个查询对象

00:30:13.420 --> 00:30:18.429
实现图QL赛跑者或遗憾

00:30:15.640 --> 00:30:21.550
图QL解析器，我们去定义

00:30:18.429 --> 00:30:23.050
这些具体的操作要去看看

00:30:21.550 --> 00:30:24.490
在这一点上，让我们开始

00:30:23.050 --> 00:30:26.650
命令行确保它可以正常工作

00:30:24.490 --> 00:30:27.220
认为我已经可以运行了

00:30:26.650 --> 00:30:30.400
大

00:30:27.220 --> 00:30:32.050
所以我们进入这里，让我们开始吧

00:30:30.400 --> 00:30:34.000
很快就可以数书了，所以你

00:30:32.050 --> 00:30:35.850
可以看到我们这里有一本书

00:30:34.000 --> 00:30:39.870
现在我要评论一下

00:30:35.850 --> 00:30:42.130
现在我要去寻找所有像这样的书

00:30:39.870 --> 00:30:43.840
让我们运行它，你可以看到我

00:30:42.130 --> 00:30:46.450
目前在我们的数据库中有一本书

00:30:43.840 --> 00:30:50.710
如果我们还记得找到所有的书和

00:30:46.450 --> 00:30:52.210
数书籍并进入我们的查询类

00:30:50.710 --> 00:30:54.190
实现图形查询

00:30:52.210 --> 00:30:56.830
解析器，您可以看到我已找到所有书籍

00:30:54.190 --> 00:30:59.200
查找所有作者数书数

00:30:56.830 --> 00:31:00.490
作者，所以如果我更改，如果我要

00:30:59.200 --> 00:31:02.500
从查找所有书籍更改为查找

00:31:00.490 --> 00:31:05.320
作者，它将返回还可以，但

00:31:02.500 --> 00:31:07.090
让我们来看一下解决方法

00:31:05.320 --> 00:31:09.399
真的很快，什么是解析器

00:31:07.090 --> 00:31:11.440
看起来像是iBook解析器实现

00:31:09.399 --> 00:31:13.120
图QL解析器，您可以看到

00:31:11.440 --> 00:31:16.269
在引擎盖下面

00:31:13.120 --> 00:31:17.950
并获取作者存储库和

00:31:16.269 --> 00:31:20.799
我们需要此解析器的原因是

00:31:17.950 --> 00:31:24.009
因为我们的书有关系

00:31:20.799 --> 00:31:26.980
到我们希望暴露的另一个对象

00:31:24.009 --> 00:31:28.750
通过图QL称为作者，所以我们

00:31:26.980 --> 00:31:31.960
必须设置此解析器

00:31:28.750 --> 00:31:35.070
在我们的查询中或查找所有书籍

00:31:31.960 --> 00:31:38.590
可以去找出那个地方

00:31:35.070 --> 00:31:42.039
底层包含的对象是正确的， 

00:31:38.590 --> 00:31:44.080
如果我们想保存一个作者，我们会

00:31:42.039 --> 00:31:47.309
创建一个实现图的变异

00:31:44.080 --> 00:31:49.330
 QL突变解析器，然后运行

00:31:47.309 --> 00:31:52.149
揭露一本叫做新书的东西

00:31:49.330 --> 00:31:54.389
如果我再次来到这里，让我

00:31:52.149 --> 00:31:59.679
我只是将其注释掉，现在写

00:31:54.389 --> 00:32:02.049
评论一下，如果我要来

00:31:59.679 --> 00:32:05.230
在这里说一遍又叫什么

00:32:02.049 --> 00:32:07.029
你的书没错，所以我会很懒

00:32:05.230 --> 00:32:13.870
只是说你那是不对的

00:32:07.029 --> 00:32:15.370
发生这种情况哦，我想我的命令键

00:32:13.870 --> 00:32:17.830
卡住了，好，我要跳过该演示

00:32:15.370 --> 00:32:18.940
现在，但是无论如何，这就是我们要做的

00:32:17.830 --> 00:32:22.059
现在我不想花太多时间

00:32:18.940 --> 00:32:24.389
在此上，因为这对

00:32:22.059 --> 00:32:26.019
像底层API一样进行构建

00:32:24.389 --> 00:32:27.909
不幸的是，有很多工作

00:32:26.019 --> 00:32:30.309
需要做的所有事情之一

00:32:27.909 --> 00:32:32.919
我们使用弹簧的原因以及诸如此类的东西

00:32:30.309 --> 00:32:34.600
带有注释和CDI的微资料

00:32:32.919 --> 00:32:36.730
而所有这些事情是因为我们不

00:32:34.600 --> 00:32:38.830
想写所有我们想要的代码

00:32:36.730 --> 00:32:41.230
花费与编写代码一样少的时间

00:32:38.830 --> 00:32:43.450
尽可能多的人喜欢

00:32:41.230 --> 00:32:45.820
用任何人的方式写很多代码

00:32:43.450 --> 00:32:47.350
知道为什么我们不喜欢写很多

00:32:45.820 --> 00:32:49.629
代码，因为您要编写的代码更多

00:32:47.350 --> 00:32:51.309
您必须测试的代码越多， 

00:32:49.629 --> 00:32:53.590
更多代码可能存在错误，并且

00:32:51.309 --> 00:32:55.059
正确分解，这就是为什么我们喜欢

00:32:53.590 --> 00:32:58.419
使用spring，因为我们可以减少写

00:32:55.059 --> 00:33:00.759
代码，所以我更喜欢这样做的库

00:32:58.419 --> 00:33:03.009
您执行此操作称为图QL扬声器

00:33:00.759 --> 00:33:04.690
它使用注释，以便我们拥有

00:33:03.009 --> 00:33:07.450
少写这种

00:33:04.690 --> 00:33:08.919
样板和更少的仪式要做

00:33:07.450 --> 00:33:11.980
这种东西，让我们快速

00:33:08.919 --> 00:33:16.960
看看另一个使用的示例项目

00:33:11.980 --> 00:33:19.210
另一个图书馆好吧，让我们开始

00:33:16.960 --> 00:33:21.190
与我们的基本目标，在这种情况下

00:33:19.210 --> 00:33:23.049
因为我真的不想写

00:33:21.190 --> 00:33:26.200
这个项目中的代码我正在使用什么

00:33:23.049 --> 00:33:27.820
叫做Project Lombok，您可以看到

00:33:26.200 --> 00:33:30.340
在这里进口但是它给了我

00:33:27.820 --> 00:33:31.600
这样的注释，所以我不必

00:33:30.340 --> 00:33:33.039
写所有的getter和setter 

00:33:31.600 --> 00:33:34.630
所有这些东西，多少人使用

00:33:33.039 --> 00:33:36.760
龙目岛项目在这里如何携带

00:33:34.630 --> 00:33:37.929
好的，那是我想每个人的

00:33:36.760 --> 00:33:40.510
手上升了，所以我不会解释

00:33:37.929 --> 00:33:44.529
好的，但是你可以看到我有我的

00:33:40.510 --> 00:33:48.399
实体对象在这里，然后我在

00:33:44.529 --> 00:33:50.470
图QL查询名称是ID描述

00:33:48.399 --> 00:33:53.200
等等等等私人长ID图

00:33:50.470 --> 00:33:54.760
很酷的查询名称等等等等等等

00:33:53.200 --> 00:33:56.350
不必写那些

00:33:54.760 --> 00:33:58.390
解析器和其他类似的东西

00:33:56.350 --> 00:34:00.100
基本上只是在

00:33:58.390 --> 00:34:03.250
领域，说这个领域现在

00:34:00.100 --> 00:34:06.429
可查询的权利，这很好，让我们

00:34:03.250 --> 00:34:08.859
我现在必须要做的工作

00:34:06.429 --> 00:34:13.510
汽车服务在这里没什么花哨的，但我

00:34:08.859 --> 00:34:17.020
已经通过身份证获得汽车，这就是那里

00:34:13.510 --> 00:34:19.300
在这里我说去，允许这件事

00:34:17.020 --> 00:34:22.320
可以查询，现在如果我上车

00:34:19.300 --> 00:34:26.080
我的车像这样的服务

00:34:22.320 --> 00:34:28.240
好吧，我可以说按ID名称ID取车

00:34:26.080 --> 00:34:30.940
等从存储库中顺利进行

00:34:28.240 --> 00:34:33.399
反对那辆车，你也可以看到

00:34:30.940 --> 00:34:35.589
它带有工艺QL查询的注释

00:34:33.399 --> 00:34:38.260
汽车，所以这是我们的路线入口点

00:34:35.589 --> 00:34:40.690
进入汽车对象，但我也

00:34:38.260 --> 00:34:42.520
定义了一个称为添加图QL的突变

00:34:40.690 --> 00:34:44.440
突变的名称是

00:34:42.520 --> 00:34:45.700
汽车 Vault 正确，所以它可以

00:34:44.440 --> 00:34:49.540
与实际名称不同

00:34:45.700 --> 00:34:51.339
我想要的方法，它接受一个类型

00:34:49.540 --> 00:34:52.899
这辆特定的汽车，您可以看到

00:34:51.339 --> 00:34:54.970
这里有一些额外的注释

00:34:52.899 --> 00:34:56.589
我称基础图为QL 

00:34:54.970 --> 00:34:58.960
仓库让我们去运行这个确保

00:34:56.589 --> 00:35:03.130
它真的很有效，好的，让我们退出

00:34:58.960 --> 00:35:08.619
在这里做一个 spring boot 

00:35:03.130 --> 00:35:11.500
真正的快速看看这是否正常

00:35:08.619 --> 00:35:13.030
来建立数据库， 

00:35:11.500 --> 00:35:14.530
一切，所以可能需要一秒钟， 

00:35:13.030 --> 00:35:15.940
你可以看到我只是在注入一些

00:35:14.530 --> 00:35:18.880
我们可以玩的初始值

00:35:15.940 --> 00:35:22.599
好的，让我们再回到我们的

00:35:18.880 --> 00:35:24.070
图形只是做一个重载，哎呀我

00:35:22.599 --> 00:35:24.460
以为我跑了那个我不是故意的突变

00:35:24.070 --> 00:35:27.010
要做到这一点

00:35:24.460 --> 00:35:30.250
好吧，让我们去看看我们的车， 

00:35:27.010 --> 00:35:30.820
让我们确保这有效哦谢谢

00:35:30.250 --> 00:35:31.850
天哪

00:35:30.820 --> 00:35:34.700
好

00:35:31.850 --> 00:35:35.780
但是如果您记得从此输出中

00:35:34.700 --> 00:35:38.210
就在这儿

00:35:35.780 --> 00:35:40.670
我只是为了测试我插入了这个

00:35:38.210 --> 00:35:42.590
进入我们的内存数据库

00:35:40.670 --> 00:35:45.170
捷豹保时捷等等等等等等等等

00:35:42.590 --> 00:35:49.130
所以看起来我有九件事，所以我

00:35:45.170 --> 00:35:51.230
如果我们现在应该在这里有九辆车

00:35:49.130 --> 00:35:53.420
很快地回到我们的代码，我们

00:35:51.230 --> 00:35:54.770
打电话给汽车，所以这是

00:35:53.420 --> 00:35:57.680
我实际引用的名称

00:35:54.770 --> 00:35:59.810
在这里四辆车对不起我

00:35:57.680 --> 00:36:02.630
正在获取汽车列表，所以图QL 

00:35:59.810 --> 00:36:05.140
查询名称基本等于汽车

00:36:02.630 --> 00:36:06.350
在我们的服务器上运行这一行代码

00:36:05.140 --> 00:36:08.600
好的

00:36:06.350 --> 00:36:10.190
现在关于这个的伟大的事情是

00:36:08.600 --> 00:36:12.110
我们只是去注释事物并说

00:36:10.190 --> 00:36:14.180
这是我的车的入口

00:36:12.110 --> 00:36:17.260
反对什么给了我汽车清单

00:36:14.180 --> 00:36:20.870
这是我在这里乘车的车

00:36:17.260 --> 00:36:22.790
忘记了一辆特定的汽车，因为我们

00:36:20.870 --> 00:36:25.550
在Java中具有强大的输入能力， 

00:36:22.790 --> 00:36:28.880
东西在那里，我们基本上是图QL 

00:36:25.550 --> 00:36:30.980
模式是为我们自动生成的

00:36:28.880 --> 00:36:32.930
将这些注释插入

00:36:30.980 --> 00:36:34.550
合适的地方，真的很好

00:36:32.930 --> 00:36:39.800
这意味着我们要做的工作更少

00:36:34.550 --> 00:36:42.410
再一次，我们得到了这个不错的API浏览器

00:36:39.800 --> 00:36:44.480
称为图形图形，我们可以去

00:36:42.410 --> 00:36:46.310
在这里浏览文档，所以我们可以说

00:36:44.480 --> 00:36:49.040
去看看查询的入口点， 

00:36:46.310 --> 00:36:53.060
这是汽车，其中包含一种

00:36:49.040 --> 00:36:56.110
汽车，而该汽车的网址URL ID是

00:36:53.060 --> 00:36:59.750
很酷的名字，所以如果我回到我的代码

00:36:56.110 --> 00:37:02.390
您可以看到我们还有一些其他功能

00:36:59.750 --> 00:37:06.050
有趣的东西在哪里

00:37:02.390 --> 00:37:11.810
这个礼品费网址在哪里

00:37:06.050 --> 00:37:15.770
从嗯好吧，所以不在我的车里

00:37:11.810 --> 00:37:18.140
对象，所以它在哪里

00:37:15.770 --> 00:37:20.390
礼物费网址，如果您还记得我

00:37:18.140 --> 00:37:23.120
说之前的图QL只是一个

00:37:20.390 --> 00:37:26.900
建立API的规范

00:37:23.120 --> 00:37:28.850
我们必须将API建立为

00:37:26.900 --> 00:37:32.450
开发人员，在这种情况下，我是

00:37:28.850 --> 00:37:34.940
我正在使用我的汽车实体对象

00:37:32.450 --> 00:37:37.190
作为基础，假设基础对象

00:37:34.940 --> 00:37:42.380
然后我可以随机添加一些

00:37:37.190 --> 00:37:44.820
如果我想好吧就废话吧，走吧

00:37:42.380 --> 00:37:48.300
在此代码库中搜索Q 

00:37:44.820 --> 00:37:51.840
到URL，这是怎么回事

00:37:48.300 --> 00:37:53.730
希望我可以输入giffy URL好的

00:37:51.840 --> 00:37:55.980
有一种叫做吉菲的服务

00:37:53.730 --> 00:37:59.130
这是这个字符串，好吧，好吧

00:37:55.980 --> 00:38:01.920
让我们去这里，现在我又在

00:37:59.130 --> 00:38:04.470
好的汽车服务，所以如果我在这里放大

00:38:01.920 --> 00:38:06.450
你可以看到我现在在开车

00:38:04.470 --> 00:38:08.010
如果我向下滚动一点，您可以

00:38:06.450 --> 00:38:10.260
看到我有这个东西叫给免费

00:38:08.010 --> 00:38:15.030
网址不错，所以我实际上在做什么

00:38:10.260 --> 00:38:18.690
我是说在上下文中

00:38:15.030 --> 00:38:20.610
这个汽车对象去添加一个额外的

00:38:18.690 --> 00:38:23.130
不属于该实际部分的字段

00:38:20.610 --> 00:38:25.230
我们基本上只是添加的实体

00:38:23.130 --> 00:38:27.720
如果您愿意的话，它就像动态地一样

00:38:25.230 --> 00:38:29.880
 QL中查询机制的说明

00:38:27.720 --> 00:38:31.620
所以我们说去得到给你的RL 

00:38:29.880 --> 00:38:33.120
对，这在做什么

00:38:31.620 --> 00:38:35.460
引擎盖下面是使用这个

00:38:33.120 --> 00:38:37.470
轻薄的服务，使

00:38:35.460 --> 00:38:40.290
打电话给吉菲，让我们回到

00:38:37.470 --> 00:38:42.860
实际的网址，我不需要显示

00:38:40.290 --> 00:38:45.840
部分，但重点是

00:38:42.860 --> 00:38:48.060
这是我们不只是简单地包装一个罪过

00:38:45.840 --> 00:38:49.710
实体对象或只是Java类或

00:38:48.060 --> 00:38:51.630
我们可以做的是

00:38:49.710 --> 00:38:55.620
实际上只是添加一些东西

00:38:51.630 --> 00:38:58.470
在这种情况下，我去打电话给

00:38:55.620 --> 00:39:00.960
礼貌的服务在这里，我去， 

00:38:58.470 --> 00:39:04.290
将该数据附加到该实际对象

00:39:00.960 --> 00:39:06.660
在这个汽车服务的运行时间还可以

00:39:04.290 --> 00:39:08.970
只是一个演示而已

00:39:06.660 --> 00:39:12.120
非常灵活，您可以进行各种操作

00:39:08.970 --> 00:39:14.700
疯狂甚至有用的东西

00:39:12.120 --> 00:39:17.040
建立这个API，让我们回到

00:39:14.700 --> 00:39:18.810
我们的API浏览器在这里，您可以看到

00:39:17.040 --> 00:39:21.630
我们有这些精美的网址以及所有内容

00:39:18.810 --> 00:39:23.610
好的，现在我们要添加一辆车

00:39:21.630 --> 00:39:26.640
好吧，让我们走吧，我要

00:39:23.610 --> 00:39:28.890
现在就注释掉这个吧

00:39:26.640 --> 00:39:31.950
我们去加点好吧，我是

00:39:28.890 --> 00:39:34.020
要说变异保存汽车特斯拉模型

00:39:31.950 --> 00:39:34.800
特斯拉3刚刚问世

00:39:34.020 --> 00:39:37.860
一会儿我们将其添加

00:39:34.800 --> 00:39:39.330
 ID名称等确定，因此ID将自动

00:39:37.860 --> 00:39:42.120
生成的我们必须提供一个名称

00:39:39.330 --> 00:39:42.990
我们在这里做的就是车： 

00:39:42.120 --> 00:39:45.540
名称 ： 

00:39:42.990 --> 00:39:47.820
现在让我们来看一下这件事

00:39:45.540 --> 00:39:51.810
我们去这里找救车好吧

00:39:47.820 --> 00:39:54.210
让我们去保存汽车哦，这是保存

00:39:51.810 --> 00:39:56.550
汽车，你会看到它需要一辆汽车

00:39:54.210 --> 00:39:57.869
但它希望将其包裹在里面

00:39:56.550 --> 00:40:00.420
某种汽车

00:39:57.869 --> 00:40:02.190
容器thingamajig，我们通过了

00:40:00.420 --> 00:40:06.269
进入这里好吧，让我们开始吧

00:40:02.190 --> 00:40:09.539
真的很快就可以了，所以我们得到了

00:40:06.269 --> 00:40:12.200
数据返回，如果正确又一次

00:40:09.539 --> 00:40:14.190
突变是我们做出改变的方式，或者

00:40:12.200 --> 00:40:15.450
本质上是做更新

00:40:14.190 --> 00:40:17.759
或者如果您想用术语思考

00:40:15.450 --> 00:40:19.529
现在你可以看到这是续集

00:40:17.759 --> 00:40:23.069
我花了第二个理由

00:40:19.529 --> 00:40:24.869
分钟是因为我没有所有

00:40:23.069 --> 00:40:26.489
太平洋所需的数据

00:40:24.869 --> 00:40:28.410
通话权

00:40:26.489 --> 00:40:31.619
我没有什么数据

00:40:28.410 --> 00:40:33.690
包含在实体对象中的吉普赛人

00:40:31.619 --> 00:40:34.920
网址正是这样，这就是为什么我选择了

00:40:33.690 --> 00:40:36.869
第二，因为服务器实际上

00:40:34.920 --> 00:40:39.869
值得庆幸的是，互联网是

00:40:36.869 --> 00:40:41.369
在我的笔记本电脑上工作就可以了

00:40:39.869 --> 00:40:43.289
在去插入那个，我们在

00:40:41.369 --> 00:40:44.759
实际获取这些数据

00:40:43.289 --> 00:40:48.059
不得不不得不去叫这个

00:40:44.759 --> 00:40:49.920
去做的软弱的服务和

00:40:48.059 --> 00:40:52.200
您可以看到这正在构建一个HTTP 

00:40:49.920 --> 00:40:54.269
它实际上伸出手给的客户

00:40:52.200 --> 00:40:59.069
他将数据取回并附加到

00:40:54.269 --> 00:41:00.690
该特定对象还可以，所以

00:40:59.069 --> 00:41:03.210
我们做了那个特定的事情意味着让我们

00:41:00.690 --> 00:41:07.140
只是仔细检查，我们是否对

00:41:03.210 --> 00:41:08.489
是的，我只是想看看

00:41:07.140 --> 00:41:12.319
他拉回什么样的礼物

00:41:08.489 --> 00:41:15.900
特斯拉好吗

00:41:12.319 --> 00:41:18.440
也许这部分代码需要一些

00:41:15.900 --> 00:41:21.410
工作，但无论如何您都会得到正确的想法

00:41:18.440 --> 00:41:24.839
同样，我们在这里还有其他东西

00:41:21.410 --> 00:41:27.809
另一种静态井不会消失

00:41:24.839 --> 00:41:29.549
上网很酷，所以

00:41:27.809 --> 00:41:32.369
再次，如果我们回到浏览器，您

00:41:29.549 --> 00:41:35.789
可以看到所有这些车都很棒

00:41:32.369 --> 00:41:37.109
不酷或其中一些很酷，但我们

00:41:35.789 --> 00:41:39.390
去，基本上就像

00:41:37.109 --> 00:41:41.309
静态设置还是可以的，但是无论如何

00:41:39.390 --> 00:41:43.410
这里的重点是我们的方式

00:41:41.309 --> 00:41:45.539
可以建立一个API非常灵活

00:41:43.410 --> 00:41:47.759
而且因为我们有这个漂亮的图书馆

00:41:45.539 --> 00:41:50.039
像图QL扬声器一样，我们可以建立

00:41:47.759 --> 00:41:51.569
不用走很快就能出去

00:41:50.039 --> 00:41:52.890
并添加很多样板并具有

00:41:51.569 --> 00:41:55.109
我们可以使用额外的类

00:41:52.890 --> 00:41:56.640
注释来构建一切，如果

00:41:55.109 --> 00:41:59.069
我们有兴趣看看这一切

00:41:56.640 --> 00:42:00.390
在一起，让我们快速

00:41:59.069 --> 00:42:03.989
看一下井，让我们从顶部开始

00:42:00.390 --> 00:42:06.299
这是我们的图酷网站配置所有

00:42:03.989 --> 00:42:09.580
对，所以如果我们去看看这个

00:42:06.299 --> 00:42:12.820
我们正在做的是我们正在使用弹簧

00:42:09.580 --> 00:42:15.760
 Web NBC在这里配置我们

00:42:12.820 --> 00:42:18.280
说这是我们要添加的额外费用

00:42:15.760 --> 00:42:20.500
查看图形图形

00:42:18.280 --> 00:42:22.510
我一直在使用的图形用户界面

00:42:20.500 --> 00:42:25.240
只是为了演示这只是一个jar文件

00:42:22.510 --> 00:42:27.820
如果您将该jar文件放入图表中

00:42:25.240 --> 00:42:30.190
 QL服务器应用程序我们可以很轻松地

00:42:27.820 --> 00:42:32.470
这样暴露它，以便我们拥有这个

00:42:30.190 --> 00:42:34.330
当然也要测试端点

00:42:32.470 --> 00:42:36.730
我们必须有一个索引点HTML 

00:42:34.330 --> 00:42:38.260
是前端代码或其他什么，但我们

00:42:36.730 --> 00:42:41.800
可以在这个特定的位置

00:42:38.260 --> 00:42:45.340
好吧，如果我在这里放大，你可以

00:42:41.800 --> 00:42:47.470
看到我要去斜线

00:42:45.340 --> 00:42:49.990
图形QL，这就是我们设置该部分的方式

00:42:47.470 --> 00:42:51.280
在这里好，再一次，你只是

00:42:49.990 --> 00:42:54.940
我们必须放入一个jar文件

00:42:51.280 --> 00:42:55.540
我们将XML下移，然后向上滚动

00:42:54.940 --> 00:43:00.400
在某处

00:42:55.540 --> 00:43:02.260
我希望它在这里

00:43:00.400 --> 00:43:05.580
对，所以实际上它嵌入了里面

00:43:02.260 --> 00:43:08.590
图QL扬声器库

00:43:05.580 --> 00:43:09.940
设置起来很容易，让我们

00:43:08.590 --> 00:43:12.340
最后，快速浏览一下

00:43:09.940 --> 00:43:14.800
图形控制器，所以我们要做的是

00:43:12.340 --> 00:43:17.410
说初始化一个新的图形模式

00:43:14.800 --> 00:43:19.720
生成器，并且该类再次来自

00:43:17.410 --> 00:43:22.480
我们的图QL扬声器库右右

00:43:19.720 --> 00:43:24.550
在这里，我们会说使用这些解析器

00:43:22.480 --> 00:43:26.470
建立一个新的注释解析器

00:43:24.550 --> 00:43:29.080
并扫描课程路径，找到那些

00:43:26.470 --> 00:43:31.030
注释使用此操作

00:43:29.080 --> 00:43:33.340
服务正确，所以您看到了汽车服务

00:43:31.030 --> 00:43:35.740
在创建价值图或工厂之前

00:43:33.340 --> 00:43:37.270
这只是为了杰克逊

00:43:35.740 --> 00:43:40.210
创建这些代码行的架构

00:43:37.270 --> 00:43:43.030
然后创建我们的图QL模式

00:43:40.210 --> 00:43:44.800
动态地确定，所以我们甚至不必

00:43:43.030 --> 00:43:45.280
去做任何硬编码或

00:43:44.800 --> 00:43:46.960
随你

00:43:45.280 --> 00:43:48.670
现在我没有显示这个，但是我做了

00:43:46.960 --> 00:43:50.140
想快速提起您不

00:43:48.670 --> 00:43:51.460
必须用代码构建一切

00:43:50.140 --> 00:43:53.800
这样，您实际上可以做的是

00:43:51.460 --> 00:43:56.290
这是从上一个示例中使用的

00:43:53.800 --> 00:43:57.790
低级图QL Java库全部

00:43:56.290 --> 00:44:02.950
对，我们实际上可以去写出来

00:43:57.790 --> 00:44:05.110
使用图QL的实际模式

00:44:02.950 --> 00:44:08.290
模式格式，这是正确的东西

00:44:05.110 --> 00:44:10.830
在这里或者如果您像我一样懒

00:44:08.290 --> 00:44:13.300
只是说你知道我要去

00:44:10.830 --> 00:44:15.670
我要去注释我所有的东西

00:44:13.300 --> 00:44:16.960
这样的东西，你去建立一个

00:44:15.670 --> 00:44:19.390
为我设计模式，因为我不想做

00:44:16.960 --> 00:44:21.610
好的，无论如何，我们建立了

00:44:19.390 --> 00:44:23.010
模式，我们从中创建一个新的图QL 

00:44:21.610 --> 00:44:24.630
该模式

00:44:23.010 --> 00:44:27.990
这是我们的斜线发布映射

00:44:24.630 --> 00:44:29.730
工艺QL端点，其余的是

00:44:27.990 --> 00:44:32.340
我们说相对简单

00:44:29.730 --> 00:44:35.970
图QL模式去执行

00:44:32.340 --> 00:44:37.710
基于输入的新查询

00:44:35.970 --> 00:44:41.310
提供好的，这就是我们的方式

00:44:37.710 --> 00:44:46.680
在Java中使用此图QL服务器

00:44:41.310 --> 00:44:47.910
好的特定库，所以让我们

00:44:46.680 --> 00:44:49.830
确保我们已经涵盖了这里的所有内容

00:44:47.910 --> 00:44:50.820
我想我们要跳过

00:44:49.830 --> 00:44:55.650
这些幻灯片，我只有一对

00:44:50.820 --> 00:44:58.830
分钟，但使用任一图表

00:44:55.650 --> 00:45:01.020
 QL图形QL Java库或

00:44:58.830 --> 00:45:03.270
图形扬声器，您可以建立一个

00:45:01.020 --> 00:45:05.190
像我们在这里使用图QL服务器

00:45:03.270 --> 00:45:07.740
 spring boot 或如果您使用微型轮廓

00:45:05.190 --> 00:45:09.570
您可以使用微资料或其他任何内容

00:45:07.740 --> 00:45:12.960
对，实际上您可能已经注意到

00:45:09.570 --> 00:45:16.200
早在其中之一

00:45:12.960 --> 00:45:19.380
如果哪一个是正确的应用

00:45:16.200 --> 00:45:21.420
你也想建立一些东西

00:45:19.380 --> 00:45:23.310
只是从命令行运行

00:45:21.420 --> 00:45:27.240
可以看到你有任何人写过

00:45:23.310 --> 00:45:29.100
 Spring命令行应用程序在任何人之前

00:45:27.240 --> 00:45:30.800
很少有人，这只是一个

00:45:29.100 --> 00:45:32.940
标准弹簧命令行运行器

00:45:30.800 --> 00:45:36.840
对象，因此您实际上可以编写一个

00:45:32.940 --> 00:45:39.960
图QL像程序我不是服务器

00:45:36.840 --> 00:45:43.920
在这种情况下，只需再次

00:45:39.960 --> 00:45:48.410
好的使用这个库，让我们回去

00:45:43.920 --> 00:45:50.460
回到这里，回到幻灯片吧

00:45:48.410 --> 00:45:51.540
我们已经涵盖了您几乎所有的一切

00:45:50.460 --> 00:45:54.660
需要知道，但有几个

00:45:51.540 --> 00:45:56.310
我们没有涵盖的事情

00:45:54.660 --> 00:45:58.670
认证和授权示例

00:45:56.310 --> 00:46:00.900
您如何针对图QL做到这一点

00:45:58.670 --> 00:46:02.970
不幸的是我们没有时间

00:46:00.900 --> 00:46:05.310
进入所有的东西，但你可以找到

00:46:02.970 --> 00:46:07.140
一些例子，带你走

00:46:05.310 --> 00:46:09.240
通过设置身份验证和

00:46:07.140 --> 00:46:11.520
授权不是很难

00:46:09.240 --> 00:46:13.860
这就是您期望的，我们也

00:46:11.520 --> 00:46:15.660
没有太多的功能细节

00:46:13.860 --> 00:46:16.980
就像分页一样，我向你展示了

00:46:15.660 --> 00:46:20.030
可以得到第一个或第一个

00:46:16.980 --> 00:46:23.010
早些时候的两个或倒数第二个

00:46:20.030 --> 00:46:24.180
示范，但要注意的是

00:46:23.010 --> 00:46:26.460
例如当你想做的时候

00:46:24.180 --> 00:46:28.200
分页时，我们正在建立一个

00:46:26.460 --> 00:46:30.510
图QL服务器我们必须编写

00:46:28.200 --> 00:46:33.360
您看到的所有内容都会添加注释

00:46:30.510 --> 00:46:34.230
汽车服务以及对汽车的对象

00:46:33.360 --> 00:46:35.940
当我们这样做时，我们基本上是

00:46:34.230 --> 00:46:38.520
建立图QL 

00:46:35.940 --> 00:46:41.040
服务器，所以如果你想做分页

00:46:38.520 --> 00:46:42.630
你必须具备内在的能力

00:46:41.040 --> 00:46:45.180
您的实体对象或服务

00:46:42.630 --> 00:46:47.370
反对去获取数据分页

00:46:45.180 --> 00:46:48.960
对，所以它不是免费的

00:46:47.370 --> 00:46:51.150
服务器端的东西不是免费的

00:46:48.960 --> 00:46:54.240
你仍然有能力去做

00:46:51.150 --> 00:46:56.220
分页，然后用图QL允许您

00:46:54.240 --> 00:46:58.470
将分页显示在图中

00:46:56.220 --> 00:47:01.830
 QL库好，所以我们没有涵盖

00:46:58.470 --> 00:47:03.480
在我们的代码示例中进行分页

00:47:01.830 --> 00:47:05.340
谈到了一些突变， 

00:47:03.480 --> 00:47:06.810
更新中的变化，但我们没有得到

00:47:05.340 --> 00:47:11.310
在这方面有太多细节

00:47:06.810 --> 00:47:12.990
不幸的是，我要停在那里

00:47:11.310 --> 00:47:14.490
因为我还剩20秒左右

00:47:12.990 --> 00:47:17.610
我还剩下多少时间

00:47:14.490 --> 00:47:19.490
我是否再没有时间继续前进了

00:47:17.610 --> 00:47:25.620
好的

00:47:19.490 --> 00:47:25.620
 [音乐] 

