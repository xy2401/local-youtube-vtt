WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.900 --> 00:00:09.480
 [音乐] 

00:00:06.649 --> 00:00:10.590
那为什么不开始呢

00:00:09.480 --> 00:00:12.330
我不认为要提前几分钟

00:00:10.590 --> 00:00:14.670
任何人都会成功

00:00:12.330 --> 00:00:16.650
我先说我爱这个

00:00:14.670 --> 00:00:17.820
会议，我爱你们所有人

00:00:16.650 --> 00:00:19.560
在这次会议上有很多

00:00:17.820 --> 00:00:21.990
这个房间里的人，所以我真的

00:00:19.560 --> 00:00:24.599
非常高兴我们今天在这里听

00:00:21.990 --> 00:00:26.849
使用多服务反应流

00:00:24.599 --> 00:00:28.499
Spring 反应堆和我们的袜子真的

00:00:26.849 --> 00:00:29.999
长名字我真的必须工作

00:00:28.499 --> 00:00:32.009
在命名上我真的很不好

00:00:29.999 --> 00:00:33.630
对于那些不认识我的人

00:00:32.009 --> 00:00:36.180
到目前为止，我还没有看过我的演讲

00:00:33.630 --> 00:00:39.060
星期我的名字叫本·黑尔（Ben Hale） 

00:00:36.180 --> 00:00:40.380
 Java on Cloud Foundry看起来像一个

00:00:39.060 --> 00:00:41.760
真奇怪，因为我在这里

00:00:40.380 --> 00:00:44.820
与您谈论被动

00:00:41.760 --> 00:00:48.900
用Java编程，这是我的日常工作

00:00:44.820 --> 00:00:49.950
实际上是在运行云平台

00:00:48.900 --> 00:00:51.750
为什么我在这里

00:00:49.950 --> 00:00:53.880
对，为什么我有这种兴趣

00:00:51.750 --> 00:00:56.190
从主题演讲中可以清楚地看到

00:00:53.880 --> 00:00:58.050
反应性的东西，关键是我的

00:00:56.190 --> 00:00:59.520
在Java on cloud上运行的位置

00:00:58.050 --> 00:01:01.050
铸造厂使我处于我所处的位置

00:00:59.520 --> 00:01:03.840
看到很多客户和很多

00:01:01.050 --> 00:01:05.850
客户需求以及何时

00:01:03.840 --> 00:01:08.040
开始谈论r2 DBC，我看到了

00:01:05.850 --> 00:01:09.960
人们试图连接

00:01:08.040 --> 00:01:12.750
数据库，这是一个非常非常

00:01:09.960 --> 00:01:14.640
类似的事情，我们看到了我们所有的

00:01:12.750 --> 00:01:17.159
客户参加反应式编程

00:01:14.640 --> 00:01:19.200
最终这是一个缓慢的trick流，但是

00:01:17.159 --> 00:01:21.510
我们越来越多地看到这种想法

00:01:19.200 --> 00:01:25.620
高效的应用真的

00:01:21.510 --> 00:01:28.050
对我们所有开发人员而言，真正的关键

00:01:25.620 --> 00:01:29.460
从长远来看，没有人愿意

00:01:28.050 --> 00:01:30.720
支付他们当前的关键费用

00:01:29.460 --> 00:01:32.610
支付关键没人愿意支付

00:01:30.720 --> 00:01:35.430
亚马逊或谷歌他们要付什么

00:01:32.610 --> 00:01:37.650
我们需要做的是摆脱

00:01:35.430 --> 00:01:39.030
我们所做的很多事情

00:01:37.650 --> 00:01:42.600
当我们只是在我们的跑步中

00:01:39.030 --> 00:01:44.850
数据中心和计算机只是

00:01:42.600 --> 00:01:47.010
沉没成本，所以它实际上并没有

00:01:44.850 --> 00:01:48.630
非常重要，所以我们想去

00:01:47.010 --> 00:01:50.310
快速进行反应式编程

00:01:48.630 --> 00:01:52.440
为没有看过我的人进行评论

00:01:50.310 --> 00:01:54.750
在基本不阻塞之前两次

00:01:52.440 --> 00:01:57.299
与异步行为配对，但

00:01:54.750 --> 00:01:59.729
绝对不是

00:01:57.299 --> 00:02:01.500
异步行为正确反应

00:01:59.729 --> 00:02:03.930
通常对

00:02:01.500 --> 00:02:05.340
同步最高效率

00:02:03.930 --> 00:02:07.740
东西，如果你看看里面

00:02:05.340 --> 00:02:09.720
 Project Reactor是您最快的东西

00:02:07.740 --> 00:02:11.340
看到运行在反应堆内部

00:02:09.720 --> 00:02:13.349
他们称之为融合的东西

00:02:11.340 --> 00:02:14.130
很多操作，他们喜欢

00:02:13.349 --> 00:02:15.510
拉他们

00:02:14.130 --> 00:02:17.460
把它们粘在旁边

00:02:15.510 --> 00:02:19.170
另一个完全一样

00:02:17.460 --> 00:02:20.490
直接一个接一个地

00:02:19.170 --> 00:02:22.560
连接的cuz实际上是

00:02:20.490 --> 00:02:25.320
但是，运行反应式代码的最快方法

00:02:22.560 --> 00:02:27.480
当你想做异步种类时

00:02:25.320 --> 00:02:29.520
行为反应真的

00:02:27.480 --> 00:02:32.100
编程模型使效果很好

00:02:29.520 --> 00:02:34.560
您可能会异步的事情

00:02:32.100 --> 00:02:36.180
甚至说出可能的右键

00:02:34.560 --> 00:02:38.490
我们要说的与众不同

00:02:36.180 --> 00:02:40.710
异步编程就是这个想法

00:02:38.490 --> 00:02:43.560
极推压力这个想法

00:02:40.710 --> 00:02:45.570
出版商无法向我发送任何数据，除非

00:02:43.560 --> 00:02:49.050
我首先请那个发布者

00:02:45.570 --> 00:02:52.140
给我发送数据，以便我们看到这张幻灯片

00:02:49.050 --> 00:02:54.360
我们前几天在主题演讲上看到了

00:02:52.140 --> 00:02:56.430
综合健康使我们有能力或

00:02:54.360 --> 00:02:59.280
所以反应式编程使我们

00:02:56.430 --> 00:03:01.290
现在可以说我想要这个东西的能力

00:02:59.280 --> 00:03:03.240
这个东西要与一个平行运行

00:03:01.290 --> 00:03:05.220
另一件事，这两件事不

00:03:03.240 --> 00:03:06.210
彼此依赖，他们可能会发生

00:03:05.220 --> 00:03:07.620
他们可能同时发生

00:03:06.210 --> 00:03:09.510
如果您认为那是一个顺序

00:03:07.620 --> 00:03:12.360
更好的方法来做反应堆，但我

00:03:09.510 --> 00:03:14.970
想要你做的就是去给我一个URI去去

00:03:12.360 --> 00:03:16.370
我另一个URI，然后一次这两个

00:03:14.970 --> 00:03:19.260
事情并行发生

00:03:16.370 --> 00:03:21.300
依序建立我的综合

00:03:19.260 --> 00:03:23.130
那真的是关键

00:03:21.300 --> 00:03:25.080
反应性框架正在为您提供

00:03:23.130 --> 00:03:26.880
是他们实现这一目标的方式

00:03:25.080 --> 00:03:29.220
效率，因为现在您

00:03:26.880 --> 00:03:33.060
声明性地基本上说平行

00:03:29.220 --> 00:03:34.380
然后连续的权利，你永远不会

00:03:33.060 --> 00:03:35.940
管理线程或

00:03:34.380 --> 00:03:38.070
幕后优化

00:03:35.940 --> 00:03:40.140
那，但仍然有路障

00:03:38.070 --> 00:03:42.060
我说我在各处都使用反应式

00:03:40.140 --> 00:03:43.770
个人随处可见的人

00:03:42.060 --> 00:03:45.209
那不是官方的政策

00:03:43.770 --> 00:03:47.640
关键不是官方政策

00:03:45.209 --> 00:03:48.990
春季团队反应使用反应

00:03:47.640 --> 00:03:50.459
当您认为正确时，有一个

00:03:48.990 --> 00:03:51.540
一堆完全没有的地方

00:03:50.459 --> 00:03:52.590
显然这是您要使用的地方

00:03:51.540 --> 00:03:53.970
反应堆，还有很多地方

00:03:52.590 --> 00:03:56.910
在哪里，实际上可能不是

00:03:53.970 --> 00:03:58.410
还清，所以当我们说使用反应式

00:03:56.910 --> 00:04:00.990
到处都是

00:03:58.410 --> 00:04:05.010
适当的数据访问数据访问

00:04:00.990 --> 00:04:07.530
方面真的是最重要的

00:04:05.010 --> 00:04:09.000
 MongoDB Cassandra Couchbase阅读它的

00:04:07.530 --> 00:04:10.800
这些没有后遗症的东西

00:04:09.000 --> 00:04:13.110
数据源真的跳上了他们

00:04:10.800 --> 00:04:15.480
是在这个

00:04:13.110 --> 00:04:18.270
异步绘图编程模型

00:04:15.480 --> 00:04:20.370
特别是由nodejs驱动的

00:04:18.270 --> 00:04:22.200
常见，所以他们把它带到了我们

00:04:20.370 --> 00:04:23.340
显然也开始我们进入DBC 

00:04:22.200 --> 00:04:25.290
因为我们知道关系

00:04:23.340 --> 00:04:27.670
数据库是您所有数据的存放地

00:04:25.290 --> 00:04:28.930
真的不是这些家伙在这里吗

00:04:27.670 --> 00:04:30.910
我们希望确保可以在

00:04:28.930 --> 00:04:32.830
同时，最后我们想要

00:04:30.910 --> 00:04:34.390
再谈一下跨进程

00:04:32.830 --> 00:04:36.790
压力真的很复杂

00:04:34.390 --> 00:04:39.130
说我到底如何得到的方式

00:04:36.790 --> 00:04:41.200
跨网络的反应式编程

00:04:39.130 --> 00:04:44.080
对，我知道我可以说一个

00:04:41.200 --> 00:04:46.090
 JVM内的发布者无法发送给我

00:04:44.080 --> 00:04:48.280
比我要求的更多的数据，但是

00:04:46.090 --> 00:04:49.960
现在我要进行HTTP调用

00:04:48.280 --> 00:04:52.150
另一个微服务即将

00:04:49.960 --> 00:04:56.770
向我发送一千万行相邻的权利

00:04:52.150 --> 00:04:58.660
现在我被抽水了，所以我很高兴没有

00:04:56.770 --> 00:05:00.850
宣布一个项目，以至于指向

00:04:58.660 --> 00:05:03.760
历史上称为我们的套接字的项目

00:05:00.850 --> 00:05:06.370
我们的插座是由团队设计的

00:05:03.760 --> 00:05:07.840
 Netflix内部称为边缘服务器

00:05:06.370 --> 00:05:09.070
路由团队，我相信这就是他们

00:05:07.840 --> 00:05:11.800
被称为这些是

00:05:09.070 --> 00:05:13.240
他们之前给您带来了Netflix OSS 

00:05:11.800 --> 00:05:15.520
坐下来说好

00:05:13.240 --> 00:05:16.930
 Netflix OSS吸引了很多人

00:05:15.520 --> 00:05:19.090
有歇斯底里的人很多

00:05:16.930 --> 00:05:21.460
在那里使用尤里卡之类的东西，但是

00:05:19.090 --> 00:05:23.440
我们认为我们可以做得更好

00:05:21.460 --> 00:05:25.990
我们内部有点受阻

00:05:23.440 --> 00:05:28.930
知道我们必须使用HTTP或必须使用

00:05:25.990 --> 00:05:30.820
 TCP，但是如果实际上不是

00:05:28.930 --> 00:05:32.560
要求如果我们真的是

00:05:30.820 --> 00:05:35.560
真的很雄心勃勃，并说所有

00:05:32.560 --> 00:05:37.390
我们想用HTTP做的所有事情

00:05:35.560 --> 00:05:39.100
我们想要做的所有事情

00:05:37.390 --> 00:05:40.510
像

00:05:39.100 --> 00:05:42.580
断路器服务模式

00:05:40.510 --> 00:05:44.710
注册表负载平衡和

00:05:42.580 --> 00:05:46.300
复杂的方式，如果我们更多

00:05:44.710 --> 00:05:48.940
雄心勃勃，我们说有一个网络

00:05:46.300 --> 00:05:50.770
向下移动的协议

00:05:48.940 --> 00:05:52.510
所有这些下面的堆栈

00:05:50.770 --> 00:05:56.410
运行的应用服务器

00:05:52.510 --> 00:05:58.350
互相协调等等

00:05:56.410 --> 00:06:00.280
他们想到了这个伟大的事情

00:05:58.350 --> 00:06:02.710
我们的插座是双向的

00:06:00.280 --> 00:06:04.750
复用消息库二进制协议

00:06:02.710 --> 00:06:06.160
基于反应流的反压

00:06:04.750 --> 00:06:07.750
有很多话，我们

00:06:06.160 --> 00:06:09.190
来看看每个

00:06:07.750 --> 00:06:11.530
这些话，接下来的几张幻灯片和

00:06:09.190 --> 00:06:14.080
它为

00:06:11.530 --> 00:06:16.030
最常见的互动模型

00:06:14.080 --> 00:06:17.410
特别是一旦您进入频道

00:06:16.030 --> 00:06:19.240
帐户，您意识到这是一次救助， 

00:06:17.410 --> 00:06:22.120
你可以做任何一种互动模型

00:06:19.240 --> 00:06:25.390
有了它，什么是消息驱动的

00:06:22.120 --> 00:06:27.730
二进制协议表示正确，所以如果您

00:06:25.390 --> 00:06:29.440
考虑一下HTTP应该如何工作

00:06:27.730 --> 00:06:31.960
你提出一个请求，你得到一个

00:06:29.440 --> 00:06:33.730
回复大部分请求，因此

00:06:31.960 --> 00:06:35.680
您可以有效地取回文件

00:06:33.730 --> 00:06:37.930
称基于文档的协议为

00:06:35.680 --> 00:06:40.090
单个请求将返回您的文档

00:06:37.930 --> 00:06:41.560
无论是HTML还是HTML 

00:06:40.090 --> 00:06:44.440
杰森之类的

00:06:41.560 --> 00:06:46.630
这样，当我们谈论一条消息时

00:06:44.440 --> 00:06:48.790
驱动二进制协议是什么

00:06:46.630 --> 00:06:50.919
谈论的是所有请求者

00:06:48.790 --> 00:06:53.440
响应者互动已分解

00:06:50.919 --> 00:06:56.080
变成一组框架

00:06:53.440 --> 00:06:58.389
小封装个人

00:06:56.080 --> 00:07:01.540
内含而不是内含的讯息

00:06:58.389 --> 00:07:03.190
一小段文字外出和

00:07:01.540 --> 00:07:05.260
一滴其他的东西来了

00:07:03.190 --> 00:07:07.600
回来，我们得到这些离散的帧说

00:07:05.260 --> 00:07:09.310
这是一个请求，所以我可以发送一堆

00:07:07.600 --> 00:07:11.169
彼此独立的请求

00:07:09.310 --> 00:07:12.520
给你，因为这是一条信息

00:07:11.169 --> 00:07:14.050
说我要你去给我​​一些东西

00:07:12.520 --> 00:07:15.520
当你该回应的时候

00:07:14.050 --> 00:07:17.620
你不只是给我一个

00:07:15.520 --> 00:07:18.850
你把它们打包的firehose 

00:07:17.620 --> 00:07:21.520
即将出现的小消息

00:07:18.850 --> 00:07:23.620
回到我的框架是二进制的

00:07:21.520 --> 00:07:26.290
真的违反直觉

00:07:23.620 --> 00:07:29.320
来自你知道20 30年的

00:07:26.290 --> 00:07:31.330
 HTTP正确，对我们来说很常见

00:07:29.320 --> 00:07:33.250
 Wireshark或类似的东西

00:07:31.330 --> 00:07:34.780
的代理机制，只是看

00:07:33.250 --> 00:07:36.910
在右边的标题处

00:07:34.780 --> 00:07:40.300
每个人都知道什么是HTTP请求

00:07:36.910 --> 00:07:42.910
看起来像是ASCII文本，但是我们

00:07:40.300 --> 00:07:45.729
找出是如果您选择二进制

00:07:42.910 --> 00:07:48.250
它小得令人难以置信

00:07:45.729 --> 00:07:50.470
压缩我们拥有巨大的效率

00:07:48.250 --> 00:07:51.550
用于机器对机器的通讯和

00:07:50.470 --> 00:07:53.560
在我们谈论我们的时候

00:07:51.550 --> 00:07:56.200
插座和我们的秤

00:07:53.560 --> 00:07:58.390
插座要你在这工作

00:07:56.200 --> 00:08:01.479
巨大的进步

00:07:58.390 --> 00:08:04.900
像HTTP一样，协议的开销

00:08:01.479 --> 00:08:06.310
与

00:08:04.900 --> 00:08:08.950
在其中传输的数据

00:08:06.310 --> 00:08:10.360
缺点主要在以下情况很少出现

00:08:08.950 --> 00:08:11.740
您正在尝试找出为什么

00:08:10.360 --> 00:08:13.990
这项工作对人特别不利

00:08:11.740 --> 00:08:16.419
在我们的套接字Java或我们的Java上工作的人

00:08:13.990 --> 00:08:19.300
 socket go或我们的socket Kotlin或

00:08:16.419 --> 00:08:21.039
像那样的东西，但堆栈

00:08:19.300 --> 00:08:22.450
实际实现的库

00:08:21.039 --> 00:08:24.910
这个协议试图调试这个可以

00:08:22.450 --> 00:08:26.710
有时会有巨大的痛苦，但是有

00:08:24.910 --> 00:08:28.419
您周围的世界中有足够的工具

00:08:26.710 --> 00:08:30.340
可以写Wireshark协议

00:08:28.419 --> 00:08:32.440
对不起，Wireshark插件例如

00:08:30.340 --> 00:08:34.140
知道如何解码二进制数据

00:08:32.440 --> 00:08:36.760
过去了，我们可以看看

00:08:34.140 --> 00:08:38.380
我们一直在谈论的关键一件事

00:08:36.760 --> 00:08:40.300
关于你知道的信息

00:08:38.380 --> 00:08:41.740
导数是

00:08:40.300 --> 00:08:43.510
这个协议是有效载荷

00:08:41.740 --> 00:08:45.820
本身是例外

00:08:43.510 --> 00:08:48.490
想法有效载荷只是字节包

00:08:45.820 --> 00:08:50.740
对，我们不，协议不

00:08:48.490 --> 00:08:52.930
实际告诉您有效载荷需要什么

00:08:50.740 --> 00:08:54.580
不需要是ASCII文本

00:08:52.930 --> 00:08:55.040
不需要是杰森，不需要

00:08:54.580 --> 00:08:58.940
成为

00:08:55.040 --> 00:09:00.649
 buf命名另一个协议GRP，请参见

00:08:58.940 --> 00:09:02.300
广告确实非常相似

00:09:00.649 --> 00:09:04.250
这样的事情，所以它可能是

00:09:02.300 --> 00:09:06.680
杰森，如果您仍然愿意的话，可能是XML 

00:09:04.250 --> 00:09:08.060
 XML类的人，因为内部

00:09:06.680 --> 00:09:09.440
该协议说这只是一堆

00:09:08.060 --> 00:09:11.079
一和零，我们要给它

00:09:09.440 --> 00:09:13.310
客户，否则我们将把它交给

00:09:11.079 --> 00:09:15.079
最后的响应者或请求者

00:09:13.310 --> 00:09:19.300
他们将以这种方式对其进行解码

00:09:15.079 --> 00:09:22.579
他们想要协议本身也是

00:09:19.300 --> 00:09:25.209
多路复用，当我第一次得到

00:09:22.579 --> 00:09:29.180
从我们的插座开始是最

00:09:25.209 --> 00:09:30.949
关于网络的惊人顿悟

00:09:29.180 --> 00:09:34.279
对，这是什么意思

00:09:30.949 --> 00:09:36.170
仅使用单个连接的连接

00:09:34.279 --> 00:09:39.620
我们看到的请求效率很低

00:09:36.170 --> 00:09:40.970
这在HTTP 1.0中，所以HTTP 1.1出现了

00:09:39.620 --> 00:09:42.680
我说好，你有一个

00:09:40.970 --> 00:09:44.480
连接为什么不发送一个

00:09:42.680 --> 00:09:46.370
一堆请求和您的订单

00:09:44.480 --> 00:09:48.529
发送给您您期望得到的订单

00:09:46.370 --> 00:09:50.449
回复他们，哦，试图

00:09:48.529 --> 00:09:53.089
确保自己永远都是巨人

00:09:50.449 --> 00:09:54.589
大多数Web框架都会照顾自己的痛苦

00:09:53.089 --> 00:09:57.920
这个给你，但仍然有

00:09:54.589 --> 00:09:59.660
问题正确，如果我发送五个，会发生什么

00:09:57.920 --> 00:10:01.490
通过单个连接请求

00:09:59.660 --> 00:10:03.709
你，但是第一个真的很慢

00:10:01.490 --> 00:10:05.630
当后来的四个

00:10:03.709 --> 00:10:07.519
真的很快，这就是为什么如果你服用

00:10:05.630 --> 00:10:09.170
看看网络浏览器是如何工作的

00:10:07.519 --> 00:10:10.790
不能为所有人打开连接

00:10:09.170 --> 00:10:12.050
每个人的效率都很低

00:10:10.790 --> 00:10:14.120
它需要去的一切

00:10:12.050 --> 00:10:15.380
您的服务器不会为每个服务器打开一个

00:10:14.120 --> 00:10:17.120
那些是因为有很多联系

00:10:15.380 --> 00:10:18.910
效率低下，但也无法打开

00:10:17.120 --> 00:10:21.290
只有一个，因为现在突然

00:10:18.910 --> 00:10:23.180
缓慢的请求可能会干扰快速的请求

00:10:21.290 --> 00:10:24.800
请求或多或少地被卡住

00:10:23.180 --> 00:10:26.750
在您的网站的情况下

00:10:24.800 --> 00:10:28.310
页面的渲染速度可能仅与

00:10:26.750 --> 00:10:30.560
最慢的事情

00:10:28.310 --> 00:10:34.279
增量加载，所以这真的

00:10:30.560 --> 00:10:36.170
甚至HTTP 1.1多路传输也非常糟糕

00:10:34.279 --> 00:10:38.000
解决了这个问题，它打开了一个

00:10:36.170 --> 00:10:40.850
单个物理连接

00:10:38.000 --> 00:10:42.709
套接字或我猜取决于您

00:10:40.850 --> 00:10:45.560
认为物理意味着物理套接字

00:10:42.709 --> 00:10:47.990
在两个服务器之间，然后说

00:10:45.560 --> 00:10:50.149
好的，我要在这个管道中发送一个

00:10:47.990 --> 00:10:51.649
消息说我流一个，然后

00:10:50.149 --> 00:10:54.319
它会再发送一条消息说我

00:10:51.649 --> 00:10:56.360
流三，那些可以返回任何

00:10:54.319 --> 00:10:57.949
如果他们很慢则命令他们想要

00:10:56.360 --> 00:11:00.230
三个很快就可以了，三个可以

00:10:57.949 --> 00:11:02.630
回来是因为，而不是说

00:11:00.230 --> 00:11:04.550
我知道你在回应什么

00:11:02.630 --> 00:11:06.019
因为你先回来

00:11:04.550 --> 00:11:07.150
那你就回来了

00:11:06.019 --> 00:11:09.010
实际标记

00:11:07.150 --> 00:11:11.440
出站请求和

00:11:09.010 --> 00:11:13.150
响应入站，它说嘿三

00:11:11.440 --> 00:11:14.560
现在回来了，随便你做什么

00:11:13.150 --> 00:11:16.779
需要做的或三个一个回来

00:11:14.560 --> 00:11:18.520
过了一会儿，说嘿去做什么

00:11:16.779 --> 00:11:20.589
您需要在那里做，这确实是

00:11:18.520 --> 00:11:22.570
太好了，这确实影响了很多

00:11:20.589 --> 00:11:24.430
我的想法，尤其是关于RTD BC 

00:11:22.570 --> 00:11:26.830
所以我们想问一下数据库驱动程序

00:11:24.430 --> 00:11:28.120
他们说嘿，你知道每个人都可以

00:11:26.830 --> 00:11:29.410
只有四个连接到您的

00:11:28.120 --> 00:11:30.760
数据库或与您的八个连接

00:11:29.410 --> 00:11:32.589
数据库为什么你没有他们有

00:11:30.760 --> 00:11:34.630
一个连接到您的数据库，然后

00:11:32.589 --> 00:11:37.000
他们可以拥有一百万个流

00:11:34.630 --> 00:11:38.710
它与逻辑行为一样多

00:11:37.000 --> 00:11:40.450
他们想在那些东西上

00:11:38.710 --> 00:11:42.910
例如Postgres团队开始

00:11:40.450 --> 00:11:45.490
一直研究这个想法

00:11:42.910 --> 00:11:47.350
可扩展性就好像是其中之一

00:11:45.490 --> 00:11:49.360
您将看到的奇妙事物来了

00:11:47.350 --> 00:11:55.480
还是那是你知道的一种整体

00:11:49.360 --> 00:11:58.390
到我们的插座这里的协议

00:11:55.480 --> 00:12:00.880
也是双向的，这有一些

00:11:58.390 --> 00:12:04.210
真的非常有趣的用例

00:12:00.880 --> 00:12:05.620
专门不是TCP的协议具有

00:12:04.210 --> 00:12:07.089
客户与客户之间的区别

00:12:05.620 --> 00:12:09.850
连接生命周期内的服务器

00:12:07.089 --> 00:12:11.800
因此，如果您的HTTP客户端写得像网络

00:12:09.850 --> 00:12:14.500
浏览器，您可以向

00:12:11.800 --> 00:12:17.980
服务器HTTP服务器，它可能会响应

00:12:14.500 --> 00:12:20.560
你，就是这样，就像

00:12:17.980 --> 00:12:22.540
只有这样才能传输数据

00:12:20.560 --> 00:12:24.790
右侧发起所有请求

00:12:22.540 --> 00:12:28.390
一侧甚至会发起所有响应

00:12:24.790 --> 00:12:29.890
像HTTP 2这样的东西

00:12:28.390 --> 00:12:33.459
应该是这样的

00:12:29.890 --> 00:12:36.700
多重哦，是的，甚至有东西

00:12:33.459 --> 00:12:39.130
像HTTP 2一样不能完全删除

00:12:36.700 --> 00:12:41.230
区分权有一种

00:12:39.130 --> 00:12:45.040
从...发送数据的机制

00:12:41.230 --> 00:12:47.020
服务器到客户端或数据有点，但

00:12:45.040 --> 00:12:48.910
服务器无法启动未请求的

00:12:47.020 --> 00:12:51.010
流客户基本上不得不说

00:12:48.910 --> 00:12:52.480
好吧，我准备好听你的

00:12:51.010 --> 00:12:54.279
开始向我发送一些东西，所以他们已经

00:12:52.480 --> 00:12:57.700
有效启动了一半

00:12:54.279 --> 00:13:00.040
在那开始了互动

00:12:57.700 --> 00:13:02.440
我们用插座说的是

00:13:00.040 --> 00:13:05.380
客户端启动与

00:13:02.440 --> 00:13:07.870
服务器正确，所以在我们的类比网络中

00:13:05.380 --> 00:13:09.490
浏览器都连接到我们的服务器

00:13:07.870 --> 00:13:11.050
合作伙伴，我们基本上失去了

00:13:09.490 --> 00:13:13.000
区别在于有一个讨论

00:13:11.050 --> 00:13:14.290
那天公司闲散

00:13:13.000 --> 00:13:15.610
试图向一些人解释

00:13:14.290 --> 00:13:17.829
人们这是一个很难的概念

00:13:15.610 --> 00:13:19.990
 grok服务器和客户端消失

00:13:17.829 --> 00:13:20.590
现在两个同伴都等于一个

00:13:19.990 --> 00:13:22.330
另一个

00:13:20.590 --> 00:13:24.040
在此网络连接中

00:13:22.330 --> 00:13:25.990
一方可以向对方发起请求

00:13:24.040 --> 00:13:28.000
双方都可以发起回应

00:13:25.990 --> 00:13:30.610
他们两个都是等效的

00:13:28.000 --> 00:13:32.850
这是一个非常有趣的副作用

00:13:30.610 --> 00:13:36.520
当涉及到安全性时

00:13:32.850 --> 00:13:38.740
想象一个坐在中间的路由器

00:13:36.520 --> 00:13:41.350
一堆不同的客户

00:13:38.740 --> 00:13:43.529
今天我在容器内工作

00:13:41.350 --> 00:13:47.350
 Cloud Foundry告诉我最大的

00:13:43.529 --> 00:13:49.180
容器受损的可能性

00:13:47.350 --> 00:13:51.790
在云环境中，您有一个

00:13:49.180 --> 00:13:54.100
有人进入的HTTP端口

00:13:51.790 --> 00:13:55.960
该端口并利用内部的某些东西

00:13:54.100 --> 00:13:58.720
现在，如果可以的话

00:13:55.960 --> 00:14:00.700
相反说你的容器没有

00:13:58.720 --> 00:14:02.980
根本没有入口

00:14:00.700 --> 00:14:05.830
只有出站连接才能进入

00:14:02.980 --> 00:14:08.320
使我们的插座启用这种

00:14:05.830 --> 00:14:10.870
我们所有的插座连接的模式

00:14:08.320 --> 00:14:13.029
到某个可信任的聚会，但是一次

00:14:10.870 --> 00:14:15.130
他们在那里任何形式的创业

00:14:13.029 --> 00:14:17.380
任何人都可以要求任何人都可以回应

00:14:15.130 --> 00:14:18.850
在您所配置的任何网络中

00:14:17.380 --> 00:14:20.860
从那里想要，它给你

00:14:18.850 --> 00:14:24.370
其实这真的很有趣

00:14:20.860 --> 00:14:25.960
因此，我认为安全态势

00:14:24.370 --> 00:14:27.940
最后的一组词

00:14:25.960 --> 00:14:30.280
有反应流反压

00:14:27.940 --> 00:14:32.020
我们将要使用的网络协议HTTP 

00:14:30.280 --> 00:14:34.300
一直都在敲它

00:14:32.020 --> 00:14:35.380
通常像我一样发送单个请求

00:14:34.300 --> 00:14:37.690
说我们都知道这是什么样子

00:14:35.380 --> 00:14:39.730
返回某种任意的10 

00:14:37.690 --> 00:14:41.740
一百万行JSON返回给我们

00:14:39.730 --> 00:14:43.540
没有什么可以阻止响应者甚至

00:14:41.740 --> 00:14:46.180
可能是发疯的请求者

00:14:43.540 --> 00:14:50.589
在服务器上，大量的

00:14:46.180 --> 00:14:52.870
 TCP返回保护您的数据

00:14:50.589 --> 00:14:54.970
压力这个想法，TCP堆栈

00:14:52.870 --> 00:14:58.720
像水平一样下降到

00:14:54.970 --> 00:15:00.970
那种堆叠权有这些想法

00:14:58.720 --> 00:15:03.400
一直排队直到知道

00:15:00.970 --> 00:15:05.410
 syn ACK配对就像数据一样

00:15:03.400 --> 00:15:07.510
一直以较低的TCP级别发送

00:15:05.410 --> 00:15:09.540
不会发送更多数据给您

00:15:07.510 --> 00:15:11.890
不能炸毁一个

00:15:09.540 --> 00:15:13.959
现代计算机，但最终

00:15:11.890 --> 00:15:18.000
发生的事情是你最终排成一列

00:15:13.959 --> 00:15:20.380
的未处理数据或不可传输

00:15:18.000 --> 00:15:21.880
您将一堆数据放在TCP中

00:15:20.380 --> 00:15:24.190
尚未备份到的队列

00:15:21.880 --> 00:15:25.600
应用程序以及发送方

00:15:24.190 --> 00:15:26.920
你最终会得到一堆

00:15:25.600 --> 00:15:29.500
无法获得的队列

00:15:26.920 --> 00:15:31.150
穿过电线，这确实是

00:15:29.500 --> 00:15:32.470
有问题只是因为如果你有一个

00:15:31.150 --> 00:15:33.910
大量的人脉关系

00:15:32.470 --> 00:15:35.830
排队需要很多

00:15:33.910 --> 00:15:37.450
内存，这真的很糟糕，所以

00:15:35.830 --> 00:15:40.980
反应流在这里背压

00:15:37.450 --> 00:15:44.080
确保我们仅实现数据

00:15:40.980 --> 00:15:45.670
并在接收方传输数据时

00:15:44.080 --> 00:15:47.710
准备在接收方处理

00:15:45.670 --> 00:15:48.970
从字面上发送这些消息之一

00:15:47.710 --> 00:15:51.160
电线上的那些框架之一， 

00:15:48.970 --> 00:15:53.740
说好吧，现在您可以发送给我

00:15:51.160 --> 00:15:55.900
现在允许您再发送128条消息

00:15:53.740 --> 00:15:58.360
给我发送下64条消息， 

00:15:55.900 --> 00:16:00.280
这是向服务器端发出的信号

00:15:58.360 --> 00:16:02.380
它可以进入数据库并读取那些

00:16:00.280 --> 00:16:04.540
离开磁盘或转到另一个微服务

00:16:02.380 --> 00:16:06.400
并获取更多数据

00:16:04.540 --> 00:16:08.950
它并发送它不会实现

00:16:06.400 --> 00:16:10.990
在我能处理它之前，那就是

00:16:08.950 --> 00:16:15.700
其实对你也有好处

00:16:10.990 --> 00:16:17.860
服务器，让我们看一下

00:16:15.700 --> 00:16:19.180
互动为第一次互动建模

00:16:17.860 --> 00:16:20.710
我们说的模型有四个

00:16:19.180 --> 00:16:22.900
对第一个交互模型

00:16:20.710 --> 00:16:25.030
我们经常谈论的是请求响应

00:16:22.900 --> 00:16:28.270
我想申请一个账户的想法

00:16:25.030 --> 00:16:29.650
抱歉，我是银行应用程序

00:16:28.270 --> 00:16:32.500
让我们让我说我是银行应用

00:16:29.650 --> 00:16:34.300
对的，我正在看它， 

00:16:32.500 --> 00:16:36.130
我要做的第一件事就是登录

00:16:34.300 --> 00:16:37.450
要给我看一个启动画面，所以

00:16:36.130 --> 00:16:39.700
知道我的帐号后， 

00:16:37.450 --> 00:16:41.500
要求并说嘿，去找我

00:16:39.700 --> 00:16:43.960
这个特殊的平衡是什么

00:16:41.500 --> 00:16:45.610
帐号标准请求响应

00:16:43.960 --> 00:16:47.260
语义，我们一直看到这条线

00:16:45.610 --> 00:16:50.560
在顶部，所以这是一个错误

00:16:47.260 --> 00:16:52.930
考虑到我要求客户的时间有多短

00:16:50.560 --> 00:16:55.390
您传递请求有效负载的响应

00:16:52.930 --> 00:16:56.890
只是单个对象而已

00:16:55.390 --> 00:16:58.360
我们称它为帐号

00:16:56.890 --> 00:17:02.350
这个特殊的情况，你会得到

00:16:58.360 --> 00:17:04.090
这些单声道有效载荷适合那些

00:17:02.350 --> 00:17:06.250
谁错过了我的其他一些演讲

00:17:04.090 --> 00:17:10.000
所有这些东西，只要你要

00:17:06.250 --> 00:17:12.850
看到我在这里做一个演示我们的插座

00:17:10.000 --> 00:17:15.610
特别是基于项目反应堆

00:17:12.850 --> 00:17:17.890
这是 Spring 附属的

00:17:15.610 --> 00:17:19.810
反应式编程的实现

00:17:17.890 --> 00:17:21.670
还有其他选择

00:17:19.810 --> 00:17:24.130
其他语言，但从根本上讲，我们

00:17:21.670 --> 00:17:25.900
项目反应堆有两种主要类型

00:17:24.130 --> 00:17:28.720
我们有一个通量的想法

00:17:25.900 --> 00:17:30.100
从0到n的事物流

00:17:28.720 --> 00:17:32.860
回到我们的元素element element 

00:17:30.100 --> 00:17:34.570
元素和一个单声道，表示0 

00:17:32.860 --> 00:17:36.190
或这些事情之一

00:17:34.570 --> 00:17:37.930
回到我们身边，所以在这种情况下，我们说我们

00:17:36.190 --> 00:17:41.110
我们希望能给您答复

00:17:37.930 --> 00:17:42.850
一个有效载荷现在返回

00:17:41.110 --> 00:17:45.590
几乎可以肯定您在做什么

00:17:42.850 --> 00:17:47.620
被洗脑了

00:17:45.590 --> 00:17:50.000
从HTTP执行请求/响应

00:17:47.620 --> 00:17:52.279
实际上，我们提供的大多数信息

00:17:50.000 --> 00:17:54.590
想知道是一种请求响应类型

00:17:52.279 --> 00:17:57.049
互动，所以没有错

00:17:54.590 --> 00:18:00.559
这个，但即使这个东西，你

00:17:57.049 --> 00:18:03.529
知道你今天可以用HTTP做它

00:18:00.559 --> 00:18:04.850
超越HTTP，因为它是异步的

00:18:03.529 --> 00:18:06.799
和多路传输，我们需要一个

00:18:04.850 --> 00:18:09.679
连接，我可以发送一个

00:18:06.799 --> 00:18:11.570
百万请求响应电话并获得

00:18:09.679 --> 00:18:12.919
他们都以混乱的速度快回来了

00:18:11.570 --> 00:18:15.169
因为它们可以在另一个上进行处理

00:18:12.919 --> 00:18:19.000
支持您今天无法做的事情

00:18:15.169 --> 00:18:21.559
 HTTP，下一个是

00:18:19.000 --> 00:18:24.010
我们称之为请求响应的优化

00:18:21.559 --> 00:18:27.409
这就是我忘了

00:18:24.010 --> 00:18:29.419
不知道这是非常美国的事情

00:18:27.409 --> 00:18:31.309
说当然，我不确定它是否有

00:18:29.419 --> 00:18:33.980
另一边的翻译很棒

00:18:31.309 --> 00:18:36.590
这次我们的枪支文化我们看到了一个马诺

00:18:33.980 --> 00:18:39.260
无效的权利和马诺无效的有点

00:18:36.590 --> 00:18:41.600
反应世界中的特殊习语和

00:18:39.260 --> 00:18:43.490
这基本上是说我不是

00:18:41.600 --> 00:18:45.020
等待回应你不好

00:18:43.490 --> 00:18:46.760
你总是会寄给我零

00:18:45.020 --> 00:18:49.100
因为void不是您可以使用的类型

00:18:46.760 --> 00:18:50.750
实例化和Java，所以我想要你

00:18:49.100 --> 00:18:52.700
要做的就是向我发出信号

00:18:50.750 --> 00:18:54.529
当我们说找到并忘记

00:18:52.700 --> 00:18:56.090
对不起火，忘了我们要发送

00:18:54.529 --> 00:18:57.890
你是有效载荷，我不在乎

00:18:56.090 --> 00:18:59.659
就像它将到达那里的TCP堆栈

00:18:57.890 --> 00:19:00.919
将保证有效载荷到达那里，但是

00:18:59.659 --> 00:19:02.149
你不需要告诉我你懂了

00:19:00.919 --> 00:19:03.289
不需要告诉我您已经完成了

00:19:02.149 --> 00:19:05.929
只是要越过电线，我

00:19:03.289 --> 00:19:08.299
要继续我的生活

00:19:05.929 --> 00:19:09.679
这主要是显着的效率

00:19:08.299 --> 00:19:12.590
关于网络的事情想象一个

00:19:09.679 --> 00:19:14.330
我寄给你的情况我有什么

00:19:12.590 --> 00:19:16.370
这里非关键事件记录正确

00:19:14.330 --> 00:19:18.470
我要给您发送一条日志行，也许

00:19:16.370 --> 00:19:20.690
您需要将该日志行同步到

00:19:18.470 --> 00:19:22.429
现实的数据库将

00:19:20.690 --> 00:19:24.110
你知道要进入数据库

00:19:22.429 --> 00:19:25.850
必须在连接池上等待

00:19:24.110 --> 00:19:27.230
得到它必须等待插入

00:19:25.850 --> 00:19:29.990
以及之后的提交

00:19:27.230 --> 00:19:32.330
数据库写入磁盘可能是

00:19:29.990 --> 00:19:34.340
半秒钟后您才能返回

00:19:32.330 --> 00:19:36.890
我说，嘿，这一切都完成了，但是如果

00:19:34.340 --> 00:19:38.720
我不在乎正确的事件记录不是

00:19:36.890 --> 00:19:40.190
特别关键，那我为什么不

00:19:38.720 --> 00:19:42.080
只是说嘿，这是一条数据， 

00:19:40.190 --> 00:19:43.549
您可以立即释放它

00:19:42.080 --> 00:19:45.049
你会继续你的生活

00:19:43.549 --> 00:19:46.640
尝试获得数据库连接

00:19:45.049 --> 00:19:49.250
仍然尝试使磁盘下沉，因此仍然正确

00:19:46.640 --> 00:19:51.380
但您已释放网络连接

00:19:49.250 --> 00:19:53.210
或逻辑上的联系

00:19:51.380 --> 00:19:54.679
可以继续我的生活而不必

00:19:53.210 --> 00:19:58.250
等你回来

00:19:54.679 --> 00:19:59.960
告诉我你已经完成了四个

00:19:58.250 --> 00:20:01.850
一种不太琐碎的东西

00:19:59.960 --> 00:20:03.350
客户服务器处理您知道

00:20:01.850 --> 00:20:05.270
这里的关键是要确保

00:20:03.350 --> 00:20:07.039
我们正在释放这些资源

00:20:05.270 --> 00:20:10.010
尽我们所能尽快

00:20:07.039 --> 00:20:15.440
无阻塞高效的

00:20:10.010 --> 00:20:17.390
环境，以便下次互动

00:20:15.440 --> 00:20:19.610
模型是请求流的例子，我们

00:20:17.390 --> 00:20:21.980
再次在这里有一个请求

00:20:19.610 --> 00:20:24.110
帐号，然后我想让你

00:20:21.980 --> 00:20:26.600
给我我所有的实时流

00:20:24.110 --> 00:20:28.309
帐户交易实际上不是

00:20:26.600 --> 00:20:31.010
已经发生但

00:20:28.309 --> 00:20:32.690
我站在这里，我哥哥已经过去了

00:20:31.010 --> 00:20:34.039
在那里，他有一张信用卡，他

00:20:32.690 --> 00:20:35.990
去刷卡喝咖啡或

00:20:34.039 --> 00:20:37.970
这样的东西可以出现在我的

00:20:35.990 --> 00:20:40.909
应用正确，这种情况发生的次数很多

00:20:37.970 --> 00:20:42.169
现代的特别是信用卡

00:20:40.909 --> 00:20:44.299
应用程序真的很喜欢这样做

00:20:42.169 --> 00:20:45.770
我们最终在这里看到的是什么时候

00:20:44.299 --> 00:20:48.169
我们去呼叫请求流

00:20:45.770 --> 00:20:50.570
这次相同的有效载荷我们没有得到

00:20:48.169 --> 00:20:51.679
马诺回来，我们得到一个通量反而我们

00:20:50.570 --> 00:20:54.500
将会得到这些

00:20:51.679 --> 00:20:56.809
事件，也许第一件事

00:20:54.500 --> 00:20:57.919
显示所有交易

00:20:56.809 --> 00:21:00.470
在过去一个小时内发生的

00:20:57.919 --> 00:21:02.090
最近两个小时，但我们不发信号

00:21:00.470 --> 00:21:03.350
这个流是完整的好吧

00:21:02.090 --> 00:21:06.320
那只是它的第一步

00:21:03.350 --> 00:21:08.299
写在我的应用程序上，现在每一次

00:21:06.320 --> 00:21:09.710
一会儿我们又遇到另一件事

00:21:08.299 --> 00:21:11.899
我们还在听，只是在等待

00:21:09.710 --> 00:21:14.000
它并以正确的方式编写，因此

00:21:11.899 --> 00:21:15.320
这类似于请求响应

00:21:14.000 --> 00:21:17.630
返回集合的地方

00:21:15.320 --> 00:21:20.950
每个元素单独进入是因为

00:21:17.630 --> 00:21:23.330
有效地永无止境的收藏

00:21:20.950 --> 00:21:25.940
这里的关键之一是

00:21:23.330 --> 00:21:27.860
我们拥有的第一个互动模型

00:21:25.940 --> 00:21:30.139
看看请求在哪里结束

00:21:27.860 --> 00:21:31.520
所谓的语义

00:21:30.139 --> 00:21:33.679
反应背压以及我们的原因

00:21:31.520 --> 00:21:35.750
称之为工作方式是

00:21:33.679 --> 00:21:38.510
您进行订阅，因此您基本上

00:21:35.750 --> 00:21:40.880
说嘿发布者，我们都准备好了

00:21:38.510 --> 00:21:43.549
是的，一切准备就绪，可以要求

00:21:40.880 --> 00:21:45.679
有效地请求八个请求

00:21:43.549 --> 00:21:47.600
这就是我们向

00:21:45.679 --> 00:21:50.000
发布者向我发送数据，所以关键

00:21:47.600 --> 00:21:52.520
这里的事情再次是假设

00:21:50.000 --> 00:21:53.600
我们说的第一件事，好的，去救我

00:21:52.520 --> 00:21:54.770
前一百二十八，但是

00:21:53.600 --> 00:21:55.940
实际上有一万件事

00:21:54.770 --> 00:21:58.190
最近一小时发生的

00:21:55.940 --> 00:22:00.049
是的，它不能寄给我一万

00:21:58.190 --> 00:22:01.100
它尚未实现，不准备发送

00:22:00.049 --> 00:22:02.539
突然我开始看到你知道

00:22:01.100 --> 00:22:04.789
大量数据通过手机进入

00:22:02.539 --> 00:22:06.980
哦，没有取消权，也许只有

00:22:04.789 --> 00:22:08.899
一万的一半

00:22:06.980 --> 00:22:10.279
它需要实现，而不必

00:22:08.899 --> 00:22:12.590
旋转下面的磁盘

00:22:10.279 --> 00:22:16.070
数据库来获取所有这些数据

00:22:12.590 --> 00:22:18.259
有巨大的性能改进

00:22:16.070 --> 00:22:20.109
您从中看到的，这是一个

00:22:18.259 --> 00:22:22.820
真正有趣的事情

00:22:20.109 --> 00:22:24.200
这个的原始作者

00:22:22.820 --> 00:22:26.809
特定协议是以下之一

00:22:24.200 --> 00:22:28.609
最终我应该说的原始作者

00:22:26.809 --> 00:22:30.739
去上班并带他去了

00:22:28.609 --> 00:22:32.330
 Facebook及其关键之处

00:22:30.739 --> 00:22:33.469
在寻找Facebook是

00:22:32.330 --> 00:22:36.070
我们要谈的效率

00:22:33.469 --> 00:22:37.849
大约一吨你知道的其他

00:22:36.070 --> 00:22:40.999
您将看到的改进

00:22:37.849 --> 00:22:42.919
随着谈话的进行，但是他们

00:22:40.999 --> 00:22:45.109
对这个想法真的很感兴趣

00:22:42.919 --> 00:22:47.119
他们不必实现一大堆

00:22:45.109 --> 00:22:48.679
永远不会获得客户的数据

00:22:47.119 --> 00:22:50.320
在你所知道的范围内

00:22:48.679 --> 00:22:53.239
像Facebook这样的东西

00:22:50.320 --> 00:22:57.169
物质美元价值想起你知道

00:22:53.239 --> 00:22:58.879
多少个应用程序多少个电话

00:22:57.169 --> 00:23:01.099
应用目前正在运行并已连接

00:22:58.879 --> 00:23:02.719
实际上在任何给定时间到Facebook 

00:23:01.099 --> 00:23:06.019
真的很重要

00:23:02.719 --> 00:23:07.249
差异，因此最终互动

00:23:06.019 --> 00:23:11.509
我们将要研究的模型

00:23:07.249 --> 00:23:13.940
这是频道我在这里的例子

00:23:11.509 --> 00:23:15.259
像我必须做的那样难以置信

00:23:13.940 --> 00:23:16.940
花了十分钟试图弄清楚

00:23:15.259 --> 00:23:17.989
它要求的东西

00:23:16.940 --> 00:23:20.200
您要使用的帐号

00:23:17.989 --> 00:23:22.429
以实时的

00:23:20.200 --> 00:23:23.779
帐户交易，但随后我按

00:23:22.429 --> 00:23:25.190
筛选器按钮和那个筛选器按钮

00:23:23.779 --> 00:23:27.289
说我只想让你给我看

00:23:25.190 --> 00:23:28.849
那是喝咖啡的，然后它就走了

00:23:27.289 --> 00:23:30.499
并列举了一个完整的列表

00:23:28.849 --> 00:23:32.479
然后我哥哥在我旁边

00:23:30.499 --> 00:23:33.950
去买咖啡，那就是

00:23:32.479 --> 00:23:35.989
唯一显示正确的东西

00:23:33.950 --> 00:23:37.849
真的签合同，我确定没有

00:23:35.989 --> 00:23:39.320
真正做到这一点的应用程序，但关键

00:23:37.849 --> 00:23:41.119
这里的事情很好，我们看到了变化

00:23:39.320 --> 00:23:42.889
有效载荷出来，我们希望那种

00:23:41.119 --> 00:23:45.440
数据流，但我们还有一个

00:23:42.889 --> 00:23:46.729
通量有效载荷进入，那些可能是

00:23:45.440 --> 00:23:48.259
两种不同类型的有效载荷

00:23:46.729 --> 00:23:50.839
必须对称，这是什么

00:23:48.259 --> 00:23:52.489
基本上是我要你开一个

00:23:50.839 --> 00:23:54.589
管道，我只是要发送一些

00:23:52.489 --> 00:23:56.599
有时会有消息，而你只是

00:23:54.589 --> 00:23:58.219
有时给我们发送消息，您可以

00:23:56.599 --> 00:24:00.979
做任何你想做的事情，如果你真的

00:23:58.219 --> 00:24:04.969
考虑一下非结构化渠道

00:24:00.979 --> 00:24:06.950
允许任何任意的交互模型

00:24:04.969 --> 00:24:08.659
就像你不喜欢其他三个

00:24:06.950 --> 00:24:10.549
互动模型以及这一模型

00:24:08.659 --> 00:24:12.289
实现我想要的任何东西

00:24:10.549 --> 00:24:13.940
发送一个，而您只能发送两个

00:24:12.289 --> 00:24:15.830
我要发送两个，你只能发送

00:24:13.940 --> 00:24:17.899
一，实际上并不重要，但是

00:24:15.830 --> 00:24:20.269
关键是，如果您可以思考

00:24:17.899 --> 00:24:21.739
这就是您可以进行的救助

00:24:20.269 --> 00:24:23.509
实际上实现所有其他

00:24:21.739 --> 00:24:23.960
渠道顶部的互动模型

00:24:23.509 --> 00:24:26.930
可以

00:24:23.960 --> 00:24:28.730
如果您愿意，但我们可以促进

00:24:26.930 --> 00:24:33.440
那些要成为其他三个

00:24:28.730 --> 00:24:36.980
一流的东西好吗

00:24:33.440 --> 00:24:41.120
很多东西大家好

00:24:36.980 --> 00:24:44.510
做得很好，让我们来看一些

00:24:41.120 --> 00:24:46.670
代码，您将非常高兴知道

00:24:44.510 --> 00:24:48.110
本演示的后续部分，我们做对了

00:24:46.670 --> 00:24:50.030
他们开始前十分钟左右

00:24:48.110 --> 00:24:51.380
启动团队结束了一次

00:24:50.030 --> 00:24:55.600
看看实际上最新的东西

00:24:51.380 --> 00:24:58.840
他们已经把它们放到位，所以

00:24:55.600 --> 00:25:04.910
我们的插座实际上是什么样的

00:24:58.840 --> 00:25:08.360
不，这是错误的，不是

00:25:04.910 --> 00:25:15.080
很好的信号哦，不，我知道了

00:25:08.360 --> 00:25:20.150
我知道我现在可以在哪里，所以我们的插座

00:25:15.080 --> 00:25:21.500
本身启动了关键的事情

00:25:20.150 --> 00:25:23.960
最后就是我们的想法

00:25:21.500 --> 00:25:26.390
插座工厂，我们的插座工厂是

00:25:23.960 --> 00:25:28.880
然后用于创建服务器或服务器

00:25:26.390 --> 00:25:31.700
客户的主要原则之一

00:25:28.880 --> 00:25:34.400
我们的套接字API是完美的

00:25:31.700 --> 00:25:43.000
对称还好，有这个东西

00:25:34.400 --> 00:25:43.000
在我们的插座中称为插座

00:25:43.149 --> 00:25:48.559
如果我能那样做

00:25:45.019 --> 00:25:51.529
我们的套接字有请求/响应

00:25:48.559 --> 00:25:53.899
即弃请求通道请求

00:25:51.529 --> 00:25:55.820
现在就在它上面流，如果你

00:25:53.899 --> 00:25:58.669
是实施者的主要收获

00:25:55.820 --> 00:25:59.779
这是因为如果我是服务器，我需要

00:25:58.669 --> 00:26:02.720
实现所有这些方法

00:25:59.779 --> 00:26:04.399
我周围的东西会呼唤那些

00:26:02.720 --> 00:26:06.679
我会尊重他们并回应他们

00:26:04.399 --> 00:26:09.019
但具有完美的对称性

00:26:06.679 --> 00:26:10.879
表示如果我是客户

00:26:09.019 --> 00:26:12.889
已经实现了这一点

00:26:10.879 --> 00:26:14.690
递给我，我称其中之一

00:26:12.889 --> 00:26:16.850
方法并从中获取响应

00:26:14.690 --> 00:26:18.499
不管这意味着你可以

00:26:16.850 --> 00:26:19.759
做一个我们将要执行的工作

00:26:18.499 --> 00:26:21.499
谈论网络传输

00:26:19.759 --> 00:26:23.659
网络传输的第二个是

00:26:21.499 --> 00:26:25.460
只是有一个物体而你

00:26:23.659 --> 00:26:26.570
讲一种方法和另一种方法

00:26:25.460 --> 00:26:28.190
只是通过这个界面你

00:26:26.570 --> 00:26:30.740
真的不知道会发生什么，但这

00:26:28.190 --> 00:26:32.419
赋予我们这种强大的能力

00:26:30.740 --> 00:26:33.559
具有对称性和易用性

00:26:32.419 --> 00:26:39.830
了解易于实施

00:26:33.559 --> 00:26:42.440
这些东西之间还好

00:26:39.830 --> 00:26:44.450
所以在这种情况下，我们要

00:26:42.440 --> 00:26:46.970
通过接收我们来设置服务器

00:26:44.450 --> 00:26:49.429
放入我们的插座

00:26:46.970 --> 00:26:51.679
实施到它，我们要去

00:26:49.429 --> 00:26:53.059
说我们将使用WebSocket 

00:26:51.679 --> 00:26:54.860
作为交通工具，我们将讨论

00:26:53.059 --> 00:26:57.139
稍后，我们开始

00:26:54.860 --> 00:26:58.879
家伙起来，最终发生的是

00:26:57.139 --> 00:27:01.580
在某个时候某人会做出

00:26:58.879 --> 00:27:03.110
呼叫在有效载荷中传递给我们

00:27:01.580 --> 00:27:04.940
下降到非常低的水平，我们处理了很多

00:27:03.110 --> 00:27:07.820
在这个特定的字节缓冲区

00:27:04.940 --> 00:27:10.039
关键时刻，这些有效载荷将具有

00:27:07.820 --> 00:27:12.740
里面有一个数字，所以我们要

00:27:10.039 --> 00:27:14.570
解析出其中的数字

00:27:12.740 --> 00:27:17.570
我们会继续说，嘿，我们收到了

00:27:14.570 --> 00:27:19.820
这个号码在这里，然后我们

00:27:17.570 --> 00:27:22.399
将产生一堆回应

00:27:19.820 --> 00:27:23.929
在另一个方向上

00:27:22.399 --> 00:27:26.929
特殊情况，因为我们正在做

00:27:23.929 --> 00:27:28.580
请求流一进一出等

00:27:26.929 --> 00:27:30.559
在这种情况下，如果您愿意，我们会说好的

00:27:28.580 --> 00:27:32.330
给我一个，我将从零开始给你

00:27:30.559 --> 00:27:33.860
如果你给我两个我要给

00:27:32.330 --> 00:27:35.749
你零一二如果你寄给我十我是

00:27:33.860 --> 00:27:37.429
要给你零一三我们

00:27:35.749 --> 00:27:39.889
会将所有数据发送回

00:27:37.429 --> 00:27:42.940
您和我们只是将其映射回

00:27:39.889 --> 00:27:42.940
的字符串点值

00:27:43.429 --> 00:27:47.839
那客户看起来怎么样

00:27:45.529 --> 00:27:49.700
我们再次看到行动中的对称性

00:27:47.839 --> 00:27:50.989
套接字客户端工厂

00:27:49.700 --> 00:27:52.070
我们将继续进行连接

00:27:50.989 --> 00:27:54.139
我们要出站的时间

00:27:52.070 --> 00:27:56.119
通过Web客户端传输进行连接

00:27:54.139 --> 00:27:58.999
在这种情况下，我们将

00:27:56.119 --> 00:28:01.039
说好，我想发送我的请求

00:27:58.999 --> 00:28:03.499
会在0到10之间熄灭

00:28:01.039 --> 00:28:06.379
将在此处创建这些有效载荷之一

00:28:03.499 --> 00:28:09.820
我们将调用我们的套接字请求

00:28:06.379 --> 00:28:11.029
现在想像一下

00:28:09.820 --> 00:28:13.940
对称

00:28:11.029 --> 00:28:16.099
我们的套接字请求流传入

00:28:13.940 --> 00:28:19.249
信息很像打电话给我们

00:28:16.099 --> 00:28:20.690
套接字请求流就在这里

00:28:19.249 --> 00:28:24.619
我们只有那一半

00:28:20.690 --> 00:28:26.149
对称互动，然后一旦

00:28:24.619 --> 00:28:27.589
向我们发送了很多数据

00:28:26.149 --> 00:28:29.599
在这里做了平坦的罂粟花

00:28:27.589 --> 00:28:30.830
基本上说好的请求流是

00:28:29.599 --> 00:28:32.299
会递给我一系列数据

00:28:30.830 --> 00:28:34.099
返回当我发送一个它将要发送

00:28:32.299 --> 00:28:36.320
当我发送2时我0和1 

00:28:34.099 --> 00:28:39.859
它会寄给我0 1 2然后0 1 3 

00:28:36.320 --> 00:28:41.629
从理论上一直上升到10 

00:28:39.859 --> 00:28:44.799
等待那完成，让我们开始吧

00:28:41.629 --> 00:28:44.799
提前启动服务器

00:28:55.539 --> 00:28:58.690
每天晚上

00:28:59.730 --> 00:29:08.200
是的，我想这已经

00:29:06.070 --> 00:29:11.640
在演示上做得很好，只是一个

00:29:08.200 --> 00:29:11.640
时间问题，直到它在我这里失败

00:29:12.090 --> 00:29:17.590
所以我们在这里看到了什么

00:29:14.950 --> 00:29:18.550
发送大量数据0 1 2 3 4 

00:29:17.590 --> 00:29:19.990
 5 6 7 8 9 

00:29:18.550 --> 00:29:22.660
记住只有一个

00:29:19.990 --> 00:29:24.670
在80 81连接所有这些东西

00:29:22.660 --> 00:29:26.380
必须出去，但突然之间我

00:29:24.670 --> 00:29:29.020
看到一堆处理程序进入

00:29:26.380 --> 00:29:30.340
各种随机排序，尤其是

00:29:29.020 --> 00:29:32.170
当我们开始在这里下车以及如何

00:29:30.340 --> 00:29:34.450
通常这些回来没有

00:29:32.170 --> 00:29:36.160
订单保证，我们看到服务器

00:29:34.450 --> 00:29:37.900
这边收到一堆东西

00:29:36.160 --> 00:29:39.730
之前有两件事

00:29:37.900 --> 00:29:42.210
它开始发送东西回来，所以

00:29:39.730 --> 00:29:47.680
排序实际上并不重要

00:29:42.210 --> 00:29:49.780
每次我们都有效

00:29:47.680 --> 00:29:51.730
服务器，我们将听到每一个

00:29:49.780 --> 00:29:53.530
当一个新的请求来到这里我们

00:29:51.730 --> 00:29:55.870
完全不执行

00:29:53.530 --> 00:29:58.330
如果我们做了某种

00:29:55.870 --> 00:29:59.950
线程睡眠一段时间

00:29:58.330 --> 00:30:02.890
没关系，所有这些都是

00:29:59.950 --> 00:30:04.720
同时在飞行中

00:30:02.890 --> 00:30:05.950
围绕这个请求流的想法，如果

00:30:04.720 --> 00:30:07.900
我想做一个要求

00:30:05.950 --> 00:30:09.910
您可以反而说嘿

00:30:07.900 --> 00:30:12.310
请求答复我要实施

00:30:09.910 --> 00:30:14.470
以某种方式我得到了有效载荷

00:30:12.310 --> 00:30:16.000
然后我返回单声道有效载荷

00:30:14.470 --> 00:30:17.800
某种转变也许我会去

00:30:16.000 --> 00:30:20.760
到数据库并进行某种查询

00:30:17.800 --> 00:30:20.760
这样的东西

00:30:22.750 --> 00:30:25.410
好的

00:30:25.630 --> 00:30:29.410
所以让我们多谈一点

00:30:27.940 --> 00:30:31.120
有趣的事情不仅仅是

00:30:29.410 --> 00:30:32.470
我们套接字的编程模型或

00:30:31.120 --> 00:30:34.360
插座事实证明，这是

00:30:32.470 --> 00:30:36.100
我认为这真的吸引了我

00:30:34.360 --> 00:30:37.660
参加该项目，然后说我想

00:30:36.100 --> 00:30:39.309
实际上成为这个的提交者

00:30:37.660 --> 00:30:41.799
我想在那里的特殊事物

00:30:39.309 --> 00:30:44.020
对此的支持者是

00:30:41.799 --> 00:30:46.090
套接字是最疯狂的套接字之一

00:30:44.020 --> 00:30:48.130
灵活的协议

00:30:46.090 --> 00:30:50.830
完全不可知的语言是

00:30:48.130 --> 00:30:52.900
根据帧传输定义

00:30:50.830 --> 00:30:54.299
通过网络传输的二进制帧

00:30:52.900 --> 00:30:56.740
这意味着我们已经有

00:30:54.299 --> 00:31:01.510
 Java和C ++中的实现是

00:30:56.740 --> 00:31:03.690
可能是最成熟的Java 

00:31:01.510 --> 00:31:06.010
特别是因为Netflix和

00:31:03.690 --> 00:31:07.690
与春季团队C ++的联系

00:31:06.010 --> 00:31:10.270
碰巧是一种旅行的语言

00:31:07.690 --> 00:31:11.650
 Facebook JavaScript，因为所有人

00:31:10.270 --> 00:31:13.960
想要在网络浏览器中执行此操作

00:31:11.650 --> 00:31:15.850
 Kotlin走了，还有更多

00:31:13.960 --> 00:31:17.950
所以除了是语言

00:31:15.850 --> 00:31:19.450
不可知的，它也是不可知的

00:31:17.950 --> 00:31:21.580
我们会看到一些发送

00:31:19.450 --> 00:31:23.679
我个人会一直发送的protobuf 

00:31:21.580 --> 00:31:25.780
杰森，但如果您更喜欢C 

00:31:23.679 --> 00:31:27.190
一些自定义的二进制协议

00:31:25.780 --> 00:31:29.620
因为你正朝着

00:31:27.190 --> 00:31:31.330
您可以肯定地发送的效率

00:31:29.620 --> 00:31:34.000
您想要的任何有效负载都不是

00:31:31.330 --> 00:31:36.370
像G RPC之类的东西

00:31:34.000 --> 00:31:38.530
你必须发送protobufs什么都没有

00:31:36.370 --> 00:31:40.390
否则最后就是运输

00:31:38.530 --> 00:31:43.059
不可知的也是

00:31:40.390 --> 00:31:45.220
真的很关键，因为它可以让您

00:31:43.059 --> 00:31:47.289
在可以的地方通过TCP 

00:31:45.220 --> 00:31:49.270
通常在数据中心内部

00:31:47.289 --> 00:31:51.130
通过TCP，而没有

00:31:49.270 --> 00:31:53.409
像WebSockets或

00:31:51.130 --> 00:31:55.360
 HTTP可能是最有效的方法

00:31:53.409 --> 00:31:58.390
您实际上将能够传输数据

00:31:55.360 --> 00:32:00.220
跨网络WebSockets虽然存在

00:31:58.390 --> 00:32:03.010
对于您没有的情况

00:32:00.220 --> 00:32:04.539
在开放的互联网上说您的电话

00:32:03.010 --> 00:32:07.270
无论您的边缘服务器位于

00:32:04.539 --> 00:32:09.159
云，您可以使用HTTP 2获得

00:32:07.270 --> 00:32:12.429
因为我们可以提高效率

00:32:09.159 --> 00:32:14.919
有点背piggy式

00:32:12.429 --> 00:32:17.080
 HTTP 2的多路传输，如果您

00:32:14.919 --> 00:32:18.429
疯狂和金融业中的那些

00:32:17.080 --> 00:32:20.350
两件事在一起很多

00:32:18.429 --> 00:32:23.350
可以使用Aeron协议

00:32:20.350 --> 00:32:25.330
超高速UDP保证交付

00:32:23.350 --> 00:32:27.039
与对称bla bla bla不知道

00:32:25.330 --> 00:32:29.770
这显然是最快的

00:32:27.039 --> 00:32:32.710
事情，但鉴于TCP，我们经常

00:32:29.770 --> 00:32:35.080
每秒看到60,000个请求

00:32:32.710 --> 00:32:36.980
这似乎真的结束了很多

00:32:35.080 --> 00:32:39.409
称呼过度杀伤权

00:32:36.980 --> 00:32:48.200
但是如果我们说它很灵活， 

00:32:39.409 --> 00:32:50.779
灵活吗？ 

00:32:48.200 --> 00:32:53.679
如果我告诉你从

00:32:50.779 --> 00:32:57.970
我们说过的WebSocket最多

00:32:53.679 --> 00:32:59.570
我们所说的有效的数据传输方式

00:32:57.970 --> 00:33:01.309
好的

00:32:59.570 --> 00:33:02.990
我只是想用TCP代替

00:33:01.309 --> 00:33:05.690
因为下面的可插拔层

00:33:02.990 --> 00:33:07.610
框架都是关于二进制封装的

00:33:05.690 --> 00:33:09.590
需要从点发送的消息

00:33:07.610 --> 00:33:12.260
 A指向B事实已发送

00:33:09.590 --> 00:33:16.120
通过TCP无关紧要

00:33:12.260 --> 00:33:16.120
之后的网络堆栈

00:33:22.740 --> 00:33:26.659
在另一边做同样的事情

00:33:34.040 --> 00:33:39.980
我们在那边看到一个小人

00:33:36.980 --> 00:33:42.080
收到八个数据已发送未

00:33:39.980 --> 00:33:43.670
效果几乎没有

00:33:42.080 --> 00:33:46.330
影响我们的任何计划权利

00:33:43.670 --> 00:33:49.040
我们的实际应用程序代码几乎没有

00:33:46.330 --> 00:33:50.600
影响了这里的配置，我们可以

00:33:49.040 --> 00:33:52.610
放了两个我们本来可以放的HTTP 

00:33:50.600 --> 00:33:54.140
 Aeron真的很容易得到

00:33:52.610 --> 00:33:55.910
可移植性，但真正的关键之一

00:33:54.140 --> 00:33:57.620
事情是很有可能的，如果你

00:33:55.910 --> 00:33:59.480
真的采用了我们的插座

00:33:57.620 --> 00:34:01.400
您可能会在异构环境中

00:33:59.480 --> 00:34:03.710
内部服务器到服务器

00:34:01.400 --> 00:34:05.690
数据中心在外部使用TCP 

00:34:03.710 --> 00:34:06.800
在设备和边缘服务器之间

00:34:05.690 --> 00:34:09.530
您将使用类似

00:34:06.800 --> 00:34:11.149
 WebSockets或h2，但您不必

00:34:09.530 --> 00:34:13.220
学习一个新的编程模型

00:34:11.149 --> 00:34:15.800
只是您的配置选择

00:34:13.220 --> 00:34:18.350
必须使这真的是真的

00:34:15.800 --> 00:34:20.810
重要的灵活性再次

00:34:18.350 --> 00:34:23.750
戳其他协议h2或总线

00:34:20.810 --> 00:34:24.950
对，所以基本上安全港声明

00:34:23.750 --> 00:34:27.050
说我要告诉你的一切

00:34:24.950 --> 00:34:32.330
可能是我们还不知道的谎言

00:34:27.050 --> 00:34:34.760
所以其他一些灵活性

00:34:32.330 --> 00:34:37.010
对于我们的套接字，它是编程模型

00:34:34.760 --> 00:34:39.230
与我们的套接字接口无关

00:34:37.010 --> 00:34:40.909
是可用的编程模型，但不是

00:34:39.230 --> 00:34:43.040
很棒，它被设计成一栋建筑

00:34:40.909 --> 00:34:46.280
阻止开始听到我的主题

00:34:43.040 --> 00:34:48.200
谈论正确的artoo DBC设计为

00:34:46.280 --> 00:34:51.139
构件不是人性化的API人员

00:34:48.200 --> 00:34:52.820
不要在我们的插座上使用此权限

00:34:51.139 --> 00:34:54.830
界面与您非常相似

00:34:52.820 --> 00:34:56.600
可以像代码不是那样使用它

00:34:54.830 --> 00:34:59.150
我见过的最糟糕的代码，但是

00:34:56.600 --> 00:35:01.100
实际上，您是高层次的

00:34:59.150 --> 00:35:02.750
开发人员想要的抽象应用程序

00:35:01.100 --> 00:35:08.330
有些不同，也许您想要RPC 

00:35:02.750 --> 00:35:10.130
也许您想要消息传递样式，所以让我们

00:35:08.330 --> 00:35:12.040
看看其他机会

00:35:10.130 --> 00:35:19.190
那里

00:35:12.040 --> 00:35:21.920
所以我对G RPC说嘘声嘘声，但我明白了

00:35:19.190 --> 00:35:24.260
就像我得到RPC一样，我实际上已经够老了

00:35:21.920 --> 00:35:26.570
我记得上一次RPC失败像

00:35:24.260 --> 00:35:28.430
在90年代末2000年代初，由于

00:35:26.570 --> 00:35:29.780
所有的紧密耦合，但这是

00:35:28.430 --> 00:35:31.250
我们所处的行业，我们必须再次做

00:35:29.780 --> 00:35:31.670
我们将再次失败

00:35:31.250 --> 00:35:33.800
惊人

00:35:31.670 --> 00:35:36.140
所以你是那种真正的人

00:35:33.800 --> 00:35:37.340
喜欢RPC交互模型，而您

00:35:36.140 --> 00:35:39.140
非常喜欢确保您所有的

00:35:37.340 --> 00:35:41.390
客户端和您所有的服务器都是

00:35:39.140 --> 00:35:43.550
绝对总是与同步

00:35:41.390 --> 00:35:45.800
零兼容性问题

00:35:43.550 --> 00:35:46.640
可能也是使用mono仓库的人

00:35:45.800 --> 00:35:49.130
我不明白

00:35:46.640 --> 00:35:51.650
让我们定义一个简单的服务吧

00:35:49.130 --> 00:35:53.900
服务请求极值请求

00:35:51.650 --> 00:35:55.430
我们定义了另一种价值流

00:35:53.900 --> 00:35:57.440
消息请求来自

00:35:55.430 --> 00:36:00.170
消息响应回退这是

00:35:57.440 --> 00:36:03.770
一种简单的protobuf或

00:36:00.170 --> 00:36:05.930
对不起IDL样式配置这个我们

00:36:03.770 --> 00:36:08.900
编译成我们注入的protobuf 

00:36:05.930 --> 00:36:16.340
有些是套接字RPC优点

00:36:08.900 --> 00:36:19.150
在它后面，以便在您的服务器上

00:36:16.340 --> 00:36:21.430
拥有这些简单的服务之一

00:36:19.150 --> 00:36:24.050
实际上这不是最坏的

00:36:21.430 --> 00:36:26.240
我见过的protobuf代码，但它有

00:36:24.050 --> 00:36:27.950
我们两种方法的另一个要求

00:36:26.240 --> 00:36:29.660
值流请求成为

00:36:27.950 --> 00:36:31.550
值接受一个简单的请求作为

00:36:29.660 --> 00:36:38.270
有效负载简单请求和一些有效负载

00:36:31.550 --> 00:36:41.270
从那里，这意味着我们可以

00:36:38.270 --> 00:36:43.310
简单地实现这个权利就是

00:36:41.270 --> 00:36:46.700
请求某种类型的值流

00:36:43.310 --> 00:36:49.240
真正的RPC风格

00:36:46.700 --> 00:36:52.040
非常语义化的上下文

00:36:49.240 --> 00:36:53.780
易于理解的API返回

00:36:52.040 --> 00:36:55.250
通量简单的响应需要

00:36:53.780 --> 00:36:56.810
在这种情况下的简单要求

00:36:55.250 --> 00:36:58.880
做我们要去的完全相同的事情

00:36:56.810 --> 00:37:01.280
到请求消息中拉出任何东西

00:36:58.880 --> 00:37:02.570
数字是从它返回一个范围

00:37:01.280 --> 00:37:06.080
这些事情，因为我们要

00:37:02.570 --> 00:37:11.120
返回这些响应的范围，让我们

00:37:06.080 --> 00:37:12.380
继续并开始这一步，我想我

00:37:11.120 --> 00:37:15.620
确保从现在开始我们一直在使用

00:37:12.380 --> 00:37:17.030
 TCP也是如此，即使使用这种RPC样式

00:37:15.620 --> 00:37:18.710
我们可以轻松地通过

00:37:17.030 --> 00:37:25.150
更改WebSocket或其他方法

00:37:18.710 --> 00:37:28.040
您在客户端看到的

00:37:25.150 --> 00:37:29.930
这在世界上某个地方很棒

00:37:28.040 --> 00:37:31.400
这些简单的服务之一

00:37:29.930 --> 00:37:33.530
客户让我们看看这是什么

00:37:31.400 --> 00:37:36.500
事情是否有更多的代码

00:37:33.530 --> 00:37:37.400
这次，但是看起来非常非常

00:37:36.500 --> 00:37:39.320
对称的

00:37:37.400 --> 00:37:40.880
这里要求另一个价值流

00:37:39.320 --> 00:37:42.890
接受一个简单的请求和一辆自行车

00:37:40.880 --> 00:37:44.780
要求这里而不是

00:37:42.890 --> 00:37:46.400
请求另一个这里的请求简单

00:37:44.780 --> 00:37:48.020
请求和自行车按钮，以便我可以建立

00:37:46.400 --> 00:37:52.780
所有这些东西与这种

00:37:48.020 --> 00:37:52.780
直接非常直接的编程模型

00:37:54.060 --> 00:37:59.800
刚开始使用计划就可以了

00:37:57.880 --> 00:38:02.080
所以我创建了一个新的客户

00:37:59.800 --> 00:38:03.820
传入我们的套接字客户端

00:38:02.080 --> 00:38:06.460
创建，这使我有能力

00:38:03.820 --> 00:38:07.900
为自己创建一个新的简单请求， 

00:38:06.460 --> 00:38:10.000
设置其消息将是什么， 

00:38:07.900 --> 00:38:12.580
然后发出请求请求流

00:38:10.000 --> 00:38:14.200
值或请求其他流

00:38:12.580 --> 00:38:16.450
值，如果我想走那条路

00:38:14.200 --> 00:38:18.430
而是获得很好的自动完成功能

00:38:16.450 --> 00:38:19.720
看起来像调用任何其他方法

00:38:18.430 --> 00:38:24.180
它正在通过网络的事实

00:38:19.720 --> 00:38:24.180
对你不可见

00:38:29.260 --> 00:38:35.510
所以输出再次做了很多

00:38:32.810 --> 00:38:37.340
这正是我们想要的一步

00:38:35.510 --> 00:38:40.580
在我们的套接字接口上方

00:38:37.340 --> 00:38:42.050
我认为这是一个非常好的策略

00:38:40.580 --> 00:38:43.520
我们都可以同意使用我们的套接字

00:38:42.050 --> 00:38:48.500
即使我们不同意，界面也不是很好

00:38:43.520 --> 00:38:54.130
在RPC上，那么第三种怎么样

00:38:48.500 --> 00:38:56.590
对，如果你熟悉 Spring 

00:38:54.130 --> 00:38:58.730
不要看那倒计时闩锁

00:38:56.590 --> 00:39:00.710
这就是我们正在努力的一点

00:38:58.730 --> 00:39:03.320
如果您熟悉的话，在最后

00:39:00.710 --> 00:39:05.980
 Spring 是我们要做的事情之一

00:39:03.320 --> 00:39:09.200
一直很擅长的是

00:39:05.980 --> 00:39:11.870
这个想法让你只写

00:39:09.200 --> 00:39:13.700
有一些输入的方法

00:39:11.870 --> 00:39:15.680
您可以基本上选择一些输出

00:39:13.700 --> 00:39:18.020
你想要的任何该死的东西

00:39:15.680 --> 00:39:20.500
上面的注释说嘿这是什么

00:39:18.020 --> 00:39:22.970
我要你做对

00:39:20.500 --> 00:39:25.940
 HTTP控制或对不起的Web MVC 

00:39:22.970 --> 00:39:27.410
控制器或卷筒纸流量控制器或

00:39:25.940 --> 00:39:29.360
像这样的东西给你

00:39:27.410 --> 00:39:30.590
与事物之间的耦合非常松散

00:39:29.360 --> 00:39:31.880
会打电话给你，你不会

00:39:30.590 --> 00:39:33.530
知道它将如何到达那里，但是

00:39:31.880 --> 00:39:35.840
有人会说我想

00:39:33.530 --> 00:39:37.670
发送或我想调用请求流

00:39:35.840 --> 00:39:38.690
向您传递有效载荷，我要您

00:39:37.670 --> 00:39:40.610
退还给我

00:39:38.690 --> 00:39:43.130
再次，我们做完全一样的事情

00:39:40.610 --> 00:39:45.470
我们一直都在那里做着

00:39:43.130 --> 00:39:46.940
通量范围在您返回的途中

00:39:45.470 --> 00:39:49.760
注意，其中一项大交易是

00:39:46.940 --> 00:39:51.500
 Spring 这个时候我们不使用有效载荷

00:39:49.760 --> 00:39:53.990
关于自动类型真的很不错

00:39:51.500 --> 00:39:55.700
也是强制的，所以我们有一点是

00:39:53.990 --> 00:39:58.280
将为我们转换成字符串

00:39:55.700 --> 00:39:59.780
在这里，我们将继续并返回一个字符串

00:39:58.280 --> 00:40:01.580
它将返回它将被拒绝

00:39:59.780 --> 00:40:04.610
那些需要发送的字节增益

00:40:01.580 --> 00:40:06.620
回到另一边

00:40:04.610 --> 00:40:09.710
在这种情况下我很棒

00:40:06.620 --> 00:40:12.140
使用 spring boot 2.2M3，我做了

00:40:09.710 --> 00:40:16.600
没有，不是，那不是真的，我撒谎了

00:40:12.140 --> 00:40:19.100
在服务器端，我必须要做

00:40:16.600 --> 00:40:21.050
应用程序属性我不得不说

00:40:19.100 --> 00:40:24.680
我们将在80 83听

00:40:21.050 --> 00:40:26.829
 Spring 的东西根本不是我

00:40:24.680 --> 00:40:30.740
想做

00:40:26.829 --> 00:40:32.240
服务器，我们做了一点

00:40:30.740 --> 00:40:34.789
定制只是它知道如何

00:40:32.240 --> 00:40:37.910
默认情况下对字符串进行编码和解码

00:40:34.789 --> 00:40:39.650
直到大约30分钟前

00:40:37.910 --> 00:40:42.380
致力于 Spring 引导它只

00:40:39.650 --> 00:40:44.569
确实看到了无聊和杰森，但现在它将

00:40:42.380 --> 00:40:46.789
 Spring 对不起，它也会打弦

00:40:44.569 --> 00:40:48.799
但易于使用的自定义方式

00:40:46.789 --> 00:40:50.359
标准 spring boot 的一种方式

00:40:48.799 --> 00:40:52.930
在这里进行定制，我们将继续

00:40:50.359 --> 00:40:55.309
并解雇这件事

00:40:52.930 --> 00:40:57.109
所以现在我们突然有了服务器

00:40:55.309 --> 00:40:58.700
没有实现接口

00:40:57.109 --> 00:41:00.950
直接，这样可以多一点

00:40:58.700 --> 00:41:02.750
灵活地知道某人的

00:41:00.950 --> 00:41:05.270
要求我路由以请求流式传输

00:41:02.750 --> 00:41:08.119
想向我发送基于字符串的有效载荷

00:41:05.270 --> 00:41:09.829
我想发送一串基于

00:41:08.119 --> 00:41:12.920
有效载荷朝着另一个方向

00:41:09.829 --> 00:41:16.339
看到meteora套接字服务器是

00:41:12.920 --> 00:41:17.839
现在在8080三Spring 客户端上运行

00:41:16.339 --> 00:41:19.099
进去看起来像什么

00:41:17.839 --> 00:41:21.109
另一个方向，这实际上不是

00:41:19.099 --> 00:41:23.359
确实是春季应用，但我们有这个

00:41:21.109 --> 00:41:26.119
一种叫做我们的套接字的实用程序

00:41:23.359 --> 00:41:28.579
请求者包装了我们的套接字客户端

00:41:26.119 --> 00:41:30.049
副作用这又是我的设置

00:41:28.579 --> 00:41:32.359
进行一些配置，希望您

00:41:30.049 --> 00:41:34.609
不需要m4 rc1的时间

00:41:32.359 --> 00:41:36.410
出来，但在这里我们要做

00:41:34.609 --> 00:41:41.390
我们要说的东西嘿嘿

00:41:36.410 --> 00:41:43.490
请求者去给我留言

00:41:41.390 --> 00:41:45.200
请求流我看到的那个端点

00:41:43.490 --> 00:41:48.140
在另一边，我要你发送

00:41:45.200 --> 00:41:50.270
这些数据，我要你去还给我

00:41:48.140 --> 00:41:52.010
一串串的字符串，你会

00:41:50.270 --> 00:41:54.200
当你说这基本上翻译

00:41:52.010 --> 00:41:57.049
有效地恢复流量是在说

00:41:54.200 --> 00:41:58.730
嘿执行请求流给我

00:41:57.049 --> 00:42:01.609
我会自动返回一堆数据

00:41:58.730 --> 00:42:04.880
类型将其插入字符串，然后

00:42:01.609 --> 00:42:09.109
发射更多数据我运行了一次

00:42:04.880 --> 00:42:11.690
所以是的，我们去了，一切都来了

00:42:09.109 --> 00:42:13.369
返回，所以有多种方法，因为

00:42:11.690 --> 00:42:16.309
我们的插座是如此灵活，以至于

00:42:13.369 --> 00:42:18.140
坐在这个三明治之间

00:42:16.309 --> 00:42:19.520
没有草药的协议是一堆

00:42:18.140 --> 00:42:21.559
无关的网络传输

00:42:19.520 --> 00:42:23.000
关于和一堆编程模型

00:42:21.559 --> 00:42:24.829
和无关紧要的有效载荷

00:42:23.000 --> 00:42:27.490
坐在它上面使它真的

00:42:24.829 --> 00:42:27.490
真的很灵活

00:42:28.740 --> 00:42:33.000
所以你看过这三个原始的

00:42:30.869 --> 00:42:36.480
套接字RPC样式消息传递样式

00:42:33.000 --> 00:42:38.910
在我们的PC上对IM真正感兴趣

00:42:36.480 --> 00:42:41.190
显然，但我知道该行业已经

00:42:38.910 --> 00:42:43.170
非常喜欢它，所以我们

00:42:41.190 --> 00:42:44.760
对听到你的声音很感兴趣

00:42:43.170 --> 00:42:46.710
我们应该集中精力做些什么

00:42:44.760 --> 00:42:49.290
进入我们的PC赌注，还是我们应该

00:42:46.710 --> 00:42:51.599
将更多精力投入到消息传递中

00:42:49.290 --> 00:42:53.250
风格还有别的

00:42:51.599 --> 00:42:55.080
您想要的协议编程模型

00:42:53.250 --> 00:42:57.000
希望看到我们还没有证明

00:42:55.080 --> 00:42:58.950
在这里与 The Spring Team 交谈

00:42:57.000 --> 00:43:00.900
足球队与我们的足球队交谈

00:42:58.950 --> 00:43:03.109
真的很感兴趣

00:43:00.900 --> 00:43:05.790
你将要使用这样的东西

00:43:03.109 --> 00:43:07.470
所以我们要花剩下的大部分时间

00:43:05.790 --> 00:43:09.810
这次谈论其他功能

00:43:07.470 --> 00:43:11.640
在我们的套接字协议中

00:43:09.810 --> 00:43:13.560
因为清楚地向回发送数据， 

00:43:11.640 --> 00:43:15.750
第四，这就是我们在这里

00:43:13.560 --> 00:43:17.550
但是就像我之前所说的那样

00:43:15.750 --> 00:43:19.470
团队坐下来说我们想做

00:43:17.550 --> 00:43:21.000
更好的是他们并没有停止我想要的

00:43:19.470 --> 00:43:23.339
更好地传输数据

00:43:21.000 --> 00:43:26.450
其实坐下来是他们说我

00:43:23.339 --> 00:43:28.890
想要进行分布式通信

00:43:26.450 --> 00:43:30.510
更好的权利，他们不只是停下来

00:43:28.890 --> 00:43:31.980
说嘿，我只需要请求/响应

00:43:30.510 --> 00:43:34.800
对于这四件事和一些框架

00:43:31.980 --> 00:43:36.839
来回去我们可以做什么

00:43:34.800 --> 00:43:39.270
协议，使我们可以删除

00:43:36.839 --> 00:43:42.150
我们看到的一堆开销

00:43:39.270 --> 00:43:43.770
其他分布式系统，因此

00:43:42.150 --> 00:43:45.180
他们做的第一件事是

00:43:43.770 --> 00:43:47.580
单帧传回

00:43:45.180 --> 00:43:50.400
每个单帧来回大多数帧

00:43:47.580 --> 00:43:52.589
具有可选的元数据有效载荷

00:43:50.400 --> 00:43:54.869
与它相关联，所以我们您

00:43:52.589 --> 00:43:56.550
必须先定义一下，嘿，我是

00:43:54.869 --> 00:43:58.320
将发送元数据，而元数据是

00:43:56.550 --> 00:43:59.880
将是这种思维类型，所以

00:43:58.320 --> 00:44:00.990
完全非结构化的选择

00:43:59.880 --> 00:44:02.130
你想发送一堆JSON如何

00:44:00.990 --> 00:44:05.070
你想只发送一个字符串吗

00:44:02.130 --> 00:44:06.750
你想一起发送CSV吗？ 

00:44:05.070 --> 00:44:08.820
因为元数据给你足够

00:44:06.750 --> 00:44:11.250
信息，以便您可以解码

00:44:08.820 --> 00:44:13.550
元数据说，并与您

00:44:11.250 --> 00:44:15.630
生活是正确的，所以它超级灵活， 

00:44:13.550 --> 00:44:17.940
通常用于携带元数据

00:44:15.630 --> 00:44:19.950
关于数据有效载荷中的内容

00:44:17.940 --> 00:44:21.510
现在意味着

00:44:19.950 --> 00:44:24.980
您实际上可以发送的连接

00:44:21.510 --> 00:44:29.010
异类数据想象

00:44:24.980 --> 00:44:30.810
需要发送一堆的公司

00:44:29.010 --> 00:44:32.040
社交媒体到您的手机中

00:44:30.810 --> 00:44:33.630
可能是文本，其中一些可能是

00:44:32.040 --> 00:44:35.640
图片其中一些可能全部是视频

00:44:33.630 --> 00:44:37.650
在同一连接上，因为每个

00:44:35.640 --> 00:44:39.599
他们遇到的单个有效载荷

00:44:37.650 --> 00:44:41.160
有能力看看

00:44:39.599 --> 00:44:42.119
与此框架关联的元数据和

00:44:41.160 --> 00:44:53.009
说嘿

00:44:42.119 --> 00:44:56.190
我应该将其编码为141吗？ 

00:44:53.009 --> 00:44:58.619
有碎片有效载荷的想法

00:44:56.190 --> 00:45:00.390
克，所以一定要说这个

00:44:58.619 --> 00:45:04.109
昨晚很晚

00:45:00.390 --> 00:45:05.519
有效负载帧没有最大大小

00:45:04.109 --> 00:45:07.039
这不能是来自

00:45:05.519 --> 00:45:10.140
负责哪个公司

00:45:07.039 --> 00:45:11.700
超过50％的人占绝大多数

00:45:10.140 --> 00:45:13.170
考虑互联网上的所有流量

00:45:11.700 --> 00:45:15.450
他们真的很喜欢给你很大

00:45:13.170 --> 00:45:17.430
高品质的视频，所以它真的

00:45:15.450 --> 00:45:19.259
非常适合服务于此类

00:45:17.430 --> 00:45:21.269
有效载荷，但现实

00:45:19.259 --> 00:45:23.940
情况是我是否必须寄给您

00:45:21.269 --> 00:45:27.569
框架让您知道整个4个演出

00:45:23.940 --> 00:45:29.609
最新高清高清4k HDR视频

00:45:27.569 --> 00:45:31.440
复仇者联盟电影或其中的某些内容

00:45:29.609 --> 00:45:32.730
会杀死您的网络连接

00:45:31.440 --> 00:45:34.859
无法处理那样的事情

00:45:32.730 --> 00:45:37.079
 tcp mt和通用

00:45:34.859 --> 00:45:38.549
可靠性，所以它有这样的想法

00:45:37.079 --> 00:45:40.559
碎片化但已处理

00:45:38.549 --> 00:45:42.569
透明地你可以说嘿我知道

00:45:40.559 --> 00:45:44.069
即使我我也知道

00:45:42.569 --> 00:45:45.990
需要给您发送4场演出，我可能只

00:45:44.069 --> 00:45:48.119
想要一次发送给您1 Meg 

00:45:45.990 --> 00:45:49.829
如果1 Meg失败，我们可以重试

00:45:48.119 --> 00:45:52.559
我不想等待的另一个裂缝

00:45:49.829 --> 00:45:53.849
让我们喜欢3.99演出，然后

00:45:52.559 --> 00:45:54.180
必须重新开始整个事情

00:45:53.849 --> 00:45:56.759
再次

00:45:54.180 --> 00:45:58.529
但关键是它已经放置

00:45:56.759 --> 00:46:00.839
进入流中，以这种方式

00:45:58.529 --> 00:46:02.549
这是完全透明的软件

00:46:00.839 --> 00:46:04.499
开发人员坐起来说

00:46:02.549 --> 00:46:06.749
请求响应去给我复仇者

00:46:04.499 --> 00:46:08.910
电影流回复仇者联盟电影从未

00:46:06.749 --> 00:46:10.499
意识到这种分裂发生了

00:46:08.910 --> 00:46:13.170
在引擎盖下，它可以让您继续

00:46:10.499 --> 00:46:15.869
关于请求的逻辑推理

00:46:13.170 --> 00:46:17.069
关于你如何知道我问的语义

00:46:15.869 --> 00:46:19.559
一个有效载荷，我得到一个

00:46:17.069 --> 00:46:21.930
有效负载，但协议确实允许您

00:46:19.559 --> 00:46:25.319
针对网络条件进行优化

00:46:21.930 --> 00:46:28.019
目前也有想法

00:46:25.319 --> 00:46:30.150
取消，这是东西

00:46:28.019 --> 00:46:31.410
几乎没有其他协议

00:46:30.150 --> 00:46:33.059
原来是我们所说的

00:46:31.410 --> 00:46:35.460
早一点真的很有趣

00:46:33.059 --> 00:46:37.410
因为取消只是一个信号

00:46:35.460 --> 00:46:38.489
由请求者说嘿我问过你

00:46:37.410 --> 00:46:40.049
对于一些东西，那可能是

00:46:38.489 --> 00:46:42.150
建造起来真的很贵

00:46:40.049 --> 00:46:43.980
只是去做，停止做正确的事

00:46:42.150 --> 00:46:45.509
明显请求流和频道

00:46:43.980 --> 00:46:47.730
但即使在类似请求中

00:46:45.509 --> 00:46:49.619
回应我要提出的要求

00:46:47.730 --> 00:46:51.210
也许你会知道你有

00:46:49.619 --> 00:46:54.119
去做一些昂贵的事

00:46:51.210 --> 00:46:55.890
回到一个单一的结果，就像我不

00:46:54.119 --> 00:46:57.450
知道去计算我的

00:46:55.890 --> 00:46:58.440
当前的信用等级或类似的东西

00:46:57.450 --> 00:47:01.289
我要去的地方

00:46:58.440 --> 00:47:02.519
响应，但也许我已关闭

00:47:01.289 --> 00:47:04.529
我已经完全

00:47:02.519 --> 00:47:06.119
我的银行业务申请的不同之处

00:47:04.529 --> 00:47:08.579
那你为什么不停下来

00:47:06.119 --> 00:47:10.289
服务器端可以回收所有CPU 

00:47:08.579 --> 00:47:13.349
您将要使用的用法并给它

00:47:10.289 --> 00:47:17.700
对其他客户来说， 

00:47:13.349 --> 00:47:21.059
也是租赁的一部分，所以租赁是

00:47:17.700 --> 00:47:22.980
服务器进行通信的方式

00:47:21.059 --> 00:47:25.769
给客户，所以我们说有要求

00:47:22.980 --> 00:47:27.000
以及请求者可以说的语义

00:47:25.769 --> 00:47:29.549
我们有联系

00:47:27.000 --> 00:47:31.109
给我八个人给我十个人

00:47:29.549 --> 00:47:33.059
将向您发送另一个请求

00:47:31.109 --> 00:47:35.430
直到我准备出发的其中之一

00:47:33.059 --> 00:47:37.410
是什么阻止我成为请求者

00:47:35.430 --> 00:47:38.970
绝对向服务器发送垃圾邮件

00:47:37.410 --> 00:47:40.799
另一端说可以，我需要请求

00:47:38.970 --> 00:47:42.420
要求MacArthur快速要求所有

00:47:40.799 --> 00:47:44.430
这样的权利，你完全可以

00:47:42.420 --> 00:47:46.140
拆除服务器，因此协议

00:47:44.430 --> 00:47:48.029
内置了这样的方式

00:47:46.140 --> 00:47:49.589
服务器基本上可以告诉任何客户端

00:47:48.029 --> 00:47:51.960
当前连接到它可以

00:47:49.589 --> 00:47:54.059
说嘿，你可以寄给我十张

00:47:51.960 --> 00:47:55.829
在一分钟后提出要求，否则您将

00:47:54.059 --> 00:47:58.410
允许向我发送十个请求

00:47:55.829 --> 00:48:00.539
下一个小时，它是完全动态的，所以

00:47:58.410 --> 00:48:03.000
您可以想象一个场景

00:48:00.539 --> 00:48:05.069
服务器端正在发送这些租赁

00:48:03.000 --> 00:48:07.710
基于当前负载的通知

00:48:05.069 --> 00:48:09.539
如果你是周围唯一的人

00:48:07.710 --> 00:48:11.910
因为你知道那是

00:48:09.539 --> 00:48:13.470
晚上是一家欧洲银行，或者

00:48:11.910 --> 00:48:15.599
两个人在那里也许他们得到了

00:48:13.470 --> 00:48:18.000
无限的权利，你去做公司点

00:48:15.599 --> 00:48:20.460
那里的int点的最大级别请求

00:48:18.000 --> 00:48:22.859
长点最大时间正确，但随后

00:48:20.460 --> 00:48:24.630
人们早上新来

00:48:22.859 --> 00:48:26.670
租赁信息发出说

00:48:24.630 --> 00:48:28.440
好吧，现在我的CPU速度提高了50％ 

00:48:26.670 --> 00:48:30.089
所以现在你不必问我那么多

00:48:28.440 --> 00:48:31.980
时代，这真的触发了

00:48:30.089 --> 00:48:33.990
客户端负载平衡真的很好

00:48:31.980 --> 00:48:35.609
因为你可以想象一个算法

00:48:33.990 --> 00:48:37.049
在那里我知道我可以连接到

00:48:35.609 --> 00:48:38.910
一堆不同的服务器在我的数据中

00:48:37.049 --> 00:48:41.730
中心，其中一个告诉我

00:48:38.910 --> 00:48:43.109
它完全满了，没有更多的负荷，没有

00:48:41.730 --> 00:48:44.430
想要听到您的声音，以便

00:48:43.109 --> 00:48:46.500
使我跳到下一个

00:48:44.430 --> 00:48:48.000
客户，那仍然是丽莎，所以我

00:48:46.500 --> 00:48:49.890
可以出去叫它

00:48:48.000 --> 00:48:53.480
而是打开一个特定的

00:48:49.890 --> 00:48:53.480
连接发出这些请求

00:48:53.940 --> 00:49:00.940
好，最后很确定这是

00:48:58.090 --> 00:49:03.190
最终恢复能力恢复能力是

00:49:00.940 --> 00:49:06.880
真的很有趣，来了

00:49:03.190 --> 00:49:09.130
关于绝对的

00:49:06.880 --> 00:49:11.680
社交媒体案例设想

00:49:09.130 --> 00:49:14.920
方案我有一个电话，我有一个

00:49:11.680 --> 00:49:16.390
我的手机上正在播放新闻提要

00:49:14.920 --> 00:49:18.640
 Wi-Fi，因为我在这里散步

00:49:16.390 --> 00:49:21.490
外面我的Wi-Fi掉线了，我

00:49:18.640 --> 00:49:24.490
进入蜂窝网络

00:49:21.490 --> 00:49:25.870
好的，现在从

00:49:24.490 --> 00:49:28.240
在另一个服务器的角度

00:49:25.870 --> 00:49:29.800
一边我我的连接已经死了

00:49:28.240 --> 00:49:31.570
表示我需要回去

00:49:29.800 --> 00:49:33.220
订阅所有新更改，并

00:49:31.570 --> 00:49:34.510
列举发生的一切

00:49:33.220 --> 00:49:37.360
最后一小时之类的

00:49:34.510 --> 00:49:39.850
我可以刷新并重新填充我的提要，你

00:49:37.360 --> 00:49:41.770
可以想象在全球范围内尝试这样做

00:49:39.850 --> 00:49:43.360
在社交网络上的规模确实是

00:49:41.770 --> 00:49:45.730
真的很困难，但现在想像一下

00:49:43.360 --> 00:49:47.500
您的用例以及清楚的例子

00:49:45.730 --> 00:49:48.940
是真正显而易见的可怕的事情，但是

00:49:47.500 --> 00:49:50.920
你可以想到同样的事情

00:49:48.940 --> 00:49:52.620
如果有人在哪里

00:49:50.920 --> 00:49:55.620
间歇性连接必须

00:49:52.620 --> 00:49:55.620
重新介入

00:49:57.760 --> 00:50:01.360
网络的效率都很高

00:49:59.590 --> 00:50:02.290
对，我们必须将所有这些都发送给您

00:50:01.360 --> 00:50:04.240
知道最后发生的一切

00:50:02.290 --> 00:50:06.310
再在数据中心两个小时

00:50:04.240 --> 00:50:07.360
计算正确，这就是我们最终的目标

00:50:06.310 --> 00:50:09.070
在这种情况下

00:50:07.360 --> 00:50:11.350
运行服务器创建大量数据

00:50:09.070 --> 00:50:13.720
客户可能已经有

00:50:11.350 --> 00:50:15.700
完全内置在协议中

00:50:13.720 --> 00:50:18.040
对用户透明的是这个想法

00:50:15.700 --> 00:50:19.720
双方回来时

00:50:18.040 --> 00:50:21.700
而不是说我创建一个

00:50:19.720 --> 00:50:24.460
新的连接，您可以说嘿

00:50:21.700 --> 00:50:27.550
我正在创建，或者我想恢复

00:50:24.460 --> 00:50:29.020
连接我就好了，所以你

00:50:27.550 --> 00:50:30.610
想继续告诉我最后一件事

00:50:29.020 --> 00:50:32.500
你看到我会告诉你我的最后一件事

00:50:30.610 --> 00:50:34.750
看到将同步这两个是

00:50:32.500 --> 00:50:36.310
然后是任何会

00:50:34.750 --> 00:50:38.110
在那段时间进来

00:50:36.310 --> 00:50:42.310
被一方或另一方丢弃

00:50:38.110 --> 00:50:44.710
变得不满，我们没有排序

00:50:42.310 --> 00:50:46.390
准确描述您如何存储

00:50:44.710 --> 00:50:47.620
数据以及您如何识别已发生的事情

00:50:46.390 --> 00:50:49.750
已发送，尚未发送的是

00:50:47.620 --> 00:50:51.280
由应用程序实施

00:50:49.750 --> 00:50:53.440
应用基础，但也许你有

00:50:51.280 --> 00:50:55.000
保留的温暖缓存

00:50:53.440 --> 00:50:57.310
真正密切关注可能发生的事情

00:50:55.000 --> 00:50:58.750
让你知道来来去去第二

00:50:57.310 --> 00:51:01.210
或超过十秒钟，然后

00:50:58.750 --> 00:51:03.460
有一个比较冷的地方

00:51:01.210 --> 00:51:04.570
事情的细化程度较低

00:51:03.460 --> 00:51:06.880
一分钟前可能在这里

00:51:04.570 --> 00:51:08.200
或五分钟前的事情

00:51:06.880 --> 00:51:10.450
但这基本上给了你能力

00:51:08.200 --> 00:51:12.640
去接你离开的地方

00:51:10.450 --> 00:51:14.650
识别您错过的所有帧

00:51:12.640 --> 00:51:18.250
自从你

00:51:14.650 --> 00:51:20.980
最后，这真的是关键

00:51:18.250 --> 00:51:22.839
很多用例我们看到我们的套接字

00:51:20.980 --> 00:51:26.589
使用还好

00:51:22.839 --> 00:51:28.329
准时准时很棒，所以我们和我一样

00:51:26.589 --> 00:51:30.759
说是双向复用

00:51:28.329 --> 00:51:32.230
基于消息的二进制协议利用

00:51:30.759 --> 00:51:34.299
效率高的背压

00:51:32.230 --> 00:51:36.069
可预测性为

00:51:34.299 --> 00:51:38.410
四种常见的互动模型

00:51:36.069 --> 00:51:40.210
几乎可以在任何地方运输的灵活性

00:51:38.410 --> 00:51:42.279
语言编程模型让我们知道

00:51:40.210 --> 00:51:44.079
您想使用什么以及所有这些

00:51:42.279 --> 00:51:46.930
我们在运行的其他功能

00:51:44.079 --> 00:51:48.369
最后，让我首先感谢

00:51:46.930 --> 00:51:50.140
大家都来这里坐下

00:51:48.369 --> 00:51:52.080
这个巨大的房间，我很乐意回答

00:51:50.140 --> 00:51:57.889
问题在这里谢谢

00:51:52.080 --> 00:51:57.889
 [掌声] 

00:51:58.050 --> 00:52:01.300
 [音乐] 

