WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.900 --> 00:00:09.360
 [音乐] 

00:00:06.830 --> 00:00:11.309
谢谢大家，谢谢

00:00:09.360 --> 00:00:14.940
我知道要熬到这么晚

00:00:11.309 --> 00:00:16.920
在这么多会议之后

00:00:14.940 --> 00:00:19.130
几个小时，我真的很难受

00:00:16.920 --> 00:00:22.860
甚至在今天结束时有些微不足道

00:00:19.130 --> 00:00:26.430
所以就像我们早些时候听到的

00:00:22.860 --> 00:00:27.540
我叫本·黑尔（Ben Hale） 

00:00:26.430 --> 00:00:29.670
我们谈了一点的项目

00:00:27.540 --> 00:00:32.610
关于今天早上在主题演讲中，但我

00:00:29.670 --> 00:00:34.559
也可以在Cloud Foundry上运行Java，因此

00:00:32.610 --> 00:00:37.019
一个大型的开放源代码传递项目，我运行了一个

00:00:34.559 --> 00:00:40.379
 Pivitol本身的许多Java策略

00:00:37.019 --> 00:00:42.440
所以听到我的声音可能很奇怪

00:00:40.379 --> 00:00:45.179
主题演讲现在正在谈论

00:00:42.440 --> 00:00:47.760
反应式编程就像清晰

00:00:45.179 --> 00:00:50.670
我负责这件事，我

00:00:47.760 --> 00:00:52.559
做很多策略，那么你到底是什么

00:00:50.670 --> 00:00:55.170
知道这把我带到这里的原因

00:00:52.559 --> 00:00:57.929
这样的反应式编程爱好者

00:00:55.170 --> 00:01:00.629
答案在我的职位上

00:00:57.929 --> 00:01:02.100
与云代工客户一起，我看到了很多

00:01:00.629 --> 00:01:03.809
有您认识的人

00:01:02.100 --> 00:01:06.210
他们自己的数据中的这个整体

00:01:03.809 --> 00:01:09.119
中心沉没成本之类的东西

00:01:06.210 --> 00:01:11.780
他们开始看看他们的

00:01:09.119 --> 00:01:14.549
账单到亚马逊或他们的账单到

00:01:11.780 --> 00:01:16.229
己糖醇，因为他们开始扩大，他们

00:01:14.549 --> 00:01:18.180
开始做微服务，他们

00:01:16.229 --> 00:01:20.310
开始看到其中一些问题

00:01:18.180 --> 00:01:22.380
我们早一点描述了，所以

00:01:20.310 --> 00:01:26.689
对我来说很清楚

00:01:22.380 --> 00:01:28.799
效率是非常关键的

00:01:26.689 --> 00:01:31.109
对我们许多客户而言势在必行

00:01:28.799 --> 00:01:33.060
所以只想再次重申一下

00:01:31.109 --> 00:01:34.920
说今天早上反应式编程

00:01:33.060 --> 00:01:37.049
我们知道 Spring 

00:01:34.920 --> 00:01:39.119
社区和关键的我们

00:01:37.049 --> 00:01:40.740
绝对将反应式编程视为

00:01:39.119 --> 00:01:43.439
 Java的下一个前沿

00:01:40.740 --> 00:01:46.259
高效率甚至比高效率

00:01:43.439 --> 00:01:48.000
表现效率

00:01:46.259 --> 00:01:50.670
在过去忘记了它

00:01:48.000 --> 00:01:52.859
两三个十年现在有点

00:01:50.670 --> 00:01:54.210
回到您的团队的最前沿

00:01:52.859 --> 00:01:57.149
你的树比萨团队很可能

00:01:54.210 --> 00:01:59.369
负责非常离散的

00:01:57.149 --> 00:02:00.659
您的AWS账单，所以突然之间您

00:01:59.369 --> 00:02:03.060
开始不得不考虑一个

00:02:00.659 --> 00:02:04.829
多一点我们在说什么

00:02:03.060 --> 00:02:06.630
再次进行反应式编程

00:02:04.829 --> 00:02:09.030
看到很多这样的东西，但让我

00:02:06.630 --> 00:02:11.340
最后一次反应是

00:02:09.030 --> 00:02:13.590
基本上是非阻塞的

00:02:11.340 --> 00:02:15.480
通常与异步行为配对

00:02:13.590 --> 00:02:17.849
但令很多人惊讶的是

00:02:15.480 --> 00:02:20.400
人们异步并不是一个

00:02:17.849 --> 00:02:23.459
反应性的关键部分

00:02:20.400 --> 00:02:25.770
实际上，如果您采取了任何意见

00:02:23.459 --> 00:02:28.020
看看很多反应式代码

00:02:25.770 --> 00:02:30.360
您今天整天都在幻灯片上看到了

00:02:28.020 --> 00:02:31.800
您所使用的绝大多数代码

00:02:30.360 --> 00:02:33.930
看到那里实际执行

00:02:31.800 --> 00:02:36.000
实际上完全同步

00:02:33.930 --> 00:02:38.760
像Project Reactor这样的东西

00:02:36.000 --> 00:02:40.950
在内部，这是一个

00:02:38.760 --> 00:02:42.599
优化使其可以

00:02:40.950 --> 00:02:44.069
看一堆不同的运算符

00:02:42.599 --> 00:02:45.540
你知道哪种编程吗

00:02:44.069 --> 00:02:47.459
它可以在一个

00:02:45.540 --> 00:02:49.560
异步或多线程

00:02:47.459 --> 00:02:51.269
并将它们融合在一起

00:02:49.560 --> 00:02:54.690
在一个线程中执行它们

00:02:51.269 --> 00:02:56.549
尽可能快地解决问题

00:02:54.690 --> 00:02:59.099
实际编写的反应式代码

00:02:56.549 --> 00:03:00.660
是同步的，但可以在哪里

00:02:59.099 --> 00:03:01.830
穿越时是异步的

00:03:00.660 --> 00:03:03.959
网络，当您要去

00:03:01.830 --> 00:03:06.299
数据库这样的东西我们最终

00:03:03.959 --> 00:03:08.310
有了这个，你知道真的很合适

00:03:06.299 --> 00:03:10.860
在反应性编程模型和

00:03:08.310 --> 00:03:13.170
异步编程模型，但这是

00:03:10.860 --> 00:03:14.910
不够，就像这样还不够

00:03:13.170 --> 00:03:16.890
说异步是一回事，或者

00:03:14.910 --> 00:03:19.709
不阻塞是我们拥有的那些东西

00:03:16.890 --> 00:03:22.140
 Java和IO之前的一种api 

00:03:19.709 --> 00:03:24.480
当我们谈论这样的事情时

00:03:22.140 --> 00:03:26.340
反应性宣言中的反应性

00:03:24.480 --> 00:03:28.530
谈论反应流

00:03:26.340 --> 00:03:31.200
项目真正关键的要素之一

00:03:28.530 --> 00:03:34.260
真正的反应力改变者

00:03:31.200 --> 00:03:36.299
只是纯粹的非阻塞或刺激是这

00:03:34.260 --> 00:03:38.400
拉推压力的想法或

00:03:36.299 --> 00:03:42.720
反应背压有这个想法

00:03:38.400 --> 00:03:45.269
在许多系统中需要

00:03:42.720 --> 00:03:47.400
有弹性的我们看到同样的问题

00:03:45.269 --> 00:03:48.810
模式一次又一次地发生

00:03:47.400 --> 00:03:51.660
发行人被允许

00:03:48.810 --> 00:03:54.000
向订阅者的用户发送数据

00:03:51.660 --> 00:03:56.280
发布者可以压倒的数据

00:03:54.000 --> 00:03:58.260
那个订户对它会不知所措

00:03:56.280 --> 00:04:00.090
该消费者以某种方式

00:03:58.260 --> 00:04:02.040
消费者因为充满而炸毁

00:04:00.090 --> 00:04:03.540
它的缓存被填满了，太多了

00:04:02.040 --> 00:04:05.489
有数据或发布者

00:04:03.540 --> 00:04:07.530
可能会尽可能地阻塞

00:04:05.489 --> 00:04:10.530
数据，因为它可能会下降

00:04:07.530 --> 00:04:13.019
也会炸毁，所以反应就足够了

00:04:10.530 --> 00:04:14.910
拒绝发行商的想法

00:04:13.019 --> 00:04:16.979
直到我被允许发送给我

00:04:14.910 --> 00:04:18.690
告诉你我拉下八个

00:04:16.979 --> 00:04:22.500
接下来的十个项目中有哪些

00:04:18.690 --> 00:04:24.639
你从那里一次又一次，所以我们开始

00:04:22.500 --> 00:04:27.819
看到这个，如果你看到了

00:04:24.639 --> 00:04:29.979
 Juergen x'在最后一节中的讲话

00:04:27.819 --> 00:04:32.199
我们也谈到了很多

00:04:29.979 --> 00:04:33.939
真的很像韦伯助焊剂对韦伯助焊剂

00:04:32.199 --> 00:04:36.009
对我们真的很有用

00:04:33.939 --> 00:04:37.270
所谓的网络客户端，这是非常

00:04:36.009 --> 00:04:39.189
通常对我来说我很奇怪

00:04:37.270 --> 00:04:40.840
小得多的房间，所以我可以走过去

00:04:39.189 --> 00:04:42.340
将其指向屏幕上的某物

00:04:40.840 --> 00:04:44.620
只会在那儿挥手

00:04:42.340 --> 00:04:46.330
有点在这里，我们有一个想法

00:04:44.620 --> 00:04:48.189
根本上是一个Web客户端

00:04:46.330 --> 00:04:51.069
反应性的，它使我们能够有效地

00:04:48.189 --> 00:04:53.889
定义需要什么顺序

00:04:51.069 --> 00:04:56.229
可以并行的是什么呢

00:04:53.889 --> 00:04:58.659
在说这里是我要使用网络

00:04:56.229 --> 00:05:01.060
客户端以获取两个不同的服务URL 

00:04:58.659 --> 00:05:03.340
我可以并行做单点拉链

00:05:01.060 --> 00:05:05.740
那里说这两件事可能发生

00:05:03.340 --> 00:05:07.509
并行并尽快

00:05:05.740 --> 00:05:10.029
完成了，我要你协调

00:05:07.509 --> 00:05:12.129
然后依次运行下一件事

00:05:10.029 --> 00:05:14.590
将此地图转换为

00:05:12.129 --> 00:05:16.389
复合类型这么有效

00:05:14.590 --> 00:05:18.580
你到这里是有能力

00:05:16.389 --> 00:05:20.710
以编程方式定义排序或

00:05:18.580 --> 00:05:22.479
声明性地会发生什么

00:05:20.710 --> 00:05:24.939
并行，然后发生什么

00:05:22.479 --> 00:05:27.129
之后，并取决于

00:05:24.939 --> 00:05:30.129
您的反应式框架反应器在此

00:05:27.129 --> 00:05:32.020
案例项目反应堆可以算出什么

00:05:30.129 --> 00:05:33.370
可以线程抱歉，该怎么办

00:05:32.020 --> 00:05:35.409
单线程可以做什么

00:05:33.370 --> 00:05:37.300
异步需要什么协调

00:05:35.409 --> 00:05:39.729
发生如何正确分配

00:05:37.300 --> 00:05:41.199
高效地使用所有线程

00:05:39.729 --> 00:05:43.300
在那附近，所以这是

00:05:41.199 --> 00:05:44.740
真的减轻了负担

00:05:43.300 --> 00:05:47.319
阻止你做这些事情

00:05:44.740 --> 00:05:49.360
你自己，你可以用你知道的

00:05:47.319 --> 00:05:51.759
分叉/联接池，您可以使用新线程

00:05:49.360 --> 00:05:53.020
并加入其中，但这将您从中解放出来

00:05:51.759 --> 00:05:55.330
可以让您描述

00:05:53.020 --> 00:05:57.279
这些请求的结构

00:05:55.330 --> 00:06:00.279
这些行为的结构分别

00:05:57.279 --> 00:06:02.889
从他们的线程，但有

00:06:00.279 --> 00:06:05.259
重用反应性仍然存在一些障碍

00:06:02.889 --> 00:06:08.560
我到处都放了些灰烬

00:06:05.259 --> 00:06:10.000
我发现随着人们使用反应性

00:06:08.560 --> 00:06:12.069
编程很多，他们最终成为

00:06:10.000 --> 00:06:13.060
狂热者对此深信不疑

00:06:12.069 --> 00:06:15.189
一切都应该做

00:06:13.060 --> 00:06:16.899
反应地这不是

00:06:15.189 --> 00:06:19.899
 The Spring Team 这不是职位

00:06:16.899 --> 00:06:21.849
这次会议上任何人的反应

00:06:19.899 --> 00:06:23.680
很棒，但是在某些地方

00:06:21.849 --> 00:06:25.960
真的非常有用，并且在哪里

00:06:23.680 --> 00:06:27.729
可能没有那么有用，所以当我们

00:06:25.960 --> 00:06:29.289
说可能到处都使用反应式

00:06:27.729 --> 00:06:31.990
假设我们正在使用反应式

00:06:29.289 --> 00:06:33.759
到处都适合我

00:06:31.990 --> 00:06:35.289
今天早些时候提到的跨进程

00:06:33.759 --> 00:06:37.780
背压是这些障碍之一

00:06:35.289 --> 00:06:39.910
所以我们在进行套接字项目

00:06:37.780 --> 00:06:42.610
明天下午我会谈

00:06:39.910 --> 00:06:44.620
还要在数据访问领域

00:06:42.610 --> 00:06:48.070
我们看到了一些续集

00:06:44.620 --> 00:06:50.440
今天存在的数据库具有反应性

00:06:48.070 --> 00:06:52.030
访问或具有异步访问权限

00:06:50.440 --> 00:06:54.490
足以让我们写反应式

00:06:52.030 --> 00:06:58.210
司机，但我们没有

00:06:54.490 --> 00:07:00.190
关系数据库访问到现在为止

00:06:58.210 --> 00:07:01.300
和观众中我的朋友们

00:07:00.190 --> 00:07:03.100
提到我，我错过了完美

00:07:01.300 --> 00:07:05.800
今天早上的机会是

00:07:03.100 --> 00:07:08.410
您实际上正在寻找的Droid也是如此

00:07:05.800 --> 00:07:11.590
两个DBC是从

00:07:08.410 --> 00:07:13.840
为反应式编程而准备

00:07:11.590 --> 00:07:15.730
再次反思那些设计

00:07:13.840 --> 00:07:18.130
特定原理背后

00:07:15.730 --> 00:07:19.620
项目，因此设计原则是

00:07:18.130 --> 00:07:22.060
我们要确保我们使用

00:07:19.620 --> 00:07:23.919
反应流类型有很多

00:07:22.060 --> 00:07:25.419
编写反应式的不同方法

00:07:23.919 --> 00:07:27.340
当然在之前编程

00:07:25.419 --> 00:07:29.320
反应流项目进入

00:07:27.340 --> 00:07:30.700
存在并标准化那里

00:07:29.320 --> 00:07:32.740
有很多不同的项目

00:07:30.700 --> 00:07:35.860
做了不同的事情，但我们想说

00:07:32.740 --> 00:07:37.419
社区选择了正确的

00:07:35.860 --> 00:07:39.130
社区已经对他们的投票

00:07:37.419 --> 00:07:41.830
脚投票赞成他们的节目

00:07:39.130 --> 00:07:43.540
并决定反应性流是

00:07:41.830 --> 00:07:45.250
我们高效的方式

00:07:43.540 --> 00:07:46.630
编程和工作，所以我们想做

00:07:45.250 --> 00:07:48.490
确保我们不是那里的本地人

00:07:46.630 --> 00:07:50.350
想要成为我们不想要的一层

00:07:48.490 --> 00:07:52.479
成为我们想要的一层

00:07:50.350 --> 00:07:54.400
我们想要成为的反应性流

00:07:52.479 --> 00:07:56.919
完全不阻塞

00:07:54.400 --> 00:07:59.080
数据库可能包括

00:07:56.919 --> 00:08:01.750
并非所有数据库都允许这种利用

00:07:59.080 --> 00:08:04.120
有线协议功能来获得这种

00:08:01.750 --> 00:08:05.860
我认为非阻塞行为之一

00:08:04.120 --> 00:08:07.270
我们要去的人的关键事情

00:08:05.860 --> 00:08:10.600
稍后再谈论这个

00:08:07.270 --> 00:08:13.000
即将结束，但其中之一

00:08:10.600 --> 00:08:15.400
关于我们两个DBC的关键是

00:08:13.000 --> 00:08:16.960
这是一个规范，我们编写实现

00:08:15.400 --> 00:08:18.400
对于它和那些实现他们

00:08:16.960 --> 00:08:20.080
不要建立在任何东西之上

00:08:18.400 --> 00:08:22.330
今天存在，他们不建立在

00:08:20.080 --> 00:08:25.720
已存在的JDBC驱动程序，因为

00:08:22.330 --> 00:08:27.370
所有这些东西都阻塞了api 

00:08:25.720 --> 00:08:30.789
我们实际上要做的是

00:08:27.370 --> 00:08:32.890
从头开始实现，但写作

00:08:30.789 --> 00:08:35.620
二进制框架和Java代码以及

00:08:32.890 --> 00:08:37.270
为所有实施有线协议

00:08:35.620 --> 00:08:39.610
这些数据库，所以这给了我们一个

00:08:37.270 --> 00:08:41.229
有机会利用功能

00:08:39.610 --> 00:08:43.060
在那些有线协议

00:08:41.229 --> 00:08:45.190
客户端与

00:08:43.060 --> 00:08:48.430
给我们非常好的数据库

00:08:45.190 --> 00:08:50.140
非阻塞异步行为

00:08:48.430 --> 00:08:51.889
第三个原则是，这确实是

00:08:50.140 --> 00:08:54.089
真

00:08:51.889 --> 00:08:56.399
对很多人而言，我们违反直觉

00:08:54.089 --> 00:08:59.329
想要将SPI的驱动器缩小到

00:08:56.399 --> 00:09:01.980
最小的一组操作

00:08:59.329 --> 00:09:04.889
即使具体实现

00:09:01.980 --> 00:09:07.740
意味着使用我们的2 DB C确实

00:09:04.889 --> 00:09:09.240
对于最终用户而言，这似乎很困难

00:09:07.740 --> 00:09:11.220
我完全不符合直觉

00:09:09.240 --> 00:09:13.050
实际上可供最终用户使用

00:09:11.220 --> 00:09:16.050
但是我们认为2 DB C是

00:09:13.050 --> 00:09:17.970
用户永远不会看到的规范

00:09:16.050 --> 00:09:21.480
我们要做的是建立一个真正的

00:09:17.970 --> 00:09:23.970
好的基础，使客户可以

00:09:21.480 --> 00:09:26.220
在这些人性化的api之上构建

00:09:23.970 --> 00:09:28.709
 r2 DB c本身不是

00:09:26.220 --> 00:09:30.870
那是因为我

00:09:28.709 --> 00:09:32.910
不知道您使用哪种客户端API 

00:09:30.870 --> 00:09:36.089
其实想要你是那种人

00:09:32.910 --> 00:09:37.920
谁真的很喜欢JPA并附有完整的ORM 

00:09:36.089 --> 00:09:40.139
最重要的是您这种人

00:09:37.920 --> 00:09:41.699
喜欢Spring 数据存储库

00:09:40.139 --> 00:09:43.350
编写一个自动

00:09:41.699 --> 00:09:45.480
为您做某种映射

00:09:43.350 --> 00:09:47.339
你是我的坏蛋还是

00:09:45.480 --> 00:09:49.589
喜欢飞入API的人

00:09:47.339 --> 00:09:51.540
 JD bi我不知道，我不认为

00:09:49.589 --> 00:09:55.199
我们应该将其指定为

00:09:51.540 --> 00:09:57.660
这个规范，那是由

00:09:55.199 --> 00:09:59.519
原来是jdbc之一的想法

00:09:57.660 --> 00:10:01.589
每当我们交谈时，c的最大失败

00:09:59.519 --> 00:10:03.149
任何类型的客户实施者

00:10:01.589 --> 00:10:05.550
坐在它上面的像冬眠或

00:10:03.149 --> 00:10:07.440
这样的东西甚至数据库

00:10:05.550 --> 00:10:09.209
驱动程序的供应商实施者

00:10:07.440 --> 00:10:12.720
他们自己喜欢Postgres 

00:10:09.209 --> 00:10:15.990
还是我的续集小组认为JDBC是排序

00:10:12.720 --> 00:10:18.360
建于20年前

00:10:15.990 --> 00:10:21.180
每个人都以为你只是的世界

00:10:18.360 --> 00:10:23.240
使用了JDBC驱动程序，这意味着它没有

00:10:21.180 --> 00:10:27.060
只有所有必要的api 

00:10:23.240 --> 00:10:28.949
借口以编程方式访问

00:10:27.060 --> 00:10:32.190
这些数据库来建立这些客户端

00:10:28.949 --> 00:10:35.839
最重要的是，但它也具有人性化的api 

00:10:32.190 --> 00:10:38.579
以及诸如此类的东西

00:10:35.839 --> 00:10:40.709
具有约束力的人道能力

00:10:38.579 --> 00:10:42.600
问号，然后他们选择了一个

00:10:40.709 --> 00:10:45.720
索引而不是零索引不像

00:10:42.600 --> 00:10:48.660
编程中的其他所有内容

00:10:45.720 --> 00:10:50.760
我们最终得到的是一个API 

00:10:48.660 --> 00:10:52.410
没有人喜欢合适的用户不使用它

00:10:50.760 --> 00:10:55.769
这个房间里几乎没人

00:10:52.410 --> 00:10:59.310
确保实际上实际上使用了JDBC API 

00:10:55.769 --> 00:11:01.470
我从来没有使用过JDBC API 

00:10:59.310 --> 00:11:03.720
当我开始Jurgen和Rod的时候

00:11:01.470 --> 00:11:04.990
已经在里面写了JDBC模板

00:11:03.720 --> 00:11:07.510
 Spring 的那就是你知道的

00:11:04.990 --> 00:11:08.830
大约13年前14年前等等

00:11:07.510 --> 00:11:10.420
我立即开始

00:11:08.830 --> 00:11:12.670
比尝试使用

00:11:10.420 --> 00:11:14.740
 JDBC API，但同时

00:11:12.670 --> 00:11:16.029
驱动程序供应商也讨厌它，因为

00:11:14.740 --> 00:11:17.620
他们最终重复了很多

00:11:16.029 --> 00:11:19.510
跨所有功能

00:11:17.620 --> 00:11:21.640
驱动程序Postgres团队必须实施

00:11:19.510 --> 00:11:23.380
问号约束我的续集团队

00:11:21.640 --> 00:11:26.410
必须实现问号绑定

00:11:23.380 --> 00:11:27.940
每个人都必须实现URL解析

00:11:26.410 --> 00:11:30.070
他们都做了不同的事情

00:11:27.940 --> 00:11:32.529
对，所以在如何使用方面存在很大的问题

00:11:30.070 --> 00:11:35.470
 JDBC API是最初设计的

00:11:32.529 --> 00:11:37.360
所以我们设计了一个API，这是

00:11:35.470 --> 00:11:39.459
有点仍然在

00:11:37.360 --> 00:11:41.529
在RTD的早期发展

00:11:39.459 --> 00:11:45.180
 BC，但我们设计的是API 

00:11:41.529 --> 00:11:47.050
试图消除很多这样的

00:11:45.180 --> 00:11:49.330
您将在这里看到的内容

00:11:47.050 --> 00:11:53.800
将通过一些API和

00:11:49.330 --> 00:11:56.080
我们将有点了解

00:11:53.800 --> 00:11:58.149
不同的部分以及它们如何相互作用

00:11:56.080 --> 00:12:00.190
以及编程模型的外观

00:11:58.149 --> 00:12:02.560
喜欢，你会看到很多

00:12:00.190 --> 00:12:04.420
您在JDBC上看到的相似之处

00:12:02.560 --> 00:12:05.920
但以某种反应的方式

00:12:04.420 --> 00:12:08.620
对它的改进

00:12:05.920 --> 00:12:11.170
驱动程序SPI中的内容是

00:12:08.620 --> 00:12:13.209
连接工厂连接

00:12:11.170 --> 00:12:15.190
工厂允许您创建一个

00:12:13.209 --> 00:12:16.959
连接获取有关此的一些元数据

00:12:15.190 --> 00:12:18.910
连接，但第一件事

00:12:16.959 --> 00:12:21.130
您将在此API上看到

00:12:18.910 --> 00:12:22.720
实际上，第一行是

00:12:21.130 --> 00:12:24.880
当您调用创建时，您实际上并没有

00:12:22.720 --> 00:12:27.700
建立联系，获得发布者

00:12:24.880 --> 00:12:29.770
这是一种反应流类型

00:12:27.700 --> 00:12:31.630
说以后的某个时候

00:12:29.770 --> 00:12:33.490
你订阅我，我会给你一个

00:12:31.630 --> 00:12:37.000
连接以进行某种工作

00:12:33.490 --> 00:12:38.740
编写这种惰性绑定消息

00:12:37.000 --> 00:12:41.290
期望的行为驱动

00:12:38.740 --> 00:12:43.089
从反应的给定连接

00:12:41.290 --> 00:12:46.180
那是一些非常有趣的地方

00:12:43.089 --> 00:12:47.529
事情发生在这是我们

00:12:46.180 --> 00:12:49.390
可以做一些事情，例如关闭连接

00:12:47.529 --> 00:12:51.399
我们可以管理的非常简单

00:12:49.390 --> 00:12:53.020
诸如开始交易之类的交易

00:12:51.399 --> 00:12:55.029
设置隔离级别

00:12:53.020 --> 00:12:57.760
提交并回滚正确

00:12:55.029 --> 00:12:59.380
我们看到您可以管理保存点

00:12:57.760 --> 00:13:01.690
是否创建它们释放滚动

00:12:59.380 --> 00:13:03.279
回到他们，您可以创建批次

00:13:01.690 --> 00:13:04.870
可以创建我们真正要去的语句

00:13:03.279 --> 00:13:06.310
专注于create语句的来临

00:13:04.870 --> 00:13:08.320
上升，但你要做的一件事

00:13:06.310 --> 00:13:11.399
看到很多这些实际上有一个

00:13:08.320 --> 00:13:14.949
非常相似，非常相似

00:13:11.399 --> 00:13:17.470
他们成语使发布者无效，所以如果

00:13:14.949 --> 00:13:18.259
你回想起到底有多反应

00:13:17.470 --> 00:13:19.759
编程作品

00:13:18.259 --> 00:13:21.799
你总是在说些什么

00:13:19.759 --> 00:13:23.839
当您订阅时发生

00:13:21.799 --> 00:13:25.999
对我来说你实际上永远不会回来

00:13:23.839 --> 00:13:27.499
无效，这个概念是说我

00:13:25.999 --> 00:13:28.910
要调用一个方法，你会返回

00:13:27.499 --> 00:13:30.679
告诉我你什么时候做完，因为

00:13:28.910 --> 00:13:31.999
我不知道什么时候虚无

00:13:30.679 --> 00:13:33.949
返回我不想阻止等待

00:13:31.999 --> 00:13:35.720
为此，在被动世界中

00:13:33.949 --> 00:13:37.789
发布者的想法使该东西无效

00:13:35.720 --> 00:13:39.559
将表示完成，但永远不会

00:13:37.789 --> 00:13:41.720
实际发送任何数据是我们的方式

00:13:39.559 --> 00:13:43.489
代表这样，当你不能开始

00:13:41.720 --> 00:13:44.899
我不知道你什么时候交易

00:13:43.489 --> 00:13:46.910
将通过网络发送数据包

00:13:44.899 --> 00:13:48.529
实际开始交易，但是

00:13:46.910 --> 00:13:50.720
一旦完成，就让我知道

00:13:48.529 --> 00:13:54.069
那会释放，我会去执行

00:13:50.720 --> 00:13:54.069
之后发生的一些事情

00:13:55.749 --> 00:14:02.389
这才是真正的地方

00:13:57.799 --> 00:14:03.889
对开发人员很有趣，所以一旦您

00:14:02.389 --> 00:14:06.079
有一个声明，批处理看起来几乎

00:14:03.889 --> 00:14:07.519
就像这样，我们只是不去

00:14:06.079 --> 00:14:09.709
谈论它，因为api是

00:14:07.519 --> 00:14:11.989
所以该死的彼此相似

00:14:09.709 --> 00:14:14.809
让您可以立即绑定

00:14:11.989 --> 00:14:16.069
您可以通过某种方式绑定的数据权利

00:14:14.809 --> 00:14:18.139
我们将要讨论的标识符

00:14:16.069 --> 00:14:19.970
在一些即将出现的例子中

00:14:18.139 --> 00:14:21.889
但是另一种未成年人

00:14:19.970 --> 00:14:24.679
我们选择的设计原则

00:14:21.889 --> 00:14:26.569
基本上是说很少

00:14:24.679 --> 00:14:28.789
 SQL实际上是可移植的

00:14:26.569 --> 00:14:31.489
数据库肯定有你知道

00:14:28.789 --> 00:14:33.319
您可以使用的一种ANSI SQL方言

00:14:31.489 --> 00:14:34.910
使用，但如果您看一下

00:14:33.319 --> 00:14:37.220
发生在像

00:14:34.910 --> 00:14:39.470
冬眠或Eclipse链接他们真的

00:14:37.220 --> 00:14:41.629
真的大量使用方言

00:14:39.470 --> 00:14:43.970
他们写的SQL语句是

00:14:41.629 --> 00:14:46.999
针对Postgres for Oracle进行了优化

00:14:43.970 --> 00:14:48.410
 db2，所以我们现实地说

00:14:46.999 --> 00:14:50.569
旨在针对的工具

00:14:48.410 --> 00:14:52.069
可以理解的工具

00:14:50.569 --> 00:14:53.600
数据库的方言

00:14:52.069 --> 00:14:55.850
他们实际上是在连接

00:14:53.600 --> 00:14:59.569
无论他们的标识符沙皇在

00:14:55.850 --> 00:15:01.249
 Postgres其美元一正确的美元二

00:14:59.569 --> 00:15:03.169
 Postgres所说的三美元

00:15:01.249 --> 00:15:05.029
它们是适当的绑定标记

00:15:03.169 --> 00:15:07.009
但是如果你看看像

00:15:05.029 --> 00:15:09.199
 Microsoft续集，他们使用命名绑定

00:15:07.009 --> 00:15:11.689
像它们是@符号的参数

00:15:09.199 --> 00:15:13.669
紧随其后的名称以及所有

00:15:11.689 --> 00:15:15.379
其他数据库具有本机方式

00:15:13.669 --> 00:15:16.939
甲骨文冒号名称的绑定

00:15:15.379 --> 00:15:19.369
可能会花很长时间，所以我已经

00:15:16.939 --> 00:15:22.129
实际上看了Oracle 

00:15:19.369 --> 00:15:23.779
直接语法，我们希望您能够

00:15:22.129 --> 00:15:25.639
说好吧我已经写了一个SQL 

00:15:23.779 --> 00:15:28.100
我想绑定到该声明

00:15:25.639 --> 00:15:30.529
特定标识符交替出现

00:15:28.100 --> 00:15:32.060
可以简单地绑定到位置权

00:15:30.529 --> 00:15:34.280
这真的很特别

00:15:32.060 --> 00:15:36.350
在使用这个想法的情况下，我

00:15:34.280 --> 00:15:38.150
去用bind绑定到零

00:15:36.350 --> 00:15:40.400
标记第一个地雷玛格丽特第二个

00:15:38.150 --> 00:15:42.590
绑定标记，我们确实决定

00:15:40.400 --> 00:15:44.540
破坏了与JDBC的兼容性

00:15:42.590 --> 00:15:47.030
没什么大不了的

00:15:44.540 --> 00:15:50.060
此项目中的JDBC，但为零

00:15:47.030 --> 00:15:52.610
索引位置绑定以及

00:15:50.060 --> 00:15:54.380
然后最终，一旦您完成所有

00:15:52.610 --> 00:15:55.450
绑定，您将其添加为一行

00:15:54.380 --> 00:15:57.680
我们将讨论如何

00:15:55.450 --> 00:15:59.990
准备的语句批处理工作使用

00:15:57.680 --> 00:16:01.940
添加您可以选择是否返回

00:15:59.990 --> 00:16:03.680
如果您正在访问一个生成的值

00:16:01.940 --> 00:16:05.270
可能创建ID的数据库

00:16:03.680 --> 00:16:07.460
自动为您，然后

00:16:05.270 --> 00:16:09.650
最终，您将调用执行， 

00:16:07.460 --> 00:16:11.450
再次执行说我不知道

00:16:09.650 --> 00:16:12.830
当您要发送此查询时

00:16:11.450 --> 00:16:14.660
您将发送所有这些数据， 

00:16:12.830 --> 00:16:17.000
您将其绑定到数据库，但是一次

00:16:14.660 --> 00:16:19.340
你已经做到了，请把我交回来

00:16:17.000 --> 00:16:21.920
结果或在多个情况下

00:16:19.340 --> 00:16:24.560
陈述行为使我退缩

00:16:21.920 --> 00:16:29.300
每件事的结果流

00:16:24.560 --> 00:16:31.340
你代表我做了结果

00:16:29.300 --> 00:16:33.140
让我有能力找出

00:16:31.340 --> 00:16:34.940
实际更新的行数

00:16:33.140 --> 00:16:37.640
进行插入或更新的常用方法

00:16:34.940 --> 00:16:39.500
然后这就是所有的大事

00:16:37.640 --> 00:16:41.090
唯一的另一件事就是要付出

00:16:39.500 --> 00:16:42.950
你真的有能力再做一次

00:16:41.090 --> 00:16:46.190
真的很简单

00:16:42.950 --> 00:16:48.380
元数据转换将其转换为

00:16:46.190 --> 00:16:50.150
茶的出版商，所以基本上

00:16:48.380 --> 00:16:52.250
此行以及有关此的一些信息

00:16:50.150 --> 00:16:55.490
行并将其映射为对象将其旋转

00:16:52.250 --> 00:16:57.140
转换为字符串将其转换为整数或

00:16:55.490 --> 00:16:59.630
像这样，然后发布

00:16:57.140 --> 00:17:01.520
回到我身上，我将开始变得

00:16:59.630 --> 00:17:04.520
每个人的源头

00:17:01.520 --> 00:17:06.110
行本身真的真的很简单

00:17:04.520 --> 00:17:11.690
上面的API仅允许您获取

00:17:06.110 --> 00:17:14.750
对象通过其标识符获取列

00:17:11.690 --> 00:17:19.280
并可能向驾驶员暗示

00:17:14.750 --> 00:17:21.350
输入您想要它返回的内容，以便

00:17:19.280 --> 00:17:27.590
当我们看到这是什么样子

00:17:21.350 --> 00:17:30.080
实际写一些代码对吧

00:17:27.590 --> 00:17:33.500
我们正在看这里

00:17:30.080 --> 00:17:35.420
连接工厂创建一个新的

00:17:33.500 --> 00:17:36.980
从它和某处的连接

00:17:35.420 --> 00:17:38.930
未来，我们将被赋予

00:17:36.980 --> 00:17:40.430
在我们特定情况下的连接

00:17:38.930 --> 00:17:44.330
我们称其为平面图

00:17:40.430 --> 00:17:45.420
很多，如果您熟悉项目

00:17:44.330 --> 00:17:48.030
反应堆

00:17:45.420 --> 00:17:50.550
所以我们不依赖于

00:17:48.030 --> 00:17:52.590
 SPI级别，但实际上所有

00:17:50.550 --> 00:17:55.110
实现需要反应

00:17:52.590 --> 00:17:56.760
幕后的框架等等

00:17:55.110 --> 00:17:58.950
每个人都是反应式框架

00:17:56.760 --> 00:18:00.690
在房子的Spring 侧使用的是

00:17:58.950 --> 00:18:02.730
将成为项目反应堆，它使

00:18:00.690 --> 00:18:05.040
这种想法之间的区别

00:18:02.730 --> 00:18:08.520
通量是元素流

00:18:05.040 --> 00:18:10.470
 0至n个元素和单声道0至1 

00:18:08.520 --> 00:18:12.420
发布者没有的元素

00:18:10.470 --> 00:18:14.430
想法权发布者基本上说这是

00:18:12.420 --> 00:18:16.620
 0至n个元素，但我们发现

00:18:14.430 --> 00:18:18.810
实验性的，或者你知道

00:18:16.620 --> 00:18:21.150
与开发人员交谈时练习

00:18:18.810 --> 00:18:22.860
如果你只是说好话的想法

00:18:21.150 --> 00:18:24.690
要取回一个实际上是

00:18:22.860 --> 00:18:25.890
我们想要的是非常有趣的事情

00:18:24.690 --> 00:18:28.290
具有一流的

00:18:25.890 --> 00:18:29.930
一流的操作就可以了

00:18:28.290 --> 00:18:33.120
在这种情况下，连接工厂

00:18:29.930 --> 00:18:35.400
创建一个该连接的单声道

00:18:33.120 --> 00:18:37.140
然后我们想将其平面映射到许多

00:18:35.400 --> 00:18:39.270
我们为什么要讨价还价

00:18:37.140 --> 00:18:41.340
实际上这是我要你的意思

00:18:39.270 --> 00:18:44.640
把这件事变成它

00:18:41.340 --> 00:18:46.380
 n件事，所以我们建立了联系

00:18:44.640 --> 00:18:48.540
在这种情况下创建一个语句选择

00:18:46.380 --> 00:18:51.930
测试的价值，我们执行

00:18:48.540 --> 00:18:54.870
对我们来说回来的是

00:18:51.930 --> 00:18:56.820
结果我们将结果映射为

00:18:54.870 --> 00:18:59.310
基本上说到每一行

00:18:56.820 --> 00:19:01.890
返回我要你去给我​​带来价值

00:18:59.310 --> 00:19:04.410
从那里以及内部的每个数据库

00:19:01.890 --> 00:19:07.320
每个artoo DBC的驱动程序实现

00:19:04.410 --> 00:19:08.940
实施有机会做

00:19:07.320 --> 00:19:10.950
一旦你没有给它一个整体

00:19:08.940 --> 00:19:13.140
很多东西很多信息

00:19:10.950 --> 00:19:15.060
关于你想要什么，但是你知道

00:19:13.140 --> 00:19:16.800
数据库驱动程序通常知道正确

00:19:15.060 --> 00:19:18.270
您将某些内容作为int 

00:19:16.800 --> 00:19:19.710
 Postgres它知道需要回来

00:19:18.270 --> 00:19:21.240
发送整数，您将某些内容放入

00:19:19.710 --> 00:19:23.400
一个INT 8，你知道它需要回来

00:19:21.240 --> 00:19:25.500
跟着你把一些东西作为VAR 

00:19:23.400 --> 00:19:29.580
好车，还有一点

00:19:25.500 --> 00:19:31.650
有趣的权利，所以除了这个

00:19:29.580 --> 00:19:33.330
您可能会做一点修改

00:19:31.650 --> 00:19:36.030
现在说我要你把我交还

00:19:33.330 --> 00:19:37.620
正确的字符串，我相信他们会这样

00:19:36.030 --> 00:19:40.170
在我们的实现中， 

00:19:37.620 --> 00:19:41.640
优先规则，但实际上是

00:19:40.170 --> 00:19:43.410
想回来说好，我想

00:19:41.640 --> 00:19:44.910
你还给我一个字符串，还有什么

00:19:43.410 --> 00:19:47.040
有效地从中可以

00:19:44.910 --> 00:19:50.010
看到顶部是这个值

00:19:47.040 --> 00:19:52.560
发布者说现在我有一个

00:19:50.010 --> 00:19:54.840
这些价值中的每一个我都不再

00:19:52.560 --> 00:19:56.370
处理你知道的数据库

00:19:54.840 --> 00:19:59.550
连接或类似的东西

00:19:56.370 --> 00:20:02.130
交给我的东西是0到n 

00:19:59.550 --> 00:20:05.010
对应于值的字符串

00:20:02.130 --> 00:20:07.350
列和将到达的每一行

00:20:05.010 --> 00:20:09.090
我在将来的某个时候

00:20:07.350 --> 00:20:10.590
真的不知道那是什么

00:20:09.090 --> 00:20:12.960
线程我不知道它是什么线程

00:20:10.590 --> 00:20:14.970
将要进行的时间以及完成的时间

00:20:12.960 --> 00:20:16.770
要么给我发一个错误说

00:20:14.970 --> 00:20:18.300
这里出了点问题，否则会

00:20:16.770 --> 00:20:20.070
给我一个完成阶段，告诉我

00:20:18.300 --> 00:20:22.020
完成向您发送数据后，您可以停止

00:20:20.070 --> 00:20:27.150
从特定的角度来关心它

00:20:22.020 --> 00:20:31.620
点，那么它看起来像什么

00:20:27.150 --> 00:20:33.330
此API一次插入数据

00:20:31.620 --> 00:20:36.660
再次，我们有我们的连接工厂

00:20:33.330 --> 00:20:38.490
创建我们做另一幅平面图，很多

00:20:36.660 --> 00:20:40.770
我们称连接创建语句

00:20:38.490 --> 00:20:42.990
插入测试值一美元

00:20:40.770 --> 00:20:47.760
正如我之前说过的，两美元

00:20:42.990 --> 00:20:49.890
坚持的决定

00:20:47.760 --> 00:20:51.810
每个的本地绑定参数

00:20:49.890 --> 00:20:53.910
这些数据库，所以在这个特定的

00:20:51.810 --> 00:20:57.620
情况I除了将R引向

00:20:53.910 --> 00:21:00.390
总体而言，DBC我也是

00:20:57.620 --> 00:21:01.410
那里的RTD BC的Postgres实现

00:21:00.390 --> 00:21:03.120
我们将讨论其他一些

00:21:01.410 --> 00:21:05.580
我实际上不是的实现

00:21:03.120 --> 00:21:07.560
以及铅，但这就是它的来源

00:21:05.580 --> 00:21:09.410
真的很有趣，因为对于那些

00:21:07.560 --> 00:21:11.670
那些不幸的人

00:21:09.410 --> 00:21:15.810
 JDBC API的百科全书学院

00:21:11.670 --> 00:21:17.760
您会记得我们拥有的API 

00:21:15.810 --> 00:21:19.530
这种说法的想法是的，但我们也

00:21:17.760 --> 00:21:20.640
有三种不同的想法

00:21:19.530 --> 00:21:21.720
声明中有一个声明

00:21:20.640 --> 00:21:24.540
有一个准备好的声明，有一个

00:21:21.720 --> 00:21:25.980
可收回的陈述，如果你们可以的话

00:21:24.540 --> 00:21:27.990
告诉我这些之间的区别

00:21:25.980 --> 00:21:29.460
三，确切地说，当你应该

00:21:27.990 --> 00:21:32.370
使用所有这些，你会更好

00:21:29.460 --> 00:21:34.040
开发人员比我将永远成为事物

00:21:32.370 --> 00:21:37.520
如果你曾经看过

00:21:34.040 --> 00:21:40.410
这些在内部的实现

00:21:37.520 --> 00:21:42.540
在JDBC驱动程序内部

00:21:40.410 --> 00:21:44.130
将其委托给单一方式

00:21:42.540 --> 00:21:46.590
您通过数据库与数据库进行通信

00:21:44.130 --> 00:21:49.410
有线协议所有这些数据库

00:21:46.590 --> 00:21:51.630
几天希望您发送一些

00:21:49.410 --> 00:21:53.400
可以选择在其中包含一些绑定标记

00:21:51.630 --> 00:21:55.320
它可能会发送一堆帧

00:21:53.400 --> 00:21:57.360
谈论如何将数据绑定到所有人

00:21:55.320 --> 00:21:59.310
那件事，然后将它们全部归还

00:21:57.360 --> 00:22:00.540
准确地对待每个调用

00:21:59.310 --> 00:22:03.210
一样，所以我们说如果是真的

00:22:00.540 --> 00:22:05.130
让我们不要保留所有繁琐的倍数

00:22:03.210 --> 00:22:06.600
不同类型的陈述

00:22:05.130 --> 00:22:08.370
相反，想要的只是一种

00:22:06.600 --> 00:22:10.350
声明我们绑定的地方的声明

00:22:08.370 --> 00:22:12.330
一些东西，然后你会注意到

00:22:10.350 --> 00:22:13.559
有效地准备我们正在做的事情

00:22:12.330 --> 00:22:15.750
语句批处理

00:22:13.559 --> 00:22:17.580
你想绑定一美元，我想

00:22:15.750 --> 00:22:19.710
绑定数字100然后绑定到

00:22:17.580 --> 00:22:21.960
美元二，想要绑定数字

00:22:19.710 --> 00:22:24.299
 200这实际上是倍数

00:22:21.960 --> 00:22:26.429
位置，但一次插入

00:22:24.299 --> 00:22:28.799
现在就可以声明

00:22:26.429 --> 00:22:30.840
如果您只想执行以下一项操作，请执行

00:22:28.799 --> 00:22:32.940
这些很好，隐含地

00:22:30.840 --> 00:22:34.919
说好吧，这一定是你的路

00:22:32.940 --> 00:22:36.270
想插入，但我们也有

00:22:34.919 --> 00:22:38.460
说的能力实际上是真的

00:22:36.270 --> 00:22:40.350
对于大多数这些数据库，如果有效

00:22:38.460 --> 00:22:42.690
您要做的就是发送SQL查询

00:22:40.350 --> 00:22:44.880
然后有效地发送一张桌子

00:22:42.690 --> 00:22:46.679
跟随它的数据，所以我们想要

00:22:44.880 --> 00:22:49.230
要做的是说基本上添加这是一个

00:22:46.679 --> 00:22:51.120
回车，这说好，我是

00:22:49.230 --> 00:22:52.919
完成了我们所有的绑定

00:22:51.120 --> 00:22:54.630
需要做的是让我将其捕捉回

00:22:52.919 --> 00:22:56.460
开始，让我再做一排

00:22:54.630 --> 00:22:58.770
绑定，您就有能力

00:22:56.460 --> 00:23:01.049
多次拨打次品

00:22:58.770 --> 00:23:02.909
您想添加尽可能多的行

00:23:01.049 --> 00:23:05.669
想要，然后最终在某个时候

00:23:02.909 --> 00:23:07.559
将来您会再次调用执行

00:23:05.669 --> 00:23:10.169
在最后一个上有点可选

00:23:07.559 --> 00:23:12.330
因为我们假设您是要开始

00:23:10.169 --> 00:23:13.770
有效地换一条新线，或者你曾经

00:23:12.330 --> 00:23:16.020
有效地结束了你的路

00:23:13.770 --> 00:23:18.120
像回车一样

00:23:16.020 --> 00:23:20.190
阻止将所有数据发送到

00:23:18.120 --> 00:23:22.860
真正高效的数据库

00:23:20.190 --> 00:23:24.419
这次我们会注意到的方式

00:23:22.860 --> 00:23:25.980
周围我们没有做任何事情

00:23:24.419 --> 00:23:27.900
数据，所以我们最终只能得到发布者

00:23:25.980 --> 00:23:31.470
结果的每个插入

00:23:27.900 --> 00:23:34.380
行在所有方面都与之相关

00:23:31.470 --> 00:23:35.789
有效地建立每个合理的数据库

00:23:34.380 --> 00:23:38.340
结果将包含

00:23:35.789 --> 00:23:40.169
是您的整数行数

00:23:38.340 --> 00:23:42.090
实际上插入正确，所以我希望

00:23:40.169 --> 00:23:45.330
基本上得到一堆结果

00:23:42.090 --> 00:23:47.549
那说1 1 1 1 1 1但你可以

00:23:45.330 --> 00:23:50.090
记住你可以想到类似

00:23:47.549 --> 00:23:52.679
用这个来做更新

00:23:50.090 --> 00:23:55.620
乐观锁定，例如

00:23:52.679 --> 00:23:57.480
您仅在以下情况下更新特定行

00:23:55.620 --> 00:23:58.980
版本号与先前的版本号匹配

00:23:57.480 --> 00:24:01.289
版本号，然后您可以期待

00:23:58.980 --> 00:24:03.240
是更新的一行是零行

00:24:01.289 --> 00:24:05.370
更新后我是否需要尝试拥有

00:24:03.240 --> 00:24:07.440
另一个与此很常见

00:24:05.370 --> 00:24:09.600
尤其是在ORM内部的模式是

00:24:07.440 --> 00:24:14.730
乐观锁定的想法，那就是

00:24:09.600 --> 00:24:17.390
现在从这里获得所有支持

00:24:14.730 --> 00:24:20.929
看一下相同的准备插入

00:24:17.390 --> 00:24:23.070
这样添加交易意味着什么

00:24:20.929 --> 00:24:26.640
奇迹的奇迹

00:24:23.070 --> 00:24:27.430
我们有交易能力，这不是

00:24:26.640 --> 00:24:29.500
放弃可以

00:24:27.430 --> 00:24:32.080
整个这件事你都不会

00:24:29.500 --> 00:24:33.970
真正了解什么时候是

00:24:32.080 --> 00:24:35.740
被执行，所以我们在你的流程中

00:24:33.970 --> 00:24:37.030
可以实际发送框架开始

00:24:35.740 --> 00:24:39.820
交易或提交交易

00:24:37.030 --> 00:24:41.410
回滚，但我们终于得到了

00:24:39.820 --> 00:24:43.270
那里又有一张平面图

00:24:41.410 --> 00:24:45.790
我们建立连接，我们开始

00:24:43.270 --> 00:24:47.800
然后与该连接进行交易

00:24:45.790 --> 00:24:52.450
从那里开始，如果您还记得开始的话

00:24:47.800 --> 00:24:54.160
交易对发行人有影响

00:24:52.450 --> 00:24:57.400
无效吧，所以说好了，我完成了

00:24:54.160 --> 00:24:59.710
然后我想接受并说创造

00:24:57.400 --> 00:25:01.570
一条语句在其中插入几行

00:24:59.710 --> 00:25:03.850
然后我做这个被称为

00:25:01.570 --> 00:25:05.590
延迟直到您真的必须

00:25:03.850 --> 00:25:06.850
了解反应堆，我一直在使用它

00:25:05.590 --> 00:25:08.890
很多要理解的基本上是说

00:25:06.850 --> 00:25:11.500
保留之前发生的数据

00:25:08.890 --> 00:25:14.020
提交交易，让所有

00:25:11.500 --> 00:25:15.730
的数据通过，但会发生什么

00:25:14.020 --> 00:25:17.410
如果有错误，如果其中之一

00:25:15.730 --> 00:25:19.480
插入物在一条道路上

00:25:17.410 --> 00:25:21.160
已经存在，所以您将其废除

00:25:19.480 --> 00:25:22.510
实际上不应该在那里

00:25:21.160 --> 00:25:24.910
错误随时可能再次出现

00:25:22.510 --> 00:25:27.130
所以有可能我们从未真正致电

00:25:24.910 --> 00:25:29.050
确认交易而不是必须

00:25:27.130 --> 00:25:31.270
调用错误恢复简历回滚

00:25:29.050 --> 00:25:33.250
交易但不能丢失错误，因此

00:25:31.270 --> 00:25:35.050
然后，我们必须发送单声道错误

00:25:33.250 --> 00:25:36.820
除了其中的例外

00:25:35.050 --> 00:25:39.160
以前，现在突然之间，您开始

00:25:36.820 --> 00:25:41.770
看着这个，你要去的是

00:25:39.160 --> 00:25:44.050
不是我想写的代码， 

00:25:41.770 --> 00:25:45.640
您最终看到的是为了

00:25:44.050 --> 00:25:48.550
那些谁能记住任何

00:25:45.640 --> 00:25:50.350
您的JDBC东西对我们而言

00:25:48.550 --> 00:25:52.990
实际上在谈论那种模式

00:25:50.350 --> 00:25:55.090
最后有这个延迟，直到

00:25:52.990 --> 00:25:56.950
在错误恢复卷上提交事务

00:25:55.090 --> 00:25:59.950
退回交易，然后转发

00:25:56.950 --> 00:26:02.080
空气这是尝试赶上最后尝试

00:25:59.950 --> 00:26:05.140
缓存所有人的方式

00:26:02.080 --> 00:26:07.630
 JDBC的原始方式，我们所有人

00:26:05.140 --> 00:26:09.400
像我保证开始一样搞砸了

00:26:07.630 --> 00:26:10.750
我的职业生涯前六个漏洞

00:26:09.400 --> 00:26:13.780
写道我们是因为我没有尝试

00:26:10.750 --> 00:26:15.940
抓住最后尝试抓住，所以它是可用的

00:26:13.780 --> 00:26:18.130
对，这有效地带我们回到了

00:26:15.940 --> 00:26:20.920
 JDBC刚开始时的位置

00:26:18.130 --> 00:26:22.360
非常冗长，容易出错，只是

00:26:20.920 --> 00:26:23.920
时间的问题，所以你忘了知道

00:26:22.360 --> 00:26:27.100
处理错误并进行回滚

00:26:23.920 --> 00:26:30.100
在那里，但要记住我们的专注

00:26:27.100 --> 00:26:32.740
重点是驱动程序SPI包含

00:26:30.100 --> 00:26:34.720
最小的一组操作

00:26:32.740 --> 00:26:38.650
具体实施，一无所获

00:26:34.720 --> 00:26:41.260
在正确之前，这意味着我们

00:26:38.650 --> 00:26:42.880
实际设计为此看起来

00:26:41.260 --> 00:26:46.270
真的很糟糕，很难

00:26:42.880 --> 00:26:49.570
使用，这似乎超级疯狂吧，但是

00:26:46.270 --> 00:26:52.150
我们需要的是人道的客户牡丹

00:26:49.570 --> 00:26:54.460
您不应该使用此代码

00:26:52.150 --> 00:26:58.450
需要的是一群人道的客户

00:26:54.460 --> 00:27:00.429
牡丹，作为你的示范

00:26:58.450 --> 00:27:03.600
可能与我们两个DBC有关

00:27:00.429 --> 00:27:06.309
名为r2 DBC客户端的项目， 

00:27:03.600 --> 00:27:09.010
从根本上启发了窃取

00:27:06.309 --> 00:27:10.330
 JD bi的故事从来都不应该排序

00:27:09.010 --> 00:27:12.100
投入生产或类似

00:27:10.330 --> 00:27:14.049
那，但如果您熟悉JD bi 

00:27:12.100 --> 00:27:16.570
您会看到很多相同类型的

00:27:14.049 --> 00:27:18.040
这个想法，我们有一个r2 DBC 

00:27:16.570 --> 00:27:21.549
对象我不知道到底是什么

00:27:18.040 --> 00:27:22.990
那就是说带手柄的手柄是

00:27:21.549 --> 00:27:24.610
基本上只是一个包装

00:27:22.990 --> 00:27:26.919
连接和一大堆其他

00:27:24.610 --> 00:27:28.720
状态和自动映射器及事物

00:27:26.919 --> 00:27:31.179
那样，我们要做一些事情

00:27:28.720 --> 00:27:32.980
比较流利吧

00:27:31.179 --> 00:27:34.330
它不是带有

00:27:32.980 --> 00:27:36.700
某种特定的东西相反，我们是

00:27:34.330 --> 00:27:38.530
只是要说选择，我们必须把

00:27:36.700 --> 00:27:40.330
在其中选择样式声明，然后

00:27:38.530 --> 00:27:42.760
发生的事情是当我们回来时，我们

00:27:40.330 --> 00:27:46.270
做某种映射注意此图

00:27:42.760 --> 00:27:48.309
行，我们最多不映射行和元数据

00:27:46.270 --> 00:27:51.220
那个时候没人在意

00:27:48.309 --> 00:27:53.260
想一想您实际使用JDBC的方式

00:27:51.220 --> 00:27:55.179
您访问数据库，如果我要

00:27:53.260 --> 00:27:56.470
从测试中选择值，我知道这是一个

00:27:55.179 --> 00:27:58.480
正确的字符串，就像我不需要

00:27:56.470 --> 00:28:01.059
检查任何元数据以找出工具

00:27:58.480 --> 00:28:02.380
可能需要但实际上我是

00:28:01.059 --> 00:28:03.970
应用程序开发人员我知道那是什么

00:28:02.380 --> 00:28:06.940
专栏将成为你永远可以

00:28:03.970 --> 00:28:10.330
回到原始的JDBC API，但

00:28:06.940 --> 00:28:11.740
这是一个人性化的API，这就是

00:28:10.330 --> 00:28:13.510
是大多数人实际使用的方式

00:28:11.740 --> 00:28:15.429
要这样做，你甚至会注意到

00:28:13.510 --> 00:28:19.530
从那里，我们实际上回到

00:28:15.429 --> 00:28:23.770
来自此权利的流量，我们在r2 DBC中

00:28:19.530 --> 00:28:26.230
 api非常重视

00:28:23.770 --> 00:28:28.299
使用反应性完全中性

00:28:26.230 --> 00:28:31.000
流API，您可以想象未来

00:28:28.299 --> 00:28:33.280
每个人都升级后，超越Java 9 

00:28:31.000 --> 00:28:35.350
到11或更远，我们可能会打开

00:28:33.280 --> 00:28:36.610
流动或类似的想法

00:28:35.350 --> 00:28:38.830
我们想要坚持的东西

00:28:36.610 --> 00:28:41.830
完全中立，但是当我们

00:28:38.830 --> 00:28:43.419
人道的api的我们可以认为我们

00:28:41.830 --> 00:28:45.429
可以说您知道大多数 Spring 用户

00:28:43.419 --> 00:28:47.559
真的在使用反应堆，也许我们应该

00:28:45.429 --> 00:28:50.320
返回通量和单声道而不是原始

00:28:47.559 --> 00:28:51.310
出版商好吧，也许你就是你

00:28:50.320 --> 00:28:53.050
知道

00:28:51.310 --> 00:28:56.200
 Juke实施者，您将更加

00:28:53.050 --> 00:28:59.320
 RX Java之类的

00:28:56.200 --> 00:29:02.080
返回单身和可流动的z-我认为

00:28:59.320 --> 00:29:04.000
他们叫什么，你可以拥有那些

00:29:02.080 --> 00:29:07.360
该客户的意见和

00:29:04.000 --> 00:29:11.680
与您的团队真正合作

00:29:07.360 --> 00:29:15.400
客户准备好的插入物是什么

00:29:11.680 --> 00:29:17.800
看起来又像是对不起我

00:29:15.400 --> 00:29:20.200
处理也许我们会创建一个更新

00:29:17.800 --> 00:29:21.790
这次我们绑定执行

00:29:20.200 --> 00:29:23.800
您会注意到我们不必做

00:29:21.790 --> 00:29:25.120
映射那种拉出

00:29:23.800 --> 00:29:26.800
行数之类的

00:29:25.120 --> 00:29:28.450
其实我应该被吃掉了

00:29:26.800 --> 00:29:31.330
您输入的助焊剂字符串量

00:29:28.450 --> 00:29:32.260
昨晚有点晚，它只是返回

00:29:31.330 --> 00:29:33.820
更新的行

00:29:32.260 --> 00:29:35.380
实际上我们当中没有一个人看起来

00:29:33.820 --> 00:29:37.330
在要返回的行数上

00:29:35.380 --> 00:29:40.570
假设这可能就是你

00:29:37.330 --> 00:29:45.370
想使用客户端来做

00:29:40.570 --> 00:29:47.200
这样，现在您看到了一个客户

00:29:45.370 --> 00:29:49.060
可以给你正确的，让我们看一下

00:29:47.200 --> 00:29:51.220
后面是插入物的样子

00:29:49.060 --> 00:29:54.100
您会注意到其中说r2 DBC的位置

00:29:51.220 --> 00:29:57.070
在这里处理，但现在如果我们想去

00:29:54.100 --> 00:29:59.470
交易非常简单

00:29:57.070 --> 00:30:01.120
正确的只是一个小词，但

00:29:59.470 --> 00:30:03.520
否则看起来完全一样

00:30:01.120 --> 00:30:05.860
因为在内部您希望有一个客户

00:30:03.520 --> 00:30:08.050
实施尝试赶上最后尝试

00:30:05.860 --> 00:30:11.680
捕捉行为延迟到

00:30:08.050 --> 00:30:13.990
错误恢复，然后出现单声道错误

00:30:11.680 --> 00:30:15.910
行为，您可以隐藏所有这些和

00:30:13.990 --> 00:30:18.880
用户只是真正地做某事

00:30:15.910 --> 00:30:21.640
很简单，但是都是JD bi 

00:30:18.880 --> 00:30:23.830
灵感飞到api的你知道排序

00:30:21.640 --> 00:30:25.840
我开始尝试做的

00:30:23.830 --> 00:30:28.690
例如，我们可以走得更远

00:30:25.840 --> 00:30:30.730
对，如果您是spring数据用户怎么办

00:30:28.690 --> 00:30:32.530
已经并且您喜欢很多api的

00:30:30.730 --> 00:30:35.110
 spring data 可以使您满意

00:30:32.530 --> 00:30:37.540
建立在该r2 DBC API之上

00:30:35.110 --> 00:30:39.010
完全不人道，但实际上是他们

00:30:37.540 --> 00:30:41.530
想要这样做，因为他们需要这样做

00:30:39.010 --> 00:30:43.360
程序性行为很多，所以他们已经

00:30:41.530 --> 00:30:46.210
在 spring data RTD BC中创建

00:30:43.360 --> 00:30:48.220
投影此数据库客户端的内容

00:30:46.210 --> 00:30:52.270
 RTD我们的连接工厂之一

00:30:48.220 --> 00:30:55.240
公元前，它允许您说执行一些

00:30:52.270 --> 00:30:56.590
 SQL绑定和这种特殊情况之一

00:30:55.240 --> 00:31:00.130
真正伟大的事情是

00:30:56.590 --> 00:31:02.290
 spring data RTD BC项目全在

00:31:00.130 --> 00:31:03.910
在命名绑定上不再像这样

00:31:02.290 --> 00:31:04.630
问不了这美元

00:31:03.910 --> 00:31:06.640
一

00:31:04.630 --> 00:31:08.410
他们将在内部进行方言工作

00:31:06.640 --> 00:31:12.520
以确保您始终使用

00:31:08.410 --> 00:31:15.190
真的很描述性的SQL表达式

00:31:12.520 --> 00:31:16.660
对，你应该一直在说：名字

00:31:15.190 --> 00:31:19.210
你应该永远是你知道

00:31:16.660 --> 00:31:22.390
那里的某种情境事物

00:31:19.210 --> 00:31:25.570
所以现在您按名称绑定特定的

00:31:22.390 --> 00:31:27.130
当你想做时告诉你的价值

00:31:25.570 --> 00:31:29.830
我想要的选择数据

00:31:27.130 --> 00:31:33.250
请自动将其映射回

00:31:29.830 --> 00:31:36.670
我一个人去拿所有这些

00:31:33.250 --> 00:31:38.980
你去，所以现在还不算JPA 

00:31:36.670 --> 00:31:41.260
是的，但是确实有点

00:31:38.980 --> 00:31:43.360
真的以有限的方式变暖

00:31:41.260 --> 00:31:47.950
灵活的绝佳选择，如果您

00:31:43.360 --> 00:31:50.200
像我歪一样飞进api 

00:31:47.950 --> 00:31:53.830
反过来说，我很喜欢

00:31:50.200 --> 00:31:56.110
亲自从Spring数据存储库

00:31:53.830 --> 00:31:58.390
相反，Spring数据存储库是

00:31:56.110 --> 00:32:01.690
对我来说很棒，因为我可以写一个

00:31:58.390 --> 00:32:03.820
你们知道的很简单

00:32:01.690 --> 00:32:06.490
接口中的方法声明和

00:32:03.820 --> 00:32:08.080
我允许真正聪​​明的团队

00:32:06.490 --> 00:32:10.210
 Spring 的数据，所以我们得到了如何扭转

00:32:08.080 --> 00:32:12.340
到SQL查询如何将其变成

00:32:10.210 --> 00:32:15.640
我们需要完成的映射

00:32:12.340 --> 00:32:18.760
当前的特殊情况

00:32:15.640 --> 00:32:20.230
释放，因为我们不是

00:32:18.760 --> 00:32:21.880
建立在具有

00:32:20.230 --> 00:32:24.100
一堆模式信息

00:32:21.880 --> 00:32:26.290
仍然需要编写查询，但是我们

00:32:24.100 --> 00:32:28.920
获得说出的名字之间的自动映射

00:32:26.290 --> 00:32:31.360
参数和名称参数

00:32:28.920 --> 00:32:33.250
在这两者之间，我们得到了

00:32:31.360 --> 00:32:35.530
客户回去，以便它自动知道

00:32:33.250 --> 00:32:37.210
而不是在这里描述

00:32:35.530 --> 00:32:38.920
我希望您将这些行作为

00:32:37.210 --> 00:32:40.900
知道的人嘿，我可以检查

00:32:38.920 --> 00:32:42.460
这个，知道你想要一个

00:32:40.900 --> 00:32:44.980
顾客回来给我们

00:32:42.460 --> 00:32:47.050
执行该存储库的能力

00:32:44.980 --> 00:32:49.030
姓，然后每个

00:32:47.050 --> 00:32:50.620
在这种情况下只需打印即可

00:32:49.030 --> 00:32:53.920
找出每个人的名字

00:32:50.620 --> 00:32:55.960
这些马修斯人中，所以我发现

00:32:53.920 --> 00:32:58.120
你对我的风格了解更多，但

00:32:55.960 --> 00:33:00.820
这里的关键要点是你没有

00:32:58.120 --> 00:33:02.650
决定之间，就像我不必

00:33:00.820 --> 00:33:05.050
如您所知，决定参与其中

00:33:02.650 --> 00:33:07.510
 RTD BC项目，我们希望所有这些

00:33:05.050 --> 00:33:10.540
每个人都有机会

00:33:07.510 --> 00:33:12.490
一个开发人员之一，所以我们

00:33:10.540 --> 00:33:14.950
现在来看看一些

00:33:12.490 --> 00:33:16.870
公元前2d的其他功能

00:33:14.950 --> 00:33:18.390
不仅仅是它的用途，因为

00:33:16.870 --> 00:33:21.180
原来是

00:33:18.390 --> 00:33:25.230
只要您知道使用客户端API或

00:33:21.180 --> 00:33:27.410
使用驱动程序spi确实

00:33:25.230 --> 00:33:29.850
周围还有很多其他事情

00:33:27.410 --> 00:33:31.650
使用真正的数据库驱动程序

00:33:29.850 --> 00:33:35.870
有趣，所以其中之一是

00:33:31.650 --> 00:33:39.180
连接网址（如果您不知道） 

00:33:35.870 --> 00:33:41.160
 java中的连接URL解析是

00:33:39.180 --> 00:33:43.950
例如，实际上是有问题的

00:33:41.160 --> 00:33:46.110
 URI类没有

00:33:43.950 --> 00:33:47.400
 Java解析中的标准化方法

00:33:46.110 --> 00:33:48.930
查询参数

00:33:47.400 --> 00:33:51.780
你会认为这是非常重要的

00:33:48.930 --> 00:33:53.250
有点知道spring有一个数据库驱动程序

00:33:51.780 --> 00:33:54.990
有其他实现没有

00:33:53.250 --> 00:33:57.210
通用的方式，因为每个人

00:33:54.990 --> 00:33:59.460
严格按照规范进行

00:33:57.210 --> 00:34:00.630
因为URI规范是正确的

00:33:59.460 --> 00:34:03.270
结束查询参数所在的位置

00:34:00.630 --> 00:34:05.460
真的很粗略真的很粗略

00:34:03.270 --> 00:34:07.520
很难做到正确，所以其中之一

00:34:05.460 --> 00:34:10.740
我们选择在这里做的事情是说

00:34:07.520 --> 00:34:12.300
传递不透明的URL确实是

00:34:10.740 --> 00:34:13.620
对于很多数据库人来说，我都很重要

00:34:12.300 --> 00:34:15.980
来自我所说的Cloud Foundry 

00:34:13.620 --> 00:34:18.720
这意味着我们要做很多

00:34:15.980 --> 00:34:22.230
绑定到您的应用程序服务

00:34:18.720 --> 00:34:24.390
环境中有一个URL有spring boot 

00:34:22.230 --> 00:34:26.700
应用程序自动使用该URL 

00:34:24.390 --> 00:34:28.890
用户永远不会看到它在哪里

00:34:26.700 --> 00:34:31.730
它包含的信息，所以我们知道

00:34:28.890 --> 00:34:35.130
这是成为一个真正密集的好方法

00:34:31.730 --> 00:34:36.900
信息交流，但我们

00:34:35.130 --> 00:34:39.720
不想像狂野西部那样

00:34:36.900 --> 00:34:42.390
我们今天在JDBC中拥有

00:34:39.720 --> 00:34:44.310
选择要做的是向右移动

00:34:42.390 --> 00:34:47.370
将该网址解析为

00:34:44.310 --> 00:34:49.740
规范本身对不对

00:34:47.370 --> 00:34:52.470
做它的碎片，但我们会说

00:34:49.740 --> 00:34:55.080
拿那个顶级URL有两个DB CS 

00:34:52.470 --> 00:34:57.780
说我们想用TLS做到这一点

00:34:55.080 --> 00:35:02.010
加密或两个DB C连接

00:34:57.780 --> 00:35:03.390
 Postgres在 localhost 端口5432上带有

00:35:02.010 --> 00:35:06.450
在这种情况下，特定的数据库名称

00:35:03.390 --> 00:35:08.610
 db2并带有一些查询参数

00:35:06.450 --> 00:35:10.980
幕后的模式测试

00:35:08.610 --> 00:35:12.810
规范内的单一实现

00:35:10.980 --> 00:35:14.940
基本上将其解析为一堆

00:35:12.810 --> 00:35:16.320
的令牌说这是驱动程序名称

00:35:14.940 --> 00:35:18.690
这是主机名这是端口

00:35:16.320 --> 00:35:20.340
这里的名字叫一些随机的东西

00:35:18.690 --> 00:35:22.470
我不知道它是什么的模式

00:35:20.340 --> 00:35:24.660
我要交给你数据库驱动程序

00:35:22.470 --> 00:35:27.000
然后你决定如何解释

00:35:24.660 --> 00:35:28.470
它不是如何从URL中解析它

00:35:27.000 --> 00:35:30.570
每个人都在做不同的事情

00:35:28.470 --> 00:35:31.480
但是你一定要决定是什么意思

00:35:30.570 --> 00:35:33.609
给你

00:35:31.480 --> 00:35:35.920
和非常酷的副作用之一

00:35:33.609 --> 00:35:37.799
这就是说我们可以

00:35:35.920 --> 00:35:40.480
做一些非常有趣的装饰

00:35:37.799 --> 00:35:42.460
要做的时候正确包装

00:35:40.480 --> 00:35:46.329
集中我们不必改变

00:35:42.460 --> 00:35:49.119
正确的URL基本位

00:35:46.329 --> 00:35:52.059
仍然说Postgres本地化了54 32 DB 

00:35:49.119 --> 00:35:54.369
架构等于测试，但前提是

00:35:52.059 --> 00:35:57.670
 Postgres说我也要你

00:35:54.369 --> 00:35:58.960
做池，我希望池大小为

00:35:57.670 --> 00:36:01.390
我们放在一个查询参数上

00:35:58.960 --> 00:36:04.059
现在，我们有点像

00:36:01.390 --> 00:36:05.260
执行，我们去那里查找，我们

00:36:04.059 --> 00:36:07.119
最后，我们称这种情况为

00:36:05.260 --> 00:36:09.640
连接工厂传递一些东西

00:36:07.119 --> 00:36:12.549
在内部，我们使用说服务

00:36:09.640 --> 00:36:16.030
加载程序支持和Java去了解

00:36:12.549 --> 00:36:17.710
 r2 DBC世界中的谁将处理池

00:36:16.030 --> 00:36:19.569
而且该池知道如何配置

00:36:17.710 --> 00:36:23.049
反应池确保尺寸为

00:36:19.569 --> 00:36:24.549
恰好四个然后

00:36:23.049 --> 00:36:26.859
它不在乎的配置

00:36:24.549 --> 00:36:29.020
它是什么具体的数据库驱动程序

00:36:26.859 --> 00:36:30.670
什么主机端口数据库等

00:36:29.020 --> 00:36:32.680
参数进入那里，它将

00:36:30.670 --> 00:36:34.540
只是将那些委托给系统

00:36:32.680 --> 00:36:36.910
并允许使用其他数据库驱动程序

00:36:34.540 --> 00:36:39.030
而不是解释并包装它

00:36:36.910 --> 00:36:41.470
那里，这基本上是

00:36:39.030 --> 00:36:42.819
没完没了的权利，我们可以把它包装起来

00:36:41.470 --> 00:36:44.470
一秒钟要谈一点

00:36:42.819 --> 00:36:46.059
关于可观察性，我们可以将其包装在

00:36:44.470 --> 00:36:49.780
某种可观察性

00:36:46.059 --> 00:36:51.670
我们的两个DB C结肠测微计结肠池

00:36:49.780 --> 00:36:53.940
冒号Postgres，现在突然之间

00:36:51.670 --> 00:36:58.450
获得一个真正可预测的可构建uri 

00:36:53.940 --> 00:37:00.309
那可以被统一解析，但是

00:36:58.450 --> 00:37:03.900
仍然允许一堆的灵活性

00:37:00.309 --> 00:37:03.900
使用它的不同实现

00:37:04.230 --> 00:37:08.829
那你今天能做什么

00:37:06.329 --> 00:37:13.089
这周早些时候我一定是

00:37:08.829 --> 00:37:16.180
星期一我们实际上发布了0.8.0 m8 

00:37:13.089 --> 00:37:19.390
有一个目标是在八月份做一个RC 

00:37:16.180 --> 00:37:21.940
也许和十月发布的

00:37:19.390 --> 00:37:24.250
打算把它带到GA，但其中之一

00:37:21.940 --> 00:37:27.730
我们试图传达的东西

00:37:24.250 --> 00:37:30.190
这是通过选择零八零我们

00:37:27.730 --> 00:37:31.900
不要认为规范做对了

00:37:30.190 --> 00:37:33.670
认为可能有地方

00:37:31.900 --> 00:37:35.200
我们错过了一些东西

00:37:33.670 --> 00:37:37.030
希望客户司机进来并说

00:37:35.200 --> 00:37:38.799
嘿，我需要其他API或数据库

00:37:37.030 --> 00:37:40.690
司机进来说这不是

00:37:38.799 --> 00:37:43.589
实际上定义得足够具体

00:37:40.690 --> 00:37:46.680
仍有改变的空间

00:37:43.589 --> 00:37:49.019
但是0-8版本就可以了

00:37:46.680 --> 00:37:51.390
向那些相同的供应商和

00:37:49.019 --> 00:37:54.390
作为客户，这是你的事

00:37:51.390 --> 00:37:56.880
实际上应该开始使用生产我

00:37:54.390 --> 00:37:59.609
不知道也许不是，但我们认为

00:37:56.880 --> 00:38:01.499
这很好，我们认为它非常扎实

00:37:59.609 --> 00:38:04.739
认为您可以在顶部运行工作负载

00:38:01.499 --> 00:38:05.789
它，但你应该期待一些改变

00:38:04.739 --> 00:38:07.440
在未来，所以如果你非常

00:38:05.789 --> 00:38:09.719
保守可能不是一个好主意

00:38:07.440 --> 00:38:12.839
开始看它，但它允许其他

00:38:09.719 --> 00:38:15.239
供应商开始在内部查看它

00:38:12.839 --> 00:38:17.430
我们已经拥有的零8 m8版本

00:38:15.239 --> 00:38:19.710
 H2的驱动程序实现

00:38:17.430 --> 00:38:21.359
测试Microsoft续集服务器Postgres 

00:38:19.710 --> 00:38:24.469
社区实际拥有的服务器

00:38:21.359 --> 00:38:27.839
为我的续集做出了贡献

00:38:24.469 --> 00:38:30.779
实现ja sync SQL这是一个

00:38:27.839 --> 00:38:33.960
我的续集驱动程序完全在

00:38:30.779 --> 00:38:35.940
 Kotlin接了那位驾驶员，让他驾驶了r2 DBC 

00:38:33.960 --> 00:38:38.309
接口并将其粘到

00:38:35.940 --> 00:38:39.109
方面真的很好，然后

00:38:38.309 --> 00:38:41.700
还有另一个从头开始

00:38:39.109 --> 00:38:43.589
称为RTD DC的实现

00:38:41.700 --> 00:38:44.969
并且每一个都有广泛的

00:38:43.589 --> 00:38:47.640
今天已经支持

00:38:44.969 --> 00:38:50.160
批量扩展类型转换，因此

00:38:47.640 --> 00:38:52.229
例如RTD bc规范定义

00:38:50.160 --> 00:38:54.539
您应该选择大约两种类型

00:38:52.229 --> 00:38:57.180
始终能够从和转换为

00:38:54.539 --> 00:38:59.969
然后允许每个实现

00:38:57.180 --> 00:39:02.460
如果他们愿意，可以继续

00:38:59.969 --> 00:39:03.900
有完整的Blob和CLOB支持，您

00:39:02.460 --> 00:39:06.119
可以考虑一下，哇，这是一个

00:39:03.900 --> 00:39:08.339
真的是非常好的用例

00:39:06.119 --> 00:39:10.319
反应性编程这个想法，我

00:39:08.339 --> 00:39:12.269
可以请求请求一个千兆字节的数据

00:39:10.319 --> 00:39:14.369
从我的数据库中，它只会流

00:39:12.269 --> 00:39:17.579
以我可以消费的速度

00:39:14.369 --> 00:39:19.769
有保存点交易数据库

00:39:17.579 --> 00:39:21.539
特定功能，因此Postgres用于

00:39:19.769 --> 00:39:23.849
例子中有一个pub sub的东西

00:39:21.539 --> 00:39:25.710
我们可以实现他们的服务加载器

00:39:23.849 --> 00:39:29.460
所有这些的驱动程序发现和

00:39:25.710 --> 00:39:31.559
支持我们的连接URL，但它

00:39:29.460 --> 00:39:33.839
甚至超越了那个权利

00:39:31.559 --> 00:39:35.640
足以让您知道

00:39:33.839 --> 00:39:38.700
我们已经完成了一些驱动程序实现

00:39:35.640 --> 00:39:41.130
有一个非常强大的，肯定会

00:39:38.700 --> 00:39:42.210
最好不要对我的工作做一个

00:39:41.130 --> 00:39:43.680
团队其他成员中的

00:39:42.210 --> 00:39:46.499
真的很勤奋

00:39:43.680 --> 00:39:48.150
定义一个真正的规范文本

00:39:46.499 --> 00:39:49.140
找到所有规则的事情，如果

00:39:48.150 --> 00:39:51.119
想出去做一个

00:39:49.140 --> 00:39:53.779
实现你知道你是什么

00:39:51.119 --> 00:39:56.910
瞄准我们有连接池，所以

00:39:53.779 --> 00:39:58.500
在反应性非步行异步中池化

00:39:56.910 --> 00:40:00.300
令人难以置信的环境

00:39:58.500 --> 00:40:02.010
困难但项目反应堆小组

00:40:00.300 --> 00:40:03.450
几个月来一直在努力

00:40:02.010 --> 00:40:04.950
和几个月又几个月，他们真的

00:40:03.450 --> 00:40:07.170
破解它，我们已经有了这个

00:40:04.950 --> 00:40:09.300
任何人都可以使用的通用对象池

00:40:07.170 --> 00:40:10.650
但最重要的是我可以用于

00:40:09.300 --> 00:40:12.840
连接池，因为它确实

00:40:10.650 --> 00:40:14.430
在我们拥有的数据库中非常重要

00:40:12.840 --> 00:40:17.010
两种现成的实现

00:40:14.430 --> 00:40:19.200
已经弹出数据r2 DBC和r2 DBC 

00:40:17.010 --> 00:40:21.390
客户，正如我之前提到的

00:40:19.200 --> 00:40:23.670
早上真的很重要

00:40:21.390 --> 00:40:25.590
工具供应商和Java生态系统

00:40:23.670 --> 00:40:27.000
可观察性是一个真正的

00:40:25.590 --> 00:40:29.460
一流的概念

00:40:27.000 --> 00:40:30.870
我们总是会考虑

00:40:29.460 --> 00:40:32.370
那么你就知道开始和

00:40:30.870 --> 00:40:34.320
我们真正工作过的APM供应商

00:40:32.370 --> 00:40:35.910
与数据狗团队紧密合作

00:40:34.320 --> 00:40:37.170
具体来说，他们会来看你

00:40:35.910 --> 00:40:39.720
在这里知道我们只是那种事情

00:40:37.170 --> 00:40:42.030
在JDBC中无法做到

00:40:39.720 --> 00:40:43.560
最奇妙的巧合

00:40:42.030 --> 00:40:45.720
我曾经在开源方面经历过

00:40:43.560 --> 00:40:47.070
项目，我们随机收到一封电子邮件

00:40:45.720 --> 00:40:48.930
关于一个男人的邮件列表哦

00:40:47.070 --> 00:40:52.050
是的，我写了这整本书，你知道

00:40:48.930 --> 00:40:54.600
我自己的组织中的私人项目

00:40:52.050 --> 00:40:57.270
这是完整的完整代理机制

00:40:54.600 --> 00:40:58.860
 RTD bc规范的100％可观察性

00:40:57.270 --> 00:41:00.570
您对此有何看法，我们

00:40:58.860 --> 00:41:02.310
马上说我们怎么想

00:41:00.570 --> 00:41:04.140
你喜欢被提升为第一个你

00:41:02.310 --> 00:41:06.330
了解我们内部的顶级项目

00:41:04.140 --> 00:41:09.030
 DBC是官方的一部分

00:41:06.330 --> 00:41:10.650
绝对，所以今天就是现在

00:41:09.030 --> 00:41:13.050
某种核心团队成员负责

00:41:10.650 --> 00:41:17.760
围绕RTD的所有可观察性

00:41:13.050 --> 00:41:21.000
卑诗省的预言，但您可能知道我们会

00:41:17.760 --> 00:41:23.730
在这里结束一点点为什么

00:41:21.000 --> 00:41:25.410
我们在做RTD BC吗

00:41:23.730 --> 00:41:27.000
我们可能想做的替代方案

00:41:25.410 --> 00:41:29.430
对，所以第一个包裹一个

00:41:27.000 --> 00:41:31.800
我提到的线程池中的jdbc 

00:41:29.430 --> 00:41:34.320
这一点JDBC是一个阻塞的API 

00:41:31.800 --> 00:41:36.960
从根本上讲不可能

00:41:34.320 --> 00:41:38.040
将API阻塞为非阻塞API 

00:41:36.960 --> 00:41:39.960
可以做相反的事情，你可以转

00:41:38.040 --> 00:41:42.210
非阻塞变为阻塞，但

00:41:39.960 --> 00:41:43.830
一旦您阻止了

00:41:42.210 --> 00:41:46.290
从非阻塞中打破它

00:41:43.830 --> 00:41:48.180
流程是添加队列，好吧，我们排队

00:41:46.290 --> 00:41:50.070
所有人都知道如何做队列，我们​​有两个

00:41:48.180 --> 00:41:52.680
各种队列无界队列

00:41:50.070 --> 00:41:54.420
排队无限制的队列想象我们

00:41:52.680 --> 00:41:58.170
在较早的时候说话

00:41:54.420 --> 00:41:59.880
反应性反应性主题演讲

00:41:58.170 --> 00:42:01.500
像网络流量这样的事情现在突然之间

00:41:59.880 --> 00:42:02.880
而不是处理数百个

00:42:01.500 --> 00:42:04.950
连接或数千

00:42:02.880 --> 00:42:06.150
现在我们正在处理数十个

00:42:04.950 --> 00:42:08.970
数千个同时连接

00:42:06.150 --> 00:42:10.560
所有这些都可能坐在队列中

00:42:08.970 --> 00:42:12.300
等待访问J 

00:42:10.560 --> 00:42:24.210
英国广播公司写有限数量的资源

00:42:12.300 --> 00:42:26.190
当这种情况发生时， 

00:42:24.210 --> 00:42:27.630
高负载情况下，我们可能想

00:42:26.190 --> 00:42:29.910
看看有界队列

00:42:27.630 --> 00:42:31.740
有限的队列导致尽快阻塞

00:42:29.910 --> 00:42:35.250
当您填充此队列时，您不会

00:42:31.740 --> 00:42:37.140
像你一样超越你的堆爆炸

00:42:35.250 --> 00:42:39.120
有一个障碍，但因为你只有

00:42:37.140 --> 00:42:41.430
四个线程或一个很小的线程

00:42:39.120 --> 00:42:42.900
接下来的四个请求的线程数

00:42:41.430 --> 00:42:44.970
这一切都在等待

00:42:42.900 --> 00:42:46.740
队列基本上关闭了整个

00:42:44.970 --> 00:42:48.570
系统没有吞吐量

00:42:46.740 --> 00:42:51.630
您想要的，所以我们遇到了问题

00:42:48.570 --> 00:42:53.640
所以包装JDBC并不是一个真正的

00:42:51.630 --> 00:42:55.320
我们的选择，我们必须

00:42:53.640 --> 00:42:58.230
从头开始设计的东西

00:42:55.320 --> 00:43:00.510
同步性和说实话

00:42:58.230 --> 00:43:03.090
尝试的其他规格

00:43:00.510 --> 00:43:04.830
现实中这种事情

00:43:03.090 --> 00:43:07.290
他们都处于非常早期的阶段

00:43:04.830 --> 00:43:09.630
它们的设计都非常相似

00:43:07.290 --> 00:43:11.430
我们的二维BC是什么，我们知道

00:43:09.630 --> 00:43:14.280
在他们身上先行一步

00:43:11.430 --> 00:43:15.960
一年或类似的东西，但每一年

00:43:14.280 --> 00:43:17.820
这些通常有少量的

00:43:15.960 --> 00:43:23.220
实施方式通常为

00:43:17.820 --> 00:43:26.130
 0或1，但我认为我们非常清楚

00:43:23.220 --> 00:43:28.470
 AR JDBC团队认为所有人的未来

00:43:26.130 --> 00:43:29.670
这些项目是合作

00:43:28.470 --> 00:43:32.070
市场不会让你知道

00:43:29.670 --> 00:43:34.320
因此有多个竞争标准

00:43:32.070 --> 00:43:36.150
实际上，我们将不得不

00:43:34.320 --> 00:43:38.340
与所有这些东西协作到一个

00:43:36.150 --> 00:43:42.150
单一标准，最终将

00:43:38.340 --> 00:43:43.500
为此来到Java生态系统

00:43:42.150 --> 00:43:44.880
是我的安全港声明，其中有一个

00:43:43.500 --> 00:43:46.800
很多话说我要

00:43:44.880 --> 00:43:49.320
告诉你可能是一个完全的谎言

00:43:46.800 --> 00:43:50.220
时间发生了，所以我们想做什么

00:43:49.320 --> 00:43:53.670
在将来

00:43:50.220 --> 00:43:56.070
所以让我们进入rc1的关键是

00:43:53.670 --> 00:43:57.990
想要多做一些补充

00:43:56.070 --> 00:44:00.600
我们知道的SPI的改进

00:43:57.990 --> 00:44:03.420
需要做的我不敢相信

00:44:00.600 --> 00:44:05.610
当我第一颗子弹在这里

00:44:03.420 --> 00:44:07.230
设计我故意避免的API 

00:44:05.610 --> 00:44:08.610
像没有人使用存储过程一样的存储过程

00:44:07.230 --> 00:44:10.470
谁使用存储的程序了

00:44:08.610 --> 00:44:12.240
程序证明我完全

00:44:10.470 --> 00:44:14.220
错了，有很多存储

00:44:12.240 --> 00:44:15.810
程序遍布世界各地

00:44:14.220 --> 00:44:17.730
所有的客户供应商都非常清楚

00:44:15.810 --> 00:44:19.200
你必须绝对有支持

00:44:17.730 --> 00:44:21.000
对于存储过程，所以我们需要

00:44:19.200 --> 00:44:23.040
我们要做的就是谈论

00:44:21.000 --> 00:44:23.880
自动提交并再次获取大小

00:44:23.040 --> 00:44:25.770
这就像

00:44:23.880 --> 00:44:27.990
伟大的协同作用是伟大的

00:44:25.770 --> 00:44:30.330
关于在开源中工作的事情

00:44:27.990 --> 00:44:33.210
与所有其他这些项目

00:44:30.330 --> 00:44:34.890
由卢卡斯（Lucas）编辑领导的子弹

00:44:33.210 --> 00:44:36.780
 Juke项目来找我们说

00:44:34.890 --> 00:44:38.580
我要知道我现在是否在

00:44:36.780 --> 00:44:44.220
自动提交模式，我需要能够

00:44:38.580 --> 00:44:45.870
设置获取大小，因为反应堆有

00:44:44.220 --> 00:44:47.490
关于何时回到

00:44:45.870 --> 00:44:48.780
数据库，说下次寄给我

00:44:47.490 --> 00:44:50.130
行发送给我下一百个

00:44:48.780 --> 00:44:52.230
第二十八排给我下一转

00:44:50.130 --> 00:44:54.870
或五十六行有点想法

00:44:52.230 --> 00:44:57.450
它是动态调整的

00:44:54.870 --> 00:44:59.790
它可以去问，但你可以做

00:44:57.450 --> 00:45:01.560
如果您是数据库用户并且您会更好

00:44:59.790 --> 00:45:03.930
知道会有多少数据

00:45:01.560 --> 00:45:06.930
发送来的你可以要求一个固定的号码

00:45:03.930 --> 00:45:09.120
更匹配的行数

00:45:06.930 --> 00:45:11.010
希望看到更多Google实现

00:45:09.120 --> 00:45:12.300
云扳手实际上有一个公共仓库

00:45:11.010 --> 00:45:15.510
现在他们开始的地方

00:45:12.300 --> 00:45:16.770
 Hana和db2都在db2 sap上工作

00:45:15.510 --> 00:45:18.780
有点看它

00:45:16.770 --> 00:45:21.810
我们尝试进行调查时对其进行调查

00:45:18.780 --> 00:45:24.270
具有它的数据库组，以及

00:45:21.810 --> 00:45:26.520
我认为我们真正想要的是我们真正的

00:45:24.270 --> 00:45:29.850
想要强调即使

00:45:26.520 --> 00:45:31.710
前三个数据库驱动程序都是我们

00:45:29.850 --> 00:45:34.860
在RTD内部实现

00:45:31.710 --> 00:45:36.960
 Spring BC团队和关键员工

00:45:34.860 --> 00:45:39.090
是我们实际上更喜欢数据库

00:45:36.960 --> 00:45:42.360
供应商要长期拥有司机

00:45:39.090 --> 00:45:44.610
是Postgres中的不幸专家

00:45:42.360 --> 00:45:46.800
有线协议，但我几乎不知道

00:45:44.610 --> 00:45:49.170
和Postgres团队实际所做的一样

00:45:46.800 --> 00:45:52.140
因此，我们已经与

00:45:49.170 --> 00:45:54.150
示例JDBC驱动程序的负责人

00:45:52.140 --> 00:45:56.790
给Postgres，他就是你每天都知道

00:45:54.150 --> 00:45:58.710
在那里承诺回答问题

00:45:56.790 --> 00:46:00.540
对我们而言，如果我们

00:45:58.710 --> 00:46:02.580
如果这实际上变成一个

00:46:00.540 --> 00:46:04.020
他们会接管的

00:46:02.580 --> 00:46:06.360
从我们手中出来，我认为这是真的

00:46:04.020 --> 00:46:08.820
真的是一件好事，最后我们

00:46:06.360 --> 00:46:11.280
也想要很多其他客户

00:46:08.820 --> 00:46:13.170
赶上TBI mybatis都有某种

00:46:11.280 --> 00:46:14.850
我正在寻找其他支持

00:46:13.170 --> 00:46:17.370
在这一点上，你知道的

00:46:14.850 --> 00:46:21.090
长期目标使我们达到0-8 

00:46:17.370 --> 00:46:22.290
发布并最终发布100次，因此

00:46:21.090 --> 00:46:24.540
最后一张幻灯片，我要离开你

00:46:22.290 --> 00:46:27.390
这里有一些资源

00:46:24.540 --> 00:46:30.570
 R 2 DB cio网站我们有一个推特

00:46:27.390 --> 00:46:32.550
我们有一个可爱的小图标给我们

00:46:30.570 --> 00:46:34.830
 github一切显然都是公开的

00:46:32.550 --> 00:46:36.960
有一个邮件列表，很幸运

00:46:34.830 --> 00:46:38.970
我们每个星期五都有一个电话

00:46:36.960 --> 00:46:41.309
我住在太平洋时区， 

00:46:38.970 --> 00:46:43.319
每天早上或每天6:30致电

00:46:41.309 --> 00:46:44.760
星期五早上大家

00:46:43.319 --> 00:46:47.460
幸运的是不必做可以做的事情

00:46:44.760 --> 00:46:51.480
您的文明程度是3:30 

00:46:47.460 --> 00:46:53.280
下午吧，所以我鼓励你

00:46:51.480 --> 00:46:54.390
这是你感兴趣的东西

00:46:53.280 --> 00:46:56.760
即使您只是一个应用程序

00:46:54.390 --> 00:46:58.319
开发一个只是你知道的人

00:46:56.760 --> 00:46:59.579
想要关注事物

00:46:58.319 --> 00:47:01.800
即使你一无所知

00:46:59.579 --> 00:47:03.390
最多编写数据库驱动程序

00:47:01.800 --> 00:47:05.760
这个特殊的重要要点

00:47:03.390 --> 00:47:07.829
我一生的努力

00:47:05.760 --> 00:47:10.349
假定的数据库驱动程序实施者

00:47:07.829 --> 00:47:11.880
就在编译器实现者旁边

00:47:10.349 --> 00:47:13.890
作为所有人中最聪明的人

00:47:11.880 --> 00:47:16.079
计算机科学，我完全错了

00:47:13.890 --> 00:47:17.579
关于任何人都可以做到这一点，如果你

00:47:16.079 --> 00:47:19.290
你能知道有点读吗

00:47:17.579 --> 00:47:21.510
文档并了解字节数

00:47:19.290 --> 00:47:23.490
可以通过电线订购

00:47:21.510 --> 00:47:25.920
自己实施这些驱动程序之一

00:47:23.490 --> 00:47:28.650
所以我绝对想拥有你

00:47:25.920 --> 00:47:30.660
在我们getter的邮件列表中

00:47:28.650 --> 00:47:32.250
即使您只是潜伏，每周通话

00:47:30.660 --> 00:47:34.200
但几乎每个人都有

00:47:32.250 --> 00:47:37.710
做出贡献，所以我们很乐意拥有你

00:47:34.200 --> 00:47:39.270
好的，谢谢大家

00:47:37.710 --> 00:47:40.990
今天下午听我说

00:47:39.270 --> 00:47:44.050
会议的其余部分

00:47:40.990 --> 00:47:50.820
 [掌声] 

00:47:44.050 --> 00:47:50.820
 [音乐] 

