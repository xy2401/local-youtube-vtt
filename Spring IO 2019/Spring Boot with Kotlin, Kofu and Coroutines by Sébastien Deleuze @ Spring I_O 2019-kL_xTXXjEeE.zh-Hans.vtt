WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.900 --> 00:00:10.120
 [音乐] 

00:00:06.629 --> 00:00:12.670
今天谢谢你，我们要谈

00:00:10.120 --> 00:00:15.340
关于构建spring应用程序，但是

00:00:12.670 --> 00:00:18.039
与往常不同的方式

00:00:15.340 --> 00:00:20.169
当然使用切瘦为

00:00:18.039 --> 00:00:22.390
语言，我们将配置您的

00:00:20.169 --> 00:00:24.999
 spring boot 以显式方式

00:00:22.390 --> 00:00:26.739
胡夫，我们将利用我们的

00:00:24.999 --> 00:00:32.290
是的反应性基础设施

00:00:26.739 --> 00:00:34.030
协程，所以在开始之前值得

00:00:32.290 --> 00:00:36.100
在这里保留我们的目标

00:00:34.030 --> 00:00:39.520
我认为首要目标是改善

00:00:36.100 --> 00:00:41.590
降低信噪比

00:00:39.520 --> 00:00:44.500
具有更多可发现的功能

00:00:41.590 --> 00:00:47.250
反应容易，我坚信

00:00:44.500 --> 00:00:50.170
显性行为等于少

00:00:47.250 --> 00:00:53.710
误解大概是运行时

00:00:50.170 --> 00:00:57.100
效率将是这里的目标，所以让我们

00:00:53.710 --> 00:00:59.230
让我们开始，我们将遵循

00:00:57.100 --> 00:01:01.270
从典型的四个步骤

00:00:59.230 --> 00:01:04.869
 Spring Boot应用程序开发于

00:01:01.270 --> 00:01:07.810
 Java将惯用代码合二为一

00:01:04.869 --> 00:01:09.520
想确保您了解

00:01:07.810 --> 00:01:12.460
您不必触及

00:01:09.520 --> 00:01:14.680
为了拥有伟大的东西

00:01:12.460 --> 00:01:16.870
我的意思是如果您只想使用spring 

00:01:14.680 --> 00:01:19.090
就像在Java中使用它一样启动

00:01:16.870 --> 00:01:20.620
结合成一种语言

00:01:19.090 --> 00:01:24.010
相同的安排是

00:01:20.620 --> 00:01:26.500
如果您想做的话就完美了

00:01:24.010 --> 00:01:28.360
紧跟并利用反应

00:01:26.500 --> 00:01:30.000
堆栈，或者切换到协同例程

00:01:28.360 --> 00:01:32.560
真的很好

00:01:30.000 --> 00:01:35.500
你想我就可以停下来

00:01:32.560 --> 00:01:37.210
向您展示逐步开始的方法

00:01:35.500 --> 00:01:39.430
从我们目前在Java中获得的

00:01:37.210 --> 00:01:41.530
我认为更多的世界

00:01:39.430 --> 00:01:43.180
惯用编码，我认为有

00:01:41.530 --> 00:01:47.770
一些很好的理由，但是

00:01:43.180 --> 00:01:50.320
真的，您随心所欲，所以

00:01:47.770 --> 00:01:53.760
第一步将是从Java切换到

00:01:50.320 --> 00:01:57.040
切入，为此，我们将

00:01:53.760 --> 00:01:59.140
使用简化版的

00:01:57.040 --> 00:02:01.630
该官员背后的应用程序

00:01:59.140 --> 00:02:06.189
在教程中的spring boot cut是

00:02:01.630 --> 00:02:08.439
用 spring boot GPA制成，并切薄

00:02:06.189 --> 00:02:13.270
我们要去看起来像这样

00:02:08.439 --> 00:02:16.780
这种应用程序，让我们切换

00:02:13.270 --> 00:02:18.940
在代码中好吧，所以我已经

00:02:16.780 --> 00:02:20.770
提出了一部分

00:02:18.940 --> 00:02:23.560
主题演讲，所以我会很快

00:02:20.770 --> 00:02:26.530
步骤，但这是一个逐步构建文件

00:02:23.560 --> 00:02:29.410
通过状态小翼IO生成

00:02:26.530 --> 00:02:32.670
而插入式DSL提供了

00:02:29.410 --> 00:02:35.170
更好地完成功能和

00:02:32.670 --> 00:02:37.540
那可能是有趣的一点

00:02:35.170 --> 00:02:40.300
有点缺点，目前有点

00:02:37.540 --> 00:02:42.070
自动完成速度很慢，但我

00:02:40.300 --> 00:02:44.590
知道即将来临

00:02:42.070 --> 00:02:47.530
改善，因此您可以期望有

00:02:44.590 --> 00:02:51.330
非常顺利的开发经验

00:02:47.530 --> 00:02:51.330
接下来的几个月，并以此为基础

00:02:51.780 --> 00:02:56.590
戏剧课有点

00:02:54.730 --> 00:02:58.570
与我介绍的内容不同

00:02:56.590 --> 00:03:02.260
主题演讲，因为我们在这里

00:02:58.570 --> 00:03:04.630
利用GPA，因此未设计GPA 

00:03:02.260 --> 00:03:07.180
对于不可变的数据结构，所以这里

00:03:04.630 --> 00:03:09.580
即使为不可变的数据而努力

00:03:07.180 --> 00:03:12.510
我正在使用属性的结构

00:03:09.580 --> 00:03:15.960
因为真正的GPA是为此而设计的

00:03:12.510 --> 00:03:20.320
我们有常规的身份注释

00:03:15.960 --> 00:03:24.060
相同类型的可选参数

00:03:20.320 --> 00:03:24.060
我之前提供的默认值

00:03:25.260 --> 00:03:31.210
所以我的控制器是一个通知

00:03:29.200 --> 00:03:33.490
在Java中编码更多

00:03:31.210 --> 00:03:37.480
促进构造函数库的使用

00:03:33.490 --> 00:03:38.800
当我从15.3开始时

00:03:37.480 --> 00:03:42.040
你只有一个构造函数

00:03:38.800 --> 00:03:44.350
根据类型和此处隐式自动连线

00:03:42.040 --> 00:03:46.630
因为我们有这个单一的构造函数

00:03:44.350 --> 00:03:49.960
文章存储库将自动

00:03:46.630 --> 00:03:53.230
注射，由于晶须干净，我们使用

00:03:49.960 --> 00:03:55.120
很多不变的属性，这是一个很好的

00:03:53.230 --> 00:03:57.220
要注意的想法是您必须

00:03:55.120 --> 00:03:59.500
添加此私人关键字，因为

00:03:57.220 --> 00:04:03.100
默认属性是public 

00:03:59.500 --> 00:04:05.680
不是我们想要的类型

00:04:03.100 --> 00:04:07.600
系统我重复一遍，但是它非常

00:04:05.680 --> 00:04:09.550
重要的是要了解凯瑟琳是

00:04:07.600 --> 00:04:12.010
静态类型更像Java 

00:04:09.550 --> 00:04:14.550
多亏了这里的新安全性

00:04:12.010 --> 00:04:18.070
配置IntelliJ IDEA以显示int 

00:04:14.550 --> 00:04:20.230
 2种第三类型的显示器，我也可以

00:04:18.070 --> 00:04:23.260
明确键入它是我的选择，但

00:04:20.230 --> 00:04:25.479
在这里我只想看看辛西娅式

00:04:23.260 --> 00:04:27.620
无需重复此操作

00:04:25.479 --> 00:04:30.240
信息

00:04:27.620 --> 00:04:32.910
仓库是常规仓库

00:04:30.240 --> 00:04:35.490
 Springwood应用程序正在使用此

00:04:32.910 --> 00:04:37.590
真正的申请，所以租金申请是

00:04:35.490 --> 00:04:40.050
 a是顶层函数，因为

00:04:37.590 --> 00:04:42.900
加泰罗尼亚语，您不必放置任何功能

00:04:40.050 --> 00:04:45.870
在一个班级里提供

00:04:42.900 --> 00:04:49.319
内置 spring boot ，您可以

00:04:45.870 --> 00:04:52.889
通过使用这种类型基本上使用它

00:04:49.319 --> 00:04:54.810
自定义您的语法的 Spring 很好

00:04:52.889 --> 00:04:57.030
应用程序，而不仅仅是更多

00:04:54.810 --> 00:05:02.880
语法糖，它也提供了一些

00:04:57.030 --> 00:05:04.909
血液配置能力

00:05:02.880 --> 00:05:07.319
房地产经纪人很有趣，因为

00:05:04.909 --> 00:05:09.599
这是一项新功能或 spring boot 

00:05:07.319 --> 00:05:13.380
 Spring 之前的两个引导到两个

00:05:09.599 --> 00:05:15.240
使用懒惰的初始元音

00:05:13.380 --> 00:05:17.520
在加泰罗尼亚语中非常戏剧化，因为

00:05:15.240 --> 00:05:20.190
基本上在

00:05:17.520 --> 00:05:23.009
引导我们不是一成不变的

00:05:20.190 --> 00:05:24.780
类，因为它不是超级流行

00:05:23.009 --> 00:05:27.180
在Java中，因为还有一点

00:05:24.780 --> 00:05:30.150
冗长而后代

00:05:27.180 --> 00:05:34.259
本地管理的两个Spring Boot 

00:05:30.150 --> 00:05:37.759
不可变的类，所以我们可以使用它

00:05:34.259 --> 00:05:40.620
 Val的惯用数据类

00:05:37.759 --> 00:05:42.000
不变的属性，这是非常

00:05:40.620 --> 00:05:45.509
好消息，所以谢谢你的 spring boot 

00:05:42.000 --> 00:05:48.750
在该扩展上行走的团队

00:05:45.509 --> 00:05:51.060
功能允许向您好添加功能

00:05:48.750 --> 00:05:55.849
将功能添加到现有类型，以便我们使用

00:05:51.060 --> 00:05:59.969
提供更多有趣的

00:05:55.849 --> 00:06:03.599
语法比常规抽象类

00:05:59.969 --> 00:06:06.569
在我的HTML中使用静态方法

00:06:03.599 --> 00:06:08.490
控制器，您可以看到我正在使用

00:06:06.569 --> 00:06:10.620
我在用的那种东西

00:06:08.490 --> 00:06:14.400
 Java，但语法更简洁

00:06:10.620 --> 00:06:17.400
我们利用一些代码

00:06:14.400 --> 00:06:20.909
扩展，例如，您看到此

00:06:17.400 --> 00:06:23.969
是模特，所以这是一个非常古老的课程

00:06:20.909 --> 00:06:28.380
从Spring Framework，如果我尝试

00:06:23.969 --> 00:06:30.449
导航到这里，您将看到我有

00:06:28.380 --> 00:06:32.580
添加了扩展功能

00:06:30.449 --> 00:06:36.270
直接在Spring 中提供模块

00:06:32.580 --> 00:06:38.699
提供一个集合运算符

00:06:36.270 --> 00:06:40.610
基本上是模型点添加的别名

00:06:38.699 --> 00:06:42.560
属性，让我

00:06:40.610 --> 00:06:44.449
使用这种非常好的语法

00:06:42.560 --> 00:06:46.879
要进行几何编码设置

00:06:44.449 --> 00:06:50.990
价值，所以我们真的提供了

00:06:46.879 --> 00:06:57.259
直接在网站上为Kirkland提供支持

00:06:50.990 --> 00:06:59.210
 Spring 形式的罐子，所以我们要

00:06:57.259 --> 00:07:01.759
转到第二步，我们要

00:06:59.210 --> 00:07:04.969
从网络迁移出来，我们发现GPA可以

00:07:01.759 --> 00:07:07.789
使用ODBC的web flex以利用我们的

00:07:04.969 --> 00:07:13.210
反应堆最有能力成为

00:07:07.789 --> 00:07:16.400
基本上不受延迟的影响

00:07:13.210 --> 00:07:18.979
所以实际上BC是反应式SQL SPI 

00:07:16.400 --> 00:07:22.759
旨在由

00:07:18.979 --> 00:07:25.580
仅依赖的降级驱动程序

00:07:22.759 --> 00:07:28.370
反应性流，它本身就是反应性的

00:07:25.580 --> 00:07:31.460
也没有线程池，我们有驱动程序

00:07:28.370 --> 00:07:36.349
对于PostgreSQL我的续集h2和

00:07:31.460 --> 00:07:38.180
 Spring World上的Microsoft SQL Server 

00:07:36.349 --> 00:07:40.610
通常会消耗我们Spring 数据

00:07:38.180 --> 00:07:42.979
 DBC在概念上很漂亮

00:07:40.610 --> 00:07:45.589
接近JDBC的 Spring ，所以它不是

00:07:42.979 --> 00:07:47.930
一个成熟的地方，不是GPA 

00:07:45.589 --> 00:07:49.610
直接编写可以

00:07:47.930 --> 00:07:52.909
利用您的本机功能

00:07:49.610 --> 00:07:55.339
数据库并向DBC鼓吹

00:07:52.909 --> 00:07:58.550
提供了一些非常有趣的功能

00:07:55.339 --> 00:08:02.089
做对象映射，所以参数

00:07:58.550 --> 00:08:06.560
竞标等，然后向DBC提出

00:08:02.089 --> 00:08:08.750
附带两个AP是常规查询模型

00:08:06.560 --> 00:08:10.729
您通常在 spring data 中发现的

00:08:08.750 --> 00:08:12.409
它还提供了数据库Kalyan 

00:08:10.729 --> 00:08:15.169
在概念上是功能性API 

00:08:12.409 --> 00:08:17.569
接近我们在网络客户端上拥有的

00:08:15.169 --> 00:08:20.419
我们要使用的这种流畅的API 

00:08:17.569 --> 00:08:25.270
反应类型也注意到它仍然

00:08:20.419 --> 00:08:28.849
工作正在进行中，但进展很快

00:08:25.270 --> 00:08:34.729
所以我们回到了IntelliJ IDEA 

00:08:28.849 --> 00:08:38.560
要切换分支，所以我要

00:08:34.729 --> 00:08:38.560
切换到第二步

00:08:41.969 --> 00:08:48.130
好吧，让我们来看看

00:08:44.980 --> 00:08:50.050
改变了，我们现在有val属性

00:08:48.130 --> 00:08:54.190
因为我们没有约束

00:08:50.050 --> 00:08:56.740
 GPA暗示我们将要

00:08:54.190 --> 00:08:58.810
用空气吹向DBCSpring 

00:08:56.740 --> 00:09:01.470
作为一流的支持

00:08:58.810 --> 00:09:04.810
不变的数据结构，因此我们遵循

00:09:01.470 --> 00:09:09.850
 Kirtland为我们设计的推动力是

00:09:04.810 --> 00:09:12.160
使用不可变的数据类，那么如果我

00:09:09.850 --> 00:09:14.860
看一下您看到的存储库

00:09:12.160 --> 00:09:16.990
我正在注入数据库帐户

00:09:14.860 --> 00:09:20.589
是功能性API的API 

00:09:16.990 --> 00:09:24.700
 JDBC提供的那个 Spring ，我

00:09:20.589 --> 00:09:27.670
使用这种流利的API编写代码

00:09:24.700 --> 00:09:31.120
 Manu和flex那是

00:09:27.670 --> 00:09:34.029
现在说我们想服用

00:09:31.120 --> 00:09:35.740
我们的反应堆的优势

00:09:34.029 --> 00:09:38.589
我们想请求一个远程网站

00:09:35.740 --> 00:09:42.070
服务，因此本演示的目的

00:09:38.589 --> 00:09:50.500
我将直接在这里创建它

00:09:42.070 --> 00:09:52.630
要添加一个命令类，所以这里是

00:09:50.500 --> 00:09:54.699
我们建议是要我们有这篇文章

00:09:52.630 --> 00:09:56.560
博客文章中的课程，我们希望

00:09:54.699 --> 00:09:58.990
向远程请求命令

00:09:56.560 --> 00:10:02.649
网络服务，我们将添加

00:09:58.990 --> 00:10:06.779
他们在文章中，所以我们有这个

00:10:02.649 --> 00:10:06.779
命令类，我们将创建一个

00:10:07.620 --> 00:10:11.250
命令控制器

00:10:14.850 --> 00:10:21.550
所以我们有这个反应式的命令

00:10:18.460 --> 00:10:26.170
像我们这样的控制器

00:10:21.550 --> 00:10:28.600
导入，因此扩展名需要

00:10:26.170 --> 00:10:31.990
进口很重要，所以我们

00:10:28.600 --> 00:10:36.490
基本上建立我们要去的标志

00:10:31.990 --> 00:10:41.760
修改我们的HTML控制器以添加

00:10:36.490 --> 00:10:46.810
网络客户端，所以我要注入一个

00:10:41.760 --> 00:10:49.720
具有Web客户端的客户端构建器

00:10:46.810 --> 00:10:53.980
建立您要使用的类型

00:10:49.720 --> 00:10:58.830
这个建造者来创建一个像

00:10:53.980 --> 00:11:05.710
我要添加评论

00:10:58.830 --> 00:11:08.830
此处的属性，以便列出命令和

00:11:05.710 --> 00:11:12.610
我将修改此渲染功能

00:11:08.830 --> 00:11:16.510
目前正在同步它

00:11:12.610 --> 00:11:26.650
什么也不做准备去远程，我要去

00:11:16.510 --> 00:11:28.930
我正在请求我的网络服务

00:11:26.650 --> 00:11:30.670
在这里我直接在这里实现

00:11:28.930 --> 00:11:33.310
但假设您正在要求

00:11:30.670 --> 00:11:36.550
远程Web服务，您知道您看到了

00:11:33.310 --> 00:11:38.050
现在我要重新排列网络客户端

00:11:36.550 --> 00:11:40.330
请求或远程Web服务以及

00:11:38.050 --> 00:11:43.900
在这里添加此命令，现在我们有了

00:11:40.330 --> 00:11:46.030
自从我们开始

00:11:43.900 --> 00:11:50.560
有个马诺我要去改变它

00:11:46.030 --> 00:11:54.100
从地图到平面地图都可以翻转

00:11:50.560 --> 00:11:56.230
结果，我将对此进行修改

00:11:54.100 --> 00:11:59.680
代码的一部分作为平面图

00:11:56.230 --> 00:12:01.750
好吧，我要称呼随机

00:11:59.680 --> 00:12:06.550
方法，然后它将是平面图

00:12:01.750 --> 00:12:08.950
在这里，我像那样修改

00:12:06.550 --> 00:12:11.260
请注意，当您在凯瑟琳（Kathleen） 

00:12:08.950 --> 00:12:14.200
只有一个参数的lambda 

00:12:11.260 --> 00:12:18.280
默认情况下，您可以使用它来引用它

00:12:14.200 --> 00:12:21.460
没有明确定义定义它，所以

00:12:18.280 --> 00:12:25.000
最后一部分，我要添加修改我的

00:12:21.460 --> 00:12:27.460
胡子模板可以显示

00:12:25.000 --> 00:12:28.680
命令，如果我运行

00:12:27.460 --> 00:12:33.820
应用

00:12:28.680 --> 00:12:37.650
如果我没有记错，那么博客文章是

00:12:33.820 --> 00:12:37.650
真的很丑，因为我不是设计师

00:12:37.680 --> 00:12:47.530
如果我去当地的房东好

00:12:45.130 --> 00:12:54.790
我有即将发表的评论

00:12:47.530 --> 00:13:02.320
从远程Web服务访问，这样就可以了

00:12:54.790 --> 00:13:06.970
第二步，现在第三步，所以我们是

00:13:02.320 --> 00:13:10.480
要从这个反应性X移民

00:13:06.970 --> 00:13:13.450
样式API，所以当我说反应式X时

00:13:10.480 --> 00:13:14.110
 Eric Java反应器这种API 

00:13:13.450 --> 00:13:16.390
协程

00:13:14.110 --> 00:13:18.670
因为我们要利用

00:13:16.390 --> 00:13:20.830
编码功能使其能够保持

00:13:18.670 --> 00:13:24.970
利用这个很好的反应堆，但是

00:13:20.830 --> 00:13:26.920
更迫切的方式，使库鲁青少年

00:13:24.970 --> 00:13:28.390
编码轻量级线程将

00:13:26.920 --> 00:13:32.080
更多地编写和阻止代码

00:13:28.390 --> 00:13:34.450
我在这里向您展示了如何命令式

00:13:32.080 --> 00:13:37.720
反应性的，除了e我翻译为kuru 

00:13:34.450 --> 00:13:41.920
青少年基本上只为

00:13:37.720 --> 00:13:43.810
您不返回任何API，我们将寻找

00:13:41.920 --> 00:13:48.430
就像你当务之急

00:13:43.810 --> 00:13:50.890
世界，如果您通过一些单声道

00:13:48.430 --> 00:13:52.660
参数，如果您不在乎

00:13:50.890 --> 00:13:55.030
单声道的懒惰，你只会通过

00:13:52.660 --> 00:13:57.220
可以通过自身获取的值

00:13:55.030 --> 00:13:59.470
调用暂停功能，如果

00:13:57.220 --> 00:14:02.170
还是想保持这个懒惰

00:13:59.470 --> 00:14:04.780
单声道的特点，您将通过

00:14:02.170 --> 00:14:07.360
供应商将被暂停

00:14:04.780 --> 00:14:09.670
 lambda，因为suspend关键字可以

00:14:07.360 --> 00:14:11.440
也可以用在lambda中

00:14:09.670 --> 00:14:16.090
概念上非常接近我们所知道的

00:14:11.440 --> 00:14:19.180
是Eric Java中的助焊剂或风味

00:14:16.090 --> 00:14:21.010
世界将转化为流动，在这里，我们

00:14:19.180 --> 00:14:25.300
谈论的是

00:14:21.010 --> 00:14:29.680
提供了协程1.2 

00:14:25.300 --> 00:14:33.840
与Java 9流容器不同

00:14:29.680 --> 00:14:37.210
输入参考类型

00:14:33.840 --> 00:14:40.640
尝试在我们的代码中使用该混凝土

00:14:37.210 --> 00:14:44.690
让我们来谈谈这种流动类型

00:14:40.640 --> 00:14:47.860
去年削减了JetBrains团队

00:14:44.690 --> 00:14:50.029
进入决赛：1.3 

00:14:47.860 --> 00:14:52.970
例行程序是稳定的年份

00:14:50.029 --> 00:14:55.220
我认为那只是部分正确

00:14:52.970 --> 00:14:57.500
因为有两个支出功能

00:14:55.220 --> 00:15:00.500
有一些API可以处理多个

00:14:57.500 --> 00:15:03.440
值，它是通道API，但我不知道

00:15:00.500 --> 00:15:05.120
真的很喜欢，但是缺少的是

00:15:03.440 --> 00:15:07.850
这种流动类型是

00:15:05.120 --> 00:15:11.750
基本上是悬浮的组合

00:15:07.850 --> 00:15:14.750
功能和极端的反应风格

00:15:11.750 --> 00:15:17.810
 API，这是非常有趣的类型

00:15:14.750 --> 00:15:21.250
因为它适合古怪或寒冷

00:15:17.810 --> 00:15:23.839
流，所以当我说热流时，我的意思是

00:15:21.250 --> 00:15:26.300
基本上，您正在订阅列表

00:15:23.839 --> 00:15:28.600
的推文，然后您赢得关注，所以

00:15:26.300 --> 00:15:32.149
基本上是事件流

00:15:28.600 --> 00:15:36.490
在我订阅之前和之后发出

00:15:32.149 --> 00:15:39.529
对他们来说，冷流更多

00:15:36.490 --> 00:15:42.740
异步迭代，所以基本上我

00:15:39.529 --> 00:15:44.990
可能有100个元素的更正

00:15:42.740 --> 00:15:47.149
但我想开始将它们处理为

00:15:44.990 --> 00:15:50.630
他们没有把所有东西都放进来

00:15:47.149 --> 00:15:52.209
内存流适用于finit或

00:15:50.630 --> 00:15:54.529
无限数量的元素

00:15:52.209 --> 00:15:56.839
有趣的是，它可以处理背压

00:15:54.529 --> 00:15:58.940
但以一种截然不同的方式

00:15:56.839 --> 00:16:01.040
反应流它只是处理

00:15:58.940 --> 00:16:04.190
使用悬挂功能的压力

00:16:01.040 --> 00:16:07.970
基本上它将处理它们的数据并

00:16:04.190 --> 00:16:10.699
然后请求n个数据元素，但是如果

00:16:07.970 --> 00:16:12.880
你是你有你经常做处理

00:16:10.699 --> 00:16:16.250
这被暂停，只是不会

00:16:12.880 --> 00:16:19.339
请求更多数据，这就是为什么我们的

00:16:16.250 --> 00:16:20.990
背压与流量一起工作

00:16:19.339 --> 00:16:23.390
比反应式动力稍差

00:16:20.990 --> 00:16:25.660
流，但对于大多数用例我

00:16:23.390 --> 00:16:28.399
认为会没事的

00:16:25.660 --> 00:16:31.100
所有运算符都实现为

00:16:28.399 --> 00:16:35.000
在路易斯维尔扩张并让您动荡

00:16:31.100 --> 00:16:37.160
基本上有100个运营商在流动

00:16:35.000 --> 00:16:40.399
你只是一个悬浮的正确

00:16:37.160 --> 00:16:43.940
方法，然后内置所有运算符

00:16:40.399 --> 00:16:47.269
或自定义实现为扩展

00:16:43.940 --> 00:16:49.010
函数运算符非常容易

00:16:47.269 --> 00:16:50.779
实施，我认为这很漂亮

00:16:49.010 --> 00:16:53.839
我的意思是有趣的功能

00:16:50.779 --> 00:16:54.470
到流量过滤器或地图的源代码

00:16:53.839 --> 00:16:56.860
算子

00:16:54.470 --> 00:17:00.260
您只会看到几行， 

00:16:56.860 --> 00:17:03.050
少特征地图设备报告

00:17:00.260 --> 00:17:05.840
同步操作，因为

00:17:03.050 --> 00:17:07.520
 lambda是一个悬浮的lambda，因此可以削减

00:17:05.840 --> 00:17:10.160
你花了你不必用平

00:17:07.520 --> 00:17:11.930
映射执行暗示

00:17:10.160 --> 00:17:16.610
延迟，您可以只使用map 

00:17:11.930 --> 00:17:23.720
那小睡是为了平面映射流程

00:17:16.610 --> 00:17:26.270
在另一个流程中，所以回到代码中

00:17:23.720 --> 00:17:29.180
我们要切换分支，我们是

00:17:26.270 --> 00:17:35.300
去这步freako例程

00:17:29.180 --> 00:17:38.030
分支我们导入差异，我们

00:17:35.300 --> 00:17:41.060
将做添加的相同工作

00:17:38.030 --> 00:17:44.510
这个命令命令控制器并

00:17:41.060 --> 00:17:47.360
事情要利用这个

00:17:44.510 --> 00:17:51.260
一种API，但在让我们看一下之前

00:17:47.360 --> 00:17:53.510
在这里，所以在这里，我们现在有一个API 

00:17:51.260 --> 00:17:56.420
更接近我当务之急

00:17:53.510 --> 00:18:00.610
而是返回文章的新标签

00:17:56.420 --> 00:18:03.620
单声道的我的代码基本上是

00:18:00.610 --> 00:18:05.150
接近命令式世界

00:18:03.620 --> 00:18:06.020
反应和之间的区别

00:18:05.150 --> 00:18:08.780
协同例程

00:18:06.020 --> 00:18:11.120
是默认情况下我们的例程

00:18:08.780 --> 00:18:15.320
第二肯定，他们提供了明确的

00:18:11.120 --> 00:18:17.390
和可选的并发

00:18:15.320 --> 00:18:18.920
灵气世界，这是你必须使用

00:18:17.390 --> 00:18:26.090
运营商基本上是做东西

00:18:18.920 --> 00:18:26.660
第二场秀，是的，就像我在

00:18:26.090 --> 00:18:28.610
主题演讲

00:18:26.660 --> 00:18:31.070
 spring格式5.2提供内置

00:18:28.610 --> 00:18:34.010
支持协程，基本上

00:18:31.070 --> 00:18:36.350
支持报告的流返回类型

00:18:34.010 --> 00:18:38.990
两者的支出功能

00:18:36.350 --> 00:18:42.080
 Web的注释和功能变体

00:18:38.990 --> 00:18:49.040
错误，我们将添加非常

00:18:42.080 --> 00:18:51.370
相同的命令类，这里没有新内容

00:18:49.040 --> 00:18:54.790
将要添加我们的cou例程

00:18:51.370 --> 00:18:54.790
命令控制器

00:19:02.270 --> 00:19:07.410
所以有趣的是看到

00:19:04.530 --> 00:19:10.470
差异流是一种装饰

00:19:07.410 --> 00:19:12.360
 API喜欢标记流，但是当您

00:19:10.470 --> 00:19:14.430
在流量生成器内部或

00:19:12.360 --> 00:19:17.820
您实际上正在写的运算符

00:19:14.430 --> 00:19:21.030
命令代码，所以这里延迟是

00:19:17.820 --> 00:19:23.940
暂停功能不会

00:19:21.030 --> 00:19:26.220
鲜血，但会暂停，因此阻塞是不好的

00:19:23.940 --> 00:19:30.480
暂停还可以

00:19:26.220 --> 00:19:33.900
您可以发出数据，从而推动流量

00:19:30.480 --> 00:19:36.150
基于API，因此您正在发出

00:19:33.900 --> 00:19:39.630
可能来自的物体

00:19:36.150 --> 00:19:42.780
我在这里的其他暂停功能和

00:19:39.630 --> 00:19:46.020
就是这样，我将修改我的

00:19:42.780 --> 00:19:49.550
基于例程的HTML控制器，带有

00:19:46.020 --> 00:19:53.760
一样的东西，所以我要

00:19:49.550 --> 00:19:55.410
注入相同的风扇生成器，因为

00:19:53.760 --> 00:19:56.850
库鲁例行报告的哲学

00:19:55.410 --> 00:19:59.190
不是真的

00:19:56.850 --> 00:20:01.260
添加新类型，我是说我们有

00:19:59.190 --> 00:20:04.380
引入了许多新类型

00:20:01.260 --> 00:20:08.250
反应堆的想法是

00:20:04.380 --> 00:20:10.050
利用相同的类型，但是

00:20:08.250 --> 00:20:13.800
在...之上提供扩展功能

00:20:10.050 --> 00:20:17.400
提供基于库鲁青少年的API 

00:20:13.800 --> 00:20:21.810
除了常规活动的顶部

00:20:17.400 --> 00:20:26.310
一个，所以我要创建客户端

00:20:21.810 --> 00:20:34.070
我是同一个Web客户端实例

00:20:26.310 --> 00:20:39.200
将在此处添加命令列表

00:20:34.070 --> 00:20:44.340
命令，我将替换它

00:20:39.200 --> 00:20:47.430
同步渲染扩展功能

00:20:44.340 --> 00:20:54.450
新的东西

00:20:47.430 --> 00:20:58.320
例行程序，所以我要添加首席运营官

00:20:54.450 --> 00:21:01.470
我只有两个常规空间R 

00:20:58.320 --> 00:21:03.630
导入扩展名，以便您看到

00:21:01.470 --> 00:21:05.690
在这里我仍然回到我们周围

00:21:03.630 --> 00:21:09.270
文章，但这是一个暂停功能

00:21:05.690 --> 00:21:10.299
在这里，我利用了Web的API 

00:21:09.270 --> 00:21:13.509
客户在哪里

00:21:10.299 --> 00:21:15.639
编码扩展功能

00:21:13.509 --> 00:21:17.289
为我提供了使用

00:21:15.639 --> 00:21:19.950
协程，所以如果我们有一个逻辑

00:21:17.289 --> 00:21:24.399
导航器没有魔力

00:21:19.950 --> 00:21:26.950
我只是利用协同程序

00:21:24.399 --> 00:21:29.139
反应游泳互操作性

00:21:26.950 --> 00:21:31.929
转换一些返回单声道的东西

00:21:29.139 --> 00:21:34.690
归还飞机的一些事情

00:21:31.929 --> 00:21:37.209
值还行，所以真的没什么神奇的

00:21:34.690 --> 00:21:39.459
在我的实现中，您看到的是

00:21:37.209 --> 00:21:43.629
当务之急是默认使用第二个shell 

00:21:39.459 --> 00:21:46.029
有趣的是，与

00:21:43.629 --> 00:21:49.349
我在反应式API上所做的我没有

00:21:46.029 --> 00:21:52.299
必须修改我的博客和文章

00:21:49.349 --> 00:21:55.839
实现，因为此地图运算符

00:21:52.299 --> 00:21:58.929
正在执行暂停功能，所以我

00:21:55.839 --> 00:22:01.929
允许调用执行

00:21:58.929 --> 00:22:03.729
例如远程通话，我在这里

00:22:01.929 --> 00:22:05.739
只是放在那里我有这个

00:22:03.729 --> 00:22:08.049
小符号说好吧，这是一个

00:22:05.739 --> 00:22:11.469
暂停函数调用，但我正在使用

00:22:08.049 --> 00:22:19.499
就像我写命令一样

00:22:11.469 --> 00:22:19.499
代码，如果我只是在此处添加命令

00:22:20.969 --> 00:22:27.959
然后我进行测试

00:22:35.720 --> 00:22:44.250
好吧，现在就可以使用了

00:22:43.590 --> 00:22:48.030
四

00:22:44.250 --> 00:22:50.940
所以直到现在我们一直专注于

00:22:48.030 --> 00:22:52.470
不久将可用的东西

00:22:50.940 --> 00:22:55.970
生产，因为 Spring 引导到

00:22:52.470 --> 00:23:00.450
几周或几个月内就会有两个

00:22:55.970 --> 00:23:02.340
也许七月我不记得有两个DBC是

00:23:00.450 --> 00:23:04.110
尚未生产就绪，但我们

00:23:02.340 --> 00:23:05.940
甚至在春季运动都非常快

00:23:04.110 --> 00:23:08.430
我有两个DBC本身不是

00:23:05.940 --> 00:23:11.790
生产就绪，因此我们可以提供支持

00:23:08.430 --> 00:23:14.010
提供MongoDB的春季

00:23:11.790 --> 00:23:16.080
 Cassandra Redis的招聘

00:23:14.010 --> 00:23:17.970
扩展程序已经可以生产了，并且

00:23:16.080 --> 00:23:20.630
 spring boot 的一部分要两个这样

00:23:17.970 --> 00:23:23.250
有了新的SQL部分，您可以完全使用

00:23:20.630 --> 00:23:25.680
基于常规的持久性

00:23:23.250 --> 00:23:28.760
真正的生产步骤

00:23:25.680 --> 00:23:31.890
四，我们真的进入

00:23:28.760 --> 00:23:33.840
的实验孵化部分

00:23:31.890 --> 00:23:35.820
的扭矩还可以，所以我真的会

00:23:33.840 --> 00:23:37.590
想明确一点，直到现在我们

00:23:35.820 --> 00:23:40.400
几乎有东西

00:23:37.590 --> 00:23:43.800
生产准备就绪，我们在这里

00:23:40.400 --> 00:23:45.870
可能会毕业并正在培养的孵化工作

00:23:43.800 --> 00:23:50.490
可用于生产阅读模式，但我们

00:23:45.870 --> 00:23:53.370
还没来我要谈谈

00:23:50.490 --> 00:23:55.650
关于那些已经是

00:23:53.370 --> 00:23:58.170
目前在春季foo孵化，所以

00:23:55.650 --> 00:24:00.810
 spring foo是一个打算孵化器

00:23:58.170 --> 00:24:02.760
成熟的实验特征

00:24:00.810 --> 00:24:05.580
纳入春季农民

00:24:02.760 --> 00:24:08.430
像我们的食物和数据中的项目

00:24:05.580 --> 00:24:10.590
政变例行报告是事实的一部分

00:24:08.430 --> 00:24:12.870
 foo毕业之前

00:24:10.590 --> 00:24:15.030
 spring data 从工作中回答

00:24:12.870 --> 00:24:16.680
这是一个很好的例子和价值观特征

00:24:15.030 --> 00:24:20.390
实际上使用了您在春季发现的

00:24:16.680 --> 00:24:23.640
从全部5.2中， Spring foo的一部分

00:24:20.390 --> 00:24:25.590
而胡夫是主要的剩余特征

00:24:23.640 --> 00:24:29.190
目前正在春季孵化

00:24:25.590 --> 00:24:32.010
凯特琳（Kathleen）的foo Kofu和功能是

00:24:29.190 --> 00:24:33.630
极简高效和明确

00:24:32.010 --> 00:24:36.810
 spring boot 的配置模型

00:24:33.630 --> 00:24:38.820
这种杠杆作用发生在DSL中， 

00:24:36.810 --> 00:24:43.560
要具体向你展示它

00:24:38.820 --> 00:24:48.090
实际上，就历史而言， 

00:24:43.560 --> 00:24:49.040
去年在Kofu上行走的ID 

00:24:48.090 --> 00:24:54.720
 Spring 

00:24:49.040 --> 00:24:59.640
所以我走了几个月后才开始

00:24:54.720 --> 00:25:02.160
在khufu 0.0的那个ex版本上

00:24:59.640 --> 00:25:05.010
最初的实验是很多API 

00:25:02.160 --> 00:25:07.500
破损我也尝试过很多变化

00:25:05.010 --> 00:25:09.810
在Java的Jeff foo上行走， 

00:25:07.500 --> 00:25:12.750
提供基本准确的功能

00:25:09.810 --> 00:25:15.480
同样的事情也适用于Java，但是

00:25:12.750 --> 00:25:17.850
 DSL中的噪音太多了

00:25:15.480 --> 00:25:20.220
意味着Java太冗长而无法

00:25:17.850 --> 00:25:22.290
使用这种方法并不意味着

00:25:20.220 --> 00:25:23.580
 Java不会提供API来

00:25:22.290 --> 00:25:26.130
以编程方式配置Springwood 

00:25:23.580 --> 00:25:28.650
未来的方式，但我只想

00:25:26.130 --> 00:25:30.660
现在或以后专注于甲府

00:25:28.650 --> 00:25:34.680
您将拥有其他类型的api 

00:25:30.660 --> 00:25:37.530
在点o是

00:25:34.680 --> 00:25:39.540
本周发布，带来 Spring 

00:25:37.530 --> 00:25:44.010
和小姐报告除了 Spring 

00:25:39.540 --> 00:25:46.890
网络通量和khufu 0.2在

00:25:44.010 --> 00:25:49.980
进步，我们正在与

00:25:46.890 --> 00:25:52.830
在这的社区智慧体

00:25:49.980 --> 00:25:55.710
Spring 安全DSL上的房间

00:25:52.830 --> 00:25:57.630
支撑执行器和支撑

00:25:55.710 --> 00:25:59.520
 Spring ，JDBC Redis Cassandra 

00:25:57.630 --> 00:26:01.500
安德鲁配置和图形我们

00:25:59.520 --> 00:26:05.310
在某人的支持下

00:26:01.500 --> 00:26:08.160
社区目前正在提供帮助，因此

00:26:05.310 --> 00:26:11.370
我们将具体看到

00:26:08.160 --> 00:26:15.090
意味着我们将逐步

00:26:11.370 --> 00:26:17.220
将此应用程序转换为

00:26:15.090 --> 00:26:22.500
利用胡夫的应用程序

00:26:17.220 --> 00:26:29.310
 khufu基本上只是您的API 

00:26:22.500 --> 00:26:32.310
基本上会坚持配置

00:26:29.310 --> 00:26:34.950
我正在添加依赖项以具有

00:26:32.310 --> 00:26:37.380
 GSL，但重要的是要了解

00:26:34.950 --> 00:26:39.930
是我只是在利用

00:26:37.380 --> 00:26:43.320
 Spring 完全相同的基础设施

00:26:39.930 --> 00:26:47.310
靴子和春季农夫，但暴露在

00:26:43.320 --> 00:26:49.410
 Kofu的不同方式和目的是

00:26:47.310 --> 00:26:51.810
能够配置一切

00:26:49.410 --> 00:26:53.310
明确地，所以我们正在利用

00:26:51.810 --> 00:26:56.190
 Spring Boot配置基础架构

00:26:53.310 --> 00:26:58.230
但那里没有自动配置

00:26:56.190 --> 00:27:01.859
只是您的显式配置

00:26:58.230 --> 00:27:05.079
轻松配置DSL 

00:27:01.859 --> 00:27:08.049
您会看到我们将

00:27:05.079 --> 00:27:11.199
使用更少的注释，所以我只是

00:27:08.049 --> 00:27:13.149
删除它，因为我们不需要它

00:27:11.199 --> 00:27:16.089
将要删除的注释和

00:27:13.149 --> 00:27:18.369
提供另一种配置我的

00:27:16.089 --> 00:27:21.819
应用程序，所以在这里我只是删除了

00:27:18.369 --> 00:27:26.099
我要删除的属性上的注释

00:27:21.819 --> 00:27:28.929
仓库侧的注释和

00:27:26.099 --> 00:27:33.309
我要去这里的博客应用程序

00:27:28.929 --> 00:27:37.139
我也将其删除

00:27:33.309 --> 00:27:42.189
然后我将创建应用程序

00:27:37.139 --> 00:27:44.829
使用这个DSL，所以真的ggs 

00:27:42.189 --> 00:27:49.569
应用DSL是释放的主要

00:27:44.829 --> 00:27:51.339
我要去的胡夫入口点

00:27:49.569 --> 00:27:54.669
在显式配置 spring boot 

00:27:51.339 --> 00:27:56.799
这样我想创建一个标准

00:27:54.669 --> 00:27:59.649
应用一个servlet来使用一些

00:27:56.799 --> 00:28:02.259
猫或反应性的人在这里使用nettie 

00:27:59.649 --> 00:28:04.839
我们要用船员的少年

00:28:02.259 --> 00:28:10.059
报告，所以我想建立在

00:28:04.839 --> 00:28:11.829
反应性基础设施然后让我说

00:28:10.059 --> 00:28:14.919
要配置配置属性

00:28:11.829 --> 00:28:18.219
所以我要像这样配置

00:28:14.919 --> 00:28:21.219
所以我在这里指定属性

00:28:18.219 --> 00:28:23.469
我会利用一个易名的名字

00:28:21.219 --> 00:28:25.629
参数具有这种不错的

00:28:23.469 --> 00:28:28.209
定义我的可读方式

00:28:25.629 --> 00:28:30.579
配置属性以ID为前缀

00:28:28.209 --> 00:28:32.079
阅读以重用词汇表和

00:28:30.579 --> 00:28:36.639
 spring boot 的组成部分，但

00:28:32.079 --> 00:28:38.439
以更明确的方式指定

00:28:36.639 --> 00:28:40.719
应用程序将像这样运行

00:28:38.439 --> 00:28:42.249
好吧，没什么神奇的，只是

00:28:40.719 --> 00:28:45.279
以编程方式运行自旋良好

00:28:42.249 --> 00:28:50.019
基础设施，我要指定

00:28:45.279 --> 00:28:53.409
我的配置，所以我要添加我的

00:28:50.019 --> 00:28:55.059
数据配置，让我们来看一下

00:28:53.409 --> 00:28:59.219
一点时间看看发生了什么

00:28:55.059 --> 00:29:01.569
在这里，您可能大部分都知道

00:28:59.219 --> 00:29:05.889
 spring boot 片，让您

00:29:01.569 --> 00:29:07.419
去使用数据切片或网络切片

00:29:05.889 --> 00:29:10.539
能够运行您等待中的俄语测试

00:29:07.419 --> 00:29:14.740
更快地进行嘲讽等，但这是

00:29:10.539 --> 00:29:17.260
预定义的静态切片可以

00:29:14.740 --> 00:29:20.350
有一个数据，一个网络，这个

00:29:17.260 --> 00:29:22.600
我们在这里定义的艺术，您负责

00:29:20.350 --> 00:29:25.360
捍卫您想要的粒度

00:29:22.600 --> 00:29:28.450
创建自己的配置片，以便

00:29:25.360 --> 00:29:30.550
在这里我要指定自己的beans

00:29:28.450 --> 00:29:32.710
还有 Spring 的美好

00:29:30.550 --> 00:29:35.560
与数据相关的结构

00:29:32.710 --> 00:29:37.900
配置，但我正在使用这种

00:29:35.560 --> 00:29:40.150
技术的速度，但如果您想做

00:29:37.900 --> 00:29:42.280
一些更多的功能拆分，例如

00:29:40.150 --> 00:29:44.890
奥利弗在这个模块中它的扭矩

00:29:42.280 --> 00:29:47.860
完全有可能，所以我在这里定义

00:29:44.890 --> 00:29:49.900
 bean 好吧，这是AB公司自己

00:29:47.860 --> 00:29:52.720
我在这里指定的Spring Framework 

00:29:49.900 --> 00:29:56.610
该文章存储库应确保

00:29:52.720 --> 00:29:58.960
被创建，它将自动

00:29:56.610 --> 00:30:01.600
构造函数的参数将

00:29:58.960 --> 00:30:05.770
被自动自动连线，注意到

00:30:01.600 --> 00:30:10.030
我冷却后就开始使用

00:30:05.770 --> 00:30:13.360
这样的供应商还可以，但是我在这里

00:30:10.030 --> 00:30:16.240
选择公正，我可以得到参考

00:30:13.360 --> 00:30:18.850
到这里的兔子我就像

00:30:16.240 --> 00:30:21.460
在应该SQL将

00:30:18.850 --> 00:30:23.350
基本上触发这是

00:30:21.460 --> 00:30:25.090
配置所有的bean 

00:30:23.350 --> 00:30:27.490
送往DB的空气所需的空间

00:30:25.090 --> 00:30:28.990
 SQL，这基本上就是什么

00:30:27.490 --> 00:30:32.050
自动配置很好

00:30:28.990 --> 00:30:34.810
但是在这里，我要定义一个

00:30:32.050 --> 00:30:37.930
听众，我要说的是

00:30:34.810 --> 00:30:40.770
我要启用此应用程序

00:30:37.930 --> 00:30:44.260
数据配置好了，很明显

00:30:40.770 --> 00:30:47.380
现在我要迁移的大部分

00:30:44.260 --> 00:30:49.420
我们的注释基于一个Web层

00:30:47.380 --> 00:30:52.840
利用的东西

00:30:49.420 --> 00:30:56.530
网络拖鞋的功能变体，所以我

00:30:52.840 --> 00:30:59.170
要改变我的控制器

00:30:56.530 --> 00:31:01.420
两者都有您在上看到的映射

00:30:59.170 --> 00:31:03.690
请求映射斜杠API斜杠文章

00:31:01.420 --> 00:31:04.810
和实施

00:31:03.690 --> 00:31:07.150
无限的

00:31:04.810 --> 00:31:08.740
到只包含

00:31:07.150 --> 00:31:09.790
结束部分，路线将是

00:31:08.740 --> 00:31:13.780
外在化

00:31:09.790 --> 00:31:19.000
所以我要重命名文章

00:31:13.780 --> 00:31:23.130
我要去的文章的控制器

00:31:19.000 --> 00:31:23.130
将此实现替换为

00:31:24.260 --> 00:31:30.440
这一次我必须导入

00:31:27.490 --> 00:31:32.570
扩展以便能够使用它们

00:31:30.440 --> 00:31:37.400
真的有不同，而不是

00:31:32.570 --> 00:31:39.799
这个注释和这个灵活的

00:31:37.400 --> 00:31:42.290
签名我是某某某某

00:31:39.799 --> 00:31:44.929
那更实用我有几个

00:31:42.290 --> 00:31:47.929
请求作为输入参数，并且

00:31:44.929 --> 00:31:49.190
返回暂停，因为我有一个

00:31:47.929 --> 00:31:52.340
暂停函数将返回一个

00:31:49.190 --> 00:31:55.850
服务器响应还可以，这就是

00:31:52.340 --> 00:32:00.500
我有一些专家的反应式API 

00:31:55.850 --> 00:32:02.870
青少年扩展名，所以可以

00:32:00.500 --> 00:32:05.840
文章，我将做同样的事情

00:32:02.870 --> 00:32:11.480
对于通用控制器，我要去

00:32:05.840 --> 00:32:13.549
将其重命名为我要执行的命令

00:32:11.480 --> 00:32:19.850
用

00:32:13.549 --> 00:32:24.110
功能变体，因此命令

00:32:19.850 --> 00:32:31.610
在这样的情况下，我将做同样的事情

00:32:24.110 --> 00:32:43.940
对于HTML控制器，我希望我需要

00:32:31.610 --> 00:32:50.950
重命名它，以便可以替换HTML 

00:32:43.940 --> 00:32:50.950
那个实现就可以了

00:32:51.160 --> 00:32:56.600
现在我要加水

00:32:53.990 --> 00:32:59.059
因为现在我只有

00:32:56.600 --> 00:33:09.740
实施，我想添加我的

00:32:59.059 --> 00:33:12.710
路线，所以我在这里利用功能

00:33:09.740 --> 00:33:16.669
路由的东西基本上可以让我

00:33:12.710 --> 00:33:19.160
进行定义，因此您拥有一个API 

00:33:16.669 --> 00:33:21.110
提供价值要求谓词

00:33:19.160 --> 00:33:24.140
可以将它们与和和或

00:33:21.110 --> 00:33:29.299
可以使用嵌套请求的运算符

00:33:24.140 --> 00:33:32.330
谓词甚至可以使用动态代码

00:33:29.299 --> 00:33:34.400
使用if for循环来创建您的路线

00:33:32.330 --> 00:33:36.769
不只是语法糖

00:33:34.400 --> 00:33:39.350
想象你想在柯克兰发展

00:33:36.769 --> 00:33:42.499
 CMS或电子商务解决方案，其中

00:33:39.350 --> 00:33:44.210
根源是

00:33:42.499 --> 00:33:47.110
是通过后台创建的，因此您只

00:33:44.210 --> 00:33:49.279
在数据库中有

00:33:47.110 --> 00:33:51.470
这允许您创建根

00:33:49.279 --> 00:33:53.690
动态而不是拥有

00:33:51.470 --> 00:33:56.419
一切都是静态的，没有

00:33:53.690 --> 00:33:58.429
注释，所以它不仅仅是一个

00:33:56.419 --> 00:34:00.860
语法糖或其他书写方式

00:33:58.429 --> 00:34:04.249
更灵活的机制

00:34:00.860 --> 00:34:06.519
让你做更强大的事情

00:34:04.249 --> 00:34:09.470
在这里我有一个根

00:34:06.519 --> 00:34:12.200
创建多个rooters组合它们，以便

00:34:09.470 --> 00:34:15.859
我只是向用户展示一个简单的

00:34:12.200 --> 00:34:19.339
现在我们要利用的安排

00:34:15.859 --> 00:34:23.599
这个很好的转子，除非通过创建

00:34:19.339 --> 00:34:25.849
我们的服务器配置以及

00:34:23.599 --> 00:34:29.839
变得更加有趣

00:34:25.849 --> 00:34:32.800
在这里，就像我说的是明确的，所以我

00:34:29.839 --> 00:34:35.810
要定义我的服务器配置

00:34:32.800 --> 00:34:37.970
配置片或模块不确定

00:34:35.810 --> 00:34:40.780
正确的名字是什么，但我是

00:34:37.970 --> 00:34:43.639
定义beans，所以我在定义

00:34:40.780 --> 00:34:47.109
 HTML在您的控制之下的文章

00:34:43.639 --> 00:34:49.849
将按类型注入的bean 

00:34:47.109 --> 00:34:54.349
氧化物清除摆动的新功能

00:34:49.849 --> 00:34:56.540
这两个我们现在可以通过使用

00:34:54.349 --> 00:34:59.200
功能顶层功能参考

00:34:56.540 --> 00:35:03.740
因为基本上这个布罗德沃特

00:34:59.200 --> 00:35:06.440
功能可以看作是一种

00:35:03.740 --> 00:35:09.560
 bean 工厂 bean 汤层，所以我

00:35:06.440 --> 00:35:11.890
仅使用对该顶级的引用

00:35:09.560 --> 00:35:14.810
功能，所有参数将是

00:35:11.890 --> 00:35:17.060
自动注入，没有

00:35:14.810 --> 00:35:21.890
反射到这里，一切都在编译完成

00:35:17.060 --> 00:35:25.400
时间冒号，然后我要去

00:35:21.890 --> 00:35:26.750
配置更多高级内容，然后

00:35:25.400 --> 00:35:29.180
与秋千靴有关的东西

00:35:26.750 --> 00:35:33.109
通过宣布我有基础设施

00:35:29.180 --> 00:35:35.720
一个Web标志服务器，在这里我指定

00:35:33.109 --> 00:35:38.119
我将明确指定编解码器

00:35:35.720 --> 00:35:41.690
在 spring boot 时自动配置

00:35:38.119 --> 00:35:44.300
机制，您将拥有一些编解码器， 

00:35:41.690 --> 00:35:46.490
是根据

00:35:44.300 --> 00:35:48.760
你在这里的依赖

00:35:46.490 --> 00:35:51.609
负责定义

00:35:48.760 --> 00:35:57.060
定义食典来定义他们的

00:35:51.609 --> 00:36:00.430
订单，您还可以配置

00:35:57.060 --> 00:36:02.410
指定您要自动完成

00:36:00.430 --> 00:36:04.540
基本上它的兴趣是

00:36:02.410 --> 00:36:06.849
一切都是可以发现的

00:36:04.540 --> 00:36:10.480
甚至必须转到您的文档

00:36:06.849 --> 00:36:14.980
在这里具有完全的可发现性

00:36:10.480 --> 00:36:17.770
不仅如此，因为你拥有你

00:36:14.980 --> 00:36:20.320
可以指定自定义引擎说

00:36:17.770 --> 00:36:24.160
您要使用Tomcats而不是

00:36:20.320 --> 00:36:26.520
猫在这里，但码头或其他引擎

00:36:24.160 --> 00:36:29.800
基本上可以用神圣的过滤器

00:36:26.520 --> 00:36:36.359
甚至可以配置您的课程，就是这样

00:36:29.800 --> 00:36:39.190
非常强大，不，不，您在这里

00:36:36.359 --> 00:36:42.359
你也有胡子支持做

00:36:39.190 --> 00:36:46.180
视图渲染，我认为是这样

00:36:42.359 --> 00:36:50.109
我要添加最新的切片

00:36:46.180 --> 00:36:52.359
我的客户端配置可以吗，所以在这里

00:36:50.109 --> 00:36:56.530
再次，我负责配置

00:36:52.359 --> 00:37:02.079
编解码器，我将启用它

00:36:56.530 --> 00:37:04.920
在我的应用程序中配置

00:37:02.079 --> 00:37:08.260
我启用服务器配置

00:37:04.920 --> 00:37:11.710
客户端配置我什至可以

00:37:08.260 --> 00:37:13.630
通过指定配置日志记录

00:37:11.710 --> 00:37:20.740
再次将一切都发现

00:37:13.630 --> 00:37:24.250
就是这样，所以我认为

00:37:20.740 --> 00:37:26.550
应该没问题，所以如果我尝试运行我的

00:37:24.250 --> 00:37:26.550
应用

00:37:34.880 --> 00:37:45.170
好吧，所以您看到它开始非常快， 

00:37:41.230 --> 00:37:47.240
我的网站我的博客文章仍然不是很

00:37:45.170 --> 00:37:48.920
很好，但是你看到那贴心

00:37:47.240 --> 00:37:51.710
相当不错的功能

00:37:48.920 --> 00:37:55.700
好吧，现在假设我要更新我的

00:37:51.710 --> 00:37:58.160
测试，因为使用胡夫法

00:37:55.700 --> 00:38:00.890
你不可以创建一些自定义

00:37:58.160 --> 00:38:04.420
应用程序上下文，因此您将

00:38:00.890 --> 00:38:04.420
事情有点不同

00:38:05.829 --> 00:38:13.009
基本上你不需要任何一种

00:38:08.990 --> 00:38:18.920
您对春季的单位特定支持

00:38:13.009 --> 00:38:20.690
只是去编程你知道的事情

00:38:18.920 --> 00:38:25.849
以编程方式进行操作

00:38:20.690 --> 00:38:28.130
我所做的让我在这里结束那件事

00:38:25.849 --> 00:38:30.140
我要做的是我只是为了

00:38:28.130 --> 00:38:32.599
我测试风俗的目的

00:38:30.140 --> 00:38:34.730
我将集成的应用程序

00:38:32.599 --> 00:38:37.099
切片配置切片

00:38:34.730 --> 00:38:39.019
我需要，所以我只是集成服务器

00:38:37.099 --> 00:38:42.049
配置和客户端配置不是我

00:38:39.019 --> 00:38:44.420
配置，我要模拟戏剧

00:38:42.049 --> 00:38:47.049
通过模拟存储库

00:38:44.420 --> 00:38:49.789
在韩国世界相当于mojito和

00:38:47.049 --> 00:38:52.609
没关系，所以真的

00:38:49.789 --> 00:38:54.710
重要的是要知道如果你组织

00:38:52.609 --> 00:38:57.829
您的配置配置片

00:38:54.710 --> 00:39:01.279
以正确的粒度

00:38:57.829 --> 00:39:03.799
您可以控制或创建自定义

00:39:01.279 --> 00:39:06.170
只是为了您的目的而申请

00:39:03.799 --> 00:39:08.869
以所需的粒度进行测试

00:39:06.170 --> 00:39:15.769
如果您只想构建应用程序

00:39:08.869 --> 00:39:18.769
测试我们将重复使用我所使用的应用程序

00:39:15.769 --> 00:39:21.380
已经在这里定义好了，在这里我不尝试

00:39:18.769 --> 00:39:24.019
创建一个自定义应用程序

00:39:21.380 --> 00:39:26.720
与进行常规集成测试

00:39:24.019 --> 00:39:29.630
我运行它的现有应用程序

00:39:26.720 --> 00:39:32.569
上下文，然后我就可以做一些

00:39:29.630 --> 00:39:34.490
断言，因为返回什么

00:39:32.569 --> 00:39:37.549
应用学说只是一个

00:39:34.490 --> 00:39:40.819
应用程序上下文再次如此

00:39:37.549 --> 00:39:43.569
的语法听起来可能还不熟悉

00:39:40.819 --> 00:39:47.390
但在下面，您正在使用所有

00:39:43.569 --> 00:39:50.200
在功能和类型下面

00:39:47.390 --> 00:39:50.200
春季提供

00:39:53.220 --> 00:40:00.130
好的，让我们用以下内容结束演示

00:39:56.980 --> 00:40:01.960
更多信息，如果您喜欢，如果

00:40:00.130 --> 00:40:03.940
你喜欢这种配置Spring 

00:40:01.960 --> 00:40:05.950
靴子和更实用的方式

00:40:03.940 --> 00:40:09.069
更明确的方式可以随意拥有

00:40:05.950 --> 00:40:11.920
从spring foo仓库开始

00:40:09.069 --> 00:40:13.480
也可以真正贡献力量

00:40:11.920 --> 00:40:15.339
社区开始做出很大贡献

00:40:13.480 --> 00:40:18.970
像 Spring 一样有趣的功能

00:40:15.339 --> 00:40:22.049
证券报告及其他功能

00:40:18.970 --> 00:40:26.740
这样，请随时尝试

00:40:22.049 --> 00:40:30.160
发送反馈简单的要求真的我们

00:40:26.740 --> 00:40:33.490
在你可以的时候进来

00:40:30.160 --> 00:40:35.740
对这个项目有重大影响， 

00:40:33.490 --> 00:40:38.680
您现在可以提供功能

00:40:35.740 --> 00:40:40.839
基础几乎稳定，我们需要

00:40:38.680 --> 00:40:42.789
增加对其他部分的支持

00:40:40.839 --> 00:40:46.779
 Spring 的Buteyko系统让您可以随意

00:40:42.789 --> 00:40:49.900
来贡献我的力量

00:40:46.779 --> 00:40:51.609
最后总结一下状态

00:40:49.900 --> 00:40:53.440
因为我们看到了一些东西

00:40:51.609 --> 00:40:55.180
不久将可用吗

00:40:53.440 --> 00:40:58.569
生产和其他东西

00:40:55.180 --> 00:40:59.920
更多的孵化，什么是生产

00:40:58.569 --> 00:41:02.890
阅读耳语到两个引导

00:40:59.920 --> 00:41:05.289
网络流量和ASO变得常规

00:41:02.890 --> 00:41:07.150
报告反应性的Spring 

00:41:05.289 --> 00:41:10.089
 MongoDB Redis Cassandra代码在

00:41:07.150 --> 00:41:13.420
扩展程序，这样就可以生产了

00:41:10.089 --> 00:41:16.359
这个很酷的例程API只是

00:41:13.420 --> 00:41:18.759
使用指令API的另一种方法

00:41:16.359 --> 00:41:21.759
我们已经开始提供

00:41:18.759 --> 00:41:24.039
耳语中的酚盐在制品

00:41:21.759 --> 00:41:28.420
这意味着我们正在努力

00:41:24.039 --> 00:41:31.809
它可能在短期内可用

00:41:28.420 --> 00:41:33.970
新产品发布说明有一个

00:41:31.809 --> 00:41:36.339
政变例行资料库

00:41:33.970 --> 00:41:38.529
此反应式代码存储库接口

00:41:36.339 --> 00:41:40.239
在 spring data 中可能会很有趣

00:41:38.529 --> 00:41:41.859
具有完全相同的功能

00:41:40.239 --> 00:41:44.079
船员们除了

00:41:41.859 --> 00:41:46.749
功能性API，因此有专门的

00:41:44.079 --> 00:41:49.869
问题，随时添加您的

00:41:46.749 --> 00:41:52.059
再加上一个明显的公元前2d和 Spring 

00:41:49.869 --> 00:41:54.609
连接到BC需要到达GS 

00:41:52.059 --> 00:41:57.130
集成在 spring boot 中的阶段

00:41:54.609 --> 00:42:00.910
并且可以在生产准备阶段使用

00:41:57.130 --> 00:42:04.660
 Kofu还在孵化

00:42:00.910 --> 00:42:06.640
再次随意为发送做贡献

00:42:04.660 --> 00:42:08.380
我们的反馈实际上是

00:42:06.640 --> 00:42:10.210
在某个时候我真的很想

00:42:08.380 --> 00:42:13.870
支持生产准备

00:42:10.210 --> 00:42:15.790
阶段我们还没到这里，那就是

00:42:13.870 --> 00:42:18.220
正确的时间给您发送反馈说

00:42:15.790 --> 00:42:20.320
您是否感兴趣并做出贡献

00:42:18.220 --> 00:42:26.220
也许您想获得支持

00:42:20.320 --> 00:42:30.610
在这里，非常感谢，是的，谢谢

00:42:26.220 --> 00:42:30.610
 [掌声] 

00:42:31.650 --> 00:42:34.900
 [音乐] 

