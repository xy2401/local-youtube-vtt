WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.900 --> 00:00:11.030
 [音乐] 

00:00:07.360 --> 00:00:13.730
好的，欢迎参加会议

00:00:11.030 --> 00:00:17.570
大家很酷的容器

00:00:13.730 --> 00:00:21.710
再来看看这部分确实

00:00:17.570 --> 00:00:23.810
揭示我们将要关注的重点

00:00:21.710 --> 00:00:28.400
看一下Spring Framework的五个二

00:00:23.810 --> 00:00:31.039
从非常特定的角度来看很酷

00:00:28.400 --> 00:00:33.199
我们不得不重新审查的机制

00:00:31.039 --> 00:00:36.680
我们必须重新审视的抽象

00:00:33.199 --> 00:00:39.109
五到两个时间框架

00:00:36.680 --> 00:00:41.030
动力来自高处

00:00:39.109 --> 00:00:44.660
 Spring Boot的某些使用模型

00:00:41.030 --> 00:00:46.879
特别是从弹簧数据中

00:00:44.660 --> 00:00:50.539
这个特定的版本，所以有

00:00:46.879 --> 00:00:52.699
相当多的需求即将到来

00:00:50.539 --> 00:00:54.500
低于其他投资组合项目

00:00:52.699 --> 00:00:57.469
到公司的核心框架

00:00:54.500 --> 00:01:00.829
容器，我要拿这个

00:00:57.469 --> 00:01:02.239
机会揭示我们的一些

00:01:00.829 --> 00:01:03.949
我们动机的变化

00:01:02.239 --> 00:01:07.250
在他们后面

00:01:03.949 --> 00:01:09.890
因为已经有很多

00:01:07.250 --> 00:01:12.230
我也认为是在5.1中引入的

00:01:09.890 --> 00:01:15.230
如果您非常了解五个

00:01:12.230 --> 00:01:19.850
哦，但没有意识到

00:01:15.230 --> 00:01:21.440
在5.1中，我也开始学习

00:01:19.850 --> 00:01:23.620
本演示文稿的第一部分

00:01:21.440 --> 00:01:28.970
我将借此机会

00:01:23.620 --> 00:01:31.430
讨论一些关键的设计变更设计

00:01:28.970 --> 00:01:34.130
我们首先在5.1中引入的元素

00:01:31.430 --> 00:01:38.450
我们将要进入​​五到两个

00:01:34.130 --> 00:01:40.580
事后有特定的机制

00:01:38.450 --> 00:01:43.430
这当然非常接近我

00:01:40.580 --> 00:01:46.030
因为我负责日常工作

00:01:43.430 --> 00:01:48.950
管理Spring框架项目

00:01:46.030 --> 00:01:52.250
我们在这里所做的很多工作

00:01:48.950 --> 00:01:55.730
我们在这里说话时确实发生了

00:01:52.250 --> 00:01:58.810
在我和我的团队中，所以这是

00:01:55.730 --> 00:02:02.200
烤箱很热，要注意

00:01:58.810 --> 00:02:04.730
这是正在进行的工作，五到两个是

00:02:02.200 --> 00:02:07.520
接近第三个里程碑不是

00:02:04.730 --> 00:02:10.879
在候选发布阶段

00:02:07.520 --> 00:02:13.879
我们在这里讨论的功能

00:02:10.879 --> 00:02:14.670
在5.1或

00:02:13.879 --> 00:02:17.490
五到二

00:02:14.670 --> 00:02:19.680
对其中的一些，我要指出

00:02:17.490 --> 00:02:21.750
他们出来，我希望你不要忘记我

00:02:19.680 --> 00:02:25.319
指出他们只会来

00:02:21.750 --> 00:02:30.900
在m3或我们的c1中，所以我仍然不

00:02:25.319 --> 00:02:34.500
实际发布了，所以让我们下去

00:02:30.900 --> 00:02:37.430
到核心api的原样

00:02:34.500 --> 00:02:40.950
当然知道Spring Framework 5要做的事情

00:02:37.430 --> 00:02:43.320
对我们来说是一个机会Java 8 

00:02:40.950 --> 00:02:45.390
基线使我们能够重新审视

00:02:43.320 --> 00:02:50.130
整个代码库，特别是

00:02:45.390 --> 00:02:53.280
整个API展示了语言元素

00:02:50.130 --> 00:02:55.530
 Java 8的设计能力

00:02:53.280 --> 00:02:58.250
语言元素真的很闪亮

00:02:55.530 --> 00:03:01.080
通过这里，我们能够重新访问

00:02:58.250 --> 00:03:03.660
许多API表面

00:03:01.080 --> 00:03:06.150
 Java 8流的观点

00:03:03.660 --> 00:03:08.310
从使用lambdas的角度

00:03:06.150 --> 00:03:09.720
和功能界面很多

00:03:08.310 --> 00:03:14.400
产生并保持的影响

00:03:09.720 --> 00:03:17.250
具有影响力的Java 8 API 

00:03:14.400 --> 00:03:19.739
设计是一种它的

00:03:17.250 --> 00:03:21.420
正在进行的工作仍在我们身边

00:03:19.739 --> 00:03:25.410
有五项改进

00:03:21.420 --> 00:03:28.500
两个仍然沿着这个主题，但让我们

00:03:25.410 --> 00:03:32.640
让我们来接几个中央

00:03:28.500 --> 00:03:35.190
那个故事的元素，第一个

00:03:32.640 --> 00:03:38.519
我们曾经能够使用Java的时间

00:03:35.190 --> 00:03:41.220
我们自己的API sand SPS中的8种API类型是

00:03:38.519 --> 00:03:43.290
从500带来，但我们只做了

00:03:41.220 --> 00:03:47.519
最初通过代码库的次数很多

00:03:43.290 --> 00:03:49.620
跟进是在5.1中

00:03:47.519 --> 00:03:51.870
以多种方式体现出来

00:03:49.620 --> 00:03:55.170
特别是Java 8 API类型的使用

00:03:51.870 --> 00:03:58.049
不仅是语言元素

00:03:55.170 --> 00:04:01.200
例如关于新时间

00:03:58.049 --> 00:04:03.120
输入本地日期时间，依此类推

00:04:01.200 --> 00:04:06.989
关于使用可完成的未来

00:04:03.120 --> 00:04:08.940
 Java 8中引入了更多功能

00:04:06.989 --> 00:04:10.950
我们可以做的高效反射查找

00:04:08.940 --> 00:04:13.140
使用可执行文件的新基础

00:04:10.950 --> 00:04:17.519
构造函数方法类介绍

00:04:13.140 --> 00:04:19.680
在Java 8中，有很多事情

00:04:17.519 --> 00:04:22.979
当然是Java util流

00:04:19.680 --> 00:04:25.710
我们在那介绍的

00:04:22.979 --> 00:04:27.990
机会，我们所做的另一部分

00:04:25.710 --> 00:04:28.500
这对我们来说仍然非常重要

00:04:27.990 --> 00:04:31.440
与

00:04:28.500 --> 00:04:33.800
完善接口以供使用

00:04:31.440 --> 00:04:37.140
默认方法，所以如果您已经

00:04:33.800 --> 00:04:40.170
与某些

00:04:37.140 --> 00:04:42.060
 springform中的接口在500和5-1 

00:04:40.170 --> 00:04:44.610
您可能已经注意到默认

00:04:42.060 --> 00:04:46.950
方法不断出现，我们确实

00:04:44.610 --> 00:04:49.740
特别清除现有方法

00:04:46.950 --> 00:04:51.720
作为默认方法，这样您就可以

00:04:49.740 --> 00:04:53.220
接口的实现或某些

00:04:51.720 --> 00:04:56.880
集成商是实施者

00:04:53.220 --> 00:04:58.140
界面拥有更轻松的时间

00:04:56.880 --> 00:05:00.330
与...特别相关

00:04:58.140 --> 00:05:04.230
回调接口，因此如果您自定义

00:05:00.330 --> 00:05:06.150
说光束后处理或处理程序

00:05:04.230 --> 00:05:08.130
然后在Spring MVC中使用方法拦截器

00:05:06.150 --> 00:05:09.660
这些现在更容易实现，因为

00:05:08.130 --> 00:05:11.310
这些方法都是默认方法， 

00:05:09.660 --> 00:05:14.160
您只是选择实施一个

00:05:11.310 --> 00:05:15.810
真的很在乎这一切

00:05:14.160 --> 00:05:21.330
由于Java八

00:05:15.810 --> 00:05:23.750
建立基线，这是我们的另一项相关努力

00:05:21.330 --> 00:05:26.280
经历过的是零能力的故事

00:05:23.750 --> 00:05:28.950
我一直在指这个

00:05:26.280 --> 00:05:30.450
早上主要是跟进

00:05:28.950 --> 00:05:33.560
有后续工作

00:05:30.450 --> 00:05:36.570
与Google和JetBrains合作

00:05:33.560 --> 00:05:38.730
所以为了更好地定义

00:05:36.570 --> 00:05:40.800
定义明确，正确发布的meta 

00:05:38.730 --> 00:05:43.830
背后的符号模型

00:05:40.800 --> 00:05:47.460
本质上，这个故事是非常直接的

00:05:43.830 --> 00:05:50.370
我们的API设计了整个API表面

00:05:47.460 --> 00:05:53.310
附带清洁声明

00:05:50.370 --> 00:05:57.060
它基本上是null安全API的一种形式

00:05:53.310 --> 00:05:59.850
设计，我们声明我们的包装不是

00:05:57.060 --> 00:06:02.490
默认情况下为null 

00:05:59.850 --> 00:06:06.770
意思是听不清的参数

00:06:02.490 --> 00:06:10.290
可以为null的返回值是

00:06:06.770 --> 00:06:12.840
如此明确地注释，如果您

00:06:10.290 --> 00:06:15.660
甚至只看Java文档或

00:06:12.840 --> 00:06:17.910
 IDE中的API（如果您要说） 

00:06:15.660 --> 00:06:20.010
豆工厂得到你有一个

00:06:17.910 --> 00:06:22.350
明确合同

00:06:20.010 --> 00:06:24.870
通常不期望参数

00:06:22.350 --> 00:06:28.229
为null，更重要的是

00:06:24.870 --> 00:06:30.900
返回值通常不为null 

00:06:28.229 --> 00:06:33.720
保证您不依赖于null 

00:06:30.900 --> 00:06:35.760
在此如果它们可以为null，则我们进行注释

00:06:33.720 --> 00:06:37.050
具有可空含义的方法

00:06:35.760 --> 00:06:40.289
该特定商品的返回值

00:06:37.050 --> 00:06:42.460
方法可以为null，这是形式上的

00:06:40.289 --> 00:06:44.560
我们正在验证的声明

00:06:42.460 --> 00:06:47.949
在IntelliJ中使用一些工具

00:06:44.560 --> 00:06:50.169
 IDEA为此提供了极大的支持

00:06:47.949 --> 00:06:51.699
生活编辑以及

00:06:50.169 --> 00:06:54.400
您可以针对

00:06:51.699 --> 00:06:57.310
代码库，我们在内部做

00:06:54.400 --> 00:07:00.009
确保我们的大型代码库具有

00:06:57.310 --> 00:07:02.560
清除可延展性代码路径，以便

00:07:00.009 --> 00:07:04.870
我们所做的所有假设

00:07:02.560 --> 00:07:07.060
东西为空或非空我

00:07:04.870 --> 00:07:09.550
实际上有效到了

00:07:07.060 --> 00:07:10.539
整个调用堆栈，您可以在

00:07:09.550 --> 00:07:13.330
您的申请

00:07:10.539 --> 00:07:17.020
与我们的api一起发货

00:07:13.330 --> 00:07:19.150
那些您可能具有以下代码的注释

00:07:17.020 --> 00:07:21.460
您的应用程序代码调用

00:07:19.150 --> 00:07:23.740
春天的API，你可以使用例如

00:07:21.460 --> 00:07:26.080
 IntelliJ是IntelliJ IDEA的工具

00:07:23.740 --> 00:07:30.009
工具来验证您对我们的呼叫

00:07:26.080 --> 00:07:32.530
工具使用的简单方法

00:07:30.009 --> 00:07:34.229
在这些正式声明中，我们

00:07:32.530 --> 00:07:36.610
通过这些可为空的注释发送

00:07:34.229 --> 00:07:39.759
当然，对编码的影响甚至

00:07:36.610 --> 00:07:42.849
更强大，因为在科特林有一个

00:07:39.759 --> 00:07:45.009
类型中不执行的元素

00:07:42.849 --> 00:07:47.169
系统可以声明类型引用

00:07:45.009 --> 00:07:49.930
不为null，耦合编译器为

00:07:47.169 --> 00:07:52.630
只允许这样的分配

00:07:49.930 --> 00:07:56.139
如果呼叫的结果

00:07:52.630 --> 00:07:59.199
您分配的表达式是干净的

00:07:56.139 --> 00:08:01.030
不为null，因此如果您使用

00:07:59.199 --> 00:08:02.860
不清楚null能力这个东西也许

00:08:01.030 --> 00:08:06.370
不是切割编译器要

00:08:02.860 --> 00:08:08.740
拒绝立即分配，而

00:08:06.370 --> 00:08:10.810
如果您正在调用spring API方法

00:08:08.740 --> 00:08:12.789
明确声明为非null 

00:08:10.810 --> 00:08:15.460
切割编译器会很高兴

00:08:12.789 --> 00:08:18.340
允许作业，这是其中之一

00:08:15.460 --> 00:08:20.469
我们之所以这样做的原因不仅在于

00:08:18.340 --> 00:08:22.630
 Java工具特别好

00:08:20.469 --> 00:08:25.630
与切割互动

00:08:22.630 --> 00:08:29.229
编译器真的很

00:08:25.630 --> 00:08:35.680
在我们切割中的重要推动力

00:08:29.229 --> 00:08:37.690
故事还好，这里只是几个

00:08:35.680 --> 00:08:40.180
示例和一些新的API 

00:08:37.690 --> 00:08:42.279
通过一个很好的例子闪耀是我们的

00:08:40.180 --> 00:08:45.370
合理的对象提供者

00:08:42.279 --> 00:08:48.779
最近推出了三款，但截至

00:08:45.370 --> 00:08:51.100
 5.1还可与

00:08:48.779 --> 00:08:52.779
对应用程序进行编程调用

00:08:51.100 --> 00:08:54.579
 Bean工厂的上下文获取光束

00:08:52.779 --> 00:08:55.840
提供者和您的类型

00:08:54.579 --> 00:08:57.550
有兴趣

00:08:55.840 --> 00:09:00.430
我们会给您一个对象提供者

00:08:57.550 --> 00:09:01.960
此处的foo类型和对象

00:09:00.430 --> 00:09:04.630
提供者有几种方法，只是

00:09:01.960 --> 00:09:07.779
看空能力得到如果

00:09:04.630 --> 00:09:09.730
就其语义而言可用

00:09:07.779 --> 00:09:12.400
如果存在的话给我

00:09:09.730 --> 00:09:14.410
如果不返回上下文，现在写

00:09:12.400 --> 00:09:16.630
同样忘记如果有

00:09:14.410 --> 00:09:18.670
唯一的对象只有一个匹配

00:09:16.630 --> 00:09:21.250
类型给我，否则返回

00:09:18.670 --> 00:09:24.480
现在这些方法当然声明为

00:09:21.250 --> 00:09:27.130
可返回值可为空

00:09:24.480 --> 00:09:30.310
我们在其中引入了一些新方法

00:09:27.130 --> 00:09:35.080
回到FIFO成为提供者

00:09:30.310 --> 00:09:36.730
 5/1这些方法有点AA 

00:09:35.080 --> 00:09:38.680
基本上可以发挥零能力

00:09:36.730 --> 00:09:41.470
他们有一点曲折

00:09:38.680 --> 00:09:43.990
如果可用，这是一个Java util 

00:09:41.470 --> 00:09:46.630
功能提供者返回默认值

00:09:43.990 --> 00:09:49.420
值（如果不可用）表示

00:09:46.630 --> 00:09:51.610
返回值保证为非

00:09:49.420 --> 00:09:53.980
 null要么是来自

00:09:51.610 --> 00:09:56.230
上下文或对象，如果那

00:09:53.980 --> 00:09:58.140
默认供应商生产， 

00:09:56.230 --> 00:10:00.670
默认供应商通常会绑定

00:09:58.140 --> 00:10:03.730
 Java 8 Lambda表达式或Java 

00:10:00.670 --> 00:10:06.250
 8方法参考甚至一点

00:10:03.730 --> 00:10:07.060
更具功能性地说

00:10:06.250 --> 00:10:09.460
有空

00:10:07.060 --> 00:10:11.380
这是一个可以做某事的消费者

00:10:09.460 --> 00:10:14.110
对象，如果不可用则可用

00:10:11.380 --> 00:10:17.220
可用，只需略过通话即可

00:10:14.110 --> 00:10:20.260
一些真正有意义的API方法

00:10:17.220 --> 00:10:23.020
如果您比较听不清处理

00:10:20.260 --> 00:10:25.150
它们被明确设计为

00:10:23.020 --> 00:10:27.880
避免在他们的空返回值

00:10:25.150 --> 00:10:29.740
语义和可为空的声明使

00:10:27.880 --> 00:10:32.080
这个非常明确的没有隐藏在

00:10:29.740 --> 00:10:34.210
 Java文档就在其中

00:10:32.080 --> 00:10:40.959
如果带注释，请签名

00:10:34.210 --> 00:10:43.900
考虑到5-1还使我们能够

00:10:40.959 --> 00:10:45.910
对象提供者多一点

00:10:43.900 --> 00:10:48.060
如果您有顺便说一句

00:10:45.910 --> 00:10:50.350
提供者可以通过编程

00:10:48.060 --> 00:10:51.820
通过get pin provider调用解决

00:10:50.350 --> 00:10:53.830
但如上所述

00:10:51.820 --> 00:10:56.500
也可以注入到您的

00:10:53.830 --> 00:10:59.980
组件，如果您只是说而不是在

00:10:56.500 --> 00:11:01.959
自动有线foo添加自动白色对象

00:10:59.980 --> 00:11:04.089
 foo的提供者，那么您有这个

00:11:01.959 --> 00:11:05.950
在您手中的间接句柄

00:11:04.089 --> 00:11:08.290
我们将注入您的组件中的内容

00:11:05.950 --> 00:11:11.259
对于更复杂的林雷

00:11:08.290 --> 00:11:12.790
您轻松分辨对象

00:11:11.259 --> 00:11:14.649
需要它，所以它不是立即的

00:11:12.790 --> 00:11:16.839
食物的参考

00:11:14.649 --> 00:11:18.699
通过特定实例检索

00:11:16.839 --> 00:11:21.940
如果需要的话

00:11:18.699 --> 00:11:23.350
除了我们以前的方法

00:11:21.940 --> 00:11:25.180
只是讨论可用性和

00:11:23.350 --> 00:11:29.350
唯一性方法还有更多

00:11:25.180 --> 00:11:32.440
 5.1中的那些特别针对多个

00:11:29.350 --> 00:11:36.190
匹配的对象，所以如果还有更多

00:11:32.440 --> 00:11:38.139
比这样的实施

00:11:36.190 --> 00:11:41.199
您中的完整界面

00:11:38.139 --> 00:11:44.139
上下文，然后您可以遍历那些

00:11:41.199 --> 00:11:45.610
您可以通过构建Java util流

00:11:44.139 --> 00:11:47.500
他们俩都做到了

00:11:45.610 --> 00:11:49.779
基本上懒惰地解决

00:11:47.500 --> 00:11:52.509
可能还有一个有序的流

00:11:49.779 --> 00:11:56.380
带着春天的命令语义带我

00:11:52.509 --> 00:11:58.480
进入匹配项中的帐户

00:11:56.380 --> 00:12:01.360
在应用程序上下文中的实例

00:11:58.480 --> 00:12:03.250
一些相当复杂的检索

00:12:01.360 --> 00:12:09.819
与我们的容器互动

00:12:03.250 --> 00:12:13.029
正在通过这种方式使一些老歌，但

00:12:09.819 --> 00:12:16.149
好东西，我们继续前进

00:12:13.029 --> 00:12:18.190
真的很好用哪个是豆子

00:12:16.149 --> 00:12:21.069
我们在FIFO中介绍的方法

00:12:18.190 --> 00:12:23.800
它的检索方面

00:12:21.069 --> 00:12:25.839
基本上显示在这里

00:12:23.800 --> 00:12:27.910
程序交互

00:12:25.839 --> 00:12:30.040
针对容器进行检索

00:12:27.910 --> 00:12:32.350
程式辅助非常好

00:12:30.040 --> 00:12:34.680
实际注册的咖啡豆

00:12:32.350 --> 00:12:37.120
您可以通过编程独立

00:12:34.680 --> 00:12:38.740
检索声明的组件

00:12:37.120 --> 00:12:41.019
通过八台计算机通过8 

00:12:38.740 --> 00:12:43.300
配置类，您可以

00:12:41.019 --> 00:12:44.740
当然做基于注解的

00:12:43.300 --> 00:12:46.209
您注册的组件

00:12:44.740 --> 00:12:46.600
以编程方式将所有内容混合在一起

00:12:46.209 --> 00:12:49.389
匹配

00:12:46.600 --> 00:12:52.870
但从风格上讲

00:12:49.389 --> 00:12:54.610
很好，这只是如何

00:12:52.870 --> 00:12:57.250
您可以以编程方式减少

00:12:54.610 --> 00:12:59.350
功能样式的组件

00:12:57.250 --> 00:13:01.839
从AK 5到后代

00:12:59.350 --> 00:13:04.630
有一些新的使用

00:13:01.839 --> 00:13:07.689
在那里注册一个类型的组件

00:13:04.630 --> 00:13:09.339
 foo该组件的bean定义

00:13:07.689 --> 00:13:12.189
将在封面下注册

00:13:09.339 --> 00:13:14.680
一个是酒吧，另一个是酒吧

00:13:12.189 --> 00:13:16.779
与即时供应商

00:13:14.680 --> 00:13:19.360
建立一个新的酒吧实例并调用

00:13:16.779 --> 00:13:21.440
回到容器中

00:13:19.360 --> 00:13:25.520
食物的实例

00:13:21.440 --> 00:13:27.170
在这里注入

00:13:25.520 --> 00:13:30.020
下面的例子多一点

00:13:27.170 --> 00:13:33.020
复杂，因为它注册了

00:13:30.020 --> 00:13:35.120
即时供应商的钢筋组件

00:13:33.020 --> 00:13:36.980
它本身不会注入foo 

00:13:35.120 --> 00:13:40.340
使用新的get in provider方法

00:13:36.980 --> 00:13:43.850
五，你通过一个对象提供者

00:13:40.340 --> 00:13:45.710
 foo进入该bar构造函数和Bar 

00:13:43.850 --> 00:13:48.640
可以懒惰地与容器互动

00:13:45.710 --> 00:13:51.440
检索实际的实例和

00:13:48.640 --> 00:13:53.150
除此之外，它因此达到

00:13:51.440 --> 00:13:55.400
底层标志底层ping 

00:13:53.150 --> 00:13:57.590
定义是懒惰的，所以如果它是一个

00:13:55.400 --> 00:13:59.630
默认情况下，单例甚至

00:13:57.590 --> 00:14:03.620
 bar实例本身只会被创建

00:13:59.630 --> 00:14:05.990
当其他组件检索条形图时

00:14:03.620 --> 00:14:08.270
来自容器，所以这是一个

00:14:05.990 --> 00:14:10.730
替代配置类

00:14:08.270 --> 00:14:12.920
完全以编程方式结束

00:14:10.730 --> 00:14:14.780
没有反射，没有注释

00:14:12.920 --> 00:14:19.670
在一起真的很融洽

00:14:14.780 --> 00:14:21.200
与医护人员检索，所以这是

00:14:19.670 --> 00:14:25.490
我们不会去的谷轮版

00:14:21.200 --> 00:14:29.240
对其进行详细介绍，但要保留

00:14:25.490 --> 00:14:31.010
在春天，我们会继续保持5马赫的速度

00:14:29.240 --> 00:14:33.530
运输棉花扩展他们

00:14:31.010 --> 00:14:36.350
实际上在v 1和

00:14:33.530 --> 00:14:38.690
 v 2也有一个

00:14:36.350 --> 00:14:41.540
特别是一个不错的一点几乎像DSL一样

00:14:38.690 --> 00:14:42.860
您可以摆脱的体验

00:14:41.540 --> 00:14:45.770
耦合语言的组合

00:14:42.860 --> 00:14:48.200
功能和我们的Kotlin被

00:14:45.770 --> 00:14:50.240
向自己注册没有

00:14:48.200 --> 00:14:56.030
特殊的必要设置只是选择

00:14:50.240 --> 00:14:59.690
使用Coplin使用spring上下文5 105 

00:14:56.030 --> 00:15:01.070
 jar并开始使用这些方法

00:14:59.690 --> 00:15:03.560
作为棉花扩展交付

00:15:01.070 --> 00:15:05.390
在标准罐子里放棉花

00:15:03.560 --> 00:15:07.940
编译器自动将它们拾取并

00:15:05.390 --> 00:15:10.040
将它们应用于spring api类型

00:15:07.940 --> 00:15:12.320
约定，以便您可以拥有一个非常

00:15:10.040 --> 00:15:13.910
开箱即用的好代码

00:15:12.320 --> 00:15:15.500
基本上与

00:15:13.910 --> 00:15:18.770
之前的代码有所不同

00:15:15.500 --> 00:15:20.990
用内联线向下扭曲

00:15:18.770 --> 00:15:25.010
是被要求像

00:15:20.990 --> 00:15:27.230
经验和在那里

00:15:25.010 --> 00:15:29.660
在线即时供应商有一些

00:15:27.230 --> 00:15:31.430
 Kopplin带来的便利

00:15:29.660 --> 00:15:33.860
因为我们可以使用专用副本

00:15:31.430 --> 00:15:35.480
反射AP也是我们要做的事情

00:15:33.860 --> 00:15:39.889
最近介绍了

00:15:35.480 --> 00:15:41.660
强制存在

00:15:39.889 --> 00:15:44.480
从技术上讲很少重复

00:15:41.660 --> 00:15:46.730
在Java中可能我们必须要求

00:15:44.480 --> 00:15:48.550
在某些情况下是明确的类型，因为

00:15:46.730 --> 00:15:51.110
我们无法推断出的返回类型

00:15:48.550 --> 00:15:52.670
贷方表达式和方法参考

00:15:51.110 --> 00:15:55.339
而在科特林有一个专门的

00:15:52.670 --> 00:15:57.709
具有可靠回报的反射API 

00:15:55.339 --> 00:16:00.860
推断类型，这样您就可以

00:15:57.709 --> 00:16:02.570
在这种情况下，不错的快捷方式语法

00:16:00.860 --> 00:16:04.760
在我们注册酒吧组件的地方

00:16:02.570 --> 00:16:07.760
不必说借来的课和

00:16:04.760 --> 00:16:10.010
这是创建供应商的方法

00:16:07.760 --> 00:16:11.420
本身就是一个Thea 

00:16:10.010 --> 00:16:13.790
做了这小段代码

00:16:11.420 --> 00:16:16.070
可靠地创建bar的实例

00:16:13.790 --> 00:16:19.730
告诉我们这将是一个酒吧课

00:16:16.070 --> 00:16:22.130
毕竟，这只是一点点

00:16:19.730 --> 00:16:25.790
耦合在这里，让我们继续

00:16:22.130 --> 00:16:30.139
特别是五到两个主题的表现

00:16:25.790 --> 00:16:32.510
调优，我们有一些努力，我

00:16:30.139 --> 00:16:35.240
将总结表现

00:16:32.510 --> 00:16:36.110
调整主要是关于启动

00:16:35.240 --> 00:16:40.630
优化

00:16:36.110 --> 00:16:43.220
但它一如既往地以任何形式

00:16:40.630 --> 00:16:44.839
从未有过的性能提升

00:16:43.220 --> 00:16:46.730
确实完成了，我们正在尝试优化

00:16:44.839 --> 00:16:48.949
根据我们得到的反馈

00:16:46.730 --> 00:16:52.370
根据我们自己的理解

00:16:48.949 --> 00:16:53.839
我们进行的权衡是一个

00:16:52.370 --> 00:16:55.519
完全不费吹灰之力

00:16:53.839 --> 00:16:56.709
您在优化启动时间吗

00:16:55.519 --> 00:16:58.790
您针对峰值性能进行了优化

00:16:56.709 --> 00:17:00.680
如果需要，通常会有迭代器

00:16:58.790 --> 00:17:02.449
让你为单身优化

00:17:00.680 --> 00:17:05.660
线程执行或高度

00:17:02.449 --> 00:17:07.939
并发执行这些事情不

00:17:05.660 --> 00:17:11.449
总是不是所有人都可以实现的

00:17:07.939 --> 00:17:15.530
必须在两者之间做出一定的权衡

00:17:11.449 --> 00:17:18.290
这些优化需要五到两个

00:17:15.530 --> 00:17:20.179
主要关注我们的入门者

00:17:18.290 --> 00:17:22.790
性能允许基于弹簧

00:17:20.179 --> 00:17:25.699
以某种方式设计应用程序

00:17:22.790 --> 00:17:28.610
他们尽快开始

00:17:25.699 --> 00:17:30.890
可能以牺牲一些

00:17:28.610 --> 00:17:32.510
最初的请求可能会出现

00:17:30.890 --> 00:17:34.970
花费比以前更长的时间

00:17:32.510 --> 00:17:38.030
但是至少系统本身是

00:17:34.970 --> 00:17:41.059
目前可访问的显示器能够一点点

00:17:38.030 --> 00:17:42.470
有点早，有几个

00:17:41.059 --> 00:17:44.679
方面，我正在

00:17:42.470 --> 00:17:47.390
有机会讨论其中的一些

00:17:44.679 --> 00:17:48.490
其中之一是注释

00:17:47.390 --> 00:17:52.810
处理中

00:17:48.490 --> 00:17:54.490
在努力优化我们的工作中

00:17:52.810 --> 00:17:58.480
调用合并的注释并合并

00:17:54.490 --> 00:18:01.450
批注处理我们到了

00:17:58.480 --> 00:18:04.150
决定以五到二

00:18:01.450 --> 00:18:07.540
彻底重塑底层

00:18:04.150 --> 00:18:10.930
注释处理，因此5至2 

00:18:07.540 --> 00:18:12.640
基本上是一个新的实现

00:18:10.930 --> 00:18:15.190
注释处理从

00:18:12.640 --> 00:18:17.680
从头开始，但隐藏在同一个API后面

00:18:15.190 --> 00:18:20.790
所以现有的代码使用注释工具

00:18:17.680 --> 00:18:22.300
或带注释的元素详细信息仍

00:18:20.790 --> 00:18:25.150
做工不错

00:18:22.300 --> 00:18:26.860
具有二进制兼容性的二进制文件，但

00:18:25.150 --> 00:18:29.800
实际上使用新机制

00:18:26.860 --> 00:18:32.230
掩护下的设施

00:18:29.800 --> 00:18:35.650
称合并注解为Springs 

00:18:32.230 --> 00:18:37.780
允许组成的特定方式

00:18:35.650 --> 00:18:41.350
注解，如果您曾经想过

00:18:37.780 --> 00:18:44.200
我们像休息一样处理这些事情

00:18:41.350 --> 00:18:45.640
控制器是一个称为

00:18:44.200 --> 00:18:47.530
休息控制器，但有一个土壤

00:18:45.640 --> 00:18:49.990
控制器注释和净响应

00:18:47.530 --> 00:18:52.510
身体注释作为元注释

00:18:49.990 --> 00:18:54.880
注释类型分解

00:18:52.510 --> 00:18:58.260
通过注释来注释

00:18:54.880 --> 00:19:00.580
注解我们称为元注解

00:18:58.260 --> 00:19:02.320
这就是我们所说的合并

00:19:00.580 --> 00:19:05.920
注释处理并执行此操作

00:19:02.320 --> 00:19:08.380
有效地是不平凡的，所以五个

00:19:05.920 --> 00:19:10.870
基本上两个是我们重新审视的方式

00:19:08.380 --> 00:19:15.160
的安排和重要组成部分

00:19:10.870 --> 00:19:18.730
它允许表达提示

00:19:15.160 --> 00:19:21.160
随时随地优化快捷方式

00:19:18.730 --> 00:19:22.840
如果没有注释，则可能

00:19:21.160 --> 00:19:24.910
在特定的组件类型上找到

00:19:22.840 --> 00:19:27.220
我们不需要去搜索它

00:19:24.910 --> 00:19:29.410
我们甚至不需要反思

00:19:27.220 --> 00:19:31.380
如果我们知道没有这样的方法

00:19:29.410 --> 00:19:33.520
无论如何都可以在这里找到注释

00:19:31.380 --> 00:19:36.460
反射可能会很昂贵，但不会

00:19:33.520 --> 00:19:39.610
必须是但必须进行反射扫描

00:19:36.460 --> 00:19:42.580
类的签名可能有点

00:19:39.610 --> 00:19:45.190
特别是在启动时很昂贵，所以

00:19:42.580 --> 00:19:48.670
有运动注释API是

00:19:45.190 --> 00:19:51.400
已经在5到2平方米之间，或者在3平方米内

00:19:48.670 --> 00:19:54.340
我们看到的最新形式是某种形式

00:19:51.400 --> 00:19:56.260
注释存在注册表的更多信息

00:19:54.340 --> 00:19:58.750
重要的是没有注释

00:19:56.260 --> 00:20:01.690
注册表在哪里，如果你知道的话

00:19:58.750 --> 00:20:03.730
您的某些特定类别

00:20:01.690 --> 00:20:05.919
组件类型甚至某些软件包

00:20:03.730 --> 00:20:07.990
无论您是什么，如果您知道

00:20:05.919 --> 00:20:10.330
找不到这样的注释

00:20:07.990 --> 00:20:13.389
在那儿你应该能够注册

00:20:10.330 --> 00:20:14.830
运行时系统的提示

00:20:13.389 --> 00:20:16.600
甚至不需要打扰

00:20:14.830 --> 00:20:19.659
那些特殊的类型

00:20:16.600 --> 00:20:22.990
注释，以最简单的形式

00:20:19.659 --> 00:20:25.120
只会说我知道

00:20:22.990 --> 00:20:28.570
特定的类只有那些注释

00:20:25.120 --> 00:20:29.799
可以找到类型，并且只需

00:20:28.570 --> 00:20:31.899
单行表达

00:20:29.799 --> 00:20:34.240
以编程方式调用容器

00:20:31.899 --> 00:20:37.090
跳过整个搜索

00:20:34.240 --> 00:20:39.429
这些类上的注释类型

00:20:37.090 --> 00:20:41.559
可以为此目的不是

00:20:39.429 --> 00:20:45.190
实际上将他们转移到它的意图

00:20:41.559 --> 00:20:46.960
因为它是为了让你表达那些

00:20:45.190 --> 00:20:49.059
提示，无论您从何处获得

00:20:46.960 --> 00:20:51.460
以编程方式注册之前的人

00:20:49.059 --> 00:20:54.610
自举，但特别是你

00:20:51.460 --> 00:20:57.070
可以获取总和索引信息，如果

00:20:54.610 --> 00:21:01.419
你碰巧有任何翻译

00:20:57.070 --> 00:21:04.389
移至此注解注册表之前

00:21:01.419 --> 00:21:06.159
在很早的阶段就进行引导

00:21:04.389 --> 00:21:08.500
引导，所以如果你碰巧有

00:21:06.159 --> 00:21:11.649
例如H和X索引

00:21:08.500 --> 00:21:13.480
内置产生有关

00:21:11.649 --> 00:21:15.519
组件上的注释类型

00:21:13.480 --> 00:21:18.039
实际上在那里，您可以选择

00:21:15.519 --> 00:21:21.309
在启动提取时解析该索引

00:21:18.039 --> 00:21:22.629
注释信息并将其应用于

00:21:21.309 --> 00:21:25.029
弹簧标注处理

00:21:22.629 --> 00:21:26.559
引导时的基础架构

00:21:25.029 --> 00:21:28.929
春天的应用程序上下文

00:21:26.559 --> 00:21:31.450
利用这些即时注释

00:21:28.929 --> 00:21:35.350
提示，而不必反思

00:21:31.450 --> 00:21:38.110
内省所有课程的详细信息

00:21:35.350 --> 00:21:40.500
你将如何表达

00:21:38.110 --> 00:21:44.080
你自己在这里还有待决定

00:21:40.500 --> 00:21:46.899
我们想允许与

00:21:44.080 --> 00:21:48.669
核心框架中的索引

00:21:46.899 --> 00:21:50.740
观点，我们不会发货

00:21:48.669 --> 00:21:52.779
与索引的现成集成

00:21:50.740 --> 00:21:54.730
与特定的索引安排

00:21:52.779 --> 00:21:57.360
与更多的集成点

00:21:54.730 --> 00:22:01.659
索引特定的应用程序

00:21:57.360 --> 00:22:06.000
安排可以利用，所以

00:22:01.659 --> 00:22:08.139
对外开放的核心机制

00:22:06.000 --> 00:22:10.119
来自外部信息的元数据

00:22:08.139 --> 00:22:12.720
之前要输入的索引

00:22:10.119 --> 00:22:12.720
自举

00:22:13.280 --> 00:22:20.010
我想要的另一个有趣的话题

00:22:16.470 --> 00:22:22.320
讨价还价

00:22:20.010 --> 00:22:25.920
再次参加今天早上我参加的比赛

00:22:22.320 --> 00:22:29.640
一个松散的VM本机映像

00:22:25.920 --> 00:22:33.240
当然与此紧密相关

00:22:29.640 --> 00:22:34.679
我在权衡之前概述的主题

00:22:33.240 --> 00:22:36.809
达到最佳性能的启动时间

00:22:34.679 --> 00:22:40.530
基本上是然后权衡

00:22:36.809 --> 00:22:43.050
减少峰值内存消耗

00:22:40.530 --> 00:22:45.870
性能，这几乎是咆哮

00:22:43.050 --> 00:22:48.330
 VM升降机至少倾斜基板

00:22:45.870 --> 00:22:52.500
虚拟机电梯间距使咆哮的虚拟机

00:22:48.330 --> 00:22:54.960
本机映像机制请记住

00:22:52.500 --> 00:22:57.510
这在所有层面上都是实验性的

00:22:54.960 --> 00:23:01.620
畜牧vm的最新GA版本

00:22:57.510 --> 00:23:03.330
问题19 GA并未实际发货， 

00:23:01.620 --> 00:23:05.250
中的本机图像支持

00:23:03.330 --> 00:23:07.230
生产准备表，你必须做一个

00:23:05.250 --> 00:23:09.990
额外的安装步骤甚至得到它

00:23:07.230 --> 00:23:12.710
它被标记为一种早期

00:23:09.990 --> 00:23:16.350
采纳者，我有点开发预览

00:23:12.710 --> 00:23:18.540
在这一点上的机制，所以我们

00:23:16.350 --> 00:23:22.410
当然是实验性的，但是

00:23:18.540 --> 00:23:24.090
这是我们做的很有趣

00:23:22.410 --> 00:23:26.790
去年做了一些修改

00:23:24.090 --> 00:23:30.210
已经在我们试图避免的地方

00:23:26.790 --> 00:23:33.990
内的不必要的反射点

00:23:30.210 --> 00:23:38.040
像spi级别的代码库

00:23:33.990 --> 00:23:40.710
默认情况下，grol vm非常有能力

00:23:38.040 --> 00:23:43.410
如果您指示，请处理反射

00:23:40.710 --> 00:23:45.600
具有反射反射配置

00:23:43.410 --> 00:23:47.490
与什么的某些配置规则

00:23:45.600 --> 00:23:50.220
婚礼时需要做的

00:23:47.490 --> 00:23:52.140
算一定的反思

00:23:50.220 --> 00:23:54.450
需要的是哪一类

00:23:52.140 --> 00:23:57.080
能够反射

00:23:54.450 --> 00:24:00.540
反射元数据的信息

00:23:57.080 --> 00:24:02.640
但是我们正在努力减少数量

00:24:00.540 --> 00:24:04.800
它需要通过一些元数据

00:24:02.640 --> 00:24:06.570
内部小重构

00:24:04.800 --> 00:24:10.290
试图在

00:24:06.570 --> 00:24:14.370
此时的代码库为5比2 

00:24:10.290 --> 00:24:16.679
仅用原型制作就走了很远

00:24:14.370 --> 00:24:19.530
弹簧组合方式

00:24:16.679 --> 00:24:23.880
基质vm上Angra上5到2的形式

00:24:19.530 --> 00:24:25.679
使用本地图像的数量

00:24:23.880 --> 00:24:27.030
显式配置仍然可以

00:24:25.679 --> 00:24:29.010
现在有点挑战

00:24:27.030 --> 00:24:33.300
只有某些配置

00:24:29.010 --> 00:24:36.210
畜栏和基于弹簧的系统

00:24:33.300 --> 00:24:41.310
确实有效，但请放心

00:24:36.210 --> 00:24:43.230
 Brad VM之间没有冲突

00:24:41.310 --> 00:24:45.140
假设和基本

00:24:43.230 --> 00:24:47.340
粗略的M假设与

00:24:45.140 --> 00:24:48.900
弹簧编程模型元素

00:24:47.340 --> 00:24:50.880
有一点点额外

00:24:48.900 --> 00:24:53.460
进行配置所需的配置

00:24:50.880 --> 00:24:56.520
配置工作，并朝着五

00:24:53.460 --> 00:24:58.440
三个我们正在努力走向一些

00:24:56.520 --> 00:25:00.720
开箱即用的设置

00:24:58.440 --> 00:25:02.610
细节尚未发现，但是

00:25:00.720 --> 00:25:05.480
已经是原型，这是

00:25:02.610 --> 00:25:07.890
我们完全有可能创造

00:25:05.480 --> 00:25:09.630
相应的RAL反射

00:25:07.890 --> 00:25:11.640
部署时的配置

00:25:09.630 --> 00:25:13.560
特殊的弹簧应用，以便

00:25:11.640 --> 00:25:15.240
松鸡VM找到所有元数据

00:25:13.560 --> 00:25:18.300
您的应用程序必需的

00:25:15.240 --> 00:25:20.610
创建本机时的组件

00:25:18.300 --> 00:25:22.860
图片，然后本机图片包含

00:25:20.610 --> 00:25:25.020
所有相关的班级信息

00:25:22.860 --> 00:25:27.030
那框架就在这个原生的

00:25:25.020 --> 00:25:29.580
作为本地映像部署时的映像

00:25:27.030 --> 00:25:32.490
本机映像的一部分可以使用其通常的

00:25:29.580 --> 00:25:36.660
反射API获取元数据

00:25:32.490 --> 00:25:38.550
在运行时需要，所以有一些粗糙

00:25:36.660 --> 00:25:41.340
当然仍然像您一样修补

00:25:38.550 --> 00:25:43.320
期望有我们编译

00:25:41.340 --> 00:25:44.990
目前的状况

00:25:43.320 --> 00:25:47.630
 github链接在那里，这是一个Wiki页面

00:25:44.990 --> 00:25:50.340
我们当前的状态

00:25:47.630 --> 00:25:52.620
了解最新的春天

00:25:50.340 --> 00:25:55.620
框架生成的最新问题

00:25:52.620 --> 00:25:57.270
版本将被维护，因此

00:25:55.620 --> 00:26:00.180
目前有一种反映

00:25:57.270 --> 00:26:04.020
截至本周为止的技术水平

00:26:00.180 --> 00:26:05.910
我们打算更新这个维基页面

00:26:04.020 --> 00:26:07.980
每当有新信息出现时

00:26:05.910 --> 00:26:11.220
每当新的咆哮声发布时

00:26:07.980 --> 00:26:13.470
特别是我们有一条直线

00:26:11.220 --> 00:26:15.090
与Oracle的车库VM团队一起

00:26:13.470 --> 00:26:17.370
有一些非常直接的

00:26:15.090 --> 00:26:20.100
与他们合作很多

00:26:17.370 --> 00:26:22.140
反馈已进入虚拟机

00:26:20.100 --> 00:26:23.750
长期发行的最新版本

00:26:22.140 --> 00:26:26.160
经过的候选人脸

00:26:23.750 --> 00:26:28.380
还有我们的反馈

00:26:26.160 --> 00:26:32.610
将使其成为即将到来的集会， 

00:26:28.380 --> 00:26:34.530
即将发布，因此

00:26:32.610 --> 00:26:36.300
地面VM团队决定宣布其

00:26:34.530 --> 00:26:39.570
支持本机图像作为生产

00:26:36.300 --> 00:26:40.020
我已经期待下一个时间了

00:26:39.570 --> 00:26:40.679
年

00:26:40.020 --> 00:26:42.990
的

00:26:40.679 --> 00:26:46.440
恩，哦，他们很可能会

00:26:42.990 --> 00:26:50.419
从我们这边得到相应的指导

00:26:46.440 --> 00:26:54.600
根据您需要做什么

00:26:50.419 --> 00:26:57.029
部署spring应用程序以丰富

00:26:54.600 --> 00:26:58.889
春天的应用

00:26:57.029 --> 00:27:01.200
适当的元数据，以便本机

00:26:58.889 --> 00:27:05.100
图像工具Corral的本机图像工具

00:27:01.200 --> 00:27:07.409
可以开箱即用地做正确的事情

00:27:05.100 --> 00:27:10.080
某种方式去那里，一些回来， 

00:27:07.409 --> 00:27:13.320
在肉汁m和弹簧之间

00:27:10.080 --> 00:27:16.320
工程组在这里，但当然

00:27:13.320 --> 00:27:18.149
我可能非常非常有吸引力的选择

00:27:16.320 --> 00:27:19.110
本应以为什么开始

00:27:18.149 --> 00:27:20.730
你想这样做

00:27:19.110 --> 00:27:23.129
好吧，您正在构建本机图像

00:27:20.730 --> 00:27:26.100
基本上有很多VM基础架构

00:27:23.129 --> 00:27:28.830
完全砍掉一个本地人

00:27:26.100 --> 00:27:31.679
基于Spring的应用程序的图像可以

00:27:28.830 --> 00:27:34.860
引导程序总共只有一小部分

00:27:31.679 --> 00:27:37.289
第二它可以使用我喜欢的一小部分

00:27:34.860 --> 00:27:39.419
基于完整JVM的内存

00:27:37.289 --> 00:27:41.610
部署基于传统JVM的

00:27:39.419 --> 00:27:44.669
部署将使用，所以您会做

00:27:41.610 --> 00:27:48.360
这主要是非常立即的

00:27:44.669 --> 00:27:51.480
启动时间很短，并且

00:27:48.360 --> 00:27:53.100
你会做的大大减少

00:27:51.480 --> 00:27:55.499
内存消耗将是

00:27:53.100 --> 00:27:57.389
特别是两个原因

00:27:55.499 --> 00:28:00.419
云的短暂过程

00:27:57.389 --> 00:28:02.100
动态启动的部署

00:28:00.419 --> 00:28:05.309
并停止进程

00:28:02.100 --> 00:28:07.940
当然是一个非常有吸引力的选择

00:28:05.309 --> 00:28:12.059
为生产目的而实现

00:28:07.940 --> 00:28:14.759
所以请继续关注

00:28:12.059 --> 00:28:17.610
在那个空间里一些直接的

00:28:14.759 --> 00:28:19.259
修改我们所做的一切

00:28:17.610 --> 00:28:20.820
春季决赛五分之一三和五

00:28:19.259 --> 00:28:22.470
已经有两个了，所以我们正在尝试运送

00:28:20.820 --> 00:28:24.419
我们可以做的任何事情

00:28:22.470 --> 00:28:27.899
开箱即用，但生产水平

00:28:24.419 --> 00:28:30.360
故事很大程度上取决于进一步发展

00:28:27.899 --> 00:28:32.700
 vm发布和生产就绪

00:28:30.360 --> 00:28:36.389
在重力和旁边声明

00:28:32.700 --> 00:28:40.200
本机图像模型非常适合

00:28:36.389 --> 00:28:43.559
有一些影响

00:28:40.200 --> 00:28:46.049
组件模型，只是为了做到这一点

00:28:43.559 --> 00:28:48.269
非常明显的性能调整不是

00:28:46.049 --> 00:28:49.649
那里完全透明所以

00:28:48.269 --> 00:28:51.450
我们只能在

00:28:49.649 --> 00:28:53.590
优化性能的框架

00:28:51.450 --> 00:28:57.160
一定的安排

00:28:53.590 --> 00:28:59.740
会对方式产生一些影响

00:28:57.160 --> 00:29:01.840
您声明可以的组件

00:28:59.740 --> 00:29:03.460
基本上可以帮助框架

00:29:01.840 --> 00:29:06.760
在启动时间方面更好的工作

00:29:03.460 --> 00:29:08.260
通过明确注册

00:29:06.760 --> 00:29:10.630
避免卡扣的组件

00:29:08.260 --> 00:29:14.320
扫描或包含组件索引

00:29:10.630 --> 00:29:17.530
为此，您可以声明为

00:29:14.320 --> 00:29:19.930
尽可能多的豆子在里面懒

00:29:17.530 --> 00:29:22.570
您的应用程序的那部分

00:29:19.930 --> 00:29:25.480
短时间内可能不需要

00:29:22.570 --> 00:29:26.500
出于特定目的启动不是

00:29:25.480 --> 00:29:30.280
我有一个引导

00:29:26.500 --> 00:29:33.550
所以有很多帮助您可以

00:29:30.280 --> 00:29:35.350
在您的组件级别上

00:29:33.550 --> 00:29:37.330
五到两个新的选择

00:29:35.350 --> 00:29:40.060
您可以在配置类上的示例

00:29:37.330 --> 00:29:42.670
将代理光束方法设置为false 

00:29:40.060 --> 00:29:44.800
基本上说没有必要

00:29:42.670 --> 00:29:47.770
创建一个我不会去的CG深度子类

00:29:44.800 --> 00:29:49.900
从一种Epping方法调用

00:29:47.770 --> 00:29:51.880
我没想到的另一个管理方法

00:29:49.900 --> 00:29:53.980
容器来拦截那些调用

00:29:51.880 --> 00:29:56.830
我只是宣布一些无辜， 

00:29:53.980 --> 00:29:59.080
独立的管理方法，无直接权限

00:29:56.830 --> 00:30:01.180
彼此之间的引用这是一个

00:29:59.080 --> 00:30:02.860
更简单的安排，无需

00:30:01.180 --> 00:30:04.980
拦截任何东西，无需创建

00:30:02.860 --> 00:30:07.590
在运行时为我们提供sigillum子类

00:30:04.980 --> 00:30:11.290
特别适用于较大的班级

00:30:07.590 --> 00:30:14.410
这可能会严重影响间接费用

00:30:11.290 --> 00:30:15.610
所多玛的阶级定义

00:30:14.410 --> 00:30:18.250
也使它成为我们的东西

00:30:15.610 --> 00:30:21.310
典型的错误配置类

00:30:18.250 --> 00:30:23.560
春季的 spring boot 部署

00:30:21.310 --> 00:30:24.880
从a5引导到两个安排

00:30:23.560 --> 00:30:26.950
所以我们也在利用这个

00:30:24.880 --> 00:30:29.200
我们自己就是这样

00:30:26.950 --> 00:30:32.290
在语义上与将

00:30:29.200 --> 00:30:34.630
任何非管理员方法

00:30:32.290 --> 00:30:36.280
配置类，所以这完全是

00:30:34.630 --> 00:30:40.030
在我们称这种光之前可能

00:30:36.280 --> 00:30:42.430
配置分析，因此有18种方法

00:30:40.030 --> 00:30:43.960
任何其他组件且没有网

00:30:42.430 --> 00:30:46.720
顶部的配置原型

00:30:43.960 --> 00:30:48.730
行为相同，但为了

00:30:46.720 --> 00:30:50.560
这仍然可以识别为

00:30:48.730 --> 00:30:51.730
配置元素并被发现

00:30:50.560 --> 00:30:54.460
当您寻找每种配置时

00:30:51.730 --> 00:30:56.920
我们决定将其介绍为

00:30:54.460 --> 00:30:59.710
选项作为配置的属性

00:30:56.920 --> 00:31:03.370
自己也沿着

00:30:59.710 --> 00:31:06.370
您可能会选择使用类似的线

00:31:03.370 --> 00:31:07.480
基于接口的代理（如果您设计） 

00:31:06.370 --> 00:31:11.290
您的组件

00:31:07.480 --> 00:31:14.770
通过诸如

00:31:11.290 --> 00:31:17.290
服务接口，无需

00:31:14.770 --> 00:31:19.840
创建目标类代理的框架

00:31:17.290 --> 00:31:21.010
所谓的意思就是说我们

00:31:19.840 --> 00:31:24.100
不需要创建julep 

00:31:21.010 --> 00:31:26.590
子类和启动我们可以使用

00:31:24.100 --> 00:31:29.740
 Chaney Kay自己的旅行反映代理

00:31:26.590 --> 00:31:32.380
设施，只要您的代理人

00:31:29.740 --> 00:31:34.559
只公开接口，这是一种模式

00:31:32.380 --> 00:31:38.380
框架始终具有的操作

00:31:34.559 --> 00:31:39.610
总是伴随着，这变成了

00:31:38.380 --> 00:31:41.230
现在，如果您要

00:31:39.610 --> 00:31:42.610
尝试优化启动时间或

00:31:41.230 --> 00:31:45.700
如果您要设计一个

00:31:42.610 --> 00:31:47.890
本机部署的应用程序

00:31:45.700 --> 00:31:51.760
 RAL VM上的映像，情况要好得多

00:31:47.890 --> 00:31:54.210
在避免CG嘴唇子类中使用

00:31:51.760 --> 00:31:58.690
代替标准的JDK工具

00:31:54.210 --> 00:32:03.429
这样您会更顺畅

00:31:58.690 --> 00:32:06.340
在这些情况下的经验，所以

00:32:03.429 --> 00:32:08.650
线条的三个例子

00:32:06.340 --> 00:32:10.090
我们正在努力尝试

00:32:08.650 --> 00:32:11.799
优化注释过程是

00:32:10.090 --> 00:32:14.970
考虑索引的安排

00:32:11.799 --> 00:32:19.630
整个gravia本机图像主题和

00:32:14.970 --> 00:32:22.299
这也闪耀着

00:32:19.630 --> 00:32:24.190
组件模型是我们的一个方面

00:32:22.299 --> 00:32:26.230
在这里工作，这只会继续

00:32:24.190 --> 00:32:27.669
我敢肯定，还有一些进一步的工作

00:32:26.230 --> 00:32:33.760
在五到三倍的时间内实现

00:32:27.669 --> 00:32:35.919
框架在这里好，最后第四节

00:32:33.760 --> 00:32:40.480
为此目的两天

00:32:35.919 --> 00:32:43.540
演讲的目的是被动的

00:32:40.480 --> 00:32:47.080
当然是Spring Framework的主题五

00:32:43.540 --> 00:32:49.360
两个是我们机会

00:32:47.080 --> 00:32:53.380
在我们的核心上有进一步的迭代

00:32:49.360 --> 00:32:55.570
反应设施，您肯定是

00:32:53.380 --> 00:32:57.370
意识到反应式一直是一个话题

00:32:55.570 --> 00:33:00.460
我们一直在谈论它

00:32:57.370 --> 00:33:02.890
以及这种反应式Web控制器

00:33:00.460 --> 00:33:04.840
几乎是我们的模型

00:33:02.890 --> 00:33:07.090
实际上引入了这么多

00:33:04.840 --> 00:33:08.980
不应该只是一个惊喜

00:33:07.090 --> 00:33:12.480
想象这是一个Web控制器

00:33:08.980 --> 00:33:16.120
与HTTP端点的两个HTTP映射

00:33:12.480 --> 00:33:17.980
其中之一用于斜线用户返回

00:33:16.120 --> 00:33:20.490
用户说这是

00:33:17.980 --> 00:33:20.490
基本上是

00:33:20.650 --> 00:33:25.750
反应性的用户元素流

00:33:23.230 --> 00:33:28.510
您可以将其呈现给呼叫者

00:33:25.750 --> 00:33:31.029
随时准备回应

00:33:28.510 --> 00:33:33.010
为此，另一个有一个

00:33:31.029 --> 00:33:36.970
传入路径变量称为some 

00:33:33.010 --> 00:33:39.460
具有单声道的基础存储库

00:33:36.970 --> 00:33:42.279
用户返回值，基本上是

00:33:39.460 --> 00:33:44.320
一套如何到达的指示

00:33:42.279 --> 00:33:47.289
给定ID的此用户元素

00:33:44.320 --> 00:33:52.270
只要处理堆栈准备就绪

00:33:47.289 --> 00:33:54.190
将其渲染得如此之多

00:33:52.270 --> 00:33:56.770
基本语义这基本上是

00:33:54.190 --> 00:33:59.980
五点状态

00:33:56.770 --> 00:34:02.590
最初介绍的是所谓的湿

00:33:59.980 --> 00:34:05.770
助焊剂这是一个完全独立的网络

00:34:02.590 --> 00:34:09.369
基于高效Web堆栈的堆栈

00:34:05.770 --> 00:34:11.530
在反应堆网Ian上的反应堆上，以及

00:34:09.369 --> 00:34:14.440
下面的nettie网络库

00:34:11.530 --> 00:34:15.010
它覆盖或改编成类似Tomcat或

00:34:14.440 --> 00:34:17.889
码头或

00:34:15.010 --> 00:34:22.599
底层为核心容器为核心

00:34:17.889 --> 00:34:24.070
整个堆栈的HTTP引擎是

00:34:22.599 --> 00:34:26.320
从上到下当然不会阻塞

00:34:24.070 --> 00:34:28.869
底部，因此它不共享任何一个

00:34:26.320 --> 00:34:32.409
 Servlet API中的语义

00:34:28.869 --> 00:34:35.530
与此平行的是我们有弹簧网

00:34:32.409 --> 00:34:38.020
 MVC堆栈仍在运行

00:34:35.530 --> 00:34:40.990
在servlet容器上和在海上

00:34:38.020 --> 00:34:43.179
特别是关于servlet API的假设

00:34:40.990 --> 00:34:45.550
在servlet回调模型中， 

00:34:43.179 --> 00:34:47.649
您收到一个拥有线程的请求

00:34:45.550 --> 00:34:49.629
然后在线程中处理

00:34:47.649 --> 00:34:51.280
要求您写一个回应，然后

00:34:49.629 --> 00:34:53.320
您返回并释放线程

00:34:51.280 --> 00:34:54.790
到游泳池，所以我们有两个平行的网络

00:34:53.320 --> 00:34:57.910
传统上堆叠其中之一

00:34:54.790 --> 00:35:02.290
公民意识强的人之一

00:34:57.910 --> 00:35:05.320
一个反应灵敏的人在这里

00:35:02.290 --> 00:35:08.619
是这样的反应性签名

00:35:05.320 --> 00:35:10.660
像这里的这些映射方法HTTP 

00:35:08.619 --> 00:35:13.960
返回反应式的映射方法

00:35:10.660 --> 00:35:16.710
流发布者，我实际上支持它

00:35:13.960 --> 00:35:20.410
在某种程度上也对Spring MVC产生了影响

00:35:16.710 --> 00:35:22.810
在web flex上，您必须编写所有代码

00:35:20.410 --> 00:35:25.150
使用

00:35:22.810 --> 00:35:27.570
 Spring MVC上的反应性字符串模型

00:35:25.150 --> 00:35:29.950
可能决定宣布其中一些

00:35:27.570 --> 00:35:32.940
终结那些真正真实的

00:35:29.950 --> 00:35:35.280
从反应过程中受益

00:35:32.940 --> 00:35:37.380
阅读流发布者，所以如果

00:35:35.280 --> 00:35:40.890
您将这些端点部署到

00:35:37.380 --> 00:35:43.079
在Servlet堆栈上使用Spring MVC 

00:35:40.890 --> 00:35:44.670
仍然尽力做到最好

00:35:43.079 --> 00:35:46.920
检测到您正在使用反应流

00:35:44.670 --> 00:35:49.950
您要致电的发布者吸引用户

00:35:46.920 --> 00:35:51.630
我们切换servlet，我们切换

00:35:49.950 --> 00:35:53.910
 servlet请求，因为我们从

00:35:51.630 --> 00:35:56.579
服务器容器-这是一种同步模式， 

00:35:53.910 --> 00:35:59.069
那么我们将采用这种异步模式

00:35:56.579 --> 00:36:01.530
 servlet处理反应流

00:35:59.069 --> 00:36:04.050
所以我们试图约束您的反应

00:36:01.530 --> 00:36:07.859
流此流量到servlet异步

00:36:04.050 --> 00:36:10.849
模式，随着元素的实现，我们

00:36:07.859 --> 00:36:13.619
重新唤醒servlet异步

00:36:10.849 --> 00:36:15.180
请求并编写这些元素，以便

00:36:13.619 --> 00:36:16.980
这是一个回调模型， 

00:36:15.180 --> 00:36:19.829
服务器容器提供某种模式

00:36:16.980 --> 00:36:22.950
可以用于

00:36:19.829 --> 00:36:25.560
特别适用于响应元素

00:36:22.950 --> 00:36:27.869
反应流发布有

00:36:25.560 --> 00:36:30.240
限制，但我们确实

00:36:27.869 --> 00:36:33.420
到很远，我们正在努力使

00:36:30.240 --> 00:36:35.910
从技术上讲一切可能

00:36:33.420 --> 00:36:37.770
明智的，所以你甚至可以有一点

00:36:35.910 --> 00:36:40.109
反应流的一点点经验

00:36:37.770 --> 00:36:45.240
如果您在servlet堆栈上使用Spring MVC 

00:36:40.109 --> 00:36:48.060
想要的不仅仅是这个

00:36:45.240 --> 00:36:51.540
新的被动交易管理

00:36:48.060 --> 00:36:53.520
 Spring Framework 52中的模型就是这个

00:36:51.540 --> 00:36:56.550
故意是一个非常相似的例子

00:36:53.520 --> 00:36:58.500
想象我们没有在编码

00:36:56.550 --> 00:37:00.359
控制器，现在我们正在建立一个

00:36:58.500 --> 00:37:02.550
服务等级有点

00:37:00.359 --> 00:37:04.470
间接服务立面这是

00:37:02.550 --> 00:37:06.750
最初非常简单，只是委托

00:37:04.470 --> 00:37:09.810
到基础存储库并添加

00:37:06.750 --> 00:37:12.359
它的交易边界

00:37:09.810 --> 00:37:15.660
使用公共边缘事务

00:37:12.359 --> 00:37:18.660
因此，只需采取类似

00:37:15.660 --> 00:37:21.089
这些在这里用添加标记

00:37:18.660 --> 00:37:22.349
事务性的并具有启用功能

00:37:21.089 --> 00:37:25.410
您的交易管理

00:37:22.349 --> 00:37:27.359
配置，我们将拦截他们

00:37:25.410 --> 00:37:30.030
事务拦截器进入尝试

00:37:27.359 --> 00:37:32.369
拦截这些电话，但是

00:37:30.030 --> 00:37:34.200
现在五到两个的理解

00:37:32.369 --> 00:37:36.690
这些正在返回反应流

00:37:34.200 --> 00:37:38.220
发布它不会天真的尝试

00:37:36.690 --> 00:37:39.990
拦截他们并开始交易

00:37:38.220 --> 00:37:41.790
绑定到称为方法的线程

00:37:39.990 --> 00:37:43.190
然后提交并回滚

00:37:41.790 --> 00:37:45.619
那没有任何意义

00:37:43.190 --> 00:37:47.569
极端发布者这些方法是

00:37:45.619 --> 00:37:49.069
没有实际处理到

00:37:47.569 --> 00:37:52.099
基本处理这些方法

00:37:49.069 --> 00:37:54.920
建立如何到达的管道

00:37:52.099 --> 00:37:56.300
用户反对，所以毫无意义

00:37:54.920 --> 00:37:59.569
试图做任何形式的威胁

00:37:56.300 --> 00:38:01.099
交易，所以我们立即切换

00:37:59.569 --> 00:38:03.290
看返回类型，我们

00:38:01.099 --> 00:38:06.050
立即切换到反应式

00:38:03.290 --> 00:38:07.790
交易经理的经营方式

00:38:06.050 --> 00:38:10.099
正在采取反应流

00:38:07.790 --> 00:38:12.650
发布者采用这种方法

00:38:10.099 --> 00:38:15.140
用交易装饰它

00:38:12.650 --> 00:38:16.819
运算符，这有点

00:38:15.140 --> 00:38:21.670
事务装饰器

00:38:16.819 --> 00:38:23.630
该操作员放置的基础管道

00:38:21.670 --> 00:38:27.260
交易要素

00:38:23.630 --> 00:38:30.020
交易资源和处理

00:38:27.260 --> 00:38:31.970
基础反应堆环境

00:38:30.020 --> 00:38:35.030
总是被变成反应堆

00:38:31.970 --> 00:38:36.829
通量或单声道，我们正在努力使

00:38:35.030 --> 00:38:39.140
使用特定的反应堆功能

00:38:36.829 --> 00:38:42.410
反应堆上下文来存储某些

00:38:39.140 --> 00:38:45.800
基本上与流程一致的元素

00:38:42.410 --> 00:38:47.720
通过反应管道，这样

00:38:45.800 --> 00:38:49.760
交易运营商基本上

00:38:47.720 --> 00:38:51.440
开始交易或实际添加

00:38:49.760 --> 00:38:54.560
并操作它开始交易

00:38:51.440 --> 00:38:56.900
然后这个操作员会存储想法

00:38:54.560 --> 00:38:58.400
基础元数据的基础

00:38:56.900 --> 00:39:01.130
反应堆上下文以及最后

00:38:58.400 --> 00:39:04.670
基于错误的处理

00:39:01.130 --> 00:39:06.800
定期结果成功的信号

00:39:04.670 --> 00:39:09.950
完成将触发回滚

00:39:06.800 --> 00:39:12.460
或提交，因此它做对了

00:39:09.950 --> 00:39:14.810
语义上非常直观

00:39:12.460 --> 00:39:17.060
自动与标准

00:39:14.810 --> 00:39:18.260
交易元素，并在

00:39:17.060 --> 00:39:22.460
邻居事务管理

00:39:18.260 --> 00:39:24.230
活跃的，这需要特定的SPI 

00:39:22.460 --> 00:39:27.970
实施，所以有一个新的SPI 

00:39:24.230 --> 00:39:30.859
称为被动交易经理， 

00:39:27.970 --> 00:39:32.810
这是好旧的替代

00:39:30.859 --> 00:39:35.180
那年春天的平台交易经理

00:39:32.810 --> 00:39:37.760
传统上用于线程绑定

00:39:35.180 --> 00:39:40.099
为交易而努力

00:39:37.760 --> 00:39:44.480
当前有两种实现

00:39:40.099 --> 00:39:47.630
对于我们的两个DBC，我们的关系反应式

00:39:44.480 --> 00:39:51.319
关系数据库连接项目

00:39:47.630 --> 00:39:53.900
对于MongoDB，他们两个都住在

00:39:51.319 --> 00:39:55.819
当前的Spring数据可能是

00:39:53.900 --> 00:39:57.020
在某个时候重新访问，但有一段时间

00:39:55.819 --> 00:40:00.740
两者都是

00:39:57.020 --> 00:40:02.420
亚洲人生活在春季数据中，因此

00:40:00.740 --> 00:40:04.340
选择使用春季格式五

00:40:02.420 --> 00:40:05.900
二，春季数据更多发布

00:40:04.340 --> 00:40:09.140
下雨就可以了

00:40:05.900 --> 00:40:11.630
很快就会有一个

00:40:09.140 --> 00:40:13.910
您可以选择程序安排

00:40:11.630 --> 00:40:16.910
以编程方式与

00:40:13.910 --> 00:40:19.520
交易交易运营商

00:40:16.910 --> 00:40:21.920
这样安排，而不是做

00:40:19.520 --> 00:40:24.140
注释驱动的交易

00:40:21.920 --> 00:40:26.150
您也可以以编程方式撰写

00:40:24.140 --> 00:40:28.130
您的反应式流发布者

00:40:26.150 --> 00:40:29.540
选择用这样的装饰

00:40:28.130 --> 00:40:32.230
交易操作员

00:40:29.540 --> 00:40:34.880
程序等效

00:40:32.230 --> 00:40:38.150
这么好的反应

00:40:34.880 --> 00:40:42.550
交易有很多工作

00:40:38.150 --> 00:40:45.200
在春季消息传递模块中，我们

00:40:42.550 --> 00:40:47.060
基本上采用现有的消息传递

00:40:45.200 --> 00:40:48.740
消息安排

00:40:47.060 --> 00:40:50.720
映射注释和所有

00:40:48.740 --> 00:40:51.620
支持随之而来的基础架构

00:40:50.720 --> 00:40:54.560
用它

00:40:51.620 --> 00:40:56.780
有一个等效的反应

00:40:54.560 --> 00:40:59.300
现在的基础设施

00:40:56.780 --> 00:41:02.330
基于反应流的消息

00:40:59.300 --> 00:41:04.460
主要使用的交互模型

00:41:02.330 --> 00:41:06.980
用我们在插座中提到的

00:41:04.460 --> 00:41:09.440
今天早上的主题演讲是为了给你

00:41:06.980 --> 00:41:12.070
这是编程模型明智的想法

00:41:09.440 --> 00:41:15.410
非常相似的消息映射注释

00:41:12.070 --> 00:41:17.780
在普通弹簧组件内

00:41:15.410 --> 00:41:19.970
模型，然后是不同口味的

00:41:17.780 --> 00:41:22.700
你会用

00:41:19.970 --> 00:41:25.760
传入负载一个简单的负载

00:41:22.700 --> 00:41:29.840
和一个反应式流发布者

00:41:25.760 --> 00:41:30.620
响应出来的

00:41:29.840 --> 00:41:33.500
其中

00:41:30.620 --> 00:41:36.760
然后内置到反应堆中

00:41:33.500 --> 00:41:39.650
运行时，因此完全无阻塞

00:41:36.760 --> 00:41:42.050
高效的处理和非常

00:41:39.650 --> 00:41:44.030
接近我们的基础金属

00:41:42.050 --> 00:41:45.620
套接字，因为我们的套接字本身也是

00:41:44.030 --> 00:41:49.160
反应流空间这是一个非常

00:41:45.620 --> 00:41:51.050
即时比赛当然有办法

00:41:49.160 --> 00:41:53.300
返回元素流和

00:41:51.050 --> 00:41:57.230
还有一种渠道运作模式

00:41:53.300 --> 00:41:58.940
根据我们的插座型号

00:41:57.230 --> 00:42:00.620
你可以有一系列的元素

00:41:58.940 --> 00:42:02.540
基本上是开放式的

00:42:00.620 --> 00:42:05.990
元素进入和开放式

00:42:02.540 --> 00:42:09.020
流出去，您可以注册一个

00:42:05.990 --> 00:42:10.670
返回一个反应式流发布者

00:42:09.020 --> 00:42:12.620
随心所欲

00:42:10.670 --> 00:42:16.010
该渠道要做的

00:42:12.620 --> 00:42:17.180
处理这些元素，所以我们

00:42:16.010 --> 00:42:19.310
我们在春季所做的部分

00:42:17.180 --> 00:42:22.640
框架级别是直接的

00:42:19.310 --> 00:42:24.650
非常自然地融入春天

00:42:22.640 --> 00:42:27.770
消息传递模块放入批注

00:42:24.650 --> 00:42:29.690
基于弹簧的端点模型

00:42:27.770 --> 00:42:32.120
消息非常类似于

00:42:29.690 --> 00:42:34.100
当您使用脚踩时会用

00:42:32.120 --> 00:42:35.780
例如在WebSockets上使用

00:42:34.100 --> 00:42:37.730
相同的编程模型

00:42:35.780 --> 00:42:40.040
当然明确地绑定到

00:42:37.730 --> 00:42:40.910
脚踩协议，但从根本上讲

00:42:40.040 --> 00:42:43.010
相同的结构相同

00:42:40.910 --> 00:42:45.230
配置元素以及任何地方

00:42:43.010 --> 00:42:46.910
可能相同的语义和相同的

00:42:45.230 --> 00:42:52.970
下方的转换基础架构

00:42:46.910 --> 00:42:56.420
涵盖了最后但并非最不重要的

00:42:52.970 --> 00:42:59.480
也是重新申请的计划

00:42:56.420 --> 00:43:01.610
事件是应用程序事件工具

00:42:59.480 --> 00:43:03.320
弹簧应用程序的核心部分

00:43:01.610 --> 00:43:07.520
上下文安排和这个

00:43:03.320 --> 00:43:09.950
传统上很好，因为它只是在

00:43:07.520 --> 00:43:13.340
它的语义是发布事件

00:43:09.950 --> 00:43:14.660
容器本身和

00:43:13.340 --> 00:43:16.610
一些与

00:43:14.660 --> 00:43:18.800
集装箱一些综合

00:43:16.610 --> 00:43:20.420
基础架构可以发布事件

00:43:18.800 --> 00:43:22.180
也可能自己发布活动

00:43:20.420 --> 00:43:25.130
以编程方式通过

00:43:22.180 --> 00:43:26.720
注入应用程序上下文或其

00:43:25.130 --> 00:43:28.610
床上的申请分开发表

00:43:26.720 --> 00:43:30.800
在它上调用发布事件

00:43:28.610 --> 00:43:32.840
具有事件层次结构的标准事件

00:43:30.800 --> 00:43:35.000
这就是我们所谓的有效负载事件

00:43:32.840 --> 00:43:37.970
只需传递

00:43:35.000 --> 00:43:39.560
触发事件背后的有效载荷

00:43:37.970 --> 00:43:41.830
基础设施上有一个SPI 

00:43:39.560 --> 00:43:44.450
多播基础架构如何

00:43:41.830 --> 00:43:46.550
事件将被调度， 

00:43:44.450 --> 00:43:50.060
他们将如何最终进入我们的生活

00:43:46.550 --> 00:43:51.650
呼叫应用程序监听器事件

00:43:50.060 --> 00:43:54.350
侦听器注释基本上是

00:43:51.650 --> 00:43:57.160
惰性和基于注释的形式

00:43:54.350 --> 00:43:59.540
这样的应用程序监听器

00:43:57.160 --> 00:44:03.970
传统上，这只是传入

00:43:59.540 --> 00:44:06.200
事件处理使它的返回值无效，并且

00:44:03.970 --> 00:44:08.000
不管发生什么事，你不是真的

00:44:06.200 --> 00:44:10.490
应该在这里做一些昂贵的工作

00:44:08.000 --> 00:44:12.440
你可以触发一些异步

00:44:10.490 --> 00:44:15.110
如果需要，请从此处手动执行步骤

00:44:12.440 --> 00:44:17.470
基本上只是一个通知

00:44:15.110 --> 00:44:20.990
发生该事件的回调信号

00:44:17.470 --> 00:44:22.819
在标准设置中，此代码是

00:44:20.990 --> 00:44:25.549
实际上要在内部执行

00:44:22.819 --> 00:44:27.949
呼叫者的威胁，无论谁做

00:44:25.549 --> 00:44:29.689
在威胁范围内发布事件

00:44:27.949 --> 00:44:31.849
呼叫发布事件所有听众

00:44:29.689 --> 00:44:34.219
将运行有配置

00:44:31.849 --> 00:44:35.749
拥有威胁池的选项

00:44:34.219 --> 00:44:37.459
在这个后面等等，但是在

00:44:35.749 --> 00:44:40.789
非常标准的安排

00:44:37.459 --> 00:44:43.969
发生了什么，所以对于m3的想法还是

00:44:40.789 --> 00:44:46.519
可能我们的c1仍然是5比2 

00:44:43.969 --> 00:44:48.529
时间表是我们将允许那些

00:44:46.519 --> 00:44:54.140
不要错过不一定的方法

00:44:48.529 --> 00:44:56.989
在此无效或声明退货

00:44:54.140 --> 00:44:58.579
直接发生事件，而是使用反应性

00:44:56.989 --> 00:45:01.130
流，就像我们在其他地方所做的一样

00:44:58.579 --> 00:45:03.799
放置空隙的数量基本上是

00:45:01.130 --> 00:45:05.689
只是完成信号说哦

00:45:03.799 --> 00:45:08.650
实际上正在建造直立的溪流

00:45:05.689 --> 00:45:11.630
出版商整个警察的金额

00:45:08.650 --> 00:45:13.509
整合了这个特定的发布者

00:45:11.630 --> 00:45:16.789
这种特殊的反应流

00:45:13.509 --> 00:45:18.709
管道进入您的管道处理

00:45:16.789 --> 00:45:21.769
所以多播光环会得到一个新的

00:45:18.709 --> 00:45:24.199
操作方式的新认识

00:45:21.769 --> 00:45:25.969
如何处理反应流

00:45:24.199 --> 00:45:28.400
可能来自多个发行商

00:45:25.969 --> 00:45:29.539
听众一听就知道

00:45:28.400 --> 00:45:31.489
如果有几个更有趣

00:45:29.539 --> 00:45:33.319
侦听器返回了反应流

00:45:31.489 --> 00:45:35.509
发布，然后它将做正确的事

00:45:33.319 --> 00:45:39.099
基本上把它们包起来的东西

00:45:35.509 --> 00:45:44.119
使用反应堆处理器有效地

00:45:39.099 --> 00:45:47.239
并在后台执行它们

00:45:44.119 --> 00:45:49.519
异步方式，只需允许

00:45:47.239 --> 00:45:52.549
这些签名和完成

00:45:49.519 --> 00:45:55.880
发出信号或触发事件

00:45:52.549 --> 00:45:58.099
当我们处理完我的活动后

00:45:55.880 --> 00:46:00.079
然后发布者最终会

00:45:58.099 --> 00:46:02.299
生产和我的其他活动

00:46:00.079 --> 00:46:05.569
最终会在幕后发布

00:46:02.299 --> 00:46:08.479
只要准备好，还有

00:46:05.569 --> 00:46:11.209
不仅允许使用反应堆的想法

00:46:08.479 --> 00:46:13.189
对于此反应堆，单型为实型

00:46:11.209 --> 00:46:15.380
带有返回的反应流发布者

00:46:13.189 --> 00:46:18.019
像我们在其他方面一样提供压力支持

00:46:15.380 --> 00:46:20.869
我们也在考虑的地方

00:46:18.019 --> 00:46:23.329
支持可完成的未来作为回报

00:46:20.869 --> 00:46:25.339
值，这当然是java.util 

00:46:23.329 --> 00:46:28.729
 Java的并发可完成功能

00:46:25.339 --> 00:46:31.219
 8您已经可以在Spring MVC中做到这一点

00:46:28.729 --> 00:46:33.469
您可以在春季消息中做到这一点

00:46:31.219 --> 00:46:35.539
模块已经存在，所以我们认为我们可以

00:46:33.469 --> 00:46:36.500
也支持它的应用程序

00:46:35.539 --> 00:46:39.560
大事记

00:46:36.500 --> 00:46:42.770
所以这是正在进行的工作或正在设计中

00:46:39.560 --> 00:46:47.420
 5:00之前要实施的进度

00:46:42.770 --> 00:46:49.250
到我们的z1仍然想增加一些

00:46:47.420 --> 00:46:53.990
应用程序事件工具的香料

00:46:49.250 --> 00:46:56.330
并缩小那里的差距

00:46:53.990 --> 00:46:57.740
自我以来的基础设施

00:46:56.330 --> 00:47:00.890
刚刚提到完全未来

00:46:57.740 --> 00:47:03.410
适应实际上使用适配器模型

00:47:00.890 --> 00:47:06.200
如果您想知道我们如何做到这一点

00:47:03.410 --> 00:47:10.340
全部都放在反应堆中，但是如果你

00:47:06.200 --> 00:47:11.750
返回并且不对我们做出反应

00:47:10.340 --> 00:47:14.540
让我们换一种说法

00:47:11.750 --> 00:47:17.420
向我们返回反应堆模型或通量

00:47:14.540 --> 00:47:20.390
立即将其整合到我们的核心

00:47:17.420 --> 00:47:22.910
如果您直接使用反应性基础架构

00:47:20.390 --> 00:47:25.310
向我们返回其他东西

00:47:22.910 --> 00:47:28.940
 Java flowable或Arch Java Single或

00:47:25.310 --> 00:47:32.210
如果您将一个可完成的未来归还给

00:47:28.940 --> 00:47:34.790
我们那么我们将尝试使他们适应

00:47:32.210 --> 00:47:36.350
对应的反应堆类型

00:47:34.790 --> 00:47:38.570
完整的未来，我们将用

00:47:36.350 --> 00:47:42.560
可流动原型的单声道

00:47:38.570 --> 00:47:43.940
类型，如果您愿意，我们会将其包装在助焊剂中

00:47:42.560 --> 00:47:46.190
返回溪流的平面残骸

00:47:43.940 --> 00:47:49.369
发布者给我们，我们也会装饰

00:47:46.190 --> 00:47:52.880
相应地使用RA反应堆通量

00:47:49.369 --> 00:47:54.800
能够与之完全集成

00:47:52.880 --> 00:47:56.180
基础基础架构

00:47:54.800 --> 00:47:58.580
这几乎发生在

00:47:56.180 --> 00:48:00.440
涵盖了我们所谓的反应式API 

00:47:58.580 --> 00:48:01.910
适配器的利益，以防万一

00:48:00.440 --> 00:48:04.010
想知道自从我们在谈论

00:48:01.910 --> 00:48:05.150
今天早上咳嗽协程，这是

00:48:04.010 --> 00:48:07.220
也是我们整合的方式

00:48:05.150 --> 00:48:10.010
协同例程有点特殊

00:48:07.220 --> 00:48:12.220
联轴器的无功返回类型

00:48:10.010 --> 00:48:15.050
流动型和涂料第三型

00:48:12.220 --> 00:48:18.500
同样理解这一点

00:48:15.050 --> 00:48:21.260
暂时中止作为已用资金的职能

00:48:18.500 --> 00:48:23.650
 Kotlin中的方法自然会返回那些

00:48:21.260 --> 00:48:25.580
基本上就像一个十字架

00:48:23.650 --> 00:48:28.190
在被窝里的秋天

00:48:25.580 --> 00:48:31.609
自动适应反应堆通量

00:48:28.190 --> 00:48:33.410
并按照

00:48:31.609 --> 00:48:35.690
常规无功流发布者

00:48:33.410 --> 00:48:39.220
与整个反应堆集成

00:48:35.690 --> 00:48:39.220
春天来的基础设施

00:48:41.080 --> 00:48:46.910
好了，这就是我今天给你的全部

00:48:44.090 --> 00:48:50.650
在本次会议上，我们正在谈论

00:48:46.910 --> 00:48:53.450
未来速率API设计主题

00:48:50.650 --> 00:48:55.790
批注处理

00:48:53.450 --> 00:48:58.790
希望你甚至不会注意到

00:48:55.790 --> 00:49:01.310
 in in的效率更高

00:48:58.790 --> 00:49:02.780
处理您的注释，但每

00:49:01.310 --> 00:49:04.400
在封面下面加上一个

00:49:02.780 --> 00:49:05.900
相当大的一个

00:49:04.400 --> 00:49:08.810
有被动交易

00:49:05.900 --> 00:49:12.290
特别是针对

00:49:08.810 --> 00:49:14.840
 r2 DBC和MongoDB用于后端

00:49:12.290 --> 00:49:16.760
真正了解一半正确

00:49:14.840 --> 00:49:19.580
交易有适当的交易

00:49:16.760 --> 00:49:22.820
我们可以在存在时附加的语义

00:49:19.580 --> 00:49:24.590
间隔开的反应流

00:49:22.820 --> 00:49:27.520
套接字消息传递集成

00:49:24.590 --> 00:49:29.540
春天消息模块附带

00:49:27.520 --> 00:49:31.640
通用反应式消息传递

00:49:29.540 --> 00:49:34.760
基础设施，特别是我们的插座

00:49:31.640 --> 00:49:36.260
与他们一起的绑定，只是

00:49:34.760 --> 00:49:38.570
在最后一点

00:49:36.260 --> 00:49:40.910
回到耦合协程

00:49:38.570 --> 00:49:43.100
以及它们整合的方式

00:49:40.910 --> 00:49:45.830
与我们的基础反应式API类型

00:49:43.100 --> 00:49:49.910
所以这就是他们很大的地方

00:49:45.830 --> 00:49:52.090
共同的主题连接到故事情节

00:49:49.910 --> 00:49:54.859
今天这个特别会议的

00:49:52.090 --> 00:49:57.830
谢谢您的关注，我当然

00:49:54.859 --> 00:49:59.630
很高兴回答任何问题

00:49:57.830 --> 00:50:01.359
到舞台上我们可以有任何

00:49:59.630 --> 00:50:04.640
关于任何主题的对话

00:50:01.359 --> 00:50:07.490
否则就接我或其他人

00:50:04.640 --> 00:50:10.280
从工程组找到

00:50:07.490 --> 00:50:12.530
我们在走廊上，谢谢你

00:50:10.280 --> 00:50:15.290
注意欣赏节目的其余部分

00:50:12.530 --> 00:50:15.930
 [掌声] 

00:50:15.290 --> 00:50:21.460
您

00:50:15.930 --> 00:50:21.460
 [音乐] 

