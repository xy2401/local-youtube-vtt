WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.900 --> 00:00:08.659
 [音乐] 

00:00:05.470 --> 00:00:10.839
猜我们都准备好了

00:00:08.659 --> 00:00:13.459
从我这边欢迎

00:00:10.839 --> 00:00:16.309
看到你我想说的我不

00:00:13.459 --> 00:00:19.699
真的看到你们这个人太多了

00:00:16.309 --> 00:00:22.099
主题演讲上的照明设备有

00:00:19.699 --> 00:00:24.740
大量适合您的材料

00:00:22.099 --> 00:00:26.359
今天，我想你还没意识到

00:00:24.740 --> 00:00:30.289
因为我们没有真正揭露它

00:00:26.359 --> 00:00:32.539
前面我的工作实际上基本上是

00:00:30.289 --> 00:00:34.969
让你为即将发生的事情热身

00:00:32.539 --> 00:00:39.280
只会详细说明

00:00:34.969 --> 00:00:42.320
分钟，然后再传递给

00:00:39.280 --> 00:00:45.949
其余的船员进行了深入的研究

00:00:42.320 --> 00:00:49.460
像我们的套接字r2 DBC之类的东西的覆盖范围

00:00:45.949 --> 00:00:52.850
和棉花遮盖住东西，但让我们开始吧

00:00:49.460 --> 00:00:56.649
对路线图有一些想法

00:00:52.850 --> 00:01:00.140
关于我们选择的主题

00:00:56.649 --> 00:01:05.930
不仅关注45-在时间范围内，而且

00:01:00.140 --> 00:01:07.940
也是到2020年，我们才是正确的

00:01:05.930 --> 00:01:10.880
春季5-春季

00:01:07.940 --> 00:01:13.310
家庭5-达到里程碑阶段，所以我们

00:01:10.880 --> 00:01:15.230
朝着第三个里程碑努力

00:01:13.310 --> 00:01:17.780
 RC阶段发布候选对象是

00:01:15.230 --> 00:01:21.020
即将到来，我们正在努力

00:01:17.780 --> 00:01:26.240
高清日期为7月31日，我们的意思是

00:01:21.020 --> 00:01:28.490
希望那天我们真的有

00:01:26.240 --> 00:01:30.740
在此之前适当的我们的C相

00:01:28.490 --> 00:01:34.040
我们真的有点时间

00:01:30.740 --> 00:01:38.210
点和春天家庭52有很多

00:01:34.040 --> 00:01:42.200
基本上在开发中的东西

00:01:38.210 --> 00:01:44.230
当你沿着几个主题的那一刻

00:01:42.200 --> 00:01:46.790
可能知道我们开始非常

00:01:44.230 --> 00:01:49.520
主题尤其受

00:01:46.790 --> 00:01:52.820
 Spring Fair Mach 5 5-发布

00:01:49.520 --> 00:01:55.970
反应主题功能API设计

00:01:52.820 --> 00:01:59.690
整个Java 8 +空间衬里就这些了

00:01:55.970 --> 00:02:05.570
主题驱动的拥抱JDK 9和

00:01:59.690 --> 00:02:08.019
现在是春季电影5的11-- 

00:02:05.570 --> 00:02:11.420
专注于启动优化

00:02:08.019 --> 00:02:13.310
这基本上是一个非常多方面的

00:02:11.420 --> 00:02:17.209
那里的努力说

00:02:13.310 --> 00:02:19.340
很多旋钮，我们可以转动很多

00:02:17.209 --> 00:02:22.160
我们可以做很多事的事情

00:02:19.340 --> 00:02:24.950
我们可以潜入改进的优化

00:02:22.160 --> 00:02:27.680
启动时间，如果那是你的时间

00:02:24.950 --> 00:02:29.810
尝试根据

00:02:27.680 --> 00:02:32.950
您的部署方案可能或

00:02:29.810 --> 00:02:35.930
如果重要的话可能并不重要

00:02:32.950 --> 00:02:38.470
那么我们有很多步骤

00:02:35.930 --> 00:02:41.630
五到两个，让你

00:02:38.470 --> 00:02:44.120
基本上使初始设置运行

00:02:41.630 --> 00:02:47.600
比之前进行的更快

00:02:44.120 --> 00:02:50.299
这将继续到五个

00:02:47.600 --> 00:02:53.780
到三个时代

00:02:50.299 --> 00:02:56.750
与此相关的我们重新审视了我们的

00:02:53.780 --> 00:02:58.430
注释处理注释是

00:02:56.750 --> 00:03:00.860
实际上不是核心的核心

00:02:58.430 --> 00:03:02.930
 Spring框架中的容器

00:03:00.860 --> 00:03:05.090
一般而言，当然

00:03:02.930 --> 00:03:08.150
每天的日常使用模型

00:03:05.090 --> 00:03:09.970
主要用法模型在那里注释

00:03:08.150 --> 00:03:12.620
加工起着非常重要的作用

00:03:09.970 --> 00:03:14.510
它以多种形式出现

00:03:12.620 --> 00:03:17.359
这是我们自省的注解

00:03:14.510 --> 00:03:19.609
当您将我们送往课程路径时

00:03:17.359 --> 00:03:21.829
用于在

00:03:19.609 --> 00:03:23.690
我们需要有效地进行组件扫描

00:03:21.829 --> 00:03:25.370
内省注释以找出

00:03:23.690 --> 00:03:28.010
您要我们注册哪些组件

00:03:25.370 --> 00:03:29.420
但后来也

00:03:28.010 --> 00:03:31.880
春天的注释过程需要

00:03:29.420 --> 00:03:33.500
找出他们必须加入

00:03:31.880 --> 00:03:36.859
有一些自动接线要做

00:03:33.500 --> 00:03:38.959
一些交易声明来做我们

00:03:36.859 --> 00:03:40.790
批发再造

00:03:38.959 --> 00:03:42.859
合并注释的新实现

00:03:40.790 --> 00:03:44.510
用我们的注释数学处理

00:03:42.859 --> 00:03:47.060
您可以覆盖所有注释的注释

00:03:44.510 --> 00:03:51.530
该业务的新合并

00:03:47.060 --> 00:03:54.079
注释API和大量的挂钩

00:03:51.530 --> 00:03:56.750
优化我要去的过程

00:03:54.079 --> 00:04:00.069
在我的春天，从

00:03:56.750 --> 00:04:00.069
伙伴今天下午再谈

00:04:00.819 --> 00:04:06.049
有新的领域正在覆盖

00:04:03.709 --> 00:04:08.420
在被动交易中

00:04:06.049 --> 00:04:10.310
交易管理空间这是一个

00:04:08.420 --> 00:04:12.200
在反应性方面有点差距

00:04:10.310 --> 00:04:15.500
做很多事情之前的故事

00:04:12.200 --> 00:04:17.900
在其他部分的湿通量中

00:04:15.500 --> 00:04:20.239
框架，但交易如何

00:04:17.900 --> 00:04:22.970
非常普遍的问题，截至春季

00:04:20.239 --> 00:04:24.979
电影五到二的交易

00:04:22.970 --> 00:04:26.660
的管理处理标准

00:04:24.979 --> 00:04:30.740
出生交易管理

00:04:26.660 --> 00:04:33.080
模仿现在可以检测到情况

00:04:30.740 --> 00:04:34.820
你正在尝试装饰一个

00:04:33.080 --> 00:04:35.590
返回反应流的方法

00:04:34.820 --> 00:04:39.110
发布者

00:04:35.590 --> 00:04:42.680
我们现在正在进入新的代码路径

00:04:39.110 --> 00:04:44.900
如果有一家出版商来装饰

00:04:42.680 --> 00:04:48.770
那么我们就不会在本地进行任何威胁

00:04:44.900 --> 00:04:50.540
我们不从事我们的业务

00:04:48.770 --> 00:04:52.820
常规平台交易经理

00:04:50.540 --> 00:04:55.790
操作模式，我们进入一个独特的

00:04:52.820 --> 00:04:58.010
基于新反应式的新代码路径

00:04:55.790 --> 00:04:59.930
我们知道的交易经理SPI 

00:04:58.010 --> 00:05:02.240
我们正在做什么

00:04:59.930 --> 00:05:04.220
交易运营商连接到

00:05:02.240 --> 00:05:06.950
您的反应式的特定后端

00:05:04.220 --> 00:05:08.840
流发布者以及您获得的收获

00:05:06.950 --> 00:05:11.150
回电的实际上是这个

00:05:08.840 --> 00:05:12.860
装饰版本的发布者

00:05:11.150 --> 00:05:15.530
我们为您准备了，已经有

00:05:12.860 --> 00:05:18.590
后端在春天基准面或释放

00:05:15.530 --> 00:05:21.200
培训RT DBC和MongoDB 

00:05:18.590 --> 00:05:26.810
实施此被动交易

00:05:21.200 --> 00:05:29.030
管理SPI这是一个全新的领域

00:05:26.810 --> 00:05:31.010
就我们而言

00:05:29.030 --> 00:05:34.220
套接字，这将是一个主题

00:05:31.010 --> 00:05:37.280
以后我就不告诉你了

00:05:34.220 --> 00:05:39.230
关于它，这本质上是一个新的

00:05:37.280 --> 00:05:42.080
您可能想要的那种应用程序

00:05:39.230 --> 00:05:45.890
从春天的角度来看

00:05:42.080 --> 00:05:48.680
基于我们的消息传递应用程序

00:05:45.890 --> 00:05:50.510
套接字机制，这是一个API 

00:05:48.680 --> 00:05:52.820
在开发中

00:05:50.510 --> 00:05:54.980
与多家公司的合作

00:05:52.820 --> 00:05:59.210
在那里，我们非常参与，就像

00:05:54.980 --> 00:06:02.150
 RT DBC的努力我们的套接字是

00:05:59.210 --> 00:06:03.680
其他被动合作

00:06:02.150 --> 00:06:09.650
您将听到很多有关

00:06:03.680 --> 00:06:10.940
后来在新的领域

00:06:09.650 --> 00:06:13.580
覆盖在谷轮

00:06:10.940 --> 00:06:15.020
风景我们有切工支持

00:06:13.580 --> 00:06:18.350
协程来了，这将

00:06:15.020 --> 00:06:20.390
像

00:06:18.350 --> 00:06:22.610
到此结束半小时

00:06:20.390 --> 00:06:27.169
主题演讲我们将继续

00:06:22.610 --> 00:06:31.360
这部分Kotlin通常是关键

00:06:27.169 --> 00:06:34.970
我们的主题在春季面料5 

00:06:31.360 --> 00:06:36.770
项目的产生，我们

00:06:34.970 --> 00:06:38.240
非常渴望获得最新的

00:06:36.770 --> 00:06:39.070
耦合复制一二最大

00:06:38.240 --> 00:06:40.900
三芯

00:06:39.070 --> 00:06:44.730
意味着现在脱离实验

00:06:40.900 --> 00:06:48.640
进入生产

00:06:44.730 --> 00:06:50.350
准备就绪，这基本上是

00:06:48.640 --> 00:06:52.120
我们正在适应我们的机制

00:06:50.350 --> 00:06:54.700
下方的反应性基础设施

00:06:52.120 --> 00:06:56.350
涵盖，所以从我们的角度来看， 

00:06:54.700 --> 00:07:02.320
关于它的使用模型

00:06:56.350 --> 00:07:04.570
可能是应用程序设计问题

00:07:02.320 --> 00:07:07.590
通过使用协程很好地解决

00:07:04.570 --> 00:07:10.900
 Kotlin翻译成相同的基础

00:07:07.590 --> 00:07:14.290
基础设施，这是一种用法

00:07:10.900 --> 00:07:15.820
通用的另一种使用模式

00:07:14.290 --> 00:07:19.480
我们所拥有的基础设施

00:07:15.820 --> 00:07:22.210
来自阿格拉500的春天已经过去了

00:07:19.480 --> 00:07:25.690
但同样重要的是，我们完成了

00:07:22.210 --> 00:07:27.340
在我们的网络中紧密地差距

00:07:25.690 --> 00:07:30.640
 Web框架中的架构

00:07:27.340 --> 00:07:33.340
产品有一个功能版本

00:07:30.640 --> 00:07:35.260
自5-2以来的Webb流量

00:07:33.340 --> 00:07:38.670
现在需要五到两天

00:07:35.260 --> 00:07:41.080
基于Servlet的等效版本

00:07:38.670 --> 00:07:43.540
被称为Web MVC事件的是

00:07:41.080 --> 00:07:47.580
本质上与功能相同

00:07:43.540 --> 00:07:50.020
传统卷筒纸MVC的湿通量

00:07:47.580 --> 00:07:53.350
基于调查的基础设施

00:07:50.020 --> 00:07:55.690
 API，因此基于注释

00:07:53.350 --> 00:07:59.500
以及两者的功能变体

00:07:55.690 --> 00:08:02.890
这些网页堆栈现在只需要一点

00:07:59.500 --> 00:08:04.420
一点点的前景将是

00:08:02.890 --> 00:08:08.040
五四三迭代的春天

00:08:04.420 --> 00:08:10.510
这已经在计划中了

00:08:08.040 --> 00:08:14.620
即将到明年第二季度

00:08:10.510 --> 00:08:18.250
这样的迭代与ev 1和v 

00:08:14.620 --> 00:08:20.320
 2次迭代有一些明显的

00:08:18.250 --> 00:08:22.510
我们要做的事情

00:08:20.320 --> 00:08:25.840
支持最新的JDK或最新的

00:08:22.510 --> 00:08:30.010
当时的阴暗案件13 

00:08:25.840 --> 00:08:31.240
 9月，然后是3月14日，然后是15日

00:08:30.010 --> 00:08:33.520
九月，所以我们要做

00:08:31.240 --> 00:08:35.469
我们可以做到的所有最新信息

00:08:33.520 --> 00:08:38.950
成为数据上的好公民

00:08:35.469 --> 00:08:41.950
稳定的情况下，我们有一个合作的F 

00:08:38.950 --> 00:08:45.370
像

00:08:41.950 --> 00:08:47.650
 Google和有关代码的聊天头脑

00:08:45.370 --> 00:08:49.510
分析注释，这是非常

00:08:47.650 --> 00:08:51.920
与我们在春季所做的有关

00:08:49.510 --> 00:08:54.319
模拟FIFO引入可延展性

00:08:51.920 --> 00:08:56.540
听不清模型的另一种能力

00:08:54.319 --> 00:09:00.410
装饰无效安全性和API 

00:08:56.540 --> 00:09:05.089
在我们这端设计这些是正确的

00:09:00.410 --> 00:09:07.339
定义明确的注释取代了

00:09:05.089 --> 00:09:10.489
追赶者305安排一些工具

00:09:07.339 --> 00:09:12.739
用于检测NAT能力声明

00:09:10.489 --> 00:09:14.929
在API中，这是一个协作

00:09:12.739 --> 00:09:17.629
我们参与的项目意味着

00:09:14.929 --> 00:09:22.850
在以下情况下采用这些新的元注释

00:09:17.629 --> 00:09:26.089
我们可以在5.3时间范围内

00:09:22.850 --> 00:09:28.999
值得的话题，我只是说一个

00:09:26.089 --> 00:09:31.669
整个会话轻松地咆哮VM本机

00:09:28.999 --> 00:09:35.929
基板vm上的图像投影

00:09:31.669 --> 00:09:40.549
与之兼容的努力

00:09:35.929 --> 00:09:44.149
本地图像正在进行中，我们已经

00:09:40.549 --> 00:09:47.359
我们有非常精致的原型

00:09:44.149 --> 00:09:50.709
非常参与oracle地面vm 

00:09:47.359 --> 00:09:54.350
团队，所以我们很有趣

00:09:50.709 --> 00:09:57.319
也进行各种合作

00:09:54.350 --> 00:09:59.419
在一定条件下准备春天

00:09:57.319 --> 00:10:01.629
建立弹簧应用程序的条件

00:09:59.419 --> 00:10:04.549
可以部署为本地映像

00:10:01.629 --> 00:10:07.160
自从原始图像建模Ralphie 

00:10:04.549 --> 00:10:10.369
 M仍是开发人员预览版

00:10:07.160 --> 00:10:12.649
早期采用者目前的虚拟机19 

00:10:10.369 --> 00:10:15.499
 GA不会以生产形式发货

00:10:12.649 --> 00:10:17.869
这将是一个话题

00:10:15.499 --> 00:10:19.699
接下来将要和我们在一起5到3 

00:10:17.869 --> 00:10:22.160
一年，我们将竭尽所能

00:10:19.699 --> 00:10:24.739
让您设计基于弹簧的

00:10:22.160 --> 00:10:27.649
部署到本地的应用程序

00:10:24.739 --> 00:10:30.919
图片，我们将要看到

00:10:27.649 --> 00:10:33.169
技术挑战依然存在，但是

00:10:30.919 --> 00:10:35.089
胆怯的地面意愿

00:10:33.169 --> 00:10:37.669
 Oracle与我们合作并解决

00:10:35.089 --> 00:10:39.709
那种咆哮的缺点

00:10:37.669 --> 00:10:42.499
典型的现代企业应用

00:10:39.709 --> 00:10:48.350
我相信我们是在春天建造的

00:10:42.499 --> 00:10:49.879
要去某个地方，所以有一个新的

00:10:48.350 --> 00:10:51.499
即将出现的版本

00:10:49.879 --> 00:10:54.949
正在等待我们要选择

00:10:51.499 --> 00:10:56.899
在5至3个时间范围内或m6 

00:10:54.949 --> 00:11:00.259
几年来的第一个主要版本

00:10:56.899 --> 00:11:01.939
我们总是渴望拥抱最新

00:11:00.259 --> 00:11:04.009
和最大的公开

00:11:01.939 --> 00:11:05.580
源生态系统

00:11:04.009 --> 00:11:07.560
我们所有人都有一扇门

00:11:05.580 --> 00:11:10.050
等待新的Jackson发行

00:11:07.560 --> 00:11:15.330
它的价值，还有其他几个

00:11:10.050 --> 00:11:17.280
有代码留置权1.4，我们接近

00:11:15.330 --> 00:11:20.010
与联队的互动

00:11:17.280 --> 00:11:22.830
总是想领先于

00:11:20.010 --> 00:11:24.570
了解Kotlin即将发生的变化

00:11:22.830 --> 00:11:27.690
所以五四三的时间框架应该

00:11:24.570 --> 00:11:29.130
为此工作很好，那是另一个

00:11:27.690 --> 00:11:31.170
我们急切等待的一块

00:11:29.130 --> 00:11:35.460
 JD十最佳版本

00:11:31.170 --> 00:11:37.170
的契迪无疑仍然是，但在五个

00:11:35.460 --> 00:11:41.460
我们要选择的三个时间范围

00:11:37.170 --> 00:11:42.990
很快就出现了

00:11:41.460 --> 00:11:44.160
我们不会处理的几件事

00:11:42.990 --> 00:11:47.190
那就是我要离开你的

00:11:44.160 --> 00:11:49.710
这里的战略主题不是

00:11:47.190 --> 00:11:52.290
可能达到五倍，但它们是

00:11:49.710 --> 00:11:54.230
在我们的心中，所以不要指望

00:11:52.290 --> 00:11:58.050
从五个东西释放

00:11:54.230 --> 00:12:00.300
把那些带到你的桌子上，但休息

00:11:58.050 --> 00:12:01.830
今天放心，他们在我们的路线图上

00:12:00.300 --> 00:12:04.980
他们在我们的脑海中

00:12:01.830 --> 00:12:08.700
试图预测什么样的影响

00:12:04.980 --> 00:12:11.610
他们将不得不坚持我们的路线图

00:12:08.700 --> 00:12:13.410
十一基线不是全部

00:12:11.610 --> 00:12:17.280
迅速从mcfife反弹

00:12:13.410 --> 00:12:19.290
仍基于JDK 8可以在JDK中使用

00:12:17.280 --> 00:12:21.780
 11和更新，但不会

00:12:19.290 --> 00:12:24.330
需要3d键十一这只会

00:12:21.780 --> 00:12:28.530
即将发布的春天

00:12:24.330 --> 00:12:32.160
我们没有的六种电影

00:12:28.530 --> 00:12:34.230
立即带任何东西的意图

00:12:32.160 --> 00:12:37.830
模块表上的新内容

00:12:34.230 --> 00:12:43.020
 Java 9引入的系统

00:12:37.830 --> 00:12:44.940
可以使用世界弹簧

00:12:43.020 --> 00:12:47.280
使用模块的定制架构

00:12:44.940 --> 00:12:49.830
系统已经存在，但没有没有可能

00:12:47.280 --> 00:12:52.380
我们即将来的盒子故事

00:12:49.830 --> 00:12:53.970
按照目前的计划5倍

00:12:52.380 --> 00:12:58.020
稍后将重新讨论

00:12:53.970 --> 00:12:59.130
要点和我们在一起的另一个话题

00:12:58.020 --> 00:13:02.340
已经有几年了

00:12:59.130 --> 00:13:04.290
雅加达EE前者的转让

00:13:02.340 --> 00:13:06.900
 Eclipse的Java EE规范

00:13:04.290 --> 00:13:09.930
基金会及其任何新修订

00:13:06.900 --> 00:13:13.280
 API可能在新名称空间中

00:13:09.930 --> 00:13:15.480
新的Jakarta命名空间，而不是X的G 

00:13:13.280 --> 00:13:17.260
这是我们非常关注的话题

00:13:15.480 --> 00:13:20.560
跟随但

00:13:17.260 --> 00:13:22.270
预计不会改变安排

00:13:20.560 --> 00:13:24.820
对于春季ik 5x，我们将

00:13:22.270 --> 00:13:28.570
保留基于Java EE的Java X空间

00:13:24.820 --> 00:13:32.710
 API的8级，以便用于OJ pa 

00:13:28.570 --> 00:13:34.840
到DOE验证两个bean 

00:13:32.710 --> 00:13:36.970
 5倍的故事没有变化，但

00:13:34.840 --> 00:13:38.500
某些时候会发生什么

00:13:36.970 --> 00:13:41.740
当有新的基础设施时

00:13:38.500 --> 00:13:44.800
从日食中捡起

00:13:41.740 --> 00:13:47.890
地基或现身现身

00:13:44.800 --> 00:13:53.950
以那些Jakarta EE api作为

00:13:47.890 --> 00:13:56.440
主要互动模型和最后但

00:13:53.950 --> 00:14:02.130
至少有项目织机战士

00:13:56.440 --> 00:14:04.930
绝对是JDK中的一个研究项目

00:14:02.130 --> 00:14:06.520
这可能是许多游戏规则的改变者

00:14:04.930 --> 00:14:08.470
就架构而言

00:14:06.520 --> 00:14:11.020
我们可以建立和那些人的效率

00:14:08.470 --> 00:14:13.420
架构（如果您使用的是

00:14:11.020 --> 00:14:15.190
命令式编程风格很好

00:14:13.420 --> 00:14:17.650
非常关注正在发生的事情

00:14:15.190 --> 00:14:20.800
在那里，但它不会来到

00:14:17.650 --> 00:14:23.100
 JDK，以便我们可以随时使用它

00:14:20.800 --> 00:14:25.600
很快我们要去等待的地方

00:14:23.100 --> 00:14:27.640
在这里实现的东西

00:14:25.600 --> 00:14:30.250
以后的春天去捡

00:14:27.640 --> 00:14:33.070
肯定的世代时间

00:14:30.250 --> 00:14:35.170
但是首先我们要去

00:14:33.070 --> 00:14:39.220
为您提供5-2 GA的春季规格

00:14:35.170 --> 00:14:41.800
今年七月，所以我希望

00:14:39.220 --> 00:14:43.630
有很多好处可以让你

00:14:41.800 --> 00:14:45.640
那一代的框架和

00:14:43.630 --> 00:14:48.850
相应的弹簧靴到

00:14:45.640 --> 00:14:51.010
释放，所以我希望你在希望你在

00:14:48.850 --> 00:14:54.250
同意我们选择的重点

00:14:51.010 --> 00:14:56.410
为这一代人而设

00:14:54.250 --> 00:14:58.870
我们现在将更深入

00:14:56.410 --> 00:15:00.970
反应性故事和

00:14:58.870 --> 00:15:02.530
下两个隔离的故事

00:15:00.970 --> 00:15:05.080
主题演讲的各个部分，让我

00:15:02.530 --> 00:15:07.620
欢迎我们来信并弯曲到

00:15:05.080 --> 00:15:07.620
请登台

00:15:12.850 --> 00:15:25.889
正确的舞台是你的，谢谢

00:15:23.559 --> 00:15:25.889
我们的确是

00:15:26.039 --> 00:15:31.809
快速笔记本电脑滑到这里或切换到这里，所以

00:15:28.779 --> 00:15:34.059
我们可以为大家做一些演示

00:15:31.809 --> 00:15:36.160
而我们正在照顾这是

00:15:34.059 --> 00:15:39.239
实际上我第一次去巴塞罗那

00:15:36.160 --> 00:15:41.499
我一直都知道这很棒

00:15:39.239 --> 00:15:43.989
观光旅游的城市

00:15:41.499 --> 00:15:45.879
那样，但是我是一个伟大的自行车手，我

00:15:43.989 --> 00:15:47.829
我真的很惊讶

00:15:45.879 --> 00:15:48.879
从旧金山到这里的路

00:15:47.829 --> 00:15:50.979
最近三天我出去了

00:15:48.879 --> 00:15:52.389
骑自行车，你一直在

00:15:50.979 --> 00:15:54.100
这里周围的山脉是

00:15:52.389 --> 00:15:56.350
绝对让所有小城镇惊艳

00:15:54.100 --> 00:15:58.059
所有的大山，如果你是

00:15:56.350 --> 00:16:03.369
也是我强烈推荐的自行车手

00:15:58.059 --> 00:16:13.299
巴塞罗那是去的目的地

00:16:03.369 --> 00:16:14.679
幻灯片在那里，我们走的很好，谢谢

00:16:13.299 --> 00:16:17.619
大家

00:16:14.679 --> 00:16:19.959
正如Juergen向我们介绍的那样，我叫Ben 

00:16:17.619 --> 00:16:22.539
 Hale我是Cloud Foundry的负责人

00:16:19.959 --> 00:16:25.149
 Java经验，所以我在Java上运行所有Java 

00:16:22.539 --> 00:16:27.419
关键的云平台，和我一起

00:16:25.149 --> 00:16:30.189
有Violetta和Violetta是

00:16:27.419 --> 00:16:31.569
反应堆核心小组成员和负责人

00:16:30.189 --> 00:16:33.879
反应堆网络连接，这将要发生

00:16:31.569 --> 00:16:37.720
在几秒钟内重要地上升

00:16:33.879 --> 00:16:41.350
因此，如果我们回顾一下过去

00:16:37.720 --> 00:16:43.209
三年左右的春季队有

00:16:41.350 --> 00:16:45.579
来找你说反应

00:16:43.209 --> 00:16:47.319
反应性权利，像三年

00:16:45.579 --> 00:16:49.449
之前我们说有一个东西叫做

00:16:47.319 --> 00:16:51.159
我们有点重启的项目反应堆

00:16:49.449 --> 00:16:52.629
来自另一个项目，我们说这是

00:16:51.159 --> 00:16:54.519
我们要组成一个团队的真实事物

00:16:52.629 --> 00:16:57.100
在我们身上会消耗很多精力

00:16:54.519 --> 00:16:59.259
大概两年前

00:16:57.100 --> 00:17:01.539
一年前让我们这样说

00:16:59.259 --> 00:17:04.419
春季团队带来了春季韦伯助焊剂

00:17:01.539 --> 00:17:07.209
你知道这是一种反应方式

00:17:04.419 --> 00:17:08.949
编写Web应用程序就可以了

00:17:07.209 --> 00:17:11.139
我要在舞台上与之交谈

00:17:08.949 --> 00:17:13.629
您的反应性要高一些，但是

00:17:11.139 --> 00:17:15.519
问题是为什么我们所有人都有

00:17:13.629 --> 00:17:17.860
曾经是Java开发人员

00:17:15.519 --> 00:17:20.740
我几年来一直15 16 

00:17:17.860 --> 00:17:24.390
多年以来为什么突然出现

00:17:20.740 --> 00:17:27.059
专注于反应性

00:17:24.390 --> 00:17:29.700
答案是春季队

00:17:27.059 --> 00:17:31.830
一般而言，实际上是更广泛的Java 

00:17:29.700 --> 00:17:34.020
此时的生态系统已经确定

00:17:31.830 --> 00:17:36.500
下一个反应式编程

00:17:34.020 --> 00:17:38.640
高效率的前沿

00:17:36.500 --> 00:17:40.380
应用程序，这是

00:17:38.640 --> 00:17:42.630
许多年来我们并没有真正

00:17:40.380 --> 00:17:45.510
非常关心效率是

00:17:42.630 --> 00:17:47.190
好吧，我有一个数据中心，我打了一场战争

00:17:45.510 --> 00:17:49.320
在墙上跑来跑去的人

00:17:47.190 --> 00:17:50.940
 tomcat，那个人需要扩展

00:17:49.320 --> 00:17:52.980
 Tomcat我没有很多

00:17:50.940 --> 00:17:54.990
可见性，但很多新

00:17:52.980 --> 00:17:56.580
某种云架构正在运行

00:17:54.990 --> 00:17:58.740
还有更多的应用

00:17:56.580 --> 00:18:00.450
水平扩展这些应用程序

00:17:58.740 --> 00:18:03.419
更重要的是，我们可能

00:18:00.450 --> 00:18:05.490
为此付出了非常大的账单

00:18:03.419 --> 00:18:06.750
现在突然有了效率

00:18:05.490 --> 00:18:09.960
开始回到我们身边

00:18:06.750 --> 00:18:11.250
所以基本的非阻塞性

00:18:09.960 --> 00:18:14.490
并且可以选择异步

00:18:11.250 --> 00:18:16.890
行为可以更好地利用

00:18:14.490 --> 00:18:19.200
我们获得的资源或我们

00:18:16.890 --> 00:18:21.630
在那里付款，而不是

00:18:19.200 --> 00:18:23.910
在您可能拥有的应用程序中

00:18:21.630 --> 00:18:25.230
使用200个线程运行Tomcat 

00:18:23.910 --> 00:18:26.940
这意味着你只能得到200 

00:18:25.230 --> 00:18:28.640
连接，所以您不得不进行排序

00:18:26.940 --> 00:18:31.110
水平扩展您的应用程序

00:18:28.640 --> 00:18:33.960
所以你有10个实例或15个实例

00:18:31.110 --> 00:18:36.570
个实例或20个实例，但全部

00:18:33.960 --> 00:18:38.010
这些实例就像10％或15％的CPU 

00:18:36.570 --> 00:18:39.600
因为你真的是连接受限

00:18:38.010 --> 00:18:42.059
反应式编程的想法

00:18:39.600 --> 00:18:44.100
像网络流量这样的东西现在

00:18:42.059 --> 00:18:45.720
突然我们可以支持成千上万

00:18:44.100 --> 00:18:47.490
连接，但我们只会

00:18:45.720 --> 00:18:49.919
根据物理线程数执行此操作

00:18:47.490 --> 00:18:51.720
现在突然可供我们使用

00:18:49.919 --> 00:18:54.840
完全合理的开始

00:18:51.720 --> 00:18:56.549
在100％CPU上运行我们的实例

00:18:54.840 --> 00:18:59.100
因为当我们等待的时候

00:18:56.549 --> 00:19:00.750
没有阻止，但另一个真的

00:18:59.100 --> 00:19:02.460
反应性带给我们的关键

00:19:00.750 --> 00:19:04.530
不仅仅是这种非阻塞

00:19:02.460 --> 00:19:07.679
异步行为是事实

00:19:04.530 --> 00:19:09.870
我们现在可以逐尾驯服尾巴延迟

00:19:07.679 --> 00:19:11.220
延迟我的意思是我们很多时候

00:19:09.870 --> 00:19:14.400
我们来看一下我们的指标

00:19:11.220 --> 00:19:16.559
看到我的百分之七十五是什么

00:19:14.400 --> 00:19:18.600
我的百分之九十是我的百分之九十九

00:19:16.559 --> 00:19:21.270
百分位数，我们响应速度有多快

00:19:18.600 --> 00:19:24.240
在最快的情况下

00:19:21.270 --> 00:19:26.370
客户，但实际上您会

00:19:24.240 --> 00:19:28.530
那种大规模的云

00:19:26.370 --> 00:19:29.790
公司已经在想你想要的

00:19:28.530 --> 00:19:31.470
在另一个方面看一下

00:19:29.790 --> 00:19:33.270
方向也最糟

00:19:31.470 --> 00:19:35.640
人们可能看到的情况

00:19:33.270 --> 00:19:37.730
也许我可以为大多数客户提供服务

00:19:35.640 --> 00:19:39.590
一两百毫秒

00:19:37.730 --> 00:19:41.480
毫秒，但如果我的情况最糟

00:19:39.590 --> 00:19:43.370
客户的情况是

00:19:41.480 --> 00:19:46.010
其实要带我你知道

00:19:43.370 --> 00:19:47.930
整整一秒钟做出回应，就像

00:19:46.010 --> 00:19:51.200
坏事和我们想要成为的事情

00:19:47.930 --> 00:19:53.210
能够掌握所有这些

00:19:51.200 --> 00:19:55.310
像我们所有的好处一样正确的事情

00:19:53.210 --> 00:19:59.480
看到关于反应的引导我们

00:19:55.310 --> 00:20:01.640
这样的代码现在是

00:19:59.480 --> 00:20:03.500
抱歉，网络通量方法知道如何

00:20:01.640 --> 00:20:05.480
使用Springs Web Client退出并

00:20:03.500 --> 00:20:08.570
异步和非阻塞使

00:20:05.480 --> 00:20:10.400
调用另外两个Web服务等待

00:20:08.570 --> 00:20:12.320
他们回来协调回报

00:20:10.400 --> 00:20:14.750
价值将其转化为

00:20:12.320 --> 00:20:17.000
复合的东西是现在这是可行的

00:20:14.750 --> 00:20:19.430
我们看到很多很多的东西

00:20:17.000 --> 00:20:21.080
开发人员今天已经在做，如果

00:20:19.430 --> 00:20:22.760
你三年前会在这里站起来

00:20:21.080 --> 00:20:24.350
然后我向别人展示了这段代码

00:20:22.760 --> 00:20:26.810
他们不知道自己在做什么

00:20:24.350 --> 00:20:32.090
或为什么它很重要，但现在我们看到了

00:20:26.810 --> 00:20:34.370
就是这样，那么仍然需要什么

00:20:32.090 --> 00:20:36.620
就像我们给您的网络流量一样

00:20:34.370 --> 00:20:38.330
我们已经完成了项目反应堆

00:20:36.620 --> 00:20:41.930
击倒了很多低迷的人

00:20:38.330 --> 00:20:43.370
水果在这里，但我们说你知道我们吃了

00:20:41.930 --> 00:20:45.650
去年退后一步说，如果

00:20:43.370 --> 00:20:48.140
我们已经做到了，我们还能做什么

00:20:45.650 --> 00:20:50.780
帮助您开始这一被动的旅程

00:20:48.140 --> 00:20:52.010
我们确定了三大问题

00:20:50.780 --> 00:20:53.780
要谈论改善

00:20:52.010 --> 00:20:55.850
我们要谈论的Raptor核心功能

00:20:53.780 --> 00:20:57.050
关于网络跨进程回

00:20:55.850 --> 00:20:59.390
压力，我们将谈论

00:20:57.050 --> 00:21:01.010
数据访问以及与此相关的

00:20:59.390 --> 00:21:04.520
交给维奥莱塔在这里谈

00:21:01.010 --> 00:21:06.920
关于那些反应堆的核心特征好吗

00:21:04.520 --> 00:21:09.260
它已经被设置为反应性

00:21:06.920 --> 00:21:12.050
编程案例有很多好处， 

00:21:09.260 --> 00:21:18.220
应用程序使用时更具可扩展性

00:21:12.050 --> 00:21:20.870
弹性较小的资源，但

00:21:18.220 --> 00:21:24.500
如果我们遇到问题怎么办

00:21:20.870 --> 00:21:26.600
应用程序有时可能会非常

00:21:24.500 --> 00:21:29.810
寻找根本原因的挑战

00:21:26.600 --> 00:21:31.850
这个问题，例如

00:21:29.810 --> 00:21:34.730
当务之急是众所周知的例外

00:21:31.850 --> 00:21:38.180
进行编程的地方

00:21:34.730 --> 00:21:40.520
您可以很容易找到该错误

00:21:38.180 --> 00:21:42.170
根本原因，但事实并非如此

00:21:40.520 --> 00:21:46.150
我们没有的反应式编程

00:21:42.170 --> 00:21:50.269
这些例外了

00:21:46.150 --> 00:21:52.820
幸运的是有了最新的改进

00:21:50.269 --> 00:21:58.369
在反应堆项目和春季

00:21:52.820 --> 00:22:01.429
我们可以为您提供漏洞检测的框架

00:21:58.369 --> 00:22:05.450
体验与您所拥有的相似

00:22:01.429 --> 00:22:14.299
命令式编程，我将开始

00:22:05.450 --> 00:22:16.580
带有反应堆的背试剂反应堆

00:22:14.299 --> 00:22:20.059
后台代理实际上能够提供

00:22:16.580 --> 00:22:24.700
您对箭头的跟踪这是一个

00:22:20.059 --> 00:22:27.499
生成字节码的Java代理

00:22:24.700 --> 00:22:30.320
转换，以便您可以轻松

00:22:27.499 --> 00:22:35.570
将其集成到您的应用程序中

00:22:30.320 --> 00:22:37.399
也不会把额外的

00:22:35.570 --> 00:22:43.369
应用程序的开销

00:22:37.399 --> 00:22:49.719
所以用这个反应堆的后卫你

00:22:43.369 --> 00:22:53.959
甚至可以将其放入您的

00:22:49.719 --> 00:22:56.749
生产环境并具备

00:22:53.959 --> 00:23:03.619
即使在

00:22:56.749 --> 00:23:06.200
您今天的生产应用

00:23:03.619 --> 00:23:10.249
主题演讲我准备了一个简单的

00:23:06.200 --> 00:23:16.339
应用程序，现在我将切换到我的

00:23:10.249 --> 00:23:19.159
此应用程序的ID，我将向您显示

00:23:16.339 --> 00:23:22.059
如何轻松使用对书的反应

00:23:19.159 --> 00:23:22.059
代理人

00:23:23.499 --> 00:23:31.279
但是首先你知道我们有

00:23:28.609 --> 00:23:33.349
这两个有趣的环节

00:23:31.279 --> 00:23:35.119
几天我看到那里的电话号码

00:23:33.349 --> 00:23:39.619
就像我想去所有这些

00:23:35.119 --> 00:23:42.709
会议是这个参加的权利

00:23:39.619 --> 00:23:45.950
因此，我创造了一个

00:23:42.709 --> 00:23:47.659
建议的简单应用

00:23:45.950 --> 00:23:52.369
会议会议基于

00:23:47.659 --> 00:23:58.369
参加的名字，所以让我看看

00:23:52.369 --> 00:24:01.210
我应该参加的会议让我开始

00:23:58.369 --> 00:24:01.210
应用

00:24:18.650 --> 00:24:26.789
现在让我们四个等一下

00:24:23.309 --> 00:24:29.970
该应用程序实际上很漂亮

00:24:26.789 --> 00:24:34.070
聪明，因为它建议参加我的

00:24:29.970 --> 00:24:39.090
自己的会议，这将是一个很好的会议

00:24:34.070 --> 00:24:43.679
现在让我们看看应用程序是什么

00:24:39.090 --> 00:24:46.620
向本求婚，然后你有

00:24:43.679 --> 00:24:50.750
没有pent内部服务器错误对不起

00:24:46.620 --> 00:24:53.940
我确定我要进行两次会议

00:24:50.750 --> 00:25:00.529
让我检查一下这是怎么回事

00:24:53.940 --> 00:25:05.370
我看到的这个应用程序是

00:25:00.529 --> 00:25:08.159
 nullpointerexception，但这就是我要做的

00:25:05.370 --> 00:25:11.669
不知道该异常发生在哪里

00:25:08.159 --> 00:25:14.220
例如如何将这种书

00:25:11.669 --> 00:25:19.770
我在堆栈跟踪中看到的情况

00:25:14.220 --> 00:25:23.820
被称为反应堆的反应堆堆芯

00:25:19.770 --> 00:25:28.799
 Nettie和Nettie没有任何东西

00:25:23.820 --> 00:25:31.520
对于我的应用程序代码，幸运的是

00:25:28.799 --> 00:25:34.950
默认使用最新的Spring Framework 

00:25:31.520 --> 00:25:39.120
您将能够看到一些检查点

00:25:34.950 --> 00:25:42.779
最后，例如在这里我可以

00:25:39.120 --> 00:25:46.980
看到最有可能是这个后端

00:25:42.779 --> 00:25:52.620
服务有一些问题，但我仍然

00:25:46.980 --> 00:25:54.929
无法说空指针在哪里

00:25:52.620 --> 00:25:58.100
让我介绍一下我的申请

00:25:54.929 --> 00:25:58.100
反应堆背剂

00:26:14.800 --> 00:26:25.420
所以我们要做的只是两个

00:26:20.520 --> 00:26:29.170
更改应用程序的第一个

00:26:25.420 --> 00:26:32.590
显然是提供对

00:26:29.170 --> 00:26:34.800
第二个和第二个是

00:26:32.590 --> 00:26:38.580
初始化反应器的后台代理

00:26:34.800 --> 00:26:41.470
因为医生后勤人员会

00:26:38.580 --> 00:26:45.040
在课堂上奖励它

00:26:41.470 --> 00:26:49.050
最好放在我的主要金属上

00:26:45.040 --> 00:26:54.570
它在这里，让我现在开始

00:26:49.050 --> 00:26:54.570
该代理程序的应用

00:27:11.670 --> 00:27:20.330
如果我再次请求，我应该能够

00:27:15.840 --> 00:27:20.330
查看有关该问题的更多信息

00:27:20.929 --> 00:27:29.370
所以我可以再次在这里找到我的处理程序

00:27:26.100 --> 00:27:32.840
检查点，但正如你所见

00:27:29.370 --> 00:27:36.929
有很多信息，现在我

00:27:32.840 --> 00:27:39.330
甚至可以看到此处理程序试图

00:27:36.929 --> 00:27:45.090
写下回应，并在

00:27:39.330 --> 00:27:49.169
此会话存储库的时间

00:27:45.090 --> 00:27:52.440
返回此无指针异常

00:27:49.169 --> 00:27:56.640
我们甚至可以导航到此技术跟踪

00:27:52.440 --> 00:27:59.360
源代码，实际上我可以看到

00:27:56.640 --> 00:28:03.330
这个发布者有问题

00:27:59.360 --> 00:28:07.140
让我看看我们拥有什么

00:28:03.330 --> 00:28:12.030
初始化阶段，是的，我做了

00:28:07.140 --> 00:28:14.929
非常愚蠢的错误在这里让我解决

00:28:12.030 --> 00:28:14.929
很快

00:28:38.680 --> 00:28:46.930
现在Ben的会议应该是

00:28:44.250 --> 00:29:05.350
练习比率关系数据库

00:28:46.930 --> 00:29:07.420
连接正确，接下来的两个

00:29:05.350 --> 00:29:11.710
我想介绍给你的是

00:29:07.420 --> 00:29:14.410
正如我已经说过的

00:29:11.710 --> 00:29:17.559
响应式编程，我们使用更少的威胁

00:29:14.410 --> 00:29:21.790
真的很重要

00:29:17.559 --> 00:29:24.670
阻止他们，但不仅

00:29:21.790 --> 00:29:27.610
您作为开发人员编写的代码，但是

00:29:24.670 --> 00:29:31.179
也是第三方图书馆

00:29:27.610 --> 00:29:35.320
您可以使用，所以您不能保证

00:29:31.179 --> 00:29:41.230
整个代码不会使用阻塞

00:29:35.320 --> 00:29:45.250
电话，重要的是要有一些

00:29:41.230 --> 00:29:47.860
可以检测是否有自动工具

00:29:45.250 --> 00:29:51.240
它在您的应用程序或您的

00:29:47.860 --> 00:29:59.020
第三方图书馆是否有

00:29:51.240 --> 00:30:01.660
阻止呼叫阻止计数是这样的-它

00:29:59.020 --> 00:30:06.640
是Java代理，用于

00:30:01.660 --> 00:30:09.580
 JVM类并拦截阻塞

00:30:06.640 --> 00:30:14.950
当他们对非

00:30:09.580 --> 00:30:18.010
仅阻止运营以及我们

00:30:14.950 --> 00:30:20.110
建议您使用这两个时间

00:30:18.010 --> 00:30:21.850
我们正在测试以验证您的

00:30:20.110 --> 00:30:24.760
应用程序，以便您可以确定

00:30:21.850 --> 00:30:29.110
没有工作代码

00:30:24.760 --> 00:30:32.880
现在整个链我将尝试使用块

00:30:29.110 --> 00:30:32.880
算上我的申请

00:30:41.460 --> 00:30:52.230
再次使用它非常容易

00:30:47.910 --> 00:30:55.380
需要依赖于阻止计数，并且

00:30:52.230 --> 00:30:59.970
然后我们还需要初始化它

00:30:55.380 --> 00:31:03.770
现在我们主要的方法开始

00:30:59.970 --> 00:31:03.770
带块数的应用

00:31:16.470 --> 00:31:34.059
并要求哎呀，真正的他们

00:31:29.050 --> 00:31:40.470
现场演示好吧，让我再试一次

00:31:34.059 --> 00:31:40.470
这个和这个，然后重新开始

00:31:51.019 --> 00:31:57.570
好的，这次我们可以看到

00:31:54.320 --> 00:31:59.879
我们有一些煤块

00:31:57.570 --> 00:32:05.309
应用程序，它做了一些套接字

00:31:59.879 --> 00:32:13.019
连接，让我们检查一下哪个组件

00:32:05.309 --> 00:32:20.549
如果我再次转到日志，我会这样做

00:32:13.019 --> 00:32:22.649
看到这里实际上是其余的

00:32:20.549 --> 00:32:24.539
在煤中执行此操作的模板

00:32:22.649 --> 00:32:27.299
因为您知道的其余模板是一个

00:32:24.539 --> 00:32:30.690
阻止HTTP线圈，其余的我们使用

00:32:27.299 --> 00:32:33.330
我们的远程呼叫模板

00:32:30.690 --> 00:32:35.879
为了解决我可以轻松切换的问题

00:32:33.330 --> 00:32:37.649
从其余模板到Web客户端

00:32:35.879 --> 00:32:42.749
是非阻塞的交互式抓取

00:32:37.649 --> 00:32:45.679
需要，所以让我这样做，看看

00:32:42.749 --> 00:32:45.679
将是结果

00:33:11.880 --> 00:33:21.410
所以我们要说的是

00:33:16.740 --> 00:33:33.240
再次工作，让我再次切换到

00:33:21.410 --> 00:33:36.179
演示摘要，您可以看到

00:33:33.240 --> 00:33:39.809
使用反应堆中的BOK代理并阻止

00:33:36.179 --> 00:33:42.690
我能够确定并解决的问题

00:33:39.809 --> 00:33:47.780
我申请的严重问题

00:33:42.690 --> 00:33:50.460
五分钟，但这不是这个工具

00:33:47.780 --> 00:33:52.980
图书馆不是我们唯一的图书馆

00:33:50.460 --> 00:33:55.740
可以为您提供新的运营商

00:33:52.980 --> 00:34:00.960
反应堆堆芯中的新钩子

00:33:55.740 --> 00:34:06.330
拖拉机网我们有表现

00:34:00.960 --> 00:34:10.020
改进，这不是，不是

00:34:06.330 --> 00:34:12.480
仅此，但我们计划进行更多增强

00:34:10.020 --> 00:34:15.950
为了将来能够

00:34:12.480 --> 00:34:20.609
改善开发经验

00:34:15.950 --> 00:34:23.369
所以我会深入

00:34:20.609 --> 00:34:25.290
您继续讲故事

00:34:23.369 --> 00:34:28.700
以及我们在那里所做的改进

00:34:25.290 --> 00:34:28.700
非常感谢你

00:34:32.730 --> 00:34:36.940
所以反应堆堆芯的改进很好

00:34:36.369 --> 00:34:39.820
不好

00:34:36.940 --> 00:34:42.429
改进反应堆堆芯

00:34:39.820 --> 00:34:44.230
显然非常重要，但是

00:34:42.429 --> 00:34:46.990
您还想做其他事情

00:34:44.230 --> 00:34:49.000
对，第一个是这个想法

00:34:46.990 --> 00:34:51.580
跨过程反压反应

00:34:49.000 --> 00:34:53.830
 streams是一个很棒的API，也是一个很棒的

00:34:51.580 --> 00:34:55.720
讨论如何规范

00:34:53.830 --> 00:34:57.790
允许发布者和订阅者

00:34:55.720 --> 00:35:00.609
在一个之间发送和使用数据

00:34:57.790 --> 00:35:02.109
另一个，但是在jvm的结尾

00:35:00.609 --> 00:35:04.210
有点失去，没有办法

00:35:02.109 --> 00:35:06.550
沟通和微服务

00:35:04.210 --> 00:35:09.609
相同需求之外的架构

00:35:06.550 --> 00:35:12.280
这一点多年来很明显

00:35:09.609 --> 00:35:14.380
整个行业已经标准化

00:35:12.280 --> 00:35:16.089
 HTTP作为网络协议

00:35:14.380 --> 00:35:19.060
互动以及很多事情

00:35:16.089 --> 00:35:20.500
这足够好，但是当您开始时

00:35:19.060 --> 00:35:22.390
看看这些项目这些

00:35:20.500 --> 00:35:24.550
效率很高效率很高

00:35:22.390 --> 00:35:26.380
吞吐量项目和微型项目

00:35:24.550 --> 00:35:29.230
服务网络，我们发现

00:35:26.380 --> 00:35:31.420
 HTTP阻止的真正大问题

00:35:29.230 --> 00:35:34.630
大部分是从它你知道它的

00:35:31.420 --> 00:35:36.130
我想去的根得到一页文字

00:35:34.630 --> 00:35:39.310
就是这样，因为我们不是真的

00:35:36.130 --> 00:35:42.099
发送大量的文本了，所以

00:35:39.310 --> 00:35:43.960
如果您看一下HTTP 1.0， 

00:35:42.099 --> 00:35:46.420
具有单个请求连接

00:35:43.960 --> 00:35:48.970
非常高效，我们引入了HTTP 

00:35:46.420 --> 00:35:51.250
 1.1，但即使那样也有问题，因为

00:35:48.970 --> 00:35:53.589
按照您应该的方式进行流水线操作

00:35:51.250 --> 00:35:55.420
使用多个连接

00:35:53.589 --> 00:35:58.089
对他们的要求有负责人

00:35:55.420 --> 00:36:00.700
阻止问题，这是真的

00:35:58.089 --> 00:36:03.760
太难了，我们也看到了

00:36:00.700 --> 00:36:06.400
使HTTP可靠，您最终使用

00:36:03.760 --> 00:36:08.430
像断路器模式一样的模式

00:36:06.400 --> 00:36:11.500
最终导致您使用外部系统

00:36:08.430 --> 00:36:13.450
像历史记录程序扩展和涡轮

00:36:11.500 --> 00:36:15.280
这样的事情只是为了保持你的

00:36:13.450 --> 00:36:17.800
系统可靠，几乎

00:36:15.280 --> 00:36:20.050
当然不是一个好的策略

00:36:17.800 --> 00:36:21.670
通过启动两项或一项可靠的服务

00:36:20.050 --> 00:36:23.589
其他三项服务，因为您必须

00:36:21.670 --> 00:36:25.690
保持它们的可靠性，这仅仅是

00:36:23.589 --> 00:36:28.599
整个乌龟，然后

00:36:25.690 --> 00:36:30.280
大概在今天的时代

00:36:28.599 --> 00:36:32.190
存在于其中的许多应用程序

00:36:30.280 --> 00:36:35.050
世界仅限于此

00:36:32.190 --> 00:36:37.630
请求/响应类型HTTP 2 

00:36:35.050 --> 00:36:40.060
放松一点但不是真的

00:36:37.630 --> 00:36:42.910
如此显着，春季队

00:36:40.060 --> 00:36:44.829
订婚一年多一点

00:36:42.910 --> 00:36:47.200
一个称为我们的套接字或

00:36:44.829 --> 00:36:50.079
套接字最初是一个协议，所以它是

00:36:47.200 --> 00:36:51.670
一个非常像HTTP的网络协议

00:36:50.079 --> 00:36:54.400
最初是在

00:36:51.670 --> 00:36:55.869
 Netflix和Netflix团队的排序

00:36:54.400 --> 00:36:57.729
分手了一点，他们搬了出去， 

00:36:55.869 --> 00:37:00.150
他们开始把它带到其他地方，所以

00:36:57.729 --> 00:37:02.499
它确实在诸如

00:37:00.150 --> 00:37:05.259
初创公司，如果我使用过，我们将与net合作

00:37:02.499 --> 00:37:08.109
在Facebook上也很忙

00:37:05.259 --> 00:37:10.239
我们的插座用很长的句子

00:37:08.109 --> 00:37:12.400
基于双向复用消息

00:37:10.239 --> 00:37:14.289
基于反应式的二进制协议

00:37:12.400 --> 00:37:16.509
流回压力，这很多

00:37:14.289 --> 00:37:17.499
将会有一个会议

00:37:16.509 --> 00:37:19.680
如果这可能

00:37:17.499 --> 00:37:22.059
使您感兴趣，但关键要点

00:37:19.680 --> 00:37:23.859
考虑我们的插座是

00:37:22.059 --> 00:37:26.529
实际上封装了多个

00:37:23.859 --> 00:37:28.299
交互模型已经

00:37:26.529 --> 00:37:30.039
封装了请求的思想

00:37:28.299 --> 00:37:32.019
我们已经知道的回应，但是

00:37:30.039 --> 00:37:34.420
一劳永逸也许您需要发送

00:37:32.019 --> 00:37:36.039
一堆来自客户端设备的日志

00:37:34.420 --> 00:37:38.319
他们不在乎它是否交付

00:37:36.039 --> 00:37:40.509
请求流，我认为是什么

00:37:38.319 --> 00:37:41.979
这些天我们大多数人都会发送

00:37:40.509 --> 00:37:43.779
给您一个请求，我希望您流式传输

00:37:41.979 --> 00:37:45.789
给我一堆数据，然后终于

00:37:43.779 --> 00:37:47.559
通道什么都有，有一个

00:37:45.789 --> 00:37:50.109
大旧管道，您可以发送数据

00:37:47.559 --> 00:37:52.690
如您所愿，两方之间

00:37:50.109 --> 00:37:54.249
那一点语言本身对不起

00:37:52.690 --> 00:37:56.140
协议本身的语言也是

00:37:54.249 --> 00:37:58.599
真正灵活的语言不可知论

00:37:56.140 --> 00:38:00.609
它有很多绑定

00:37:58.599 --> 00:38:03.400
有效负载不可知的权利，而不仅仅是

00:38:00.609 --> 00:38:05.170
 HTTP，不是Jason，不是

00:38:03.400 --> 00:38:06.940
像G RPC这样的情况

00:38:05.170 --> 00:38:09.880
 protobufs您可以发送所有这些

00:38:06.940 --> 00:38:12.039
整个协议中的事情

00:38:09.880 --> 00:38:13.900
与运输无关，所以如果你幸运的话

00:38:12.039 --> 00:38:15.459
足以拥有一个内部网络

00:38:13.900 --> 00:38:18.039
您可以安全使用的数据中心

00:38:15.459 --> 00:38:19.869
发送TCP数据，你可以做到，但你是

00:38:18.039 --> 00:38:22.119
不限于此，您可以将其流式传输

00:38:19.869 --> 00:38:24.729
通过WebSockets进入开放世界或

00:38:22.119 --> 00:38:27.849
 HTTP-如果需要，可以使用air 

00:38:24.729 --> 00:38:30.459
令人难以置信的最快的事情

00:38:27.849 --> 00:38:32.410
您也可以通过UDP，我们也

00:38:30.459 --> 00:38:33.969
在春季做了很多工作

00:38:32.410 --> 00:38:36.279
一边确保我们的插座是

00:38:33.969 --> 00:38:38.410
可以使用不可知的编程模型

00:38:36.279 --> 00:38:40.839
您可以直接使用我们的套接字API 

00:38:38.410 --> 00:38:42.940
 RPC和protobuf样式非常相似

00:38:40.839 --> 00:38:45.160
 G RPC如果您要这样做，但是

00:38:42.940 --> 00:38:47.440
您还可以使用一种消息传递样式

00:38:45.160 --> 00:38:49.449
是春天真正认可的东西

00:38:47.440 --> 00:38:52.959
显然，从您那里了解我们的历史

00:38:49.449 --> 00:38:54.910
消息处理程序和控制器

00:38:52.959 --> 00:38:58.180
我们有一个网络协议可以

00:38:54.910 --> 00:38:58.720
帮助您进行这一被动的旅程哦

00:38:58.180 --> 00:38:59.710
抱歉

00:38:58.720 --> 00:39:00.760
他们是一堆其他协议

00:38:59.710 --> 00:39:02.470
他们还有很多其他功能

00:39:00.760 --> 00:39:04.990
良好的恢复能力可能是

00:39:02.470 --> 00:39:07.240
 Facebook最大的一家公司已经使用它来

00:39:04.990 --> 00:39:09.670
效果很好，例如

00:39:07.240 --> 00:39:12.010
网络连接暂时断开

00:39:09.670 --> 00:39:14.260
当它回来而不是

00:39:12.010 --> 00:39:17.230
尝试从那里重新同步状态

00:39:14.260 --> 00:39:18.760
恰恰相反，它现在会说嘿

00:39:17.230 --> 00:39:20.590
我已经走了最后一百

00:39:18.760 --> 00:39:26.530
毫秒告诉我发生了什么

00:39:20.590 --> 00:39:28.270
自从上次见到你以来，我们有一个

00:39:26.530 --> 00:39:31.210
可以帮助您的网络协议

00:39:28.270 --> 00:39:32.200
反应性的旅程，但随后

00:39:31.210 --> 00:39:34.030
我们要谈的最后一件事

00:39:32.200 --> 00:39:37.450
今天在这里非常非常

00:39:34.030 --> 00:39:39.910
当我们交谈时，我的心就亲近了

00:39:37.450 --> 00:39:41.560
给客户很多关于反应式的

00:39:39.910 --> 00:39:43.870
编程尤其是客户

00:39:41.560 --> 00:39:44.500
尚未真正投产的

00:39:43.870 --> 00:39:47.560
用它

00:39:44.500 --> 00:39:50.110
我们总是听到这种反应

00:39:47.560 --> 00:39:52.870
数据访问对他们来说是有问题的，所以

00:39:50.110 --> 00:39:55.570
今天我们大多数的客户

00:39:52.870 --> 00:39:58.360
反应堆和反应堆

00:39:55.570 --> 00:40:01.240
生产中的应用没有续集

00:39:58.360 --> 00:40:04.410
数据存储对，这些都是新的

00:40:01.240 --> 00:40:07.060
非常有远见的

00:40:04.410 --> 00:40:08.140
服务，他们真的拥抱这些

00:40:07.060 --> 00:40:09.250
新型的前瞻性思维

00:40:08.140 --> 00:40:11.170
非阻塞

00:40:09.250 --> 00:40:13.750
异步编程模型

00:40:11.170 --> 00:40:17.650
所以MongoDB Apache Cassandra Couchbase 

00:40:13.750 --> 00:40:20.410
 Redis所有这些都是服务

00:40:17.650 --> 00:40:24.160
有Java客户端驱动程序的地方

00:40:20.410 --> 00:40:25.870
可以在反应性世界中工作，但是

00:40:24.160 --> 00:40:28.210
最常见的数据存储丢失最多

00:40:25.870 --> 00:40:30.400
到目前为止，通用数据存储是

00:40:28.210 --> 00:40:31.750
你可能会想到的那些顶级

00:40:30.400 --> 00:40:33.850
他们非常性感，除了

00:40:31.750 --> 00:40:35.530
他们只是一小部分

00:40:33.850 --> 00:40:39.190
当前存储的所有数据或

00:40:35.530 --> 00:40:41.470
目前在我们行业中加工最多

00:40:39.190 --> 00:40:43.000
通用数据存储显然是相关的

00:40:41.470 --> 00:40:45.340
数据库是所有数据所在的地方

00:40:43.000 --> 00:40:46.750
被发送了最近30年， 

00:40:45.340 --> 00:40:48.550
确切地说所有数据仍然在哪里

00:40:46.750 --> 00:40:50.140
目前坐着，你们所有人都有

00:40:48.550 --> 00:40:53.860
需要与之交互的应用程序

00:40:50.140 --> 00:40:56.830
他们，所以我们启动了一个名为r2的项目

00:40:53.860 --> 00:40:59.050
 DBC我们两个DBC是反应性的关系

00:40:56.830 --> 00:41:05.080
数据库连接很少

00:40:59.050 --> 00:41:08.290
只要记住Droid徽标r2 DBC是

00:41:05.080 --> 00:41:10.390
从根本上说， 

00:41:08.290 --> 00:41:12.620
反应式编程的基础

00:41:10.390 --> 00:41:14.870
因为只是包装

00:41:12.620 --> 00:41:17.690
是不够的，JDBC是一个

00:41:14.870 --> 00:41:19.670
阻止API甚至是命令式API 

00:41:17.690 --> 00:41:22.160
将其放入线程池有问题

00:41:19.670 --> 00:41:23.510
池耗尽或资源不足

00:41:22.160 --> 00:41:25.300
用尽会导致那些

00:41:23.510 --> 00:41:27.920
您最终阻止的情况

00:41:25.300 --> 00:41:29.750
在线程池中，所以我们不能做

00:41:27.920 --> 00:41:31.520
我们需要从头开始， 

00:41:29.750 --> 00:41:33.110
它有一些非常坚固的设计

00:41:31.520 --> 00:41:35.270
随之而来的原则

00:41:33.110 --> 00:41:37.460
首先是利用反应

00:41:35.270 --> 00:41:39.410
流和对不起的反应流类型

00:41:37.460 --> 00:41:41.480
和模式，我们希望这是本地的

00:41:39.410 --> 00:41:43.490
直接进入反应世界

00:41:41.480 --> 00:41:45.620
蝙蝠，我们希望它被完全阻挡

00:41:43.490 --> 00:41:47.600
很抱歉，一路无路

00:41:45.620 --> 00:41:49.820
数据库，我们走得更远

00:41:47.600 --> 00:41:51.830
一些有线协议的一些

00:41:49.820 --> 00:41:54.530
数据库客户端连接的协议

00:41:51.830 --> 00:41:57.380
有能力去做的数据库

00:41:54.530 --> 00:41:59.240
我有点反应风格的背压

00:41:57.380 --> 00:42:01.070
最了解Postgres的那个

00:41:59.240 --> 00:42:03.320
我已经实现的，例如

00:42:01.070 --> 00:42:04.910
您可以简单地说下10个寄给我

00:42:03.320 --> 00:42:06.440
物品，然后再寄给我

00:42:04.910 --> 00:42:08.600
二十八项和数据库

00:42:06.440 --> 00:42:11.030
甚至没有实现

00:42:08.600 --> 00:42:12.530
磁盘，直到您要求下一个

00:42:11.030 --> 00:42:14.480
项目数量，这样您就可以

00:42:12.530 --> 00:42:16.850
一种很好的受控方式将数据导入

00:42:14.480 --> 00:42:18.890
客户我们也想缩小这些

00:42:16.850 --> 00:42:21.800
将驱动程序最小化

00:42:18.890 --> 00:42:24.200
即使那会影响某种

00:42:21.800 --> 00:42:26.360
人类的可用性，我们希望拥有一个非常

00:42:24.200 --> 00:42:28.040
表面积小，因此数据库供应商

00:42:26.360 --> 00:42:30.620
有最容易的事情

00:42:28.040 --> 00:42:31.790
实施，然后我们要启用我们

00:42:30.620 --> 00:42:33.530
要确保该API 

00:42:31.790 --> 00:42:36.200
我们在这里设计的还可以

00:42:33.530 --> 00:42:38.360
我们期望多种人性化的api的权利

00:42:36.200 --> 00:42:40.520
我们的两个DB C是针对数据库供应商的， 

00:42:38.360 --> 00:42:42.140
我们希望在其他客户上创建

00:42:40.520 --> 00:42:44.150
最重要的是，我不知道你是否是

00:42:42.140 --> 00:42:45.890
那种喜欢mybatis的人

00:42:44.150 --> 00:42:48.410
你写了很多续集声明，或者

00:42:45.890 --> 00:42:51.140
您是您交易的JPA类人

00:42:48.410 --> 00:42:54.860
与对象或您是JD bi人， 

00:42:51.140 --> 00:42:57.140
您喜欢一个真正流利的API，而我

00:42:54.860 --> 00:43:01.670
希望所有这些事情成为可能

00:42:57.140 --> 00:43:03.710
在单个驱动程序API之上，所以今天

00:43:01.670 --> 00:43:05.870
我们的2D VC有很多驱动程序

00:43:03.710 --> 00:43:08.690
我们拥有H2 Microsoft的实现

00:43:05.870 --> 00:43:09.980
续集Postgres我的续集问世了

00:43:08.690 --> 00:43:12.080
社区，所以我们真的是

00:43:09.980 --> 00:43:13.580
为那一大批人感到高兴

00:43:12.080 --> 00:43:15.980
类型转换

00:43:13.580 --> 00:43:18.260
 JDBC驱动程序的等效性

00:43:15.980 --> 00:43:20.390
 blob和CLOB支持保存的那些东西

00:43:18.260 --> 00:43:22.910
点和利用新

00:43:20.390 --> 00:43:25.859
 Jurgen的交易功能

00:43:22.910 --> 00:43:29.430
在Spring框架中描述

00:43:25.859 --> 00:43:32.849
我们也有被动交易

00:43:29.430 --> 00:43:35.430
还看了一下，还是对不起我们

00:43:32.849 --> 00:43:38.099
与更广泛的Java社区进行了交谈

00:43:35.430 --> 00:43:39.930
像APM供应商之类的东西

00:43:38.099 --> 00:43:41.759
并说如果你可以改变的话

00:43:39.930 --> 00:43:43.890
有关JDBC的信息，如果您有机会开始

00:43:41.759 --> 00:43:45.719
再次，你想看到什么，一个

00:43:43.890 --> 00:43:47.880
他们的主要原则是

00:43:45.719 --> 00:43:50.279
真的很想看一流

00:43:47.880 --> 00:43:51.959
可观察性他们想知道

00:43:50.279 --> 00:43:54.690
他们可以检查所有的东西

00:43:51.959 --> 00:43:56.609
他们的客户非常期待

00:43:54.690 --> 00:43:59.130
今天显然是APM的简便方法

00:43:56.609 --> 00:44:01.440
供应商观察到的JDBC只是一个

00:43:59.130 --> 00:44:03.509
我们想为他们解决的巨大问题

00:44:01.440 --> 00:44:04.829
确保我们真的是一流的

00:44:03.509 --> 00:44:06.390
连接池事实证明

00:44:04.829 --> 00:44:08.219
连接池和非阻塞

00:44:06.390 --> 00:44:10.349
环境真的很困难

00:44:08.219 --> 00:44:12.059
反应堆团队已经绝对

00:44:10.349 --> 00:44:14.069
创建一个名为

00:44:12.059 --> 00:44:16.799
我们能够利用的反应堆燃料

00:44:14.069 --> 00:44:19.380
并获得真正高效的汇总

00:44:16.799 --> 00:44:21.539
而且我们已经有一些客户

00:44:19.380 --> 00:44:23.700
实施春季数据非常

00:44:21.539 --> 00:44:26.450
第一人称基本上跳到

00:44:23.700 --> 00:44:30.630
该API，因此，如果您熟悉

00:44:26.450 --> 00:44:33.119
 Spring Data的数据存储库样式

00:44:30.630 --> 00:44:34.680
您已经可以使用的访问权限

00:44:33.119 --> 00:44:38.579
但我们在更广泛的社区中看到

00:44:34.680 --> 00:44:42.089
再说那个JKE JDI mybatis 

00:44:38.579 --> 00:44:44.819
已经都在看r2 DBC 

00:44:42.089 --> 00:44:46.529
 api，实际上我只是来自DevOps 

00:44:44.819 --> 00:44:48.420
在英国，我们有一个非常非常

00:44:46.529 --> 00:44:49.890
与休眠团队的愉快会议

00:44:48.420 --> 00:44:52.709
冬眠团队开始寻找

00:44:49.890 --> 00:44:54.420
反应性JTA或反应性ORM 

00:44:52.709 --> 00:44:56.069
可能看起来像，他们开始

00:44:54.420 --> 00:44:57.479
看看我们两个DB C 

00:44:56.069 --> 00:45:00.239
可能会进一步下降

00:44:57.479 --> 00:45:02.219
生产线更大的项目更大的计划

00:45:00.239 --> 00:45:03.930
但是每个人都参与其中

00:45:02.219 --> 00:45:06.089
这个想法，我们需要这种

00:45:03.930 --> 00:45:09.839
反应性数据访问关系

00:45:06.089 --> 00:45:12.089
数据库，以便完成它我们

00:45:09.839 --> 00:45:14.309
说完了还是对不起，我们来看了一下

00:45:12.089 --> 00:45:16.410
对人们的阻碍是什么

00:45:14.309 --> 00:45:18.029
为了开始做出反应，我们确定了

00:45:16.410 --> 00:45:19.640
三巨头我们在这里紫罗兰

00:45:18.029 --> 00:45:23.880
谈论我们所做的改进- 

00:45:19.640 --> 00:45:25.709
谈到我们的核心

00:45:23.880 --> 00:45:27.690
以此来减轻压力

00:45:25.709 --> 00:45:30.329
跨线并使用协议

00:45:27.690 --> 00:45:32.849
这是为分布式而构建的

00:45:30.329 --> 00:45:36.319
系统，而不是HTTP，最后我们

00:45:32.849 --> 00:45:39.730
看看RTD BC的反应性

00:45:36.319 --> 00:45:42.340
如果您有兴趣访问数据库

00:45:39.730 --> 00:45:44.290
这三个概念中的任何一个violetta都有

00:45:42.340 --> 00:45:45.490
周五的一次讨论

00:45:44.290 --> 00:45:47.170
她在这里做的事情，包括一些

00:45:45.490 --> 00:45:49.570
她所做的巨大改进

00:45:47.170 --> 00:45:53.050
 Nettie反应堆我在说我们的

00:45:49.570 --> 00:45:56.850
星期五在套接字上，稍后有Archie TBC 

00:45:53.050 --> 00:45:56.850
今天下午，谢谢大家

00:46:02.329 --> 00:46:08.109
哦，我应该接下来介绍

00:46:05.660 --> 00:46:10.189
塞巴斯蒂安·图卢兹与我们交谈

00:46:08.109 --> 00:46:11.880
春季Kotlin的改进

00:46:10.189 --> 00:46:18.489
框架谢谢

00:46:11.880 --> 00:46:30.829
 [掌声] 

00:46:18.489 --> 00:46:33.130
好吧，所以我不是12点好吧，好吧，留下来

00:46:30.829 --> 00:46:33.130
亲

00:46:38.840 --> 00:46:41.380
好的

00:46:44.300 --> 00:46:46.720
测试

00:46:48.990 --> 00:46:52.220
没关系

00:46:56.260 --> 00:47:03.089
好吧，你有一只鸟是麦克风吗

00:47:00.089 --> 00:47:03.089
好的

00:47:05.570 --> 00:47:12.950
一二一二好吧，大家好，我是

00:47:10.340 --> 00:47:15.080
塞巴斯蒂安门，我正走在枢轴上

00:47:12.950 --> 00:47:18.320
我是春季正式通勤者，今天

00:47:15.080 --> 00:47:23.060
我将谈论有关的最新更新

00:47:18.320 --> 00:47:25.130
 2016年的柯克兰报告

00:47:23.060 --> 00:47:27.140
可待因窗口已发布，并且相同

00:47:25.130 --> 00:47:30.740
那天我们增加了对凯瑟琳的支持

00:47:27.140 --> 00:47:33.050
而不是春季数据哦几

00:47:30.740 --> 00:47:35.540
几个月后，苏格兰ESL 

00:47:33.050 --> 00:47:38.900
最近在

00:47:35.540 --> 00:47:41.030
一年五个版本中的稳定版本

00:47:38.900 --> 00:47:43.640
在我们宣布可待因官员之后

00:47:41.030 --> 00:47:46.400
春季报告五马赫及以后

00:47:43.640 --> 00:47:49.760
德鲁伊未知数削减报告

00:47:46.400 --> 00:47:52.010
以及去年的四百次政变

00:47:49.760 --> 00:47:54.830
例行程序被宣布为稳定

00:47:52.010 --> 00:47:57.980
 Kirkland 1.3的功能和几天

00:47:54.830 --> 00:47:59.840
之前在Google I / O，Google宣布

00:47:57.980 --> 00:48:03.320
现在首先切入Android，这意味着

00:47:59.840 --> 00:48:07.550
现在dpi提出的方式是

00:48:03.320 --> 00:48:10.820
默认为切入，稍后再显示

00:48:07.550 --> 00:48:13.100
对于照片Java开发人员，因此继续

00:48:10.820 --> 00:48:15.290
眼睛继续明显的很大一部分

00:48:13.100 --> 00:48:17.930
这个新的窗帘开发商来了

00:48:15.290 --> 00:48:19.790
来自移动世界，但我们也看到了

00:48:17.930 --> 00:48:22.160
对可待因的兴趣增加

00:48:19.790 --> 00:48:27.470
服务器端，我在这里谈论

00:48:22.160 --> 00:48:30.470
今天，但让我们谈谈你为什么

00:48:27.470 --> 00:48:32.480
我想可能对卡特里娜飓风感兴趣

00:48:30.470 --> 00:48:35.150
第一点是，这是一个

00:48:32.480 --> 00:48:38.360
实用的语言，但仍然优雅

00:48:35.150 --> 00:48:40.340
提供扩展等具体工具

00:48:38.360 --> 00:48:44.260
具有强大的互操作性

00:48:40.340 --> 00:48:47.090
 Java简洁明了而不是我的库

00:48:44.260 --> 00:48:48.830
也认为

00:48:47.090 --> 00:48:51.100
凯瑟琳特别是其中的新安全

00:48:48.830 --> 00:48:54.410
在类型系统中本地管理

00:48:51.100 --> 00:48:57.410
变成Java的一种缺点，因为

00:48:54.410 --> 00:48:59.510
在Java中，新事物是一种

00:48:57.410 --> 00:49:02.090
想要避免与可选和其他

00:48:59.510 --> 00:49:04.310
这样的东西变成了强大的功能

00:49:02.090 --> 00:49:06.380
使得在

00:49:04.310 --> 00:49:08.180
编译时间而不是处理

00:49:06.380 --> 00:49:11.180
运行时新的指针异常

00:49:08.180 --> 00:49:13.340
我也认为代码干净

00:49:11.180 --> 00:49:16.130
提供更好的信噪比

00:49:13.340 --> 00:49:18.520
比Java代码更易反应

00:49:16.130 --> 00:49:22.030
由于协程更容易

00:49:18.520 --> 00:49:23.859
所以上师的青少年正在割湿

00:49:22.030 --> 00:49:27.880
线程将无法正常工作

00:49:23.859 --> 00:49:30.099
您可以以更强制性的方式编写代码

00:49:27.880 --> 00:49:33.730
看到这里反应性之间的映射

00:49:30.099 --> 00:49:36.369
和协程，所以基本上是单身

00:49:33.730 --> 00:49:39.609
值，您将拥有一个看起来像的API 

00:49:36.369 --> 00:49:44.320
就像命令式代码

00:49:39.609 --> 00:49:48.010
暂停关键字，助焊剂将翻译

00:49:44.320 --> 00:49:50.380
流动，所以这里的流动类型被切入

00:49:48.010 --> 00:49:53.050
流，因此它们使用的类型与

00:49:50.380 --> 00:49:55.089
与用于响应的包装器同名

00:49:53.050 --> 00:49:57.220
 Java 9中的Java流实现

00:49:55.089 --> 00:49:59.230
但是在这里我们真的在谈论

00:49:57.220 --> 00:50:02.290
编码流程，相当于

00:49:59.230 --> 00:50:05.170
助长词和春天

00:50:02.290 --> 00:50:06.190
格式5.2我们提供内置支持

00:50:05.170 --> 00:50:08.410
用于例程

00:50:06.190 --> 00:50:09.970
通过利用所有向量

00:50:08.410 --> 00:50:13.180
基础设施，使一切

00:50:09.970 --> 00:50:15.940
 Violetta，然后我以前展示了它

00:50:13.180 --> 00:50:18.580
将是CL电路的网页标志

00:50:15.940 --> 00:50:21.180
一切都在croute中使用

00:50:18.580 --> 00:50:23.710
支持另一种消费方式

00:50:21.180 --> 00:50:25.900
由...提供的反应性基础设施

00:50:23.710 --> 00:50:29.109
就像我们也为春天提供支持

00:50:25.900 --> 00:50:31.690
 Erick Java在设计决策中我们

00:50:29.109 --> 00:50:33.430
悄悄地打了标记5我们真的打赌

00:50:31.690 --> 00:50:35.440
在无功流上每间隔

00:50:33.430 --> 00:50:37.660
能力的原因，这就是

00:50:35.440 --> 00:50:39.550
利用这种互操作性

00:50:37.660 --> 00:50:43.359
提供消耗反应性的另一种方法

00:50:39.550 --> 00:50:45.550
我要以更强制的方式堆叠

00:50:43.359 --> 00:50:49.180
给你看演示，但是在我之前

00:50:45.550 --> 00:50:51.460
多亏了

00:50:49.180 --> 00:50:54.070
吉恩-巴蒂斯特·忍者的作品

00:50:51.460 --> 00:50:55.930
社区和春天的漫步

00:50:54.070 --> 00:50:59.050
斯普林伍德队特别是斯蒂芬队

00:50:55.930 --> 00:51:01.810
到今天为止，当您创建一个

00:50:59.050 --> 00:51:04.599
用Gradle切割项目来构建它

00:51:01.810 --> 00:51:06.820
将改用GSL中的Gradle剪切

00:51:04.599 --> 00:51:10.930
时髦的，我将展示

00:51:06.820 --> 00:51:14.290
具体说来就是和您一起演示的

00:51:10.930 --> 00:51:17.470
我们将创建一个新的

00:51:14.290 --> 00:51:22.330
响应式Web应用程序，我们

00:51:17.470 --> 00:51:23.680
由于要开始，所以要这样做

00:51:22.330 --> 00:51:26.560
春天，你的整合

00:51:23.680 --> 00:51:30.849
有一个ID，所以我正在使用状态

00:51:26.560 --> 00:51:31.960
窗口给你，我要创建一个新的

00:51:30.849 --> 00:51:35.020
项目

00:51:31.960 --> 00:51:38.650
这显然将使用Gradle 

00:51:35.020 --> 00:51:44.530
作为一种语言被砍干净了

00:51:38.650 --> 00:51:46.920
我们将自定义名称

00:51:44.530 --> 00:51:49.210
我正在选择最新和最伟大的

00:51:46.920 --> 00:51:51.730
米利斯的春天引导到两个

00:51:49.210 --> 00:51:53.800
我将添加反应式

00:51:51.730 --> 00:51:55.480
网络依赖，因为一件事

00:51:53.800 --> 00:51:57.760
重要的是要了解

00:51:55.480 --> 00:52:05.250
例行报告基于网络流量

00:51:57.760 --> 00:52:05.250
织带收据不报告好吗

00:52:08.970 --> 00:52:17.080
好吧，就像我今天说的那样，当你

00:52:13.030 --> 00:52:19.570
创建新内容时创建新内容

00:52:17.080 --> 00:52:22.150
柯克兰项目默认情况下具有天气

00:52:19.570 --> 00:52:24.550
它生成一个kts的生成器Gradle 

00:52:22.150 --> 00:52:27.190
这是Gradle的Kirtland变体

00:52:24.550 --> 00:52:29.440
代码看起来像熊一样，但

00:52:27.190 --> 00:52:33.480
你还有更多可以浏览的

00:52:29.440 --> 00:52:36.270
静态类型的所有内容

00:52:33.480 --> 00:52:39.400
你有更好的文件

00:52:36.270 --> 00:52:40.840
自动完成，所以我认为

00:52:39.400 --> 00:52:44.410
平地机很有趣，因为天气

00:52:40.840 --> 00:52:46.540
功能强大，但也非常困难

00:52:44.410 --> 00:52:48.880
所以当我使用常规动作时

00:52:46.540 --> 00:52:51.340
主要在互联网上复制和粘贴

00:52:48.880 --> 00:52:53.050
修改我们最在这里的东西

00:52:51.340 --> 00:52:54.790
结构化，因为一切都是

00:52:53.050 --> 00:52:59.290
静态类型，我认为这是一个

00:52:54.790 --> 00:53:01.510
伟大的组合，现在我们要

00:52:59.290 --> 00:53:05.830
创建一个简单的反应式应用程序

00:53:01.510 --> 00:53:09.850
使用Kotlin和网络流量，所以我要

00:53:05.830 --> 00:53:11.860
让我只添加依赖性，所以我们

00:53:09.850 --> 00:53:14.620
将使用将数据带到VCS 

00:53:11.860 --> 00:53:17.470
将数据带到DBC是消费者的一种方式

00:53:14.620 --> 00:53:22.660
到刚刚提交的DBC 

00:53:17.470 --> 00:53:24.930
春天的世界，所以我们要添加

00:53:22.660 --> 00:53:27.730
将弹簧数据发送给DBC，我们将使用

00:53:24.930 --> 00:53:30.220
 PostgreSQL驱动程序，我们将

00:53:27.730 --> 00:53:33.700
添加依赖项管理，因为

00:53:30.220 --> 00:53:35.440
因为到DBC的春季数据不是最终数据

00:53:33.700 --> 00:53:37.450
尚未集成到引导中，但稍后

00:53:35.440 --> 00:53:38.160
您将拥有入门和类似的东西

00:53:37.450 --> 00:53:42.130
那

00:53:38.160 --> 00:53:44.550
所以我要在里面创建我的难题

00:53:42.130 --> 00:53:47.460
凯瑟琳，所以我要创建一个

00:53:44.550 --> 00:53:52.050
因此，我们将在

00:53:47.460 --> 00:53:55.230
文章顶部的课程，让我们来

00:53:52.050 --> 00:53:59.520
有一段时间谈论差异

00:53:55.230 --> 00:54:02.430
与Java相比，我们有

00:53:59.520 --> 00:54:04.770
一个非常简洁的课程，因为我们

00:54:02.430 --> 00:54:06.180
具有这种简洁的语法， 

00:54:04.770 --> 00:54:11.070
同时声明构造函数

00:54:06.180 --> 00:54:13.230
参数和属性可能意味着

00:54:11.070 --> 00:54:16.110
推动不可变的数据结构

00:54:13.230 --> 00:54:18.480
在这里我们用Val代替Val 

00:54:16.110 --> 00:54:20.400
具有不变的属性的数据

00:54:18.480 --> 00:54:22.800
允许产生的关键字

00:54:20.400 --> 00:54:27.960
自动等于一个小队和两个

00:54:22.800 --> 00:54:29.850
字符串的类型是三个固定的

00:54:27.960 --> 00:54:31.920
默认编码类型为非

00:54:29.850 --> 00:54:34.020
可用意味着如果您尝试放置

00:54:31.920 --> 00:54:36.150
例如标题中的新标签值

00:54:34.020 --> 00:54:39.420
您在编译时会有另一个

00:54:36.150 --> 00:54:43.140
以及是否要指定新标签

00:54:39.420 --> 00:54:45.480
类型，您将使用此类问题

00:54:43.140 --> 00:54:47.700
标记爱琴海的人说这种类型

00:54:45.480 --> 00:54:50.160
是新标签，在

00:54:47.700 --> 00:54:53.340
凯瑟琳意味着它可能是空的

00:54:50.160 --> 00:54:55.470
值，这是一种更强大的功能

00:54:53.340 --> 00:54:57.150
也可以用于输入的可选

00:54:55.470 --> 00:54:58.500
参数和其他东西，你不会

00:54:57.150 --> 00:55:00.570
必须付出代价

00:54:58.500 --> 00:55:05.460
易读性和性能

00:55:00.570 --> 00:55:07.580
我们也使用的包装器

00:55:05.460 --> 00:55:09.960
另一个有趣的功能是

00:55:07.580 --> 00:55:12.720
可选参数将为默认值

00:55:09.960 --> 00:55:14.340
因此不必创建另一个

00:55:12.720 --> 00:55:16.770
构造函数的重载版本

00:55:14.340 --> 00:55:18.540
就像在Java中，我可以定义

00:55:16.770 --> 00:55:21.119
可选参数，默认

00:55:18.540 --> 00:55:25.020
参数，所以如果我没有新的边缘

00:55:21.119 --> 00:55:26.640
指定Edline炉渣或编辑添加幕布

00:55:25.020 --> 00:55:28.560
我们会自动使用默认值

00:55:26.640 --> 00:55:31.250
我们在这里提供的

00:55:28.560 --> 00:55:34.230
可读性我认为这很有趣

00:55:31.250 --> 00:55:36.690
现在你看到你看到这渣方法

00:55:34.230 --> 00:55:39.090
显然是红色的

00:55:36.690 --> 00:55:43.170
标题是字符串，不是渣

00:55:39.090 --> 00:55:44.970
字符串类型提供的方法，所以我们

00:55:43.170 --> 00:55:49.980
将使用扩展名进行编辑

00:55:44.970 --> 00:55:51.900
功能，因此扩展功能是

00:55:49.980 --> 00:55:53.560
春天大量使用的机制

00:55:51.900 --> 00:55:56.140
从上为您提供

00:55:53.560 --> 00:55:58.690
特定于切割的API 

00:55:56.140 --> 00:56:00.490
现有的弹簧类型，但您可以使用它

00:55:58.690 --> 00:56:03.450
为您自己的项目，您应该使用

00:56:00.490 --> 00:56:07.060
它代替了抽象类

00:56:03.450 --> 00:56:08.770
用静态方法，我在这里添加

00:56:07.060 --> 00:56:10.510
将金属渣转化成

00:56:08.770 --> 00:56:13.270
带空格和特殊字符的标题

00:56:10.510 --> 00:56:17.230
到我可以使用的东西，我们

00:56:13.270 --> 00:56:19.210
着火了，然后我可以

00:56:17.230 --> 00:56:21.520
使用这种不错的语法，这样您

00:56:19.210 --> 00:56:24.610
不应滥用扩展名，因为

00:56:21.520 --> 00:56:25.570
你可以做些粗鲁的事情，但我认为

00:56:24.610 --> 00:56:27.820
这是一个非常有用的功能

00:56:25.570 --> 00:56:30.490
特别是考虑到它们是

00:56:27.820 --> 00:56:32.590
不一样的耳朵

00:56:30.490 --> 00:56:34.120
包装，因此可以直接使用，但如果

00:56:32.590 --> 00:56:38.020
我的扩展程序位于其他程序包中

00:56:34.120 --> 00:56:39.790
我必须像我一样明确导入

00:56:38.020 --> 00:56:42.220
导入静态导入例如

00:56:39.790 --> 00:56:44.230
这不是魔术和动态的一切

00:56:42.220 --> 00:56:46.810
被切干净是静态类型

00:56:44.230 --> 00:56:50.170
 Java，甚至更多

00:56:46.810 --> 00:56:52.360
安全功能，现在我们要

00:56:50.170 --> 00:56:55.830
使用创建一个文章库

00:56:52.360 --> 00:57:02.890
春天数据到BC所以文章

00:56:55.830 --> 00:57:09.210
好的，就像我说过的

00:57:02.890 --> 00:57:15.280
导入扩展以使用它们好

00:57:09.210 --> 00:57:18.340
所以这是一个L2 DBC弹簧数据-DBC 

00:57:15.280 --> 00:57:20.320
基于存储库数据库的父级是

00:57:18.340 --> 00:57:22.690
提供的功能性API 

00:57:20.320 --> 00:57:24.850
将弹簧数据发送到DBC 

00:57:22.690 --> 00:57:26.680
常规存储库模型，我们

00:57:24.850 --> 00:57:29.290
您将使用这种流利的API 

00:57:26.680 --> 00:57:30.820
可以将其视为一种网络连接

00:57:29.290 --> 00:57:34.420
数据库，所以您有这种

00:57:30.820 --> 00:57:37.360
同样的流利的API，我直接在这里

00:57:34.420 --> 00:57:39.400
编写PostgreSQL代码，这样我就可以

00:57:37.360 --> 00:57:39.760
利用海报的本机功能

00:57:39.400 --> 00:57:42.940
组

00:57:39.760 --> 00:57:45.490
 SQL很棒的数据库，如果我想和

00:57:42.940 --> 00:57:48.340
 2d BCT照顾的春天

00:57:45.490 --> 00:57:52.960
把它变成物体，你

00:57:48.340 --> 00:57:55.120
看到我需要的API返回单声道和通量

00:57:52.960 --> 00:57:57.130
指定代码意味着一切

00:57:55.120 --> 00:58:01.540
是静态类型的，所以这里是ins 

00:57:57.130 --> 00:58:04.630
 IDE会根据

00:58:01.540 --> 00:58:06.760
法国的内容类型，因此您会看到

00:58:04.630 --> 00:58:07.510
 API返回单声道和通量，我们是

00:58:06.760 --> 00:58:10.300
去

00:58:07.510 --> 00:58:12.030
所以是的，当你使用季节承认

00:58:10.300 --> 00:58:15.310
第二个电路，你必须使用这个

00:58:12.030 --> 00:58:19.470
反应性操作员要做我要去的事

00:58:15.310 --> 00:58:25.840
添加控制器也文章

00:58:19.470 --> 00:58:27.850
控制器，因此这是常规网络优先

00:58:25.840 --> 00:58:31.450
使用flex和mono的控制器

00:58:27.850 --> 00:58:35.109
基于API，我只需要添加

00:58:31.450 --> 00:58:40.720
有点配置，因为它不是

00:58:35.109 --> 00:58:43.500
尚未在Josh上受支持

00:58:40.720 --> 00:58:46.060
所以我们声明Kalyan bin为数据库

00:58:43.500 --> 00:58:47.890
显然，何时会支持

00:58:46.060 --> 00:58:51.430
最终版本，您将不必

00:58:47.890 --> 00:58:53.170
做到这一点，就是这样，我有

00:58:51.430 --> 00:58:56.650
完成实施我的反应式

00:58:53.170 --> 00:58:59.530
版本，现在我要把它变成

00:58:56.650 --> 00:59:01.450
更迫切的东西

00:58:59.530 --> 00:59:04.270
协程，但利用相同

00:59:01.450 --> 00:59:07.990
在基础设施下面，所以我要去

00:59:04.270 --> 00:59:13.780
添加对协同例程的依赖

00:59:07.990 --> 00:59:17.080
好的，就是这样，然后是策略

00:59:13.780 --> 00:59:19.690
我们用来提供日常服务

00:59:17.080 --> 00:59:21.760
报告使用以下现有类型

00:59:19.690 --> 00:59:23.530
扩展名，因此您不必导入

00:59:21.760 --> 00:59:27.220
 cou例程数据库超出何处

00:59:23.530 --> 00:59:29.920
一切都包裹好了，我们可以

00:59:27.220 --> 00:59:32.950
使用这种扩展名，因此

00:59:29.920 --> 00:59:35.320
定义协程暂停

00:59:32.950 --> 00:59:37.990
功能扩展以a为前缀

00:59:35.320 --> 00:59:40.480
用任何重量固定的方式，在这里

00:59:37.990 --> 00:59:42.760
你看我改变了我的方法

00:59:40.480 --> 00:59:46.119
使用反应类型，例如mono和flex 

00:59:42.760 --> 00:59:48.700
挂起的方法

00:59:46.119 --> 00:59:51.520
仅返回文章的新标签

00:59:48.700 --> 00:59:54.300
我要在这里做同样的工作

00:59:51.520 --> 00:59:58.230
而不是使用流量，我使用流量

00:59:54.300 --> 01:00:03.880
这里我用的是重量而不是重量

00:59:58.230 --> 01:00:04.450
我把这变成了悬念

01:00:03.880 --> 01:00:10.260
这里

01:00:04.450 --> 01:00:12.850
重达最大的重量悬挂

01:00:10.260 --> 01:00:15.010
同样的事情，你会发现

01:00:12.850 --> 01:00:16.900
不只是返回类型

01:00:15.010 --> 01:00:20.970
编程风格会改变，所以这里

01:00:16.900 --> 01:00:20.970
而不是使用反应式运算符

01:00:21.119 --> 01:00:32.349
我将只使用命令式代码，因此

01:00:28.089 --> 01:00:34.479
我只去除零个花瓣，然后使用

01:00:32.349 --> 01:00:37.630
我本来会用的相同类型的代码

01:00:34.479 --> 01:00:41.049
我的命令性代码除外

01:00:37.630 --> 01:00:43.180
下面是基于指令栈

01:00:41.049 --> 01:00:44.979
让我澄清两点

01:00:43.180 --> 01:00:47.199
处理背压

01:00:44.979 --> 01:00:48.939
它使用

01:00:47.199 --> 01:00:53.380
暂停功能，因此您将看到更多

01:00:48.939 --> 01:00:55.089
明天在我的演讲中也有详细介绍

01:00:53.380 --> 01:00:57.249
默认一切都是第二枪

01:00:55.089 --> 01:00:59.920
非阻塞，但默认情况下为第二张

01:00:57.249 --> 01:01:04.449
你可以做可选的并发我

01:00:59.920 --> 01:01:07.660
今天不会显示，但现在相信我

01:01:04.449 --> 01:01:09.910
我要改变它，所以

01:01:07.660 --> 01:01:13.779
支持将弹簧数据发送到DBC 

01:01:09.910 --> 01:01:15.640
这里的扩展spring web flags 

01:01:13.779 --> 01:01:18.609
本机处理，所以我一无所有

01:01:15.640 --> 01:01:20.499
去做，我会把它变成

01:01:18.609 --> 01:01:23.499
更迫切的事情

01:01:20.499 --> 01:01:28.229
所以我写的完全一样

01:01:23.499 --> 01:01:31.179
春天的代码我的春天MVC接受

01:01:28.229 --> 01:01:34.209
现在让我暂停功能

01:01:31.179 --> 01:01:35.890
想做某种手术

01:01:34.209 --> 01:01:38.380
您播放延迟，例如呼叫

01:01:35.890 --> 01:01:42.249
远程Web服务，所以我要

01:01:38.380 --> 01:01:44.499
通过这种悬浮来模拟

01:01:42.249 --> 01:01:48.789
方法，但假设您正在编码

01:01:44.499 --> 01:01:50.559
远程慢速Web服务在这里

01:01:48.789 --> 01:01:54.699
返回流量和流量提供

01:01:50.559 --> 01:01:57.099
像Flex这样的运算符

01:01:54.699 --> 01:01:59.739
运算符，但这里所有这些运算符

01:01:57.099 --> 01:02:02.949
是扩展和有趣的事情

01:01:59.739 --> 01:02:06.069
关于协程中的地图运算符

01:02:02.949 --> 01:02:07.509
流动就是可以使用就可以强迫

01:02:06.069 --> 01:02:09.640
暂停功能，这意味着

01:02:07.509 --> 01:02:11.459
您不必将平面地图用作

01:02:09.640 --> 01:02:15.789
一旦有延迟操作

01:02:11.459 --> 01:02:17.199
地图是完美的，最后

01:02:15.789 --> 01:02:20.349
事之后，我会告诉你

01:02:17.199 --> 01:02:21.699
如果我能

01:02:20.349 --> 01:02:24.130
想要使用服务器发送的事件

01:02:21.699 --> 01:02:27.039
在苔藓修剪中终结更多的东西

01:02:24.130 --> 01:02:30.219
方式，我们使用流量而不是流量

01:02:27.039 --> 01:02:32.170
你会在我的流程生成器中看到

01:02:30.219 --> 01:02:34.030
这只是简单

01:02:32.170 --> 01:02:37.810
我只是命令式代码

01:02:34.030 --> 01:02:40.060
使用while循环将发出

01:02:37.810 --> 01:02:42.490
这是推低音和流，所以你发出一个

01:02:40.060 --> 01:02:44.530
可能是按钮的新对象

01:02:42.490 --> 01:02:47.109
来自暂停功能，我

01:02:44.530 --> 01:02:54.670
用来模拟某种延迟

01:02:47.109 --> 01:02:56.020
因此，如果我现在运行该应用程序， 

01:02:54.670 --> 01:03:01.300
以为我忘记了什么

01:02:56.020 --> 01:03:02.920
是的，所以我在这里用彩虹之王

01:03:01.300 --> 01:03:05.440
这是我们展示的政变常规

01:03:02.920 --> 01:03:10.000
封闭，但从概念上讲这是

01:03:05.440 --> 01:03:13.680
相同，因为挂起功能需要

01:03:10.000 --> 01:03:13.680
被另一个挂起函数调用

01:03:14.970 --> 01:03:21.609
所以我开始我的申请，然后如果我

01:03:19.450 --> 01:03:25.060
请求我的路线终点，您会看到

01:03:21.609 --> 01:03:27.310
它返回了我放的我的对象

01:03:25.060 --> 01:03:30.070
在初始化器中，如果我想

01:03:27.310 --> 01:03:32.940
流数据，您看到我的同事

01:03:30.070 --> 01:03:35.890
点的工作就像我会使用

01:03:32.940 --> 01:03:38.560
 flex和一切都支持暂停

01:03:35.890 --> 01:03:40.030
功能，所以真的很反应

01:03:38.560 --> 01:03:43.480
编程，但势在必行

01:03:40.030 --> 01:03:45.369
就范围而言，编程模型

01:03:43.480 --> 01:03:46.990
同时支持酷炫的网络标志例程

01:03:45.369 --> 01:03:49.089
用于带注释的控制器编程

01:03:46.990 --> 01:03:51.280
模型和Web Flex功能

01:03:49.089 --> 01:03:53.710
我们有cout例程的变体

01:03:51.280 --> 01:03:55.780
网络客户端扩展也

01:03:53.710 --> 01:03:58.089
扬声器电路报告弹簧

01:03:55.780 --> 01:04:00.730
 Atmos H映射和电路

01:03:58.089 --> 01:04:03.430
请求者提供妙招例程API 

01:04:00.730 --> 01:04:06.760
而在春天，我们提供它

01:04:03.430 --> 01:04:09.089
像F 2d BC一样使用功能性API 

01:04:06.760 --> 01:04:13.630
数据库客户端，我们也提供

01:04:09.089 --> 01:04:16.180
模板或操作的扩展

01:04:13.630 --> 01:04:21.280
从春天开始基于MongoDB的API 

01:04:16.180 --> 01:04:26.920
 Kisan运行Redis报告让我结束

01:04:21.280 --> 01:04:28.900
 ESL的DSL是写ap的一种方式

01:04:26.920 --> 01:04:31.030
一种可以装饰的方式

01:04:28.900 --> 01:04:33.310
在Java中注册，但看起来像

01:04:31.030 --> 01:04:35.740
不很棒，至少

01:04:33.310 --> 01:04:38.109
 Java没有为您提供特定工具

01:04:35.740 --> 01:04:40.630
帮你写自己的理由

01:04:38.109 --> 01:04:43.660
凯瑟琳为您提供真正的专注

01:04:40.630 --> 01:04:45.820
为此的功能，这是路由

01:04:43.660 --> 01:04:47.500
我们提供的您自己

01:04:45.820 --> 01:04:49.660
 5马赫的弹簧哦

01:04:47.500 --> 01:04:52.000
以及Mach春季的新功能

01:04:49.660 --> 01:04:54.670
 5.2是我们也为

01:04:52.000 --> 01:04:56.200
 Spring MVC，让您永无止境

01:04:54.670 --> 01:04:59.290
就像之前由

01:04:56.200 --> 01:05:03.070
再次，您可以利用spring MVC Tomcat 

01:04:59.290 --> 01:05:05.370
并使用这种不错的DSL 

01:05:03.070 --> 01:05:07.840
您可以按数十年合并请求

01:05:05.370 --> 01:05:10.780
提供某种动态代码来

01:05:07.840 --> 01:05:13.830
通用路线，那是我认为的

01:05:10.780 --> 01:05:16.000
非常适合Kathleen I 

01:05:13.830 --> 01:05:20.200
希望她在你的帮助下完成

01:05:16.000 --> 01:05:22.870
去年来我这里的项目

01:05:20.200 --> 01:05:26.470
在春季IO想到的是

01:05:22.870 --> 01:05:28.330
宵禁是如此的实验性豆腐

01:05:26.470 --> 01:05:30.370
弹簧的显式配置模型

01:05:28.330 --> 01:05:32.140
屠夫在问题DSL这不是

01:05:30.370 --> 01:05:34.390
准备生产，这是实验性的

01:05:32.140 --> 01:05:36.580
这正在孵化，好吧，我不使用它

01:05:34.390 --> 01:05:38.740
在生产中，但我想

01:05:36.580 --> 01:05:40.900
提出它，因为在豆类和

01:05:38.740 --> 01:05:43.240
路由或DSL我认为这是一个非常

01:05:40.900 --> 01:05:44.770
乙酰胆碱的好用例吗

01:05:43.240 --> 01:05:48.010
只是在配置弹簧启动

01:05:44.770 --> 01:05:49.630
明确的方式，以便

01:05:48.010 --> 01:05:52.030
 re0我发布的一个蔬菜通心粉汤

01:05:49.630 --> 01:05:55.360
昨天是报告两个网站

01:05:52.030 --> 01:05:57.430
博客和网络MVC，就像那样

01:05:55.360 --> 01:06:00.130
所以基本上你配置Spring Boot 

01:05:57.430 --> 01:06:02.380
使用程序化API定义是否

01:06:00.130 --> 01:06:05.620
这是一个独立的基于

01:06:02.380 --> 01:06:07.540
反应一个Web应用程序，您可以

01:06:05.620 --> 01:06:09.640
您可以使用

01:06:07.540 --> 01:06:12.580
直接从您的IDE自动完成

01:06:09.640 --> 01:06:14.380
您可以配置日志级别

01:06:12.580 --> 01:06:16.090
使用明显来自动态的东西

01:06:14.380 --> 01:06:18.580
环境不是一切

01:06:16.090 --> 01:06:21.760
一切都是动态的，这很简单

01:06:18.580 --> 01:06:25.660
像在港口一样切割代码

01:06:21.760 --> 01:06:29.140
您可以使用动态的if或for定义

01:06:25.660 --> 01:06:32.020
声明您利用垃圾箱和

01:06:29.140 --> 01:06:33.730
根或DSL并提供明确的

01:06:32.020 --> 01:06:35.020
配置模型，基本上

01:06:33.730 --> 01:06:37.090
利用所有的Springwood 

01:06:35.020 --> 01:06:39.910
没有配置的东西

01:06:37.090 --> 01:06:42.780
有条件的注释，所以基本上你

01:06:39.910 --> 01:06:45.520
负责宣布您要

01:06:42.780 --> 01:06:47.560
串和杰克的拒绝转换器

01:06:45.520 --> 01:06:49.270
以此顺序，并在

01:06:47.560 --> 01:06:52.350
您想使用漂亮的转换器

01:06:49.270 --> 01:06:55.570
打印，有趣的是

01:06:52.350 --> 01:06:58.030
因为您只指定需要的内容

01:06:55.570 --> 01:07:00.610
会更有效率，因为它只是

01:06:58.030 --> 01:07:02.680
您将得到所需的东西

01:07:00.610 --> 01:07:04.800
一旦你祝福我我的

01:07:02.680 --> 01:07:09.040
手腕更快，因为你

01:07:04.800 --> 01:07:11.020
是的，它没有新功能

01:07:09.040 --> 01:07:12.790
因为您添加了依赖项而没有弹出

01:07:11.020 --> 01:07:15.310
一切都是明确的，你在

01:07:12.790 --> 01:07:18.100
控制不那么惊讶，所以我认为

01:07:15.310 --> 01:07:21.240
一个有趣的编程模型，如果您

01:07:18.100 --> 01:07:23.440
有兴趣去春季foo 

01:07:21.240 --> 01:07:25.540
这个投影的地方很少

01:07:23.440 --> 01:07:27.610
诱饵成为项目的明星

01:07:25.540 --> 01:07:29.560
贡献我们有来自

01:07:27.610 --> 01:07:32.410
例如涉及的社区

01:07:29.560 --> 01:07:34.570
社区里有人在这个房间里

01:07:32.410 --> 01:07:36.610
在弹簧安全车上行走

01:07:34.570 --> 01:07:38.890
印度单元将被整合到

01:07:36.610 --> 01:07:41.730
甲府，也许稍后在春季安全

01:07:38.890 --> 01:07:45.190
所以随时来贡献我

01:07:41.730 --> 01:07:47.260
明天将提供更多信息

01:07:45.190 --> 01:07:51.040
我与之专门交谈的日子

01:07:47.260 --> 01:07:52.160
豆腐和例程进行实时编码，谢谢

01:07:51.040 --> 01:07:57.450
很多

01:07:52.160 --> 01:08:02.980
 [掌声] 

01:07:57.450 --> 01:08:02.980
 [音乐] 

