WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.900 --> 00:00:07.980
 [音乐] 

00:00:09.770 --> 00:00:17.400
 [掌声] 

00:00:18.779 --> 00:00:23.769
是的，虽然我是一个

00:00:21.670 --> 00:00:28.420
汇合，我们将要谈论

00:00:23.769 --> 00:00:32.200
大概是 Spring 吧

00:00:28.420 --> 00:00:36.880
对于一个四人卡夫卡卡夫卡流谁

00:00:32.200 --> 00:00:39.240
这里听说过 Spring 

00:00:36.880 --> 00:00:42.310
听说卡夫卡

00:00:39.240 --> 00:00:48.570
好吧，这不是全部

00:00:42.310 --> 00:00:51.640
关于JMS，那就太好了

00:00:48.570 --> 00:00:56.290
点亮很多幻灯片

00:00:51.640 --> 00:00:57.580
实际上它在这里，基本上这是

00:00:56.290 --> 00:00:59.170
唯一的幻灯片是最

00:00:57.580 --> 00:01:02.230
您需要拍摄的重要幻灯片

00:00:59.170 --> 00:01:06.149
拍照留念

00:01:02.230 --> 00:01:09.780
抓住这个叫做github的东西， 

00:01:06.149 --> 00:01:22.719
一切是否存在，如果

00:01:09.780 --> 00:01:23.710
您对代码感兴趣，所以我们要

00:01:22.719 --> 00:01:25.329
必须尽快走

00:01:23.710 --> 00:01:27.219
通过我们要谈论的一切

00:01:25.329 --> 00:01:29.409
今天左右，希望结束

00:01:27.219 --> 00:01:31.299
及时处理，我们有很多要讲的

00:01:29.409 --> 00:01:33.909
是的，我们将脱离绝对基础

00:01:31.299 --> 00:01:36.850
一直到卡夫卡溪流

00:01:33.909 --> 00:01:40.359
 Spring 的云流和所有的东西

00:01:36.850 --> 00:01:44.770
就像我的好友David Coverdale曾经

00:01:40.359 --> 00:01:48.759
说准备你的大脑融化，所以我们开始

00:01:44.770 --> 00:01:51.429
就像前提一样

00:01:48.759 --> 00:01:53.139
是的，我们可以带黑屏吗？ 

00:01:51.429 --> 00:01:55.780
让我们带白屏，让我们

00:01:53.139 --> 00:01:57.639
带上您最喜欢的地方，以便我们可以

00:01:55.780 --> 00:02:00.549
构建新软件今天的目标是

00:01:57.639 --> 00:02:03.579
只是看一下数据

00:02:00.549 --> 00:02:05.409
用卡夫卡处理我认为卡夫卡是

00:02:03.579 --> 00:02:07.240
想到卡夫卡只是危险的

00:02:05.409 --> 00:02:09.490
是另一个消息队列吧

00:02:07.240 --> 00:02:10.630
不要以为很多人我认为

00:02:09.490 --> 00:02:12.370
使用咖啡杯的人

00:02:10.630 --> 00:02:14.200
成功地没有使用它

00:02:12.370 --> 00:02:16.540
因为他们可以将其作为传统

00:02:14.200 --> 00:02:18.760
例如替换珍妮丝之类的东西

00:02:16.540 --> 00:02:21.909
那样的原因更多是因为

00:02:18.760 --> 00:02:24.310
如此好地缩放，变得像一条静脉

00:02:21.909 --> 00:02:26.470
对于组织中的数据， 

00:02:24.310 --> 00:02:28.420
成为一种移动的方式，而不仅仅是

00:02:26.470 --> 00:02:30.220
事件是关于数据的移动

00:02:28.420 --> 00:02:31.720
整个组织中以及当您

00:02:30.220 --> 00:02:34.659
开始像那样思考它

00:02:31.720 --> 00:02:36.250
数据层的另一部分

00:02:34.659 --> 00:02:37.870
变成另一种数据库

00:02:36.250 --> 00:02:40.000
有趣的事情成为可能

00:02:37.870 --> 00:02:42.040
不只是要移动那些小事件

00:02:40.000 --> 00:02:44.980
然后触发一些动作

00:02:42.040 --> 00:02:46.000
数据库是数据库的权利等等

00:02:44.980 --> 00:02:47.530
我们今天要谈论的是

00:02:46.000 --> 00:02:50.620
首先将其视为

00:02:47.530 --> 00:02:51.819
消息队列还不错，之后

00:02:50.620 --> 00:02:54.359
我们将切换为更像

00:02:51.819 --> 00:02:57.190
我们可以做的处理层

00:02:54.359 --> 00:02:59.440
事件驱动的微服务类型的事物

00:02:57.190 --> 00:03:01.060
您有处理逻辑的地方

00:02:59.440 --> 00:03:03.099
应用程序中内置的数据

00:03:01.060 --> 00:03:06.879
并且存储在

00:03:03.099 --> 00:03:08.349
卡夫卡里面的商店就好了

00:03:06.879 --> 00:03:09.549
简化我们要去我的

00:03:08.349 --> 00:03:12.489
互联网第二受欢迎的地方

00:03:09.549 --> 00:03:13.720
生产开始后的过程点Spring 

00:03:12.489 --> 00:03:16.540
我将要建立一个应用程序

00:03:13.720 --> 00:03:17.980
这里叫做Kafka，我们将使用

00:03:16.540 --> 00:03:18.579
许多不同的东西可能会使用卡夫卡

00:03:17.980 --> 00:03:22.959
本身

00:03:18.579 --> 00:03:24.609
 lombok ，我们将使用卡夫卡琴弦和

00:03:22.959 --> 00:03:26.620
我们将使用 Spring 的云流，所以

00:03:24.609 --> 00:03:28.090
我们实际使用的是 Spring 

00:03:26.620 --> 00:03:32.590
云流卡夫卡流是

00:03:28.090 --> 00:03:35.650
一点点的嘴，但它能起作用

00:03:32.590 --> 00:03:39.190
否则不应该很好

00:03:35.650 --> 00:03:43.540
应该是可以上网的，但是我们真的

00:03:39.190 --> 00:03:45.099
不知道我们使用的像马stable一样

00:03:43.540 --> 00:03:47.139
就像你说的那样，我们想进入

00:03:45.099 --> 00:04:00.940
生产我们做稳定的东西

00:03:47.139 --> 00:04:02.349
生产产生好的，好吧， 

00:04:00.940 --> 00:04:04.120
所以这里的目标是建立一个

00:04:02.349 --> 00:04:07.180
实际上是什么样的应用程序

00:04:04.120 --> 00:04:10.720
的域域，这就是事情

00:04:07.180 --> 00:04:13.930
有点奇怪的话要说，但是我很友善

00:04:10.720 --> 00:04:16.419
喜欢看电影，并且喜欢这些天

00:04:13.930 --> 00:04:19.090
关于婴儿潮一代的收视率

00:04:16.419 --> 00:04:20.829
人们去检查Metacritic人们去

00:04:19.090 --> 00:04:22.960
检查烂番茄的人会

00:04:20.829 --> 00:04:27.520
像Facebook一样查看一些意见

00:04:22.960 --> 00:04:31.240
由于某种原因，我不知道是谁

00:04:27.520 --> 00:04:34.510
看到了，所以我们需要报废一些

00:04:31.240 --> 00:04:35.650
你准备的剧透所以很抱歉

00:04:34.510 --> 00:04:42.669
关于下一次

00:04:35.650 --> 00:04:44.229
哦，我等下一集

00:04:42.669 --> 00:04:46.860
然后我就可以开始观看了

00:04:44.229 --> 00:04:50.050
最终了解所有这些参考

00:04:46.860 --> 00:04:52.110
是的，所以这就像一个

00:04:50.050 --> 00:04:54.909
电影不是关于电视节目的，而是关于

00:04:52.110 --> 00:04:57.880
编写一个流应用程序

00:04:54.909 --> 00:04:59.320
会产生评分或类似我们得到的

00:04:57.880 --> 00:05:01.840
他们的电影评分

00:04:59.320 --> 00:05:04.840
为此，我们将使用

00:05:01.840 --> 00:05:06.729
卡夫卡自然而然地

00:05:04.840 --> 00:05:09.430
使用Kafka我们将使用的数据

00:05:06.729 --> 00:05:11.740
我们将要移动的数据

00:05:09.430 --> 00:05:14.349
我们的系统实际上是非常

00:05:11.740 --> 00:05:16.599
企业格式是管道

00:05:14.349 --> 00:05:20.260
分隔文本非常企业形式如何

00:05:16.599 --> 00:05:22.870
许多来自金融科技界的女士们

00:05:20.260 --> 00:05:25.360
像银行业，我是说你

00:05:22.870 --> 00:05:27.120
处理管道中的流数据

00:05:25.360 --> 00:05:30.760
分隔格式

00:05:27.120 --> 00:05:33.580
是的，伙计们不必害羞， 

00:05:30.760 --> 00:05:37.779
我们都在为这个感到愧

00:05:33.580 --> 00:05:40.120
这没关系，没关系，是的，所以我们

00:05:37.779 --> 00:05:41.560
本质上将在

00:05:40.120 --> 00:05:45.099
在文件格式中，我们

00:05:41.560 --> 00:05:48.070
流媒体到卡夫卡，我们开始，我们将添加

00:05:45.099 --> 00:05:51.550
从0到此数据的速度

00:05:48.070 --> 00:05:54.460
无限，要做到这一点，我们要

00:05:51.550 --> 00:05:56.500
使用一些乔治的数据

00:05:54.460 --> 00:05:57.940
只会使这个正确，所以我们需要

00:05:56.500 --> 00:05:59.740
我们需要实际将数据导入

00:05:57.940 --> 00:06:04.469
为了将其引入我们将使用

00:05:59.740 --> 00:06:04.469
是一种称为Avro的格式，是的

00:06:04.950 --> 00:06:14.100
哦，好的，我们需要喜欢记住

00:06:12.030 --> 00:06:23.720
就像致命武器一样

00:06:14.100 --> 00:06:31.350
我们将使用Avro，而且没有压力，我

00:06:23.720 --> 00:06:33.480
是的，所以因为我们使用Avro 

00:06:31.350 --> 00:06:35.130
将为Avro提供支持

00:06:33.480 --> 00:06:36.810
在这里，我们要去我们的小

00:06:35.130 --> 00:06:40.470
我要打开手掌的项目

00:06:36.810 --> 00:06:42.900
 XML，我们要做一些可怕的事情

00:06:40.470 --> 00:06:44.700
你对我们依赖的东西

00:06:42.900 --> 00:06:47.070
复制粘贴的依赖项是

00:06:44.700 --> 00:06:49.920
糟糕的是我们如何编程

00:06:47.070 --> 00:06:52.530
没有一切

00:06:49.920 --> 00:06:54.330
不幸的是，没有像这样的开始

00:06:52.530 --> 00:06:57.090
我为一切做好的 Spring 

00:06:54.330 --> 00:07:08.850
应该是因为我不知道喜欢

00:06:57.090 --> 00:07:10.880
午餐或晚餐，这是这里

00:07:08.850 --> 00:07:13.770
我们要把汇合处

00:07:10.880 --> 00:07:15.600
顺便支持架构注册表

00:07:13.770 --> 00:07:17.580
我们有你可以做到的

00:07:15.600 --> 00:07:20.070
是使用架构注册表进行存储的时间

00:07:17.580 --> 00:07:21.270
有关数据类型的信息

00:07:20.070 --> 00:07:22.950
我们将跨线进行

00:07:21.270 --> 00:07:25.140
我们要自己喝咖啡

00:07:22.950 --> 00:07:27.330
卡夫卡要求 Zookeeper 你有一个

00:07:25.140 --> 00:07:29.790
整个你都知道整个疯狂的动物园

00:07:27.330 --> 00:07:31.110
像正在运行的进程一样

00:07:29.790 --> 00:07:32.880
与我们正在做的事情有关

00:07:31.110 --> 00:07:35.190
正是这就是人们喜欢的

00:07:32.880 --> 00:07:38.460
这个视频很好，所以而不是

00:07:35.190 --> 00:07:39.930
自己做，我发现那里我

00:07:38.460 --> 00:07:42.000
猜测平静的气流，并非常方便

00:07:39.930 --> 00:07:44.250
小东西叫合流见

00:07:42.000 --> 00:07:46.470
你会知道的，但这是一个哦

00:07:44.250 --> 00:07:47.610
平台还可以，所以汇合的相遇

00:07:46.470 --> 00:07:49.920
您将为什么做出贡献

00:07:47.610 --> 00:07:51.510
 apache Kafka项目，我们也是

00:07:49.920 --> 00:07:53.400
有自己的公司

00:07:51.510 --> 00:07:54.840
执行不执行

00:07:53.400 --> 00:07:56.730
但至少像

00:07:54.840 --> 00:07:58.140
 Apache Kafka和其中的工具之一

00:07:56.730 --> 00:08:01.050
针对那些没有

00:07:58.140 --> 00:08:03.870
至少要有他们的大脑

00:08:01.050 --> 00:08:05.790
被你知道的 Zookeeper 工艺融化

00:08:03.870 --> 00:08:07.440
该架构减少了所有这些连接

00:08:05.790 --> 00:08:09.750
我们有一个融合的礼来让您

00:08:07.440 --> 00:08:11.220
开始不同的组件，所以我们

00:08:09.750 --> 00:08:14.340
会做的，我们会使用汇合的Eli 

00:08:11.220 --> 00:08:17.270
并以Zookeeper Kafka模式开始

00:08:14.340 --> 00:08:22.220
具有一个命令权限的注册表

00:08:17.270 --> 00:08:24.380
销毁是的，你应该每次开始

00:08:22.220 --> 00:08:26.780
咨询销毁，所以这是非常

00:08:24.380 --> 00:08:29.030
有用，因为您可能有一些

00:08:26.780 --> 00:08:30.440
子的剩余物，因为卡夫卡

00:08:29.030 --> 00:08:32.810
记得你知道这是参考

00:08:30.440 --> 00:08:35.209
为《权力的游戏》粉丝Kafka 

00:08:32.810 --> 00:08:37.070
记得，这就是为什么你需要喜欢

00:08:35.209 --> 00:08:39.289
白色的流行音乐，所以从头开始， 

00:08:37.070 --> 00:08:42.020
这就是为什么下巴做得很出色

00:08:39.289 --> 00:08:44.060
现在调用我最喜欢的命令

00:08:42.020 --> 00:08:45.920
将再次开始和架构注册表

00:08:44.060 --> 00:08:47.270
取决于对不起的 Zookeeper 

00:08:45.920 --> 00:08:48.950
取决于卡夫卡，这取决于和

00:08:47.270 --> 00:08:51.080
 Zookeeper ，所以这将带来

00:08:48.950 --> 00:08:52.459
启动它所需的一切，等等

00:08:51.080 --> 00:08:54.980
很好，我不必指定

00:08:52.459 --> 00:08:56.149
之间的其他其他事情还可以

00:08:54.980 --> 00:08:57.800
那将会开始，现在一次

00:08:56.149 --> 00:08:59.959
在那里，我在这里有这些插件

00:08:57.800 --> 00:09:02.540
是的，这个插件会转换

00:08:59.959 --> 00:09:04.550
模式定义avro模式

00:09:02.540 --> 00:09:06.200
定义成我可以使用的对象

00:09:04.550 --> 00:09:08.240
为了做到这一点，我需要

00:09:06.200 --> 00:09:10.360
有实际的架构文件，我

00:09:08.240 --> 00:09:16.970
要从我的主要来源那里获取它们

00:09:10.360 --> 00:09:19.190
资源的原因是我们作为

00:09:16.970 --> 00:09:21.470
开发人员很懒，所以很多

00:09:19.190 --> 00:09:23.600
当有人或

00:09:21.470 --> 00:09:26.029
生成您的工作对象的东西

00:09:23.600 --> 00:09:28.010
因此我们将这种格式的Avro用作

00:09:26.029 --> 00:09:30.770
合同，我们将在Maven插件中使用

00:09:28.010 --> 00:09:33.140
来生成我们的Java POJO 

00:09:30.770 --> 00:09:35.029
有点像钢琴，但它也有一个概念

00:09:33.140 --> 00:09:36.560
关于如何序列化对象怎么办

00:09:35.029 --> 00:09:38.270
幸存的物体，所以要多一点

00:09:36.560 --> 00:09:39.740
更智能的链，只是一个POJO 

00:09:38.270 --> 00:09:42.290
所以我们将使用这种

00:09:39.740 --> 00:09:44.029
电影的东西，我们会喜欢

00:09:42.290 --> 00:09:47.120
电影ID的重要属性

00:09:44.029 --> 00:09:49.790
正常年度导演演员称号

00:09:47.120 --> 00:09:52.100
种类，到目前为止等等

00:09:49.790 --> 00:09:55.370
我们在这个错误中有很好的老师

00:09:52.100 --> 00:09:56.990
格式，但我需要使用插件来完成

00:09:55.370 --> 00:10:01.120
我可能需要这个插件

00:09:56.990 --> 00:10:03.920
就在这里，所以建立插件哦

00:10:01.120 --> 00:10:05.570
好吧，那是阿拉伯人

00:10:03.920 --> 00:10:07.700
插件，以便所有这些都能正常工作

00:10:05.570 --> 00:10:09.290
当然，您需要正确的存储库

00:10:07.700 --> 00:10:15.260
因此，请确保同时添加

00:10:09.290 --> 00:10:18.470
好吧，所以仓库好东西， 

00:10:15.260 --> 00:10:20.800
然后从那里做你的一个非常

00:10:18.470 --> 00:10:25.279
小Maven干净安装远离

00:10:20.800 --> 00:10:27.020
满意在这里，我们去吧，去吧，所以

00:10:25.279 --> 00:10:28.670
在这个构建过程中，它会落在

00:10:27.020 --> 00:10:30.740
这个插件会找到这个Avro文件

00:10:28.670 --> 00:10:34.160
在这个洛杉矶的这个仓库里

00:10:30.740 --> 00:10:35.660
资源文件夹并生成所有

00:10:34.160 --> 00:10:42.250
这些我们将用于的类

00:10:35.660 --> 00:10:48.920
这对于for-4电影等电影Java和

00:10:42.250 --> 00:10:53.390
收视率不用担心，只是看一下

00:10:48.920 --> 00:10:54.890
离开好吧，不用担心那可怕的紧

00:10:53.390 --> 00:10:56.300
现在我们要做什么我想看看

00:10:54.890 --> 00:10:58.399
我们要做两件事

00:10:56.300 --> 00:11:00.110
是的，有些数据，然后我们得到了

00:10:58.399 --> 00:11:02.300
得到一些数据是的，但我没有

00:11:00.110 --> 00:11:03.800
希望是我们不只是在做数据

00:11:02.300 --> 00:11:06.140
做好数据，我们想要我们想要做的

00:11:03.800 --> 00:11:08.149
实际上是将数据写入提示

00:11:06.140 --> 00:11:10.040
给经纪人，然后收集

00:11:08.149 --> 00:11:11.839
洞察力并获得洞察力

00:11:10.040 --> 00:11:13.760
了解数据的含义以及方式

00:11:11.839 --> 00:11:15.380
我们可以知道您能做什么

00:11:13.760 --> 00:11:16.730
处理它，我们正在处理

00:11:15.380 --> 00:11:19.190
潜在的大量数据

00:11:16.730 --> 00:11:21.260
我们要先创建一个加载器

00:11:19.190 --> 00:11:23.899
使它显得沮丧

00:11:21.260 --> 00:11:25.430
更多的流媒体类型的东西，所以我们

00:11:23.899 --> 00:11:27.620
在这种情况下我们需要做的是

00:11:25.430 --> 00:11:29.660
这种制片人

00:11:27.620 --> 00:11:32.360
将产生一些数据，所以我们

00:11:29.660 --> 00:11:35.570
将创建将调用的类

00:11:32.360 --> 00:11:41.750
生产者我们将注入什么

00:11:35.570 --> 00:11:43.040
美丽的东西到应用程序，所以我

00:11:41.750 --> 00:11:47.950
要在这里创建一个新包

00:11:43.040 --> 00:11:55.760
制片人和另一个叫做分析器的人

00:11:47.950 --> 00:11:57.860
进入那里，你是的，所以

00:11:55.760 --> 00:12:04.220
与生产者在一起，所以我们

00:11:57.860 --> 00:12:06.829
在这里做是对生产者的权利，所以我们有

00:12:04.220 --> 00:12:09.140
一班我们有 lombok ，所以我们可以有

00:12:06.829 --> 00:12:17.360
 lombok 所有这些美丽的东西

00:12:09.140 --> 00:12:21.560
请问RX需要什么构造函数

00:12:17.360 --> 00:12:24.020
构造函数日志记录显然是我们要做的

00:12:21.560 --> 00:12:29.149
在log4j版本2中，现在您有了

00:12:24.020 --> 00:12:31.940
需要输入它是，是的， 

00:12:29.149 --> 00:12:36.829
显然它将是正确的

00:12:31.940 --> 00:12:39.020
是的，这是我们真正需要做的

00:12:36.829 --> 00:12:40.100
人生有两个班制片人

00:12:39.020 --> 00:12:41.329
和消费者在这种情况下，我们将

00:12:40.100 --> 00:12:43.160
专注于生产者方面

00:12:41.329 --> 00:12:44.540
事情在这里，但我们不会

00:12:43.160 --> 00:12:45.950
用这个是因为 Spring 

00:12:44.540 --> 00:12:48.410
有更好的东西叫做

00:12:45.950 --> 00:12:51.010
卡夫卡只是你们中有多少人

00:12:48.410 --> 00:12:53.090
女士们一起工作，如果事情叫

00:12:51.010 --> 00:12:56.180
东西模板头Spring 

00:12:53.090 --> 00:13:00.410
所以在这种情况下，您确切知道该怎么做

00:12:56.180 --> 00:13:02.300
期待，所以你需要拥有这个

00:13:00.410 --> 00:13:05.990
我们称之为走吧，我们有两个主题

00:13:02.300 --> 00:13:10.370
生产，我们将其称为

00:13:05.990 --> 00:13:13.100
电影制片人和雷尼的制片人

00:13:10.370 --> 00:13:17.210
在这种情况下，我们将拥有卡夫卡

00:13:13.100 --> 00:13:19.880
模板第一个将使用很长的时间是

00:13:17.210 --> 00:13:22.520
我们的类型和电影一起去是我们的

00:13:19.880 --> 00:13:27.830
值，我们将其称为电影

00:13:22.520 --> 00:13:28.940
每封邮件的Kafka模板密钥和

00:13:27.830 --> 00:13:30.950
那么你就拥有了信息的价值

00:13:28.940 --> 00:13:32.600
再次，这不像消息队列

00:13:30.950 --> 00:13:34.100
倾斜队列不仅是一项工作， 

00:13:32.600 --> 00:13:36.440
存储数据，实际上更多

00:13:34.100 --> 00:13:39.410
就像地图一样，您实际上可以将其编入索引

00:13:36.440 --> 00:13:40.970
通过他们进入队列中的消息

00:13:39.410 --> 00:13:42.110
键，所以当您使用Kafka时

00:13:40.970 --> 00:13:43.780
模板，您必须同时考虑两者

00:13:42.110 --> 00:13:46.790
键的类型和时间值

00:13:43.780 --> 00:13:49.630
为了使这项工作，我们需要

00:13:46.790 --> 00:13:51.740
有某种配置，所以

00:13:49.630 --> 00:13:52.790
好吧，是的

00:13:51.740 --> 00:13:55.370
在这种情况下，我们需要

00:13:52.790 --> 00:13:57.230
配置类，这样我们就可以使用

00:13:55.370 --> 00:14:05.900
这里的配置是的，我们也赢了

00:13:57.230 --> 00:14:07.640
这种情况下，我们只是把这个

00:14:05.900 --> 00:14:09.890
在这里，让我们将别针放在这里

00:14:07.640 --> 00:14:12.500
我们将尝试将其部署在

00:14:09.890 --> 00:14:18.050
现在生产以便工作

00:14:12.500 --> 00:14:21.110
这项工作，我们需要有这个好吧

00:14:18.050 --> 00:14:25.270
是的，为了做到这一点，我们需要

00:14:21.110 --> 00:14:25.270
我们需要通过配置吗

00:14:28.540 --> 00:14:39.710
是的，所以我们会知道

00:14:33.650 --> 00:14:43.840
叫生产者工厂

00:14:39.710 --> 00:14:47.050
生产者默认默认值还是

00:14:43.840 --> 00:14:51.080
默认生产者

00:14:47.050 --> 00:14:55.690
是的，在生产工厂之前

00:14:51.080 --> 00:14:58.209
工厂，所以我们需要做什么

00:14:55.690 --> 00:15:03.399
全部归还

00:14:58.209 --> 00:15:06.370
一些新的默认默认生产者

00:15:03.399 --> 00:15:10.000
工厂，在这种情况下，这个家伙也

00:15:06.370 --> 00:15:12.100
对Spring 工艺了解很多

00:15:10.000 --> 00:15:14.140
一个框架知道很多事情

00:15:12.100 --> 00:15:15.370
如何配置，所以有很多

00:15:14.140 --> 00:15:16.450
如果你在这个地方做的话

00:15:15.370 --> 00:15:18.250
您不需要提供的开发

00:15:16.450 --> 00:15:20.589
就像当地的整个步骤

00:15:18.250 --> 00:15:21.730
像在这种情况下，我们需要提供所有

00:15:20.589 --> 00:15:23.320
这些信息，因为我们要

00:15:21.730 --> 00:15:24.579
使用金诗句注册表，我们需要

00:15:23.320 --> 00:15:26.320
提供信息服务的是

00:15:24.579 --> 00:15:28.720
明智的乔治只是

00:15:26.320 --> 00:15:30.490
提到价值的关键是

00:15:28.720 --> 00:15:33.610
我们在哪里消毒过

00:15:30.490 --> 00:15:37.110
这样做，我们将取代它

00:15:33.610 --> 00:15:40.420
通过，所以我们有这张地图

00:15:37.110 --> 00:15:47.529
所谓的配置图

00:15:40.420 --> 00:15:51.760
配置新的哈希图，将被缩小

00:15:47.529 --> 00:15:55.120
然后我们串起，在这种情况下，我们将

00:15:51.760 --> 00:15:57.250
确实像开始编程那样观察：和

00:15:55.120 --> 00:16:04.839
我忘记了这个，你可以看到

00:15:57.250 --> 00:16:07.870
正是这样，我们将拥有这把枪的东西

00:16:04.839 --> 00:16:10.420
并认为这将是现场编码

00:16:07.870 --> 00:16:14.890
所以我们会有这个引导网址

00:16:10.420 --> 00:16:17.320
生产者配置，所以我们有这个生产者

00:16:14.890 --> 00:16:19.480
配置，我们在其中有一个引导网址

00:16:17.320 --> 00:16:24.640
在这种情况下，我们会说它将

00:16:19.480 --> 00:16:28.420
 localhost 1992我们将在这里考虑

00:16:24.640 --> 00:16:30.100
需要什么来源的东西

00:16:28.420 --> 00:16:34.410
有一个模式注册欧元

00:16:30.100 --> 00:16:40.959
情况下，我们将成为架构注册表

00:16:34.410 --> 00:16:44.880
 ray g3您是Al，我们需要有一个

00:16:40.959 --> 00:16:46.500
 HTTP显然在生产中要做HTTP 

00:16:44.880 --> 00:16:50.680
 localhost 

00:16:46.500 --> 00:16:56.399
 1981年，另外两件事负责

00:16:50.680 --> 00:17:01.510
用于减速器配置生产者配置和

00:16:56.399 --> 00:17:03.820
我们需要一个关键的消毒吻

00:17:01.510 --> 00:17:06.110
在这种情况下，您的Eliza班级将会

00:17:03.820 --> 00:17:12.860
成为

00:17:06.110 --> 00:17:14.240
在这种情况下自然很长

00:17:12.860 --> 00:17:18.079
有很多，但我们需要

00:17:14.240 --> 00:17:19.760
想要卡夫卡课和另一件事

00:17:18.079 --> 00:17:24.919
因为我们将要使用所有这些

00:17:19.760 --> 00:17:30.519
永远很棒的东西哦，它将起作用

00:17:24.919 --> 00:17:37.460
所以我们有生产者配置和

00:17:30.519 --> 00:17:44.110
值消毒器，所以2 2 2我们将

00:17:37.460 --> 00:17:46.279
有卡夫卡一个兄弟一个兄弟有AF 

00:17:44.110 --> 00:17:48.470
序列化器有很多东西

00:17:46.279 --> 00:17:51.679
我们只需要在这一堂课中使用一个

00:17:48.470 --> 00:17:53.240
好吧，所以我们有这个冲突

00:17:51.679 --> 00:17:57.919
对的，所以我们将其传递给默认值

00:17:53.240 --> 00:18:03.340
工厂现在我们有两件事

00:17:57.919 --> 00:18:06.080
配置，所以可能应该是它

00:18:03.340 --> 00:18:07.580
在我们的配置中，下一件事

00:18:06.080 --> 00:18:09.260
我们需要做的是

00:18:07.580 --> 00:18:11.059
主题定义，因为Kafka是

00:18:09.260 --> 00:18:13.730
处理主题概念和

00:18:11.059 --> 00:18:16.070
主题是我们分配的实体

00:18:13.730 --> 00:18:19.549
跨多个卡夫卡知道很酷

00:18:16.070 --> 00:18:21.919
事情是，Spring 工艺

00:18:19.549 --> 00:18:26.149
整合物 Spring 卡夫卡

00:18:21.919 --> 00:18:26.299
项目具有创建主题的能力

00:18:26.149 --> 00:18:33.649
我们

00:18:26.299 --> 00:18:44.889
所以我想我想念斌了

00:18:33.649 --> 00:18:44.889
有一个新的课程主题

00:18:48.210 --> 00:18:57.669
 topic topic，您会返回新的

00:18:52.929 --> 00:19:00.279
主题好吧，新的，新的，再次，这是

00:18:57.669 --> 00:19:03.220
我也怪Kotlin，因为我刚开始

00:19:00.279 --> 00:19:09.490
设置我的东西，以便我们拥有主题名称

00:19:03.220 --> 00:19:10.779
电影中的这个话题，这是一个

00:19:09.490 --> 00:19:12.850
这是一个配置

00:19:10.779 --> 00:19:14.679
负责数据的持久性

00:19:12.850 --> 00:19:17.080
复制因子，我们将成为

00:19:14.679 --> 00:19:20.710
在这里做很酷的事情

00:19:17.080 --> 00:19:29.710
意思是你知道黄色

00:19:20.710 --> 00:19:34.990
没有复制是，我们会做评级

00:19:29.710 --> 00:19:39.429
顺利进行评分主题，对吗？ 

00:19:34.990 --> 00:19:45.639
返回新的新主题和同一件事

00:19:39.429 --> 00:19:50.460
请问您的收视率，所以其中之一

00:19:45.639 --> 00:19:52.870
开发人员通常要做的是

00:19:50.460 --> 00:19:54.940
在或之前预先设置这些主题

00:19:52.870 --> 00:19:57.070
一些操作人员提供，所以

00:19:54.940 --> 00:20:00.009
这个集成的很棒的事情

00:19:57.070 --> 00:20:02.289
或此代码，您不需要

00:20:00.009 --> 00:20:03.850
检查是否存在主题

00:20:02.289 --> 00:20:06.429
会用它而我会用

00:20:03.850 --> 00:20:08.259
此定义并在此处插入主题

00:20:06.429 --> 00:20:09.850
不存在，它将如此创建并

00:20:08.259 --> 00:20:13.090
 Spring 提供的很酷的东西

00:20:09.850 --> 00:20:16.299
这些功能正是

00:20:13.090 --> 00:20:18.009
它将起作用，因为在这种情况下，我们

00:20:16.299 --> 00:20:21.809
有美好的工厂和 Spring 

00:20:18.009 --> 00:20:21.809
将能够按类型弄清楚

00:20:24.929 --> 00:20:33.070
是的，所以我要输入George 

00:20:29.350 --> 00:20:35.019
加上因素，因为我们有这个

00:20:33.070 --> 00:20:37.240
数据格式非常

00:20:35.019 --> 00:20:39.460
进取的意思是我们这种文本格式

00:20:37.240 --> 00:20:43.809
需要进行解析，因此我们将带来一个

00:20:39.460 --> 00:20:48.090
我们将在之后称为解析器的小东西

00:20:43.809 --> 00:20:48.090
重构应用

00:20:50.279 --> 00:21:02.830
被称为强迫症的严重病例

00:21:00.070 --> 00:21:05.380
没有si Jin barf向下滚动向下滚动

00:21:02.830 --> 00:21:09.450
起来起来起来，你看到这是图形的

00:21:05.380 --> 00:21:09.450
版本，所以我们在正确的轨道上

00:21:10.889 --> 00:21:19.570
是的，所以你会去你去

00:21:13.990 --> 00:21:23.230
这个家伙也是卡夫卡主题， 

00:21:19.570 --> 00:21:28.210
一个称为列表的注释，在这种情况下

00:21:23.230 --> 00:21:34.169
我们将有一个 Zookeeper ，它在哪里

00:21:28.210 --> 00:21:40.200
有一个 Zookeeper ，所以我们做 Zookeeper 

00:21:34.169 --> 00:21:43.690
你会想要 localhost 21 

00:21:40.200 --> 00:21:45.460
太神奇了，我想我们已经走了一半

00:21:43.690 --> 00:21:47.379
创建主题而不创建主题

00:21:45.460 --> 00:21:51.100
只用一个 spring boot ，我认为这是一个

00:21:47.379 --> 00:21:53.519
这是个好东西，可怜的先生响了

00:21:51.100 --> 00:21:53.519
可怜的先生

00:21:58.960 --> 00:22:06.120
关于这个酒吧的 Spring G所以你就是你

00:22:01.509 --> 00:22:06.120
阅读该行，你知道吗

00:22:10.769 --> 00:22:17.620
我也不以维克多为荣

00:22:14.529 --> 00:22:18.610
我们编写此代码时

00:22:17.620 --> 00:22:36.460
我们是否互相说过

00:22:18.610 --> 00:22:38.289
干得好，它使用流您

00:22:36.460 --> 00:22:43.019
看到天气有些冷

00:22:38.289 --> 00:22:43.019
有一些值得骄傲的事情

00:22:46.620 --> 00:22:51.129
好了，所以把文件放进去，所以我们需要

00:22:49.539 --> 00:22:53.200
从某处读取文件

00:22:51.129 --> 00:22:56.659
在这种情况下，我们需要同时

00:22:53.200 --> 00:22:58.999
我们应用程序的端点

00:22:56.659 --> 00:23:01.840
我要告诉我我是发现者

00:22:58.999 --> 00:23:04.369
要在这里复制意大利面

00:23:01.840 --> 00:23:10.099
好吧，当然

00:23:04.369 --> 00:23:13.599
不要打破哇，那不是

00:23:10.099 --> 00:23:19.009
相当多，因为它有900 

00:23:13.599 --> 00:23:28.749
文字行相当不是

00:23:19.009 --> 00:23:28.749
不是那么大是一些洒

00:23:40.179 --> 00:23:52.909
电影，在这种情况下，我们将成为

00:23:50.450 --> 00:23:54.289
在现实生活中使用此文件

00:23:52.909 --> 00:23:56.869
 kafka的工作方式

00:23:54.289 --> 00:23:58.759
连接后的管道将

00:23:56.869 --> 00:24:00.710
聆听一些旧数据

00:23:58.759 --> 00:24:03.710
数据源，例如数据库和抽水

00:24:00.710 --> 00:24:05.869
将此数据导入Kafka或可以使用

00:24:03.710 --> 00:24:09.139
同一生产者-消费者去做

00:24:05.869 --> 00:24:11.029
所以在这种情况下，我们会做

00:24:09.139 --> 00:24:14.210
老式的方式，我们将读取文件或

00:24:11.029 --> 00:24:15.739
一行一行地阅读，所以我不

00:24:14.210 --> 00:24:18.049
记得喜欢如何从中读取文件

00:24:15.739 --> 00:24:20.539
好的，这在哪里

00:24:18.049 --> 00:24:23.359
它只是让我们复制让我们复制我们的

00:24:20.539 --> 00:24:25.399
方法并保存好东西，所以既然我们

00:24:23.359 --> 00:24:25.849
就像我说过的那样，我们并不为此感到自豪

00:24:25.399 --> 00:24:29.049
这些东西

00:24:25.849 --> 00:24:31.820
是的，这就是我们的正确做法

00:24:29.049 --> 00:24:34.549
我们要这样做我们要这样做

00:24:31.820 --> 00:24:40.039
我们将要复制粘贴内容，以便

00:24:34.549 --> 00:24:48.440
这样做，所以这是好东西

00:24:40.039 --> 00:24:51.399
对，所以您可以按需进口或港口

00:24:48.440 --> 00:24:55.940
现在我们正在看电影文件

00:24:51.399 --> 00:24:59.090
我们有正确的Java版本吗

00:24:55.940 --> 00:25:02.619
可能是的，所以在游戏中移动它

00:24:59.090 --> 00:25:05.899
我们有它的工作质量，我们称之为

00:25:02.619 --> 00:25:17.539
切片，我们在这里右移

00:25:05.899 --> 00:25:22.220
放好，所以下一个是我们的

00:25:17.539 --> 00:25:23.960
模板在哪里不起作用移动它

00:25:22.220 --> 00:25:25.729
好吧，电影主题是一些

00:25:23.960 --> 00:25:31.519
我们也将复制的常量，因为

00:25:25.729 --> 00:25:34.039
这是两个很酷的东西

00:25:31.519 --> 00:25:36.739
我们通常使用的主题名称

00:25:34.039 --> 00:25:39.019
 spring boot 配置的东西

00:25:36.739 --> 00:25:42.379
像这样通过这种

00:25:39.019 --> 00:25:52.549
配置，如果您正在运行此

00:25:42.379 --> 00:25:55.099
在某种程度上，我发布了新的

00:25:52.549 --> 00:25:56.509
每个星期三的 Spring 提示视频

00:25:55.099 --> 00:25:59.690
有一个新视频，昨天我

00:25:56.509 --> 00:26:01.729
介绍了如何使用spring batch来

00:25:59.690 --> 00:26:03.589
处理来自Kafka的大量数据

00:26:01.729 --> 00:26:05.539
与我们正在做的ETL完全一样

00:26:03.589 --> 00:26:07.399
在这里我真的认为我应该有

00:26:05.539 --> 00:26:09.559
在我们上台之前提出来

00:26:07.399 --> 00:26:11.989
虽然可能有所不同

00:26:09.559 --> 00:26:14.720
说话的 Spring 分支 Spring 

00:26:11.989 --> 00:26:23.649
流哦，昏迷你要注射这个吗

00:26:14.720 --> 00:26:23.649
在这里，为什么不是我们

00:26:27.680 --> 00:26:38.090
哦，它没有分配给任何

00:26:37.130 --> 00:26:41.270
不错

00:26:38.090 --> 00:26:43.580
他一直在写的好东西

00:26:41.270 --> 00:26:47.900
很多Kotlin，所以在Kotlin

00:26:43.580 --> 00:26:53.720
构造函数是存储是的，不要

00:26:47.900 --> 00:26:55.220
是的，只是，然后你会看到

00:26:53.720 --> 00:27:01.010
当我做下一个演讲时，我会

00:26:55.220 --> 00:27:02.870
用率唱来做，他是

00:27:01.010 --> 00:27:18.530
如果你是你的你会挣扎

00:27:02.870 --> 00:27:20.540
四人好的好的好的好的好的

00:27:18.530 --> 00:27:26.360
好的模板模板，我们有一个

00:27:20.540 --> 00:27:32.540
是不同的名字，是的，所以和你一样

00:27:26.360 --> 00:27:34.250
可以看到这就是我们如何称呼它

00:27:32.540 --> 00:27:35.990
这就像框架编程是

00:27:34.250 --> 00:27:38.840
基本上只是一个罐子

00:27:35.990 --> 00:27:40.490
一些复制粘贴的东西，这是什么

00:27:38.840 --> 00:27:46.160
你在互联网上发现只有你

00:27:40.490 --> 00:27:49.430
复制粘贴，但是恰好有两件事

00:27:46.160 --> 00:27:52.160
我们确实有电影模板

00:27:49.430 --> 00:27:53.810
将使用它来产生这个数据

00:27:52.160 --> 00:27:55.760
如果这件事有不同的变化

00:27:53.810 --> 00:27:57.140
你更喜欢同步风格

00:27:55.760 --> 00:27:59.450
编程就像一个可玩的游戏

00:27:57.140 --> 00:28:00.890
未来或喜欢听未来

00:27:59.450 --> 00:28:07.480
可以变成可完成的

00:28:00.890 --> 00:28:07.480
现在就开始吧

00:28:10.310 --> 00:28:14.170
我们有合流，你知道我记得

00:28:19.690 --> 00:28:25.999
它就在构建周围

00:28:22.790 --> 00:28:31.169
删除这个家伙，这个删除是的

00:28:25.999 --> 00:28:42.889
电影电影和是的电影都很好

00:28:31.169 --> 00:28:51.269
是的，完美的爱情流

00:28:42.889 --> 00:28:54.259
删除这两个破折号是是是

00:28:51.269 --> 00:28:54.259
那可行

00:28:56.480 --> 00:29:00.299
好吧好吧

00:28:58.379 --> 00:29:02.129
这样的会计，让我们看看是否

00:29:00.299 --> 00:29:02.789
实际上这里有东西，所以

00:29:02.129 --> 00:29:06.059
您

00:29:02.789 --> 00:29:08.899
请问我们的终点站在哪里

00:29:06.059 --> 00:29:08.899
合流

00:29:17.600 --> 00:29:29.850
作品哎呀作品正确，我们

00:29:25.020 --> 00:29:31.860
应该看到一些数据流

00:29:29.850 --> 00:29:33.720
但是有一秒钟的人在说什么

00:29:31.860 --> 00:29:38.360
到底我要告诉你什么

00:29:33.720 --> 00:29:38.360
因为我们没有指定值格式

00:29:39.050 --> 00:29:49.530
现在看到啊，那只鸡你

00:29:45.120 --> 00:29:51.690
看到一切都不同好吧，是的

00:29:49.530 --> 00:29:54.720
是的，所以没有理由

00:29:51.690 --> 00:29:56.640
是的，是的，终端啊，我们需要这样做

00:29:54.720 --> 00:29:59.550
因为这是全屏滑动

00:29:56.640 --> 00:30:01.650
刷是的，所以这样做的原因是这样，我们

00:29:59.550 --> 00:30:04.410
开始从或读取数据

00:30:01.650 --> 00:30:06.660
在我们的java文件中生成数据

00:30:04.410 --> 00:30:08.370
然后我们将这些数据发送到

00:30:06.660 --> 00:30:09.600
 Kafka这就是Kafka真正的东西

00:30:08.370 --> 00:30:11.070
不在乎你会什么样的东西

00:30:09.600 --> 00:30:12.780
放一些人甚至放文件

00:30:11.070 --> 00:30:14.820
我不是说这是个好主意

00:30:12.780 --> 00:30:16.500
也许如果你开始把这些

00:30:14.820 --> 00:30:19.680
卡夫卡中的文件，您需要考虑您的

00:30:16.500 --> 00:30:22.020
人生一般的选择，但我不是

00:30:19.680 --> 00:30:24.780
一个可以判断的就是我们

00:30:22.020 --> 00:30:26.430
实际上尝试使用二进制格式

00:30:24.780 --> 00:30:28.260
我们正在尝试简化和减少

00:30:26.430 --> 00:30:30.120
有效负载，这就是为什么您会看到此内容

00:30:28.260 --> 00:30:32.010
此二进制数据的输出，因为

00:30:30.120 --> 00:30:35.700
控制台将无法读取此内容

00:30:32.010 --> 00:30:37.920
出来，像平均二进制

00:30:35.700 --> 00:30:41.160
格式化我们存储架构的另一件事

00:30:37.920 --> 00:30:42.720
不作为我们有效载荷的一部分

00:30:41.160 --> 00:30:45.180
在这种情况下，我们的有效负载变为偶数

00:30:42.720 --> 00:30:47.730
较小，我们不存储方案

00:30:45.180 --> 00:30:49.230
每条消息，以便下次您尝试时

00:30:47.730 --> 00:30:51.240
阅读此计划的读者将

00:30:49.230 --> 00:30:52.920
返回这个，它也会在本地

00:30:51.240 --> 00:30:55.640
缓存在您的应用程序返回中

00:30:52.920 --> 00:30:58.410
模式和序列化程序，因为

00:30:55.640 --> 00:31:00.660
我们的二元菜知道如何

00:30:58.410 --> 00:31:03.270
反序列化本身就是您知道的

00:31:00.660 --> 00:31:05.820
被调用，我们会把东西带进来

00:31:03.270 --> 00:31:16.440
所以我们现在有一个数据，我们需要

00:31:05.820 --> 00:31:17.910
开始做一些过程20 

00:31:16.440 --> 00:31:20.200
 Spring 的代码流是一个

00:31:17.910 --> 00:31:23.150
使您能够

00:31:20.200 --> 00:31:25.130
描述消息代理中的

00:31:23.150 --> 00:31:27.410
可以的通用时尚

00:31:25.130 --> 00:31:30.050
拔掉

00:31:27.410 --> 00:31:31.750
将这些代理路由到配置中

00:31:30.050 --> 00:31:33.680
文件，然后Spring 代码流

00:31:31.750 --> 00:31:35.540
实现您需要的东西

00:31:33.680 --> 00:31:37.790
确实在

00:31:35.540 --> 00:31:39.380
有效的方法，因此一种方法是使用

00:31:37.790 --> 00:31:41.450
 Spring Framework消息传递通道

00:31:39.380 --> 00:31:42.680
消息通道相当抽象， 

00:31:41.450 --> 00:31:45.560
这可以让您考虑

00:31:42.680 --> 00:31:47.090
下游经纪人就像你一样

00:31:45.560 --> 00:31:49.700
知道管道另一端的东西

00:31:47.090 --> 00:31:51.740
你会看到的那种管道

00:31:49.700 --> 00:31:54.200
在 Spring Integration 中

00:31:51.740 --> 00:31:56.990
我说管道II确实意味着建议我这样做

00:31:54.200 --> 00:31:58.790
意图引用皮大衣的想法

00:31:56.990 --> 00:32:01.250
另一方面，如果使用纹理

00:31:58.790 --> 00:32:04.190
卡夫卡溪流的spring-cloud-stream

00:32:01.250 --> 00:32:06.050
您可以使用更多类型

00:32:04.190 --> 00:32:07.790
与Kafka合作的人很自然

00:32:06.050 --> 00:32:09.410
溪流，尤其是在卡夫卡

00:32:07.790 --> 00:32:12.170
流你有两种思维方式

00:32:09.410 --> 00:32:14.330
关于您似乎拥有的数据

00:32:12.170 --> 00:32:15.620
阻止你就在那里，因为有人

00:32:14.330 --> 00:32:17.330
我可能不知道卡夫卡街

00:32:15.620 --> 00:32:20.540
你们当中有多少人听说过卡夫卡

00:32:17.330 --> 00:32:23.600
流哦，好吧，你好，卡夫卡

00:32:20.540 --> 00:32:25.580
卡夫卡街上流的只是

00:32:23.600 --> 00:32:26.990
一个库，它是Apache Kafka的一部分

00:32:25.580 --> 00:32:28.460
它是流的嵌入式框架

00:32:26.990 --> 00:32:30.230
就是这样处理

00:32:28.460 --> 00:32:32.300
这就是为什么这是一个很好的

00:32:30.230 --> 00:32:34.250
与卡夫卡·奥利弗打交道的想法

00:32:32.300 --> 00:32:36.830
 Spring Boot只是另一项工作

00:32:34.250 --> 00:32:38.870
流处理管道，但何时

00:32:36.830 --> 00:32:40.970
您正在使用Kafka串流

00:32:38.870 --> 00:32:43.460
可以建立处理

00:32:40.970 --> 00:32:46.460
管道，对我来说，我成为

00:32:43.460 --> 00:32:47.810
我想对卡夫卡流感兴趣

00:32:46.460 --> 00:32:49.940
做很多人做的事情

00:32:47.810 --> 00:32:52.550
否则可能会像

00:32:49.940 --> 00:32:55.010
火花，我想拥有那种

00:32:52.550 --> 00:32:57.650
功能而无需部署

00:32:55.010 --> 00:33:00.530
和管理火花，所以我一直在寻找

00:32:57.650 --> 00:33:02.300
你知道我想要的东西

00:33:00.530 --> 00:33:05.600
没有尽可能多的功能

00:33:02.300 --> 00:33:08.750
必须支付复杂性成本

00:33:05.600 --> 00:33:11.270
弄清楚您的应用程序在哪里

00:33:08.750 --> 00:33:14.060
正在运行如何像这样存储您的状态

00:33:11.270 --> 00:33:17.420
您将如何提交这份工作

00:33:14.060 --> 00:33:19.580
可以处理一些复杂的管道， 

00:33:17.420 --> 00:33:21.530
如何恢复以及所有这些东西正确

00:33:19.580 --> 00:33:23.180
现在卡夫卡很久了，你已经在卡夫卡了

00:33:21.530 --> 00:33:24.980
您的组织可以使用Kafka 

00:33:23.180 --> 00:33:26.390
流卡夫卡是您订购所需的一切

00:33:24.980 --> 00:33:29.150
运行它，所以你可以写

00:33:26.390 --> 00:33:30.500
那个 Spring 用任何语言编写的代码

00:33:29.150 --> 00:33:32.639
靴子，你知道我可以用 spring boot 

00:33:30.500 --> 00:33:34.529
加卡夫卡流很容易

00:33:32.639 --> 00:33:36.749
就是这样，任何支持的事情

00:33:34.529 --> 00:33:38.519
 Spring Boot Cartland Java groovy 

00:33:36.749 --> 00:33:41.070
无论Scala什么都行不通

00:33:38.519 --> 00:33:42.749
在Kafka的尖叫声中表现不错

00:33:41.070 --> 00:33:46.109
您有两种类型，一种叫做K 

00:33:42.749 --> 00:33:49.709
桌子是什么K桌子K桌子是

00:33:46.109 --> 00:33:52.619
国家的代表，所以有两个

00:33:49.709 --> 00:33:56.190
您可能在这里拥有的东西类型

00:33:52.619 --> 00:33:58.499
事物的历史和状态

00:33:56.190 --> 00:34:00.209
事物的状态

00:33:58.499 --> 00:34:01.679
表示我们可以创建此表

00:34:00.209 --> 00:34:03.779
可以说我们知道例如

00:34:01.679 --> 00:34:06.059
电影四个特别的能量

00:34:03.779 --> 00:34:09.299
这个时候有这个特别

00:34:06.059 --> 00:34:11.129
值第二个显然是卡夫卡

00:34:09.299 --> 00:34:13.770
流代表了它的历史

00:34:11.129 --> 00:34:18.750
代表发生的所有事实

00:34:13.770 --> 00:34:21.059
在特定的时间之类的时间内

00:34:18.750 --> 00:34:23.129
所以本质上它映射到什么

00:34:21.059 --> 00:34:26.760
 Kafka将地图流式传输到Kafka主题中

00:34:23.129 --> 00:34:28.919
 caf K表映射到紧凑的顶部

00:34:26.760 --> 00:34:31.200
因此，将主题压缩为一种特殊的

00:34:28.919 --> 00:34:33.210
卡夫卡内部存储的存储

00:34:31.200 --> 00:34:34.529
只有最新和最大的价值

00:34:33.210 --> 00:34:36.809
特定键权

00:34:34.529 --> 00:34:38.339
还有另一件事我只是想

00:34:36.809 --> 00:34:39.539
提到这个，因为你提到

00:34:38.339 --> 00:34:40.529
不同的语言，我想

00:34:39.539 --> 00:34:43.079
提一点组装

00:34:40.529 --> 00:34:45.059
这里的语言，所以像消费者

00:34:43.079 --> 00:34:47.010
制片人和卡夫卡的一点点

00:34:45.059 --> 00:34:49.500
模板就是我们认为的

00:34:47.010 --> 00:34:51.510
低级API是您处理这些

00:34:49.500 --> 00:34:53.700
就像个人发送消息一样

00:34:51.510 --> 00:34:56.190
卡夫卡流更多的消息

00:34:53.700 --> 00:34:57.839
喜欢让您处理

00:34:56.190 --> 00:35:00.029
功能方法Kafka流具有

00:34:57.839 --> 00:35:03.900
两个两个类型两个字段，这是一个DSL 

00:35:00.029 --> 00:35:06.210
看起来像Java 8流API 

00:35:03.900 --> 00:35:08.190
还有适当的处理器API 

00:35:06.210 --> 00:35:10.529
在这次演讲中不会碰到这个

00:35:08.190 --> 00:35:14.250
但它也可以让您建立

00:35:10.529 --> 00:35:16.859
复杂的数据管道，因此在您工作时

00:35:14.250 --> 00:35:19.049
我所知道的，以及大多数

00:35:16.859 --> 00:35:20.609
匹配消息传递技术

00:35:19.049 --> 00:35:21.720
你必须考虑很多

00:35:20.609 --> 00:35:24.180
首先需要注意的事情

00:35:21.720 --> 00:35:26.819
所有如何连接到这个东西

00:35:24.180 --> 00:35:29.279
而且由于我正在编写通用Java 

00:35:26.819 --> 00:35:32.369
我正在使用绑定代码，所以这是

00:35:29.279 --> 00:35:34.230
此接口定义的接口

00:35:32.369 --> 00:35:36.329
我想要 Spring 代码的绑定

00:35:34.230 --> 00:35:38.309
在 Spring 为我管理

00:35:36.329 --> 00:35:40.859
代码流Kafka串应用程序所以

00:35:38.309 --> 00:35:43.349
我说的是嘿，我的Spring代码流

00:35:40.859 --> 00:35:44.910
这个东西叫做电影

00:35:43.349 --> 00:35:45.869
现在这是一个逻辑名称

00:35:44.910 --> 00:35:47.999
给它

00:35:45.869 --> 00:35:50.970
我可以理解的逻辑名称

00:35:47.999 --> 00:35:53.069
在我的代码中，逻辑映射

00:35:50.970 --> 00:35:55.079
实际经纪人的姓名在

00:35:53.069 --> 00:35:57.059
配置条款，因此您可以

00:35:55.079 --> 00:35:59.130
看到这里我把电影当成逻辑

00:35:57.059 --> 00:36:01.349
名称和配置在这里

00:35:59.130 --> 00:36:03.809
有电影，所以这是春暖花开的溪流

00:36:01.349 --> 00:36:06.059
绑定点电影，然后我指定

00:36:03.809 --> 00:36:08.220
我可以的应用程序ID之类的东西

00:36:06.059 --> 00:36:09.869
指定诸如目的地之类的东西

00:36:08.220 --> 00:36:12.480
实际话题的经纪人我们如何

00:36:09.869 --> 00:36:14.490
应该对标题开始头进行编码

00:36:12.480 --> 00:36:15.749
我们应该解码，所有这些

00:36:14.490 --> 00:36:17.819
特定的东西在

00:36:15.749 --> 00:36:19.619
配置我不必担心

00:36:17.819 --> 00:36:21.329
关于这一切，因为它是在

00:36:19.619 --> 00:36:22.980
属性文件，并且可以存在于

00:36:21.329 --> 00:36:24.630
配置服务器的例子和 Spring 

00:36:22.980 --> 00:36:26.400
俱乐部配置服务器或其他地方

00:36:24.630 --> 00:36:28.259
不必在我的Java代码中

00:36:26.400 --> 00:36:30.210
很难理解

00:36:28.259 --> 00:36:31.980
一目了然，这也很多

00:36:30.210 --> 00:36:33.299
很难改变，显然在

00:36:31.980 --> 00:36:35.369
生产中您可能具有不同的URL 

00:36:33.299 --> 00:36:36.960
用于Kafka引导程序的方案注册表

00:36:35.369 --> 00:36:37.710
服务器，以便此信息可以是

00:36:36.960 --> 00:36:41.039
外在化

00:36:37.710 --> 00:36:42.569
甚至在运行时弹出

00:36:41.039 --> 00:36:44.160
我们已经完成了提取

00:36:42.569 --> 00:36:46.559
我只是说基本上我是

00:36:44.160 --> 00:36:49.200
期望得到数据，我想工作

00:36:46.559 --> 00:36:52.289
从K表API开始

00:36:49.200 --> 00:36:53.880
电影主题好吧，我有数据

00:36:52.289 --> 00:36:56.220
收视率主题，我希望能正常工作

00:36:53.880 --> 00:36:57.239
作为案例流，我有数据

00:36:56.220 --> 00:36:59.009
那将来自

00:36:57.239 --> 00:37:00.539
平均表主题，我希望一些

00:36:59.009 --> 00:37:02.309
像这样在那工作，然后

00:37:00.539 --> 00:37:05.009
最后我有两个输出

00:37:02.309 --> 00:37:06.660
将数据发送到这些案例流，这样

00:37:05.009 --> 00:37:08.430
这些是我可以掌握的这些

00:37:06.660 --> 00:37:08.670
他们完全初始化的引用

00:37:08.430 --> 00:37:10.499
我

00:37:08.670 --> 00:37:12.599
通过 Spring 代码流，我可以

00:37:10.499 --> 00:37:14.430
开始处理即将到来的数据

00:37:12.599 --> 00:37:16.470
他们或者我可以开始发送数据

00:37:14.430 --> 00:37:18.599
对他们来说现在好了

00:37:16.470 --> 00:37:20.519
输出您实际上不使用您不

00:37:18.599 --> 00:37:21.960
实际上抓住了对

00:37:20.519 --> 00:37:24.539
案例流并将任何内容发送给

00:37:21.960 --> 00:37:27.720
在这种情况下，您将不是

00:37:24.539 --> 00:37:29.309
春船方式或Spring Cloud方式

00:37:27.720 --> 00:37:32.730
我们将使用依赖

00:37:29.309 --> 00:37:34.049
注射在这里，所以现在我们要

00:37:32.730 --> 00:37:35.970
做两件事我认为第一件事是

00:37:34.049 --> 00:37:38.369
当告诉spring代码流时

00:37:35.970 --> 00:37:41.400
它是这样，并在启用时说

00:37:38.369 --> 00:37:42.779
绑定，所以在这里我们去doc类， 

00:37:41.400 --> 00:37:44.519
然后我们将创建一个

00:37:42.779 --> 00:37:47.220
我要做的第一件事是处理

00:37:44.519 --> 00:37:50.599
游戏我们要启用启用卡夫卡吗

00:37:47.220 --> 00:37:54.089
溪流也应该做

00:37:50.599 --> 00:37:56.160
是的，我们要像

00:37:54.089 --> 00:37:57.930
非常复杂的算法来计算

00:37:56.160 --> 00:38:00.059
电影分级，所以有一个

00:37:57.930 --> 00:38:01.829
不同的不同方法是

00:38:00.059 --> 00:38:04.259
使用更复杂的一个

00:38:01.829 --> 00:38:05.819
我们正在考虑收视率和

00:38:04.259 --> 00:38:08.999
之后，我们要做一些这样的栏杆

00:38:05.819 --> 00:38:10.859
然后我们除以

00:38:08.999 --> 00:38:13.949
计数正确，所以我要创建一个

00:38:10.859 --> 00:38:15.599
流侦听器，这是一个 spring boot 

00:38:13.949 --> 00:38:17.459
组件常规弹跳靴

00:38:15.599 --> 00:38:20.939
将要侦听的组件

00:38:17.459 --> 00:38:25.619
评分主题中出现的消息

00:38:20.939 --> 00:38:27.689
是真的吗，所以绑定

00:38:25.619 --> 00:38:29.759
这种情况下我们真的很在乎

00:38:27.689 --> 00:38:31.680
评级之流，因为我们的另一个

00:38:29.759 --> 00:38:33.119
如果应用其他微服务

00:38:31.680 --> 00:38:36.569
如果您愿意，可以给您另一个标记服务

00:38:33.119 --> 00:38:39.299
将要抽入数据，所以我们感兴趣

00:38:36.569 --> 00:38:40.920
在发生故事的所有事件中

00:38:39.299 --> 00:38:43.559
电影跟我们没什么两样

00:38:40.920 --> 00:38:46.099
谈论电影时，我们会碰触

00:38:43.559 --> 00:38:49.529
基于这样的事情还可以

00:38:46.099 --> 00:38:52.699
还有我们已经阅读的资料了

00:38:49.529 --> 00:38:55.289
那很长，阅读来信

00:38:52.699 --> 00:39:01.949
在这里读书很有趣

00:38:55.289 --> 00:39:03.749
那就是公共无效过程

00:39:01.949 --> 00:39:05.969
有趣的是，卡夫卡还是

00:39:03.749 --> 00:39:09.299
对不起，春佛洒出溪流

00:39:05.969 --> 00:39:12.599
将处理所有这些低层次的

00:39:09.299 --> 00:39:15.269
包括Spring Streams Builder在内的东西

00:39:12.599 --> 00:39:17.160
建立启动Kafka流的拓扑

00:39:15.269 --> 00:39:18.150
应用程序的一切都会

00:39:17.160 --> 00:39:20.459
这样处理，在这种情况下，您只

00:39:18.150 --> 00:39:22.709
专注于这个叫做拓扑的东西

00:39:20.459 --> 00:39:25.199
所以基本上是带有密钥流的东西

00:39:22.709 --> 00:39:27.119
您构建拓扑的关键表

00:39:25.199 --> 00:39:30.769
您的应用程序你们有多少人

00:39:27.119 --> 00:39:33.779
在这里获得图论博士学位

00:39:30.769 --> 00:39:35.429
任何人都可以，所以我可以很聪明

00:39:33.779 --> 00:39:36.989
几秒钟，这就是事情

00:39:35.429 --> 00:39:40.410
有一种叫做定向非循环的东西

00:39:36.989 --> 00:39:42.689
图，而不仅仅是一个简单的图

00:39:40.410 --> 00:39:45.660
图是它的直接含义

00:39:42.689 --> 00:39:47.670
在结尾处有一个开头，在循环中

00:39:45.660 --> 00:39:50.880
意味着里面没有循环，所以

00:39:47.670 --> 00:39:53.400
这是您以前使用的模型

00:39:50.880 --> 00:39:56.189
解释或描述任何数据管道，以便

00:39:53.400 --> 00:39:58.410
基本上，Kafka Streams API为您提供

00:39:56.189 --> 00:40:01.469
您如何建立定向的方式

00:39:58.410 --> 00:40:05.189
非循环图，所以很酷

00:40:01.469 --> 00:40:07.000
不像这里的图论博士，所以我

00:40:05.189 --> 00:40:11.380
可以说

00:40:07.000 --> 00:40:13.570
对，这很完美，很酷

00:40:11.380 --> 00:40:15.130
问题是该应用程序是Kafka 

00:40:13.570 --> 00:40:17.590
双向传输成对流

00:40:15.130 --> 00:40:19.600
描述您的拓扑，以便您可以抓取

00:40:17.590 --> 00:40:22.060
并使用可视化工具查看

00:40:19.600 --> 00:40:24.340
这个图，所以我在这里做的是

00:40:22.060 --> 00:40:26.230
要说的是当数据输入到

00:40:24.340 --> 00:40:31.270
案例流，我要减少它，我是

00:40:26.230 --> 00:40:32.620
要将其变成分组流

00:40:31.270 --> 00:40:34.090
没关系，好​​了

00:40:32.620 --> 00:40:35.650
评分流，我要接受所有

00:40:34.090 --> 00:40:38.080
评分，然后按关键分组

00:40:35.650 --> 00:40:41.380
然后最后从那我要

00:40:38.080 --> 00:40:44.350
然后再拿出另一根电缆

00:40:41.380 --> 00:40:46.600
我要在这里减少添加

00:40:44.350 --> 00:40:49.210
他们在一起，是的，如你所见

00:40:46.600 --> 00:40:51.340
在这里，我们将一个流转换为

00:40:49.210 --> 00:40:52.720
组流，然后我们进行转换

00:40:51.340 --> 00:40:55.000
在密钥表中分组流，因为我们

00:40:52.720 --> 00:40:58.240
对这种状态和方式感兴趣

00:40:55.000 --> 00:41:02.020
收集状态的计数和结束

00:40:58.240 --> 00:41:04.570
最终，总和就是这样，因为

00:41:02.020 --> 00:41:07.030
密钥表具有此方法，因此评分

00:41:04.570 --> 00:41:09.910
计数的流返回密钥表

00:41:07.030 --> 00:41:12.370
将具有有关的所有信息

00:41:09.910 --> 00:41:14.650
特定的键和运行中的运行

00:41:12.370 --> 00:41:17.110
总和和你所要做的一件事

00:41:14.650 --> 00:41:19.470
可能会注意到，不会注意到

00:41:17.110 --> 00:41:22.090
在这段代码中，我们没有办法

00:41:19.470 --> 00:41:23.980
指定存储空间，就像我们在

00:41:22.090 --> 00:41:26.020
数据库，或者我们使用文件，或者我们只是

00:41:23.980 --> 00:41:29.320
将其存储在哈希图中，所以所有这些

00:41:26.020 --> 00:41:31.990
事情由卡夫卡流卡夫卡处理

00:41:29.320 --> 00:41:34.300
流是延迟是框架

00:41:31.990 --> 00:41:36.700
提供您做有状态的能力

00:41:34.300 --> 00:41:39.400
流处理意味着您何时

00:41:36.700 --> 00:41:41.860
您正在计算总和或

00:41:39.400 --> 00:41:43.450
您数数您以计算

00:41:41.860 --> 00:41:46.450
当前步骤，您需要有一个状态

00:41:43.450 --> 00:41:49.150
从过去的权利和卡夫卡流

00:41:46.450 --> 00:41:51.940
让你被覆盖，所以它有各种各样的

00:41:49.150 --> 00:41:53.290
状态存储，可以持久使用

00:41:51.940 --> 00:41:55.810
在这种情况下存储的状态将是

00:41:53.290 --> 00:41:57.400
岩石数据库的小实例

00:41:55.810 --> 00:41:59.800
有所有这些信息可以在

00:41:57.400 --> 00:42:02.380
内存存储中有API我们该如何

00:41:59.800 --> 00:42:03.910
计划自己的商店，冷静思考

00:42:02.380 --> 00:42:06.160
关于这个州立商店

00:42:03.910 --> 00:42:08.320
通过Kafka复制，因此如果

00:42:06.160 --> 00:42:10.660
应用程序墙中断将有一个

00:42:08.320 --> 00:42:12.220
更改卡夫卡内部的日志主题

00:42:10.660 --> 00:42:13.780
下次重新启动时

00:42:12.220 --> 00:42:15.550
您不需要重新处理的应用程序

00:42:13.780 --> 00:42:19.360
您可以检索状态的一切

00:42:15.550 --> 00:42:23.760
来自卡夫卡，所以工作是，让我们

00:42:19.360 --> 00:42:23.760
我们应该看到什么，所以你做了什么

00:42:24.280 --> 00:42:32.680
映射无法移动的值

00:42:28.120 --> 00:42:34.000
准备K街哦，哦，我们有

00:42:32.680 --> 00:42:36.610
一些尚未使用的东西

00:42:34.000 --> 00:42:38.530
所以我们想要阅读我们不想要电影

00:42:36.610 --> 00:42:43.090
只是，我们不希望平均和

00:42:38.530 --> 00:42:46.480
平均读数，所以我们有

00:42:43.090 --> 00:42:49.960
中的读数和等级，我们需要

00:42:46.480 --> 00:42:51.720
有一个评分，我们知道

00:42:49.960 --> 00:42:54.130
正确，好的，让我们再试一次

00:42:51.720 --> 00:42:57.690
那些东西还没有约束

00:42:54.130 --> 00:43:00.820
因此这是行不通的

00:42:57.690 --> 00:43:04.420
好吧发生了什么事

00:43:00.820 --> 00:43:06.490
事情只是脸红了是好的，西里尔的眼睛

00:43:04.420 --> 00:43:08.200
哦，我们需要材料作为数据，所以

00:43:06.490 --> 00:43:09.340
再次，我们将在处理数据

00:43:08.200 --> 00:43:11.230
这个管道，但在中间

00:43:09.340 --> 00:43:13.900
编写流程的步骤

00:43:11.230 --> 00:43:15.370
数据存储到数据库中，因此您必须

00:43:13.900 --> 00:43:18.160
实现数据，这就是

00:43:15.370 --> 00:43:19.540
您知道这很容易

00:43:18.160 --> 00:43:22.750
之后再做，这样你就有了材料

00:43:19.540 --> 00:43:26.200
只要你有足够的意甲天

00:43:22.750 --> 00:43:28.090
这样，然后在点点上加倍

00:43:26.200 --> 00:43:31.900
如今是对ER进行反序列化的灭菌器

00:43:28.090 --> 00:43:33.640
配对好了，再次是Java框架

00:43:31.900 --> 00:43:35.770
处理对象，但卡夫卡

00:43:33.640 --> 00:43:37.540
正在处理二进制文件，所以每次

00:43:35.770 --> 00:43:39.550
当我们需要保存一些东西时

00:43:37.540 --> 00:43:42.280
图形或说一些我们需要的东西

00:43:39.550 --> 00:43:43.780
带来所有这种有趣的乐趣

00:43:42.280 --> 00:43:46.450
诸如序列化和反序列化之类的东西

00:43:43.780 --> 00:43:47.980
错误，有一个像一个

00:43:46.450 --> 00:43:49.570
帮助器类，使您可以

00:43:47.980 --> 00:43:51.070
检索特定类型的消毒器

00:43:49.570 --> 00:43:54.160
像所有这些像标准类型

00:43:51.070 --> 00:43:55.690
支持曾经支持过的还喜欢

00:43:54.160 --> 00:43:58.540
开箱即用的

00:43:55.690 --> 00:44:00.130
能够对此进行调用的灭菌器

00:43:58.540 --> 00:44:06.450
清除这些东西的方法

00:44:00.130 --> 00:44:08.320
我要先运行

00:44:06.450 --> 00:44:11.920
记得我记得是什么

00:44:08.320 --> 00:44:13.600
我们用来存储数据的主题是

00:44:11.920 --> 00:44:15.460
这样我们就可以听听这个话题

00:44:13.600 --> 00:44:17.290
如果我们在这个话题上有什么话

00:44:15.460 --> 00:44:20.530
锤击读数称为AVG等级

00:44:17.290 --> 00:44:22.210
是的，只是擦除一切，因为

00:44:20.530 --> 00:44:24.580
在这种情况下，值格式为

00:44:22.210 --> 00:44:26.440
从来没有，这只是一种Java格式，所以我们

00:44:24.580 --> 00:44:28.450
会看到非常美丽的东西， 

00:44:26.440 --> 00:44:30.970
实际上，您注意到它就像

00:44:28.450 --> 00:44:33.140
 Java序列化的样子

00:44:30.970 --> 00:44:35.240
就像标准的Java可序列化的

00:44:33.140 --> 00:44:37.339
对，这样我们就可以使用很棒的东西

00:44:35.240 --> 00:44:38.690
就像protobuf，我们正在使用Avro 

00:44:37.339 --> 00:44:44.150
我们正在使用节俭我们不使用

00:44:38.690 --> 00:44:45.710
因为看起来很丑对，所以还可以

00:44:44.150 --> 00:44:47.210
我们知道那显然是在做点什么

00:44:45.710 --> 00:44:48.799
正确，它正在向该数据运行数据哦

00:44:47.210 --> 00:44:49.190
呃我们可以把它变成更多的东西吗

00:44:48.799 --> 00:44:51.859
有用

00:44:49.190 --> 00:44:53.329
啊，在这种情况下，它没有用

00:44:51.859 --> 00:44:56.329
因为我们对此没有兴趣

00:44:53.329 --> 00:44:58.039
结果在这种情况下我们像

00:44:56.329 --> 00:44:59.869
通用命令行工具需要

00:44:58.039 --> 00:45:01.609
了解我们需要的Java文明

00:44:59.869 --> 00:45:03.799
带上课和所有这些废话

00:45:01.609 --> 00:45:06.980
好吧，现在我们需要阅读

00:45:03.799 --> 00:45:09.200
电影可能是这样，所以我们有

00:45:06.980 --> 00:45:11.480
这些收视率平均值以及如何

00:45:09.200 --> 00:45:13.250
我们将这样做，我们将加入

00:45:11.480 --> 00:45:15.980
两个流，所以这个Y你有一个

00:45:13.250 --> 00:45:18.470
两个人在街上和在

00:45:15.980 --> 00:45:22.910
这个阶段你需要多少人

00:45:18.470 --> 00:45:26.289
加入两个流，所以我们要说

00:45:22.910 --> 00:45:29.119
第一件事首先是公共无效过程

00:45:26.289 --> 00:45:31.250
我要去的即将上映的电影

00:45:29.119 --> 00:45:35.869
我在这里输入两个不同的东西

00:45:31.250 --> 00:45:37.730
将有绑定点电影是和

00:45:35.869 --> 00:45:41.259
这将是一个漫长的案例

00:45:37.730 --> 00:45:43.730
和电影是电影，然后

00:45:41.259 --> 00:45:46.009
输入，我们不想要电影本身

00:45:43.730 --> 00:45:48.500
这次我们要溢出

00:45:46.009 --> 00:45:49.250
是的，是的，所以它将具有约束力

00:45:48.500 --> 00:45:52.069
这个点

00:45:49.250 --> 00:45:54.799
普通桌子还是我在请客

00:45:52.069 --> 00:45:59.000
我们希望它成为案例流

00:45:54.799 --> 00:46:01.190
好吧，这将是一个很长的类型，所以

00:45:59.000 --> 00:46:02.630
为了我们不要每次都去卡夫卡

00:46:01.190 --> 00:46:04.369
是时候读这个评分了，因为我们

00:46:02.630 --> 00:46:07.190
有两个单独的过程

00:46:04.369 --> 00:46:08.869
这个处理器也那一刻

00:46:07.190 --> 00:46:11.990
乔治在哪里实现

00:46:08.869 --> 00:46:13.400
实际上建立了当地的地方州

00:46:11.990 --> 00:46:15.259
我们可以从本地获取

00:46:13.400 --> 00:46:15.980
状态，这就是为什么我们注入实际

00:46:15.259 --> 00:46:24.200
表

00:46:15.980 --> 00:46:26.029
这将是没有电影联合耶

00:46:24.200 --> 00:46:31.609
我们正在加入电影，是的， 

00:46:26.029 --> 00:46:33.470
联合评级，是的，是的， 

00:46:31.609 --> 00:46:34.970
输入将是电影和双

00:46:33.470 --> 00:46:37.759
并且输出将是额定的

00:46:34.970 --> 00:46:39.559
是的，我们没有的电影是我们创造的

00:46:37.759 --> 00:46:41.720
通过创建一部新的额定电影， 

00:46:39.559 --> 00:46:43.369
是的，复制并粘贴的比较早，是的，我

00:46:41.720 --> 00:46:46.320
你去那就是那是那

00:46:43.369 --> 00:46:49.420
来这里好吗

00:46:46.320 --> 00:46:52.330
所以我要制作一部新的电影

00:46:49.420 --> 00:46:53.980
要成为一个电影点，获得电影ID 

00:46:52.330 --> 00:46:57.030
将成为获得发行年份的电影

00:46:53.980 --> 00:46:59.740
这将是一部获得标题的电影， 

00:46:57.030 --> 00:47:01.840
然后最后是双

00:46:59.740 --> 00:47:03.600
这是评分，是平均值

00:47:01.840 --> 00:47:06.520
以前的评分是

00:47:03.600 --> 00:47:14.310
好吧，所以发生了什么事

00:47:06.520 --> 00:47:20.580
那些看起来不错的电影，乔纳

00:47:14.310 --> 00:47:32.830
是的，哪里出了问题

00:47:20.580 --> 00:47:35.550
这是什么错误是什么不应该

00:47:32.830 --> 00:47:38.950
是双重的，好吧，让我们带上我们

00:47:35.550 --> 00:47:46.440
工作代码肯定总是很好

00:47:38.950 --> 00:47:48.970
以防万一凯特表钥匙表

00:47:46.440 --> 00:47:51.880
是的，我需要一个

00:47:48.970 --> 00:47:54.310
蝇头蝇头是的是的是的但是你

00:47:51.880 --> 00:48:03.100
有一个手指桌哦，这是钥匙桌

00:47:54.310 --> 00:48:07.690
是的，这应该是平均水平

00:48:03.100 --> 00:48:11.260
好吧，所以我们有一个我们需要

00:48:07.690 --> 00:48:12.880
把它放回卡夫卡，所以在这个

00:48:11.260 --> 00:48:18.640
情况下，我们需要一个返回键流

00:48:12.880 --> 00:48:20.590
当然可以，所以当你有一个

00:48:18.640 --> 00:48:24.700
联合是的，我们将加入

00:48:20.590 --> 00:48:30.170
从yep join return中提取有价值

00:48:24.700 --> 00:48:33.769
加入狗这条流好

00:48:30.170 --> 00:48:38.779
然后将其发送到将

00:48:33.769 --> 00:48:41.359
这入额定电影电影最后

00:48:38.779 --> 00:48:42.950
产品是最后的事情，并为了

00:48:41.359 --> 00:48:47.109
要做到这一点，我们要说加入两个

00:48:42.950 --> 00:48:57.500
您知道这是关键流的流

00:48:47.109 --> 00:48:59.539
它的情况下果酱是的，没有桌子

00:48:57.500 --> 00:49:05.029
返回要加入的密钥表密钥表

00:48:59.539 --> 00:49:09.230
流我认为我们做的评级

00:49:05.029 --> 00:49:14.119
加入电影没有滚动将有电影

00:49:09.230 --> 00:49:19.039
这也是关键表确定表，在此

00:49:14.119 --> 00:49:23.059
如果它变成正确的事情，并且会做

00:49:19.039 --> 00:49:29.349
你如何提取变量好吧好吧

00:49:23.059 --> 00:49:43.369
没错，最后的权利哦

00:49:29.349 --> 00:49:44.779
我做了这个，所以我们还有一个

00:49:43.369 --> 00:49:48.740
分钟，因此有效

00:49:44.779 --> 00:49:50.809
只需运行就可以了，那该怎么办

00:49:48.740 --> 00:49:59.210
让我们准备好看看，我们将可以

00:49:50.809 --> 00:50:01.430
看到结果会幸福，好吧，你不是

00:49:59.210 --> 00:50:04.420
额定值不同

00:50:01.430 --> 00:50:04.420
是的

00:50:10.610 --> 00:50:17.700
装载机在运行吗

00:50:14.810 --> 00:50:19.950
加载程序运行的Kafka应用程序

00:50:17.700 --> 00:50:22.920
是的，我不是我们开始分析器

00:50:19.950 --> 00:50:24.780
是的，那是我们的Kafka应用程序

00:50:22.920 --> 00:50:31.260
启动不知道的分析仪

00:50:24.780 --> 00:50:33.270
关于这个新东西，但是等待

00:50:31.260 --> 00:50:35.340
电影是必不可少的组成部分

00:50:33.270 --> 00:50:38.180
命名分级电影哦，我们必须启用

00:50:35.340 --> 00:50:44.510
那个约束，所以这是我们的我想你

00:50:38.180 --> 00:50:44.510
是的，需要我会需要这个

00:50:51.860 --> 00:51:03.810
好吧

00:50:53.300 --> 00:51:07.050
准备稳定的赎罪日好吧，所以

00:51:03.810 --> 00:51:10.470
打破这种尴尬的沉默，我需要

00:51:07.050 --> 00:51:12.890
也许可以节省一些笑话， 

00:51:10.470 --> 00:51:12.890
东西

00:51:21.780 --> 00:51:25.520
先生，我们在这里错过了什么

00:51:23.940 --> 00:51:28.860
很酷，我们去

00:51:25.520 --> 00:51:36.210
非常感谢乔希（Josh）的好地方， 

00:51:28.860 --> 00:51:38.190
先生，所以我们开始做什么

00:51:36.210 --> 00:51:40.170
从基本的卡夫卡开始

00:51:38.190 --> 00:51:41.760
模板将消息发送到代理

00:51:40.170 --> 00:51:43.020
如果您有的话，那一切都很好

00:51:41.760 --> 00:51:45.360
之前曾经使用过模板

00:51:43.020 --> 00:51:46.710
很明显，然后我们径直向前

00:51:45.360 --> 00:51:48.810
进入游泳池的深处

00:51:46.710 --> 00:51:50.280
开始使用spring代码流

00:51:48.810 --> 00:51:51.840
抽象一些配置

00:51:50.280 --> 00:51:54.080
布线和缪斯Spring 切

00:51:51.840 --> 00:51:56.700
与卡夫卡流一起做

00:51:54.080 --> 00:51:59.280
分布式流处理很棒

00:51:56.700 --> 00:52:01.080
缩放，所以这只是一个有限的数据

00:51:59.280 --> 00:52:01.950
设置了，但是当然这是全部

00:52:01.080 --> 00:52:04.020
这是你现在可以建立

00:52:01.950 --> 00:52:05.580
处理您的管道知道Netflix 

00:52:04.020 --> 00:52:07.500
正确地缩放东西，这是一个

00:52:05.580 --> 00:52:11.310
真正的机会好吧谢谢

00:52:07.500 --> 00:52:12.750
每个人都喜欢，肯定，一如既往

00:52:11.310 --> 00:52:13.420
我们可以提供高级

00:52:12.750 --> 00:52:16.650
审讯

00:52:13.420 --> 00:52:19.699
 [掌声] 

00:52:16.650 --> 00:52:19.699
 [音乐] 

