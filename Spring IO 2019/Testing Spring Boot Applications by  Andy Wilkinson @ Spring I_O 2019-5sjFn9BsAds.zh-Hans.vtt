WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.900 --> 00:00:10.160
 [音乐] 

00:00:07.330 --> 00:00:13.700
好的，我欢迎大家

00:00:10.160 --> 00:00:15.230
那11:30，所以让我们开始吧

00:00:13.700 --> 00:00:17.570
很高兴见到你们这么多的人

00:00:15.230 --> 00:00:20.119
本次有关测试Spring Boot的会议

00:00:17.570 --> 00:00:22.340
我的名字叫安迪·威尔金森

00:00:20.119 --> 00:00:24.740
在我度过的大部分时间里为关键工作

00:00:22.340 --> 00:00:32.180
我在 spring boot 上工作的时间

00:00:24.740 --> 00:00:33.560
 Spring Rest Docs的主管如此

00:00:32.180 --> 00:00:35.660
我们有点陷入低谷

00:00:33.560 --> 00:00:37.460
测试级技术细节

00:00:35.660 --> 00:00:39.320
我想要的 spring boot 应用程序

00:00:37.460 --> 00:00:42.320
花一点时间谈论

00:00:39.320 --> 00:00:43.910
为什么为什么要打扰测试呢？ 

00:00:42.320 --> 00:00:46.190
也许不是最迷人的部分

00:00:43.910 --> 00:00:48.710
我们的工作，但我认为这是其中之一

00:00:46.190 --> 00:00:51.470
最重要的是举手示意

00:00:48.710 --> 00:00:53.990
你们中的许多人的测试

00:00:51.470 --> 00:00:58.280
自动运行，无需您

00:00:53.990 --> 00:01:00.380
做几乎所有人

00:00:58.280 --> 00:01:02.870
那是很高兴看到的，有多少

00:01:00.380 --> 00:01:05.719
你们中的一个人可以

00:01:02.870 --> 00:01:07.579
承诺更改一些测试运行，然后

00:01:05.719 --> 00:01:09.140
东西突然冒出来

00:01:07.579 --> 00:01:12.530
在另一端的环境

00:01:09.140 --> 00:01:16.939
现在是一种部署管道

00:01:12.530 --> 00:01:18.759
还是不错，很好，那为什么我们要

00:01:16.939 --> 00:01:23.719
我认为测试很麻烦

00:01:18.759 --> 00:01:25.249
首先，我们进行测试以降低风险

00:01:23.719 --> 00:01:27.020
你什么时候应该做什么

00:01:25.249 --> 00:01:29.210
您正在编写测试，您正在尝试

00:01:27.020 --> 00:01:32.630
允许您编写的代码

00:01:29.210 --> 00:01:37.009
成功地从您的方式

00:01:32.630 --> 00:01:39.530
机器进入生产环境

00:01:37.009 --> 00:01:42.289
你们很多人似乎都同意

00:01:39.530 --> 00:01:44.810
使那些测试自动化并运行

00:01:42.289 --> 00:01:47.509
每次您进行更改都很大

00:01:44.810 --> 00:01:49.520
好处，因为你知道你得到一些

00:01:47.509 --> 00:01:51.619
保证的程度

00:01:49.520 --> 00:01:53.299
通过了这些测试就做出了更改

00:01:51.619 --> 00:01:59.420
不会犯错的

00:01:53.299 --> 00:02:00.679
当它弹出另一端时，我

00:01:59.420 --> 00:02:02.840
想想虽然很重要

00:02:00.679 --> 00:02:05.600
关于添加测试时的事情

00:02:02.840 --> 00:02:09.080
为什么要添加它们以及可以做什么

00:02:05.600 --> 00:02:11.630
如果有的话，可以降低风险

00:02:09.080 --> 00:02:14.030
根本没有测试的风险

00:02:11.630 --> 00:02:15.680
尽可能高，然后我想

00:02:14.030 --> 00:02:18.740
您可以做的最重要的事情是

00:02:15.680 --> 00:02:21.800
添加第一个测试，以便在 spring boot 中

00:02:18.740 --> 00:02:25.370
如果您只想去申请

00:02:21.800 --> 00:02:27.650
有一个测试可以刷新

00:02:25.370 --> 00:02:29.780
应用程序上下文已经摆脱

00:02:27.650 --> 00:02:32.230
如果您进行一项测试，则会有很大的风险

00:02:29.780 --> 00:02:34.459
刷新上下文，然后您知道

00:02:32.230 --> 00:02:35.959
希望你所有的豆子都是

00:02:34.459 --> 00:02:38.270
可用你所有的依赖

00:02:35.959 --> 00:02:42.440
注射将起作用，您知道

00:02:38.270 --> 00:02:45.200
网络服务器将启动等，但随着你

00:02:42.440 --> 00:02:46.640
添加更多测试，您将获得好处

00:02:45.200 --> 00:02:49.790
从添加这些测试和

00:02:46.640 --> 00:02:51.830
风险降低实际上降低了， 

00:02:49.790 --> 00:02:54.080
可能会遇到以下情况

00:02:51.830 --> 00:02:56.300
您正在盲目地向您添加测试

00:02:54.080 --> 00:02:59.209
您并没有真正减少应用程序

00:02:56.300 --> 00:03:01.340
完全没有风险，这是

00:02:59.209 --> 00:03:03.080
我认为该代码的一个领域

00:03:01.340 --> 00:03:04.940
实际上，承保范围比

00:03:03.080 --> 00:03:08.569
好你们当中有多少人注意

00:03:04.940 --> 00:03:10.850
代码覆盖率测试

00:03:08.569 --> 00:03:13.010
你从这个谈话中拿走了一件事

00:03:10.850 --> 00:03:16.400
我希望您开始忽略您的代码

00:03:13.010 --> 00:03:19.010
承保范围号或不将其视为

00:03:16.400 --> 00:03:21.350
福音我之前曾在团队中工作

00:03:19.010 --> 00:03:23.150
您被禁止输入密码

00:03:21.350 --> 00:03:26.900
允许继续前进到下一个

00:03:23.150 --> 00:03:29.630
直到达到80％的代码覆盖率

00:03:26.900 --> 00:03:31.370
知道80％的分支机构覆盖率或80％的线路

00:03:29.630 --> 00:03:33.829
覆盖率是什么指标

00:03:31.370 --> 00:03:36.079
他们决定专注于

00:03:33.829 --> 00:03:38.540
陷入这种荒谬的境地

00:03:36.079 --> 00:03:40.160
某人的代码覆盖率为79％， 

00:03:38.540 --> 00:03:42.290
他们只是想要自己的改变就能做到

00:03:40.160 --> 00:03:44.239
投入生产或进入下一阶段

00:03:42.290 --> 00:03:46.400
他们会为吸气剂方法添加测试

00:03:44.239 --> 00:03:49.459
只是为了覆盖另外一个班轮代码， 

00:03:46.400 --> 00:03:51.650
其实有什么机会

00:03:49.459 --> 00:03:54.140
你在吸气剂中弄错了

00:03:51.650 --> 00:03:56.600
方法可能是零或接近

00:03:54.140 --> 00:03:59.209
零，所以您又添加了一个测试

00:03:56.600 --> 00:04:01.400
你认为哦，先知的报道

00:03:59.209 --> 00:04:03.109
上升风险下降了可以

00:04:01.400 --> 00:04:05.930
同时移至下一阶段

00:04:03.109 --> 00:04:08.150
你可能有一个50行的方法

00:04:05.930 --> 00:04:10.040
充满了可怕的复杂逻辑，没有

00:04:08.150 --> 00:04:11.959
一个人真的知道如何测试或

00:04:10.040 --> 00:04:14.120
麻烦的测试，这只是坐

00:04:11.959 --> 00:04:16.039
未经测试的你可能已经改变了

00:04:14.120 --> 00:04:18.289
 50线的各种方法

00:04:16.039 --> 00:04:20.329
在其中分支，而无需进行测试

00:04:18.289 --> 00:04:22.250
但是因为您添加了一个测试

00:04:20.329 --> 00:04:23.780
得到你未经测试的代码被允许

00:04:22.250 --> 00:04:26.570
进入下一阶段

00:04:23.780 --> 00:04:27.460
管道，因此代码覆盖范围可以

00:04:26.570 --> 00:04:31.030
成为一个男人

00:04:27.460 --> 00:04:33.100
告诉您您已经进行了一些测试

00:04:31.030 --> 00:04:35.680
和一些方法被执行，但我

00:04:33.100 --> 00:04:38.229
认为你需要你需要多看

00:04:35.680 --> 00:04:40.449
详细介绍已涵盖的内容

00:04:38.229 --> 00:04:42.850
而不是只注意

00:04:40.449 --> 00:04:46.690
公司覆盖率

00:04:42.850 --> 00:04:47.800
提供你我认为另一个重要

00:04:46.690 --> 00:04:50.009
想着自己的事情

00:04:47.800 --> 00:04:51.880
测试就是要接受这样一个事实： 

00:04:50.009 --> 00:04:53.889
实际上，您永远不会

00:04:51.880 --> 00:04:57.009
将风险降低到零

00:04:53.889 --> 00:04:58.990
不管你写多少次测试

00:04:57.009 --> 00:05:02.740
仍然会出错

00:04:58.990 --> 00:05:04.240
生产环境，所以我认为

00:05:02.740 --> 00:05:07.120
需要到达一个点

00:05:04.240 --> 00:05:10.060
问自己是否值得再增加一点

00:05:07.120 --> 00:05:12.370
测试是否值得编写复杂的测试

00:05:10.060 --> 00:05:15.370
搭建一个复杂的环境

00:05:12.370 --> 00:05:17.830
也许说这只是一个问题

00:05:15.370 --> 00:05:19.750
发生在非常高的负载或

00:05:17.830 --> 00:05:21.970
确定您知道并发情况

00:05:19.750 --> 00:05:23.770
您可以尝试重新创建

00:05:21.970 --> 00:05:25.990
在暂存环境中的示例

00:05:23.770 --> 00:05:28.090
然后有一些回归测试套件

00:05:25.990 --> 00:05:29.800
试图复制该工作负载

00:05:28.090 --> 00:05:32.199
这件事曾经错在哪里

00:05:29.800 --> 00:05:35.050
生产，我想你会结束

00:05:32.199 --> 00:05:37.090
花更多的时间来保持这一阶段

00:05:35.050 --> 00:05:41.190
与环境模糊地同步

00:05:37.090 --> 00:05:43.930
生产，那么您会从中受益

00:05:41.190 --> 00:05:45.520
也许避免再次出现该问题

00:05:43.930 --> 00:05:48.520
在生产中，我认为你必须接受

00:05:45.520 --> 00:05:50.110
在某些时候，事情将会发生

00:05:48.520 --> 00:05:52.240
出问题了，所以你应该停止

00:05:50.110 --> 00:05:54.789
花时间写更多

00:05:52.240 --> 00:05:56.740
测试并考虑转而投资

00:05:54.789 --> 00:05:58.509
制作时间

00:05:56.740 --> 00:06:00.940
环境更可观察，所以什么时候

00:05:58.509 --> 00:06:03.280
生产中出现问题

00:06:00.940 --> 00:06:05.229
从中获取指标，从中获取日志

00:06:03.280 --> 00:06:07.780
你会从中得到想要的东西

00:06:05.229 --> 00:06:09.810
让您快速查明某事

00:06:07.780 --> 00:06:12.669
在生产中出错

00:06:09.810 --> 00:06:15.669
迅速找出问题所在， 

00:06:12.669 --> 00:06:17.500
然后希望推动修复或回滚

00:06:15.669 --> 00:06:19.479
回到以前的状态，另一件事

00:06:17.500 --> 00:06:22.419
你不能总是合适的

00:06:19.479 --> 00:06:24.699
对于各种问题，但能够

00:06:22.419 --> 00:06:26.919
回滚到以前的已知商品

00:06:24.699 --> 00:06:29.919
状态也可能是有益的，所以如果你

00:06:26.919 --> 00:06:31.720
将某物投入生产，您的

00:06:29.919 --> 00:06:34.150
测试没有发现问题，所有

00:06:31.720 --> 00:06:37.300
地狱破了你有两个选择

00:06:34.150 --> 00:06:39.370
一个是您尝试修复它，但是可以

00:06:37.300 --> 00:06:40.990
如果您的服务不愉快，请保持压力

00:06:39.370 --> 00:06:41.640
可用，这对您至关重要

00:06:40.990 --> 00:06:44.050
法案

00:06:41.640 --> 00:06:45.550
这些条件并不理想

00:06:44.050 --> 00:06:47.380
试图做出改变，因为

00:06:45.550 --> 00:06:49.240
想必您在您犯错时

00:06:47.380 --> 00:06:50.890
现在没有压力，如果你

00:06:49.240 --> 00:06:52.960
面临着试图解决此问题的压力

00:06:50.890 --> 00:06:54.850
尽快给你机会

00:06:52.960 --> 00:06:56.680
犯另一个错误的可能性很高

00:06:54.850 --> 00:06:58.720
如果您投入时间来

00:06:56.680 --> 00:07:01.180
回滚，那可能是

00:06:58.720 --> 00:07:03.460
比花更多的钱更好的投资

00:07:01.180 --> 00:07:07.780
时间写作复杂的系统

00:07:03.460 --> 00:07:09.520
集成类型测试，我认为什么时候

00:07:07.780 --> 00:07:11.290
您正在编写测试，还应该

00:07:09.520 --> 00:07:13.240
考虑一下那种错误

00:07:11.290 --> 00:07:16.390
您所做的，这将因团队而异

00:07:13.240 --> 00:07:18.100
团队，使人们绘画

00:07:16.390 --> 00:07:19.540
他们在这条路上的学校写作

00:07:18.100 --> 00:07:21.070
显然他们的色彩很好

00:07:19.540 --> 00:07:23.530
他们得到所有字母相同的颜色

00:07:21.070 --> 00:07:26.290
但是拼写不好

00:07:23.530 --> 00:07:28.030
知道你团队中的错误

00:07:26.290 --> 00:07:29.740
您所做的并在您的域中

00:07:28.030 --> 00:07:32.320
经常出错的事情

00:07:29.740 --> 00:07:33.730
那就是风险所在， 

00:07:32.320 --> 00:07:36.160
那是代码覆盖范围所在

00:07:33.730 --> 00:07:37.900
误导，因为并非所有行都

00:07:36.160 --> 00:07:40.000
相等，如果这是一个常见错误， 

00:07:37.900 --> 00:07:42.370
您个人做出或您知道

00:07:40.000 --> 00:07:44.440
您团队中的成员使

00:07:42.370 --> 00:07:46.180
您集中精力的好地方

00:07:44.440 --> 00:07:48.280
在编写测试时要注意

00:07:46.180 --> 00:07:50.260
而不是只是被

00:07:48.280 --> 00:07:57.880
有关我需要打一定

00:07:50.260 --> 00:07:59.890
代码覆盖率可以吗

00:07:57.880 --> 00:08:01.630
希望这是一个水平设置

00:07:59.890 --> 00:08:03.970
关于为什么我们编写测试的一些事情

00:08:01.630 --> 00:08:05.470
以及我如何思考那种

00:08:03.970 --> 00:08:07.270
我们应该编写的测试

00:08:05.470 --> 00:08:09.730
也许什么时候我们应该停止写作

00:08:07.270 --> 00:08:12.850
测试，我想开始谈论

00:08:09.730 --> 00:08:17.050
 spring boot 的实际测试面

00:08:12.850 --> 00:08:18.640
应用程序，我认为一个好地方

00:08:17.050 --> 00:08:21.430
建立一个很多人的地方

00:08:18.640 --> 00:08:23.110
首先是单元测试，如果

00:08:21.430 --> 00:08:25.060
您的单元测试 spring boot 

00:08:23.110 --> 00:08:26.950
您尚未实际测试的应用程序

00:08:25.060 --> 00:08:30.580
一个Spring Boot应用程序

00:08:26.950 --> 00:08:32.860
个别单位应该很少

00:08:30.580 --> 00:08:35.229
如果与春天或春天有关

00:08:32.860 --> 00:08:39.160
启动，这是您知道的东西

00:08:35.229 --> 00:08:41.650
在2003年左右的春天

00:08:39.160 --> 00:08:44.320
启动对不起Spring框架有一个可怕的

00:08:41.650 --> 00:08:47.590
很多牵引力，因为它可以让您写作

00:08:44.320 --> 00:08:51.610
作为普通的旧Java对象的代码，我们

00:08:47.590 --> 00:08:54.380
从当时的Java移至j2ee 

00:08:51.610 --> 00:08:56.300
做事的方式

00:08:54.380 --> 00:08:57.860
对事物进行分类，如果您编写了EJB 

00:08:56.300 --> 00:08:59.780
没有它很难测试

00:08:57.860 --> 00:09:02.300
 EJB的所有支架

00:08:59.780 --> 00:09:05.780
容器给了你，春天让你

00:09:02.300 --> 00:09:07.880
只是写一个普通的旧Java对象

00:09:05.780 --> 00:09:09.800
然后，您可以轻松地进行测试

00:09:07.880 --> 00:09:12.110
标准单元测试，而无需

00:09:09.800 --> 00:09:13.910
担心拥有EJB容器或

00:09:12.110 --> 00:09:16.640
 servlet容器或其他可能的容器

00:09:13.910 --> 00:09:19.130
这是真的，你知道像

00:09:16.640 --> 00:09:21.770
 15年后的16年，我认为

00:09:19.130 --> 00:09:24.020
现在仍然成立，但您可以

00:09:21.770 --> 00:09:25.880
不仅获得了很多里程

00:09:24.020 --> 00:09:29.420
为您的应用程序编写单元测试

00:09:25.880 --> 00:09:32.270
现在测试一些个人单元

00:09:29.420 --> 00:09:33.740
不喜欢单元测试，以为你

00:09:32.270 --> 00:09:35.600
应该写更多的功能

00:09:33.740 --> 00:09:38.810
测试，因为他们考虑了单位

00:09:35.600 --> 00:09:41.330
测试很难发展，你知道

00:09:38.810 --> 00:09:43.250
如果您重写了大部分

00:09:41.330 --> 00:09:44.930
应用程序，那么您已经拥有了所有这些

00:09:43.250 --> 00:09:46.940
然后还需要进行单元测试

00:09:44.930 --> 00:09:48.950
改写，我想我有一些

00:09:46.940 --> 00:09:50.630
同情这个说法，我不是

00:09:48.950 --> 00:09:53.420
真的确定一切正确

00:09:50.630 --> 00:09:55.010
还是错在这里，但这是有可能的

00:09:53.420 --> 00:09:58.340
知道那种测试

00:09:55.010 --> 00:10:00.500
你写的是，如果他们减少

00:09:58.340 --> 00:10:02.720
冒着风险，您可能想保留它们

00:10:00.500 --> 00:10:04.880
当您开发应用程序时， 

00:10:02.720 --> 00:10:08.570
想要发展为

00:10:04.880 --> 00:10:10.510
好吧，当您编写测试时， 

00:10:08.570 --> 00:10:13.070
想考虑写他们

00:10:10.510 --> 00:10:14.510
以某种方式，您知道您希望他们成为

00:10:13.070 --> 00:10:18.050
尽可能简明扼要

00:10:14.510 --> 00:10:19.450
他们不包含消费

00:10:18.050 --> 00:10:22.340
您随着应用程序的发展而发展

00:10:19.450 --> 00:10:23.990
可能对你意味着那个单位的发展

00:10:22.340 --> 00:10:25.550
测试很好，可能对您意味着

00:10:23.990 --> 00:10:27.620
你有一些单元测试，你

00:10:25.550 --> 00:10:29.120
只专注于功能测试

00:10:27.620 --> 00:10:31.160
在团队中要考虑的事情

00:10:29.120 --> 00:10:34.880
什么最适合那种

00:10:31.160 --> 00:10:36.980
您正在编写另一个应用程序

00:10:34.880 --> 00:10:38.720
我在准备这次演讲时看到的东西

00:10:36.980 --> 00:10:40.220
这条推文过去了，我想

00:10:38.720 --> 00:10:41.630
实际上我把它放在单元测试中

00:10:40.220 --> 00:10:44.450
部分，但我认为它适用于

00:10:41.630 --> 00:10:46.310
所有测试的一切都在何时

00:10:44.450 --> 00:10:48.320
您正在命名测试，不要称呼它们

00:10:46.310 --> 00:10:51.050
像test1 test2 test3 

00:10:48.320 --> 00:10:52.940
因为未来你会讨厌过去

00:10:51.050 --> 00:10:54.350
当该测试失败并且您正在寻找

00:10:52.940 --> 00:10:57.190
在它，你试图记住什么

00:10:54.350 --> 00:10:59.570
在地球上，那是你在测试

00:10:57.190 --> 00:11:02.900
这样的事情只是不会

00:10:59.570 --> 00:11:04.970
帮助使用任何命名约定

00:11:02.900 --> 00:11:07.900
你喜欢这里，只是用点东西

00:11:04.970 --> 00:11:10.760
那说你知道X在什么时候

00:11:07.900 --> 00:11:12.650
为什么要发生低音尝试并描述

00:11:10.760 --> 00:11:15.890
以测试的名义是什么

00:11:12.650 --> 00:11:17.750
测试正在检查，您可以执行

00:11:15.890 --> 00:11:18.800
您可以通过多种方式知道这一点

00:11:17.750 --> 00:11:20.660
你只是在写，你知道你是否

00:11:18.800 --> 00:11:23.210
使用j-unit可以将其放入

00:11:20.660 --> 00:11:25.190
如果使用的是J单元5，则为测试方法

00:11:23.210 --> 00:11:27.020
然后有一个新的显示名称

00:11:25.190 --> 00:11:30.470
使您了解自己的注释

00:11:27.020 --> 00:11:32.150
可以在其中粘贴更易读的名称

00:11:30.470 --> 00:11:33.680
注释，而不是碰巧

00:11:32.150 --> 00:11:36.620
尝试从

00:11:33.680 --> 00:11:38.210
方法名称，只是我会鼓励

00:11:36.620 --> 00:11:40.640
你想想你的名字，也许

00:11:38.210 --> 00:11:42.410
在整个团队中采用惯例

00:11:40.640 --> 00:11:44.750
团队中的每个人都使用相同的

00:11:42.410 --> 00:11:46.460
测试方法名称的样式，以便

00:11:44.750 --> 00:11:47.930
如果您团队中的其他人来

00:11:46.460 --> 00:11:50.030
查看您编写的测试或

00:11:47.930 --> 00:11:51.410
反之亦然，你可以看看

00:11:50.030 --> 00:11:53.120
测试的名称，您可以大致了解

00:11:51.410 --> 00:11:54.950
测试应该是什么的想法

00:11:53.120 --> 00:11:57.110
检查以确保测试不合格

00:11:54.950 --> 00:11:59.750
或者您正在尝试更改一些代码

00:11:57.110 --> 00:12:01.010
测试练习和测试

00:11:59.750 --> 00:12:02.630
在这样做时开始失败

00:12:01.010 --> 00:12:04.850
你可以找出我犯了一个错误

00:12:02.630 --> 00:12:07.850
还是测试错误或有

00:12:04.850 --> 00:12:15.610
由于

00:12:07.850 --> 00:12:18.770
您所做的修改

00:12:15.610 --> 00:12:21.980
想象这里我们有一个典型的

00:12:18.770 --> 00:12:24.140
应用程序或应用程序的子集

00:12:21.980 --> 00:12:25.940
我们有一堆豆子

00:12:24.140 --> 00:12:28.010
他们之间的关系

00:12:25.940 --> 00:12:30.260
这些豆有一些依赖

00:12:28.010 --> 00:12:32.930
他们不认为其中一些是

00:12:30.260 --> 00:12:36.920
比单元测试更好的候选人

00:12:32.930 --> 00:12:39.680
其他人，所有这些都是

00:12:36.920 --> 00:12:42.110
以绿色突出显示，他们没有任何

00:12:39.680 --> 00:12:44.600
依赖关系，对我来说，这些都是

00:12:42.110 --> 00:12:46.580
如果您打算进行单元测试

00:12:44.600 --> 00:12:48.140
他们是写单元的好人选

00:12:46.580 --> 00:12:49.370
无需为您进行测试

00:12:48.140 --> 00:12:51.110
嘲笑你不想要的任何东西

00:12:49.370 --> 00:12:53.630
脚手架

00:12:51.110 --> 00:12:55.700
运用逻辑并确保

00:12:53.630 --> 00:13:00.950
通过特定的输入，您可以获得正确的选择

00:12:55.700 --> 00:13:03.110
如果您查看这些组件，则输出

00:13:00.950 --> 00:13:06.830
这些有依赖关系，所以如果你想

00:13:03.110 --> 00:13:08.480
要测试这些，您可能要

00:13:06.830 --> 00:13:10.190
如果你想要的话，一定要嘲笑

00:13:08.480 --> 00:13:12.590
成为真正的单元测试

00:13:10.190 --> 00:13:15.110
必须嘲笑一些东西，所以如果你是

00:13:12.590 --> 00:13:17.840
您可能正在使用的Java开发人员

00:13:15.110 --> 00:13:19.610
我认为这通常是我们

00:13:17.840 --> 00:13:22.280
推荐给Spring Boot用户

00:13:19.610 --> 00:13:26.360
 Spring Boot测试提供了什么

00:13:22.280 --> 00:13:29.440
人们对如何

00:13:26.360 --> 00:13:32.240
很多人在测试中使用拖把

00:13:29.440 --> 00:13:38.360
你们当中有多少人避免像

00:13:32.240 --> 00:13:39.710
再次困扰所有人

00:13:38.360 --> 00:13:43.040
不要以为是非

00:13:39.710 --> 00:13:44.420
从本质上讲，当您开始嘲笑时

00:13:43.040 --> 00:13:46.370
你有一些额外的东西

00:13:44.420 --> 00:13:48.300
实现某种行为

00:13:46.370 --> 00:13:49.360
保持这样，当你写

00:13:48.300 --> 00:13:51.440
 [音乐] 

00:13:49.360 --> 00:13:52.940
对你和你的期望

00:13:51.440 --> 00:13:56.180
说你知道什么时候这个特殊的方法

00:13:52.940 --> 00:13:57.890
被称为融洽返回此值

00:13:56.180 --> 00:14:01.160
或抛出此异常或任何可能

00:13:57.890 --> 00:14:03.530
发生，你需要保持

00:14:01.160 --> 00:14:05.360
您已同步嘲笑的行为

00:14:03.530 --> 00:14:08.270
与实际的实现是

00:14:05.360 --> 00:14:09.620
将被嵌入更多你知道的

00:14:08.270 --> 00:14:11.030
在功能测试中或

00:14:09.620 --> 00:14:14.210
应用程序实际上正在运行

00:14:11.030 --> 00:14:16.610
生产，所以有一种额外的

00:14:14.210 --> 00:14:18.350
您作为开发人员的责任

00:14:16.610 --> 00:14:20.420
最新的事情，你可以进入

00:14:18.350 --> 00:14:22.310
我确定你们都看过这种情况

00:14:20.420 --> 00:14:24.890
您设定的期望

00:14:22.310 --> 00:14:26.660
模拟与服务的方式有所不同

00:14:24.890 --> 00:14:28.610
实际表现良好，因此您的单元测试了所有

00:14:26.660 --> 00:14:30.170
通过，然后也许您运行了功能

00:14:28.610 --> 00:14:31.850
测试，一切都坏了，或者也许

00:14:30.170 --> 00:14:33.800
东西突然冒出来生产

00:14:31.850 --> 00:14:37.520
一切都中断了，因为您的模拟和

00:14:33.800 --> 00:14:39.230
您的实际服务不同步，所以

00:14:37.520 --> 00:14:40.760
您需要注意并且通常

00:14:39.230 --> 00:14:43.430
假设您可能知道Tet和

00:14:40.760 --> 00:14:44.930
在编写测试时可能会犯错

00:14:43.430 --> 00:14:46.550
您在模拟中设置的行为是

00:14:44.930 --> 00:14:48.410
真的只是一个时间点

00:14:46.550 --> 00:14:50.210
说我测试的东西表现得像

00:14:48.410 --> 00:14:51.980
在我编写测试时

00:14:50.210 --> 00:14:53.720
然后您需要记住保持

00:14:51.980 --> 00:14:56.060
审查，如果有人

00:14:53.720 --> 00:14:58.010
改变事物的行为

00:14:56.060 --> 00:15:00.350
你已经嘲笑了，你还需要尝试

00:14:58.010 --> 00:15:02.420
并记得回顾期望

00:15:00.350 --> 00:15:07.010
您设置了任何标记以确保

00:15:02.420 --> 00:15:11.480
他们保持同步

00:15:07.010 --> 00:15:13.250
我们在这里拥有的组件在这里是

00:15:11.480 --> 00:15:15.530
与服务器对话的东西

00:15:13.250 --> 00:15:18.020
想象这是

00:15:15.530 --> 00:15:20.600
谈论使用其余模板

00:15:18.020 --> 00:15:23.930
 Spring应用程序或Web中的典型示例

00:15:20.600 --> 00:15:25.730
例如客户，这些可以

00:15:23.930 --> 00:15:30.410
这些可能是有趣的组成部分

00:15:25.730 --> 00:15:33.380
测试你通常别无选择

00:15:30.410 --> 00:15:35.149
嘲笑你可能在

00:15:33.380 --> 00:15:37.430
现场服务的情况

00:15:35.149 --> 00:15:39.949
这实际上需要生产

00:15:37.430 --> 00:15:42.680
环境对您不可用

00:15:39.949 --> 00:15:46.009
在您的测试环境中

00:15:42.680 --> 00:15:47.809
可以得到一个分阶段的版本

00:15:46.009 --> 00:15:49.850
您可以打电话给您的服务，但是您

00:15:47.809 --> 00:15:53.209
常常没有选择

00:15:49.850 --> 00:15:56.420
调用实际的实际系统

00:15:53.209 --> 00:15:58.370
例如，我们有一些东西

00:15:56.420 --> 00:16:00.019
我们在春季为您使用的应用程序

00:15:58.370 --> 00:16:01.939
团队跟踪我们的发布情况

00:16:00.019 --> 00:16:03.559
日历，它熄灭，看着

00:16:01.939 --> 00:16:05.029
 github里程碑并收集所有

00:16:03.559 --> 00:16:07.189
有关所有发行日期的信息

00:16:05.029 --> 00:16:09.769
对于所有项目而言， 

00:16:07.189 --> 00:16:11.809
与github交谈github有速率限制

00:16:09.769 --> 00:16:13.540
因此，当我们运行测试时， 

00:16:11.809 --> 00:16:15.730
要么必须非常小心，否则

00:16:13.540 --> 00:16:18.079
超过github速率限制而没有

00:16:15.730 --> 00:16:20.420
进行身份验证，否则我们可以有一些

00:16:18.079 --> 00:16:22.069
我们使用的凭证

00:16:20.420 --> 00:16:23.870
提高了速率限制，但是我们有了

00:16:22.069 --> 00:16:25.639
担心在我们的测试中，我们必须

00:16:23.870 --> 00:16:27.230
以某种方式提供这些凭据，并

00:16:25.639 --> 00:16:28.579
然后你进入健康然后我的测试

00:16:27.230 --> 00:16:30.259
套房不想拥有这些秘密

00:16:28.579 --> 00:16:31.550
签入开放-您知道这是一个

00:16:30.259 --> 00:16:33.350
我们不想的开源项目

00:16:31.550 --> 00:16:34.459
有那些签入让我们然后

00:16:33.350 --> 00:16:36.980
这一切变得越来越多

00:16:34.459 --> 00:16:43.279
很复杂，所以您可以做些什么

00:16:36.980 --> 00:16:45.379
你可以用一些东西来模拟

00:16:43.279 --> 00:16:47.300
您正在呼叫的服务以及多少

00:16:45.379 --> 00:16:52.309
你们当中有人听说过模拟休息

00:16:47.300 --> 00:16:56.360
服务服务器不多，所以这是一个

00:16:52.309 --> 00:16:59.749
弹簧测试模块的隐藏宝石和

00:16:56.360 --> 00:17:02.600
它的作用是让您基本上

00:16:59.749 --> 00:17:04.699
设置一些东西，你可以说什么时候我

00:17:02.600 --> 00:17:08.809
收到与此特定的请求

00:17:04.699 --> 00:17:10.970
 HTTP动词，也许这些请求

00:17:08.809 --> 00:17:12.799
参数或任何这是

00:17:10.970 --> 00:17:15.890
我要你回来的回应

00:17:12.799 --> 00:17:18.770
您可以在HTTP上设置期望

00:17:15.890 --> 00:17:20.959
关于你想要这个东西的程度

00:17:18.770 --> 00:17:25.100
表现出来，然后你就可以约束休息

00:17:20.959 --> 00:17:26.839
模板而不是你做

00:17:25.100 --> 00:17:29.000
像这样的休息模板

00:17:26.839 --> 00:17:31.340
可能知道执行其余操作

00:17:29.000 --> 00:17:33.289
界面，因此您可以采取一种方法

00:17:31.340 --> 00:17:35.570
在这里模拟其余的操作

00:17:33.289 --> 00:17:38.779
界面，然后您设置了一堆

00:17:35.570 --> 00:17:40.730
期望用莫吉托说什么时候

00:17:38.779 --> 00:17:43.340
有一个与此实体通话

00:17:40.730 --> 00:17:45.559
 URI，您知道这些请求

00:17:43.340 --> 00:17:47.200
实体，这是响应实体， 

00:17:45.559 --> 00:17:49.119
你应该回来

00:17:47.200 --> 00:17:51.340
但这错过了很多

00:17:49.119 --> 00:17:53.499
您的服务实际上是

00:17:51.340 --> 00:17:54.999
如果您要在运行时执行

00:17:53.499 --> 00:17:58.029
模拟其余的操作

00:17:54.999 --> 00:18:00.159
界面中您可能会犯错

00:17:58.029 --> 00:18:01.509
您传递的URI可以使

00:18:00.159 --> 00:18:05.889
您如何替换的错误

00:18:01.509 --> 00:18:07.629
路径变量到HTTP的URI中

00:18:05.889 --> 00:18:10.419
消息转换可能不完全

00:18:07.629 --> 00:18:12.309
对，如果您使用类似模拟的东西

00:18:10.419 --> 00:18:14.980
休息服务服务器，您可以将您的

00:18:12.309 --> 00:18:17.139
休息模板将其绑定到模拟休息

00:18:14.980 --> 00:18:19.869
服务服务器，然后在

00:18:17.139 --> 00:18:22.690
 HTTP级别，因此您几乎可以获得

00:18:19.869 --> 00:18:24.519
免费获得其余的测试

00:18:22.690 --> 00:18:27.909
您正在进行的模板调用是

00:18:24.519 --> 00:18:30.820
实际映射到您的URI 

00:18:27.909 --> 00:18:32.350
服务的运营时间是

00:18:30.820 --> 00:18:33.940
当我们与github打交道时

00:18:32.350 --> 00:18:38.129
基本上可以采用github API 

00:18:33.940 --> 00:18:41.019
文档和预期的格式

00:18:38.129 --> 00:18:43.090
请求和响应有效负载及映射

00:18:41.019 --> 00:18:44.889
模拟休息服务服务器

00:18:43.090 --> 00:18:47.470
那么它给我们更高的程度

00:18:44.889 --> 00:18:50.019
相信我们的休息模板是

00:18:47.470 --> 00:18:54.989
正确地走向

00:18:50.019 --> 00:18:57.249
实际的HTTP后端（如果您未使用） 

00:18:54.989 --> 00:19:01.029
休息模板，而您正在使用网络

00:18:57.249 --> 00:19:06.730
客户反而故事不尽如人意

00:19:01.029 --> 00:19:08.679
同样，尚不支持使用

00:19:06.730 --> 00:19:10.840
带有模拟休息服务服务器的Web客户端

00:19:08.679 --> 00:19:12.639
春天有一个未解决的问题

00:19:10.840 --> 00:19:15.340
框架问题跟踪器添加

00:19:12.639 --> 00:19:17.859
支持，我认为这是五个点

00:19:15.340 --> 00:19:20.889
 X待办事项列表，因此我们将来可能会看到

00:19:17.859 --> 00:19:22.629
 5到X用Spring Framework发布，但是

00:19:20.889 --> 00:19:26.529
在此期间您可以做点什么

00:19:22.629 --> 00:19:29.350
与HTTP仿冒网站非常相似

00:19:26.529 --> 00:19:34.960
服务器，所以您可能知道确定，HTTP是

00:19:29.350 --> 00:19:36.909
 JVM上的另一个HTTP客户端，但是

00:19:34.960 --> 00:19:39.909
有一个提供的模拟Web服务器

00:19:36.909 --> 00:19:41.859
而且还没有确定的HTTP和

00:19:39.909 --> 00:19:44.409
我相信我是 Spring Framework 团队

00:19:41.859 --> 00:19:46.389
说对了，用它来测试网站

00:19:44.409 --> 00:19:48.700
客户自己，所以他们有网络

00:19:46.389 --> 00:19:50.799
客户测试，他们建立了模拟网站

00:19:48.700 --> 00:19:53.519
服务器以及我作为我的方式

00:19:50.799 --> 00:19:56.230
描述为模拟休息服务服务器

00:19:53.519 --> 00:19:57.700
您可以对

00:19:56.230 --> 00:19:59.379
模拟Web服务器，所以您可以说您知道

00:19:57.700 --> 00:20:00.740
当您收到对此URI的获取请求时

00:19:59.379 --> 00:20:03.230
返回此回复

00:20:00.740 --> 00:20:05.450
当您收到发帖请求时

00:20:03.230 --> 00:20:07.730
该有效载荷然后返回此响应

00:20:05.450 --> 00:20:09.500
并且您可以控制响应

00:20:07.730 --> 00:20:13.940
主体和状态代码以及各种

00:20:09.500 --> 00:20:16.610
的东西，所以它可以让您进行测试

00:20:13.940 --> 00:20:18.320
 HTTP级别的HTTP客户端数量

00:20:16.610 --> 00:20:20.059
你真的在乎那个

00:20:18.320 --> 00:20:22.280
他们正在做出正确的HTTP请求

00:20:20.059 --> 00:20:24.020
并正确处理HTTP响应

00:20:22.280 --> 00:20:26.059
不用担心那种

00:20:24.020 --> 00:20:27.559
确切的说，你知道

00:20:26.059 --> 00:20:32.320
 Java调用您正在做的

00:20:27.559 --> 00:20:32.320
导致发出这些HTTP请求

00:20:33.309 --> 00:20:39.620
另一个要看的是想象

00:20:37.610 --> 00:20:42.799
你有正在做的事

00:20:39.620 --> 00:20:45.500
数据访问，这里可能会有时间

00:20:42.799 --> 00:20:48.049
你不在那里你不在一个位置

00:20:45.500 --> 00:20:53.720
调用实际的实时数据库

00:20:48.049 --> 00:20:58.549
你可能不想这样说

00:20:53.720 --> 00:21:00.679
例如你有一些 spring data 

00:20:58.549 --> 00:21:03.110
存储库，所以它们有点像

00:21:00.679 --> 00:21:05.030
有趣的情况，因为在某些情况下

00:21:03.110 --> 00:21:08.270
非常简单的杂案

00:21:05.030 --> 00:21:11.419
写很多代码，你只有一个

00:21:08.270 --> 00:21:14.900
您编写的界面

00:21:11.419 --> 00:21:16.610
将JP扩展为存储库或Crud 

00:21:14.900 --> 00:21:19.549
仓库或春季您有什么

00:21:16.610 --> 00:21:21.650
数据，然后弹簧数据实际上看起来

00:21:19.549 --> 00:21:24.799
在您的界面和方法

00:21:21.650 --> 00:21:26.690
方法名称并生成

00:21:24.799 --> 00:21:29.030
然后应该是适当的查询

00:21:26.690 --> 00:21:33.620
与数据后端的数据冲突

00:21:29.030 --> 00:21:34.970
您正在使用标准杂物

00:21:33.620 --> 00:21:36.830
也许可以逃脱

00:21:34.970 --> 00:21:37.970
模拟该存储库接口

00:21:36.830 --> 00:21:39.650
你知道那里可能有一个

00:21:37.970 --> 00:21:41.270
无需任何费用的findall方法

00:21:39.650 --> 00:21:44.960
参数并返回一个列表

00:21:41.270 --> 00:21:48.470
可能还不错的人

00:21:44.960 --> 00:21:49.669
你可以用maketo模拟出来

00:21:48.470 --> 00:21:51.230
放到那里，那里非常

00:21:49.669 --> 00:21:53.240
知道自己会发现的风险很小

00:21:51.230 --> 00:21:56.780
所有方法都会存在

00:21:53.240 --> 00:21:58.220
如果有的话就是一个错误

00:21:56.780 --> 00:21:59.780
将会出现在 spring data 中，因为您

00:21:58.220 --> 00:22:01.429
没有为发现写任何东西

00:21:59.780 --> 00:22:07.190
所有这些都是生硬的标准方法

00:22:01.429 --> 00:22:09.169
存储库界面（如果您进入

00:22:07.190 --> 00:22:11.419
编写更复杂方法的业务

00:22:09.169 --> 00:22:13.970
所以对于那些你不知道春天的人

00:22:11.419 --> 00:22:15.710
数据使您可以在

00:22:13.970 --> 00:22:17.360
方法名称，或者您也可以提供

00:22:15.710 --> 00:22:20.540
其他可让您创建的元数据

00:22:17.360 --> 00:22:23.150
查询，以便您可以编写方法名称

00:22:20.540 --> 00:22:25.670
就像找到年龄所在的所有地方

00:22:23.150 --> 00:22:27.710
大于10，它将变成

00:22:25.670 --> 00:22:29.780
进入适当的查询

00:22:27.710 --> 00:22:34.370
数据存储区中的任何一个

00:22:29.780 --> 00:22:37.640
使用基于SQL的数据存储区还是

00:22:34.370 --> 00:22:39.890
没有基于SQL日期的数据存储

00:22:37.640 --> 00:22:42.200
同时从界面支持

00:22:39.890 --> 00:22:44.680
还有那里的查询级别

00:22:42.200 --> 00:22:47.000
他们在这里的目的是相同的

00:22:44.680 --> 00:22:48.890
如果您这样做并且已经开始

00:22:47.000 --> 00:22:52.270
通过编写自己的查询

00:22:48.890 --> 00:22:55.850
提供其他方法或通过

00:22:52.270 --> 00:22:57.770
通过注释提供元数据

00:22:55.850 --> 00:22:59.240
那么你就进入了被存在的境界

00:22:57.770 --> 00:23:02.330
能够犯错误，还有更多

00:22:59.240 --> 00:23:04.790
冒险，那时候我不认为你

00:23:02.330 --> 00:23:06.650
想嘲笑你的界面

00:23:04.790 --> 00:23:09.920
需要做你需要做其他事情

00:23:06.650 --> 00:23:12.770
我们稍后会谈到，我

00:23:09.920 --> 00:23:16.820
认为JDBC模板在类似的船上

00:23:12.770 --> 00:23:17.660
仍有多少人仍在使用JDBC模板

00:23:16.820 --> 00:23:19.070
一个合理的数字

00:23:17.660 --> 00:23:20.900
是的，如果你

00:23:19.070 --> 00:23:23.960
写你知道你是否不想

00:23:20.900 --> 00:23:25.730
使用一个ORM，你有一些SQL查询

00:23:23.960 --> 00:23:28.880
使JDBC模板仍然是一个真正的

00:23:25.730 --> 00:23:31.010
真的好选择，你们有多少人

00:23:28.880 --> 00:23:36.110
通过模拟测试数据库代码

00:23:31.010 --> 00:23:39.890
 JDBC操作一人二人哦

00:23:36.110 --> 00:23:42.260
我认为做的三个问题

00:23:39.890 --> 00:23:45.350
那就是你创造一个机会

00:23:42.260 --> 00:23:47.480
您的查询中的错误过高，因此如果

00:23:45.350 --> 00:23:49.550
您模拟出JDBC操作，然后

00:23:47.480 --> 00:23:51.230
你只是建立期望，你可能

00:23:49.550 --> 00:23:52.790
在查询中输入错误，您可能

00:23:51.230 --> 00:23:54.140
列名错误，您可能会

00:23:52.790 --> 00:23:55.310
将支架放在错误的位置

00:23:54.140 --> 00:23:58.070
你可能忘了报价

00:23:55.310 --> 00:24:01.280
东西，如果您只是模拟JDBC 

00:23:58.070 --> 00:24:03.350
操作，而不是实际发送

00:24:01.280 --> 00:24:05.870
该文本作为对数据库的查询

00:24:03.350 --> 00:24:08.780
直到你才发现

00:24:05.870 --> 00:24:11.120
确实有锻炼

00:24:08.780 --> 00:24:13.490
针对真实数据库的查询是

00:24:11.120 --> 00:24:14.720
在以后的测试中或马上进行

00:24:13.490 --> 00:24:18.770
从您的部署管道中弹出

00:24:14.720 --> 00:24:21.140
并且正在并且正在生产中，因此

00:24:18.770 --> 00:24:23.570
解决此问题的常见方法是

00:24:21.140 --> 00:24:27.850
在测试中使用内存数据库

00:24:23.570 --> 00:24:32.240
所以你可以使用h2你可以使用hsqldb 

00:24:27.850 --> 00:24:34.010
作为替代品

00:24:32.240 --> 00:24:35.270
您可能会在内存中使用的应用程序

00:24:34.010 --> 00:24:36.590
可能足够的数据库

00:24:35.270 --> 00:24:38.270
取决于应用

00:24:36.590 --> 00:24:40.190
持久性需求，但我认为那是

00:24:38.270 --> 00:24:42.650
非常例外，而不是

00:24:40.190 --> 00:24:45.740
规则，以便您可以加入h2 

00:24:42.650 --> 00:24:47.930
放入hsqldb作为替换，然后

00:24:45.740 --> 00:24:51.770
你进入那会有一些风险

00:24:47.930 --> 00:24:53.980
 h2或hsqldb在哪里运行

00:24:51.770 --> 00:24:57.290
和我的后端完全一样

00:24:53.980 --> 00:24:58.520
 h2具有一些兼容模式，因此对于

00:24:57.290 --> 00:25:00.890
您可以在Postgres中运行它的示例

00:24:58.520 --> 00:25:03.710
假装为兼容模式

00:25:00.890 --> 00:25:06.050
表现得像Postgres数据库，所以

00:25:03.710 --> 00:25:08.660
是特定于事物的行为

00:25:06.050 --> 00:25:11.620
 Postgres和H2尝试模仿

00:25:08.660 --> 00:25:15.200
并以相同的方式表现

00:25:11.620 --> 00:25:17.120
在某种程度上，这是很好的

00:25:15.200 --> 00:25:18.620
兼容性与

00:25:17.120 --> 00:25:20.840
您使用的Postgres版本

00:25:18.620 --> 00:25:23.120
那么你几乎会陷入沉迷

00:25:20.840 --> 00:25:24.890
我对安全思想的错误认识

00:25:23.120 --> 00:25:27.140
在Postgres中使用h2对此进行了测试

00:25:24.890 --> 00:25:29.090
兼容模式我所有的SQL都是

00:25:27.140 --> 00:25:31.220
绝对很好，然后你实际上

00:25:29.090 --> 00:25:33.290
找出何时指向真正的Postgres 

00:25:31.220 --> 00:25:36.860
实例，那不好，你

00:25:33.290 --> 00:25:38.330
查询开始中断，所以我认为什么时候

00:25:36.860 --> 00:25:42.200
发生这种情况，您需要替代方法

00:25:38.330 --> 00:25:44.660
选项，我认为这是真的

00:25:42.200 --> 00:25:46.430
一个很好的项目叫做测试

00:25:44.660 --> 00:25:50.060
容器你们中有多少人听说过

00:25:46.430 --> 00:25:52.580
测试容器可以一半左右

00:25:50.060 --> 00:25:55.250
那些还没有测试的人

00:25:52.580 --> 00:26:00.320
 container是一个开源项目

00:25:55.250 --> 00:26:05.270
使用docker和docker容器

00:26:00.320 --> 00:26:06.860
站起来，在这种情况下，您可以

00:26:05.270 --> 00:26:08.600
基本上你可以运行它可以站起来

00:26:06.860 --> 00:26:10.130
码头集装箱中的任何东西

00:26:08.600 --> 00:26:13.280
您可以打包的所有内容

00:26:10.130 --> 00:26:17.360
 docker容器测试容器将

00:26:13.280 --> 00:26:18.890
帮助您在测试中使用，但通常

00:26:17.360 --> 00:26:20.900
用法和我想谈的一个

00:26:18.890 --> 00:26:23.360
这是它站起来的实际

00:26:20.900 --> 00:26:27.380
 Redis的真实实例或真实的

00:26:23.360 --> 00:26:30.860
 Mongo或我的续集或

00:26:27.380 --> 00:26:33.550
您正在使用的任何数据存储测试

00:26:30.860 --> 00:26:37.220
容器可以为您提供帮助

00:26:33.550 --> 00:26:40.910
通过规则与J单元4集成

00:26:37.220 --> 00:26:42.800
 J单元5消防和扩展2 

00:26:40.910 --> 00:26:46.670
基本上可以让你在

00:26:42.800 --> 00:26:48.860
测试我想要Redis，它会走

00:26:46.670 --> 00:26:51.320
只要有码头工人就可以

00:26:48.860 --> 00:26:53.110
在您的机器上运行它将消失

00:26:51.320 --> 00:26:55.460
您可以将其指向特定的

00:26:53.110 --> 00:26:57.410
 Redis的docker映像，因此可能是

00:26:55.460 --> 00:27:01.160
仅来自docker hub的一个

00:26:57.410 --> 00:27:02.660
 docker hub上的标准Redis映像或

00:27:01.160 --> 00:27:04.490
它可以是任何docker镜像

00:27:02.660 --> 00:27:07.040
属于您自己的创作之一

00:27:04.490 --> 00:27:09.440
需要，它将在您进行测试时

00:27:07.040 --> 00:27:11.060
运行它将为该容器启动

00:27:09.440 --> 00:27:13.550
然后为您提供非常简单的方法

00:27:11.060 --> 00:27:15.470
访问您的主机名和端口

00:27:13.550 --> 00:27:17.360
需要使用与Redis进行通信

00:27:15.470 --> 00:27:19.070
在那个容器中运行，然后你

00:27:17.360 --> 00:27:20.990
可以运行，或者您知道它不必

00:27:19.070 --> 00:27:22.940
成为Redis的任何数据存储，然后您

00:27:20.990 --> 00:27:26.630
可以针对该数据进行测试

00:27:22.940 --> 00:27:28.340
存放在已知货品中

00:27:26.630 --> 00:27:30.080
状态，因为它是一个新鲜的码头工人

00:27:28.340 --> 00:27:32.000
每次都有容器，这样您就不用了

00:27:30.080 --> 00:27:34.130
担心其他测试

00:27:32.000 --> 00:27:36.620
污染了数据库或遗留了东西

00:27:34.130 --> 00:27:38.510
一个破碎的国家，事情将完全一样

00:27:36.620 --> 00:27:41.030
他们在docker映像被保留时被留下了

00:27:38.510 --> 00:27:42.530
由第三方创建（如果是） 

00:27:41.030 --> 00:27:46.970
在公共docker hub上或者您已经

00:27:42.530 --> 00:27:48.650
造成的不利之处是码头工人

00:27:46.970 --> 00:27:51.460
故事和Windows无法正常工作

00:27:48.650 --> 00:27:53.810
很好，但是如果您使用的是Mac或Linux，我

00:27:51.460 --> 00:27:55.850
会彻底建议退房

00:27:53.810 --> 00:27:58.450
像测试容器之类的东西

00:27:55.850 --> 00:28:01.520
亲自如此在 spring boot 代码库中

00:27:58.450 --> 00:28:04.280
实际上，我们为

00:28:01.520 --> 00:28:06.440
有一个嵌入式Mongo项目

00:28:04.280 --> 00:28:09.650
哪种尝试做类似的

00:28:06.440 --> 00:28:12.230
的东西，如果您使用 spring boot 

00:28:09.650 --> 00:28:13.970
测试支持，您就可以

00:28:12.230 --> 00:28:16.280
对类的嵌入式Mongo依赖

00:28:13.970 --> 00:28:19.340
路径然后 spring boot 测试支持

00:28:16.280 --> 00:28:20.930
将自动配置嵌入式Mongo，但是

00:28:19.340 --> 00:28:22.700
嵌入式Mongo这个名字有点像

00:28:20.930 --> 00:28:27.170
这有点用词不当，不是真的

00:28:22.700 --> 00:28:28.790
嵌入它不是嵌入在JVM中

00:28:27.170 --> 00:28:30.410
以及哪些测试正在运行

00:28:28.790 --> 00:28:33.890
真的意味着它将抓住一切

00:28:30.410 --> 00:28:35.840
一个Mongo二进制文件在您的计算机上启动它

00:28:33.890 --> 00:28:39.200
机器，然后你可以在一个类似的

00:28:35.840 --> 00:28:41.360
您可以获取端口来访问该端口的方法

00:28:39.200 --> 00:28:43.160
 Mongo实例，然后您可以运行

00:28:41.360 --> 00:28:46.070
针对这个真实的现实世界进行测试

00:28:43.160 --> 00:28:47.930
 Mongo实例，这很棒，因为

00:28:46.070 --> 00:28:50.240
您实际上是在对Mongo进行测试

00:28:47.930 --> 00:28:52.520
而不是蒙戈的一些嘲讽变体

00:28:50.240 --> 00:28:54.190
我认为有一些项目

00:28:52.520 --> 00:28:56.320
这些数据存储中

00:28:54.190 --> 00:28:58.600
尝试嘲笑他们并假装自己

00:28:56.320 --> 00:29:01.389
实际的真实事物，但是有一些

00:28:58.600 --> 00:29:03.940
使用h2或hsqldb的相同问题

00:29:01.389 --> 00:29:05.460
在兼容模式下

00:29:03.940 --> 00:29:09.480
您可能会略有不同

00:29:05.460 --> 00:29:11.559
嵌入式Mongo之类的行为

00:29:09.480 --> 00:29:14.110
因为它不在docker中运行

00:29:11.559 --> 00:29:15.909
容器正在运行，因此如果您是

00:29:14.110 --> 00:29:18.070
您将要运行的Windows开发人员

00:29:15.909 --> 00:29:19.960
 Windows上的Mongo，而在生产中

00:29:18.070 --> 00:29:22.029
您可能正在Linux上运行，因此您已经

00:29:19.960 --> 00:29:24.039
有操作系统差异，而

00:29:22.029 --> 00:29:26.529
如果您正在docker中运行测试

00:29:24.039 --> 00:29:28.720
您可以获得或运行的容器

00:29:26.529 --> 00:29:30.429
服务器您的后端服务

00:29:28.720 --> 00:29:32.049
与数据存储或其他任何数据通信

00:29:30.429 --> 00:29:33.429
可能是因为您正在

00:29:32.049 --> 00:29:35.200
码头集装箱的机会是

00:29:33.429 --> 00:29:37.210
您可以更接近您的生产

00:29:35.200 --> 00:29:38.860
环境，所以您也许可以使用

00:29:37.210 --> 00:29:41.019
完全相同的Linux发行版

00:29:38.860 --> 00:29:42.820
相同版本的Linux内核

00:29:41.019 --> 00:29:44.139
您生产的docker容器

00:29:42.820 --> 00:29:46.450
环境正在运行，所以它只是

00:29:44.139 --> 00:29:48.759
有助于通过以下方式降低风险

00:29:46.450 --> 00:29:52.480
调整要测试的内容

00:29:48.759 --> 00:29:59.590
与正在运行的内容更加紧密

00:29:52.480 --> 00:30:01.210
您的生产环境还可以

00:29:59.590 --> 00:30:03.940
这是一种单元测试， 

00:30:01.210 --> 00:30:05.259
纯单元测试之间的灰色区域

00:30:03.940 --> 00:30:07.259
还有你开始嘲笑的东西

00:30:05.259 --> 00:30:10.779
事情出来，你开始担心

00:30:07.259 --> 00:30:13.179
关于数据库，但所有那些

00:30:10.779 --> 00:30:15.549
你可以做所有这些测试

00:30:13.179 --> 00:30:18.220
无需启动应用程序即可完成

00:30:15.549 --> 00:30:20.860
上下文，以便您可以测试JDBC模板或

00:30:18.220 --> 00:30:22.450
组件使用JDBC模板作为

00:30:20.860 --> 00:30:26.799
只要您注入该模板

00:30:22.450 --> 00:30:28.629
可以测试的组件中

00:30:26.799 --> 00:30:31.600
它很容易就可以模拟出来，如果

00:30:28.629 --> 00:30:33.759
您想要的话，可以配置它进行通话

00:30:31.600 --> 00:30:36.610
通过提供数据来测试容器

00:30:33.759 --> 00:30:38.289
带有特定网址的来源（如果您是

00:30:36.610 --> 00:30:40.409
测试其余模板，您不需要

00:30:38.289 --> 00:30:43.000
您可以将其绑定到应用程序上下文中

00:30:40.409 --> 00:30:46.000
到模拟休息服务服务器，并

00:30:43.000 --> 00:30:47.860
注入到您的组件，但我

00:30:46.000 --> 00:30:50.289
现在想继续谈论

00:30:47.860 --> 00:30:52.120
集成测试，这就是您要去的地方

00:30:50.289 --> 00:30:53.799
实际启动一个应用程序

00:30:52.120 --> 00:30:56.200
上下文，这就是你的地方

00:30:53.799 --> 00:30:57.879
整个或部分应用程序

00:30:56.200 --> 00:31:00.190
应用程序都已经过测试， 

00:30:57.879 --> 00:31:03.840
春天参与了依赖

00:31:00.190 --> 00:31:03.840
正在注射等

00:31:06.010 --> 00:31:14.510
所以我怀疑几乎所有人都知道

00:31:10.790 --> 00:31:16.520
 spring boot 的主要切入点

00:31:14.510 --> 00:31:19.730
测试是 spring boot 测试

00:31:16.520 --> 00:31:21.440
注解我们也有注解

00:31:19.730 --> 00:31:23.450
切片测试，但是如果您正在

00:31:21.440 --> 00:31:25.640
全面的集成测试

00:31:23.450 --> 00:31:28.970
您将使用的 spring boot 世界

00:31:25.640 --> 00:31:32.360
弹簧启动测试和弹簧启动测试

00:31:28.970 --> 00:31:35.090
钩入并建立在

00:31:32.360 --> 00:31:36.920
在Spring框架中测试框架

00:31:35.090 --> 00:31:41.810
为您提供一种 spring boot 

00:31:36.920 --> 00:31:44.780
具体的测试经验

00:31:41.810 --> 00:31:46.220
使用弹簧启动测试意味着

00:31:44.780 --> 00:31:48.410
您得到所有​​标准的一种

00:31:46.220 --> 00:31:50.060
模仿的Spring应用程序行为

00:31:48.410 --> 00:31:52.760
当你在主要方法中得到什么

00:31:50.060 --> 00:31:54.680
您运行您的应用程序，以便获得

00:31:52.760 --> 00:31:56.000
知道配置属性绑定

00:31:54.680 --> 00:31:59.120
从 spring boot ，您可以获得应用程序

00:31:56.000 --> 00:32:00.950
财产支持以及所有这些

00:31:59.120 --> 00:32:04.130
事情是春天带来的

00:32:00.950 --> 00:32:10.730
引导测试以自定义

00:32:04.130 --> 00:32:12.530
 Springs测试框架的行为

00:32:10.730 --> 00:32:15.680
我将深入了解

00:32:12.530 --> 00:32:18.980
确切的测试细节

00:32:15.680 --> 00:32:21.920
框架之所以有效，是因为一些 spring boot 

00:32:18.980 --> 00:32:26.060
测试特定功能相当不错

00:32:21.920 --> 00:32:28.490
在某种较低级别上

00:32:26.060 --> 00:32:31.100
 Springs测试框架的一部分和一个

00:32:28.490 --> 00:32:33.230
这些是上下文缓存，所以我

00:32:31.100 --> 00:32:35.540
希望在这里做的就是给你

00:32:33.230 --> 00:32:38.150
对Springs测试的所有理解

00:32:35.540 --> 00:32:40.550
框架缓存上下文以及何时

00:32:38.150 --> 00:32:42.710
将看到上下文被重用，以及何时

00:32:40.550 --> 00:32:52.660
您将看到一个特定的测试课程

00:32:42.710 --> 00:32:52.660
创建一个新的应用程序上下文

00:32:54.150 --> 00:33:00.760
这里我们有一个典型的集成测试

00:32:59.560 --> 00:33:03.010
你可能知道你可能已经

00:33:00.760 --> 00:33:07.390
所有人都看到与此非常相似的东西

00:33:03.010 --> 00:33:09.220
所以这是一个J单位，例如

00:33:07.390 --> 00:33:12.070
我们要使用的第一个注释

00:33:09.220 --> 00:33:17.110
春季赛跑者，所以这告诉J 

00:33:12.070 --> 00:33:19.450
单元将控制权移交给弹簧

00:33:17.110 --> 00:33:21.670
框架测试框架运行

00:33:19.450 --> 00:33:23.770
测试，然后我们进行了 spring boot 测试

00:33:21.670 --> 00:33:26.890
注解，这就是Spring Boot所说的

00:33:23.770 --> 00:33:28.630
到测试框架spring框架

00:33:26.890 --> 00:33:32.590
测试框架，它必须是

00:33:28.630 --> 00:33:34.420
 spring boot 样式测试，然后

00:33:32.590 --> 00:33:36.250
活动配置文件注释是一部分

00:33:34.420 --> 00:33:39.700
春季测试框架，所以这是

00:33:36.250 --> 00:33:41.350
调整活动的配置文件

00:33:39.700 --> 00:33:44.170
当您运行特定测试时

00:33:41.350 --> 00:33:45.760
所以这是建立在个人资料上

00:33:44.170 --> 00:33:47.110
特定的梁支撑或种类

00:33:45.760 --> 00:33:49.060
配置配置文件专用梁

00:33:47.110 --> 00:33:51.030
支持，然后我们有测试属性

00:33:49.060 --> 00:33:53.800
来源，这是来自的另一个注释

00:33:51.030 --> 00:33:57.070
春天的框架来测试框架，但

00:33:53.800 --> 00:33:58.720
让您提供属性来源

00:33:57.070 --> 00:34:00.640
我在这里指向属性文件

00:33:58.720 --> 00:34:03.220
然后这些属性将

00:34:00.640 --> 00:34:05.560
为环境做出贡献

00:34:03.220 --> 00:34:06.910
然后 spring boot 配置属性

00:34:05.560 --> 00:34:08.590
绑定将能够使用那些

00:34:06.910 --> 00:34:11.400
属性作为来源，因此您可以使用它

00:34:08.590 --> 00:34:15.580
调整事物自定义配置

00:34:11.400 --> 00:34:17.320
专为您的口试

00:34:15.580 --> 00:34:19.240
关于环境并对其进行自定义

00:34:17.320 --> 00:34:22.140
您可以在这里看到我正在使用

00:34:19.240 --> 00:34:25.420
 Spring Boot测试中的properties属性

00:34:22.140 --> 00:34:26.710
所以这是另一种配置方式

00:34:25.420 --> 00:34:28.240
属性，而你只有一个

00:34:26.710 --> 00:34:30.250
一两个你不想分开

00:34:28.240 --> 00:34:31.960
将它们放入单独的文件中，您可以

00:34:30.250 --> 00:34:33.730
在spring上使用properties属性

00:34:31.960 --> 00:34:38.260
开机测试，它做的完全一样

00:34:33.730 --> 00:34:40.510
它向其添加属性源的东西

00:34:38.260 --> 00:34:45.430
环境，所以我们在这里启用

00:34:40.510 --> 00:34:47.980
 JMX为此特定测试的关键

00:34:45.430 --> 00:34:53.200
几乎所有的东西

00:34:47.980 --> 00:34:55.660
这些注释是因为它们具有

00:34:53.200 --> 00:34:59.830
对将要存在的豆类的影响

00:34:55.660 --> 00:35:03.160
在应用程序上下文中如此春天

00:34:59.830 --> 00:35:06.040
引导测试活动配置文件和测试

00:35:03.160 --> 00:35:06.760
调味酱都会影响豆类

00:35:06.040 --> 00:35:08.740
出现在

00:35:06.760 --> 00:35:13.330
因此， spring boot 测试就是

00:35:08.740 --> 00:35:15.280
把它变成 spring boot 的测试

00:35:13.330 --> 00:35:17.980
应用程序，它给你

00:35:15.280 --> 00:35:21.430
配置属性绑定但是

00:35:17.980 --> 00:35:24.040
它所做的关键是

00:35:21.430 --> 00:35:26.110
它控制配置类

00:35:24.040 --> 00:35:28.330
被用作所有

00:35:26.110 --> 00:35:30.310
您的应用程序配置，以便何时

00:35:28.330 --> 00:35:33.970
您在测试中进行了 spring boot 测试

00:35:30.310 --> 00:35:36.280
下课我们去找课

00:35:33.970 --> 00:35:37.930
用Spring Boot应用程序注释

00:35:36.280 --> 00:35:40.300
所以你只有 spring boot 

00:35:37.930 --> 00:35:41.770
在您的主班上申请更多

00:35:40.300 --> 00:35:43.540
准确地说，我们实际上正在寻找

00:35:41.770 --> 00:35:45.310
用 spring boot 注释的类

00:35:43.540 --> 00:35:48.340
配置，但这是一个元

00:35:45.310 --> 00:35:51.100
在Spring Boot应用程序上的注释

00:35:48.340 --> 00:35:53.140
通常在您的应用中我们正在做什么

00:35:51.100 --> 00:35:55.420
这里要去寻找春天

00:35:53.140 --> 00:35:59.200
在一个类上启动应用程序，我们看一下

00:35:55.420 --> 00:36:01.420
包的层次结构，所以如果您

00:35:59.200 --> 00:36:02.860
测试是常见的示例fubar 

00:36:01.420 --> 00:36:04.390
看看那个包裹，然后我们去

00:36:02.860 --> 00:36:08.020
到comm example foo，然后到

00:36:04.390 --> 00:36:09.880
通讯示例，直到我们在

00:36:08.020 --> 00:36:12.250
您的主要代码带有注释

00:36:09.880 --> 00:36:14.290
 spring boot 应用程序，那就是

00:36:12.250 --> 00:36:15.760
我们将使用的类

00:36:14.290 --> 00:36:18.070
您的应用程序进行情况的来源

00:36:15.760 --> 00:36:20.820
进行配置，以使其带有注释

00:36:18.070 --> 00:36:23.170
使用Spring Boot应用程序意味着

00:36:20.820 --> 00:36:25.000
 spring boot 自动配置将

00:36:23.170 --> 00:36:28.420
打开，因为那是另一个元

00:36:25.000 --> 00:36:29.950
在Spring Boot应用程序上的注释

00:36:28.420 --> 00:36:32.080
那显然可以有一个巨大的

00:36:29.950 --> 00:36:33.970
对应用程序中的bean的影响

00:36:32.080 --> 00:36:35.800
上下文，因为您已打开自动

00:36:33.970 --> 00:36:38.110
配置，使 spring boot 自动

00:36:35.800 --> 00:36:40.390
配置将有助于

00:36:38.110 --> 00:36:42.310
豆到您的上下文中也有

00:36:40.390 --> 00:36:44.200
活动配置文件，如果您启用了一些

00:36:42.310 --> 00:36:46.030
个人资料（如果您激活了一些个人资料） 

00:36:44.200 --> 00:36:48.580
在测试中，您拥有个人资料

00:36:46.030 --> 00:36:50.320
那些豆取决于具体的豆

00:36:48.580 --> 00:36:52.360
他们是否是个人资料

00:36:50.320 --> 00:36:55.390
他们所属的是主动意志还是意志

00:36:52.360 --> 00:36:57.340
不是上下文的一部分，还有

00:36:55.390 --> 00:36:58.480
测试属性源，它可以更改

00:36:57.340 --> 00:37:01.960
环境中的属性

00:36:58.480 --> 00:37:04.180
如果您的代码或某些自动

00:37:01.960 --> 00:37:06.670
您正在使用的配置

00:37:04.180 --> 00:37:08.760
使用基于条件的条件来控制

00:37:06.670 --> 00:37:11.050
是否存在某些豆类

00:37:08.760 --> 00:37:12.940
然后是测试属性来源和

00:37:11.050 --> 00:37:14.860
提供的属性也会影响

00:37:12.940 --> 00:37:16.840
应用程序中的bean 

00:37:14.860 --> 00:37:18.700
上下文与属性类似

00:37:16.840 --> 00:37:20.650
 spring boot上的属性测试任何东西

00:37:18.700 --> 00:37:22.569
操纵环境

00:37:20.650 --> 00:37:25.630
对出现的豆有影响

00:37:22.569 --> 00:37:27.670
在上下文中有几个

00:37:25.630 --> 00:37:29.980
越来越多的注释

00:37:27.670 --> 00:37:32.109
您也可以使用会影响

00:37:29.980 --> 00:37:34.809
上下文，以便您可以使用import导入

00:37:32.109 --> 00:37:37.059
您还可以使用其他配置类

00:37:34.809 --> 00:37:38.920
使用上下文配置

00:37:37.059 --> 00:37:40.690
提供

00:37:38.920 --> 00:37:44.109
将要使用的配置类

00:37:40.690 --> 00:37:46.180
配置测试的上下文，以便

00:37:44.109 --> 00:37:47.650
在编写测试时，您需要

00:37:46.180 --> 00:37:50.440
考虑所有这些不同

00:37:47.650 --> 00:37:52.450
控制和

00:37:50.440 --> 00:37:55.990
影响出现在

00:37:52.450 --> 00:37:58.660
在上下文中测试框架

00:37:55.990 --> 00:38:01.150
正在运行测试，它占

00:37:58.660 --> 00:38:04.089
当j-unit时新建一个新的测试类

00:38:01.150 --> 00:38:06.339
遇到与之交谈的新测试班

00:38:04.089 --> 00:38:08.440
 spring boot 与测试框架对话

00:38:06.339 --> 00:38:10.390
告诉它运行测试和测试

00:38:08.440 --> 00:38:12.220
框架开始运作，并研究所有

00:38:10.390 --> 00:38:14.289
这些用于配置的资源

00:38:12.220 --> 00:38:16.960
并弄清楚哪些豆子要去

00:38:14.289 --> 00:38:19.420
在上下文中并创建一个缓存

00:38:16.960 --> 00:38:22.779
基于所有配置的密钥

00:38:19.420 --> 00:38:25.329
并且仅当缓存键与

00:38:22.779 --> 00:38:27.789
先前的测试将重用上下文

00:38:25.329 --> 00:38:30.130
因此，如果您巧妙地更改

00:38:27.789 --> 00:38:34.510
配置，使您拥有一个

00:38:30.130 --> 00:38:36.520
多一点或少一点豆，你就会

00:38:34.510 --> 00:38:38.260
发现测试框架将开始

00:38:36.520 --> 00:38:40.480
为您而非您提供新环境

00:38:38.260 --> 00:38:42.270
重用旧的，所以如果您正在跑步

00:38:40.480 --> 00:38:44.380
您的 spring boot 测试套件，您会发现

00:38:42.270 --> 00:38:46.150
你知道你有很多

00:38:44.380 --> 00:38:47.470
集成测试，您会发现

00:38:46.150 --> 00:38:50.559
事情比你想的要慢

00:38:47.470 --> 00:38:52.599
要看的一件事是多少

00:38:50.559 --> 00:38:54.910
正在创建应用程序上下文

00:38:52.599 --> 00:38:56.920
并且有日志记录支持，您可以

00:38:54.910 --> 00:38:58.900
如果您设置，请在测试框架中打开

00:38:56.920 --> 00:39:01.089
所有Spring框架测试以进行调试

00:38:58.900 --> 00:39:02.589
记录它会输出信息

00:39:01.089 --> 00:39:04.230
关于缓存命中和未命中以及

00:39:02.589 --> 00:39:07.000
事物，它可以帮助您识别

00:39:04.230 --> 00:39:08.730
问题或很少的优化

00:39:07.000 --> 00:39:10.960
可以分享

00:39:08.730 --> 00:39:12.750
跨测试进行配置，以便

00:39:10.960 --> 00:39:14.980
应用程序上下文可以重用

00:39:12.750 --> 00:39:16.839
这是否真的是一个问题

00:39:14.980 --> 00:39:18.789
取决于您的应用程序有多大

00:39:16.839 --> 00:39:21.549
以及需要多长时间

00:39:18.789 --> 00:39:23.140
刷新，因此会有所不同，具体取决于

00:39:21.549 --> 00:39:25.529
您正在使用的应用程序的大小

00:39:23.140 --> 00:39:25.529
从事

00:39:26.280 --> 00:39:30.120
在某些情况下， 

00:39:28.740 --> 00:39:32.520
你实际上是上下文收银员

00:39:30.120 --> 00:39:35.190
故意不希望上下文

00:39:32.520 --> 00:39:37.740
兑现您可能有一个测试

00:39:35.190 --> 00:39:39.750
留下上下文的副作用或

00:39:37.740 --> 00:39:42.600
在上下文中有些脏的东西

00:39:39.750 --> 00:39:45.240
它不是处于干净状态，我们想要

00:39:42.600 --> 00:39:47.520
我们的测试能够在没有

00:39:45.240 --> 00:39:49.770
对其他测试有副作用

00:39:47.520 --> 00:39:52.080
不想编写需要

00:39:49.770 --> 00:39:53.700
以特定的顺序运行，因为它

00:39:52.080 --> 00:39:55.410
可能导致您遇到奇怪的问题

00:39:53.700 --> 00:39:57.210
运行一点测试套件

00:39:55.410 --> 00:39:59.640
一切都过去了，然后你跑

00:39:57.210 --> 00:40:02.390
整个事情和所有事情都失败了

00:39:59.640 --> 00:40:04.650
顺序发生变化，因为理论上

00:40:02.390 --> 00:40:08.430
你知道不能保证订购

00:40:04.650 --> 00:40:10.530
总是一样，所以你

00:40:08.430 --> 00:40:12.540
可能有一些东西，例如

00:40:10.530 --> 00:40:15.930
更改其中之一的内存状态

00:40:12.540 --> 00:40:16.800
您的豆类脏物上下文可以提供帮助

00:40:15.930 --> 00:40:18.960
你这样，因为你基本上是

00:40:16.800 --> 00:40:21.120
对测试框架说不要缓存

00:40:18.960 --> 00:40:22.320
对我而言，我知道这是

00:40:21.120 --> 00:40:24.930
会使上下文陷入困境

00:40:22.320 --> 00:40:26.940
状态和其他任何后续测试

00:40:24.930 --> 00:40:31.530
如果使用相同的配置

00:40:26.940 --> 00:40:33.060
需要一个新的上下文，所以现在您已经

00:40:31.530 --> 00:40:35.010
希望对如何

00:40:33.060 --> 00:40:36.360
我想要的上下文缓存工作

00:40:35.010 --> 00:40:38.220
与您谈谈切片测试

00:40:36.360 --> 00:40:40.530
 spring boot 支持你们

00:40:38.220 --> 00:40:46.410
熟悉春季的试片

00:40:40.530 --> 00:40:51.270
引导好酷，所以我们有一堆

00:40:46.410 --> 00:40:53.940
春天的 spring boot 中的注释

00:40:51.270 --> 00:40:55.710
引导测试自动配置模块

00:40:53.940 --> 00:40:58.500
为您提供测试支持

00:40:55.710 --> 00:41:00.600
您的应用程序的特定部分

00:40:58.500 --> 00:41:02.700
你可以在这里看到我们有

00:41:00.600 --> 00:41:04.290
各种数据后端，所以弹簧数据

00:41:02.700 --> 00:41:07.530
 LDAP弹簧数据JPA 

00:41:04.290 --> 00:41:09.300
带来数据Redis等，我们还有一个

00:41:07.530 --> 00:41:11.670
与网络相关的测试切片

00:41:09.300 --> 00:41:14.490
您正在使用Spring MVC，有Web MVC 

00:41:11.670 --> 00:41:17.630
测试是否使用网络流量来检测网络

00:41:14.490 --> 00:41:19.680
流量测试其余客户测试做测试

00:41:17.630 --> 00:41:21.960
您可能想做的各种事情

00:41:19.680 --> 00:41:24.600
测试，这使您可以做的事

00:41:21.960 --> 00:41:27.090
在一个特定的方面

00:41:24.600 --> 00:41:30.540
应用程序的一部分，而不是

00:41:27.090 --> 00:41:34.620
测试整个事情，并做到这一点

00:41:30.540 --> 00:41:36.450
通过组件扫描过滤，所以当

00:41:34.620 --> 00:41:38.700
您的应用程序启动，您正在

00:41:36.450 --> 00:41:39.690
使用组件扫描，我们开始

00:41:38.700 --> 00:41:42.150
看着扣

00:41:39.690 --> 00:41:44.609
地球找到您所有的组件

00:41:42.150 --> 00:41:47.099
切片测试为此添加了一个过滤器

00:41:44.609 --> 00:41:48.930
组件扫描过程，因此我们将其删除

00:41:47.099 --> 00:41:51.030
与

00:41:48.930 --> 00:41:54.540
您正在测试的特定切片

00:41:51.030 --> 00:41:56.849
例如，如果您正在测试一些数据

00:41:54.540 --> 00:41:58.950
 JPA的东西，那么你真的不在乎

00:41:56.849 --> 00:42:00.810
关于您的Web控制器，以便我们可以

00:41:58.950 --> 00:42:05.339
从测试中排除所有这些并且

00:42:00.810 --> 00:42:07.890
只关注数据JPA部分，以便

00:42:05.339 --> 00:42:10.589
这里给你一个具体的例子

00:42:07.890 --> 00:42:12.510
我们有一个示例应用程序

00:42:10.589 --> 00:42:14.430
所以我们有 spring boot 应用程序

00:42:12.510 --> 00:42:16.260
我们主要的应用程序类别

00:42:14.430 --> 00:42:18.660
一个包，然后我们有两个

00:42:16.260 --> 00:42:20.550
为客户打包一个，为客户打包一个

00:42:18.660 --> 00:42:23.160
订单，在每个订单中我们都有一些网站

00:42:20.550 --> 00:42:25.859
的东西，在这种情况下，一些JPA的东西，所以

00:42:23.160 --> 00:42:31.349
我们有扩展JPA的接口

00:42:25.859 --> 00:42:34.020
如果我们使用数据JPA测试和

00:42:31.349 --> 00:42:36.960
通过组件扫描会发生什么

00:42:34.020 --> 00:42:39.510
过滤是我们摆脱了

00:42:36.960 --> 00:42:41.880
控制器的设置现在是这样

00:42:39.510 --> 00:42:44.069
不用付钱的环境

00:42:41.880 --> 00:42:46.380
这些控制器的成本是

00:42:44.069 --> 00:42:47.640
在应用程序上下文中创建

00:42:46.380 --> 00:42:49.859
刷新或什至确实

00:42:47.640 --> 00:42:52.980
依赖所有将在

00:42:49.859 --> 00:42:54.930
上下文是JPA存储库， 

00:42:52.980 --> 00:42:56.640
然后是JPA基础架构

00:42:54.930 --> 00:42:59.010
他们取决于，所以我们将引导数据

00:42:56.640 --> 00:43:00.630
源和休眠以及您的JPA 

00:42:59.010 --> 00:43:02.400
仓库，就是这样

00:43:00.630 --> 00:43:08.339
其他所有东西都会被过滤掉

00:43:02.400 --> 00:43:08.849
如果您编写Web MVC，也会有类似的结果

00:43:08.339 --> 00:43:10.859
测试

00:43:08.849 --> 00:43:13.890
另一面会怎样

00:43:10.859 --> 00:43:16.020
它会摆脱您所有的JPA 

00:43:13.890 --> 00:43:18.359
东西，所以您将不再支付费用

00:43:16.020 --> 00:43:20.700
引导休眠时，您只是

00:43:18.359 --> 00:43:23.099
想要测试您的Web层

00:43:20.700 --> 00:43:25.829
得到您的控制器和所有

00:43:23.099 --> 00:43:31.170
 JPA东西数据源休眠等将

00:43:25.829 --> 00:43:33.720
现在都被过滤掉了

00:43:31.170 --> 00:43:35.550
这创造的是或你

00:43:33.720 --> 00:43:37.740
发生这种情况时需要做的数据

00:43:35.550 --> 00:43:39.569
 JPA可能很好，因为它是

00:43:37.740 --> 00:43:42.480
有点依赖

00:43:39.569 --> 00:43:44.550
图和您的数据JPA存储库是

00:43:42.480 --> 00:43:46.650
图中叶节点的种类

00:43:44.550 --> 00:43:48.930
您的代码不会

00:43:46.650 --> 00:43:51.990
向它们注入任何依赖关系，但是

00:43:48.930 --> 00:43:53.490
他们可能会为您的控制器打电话

00:43:51.990 --> 00:43:55.170
其他服务或他们

00:43:53.490 --> 00:43:56.640
正在调用spring数据存储库或

00:43:55.170 --> 00:43:58.860
一些东西，所以你需要提供

00:43:56.640 --> 00:44:00.270
给他们一些互动的东西

00:43:58.860 --> 00:44:02.040
与你知道这是他们将要

00:44:00.270 --> 00:44:05.850
一些需要的依赖

00:44:02.040 --> 00:44:12.150
注入，这是模拟豆和

00:44:05.850 --> 00:44:14.340
间谍豆进来，所以你可以在这里看到

00:44:12.150 --> 00:44:17.310
想象我们有客户总监

00:44:14.340 --> 00:44:19.350
 Web MVC测试上的集成测试

00:44:17.310 --> 00:44:21.720
所以我说我只是想测试我的

00:44:19.350 --> 00:44:23.610
 Web层我正在注入客户

00:44:21.720 --> 00:44:25.200
因为我想要存储库到测试中

00:44:23.610 --> 00:44:28.140
卖回之前的一些行为

00:44:25.200 --> 00:44:30.180
我锻炼我的控制器，我也

00:44:28.140 --> 00:44:32.880
必须提供单独的配置

00:44:30.180 --> 00:44:36.090
类提供客户的模拟

00:44:32.880 --> 00:44:38.010
仓库和订单仓库，以及

00:44:36.090 --> 00:44:40.590
这里有很多仪式

00:44:38.010 --> 00:44:45.600
有点笨拙，您必须设置所有这些

00:44:40.590 --> 00:44:49.170
模拟，因此您可以将其替换为

00:44:45.600 --> 00:44:52.260
使用模拟豆代替所以

00:44:49.170 --> 00:44:54.180
这里的配置本质上是

00:44:52.260 --> 00:44:56.280
相当于以前没有

00:44:54.180 --> 00:44:58.230
不再需要任何静态

00:44:56.280 --> 00:45:00.510
嘲笑客户的课程

00:44:58.230 --> 00:45:03.000
仓库和订单仓库

00:45:00.510 --> 00:45:05.490
这些字段使用模拟注释

00:45:03.000 --> 00:45:08.100
 spring boot 测试发现豆

00:45:05.490 --> 00:45:10.020
支持，我们将替换

00:45:08.100 --> 00:45:12.030
客户资源库在上下文中

00:45:10.020 --> 00:45:15.119
已经有一个或将添加一个

00:45:12.030 --> 00:45:16.920
为此，您现在有了一个客户

00:45:15.119 --> 00:45:19.290
您的存储库或订单存储库

00:45:16.920 --> 00:45:21.630
然后就可以设定任何期望

00:45:19.290 --> 00:45:23.670
在测试中，然后您就可以锻炼

00:45:21.630 --> 00:45:26.940
您的控制器使用模拟MVC或

00:45:23.670 --> 00:45:29.100
无论你喜欢什么，并检查给定的

00:45:26.940 --> 00:45:33.570
来自存储库的某些响应

00:45:29.100 --> 00:45:34.830
是否有预期的事情

00:45:33.570 --> 00:45:36.720
仍然有些东西，虽然那不是很

00:45:34.830 --> 00:45:40.920
我真的不喜欢

00:45:36.720 --> 00:45:42.630
我们有客户资料库

00:45:40.920 --> 00:45:44.940
客户总监测试客户

00:45:42.630 --> 00:45:48.900
仓库，但我们也有订单

00:45:44.940 --> 00:45:51.270
仓库，那是我不喜欢的错误

00:45:48.900 --> 00:45:52.859
我以为你的蛋ust 

00:45:51.270 --> 00:45:56.160
域不应该对

00:45:52.859 --> 00:45:58.140
订购域，反之亦然，因为

00:45:56.160 --> 00:46:00.540
这些代码在单独的程序包中

00:45:58.140 --> 00:46:02.070
因为我们需要我们所有的

00:46:00.540 --> 00:46:04.020
控制器将存在于

00:46:02.070 --> 00:46:05.609
上下文，因为我们已经切出

00:46:04.020 --> 00:46:07.200
除了控制器和

00:46:05.609 --> 00:46:09.599
网络相关的东西

00:46:07.200 --> 00:46:11.790
您仍然需要提供模拟订单

00:46:09.599 --> 00:46:13.650
仓库，这意味着你不能

00:46:11.790 --> 00:46:15.900
您的订单存储库界面包

00:46:13.650 --> 00:46:19.049
私人的，所以您现在仅用于测试

00:46:15.900 --> 00:46:21.859
目的，你不得不增加

00:46:19.049 --> 00:46:24.089
您的某些api的可见性

00:46:21.859 --> 00:46:25.799
引入包装缠结的风险

00:46:24.089 --> 00:46:28.799
或人们在各地呼叫事物

00:46:25.799 --> 00:46:31.500
您的网域，当他们不应该这样做时

00:46:28.799 --> 00:46:33.270
我们真正想去的地方是

00:46:31.500 --> 00:46:34.890
我们只需要嘲笑客户

00:46:33.270 --> 00:46:37.950
测试我们的客户的资料库

00:46:34.890 --> 00:46:41.640
控制器以及我们可以提供的帮助

00:46:37.950 --> 00:46:44.549
就是说我们可以对网络MVC说

00:46:41.640 --> 00:46:47.190
测试我想让你专注于

00:46:44.549 --> 00:46:49.440
特定的控制器，所以我不要你

00:46:47.190 --> 00:46:52.980
专注于所有控制器，但

00:46:49.440 --> 00:46:54.780
现在就专注于这个控制器

00:46:52.980 --> 00:46:57.869
你应该考虑一下

00:46:54.780 --> 00:46:59.700
在你的脑海中

00:46:57.869 --> 00:47:02.220
我提到的有关上下文的事情

00:46:59.700 --> 00:47:05.280
如果您专注于

00:47:02.220 --> 00:47:07.589
特定控制器和Web MVC 

00:47:05.280 --> 00:47:09.089
确实缩小了豆子的范围

00:47:07.589 --> 00:47:11.640
在上下文中，您将要

00:47:09.089 --> 00:47:14.700
了解基本的Web基础架构

00:47:11.640 --> 00:47:16.770
这是模拟MVC所需的，因此您将获得

00:47:14.700 --> 00:47:18.270
像模拟派遣一个servlet但

00:47:16.770 --> 00:47:20.280
你只需要一个控制器

00:47:18.270 --> 00:47:22.559
如果您为订单编写另一个测试

00:47:20.280 --> 00:47:24.930
控制器，您就可以专注于

00:47:22.559 --> 00:47:26.549
您将获得的订单控制器

00:47:24.930 --> 00:47:28.650
另一个环境将不会

00:47:26.549 --> 00:47:30.960
上下文缓存的机会

00:47:28.650 --> 00:47:33.599
重用该上下文，所以有一个

00:47:30.960 --> 00:47:35.880
需要在此处进行权衡

00:47:33.599 --> 00:47:37.079
这个案例，根据我们的经验

00:47:35.880 --> 00:47:39.180
通常是因为

00:47:37.079 --> 00:47:41.970
你专注于一个特定的

00:47:39.180 --> 00:47:43.710
控制刷新时间

00:47:41.970 --> 00:47:46.290
应用程序上下文是最小的，因为

00:47:43.710 --> 00:47:49.339
它很少，所以好处

00:47:46.290 --> 00:47:53.160
就代码可见性而言

00:47:49.339 --> 00:47:55.020
和专注能力

00:47:53.160 --> 00:47:57.480
特别是要测试的内容

00:47:55.020 --> 00:47:59.250
我们的经验超过了成本

00:47:57.480 --> 00:48:02.130
创建额外的上下文，因为它们

00:47:59.250 --> 00:48:03.869
很快被重新创建

00:48:02.130 --> 00:48:06.480
造成了抱歉，但这是要

00:48:03.869 --> 00:48:08.970
拥抱时切记

00:48:06.480 --> 00:48:10.829
测试支持以考虑

00:48:08.970 --> 00:48:12.720
它可以对上下文产生的影响

00:48:10.829 --> 00:48:15.829
缓存，因为它确实会影响bean 

00:48:12.720 --> 00:48:15.829
在上下文中

00:48:16.650 --> 00:48:22.779
现在只剩几分钟了

00:48:20.289 --> 00:48:26.260
我最后要提的是J 

00:48:22.779 --> 00:48:28.450
不幸的是，第5单元

00:48:26.260 --> 00:48:30.430
昨天，所以我不能要求大家走

00:48:28.450 --> 00:48:31.779
今天晚些时候去山姆的谈话，但我能

00:48:30.430 --> 00:48:34.299
说是我会彻底推荐

00:48:31.779 --> 00:48:39.010
在YouTube上查看录音

00:48:34.299 --> 00:48:40.990
会议J单元5之后

00:48:39.010 --> 00:48:43.000
现在对春季特别重要

00:48:40.990 --> 00:48:46.690
引导用户终于终于

00:48:43.000 --> 00:48:48.670
我们至少要这样做一次

00:48:46.690 --> 00:48:52.720
弹簧释放，如果不是两个，则较小释放

00:48:48.670 --> 00:48:55.750
 2.2 spring boot 测试会给你J 

00:48:52.720 --> 00:48:58.660
默认情况下，单元5而非J单元4 

00:48:55.750 --> 00:49:00.730
所以J单元5有很多东西

00:48:58.660 --> 00:49:04.420
我说过的显示名称的东西

00:49:00.730 --> 00:49:05.470
关于嵌套测试类

00:49:04.420 --> 00:49:07.690
新的东西在那里

00:49:05.470 --> 00:49:10.930
扩展模型可以很好地完成这些工作

00:49:07.690 --> 00:49:13.809
查看Sam的谈话以了解更多信息

00:49:10.930 --> 00:49:15.910
在录音中以及当您

00:49:13.809 --> 00:49:20.410
升级到Spring Boot 2.2，您将

00:49:15.910 --> 00:49:22.869
默认情况下使用J单元5，但

00:49:20.410 --> 00:49:25.630
拖延了我们这样做的事情

00:49:22.869 --> 00:49:28.450
当我们一直在等待Maven的时候

00:49:25.630 --> 00:49:30.519
准备好就是这样

00:49:28.450 --> 00:49:34.450
我们已经在 spring boot 中配置了J单元5 

00:49:30.519 --> 00:49:36.519
测试意味着您的J单元4测试将

00:49:34.450 --> 00:49:38.859
继续在J单元5上运行

00:49:36.519 --> 00:49:41.799
无需更改任何代码，因此

00:49:38.859 --> 00:49:43.660
您可以随时迁移到J单元5 

00:49:41.799 --> 00:49:44.710
您已经准备好，或者可以坚持使用J 

00:49:43.660 --> 00:49:47.740
单元4 API 

00:49:44.710 --> 00:49:52.059
在J单元5测试之上运行

00:49:47.740 --> 00:49:54.970
执行引擎，这是通过

00:49:52.059 --> 00:49:57.640
属于J单元5的老式引擎

00:49:54.970 --> 00:50:00.519
就您的代码而言

00:49:57.640 --> 00:50:03.279
让我们假装成j单元4，所以你

00:50:00.519 --> 00:50:05.109
可以继续使用j单元5并进行迁移

00:50:03.279 --> 00:50:08.259
它会继续加入您的4和

00:50:05.109 --> 00:50:09.759
迁移至第5个单元， 

00:50:08.259 --> 00:50:12.279
这样做不会太大

00:50:09.759 --> 00:50:17.140
升级到春季时爆炸开关

00:50:12.279 --> 00:50:18.730
启动2.2，这就是我所拥有的

00:50:17.140 --> 00:50:20.440
非常感谢您的宝贵时间

00:50:18.730 --> 00:50:23.799
希望大家都觉得有用

00:50:20.440 --> 00:50:25.299
我认为我们没时间了，但我会

00:50:23.799 --> 00:50:26.559
在大厅外面，如果有的话

00:50:25.299 --> 00:50:28.000
问题，你想提出来， 

00:50:26.559 --> 00:50:29.140
问我还是在其他地方看到我

00:50:28.000 --> 00:50:30.010
会议当天请来

00:50:29.140 --> 00:50:31.510
问我任何

00:50:30.010 --> 00:50:33.750
非常感谢你

00:50:31.510 --> 00:50:33.750
大家

00:50:35.450 --> 00:50:40.980
 [音乐] 

