WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.900 --> 00:00:08.450
 [音乐] 

00:00:05.980 --> 00:00:10.340
好吧，我想我想我们可以开始

00:00:08.450 --> 00:00:12.710
大概两分钟之后

00:00:10.340 --> 00:00:13.429
我觉得很好

00:00:12.710 --> 00:00:15.740
大家早上好

00:00:13.429 --> 00:00:18.560
希望您在这里玩得开心

00:00:15.740 --> 00:00:20.840
会议并在巴塞罗那举行

00:00:18.560 --> 00:00:22.510
一般，公平地说，我的意思是

00:00:20.840 --> 00:00:25.789
巴塞罗那是一个很棒的地方

00:00:22.510 --> 00:00:28.820
很难没有美好的时光

00:00:25.789 --> 00:00:30.170
我最近在这里与同事交谈

00:00:28.820 --> 00:00:32.419
我会讲有关Java的内容

00:00:30.170 --> 00:00:33.890
关系持久性，他告诉我

00:00:32.419 --> 00:00:35.540
像哦，我的天哪，你为什么不能讲

00:00:33.890 --> 00:00:37.940
实际上很酷的东西

00:00:35.540 --> 00:00:41.450
就像你知道也许没有续集

00:00:37.940 --> 00:00:43.480
微服务等等，所以也许让我们

00:00:41.450 --> 00:00:46.940
遵循他的思维方式

00:00:43.480 --> 00:00:49.430
大约10年前像99 10 

00:00:46.940 --> 00:00:53.149
多年前的无续集运动

00:00:49.430 --> 00:00:54.649
开始，没有第一个续集

00:00:53.149 --> 00:00:56.300
旧金山聚会或多或少

00:00:54.649 --> 00:00:57.949
就像一切始于旧金山

00:00:56.300 --> 00:01:01.340
所以我们可以说是一个很好的约会

00:00:57.949 --> 00:01:03.289
我想知道你们中有多少人在工作

00:01:01.340 --> 00:01:05.059
像专业人士一样从事业务

00:01:03.289 --> 00:01:06.500
如果您可以养育超过10年

00:01:05.059 --> 00:01:10.250
你的手只跟布比

00:01:06.500 --> 00:01:12.799
好吧，我想大概是50 50 

00:01:10.250 --> 00:01:14.570
像50％的人觉得

00:01:12.799 --> 00:01:17.450
有趣，因为当我当我

00:01:14.570 --> 00:01:21.470
开始工作，我刚开始

00:01:17.450 --> 00:01:24.530
当时的2008年会议

00:01:21.470 --> 00:01:26.689
当某人有2至3年的

00:01:24.530 --> 00:01:28.430
他已经有资格参加

00:01:26.689 --> 00:01:32.360
因为整体

00:01:28.430 --> 00:01:34.549
社区还有些不成熟，但是

00:01:32.360 --> 00:01:36.079
回到聚会，所以

00:01:34.549 --> 00:01:38.869
见面会宣布我们的终结

00:01:36.079 --> 00:01:40.280
 DBMS时代也许是正确的，也是其中之一

00:01:38.869 --> 00:01:41.960
这次聚会的报价是

00:01:40.280 --> 00:01:43.790
关系数据库也给您

00:01:41.960 --> 00:01:46.399
他们迫使你扭曲你的物体

00:01:43.790 --> 00:01:48.979
数据适合我们的DBMS，无后遗症

00:01:46.399 --> 00:01:51.290
只要给你你需要的东西，我想

00:01:48.979 --> 00:01:55.130
每个与关系部门合作的人

00:01:51.290 --> 00:01:56.930
数据库或我的意思是特别以

00:01:55.130 --> 00:01:59.869
与文档一起说基本数据库

00:01:56.930 --> 00:02:02.360
知道这是什么意思，两者

00:01:59.869 --> 00:02:04.670
人们看到的主要问题

00:02:02.360 --> 00:02:08.289
关系数据库是

00:02:04.670 --> 00:02:11.270
没有真正的可扩展性，它们是

00:02:08.289 --> 00:02:14.670
僵化的意思，我们必须定义这个

00:02:11.270 --> 00:02:17.400
固定模式，模式真的很难

00:02:14.670 --> 00:02:20.370
这些就像两个主要的

00:02:17.400 --> 00:02:23.580
担心没有续集数据库

00:02:20.370 --> 00:02:25.170
当时的地址是10 10 

00:02:23.580 --> 00:02:27.780
年前，所以已经是相当

00:02:25.170 --> 00:02:31.140
虽然很多事情都变了

00:02:27.780 --> 00:02:34.170
从那以后在关系

00:02:31.140 --> 00:02:36.240
数据库空间，我会选择我

00:02:34.170 --> 00:02:39.180
像三个数据库一样选择

00:02:36.240 --> 00:02:41.400
甚至有两个半的时间

00:02:39.180 --> 00:02:42.780
最流行的

00:02:41.400 --> 00:02:44.250
他们是开源的，我也没工作

00:02:42.780 --> 00:02:46.290
与Oracle息息相关，所以我也不会说

00:02:44.250 --> 00:02:48.150
一般而言，有关Oracle的内容很多，但是

00:02:46.290 --> 00:02:50.670
 Postgres特别是那是我的

00:02:48.150 --> 00:02:53.190
过去最喜欢的数据库

00:02:50.670 --> 00:02:54.840
几年他们确实发展了很多

00:02:53.190 --> 00:02:57.120
让我们说说改进

00:02:54.840 --> 00:02:58.650
核心引擎让我们回到过去

00:02:57.120 --> 00:03:00.510
您想对

00:02:58.650 --> 00:03:02.730
数据库结构，例如添加新的

00:03:00.510 --> 00:03:04.800
更改类型的列等等

00:03:02.730 --> 00:03:08.310
你很有可能最终会陷入

00:03:04.800 --> 00:03:10.560
表锁意味着您

00:03:08.310 --> 00:03:12.959
数据库将无法读取

00:03:10.560 --> 00:03:16.140
或从特定的表格或

00:03:12.959 --> 00:03:19.049
它真正取决于的特定行

00:03:16.140 --> 00:03:20.880
当然，我们的应用程序

00:03:19.049 --> 00:03:23.730
时下经常建造有

00:03:20.880 --> 00:03:25.350
数以百万计的消费者

00:03:23.730 --> 00:03:27.420
每秒的请求数

00:03:25.350 --> 00:03:29.220
表锁意味着请求

00:03:27.420 --> 00:03:31.580
将开始堆积，基本上

00:03:29.220 --> 00:03:34.049
一切都会开始爆炸， 

00:03:31.580 --> 00:03:35.910
那就是他们几乎要面对的问题

00:03:34.049 --> 00:03:37.650
消除它，所以今天很

00:03:35.910 --> 00:03:39.180
您不太可能会获得表日志

00:03:37.650 --> 00:03:40.920
即使创建索引，您也可以

00:03:39.180 --> 00:03:43.230
同时创建索引，以便

00:03:40.920 --> 00:03:45.930
在后台创建索引

00:03:43.230 --> 00:03:48.060
他们还介绍了JSON数据类型

00:03:45.930 --> 00:03:50.989
就像直接解决

00:03:48.060 --> 00:03:55.440
假设没有续集数据库

00:03:50.989 --> 00:03:57.150
优势，所以现在不仅您拥有

00:03:55.440 --> 00:03:59.790
具有的所有好处

00:03:57.150 --> 00:04:02.340
关系结构，如果你

00:03:59.790 --> 00:04:04.980
需要存储某种非结构化的

00:04:02.340 --> 00:04:07.980
您可以将其放入JSON列的数据

00:04:04.980 --> 00:04:09.570
时间类型，您不必放

00:04:07.980 --> 00:04:11.579
就像一个字符串，实际上是

00:04:09.570 --> 00:04:13.950
你们都可以索引的结构

00:04:11.579 --> 00:04:15.870
您可以像使用字段一样进行查询

00:04:13.950 --> 00:04:17.640
他们也有对XML的支持， 

00:04:15.870 --> 00:04:19.410
还没有个人使用，他们也支持

00:04:17.640 --> 00:04:20.940
地理空间查询和全文搜索

00:04:19.410 --> 00:04:24.270
全文搜索可能不像

00:04:20.940 --> 00:04:27.330
令人印象深刻的Lucene指数，让我们

00:04:24.270 --> 00:04:28.620
说弹性搜索，但我的意思仍然是

00:04:27.330 --> 00:04:30.900
完全足够

00:04:28.620 --> 00:04:35.060
许多用例基本上如此繁荣

00:04:30.900 --> 00:04:38.190
变得非常认真

00:04:35.060 --> 00:04:39.960
功能丰富的数据库，我的续集

00:04:38.190 --> 00:04:41.790
日子就像我们说的

00:04:39.960 --> 00:04:44.130
该数据库的WordPress的，所以不是

00:04:41.790 --> 00:04:46.020
对于严重的东西，但多年来

00:04:44.130 --> 00:04:48.360
他们也进化了，所以现在他们喜欢

00:04:46.020 --> 00:04:49.740
这是我们期望的功能

00:04:48.360 --> 00:04:51.840
成为外国人的标准

00:04:49.740 --> 00:04:54.870
他们还支持关键的AC交易

00:04:51.840 --> 00:04:56.610
 JSON，它在很多严肃的情况下都被使用

00:04:54.870 --> 00:04:58.400
 Pinterest的项目基于我的

00:04:56.610 --> 00:05:02.130
续集，或者至少曾经是

00:04:58.400 --> 00:05:03.479
然后我们有这个，这些是

00:05:02.130 --> 00:05:07.340
两个数据库，现在我们有了一半

00:05:03.479 --> 00:05:09.060
因为AWS Aurora并非完全

00:05:07.340 --> 00:05:10.979
假设完全不同

00:05:09.060 --> 00:05:13.830
数据库，但它是一个引擎

00:05:10.979 --> 00:05:15.660
它建立在或也许是

00:05:13.830 --> 00:05:18.870
它是一个数据库

00:05:15.660 --> 00:05:20.940
与邮政礼服或我的兼容

00:05:18.870 --> 00:05:22.919
续集，他们将其作为

00:05:20.940 --> 00:05:25.350
云的关系数据库和

00:05:22.919 --> 00:05:27.210
所有其他云提供商都拥有

00:05:25.350 --> 00:05:29.699
我没用过的类似东西

00:05:27.210 --> 00:05:31.500
具有但能够提供AWS Aurora地址的功能是

00:05:29.699 --> 00:05:34.710
很好的可扩展性问题

00:05:31.500 --> 00:05:36.870
关系数据库，我的意思是一个

00:05:34.710 --> 00:05:39.389
事实是，他们至少声称

00:05:36.870 --> 00:05:41.160
快了十倍

00:05:39.389 --> 00:05:44.400
比我的续集基准测试更快

00:05:41.160 --> 00:05:49.310
显示不同的东西，但这全都取决于

00:05:44.400 --> 00:05:52.770
您如何操作基准，但是

00:05:49.310 --> 00:05:54.870
没有两个很好的方法来扩展

00:05:52.770 --> 00:05:56.099
 Aurora数据库，一个就是可以扩展

00:05:54.870 --> 00:05:57.720
这样基本上可以使用

00:05:56.099 --> 00:05:59.639
更大的实例，真的不算什么

00:05:57.720 --> 00:06:02.580
新功能，但考虑到您可以扩展

00:05:59.639 --> 00:06:05.190
直到运行120的机器为止

00:06:02.580 --> 00:06:06.599
您的CPU和4 TB RAM 

00:06:05.190 --> 00:06:09.599
你必须承认这是一个漂亮的

00:06:06.599 --> 00:06:11.820
好的说明，我的意思是，这是

00:06:09.599 --> 00:06:16.050
可以处理很多，但您也可以

00:06:11.820 --> 00:06:19.440
扩展它，以便您可以阅读更多

00:06:16.050 --> 00:06:21.930
复制品，这意味着所有

00:06:19.440 --> 00:06:23.550
读取去读取副本，您可以

00:06:21.930 --> 00:06:26.699
随心所欲

00:06:23.550 --> 00:06:28.229
可能有限制，因此

00:06:26.699 --> 00:06:29.729
许多用例也足够了

00:06:28.229 --> 00:06:33.720
他们最后还介绍了服务器

00:06:29.729 --> 00:06:36.409
版本的意思是说

00:06:33.720 --> 00:06:40.710
他们分配了计算能力，包括

00:06:36.409 --> 00:06:42.259
您的帐单比例取决于

00:06:40.710 --> 00:06:44.509
你的流量

00:06:42.259 --> 00:06:46.550
所以这是两个问题

00:06:44.509 --> 00:06:48.800
是关系的主要问题

00:06:46.550 --> 00:06:52.389
数据库，它们一直是

00:06:48.800 --> 00:06:55.009
到现在为止，但对我来说最多

00:06:52.389 --> 00:06:58.729
有趣和最大的问题

00:06:55.009 --> 00:07:00.289
没有续集数据库是，或者也许

00:06:58.729 --> 00:07:02.319
关系数据库的好处是

00:07:00.289 --> 00:07:06.470
关系数据库更多

00:07:02.319 --> 00:07:10.190
如果您不使用任何续集数据库，请原谅

00:07:06.470 --> 00:07:12.800
只是为了澄清我是

00:07:10.190 --> 00:07:15.650
没有续集数据库的忠实拥护者

00:07:12.800 --> 00:07:17.389
通用多个不同的数据库，但是

00:07:15.650 --> 00:07:19.159
他们有一个很大的缺点，所以

00:07:17.389 --> 00:07:21.229
通常在没有续集的情况下

00:07:19.159 --> 00:07:24.099
您必须构建的数据库

00:07:21.229 --> 00:07:28.219
设计非隐式架构，并

00:07:24.099 --> 00:07:31.009
针对特定的用例

00:07:28.219 --> 00:07:35.770
特定访问权限的特定功能

00:07:31.009 --> 00:07:39.469
模式，可能发生的是

00:07:35.770 --> 00:07:41.419
随时间变化的需求或

00:07:39.469 --> 00:07:43.340
访问模式发生变化，然后您

00:07:41.419 --> 00:07:46.520
突然可能会变成这种状态

00:07:43.340 --> 00:07:49.069
你的续集没有续集结构

00:07:46.520 --> 00:07:51.289
不再适合，然后您必须

00:07:49.069 --> 00:07:53.630
重组它，但重组

00:07:51.289 --> 00:07:55.880
没有续集数据库并非易事

00:07:53.630 --> 00:07:57.469
因为没有支持

00:07:55.880 --> 00:08:00.139
因此通常您必须编写脚本

00:07:57.469 --> 00:08:03.139
或在最坏的情况下找到其他解决方法

00:08:00.139 --> 00:08:04.610
可能会发生的情况，甚至可能不会发生

00:08:03.139 --> 00:08:07.279
能够重组它，因为您可能

00:08:04.610 --> 00:08:08.870
已经丢失了一些数据，但随着

00:08:07.279 --> 00:08:10.909
关系数据库，我们拥有所有

00:08:08.870 --> 00:08:13.310
续集的力量，所以无论如何

00:08:10.909 --> 00:08:15.169
改变我们可以很容易地使用续集

00:08:13.310 --> 00:08:17.779
具有续集保证的语言

00:08:15.169 --> 00:08:19.219
我们可以基本重组的语言

00:08:17.779 --> 00:08:24.229
数据我们将其洗牌到

00:08:19.219 --> 00:08:27.020
不同的桌子，所以我非常喜欢

00:08:24.229 --> 00:08:30.020
还是来自卢卡斯的这条推文

00:08:27.020 --> 00:08:32.360
我的意思是续集一无所获

00:08:30.020 --> 00:08:33.169
没有关系数据库的任何地方

00:08:32.360 --> 00:08:35.329
去任何地方

00:08:33.169 --> 00:08:36.620
它们在过去20年内有效，并且

00:08:35.329 --> 00:08:40.329
我很确定他们将对

00:08:36.620 --> 00:08:43.010
未来20年

00:08:40.329 --> 00:08:45.440
我的名字是马特·埃瓦尔·科瓦奇，我是

00:08:43.010 --> 00:08:50.630
独立顾问，意味着我是

00:08:45.440 --> 00:08:53.120
自从我成为 Spring 的自由职业者

00:08:50.630 --> 00:08:54.960
意味着自从开始使用Spring 技术

00:08:53.120 --> 00:08:57.900
 2007年

00:08:54.960 --> 00:08:59.730
最近我工作的大部分项目

00:08:57.900 --> 00:09:04.140
与基于棉花和大多数

00:08:59.730 --> 00:09:06.510
它们在AWS上运行，我也为

00:09:04.140 --> 00:09:08.760
开源项目项目，它是

00:09:06.510 --> 00:09:10.410
这些通常是洒水项目

00:09:08.760 --> 00:09:11.880
这就像最近的

00:09:10.410 --> 00:09:14.040
改变我所做的可能不是

00:09:11.880 --> 00:09:16.740
非常令人印象深刻，但只要我发现

00:09:14.040 --> 00:09:18.000
我发现错误的东西

00:09:16.740 --> 00:09:19.530
那也许可以改善

00:09:18.000 --> 00:09:21.870
至少我尝试过，并不会发生

00:09:19.530 --> 00:09:26.400
通常，但我鼓励您这样做

00:09:21.870 --> 00:09:29.460
每当你有时间去年

00:09:26.400 --> 00:09:31.620
花了大部分时间陪我儿子

00:09:29.460 --> 00:09:33.990
我休了六个月的育儿假， 

00:09:31.620 --> 00:09:36.300
我知道很多人不能真正

00:09:33.990 --> 00:09:38.040
负担得起，但只要你愿意，我就会

00:09:36.300 --> 00:09:41.070
强烈建议您这样做，因为

00:09:38.040 --> 00:09:44.280
这确实建立了反弹

00:09:41.070 --> 00:09:46.230
孩子很多，我也经营YouTube 

00:09:44.280 --> 00:09:49.470
我叫Spring Academy的频道

00:09:46.230 --> 00:09:51.450
发布有关spring it的视频教程

00:09:49.470 --> 00:09:54.120
这些视频至少像更多或

00:09:51.450 --> 00:09:56.430
不像一个月一次，但是

00:09:54.120 --> 00:09:59.100
好，因为不是，我的意思是

00:09:56.430 --> 00:10:00.720
耗时，但是如果您喜欢

00:09:59.100 --> 00:10:04.440
 Spring ，你喜欢说看

00:10:00.720 --> 00:10:06.780
乔什（Josh）漫长的 Spring 提示这是什么

00:10:04.440 --> 00:10:08.630
我们可以说那是类似的

00:10:06.780 --> 00:10:10.800
它的目标是与 spring 技巧 一样好

00:10:08.630 --> 00:10:12.930
回到我们的话题

00:10:10.800 --> 00:10:15.630
所以谈话的话题是

00:10:12.930 --> 00:10:18.030
关系数据库的状态

00:10:15.630 --> 00:10:21.300
对不起Java关系的状态

00:10:18.030 --> 00:10:24.600
抵抗和很多事情

00:10:21.300 --> 00:10:26.160
在这个空间里有很多

00:10:24.600 --> 00:10:31.230
有趣的框架很多

00:10:26.160 --> 00:10:33.180
有趣的技术，想法是

00:10:31.230 --> 00:10:38.670
我将介绍这些技术

00:10:33.180 --> 00:10:40.530
给你，以便以后如果你喜欢

00:10:38.670 --> 00:10:42.150
开始一个新项目甚至工作

00:10:40.530 --> 00:10:44.070
与您现有的项目，您将

00:10:42.150 --> 00:10:47.520
能够做出更好的决定，例如

00:10:44.070 --> 00:10:48.930
可供选择的技术

00:10:47.520 --> 00:10:50.610
我们要做的是澄清一些

00:10:48.930 --> 00:10:54.000
基础知识，因为我看到了关于

00:10:50.610 --> 00:10:56.430
两个Java冠军之间的Twitter，例如

00:10:54.000 --> 00:10:57.960
如果休眠是JDBC的替代方法

00:10:56.430 --> 00:11:00.150
这样就像一个快速的介绍

00:10:57.960 --> 00:11:02.460
这些东西实际上是如何工作的

00:11:00.150 --> 00:11:03.900
总是以一个数据库开头

00:11:02.460 --> 00:11:05.550
哪个数据库并不重要

00:11:03.900 --> 00:11:07.860
在另一边是我们

00:11:05.550 --> 00:11:08.760
应用程序，这个应用程序的工作原理

00:11:07.860 --> 00:11:11.370
与数据对话

00:11:08.760 --> 00:11:13.050
通过网络以及这些数据库中的每一个

00:11:11.370 --> 00:11:16.350
使用有点不同

00:11:13.050 --> 00:11:20.870
有线协议，所以我们当然不

00:11:16.350 --> 00:11:25.290
想像我们的山羊一样学习

00:11:20.870 --> 00:11:27.180
我们要编写续集查询

00:11:25.290 --> 00:11:30.150
为了做到这一点，它贯穿了整个过程

00:11:27.180 --> 00:11:33.030
 JDBC驱动程序，因此JDBC是标准的

00:11:30.150 --> 00:11:34.890
每组都有一组相似的接口

00:11:33.030 --> 00:11:38.970
这些供应商在右边

00:11:34.890 --> 00:11:41.130
方面必须实施以符合要求

00:11:38.970 --> 00:11:45.500
使用JDBC，然后我们将这个jar放入

00:11:41.130 --> 00:11:50.730
我们的应用程序，我们编写代码

00:11:45.500 --> 00:11:52.140
看起来像这样

00:11:50.730 --> 00:11:53.490
不完全是我们编写的代码

00:11:52.140 --> 00:11:54.900
至少我没有见过这种崇拜

00:11:53.490 --> 00:11:57.660
在生产中，因为显然这是

00:11:54.900 --> 00:12:00.570
太低级了，我的意思是你不

00:11:57.660 --> 00:12:04.350
想要我的意思是这是要求

00:12:00.570 --> 00:12:07.490
错误是正确的，但没有错

00:12:04.350 --> 00:12:10.590
关于JDBC本身，我们通常会做什么

00:12:07.490 --> 00:12:11.940
我们认为在对象中写Java是

00:12:10.590 --> 00:12:16.110
面向对象的语言，我们非常

00:12:11.940 --> 00:12:17.850
曾经与实体合作

00:12:16.110 --> 00:12:21.600
是我们想要的代码

00:12:17.850 --> 00:12:23.960
写，所以我们把我们的应用程序JP a 

00:12:21.600 --> 00:12:26.520
在大多数情况下是

00:12:23.960 --> 00:12:30.510
休眠任何人使用不同的JP 

00:12:26.520 --> 00:12:34.590
提供者这里有两只手还可以

00:12:30.510 --> 00:12:36.590
所以这意味着我不知道5％ 

00:12:34.590 --> 00:12:38.580
也许是那样的我

00:12:36.590 --> 00:12:40.170
我个人从来没有机会

00:12:38.580 --> 00:12:42.600
说高伯尔尼语是最好的

00:12:40.170 --> 00:12:44.280
只是它变得如此如此

00:12:42.600 --> 00:12:45.570
标准权利，因此它的工作方式

00:12:44.280 --> 00:12:47.610
我们里面有一个冬眠

00:12:45.570 --> 00:12:50.040
应用程序还有JDBC驱动程序

00:12:47.610 --> 00:12:52.380
以及每当您对

00:12:50.040 --> 00:12:56.430
冬眠它总是经历

00:12:52.380 --> 00:13:01.580
 JDBC，因此JDBC仍在

00:12:56.430 --> 00:13:01.580
引擎盖，即使您使用冬眠

00:13:02.740 --> 00:13:08.420
所以在接下来的演讲中，我将

00:13:04.760 --> 00:13:11.180
实际使用JPA和休眠，我

00:13:08.420 --> 00:13:14.330
总是想着同一件事，我

00:13:11.180 --> 00:13:16.070
想从JP开始，所以JP最

00:13:14.330 --> 00:13:17.450
无论何时何地

00:13:16.070 --> 00:13:19.220
该项目为解决方案加注星标

00:13:17.450 --> 00:13:21.500
数据库，他们只是JP，这是一个

00:13:19.220 --> 00:13:24.260
标准每个人都知道，这是

00:13:21.500 --> 00:13:28.940
简单好吧，至少很容易

00:13:24.260 --> 00:13:31.570
首先，我不认为

00:13:28.940 --> 00:13:38.020
 JP a很简单，我认为JP a是

00:13:31.570 --> 00:13:40.010
如果我们看这样一个超级复杂

00:13:38.020 --> 00:13:41.870
映射这就像规范

00:13:40.010 --> 00:13:43.310
例如或多或少，我们有这个免费的

00:13:41.870 --> 00:13:46.520
您想购买的实体

00:13:43.310 --> 00:13:49.100
使用JP a将它们输入数据库

00:13:46.520 --> 00:13:50.990
冬眠，所以事情首先

00:13:49.100 --> 00:13:54.890
我们把这些注释像

00:13:50.990 --> 00:13:57.710
实体ID一对多订单

00:13:54.890 --> 00:14:02.360
有多个订单商品

00:13:57.710 --> 00:14:04.130
与某个产品有关，所以这已经是

00:14:02.360 --> 00:14:05.930
不好，因为订单是保留订单

00:14:04.130 --> 00:14:07.310
关键字，所以我们必须摆在桌子上

00:14:05.930 --> 00:14:10.910
但这实际上不是很大

00:14:07.310 --> 00:14:13.760
交易，但实际上我必须先运行它

00:14:10.910 --> 00:14:17.300
找到它，然后我们编写代码

00:14:13.760 --> 00:14:20.030
与最有可能的 spring data JPA 

00:14:17.300 --> 00:14:22.040
看起来或多或少像这样，我们

00:14:20.030 --> 00:14:23.900
期望它可以完美地工作，但是

00:14:22.040 --> 00:14:26.090
实际上发生的是，我们得到了这个

00:14:23.900 --> 00:14:28.280
临时对象异常的例外

00:14:26.090 --> 00:14:31.340
该对象引用了不安全的对象

00:14:28.280 --> 00:14:34.040
临时实例，并为某人

00:14:31.340 --> 00:14:38.450
假设在初级阶段，这是

00:14:34.040 --> 00:14:40.730
像这样的隐秘信息

00:14:38.450 --> 00:14:42.380
这当然是什么意思

00:14:40.730 --> 00:14:44.720
必须学习JPA才能真正理解

00:14:42.380 --> 00:14:50.480
它，但您必须输入Cascade类型

00:14:44.720 --> 00:14:52.580
全部，然后代码运行良好，除了

00:14:50.480 --> 00:14:55.940
它创建的数据库结构

00:14:52.580 --> 00:14:58.610
我至少不会

00:14:55.940 --> 00:15:00.950
期望，因为订单和

00:14:58.610 --> 00:15:03.770
订购项目我们有一对多

00:15:00.950 --> 00:15:06.770
关系但数据库结构

00:15:03.770 --> 00:15:09.020
生成或什么冬眠

00:15:06.770 --> 00:15:10.430
期望是不同的，所以我们如何

00:15:09.020 --> 00:15:12.050
可以解决它，我们必须放另一个

00:15:10.430 --> 00:15:14.090
作为联合列的注释，以及

00:15:12.050 --> 00:15:15.220
然后我们将获得数据库结构

00:15:14.090 --> 00:15:18.490
我们实际上

00:15:15.220 --> 00:15:20.529
我们期望，有很多人

00:15:18.490 --> 00:15:21.639
与这类斗争

00:15:20.529 --> 00:15:23.230
问题

00:15:21.639 --> 00:15:25.480
每次你有这种

00:15:23.230 --> 00:15:28.420
您必须运行应用程序的问题

00:15:25.480 --> 00:15:31.209
运行测试以查看其实际效果

00:15:28.420 --> 00:15:33.310
有效，这只是一个简单的例子

00:15:31.209 --> 00:15:34.959
你实际上可以更深入

00:15:33.310 --> 00:15:37.089
所有这些小事情都在休眠

00:15:34.959 --> 00:15:39.160
那有很大的不同，那怎么办

00:15:37.089 --> 00:15:45.129
大多数人通常会处理这个

00:15:39.160 --> 00:15:48.250
问题，他们去那个博客，那是一个

00:15:45.129 --> 00:15:50.379
像冬眠般工作很抱歉

00:15:48.250 --> 00:15:51.819
冬眠的开发者拥护者，他是

00:15:50.379 --> 00:15:54.069
基本上谁都知道的家伙

00:15:51.819 --> 00:15:57.279
关于冬眠，所以他每个人都去

00:15:54.069 --> 00:15:58.569
到他的博客文章，这不是很大

00:15:57.279 --> 00:16:00.399
惊讶的是他有数百个

00:15:58.569 --> 00:16:02.379
每月有成千上万的访客，因为

00:16:00.399 --> 00:16:04.149
他的内容实际上非常非常好

00:16:02.379 --> 00:16:06.370
他解决了真正的问题

00:16:04.149 --> 00:16:08.319
人们有，我什至不只说

00:16:06.370 --> 00:16:10.120
像是初级开发者的问题

00:16:08.319 --> 00:16:12.850
从事业务的普通人

00:16:10.120 --> 00:16:15.160
多年来有这个问题，包括我

00:16:12.850 --> 00:16:17.589
因为我倾向于忘记这种

00:16:15.160 --> 00:16:19.779
东西，所以他基本上解释

00:16:17.589 --> 00:16:23.050
像你应该怎么做的一切

00:16:19.779 --> 00:16:25.629
与冬眠如何使这项工作

00:16:23.050 --> 00:16:28.360
表现出色

00:16:25.629 --> 00:16:30.100
的观点，我想知道

00:16:28.360 --> 00:16:33.819
这实际上是一件很棒的事情

00:16:30.100 --> 00:16:35.800
有这样的服务

00:16:33.819 --> 00:16:37.269
这将是最好的，这样我就可以

00:16:35.800 --> 00:16:38.769
其实不必去他的街区

00:16:37.269 --> 00:16:43.000
每当我发现一个问题

00:16:38.769 --> 00:16:45.129
以某种方式为我工作，那里

00:16:43.000 --> 00:16:46.889
最近开发了一种名为hyper的工具

00:16:45.129 --> 00:16:49.089
持久性优化器

00:16:46.889 --> 00:16:51.370
这不是免费的，但它也是

00:16:49.089 --> 00:16:53.529
便宜，我想特别是如果

00:16:51.370 --> 00:16:55.240
您在一家规模较大的公司工作， 

00:16:53.529 --> 00:16:57.639
更大的预算，这是一个工具

00:16:55.240 --> 00:17:00.550
也许值得考虑

00:16:57.639 --> 00:17:02.199
超持久性优化器是一个工具

00:17:00.550 --> 00:17:04.270
意味着像

00:17:02.199 --> 00:17:06.400
服务，所以基本上你有你的代码

00:17:04.270 --> 00:17:08.799
你问那个，它告诉你什么是

00:17:06.400 --> 00:17:11.380
错误，它的用法很简单

00:17:08.799 --> 00:17:14.919
所以你只添加一个依赖

00:17:11.380 --> 00:17:17.579
我认为该项目仍在紧要关头

00:17:14.919 --> 00:17:20.409
快照我不知道，你把这个

00:17:17.579 --> 00:17:22.600
我什至没有参加这个测试班

00:17:20.409 --> 00:17:24.610
深入了解实际在做什么

00:17:22.600 --> 00:17:28.000
像指南一样复制粘贴

00:17:24.610 --> 00:17:29.140
您应该使用它，它可以内省所有

00:17:28.000 --> 00:17:32.650
您的映射

00:17:29.140 --> 00:17:34.600
和JDBC配置，并作为输出

00:17:32.650 --> 00:17:37.510
你得到类似的东西，所以这是

00:17:34.600 --> 00:17:40.000
我针对我的一些代码运行此代码

00:17:37.510 --> 00:17:43.390
我的课，所以它立即给你

00:17:40.000 --> 00:17:46.420
提示你把自己弄得一团糟

00:17:43.390 --> 00:17:49.570
休眠配置其中一些你

00:17:46.420 --> 00:17:51.070
可以同意我的情况

00:17:49.570 --> 00:17:57.820
两者都很关键

00:17:51.070 --> 00:18:00.100
惊喜，但是是的，这就是

00:17:57.820 --> 00:18:01.210
绝对值得至少考虑

00:18:00.100 --> 00:18:04.390
有一个试用版，所以你可以

00:18:01.210 --> 00:18:06.340
总是尝试一下，但是如果我们回到

00:18:04.390 --> 00:18:08.370
这些实体的设计

00:18:06.340 --> 00:18:11.380
我们现在说的是

00:18:08.370 --> 00:18:13.360
根据JPA正确设置并休眠

00:18:11.380 --> 00:18:14.710
仍然有很多问题

00:18:13.360 --> 00:18:16.300
仍然没有答案

00:18:14.710 --> 00:18:19.630
所以哪个实体应该有

00:18:16.300 --> 00:18:21.900
相应的存储库应订购

00:18:19.630 --> 00:18:24.550
项目有产品参考

00:18:21.900 --> 00:18:27.070
订单商品应参考

00:18:24.550 --> 00:18:28.570
我的意思是有多种方式

00:18:27.070 --> 00:18:30.670
您可以使用JPA和

00:18:28.570 --> 00:18:32.860
冬眠，它并没有真正告诉你

00:18:30.670 --> 00:18:35.380
如何正确做就离开了

00:18:32.860 --> 00:18:38.470
由您自己决定，其中大多数

00:18:35.380 --> 00:18:41.620
问题已经在此得到解答

00:18:38.470 --> 00:18:45.520
书或一般由域驱动

00:18:41.620 --> 00:18:48.750
设计，他们告诉你如何构造

00:18:45.520 --> 00:18:54.190
该项目并以此知识

00:18:48.750 --> 00:18:56.140
也许你可以走很远，这

00:18:54.190 --> 00:19:00.580
是我们过渡到的方式

00:18:56.140 --> 00:19:02.560
 spring data 项目总体上如此春季

00:19:00.580 --> 00:19:05.080
数据是它建立的一个项目

00:19:02.560 --> 00:19:07.180
考虑到域驱动设计

00:19:05.080 --> 00:19:10.390
显然，您拥有存储库

00:19:07.180 --> 00:19:11.890
有你的实体，我想每个人

00:19:10.390 --> 00:19:14.440
或多或少知道它是如何工作的，因为

00:19:11.890 --> 00:19:17.710
它已经成为一种标准，我当时

00:19:14.440 --> 00:19:22.270
看起来是最古老的音符

00:19:17.710 --> 00:19:24.570
关于 spring data 项目，我不能

00:19:22.270 --> 00:19:27.520
找到任何关于喜欢的版本

00:19:24.570 --> 00:19:29.620
但是，假设我说的是一个

00:19:27.520 --> 00:19:31.870
关于1.0的博客文章，但实际上

00:19:29.620 --> 00:19:34.620
 JPA的 spring data 已经超出了

00:19:31.870 --> 00:19:40.990
奥利弗开发的名为hadas的项目

00:19:34.620 --> 00:19:42.490
希望我能出生

00:19:40.990 --> 00:19:45.190
我没有错过

00:19:42.490 --> 00:19:48.670
最难的是

00:19:45.190 --> 00:19:55.060
春季日期之前的项目

00:19:48.670 --> 00:19:57.520
 JPA正是基于这个想法

00:19:55.060 --> 00:19:59.560
由熊心瓣膜在

00:19:57.520 --> 00:20:02.650
文章中的杂志和

00:19:59.560 --> 00:20:04.630
后来它变成了

00:20:02.650 --> 00:20:06.730
Spring 数据JPA和中的Spring 数据

00:20:04.630 --> 00:20:09.790
总的来说，我感到非常着迷

00:20:06.730 --> 00:20:12.910
基本上改变了的图书馆

00:20:09.790 --> 00:20:14.860
与关系有关的一切

00:20:12.910 --> 00:20:17.830
坚持我们编写应用程序的方式

00:20:14.860 --> 00:20:22.840
以及基本上我们的应用程序

00:20:17.830 --> 00:20:25.960
影响世界的原因是

00:20:22.840 --> 00:20:28.330
撰写的文章，也可能是

00:20:25.960 --> 00:20:29.800
博客文章，所以，如果您有一些想法，我

00:20:28.330 --> 00:20:31.390
强烈鼓励写博客

00:20:29.800 --> 00:20:34.870
发布，因为你永远不知道这可能

00:20:31.390 --> 00:20:36.250
最后，关于

00:20:34.870 --> 00:20:38.080
我想说的 spring data 

00:20:36.250 --> 00:20:39.820
关于不是很好

00:20:38.080 --> 00:20:41.560
众所周知，我认为这有点

00:20:39.820 --> 00:20:43.570
正在使用，因为有很多不错的

00:20:41.560 --> 00:20:46.420
用例，这是关于

00:20:43.570 --> 00:20:53.280
从聚合发布域事件

00:20:46.420 --> 00:20:53.280
根源，让我们考虑以下代码

00:20:54.360 --> 00:20:58.780
我们有一个订单，该订单可以是

00:20:57.100 --> 00:21:02.440
确定，所以这就像

00:20:58.780 --> 00:21:04.630
确认的典型业务方法

00:21:02.440 --> 00:21:06.960
这是通常开始的顺序

00:21:04.630 --> 00:21:08.980
但是后来我们有了另一个

00:21:06.960 --> 00:21:10.690
要求每当有订单

00:21:08.980 --> 00:21:12.790
确认我们必须通知客户

00:21:10.690 --> 00:21:16.810
然后确认没有订单

00:21:12.790 --> 00:21:18.430
后来又发生了另一件事，你

00:21:16.810 --> 00:21:20.920
知道推送通知可能是

00:21:18.430 --> 00:21:23.800
发送等等，基本上这样

00:21:20.920 --> 00:21:28.750
方法永远是一个完美的候选人

00:21:23.800 --> 00:21:32.110
生长方法，我们在某个时候可能

00:21:28.750 --> 00:21:34.060
开始失去实际的领域

00:21:32.110 --> 00:21:36.850
这里的逻辑是什么

00:21:34.060 --> 00:21:40.360
分开不同的问题，有

00:21:36.850 --> 00:21:44.350
用 Spring 解决这个问题的方法

00:21:40.360 --> 00:21:45.700
使用内置事件总线的spring，所以我们

00:21:44.350 --> 00:21:47.680
甚至可以注入应用程序

00:21:45.700 --> 00:21:49.660
发布者，然后每当这件事

00:21:47.680 --> 00:21:52.450
发生了，我们只是发布了一个新事件

00:21:49.660 --> 00:21:54.370
订单已确认，订单

00:21:52.450 --> 00:21:55.360
确定只是一个非常简单的类

00:21:54.370 --> 00:21:57.730
与任何领域

00:21:55.360 --> 00:22:01.000
在这种情况下，我们见面只是一个ID， 

00:21:57.730 --> 00:22:02.590
那么我们已经将整个发送过程解耦了

00:22:01.000 --> 00:22:04.330
电子邮件推送通知等

00:22:02.590 --> 00:22:06.850
其他问题分为两个部分

00:22:04.330 --> 00:22:12.250
只听这些的组件

00:22:06.850 --> 00:22:15.520
事件，这已经看起来不错，但

00:22:12.250 --> 00:22:18.370
 spring data 使我们可以选择

00:22:15.520 --> 00:22:21.070
甚至更好，而不是发布

00:22:18.370 --> 00:22:26.020
方法中的

00:22:21.070 --> 00:22:28.360
本身，我们可以作为A +订购

00:22:26.020 --> 00:22:31.660
扩展了抽象的聚合路线

00:22:28.360 --> 00:22:33.460
抽象的聚合根为我们提供了

00:22:31.660 --> 00:22:35.290
选择注册事件，以便每当

00:22:33.460 --> 00:22:37.419
骨料内部发生了一些事情

00:22:35.290 --> 00:22:40.620
我们可以注册事件

00:22:37.419 --> 00:22:43.120
这样的事情发生了，所以一切都保持不变

00:22:40.620 --> 00:22:45.010
就像改变状态一样

00:22:43.120 --> 00:22:48.130
包括发布事件

00:22:45.010 --> 00:22:50.590
聚合内的状态以及什么

00:22:48.130 --> 00:22:52.570
然后发生，而不是有这个甚至

00:22:50.590 --> 00:22:55.660
发布者发布的事件，我们可以

00:22:52.570 --> 00:22:57.460
将方法和Spring 数据保存在

00:22:55.660 --> 00:23:00.730
只要保存了骨料，就可以罩住

00:22:57.460 --> 00:23:03.910
它发出所有的事件

00:23:00.730 --> 00:23:05.610
注册之前，所以我们基本上结束了

00:23:03.910 --> 00:23:08.440
看起来很像的方法

00:23:05.610 --> 00:23:11.290
就像所有这些美好的开始

00:23:08.440 --> 00:23:13.510
功能，我认为这看起来

00:23:11.290 --> 00:23:15.340
真的很好，分离

00:23:13.510 --> 00:23:19.990
关注是值得的

00:23:15.340 --> 00:23:23.820
看着，让我们看看另一个

00:23:19.990 --> 00:23:23.820
例如，它有点琐碎

00:23:23.970 --> 00:23:30.010
但这只是为了切题

00:23:27.429 --> 00:23:31.570
这是一个非常典型的用例

00:23:30.010 --> 00:23:34.030
您正在使用关系数据库

00:23:31.570 --> 00:23:36.190
我们不只是在哪里

00:23:34.030 --> 00:23:38.290
提取数据保存数据，依此类推

00:23:36.190 --> 00:23:42.070
但是我们要么执行一些

00:23:38.290 --> 00:23:45.040
汇总或报告，例如

00:23:42.070 --> 00:23:47.500
建立如此漂亮的HTML表格，最后

00:23:45.040 --> 00:23:52.450
非常天真地等待着与

00:23:47.500 --> 00:23:54.250
休眠和JPA就像拥有一个

00:23:52.450 --> 00:23:56.320
迈克，你有订单，那为什么不

00:23:54.250 --> 00:23:58.480
有一个返回这些的方法

00:23:56.320 --> 00:24:00.309
数量，因为所有订单项均为

00:23:58.480 --> 00:24:02.860
已经有这种方法了

00:24:00.309 --> 00:24:05.500
来自面向对象的完美

00:24:02.860 --> 00:24:07.360
观点，所以如果你写点东西

00:24:05.500 --> 00:24:08.540
这样在您的面向对象

00:24:07.360 --> 00:24:13.730
班级和大学

00:24:08.540 --> 00:24:16.790
也许你会过去，但是会发生什么

00:24:13.730 --> 00:24:19.490
引擎盖下有点吓人

00:24:16.790 --> 00:24:21.890
那如果我们执行这样的事情

00:24:19.490 --> 00:24:24.140
意思是一个查询是要获取订单， 

00:24:21.890 --> 00:24:26.420
然后每个订单项都有一个

00:24:24.140 --> 00:24:30.920
在后台执行单独的查询

00:24:26.420 --> 00:24:33.140
而如果我们只用一个

00:24:30.920 --> 00:24:39.440
续集就这么简单

00:24:33.140 --> 00:24:45.320
就像续集101这样的课程

00:24:39.440 --> 00:24:48.020
来自它的是冬眠的＆ 

00:24:45.320 --> 00:24:50.900
 JP不能代替续集

00:24:48.020 --> 00:24:54.100
每当您使用休眠和jj PA 

00:24:50.900 --> 00:24:57.080
那些很棒的工具不要忘记

00:24:54.100 --> 00:25:01.100
续集仍然是您可以使用的工具

00:24:57.080 --> 00:25:02.570
使用，可能应该使用，但随后

00:25:01.100 --> 00:25:04.640
问题是我们如何执行本机

00:25:02.570 --> 00:25:06.380
在休眠状态下使用die JPA的续集

00:25:04.640 --> 00:25:08.270
而做到这一点的方法之一就是

00:25:06.380 --> 00:25:10.960
在下面的实体上这样的东西

00:25:08.270 --> 00:25:14.510
喜欢创建一个命名的本地查询

00:25:10.960 --> 00:25:17.900
我认为这有点像

00:25:14.510 --> 00:25:19.790
理智的人或不签名，我的意思是

00:25:17.900 --> 00:25:21.860
像我这样的普通人真的不能

00:25:19.790 --> 00:25:23.060
像这样记住，我将不得不谷歌

00:25:21.860 --> 00:25:26.540
一直像我的意思

00:25:23.060 --> 00:25:29.600
注释树不是很诱人

00:25:26.540 --> 00:25:31.070
至少但幸运的是我们有 Spring 

00:25:29.600 --> 00:25:33.500
数据，所以我们可以做很多事情

00:25:31.070 --> 00:25:36.140
更好的方法，所以每个 Spring 的数据

00:25:33.500 --> 00:25:37.850
我们都知道的方法我们知道

00:25:36.140 --> 00:25:39.470
 Spring ，在JPA，我的意思是我们知道

00:25:37.850 --> 00:25:41.390
我们可以将查询注释放在

00:25:39.470 --> 00:25:43.640
可以编写J pql查询，但是有

00:25:41.390 --> 00:25:46.610
也是这一属性本机查询true 

00:25:43.640 --> 00:25:50.450
让我们执行本地续集， 

00:25:46.610 --> 00:25:52.280
这看起来已经好多了，这

00:25:50.450 --> 00:25:55.310
就像我相信默认的方式

00:25:52.280 --> 00:26:00.140
实际上在执行简单查询时

00:25:55.310 --> 00:26:01.520
您使用spring data JPA的问题

00:26:00.140 --> 00:26:05.240
真正开始，当我们必须建立

00:26:01.520 --> 00:26:06.860
更复杂的东西，当我们

00:26:05.240 --> 00:26:08.810
假设我们建立了搜寻

00:26:06.860 --> 00:26:12.320
引擎，我们有多个条件

00:26:08.810 --> 00:26:14.540
选择，这是财产

00:26:12.320 --> 00:26:16.160
在西班牙搜寻被称为相片城堡的人

00:26:14.540 --> 00:26:17.630
可以选择不同的价格

00:26:16.160 --> 00:26:19.820
不同的标准或您想要的方式

00:26:17.630 --> 00:26:24.619
选择你的公寓

00:26:19.820 --> 00:26:27.950
就像用续集构建它一样

00:26:24.619 --> 00:26:29.960
很有挑战性，所以我只带了希尔

00:26:27.950 --> 00:26:32.330
价格的子集，所以我们要在这里

00:26:29.960 --> 00:26:37.369
喜欢选择适合的公寓

00:26:32.330 --> 00:26:39.019
转换为该代码的特定价格部分

00:26:37.369 --> 00:26:41.090
几乎被委派了，所以一开始

00:26:39.019 --> 00:26:42.799
我们必须在处建立一个续集查询

00:26:41.090 --> 00:26:46.700
最后，我们必须将参数设置为

00:26:42.799 --> 00:26:49.249
有任何简单的注射和此代码

00:26:46.700 --> 00:26:51.289
非常容易出错，因为当我们

00:26:49.249 --> 00:26:55.190
手动建立续集查询

00:26:51.289 --> 00:26:58.999
意味着我们容易受到任何类型的伤害

00:26:55.190 --> 00:27:01.279
像愚蠢的错误，所以我们可以忘记

00:26:58.999 --> 00:27:03.139
逗号，我们可以放空格或者我们可以

00:27:01.279 --> 00:27:05.359
忘记我们可以加逗号的空格

00:27:03.139 --> 00:27:08.059
基本上像字符串连接是

00:27:05.359 --> 00:27:10.609
不是制作续集的最好方法

00:27:08.059 --> 00:27:17.929
查询，这就是我们是否来

00:27:10.609 --> 00:27:23.149
是个玩笑的工具

00:27:17.929 --> 00:27:26.080
笑话不是一个新的框架，而是

00:27:23.149 --> 00:27:29.929
也不像冬眠那么流行

00:27:26.080 --> 00:27:34.460
 jook jook是Lukas开发的工具

00:27:29.929 --> 00:27:37.070
加法器和Lukas加法器最像

00:27:34.460 --> 00:27:39.049
受欢迎，我什至最

00:27:37.070 --> 00:27:40.489
有知识的人喜欢在边缘

00:27:39.049 --> 00:27:42.769
 Java和续集如此

00:27:40.489 --> 00:27:44.450
基本上，他自己开发了这个

00:27:42.769 --> 00:27:46.489
好像他什么都知道

00:27:44.450 --> 00:27:49.369
关于续集，他开发了一种工具

00:27:46.489 --> 00:27:50.629
叫做笑话，这个笑话就像

00:27:49.369 --> 00:27:53.330
任务说明很清楚

00:27:50.629 --> 00:28:00.379
从生成Java代码

00:27:53.330 --> 00:28:03.739
数据库建立流畅的编译时间

00:28:00.379 --> 00:28:06.379
友好的说，续集查询的东西

00:28:03.739 --> 00:28:10.999
要注意的是，药物不是ORM，因此

00:28:06.379 --> 00:28:13.489
这并不意味着要与JPA竞争，或者

00:28:10.999 --> 00:28:16.399
休眠它也不是spring数据

00:28:13.489 --> 00:28:18.830
项目它只是一个要构建的库

00:28:16.399 --> 00:28:21.470
类型安全续集查询，它是

00:28:18.830 --> 00:28:23.960
当您必须建造复杂建筑时，这太棒了

00:28:21.470 --> 00:28:26.960
查询数据库，这太棒了

00:28:23.960 --> 00:28:29.990
读取数据可能不是

00:28:26.960 --> 00:28:31.039
很棒，如果您想保存

00:28:29.990 --> 00:28:33.110
数据，所以当然有可能

00:28:31.039 --> 00:28:36.380
保存数据

00:28:33.110 --> 00:28:38.090
根据我与我们女士合作的经验

00:28:36.380 --> 00:28:40.250
当您需要获取数据时

00:28:38.090 --> 00:28:44.620
更改它，修改状态并保持不变

00:28:40.250 --> 00:28:47.570
只需JPA或

00:28:44.620 --> 00:28:49.610
冬眠和乔克的工作方式

00:28:47.570 --> 00:28:52.010
它在

00:28:49.610 --> 00:28:54.020
在构建时间上，所以当您构建自己的

00:28:52.010 --> 00:28:56.600
进行项目内省数据库

00:28:54.020 --> 00:28:58.970
然后为您生成Java类，并

00:28:56.600 --> 00:29:01.010
这些Java类完全反映了

00:28:58.970 --> 00:29:03.470
您已经在数据库中，以便以后

00:29:01.010 --> 00:29:06.590
建立查询时，您可以

00:29:03.470 --> 00:29:09.110
就像导入普通Java一样使用它

00:29:06.590 --> 00:29:11.630
上课的好处是

00:29:09.110 --> 00:29:14.780
您的数据库结构发生了变化

00:29:11.630 --> 00:29:16.640
以不正确的方式改变

00:29:14.780 --> 00:29:19.790
您实施的金属，您会的

00:29:16.640 --> 00:29:22.670
如果在编译期间失败，则

00:29:19.790 --> 00:29:24.500
我们看这个最简单的续集

00:29:22.670 --> 00:29:27.890
查询这是当您时的样子

00:29:24.500 --> 00:29:33.770
使用Juke，因此它带有DSL， 

00:29:27.890 --> 00:29:36.800
对于SQL开发人员来说看起来很熟悉

00:29:33.770 --> 00:29:41.030
以及Java开发人员

00:29:36.800 --> 00:29:45.470
订单商品和订单ID都来自

00:29:41.030 --> 00:29:47.000
这些生成的类中的

00:29:45.470 --> 00:29:48.710
在简单的例子上总是很容易

00:29:47.000 --> 00:29:50.870
让我们再看看它的样子

00:29:48.710 --> 00:29:53.179
复杂的一个，所以我们回到

00:29:50.870 --> 00:29:55.429
搜索属性

00:29:53.179 --> 00:29:58.100
这是我们串联的方式

00:29:55.429 --> 00:30:03.980
手动字符串这是我们的工作方式

00:29:58.100 --> 00:30:06.440
开玩笑吧，选择部分是

00:30:03.980 --> 00:30:09.380
在底部，就像我们会选择

00:30:06.440 --> 00:30:12.500
我们可以指定条件，但首先

00:30:09.380 --> 00:30:14.420
它为我们提供了类型安全性，但我们也做到了

00:30:12.500 --> 00:30:16.160
这一切都是一次的，而不是分裂

00:30:14.420 --> 00:30:17.510
像在那之前，我们必须建立

00:30:16.160 --> 00:30:21.080
一个查询，然后我们必须绑定

00:30:17.510 --> 00:30:22.850
每当我们改变参数时

00:30:21.080 --> 00:30:24.520
指定我们已经设置的查询

00:30:22.850 --> 00:30:29.720
是价值观和引擎盖下的公爵

00:30:24.520 --> 00:30:31.460
如果您愿意，我们会做的一切

00:30:29.720 --> 00:30:32.929
想从开玩笑开始

00:30:31.460 --> 00:30:36.830
当然，要做的第一件事就是

00:30:32.929 --> 00:30:40.400
转到其主页乔治长期以来记录在案

00:30:36.830 --> 00:30:42.650
 Spring 的一些视频提示

00:30:40.400 --> 00:30:44.450
认真讲笑话，还有

00:30:42.650 --> 00:30:46.759
一位出色的评论演讲者

00:30:44.450 --> 00:30:51.019
迈克尔·西蒙斯

00:30:46.759 --> 00:30:53.239
从2017年春季aiyo开始

00:30:51.019 --> 00:30:56.389
展示他们如何使用它

00:30:53.239 --> 00:30:58.489
在他们的项目中，笑话真的

00:30:56.389 --> 00:31:00.769
与 spring boot 很好地集成在一起，因此您

00:30:58.489 --> 00:31:09.799
也可以在

00:31:00.769 --> 00:31:12.979
开始点Spring IO页面，所以我们谈到了

00:31:09.799 --> 00:31:15.229
关于以Java为中心的JPA 

00:31:12.979 --> 00:31:17.599
还有一个以续集为中心的笑话

00:31:15.229 --> 00:31:19.869
中间会有东西，所以

00:31:17.599 --> 00:31:24.109
 spring data 有了一个新的框架

00:31:19.869 --> 00:31:25.969
 Spring数据JDBC，这是第一个

00:31:24.109 --> 00:31:29.569
 1.0版本于去年10月发布

00:31:25.969 --> 00:31:31.219
年，从这个想法开始

00:31:29.569 --> 00:31:35.079
人们想与关系互动

00:31:31.219 --> 00:31:38.269
数据库，但他们不想使用JPA 

00:31:35.079 --> 00:31:40.999
因为也许因为那已经是我的

00:31:38.269 --> 00:31:43.429
由于JPA的复杂性而做出的假设

00:31:40.999 --> 00:31:45.799
并且由于所有功能

00:31:43.429 --> 00:31:49.940
 APA可能人们没有

00:31:45.799 --> 00:31:54.199
必然需要这样的Spring数据JDBC 

00:31:49.940 --> 00:31:57.409
带有一个简单的ORM，它

00:31:54.199 --> 00:31:59.539
包含其构建的域驱动设计

00:31:57.409 --> 00:32:01.909
从头开始，所以没有JPA 

00:31:59.539 --> 00:32:04.879
您不会，它不会实现JPA 

00:32:01.909 --> 00:32:06.829
没有冬眠的引擎盖下

00:32:04.879 --> 00:32:10.099
当然我们在幕后发现了什么

00:32:06.829 --> 00:32:11.329
是JDBC，因为它是 Spring 

00:32:10.099 --> 00:32:13.399
数据项目也一样

00:32:11.329 --> 00:32:15.159
原理，所以那里有一个仓库

00:32:13.399 --> 00:32:18.469
是映射类，还有

00:32:15.159 --> 00:32:21.559
模板，如果您使用它，感觉

00:32:18.469 --> 00:32:23.899
实际上至少对我而言

00:32:21.559 --> 00:32:26.239
喜欢与MongoDB进行交互

00:32:23.899 --> 00:32:28.459
就像在同一水平

00:32:26.239 --> 00:32:30.499
我在 spring data 中发现的简单性

00:32:28.459 --> 00:32:33.709
 Spring数据与MongoDB相同

00:32:30.499 --> 00:32:36.409
 JDBC是非常非常可预测的

00:32:33.709 --> 00:32:39.489
主要由Jen's开发

00:32:36.409 --> 00:32:42.409
由 spring data 团队负责

00:32:39.489 --> 00:32:44.419
现在让我们看一下示例

00:32:42.409 --> 00:32:47.089
我之前在JPA上展示过的

00:32:44.419 --> 00:32:48.889
就像左边的spring数据JDBC 

00:32:47.089 --> 00:32:50.869
手侧，我们拥有相同的

00:32:48.889 --> 00:32:54.440
与我们之前在

00:32:50.869 --> 00:32:58.429
右侧相同，但已映射

00:32:54.440 --> 00:33:00.169
使用Spring数据JDBC，所以第一件事

00:32:58.429 --> 00:33:02.090
要注意的是，使用差异

00:33:00.169 --> 00:33:04.460
注释的数量少得多

00:33:02.090 --> 00:33:07.269
其中的一个，因此您在

00:33:04.460 --> 00:33:17.779
右侧的ID与

00:33:07.269 --> 00:33:22.970
从Java X持久性也可以驱动

00:33:17.779 --> 00:33:26.109
您的设计，所以如果您仔细看

00:33:22.970 --> 00:33:29.179
订单商品与产品无关

00:33:26.109 --> 00:33:32.679
实体了，我的意思是它确实引用了

00:33:29.179 --> 00:33:36.080
仅按ID而不按类型

00:33:32.679 --> 00:33:41.450
就像在JPA中一样，这是因为

00:33:36.080 --> 00:33:43.669
订购订单商品这是不同的

00:33:41.450 --> 00:33:45.820
比产品产品总和

00:33:43.669 --> 00:33:48.350
根据领域驱动设计

00:33:45.820 --> 00:33:49.940
这是两个单独的集合

00:33:48.350 --> 00:33:51.889
根据域驱动设计

00:33:49.940 --> 00:33:54.200
聚合不应引用每个

00:33:51.889 --> 00:33:56.840
其他按类型而是ID和

00:33:54.200 --> 00:33:59.059
因为spring数据的JDBC包含域

00:33:56.840 --> 00:34:00.379
驱动设计是不可能做到的

00:33:59.059 --> 00:34:02.539
它与产品，如果你愿意

00:34:00.379 --> 00:34:05.690
产品在这里你会喜欢

00:34:02.539 --> 00:34:08.990
完全出乎意料的结果

00:34:05.690 --> 00:34:11.720
现在完全没有任何意义

00:34:08.990 --> 00:34:14.599
你可能会说你可以做同样的事情

00:34:11.720 --> 00:34:17.990
使用JPA正确，所以没有什么可以阻止我们停止

00:34:14.599 --> 00:34:23.179
我们从这里开始使用产品ID 

00:34:17.990 --> 00:34:27.799
 JPA方面，这是事实，但

00:34:23.179 --> 00:34:31.040
 JPA的问题是它不会

00:34:27.799 --> 00:34:32.839
强制执行，即使您提出了

00:34:31.040 --> 00:34:36.649
非常好的设计，您可以构建自己的

00:34:32.839 --> 00:34:39.619
所有领域的实体

00:34:36.649 --> 00:34:43.010
驱动的设计建议仍然

00:34:39.619 --> 00:34:44.780
在某一点上很有可能

00:34:43.010 --> 00:34:47.030
有人来了这个项目

00:34:44.780 --> 00:34:48.950
不理解这些设计

00:34:47.030 --> 00:34:52.159
约束，也许你会离开

00:34:48.950 --> 00:34:54.139
项目和整个架构

00:34:52.159 --> 00:35:00.079
关于实体的结构是

00:34:54.139 --> 00:35:02.930
走了，你又陷入了混乱

00:35:00.079 --> 00:35:04.250
预期的数据库架构

00:35:02.930 --> 00:35:07.430
这种映射就像

00:35:04.250 --> 00:35:09.619
自动合理，所以斯普林代尔

00:35:07.430 --> 00:35:12.290
 JDBC也对

00:35:09.619 --> 00:35:14.030
模式，这正是您可以做到的

00:35:12.290 --> 00:35:16.250
更改列名称，例如进行更改

00:35:14.030 --> 00:35:18.340
基本的东西，但不是框架

00:35:16.250 --> 00:35:20.830
它的意思是涵盖任何

00:35:18.340 --> 00:35:23.240
你拥有的数据库结构

00:35:20.830 --> 00:35:24.980
这就是我们的方法这就是我们的方法

00:35:23.240 --> 00:35:27.410
应该这样做，如果您正在使用

00:35:24.980 --> 00:35:29.930
旧版项目，您想

00:35:27.410 --> 00:35:33.620
开始使用JDBC的Spring数据JDBC 

00:35:29.930 --> 00:35:36.140
这个项目可能不会很好地结束

00:35:33.620 --> 00:35:37.520
但是如果您开始新的东西

00:35:36.140 --> 00:35:40.790
那可能是你可能会发生的事

00:35:37.520 --> 00:35:42.800
考虑如何使用它，我的意思是用法

00:35:40.790 --> 00:35:45.110
非常相似，所以您也有一个

00:35:42.800 --> 00:35:47.180
需要其他存储库时

00:35:45.110 --> 00:35:49.940
添加新方法您只需添加新方法

00:35:47.180 --> 00:35:53.300
方法有几个例外，所以

00:35:49.940 --> 00:35:56.390
一件事是spring数据JDBC去了

00:35:53.300 --> 00:35:58.940
至少直到现在或至少

00:35:56.390 --> 00:36:01.160
一一哦，我的灵魂自由，因为

00:35:58.940 --> 00:36:03.410
昨天是我儿子要释放，我

00:36:01.160 --> 00:36:06.860
没有检查它是否实现了目标

00:36:03.410 --> 00:36:10.580
仓库意味着你得到所有类似的东西

00:36:06.860 --> 00:36:13.220
基本的精细保存删除方法，但是

00:36:10.580 --> 00:36:15.980
它没有实现分页和排序

00:36:13.220 --> 00:36:18.410
存储库，所以不要让分页

00:36:15.980 --> 00:36:20.690
说平淡无奇

00:36:18.410 --> 00:36:24.790
也不支持的数据项目

00:36:20.690 --> 00:36:27.530
派生查询派生查询是一个查询

00:36:24.790 --> 00:36:30.110
你不必写，但这是

00:36:27.530 --> 00:36:33.410
就像从方法名派生

00:36:30.110 --> 00:36:35.960
所以用Spring 数据JPA这种方法

00:36:33.410 --> 00:36:38.330
按状态可以很好地工作

00:36:35.960 --> 00:36:41.000
如果是Spring数据JDBC，我们必须

00:36:38.330 --> 00:36:43.280
明确写出什么是续集

00:36:41.000 --> 00:36:45.530
查询我们希望它会被执行

00:36:43.280 --> 00:36:48.530
我实际上不认为这是一个

00:36:45.530 --> 00:36:51.230
大不了，也许更好

00:36:48.530 --> 00:36:53.000
事情更加明确，当然

00:36:51.230 --> 00:36:56.140
与传统的 Spring 一起工作

00:36:53.000 --> 00:36:56.140
交易管理

00:36:59.500 --> 00:37:05.960
只有一件事是

00:37:01.820 --> 00:37:08.510
如果编写此代码则不同

00:37:05.960 --> 00:37:11.450
与 spring data JPA，我的意思是

00:37:08.510 --> 00:37:13.339
确认方法安全方法

00:37:11.450 --> 00:37:15.589
并不需要，因为

00:37:13.339 --> 00:37:17.510
每当我们发现从

00:37:15.589 --> 00:37:20.150
从存储库中，这是一个

00:37:17.510 --> 00:37:23.329
由JP a管理的实体，因此JP a和

00:37:20.150 --> 00:37:25.070
冬眠，他们跟踪的变化

00:37:23.329 --> 00:37:26.540
发生在该州以及任何

00:37:25.070 --> 00:37:28.970
方法已经结束了

00:37:26.540 --> 00:37:32.450
更改将刷新到数据库

00:37:28.970 --> 00:37:36.589
对于spring数据JDBC，它的目标是

00:37:32.450 --> 00:37:38.810
要透明简单，所以不会

00:37:36.589 --> 00:37:41.150
做您不希望做的事情

00:37:38.810 --> 00:37:43.550
如果您不执行安全方法， 

00:37:41.150 --> 00:37:45.470
保存不会发生，这是这个

00:37:43.550 --> 00:37:47.750
指出我感觉更接近

00:37:45.470 --> 00:37:53.089
产生数据MongoDB然后

00:37:47.750 --> 00:37:56.270
实际上是JPA，这又是

00:37:53.089 --> 00:37:58.930
不管是好是坏

00:37:56.270 --> 00:38:04.099
考虑，我个人非常喜欢

00:37:58.930 --> 00:38:05.599
它也实现了所有

00:38:04.099 --> 00:38:08.270
关于域事件的好东西是

00:38:05.599 --> 00:38:11.390
之前提到过的问题

00:38:08.270 --> 00:38:12.890
缺少的是很多

00:38:11.390 --> 00:38:15.290
如果要比较，缺少的东西

00:38:12.890 --> 00:38:18.349
它与冬眠，所以没有脏

00:38:15.290 --> 00:38:19.310
跟踪没有延迟加载，这是

00:38:18.349 --> 00:38:21.079
实际上是设计使然

00:38:19.310 --> 00:38:23.420
没有缓存，所以没有

00:38:21.079 --> 00:38:24.859
会议，因为没有第二个

00:38:23.420 --> 00:38:26.750
一级缓存，如果您想进行缓存

00:38:24.859 --> 00:38:28.160
您必须使用spring应用程序

00:38:26.750 --> 00:38:31.069
级别缓存又不是

00:38:28.160 --> 00:38:34.310
其实很糟糕，也许是

00:38:31.069 --> 00:38:36.170
也许更好，没有

00:38:34.310 --> 00:38:37.910
多对一和多对多关系

00:38:36.170 --> 00:38:40.069
因为他们只是不适合领域

00:38:37.910 --> 00:38:42.470
驱动的设计概念，但您会得到什么

00:38:40.069 --> 00:38:44.960
相反，这很容易预测

00:38:42.470 --> 00:38:46.970
拥抱续集并保持良好的设计

00:38:44.960 --> 00:38:48.940
这些都是足够好的理由

00:38:46.970 --> 00:38:52.400
至少考虑一下

00:38:48.940 --> 00:38:54.410
它的副作用是什么

00:38:52.400 --> 00:38:56.660
因为实体可以聚合

00:38:54.410 --> 00:38:58.540
仅通过ID互相引用

00:38:56.660 --> 00:39:00.890
那也没什么能阻止你

00:38:58.540 --> 00:39:04.400
存储不同的聚合

00:39:00.890 --> 00:39:06.470
经常可能产生的不同数据源

00:39:04.400 --> 00:39:08.390
存储部分应用程序的感觉

00:39:06.470 --> 00:39:10.520
在关系数据库中，但另一个

00:39:08.390 --> 00:39:12.470
一部分，例如在Redis中，当您

00:39:10.520 --> 00:39:16.280
仅通过ID引用实体

00:39:12.470 --> 00:39:18.349
那么您就拥有了这种灵活性，我们

00:39:16.280 --> 00:39:20.480
现在就谈到这三个

00:39:18.349 --> 00:39:23.089
框架，它们都有

00:39:20.480 --> 00:39:26.480
有两个或一个共同点

00:39:23.089 --> 00:39:31.760
它们都是基于JDBC的

00:39:26.480 --> 00:39:34.790
所有阻止，不一定是

00:39:31.760 --> 00:39:38.260
问题，但这只是我们现在所处的事实

00:39:34.790 --> 00:39:41.540
我们谈论很多的阶段

00:39:38.260 --> 00:39:45.190
反应式反应框架Sprintweb 

00:39:41.540 --> 00:39:48.170
通量，当然还有阻塞

00:39:45.190 --> 00:39:51.170
 JDBC级别的连接不正确

00:39:48.170 --> 00:39:53.119
非常合适，我们可以胜任工作

00:39:51.170 --> 00:39:55.670
周围有踏板池，但是

00:39:53.119 --> 00:39:58.130
我仍然是说我们如此反应

00:39:55.670 --> 00:39:59.810
避免让您知道使用多个

00:39:58.130 --> 00:40:01.730
线程，然后我们得到一个线程

00:39:59.810 --> 00:40:05.030
游泳池不太适合，这是

00:40:01.730 --> 00:40:07.540
我们到了什么地方

00:40:05.030 --> 00:40:10.480
是2d BC comps和Ben Hale 

00:40:07.540 --> 00:40:16.550
说了我想说的大部分内容

00:40:10.480 --> 00:40:18.740
在主题演讲中，他还发表了演讲

00:40:16.550 --> 00:40:20.060
今天在5:00，我会坚决

00:40:18.740 --> 00:40:22.040
鼓励你来，如果你是一个

00:40:20.060 --> 00:40:25.460
这个话题有点，但是我们的是什么

00:40:22.040 --> 00:40:27.230
 2d BC art ODBC是规范

00:40:25.460 --> 00:40:29.720
还有一个寿命更长的图书馆

00:40:27.230 --> 00:40:32.260
少了与JDBC相同的级别，只是

00:40:29.720 --> 00:40:35.030
对于反应性，我们说

00:40:32.260 --> 00:40:38.810
 Spring 还是不仅因为 Spring 

00:40:35.030 --> 00:40:40.730
不以任何方式反弹

00:40:38.810 --> 00:40:46.099
这给我们我的意思是

00:40:40.730 --> 00:40:47.690
反应性对我来说很重要

00:40:46.099 --> 00:40:49.339
关键是没有阻塞

00:40:47.690 --> 00:40:51.200
因此，每当我们从

00:40:49.339 --> 00:40:55.160
数据库而不是获取数据

00:40:51.200 --> 00:40:58.339
立即我们得到这个单声道或助焊剂， 

00:40:55.160 --> 00:41:03.530
我们的2d BC分为多种类型

00:40:58.339 --> 00:41:06.020
 api与JDBC不同，因此它们基本上

00:41:03.530 --> 00:41:08.390
从JDBC中吸取的教训

00:41:06.020 --> 00:41:09.829
也许JDBC API不一定像

00:41:08.390 --> 00:41:11.630
您想在自己的API中使用的API 

00:41:09.829 --> 00:41:13.609
项目，但也许对

00:41:11.630 --> 00:41:15.619
图书馆提供者，所以也许你

00:41:13.609 --> 00:41:20.030
如果您构建了一个

00:41:15.619 --> 00:41:23.510
 JDBC顶部的框架是2 DB C 

00:41:20.030 --> 00:41:25.190
所以如果R 2 DB C我们有这个spi 

00:41:23.510 --> 00:41:25.720
它应该由框架使用

00:41:25.190 --> 00:41:27.040
提供者

00:41:25.720 --> 00:41:28.840
就像您想建立一个框架

00:41:27.040 --> 00:41:31.150
我们2d BC的顶部

00:41:28.840 --> 00:41:33.160
我个人喜欢的低级内容

00:41:31.150 --> 00:41:35.619
再次，我不想在我的家中看到它

00:41:33.160 --> 00:41:38.320
我的生产代码基本正确，但是有

00:41:35.619 --> 00:41:40.060
此流量级别的组件和功能

00:41:38.320 --> 00:41:42.520
当你想要的时候很有意义

00:41:40.060 --> 00:41:45.730
在2d的顶部建立下一个RM 

00:41:42.520 --> 00:41:48.430
公元前，他们还附带了我们的二维公元前

00:41:45.730 --> 00:41:50.290
已经赌注的客户是一个

00:41:48.430 --> 00:41:52.210
升级，现在让我们说如果你想

00:41:50.290 --> 00:41:54.490
可以执行一些交易

00:41:52.210 --> 00:41:59.200
在交易和通话中使用RTD BC 

00:41:54.490 --> 00:42:01.180
感觉比正常人自然得多

00:41:59.200 --> 00:42:02.619
应用程序开发人员

00:42:01.180 --> 00:42:04.619
当然还有其他框架

00:42:02.619 --> 00:42:08.170
建立在它的顶部

00:42:04.619 --> 00:42:10.150
一个是Spring 数据r2 DBC 

00:42:08.170 --> 00:42:15.040
例如将应用程序提升一级

00:42:10.150 --> 00:42:17.260
该代码甚至更好，也有一些

00:42:15.040 --> 00:42:19.660
我们完全习惯了你的意思

00:42:17.260 --> 00:42:21.640
可以建立一个构建库扩展

00:42:19.660 --> 00:42:23.800
反应性代码存储库并具有

00:42:21.640 --> 00:42:28.990
和平时一样的东西

00:42:23.800 --> 00:42:31.240
期望这是Alpha阶段，所以

00:42:28.990 --> 00:42:34.510
我认为它不建议

00:42:31.240 --> 00:42:36.430
用于生产中，但我的意思是谁从来没有

00:42:34.510 --> 00:42:40.450
我知道使用过的Alpha阶段项目五个

00:42:36.430 --> 00:42:44.349
分钟好吧，我更快，好

00:42:40.450 --> 00:42:45.820
来本·黑尔股票，五点钟

00:42:44.349 --> 00:42:48.040
那是我想要的最后一件事

00:42:45.820 --> 00:42:50.200
要说的是，我们如何测试它，所以

00:42:48.040 --> 00:42:52.750
历史上我们有很多问题

00:42:50.200 --> 00:42:55.450
通过编写集成测试

00:42:52.750 --> 00:42:56.950
关系数据库代码正确，所以我们

00:42:55.450 --> 00:42:59.710
在内存数据库中将其用作

00:42:56.950 --> 00:43:02.020
更换和它的作品，但

00:42:59.710 --> 00:43:04.060
就像我们使用一些

00:43:02.020 --> 00:43:05.800
真正的一些能力

00:43:04.060 --> 00:43:08.109
数据库，所以您要么不使用它们

00:43:05.800 --> 00:43:11.440
或者你只是不测试它们， 

00:43:08.109 --> 00:43:14.260
一个可以帮助我们

00:43:11.440 --> 00:43:16.450
实际测试数据库

00:43:14.260 --> 00:43:18.430
正确的相关代码和这个框架

00:43:16.450 --> 00:43:20.290
被称为测试容器

00:43:18.430 --> 00:43:21.940
一般用于测试数据库

00:43:20.290 --> 00:43:24.070
旋转您所使用的任何Docker容器

00:43:21.940 --> 00:43:25.839
想要从您的Java代码开始，我将展示

00:43:24.070 --> 00:43:27.339
关于如何使用它的唯一子集

00:43:25.839 --> 00:43:29.140
关系数据库，因此您添加了一个

00:43:27.339 --> 00:43:32.770
在我的情况下对测试容器的依赖

00:43:29.140 --> 00:43:36.730
这是Postgres，然后您只需输入一个

00:43:32.770 --> 00:43:38.380
Spring 的特性不同

00:43:36.730 --> 00:43:39.190
引导配置，这部分是

00:43:38.380 --> 00:43:42.180
特别是在

00:43:39.190 --> 00:43:44.470
您为该JDBC TC加上前缀的Orton 

00:43:42.180 --> 00:43:47.770
 PostgreSQL，它的工作方式

00:43:44.470 --> 00:43:50.050
当应用程序启动容器时

00:43:47.770 --> 00:43:52.569
数据库驱动程序提取docker映像

00:43:50.050 --> 00:43:54.460
开始在引擎盖下

00:43:52.569 --> 00:43:59.829
应用程序可以免费使用真实

00:43:54.460 --> 00:44:01.720
像我的意思是数据库

00:43:59.829 --> 00:44:04.329
透明地正确，这样您就可以

00:44:01.720 --> 00:44:06.369
像这样写一个普通的代码

00:44:04.329 --> 00:44:10.079
你习惯了，你也不得不选择退出

00:44:06.369 --> 00:44:15.250
用替换测试数据库

00:44:10.079 --> 00:44:16.960
与Spring 测试的支持，所以关键

00:44:15.250 --> 00:44:20.500
我想从这次演讲中总结

00:44:16.960 --> 00:44:22.569
像你一样记得

00:44:20.500 --> 00:44:24.490
 JPA之外还有一个世界

00:44:22.569 --> 00:44:28.119
 JP也没有错

00:44:24.490 --> 00:44:30.520
 JP是一个很棒的框架，我的意思是

00:44:28.119 --> 00:44:32.619
有功能最丰富的框架

00:44:30.520 --> 00:44:36.040
我认为在地球上可以互动

00:44:32.619 --> 00:44:38.319
做对象关系映射，但是

00:44:36.040 --> 00:44:40.510
这不是银弹

00:44:38.319 --> 00:44:42.160
其他选项也包括续集

00:44:40.510 --> 00:44:43.900
每当你需要做更多的事情

00:44:42.160 --> 00:44:46.030
与数据库复杂，我的意思是您使用

00:44:43.900 --> 00:44:49.180
续集数据库很愚蠢

00:44:46.030 --> 00:44:51.819
利用它的力量考虑Spring 数据

00:44:49.180 --> 00:44:53.440
 JDBC到您的项目中

00:44:51.819 --> 00:44:57.730
初期还有点

00:44:53.440 --> 00:44:59.829
越野车1.1版的功能更多

00:44:57.730 --> 00:45:01.540
承诺实际上就是

00:44:59.829 --> 00:45:05.109
我喜欢使用的版本，但是

00:45:01.540 --> 00:45:06.700
目前仍处于里程碑

00:45:05.109 --> 00:45:08.260
如果您想建立一个新的

00:45:06.700 --> 00:45:09.430
微服务，我们说这是

00:45:08.260 --> 00:45:11.650
值得考虑的事情

00:45:09.430 --> 00:45:16.109
观看我们两个DBC的进度，如果您

00:45:11.650 --> 00:45:16.109
考虑也许真的

00:45:16.170 --> 00:45:22.300
反应性应用程序，那就是

00:45:20.109 --> 00:45:24.609
我肯定使用测试的东西

00:45:22.300 --> 00:45:26.050
容器只有在您可以的情况下

00:45:24.609 --> 00:45:28.300
服务器支持旋转docker 

00:45:26.050 --> 00:45:30.520
容器使用测试容器

00:45:28.300 --> 00:45:33.190
解决很多与测试有关的测试

00:45:30.520 --> 00:45:34.420
问题非常感谢你

00:45:33.190 --> 00:45:36.910
这些都是您可以链接的

00:45:34.420 --> 00:45:40.810
找到关于我的东西，我在推特上

00:45:36.910 --> 00:45:43.750
很多，有时太多，然后

00:45:40.810 --> 00:45:45.670
我必须删除它们

00:45:43.750 --> 00:45:47.920
演示文稿将很快发布在

00:45:45.670 --> 00:45:49.750
在我也发推文的扬声器甲板上

00:45:47.920 --> 00:45:51.300
关于，所以谢谢大家

00:45:49.750 --> 00:45:53.850
来了

00:45:51.300 --> 00:45:57.390
很高兴与您交谈

00:45:53.850 --> 00:45:58.640
你谢谢你，我会像

00:45:57.390 --> 00:46:00.400
四个问题，依此类推

00:45:58.640 --> 00:46:06.980
 [掌声] 

00:46:00.400 --> 00:46:06.980
 [音乐] 

