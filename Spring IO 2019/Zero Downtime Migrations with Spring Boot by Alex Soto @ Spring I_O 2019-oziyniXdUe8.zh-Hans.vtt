WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.900 --> 00:00:08.309
 [音乐] 

00:00:04.279 --> 00:00:10.470
对，非常感谢您的光临

00:00:08.309 --> 00:00:14.460
这个 Spring 的最后一堂课

00:00:10.470 --> 00:00:16.139
今天是一个了不起的会议

00:00:14.460 --> 00:00:18.689
我将谈论零停机时间

00:00:16.139 --> 00:00:20.759
 Microsoft微服务中的部署

00:00:18.689 --> 00:00:23.609
时代，更具体地说，当你

00:00:20.759 --> 00:00:25.169
开始使用服务网格，是的，我

00:00:23.609 --> 00:00:28.650
表示示例正在运行

00:00:25.169 --> 00:00:30.179
 Spring 或 spring boot ，但我当然

00:00:28.650 --> 00:00:32.070
意味着它可以是同一件事

00:00:30.179 --> 00:00:34.650
适用于其他任何技术

00:00:32.070 --> 00:00:37.260
 Java技术，我叫Alex OTA 

00:00:34.650 --> 00:00:40.530
康复康复我是很多人的创造者

00:00:37.260 --> 00:00:42.900
塔楼，如果您喜欢这个徽标

00:00:40.530 --> 00:00:44.820
这是公爵，我的意思是这是巫师公爵

00:00:42.900 --> 00:00:47.810
会议结束后我有一些贴纸

00:00:44.820 --> 00:00:51.060
如果您愿意，可以带一些

00:00:47.810 --> 00:00:53.160
我也是测试Java的合著者

00:00:51.060 --> 00:00:55.740
微服务，还有一个抽奖活动

00:00:53.160 --> 00:00:57.360
一本电子书，所以如果您跟随我

00:00:55.740 --> 00:00:59.190
在Twitter上带有会议图片

00:00:57.360 --> 00:01:04.129
你用话题标签提到我

00:00:59.190 --> 00:01:06.600
 Spring 的yo，那么我会知道抽奖吗

00:01:04.129 --> 00:01:08.010
折扣和折扣计数为100 

00:01:06.600 --> 00:01:10.350
电子书的百分比，因此您

00:01:08.010 --> 00:01:13.830
可以变得很多冷静，然后你就

00:01:10.350 --> 00:01:17.760
删除并下载该书（如果有） 

00:01:13.830 --> 00:01:19.260
有什么问题请阻止我， 

00:01:17.760 --> 00:01:21.330
说我有一个问题，我会回答

00:01:19.260 --> 00:01:23.190
在上下文中，您知道我的意思是

00:01:21.330 --> 00:01:26.610
最后，我们可能会有一些

00:01:23.190 --> 00:01:28.620
时间，但如果不是，我是说你可以做到

00:01:26.610 --> 00:01:32.430
它在任何时候都没问题，所以

00:01:28.620 --> 00:01:36.150
让我们大概在几年前开始

00:01:32.430 --> 00:01:38.070
意味着现在看来我们发展了很多年

00:01:36.150 --> 00:01:40.770
这样的事情就像你知道的

00:01:38.070 --> 00:01:43.830
一个大型的整体应用程序

00:01:40.770 --> 00:01:45.360
实际上你知道的一切

00:01:43.830 --> 00:01:48.060
就是这样

00:01:45.360 --> 00:01:51.000
我们在组件内部有一些模块

00:01:48.060 --> 00:01:55.290
所有的应用程序，甚至每个内部

00:01:51.000 --> 00:01:57.390
模块我们可以有一些你知道一些

00:01:55.290 --> 00:01:59.580
组件，如果您考虑这些

00:01:57.390 --> 00:02:02.700
体系结构，您会看到这确实是

00:01:59.580 --> 00:02:04.439
容易部署，就像我一样

00:02:02.700 --> 00:02:06.600
不知道我是说一个字文件还是一个

00:02:04.439 --> 00:02:09.630
 jar文件无关紧要，但这是一个

00:02:06.600 --> 00:02:12.470
大型应用程序，您可以在其中运行

00:02:09.630 --> 00:02:12.470
它有效

00:02:13.290 --> 00:02:19.690
好处是通常

00:02:16.450 --> 00:02:21.640
你没有部署几次的整体

00:02:19.690 --> 00:02:24.010
每天，但您可能每个月部署一次

00:02:21.640 --> 00:02:26.290
一个月可能很好，如果你们中的一些人说

00:02:24.010 --> 00:02:28.840
每月一次，就像每六个一次

00:02:26.290 --> 00:02:30.400
可以，每六个月一次

00:02:28.840 --> 00:02:33.250
但这真的很容易，因为你

00:02:30.400 --> 00:02:35.320
甚至可以等到凌晨1:00 

00:02:33.250 --> 00:02:39.790
凌晨1:00您只需要发送维护

00:02:35.320 --> 00:02:42.610
页面交换重复，仅此而已

00:02:39.790 --> 00:02:44.800
部署几乎完成了零区域

00:02:42.610 --> 00:02:47.830
时间部署的问题是两个

00:02:44.800 --> 00:02:50.230
几年前，我们开始思考

00:02:47.830 --> 00:02:51.730
打破这个整体应用程序

00:02:50.230 --> 00:02:54.940
像这样的东西，我们从微开始

00:02:51.730 --> 00:02:56.800
服务正确，然后我们有

00:02:54.940 --> 00:02:59.500
像这样的东西，所有这些模块

00:02:56.800 --> 00:03:03.430
所有这些组成部分分布在

00:02:59.500 --> 00:03:05.950
网格所有它们相互连接

00:03:03.430 --> 00:03:09.100
网络，如您所见，这是一个

00:03:05.950 --> 00:03:12.970
图结构不是树，而是树

00:03:09.100 --> 00:03:14.620
可以在其中显示所有服务的图

00:03:12.970 --> 00:03:17.860
他们之间相互联系，所以

00:03:14.620 --> 00:03:19.540
真的很有趣，甚至有些

00:03:17.860 --> 00:03:21.090
服务可能有一个数据库， 

00:03:19.540 --> 00:03:25.720
每个服务都有自己的

00:03:21.090 --> 00:03:28.960
数据库甚至多个点

00:03:25.720 --> 00:03:31.660
某些服务可能有权访问的条目

00:03:28.960 --> 00:03:33.400
外墙，但为此

00:03:31.660 --> 00:03:35.380
总是拥有一个好主意

00:03:33.400 --> 00:03:39.550
在前面有一个AP网关

00:03:35.380 --> 00:03:42.280
支持这个用例的问题是

00:03:39.550 --> 00:03:45.340
通常我部署的微服务

00:03:42.280 --> 00:03:47.950
与整体独立，你只是

00:03:45.340 --> 00:03:50.200
一无所有，但您可能拥有

00:03:47.950 --> 00:03:52.960
您可能决定选择的微服务

00:03:50.200 --> 00:03:56.950
部署其中之一的新版本

00:03:52.960 --> 00:03:59.530
每天为您服务多次

00:03:56.950 --> 00:04:02.440
现在可以看到停机时间的问题

00:03:59.530 --> 00:04:03.850
比较有趣，因为

00:04:02.440 --> 00:04:06.070
如果有停机时间会发生

00:04:03.850 --> 00:04:08.650
服务可能是因为我们正在更新

00:04:06.070 --> 00:04:11.950
这项服务的事是

00:04:08.650 --> 00:04:14.860
一连串的错误，所以有很多

00:04:11.950 --> 00:04:16.359
失败基本上都是可传递的

00:04:14.860 --> 00:04:19.420
服务取决于

00:04:16.359 --> 00:04:23.190
服务也失败了，所以现在为零

00:04:19.420 --> 00:04:25.990
停机部署非常重要

00:04:23.190 --> 00:04:26.710
但是我们需要做的第一件事

00:04:25.990 --> 00:04:29.169
想一想

00:04:26.710 --> 00:04:32.740
它如何实现零停机时间部署

00:04:29.169 --> 00:04:34.810
是因为现在部署有所不同， 

00:04:32.740 --> 00:04:36.550
发布，它们在

00:04:34.810 --> 00:04:38.919
在整体应用中的过去

00:04:36.550 --> 00:04:40.690
通常说我要部署

00:04:38.919 --> 00:04:42.160
基本上意味着采取的申请

00:04:40.690 --> 00:04:44.289
然后将该应用程序放在

00:04:42.160 --> 00:04:48.250
生产，让我们说这是

00:04:44.289 --> 00:04:50.770
平等地说部署或发布，但

00:04:48.250 --> 00:04:53.319
微服务现在已经改变了

00:04:50.770 --> 00:04:56.710
事情是部署服务，这意味着

00:04:53.319 --> 00:04:59.560
放入生产集群

00:04:56.710 --> 00:05:02.830
另一件事是说释放

00:04:59.560 --> 00:05:07.150
服务，这意味着开始发送一些

00:05:02.830 --> 00:05:08.860
该服务的流量，所以这是

00:05:07.150 --> 00:05:10.449
从零开始真的很重要

00:05:08.860 --> 00:05:12.910
微型停机时间部署

00:05:10.449 --> 00:05:15.490
服务斑马有几种

00:05:12.910 --> 00:05:17.410
我将要解释的技术

00:05:15.490 --> 00:05:20.460
常见的，我们还将看到

00:05:17.410 --> 00:05:22.750
有点演示，所以你可以得到一年

00:05:20.460 --> 00:05:26.319
现在这是蓝绿色的部署

00:05:22.750 --> 00:05:29.580
也许你们大多数人都知道蓝色是什么

00:05:26.319 --> 00:05:32.770
提醒您绿色部署

00:05:29.580 --> 00:05:35.320
挖掘我们拥有的所有流量

00:05:32.770 --> 00:05:37.659
即将走向蓝色和比尤曼

00:05:35.320 --> 00:05:40.180
然后我们有一个构建

00:05:37.659 --> 00:05:42.520
服务的新版本，就像

00:05:40.180 --> 00:05:44.800
投入生产，这意味着

00:05:42.520 --> 00:05:47.199
我要部署到生产中，然后

00:05:44.800 --> 00:05:50.520
释放基本上意味着改变

00:05:47.199 --> 00:05:54.729
从蓝色到绿色的路线

00:05:50.520 --> 00:05:56.710
而且我们不采用蓝色W 

00:05:54.729 --> 00:05:57.969
仍然在那里，原因是

00:05:56.710 --> 00:06:00.190
仍然存在是因为当你在

00:05:57.969 --> 00:06:01.990
做这个改变，你可以开始

00:06:00.190 --> 00:06:04.199
监视此服务也许您正在

00:06:01.990 --> 00:06:06.880
使用诺言，然后您只需检查

00:06:04.199 --> 00:06:09.610
原语，如果一切顺利

00:06:06.880 --> 00:06:11.889
预计，那么您离开这条路线，但是

00:06:09.610 --> 00:06:16.840
如果有错误，您可以真正地

00:06:11.889 --> 00:06:19.659
快速从绿色变为蓝色，然后

00:06:16.840 --> 00:06:22.479
那是一种方式，但是它有一个

00:06:19.659 --> 00:06:24.550
最大的问题是所有

00:06:22.479 --> 00:06:26.770
如果您的客户受到影响， 

00:06:24.550 --> 00:06:28.930
失败，所以如果您正在创建一个新

00:06:26.770 --> 00:06:31.330
您部署它的服务版本

00:06:28.930 --> 00:06:34.000
你释放它，然后哦，还有

00:06:31.330 --> 00:06:37.150
一个非常大的错误，那么所有的客户

00:06:34.000 --> 00:06:40.210
将开始为任何得到此错误

00:06:37.150 --> 00:06:42.669
原因是

00:06:40.210 --> 00:06:45.220
金丝雀释放可能你们大多数人

00:06:42.669 --> 00:06:48.699
已经知道不能释放哪个

00:06:45.220 --> 00:06:50.889
基本上来自煤矿

00:06:48.699 --> 00:06:52.720
对，我是说过去

00:06:50.889 --> 00:06:54.400
煤矿有一些位置

00:06:52.720 --> 00:06:56.229
气体，无法检测

00:06:54.400 --> 00:06:59.500
这个位置气体基本上是什么

00:06:56.229 --> 00:07:02.400
矿工们只是在抓鸟

00:06:59.500 --> 00:07:05.080
和鸟一起进入矿井

00:07:02.400 --> 00:07:05.560
对人类有益，但对人类不利

00:07:05.080 --> 00:07:10.000
那些鸟儿

00:07:05.560 --> 00:07:15.099
是那只鸟在30秒后死亡

00:07:10.000 --> 00:07:16.539
这些毒气的意思是

00:07:15.099 --> 00:07:18.729
而人类只需要两个

00:07:16.539 --> 00:07:21.789
分钟，这意味着矿工在

00:07:18.729 --> 00:07:23.620
他们让小鸟节食，这意味着

00:07:21.789 --> 00:07:26.349
他们有一分半钟的时间

00:07:23.620 --> 00:07:27.970
刚从采矿出去，这是

00:07:26.349 --> 00:07:30.490
正是我们将要做的

00:07:27.970 --> 00:07:32.259
罐头厂，因为是的，我是说我们

00:07:30.490 --> 00:07:36.490
是软件工程师，但拥有软件

00:07:32.259 --> 00:07:37.690
所以我们有所有的蓝色bjurman 

00:07:36.490 --> 00:07:39.909
没关系，我的意思是我们

00:07:37.690 --> 00:07:42.639
使用旧版本的服务

00:07:39.909 --> 00:07:46.419
所有的交通都经过那里

00:07:42.639 --> 00:07:50.349
有这个黄色的民谣

00:07:46.419 --> 00:07:54.009
新版本，然后我们把这个新

00:07:50.349 --> 00:07:56.020
版本内的旧版本，我们

00:07:54.009 --> 00:07:58.180
开始站立，例如十

00:07:56.020 --> 00:08:00.130
流量的百分比，以便您发送

00:07:58.180 --> 00:08:01.449
如果一切都占流量的百分之十

00:08:00.130 --> 00:08:04.150
按预期工作

00:08:01.449 --> 00:08:07.360
我们可以增加，否则我们就可以

00:08:04.150 --> 00:08:08.949
删除此新版本，以便您

00:08:07.360 --> 00:08:11.740
如果有效的话，百分之十

00:08:08.949 --> 00:08:15.219
百分之二十五百分之七十五

00:08:11.740 --> 00:08:16.840
 ％，最后是100％ 

00:08:15.219 --> 00:08:19.210
这样我们不会影响所有的

00:08:16.840 --> 00:08:23.710
用户，但只占一小部分

00:08:19.210 --> 00:08:26.349
用户再次有另一个大

00:08:23.710 --> 00:08:29.169
问题是，如果你没有很多

00:08:26.349 --> 00:08:31.000
每秒的用户数

00:08:29.169 --> 00:08:35.050
但是如果您是Facebook会发生什么

00:08:31.000 --> 00:08:36.969
百分之十的用户确实很大

00:08:35.050 --> 00:08:40.950
您影响的用户数量

00:08:36.969 --> 00:08:43.779
有可能的问题

00:08:40.950 --> 00:08:46.180
所以基本上Google和Facebook都有

00:08:43.779 --> 00:08:48.130
开始做一种技术

00:08:46.180 --> 00:08:50.860
这是一把雨伞，叫做

00:08:48.130 --> 00:08:53.209
午餐基本上是深色午餐

00:08:50.860 --> 00:08:55.910
一套技术

00:08:53.209 --> 00:08:57.709
在没有最终用户的情况下生产

00:08:55.910 --> 00:09:02.059
看到你正在使用自己的

00:08:57.709 --> 00:09:09.740
交通测试您的工厂版本和

00:09:02.059 --> 00:09:11.569
通常有几种技术

00:09:09.740 --> 00:09:12.529
例如Facebook使用的一件事是

00:09:11.569 --> 00:09:15.379
叫做弧

00:09:12.529 --> 00:09:18.470
罐头厂是类似的东西

00:09:15.379 --> 00:09:20.240
像康纳·爱丽丝（Connor Alice）一样， 

00:09:18.470 --> 00:09:22.970
使用他们的流量百分比

00:09:20.240 --> 00:09:26.920
例如使用IP范围

00:09:22.970 --> 00:09:30.529
是Facebook的员工

00:09:26.920 --> 00:09:32.779
从一定范围访问Facebook 

00:09:30.529 --> 00:09:35.119
 IP基本上是Facebook办事处，所以

00:09:32.779 --> 00:09:36.439
那么你可以得到这个IPS并说好

00:09:35.119 --> 00:09:38.509
我知道这是Facebook用户

00:09:36.439 --> 00:09:40.249
是Facebook的员工，所以我

00:09:38.509 --> 00:09:42.920
要将流量发送到新

00:09:40.249 --> 00:09:45.439
这样的Facebook版本

00:09:42.920 --> 00:09:48.110
在我之前要测试发生了什么

00:09:45.439 --> 00:09:51.860
向所有用户发布此新版本

00:09:48.110 --> 00:09:53.110
这叫做他们的狗窝

00:09:51.860 --> 00:09:55.459
 [音乐] 

00:09:53.110 --> 00:09:57.860
我使用的一种技术，因为

00:09:55.459 --> 00:09:59.509
镜像流量真的很容易

00:09:57.860 --> 00:10:03.920
镜像流量就像

00:09:59.509 --> 00:10:07.790
我只有两个版本

00:10:03.920 --> 00:10:10.519
部署了旧的和新的

00:10:07.790 --> 00:10:13.670
我只是发送一个请求，然后这个

00:10:10.519 --> 00:10:16.069
请求被发送到两个服务

00:10:13.670 --> 00:10:19.399
蓝色和绿色，但请注意这里

00:10:16.069 --> 00:10:22.040
蓝色有一个双箭头

00:10:19.399 --> 00:10:24.850
同时绿色是唯一的

00:10:22.040 --> 00:10:29.740
箭头的原因是，真的

00:10:24.850 --> 00:10:33.709
从用户的角度来看很重要

00:10:29.740 --> 00:10:36.649
是旧的，因此用户会收到

00:10:33.709 --> 00:10:40.299
旧的回应新的回应

00:10:36.649 --> 00:10:42.619
它只是一劳永逸

00:10:40.299 --> 00:10:44.869
请求它发送一个请求，如果他们

00:10:42.619 --> 00:10:48.350
不在乎回应和这个

00:10:44.869 --> 00:10:50.689
是一个非常有趣的技术

00:10:48.350 --> 00:10:53.749
因为它可以让你开始

00:10:50.689 --> 00:10:55.639
监控我们认为的新服务

00:10:53.749 --> 00:10:59.269
您知道检查这些错误或

00:10:55.639 --> 00:11:03.470
而不改变它的表现

00:10:59.269 --> 00:11:05.820
您的新用户如何看待您

00:11:03.470 --> 00:11:07.890
更新了一些东西

00:11:05.820 --> 00:11:11.430
这似乎真的很复杂

00:11:07.890 --> 00:11:13.110
可以，但是如果您只是在使用古巴地区

00:11:11.430 --> 00:11:17.330
这就是因素平台

00:11:13.110 --> 00:11:19.790
微服务，那是真的

00:11:17.330 --> 00:11:21.660
基本上很容易，因为

00:11:19.790 --> 00:11:23.790
我们需要实现所有微服务

00:11:21.660 --> 00:11:25.830
这些跨领域的关注是

00:11:23.790 --> 00:11:27.840
就像您需要一个API一样

00:11:25.830 --> 00:11:29.970
找到一种发现服务的方式

00:11:27.840 --> 00:11:31.320
最后一个CT调用添加服务

00:11:29.970 --> 00:11:32.820
储存指示管道

00:11:31.320 --> 00:11:34.980
登录监视和跟踪所有这些

00:11:32.820 --> 00:11:37.320
横切关注点本质上是

00:11:34.980 --> 00:11:40.290
在微服务架构中

00:11:37.320 --> 00:11:43.410
这意味着我基本上可以使用所有

00:11:40.290 --> 00:11:45.870
这个发现是一个调用的东西

00:11:43.410 --> 00:11:48.900
定义我要发送流量的位置

00:11:45.870 --> 00:11:53.760
因此使用微服务真的很容易

00:11:48.900 --> 00:11:57.000
去做真正发生的事情，但是

00:11:53.760 --> 00:11:59.880
像这样的东西，你开始

00:11:57.000 --> 00:12:02.490
微服务，你说好，我需要

00:11:59.880 --> 00:12:04.200
做一些我需要做的发现

00:12:02.490 --> 00:12:05.250
我需要某种追踪

00:12:04.200 --> 00:12:07.410
断路器，因为有网络

00:12:05.250 --> 00:12:09.750
也许你们所有人都在微

00:12:07.410 --> 00:12:11.610
服务已经面临这个问题，并且

00:12:09.750 --> 00:12:13.050
你被某件事所结束

00:12:11.610 --> 00:12:14.730
这样的事情你有一个

00:12:13.050 --> 00:12:16.350
容器JVM，然后您有一个

00:12:14.730 --> 00:12:18.990
服务，然后您就会发现

00:12:16.350 --> 00:12:21.420
令人恐惧的部分是发送到哪里

00:12:18.990 --> 00:12:23.820
流量，然后是负载均衡器

00:12:21.420 --> 00:12:26.760
弹性矩阵和跟踪以及所有

00:12:23.820 --> 00:12:29.580
这个逻辑在您的服务内部

00:12:26.760 --> 00:12:32.310
如果您喜欢的话，很酷的示例类型是hystrix 

00:12:29.580 --> 00:12:35.780
有地区，您只需服务

00:12:32.310 --> 00:12:38.910
添加一个新的依赖项，您注释您的

00:12:35.780 --> 00:12:41.250
服务，然后你已经

00:12:38.910 --> 00:12:43.650
那里有断路器行为

00:12:41.250 --> 00:12:45.690
注意，您真正在做的是

00:12:43.650 --> 00:12:51.530
只为您全力以赴

00:12:45.690 --> 00:12:53.790
业务逻辑，只是有一些

00:12:51.530 --> 00:12:56.490
来自的期货

00:12:53.790 --> 00:13:00.170
像说做塔玛蒂的基础设施

00:12:56.490 --> 00:13:02.670
重试或发现其他服务

00:13:00.170 --> 00:13:07.170
但是如果我告诉你你会怎样

00:13:02.670 --> 00:13:10.290
可以把所有这些交叉

00:13:07.170 --> 00:13:13.230
发现断路器等问题

00:13:10.290 --> 00:13:16.200
安全所有这些东西，并把它

00:13:13.230 --> 00:13:19.410
在基础架构中，这样您就可以抓住

00:13:16.200 --> 00:13:21.569
从您的服务中出来，您就是

00:13:19.410 --> 00:13:25.290
并在或以后留下深刻的印象，这是

00:13:21.569 --> 00:13:26.910
复活节到底在做什么

00:13:25.290 --> 00:13:29.100
服务匹配，服务匹配是

00:13:26.910 --> 00:13:30.959
专用的基础架构层

00:13:29.100 --> 00:13:34.949
服务到服务的沟通

00:13:30.959 --> 00:13:37.350
安全快速不可靠，所以如果您喜欢

00:13:34.949 --> 00:13:39.060
微服务墙，与您同在

00:13:37.350 --> 00:13:40.860
得到这样的东西，你有一个

00:13:39.060 --> 00:13:42.420
锅，然后在这个锅里，你有一个

00:13:40.860 --> 00:13:44.009
容器和JVM的纯棉外观

00:13:42.420 --> 00:13:46.430
然后你有你的服务，但

00:13:44.009 --> 00:13:52.610
注意，现在没有逻辑

00:13:46.430 --> 00:13:55.620
指与发现无关的发现

00:13:52.610 --> 00:13:57.389
断路器安全无非

00:13:55.620 --> 00:13:59.759
我们有一个杂物箱，这是

00:13:57.389 --> 00:14:02.759
另一个容器，现在我们的锅有

00:13:59.759 --> 00:14:05.399
两个容器，我的服务以及所有这些

00:14:02.759 --> 00:14:07.740
逻辑以及与之相关的所有逻辑

00:14:05.399 --> 00:14:10.439
基础设施就在里面

00:14:07.740 --> 00:14:12.689
容器，这样我就可以在所有

00:14:10.439 --> 00:14:15.959
服务，而不必执行复制粘贴

00:14:12.689 --> 00:14:19.829
我们希望基本上是细节

00:14:15.959 --> 00:14:21.300
如果在此边角内有istria 

00:14:19.829 --> 00:14:23.040
容器中有一个由代理命名的名称

00:14:21.300 --> 00:14:25.470
代理，就像Ingenix或chai 

00:14:23.040 --> 00:14:28.170
基本上接受请求的代理

00:14:25.470 --> 00:14:31.100
然后操纵此请求

00:14:28.170 --> 00:14:35.160
将交通发送到另一个地方或

00:14:31.100 --> 00:14:39.660
执行自动回溯或管理

00:14:35.160 --> 00:14:41.880
证书，以便您可以使用Sto做

00:14:39.660 --> 00:14:44.189
第一件事是你可以做

00:14:41.880 --> 00:14:46.889
您可以开始进行流量管理

00:14:44.189 --> 00:14:49.139
像我想发送所有的东西

00:14:46.889 --> 00:14:51.060
服务v1的流量，然后您就

00:14:49.139 --> 00:14:54.329
执行普通流量，然后执行其他流量

00:14:51.060 --> 00:14:56.910
去服务B-或者我可以说我想要

00:14:54.329 --> 00:14:59.990
将90％的流量发送到服务v1 

00:14:56.910 --> 00:15:03.600
和90％的服务流量

00:14:59.990 --> 00:15:06.300
版本-使用起来真的很容易

00:15:03.600 --> 00:15:08.160
这-它也可以让你做

00:15:06.300 --> 00:15:10.050
反映流量，这就是我们所要做的

00:15:08.160 --> 00:15:14.370
可以看到您可以发送的深色午餐

00:15:10.050 --> 00:15:16.699
请求-服务是我的意思是

00:15:14.370 --> 00:15:19.589
这是一项服务，但版本不同

00:15:16.699 --> 00:15:22.500
你也可以做深色罐头厂

00:15:19.589 --> 00:15:24.779
这样你就可以开始做像我这样的事情

00:15:22.500 --> 00:15:26.910
想要发送来自

00:15:24.779 --> 00:15:28.949
铬这项服务，如果它来了

00:15:26.910 --> 00:15:31.980
从手机到其他服务，以及

00:15:28.949 --> 00:15:33.000
如果它来自此用户

00:15:31.980 --> 00:15:37.370
服务如此

00:15:33.000 --> 00:15:40.410
易于实现某种逻辑

00:15:37.370 --> 00:15:44.670
取决于谁连接到您

00:15:40.410 --> 00:15:46.680
应用程序，使其实现秘密

00:15:44.670 --> 00:15:49.410
断路器，我的意思是这不适合我

00:15:46.680 --> 00:15:51.810
这意味着在长时间的情况下有帮助

00:15:49.410 --> 00:15:54.030
并非真的

00:15:51.810 --> 00:15:56.970
子长时间部署，因为它

00:15:54.030 --> 00:16:00.060
允许您实施某种

00:15:56.970 --> 00:16:02.670
自动重试和池弹出

00:16:00.060 --> 00:16:04.470
表示如果我要部署新的

00:16:02.670 --> 00:16:07.170
服务，然后我开始发布

00:16:04.470 --> 00:16:09.590
有一段时间秒

00:16:07.170 --> 00:16:12.420
该新服务不可用

00:16:09.590 --> 00:16:16.470
你可以做某种回溯

00:16:12.420 --> 00:16:20.040
让东您重试任何失败

00:16:16.470 --> 00:16:21.960
当它启动并运行时

00:16:20.040 --> 00:16:24.420
行为正确，所以这意味着

00:16:21.960 --> 00:16:27.570
你在中间有一些停机时间

00:16:24.420 --> 00:16:30.480
一两三秒，你会得到东

00:16:27.570 --> 00:16:34.620
服务失败的响应和

00:16:30.480 --> 00:16:38.010
重新路由到新服务也

00:16:34.620 --> 00:16:40.830
帮助您继续努力

00:16:38.010 --> 00:16:42.780
测试，所以如果你想做某种

00:16:40.830 --> 00:16:44.850
母牛正在发生的事情的测试

00:16:42.780 --> 00:16:46.410
在我的服务中，当有一些

00:16:44.850 --> 00:16:50.640
延迟或您超时

00:16:46.410 --> 00:16:54.839
可以使用问题来模拟这一点

00:16:50.640 --> 00:16:56.250
关于我谈论过的奶牛工程的说明

00:16:54.839 --> 00:17:01.200
与几家公司一起

00:16:56.250 --> 00:17:03.960
告诉我，是的，我们正在使用堂兄珍妮

00:17:01.200 --> 00:17:06.540
母牛测试，然后我问和

00:17:03.960 --> 00:17:11.339
情况如何，现在大多数人都告诉

00:17:06.540 --> 00:17:13.439
我哇这是一场灾难吧，我说

00:17:11.339 --> 00:17:15.480
而当你在使用时

00:17:13.439 --> 00:17:19.829
学习做奶牛工程和

00:17:15.480 --> 00:17:21.630
答案是因为Netflix做到了

00:17:19.829 --> 00:17:23.430
真的很有趣，因为您可能

00:17:21.630 --> 00:17:24.839
问题与Netflix和

00:17:23.430 --> 00:17:27.089
可能您没有

00:17:24.839 --> 00:17:29.490
 Netflix拥有的基础设施

00:17:27.089 --> 00:17:31.470
任何情况下最常见的问题之一

00:17:29.490 --> 00:17:34.350
他们告诉我他们有

00:17:31.470 --> 00:17:37.110
有一些紧急情况

00:17:34.350 --> 00:17:41.460
一些开发人员决定的感觉

00:17:37.110 --> 00:17:42.900
现在是下午1:00做某事的好时机

00:17:41.460 --> 00:17:45.960
牛工程，他们开始做

00:17:42.900 --> 00:17:46.890
他们自己的奶牛测试和

00:17:45.960 --> 00:17:50.160
监察组

00:17:46.890 --> 00:17:52.290
我开始看到某种随机的

00:17:50.160 --> 00:17:55.380
服务上的错误，他们说得很好

00:17:52.290 --> 00:17:57.929
这里发生了什么，就像我们

00:17:55.380 --> 00:17:59.160
正在做一些母牛测试的事情是

00:17:57.929 --> 00:18:01.380
没有人通知

00:17:59.160 --> 00:18:03.120
监控团队，这些测试是

00:18:01.380 --> 00:18:05.100
将会发生，所以当你

00:18:03.120 --> 00:18:05.460
首先要做牛工程

00:18:05.100 --> 00:18:08.309
所有

00:18:05.460 --> 00:18:10.559
很好地教自己第二个

00:18:08.309 --> 00:18:13.320
与每个人交流你

00:18:10.559 --> 00:18:17.070
去做，因为如果没有的话，你不会

00:18:13.320 --> 00:18:20.910
在

00:18:17.070 --> 00:18:24.150
还测试工具的安全性和

00:18:20.910 --> 00:18:27.750
这是为什么大多数

00:18:24.150 --> 00:18:29.460
红帽用户或客户是

00:18:27.750 --> 00:18:35.900
对Istria感兴趣，这是因为

00:18:29.460 --> 00:18:38.820
 sto允许您使用MPLS进行通信

00:18:35.900 --> 00:18:41.520
但是作为开发人员的你

00:18:38.820 --> 00:18:44.160
只是用HTTP写东西， 

00:18:41.520 --> 00:18:46.320
然后，因为您拥有此网站容器

00:18:44.160 --> 00:18:49.230
接收所有流量，然后您

00:18:46.320 --> 00:18:52.440
向此小车容器发送请求

00:18:49.230 --> 00:18:55.860
二次侧汽车集装箱改造

00:18:52.440 --> 00:18:57.570
您的HTTP请求到HTTP请求

00:18:55.860 --> 00:18:59.790
与对方沟通

00:18:57.570 --> 00:19:02.429
与HTTP服务到其他我的

00:18:59.790 --> 00:19:04.350
代理这我的代理只是转换

00:19:02.429 --> 00:19:07.410
 HTTP到HTTPS 

00:19:04.350 --> 00:19:08.880
到达服务，所以如果您看到

00:19:07.410 --> 00:19:10.740
从开发者的角度来看

00:19:08.880 --> 00:19:13.590
不需要照顾

00:19:10.740 --> 00:19:14.910
证书CAS吊销证书

00:19:13.590 --> 00:19:17.630
等等，因为从角度来看

00:19:14.910 --> 00:19:20.250
开发人员的一切都是HTTP和

00:19:17.630 --> 00:19:22.410
实现吸收性，这意味着

00:19:20.250 --> 00:19:24.450
 Prometheus默认具有的

00:19:22.410 --> 00:19:28.590
和跳汰机检查正在发生的事情

00:19:24.450 --> 00:19:32.370
在网格内部，现在让我们来看所有

00:19:28.590 --> 00:19:35.820
演示，如果您走了或者您已经看过

00:19:32.370 --> 00:19:37.500
关于零的其他想法不

00:19:35.820 --> 00:19:39.650
部署，所有人都可以做到

00:19:37.500 --> 00:19:42.030
一样的东西，大家好

00:19:39.650 --> 00:19:43.650
服务是无状态的服务

00:19:42.030 --> 00:19:45.150
您知道自己有一项服务，并且

00:19:43.650 --> 00:19:48.600
然后您将所有流量发送给服务

00:19:45.150 --> 00:19:50.220
 b1然后他们向您显示您

00:19:48.600 --> 00:19:52.590
可以做一个金丝雀将流量发送到

00:19:50.220 --> 00:19:55.290
服务b2，当然可以

00:19:52.590 --> 00:19:57.870
它之所以有效是因为它不锈但是

00:19:55.290 --> 00:20:00.500
我想告诉你这是什么

00:19:57.870 --> 00:20:02.000
有状态的时候发生

00:20:00.500 --> 00:20:03.950
服务，那就更多了

00:20:02.000 --> 00:20:05.930
一个有趣的早晨

00:20:03.950 --> 00:20:10.310
更有趣的是，当您开始

00:20:05.930 --> 00:20:12.230
更改数据库的架构，以便

00:20:10.310 --> 00:20:14.870
我首先要开始

00:20:12.230 --> 00:20:18.050
短暂的状态和一个女性

00:20:14.870 --> 00:20:20.390
房地产我们的坚持是

00:20:18.050 --> 00:20:22.310
基本上不是股骨，例子是

00:20:20.390 --> 00:20:25.160
正确的购物车是

00:20:22.310 --> 00:20:28.280
它以某种方式持续存在的东西

00:20:25.160 --> 00:20:34.100
但是如果会议进行得很短暂

00:20:28.280 --> 00:20:36.770
降低您的损失，所以在

00:20:34.100 --> 00:20:39.770
过去基本上我做了类似的事情

00:20:36.770 --> 00:20:42.680
我有我的路透社，然后我有我的

00:20:39.770 --> 00:20:45.890
人之一的服务，我用

00:20:42.680 --> 00:20:49.990
粘性会议，我不知道你是否

00:20:45.890 --> 00:20:53.090
仍在使用状态粘性会话

00:20:49.990 --> 00:20:54.860
立即这是一个很大的问题

00:20:53.090 --> 00:20:56.810
基本上发生了什么

00:20:54.860 --> 00:21:00.500
粘性会话只是记录

00:20:56.810 --> 00:21:03.020
请求和服务器的IP 

00:21:00.500 --> 00:21:05.030
正确处理此请求的服务器

00:21:03.020 --> 00:21:07.640
那如果你有购物车

00:21:05.030 --> 00:21:09.110
你正在做的是，好黏

00:21:07.640 --> 00:21:11.060
会议上，我有购物车

00:21:09.110 --> 00:21:13.430
我有一个版本，所以所有

00:21:11.060 --> 00:21:17.300
该用户的请求始终会到达

00:21:13.430 --> 00:21:19.370
此版本提供一项服务，但现在是什么

00:21:17.300 --> 00:21:21.200
例如，如果我想做一个

00:21:19.370 --> 00:21:22.700
蓝绿色部署，因此您已经

00:21:21.200 --> 00:21:27.800
我要更改为版本1 

00:21:22.700 --> 00:21:30.470
两个好，现在所有重新路由更改都

00:21:27.800 --> 00:21:33.230
版本2和拥有他们的用户

00:21:30.470 --> 00:21:35.540
您自己看到的自己的购物车

00:21:33.230 --> 00:21:39.620
没有购物车，因为

00:21:35.540 --> 00:21:42.140
服务器没有达到任何流量

00:21:39.620 --> 00:21:45.020
解决这个问题基本上是使用

00:21:42.140 --> 00:21:47.060
任何内存数据网格和内存数据

00:21:45.020 --> 00:21:49.220
网格是驻留在其中的数据结构

00:21:47.060 --> 00:21:51.440
 Turrell在RAM中并且是分布式的

00:21:49.220 --> 00:21:54.200
在多种服务中，例如

00:21:51.440 --> 00:21:55.970
鳍跨Reddy的危险等级

00:21:54.200 --> 00:21:59.300
技术在内存数据网格中

00:21:55.970 --> 00:22:03.830
有根据是，对于任何

00:21:59.300 --> 00:22:05.450
请求他们存储的任何版本

00:22:03.830 --> 00:22:08.000
购物车如此短暂

00:22:05.450 --> 00:22:09.650
此内存数据网格内的实体

00:22:08.000 --> 00:22:12.250
所以当你做例如

00:22:09.650 --> 00:22:14.350
蓝色，您切换为绿色

00:22:12.250 --> 00:22:17.650
你得到这样的东西

00:22:14.350 --> 00:22:19.570
你有蓝色只是消失了，但是

00:22:17.650 --> 00:22:22.030
因为绿色正在访问

00:22:19.570 --> 00:22:23.830
内存数据网格和内存数据

00:22:22.030 --> 00:22:25.870
网格在所有

00:22:23.830 --> 00:22:28.510
集群你仍然得到所有

00:22:25.870 --> 00:22:31.600
购物车，我将向您展示

00:22:28.510 --> 00:22:35.070
演示是否可行，因为我注意到了

00:22:31.600 --> 00:22:42.990
有一些问题

00:22:35.070 --> 00:22:42.990
网络是的，现在是

00:22:54.380 --> 00:23:02.000
好吧，现在我正在开始

00:23:00.500 --> 00:23:05.419
集群，因为我有一些问题

00:23:02.000 --> 00:23:13.360
同时网络有任何问题

00:23:05.419 --> 00:23:13.360
开始没有

00:23:30.059 --> 00:23:37.109
你好啊，完美的权利，所以我的问题是

00:23:32.999 --> 00:23:40.859
您将如何处理

00:23:37.109 --> 00:23:43.320
数据，例如内存中的数据网格

00:23:40.859 --> 00:23:46.200
或者即使您正在连接

00:23:43.320 --> 00:23:47.729
绿色和蓝色部署，如果您

00:23:46.200 --> 00:23:49.919
有一个数据库，该如何

00:23:47.729 --> 00:23:52.190
您升级数据模型，这是

00:23:49.919 --> 00:23:54.659
另一个例子，我将解释所有

00:23:52.190 --> 00:23:56.399
您需要遵循的步骤

00:23:54.659 --> 00:23:58.169
看到有三个步骤

00:23:56.399 --> 00:24:01.889
你需要我的意思是你创造了三个

00:23:58.169 --> 00:24:05.539
新的中间版本

00:24:01.889 --> 00:24:08.299
然后您将通过演示看到版本

00:24:05.539 --> 00:24:11.969
解释，但基本上是遵循

00:24:08.299 --> 00:24:15.029
意大利面法，您需要

00:24:11.969 --> 00:24:17.789
接受一切并发送什么

00:24:15.029 --> 00:24:20.309
他们要求你基本上你看到了

00:24:17.789 --> 00:24:24.259
现在，现在看起来不难

00:24:20.309 --> 00:24:24.259
这正在工作

00:24:45.040 --> 00:24:50.070
我认为这个这一希望如此

00:25:00.320 --> 00:25:05.380
好吧，所以我开始错了

00:25:20.030 --> 00:25:33.580
我要更改显示，但是

00:25:30.740 --> 00:25:33.580
这不重要

00:25:47.080 --> 00:25:51.919
现在我有这个应用程序

00:25:49.549 --> 00:25:54.169
应用程序是存储的电影，因此

00:25:51.919 --> 00:25:58.760
你有我有一些电影，我

00:25:54.169 --> 00:26:01.159
有两个版本的同一个购物

00:25:58.760 --> 00:26:04.940
购物车是那个服务谁

00:26:01.159 --> 00:26:07.280
提供所有的电影，所以

00:26:04.940 --> 00:26:10.159
我要做的就是添加一些

00:26:07.280 --> 00:26:12.289
电影到一个版本，然后我要去

00:26:10.159 --> 00:26:14.539
对另一个进行蓝绿色部署

00:26:12.289 --> 00:26:16.850
版本，您会看到购物

00:26:14.539 --> 00:26:19.130
购物车永远不会丢失，我可以走了

00:26:16.850 --> 00:26:21.409
从第一版到第二版，然后

00:26:19.130 --> 00:26:26.150
再次版本一，用户将

00:26:21.409 --> 00:26:31.539
总是准备好购物车，所以

00:26:26.150 --> 00:26:31.539
现在它正在工作，他们可以

00:26:40.330 --> 00:26:43.379
这东西

00:27:01.770 --> 00:27:11.880
好吧，现在只是在说好

00:27:14.210 --> 00:27:22.309
那我要做的就是

00:27:19.289 --> 00:27:24.179
这是我需要知道的工作

00:27:22.309 --> 00:27:37.200
那是第一件事

00:27:24.179 --> 00:27:41.210
什么是行不通的，因为reddy是

00:27:37.200 --> 00:27:41.210
还没有

00:27:42.890 --> 00:27:55.020
是的，它在哪里很好，让我们现在看看

00:27:51.680 --> 00:27:57.090
恩，我希望现在，如果不是他们

00:27:55.020 --> 00:27:59.730
记录好了第一件事

00:27:57.090 --> 00:28:06.870
他们需要做的就是这就是你

00:27:59.730 --> 00:28:08.490
可以看到我有电影b1 

00:28:06.870 --> 00:28:10.980
具有两个电影网关的电影和

00:28:08.490 --> 00:28:13.470
准备好了，请注意我喜欢-哦

00:28:10.980 --> 00:28:17.150
 -这是因为我有一个锅

00:28:13.470 --> 00:28:20.610
两个容器的服务和存储

00:28:17.150 --> 00:28:26.310
容器，所以我需要的第一件事

00:28:20.610 --> 00:28:29.550
要做的就是发送，我的意思是指示

00:28:26.310 --> 00:28:46.310
所有这些服务更容易

00:28:29.550 --> 00:28:48.930
他们正在运行目标规则

00:28:46.310 --> 00:28:51.810
好了，已经有一条区分路线

00:28:48.930 --> 00:28:53.850
所以这是我正在注册，然后

00:28:51.810 --> 00:28:56.160
他们需要做的另一件事是发送

00:28:53.850 --> 00:29:03.930
版本B 1的所有流量

00:28:56.160 --> 00:29:07.710
也许我在那里还可以，所以现在

00:29:03.930 --> 00:29:08.730
所有流量都流向服务1，如果

00:29:07.710 --> 00:29:13.110
这有效

00:29:08.730 --> 00:29:16.049
终于是

00:29:13.110 --> 00:29:18.720
你看这里是电影和一部

00:29:16.049 --> 00:29:21.960
重要的是这是这个

00:29:18.720 --> 00:29:24.660
服务此页面的主持人

00:29:21.960 --> 00:29:31.950
注意这部电影是一部，所以我需要

00:29:24.660 --> 00:29:36.240
买一些电影无限战争如何

00:29:31.950 --> 00:29:38.390
很多副本-我会说-队长

00:29:36.240 --> 00:29:42.270
奇迹哇

00:29:38.390 --> 00:29:47.850
零添加一个项目，好吧，我咬了- 

00:29:42.270 --> 00:29:49.919
无限战争，我拿出了，所以如果我去

00:29:47.850 --> 00:29:53.730
在这里，您看到我已添加的购物车

00:29:49.919 --> 00:29:57.210
到无限战争，主机又是

00:29:53.730 --> 00:30:01.590
电影b1，所以我可以再去两部

00:29:57.210 --> 00:30:03.419
电机，我将重新路由所有

00:30:01.590 --> 00:30:06.530
流量到版本v2唯一

00:30:03.419 --> 00:30:14.220
我需要的是双重替代

00:30:06.530 --> 00:30:15.419
源主要仍然是服务否决权

00:30:14.220 --> 00:30:17.840
所以我只是

00:30:15.419 --> 00:30:29.809
我们将流量从b1路由到b2 

00:30:17.840 --> 00:30:33.780
然后我可以去刷新

00:30:29.809 --> 00:30:36.210
注意这里现在有v2，请不要v1 

00:30:33.780 --> 00:30:38.340
购物车还在

00:30:36.210 --> 00:30:42.570
一个元素是无限的两个

00:30:38.340 --> 00:30:45.150
战争，我可以回到这里，我可以购买

00:30:42.570 --> 00:30:48.570
这是我女儿会的

00:30:45.150 --> 00:30:51.419
真的很高兴，我当然在这里

00:30:48.570 --> 00:30:54.299
两部电影，如果我检测到

00:30:51.419 --> 00:30:57.510
 v2中存在一些错误，我想

00:30:54.299 --> 00:31:02.669
回到一个我只需要走的地方

00:30:57.510 --> 00:31:05.730
在这里应用这个文件，现在当我只是

00:31:02.669 --> 00:31:10.140
刷新，您会再次看到这里是p1 

00:31:05.730 --> 00:31:12.150
和电影，但电影

00:31:10.140 --> 00:31:13.679
这里有链接，您会看到

00:31:12.150 --> 00:31:16.140
有如何训练你的龙

00:31:13.679 --> 00:31:19.410
复仇者联盟，所以我不会失去状态

00:31:16.140 --> 00:31:21.240
而且可以随时切换

00:31:19.410 --> 00:31:23.809
从第一版到第二版，没有

00:31:21.240 --> 00:31:23.809
很大的问题

00:31:24.240 --> 00:31:29.440
那么下一个例子就是你

00:31:27.790 --> 00:31:30.970
提及何时发生的事情

00:31:29.440 --> 00:31:32.350
有持续性发生了什么

00:31:30.970 --> 00:31:33.670
因为现在真的很容易

00:31:32.350 --> 00:31:37.600
有红色就在那里

00:31:33.670 --> 00:31:39.790
发送并查看发生了什么

00:31:37.600 --> 00:31:49.840
首先，我要

00:31:39.790 --> 00:31:51.310
向你解释一件事，所以发生了什么事

00:31:49.840 --> 00:31:55.000
当我们有一个持久的状态时

00:31:51.310 --> 00:31:58.840
基本上我有数据库

00:31:55.000 --> 00:32:00.730
向您解释最复杂的例子

00:31:58.840 --> 00:32:05.230
通过这个例子，那么你可以知道

00:32:00.730 --> 00:32:07.570
接受这个想法并将其应用于任何

00:32:05.230 --> 00:32:09.670
发生在

00:32:07.570 --> 00:32:11.350
在这个数据库下是

00:32:09.670 --> 00:32:14.380
例如更新列名

00:32:11.350 --> 00:32:16.650
你有列名name而你

00:32:14.380 --> 00:32:19.630
想要重命名为全名

00:32:16.650 --> 00:32:21.880
我有版本1的数据方式

00:32:19.630 --> 00:32:24.190
比赛中有一个叫名字的列

00:32:21.880 --> 00:32:27.820
然后我想将此列重命名为

00:32:24.190 --> 00:32:30.180
全名，所以如果我为

00:32:27.820 --> 00:32:33.550
你可以释放它的例子意味着

00:32:30.180 --> 00:32:35.230
如果列名不变则一些

00:32:33.550 --> 00:32:37.900
这不是问题，但如果专栏

00:32:35.230 --> 00:32:40.570
更改名称，然后一些用户可能会发现

00:32:37.900 --> 00:32:42.730
有些问题是因为一列

00:32:40.570 --> 00:32:45.010
之所以称为全名，是因为您重命名

00:32:42.730 --> 00:32:48.160
它列，然后百分之一

00:32:45.010 --> 00:32:51.160
用户会得到正确的

00:32:48.160 --> 00:32:56.860
回应，但99％的使用者会

00:32:51.160 --> 00:32:59.110
收到未找到的列名，那么如何

00:32:56.860 --> 00:33:02.290
要做第一件事

00:32:59.110 --> 00:33:06.250
做就是做你这样的事情

00:33:02.290 --> 00:33:10.210
有版本1需要阅读并

00:33:06.250 --> 00:33:14.290
写姓名和全名，这样你就可以

00:33:10.210 --> 00:33:17.500
复制领域任何红色动力学

00:33:14.290 --> 00:33:23.470
版本1的权利应同时应用于

00:33:17.500 --> 00:33:30.130
这些专栏和版本2只是

00:33:23.470 --> 00:33:33.670
从全名中读取

00:33:30.130 --> 00:33:35.880
注意这种方式，但是你的

00:33:33.670 --> 00:33:38.590
你得到的是，如果有

00:33:35.880 --> 00:33:41.190
版本二行为不正确，您可以

00:33:38.590 --> 00:33:44.560
总是回来而不会丢失任何东西

00:33:41.190 --> 00:33:46.060
当然如果有明亮的

00:33:44.560 --> 00:33:48.880
因为最终用户将阅读

00:33:46.060 --> 00:33:51.730
他们哭了两个全名

00:33:48.880 --> 00:33:55.180
并指出其原因是，如果

00:33:51.730 --> 00:33:58.090
版本2，您需要将其回滚到

00:33:55.180 --> 00:34:02.740
版本p1的所有数据仍然是

00:33:58.090 --> 00:34:07.150
命名，尽管您知道最后一步

00:34:02.740 --> 00:34:10.210
只是全名而已

00:34:07.150 --> 00:34:12.850
第一次，然后记住，我们已经

00:34:10.210 --> 00:34:15.190
版本2有权为其命名

00:34:12.850 --> 00:34:17.830
全名和出生，并准备好

00:34:15.190 --> 00:34:20.889
从名字读，但你想结束

00:34:17.830 --> 00:34:23.620
通过删除名称，第一件事就是

00:34:20.889 --> 00:34:24.700
您需要使用版本3只是

00:34:23.620 --> 00:34:28.149
这样的东西

00:34:24.700 --> 00:34:29.440
我从名称复制所有先前的数据

00:34:28.149 --> 00:34:31.510
全名

00:34:29.440 --> 00:34:32.889
因为请记住您已经添加了

00:34:31.510 --> 00:34:36.159
他在我中间的意思是你

00:34:32.889 --> 00:34:38.169
可能在运行一年后才有效

00:34:36.159 --> 00:34:40.510
此应用程序，因此您需要复制

00:34:38.169 --> 00:34:42.159
从名称到全名的先前数据，以及

00:34:40.510 --> 00:34:44.620
可能会使用类似

00:34:42.159 --> 00:34:47.649
 Spring 批处理所有这一切

00:34:44.620 --> 00:34:51.990
列与列之间的信息使您

00:34:47.649 --> 00:34:55.720
之后不要锁定整个数据库

00:34:51.990 --> 00:34:59.080
您这个版本3将开始阅读

00:34:55.720 --> 00:35:00.610
自全名以来的所有信息

00:34:59.080 --> 00:35:02.050
您已将所有内容从名称复制到

00:35:00.610 --> 00:35:02.590
全名，那么您还没有丢失

00:35:02.050 --> 00:35:06.490
任何东西

00:35:02.590 --> 00:35:08.560
并且写仍然碰巧命名和

00:35:06.490 --> 00:35:11.620
全名，您需要这样做

00:35:08.560 --> 00:35:13.690
同样的原因，如果版本

00:35:11.620 --> 00:35:16.930
 3有任何错误，您需要回退

00:35:13.690 --> 00:35:19.720
您仍然需要能够与

00:35:16.930 --> 00:35:23.800
版本2，如果您看到版本2， 

00:35:19.720 --> 00:35:25.180
速率是从列名发生的，所以

00:35:23.800 --> 00:35:29.260
您仍然需要写列名

00:35:25.180 --> 00:35:31.450
还有你要做的最后一件事

00:35:29.260 --> 00:35:33.130
就像我现在有版本3 

00:35:31.450 --> 00:35:35.890
从全名写入最低费用

00:35:33.130 --> 00:35:40.990
我需要做的只是一个开始

00:35:35.890 --> 00:35:43.660
以全名读取和写入，因此在3之后

00:35:40.990 --> 00:35:47.530
您的申请有我的步骤

00:35:43.660 --> 00:35:50.470
从列名读取到

00:35:47.530 --> 00:35:52.539
阅读和写全名，这样你

00:35:50.470 --> 00:35:54.339
如果您需要阅读这三个步骤

00:35:52.539 --> 00:35:56.950
不要那样做，我知道这是

00:35:54.339 --> 00:35:59.710
有点复杂，但是如果你不这样做

00:35:56.950 --> 00:36:02.440
这样就不可能保证

00:35:59.710 --> 00:36:04.119
向后兼容零区

00:36:02.440 --> 00:36:05.140
当然可以，您可以尝试

00:36:04.119 --> 00:36:07.329
零了很久，看看是什么

00:36:05.140 --> 00:36:09.910
发生并且没有零时间

00:36:07.329 --> 00:36:11.559
只是为了阻止一切星光一切

00:36:09.910 --> 00:36:13.750
看看天堂是什么，但是如果你想

00:36:11.559 --> 00:36:17.440
用您需要吃的实时代码完成

00:36:13.750 --> 00:36:24.359
遵循所有这些步骤，让我们看看

00:36:17.440 --> 00:36:24.359
现在这个例子我在这里

00:36:31.660 --> 00:36:36.520
我就是古巴艺术家

00:36:35.200 --> 00:36:38.650
当它是openshift但最终

00:36:36.520 --> 00:36:41.890
实现它的古巴，那是你看到我

00:36:38.650 --> 00:36:50.740
将一直使用多维数据集城市，并且

00:36:41.890 --> 00:36:56.850
没关系，现在我有下一个井

00:36:50.740 --> 00:36:56.850
可以等我打开，这很容易

00:37:01.950 --> 00:37:09.730
如果您再次看到这个k9，我有一个

00:37:07.570 --> 00:37:11.650
我最喜欢的客户是我

00:37:09.730 --> 00:37:14.980
在我的意思之前有建议

00:37:11.650 --> 00:37:16.930
因为b1 b2我是三个

00:37:14.980 --> 00:37:20.380
事情，现在才像

00:37:16.930 --> 00:37:22.810
像这样的标准标准版本

00:37:20.380 --> 00:37:25.780
从正常的方式大，我在这里

00:37:22.810 --> 00:37:28.690
 Postgres，如果您检查这是什么

00:37:25.780 --> 00:37:31.170
 Postgres的原因包含我可以执行P 

00:37:28.690 --> 00:37:31.170
广场

00:37:42.180 --> 00:37:51.640
您会看到他们有一个ID和一个

00:37:50.140 --> 00:37:54.790
名字叫星球大战一个新希望

00:37:51.640 --> 00:37:56.620
和星际迷航v联络这只是

00:37:54.790 --> 00:37:59.920
这个名字，我想重命名这个名字

00:37:56.620 --> 00:38:06.340
他们当然会做另一件事

00:37:59.920 --> 00:38:09.310
在这里打个电话，你看到他们越来越我

00:38:06.340 --> 00:38:11.410
获得客户的偏爱

00:38:09.310 --> 00:38:15.430
星球大战之前的推荐新

00:38:11.410 --> 00:38:17.590
星际迷航》这本合同现在是什么

00:38:15.430 --> 00:38:21.220
如果我想添加一个例子

00:38:17.590 --> 00:38:37.500
新电影，我只需要打电话即可

00:38:21.220 --> 00:38:37.500
 H我要添加例如复仇者

00:38:40.920 --> 00:38:47.200
现在我们在旧电影中添加了新电影

00:38:44.620 --> 00:38:48.790
版本，所以他们当然会选择

00:38:47.200 --> 00:38:52.870
您会看到也有这部电影

00:38:48.790 --> 00:38:56.670
而且必须听到电话，然后我得到了

00:38:52.870 --> 00:38:59.890
 《星际迷航》《星际大战》和《复仇者联盟》现在我

00:38:56.670 --> 00:39:02.740
想要部署b5版本

00:38:59.890 --> 00:39:04.870
知道重命名的开始唯一

00:39:02.740 --> 00:39:13.690
我需要做的事情

00:39:04.870 --> 00:39:18.510
从这里请原谅它大声申请， 

00:39:13.690 --> 00:39:18.510
我要使用的部署是

00:39:19.290 --> 00:39:23.520
 55 

00:39:21.210 --> 00:39:28.069
注意，我在这里所做的只是

00:39:23.520 --> 00:39:30.180
进行b5部署，这是我的常规

00:39:28.069 --> 00:39:32.760
部署，我正在经历

00:39:30.180 --> 00:39:36.710
修改杰米的杰克

00:39:32.760 --> 00:39:47.510
文件来添加所有这些复活节魔术和

00:39:36.710 --> 00:39:56.099
不，因为好吧，好吧，我只是

00:39:47.510 --> 00:39:58.799
部署下一个版本

00:39:56.099 --> 00:40:01.279
快要跑了，记得这个新

00:39:58.799 --> 00:40:03.690
版本只是在创建

00:40:01.279 --> 00:40:05.700
列名称，此新版本是

00:40:03.690 --> 00:40:10.740
读旧书

00:40:05.700 --> 00:40:14.400
但是现在写到两者都在运行

00:40:10.740 --> 00:40:16.680
任何人在这里选择这个看到

00:40:14.400 --> 00:40:20.039
有一部名为失败的电影，有一部

00:40:16.680 --> 00:40:23.240
新字段的权利以及我想要的所有字段

00:40:20.039 --> 00:40:26.579
然后从名称重命名为电影名称

00:40:23.240 --> 00:40:28.829
再次，我需要做的是重新路由

00:40:26.579 --> 00:40:31.289
流量到此b5以重新路由

00:40:28.829 --> 00:40:44.160
只需要做的流量就是

00:40:31.289 --> 00:40:46.349
我现在要更换新的自助服务b5 

00:40:44.160 --> 00:40:50.069
只是将所有流量发送到p5 

00:40:46.349 --> 00:40:52.079
版本，如果不是，则为

00:40:50.069 --> 00:40:54.329
我得到的建议b5与

00:40:52.079 --> 00:40:57.180
三部电影，如果我现在去做什么

00:40:54.329 --> 00:41:00.359
一个电话，例如我又一个

00:40:57.180 --> 00:41:03.809
例如电影冻结将是一个很好的

00:41:00.359 --> 00:41:07.589
电影，他们将要发行

00:41:03.809 --> 00:41:09.020
冻结那些将要冻结的

00:41:07.589 --> 00:41:11.040
一

00:41:09.020 --> 00:41:13.350
现在让任何人在这里工作

00:41:11.040 --> 00:41:17.220
选择您正在看到冻结的

00:41:13.350 --> 00:41:24.570
添加到两列，当然我

00:41:17.220 --> 00:41:27.200
可以在这里做是星际迷航的曲线

00:41:24.570 --> 00:41:30.210
如果我注意到那无限和冻结哦

00:41:27.200 --> 00:41:33.870
现在此版本b5中存在错误

00:41:30.210 --> 00:41:36.810
我需要先切换回

00:41:33.870 --> 00:41:38.510
只是要做的就是坐，取代我的新

00:41:36.810 --> 00:41:46.500
自我是两个文件

00:41:38.510 --> 00:41:50.070
我之前看到的Piero的服务b5 

00:41:46.500 --> 00:41:53.460
卷发，当然现在是

00:41:50.070 --> 00:41:55.380
冰冻的电影，它仍然在那里

00:41:53.460 --> 00:41:57.830
注意之前的版本没有

00:41:55.380 --> 00:42:01.110
对电影名称字段一无所知

00:41:57.830 --> 00:42:03.270
因为还没有创建，但是

00:42:01.110 --> 00:42:04.260
因为我在两个地方都读过

00:42:03.270 --> 00:42:07.230
然后我明白了

00:42:04.260 --> 00:42:10.440
然后假设两者中的数据

00:42:07.230 --> 00:42:13.110
一切正常，b5 

00:42:10.440 --> 00:42:17.160
是正确的，所以我可以跳回到

00:42:13.110 --> 00:42:20.610
 b5和我将下一步部署到此

00:42:17.160 --> 00:42:24.020
正在部署b6的移民

00:42:20.610 --> 00:42:28.710
我只需要继续应用CTL 

00:42:24.020 --> 00:42:41.760
部署b6首先要做好

00:42:28.710 --> 00:42:48.090
疯了，我要去做一个版本

00:42:41.760 --> 00:42:51.270
以前是现在，因为b5很好，然后我

00:42:48.090 --> 00:42:59.340
可以在之前部署，而我要去

00:42:51.270 --> 00:43:05.000
重新部署b6，所以现在我有了b5， 

00:42:59.340 --> 00:43:08.070
那么你有b6，当我有

00:43:05.000 --> 00:43:08.070
 [音乐] 

00:43:08.570 --> 00:43:13.770
现在基本上从b6开始

00:43:11.910 --> 00:43:16.260
我正在做的是从旧数据复制

00:43:13.770 --> 00:43:19.320
到新的意思是从旧列到

00:43:16.260 --> 00:43:21.880
新列，现在是regionright 

00:43:19.320 --> 00:43:25.010
发生在新的

00:43:21.880 --> 00:43:26.450
专栏让我们看看现在好了

00:43:25.010 --> 00:43:29.270
一切都在运行，我已经做了一个选择

00:43:26.450 --> 00:43:30.800
在这里您会看到，但现在是《星球大战》或

00:43:29.270 --> 00:43:33.080
开始潜入来自的复仇者联盟

00:43:30.800 --> 00:43:35.030
之前复制到电影名称的通知

00:43:33.080 --> 00:43:36.980
在前面选择这些

00:43:35.030 --> 00:43:41.270
元素不在那里，但现在它们在

00:43:36.980 --> 00:43:45.320
在那里，我可以再做一个谜

00:43:41.270 --> 00:43:50.660
城市，我将只替换您的文件

00:43:45.320 --> 00:43:53.330
提款服务v6，我可以

00:43:50.660 --> 00:43:56.480
打电话给我看所有电影

00:43:53.330 --> 00:43:58.040
 b6如果我可以切换回我的话

00:43:56.480 --> 00:44:00.440
我的意思是，如果您想做一个

00:43:58.040 --> 00:44:11.770
例如现在抓取添加一些数据

00:44:00.440 --> 00:44:15.320
让我们为它添加任何电影“玩具总动员” 

00:44:11.770 --> 00:44:18.470
我当然可以卷发，然后

00:44:15.320 --> 00:44:21.230
如果我可以的话，可以一次又一次地存储

00:44:18.470 --> 00:44:24.230
检测到我可以切换回的任何错误

00:44:21.230 --> 00:44:27.190
五号，我可以打个电话， 

00:44:24.230 --> 00:44:37.930
当然，《玩具总动员4》仍然存在

00:44:27.190 --> 00:44:41.450
最后一步就是删除p5 

00:44:37.930 --> 00:44:44.510
好吧，不是因为我仍然卷

00:44:41.450 --> 00:44:50.470
指出我要拧6j 

00:44:44.510 --> 00:45:00.070
 em boy替换为b6，然后我可以

00:44:50.470 --> 00:45:00.070
离开b5，最后我可以部署

00:45:00.700 --> 00:45:10.430
最后一个是v7 

00:45:08.300 --> 00:45:12.410
现在我只是另一个版本

00:45:10.430 --> 00:45:14.810
更改正确写入数据的位置

00:45:12.410 --> 00:45:18.230
现在的原因是正确的

00:45:14.810 --> 00:45:21.710
全部，并来自新列

00:45:18.230 --> 00:45:25.120
新列的条款没有任何反应

00:45:21.710 --> 00:45:31.800
但是如果我这样做现在会发生什么

00:45:25.120 --> 00:45:31.800
我将其更改为七个

00:45:32.700 --> 00:45:42.430
当然，通话仍然返回

00:45:35.530 --> 00:45:45.040
七个，但是如果我添加一个新的，我不会

00:45:42.430 --> 00:45:47.670
确切地知道我在这里还有另一个

00:45:45.040 --> 00:45:47.670
一

00:45:50.880 --> 00:46:03.720
任何电影都可以确定终结者

00:46:01.220 --> 00:46:05.250
意思是原来的是的，因为

00:46:03.720 --> 00:46:08.100
现在有很多终结者

00:46:05.250 --> 00:46:11.340
好吧，打个电话，但现在注意

00:46:08.100 --> 00:46:14.450
如果我选择“终结者” 

00:46:11.340 --> 00:46:17.040
在新列中而不是旧列中

00:46:14.450 --> 00:46:19.260
你说的，如果我这样，这将起作用

00:46:17.040 --> 00:46:21.510
当然要对版本做一个机器人

00:46:19.260 --> 00:46:25.770
因为第六版只是从

00:46:21.510 --> 00:46:26.550
新的，所以你可以取代我去

00:46:25.770 --> 00:46:31.980
回到六

00:46:26.550 --> 00:46:34.350
我打了电话，终结者是什么

00:46:31.980 --> 00:46:37.380
在那里，我只是你知道所有事情

00:46:34.350 --> 00:46:38.610
这三个版本总是回来

00:46:37.380 --> 00:46:40.530
兼容性，我们已经看到我一直

00:46:38.610 --> 00:46:44.570
从新旧转换

00:46:40.530 --> 00:46:44.570
添加数据，数据永不丢失

00:46:45.290 --> 00:46:51.630
所以我们快完成了

00:46:47.310 --> 00:46:56.270
如果你的意思是如果你想检查

00:46:51.630 --> 00:46:59.520
所有这些例子，深入了解

00:46:56.270 --> 00:47:01.860
 sto，你可以去这是教程

00:46:59.520 --> 00:47:05.040
一切都在解释，这也是

00:47:01.860 --> 00:47:06.660
如果你想教你

00:47:05.040 --> 00:47:10.320
对东方人有一些了解

00:47:06.660 --> 00:47:12.540
想要其中的所有内容的摘要

00:47:10.320 --> 00:47:14.010
你可能会发现的是

00:47:12.540 --> 00:47:17.040
我正在镜像时发生了什么

00:47:14.010 --> 00:47:20.220
正确的交通回头

00:47:17.040 --> 00:47:21.510
发送请求到两个服务

00:47:20.220 --> 00:47:23.820
两种不同的版本， 

00:47:21.510 --> 00:47:26.460
我正在插入的插入

00:47:23.820 --> 00:47:29.460
同样的数据库权限可以避免这种情况

00:47:26.460 --> 00:47:31.470
可以使用两种方法，但是有

00:47:29.460 --> 00:47:33.360
实际上是三个，但我会向您解释

00:47:31.470 --> 00:47:35.190
两个第一个是使用合成

00:47:33.360 --> 00:47:37.560
交易中的毒品制裁

00:47:35.190 --> 00:47:39.180
只是检测到流量

00:47:37.560 --> 00:47:41.730
流量很浅

00:47:39.180 --> 00:47:44.100
这样做很容易，然后滚动

00:47:41.730 --> 00:47:46.170
支持所有交易，以便您收到

00:47:44.100 --> 00:47:48.090
两个插入件以服务BB一和

00:47:46.170 --> 00:47:50.400
服务VB到那里有发送两个

00:47:48.090 --> 00:47:52.890
正确插入数据库，但是当

00:47:50.400 --> 00:47:55.140
然后对v2做出响应的阅读器

00:47:52.890 --> 00:47:58.520
后面有一排，所以此插入永远不会

00:47:55.140 --> 00:47:58.520
发生在数据库内部

00:47:58.750 --> 00:48:03.970
另一个选择就是创建一个

00:48:00.280 --> 00:48:05.800
漂亮的球利用数据库

00:48:03.970 --> 00:48:07.750
集群，所以你有类似

00:48:05.800 --> 00:48:09.520
这是什么生产数据库和

00:48:07.750 --> 00:48:11.050
然后我有一张账单到所有数据库

00:48:09.520 --> 00:48:13.270
使用凯特的例子

00:48:11.050 --> 00:48:15.099
开源工具，然后是所有费率

00:48:13.270 --> 00:48:17.470
发生在生产和所有

00:48:15.099 --> 00:48:19.510
权利进入了一次性数据库，因此

00:48:17.470 --> 00:48:22.510
您的交通流量很浅

00:48:19.510 --> 00:48:24.550
两种服务的插入

00:48:22.510 --> 00:48:27.820
去这个一次性的东西，然后当你

00:48:24.550 --> 00:48:31.140
从v1切换到v2，那么您只需要

00:48:27.820 --> 00:48:38.859
删除所有这些一次性数据库

00:48:31.140 --> 00:48:41.710
我们几乎做得很好，我的意思是

00:48:38.859 --> 00:48:44.260
你知道很难

00:48:41.710 --> 00:48:47.140
让我们以这种方式结束保持零

00:48:44.260 --> 00:48:49.810
使用微服务进行停机部署

00:48:47.140 --> 00:48:51.970
但只有你知道忘记什么

00:48:49.810 --> 00:48:53.470
您过去已经做过，只是开始

00:48:51.970 --> 00:48:55.330
将这些新技术应用于

00:48:53.470 --> 00:48:57.849
历史，这真的很容易做到

00:48:55.330 --> 00:49:01.180
您已经看到谨慎行事

00:48:57.849 --> 00:49:03.910
因为记住在里面有一个O 

00:49:01.180 --> 00:49:05.680
在重命名列的情况下

00:49:03.910 --> 00:49:08.830
还有所有数据的一列

00:49:05.680 --> 00:49:11.349
而且可能没有续集管理

00:49:08.830 --> 00:49:15.849
管理员将允许您删除

00:49:11.349 --> 00:49:19.990
本专栏，但理论上的最后一步

00:49:15.849 --> 00:49:21.580
应该删除旧列

00:49:19.990 --> 00:49:23.290
我的意思是也有这种

00:49:21.580 --> 00:49:25.510
有一些冲突的书，我会

00:49:23.290 --> 00:49:27.220
解释一下，但基本上这是一个

00:49:25.510 --> 00:49:29.349
指责两个微服务e 

00:49:27.220 --> 00:49:32.740
 Janaka的18个数据库进行了解释

00:49:29.349 --> 00:49:34.720
这种技术和其他用例，以及

00:49:32.740 --> 00:49:36.670
他们可以从以下位置免费下载

00:49:34.720 --> 00:49:38.530
开发人员地址，您随便走

00:49:36.670 --> 00:49:41.619
在那儿注册，然后就可以

00:49:38.530 --> 00:49:45.580
全部下载，仅此而已

00:49:41.619 --> 00:49:47.619
如果有任何问题就可以形成

00:49:45.580 --> 00:49:49.930
在Twitter上，甚至给我发送电子邮件

00:49:47.619 --> 00:49:51.910
意味着有人问我可以发送

00:49:49.930 --> 00:49:54.099
您会收到一封电子邮件，是的，您可以发送

00:49:51.910 --> 00:49:57.700
电子邮件，因为如果不是，这里是邮件

00:49:54.099 --> 00:49:57.970
这意味着在这里谢谢

00:49:57.700 --> 00:49:58.950
您

00:49:57.970 --> 00:50:05.620
 [掌声] 

00:49:58.950 --> 00:50:05.620
 [音乐] 

