WEBVTT
Kind: captions
Language: zh-Hans

00:00:01.149 --> 00:00:09.650
您好在今天的 spring 技巧 中

00:00:05.839 --> 00:00:11.990
我们要看一下 Spring 的基础知识

00:00:09.650 --> 00:00:13.160
只是 Spring 101的绝对基础

00:00:11.990 --> 00:00:15.410
你会我们将建立一个绝对的

00:00:13.160 --> 00:00:17.630
基本的简单Spring应用程序使用

00:00:15.410 --> 00:00:19.580
 spring boot ，然后我们可以做到这一点，我们

00:00:17.630 --> 00:00:20.780
我们需要一个样本

00:00:19.580 --> 00:00:22.100
我要使用的应用程序

00:00:20.780 --> 00:00:24.350
为此，我们将创建一个

00:00:22.100 --> 00:00:27.110
在spring tool中的应用

00:00:24.350 --> 00:00:29.270
 spring tool suite 是

00:00:27.110 --> 00:00:31.340
当然只是一些不同

00:00:29.270 --> 00:00:34.820
可以在任何一个之上使用的插件

00:00:31.340 --> 00:00:36.380
现有发行版或单独发行

00:00:34.820 --> 00:00:37.910
可以自己下载的东西

00:00:36.380 --> 00:00:39.470
而且你知道 eclipse 发行版 

00:00:37.910 --> 00:00:40.850
全部开源，因此您可以下载

00:00:39.470 --> 00:00:42.680
完整的 spring tool suite ，用于

00:00:40.850 --> 00:00:44.570
与 eclipse 一起分发

00:00:42.680 --> 00:00:45.770
所有其他一切都捆绑在一起

00:00:44.570 --> 00:00:47.900
我建议的就是超级好

00:00:45.770 --> 00:00:50.000
很简单，您只需下载二进制文件即可

00:00:47.900 --> 00:00:52.160
您不相关的操作系统

00:00:50.000 --> 00:00:52.579
下一台Mac或Windows，您将

00:00:52.160 --> 00:00:53.630
比赛

00:00:52.579 --> 00:00:55.160
对，那么您就可以建立一个新的

00:00:53.630 --> 00:00:56.690
我要建立一个应用程序

00:00:55.160 --> 00:01:00.140
通过在此处提交新申请

00:00:56.690 --> 00:01:04.489
 spring starter 项目

00:01:00.140 --> 00:01:05.840
我是一个向导，这个向导只是一个

00:01:04.489 --> 00:01:07.069
配置新的简单方法

00:01:05.840 --> 00:01:08.479
应用程序，我要建立一个高地

00:01:07.069 --> 00:01:10.909
统一称为预订服务

00:01:08.479 --> 00:01:12.859
我接下来要打，它会给我一堆

00:01:10.909 --> 00:01:14.359
我不同的复选框或事物

00:01:12.859 --> 00:01:17.299
可以单击添加到我的应用程序中

00:01:14.359 --> 00:01:18.649
在这些不同的下拉菜单中

00:01:17.299 --> 00:01:20.959
我们的目标我很高兴

00:01:18.649 --> 00:01:23.810
已经获得 reactor reactive web 支持

00:01:20.959 --> 00:01:25.579
开发人员工具执行器反应式MongoDB 

00:01:23.810 --> 00:01:27.920
这些是我经常使用的

00:01:25.579 --> 00:01:29.990
例如，所以我打了下一个

00:01:27.920 --> 00:01:33.170
现在将给我一个URL请记住这一点

00:01:29.990 --> 00:01:36.079
 IDE只是花哨的前端

00:01:33.170 --> 00:01:38.929
开始那是指甲的 Spring 

00:01:36.079 --> 00:01:40.670
初始值设定项，如果您愿意

00:01:38.929 --> 00:01:43.159
理论上去那个初始化粘贴

00:01:40.670 --> 00:01:45.079
将该网址导入浏览器或控制台， 

00:01:43.159 --> 00:01:46.639
它会给你一个压缩文件

00:01:45.079 --> 00:01:48.950
下载一个zip文件，他们可以解压缩

00:01:46.639 --> 00:01:51.560
然后导入生成的Maven 

00:01:48.950 --> 00:01:53.090
项目到IDE，但为什么要打扰

00:01:51.560 --> 00:01:55.130
只要去就可以完成所有这些额外的工作

00:01:53.090 --> 00:01:56.840
到ID并选择文件新启动器

00:01:55.130 --> 00:01:59.029
然后就去吧，这就是我所做的

00:01:56.840 --> 00:02:01.549
在这里我打完了，然后我给

00:01:59.029 --> 00:02:04.459
给我一个新项目，然后我要打开

00:02:01.549 --> 00:02:06.770
在我的IDE中启动该项目

00:02:04.459 --> 00:02:09.379
它在这里，我要选择新文件

00:02:06.770 --> 00:02:11.510
你知道我已经选择了所有

00:02:09.379 --> 00:02:12.860
我有一个新的应用程序，这是 Spring 

00:02:11.510 --> 00:02:13.430
 Spring 申请还可以

00:02:12.860 --> 00:02:14.140
应用

00:02:13.430 --> 00:02:15.730
旧

00:02:14.140 --> 00:02:17.650
他们在一天结束时在

00:02:15.730 --> 00:02:19.209
一天结束的时候， 

00:02:17.650 --> 00:02:22.330
只是一大袋东西

00:02:19.209 --> 00:02:23.860
你描述自己的贡献

00:02:22.330 --> 00:02:25.510
您提供的定义这些

00:02:23.860 --> 00:02:27.970
对象代表您的业务逻辑

00:02:25.510 --> 00:02:31.300
而目标是让 Spring 做更多的事情

00:02:27.970 --> 00:02:33.190
在没有爆炸的情况下尽可能为您服务

00:02:31.300 --> 00:02:35.740
根据您在中的代码

00:02:33.190 --> 00:02:37.570
干扰您的业务逻辑，所以我们

00:02:35.740 --> 00:02:39.190
我们有一个叫做依赖的东西

00:02:37.570 --> 00:02:40.239
注入依赖背后的想法

00:02:39.190 --> 00:02:45.420
注射很简单

00:02:40.239 --> 00:02:49.480
假设我想建立一个um aa 

00:02:45.420 --> 00:02:51.130
 API支持访问的HTTP API 

00:02:49.480 --> 00:02:53.290
您的数据是塞尔数据是

00:02:51.130 --> 00:02:56.530
本身存储在数据库中

00:02:53.290 --> 00:02:58.930
您可以方便地通过

00:02:56.530 --> 00:03:00.370
好的，这些不同

00:02:58.930 --> 00:03:01.870
您拥有的逻辑层和应用程序

00:03:00.370 --> 00:03:03.880
获得了网络层

00:03:01.870 --> 00:03:05.470
代表网站的

00:03:03.880 --> 00:03:07.390
数据访问对象

00:03:05.470 --> 00:03:09.970
对象，然后依次转到存储库

00:03:07.390 --> 00:03:12.400
依赖并管理对

00:03:09.970 --> 00:03:14.080
您的数据库的实际连接

00:03:12.400 --> 00:03:16.720
您的数据库对，您有三个

00:03:14.080 --> 00:03:18.070
 rest api 取决于不同的对象

00:03:16.720 --> 00:03:22.209
在存储库上，具体取决于

00:03:18.070 --> 00:03:23.829
数据库，如果你告诉 Spring 这些

00:03:22.209 --> 00:03:25.660
对象，然后您可以集中

00:03:23.829 --> 00:03:27.040
您可以保留这些对象的定义

00:03:25.660 --> 00:03:28.329
他们在一个地方，如果你想

00:03:27.040 --> 00:03:30.160
改变他们，你只是改变他们

00:03:28.329 --> 00:03:32.380
一个地方，然后所有的代码

00:03:30.160 --> 00:03:33.930
结束依赖的应用程序

00:03:32.380 --> 00:03:38.530
这些对象可以相应地更新

00:03:33.930 --> 00:03:40.120
同样，您不必做所有的事情

00:03:38.530 --> 00:03:42.100
工作正常，所以有人说你想

00:03:40.120 --> 00:03:44.290
建立一个应该很好的服务

00:03:42.100 --> 00:03:47.350
建立HTTP涉及什么

00:03:44.290 --> 00:03:50.650
服务很好，您需要Web服务器，因此

00:03:47.350 --> 00:03:52.480
只是你有好几天的工作

00:03:50.650 --> 00:03:54.579
知道学习有关Web服务器的所有知识，以及

00:03:52.480 --> 00:03:56.530
站起来并配置路由

00:03:54.579 --> 00:03:59.530
然后将该路由连接到您的

00:03:56.530 --> 00:04:02.110
在JVM代码中的某个对象

00:03:59.530 --> 00:04:03.519
然后一旦完成，现在怎么样

00:04:02.110 --> 00:04:05.440
您现在需要获取一个指向

00:04:03.519 --> 00:04:07.000
该存储库，进而需要

00:04:05.440 --> 00:04:08.440
管理对数据库的引用

00:04:07.000 --> 00:04:10.120
谁可以创建数据库

00:04:08.440 --> 00:04:12.549
当然可以，但是为什么不呢？ 

00:04:10.120 --> 00:04:14.200
让我们 Spring 为您做，让我们带来

00:04:12.549 --> 00:04:14.440
引导部分特别是为了

00:04:14.200 --> 00:04:16.180
您

00:04:14.440 --> 00:04:18.940
所以这里有两件事

00:04:16.180 --> 00:04:21.240
你可以定义对象然后教

00:04:18.940 --> 00:04:26.470
他们如何将自己联系在一起

00:04:21.240 --> 00:04:27.760
使用spring，如果您想要更多

00:04:26.470 --> 00:04:28.900
需要帮助之前，例如网络

00:04:27.760 --> 00:04:30.670
要提供的服务器

00:04:28.900 --> 00:04:31.960
示例数据库自动

00:04:30.670 --> 00:04:35.020
创造了这些东西

00:04:31.960 --> 00:04:36.220
那你可以去 spring boot 了，但是

00:04:35.020 --> 00:04:37.900
但这一切都从 Spring 开始

00:04:36.220 --> 00:04:39.700
一切都始于对如何

00:04:37.900 --> 00:04:44.200
事情彼此相关，所以说

00:04:39.700 --> 00:04:46.150
我想建立一个简单的REST API 

00:04:44.200 --> 00:04:49.720
所以说我有一个应用程序

00:04:46.150 --> 00:04:52.830
通过MongoDB管理对数据的访问

00:04:49.720 --> 00:04:57.250
好吧，我要说 class 预约

00:04:52.830 --> 00:04:58.510
 rest controller ，这将是一个

00:04:57.250 --> 00:05:01.140
将用于管理访问权限的对象

00:04:58.510 --> 00:05:04.510
我在MongoDB中的数据，所以我说私有

00:05:01.140 --> 00:05:06.730
最后的和我需要的我猜我猜我

00:05:04.510 --> 00:05:08.710
可能从一个很低的水平开始

00:05:06.730 --> 00:05:10.150
我需要某种服务

00:05:08.710 --> 00:05:15.460
至少我可以说那里的资料库

00:05:10.150 --> 00:05:18.880
类保留存储库，然后

00:05:15.460 --> 00:05:21.070
我想在某个时候需要

00:05:18.880 --> 00:05:25.980
访问Mongo数据库不是吗

00:05:21.070 --> 00:05:30.790
这是一个Mongo数据库

00:05:25.980 --> 00:05:33.940
 DB，我要说alt 

00:05:30.790 --> 00:05:36.550
命令，并且LS有一个Sam 

00:05:33.940 --> 00:05:38.530
然后我将覆盖生成

00:05:36.550 --> 00:05:40.240
从我那里的构造函数

00:05:38.530 --> 00:05:41.920
好吧，所以我创建了一个具有

00:05:40.240 --> 00:05:43.960
我在这里表达的依赖性

00:05:41.920 --> 00:05:45.100
通过该Mongo上的构造函数

00:05:43.960 --> 00:05:48.690
数据库，我们不知道那是哪里

00:05:45.100 --> 00:05:52.800
来自我的 rest controller 

00:05:48.690 --> 00:05:58.600
私人，你知道私人决赛

00:05:52.800 --> 00:06:03.000
像这样的预订库

00:05:58.600 --> 00:06:06.930
仓库相同的技巧，我要做一个替代

00:06:03.000 --> 00:06:11.430
命令s我将生成构造函数

00:06:06.930 --> 00:06:14.140
瞧，还不错，所以我知道了

00:06:11.430 --> 00:06:16.120
你知道这是怎么得到的

00:06:14.140 --> 00:06:17.590
很好地连接在一起的一种方法

00:06:16.120 --> 00:06:19.750
一种将这些东西连接起来的方法

00:06:17.590 --> 00:06:21.820
在一起是非常明确的，你可以

00:06:19.750 --> 00:06:26.680
使用Java配置，所以我可以说

00:06:21.820 --> 00:06:29.980
类预订配置还可以， 

00:06:26.680 --> 00:06:31.480
这只是 Spring 的一个物体

00:06:29.980 --> 00:06:33.940
知道这一点，因为我已经注释了

00:06:31.480 --> 00:06:35.740
它带有一个标记注释，即所谓的

00:06:33.940 --> 00:06:38.050
构造型注释称为add 

00:06:35.740 --> 00:06:41.050
配置时配置

00:06:38.050 --> 00:06:41.810
最终用组件注释

00:06:41.050 --> 00:06:43.540
我们将谈论

00:06:41.810 --> 00:06:46.820
组件再次，但这是

00:06:43.540 --> 00:06:49.070
注释告诉Spring 清扫

00:06:46.820 --> 00:06:51.200
任何带有注释的类

00:06:49.070 --> 00:06:53.000
或以或或以注释

00:06:51.200 --> 00:06:55.460
注释本身就是lis的反义词

00:06:53.000 --> 00:06:57.800
加上注释，它将扫除

00:06:55.460 --> 00:07:01.010
该对象用于一点点管理

00:06:57.800 --> 00:07:02.389
为我们管理它，它会看到这个

00:07:01.010 --> 00:07:04.370
将会看到的配置注释

00:07:02.389 --> 00:07:06.110
它是一个组件，一个组件是

00:07:04.370 --> 00:07:07.820
足以让 Spring 来管理它，但是那

00:07:06.110 --> 00:07:10.010
配置更进一步

00:07:07.820 --> 00:07:12.260
告诉 Spring ，里面有方法

00:07:10.010 --> 00:07:15.410
这个对象这个类

00:07:12.260 --> 00:07:17.210
为您生产对象实例

00:07:15.410 --> 00:07:19.430
我们称那些 Spring 世界的人

00:07:17.210 --> 00:07:20.900
称这些结果对象为bean 

00:07:19.430 --> 00:07:24.020
Spring 管理的对象是

00:07:20.900 --> 00:07:26.979
一个beans，所以您创建了一个

00:07:24.020 --> 00:07:32.919
注释着被这样说

00:07:26.979 --> 00:07:38.990
预订 rest controller 还可以

00:07:32.919 --> 00:07:40.700
预订 rest controller ，还有

00:07:38.990 --> 00:07:44.990
我的控制器就很简单

00:07:40.700 --> 00:07:49.070
对的，我希望那个控制器

00:07:44.990 --> 00:07:53.630
取决于我的预订库

00:07:49.070 --> 00:07:59.140
预留存储库预留

00:07:53.630 --> 00:08:04.130
仓库，我们说返回新

00:07:59.140 --> 00:08:05.750
保留资料库还可以

00:08:04.130 --> 00:08:11.169
完全取决于数据源

00:08:05.750 --> 00:08:13.340
善良 bean Mongo数据库权利和

00:08:11.169 --> 00:08:15.590
现在我想我们只能返回不，我

00:08:13.340 --> 00:08:16.940
我不知道如何创建一个Mongo 

00:08:15.590 --> 00:08:18.710
暂存数据库，但让我们返回

00:08:16.940 --> 00:08:20.360
暂时为空，我们知道这需要

00:08:18.710 --> 00:08:23.660
最终得到解决，但只是

00:08:20.360 --> 00:08:25.460
现在不行，所以我要注入

00:08:23.660 --> 00:08:29.470
要告诉 Spring 注射或

00:08:25.460 --> 00:08:31.550
满足此要求

00:08:29.470 --> 00:08:34.370
像这样的协作对象

00:08:31.550 --> 00:08:37.360
告诉它在提供

00:08:34.370 --> 00:08:39.700
此方法的原型还可以

00:08:37.360 --> 00:08:43.490
最后我的 rest controller 在这里

00:08:39.700 --> 00:08:44.720
同样，它需要一个指向

00:08:43.490 --> 00:08:48.380
服务器上有我要说的海报

00:08:44.720 --> 00:08:50.330
一个新的预订 rest controller 

00:08:48.380 --> 00:08:54.960
提供指向存储库的指针，例如

00:08:50.330 --> 00:08:58.200
所以预订库是

00:08:54.960 --> 00:08:59.910
 Arar很好看，所以有

00:08:58.200 --> 00:09:01.440
与我有关的三个对象

00:08:59.910 --> 00:09:02.910
彼此依赖

00:09:01.440 --> 00:09:05.970
数据库，我们不知道那是一个

00:09:02.910 --> 00:09:07.110
大老就在那里做，我们已经

00:09:05.970 --> 00:09:09.330
 rest controller ，但我们当然不

00:09:07.110 --> 00:09:11.880
有一个网络服务器，所以如果你看

00:09:09.330 --> 00:09:14.520
这种配置，这很好，你知道

00:09:11.880 --> 00:09:17.370
但是我们真的没有一个你知道如何

00:09:14.520 --> 00:09:19.560
我们对这家出版社意味着什么

00:09:17.370 --> 00:09:21.360
控制器成为要获取的API 

00:09:19.560 --> 00:09:23.610
暴露给我本可以拥有的互联网

00:09:21.360 --> 00:09:27.620
这样的注释我可以在获取时说

00:09:23.610 --> 00:09:32.220
映射正斜杠保留和

00:09:27.620 --> 00:09:38.220
在这里有一个端点可以返回您

00:09:32.220 --> 00:09:41.220
知道所有数据，因此返回该点RR 

00:09:38.220 --> 00:09:42.480
点存储库，我想做什么

00:09:41.220 --> 00:09:47.400
好好支持我会支持一种方法

00:09:42.480 --> 00:09:52.950
叫找到所有我想找到所有的

00:09:47.400 --> 00:09:54.360
反应性好的数据，所以我们不知道

00:09:52.950 --> 00:09:58.470
这将如何工作，但我们知道我们

00:09:54.360 --> 00:10:00.690
想支持它，所以现在有几个

00:09:58.470 --> 00:10:03.570
首先要分解的事情

00:10:00.690 --> 00:10:08.850
它的通量就像一个集合- 

00:10:03.570 --> 00:10:10.740
这是一种可以处理中介的类型

00:10:08.850 --> 00:10:12.780
访问将要

00:10:10.740 --> 00:10:15.330
异步交付给我们不对

00:10:12.780 --> 00:10:17.100
现在，但也许以后我也要两个

00:10:15.330 --> 00:10:18.510
斯廷森男人的保留类型

00:10:17.100 --> 00:10:20.430
这是一项旨在

00:10:18.510 --> 00:10:21.960
支持类型的管理实体

00:10:20.430 --> 00:10:24.120
辞职，让我们继续定义

00:10:21.960 --> 00:10:26.730
这个类型好吧，让我们继续说

00:10:24.120 --> 00:10:28.410
创建课程预订将成为您

00:10:26.730 --> 00:10:30.810
知道它会拥有的全新对象

00:10:28.410 --> 00:10:32.850
这将有一个私人领域

00:10:30.810 --> 00:10:35.190
字符串ID，这将是

00:10:32.850 --> 00:10:39.600
将其存储在MongoDB文档中，然后

00:10:35.190 --> 00:10:42.950
私人字符串保留名称，所以在那里

00:10:39.600 --> 00:10:45.510
我们去那是我的基本实体

00:10:42.950 --> 00:10:47.970
这显然是Java，所以我需要一些

00:10:45.510 --> 00:10:51.330
一些鳄鱼和二传手等等

00:10:47.970 --> 00:10:54.900
所以我要说alt shift或对不起

00:10:51.330 --> 00:10:57.510
命令alt，我会生成一些

00:10:54.900 --> 00:11:00.000
我所在领域的吸气器和吸气器

00:10:57.510 --> 00:11:02.340
那里选择所有很好产生所有

00:11:00.000 --> 00:11:04.480
命令s的构造函数

00:11:02.340 --> 00:11:07.360
我不想要那两个字符串

00:11:04.480 --> 00:11:10.270
好的，我希望构造函数使用

00:11:07.360 --> 00:11:13.630
这些领域，然后我们想要

00:11:10.270 --> 00:11:16.780
一个没有字段的构造函数，所以

00:11:13.630 --> 00:11:19.210
您是否选择了所有生成，并且在那里

00:11:16.780 --> 00:11:21.610
我的基本安排是

00:11:19.210 --> 00:11:24.160
基本对象好了，这一切都为我完成

00:11:21.610 --> 00:11:25.660
现在和这里我想说的是找到所有

00:11:24.160 --> 00:11:26.860
是的，我们不知道该如何获得

00:11:25.660 --> 00:11:27.820
结果还没有，但是我们知道那就是我们

00:11:26.860 --> 00:11:29.440
想做得好

00:11:27.820 --> 00:11:31.450
所以我们去那里是我的HTTP端点

00:11:29.440 --> 00:11:34.810
我告诉我告诉 Spring 嘿我

00:11:31.450 --> 00:11:36.880
希望您采用此方法并调用

00:11:34.810 --> 00:11:40.360
每当有人进行HTTP GET时它

00:11:36.880 --> 00:11:41.770
要求在我们的网站上强行预订

00:11:40.360 --> 00:11:43.540
我们尚未定义的服务器

00:11:41.770 --> 00:11:45.250
不知道会发生什么，但是我们

00:11:43.540 --> 00:11:47.140
知道我们想要它正确，我们已经

00:11:45.250 --> 00:11:49.210
告诉Spring，我有一个构造函数

00:11:47.140 --> 00:11:50.620
提供一个指向

00:11:49.210 --> 00:11:53.380
预订资料库就是这个东西

00:11:50.620 --> 00:11:56.290
在这里和生活的定义

00:11:53.380 --> 00:11:57.640
在这里，但施工逻辑

00:11:56.290 --> 00:12:00.520
所有这些东西都生活在这个

00:11:57.640 --> 00:12:01.900
配置类好结果

00:12:00.520 --> 00:12:03.700
那有点

00:12:01.900 --> 00:12:06.070
在这种情况下断开连接

00:12:03.700 --> 00:12:07.780
明显感觉到我的Mongo数据库

00:12:06.070 --> 00:12:09.160
必须构造实例，因为

00:12:07.780 --> 00:12:12.670
除此以外，别无选择

00:12:09.160 --> 00:12:15.040
这种情况下为什么不只是

00:12:12.670 --> 00:12:18.310
对象及其定义

00:12:15.040 --> 00:12:20.500
在组件的带电状态下布线

00:12:18.310 --> 00:12:22.330
类本身并依靠目标代码

00:12:20.500 --> 00:12:23.800
本身，所以我要用

00:12:22.330 --> 00:12:26.590
另一个构造型注释或另一个

00:12:23.800 --> 00:12:28.300
标记注释mm-hmm称为发束

00:12:26.590 --> 00:12:29.950
控制器，它遵循相同的规则

00:12:28.300 --> 00:12:32.560
作为该配置，就是这样

00:12:29.950 --> 00:12:34.510
组件，因为它在此软件包中

00:12:32.560 --> 00:12:37.080
会被组件发现

00:12:34.510 --> 00:12:40.030
可以在应用程序启动时

00:12:37.080 --> 00:12:43.630
同样，我有一个可以

00:12:40.030 --> 00:12:45.760
说这是一个像这样的仓库

00:12:43.630 --> 00:12:48.040
存储库本身带有元注释

00:12:45.760 --> 00:12:49.660
一个组件，所以我拥有了所有这些东西

00:12:48.040 --> 00:12:53.050
你知道他们有仓库我有

00:12:49.660 --> 00:12:54.070
配置时的风险控制者

00:12:53.050 --> 00:12:55.270
这些是我不同的对象， 

00:12:54.070 --> 00:12:57.400
 Spring 要去看看这些标记

00:12:55.270 --> 00:12:59.670
注释将清除这些

00:12:57.400 --> 00:13:02.020
森林和森林中的物体和金属

00:12:59.670 --> 00:13:03.220
相互依存是

00:13:02.020 --> 00:13:06.430
由类型和

00:13:03.220 --> 00:13:08.080
构造函数等等，所以这是

00:13:06.430 --> 00:13:09.700
非常非常你知道我认为很干净

00:13:08.080 --> 00:13:12.820
现在唯一的方法是

00:13:09.700 --> 00:13:14.500
数据库，您知道II确实需要

00:13:12.820 --> 00:13:16.510
定义在某个时候我需要

00:13:14.500 --> 00:13:17.650
这个定义在某处，但我们

00:13:16.510 --> 00:13:19.210
使用 spring boot 

00:13:17.650 --> 00:13:21.430
所以 spring boot 可以帮助我们休息

00:13:19.210 --> 00:13:22.660
可以帮助我们脱离您的方式

00:13:21.430 --> 00:13:24.010
知道拥有这些具有

00:13:22.660 --> 00:13:26.380
这些HTTP端点

00:13:24.010 --> 00:13:27.880
已经很方便了，我们可以

00:13:26.380 --> 00:13:32.380
例如忽略Nano 

00:13:27.880 --> 00:13:34.150
现在将对象连接到Web服务器

00:13:32.380 --> 00:13:36.790
我们可以感谢 spring boot 

00:13:34.150 --> 00:13:39.160
我们甚至可以忽略更多

00:13:36.790 --> 00:13:41.080
 spring boot 看起来的例子

00:13:39.160 --> 00:13:43.089
 XML，这是您的这个文件

00:13:41.080 --> 00:13:45.070
建立文件，在那里

00:13:43.089 --> 00:13:47.050
 spring boot 启动死了吗

00:13:45.070 --> 00:13:49.180
反应性的，这意味着默认情况下

00:13:47.050 --> 00:13:54.040
 Spring 的引导将尝试创建一个

00:13:49.180 --> 00:13:56.350
连接到正在运行的localhost 

00:13:54.040 --> 00:13:57.880
 MongoDB的实例，所以我可以删除

00:13:56.350 --> 00:14:00.820
该bean，它将仅提供默认值

00:13:57.880 --> 00:14:02.950
为我们而所有的代码

00:14:00.820 --> 00:14:04.180
需要它会注入它，这意味着

00:14:02.950 --> 00:14:06.250
如果我可以实际运行此代码

00:14:04.180 --> 00:14:08.050
想注入它，但再次看

00:14:06.250 --> 00:14:09.910
这段代码，实际上你知道

00:14:08.050 --> 00:14:12.940
假设我建立了这段程式码

00:14:09.910 --> 00:14:14.230
假设我做到了II可以做到，但是

00:14:12.940 --> 00:14:16.480
与数据库交谈是这样的

00:14:14.230 --> 00:14:17.980
很低级，所以另一件事

00:14:16.480 --> 00:14:19.900
这使 Spring 变得如此有用，以至于我们有了

00:14:17.980 --> 00:14:21.550
这些抽象这些非常低

00:14:19.900 --> 00:14:23.709
使工作正常的级别抽象

00:14:21.550 --> 00:14:25.810
繁琐的基础设施之类的东西

00:14:23.709 --> 00:14:28.330
数据库和消息队列等等

00:14:25.810 --> 00:14:31.870
在更容易使用它归结为所有

00:14:28.330 --> 00:14:35.140
它减少的样板代码的种类

00:14:31.870 --> 00:14:36.790
降至最低的最低限度

00:14:35.140 --> 00:14:38.820
您正在尝试这样做的事情

00:14:36.790 --> 00:14:40.839
而不是直接使用MongoDB base 

00:14:38.820 --> 00:14:47.709
而不是直接这样做，我要

00:14:40.839 --> 00:14:51.190
使用反应性Mongo模板好吧， 

00:14:47.709 --> 00:14:53.470
反应性Mongo模板只是一个

00:14:51.190 --> 00:14:56.350
您可以用来的便利客户

00:14:53.470 --> 00:14:58.420
和我说话，那将会是

00:14:56.350 --> 00:15:02.140
我在介绍的东西

00:14:58.420 --> 00:15:03.790
像这样一次注入我的构造函数

00:15:02.140 --> 00:15:05.410
我已经完成了对我的引用

00:15:03.790 --> 00:15:06.730
我可以用它来取得良好的效果

00:15:05.410 --> 00:15:10.650
现在可以对芒戈说

00:15:06.730 --> 00:15:13.450
看，请转到模板，转到

00:15:10.650 --> 00:15:18.880
我的数据库并找到所有文件

00:15:13.450 --> 00:15:24.910
并匹配它们匹配它们或将它们映射到

00:15:18.880 --> 00:15:26.140
我的预订班还可以，所以在

00:15:24.910 --> 00:15:27.579
为了做到这一点，它将需要

00:15:26.140 --> 00:15:29.290
有关此预订的一些信息

00:15:27.579 --> 00:15:32.529
它需要知道如何

00:15:29.290 --> 00:15:35.199
映射ID这是ID字段右侧

00:15:32.529 --> 00:15:39.699
文档ID，它需要知道

00:15:35.199 --> 00:15:41.560
这是一个像这样的文件

00:15:39.699 --> 00:15:43.600
对，所以现在有我的文件

00:15:41.560 --> 00:15:45.220
我已经做到了，我认为那很漂亮

00:15:43.600 --> 00:15:47.850
很简单，不是吗

00:15:45.220 --> 00:15:50.949
确实有效，但是你知道吗

00:15:47.850 --> 00:15:53.529
这种工作很简单，尽管它是

00:15:50.949 --> 00:15:55.329
还有一点低层次的考虑，我

00:15:53.529 --> 00:15:56.680
仍然需要创建一个小结

00:15:55.329 --> 00:15:58.870
我能不能支持所有的

00:15:56.680 --> 00:16:00.639
我必须创建的关键生命周期方法

00:15:58.870 --> 00:16:02.230
阅读更新删除我必须去

00:16:00.639 --> 00:16:02.589
支持自定义查询等

00:16:02.230 --> 00:16:04.690
的东西

00:16:02.589 --> 00:16:06.579
所以我们可以再往前走一步

00:16:04.690 --> 00:16:09.670
启动已自动配置

00:16:06.579 --> 00:16:11.800
对我们来说spring data spring data是一个

00:16:09.670 --> 00:16:13.240
总括项目

00:16:11.800 --> 00:16:15.519
基于接口的能力

00:16:13.240 --> 00:16:18.730
定义自动提供

00:16:15.519 --> 00:16:20.550
满足的对象的定义

00:16:18.730 --> 00:16:25.259
该定义如此保留

00:16:20.550 --> 00:16:27.430
存储库扩展了反应性Mongo 

00:16:25.259 --> 00:16:30.370
仓库这将是一个

00:16:27.430 --> 00:16:33.970
用于管理对

00:16:30.370 --> 00:16:37.949
在这种情况下的实体或文件

00:16:33.970 --> 00:16:40.959
保留，所以命令一个导入

00:16:37.949 --> 00:16:42.730
正确的看那还不错，所以它已经

00:16:40.959 --> 00:16:44.350
有方法，如果你看这个反应

00:16:42.730 --> 00:16:46.630
它已经提供的漫画库

00:16:44.350 --> 00:16:48.639
插入的方法基于

00:16:46.630 --> 00:16:50.980
基于一个插入的集合

00:16:48.639 --> 00:16:54.010
反应性发布者，我们可以找到所有给定的

00:16:50.980 --> 00:16:55.329
一个例子，我们可以看看找到所有

00:16:54.010 --> 00:16:56.019
基于排序中的更多示例

00:16:55.329 --> 00:16:58.540
条件

00:16:56.019 --> 00:16:59.949
它支持反应式分类库

00:16:58.540 --> 00:17:00.490
说找到所有给定的

00:16:59.949 --> 00:17:03.220
条件

00:17:00.490 --> 00:17:06.130
反应堆存储库支持保存

00:17:03.220 --> 00:17:08.350
保存所有保存所有找到我的ID 

00:17:06.130 --> 00:17:10.419
找到我的身份证给发布者测试

00:17:08.350 --> 00:17:12.130
检查它是否存在，然后找到

00:17:10.419 --> 00:17:14.169
这实际上是我们所要做的

00:17:12.130 --> 00:17:15.699
定义或开始更早定义

00:17:14.169 --> 00:17:17.740
所有这些不同种类的共同点

00:17:15.699 --> 00:17:19.270
隐含生命周期方法

00:17:17.740 --> 00:17:21.809
界面，这就是我们需要做的

00:17:19.270 --> 00:17:24.040
Spring 数据将采用此接口， 

00:17:21.809 --> 00:17:25.870
提供一个我们可以

00:17:24.040 --> 00:17:27.909
我在这里注入正确的权利

00:17:25.870 --> 00:17:30.640
我可以按类型注入

00:17:27.909 --> 00:17:32.740
运行时在此处的第31行有一个断点

00:17:30.640 --> 00:17:33.970
我会发现我实际上没有这个

00:17:32.740 --> 00:17:35.260
界面显然你不能只是

00:17:33.970 --> 00:17:37.750
注入它没有像

00:17:35.260 --> 00:17:39.159
运行时，您知道接口实例

00:17:37.750 --> 00:17:40.900
你有一个实现

00:17:39.159 --> 00:17:42.400
接口，所以我将有一个指向

00:17:40.900 --> 00:17:43.840
引用一个对象

00:17:42.400 --> 00:17:46.480
实施保留或

00:17:43.840 --> 00:17:49.990
在我的 Spring 衬裙里，现在我有一个

00:17:46.480 --> 00:17:51.850
非常简单的API，具体取决于

00:17:49.990 --> 00:17:53.620
在那里存放或缓和到

00:17:51.850 --> 00:17:55.630
只是我可以创建自定义界面

00:17:53.620 --> 00:17:57.940
查找器方法以及我可以说我想要

00:17:55.630 --> 00:18:01.110
找到这个的所有实例

00:17:57.940 --> 00:18:05.110
通过预订名称进行预订

00:18:01.110 --> 00:18:06.430
领域，这样，仅此而已

00:18:05.110 --> 00:18:08.500
那是实际上会得到的

00:18:06.430 --> 00:18:10.270
根据惯例实施

00:18:08.500 --> 00:18:12.670
春爸爸要说我要创造

00:18:10.270 --> 00:18:14.140
在查询中的野兽

00:18:12.670 --> 00:18:16.180
数据库中的文档并找到

00:18:14.140 --> 00:18:18.130
渴望成为具有

00:18:16.180 --> 00:18:19.360
属性保留名称，其值

00:18:18.130 --> 00:18:22.900
等于我们提供的价值

00:18:19.360 --> 00:18:23.800
在RN参数中， 

00:18:22.900 --> 00:18:25.240
为我们做好了，我们不必

00:18:23.800 --> 00:18:27.310
实现只是为了完成

00:18:25.240 --> 00:18:28.630
我们自动，所以这是整个 Spring 

00:18:27.310 --> 00:18:30.400
现在启动，我当然已经休息了

00:18:28.630 --> 00:18:31.540
控制器Spring 启动

00:18:30.400 --> 00:18:35.440
自动确保

00:18:31.540 --> 00:18:39.640
那是个你知道工作的地方

00:18:35.440 --> 00:18:41.080
 rest controller ，这是一种方法

00:18:39.640 --> 00:18:42.730
顺便创建一个 rest controller 

00:18:41.080 --> 00:18:43.990
 Spring 你有两种不同的方式

00:18:42.730 --> 00:18:46.810
可以实际使用这种样式

00:18:43.990 --> 00:18:49.510
非常好，或者您可以使用新的

00:18:46.810 --> 00:18:52.120
功能反应式，让我们尝试

00:18:49.510 --> 00:18:57.670
路由器功能写一个功能

00:18:52.120 --> 00:19:01.390
服务器响应路由返回路由器

00:18:57.670 --> 00:19:05.610
功能点路线我要去

00:19:01.390 --> 00:19:09.190
提供请求谓词点获取

00:19:05.610 --> 00:19:11.230
正斜杠保留和这个

00:19:09.190 --> 00:19:14.770
这里需要的是一个

00:19:11.230 --> 00:19:16.900
类型处理程序函数的对象，所以我

00:19:14.770 --> 00:19:19.150
可以在那里提供一个lambda，但是我

00:19:16.900 --> 00:19:21.510
喜欢做的就是使用Java 8方法

00:19:19.150 --> 00:19:26.830
参考，所以我要说课

00:19:21.510 --> 00:19:28.300
预订处理程序好，这是

00:19:26.830 --> 00:19:29.620
会成为普通的老Spring bean 

00:19:28.300 --> 00:19:30.820
对此一无所知

00:19:29.620 --> 00:19:33.460
我要带来管理的对象

00:19:30.820 --> 00:19:39.280
为了我，我要说和你

00:19:33.460 --> 00:19:43.030
知道我要说我去了

00:19:39.280 --> 00:19:47.940
要实现处理程序响应或

00:19:43.030 --> 00:19:47.940
处理权

00:19:48.730 --> 00:19:52.090
它会实现第二种

00:19:50.710 --> 00:19:57.970
这是路线所需的

00:19:52.090 --> 00:19:59.200
方法是的，我们去了，类型

00:19:57.970 --> 00:20:05.950
这需要的是

00:19:59.200 --> 00:20:07.179
需要的是处理程序功能，所以我

00:20:05.950 --> 00:20:08.919
要创建一个处理程序函数

00:20:07.179 --> 00:20:13.239
要实现类型的处理函数

00:20:08.919 --> 00:20:14.950
这样的服务器响应

00:20:13.239 --> 00:20:22.499
及其服务器类型的功能

00:20:14.950 --> 00:20:28.440
响应好，所以这是我的习惯

00:20:22.499 --> 00:20:34.359
导入此处理程序

00:20:28.440 --> 00:20:35.859
导入，我们将不得不

00:20:34.359 --> 00:20:38.409
实现那些方法，所以我会说

00:20:35.859 --> 00:20:41.169
命令1，您可以看到

00:20:38.409 --> 00:20:42.190
期望的方法是给定的句柄

00:20:41.169 --> 00:20:43.539
服务器请求，实际上我没有

00:20:42.190 --> 00:20:45.220
甚至需要实现这一点，我们可以使用

00:20:43.539 --> 00:20:48.639
方法参考，所以我将摆脱它

00:20:45.220 --> 00:20:50.739
然后我们去那里是我的经理

00:20:48.639 --> 00:20:52.269
我会说这是处理程序

00:20:50.739 --> 00:20:57.759
由ID提供

00:20:52.269 --> 00:21:00.669
好的，所以保留ID和此处理程序

00:20:57.759 --> 00:21:02.289
为了完成其工作，需要

00:21:00.669 --> 00:21:07.169
指向保留库的指针

00:21:02.289 --> 00:21:12.299
像这样的预订库

00:21:07.169 --> 00:21:18.809
 alt命令S生成构造函数

00:21:12.299 --> 00:21:20.649
然后你去

00:21:18.809 --> 00:21:22.509
所以你去那里是我的习惯

00:21:20.649 --> 00:21:24.070
处理程序方法我要说的是

00:21:22.509 --> 00:21:25.239
想要注入合作对象

00:21:24.070 --> 00:21:30.190
在这里，他们提供了合作

00:21:25.239 --> 00:21:32.789
这里参考处理程序和我

00:21:30.190 --> 00:21:36.700
在Java 8和ER中使用方法参考

00:21:32.789 --> 00:21:39.489
通过ID我们去那里是我的习惯

00:21:36.700 --> 00:21:40.960
方法，你知道这是一个非常

00:21:39.489 --> 00:21:42.669
很简单的一段代码

00:21:40.960 --> 00:21:44.830
我们可以缩写一下

00:21:42.669 --> 00:21:47.499
再次使用命令1转换为

00:21:44.830 --> 00:21:50.109
静态导入还可以，很好用

00:21:47.499 --> 00:21:53.289
再次静态导入非常好，所以

00:21:50.109 --> 00:21:54.639
实际上是提供

00:21:53.289 --> 00:21:56.379
休息一下让我们实际上你知道

00:21:54.639 --> 00:21:59.580
现在实现说服务器

00:21:56.379 --> 00:22:02.250
首先反应良好

00:21:59.580 --> 00:22:11.000
我们要说的是请求点路径

00:22:02.250 --> 00:22:13.110
变量等于ID字符串ID等于

00:22:11.000 --> 00:22:15.090
和我想做的人抬头

00:22:13.110 --> 00:22:16.460
记录的ID，所以我会这样说

00:22:15.090 --> 00:22:20.850
步骤库

00:22:16.460 --> 00:22:24.080
通过ID输入ID和

00:22:20.850 --> 00:22:27.960
这会给我一个出版商

00:22:24.080 --> 00:22:29.760
保留单声道简历，实际上

00:22:27.960 --> 00:22:35.870
另一个出版商mono和flux是

00:22:29.760 --> 00:22:38.130
通过ID的两个发布者都可以，并且

00:22:35.870 --> 00:22:40.620
现在我要回覆

00:22:38.130 --> 00:22:44.850
客户，这是一个好的回应

00:22:40.620 --> 00:22:55.050
该身体是通过ID结果坐在

00:22:44.850 --> 00:22:58.290
保留点类不错

00:22:55.050 --> 00:23:03.690
我们的整个代码清理了一个

00:22:58.290 --> 00:23:06.000
一点点，我们去了那里，那是

00:23:03.690 --> 00:23:09.929
保留处理程序，其余控制器

00:23:06.000 --> 00:23:11.040
所有的仓库都在这里

00:23:09.929 --> 00:23:13.380
简单的应用程序，让我们继续前进， 

00:23:11.040 --> 00:23:15.960
运行这个好吧，让我们继续运行

00:23:13.380 --> 00:23:18.630
这个应用程序，你可以看到我已经

00:23:15.960 --> 00:23:20.040
到这里启动仪表板，所以

00:23:18.630 --> 00:23:21.720
仪表板正在运行中

00:23:20.040 --> 00:23:23.340
它坐在当地的背景

00:23:21.720 --> 00:23:25.650
我只是去做，我要去

00:23:23.340 --> 00:23:27.360
前进并点击“点击”，我将继续前进

00:23:25.650 --> 00:23:30.000
然后点击运行，它将启动

00:23:27.360 --> 00:23:31.980
应用程序，您知道

00:23:30.000 --> 00:23:33.390
应用程序旋转起来，您可以看到

00:23:31.980 --> 00:23:36.510
在你知道一切都很好的情况下

00:23:33.390 --> 00:23:38.340
在控制台上，我们没有任何

00:23:36.510 --> 00:23:40.200
我实际上没有写任何数据的数据

00:23:38.340 --> 00:23:42.750
这里的数据库，所以也许我应该

00:23:40.200 --> 00:23:45.390
创建一些代码以编写一些示例

00:23:42.750 --> 00:23:51.679
数据到数据库，所以我将创建一个

00:23:45.390 --> 00:23:54.559
初始化程序将实现

00:23:51.679 --> 00:23:57.090
应用程序运行或回调接口

00:23:54.559 --> 00:24:01.800
他们回叫亚军申请

00:23:57.090 --> 00:24:06.780
跑步者回调界面是 Spring 

00:24:01.800 --> 00:24:09.090
引导，并以一种类型，而我要

00:24:06.780 --> 00:24:10.179
进口增加失业

00:24:09.090 --> 00:24:11.789
方法然后

00:24:10.179 --> 00:24:14.769
当应用程序启动时，我要

00:24:11.789 --> 00:24:20.529
在此处注入预订存储库

00:24:14.769 --> 00:24:21.730
我们将看到这样的回购， 

00:24:20.529 --> 00:24:25.360
只是将其提供给

00:24:21.730 --> 00:24:26.740
构造函数和以前一样，您可以

00:24:25.360 --> 00:24:30.340
在我做的时候在底部看到

00:24:26.740 --> 00:24:32.259
更改我的代码Spring 正在重新启动

00:24:30.340 --> 00:24:33.639
只是自动尝试重新加载

00:24:32.259 --> 00:24:35.379
当然，更改代码有时是

00:24:33.639 --> 00:24:36.999
失败，所以我们得到这些你知道

00:24:35.379 --> 00:24:39.249
那里难看的错误，但是没关系

00:24:36.999 --> 00:24:41.470
那就是你知道那是没有编译的

00:24:39.249 --> 00:24:42.820
代码，因此有时在某些情况下不起作用

00:24:41.470 --> 00:24:44.710
它确实可以编译运行并且可以正常工作

00:24:42.820 --> 00:24:52.179
很好，所以我在这里写一些

00:24:44.710 --> 00:24:56.379
约会，我要说的是公元前

00:24:52.179 --> 00:25:01.320
我要把每个名字都映射到一个新名字

00:24:56.379 --> 00:25:06.279
您知道ID名称的预订，以及

00:25:01.320 --> 00:25:11.559
然后将平面图保存到

00:25:06.279 --> 00:25:16.210
这个仓库点保存我们的，然后那个

00:25:11.559 --> 00:25:17.409
产生一个实际上会

00:25:16.210 --> 00:25:20.230
今天保存数据，实际上你知道

00:25:17.409 --> 00:25:25.990
更好，但我会在那里订阅

00:25:20.230 --> 00:25:27.129
订阅好，所以有我的有我的

00:25:25.990 --> 00:25:29.950
整个事情都会写数据

00:25:27.129 --> 00:25:35.950
到数据库中，您实际上知道什么

00:25:29.950 --> 00:25:45.840
打赌，我将其保留为平面图，然后

00:25:35.950 --> 00:25:45.840
说点订阅我们的系统好

00:25:47.879 --> 00:25:56.440
保留字符串在那里我们去

00:25:55.029 --> 00:25:57.879
有我的应用程序启动了

00:25:56.440 --> 00:25:59.590
马上有结果

00:25:57.879 --> 00:26:01.299
控制台，这样就可以了，我们可以

00:25:59.590 --> 00:26:03.519
看到我们的简单代码是

00:26:01.299 --> 00:26:05.559
启动应用程序时正常工作

00:26:03.519 --> 00:26:11.740
发生一件有趣的事情，让我们开始吧

00:26:05.559 --> 00:26:14.649
并关闭所有其他标签

00:26:11.740 --> 00:26:16.960
当我开始一些我的

00:26:14.649 --> 00:26:19.419
应用程序在某些方面变成绿色的伊恩

00:26:16.960 --> 00:26:23.649
你在哪里看到 spring tool suite 

00:26:19.419 --> 00:26:24.370
专注于开发时间

00:26:23.649 --> 00:26:25.780
验证，因为

00:26:24.370 --> 00:26:29.350
真的 Spring 只是Java对吧

00:26:25.780 --> 00:26:32.590
不需要什么-什么都没有

00:26:29.350 --> 00:26:35.230
不仅仅是编译器，而且您知道您的

00:26:32.590 --> 00:26:37.930
您对API的理解是

00:26:35.230 --> 00:26:40.960
真的在这里指导您

00:26:37.930 --> 00:26:43.059
运行时产生的运行时

00:26:40.960 --> 00:26:45.190
该应用程序的行为是

00:26:43.059 --> 00:26:46.690
完全由 Spring 决定，所以

00:26:45.190 --> 00:26:49.059
不像我们可以做的静态分析

00:26:46.690 --> 00:26:50.860
那将没有重新实现

00:26:49.059 --> 00:26:51.610
 Spring 的ID没有意义

00:26:50.860 --> 00:26:53.980
要么这样做

00:26:51.610 --> 00:26:55.720
所以 Spring 发出了信息

00:26:53.980 --> 00:26:57.790
关于其正在运行的应用程序以及

00:26:55.720 --> 00:26:59.530
信息反馈到IDE中，因此

00:26:57.790 --> 00:27:02.380
您可以在这里看到这种

00:26:59.530 --> 00:27:03.640
不同的小绿色亮点

00:27:02.380 --> 00:27:05.890
类型和不同的事物

00:27:03.640 --> 00:27:08.050
您可以查看应用程序，例如

00:27:05.890 --> 00:27:10.840
您将鼠标悬停在组件上会向我显示

00:27:08.050 --> 00:27:13.780
这是一个beans，就是

00:27:10.840 --> 00:27:15.250
称为初始化器的bean的ID是

00:27:13.780 --> 00:27:18.010
称为初始化程序，它在此运行

00:27:15.250 --> 00:27:19.960
过程，这是一个范围

00:27:18.010 --> 00:27:22.150
让我们在这个基于类的内部找到它

00:27:19.960 --> 00:27:24.760
在此配置类中，我们可以看到

00:27:22.150 --> 00:27:27.730
这是生活在里面的beans

00:27:24.760 --> 00:27:29.500
您知道的预订存储库类型

00:27:27.730 --> 00:27:32.490
很抱歉，我们可以看到

00:27:29.500 --> 00:27:35.890
依赖关系在这里用箭头是

00:27:32.490 --> 00:27:36.970
将bean注入初始化程序

00:27:35.890 --> 00:27:38.740
本身称为保留

00:27:36.970 --> 00:27:40.390
预订存储库，但它位于

00:27:38.740 --> 00:27:41.470
这种类型，这很有趣

00:27:40.390 --> 00:27:43.059
在这里，这些箭头非常

00:27:41.470 --> 00:27:45.340
在秋千工具中很有趣

00:27:43.059 --> 00:27:48.570
给我们它说的依赖图

00:27:45.340 --> 00:27:50.650
这是我的路线，我通往 bean 的路线

00:27:48.570 --> 00:27:52.990
取决于处理程序，这就是

00:27:50.650 --> 00:27:55.200
左箭头表示这意味着

00:27:52.990 --> 00:27:57.309
水印所在的东西

00:27:55.200 --> 00:27:59.080
取决于水印中的东西

00:27:57.309 --> 00:28:02.650
初始化程序取决于

00:27:59.080 --> 00:28:05.710
预约预约仓库去

00:28:02.650 --> 00:28:06.880
另一种方式，我们可以看到哦， 

00:28:05.710 --> 00:28:08.410
还有另一个例子

00:28:06.880 --> 00:28:13.840
路由器功能和我的预订

00:28:08.410 --> 00:28:20.230
仓库都取决于对不起我

00:28:13.840 --> 00:28:22.510
保留处理程序取决于

00:28:20.230 --> 00:28:24.400
保留资料库，但我的路由器

00:28:22.510 --> 00:28:26.590
功能取决于预约

00:28:24.400 --> 00:28:29.950
处理程序，所以这就是

00:28:26.590 --> 00:28:32.350
取决于这个对象，这是

00:28:29.950 --> 00:28:34.780
注入这个物体的东西

00:28:32.350 --> 00:28:36.860
因为这取决于他们好，所以两者

00:28:34.780 --> 00:28:38.600
方向对我

00:28:36.860 --> 00:28:40.130
这取决于我的预订处理程序

00:28:38.600 --> 00:28:42.799
这意味着我们的预订处理程序

00:28:40.130 --> 00:28:44.510
取决于它好吗

00:28:42.799 --> 00:28:47.900
我们在运行时也有反馈

00:28:44.510 --> 00:28:49.610
关于此映射的URL 

00:28:47.900 --> 00:28:51.799
所以我可以将鼠标悬停在上面，说是的

00:28:49.610 --> 00:28:54.200
我要去本地主机8080 

00:28:51.799 --> 00:28:58.130
现在可以预定

00:28:54.200 --> 00:29:00.290
可以肯定地看到这个端点

00:28:58.130 --> 00:29:02.570
是的，当我单击

00:29:00.290 --> 00:29:04.429
我可以看到那里的所有数据

00:29:02.570 --> 00:29:06.740
我写了几笔唱片

00:29:04.429 --> 00:29:08.059
在过去的几天里， 

00:29:06.740 --> 00:29:10.600
同一点，所以我们知道那是

00:29:08.059 --> 00:29:15.559
工作正常

00:29:10.600 --> 00:29:17.570
现在我已经看到了这些端点

00:29:15.559 --> 00:29:18.770
在这里看到了导航

00:29:17.570 --> 00:29:23.720
几个不同的端点不是吗

00:29:18.770 --> 00:29:27.320
我有终点

00:29:23.720 --> 00:29:28.820
该处理程序在此处定义的

00:29:27.320 --> 00:29:32.480
如果我这样做的逻辑是在处理程序中

00:29:28.820 --> 00:29:34.250
点击，我可以看到你知道

00:29:32.480 --> 00:29:37.669
该端点正在提供业务

00:29:34.250 --> 00:29:41.360
如果我公开给你，对我来说就是逻辑

00:29:37.669 --> 00:29:43.100
知道我们也可以看到它说

00:29:41.360 --> 00:29:44.240
这是您知道的端点

00:29:43.100 --> 00:29:46.520
实际上给我看了映射注解

00:29:44.240 --> 00:29:49.340
如果我也将其公开，那就是

00:29:46.520 --> 00:29:50.840
非常方便，我得到你知道的我

00:29:49.340 --> 00:29:53.840
有能力看到这个

00:29:50.840 --> 00:29:55.700
端点是此端点存在的URI 

00:29:53.840 --> 00:29:57.440
在什么时候以及什么时候您或我

00:29:55.700 --> 00:29:58.910
端点安装基本上是

00:29:57.440 --> 00:30:01.010
安装在四个窗扇上

00:29:58.910 --> 00:30:03.559
窗框ID和响应阶段

00:30:01.010 --> 00:30:04.850
那很好，因为我的经理非常

00:30:03.559 --> 00:30:08.559
可能会住在单独的代码页中

00:30:04.850 --> 00:30:11.660
举例来说，我完全可以

00:30:08.559 --> 00:30:15.559
命令T并将其移动到新

00:30:11.660 --> 00:30:18.350
键入文件，写一个新文件，当我这样做

00:30:15.559 --> 00:30:19.610
你知道一切都知道

00:30:18.350 --> 00:30:23.090
从语义上讲，这就是

00:30:19.610 --> 00:30:25.220
完全一样，但是我的请求映射

00:30:23.090 --> 00:30:26.390
找不到路由逻辑

00:30:25.220 --> 00:30:27.590
它在单独的代码页中

00:30:26.390 --> 00:30:29.059
在一起，所以很好，我不必

00:30:27.590 --> 00:30:31.280
在两者之间来回切换

00:30:29.059 --> 00:30:32.570
不同的代码页，看到这是

00:30:31.280 --> 00:30:37.610
安装在进行测试预订

00:30:32.570 --> 00:30:41.179
触摸ID，我可以导航

00:30:37.610 --> 00:30:43.429
我可以很容易地说出命令六，如果

00:30:41.179 --> 00:30:46.100
我说例如add命令或

00:30:43.429 --> 00:30:47.330
在组件上的符号处显示给我

00:30:46.100 --> 00:30:49.900
一切都用添加来注释

00:30:47.330 --> 00:30:51.400
组件以及此meta中的所有内容

00:30:49.900 --> 00:30:53.830
与该组件的传递

00:30:51.400 --> 00:30:54.910
预订处理程序预订示例

00:30:53.830 --> 00:30:56.290
 rest controller 本身

00:30:54.910 --> 00:30:57.520
带有地址控制器的注释

00:30:56.290 --> 00:30:58.900
本身用那个控制器注释

00:30:57.520 --> 00:31:00.790
这本身就是注释

00:30:58.900 --> 00:31:02.290
零件预定服务

00:31:00.790 --> 00:31:04.000
应用程序用Springwood注释

00:31:02.290 --> 00:31:05.440
注释Spring 的应用程序

00:31:04.000 --> 00:31:06.760
带有注释的启动配置

00:31:05.440 --> 00:31:08.440
带有注释的配置

00:31:06.760 --> 00:31:10.750
组件，这样您就可以看到

00:31:08.440 --> 00:31:12.760
真正有趣的可导航性

00:31:10.750 --> 00:31:14.890
在这里，我可以单击它，它将

00:31:12.760 --> 00:31:16.960
带我到代码页

00:31:14.890 --> 00:31:18.850
如果我再次执行命令6 

00:31:16.960 --> 00:31:20.950
并向前斜线显示所有

00:31:18.850 --> 00:31:22.870
在此可用的URL 

00:31:20.950 --> 00:31:24.730
申请权，是我点击

00:31:22.870 --> 00:31:25.960
他们，我可以看到他们的行动，所以我

00:31:24.730 --> 00:31:27.970
有这个非常好的导航

00:31:25.960 --> 00:31:30.730
应用程序本身的可导航性

00:31:27.970 --> 00:31:33.430
而这一切都是基于这种

00:31:30.730 --> 00:31:36.550
spring tool的运行时意识

00:31:33.430 --> 00:31:38.170
套房4对我来说好吧，现在我喜欢我的

00:31:36.550 --> 00:31:40.840
应用程序肯定很简单

00:31:38.170 --> 00:31:42.970
说我想要的应用程序

00:31:40.840 --> 00:31:44.590
在生产中运行它，我正在运行

00:31:42.970 --> 00:31:47.560
在我的本地计算机上，您会发现它多么容易

00:31:44.590 --> 00:31:48.910
是开始和停止，然后做所有

00:31:47.560 --> 00:31:50.260
这些事情，但我想

00:31:48.910 --> 00:31:52.200
我要做的是将其实际部署到

00:31:50.260 --> 00:31:54.490
 Cloud Foundry现在可以使用

00:31:52.200 --> 00:31:56.140
平台是开源的服务

00:31:54.490 --> 00:31:58.660
我要连接两个关键网络

00:31:56.140 --> 00:32:00.430
多租户托管的服务

00:31:58.660 --> 00:32:04.390
运行中的云实例

00:32:00.430 --> 00:32:05.950
默认情况下，东部地区的亚马逊和

00:32:04.390 --> 00:32:07.480
我要将此应用程序部署到它

00:32:05.950 --> 00:32:08.770
我将能够看到什么

00:32:07.480 --> 00:32:10.900
它是从那里做的，所以我已经

00:32:08.770 --> 00:32:12.700
有一个Cloud Foundry目标

00:32:10.900 --> 00:32:14.590
要做的就是单击加号单击

00:32:12.700 --> 00:32:16.180
 Cloud Foundry目标填写表格

00:32:14.590 --> 00:32:18.400
您知道电子邮件密码

00:32:16.180 --> 00:32:20.140
您关心的事情

00:32:18.400 --> 00:32:22.660
例如您的卡平台

00:32:20.140 --> 00:32:25.960
您已经注册了一个帐户，而我

00:32:22.660 --> 00:32:27.520
我想现在就播放应用程序

00:32:25.960 --> 00:32:29.110
知道我还记得那件事

00:32:27.520 --> 00:32:30.850
记住默认的命令移位是

00:32:29.110 --> 00:32:31.900
会告诉我适当的资源， 

00:32:30.850 --> 00:32:36.100
打开我的财产文件

00:32:31.900 --> 00:32:41.620
我在这里没有配置

00:32:36.100 --> 00:32:47.190
说 Spring ，蒙哥蒙哥点点什么

00:32:41.620 --> 00:32:50.290
是的，我还没有指定Mongo 

00:32:47.190 --> 00:32:51.850
任何东西，所以我还没有指定日志记录

00:32:50.290 --> 00:32:54.670
我可以指定各种各样的东西

00:32:51.850 --> 00:33:01.030
可以指定服务器点端口权限

00:32:54.670 --> 00:33:03.250
您知道该端口的服务器

00:33:01.030 --> 00:33:05.410
例如，端口等于t10 

00:33:03.250 --> 00:33:07.270
如果我点击保存，将重新启动

00:33:05.410 --> 00:33:09.820
应用程序，现在该应用程序

00:33:07.270 --> 00:33:11.320
在端口80 10上旋转，这样我可以

00:33:09.820 --> 00:33:13.930
带有此属性的各种事物

00:33:11.320 --> 00:33:15.940
文件，您可以看到该spring tool

00:33:13.930 --> 00:33:17.590
套件真的很聪明，它告诉我

00:33:15.940 --> 00:33:19.390
我的不同配置值

00:33:17.590 --> 00:33:21.220
可以用来改变他们建立了

00:33:19.390 --> 00:33:23.890
说我还没有的申请

00:33:21.220 --> 00:33:25.690
指定了MongoDB URL，但我不想

00:33:23.890 --> 00:33:27.400
在我本地开发的机器上

00:33:25.690 --> 00:33:29.620
它工作正常，我不需要

00:33:27.400 --> 00:33:33.040
指定URL，但是当我将其连接到

00:33:29.620 --> 00:33:34.660
关于Cloud Foundry的信息

00:33:33.040 --> 00:33:37.150
我如何才能将其连接到

00:33:34.660 --> 00:33:38.980
将被埋在MongoDB中

00:33:37.150 --> 00:33:41.110
环境中的环境变量

00:33:38.980 --> 00:33:42.670
平台中的运行过程

00:33:41.110 --> 00:33:44.170
这些环境变量被打开

00:33:42.670 --> 00:33:45.730
变成我可见的属性

00:33:44.170 --> 00:33:47.440
当他们使用Springwood应用程序时

00:33:45.730 --> 00:33:50.050
在Cloud Foundry中运行，所以我需要

00:33:47.440 --> 00:33:52.420
要做的是我要告诉 Spring 嘿

00:33:50.050 --> 00:33:54.040
是一些只会用的配置

00:33:52.420 --> 00:33:55.990
在您运行时可用

00:33:54.040 --> 00:33:58.030
卡注资，否则只需使用

00:33:55.990 --> 00:34:00.100
默认配置

00:33:58.030 --> 00:34:01.300
配置，那么我们要去

00:34:00.100 --> 00:34:03.280
分开我要去逗它

00:34:01.300 --> 00:34:06.070
通过使用远离其他代码

00:34:03.280 --> 00:34:08.050
个人资料只是个人资料的标签

00:34:06.070 --> 00:34:09.700
标签，我可以对对象执行此操作

00:34:08.050 --> 00:34:12.669
对于配置，我可以例如去

00:34:09.700 --> 00:34:17.790
在这里说这是一个光束

00:34:12.669 --> 00:34:21.179
在您知道的演示下

00:34:17.790 --> 00:34:25.179
个人资料正确，所以我说添加个人资料， 

00:34:21.179 --> 00:34:26.770
弹跳井自动使该光束

00:34:25.179 --> 00:34:29.139
不存在，所以如果我重新启动

00:34:26.770 --> 00:34:30.700
现在，您可以看到

00:34:29.139 --> 00:34:32.139
现在重新启动，只是重新启动

00:34:30.700 --> 00:34:34.330
自动，因为我有开发人员

00:34:32.139 --> 00:34:35.919
工具没有在控制台上登录的权利

00:34:34.330 --> 00:34:37.690
那里什么都没有，因为我没有

00:34:35.919 --> 00:34:40.419
明确激活此个人资料并

00:34:37.690 --> 00:34:42.550
因为我没有做到这一点

00:34:40.419 --> 00:34:44.230
实际上不存在，为什么你会

00:34:42.550 --> 00:34:45.429
想要这样的事情再想像

00:34:44.230 --> 00:34:46.270
没想到你正在做那种

00:34:45.429 --> 00:34:47.590
我正在做的事我会采取

00:34:46.270 --> 00:34:49.629
开发环境工件和

00:34:47.590 --> 00:34:53.350
推广到生产环境我

00:34:49.629 --> 00:34:56.800
不想我的本地主机名和

00:34:53.350 --> 00:34:58.450
您知道用来尝试输入的密码

00:34:56.800 --> 00:34:59.980
与生产数据库交谈， 

00:34:58.450 --> 00:35:02.170
同样，我不要我的作品

00:34:59.980 --> 00:35:03.310
代码中埋藏的数据库凭据

00:35:02.170 --> 00:35:04.480
所以我可能想单独订一套

00:35:03.310 --> 00:35:07.020
绘制其配置的

00:35:04.480 --> 00:35:09.340
来自外部来源的配置

00:35:07.020 --> 00:35:10.780
好吧，我可以为对象做这些，我

00:35:09.340 --> 00:35:12.280
也无法为此配置文件执行此操作

00:35:10.780 --> 00:35:15.040
我给你看了属性文件

00:35:12.280 --> 00:35:16.000
叫应用程序属性，所以我

00:35:15.040 --> 00:35:16.780
要做那我要去来源

00:35:16.000 --> 00:35:18.960
主要资源

00:35:16.780 --> 00:35:27.180
我将创建一个名为

00:35:18.960 --> 00:35:29.470
应用程序-云点属性和

00:35:27.180 --> 00:35:31.359
我要给它一个非常具体的

00:35:29.470 --> 00:35:34.270
这里的配置我要说的是猫

00:35:31.359 --> 00:35:35.349
桌面应用程序使属性模糊

00:35:34.270 --> 00:35:38.200
我将其复制到

00:35:35.349 --> 00:35:40.540
剪贴板并粘贴Spring 数据

00:35:38.200 --> 00:35:43.300
其中将成为你我等于

00:35:40.540 --> 00:35:44.859
引用MongoDB的属性

00:35:43.300 --> 00:35:46.960
我给了逻辑名的实例

00:35:44.859 --> 00:35:49.599
叫我的MongoDB在

00:35:46.960 --> 00:35:51.280
只能访问的平台

00:35:49.599 --> 00:35:54.790
该属性文件将仅处于活动状态

00:35:51.280 --> 00:35:57.280
当云配置文件处于活动状态时， 

00:35:54.790 --> 00:36:00.579
为了使它活跃起来，我们需要

00:35:57.280 --> 00:36:06.960
创建一个Cloud Foundry清单

00:36:00.579 --> 00:36:06.960
我要在这里做

00:36:07.680 --> 00:36:16.450
明显的点黄色粘贴所有

00:36:14.050 --> 00:36:18.160
好吧，我有一个环境

00:36:16.450 --> 00:36:19.450
会告诉spring的变量

00:36:18.160 --> 00:36:21.069
告诉Cloud Foundry就让我走

00:36:19.450 --> 00:36:23.260
并创建MongoDB实例

00:36:21.069 --> 00:36:24.040
我只是说继续吧

00:36:23.260 --> 00:36:26.530
我要使用环境变量

00:36:24.040 --> 00:36:28.990
这里的Spring 型材主动式 spring boot 

00:36:26.530 --> 00:36:30.160
自动将其标准化，以便 Spring 

00:36:28.990 --> 00:36:33.490
开机会将它变成小写

00:36:30.160 --> 00:36:35.140
Spring 点轮廓点活动所有

00:36:33.490 --> 00:36:37.569
小写，该值将等于

00:36:35.140 --> 00:36:38.710
云，所以我要说的是云基金

00:36:37.569 --> 00:36:42.220
我是说继续部署我的

00:36:38.710 --> 00:36:45.190
随心所欲的申请

00:36:42.220 --> 00:36:46.630
 Spring 告诉它设置这些

00:36:45.190 --> 00:36:48.190
运行的环境变量

00:36:46.630 --> 00:36:49.660
应用程序的行为

00:36:48.190 --> 00:36:52.030
稍有不同，因此配置文件

00:36:49.660 --> 00:36:54.250
所谓的云是活跃的，因此

00:36:52.030 --> 00:36:55.720
它将在

00:36:54.250 --> 00:36:56.800
除了现有的应用

00:36:55.720 --> 00:36:59.349
属性并将其绘制到

00:36:56.800 --> 00:37:01.390
环境并以此来告知

00:36:59.349 --> 00:37:05.020
查找MongoDB实例，并

00:37:01.390 --> 00:37:06.550
然后最后我告诉它绑定

00:37:05.020 --> 00:37:09.700
已经准备好了吗

00:37:06.550 --> 00:37:12.099
实例以使该实例可见

00:37:09.700 --> 00:37:13.960
到正在运行的应用程序，以便我可以

00:37:12.099 --> 00:37:15.849
连接到它会把连接

00:37:13.960 --> 00:37:17.470
凭据所有此类内容

00:37:15.849 --> 00:37:19.150
环境，我要用它

00:37:17.470 --> 00:37:22.599
连接到那就是那个

00:37:19.150 --> 00:37:24.940
属性告诉MongoDB可以做

00:37:22.599 --> 00:37:26.710
所以现在在那里，这就是你知道我在

00:37:24.940 --> 00:37:28.480
使用spring工具套件

00:37:26.710 --> 00:37:31.060
一些非常好的配置支持

00:37:28.480 --> 00:37:33.160
在这里我可以自定义我想要的一切

00:37:31.060 --> 00:37:35.320
关于使用此ayat的应用程序' 

00:37:33.160 --> 00:37:37.330
这个工具，但是你知道我已经有了

00:37:35.320 --> 00:37:38.500
一件事很好，一件事是

00:37:37.330 --> 00:37:40.000
仁慈的眼睛是如果我不知道名字

00:37:38.500 --> 00:37:41.590
的服务，到位的我

00:37:40.000 --> 00:37:43.630
可以拥有控制空间，它将

00:37:41.590 --> 00:37:45.700
告诉我所有不同的可连接性

00:37:43.630 --> 00:37:48.790
支持服务，包括Maya MongoDB 

00:37:45.700 --> 00:37:50.920
例如，就可以了

00:37:48.790 --> 00:37:53.200
我在这里有Cloud Foundry 

00:37:50.920 --> 00:37:54.520
我的应用程序将其拖到购物车上

00:37:53.200 --> 00:37:56.310
渲染正确，它会说你

00:37:54.520 --> 00:37:58.150
想用这个清单我会说

00:37:56.310 --> 00:38:00.370
绝对

00:37:58.150 --> 00:38:02.980
我要启用的JMX SSH隧道

00:38:00.370 --> 00:38:05.490
可能对以后的调试很有用，并且

00:38:02.980 --> 00:38:05.490
我去了

00:38:11.200 --> 00:38:13.260
您

00:38:24.880 --> 00:38:28.850
所以这里有应用程序

00:38:27.110 --> 00:38:31.190
它启动了，您可以看到输出为

00:38:28.850 --> 00:38:32.750
它显示在服务器本身中

00:38:31.190 --> 00:38:35.330
 Cloud Foundry就在这里

00:38:32.750 --> 00:38:40.970
如果我回到我的应用程序

00:38:35.330 --> 00:38:43.850
例如，这里我可以使用应用程序代码

00:38:40.970 --> 00:38:46.250
不仅看到的本地版本

00:38:43.850 --> 00:38:47.660
端点，现在还有URL 

00:38:46.250 --> 00:38:50.570
运行Cloud Foundry的应用程序

00:38:47.660 --> 00:38:52.490
 HTTP Co spring cff star IO等

00:38:50.570 --> 00:38:55.880
告诉我数据没有那么酷

00:38:52.490 --> 00:38:58.070
 II现在从双方获得即时反馈

00:38:55.880 --> 00:38:59.540
我可以在本地和我的云环境中

00:38:58.070 --> 00:39:01.220
做诸如调试之类的事情

00:38:59.540 --> 00:39:04.100
我可以管理很多事情

00:39:01.220 --> 00:39:06.740
来自不同的正在运行的应用程序

00:39:04.100 --> 00:39:08.300
启动仪表板，您可以获得所有这些

00:39:06.740 --> 00:39:10.610
自由权，你就得到这一切

00:39:08.300 --> 00:39:14.390
我能做的ID体验很好

00:39:10.610 --> 00:39:15.980
编写软件测试调试连接

00:39:14.390 --> 00:39:17.119
安装到云平台

00:39:15.980 --> 00:39:18.230
跑步，看看它的样子等等

00:39:17.119 --> 00:39:22.280
上

00:39:18.230 --> 00:39:24.320
摆动工具套件，您知道的是

00:39:22.280 --> 00:39:26.540
非常引人注目，因为它给了我一个

00:39:24.320 --> 00:39:29.540
一站式商店，我可以在其中创建新商品

00:39:26.540 --> 00:39:31.640
我可以使用它编写代码的项目

00:39:29.540 --> 00:39:34.850
使用世界一流的Java编辑器和

00:39:31.640 --> 00:39:36.830
调试器等，我获得了明智的见解

00:39:34.850 --> 00:39:39.170
自动完成时，例如

00:39:36.830 --> 00:39:42.130
 Java和诸如我的财产之类的东西

00:39:39.170 --> 00:39:44.240
文件和我的鳕鱼资金清单证明我得到了

00:39:42.130 --> 00:39:46.190
关于正在运行的应用程序的见解

00:39:44.240 --> 00:39:47.960
这是唯一真正准确的

00:39:46.190 --> 00:39:49.369
信息正确，没有错误

00:39:47.960 --> 00:39:50.750
积极在这里，您正在获得反馈

00:39:49.369 --> 00:39:52.760
关于正在运行的应用程序以及

00:39:50.750 --> 00:39:55.040
没什么不告诉你的

00:39:52.760 --> 00:39:56.480
不会尝试并再次猜测

00:39:55.040 --> 00:39:59.270
 Spring 已经建立的元模型

00:39:56.480 --> 00:40:01.310
准备好运行对象筏

00:39:59.270 --> 00:40:03.680
它只是直接基于

00:40:01.310 --> 00:40:06.080
正在运行的帮助应用程序本身

00:40:03.680 --> 00:40:09.530
可以看到导航可导航性是

00:40:06.080 --> 00:40:11.420
正确的关键，所以如果我向前斜杠

00:40:09.530 --> 00:40:13.160
显示给我的不仅仅是我的本地主机

00:40:11.420 --> 00:40:14.450
端点，还有我的云代工厂

00:40:13.160 --> 00:40:15.560
正确的端点是

00:40:14.450 --> 00:40:18.109
我也将其部署在云中

00:40:15.560 --> 00:40:20.930
通过前进就拥有所有这些

00:40:18.109 --> 00:40:22.490
斜线正斜杠，你知道是

00:40:20.930 --> 00:40:24.080
真的是你的钥匙，我会告诉你

00:40:22.490 --> 00:40:26.030
各种各样有趣的事情

00:40:24.080 --> 00:40:27.470
你可以做的和应用程序这样

00:40:26.030 --> 00:40:31.400
再次只是很多非常有趣

00:40:27.470 --> 00:40:32.660
我会说的发现的东西

00:40:31.400 --> 00:40:34.580
我认为那是真正的

00:40:32.660 --> 00:40:36.420
引人注目的功能是您

00:40:34.580 --> 00:40:38.700
知道任何人都可以制造汽车

00:40:36.420 --> 00:40:39.900
和Java IDE，这时

00:40:38.700 --> 00:40:41.610
各种不同的工具

00:40:39.900 --> 00:40:42.840
是为此而设计的

00:40:41.610 --> 00:40:44.940
建立企业出色的应用程序

00:40:42.840 --> 00:40:45.900
那些连接到

00:40:44.940 --> 00:40:47.910
他们面向的生产

00:40:45.900 --> 00:40:50.490
足够大的产品

00:40:47.910 --> 00:40:51.840
变得有点笨拙

00:40:50.490 --> 00:40:53.640
从一个快速导航的能力

00:40:51.840 --> 00:40:55.140
事情到另一个，看看它取决于什么

00:40:53.640 --> 00:40:58.500
另一方面，事物如何相互作用

00:40:55.140 --> 00:41:00.120
我认为是一个不同的射手，所以

00:40:58.500 --> 00:41:02.100
我的朋友们，我们已经建立了一个非常

00:41:00.120 --> 00:41:04.530
我们已经构建了一个简单的应用程序

00:41:02.100 --> 00:41:06.750
具有反应式Web的应用程序

00:41:04.530 --> 00:41:09.690
端点和一些反应式数据访问

00:41:06.750 --> 00:41:12.420
我们使用了开发工具来支持实时

00:41:09.690 --> 00:41:15.150
重新加载并支持您知道

00:41:12.420 --> 00:41:18.060
洞察应用程序，我们也

00:41:15.150 --> 00:41:19.860
二手Lum对不起，执行器

00:41:18.060 --> 00:41:21.300
一组添加到

00:41:19.860 --> 00:41:23.520
自动为我们申请

00:41:21.300 --> 00:41:25.230
在以下位置可见执行器信息

00:41:23.520 --> 00:41:26.850
云铸造厂，然后反馈

00:41:25.230 --> 00:41:29.010
您在这里看到的见解

00:41:26.850 --> 00:41:30.150
这就是为什么这些URL反映了什么

00:41:29.010 --> 00:41:32.190
发生在袖扣中是因为

00:41:30.150 --> 00:41:33.540
如果资金本身，云内部的执行器

00:41:32.190 --> 00:41:35.370
你去云供应商的应用程序经理

00:41:33.540 --> 00:41:37.530
它还会向您显示信息

00:41:35.370 --> 00:41:39.300
受够了你知道

00:41:37.530 --> 00:41:41.010
从执行器端点排出

00:41:39.300 --> 00:41:42.330
应用程序本身就会浮出水面

00:41:41.010 --> 00:41:44.490
在一块玻璃中

00:41:42.330 --> 00:41:46.980
非常重要的是一块玻璃或

00:41:44.490 --> 00:41:49.110
云中的仪表板体验

00:41:46.980 --> 00:41:50.160
待定的应用程序经理，因此您可以获得很多

00:41:49.110 --> 00:41:51.990
重视其中，我们当然

00:41:50.160 --> 00:41:53.850
构建一个反应式Web应用程序，我们

00:41:51.990 --> 00:41:55.500
可以访问数据我们没有写的是

00:41:53.850 --> 00:41:57.120
几乎和我们在哪里一样重要

00:41:55.500 --> 00:41:59.940
我们说对了，我们没有写的是

00:41:57.120 --> 00:42:01.920
代码还是我们也不必关心

00:41:59.940 --> 00:42:04.020
与部署或

00:42:01.920 --> 00:42:05.790
管理我们的服务器，更不用说反应式

00:42:04.020 --> 00:42:07.860
基于Neddie的服务器

00:42:05.790 --> 00:42:10.230
这是Neddie在印度开始的港口

00:42:07.860 --> 00:42:12.330
 -快速而异步

00:42:10.230 --> 00:42:15.860
高效，我们不用担心

00:42:12.330 --> 00:42:18.030
连接到我们担心的MongoDB 

00:42:15.860 --> 00:42:20.610
做任何事情，实际上我们只是写了

00:42:18.030 --> 00:42:22.350
与我们业务相关的代码

00:42:20.610 --> 00:42:24.120
需求，我们写的代码是

00:42:22.350 --> 00:42:26.250
可测试的，所以我当然不是

00:42:24.120 --> 00:42:28.620
触及了这个视频中的测试

00:42:26.250 --> 00:42:30.810
但是所有这些代码都被编写了

00:42:28.620 --> 00:42:32.250
使用构造函数注入意味着

00:42:30.810 --> 00:42:34.320
我可以提供合作对象

00:42:32.250 --> 00:42:35.940
如果愿意，可以使用模拟游戏

00:42:34.320 --> 00:42:37.470
例如初始化器或仅

00:42:35.940 --> 00:42:39.900
预订 rest controller 

00:42:37.470 --> 00:42:42.180
隔离，因此您可以通过编写来获得所有这些

00:42:39.900 --> 00:42:46.740
干净的面向对象代码非常

00:42:42.180 --> 00:42:49.359
容易提取东西-重构

00:42:46.740 --> 00:42:52.059
我用的ID里的东西哦

00:42:49.359 --> 00:42:54.880
命令T，我要命令s 

00:42:52.059 --> 00:42:56.440
重构和提取，以及

00:42:54.880 --> 00:42:57.759
我可以做的事情和结果

00:42:56.440 --> 00:42:59.680
你知道我可以很快原型

00:42:57.759 --> 00:43:01.269
我会犯错，然后如果我

00:42:59.680 --> 00:43:03.039
达到我感觉像东西的地步

00:43:01.269 --> 00:43:05.890
是稳定的，我可以将它们提取到

00:43:03.039 --> 00:43:08.109
单独的类型，您知道结果

00:43:05.890 --> 00:43:08.979
我认为不言而喻非常感谢

00:43:08.109 --> 00:43:11.160
收看很多，我们下次见

00:43:08.979 --> 00:43:11.160
时间

