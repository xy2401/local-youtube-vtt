WEBVTT
Kind: captions
Language: zh-Hans

00:00:08.880 --> 00:00:14.040
很快我的名字叫Cornelio 

00:00:11.880 --> 00:00:16.740
戴维斯（Davis）我是平台主管

00:00:14.040 --> 00:00:19.590
云铸造的工程，所以我在

00:00:16.740 --> 00:00:21.720
我一直在与我合作

00:00:19.590 --> 00:00:23.310
意识到我已经是九月了

00:00:21.720 --> 00:00:27.600
一直在与Cloud Foundry合作

00:00:23.310 --> 00:00:29.730
大约三年后，我从

00:00:27.600 --> 00:00:32.790
我在公司CTO工作的EMC 

00:00:29.730 --> 00:00:36.030
办公室，我们在那里做新兴技术

00:00:32.790 --> 00:00:38.100
大约三年前， 

00:00:36.030 --> 00:00:40.050
我老板汤姆·马奎尔（Tom Maguire）的一个项目

00:00:38.100 --> 00:00:41.430
当时说嘿，你知道我想要你

00:00:40.050 --> 00:00:45.150
开始看这个新东西

00:00:41.430 --> 00:00:46.800
叫做通行证相对较新，所以我

00:00:45.150 --> 00:00:49.589
开始调查，当然

00:00:46.800 --> 00:00:51.089
我们是EMC，云代工厂是VMware 

00:00:49.589 --> 00:00:54.449
所以我开始研究云代工厂

00:00:51.089 --> 00:00:57.650
然后大约一年前，我加入了云

00:00:54.449 --> 00:01:00.000
我正确地加入了Cloud Foundry团队

00:00:57.650 --> 00:01:02.159
从这个平台工程角色

00:01:00.000 --> 00:01:04.470
平台工程很小

00:01:02.159 --> 00:01:07.799
产品中的工程团队

00:01:04.470 --> 00:01:09.799
团队，但我们面对现场，所以我花了

00:01:07.799 --> 00:01:13.020
我几乎所有的时间都在与

00:01:09.799 --> 00:01:15.750
大型战略客户以及

00:01:13.020 --> 00:01:17.430
合作伙伴有点推波助澜

00:01:15.750 --> 00:01:21.630
与云铸造

00:01:17.430 --> 00:01:23.880
所以绝对动手技术等等

00:01:21.630 --> 00:01:26.210
你会听到很多这样的

00:01:23.880 --> 00:01:29.640
整个演讲过程中的思考

00:01:26.210 --> 00:01:31.439
因此，还介绍了我的同事

00:01:29.640 --> 00:01:35.850
 Josh Kruk和我一起工作于枢纽

00:01:31.439 --> 00:01:37.619
继续吧，我是Josh Kruk II， 

00:01:35.850 --> 00:01:38.880
姐妹队去科妮莉亚的

00:01:37.619 --> 00:01:41.640
客户成功办公室

00:01:38.880 --> 00:01:43.170
我的角色是50％的客户需要帮助

00:01:41.640 --> 00:01:45.299
人们通过Cloud Foundry获得成功

00:01:43.170 --> 00:01:47.149
这就是部署和操作， 

00:01:45.299 --> 00:01:49.079
还有很多应用程序开发你如何

00:01:47.149 --> 00:01:50.880
转换您的应用程序或如何编写

00:01:49.079 --> 00:01:52.890
新应用可以利用

00:01:50.880 --> 00:01:54.509
第三个平台，然后另一个

00:01:52.890 --> 00:01:56.609
我一半的时间也花在了

00:01:54.509 --> 00:01:59.159
产品我的激情那种实用程序

00:01:56.609 --> 00:02:02.039
和围绕云铸造的工具

00:01:59.159 --> 00:02:03.749
制作可在平台上运行的应用程序或

00:02:02.039 --> 00:02:07.649
针对平台本身

00:02:03.749 --> 00:02:09.240
很棒的行动谢谢你

00:02:07.649 --> 00:02:12.090
所以我们想谈谈这个

00:02:09.240 --> 00:02:14.370
早上你已经听到很多声音了

00:02:12.090 --> 00:02:16.110
数以千计的短语cloud native和

00:02:14.370 --> 00:02:19.350
您可能还听过人们的谈话

00:02:16.110 --> 00:02:21.270
大约12个因素的应用程序及其不足之处

00:02:19.350 --> 00:02:22.319
就是我们过去的建造方式

00:02:21.270 --> 00:02:25.739
应用

00:02:22.319 --> 00:02:27.900
在过去的几十年中， 

00:02:25.739 --> 00:02:30.079
真正针对架构进行了优化

00:02:27.900 --> 00:02:32.189
那时候我们曾经有过

00:02:30.079 --> 00:02:34.019
架构从根本上说是

00:02:32.189 --> 00:02:36.659
不一样，所以给你一点

00:02:34.019 --> 00:02:38.430
我一直在为此做一个观点

00:02:36.659 --> 00:02:40.769
很长一段时间我要在这里约会

00:02:38.430 --> 00:02:43.109
但是我已经写了25年的软件

00:02:40.769 --> 00:02:46.230
多年，当我第一次开始时

00:02:43.109 --> 00:02:49.260
在嵌入式系统中，我编译了

00:02:46.230 --> 00:02:52.129
写了代码，我什至是C甚至是DES 

00:02:49.260 --> 00:02:55.889
我当时在国防行业

00:02:52.129 --> 00:02:57.930
我们所做的最复杂的事情

00:02:55.889 --> 00:02:59.669
是我们也许我们交叉编译了，所以我

00:02:57.930 --> 00:03:01.409
在一台机器上编译并接受

00:02:59.669 --> 00:03:04.319
二进制文件并在另一台计算机上运行它们

00:03:01.409 --> 00:03:06.060
所以没有内在的东西

00:03:04.319 --> 00:03:09.239
分散，我也记得

00:03:06.060 --> 00:03:12.299
实际上我们有一个项目

00:03:09.239 --> 00:03:14.219
有三个处理器，我们实际上有

00:03:12.299 --> 00:03:15.900
我们画出了什么的白板

00:03:14.219 --> 00:03:18.030
发生在不同的处理器上

00:03:15.900 --> 00:03:19.709
以及我们如何超时多长时间

00:03:18.030 --> 00:03:21.120
打算去哪里

00:03:19.709 --> 00:03:24.180
交接将是非常

00:03:21.120 --> 00:03:26.939
静态的，它非常非常僵硬， 

00:03:24.180 --> 00:03:28.769
现在一切都散布了，所以

00:03:26.939 --> 00:03:31.109
这些我们拥有的手机

00:03:28.769 --> 00:03:32.759
甚至不存在云不存在

00:03:31.109 --> 00:03:35.400
所以我们建立的方式

00:03:32.759 --> 00:03:37.560
过去的申请是为了

00:03:35.400 --> 00:03:40.639
我们拥有的架构以及

00:03:37.560 --> 00:03:44.340
架构发生了根本变化

00:03:40.639 --> 00:03:47.180
成为云现在我们将讨论什么

00:03:44.340 --> 00:03:50.280
确切地说这意味着

00:03:47.180 --> 00:03:52.620
但是因为基础架构

00:03:50.280 --> 00:03:56.370
改变了一切分配

00:03:52.620 --> 00:03:59.579
现在一切都在改变

00:03:56.370 --> 00:04:01.769
具有非常严格的计时的旧图和

00:03:59.579 --> 00:04:04.769
所以在那永远不会飞

00:04:01.769 --> 00:04:06.389
从根本上意味着

00:04:04.769 --> 00:04:09.030
为了利用这一点

00:04:06.389 --> 00:04:11.879
建筑，我们需要改变方式

00:04:09.030 --> 00:04:14.400
我们构建应用程序，以便您

00:04:11.879 --> 00:04:16.859
听说这件事叫做12因素

00:04:14.400 --> 00:04:18.840
也许，但是我们想要做的是

00:04:16.859 --> 00:04:22.380
有点神秘化

00:04:18.840 --> 00:04:24.840
这个演讲很具体，说什么

00:04:22.380 --> 00:04:27.120
是这12个因素让我们来看一下

00:04:24.840 --> 00:04:28.860
让我们了解一下他们的想法

00:04:27.120 --> 00:04:30.810
关于他们更深入一点

00:04:28.860 --> 00:04:32.849
顺便说一个半小时

00:04:30.810 --> 00:04:34.229
谈论我们无法想像他们

00:04:32.849 --> 00:04:34.849
不能谈论他们并思考

00:04:34.229 --> 00:04:38.209
他们作为

00:04:34.849 --> 00:04:40.639
深深地希望，我们应该如此

00:04:38.209 --> 00:04:43.219
我希望大家都摆脱这个

00:04:40.639 --> 00:04:45.559
我真的需要研究这些东西吗

00:04:43.219 --> 00:04:48.099
我现在需要介绍

00:04:45.559 --> 00:04:51.050
需要研究这些各种因素，并且

00:04:48.099 --> 00:04:53.749
了解它们是什么，重要的是

00:04:51.050 --> 00:04:56.089
为什么它们很重要，因为那是

00:04:53.749 --> 00:04:58.240
将使您能够建立

00:04:56.089 --> 00:05:00.619
您的应用程序是正确的方式

00:04:58.240 --> 00:05:02.389
说实话能够表达

00:05:00.619 --> 00:05:06.229
您不在这里的同事

00:05:02.389 --> 00:05:08.269
 Spring 之一，所以这真的是我们的目标是

00:05:06.229 --> 00:05:11.379
让你了解那些事情

00:05:08.269 --> 00:05:14.119
然后更深入地思考他们

00:05:11.379 --> 00:05:18.129
什么是云原生

00:05:14.119 --> 00:05:20.569
应用程序，所以有很多

00:05:18.129 --> 00:05:22.819
人们的定义和属性

00:05:20.569 --> 00:05:25.099
与云原生应用程序关联

00:05:22.819 --> 00:05:26.779
每个人都有不同

00:05:25.099 --> 00:05:29.869
定义，所以我拉了几个

00:05:26.779 --> 00:05:31.669
他们离开这里，所以我其中一个

00:05:29.869 --> 00:05:33.379
发现它实际上是报价，这就是为什么

00:05:31.669 --> 00:05:37.669
用引号引起来的

00:05:33.379 --> 00:05:41.180
专为云平台而设计

00:05:37.669 --> 00:05:43.189
像这样，那么云平台是什么

00:05:41.180 --> 00:05:46.669
这就像在

00:05:43.189 --> 00:05:47.839
字典，他们说你知道我不知道

00:05:46.669 --> 00:05:49.189
知道我应该有一个更好的例子

00:05:47.839 --> 00:05:51.259
离开我的舌尖，但你知道

00:05:49.189 --> 00:05:53.089
你去查一个字，它说哦

00:05:51.259 --> 00:05:55.039
这是在做生意，他们给

00:05:53.089 --> 00:05:58.639
你这个单词的缩写

00:05:55.039 --> 00:06:02.569
所以我什么也没告诉我

00:05:58.639 --> 00:06:07.779
云平台是AWS还是云

00:06:02.569 --> 00:06:10.339
铸造厂不确定其高度可扩展性

00:06:07.779 --> 00:06:13.069
绝对没问题，很高

00:06:10.339 --> 00:06:14.539
可扩展性几乎就是我所需要的

00:06:13.069 --> 00:06:17.479
想尽快有

00:06:14.539 --> 00:06:19.459
超过一台已经存在的机器

00:06:17.479 --> 00:06:21.979
您已经必须应对的可扩展性

00:06:19.459 --> 00:06:24.439
某种程度的分布

00:06:21.979 --> 00:06:25.300
情况下，它具有很高的可扩展性，因此

00:06:24.439 --> 00:06:30.349
似乎是正确的

00:06:25.300 --> 00:06:32.300
是的，移动电话不一定，但可能

00:06:30.349 --> 00:06:34.909
好主意，我们再谈一点

00:06:32.300 --> 00:06:36.889
关于您是否有多个设备

00:06:34.909 --> 00:06:38.209
您正在支持其中之一

00:06:36.889 --> 00:06:42.769
您可能会考虑的因素

00:06:38.209 --> 00:06:45.589
他们绝对是吉尔

00:06:42.769 --> 00:06:48.680
这个世界，我们不断释放

00:06:45.589 --> 00:06:50.810
我们需要敏捷的软件

00:06:48.680 --> 00:06:52.340
不仅软件的敏捷性

00:06:50.810 --> 00:06:54.620
我们要发布，但我们需要

00:06:52.340 --> 00:06:57.680
敏捷，因为我在平台上

00:06:54.620 --> 00:06:59.270
持续运行总是在变化， 

00:06:57.680 --> 00:07:02.180
我们将在后面的讨论中

00:06:59.270 --> 00:07:04.310
更详细地运行在

00:07:02.180 --> 00:07:06.350
容器其实我认为那是

00:07:04.310 --> 00:07:08.060
真正的实现细节

00:07:06.350 --> 00:07:09.620
没关系，我们拥有的是

00:07:08.060 --> 00:07:11.810
不管他们跑进去

00:07:09.620 --> 00:07:13.940
容器与否我真的不认为

00:07:11.810 --> 00:07:16.430
那是定义的一部分

00:07:13.940 --> 00:07:18.169
云本机应用程序微服务

00:07:16.430 --> 00:07:20.240
今天早上我们约瑟开玩笑

00:07:18.169 --> 00:07:22.010
在整个谈话中几乎都做到了

00:07:20.240 --> 00:07:23.810
不使用微服务这个词

00:07:22.010 --> 00:07:26.300
在幻灯片上，但我在最后很晚才偷了它

00:07:23.810 --> 00:07:29.210
晚上，所以这里是微服务

00:07:26.300 --> 00:07:31.060
大概一次又一次，我们可以出发

00:07:29.210 --> 00:07:34.910
对微服务进行定义

00:07:31.060 --> 00:07:36.530
专为失败而设计

00:07:34.910 --> 00:07:38.389
那就是我刚才所说的

00:07:36.530 --> 00:07:39.910
事情总是在变化，我们会

00:07:38.389 --> 00:07:43.639
多谈一些设计

00:07:39.910 --> 00:07:45.349
对于失败，所以另一部分

00:07:43.639 --> 00:07:47.000
标题，所以我一直在谈论云

00:07:45.349 --> 00:07:48.860
在第一张幻灯片中是本机的，但如果您

00:07:47.000 --> 00:07:52.370
请记住，演讲的标题

00:07:48.860 --> 00:07:53.900
还有12因子，所以12因子净

00:07:52.370 --> 00:07:57.260
如果您没有看过的话

00:07:53.900 --> 00:08:00.229
网址绝对值得一读，很漂亮

00:07:57.260 --> 00:08:02.750
短，实际上很短，而且

00:08:00.229 --> 00:08:04.430
谈论它是由一个人写的

00:08:02.750 --> 00:08:07.490
工作过的开发人员数量

00:08:04.430 --> 00:08:08.900
 Heroku，因此Heroku是一个平台

00:08:07.490 --> 00:08:10.639
服务在那里，人们一直在

00:08:08.900 --> 00:08:12.110
在上面部署应用程序，它们有点

00:08:10.639 --> 00:08:14.960
找出其中的一些模式

00:08:12.110 --> 00:08:17.900
这些因素中有些起作用吗？ 

00:08:14.960 --> 00:08:19.430
我们从12个因素开始

00:08:17.900 --> 00:08:21.530
您会看到我们实际上将

00:08:19.430 --> 00:08:24.050
还要超出一点

00:08:21.530 --> 00:08:28.039
 12个因素真是很棒

00:08:24.050 --> 00:08:29.720
简要说明一些

00:08:28.039 --> 00:08:32.000
这些因素是我们将要使用的

00:08:29.720 --> 00:08:34.339
作为我们的指导，这不是

00:08:32.000 --> 00:08:36.589
议程幻灯片上有很多内容，但您确实可以

00:08:34.339 --> 00:08:38.950
想到12因子网就是那种

00:08:36.589 --> 00:08:42.950
我们要通过的议程

00:08:38.950 --> 00:08:45.080
现在第一个因素是代码库

00:08:42.950 --> 00:08:46.910
你会看到那里的字幕说

00:08:45.080 --> 00:08:51.170
跟踪和修订一个代码库

00:08:46.910 --> 00:08:53.270
控制很多部署，所以很明显我们

00:08:51.170 --> 00:08:55.310
需要版本控制，所以我们不会

00:08:53.270 --> 00:08:57.560
专注于那一部分

00:08:55.310 --> 00:08:59.870
赌桌赌注，但更大

00:08:57.560 --> 00:09:00.460
问题，顺便说一句

00:08:59.870 --> 00:09:02.260
工作

00:09:00.460 --> 00:09:04.270
花很多时间不仅要去

00:09:02.260 --> 00:09:06.160
通过幻灯片实际上这将是

00:09:04.270 --> 00:09:09.160
一小部分，我们将花费

00:09:06.160 --> 00:09:10.480
在github内部和内部的大量时间

00:09:09.160 --> 00:09:12.580
代码，我们将损失很多

00:09:10.480 --> 00:09:16.900
还有很多演示，如果演示之神会

00:09:12.580 --> 00:09:19.780
有它，所以如果您阅读第一个因素

00:09:16.900 --> 00:09:23.230
真的像我一样在谈论更多

00:09:19.780 --> 00:09:26.320
说的休息或桌子赌注，但如何

00:09:23.230 --> 00:09:28.180
你打破你的代码库

00:09:26.320 --> 00:09:30.490
真正的根本问题

00:09:28.180 --> 00:09:33.880
问题在那里，他们使

00:09:30.490 --> 00:09:36.780
断言一个代码库等于一个

00:09:33.880 --> 00:09:39.520
应用程序现在似乎相对

00:09:36.780 --> 00:09:41.410
直截了当，虽然你可以想象

00:09:39.520 --> 00:09:44.110
现在我们等一下，如果我

00:09:41.410 --> 00:09:46.960
有一个大型的复杂系统， 

00:09:44.110 --> 00:09:48.430
真正的复合应用程序，您可以

00:09:46.960 --> 00:09:50.140
说好吧，我有一个综合

00:09:48.430 --> 00:09:52.090
应用程序，它由一个

00:09:50.140 --> 00:09:54.670
一堆应用程序，我们将

00:09:52.090 --> 00:09:56.920
对此进行一对一映射，但是

00:09:54.670 --> 00:09:59.080
真的，这就是第一个因素

00:09:56.920 --> 00:10:01.330
挑战首要因素

00:09:59.080 --> 00:10:03.430
你想想你怎么分手

00:10:01.330 --> 00:10:06.370
您的代码到不同的存储库

00:10:03.430 --> 00:10:08.080
有趣的是

00:10:06.370 --> 00:10:10.420
实际上有一个组织

00:10:08.080 --> 00:10:11.830
那里的设计问题也是

00:10:10.420 --> 00:10:13.270
好像超级好

00:10:11.830 --> 00:10:15.670
简单明了，但您可以花很多钱

00:10:13.270 --> 00:10:18.340
只是在想这个

00:10:15.670 --> 00:10:20.710
真正的问题是这种映射

00:10:18.340 --> 00:10:23.020
一个应用程序的一个代码库就是

00:10:20.710 --> 00:10:25.810
前进的方式，答案也许是

00:10:23.020 --> 00:10:27.190
让我在这里花点时间说

00:10:25.810 --> 00:10:32.590
我想强调的东西

00:10:27.190 --> 00:10:35.260
尽早，所以这12个因素并不是

00:10:32.590 --> 00:10:38.320
严格的规则不是你

00:10:35.260 --> 00:10:41.290
不能，除非您全部遵循12 

00:10:38.320 --> 00:10:43.540
他们中的12人来信并顺便说一句

00:10:41.290 --> 00:10:46.750
太短了，有很多空间

00:10:43.540 --> 00:10:48.700
解释在那里

00:10:46.750 --> 00:10:50.830
不必跟随所有12到

00:10:48.700 --> 00:10:53.410
信百分之一百之前，你有一个

00:10:50.830 --> 00:10:55.090
云本机应用程序，因此您应该

00:10:53.410 --> 00:10:56.950
看看其中的每一个

00:10:55.090 --> 00:10:58.600
就像我说的那样深思熟虑

00:10:56.950 --> 00:11:02.860
考虑一下它的含义

00:10:58.600 --> 00:11:04.720
您的特定部署再次

00:11:02.860 --> 00:11:07.390
问题在这里， 

00:11:04.720 --> 00:11:09.820
答案可能是，所以让我们来看一下

00:11:07.390 --> 00:11:12.160
一些替代方案，所以我会好心

00:11:09.820 --> 00:11:13.089
在这里做一点证明并说好

00:11:12.160 --> 00:11:15.370
我想证明

00:11:13.089 --> 00:11:17.620
一个代码库等于一个应用程序，所以让我们

00:11:15.370 --> 00:11:20.589
看一些其他的东西，基本上

00:11:17.620 --> 00:11:22.600
显示冲突，让我们看一下

00:11:20.589 --> 00:11:24.430
其中的几个，因为它真的来了

00:11:22.600 --> 00:11:27.370
到那可能是一个漂亮的

00:11:24.430 --> 00:11:30.579
好的规则，一个代码库等于一个应用程序

00:11:27.370 --> 00:11:33.759
所以让我们来看看那些替代方案

00:11:30.579 --> 00:11:37.240
这是我们所做的

00:11:33.759 --> 00:11:42.819
过去是一个代码库等于一个整体

00:11:37.240 --> 00:11:45.220
现在我们已经打包了很多应用

00:11:42.819 --> 00:11:47.470
在整体中，因此您实际上可以

00:11:45.220 --> 00:11:50.379
你可能想到了那个中间

00:11:47.470 --> 00:11:53.800
事情在那里作为一个单一的应用程序

00:11:50.379 --> 00:11:56.620
应用程序，但现实是您

00:11:53.800 --> 00:12:00.279
应该打破那块巨石， 

00:11:56.620 --> 00:12:02.589
我花了很多时间与

00:12:00.279 --> 00:12:04.990
那些最大的大客户

00:12:02.589 --> 00:12:08.050
问题是我有这些遗产

00:12:04.990 --> 00:12:09.879
巨石，我知道我拥有这一切

00:12:08.050 --> 00:12:12.699
痛苦，因为它很难修复

00:12:09.879 --> 00:12:14.589
而且甚至很难组建一个团队

00:12:12.699 --> 00:12:16.749
能够窥探那块巨石中的东西， 

00:12:14.589 --> 00:12:18.699
开始有效地构建代码

00:12:16.749 --> 00:12:20.769
等等，以便他们知道他们想要什么

00:12:18.699 --> 00:12:22.990
分解这些东西而不是

00:12:20.769 --> 00:12:25.120
问什么代码的问题

00:12:22.990 --> 00:12:29.439
基本等于许多应用程序，这实际上是一个

00:12:25.120 --> 00:12:32.439
什么应该有很多的代码库

00:12:29.439 --> 00:12:35.319
现在的应用程序当然这是一个

00:12:32.439 --> 00:12:37.329
反模式，我们正在远离

00:12:35.319 --> 00:12:39.100
巨石我会做的另一件事

00:12:37.329 --> 00:12:40.899
告诉您与客户合作是我们

00:12:39.100 --> 00:12:43.779
有时候有些顾客说可以

00:12:40.899 --> 00:12:45.879
想尝试Cloud Foundry，我想

00:12:43.779 --> 00:12:48.939
拿一个现有的应用程序，你知道

00:12:45.879 --> 00:12:51.879
 Documentum怎么样？ 

00:12:48.939 --> 00:12:56.199
 Liferay我可以在您的平台上运行它吗

00:12:51.879 --> 00:12:57.879
答案是不，不，不，不，云

00:12:56.199 --> 00:13:00.009
本机并不意味着您会选择

00:12:57.879 --> 00:13:02.709
现有的所有旧行李

00:13:00.009 --> 00:13:04.509
您进入云原生

00:13:02.709 --> 00:13:07.059
意味着您要摆脱一些

00:13:04.509 --> 00:13:09.610
那个行李，所以这真的是一个

00:13:07.059 --> 00:13:11.439
反模式，但这是我们

00:13:09.610 --> 00:13:13.480
可以像我所说的那样迁移

00:13:11.439 --> 00:13:15.339
的客户因此而工作

00:13:13.480 --> 00:13:18.490
这一种让我们推迟

00:13:15.339 --> 00:13:20.350
在迁移方面

00:13:18.490 --> 00:13:23.019
我只是要做几个

00:13:20.350 --> 00:13:24.759
评论在这里，我们有几个讲座

00:13:23.019 --> 00:13:26.170
在末尾引用

00:13:24.759 --> 00:13:30.220
滑梯

00:13:26.170 --> 00:13:33.000
一 Spring 在这里进行的那场谈话

00:13:30.220 --> 00:13:35.500
这一个迁移的整体

00:13:33.000 --> 00:13:37.120
不幸的是已经通过了多少

00:13:35.500 --> 00:13:39.940
人们热闹非凡

00:13:37.120 --> 00:13:42.610
昨天你们当中有几个很棒

00:13:39.940 --> 00:13:44.769
所以昨天下午再热

00:13:42.610 --> 00:13:47.110
迁移整体，好消息是

00:13:44.769 --> 00:13:48.790
所有这些都被记录下来

00:13:47.110 --> 00:13:50.110
我鼓励你回去

00:13:48.790 --> 00:13:52.779
看一下那个

00:13:50.110 --> 00:13:54.519
提供了录音，但实际上

00:13:52.779 --> 00:13:56.260
关于迁移，有一些

00:13:54.519 --> 00:13:57.670
我们可以遵循的模式

00:13:56.260 --> 00:13:59.440
您需要确保的一些先决条件

00:13:57.670 --> 00:14:01.800
您有足够的测试范围，并且

00:13:59.440 --> 00:14:04.180
同一构建环境中的管道

00:14:01.800 --> 00:14:06.010
那你就很想选择东西

00:14:04.180 --> 00:14:08.199
仔细地我想从中取出什么

00:14:06.010 --> 00:14:10.750
整体确保您可以

00:14:08.199 --> 00:14:14.199
在提取中展示价值

00:14:10.750 --> 00:14:17.829
提取东西，现在这是关键

00:14:14.199 --> 00:14:19.540
当您提取该组件时， 

00:14:17.829 --> 00:14:24.070
您现在正在做的是创建一个

00:14:19.540 --> 00:14:27.370
单独的应用程序

00:14:24.070 --> 00:14:29.649
它自己的存储库，或者必须是它的

00:14:27.370 --> 00:14:32.290
拥有自己的存储库，所以现在您要移回

00:14:29.649 --> 00:14:33.850
朝那个一对一的映射，然后

00:14:32.290 --> 00:14:36.130
你可以做代理之类的事情

00:14:33.850 --> 00:14:38.170
整体内部的图案

00:14:36.130 --> 00:14:40.029
所以这是一个非常快的高

00:14:38.170 --> 00:14:42.519
整体迁移的概述

00:14:40.029 --> 00:14:45.160
等等，这是第一个

00:14:42.519 --> 00:14:48.160
回到好吧，也许是因为

00:14:45.160 --> 00:14:51.250
一个映射在那里，我们去了新的仓库

00:14:48.160 --> 00:14:53.410
盘旋我做得很好的重点

00:14:51.250 --> 00:14:55.240
那么很多代码库等于

00:14:53.410 --> 00:14:57.250
一个应用程序让我们看一个场景

00:14:55.240 --> 00:14:59.140
这实际上是一个

00:14:57.250 --> 00:15:00.459
在我们谈论时长大

00:14:59.140 --> 00:15:03.040
和我们乔希的同事一起

00:15:00.459 --> 00:15:06.310
 McEntee和他建议也许

00:15:03.040 --> 00:15:09.279
您可能只有一个代码库

00:15:06.310 --> 00:15:11.319
有两个不同的进程正在运行

00:15:09.279 --> 00:15:13.510
它将被部署为两个

00:15:11.319 --> 00:15:16.230
不同的应用程序，例如这里

00:15:13.510 --> 00:15:18.430
您有一个Web界面

00:15:16.230 --> 00:15:21.399
访问可能在

00:15:18.430 --> 00:15:23.050
排队工作，所以我要安排一个

00:15:21.399 --> 00:15:25.480
医生的任命，现在我想

00:15:23.050 --> 00:15:27.190
在我排队之前说些什么

00:15:25.480 --> 00:15:28.690
请去看那个医生的约会

00:15:27.190 --> 00:15:31.089
确保您已转移所有

00:15:28.690 --> 00:15:32.860
我的病历从云端降下来

00:15:31.089 --> 00:15:34.930
到当地的医生办公室

00:15:32.860 --> 00:15:36.970
医生的办公室，所以小灰盒

00:15:34.930 --> 00:15:38.200
在绿色的小盒子里是

00:15:36.970 --> 00:15:39.940
两个不同的应用

00:15:38.200 --> 00:15:42.880
我们可以说那是一个

00:15:39.940 --> 00:15:45.190
实际上只是一个应用程序的代码库

00:15:42.880 --> 00:15:47.770
两个不同的过程，让我们暂停

00:15:45.190 --> 00:15:51.460
难以置信片刻，想一想

00:15:47.770 --> 00:15:53.680
所以也许这是一个不错的情况

00:15:51.460 --> 00:15:57.820
所以我有这两个不同的应用程序，但是

00:15:53.680 --> 00:16:00.940
如果你开始考虑的话

00:15:57.820 --> 00:16:02.440
嗯，其实我很抱歉他

00:16:00.940 --> 00:16:03.760
在这里谈论有两个

00:16:02.440 --> 00:16:06.730
不同的代码库两个不同

00:16:03.760 --> 00:16:08.560
存储库单个应用程序，但是如果您已经

00:16:06.730 --> 00:16:10.510
有两个不同的存储库

00:16:08.560 --> 00:16:13.600
大概在谈论两个不同

00:16:10.510 --> 00:16:15.520
团队，或者您要启用两个不同的

00:16:13.600 --> 00:16:18.550
团队来从事这两个不同的工作

00:16:15.520 --> 00:16:19.900
比萨盒团队就在您身边

00:16:18.550 --> 00:16:24.220
有两个团队

00:16:19.900 --> 00:16:26.170
您可能需要API，因为

00:16:24.220 --> 00:16:28.570
命令两个不同的团队一起工作

00:16:26.170 --> 00:16:31.120
事实证明，接口是一个

00:16:28.570 --> 00:16:33.970
非常好的思考方式

00:16:31.120 --> 00:16:37.030
 Organa组织您的开发团队

00:16:33.970 --> 00:16:38.860
因此，如果可以分开，可以放一个

00:16:37.030 --> 00:16:40.450
 API，然后您就可以分离出

00:16:38.860 --> 00:16:45.220
开发团队，这意味着您可以

00:16:40.450 --> 00:16:47.800
扩展您的开发范围，以便两个

00:16:45.220 --> 00:16:50.080
分解一个代码库，所以我们回到

00:16:47.800 --> 00:16:54.430
一个代码库的问题等于一个

00:16:50.080 --> 00:16:57.400
是的，可能是个好习惯

00:16:54.430 --> 00:16:59.530
想法，让我们做一点

00:16:57.400 --> 00:17:01.210
除了在这里，我们谈论的事实是

00:16:59.530 --> 00:17:03.550
我们将要谈论十二点

00:17:01.210 --> 00:17:05.860
现在我会让你知道那不是

00:17:03.550 --> 00:17:07.420
我们实际上将要谈论的是

00:17:05.860 --> 00:17:10.120
我们认为的其他因素数量

00:17:07.420 --> 00:17:11.949
也很重要，所以这是其中之一

00:17:10.120 --> 00:17:13.360
顺便说一句第一奖金因素

00:17:11.949 --> 00:17:16.060
您会注意到我们不会去

00:17:13.360 --> 00:17:17.949
通过从1开始的因素

00:17:16.060 --> 00:17:19.600
到12点，我们将经历

00:17:17.949 --> 00:17:22.810
他们的顺序似乎使

00:17:19.600 --> 00:17:25.570
对我们来说更有意义，所以这是奖金

00:17:22.810 --> 00:17:29.790
因素，那就是在设计时

00:17:25.570 --> 00:17:32.800
您的应用程序首先考虑API 

00:17:29.790 --> 00:17:34.660
考虑一下接口如何

00:17:32.800 --> 00:17:38.680
微服务又来了

00:17:34.660 --> 00:17:41.470
我之前有微服务

00:17:38.680 --> 00:17:45.490
考虑甚至设计它们

00:17:41.470 --> 00:17:47.350
开发那些api的第一个，因此

00:17:45.490 --> 00:17:48.790
您可以做的一件伟大的事

00:17:47.350 --> 00:17:50.400
您可以做的事情

00:17:48.790 --> 00:17:52.590
可测性

00:17:50.400 --> 00:17:55.920
是创建您的API的实现

00:17:52.590 --> 00:17:57.930
这样我们的模拟游戏才能

00:17:55.920 --> 00:17:59.850
在高度分散的环境中进行测试

00:17:57.930 --> 00:18:02.220
您需要模拟的环境

00:17:59.850 --> 00:18:05.310
不同的不同的API和不同的

00:18:02.220 --> 00:18:06.960
服务，甚至在发展之前

00:18:05.310 --> 00:18:08.970
你把真正的实现放回去

00:18:06.960 --> 00:18:11.880
在那里您可以为您的AP开发模拟

00:18:08.970 --> 00:18:13.770
您是否需要对API进行版本控制

00:18:11.880 --> 00:18:15.990
需要能够发现api的

00:18:13.770 --> 00:18:18.420
等等，整个社区

00:18:15.990 --> 00:18:21.510
真正涉及到的是

00:18:18.420 --> 00:18:23.790
在API开发和API管理中

00:18:21.510 --> 00:18:26.640
你会看到那里有一个URL 

00:18:23.790 --> 00:18:30.420
这是API的第一次交流，所以看看

00:18:26.640 --> 00:18:31.100
那里真的有非常好的信息

00:18:30.420 --> 00:18:35.220
对

00:18:31.100 --> 00:18:37.650
第二个因素说依赖性

00:18:35.220 --> 00:18:40.380
明确声明和隔离

00:18:37.650 --> 00:18:42.390
依赖，所以我的第一件事

00:18:40.380 --> 00:18:45.660
想说的是你需要问

00:18:42.390 --> 00:18:48.570
为什么这样的问题，因为那是真的

00:18:45.660 --> 00:18:51.420
是什么激励着我们，为什么要做

00:18:48.570 --> 00:18:53.520
很明显，我们都是开发人员

00:18:51.420 --> 00:18:57.560
确实是让我们的生活更轻松

00:18:53.520 --> 00:19:00.300
对，这一切都与我们有关，我

00:18:57.560 --> 00:19:02.040
在这里从事职业生涯的开发人员，所以我包括

00:19:00.300 --> 00:19:05.360
我自己在那里，这就是关于

00:19:02.040 --> 00:19:08.130
开发人员避免依赖地狱权

00:19:05.360 --> 00:19:09.960
所以我知道 Spring 1是一个

00:19:08.130 --> 00:19:11.820
我去其他的开发者大会

00:19:09.960 --> 00:19:13.800
像DevOps这样的会议

00:19:11.820 --> 00:19:15.930
完全歪斜，相反

00:19:13.800 --> 00:19:17.610
这是一个充满操作人员的房间， 

00:19:15.930 --> 00:19:23.040
我意识到你们大多数人可能是

00:19:17.610 --> 00:19:25.140
开发人员，但最终您的应用程序运行良好

00:19:23.040 --> 00:19:30.780
希望如果他们看到了曙光

00:19:25.140 --> 00:19:33.210
由您在生产中操作，因此

00:19:30.780 --> 00:19:36.140
不只是让我们的开发人员

00:19:33.210 --> 00:19:39.510
生活更轻松，但这也与

00:19:36.140 --> 00:19:41.760
操作更轻松，其中哪一项

00:19:39.510 --> 00:19:43.470
我们绝对必须要做的事情

00:19:41.760 --> 00:19:46.890
在操作方面是

00:19:43.470 --> 00:19:49.860
如果我不能重复部署

00:19:46.890 --> 00:19:52.560
反复部署或如果我无法部署

00:19:49.860 --> 00:19:54.660
在整个生命周期中的应用

00:19:52.560 --> 00:19:57.540
没有巨大障碍的生命周期

00:19:54.660 --> 00:20:00.150
那真的会阻碍我

00:19:57.540 --> 00:20:04.410
在新产品中变得非常敏捷的能力

00:20:00.150 --> 00:20:06.390
世界，让我们深入一点

00:20:04.410 --> 00:20:10.410
片刻，然后在

00:20:06.390 --> 00:20:12.180
多一点的深度，所以我要跳过

00:20:10.410 --> 00:20:15.180
分解为五，我将回到分解

00:20:12.180 --> 00:20:17.790
一会儿就有两个，因数5说

00:20:15.180 --> 00:20:21.060
严格区分那些不同的人

00:20:17.790 --> 00:20:24.630
严格的申请阶段

00:20:21.060 --> 00:20:26.970
十二因子中的五因子

00:20:24.630 --> 00:20:29.880
实际谈论的是版本发布和

00:20:26.970 --> 00:20:33.120
运行我们想做的就是添加

00:20:29.880 --> 00:20:34.860
在设计阶段，现在我想

00:20:33.120 --> 00:20:36.840
花一点时间在这里谈论

00:20:34.860 --> 00:20:40.260
那些不同的阶段并谈论

00:20:36.840 --> 00:20:43.770
谁来了谁在做那些你在做什么

00:20:40.260 --> 00:20:45.480
然后为什么我们不想

00:20:43.770 --> 00:20:47.640
将其与其他一些阶段合并

00:20:45.480 --> 00:20:50.940
我们为什么要创建这个严格的

00:20:47.640 --> 00:20:53.430
分离，所以首先是

00:20:50.940 --> 00:20:55.290
我们大多数人在这里的房间开发商

00:20:53.430 --> 00:20:58.020
正在使用 Spring 和 Spring 

00:20:55.290 --> 00:21:00.600
但是-Gradle和Maven能够

00:20:58.020 --> 00:21:02.430
表达那些依赖性，为什么

00:21:00.600 --> 00:21:04.170
开发人员这样做是因为

00:21:02.430 --> 00:21:05.640
开发人员最了解

00:21:04.170 --> 00:21:07.440
应用程序并了解

00:21:05.640 --> 00:21:11.730
依赖，这样一个人很漂亮

00:21:07.440 --> 00:21:13.800
简单的构建，所以首先

00:21:11.730 --> 00:21:15.750
这里的想法是你需要

00:21:13.800 --> 00:21:18.480
创建一个版本，您需要创建一个

00:21:15.750 --> 00:21:20.130
可部署工件，即工件

00:21:18.480 --> 00:21:23.190
贯穿于您的其余部分

00:21:20.130 --> 00:21:25.170
应用程序生命周期，所以我们都知道

00:21:23.190 --> 00:21:27.480
关于它的故事可以在我的机器上运行

00:21:25.170 --> 00:21:30.870
在我的机器上不起作用，如果您

00:21:27.480 --> 00:21:32.910
在改变构建然后构建

00:21:30.870 --> 00:21:35.160
环境可能是

00:21:32.910 --> 00:21:37.200
问题，那么问题不在哪里

00:21:35.160 --> 00:21:39.330
知道所以我们可以的方法之一

00:21:37.200 --> 00:21:40.830
最小化不同的地方

00:21:39.330 --> 00:21:43.350
正如我们所说，必须寻找问题

00:21:40.830 --> 00:21:45.240
我们要在一处建造

00:21:43.350 --> 00:21:47.910
然后将是

00:21:45.240 --> 00:21:51.060
完全自动化和可重复的方式

00:21:47.910 --> 00:21:53.580
做一般的建造

00:21:51.060 --> 00:21:56.310
如果您没有CI，请成为您的CI系统

00:21:53.580 --> 00:21:58.380
您绝对需要获得CI系统

00:21:56.310 --> 00:22:00.030
没有地方，你可以

00:21:58.380 --> 00:22:02.280
在这个新世界中构建软件

00:22:00.030 --> 00:22:04.080
 CI系统，所以您要做什么

00:22:02.280 --> 00:22:06.300
在 Spring 这里，你当然是

00:22:04.080 --> 00:22:08.820
要创建战争或jar文件， 

00:22:06.300 --> 00:22:11.040
重点是很多

00:22:08.820 --> 00:22:14.750
部署并远离反

00:22:11.040 --> 00:22:16.870
在我的机器上工作是一种回应

00:22:14.750 --> 00:22:19.720
然后您将创建一个

00:22:16.870 --> 00:22:22.809
现在，谁来创建

00:22:19.720 --> 00:22:24.790
发布我们认为这是平台，所以

00:22:22.809 --> 00:22:27.010
让我在这里花点时间

00:22:24.790 --> 00:22:28.660
谈到 Spring 开发者，我们

00:22:27.010 --> 00:22:30.820
会给你很多例子

00:22:28.660 --> 00:22:32.800
 Spring 可用的东西， 

00:22:30.820 --> 00:22:34.809
您注意到我们俩都在

00:22:32.800 --> 00:22:36.910
 Cloud Foundry团队我们相信很多

00:22:34.809 --> 00:22:39.700
必要的东西

00:22:36.910 --> 00:22:41.530
十二个因素不仅满足于

00:22:39.700 --> 00:22:45.040
中的开发框架

00:22:41.530 --> 00:22:47.710
语言，但可以通过以下方式最满意

00:22:45.040 --> 00:22:50.830
工具，我已经给你的平台

00:22:47.710 --> 00:22:52.980
一个示例CI系统其他云

00:22:50.830 --> 00:22:56.200
平台可以满足其他条件

00:22:52.980 --> 00:22:59.429
所以对于发布，我们的意思是好的

00:22:56.200 --> 00:23:02.080
让我们把所有这些代码位和

00:22:59.429 --> 00:23:04.450
将其与其他东西粘合在一起

00:23:02.080 --> 00:23:07.390
我们需要剩下的是什么

00:23:04.450 --> 00:23:10.450
好吧，可能是JDK，可能是

00:23:07.390 --> 00:23:12.220
应用服务器可能是基础

00:23:10.450 --> 00:23:14.550
您正在运行的操作系统

00:23:12.220 --> 00:23:16.929
所以我们需要将那些碎片粘合在一起

00:23:14.550 --> 00:23:19.510
变成我们称为发布的东西

00:23:16.929 --> 00:23:23.530
该发布是我们可以做到的

00:23:19.510 --> 00:23:25.510
然后部署它是我们转换的东西

00:23:23.530 --> 00:23:29.410
这是我们可以回滚到的东西

00:23:25.510 --> 00:23:31.210
等等，这一切都与敏捷性有关， 

00:23:29.410 --> 00:23:34.780
就像我说的那样，升级和回滚

00:23:31.210 --> 00:23:38.650
最后，我希望能够

00:23:34.780 --> 00:23:40.840
获取该版本并运行它

00:23:38.650 --> 00:23:42.700
平台再次是关于

00:23:40.840 --> 00:23:44.800
平台满足发布要求

00:23:42.700 --> 00:23:47.140
并运行它，一切都在这里

00:23:44.800 --> 00:23:49.480
速度，稍后我们会看到

00:23:47.140 --> 00:23:50.890
可以通过一些演示

00:23:49.480 --> 00:23:52.720
我要去跳过这个

00:23:50.890 --> 00:23:54.600
部署管道中

00:23:52.720 --> 00:23:57.340
幻灯片将放在SlideShare上

00:23:54.600 --> 00:24:00.940
但现在让我们回到依赖关系

00:23:57.340 --> 00:24:05.980
一会儿，所以请记住，这就是全部

00:24:00.940 --> 00:24:08.230
关于可重复部署，因此

00:24:05.980 --> 00:24:10.840
这里的重点是你永远都不要

00:24:08.230 --> 00:24:14.830
对环境承担任何责任

00:24:10.840 --> 00:24:16.720
这不是完全自动化的，所以您

00:24:14.830 --> 00:24:19.630
需要明确声明

00:24:16.720 --> 00:24:22.090
依赖关系，但是你可以问

00:24:19.630 --> 00:24:24.400
最终那个运行时的问题

00:24:22.090 --> 00:24:26.470
有运行时环境

00:24:24.400 --> 00:24:28.900
操作系统中有JDK 

00:24:26.470 --> 00:24:29.779
有应用程序容器，所以

00:24:28.900 --> 00:24:32.119
上

00:24:29.779 --> 00:24:33.710
谁要指定的是

00:24:32.119 --> 00:24:36.879
将成为开发商或

00:24:33.710 --> 00:24:39.229
平台以及我们现在要做的事情

00:24:36.879 --> 00:24:41.960
最后感谢您的耐心配合

00:24:39.229 --> 00:24:44.809
从PowerPoint中移走看看

00:24:41.960 --> 00:24:46.759
在一些代码，所以我要检查我的

00:24:44.809 --> 00:24:50.450
时钟，我跑得超级慢，所以

00:24:46.759 --> 00:24:52.700
让我们去这里好吧，让我们

00:24:50.450 --> 00:24:55.070
看看URL所在的代码

00:24:52.700 --> 00:24:56.509
最后的幻灯片以及所有内容

00:24:55.070 --> 00:24:58.149
我们正在经历所有的

00:24:56.509 --> 00:25:01.099
样本在此github中可用

00:24:58.149 --> 00:25:06.019
仓库，所以你可以看看

00:25:01.099 --> 00:25:08.269
那但是我们这里有一个github 

00:25:06.019 --> 00:25:10.039
有很多分支的存储库

00:25:08.269 --> 00:25:12.559
您可以看到我们已经创建了分支

00:25:10.039 --> 00:25:14.269
对于所有不同的因素， 

00:25:12.559 --> 00:25:16.849
再次，我们不会经历他们

00:25:14.269 --> 00:25:21.619
为了我们要

00:25:16.849 --> 00:25:25.399
从f2 f2依赖关系开始

00:25:21.619 --> 00:25:27.109
现在分支该分支正是您

00:25:25.399 --> 00:25:29.479
去这将是一个 spring boot 

00:25:27.109 --> 00:25:31.359
应用程序，如果你去 Spring spring bio 

00:25:29.479 --> 00:25:35.179
起始页

00:25:31.359 --> 00:25:37.190
这是Spring Boot Starter应用程序

00:25:35.179 --> 00:25:38.869
确切地说，你会看看你是否看

00:25:37.190 --> 00:25:41.929
里面的代码来看看

00:25:38.869 --> 00:25:44.450
现在让我过来

00:25:41.929 --> 00:25:47.259
是f1代码库，所以我们可以再次看到

00:25:44.450 --> 00:25:49.789
可以看到所有分支

00:25:47.259 --> 00:25:51.769
在这里让我得到所有的屏幕真实

00:25:49.789 --> 00:25:55.879
我需要的房地产，所以我要去做

00:25:51.769 --> 00:25:59.799
 git checkout哦，我们不在了

00:25:55.879 --> 00:25:59.799
屏幕，让我向上滚动一下

00:25:59.859 --> 00:26:05.509
我什至什至没有一点

00:26:03.859 --> 00:26:11.499
获得所有屏幕房地产

00:26:05.509 --> 00:26:14.499
没有更多，我们可以

00:26:11.499 --> 00:26:14.499
 f2 

00:26:18.820 --> 00:26:27.130
好的，所以我将其向下滚动

00:26:25.180 --> 00:26:30.130
所以你现在可以在那里看看

00:26:27.130 --> 00:26:35.050
我们出发，很高兴见到戴维斯AFC 

00:26:30.130 --> 00:26:37.530
 / 12因子应用程序还可以，我们会给

00:26:35.050 --> 00:26:41.470
您在最后一张幻灯片上的网址

00:26:37.530 --> 00:26:43.570
好的，所以这里有f2依赖项

00:26:41.470 --> 00:26:51.490
我将继续进行构建

00:26:43.570 --> 00:26:54.820
就这样，就像我说的那样

00:26:51.490 --> 00:26:57.040
标准的 spring boot 应用程序，我

00:26:54.820 --> 00:26:59.320
打算把它部署到平台上

00:26:57.040 --> 00:27:01.600
让我为您设置ACF目标并确保

00:26:59.320 --> 00:27:04.120
我在正确的地方，好吧，我

00:27:01.600 --> 00:27:09.780
我有我的空间，所以我要

00:27:04.120 --> 00:27:13.600
做一个CF推，我要指出

00:27:09.780 --> 00:27:21.940
 jar文件，因为我建立了一个jar文件

00:27:13.600 --> 00:27:23.710
然后罗12因素现在是主要的

00:27:21.940 --> 00:27:25.780
我想在这里告诉你，这是

00:27:23.710 --> 00:27:26.670
这不是关于云铸造的话题

00:27:25.780 --> 00:27:29.170
本身

00:27:26.670 --> 00:27:32.980
除了像我说的一些

00:27:29.170 --> 00:27:35.110
平台最好实现因素

00:27:32.980 --> 00:27:37.960
所以我们在这里要做的是

00:27:35.110 --> 00:27:42.370
请注意，我刚刚提供了广口瓶

00:27:37.960 --> 00:27:46.000
没有提供JDK，我没有提供

00:27:42.370 --> 00:27:48.160
应用程序容器还是我会

00:27:46.000 --> 00:27:50.620
谈论一下， 

00:27:48.160 --> 00:27:52.900
您在这里看到的是您实际看到的

00:27:50.620 --> 00:27:55.330
记住我们离开的因素5 

00:27:52.900 --> 00:27:58.390
继续，我们讨论了设计构建

00:27:55.330 --> 00:28:00.670
释放并运行您在此处看到的内容

00:27:58.390 --> 00:28:04.720
如您所见，现在在屏幕上

00:28:00.670 --> 00:28:07.540
您如何看待该平台产生了

00:28:04.720 --> 00:28:10.390
发布，记得我说发布

00:28:07.540 --> 00:28:12.130
是我们存放战争档案或罐子的地方

00:28:10.390 --> 00:28:14.680
文件，让我向上滚动一点

00:28:12.130 --> 00:28:17.260
在这里它释放了我们接受代码的地方

00:28:14.680 --> 00:28:18.940
单词jar文件并粘贴

00:28:17.260 --> 00:28:21.820
连同其他所有东西

00:28:18.940 --> 00:28:24.460
只需要运行它就可以了

00:28:21.820 --> 00:28:26.830
与JDK和

00:28:24.460 --> 00:28:28.630
应用程序容器，所以如果我们采用

00:28:26.830 --> 00:28:31.210
看这里，您会注意到

00:28:28.630 --> 00:28:32.070
意识到这是一个Java应用， 

00:28:31.210 --> 00:28:38.460
抓住

00:28:32.070 --> 00:28:40.830
 JDK因此抢到jdk 1.8，然后

00:28:38.460 --> 00:28:45.499
向前，它做了剩下的一切，现在

00:28:40.830 --> 00:28:48.509
您可以看到它实际上正在运行

00:28:45.499 --> 00:28:52.679
就在 spring boot 的问候

00:28:48.509 --> 00:28:56.309
因此该应用程序现在正在运行，您会注意到

00:28:52.679 --> 00:29:00.600
它只是拉进了jdk， 

00:28:56.309 --> 00:29:03.869
是因为正如您所知， spring boot 说

00:29:00.600 --> 00:29:05.309
不，我们不会使用，请原谅

00:29:03.869 --> 00:29:07.440
我们不会使用外部

00:29:05.309 --> 00:29:09.119
我们实际上要去的应用服务器

00:29:07.440 --> 00:29:13.049
把它捆成罐子的一部分

00:29:09.119 --> 00:29:15.479
本身，所以当我们运行该罐子时， 

00:29:13.049 --> 00:29:19.859
嵌入其中的tomcat，那就是

00:29:15.479 --> 00:29:23.159
现在开始的事情你可能会说得很好

00:29:19.859 --> 00:29:25.019
真的，过去，如果你知道

00:29:23.159 --> 00:29:28.649
过去有关Cloud Foundry的一切

00:29:25.019 --> 00:29:30.210
在 spring boot 之前，平台带来了

00:29:28.649 --> 00:29:33.149
应用程序容器

00:29:30.210 --> 00:29:35.159
它带来了tomcat，所以你可以问

00:29:33.149 --> 00:29:37.889
那么问题是什么正确的方法

00:29:35.159 --> 00:29:39.690
做事情和那些非常

00:29:37.889 --> 00:29:41.399
对 spring boot 充满热情的人会说

00:29:39.690 --> 00:29:43.379
哦，你总是带上申请表

00:29:41.399 --> 00:29:45.720
容器是 spring boot 的一部分

00:29:43.379 --> 00:29:47.580
始终是应用程序的一部分，但我可以

00:29:45.720 --> 00:29:49.889
告诉您与客户合作

00:29:47.580 --> 00:29:51.509
受管制的行业之一

00:29:49.889 --> 00:29:53.999
他们喜欢的事情是他们说你

00:29:51.509 --> 00:29:56.489
知道我们需要一些控制

00:29:53.999 --> 00:30:00.090
该应用程序容器是什么

00:29:56.489 --> 00:30:04.200
我们IT只会提供某些

00:30:00.090 --> 00:30:06.119
应用程序容器，所以我们不想

00:30:04.200 --> 00:30:08.220
开发人员做出选择，我们

00:30:06.119 --> 00:30:09.869
想做出选择，现在有一个

00:30:08.220 --> 00:30:11.940
多种破解方法

00:30:09.869 --> 00:30:13.259
坚果，但我将在这里向您展示

00:30:11.940 --> 00:30:15.629
通过切换到不同的git 

00:30:13.259 --> 00:30:20.129
仓库是我要做一个git 

00:30:15.629 --> 00:30:22.559
结帐f2，我要去抓

00:30:20.129 --> 00:30:26.279
另一个分支，所以有另一个分支

00:30:22.559 --> 00:30:28.379
在那里，让我继续前进，继续前进

00:30:26.279 --> 00:30:33.539
然后推一下，我会告诉你

00:30:28.379 --> 00:30:35.580
区别哦，如果我可以输入

00:30:33.539 --> 00:30:36.989
太好了，我们将继续进行

00:30:35.580 --> 00:30:43.649
建立，然后我要推动

00:30:36.989 --> 00:30:45.870
应用程序再次到那里，您会看到

00:30:43.649 --> 00:30:47.460
释放过程的差异

00:30:45.870 --> 00:30:48.840
片刻，但这里的重点

00:30:47.460 --> 00:30:51.540
你会看到非常非常

00:30:48.840 --> 00:30:54.900
显然是我们经历了

00:30:51.540 --> 00:30:57.780
发布过程，所以又是

00:30:54.900 --> 00:30:59.370
已上传或尚未上传

00:30:57.780 --> 00:31:01.559
应用程序，现在我们要去

00:30:59.370 --> 00:31:05.190
通过产生那个的过程

00:31:01.559 --> 00:31:11.520
放开，我们去了，您会注意到

00:31:05.190 --> 00:31:17.490
在这里，它抓住了JRE，但它也

00:31:11.520 --> 00:31:18.300
抓了没抓啊我知道了

00:31:17.490 --> 00:31:21.900
问题是

00:31:18.300 --> 00:31:25.679
我推罐子不是战争

00:31:21.900 --> 00:31:30.510
非常感谢您，我们将继续

00:31:25.679 --> 00:31:33.120
杀死它，让我告诉你

00:31:30.510 --> 00:31:36.570
在第一次的大屠杀中

00:31:33.120 --> 00:31:38.610
建成我们建成了罐子，但当我建立

00:31:36.570 --> 00:31:41.010
相反，所有这些都在

00:31:38.610 --> 00:31:44.760
 github你可以看到其中的区别

00:31:41.010 --> 00:31:46.350
构建Gradle构建文件，因此

00:31:44.760 --> 00:31:50.040
 Gradle构建文件是唯一的

00:31:46.350 --> 00:31:53.670
从f2与嵌入到

00:31:50.040 --> 00:31:54.510
 f2与外部tomcat无关

00:31:53.670 --> 00:31:57.330
在代码中

00:31:54.510 --> 00:31:59.850
一点都没有

00:31:57.330 --> 00:32:02.790
构建，您会看到我们所做的

00:31:59.850 --> 00:32:05.100
相反，我们建立了战争文件，所以

00:32:02.790 --> 00:32:06.990
而不是将jar文件推送到

00:32:05.100 --> 00:32:10.620
当然，我有同样的事情，让我们开始吧

00:32:06.990 --> 00:32:12.660
向前推动战争档案，现在

00:32:10.620 --> 00:32:14.940
您现在将看到差异

00:32:12.660 --> 00:32:18.330
顺便说一句，这是12 

00:32:14.940 --> 00:32:22.350
因素罐点原始，那是

00:32:18.330 --> 00:32:22.980
因为 Spring 的Gradle插件

00:32:22.350 --> 00:32:25.679
开机

00:32:22.980 --> 00:32:28.020
所以罐子里有Gradle插件

00:32:25.679 --> 00:32:30.240
足够复杂，以至于

00:32:28.020 --> 00:32:32.820
来为创建Gradle插件

00:32:30.240 --> 00:32:34.530
他们不想重复的 spring boot 

00:32:32.820 --> 00:32:37.290
 Gradle插件中的所有内容

00:32:34.530 --> 00:32:40.350
罐子的方式，这样的 Spring 引导

00:32:37.290 --> 00:32:42.210
 Gradle插件可以用吗

00:32:40.350 --> 00:32:45.570
 spring boot 对不起

00:32:42.210 --> 00:32:47.790
使用jar Gradle插件

00:32:45.570 --> 00:32:49.830
那是那个原始的输出

00:32:47.790 --> 00:32:52.080
您看到的，然后应用另一个

00:32:49.830 --> 00:32:54.390
插入那个jar文件，这就是为什么

00:32:52.080 --> 00:32:57.179
您在构建中看到了两个jar文件

00:32:54.390 --> 00:32:59.370
目录，所以现在您可以在这里看到

00:32:57.179 --> 00:33:02.790
实际上它确实抓住了少年

00:32:59.370 --> 00:33:03.630
但是后来它也抓住了Tomcat，所以你

00:33:02.790 --> 00:33:07.230
可以在这里看到

00:33:03.630 --> 00:33:10.320
下载Tomcat，它正在扩展Tomcat 

00:33:07.230 --> 00:33:15.990
等等，再次不同的是

00:33:10.320 --> 00:33:20.090
真的只在构建文件中好吗

00:33:15.990 --> 00:33:24.660
对，所以让我们回到我们的代码中

00:33:20.090 --> 00:33:26.610
这是这里的图片

00:33:24.660 --> 00:33:28.560
不同的层次，所以当你

00:33:26.610 --> 00:33:31.110
将应用程序部署到

00:33:28.560 --> 00:33:33.150
平台上您会看到那条大虚线

00:33:31.110 --> 00:33:35.850
记得我说过容器

00:33:33.150 --> 00:33:37.710
实施细节确实是，但是

00:33:35.850 --> 00:33:39.390
那是容器，这就是全部

00:33:37.710 --> 00:33:41.640
容器中正在运行的东西

00:33:39.390 --> 00:33:43.410
您已经拥有主机操作系统，但是

00:33:41.640 --> 00:33:45.570
然后您得到的操作系统映像是

00:33:43.410 --> 00:33:47.490
然后在容器内运行

00:33:45.570 --> 00:33:50.220
你有那个运行时层

00:33:47.490 --> 00:33:51.300
 Tomcat的JDK和也许其他一些

00:33:50.220 --> 00:33:54.120
的东西，然后你有

00:33:51.300 --> 00:33:56.370
顶部的应用程序和问题

00:33:54.120 --> 00:33:58.830
再次是运行时层， 

00:33:56.370 --> 00:34:01.140
您会发现有优点和缺点

00:33:58.830 --> 00:34:03.870
后来当乔希说话时，你会

00:34:01.140 --> 00:34:07.110
看到拥有的价值之一

00:34:03.870 --> 00:34:10.410
这种分层的分离是

00:34:07.110 --> 00:34:13.290
允许平台团队之类的人

00:34:10.410 --> 00:34:15.810
在较低的层上

00:34:13.290 --> 00:34:18.120
此图中的蓝色层，并允许

00:34:15.810 --> 00:34:20.250
应用团队真的要熬夜

00:34:18.120 --> 00:34:21.930
在应用程序世界中，所以您不必

00:34:20.250 --> 00:34:26.310
必须让事物紧密结合

00:34:21.930 --> 00:34:28.110
好了，所以这真的只是

00:34:26.310 --> 00:34:30.270
区别的代码是

00:34:28.110 --> 00:34:33.150
嵌入式运行时，这是

00:34:30.270 --> 00:34:37.380
外部运行时，您必须

00:34:33.150 --> 00:34:39.120
明确不使用Spring 启动插头

00:34:37.380 --> 00:34:41.880
在Gradle插件中，因为这将

00:34:39.120 --> 00:34:43.530
总是带上tomcat，所以你必须

00:34:41.880 --> 00:34:45.900
有点解剖

00:34:43.530 --> 00:34:47.790
而是在这里引入此插件

00:34:45.900 --> 00:34:51.000
该依赖性管理插件和

00:34:47.790 --> 00:34:52.650
在这里指定您的依赖关系

00:34:51.000 --> 00:34:56.340
所有这些都可以在github中找到

00:34:52.650 --> 00:34:57.600
仓库很好，所以还有两个因素

00:34:56.340 --> 00:35:00.030
我要谈论的然后

00:34:57.600 --> 00:35:02.760
我要交给乔希

00:35:00.030 --> 00:35:05.760
第三因子表示配置

00:35:02.760 --> 00:35:07.620
所以你要做的就是存储

00:35:05.760 --> 00:35:09.240
在环境中进行配置

00:35:07.620 --> 00:35:11.820
首先让我们谈谈什么是

00:35:09.240 --> 00:35:12.150
配置，以便配置

00:35:11.820 --> 00:35:14.910
成为

00:35:12.150 --> 00:35:17.270
诸如外部服务句柄之类的东西

00:35:14.910 --> 00:35:21.000
将这些类型的东西数据库化

00:35:17.270 --> 00:35:24.510
凭据（例如，每次部署） 

00:35:21.000 --> 00:35:26.849
值，因此可能是一些网址

00:35:24.510 --> 00:35:31.020
特定于您的Prada策略与您的

00:35:26.849 --> 00:35:33.119
分期部署实际上是

00:35:31.020 --> 00:35:36.119
经历不同的过程

00:35:33.119 --> 00:35:38.160
应用产品

00:35:36.119 --> 00:35:40.650
生命周期中将要发生的一切

00:35:38.160 --> 00:35:43.039
从开发到测试到生产都不同

00:35:40.650 --> 00:35:45.990
其中需要在配置中

00:35:43.039 --> 00:35:47.520
现在我们已经存储了这些东西

00:35:45.990 --> 00:35:52.020
历史上有很多不同

00:35:47.520 --> 00:35:54.839
我们将它们存储在

00:35:52.020 --> 00:35:56.420
代码，感谢我的同事马特

00:35:54.839 --> 00:35:59.880
斯坦因船长

00:35:56.420 --> 00:36:01.770
括号在这里是的，你

00:35:59.880 --> 00:36:04.619
不应该对您的内容进行硬编码

00:36:01.770 --> 00:36:05.760
代码，但这里有多少人有代码

00:36:04.619 --> 00:36:08.670
在可能存在的地方

00:36:05.760 --> 00:36:13.109
硬编码的配置，我们都可以

00:36:08.670 --> 00:36:15.299
不只是您的属性文件不

00:36:13.109 --> 00:36:17.039
将它们放在属性文件中等待什么

00:36:15.299 --> 00:36:19.440
分钟不是我应该做的

00:36:17.039 --> 00:36:24.089
这样做，您将在其中看到一个示例

00:36:19.440 --> 00:36:26.130
只是一点，所以答案通常是

00:36:24.089 --> 00:36:27.569
您将要检查的东西- 

00:36:26.130 --> 00:36:29.910
您将要检查财产

00:36:27.569 --> 00:36:32.730
文件放入您的源代码控制

00:36:29.910 --> 00:36:36.180
系统，所以你不想要这样的事情

00:36:32.730 --> 00:36:37.859
那里的凭据，所以属性文件

00:36:36.180 --> 00:36:39.690
通常不是一件好事

00:36:37.859 --> 00:36:42.210
问题是属性文件几乎

00:36:39.690 --> 00:36:44.789
总是内置在罐子或战争中

00:36:42.210 --> 00:36:46.680
归档，记得我说过一条规则

00:36:44.789 --> 00:36:49.470
是你不打算做一个新的

00:36:46.680 --> 00:36:51.150
在您生命周期的每个阶段进行构建

00:36:49.470 --> 00:36:54.569
要做一个建造很多部署

00:36:51.150 --> 00:36:57.150
那是另一个因素

00:36:54.569 --> 00:36:58.950
我们谈论的下一个

00:36:57.150 --> 00:37:00.690
应用服务器，我们在哪里

00:36:58.950 --> 00:37:03.059
要很好地存储它，我们要

00:37:00.690 --> 00:37:05.099
将其存储在环境中，让我们

00:37:03.059 --> 00:37:09.240
看一下让我们跳过去

00:37:05.099 --> 00:37:15.960
到我们的代码中，我要做

00:37:09.240 --> 00:37:19.020
查看另一个分支环境

00:37:15.960 --> 00:37:22.200
配置，我们在这里是

00:37:19.020 --> 00:37:24.900
相同的应用程序，但现在我要

00:37:22.200 --> 00:37:25.440
用环境对其进行参数化

00:37:24.900 --> 00:37:28.650
变量

00:37:25.440 --> 00:37:33.870
所以让我继续做下去

00:37:28.650 --> 00:37:35.880
这个，然后我们将继续进行部署

00:37:33.870 --> 00:37:39.120
在部署过程中，我将采取

00:37:35.880 --> 00:37:42.480
看一下代码，所以我要推

00:37:39.120 --> 00:37:44.310
我实际上要回到我的

00:37:42.480 --> 00:37:48.780
 jar文件，因为我要做

00:37:44.310 --> 00:37:50.400
现在，嵌入式应用程序中的所有内容都可以

00:37:48.780 --> 00:37:55.320
我在放手的时候过来

00:37:50.400 --> 00:37:57.390
部署，我要知道

00:37:55.320 --> 00:37:58.950
您看不到顶部的网址不是

00:37:57.390 --> 00:38:04.100
如此重要，让我们来

00:37:58.950 --> 00:38:07.470
在这里进入环境

00:38:04.100 --> 00:38:08.670
配置，所以我现在要做的是

00:38:07.470 --> 00:38:12.270
已经改变了

00:38:08.670 --> 00:38:14.900
我改变了控制器的大小

00:38:12.270 --> 00:38:19.260
可能还不够

00:38:14.900 --> 00:38:21.450
更好吗，关键是

00:38:19.260 --> 00:38:24.120
我们在这里看的是

00:38:21.450 --> 00:38:27.000
超级简单，我们要放东西

00:38:24.120 --> 00:38:28.620
在环境变量中现在如何

00:38:27.000 --> 00:38:30.030
事物进入环境

00:38:28.620 --> 00:38:33.090
完全不同的变量

00:38:30.030 --> 00:38:34.530
讨论，让我们了解如何

00:38:33.090 --> 00:38:36.600
这些环境变量，实际上

00:38:34.530 --> 00:38:38.700
当乔希说话时，您会看到其中的一些

00:38:36.600 --> 00:38:41.040
关于其他一些因素

00:38:38.700 --> 00:38:42.600
片刻，但假设我们已经

00:38:41.040 --> 00:38:45.150
环境变量中的东西是什么

00:38:42.600 --> 00:38:46.350
作为一名应用程序开发人员，我做得如何？ 

00:38:45.150 --> 00:38:49.050
我将要使用的是

00:38:46.350 --> 00:38:51.450
 Spring 有空所以 Spring 给我

00:38:49.050 --> 00:38:53.490
这些库让我能够

00:38:51.450 --> 00:38:56.100
非常了解环境变量

00:38:53.490 --> 00:38:58.410
我很快实现了环境

00:38:56.100 --> 00:39:00.180
你可以在这里看到我正在抓那些

00:38:58.410 --> 00:39:01.890
环境变量，所以这是

00:39:00.180 --> 00:39:04.770
我感兴趣的环境变量

00:39:01.890 --> 00:39:07.560
在其中一个叫做谁然后

00:39:04.770 --> 00:39:09.660
我同时更改了问候语

00:39:07.560 --> 00:39:14.820
这应该已经部署了，实际上

00:39:09.660 --> 00:39:17.580
这样做，如果我再次卷曲，你可以看到

00:39:14.820 --> 00:39:20.610
问候为空，因此环境

00:39:17.580 --> 00:39:22.470
变量尚未设置

00:39:20.610 --> 00:39:24.750
环境变量当然在

00:39:22.470 --> 00:39:26.910
云中的容器如何

00:39:24.750 --> 00:39:30.810
我能很好地将事情放在云端吗

00:39:26.910 --> 00:39:34.470
 Cloud Foundry有一个很好的小命令

00:39:30.810 --> 00:39:36.660
称为set env，它使您能够

00:39:34.470 --> 00:39:38.579
这是我们要去的另一种

00:39:36.660 --> 00:39:42.839
片刻之后，我就可以

00:39:38.579 --> 00:39:46.319
将环境变量设置为值

00:39:42.839 --> 00:39:48.119
然后我需要说的是CF 

00:39:46.319 --> 00:39:51.150
休息，但我实际上要去做

00:39:48.119 --> 00:39:53.190
重新启动，我会在一个

00:39:51.150 --> 00:39:56.280
即将重启应用的那一刻

00:39:53.190 --> 00:39:59.490
现在我们休息说我要去

00:39:56.280 --> 00:40:02.280
为此创建一个新版本

00:39:59.490 --> 00:40:04.200
情况我知道我的代码正在查找

00:40:02.280 --> 00:40:07.260
在看环境变量

00:40:04.200 --> 00:40:09.690
在启动时就没有使用那些

00:40:07.260 --> 00:40:12.540
发布时的环境变量

00:40:09.690 --> 00:40:13.920
如果使用了那些

00:40:12.540 --> 00:40:15.660
发布时的环境变量

00:40:13.920 --> 00:40:18.150
那时候我就不得不

00:40:15.660 --> 00:40:19.980
休息一下，但在这种情况下，我没有

00:40:18.150 --> 00:40:21.930
需要创建一个新版本，因为

00:40:19.980 --> 00:40:25.710
该环境变量仅受影响

00:40:21.930 --> 00:40:29.460
运行时行为，所以现在如果我进入

00:40:25.710 --> 00:40:33.359
并卷曲它，你可以说看到它说

00:40:29.460 --> 00:40:36.589
来自 spring boot 的乔什问候

00:40:33.359 --> 00:40:41.180
环境存储配置

00:40:36.589 --> 00:40:45.420
环境中的配置还可以

00:40:41.180 --> 00:40:48.000
还有一个因素，然后我们会处理

00:40:45.420 --> 00:40:49.560
到乔希那里，所以有一些

00:40:48.000 --> 00:40:51.960
在环境取货的代码

00:40:49.560 --> 00:40:54.450
变量很好，所以现在我们要

00:40:51.960 --> 00:40:56.430
我们从因子1因子2开始

00:40:54.450 --> 00:40:58.920
跳到因子5回到因子

00:40:56.430 --> 00:41:01.319
 2现在我们需要3现在我们要跳

00:40:58.920 --> 00:41:05.099
一直到因子11 

00:41:01.319 --> 00:41:06.480
记录日志，这当然是其中之一

00:41:05.099 --> 00:41:08.579
您需要的是您需要能够阅读

00:41:06.480 --> 00:41:10.740
现在您的应用程序的日志

00:41:08.579 --> 00:41:13.349
部署到云中，我需要

00:41:10.740 --> 00:41:16.470
能够获取这些日志消息，以便

00:41:13.349 --> 00:41:19.710
我要怎么做和答案

00:41:16.470 --> 00:41:21.869
就像环境变量一样

00:41:19.710 --> 00:41:24.329
是一种无处不在的东西

00:41:21.869 --> 00:41:27.180
存在于所有

00:41:24.329 --> 00:41:30.150
所有语言都可以访问

00:41:27.180 --> 00:41:32.609
一个事实上的标准，还有另一个

00:41:30.150 --> 00:41:35.160
在这里可用的事实标准

00:41:32.609 --> 00:41:36.810
日志端，这只是发送

00:41:35.160 --> 00:41:40.170
在本标准中标准化的事情

00:41:36.810 --> 00:41:42.750
错误，因此如果您设置发送日志

00:41:40.170 --> 00:41:46.170
文件到某些地方的特殊日志文件

00:41:42.750 --> 00:41:47.950
在某个目录中然后

00:41:46.170 --> 00:41:49.570
环境正在流传那些法律

00:41:47.950 --> 00:41:51.610
因为你将不得不了解

00:41:49.570 --> 00:41:53.710
该目录，或者如果您要

00:41:51.610 --> 00:41:56.260
流很多，如果你要写你的

00:41:53.710 --> 00:41:58.690
将您的日志数据记录到一些文件中

00:41:56.260 --> 00:42:00.190
数据库，那么系统将不得不

00:41:58.690 --> 00:42:03.040
知道从中获取日志

00:42:00.190 --> 00:42:05.410
数据库等等

00:42:03.040 --> 00:42:06.910
平台可以做的就是，如果我们只是说看

00:42:05.410 --> 00:42:08.680
只是把东西发送到标准

00:42:06.910 --> 00:42:10.630
标准错误，然后平台说

00:42:08.680 --> 00:42:12.880
我从那里拿走我就走

00:42:10.630 --> 00:42:15.040
向前拿那些东西，所以

00:42:12.880 --> 00:42:17.980
真正要做的事情，所以让我们

00:42:15.040 --> 00:42:24.430
看一下，所以如果我们回来

00:42:17.980 --> 00:42:28.960
在这里，我要进行git checkout f11 

00:42:24.430 --> 00:42:32.920
我要继续做我的

00:42:28.960 --> 00:42:34.150
建立，我们将建立

00:42:32.920 --> 00:42:35.710
很快，然后

00:42:34.150 --> 00:42:44.200
部署，我们将看一看

00:42:35.710 --> 00:42:46.600
在代码上，所以有我的推动

00:42:44.200 --> 00:42:49.630
所以让我们过来看看

00:42:46.600 --> 00:42:55.710
在代码的推动下， 

00:42:49.630 --> 00:42:59.530
进入我的f11分支，进入日志

00:42:55.710 --> 00:43:02.380
这里应用程序的主要变化

00:42:59.530 --> 00:43:04.480
我当然已经添加了所有

00:43:02.380 --> 00:43:07.360
标准的东西，所以如果我来这里

00:43:04.480 --> 00:43:09.970
在主要和你好，你可以看到

00:43:07.360 --> 00:43:13.540
我添加的控制器

00:43:09.970 --> 00:43:15.040
记录器的东西，在这里您可以看到

00:43:13.540 --> 00:43:19.890
我添加了更长的内容， 

00:43:15.040 --> 00:43:22.720
添加了调试消息，因此记录调试和

00:43:19.890 --> 00:43:25.020
还有其他一些日志信息

00:43:22.720 --> 00:43:27.430
在启动时在应用程序方面

00:43:25.020 --> 00:43:30.130
所以这很简单

00:43:27.430 --> 00:43:32.980
东西，一切都很好，但是

00:43:30.130 --> 00:43:34.810
我们想更进一步

00:43:32.980 --> 00:43:38.020
当您进行日志记录时，您将

00:43:34.810 --> 00:43:39.520
具有不同级别的信息调试所有

00:43:38.020 --> 00:43:42.280
这些东西，你将拥有那些

00:43:39.520 --> 00:43:44.800
不同的水平，所以不是很好

00:43:42.280 --> 00:43:47.530
如果我能控制那些水平而没有

00:43:44.800 --> 00:43:50.980
必须在某个地方进行重建

00:43:47.530 --> 00:43:52.900
答案是你绝对可以

00:43:50.980 --> 00:43:54.730
如果我们来到这里，你会

00:43:52.900 --> 00:43:56.740
请注意，我们已经添加了资源

00:43:54.730 --> 00:43:58.980
目录，在这里我们有一个

00:43:56.740 --> 00:44:01.270
应用程序yamo文件和那个

00:43:58.980 --> 00:44:04.360
应用程序

00:44:01.270 --> 00:44:09.310
正确识别并实际定义

00:44:04.360 --> 00:44:12.070
这些属性的值

00:44:09.310 --> 00:44:15.120
正在查看日志记录包，以便

00:44:12.070 --> 00:44:18.730
日志记录包正在查看

00:44:15.120 --> 00:44:21.250
属性记录点级别点，然后

00:44:18.730 --> 00:44:22.990
哪个包，以便您设置

00:44:21.250 --> 00:44:26.050
每个软件包的日志记录级别

00:44:22.990 --> 00:44:29.980
个别地，所以这是一个地方

00:44:26.050 --> 00:44:33.610
您可以定义这些内容，但请等待

00:44:29.980 --> 00:44:36.070
分钟不只是在

00:44:33.610 --> 00:44:37.750
上一个你不应该的

00:44:36.070 --> 00:44:40.210
有一些你应该配置的东西

00:44:37.750 --> 00:44:42.550
环境中没有的东西

00:44:40.210 --> 00:44:45.370
属性文件不只是一个

00:44:42.550 --> 00:44:50.200
属性文件，答案是肯定的

00:44:45.370 --> 00:44:52.750
但是，此属性文件是唯一的

00:44:50.200 --> 00:44:56.110
我们正在使用的唯一东西是

00:44:52.750 --> 00:45:00.000
我们正在使用它来拥有一棵树

00:44:56.110 --> 00:45:02.980
结构到我的属性，以便那些日志

00:45:00.000 --> 00:45:04.960
包期望这个特殊

00:45:02.980 --> 00:45:07.540
属性的树结构和

00:45:04.960 --> 00:45:11.890
您会注意到此语法的作用

00:45:07.540 --> 00:45:17.050
就在这里，这种语法定义了

00:45:11.890 --> 00:45:19.660
信息的默认值，但它表示查找

00:45:17.050 --> 00:45:22.240
来自环境的实际价值

00:45:19.660 --> 00:45:26.200
变量，所以我马上回到

00:45:22.240 --> 00:45:28.930
环境变量就可以了

00:45:26.200 --> 00:45:32.820
让我们过去看看这个内置的

00:45:28.930 --> 00:45:36.400
很好，实际上让我重新

00:45:32.820 --> 00:45:38.890
窗口做一个哦，我想检查一下

00:45:36.400 --> 00:45:48.460
这是大鼓声吗？ 

00:45:38.890 --> 00:45:56.820
到位CF日志代理，看看是不是

00:45:48.460 --> 00:45:56.820
一家CF Apps Co 

00:46:00.150 --> 00:46:08.880
好吧，这是拖尾日志，这是一个

00:46:03.820 --> 00:46:08.880
好兆头，所以如果我现在卷曲这个端点

00:46:09.540 --> 00:46:18.010
乔希和鼓声的问候，我们去了

00:46:15.190 --> 00:46:20.109
我们得到一些输出，但是其中之一

00:46:18.010 --> 00:46:22.930
首先，我会注意到

00:46:20.109 --> 00:46:25.300
没有得到我打算和某人打招呼

00:46:22.930 --> 00:46:27.940
那是因为默认情况下我的日志

00:46:25.300 --> 00:46:30.490
级别设置为信息，我们将向您展示

00:46:27.940 --> 00:46:32.770
设置一下，但是你会

00:46:30.490 --> 00:46:35.320
注意我还是得到了一些日志输出

00:46:32.770 --> 00:46:37.060
这实际上是日志输出， 

00:46:35.320 --> 00:46:40.060
平台提供的不是

00:46:37.060 --> 00:46:42.070
应用程序日志实际上是

00:46:40.060 --> 00:46:44.470
关于应用程序的上下文

00:46:42.070 --> 00:46:47.650
在运行，所以这表明一条消息

00:46:44.470 --> 00:46:49.570
被路由到我的应用程序，所以让我们

00:46:47.650 --> 00:46:52.839
回来这里，我要去做

00:46:49.570 --> 00:46:55.900
再次设置环境，我现在要

00:46:52.839 --> 00:47:04.480
设置该日志级别进行调试，我

00:46:55.900 --> 00:47:08.080
要进行CF重新启动，我们去了

00:47:04.480 --> 00:47:10.420
那只需要片刻

00:47:08.080 --> 00:47:12.490
然后我们再顺便卷曲一下

00:47:10.420 --> 00:47:15.220
您可以查看所有日志信息

00:47:12.490 --> 00:47:16.990
如果我们重新启动会在这里出现

00:47:15.220 --> 00:47:19.030
有更多的时间我会经历这个

00:47:16.990 --> 00:47:20.770
看到这非常有趣

00:47:19.030 --> 00:47:22.720
平台在您身上做什么

00:47:20.770 --> 00:47:24.849
代表您在此重新启动

00:47:22.720 --> 00:47:27.070
应用程序，因此您可以在此处看到

00:47:24.849 --> 00:47:30.310
有一些DEA消息有一些

00:47:27.070 --> 00:47:31.780
 API消息（如果我们在此查找） 

00:47:30.310 --> 00:47:34.480
你可以看到有一堆

00:47:31.780 --> 00:47:37.240
其实有 Spring 

00:47:34.480 --> 00:47:40.839
开机徽标应该在这里弹出

00:47:37.240 --> 00:47:44.880
某处有很多信息

00:47:40.839 --> 00:47:47.920
出现的消息很多

00:47:44.880 --> 00:47:52.660
好，现在应用程序启动了

00:47:47.920 --> 00:47:56.109
让我们继续并卷曲它，我们应该

00:47:52.660 --> 00:47:59.589
一会儿在这里看到

00:47:56.109 --> 00:48:01.810
我打算和某人打招呼，所以

00:47:59.589 --> 00:48:03.369
调试消息，以便再次看到

00:48:01.810 --> 00:48:07.390
我们如何通过控制

00:48:03.369 --> 00:48:09.520
环境变量好吧，让我们来

00:48:07.390 --> 00:48:10.720
回到这里，回到

00:48:09.520 --> 00:48:13.839
滑梯

00:48:10.720 --> 00:48:15.579
我确实有一个重点

00:48:13.839 --> 00:48:17.260
即使我们做了现场演示

00:48:15.579 --> 00:48:19.480
喜欢把那些放在幻灯片中

00:48:17.260 --> 00:48:21.520
稍后您的备忘单，我看到

00:48:19.480 --> 00:48:24.880
有人拍张照片，让你拍

00:48:21.520 --> 00:48:26.829
您的照片，然后我们继续

00:48:24.880 --> 00:48:28.240
所以我要交给乔希

00:48:26.829 --> 00:48:31.680
还要经历一大堆

00:48:28.240 --> 00:48:31.680
因素是问题

00:48:41.140 --> 00:48:45.980
是的，事实上，您会注意到

00:48:44.270 --> 00:48:47.990
该问题是否重复该问题

00:48:45.980 --> 00:48:49.609
您正在将一切标准化

00:48:47.990 --> 00:48:52.069
在标准错误中，我们有一个

00:48:49.609 --> 00:48:54.950
我们常用的最喜欢的工具

00:48:52.069 --> 00:48:56.869
解析出来，答案是

00:48:54.950 --> 00:48:59.869
绝对，所以你会注意到，当我

00:48:56.869 --> 00:49:02.000
 CF记录了我已经使用过的空间应用程序名称

00:48:59.869 --> 00:49:04.760
已经采取一切损害

00:49:02.000 --> 00:49:06.829
只是应用程序，所以我有

00:49:04.760 --> 00:49:08.779
平台日志之类的东西，但是

00:49:06.829 --> 00:49:10.579
只是平台消息

00:49:08.779 --> 00:49:12.319
与该应用有关

00:49:10.579 --> 00:49:14.390
所以实际上有一些内置的东西

00:49:12.319 --> 00:49:17.270
 Cloud Foundry使您可以进行范围调整

00:49:14.390 --> 00:49:17.960
您的日志到应用程序，所以

00:49:17.270 --> 00:49:20.660
第一

00:49:17.960 --> 00:49:22.430
那接下来的事情就很好了

00:49:20.660 --> 00:49:24.640
一堆日志信息

00:49:22.430 --> 00:49:27.319
在那里我如何解析我们

00:49:24.640 --> 00:49:29.119
实际使用许多不同的工具

00:49:27.319 --> 00:49:31.700
我们在操作自己时

00:49:29.119 --> 00:49:34.549
生产中的应用我们使用的东西

00:49:31.700 --> 00:49:37.039
就像我们可能会使用日志存储或

00:49:34.549 --> 00:49:39.109
 Splunk的另一件事是Cloud 

00:49:37.039 --> 00:49:42.920
与公司的代工伙伴

00:49:39.109 --> 00:49:47.109
使用ALK解决方案，您可以

00:49:42.920 --> 00:49:49.569
将这些日志通过管道传送到LK Cabana 

00:49:47.109 --> 00:49:51.859
环境，然后做各种我

00:49:49.569 --> 00:49:53.779
可以给你看一些真的很酷

00:49:51.859 --> 00:49:54.200
在其上内置的仪表板

00:49:53.779 --> 00:49:56.930
好

00:49:54.200 --> 00:49:58.220
所以答案是有很多

00:49:56.930 --> 00:50:00.410
 Cloud Foundry中内置的内容

00:49:58.220 --> 00:50:03.319
平台，然后您也可能

00:50:00.410 --> 00:50:08.029
与一些外部日志搜索集成

00:50:03.319 --> 00:50:10.420
和分析工具，还可以

00:50:08.029 --> 00:50:10.420
另一个问题

00:50:14.789 --> 00:50:26.829
它正在运行多个实例，而您的

00:50:18.009 --> 00:50:28.809
问题是什么啊，那么日志会

00:50:26.829 --> 00:50:31.029
基本上有足够的信息

00:50:28.809 --> 00:50:33.940
在那里向您展示哪些实例

00:50:31.029 --> 00:50:36.130
日志消息来自

00:50:33.940 --> 00:50:38.289
一个更复杂的答案，但也许我们可以

00:50:36.130 --> 00:50:40.900
之后聊一点，因为我们

00:50:38.289 --> 00:50:42.910
仍然有很多信息可以解决

00:50:40.900 --> 00:50:47.979
好吧，让我关闭并交给它

00:50:42.910 --> 00:50:50.289
谢谢乔什，所以我们聊了

00:50:47.979 --> 00:50:51.400
关于12个因素以及您的消费方式

00:50:50.289 --> 00:50:53.229
来自环境的东西

00:50:51.400 --> 00:50:54.819
环境也提出了一些要求

00:50:53.229 --> 00:50:56.410
在您和您的应用程序上以及如何

00:50:54.819 --> 00:50:59.380
您建立正确的12个因素集

00:50:56.410 --> 00:51:02.410
公理是最重要的公理之一

00:50:59.380 --> 00:51:04.930
表面上看起来真的很普通

00:51:02.410 --> 00:51:07.239
就需求而言，就是你

00:51:04.930 --> 00:51:08.799
必须快速启动您拥有的原因

00:51:07.239 --> 00:51:11.109
快速启动是您无法执行此列表

00:51:08.799 --> 00:51:14.170
如果不部署规模的话

00:51:11.109 --> 00:51:15.640
发布和恢复云是

00:51:14.170 --> 00:51:19.479
最多会杀死你几天

00:51:15.640 --> 00:51:21.279
 AWS数据中心中的硬件模具将

00:51:19.479 --> 00:51:22.690
将VM从您下方移入

00:51:21.279 --> 00:51:24.160
 Cloud Foundry对各种东西的权利

00:51:22.690 --> 00:51:25.779
发生，所以如果您的应用程序无法启动

00:51:24.160 --> 00:51:27.130
很快您就无法从中恢复

00:51:25.779 --> 00:51:31.299
只是正常的日常情况

00:51:27.130 --> 00:51:33.039
操作还必须关闭

00:51:31.299 --> 00:51:35.739
收到信号后优雅地

00:51:33.039 --> 00:51:39.069
正确的部门通常需要

00:51:35.739 --> 00:51:40.959
这基本上是这样，如果

00:51:39.069 --> 00:51:42.339
如果我们看典型的

00:51:40.959 --> 00:51:44.709
我在职业生涯中遇到的问题

00:51:42.339 --> 00:51:46.150
应用没有正常关闭我结束

00:51:44.709 --> 00:51:48.069
处理锁定作业和

00:51:46.150 --> 00:51:49.959
我最终发现的数据库很晚

00:51:48.069 --> 00:51:52.089
数据库连接挂起，然后我的

00:51:49.959 --> 00:51:53.589
 SAS数据库服务之类的哦

00:51:52.089 --> 00:51:56.650
 50个您无法再拥有的连接

00:51:53.589 --> 00:51:58.180
你也开始失去对

00:51:56.650 --> 00:51:59.499
你在哪里所以你必须采取这个

00:51:58.180 --> 00:52:02.589
当你考虑到某种东西

00:51:59.499 --> 00:52:03.670
构建和设计您的应用，以便

00:52:02.589 --> 00:52:05.199
需要记住的东西

00:52:03.670 --> 00:52:08.229
您会看到我们拥有的应用

00:52:05.199 --> 00:52:09.969
它的基本启动甚至很快

00:52:08.229 --> 00:52:11.739
大型Spring Boot应用倾向于启动

00:52:09.969 --> 00:52:14.199
很快，只要你不在

00:52:11.739 --> 00:52:15.969
从数据库加载一堆数据

00:52:14.199 --> 00:52:18.819
在公开休息界面之前先说

00:52:15.969 --> 00:52:20.529
你还可以记住另一件事

00:52:18.819 --> 00:52:22.420
关于这个权利是12个因素是

00:52:20.529 --> 00:52:23.830
由平台提供商撰写，就像

00:52:22.420 --> 00:52:26.770
 Cloud Foundry Heroku GAE 

00:52:23.830 --> 00:52:28.600
 Bua通行证，我们必须变得聪明

00:52:26.770 --> 00:52:30.250
关于您的应用程序的决定，我们

00:52:28.600 --> 00:52:32.740
只能从开始做起

00:52:30.250 --> 00:52:33.910
有超时的概念，所以

00:52:32.740 --> 00:52:35.500
如果您的应用程序没有出现

00:52:33.910 --> 00:52:37.510
我们必须称其为死时间

00:52:35.500 --> 00:52:39.040
所以快速开始对

00:52:37.510 --> 00:52:43.570
在这些环境中取得成功

00:52:39.040 --> 00:52:46.720
我认为第四要素确实是最重要的

00:52:43.570 --> 00:52:48.760
重要的是它基本上说

00:52:46.720 --> 00:52:50.260
您必须访问我们的所有内容

00:52:48.760 --> 00:52:51.760
穿过环境Cornelia 

00:52:50.260 --> 00:52:54.100
已经给我们展示了一个例子

00:52:51.760 --> 00:52:56.080
我们通过一个

00:52:54.100 --> 00:52:57.430
环境变量，但这会得到更多

00:52:56.080 --> 00:52:58.990
当我们开始看看我们的

00:52:57.430 --> 00:53:00.850
应用程序，它们是

00:52:58.990 --> 00:53:03.070
我们拥有数据库的真实拓扑

00:53:00.850 --> 00:53:04.420
我们有消息队列，我们​​有那些

00:53:03.070 --> 00:53:06.310
数据库和消息队列非常

00:53:04.420 --> 00:53:08.850
不同的环境，所以我们必须

00:53:06.310 --> 00:53:10.810
有办法拿走这件神器

00:53:08.850 --> 00:53:12.580
指向两个不同的数据库， 

00:53:10.810 --> 00:53:14.650
每次我们有不同的消息队列

00:53:12.580 --> 00:53:16.560
部署它，而我们这样做的方式是

00:53:14.650 --> 00:53:18.790
通过定位器访问环境

00:53:16.560 --> 00:53:20.290
所以Cloud Foundry有一个环境

00:53:18.790 --> 00:53:22.020
我们称为vcap服务的变量

00:53:20.290 --> 00:53:24.700
用于对所有这些信息进行编码

00:53:22.020 --> 00:53:25.150
其他系统将使用不同的东西

00:53:24.700 --> 00:53:26.920
我知道

00:53:25.150 --> 00:53:28.930
以Heroku为例， 

00:53:26.920 --> 00:53:33.100
每个连接的环境变量或

00:53:28.930 --> 00:53:34.450
每个后勤服务我们这样做的原因

00:53:33.100 --> 00:53:38.920
这项权利是这样，我们可以更改

00:53:34.450 --> 00:53:40.480
这些东西的位置

00:53:38.920 --> 00:53:42.340
我们将分三步走

00:53:40.480 --> 00:53:43.720
穿过，然后我们看一下

00:53:42.340 --> 00:53:45.760
将其消耗掉的代码

00:53:43.720 --> 00:53:47.200
要做的就是创造你的东西

00:53:45.760 --> 00:53:48.640
需要和你说话，所以这是

00:53:47.200 --> 00:53:51.040
 Cloud Foundry命令启动新的

00:53:48.640 --> 00:53:52.030
我的示例应用程序的续集实例

00:53:51.040 --> 00:53:55.240
那就是我们要存储我们的地方

00:53:52.030 --> 00:53:57.160
信息，这是一个Cloud Foundry 

00:53:55.240 --> 00:53:59.410
命令将连接您的我的

00:53:57.160 --> 00:54:01.750
应用程序的后续实例

00:53:59.410 --> 00:54:03.490
最终的结果是您现在拥有

00:54:01.750 --> 00:54:05.200
您内部的环境变量

00:54:03.490 --> 00:54:06.490
您特定部署中的容器

00:54:05.200 --> 00:54:07.840
告诉您数据库在哪里

00:54:06.490 --> 00:54:09.010
您将拥有一个JDBC连接

00:54:07.840 --> 00:54:11.170
您将插入的字符串

00:54:09.010 --> 00:54:15.550
仅使用用户名和

00:54:11.170 --> 00:54:17.320
最后一个命令的密码

00:54:15.550 --> 00:54:18.460
向右拖动有很多仪式， 

00:54:17.320 --> 00:54:20.770
如果我必须运行所有这些命令

00:54:18.460 --> 00:54:22.720
每次我部署我的应用程序

00:54:20.770 --> 00:54:24.040
有两件事发生了，我们忘记做

00:54:22.720 --> 00:54:26.590
事情，然后我们有意外

00:54:24.040 --> 00:54:28.750
结果或我们的CI系统得到了真正的

00:54:26.590 --> 00:54:30.100
真正复杂的Cloud Foundry具有

00:54:28.750 --> 00:54:32.290
被称为清单的东西可以让我们

00:54:30.100 --> 00:54:33.910
声明我们的应用程序应该是什么

00:54:32.290 --> 00:54:36.190
应该看起来像，应该怎样

00:54:33.910 --> 00:54:36.680
部署，所以我们将使用它

00:54:36.190 --> 00:54:39.440
我们要

00:54:36.680 --> 00:54:40.819
看看不同的是一秒钟， 

00:54:39.440 --> 00:54:42.200
我们会看到我们已经改变了

00:54:40.819 --> 00:54:43.970
我们部署的方式，因此命令将

00:54:42.200 --> 00:54:45.380
变化最大

00:54:43.970 --> 00:54:47.150
重要的事情要打转

00:54:45.380 --> 00:54:49.910
最底层是服务

00:54:47.150 --> 00:54:52.849
我们声明要去的东西

00:54:49.910 --> 00:54:54.500
依赖于服务名称pelo DB，如果

00:54:52.849 --> 00:54:55.700
如果我们不提供该服务就不存在

00:54:54.500 --> 00:54:57.650
看到我们的环境变量

00:54:55.700 --> 00:54:58.970
应用程序将无法部署，这

00:54:57.650 --> 00:55:00.800
是很好的权利，因为现在我们的部署

00:54:58.970 --> 00:55:07.160
将很快失败，因为支持服务

00:55:00.800 --> 00:55:17.660
不见了，所以我会回到这里

00:55:07.160 --> 00:55:17.839
我们会看看支持抱歉

00:55:17.660 --> 00:55:20.950
那

00:55:17.839 --> 00:55:20.950
支持服务

00:55:27.650 --> 00:55:31.070
所以首先要注意的是

00:55:29.540 --> 00:55:34.640
清单，我们刚刚在幻灯片中看到了

00:55:31.070 --> 00:55:38.660
这是我们内部的同一件事

00:55:34.640 --> 00:55:40.850
 Gradle构建或构建文件，我们制作了一个

00:55:38.660 --> 00:55:43.130
如果您有几个新的声明

00:55:40.850 --> 00:55:44.750
特别是去过Spring Cloud

00:55:43.130 --> 00:55:46.640
他们谈论过的 Spring 的云谈话

00:55:44.750 --> 00:55:47.180
关于应该看起来的连接器

00:55:46.640 --> 00:55:48.920
熟悉的

00:55:47.180 --> 00:55:50.300
我们包括对

00:55:48.920 --> 00:55:51.890
服务连接库，然后

00:55:50.300 --> 00:55:53.330
我们包括了对

00:55:51.890 --> 00:55:55.010
 Cloud的服务连接库

00:55:53.330 --> 00:55:57.080
我刚才说过的铸造厂

00:55:55.010 --> 00:55:58.940
平台将在

00:55:57.080 --> 00:56:00.140
不同的方式或这些在树中的配置

00:55:58.940 --> 00:56:03.010
以不同的方式，这就是

00:56:00.140 --> 00:56:05.330
了解Cloud Foundry是如何做到的

00:56:03.010 --> 00:56:06.560
我们包括了另外两个库

00:56:05.330 --> 00:56:08.810
我会在他们对面越过它们

00:56:06.560 --> 00:56:10.940
我们已经说过的顺序，运行时必须有一个

00:56:08.810 --> 00:56:13.310
我的续集驱动程序，我们也

00:56:10.940 --> 00:56:15.200
声明了对flyweight的依赖，因此

00:56:13.310 --> 00:56:16.430
我们将推送一个应用程序

00:56:15.200 --> 00:56:17.840
需要我们要使用的数据库架构

00:56:16.430 --> 00:56:19.790
只要让举重为我们创造

00:56:17.840 --> 00:56:21.320
现在，我们将回到为什么我们让它

00:56:19.790 --> 00:56:22.580
以不同的方式做到这一点

00:56:21.320 --> 00:56:27.080
当我们谈论

00:56:22.580 --> 00:56:28.490
 12包装其他东西定向

00:56:27.080 --> 00:56:31.690
你自己就是我们做了一些结构上的

00:56:28.490 --> 00:56:31.690
我们服务的变化

00:56:36.230 --> 00:56:41.390
我们的控制器现在有服务

00:56:38.349 --> 00:56:43.250
注入它的自动接线，然后

00:56:41.390 --> 00:56:44.990
我们添加了我们已经更改了

00:56:43.250 --> 00:56:48.369
路线，我们通过了

00:56:44.990 --> 00:56:50.299
作为请求参数打招呼的人

00:56:48.369 --> 00:56:53.240
其他一切都差不多

00:56:50.299 --> 00:56:54.710
我们称我们的服务可以节省我们

00:56:53.240 --> 00:56:56.059
得到我们打招呼的时间

00:56:54.710 --> 00:56:59.450
我们用它做个约会，然后保存

00:56:56.059 --> 00:57:01.359
这个名字是由 Spring 结团支持的

00:56:59.450 --> 00:57:03.770
来自Spring数据的存储库

00:57:01.359 --> 00:57:09.790
它对JPA的数据有何作用？ 

00:57:03.770 --> 00:57:09.790
您可以在其中看到的界面项目

00:57:15.990 --> 00:57:20.160
就在那里，所以这一切看起来

00:57:18.750 --> 00:57:21.780
很普通很漂亮香草

00:57:20.160 --> 00:57:25.050
跳出这似乎会起作用

00:57:21.780 --> 00:57:27.859
几乎在任何地方，所以我们去

00:57:25.050 --> 00:57:27.859
我们将检查这个应用程序

00:57:54.290 --> 00:58:02.510
我们生活在边缘，看看是否需要

00:57:56.270 --> 00:58:11.360
这些命令很贴心，所以我们继续

00:58:02.510 --> 00:58:15.680
并建立这个，我要去做蓝色

00:58:11.360 --> 00:58:18.550
绿色，让Cornelia很好

00:58:15.680 --> 00:58:20.750
如果我们看看我们现在拥有的应用程序

00:58:18.550 --> 00:58:22.100
我们有我们原始的应用程序，它仍然

00:58:20.750 --> 00:58:24.560
启动并运行它没有连接到

00:58:22.100 --> 00:58:28.250
除了URL知道的任何东西

00:58:24.560 --> 00:58:29.600
你好1212 f dot c FF在IO处窥探到

00:58:28.250 --> 00:58:31.220
演示文稿的其余部分将视为

00:58:29.600 --> 00:58:32.990
这是我们的生产网址，我们将推送

00:58:31.220 --> 00:58:34.610
我们的应用程序将与他们混乱

00:58:32.990 --> 00:58:36.770
验证它们是否有效，然后我们将削减

00:58:34.610 --> 00:58:39.500
过度生产，所以这是人们的方式

00:58:36.770 --> 00:58:42.020
将会从中了解我们的应用

00:58:39.500 --> 00:58:43.850
外界，所以命令有

00:58:42.020 --> 00:58:45.920
改变了一点，我将要

00:58:43.850 --> 00:58:49.600
为了安全起见，请确保我们进行清理

00:58:45.920 --> 00:58:49.600
我们的环境，因为我很偏执

00:58:59.619 --> 00:59:04.089
所以我刚刚运行的这个命令说垃圾

00:59:02.019 --> 00:59:05.529
我的数据库将环境设置为

00:59:04.089 --> 00:59:07.059
正常，我认为我们已经做到了，但是我

00:59:05.529 --> 00:59:11.049
只是有种可怕的想法

00:59:07.059 --> 00:59:12.430
我不希望演示失败，所以我已经

00:59:11.049 --> 00:59:13.660
让Cloud Foundry重新振兴我们

00:59:12.430 --> 00:59:15.640
我的续集实例

00:59:13.660 --> 00:59:19.869
以后绑定到这个将给我们一个空

00:59:15.640 --> 00:59:27.489
数据库，到此为止

00:59:19.869 --> 00:59:28.930
完成后，我们将向上推送该应用程序，以便您可以

00:59:27.489 --> 00:59:31.269
看到几件事发生了变化

00:59:28.930 --> 00:59:33.999
我们的输出权，我们正在推动相同

00:59:31.269 --> 00:59:36.160
应用程序，但名称已更改，因此我们将

00:59:33.999 --> 00:59:37.630
有两个不同的两个实例

00:59:36.160 --> 00:59:39.819
本质上运行的应用程序版本

00:59:37.630 --> 00:59:41.109
为我们创造了一条随机路线

00:59:39.819 --> 00:59:43.539
因为我不想大惊小怪

00:59:41.109 --> 00:59:45.759
与不匹配并且找不到URL 

00:59:43.539 --> 00:59:49.079
所以它只是产生了一堆随机

00:59:45.759 --> 00:59:49.079
对我们而言，我们的应用程序名称后面的单词

00:59:50.339 --> 00:59:54.969
它会尝试使其飞起来

00:59:53.319 --> 00:59:56.259
如果你不熟悉它就走了

00:59:54.969 --> 00:59:57.609
默认情况下，如果您不这样做

00:59:56.259 --> 00:59:59.019
 spring boot 应用中的任何内容

00:59:57.609 --> 01:00:00.729
声明依赖关系，而你只是

00:59:59.019 --> 01:00:02.739
不要再写类似的代码了

01:00:00.729 --> 01:00:04.269
大多数事情都可以，并且它有一个

01:00:02.739 --> 01:00:06.299
默认行为，所以我们有一个数据库

01:00:04.269 --> 01:00:08.710
迁移将为我们创建一个架构

01:00:06.299 --> 01:00:15.430
这是一个非常基本的表，可以映射到

01:00:08.710 --> 01:00:17.079
我们的班级，我们可以在这里看到它，所以我们

01:00:15.430 --> 01:00:19.839
只需创建一个包含三列的表

01:00:17.079 --> 01:00:22.180
自动生成日期的ID 

01:00:19.839 --> 01:00:23.529
说我什么时候受到欢迎

01:00:22.180 --> 01:00:27.069
然后是我们这个人的名字

01:00:23.529 --> 01:00:28.390
问候这是具体的，我们想

01:00:27.069 --> 01:00:29.499
喊出来，因为那很重要

01:00:28.390 --> 01:00:30.940
当我们谈论时，您会看到

01:00:29.499 --> 01:00:32.710
环境以及它们应该如何

01:00:30.940 --> 01:00:34.329
同样这只会在我身上起作用

01:00:32.710 --> 01:00:35.469
该模式创建的续集权

01:00:34.329 --> 01:00:37.749
不会在另一个平台上工作

01:00:35.469 --> 01:00:39.309
这与我们的工作方式不同

01:00:37.749 --> 01:00:40.960
事情很久了，但是十二点

01:00:39.309 --> 01:00:42.759
因素非常认为，我们应该

01:00:40.960 --> 01:00:46.259
始终使用版本和

01:00:42.759 --> 01:00:48.819
我们打算与我合作的服务类型

01:00:46.259 --> 01:00:51.579
我可能不得不让我的生活更轻松

01:00:48.819 --> 01:00:52.960
正在开发此最初运行的h2 

01:00:51.579 --> 01:00:54.279
在本地，但那时我不得不

01:00:52.960 --> 01:00:55.779
复制所有这些工作

01:00:54.279 --> 01:00:57.489
显然还有其他解决方案

01:00:55.779 --> 01:00:59.289
我是实用主义的忠实粉丝

01:00:57.489 --> 01:01:01.089
什么对您有效，但是如果我们要

01:00:59.289 --> 01:01:02.859
遵循12要素的精神是

01:01:01.089 --> 01:01:05.609
我们只与之互动的指导权

01:01:02.859 --> 01:01:08.920
我的续集，因为那是我们的意图

01:01:05.609 --> 01:01:11.830
所以现在我们的应用程序已启动并正在运行，我们

01:01:08.920 --> 01:01:13.790
可以再次卷曲

01:01:11.830 --> 01:01:21.680
但是我们将不得不使用这个新的

01:01:13.790 --> 01:01:25.220
 URL很抱歉，我更多地使用Cloud Foundry 

01:01:21.680 --> 01:01:26.750
比我卷曲的应用程序，所以我们卷曲它，我们

01:01:25.220 --> 01:01:28.340
看到我们已经添加了默认权限，我们

01:01:26.750 --> 01:01:32.060
看到人们的默认值

01:01:28.340 --> 01:01:35.620
没人欢迎，我们可以得到一点

01:01:32.060 --> 01:01:35.620
更多的正式

01:01:43.070 --> 01:01:50.620
我们可以问候Cornelia我们还添加了一个

01:01:46.970 --> 01:01:50.620
历史API只会给我们

01:01:57.290 --> 01:02:00.230
这样我们可以看到我们已经创建了一个

01:01:58.910 --> 01:02:01.880
几个人，我们得到一些好

01:02:00.230 --> 01:02:04.220
四舍五入的数字，我们将谈论

01:02:01.880 --> 01:02:05.900
大约和我们做的时候差不多

01:02:04.220 --> 01:02:07.490
所以我们在这问候了两个人

01:02:05.900 --> 01:02:09.770
点，我们的应用程序启动并且正在运行

01:02:07.490 --> 01:02:11.060
我们已经决定这很好，让我们开始吧

01:02:09.770 --> 01:02:12.590
继续做，其余的

01:02:11.060 --> 01:02:14.600
我们做到的蓝绿色部署

01:02:12.590 --> 01:02:18.970
这个应用程式会回应生产

01:02:14.600 --> 01:02:23.680
流量也是如此，如果我们运行CF路由

01:02:18.970 --> 01:02:23.680
我们可以说CF地图-路线

01:02:33.160 --> 01:02:37.170
我会用的，因为我没有

01:02:34.540 --> 01:02:37.170
记住命令

01:02:42.700 --> 01:02:49.720
我们将告诉我们应用的名称以及

01:02:45.880 --> 01:02:53.530
我们要添加的域，然后

01:02:49.720 --> 01:02:55.210
我们现在告诉它主机名

01:02:53.530 --> 01:03:00.180
什么时候应该发生一些有趣的事情

01:02:55.210 --> 01:03:00.180
我开始卷曲这个应用程序

01:03:05.000 --> 01:03:13.670
我们说过我们默认之前没有人

01:03:07.069 --> 01:03:17.260
所以我们应该在执行此操作时看到

01:03:13.670 --> 01:03:17.260
请求将在两个应用之间反弹

01:03:29.760 --> 01:03:33.150
因此Cloud Foundry路线

01:03:31.410 --> 01:03:34.800
我们可以在输出中随机看到

01:03:33.150 --> 01:03:36.030
有时它打招呼我有时

01:03:34.800 --> 01:03:37.200
向所有人打招呼，所以大家

01:03:36.030 --> 01:03:38.609
现在相信我，我们正在反弹

01:03:37.200 --> 01:03:41.040
两个实例之间的流量

01:03:38.609 --> 01:03:42.480
应用程序，我们将在这一点上继续前进， 

01:03:41.040 --> 01:03:44.250
决定削减覆盖我们的新版本

01:03:42.480 --> 01:03:46.830
是好的，旧的是坏的，但是我们已经

01:03:44.250 --> 01:03:47.850
零停机时间将其中一个

01:03:46.830 --> 01:03:50.160
有趣的是我们实际上

01:03:47.850 --> 01:03:52.859
进行了重大的功能更改

01:03:50.160 --> 01:03:55.560
在没有用户的情况下我们的应用程序如何工作

01:03:52.859 --> 01:03:56.940
有没有见过停机时间，可能有

01:03:55.560 --> 01:03:59.760
这是我们必须管理的一些事情

01:03:56.940 --> 01:04:02.280
后端，但我们的客户没有看到

01:03:59.760 --> 01:04:03.210
所以我们可以说CF未映射路线

01:04:02.280 --> 01:04:06.230
我们可以变得更具侵略性

01:04:03.210 --> 01:04:06.230
 CF停止

01:04:07.430 --> 01:04:17.760
你好12 F，所以我们可以看到旧的

01:04:13.200 --> 01:04:20.100
版本已停止，如果我们卷曲，我们

01:04:17.760 --> 01:04:21.480
只是看到没有人记录我们

01:04:20.100 --> 01:04:26.609
请注意，我们的历史记录API仍然

01:04:21.480 --> 01:04:27.930
工作我们返回了JSON，所以

01:04:26.609 --> 01:04:30.119
外卖权，我们添加了一个

01:04:27.930 --> 01:04:31.650
数据库，我们部署了应用程序，然后

01:04:30.119 --> 01:04:34.590
并没有在代码中做任何事情

01:04:31.650 --> 01:04:37.400
除了说 Spring Cloud  Spring Cloud 

01:04:34.590 --> 01:04:39.810
 Cloud Foundry和我的续集联系

01:04:37.400 --> 01:04:41.520
 Spring 的云穿过我们

01:04:39.810 --> 01:04:43.320
环境审问了所显示的

01:04:41.520 --> 01:04:49.890
如果我们考虑环境

01:04:43.320 --> 01:04:51.990
我们可以看到它的容器

01:04:49.890 --> 01:04:54.390
注入了一堆不是的东西

01:04:51.990 --> 01:04:56.520
关于我们的数据库之前

01:04:54.390 --> 01:04:59.510
包括主机名和JDBC URL 

01:04:56.520 --> 01:04:59.510
还有其他所有东西

01:05:06.900 --> 01:05:12.410
播放按钮在哪里起作用

01:05:12.560 --> 01:05:15.320
所以这是外卖

01:05:14.120 --> 01:05:16.550
部分，这个因素确实

01:05:15.320 --> 01:05:18.860
重要，因为它是基础

01:05:16.550 --> 01:05:20.720
使我们的代码具有其他功能

01:05:18.860 --> 01:05:22.970
用某物的知识建造

01:05:20.720 --> 01:05:24.740
正确在此实例中构建的代码

01:05:22.970 --> 01:05:26.510
在 Spring 的帮助下，所以我们

01:05:24.740 --> 01:05:28.430
没有什么的卑鄙

01:05:26.510 --> 01:05:30.290
环境变量被称为

01:05:28.430 --> 01:05:31.940
我们看过Python还是看过

01:05:30.290 --> 01:05:35.000
 Ruby或有些东西

01:05:31.940 --> 01:05:36.320
少了Cloud Foundry背后的魔力

01:05:35.000 --> 01:05:37.910
本来会很明确

01:05:36.320 --> 01:05:40.130
我需要一个名为vcap services的变量

01:05:37.910 --> 01:05:42.350
在这种情况下，Spring Cloud照顾我们

01:05:40.130 --> 01:05:47.420
对于我们来说，当我们上演我们的应用程序时， 

01:05:42.350 --> 01:05:49.250
在发布中内置了这些内容，因此我们

01:05:47.420 --> 01:05:51.260
知道必须有一个叫做

01:05:49.250 --> 01:05:53.240
您好在容器中的DB以及当我们

01:05:51.260 --> 01:05:55.820
建立它称为液滴

01:05:53.240 --> 01:05:57.020
我们部署的东西推了所有这些东西

01:05:55.820 --> 01:05:58.870
在那里所有的信息都是

01:05:57.020 --> 01:06:01.190
从那时起对我们可用

01:05:58.870 --> 01:06:03.260
当我们去运行该应用程序时

01:06:01.190 --> 01:06:05.000
开始，它寻找一个东西，它

01:06:03.260 --> 01:06:06.110
用hello DB的名字找到了一个东西

01:06:05.000 --> 01:06:07.550
然后拿出凭证

01:06:06.110 --> 01:06:08.930
能够与之交流

01:06:07.550 --> 01:06:10.820
所以这就是重点

01:06:08.930 --> 01:06:12.560
原因是您必须与

01:06:10.820 --> 01:06:14.480
通过从中使用服务来支持服务

01:06:12.560 --> 01:06:16.640
环境，如果您以其他方式这样做

01:06:14.480 --> 01:06:19.640
你不能四处走动

01:06:16.640 --> 01:06:21.350
可以接受这个申请，我可以

01:06:19.640 --> 01:06:23.990
部署到我们的另一个空间或

01:06:21.350 --> 01:06:30.640
生产环境，所以如果我说看

01:06:23.990 --> 01:06:30.640
如果目标确定什么叫做辅因子

01:06:35.119 --> 01:06:41.630
我们可以在空间中看到我没有应用

01:06:38.559 --> 01:06:43.489
确实有服务，所以我要推动

01:06:41.630 --> 01:06:43.940
我们的应用程序再次，所以我没有改变

01:06:43.489 --> 01:06:45.979
任何东西

01:06:43.940 --> 01:06:50.719
我不会重建任何我要去的东西

01:06:45.979 --> 01:06:52.849
按下拼写推动器，我们将观看该应用程序

01:06:50.719 --> 01:06:54.799
上升，我们将看到一个新的随机URL 

01:06:52.849 --> 01:06:57.229
被生成的是为

01:06:54.799 --> 01:06:58.190
我们，所以我们的应用程序是一个不同的实例

01:06:57.229 --> 01:06:59.509
会以不同的方式回应

01:06:58.190 --> 01:07:00.829
位置，我将讨论不同的数据

01:06:59.509 --> 01:07:02.119
所以一分钟后，我们会

01:07:00.829 --> 01:07:04.489
能够看到数据库是

01:07:02.119 --> 01:07:06.469
空的，但我们这样做的原因是将其写入

01:07:04.489 --> 01:07:09.200
这样我们就可以部署到多个地方

01:07:06.469 --> 01:07:11.299
使生活更轻松的不同原因

01:07:09.200 --> 01:07:12.529
我们将讨论在

01:07:11.299 --> 01:07:14.049
出现时请稍等一下

01:07:12.529 --> 01:07:16.160
我向你们证明它有效

01:07:14.049 --> 01:07:22.700
实际上让我们开始谈论这个

01:07:16.160 --> 01:07:24.410
虽然这样下去，所以下一个因素是

01:07:22.700 --> 01:07:27.049
开发人员模仿模仿权，你可以看到

01:07:24.410 --> 01:07:31.729
我要去生产

01:07:27.049 --> 01:07:35.390
分期应该是一样的相似是

01:07:31.729 --> 01:07:36.950
太好了，我们都参加了

01:07:35.390 --> 01:07:38.900
我们的职业生涯花了很多时间

01:07:36.950 --> 01:07:42.319
产品目录框周围没有出现

01:07:38.900 --> 01:07:43.849
像我的产品盒上的，还是我开发的

01:07:42.319 --> 01:07:45.289
在Mac上，我把东西花在里面

01:07:43.849 --> 01:07:46.969
 Eclipse，然后我想知道为什么它没有

01:07:45.289 --> 01:07:49.969
当我将其运送到任何地方时都可以工作

01:07:46.969 --> 01:07:52.130
不管这些是什么，代码都会转到AWS 

01:07:49.969 --> 01:07:53.660
没有区别的问题

01:07:52.130 --> 01:07:55.339
繁重的举动吧，我们浪费了很多

01:07:53.660 --> 01:08:00.200
时间做一些不该做的事情

01:07:55.339 --> 01:08:01.579
发生这种情况在以下情况下更重要

01:08:00.200 --> 01:08:03.380
我们开始谈论云原生应用

01:08:01.579 --> 01:08:07.009
因为它们是专为持续

01:08:03.380 --> 01:08:08.690
可以持续部署，所以如果我们

01:08:07.009 --> 01:08:10.579
必须经历所有的仪式

01:08:08.690 --> 01:08:11.960
像我签入一样验证

01:08:10.579 --> 01:08:13.190
它可以在我的本地盒子上工作

01:08:11.960 --> 01:08:14.479
在分阶段环境中

01:08:13.190 --> 01:08:16.549
不同，我们将如何去

01:08:14.479 --> 01:08:19.339
知道它可以在这个模仿产品中发挥作用

01:08:16.549 --> 01:08:22.009
变得非常重要，它让

01:08:19.339 --> 01:08:23.599
我们走得快，所以我们在环境中

01:08:22.009 --> 01:08:25.639
今天我们正在努力

01:08:23.599 --> 01:08:27.560
有效的CI环境，我们拥有

01:08:25.639 --> 01:08:29.239
产品通常还有另外一步

01:08:27.560 --> 01:08:31.520
在工作流程中我们称为接受

01:08:29.239 --> 01:08:32.719
在关键实验室使用它

01:08:31.520 --> 01:08:35.869
来，他们会祝福一个特殊的

01:08:32.719 --> 01:08:38.089
承诺，但无论您处理了什么

01:08:35.869 --> 01:08:39.739
跟随你将对你的承诺

01:08:38.089 --> 01:08:42.560
源代码，您将进行更改， 

01:08:39.739 --> 01:08:43.940
最终，您将决定还是作为一个团队或

01:08:42.560 --> 01:08:45.529
但是你这样做，我们有一个我们

01:08:43.940 --> 01:08:47.029
想看看，这个内容是

01:08:45.529 --> 01:08:48.319
正是我们需要的，我们应该

01:08:47.029 --> 01:08:50.540
准备好出发

01:08:48.319 --> 01:08:53.540
先生。产品负责人或产品经理

01:08:50.540 --> 01:08:55.040
您想部署他们会打电话

01:08:53.540 --> 01:08:58.430
他们会说是的，这是如何运作的

01:08:55.040 --> 01:09:00.020
为我们服务，所以我们部署201版及现在

01:08:58.430 --> 01:09:01.730
该应用程序已上线，但我们没有

01:09:00.020 --> 01:09:04.030
除了它，我们还有其他任何东西

01:09:01.730 --> 01:09:06.560
运行CF推送，它消失了，它消失了

01:09:04.030 --> 01:09:08.150
起作用的原因是因为

01:09:06.560 --> 01:09:09.440
他们模仿所有这些环境

01:09:08.150 --> 01:09:10.640
都有自己的价值观

01:09:09.440 --> 01:09:14.420
环境变量，但它们都使用

01:09:10.640 --> 01:09:16.490
相同的环境变量

01:09:14.420 --> 01:09:18.290
我们走得快，它是可重复的，所以我们可以

01:09:16.490 --> 01:09:19.549
一遍又一遍地做

01:09:18.290 --> 01:09:23.089
提交成为候选人

01:09:19.549 --> 01:09:24.620
部署，因此我们的运营商应该

01:09:23.089 --> 01:09:29.000
拥有并且应该容易出现可以

01:09:24.620 --> 01:09:31.190
回来，这是一个非常好的需求

01:09:29.000 --> 01:09:32.480
他们可以回来，他们可以修补

01:09:31.190 --> 01:09:35.330
平台，他们可以重新部署

01:09:32.480 --> 01:09:36.859
软件，所以有很多功能

01:09:35.330 --> 01:09:38.230
我们靠在平台上

01:09:36.859 --> 01:09:39.980
依靠平台是一样的

01:09:38.230 --> 01:09:44.450
这对每个人都有意义

01:09:39.980 --> 01:09:47.750
任何问题，以便我们回到这里

01:09:44.450 --> 01:09:50.020
应用已启动并正在运行，我们可以进行CF 

01:09:47.750 --> 01:09:50.020
卷曲

01:09:54.469 --> 01:10:00.140
我们会看到这招呼没人，如果

01:09:56.390 --> 01:10:02.260
我们看看历史，我们只有一个

01:10:00.140 --> 01:10:02.260
条目

01:10:09.530 --> 01:10:14.000
所以正确使用平台是一样的

01:10:12.380 --> 01:10:18.980
因为都是一样的

01:10:14.000 --> 01:10:22.070
猜想那个因素12是我的吗

01:10:18.980 --> 01:10:23.960
最不喜欢的因素12的因素是

01:10:22.070 --> 01:10:25.790
有观点和偏见

01:10:23.960 --> 01:10:28.400
对使用repple运行的应用程序

01:10:25.790 --> 01:10:30.590
货架，所以当您查看管理任务时

01:10:28.400 --> 01:10:32.090
这变得非常非常明显

01:10:30.590 --> 01:10:33.530
有人像嘿，我可以吐了

01:10:32.090 --> 01:10:35.150
 shell，我可以通过SSH进入

01:10:33.530 --> 01:10:38.000
我可以做任何我想做的事，因为

01:10:35.150 --> 01:10:39.350
我有这种非常棒的自由形式

01:10:38.000 --> 01:10:41.210
与我互动的插件方式

01:10:39.350 --> 01:10:45.800
 Java中没有的环境

01:10:41.210 --> 01:10:47.120
对，那对我们来说不是什么，所以

01:10:45.800 --> 01:10:51.050
我们必须稍微对待这个因素

01:10:47.120 --> 01:10:53.120
法律的精神不同

01:10:51.050 --> 01:10:54.800
管理流程针对我们发布的版本

01:10:53.120 --> 01:10:56.960
完全可以做到我们的工具适应了

01:10:54.800 --> 01:10:58.550
为此，它应该以相同的方式运行

01:10:56.960 --> 01:10:59.930
完全可以的环境

01:10:58.550 --> 01:11:01.760
它应该使用相同的代码库

01:10:59.930 --> 01:11:03.620
我认为相同的配置

01:11:01.760 --> 01:11:04.970
感觉很奇怪，因为它看起来像

01:11:03.620 --> 01:11:07.490
我们一直在告诉人们

01:11:04.970 --> 01:11:08.750
做很长一段时间，但有点

01:11:07.490 --> 01:11:12.320
先进的案例，你最终与这些

01:11:08.750 --> 01:11:13.580
多项目Gradle文件的感觉

01:11:12.320 --> 01:11:16.750
每次我做错我

01:11:13.580 --> 01:11:19.400
喜欢那是不对的

01:11:16.750 --> 01:11:21.530
您的管理员代码应该绝对有效

01:11:19.400 --> 01:11:22.820
与编码的管理员

01:11:21.530 --> 01:11:26.480
为什么我们最终参与这些多项目

01:11:22.820 --> 01:11:27.980
情况下我想呼唤的东西

01:11:26.480 --> 01:11:29.900
这有很多规则是务实的吗

01:11:27.980 --> 01:11:32.360
正确地做最有效的事情

01:11:29.900 --> 01:11:34.370
我被包裹的重要

01:11:32.360 --> 01:11:36.110
上个星期我们有了这个车轴

01:11:34.370 --> 01:11:38.180
关于第十二因素的很多讨论和

01:11:36.110 --> 01:11:38.780
有多少让我生气的事

01:11:38.180 --> 01:11:40.280
正确的事

01:11:38.780 --> 01:11:41.390
所以直到我熬夜

01:11:40.280 --> 01:11:42.290
尝试之前的凌晨2:00 

01:11:41.390 --> 01:11:47.780
使它工作，我终于喜欢

01:11:42.290 --> 01:11:50.510
忘了它太远了，所以我们要

01:11:47.780 --> 01:11:52.130
抓取我们应用的新版本，然后

01:11:50.510 --> 01:11:53.570
应用程序将有一个小变化我

01:11:52.130 --> 01:11:59.150
早先谈到这个日期没有

01:11:53.570 --> 01:12:04.190
有很多保真我要回去

01:11:59.150 --> 01:12:07.150
到另一个空间，以便我们可以使用我们的

01:12:04.190 --> 01:12:07.150
不错的网址

01:12:18.280 --> 01:12:23.840
因此，我们将其构建，然后开始

01:12:22.580 --> 01:12:26.230
下部署，我们将看看

01:12:23.840 --> 01:12:26.230
不同

01:12:32.540 --> 01:12:35.540
抱歉

01:12:44.449 --> 01:12:48.770
因此，如果我们再次定位自己， 

01:12:47.150 --> 01:12:51.110
我们的构建文件没有什么不同

01:12:48.770 --> 01:12:54.110
仍然依赖相同的东西

01:12:51.110 --> 01:12:56.270
仍然有飞路，我们已经完成了一项

01:12:54.110 --> 01:12:57.530
我们已经决定， 

01:12:56.270 --> 01:12:58.750
保真度过我们时间

01:12:57.530 --> 01:13:00.500
我们向某人打招呼不是很好

01:12:58.750 --> 01:13:02.210
我们建立数据库的方式

01:13:00.500 --> 01:13:04.310
最初它是所有的思想专栏

01:13:02.210 --> 01:13:05.870
存储日期，以便我们进行历史记录时

01:13:04.310 --> 01:13:06.860
您看到的API每个都有相同的编号

01:13:05.870 --> 01:13:11.390
时间是因为是午夜

01:13:06.860 --> 01:13:12.560
今天午夜我们是产品经理

01:13:11.390 --> 01:13:15.469
说他们想要更好，所以我们已经

01:13:12.560 --> 01:13:17.360
走了，我们做了一个小小的改变

01:13:15.469 --> 01:13:26.290
我认为可能最容易看出我们是否

01:13:17.360 --> 01:13:26.290
只需将其浸在最后一个分支上

01:13:32.790 --> 01:13:38.820
所以在我们约会之前，我们正在使用

01:13:36.540 --> 01:13:40.200
 UNIX纪元秒，然后我们可以

01:13:38.820 --> 01:13:41.850
看到改变的方法

01:13:40.200 --> 01:13:43.410
通过我们拥有的代码

01:13:41.850 --> 01:13:46.590
您开始沿用而不是

01:13:43.410 --> 01:13:48.660
一直到我们的约会

01:13:46.590 --> 01:13:50.700
一直到我们的实体类

01:13:48.660 --> 01:13:52.590
我们还必须创建一个新数据库

01:13:50.700 --> 01:13:54.630
为此进行宽限期迁移

01:13:52.590 --> 01:13:55.860
我故意挑了一个奇怪的例子

01:13:54.630 --> 01:13:58.710
想要一些我的续集会

01:13:55.860 --> 01:14:01.200
如果我们做对了就窒息

01:13:58.710 --> 01:14:03.720
对，我们创建一个新表，我们给它一个

01:14:01.200 --> 01:14:05.790
我们插入的临时名称或我们更改的

01:14:03.720 --> 01:14:08.670
该表的布局，因此最初是

01:14:05.790 --> 01:14:10.890
将匹配完全相同的列是

01:14:08.670 --> 01:14:13.320
问候表，所以我们将其更改为

01:14:10.890 --> 01:14:15.030
取一个大整数而不是我们抓住的日期

01:14:13.320 --> 01:14:16.530
一切，我们进行了改造，所以它

01:14:15.030 --> 01:14:18.060
与我们期望的新格式匹配

01:14:16.530 --> 01:14:19.620
表，然后我们将旧表复制到

01:14:18.060 --> 01:14:20.820
备份，因为我们可能不想

01:14:19.620 --> 01:14:23.310
丢掉旧东西以防万一

01:14:20.820 --> 01:14:25.170
在这个过程中流氓，然后我们

01:14:23.310 --> 01:14:27.810
将临时表复制到新表

01:14:25.170 --> 01:14:29.850
所以这是我的应用可以做到的很棒的权利

01:14:27.810 --> 01:14:31.530
这很烂，我必须记下来

01:14:29.850 --> 01:14:34.650
时间，因为这是数据库迁移

01:14:31.530 --> 01:14:35.940
这是一个真正的早期

01:14:34.650 --> 01:14:37.290
 Cornelia的应用程式版本和我的

01:14:35.940 --> 01:14:40.410
该应用程序的版本可以运行，因为我们

01:14:37.290 --> 01:14:41.760
如果我当时不共享依赖

01:14:40.410 --> 01:14:42.840
推送到一个新的应用程序，我们将

01:14:41.760 --> 01:14:45.270
分享一个依赖，我们会有一个

01:14:42.840 --> 01:14:47.190
问题吧，那会有某种

01:14:45.270 --> 01:14:49.440
冲突如何体现自己

01:14:47.190 --> 01:14:51.660
知道我认为真正发生的事情是我们

01:14:49.440 --> 01:14:53.040
最终会损坏数据库，并且

01:14:51.660 --> 01:14:54.360
然后他们都不会在

01:14:53.040 --> 01:14:55.860
真实的世界是

01:14:54.360 --> 01:14:57.420
绝对适合我们的情况

01:14:55.860 --> 01:15:00.390
琐碎的应用程序，如果

01:14:57.420 --> 01:15:02.370
没有请求进来怎么办

01:15:00.390 --> 01:15:04.230
在简单的情况下，我们要做的是

01:15:02.370 --> 01:15:06.390
只是让flyweight运行迁移

01:15:04.230 --> 01:15:08.070
对我们来说，举重的工作方式是正确的

01:15:06.390 --> 01:15:11.040
它是否在寻找具有特定含义的文件

01:15:08.070 --> 01:15:12.840
在类路径上的命名约定

01:15:11.040 --> 01:15:15.090
它会在数据库迁移中查看

01:15:12.840 --> 01:15:16.620
叫做v1的东西可以运行

01:15:15.090 --> 01:15:18.390
然后它看到一个叫做v2的东西

01:15:16.620 --> 01:15:20.760
运行它，依此类推等等

01:15:18.390 --> 01:15:22.500
和订单，因此它将在运行期间

01:15:20.760 --> 01:15:24.000
申请过程中对我们的推动

01:15:22.500 --> 01:15:29.160
启动它将要迁移表

01:15:24.000 --> 01:15:31.820
为我们服务，因此我们将看到我们的应用已启动

01:15:29.160 --> 01:15:31.820
现在运行

01:15:42.750 --> 01:15:46.260
如果你知道示范神

01:15:44.850 --> 01:15:48.590
微笑着，我们将看到里面的东西

01:15:46.260 --> 01:15:48.590
之前

01:15:53.260 --> 01:15:56.440
一件大事，我们跑来的项链

01:15:55.300 --> 01:15:58.750
卷曲整个东西

01:15:56.440 --> 01:16:00.640
时间早了，时间都一样

01:15:58.750 --> 01:16:03.219
所以如果我们要添加一个新的人，如果我们

01:16:00.640 --> 01:16:04.510
问候我老板离开的新人

01:16:03.219 --> 01:16:06.660
房间的后面，所以我们用他的

01:16:04.510 --> 01:16:06.660
名称

01:16:16.520 --> 01:16:19.640
现在我们看到有一段时间

01:16:18.230 --> 01:16:22.010
保真度更高一点，所以

01:16:19.640 --> 01:16:23.630
这一切都是在飞行中发生的，我们跑了

01:16:22.010 --> 01:16:25.160
管理过程发生在

01:16:23.630 --> 01:16:26.270
容器发生在相同的位置

01:16:25.160 --> 01:16:28.310
配置显然是因为我们已经

01:16:26.270 --> 01:16:32.480
操纵我们的数据库以及所有内容

01:16:28.310 --> 01:16:34.520
当你可以做到的时候我很好

01:16:32.480 --> 01:16:36.680
说对了，那真的很容易

01:16:34.520 --> 01:16:38.180
可以度过一生的美好生活

01:16:36.680 --> 01:16:39.500
对我们如何变得超级疯狂

01:16:38.180 --> 01:16:41.060
管理数据库并完成

01:16:39.500 --> 01:16:42.560
迁移快照并带来了

01:16:41.060 --> 01:16:44.000
返回并调和差异，以便

01:16:42.560 --> 01:16:46.160
有办法解决零

01:16:44.000 --> 01:16:48.110
数据库宕机问题

01:16:46.160 --> 01:16:49.640
迁移和管理流程

01:16:48.110 --> 01:16:51.440
只是很多工作，所以你知道规则

01:16:49.640 --> 01:16:54.650
如果可以的话，因子12排名第一

01:16:51.440 --> 01:16:58.160
停工停工

01:16:54.650 --> 01:16:59.750
前进，尽管事情会变得更多

01:16:58.160 --> 01:17:01.460
复杂，有时你只是

01:16:59.750 --> 01:17:02.600
在github仓库中想要一个单独的应用程序

01:17:01.460 --> 01:17:04.280
而且因为我们时间紧迫

01:17:02.600 --> 01:17:05.690
我不会掩饰它的存在

01:17:04.280 --> 01:17:07.040
我们如何做到这一点的例子

01:17:05.690 --> 01:17:08.540
基本上，我们只是移动所有的轻重物

01:17:07.040 --> 01:17:11.690
填充到另一个应用程序中并将其构建为

01:17:08.540 --> 01:17:13.190
多项目构建，到此为止

01:17:11.690 --> 01:17:21.320
我的部分，我们回到Cornelia 

01:17:13.190 --> 01:17:22.520
一份有约束力的报告，所以我们

01:17:21.320 --> 01:17:25.730
还要再经历几个

01:17:22.520 --> 01:17:27.950
这是第一件事

01:17:25.730 --> 01:17:29.600
我们要谈论的是因素

01:17:27.950 --> 01:17:32.719
七点，你又可以看到我们要去

01:17:29.600 --> 01:17:36.760
乱序在这里，真的

01:17:32.719 --> 01:17:39.320
关于不良发现的一句口号是

01:17:36.760 --> 01:17:41.750
让平台为您处理

01:17:39.320 --> 01:17:43.190
所以你面临的挑战之一

01:17:41.750 --> 01:17:46.040
通过应用程序移动事物

01:17:43.190 --> 01:17:48.410
生命周期，或者即使情况正在发生变化

01:17:46.040 --> 01:17:50.750
在您的Prada环境中，如果您是

01:17:48.410 --> 01:17:52.670
不得不改变端口，而你不得不

01:17:50.750 --> 01:17:55.100
进入并更改一些配置

01:17:52.670 --> 01:17:56.480
某个地方，哦，天哪，我现在这是

01:17:55.100 --> 01:17:58.280
在其他地方跑，我有一个

01:17:56.480 --> 01:18:00.410
不同的URL或我有不同的端口

01:17:58.280 --> 01:18:03.170
你必须处理所有这些端口的东西

01:18:00.410 --> 01:18:06.020
你自己，所以整个重点

01:18:03.170 --> 01:18:07.730
这是允许允许的东西

01:18:06.020 --> 01:18:10.280
就像平台为您处理

01:18:07.730 --> 01:18:11.930
并在云原生应用程序中

01:18:10.280 --> 01:18:14.960
平台记得那是

01:18:11.930 --> 01:18:17.510
一开始的报价是设计好的

01:18:14.960 --> 01:18:20.210
要做到这一点，让我们继续前进， 

01:18:17.510 --> 01:18:23.510
看看那个

01:18:20.210 --> 01:18:26.210
让我们看看你在那个URL上很棒

01:18:23.510 --> 01:18:32.900
我只想确保让我们开始

01:18:26.210 --> 01:18:41.660
查看因子7端口绑定

01:18:32.900 --> 01:18:43.910
我要进行构建，然后我们

01:18:41.660 --> 01:18:45.770
继续进行部署，然后

01:18:43.910 --> 01:18:49.940
我要跳到一张照片

01:18:45.770 --> 01:19:01.790
在我们等待部署CF时

01:18:49.940 --> 01:19:03.980
推好，那里有部署，所以让我们

01:19:01.790 --> 01:19:07.250
回到这里，看看

01:19:03.980 --> 01:19:10.430
图片，那么这就是发生的情况

01:19:07.250 --> 01:19:12.320
 Cloud Foundry所以我拥有的是

01:19:10.430 --> 01:19:14.960
那里不同机器的数量

01:19:12.320 --> 01:19:17.090
我们称跑步者为跑步者

01:19:14.960 --> 01:19:18.440
我是否把它说成是

01:19:17.090 --> 01:19:20.030
实施细节，但

01:19:18.440 --> 01:19:21.739
实施细节在这里

01:19:20.030 --> 01:19:23.960
他们正在创建容器和我的应用

01:19:21.739 --> 01:19:25.310
在容器中运行，所以在此

01:19:23.960 --> 01:19:27.440
在这里看到两个不同的图片

01:19:25.310 --> 01:19:29.989
两个不同的虚拟跑步者

01:19:27.440 --> 01:19:32.060
他们每个都被分解成的机器

01:19:29.989 --> 01:19:34.400
不同的容器，你可以看到

01:19:32.060 --> 01:19:37.219
这些正在运行以及

01:19:34.400 --> 01:19:40.040
我们去的时候端口映射就是这样

01:19:37.219 --> 01:19:41.870
打招呼12个因素

01:19:40.040 --> 01:19:44.960
路由组件是

01:19:41.870 --> 01:19:48.230
路由组件具有的平台

01:19:44.960 --> 01:19:51.140
本质上是一个映射到它的表

01:19:48.230 --> 01:19:53.420
说哦，我看到你好12要素是

01:19:51.140 --> 01:19:55.969
映射到此应用程序实例

01:19:53.420 --> 01:20:02.750
在那边，它被映射到

01:19:55.969 --> 01:20:04.910
像192168227这样的URL和端口就可以了

01:20:02.750 --> 01:20:06.680
该端口已写入，我将显示

01:20:04.910 --> 01:20:08.570
你，我们要做什么区别

01:20:06.680 --> 01:20:12.440
一会儿就能在代码中看到

01:20:08.570 --> 01:20:14.420
它会处理您会注意到的端口

01:20:12.440 --> 01:20:18.080
我从未配置过，我从未说过

01:20:14.420 --> 01:20:21.500
端口61哦21我从未给它端口

01:20:18.080 --> 01:20:23.300
一切都为您处理，我们会得到

01:20:21.500 --> 01:20:26.180
回到我的那张照片

01:20:23.300 --> 01:20:28.010
可以有多个实例，实际上

01:20:26.180 --> 01:20:30.440
我马上指出，你会

01:20:28.010 --> 01:20:33.800
注意这里我有两个不同

01:20:30.440 --> 01:20:38.930
跑步者有两个不同的URL 192 

01:20:33.800 --> 01:20:41.780
 1 68 227和点33，但端口是

01:20:38.930 --> 01:20:44.720
本地范围，所以我实际上可能有

01:20:41.780 --> 01:20:47.600
在两个端口上运行相同的端口号

01:20:44.720 --> 01:20:50.000
现在完全不同的机器

01:20:47.600 --> 01:20:52.310
如果您必须管理跨

01:20:50.000 --> 01:20:54.710
整个地区的分布式环境

01:20:52.310 --> 01:20:57.410
不同的虚拟机

01:20:54.710 --> 01:21:00.740
使事情变得更加复杂

01:20:57.410 --> 01:21:03.530
不要去那里得到一个平台，可以

01:21:00.740 --> 01:21:06.230
这个给你，让我们回到这里

01:21:03.530 --> 01:21:07.730
很好的东西部署很好，所以我

01:21:06.230 --> 01:21:09.320
继续前进，我要卷曲

01:21:07.730 --> 01:21:17.810
这样，您会看到我们已经完成了

01:21:09.320 --> 01:21:22.250
在这个应用程序中，我们没有

01:21:17.810 --> 01:21:31.190
想要历史，我只想要这个

01:21:22.250 --> 01:21:33.770
我做了吗，哦，我们去了12我

01:21:31.190 --> 01:21:36.140
要说的是煽动者不是

01:21:33.770 --> 01:21:37.900
对我微笑好吧，现在你可以看到

01:21:36.140 --> 01:21:40.700
在这里，它没有问候任何人， 

01:21:37.900 --> 01:21:43.550
这是机器的IP地址

01:21:40.700 --> 01:21:45.650
正在运行该应用程序，而我

01:21:43.550 --> 01:21:48.260
可以再次卷曲，你可以说看到

01:21:45.650 --> 01:21:52.400
这是端口号，事实证明

01:21:48.260 --> 01:21:53.900
在这里有一个设施

01:21:52.400 --> 01:21:56.480
 Cloud Foundry使您能够

01:21:53.900 --> 01:21:59.540
实际上是在内部设置端口

01:21:56.480 --> 01:22:01.640
然后它映射到外部端口

01:21:59.540 --> 01:22:03.110
您确实拥有两全其美的优势

01:22:01.640 --> 01:22:05.270
你可以做一些配置

01:22:03.110 --> 01:22:08.420
您自己，我们会照顾港口

01:22:05.270 --> 01:22:10.100
为您绑定，以便映射，所以我

01:22:08.420 --> 01:22:11.660
可以保持卷曲并保持卷曲

01:22:10.100 --> 01:22:14.660
这个，我总是要回去

01:22:11.660 --> 01:22:18.410
相同的IP地址和相同的端口

01:22:14.660 --> 01:22:21.050
现在让我们回到下一个因素

01:22:18.410 --> 01:22:24.200
下一个因素是无状态

01:22:21.050 --> 01:22:26.690
因此，当您部署自己的

01:22:24.200 --> 01:22:29.540
云中的应用程序应用程序

01:22:26.690 --> 01:22:31.040
这就是您的云在

01:22:29.540 --> 01:22:34.190
开始你可能会跑一个

01:22:31.040 --> 01:22:36.080
一台机器，然后你就是

01:22:34.190 --> 01:22:38.300
变得更好，您需要更多的负载， 

01:22:36.080 --> 01:22:41.000
您添加其他计算机，然后全部

01:22:38.300 --> 01:22:44.750
突然间，您的应用程式开始流行，而您

01:22:41.000 --> 01:22:47.329
需要扩展到大量实例

01:22:44.750 --> 01:22:48.289
所以你现在已经部署了10 

01:22:47.329 --> 01:22:51.289
和您的应用程序实例

01:22:48.289 --> 01:22:52.820
因为你好，世界好可怕

01:22:51.289 --> 01:22:56.300
很酷，每个人都在看它

01:22:52.820 --> 01:22:58.489
如果您在环境中看就很好

01:22:56.300 --> 01:23:00.439
像这样我有数百个或

01:22:58.489 --> 01:23:02.409
成千上万

01:23:00.439 --> 01:23:06.050
数十万台机器

01:23:02.409 --> 01:23:08.689
一直在破坏

01:23:06.050 --> 01:23:10.939
总是有东西掉下来， 

01:23:08.689 --> 01:23:13.010
我可以告诉你，当你在谷歌

01:23:10.939 --> 01:23:14.989
搜索有机器故障

01:23:13.010 --> 01:23:18.079
所有的时间，但仍然可以正常工作

01:23:14.989 --> 01:23:19.760
我可以继续往前走，我可以得到我的

01:23:18.079 --> 01:23:21.679
搜索结果，我可以从页面转到

01:23:19.760 --> 01:23:23.570
一到二页，你知道什么

01:23:21.679 --> 01:23:25.609
机器可能已经死了，我的机器

01:23:23.570 --> 01:23:27.889
只是得到我可能的回应

01:23:25.609 --> 01:23:30.379
在此过程中死亡，因此

01:23:27.889 --> 01:23:32.749
整个要点，这个因素六是

01:23:30.379 --> 01:23:36.769
关于为失败而设计

01:23:32.749 --> 01:23:39.199
为什么呢，那又怎样呢？ 

01:23:36.769 --> 01:23:42.079
无状态是如果你坚持

01:23:39.199 --> 01:23:44.899
无状态应用程序，它允许平台

01:23:42.079 --> 01:23:48.409
为您做各种事情，所以让我们

01:23:44.899 --> 01:23:49.849
看看那个，我要去

01:23:48.409 --> 01:23:52.059
大概应该把这个我可以

01:23:49.849 --> 01:23:58.219
节省了自己一点时间

01:23:52.059 --> 01:24:02.079
但是我们要去检查一下

01:23:58.219 --> 01:24:05.209
下一个因素，我们将要做一个

01:24:02.079 --> 01:24:13.159
建立Gradle，然后我们将

01:24:05.209 --> 01:24:15.019
部署这个，看，推，好吧，等等

01:24:13.159 --> 01:24:17.239
我们现在正在做的是重新部署

01:24:15.019 --> 01:24:20.869
该应用程序，您将看到

01:24:17.239 --> 01:24:22.760
我所做的实际上是我刚刚添加的

01:24:20.869 --> 01:24:25.369
另一个端点，所以我要

01:24:22.760 --> 01:24:27.079
模拟其中一种爆炸

01:24:25.369 --> 01:24:29.449
的机器，所以我要模拟

01:24:27.079 --> 01:24:31.159
我的应用程序快要死了，我想证明

01:24:29.449 --> 01:24:33.439
你与它有关的东西

01:24:31.159 --> 01:24:35.300
端口绑定，我在看

01:24:33.439 --> 01:24:37.339
时钟我意识到我只有两个

01:24:35.300 --> 01:24:38.839
分钟，这是我们要去的

01:24:37.339 --> 01:24:41.239
做到这一点，我们要坚持下去

01:24:38.839 --> 01:24:43.280
和我一起进行部署

01:24:41.239 --> 01:24:44.989
只是几分钟，但是一旦

01:24:43.280 --> 01:24:46.909
一出现，您很快就会看到

01:24:44.989 --> 01:24:50.359
我已经说过我已经模拟过

01:24:46.909 --> 01:24:52.369
模拟了此应用程序即将消亡并

01:24:50.359 --> 01:24:54.109
有一些非常有趣的事情

01:24:52.369 --> 01:24:56.780
关于这一点，因为它回到了

01:24:54.109 --> 01:24:58.879
关于端口绑定的问题，所以端口

01:24:56.780 --> 01:25:00.059
你记得我说的东西是

01:24:58.879 --> 01:25:02.039
改变也许

01:25:00.059 --> 01:25:03.900
法院正在改变，我们将

01:25:02.039 --> 01:25:07.320
马上看到一个例子

01:25:03.900 --> 01:25:09.420
如果这些事情改变了所有

01:25:07.320 --> 01:25:12.420
不想管理的时间

01:25:09.420 --> 01:25:15.449
今天就自己生活在这朵云中

01:25:12.420 --> 01:25:18.329
您绝对必须的本地世界

01:25:15.449 --> 01:25:20.219
自动化一切，所以您无法管理

01:25:18.329 --> 01:25:21.780
您的应用程序和部署

01:25:20.219 --> 01:25:22.409
您自己升级

01:25:21.780 --> 01:25:24.270
不再

01:25:22.409 --> 01:25:27.420
您需要一些帮助，那就是

01:25:24.270 --> 01:25:30.780
平台可以进入哪里，所以如果我们

01:25:27.420 --> 01:25:33.059
现在卷曲这个，你可以在这里看到我的

01:25:30.780 --> 01:25:40.409
应用已启动并正在运行我现在正在运行

01:25:33.059 --> 01:25:42.599
 10.10 81 16端口6368 5所以我可以保持

01:25:40.409 --> 01:25:45.710
这样做，现在特别

01:25:42.599 --> 01:25:49.650
虽然我要访问一个新的

01:25:45.710 --> 01:25:55.079
我的应用程式中有这个网址

01:25:49.650 --> 01:25:58.489
 URL损坏，您会看到我

01:25:55.079 --> 01:25:58.489
回到我没想到的杰森

01:25:58.530 --> 01:26:06.989
好的，我同时打了两个CF应用程序

01:26:03.659 --> 01:26:09.239
该应用的名称是hello spring 1，请查看是否

01:26:06.989 --> 01:26:13.099
删除是正确的

01:26:09.239 --> 01:26:19.590
我们正在对该删除进行负载平衡

01:26:13.099 --> 01:26:21.239
抱歉，你好， Spring 1，我就是这样

01:26:19.590 --> 01:26:23.280
以为会早点打到你，但

01:26:21.239 --> 01:26:26.489
那你做了蓝绿色反而还好

01:26:23.280 --> 01:26:29.610
所以让我们再做一次卷翘

01:26:26.489 --> 01:26:35.250
它说了一些事情

01:26:29.610 --> 01:26:38.909
如果我们使用CF应用程序，现在会坏掉

01:26:35.250 --> 01:26:41.610
目前只有零分之一

01:26:38.909 --> 01:26:44.250
我想要的那个应用程序的实例

01:26:41.610 --> 01:26:47.429
一台正在运行，但一台没有运行

01:26:44.250 --> 01:26:49.260
再这样，如果我做一个CF应用程序， 

01:26:47.429 --> 01:26:50.369
想知道演示神是否不是

01:26:49.260 --> 01:26:55.010
要对我微笑

01:26:50.369 --> 01:26:56.750
它说请求的状态已停止CF 

01:26:55.010 --> 01:27:03.469
重新开始

01:26:56.750 --> 01:27:03.469
你好12因素我杀错了吗

01:27:06.909 --> 01:27:12.229
这只需要片刻

01:27:09.800 --> 01:27:14.360
请求状态已停止，所以我

01:27:12.229 --> 01:27:18.499
需要的是请求的状态开始

01:27:14.360 --> 01:27:20.809
这就是为什么它不存在的原因，我知道

01:27:18.499 --> 01:27:24.320
我结束了，我保证我会在这里结束

01:27:20.809 --> 01:27:27.650
我刚刚杀了好

01:27:24.320 --> 01:27:30.139
所以不，是我被错误地部署了

01:27:27.650 --> 01:27:32.630
应用程序，所以我就去

01:27:30.139 --> 01:27:34.669
前进并结束这就是你所知道的

01:27:32.630 --> 01:27:36.949
真实的是演示并不总是

01:27:34.669 --> 01:27:40.760
很高兴在手机上向您展示

01:27:36.949 --> 01:27:42.409
紧接着休息，所以最后

01:27:40.760 --> 01:27:45.320
我想在这里谈的因素是

01:27:42.409 --> 01:27:48.260
并发，所以我们都熟悉

01:27:45.320 --> 01:27:50.360
放大模型，因此如果您需要更多

01:27:48.260 --> 01:27:53.659
和更多的能力，你只是给它更多

01:27:50.360 --> 01:27:56.959
内存，或者您赋予它更多的CPU能力， 

01:27:53.659 --> 01:27:59.959
在云原生世界中

01:27:56.959 --> 01:28:02.599
扩展使用，您可以建立自己的

01:27:59.959 --> 01:28:05.209
应用程序，如果我

01:28:02.599 --> 01:28:08.449
如果我的hello world应用程序具有病毒性，则需要

01:28:05.209 --> 01:28:11.329
我需要部署更多实例

01:28:08.449 --> 01:28:13.669
更多实例非常非常简单

01:28:11.329 --> 01:28:16.489
这就是它的工作方式，所以我们拥有

01:28:13.669 --> 01:28:18.530
这是我们有很多不同的地方

01:28:16.489 --> 01:28:20.360
工作量以及这些工作量

01:28:18.530 --> 01:28:22.039
不只是网络应用

01:28:20.360 --> 01:28:24.530
可能是后台进程

01:28:22.039 --> 01:28:26.449
不同的过程类型以及何时

01:28:24.530 --> 01:28:29.179
扩大规模，就扩大规模

01:28:26.449 --> 01:28:31.130
现在我在这里还有其他实例

01:28:29.179 --> 01:28:32.929
要给你看一个规模演示，我当时

01:28:31.130 --> 01:28:34.639
会告诉你如何快速，其中之一

01:28:32.929 --> 01:28:36.499
最重要的是我要按比例缩放

01:28:34.639 --> 01:28:39.469
从一个应用程序实例到五个应用程序

01:28:36.499 --> 01:28:41.689
实例，它确实发生了

01:28:39.469 --> 01:28:44.059
其他应用程序实例在以下位置启动

01:28:41.689 --> 01:28:46.329
大约一秒钟，并一直记住

01:28:44.059 --> 01:28:50.119
回到分解的第五因子

01:28:46.329 --> 01:28:51.949
设计版本发布并运行，我们说

01:28:50.119 --> 01:28:54.650
发布将所有内容捆绑在一起，以便

01:28:51.949 --> 01:28:56.659
运行会很快发生，这就是

01:28:54.650 --> 01:28:58.820
该平台为您服务，以便

01:28:56.659 --> 01:29:01.309
发布过程使您可以扩展到

01:28:58.820 --> 01:29:04.219
其他实例，我将没有

01:29:01.309 --> 01:29:07.340
是时候向您展示该演示了

01:29:04.219 --> 01:29:10.309
几件事不是我们所拥有的

01:29:07.340 --> 01:29:12.679
一些我们想要的额外奖金因素

01:29:10.309 --> 01:29:15.079
您考虑一下您的可审核性

01:29:12.679 --> 01:29:16.969
应用程序，而不仅仅是您的

01:29:15.079 --> 01:29:18.810
责任其实是另一回事

01:29:16.969 --> 01:29:21.720
作为开发人员，您可以

01:29:18.810 --> 01:29:24.570
推到平台上，使

01:29:21.720 --> 01:29:26.820
平台提供可审核性

01:29:24.570 --> 01:29:29.070
在哪里开始运行

01:29:26.820 --> 01:29:31.140
所有这些事件流等等

01:29:29.070 --> 01:29:33.420
那已经是Cloud Foundry的一部分

01:29:31.140 --> 01:29:34.680
平台您需要的其他东西

01:29:33.420 --> 01:29:36.810
想想是你需要思考

01:29:34.680 --> 01:29:39.330
关于以这种方式编写应用程序

01:29:36.810 --> 01:29:42.030
你可以从外部

01:29:39.330 --> 01:29:44.490
申请取消授权并

01:29:42.030 --> 01:29:47.970
对那些角色进行身份验证

01:29:44.490 --> 01:29:50.190
基于URL的访问控制

01:29:47.970 --> 01:29:52.740
重要的是反对URL和

01:29:50.190 --> 01:29:54.480
实际上，其中一些来自我们

01:29:52.740 --> 01:29:57.060
同事Josh McEntee我们只是

01:29:54.480 --> 01:29:58.440
在上周进行了辩论，因此

01:29:57.060 --> 01:30:00.840
非常感谢你，我们会留给你

01:29:58.440 --> 01:30:03.150
我们可以推荐的几件事

01:30:00.840 --> 01:30:05.730
几个即将举行的会议，所以有

01:30:03.150 --> 01:30:07.110
 DevOps的 spring boot ，所以很多

01:30:05.730 --> 01:30:09.960
我们在这里谈论的是

01:30:07.110 --> 01:30:11.720
 DevOps应运而生，因此 spring boot DevOps 

01:30:09.960 --> 01:30:15.030
有一个演讲正在发生

01:30:11.720 --> 01:30:17.160
在10:30休息后立即

01:30:15.030 --> 01:30:19.350
另一个乔什在说话的人

01:30:17.160 --> 01:30:21.240
关于 Spring 的云，有一个 Spring 

01:30:19.350 --> 01:30:24.360
云服务今天下午在

01:30:21.240 --> 01:30:26.550
斯科特和克雷格正在做的两个30 

01:30:24.360 --> 01:30:28.620
强烈鼓励您去看看

01:30:26.550 --> 01:30:30.030
这样会给你一个真正的

01:30:28.620 --> 01:30:33.030
关于其中一些的好主意

01:30:30.030 --> 01:30:34.740
因素在 Spring 实施

01:30:33.030 --> 01:30:37.050
上下文，我已经提到了

01:30:34.740 --> 01:30:40.170
迁移整体并在那里再次

01:30:37.050 --> 01:30:41.970
是具有以下内容的存储库的URL 

01:30:40.170 --> 01:30:44.760
我们刚刚展示的所有示例

01:30:41.970 --> 01:30:46.260
你，并会坚持一个

01:30:44.760 --> 01:30:49.640
如果您有任何问题的话

01:30:46.260 --> 01:30:49.640
非常感谢您的关注

