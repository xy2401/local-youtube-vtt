WEBVTT
Kind: captions
Language: zh-Hans

00:00:09.300 --> 00:00:15.280
我的名字是克里斯托弗·富勒

00:00:12.400 --> 00:00:18.490
在春季起关键作用

00:00:15.280 --> 00:00:22.210
数据团队基本上专注于这些

00:00:18.490 --> 00:00:25.270
 MongoDB的四个抽象准备就绪

00:00:22.210 --> 00:00:28.630
太阳能谢谢您重视的东西，但我也

00:00:25.270 --> 00:00:31.349
也会改变GPA分子

00:00:28.630 --> 00:00:36.670
作为新引入的关键值之一

00:00:31.349 --> 00:00:40.180
今天我们要谈论一个非常

00:00:36.670 --> 00:00:42.850
特定组的Spring数据模块

00:00:40.180 --> 00:00:48.159
即可以用于搜索的那些

00:00:42.850 --> 00:00:49.870
全文搜索，或者就是这样

00:00:48.159 --> 00:00:52.989
基本上构成了议程，所以如果我们

00:00:49.870 --> 00:00:56.080
快速浏览一下的历史

00:00:52.989 --> 00:00:58.960
在Java生态系统中搜索

00:00:56.080 --> 00:01:05.409
基本上已经开始

00:00:58.960 --> 00:01:09.070
 1999年，露西最初发行时， 

00:01:05.409 --> 00:01:12.369
直到今天为止，所有可见的核心

00:01:09.070 --> 00:01:17.890
大多数搜索引擎的技术

00:01:12.369 --> 00:01:20.230
在那里有Java等等

00:01:17.890 --> 00:01:23.890
基本上它包含了所有的东西

00:01:20.230 --> 00:01:27.130
您需要分析标签以

00:01:23.890 --> 00:01:32.020
将其分类存储在您的

00:01:27.130 --> 00:01:34.150
正确的方法和大多数更现代的

00:01:32.020 --> 00:01:42.250
搜索技术基于此

00:01:34.150 --> 00:01:44.860
所以基本上2004年的Apache Solr是

00:01:42.250 --> 00:01:48.790
发布-这基本上增加了服务器

00:01:44.860 --> 00:01:54.070
场景下搜索周围的组件

00:01:48.790 --> 00:01:57.300
从那时起直到现在

00:01:54.070 --> 00:02:01.630
我们基本上可以访问我们的

00:01:57.300 --> 00:02:03.550
搜索线内的专用组件

00:02:01.630 --> 00:02:06.040
我们能够谈论的基础设施

00:02:03.550 --> 00:02:09.009
到搜索引擎线休息像

00:02:06.040 --> 00:02:11.769
通过HTTP的接口，我们有各种

00:02:09.009 --> 00:02:14.250
输入和输出格式是太阳能

00:02:11.769 --> 00:02:17.440
有能力处理或

00:02:14.250 --> 00:02:20.020
 XML CSV等所有内容， 

00:02:17.440 --> 00:02:22.390
居里PI，您可以在其中使用

00:02:20.020 --> 00:02:22.780
 HTTP请求，所以这很棒

00:02:22.390 --> 00:02:26.860
和

00:02:22.780 --> 00:02:29.170
有些功能还没有

00:02:26.860 --> 00:02:31.020
到目前为止被亮氨酸覆盖

00:02:29.170 --> 00:02:33.880
方面，我们稍后会谈到

00:02:31.020 --> 00:02:36.370
我们只在太阳能中实现

00:02:33.880 --> 00:02:38.620
直到那两个人花了很长时间

00:02:36.370 --> 00:02:42.209
基本项目基本项目

00:02:38.620 --> 00:02:45.100
联合起来或多或少地合并在一起

00:02:42.209 --> 00:02:47.470
例如那个时候

00:02:45.100 --> 00:02:51.880
刻面并入亮氨酸

00:02:47.470 --> 00:02:53.980
太阳能的核心能力

00:02:51.880 --> 00:02:58.030
到现在已经有十多年了

00:02:53.980 --> 00:03:00.730
在2010年， 

00:02:58.030 --> 00:03:03.209
 Java搜索市场

00:03:00.730 --> 00:03:05.680
释放弹性搜索，这是一个

00:03:03.209 --> 00:03:09.730
一件好事，因为它带来了

00:03:05.680 --> 00:03:11.290
竞争和弹性搜索解决

00:03:09.730 --> 00:03:14.890
一些尚未解决的问题

00:03:11.290 --> 00:03:18.400
由太阳能本身解决了太多问题，所以在

00:03:14.890 --> 00:03:20.680
 2010年您基本上拥有的是

00:03:18.400 --> 00:03:23.290
搜索服务器（如果您使用的是太阳能） 

00:03:20.680 --> 00:03:25.810
和本地集群，因此如果您的服务器是

00:03:23.290 --> 00:03:28.090
下来，你不得不以某种方式处理它

00:03:25.810 --> 00:03:30.310
你自己的，你无法集群

00:03:28.090 --> 00:03:32.230
它或分片数据，那是什么

00:03:30.310 --> 00:03:34.780
弹性搜索出来了，所以

00:03:32.230 --> 00:03:36.820
旋转起来很容易

00:03:34.780 --> 00:03:38.920
连接到的搜索服务器

00:03:36.820 --> 00:03:41.290
互相攻击并绘制图表

00:03:38.920 --> 00:03:43.959
为您和自动故障转移

00:03:41.290 --> 00:03:45.850
非常棒，所以太阳能社区

00:03:43.959 --> 00:03:49.600
必须对此做些事情，这是

00:03:45.850 --> 00:03:51.340
很高兴看到现在集群

00:03:49.600 --> 00:03:54.850
能力不同

00:03:51.340 --> 00:03:56.829
也实施了我们的太阳能事业

00:03:54.850 --> 00:03:59.019
你看到比赛带来了

00:03:56.829 --> 00:04:03.459
给我们所有人的东西

00:03:59.019 --> 00:04:06.880
社区，因为我们有专门的

00:04:03.459 --> 00:04:12.850
春季日期MongoDB模块和MongoDB 

00:04:06.880 --> 00:04:16.539
与2.6版本搜索一起发布

00:04:12.850 --> 00:04:18.400
整合到他们的商店中

00:04:16.539 --> 00:04:21.190
也会去看看

00:04:18.400 --> 00:04:24.760
虽然我必须承认搜索

00:04:21.190 --> 00:04:26.800
 MongoDB中的功能不是

00:04:24.760 --> 00:04:32.169
根据现场，所以他们做了自己的

00:04:26.800 --> 00:04:36.099
事，成为MongoDB不是搜索服务器

00:04:32.169 --> 00:04:36.580
根据定义，所以前两个或太阳能

00:04:36.099 --> 00:04:38.680
安吉拉

00:04:36.580 --> 00:04:41.080
搜索成熟的搜索服务

00:04:38.680 --> 00:04:45.099
拥有全部资本k p 

00:04:41.080 --> 00:04:47.979
想要为您的帐单付款

00:04:45.099 --> 00:04:51.810
应用程序，而妈妈数据库只是提供了一个

00:04:47.979 --> 00:04:54.789
全文搜索作为其数据库的一部分

00:04:51.810 --> 00:04:58.060
所以那里有一个区别

00:04:54.789 --> 00:05:00.400
请不要把事情混在一起走

00:04:58.060 --> 00:05:03.039
结束本次会议，然后说妈妈数据库

00:05:00.400 --> 00:05:04.330
是我们的全文搜索引擎

00:05:03.039 --> 00:05:09.159
并非如此，但您有

00:05:04.330 --> 00:05:11.530
那里的功能很好，今天

00:05:09.159 --> 00:05:15.069
会议，正如我已经说过的，我们不是

00:05:11.530 --> 00:05:17.860
将要覆盖场景的内部或

00:05:15.069 --> 00:05:21.879
鸡巴-太深了，但我们会

00:05:17.860 --> 00:05:23.310
看看我们如何做全文

00:05:21.879 --> 00:05:27.009
用MongoDB搜索

00:05:23.310 --> 00:05:29.440
与Apache Solr和弹性搜索以及

00:05:27.009 --> 00:05:31.569
我们如何使用这些带来的数据

00:05:29.440 --> 00:05:34.779
在这些之上的抽象

00:05:31.569 --> 00:05:37.659
技术及其对我们的意义

00:05:34.779 --> 00:05:42.190
当我们使用它时，潜在的陷阱

00:05:37.659 --> 00:05:45.190
还有所有这些东西，但在我们开始之前

00:05:42.190 --> 00:05:48.520
我们基本上搜索的是什么东西

00:05:45.190 --> 00:05:52.029
关于我的全部意思是我认为搜索是

00:05:48.520 --> 00:05:56.680
一个非常简单的要求，我的意思是

00:05:52.029 --> 00:06:03.150
我想快速轻松地找到我的数据

00:05:56.680 --> 00:06:06.759
而且我看到了失败的应用程序

00:06:03.150 --> 00:06:08.770
不是因为他们真的被实施了

00:06:06.759 --> 00:06:11.259
或测试不良，或者我有零件或

00:06:08.770 --> 00:06:13.180
缺少功能，只是因为它们

00:06:11.259 --> 00:06:16.690
之所以无法使用，是因为用户无法

00:06:13.180 --> 00:06:19.270
找到他们的数据，所以有一种

00:06:16.690 --> 00:06:21.460
我去读一本本地书时的有趣故事

00:06:19.270 --> 00:06:24.129
几周前在我的家乡存储

00:06:21.460 --> 00:06:26.020
我当时要一本特定的书，我

00:06:24.129 --> 00:06:28.960
在标题中告诉他们作者

00:06:26.020 --> 00:06:31.779
还有柜台的家伙

00:06:28.960 --> 00:06:34.509
基本上告诉我哦，等等，让我

00:06:31.779 --> 00:06:36.610
快速打开Goog​​le并在其中搜索

00:06:34.509 --> 00:06:38.139
在那里，然后复制冰P n因此

00:06:36.610 --> 00:06:40.270
基本上把书号放进去

00:06:38.139 --> 00:06:42.449
自己的系统，因为这更快

00:06:40.270 --> 00:06:48.430
比在自己的系统中搜索

00:06:42.449 --> 00:06:50.180
我认为很好

00:06:48.430 --> 00:06:52.340
情况下，如果您让我们

00:06:50.180 --> 00:06:54.820
明智的选择，所以如果你有一个

00:06:52.340 --> 00:06:58.310
呼叫中心应用程序处理

00:06:54.820 --> 00:07:00.380
首先是数千个客户编号

00:06:58.310 --> 00:07:01.910
命名您的姓氏敏感数据

00:07:00.380 --> 00:07:03.800
不能仅仅去谷歌搜索

00:07:01.910 --> 00:07:06.860
骨灰盒里的人可能是

00:07:03.800 --> 00:07:08.330
一些内部ID进入您的系统

00:07:06.860 --> 00:07:12.050
所以你可以做点什么

00:07:08.330 --> 00:07:15.410
没有潜在地杀死数据库

00:07:12.050 --> 00:07:17.870
通过执行任何您拥有的SQL 

00:07:15.410 --> 00:07:21.590
针对它的声明基本上是在做

00:07:17.870 --> 00:07:24.979
全表扫描或什至更糟

00:07:21.590 --> 00:07:27.229
多次全表扫描，所以这是一个

00:07:24.979 --> 00:07:29.210
简单的要求，我想让你找到我的

00:07:27.229 --> 00:07:32.210
我想在人类中找到的数据

00:07:29.210 --> 00:07:35.090
可读的方式也很重要

00:07:32.210 --> 00:07:37.759
我不想让你知道一些

00:07:35.090 --> 00:07:39.620
我必须了解的表达语言

00:07:37.759 --> 00:07:42.349
在输入我的搜索字词之前

00:07:39.620 --> 00:07:45.380
我想要像Google一样拥有它

00:07:42.349 --> 00:07:47.389
这就是我想要的要求

00:07:45.380 --> 00:07:49.669
输入我可以轻松输入的内容

00:07:47.389 --> 00:07:53.210
明白，这很简单

00:07:49.669 --> 00:07:56.389
我认为是必需品

00:07:53.210 --> 00:07:58.699
简单的要求是

00:07:56.389 --> 00:08:01.460
可以实现很漂亮

00:07:58.699 --> 00:08:06.169
很容易，但问题是人

00:08:01.460 --> 00:08:08.930
犯错误，我也想努力

00:08:06.169 --> 00:08:11.479
搜索我是否用户出错

00:08:08.930 --> 00:08:13.970
所以这是一个搜索引擎

00:08:11.479 --> 00:08:17.389
应该有能力，如果我有错字

00:08:13.970 --> 00:08:19.190
在我的搜索查询中，我仍然想做

00:08:17.389 --> 00:08:22.460
有它为我做正确的事

00:08:19.190 --> 00:08:23.289
我想找文件

00:08:22.460 --> 00:08:29.720
错误

00:08:23.289 --> 00:08:31.970
所以对不起一个非常简单的要求

00:08:29.720 --> 00:08:33.529
可以变成一个真正的

00:08:31.970 --> 00:08:36.380
复杂的解决方案，所以这基本上是

00:08:33.529 --> 00:08:39.110
 11个蒸汽距离的算法

00:08:36.380 --> 00:08:43.459
用于计算距离

00:08:39.110 --> 00:08:46.579
字距之间的距离

00:08:43.459 --> 00:08:49.450
每个字符都给对方哦，感谢上帝

00:08:46.579 --> 00:08:52.850
有比我更聪明的人

00:08:49.450 --> 00:08:56.570
谁给我们提供了某种

00:08:52.850 --> 00:08:58.670
抽象，所以这基本上就是

00:08:56.570 --> 00:09:03.980
的弹性搜索表示

00:08:58.670 --> 00:09:07.160
实际中的levenshtein距离算法

00:09:03.980 --> 00:09:09.290
以开发人员可读的方式

00:09:07.160 --> 00:09:14.149
您需要学习一些语法，然后

00:09:09.290 --> 00:09:19.810
您可以继续使用

00:09:14.149 --> 00:09:19.810
有人为我们所做的工作值得庆幸的是

00:09:20.050 --> 00:09:25.399
话虽如此，我想引用米尔福德

00:09:23.360 --> 00:09:27.279
有点，因为这是

00:09:25.399 --> 00:09:29.750
或多或少的本届会议的模型

00:09:27.279 --> 00:09:31.700
您需要了解一个层次的

00:09:29.750 --> 00:09:33.740
下面的抽象是

00:09:31.700 --> 00:09:37.970
你正在努力，所以基本上

00:09:33.740 --> 00:09:40.130
这个太阳弹性搜索MongoDB 

00:09:37.970 --> 00:09:42.620
那些复杂的抽象

00:09:40.130 --> 00:09:45.980
数据库或数据中的算法

00:09:42.620 --> 00:09:48.740
商店将为我们工作，然后我们

00:09:45.980 --> 00:09:50.930
找到了该特定商店的驱动程序

00:09:48.740 --> 00:09:54.260
作为另一个抽象层次

00:09:50.930 --> 00:09:56.120
主要提供真正的直接功能

00:09:54.260 --> 00:09:57.890
所以我必须了解查询

00:09:56.120 --> 00:09:59.779
语言以及所有这些东西

00:09:57.890 --> 00:10:02.390
最重要的是，我们获得了挥杆数据

00:09:59.779 --> 00:10:06.680
存储库模板和存储库

00:10:02.390 --> 00:10:09.320
抽象，所以有很多

00:10:06.680 --> 00:10:12.770
在发生的事情之间

00:10:09.320 --> 00:10:15.500
商店实际以及您使用什么API 

00:10:12.770 --> 00:10:17.600
接触，所以我们将尝试

00:10:15.500 --> 00:10:20.300
看看这之间的德

00:10:17.600 --> 00:10:25.270
了解在发生了什么

00:10:20.300 --> 00:10:26.480
这些组件的特定部分

00:10:25.270 --> 00:10:30.020
好的

00:10:26.480 --> 00:10:32.480
哦，谁不知道春天

00:10:30.020 --> 00:10:38.930
约会者关于或未使用过的所有信息

00:10:32.480 --> 00:10:42.830
远哦，是的，几只手，好吧，我去

00:10:38.930 --> 00:10:46.700
在那真正的快速，所以这是

00:10:42.830 --> 00:10:48.290
简介会

00:10:46.700 --> 00:10:52.339
Spring 数据基本上是由

00:10:48.290 --> 00:10:54.920
几个模块，所以我们有核心

00:10:52.339 --> 00:10:58.100
模块集是命令

00:10:54.920 --> 00:11:01.490
拥有我们在

00:10:58.100 --> 00:11:04.010
不同的故事实现，例如

00:11:01.490 --> 00:11:05.630
页面告诉的内容，并告诉你

00:11:04.010 --> 00:11:07.700
关于上一页是否有下一页

00:11:05.630 --> 00:11:11.019
页面以及我们得到的所有东西

00:11:07.700 --> 00:11:13.389
 JPA的几个实现

00:11:11.019 --> 00:11:15.190
像冬食这样的廉价供应商

00:11:13.389 --> 00:11:17.500
链接以及我们获得支持的所有东西

00:11:15.190 --> 00:11:21.579
从两个驱动器厌恶的MongoDB 

00:11:17.500 --> 00:11:24.370
点12.3我猜是最新的

00:11:21.579 --> 00:11:27.730
三行版哦

00:11:24.370 --> 00:11:30.009
我们有neo4j我们有太阳能宝石火

00:11:27.730 --> 00:11:32.139
奇怪的是休息，因为它不是

00:11:30.009 --> 00:11:36.850
真正的商店抽象，但更多

00:11:32.139 --> 00:11:39.370
将存储库公开到HTTP 

00:11:36.850 --> 00:11:41.410
我们准备好的资源发送了密钥

00:11:39.370 --> 00:11:43.540
价值模块也有很多

00:11:41.410 --> 00:11:45.970
社区模块和正在进行的工作

00:11:43.540 --> 00:11:47.800
在那里，因为有沙发底座

00:11:45.970 --> 00:11:49.300
有我的elasticsearch模块

00:11:47.800 --> 00:11:51.639
今天要向您介绍

00:11:49.300 --> 00:11:53.920
实际上不是我们维护的，而是

00:11:51.639 --> 00:11:56.560
社区本身，所以有一个

00:11:53.920 --> 00:11:59.170
一群喜欢伦敦的家伙

00:11:56.560 --> 00:12:01.329
 elasticsearch很多，谁喜欢

00:11:59.170 --> 00:12:04.120
 spring data 的想法很多，这就是

00:12:01.329 --> 00:12:06.550
基本上坐在那里并实施

00:12:04.120 --> 00:12:09.790
东西，看到所有东西真的很酷

00:12:06.550 --> 00:12:12.310
这些社区项目不断发展壮大

00:12:09.790 --> 00:12:15.370
卡桑德拉（Cassandra）也有一个

00:12:12.310 --> 00:12:17.410
正如我所说的，有很多社区

00:12:15.370 --> 00:12:19.449
一些正在孵化的项目

00:12:17.410 --> 00:12:21.819
只是想创造他们的航拍

00:12:19.449 --> 00:12:25.870
和那些家伙做了很多工作

00:12:21.819 --> 00:12:29.370
最近甚至有一个穷人

00:12:25.870 --> 00:12:31.689
请求打开Spring 数据

00:12:29.370 --> 00:12:35.589
榛树种姓的存储库抽象

00:12:31.689 --> 00:12:38.740
因为世界也提供了cos，或者

00:12:35.589 --> 00:12:42.399
关于查询语言，所以有点

00:12:38.740 --> 00:12:46.209
天作之合，但我们来看看

00:12:42.399 --> 00:12:50.850
在那三个，就像你看到的那样

00:12:46.209 --> 00:12:55.029
Spring 数据中的许多模块

00:12:50.850 --> 00:12:57.880
发布，我们基本上尝试分组

00:12:55.029 --> 00:13:01.899
这些版本一起发布，以便您

00:12:57.880 --> 00:13:04.120
不必面对不同

00:13:01.899 --> 00:13:06.879
模块的版本，因为那些

00:13:04.120 --> 00:13:11.559
所有这些都按照自己的节奏发展

00:13:06.879 --> 00:13:13.930
并且我们不强迫他们升级到

00:13:11.559 --> 00:13:17.559
基本上在版本行上

00:13:13.930 --> 00:13:21.220
我认为elasticsearch是其中之一

00:13:17.559 --> 00:13:24.010
目前有3个，例如1.6和JPA 

00:13:21.220 --> 00:13:26.380
我希望是1.9 

00:13:24.010 --> 00:13:28.570
记住正确，但是我们尝试

00:13:26.380 --> 00:13:31.390
将它们组合在一起并进行一些语义

00:13:28.570 --> 00:13:34.090
版本控制，我们基本上将其命名为

00:13:31.390 --> 00:13:37.360
在我们的名人之后释放

00:13:34.090 --> 00:13:39.640
行业，所以我们从2013年开始

00:13:37.360 --> 00:13:43.720
 Aurora Babbage称为Dijkstra事件

00:13:39.640 --> 00:13:47.800
 2015年和Gosling的后续发布

00:13:43.720 --> 00:13:50.290
是当前的最新版本， 

00:13:47.800 --> 00:13:50.770
下一个将以格蕾丝（Grace）的名字命名

00:13:50.290 --> 00:13:56.290
料斗

00:13:50.770 --> 00:13:59.050
而且快要走了

00:13:56.290 --> 00:14:03.730
如果一切顺利，在十一月

00:13:59.050 --> 00:14:06.940
按照计划并使其真正实现

00:14:03.730 --> 00:14:09.220
方便您领取转移

00:14:06.940 --> 00:14:11.770
这样您就不必记住所有

00:14:09.220 --> 00:14:14.800
这些版本中，我们为您提供了一些东西

00:14:11.770 --> 00:14:18.300
这就是所谓的释放炸弹

00:14:14.800 --> 00:14:21.310
基本上是保存所有这些的pom文件

00:14:18.300 --> 00:14:23.260
所有版本号都作为属性，因此您

00:14:21.310 --> 00:14:25.330
以后可以覆盖它，你也可以

00:14:23.260 --> 00:14:28.230
基本要做的就是输入

00:14:25.330 --> 00:14:31.450
人工数据ID（是 spring data ）- 

00:14:28.230 --> 00:14:34.900
春天-发布的数据火车和

00:14:31.450 --> 00:14:38.230
 Gosling发生错误-发布或

00:14:34.900 --> 00:14:42.550
 r1或Fowler释放您

00:14:38.230 --> 00:14:44.710
选择然后继续添加该东西

00:14:42.550 --> 00:14:47.710
到您的依赖性管理部分

00:14:44.710 --> 00:14:50.010
在行家，你基本上可以继续

00:14:47.710 --> 00:14:50.010
哎呀

00:14:50.310 --> 00:14:56.050
你去那里和快递员的依赖

00:14:53.800 --> 00:14:59.230
依赖关系而不必担心

00:14:56.050 --> 00:15:02.290
关于明确定义

00:14:59.230 --> 00:15:06.010
人工流产，比如说春天

00:15:02.290 --> 00:15:08.500
最重要的Web MVC和MongoDB是因为

00:15:06.010 --> 00:15:12.330
可以一起使用的版本是

00:15:08.500 --> 00:15:12.330
在释放泵中已经定义

00:15:14.800 --> 00:15:21.699
让我们快速看一下春天

00:15:17.769 --> 00:15:24.819
数据实际上有效，所以我们有几个

00:15:21.699 --> 00:15:27.639
抽象层次如此之低

00:15:24.819 --> 00:15:29.199
 Lehrer非常低的模板

00:15:27.639 --> 00:15:33.220
您可能从中知道的抽象

00:15:29.199 --> 00:15:34.660
 JDBC模板或JMS模板或

00:15:33.220 --> 00:15:36.579
您在Spring Framework中拥有什么

00:15:34.660 --> 00:15:37.989
这很容易找到你的方式

00:15:36.579 --> 00:15:40.290
如果您使用过其中一种

00:15:37.989 --> 00:15:43.929
已经有人，这给你

00:15:40.290 --> 00:15:46.899
基本上进入低位

00:15:43.929 --> 00:15:50.739
特定商店的级别API，因此

00:15:46.899 --> 00:15:53.579
这是我们尝试与春天做的事情

00:15:50.739 --> 00:15:58.239
数据并不能阻止您使用

00:15:53.579 --> 00:16:02.429
本地存储API，因此您可以使用它们

00:15:58.239 --> 00:16:04.839
如果您愿意，但我们尝试为您提供

00:16:02.429 --> 00:16:06.939
更高的抽象度，但您仍然可以

00:16:04.839 --> 00:16:11.889
使用较低的，所以基本上

00:16:06.939 --> 00:16:15.100
为a做一个DD配置文件级别设置

00:16:11.889 --> 00:16:19.149
 MongoDB数据库进入调试模式，因此

00:16:15.100 --> 00:16:21.249
将所有东西锁定在那些低点之上

00:16:19.149 --> 00:16:24.449
级别模板，我们获取存储库

00:16:21.249 --> 00:16:33.069
实施基本上就是

00:16:24.449 --> 00:16:37.839
我们拥有的部分可以完成所有DES 

00:16:33.069 --> 00:16:41.499
代理您获得实际

00:16:37.839 --> 00:16:43.480
或存储特定的Spring数据存储库

00:16:41.499 --> 00:16:46.920
实施，所以这是一部分

00:16:43.480 --> 00:16:49.209
让您只定义一个接口

00:16:46.920 --> 00:16:50.920
这样您就不必写您的

00:16:49.209 --> 00:16:54.429
数据访问代码再次

00:16:50.920 --> 00:16:56.619
所以我们基本上为您提供

00:16:54.429 --> 00:16:59.040
人群存储库分页的抽象

00:16:56.619 --> 00:17:02.949
和存储库，并与您一起

00:16:59.040 --> 00:17:05.230
基本上得到你所有的东西

00:17:02.949 --> 00:17:08.470
自然地期望从那里，所以你得到

00:17:05.230 --> 00:17:10.600
保存您必须查找的所有操作

00:17:08.470 --> 00:17:13.029
您可以通过操作找到一些东西

00:17:10.600 --> 00:17:15.279
身份证，当然你可以吃饱了

00:17:13.029 --> 00:17:16.959
东西再次，所以有整洁的作为

00:17:15.279 --> 00:17:20.620
好吧，但我也不会用

00:17:16.959 --> 00:17:21.880
实际上，最酷的部分是

00:17:20.620 --> 00:17:25.240
哦，最后一部分

00:17:21.880 --> 00:17:26.649
哦，我真的向你展示了

00:17:25.240 --> 00:17:28.360
简短的 spring data 介绍

00:17:26.649 --> 00:17:31.630
还有更多的东西要学习

00:17:28.360 --> 00:17:33.190
看看，但有专门的讲座

00:17:31.630 --> 00:17:36.309
在网上您可以观看或

00:17:33.190 --> 00:17:38.919
看看以后您一步一步走，然后

00:17:36.309 --> 00:17:41.159
我们将聊天，基本上

00:17:38.919 --> 00:17:44.110
也为您提供了派生的发现者

00:17:41.159 --> 00:17:48.279
方法，所以我们在这里要做的是分析

00:17:44.110 --> 00:17:50.380
在启动时，您放置的方法名称

00:17:48.279 --> 00:17:54.130
进入您的存储库分析收益

00:17:50.380 --> 00:17:55.659
类型并为您弄清楚它是什么

00:17:54.130 --> 00:17:58.659
真的应该看起来像我们

00:17:55.659 --> 00:18:01.210
稍后执行，因此找到

00:17:58.659 --> 00:18:04.720
标题返回列表基本上

00:18:01.210 --> 00:18:07.899
从MongoDB中读取所有所有文档

00:18:04.720 --> 00:18:10.419
匹配给定标题或您可以使用

00:18:07.899 --> 00:18:12.100
 EDP​​抽象，所以我们为您提供

00:18:10.419 --> 00:18:17.110
开箱即用的分页功能

00:18:12.100 --> 00:18:19.630
基本上可以使用页表或

00:18:17.110 --> 00:18:23.080
页表参数定义嘿我

00:18:19.630 --> 00:18:25.779
想要获得大小为10的第一页， 

00:18:23.080 --> 00:18:27.490
它给你正确的结果

00:18:25.779 --> 00:18:29.830
返回页面的一部分并告诉你

00:18:27.490 --> 00:18:31.899
要么是下一个，这是通过

00:18:29.830 --> 00:18:35.620
页面表用于获取的方式

00:18:31.899 --> 00:18:39.159
您还可以在下一页上使用Delete by 

00:18:35.620 --> 00:18:42.039
作者将创建一个

00:18:39.159 --> 00:18:44.350
删除查询或最近我们添加了

00:18:42.039 --> 00:18:47.409
支持流基本上是

00:18:44.350 --> 00:18:52.000
可在下午40点Modi哔哔声中使用

00:18:47.409 --> 00:18:55.600
包装我们的光标，以便您可以

00:18:52.000 --> 00:19:02.139
每小时使用d字符串api 

00:18:55.600 --> 00:19:04.720
流API很好，所以我们完成了

00:19:02.139 --> 00:19:07.710
真的非常快速地介绍

00:19:04.720 --> 00:19:12.220
 spring data ，让我们开始讨论

00:19:07.710 --> 00:19:15.370
搜索技术和为了做

00:19:12.220 --> 00:19:18.159
我将要使用一些

00:19:15.370 --> 00:19:21.250
几句话以后，我认为我们应该

00:19:18.159 --> 00:19:25.870
至少看看以下内容

00:19:21.250 --> 00:19:27.700
术语，这首先是什么

00:19:25.870 --> 00:19:32.289
方案或该模式的含义

00:19:27.700 --> 00:19:34.630
搜索条件，我的意思是架构更多或

00:19:32.289 --> 00:19:37.389
不太像以前那样的东西

00:19:34.630 --> 00:19:40.419
从关系数据库中

00:19:37.389 --> 00:19:42.720
基本上告诉您一种格式

00:19:40.419 --> 00:19:45.570
给定的数据类型是

00:19:42.720 --> 00:19:48.900
以及什么申请，但有一点

00:19:45.570 --> 00:19:51.600
当您使用它进行研究时会更多

00:19:48.900 --> 00:19:53.340
现在就可以了，我们将有一个

00:19:51.600 --> 00:19:55.730
看一点文字分析

00:19:53.340 --> 00:19:57.840
这是什么意思

00:19:55.730 --> 00:20:00.900
它是什么样子的

00:19:57.840 --> 00:20:03.540
有陷阱我该怎么办

00:20:00.900 --> 00:20:06.330
不，我们看看什么得分

00:20:03.540 --> 00:20:08.970
而提升是因为有一个术语稳定

00:20:06.330 --> 00:20:13.020
就像您查询查询ver 

00:20:08.970 --> 00:20:18.140
与筛选器查询还可以，让我来

00:20:13.020 --> 00:20:22.740
迅速离开这里并开火

00:20:18.140 --> 00:20:27.230
例如，elasticsearch好吧，这可能

00:20:22.740 --> 00:20:30.450
花一秒钟左右，所以我正在使用

00:20:27.230 --> 00:20:34.320
单节点弹性搜索搜索

00:20:30.450 --> 00:20:35.760
这个演示，我想向您展示

00:20:34.320 --> 00:20:38.340
一点点的弹性搜索

00:20:35.760 --> 00:20:40.710
配置，所以我们基本上有

00:20:38.340 --> 00:20:42.840
这是一个弹性搜索弹药

00:20:40.710 --> 00:20:45.780
您的配置目录

00:20:42.840 --> 00:20:48.420
弹性搜索分布和我

00:20:45.780 --> 00:20:49.890
基本上是在定义集群

00:20:48.420 --> 00:20:52.170
名称是因为弹性搜索具有

00:20:49.890 --> 00:20:56.760
基本找到集群的能力

00:20:52.170 --> 00:20:59.670
节点本身以及群集

00:20:56.760 --> 00:21:03.660
命名，以便您不进行配置，并且

00:20:59.670 --> 00:21:05.220
在本地启动几个节点

00:21:03.660 --> 00:21:07.800
机器，他们会发现彼此或

00:21:05.220 --> 00:21:09.360
甚至可以通过网络

00:21:07.800 --> 00:21:11.850
会议上的坏事

00:21:09.360 --> 00:21:14.790
因为它可能会加入一些

00:21:11.850 --> 00:21:17.910
可能在这里的其他集群

00:21:14.790 --> 00:21:20.700
所以我给它起个专用的名字和希望

00:21:17.910 --> 00:21:23.390
没有人拥有它，并且为了

00:21:20.700 --> 00:21:29.130
确保真的没有人干预

00:21:23.390 --> 00:21:31.800
目前我也用过这个小朋友

00:21:29.130 --> 00:21:33.510
在这叫我可以吗

00:21:31.800 --> 00:21:36.110
实际阅读它，我会放大一点

00:21:33.510 --> 00:21:39.300
称为网络主机的位

00:21:36.110 --> 00:21:41.790
小朋友基本上限制了

00:21:39.300 --> 00:21:45.690
与本地计算机的传出连接

00:21:41.790 --> 00:21:47.400
只是为了确保没有人干预

00:21:45.690 --> 00:21:48.810
如果您是

00:21:47.400 --> 00:21:52.830
在公司工作，不想

00:21:48.810 --> 00:21:54.300
来你当地的elasticsearch连接

00:21:52.830 --> 00:21:56.890
与所有其他人，如果在

00:21:54.300 --> 00:22:00.970
公司网络，还有

00:21:56.890 --> 00:22:03.940
有时可能是另一种选择

00:22:00.970 --> 00:22:07.480
有用的，那是集群的意思

00:22:03.940 --> 00:22:10.030
命名，因此默认情况下为elasticsearch 

00:22:07.480 --> 00:22:12.820
开始选择随机的羊肚菌漫画

00:22:10.030 --> 00:22:14.500
角色名称，他们有一些联系

00:22:12.820 --> 00:22:16.810
在那儿我实际上不知道

00:22:14.500 --> 00:22:18.820
即将到来，但似乎有一千

00:22:16.810 --> 00:22:20.620
和六百个漫威漫画人物

00:22:18.820 --> 00:22:23.530
它应该选择一个随机的名字

00:22:20.620 --> 00:22:26.920
对于您拥有的实例

00:22:23.530 --> 00:22:29.200
在某种程度上可以很好，因为

00:22:26.920 --> 00:22:33.160
看到你所有的名字真有趣

00:22:29.200 --> 00:22:37.690
您可能知道，但很难

00:22:33.160 --> 00:22:40.480
在日志中找出其中有

00:22:37.690 --> 00:22:42.280
当时这个名字属于

00:22:40.480 --> 00:22:44.850
它崩溃了，因为它可能有

00:22:42.280 --> 00:22:47.650
启动时的另一个名字，所以我

00:22:44.850 --> 00:22:52.990
建议设置这个，但是暂时

00:22:47.650 --> 00:22:57.150
我让我看看哦已经

00:22:52.990 --> 00:23:00.970
开始，让我们来看看

00:22:57.150 --> 00:23:03.670
基本上可以安装的仪表板

00:23:00.970 --> 00:23:07.840
作为插件，所以猜猜大多数人都注意到了

00:23:03.670 --> 00:23:09.700
这是Qabbani哦，我安装为

00:23:07.840 --> 00:23:13.090
我的弹性搜索树中的插件

00:23:09.700 --> 00:23:16.000
分布及其作用是什么

00:23:13.090 --> 00:23:18.310
给我关于我的一般概述

00:23:16.000 --> 00:23:20.490
集群，所以我基本上可以在这里看到

00:23:18.310 --> 00:23:23.190
这是一个集群的

00:23:20.490 --> 00:23:26.140
通常不是一件好事，因为即使

00:23:23.190 --> 00:23:28.420
显示所有内容都已读取

00:23:26.140 --> 00:23:31.240
这里是因为没有副本

00:23:28.420 --> 00:23:34.060
分配的，如果节点死了

00:23:31.240 --> 00:23:36.790
搜索消失了，我也得到了一些

00:23:34.060 --> 00:23:39.100
有关CPU使用率以及所有其他信息

00:23:36.790 --> 00:23:43.480
东西使它变得更大

00:23:39.100 --> 00:23:45.340
你和哦，是的，我不知道

00:23:43.480 --> 00:23:48.250
那将是自动的

00:23:45.340 --> 00:23:51.460
我有的漫画人物移动节点名称

00:23:48.250 --> 00:23:54.580
对于这台机器，但是什么型号

00:23:51.460 --> 00:23:57.070
插件还附带了这真的吗

00:23:54.580 --> 00:24:01.360
好用的工具Marvel 

00:23:57.070 --> 00:24:03.520
感觉这是一个JavaScript页面

00:24:01.360 --> 00:24:06.120
为您提供基于

00:24:03.520 --> 00:24:08.770
弹性搜寻API，因此您基本上可以

00:24:06.120 --> 00:24:10.730
从那里获取索引信息，然后

00:24:08.770 --> 00:24:13.760
您在端口上具有自动完成功能

00:24:10.730 --> 00:24:16.309
它检测到您那里的索引

00:24:13.760 --> 00:24:18.799
和办公室，它可以帮助您编写您的

00:24:16.309 --> 00:24:21.110
查询并尝试elasticsearch和

00:24:18.799 --> 00:24:22.850
玩耍也可以用它来做

00:24:21.110 --> 00:24:25.490
一些分析和你有什么

00:24:22.850 --> 00:24:27.559
所以它真的非常不错一个不错的插件

00:24:25.490 --> 00:24:30.080
这是免费的开发模式

00:24:27.559 --> 00:24:34.340
如果您要使用它，必须付费

00:24:30.080 --> 00:24:37.120
在生产或有点，但是的

00:24:34.340 --> 00:24:42.100
在那上面很多，所以我实际上是在做

00:24:37.120 --> 00:24:43.580
预加载的elasticsearch只是

00:24:42.100 --> 00:24:48.080
重新初始化

00:24:43.580 --> 00:24:51.380
我预装了弹性搜索索引

00:24:48.080 --> 00:24:53.840
当前是s-GX索引

00:24:51.380 --> 00:24:56.000
数据中的一些会话和

00:24:53.840 --> 00:25:00.260
集成轨迹，所以基本上我添加了

00:24:56.000 --> 00:25:02.600
排毒托马斯和他给的一切

00:25:00.260 --> 00:25:05.840
早餐后就来-最新消息

00:25:02.600 --> 00:25:09.080
在 spring data 中谈谈32d轨迹数据

00:25:05.840 --> 00:25:11.299
整合以及您所看到的已经看到的

00:25:09.080 --> 00:25:15.559
这是我需要一个JSON 

00:25:11.299 --> 00:25:17.809
文档，这真是太好了

00:25:15.559 --> 00:25:20.360
他们可以使用以撒搜索的问题

00:25:17.809 --> 00:25:23.450
 JSON文档推入索引

00:25:20.360 --> 00:25:28.340
然后是什么elasticsearch呢

00:25:23.450 --> 00:25:32.450
分析我推送的数据并尝试

00:25:28.340 --> 00:25:35.960
从根本上弄清楚架构

00:25:32.450 --> 00:25:40.190
分析我提供的数据并检测

00:25:35.960 --> 00:25:43.280
自动检测或多或少或

00:25:40.190 --> 00:25:46.250
标题将是或可能是字符串字段

00:25:43.280 --> 00:25:50.360
它也会看到一个字段

00:25:46.250 --> 00:25:53.290
称为潜在或更多日期

00:25:50.360 --> 00:25:56.299
当然会是一个有时间的日期， 

00:25:53.290 --> 00:25:58.610
轨道可能是字符串

00:25:56.299 --> 00:26:01.580
我的东西，但它将是字符串和

00:25:58.610 --> 00:26:03.799
 elasticsearch然后做的是

00:26:01.580 --> 00:26:08.030
为您创建一个架构，这是

00:26:03.799 --> 00:26:10.360
重要，因为所有这些搜索

00:26:08.030 --> 00:26:13.549
基于Lucene的服务器实现

00:26:10.360 --> 00:26:15.850
需要你有一个模式

00:26:13.549 --> 00:26:18.470
他们是他们中的大多数

00:26:15.850 --> 00:26:21.590
 elasticsearch声称或多或少

00:26:18.470 --> 00:26:25.250
少方案，太阳能也是如此，但是

00:26:21.590 --> 00:26:27.750
后面总有一个策划者

00:26:25.250 --> 00:26:30.480
在这些东西后面，所以有一个模式

00:26:27.750 --> 00:26:32.190
在搜索服务器本身中，您可以

00:26:30.480 --> 00:26:36.420
看看这个kima，我们

00:26:32.190 --> 00:26:41.040
期望基本上有映射和

00:26:36.420 --> 00:26:43.170
在会议中有

00:26:41.040 --> 00:26:47.490
属性，如您所见，有一个

00:26:43.170 --> 00:26:49.970
日期类型日期日期所以弹性搜索

00:26:47.490 --> 00:26:55.290
将其识别为带有和的日期

00:26:49.970 --> 00:26:58.170
明确的模式，所以时间到了

00:26:55.290 --> 00:27:00.570
在这种情况下，它可以识别

00:26:58.170 --> 00:27:04.110
标题为字符串，轨道也为

00:27:00.570 --> 00:27:05.910
作为一个字符串，这真的很好，很酷

00:27:04.110 --> 00:27:09.420
如果您正在与之合作，但

00:27:05.910 --> 00:27:11.670
如你所想，因为有

00:27:09.420 --> 00:27:17.250
我可以在那里有一个专用的架构

00:27:11.670 --> 00:27:23.970
继续尝试做一个原始

00:27:17.250 --> 00:27:29.040
文档并将一些无效字段放入

00:27:23.970 --> 00:27:31.320
在那里，因为有人对某人的同意

00:27:29.040 --> 00:27:34.230
头脑进入了一天，它看起来像

00:27:31.320 --> 00:27:37.070
这个，当我尝试现在尝试添加时

00:27:34.230 --> 00:27:40.440
它基本上会返回一个错误

00:27:37.070 --> 00:27:43.530
告诉我我不能添加这个

00:27:40.440 --> 00:27:49.290
文档到我的索引，因为类型

00:27:43.530 --> 00:27:52.410
不匹配，所以在这种情况下

00:27:49.290 --> 00:27:57.300
显然，它不会起作用，但是假设

00:27:52.410 --> 00:28:00.540
你那里有数字，第一个

00:27:57.300 --> 00:28:03.990
当您传递文件时，可能是

00:28:00.540 --> 00:28:05.310
一个整数值，这工作正常

00:28:03.990 --> 00:28:09.120
几次，然后你

00:28:05.310 --> 00:28:12.030
突然开始传给龙，所以现在

00:28:09.120 --> 00:28:14.760
你有一个问题，因为这些关键

00:28:12.030 --> 00:28:16.500
汽车旅馆，这是您传入的整数

00:28:14.760 --> 00:28:19.050
多久你会得到一个错误以及你所拥有的

00:28:16.500 --> 00:28:21.240
然后要做的是架构迁移，因此您

00:28:19.050 --> 00:28:24.780
基本上必须重演所有这些

00:28:21.240 --> 00:28:27.690
东西，因为你不能改变

00:28:24.780 --> 00:28:28.520
我们已经看到过的字段类型不会让您

00:28:27.690 --> 00:28:33.060
去做

00:28:28.520 --> 00:28:34.830
所以我真的要小心

00:28:33.060 --> 00:28:37.560
这很容易推动

00:28:34.830 --> 00:28:41.010
文件，但您必须考虑

00:28:37.560 --> 00:28:44.160
文件将代表什么

00:28:41.010 --> 00:28:45.420
在您的商店内，尤其是在

00:28:44.160 --> 00:28:46.950
弹性搜索和亮氨酸

00:28:45.420 --> 00:28:49.470
我的意思是MongoDB是另一回事

00:28:46.950 --> 00:28:52.350
 MongoDB完全没有架构

00:28:49.470 --> 00:28:54.000
 UTP您可以通过搜索来执行此操作

00:28:52.350 --> 00:28:55.920
视类型而定

00:28:54.000 --> 00:28:57.960
你是研究的国歌，但是

00:28:55.920 --> 00:28:59.460
 MongoDB可能不是基于

00:28:57.960 --> 00:29:03.990
现场是一些

00:28:59.460 --> 00:29:06.390
不同的部分好吧，那是一个真实的

00:29:03.990 --> 00:29:08.310
真正的简短了解架构是什么

00:29:06.390 --> 00:29:11.610
它所做的是为了

00:29:08.310 --> 00:29:15.320
还有更多

00:29:11.610 --> 00:29:20.040
模式，因为您还可以添加

00:29:15.320 --> 00:29:22.020
有关如何处理数据的信息，如果

00:29:20.040 --> 00:29:27.360
您可以基本上存储文档

00:29:22.020 --> 00:29:30.180
定义字符串，比如说

00:29:27.360 --> 00:29:33.570
如果某些字段的字符串被视为

00:29:30.180 --> 00:29:35.910
它是分裂的还是整体的

00:29:33.570 --> 00:29:37.770
数字，我会消除它，如果它较低

00:29:35.910 --> 00:29:40.020
装箱了你

00:29:37.770 --> 00:29:43.500
所以elasticsearch应用了

00:29:40.020 --> 00:29:46.230
这些或默认情况下，但给你一个

00:29:43.500 --> 00:29:49.620
真正的印象基本上是要做的

00:29:46.230 --> 00:29:52.320
关于这个特殊的一些分析

00:29:49.620 --> 00:29:55.740
Spring 之一的弦-GX 2015 in 

00:29:52.320 --> 00:29:58.680
华盛顿特区，当我尝试分析时

00:29:55.740 --> 00:30:02.370
你会看到有一堆

00:29:58.680 --> 00:30:06.390
的令牌返回，令牌始终具有

00:30:02.370 --> 00:30:09.420
抵消您是字母数字的类型

00:30:06.390 --> 00:30:11.460
可以看到2015年它检测到这是

00:30:09.420 --> 00:30:13.920
数量不多

00:30:11.460 --> 00:30:14.880
通常它不是字母数字，所以可以

00:30:13.920 --> 00:30:20.130
区别对待

00:30:14.880 --> 00:30:23.430
哦，是的，基本上就是这样，你知道

00:30:20.130 --> 00:30:27.090
每个令牌都得到一个位置并回家

00:30:23.430 --> 00:30:29.070
值具有偏移量，依此类推等等

00:30:27.090 --> 00:30:31.520
哎呀

00:30:29.070 --> 00:30:33.810
所以有很多不同

00:30:31.520 --> 00:30:37.860
不同的标记器

00:30:33.810 --> 00:30:39.990
所以我可以认为我可以

00:30:37.860 --> 00:30:42.750
使用a删除数字部分

00:30:39.990 --> 00:30:45.360
不同的分词器，所以如果我不是

00:30:42.750 --> 00:30:48.300
对我的搜索感兴趣的任何数字

00:30:45.360 --> 00:30:50.700
无论出于什么原因我都可以珍惜

00:30:48.300 --> 00:30:51.399
继续使用字母标记器

00:30:50.700 --> 00:30:54.849
身体

00:30:51.399 --> 00:30:59.009
 Walt从字符串中删除了2015 

00:30:54.849 --> 00:31:02.830
甚至还有2g ex的d2 

00:30:59.009 --> 00:31:09.789
单方令牌好

00:31:02.830 --> 00:31:12.960
这就是GDG组织者

00:31:09.789 --> 00:31:17.799
我可以申请的代币Isis之外

00:31:12.960 --> 00:31:19.629
过滤器提取的令牌

00:31:17.799 --> 00:31:23.529
令牌生成器，那是什么意思

00:31:19.629 --> 00:31:27.729
基本上，如果您没有定义任何

00:31:23.529 --> 00:31:30.429
过滤器哦，你将不得不

00:31:27.729 --> 00:31:32.649
完全匹配，春季1 

00:31:30.429 --> 00:31:35.349
将用大写的s和大写的一半

00:31:32.649 --> 00:31:37.359
 o但是对于搜索而言，并不总是

00:31:35.349 --> 00:31:42.330
最好的做法是让您基本上想要

00:31:37.359 --> 00:31:45.999
做一个更低的它

00:31:42.330 --> 00:31:49.330
在您的搜索索引中花费更少

00:31:45.999 --> 00:31:51.129
放置并易于搜索

00:31:49.330 --> 00:31:54.070
因为用户不必关心

00:31:51.129 --> 00:31:57.070
关于原始价值和骆驼

00:31:54.070 --> 00:31:59.830
肠衣，你和我有什么

00:31:57.070 --> 00:32:02.580
可以做的就是我可以过滤到

00:31:59.830 --> 00:32:07.059
如果我有春天1到GX 

00:32:02.580 --> 00:32:08.739
我可以在华盛顿特区的华盛顿特区

00:32:07.059 --> 00:32:12.999
当我现在继续小写

00:32:08.739 --> 00:32:16.779
独特的，你会看到华盛顿

00:32:12.999 --> 00:32:20.619
现在只在它的第一个出现时

00:32:16.779 --> 00:32:24.960
第一次遇到所以一如既往

00:32:20.619 --> 00:32:28.539
有一个陷阱，因为

00:32:24.960 --> 00:32:32.080
过滤金属的数量很多

00:32:28.539 --> 00:32:36.039
当我把它弄乱并放置一个独特的

00:32:32.080 --> 00:32:38.950
在小写过滤器之前过滤

00:32:36.039 --> 00:32:42.070
将无法消除D项

00:32:38.950 --> 00:32:45.369
但是它们还是小写的

00:32:42.070 --> 00:32:48.609
如果我这样做的话，你会看到

00:32:45.369 --> 00:32:51.249
华盛顿在第4位， 

00:32:48.609 --> 00:32:54.219
通过小写字母和

00:32:51.249 --> 00:32:55.570
那没有太大意义，所以你

00:32:54.219 --> 00:32:59.829
必须意识到

00:32:55.570 --> 00:33:01.600
当您与计划者打交道或尝试

00:32:59.829 --> 00:33:05.290
去做

00:33:01.600 --> 00:33:09.180
为实现添加过滤器

00:33:05.290 --> 00:33:13.500
顺序真的很重要，并且会

00:33:09.180 --> 00:33:25.810
那不是我想要的

00:33:13.500 --> 00:33:29.650
谢谢，好吧，好吧，让我们开始吧

00:33:25.810 --> 00:33:32.140
基本搜索哦，真正的快速找到所有

00:33:29.650 --> 00:33:34.470
文件根本不在乎什么

00:33:32.140 --> 00:33:37.210
告诉你一些得分

00:33:34.470 --> 00:33:39.370
所以我现在要做的是执行搜索

00:33:37.210 --> 00:33:40.750
这给了我所有的文件

00:33:39.370 --> 00:33:43.930
基本上就是这些会话的索引

00:33:40.750 --> 00:33:45.940
在那里，我想告诉

00:33:43.930 --> 00:33:49.810
表明你是Elasticsearch回报

00:33:45.940 --> 00:33:53.440
您的总点击数，所以您

00:33:49.810 --> 00:33:55.150
自动知道多少文件

00:33:53.440 --> 00:33:57.190
和你在一起在那里是完美的

00:33:55.150 --> 00:33:58.570
匹配 spring data 或页面

00:33:57.190 --> 00:34:00.670
抽象，因为我们总是告诉你

00:33:58.570 --> 00:34:02.740
有多少文件符合您的条件

00:34:00.670 --> 00:34:05.830
搜索它会告诉您最高分

00:34:02.740 --> 00:34:07.780
遇到的所有

00:34:05.830 --> 00:34:10.450
符合您搜索条件的文档和

00:34:07.780 --> 00:34:13.720
有一个领域是

00:34:10.450 --> 00:34:17.110
这个核心领域，所以分数基本上可以说明

00:34:13.720 --> 00:34:20.410
您与特定内容的相关性

00:34:17.110 --> 00:34:22.720
与您搜索字词相关的文档

00:34:20.410 --> 00:34:24.880
输入了我没有输入任何搜索词

00:34:22.720 --> 00:34:27.370
所以所有文件都一样

00:34:24.880 --> 00:34:29.800
与百分之一百相关

00:34:27.370 --> 00:34:32.560
一直想要他们，如您所见

00:34:29.800 --> 00:34:35.050
那里有分数，那里有一个分数

00:34:32.560 --> 00:34:37.090
注意事项elasticsearch总是返回

00:34:35.050 --> 00:34:39.220
您原始的数据结构

00:34:37.090 --> 00:34:45.100
内的原始JSON结构

00:34:39.220 --> 00:34:50.760
 Chasen的源元素可以返回

00:34:45.100 --> 00:34:54.580
现在让我们来看看

00:34:50.760 --> 00:34:58.180
另一个搜索，如你所见，我

00:34:54.580 --> 00:34:59.650
提供我寻找的全部

00:34:58.180 --> 00:35:01.360
文本搜索和数据，因此基本上

00:34:59.650 --> 00:35:04.960
退还我所有的文件

00:35:01.360 --> 00:35:07.810
里面的数据，现在已经排序了

00:35:04.960 --> 00:35:09.880
通过相关性，这就是

00:35:07.810 --> 00:35:12.790
太阳能和

00:35:09.880 --> 00:35:14.610
 elasticsearch MongoDB在这种情况下是

00:35:12.790 --> 00:35:18.150
也不同，因为

00:35:14.610 --> 00:35:20.580
它不会使用自然顺序

00:35:18.150 --> 00:35:23.460
而Elasticsearch和Sola总是

00:35:20.580 --> 00:35:26.490
如果您不退还给您喷水命令

00:35:23.460 --> 00:35:29.010
定义不同，所以最

00:35:26.490 --> 00:35:31.980
相关文件将永远是

00:35:29.010 --> 00:35:36.810
首先是，相关性是

00:35:31.980 --> 00:35:39.270
由单词位置

00:35:36.810 --> 00:35:41.640
字段及其出现的频率，以及

00:35:39.270 --> 00:35:46.170
有一个非常复杂的算法

00:35:41.640 --> 00:35:50.340
完成了，但是您可以对

00:35:46.170 --> 00:35:53.280
得分，所以如果我基本上尝试查询

00:35:50.340 --> 00:35:56.520
具有引导和数据的多个字段，以及

00:35:53.280 --> 00:35:58.440
标题轨道，我可以看到此和弦

00:35:56.520 --> 00:36:03.260
变化，因为有多个搜索

00:35:58.440 --> 00:36:06.060
条款，我将其限制为字段和

00:36:03.260 --> 00:36:09.410
和平核心价值观，现在看起来

00:36:06.060 --> 00:36:13.050
不一样，这就是你

00:36:09.410 --> 00:36:15.840
非常有用，因为您可以获得它可以

00:36:13.050 --> 00:36:18.540
向您的用户提供有关如何

00:36:15.840 --> 00:36:22.980
可能与您的结果相关

00:36:18.540 --> 00:36:26.520
目前他们是，但你也可以

00:36:22.980 --> 00:36:29.120
影响他的核心有点所以

00:36:26.520 --> 00:36:32.520
之所以称为助推，是因为我

00:36:29.120 --> 00:36:35.550
希望在该领域获得成功

00:36:32.520 --> 00:36:37.770
称号比

00:36:35.550 --> 00:36:40.290
可能在类别中或

00:36:37.770 --> 00:36:42.600
在轨道上，因为我不是真的

00:36:40.290 --> 00:36:46.280
对那些我只想找到的人感兴趣

00:36:42.600 --> 00:36:50.010
这些在这些会议上有一个

00:36:46.280 --> 00:36:52.980
标题中的引导和数据以及什么

00:36:50.010 --> 00:36:57.480
我在这里是查询时间的增加，所以我

00:36:52.980 --> 00:36:59.880
告诉搜索服务器对待搜索

00:36:57.480 --> 00:37:03.540
在某个领域内命中率不同

00:36:59.880 --> 00:37:06.780
所以它的重量更大

00:37:03.540 --> 00:37:10.010
我不懂英语表达

00:37:06.780 --> 00:37:13.490
很好的回音

00:37:10.010 --> 00:37:16.770
我不知道一次或多次的力量

00:37:13.490 --> 00:37:19.500
是的，好的，基本上就是

00:37:16.770 --> 00:37:22.710
先生的语法，如果我们看看

00:37:19.500 --> 00:37:24.630
在目前如此春季

00:37:22.710 --> 00:37:27.780
数据剩余满足超媒体和安全性

00:37:24.630 --> 00:37:28.350
这是辐射的顶部，让我们看看是否

00:37:27.780 --> 00:37:30.600
没有

00:37:28.350 --> 00:37:32.850
它仍然准备顶，但它有一个

00:37:30.600 --> 00:37:36.840
里面有不同的重量

00:37:32.850 --> 00:37:39.450
会话确实从下方向上移动

00:37:36.840 --> 00:37:41.760
所以第一个没有改变，但是是

00:37:39.450 --> 00:37:43.700
因为它是最热门但第二

00:37:41.760 --> 00:37:46.080
您看到订单已更改，或者

00:37:43.700 --> 00:37:48.480
取决于您在其中定义的内容

00:37:46.080 --> 00:37:51.810
您的查询很好，因为

00:37:48.480 --> 00:37:54.030
您可以在实际搜索时完成

00:37:51.810 --> 00:37:56.100
而且你也不能事先定义它

00:37:54.030 --> 00:37:58.350
在这些化学中，因此您可以定义

00:37:56.100 --> 00:38:01.170
它在那里，以便用户没有

00:37:58.350 --> 00:38:04.430
照顾，但你也可以在查询

00:38:01.170 --> 00:38:04.430
时间真的很棒

00:38:09.530 --> 00:38:18.900
好吧，让我们移回去，有一件事我

00:38:16.770 --> 00:38:20.910
并没有告诉您有关的信息

00:38:18.900 --> 00:38:23.220
查询与

00:38:20.910 --> 00:38:34.020
过滤查询，以便我们了解评分

00:38:23.220 --> 00:38:36.320
在你应该继续之前，如何让我

00:38:34.020 --> 00:38:36.320
再试一次

00:38:36.830 --> 00:38:39.830
你好

00:38:44.430 --> 00:38:52.860
哦，我击碎了Beamer，对此我感到抱歉

00:38:49.260 --> 00:38:59.310
我不知道那是什么

00:38:52.860 --> 00:39:06.510
再次回来哦，哇好吧竖起大拇指

00:38:59.310 --> 00:39:09.270
哦，好吧，我想告诉你

00:39:06.510 --> 00:39:11.850
关于查询良好与过滤查询的关系

00:39:09.270 --> 00:39:18.290
基本查询信息对

00:39:11.850 --> 00:39:22.530
得分，所以您对int的搜索很好

00:39:18.290 --> 00:39:24.780
是的，所以完全可以填充查询

00:39:22.530 --> 00:39:26.790
影响力得分，因此您基本上可以

00:39:24.780 --> 00:39:31.910
定义消除文件的标准

00:39:26.790 --> 00:39:34.350
从您的搜索而无需

00:39:31.910 --> 00:39:38.250
对得分的影响，所以顺序

00:39:34.350 --> 00:39:42.050
不会仍然存在会像你一样

00:39:38.250 --> 00:39:46.970
你还没有定义，它将令法令如此

00:39:42.050 --> 00:39:46.970
是的，谢谢

00:39:49.610 --> 00:39:58.440
正是这样，让我们​​直接进入

00:39:54.860 --> 00:40:01.590
 MongoDB，看看我们有什么功能

00:39:58.440 --> 00:40:04.380
那里有我们如何建立搜索

00:40:01.590 --> 00:40:07.500
索引以及如何使用MongoDB 

00:40:04.380 --> 00:40:09.870
在那里进行全文搜索

00:40:07.500 --> 00:40:13.470
样品我想给你看些东西

00:40:09.870 --> 00:40:15.450
基本上，我希望大家都知道

00:40:13.470 --> 00:40:19.170
网站，这是我们自己的网站， 

00:40:15.450 --> 00:40:22.590
我们的街区，这里有我们

00:40:19.170 --> 00:40:26.130
在那里集成了全文本搜索

00:40:22.590 --> 00:40:29.550
这实际上是由Elasticsearch支持的

00:40:26.130 --> 00:40:32.420
幕后以及我想做什么

00:40:29.550 --> 00:40:37.290
我想搜索一个特定的

00:40:32.420 --> 00:40:40.620
高斯林一个特定的搜索词，我作为

00:40:37.290 --> 00:40:43.140
希望我能找到最新的 spring data 

00:40:40.620 --> 00:40:45.690
释放火车和所有这些东西

00:40:43.140 --> 00:40:50.220
想告诉你基本上是

00:40:45.690 --> 00:40:55.110
这附近的东西

00:40:50.220 --> 00:40:57.960
所谓的方面，所以方面是一部分

00:40:55.110 --> 00:40:58.920
用于引导式导航

00:40:57.960 --> 00:41:03.109
基本上

00:40:58.920 --> 00:41:06.119
您，有些文件有

00:41:03.109 --> 00:41:09.390
某种类型的原因是每个博客帖子都是

00:41:06.119 --> 00:41:11.549
要么回复其中的每个内容

00:41:09.390 --> 00:41:14.430
博客文章或指南或其他内容

00:41:11.549 --> 00:41:16.829
你和博客归类于

00:41:14.430 --> 00:41:19.500
工程新闻和事件，所以每一个

00:41:16.829 --> 00:41:22.799
博客帖子基本上已分配给

00:41:19.500 --> 00:41:25.380
类别以及它说明了什么

00:41:22.799 --> 00:41:27.839
您有多少文件符合您的条件

00:41:25.380 --> 00:41:30.780
标准实际上显示在

00:41:27.839 --> 00:41:34.890
这些类别，因此您基本上可以

00:41:30.780 --> 00:41:36.930
引导您的用户使用某些类别或

00:41:34.890 --> 00:41:40.349
像亚马逊一样，它告诉你嘿

00:41:36.930 --> 00:41:43.680
是15本奇幻书籍的热门作品并获胜

00:41:40.349 --> 00:41:46.680
别人，你有什么，所以

00:41:43.680 --> 00:41:48.630
用户基本上可以向下钻取

00:41:46.680 --> 00:41:51.930
更具体，他正在寻找什么

00:41:48.630 --> 00:41:54.480
所以这真的很好，我们也

00:41:51.930 --> 00:41:58.260
在这里，我希望你能有更多的解决方案

00:41:54.480 --> 00:42:01.760
允许这突出显示，所以我的搜索

00:41:58.260 --> 00:42:04.559
学期是的，我想这是真的

00:42:01.760 --> 00:42:06.660
以某种方式突出显示，因此在这种情况下

00:42:04.559 --> 00:42:08.880
它是大胆的，它有一个不同的休息时间

00:42:06.660 --> 00:42:12.089
背景颜色，所以这些都很好

00:42:08.880 --> 00:42:16.400
搜索可以为您提供的功能

00:42:12.089 --> 00:42:18.630
尽管我必须承认那些

00:42:16.400 --> 00:42:20.490
突出显示和刻面功能

00:42:18.630 --> 00:42:23.069
是全面搜索的一部分

00:42:20.490 --> 00:42:26.520
像我们的弹性搜索和

00:42:23.069 --> 00:42:28.859
太阳能有计划为

00:42:26.520 --> 00:42:31.609
据我在他们的JIRA中阅读的MongoDB 

00:42:28.859 --> 00:42:35.280
但是到目前为止还没有实现

00:42:31.609 --> 00:42:38.609
但是对于主要的东西，如果你不这样做

00:42:35.280 --> 00:42:40.920
取决于由

00:42:38.609 --> 00:42:44.490
方面或突出显示内容

00:42:40.920 --> 00:42:49.049
 MongoDB可以做的很好，所以

00:42:44.490 --> 00:42:51.859
让我们建立让我们建立博客

00:42:49.049 --> 00:42:56.809
具有全文搜索的系统

00:42:51.859 --> 00:42:56.809
让我启动MongoDB 

00:42:59.160 --> 00:43:09.630
并使用测试，所以我们首先需要什么

00:43:03.780 --> 00:43:12.740
要定义的是你们能读吗

00:43:09.630 --> 00:43:23.190
从背面可以吗？ 

00:43:12.740 --> 00:43:28.470
让我移动一下，是的，不会回头

00:43:23.190 --> 00:43:30.870
好吧，让我们将其向上移动一点，以便我

00:43:28.470 --> 00:43:33.300
希望更好的是你首先需要的

00:43:30.870 --> 00:43:37.350
要做的是我们必须定义一个特殊的

00:43:33.300 --> 00:43:41.060
 MongoDB中的索引，我们可以通过

00:43:37.350 --> 00:43:44.400
通过电话和下水道索引发布

00:43:41.060 --> 00:43:46.890
给它我想要的所有属性

00:43:44.400 --> 00:43:50.960
我要全文搜索吗

00:43:46.890 --> 00:43:55.470
能够做到这一点，我必须添加

00:43:50.960 --> 00:43:59.820
文本关键字基本上与类型相同

00:43:55.470 --> 00:44:04.350
您可以在此处看到的部分是

00:43:59.820 --> 00:44:08.130
基本上影响a的平方

00:44:04.350 --> 00:44:10.740
搜索文档时，例如

00:44:08.130 --> 00:44:15.450
在这个例子中，我要你

00:44:10.740 --> 00:44:18.060
以标题方式衡量搜索结果更多

00:44:15.450 --> 00:44:21.600
比一个内容，这是

00:44:18.060 --> 00:44:23.820
基本上是您唯一的方式

00:44:21.600 --> 00:44:27.240
目前可以影响的方式

00:44:23.820 --> 00:44:30.720
用MongoDB查询，以便对此进行索引

00:44:27.240 --> 00:44:33.030
我正在进步，你必须考虑

00:44:30.720 --> 00:44:35.040
在实际创建索引之前

00:44:33.030 --> 00:44:37.560
当然，MongoDB相当容易

00:44:35.040 --> 00:44:39.330
只需删除索引并重新创建它即可

00:44:37.560 --> 00:44:41.520
为您完成，但您必须考虑

00:44:39.330 --> 00:44:45.690
否则您的搜索结果可能

00:44:41.520 --> 00:44:48.180
可能有点糟糕

00:44:45.690 --> 00:44:54.570
所以让我们在其中添加该索引

00:44:48.180 --> 00:44:57.330
然后只插入一些随机的JSON 

00:44:54.570 --> 00:45:00.180
您所看到的文档中有详细信息

00:44:57.330 --> 00:45:05.760
在这里和内容，我只添加它

00:45:00.180 --> 00:45:08.460
然后我继续使用MongoDB语法

00:45:05.760 --> 00:45:12.410
用于文本搜索，基本上是我

00:45:08.460 --> 00:45:14.060
添加了与美元文本一致的

00:45:12.410 --> 00:45:16.600
讨厌我要全文搜索

00:45:14.060 --> 00:45:19.010
然后我给你搜索词

00:45:16.600 --> 00:45:21.920
由美元搜索和

00:45:19.010 --> 00:45:24.860
搜索包含以下内容的任何文档

00:45:21.920 --> 00:45:29.090
标题内容或类别D字符串

00:45:24.860 --> 00:45:32.210
我想漂亮地打印它，是的

00:45:29.090 --> 00:45:36.610
好吧，这不会返回任何结果，所以

00:45:32.210 --> 00:45:40.880
这是为什么，因为MongoDB 

00:45:36.610 --> 00:45:44.900
内置了stammers令牌生成器

00:45:40.880 --> 00:45:47.240
停止说话你16岁左右

00:45:44.900 --> 00:45:49.070
我希望我不会说什么语言

00:45:47.240 --> 00:45:51.860
在这里错了，但应该是16 

00:45:49.070 --> 00:45:54.380
语言以及令牌生成器发送的内容

00:45:51.860 --> 00:45:56.960
雄蕊为您做的基本上在

00:45:54.380 --> 00:45:59.810
为了使搜索索引较小并

00:45:56.960 --> 00:46:02.300
他们很快消除了常用词， 

00:45:59.810 --> 00:46:08.030
这是一个非常非常普遍的短语吗

00:46:02.300 --> 00:46:10.880
所以基本上当MongoDB看到

00:46:08.030 --> 00:46:13.670
记录在这里，它可以识别

00:46:10.880 --> 00:46:15.920
是个停用词，算了我不

00:46:13.670 --> 00:46:18.530
需要它，所以您将无法

00:46:15.920 --> 00:46:19.880
搜索它就是你

00:46:18.530 --> 00:46:23.750
应该知道您何时使用

00:46:19.880 --> 00:46:25.610
 MongoDB，因此您的搜索词应该

00:46:23.750 --> 00:46:29.060
您应该搜索的东西

00:46:25.610 --> 00:46:32.120
它应该在某种程度上

00:46:29.060 --> 00:46:35.240
移动数据库还可以，因为您

00:46:32.120 --> 00:46:37.250
无法自定义其行为

00:46:35.240 --> 00:46:39.440
因为它只是内置在里面

00:46:37.250 --> 00:46:42.770
准备好供您使用，但您不能

00:46:39.440 --> 00:46:46.670
更改它，但如果我能很好地工作

00:46:42.770 --> 00:46:50.690
继续搜索就可以说

00:46:46.670 --> 00:46:53.900
华盛顿然后好吧，您看到的内容

00:46:50.690 --> 00:46:55.550
在华盛顿基本上是

00:46:53.900 --> 00:46:57.440
术语包含在内容字段中

00:46:55.550 --> 00:47:01.040
刚把它还给我

00:46:57.440 --> 00:47:05.450
一切都很好，所以让我们

00:47:01.040 --> 00:47:12.020
再次删除索引，让我们看看如何

00:47:05.450 --> 00:47:14.690
我们可以用 spring data 做到这一点

00:47:12.020 --> 00:47:17.510
使用 spring data ，我们基本上有

00:47:14.690 --> 00:47:20.030
结构非常相似，我们有一篇博客文章

00:47:17.510 --> 00:47:22.550
具有年份标题的内容可能是

00:47:20.030 --> 00:47:25.500
分配给类别和您所看到的

00:47:22.550 --> 00:47:27.570
这基本上是这个核心，因为我

00:47:25.500 --> 00:47:29.790
我对自己的分数感兴趣

00:47:27.570 --> 00:47:33.060
对我的搜索结果如何感兴趣

00:47:29.790 --> 00:47:37.140
所以我在这里添加了这个核心领域

00:47:33.060 --> 00:47:40.349
拿起价值，这又如何

00:47:37.140 --> 00:47:43.619
这里的小朋友告诉春天

00:47:40.349 --> 00:47:55.140
忽略要写入的属性的数据

00:47:43.619 --> 00:47:56.730
一个问题哦，确定是的，对不起，好的

00:47:55.140 --> 00:47:58.470
小朋友告诉春天的数据

00:47:56.730 --> 00:48:01.349
抽象只是忽略它

00:47:58.470 --> 00:48:04.020
写作，但如果在那里或结果

00:48:01.349 --> 00:48:10.440
它只是将值读回到您的

00:48:04.020 --> 00:48:12.359
您的域名类型好吧，让我们继续

00:48:10.440 --> 00:48:14.849
一些简单的搜索，如您之前所见

00:48:12.359 --> 00:48:17.700
我们可以在

00:48:14.849 --> 00:48:20.130
控制台，我们基本上会为您提供数据

00:48:17.700 --> 00:48:23.430
有一些叫做文本索引的东西

00:48:20.130 --> 00:48:27.150
定义与建设者，所以我们

00:48:23.430 --> 00:48:30.930
基本上在字段标题上定义一个

00:48:27.150 --> 00:48:33.690
我想把三重

00:48:30.930 --> 00:48:35.609
内容字段默认为140 

00:48:33.690 --> 00:48:38.490
类别字段，然后创建索引

00:48:35.609 --> 00:48:41.430
定义并告诉索引操作

00:48:38.490 --> 00:48:46.680
为此，只需创建博客文章类型

00:48:41.430 --> 00:48:52.980
对我来说索引很简单，然后

00:48:46.680 --> 00:48:55.770
我可以继续说，只要定义一个

00:48:52.980 --> 00:48:57.810
默认语言的文本标准

00:48:55.770 --> 00:48:59.900
是一个MongoDB，基本上是英语，但是我可以

00:48:57.810 --> 00:49:02.280
使用其他十六个之一

00:48:59.900 --> 00:49:04.380
匹配我手上的任何搜索词

00:49:02.280 --> 00:49:08.130
在这里可能被释放，因为

00:49:04.380 --> 00:49:11.550
刚刚下载了我们的

00:49:08.130 --> 00:49:14.070
博客出现在这里有一个

00:49:11.550 --> 00:49:17.250
简洁的结果，然后基本上

00:49:14.070 --> 00:49:19.530
使用Mongo执行这些东西

00:49:17.250 --> 00:49:22.530
操作调用中找到

00:49:19.530 --> 00:49:24.599
我基本上可以连锁其他的标准

00:49:22.530 --> 00:49:26.730
文字搜索的标准只要一个

00:49:24.599 --> 00:49:30.750
因为我不使用特殊索引，例如

00:49:26.730 --> 00:49:33.540
地理空间搜索我可以使用其他术语

00:49:30.750 --> 00:49:37.109
结合起来，所以我基本上也可以

00:49:33.540 --> 00:49:39.210
说，文件必须有

00:49:37.109 --> 00:49:43.950
分类发布有什么

00:49:39.210 --> 00:49:46.200
你还好，基本上执行

00:49:43.950 --> 00:49:48.720
寻找我，当你看到它

00:49:46.200 --> 00:49:51.510
这是结果，值得注意的是

00:49:48.720 --> 00:49:54.349
这个核心领域虽然我在这里

00:49:51.510 --> 00:49:58.589
我的域内的类型当前为null 

00:49:54.349 --> 00:50:00.690
这是因为MongoDB不会

00:49:58.589 --> 00:50:03.720
默认情况下，返回此核心字段

00:50:00.690 --> 00:50:06.030
因为要花一些时间然后炸毁

00:50:03.720 --> 00:50:09.690
结果的大小，你有什么所以你

00:50:06.030 --> 00:50:12.410
必须明确告诉MongoDB给

00:50:09.690 --> 00:50:16.109
它给你，你可以做到这一点

00:50:12.410 --> 00:50:20.089
鉴于此，定义了一个文本查询

00:50:16.109 --> 00:50:22.859
我们之前拥有的相同标准和

00:50:20.089 --> 00:50:26.520
美化您必须定义

00:50:22.859 --> 00:50:29.730
这个核心领域的核心，然后

00:50:26.520 --> 00:50:31.890
您基本上也可以按此排序

00:50:29.730 --> 00:50:33.300
字段，否则您将无法

00:50:31.890 --> 00:50:36.390
通过此核心排序

00:50:33.300 --> 00:50:39.570
 MongoDB尽可能返回自然顺序

00:50:36.390 --> 00:50:42.540
看看这里，这只是iOS或

00:50:39.570 --> 00:50:45.060
在这扇门里面的路

00:50:42.540 --> 00:50:47.940
然后您基本上可以继续使用

00:50:45.060 --> 00:50:53.880
使用此查询工具对结果进行排序

00:50:47.940 --> 00:50:56.339
当我这样做时，我就执行

00:50:53.880 --> 00:50:59.609
你可以看到这个核心领域是

00:50:56.339 --> 00:51:02.430
现在在那里给你，所以你的兴趣

00:50:59.609 --> 00:51:03.900
得到了你的回馈

00:51:02.430 --> 00:51:07.020
结果的顺序不同

00:51:03.900 --> 00:51:09.660
因为我们现在按分数排序，但是

00:51:07.020 --> 00:51:12.210
如果不是，那将不是 spring data 

00:51:09.660 --> 00:51:16.680
在那里尝试使它变得容易

00:51:12.210 --> 00:51:21.410
尽我们所能使用这项技术

00:51:16.680 --> 00:51:26.900
我们还为您提供的是

00:51:21.410 --> 00:51:31.770
所谓的文字比分

00:51:26.900 --> 00:51:33.720
注释基本上是

00:51:31.770 --> 00:51:35.160
只读注释作为其元数据

00:51:33.720 --> 00:51:38.310
注解，因此基本上是只读的

00:51:35.160 --> 00:51:39.930
字段，但是当我们检测到一个属性时， 

00:51:38.310 --> 00:51:43.109
在您的域内有此注释

00:51:39.930 --> 00:51:45.359
类型，而您使用的是MongoDB，我们假设

00:51:43.109 --> 00:51:48.869
您对这个核心感兴趣

00:51:45.359 --> 00:51:50.580
我们将所有其他部分添加到

00:51:48.869 --> 00:51:51.680
查询您否则必须

00:51:50.580 --> 00:51:56.630
类型

00:51:51.680 --> 00:51:59.570
所以这就是核心

00:51:56.630 --> 00:52:02.060
回到你身边，我们还有

00:51:59.570 --> 00:52:05.000
我们有自动创建索引

00:52:02.060 --> 00:52:08.450
您已经准备好，因此您基本上可以添加

00:52:05.000 --> 00:52:13.190
那里的文本索引注释给它一个

00:52:08.450 --> 00:52:16.000
像我们在那之前做的那样重

00:52:13.190 --> 00:52:16.000
我只要复制那个

00:52:16.630 --> 00:52:25.280
我们称这两个为无

00:52:21.050 --> 00:52:27.170
重量只是默认值之一，但它

00:52:25.280 --> 00:52:30.740
应该被索引，所以这差不多

00:52:27.170 --> 00:52:33.770
您需要做的所有事情来摆脱我的

00:52:30.740 --> 00:52:36.650
向您展示了这些小东西

00:52:33.770 --> 00:52:40.100
我现在所能做的基本上是

00:52:36.650 --> 00:52:42.790
定义我的阿姨域类型

00:52:40.100 --> 00:52:46.630
我编辑这些注释，它可以做到

00:52:42.790 --> 00:52:49.130
基本上只使用相同的搜索

00:52:46.630 --> 00:52:51.350
无需抽象存储库

00:52:49.130 --> 00:52:53.780
与的任何互动

00:52:51.350 --> 00:52:56.300
模板或较低级别的API 

00:52:53.780 --> 00:53:00.020
所以你拥有的一切都非常容易

00:52:56.300 --> 00:53:02.600
要做的就是传递文字标准或

00:53:00.020 --> 00:53:05.240
使用文本标准作为某些内容的一部分

00:53:02.600 --> 00:53:07.210
其他条件将检测到，然后

00:53:05.240 --> 00:53:11.120
只需执行全文搜索查询

00:53:07.210 --> 00:53:13.070
这很简单，是的，你也可以

00:53:11.120 --> 00:53:14.630
结合不匹配和

00:53:13.070 --> 00:53:20.360
你有什么或所有的东西

00:53:14.630 --> 00:53:24.460
 MongoDB基本上为您提供了良好的时间

00:53:20.360 --> 00:53:29.270
继续前进，我必须快一点

00:53:24.460 --> 00:53:33.050
太好了，我想我们已经基本完成了

00:53:29.270 --> 00:53:35.810
我将展示MongoDB抽象

00:53:33.050 --> 00:53:39.470
你有结巴并停下来

00:53:35.810 --> 00:53:44.050
这个核心没有回报的话

00:53:39.470 --> 00:53:49.610
您必须明确地对其进行排序

00:53:44.050 --> 00:53:51.500
我们做了索引创建和

00:53:49.610 --> 00:53:55.520
使用该命令自动创建索引

00:53:51.500 --> 00:53:58.010
响了，这个Corinne是的，谢谢

00:53:55.520 --> 00:54:00.530
哦，是的，我有一件事

00:53:58.010 --> 00:54:02.420
也想提一提

00:54:00.530 --> 00:54:05.120
在内部使用这些Corinne 

00:54:02.420 --> 00:54:05.360
派生查询，因此您基本上可以使用

00:54:05.120 --> 00:54:08.570
的

00:54:05.360 --> 00:54:10.550
天然Spring 数据或其中的细则

00:54:08.570 --> 00:54:13.130
您的方法声明，它将只是

00:54:10.550 --> 00:54:16.150
如您所愿地工作，这是

00:54:13.130 --> 00:54:16.150
整齐漂亮

00:54:16.570 --> 00:54:21.290
完全可以

00:54:18.620 --> 00:54:23.660
到目前为止的问题-否则MongoDB 

00:54:21.290 --> 00:54:25.840
我继续-是的问题

00:54:23.660 --> 00:54:25.840
啊

00:54:33.260 --> 00:54:39.320
哦，我实际上不知道，因为

00:54:37.130 --> 00:54:42.700
我可以检查的社区模块之一

00:54:39.320 --> 00:54:45.850
以后我们可以检查一下

00:54:42.700 --> 00:54:49.910
对不起，我实际上并不知道

00:54:45.850 --> 00:54:55.160
好吧，现在继续-Spring Data Solar 

00:54:49.910 --> 00:54:57.710
就像我之前说的，没有Lucene 

00:54:55.160 --> 00:55:00.140
基于搜索的服务器

00:54:57.710 --> 00:55:02.740
无需架构，因此您在太阳能领域所拥有的

00:55:00.140 --> 00:55:07.310
好是所谓的架构， 

00:55:02.740 --> 00:55:09.620
显然，这是一个XML文档

00:55:07.310 --> 00:55:13.820
该XML文档中您有一些东西

00:55:09.620 --> 00:55:16.730
基本上定义了关键字段

00:55:13.820 --> 00:55:19.250
有一个类型为字符串的IDE 

00:55:16.730 --> 00:55:22.340
现在有趣的部分是

00:55:19.250 --> 00:55:26.690
建立索引必须设置索引

00:55:22.340 --> 00:55:29.240
值为true才能拥有它

00:55:26.690 --> 00:55:31.130
可搜索，如果它是假的，你不会

00:55:29.240 --> 00:55:33.020
能够查询它会给你

00:55:31.130 --> 00:55:34.670
没有这样的错误

00:55:33.020 --> 00:55:37.670
感觉一无所知

00:55:34.670 --> 00:55:40.430
那就是全部，下一个道具

00:55:37.670 --> 00:55:43.010
属性被存储，所以存储了什么

00:55:40.430 --> 00:55:45.920
表示Stewart表示此属性是

00:55:43.010 --> 00:55:48.290
在那里作为您的一部分退还给您

00:55:45.920 --> 00:55:50.560
您在文档中的搜索结果

00:55:48.290 --> 00:55:54.880
好吧，这是必需的并且是多值的

00:55:50.560 --> 00:55:59.720
没什么没什么特别的

00:55:54.880 --> 00:56:05.360
但是如果您基本上有一个字段

00:55:59.720 --> 00:56:09.050
没有存储它可以潜在地使用

00:56:05.360 --> 00:56:12.050
用于搜索，因此您拥有

00:56:09.050 --> 00:56:15.830
与elasticsearch专业领域一样

00:56:12.050 --> 00:56:18.700
完成一个专门的目的，所以如果你

00:56:15.830 --> 00:56:18.700
有一个标题栏

00:56:19.260 --> 00:56:26.490
或者说名称字段，那么您

00:56:22.740 --> 00:56:29.790
按照通常的名称存储名称

00:56:26.490 --> 00:56:31.950
通常在您的索引范围内

00:56:29.790 --> 00:56:34.620
索引和斯图尔特，这意味着

00:56:31.950 --> 00:56:40.260
结果的一部分，但用于搜索您

00:56:34.620 --> 00:56:42.600
想要一个可能是小写的

00:56:40.260 --> 00:56:44.850
在那里有小写字母

00:56:42.600 --> 00:56:47.340
用户不必担心大小写或

00:56:44.850 --> 00:56:49.020
这些搜索字词中，因此您必须添加

00:56:47.340 --> 00:56:52.770
可能是

00:56:49.020 --> 00:56:55.230
键入小写字母，然后不存储

00:56:52.770 --> 00:56:59.070
只是谁对低端感兴趣

00:56:55.230 --> 00:57:01.080
案件结果几乎没人，但是

00:56:59.070 --> 00:57:08.940
放在里面很有用，因为您

00:57:01.080 --> 00:57:11.310
需要查询就可以了，在这里你

00:57:08.940 --> 00:57:13.500
基本上可以看到一个字段类型

00:57:11.310 --> 00:57:18.150
我们之前所看到的定义

00:57:13.500 --> 00:57:21.840
此字段的名称为type 

00:57:18.150 --> 00:57:27.360
常规文本，该字段类型后面

00:57:21.840 --> 00:57:29.490
定义基本上是

00:57:27.360 --> 00:57:32.910
信息领域应该如何

00:57:29.490 --> 00:57:35.490
在搜索服务器内处理过

00:57:32.910 --> 00:57:37.500
基本上它被标记化

00:57:35.490 --> 00:57:40.170
标准令牌生成器工厂

00:57:37.500 --> 00:57:42.240
需要两个字符串，因为它不适用

00:57:40.170 --> 00:57:43.710
您可以使用字母进行的任何标记化

00:57:42.240 --> 00:57:45.930
整理，那里有什么

00:57:43.710 --> 00:57:48.000
是一堆列出的

00:57:45.930 --> 00:57:51.630
网站我几乎解释了什么

00:57:48.000 --> 00:57:57.410
他们这样做，然后是一个小写过滤器

00:57:51.630 --> 00:58:01.200
工厂只是降低了字符串

00:57:57.410 --> 00:58:03.680
用于索引，因此基本上所有值

00:58:01.200 --> 00:58:07.260
都以小写形式写入索引

00:58:03.680 --> 00:58:11.250
您还可以定义一个特殊的

00:58:07.260 --> 00:58:14.970
处理查询，以便在查询时

00:58:11.250 --> 00:58:16.980
出现在字符串中，提供查询

00:58:14.970 --> 00:58:20.430
字符串也被标记

00:58:16.980 --> 00:58:24.780
和停用词是有限的，所有这些

00:58:20.430 --> 00:58:30.690
东西，所以那里真的有很多

00:58:24.780 --> 00:58:33.480
类型信息背后有很多

00:58:30.690 --> 00:58:36.660
给你，所以你得到了

00:58:33.480 --> 00:58:38.490
指向在那里调整索引， 

00:58:36.660 --> 00:58:42.840
您的搜索行为如何

00:58:38.490 --> 00:58:46.410
调整字段类型定义，但

00:58:42.840 --> 00:58:48.630
同样，您必须要小心，因为或

00:58:46.410 --> 00:58:50.640
考虑一下你想做什么

00:58:48.630 --> 00:58:54.240
你会用它来保护你

00:58:50.640 --> 00:58:58.140
因为再次，如果你改变东西

00:58:54.240 --> 00:59:00.720
那里可能会导致

00:58:58.140 --> 00:59:02.790
需要索引内容并重新索引

00:59:00.720 --> 00:59:06.840
根据您的索引大小可以

00:59:02.790 --> 00:59:08.450
需要几个小时或几天甚至是

00:59:06.840 --> 00:59:12.000
真的很长

00:59:08.450 --> 00:59:13.320
好，太阳能也有

00:59:12.000 --> 00:59:19.590
称为托管

00:59:13.320 --> 00:59:21.240
基本上是更多的化学模式或

00:59:19.590 --> 00:59:23.160
与我们所拥有的不一样

00:59:21.240 --> 00:59:24.930
 elasticsearch，所以它需要第一个

00:59:23.160 --> 00:59:27.840
收集到的文档，以及

00:59:24.930 --> 00:59:32.910
然后尝试以某种方式猜测DD字段

00:59:27.840 --> 00:59:39.470
打字，让我旋转太阳能

00:59:32.910 --> 00:59:42.060
实例给你，所以我在用

00:59:39.470 --> 00:59:46.859
这些附带的例子

00:59:42.060 --> 00:59:49.980
分布，所以基本上有一个

00:59:46.859 --> 00:59:53.510
此云设置的云示例

00:59:49.980 --> 00:59:56.580
在您可以使用的发行版中

00:59:53.510 --> 01:00:00.420
启动非常简单，然后

00:59:56.580 --> 01:00:03.810
它只是让你去太阳能

01:00:00.420 --> 01:00:05.609
管理员看起来像这样，你可以

01:00:03.810 --> 01:00:07.260
在云标签上看到

01:00:05.609 --> 01:00:09.810
基本上是一个称为

01:00:07.260 --> 01:00:11.880
入门，因为它是

01:00:09.810 --> 01:00:15.869
例如夏洛特有两个

01:00:11.880 --> 01:00:23.100
实际可用的节点以及我拥有的

01:00:15.869 --> 01:00:29.180
在这里完成的是索引本身，而我

01:00:23.100 --> 01:00:33.920
可以继续查询那里的三个

01:00:29.180 --> 01:00:37.470
在所有的东西后面

01:00:33.920 --> 01:00:40.470
有架构，所以架构是

01:00:37.470 --> 01:00:41.369
基本上隐藏在

01:00:40.470 --> 01:00:44.830
索引本身

01:00:41.369 --> 01:00:47.410
我有什么意思

01:00:44.830 --> 01:00:53.080
在这种情况下称为托管模式

01:00:47.410 --> 01:00:54.550
在里面，所以有一个基本的

01:00:53.080 --> 01:00:57.580
那里的配置

01:00:54.550 --> 01:01:03.369
您可以看到已经有字段

01:00:57.580 --> 01:01:06.369
包含的类型有一些

01:01:03.369 --> 01:01:08.860
有一个名称字段有一个

01:01:06.369 --> 01:01:12.430
文字类型一般，有

01:01:08.860 --> 01:01:16.480
那里的动态字段，因此您可以

01:01:12.430 --> 01:01:18.820
基本上定义通配符，以便每个

01:01:16.480 --> 01:01:23.170
以下划线I结尾的字段是

01:01:18.820 --> 01:01:26.800
视为整数，所以有

01:01:23.170 --> 01:01:29.410
在下面的策划者

01:01:26.800 --> 01:01:31.930
更新的特定文件，所以如果

01:01:29.410 --> 01:01:33.820
有一个太阳能看到一个新领域，当

01:01:31.930 --> 01:01:38.340
您基本上添加了一个文档

01:01:33.820 --> 01:01:38.340
该字段已添加到此文件中

01:01:42.330 --> 01:01:48.670
所以当我现在想独自搜寻时

01:01:46.930 --> 01:01:50.530
基本上可以单击继续并采取

01:01:48.670 --> 01:01:52.720
那里的字段名称并搜索

01:01:50.530 --> 01:01:56.859
两个有点热的搜索开始

01:01:52.720 --> 01:01:59.710
所有文件都退还给我

01:01:56.859 --> 01:02:04.150
以CA n开头的

01:01:59.710 --> 01:02:06.630
基本上是大炮或是的，有一个

01:02:04.150 --> 01:02:10.660
强力射击和你有什么

01:02:06.630 --> 01:02:13.690
我想告诉你的是

01:02:10.660 --> 01:02:16.270
基本上在那里突出显示为

01:02:13.690 --> 01:02:19.780
我们在博客文章示例中看到了

01:02:16.270 --> 01:02:21.730
我们看到您必须真正了解

01:02:19.780 --> 01:02:23.619
度字符串，所以您必须学习

01:02:21.730 --> 01:02:26.619
查询语言，突出显示的是

01:02:23.619 --> 01:02:31.600
那些代表的东西之一

01:02:26.619 --> 01:02:33.820
由HL代表或突出显示，但您

01:02:31.600 --> 01:02:36.160
必须知道，然后有FL 

01:02:33.820 --> 01:02:38.640
这基本上是字段列表

01:02:36.160 --> 01:02:43.480
突出显示应应用于

01:02:38.640 --> 01:02:46.990
它的用法不是很好，所以

01:02:43.480 --> 01:02:49.660
您基本上可以添加一个商店

01:02:46.990 --> 01:02:51.840
将其应用于所有字段并执行

01:02:49.660 --> 01:02:55.080
在那里突出

01:02:51.840 --> 01:02:58.730
这很了不起，因为在这里

01:02:55.080 --> 01:03:01.290
查看文档的回复，并

01:02:58.730 --> 01:03:03.930
那是两个文件，在这里

01:03:01.290 --> 01:03:05.610
在实际搜索结果旁边

01:03:03.930 --> 01:03:07.590
有突出显示的结果，所以

01:03:05.610 --> 01:03:09.390
突出显示实际上没有完成

01:03:07.590 --> 01:03:12.420
在您得到的文件中

01:03:09.390 --> 01:03:17.840
但旁边的意思是一样的

01:03:12.420 --> 01:03:23.460
 elasticsearch，所以您必须手动

01:03:17.840 --> 01:03:27.800
检查以下哪些ID与以下其中一项匹配

01:03:23.460 --> 01:03:32.880
那里的文件合并在一起

01:03:27.800 --> 01:03:36.090
这里的字符串是因为

01:03:32.880 --> 01:03:38.630
佳能被定义，这里是名称

01:03:36.090 --> 01:03:41.340
字段高亮显示，因此不是

01:03:38.630 --> 01:03:45.840
自动包含在内

01:03:41.340 --> 01:03:47.460
反映在 spring data 中

01:03:45.840 --> 01:03:49.940
以及 spring data 

01:03:47.460 --> 01:03:53.220
弹性搜索抽象有

01:03:49.940 --> 01:03:57.570
突出显示页面和多面

01:03:53.220 --> 01:04:01.200
页面和所有这些漂亮的东西

01:03:57.570 --> 01:04:04.560
很多让您可以访问突出显示

01:04:01.200 --> 01:04:06.570
从商店退回

01:04:04.560 --> 01:04:09.150
实施，所以我们不做

01:04:06.570 --> 01:04:11.700
为您合并，您仍然必须这样做

01:04:09.150 --> 01:04:15.330
手动，因为我们不想

01:04:11.700 --> 01:04:21.690
干扰自然

01:04:15.330 --> 01:04:26.400
存储，这就是他们如何工作的

01:04:21.690 --> 01:04:29.730
所以回到三个

01:04:26.400 --> 01:04:33.780
演示好了，我们看到了管理

01:04:29.730 --> 01:04:36.960
计划另一件事，我想

01:04:33.780 --> 01:04:38.580
提到的是全文搜索

01:04:36.960 --> 01:04:42.660
您需要类似复制字段的内容

01:04:38.580 --> 01:04:44.730
控制器，您基本上可以定义一个

01:04:42.660 --> 01:04:46.410
您想要您的值的一组字段

01:04:44.730 --> 01:04:49.110
复制到另一个字段

01:04:46.410 --> 01:04:51.060
所以通常你定义一个下划线

01:04:49.110 --> 01:04:53.400
松鼠，你有什么感觉， 

01:04:51.060 --> 01:04:55.350
然后定义规则复制字段

01:04:53.400 --> 01:04:57.540
为所有的字段加星标

01:04:55.350 --> 01:05:00.420
文档将它们复制到

01:04:57.540 --> 01:05:02.520
目标文本字段，然后您就可以

01:05:00.420 --> 01:05:04.620
继续查询下划线文字

01:05:02.520 --> 01:05:05.819
你有什么，这就是方式

01:05:04.620 --> 01:05:12.719
文字搜索作品

01:05:05.819 --> 01:05:14.339
在那里，但是什么肯定

01:05:12.719 --> 01:05:17.549
让我们看一个简单的太阳能

01:05:14.339 --> 01:05:20.150
查询您之前在API中看到的内容

01:05:17.549 --> 01:05:23.699
 Java，看起来有点不同，所以

01:05:20.150 --> 01:05:25.769
这只是一个随机的方法

01:05:23.699 --> 01:05:28.140
名称或说明的名称和

01:05:25.769 --> 01:05:30.299
说明说明，我们

01:05:28.140 --> 01:05:32.489
想在太阳能中查找它，我想

01:05:30.299 --> 01:05:34.410
需要没有Spring 数据

01:05:32.489 --> 01:05:39.390
抽象基本上继续

01:05:34.410 --> 01:05:41.969
查询字符串知道名称转义或

01:05:39.390 --> 01:05:44.459
输入，因为可能有通配符

01:05:41.969 --> 01:05:47.640
我在那里不想用a让

01:05:44.459 --> 01:05:49.999
使用或注册正则表达式或其他

01:05:47.640 --> 01:05:55.410
你有我要炮制吗？ 

01:05:49.999 --> 01:05:58.229
再次使用拒绝的S工具逃脱

01:05:55.410 --> 01:06:02.789
然后我需要定义一个独奏

01:05:58.229 --> 01:06:04.709
事业告诉它开始和上升

01:06:02.789 --> 01:06:07.289
这基本上是分页

01:06:04.709 --> 01:06:09.619
信息获取总数

01:06:07.289 --> 01:06:14.369
值，所以实际上有多少文件

01:06:09.619 --> 01:06:16.949
匹配该结果，然后执行

01:06:14.369 --> 01:06:19.259
法令再次获取所有这些结果

01:06:16.949 --> 01:06:21.630
真正获得清单，否则法律

01:06:19.259 --> 01:06:23.940
将开始并将我的搜索限制为十个

01:06:21.630 --> 01:06:26.729
结果或定义的默认值

01:06:23.940 --> 01:06:29.249
在索引中，所以这是一个相当

01:06:26.729 --> 01:06:32.160
很多代码我甚至添加了一个异常

01:06:29.249 --> 01:06:35.069
翻译者和您所有的东西

01:06:32.160 --> 01:06:37.289
将不得不写不使用此打印

01:06:35.069 --> 01:06:41.999
数据，那么案子带来了什么

01:06:37.289 --> 01:06:46.170
太阳能办公室再次使用查询API，因此

01:06:41.999 --> 01:06:51.059
您不必知道语法

01:06:46.170 --> 01:06:53.400
名称，the或子句以及所有

01:06:51.059 --> 01:06:54.660
那个东西或抑扬音

01:06:53.400 --> 01:06:56.759
提升或拥有你或

01:06:54.660 --> 01:07:00.660
突出所以有一个高

01:06:56.759 --> 01:07:04.559
级别的API流畅的API，所以我们

01:07:00.660 --> 01:07:06.719
非常习惯，我们也为您提供

01:07:04.559 --> 01:07:09.779
派生的查询机制，所以这

01:07:06.719 --> 01:07:11.969
基本上归结为

01:07:09.779 --> 01:07:12.839
就像您内部的那种方法

01:07:11.969 --> 01:07:15.509
资料库

01:07:12.839 --> 01:07:17.489
界面，这就是您所需要的， 

01:07:15.509 --> 01:07:18.630
你很好去执行搜索

01:07:17.489 --> 01:07:22.739
只要你

01:07:18.630 --> 01:07:28.529
只要您的索引与您的匹配

01:07:22.739 --> 01:07:30.869
想要做的事情总是存在的

01:07:28.529 --> 01:07:35.130
我们在做时间，我必须快点

01:07:30.869 --> 01:07:43.739
一点，所以我会跳过那个

01:07:35.130 --> 01:07:46.799
我们看到了提振

01:07:43.739 --> 01:07:49.529
基本上定义了提升

01:07:46.799 --> 01:07:53.160
抑扬灵哦，在春天那伊索拉

01:07:49.529 --> 01:07:54.869
创建起来非常容易

01:07:53.160 --> 01:07:57.900
只需添加即可节省时间

01:07:54.869 --> 01:08:00.749
在任何方法参数上增加注释

01:07:57.900 --> 01:08:03.509
您想要拥有，我们将确保

01:08:00.749 --> 01:08:06.660
这个我们的注释这个值得到

01:08:03.509 --> 01:08:10.229
拾取后应用于实际

01:08:06.660 --> 01:08:15.469
查询执行，这是一种不错的选择

01:08:10.229 --> 01:08:20.190
事情，我们也对

01:08:15.469 --> 01:08:24.960
得分是因为再次出现在MongoDB中

01:08:20.190 --> 01:08:28.290
默认分数是不返回

01:08:24.960 --> 01:08:30.089
对于单个文档，这样您就可以

01:08:28.290 --> 01:08:31.619
如果你是在太阳能

01:08:30.089 --> 01:08:33.779
对分数有兴趣

01:08:31.619 --> 01:08:37.679
定义应该是的字段

01:08:33.779 --> 01:08:40.889
作为结果的一部分返回并让

01:08:37.679 --> 01:08:43.619
我只是迅速向你表明你

01:08:40.889 --> 01:08:46.440
基本上会有FL场

01:08:43.619 --> 01:08:48.599
您将必须看到的清单

01:08:46.440 --> 01:08:52.020
这是文档

01:08:48.599 --> 01:08:53.790
而且那里没有分数字段

01:08:52.020 --> 01:08:56.580
那里没有东西，所以你必须

01:08:53.790 --> 01:08:59.299
定义我想拥有所有领域和

01:08:56.580 --> 01:09:02.429
我也想要分数区

01:08:59.299 --> 01:09:05.730
然后执行度数和所有

01:09:02.429 --> 01:09:07.889
突然得分场在那里

01:09:05.730 --> 01:09:10.319
对于那个特定的来说不是很有用

01:09:07.889 --> 01:09:12.210
查询，但如果我结合一些

01:09:10.319 --> 01:09:18.299
得分的其他标准

01:09:12.210 --> 01:09:21.449
变化，但重点是我们所拥有的

01:09:18.299 --> 01:09:23.849
你不仅是那个，也是

01:09:21.449 --> 01:09:26.040
我们在MongoDB中看到的其他注释

01:09:23.849 --> 01:09:28.139
有文字分数和那两个

01:09:26.040 --> 01:09:30.000
你们都是来自不同的人

01:09:28.139 --> 01:09:32.460
在这种情况下，只是

01:09:30.000 --> 01:09:34.890
他们叫分数

01:09:32.460 --> 01:09:36.779
是的，在那个istick里有东西

01:09:34.890 --> 01:09:40.319
搜索世界，我们正在努力

01:09:36.779 --> 01:09:43.109
在将来的某个时候移动那些

01:09:40.319 --> 01:09:45.450
或多或少地统一起来

01:09:43.109 --> 01:09:47.790
所以有一个专门的事情

01:09:45.450 --> 01:09:50.069
注释，表示这是

01:09:47.790 --> 01:09:52.259
与搜索相关，这是一个

01:09:50.069 --> 01:09:54.360
得分字段，因此我们可以使用

01:09:52.259 --> 01:09:58.680
我们拥有的可组合注释模型

01:09:54.360 --> 01:10:03.030
春天也是这样，但这就是

01:09:58.680 --> 01:10:05.219
我们想做的事情与您一样

01:10:03.030 --> 01:10:07.760
在D结果突出显示之前看到

01:10:05.219 --> 01:10:09.900
您必须了解HL配对

01:10:07.760 --> 01:10:12.510
您必须知道的参数

01:10:09.900 --> 01:10:14.040
春天的来临

01:10:12.510 --> 01:10:17.760
数据抽象基本上可以归结为

01:10:14.040 --> 01:10:20.070
这个注释，所以您可以

01:10:17.760 --> 01:10:22.650
添加添加亮点定义一个

01:10:20.070 --> 01:10:25.590
碎片大小和数量

01:10:22.650 --> 01:10:28.830
片段，因此基本上可以告诉您如何

01:10:25.590 --> 01:10:32.520
从头到尾有多少个字符

01:10:28.830 --> 01:10:36.540
在找到搜索词的地方结束

01:10:32.520 --> 01:10:38.219
返回，并包含多少个片段

01:10:36.540 --> 01:10:40.260
最大的你应该返回那里

01:10:38.219 --> 01:10:44.610
还有一堆其他参数

01:10:40.260 --> 01:10:46.950
就像让我

01:10:44.610 --> 01:10:49.230
是的，有亮点，有

01:10:46.950 --> 01:10:50.880
还有很多其他的

01:10:49.230 --> 01:10:54.030
您可以定义字段

01:10:50.880 --> 01:10:55.380
可以找到格式的前缀或后缀，如果

01:10:54.030 --> 01:11:02.190
你不喜欢默认

01:10:55.380 --> 01:11:04.110
是下午，我想是的，你可以

01:11:02.190 --> 01:11:06.780
定义一个明确的查询，所以

01:11:04.110 --> 01:11:08.489
里面有很多选择

01:11:06.780 --> 01:11:11.070
注释，所以差不多

01:11:08.489 --> 01:11:19.760
我已经处理过的所有事情

01:11:11.070 --> 01:11:19.760
你，在那里很简单

01:11:20.389 --> 01:11:27.440
好的，我想展示的最后一件事

01:11:24.050 --> 01:11:29.030
您是关于架构API的，那又如何

01:11:27.440 --> 01:11:31.670
我们在一开始就知道

01:11:29.030 --> 01:11:33.800
那里有一个计划者，那是一个

01:11:31.670 --> 01:11:36.350
很多尝试猜测它看起来像什么

01:11:33.800 --> 01:11:39.080
我们提供给您的基本上是

01:11:36.350 --> 01:11:42.670
在索引注释处，以便您可以

01:11:39.080 --> 01:11:46.580
向研究人员提示如何治疗

01:11:42.670 --> 01:11:48.770
字段和其中的类型是

01:11:46.580 --> 01:11:51.290
方便，希望能证明

01:11:48.770 --> 01:11:53.750
阻止您进入索引

01:11:51.290 --> 01:11:56.239
问题，所以如果你想使用这个

01:11:53.750 --> 01:11:59.900
它在那里为您使用太阳能

01:11:56.239 --> 01:12:04.190
用于模式API或我们最近升级了

01:11:59.900 --> 01:12:05.780
主太阳能5与

01:12:04.190 --> 01:12:07.730
下一个版本

01:12:05.780 --> 01:12:10.790
但是，是的，在那里您可以使用和

01:12:07.730 --> 01:12:14.810
很简单，就像你一样

01:12:10.790 --> 01:12:17.600
期望做它尚未索引的符号

01:12:14.810 --> 01:12:19.880
可以用作来源的替代

01:12:17.600 --> 01:12:22.010
自己的字段注释

01:12:19.880 --> 01:12:25.520
允许您定义索引信息

01:12:22.010 --> 01:12:28.880
在那里告诉您哪些字段- 

01:12:25.520 --> 01:12:33.580
被索引，但不如何与此

01:12:28.880 --> 01:12:36.500
一个你可以做到的

01:12:33.580 --> 01:12:37.880
然后我们继续到

01:12:36.500 --> 01:12:40.159
这个话题将会很重要

01:12:37.880 --> 01:12:41.389
弹性搜索，我们看到了很多弹性

01:12:40.159 --> 01:12:43.429
在开始搜索，所以

01:12:41.389 --> 01:12:45.860
基本上，这个搜寻伺服器

01:12:43.429 --> 01:12:48.619
 JSON文档具有此架构

01:12:45.860 --> 01:12:51.280
检测，甚至可以让您拥有

01:12:48.619 --> 01:12:55.040
您内部的嵌套文档

01:12:51.280 --> 01:12:57.739
结构，但可以大大

01:12:55.040 --> 01:12:58.429
如果使用它会降低性能

01:12:57.739 --> 01:13:01.250
小心一点

01:12:58.429 --> 01:13:04.340
特别是在进行查询和

01:13:01.250 --> 01:13:07.219
我想给你展示一种弹性

01:13:04.340 --> 01:13:11.719
搜索基本上是索引的东西

01:13:07.219 --> 01:13:14.600
所以你有添加文档注释

01:13:11.719 --> 01:13:18.290
基本上可以定义

01:13:14.600 --> 01:13:22.100
您的域名类型应该这样

01:13:18.290 --> 01:13:24.350
可能有索引定义

01:13:22.100 --> 01:13:26.600
添加索引名称，即路由类型

01:13:24.350 --> 01:13:29.119
然后您可以存储不同的类型

01:13:26.600 --> 01:13:32.480
其中不同类型的文件

01:13:29.119 --> 01:13:34.430
收藏，所以这本书是

01:13:32.480 --> 01:13:39.050
基本上存放在酒吧

01:13:34.430 --> 01:13:43.770
集合，显然是类型的书

01:13:39.050 --> 01:13:46.080
所以如果我翻译这个请求

01:13:43.770 --> 01:13:48.270
 elasticsearch基本上是一个穿上

01:13:46.080 --> 01:13:51.300
狗类型的出版指数

01:13:48.270 --> 01:13:53.340
和一些ID你有什么价值

01:13:51.300 --> 01:13:56.280
作为优先JSON文档

01:13:53.340 --> 01:13:59.610
我现在也可以做的是上一堂课

01:13:56.280 --> 01:14:02.130
文章也存储在

01:13:59.610 --> 01:14:05.040
出版物的集合，但它的

01:14:02.130 --> 01:14:08.310
输入文章，以便该模式在那里

01:14:05.040 --> 01:14:11.550
将更改为出版物文章

01:14:08.310 --> 01:14:14.730
你有什么身份证件

01:14:11.550 --> 01:14:19.380
要知道的是

01:14:14.730 --> 01:14:24.570
这两种类型都需要匹配，所以如果您

01:14:19.380 --> 01:14:29.220
让我们在书本类型中说一个名字

01:14:24.570 --> 01:14:33.300
这是一个字符串，您在

01:14:29.220 --> 01:14:36.180
您使用的是名字类型的文章

01:14:33.300 --> 01:14:37.710
输入你有什么，那不是

01:14:36.180 --> 01:14:41.100
允许这样做将为您建立索引

01:14:37.710 --> 01:14:43.080
错误，所以那些必须匹配，如果

01:14:41.100 --> 01:14:45.270
你有一个名字，你必须

01:14:43.080 --> 01:14:48.540
同一类型在另一个中具有相同的

01:14:45.270 --> 01:14:52.680
哦好的

01:14:48.540 --> 01:14:56.820
并让我们也进行弹性搜索

01:14:52.680 --> 01:15:00.030
为您提供与我们一样的太阳能服务

01:14:56.820 --> 01:15:02.700
 API影响结构

01:15:00.030 --> 01:15:04.290
您的架构，因此在弹性搜索中

01:15:02.700 --> 01:15:09.410
通过添加字段注释完成

01:15:04.290 --> 01:15:12.420
让您定义或基本上让您

01:15:09.410 --> 01:15:16.010
定义字段的类型，以便您可以

01:15:12.420 --> 01:15:19.470
基本上有一个字符串是一个日期

01:15:16.010 --> 01:15:22.800
并告诉elasticsearch适用于

01:15:19.470 --> 01:15:26.730
将其视为日期的特定字符串

01:15:22.800 --> 01:15:28.680
使用特定格式，或者您可以使用

01:15:26.730 --> 01:15:30.660
那里的地理位置数据

01:15:28.680 --> 01:15:33.810
翻译成一台很长的笔记本电脑，什么

01:15:30.660 --> 01:15:37.800
你有趣的是多领域

01:15:33.810 --> 01:15:41.660
或注释，因为基本上

01:15:37.800 --> 01:15:44.640
创建您可以分配不同的

01:15:41.660 --> 01:15:47.970
我们今天学习的分析器和索引

01:15:44.640 --> 01:15:49.770
到特定领域

01:15:47.970 --> 01:15:52.290
在这种情况下，那将是作者的

01:15:49.770 --> 01:15:55.050
领域，将有一个专门的

01:15:52.290 --> 01:15:57.210
用于使用

01:15:55.050 --> 01:16:00.060
关键字分析器，所以与众不同

01:15:57.210 --> 01:16:01.530
比实际的，所以它会

01:16:00.060 --> 01:16:05.340
会有一个额外的领域

01:16:01.530 --> 01:16:06.930
作者使用关键字进行点排序

01:16:05.340 --> 01:16:10.320
分析仪，所以这很整洁，因为

01:16:06.930 --> 01:16:13.230
它可以帮助您设置您的域

01:16:10.320 --> 01:16:20.280
可以真正真正搜索到的类型

01:16:13.230 --> 01:16:23.100
您的用例很好，所以有

01:16:20.280 --> 01:16:25.740
我当然会策划一个专门的

01:16:23.100 --> 01:16:29.100
您可以使用的查询API 

01:16:25.740 --> 01:16:31.080
自己的spring数据标准API 

01:16:29.100 --> 01:16:35.040
非常简单的查询，因此您基本上

01:16:31.080 --> 01:16:37.650
定义位置并使用一些

01:16:35.040 --> 01:16:40.290
顾点，然后你就好了

01:16:37.650 --> 01:16:42.860
当然有弹性搜索

01:16:40.290 --> 01:16:45.270
功能远远不止

01:16:42.860 --> 01:16:47.940
通过一些属性进行搜索，这样您

01:16:45.270 --> 01:16:50.010
基本上可以继续使用本机

01:16:47.940 --> 01:16:53.970
搜索查询构建器正在调用

01:16:50.010 --> 01:16:59.000
结束项目，然后申请

01:16:53.970 --> 01:17:04.790
对其进行过滤，以便您可以定义

01:16:59.000 --> 01:17:04.790
具有完全相同的布尔过滤器

01:17:05.060 --> 01:17:11.010
弹性内的术语

01:17:08.850 --> 01:17:12.870
如您所见，在网络用户界面中进行搜索

01:17:11.010 --> 01:17:17.310
构造命令，所以它是一个布尔值

01:17:12.870 --> 01:17:20.130
先过滤，然后过滤D项

01:17:17.310 --> 01:17:22.830
必须与春天和你相匹配

01:17:20.130 --> 01:17:25.080
您可以使用所有的弹性

01:17:22.830 --> 01:17:30.480
搜索功能原生

01:17:25.080 --> 01:17:36.390
搜索下面的查询好吧，让我就

01:17:30.480 --> 01:17:38.250
给你看一些我想要的弹性搜索

01:17:36.390 --> 01:17:43.170
用弹性搜索显示

01:17:38.250 --> 01:17:45.000
基本上给你看一个设置，所以这是

01:17:43.170 --> 01:17:47.550
导航方面的有用指南

01:17:45.000 --> 01:17:50.910
说之前有一个方面

01:17:47.550 --> 01:17:53.340
在那里的抽象

01:17:50.910 --> 01:17:56.910
方面查询，您有一个方面的患者

01:17:53.340 --> 01:17:59.970
基本上可以返回

01:17:56.910 --> 01:18:01.590
弄清楚条款，在这个例子中

01:17:59.970 --> 01:18:04.110
有一个清单

01:18:01.590 --> 01:18:07.710
几年前的法兰西斯会议

01:18:04.110 --> 01:18:09.540
关于像Springs这样的术语

01:18:07.710 --> 01:18:10.349
领elasticsearch人在云上

01:18:09.540 --> 01:18:12.300
还有你

01:18:10.349 --> 01:18:15.780
这就是会议的内容

01:18:12.300 --> 01:18:19.440
我们想知道所有

01:18:15.780 --> 01:18:23.940
该馆藏中的文件

01:18:19.440 --> 01:18:29.070
基本上这个词多久一次

01:18:23.940 --> 01:18:31.260
 Java或您有什么治愈方法以及何时

01:18:29.070 --> 01:18:32.610
执行这是一个常规的 spring boot 

01:18:31.260 --> 01:18:34.830
将所有这些都播放给我们

01:18:32.610 --> 01:18:37.260
实现基本上有春天

01:18:34.830 --> 01:18:39.360
引导自动配置为您准备好

01:18:37.260 --> 01:18:42.360
当我执行创建时，您可以

01:18:39.360 --> 01:18:43.739
基本上看到了我所有的查询

01:18:42.360 --> 01:18:46.139
文件那里有四个

01:18:43.739 --> 01:18:48.150
会议大约两个

01:18:46.139 --> 01:18:50.099
 Scala播放的春季第一曲继续

01:18:48.150 --> 01:18:54.239
 elasticsearch你怎么了，这是

01:18:50.099 --> 01:18:56.010
对于保镖来说非常好

01:18:54.239 --> 01:19:02.159
导航和很方便

01:18:56.010 --> 01:19:04.800
 elasticsearch最近很好，但是没有

01:19:02.159 --> 01:19:09.420
实际上删除了构面，但已弃用

01:19:04.800 --> 01:19:11.159
有利于聚合的方面

01:19:09.420 --> 01:19:14.310
也为此提供了支持

01:19:11.159 --> 01:19:17.760
聚合是我们的下一步

01:19:14.310 --> 01:19:19.710
可以这么说， 

01:19:17.760 --> 01:19:21.960
类固醇，所以您可以做更多的事情

01:19:19.710 --> 01:19:24.920
有关的专用文档

01:19:21.960 --> 01:19:30.300
 elasticsearch网站，但只是为了向您展示

01:19:24.920 --> 01:19:32.699
在另一个相同的查询

01:19:30.300 --> 01:19:35.460
使用聚合的另一种方法是

01:19:32.699 --> 01:19:38.010
基本上我有一个相同的搜索查询

01:19:35.460 --> 01:19:40.830
和以前一样搜索类型，然后我

01:19:38.010 --> 01:19:44.580
编辑以下术语的汇总

01:19:40.830 --> 01:19:47.070
基本上和我们看到的一样

01:19:44.580 --> 01:19:50.639
这里只是格式化了一点

01:19:47.070 --> 01:19:53.010
不同的是，我不使用刻面

01:19:50.639 --> 01:19:55.170
与构面或请求构建器有关，但我

01:19:53.010 --> 01:20:00.449
使用聚合，这基本上

01:19:55.170 --> 01:20:04.949
只是给我相同的输出

01:20:00.449 --> 01:20:07.380
在此之前，有对

01:20:04.949 --> 01:20:14.480
新旧版本的

01:20:07.380 --> 01:20:14.480
刻面还可以

01:20:15.430 --> 01:20:20.840
是的，我们在各个方面都看到了汇总

01:20:19.010 --> 01:20:23.000
带给我或多或少

01:20:20.840 --> 01:20:27.340
嘿，我们还有几分钟的时间

01:20:23.000 --> 01:20:30.350
结束您今天看到的所有代码是

01:20:27.340 --> 01:20:33.500
在github上可用哦，您可以检查一下

01:20:30.350 --> 01:20:35.960
玩一下它，这是我们非常

01:20:33.500 --> 01:20:40.310
自己的spring数据示例或git 

01:20:35.960 --> 01:20:41.900
仓库中有我们所有的例子

01:20:40.310 --> 01:20:44.240
在那里有卡桑德拉

01:20:41.900 --> 01:20:45.800
 elasticsearch GPA，其他所有风暴

01:20:44.240 --> 01:20:47.930
也会使用模块

01:20:45.800 --> 01:20:50.870
我今天给你看的一切都在那里

01:20:47.930 --> 01:20:54.680
在那里你也可以检查出来

01:20:50.870 --> 01:20:57.980
其他人有时候我们已经

01:20:54.680 --> 01:21:01.610
在

01:20:57.980 --> 01:21:03.380
例子，所以你可能想看看

01:21:01.610 --> 01:21:04.910
一些发展分支

01:21:03.380 --> 01:21:09.320
那些也看看我们在做什么

01:21:04.910 --> 01:21:11.600
对于下一个版本，但如果您已经

01:21:09.320 --> 01:21:13.460
有任何问题随时问或

01:21:11.600 --> 01:21:17.180
来到羽毛的鸟儿

01:21:13.460 --> 01:21:18.500
我想是明天还是来了

01:21:17.180 --> 01:21:21.080
后来我在这里休息

01:21:18.500 --> 01:21:24.380
发布会如果没有问题哦

01:21:21.080 --> 01:21:27.860
祝您休息愉快

01:21:24.380 --> 01:21:30.190
会议并展示并告别

01:21:27.860 --> 01:21:30.190
谢谢

