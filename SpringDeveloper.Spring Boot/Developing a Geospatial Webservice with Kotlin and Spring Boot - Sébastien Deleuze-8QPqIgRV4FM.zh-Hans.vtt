WEBVTT
Kind: captions
Language: zh-Hans

00:00:10.050 --> 00:00:15.790
欢迎大家今天我们要

00:00:13.390 --> 00:00:19.420
了解如何开发您的特殊网站

00:00:15.790 --> 00:00:20.920
首先与Kalinin Springwood合作

00:00:19.420 --> 00:00:23.770
让我快速介绍一下自己

00:00:20.920 --> 00:00:26.380
我自己，所以我住在塞巴斯蒂安·德·罗斯

00:00:23.770 --> 00:00:29.560
法国的新事物，就像你可以听到我的

00:00:26.380 --> 00:00:32.470
我在支点时代工作的口音很多

00:00:29.560 --> 00:00:35.500
 Spring 农场工作，并指导我的实际工作

00:00:32.470 --> 00:00:38.890
重点放在

00:00:35.500 --> 00:00:40.960
 Spring Framework 5我是一家公司的同事

00:00:38.890 --> 00:00:43.089
我叫La Cote的共同工作空间

00:00:40.960 --> 00:00:45.489
也是麻省理工学院的工作人员

00:00:43.089 --> 00:00:50.470
会议是一个会议

00:00:45.489 --> 00:00:54.159
在法国开业，所以我们要

00:00:50.470 --> 00:00:57.010
介绍：在深入之前

00:00:54.159 --> 00:01:00.129
该应用程序的细节，我们

00:00:57.010 --> 00:01:02.739
将会看到所以第一个问题

00:01:00.129 --> 00:01:06.490
想问一下为什么选择： 

00:01:02.739 --> 00:01:10.180
还有芹泽其他语言，为什么

00:01:06.490 --> 00:01:13.600
我们应该使用切割吗？我认为主要

00:01:10.180 --> 00:01:17.140
驱动程序是要克服Java的限制

00:01:13.600 --> 00:01:17.619
我的意思是服务很棒，我们都非常了解

00:01:17.140 --> 00:01:20.020
好

00:01:17.619 --> 00:01:22.000
我每天都用它来纺纱

00:01:20.020 --> 00:01:25.289
反应堆和许多项目

00:01:22.000 --> 00:01:28.659
关键但要开发应用程序

00:01:25.289 --> 00:01:31.329
服务一些限制它的冗长

00:01:28.659 --> 00:01:34.689
限制打字的朋友没有属性

00:01:31.329 --> 00:01:37.270
检查异常为空的问题

00:01:34.689 --> 00:01:42.159
指针异常的可扩展性是

00:01:37.270 --> 00:01:44.590
如果我们比较一下Java的话

00:01:42.159 --> 00:01:46.899
例如Ruby之类的语言

00:01:44.590 --> 00:01:50.670
我们有一个完整的完全扩展

00:01:46.899 --> 00:01:53.259
模型那里有问题

00:01:50.670 --> 00:01:55.299
分号和行尾是

00:01:53.259 --> 00:01:59.320
太详细了，但是那很好

00:01:55.299 --> 00:02:03.039
 Java很简单，但是在那里

00:01:59.320 --> 00:02:06.670
还有多个Java Paseos Java具有

00:02:03.039 --> 00:02:10.300
历史悠久，有一些陷阱

00:02:06.670 --> 00:02:12.190
来自悠久的历史，我

00:02:10.300 --> 00:02:14.440
真的认为我们应该得到更好的

00:02:12.190 --> 00:02:16.510
 lombok 的解决方案，我不知道你是否

00:02:14.440 --> 00:02:19.360
纽伦堡，就是这样

00:02:16.510 --> 00:02:21.790
注释和一些Alpers能够

00:02:19.360 --> 00:02:23.110
编写较短的Java代码，那就是

00:02:21.790 --> 00:02:25.270
不错但是

00:02:23.110 --> 00:02:29.290
那仍然是一个把戏，我想我们只是

00:02:25.270 --> 00:02:32.230
有更好的更好的解决方案

00:02:29.290 --> 00:02:35.740
同时我们要保持使

00:02:32.230 --> 00:02:38.590
优质的服务，快速，产生了优化

00:02:35.740 --> 00:02:40.600
床码，它具有静态类型

00:02:38.590 --> 00:02:44.680
让我们有一个很好的自动完成功能

00:02:40.600 --> 00:02:47.200
 IDE可以进行很多检查

00:02:44.680 --> 00:02:49.690
在编译过程中

00:02:47.200 --> 00:02:51.790
大型项目非常重要

00:02:49.690 --> 00:02:54.880
很简单的学习，它有一个

00:02:51.790 --> 00:02:57.070
令人惊叹的生态系统，在 Spring ， 

00:02:54.880 --> 00:03:02.140
在第二个系统中，所以我们要保持

00:02:57.070 --> 00:03:07.420
所以我试图在那里总结

00:03:02.140 --> 00:03:09.310
我认为有一个重点： 

00:03:07.420 --> 00:03:11.890
在我看来，凯瑟琳是一位优雅而

00:03:09.310 --> 00:03:15.880
允许写的实用语言

00:03:11.890 --> 00:03:18.940
简洁的代码，以便更快地编写

00:03:15.880 --> 00:03:22.090
应用程序着重于

00:03:18.940 --> 00:03:25.050
使内容易于阅读，我们将看到

00:03:22.090 --> 00:03:27.190
后面的代码示例

00:03:25.050 --> 00:03:29.410
轻松阅读代码非常

00:03:27.190 --> 00:03:31.989
重要，因为您编写代码

00:03:29.410 --> 00:03:35.530
一次，但之后你和其他人

00:03:31.989 --> 00:03:38.380
人们将不得不调试该代码， 

00:03:35.530 --> 00:03:45.070
能够做到这一点非常重要

00:03:38.380 --> 00:03:46.900
阅读代码很容易干净

00:03:45.070 --> 00:03:50.590
很棒的静态类型推断

00:03:46.900 --> 00:03:52.989
打字真的很干净

00:03:50.590 --> 00:03:54.940
静态类型比Java一切都重要

00:03:52.989 --> 00:03:57.430
静态输入您没有一些

00:03:54.940 --> 00:04:02.440
像在Ruby中那样神奇的东西

00:03:57.430 --> 00:04:05.650
 JavaScript，但是由于它的巧妙

00:04:02.440 --> 00:04:10.380
基本上在法国输入您就可以

00:04:05.650 --> 00:04:14.620
写非常短的代码，我的意思是代码键

00:04:10.380 --> 00:04:17.080
可能和groovy一样短，但是

00:04:14.620 --> 00:04:20.229
完全是静态类型的API，那就是

00:04:17.080 --> 00:04:22.060
这是非常有效的容器

00:04:20.229 --> 00:04:25.660
两种方式都具有良好的Java互操作性

00:04:22.060 --> 00:04:27.760
这就是关键点

00:04:25.660 --> 00:04:31.690
当您想将可卡因与

00:04:27.760 --> 00:04:33.850
 Spring 生态系统没有安全感

00:04:31.690 --> 00:04:34.849
扩展DSL所有这些东西

00:04:33.850 --> 00:04:37.159
即将

00:04:34.849 --> 00:04:39.619
稍后查看更多详细信息

00:04:37.159 --> 00:04:44.179
不再没有强制性分号

00:04:39.619 --> 00:04:48.349
行尾好我开始

00:04:44.179 --> 00:04:51.469
几年前，但才来到GA 

00:04:48.349 --> 00:04:53.539
这么干净的一年

00:04:51.469 --> 00:04:58.509
在今年年初发布

00:04:53.539 --> 00:05:01.429
所以这也许就是为什么它不那么广泛的原因

00:04:58.509 --> 00:05:04.669
比其他语言传播得更多，但是

00:05:01.429 --> 00:05:07.159
我的泰米尔语没有确切数字

00:05:04.669 --> 00:05:09.379
例如github仓库，但是当

00:05:07.159 --> 00:05:11.179
我当时正在和那些脑筋急转弯的家伙聊天

00:05:09.379 --> 00:05:16.189
认为这些数字是真的

00:05:11.179 --> 00:05:19.249
太好了，我想是的

00:05:16.189 --> 00:05:24.519
好趋势，所以当前最新稳定

00:05:19.249 --> 00:05:24.519
版本是免费订购的版本， 

00:05:24.580 --> 00:05:30.889
第一个干净的1.1预览版是

00:05:28.039 --> 00:05:34.909
可用，并将继续

00:05:30.889 --> 00:05:38.990
稍后发布对

00:05:34.909 --> 00:05:41.300
了解必须切

00:05:38.990 --> 00:05:43.879
干净的应用程序开发者来自

00:05:41.300 --> 00:05:48.499
 Android世界，因为您好

00:05:43.879 --> 00:05:50.119
生成非常漂亮的Java 6字节代码

00:05:48.499 --> 00:05:50.479
我们将要详细介绍的语言

00:05:50.119 --> 00:05:54.259
后来

00:05:50.479 --> 00:05:56.029
基本上，这使开发人员能够

00:05:54.259 --> 00:05:59.149
欢迎阅读的限制

00:05:56.029 --> 00:06:01.789
坚持Java 6的平台

00:05:59.149 --> 00:06:04.369
语法直到窗口间隙

00:06:01.789 --> 00:06:06.949
即将被释放，甚至与

00:06:04.369 --> 00:06:10.519
 Android牛轧糖记者艾滋病一些Java 

00:06:06.949 --> 00:06:14.149
 8 ApS不可用，您可以

00:06:10.519 --> 00:06:17.569
生成一些旧版本的字节码

00:06:14.149 --> 00:06:19.939
 Android，所以我真的认为该代码

00:06:17.569 --> 00:06:21.499
清洁将继续在

00:06:19.939 --> 00:06:24.369
在Android世界中

00:06:21.499 --> 00:06:28.939
 Android社区做饭非常非常

00:06:24.369 --> 00:06:30.349
广泛使用的第二个用例是

00:06:28.939 --> 00:06:30.979
我们将详细介绍的用例

00:06:30.349 --> 00:06:33.319
今天

00:06:30.979 --> 00:06:34.969
这是使用内容的服务器用例

00:06:33.319 --> 00:06:37.429
开发服务器应用程序而不是

00:06:34.969 --> 00:06:39.110
闭嘴，你也可以开发桌面

00:06:37.429 --> 00:06:40.789
应用程序和其他类似Web的应用程序

00:06:39.110 --> 00:06:47.120
我们将要看到的应用程序

00:06:40.789 --> 00:06:48.380
稍后，此图显示了

00:06:47.120 --> 00:06:50.390
方法

00:06:48.380 --> 00:06:51.560
我不知道是否有八号申请

00:06:50.390 --> 00:06:54.650
你熟悉一些重建

00:06:51.560 --> 00:06:57.500
但基本上在移动设备上

00:06:54.650 --> 00:07:00.470
资源有限，有一些

00:06:57.500 --> 00:07:03.770
关于阅读的限制

00:07:00.470 --> 00:07:06.580
方法和非常动态的语言

00:07:03.770 --> 00:07:09.140
像Ruby这样生成的字节码

00:07:06.580 --> 00:07:13.220
包含很多案例，很多神话

00:07:09.140 --> 00:07:15.770
您可以在该图中看到

00:07:13.220 --> 00:07:17.990
常规的方法数量很多

00:07:15.770 --> 00:07:22.250
那颜色好一点之后

00:07:17.990 --> 00:07:25.820
和代码干净几乎是相同的

00:07:22.250 --> 00:07:29.120
级别比danjela这个数字高

00:07:25.820 --> 00:07:31.790
方法是在使用ProGuard之后

00:07:29.120 --> 00:07:35.290
删除新闻代码，基本上是什么

00:07:31.790 --> 00:07:38.270
你你应该投产所以

00:07:35.290 --> 00:07:40.400
这就是凯瑟琳成功的原因

00:07:38.270 --> 00:07:44.240
在红色的世界里

00:07:40.400 --> 00:07:47.770
生成优化的优化错误代码

00:07:44.240 --> 00:07:52.930
作为注射剂，几乎还有更多

00:07:47.770 --> 00:07:58.010
强大的语言继续

00:07:52.930 --> 00:08:00.310
压缩我试图把一些

00:07:58.010 --> 00:08:02.960
与它相比如何的句子

00:08:00.310 --> 00:08:04.850
重视语言，所以它如何比较

00:08:02.960 --> 00:08:08.360
时髦

00:08:04.850 --> 00:08:11.720
我认为凯瑟琳做了很多事情

00:08:08.360 --> 00:08:14.060
从groovy他们共享了很多ID 

00:08:11.720 --> 00:08:16.730
相同的一致表达代码，但

00:08:14.060 --> 00:08:20.450
主要的区别甚至是

00:08:16.730 --> 00:08:24.260
他们开发的静态编译模式

00:08:20.450 --> 00:08:28.130
通过选择教皇，但凯瑟琳有

00:08:24.260 --> 00:08:30.770
释放了静态打字的核心

00:08:28.130 --> 00:08:33.260
语言，这使得很多

00:08:30.770 --> 00:08:36.289
自动完成方面的差异

00:08:33.260 --> 00:08:38.570
在很多事情上不是

00:08:36.289 --> 00:08:41.930
您以后添加的可选内容或

00:08:38.570 --> 00:08:44.960
内容API设计用于

00:08:41.930 --> 00:08:47.840
静态类型在Ruby世界中的位置

00:08:44.960 --> 00:08:49.790
有很多像耶稣这样充满活力的东西

00:08:47.840 --> 00:08:53.630
这样的报告只能在

00:08:49.790 --> 00:08:55.190
动态模式，实际上在Ruby中

00:08:53.630 --> 00:08:55.850
和静态模式真的是两个不同

00:08:55.190 --> 00:09:00.290
东西

00:08:55.850 --> 00:09:02.480
我们正在包含转移到以允许

00:09:00.290 --> 00:09:04.399
简洁的静态代码

00:09:02.480 --> 00:09:09.440
无处不在，这就是关键

00:09:04.399 --> 00:09:11.870
我想起我所学的卡拉

00:09:09.440 --> 00:09:14.420
来自一个不错的博客文章的一些报价

00:09:11.870 --> 00:09:18.230
从疤痕的开发商和人

00:09:14.420 --> 00:09:20.300
真的很喜欢凯勒

00:09:18.230 --> 00:09:22.070
我认为在电子艺术领域工作

00:09:20.300 --> 00:09:25.730
该博客文章称为“阴和

00:09:22.070 --> 00:09:29.060
杨编程语言这家伙

00:09:25.730 --> 00:09:32.240
有人说含有80％ 

00:09:29.060 --> 00:09:37.100
 Skara的力量占20％ 

00:09:32.240 --> 00:09:38.959
功能，您还说包括

00:09:37.100 --> 00:09:41.000
两种工程语言相对

00:09:38.959 --> 00:09:42.920
 Skara是一门计算科学

00:09:41.000 --> 00:09:47.029
语言，我认为这是一个很好的

00:09:42.920 --> 00:09:50.050
好的差异包含比较简单

00:09:47.029 --> 00:09:53.630
少一点力量，更务实

00:09:50.050 --> 00:09:56.209
也许使用JVM更仔细地设计

00:09:53.630 --> 00:09:58.070
考虑到限制因素

00:09:56.209 --> 00:10:00.889
语言很有趣，但是作为一种

00:09:58.070 --> 00:10:03.980
作为某人的软件工程师

00:10:00.889 --> 00:10:09.380
对我很好的发展

00:10:03.980 --> 00:10:13.250
棉花更合身，如果

00:10:09.380 --> 00:10:16.639
我们将14种语言与快速语言进行比较

00:10:13.250 --> 00:10:19.279
苹果公司开发的语言

00:10:16.639 --> 00:10:21.230
 iOS应用程序即将推出

00:10:19.279 --> 00:10:25.339
用于开发服务器端应用程序

00:10:21.230 --> 00:10:28.069
与IBM和类似的公司一起

00:10:25.339 --> 00:10:31.339
就Swift和

00:10:28.069 --> 00:10:33.620
可卡因非常非常相似

00:10:31.339 --> 00:10:37.430
会看到有很多语法

00:10:33.620 --> 00:10:39.380
在指挥中，所以其中一个主电源在那里

00:10:37.430 --> 00:10:43.279
有很多差异，但其中之一

00:10:39.380 --> 00:10:45.500
主要是Swift是基于11的，因此LLVM 

00:10:43.279 --> 00:10:49.040
是我们Lola即将来临的字节码

00:10:45.500 --> 00:10:51.500
来自cc绝境世界，即数据

00:10:49.040 --> 00:10:55.459
加载以生成一些本机代码

00:10:51.500 --> 00:10:57.800
 BIOS平台，这有点不足

00:10:55.459 --> 00:10:59.899
代码，但编译时间更多

00:10:57.800 --> 00:11:04.040
对于执行时间，而不是

00:10:59.899 --> 00:11:05.930
运行时间，因此切换为C和C ++ 

00:11:04.040 --> 00:11:09.740
互操作性

00:11:05.930 --> 00:11:12.170
代码清理更基于gvm，并且非常

00:11:09.740 --> 00:11:14.540
良好的Java互操作性，但实际上

00:11:12.170 --> 00:11:15.360
这两种语言非常接近

00:11:14.540 --> 00:11:18.839
而且我认为

00:11:15.360 --> 00:11:24.300
这两种语言都很棒

00:11:18.839 --> 00:11:28.470
很好，这是这里的一些代码

00:11:24.300 --> 00:11:30.480
一个定义四个的用户类

00:11:28.470 --> 00:11:34.769
属性用户名名姓

00:11:30.480 --> 00:11:37.320
名称和位置，以便您看到

00:11:34.769 --> 00:11:41.430
通过这种简短的语法，您可以找到

00:11:37.320 --> 00:11:43.560
在同一时间在斯卡拉关闭的东西

00:11:41.430 --> 00:11:46.589
定义为四个的时间加法

00:11:43.560 --> 00:11:50.579
属性，我还定义了

00:11:46.589 --> 00:11:52.560
这个类的构造函数有

00:11:50.579 --> 00:11:55.079
 VAR关键字，位于用户名的名字之前

00:11:52.560 --> 00:11:57.930
姓氏和位置非常重要

00:11:55.079 --> 00:12:00.779
通过属性表我可以

00:11:57.930 --> 00:12:06.390
用瓦尔说财产会

00:12:00.779 --> 00:12:09.680
不是，我们在Java中不是很像

00:12:06.390 --> 00:12:12.450
类型是在属性名称之后

00:12:09.680 --> 00:12:14.310
所以这会产生吸气剂和

00:12:12.450 --> 00:12:16.050
二传手，您不必定义

00:12:14.310 --> 00:12:18.060
领域，并获得所有的二传手

00:12:16.050 --> 00:12:22.410
完成所有操作后，您还可以自定义

00:12:18.060 --> 00:12:24.300
酮症和二传手，如果你

00:12:22.410 --> 00:12:25.920
看一下最后一个属性

00:12:24.300 --> 00:12:31.199
位置，您会看到一个问号

00:12:25.920 --> 00:12:33.839
在这之后是一个是的类型

00:12:31.199 --> 00:12:36.029
那只是几何类型而已

00:12:33.839 --> 00:12:38.640
在结尾处有一个问号

00:12:36.029 --> 00:12:45.000
在类型上意味着

00:12:38.640 --> 00:12:48.360
类型是新标签，因为在加泰罗尼亚语中

00:12:45.000 --> 00:12:51.089
您的默认变量或属性

00:12:48.360 --> 00:12:53.459
定义不可用，该检查

00:12:51.089 --> 00:12:55.079
在编译过程中，到处都是

00:12:53.459 --> 00:12:56.550
在这里你可以只是一个新的指针

00:12:55.079 --> 00:12:59.690
例外，你将不得不根据

00:12:56.550 --> 00:13:04.170
默认情况下，您无法设置

00:12:59.690 --> 00:13:06.300
我要添加一个问题才能知道的事情

00:13:04.170 --> 00:13:09.920
在类型之后标记，表示此

00:13:06.300 --> 00:13:13.350
类型是基本上是新标签和

00:13:09.920 --> 00:13:17.250
您会发现在

00:13:13.350 --> 00:13:19.860
这行的末尾意味着我

00:13:17.250 --> 00:13:22.680
我给最后一个默认值

00:13:19.860 --> 00:13:27.449
参数，以便在实践中让我

00:13:22.680 --> 00:13:27.910
仅使用用户名创建用户

00:13:27.449 --> 00:13:32.550
名字

00:13:27.910 --> 00:13:35.650
姓氏或使用第四个参数

00:13:32.550 --> 00:13:37.870
这是位置，我可以做到

00:13:35.650 --> 00:13:39.790
无需重新定义重载

00:13:37.870 --> 00:13:42.970
允许我们产生的构造函数

00:13:39.790 --> 00:13:44.890
更简洁的代码可以使

00:13:42.970 --> 00:13:47.800
更具可读性的代码

00:13:44.890 --> 00:13:52.000
在右边很重要，我想你不会

00:13:47.800 --> 00:13:54.910
能够阅读但只是向您展示

00:13:52.000 --> 00:13:58.000
 Java中的相同代码会更长

00:13:54.910 --> 00:14:00.850
我们都有想法让我们能够

00:13:58.000 --> 00:14:02.620
甚至可以轻松生成Gator setter 

00:14:00.850 --> 00:14:04.960
等于和hashcode方法，但我

00:14:02.620 --> 00:14:07.360
关键不是这里，我的意思是

00:14:04.960 --> 00:14:09.760
是时候阅读您的代码了

00:14:07.360 --> 00:14:13.900
真的更喜欢看卡通版

00:14:09.760 --> 00:14:15.550
比Java版本更清晰

00:14:13.900 --> 00:14:23.230
书可能在任何地方，并且有

00:14:15.550 --> 00:14:25.960
很多代码和很多噪音，所以我

00:14:23.230 --> 00:14:28.510
可以在课程之前添加数据关键字

00:14:25.960 --> 00:14:30.910
为了说我也想

00:14:28.510 --> 00:14:32.430
自动生成等于和

00:14:30.910 --> 00:14:36.370
哈希码方法

00:14:32.430 --> 00:14:41.070
所以那句语法糖

00:14:36.370 --> 00:14:43.420
让我们编写更简洁的代码

00:14:41.070 --> 00:14:46.060
编码为可选参数和命名参数

00:14:43.420 --> 00:14:49.780
所以如果我们看看这个格式

00:14:46.060 --> 00:14:53.440
函数你看到我有一个字符串

00:14:49.780 --> 00:14:56.170
强制参数，然后我

00:14:53.440 --> 00:14:59.050
有四个可选参数

00:14:56.170 --> 00:15:00.970
可选，因为我定义了默认值

00:14:59.050 --> 00:15:02.590
价值，因此，如果您不提供这些

00:15:00.970 --> 00:15:05.410
参数默认值为

00:15:02.590 --> 00:15:07.960
在Java中使用超载已完成

00:15:05.410 --> 00:15:09.430
方法，我将不得不投入很多

00:15:07.960 --> 00:15:12.370
一种有效的方法

00:15:09.430 --> 00:15:18.070
在这里，我只需一个

00:15:12.370 --> 00:15:22.240
单一功能定义，所以我可以

00:15:18.070 --> 00:15:23.950
只需重新格式化foobar并标准化

00:15:22.240 --> 00:15:26.080
 case参数将设置为true 

00:15:23.950 --> 00:15:30.310
大写首字母参数将

00:15:26.080 --> 00:15:35.140
设置为true等相同的方法我

00:15:30.310 --> 00:15:37.420
可以调用重新格式化foobar并指定

00:15:35.140 --> 00:15:39.960
值参数，以便由

00:15:37.420 --> 00:15:39.960
反对派

00:15:40.230 --> 00:15:44.550
因此，在这种情况下，您会看到重新定义

00:15:42.480 --> 00:15:49.590
定义什么分隔符的值

00:15:44.550 --> 00:15:51.980
我被迫定义另一个

00:15:49.590 --> 00:15:54.780
参数即使它们没有变化

00:15:51.980 --> 00:15:58.050
即使他们保留默认值

00:15:54.780 --> 00:16:00.840
那不是我所要做的

00:15:58.050 --> 00:16:04.410
高效，因此容器使您能够

00:16:00.840 --> 00:16:07.530
在您通过参数名称指定参数时

00:16:04.410 --> 00:16:11.070
有一些像这样的参数

00:16:07.530 --> 00:16:14.220
允许您指定杆

00:16:11.070 --> 00:16:17.760
估计的分隔符参数

00:16:14.220 --> 00:16:20.490
没有定义其他的价值

00:16:17.760 --> 00:16:22.380
另一个是这样设计的

00:16:20.490 --> 00:16:26.280
允许您编写简洁的代码并

00:16:22.380 --> 00:16:33.210
可读的代码，您还可以自定义

00:16:26.280 --> 00:16:36.240
其他不一样的新东西

00:16:33.210 --> 00:16:38.460
安全在棉花中非常重要

00:16:36.240 --> 00:16:42.780
事实上，在我从事棉花工作之前

00:16:38.460 --> 00:16:45.600
不确定这样做是否有用

00:16:42.780 --> 00:16:51.600
功能我的意思是我们都有问题

00:16:45.600 --> 00:16:54.120
新的指针异常，但是是的

00:16:51.600 --> 00:16:56.670
在开发容器时使用棉花

00:16:54.120 --> 00:16:58.890
应用程序，我真的觉得那是

00:16:56.670 --> 00:17:02.940
最重要的特征之一

00:16:58.890 --> 00:17:04.920
语言，就像我之前说的，如果你

00:17:02.940 --> 00:17:08.040
不要在类型后面加上问号

00:17:04.920 --> 00:17:10.470
这意味着类型不是变量，所以

00:17:08.040 --> 00:17:13.440
您将无法赋予新的价值

00:17:10.470 --> 00:17:16.850
在那里，如果您有问号， 

00:17:13.440 --> 00:17:19.520
你可以把这个价值

00:17:16.850 --> 00:17:22.829
此变量的此属性为nil 

00:17:19.520 --> 00:17:23.640
 IDE给您一些提示，告诉您

00:17:22.829 --> 00:17:26.490
好的

00:17:23.640 --> 00:17:31.650
这里有一个新价值的风险

00:17:26.490 --> 00:17:33.840
所以有各种各样的经营者去

00:17:31.650 --> 00:17:35.490
提供默认值（如果是） 

00:17:33.840 --> 00:17:38.220
面条或类似的东西，所以你必须

00:17:35.490 --> 00:17:42.000
在你的自我之下，事实是什么

00:17:38.220 --> 00:17:45.240
如果这个值是新值，我会做，所以如果我们看到

00:17:42.000 --> 00:17:50.070
那个我创造水的例子

00:17:45.240 --> 00:17:53.940
在第二行

00:17:50.070 --> 00:17:57.630
用点分配和

00:17:53.940 --> 00:18:01.289
问号，所以我可以这样做

00:17:57.630 --> 00:18:04.530
因为出生出生类型是我们新的

00:18:01.289 --> 00:18:07.470
自由点基本上在第二

00:18:04.530 --> 00:18:09.770
例如，位置2我们具有类型

00:18:07.470 --> 00:18:12.090
自动给出的推论

00:18:09.770 --> 00:18:14.039
一个新的自由派类型的位置

00:18:12.090 --> 00:18:17.010
点，因为告诉位置

00:18:14.039 --> 00:18:19.860
一个新标签指向位置2是

00:18:17.010 --> 00:18:22.440
真的是静态输入

00:18:19.860 --> 00:18:24.390
与其他位置的字词类型相同

00:18:22.440 --> 00:18:29.640
这是切割类型的一个例子

00:18:24.390 --> 00:18:33.570
推断和位置自由

00:18:29.640 --> 00:18:39.299
此处的示例免费位置不是新事物

00:18:33.570 --> 00:18:43.530
标签点，所以与猫王操作员

00:18:39.299 --> 00:18:46.289
我们是否提供了默认值，所以

00:18:43.530 --> 00:18:48.659
这意味着免费位置将是

00:18:46.289 --> 00:18:50.909
等于其他位置，但如果

00:18:48.659 --> 00:18:54.409
应用程序的工作量是已知的值

00:18:50.909 --> 00:18:57.360
将为零零零零的点

00:18:54.409 --> 00:19:01.049
所以你不必做什么魔法

00:18:57.360 --> 00:19:04.320
如果值是新的，也有一些

00:19:01.049 --> 00:19:08.130
帮助避免新的帮手

00:19:04.320 --> 00:19:12.750
指针异常，所以这里是新的

00:19:08.130 --> 00:19:13.770
标签，如果在此代码中，位置为

00:19:12.750 --> 00:19:17.700
零

00:19:13.770 --> 00:19:23.340
如果没有，将不会有任何异常巨魔

00:19:17.700 --> 00:19:25.740
 location是一个值X将是x 

00:19:23.340 --> 00:19:28.289
所在位置的价值，以及

00:19:25.740 --> 00:19:31.260
职业为空，它将为否

00:19:28.289 --> 00:19:37.950
您在groovy中具有类似的功能

00:19:31.260 --> 00:19:40.950
像那样，我看到了一个有趣的

00:19:37.950 --> 00:19:43.350
例如来自的有趣的博客文章

00:19:40.950 --> 00:19:46.230
来自基层的Dan Kim在说话

00:19:43.350 --> 00:19:49.679
关于我们如何爱我们的语言

00:19:46.230 --> 00:19:53.490
使用，所以大本营是很多红宝石

00:19:49.679 --> 00:19:56.370
公司，它是一个Java开发人员， 

00:19:53.490 --> 00:19:57.940
他一直想知道为什么这红宝石为什么

00:19:56.370 --> 00:19:59.289
大家真的很喜欢这种语言

00:19:57.940 --> 00:20:02.529
他们真的很热衷于

00:19:59.289 --> 00:20:04.690
语言，感觉不一样

00:20:02.529 --> 00:20:07.889
与Java这是一种语言

00:20:04.690 --> 00:20:10.240
他在日常工作中使用的

00:20:07.889 --> 00:20:12.789
不能说她爱

00:20:10.240 --> 00:20:13.240
 Java和使用代码时

00:20:12.789 --> 00:20:15.850
清洁

00:20:13.240 --> 00:20:17.830
他写了这篇博客文章，并为

00:20:15.850 --> 00:20:20.139
很多年以来，我的观点是

00:20:17.830 --> 00:20:21.700
简单，我不必爱Java或

00:20:20.139 --> 00:20:23.950
用什么编程语言来做我的

00:20:21.700 --> 00:20:26.019
运行良好，几个月都变了

00:20:23.950 --> 00:20:29.919
以前，当您使用代码清洁时，因为

00:20:26.019 --> 00:20:32.649
基本上，语言帮助了他，他

00:20:29.919 --> 00:20:35.500
终于真正了解了Ruby 

00:20:32.649 --> 00:20:38.559
伙计们真的是那种社区

00:20:35.500 --> 00:20:42.309
感觉很难用

00:20:38.559 --> 00:20:44.200
幻灯片，但你我想你不会

00:20:42.309 --> 00:20:48.580
当开发一些卡通片时

00:20:44.200 --> 00:20:51.100
应用程序，现在我们已经看到了

00:20:48.580 --> 00:20:54.009
快速清洁代码概述让我们谈谈

00:20:51.100 --> 00:20:58.210
关于使用干净的代码进行开发

00:20:54.009 --> 00:21:01.360
 Spring 申请，所以几个月前

00:20:58.210 --> 00:21:04.750
刚开始就添加了对烹饪的支持

00:21:01.360 --> 00:21:06.789
玩tayo，所以我猜有些人

00:21:04.750 --> 00:21:10.570
已经知道那是一个网站

00:21:06.789 --> 00:21:13.629
生成项目框架以开始

00:21:10.570 --> 00:21:16.720
引导您的项目，所以如果您去

00:21:13.629 --> 00:21:19.690
幻灯片顶部的URL 

00:21:16.720 --> 00:21:21.190
您将拥有带有代码的晶状体

00:21:19.690 --> 00:21:22.950
已经选择清洁剂，您将

00:21:21.190 --> 00:21:26.409
只需添加您的依赖项

00:21:22.950 --> 00:21:28.360
选择Maven分级机指定酒水

00:21:26.409 --> 00:21:30.879
版本，它将自动

00:21:28.360 --> 00:21:33.909
产生 spring boot 并切成拐杖

00:21:30.879 --> 00:21:36.519
项目，如果你去常规

00:21:33.909 --> 00:21:38.860
 Spring 开始那 Spring 的数据你你

00:21:36.519 --> 00:21:41.350
将不得不切换到完整

00:21:38.860 --> 00:21:46.059
表格的版本，然后选择清理

00:21:41.350 --> 00:21:48.190
作为最后而不是我把Java 

00:21:46.059 --> 00:21:53.039
一些条形码，如果你想做一个

00:21:48.190 --> 00:21:55.509
与您的手机三路同行

00:21:53.039 --> 00:21:57.669
考虑使用 spring boot 和切割

00:21:55.509 --> 00:21:59.559
在一起很有意义，因为他们分享

00:21:57.669 --> 00:22:03.129
他们有着相同的务实和

00:21:59.559 --> 00:22:05.860
创新的心态我是说他们俩

00:22:03.129 --> 00:22:08.350
既创新，例如Spring 

00:22:05.860 --> 00:22:09.900
靴子带来了很多新东西

00:22:08.350 --> 00:22:14.340
准备好创新

00:22:09.900 --> 00:22:16.650
但我们也使用生态系统

00:22:14.340 --> 00:22:19.170
 Java生态系统非常好，不要尝试

00:22:16.650 --> 00:22:21.720
重新发明轮子，这就是为什么我

00:22:19.170 --> 00:22:24.030
认为创新务实

00:22:21.720 --> 00:22:26.870
和凯琳几乎是一样的

00:22:24.030 --> 00:22:29.610
关于允许您写的东西

00:22:26.870 --> 00:22:32.190
有效地应用程序，但是

00:22:29.610 --> 00:22:34.700
没有创建新的生态系统

00:22:32.190 --> 00:22:37.080
每个人都在发展清洁

00:22:34.700 --> 00:22:40.680
我们已经看到某些语言，例如

00:22:37.080 --> 00:22:43.170
在Scala中有些可怕的东西

00:22:40.680 --> 00:22:46.050
如果没有使用就不会感到

00:22:43.170 --> 00:22:49.500
好，我认为棉花少了

00:22:46.050 --> 00:22:51.510
对此很自以为是

00:22:49.500 --> 00:22:53.550
 mod谁可以重用现有的生态系统

00:22:51.510 --> 00:22:57.300
这就是为什么它很适合

00:22:53.550 --> 00:23:00.210
用Java编写的spring，我们

00:22:57.300 --> 00:23:02.520
我们要做一些吗

00:23:00.210 --> 00:23:04.620
改进以使用Spring 和

00:23:02.520 --> 00:23:07.470
尽我们最大的努力

00:23:04.620 --> 00:23:09.360
实际上，这就是我们当

00:23:07.470 --> 00:23:11.250
开发一些应用程序

00:23:09.360 --> 00:23:14.940
与代码清洁的应用程序，我们

00:23:11.250 --> 00:23:17.460
不要觉得不是为那个而设计的

00:23:14.940 --> 00:23:19.260
那很好，所以我认为

00:23:17.460 --> 00:23:23.810
关键点是谁，为什么这两个

00:23:19.260 --> 00:23:23.810
一起使用的技术很棒

00:23:24.140 --> 00:23:27.840
我不是要说一切都在

00:23:27.030 --> 00:23:30.360
完善

00:23:27.840 --> 00:23:36.720
结果摩擦点了一些

00:23:30.360 --> 00:23:40.200
已经修复了一些

00:23:36.720 --> 00:23:44.660
他们仍然是摩擦之一

00:23:40.200 --> 00:23:50.550
剩下的一点是一个小问题

00:23:44.660 --> 00:23:54.330
带有注释的意思是在Java代码中

00:23:50.550 --> 00:23:57.860
当您有注解时， 

00:23:54.330 --> 00:24:00.870
致敬，您只想指定一个

00:23:57.860 --> 00:24:03.000
一个值，例如，如果您想

00:24:00.870 --> 00:24:05.640
写请求映射方法等于

00:24:03.000 --> 00:24:08.790
获得有效的请求方法

00:24:05.640 --> 00:24:10.470
自动在Java中，因为如果

00:24:08.790 --> 00:24:13.800
有一个循环来请求映射方法

00:24:10.470 --> 00:24:16.050
注释就是数组

00:24:13.800 --> 00:24:17.910
请求方法数组，如果您

00:24:16.050 --> 00:24:20.310
指定一个合适的值

00:24:17.910 --> 00:24:22.890
我可以用Java在棉花中工作，我认为

00:24:20.310 --> 00:24:25.080
同样，您必须分散

00:24:22.890 --> 00:24:27.480
指定这是一个东西的数组

00:24:25.080 --> 00:24:28.950
语法更长一点

00:24:27.480 --> 00:24:32.400
柯克兰，那不是很好

00:24:28.950 --> 00:24:35.580
没有什么阻碍，但这不是很

00:24:32.400 --> 00:24:38.820
使用起来不是很好，所以有

00:24:35.580 --> 00:24:41.550
二对一解决方法和一个修复

00:24:38.820 --> 00:24:45.090
在这种情况下的解决方法

00:24:41.550 --> 00:24:47.340
更常见的是使用

00:24:45.090 --> 00:24:51.450
我们放置的新注释地图集

00:24:47.340 --> 00:24:53.730
在 Spring 免费的框架中

00:24:51.450 --> 00:24:56.310
 3阶和5阶及更高版本的Spring 形式

00:24:53.730 --> 00:24:57.540
您过去映射过的版本

00:24:56.310 --> 00:25:00.120
映射但映射

00:24:57.540 --> 00:25:02.520
删除映射一些快捷方式

00:25:00.120 --> 00:25:05.010
有点像您在jax-rs中所拥有的

00:25:02.520 --> 00:25:06.690
可以让您指定的世界

00:25:05.010 --> 00:25:08.850
这是一个常规的请求映射

00:25:06.690 --> 00:25:11.490
相同的选项，但方法是

00:25:08.850 --> 00:25:14.940
固定为单个获取或单个帖子

00:25:11.490 --> 00:25:18.030
或单个删除，那就是

00:25:14.940 --> 00:25:19.590
很好，因为那是一种放置

00:25:18.030 --> 00:25:21.930
很少有没有映射的特定请求

00:25:19.590 --> 00:25:25.220
方法基本上每个方法都被映射

00:25:21.930 --> 00:25:27.690
这也可能导致一些

00:25:25.220 --> 00:25:29.160
意外的行为就是这样

00:25:27.690 --> 00:25:31.680
很高兴拥有此快捷方式， 

00:25:29.160 --> 00:25:36.830
使用此快捷方式，我们没有

00:25:31.680 --> 00:25:41.130
 sprin Kirkland 1.1中的一系列问题

00:25:36.830 --> 00:25:43.380
这个问题很可能已经解决，例如

00:25:41.130 --> 00:25:51.200
在7月，您将可以指定一个

00:25:43.380 --> 00:25:55.080
数组注释值的单个值

00:25:51.200 --> 00:25:58.380
第二个问题来自设计

00:25:55.080 --> 00:26:00.120
科琳的决定，所以那里有

00:25:58.380 --> 00:26:03.810
对此进行了很多讨论

00:26:00.120 --> 00:26:06.150
一些人的特定设计点

00:26:03.810 --> 00:26:08.370
对此选择感到满意，bhajiya 

00:26:06.150 --> 00:26:11.670
有些不在柯克兰

00:26:08.370 --> 00:26:13.350
默认情况下，这些课程是最终的

00:26:11.670 --> 00:26:15.810
稍后会看到canelo一些

00:26:13.350 --> 00:26:20.640
额外的可扩展性

00:26:15.810 --> 00:26:22.620
 default plus类在Java中更好

00:26:20.640 --> 00:26:26.070
默认情况下，类是开放的，您

00:26:22.620 --> 00:26:27.870
你必须说最后一点好吧

00:26:26.070 --> 00:26:29.910
扩展此类，不允许扩展

00:26:27.870 --> 00:26:33.479
此类或不允许覆盖

00:26:29.910 --> 00:26:35.759
这个方法包含另一个

00:26:33.479 --> 00:26:37.859
默认情况下，愉快的方法是最终的

00:26:35.759 --> 00:26:41.009
而且您必须使用open关键字

00:26:37.859 --> 00:26:43.549
指定应扩展它，或

00:26:41.009 --> 00:26:43.549
超载

00:26:44.840 --> 00:26:52.289
为什么不这样，但这不适合

00:26:49.129 --> 00:26:54.599
一些模拟库或一些饱和的

00:26:52.289 --> 00:26:56.940
代理，在 Spring 我们使用数字

00:26:54.599 --> 00:26:59.940
代理，我们还使用了其他类型的

00:26:56.940 --> 00:27:04.409
 Jenica demmick代理，但我们使用了一些

00:26:59.940 --> 00:27:05.009
果冻代理，因此当前切入

00:27:04.409 --> 00:27:10.379
一点哦

00:27:05.009 --> 00:27:13.859
首先要如何处理好

00:27:10.379 --> 00:27:16.349
没有断点，您只需要放

00:27:13.859 --> 00:27:19.229
打开关键字以及类和方法

00:27:16.349 --> 00:27:21.330
水平，但这又是对的

00:27:19.229 --> 00:27:23.489
凯特琳的精神就是让你

00:27:21.330 --> 00:27:26.519
写较短的代码，这有点

00:27:23.489 --> 00:27:28.679
有点烦人的可以指定为

00:27:26.519 --> 00:27:30.929
强制为每种方法指定打开

00:27:28.679 --> 00:27:33.809
或例如显示配置通过

00:27:30.929 --> 00:27:37.200
因此，当您可以提供服务时， 

00:27:33.809 --> 00:27:39.710
存储库的唯一性和动态代理

00:27:37.200 --> 00:27:42.210
所以这是您使用时的默认位置

00:27:39.710 --> 00:27:44.519
具有接口的类，因为在那

00:27:42.210 --> 00:27:46.080
如果我们能够使用玉学院

00:27:44.519 --> 00:27:47.789
代理，效果很好

00:27:46.080 --> 00:27:51.809
因为那不需要你

00:27:47.789 --> 00:27:52.739
内部扩展类时

00:27:51.809 --> 00:27:55.499
那不可能

00:27:52.739 --> 00:27:59.340
例如添加配置或

00:27:55.499 --> 00:28:02.009
在某些情况下，如果您的存储库服务

00:27:59.340 --> 00:28:04.679
没有界面或类似的东西

00:28:02.009 --> 00:28:08.729
将必须将open关键字放在

00:28:04.679 --> 00:28:10.769
类和方法级别的希望是因为

00:28:08.729 --> 00:28:13.950
我们已经把这一点提到了喷气脑

00:28:10.769 --> 00:28:19.529
哪个开发的凯丁烯应该是

00:28:13.950 --> 00:28:23.279
固定在：1.1我们正在思考

00:28:19.529 --> 00:28:28.080
关于在其中之一之下的价值观方法

00:28:23.279 --> 00:28:32.429
最有趣的是

00:28:28.080 --> 00:28:34.649
能够提供一个元F文件，该文件将

00:28:32.429 --> 00:28:36.809
成为亚洲 Spring 的榜样

00:28:34.649 --> 00:28:40.109
可以让我们指定

00:28:36.809 --> 00:28:43.259
凯思琳编译器每个类

00:28:40.109 --> 00:28:45.059
直接用添加组件注释

00:28:43.259 --> 00:28:46.830
还是间接的，因为我不知道

00:28:45.059 --> 00:28:48.960
你知道，但是每个

00:28:46.830 --> 00:28:52.470
在存储库中的配置广告系列中

00:28:48.960 --> 00:28:54.960
本身被注释的全部

00:28:52.470 --> 00:28:56.760
组件基本上是因为

00:28:54.960 --> 00:28:59.760
注解不是我买的

00:28:56.760 --> 00:29:02.240
因此，如果棉花能够

00:28:59.760 --> 00:29:05.730
认识到添加组件类

00:29:02.240 --> 00:29:09.029
应该默认打开，我们不会

00:29:05.730 --> 00:29:14.630
必须做所有这些事情，所以我们

00:29:09.029 --> 00:29:17.490
试图找到一种方法使一些

00:29:14.630 --> 00:29:21.360
特定注释的类

00:29:17.490 --> 00:29:23.399
注释默认为

00:29:21.360 --> 00:29:24.659
编译器，我的意思是用户

00:29:23.399 --> 00:29:27.419
将无法扩展它，但是

00:29:24.659 --> 00:29:30.960
编译器或在运行时

00:29:27.419 --> 00:29:33.510
可以扩展它那里

00:29:30.960 --> 00:29:35.309
其他方式可能是一些

00:29:33.510 --> 00:29:38.130
编译器插件可能是一些构建工具

00:29:35.309 --> 00:29:42.779
但我目前首选的是

00:29:38.130 --> 00:29:44.700
 meta f1，因为我们就像裁员一样

00:29:42.779 --> 00:29:51.000
选择实施，我们将只是

00:29:44.700 --> 00:29:54.570
必须在其中添加特定的小文件

00:29:51.000 --> 00:29:55.110
 Spring 工作要对科钦说

00:29:54.570 --> 00:29:56.850
好的

00:29:55.110 --> 00:29:58.799
一切都直接注释或

00:29:56.850 --> 00:30:05.070
通过添加组件间接应

00:29:58.799 --> 00:30:06.990
在运行时打开，这确实是

00:30:05.070 --> 00:30:08.549
如果这两个主要摩擦点

00:30:06.990 --> 00:30:12.090
摩擦点在教练中固定

00:30:08.549 --> 00:30:12.750
 1.1我的意思是那会起作用

00:30:12.090 --> 00:30:14.610
很不错

00:30:12.750 --> 00:30:17.210
那已经很不错了，但是

00:30:14.610 --> 00:30:19.769
那真的是我的两个主要问题

00:30:17.210 --> 00:30:24.720
创建了一个 Spring 大扫除项目

00:30:19.769 --> 00:30:27.750
目前实际上主要是常见问题，所以

00:30:24.720 --> 00:30:31.230
我试图放一些文件

00:30:27.750 --> 00:30:35.909
关于这种事情的摩擦点

00:30:31.230 --> 00:30:39.779
或有关如何等待的一些建议

00:30:35.909 --> 00:30:41.460
Spring 和窗帘的应用，所以如果你

00:30:39.779 --> 00:30:48.620
看看你是否想要国防部

00:30:41.460 --> 00:30:51.840
这些行为的眼泪

00:30:48.620 --> 00:30:57.899
让我们谈谈乔特使者

00:30:51.840 --> 00:30:59.879
情况2d所以只是特殊的使者

00:30:57.899 --> 00:31:04.499
只是一个小应用

00:30:59.879 --> 00:31:06.509
一个小的玩具应用程序，但我想你

00:31:04.499 --> 00:31:11.999
会看到足够的源代码

00:31:06.509 --> 00:31:14.519
向您展示如何编写干净的代码

00:31:11.999 --> 00:31:16.919
 Spring Boot应用程序如何

00:31:14.519 --> 00:31:20.699
设计此应用程序，以便使用

00:31:16.919 --> 00:31:24.569
代码干净如语言的 Spring 

00:31:20.699 --> 00:31:28.559
启动加上t2 SQL作为数据库打开

00:31:24.569 --> 00:31:31.199
开放年是一种层次

00:31:28.559 --> 00:31:33.929
 Google Maps但开源及其

00:31:31.199 --> 00:31:34.440
允许您选择价值来源

00:31:33.929 --> 00:31:37.769
数据的

00:31:34.440 --> 00:31:40.709
 OpenStreetMap Google Maps Bing Maps任何

00:31:37.769 --> 00:31:44.419
一种东西，所以你可以看到

00:31:40.709 --> 00:31:46.769
泳镜地图开源，所以我们将有

00:31:44.419 --> 00:31:49.409
所以我们有这个JavaScript 

00:31:46.769 --> 00:31:51.509
我们要求的应用程序

00:31:49.409 --> 00:31:53.249
服务器端我们方便重启

00:31:51.509 --> 00:31:56.759
暴露了一些休息的应用程序

00:31:53.249 --> 00:32:02.099
哎呀，让我们可以免费阅读API 

00:31:56.759 --> 00:32:03.989
例如消息和新消息

00:32:02.099 --> 00:32:07.859
即将到来的消息被推送

00:32:03.989 --> 00:32:11.369
服务器发送事件的用户位置是

00:32:07.859 --> 00:32:14.369
使用html5地理位置API检索到的

00:32:11.369 --> 00:32:17.639
使用引导程序完成一些弹出窗口，因此

00:32:14.369 --> 00:32:20.190
那是一种丰富的富互联网

00:32:17.639 --> 00:32:23.579
应用程序丰富的界面应用程序

00:32:20.190 --> 00:32:30.949
搭配定期的 spring boot jeez和

00:32:23.579 --> 00:32:34.469
再次在github上提供了代码，因此

00:32:30.949 --> 00:32:38.429
 github.com大幅削减美元

00:32:34.469 --> 00:32:40.799
真正的特别-Messenger，使您成为

00:32:38.429 --> 00:32:43.219
能够看一下它运行的克隆

00:32:40.799 --> 00:32:46.199
您想尝试的笔记本电脑

00:32:43.219 --> 00:32:49.559
一切都可用，我会尽力

00:32:46.199 --> 00:32:52.529
保持最新

00:32:49.559 --> 00:32:57.029
 Spring 和延续，例如

00:32:52.529 --> 00:32:58.889
何时可用-何时可用

00:32:57.029 --> 00:33:00.479
可以写一些课

00:32:58.889 --> 00:33:03.690
和方法不用公开

00:33:00.479 --> 00:33:08.009
关键字，我将更新，我将尝试

00:33:03.690 --> 00:33:10.140
跟随演变，让我们来

00:33:08.009 --> 00:33:13.860
看-今年 Spring 的MVC 

00:33:10.140 --> 00:33:17.700
可卡因控制器，所以大部分事情

00:33:13.860 --> 00:33:20.160
对汽车Spring 非常封闭

00:33:17.700 --> 00:33:22.380
我尝试过的排放控制

00:33:20.160 --> 00:33:24.660
突出显示主要差异

00:33:22.380 --> 00:33:26.880
 Kirtland类默认为公开

00:33:24.660 --> 00:33:29.730
因此您不必指定公众

00:33:26.880 --> 00:33:31.620
关键词这些方法也是公开的

00:33:29.730 --> 00:33:35.820
默认情况下，您不必指定

00:33:31.620 --> 00:33:38.160
公共关键字-从锁开始的 Spring 

00:33:35.820 --> 00:33:42.240
这是免费的，而这并非特定于

00:33:38.160 --> 00:33:43.770
凯瑟琳，但我想谈一谈

00:33:42.240 --> 00:33:47.429
关于构造函数注入

00:33:43.770 --> 00:33:49.320
如果我们在渥太华场没有

00:33:47.429 --> 00:33:54.570
只有一个构造函数，所以这就是为什么

00:33:49.320 --> 00:33:57.210
没有总接线

00:33:54.570 --> 00:33:59.299
控制器构造函数，因为那是

00:33:57.210 --> 00:34:02.820
就像我们看到的第一个例子

00:33:59.299 --> 00:34:09.810
我们正在同时定义

00:34:02.820 --> 00:34:12.659
构造函数和属性

00:34:09.810 --> 00:34:13.859
正在使用用于

00:34:12.659 --> 00:34:16.649
请求映射，我们以前见过

00:34:13.859 --> 00:34:19.310
避免注销数组，所以我们

00:34:16.649 --> 00:34:21.510
使用添加通过映射和获取映射

00:34:19.310 --> 00:34:23.550
广告映射，那将是

00:34:21.510 --> 00:34:25.770
再次在Java中相同，但不具体

00:34:23.550 --> 00:34:28.169
到凯瑟琳，那只能让你

00:34:25.770 --> 00:34:30.780
编写较短的代码，如果您有

00:34:28.169 --> 00:34:34.409
查看列表功能，您将看到

00:34:30.780 --> 00:34:37.230
由于法国的类型

00:34:34.409 --> 00:34:39.510
通常能够写一个电表

00:34:37.230 --> 00:34:41.159
用这样的单行，我们

00:34:39.510 --> 00:34:45.270
不必指定

00:34:41.159 --> 00:34:48.210
列表返回值的比率

00:34:45.270 --> 00:34:52.730
自动成为客人，那将是

00:34:48.210 --> 00:34:56.129
使用的类型将与

00:34:52.730 --> 00:34:58.170
找到所有返回值的存储库

00:34:56.129 --> 00:35:00.869
真的，一切都是静态的

00:34:58.170 --> 00:35:02.520
完全像在Java中一样键入

00:35:00.869 --> 00:35:03.720
使用您在Cochin中创建的类

00:35:02.520 --> 00:35:04.290
你有相同的中篇小说照片

00:35:03.720 --> 00:35:07.080
完成

00:35:04.290 --> 00:35:09.570
但法国的类型允许您

00:35:07.080 --> 00:35:12.840
没有指定返回值的类型

00:35:09.570 --> 00:35:17.570
如果变量的参数

00:35:12.840 --> 00:35:17.570
编译器可以猜测

00:35:18.130 --> 00:35:25.930
所以我们来谈谈如何坚持

00:35:21.640 --> 00:35:27.430
数据，因此选择Spring 数据GPA为

00:35:25.930 --> 00:35:30.670
完美的代码清理

00:35:27.430 --> 00:35:33.160
作品我创建了一个样本给你

00:35:30.670 --> 00:35:35.890
可以在github.com中看到斜杠

00:35:33.160 --> 00:35:37.869
 Spring 会减少演示， 

00:35:35.890 --> 00:35:40.329
效果很好，所以没错

00:35:37.869 --> 00:35:44.710
使用GPA并一起修剪干净

00:35:40.329 --> 00:35:48.479
要清楚一点，但我想

00:35:44.710 --> 00:35:51.910
给你展示另一种写作方式

00:35:48.479 --> 00:35:54.339
你，你，你，坚持，他们更

00:35:51.910 --> 00:35:58.450
轻巧的方式来做更多

00:35:54.339 --> 00:36:00.130
惯用的简洁方式来写

00:35:58.450 --> 00:36:03.970
为了实现我们要

00:36:00.130 --> 00:36:09.549
使用裸露是安全切入的类型

00:36:03.970 --> 00:36:14.799
 SQL DSL将使我们能够编写SQL 

00:36:09.549 --> 00:36:17.739
查询编码，我认为

00:36:14.799 --> 00:36:19.779
通常是DSL的一个很好的例子

00:36:17.739 --> 00:36:21.910
可以用Kotlin进行写

00:36:19.779 --> 00:36:25.569
比scala更强大

00:36:21.910 --> 00:36:27.339
写你不懂的GSL 

00:36:25.569 --> 00:36:31.150
你自己，即使你在写

00:36:27.339 --> 00:36:33.609
即使有代码限制也更好

00:36:31.150 --> 00:36:36.880
干净，你真的可以写一些非常

00:36:33.609 --> 00:36:40.329
可怜的傻瓜DSL，我认为发现者

00:36:36.880 --> 00:36:43.509
为此写了正确的平衡

00:36:40.329 --> 00:36:46.239
为什么使用没有GPA的正方形

00:36:43.509 --> 00:36:49.420
我认为这可以让您获得更多

00:36:46.239 --> 00:36:51.969
控制SQL查询以及关于

00:36:49.420 --> 00:36:54.700
可以让你轻一点的关节

00:36:51.969 --> 00:36:57.190
技术堆栈以利用

00:36:54.700 --> 00:37:00.130
本机数据库功能和

00:36:57.190 --> 00:37:02.799
我们也很少需要改变

00:37:00.130 --> 00:37:06.579
所以为什么不仅仅利用

00:37:02.799 --> 00:37:08.140
关于您正在使用的

00:37:06.579 --> 00:37:10.239
有趣的本地人的例子

00:37:08.140 --> 00:37:13.299
功能，例如PostgreSQL 

00:37:10.239 --> 00:37:16.809
在此示例中，本机JSON支持

00:37:13.299 --> 00:37:19.630
正在创建一个用户表

00:37:16.809 --> 00:37:22.950
包含值列和其中之一

00:37:19.630 --> 00:37:25.900
列元数据作为JSON类型

00:37:22.950 --> 00:37:28.630
那你要插入一些G的承受力

00:37:25.900 --> 00:37:31.750
单位，以便您看到我们正在插入

00:37:28.630 --> 00:37:37.870
第1行邮政编码的地址

00:37:31.750 --> 00:37:40.870
两国富巴和好东西

00:37:37.870 --> 00:37:43.680
关于耶稣邀请，因为我们

00:37:40.870 --> 00:37:47.530
可以用古兰经》来做到这一点

00:37:43.680 --> 00:37:53.680
所以耶稣和B型让我们索引到

00:37:47.530 --> 00:37:57.280
在G区域打开索引

00:37:53.680 --> 00:37:59.230
直接在此列中提供的内容

00:37:57.280 --> 00:38:01.000
这意味着我将

00:37:59.230 --> 00:38:05.530
能够写一些像细胞一样的语句

00:38:01.000 --> 00:38:08.740
在用户选择文档并打开时进行选择，然后

00:38:05.530 --> 00:38:11.920
在地址附近放一个地方

00:38:08.740 --> 00:38:15.670
和邮递区号的速度相同

00:38:11.920 --> 00:38:17.530
比起它是原生列

00:38:15.670 --> 00:38:20.260
数据法必须要做非常有力的事情

00:38:17.530 --> 00:38:23.470
之所以这样，是因为在Java和

00:38:20.260 --> 00:38:26.170
凯瑟琳我们被静态键入，所以我们

00:38:23.470 --> 00:38:28.900
像PHP或in 

00:38:26.170 --> 00:38:31.870
 JavaScript和您在哪里写

00:38:28.900 --> 00:38:34.300
例如后端的后台

00:38:31.870 --> 00:38:36.940
允许您允许您使用用户

00:38:34.300 --> 00:38:40.570
在运行时创建一些结构

00:38:36.940 --> 00:38:42.520
你没有你不知道你什么时候

00:38:40.570 --> 00:38:47.880
开发这样的应用程序

00:38:42.520 --> 00:38:51.580
动态功能非常有用

00:38:47.880 --> 00:38:55.360
所以如果我们写的话我们添加

00:38:51.580 --> 00:38:57.580
用Spring gdb编写应用程序

00:38:55.360 --> 00:39:01.330
看到我们应该有一份严格的报告

00:38:57.580 --> 00:39:04.270
创建了一种使用这种SQL的架构

00:39:01.330 --> 00:39:06.970
创建表的东西，如果他们

00:39:04.270 --> 00:39:10.540
不存在，他们创建索引为

00:39:06.970 --> 00:39:12.910
如果它们不存在，那么我们将如何发展

00:39:10.540 --> 00:39:17.310
写在柯克兰与暴露

00:39:12.910 --> 00:39:21.880
实际上，我们将要编写SQL模式

00:39:17.310 --> 00:39:25.150
与代码中的代码，所以这是

00:39:21.880 --> 00:39:30.040
等效于您之前的SQL代码

00:39:25.150 --> 00:39:33.210
看到那是SQL的吸引力，但是

00:39:30.040 --> 00:39:37.240
当我们轻量化时，我们直接使用

00:39:33.210 --> 00:39:39.460
我们正在定义的技能类型

00:39:37.240 --> 00:39:41.650
在女孩汽车实施了新的

00:39:39.460 --> 00:39:43.099
主键我们定义了各种

00:39:41.650 --> 00:39:46.260
列和

00:39:43.099 --> 00:39:49.170
有趣的是，这些

00:39:46.260 --> 00:39:51.690
消息和用户对象将是

00:39:49.170 --> 00:39:56.339
在我要告诉你之后再使用

00:39:51.690 --> 00:40:04.200
用一个直接写查询

00:39:56.339 --> 00:40:05.970
静态静态类型化的API，所以我们

00:40:04.200 --> 00:40:08.369
不使用Spring 数据

00:40:05.970 --> 00:40:10.920
应用程序，所以我很快就写了

00:40:08.369 --> 00:40:13.319
存储库接口，其中包含

00:40:10.920 --> 00:40:15.000
伟大的表创造最终的数字罚款

00:40:13.319 --> 00:40:19.530
银行精品盒，使一个

00:40:15.000 --> 00:40:23.369
允许查找一些消息或用户

00:40:19.530 --> 00:40:25.819
基于特定的边界框

00:40:23.369 --> 00:40:29.099
将允许我们更新位置并

00:40:25.819 --> 00:40:32.780
所以方法库和新闻库

00:40:29.099 --> 00:40:34.950
扩展产生一棵树

00:40:32.780 --> 00:40:37.800
所以如果我们看一下仓库

00:40:34.950 --> 00:40:40.829
实现，其注释为

00:40:37.800 --> 00:40:44.130
像常规的常规 Spring 一样的存储库

00:40:40.829 --> 00:40:46.319
我们正在使用的存储库

00:40:44.130 --> 00:40:48.960
事务性的，因为支持暴露

00:40:46.319 --> 00:40:50.520
真正的 Spring 交易

00:40:48.960 --> 00:40:55.290
应该在

00:40:50.520 --> 00:40:57.030
服务层，我想如果您有一个

00:40:55.290 --> 00:40:58.859
寻找更新位置功能

00:40:57.030 --> 00:41:01.829
示例，您将看到它被暴露

00:40:58.859 --> 00:41:05.609
允许我们用编写SQL查询

00:41:01.829 --> 00:41:07.079
允许使用的清洁类型安全API 

00:41:05.609 --> 00:41:09.480
我们即将完成类似

00:41:07.079 --> 00:41:09.930
所以不是那一点

00:41:09.480 --> 00:41:11.730
不同

00:41:09.930 --> 00:41:14.099
通常我们会根据数据来证明您的信誉

00:41:11.730 --> 00:41:17.760
归功于您扩展到的相反URI 

00:41:14.099 --> 00:41:20.250
添加您的自定义 Spring 

00:41:17.760 --> 00:41:22.440
能够根据

00:41:20.250 --> 00:41:25.799
方法的名称在这里有点

00:41:22.440 --> 00:41:28.829
有点不同，我们在使用

00:41:25.799 --> 00:41:30.450
代码清理和库的功能

00:41:28.829 --> 00:41:33.660
暴露但我想会有很多

00:41:30.450 --> 00:41:36.410
一开始也是其他的

00:41:33.660 --> 00:41:40.619
定义表的结构，并

00:41:36.410 --> 00:41:43.770
重用这些用户或消息对象

00:41:40.619 --> 00:41:47.040
用一个直接写查询

00:41:43.770 --> 00:41:50.880
静态类型的API，因此这里的查询

00:41:47.040 --> 00:41:53.010
很简单，但在现实生活中

00:41:50.880 --> 00:41:55.380
可以写出非常复杂的语句

00:41:53.010 --> 00:41:57.809
使用这种API并

00:41:55.380 --> 00:42:00.109
这是一个关于SQL的例子

00:41:57.809 --> 00:42:04.740
但是您可以找到关于没有SQL的相同信息

00:42:00.109 --> 00:42:07.529
您可以使用HTML将值DSL写入HTML 

00:42:04.740 --> 00:42:10.259
卡普兰，那是一个漂亮的

00:42:07.529 --> 00:42:14.819
我认为如果您有一个有趣的用例

00:42:10.259 --> 00:42:17.339
看看不是

00:42:14.819 --> 00:42:20.730
使用括号是因为

00:42:17.339 --> 00:42:23.009
此功能已指定为

00:42:20.730 --> 00:42:25.200
修复和修复中只是说你可以

00:42:23.009 --> 00:42:28.200
省略括号将

00:42:25.200 --> 00:42:30.089
只是语法糖就可以

00:42:28.200 --> 00:42:31.859
基本上写更多的功能代码，但是

00:42:30.089 --> 00:42:38.039
那是那里的常规功能

00:42:31.859 --> 00:42:40.589
这里不是没有魔术，所以我们正在使用

00:42:38.039 --> 00:42:44.339
 SQL，那很好，但是那怎么办

00:42:40.589 --> 00:42:47.819
当我必须使用本机时可以工作

00:42:44.339 --> 00:42:50.039
我的数据库的功能，因为

00:42:47.819 --> 00:42:52.920
我说以前曝光是正常的

00:42:50.039 --> 00:42:54.660
我谈论过的本机SQL库

00:42:52.920 --> 00:42:57.569
 JSON支持或

00:42:54.660 --> 00:43:03.200
像地理空间支持，那怎么可能

00:42:57.569 --> 00:43:07.650
我在我们所在的方法中编写此代码

00:43:03.200 --> 00:43:10.349
暴露只是支持常规SQL所以

00:43:07.650 --> 00:43:13.769
那是另一个代码示例

00:43:10.349 --> 00:43:16.410
减少了扩展功能的清洁电源

00:43:13.769 --> 00:43:20.250
窗帘扩展允许您扩展

00:43:16.410 --> 00:43:23.789
现有类中添加新方法

00:43:20.250 --> 00:43:25.740
直接就位，听起来像

00:43:23.789 --> 00:43:29.730
一点魔力，但这不是

00:43:25.740 --> 00:43:32.759
所以魔术基本上你在这里看到我定义

00:43:29.730 --> 00:43:35.369
列出并放入扩展中的函数

00:43:32.759 --> 00:43:38.420
表格点表示我

00:43:35.369 --> 00:43:41.430
将增加一个点到现有的

00:43:38.420 --> 00:43:43.799
来自暴露的表类型

00:43:41.430 --> 00:43:46.490
所以那是我不拥有的罐子里出来的

00:43:43.799 --> 00:43:52.559
我只是在其中添加一个方法

00:43:46.490 --> 00:43:55.799
并且此功能将是

00:43:52.559 --> 00:43:58.049
仅当我编写代码时可用

00:43:55.799 --> 00:44:01.309
导入这个扩展名

00:43:58.049 --> 00:44:01.309
有点像静态导入

00:44:01.609 --> 00:44:04.940
我不知道您是否使用过

00:44:03.290 --> 00:44:08.780
鸡肉锅，但是有点像

00:44:04.940 --> 00:44:10.940
如果我只是使用常规代码

00:44:08.780 --> 00:44:14.750
没有具体的导入表，我们只添加

00:44:10.940 --> 00:44:18.230
方法定义的功能

00:44:14.750 --> 00:44:20.780
此类中的默认值，但如果我导入

00:44:18.230 --> 00:44:23.780
我定义这个的门

00:44:20.780 --> 00:44:26.660
扩展类型表枪口，然后

00:44:23.780 --> 00:44:30.160
 IDE的编译器会在

00:44:26.660 --> 00:44:32.960
自动完成点方法和

00:44:30.160 --> 00:44:34.490
动态与动态

00:44:32.960 --> 00:44:38.150
因为扩展是动态的

00:44:34.490 --> 00:44:42.550
但扩展名已解决的事实

00:44:38.150 --> 00:44:46.280
静态地减少魔法

00:44:42.550 --> 00:44:50.540
保持负荷以保持控制

00:44:46.280 --> 00:44:53.980
什么是扩展名，因为如果

00:44:50.540 --> 00:44:58.609
我们不添加此静态分辨率

00:44:53.980 --> 00:45:04.819
如果我写了1个未读的扩展

00:44:58.609 --> 00:45:06.500
将无法管理，所以我们在这里

00:45:04.819 --> 00:45:07.940
看看配置类

00:45:06.500 --> 00:45:10.309
那是常规的 spring boot 

00:45:07.940 --> 00:45:13.460
带有注释的配置类

00:45:10.309 --> 00:45:16.160
 Spring 很好的应用程序，所以打开关键字

00:45:13.460 --> 00:45:19.309
在类和方法级别是必需的

00:45:16.160 --> 00:45:23.450
因为我们不是因为我们正在使用

00:45:19.309 --> 00:45:26.569
愚蠢地在内部扩展该类

00:45:23.450 --> 00:45:28.069
从 Spring 农场开始

00:45:26.569 --> 00:45:29.540
注入并自动绘制模块

00:45:28.069 --> 00:45:32.150
已注册，因此您不必

00:45:29.540 --> 00:45:33.920
在这种情况下注册并使用

00:45:32.150 --> 00:45:36.200
注册页面此模块

00:45:33.920 --> 00:45:40.359
允许杰克逊处理您的

00:45:36.200 --> 00:45:42.680
图形类型和主要功能

00:45:40.359 --> 00:45:44.299
不必被包裹在一个类中

00:45:42.680 --> 00:45:50.480
您可以将其作为顶级

00:45:44.299 --> 00:45:52.620
适用于平地机文件的功能是

00:45:50.480 --> 00:45:55.650
普通人

00:45:52.620 --> 00:45:57.390
特定于切割的点

00:45:55.650 --> 00:46:00.320
您指定的清洁牛插件

00:45:57.390 --> 00:46:04.380
和最干净的剪彩

00:46:00.320 --> 00:46:07.980
反映图书馆，其余的只是

00:46:04.380 --> 00:46:10.440
我没有的常规Java依赖项

00:46:07.980 --> 00:46:13.020
指定以前，但您可以

00:46:10.440 --> 00:46:15.540
完全混合Java输入干净的代码

00:46:13.020 --> 00:46:19.680
同样完美的代码库

00:46:15.540 --> 00:46:22.080
好，那就是，是的，有一个

00:46:19.680 --> 00:46:26.580
两者之间非常好

00:46:22.080 --> 00:46:30.270
技术，而不是我们

00:46:26.580 --> 00:46:33.750
宣布削减Gradle前往苏格兰

00:46:30.270 --> 00:46:38.330
那你可能知道什么意思

00:46:33.750 --> 00:46:41.460
 Gradle使用groovy来形容

00:46:38.330 --> 00:46:44.010
您在其中指定的build.gradle文件和

00:46:41.460 --> 00:46:46.200
您配置您的构建，它允许

00:46:44.010 --> 00:46:49.440
使用groovy开发插件

00:46:46.200 --> 00:46:52.440
例如仍将受支持

00:46:49.440 --> 00:46:56.370
当然，但平地机确实在切换

00:46:52.440 --> 00:47:01.020
给凯瑟琳（Kathleen）使用的主要语言

00:46:56.370 --> 00:47:04.040
描述你所有的垃圾箱

00:47:01.020 --> 00:47:06.600
因为我之前说过

00:47:04.040 --> 00:47:11.510
做饭允许写短代码

00:47:06.600 --> 00:47:14.910
 Layton常规但具有静态输入和

00:47:11.510 --> 00:47:18.240
在自动完成方面，例如

00:47:14.910 --> 00:47:22.760
我12月自动完成的值在

00:47:18.240 --> 00:47:25.920
摇篮只是基本上不起作用

00:47:22.760 --> 00:47:27.990
默认情况下与凯瑟琳一起

00:47:25.920 --> 00:47:29.700
自动完成所有工作， 

00:47:27.990 --> 00:47:31.710
对插件进行更多控制

00:47:29.700 --> 00:47:34.800
生态系统之类的东西

00:47:31.710 --> 00:47:38.060
不小的动作， 

00:47:34.800 --> 00:47:40.950
免费Gradle，您会默认看到

00:47:38.060 --> 00:47:43.740
相当的方法将推动使用

00:47:40.950 --> 00:47:45.180
凯瑟琳（Kathleen）默认情况下，他们仍然

00:47:43.740 --> 00:47:47.370
支持groovy，那很好

00:47:45.180 --> 00:47:49.620
使用groovy，但是当您看到

00:47:47.370 --> 00:47:52.980
在自动完成方面的优势

00:47:49.620 --> 00:47:54.930
旋转的条件，是的，真的

00:47:52.980 --> 00:47:58.520
有所作为，所以我认为这就是为什么

00:47:54.930 --> 00:47:58.520
他们做了切换

00:47:59.040 --> 00:48:05.610
就部署而言，复制是

00:48:03.180 --> 00:48:11.580
经常下颌的斯普林伍德

00:48:05.610 --> 00:48:14.840
这是18 18兆字节，非常小

00:48:11.580 --> 00:48:17.760
不到三秒钟就完成了

00:48:14.840 --> 00:48:22.050
就内存消耗而言，它运行

00:48:17.760 --> 00:48:26.480
少于32 MB的RAM 

00:48:22.050 --> 00:48:30.360
你会看到凯瑟琳不消耗更多

00:48:26.480 --> 00:48:33.450
记忆力比D'Angela以及使用时

00:48:30.360 --> 00:48:36.120
一些依赖，例如没有

00:48:33.450 --> 00:48:39.390
像我所做的那样，想法网和GPA 

00:48:36.120 --> 00:48:43.860
露出那是薄薄的一层

00:48:39.390 --> 00:48:45.750
 gdb看到您可以完美运行

00:48:43.860 --> 00:48:49.980
 spring boot 和计算应用

00:48:45.750 --> 00:48:52.290
少于30 32 MB的内存

00:48:49.980 --> 00:48:54.660
我不会在生产中使用它，但是我

00:48:52.290 --> 00:48:57.830
用64位思考生产

00:48:54.660 --> 00:49:00.360
那-一点都很好并且

00:48:57.830 --> 00:49:02.100
卡特琳（Catrin）也专为

00:49:00.360 --> 00:49:04.530
移动世界在哪里

00:49:02.100 --> 00:49:06.690
约束是规则所在

00:49:04.530 --> 00:49:12.240
非常模仿，所以这也是一个很好的

00:49:06.690 --> 00:49:14.220
适合云应用程序，所以我们有

00:49:12.240 --> 00:49:16.680
谈论了很多关于凯瑟琳的事情

00:49:14.220 --> 00:49:18.870
我说过服务器端的发展

00:49:16.680 --> 00:49:21.480
并没有阻止我做饭

00:49:18.870 --> 00:49:25.860
认为是Android的首选

00:49:21.480 --> 00:49:31.920
开发，但也可以使用

00:49:25.860 --> 00:49:35.310
用于客户端开发，因此有

00:49:31.920 --> 00:49:38.340
一个叫切成GS的堆垛机

00:49:35.310 --> 00:49:41.520
行来编译干净的源代码到

00:49:38.340 --> 00:49:44.460
我认为每一个JavaScript源代码

00:49:41.520 --> 00:49:47.220
每种语言的差异

00:49:44.460 --> 00:49:49.020
期限，以及是否适用于

00:49:47.220 --> 00:49:54.780
现实生活

00:49:49.020 --> 00:49:58.230
因此目前尚未发布

00:49:54.780 --> 00:50:00.210
在一个地方煮一个点哦，我的意思是

00:49:58.230 --> 00:50:02.820
它可用，但未标记为

00:50:00.210 --> 00:50:05.190
准备好的投影，这就是目标

00:50:02.820 --> 00:50:10.080
切成一个但有一个

00:50:05.190 --> 00:50:12.630
已经产生了可用的，所以我们

00:50:10.080 --> 00:50:15.210
使用JavaScript在JavaScript中生成一些

00:50:12.630 --> 00:50:17.070
您正在使用某些零件的库

00:50:15.210 --> 00:50:23.700
代码清理标准库

00:50:17.070 --> 00:50:25.950
和您的应用程序，如我所说的Kalina 

00:50:23.700 --> 00:50:28.110
静态输入，因此您必须

00:50:25.950 --> 00:50:31.050
写一些，否则你将不得不使用一些

00:50:28.110 --> 00:50:34.950
现有的定义有点像

00:50:31.050 --> 00:50:37.920
打字稿，使您可以使用

00:50:34.950 --> 00:50:41.910
 JavaScript库，所以在这种情况下

00:50:37.920 --> 00:50:47.670
定义一些快速的声明

00:50:41.910 --> 00:50:49.980
 jQuery的加泰罗尼亚人走了

00:50:47.670 --> 00:50:52.740
和一些允许

00:50:49.980 --> 00:50:55.770
将打字稿定义转换为包含

00:50:52.740 --> 00:50:58.980
自动定义，将允许

00:50:55.770 --> 00:51:00.570
您重用大量的API 

00:50:58.980 --> 00:51:04.560
来自打字稿的定义

00:51:00.570 --> 00:51:07.650
世界，那你将拥有

00:51:04.560 --> 00:51:09.120
自动完成编译时间检查共享

00:51:07.650 --> 00:51:12.110
客户端和服务器端之间的代码

00:51:09.120 --> 00:51:15.650
还有苏珊歌剧

00:51:12.110 --> 00:51:22.620
两者之间的匹配源代码

00:51:15.650 --> 00:51:25.620
盒子的基础上，所以预计

00:51:22.620 --> 00:51:29.220
真正发布用于广泛

00:51:25.620 --> 00:51:30.660
带有模块JavaScript的13个1.1 

00:51:29.220 --> 00:51:33.720
模块支持更好的文档

00:51:30.660 --> 00:51:39.380
 IDE集成和一些Xmas之间

00:51:33.720 --> 00:51:43.550
脚本e6报告效果很好

00:51:39.380 --> 00:51:48.090
会生成大的javascript文件，因此

00:51:43.550 --> 00:51:50.190
那并不完美，仍然可以

00:51:48.090 --> 00:51:55.830
规模的进步

00:51:50.190 --> 00:51:58.380
 javascript生成的，但是那

00:51:55.830 --> 00:52:00.060
绝对可以写一个

00:51:58.380 --> 00:52:03.180
结合使用的应用

00:52:00.060 --> 00:52:05.580
客户端和服务器端，但是

00:52:03.180 --> 00:52:06.710
从长远来看，我的确更多

00:52:05.580 --> 00:52:10.160
有兴趣

00:52:06.710 --> 00:52:14.599
说你们中有多少人听说过

00:52:10.160 --> 00:52:17.420
 webassembly是的，所以无论是否说谎

00:52:14.599 --> 00:52:19.220
一项真正的新技术，所以不是

00:52:17.420 --> 00:52:21.500
令人惊讶的是，不是我听说过的每个人

00:52:19.220 --> 00:52:24.589
关于那个好，基本上是一些谎言

00:52:21.500 --> 00:52:27.800
通过代码I进行网络技术

00:52:24.589 --> 00:52:29.839
意思是直到现在我们都使用过JavaScript 

00:52:27.800 --> 00:52:32.109
作为网络，基本上每个代码

00:52:29.839 --> 00:52:35.900
每个人都在转移到JavaScript 

00:52:32.109 --> 00:52:38.630
我认为转移到

00:52:35.900 --> 00:52:41.330
 JavaScript从长远来看是完美的

00:52:38.630 --> 00:52:43.190
适用于以下语言的超集

00:52:41.330 --> 00:52:45.650
 JavaScript我的意思是打字稿

00:52:43.190 --> 00:52:47.630
非常适合CoffeeScript 

00:52:45.650 --> 00:52:51.980
完美的表现出一些X我的

00:52:47.630 --> 00:52:53.960
脚本六到七到以前的版本

00:52:51.980 --> 00:52:58.130
的JavaScript也很好

00:52:53.960 --> 00:53:01.060
最终会保留下来

00:52:58.130 --> 00:53:03.890
一些JavaScript截然不同

00:53:01.060 --> 00:53:05.960
用一些非常汇编的语言

00:53:03.890 --> 00:53:10.460
与JavaScript具有不同的语义

00:53:05.960 --> 00:53:13.550
 javascript是一种hack，是的， 

00:53:10.460 --> 00:53:15.410
一些问题，例如数字

00:53:13.550 --> 00:53:18.140
类型不一样，即使您

00:53:15.410 --> 00:53:21.170
可以接近有效的东西

00:53:18.140 --> 00:53:23.390
你有一些小的差异

00:53:21.170 --> 00:53:30.050
一些性能问题，那不是

00:53:23.390 --> 00:53:33.470
非常原生，所以之前的Biggers 

00:53:30.050 --> 00:53:37.130
 Google Apple Microsoft Mozilla已拥有

00:53:33.470 --> 00:53:39.770
已经工作了几年了

00:53:37.130 --> 00:53:43.070
提高绩效水平

00:53:39.770 --> 00:53:46.430
浏览器，因此您可能听说过SMG 

00:53:43.070 --> 00:53:51.349
这是JavaScript的一小部分

00:53:46.430 --> 00:53:53.990
基本上可以编译C C ++ 

00:53:51.349 --> 00:53:58.099
编程到此JavaScript子集并

00:53:53.990 --> 00:54:00.140
运行非常非常快，所以在这种情况下

00:53:58.099 --> 00:54:03.560
他们正在使用这部分JavaScript 

00:54:00.140 --> 00:54:08.300
作为描述汇编代码的一种方式

00:54:03.560 --> 00:54:11.150
该程序的存在本机客户端

00:54:08.300 --> 00:54:14.210
例如Google的技术

00:54:11.150 --> 00:54:17.190
一直以来，我已经做了很多工作

00:54:14.210 --> 00:54:21.059
在某个时候

00:54:17.190 --> 00:54:25.799
是的，这就是这些技术

00:54:21.059 --> 00:54:28.920
不错，但是没有标准化

00:54:25.799 --> 00:54:32.609
而且应该有更好的方法

00:54:28.920 --> 00:54:35.130
所以这对于四大浏览器

00:54:32.609 --> 00:54:35.849
供应商工作了几个月， 

00:54:35.130 --> 00:54:40.769
网络组装

00:54:35.849 --> 00:54:47.450
这是一种二进制格式，用于描述

00:54:40.769 --> 00:54:52.710
一种中立的方式，基本上有一个代码

00:54:47.450 --> 00:54:54.450
而且想法是能够做到

00:54:52.710 --> 00:54:57.390
浏览器可以执行

00:54:54.450 --> 00:55:02.730
最初非常有效地编码

00:54:57.390 --> 00:55:05.099
更专注于应用

00:55:02.730 --> 00:55:08.490
像计算计算这样的游戏

00:55:05.099 --> 00:55:11.190
密集的应用程序，但使

00:55:08.490 --> 00:55:14.220
我是作为目标计算

00:55:11.190 --> 00:55:16.829
 CCP空间计划，但基于Web的在线

00:55:14.220 --> 00:55:19.170
也是可以用来

00:55:16.829 --> 00:55:21.890
作为其他人的计算目标

00:55:19.170 --> 00:55:24.000
语言，以便我们可以看到休息

00:55:21.890 --> 00:55:27.119
抱怨一些竞争对手是否可以

00:55:24.000 --> 00:55:31.190
看到柯克兰可能开小数

00:55:27.119 --> 00:55:34.529
我换了等等等等，这会使

00:55:31.190 --> 00:55:36.869
嫉妒的Caprice死了，我们留下来了，但是那

00:55:34.529 --> 00:55:39.210
将不是一个非常有效的实现

00:55:36.869 --> 00:55:42.839
相当低的水平，可以运行一些

00:55:39.210 --> 00:55:44.819
应用程序，我试图讨论

00:55:42.839 --> 00:55:47.759
与柯克兰的家伙在一起，所以没有

00:55:44.819 --> 00:55:51.180
关于webOS在线的官方计划，但是

00:55:47.759 --> 00:55:53.730
我认为那是一种有趣的方式

00:55:51.180 --> 00:55:57.000
关于柯克兰的思考

00:55:53.730 --> 00:56:00.410
客户端，供将来编译

00:55:57.000 --> 00:56:02.609
不共享

00:56:00.410 --> 00:56:05.309
 JavaScript语义到JavaScript是

00:56:02.609 --> 00:56:08.039
 hack，从长远来看，我认为

00:56:05.309 --> 00:56:11.359
会很有趣，我想我们会看到

00:56:08.039 --> 00:56:16.500
快速休息，将其合并到webOS中

00:56:11.359 --> 00:56:18.450
 Webassembly已在中提供

00:56:16.500 --> 00:56:22.500
 Chrome Canary（如果您启用了标记和

00:56:18.450 --> 00:56:24.269
您可以全速运行视频游戏

00:56:22.500 --> 00:56:27.480
那就是那很好

00:56:24.269 --> 00:56:29.670
他们在这方面确实进步很快

00:56:27.480 --> 00:56:32.029
明年我想我们会很好看的

00:56:29.670 --> 00:56:34.980
一些-通过遮阳浏览器进行处理

00:56:32.029 --> 00:56:39.500
没有标志，所以这是一个

00:56:34.980 --> 00:56:42.240
有趣的技术，如果

00:56:39.500 --> 00:56:45.569
整理干净-遵守阳光

00:56:42.240 --> 00:56:49.349
可能会让人们发动战争

00:56:45.569 --> 00:56:52.319
抱怨的生态系统干净利落

00:56:49.349 --> 00:56:55.049
客户端库

00:56:52.319 --> 00:56:58.109
与JavaScript生态系统不同

00:56:55.049 --> 00:57:04.829
我们看到的，是的

00:56:58.109 --> 00:57:07.710
有趣的如何学习加泰罗尼亚语，所以你

00:57:04.829 --> 00:57:10.890
可以去尝试那个过场的长狗

00:57:07.710 --> 00:57:12.900
会看到加泰罗尼亚锥

00:57:10.890 --> 00:57:17.609
可以让您学习的应用程序

00:57:12.900 --> 00:57:19.680
逐步使用此应用程序的语言

00:57:17.609 --> 00:57:22.769
用干净的代码开发-是的

00:57:19.680 --> 00:57:25.589
就是那个例子

00:57:22.769 --> 00:57:28.829
社区很有趣

00:57:25.589 --> 00:57:31.529
可卡因有一个松弛的实例

00:57:28.829 --> 00:57:36.269
很好，您可以在那里讨论

00:57:31.529 --> 00:57:39.019
直接与有经验的开发人员联系

00:57:36.269 --> 00:57:43.819
应该是一个有趣的地方

00:57:39.019 --> 00:57:47.190
我会结束，因为我可以快速展示

00:57:43.819 --> 00:57:50.430
该应用程序的快速示例演示

00:57:47.190 --> 00:57:52.710
因此，如果您克隆的只是堡垒

00:57:50.430 --> 00:57:56.359
 Messenger，您将获得此应用程序

00:57:52.710 --> 00:58:00.569
我们有消息用户类

00:57:56.359 --> 00:58:05.970
只是我向你展示的

00:58:00.569 --> 00:58:10.490
运行它，我只是运行了

00:58:05.970 --> 00:58:10.490
应用类别

00:58:15.200 --> 00:58:23.329
好，这样一个应用程序

00:58:19.609 --> 00:58:34.369
在这里我可以写一些消息

00:58:23.329 --> 00:58:42.290
好的，如果我打开另一个

00:58:34.369 --> 00:58:44.780
浏览器并转到货车，我创建了

00:58:42.290 --> 00:58:46.849
一条消息，消息将是

00:58:44.780 --> 00:58:49.190
由服务器在两个事件中发送事件

00:58:46.849 --> 00:58:51.230
洞各种实例表明

00:58:49.190 --> 00:58:54.049
那是一个非常简单的应用程序，但是

00:58:51.230 --> 00:58:58.549
只是为了向您展示真实

00:58:54.049 --> 00:59:06.040
方便的例子很好

00:58:58.549 --> 00:59:09.400
应用程序公爵回到那里，那么下一步

00:59:06.040 --> 00:59:14.270
根据 Spring 的信心报告

00:59:09.400 --> 00:59:15.920
我们将发展以改善

00:59:14.270 --> 00:59:18.859
 Spring 凯瑟琳切

00:59:15.920 --> 00:59:21.380
 Spring 的延伸，我们也要

00:59:18.859 --> 00:59:23.900
为添加一些窗帘扩展

00:59:21.380 --> 00:59:25.940
不是官方项目的反应堆

00:59:23.900 --> 00:59:28.250
这是一个将要开发的项目

00:59:25.940 --> 00:59:30.859
主要由我负责

00:59:28.250 --> 00:59:34.339
社区反应堆的例子非常

00:59:30.859 --> 00:59:37.880
有趣，因为反应式API是

00:59:34.339 --> 00:59:41.510
就像Raghava Reactor的api一样

00:59:37.880 --> 00:59:43.819
您无法以用户身份扩展，也无法添加

00:59:41.510 --> 00:59:46.150
观察柏林eric java的方法

00:59:43.819 --> 00:59:49.940
你不能接受反应堆的涌入

00:59:46.150 --> 00:59:52.700
再次在这里窗帘扩展

00:59:49.940 --> 00:59:55.190
效果很好，因为它们允许您

00:59:52.700 --> 00:59:58.700
添加一些扩展到flex或

00:59:55.190 --> 01:00:01.480
可观察而无需修改乔治

00:59:58.700 --> 01:00:06.400
例如，我们可以想象一个最大值

01:00:01.480 --> 01:00:10.700
最大点数法

01:00:06.400 --> 01:00:12.920
当我们有通量或

01:00:10.700 --> 01:00:16.220
例如长整数的观察者

01:00:12.920 --> 01:00:21.369
这就是我们的一个例子

01:00:16.220 --> 01:00:23.660
我们可以在退出时使用一些方法吗

01:00:21.369 --> 01:00:26.089
现有的课程，那是一个很好的

01:00:23.660 --> 01:00:28.700
适用于Java中的反应式api统计信息是

01:00:26.089 --> 01:00:30.860
根本无法扩展

01:00:28.700 --> 01:00:33.010
我们将不断添加一些

01:00:30.860 --> 01:00:36.170
 Spring Framework 上课前的报告

01:00:33.010 --> 01:00:38.450
为此，我们将使用信息

01:00:36.170 --> 01:00:41.300
从插入式系统中，我们可以

01:00:38.450 --> 01:00:45.290
知道变量是否可以为null或

01:00:41.300 --> 01:00:48.530
没有，我们将知道

01:00:45.290 --> 01:00:50.450
如果参数应该是

01:00:48.530 --> 01:00:53.540
 Spring MVC是否需要

01:00:50.450 --> 01:00:55.160
示例，我们将继续改进

01:00:53.540 --> 01:00:57.770
窗帘整合在斯普林伍德那里

01:00:55.160 --> 01:01:00.050
并不是真正的突破点

01:00:57.770 --> 01:01:02.690
等我说的切成一个

01:01:00.050 --> 01:01:05.020
以前有一个削减

01:01:02.690 --> 01:01:08.180
一个带协同例程的预览

01:01:05.020 --> 01:01:10.610
协程允许您编写一个

01:01:08.180 --> 01:01:14.960
不使用回调的同步代码

01:01:10.610 --> 01:01:17.480
例如现在简单的用例

01:01:14.960 --> 01:01:20.480
我个人更喜欢使用反应式API 

01:01:17.480 --> 01:01:23.660
像反应堆这样写

01:01:20.480 --> 01:01:25.550
更强大，但似乎在想

01:01:23.660 --> 01:01:29.900
腐蚀很好，那就是

01:01:25.550 --> 01:01:32.390
 in.net一词，那就是

01:01:29.900 --> 01:01:34.940
可选的，所以不是问题类型

01:01:32.390 --> 01:01:39.110
别名更有趣，允许

01:01:34.940 --> 01:01:42.890
您为值类型编写别名

01:01:39.110 --> 01:01:45.350
而且这种睫毛在

01:01:42.890 --> 01:01:49.510
编译时间，使它成为零成本

01:01:45.350 --> 01:01:52.100
在运行时方面，这也

01:01:49.510 --> 01:01:53.870
继续提高可读性时

01:01:52.100 --> 01:01:56.480
你是很长的仿制药

01:01:53.870 --> 01:01:59.570
你可以用它来编写较短的代码

01:01:56.480 --> 01:02:01.520
是的，我喜欢那种零

01:01:59.570 --> 01:02:04.400
成本抽象，使您能够

01:02:01.520 --> 01:02:06.650
编写更好的代码将有Java 

01:02:04.400 --> 01:02:09.170
 Java 8字节代码生成，因为

01:02:06.650 --> 01:02:12.500
当前包含生成器的六个字节

01:02:09.170 --> 01:02:17.900
即使语言更多，也可以编码

01:02:12.500 --> 01:02:22.070
比Java 8更强大，这意味着

01:02:17.900 --> 01:02:24.860
使用Curtin 1.1，他们将能够使用

01:02:22.070 --> 01:02:27.530
一个lambda不好的合作者，例如

01:02:24.860 --> 01:02:29.810
在字节码中实现

01:02:27.530 --> 01:02:35.180
而不是产生一些匿名

01:02:29.810 --> 01:02:37.120
类沙拉样式代理应该

01:02:35.180 --> 01:02:41.950
没有开放的可能，我们将看到，但是

01:02:37.120 --> 01:02:44.500
那是计划，我们将有

01:02:41.950 --> 01:02:51.070
切入JavaScript更有用

01:02:44.500 --> 01:02:55.560
编译器，最后一点就是我

01:02:51.070 --> 01:02:58.450
看到了一些幻灯片，所以

01:02:55.560 --> 01:03:01.450
柯克兰的家伙似乎在努力工作

01:02:58.450 --> 01:03:04.860
承担责任的本地倡议

01:03:01.450 --> 01:03:09.010
编译代码干净-Nate本机代码

01:03:04.860 --> 01:03:11.230
多亏了LLVM后端，所以

01:03:09.010 --> 01:03:14.350
吠陀经时间编译

01:03:11.230 --> 01:03:17.260
针对轻量级运行时

01:03:14.350 --> 01:03:19.510
我们像这样唱歌的嵌入式物联网

01:03:17.260 --> 01:03:23.200
那可能是通往天气的桥梁

01:03:19.510 --> 01:03:25.660
网络上的一些光阿萨姆邦像家伙

01:03:23.200 --> 01:03:28.480
在LLVM上走到巴萨姆的谎言

01:03:25.660 --> 01:03:31.030
强迫，所以只要你能够

01:03:28.480 --> 01:03:32.920
生成天气代码

01:03:31.030 --> 01:03:36.400
您能够使用的中间代码

01:03:32.920 --> 01:03:37.930
生成一些Web汇编代码，为什么

01:03:36.400 --> 01:03:43.240
不使用它来产生反向

01:03:37.930 --> 01:03:46.000
在网上我们会说这是结束

01:03:43.240 --> 01:03:52.140
演示文稿，如果您有任何问题

01:03:46.000 --> 01:03:52.140
我可以回答谢谢

01:03:59.539 --> 01:04:11.969
对不起，我是G IDE 

01:04:06.479 --> 01:04:13.439
结果是一个eclipse插件说Vince 

01:04:11.969 --> 01:04:16.019
我不确定我认为没有

01:04:13.439 --> 01:04:18.989
确实有用但在GDG ID中

01:04:16.019 --> 01:04:22.289
和Eclipse都可以使用

01:04:18.989 --> 01:04:23.999
用代码写代码，显然

01:04:22.289 --> 01:04:27.229
更好，更好的支持是在IntelliJ中

01:04:23.999 --> 01:04:27.229
 IDE，但这不足为奇

01:04:34.160 --> 01:04:39.310
是的

01:04:35.800 --> 01:04:41.320
是的，它将起作用，因此它将起作用

01:04:39.310 --> 01:04:43.570
 Spring 游套房，因为它基于

01:04:41.320 --> 01:04:53.910
一个剪辑，是的，是的，那个

01:04:43.570 --> 01:04:53.910
会很好的工作，谢谢

01:05:00.100 --> 01:05:02.160
您

