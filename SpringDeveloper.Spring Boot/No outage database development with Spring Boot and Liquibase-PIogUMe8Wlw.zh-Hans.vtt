WEBVTT
Kind: captions
Language: zh-Hans

00:00:09.850 --> 00:00:16.420
这是这个话题，没有停机数据库

00:00:13.810 --> 00:00:19.570
用弹簧靴和液体进行开发

00:00:16.420 --> 00:00:21.580
我的名字叫艾伦·班克斯，休斯是我的名字

00:00:19.570 --> 00:00:25.210
共同主持人是PI V Robert为什么是我

00:00:21.580 --> 00:00:28.390
我们来自高级卫生保健

00:00:25.210 --> 00:00:31.420
在提交时间前后，我和我说话

00:00:28.390 --> 00:00:33.250
老板，你知道他说的话

00:00:31.420 --> 00:00:36.190
应该是关于开展业务

00:00:33.250 --> 00:00:39.370
价值，然后我来了，我对我的讲话

00:00:36.190 --> 00:00:41.530
团队，他们说不，我认为演讲

00:00:39.370 --> 00:00:44.250
应该是关于提供更好的技术

00:00:41.530 --> 00:00:46.780
然后我跟我父亲说，他说

00:00:44.250 --> 00:00:48.190
不，你说的最好是30岁左右

00:00:46.780 --> 00:00:53.070
这些人喝啤酒的分钟

00:00:48.190 --> 00:00:55.300
喝吧，所以今天就开始吧

00:00:53.070 --> 00:00:58.809
我们要去一起绑一些

00:00:55.300 --> 00:01:00.729
几个轮廓概念执行否

00:00:58.809 --> 00:01:03.640
中断部署，其中包括

00:01:00.729 --> 00:01:06.370
潜在破坏性数据库DDL 

00:01:03.640 --> 00:01:08.350
更改我们将要涉及的主题

00:01:06.370 --> 00:01:11.350
在将是蓝绿色和金丝雀

00:01:08.350 --> 00:01:14.140
部署敏捷数据库开发

00:01:11.350 --> 00:01:16.270
概念，我将向您介绍

00:01:14.140 --> 00:01:19.719
称为液体基础的框架

00:01:16.270 --> 00:01:21.670
我们将使用将演示放置床上用品

00:01:19.719 --> 00:01:25.240
液体基础和数据库更改

00:01:21.670 --> 00:01:28.119
在 spring boot 里，我们已经

00:01:25.240 --> 00:01:32.740
为演示神做了我们的牺牲

00:01:28.119 --> 00:01:35.049
希望最后可以进行现场演示

00:01:32.740 --> 00:01:37.329
蓝色/绿色部署中心

00:01:35.049 --> 00:01:38.320
租户，您将有两个截然不同的地方

00:01:37.329 --> 00:01:39.070
您的代码库版本

00:01:38.320 --> 00:01:41.789
基础设施

00:01:39.070 --> 00:01:44.799
他们将在路由器版本的前面

00:01:41.789 --> 00:01:46.179
我们将实时面对客户

00:01:44.799 --> 00:01:48.729
那蓝色和另一个处于休眠状态

00:01:46.179 --> 00:01:50.380
我们将其称为绿色斧头

00:01:48.729 --> 00:01:53.590
是您部署自己的阶段

00:01:50.380 --> 00:01:55.149
下次发布时就温暖而模糊

00:01:53.590 --> 00:01:57.369
签收，您对此很满意

00:01:55.149 --> 00:02:00.159
您指示它重定向到的Rudo 

00:01:57.369 --> 00:02:00.759
交通变成绿色，蓝色变成您的

00:02:00.159 --> 00:02:02.920
休眠的

00:02:00.759 --> 00:02:05.049
待机系统，现在绿色

00:02:02.920 --> 00:02:06.880
直播，因此您可以关注发行版

00:02:05.049 --> 00:02:09.039
用蓝色作为你的舞台

00:02:06.880 --> 00:02:11.800
面向客户的现在绿色环保

00:02:09.039 --> 00:02:13.930
您可以来回切换等等

00:02:11.800 --> 00:02:18.610
它很方便，为您提供了不错的快速体验

00:02:13.930 --> 00:02:20.950
回退金丝雀部署的机制

00:02:18.610 --> 00:02:22.090
在这种情况下，您将了解很多

00:02:20.950 --> 00:02:23.590
具有代码库的实例

00:02:22.090 --> 00:02:25.150
基础设施，没有前线

00:02:23.590 --> 00:02:27.250
一只公鸡，所有系统都运转起来

00:02:25.150 --> 00:02:29.650
并并行运行，而不是

00:02:27.250 --> 00:02:31.510
仅一小部分的完整切割

00:02:29.650 --> 00:02:33.250
的实例已使用

00:02:31.510 --> 00:02:35.200
新代码，然后随着您获得更多

00:02:33.250 --> 00:02:37.239
对新版本的信心以及更多

00:02:35.200 --> 00:02:39.480
实例已升级并获得更多

00:02:37.239 --> 00:02:46.120
直到旧版本的流量

00:02:39.480 --> 00:02:49.120
休眠，不再在那里所以思考

00:02:46.120 --> 00:02:51.790
关于数据库注意事项

00:02:49.120 --> 00:02:53.140
这些技术通常是一个挑战

00:02:51.790 --> 00:02:56.200
特别是当您必须更改

00:02:53.140 --> 00:02:58.269
支持新功能和新功能的架构

00:02:56.200 --> 00:03:01.420
该软件的版本，所以诀窍是

00:02:58.269 --> 00:03:04.030
将数据库不应更改应用于

00:03:01.420 --> 00:03:05.769
支持旧版本和旧版本的架构

00:03:04.030 --> 00:03:09.310
该应用程序的新版本位于

00:03:05.769 --> 00:03:11.110
同时，所以首先我们部署

00:03:09.310 --> 00:03:12.940
金丝雀或绿色建筑，我们检查

00:03:11.110 --> 00:03:14.680
一切都很好，所以你有一个

00:03:12.940 --> 00:03:16.569
回滚点，然后您高兴

00:03:14.680 --> 00:03:19.000
您推出新版本的

00:03:16.569 --> 00:03:21.640
申请，然后当每个人的

00:03:19.000 --> 00:03:23.739
已升级，升级已失败

00:03:21.640 --> 00:03:25.480
您可以走过去并删除

00:03:23.739 --> 00:03:31.209
数据库支持或您知道

00:03:25.480 --> 00:03:36.569
敏捷的旧版本的垫片

00:03:31.209 --> 00:03:39.190
数据库开发概念，而不是

00:03:36.569 --> 00:03:41.769
产生大功能发布

00:03:39.190 --> 00:03:44.290
引入很多风险可能很高

00:03:41.769 --> 00:03:48.900
立刻改变，并且更有可能

00:03:44.290 --> 00:03:52.419
您知道需要部署中断吗

00:03:48.900 --> 00:03:54.760
小型化您的数据库

00:03:52.419 --> 00:03:56.829
他们将发布更频繁的功能

00:03:54.760 --> 00:03:59.530
降低风险，使其更易于管理

00:03:56.829 --> 00:04:02.169
而且因为变化较小

00:03:59.530 --> 00:04:06.160
更易于管理，您可以部署

00:04:02.169 --> 00:04:08.049
他们更有可能没有中断，所以

00:04:06.160 --> 00:04:10.030
开发人员已经习惯了重构

00:04:08.049 --> 00:04:12.489
重构代码，您会感到

00:04:10.030 --> 00:04:15.040
带有代码的气味，我们的数据库可以闻到

00:04:12.489 --> 00:04:16.599
现在也可以进行分解，所以如果

00:04:15.040 --> 00:04:18.250
你以为你需要做一个

00:04:16.599 --> 00:04:21.250
重大更改，尝试将其分解

00:04:18.250 --> 00:04:25.000
分成较小的步骤并完成它们

00:04:21.250 --> 00:04:27.490
较小的较小变化，所以我们来谈谈

00:04:25.000 --> 00:04:29.020
关于一些结构性变化以及我们如何

00:04:27.490 --> 00:04:31.030
会在敏捷数据库中做到这一点

00:04:29.020 --> 00:04:33.880
开发方式，所以我们要重命名

00:04:31.030 --> 00:04:35.110
一列可能我们知道你

00:04:33.880 --> 00:04:36.970
需要这样做来增加

00:04:35.110 --> 00:04:38.650
模式的可读性

00:04:36.970 --> 00:04:40.620
或者我们有一些企业命名

00:04:38.650 --> 00:04:43.960
我们不遵守的约定

00:04:40.620 --> 00:04:47.740
因此，我们将继续介绍

00:04:43.960 --> 00:04:48.550
新列迁移旧数据，然后

00:04:47.740 --> 00:04:50.830
我们将介绍

00:04:48.550 --> 00:04:54.370
同步触发器将保持

00:04:50.830 --> 00:04:58.150
旧数据和新数据同步

00:04:54.370 --> 00:05:00.310
然后在弃用期之后

00:04:58.150 --> 00:05:01.690
可能要过几个小时，可能要过几天

00:05:00.310 --> 00:05:03.760
所有新客户都转移到了

00:05:01.690 --> 00:05:05.170
新模式的新版本，我们可以

00:05:03.760 --> 00:05:09.970
绕回来或掉旧

00:05:05.170 --> 00:05:11.830
列并删除您可能会触发的触发器

00:05:09.970 --> 00:05:15.430
需要将一列从一个表移动到

00:05:11.830 --> 00:05:18.310
另一个你可能会这样做以增加

00:05:15.430 --> 00:05:21.370
归一化增加您的数据

00:05:18.310 --> 00:05:22.570
减少您的数据冗余

00:05:21.370 --> 00:05:25.480
可能是您需要的用例

00:05:22.570 --> 00:05:28.840
去规范化并移除一个共同的关节

00:05:25.480 --> 00:05:31.120
加快代码速度，因此在开始之前

00:05:28.840 --> 00:05:33.160
您需要确定您的插入内容

00:05:31.120 --> 00:05:35.710
您的删除规则，那么什么时候发生

00:05:33.160 --> 00:05:37.750
我将插入表A或从中删除

00:05:35.710 --> 00:05:39.610
表B的业务规则是什么

00:05:37.750 --> 00:05:41.350
我需要传播回来， 

00:05:39.610 --> 00:05:43.510
来，然后你可以继续

00:05:41.350 --> 00:05:46.120
将您的新专栏介绍给新

00:05:43.510 --> 00:05:47.920
表格，您可以通过

00:05:46.120 --> 00:05:50.940
然后介绍保持的触发器

00:05:47.920 --> 00:05:53.530
同步的两个表保留该数据

00:05:50.940 --> 00:05:55.510
适用于旧版本的代码

00:05:53.530 --> 00:05:57.510
以及新版本的代码，然后

00:05:55.510 --> 00:05:59.530
弃用期过后再次

00:05:57.510 --> 00:06:01.360
每个人都在使用新架构

00:05:59.530 --> 00:06:03.610
每个人都在使用新列

00:06:01.360 --> 00:06:05.440
新表，我们可以过来删除

00:06:03.610 --> 00:06:09.130
原始列和相应的

00:06:05.440 --> 00:06:11.500
触发，否则您可能需要采取

00:06:09.130 --> 00:06:13.570
多用途专栏并将其传播到

00:06:11.500 --> 00:06:15.610
几个不同的列，所以您开始

00:06:13.570 --> 00:06:18.010
取消名字，现在你想拥有

00:06:15.610 --> 00:06:21.040
您的数据更加细化并细分

00:06:18.010 --> 00:06:23.680
进入第一个中间和最后一个，或者您有一个

00:06:21.040 --> 00:06:25.030
现在的状态字段已变为

00:06:23.680 --> 00:06:28.570
超载，你需要打破它

00:06:25.030 --> 00:06:30.430
分成几列，因此您将介绍

00:06:28.570 --> 00:06:31.960
数据期间的新列

00:06:30.430 --> 00:06:33.460
这次迁移可能需要

00:06:31.960 --> 00:06:35.920
沿引入一个存储过程

00:06:33.460 --> 00:06:39.390
知道如何分解你的方式

00:06:35.920 --> 00:06:43.000
将其命名为组成部分

00:06:39.390 --> 00:06:44.680
同样，如果有人在您插入

00:06:43.000 --> 00:06:47.290
变成你的名字的中间名和姓氏

00:06:44.680 --> 00:06:49.830
可能需要一个转换程序来

00:06:47.290 --> 00:06:51.960
把它带回旧专栏

00:06:49.830 --> 00:06:55.110
串联的名称，您将

00:06:51.960 --> 00:06:57.870
再次引入触发器，重构您的

00:06:55.110 --> 00:06:59.940
应用程序代码，然后您可以看到一个

00:06:57.870 --> 00:07:02.490
模式类型在

00:06:59.940 --> 00:07:04.050
每个人都起来的弃用期

00:07:02.490 --> 00:07:06.360
在新版本的架构上，您可以

00:07:04.050 --> 00:07:12.300
来掉原始列和

00:07:06.360 --> 00:07:14.580
触发因素使我们吸取了一些教训

00:07:12.300 --> 00:07:18.660
您需要知道很多小的变化

00:07:14.580 --> 00:07:20.820
易于应用，对

00:07:18.660 --> 00:07:21.540
唯一地识别您的每个人

00:07:20.820 --> 00:07:23.970
因素

00:07:21.540 --> 00:07:28.740
这样您就可以看到发生了什么

00:07:23.970 --> 00:07:31.470
谁以及何时使用触发器概述

00:07:28.740 --> 00:07:34.020
用于数据库同步

00:07:31.470 --> 00:07:36.630
可能支持可更新的视图

00:07:34.020 --> 00:07:39.180
不太可能全部用于查看

00:07:36.630 --> 00:07:40.680
加入，所以有一个处理

00:07:39.180 --> 00:07:46.140
我们发现使用触发器的开销

00:07:40.680 --> 00:07:48.150
它更易于管理， 

00:07:46.140 --> 00:07:52.620
然后确保您知道所有这些

00:07:48.150 --> 00:07:55.560
在变更控制之下，所以我们使用一种工具

00:07:52.620 --> 00:07:56.550
叫做液体基础

00:07:55.560 --> 00:08:00.720
脚本语言

00:07:56.550 --> 00:08:02.700
它运行在Java中，我们用它来控制

00:08:00.720 --> 00:08:04.950
该计划的所有修改

00:08:02.700 --> 00:08:07.530
实际上，我们不让

00:08:04.950 --> 00:08:11.160
除非完成数据库更改

00:08:07.530 --> 00:08:12.690
通过液体阵列，它记录了每一个

00:08:11.160 --> 00:08:14.370
对您的数据库进行更改，以便

00:08:12.690 --> 00:08:17.040
没有忘记的更改您有记录

00:08:14.370 --> 00:08:19.280
所有发生的事情，以便您可以

00:08:17.040 --> 00:08:21.600
回头看看，它有一些工具

00:08:19.280 --> 00:08:24.180
生成数据库文档，以便您

00:08:21.600 --> 00:08:27.120
可以看到谁更改了内容以及何时更改

00:08:24.180 --> 00:08:30.440
为什么它使您能够滚动

00:08:27.120 --> 00:08:33.990
退回更改并再次向前滚动

00:08:30.440 --> 00:08:36.120
因此，如果您知道发布的是

00:08:33.990 --> 00:08:39.270
运行不顺利，您可以标记

00:08:36.120 --> 00:08:41.010
指出，当您添加申请

00:08:39.270 --> 00:08:44.940
改变液基能够

00:08:41.010 --> 00:08:50.340
开箱即用地将其还原

00:08:44.940 --> 00:08:52.590
支持很多数据库，您可以

00:08:50.340 --> 00:08:55.560
它是可扩展的，所以如果您碰巧使用

00:08:52.590 --> 00:08:59.190
并非由JDBC驱动的数据库

00:08:55.560 --> 00:09:02.850
支持您可以创建扩展，我们

00:08:59.190 --> 00:09:03.870
用过或我们在预告片中用作以下一种

00:09:02.850 --> 00:09:05.460
我们的数据库

00:09:03.870 --> 00:09:06.960
酒基不支持

00:09:05.460 --> 00:09:08.279
开箱即用

00:09:06.960 --> 00:09:10.980
晚上我能够创造一个

00:09:08.279 --> 00:09:12.990
扩展到液体基础，并允许它

00:09:10.980 --> 00:09:16.620
与netezza交流并进行交流

00:09:12.990 --> 00:09:20.160
喝酒的时候很容易做到

00:09:16.620 --> 00:09:22.920
基于运行，它具有更改列表， 

00:09:20.160 --> 00:09:24.510
您希望它可能适用，所以它

00:09:22.920 --> 00:09:26.790
拍摄什么架构的快照

00:09:24.510 --> 00:09:29.100
现在看起来有什么变化

00:09:26.790 --> 00:09:30.420
已经应用了它扣除

00:09:29.100 --> 00:09:32.520
从您想要的更改

00:09:30.420 --> 00:09:35.160
申请，所以它只是确定Delta 

00:09:32.520 --> 00:09:36.540
您也想应用它

00:09:35.160 --> 00:09:40.500
回顾历史以确保

00:09:36.540 --> 00:09:42.620
您更改的内容仍然有效，因此

00:09:40.500 --> 00:09:45.720
你还没有弄乱你的

00:09:42.620 --> 00:09:47.150
您的代码库中的更改具有

00:09:45.720 --> 00:09:50.610
已经应用于数据库

00:09:47.150 --> 00:09:52.680
每个更改都是原子应用的， 

00:09:50.610 --> 00:09:56.420
它有一种机制来确保

00:09:52.680 --> 00:09:59.220
只能有一个实例

00:09:56.420 --> 00:10:01.080
一次升级数据库，然后

00:09:59.220 --> 00:10:05.279
再次更改，它记录了每次更改

00:10:01.080 --> 00:10:07.529
这样就可以了

00:10:05.279 --> 00:10:10.320
更改日志的形式这些只是

00:10:07.529 --> 00:10:13.350
变更集的集合，然后每个

00:10:10.320 --> 00:10:16.320
我们尝试并尽量少更改的变更集

00:10:13.350 --> 00:10:18.350
在每个变更集中尽可能

00:10:16.320 --> 00:10:21.029
在它里面有个别的变化

00:10:18.350 --> 00:10:23.779
你知道个人重构

00:10:21.029 --> 00:10:26.580
您正在建立自己的建筑

00:10:23.779 --> 00:10:30.300
更改数据库是很好的

00:10:26.580 --> 00:10:32.730
考虑一些小的添加剂变化，以便您

00:10:30.300 --> 00:10:34.170
知道在专栏然后

00:10:32.730 --> 00:10:36.480
索引不添加列

00:10:34.170 --> 00:10:38.850
索引一起，因为您知道是否

00:10:36.480 --> 00:10:41.070
一个失败，另一个失败

00:10:38.850 --> 00:10:44.130
会使您的生活变得更加美好

00:10:41.070 --> 00:10:45.930
简单地改变添加剂就可以了

00:10:44.130 --> 00:10:49.140
有一种您可以编码的标记语言

00:10:45.930 --> 00:10:52.080
在雅知道JSON或XML，这将需要

00:10:49.140 --> 00:10:53.580
标记语言可以检测出

00:10:52.080 --> 00:10:58.050
您已连接到的数据库

00:10:53.580 --> 00:11:01.080
为您创建续集，是的

00:10:58.050 --> 00:11:03.890
我们有一个项目与

00:11:01.080 --> 00:11:06.150
几个数据库，并有一些共同点

00:11:03.890 --> 00:11:08.640
每个表，所以我们可以

00:11:06.150 --> 00:11:10.620
将相同的标记语言应用于两者

00:11:08.640 --> 00:11:12.270
 Oracle和Postgres以及预告片和

00:11:10.620 --> 00:11:16.400
当他们改变跑的时候

00:11:12.270 --> 00:11:18.060
创建供应商特定的续集并

00:11:16.400 --> 00:11:19.950
然后

00:11:18.060 --> 00:11:21.390
你知道是否需要打碎玻璃以防万一

00:11:19.950 --> 00:11:25.020
应急液罐

00:11:21.390 --> 00:11:27.150
自动回滚那些更改

00:11:25.020 --> 00:11:28.800
并且如果您已经使用了标记

00:11:27.150 --> 00:11:30.270
语言，因为它创造了续集

00:11:28.800 --> 00:11:32.010
应用它知道如何进行的更改

00:11:30.270 --> 00:11:38.010
创建续集以回滚为

00:11:32.010 --> 00:11:40.980
是的，所以这些只是示例

00:11:38.010 --> 00:11:43.860
一些DDL更改是

00:11:40.980 --> 00:11:45.690
能够为您提供标记

00:11:43.860 --> 00:11:49.200
使用，所以您知道创建表

00:11:45.690 --> 00:11:52.830
程序色度键有能力

00:11:49.200 --> 00:11:54.690
提取出您知道的列

00:11:52.830 --> 00:11:57.540
新的查找表并将其放在索引中

00:11:54.690 --> 00:11:59.520
外键，我们用它来管理所有

00:11:57.540 --> 00:12:04.380
我们个人存储程序或视图，以及

00:11:59.520 --> 00:12:08.790
触发并具有加载能力

00:12:04.380 --> 00:12:12.600
静态数据参考表

00:12:08.790 --> 00:12:15.090
知道对CSV文件的引用，我们也

00:12:12.600 --> 00:12:18.150
也用它来管理我们的测试数据

00:12:15.090 --> 00:12:22.980
这样您就可以触发某些文件

00:12:18.150 --> 00:12:24.450
在某些环境中加载，该怎么办

00:12:22.980 --> 00:12:27.060
我们将液体基质嵌入其中

00:12:24.450 --> 00:12:29.750
春天的靴子，所以你去那是

00:12:27.060 --> 00:12:33.150
您需要的所有代码

00:12:29.750 --> 00:12:35.580
好吧，你还有更多

00:12:33.150 --> 00:12:37.860
需要提供一个依赖，所以春天

00:12:35.580 --> 00:12:40.290
开机自动感应到液体

00:12:37.860 --> 00:12:43.890
基于类的路径，并会看起来

00:12:40.290 --> 00:12:46.410
为您的来源中设置的第一条链

00:12:43.890 --> 00:12:49.800
主要资源DB更改日志主数据

00:12:46.410 --> 00:12:53.250
 yanil文件，然后它开始

00:12:49.800 --> 00:12:55.200
当然，您需要知道

00:12:53.250 --> 00:12:59.360
有一个要迁移的数据库，所以您将

00:12:55.200 --> 00:12:59.360
只提供您的数据库信息

00:12:59.540 --> 00:13:06.570
所以现在我要交给它

00:13:02.880 --> 00:13:09.860
超过五杆杆，谁将带走

00:13:06.570 --> 00:13:09.860
我们通过现场演示

00:13:13.889 --> 00:13:19.269
谢谢艾伦

00:13:16.649 --> 00:13:20.980
现在有了丰富的信息，我们

00:13:19.269 --> 00:13:24.399
关于敏捷数据库

00:13:20.980 --> 00:13:27.430
开发模式让我们启动这个

00:13:24.399 --> 00:13:29.529
具有两个spring boot节点的演示

00:13:27.430 --> 00:13:33.279
共享一个公共数据库和我们的负载

00:13:29.529 --> 00:13:34.690
使用nginx平衡主要

00:13:33.279 --> 00:13:36.910
我们的应用程序功能

00:13:34.690 --> 00:13:38.589
会看到它捕获的非常小

00:13:36.910 --> 00:13:40.810
最少使用用户信息，例如

00:13:38.589 --> 00:13:43.690
名字姓氏和电子邮件地址

00:13:40.810 --> 00:13:46.120
用户的演示目标是

00:13:43.690 --> 00:13:48.279
将电子邮件地址列从

00:13:46.120 --> 00:13:50.319
将用户信息表转换为其表

00:13:48.279 --> 00:13:53.019
自己的，这样我们就可以增强

00:13:50.319 --> 00:13:57.009
捕获多个应用程序

00:13:53.019 --> 00:14:00.040
用户的电子邮件地址有三个

00:13:57.009 --> 00:14:01.839
本演示中的重要阶段

00:14:00.040 --> 00:14:03.970
完成我们在这里试图做的事情

00:14:01.839 --> 00:14:07.779
所以首先是部署

00:14:03.970 --> 00:14:10.209
版本1.1，此部署包括

00:14:07.779 --> 00:14:12.579
初始表的创建和

00:14:10.209 --> 00:14:14.829
与之相关的应用程序代码

00:14:12.579 --> 00:14:17.500
第二个是部署版本

00:14:14.829 --> 00:14:19.569
代码的1.1，这将是

00:14:17.500 --> 00:14:22.779
部署到其中一个节点上

00:14:19.569 --> 00:14:25.630
部署包括创建新车

00:14:22.779 --> 00:14:27.069
变化与两者有关

00:14:25.630 --> 00:14:29.439
创建将容纳的新表

00:14:27.069 --> 00:14:31.660
多个电子邮件地址的更改

00:14:29.439 --> 00:14:33.670
与从

00:14:31.660 --> 00:14:36.430
旧的电子邮件地址列改为新的

00:14:33.670 --> 00:14:39.279
表格和触发器， 

00:14:36.430 --> 00:14:40.990
保持数据同步，以便任何时候

00:14:39.279 --> 00:14:43.149
任何旧的应用程序奇迹

00:14:40.990 --> 00:14:45.069
应用程序不断插入核心数据

00:14:43.149 --> 00:14:47.230
进入旧列，此触发器将

00:14:45.069 --> 00:14:50.439
使新车的数据保持同步

00:14:47.230 --> 00:14:52.360
新的应用程序开始阅读

00:14:50.439 --> 00:14:55.380
在这一阶段，我们将注意到该版本

00:14:52.360 --> 00:14:58.269
 1.0和1.1版的应用程序

00:14:55.380 --> 00:15:03.430
共存并并行运行

00:14:58.269 --> 00:15:05.740
一次创建新架构，并作为最后一步

00:15:03.430 --> 00:15:08.290
我们知道所有节点都已经

00:15:05.740 --> 00:15:10.149
成功升级到1.1版

00:15:08.290 --> 00:15:14.079
现在可以放下多余的

00:15:10.149 --> 00:15:15.730
列和触发器，以便

00:15:14.079 --> 00:15:19.949
我们将从的演示目标开始

00:15:15.730 --> 00:15:19.949
脚本执行

00:15:23.710 --> 00:15:28.430
首先针对码头工人

00:15:26.120 --> 00:15:30.650
容器，我们将安装Postgres 

00:15:28.430 --> 00:15:34.100
数据库，这是一个要执行的命令

00:15:30.650 --> 00:15:39.620
然后我们将安装版本

00:15:34.100 --> 00:15:44.930
 1.0在节点一上，然后它们将安装

00:15:39.620 --> 00:15:48.440
 1.0版还将安装一个节点2 

00:15:44.930 --> 00:15:50.570
 nginx在这里，我们快速浏览一下

00:15:48.440 --> 00:15:52.280
可以看到所有这些容器都是

00:15:50.570 --> 00:15:54.800
成功地对抗

00:15:52.280 --> 00:15:57.530
泊坞窗，现在让我们快速看一下

00:15:54.800 --> 00:16:06.650
在安装中看到什么液体

00:15:57.530 --> 00:16:12.260
被执行了，我要突出显示

00:16:06.650 --> 00:16:13.970
部分，以便更具可读性，所以

00:16:12.260 --> 00:16:15.860
你会看到当液体基地

00:16:13.970 --> 00:16:17.930
开始执行它获取了锁

00:16:15.860 --> 00:16:20.690
对数据库进行验证

00:16:17.930 --> 00:16:23.210
保持交易是

00:16:20.690 --> 00:16:24.860
变化的本质是原子的，然后保持原样

00:16:23.210 --> 00:16:26.870
第一次针对

00:16:24.860 --> 00:16:27.440
数据库模式它创建了一个表

00:16:26.870 --> 00:16:30.050
叫

00:16:27.440 --> 00:16:31.760
数据库更改锁定此表的位置

00:16:30.050 --> 00:16:34.040
关于所有的历史信息

00:16:31.760 --> 00:16:35.990
通过液体执行的变更集

00:16:34.040 --> 00:16:38.720
记录的基础，所以我们可以参考

00:16:35.990 --> 00:16:40.430
这张桌子随时查看得到了什么

00:16:38.720 --> 00:16:42.770
执行时执行的是谁

00:16:40.430 --> 00:16:44.660
执行它，然后酒基地开始

00:16:42.770 --> 00:16:46.550
首先执行更改

00:16:44.660 --> 00:16:48.590
变更集正在创造

00:16:46.550 --> 00:16:51.080
用户信息表，然后

00:16:48.590 --> 00:16:52.640
创建序列，然后添加

00:16:51.080 --> 00:16:54.020
主键，以便进行其他任何更改

00:16:52.640 --> 00:16:55.940
在更改中指定的

00:16:54.020 --> 00:16:57.530
日志将自动执行并

00:16:55.940 --> 00:16:59.750
然后终于成功了

00:16:57.530 --> 00:17:04.640
完成所有更改日志，它将

00:16:59.750 --> 00:17:07.670
释放对数据库的锁定，确定

00:17:04.640 --> 00:17:10.610
好的，这里的应用程序

00:17:07.670 --> 00:17:14.030
负载平衡，所以我们有版本1.0 

00:17:10.610 --> 00:17:16.390
在节点1上运行，然后当我

00:17:14.030 --> 00:17:16.390
刷新

00:17:26.540 --> 00:17:33.370
好的，所以我们在注释2上已经洗了1.1 

00:17:29.060 --> 00:17:33.370
也将在此处进行快速数据输入

00:17:55.080 --> 00:17:59.029
否否网络似乎有点慢

00:18:02.680 --> 00:18:08.620
好吧，你去那里，谢谢你

00:18:04.300 --> 00:18:11.140
现在成功了，我们将继续前进， 

00:18:08.620 --> 00:18:13.230
针对其中一种安装版本1.1 

00:18:11.140 --> 00:18:15.820
注意，这次我们要注意一个

00:18:13.230 --> 00:18:20.080
所以这里我们执行的是1.1版

00:18:15.820 --> 00:18:25.090
针对节点1，我要给它一个

00:18:20.080 --> 00:18:27.670
马上启动，所以在这里我们看到

00:18:25.090 --> 00:18:30.330
该版本1.0仍然是

00:18:27.670 --> 00:18:30.330
在节点2上

00:18:52.270 --> 00:18:59.470
好的，版本1.1正在节点上运行

00:18:55.120 --> 00:19:06.100
 1，因此，如果我们快速浏览一下日志

00:18:59.470 --> 00:19:11.500
从版本1.1执行中我们可以看到

00:19:06.100 --> 00:19:13.300
当卢卡基地执行时， 

00:19:11.500 --> 00:19:16.150
像以前一样获得了锁，并且

00:19:13.300 --> 00:19:18.190
然后它开始创建新表

00:19:16.150 --> 00:19:20.740
用于捕获多个电子邮件地址

00:19:18.190 --> 00:19:22.660
它添加了必要的主键

00:19:20.740 --> 00:19:24.820
它添加了一些自定义续集，所以这些

00:19:22.660 --> 00:19:28.210
是用于创建

00:19:24.820 --> 00:19:29.770
触发自定义续集触发，然后

00:19:28.210 --> 00:19:31.450
它取消了对

00:19:29.770 --> 00:19:34.900
主列，因为它可以是

00:19:31.450 --> 00:19:37.330
现在可以为null，但此版本和

00:19:34.900 --> 00:19:38.950
然后您可以看到它已经创建

00:19:37.330 --> 00:19:42.309
其他四个外国约束条件和

00:19:38.950 --> 00:19:46.679
现在，如果我们启动

00:19:42.309 --> 00:19:46.679
应用程序的1.0版

00:19:56.060 --> 00:20:02.260
所以清洗1.0仍然在节点1上

00:19:59.090 --> 00:20:02.260
我们将尝试在此处输入

00:20:23.040 --> 00:20:26.820
因此，我们尝试再添加一封电子邮件

00:20:24.990 --> 00:20:28.620
地址，但如果您看到它，它将永远不会

00:20:26.820 --> 00:20:32.210
无法输入内容，因为此版本

00:20:28.620 --> 00:20:32.210
该应用程序不支持

00:20:37.669 --> 00:20:40.880
对于那个很抱歉

00:20:44.490 --> 00:20:47.940
我认为因为这是文字输入

00:20:46.290 --> 00:20:55.050
认为它是自动输入的，但是

00:20:47.940 --> 00:21:01.380
通常不允许这样做，如果我

00:20:55.050 --> 00:21:04.040
发布版本-对不起1.1版，所以

00:21:01.380 --> 00:21:04.040
这里我们有

00:21:24.630 --> 00:21:30.440
认为这有问题

00:21:26.370 --> 00:21:30.440
洗，因为这不是海洋

00:21:40.660 --> 00:21:44.260
我认为我们的演示有问题

00:21:43.060 --> 00:21:47.610
出了点问题我很抱歉

00:21:44.260 --> 00:21:47.610
是的

00:21:56.310 --> 00:22:00.650
也许我们的牺牲不是很好

00:21:58.440 --> 00:22:00.650
足够

00:22:07.430 --> 00:22:11.710
好吧，我们可以看到，尽管我们

00:22:09.800 --> 00:22:13.760
在1.1版的

00:22:11.710 --> 00:22:16.250
应用我们所做的输入

00:22:13.760 --> 00:22:17.330
相对于1.0版，它仍然显示

00:22:16.250 --> 00:22:22.910
很好

00:22:17.330 --> 00:22:25.970
最后我们将升级版本

00:22:22.910 --> 00:22:29.990
还将节点2升级到节点1.1 

00:22:25.970 --> 00:22:31.370
 1.1版，因此，如果您在此处注意到我们，可以

00:22:29.990 --> 00:22:33.620
通过额外的液体基础

00:22:31.370 --> 00:22:36.920
参数在这里，所以现在我们只是

00:22:33.620 --> 00:22:38.660
与节点1和节点2一起运行

00:22:36.920 --> 00:22:41.180
最后运行，所以我知道版本

00:22:38.660 --> 00:22:43.190
 1.2已通过验证并成功

00:22:41.180 --> 00:22:44.960
将此额外参数传递给lipeh 

00:22:43.190 --> 00:22:48.170
我可以告诉代码库执行

00:22:44.960 --> 00:22:50.630
可以绘制的额外脚本

00:22:48.170 --> 00:22:52.760
向前并放下旧列和

00:22:50.630 --> 00:22:55.630
旧触发器，让我们快速看一下

00:22:52.760 --> 00:22:55.630
在日志上

00:23:40.630 --> 00:23:45.550
这是变更日志，因为

00:23:43.150 --> 00:23:46.870
要求它清理它开始

00:23:45.550 --> 00:23:49.120
执行与

00:23:46.870 --> 00:23:50.500
清理和得到的自定义序列

00:23:49.120 --> 00:23:53.230
被处决或抢劫

00:23:50.500 --> 00:23:55.060
触发，最终执行也

00:23:53.230 --> 00:23:56.620
删除旧的主要电子邮件地址

00:23:55.060 --> 00:23:59.100
用户信息表中的

00:23:56.620 --> 00:23:59.100
不再需要

00:24:08.710 --> 00:24:15.389
好的，这是现在的节目

00:24:11.080 --> 00:24:15.389
 1.1不需执行

00:24:28.250 --> 00:24:31.669
好吧，我想我们已经没有了

00:24:30.230 --> 00:24:33.799
验证这就是这样

00:24:31.669 --> 00:24:36.789
好的，我们可以看到1.1版的节点1 

00:24:33.799 --> 00:24:36.789
这就是负载平衡

00:25:00.640 --> 00:25:05.650
好了，他们再也不能松动了

00:25:02.290 --> 00:25:18.010
太谢谢你了谢谢

00:25:05.650 --> 00:25:21.070
浮肿好吧，所以显然是的，我们

00:25:18.010 --> 00:25:24.429
不足以服务我们的演示之神

00:25:21.070 --> 00:25:27.670
但我认为我们已经完成了大部分

00:25:24.429 --> 00:25:28.929
所以我包括了一些脚注

00:25:27.670 --> 00:25:31.360
关于Bluegreen的一些很好的信息

00:25:28.929 --> 00:25:34.059
 Canary中的部署释放链接

00:25:31.360 --> 00:25:35.950
液体基础上有一本很棒的书

00:25:34.059 --> 00:25:38.530
老歌，但又叫重构

00:25:35.950 --> 00:25:40.419
数据库，我已经结冰了

00:25:38.530 --> 00:25:43.720
在那里，你可以去看那个

00:25:40.419 --> 00:25:47.890
有很多很好的敏捷配方

00:25:43.720 --> 00:25:50.380
保理数据库，并且

00:25:47.890 --> 00:25:54.850
该演示的github已经

00:25:50.380 --> 00:25:56.590
完美地工作到现在

00:25:54.850 --> 00:26:01.030
非常感谢您参加

00:25:56.590 --> 00:26:04.500
会议我们来自高级水墨和是

00:26:01.030 --> 00:26:08.669
你知道我们正在招聘，所以给我们发一条tweet 

00:26:04.500 --> 00:26:08.669
非常感谢您的宝贵时间

00:26:17.250 --> 00:26:19.310
您

