WEBVTT
Kind: captions
Language: zh-Hans

00:00:13.590 --> 00:00:18.000
嗨，本周的春季粉丝

00:00:16.200 --> 00:00:19.860
我们将要介绍的 spring 技巧 

00:00:18.000 --> 00:00:22.020
看一下如何揭开一些神秘的面纱

00:00:19.860 --> 00:00:24.330
感知的魔法和典型的 Spring 

00:00:22.020 --> 00:00:26.220
当我说话时启动应用程序

00:00:24.330 --> 00:00:28.590
想知道其中一些应用程序

00:00:26.220 --> 00:00:30.990
我特别在 Spring Cloud 世界中建造

00:00:28.590 --> 00:00:33.570
单个注解在

00:00:30.990 --> 00:00:36.150
整个功能弹幕

00:00:33.570 --> 00:00:38.520
其实现可能不是

00:00:36.150 --> 00:00:40.620
直接连接到注解

00:00:38.520 --> 00:00:44.870
我想做的就是探索

00:00:40.620 --> 00:00:46.980
一点点特别是 spring boot 

00:00:44.870 --> 00:00:49.020
为我们和您配置什么

00:00:46.980 --> 00:00:50.220
可以做些拉回面纱和

00:00:49.020 --> 00:00:51.719
了解发生了什么事

00:00:50.220 --> 00:00:53.190
当您看到其中一些背景时

00:00:51.719 --> 00:00:55.020
之所以发生，是因为

00:00:53.190 --> 00:00:57.090
 Spring 只是配置

00:00:55.020 --> 00:00:58.860
在应用程序上下文中

00:00:57.090 --> 00:01:01.290
配置容器很大

00:00:58.860 --> 00:01:03.180
一袋beans和那 Spring 的一切

00:01:01.290 --> 00:01:04.979
要做的仅仅是管理这些bean 

00:01:03.180 --> 00:01:06.869
这些对象，让我们继续前进， 

00:01:04.979 --> 00:01:08.880
在 Spring 树立一个典型的例子

00:01:06.869 --> 00:01:10.729
云世界的配置服务器，所以

00:01:08.880 --> 00:01:13.380
我要建立一个配置服务

00:01:10.729 --> 00:01:15.390
建立一个配置服务器，我已经上网了

00:01:13.380 --> 00:01:18.690
支持那里，我不需要准备， 

00:01:15.390 --> 00:01:21.780
现在确实生成了此配置

00:01:18.690 --> 00:01:27.119
服务让我在这里再次尝试

00:01:21.780 --> 00:01:30.209
此配置服务是Springwood 

00:01:27.119 --> 00:01:31.740
应用程序，它将照看

00:01:30.209 --> 00:01:33.599
充满配置的目录

00:01:31.740 --> 00:01:39.959
我曾经为我的例子

00:01:33.599 --> 00:01:42.450
这是这个git存储库，我将

00:01:39.959 --> 00:01:49.380
将其克隆到我的目录中

00:01:42.450 --> 00:01:56.840
桌面配置和我的Springwood 

00:01:49.380 --> 00:02:00.660
我会说 Spring 的申请

00:01:56.840 --> 00:02:06.239
应用程序点名称等于config- 

00:02:00.660 --> 00:02:08.520
服务，我会告诉它在哪里可以找到

00:02:06.239 --> 00:02:09.840
配置是目录

00:02:08.520 --> 00:02:16.260
我们刚刚克隆了 Spring 的云

00:02:09.840 --> 00:02:21.300
配置服务器获取获取点uri等于

00:02:16.260 --> 00:02:26.530
家用桌面配置，最后我将

00:02:21.300 --> 00:02:28.030
告诉它现在立即运行导入8888 

00:02:26.530 --> 00:02:31.480
为了使所有效果生效，我需要

00:02:28.030 --> 00:02:32.830
对我说将配置服务器，然后我

00:02:31.480 --> 00:02:36.100
可以运行它，我只需点击命令我们

00:02:32.830 --> 00:02:38.709
控制我们，而是旋转一个

00:02:36.100 --> 00:02:40.930
我的IDE中的主轴ta实例和

00:02:38.709 --> 00:02:42.550
几秒钟之内我就会

00:02:40.930 --> 00:02:47.350
配置服务器，我可以确认

00:02:42.550 --> 00:02:49.030
通过访问本地主机8080 8:00 

00:02:47.350 --> 00:02:51.670
我没有为这样的预订

00:02:49.030 --> 00:02:55.300
默认，所以您可以看到我已经构建了REST 

00:02:51.670 --> 00:02:58.120
 API是斧头，是保姆，你知道

00:02:55.300 --> 00:03:00.519
调解对这些配置的访问

00:02:58.120 --> 00:03:05.350
文件，它基于

00:03:00.519 --> 00:03:06.550
此注释和指向的指针

00:03:05.350 --> 00:03:09.130
应该在其中找到目录

00:03:06.550 --> 00:03:12.069
配置，所以我可以知道吗

00:03:09.130 --> 00:03:14.440
了解这是一个抱怨

00:03:12.069 --> 00:03:15.970
间接的有点不容易

00:03:14.440 --> 00:03:17.080
了解发生了什么，所以让我们

00:03:15.970 --> 00:03:19.209
继续花一点时间

00:03:17.080 --> 00:03:21.670
首先看一下 spring boot 

00:03:19.209 --> 00:03:24.340
Spring 自动配置机构

00:03:21.670 --> 00:03:28.510
引导启动，它看起来像在课堂上

00:03:24.340 --> 00:03:34.840
称为Spring 点的文本文件的路径

00:03:28.510 --> 00:03:36.790
工厂在其中找到此文本文件

00:03:34.840 --> 00:03:38.829
各种罐子，特别是 Spring 

00:03:36.790 --> 00:03:40.600
启动它会在 Spring 找到一个文本文件

00:03:38.829 --> 00:03:43.030
把自动配置目录或罐子

00:03:40.600 --> 00:03:45.100
而不是在meta info文件夹里面

00:03:43.030 --> 00:03:47.590
那个罐子，所以当它找到那个罐子

00:03:45.100 --> 00:03:50.489
然后找到这是一个服务加载器

00:03:47.590 --> 00:03:53.200
 Spring 工厂就这样了

00:03:50.489 --> 00:03:54.820
名称和属性映射到Java 

00:03:53.200 --> 00:03:56.950
配置类和不同

00:03:54.820 --> 00:03:59.890
 Spring 的部分使用不同，你知道

00:03:56.950 --> 00:04:02.170
确定要加载哪些类的键

00:03:59.890 --> 00:04:03.730
 spring boot 特别在乎

00:04:02.170 --> 00:04:05.769
一个说org Spring Framework的人

00:04:03.730 --> 00:04:07.870
想哦配置启用自动

00:04:05.769 --> 00:04:09.640
Spring 启动启动时的配置

00:04:07.870 --> 00:04:11.709
它尝试运行每个

00:04:09.640 --> 00:04:13.299
这些Java配置类

00:04:11.709 --> 00:04:15.010
他们在那里看到，你可以看到

00:04:13.299 --> 00:04:16.660
有很多权利，有汽车

00:04:15.010 --> 00:04:18.370
在此处配置Couchbase和

00:04:16.660 --> 00:04:20.859
 Cassandra和弹性搜索以及MongoDB 

00:04:18.370 --> 00:04:24.160
和neo4j以及WebSockets和超媒体

00:04:20.859 --> 00:04:27.310
和JMS和JTA以及jane di和Davies 

00:04:24.160 --> 00:04:28.840
移民和税收RS与安全以及我

00:04:27.310 --> 00:04:31.360
就是说一切都对

00:04:28.840 --> 00:04:33.039
不同的事物起初可能是

00:04:31.360 --> 00:04:34.479
有点反感，我们不想全部

00:04:33.039 --> 00:04:36.340
如果我们没有这些就可以运行

00:04:34.479 --> 00:04:38.790
图书馆对班上人的支持

00:04:36.340 --> 00:04:41.460
例如，但 Spring 会尝试

00:04:38.790 --> 00:04:42.840
在商场里，所以有点了解

00:04:41.460 --> 00:04:45.750
发生什么事让我们看一下

00:04:42.840 --> 00:04:47.160
只是一个随机的东西好吗

00:04:45.750 --> 00:04:49.110
在这种情况下知道自动配置

00:04:47.160 --> 00:04:51.780
或自动配置队列中的兔子

00:04:49.110 --> 00:04:53.640
这只是一个Spring Java配置

00:04:51.780 --> 00:04:54.660
类，如果您了解Springs Java 

00:04:53.640 --> 00:04:57.150
你知道的配置

00:04:54.660 --> 00:04:58.410
配置类只是Java 

00:04:57.150 --> 00:05:01.500
可以产生的配置类

00:04:58.410 --> 00:05:03.750
对象和对象产生

00:05:01.500 --> 00:05:06.120
从bean提供者方法B方法

00:05:03.750 --> 00:05:07.950
被注释但在这个

00:05:06.120 --> 00:05:10.020
配置类有一些额外的

00:05:07.950 --> 00:05:12.360
您可能无法识别的注释

00:05:10.020 --> 00:05:13.980
是这里的条件注释

00:05:12.360 --> 00:05:17.790
引入了条件注释

00:05:13.980 --> 00:05:20.100
在春季4，那里是什么

00:05:17.790 --> 00:05:21.630
动力 spring boot 就在那里

00:05:20.100 --> 00:05:23.160
 spring boot 之一

00:05:21.630 --> 00:05:25.530
可能它允许Spring 

00:05:23.160 --> 00:05:27.540
有条件地激活不同的对象

00:05:25.530 --> 00:05:29.550
根据某些测试，我们已经做到了

00:05:27.540 --> 00:05:31.950
在我们获得类似的支持之前

00:05:29.550 --> 00:05:35.850
你知道这个的支持

00:05:31.950 --> 00:05:37.350
与个人资料一起使用，因此过去您

00:05:35.850 --> 00:05:40.080
可以使用Spring 轮廓来

00:05:37.350 --> 00:05:41.730
有条件地激活某些确定的

00:05:40.080 --> 00:05:43.590
对象图的一部分，但是

00:05:41.730 --> 00:05:46.050
限于存在或不存在

00:05:43.590 --> 00:05:48.000
该轮廓在春季4中的存在

00:05:46.050 --> 00:05:49.380
我们已经使泛型条件

00:05:48.000 --> 00:05:51.540
机制，现在您可以提供任何

00:05:49.380 --> 00:05:53.730
任意连接条件

00:05:51.540 --> 00:05:55.170
有条件地激活光束，所以在这里我们

00:05:53.730 --> 00:05:58.230
有一个条件

00:05:55.170 --> 00:05:59.910
说创建此配置类，但

00:05:58.230 --> 00:06:02.070
只要那种叫兔子

00:05:59.910 --> 00:06:04.170
模板类在类路径上， 

00:06:02.070 --> 00:06:06.450
类似地创建此配置

00:06:04.170 --> 00:06:08.640
班级只要通道鸭

00:06:06.450 --> 00:06:11.670
班级在您可以看到的班级路径上

00:06:08.640 --> 00:06:13.230
现在在我的IDE中读取

00:06:11.670 --> 00:06:15.780
这些类型不在类路径上

00:06:13.230 --> 00:06:17.400
因此，当Springwood启动时， 

00:06:15.780 --> 00:06:19.020
这将是惰性的，不会，不会得到

00:06:17.400 --> 00:06:20.850
完全被激活

00:06:19.020 --> 00:06:23.730
评估，因此此配置为

00:06:20.850 --> 00:06:25.820
很好，因为基本上没有

00:06:23.730 --> 00:06:29.760
要出席我们要去的地方

00:06:25.820 --> 00:06:35.960
 Maven构建在这里我们可以添加

00:06:29.760 --> 00:06:38.250
 spring boot 启动器示例AMQP和

00:06:35.960 --> 00:06:41.280
当工艺路线只是其中的一部分

00:06:38.250 --> 00:06:43.280
这些类型现在可用

00:06:41.280 --> 00:06:46.230
课程将被激活， 

00:06:43.280 --> 00:06:48.360
然后 Spring 将尝试并评估每个

00:06:46.230 --> 00:06:49.590
在这种情况下很好的个人布纳

00:06:48.360 --> 00:06:51.900
将创建一个连接工厂

00:06:49.590 --> 00:06:52.620
与rabbitmq交谈，这是客户端

00:06:51.900 --> 00:06:54.210
中间件

00:06:52.620 --> 00:06:56.160
我们可以用来跟拉比说话

00:06:54.210 --> 00:06:57.750
例如它会哭泣并尝试

00:06:56.160 --> 00:06:59.550
为我们创造那种存在，但这仅仅是

00:06:57.750 --> 00:07:02.699
如果还没有

00:06:59.550 --> 00:07:04.889
属于类型连接工厂

00:07:02.699 --> 00:07:06.870
正确的地方，所以这是一个

00:07:04.889 --> 00:07:09.060
 Spring Framework瞄准Coupee兔子

00:07:06.870 --> 00:07:11.040
兔子连接连接工厂如果

00:07:09.060 --> 00:07:12.840
您在其他地方定义了一个bean 

00:07:11.040 --> 00:07:20.550
在您自己的Java配置中

00:07:12.840 --> 00:07:23.280
例子在这里，你知道我会离开

00:07:20.550 --> 00:07:26.370
对你来说实际上很重要的事情

00:07:23.280 --> 00:07:29.430
免费为您做运动，但我说

00:07:26.370 --> 00:07:35.370
假设我们已经定义了我的习惯

00:07:29.430 --> 00:07:37.590
兔子MQ连接工厂假设我们

00:07:35.370 --> 00:07:40.740
在光束上已经定义了

00:07:37.590 --> 00:07:42.090
优先Spring 将忽略此光束

00:07:40.740 --> 00:07:44.699
在这个配置中

00:07:42.090 --> 00:07:46.320
一般上课，这样我们就可以

00:07:44.699 --> 00:07:48.780
覆盖对象本身，我们将能够

00:07:46.320 --> 00:07:51.030
改变一些功能

00:07:48.780 --> 00:07:53.460
习惯于连接到已连接到

00:07:51.030 --> 00:07:55.530
 RabbitMQ，所以您知道我们添加了折叠

00:07:53.460 --> 00:07:58.849
 Spring ，我们要用rabbitmq发出信号

00:07:55.530 --> 00:08:02.099
通过添加Spring 启动启动器

00:07:58.849 --> 00:08:02.970
 mqp在classpathSpring 上的支持

00:08:02.099 --> 00:08:05.789
启动启动的mqp 

00:08:02.970 --> 00:08:07.710
你知道大部分只是带来其他

00:08:05.789 --> 00:08:10.289
将这些入门依赖库存储在

00:08:07.710 --> 00:08:13.470
春季引导很少有任何java 

00:08:10.289 --> 00:08:15.599
他们里面的代码几乎从来没有

00:08:13.470 --> 00:08:17.520
主要功能是简单地管理

00:08:15.599 --> 00:08:19.289
其他图书馆为您带来

00:08:17.520 --> 00:08:21.389
所以在这里我们引入了基本的 Spring 

00:08:19.289 --> 00:08:23.130
启动启动程序Rabbit队列类型和

00:08:21.389 --> 00:08:25.380
 Spring 的消息自动

00:08:23.130 --> 00:08:27.990
此类的配置代码

00:08:25.380 --> 00:08:29.900
特别生活在一个罐子的 spring boot 中

00:08:27.990 --> 00:08:32.010
自动配置，所以你知道

00:08:29.900 --> 00:08:33.510
数十种不同的汽车

00:08:32.010 --> 00:08:36.719
一个 spring boot 中的配置

00:08:33.510 --> 00:08:39.089
主罐和不同的组合

00:08:36.719 --> 00:08:40.740
库激活不同的自动

00:08:39.089 --> 00:08:43.349
一个主Spring 中的配置

00:08:40.740 --> 00:08:45.600
靴子，所以我们在这里用了Spring 

00:08:43.349 --> 00:08:47.459
启动启动器和Coupee点亮或

00:08:45.600 --> 00:08:49.050
开启或激活

00:08:47.459 --> 00:08:50.790
 rabbitmq auto中的功能

00:08:49.050 --> 00:08:52.770
配置并不是说你

00:08:50.790 --> 00:08:54.779
你不知道明确引入

00:08:52.770 --> 00:08:56.910
 Spring Boot Starter，直接竞争

00:08:54.779 --> 00:08:58.470
或更确切地说是spring的依赖

00:08:56.910 --> 00:09:00.600
靴子直接启动了mqp，因此您可以

00:08:58.470 --> 00:09:02.880
将这三个库带入您的

00:09:00.600 --> 00:09:05.220
直接编写代码，而不是使用spring 

00:09:02.880 --> 00:09:06.360
启动启动器AMQP，您将拥有

00:09:05.220 --> 00:09:07.829
同样的效果

00:09:06.360 --> 00:09:09.690
对，你有完全一样的效果

00:09:07.829 --> 00:09:12.089
好像你用过Spring 助推器

00:09:09.690 --> 00:09:13.550
可能要当心，如果你是

00:09:12.089 --> 00:09:15.839
不使用启动器，但有些事情是

00:09:13.550 --> 00:09:17.430
可用，有些事情变得活跃

00:09:15.839 --> 00:09:19.920
可能是因为您有图书馆

00:09:17.430 --> 00:09:21.450
激活一定的收益

00:09:19.920 --> 00:09:22.070
将我们带入下一个世界

00:09:21.450 --> 00:09:24.450
题

00:09:22.070 --> 00:09:26.250
我们知道 spring boot 有这些

00:09:24.450 --> 00:09:30.440
条件，这些条件可以

00:09:26.250 --> 00:09:32.850
用于有条件地激活它们

00:09:30.440 --> 00:09:34.880
北极筏的不同部分

00:09:32.850 --> 00:09:37.440
知道这些条件是

00:09:34.880 --> 00:09:39.720
该行为的专业化

00:09:37.440 --> 00:09:41.940
 Spring 4中的条件注释和

00:09:39.720 --> 00:09:43.890
在其中添加条件注释

00:09:41.940 --> 00:09:46.140
转一个条件对象

00:09:43.890 --> 00:09:48.120
条件类文字引用

00:09:46.140 --> 00:09:50.730
反过来只是提供一些程序化

00:09:48.120 --> 00:09:53.010
经过测试的任何证明

00:09:50.730 --> 00:09:54.930
在中还有另一个对象

00:09:53.010 --> 00:09:56.910
应用程序上下文证明

00:09:54.930 --> 00:10:00.180
它测试的某个属性的存在

00:09:56.910 --> 00:10:01.829
对于任何正确的东西，它都会测试您知道的

00:10:00.180 --> 00:10:03.329
是汞逆行吗

00:10:01.829 --> 00:10:04.500
可以的可以的

00:10:03.329 --> 00:10:08.310
以编程方式描述它，然后你

00:10:04.500 --> 00:10:10.980
可以测试它，所以这是

00:10:08.310 --> 00:10:13.470
故事你怎么知道哪些测试

00:10:10.980 --> 00:10:16.970
对或错在哪个活跃

00:10:13.470 --> 00:10:19.769
任何给定的点，为此，我们有

00:10:16.970 --> 00:10:22.410
调试选项，如果您通过则

00:10:19.769 --> 00:10:28.230
在您的应用程序中指定调试

00:10:22.410 --> 00:10:30.630
这样的属性等于true或您

00:10:28.230 --> 00:10:35.070
将其指定为--您知道调试

00:10:30.630 --> 00:10:38.370
等于true甚至调试等于

00:10:35.070 --> 00:10:40.829
 true或在IDE中指定

00:10:38.370 --> 00:10:42.540
例如在IntelliJ中，您可以说

00:10:40.829 --> 00:10:45.060
在启用调试输出中，有一个

00:10:42.540 --> 00:10:48.890
复选框，无论您做什么

00:10:45.060 --> 00:10:53.339
结果将使您受益匪浅

00:10:48.890 --> 00:10:55.380
实用程序在这里让我注释掉这些

00:10:53.339 --> 00:10:56.399
三位，因为我不需要它们

00:10:55.380 --> 00:11:00.480
结果会给你一个非常有用的

00:10:56.399 --> 00:11:03.269
实用程序，它会打印出一个

00:11:00.480 --> 00:11:05.010
所有不同汽车的枚举

00:11:03.269 --> 00:11:07.980
配置和条件

00:11:05.010 --> 00:11:13.050
正面或负面评价为

00:11:07.980 --> 00:11:15.529
以及那种不活跃的权利

00:11:13.050 --> 00:11:18.149
所以让我们继续来看结果

00:11:15.529 --> 00:11:19.440
在所有不同的条件

00:11:18.149 --> 00:11:20.279
应用程序，所以这会告诉你

00:11:19.440 --> 00:11:21.829
所有的东西

00:11:20.279 --> 00:11:24.569
尝试启动时的Spring 启动

00:11:21.829 --> 00:11:25.740
评估以得出

00:11:24.569 --> 00:11:28.790
声明它在何时，何时

00:11:25.740 --> 00:11:28.790
运行，让我们看看

00:11:39.029 --> 00:11:46.540
我们在那里，所以我们有条件

00:11:42.850 --> 00:11:48.610
如果您看到这里的条件是

00:11:46.540 --> 00:11:52.269
打印方便，易于分类

00:11:48.610 --> 00:11:58.929
控制台滚动中的读取格式

00:11:52.269 --> 00:12:00.850
在这里，我们可以看到负匹配

00:11:58.929 --> 00:12:02.170
这些是尝试过的测试

00:12:00.850 --> 00:12:04.959
但不匹配，您会看到一个

00:12:02.170 --> 00:12:06.009
班级细分，然后

00:12:04.959 --> 00:12:08.860
具体条件

00:12:06.009 --> 00:12:10.809
您知道注释是有条件的， 

00:12:08.860 --> 00:12:12.579
它试图运行的测试

00:12:10.809 --> 00:12:14.589
那么我们可以在这里看到积极的

00:12:12.579 --> 00:12:17.319
测试确实匹配的那些，我

00:12:14.589 --> 00:12:22.179
认为这些通常是更多

00:12:17.319 --> 00:12:26.459
有趣，所以这里我们去自动

00:12:22.179 --> 00:12:26.459
配置端口，这说明我们

00:12:29.100 --> 00:12:33.519
评估候选人是否

00:12:31.689 --> 00:12:38.199
类型为抽象审核侦听器

00:12:33.519 --> 00:12:39.369
在汽车内部不可用

00:12:38.199 --> 00:12:42.970
配置称为audit Auto 

00:12:39.369 --> 00:12:44.829
配置，因此您知道

00:12:42.970 --> 00:12:46.360
梁提供程序或配置类

00:12:44.829 --> 00:12:49.420
该活动注释所在的位置

00:12:46.360 --> 00:12:50.319
目前已激活，所以这是你

00:12:49.420 --> 00:12:53.769
知道现在我们有一个简单的方法

00:12:50.319 --> 00:12:55.929
了解哪些引脚在起作用

00:12:53.769 --> 00:12:59.139
在自动配置上以及哪些

00:12:55.929 --> 00:13:01.259
您是否知道整个

00:12:59.139 --> 00:13:05.009
仍然没有的配置

00:13:01.259 --> 00:13:08.019
完全解释这是一个使能

00:13:05.009 --> 00:13:09.999
注解和 Spring 以来的 Spring 

00:13:08.019 --> 00:13:12.549
 3.1我们在肚脐注释中

00:13:09.999 --> 00:13:15.279
是Java注释的一种

00:13:12.549 --> 00:13:18.639
相当于各种配置

00:13:15.279 --> 00:13:20.559
 XML中注释驱动的元素

00:13:18.639 --> 00:13:22.419
和旧式XML，例如

00:13:20.559 --> 00:13:24.040
如果您想进行交易

00:13:22.419 --> 00:13:25.749
在中启用交易管理

00:13:24.040 --> 00:13:28.089
 Spring ，您可以说TX：注解

00:13:25.749 --> 00:13:29.470
在XML中驱动氢，现在

00:13:28.089 --> 00:13:32.019
有海军事务管理

00:13:29.470 --> 00:13:33.839
例如，好吧，这是怎么回事

00:13:32.019 --> 00:13:37.929
是当spring看到这个注释时

00:13:33.839 --> 00:13:41.769
它看到它在导入时会

00:13:37.929 --> 00:13:45.309
导入它的配置类

00:13:41.769 --> 00:13:48.519
需要您知道要运行，并且很多

00:13:45.309 --> 00:13:50.259
这些进口只是带来了

00:13:48.519 --> 00:13:51.730
相关对象和相关对象

00:13:50.259 --> 00:13:52.610
因为它现在存在于

00:13:51.730 --> 00:13:54.560
应用环境

00:13:52.610 --> 00:13:56.720
然后允许自动配置

00:13:54.560 --> 00:13:58.490
条件评估为真，所以

00:13:56.720 --> 00:14:00.290
其余的则根据

00:13:58.490 --> 00:14:02.720
其他配置有时会导入

00:14:00.290 --> 00:14:04.190
只是at enable断言您

00:14:02.720 --> 00:14:05.329
有兴趣选择任何东西

00:14:04.190 --> 00:14:07.880
您想要获得的功能

00:14:05.329 --> 00:14:10.480
然后带上一个标记物或一些

00:14:07.880 --> 00:14:14.360
 Spring 关心的一种物体

00:14:10.480 --> 00:14:16.790
如果在那里，那么它习惯了

00:14:14.360 --> 00:14:18.350
告诉您知道的配置服务器

00:14:16.790 --> 00:14:20.810
其他地方的自动配置

00:14:18.350 --> 00:14:22.070
它应该激活其余的

00:14:20.810 --> 00:14:23.779
支持该图

00:14:22.070 --> 00:14:26.060
功能，这是很常见的

00:14:23.779 --> 00:14:30.709
模式，例如，如果您使用Spring 

00:14:26.060 --> 00:14:32.959
在Akaka上启动启动程序批处理

00:14:30.709 --> 00:14:35.329
批量支持仍然需要

00:14:32.959 --> 00:14:38.560
能够进行批处理的权利

00:14:35.329 --> 00:14:41.390
这只是您要

00:14:38.560 --> 00:14:44.149
某些功能到位，所以我们已经

00:14:41.390 --> 00:14:45.620
现在看一下我们的Java配置

00:14:44.149 --> 00:14:48.529
看了我们看过的自动配置

00:14:45.620 --> 00:14:49.820
如何覆盖某些部分

00:14:48.529 --> 00:14:51.740
对象图始终

00:14:49.820 --> 00:14:53.180
提供已知类型的对象

00:14:51.740 --> 00:14:57.890
因为记得 Spring 的结束是

00:14:53.180 --> 00:14:59.390
只是一个框架而已

00:14:57.890 --> 00:15:00.850
知道你愿意扩展

00:14:59.390 --> 00:15:04.310
已关闭，您可以提供修改

00:15:00.850 --> 00:15:06.470
打算插入的对象

00:15:04.310 --> 00:15:08.180
并作为机器的货物

00:15:06.470 --> 00:15:10.010
说话， Spring 会做的

00:15:08.180 --> 00:15:14.810
基于它的正确的东西

00:15:10.010 --> 00:15:15.949
较早的类型，我们看着兔子

00:15:14.810 --> 00:15:20.510
兔子自动配置

00:15:15.949 --> 00:15:23.300
使它很容易被覆盖是

00:15:20.510 --> 00:15:25.610
连接工厂的配置

00:15:23.300 --> 00:15:27.980
通过提供替换光束， 

00:15:25.610 --> 00:15:28.910
有点过分不是

00:15:27.980 --> 00:15:31.670
就像把婴儿扔出去

00:15:28.910 --> 00:15:32.990
大量的沐浴水

00:15:31.670 --> 00:15:34.820
这里我没有的功能

00:15:32.990 --> 00:15:36.380
 -不想重复

00:15:34.820 --> 00:15:38.839
只是为了调整一件事

00:15:36.380 --> 00:15:42.920
值得庆幸的是，我们可以轻松得多

00:15:38.839 --> 00:15:45.320
 11 ooh追求容易得多

00:15:42.920 --> 00:15:46.820
我们可以通过其定制渠道

00:15:45.320 --> 00:15:48.290
创建此连接Factory和

00:15:46.820 --> 00:15:50.600
那不是说我们可以提供

00:15:48.290 --> 00:15:51.980
您看到的Spring Boot具有的属性

00:15:50.600 --> 00:15:54.560
另一种称为

00:15:51.980 --> 00:15:56.480
配置属性POJO，所以这里是

00:15:54.560 --> 00:15:59.329
一个配置属性对象

00:15:56.480 --> 00:16:01.160
发出Spring 信号的注释

00:15:59.329 --> 00:16:02.540
所有来自

00:16:01.160 --> 00:16:04.540
从应用程序环境

00:16:02.540 --> 00:16:06.140
罐子或从

00:16:04.540 --> 00:16:07.880
邻近环境或

00:16:06.140 --> 00:16:10.040
环境变量用于配置

00:16:07.880 --> 00:16:13.310
从Jane di的配置服务器或

00:16:10.040 --> 00:16:15.350
无论这个属性这些

00:16:13.310 --> 00:16:17.420
属性映射到上的字段

00:16:15.350 --> 00:16:19.580
 Spring 登上领奖台

00:16:17.420 --> 00:16:21.680
主持人 Spring 指出牧师暗示港口

00:16:19.580 --> 00:16:23.540
 Spring 那RabbitMQ那用户名

00:16:21.680 --> 00:16:26.540
密码，但作为该虚拟主机的单元格

00:16:23.540 --> 00:16:28.250
等等等，所以我可以覆盖

00:16:26.540 --> 00:16:30.890
这些默认值在这里获得

00:16:28.250 --> 00:16:33.080
覆盖在这些字段上，然后

00:16:30.890 --> 00:16:34.850
配置可以注入

00:16:33.080 --> 00:16:38.060
配置属性对象，然后

00:16:34.850 --> 00:16:39.710
用它来配置

00:16:38.060 --> 00:16:41.990
如果我在这种情况下连接工厂

00:16:39.710 --> 00:16:44.750
想指出我的RabbitMQ连接

00:16:41.990 --> 00:16:47.230
工厂可以使用的特定主机

00:16:44.750 --> 00:16:49.820
您知道的一个配置对象

00:16:47.230 --> 00:16:51.410
解决用户拥有的主机

00:16:49.820 --> 00:16:53.090
指定，这样我就不必

00:16:51.410 --> 00:16:55.310
覆盖整个连接工厂

00:16:53.090 --> 00:16:58.490
我可以我只是可以裁缝

00:16:55.310 --> 00:17:00.470
配置的一部分，因此

00:16:58.490 --> 00:17:02.030
与属性和智能

00:17:00.470 --> 00:17:03.680
自动配置和应用

00:17:02.030 --> 00:17:06.199
条件注释能够

00:17:03.680 --> 00:17:07.790
更改堆栈中的所有内容

00:17:06.199 --> 00:17:09.740
框架中的所有内容

00:17:07.790 --> 00:17:13.870
机器中的一切和您

00:17:09.740 --> 00:17:15.890
有完全的控制权，所以我想

00:17:13.870 --> 00:17:17.860
我们会说那 Spring 结束

00:17:15.890 --> 00:17:19.760
靴子最强大的资产是

00:17:17.860 --> 00:17:22.720
便利，然后它变得多么容易

00:17:19.760 --> 00:17:25.190
它来构建简单的应用程序

00:17:22.720 --> 00:17:27.490
感谢您的加入，希望您再见

00:17:25.190 --> 00:17:27.490
下次

00:17:39.220 --> 00:17:41.280
您

