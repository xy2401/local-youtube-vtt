WEBVTT
Kind: captions
Language: zh-Hans

00:00:10.759 --> 00:00:15.440
嗨，我的名字是警报鲍泽，我是

00:00:13.339 --> 00:00:17.810
司机的首席技术官来找我

00:00:15.440 --> 00:00:21.650
轴突框架的创始人，我在这里

00:00:17.810 --> 00:00:23.419
和Josh在一起，大家好，我是Josh 

00:00:21.650 --> 00:00:26.810
很长一段时间，我是Spring开发人员的拥护者

00:00:23.419 --> 00:00:29.480
我们一直在做的关键和关键

00:00:26.810 --> 00:00:31.039
我们头脑冷静的最佳服务客户

00:00:29.480 --> 00:00:33.170
以及社区成员和组织

00:00:31.039 --> 00:00:35.839
转向他们正在寻找的微服务

00:00:33.170 --> 00:00:37.640
寻求更快的方法并减少

00:00:35.839 --> 00:00:39.530
他们拥有的工作量

00:00:37.640 --> 00:00:41.210
在整个价值链中移动

00:00:39.530 --> 00:00:42.470
投入生产，我们已经看到了很多

00:00:41.210 --> 00:00:43.670
的组织采取了这一举措， 

00:00:42.470 --> 00:00:45.320
他们正在使用Spring Buettner使用

00:00:43.670 --> 00:00:47.270
春天云来建立这种

00:00:45.320 --> 00:00:49.340
分布式系统和一件事

00:00:47.270 --> 00:00:52.910
似乎很多是我们如何

00:00:49.340 --> 00:00:55.850
建立您知道的分发系统

00:00:52.910 --> 00:00:57.710
有纠结或必须了解

00:00:55.850 --> 00:01:00.260
在其他节点陈述我们如何得到

00:00:57.710 --> 00:01:02.780
不同的节点同意状态或

00:01:00.260 --> 00:01:04.879
收敛到正确的状态

00:01:02.780 --> 00:01:06.830
一种似乎常见的模式

00:01:04.879 --> 00:01:10.399
很多是CQRS 

00:01:06.830 --> 00:01:13.910
所以今天我们很幸运

00:01:10.399 --> 00:01:16.399
在这里加入我们并介绍寻找者

00:01:13.910 --> 00:01:19.280
行动框架

00:01:16.399 --> 00:01:21.860
与弹簧配合使用非常非常好

00:01:19.280 --> 00:01:26.840
但是-就像您能告诉我们什么CQRS 

00:01:21.860 --> 00:01:29.390
是非常安全的s表示命令和查询

00:01:26.840 --> 00:01:32.030
责任分工吧

00:01:29.390 --> 00:01:34.489
基本上意味着拆分组件

00:01:32.030 --> 00:01:37.009
变成可以处理的东西

00:01:34.489 --> 00:01:39.380
旨在更改的命令

00:01:37.009 --> 00:01:42.619
系统中的某些东西需要更改

00:01:39.380 --> 00:01:45.020
应用程序状态与

00:01:42.619 --> 00:01:46.899
另一面的查询给你

00:01:45.020 --> 00:01:49.759
对当前状态的洞察

00:01:46.899 --> 00:01:53.599
应用程序，您已经提到

00:01:49.759 --> 00:01:56.270
不同的组成部分需要同意

00:01:53.599 --> 00:01:58.009
在一个共同的共同状态上，这是非常

00:01:56.270 --> 00:02:00.920
通常，当您有很多

00:01:58.009 --> 00:02:03.170
本质上不同的观点

00:02:00.920 --> 00:02:04.789
相同的数据有很多

00:02:03.170 --> 00:02:07.099
查看信息的不同方法

00:02:04.789 --> 00:02:09.679
包含在系统中并且与众不同

00:02:07.099 --> 00:02:12.410
人们有不同的要求

00:02:09.679 --> 00:02:15.140
那些，那恰恰是什么？ 

00:02:12.410 --> 00:02:18.650
将帮助您做到这一点将帮助您

00:02:15.140 --> 00:02:20.840
专注于您需要的数据

00:02:18.650 --> 00:02:25.870
这些观众中的每一个

00:02:20.840 --> 00:02:25.870
您数据的这些用户

00:02:25.950 --> 00:02:30.609
你可以在分布式

00:02:28.599 --> 00:02:32.590
系统为什么这种架构更好

00:02:30.609 --> 00:02:34.810
为了分配我们得到什么

00:02:32.590 --> 00:02:37.299
安全地构建我们的应用程序

00:02:34.810 --> 00:02:40.150
您知道我们是否要移至的方式

00:02:37.299 --> 00:02:42.939
分发系统的东西

00:02:40.150 --> 00:02:45.719
这是很常见的

00:02:42.939 --> 00:02:48.400
基于蔗糖的系统，不是

00:02:45.719 --> 00:02:50.469
本质上，CQ本身会说

00:02:48.400 --> 00:02:53.079
与分布式系统无关，但

00:02:50.469 --> 00:02:54.549
它非常常与

00:02:53.079 --> 00:02:57.099
事件驱动的架构，那就是

00:02:54.549 --> 00:03:01.209
真正在哪里

00:02:57.099 --> 00:03:03.790
海冠也进来了，你是你吗

00:03:01.209 --> 00:03:05.469
有这些明确的消息，你

00:03:03.790 --> 00:03:07.719
可以使用，因此您有改变的意图

00:03:05.469 --> 00:03:11.409
如果你表达了这种意图

00:03:07.719 --> 00:03:13.599
一条消息，然后你就可以实现

00:03:11.409 --> 00:03:17.260
位置透明，因此您可以实现

00:03:13.599 --> 00:03:19.510
该组件发送的那个组件

00:03:17.260 --> 00:03:21.730
该命令不知道或需要知道

00:03:19.510 --> 00:03:24.150
组件接收和

00:03:21.730 --> 00:03:27.760
处理实际运行的命令

00:03:24.150 --> 00:03:29.949
这样可以帮助您构建应用程序

00:03:27.760 --> 00:03:32.739
以后甚至可以分发

00:03:29.949 --> 00:03:35.019
每当你需要和相同的

00:03:32.739 --> 00:03:37.780
当你当你改变一个东西

00:03:35.019 --> 00:03:41.169
在系统中，您可以发明事件并

00:03:37.780 --> 00:03:43.209
然后可以处理这些事件

00:03:41.169 --> 00:03:45.699
更新的不同组件

00:03:43.209 --> 00:03:47.799
针对特定目标的特定模型

00:03:45.699 --> 00:03:50.949
受众与这些数据

00:03:47.799 --> 00:03:52.989
听众要求，所以您可以使用这些

00:03:50.949 --> 00:03:55.030
消息并优化每个组件

00:03:52.989 --> 00:03:58.090
分开，这是一个非常好的

00:03:55.030 --> 00:04:00.340
可以组合的功能

00:03:58.090 --> 00:04:05.019
用于构建分布式系统

00:04:00.340 --> 00:04:06.849
哦，很酷，好吧，我知道了

00:04:05.019 --> 00:04:08.680
激起我的好奇心，你能告诉我们吗

00:04:06.849 --> 00:04:11.909
如何建立一个简单的应用程序

00:04:08.680 --> 00:04:14.349
假设我有一个简单的微型服务器

00:04:11.909 --> 00:04:16.930
有一些状态，你知道我们可以

00:04:14.349 --> 00:04:19.840
建立一个简单的例子，看看它是什么

00:04:16.930 --> 00:04:22.330
看起来像-是的，制作一部迷你剧

00:04:19.840 --> 00:04:24.340
国家服务，我们想建立一些东西

00:04:22.330 --> 00:04:26.949
快速正确，所以做到这一点的最佳方法

00:04:24.340 --> 00:04:28.180
是在 spring boot I / O并使用

00:04:26.949 --> 00:04:32.169
你可能非常

00:04:28.180 --> 00:04:33.520
熟悉spring初始值设定项

00:04:32.169 --> 00:04:35.090
我们将开始一个春天

00:04:33.520 --> 00:04:37.040
启动应用

00:04:35.090 --> 00:04:39.320
我一直在想

00:04:37.040 --> 00:04:41.960
我们可以抱怨的应用程序

00:04:39.320 --> 00:04:45.950
对的公司，所以我们要建立

00:04:41.960 --> 00:04:49.250
投诉申请做了很多

00:04:45.950 --> 00:04:51.260
您喜欢的Web应用程序

00:04:49.250 --> 00:04:55.280
每隔一段时间，是的，它让我

00:04:51.260 --> 00:05:02.390
它让我充满动力，这是导泻和

00:04:55.280 --> 00:05:05.120
所以我们将web和JPA hsqldb放到

00:05:02.390 --> 00:05:07.340
在稍后的一些MQP中，因为

00:05:05.120 --> 00:05:09.980
我们想做一些有趣的事情

00:05:07.340 --> 00:05:13.910
东西，不要以为我失踪了

00:05:09.980 --> 00:05:18.220
这里的任何东西都很好

00:05:13.910 --> 00:05:28.910
让我们开始吧，让我们解压缩

00:05:18.220 --> 00:05:30.830
文件，然后开始我们的项目

00:05:28.910 --> 00:05:33.530
所以这里就是一切，这就是

00:05:30.830 --> 00:05:35.540
只是普通的 spring boot 就可以了

00:05:33.530 --> 00:05:37.730
你在几秒钟内开始

00:05:35.540 --> 00:05:41.840
不幸的是，我们不得不

00:05:37.730 --> 00:05:46.160
手动添加轴突 spring boot 

00:05:41.840 --> 00:05:49.729
入门，目前我们将使用

00:05:46.160 --> 00:05:52.550
释放候选最大

00:05:49.729 --> 00:05:54.710
三个轴突，三个几乎是

00:05:52.550 --> 00:05:58.160
差不多完成了，我们要做很多工作

00:05:54.710 --> 00:06:00.470
进去拿出来，但轴突

00:05:58.160 --> 00:06:03.560
三个有这些弹簧启动器

00:06:00.470 --> 00:06:06.710
真正启动您的

00:06:03.560 --> 00:06:10.180
申请就可以了，仅此而已

00:06:06.710 --> 00:06:13.910
需要做的，然后我们去我们的

00:06:10.180 --> 00:06:17.360
应用程序，这是我们的 spring boot 

00:06:13.910 --> 00:06:18.770
应用正确的配置

00:06:17.360 --> 00:06:21.830
让我们开始吧

00:06:18.770 --> 00:06:24.120
建立一个小API从而建立一个小联盟

00:06:21.830 --> 00:06:25.320
其余的部分

00:06:24.120 --> 00:06:27.560
你能定义一点吗

00:06:25.320 --> 00:06:27.560
大

00:06:42.850 --> 00:06:51.910
 18完美

00:06:48.340 --> 00:06:53.050
我们从头开始好好游泳吗

00:06:51.910 --> 00:06:56.730
确保我们都在同一页面上

00:06:53.050 --> 00:06:58.770
我改变了我的最后时间很酷

00:06:56.730 --> 00:07:03.330
对

00:06:58.770 --> 00:07:08.020
所以我们创建了这个rest控制器， 

00:07:03.330 --> 00:07:12.880
让我们得到一个公开的方法

00:07:08.020 --> 00:07:17.710
类静态类，我们称之为

00:07:12.880 --> 00:07:19.390
间歇泉精确地处理投诉

00:07:17.710 --> 00:07:23.260
因此，让我们从一点一无所获开始

00:07:19.390 --> 00:07:26.350
所以我们有这个HTTP GET请求， 

00:07:23.260 --> 00:07:29.740
想映射到并始终使用void我让

00:07:26.350 --> 00:07:33.130
 ID的键入速度更快

00:07:29.740 --> 00:07:34.930
比我好，让我们做一个最后的方法，所以我们

00:07:33.130 --> 00:07:38.290
想找到我们所有的抱怨

00:07:34.930 --> 00:07:43.090
我们拥有并获得我们需要的

00:07:38.290 --> 00:07:46.770
仓库，以便我们可以投诉

00:07:43.090 --> 00:07:52.360
这是第一个小CQ 

00:07:46.770 --> 00:07:54.430
事情来了，我们提出了投诉

00:07:52.360 --> 00:07:56.860
查询对象存储库要非常

00:07:54.430 --> 00:08:01.510
明确说明对象的类型

00:07:56.860 --> 00:08:04.870
我们正在使用，所以我们正在服务

00:08:01.510 --> 00:08:09.100
信息，这是一个查询，所以我们想要

00:08:04.870 --> 00:08:11.850
明确地说，我们创建

00:08:09.100 --> 00:08:14.530
扩展差距的接口

00:08:11.850 --> 00:08:19.470
我们将提供的存储库

00:08:14.530 --> 00:08:23.660
投诉查询投诉查询对象

00:08:19.470 --> 00:08:27.080
用字符串标识

00:08:23.660 --> 00:08:29.300
并建立一个仓库

00:08:27.080 --> 00:08:36.440
对象也不存在，所以我们创建

00:08:29.300 --> 00:08:47.390
这是一个API实体，我们拥有

00:08:36.440 --> 00:08:53.030
在id private字符串处有一个private 

00:08:47.390 --> 00:08:57.250
字符串脚本和私有字符串

00:08:53.030 --> 00:08:57.250
我们要投诉的公司

00:08:58.030 --> 00:09:09.590
我喜欢避免系列创建一个

00:09:04.760 --> 00:09:13.670
我们的构造函数以及我们所有的构造函数

00:09:09.590 --> 00:09:16.250
只是为了以后，所以现在我们

00:09:13.670 --> 00:09:21.080
有我们的仓库，我们可以做到这一点

00:09:16.250 --> 00:09:27.080
最后，我们添加一个后构造器

00:09:21.080 --> 00:09:29.000
参数Springvale是的，将使用

00:09:27.080 --> 00:09:32.240
 Spring Framework 4.3中的新支持

00:09:29.000 --> 00:09:34.310
自动注入明确

00:09:32.240 --> 00:09:35.630
可解析的协作对象

00:09:34.310 --> 00:09:39.880
即使没有自动接线的构造函数

00:09:35.630 --> 00:09:46.390
正确正确，这样就可以做到

00:09:39.880 --> 00:09:49.460
更简单，更不易出错，所以让我们

00:09:46.390 --> 00:09:53.480
做他们的映射，所以我们有我们的

00:09:49.460 --> 00:09:55.910
链接的投诉查询对象

00:09:53.480 --> 00:09:59.080
查询对象，我们想找到一个

00:09:55.910 --> 00:10:04.280
具体的一个，所以我们可以使用一条路径

00:09:59.080 --> 00:10:06.530
可变字符串ID，我们必须

00:10:04.280 --> 00:10:12.320
在请求映射中提到

00:10:06.530 --> 00:10:14.000
说出身分证，这样就可以

00:10:12.320 --> 00:10:16.730
然后不习惯于Spring Framework 4.3 

00:10:14.000 --> 00:10:18.320
你会不会意识到这些， 

00:10:16.730 --> 00:10:20.930
获取映射，然后发布映射

00:10:18.320 --> 00:10:22.790
凯撒注解是捷径

00:10:20.930 --> 00:10:24.770
用于请求映射以及特定的

00:10:22.790 --> 00:10:27.400
这三个方法介绍

00:10:24.770 --> 00:10:27.400
另一个不错的功能

00:10:27.500 --> 00:10:32.820
是的，它真的很干净我

00:10:30.240 --> 00:10:35.550
很喜欢这样，我们当然有

00:10:32.820 --> 00:10:39.170
以及发布映射，这是

00:10:35.550 --> 00:10:42.959
搜寻者的更多实际用途

00:10:39.170 --> 00:10:43.290
变得可见，让我们对其无效

00:10:42.959 --> 00:10:46.290
现在

00:10:43.290 --> 00:10:49.649
让我们要创建的学校

00:10:46.290 --> 00:10:54.360
这里的东西恰好我们要去

00:10:49.649 --> 00:10:59.190
做好投诉的地方

00:10:54.360 --> 00:11:01.079
这是一台真正的服务器，所以我们有一个

00:10:59.190 --> 00:11:04.290
请求正文，让我们创建一个地图

00:11:01.079 --> 00:11:06.839
字符串到字符串，当然你

00:11:04.290 --> 00:11:09.390
可以创建这些对象

00:11:06.839 --> 00:11:13.350
包含所有数据给您，但这是

00:11:09.390 --> 00:11:19.140
只是一种快速而肮脏的方式来获得我们的

00:11:13.350 --> 00:11:21.630
要求，所以我们没有东西

00:11:19.140 --> 00:11:22.529
现在是一个P，它将成为一个映射

00:11:21.630 --> 00:11:25.560
您将从JSON获取

00:11:22.529 --> 00:11:28.440
正确的JSON结构

00:11:25.560 --> 00:11:32.640
结构被翻译成键图

00:11:28.440 --> 00:11:34.980
和价值观，因此我们需要

00:11:32.640 --> 00:11:37.890
现在是有人提出投诉的时候

00:11:34.980 --> 00:11:39.600
我们希望系统为

00:11:37.890 --> 00:11:41.100
我们是正确的，所以我们不要求

00:11:39.600 --> 00:11:44.100
我们告诉它要做的信息

00:11:41.100 --> 00:11:46.769
东西，所以这是我们传递的地方

00:11:44.100 --> 00:11:51.440
命令，并在轴突中有命令

00:11:46.769 --> 00:11:54.180
网关并发送命令和

00:11:51.440 --> 00:11:58.890
因为我们包括了春天的美好

00:11:54.180 --> 00:12:02.279
入门模块，我们拥有所有的轴突

00:11:58.890 --> 00:12:05.329
我们可以使用的基础设施是

00:12:02.279 --> 00:12:07.920
命令总线，还有事件总线

00:12:05.329 --> 00:12:09.930
然后还有一些其他的事情

00:12:07.920 --> 00:12:13.110
我们稍后会看到和命令

00:12:09.930 --> 00:12:15.660
网关是一个非常方便的API 

00:12:13.110 --> 00:12:18.209
发送命令，以便我们现在可以做什么

00:12:15.660 --> 00:12:19.860
我们可以说发送，我们可以通过

00:12:18.209 --> 00:12:22.760
在我们要作为对象发送的对象中

00:12:19.860 --> 00:12:27.449
命令，所以我们要发送文件

00:12:22.760 --> 00:12:30.660
投诉命令，我们要传递

00:12:27.449 --> 00:12:32.610
一些信息，所以要求得到和这个

00:12:30.660 --> 00:12:35.970
基本上是查询或获取数据

00:12:32.610 --> 00:12:37.430
从我们的JSON结构中，我们说

00:12:35.970 --> 00:12:44.000
有公司

00:12:37.430 --> 00:12:48.470
我们确实要求获得描述，我们

00:12:44.000 --> 00:12:50.390
想返回该方法发送的内容

00:12:48.470 --> 00:12:52.339
现在还没有编译，所以

00:12:50.390 --> 00:12:55.220
它不是在抱怨空隙，所以

00:12:52.339 --> 00:12:57.080
我们需要创建这个命令对象

00:12:55.220 --> 00:13:03.230
我们将其创建为内部类

00:12:57.080 --> 00:13:03.940
这是我们需要的任何东西

00:13:03.230 --> 00:13:07.029
抱歉

00:13:03.940 --> 00:13:09.820
是否有ID或我们需要的任何东西

00:13:07.029 --> 00:13:12.680
是的，实际上

00:13:09.820 --> 00:13:15.050
这实际上是一个好习惯

00:13:12.680 --> 00:13:17.360
传递投诉的标识符

00:13:15.050 --> 00:13:19.430
您将要创建，就是这样

00:13:17.360 --> 00:13:21.560
听起来可能有点奇怪，为什么

00:13:19.430 --> 00:13:23.660
您必须先创建一个标识符

00:13:21.560 --> 00:13:25.459
创建了一些东西，但特别是

00:13:23.660 --> 00:13:29.149
分布式系统非常方便

00:13:25.459 --> 00:13:32.060
有所谓的客户端生成

00:13:29.149 --> 00:13:34.899
标识符，所以实际上我们可以有一个

00:13:32.060 --> 00:13:38.089
这里的本地变量的类型为string和

00:13:34.899 --> 00:13:41.770
使用随机的东西，你的ID是

00:13:38.089 --> 00:13:45.350
通常来说，这是一个很好的价值，并且

00:13:41.770 --> 00:13:48.709
所以在这种情况下，我们在这里有一个ID 

00:13:45.350 --> 00:13:51.410
好，现在您可以看到

00:13:48.709 --> 00:13:53.480
抱怨我可以返回的值

00:13:51.410 --> 00:13:55.700
使它返回可完成的未来

00:13:53.480 --> 00:13:59.410
实际上知道这种情况

00:13:55.700 --> 00:14:03.529
成为一个字符串，所以这样做是

00:13:59.410 --> 00:14:05.690
发送命令，如果命令

00:14:03.529 --> 00:14:09.320
异步执行，甚至

00:14:05.690 --> 00:14:12.170
遥远的地方或只有春天

00:14:09.320 --> 00:14:14.420
将响应发送到HTTP POST 

00:14:12.170 --> 00:14:16.310
该命令实际上是这样执行的

00:14:14.420 --> 00:14:18.709
用户界面获得响应的时间

00:14:16.310 --> 00:14:20.120
命令已处理但线程

00:14:18.709 --> 00:14:23.240
该模拟实际上起作用

00:14:20.120 --> 00:14:25.190
早些时候发布我只是自然地工作

00:14:23.240 --> 00:14:28.100
在Spring中支持异步

00:14:25.190 --> 00:14:30.560
在以后的Framework 3.1中编写

00:14:28.100 --> 00:14:35.510
可完成的未来

00:14:30.560 --> 00:14:38.440
等等完全可以调用，那就是

00:14:35.510 --> 00:14:43.010
为什么轴突API具有完全相同的

00:14:38.440 --> 00:14:44.600
您只需将它们传递给两个功能

00:14:43.010 --> 00:14:47.480
春天和春天以这种方式处理

00:14:44.600 --> 00:14:49.310
你会期望的，所以这是

00:14:47.480 --> 00:14:50.670
实际上，现在我们可以发送一个

00:14:49.310 --> 00:14:53.790
发送方命令正确，所以我们

00:14:50.670 --> 00:14:55.620
请求并发送命令，但

00:14:53.790 --> 00:14:58.230
这个命令无处可去

00:14:55.620 --> 00:14:59.850
组件与此做任何事情

00:14:58.230 --> 00:15:04.860
命令，因此我们需要将其创建为

00:14:59.850 --> 00:15:07.350
好，在CQRS命令是

00:15:04.860 --> 00:15:08.910
针对与其他模型不同的模型执行

00:15:07.350 --> 00:15:11.880
查询正确，查询在那里

00:15:08.910 --> 00:15:15.000
获取信息和命令

00:15:11.880 --> 00:15:18.360
有一个指挥官的帽子处理了

00:15:15.000 --> 00:15:20.210
通过一个经常返回的单独模型

00:15:18.360 --> 00:15:22.920
冷杉二作为骨料

00:15:20.210 --> 00:15:24.960
这是领域驱动的设计理念， 

00:15:22.920 --> 00:15:27.990
这意味着它是许多实体

00:15:24.960 --> 00:15:30.000
保持与

00:15:27.990 --> 00:15:34.500
关于数据更改，所以有

00:15:30.000 --> 00:15:37.560
该数据已经在

00:15:34.500 --> 00:15:39.690
聚合，所以我们只创建一个类， 

00:15:37.560 --> 00:15:44.850
我们称之为投诉，因为那是

00:15:39.690 --> 00:15:47.010
它代表了，所以我把

00:15:44.850 --> 00:15:53.100
聚集注释是轴突

00:15:47.010 --> 00:15:56.850
注释，我至少需要违抗

00:15:53.100 --> 00:15:59.760
一个字段，它是

00:15:56.850 --> 00:16:01.680
这个聚合，所以我需要添加

00:15:59.760 --> 00:16:03.870
聚合标识符注释

00:16:01.680 --> 00:16:08.820
现在我无法创建命令处理程序

00:16:03.870 --> 00:16:11.700
在这种情况下，我可以创建

00:16:08.820 --> 00:16:14.220
一个新的投诉实例，所以当

00:16:11.700 --> 00:16:15.450
文件投诉命令进入我们

00:16:14.220 --> 00:16:22.440
想要创建一个新的实例

00:16:15.450 --> 00:16:26.190
投诉，我们传递参数

00:16:22.440 --> 00:16:28.260
指挥官的参数

00:16:26.190 --> 00:16:31.520
我们会知道该命令何时发送

00:16:28.260 --> 00:16:34.410
它创建了一个新的投诉实例

00:16:31.520 --> 00:16:36.150
现在通常你会改变状态

00:16:34.410 --> 00:16:38.550
在这个处理程序中，在哪里

00:16:36.150 --> 00:16:40.670
你有东西进来， 

00:16:38.550 --> 00:16:44.340
通常，您将执行此点ID等于

00:16:40.670 --> 00:16:46.860
等等，那是不允许的

00:16:44.340 --> 00:16:49.590
实际上在CQ中允许，但是我们

00:16:46.860 --> 00:16:52.230
想在这里做活动采购，所以我们

00:16:49.590 --> 00:16:54.750
不想存储状态

00:16:52.230 --> 00:16:56.340
抱怨原样，但我们想要

00:16:54.750 --> 00:16:58.650
存储所有具有

00:16:56.340 --> 00:17:00.750
过去曾发生过投诉

00:16:58.650 --> 00:17:02.850
如果我们想知道当前状态

00:17:00.750 --> 00:17:04.559
我们需要做的就是重播，否则

00:17:02.850 --> 00:17:06.390
口音实际上为您带来了什么

00:17:04.559 --> 00:17:08.699
您只需重播一个

00:17:06.390 --> 00:17:10.789
在发生的特定投诉

00:17:08.699 --> 00:17:13.140
过去，您将了解当前状态

00:17:10.789 --> 00:17:16.530
但是要做到这一点，我们需要

00:17:13.140 --> 00:17:19.770
将决策与

00:17:16.530 --> 00:17:21.510
实际状态改变逻辑，所以在这里我们

00:17:19.770 --> 00:17:24.299
做一些决策，我们可以说

00:17:21.510 --> 00:17:27.449
让我们提出一些不错的assert方法

00:17:24.299 --> 00:17:31.200
你可以说思想上有联系

00:17:27.449 --> 00:17:32.250
得到公司权利，我们需要信息，如果

00:17:31.200 --> 00:17:34.760
我们不知道你是哪家公司

00:17:32.250 --> 00:17:36.570
抱怨本质上是没有用的

00:17:34.760 --> 00:17:42.980
如果可以的话

00:17:36.570 --> 00:17:48.450
然后我们可以提出新的申诉

00:17:42.980 --> 00:17:52.830
事件我从中看到了一些信息

00:17:48.450 --> 00:17:54.659
指挥比赛并取得好成绩

00:17:52.830 --> 00:17:58.740
公司确保我们得到正确的订单

00:17:54.659 --> 00:18:00.120
不然我们搞砸了

00:17:58.740 --> 00:18:02.190
 apply方法是我们

00:18:00.120 --> 00:18:06.179
可以从轴突静态导入

00:18:02.190 --> 00:18:10.679
框架，这将做两件事

00:18:06.179 --> 00:18:13.140
将在内部发布此活动，并且

00:18:10.679 --> 00:18:15.090
然后在内部汇总

00:18:13.140 --> 00:18:18.360
将应用所属的状态更改

00:18:15.090 --> 00:18:20.640
该事件，它将发布

00:18:18.360 --> 00:18:22.679
事件发生在

00:18:20.640 --> 00:18:25.140
汇总在应用程序中并作为

00:18:22.679 --> 00:18:27.809
我们稍后会看到

00:18:25.140 --> 00:18:32.659
应用程序，所以我们要

00:18:27.809 --> 00:18:39.780
建立一个小班和公司

00:18:32.659 --> 00:18:48.020
然后将其绑定到我们，然后创建

00:18:39.780 --> 00:18:50.290
一些吸气剂正确，以便聚集

00:18:48.020 --> 00:18:52.370
创建它以响应一个

00:18:50.290 --> 00:18:54.380
命令每一个都写

00:18:52.370 --> 00:18:57.740
那个时候有一个命令

00:18:54.380 --> 00:19:00.560
特定的命令轴突将

00:18:57.740 --> 00:19:02.510
创建一个新的聚合，如果有

00:19:00.560 --> 00:19:05.450
不同的投诉ID或具有

00:19:02.510 --> 00:19:07.570
不同的投诉仅汇总

00:19:05.450 --> 00:19:11.360
生存时间与该命令处理程序一样长

00:19:07.570 --> 00:19:13.400
是活跃的，是的，是的，是的

00:19:11.360 --> 00:19:15.140
所以实际上当然是法院的

00:19:13.400 --> 00:19:16.880
从概念上讲，它们的寿命更长

00:19:15.140 --> 00:19:19.640
但是实际创建的对象

00:19:16.880 --> 00:19:22.190
只会在处理

00:19:19.640 --> 00:19:25.310
命令，然后事件是

00:19:22.190 --> 00:19:28.130
持续存在，农业总量

00:19:25.310 --> 00:19:31.480
实例只是被遗忘了，除非

00:19:28.130 --> 00:19:36.590
您可以使用随便举报

00:19:31.480 --> 00:19:38.930
谁坚持了这些事件

00:19:36.590 --> 00:19:42.800
轴突在

00:19:38.930 --> 00:19:45.770
背景，所以轴突 spring boot 

00:19:42.800 --> 00:19:46.340
入门者会认识到您正在使用

00:19:45.770 --> 00:19:50.510
 JPA 

00:19:46.340 --> 00:19:53.210
它将在您的计算机中配置一个表

00:19:50.510 --> 00:19:57.860
您的数据库，其中包含所有

00:19:53.210 --> 00:20:01.100
事件，并将投诉ID存储为

00:19:57.860 --> 00:20:03.710
这些事件的元数据的一部分，所以

00:20:01.100 --> 00:20:06.020
当您提出特定投诉时

00:20:03.710 --> 00:20:09.770
可以很快找到所有事件

00:20:06.020 --> 00:20:11.660
这是该投诉的一部分

00:20:09.770 --> 00:20:13.790
那个单一的投诉，然后基于

00:20:11.660 --> 00:20:17.210
这些事件然后可以重建

00:20:13.790 --> 00:20:18.770
状态好酷， 

00:20:17.210 --> 00:20:23.120
重建整个日期已完成

00:20:18.770 --> 00:20:24.860
对于事件源处理人员，所以我

00:20:23.120 --> 00:20:29.170
可以在理论上重述整个历史

00:20:24.860 --> 00:20:32.210
对，我可以不必

00:20:29.170 --> 00:20:35.690
如果我想回到国家本身

00:20:32.210 --> 00:20:37.400
通过事件源我可以将其归零

00:20:35.690 --> 00:20:40.220
基本上退出并重新播放

00:20:37.400 --> 00:20:42.530
事件并准确地再次获得新状态

00:20:40.220 --> 00:20:44.780
这实际上是发生在

00:20:42.530 --> 00:20:48.080
始终汇总，但您也可以

00:20:44.780 --> 00:20:50.180
自行执行查询模型

00:20:48.080 --> 00:20:53.480
如果您创建了一个不错的模型，但是

00:20:50.180 --> 00:20:56.570
发现您与众不同

00:20:53.480 --> 00:20:58.040
不同的观点或表现

00:20:56.570 --> 00:21:00.260
可能会更好，你决定

00:20:58.040 --> 00:21:01.760
而不是重构它，您可以

00:21:00.260 --> 00:21:04.210
扔掉整个模型

00:21:01.760 --> 00:21:06.800
然后从头开始重建它

00:21:04.210 --> 00:21:09.160
时间的开始实际上是这样，因为你

00:21:06.800 --> 00:21:11.360
首先启动了应用程序

00:21:09.160 --> 00:21:13.730
取决于您产生多少个事件

00:21:11.360 --> 00:21:15.860
在您的应用程序中

00:21:13.730 --> 00:21:18.230
可能要花很长时间，但至少

00:21:15.860 --> 00:21:19.520
您可以选择这样做

00:21:18.230 --> 00:21:21.830
大多数已构建的应用程序

00:21:19.520 --> 00:21:24.520
现在，让我们说一个

00:21:21.830 --> 00:21:26.870
经理想要一份不同的报告

00:21:24.520 --> 00:21:29.030
您不捕获数据的

00:21:26.870 --> 00:21:31.280
最好的办法就是说我们要走了

00:21:29.030 --> 00:21:32.900
现在建造它，然后我们就去放

00:21:31.280 --> 00:21:34.550
它在大约一个月的生产中

00:21:32.900 --> 00:21:36.020
然后我们需要记录三个数据

00:21:34.550 --> 00:21:38.930
几个月，然后你会第一次

00:21:36.020 --> 00:21:41.060
报告，但现在您可以说

00:21:38.930 --> 00:21:43.070
好，给我几分钟时间重新加载

00:21:41.060 --> 00:21:45.470
最少的整个历史记录

00:21:43.070 --> 00:21:50.320
您的报告基于

00:21:45.470 --> 00:21:52.820
至少花费您的申请时间

00:21:50.320 --> 00:21:55.040
所以在这个事件中，采购经理

00:21:52.820 --> 00:21:56.900
这是由apply调用的

00:21:55.040 --> 00:21:59.300
方法或当我们加载一个

00:21:56.900 --> 00:22:01.220
来自数据库的现有投诉

00:21:59.300 --> 00:22:04.510
如果您有一个

00:22:01.220 --> 00:22:07.100
常规方法上的命令处理程序

00:22:04.510 --> 00:22:09.080
说你想更新一些

00:22:07.100 --> 00:22:12.590
状态，因此在这种情况下，您可以说

00:22:09.080 --> 00:22:17.060
投诉已解决，那么您可以

00:22:12.590 --> 00:22:20.470
可能会放在和幸福伟大或

00:22:17.060 --> 00:22:23.060
您想传递的东西

00:22:20.470 --> 00:22:25.820
但我们坚持对文件的投诉

00:22:23.060 --> 00:22:28.220
现在，我们有一些状态要保持

00:22:25.820 --> 00:22:31.040
这是投诉编号，我们得到

00:22:28.220 --> 00:22:33.230
从事件开始，所以当我们加载一个

00:22:31.040 --> 00:22:36.280
现有投诉称这种方法

00:22:33.230 --> 00:22:38.570
并且投诉ID设置为

00:22:36.280 --> 00:22:42.560
那和那个中包含的标识符

00:22:38.570 --> 00:22:44.510
就像我早先说的那样

00:22:42.560 --> 00:22:47.770
基于目的的事件

00:22:44.510 --> 00:22:47.770
正确的组件

00:22:48.140 --> 00:22:51.710
你正在补充水分的状态

00:22:50.269 --> 00:22:54.850
在该事件中的投诉

00:22:51.710 --> 00:22:58.519
经理基本上是正确的

00:22:54.850 --> 00:23:00.620
是的，当您添加更多命令事件时

00:22:58.519 --> 00:23:03.230
通过您的合计，您将拥有更多

00:23:00.620 --> 00:23:05.539
这些事件源处理程序方法

00:23:03.230 --> 00:23:08.000
但说在某些情况下，您甚至会拥有

00:23:05.539 --> 00:23:09.799
应用适用于事件的方法

00:23:08.000 --> 00:23:12.409
聚合本身不感兴趣

00:23:09.799 --> 00:23:14.779
只是说有些改变

00:23:12.409 --> 00:23:17.450
但是如果这种改变不影响任何

00:23:14.779 --> 00:23:19.519
其他命令，那么就不需要

00:23:17.450 --> 00:23:22.880
保持状态在你的

00:23:19.519 --> 00:23:24.980
投诉对象，但是这个事件

00:23:22.880 --> 00:23:26.539
采购经理不是一个好地方

00:23:24.980 --> 00:23:29.510
建立正确的业务逻辑

00:23:26.539 --> 00:23:31.519
运用您正在录制的过去

00:23:29.510 --> 00:23:33.919
过去这里就是你正在做的

00:23:31.519 --> 00:23:37.309
聚合恰恰是非常

00:23:33.919 --> 00:23:38.929
重要的是要意识到你永远不会拒绝

00:23:37.309 --> 00:23:42.169
活动权不要放任何

00:23:38.929 --> 00:23:45.590
验证这里只是想像我们没有

00:23:42.169 --> 00:23:49.309
放入的的长度

00:23:45.590 --> 00:23:51.320
公司在这里，所以我们有一些

00:23:49.309 --> 00:23:53.299
公司，或者至少我们有一些

00:23:51.320 --> 00:23:54.830
运行此命令后数据库中的数据

00:23:53.299 --> 00:23:57.559
一段时间没有申请

00:23:54.830 --> 00:23:59.510
公司数据，如果我们将

00:23:57.559 --> 00:24:02.090
在这里验证我们将无法

00:23:59.510 --> 00:24:04.250
减轻他们的抱怨

00:24:02.090 --> 00:24:05.870
将被拒绝，所以不要拒绝

00:24:04.250 --> 00:24:07.730
事件处理程序只接受任何内容

00:24:05.870 --> 00:24:09.830
碰巧你可能想带

00:24:07.730 --> 00:24:12.080
采取纠正措施

00:24:09.830 --> 00:24:15.769
你真的不想拥有

00:24:12.080 --> 00:24:17.330
发生了，但还是发生了

00:24:15.769 --> 00:24:25.880
不要在这里放任何验证

00:24:17.330 --> 00:24:28.909
接受得好，他们接受历史，所以

00:24:25.880 --> 00:24:31.370
我们现在拥有的是我们有一些得到

00:24:28.909 --> 00:24:33.440
返回我们数据的映射，我们有一个

00:24:31.370 --> 00:24:36.350
允许我们发送的命令网关

00:24:33.440 --> 00:24:38.480
发出事件的命令，但

00:24:36.350 --> 00:24:40.539
有一个一小块的失踪， 

00:24:38.480 --> 00:24:43.429
就是要同步这两个模型

00:24:40.539 --> 00:24:44.990
对，我们已经创建了查询模型

00:24:43.429 --> 00:24:47.179
创建了一个命令模型

00:24:44.990 --> 00:24:50.870
投诉，但现在我们需要更新

00:24:47.179 --> 00:24:53.630
基于该查询模型

00:24:50.870 --> 00:24:55.559
实际发生的事情，所以我们需要做什么

00:24:53.630 --> 00:25:00.149
是我们

00:24:55.559 --> 00:25:02.610
径向分量是公共类

00:25:00.149 --> 00:25:05.370
如您所见，我正在用

00:25:02.610 --> 00:25:07.830
相同的春季良好应用类别

00:25:05.370 --> 00:25:10.740
在一个更大的项目中

00:25:07.830 --> 00:25:14.129
可能不想这样做，但是

00:25:10.740 --> 00:25:17.249
为了快，我们可以做到

00:25:14.129 --> 00:25:25.169
这样，我们做到这一点，我们称之为

00:25:17.249 --> 00:25:32.279
符合条件的查询对象

00:25:25.169 --> 00:25:34.080
将有一个事件处理程序，它

00:25:32.279 --> 00:25:36.450
听取投诉事件，以便

00:25:34.080 --> 00:25:38.789
如您所见， 

00:25:36.450 --> 00:25:41.009
方法的定义事件在哪里

00:25:38.789 --> 00:25:43.649
我们感兴趣的是还有一些额外的

00:25:41.009 --> 00:25:46.049
您可以传入以获得的参数

00:25:43.649 --> 00:25:48.749
示例元数据和值

00:25:46.049 --> 00:25:52.230
事件或什至是时间戳

00:25:48.749 --> 00:25:55.169
事件等，但在这种情况下，那就是

00:25:52.230 --> 00:26:01.409
不太重要，当然我们需要

00:25:55.169 --> 00:26:05.669
我们这里的小仓库和对象

00:26:01.409 --> 00:26:11.029
我们可以从中取出存储库

00:26:05.669 --> 00:26:14.399
连接到那里，我们可以保存一个新的

00:26:11.029 --> 00:26:17.690
基于的投诉查询对象

00:26:14.399 --> 00:26:17.690
我们从活动中获得的信息

00:26:20.630 --> 00:26:29.940
就像这样，太棒了

00:26:25.770 --> 00:26:37.530
是我们最后应该丢失的一块

00:26:29.940 --> 00:26:38.880
能够运行该应用程序，并且

00:26:37.530 --> 00:26:44.630
永远是你的一件事

00:26:38.880 --> 00:26:44.630
忘记了，但是如果我们做了春天会告诉我们

00:26:44.810 --> 00:26:56.310
没有，所以我们可以回过头来

00:26:52.920 --> 00:27:00.150
小控制台，我们要发送

00:26:56.310 --> 00:27:03.660
发布请求，我们想传递一个

00:27:00.150 --> 00:27:08.130
标头，告诉应用程序我们

00:27:03.660 --> 00:27:13.040
已经向Jason发送了一些数据， 

00:27:08.130 --> 00:27:15.630
它，这是一个小的JSON文档

00:27:13.040 --> 00:27:16.920
公司就是我们要做的

00:27:15.630 --> 00:27:24.090
抱怨让我们抱怨

00:27:16.920 --> 00:27:25.800
苹果，然后描述我现在在

00:27:24.090 --> 00:27:31.650
 Windows机器抱怨苹果

00:27:25.800 --> 00:27:33.300
但是想像一下我的Escape键丢失了， 

00:27:31.650 --> 00:27:35.280
这就是为什么我使用Windows计算机

00:27:33.300 --> 00:27:41.850
再次因为我没有逃脱

00:27:35.280 --> 00:27:44.730
钥匙请寄一个去

00:27:41.850 --> 00:27:47.060
我们想将其发送到本地主机

00:27:44.730 --> 00:27:51.380
 8080 

00:27:47.060 --> 00:27:53.210
我们去了，但这是我们的UUID 

00:27:51.380 --> 00:27:56.930
正在发送，请注意这一点

00:27:53.210 --> 00:28:00.140
渲染我猜这两个三

00:27:56.930 --> 00:28:02.990
速度也是五个，其余的

00:28:00.140 --> 00:28:05.030
这是回应，所以不要

00:28:02.990 --> 00:28:08.030
复制所有内容，然后复制的错误

00:28:05.030 --> 00:28:10.610
找不到该标识符，并且在您的

00:28:08.030 --> 00:28:16.040
在您的数据库中，所以实际上现在我们

00:28:10.610 --> 00:28:19.040
可以去本地主机8080，这是

00:28:16.040 --> 00:28:22.400
我们最后的方法正确，所以我们得到了

00:28:19.040 --> 00:28:24.650
投诉ID和哇，那么我们会看到

00:28:22.400 --> 00:28:26.990
公司和说明，我们可以

00:28:24.650 --> 00:28:30.500
即使我们采用的标识符是

00:28:26.990 --> 00:28:33.440
我们创建的另一个映射，我们

00:28:30.500 --> 00:28:36.080
距离您看到的正方形一倍

00:28:33.440 --> 00:28:37.550
括号现在不存在

00:28:36.080 --> 00:28:39.470
寄给我一个，让我们放另一个

00:28:37.550 --> 00:28:49.370
抱怨只是为了使它稍微多一点

00:28:39.470 --> 00:28:54.410
有趣的微软很好，我们是什么

00:28:49.370 --> 00:29:03.530
抱怨bash并不总是

00:28:54.410 --> 00:29:07.840
那里工作很好，我们可以，我放了一个

00:29:03.530 --> 00:29:07.840
小报价，它没有在这里关闭

00:29:10.930 --> 00:29:21.320
看到它是Windows bash不存在，我们

00:29:15.710 --> 00:29:23.350
去那正是我们的抱怨啊和

00:29:21.320 --> 00:29:27.370
你去那里，你现在有两个

00:29:23.350 --> 00:29:31.520
这是另一个抱怨

00:29:27.370 --> 00:29:34.310
没错，那是一个令人窒息的

00:29:31.520 --> 00:29:35.960
单节点，但是有没有办法

00:29:34.310 --> 00:29:38.120
我采取什么将电话创建一个

00:29:35.960 --> 00:29:40.040
只读视图，如果我想

00:29:38.120 --> 00:29:41.990
捕获统计数据有某种方式

00:29:40.040 --> 00:29:43.660
嗯，我不想做所有的事情

00:29:41.990 --> 00:29:45.890
在这里，我想保留这些知识

00:29:43.660 --> 00:29:48.620
在其他地方进行优化

00:29:45.890 --> 00:29:51.710
一种特殊的存储方式

00:29:48.620 --> 00:29:53.570
你认为有两个吗

00:29:51.710 --> 00:29:55.370
部队现在在比赛，所以有

00:29:53.570 --> 00:29:59.000
最安全的说你知道我有

00:29:55.370 --> 00:30:01.550
您需要这种不同的数据视图

00:29:59.000 --> 00:30:03.620
看一些统计数据，所以让我们说

00:30:01.550 --> 00:30:06.770
特定投诉的数量

00:30:03.620 --> 00:30:08.180
公司，但基本上就是这样

00:30:06.770 --> 00:30:10.820
说好创建一个不同的模型

00:30:08.180 --> 00:30:12.560
然后微服务说的很好

00:30:10.820 --> 00:30:14.090
如果您执行其他操作

00:30:12.560 --> 00:30:17.540
另一个合适的应用程序不要

00:30:14.090 --> 00:30:20.060
不要将所有这些功能放在一个

00:30:17.540 --> 00:30:24.080
实际上是新的整体，所以我们可以

00:30:20.060 --> 00:30:28.670
我们可以将这些更改推到两个

00:30:24.080 --> 00:30:30.710
 AMQP，所以让我们发布事件

00:30:28.670 --> 00:30:32.960
这个应用程序，因为现在我们

00:30:30.710 --> 00:30:35.690
事件总线仅包含在其中

00:30:32.960 --> 00:30:39.110
节点正确，所以我们想公开它

00:30:35.690 --> 00:30:43.360
我们可以这样说： 

00:30:39.110 --> 00:30:49.370
 AMQP点交换等于投诉

00:30:43.360 --> 00:30:51.500
这样的事件，那是一回事

00:30:49.370 --> 00:30:54.850
我们需要做的，另一个是做

00:30:51.500 --> 00:30:54.850
确保行动

00:30:54.980 --> 00:31:04.830
 mqp在我们去的classpath上

00:31:00.060 --> 00:31:07.590
现在也释放候选人

00:31:04.830 --> 00:31:10.230
 axel mqp模块位于类路径上，并且

00:31:07.590 --> 00:31:15.510
它提供具有以下功能的动作

00:31:10.230 --> 00:31:17.400
发送数据到两个AMQP 

00:31:15.510 --> 00:31:22.230
告诉我们我们想要的交流

00:31:17.400 --> 00:31:26.100
将这些事件转发给的是

00:31:22.230 --> 00:31:29.880
投诉事件已交换，我们需要

00:31:26.100 --> 00:31:33.660
定义这些交流，所以在

00:31:29.880 --> 00:31:36.420
 rabbim队列中有一个随机队列

00:31:33.660 --> 00:31:40.910
它基于开放的经纪人

00:31:36.420 --> 00:31:42.810
源一个称为AMQP的开放协议AMQP 

00:31:40.910 --> 00:31:45.650
描述结构

00:31:42.810 --> 00:31:49.950
消息队列中的基础架构和

00:31:45.650 --> 00:31:51.660
在AMQP中，您有轻微的了解

00:31:49.950 --> 00:31:53.580
在经典的安排上的扭曲

00:31:51.660 --> 00:31:56.000
消息告诉您是否习惯

00:31:53.580 --> 00:31:58.950
示例JMS，您将习惯于

00:31:56.000 --> 00:32:02.400
生产者和

00:31:58.950 --> 00:32:05.130
消费者连接RabbitMQ和QP 

00:32:02.400 --> 00:32:08.030
通常有一些额外的

00:32:05.130 --> 00:32:11.640
间接生产者将消息发送到

00:32:08.030 --> 00:32:15.000
交流，然后交流路线

00:32:11.640 --> 00:32:18.060
消息发送给消费者使用的队列

00:32:15.000 --> 00:32:21.330
然后会听，所以您正在定义

00:32:18.060 --> 00:32:25.170
现在是这里的运动部分

00:32:21.330 --> 00:32:28.680
交换队列和绑定

00:32:25.170 --> 00:32:32.520
在这两个之间，所以我想

00:32:28.680 --> 00:32:40.320
确保我得到正确的名字，所以我

00:32:32.520 --> 00:32:44.960
定义一个交流，然后我要去

00:32:40.320 --> 00:32:44.960
定义队列

00:32:46.190 --> 00:32:54.600
只要给他们一个名字就可以了

00:32:50.480 --> 00:32:56.100
队列构建器点让我们创建一个持久的

00:32:54.600 --> 00:32:59.249
排队，这将是一个队列

00:32:56.100 --> 00:33:03.330
生存并重新启动，我们称之为

00:32:59.249 --> 00:33:09.179
投诉事件以及为什么不保留它

00:33:03.330 --> 00:33:10.889
填充，现在我们需要告诉我们的AMQP 

00:33:09.179 --> 00:33:14.609
在这种情况下我们的消息经纪人

00:33:10.889 --> 00:33:17.669
邮件发送给投诉

00:33:14.609 --> 00:33:21.119
事件交换需要转发或

00:33:17.669 --> 00:33:25.529
放置在投诉事件队列中，因此

00:33:21.119 --> 00:33:28.830
我们通过绑定来做到这一点，我们可以说

00:33:25.529 --> 00:33:35.789
从绑定构建器返回的点绑定

00:33:28.830 --> 00:33:38.159
我们与之交流的队列

00:33:35.789 --> 00:33:39.869
您要转发哪些邮件

00:33:38.159 --> 00:33:43.470
到哪个队列，以便您可以传递

00:33:39.869 --> 00:33:44.639
过滤器和类似的东西，我们不会

00:33:43.470 --> 00:33:50.220
想做我们想发送的

00:33:44.639 --> 00:33:53.070
一切，所以我们将使用星，然后

00:33:50.220 --> 00:33:54.840
最后，因为这只是定义

00:33:53.070 --> 00:33:56.460
我们希望能够使用这些

00:33:54.840 --> 00:34:00.059
不会自动交换

00:33:56.460 --> 00:34:02.309
创建它们，这是一个mqp，非常

00:34:00.059 --> 00:34:04.409
申明的共同点

00:34:02.309 --> 00:34:05.999
它需要的队列，它们是

00:34:04.409 --> 00:34:08.309
由他们自动创建

00:34:05.999 --> 00:34:09.389
经纪人，所以我可以创建它

00:34:08.309 --> 00:34:10.859
关于mqp 

00:34:09.389 --> 00:34:11.940
对，这是关于它的一件好事

00:34:10.859 --> 00:34:14.190
 AMQP是您实际上可以

00:34:11.940 --> 00:34:15.990
以标准方式编程

00:34:14.190 --> 00:34:18.659
创造创造那些运动的部分

00:34:15.990 --> 00:34:21.000
创建交易所和队列，以及

00:34:18.659 --> 00:34:23.040
在部署中完全一样

00:34:21.000 --> 00:34:25.109
不需要通过我不知道

00:34:23.040 --> 00:34:27.240
部署文件到

00:34:25.109 --> 00:34:29.069
部署此之前的操作人员

00:34:27.240 --> 00:34:30.809
应用程序确保这些队列存在

00:34:29.069 --> 00:34:34.260
现在您可以定义自己知道

00:34:30.809 --> 00:34:36.299
基础架构实际上就是代码，是的

00:34:34.260 --> 00:34:39.780
所以现在我们有我们的管理员，我们

00:34:36.299 --> 00:34:43.740
宣布我们的交流，这仅仅是

00:34:39.780 --> 00:34:47.820
春天的魔法再次对你

00:34:43.740 --> 00:34:55.740
只需输入名称密钥密钥交换

00:34:47.820 --> 00:35:02.550
然后您声明q是，然后您

00:34:55.740 --> 00:35:04.530
声明绑定，所以这很正常

00:35:02.550 --> 00:35:08.160
我们的弹簧配置接线

00:35:04.530 --> 00:35:15.990
我们现在在这里可以重新启动她

00:35:08.160 --> 00:35:20.580
我有我的QP管理人员

00:35:15.990 --> 00:35:22.730
控制台打开，我们应该看到一个Q 

00:35:20.580 --> 00:35:26.220
确定是否其他啊，我们去

00:35:22.730 --> 00:35:29.070
所以我们看到我们的投诉事件队列

00:35:26.220 --> 00:35:34.770
它显然是完全空的，让我们

00:35:29.070 --> 00:35:39.150
表示希望我们或发表我们的投诉

00:35:34.770 --> 00:35:43.020
再次，这不能很好地工作，现在

00:35:39.150 --> 00:35:45.390
一分钟后有两条消息

00:35:43.020 --> 00:35:48.180
等待，所以我们的应用程序是现在

00:35:45.390 --> 00:35:50.490
推送所有的消息

00:35:48.180 --> 00:35:54.230
我们正在创建的事件排队

00:35:50.490 --> 00:35:56.170
所以现在该建立另一侧了

00:35:54.230 --> 00:35:58.119
 [音乐] 

00:35:56.170 --> 00:36:00.910
对消费者而言，到目前为止，您只是

00:35:58.119 --> 00:36:04.599
显示到目前为止，您正在显示我们

00:36:00.910 --> 00:36:07.359
 Rabbitmq还有其他方法可以

00:36:04.599 --> 00:36:08.819
分发这个即将到来

00:36:07.359 --> 00:36:11.290
除了驾驶队列以外还要使用其他东西

00:36:08.819 --> 00:36:14.200
可能是的，我们真的在未来

00:36:11.290 --> 00:36:18.660
看着卡夫卡分发事件

00:36:14.200 --> 00:36:23.140
我的意思是，这是一个非常普遍的共同点

00:36:18.660 --> 00:36:24.760
共享事件的一项技术，但

00:36:23.140 --> 00:36:28.750
另一个可能是受到威胁的人

00:36:24.760 --> 00:36:30.970
代理机构，我很抱歉，可能是

00:36:28.750 --> 00:36:33.880
另一个将是屏幕创新

00:36:30.970 --> 00:36:36.309
只是使用频道而已

00:36:33.880 --> 00:36:38.109
已经有转发的可能性

00:36:36.309 --> 00:36:40.900
到频道的事件以及

00:36:38.109 --> 00:36:42.430
基本上可以使用spring 

00:36:40.900 --> 00:36:45.430
云将其转发给任何

00:36:42.430 --> 00:36:48.490
我猜是春天云支持

00:36:45.430 --> 00:36:49.960
将成为任何一种方式

00:36:48.490 --> 00:36:51.910
另一种有趣的方式

00:36:49.960 --> 00:36:54.549
实际上将事件存储用作

00:36:51.910 --> 00:36:57.400
消息源以及消息源

00:36:54.549 --> 00:36:59.079
可以有这些成分，我的意思是

00:36:57.400 --> 00:37:00.430
已存储在事件存储中的事件

00:36:59.079 --> 00:37:04.210
无论如何，所以你可以有一个组件

00:37:00.430 --> 00:37:07.420
跟踪事件存储在其中

00:37:04.210 --> 00:37:11.260
事件存储，然后它将

00:37:07.420 --> 00:37:14.040
记得用

00:37:11.260 --> 00:37:16.540
每个事件收到的令牌

00:37:14.040 --> 00:37:19.569
这样你就可以重建职业

00:37:16.540 --> 00:37:23.109
只需投掷即可完全建模

00:37:19.569 --> 00:37:25.720
一切都删除并删除令牌

00:37:23.109 --> 00:37:27.609
它会在何时启动

00:37:25.720 --> 00:37:30.099
它没有令牌，所以我们从

00:37:27.609 --> 00:37:34.180
开始和重建

00:37:30.099 --> 00:37:35.710
一切强大，但现在对我们而言

00:37:34.180 --> 00:37:37.540
统计应用程序

00:37:35.710 --> 00:37:40.500
保持简单，我们只是要

00:37:37.540 --> 00:37:45.309
创建一个小的Web应用程序并

00:37:40.500 --> 00:37:48.160
 AMQP Spring Home是否可以作为来源

00:37:45.309 --> 00:37:52.839
是的，我们称之为演示投诉统计

00:37:48.160 --> 00:37:56.130
下载我们解压缩演示的zip文件

00:37:52.839 --> 00:37:56.130
投诉统计

00:37:57.020 --> 00:38:07.500
我们从IntelliJ开始

00:38:04.440 --> 00:38:12.630
一个新的窗口作为

00:38:07.500 --> 00:38:19.020
当然，我们需要添加一个依赖项

00:38:12.630 --> 00:38:31.460
作用在弹簧启动启动器上不

00:38:19.020 --> 00:38:31.460
一个，我们还将在AMQP上添加行为

00:38:34.580 --> 00:38:41.760
所以现在让我们进入应用程序

00:38:38.520 --> 00:38:46.290
我们需要做的是获取

00:38:41.760 --> 00:38:53.820
那些来自频道的事件

00:38:46.290 --> 00:39:02.340
对，是的，我认为是豆子，我们

00:38:53.820 --> 00:39:05.490
返回spring AMQP消息源，因此

00:39:02.340 --> 00:39:09.150
这是一个允许

00:39:05.490 --> 00:39:12.770
我们要处理的事件处理程序

00:39:09.150 --> 00:39:17.270
一秒钟创建即可从AMQP中读取

00:39:12.770 --> 00:39:25.500
排队，然后我们称之为

00:39:17.270 --> 00:39:30.330
以及正常情况下的投诉事件

00:39:25.500 --> 00:39:34.510
你将不得不建立一个简单的消息

00:39:30.330 --> 00:39:36.710
侦听器容器将其忘记，然后

00:39:34.510 --> 00:39:39.930
 [音乐] 

00:39:36.710 --> 00:39:41.790
我来注入一下

00:39:39.930 --> 00:39:44.670
序列化器是您从

00:39:41.790 --> 00:39:46.320
 Springwood入门版，所以我们有

00:39:44.670 --> 00:39:48.420
创建一点折叠

00:39:46.320 --> 00:39:50.370
消息转换器，告诉我们如何

00:39:48.420 --> 00:39:53.490
从名称转换可能是消息

00:39:50.370 --> 00:39:55.950
到轴突消息，但有一个

00:39:53.490 --> 00:40:00.620
我们可以做的小技巧，因为响

00:39:55.950 --> 00:40:03.600
有更好的表达方式

00:40:00.620 --> 00:40:05.280
因为我说一个事实是

00:40:03.600 --> 00:40:07.780
你想从队列中读取

00:40:05.280 --> 00:40:09.430
定义弹簧梅塞尔

00:40:07.780 --> 00:40:11.500
简单消息侦听器容器计划

00:40:09.430 --> 00:40:15.520
虽然还有一个把戏

00:40:11.500 --> 00:40:18.580
仅在此处覆盖消息传递方法

00:40:15.520 --> 00:40:21.550
保持原样，然后放入

00:40:18.580 --> 00:40:24.910
兔子监听器，我们可以说队列

00:40:21.550 --> 00:40:33.790
我们想听的是我们做了什么

00:40:24.910 --> 00:40:39.480
如果事件排队，则将其命名为投诉

00:40:33.790 --> 00:40:43.110
投诉事件正确的投诉事件

00:40:39.480 --> 00:40:47.350
因此spring将调用此方法， 

00:40:43.110 --> 00:40:49.450
然后，此方法将导致一个事件

00:40:47.350 --> 00:40:51.040
处理程序在某处被调用

00:40:49.450 --> 00:40:52.650
当然有那个事件，有

00:40:51.040 --> 00:40:56.860
我们也需要定义一些东西

00:40:52.650 --> 00:41:05.740
让我们制造一点抱怨

00:40:56.860 --> 00:41:07.060
统计不是AB Union的班级

00:41:05.740 --> 00:41:12.670
我们要创造一点休息

00:41:07.060 --> 00:41:17.020
控制器，我们需要一个API 

00:41:12.670 --> 00:41:21.700
有一个公共的事件处理程序

00:41:17.020 --> 00:41:23.920
甚至不必是现在

00:41:21.700 --> 00:41:26.380
当然我们需要另一个的API 

00:41:23.920 --> 00:41:30.790
申请权，我们需要一些方法

00:41:26.380 --> 00:41:33.850
共享信息和一种方式

00:41:30.790 --> 00:41:36.960
要做到这一点是通过复制类

00:41:33.850 --> 00:41:40.480
不是你想做的事

00:41:36.960 --> 00:41:43.990
假设现实生活中您会有

00:41:40.480 --> 00:41:48.490
依赖于jar文件或什至

00:41:43.990 --> 00:41:51.850
更好的是只有正式的API 

00:41:48.490 --> 00:41:54.130
实际上是序列化的

00:41:51.850 --> 00:41:55.840
该事件的形式，它有一个

00:41:54.130 --> 00:41:58.900
发布的文档，这样您就可以

00:41:55.840 --> 00:42:01.690
序列化器将其转换为

00:41:58.900 --> 00:42:03.790
 JSON文档，并通过AMQP发送

00:42:01.690 --> 00:42:07.150
然后您只需要分享

00:42:03.790 --> 00:42:08.800
日期JSON文档结构化但

00:42:07.150 --> 00:42:10.810
从现在开始，制作人和

00:42:08.800 --> 00:42:15.420
消费者是基于基础的应用程序

00:42:10.810 --> 00:42:18.900
我们可以使用事件类

00:42:15.420 --> 00:42:20.040
只是让他们不是临终关怀和

00:42:18.900 --> 00:42:22.530
好东西是他们没有通过

00:42:20.040 --> 00:42:23.990
围绕投诉汇总或

00:42:22.530 --> 00:42:26.430
他们经过的Jaypee实体

00:42:23.990 --> 00:42:31.380
活动，仅此而已

00:42:26.430 --> 00:42:33.089
建立一个所以他们只是他们有一个

00:42:31.380 --> 00:42:34.770
这些事件是

00:42:33.089 --> 00:42:37.710
不是非技术性的，他们非常

00:42:34.770 --> 00:42:40.710
功能对象，它们应该使

00:42:37.710 --> 00:42:44.609
对您的产品所有者非常有帮助，或者

00:42:40.710 --> 00:42:47.660
不管你是什么商人

00:42:44.609 --> 00:42:47.660
建立这个应用程式

00:42:48.260 --> 00:42:58.910
所以让我们创建一些记忆

00:42:52.390 --> 00:43:04.089
出现的字符串是

00:42:58.910 --> 00:43:09.200
公司名称-原子长

00:43:04.089 --> 00:43:12.560
统计的投诉数量

00:43:09.200 --> 00:43:15.410
是的，我们将创建一个并发

00:43:12.560 --> 00:43:20.150
哈希图，现在我们可以说统计

00:43:15.410 --> 00:43:23.240
如果不存在则开始计算，如果存在

00:43:20.150 --> 00:43:25.250
否，第一个投诉是

00:43:23.240 --> 00:43:29.599
我们要投诉一家公司

00:43:25.250 --> 00:43:31.490
创建一个新的原子长， 

00:43:29.599 --> 00:43:34.700
否则我们想得到它，然后我们

00:43:31.490 --> 00:43:40.180
想要增加该值和

00:43:34.700 --> 00:43:40.180
当然我们要有一点要求

00:43:40.510 --> 00:43:49.700
一无所获，我认为这并不意味着我们

00:43:46.010 --> 00:43:52.420
想说我们有一个字符串映射

00:43:49.700 --> 00:43:57.069
原子长

00:43:52.420 --> 00:44:00.099
这是统计数据非常好用的词

00:43:57.069 --> 00:44:02.019
我们可以返回统计信息

00:44:00.099 --> 00:44:04.029
没有什么特别的，我们需要

00:44:02.019 --> 00:44:08.849
在这里做所以这就是我们的

00:44:04.029 --> 00:44:13.779
我们的API ID是一个统计数据，例如

00:44:08.849 --> 00:44:16.089
那根棍子哦，它仍然有

00:44:13.779 --> 00:44:20.170
烦人的你很难打字

00:44:16.089 --> 00:44:22.809
不同顺序的关键Isis过多

00:44:20.170 --> 00:44:26.109
您需要输入的内容，因此我们几乎

00:44:22.809 --> 00:44:29.769
那里我们看起来不错，我们有

00:44:26.109 --> 00:44:32.049
此消息源使我们能够

00:44:29.769 --> 00:44:35.680
从队列中读取，我们有一个事件

00:44:32.049 --> 00:44:38.769
经理，但行动组织这些

00:44:35.680 --> 00:44:41.950
所谓的事件处理程序

00:44:38.769 --> 00:44:45.460
处理器和处理器默认情况下

00:44:41.950 --> 00:44:48.160
他们从事件总线而不是从事件总线读取

00:44:45.460 --> 00:44:51.309
其他来源，所以我们需要告诉

00:44:48.160 --> 00:44:53.920
轴突此事件处理程序需要

00:44:51.309 --> 00:44:56.319
放入实际读取的处理器

00:44:53.920 --> 00:44:59.740
从队列而不是从事件

00:44:56.319 --> 00:45:01.690
总线本身，默认情况下为

00:44:59.740 --> 00:45:03.640
处理器是的名称

00:45:01.690 --> 00:45:06.430
包装，所以在这种情况下会很平静

00:45:03.640 --> 00:45:10.089
点的例子不是很好

00:45:06.430 --> 00:45:14.019
名称，所以我们现在可以显式定义

00:45:10.089 --> 00:45:18.039
希望这个出现在我可以

00:45:14.019 --> 00:45:20.220
成为mqp事件之类的东西

00:45:18.039 --> 00:45:22.660
我知道没什么大不了的

00:45:20.220 --> 00:45:26.079
现在在我们的属性应用中

00:45:22.660 --> 00:45:29.270
我们可以说轴突点让我仔细检查

00:45:26.079 --> 00:45:34.280
对于主要的错别字

00:45:29.270 --> 00:45:36.110
复制/粘贴在那里，我们会发现

00:45:34.280 --> 00:45:38.450
意外事件结束点处理器

00:45:36.110 --> 00:45:41.360
在这里我们指定的名称

00:45:38.450 --> 00:45:44.750
我们拥有的处理器

00:45:41.360 --> 00:45:48.470
已经忘记并保留事件了， 

00:45:44.750 --> 00:45:51.350
我们说这不是

00:45:48.470 --> 00:45:55.940
统计信息队列或我们叫什么名字

00:45:51.350 --> 00:45:57.730
给它投诉事件

00:45:55.940 --> 00:46:01.730
那不是事实那不是来源

00:45:57.730 --> 00:46:04.820
来源是这个名字仍然

00:46:01.730 --> 00:46:07.970
投诉事件，所以这实际上是

00:46:04.820 --> 00:46:10.610
我们想要nqp事件的来源

00:46:07.970 --> 00:46:14.120
要读取的处理器，仅此而已

00:46:10.610 --> 00:46:20.530
那是无檐小便帽，只是个大名声

00:46:14.120 --> 00:46:26.240
此消息源正确无误

00:46:20.530 --> 00:46:33.830
所以我的意思是不是，是的，让我们

00:46:26.240 --> 00:46:35.720
运行它，让我们运行并查看，以便有

00:46:33.830 --> 00:46:38.990
一些消息已经在等待，所以

00:46:35.720 --> 00:46:42.460
应该马上耗尽我们的队列

00:46:38.990 --> 00:46:44.660
是的，当然端口已经在使用中

00:46:42.460 --> 00:46:47.780
所有可能出错的事情

00:46:44.660 --> 00:46:54.160
这是出问题的那可怜的吗

00:46:47.780 --> 00:46:54.160
是80 81足以修复

00:47:02.489 --> 00:47:06.180
让我们看看我们的队列是否现在是空的

00:47:05.440 --> 00:47:10.269
它消失了

00:47:06.180 --> 00:47:10.900
所以我们去localhost 8080 1看看

00:47:10.269 --> 00:47:15.670
怎么了

00:47:10.900 --> 00:47:19.650
嘿，微软的投诉还不错

00:47:15.670 --> 00:47:22.869
现在说，如果我们最终能做到

00:47:19.650 --> 00:47:25.359
让我们来一些苹果的投诉， 

00:47:22.869 --> 00:47:27.640
刷新这个，你去这里是你的

00:47:25.359 --> 00:47:30.279
苹果投诉，我们可以去这里

00:47:27.640 --> 00:47:33.459
看看实际上是哪个投诉

00:47:30.279 --> 00:47:35.430
那是我们的另一项服务，还是Apple 

00:47:33.459 --> 00:47:37.599
说明我的转义键丢失，并且

00:47:35.430 --> 00:47:39.670
当然这个应用程序正在运行

00:47:37.599 --> 00:47:41.709
在我们所处的另一个之前

00:47:39.670 --> 00:47:46.170
我们在这里存储信息

00:47:41.709 --> 00:47:56.739
还没有发送到mqp等

00:47:46.170 --> 00:48:02.380
那是另一件事吗

00:47:56.739 --> 00:48:08.259
怪我不如我想的好

00:48:02.380 --> 00:48:10.059
期待你去那里，是的

00:48:08.259 --> 00:48:13.479
您在那里抱怨的另一项苹果法律

00:48:10.059 --> 00:48:15.459
你会很酷地看着

00:48:13.479 --> 00:48:17.619
简单的方法来推理它，如果您

00:48:15.459 --> 00:48:19.269
了解如何使

00:48:17.619 --> 00:48:20.979
逻辑上的组件

00:48:19.269 --> 00:48:22.809
同一注释中的命令和查询

00:48:20.979 --> 00:48:25.329
当您这样做时，这很容易

00:48:22.809 --> 00:48:28.900
跨分布式系统

00:48:25.329 --> 00:48:30.849
确实非常方便，而且没有

00:48:28.900 --> 00:48:32.259
真的很重要，我的意思是我可以复制我的

00:48:30.849 --> 00:48:34.180
事件处理程序并将其放在另一个

00:48:32.259 --> 00:48:35.859
应用程序，我们将它只是

00:48:34.180 --> 00:48:38.019
在那里正确地工作，那就是

00:48:35.859 --> 00:48:40.900
这就是位置的透明度

00:48:38.019 --> 00:48:42.160
给你和事实，你是

00:48:40.900 --> 00:48:44.019
分配只是一个问题

00:48:42.160 --> 00:48:47.289
配置逻辑本身不

00:48:44.019 --> 00:48:49.630
更改仅仅是因为应用程序

00:48:47.289 --> 00:48:52.089
分散，所以您现在可以真正专注

00:48:49.630 --> 00:48:54.579
开始专注于获得

00:48:52.089 --> 00:48:58.349
首先是业务逻辑，然后是什么时候

00:48:54.579 --> 00:49:02.109
是的，您可以解决

00:48:58.349 --> 00:49:03.910
痛点或您要做的部分

00:49:02.109 --> 00:49:06.130
想要扩展或想要

00:49:03.910 --> 00:49:09.309
从那里拿出来

00:49:06.130 --> 00:49:12.459
看起来合适，所以您不必开始

00:49:09.309 --> 00:49:14.810
拥有庞大的分布式系统，但

00:49:12.459 --> 00:49:19.790
你可以进化成一个

00:49:14.810 --> 00:49:22.610
或者随着您的应用程序变得越来越强大

00:49:19.790 --> 00:49:26.150
有没有什么外卖的东西

00:49:22.610 --> 00:49:27.860
人们什么时候应该明白

00:49:26.150 --> 00:49:30.920
你应该了解的其他任何事情

00:49:27.860 --> 00:49:34.550
在他们看东西之前，任何文字

00:49:30.920 --> 00:49:36.760
你可能会读我很好推荐

00:49:34.550 --> 00:49:39.380
有一篇非常有趣的文章

00:49:36.760 --> 00:49:41.510
实际上由Microsoft称为

00:49:39.380 --> 00:49:43.130
寻求者的旅程

00:49:41.510 --> 00:49:46.160
好的阅读，它给你一个很好的

00:49:43.130 --> 00:49:49.340
这些方面的概述

00:49:46.160 --> 00:49:51.530
不是必不可少的CQRS，但通常

00:49:49.340 --> 00:49:53.000
像事件采购一样与之结合

00:49:51.530 --> 00:49:56.420
平均搜寻者的事件来源是两个

00:49:53.000 --> 00:49:58.810
确保完全不同的事物

00:49:56.420 --> 00:50:00.980
分布式系统和搜寻器

00:49:58.810 --> 00:50:04.280
事件驱动的架构

00:50:00.980 --> 00:50:06.830
分开的东西，但它们结合在一起

00:50:04.280 --> 00:50:09.170
在一起真的很好，就是这样

00:50:06.830 --> 00:50:12.560
该文档还描述了

00:50:09.170 --> 00:50:14.360
叫做寻找者的旅程

00:50:12.560 --> 00:50:16.810
说在里面做得很好

00:50:14.360 --> 00:50:20.720
描述所有这些小事

00:50:16.810 --> 00:50:24.320
可以的建筑组件

00:50:20.720 --> 00:50:26.270
放在一起创造一个非常好的

00:50:24.320 --> 00:50:30.640
实际上是分布式系统

00:50:26.270 --> 00:50:33.310
也很容易维护

00:50:30.640 --> 00:50:39.100
现在的项目是

00:50:33.310 --> 00:50:40.600
朝着300克前进

00:50:39.100 --> 00:50:43.660
它不是您想要的任何功能

00:50:40.600 --> 00:50:47.200
以某种方式拥有或看到

00:50:43.660 --> 00:50:49.200
未来，我的意思是，也想反馈

00:50:47.200 --> 00:50:52.300
你想让人尝试一下哦

00:50:49.200 --> 00:50:53.830
是的，请尝试我的意思是

00:50:52.300 --> 00:50:56.980
释放候选人实际上

00:50:53.830 --> 00:51:01.840
已经有一些公司投入生产

00:50:56.980 --> 00:51:03.310
现在的状态是否

00:51:01.840 --> 00:51:06.160
你想做自己的事

00:51:03.310 --> 00:51:08.380
当然取决于您，但我会

00:51:06.160 --> 00:51:12.010
会问你请尝试一下

00:51:08.380 --> 00:51:15.160
由于我们不是GA，因此我们欢迎您

00:51:12.010 --> 00:51:17.430
我们可以得到的所有反馈

00:51:15.160 --> 00:51:21.970
确保API是最

00:51:17.430 --> 00:51:27.580
尽可能愉快地工作

00:51:21.970 --> 00:51:30.760
那是的，我们仍然可以赚一点钱

00:51:27.580 --> 00:51:33.790
调整到那些API，所以这

00:51:30.760 --> 00:51:36.370
是时候做你了

00:51:33.790 --> 00:51:39.070
知道你被允许你你我

00:51:36.370 --> 00:51:40.930
彼此相识更好

00:51:39.070 --> 00:51:43.720
我不知道十年的大部分时间

00:51:40.930 --> 00:51:46.690
现在，原来的地方之一

00:51:43.720 --> 00:51:48.750
我们所说的是

00:51:46.690 --> 00:51:51.940
我写的有关您的信息Q文章

00:51:48.750 --> 00:51:56.820
多年前关于你知道

00:51:51.940 --> 00:52:00.310
大约5或6年前，我认为是的， 

00:51:56.820 --> 00:52:01.900
那段旅程看着重音

00:52:00.310 --> 00:52:04.300
这是你知道的几年

00:52:01.900 --> 00:52:06.580
现在我们知道了我们必须执行的代码

00:52:04.300 --> 00:52:08.010
写信以获得合理的解决方案

00:52:06.580 --> 00:52:11.650
而运行它只是减少

00:52:08.010 --> 00:52:13.390
没事真的是真的

00:52:11.650 --> 00:52:14.920
做得好，我喜欢这个结果， 

00:52:13.390 --> 00:52:18.940
还有一段漫长的旅程，并认为

00:52:14.920 --> 00:52:20.740
我的意思是，最重要的是

00:52:18.940 --> 00:52:23.620
春天暴力的工作方式，我认为

00:52:20.740 --> 00:52:25.540
我是说我当时真的很惊讶

00:52:23.620 --> 00:52:28.560
我自己，当我开始执行这个

00:52:25.540 --> 00:52:32.830
你会达到这样的地步哦

00:52:28.560 --> 00:52:35.590
但是是的，优秀的演员

00:52:32.830 --> 00:52:37.720
同样，您需要很多

00:52:35.590 --> 00:52:39.220
入门指南

00:52:37.720 --> 00:52:40.840
您需要在事件中使用命令总线

00:52:39.220 --> 00:52:42.260
公交车和您需要的每个集合

00:52:40.840 --> 00:52:44.089
所有这些组成部分

00:52:42.260 --> 00:52:47.180
现在你在上面放一个注释

00:52:44.089 --> 00:52:50.480
有一个春天真的很有效

00:52:47.180 --> 00:52:52.760
和你一起很好地声明东西

00:52:50.480 --> 00:52:56.210
那么春天可以帮助你，当然

00:52:52.760 --> 00:52:59.050
 spring boot 启动器上有一个轴

00:52:56.210 --> 00:53:01.369
在中间但自动配置

00:52:59.050 --> 00:53:03.170
是的，它会自动配置

00:53:01.369 --> 00:53:05.839
您想要并且仍然想要的一切

00:53:03.170 --> 00:53:09.260
允许您修改每一部分

00:53:05.839 --> 00:53:11.960
如您所见，如果

00:53:09.260 --> 00:53:14.270
默认值不是您的默认值，然后您

00:53:11.960 --> 00:53:16.579
可以更改它们，如果您想那样的话

00:53:14.270 --> 00:53:19.369
使其功能强大，所以我认为轴突

00:53:16.579 --> 00:53:22.820
搭配 spring boot 绝对是

00:53:19.369 --> 00:53:24.800
是的，它可以帮助您入门

00:53:22.820 --> 00:53:27.020
很快因为我和 spring boot 

00:53:24.800 --> 00:53:28.670
总是说不是为了让你动起来

00:53:27.020 --> 00:53:31.460
快速启动，但旨在保持

00:53:28.670 --> 00:53:34.700
你走了很长时间，我想

00:53:31.460 --> 00:53:38.390
该组合适用于作品

00:53:34.700 --> 00:53:39.950
我很好，我也非常感谢你

00:53:38.390 --> 00:53:43.130
向我展示所有这些，并为我展示所有

00:53:39.950 --> 00:53:45.920
我们当中非常有口音的人

00:53:43.130 --> 00:53:49.430
非常酷，我想我们

00:53:45.920 --> 00:53:52.730
应该转向问题和答案

00:53:49.430 --> 00:53:54.380
你不认为是的，让我们来回答

00:53:52.730 --> 00:53:56.630
您的问题，如果您有他们使用

00:53:54.380 --> 00:53:58.580
聊天以询问您的问题和

00:53:56.630 --> 00:53:59.830
我们将开始回答他们

00:53:58.580 --> 00:54:03.430
 [音乐] 

00:53:59.830 --> 00:54:05.920
好的，那是一个非常非常非常

00:54:03.430 --> 00:54:08.590
很好地了解埃克森美孚以及如何建立

00:54:05.920 --> 00:54:09.970
你知道基于扬声器的系统

00:54:08.590 --> 00:54:11.800
春天普京口音非常感谢你

00:54:09.970 --> 00:54:13.330
对于ed警报，我们现在有很多

00:54:11.800 --> 00:54:15.490
这里的问题，所以我认为我们应该

00:54:13.330 --> 00:54:19.630
看看我们是否能解决尽可能多的问题

00:54:15.490 --> 00:54:23.170
我们可以尽快

00:54:19.630 --> 00:54:28.270
首先，为什么不使用Spring Cloud 

00:54:23.170 --> 00:54:28.540
流呃，我爱是的，继续

00:54:28.270 --> 00:54:31.270
先

00:54:28.540 --> 00:54:35.590
哦，是的，那是一个非常

00:54:31.270 --> 00:54:38.290
好问题，我们有一些

00:54:35.590 --> 00:54:40.570
对Spring Cloud的支持已经

00:54:38.290 --> 00:54:44.200
实际上是春天的消息

00:54:40.570 --> 00:54:49.480
因此，在其中有一些适配器

00:54:44.200 --> 00:54:53.710
轴突，但我们正在寻找更好的

00:54:49.480 --> 00:54:56.080
与弹簧云集成

00:54:53.710 --> 00:54:58.720
一般，是的，梦想将会是

00:54:56.080 --> 00:55:02.020
其中之一，如果我们也移除了视力

00:54:58.720 --> 00:55:03.400
是的，我是说你可以用弹簧

00:55:02.020 --> 00:55:05.350
云流与此消息传递

00:55:03.400 --> 00:55:07.180
支撑和弹簧好弹簧

00:55:05.350 --> 00:55:09.940
中耕者-是的，消息通道

00:55:07.180 --> 00:55:13.450
为您服务，因此您已经可以使用

00:55:09.940 --> 00:55:18.160
 Spring消息传递适配器上的行为

00:55:13.450 --> 00:55:20.200
用于转换轴突消息

00:55:18.160 --> 00:55:22.270
带来消息然后发送给他们

00:55:20.200 --> 00:55:24.610
在春天的渠道，你可以

00:55:22.270 --> 00:55:28.840
然后有春天的云流为他们

00:55:24.610 --> 00:55:30.550
不管他们支持什么，但是

00:55:28.840 --> 00:55:32.560
我们也在寻找的另一件事是

00:55:30.550 --> 00:55:34.990
春季春季云发现示例

00:55:32.560 --> 00:55:37.450
我的意思是春天的云是

00:55:34.990 --> 00:55:39.370
相当大，而且有很多

00:55:37.450 --> 00:55:41.980
有趣的东西在那里

00:55:39.370 --> 00:55:45.130
但是我们现在的重点是

00:55:41.980 --> 00:55:49.360
在正确使用api上

00:55:45.130 --> 00:55:54.130
因为他们说对了， 

00:55:49.360 --> 00:55:59.400
这只是时间问题吗

00:55:54.130 --> 00:56:01.510
音速吧，让我们看看

00:55:59.400 --> 00:56:02.950
优秀的三个快速入门指南

00:56:01.510 --> 00:56:05.560
我可以在X和网站上找到

00:56:02.950 --> 00:56:08.140
在GA版本的行为之后立即考虑

00:56:05.560 --> 00:56:12.010
在公平的船上，甚至甚至

00:56:08.140 --> 00:56:13.880
以前但是可能在某个地方

00:56:12.010 --> 00:56:16.099
那个时候

00:56:13.880 --> 00:56:19.220
目前我们有一些人

00:56:16.099 --> 00:56:23.599
寻找另一种方式来获得

00:56:19.220 --> 00:56:26.329
快速入门指南，运行和一些

00:56:23.599 --> 00:56:28.759
互动比不仅仅是哦

00:56:26.329 --> 00:56:29.930
这是一个网页，按照它说的做

00:56:28.759 --> 00:56:33.349
然后你会有一个小应用

00:56:29.930 --> 00:56:35.950
去，所以我们希望能够得到

00:56:33.349 --> 00:56:38.319
在，否则它将只是一个

00:56:35.950 --> 00:56:40.460
告诉你该怎么做的页面

00:56:38.319 --> 00:56:42.170
再加上我认为今天

00:56:40.460 --> 00:56:44.589
会议是一个很好的快速入门，所以

00:56:42.170 --> 00:56:47.019
希望它将完全生存

00:56:44.589 --> 00:56:49.880
那是一个小视频

00:56:47.019 --> 00:56:51.980
好，我们要去录制了

00:56:49.880 --> 00:56:55.369
它将在某个时候出版

00:56:51.980 --> 00:57:01.009
很快，那么我们将作为一个快速

00:56:55.369 --> 00:57:04.400
入门指南完全正确

00:57:01.009 --> 00:57:06.230
是因为查询对象存储库是

00:57:04.400 --> 00:57:07.430
只是一个JTA存储库

00:57:06.230 --> 00:57:08.539
与spring数据架集成

00:57:07.430 --> 00:57:11.900
以编程方式生成查询API 

00:57:08.539 --> 00:57:14.150
是的，你可以使用弹簧数据

00:57:11.900 --> 00:57:18.019
休息以生成视图模型

00:57:14.150 --> 00:57:20.539
该那个的视图服务

00:57:18.019 --> 00:57:22.249
建模问题的第二部分

00:57:20.539 --> 00:57:24.289
关于如何减少用量的任何想法

00:57:22.249 --> 00:57:26.180
的油盘并很好地接受命令

00:57:24.289 --> 00:57:28.640
好的，所以您不会使用好的

00:57:26.180 --> 00:57:29.930
在这里向您提出问题

00:57:28.640 --> 00:57:31.519
如何减少样板数量

00:57:29.930 --> 00:57:39.529
通过REST接受命令

00:57:31.519 --> 00:57:43.359
 API是是绝对我们已经

00:57:39.529 --> 00:57:46.999
考虑只是暴露终点

00:57:43.359 --> 00:57:50.480
您可以在其中发送命令的地方

00:57:46.999 --> 00:57:54.710
在实践中，我们看到的是你

00:57:50.480 --> 00:57:57.619
并不总是希望您的事件之一

00:57:54.710 --> 00:58:01.369
在我们或您的命令上一对一

00:57:57.619 --> 00:58:03.259
 API调用，通常也

00:58:01.369 --> 00:58:05.509
因为您在这些类名中

00:58:03.259 --> 00:58:08.450
在那里，一旦你打开

00:58:05.509 --> 00:58:14.539
这样一来，就有一定的潜力

00:58:08.450 --> 00:58:18.799
泄漏，所以那里的安全漏洞

00:58:14.539 --> 00:58:21.009
说，所以是的，我们正在看一些

00:58:18.799 --> 00:58:23.359
使非常通用的某种方式

00:58:21.009 --> 00:58:24.859
发出命令或至少发出命令

00:58:23.359 --> 00:58:29.749
基于

00:58:24.859 --> 00:58:33.230
 REST API，但实际上我们看到了

00:58:29.749 --> 00:58:35.690
你知道那里有

00:58:33.230 --> 00:58:37.599
不是真正的一对一映射

00:58:35.690 --> 00:58:41.150
反正前端

00:58:37.599 --> 00:58:43.700
使用时有什么变化吗

00:58:41.150 --> 00:58:48.289
不同的mq，因此在这种情况下，我们使用

00:58:43.700 --> 00:58:51.259
我想我们可以使用的收入mq 

00:58:48.289 --> 00:58:53.480
春天消息频道的事

00:58:51.259 --> 00:58:54.650
然后会在那个春天跟任何人说话

00:58:53.480 --> 00:58:56.690
创新可以正确地与您交流

00:58:54.650 --> 00:58:59.989
是的，所以在发生意外

00:58:56.690 --> 00:59:03.529
本身仅支持AMQP或spring 

00:58:59.989 --> 00:59:09.230
即时通讯，仅在MKP中

00:59:03.529 --> 00:59:11.869
使用春季AMQP，是的，这些是

00:59:09.230 --> 00:59:14.420
选项，也许我很可能

00:59:11.869 --> 00:59:16.519
通过支持 Spring Cloud Stream 意味着

00:59:14.420 --> 00:59:18.019
目前是间接的，但是

00:59:16.519 --> 00:59:20.569
可能更直接地在附近

00:59:18.019 --> 00:59:25.519
未来，我们支持一切

00:59:20.569 --> 00:59:28.029
弹簧可以在任何MC上支撑

00:59:25.519 --> 00:59:30.470
似乎数据中心

00:59:28.029 --> 00:59:33.769
 AWS集成又如何呢？ 

00:59:30.470 --> 00:59:35.180
我想改个问题

00:59:33.769 --> 00:59:36.950
看起来像在云中使用它

00:59:35.180 --> 00:59:38.900
在不同的环境中有

00:59:36.950 --> 00:59:40.160
您知道在AWS中会有所不同

00:59:38.900 --> 00:59:41.839
从例如更固执

00:59:40.160 --> 00:59:45.039
像格子这样的平台

00:59:41.839 --> 00:59:47.150
 Google App Engine中的桑格利亚汽酒Heroku，因此

00:59:45.039 --> 00:59:50.210
当你说话的时候

00:59:47.150 --> 00:59:52.130
首先有几件事是

00:59:50.210 --> 00:59:56.569
就像其他应用程序一样

00:59:52.130 --> 01:00:00.309
对，轴突的东西大部分在

00:59:56.569 --> 01:00:04.160
至少在我们的示例中，JVM 

01:00:00.309 --> 01:00:07.819
当我们离开JVM时，我们在MV中使用

01:00:04.160 --> 01:00:09.529
这种情况下您可以使用，但不是

01:00:07.819 --> 01:00:12.430
开箱即用，但您可以

01:00:09.529 --> 01:00:18.319
使用简单的队列服务

01:00:12.430 --> 01:00:20.720
再见AWS做到这一点，但为此

01:00:18.319 --> 01:00:23.539
目前，我们仅可扩展性部分

01:00:20.720 --> 01:00:25.789
支持J组，您可以获得J 

01:00:23.539 --> 01:00:29.180
小组在不使用的AWS上工作

01:00:25.789 --> 01:00:33.619
对于发现只是使用八卦

01:00:29.180 --> 01:00:35.599
例如服务器，但不是最

01:00:33.619 --> 01:00:38.270
理想，这是我们要做的事情之一

01:00:35.599 --> 01:00:40.370
看着

01:00:38.270 --> 01:00:42.950
我们正在寻找春季云发现

01:00:40.370 --> 01:00:46.430
是为了支持那个，那将

01:00:42.950 --> 01:00:50.180
绝对提高了跑步能力

01:00:46.430 --> 01:00:55.090
基于轴突的应用规模不断扩大

01:00:50.180 --> 01:00:57.800
云环境发现最后对不起

01:00:55.090 --> 01:01:00.520
是的，发现客户端抽象在

01:00:57.800 --> 01:01:03.410
春天的云正好

01:01:00.520 --> 01:01:06.430
当轴突有一个

01:01:03.410 --> 01:01:09.200
界面，因此相对来说比较简单

01:01:06.430 --> 01:01:12.560
做一些非常具体的事情

01:01:09.200 --> 01:01:15.020
到两个特定的环境（如果有） 

01:01:12.560 --> 01:01:18.140
发现节点的另一种方法或

01:01:15.020 --> 01:01:20.210
例如在AWS上有不同的方式

01:01:18.140 --> 01:01:22.040
您可以使用API​​来查找所有

01:01:20.210 --> 01:01:25.100
您正在运行的节点，然后

01:01:22.040 --> 01:01:31.300
发现其中哪些是真实的

01:01:25.100 --> 01:01:35.270
节点等，等等，让我们来看看

01:01:31.300 --> 01:01:36.530
怎么样率好吧，让我们看看如何选择

01:01:35.270 --> 01:01:38.300
您可以谈谈采取行动的步骤

01:01:36.530 --> 01:01:43.240
谁在使用它，他们如何使用它

01:01:38.300 --> 01:01:46.070
是的，我当然可以

01:01:43.240 --> 01:01:49.100
没有做太多的名字删除，因为x1 

01:01:46.070 --> 01:01:51.170
实际上经常用于

01:01:49.100 --> 01:01:54.140
关键任务系统和公司

01:01:51.170 --> 01:01:57.740
对他们来说比较秘密

01:01:54.140 --> 01:02:01.250
不幸地使用它，但是我可以说

01:01:57.740 --> 01:02:04.520
有一些非常大的银行使用

01:02:01.250 --> 01:02:06.440
他们中的一些人将其用于

01:02:04.520 --> 01:02:12.020
付款处理，我们已经看到了

01:02:06.440 --> 01:02:14.270
基于轴突的股票交易

01:02:12.020 --> 01:02:20.240
大量的财务申请

01:02:14.270 --> 01:02:22.190
一般，但大多数情况下，他们是

01:02:20.240 --> 01:02:25.850
交易系统和一些

01:02:22.190 --> 01:02:27.710
他们大规模运行，只有一个

01:02:25.850 --> 01:02:30.590
客户我称我为kaazoo Moe 

01:02:27.710 --> 01:02:33.470
允许提及他们，他们是

01:02:30.590 --> 01:02:35.930
网上赌场，他们真的有

01:02:33.470 --> 01:02:37.940
审核员提出了严格的审核要求

01:02:35.930 --> 01:02:42.440
政府显然是因为他们是

01:02:37.940 --> 01:02:44.300
赌场，今天他们使用它们存储

01:02:42.440 --> 01:02:48.310
自申请以来的全部历史

01:02:44.300 --> 01:02:52.190
现在大约五年或六年

01:02:48.310 --> 01:02:54.559
他们有数十亿

01:02:52.190 --> 01:02:57.200
在那里实际上是我的续集

01:02:54.559 --> 01:02:59.089
他们有调整的数据库

01:02:57.200 --> 01:03:01.970
优化以存储该数据量

01:02:59.089 --> 01:03:03.799
所以现在我们不知道实数

01:03:01.970 --> 01:03:08.240
因为我们这是一个开源项目

01:03:03.799 --> 01:03:10.940
和名字不断出现

01:03:08.240 --> 01:03:14.960
有时我们突然看到一个名字

01:03:10.940 --> 01:03:16.520
例如发布职位发布

01:03:14.960 --> 01:03:18.829
寻找优秀的人

01:03:16.520 --> 01:03:20.270
经验丰富，只有当你

01:03:18.829 --> 01:03:23.869
有运行我的口音应用程序

01:03:20.270 --> 01:03:26.809
怀疑，但我们希望在

01:03:23.869 --> 01:03:35.960
至少有数千个实现

01:03:26.809 --> 01:03:36.710
现在就生产什么

01:03:35.960 --> 01:03:38.000
关于卡夫卡

01:03:36.710 --> 01:03:39.170
而不是rabbitmq，我想你

01:03:38.000 --> 01:03:42.680
谈了一点，但是可以

01:03:39.170 --> 01:03:45.799
你说的更多，是的

01:03:42.680 --> 01:03:47.390
目前不支持Kafka 

01:03:45.799 --> 01:03:48.349
好吧，我还没有

01:03:47.390 --> 01:03:51.130
盒子外面

01:03:48.349 --> 01:03:55.549
卡夫卡成分四四四作用

01:03:51.130 --> 01:03:57.349
但是，肯定是

01:03:55.549 --> 01:04:00.380
一个事件的很好实现

01:03:57.349 --> 01:04:02.839
公交车，这就是我们的路线图

01:04:00.380 --> 01:04:06.589
期望我们期望能够

01:04:02.839 --> 01:04:08.299
包括三点一

01:04:06.589 --> 01:04:10.369
人们认为您也可以使用它

01:04:08.299 --> 01:04:13.549
作为事件存储，因为基本上

01:04:10.369 --> 01:04:16.849
可以将事件生存期设置为

01:04:13.549 --> 01:04:18.910
无限期，然后Kafka将允许您

01:04:16.849 --> 01:04:22.190
也可以从头开始重播

01:04:18.910 --> 01:04:23.990
我不是100％相信这是件好事

01:04:22.190 --> 01:04:27.950
要做的事情，因为它不是卡夫卡

01:04:23.990 --> 01:04:30.740
旨在做到这一点

01:04:27.950 --> 01:04:37.190
但是，如果您将事件存储很长时间， 

01:04:30.740 --> 01:04:39.200
时间，然后你最好有一个

01:04:37.190 --> 01:04:41.480
用于存储这些信息的系统

01:04:39.200 --> 01:04:44.329
事件持续了很长时间，最好

01:04:41.480 --> 01:04:46.819
永远，所以这将是我的建议，但是

01:04:44.329 --> 01:04:51.020
绝对是卡夫卡是一个非常好的方法

01:04:46.819 --> 01:04:57.200
从一台机器获取事件到多台

01:04:51.020 --> 01:05:00.260
其他人很酷，嗯，我去的时候很好

01:04:57.200 --> 01:05:02.660
输入此一个一对一的评论是吗

01:05:00.260 --> 01:05:05.170
他没有意识到你可以避免

01:05:02.660 --> 01:05:06.309
坚持在自动电线唐娜

01:05:05.170 --> 01:05:07.740
在构造函数上，现在我要指出

01:05:06.309 --> 01:05:10.930
这是新的，Spring Framework 

01:05:07.740 --> 01:05:12.130
 4.3现在是春季分组1.4 

01:05:10.930 --> 01:05:14.200
这就是我们在本演示中使用的

01:05:12.130 --> 01:05:15.339
这样对任何东西都有效

01:05:14.200 --> 01:05:17.829
最后一次，我不知道几个月

01:05:15.339 --> 01:05:20.200
或今年基本上因为我们有一个

01:05:17.829 --> 01:05:22.750
 spring boot ，所以我们的春季付款

01:05:20.200 --> 01:05:25.660
那三个谁来申请

01:05:22.750 --> 01:05:27.000
构造函数中的方法是做什么的

01:05:25.660 --> 01:05:28.599
构造函数中的apply方法

01:05:27.000 --> 01:05:34.000
这就是问题所在

01:05:28.599 --> 01:05:36.030
是它是做什么的，是的

01:05:34.000 --> 01:05:38.950
应用，并且应用方法可以

01:05:36.030 --> 01:05:41.020
本质上首先要做两件事

01:05:38.950 --> 01:05:43.900
在聚合本身内

01:05:41.020 --> 01:05:46.480
因此在我们的投诉中，它会发现

01:05:43.900 --> 01:05:48.640
所有的处理程序，所以添加事件

01:05:46.480 --> 01:05:51.420
在那里找到处理程序并调用

01:05:48.640 --> 01:05:55.240
他们马上就没有

01:05:51.420 --> 01:05:58.780
等待参与以及何时参与

01:05:55.240 --> 01:06:02.470
调用该事件也将保留

01:05:58.780 --> 01:06:05.049
与事件总线一起发布以及何时发布

01:06:02.470 --> 01:06:06.790
命令执行在那里完成

01:06:05.049 --> 01:06:09.910
周围有一小部分工作

01:06:06.790 --> 01:06:12.520
该命令执行该工作单元

01:06:09.910 --> 01:06:14.470
将开始提交过程，并且

01:06:12.520 --> 01:06:16.990
该过程的第一步是获取

01:06:14.470 --> 01:06:19.839
事件出标签去存储

01:06:16.990 --> 01:06:24.609
事件存储中的事件取决于

01:06:19.839 --> 01:06:26.410
在例如mqp的类型上

01:06:24.609 --> 01:06:28.089
您拥有的连接

01:06:26.410 --> 01:06:29.950
事务性的它将发送事件

01:06:28.089 --> 01:06:34.480
马上开放

01:06:29.950 --> 01:06:35.920
连接并等待提交-它

01:06:34.480 --> 01:06:37.900
将会进入下一阶段， 

01:06:35.920 --> 01:06:39.460
一个提交阶段，其中所有提交都是

01:06:37.900 --> 01:06:41.410
完成，然后有一个不是这样的提交，所以

01:06:39.460 --> 01:06:44.770
这就是一切协调的方式，但是

01:06:41.410 --> 01:06:47.559
 apply方法将在内部应用

01:06:44.770 --> 01:06:50.470
它调用所有处理程序，然后

01:06:47.559 --> 01:06:58.170
其余阶段的出版阶段

01:06:50.470 --> 01:07:01.599
下一步就是好世界

01:06:58.170 --> 01:07:02.799
一个问题似乎是

01:07:01.599 --> 01:07:05.710
问题不起作用，但是

01:07:02.799 --> 01:07:07.720
当然有一个问题，所以你

01:07:05.710 --> 01:07:10.990
知道你能告诉我什么事吗

01:07:07.720 --> 01:07:13.630
采购表看起来像这样，所以我们使用了H 

01:07:10.990 --> 01:07:15.690
续集或H2在这个权利，你呢

01:07:13.630 --> 01:07:19.390
有什么可以告诉我们的，是的，我

01:07:15.690 --> 01:07:22.630
关闭IDE，使它们消失

01:07:19.390 --> 01:07:24.760
但我应该能够因为我

01:07:22.630 --> 01:07:28.480
关闭屏幕共享应该能够

01:07:24.760 --> 01:07:31.150
重新获得屏幕共享，让我

01:07:28.480 --> 01:07:35.470
首先启动我的续集工作台，因为

01:07:31.150 --> 01:07:38.080
我很确定我当然有

01:07:35.470 --> 01:07:41.200
可以谈论它，但让我们开始吧

01:07:38.080 --> 01:07:46.570
在那里，所以我应该有一张桌子

01:07:41.200 --> 01:07:49.170
好吧，让我分享屏幕内容吧

01:07:46.570 --> 01:07:56.410
走着瞧吧

01:07:49.170 --> 01:08:01.410
好的，所以您应该能够看到

01:07:56.410 --> 01:08:06.670
这个，我可以选择这些行

01:08:01.410 --> 01:08:09.310
在这里，您会看到一些如果您在银行业务

01:08:06.670 --> 01:08:13.090
抱歉，这是我的观点

01:08:09.310 --> 01:08:15.580
银行我我只取钱让你

01:08:13.090 --> 01:08:17.620
看到那里有一个全球索引

01:08:15.580 --> 01:08:20.050
一个事件标识符，它是唯一的

01:08:17.620 --> 01:08:22.510
消息标识符，主要是

01:08:20.050 --> 01:08:24.400
为了我们的相关目的，然后

01:08:22.510 --> 01:08:28.660
有两个Blob，一个用于元数据，另一个用于

01:08:24.400 --> 01:08:31.210
一个用于有效载荷，然后在

01:08:28.660 --> 01:08:34.839
这些斑点，您可以看到实际或

01:08:31.210 --> 01:08:37.510
这种情况下默认情况下只是XML 

01:08:34.839 --> 01:08:40.900
 Exim使用Extreme来序列化事件

01:08:37.510 --> 01:08:43.330
所以这是一个序列化的事件，然后

01:08:40.900 --> 01:08:46.330
有关于什么的描述

01:08:43.330 --> 01:08:49.060
有效载荷实际上是原因

01:08:46.330 --> 01:08:50.830
因为那是轴突只会反序列化

01:08:49.060 --> 01:08:54.130
该事件是否有处理程序

01:08:50.830 --> 01:08:57.430
但是当它使用ladydi序列化时

01:08:54.130 --> 01:08:59.680
聚合是很常见的

01:08:57.430 --> 01:09:02.320
发布不感兴趣的事件

01:08:59.680 --> 01:09:06.010
本身，因为它不影响任何

01:09:02.320 --> 01:09:07.690
聚合本身及其内部的状态

01:09:06.010 --> 01:09:09.339
这种情况不是

01:09:07.690 --> 01:09:12.180
加载时序列化

01:09:09.339 --> 01:09:14.740
汇总，然后有一个时间戳

01:09:12.180 --> 01:09:16.810
然后有合计

01:09:14.740 --> 01:09:19.030
标识符和序列号以及那些

01:09:16.810 --> 01:09:22.839
用于加载所有事件

01:09:19.030 --> 01:09:25.440
具体的聚合实例是

01:09:22.839 --> 01:09:29.140
不是很明智的标识符，但是

01:09:25.440 --> 01:09:31.880
这是为演示，然后有一个

01:09:29.140 --> 01:09:36.440
 type是集合的类型

01:09:31.880 --> 01:09:39.859
我怀疑它在轴突的任何地方都可以使用，但是

01:09:36.440 --> 01:09:42.980
我们已经注意到这是非常

01:09:39.859 --> 01:09:46.700
如果您正在调试，则非常有用，因此我们添加了

01:09:42.980 --> 01:09:48.740
在行动中也要输入-有一个

01:09:46.700 --> 01:09:53.120
以及键入列，它是

01:09:48.740 --> 01:09:56.600
集合中的唯一标识符

01:09:53.120 --> 01:10:00.920
轴突3只是根本没有索引

01:09:56.600 --> 01:10:05.060
对我们来说就在那里-好吧，我们

01:10:00.920 --> 01:10:08.330
您进行调试，非常好

01:10:05.060 --> 01:10:11.590
我认为应该很酷

01:10:08.330 --> 01:10:15.250
对于请求者来说非常有启发性

01:10:11.590 --> 01:10:19.070
那是D，什么时候可以谈论

01:10:15.250 --> 01:10:20.930
何时完成版本的GA 

01:10:19.070 --> 01:10:23.450
 Torito对待的哦，那是什么之一

01:10:20.930 --> 01:10:26.360
计划哦

01:10:23.450 --> 01:10:27.830
回答这个问题很危险，但是

01:10:26.360 --> 01:10:30.440
我还是去试试看

01:10:27.830 --> 01:10:35.240
现在我们正在发布候选

01:10:30.440 --> 01:10:37.220
一个，我们邀请大家提供

01:10:35.240 --> 01:10:38.990
我们有反馈，基本上

01:10:37.220 --> 01:10:42.440
取决于我们得到多少反馈

01:10:38.990 --> 01:10:45.110
到那里有一些皱纹

01:10:42.440 --> 01:10:50.570
我们仍然发现我们

01:10:45.110 --> 01:10:52.730
努力工作，但我们希望GA表现良好

01:10:50.570 --> 01:10:54.560
最迟在今年年底

01:10:52.730 --> 01:10:59.660
我们希望能够在

01:10:54.560 --> 01:11:01.640
 12月初很酷，嗯

01:10:59.660 --> 01:11:07.190
 ID的目的是存储在

01:11:01.640 --> 01:11:12.890
投诉课任何想法都可以

01:11:07.190 --> 01:11:15.980
当您应用事件时，轴需要

01:11:12.890 --> 01:11:21.020
应用于另一个合计

01:11:15.980 --> 01:11:23.780
事件，因此使用了ID字段是

01:11:21.020 --> 01:11:25.970
实际上使轴突能够

01:11:23.780 --> 01:11:28.880
确定汇总

01:11:25.970 --> 01:11:31.490
已发布的事件，因此当您加载

01:11:28.880 --> 01:11:33.410
汇总它确切知道哪个

01:11:31.490 --> 01:11:36.719
从事件中加载事件

01:11:33.410 --> 01:11:39.420
存储，但相关

01:11:36.719 --> 01:11:41.100
是的，当你当你

01:11:39.420 --> 01:11:42.840
从事件存储中加载聚合

01:11:41.100 --> 01:11:44.190
您不想加载所有事件

01:11:42.840 --> 01:11:46.110
时间的开始，你会看到

01:11:44.190 --> 01:11:47.760
哪个适用，但您想成为

01:11:46.110 --> 01:11:49.890
能够真正地找到那些

01:11:47.760 --> 01:11:52.170
该事件所产生的事件

01:11:49.890 --> 01:11:56.040
过去且仅特定的总计

01:11:52.170 --> 01:11:59.070
重播它们，是的，它们与

01:11:56.040 --> 01:12:08.969
将实例聚合到事件中

01:11:59.070 --> 01:12:11.190
酷，让我们看看你如何支持

01:12:08.969 --> 01:12:17.610
您如何支持以下方面的报告

01:12:11.190 --> 01:12:21.180
分布式微服务报告

01:12:17.610 --> 01:12:22.320
这是什么问题

01:12:21.180 --> 01:12:24.330
分发报告如何

01:12:22.320 --> 01:12:26.610
微型资源，我认为那会

01:12:24.330 --> 01:12:27.780
有点像我的意思是读

01:12:26.610 --> 01:12:29.340
模型可以满足您的需求

01:12:27.780 --> 01:12:31.800
没有这个想法

01:12:29.340 --> 01:12:33.360
您可以作为多个读取模型

01:12:31.800 --> 01:12:38.040
高级哦，视频是吗

01:12:33.360 --> 01:12:40.110
监控还是很好，我是说嗯，如果

01:12:38.040 --> 01:12:42.199
如果您有阅读的话，可能是这样

01:12:40.110 --> 01:12:45.840
包含很多

01:12:42.199 --> 01:12:49.500
不同的可能性很大，请

01:12:45.840 --> 01:12:51.449
如果我错了就纠正我，但是经常

01:12:49.500 --> 01:12:55.980
在报告中您结合了信息

01:12:51.449 --> 01:12:59.520
来自许多不同的来源等等

01:12:55.980 --> 01:13:03.230
有效地拥有它是

01:12:59.520 --> 01:13:06.480
只是一个具有许多新视图模型

01:13:03.230 --> 01:13:09.180
其事件的来源，因此可能是

01:13:06.480 --> 01:13:12.420
这取决于您的喜好

01:13:09.180 --> 01:13:14.610
部署模型（如果您有事件或

01:13:12.420 --> 01:13:16.860
您可能需要阅读的每种服务

01:13:14.610 --> 01:13:19.550
从多个事件存储，然后

01:13:16.860 --> 01:13:24.120
以某种方式命令那些事件

01:13:19.550 --> 01:13:25.920
但是是的，基本上你只有一个

01:13:24.120 --> 01:13:27.660
不同的视图模型，然后选择

01:13:25.920 --> 01:13:29.820
您想要来自任何来源的事件

01:13:27.660 --> 01:13:32.670
合并它们，然后建立您的视图

01:13:29.820 --> 01:13:34.440
模型，这就是我喜欢的部分

01:13:32.670 --> 01:13:36.870
意味着不是真的那么不同

01:13:34.440 --> 01:13:38.460
从其他任何事件

01:13:36.870 --> 01:13:41.550
作为资源，您可以构建自己的任何东西

01:13:38.460 --> 01:13:43.979
认为有助于提供您的

01:13:41.550 --> 01:13:49.019
终端用户

01:13:43.979 --> 01:13:53.039
很好，让我们看看

01:13:49.019 --> 01:13:54.749
哦，是的，问题是

01:13:53.039 --> 01:13:56.459
被提炼

01:13:54.749 --> 01:14:00.749
跨数据库报告怎么办

01:13:56.459 --> 01:14:02.760
你如何续集加入，但我猜

01:14:00.749 --> 01:14:04.829
我认为那是我认为答案

01:14:02.760 --> 01:14:08.429
我想就是这样

01:14:04.829 --> 01:14:10.530
完全是这样，所以您不太舒服

01:14:08.429 --> 01:14:15.179
两种正确的选择

01:14:10.530 --> 01:14:18.599
使用组合流，所以您使用流

01:14:15.179 --> 01:14:23.610
来自多个来源的事件，然后

01:14:18.599 --> 01:14:27.869
创建一个不错的报告模型或执行

01:14:23.610 --> 01:14:30.900
猜测一些微服务的方式

01:14:27.869 --> 01:14:32.459
至少是您查询一个，然后

01:14:30.900 --> 01:14:34.679
查询另一个喜欢数据的人

01:14:32.459 --> 01:14:38.639
这样我不确定那是否真的

01:14:34.679 --> 01:14:40.979
高效但是一切都取决于

01:14:38.639 --> 01:14:43.679
这取决于它需要如何

01:14:40.979 --> 01:14:46.289
您说的查询是否频繁

01:14:43.679 --> 01:14:49.110
一年一次的风格

01:14:46.289 --> 01:14:55.050
查询或有什么不同

01:14:49.110 --> 01:14:57.840
选项在那里，但我首先想到的是

01:14:55.050 --> 01:15:00.090
在结合那些方向

01:14:57.840 --> 01:15:03.630
流，并从中建立模型

01:15:00.090 --> 01:15:05.159
数据信息，但如果我们了解到

01:15:03.630 --> 01:15:07.519
你应该从鬼魂破坏者那里得到任何东西

01:15:05.159 --> 01:15:10.139
永不越过溪流

01:15:07.519 --> 01:15:13.860
不，那很好，这取决于我的意思

01:15:10.139 --> 01:15:16.940
给您非常强大的功能

01:15:13.860 --> 01:15:22.229
有时您真的需要吗

01:15:16.940 --> 01:15:24.510
嗯，让我们看看我们还能得到什么

01:15:22.229 --> 01:15:27.110
您是否确保我们的视频必须

01:15:24.510 --> 01:15:31.110
与动物园顺便说一句是的

01:15:27.110 --> 01:15:32.729
很棒，你如何确保

01:15:31.110 --> 01:15:35.249
该事件已保存到该事件

01:15:32.729 --> 01:15:37.139
原子存储并通过AMQP发送如何

01:15:35.249 --> 01:15:41.909
可以与例如Kafka一起使用吗

01:15:37.139 --> 01:15:45.840
还有没有续集的商店，所以那是

01:15:41.909 --> 01:15:48.090
好问题，以及我们在哪里

01:15:45.840 --> 01:15:53.130
发送数据到两个不同的系统

01:15:48.090 --> 01:15:57.389
保证是不存在，但我们

01:15:53.130 --> 01:16:00.030
可以走得很远

01:15:57.389 --> 01:16:01.829
如果发生交易是

01:16:00.030 --> 01:16:03.599
开始，因为我们使用弹簧

01:16:01.829 --> 01:16:06.689
它正在使用Springs交易

01:16:03.599 --> 01:16:08.909
平台交易经理和

01:16:06.689 --> 01:16:10.800
可以的平台交易管理器

01:16:08.909 --> 01:16:12.989
进行很多不同的交易

01:16:10.800 --> 01:16:15.929
所以你可以结合数据库

01:16:12.989 --> 01:16:19.110
交易和担保完成

01:16:15.929 --> 01:16:21.599
一口井中的一口交易

01:16:19.110 --> 01:16:24.869
有点是因为提交发生的非常

01:16:21.599 --> 01:16:27.090
彼此不久之后好

01:16:24.869 --> 01:16:30.840
动作所做的就是它将发送数据

01:16:27.090 --> 01:16:32.729
到事件存储并刷新任何

01:16:30.840 --> 01:16:38.489
数据，因此它将迫使数据转到

01:16:32.729 --> 01:16:40.739
然后将事件发送到

01:16:38.489 --> 01:16:42.719
 okapi，然后提交发生

01:16:40.739 --> 01:16:45.119
为他们两个，所以我可以

01:16:42.719 --> 01:16:47.010
如果您需要更强壮的尿布

01:16:45.119 --> 01:16:49.289
保证有替代方案可以

01:16:47.010 --> 01:16:54.059
将其存储到事件中或仅收取一些费用

01:16:49.289 --> 01:16:58.409
然后有一个它只会

01:16:54.059 --> 01:17:02.249
频繁的赠品，然后你有

01:16:58.409 --> 01:17:04.919
处理器跟踪事件存储并

01:17:02.249 --> 01:17:08.820
将发现的所有内容都发送出去

01:17:04.919 --> 01:17:12.809
在这种情况下，您至少拥有一个

01:17:08.820 --> 01:17:14.489
那种情况下的交付保证

01:17:12.809 --> 01:17:17.309
可能比大多数广告更好

01:17:14.489 --> 01:17:19.380
保证，但就在我的意思是

01:17:17.309 --> 01:17:21.590
人们说过很多次了

01:17:19.380 --> 01:17:25.380
关于它的辩论，但它不存在

01:17:21.590 --> 01:17:29.360
没有两个系统可以

01:17:25.380 --> 01:17:37.349
保证相互状态

01:17:29.360 --> 01:17:39.149
没有量子纠缠，好吧，我是

01:17:37.349 --> 01:17:41.550
有人告诉我应该让我的电话静音

01:17:39.149 --> 01:17:46.289
可能是反馈，但在财务方面

01:17:41.550 --> 01:17:48.929
说说大卫编辑了什么，好吧

01:17:46.289 --> 01:17:53.849
什么动作能够支持一个

01:17:48.929 --> 01:17:57.479
分配权利模型是

01:17:53.849 --> 01:17:59.039
问题是或不是因为是

01:17:57.479 --> 01:18:01.649
口音是否支持分销商权利

01:17:59.039 --> 01:18:03.409
我认为实际上有两个阶段

01:18:01.649 --> 01:18:06.479
进行某种讨论而不是

01:18:03.409 --> 01:18:08.459
写两个不同的东西，但要接受

01:18:06.479 --> 01:18:10.649
任何你想要的方式

01:18:08.459 --> 01:18:11.350
还有更多，所以你有这些

01:18:10.649 --> 01:18:13.720
骨料

01:18:11.350 --> 01:18:16.780
骨料永远活在一个

01:18:13.720 --> 01:18:19.000
正确的位置居住

01:18:16.780 --> 01:18:21.010
实例将位于一个位置

01:18:19.000 --> 01:18:22.900
如果它住在两个地方，那么你

01:18:21.010 --> 01:18:24.670
进一步解决一些问题

01:18:22.900 --> 01:18:26.530
他们试图插入的流

01:18:24.670 --> 01:18:29.440
相同事件进入事件存储

01:18:26.530 --> 01:18:32.290
然后拒绝，但是你可以的方式

01:18:29.440 --> 01:18:34.990
分发它，您可以分片您的

01:18:32.290 --> 01:18:37.270
聚集在多个节点和轴突上

01:18:34.990 --> 01:18:41.140
确实发生在分布式命令上

01:18:37.270 --> 01:18:43.390
巴士，如果我们有一个半小时

01:18:41.140 --> 01:18:45.070
网络研讨会，那么我可以证明

01:18:43.390 --> 01:18:48.370
其实还有一个入门

01:18:45.070 --> 01:18:52.120
它也是轴突弹簧展位

01:18:48.370 --> 01:18:53.530
入门级J组，它使您能够

01:18:52.120 --> 01:18:57.100
启动节点，然后这些鼻子

01:18:53.530 --> 01:19:00.910
互相检测并开始共享

01:18:57.100 --> 01:19:03.010
或平衡每个之间的负载

01:19:00.910 --> 01:19:06.070
其他基于一致的哈希

01:19:03.010 --> 01:19:08.530
算法，这样每个客户都会知道

01:19:06.070 --> 01:19:10.930
向特定节点发送命令

01:19:08.530 --> 01:19:13.090
只是因为它以

01:19:10.930 --> 01:19:16.620
聚合，然后基于

01:19:13.090 --> 01:19:19.740
您可以找到汇总标识符

01:19:16.620 --> 01:19:22.360
将其发送到的正确节点

01:19:19.740 --> 01:19:25.570
这样便可以留下刻度

01:19:22.360 --> 01:19:29.620
命令端并获得一些分配

01:19:25.570 --> 01:19:32.470
那边你不能做的事应该

01:19:29.620 --> 01:19:35.410
按照定义，我不会说

01:19:32.470 --> 01:19:37.440
真的很烦人是分发

01:19:35.410 --> 01:19:39.700
多个节点上的单个聚合

01:19:37.440 --> 01:19:43.800
因为聚合的定义

01:19:39.700 --> 01:19:50.350
是一组实体

01:19:43.800 --> 01:19:52.180
一起作为数据

01:19:50.350 --> 01:19:54.610
一开始就改变

01:19:52.180 --> 01:19:59.800
分配得很好不是

01:19:54.610 --> 01:20:02.610
我不是我对简单系统的看法

01:19:59.800 --> 01:20:06.970
维护系统不是一个领域

01:20:02.610 --> 01:20:09.190
如果不是，那将不再是一个合计

01:20:06.970 --> 01:20:11.200
事件需要由消费者处理

01:20:09.190 --> 01:20:13.930
顺便要求消费者必须

01:20:11.200 --> 01:20:19.750
在消费者B之前在X中处理em怎么办

01:20:13.930 --> 01:20:23.449
你会很有趣

01:20:19.750 --> 01:20:27.830
那我们又去了对不起

01:20:23.449 --> 01:20:29.000
所以如果两个消费者是其中的一部分

01:20:27.830 --> 01:20:31.250
记得我在说这些

01:20:29.000 --> 01:20:33.710
处理组和这些处理器

01:20:31.250 --> 01:20:38.810
它们是同一处理器的一部分吗

01:20:33.710 --> 01:20:40.850
组中有一些方法可以定义

01:20:38.810 --> 01:20:43.150
消费者应在特定条件下调用

01:20:40.850 --> 01:20:43.150
订购

01:20:43.239 --> 01:20:50.950
嗨，如果他们是不同的一部分

01:20:46.540 --> 01:20:54.510
应用程序就没有保证

01:20:50.950 --> 01:20:54.510
 [音乐] 

01:20:56.620 --> 01:21:02.719
根本没有任何保证或任何幽默

01:21:00.650 --> 01:21:11.210
在其他事件之前处理事件

01:21:02.719 --> 01:21:15.260
它已经很酷了吗，哦，还有什么

01:21:11.210 --> 01:21:18.080
我们到达这里了吗我认为我们实际上在

01:21:15.260 --> 01:21:19.670
很好哦还有另一个问题

01:21:18.080 --> 01:21:22.760
缩放命令，但我不是真的

01:21:19.670 --> 01:21:25.550
确定我了解我认为

01:21:22.760 --> 01:21:28.640
与我之前说的有关

01:21:25.550 --> 01:21:31.820
分销商坐公交车，然后

01:21:28.640 --> 01:21:34.160
我怎样才能正确地缩放它们

01:21:31.820 --> 01:21:36.170
同时没有多个音符

01:21:34.160 --> 01:21:37.699
只要有事件就可以处理

01:21:36.170 --> 01:21:39.290
四个不同的集合

01:21:37.699 --> 01:21:42.770
单个聚合的命令是

01:21:39.290 --> 01:21:44.239
总是顺序地调用， 

01:21:42.770 --> 01:21:46.940
使得编程模型

01:21:44.239 --> 01:21:49.130
聚合更好，但也使

01:21:46.940 --> 01:21:52.160
聚集和聚集是根据定义

01:21:49.130 --> 01:21:56.660
您不能同时执行

01:21:52.160 --> 01:21:59.210
总的来说好点好点

01:21:56.660 --> 01:22:01.880
嗯，回溯到那个

01:21:59.210 --> 01:22:04.280
有关显微镜报告的问题

01:22:01.880 --> 01:22:08.540
或跨不同的微服务

01:22:04.280 --> 01:22:11.690
嗯，有个好朋友我的朋友本·威尔考克

01:22:08.540 --> 01:22:15.469
只是指出我非常好

01:22:11.690 --> 01:22:18.040
 Microsoft开发人员网络的资源

01:22:15.469 --> 01:22:20.900
他们有一本书叫电子书电子书

01:22:18.040 --> 01:22:22.880
叫做CQRS旅程，我想他们

01:22:20.900 --> 01:22:26.420
跟那边说一点

01:22:22.880 --> 01:22:29.870
好吧，请检查一下它是免费的

01:22:26.420 --> 01:22:33.760
可用看起来很有趣，嗯，所以

01:22:29.870 --> 01:22:36.560
最后一个问题外显子如何与

01:22:33.760 --> 01:22:38.240
顶点是

01:22:36.560 --> 01:22:39.740
这更像是对的事件

01:22:38.240 --> 01:22:42.650
它实际上并不能解决问题

01:22:39.740 --> 01:22:49.010
确保它只是我没有的一个事件

01:22:42.650 --> 01:22:52.790
知道我还在寻找一些方法

01:22:49.010 --> 01:22:55.490
我知道的人非常喜欢顶点

01:22:52.790 --> 01:22:58.910
他们一直在尝试看看是否

01:22:55.490 --> 01:23:02.980
它适合轴突吗？我认为

01:22:58.910 --> 01:23:06.320
轴突比顶点略大

01:23:02.980 --> 01:23:09.050
在建筑范围内

01:23:06.320 --> 01:23:12.410
尝试解决顶点的模式

01:23:09.050 --> 01:23:15.440
更多的是事件事件处理

01:23:12.410 --> 01:23:16.700
我的意思是正确的机制

01:23:15.440 --> 01:23:21.710
有很多概念

01:23:16.700 --> 01:23:24.860
类似，因此顶点具有此事件循环

01:23:21.710 --> 01:23:27.380
然后每个动作都是自己的

01:23:24.860 --> 01:23:29.350
线程或进程，我不认为他们

01:23:27.380 --> 01:23:33.470
确实使用线程，但他们使用一些

01:23:29.350 --> 01:23:37.880
其他机制，然后一切

01:23:33.470 --> 01:23:40.580
是唯一的排气回路吗，是的

01:23:37.880 --> 01:23:45.290
你可以用我拥有的顶点来构建东西

01:23:40.580 --> 01:23:48.410
从来没有见过一个很好的组合

01:23:45.290 --> 01:23:50.270
我以为你知道的那两个

01:23:48.410 --> 01:23:52.490
为样品工作，但我永远不会建立

01:23:50.270 --> 01:23:56.030
据我所见正确的应用程序

01:23:52.490 --> 01:23:57.830
现在基于两种技术，所以如果一个

01:23:56.030 --> 01:24:00.190
适合，另一个可能不适合

01:23:57.830 --> 01:24:05.060
反之亦然

01:24:00.190 --> 01:24:06.620
很好，很好，嗯，我想

01:24:05.060 --> 01:24:07.940
就是我的朋友，我想我们做的是

01:24:06.620 --> 01:24:10.670
我们是否解决了所有这些问题

01:24:07.940 --> 01:24:14.420
这次只用了25分钟

01:24:10.670 --> 01:24:16.400
而不是花了27分钟左右

01:24:14.420 --> 01:24:19.370
上次，所以我认为我们只是我认为我们

01:24:16.400 --> 01:24:21.110
很好，很好，我希望

01:24:19.370 --> 01:24:24.350
大家都说我回答了

01:24:21.110 --> 01:24:27.680
令任何人满意的问题

01:24:24.350 --> 01:24:29.450
马上问他们，所以我不

01:24:27.680 --> 01:24:31.760
实际上只是与我们联系

01:24:29.450 --> 01:24:35.090
对吧，我们在互联网上

01:24:31.760 --> 01:24:39.050
得到了我们的Twitter信息，那

01:24:35.090 --> 01:24:40.610
滑到那里，让那些仍在的人

01:24:39.050 --> 01:24:43.220
行非常感谢您加入我们

01:24:40.610 --> 01:24:45.980
该视频已被记录下来

01:24:43.220 --> 01:24:48.230
可以在春季在线上获得IO 

01:24:45.980 --> 01:24:49.970
这样的视频，我会在一周左右的时间内

01:24:48.230 --> 01:24:51.770
想象是不是

01:24:49.970 --> 01:24:53.980
 -当然可以，但也许你知道

01:24:51.770 --> 01:24:56.300
可能比谁知道的要早

01:24:53.980 --> 01:24:58.820
我们期待再次与您见面

01:24:56.300 --> 01:25:02.110
下一次网络研讨会我们的下一部分

01:24:58.820 --> 01:25:05.560
非常感谢你，祝你有美好的一天

01:25:02.110 --> 01:25:05.560
可以，但是

01:25:10.710 --> 01:25:12.770
您

