WEBVTT
Kind: captions
Language: zh-Hans

00:00:09.840 --> 00:00:16.289
好，大家好，谢谢

00:00:13.039 --> 00:00:17.939
加入此网络研讨会和标题

00:00:16.289 --> 00:00:20.700
微观中由消费者驱动的合同

00:00:17.939 --> 00:00:22.470
服务架构，然后再去

00:00:20.700 --> 00:00:25.770
主要话题让我说几句话

00:00:22.470 --> 00:00:28.169
我自己，所以我叫marcin jiseok 

00:00:25.770 --> 00:00:31.680
在这个印刷云团队工作， 

00:00:28.169 --> 00:00:33.870
关键的开发人员，我主要在工作

00:00:31.680 --> 00:00:36.180
在免费项目上，所以撒了侦探

00:00:33.870 --> 00:00:39.170
零星的合约，所以那个

00:00:36.180 --> 00:00:42.420
我们今天要谈论的是

00:00:39.170 --> 00:00:44.910
我的最新一期Spring Cloud Pipelines 

00:00:42.420 --> 00:00:47.129
 Twitter句柄在MJ鲨鱼和我的

00:00:44.910 --> 00:00:49.050
博客太多编码通讯，我很漂亮

00:00:47.129 --> 00:00:50.670
确保您无法保护

00:00:49.050 --> 00:00:52.859
我的名字，所以你可以找到我的推特

00:00:50.670 --> 00:00:56.789
在我的博客网站上处理

00:00:52.859 --> 00:01:00.210
更容易记住，所以这是怎么回事

00:00:56.789 --> 00:01:01.440
议程，我认为这很简单， 

00:01:00.210 --> 00:01:03.979
基本上会有一个

00:01:01.440 --> 00:01:09.570
介绍，然后是摘要中的演示

00:01:03.979 --> 00:01:10.740
那没什么好复杂的，女士们和

00:01:09.570 --> 00:01:12.020
先生们，我能引起你的注意吗

00:01:10.740 --> 00:01:16.170
请

00:01:12.020 --> 00:01:19.710
因为在

00:01:16.170 --> 00:01:23.100
互联网引起了很大的骚动

00:01:19.710 --> 00:01:24.780
什么合同是什么

00:01:23.100 --> 00:01:27.149
消费者驱动的合同之类的东西

00:01:24.780 --> 00:01:29.520
所以我要做的第一件事

00:01:27.149 --> 00:01:33.329
跟你说的是我们不会的

00:01:29.520 --> 00:01:36.479
在谈论，所以我们不会谈论

00:01:33.329 --> 00:01:38.430
关于那些成功实现ESB的架构

00:01:36.479 --> 00:01:42.180
行动配件和类似的东西

00:01:38.430 --> 00:01:45.479
它不会发生，所以

00:01:42.180 --> 00:01:48.630
喷水合同不介绍

00:01:45.479 --> 00:01:52.649
任何不必要的耦合或复制

00:01:48.630 --> 00:01:55.380
正确的州，我们看到了一些事情

00:01:52.649 --> 00:01:58.409
错误撒合同不像

00:01:55.380 --> 00:02:01.729
重塑同一件事，为什么

00:01:58.409 --> 00:02:05.549
我将在一秒钟内向您展示

00:02:01.729 --> 00:02:08.070
好的，这样我们才能进入

00:02:05.549 --> 00:02:09.899
我们必须使用相同的页面

00:02:08.070 --> 00:02:12.180
词汇，所以让我们定义一些术语

00:02:09.899 --> 00:02:16.230
我们将在整个过程中使用

00:02:12.180 --> 00:02:19.440
整个会议，所以制片人

00:02:16.230 --> 00:02:22.480
是公开API权利的服务

00:02:19.440 --> 00:02:25.239
简单的东西，那么我们有它

00:02:22.480 --> 00:02:28.360
幽默消费者是一项服务， 

00:02:25.239 --> 00:02:30.940
消耗生产者的API，因此如果

00:02:28.360 --> 00:02:34.480
您正在向另一个人发送请求

00:02:30.940 --> 00:02:39.000
服务器，那么你正在消耗

00:02:34.480 --> 00:02:41.230
服务API是什么合同

00:02:39.000 --> 00:02:43.959
合同是

00:02:41.230 --> 00:02:46.560
生产者和消费者如何使用API 

00:02:43.959 --> 00:02:49.569
看起来像是最近的声明

00:02:46.560 --> 00:02:53.019
通常一些公司写那些

00:02:49.569 --> 00:02:56.319
像你认识的人这样的文档

00:02:53.019 --> 00:02:57.940
或控制台和舞台，我们不，我们不

00:02:56.319 --> 00:03:00.180
想要使用我们需要的东西

00:02:57.940 --> 00:03:02.620
可以在代码内部，这可以帮助我们

00:03:00.180 --> 00:03:05.950
将这些方面绑定到此

00:03:02.620 --> 00:03:07.599
现在协议，消费者驱动的合同

00:03:05.950 --> 00:03:09.670
是消费者在

00:03:07.599 --> 00:03:12.819
推动API的更改

00:03:09.670 --> 00:03:15.310
生产者这是什么意思

00:03:12.819 --> 00:03:17.530
因为消费者是

00:03:15.310 --> 00:03:22.000
使用API​​的原因就是它被称为

00:03:17.530 --> 00:03:24.519
消费者最了解您

00:03:22.000 --> 00:03:26.319
看起来和如何完成

00:03:24.519 --> 00:03:30.940
练习你会在

00:03:26.319 --> 00:03:34.200
演示，这样无论何时有人告诉你

00:03:30.940 --> 00:03:37.239
关于新工具或新方法

00:03:34.200 --> 00:03:39.250
您应该经常问的第一件事是

00:03:37.239 --> 00:03:41.169
我们要解决什么问题

00:03:39.250 --> 00:03:45.069
因为这里经常有人是新来的

00:03:41.169 --> 00:03:46.510
标语您喜欢的工具，并立即

00:03:45.069 --> 00:03:48.700
有人说让我们在我们中使用它

00:03:46.510 --> 00:03:51.040
公司，但如果您无法回答

00:03:48.700 --> 00:03:52.569
像什么问题一样的问题

00:03:51.040 --> 00:03:55.450
这个工具解决了你不应该使用

00:03:52.569 --> 00:03:57.190
那我们想解决什么问题

00:03:55.450 --> 00:04:00.040
用洒水合同解决

00:03:57.190 --> 00:04:01.780
消费者这样的不同合同

00:04:00.040 --> 00:04:03.849
第一个是存根有效性， 

00:04:01.780 --> 00:04:06.819
集成测试中的可重用性

00:04:03.849 --> 00:04:10.599
现在我们的集成测试是什么

00:04:06.819 --> 00:04:14.139
再次在同一页面上，所以当我

00:04:10.599 --> 00:04:16.810
使用短语集成测试意味着

00:04:14.139 --> 00:04:18.579
他们在测试期间喝醉的测试

00:04:16.810 --> 00:04:22.780
建立时间，以便您建立自己的

00:04:18.579 --> 00:04:25.210
我们说应用程序和一些测试

00:04:22.780 --> 00:04:26.740
处理模拟，存根和东西

00:04:25.210 --> 00:04:29.199
就像这些是单元测试

00:04:26.740 --> 00:04:32.380
集成测试是那些

00:04:29.199 --> 00:04:35.260
发送真实请求到伪造的HTTP服务器

00:04:32.380 --> 00:04:36.490
或访问内存数据库，所以我

00:04:35.260 --> 00:04:40.270
谈论那些

00:04:36.490 --> 00:04:42.100
后者后者测试第二个

00:04:40.270 --> 00:04:48.160
我们要解决的问题是

00:04:42.100 --> 00:04:51.250
创建一个不错的API，所以我们有一个

00:04:48.160 --> 00:04:53.889
我们有消费者的典型情况

00:04:51.250 --> 00:04:55.780
发送请求到

00:04:53.889 --> 00:04:57.610
我想是制片人

00:04:55.780 --> 00:05:00.639
通常这就是您的生产方式

00:04:57.610 --> 00:05:03.970
看起来或多或少

00:05:00.639 --> 00:05:06.900
更多服务，那么您将如何写

00:05:03.970 --> 00:05:11.800
对于这种特定情况进行测试

00:05:06.900 --> 00:05:14.680
所以第一种方法可能就是

00:05:11.800 --> 00:05:17.650
同样的事情，所以你经营你的消费者

00:05:14.680 --> 00:05:20.979
你使生产者运转起来，你

00:05:17.650 --> 00:05:24.009
执行端到端测试，这通常是

00:05:20.979 --> 00:05:27.220
很好，但是如果您有Micro Services或

00:05:24.009 --> 00:05:30.330
如果模型很难实际执行

00:05:27.220 --> 00:05:33.669
例如，如果您运行的是单片

00:05:30.330 --> 00:05:34.960
应用程序，那么基本上你知道你

00:05:33.669 --> 00:05:38.860
可能有各种各样的问题

00:05:34.960 --> 00:05:41.130
就像在制作人那边，我该如何设置

00:05:38.860 --> 00:05:43.690
数据库上我需要一些特殊的东西吗

00:05:41.130 --> 00:05:45.880
该数据库中的表格我需要更多吗

00:05:43.690 --> 00:05:48.240
服务我应该停止类似的事情

00:05:45.880 --> 00:05:52.539
手动，所以有很多问题

00:05:48.240 --> 00:05:54.940
典型的端到端测试，所以另一个

00:05:52.539 --> 00:05:59.800
你可以做的是

00:05:54.940 --> 00:06:02.229
消费者正在与存根聊天，为什么

00:05:59.800 --> 00:06:03.880
你想这样做是因为你

00:06:02.229 --> 00:06:07.770
会有更快的反馈，因为

00:06:03.880 --> 00:06:12.039
它在构建期间运行，所以

00:06:07.770 --> 00:06:15.699
让我们像检查更多这个例子

00:06:12.039 --> 00:06:17.620
细节说，消费者

00:06:15.699 --> 00:06:20.650
应用程序称为关键计算器

00:06:17.620 --> 00:06:23.409
服务，您在这里可以看到的是

00:06:20.650 --> 00:06:28.060
消费者申请权及其

00:06:23.409 --> 00:06:31.630
包含HTTP的一些JSON映射

00:06:28.060 --> 00:06:36.070
服务器存根，因此您要使用的示例

00:06:31.630 --> 00:06:40.120
一秒钟内看到使用电线

00:06:36.070 --> 00:06:43.180
模拟是阻止链条的工具

00:06:40.120 --> 00:06:45.400
 HTTP服务器，因此正在使用一些存根

00:06:43.180 --> 00:06:47.199
电线模拟的正确定义

00:06:45.400 --> 00:06:49.599
我们在消费者方面， 

00:06:47.199 --> 00:06:52.539
消费者拥有存根定义

00:06:49.599 --> 00:06:55.089
作为一个非常关键的眼睛

00:06:52.539 --> 00:06:58.599
消费者我正在写测试，我说

00:06:55.089 --> 00:07:01.059
就像我定义制作人应该如何

00:06:58.599 --> 00:07:03.509
表现，这意味着什么

00:07:01.059 --> 00:07:07.089
是这站吗，让我们看看

00:07:03.509 --> 00:07:11.229
这是存根定义的示例

00:07:07.089 --> 00:07:12.759
带有电线标记，让您拥有

00:07:11.229 --> 00:07:15.069
忽略它的优先级部分

00:07:12.759 --> 00:07:18.339
完全相关，我们有要求， 

00:07:15.069 --> 00:07:21.209
响应正确，就像与mojito一样

00:07:18.339 --> 00:07:23.830
例如，你说给了一些东西

00:07:21.209 --> 00:07:26.379
返回一些值，所以这正是

00:07:23.830 --> 00:07:28.809
同样，如果您要发送

00:07:26.379 --> 00:07:31.629
请求与方法发布到URL 

00:07:28.809 --> 00:07:34.659
历史，则响应应为

00:07:31.629 --> 00:07:37.139
状态为201和内容类型标头

00:07:34.659 --> 00:07:42.969
应该等于应用Jason 

00:07:37.139 --> 00:07:45.639
另一个示例，您正在发送HTTP 

00:07:42.969 --> 00:07:49.209
具有方法的请求可能是URL 

00:07:45.639 --> 00:07:52.330
历史和身体应该包含我的

00:07:49.209 --> 00:07:55.719
像五加五的值，然后

00:07:52.330 --> 00:07:58.360
响应的状态为200 

00:07:55.719 --> 00:08:01.149
将是在正文结果内部的JSON 10 

00:07:58.360 --> 00:08:03.759
例如，计数为e2，标题为

00:08:01.149 --> 00:08:06.610
内容类型应用程序Jason last 

00:08:03.759 --> 00:08:10.539
例如，您要向其中发送吐司方法

00:08:06.610 --> 00:08:13.059
网址历史记录正文应包含一个值

00:08:10.539 --> 00:08:16.749
文字值六加六，然后

00:08:13.059 --> 00:08:21.789
响应应该是400 

00:08:16.749 --> 00:08:24.249
给定一些条件，例如我们的要求

00:08:21.789 --> 00:08:27.369
应该看起来像这样一些回应

00:08:24.249 --> 00:08:30.610
应该寄回去，让我们集中精力

00:08:27.369 --> 00:08:32.740
这个例子我作为消费者有这个

00:08:30.610 --> 00:08:34.930
我定义的JSON文件

00:08:32.740 --> 00:08:39.250
制片人应该表现出来，我有这个

00:08:34.930 --> 00:08:42.219
网址历史记录，所以我如何更改

00:08:39.250 --> 00:08:45.970
从历史记录到URL从历史记录到

00:08:42.219 --> 00:08:48.550
一些不存在的URL为什么我不能做

00:08:45.970 --> 00:08:52.240
因为我基本上拥有存根

00:08:48.550 --> 00:08:55.060
这是一种拖钓，但我可以

00:08:52.240 --> 00:08:57.730
所以现在发生了什么，所以我改变了

00:08:55.060 --> 00:08:58.899
存根定义，所以我说的是

00:08:57.730 --> 00:09:02.769
生产者的行为会有所不同

00:08:58.899 --> 00:09:04.600
我的测试工具

00:09:02.769 --> 00:09:07.059
失败，因为我正在拍摄请求， 

00:09:04.600 --> 00:09:08.739
一个不存在的URL，所以在我的

00:09:07.059 --> 00:09:11.439
我说的生产代码是

00:09:08.739 --> 00:09:14.290
将根据要求拍摄闪光记录

00:09:11.439 --> 00:09:17.559
但现在我的存根说嘿

00:09:14.290 --> 00:09:21.309
没有这样的女孩，我有些不存在

00:09:17.559 --> 00:09:24.569
网址，因此我重写了要使用的代码

00:09:21.309 --> 00:09:27.549
我刚刚更改了新的URL 

00:09:24.569 --> 00:09:29.980
现在单元测试和集成测试通过

00:09:27.549 --> 00:09:32.139
因为我固定了实现方式

00:09:29.980 --> 00:09:36.910
认为生产代码，我认为

00:09:32.139 --> 00:09:38.619
标签，现在开始部署

00:09:36.910 --> 00:09:41.170
我经历了构建阶段的管道

00:09:38.619 --> 00:09:43.179
我正在将应用程序部署到

00:09:41.170 --> 00:09:45.279
在真正的环境中进行干预

00:09:43.179 --> 00:09:47.829
整合状态发挥，所以我们有一个

00:09:45.279 --> 00:09:50.709
几个已部署的应用程序和一些

00:09:47.829 --> 00:09:53.230
端到端测试将进行， 

00:09:50.709 --> 00:09:55.360
显然我没什么好担心的

00:09:53.230 --> 00:09:58.509
因为我的建筑是绿色的，所以我通过了

00:09:55.360 --> 00:10:02.139
不幸的是，情况并非如此

00:09:58.509 --> 00:10:04.389
因为当那些时刻

00:10:02.139 --> 00:10:07.689
运行，那将是一场灾难

00:10:04.389 --> 00:10:11.529
在这种环境下希望

00:10:07.689 --> 00:10:14.160
分期而不是生产怎么办

00:10:11.529 --> 00:10:16.839
怎么了，让我们检查一下

00:10:14.160 --> 00:10:20.429
构建阶段中使用的存根

00:10:16.839 --> 00:10:23.410
与真实的API无关

00:10:20.429 --> 00:10:26.740
随意将URL更改为一些

00:10:23.410 --> 00:10:29.319
您的网址不存在，我的桌面如何

00:10:26.740 --> 00:10:32.709
所以我们身体幽默就全部了

00:10:29.319 --> 00:10:36.579
拥有我今天说的存根

00:10:32.709 --> 00:10:39.549
发送这个奇怪的消息给

00:10:36.579 --> 00:10:41.769
不存在的网址，我们有独角兽

00:10:39.549 --> 00:10:43.299
因为结果还可以，因为

00:10:41.769 --> 00:10:45.009
桌子说是的

00:10:43.299 --> 00:10:47.919
你的头反应会像

00:10:45.009 --> 00:10:51.759
这但实际上当我发送

00:10:47.919 --> 00:10:54.879
对生产者的相同要求

00:10:51.759 --> 00:10:56.860
在那些端到端测试中

00:10:54.879 --> 00:11:02.259
制片人说没有

00:10:56.860 --> 00:11:04.119
端点404，所以我们遇到的问题

00:11:02.259 --> 00:11:06.669
试图解决存根的有效性和

00:11:04.119 --> 00:11:09.429
可重用性的问题是存根

00:11:06.669 --> 00:11:13.540
与消费者一起居住

00:11:09.429 --> 00:11:15.369
控制存根过程，如何

00:11:13.540 --> 00:11:16.300
我们确保此存根有效

00:11:15.369 --> 00:11:19.840
因为消费者

00:11:16.300 --> 00:11:23.920
就在我提出任何愚蠢的事情时

00:11:19.840 --> 00:11:26.020
这是不对的，所以这是一回事

00:11:23.920 --> 00:11:27.550
坚固性和可重复使用性

00:11:26.020 --> 00:11:29.260
我正在从事的项目

00:11:27.550 --> 00:11:30.850
有一个儿子的公司

00:11:29.260 --> 00:11:33.580
建筑，因为我们有一个整体

00:11:30.850 --> 00:11:36.580
中间有很多应用

00:11:33.580 --> 00:11:40.780
微服务与之对话

00:11:36.580 --> 00:11:44.650
团队必须做同样的工作

00:11:40.780 --> 00:11:46.720
他们正在停止模型， 

00:11:44.650 --> 00:11:48.940
问题是他们创造的那一刻

00:11:46.720 --> 00:11:51.370
那些完全过时的存根

00:11:48.940 --> 00:11:53.050
因为模型在

00:11:51.370 --> 00:11:56.020
与此同时

00:11:53.050 --> 00:12:00.250
当然，存根已经投保了

00:11:56.020 --> 00:12:03.550
之间的事物之间，所以每个人

00:12:00.250 --> 00:12:06.190
做同样的工作，所以这是第一个

00:12:03.550 --> 00:12:10.720
问题另一个是好的API创建

00:12:06.190 --> 00:12:13.690
所以消费者被称为消费者

00:12:10.720 --> 00:12:15.640
因为它正在消耗想法，并且

00:12:13.690 --> 00:12:19.240
之所以这样冷是因为

00:12:15.640 --> 00:12:21.400
知道EPI应该是什么样子

00:12:19.240 --> 00:12:23.820
因此他们应该参加

00:12:21.400 --> 00:12:26.800
创建生产者的API 

00:12:23.820 --> 00:12:29.740
我通常会说

00:12:26.800 --> 00:12:33.190
如果制作人团队发生了什么情况

00:12:29.740 --> 00:12:35.350
说更好，这是我的API，如果

00:12:33.190 --> 00:12:38.200
你不喜欢它，不要使用它

00:12:35.350 --> 00:12:40.870
消费者说eh告诉我这个API是

00:12:38.200 --> 00:12:43.120
就像无法使用，我们无法工作

00:12:40.870 --> 00:12:45.250
有了它，你可以改变它， 

00:12:43.120 --> 00:12:49.060
生产者团队通常说的是

00:12:45.250 --> 00:12:50.680
嗯，抱歉，我们必须有一个

00:12:49.060 --> 00:12:52.540
时间表紧张，你可以跟太多人说话

00:12:50.680 --> 00:12:55.600
我们的产品所有者将把它放进去

00:12:52.540 --> 00:12:57.640
我们的冲刺，也许是半年

00:12:55.600 --> 00:12:59.590
我们将修复它，而不是

00:12:57.640 --> 00:13:03.220
因为每个人都不开心而走的路

00:12:59.590 --> 00:13:05.200
因此，生产者API更改应为

00:13:03.220 --> 00:13:09.130
由消费者驱动，因为消费者

00:13:05.200 --> 00:13:10.300
正在使用API​​，所以这是

00:13:09.130 --> 00:13:13.000
如果没有，那会发生

00:13:10.300 --> 00:13:15.970
合作权单元测试问

00:13:13.000 --> 00:13:18.190
但总的来说不合适

00:13:15.970 --> 00:13:20.980
消费者和生产者没有

00:13:18.190 --> 00:13:24.130
在另一个地方遇到另一个例子是

00:13:20.980 --> 00:13:26.710
这样的事情，所以我们认为

00:13:24.130 --> 00:13:29.770
字段应该是ABC，但整个字段

00:13:26.710 --> 00:13:32.760
是的，是的，我们有问题

00:13:29.770 --> 00:13:35.350
所以我们必须以某种方式解决这个问题

00:13:32.760 --> 00:13:42.040
所以这个问题的潜在答案

00:13:35.350 --> 00:13:44.410
实际上是撒合同，所以

00:13:42.040 --> 00:13:48.160
证明它的最好方法是编写代码

00:13:44.410 --> 00:13:50.770
所以我们实际上要编码什么

00:13:48.160 --> 00:13:53.950
消费者将是一个应用程序

00:13:50.770 --> 00:13:56.050
收到啤酒的人

00:13:53.950 --> 00:13:59.080
来到酒吧，说我要啤酒

00:13:56.050 --> 00:14:02.200
因此消费者应用会收到

00:13:59.080 --> 00:14:05.470
请求，它将不得不问另一个

00:14:02.200 --> 00:14:08.320
服务有关客户是否

00:14:05.470 --> 00:14:11.380
有资格获得鹿，所以消费者

00:14:08.320 --> 00:14:14.560
将向生产者发送一个请求

00:14:11.380 --> 00:14:16.270
会说你知道我必须检查

00:14:14.560 --> 00:14:18.670
客户年龄大到可以得到鹿

00:14:16.270 --> 00:14:22.360
因为喜欢把事情简单化

00:14:18.670 --> 00:14:24.220
假设年龄将是

00:14:22.360 --> 00:14:26.560
定义是否

00:14:24.220 --> 00:14:28.330
人可以给局的，所以

00:14:26.560 --> 00:14:31.570
特点是如果用户太年轻

00:14:28.330 --> 00:14:34.840
啤酒将不出售，否则

00:14:31.570 --> 00:14:36.370
啤酒将被授予

00:14:34.840 --> 00:14:41.290
简单起见，如果

00:14:36.370 --> 00:14:44.410
某人年满20岁或以上

00:14:41.290 --> 00:14:47.290
如果他不满20岁，就去喝啤酒

00:14:44.410 --> 00:14:48.940
喝啤酒的机会吧

00:14:47.290 --> 00:14:51.310
之所以这样，是因为它更容易编写

00:14:48.940 --> 00:14:55.530
正则表达式，让我们继续

00:14:51.310 --> 00:14:58.000
是的，那看起来怎么样

00:14:55.530 --> 00:15:01.000
有人来到酒吧说我

00:14:58.000 --> 00:15:04.480
 20给我在这里，让消费者应用

00:15:01.000 --> 00:15:07.570
问了一个他可以拿啤酒和

00:15:04.480 --> 00:15:12.160
答案是肯定的，所以消费者说

00:15:07.570 --> 00:15:15.250
你去，第二个功能，你有

00:15:12.160 --> 00:15:17.440
生产者和某人中的消费者

00:15:15.250 --> 00:15:20.560
来到酒吧，说我17岁给我

00:15:17.440 --> 00:15:23.170
啤酒，所以消费者问生产者

00:15:20.560 --> 00:15:25.810
他可以给啤酒吗，答案是

00:15:23.170 --> 00:15:30.280
不，所以我们说迷路那么典型的东西

00:15:25.810 --> 00:15:32.620
现在在酒吧发生的事情很重要

00:15:30.280 --> 00:15:35.800
事情，因为我一直在讲这个

00:15:32.620 --> 00:15:37.600
很多时候，我认为这是

00:15:35.800 --> 00:15:39.820
区分的最佳方法

00:15:37.600 --> 00:15:43.260
消费者和生产者，所以无论何时

00:15:39.820 --> 00:15:48.150
你看到一个黑色的终端

00:15:43.260 --> 00:15:50.880
或黑色的IBE（即用户端） 

00:15:48.150 --> 00:15:54.150
我还将重复说，我们是

00:15:50.880 --> 00:15:58.320
在消费者方面，只要您看到

00:15:54.150 --> 00:16:02.880
白色终端或白色IDE，表示

00:15:58.320 --> 00:16:06.600
我们在生产者方面好吗

00:16:02.880 --> 00:16:12.650
演示的时间，让我们看一下代码

00:16:06.600 --> 00:16:16.200
这是我们的消费者应用程序

00:16:12.650 --> 00:16:19.080
因为我们没有那么多时间

00:16:16.200 --> 00:16:23.010
我已经有了一些Clutton的代码

00:16:19.080 --> 00:16:25.020
我已经几乎没有生产

00:16:23.010 --> 00:16:29.660
代码我将向您展示

00:16:25.020 --> 00:16:33.570
其次，消费者驱动的合同是

00:16:29.660 --> 00:16:36.090
实际上就像TVD上的架构11 

00:16:33.570 --> 00:16:38.610
这是什么意思

00:16:36.090 --> 00:16:41.580
 TDD，您先进行测试，然后

00:16:38.610 --> 00:16:45.450
事情发展了，所以正是

00:16:41.580 --> 00:16:48.450
这里也有撒文化

00:16:45.450 --> 00:16:50.400
这个想法是API会邪恶，所以

00:16:48.450 --> 00:16:52.440
我们正在做的是开始

00:16:50.400 --> 00:16:54.780
通过测试，我们有两个功能

00:16:52.440 --> 00:16:57.090
写第一个是应该给我一个

00:16:54.780 --> 00:16:58.620
啤酒，当我老了，第二次

00:16:57.090 --> 00:17:01.350
这应该拒绝啤酒上升到

00:16:58.620 --> 00:17:04.520
你，所以我要在这里复制一些代码

00:17:01.350 --> 00:17:04.520
所以我不会犯任何错误

00:17:06.260 --> 00:17:16.890
我们将使用模拟MVC来进行UM 

00:17:12.390 --> 00:17:25.589
测试让我做一些静态导入，所以

00:17:16.890 --> 00:17:28.500
那里你还好，所以这个测试是

00:17:25.589 --> 00:17:32.100
在发布HTTP中发送发布方法

00:17:28.500 --> 00:17:33.930
向啤酒端点请求

00:17:32.100 --> 00:17:36.780
应用程序JSON和

00:17:33.930 --> 00:17:40.920
我们发送的是某人，某人有一个

00:17:36.780 --> 00:17:43.920
名字和年龄，在这种情况下，如果我

00:17:40.920 --> 00:17:48.330
想喝啤酒，我希望我22岁

00:17:43.920 --> 00:17:50.370
不是，但可以说我当时是

00:17:48.330 --> 00:17:52.200
状况会很好，而且回应

00:17:50.370 --> 00:17:55.740
会在那里你走，这是我们的功能

00:17:52.200 --> 00:18:01.590
第二个

00:17:55.740 --> 00:18:04.110
非常相似，但我17岁，然后

00:18:01.590 --> 00:18:08.580
应该发生的是，我收到了

00:18:04.110 --> 00:18:12.059
迷路的消息正确的迷路所以两个

00:18:08.580 --> 00:18:14.460
您超过20岁的人会喝啤酒

00:18:12.059 --> 00:18:16.590
你不到两个，你不是吗

00:18:14.460 --> 00:18:19.140
不要在这里住

00:18:16.590 --> 00:18:21.510
控制器看起来就像我告诉你的

00:18:19.140 --> 00:18:23.580
我已经创建了一些代码框架

00:18:21.510 --> 00:18:26.910
实际上这里什么都没有

00:18:23.580 --> 00:18:29.429
基本上我们有一种后期方法啤酒

00:18:26.910 --> 00:18:33.600
端点应用程序JSON和一个人

00:18:29.429 --> 00:18:38.040
进来所以这时我应该问

00:18:33.600 --> 00:18:41.490
另一个我应该发送请求到

00:18:38.040 --> 00:18:43.340
制片人说一个喜欢你可以检查

00:18:41.490 --> 00:18:46.980
该人有资格获得啤酒

00:18:43.340 --> 00:18:50.220
但实际上另一个站点没有

00:18:46.980 --> 00:18:52.800
如果我写了一行代码

00:18:50.220 --> 00:18:55.260
希望他们创建一些伪造的API 

00:18:52.800 --> 00:18:57.960
或将需要的东西

00:18:55.260 --> 00:18:59.970
一段时间，我想尝试一下

00:18:57.960 --> 00:19:02.790
甚至不知道我们是否要去

00:18:59.970 --> 00:19:04.530
选择是好的，所以我们该怎么做

00:19:02.790 --> 00:19:07.020
来了

00:19:04.530 --> 00:19:09.870
洒了合同，所以对不起黑人

00:19:07.020 --> 00:19:12.720
屏幕我们在消费者方面

00:19:09.870 --> 00:19:14.370
在演示中，我不，我真的不

00:19:12.720 --> 00:19:17.670
想使用互联网，所以我们要

00:19:14.370 --> 00:19:20.820
做一个永久的克隆版本

00:19:17.670 --> 00:19:26.220
我现在作为消费者的项目

00:19:20.820 --> 00:19:29.490
将克隆生产者代码热潮

00:19:26.220 --> 00:19:34.770
像冰一样克隆它，作为一个消费者我

00:19:29.490 --> 00:19:37.500
现在已经克隆了生产者代码

00:19:34.770 --> 00:19:43.530
我检查出正确的分支，对吧

00:19:37.500 --> 00:19:45.510
现在我要打开那个项目

00:19:43.530 --> 00:19:53.250
我们在消费者方面，我正在开放

00:19:45.510 --> 00:19:58.320
生产者本地项目让我们等待

00:19:53.250 --> 00:20:00.480
对于所有导入的是

00:19:58.320 --> 00:20:01.980
现在你可以看到没有

00:20:00.480 --> 00:20:05.040
这里的代码只有生产者

00:20:01.980 --> 00:20:08.559
应用程序没有控制器没什么像

00:20:05.040 --> 00:20:11.440
那我为什么要做

00:20:08.559 --> 00:20:14.950
因为我对泵感兴趣

00:20:11.440 --> 00:20:17.289
在正确设置的项目中

00:20:14.950 --> 00:20:21.249
我有一首很重要的诗

00:20:17.289 --> 00:20:24.190
这就是这样的代码

00:20:21.249 --> 00:20:27.759
合约Maven插件为什么我有它

00:20:24.190 --> 00:20:31.480
你将在一秒钟内看到我是什么

00:20:27.759 --> 00:20:34.749
对这部分感兴趣

00:20:31.480 --> 00:20:38.529
我有合同的源测试资源

00:20:34.749 --> 00:20:40.990
我们定义的那些合同是什么

00:20:38.529 --> 00:20:43.749
合同是

00:20:40.990 --> 00:20:45.970
消费者和生产者如何使用API 

00:20:43.749 --> 00:20:48.190
应该看起来像，在这里我要

00:20:45.970 --> 00:20:50.289
最后一次使用这个词

00:20:48.190 --> 00:20:53.529
第一次也是最后一次，但这不是

00:20:50.289 --> 00:20:55.450
模式，它与功能更多相关

00:20:53.529 --> 00:20:59.019
我们要测试，但这也是

00:20:55.450 --> 00:21:00.850
看起来你应该没有那么多

00:20:59.019 --> 00:21:03.879
签约您拥有的许多功能

00:21:00.850 --> 00:21:07.869
因为合同测试的想法是

00:21:03.879 --> 00:21:10.210
测试语义而不是取代

00:21:07.869 --> 00:21:12.899
就像在功能中一次执行两次

00:21:10.210 --> 00:21:19.690
代码，然后在合同中一次

00:21:12.899 --> 00:21:23.139
在这里我创建了两个工具合同

00:21:19.690 --> 00:21:26.379
冲刺您使用的所有合同

00:21:23.139 --> 00:21:29.460
普通的DSL，所以让我们看看

00:21:26.379 --> 00:21:32.889
合同看起来像这里

00:21:29.460 --> 00:21:37.240
第一种情况，如果

00:21:32.889 --> 00:21:41.889
我够大了，我们有工厂方法

00:21:37.240 --> 00:21:43.659
合同类别以及以下任何一项

00:21:41.889 --> 00:21:47.049
你害怕时髦，因为这是一个

00:21:43.659 --> 00:21:49.080
动态语言，我必须非常

00:21:47.049 --> 00:21:51.490
之所以不同意是因为它可能是动态的， 

00:21:49.080 --> 00:21:54.009
我个人喜欢groovy 

00:21:51.490 --> 00:21:55.840
静态类型的，所以DSL是

00:21:54.009 --> 00:21:59.409
静态键入您要进行的所有操作

00:21:55.840 --> 00:22:00.999
在这里看到我们的方法是

00:21:59.409 --> 00:22:03.580
是静态类型的，因此编译器

00:22:00.999 --> 00:22:06.940
将在我们的每一个方面为我们提供帮助

00:22:03.580 --> 00:22:09.519
编写代码，所以说我

00:22:06.940 --> 00:22:12.610
想要玩的dapi 

00:22:09.519 --> 00:22:15.129
生产者，所以说方法

00:22:12.610 --> 00:22:20.409
我希望他们使用

00:22:15.129 --> 00:22:22.360
双方都准备好URL，我们假设

00:22:20.409 --> 00:22:27.340
可以检查一下

00:22:22.360 --> 00:22:31.900
继续，我会送一些身体

00:22:27.340 --> 00:22:34.020
时髦，您可以使用地图符号

00:22:31.900 --> 00:22:37.420
用精神契约来定义一个身体

00:22:34.020 --> 00:22:40.030
基本上杰森是一张地图，对不起

00:22:37.420 --> 00:22:42.880
可以有一张地图和生活地图的清单

00:22:40.030 --> 00:22:44.860
它基本上可以拥有任何东西

00:22:42.880 --> 00:22:46.840
你可以想象的那种组合

00:22:44.860 --> 00:22:50.350
这就是为什么很难与之合作

00:22:46.840 --> 00:22:52.990
杰森，当你需要解析它，但是

00:22:50.350 --> 00:22:55.720
我想寄出这样的尸体

00:22:52.990 --> 00:22:57.550
假设我想有一个

00:22:55.720 --> 00:22:59.800
 JSON将会有一些

00:22:57.550 --> 00:23:03.640
代号名称

00:22:59.800 --> 00:23:06.940
游行，年龄将是22岁

00:23:03.640 --> 00:23:10.570
我如何定义一个非常好的

00:23:06.940 --> 00:23:13.570
可读方式如何信息杰森

00:23:10.570 --> 00:23:18.250
应该看起来像，现在是时候了

00:23:13.570 --> 00:23:23.170
标头，让我创建一个标头

00:23:18.250 --> 00:23:27.580
关键是内容类型， 

00:23:23.170 --> 00:23:33.520
值将是应用程序JSON，所以这里

00:23:27.580 --> 00:23:36.550
我定义了一些我会要求的要求

00:23:33.520 --> 00:23:38.860
喜欢被匹配时

00:23:36.550 --> 00:23:42.790
考虑应该给啤酒

00:23:38.860 --> 00:23:44.620
已经足够老了

00:23:42.790 --> 00:23:46.300
回应，因为我不忍受任何

00:23:44.620 --> 00:23:48.840
错误，我要从这里复制

00:23:46.300 --> 00:23:53.560
我将向您解释我做了什么

00:23:48.840 --> 00:23:58.060
所以在这种情况下，我认为是

00:23:53.560 --> 00:24:01.990
拥有状态200这是另一种方式

00:23:58.060 --> 00:24:04.660
定义身体检查员合同的方式

00:24:01.990 --> 00:24:09.400
在groovy中，您可以做多行字符串

00:24:04.660 --> 00:24:11.590
通过提供那些免费字符

00:24:09.400 --> 00:24:14.650
在这里，我只是定义了哪种JSON 

00:24:11.590 --> 00:24:17.860
我希望这个人有资格

00:24:14.650 --> 00:24:20.620
得到啤酒和回应

00:24:17.860 --> 00:24:22.780
我希望内容类型等于

00:24:20.620 --> 00:24:25.780
应用程序JSON有一些神奇之处

00:24:22.780 --> 00:24:28.750
魔术在这里不介意

00:24:25.780 --> 00:24:31.690
目前，我们期望的是

00:24:28.750 --> 00:24:35.140
响应将具有应用程序JSON 

00:24:31.690 --> 00:24:35.680
内容类型正确，所以在这里我们定义一个

00:24:35.140 --> 00:24:37.690
非常

00:24:35.680 --> 00:24:40.210
与之签订合同

00:24:37.690 --> 00:24:42.580
方法发布和URL检查主体

00:24:40.210 --> 00:24:45.160
包含22岁时行军的名字

00:24:42.580 --> 00:24:47.550
它实际上是一个JSON，我们期望

00:24:45.160 --> 00:24:51.160
回复状态为200和身体

00:24:47.550 --> 00:24:53.800
具有字段状态为的JSON 

00:24:51.160 --> 00:24:57.220
值还可以，标题为

00:24:53.800 --> 00:24:59.740
应用程序JSON，因此第二个

00:24:57.220 --> 00:25:02.650
我正在做的是pH值是

00:24:59.740 --> 00:25:08.380
现在是17，状态应为备注

00:25:02.650 --> 00:25:10.930
好的，所以这就是我作为

00:25:08.380 --> 00:25:14.620
消费者，我正在和

00:25:10.930 --> 00:25:17.110
生产者的合同，但是我为什么

00:25:14.620 --> 00:25:20.290
即使这样做也很重要，所以让我们

00:25:17.110 --> 00:25:24.640
回到我们作为消费者的终端

00:25:20.290 --> 00:25:28.030
我在克隆的生产者代码中是什么

00:25:24.640 --> 00:25:30.100
我现在要去做

00:25:28.030 --> 00:25:31.480
清理安装并跳过以下测试

00:25:30.100 --> 00:25:34.030
当然你不应该这样

00:25:31.480 --> 00:25:36.100
您现在喜欢真正的生产代码

00:25:34.030 --> 00:25:38.860
我们正在使用的API 

00:25:36.100 --> 00:25:42.930
为什么我在做什么，为什么会这样，所以你在

00:25:38.860 --> 00:25:47.590
如果我们向上滚动，将在一秒钟内看到

00:25:42.930 --> 00:25:50.560
您将看到Spring Cloud Contract Maven 

00:25:47.590 --> 00:25:54.480
插件在起作用，所以会发生什么

00:25:50.560 --> 00:25:57.430
打印出合同的Maven插件是

00:25:54.480 --> 00:26:00.610
分析您拥有的合同

00:25:57.430 --> 00:26:04.240
定义并将其转换为

00:26:00.610 --> 00:26:06.970
连线日志存根映射，所以如果我们返回

00:26:04.240 --> 00:26:11.410
到二维代码，您将看到一个目标

00:26:06.970 --> 00:26:15.870
像这里和映射中一样来

00:26:11.410 --> 00:26:19.120
部分，您将看到一个电线模拟存根I 

00:26:15.870 --> 00:26:22.030
已经给你展示了一个例子

00:26:19.120 --> 00:26:24.790
在演示过程中连接模拟存根

00:26:22.030 --> 00:26:28.450
阶段，在这里您可以看到DSL 

00:26:24.790 --> 00:26:30.640
已更改为Wire模拟JSON文件

00:26:28.450 --> 00:26:32.560
所以在这里你可以看到如果有人

00:26:30.640 --> 00:26:35.290
显示您请求的URL检查

00:26:32.560 --> 00:26:37.810
带有方法发布和内容类型

00:26:35.290 --> 00:26:40.600
等于应用程序JSON，在这里您可以

00:26:37.810 --> 00:26:43.990
看到我们正在使用JSON路径

00:26:40.600 --> 00:26:47.470
分析JSON，因此名称必须为

00:26:43.990 --> 00:26:49.120
行军和h22如果是这样，那么

00:26:47.470 --> 00:26:50.880
响应应该是200 

00:26:49.120 --> 00:26:53.980
身体应该没问题， 

00:26:50.880 --> 00:26:56.830
补偿应用程序JSON，因此第一个

00:26:53.980 --> 00:26:59.830
洒了合同的专家

00:26:56.830 --> 00:27:04.980
插件Gradle也是吗

00:26:59.830 --> 00:27:09.550
将DSL转换成此存根

00:27:04.980 --> 00:27:14.260
它所做的另一件事是

00:27:09.550 --> 00:27:18.000
将这些存根安装到本地

00:27:14.260 --> 00:27:21.340
 Maven存储库现在作为一个

00:27:18.000 --> 00:27:24.100
我清楚地与之互动的消费者

00:27:21.340 --> 00:27:28.630
生产者的API，我安装了

00:27:24.100 --> 00:27:32.100
它存根到我的伴侣和本地为什么

00:27:28.630 --> 00:27:36.040
我现在就这样做，让我们回到

00:27:32.100 --> 00:27:39.520
消费者代码，所以我们回来了，这是我们的

00:27:36.040 --> 00:27:42.520
测试让我们看看它是否通过了

00:27:39.520 --> 00:27:45.450
不会通过，因为我们没有写

00:27:42.520 --> 00:27:48.760
单行之类的生产代码

00:27:45.450 --> 00:27:51.400
繁荣当然是行不通的，所以让我们

00:27:48.760 --> 00:27:54.250
在这里写一些代码我在这里

00:27:51.400 --> 00:28:03.460
所以我希望不会犯任何错误

00:27:54.250 --> 00:28:06.190
不好吧，让我们做一些导入吧

00:28:03.460 --> 00:28:10.090
所以我使用风险发送请求

00:28:06.190 --> 00:28:13.720
带有post方法的模板到30 

00:28:10.090 --> 00:28:16.270
 20欧元的URI本地酱8090 

00:28:13.720 --> 00:28:20.590
一个URL检查应用程序JSON，我是

00:28:16.270 --> 00:28:22.900
派人到那里然后

00:28:20.590 --> 00:28:26.860
我正在检查状态，就像我们在

00:28:22.900 --> 00:28:29.620
接受标准，所以你去

00:28:26.860 --> 00:28:31.660
状态一旦发送回给用户

00:28:29.620 --> 00:28:35.230
可以，这样用户就可以喝啤酒了

00:28:31.660 --> 00:28:39.940
如果不让我们迷路的话

00:28:35.230 --> 00:28:42.370
看看测试是否通过了

00:28:39.940 --> 00:28:46.870
不会，我们会非常讨厌

00:28:42.370 --> 00:28:50.429
 IO异常和它

00:28:46.870 --> 00:28:57.310
有道理，因为我发送了一个真实的

00:28:50.429 --> 00:29:00.880
请求到真实网址，但我没有

00:28:57.310 --> 00:29:02.510
启动任何服务器对，我的意思是你看到了

00:29:00.880 --> 00:29:06.200
我所做的一切

00:29:02.510 --> 00:29:09.320
我刚刚添加了一些实现

00:29:06.200 --> 00:29:12.110
但是我没有启动任何服务器，所以在这里

00:29:09.320 --> 00:29:15.470
与消费者签订租赁合同

00:29:12.110 --> 00:29:18.200
侧喷头合同包含

00:29:15.470 --> 00:29:21.890
可以叫桌旗的模块

00:29:18.200 --> 00:29:26.299
想象存根赛跑者跑停，这就是为什么

00:29:21.890 --> 00:29:29.419
这个名字很好，我告诉

00:29:26.299 --> 00:29:32.750
存根赛跑者离线工作是什么

00:29:29.419 --> 00:29:36.650
这意味着存根转轮请找到

00:29:32.750 --> 00:29:39.679
我的合作者的存根

00:29:36.650 --> 00:29:42.590
这就是我安装本地Maven存储库的原因

00:29:39.679 --> 00:29:44.000
对于本地的生产者存根

00:29:42.590 --> 00:29:47.330
因为现在我想玩

00:29:44.000 --> 00:29:49.790
与生产者的API，因此

00:29:47.330 --> 00:29:54.320
存根安装在本地的我的邮件中

00:29:49.790 --> 00:29:56.270
我在这里说的是

00:29:54.320 --> 00:29:59.000
想要你先生。 Staub跑步者

00:29:56.270 --> 00:30:02.540
下载的是具有组ID的文件

00:29:59.000 --> 00:30:05.690
梳齿示例工件ID的纯API 

00:30:02.540 --> 00:30:08.210
制作人提供最新版本

00:30:05.690 --> 00:30:12.049
分类器存根，请注册

00:30:08.210 --> 00:30:12.590
他们回到89号港口

00:30:12.049 --> 00:30:14.780
终奌站

00:30:12.590 --> 00:30:17.780
您将在安装时看到

00:30:14.780 --> 00:30:20.350
生产者存根，你可以看到平静

00:30:17.780 --> 00:30:24.500
啤酒API生产商示例

00:30:20.350 --> 00:30:27.950
 0:01快照和存根在这里

00:30:24.500 --> 00:30:30.919
从理论上讲，分类器已停止

00:30:27.950 --> 00:30:33.890
我期望的是当我跑步时

00:30:30.919 --> 00:30:38.110
存根赛跑者将下载停靠点

00:30:33.890 --> 00:30:41.690
从我的Mason mavin徽标开始

00:30:38.110 --> 00:30:45.440
 HTTP服务器存根，并以

00:30:41.690 --> 00:30:46.460
生产者的存根，所以如果我不做的话

00:30:45.440 --> 00:30:52.490
哪里不对了

00:30:46.460 --> 00:30:56.660
测试应该通过，他们这样做了

00:30:52.490 --> 00:31:00.020
发生了什么事，他们为什么要任务，如果我们

00:30:56.660 --> 00:31:04.929
在这里查看控制台会发生什么

00:31:00.020 --> 00:31:08.030
是桌手解决了

00:31:04.929 --> 00:31:12.380
版本到平静示例局API 

00:31:08.030 --> 00:31:14.970
带有分类器存根的生产者罐

00:31:12.380 --> 00:31:18.650
版本通常是一张快照

00:31:14.970 --> 00:31:22.230
然后把那个罐子里的东西停下来

00:31:18.650 --> 00:31:24.630
喂电线模拟存根mcguire模拟

00:31:22.230 --> 00:31:27.990
服务器与存根，并开始了

00:31:24.630 --> 00:31:29.820
如果您在端口80 90处安装有线拖把服务器

00:31:27.990 --> 00:31:32.100
不相信我，我们可以去喝啤酒

00:31:29.820 --> 00:31:35.460
控制器，我将放置一个断点

00:31:32.100 --> 00:31:38.510
在这里，让我们运行第一种情况

00:31:35.460 --> 00:31:44.400
我足够大的时候应该喝啤酒

00:31:38.510 --> 00:31:47.640
我们正在测试断点是

00:31:44.400 --> 00:31:51.480
在这里和这里，您可以在

00:31:47.640 --> 00:31:56.130
我们的身体反应良好

00:31:51.480 --> 00:32:01.320
头是应用程序JSON，所以

00:31:56.130 --> 00:32:03.929
确实工作正常，所以这是

00:32:01.320 --> 00:32:08.250
 Stricker合约的魔力，但是这个主意

00:32:03.929 --> 00:32:11.880
整个流程的背后是玩转

00:32:08.250 --> 00:32:14.549
使用API​​，所以突然我说这是一种

00:32:11.880 --> 00:32:18.179
愚蠢的我无论收到什么

00:32:14.549 --> 00:32:21.090
我的身边，并发送给生产者

00:32:18.179 --> 00:32:24.210
正确的对象但生产者

00:32:21.090 --> 00:32:28.890
不应该在乎我的意思是

00:32:24.210 --> 00:32:31.140
唯一的标准应该是年龄，所以让我们

00:32:28.890 --> 00:32:33.270
说我要去玩

00:32:31.140 --> 00:32:36.299
我目前不喜欢的API 

00:32:33.270 --> 00:32:40.020
看起来很棒， 

00:32:36.299 --> 00:32:41.880
我还没有写过一行

00:32:40.020 --> 00:32:43.650
生产者方面的实施

00:32:41.880 --> 00:32:46.640
我只是在哪里玩

00:32:43.650 --> 00:32:50.220
合同我要发送请求

00:32:46.640 --> 00:32:52.919
我将只通过

00:32:50.220 --> 00:32:56.580
人的年龄唯一

00:32:52.919 --> 00:33:01.330
已经改变了，让我们运行测试

00:32:56.580 --> 00:33:04.420
再来看看

00:33:01.330 --> 00:33:08.320
即将发生的繁荣测试失败了为什么

00:33:04.420 --> 00:33:11.530
这是因为我不匹配的歌吗

00:33:08.320 --> 00:33:14.290
合同，所以电线暴徒告诉我

00:33:11.530 --> 00:33:18.760
最接近的匹配是

00:33:14.290 --> 00:33:22.990
两个字段都年龄和名称，而我是

00:33:18.760 --> 00:33:26.410
只发送年龄字段，所以我说嘿

00:33:22.990 --> 00:33:29.910
好吧公平，我的坏事我忘记了

00:33:26.410 --> 00:33:32.470
关于这一点，基本上它应该喜欢

00:33:29.910 --> 00:33:34.330
最好打个铃

00:33:32.470 --> 00:33:37.420
这种情况例如

00:33:34.330 --> 00:33:39.850
在API中，您输入错误，所以如果您

00:33:37.420 --> 00:33:41.740
输入错误，测试将不及格

00:33:39.850 --> 00:33:45.610
因为最接近的匹配是

00:33:41.740 --> 00:33:47.980
一没有错字，所以我们去

00:33:45.610 --> 00:33:50.470
回到合同，我们说

00:33:47.980 --> 00:33:54.010
嘿，我的意思是名字应该在那里

00:33:50.470 --> 00:33:56.940
好的，让我们删除nei什么

00:33:54.010 --> 00:34:00.340
我们现在正在做的是

00:33:56.940 --> 00:34:03.790
从本地安装存根

00:34:00.340 --> 00:34:04.690
生产者正在运行的全新安装和

00:34:03.790 --> 00:34:06.460
我们正在跳过测试

00:34:04.690 --> 00:34:09.400
那么为什么我们跳过测试你

00:34:06.460 --> 00:34:12.010
我们去的时候一秒钟就会看到

00:34:09.400 --> 00:34:15.430
到生产者方面，所以这里再次

00:34:12.010 --> 00:34:18.910
如果我们签出存根，就会创建存根

00:34:15.430 --> 00:34:21.670
在目标这里不再有

00:34:18.910 --> 00:34:24.910
名称字段，所以如果我们返回到

00:34:21.670 --> 00:34:28.330
消费者，我们会重新运行测试

00:34:24.910 --> 00:34:30.970
希望这些测试通过，因为

00:34:28.330 --> 00:34:33.550
名称字段不再是必需的，并且

00:34:30.970 --> 00:34:36.220
是这样，另一件事是

00:34:33.550 --> 00:34:41.620
我正在做的是，如果我回到我的

00:34:36.220 --> 00:34:44.200
测试，我说我实际上想

00:34:41.620 --> 00:34:47.890
如果我50岁和10岁，则该测试通过

00:34:44.200 --> 00:34:50.740
当然，在这里我有点

00:34:47.890 --> 00:34:53.860
复制功能，但

00:34:50.740 --> 00:34:57.490
想法是告诉你，如果不是

00:34:53.860 --> 00:34:59.980
您将拥有时间戳或年龄的年龄

00:34:57.490 --> 00:35:01.660
您将拥有两个数据库ID 

00:34:59.980 --> 00:35:04.150
例如他们回到这个时候

00:35:01.660 --> 00:35:07.780
例如，您必须设置图章

00:35:04.150 --> 00:35:11.860
像将时钟固定在测试中

00:35:07.780 --> 00:35:15.010
在您的时间设置相同的时间值

00:35:11.860 --> 00:35:16.900
你的例子，所以我们会

00:35:15.010 --> 00:35:21.280
这是正确的合同

00:35:16.900 --> 00:35:23.530
非常僵化，假设我们会

00:35:21.280 --> 00:35:26.400
引入一些耦合形式

00:35:23.530 --> 00:35:30.850
你将不得不非常精确地

00:35:26.400 --> 00:35:33.460
创建的请求可能像

00:35:30.850 --> 00:35:35.710
很难实现，所以我们能做些什么

00:35:33.460 --> 00:35:38.560
现在如果我运行测试

00:35:35.710 --> 00:35:42.250
应该失败，因为我们期望

00:35:38.560 --> 00:35:45.270
年龄分别是22岁和17岁

00:35:42.250 --> 00:35:48.760
这样的话，我们可以做的就是使用

00:35:45.270 --> 00:35:52.060
洒水器附带的动态值

00:35:48.760 --> 00:35:55.570
签约，所以要做的是

00:35:52.060 --> 00:35:58.570
调用一个名为value的方法并说

00:35:55.570 --> 00:36:02.200
消费者想要定期

00:35:58.570 --> 00:36:05.350
在这里表达，如果我够大的话

00:36:02.200 --> 00:36:07.690
表示H的值为

00:36:05.350 --> 00:36:09.490
第一位数字是2到9，而

00:36:07.690 --> 00:36:11.890
今晚最后一个是0，这就是为什么我

00:36:09.490 --> 00:36:13.840
想像这样结束

00:36:11.890 --> 00:36:15.010
 20，那么您就有资格喝啤酒

00:36:13.840 --> 00:36:19.600
因为写一个普通的书更容易

00:36:15.010 --> 00:36:22.000
如果你不老的话

00:36:19.600 --> 00:36:25.000
正则表达式看起来足够

00:36:22.000 --> 00:36:28.570
像这样的权利，因此请求应该是

00:36:25.000 --> 00:36:31.420
年龄小于19岁时匹配

00:36:28.570 --> 00:36:34.750
或等于19，所以我们要做的是

00:36:31.420 --> 00:36:37.810
现在，我们将运行

00:36:34.750 --> 00:36:41.140
再次安装存根

00:36:37.810 --> 00:36:42.670
在生产者方面跳过测试

00:36:41.140 --> 00:36:46.060
消费者对不起的顶峰

00:36:42.670 --> 00:36:48.190
但是在克隆生产者代码中

00:36:46.060 --> 00:36:52.000
与我们为之所做的相同的事情

00:36:48.190 --> 00:36:53.740
最后几个例子，如果现在

00:36:52.000 --> 00:36:56.470
我运行它，但没有做错任何事

00:36:53.740 --> 00:36:59.580
测试应该通过，因为常规

00:36:56.470 --> 00:37:04.030
表达式将被匹配，因此它们可以

00:36:59.580 --> 00:37:06.820
我现在说的很棒，作为消费者

00:37:04.030 --> 00:37:08.590
好吧，我计划与

00:37:06.820 --> 00:37:10.840
 API我对我们的工作感到非常满意

00:37:08.590 --> 00:37:14.020
实现了这是我的合同

00:37:10.840 --> 00:37:18.240
此时此刻我很满意

00:37:14.020 --> 00:37:22.390
向PR提出PR请求

00:37:18.240 --> 00:37:25.930
制片人，所以现在我们要

00:37:22.390 --> 00:37:26.690
生产者方面，我们在这里白色

00:37:25.930 --> 00:37:29.870
屏幕

00:37:26.690 --> 00:37:32.900
制片人，现在我们要去

00:37:29.870 --> 00:37:37.880
我们那里有白色的IDE 

00:37:32.900 --> 00:37:40.280
所以我们在生产者方面，我们

00:37:37.880 --> 00:37:42.320
已经接受了拉取请求，我是说我们

00:37:40.280 --> 00:37:45.650
已经接管了，所以我们还没有

00:37:42.320 --> 00:37:49.010
合并它，但是我们看到一个TR，我们要

00:37:45.650 --> 00:37:50.870
玩弄它，我必须

00:37:49.010 --> 00:37:54.020
加快速度，我创造了一个非常

00:37:50.870 --> 00:37:55.760
我有的简单的生产者控制器

00:37:54.020 --> 00:37:58.970
人员检查人员检查

00:37:55.760 --> 00:38:02.240
只是H，仅此而已

00:37:58.970 --> 00:38:03.620
响应的状态将等于

00:38:02.240 --> 00:38:07.010
可以还是不可以

00:38:03.620 --> 00:38:09.650
就是这样，我们要做的是

00:38:07.010 --> 00:38:12.740
现在是我们要打扫干净

00:38:09.650 --> 00:38:16.070
安装我还没有写过一个测试

00:38:12.740 --> 00:38:18.190
让我们运行它，看看有什么

00:38:16.070 --> 00:38:18.190
发生

00:38:19.990 --> 00:38:26.030
我为什么要说我发生了什么

00:38:23.000 --> 00:38:30.580
还没写过一个测试，为什么

00:38:26.030 --> 00:38:33.860
我必须考试不及格，很抱歉

00:38:30.580 --> 00:38:36.830
所以发生的是洒

00:38:33.860 --> 00:38:39.230
合同Maven插件，除了

00:38:36.830 --> 00:38:42.920
它正在将合同转换为

00:38:39.230 --> 00:38:47.420
存根它也在转换合同

00:38:42.920 --> 00:38:49.370
进行测试，因此在这里您可以看到

00:38:47.420 --> 00:38:51.290
那两个例子我应该给予

00:38:49.370 --> 00:38:53.980
 burek年纪大了，应该拒绝

00:38:51.290 --> 00:38:56.780
狄拉克（Dirac）太年轻，正在创建两个测试

00:38:53.980 --> 00:39:00.710
这些测试是完全

00:38:56.780 --> 00:39:03.650
自动生成这些测试的功能

00:39:00.710 --> 00:39:06.500
如果在这里我们说如果我够大的话

00:39:03.650 --> 00:39:08.570
我正在发送一个方法发布给你

00:39:06.500 --> 00:39:11.420
就像一个方法请求的一周请求

00:39:08.570 --> 00:39:13.850
到带有特定正文的URL检查

00:39:11.420 --> 00:39:17.740
 match是一个正则表达式，那么我们

00:39:13.850 --> 00:39:21.410
期望状态为200，状态为ok 

00:39:17.740 --> 00:39:23.180
因此，实际上我们正在创建一个

00:39:21.410 --> 00:39:25.970
标头内容类型的请求

00:39:23.180 --> 00:39:29.000
与年龄匹配的应用程序JSON 

00:39:25.970 --> 00:39:31.790
正则表达式，我们

00:39:29.000 --> 00:39:35.210
发送帖子的发布方法

00:39:31.790 --> 00:39:38.030
检查网址的方法，然后我们

00:39:35.210 --> 00:39:40.520
期望状态码为200，内容为

00:39:38.030 --> 00:39:42.470
键入以匹配应用程序JSON 

00:39:40.520 --> 00:39:46.570
很酷的是，我们还检查了

00:39:42.470 --> 00:39:48.890
身体指向我们这样做是为什么

00:39:46.570 --> 00:39:51.980
因为如果你在说谎

00:39:48.890 --> 00:39:55.400
在您的合同中，事情就像

00:39:51.980 --> 00:39:57.920
然后我们要像这个测试

00:39:55.400 --> 00:40:01.610
中断，所以我的实现不是

00:39:57.920 --> 00:40:04.130
准备要做什么让我们

00:40:01.610 --> 00:40:07.790
说与此合规

00:40:04.130 --> 00:40:10.760
合同，这就是为什么自动生成

00:40:07.790 --> 00:40:14.090
测试失败，所以我需要做的事情

00:40:10.760 --> 00:40:18.320
是在这里写一些实现

00:40:14.090 --> 00:40:21.830
如果要检查的人的H大于或

00:40:18.320 --> 00:40:23.930
等于20然后我要返回一个新的

00:40:21.830 --> 00:40:27.170
 berchik状态的响应等于

00:40:23.930 --> 00:40:29.570
好吧，我正在做的事情很快

00:40:27.170 --> 00:40:32.060
我要进行测试

00:40:29.570 --> 00:40:34.820
自动生成的测试又可以了

00:40:32.060 --> 00:40:37.970
通过了，哪一个通过了

00:40:34.820 --> 00:40:40.280
向我发送真正的请求

00:40:37.970 --> 00:40:43.820
控制器并检查其状态

00:40:40.280 --> 00:40:46.850
好吧，让我们运行第二个

00:40:43.820 --> 00:40:50.290
在这里，我们有了新的回应

00:40:46.850 --> 00:40:55.610
啤酒检查状态等于不正常

00:40:50.290 --> 00:40:58.100
运行这个，两个测试都通过了

00:40:55.610 --> 00:41:01.850
现在当电脑，当制作人

00:40:58.100 --> 00:41:04.760
知道我的实现是匹配的

00:41:01.850 --> 00:41:11.120
我可以在合同上写什么

00:41:04.760 --> 00:41:13.400
通过运行构建来证明这一点

00:41:11.120 --> 00:41:15.920
我正在运行自动生成的构建

00:41:13.400 --> 00:41:19.100
测试已通过，我已经安装了

00:41:15.920 --> 00:41:21.710
本地存根至关重要的是说

00:41:19.100 --> 00:41:23.540
是这些是相同的合同

00:41:21.710 --> 00:41:27.880
消费者习惯于自己写

00:41:23.540 --> 00:41:32.290
测试，所以我们有一个真理来源

00:41:27.880 --> 00:41:35.780
双方共享

00:41:32.290 --> 00:41:38.420
所以现在我会在

00:41:35.780 --> 00:41:43.580
真正的意思是，一旦我合并了

00:41:38.420 --> 00:41:48.560
 pr SEI工具，例如，建立生产者

00:41:43.580 --> 00:41:50.750
代码并使用

00:41:48.560 --> 00:41:52.700
在应用程序上的父亲和一些停止

00:41:50.750 --> 00:41:53.349
神器3 Nexus或类似的东西

00:41:52.700 --> 00:41:57.660
对

00:41:53.349 --> 00:42:03.940
那么现在让我们切换消费者

00:41:57.660 --> 00:42:07.299
然后在我的内在和我的内在哪里

00:42:03.940 --> 00:42:09.969
这种相反的消费者测试我会

00:42:07.299 --> 00:42:16.499
将说谎的工作改为假， 

00:42:09.969 --> 00:42:21.910
提供与我的Nexus一样的网址给我

00:42:16.499 --> 00:42:24.999
 Nexus或人工通讯/离开

00:42:21.910 --> 00:42:27.969
随时以任何方式释放本地

00:42:24.999 --> 00:42:28.509
我建立应用程式就像建立我的执行

00:42:27.969 --> 00:42:31.299
测试

00:42:28.509 --> 00:42:34.029
世界各地的最新存根

00:42:31.299 --> 00:42:37.390
您在此处提供的将是

00:42:34.029 --> 00:42:39.699
下载并运行我的测试

00:42:37.390 --> 00:42:41.199
反对这项权利，但由于我不

00:42:39.699 --> 00:42:44.380
这里有一个神器树让我们回去

00:42:41.199 --> 00:42:46.660
到离线工作，最后

00:42:44.380 --> 00:42:50.349
告诉你的是，如果我回去

00:42:46.660 --> 00:42:53.289
到生产者代码，抱歉，让我们

00:42:50.349 --> 00:42:55.420
说，出于某种原因，我决定

00:42:53.289 --> 00:42:59.890
做一个我不应该做的重大改变

00:42:55.420 --> 00:43:01.869
但我是因为我不知道为什么

00:42:59.890 --> 00:43:05.680
做一个重大的改变并改变

00:43:01.869 --> 00:43:11.259
从支票到啤酒的网址，如果我去

00:43:05.680 --> 00:43:14.259
回到我的终端，我正在跑步

00:43:11.259 --> 00:43:17.859
 Maven构建自动生成的测试

00:43:14.259 --> 00:43:21.190
应该失败为什么会这样，因为那里

00:43:17.859 --> 00:43:25.479
没有喝啤酒的终点

00:43:21.190 --> 00:43:29.140
检查端点，所以我得到404，所以如果我

00:43:25.479 --> 00:43:33.400
回到代码，我修复了

00:43:29.140 --> 00:43:35.589
像我修理刹车的情况

00:43:33.400 --> 00:43:37.630
我是说我一直在努力改变

00:43:35.589 --> 00:43:40.829
生产代码，如果我回到

00:43:37.630 --> 00:43:44.049
合同验证者在这里我可以看到

00:43:40.829 --> 00:43:49.299
他们的新网址，所以如果我运行这些测试

00:43:44.049 --> 00:43:49.989
他们应该通过，我回到

00:43:49.299 --> 00:43:56.859
终奌站

00:43:49.989 --> 00:43:57.480
我再次运行Maven构建

00:43:56.859 --> 00:43:59.460
应该

00:43:57.480 --> 00:44:03.829
我已经安装了最新的站点

00:43:59.460 --> 00:44:07.790
所以现在如果我回到本地

00:44:03.829 --> 00:44:10.410
消费者代码，如果我再次运行那些测试

00:44:07.790 --> 00:44:15.930
应该发生的是那些测试

00:44:10.410 --> 00:44:19.380
会破裂，所以想象一下情况

00:44:15.930 --> 00:44:22.619
现实，所以对于一些生产者

00:44:19.380 --> 00:44:25.829
错误或故意

00:44:22.619 --> 00:44:28.290
上传了违约合同

00:44:25.829 --> 00:44:30.630
向后兼容性测试

00:44:28.290 --> 00:44:33.750
将立即中断，因为

00:44:30.630 --> 00:44:36.960
这次最接近的比赛是不同的

00:44:33.750 --> 00:44:38.460
 URL，因此被破坏的那个

00:44:36.960 --> 00:44:42.059
为了让我修复它，我将不得不

00:44:38.460 --> 00:44:44.700
改变那里的实现好吧

00:44:42.059 --> 00:44:49.470
演示结束，让我们回到

00:44:44.700 --> 00:44:53.220
演示文稿，让我们做一些

00:44:49.470 --> 00:44:55.530
摘要，所以您可以看到的是，我们

00:44:53.220 --> 00:44:58.619
拥有该消费者第一阶段，因此

00:44:55.530 --> 00:45:02.010
消费者已完成一些离线工作

00:44:58.619 --> 00:45:04.440
它正在使用像TDD这样的API进行播放

00:45:02.010 --> 00:45:08.569
在架构层面上

00:45:04.440 --> 00:45:12.059
 AP直到开心为止

00:45:08.569 --> 00:45:15.930
合同约定可以是

00:45:12.059 --> 00:45:18.630
制片人写的那一刻

00:45:15.930 --> 00:45:21.059
部分，以便这些事情可以并行进行

00:45:18.630 --> 00:45:24.270
所以合同一经达成

00:45:21.059 --> 00:45:25.980
双方可以并行工作，所以

00:45:24.270 --> 00:45:27.630
生产者正在实施该功能，并且

00:45:25.980 --> 00:45:34.260
然后消费者转为在线

00:45:27.630 --> 00:45:36.690
模式，让我们看一下图像， 

00:45:34.260 --> 00:45:38.490
有一个例子，如消费者

00:45:36.690 --> 00:45:42.420
在右边或左边，我们有一个

00:45:38.490 --> 00:45:46.589
拥有这只的生产者

00:45:42.420 --> 00:45:48.900
合同权利，因此消费者可以克隆

00:45:46.589 --> 00:45:53.160
生产者代码并与

00:45:48.900 --> 00:45:55.020
当地俱乐部有一个调查互动

00:45:53.160 --> 00:45:57.900
在消费者和消费者之间

00:45:55.020 --> 00:46:01.859
克隆制作人来玩

00:45:57.900 --> 00:46:05.460
消费者满意后立即签约

00:46:01.859 --> 00:46:08.549
它将生产者的公关文件与

00:46:05.460 --> 00:46:11.180
新合同的提议

00:46:08.549 --> 00:46:14.250
变化之类的

00:46:11.180 --> 00:46:16.260
所以这都是关于TDD的，所以你写一个

00:46:14.250 --> 00:46:17.970
以消费者身份测试该功能

00:46:16.260 --> 00:46:21.500
在本地克隆Perl代码以进行更改

00:46:17.970 --> 00:46:24.210
 API，并记住您安装了

00:46:21.500 --> 00:46:27.480
本地存根，以便您克隆

00:46:24.210 --> 00:46:30.720
安装存根的生产者代码

00:46:27.480 --> 00:46:32.640
然后在本地将存根转轮

00:46:30.720 --> 00:46:35.190
在离线模式下工作，因为您

00:46:32.640 --> 00:46:37.680
不想从Nexus下载停靠站

00:46:35.190 --> 00:46:40.320
还是您必须提供的电池

00:46:37.680 --> 00:46:42.540
组ID和工件ID以及

00:46:40.320 --> 00:46:44.370
像生产者一样的版本

00:46:42.540 --> 00:46:45.930
如果你去撒合同

00:46:44.370 --> 00:46:48.060
您会看到不同的文档

00:46:45.930 --> 00:46:51.150
版本控制方法，请检查

00:46:48.060 --> 00:46:53.480
出来，你确实会阅读所有因素

00:46:51.150 --> 00:46:57.270
直到您对API满意为止

00:46:53.480 --> 00:47:00.410
一旦API被接受并进行测试

00:46:57.270 --> 00:47:03.650
停止您向生产者提交pr2 

00:47:00.410 --> 00:47:06.230
现在生产者接管了公关

00:47:03.650 --> 00:47:11.070
写缺少的实现，并

00:47:06.230 --> 00:47:14.850
一旦TR合并了CI工具

00:47:11.070 --> 00:47:19.860
将上传存根和父亲罐

00:47:14.850 --> 00:47:21.300
 Nexus或人工制品，因此我们接管了

00:47:19.860 --> 00:47:23.730
公关我们写失踪者

00:47:21.300 --> 00:47:26.700
实施，因为我们正在使用

00:47:23.730 --> 00:47:28.560
那里的Spring Cloud Contract Maven插件

00:47:26.700 --> 00:47:30.960
将是一些自动生成的测试

00:47:28.560 --> 00:47:33.690
为我们创造了他们拥有我们的权利

00:47:30.960 --> 00:47:36.630
必须让他们通过我们合并TR 

00:47:33.690 --> 00:47:39.900
这样我们部署CI工具

00:47:36.630 --> 00:47:43.280
部署应用程序并停止

00:47:39.900 --> 00:47:45.810
下一个授权工厂然后是消费者

00:47:43.280 --> 00:47:47.700
切换到在线模式，然后

00:47:45.810 --> 00:47:49.410
下载其他的存根

00:47:47.700 --> 00:47:54.240
在构建站点期间的合作者

00:47:49.410 --> 00:47:55.950
您有更快的反馈，就像

00:47:54.240 --> 00:47:59.610
我告诉你你必须提供

00:47:55.950 --> 00:48:01.320
离线工作默认为false 

00:47:59.610 --> 00:48:03.930
这是错误的，因此您可以将其删除

00:48:01.320 --> 00:48:07.230
当然，您必须提供

00:48:03.930 --> 00:48:09.690
您存储您的位置的网址

00:48:07.230 --> 00:48:12.360
 Nexus等产品或工厂

00:48:09.690 --> 00:48:14.520
这样你的测试就会失败

00:48:12.360 --> 00:48:18.900
一旦有任何破裂

00:48:14.520 --> 00:48:23.100
改变，这里我们要解决一个问题

00:48:18.900 --> 00:48:24.960
出现就像是经常出现的那样

00:48:23.100 --> 00:48:26.849
不只是克隆别人

00:48:24.960 --> 00:48:29.580
人们那里有项目

00:48:26.849 --> 00:48:31.800
出于安全原因的情况

00:48:29.580 --> 00:48:34.290
您无法克隆生产者代码，因此

00:48:31.800 --> 00:48:38.040
你能为他们做的唯一的事

00:48:34.290 --> 00:48:40.170
变化是合同不再

00:48:38.040 --> 00:48:42.330
他们与生产者，但他们在一个

00:48:40.170 --> 00:48:43.859
单独的仓库是一个普通的专家

00:48:42.330 --> 00:48:47.609
您将从中产生一个项目

00:48:43.859 --> 00:48:51.000
工作，以便消费者克隆回购和

00:48:47.609 --> 00:48:53.970
在本地玩一次

00:48:51.000 --> 00:48:56.550
人们对API感到满意

00:48:53.970 --> 00:48:58.770
您可以非常严格地定义结构

00:48:56.550 --> 00:49:00.630
当然要覆盖它，但是有一些

00:48:58.770 --> 00:49:03.300
允许您做事的约定

00:49:00.630 --> 00:49:04.470
非常快，请检查所有的狗我

00:49:03.300 --> 00:49:06.720
不想给你太多

00:49:04.470 --> 00:49:10.050
详细信息在这里，因为我只是向您展示

00:49:06.720 --> 00:49:13.200
概述，一旦消费者

00:49:10.050 --> 00:49:15.420
对公关很满意

00:49:13.200 --> 00:49:18.960
合同年利率是通过该回购完成的

00:49:15.420 --> 00:49:21.950
在那边，然后制作人让我们

00:49:18.960 --> 00:49:25.320
说接管公关，所以关闭回购

00:49:21.950 --> 00:49:31.730
对丢失的实现进行本地处理

00:49:25.320 --> 00:49:36.300
然后公关合并后

00:49:31.730 --> 00:49:38.670
在配置项期间，生产者正在重用

00:49:36.300 --> 00:49:40.619
来自此回购的合同具有

00:49:38.670 --> 00:49:43.950
所有共同合同

00:49:40.619 --> 00:49:45.869
再次用存根和绒毛震撼

00:49:43.950 --> 00:49:48.630
罐子上传到下一个授权

00:49:45.869 --> 00:49:52.070
工厂，所以唯一改变的地方

00:49:48.630 --> 00:49:54.570
是它使用或签约的地方

00:49:52.070 --> 00:49:56.460
所以当你

00:49:54.570 --> 00:50:01.410
例如由于安全

00:49:56.460 --> 00:50:03.570
原因，重要的是要记住

00:50:01.410 --> 00:50:06.089
这是合同的回购是

00:50:03.570 --> 00:50:09.270
也由您的CI构建，因此它会产生一个

00:50:06.089 --> 00:50:11.810
带有合同定义的罐子，然后

00:50:09.270 --> 00:50:14.640
生产者下载您可以使用的罐子

00:50:11.810 --> 00:50:17.220
在春季合同中配置Maven 

00:50:14.640 --> 00:50:19.650
插件并找到自己的合同

00:50:17.220 --> 00:50:22.580
定义很传统或你

00:50:19.650 --> 00:50:25.500
可以覆盖它，约定是

00:50:22.580 --> 00:50:28.890
有一个合同的文件夹

00:50:25.500 --> 00:50:31.859
生产者躺在一个文件夹中

00:50:28.890 --> 00:50:35.020
组ID工件ID分隔为

00:50:31.859 --> 00:50:36.880
闪烁制作人

00:50:35.020 --> 00:50:40.840
从那些创建测试和东西

00:50:36.880 --> 00:50:43.210
合同，所以我们再次验证

00:50:40.840 --> 00:50:46.450
合同是否有效

00:50:43.210 --> 00:50:48.010
生产者，所以没有什么变化

00:50:46.450 --> 00:50:51.130
这方面唯一改变的地方

00:50:48.010 --> 00:50:53.170
是合同订立的地方， 

00:50:51.130 --> 00:50:54.940
然后生产者部署胖罐， 

00:50:53.170 --> 00:50:57.370
自动生成的带有存根的jar 

00:50:54.940 --> 00:51:01.720
测试通过，您必须将其放入您的

00:50:57.370 --> 00:51:03.400
消费者使用的CI管道存根

00:51:01.720 --> 00:51:06.160
而不是从Nexus下载停靠站

00:51:03.400 --> 00:51:11.530
这与您完全一样

00:51:06.160 --> 00:51:13.570
在演示摘要中看到了，所以做了什么

00:51:11.530 --> 00:51:15.520
我们通过洒水合同来实现

00:51:13.570 --> 00:51:17.740
消费者驱动的合同，所以我们

00:51:15.520 --> 00:51:19.210
创建了适合消费者的API 

00:51:17.740 --> 00:51:22.120
双方的生产者都是

00:51:19.210 --> 00:51:24.280
幸福的期望是由

00:51:22.120 --> 00:51:27.550
可读合同，这意味着DBA 

00:51:24.280 --> 00:51:29.680
是可以读取那些文件和那些

00:51:27.550 --> 00:51:31.240
合同你也有那个描述

00:51:29.680 --> 00:51:34.630
可以在那里提供

00:51:31.240 --> 00:51:37.660
测试了任意文本期望

00:51:34.630 --> 00:51:39.670
对生产者不利，因此如果合同

00:51:37.660 --> 00:51:42.430
如果生产者在合同中

00:51:39.670 --> 00:51:45.310
还是不履行合同，它将

00:51:42.430 --> 00:51:47.050
没有建立自己，所以存根不会

00:51:45.310 --> 00:51:50.140
被上传，所以没有人能够

00:51:47.050 --> 00:51:52.240
重用它，你必须说出真相， 

00:51:50.140 --> 00:51:54.420
因为我们正在将存根上传到

00:51:52.240 --> 00:51:57.850
 Nexus或人工制品

00:51:54.420 --> 00:51:59.530
每个人都可以用来启动和

00:51:57.850 --> 00:52:02.470
设置存根是完全自动化的

00:51:59.530 --> 00:52:06.730
您可以看到就像您添加注释一样

00:52:02.470 --> 00:52:08.800
事情像自动发生一样，为什么

00:52:06.730 --> 00:52:11.680
你能撒合同验证者吗

00:52:08.800 --> 00:52:14.670
更大的项目验证者是

00:52:11.680 --> 00:52:17.080
插入存根运行器所有这一切是

00:52:14.670 --> 00:52:20.110
该项目下的规格

00:52:17.080 --> 00:52:22.480
合同证明您可以进行CDC 

00:52:20.110 --> 00:52:24.670
对称合同也带有消息传递

00:52:22.480 --> 00:52:27.400
不仅是HTTP请求，所以我们可以定义

00:52:24.670 --> 00:52:29.530
这样的输入消息可以来了

00:52:27.400 --> 00:52:31.750
这样的出去消息将被发送， 

00:52:29.530 --> 00:52:34.060
我们正在与生产者核对

00:52:31.750 --> 00:52:37.570
以及清晰易用

00:52:34.060 --> 00:52:39.040
静态类型的DSL并自动

00:52:37.570 --> 00:52:43.060
地理测试由此产生

00:52:39.040 --> 00:52:45.250
合同真的很重要

00:52:43.060 --> 00:52:47.470
赛跑者自动在以下位置下载存根

00:52:45.250 --> 00:52:49.180
运行时，所以您Tenuta必须考虑

00:52:47.470 --> 00:52:52.420
关于它发生在

00:52:49.180 --> 00:52:54.279
我们与洒水器集成在一起，因此，如果您

00:52:52.420 --> 00:52:56.349
有您正在使用的发现服务

00:52:54.279 --> 00:52:59.289
例如控制台，您将无法执行

00:52:56.349 --> 00:53:02.819
在内存控制台中，您可以使用洒

00:52:59.289 --> 00:53:05.259
合同存根而不是因为它将

00:53:02.819 --> 00:53:08.019
停止服务发现

00:53:05.259 --> 00:53:11.950
自动将其路由到

00:53:08.019 --> 00:53:13.150
适合您和我们的Wiremock实例

00:53:11.950 --> 00:53:14.859
与Cloud Foundry集成

00:53:13.150 --> 00:53:18.579
所以有一个叫存根的项目

00:53:14.859 --> 00:53:20.680
启动，以便您可以运行应用程序存根

00:53:18.579 --> 00:53:23.890
转轮启动告诉它下载某些

00:53:20.680 --> 00:53:26.609
存根，甚至可以告诉浏览器

00:53:23.890 --> 00:53:29.499
请在尤里卡注册或

00:53:26.609 --> 00:53:31.569
请评论一只真正的兔子并排队

00:53:29.499 --> 00:53:34.119
如果你想发送触发一些

00:53:31.569 --> 00:53:36.329
您可以查看合同中的消息

00:53:34.119 --> 00:53:38.680
洒管道项目在哪里

00:53:36.329 --> 00:53:42.489
在那里合并，您可以检查一下

00:53:38.680 --> 00:53:44.349
知道它是如何工作的，那是来自

00:53:42.489 --> 00:53:48.660
我的身边，这将是时候

00:53:44.349 --> 00:53:52.329
从你这边问的是的

00:53:48.660 --> 00:53:54.729
就像每当您有疑问时

00:53:52.329 --> 00:53:56.529
只是读狗，你可以签出

00:53:54.729 --> 00:54:00.009
样本，因为我们在撒

00:53:56.529 --> 00:54:02.739
合同特殊独立样品

00:54:00.009 --> 00:54:04.180
这是可以

00:54:02.739 --> 00:54:05.950
在我们使用皮肤时互相交谈

00:54:04.180 --> 00:54:07.960
护理合同，还有

00:54:05.950 --> 00:54:10.859
吸气剂渠道，我们将超越

00:54:07.960 --> 00:54:10.859
很高兴回答您的问题

00:54:15.509 --> 00:54:23.680
很棒，很好，谢谢，恩慈，恩

00:54:18.609 --> 00:54:29.979
嗯，还有很多问题

00:54:23.680 --> 00:54:34.930
哦，是的，所以实际上在那里

00:54:29.979 --> 00:54:36.999
是一大堆，所以我们嗯，不要

00:54:34.930 --> 00:54:48.999
在每个人身上花费太多时间

00:54:36.999 --> 00:54:49.300
一umm，请稍等片刻

00:54:48.999 --> 00:54:51.900
关于

00:54:49.300 --> 00:54:54.850
那个第一个问题来自

00:54:51.900 --> 00:54:57.580
 andreas我们的朋友andreas Evers来自

00:54:54.850 --> 00:54:59.230
奥尔迪娜对他说，如果我理解

00:54:57.580 --> 00:55:01.660
正确地，您使用生产者

00:54:59.230 --> 00:55:05.050
回购和Maven构建以安装

00:55:01.660 --> 00:55:06.940
签订了Maven回购协议

00:55:05.050 --> 00:55:09.190
与单独的契约经纪人一起做

00:55:06.940 --> 00:55:12.760
这是您可以使用的HTTP服务器

00:55:09.190 --> 00:55:14.740
发布合同并与之签订合同

00:55:12.760 --> 00:55:16.450
为了脱钩不是吗

00:55:14.740 --> 00:55:19.720
这种方法更有意义

00:55:16.450 --> 00:55:21.400
在您克隆Java repo运行Maven时

00:55:19.720 --> 00:55:23.380
消费者可以用JavaScript编写

00:55:21.400 --> 00:55:25.180
你知道，让我们假装你知道

00:55:23.380 --> 00:55:28.660
您可能不熟悉Java 

00:55:25.180 --> 00:55:31.300
 Maven或groovy是非常非常好的

00:55:28.660 --> 00:55:31.810
问题是的，这非常好

00:55:31.300 --> 00:55:35.410
感

00:55:31.810 --> 00:55:39.670
所以是的，我想这个问题被问到了

00:55:35.410 --> 00:55:42.340
在我展示这个中央仓库之前

00:55:39.670 --> 00:55:45.610
部分地回答了这一切都取决于我

00:55:42.340 --> 00:55:49.030
觉得很抱歉，您可以解释一下

00:55:45.610 --> 00:55:52.210
对，但只有一些超出它的答案

00:55:49.030 --> 00:55:55.710
只是要花一些钱，所以答案是

00:55:52.210 --> 00:56:00.190
这是我的偏爱

00:55:55.710 --> 00:56:02.680
合同订立时个人更喜欢

00:56:00.190 --> 00:56:05.260
与制作人一起，但就像我介绍的那样

00:56:02.680 --> 00:56:07.990
这并不总是可能的，所以这是

00:56:05.260 --> 00:56:10.060
第一件事是另一个像我

00:56:07.990 --> 00:56:14.440
个人喜欢经纪人的想法

00:56:10.060 --> 00:56:18.340
我喜欢这样，因为包

00:56:14.440 --> 00:56:20.680
让您可以说

00:56:18.340 --> 00:56:23.440
使用与消费者驱动的合同

00:56:20.680 --> 00:56:26.380
不同的语言，所以我们在这里

00:56:23.440 --> 00:56:28.540
是某种绑定到JVM，并且

00:56:26.380 --> 00:56:31.900
恰恰是从

00:56:28.540 --> 00:56:35.310
开始，因为这是

00:56:31.900 --> 00:56:38.590
碎片文化的保护伞项目

00:56:35.310 --> 00:56:42.100
我们正计划增加

00:56:38.590 --> 00:56:44.460
与我们计划达成的协议

00:56:42.100 --> 00:56:49.750
允许您使用定义合同

00:56:44.460 --> 00:56:53.110
契约文件，而且在我扭曲的头脑中，我

00:56:49.750 --> 00:56:57.610
有一个经纪人可以在哪里工作的想法

00:56:53.110 --> 00:57:01.540
与Sprint杯合同亲爱的灵魂

00:56:57.610 --> 00:57:02.289
也想回顾一下这是一个问题

00:57:01.540 --> 00:57:05.979
偏好

00:57:02.289 --> 00:57:09.029
现在，如果您有很多

00:57:05.979 --> 00:57:14.380
不同语言漫游

00:57:09.029 --> 00:57:17.829
公约将更有可能在

00:57:14.380 --> 00:57:20.499
更好的自动化方式

00:57:17.829 --> 00:57:22.719
用咒语达到类似的目的

00:57:20.499 --> 00:57:26.529
已经签约，因为您可以使用

00:57:22.719 --> 00:57:29.229
停止跑步者跑鞋的存根

00:57:26.529 --> 00:57:30.880
例如，如果您有用于

00:57:29.229 --> 00:57:33.640
示例nodejs中心，它是

00:57:30.880 --> 00:57:36.939
与Java应用通信

00:57:33.640 --> 00:57:39.099
实例，那么您可以运行存根

00:57:36.939 --> 00:57:41.140
跑步靴，并告诉它下载

00:57:39.099 --> 00:57:43.919
 node.js应用程序需要的存根和

00:57:41.140 --> 00:57:48.130
就是这样，您将再次拥有

00:57:43.919 --> 00:57:50.289
伪造的HTTP服务器运行并且node.js 

00:57:48.130 --> 00:57:52.630
应用将能够与之通信

00:57:50.289 --> 00:57:54.359
这些东西实际上就是

00:57:52.630 --> 00:57:57.400
发生在我以前的公司之一

00:57:54.359 --> 00:58:01.359
用户界面是用react和

00:57:57.400 --> 00:58:05.140
伙计们正在使用存根转轮

00:58:01.359 --> 00:58:07.569
可以这么说

00:58:05.140 --> 00:58:09.339
我问他们提出了

00:58:07.569 --> 00:58:15.189
他们将其纳入的管道

00:58:09.339 --> 00:58:17.829
他们的构建管道实际上谢谢你

00:58:15.189 --> 00:58:22.380
是的，嗯，这使得

00:58:17.829 --> 00:58:24.429
感觉，我认为我们的下一个问题是

00:58:22.380 --> 00:58:26.589
希望我觉得这很漂亮

00:58:24.429 --> 00:58:28.929
简短，我可以多层次吗

00:58:26.589 --> 00:58:33.989
定义为模拟合同

00:58:28.929 --> 00:58:36.849
集成测试从多个级别开始

00:58:33.989 --> 00:58:39.369
是的，我爱我不完全

00:58:36.849 --> 00:58:42.779
了解什么多层次合同

00:58:39.369 --> 00:58:47.559
意思是，但如果有人指的是

00:58:42.779 --> 00:58:49.959
有状态的情况

00:58:47.559 --> 00:58:53.199
例如场景，那么你可以

00:58:49.959 --> 00:58:56.140
有他们，我们确实支持方案，但我

00:58:53.199 --> 00:59:00.400
会阻止使用方案，因为

00:58:56.140 --> 00:59:04.269
我们不想复制我们的功能

00:59:00.400 --> 00:59:07.509
对，那是什么意思

00:59:04.269 --> 00:59:11.739
回到啤酒欺诈中

00:59:07.509 --> 00:59:14.859
检查大小写正确，所以如果我们说

00:59:11.739 --> 00:59:15.790
有500种不同的说法

00:59:14.859 --> 00:59:19.630
人

00:59:15.790 --> 00:59:22.150
 Jaromir是的Marcia怜悯抱歉，他是

00:59:19.630 --> 00:59:26.550
嗯，他正在澄清，他说如果我有

00:59:22.150 --> 00:59:26.550
一系列的多级服务称为

00:59:26.580 --> 00:59:33.490
并不是很多，所以让我们

00:59:30.610 --> 00:59:36.730
说一个人可以喜欢的系列

00:59:33.490 --> 00:59:39.850
解释多层次呼叫是什么

00:59:36.730 --> 00:59:43.000
我可以定义任何类型的请求， 

00:59:39.850 --> 00:59:45.370
真的就像您希望的那样

00:59:43.000 --> 00:59:47.770
我将他进一步澄清， 

00:59:45.370 --> 00:59:49.630
称服务为分类呼叫服务PT 

00:59:47.770 --> 00:59:53.350
我想这是电话服务费哦

00:59:49.630 --> 00:59:55.270
不不绝对不是绝对不是

00:59:53.350 --> 00:59:58.420
我的意思是，我们

00:59:55.270 --> 01:00:00.640
不想，所以我们想测试一下

00:59:58.420 --> 01:00:03.880
隔离，所以基本上如果你去

01:00:00.640 --> 01:00:06.880
喝完管道的项目

01:00:03.880 --> 01:00:12.160
我在那里明确写的文档

01:00:06.880 --> 01:00:16.330
就像让我们说的背后的想法

01:00:12.160 --> 01:00:19.420
这些存根，所以我们要

01:00:16.330 --> 01:00:21.580
因素反馈，所以我首先要

01:00:19.420 --> 01:00:24.670
孤立地测试我的应用程序

01:00:21.580 --> 01:00:27.070
所以我要打电话给BI 

01:00:24.670 --> 01:00:29.020
关心服务，我什至不知道

01:00:27.070 --> 01:00:35.320
它存在，我不在乎，因为

01:00:29.020 --> 01:00:38.560
 C对，所以我作为一个消费者

01:00:35.320 --> 01:00:41.650
该服务BI只会写

01:00:38.560 --> 01:00:44.770
我感兴趣的合同

01:00:41.650 --> 01:00:48.030
对，我不会这样使用

01:00:44.770 --> 01:00:51.730
完全我不知道模拟了

01:00:48.030 --> 01:00:54.850
像那些多层次情景的人

01:00:51.730 --> 01:00:57.250
当然你可以像

01:00:54.850 --> 01:00:58.990
呼叫CC呼叫行为

01:00:57.250 --> 01:01:02.380
完美的感觉对，因为你需要

01:00:58.990 --> 01:01:06.930
有些你需要那些合同，但是我

01:01:02.380 --> 01:01:10.840
无法想象还有更多

01:01:06.930 --> 01:01:14.830
像停止复杂的想法在这里也是

01:01:10.840 --> 01:01:17.590
如果你和我会鼓励

01:01:14.830 --> 01:01:22.180
大家检查接管

01:01:17.590 --> 01:01:25.540
如果你有很好的警报，那边

01:01:22.180 --> 01:01:26.800
好的指标，然后进行良好的KPI监控

01:01:25.540 --> 01:01:29.510
您实际上可以摆脱端到端的局面

01:01:26.800 --> 01:01:33.410
测试为什么，因为我们

01:01:29.510 --> 01:01:35.390
检查所有与合同，所以我们

01:01:33.410 --> 01:01:38.180
确保语义是可以的

01:01:35.390 --> 01:01:40.880
生产，你永远不会，你不应该

01:01:38.180 --> 01:01:42.830
有这样的问题

01:01:40.880 --> 01:01:45.290
请求是嘴形或类似

01:01:42.830 --> 01:01:47.660
那当然并不意味着

01:01:45.290 --> 01:01:50.330
功能正在运作，但如果您有

01:01:47.660 --> 01:01:53.180
非常快速的管道，您可以立即

01:01:50.330 --> 01:01:54.800
回滚到以前的版本吧

01:01:53.180 --> 01:01:58.490
这样也许可以回答问题

01:01:54.800 --> 01:02:00.859
在某种程度上是可以的

01:01:58.490 --> 01:02:03.080
做那些合同测试，你有

01:02:00.859 --> 01:02:04.700
快速的反馈，您可以更快

01:02:03.080 --> 01:02:07.460
生产并回滚到上一个

01:02:04.700 --> 01:02:09.560
您可以摆脱端到端版本的版本

01:02:07.460 --> 01:02:12.140
测试您可以在本地进行，例如

01:02:09.560 --> 01:02:15.020
确保我会以开发人员的身份来做，但是

01:02:12.140 --> 01:02:20.480
你可以在大范围内摆脱它们

01:02:15.020 --> 01:02:24.680
管道很好，谢谢，谢谢

01:02:20.480 --> 01:02:26.450
哎呀，让我们看看我正在努力保持

01:02:24.680 --> 01:02:29.720
与问题队列在一起，这里有狼

01:02:26.450 --> 01:02:32.300
卢卡进来的人问

01:02:29.720 --> 01:02:35.119
假设制作人是我的客户

01:02:32.300 --> 01:02:39.830
而且我没有克隆任何权利

01:02:35.119 --> 01:02:42.800
那Rico那我该如何管理它，所以我们

01:02:39.830 --> 01:02:46.609
可以像他们一样有一个通用的仓库

01:02:42.800 --> 01:02:50.150
介绍，所以我们可以喜欢，如果这是一个

01:02:46.609 --> 01:02:53.840
客户然后啊，就像我们有两个选择

01:02:50.150 --> 01:02:56.390
他们要么合作，我们创造一些

01:02:53.840 --> 01:02:59.060
他们在那里的私人github回购

01:02:56.390 --> 01:03:02.630
访问和双方都同意一些

01:02:59.060 --> 01:03:04.609
的东西，或者如果那不可能，我会

01:03:02.630 --> 01:03:09.050
要求他们提供测试环境

01:03:04.609 --> 01:03:10.490
像App III这样的测试可以

01:03:09.050 --> 01:03:14.869
写一些合同，但它们很漂亮

01:03:10.490 --> 01:03:18.050
如果我不知道我说的话没用

01:03:14.869 --> 01:03:22.520
像客户一样对他们进行锻炼

01:03:18.050 --> 01:03:24.830
就像我的意思是

01:03:22.520 --> 01:03:27.410
这个工具是我检查

01:03:24.830 --> 01:03:29.570
合同说的是实话

01:03:27.410 --> 01:03:30.950
消费者是我的客户，但他们不是

01:03:29.570 --> 01:03:33.800
想要合作，他们不使用

01:03:30.950 --> 01:03:36.440
工具，那么我们有一个问题，我

01:03:33.800 --> 01:03:39.380
我想我希望他们能

01:03:36.440 --> 01:03:43.069
给我一个他们拥有的环境

01:03:39.380 --> 01:03:44.390
我可以调用的某种测试应用

01:03:43.069 --> 01:03:48.229
真正的要求就是我要的

01:03:44.390 --> 01:03:49.880
个人认为这有意义

01:03:48.229 --> 01:03:51.799
对你来说真的很现实

01:03:49.880 --> 01:03:53.119
你知道，因为有时候这些

01:03:51.799 --> 01:03:54.769
您知道他们可能会使用的Web服务

01:03:53.119 --> 01:03:57.469
可能在四壁之外

01:03:54.769 --> 01:04:01.579
非常有意义的业务

01:03:57.469 --> 01:04:03.890
工具谢谢恩里克问你好我

01:04:01.579 --> 01:04:07.309
想知道您将如何运行

01:04:03.890 --> 01:04:11.390
当生产者本身时，生产者进行测试

01:04:07.309 --> 01:04:15.109
是其他服务的消费者，并且

01:04:11.390 --> 01:04:18.949
你不想有这种依赖

01:04:15.109 --> 01:04:24.410
作为测试的一部分，我没有全部

01:04:18.949 --> 01:04:27.979
是的，我的意思是，也许我会说

01:04:24.410 --> 01:04:32.869
再次，我作为制作人打电话

01:04:27.979 --> 01:04:35.630
有人吧，好吧，那是一个

01:04:32.869 --> 01:04:39.079
非常非常好的问题，让我走

01:04:35.630 --> 01:04:43.249
如果我不知道每个人都可以

01:04:39.079 --> 01:04:44.630
看到我喜欢的代码可能是

01:04:43.249 --> 01:04:49.999
表现出来并同时说话

01:04:44.630 --> 01:04:53.089
时间，基本上，如果你有一个

01:04:49.999 --> 01:04:55.459
生产者方面的控制器，所以我们

01:04:53.089 --> 01:04:57.799
有那些自动生成的测试

01:04:55.459 --> 01:05:01.180
打电话发送真实的请求，所以在这里

01:04:57.799 --> 01:05:04.910
为了演示，我做了一个

01:05:01.180 --> 01:05:10.069
简化地说

01:05:04.910 --> 01:05:12.559
至少在这里，我创建了I 

01:05:10.069 --> 01:05:15.579
顺便写了真正的实现

01:05:12.559 --> 01:05:18.680
彼得可以让所有人看到正确的屏幕

01:05:15.579 --> 01:05:20.839
是的，我一定会让你有信心

01:05:18.680 --> 01:05:24.289
只是不想打扰我

01:05:20.839 --> 01:05:26.660
没问题，所以我应该做的是

01:05:24.289 --> 01:05:31.009
应该做一个接口

01:05:26.660 --> 01:05:32.989
称为生产者收费服务，并带有

01:05:31.009 --> 01:05:34.369
诸如重生之类的方法

01:05:32.989 --> 01:05:37.549
当然不应该是这样

01:05:34.369 --> 01:05:42.499
就像我正在快速地做，所以检查

01:05:37.549 --> 01:05:46.099
如果合格的合格支票还可以，我

01:05:42.499 --> 01:05:48.529
不知道也许我拼错了

01:05:46.099 --> 01:05:51.380
我们有人在这里检查，所以

01:05:48.529 --> 01:05:53.630
应该发生的实际上是我们应该

01:05:51.380 --> 01:05:58.339
连线

01:05:53.630 --> 01:06:01.730
服务在这里生产者服务哦，我们愿意

01:05:58.339 --> 01:06:05.119
像这样我们会退还生产者

01:06:01.730 --> 01:06:08.269
服务检查是否还可以，我们对此进行了标记

01:06:05.119 --> 01:06:12.319
我们不运行真正逻辑的事情

01:06:08.269 --> 01:06:15.230
所以如果在下面我打电话给

01:06:12.319 --> 01:06:16.970
真正的东西我不想那样做

01:06:15.230 --> 01:06:18.950
因为我不想检查

01:06:16.970 --> 01:06:21.410
实现我只想检查

01:06:18.950 --> 01:06:27.559
语义，那么我该怎么做

01:06:21.410 --> 01:06:31.160
在这首诗中，您定义了玻璃杯

01:06:27.559 --> 01:06:33.319
用于测试可以是一个或您

01:06:31.160 --> 01:06:36.319
可以定义其中的一系列，或者有

01:06:33.319 --> 01:06:39.380
在基类内部的约定

01:06:36.319 --> 01:06:42.759
我在这里做的是

01:06:39.380 --> 01:06:46.369
独立设置用于放置控制器

01:06:42.759 --> 01:06:48.230
其实奥利弗认为我会杀了我

01:06:46.369 --> 01:06:52.880
这样做，让我做

01:06:48.230 --> 01:06:57.109
与构造函数正确地相处

01:06:52.880 --> 01:06:59.660
其实三个像这样

01:06:57.109 --> 01:07:02.289
现在在基类中，我需要

01:06:59.660 --> 01:07:05.960
生产者服务，所以我要做的是

01:07:02.289 --> 01:07:08.390
让我快做一个穷人的版本

01:07:05.960 --> 01:07:12.680
做一个生产者服务的生产者

01:07:08.390 --> 01:07:16.369
生产者的服务模拟

01:07:12.680 --> 01:07:19.430
服务，在这里我必须做所有

01:07:16.369 --> 01:07:20.410
吉风和风，然后例如

01:07:19.430 --> 01:07:24.980
模仿

01:07:20.410 --> 01:07:28.039
鉴于我没有VD D，所以当制作人时

01:07:24.980 --> 01:07:32.930
服务很冷我要去做一些

01:07:28.039 --> 01:07:39.019
伪代码在这里，这样一个人

01:07:32.930 --> 01:07:41.950
检查适当的年龄然后返回

01:07:39.019 --> 01:07:44.930
示例响应将是新响应

01:07:41.950 --> 01:07:50.420
啤酒检查状态还可以

01:07:44.930 --> 01:07:53.420
这项权利和不适当的年龄

01:07:50.420 --> 01:07:57.130
啤酒检查状态不好

01:07:53.420 --> 01:07:59.420
假设我会打电话给一些

01:07:57.130 --> 01:08:02.000
下面的数据库或类似的东西

01:07:59.420 --> 01:08:04.579
我不想做我不想

01:08:02.000 --> 01:08:06.589
与其他人融合是一个

01:08:04.579 --> 01:08:07.130
模拟应该在这里出现

01:08:06.589 --> 01:08:11.420
生产者

01:08:07.130 --> 01:08:13.430
所以就像直接在这里没有真实

01:08:11.420 --> 01:08:17.060
互动应该发生

01:08:13.430 --> 01:08:19.550
这是我个人的看法， 

01:08:17.060 --> 01:08:22.430
一些有效的理由，但我知道公司

01:08:19.550 --> 01:08:24.860
不这样做，他们使用

01:08:22.430 --> 01:08:27.980
签订一些端到端的合同

01:08:24.860 --> 01:08:30.530
测试，但是这些真的很具体

01:08:27.980 --> 01:08:33.410
我建议的情况是你

01:08:30.530 --> 01:08:36.710
不要在

01:08:33.410 --> 01:08:38.870
签订合同，您不进行真正的跟注

01:08:36.710 --> 01:08:46.220
在数据库或其他数据库的下面

01:08:38.870 --> 01:08:48.140
服务还可以，谢谢

01:08:46.220 --> 01:08:51.770
那是非常重要的

01:08:48.140 --> 01:08:54.350
澄清闪族的来源

01:08:51.770 --> 01:08:56.120
实施谢谢你好吧， 

01:08:54.350 --> 01:09:01.880
让我们看看我猜是从

01:08:56.120 --> 01:09:06.290
 Enrique让我们看一下Roy Roy的极限是n 

01:09:01.880 --> 01:09:08.500
我是罗伊·埃斯拉或劳拉

01:09:06.290 --> 01:09:11.420
从你的名字开始

01:09:08.500 --> 01:09:15.590
有时我整合的服务

01:09:11.420 --> 01:09:18.200
以其投放数据为例

01:09:15.590 --> 01:09:19.670
例如有时提供数据

01:09:18.200 --> 01:09:21.350
需要进行模拟测试

01:09:19.670 --> 01:09:23.600
生产者提供的不同数据集

01:09:21.350 --> 01:09:27.260
对于消费者的测试如何

01:09:23.600 --> 01:09:30.550
做到这一点，有时我需要

01:09:27.260 --> 01:09:34.010
拥有不同的数据集

01:09:30.550 --> 01:09:38.090
好的，但是我的意思是相同的网址

01:09:34.010 --> 01:09:41.060
对，所以基本上用DES我是假的

01:09:38.090 --> 01:09:42.560
是的，我想是的

01:09:41.060 --> 01:09:47.180
模拟，以便您可以拥有不同的

01:09:42.560 --> 01:09:51.050
赞助消费者的测试，所以

01:09:47.180 --> 01:09:53.300
假设您定义穷人就像我们走

01:09:51.050 --> 01:09:55.910
面对这种啤酒情况，我们可以说

01:09:53.300 --> 01:09:58.220
您出于某种原因，这很有意义

01:09:55.910 --> 01:10:00.620
为你，因为你知道更多

01:09:58.220 --> 01:10:03.380
合约越多，它就变成了

01:10:00.620 --> 01:10:05.020
最应该支持的负担

01:10:03.380 --> 01:10:09.110
好的

01:10:05.020 --> 01:10:12.670
对于生产者来说，它可能会变成

01:10:09.110 --> 01:10:16.220
问题，如果你有数十亿

01:10:12.670 --> 01:10:18.740
支持方案，因为您需要

01:10:16.220 --> 01:10:20.360
在下面创建那些模拟

01:10:18.740 --> 01:10:22.670
可以说

01:10:20.360 --> 01:10:26.449
感觉你可以创造四个不同

01:10:22.670 --> 01:10:28.880
假设有不同的要求返回

01:10:26.449 --> 01:10:31.940
不同的响应，所以我们在一处做了

01:10:28.880 --> 01:10:35.270
我以前的公司是我们

01:10:31.940 --> 01:10:36.889
这个例子创造了不同，因为我们有

01:10:35.270 --> 01:10:39.650
一个人可能是一个场景

01:10:36.889 --> 01:10:41.750
欺诈，而您可能会欺诈

01:10:39.650 --> 01:10:43.340
数量原因，假设我知道五个

01:10:41.750 --> 01:10:45.980
一百种不同的选择

01:10:43.340 --> 01:10:48.219
欺诈，所以我们选了五个最重要的

01:10:45.980 --> 01:10:51.110
例如我们将它们区分开

01:10:48.219 --> 01:10:54.830
按名称（例如，客户名称） 

01:10:51.110 --> 01:10:57.770
是我不知道会丢一个然后你

01:10:54.830 --> 01:11:00.290
返回具体阶段或类似的东西

01:10:57.770 --> 01:11:03.949
所以我的意思是这是测试数据

01:11:00.290 --> 01:11:05.869
对，那么在消费者方面，如果我们

01:11:03.949 --> 01:11:08.600
需要它，就像我们本可以选择其中一个

01:11:05.869 --> 01:11:11.000
这五个场景取决于

01:11:08.600 --> 01:11:14.540
您需要测试但要让我做的事情

01:11:11.000 --> 01:11:15.949
再强调一次，如果可以的话

01:11:14.540 --> 01:11:18.080
三百种不同的欺诈

01:11:15.949 --> 01:11:19.730
我不会假设的原因

01:11:18.080 --> 01:11:22.280
你将有免费狩猎合同我

01:11:19.730 --> 01:11:24.739
会假设你必须这样做

01:11:22.280 --> 01:11:26.239
是不是欺诈？为什么，如果你

01:11:24.739 --> 01:11:29.860
具有适当的洋葱层架构

01:11:26.239 --> 01:11:33.380
所以在消费者方面

01:11:29.860 --> 01:11:36.380
消费者测试就像

01:11:33.380 --> 01:11:40.070
一些微小的层，看看我们是否可以

01:11:36.380 --> 01:11:42.889
正确沟通真实的测试

01:11:40.070 --> 01:11:44.690
就好吧

01:11:42.889 --> 01:11:46.850
你可能因此而成为欺诈

01:11:44.690 --> 01:11:51.110
可以看到文件夹，因为我会

01:11:46.850 --> 01:11:55.880
像马克杯这样的模拟电话

01:11:51.110 --> 01:11:57.770
到制作人的原因，因为我

01:11:55.880 --> 01:12:01.070
可以得到更快的反馈，因为我会

01:11:57.770 --> 01:12:05.210
注意我将进行的真正的集成测试

01:12:01.070 --> 01:12:07.969
我不可以打电话，我可以做

01:12:05.210 --> 01:12:10.670
它很快，所以基本上你应该有一个

01:12:07.969 --> 01:12:13.190
很多类似的单元测试不是很多

01:12:10.670 --> 01:12:15.080
集成测试的一部分可以是

01:12:13.190 --> 01:12:19.489
得到合同测试的权利，我会

01:12:15.080 --> 01:12:22.429
真的用它们来检查我们是否可以

01:12:19.489 --> 01:12:30.249
说话正确，而不是检查

01:12:22.429 --> 01:12:33.070
功能正常工作很棒

01:12:30.249 --> 01:12:34.749
好吧，我们差不多要做的很漂亮

01:12:33.070 --> 01:12:40.780
好多的风景，我们到那里

01:12:34.749 --> 01:12:44.769
剩下几对了，好吧，让我们

01:12:40.780 --> 01:12:48.729
很好，我想你已经回答了

01:12:44.769 --> 01:12:50.469
这实际上我会看起来

01:12:48.729 --> 01:12:53.110
谁在提早一个问题

01:12:50.469 --> 01:12:54.280
您知道连锁合同的多层次

01:12:53.110 --> 01:12:55.960
问一个关于你的问题知道什么

01:12:54.280 --> 01:12:57.010
如果我是Java开发人员或

01:12:55.960 --> 01:12:59.440
消费者是他们两个不同

01:12:57.010 --> 01:13:01.119
 Java Script之类的语言

01:12:59.440 --> 01:13:05.920
使用这些对比，您就会知道测试

01:13:01.119 --> 01:13:08.110
用Spock写的，嗯，是的，很好

01:13:05.920 --> 01:13:11.050
所以也许我们只能进行一些解释

01:13:08.110 --> 01:13:14.130
我会只想快点给

01:13:11.050 --> 01:13:16.809
基本上这就是我穿的衣服

01:13:14.130 --> 01:13:19.449
不能相信JavaScript 

01:13:16.809 --> 01:13:21.729
开发人员将无法安装

01:13:19.449 --> 01:13:24.190
内森（Nathan），如果您有Linux电脑

01:13:21.729 --> 01:13:27.429
 sudo apt-get安装Nathan，然后您

01:13:24.190 --> 01:13:31.030
只需编写Maven全新安装-这个

01:13:27.429 --> 01:13:33.460
套件测试是正确的

01:13:31.030 --> 01:13:36.639
您将在本地安装存根的方式

01:13:33.460 --> 01:13:38.949
所以我真的不相信

01:13:36.639 --> 01:13:41.769
对于某些人来说可能是个问题

01:13:38.949 --> 01:13:43.949
有人可以运行npm install或

01:13:41.769 --> 01:13:48.610
那个人可以写的东西

01:13:43.949 --> 01:13:51.820
 Maven再次像Maven点一样干净

01:13:48.610 --> 01:13:54.159
安装跳过测试

01:13:51.820 --> 01:13:55.929
这很琐碎

01:13:54.159 --> 01:14:01.510
不敢相信这可能是一个问题

01:13:55.929 --> 01:14:05.139
对于一个足够公平的人，是的

01:14:01.510 --> 01:14:07.809
听起来很简单，嗯， 

01:14:05.139 --> 01:14:10.929
那我是开放Creo的Andrew Morgan 

01:14:07.809 --> 01:14:13.510
询问是因为您自动生成或推断

01:14:10.929 --> 01:14:17.889
通过与API交互来签订合同

01:14:13.510 --> 01:14:21.579
已经存在哦，那就是

01:14:17.889 --> 01:14:25.079
不错的一个，所以我们正在考虑这个

01:14:21.579 --> 01:14:27.670
但你可以拥有它不会是微不足道的

01:14:25.079 --> 01:14:30.880
为什么，因为例如当你

01:14:27.670 --> 01:14:32.530
使用spring数据，您知道API是

01:14:30.880 --> 01:14:35.199
自动创建，可以这么说

01:14:32.530 --> 01:14:37.690
控制器，所以不会那么容易

01:14:35.199 --> 01:14:41.320
实际上你不想停下来

01:14:37.690 --> 01:14:43.449
一切，所以你知道这就像

01:14:41.320 --> 01:14:44.979
有点问题，但

01:14:43.449 --> 01:14:48.400
您正在考虑这样做

01:14:44.979 --> 01:14:51.670
另一种方法是如何创建一个

01:14:48.400 --> 01:14:53.079
合同的控制者，那就是

01:14:51.670 --> 01:14:56.289
我们积压的东西，所以

01:14:53.079 --> 01:14:58.570
想象一下，但是消费者

01:14:56.289 --> 01:15:00.369
创建一个像全新的新API 

01:14:58.570 --> 01:15:02.709
在新的网址上像这样

01:15:00.369 --> 01:15:06.909
然后生产者接管

01:15:02.709 --> 01:15:09.610
公关喜欢自动做某事

01:15:06.909 --> 01:15:11.260
这个打印输出合同插件会

01:15:09.610 --> 01:15:13.420
生成匹配的控制器

01:15:11.260 --> 01:15:14.769
例如，带有虚假数据的合同

01:15:13.420 --> 01:15:16.449
您在其中提供的

01:15:14.769 --> 01:15:22.119
很棒的合同

01:15:16.449 --> 01:15:24.159
我们正在考虑这很酷

01:15:22.119 --> 01:15:30.809
哦，天哪，我简直不敢相信我们

01:15:24.159 --> 01:15:34.570
快结束了，嗯，嗯，嗯

01:15:30.809 --> 01:15:37.360
我要说他的名字错了，所以

01:15:34.570 --> 01:15:41.949
也许我不应该尝试，但这是

01:15:37.360 --> 01:15:45.159
就像迪斯尼的熊从树上问

01:15:41.949 --> 01:15:47.920
在生产方运行的测试确实

01:15:45.159 --> 01:15:50.979
合同测试实际上称为

01:15:47.920 --> 01:15:53.590
预期的终点，例如测试

01:15:50.979 --> 01:15:56.469
后端点将创建一个实体

01:15:53.590 --> 01:16:00.010
我现在每次都在生产者数据库中

01:15:56.469 --> 01:16:03.760
答案不对，嗯，是你的

01:16:00.010 --> 01:16:07.059
叫模拟是完全正确是的

01:16:03.760 --> 01:16:07.469
是的，好的，好的，我只是想成为

01:16:07.059 --> 01:16:11.229
当然

01:16:07.469 --> 01:16:14.409
恰恰是您所不愿的一切

01:16:11.229 --> 01:16:15.820
致电，因为您不会过去

01:16:14.409 --> 01:16:21.550
控制器，因为您正在与

01:16:15.820 --> 01:16:23.920
我只是在写一个模拟

01:16:21.550 --> 01:16:24.070
控制台论坛在这里挂好所有好

01:16:23.920 --> 01:16:27.999
对

01:16:24.070 --> 01:16:32.229
啊很好很好很好很好

01:16:27.999 --> 01:16:35.650
嗯嗯嗯好吧，你就是你，你就是

01:16:32.229 --> 01:16:38.650
嗯，我要去的公司名称是

01:16:35.650 --> 01:16:41.650
屠杀ask的发音

01:16:38.650 --> 01:16:44.369
在我们的示例中，我们只有一个消费者

01:16:41.650 --> 01:16:48.880
与客户合同和生产者

01:16:44.369 --> 01:16:51.130
与服务器合同呃，但我们可以

01:16:48.880 --> 01:16:53.860
生产者与

01:16:51.130 --> 01:16:54.760
同时有另一位制片人

01:16:53.860 --> 01:16:56.170
知道你是否要我再读一遍

01:16:54.760 --> 01:16:57.650
因为我有点困惑你

01:16:56.170 --> 01:17:00.250
请

01:16:57.650 --> 01:17:02.240
好吧好吧好吧

01:17:00.250 --> 01:17:03.980
基本上他是在说你知道吗

01:17:02.240 --> 01:17:06.770
我们知道我知道该单位的通知

01:17:03.980 --> 01:17:09.470
在我们的示例中，我们有一个

01:17:06.770 --> 01:17:11.960
签约安静的单一消费者

01:17:09.470 --> 01:17:14.750
和具有服务器合同的生产者

01:17:11.960 --> 01:17:16.910
对不起，我是说我有一个消费者

01:17:14.750 --> 01:17:19.250
客户会议权

01:17:16.910 --> 01:17:21.800
我是说他们说一个小时是医生

01:17:19.250 --> 01:17:22.130
好吧，那不是你的展览

01:17:21.800 --> 01:17:26.300
你的

01:17:22.130 --> 01:17:28.400
嗯，是什么例子

01:17:26.300 --> 01:17:30.020
举例说他有一个

01:17:28.400 --> 01:17:32.810
具有客户合同和

01:17:30.020 --> 01:17:35.960
生产者与服务器签订合同啊但是

01:17:32.810 --> 01:17:37.400
我们的生产者能有一个消费者吗

01:17:35.960 --> 01:17:41.030
与另一家生产商签订合同

01:17:37.400 --> 01:17:43.550
同时我不知道那是不是

01:17:41.030 --> 01:17:45.680
有点难以遵循，但我是说我

01:17:43.550 --> 01:17:47.150
说我不需要任何构成

01:17:45.680 --> 01:17:49.730
客户合同我会说这是一个

01:17:47.150 --> 01:17:50.150
期望正确，好吧，我想我明白了

01:17:49.730 --> 01:17:54.770
它

01:17:50.150 --> 01:17:59.810
所以基本上就是这样

01:17:54.770 --> 01:18:01.190
如果您是常见的仓库，例如

01:17:59.810 --> 01:18:04.190
您与所有

01:18:01.190 --> 01:18:06.860
合约你可以称之为合约

01:18:04.190 --> 01:18:09.770
期望为什么因为消费者

01:18:06.860 --> 01:18:12.890
放在下面的文件夹

01:18:09.770 --> 01:18:15.440
个人特定的制作人

01:18:12.890 --> 01:18:20.270
像制片人那样表现，所以说

01:18:15.440 --> 01:18:22.520
我们有一个组ID ABC和

01:18:20.270 --> 01:18:24.710
存档工件ID将是生产者

01:18:22.520 --> 01:18:26.840
对，然后我们有三个消费者

01:18:24.710 --> 01:18:29.180
那个生产者的共同点

01:18:26.840 --> 01:18:32.810
包含您所有合同的资料库

01:18:29.180 --> 01:18:35.360
会有一个文件夹a / b / c / producer 

01:18:32.810 --> 01:18:37.580
在此之下，我们将拥有三个文件夹

01:18:35.360 --> 01:18:40.730
消费者一消费者二和消费者

01:18:37.580 --> 01:18:44.720
免费，所以所有这些消费者都会

01:18:40.730 --> 01:18:46.700
对API寄予期望

01:18:44.720 --> 01:18:48.950
应该看起来像，但这将是一个

01:18:46.700 --> 01:18:54.500
没事，那么制片人会

01:18:48.950 --> 01:18:58.190
就像测试将针对

01:18:54.500 --> 01:19:01.130
他来自这个仓库，但你也可以

01:18:58.190 --> 01:19:03.950
让那个制作人有自己的风格

01:19:01.130 --> 01:19:06.890
在他身边签约，这样你就可以

01:19:03.950 --> 01:19:10.250
像两个阶段的评论这样说

01:19:06.890 --> 01:19:14.200
重复合同

01:19:10.250 --> 01:19:17.930
就像您需要更大的安全性，但我

01:19:14.200 --> 01:19:20.150
我是否觉得这太过分了

01:19:17.930 --> 01:19:22.730
所以你应该选择其中之一

01:19:20.150 --> 01:19:24.680
这些方法，我不知道我是否

01:19:22.730 --> 01:19:28.220
正确理解了这个问题，所以我

01:19:24.680 --> 01:19:30.290
闭嘴我不确定我是否做过

01:19:28.220 --> 01:19:32.150
说实话，因为他只是澄清了

01:19:30.290 --> 01:19:33.620
跟客户说我刚遇到你

01:19:32.150 --> 01:19:35.360
如此庞大的消费者案例

01:19:33.620 --> 01:19:36.590
我想也许这不是，这是一个

01:19:35.360 --> 01:19:38.960
你们可能想要的实例

01:19:36.590 --> 01:19:43.700
在这方面与Gator合作

01:19:38.960 --> 01:19:45.740
真的不是第一次尝试的最佳选择

01:19:43.700 --> 01:19:47.450
得到这个感觉就像一张图

01:19:45.740 --> 01:19:50.750
一个好主意，对此感到抱歉

01:19:47.450 --> 01:19:52.210
嗯，信不信由你，我想我们已经

01:19:50.750 --> 01:19:55.910
运行到问题队列的末尾

01:19:52.210 --> 01:19:57.860
乡亲，这是一个看的好时机

01:19:55.910 --> 01:20:03.230
您在24界面上，然后转到

01:19:57.860 --> 01:20:07.490
 “资源”标签，然后对不起， 

01:20:03.230 --> 01:20:09.310
然后有一些有一些链接

01:20:07.490 --> 01:20:13.070
那里有一些后续信息

01:20:09.310 --> 01:20:17.410
这样你就可以掌握

01:20:13.070 --> 01:20:20.000
很容易在很多事情上

01:20:17.410 --> 01:20:22.550
您知道有关

01:20:20.000 --> 01:20:24.640
发布，有一篇马丁的文章

01:20:22.550 --> 01:20:27.410
福勒以消费者为导向的合同

01:20:24.640 --> 01:20:29.780
有一个链接到github repo和一个

01:20:27.410 --> 01:20:33.560
一堆其他真的很好的东西很棒

01:20:29.780 --> 01:20:35.600
嗯，马辛，我没有机会

01:20:33.560 --> 01:20:37.580
查看此内容，但我认为

01:20:35.600 --> 01:20:38.600
这是一个伴侣，这是一个行家下载

01:20:37.580 --> 01:20:40.130
对，所以如果人们想得到他们的

01:20:38.600 --> 01:20:42.590
动手实际位，这只是一个

01:20:40.130 --> 01:20:47.000
插入一些坐标的问题

01:20:42.590 --> 01:20:49.370
 -也许在中央

01:20:47.000 --> 01:20:53.180
基本来说，你是在问

01:20:49.370 --> 01:20:56.540
图书馆是正确的所以更多

01:20:53.180 --> 01:20:58.250
复杂的权利，因为有一堆

01:20:56.540 --> 01:21:01.060
思念他们就像在移动碎片

01:20:58.250 --> 01:21:04.640
在那里，所以我建议去

01:21:01.060 --> 01:21:07.910
合同页面以签订合同

01:21:04.640 --> 01:21:11.540
页并查看介绍

01:21:07.910 --> 01:21:14.210
在主页上您可以看到

01:21:11.540 --> 01:21:18.050
所有需要的依赖

01:21:14.210 --> 01:21:20.750
制片人和凡妮莎的消费者我们

01:21:18.050 --> 01:21:24.290
为此做一步一步的指导，所以我

01:21:20.750 --> 01:21:26.600
只会进入项目页面

01:21:24.290 --> 01:21:30.650
从那里检查出来像什么

01:21:26.600 --> 01:21:32.030
到底需要什么好吧好吧

01:21:30.650 --> 01:21:33.620
所以这可能更多是一个实例

01:21:32.030 --> 01:21:35.030
让我们克隆回购而不是

01:21:33.620 --> 01:21:36.620
让我们插入一些Maven坐标

01:21:35.030 --> 01:21:39.920
好的，嗯

01:21:36.620 --> 01:21:44.570
很好，然后我认为

01:21:39.920 --> 01:21:46.670
就是这样，如果你是哦，是的，如果

01:21:44.570 --> 01:21:49.610
你很好奇下一个

01:21:46.670 --> 01:21:52.100
我们将要举行的网络研讨会，但要做的是

01:21:49.610 --> 01:21:55.280
我们正在继续我们的微观

01:21:52.100 --> 01:21:59.990
服务波束和分布式系统

01:21:55.280 --> 01:22:00.980
乔什（Josh）的计划

01:21:59.990 --> 01:22:02.990
尝试叉

01:22:00.980 --> 01:22:07.340
谁是背后的域名提交者

01:22:02.990 --> 01:22:09.050
轴突CQRS框架

01:22:07.340 --> 01:22:11.120
将于11月16日（星期三） 

01:22:09.050 --> 01:22:15.440
嗯，如果你想加入我们

01:22:11.120 --> 01:22:17.660
网络研讨会，您可以找到一个链接

01:22:15.440 --> 01:22:20.060
在“问题和答案”面板中

01:22:17.660 --> 01:22:23.540
在24界面上，或者您也可以

01:22:20.060 --> 01:22:26.840
启动IO / blog，您会看到

01:22:23.540 --> 01:22:28.790
帖子，您只需向下滚动即可

01:22:26.840 --> 01:22:29.930
然后您会看到有关网络研讨会的帖子

01:22:28.790 --> 01:22:31.610
在11月16日

01:22:29.930 --> 01:22:33.590
嗯，请随时加入我们

01:22:31.610 --> 01:22:38.000
然后邀请你的同事

01:22:33.590 --> 01:22:40.160
然后像我说的注册嗯

01:22:38.000 --> 01:22:41.660
注册或订阅博客或

01:22:40.160 --> 01:22:43.700
 YouTube频道，因此您可以

01:22:41.660 --> 01:22:45.800
重播的通知

01:22:43.700 --> 01:22:46.910
幻灯片可用，我是Marcin 

01:22:45.800 --> 01:22:50.570
有很多人只是同步

01:22:46.910 --> 01:22:52.370
谢谢你，我在想你

01:22:50.570 --> 01:22:55.790
知道提供给您一些很棒的东西

01:22:52.370 --> 01:22:57.380
工作反馈和一个人说呃

01:22:55.790 --> 01:23:00.770
听到你比说要好得多

01:22:57.380 --> 01:23:07.610
看你检查那些可爱的哦，是的，所以

01:23:00.770 --> 01:23:08.960
也许我必须完成我的写作，所以

01:23:07.610 --> 01:23:13.010
您想在我们面前说什么

01:23:08.960 --> 01:23:15.500
每天都这样吧，非常感谢

01:23:13.010 --> 01:23:18.290
我很高兴能有这个

01:23:15.500 --> 01:23:20.830
讨论这些对话，我真的

01:23:18.290 --> 01:23:23.720
很高兴听到您喜欢您的反馈

01:23:20.830 --> 01:23:26.270
因为只有您给我们反馈

01:23:23.720 --> 01:23:29.860
可以使我们的工具变得更好，我们可以

01:23:26.270 --> 01:23:32.720
他们为你，所以没有你们我的意思是

01:23:29.860 --> 01:23:36.050
我们的工作没有用，所以请提供

01:23:32.720 --> 01:23:37.460
反馈像洒的主题

01:23:36.050 --> 01:23:38.210
消费者被授予合同， 

01:23:37.460 --> 01:23:41.000
合同是

01:23:38.210 --> 01:23:43.340
这很旧，因为

01:23:41.000 --> 01:23:46.430
自从我走了十多年

01:23:43.340 --> 01:23:51.340
记住正确的自博客文章

01:23:46.430 --> 01:23:54.110
来自我，但这有点复杂

01:23:51.340 --> 01:23:56.390
你可以让学校成为消费者

01:23:54.110 --> 01:23:59.120
制片人，但希望我能做到

01:23:56.390 --> 01:24:01.790
至少要解释一下

01:23:59.120 --> 01:24:03.710
一些东西，并显示什么是

01:24:01.790 --> 01:24:07.250
好处是我们不说话

01:24:03.710 --> 01:24:08.540
大约与这三个零类似或

01:24:07.250 --> 01:24:11.540
像那样的东西

01:24:08.540 --> 01:24:12.469
完全不同，它正在解决

01:24:11.540 --> 01:24:14.500
实际问题

01:24:12.469 --> 01:24:16.670
所以希望能够证明

01:24:14.500 --> 01:24:19.300
对每个人都有一个伟大的感谢和看到

01:24:16.670 --> 01:24:22.300
在不利于您的天气中，您要小心

01:24:19.300 --> 01:24:22.300
谢谢

