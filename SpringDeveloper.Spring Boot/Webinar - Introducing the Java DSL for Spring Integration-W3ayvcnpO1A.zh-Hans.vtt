WEBVTT
Kind: captions
Language: zh-Hans

00:00:00.000 --> 00:00:03.929
早上好下午好晚上好

00:00:01.680 --> 00:00:05.790
每个人，如果你发现自己

00:00:03.929 --> 00:00:08.309
世界，我叫加里·罗素，我是

00:00:05.790 --> 00:00:11.280
当前的Spring 整合领导者

00:00:08.309 --> 00:00:13.080
今天我们要谈的是比尔

00:00:11.280 --> 00:00:14.639
这是对DSL的介绍，但是

00:00:13.080 --> 00:00:16.139
我实际上要花一点时间

00:00:14.639 --> 00:00:22.080
深入了解我们所拥有的

00:00:16.139 --> 00:00:25.439
以前只在这里公开了一些链接

00:00:22.080 --> 00:00:28.680
这些幻灯片将在以下位置共享

00:00:25.439 --> 00:00:32.070
彼得出版的结尾或结尾

00:00:28.680 --> 00:00:35.489
视频到博客主页

00:00:32.070 --> 00:00:40.590
该项目的新增功能和几个

00:00:35.489 --> 00:00:42.480
资源的实际一些样本

00:00:40.590 --> 00:00:46.559
 DSL，当然还有到

00:00:42.480 --> 00:00:48.660
 DSL本身，正如我提到的， 

00:00:46.559 --> 00:00:51.140
更深一点的潜水让我走吧

00:00:48.660 --> 00:00:54.870
返回并显示一点历史

00:00:51.140 --> 00:00:56.940
去年五月，我们举行了一个网络研讨会， 

00:00:54.870 --> 00:00:59.340
介绍了spring的集成哦

00:00:56.940 --> 00:01:01.260
发布其中已经发布了一些

00:00:59.340 --> 00:01:05.970
几个月前，也是最大的公司之一

00:01:01.260 --> 00:01:10.439
 Spring集成中的附加内容

00:01:05.970 --> 00:01:12.240
除了支持或使用

00:01:10.439 --> 00:01:14.070
 Spring 的消息模块很多

00:01:12.240 --> 00:01:16.110
春季的基础班

00:01:14.070 --> 00:01:18.299
消息传递，以便可以在

00:01:16.110 --> 00:01:21.689
另一个春季项目，例如春季

00:01:18.299 --> 00:01:24.299
具有Spring集成的WebSocket 

00:01:21.689 --> 00:01:27.479
我们添加了一些重要功能

00:01:24.299 --> 00:01:29.729
注释对

00:01:27.479 --> 00:01:32.990
能够做 Spring 的目标

00:01:29.729 --> 00:01:36.329
与Java和

00:01:32.990 --> 00:01:38.369
并开始消除

00:01:36.329 --> 00:01:40.530
对XML的需求

00:01:38.369 --> 00:01:42.810
仍然更喜欢使用XML，那仅仅是

00:01:40.530 --> 00:01:45.689
很好，但是还有其他一些人喜欢

00:01:42.810 --> 00:01:48.799
使用Java配置，因此在此

00:01:45.689 --> 00:01:51.000
我讨论了新的网络研讨会

00:01:48.799 --> 00:01:51.509
我们添加了注释支持

00:01:51.000 --> 00:01:57.600
前叉

00:01:51.509 --> 00:02:01.110
我先睹了

00:01:57.600 --> 00:02:05.399
我们正在做的Java DSL工作以及

00:02:01.110 --> 00:02:08.190
该网络研讨会的项目是

00:02:05.399 --> 00:02:12.450
在 Spring Integration 样品仓库中

00:02:08.190 --> 00:02:13.800
在DSL类别下，它是

00:02:12.450 --> 00:02:15.750
 Spring Integration 

00:02:13.800 --> 00:02:22.860
以及我们谈论的信息

00:02:15.750 --> 00:02:25.260
在那个特定的网络研讨会中，有两个

00:02:22.860 --> 00:02:27.270
两个版本后的注释版本

00:02:25.260 --> 00:02:29.130
我们看过的课和一个

00:02:27.270 --> 00:02:34.080
我说过的DSL版本就像

00:02:29.130 --> 00:02:36.690
潜入预览

00:02:34.080 --> 00:02:39.180
我们已经提前计划了

00:02:36.690 --> 00:02:42.360
是去年五月，然后在春季

00:02:39.180 --> 00:02:47.450
九月在德克萨斯州达拉斯市落下

00:02:42.360 --> 00:02:51.240
我们更深入地研究了

00:02:47.450 --> 00:02:54.240
 Spring整合配置使用

00:02:51.240 --> 00:02:56.610
当时的DSL 

00:02:54.240 --> 00:02:57.750
有一个里程碑发布以及

00:02:56.610 --> 00:03:02.030
 Spring 的里程碑式发布

00:02:57.750 --> 00:03:05.610
集成一个特定的

00:03:02.030 --> 00:03:09.780
项目建立在一个

00:03:05.610 --> 00:03:12.890
网络研讨会，我们实际上是在

00:03:09.780 --> 00:03:17.820
我们从那个特别的谈话

00:03:12.890 --> 00:03:20.970
 XML配置的应用程序并结束

00:03:17.820 --> 00:03:22.920
完全使用DSL 

00:03:20.970 --> 00:03:32.280
配置器配置在哪里

00:03:22.920 --> 00:03:34.050
此应用程序创建了一个，它发送了一个

00:03:32.280 --> 00:03:36.120
电子邮件，所以我们收到一条消息，我们结束了

00:03:34.050 --> 00:03:37.830
你知道在做一些标题

00:03:36.120 --> 00:03:40.170
里士满你可以在这里看到开始

00:03:37.830 --> 00:03:42.959
这里有些DSL风格

00:03:40.170 --> 00:03:44.790
我们正在丰富标题，然后发送

00:03:42.959 --> 00:03:49.110
对此邮件的消息我有一个

00:03:44.790 --> 00:03:52.680
适配器，并在下一个中类似

00:03:49.110 --> 00:03:54.840
在那个谈话的下一个例子中，我们

00:03:52.680 --> 00:03:57.450
最后收到了我们的邮件

00:03:54.840 --> 00:04:01.140
再次从空闲的IMAP中使用DSL 

00:03:57.450 --> 00:04:02.880
适配器，我们收到消息，您

00:04:01.140 --> 00:04:04.260
知道掏出一些标题和东西

00:04:02.880 --> 00:04:08.040
所以这只是

00:04:04.260 --> 00:04:10.140
我们在那两个领域所做的背景

00:04:08.040 --> 00:04:13.260
说话，如果你去 Spring 

00:04:10.140 --> 00:04:14.880
 I / O页面和博客页面并搜索

00:04:13.260 --> 00:04:16.350
对于这些，我们期待网络研讨会重播

00:04:14.880 --> 00:04:19.080
 Spring Integration ，你会发现你会

00:04:16.350 --> 00:04:23.100
找到这个，如果您进行搜索

00:04:19.080 --> 00:04:25.229
 Spring 1/2 GX重播，您会发现

00:04:23.100 --> 00:04:27.030
这个是那些值得的

00:04:25.229 --> 00:04:28.050
看看只是看一些

00:04:27.030 --> 00:04:30.870
的味道

00:04:28.050 --> 00:04:34.500
我们将要谈论的内容

00:04:30.870 --> 00:04:38.000
今天大约还有其他一些资源

00:04:34.500 --> 00:04:42.569
重要的是我们也在线上

00:04:38.000 --> 00:04:45.090
谁是谁的汽车

00:04:42.569 --> 00:04:47.190
主要贡献者，所以实际上您

00:04:45.090 --> 00:04:49.979
知道很多初始原型

00:04:47.190 --> 00:04:51.419
是他做的，他做了很多事情

00:04:49.979 --> 00:04:54.289
繁重的工作使这

00:04:51.419 --> 00:04:56.780
工作，所以我们需要大声喊叫

00:04:54.289 --> 00:05:03.659
他实际上出版了几本

00:04:56.780 --> 00:05:07.710
教程来展示DSL可以如何

00:05:03.659 --> 00:05:11.759
可以使用，如果我们看看

00:05:07.710 --> 00:05:15.000
在我们回到 Spring Integration 

00:05:11.759 --> 00:05:16.500
与曾经去过的任何人进行样本回购

00:05:15.000 --> 00:05:20.069
围绕 Spring Integration 很长一段时间

00:05:16.500 --> 00:05:23.210
最初的应用之一

00:05:20.069 --> 00:05:26.009
演示应用程序是这个咖啡馆

00:05:23.210 --> 00:05:27.930
应用在哪里我们的主意

00:05:26.009 --> 00:05:31.139
接到订单，然后分成

00:05:27.930 --> 00:05:34.340
订购物品或饮料，然后得到

00:05:31.139 --> 00:05:36.659
送去喝热饮料和冷饮料

00:05:34.340 --> 00:05:38.580
咖啡师实际准备饮料

00:05:36.659 --> 00:05:41.130
然后，他们聚合回到一个

00:05:38.580 --> 00:05:46.409
交货和退货，所以aartsen接受了

00:05:41.130 --> 00:05:49.440
那个咖啡馆示例应用程序，然后重写

00:05:46.409 --> 00:05:53.400
在DSL中，在咖啡厅DSL中

00:05:49.440 --> 00:05:57.389
 Spring Integration 项目

00:05:53.400 --> 00:05:59.729
现在收割的样品是他的工作

00:05:57.389 --> 00:06:01.110
接受，然后逐行进行

00:05:59.729 --> 00:06:03.090
行，我不会在这里通过它

00:06:01.110 --> 00:06:04.800
你可以随便带走

00:06:03.090 --> 00:06:06.479
知道看看休闲一件事

00:06:04.800 --> 00:06:09.090
您会注意到，这是一个相当

00:06:06.479 --> 00:06:10.860
复杂的流程，我们不一定

00:06:09.090 --> 00:06:12.120
回答某人指出的

00:06:10.860 --> 00:06:14.310
评论这不是我们想要的

00:06:12.120 --> 00:06:17.969
真的建议做一个非常复杂的

00:06:14.310 --> 00:06:20.539
使用DSL进行这样的流程

00:06:17.969 --> 00:06:23.310
倾向于将其拆分，这是此dis 

00:06:20.539 --> 00:06:28.069
这篇博客文章实际上只是为了

00:06:23.310 --> 00:06:28.069
说明如何使用DSL 

00:06:28.190 --> 00:06:33.990
您还注意到我们在

00:06:30.930 --> 00:06:36.360
你们很多人大量使用Java 

00:06:33.990 --> 00:06:37.030
一个lambda，这确实使DSL和

00:06:36.360 --> 00:06:41.860
更多

00:06:37.030 --> 00:06:43.600
易于看和理解，但

00:06:41.860 --> 00:06:45.790
显然有些人

00:06:43.600 --> 00:06:48.430
尚无法将工作转移到

00:06:45.790 --> 00:06:51.790
我个人认为Lambda 

00:06:48.430 --> 00:06:53.620
支持是一个令人信服的理由

00:06:51.790 --> 00:06:55.990
开始看工作八的运动

00:06:53.620 --> 00:06:57.310
但是为了容纳那些

00:06:55.990 --> 00:07:00.250
还没有准备好这样做

00:06:57.310 --> 00:07:05.800
而Artem做了第二版的

00:07:00.250 --> 00:07:07.810
使用Java六个Java 7的博客

00:07:05.800 --> 00:07:08.800
显示了如何使用Java 6使用流程

00:07:07.810 --> 00:07:10.750
乔娜七先生

00:07:08.800 --> 00:07:13.030
是的，我会讲一点

00:07:10.750 --> 00:07:20.140
当我们走进一些现场

00:07:13.030 --> 00:07:23.320
演示是的，所以那就是

00:07:20.140 --> 00:07:25.930
第二资源，以便通过事物

00:07:23.320 --> 00:07:29.740
这两个网络研讨会或网络研讨会以及

00:07:25.930 --> 00:07:37.510
春季一两GX对话和DSL 

00:07:29.740 --> 00:07:40.090
现在逐行讨论之一

00:07:37.510 --> 00:07:42.430
事情将变得相当明显

00:07:40.090 --> 00:07:45.669
当我们谈论更多

00:07:42.430 --> 00:07:50.200
今天是DSL目前还没有

00:07:45.669 --> 00:07:52.690
支持您所知道的每个适配器

00:07:50.200 --> 00:07:54.760
例如，MQTT是相当新的适配器

00:07:52.690 --> 00:07:57.040
在 Spring Integration 中，我们没有

00:07:54.760 --> 00:07:59.200
 DSL中的直接一流支持

00:07:57.040 --> 00:08:01.479
但是你会发现那不是真的

00:07:59.200 --> 00:08:05.350
入口，因为我们可以真正利用

00:08:01.479 --> 00:08:06.640
 DSL中的任何集成组件

00:08:05.350 --> 00:08:08.979
只是没有我们所说的

00:08:06.640 --> 00:08:11.530
一流的支持，我们将看到

00:08:08.979 --> 00:08:15.220
我的意思是那一点点时间

00:08:11.530 --> 00:08:18.250
今天进行，所以我们有支持

00:08:15.220 --> 00:08:23.410
对Rabbit MQP的一流支持

00:08:18.250 --> 00:08:26.710
事件文件FTP JDBC JMS邮件Mongo和

00:08:23.410 --> 00:08:29.650
如果您有任何SFTP 

00:08:26.710 --> 00:08:32.110
喜好哦，我真的需要一流的

00:08:29.650 --> 00:08:33.789
支持mqtt然后请

00:08:32.110 --> 00:08:36.370
通过以下方式提供反馈

00:08:33.789 --> 00:08:39.729
使用Spring 堆栈溢出

00:08:36.370 --> 00:08:41.589
集成标签，或者只是继续

00:08:39.729 --> 00:08:44.589
在JIRA中放点东西好

00:08:41.589 --> 00:08:46.959
如果我有X并且这会真的很酷

00:08:44.589 --> 00:08:49.300
几乎任何功能都是如此

00:08:46.959 --> 00:08:50.769
要求您拥有，让我们得到

00:08:49.300 --> 00:08:54.249
从一个非常简单的开始

00:08:50.769 --> 00:08:55.959
例如我只想为那些

00:08:54.249 --> 00:08:58.600
看过较早的演讲

00:08:55.959 --> 00:09:00.670
这将是人们的回顾

00:08:58.600 --> 00:09:02.980
希望这对DSL来说是新的

00:09:00.670 --> 00:09:08.049
会给你一点什么味道

00:09:02.980 --> 00:09:12.009
我们就是我们要看的东西，所以我

00:09:08.049 --> 00:09:14.319
从刚开始

00:09:12.009 --> 00:09:17.529
写一点J单元测试，在这个

00:09:14.319 --> 00:09:22.119
情况很明显，我们没有使用任何珍妮

00:09:17.529 --> 00:09:24.670
 XML我将使用

00:09:22.119 --> 00:09:26.829
配置类，为方便起见

00:09:24.670 --> 00:09:30.399
我将要声明该类为

00:09:26.829 --> 00:09:42.670
作为此内的静态类

00:09:30.399 --> 00:09:44.769
上下文，我们只要解决这个问题就可以了

00:09:42.670 --> 00:09:53.589
我们要做的第一件事是

00:09:44.769 --> 00:09:55.509
那些已知的单位我们会注释aa 

00:09:53.589 --> 00:09:57.519
 Java配置类

00:09:55.509 --> 00:09:59.889
告诉Spring的配置

00:09:57.519 --> 00:10:03.939
此类包含的框架

00:09:59.889 --> 00:10:05.769
 bean定义我们有一个新的

00:10:03.939 --> 00:10:11.069
在其中添加的注释

00:10:05.769 --> 00:10:11.069
Spring 集成称为启用

00:10:11.309 --> 00:10:17.019
现在集成现在做什么

00:10:14.709 --> 00:10:19.660
与传统的XML应用程序一样

00:10:17.019 --> 00:10:21.790
解析器检测到我们有一个

00:10:19.660 --> 00:10:26.589
我们的Spring 集成组件

00:10:21.790 --> 00:10:29.189
应用程序上下文解析器导致

00:10:26.589 --> 00:10:31.480
要使用的基础结构bean的数量

00:10:29.189 --> 00:10:33.339
在应用程序上下文中注册

00:10:31.480 --> 00:10:36.100
这包括任务

00:10:33.339 --> 00:10:38.529
执行标准任务执行器

00:10:36.100 --> 00:10:41.499
环的集成提供了

00:10:38.529 --> 00:10:43.240
标准错误通道，有一个

00:10:41.499 --> 00:10:45.910
我们有记录的pub子频道

00:10:43.240 --> 00:10:48.610
适配器订阅类似的东西

00:10:45.910 --> 00:10:50.739
一些基本的基础设施

00:10:48.610 --> 00:10:53.230
发布流程和各种各样的东西

00:10:50.739 --> 00:10:55.629
Spring 集成所需

00:10:53.230 --> 00:10:58.839
运行时去做它的工作

00:10:55.629 --> 00:11:01.540
所以启用启用集成是

00:10:58.839 --> 00:11:03.880
我们用来转向的机制

00:11:01.540 --> 00:11:07.639
该功能在

00:11:03.880 --> 00:11:11.029
亲爱的，那么DSL是什么

00:11:07.639 --> 00:11:15.519
 DSL的基本组成部分是

00:11:11.029 --> 00:11:18.399
现在的定义集成流程

00:11:15.519 --> 00:11:22.699
为了创建一个集成流程

00:11:18.399 --> 00:11:27.910
定义我们只是创建一个光束

00:11:22.699 --> 00:11:34.339
集成流程我将其称为流程

00:11:27.910 --> 00:11:36.290
所以我们现在需要在

00:11:34.339 --> 00:11:38.420
我们的流程定义有点像

00:11:36.290 --> 00:11:41.000
就像是巨型光束的定义

00:11:38.420 --> 00:11:43.970
实际上是整合的定义

00:11:41.000 --> 00:11:47.269
流动通道端点及其状况

00:11:43.970 --> 00:11:50.269
连在一起，就像一条光束，我们只是

00:11:47.269 --> 00:11:53.690
在建立流程定义时

00:11:50.269 --> 00:11:56.120
我们实际上实例化了应用程序

00:11:53.690 --> 00:11:57.769
从字面上看，当我们刷新它时

00:11:56.120 --> 00:12:03.320
光束后处理器发现

00:11:57.769 --> 00:12:05.600
整合流程定义以及意愿和

00:12:03.320 --> 00:12:07.550
基本上会经历

00:12:05.600 --> 00:12:09.140
定义注册所有端点

00:12:07.550 --> 00:12:11.480
将它们与通道连接在一起

00:12:09.140 --> 00:12:14.540
有适当的渠道，所以我

00:12:11.480 --> 00:12:16.310
将开始使用Java Java 

00:12:14.540 --> 00:12:19.730
 8个lambda，因为还多了一点

00:12:16.310 --> 00:12:22.730
性感，让我们看看我们从这里走到哪里

00:12:19.730 --> 00:12:24.170
所以我要返回一个流

00:12:22.730 --> 00:12:27.850
我定义为lambda 

00:12:24.170 --> 00:12:30.170
表达，我要给它一些

00:12:27.850 --> 00:12:33.920
在这种情况下要做的只是

00:12:30.170 --> 00:12:40.610
要转变，我们从开始

00:12:33.920 --> 00:12:44.380
大写字母的咒语表达

00:12:40.610 --> 00:12:47.750
我要做的就是

00:12:44.380 --> 00:12:50.569
将字符串有效负载转换为

00:12:47.750 --> 00:12:52.370
它的大写版本，然后我

00:12:50.569 --> 00:12:55.279
现在要实际发送它

00:12:52.370 --> 00:12:57.490
让您了解我的意思

00:12:55.279 --> 00:13:01.670
可以处理任何不是

00:12:57.490 --> 00:13:03.980
没有一流的支持

00:13:01.670 --> 00:13:10.639
这种情况下我要实际发送

00:13:03.980 --> 00:13:12.170
到一个日志消息处理程序，所以我

00:13:10.639 --> 00:13:14.529
将为该日志创建光束

00:13:12.170 --> 00:13:14.529
已经

00:13:23.520 --> 00:13:28.950
我只是要返回一个

00:13:30.180 --> 00:13:46.450
新的日志记录，我们将对其进行记录

00:13:37.330 --> 00:13:50.920
警告他们好吧，所以我们在那里

00:13:46.450 --> 00:13:52.750
第一个DSL，我们有一个流程

00:13:50.920 --> 00:13:55.720
从一个频道开始，并解释说

00:13:52.750 --> 00:13:59.440
一分钟后，我们将有效载荷转换

00:13:55.720 --> 00:14:01.240
大写，我们可以，我们可以

00:13:59.440 --> 00:14:03.760
在短短的时间内就会将该消息路由到

00:14:01.240 --> 00:14:07.620
记录员，我要做的第一件事是

00:14:03.760 --> 00:14:07.620
我要在通道中自动接线

00:14:16.500 --> 00:14:24.520
现在是技巧之一，因为我使用

00:14:21.970 --> 00:14:29.500
我需要在预选赛上放一个lambda 

00:14:24.520 --> 00:14:32.080
这里告诉框架什么

00:14:29.500 --> 00:14:34.510
频道名称为，约定为

00:14:32.080 --> 00:14:38.140
您使用的是Lambda星，流是

00:14:34.510 --> 00:14:42.400
通道获得流的名称

00:14:38.140 --> 00:14:45.490
流名称输入，所以在这里我们有流

00:14:42.400 --> 00:14:47.470
使用Lambda始于通道

00:14:45.490 --> 00:14:50.170
称为流程输入，它将编写它

00:14:47.470 --> 00:14:54.280
转换为大写字母

00:14:50.170 --> 00:14:56.490
将其插入，让我们让我们运行

00:14:54.280 --> 00:14:56.490
那

00:15:15.330 --> 00:15:21.589
而且它总是对我这样做

00:15:27.960 --> 00:15:30.770
天啊

00:15:44.270 --> 00:15:50.900
赫克非常喜欢我这样的消息

00:15:48.740 --> 00:15:53.210
只是确实经历了我不确定

00:15:50.900 --> 00:15:56.990
我的配置在这里发生了什么

00:15:53.210 --> 00:16:01.310
应该是我们应该得到一个

00:15:56.990 --> 00:16:09.140
如果我有时间的话，日志大小

00:16:01.310 --> 00:16:11.990
好吧，我回去想一想

00:16:09.140 --> 00:16:26.530
让我让我只是为了证明

00:16:11.990 --> 00:16:36.380
我是我不是我要去做

00:16:26.530 --> 00:16:38.090
这样，所以我在这里所做的是

00:16:36.380 --> 00:16:39.650
只是说而不是一条记录消息

00:16:38.090 --> 00:16:43.000
经理，我要去，我要去， 

00:16:39.650 --> 00:16:51.860
再做一次

00:16:43.000 --> 00:16:58.720
希望谢谢你奥尔顿

00:16:51.860 --> 00:16:58.720
我实际上并没有写测试

00:16:59.530 --> 00:17:09.670
好吧，是的，的确如此，我要去

00:17:05.270 --> 00:17:09.670
只是我要说一个新的

00:17:14.530 --> 00:17:21.800
中的频道的消息传递模板

00:17:18.580 --> 00:17:32.000
我要发送一个消息ID 

00:17:21.800 --> 00:17:34.210
转换，那里我们去那里

00:17:32.000 --> 00:17:34.210
写

00:17:53.530 --> 00:17:56.530
好的

00:18:10.330 --> 00:18:13.840
再一次

00:18:51.700 --> 00:18:53.730
哦

00:19:15.470 --> 00:19:29.570
我需要告诉他们我需要告诉

00:19:22.100 --> 00:19:31.970
当然，我们正在使用春季

00:19:29.570 --> 00:19:34.929
这次我们终于应该

00:19:31.970 --> 00:19:34.929
得到消息

00:19:46.210 --> 00:19:54.530
好吧，我们已经发送了一条消息给

00:19:52.700 --> 00:19:58.070
此通道此输入通道a 

00:19:54.530 --> 00:20:02.540
浮动输入并转换为w 

00:19:58.070 --> 00:20:05.690
并为出现的故障道歉

00:20:02.540 --> 00:20:09.410
在那里，现在事情可以是

00:20:05.690 --> 00:20:18.650
任何咒语表达，让我让我

00:20:09.410 --> 00:20:24.290
创建一个光束，我的变压器是

00:20:18.650 --> 00:20:28.430
只是一个POJO而我要返回

00:20:24.290 --> 00:20:35.080
一个新对象，我将添加一个

00:20:28.430 --> 00:20:35.080
方法公共字符串转换

00:20:40.920 --> 00:20:48.290
我将要返回加号

00:20:53.600 --> 00:21:02.340
好吧，我现在要串联

00:20:56.250 --> 00:21:07.620
它本身，所以现在这个

00:21:02.340 --> 00:21:10.140
咒语表达将是

00:21:07.620 --> 00:21:18.840
我们将要调用的是

00:21:10.140 --> 00:21:22.050
我的变压器叫这个标准

00:21:18.840 --> 00:21:27.020
拼写我的变压器我叫什么

00:21:22.050 --> 00:21:27.020
转换有效载荷

00:21:44.650 --> 00:21:49.730
再次，我们有我们的输出，所以我们

00:21:47.360 --> 00:21:51.770
现在所以现在我们已经改变了我们的咒语

00:21:49.730 --> 00:21:53.720
而不是仅仅使用一个

00:21:51.770 --> 00:22:01.400
简单的咒语表达，我们可以调用

00:21:53.720 --> 00:22:03.740
 POJO我们可以做的另一件事是

00:22:01.400 --> 00:22:06.110
可以代替使用咒语，我们可以

00:22:03.740 --> 00:22:08.720
现在使用lambda表达式以

00:22:06.110 --> 00:22:11.000
给编译器提供一些帮助

00:22:08.720 --> 00:22:14.900
告诉我们我们在做什么

00:22:11.000 --> 00:22:17.240
现在和现在之间使用

00:22:14.900 --> 00:22:22.400
 lambda表情我可以说好

00:22:17.240 --> 00:22:24.590
我将要转换的有效载荷

00:22:22.400 --> 00:22:29.660
只是要有一个参数P 

00:22:24.590 --> 00:22:31.550
大写，所以现在我们有一个lambda 

00:22:29.660 --> 00:22:34.570
完全相同的版本

00:22:31.550 --> 00:22:38.600
避免咒语以及我们要去的地方

00:22:34.570 --> 00:22:40.990
只是只是大写的情况下

00:22:38.600 --> 00:22:40.990
佩洛

00:22:53.650 --> 00:23:01.220
很好，很好，这是一个非常

00:22:57.890 --> 00:23:04.760
很简洁，但是正如我提到的

00:23:01.220 --> 00:23:08.420
在某些人之前

00:23:04.760 --> 00:23:11.560
还不能搬到八号工作

00:23:08.420 --> 00:23:16.250
让我们来看看

00:23:11.560 --> 00:23:19.310
再次使用Java布道，我所做的一切

00:23:16.250 --> 00:23:21.770
之前的咒语表达是

00:23:19.310 --> 00:23:23.930
 Java 7仍然可以通过Java完成

00:23:21.770 --> 00:23:26.810
但我们不能使用此lambda进行构建

00:23:23.930 --> 00:23:30.820
 Java 7的流程，所以我们有一个

00:23:26.810 --> 00:23:34.250
有一个工厂称为整合流程

00:23:30.820 --> 00:23:39.520
我们实际上从哪里说，然后

00:23:34.250 --> 00:23:42.110
我们给它一些频道名称， 

00:23:39.520 --> 00:23:44.510
这个整合流程

00:23:42.110 --> 00:23:48.170
工厂是核心组成部分之一

00:23:44.510 --> 00:23:50.240
我们稍后会看到

00:23:48.170 --> 00:23:51.710
来自渠道以外的东西

00:23:50.240 --> 00:23:54.320
如果我们想从消息开始

00:23:51.710 --> 00:23:56.690
轮询消息源等的来源

00:23:54.320 --> 00:23:58.400
将使用我们将使用此工厂，但

00:23:56.690 --> 00:24:01.820
现在，我将主要展示

00:23:58.400 --> 00:24:06.710
相同的相同的应用程序，没有

00:24:01.820 --> 00:24:08.270
使用lambdas，所以我只评论

00:24:06.710 --> 00:24:11.750
 lambda版本出来了，有一个

00:24:08.270 --> 00:24:14.870
我们可以做的几件事是

00:24:11.750 --> 00:24:17.630
只需使用一个匿名类

00:24:14.870 --> 00:24:24.320
就像lambda和

00:24:17.630 --> 00:24:30.040
我们有一个便利班

00:24:24.320 --> 00:24:38.800
通用转换，使我们能够

00:24:30.040 --> 00:24:38.800
定义一个变压器

00:24:51.180 --> 00:24:56.660
覆盖它们并

00:25:05.370 --> 00:25:11.790
我们需要，我们只需要

00:25:07.480 --> 00:25:11.790
在此处公开实施该方法

00:25:26.210 --> 00:25:31.139
变成大写，所以基本上

00:25:28.620 --> 00:25:32.940
做和我们做的一样的事情

00:25:31.139 --> 00:25:35.940
以前，但是我们使用匿名

00:25:32.940 --> 00:25:40.769
类来做到这一点在功能上

00:25:35.940 --> 00:25:42.809
与现在的lambda表达式相同

00:25:40.769 --> 00:25:44.759
当我们使用集成流程时

00:25:42.809 --> 00:25:46.889
我们没有lambda的好处

00:25:44.759 --> 00:25:49.740
所以我们只需要使用get方法

00:25:46.889 --> 00:25:52.559
这基本上是在结束之后

00:25:49.740 --> 00:25:54.779
我们已经完成了流程的构建

00:25:52.559 --> 00:25:56.399
得到那束光，我们读回这个

00:25:54.779 --> 00:25:58.379
 get方法rachet返回

00:25:56.399 --> 00:26:03.389
获得的集成流程类凭单

00:25:58.379 --> 00:26:07.590
返回给调用者的获取

00:26:03.389 --> 00:26:10.950
已注册，所以这是

00:26:07.590 --> 00:26:17.940
基本上完全一样，但是

00:26:10.950 --> 00:26:20.909
使用Java 7是Java 8 

00:26:17.940 --> 00:26:23.789
这样说，我接下来要去

00:26:20.909 --> 00:26:31.740
要做的只是看一看

00:26:23.789 --> 00:26:33.750
中的一些测试用例

00:26:31.740 --> 00:26:38.120
框架，以便我们可以看到一点

00:26:33.750 --> 00:26:43.440
有关DSL工作原理的更多信息

00:26:38.120 --> 00:26:46.009
所以我将从这个开始

00:26:43.440 --> 00:26:50.129
主要的集成流程测试

00:26:46.009 --> 00:26:56.370
的主要主要测试用例

00:26:50.129 --> 00:27:05.059
框架和我要做的事情之一

00:26:56.370 --> 00:27:07.860
我想展示的是一些基本的

00:27:05.059 --> 00:27:10.230
功能，所以我们有这个

00:27:07.860 --> 00:27:11.700
简单上下文配置之一

00:27:10.230 --> 00:27:13.289
问题之一公平出现

00:27:11.700 --> 00:27:15.210
经常好如何控制

00:27:13.289 --> 00:27:17.490
总线以编程方式意味着足够

00:27:15.210 --> 00:27:19.980
在XML中，我们只是尖括号控制

00:27:17.490 --> 00:27:22.580
巴士，我们有控制巴士， 

00:27:19.980 --> 00:27:25.200
与DSL一样简单，我们只是说

00:27:22.580 --> 00:27:27.600
我们使用整合流程

00:27:25.200 --> 00:27:31.049
表明我们从一个名为

00:27:27.600 --> 00:27:32.879
控制总线我们使用控制总线构建

00:27:31.049 --> 00:27:34.409
一种方法，然后得到它，所以我们没有

00:27:32.879 --> 00:27:37.619
现在我们有了控制总线

00:27:34.409 --> 00:27:39.710
发送消息到该频道以开始

00:27:37.619 --> 00:27:42.090
停下来

00:27:39.710 --> 00:27:44.280
适配器或您所做的任何事情

00:27:42.090 --> 00:27:48.660
您想要进行生物防治的任何东西

00:27:44.280 --> 00:27:55.559
这个特殊的测试显示了如何

00:27:48.660 --> 00:27:58.080
如何创建默认极坐标

00:27:55.559 --> 00:27:59.850
如果您记得的话，默认Polar是XML 

00:27:58.080 --> 00:28:01.710
说这通常是一张桌子

00:27:59.850 --> 00:28:06.210
是顶级商品，它是顶级商品

00:28:01.710 --> 00:28:08.040
光束所在的水平极

00:28:06.210 --> 00:28:10.460
指定为默认极性

00:28:08.040 --> 00:28:12.510
此极将用于任何轮询

00:28:10.460 --> 00:28:17.490
要求，例如轮询消息

00:28:12.510 --> 00:28:21.420
没有时的来源或轮询渠道

00:28:17.490 --> 00:28:24.510
提供了特定的极性，因此

00:28:21.420 --> 00:28:27.780
这个来这里基本上是在说这个

00:28:24.510 --> 00:28:30.450
这是我的默认极点

00:28:27.780 --> 00:28:36.809
这个固定汇率，你知道吗

00:28:30.450 --> 00:28:39.270
下一条消息表示下一条光束

00:28:36.809 --> 00:28:41.850
在这次测试中，她向您展示了

00:28:39.270 --> 00:28:44.309
覆盖默认任务计划程序I 

00:28:41.850 --> 00:28:48.540
提到启用

00:28:44.309 --> 00:28:51.450
集成批注的结果是

00:28:48.540 --> 00:28:52.920
整堆基础架构bean或

00:28:51.450 --> 00:28:56.040
定义了一堆基础架构

00:28:52.920 --> 00:28:59.340
 bean 好那些 bean 之一是

00:28:56.040 --> 00:29:02.130
一个任务计划程序，默认情况下它具有

00:28:59.340 --> 00:29:04.320
 10个线程，因此如果您需要覆盖

00:29:02.130 --> 00:29:07.770
那你可以简单地添加这个bean 

00:29:04.320 --> 00:29:09.270
与您的环境

00:29:07.770 --> 00:29:14.540
适当的名称，它将覆盖

00:29:09.270 --> 00:29:14.540
默认任务计划程序

00:29:15.260 --> 00:29:19.350
向下滚动一些，我们实际上可以

00:29:17.460 --> 00:29:24.600
开始看着一些流量

00:29:19.350 --> 00:29:27.720
现在，在这种情况下，我们将

00:29:24.600 --> 00:29:29.910
看一下过滤器，所以过滤方法

00:29:27.720 --> 00:29:32.460
关于集成流程的定义给出了

00:29:29.910 --> 00:29:34.679
我们能够将邮件过滤为

00:29:32.460 --> 00:29:37.440
与所有过滤器和秋千一样

00:29:34.679 --> 00:29:40.580
整合以及我们在这里看到的

00:29:37.440 --> 00:29:42.840
定义是实际的过滤器

00:29:40.580 --> 00:29:46.620
 lambda基本上是一样的

00:29:42.840 --> 00:29:49.590
我们将对有效载荷进行过滤

00:29:46.620 --> 00:29:53.070
是字符串，然后是第二个参数

00:29:49.590 --> 00:29:55.799
过滤方法是终点

00:29:53.070 --> 00:30:01.980
在这种情况下，我们已经定义了规范

00:29:55.799 --> 00:30:03.899
 ID过滤器，然后通常使用

00:30:01.980 --> 00:30:05.549
过滤器，我们只是向

00:30:03.899 --> 00:30:08.059
放弃频道，然后如果我们愿意

00:30:05.549 --> 00:30:11.220
 XML配置，我们将不得不

00:30:08.059 --> 00:30:14.190
有另一个消耗的流量

00:30:11.220 --> 00:30:16.049
从那个过滤器通道和/或那个

00:30:14.190 --> 00:30:18.630
放弃渠道，然后采取一些

00:30:16.049 --> 00:30:20.419
在此对丢弃的消息采取的措施

00:30:18.630 --> 00:30:24.419
情况下，我们实际上正在展示

00:30:20.419 --> 00:30:26.850
 DSL的相当不错的功能

00:30:24.419 --> 00:30:28.620
我们实际上可以有子流

00:30:26.850 --> 00:30:31.470
在流中，所以这是我们的

00:30:28.620 --> 00:30:34.470
集成流称为流向，但

00:30:31.470 --> 00:30:36.360
丢弃通常会丢弃，您可能只是

00:30:34.470 --> 00:30:38.159
想要记录或发送

00:30:36.360 --> 00:30:40.620
到兔子队列点东西

00:30:38.159 --> 00:30:43.879
基本的消息被丢弃

00:30:40.620 --> 00:30:46.919
所以不必写一个全新的

00:30:43.879 --> 00:30:50.940
悬挂丢弃通道的流量

00:30:46.919 --> 00:30:52.860
我们有这种丢弃流方法

00:30:50.940 --> 00:30:55.919
使我们能够实际编写另一个

00:30:52.860 --> 00:30:58.259
流是主流的子流

00:30:55.919 --> 00:30:59.820
如果我们真的去看看这个

00:30:58.259 --> 00:31:03.919
定义，您将看到

00:30:59.820 --> 00:31:03.919
论点是另一种整合流程

00:31:04.100 --> 00:31:08.399
再次，我们使用lambda，所以

00:31:06.509 --> 00:31:10.110
丢弃流，它可以有任何东西

00:31:08.399 --> 00:31:12.450
在这种情况下，我们要做的就是

00:31:10.110 --> 00:31:16.139
转换我们丢弃的消息

00:31:12.450 --> 00:31:17.490
向其中添加一些文本，然后发送

00:31:16.139 --> 00:31:19.049
它，然后我们仍将其发送到

00:31:17.490 --> 00:31:20.460
频道，在这种情况下，您知道

00:31:19.049 --> 00:31:22.860
你仍然会对此有所作为

00:31:20.460 --> 00:31:26.029
但您可以轻松处置它

00:31:22.860 --> 00:31:28.710
完全在此丢弃流程之内

00:31:26.029 --> 00:31:30.389
在过滤器等消息之后

00:31:28.710 --> 00:31:32.279
已通过，未通过的消息

00:31:30.389 --> 00:31:34.740
过滤器得到正确的这个

00:31:32.279 --> 00:31:37.049
子流消息牧师过滤器即

00:31:34.740 --> 00:31:40.710
那些是字符串的现在将下降

00:31:37.049 --> 00:31:43.379
向下流到其余部分

00:31:40.710 --> 00:31:46.080
在这种情况下，我们的定义是

00:31:43.379 --> 00:31:49.309
特别是说我们在命名

00:31:46.080 --> 00:31:52.500
渠道，这样我们就可以做

00:31:49.309 --> 00:31:53.700
例如添加全局拦截器，以便我们

00:31:52.500 --> 00:31:55.019
如果可以拦截此消息

00:31:53.700 --> 00:31:57.480
必要

00:31:55.019 --> 00:31:59.279
或者我们可以忽略这一点和框架

00:31:57.480 --> 00:32:01.919
只会使用内部频道

00:31:59.279 --> 00:32:04.649
将它们固定在一起

00:32:01.919 --> 00:32:05.850
用户频道是一种特殊的用例

00:32:04.649 --> 00:32:11.580
那是你

00:32:05.850 --> 00:32:16.830
是将端点紧密绑定在一起

00:32:11.580 --> 00:32:18.510
为了提高效率（如果需要），然后

00:32:16.830 --> 00:32:20.400
我们正在另一个转换中进行

00:32:18.510 --> 00:32:22.049
我们曾经如此，所以我们将一再屈服

00:32:20.400 --> 00:32:23.580
编译器提示我们转换为

00:32:22.049 --> 00:32:26.130
一个字符串到一个整数，我们就是

00:32:23.580 --> 00:32:31.350
使用功能参考这里

00:32:26.130 --> 00:32:32.789
在整数类上传递方法我们

00:32:31.350 --> 00:32:34.770
当您有另一个付款人时

00:32:32.789 --> 00:32:36.919
变压器这证明了

00:32:34.770 --> 00:32:39.780
我们可以添加的事实

00:32:36.919 --> 00:32:42.870
我们可以阅读的变压器对象

00:32:39.780 --> 00:32:44.460
在此和此声明一个

00:32:42.870 --> 00:32:47.010
如果我们实际上是在配置

00:32:44.460 --> 00:32:49.890
端点本身，例如作者的

00:32:47.010 --> 00:32:52.320
记录那些属性

00:32:49.890 --> 00:32:56.700
在端点而不是

00:32:52.320 --> 00:32:59.159
变压器另一个变压器等等

00:32:56.700 --> 00:33:03.480
这基本上使过滤器流动，然后

00:32:59.159 --> 00:33:06.169
几个变形金刚下

00:33:03.480 --> 00:33:10.020
我想向您展示的下一个流程是

00:33:06.169 --> 00:33:13.289
在其中发布/订阅频道流

00:33:10.020 --> 00:33:14.600
如果需要，通常在XML世界中

00:33:13.289 --> 00:33:17.220
向多个人发送消息

00:33:14.600 --> 00:33:18.390
您可以使用收件人的目的地

00:33:17.220 --> 00:33:21.650
列出路由器，或者您可以使用

00:33:18.390 --> 00:33:21.650
发布/订阅频道

00:33:21.960 --> 00:33:29.850
在这种情况下，它也再次显示了

00:33:25.860 --> 00:33:32.909
我们可以将子流订阅到发布

00:33:29.850 --> 00:33:35.370
订阅频道，让我们考虑

00:33:32.909 --> 00:33:37.470
相当典型的场景

00:33:35.370 --> 00:33:39.299
向出站通道发送消息

00:33:37.470 --> 00:33:40.710
适配器根据定义没有结果

00:33:39.299 --> 00:33:44.730
从那如果你想发送一个

00:33:40.710 --> 00:33:48.600
结果给您的来电者，让我们说一个

00:33:44.730 --> 00:33:51.799
默认情况下，发送邮件成功

00:33:48.600 --> 00:33:54.090
您发送邮件的方式发送得很好

00:33:51.799 --> 00:33:56.340
适配器正常工作是您在发送消息

00:33:54.090 --> 00:33:59.510
它的它已经消失了，它发送得很公平

00:33:56.340 --> 00:34:01.980
常见的模式是订阅第二个

00:33:59.510 --> 00:34:04.860
该发布/订阅的端点

00:34:01.980 --> 00:34:07.890
一旦

00:34:04.860 --> 00:34:10.290
邮件已成功发送，然后我们

00:34:07.890 --> 00:34:12.619
将返回的总和结果返回到

00:34:10.290 --> 00:34:15.570
第二个订户的呼叫者

00:34:12.619 --> 00:34:18.000
到发布/订阅频道，您

00:34:15.570 --> 00:34:19.860
最后可以用dsl作为

00:34:18.000 --> 00:34:23.070
好吧，不过我们有这个可以

00:34:19.860 --> 00:34:25.110
我们可以在哪里添加子流

00:34:23.070 --> 00:34:28.800
可以将子流订阅到

00:34:25.110 --> 00:34:32.129
发布/订阅频道，因此在此

00:34:28.800 --> 00:34:34.830
这个特殊的实例

00:34:32.129 --> 00:34:36.990
实例具有一个，它正在使用

00:34:34.830 --> 00:34:38.909
 pub子通道上的执行程序，所以这些

00:34:36.990 --> 00:34:42.360
这些订户将在中被调用

00:34:38.909 --> 00:34:45.030
并行，假设使用的是

00:34:42.360 --> 00:34:48.240
现金线程端口，以便这些子流

00:34:45.030 --> 00:34:50.520
将在不同的位置并行调用

00:34:48.240 --> 00:34:52.770
线程，然后第三个订阅者是

00:34:50.520 --> 00:34:55.169
主流本身，所以它只是另一个

00:34:52.770 --> 00:34:57.360
使用pub sub Cannell时的风味

00:34:55.169 --> 00:34:59.490
您可以像往常一样使用它们，并且

00:34:57.360 --> 00:35:02.010
只是将不同的流程附加到那些

00:34:59.490 --> 00:35:05.010
定义我们在哪里的渠道或

00:35:02.010 --> 00:35:16.430
您可以将它们定义为内部的子流

00:35:05.010 --> 00:35:16.430
定义本身中的

00:35:17.000 --> 00:35:24.810
好吧，现在我提到我提到了

00:35:22.530 --> 00:35:28.530
我们有一些一流的支持

00:35:24.810 --> 00:35:33.210
我们有一些适配器

00:35:28.530 --> 00:35:35.820
我没有一流的支持

00:35:33.210 --> 00:35:39.480
提到我们可以随时调用任何

00:35:35.820 --> 00:35:41.820
通过句柄的消息处理程序

00:35:39.480 --> 00:35:45.690
方法让我们快速浏览一下

00:35:41.820 --> 00:35:47.490
其中一项测试

00:35:45.690 --> 00:35:49.050
确实有其中一个模块

00:35:47.490 --> 00:35:53.250
有一流的支持，那就是

00:35:49.050 --> 00:35:57.300
邮件，所以我们有邮件

00:35:53.250 --> 00:36:05.730
基本上有这些工厂方法

00:35:57.300 --> 00:36:07.890
这将为我们和

00:36:05.730 --> 00:36:10.590
还有其他事情，例如这里

00:36:07.890 --> 00:36:13.170
有这个作为邮件工厂

00:36:10.590 --> 00:36:15.150
具有多个静态值的类

00:36:13.170 --> 00:36:19.500
在这种情况下，标头上的方法

00:36:15.150 --> 00:36:23.610
使我们能够作为头文件向前发展

00:36:19.500 --> 00:36:28.810
我们可以设置虐待狂的建设者，但是

00:36:23.610 --> 00:36:30.520
那一点

00:36:28.810 --> 00:36:33.430
试图处理一下，所以说

00:36:30.520 --> 00:36:37.900
我们想要处理一些

00:36:33.430 --> 00:36:39.250
像mqtt适配器这样的东西

00:36:37.900 --> 00:36:41.980
没有第一张卡，我们没有

00:36:39.250 --> 00:36:44.440
工厂创建MQTT的方法

00:36:41.980 --> 00:36:48.580
适配器，让我们看看如何

00:36:44.440 --> 00:37:00.780
做那件事我们可以做的就是我

00:36:48.580 --> 00:37:00.780
只是要创建一个MQTT梁公共

00:37:11.460 --> 00:37:21.990
我要去的MQTT零件消息句柄

00:37:14.020 --> 00:37:24.970
调用MQTT，我们可以返回一个新的

00:37:21.990 --> 00:37:27.100
消息处理程序，无论我们做什么

00:37:24.970 --> 00:37:28.690
配置它，以便任何东西

00:37:27.100 --> 00:37:32.140
虽然我们说我们没有

00:37:28.690 --> 00:37:35.230
一流的支持，您可以轻松接线

00:37:32.140 --> 00:37:37.000
那些适配器的光束

00:37:35.230 --> 00:37:41.650
我们没有一流的支持

00:37:37.000 --> 00:37:47.430
并通过中的handle方法调用它们

00:37:41.650 --> 00:37:47.430
邮件的情况，所以我们可以说

00:37:47.460 --> 00:37:53.050
我们可以用工厂法男

00:37:50.230 --> 00:37:57.430
有一个适配器，然后我们可以给它

00:37:53.050 --> 00:38:00.100
一个主机，所以区别在于

00:37:57.430 --> 00:38:02.710
一流的支持，您能得到这个

00:38:00.100 --> 00:38:05.890
构建此流利的Builder API进行构建

00:38:02.710 --> 00:38:11.950
端点或消息处理程序

00:38:05.890 --> 00:38:13.450
在这种情况下与那些模块

00:38:11.950 --> 00:38:15.790
我们还没有一流的

00:38:13.450 --> 00:38:19.240
支持你就可以创造光束

00:38:15.790 --> 00:38:21.520
作为常规的光束定义，然后

00:38:19.240 --> 00:38:25.300
在句柄中为其提供参考

00:38:21.520 --> 00:38:28.210
方法出现的另一个问题是

00:38:25.300 --> 00:38:37.380
好吧，如果我只有某种

00:38:28.210 --> 00:38:37.380
 POJO我只是称它为对象

00:38:39.750 --> 00:38:48.520
我有一些东西

00:38:43.300 --> 00:38:51.960
或我有一些课程我有一些

00:38:48.520 --> 00:38:51.960
一些讲台上的方法

00:38:56.170 --> 00:39:00.720
我将公开一条消息

00:39:22.740 --> 00:39:28.740
而且我们有

00:39:26.580 --> 00:39:32.820
鹿细胞的处理方法

00:39:28.740 --> 00:39:35.270
现在使我们能够调用该偷猎者

00:39:32.820 --> 00:39:37.920
我们给它起梁的名称， 

00:39:35.270 --> 00:39:41.610
然后我们想要的方法名称

00:39:37.920 --> 00:39:44.400
调用，就像用

00:39:41.610 --> 00:39:46.890
 XML配置，我们可以

00:39:44.400 --> 00:39:49.170
服务激活器等

00:39:46.890 --> 00:39:53.550
简单的马球偷猎者，那么我们有

00:39:49.170 --> 00:39:56.270
通过相同的能力

00:39:53.550 --> 00:39:56.270
处理方法

00:39:57.890 --> 00:40:05.340
好吧，那又是针对情况

00:40:03.210 --> 00:40:11.119
我们不知道你在哪里

00:40:05.340 --> 00:40:14.520
就像我们想展示的Paro一样，或

00:40:11.119 --> 00:40:16.530
我们可以邀请任何人加入

00:40:14.520 --> 00:40:18.720
消息处理程序实际上您知道这是

00:40:16.530 --> 00:40:21.180
 POJO，您也可以实现自己的POJO 

00:40:18.720 --> 00:40:24.300
消息处理程序，这不一定是

00:40:21.180 --> 00:40:28.080
消息处理程序接口的一部分

00:40:24.300 --> 00:40:36.440
我们需要返回，我们可以注入

00:40:28.080 --> 00:40:36.440
进入任何handle方法

00:40:36.710 --> 00:40:43.410
所以AMQP所以兔子再次支持我们

00:40:41.520 --> 00:40:48.270
拥有webson的一流支持

00:40:43.410 --> 00:40:55.350
兔子，如果我去的话，我们有这个

00:40:48.270 --> 00:41:01.380
实际去看看

00:40:55.350 --> 00:41:03.060
 AMQP工厂如此再次数

00:41:01.380 --> 00:41:05.430
在同一QP上的工厂方法

00:41:03.060 --> 00:41:06.930
工厂和爆炸网关，只是

00:41:05.430 --> 00:41:09.570
您可以看到内部

00:41:06.930 --> 00:41:11.940
关于你得到的是我们有

00:41:09.570 --> 00:41:14.490
这些规范类以及这些

00:41:11.940 --> 00:41:18.630
像无效的网关规范是我们的构建者

00:41:14.490 --> 00:41:21.270
我们的流利的api用于构建

00:41:18.630 --> 00:41:26.810
建立一个n QP网关，所以如果我们看

00:41:21.270 --> 00:41:30.000
在测试测试配置中

00:41:26.810 --> 00:41:33.720
我们只是使用这种工厂方法

00:41:30.000 --> 00:41:36.670
在班加的AMQP工厂级

00:41:33.720 --> 00:41:38.650
一个我们给它

00:41:36.670 --> 00:41:40.990
它引用了连接工厂， 

00:41:38.650 --> 00:41:44.309
将要监听的队列

00:41:40.990 --> 00:41:46.720
当然，只是转变，然后

00:41:44.309 --> 00:41:49.690
改变它，所以它是一个见证

00:41:46.720 --> 00:41:52.119
特定测试将退回

00:41:49.690 --> 00:41:57.760
你好，将其连接到输入并

00:41:52.119 --> 00:42:00.250
然后大写然后类似地在

00:41:57.760 --> 00:42:03.280
我们将从这里开始

00:42:00.250 --> 00:42:05.049
在这种情况下，我们使用名称QP 

00:42:03.280 --> 00:42:09.910
后通道是另一个工厂

00:42:05.049 --> 00:42:12.690
 NQ p工厂的方法以及那些

00:42:09.910 --> 00:42:15.099
您知道名为QP的JMS具有

00:42:12.690 --> 00:42:17.380
持续性频道，所以如果您有一个

00:42:15.099 --> 00:42:19.809
您需要的芯片中流通道

00:42:17.380 --> 00:42:22.720
这样就可以保持独特的持久性

00:42:19.809 --> 00:42:25.690
用兔子或JMS来坚持

00:42:22.720 --> 00:42:29.049
在这种情况下， 

00:42:25.690 --> 00:42:32.710
该流是名称QP的下游

00:42:29.049 --> 00:42:35.710
返回频道季度通话，称为n QP 

00:42:32.710 --> 00:42:37.750
输入，然后再次将其传递给

00:42:35.710 --> 00:42:39.970
处理程序，然后这个工厂再次

00:42:37.750 --> 00:42:43.270
我们的频段适配器工厂方法正在发展

00:42:39.970 --> 00:42:48.700
使用流利的API来建立我们

00:42:43.270 --> 00:42:51.450
为我们建立乐队

00:42:48.700 --> 00:42:51.450
并发送消息

00:42:54.480 --> 00:43:00.490
同样，我们显示了另一个

00:42:58.450 --> 00:43:02.859
来自我们早期的风味

00:43:00.490 --> 00:43:06.099
是从渠道开始的

00:43:02.859 --> 00:43:08.430
在这种情况下，我们从

00:43:06.099 --> 00:43:10.750
消息产生者，所以这就像一个

00:43:08.430 --> 00:43:15.160
消息驱动的入站通道适配器

00:43:10.750 --> 00:43:17.309
这将要创建消息

00:43:15.160 --> 00:43:20.410
并将它们发送到此变压器

00:43:17.309 --> 00:43:22.329
所以我建议如果这个测试

00:43:20.410 --> 00:43:24.700
是开始的好地方

00:43:22.329 --> 00:43:28.770
我们已经拥有的资源

00:43:24.700 --> 00:43:34.619
讨论了以前的网络研讨会

00:43:28.770 --> 00:43:37.809
那个秋天的两个教程

00:43:34.619 --> 00:43:39.369
这些测试案例是很好的例子， 

00:43:37.809 --> 00:43:44.040
当然参考指南本身

00:43:39.369 --> 00:43:46.690
会给你很好的感觉

00:43:44.040 --> 00:43:49.069
如何使用

00:43:46.690 --> 00:43:52.730
 DSL 

00:43:49.069 --> 00:43:55.609
我只想结束

00:43:52.730 --> 00:44:01.210
说或至少完成

00:43:55.609 --> 00:44:04.700
在我们去问答环节之前， 

00:44:01.210 --> 00:44:06.470
如何找到我们喜欢的任何东西

00:44:04.700 --> 00:44:08.839
无论如何，我们正在寻找有关

00:44:06.470 --> 00:44:12.710
你知道接下来你需要什么

00:44:08.839 --> 00:44:14.359
一流的支持，我们有这些

00:44:12.710 --> 00:44:15.980
已经我们需要知道我们需要

00:44:14.359 --> 00:44:18.829
一些排序的东西

00:44:15.980 --> 00:44:21.680
什么时候做其余的适配器

00:44:18.829 --> 00:44:24.710
您可以通过以下方式与我们联系

00:44:21.680 --> 00:44:27.500
Spring 集成标签，当然

00:44:24.710 --> 00:44:30.789
 JIRA有任何新东西

00:44:27.500 --> 00:44:34.760
功能建议你们有

00:44:30.789 --> 00:44:42.760
这样我就交给彼得

00:44:34.760 --> 00:44:42.760
负责问答环节，嘿，加里

00:44:43.230 --> 00:44:47.550
下一个问题来自Marco和

00:44:46.260 --> 00:44:50.850
他很好奇是什么样的支持

00:44:47.550 --> 00:44:57.120
提供给LDAP，而您知道LDAP 

00:44:50.850 --> 00:44:58.980
我一般都知道服务器

00:44:57.120 --> 00:45:00.300
你通常知道我的经历

00:44:58.980 --> 00:45:01.890
人们问有关LDAP的更多信息

00:45:00.300 --> 00:45:06.300
对其进行身份验证感到好奇

00:45:01.890 --> 00:45:08.370
储存在正确的位置，这样我会很喜欢你

00:45:06.300 --> 00:45:09.660
知道马可，如果你能听见我，我会

00:45:08.370 --> 00:45:12.900
来看看 Spring 的LDAP 

00:45:09.660 --> 00:45:14.220
项目，如果那是你的角度，但如果

00:45:12.900 --> 00:45:17.160
你真的在想

00:45:14.220 --> 00:45:18.990
作为Spring 集成连接到它

00:45:17.160 --> 00:45:20.730
你直接从 Spring 知道

00:45:18.990 --> 00:45:24.180
集成，因为您需要数据

00:45:20.730 --> 00:45:25.680
那里实际上是 Spring 

00:45:24.180 --> 00:45:28.740
这样做确实做得不错

00:45:25.680 --> 00:45:30.270
也是，但Stumm我不知道Gary是

00:45:28.740 --> 00:45:32.250
你们有一个频道

00:45:30.270 --> 00:45:34.530
我无法想象的适配器

00:45:32.250 --> 00:45:36.720
好的，等待，不，我们现在不

00:45:34.530 --> 00:45:38.310
它实际上已经出现在您的位置之前

00:45:36.720 --> 00:45:40.110
我可以知道吗？ 

00:45:38.310 --> 00:45:43.470
可能想做某种事情

00:45:40.110 --> 00:45:45.600
查找，然后我又没有

00:45:43.470 --> 00:45:47.460
达到障碍或门槛

00:45:45.600 --> 00:45:49.950
哦，我们真的需要写一个

00:45:47.460 --> 00:45:54.110
特定的适配器来做到这一点，但作为

00:45:49.950 --> 00:45:56.550
阴茎的 Spring LDAP是一个伟大的

00:45:54.110 --> 00:45:58.020
 ARP API之上的抽象，因此您

00:45:56.550 --> 00:46:01.860
不需要深入杂草

00:45:58.020 --> 00:46:04.140
是的，这很容易

00:46:01.860 --> 00:46:06.270
编写自己的POJO来调用

00:46:04.140 --> 00:46:09.180
 Spring 的LDAP，然后您调用

00:46:06.270 --> 00:46:12.900
来自Spring 集成服务的POJO 

00:46:09.180 --> 00:46:16.050
和服务激活器，所以在

00:46:12.900 --> 00:46:21.000
您将使用的DSL上下文

00:46:16.050 --> 00:46:26.940
这样处理方法来回答

00:46:21.000 --> 00:46:28.980
让我让我回去好吗

00:46:26.940 --> 00:46:31.380
因为无论我怎样

00:46:28.980 --> 00:46:35.550
记得 Spring 的LDAP是

00:46:31.380 --> 00:46:36.780
它实际上有一些设施，不是

00:46:35.550 --> 00:46:38.190
关于它的身份验证

00:46:36.780 --> 00:46:40.230
有一些设施，实际上是

00:46:38.190 --> 00:46:42.960
遍历和对对对

00:46:40.230 --> 00:46:45.780
通常在实际数据和

00:46:42.960 --> 00:46:47.430
所有这一切可能就是你很清楚

00:46:45.780 --> 00:46:50.130
是的，你变成纳德拉了

00:46:47.430 --> 00:46:52.740
攻击适配器实际上是对的

00:46:50.130 --> 00:46:55.410
但是是的，所以你可以做类似的事情

00:46:52.740 --> 00:46:56.549
您可以查询LDAP您可以查询

00:46:55.410 --> 00:46:59.339
您可以的目录树

00:46:56.549 --> 00:47:01.619
在LDAP中搜索对象

00:46:59.339 --> 00:47:06.299
然后通过spring LDAP进行操作

00:47:01.619 --> 00:47:09.559
只是因为你知道我会这样做

00:47:06.299 --> 00:47:14.309
你知道你可以写一个POJO 

00:47:09.559 --> 00:47:17.519
包裹了LDAP的 Spring 

00:47:14.309 --> 00:47:19.079
代码，然后您就可以做到

00:47:17.519 --> 00:47:20.819
根据您基于的消息

00:47:19.079 --> 00:47:23.819
您可以执行的邮件属性

00:47:20.819 --> 00:47:25.619
那些查找和搜索等等

00:47:23.819 --> 00:47:27.390
我使用的任何技术都是如此

00:47:25.619 --> 00:47:29.459
意味着有时候人们问了这个

00:47:27.390 --> 00:47:31.920
好吧，您知道JDBC医生

00:47:29.459 --> 00:47:34.529
不完全按照我的意愿去做

00:47:31.920 --> 00:47:36.630
就出站适配器而言

00:47:34.529 --> 00:47:39.630
在那种情况下，只写自己的写

00:47:36.630 --> 00:47:41.579
您自己的JDBC包装器

00:47:39.630 --> 00:47:44.579
模板完全可以执行您想要的操作

00:47:41.579 --> 00:47:46.979
做然后调用那个钢琴

00:47:44.579 --> 00:47:49.199
来自作为一个服务激活者

00:47:46.979 --> 00:47:51.599
注释或外部视角或

00:47:49.199 --> 00:47:56.429
通过一个获取这种处理方法

00:47:51.599 --> 00:47:58.529
 DSL磨损处理方法中的

00:47:56.429 --> 00:48:00.900
任何消息处理程序，以便您可以

00:47:58.529 --> 00:48:02.849
做你想做的几乎所有事情

00:48:00.900 --> 00:48:04.019
Spring 整合流程

00:48:02.849 --> 00:48:07.469
写一点胶水代码

00:48:04.019 --> 00:48:09.329
在集成API和

00:48:07.469 --> 00:48:12.329
您要与之交互的组件

00:48:09.329 --> 00:48:14.309
是否有某种特殊能力

00:48:12.329 --> 00:48:18.349
我们不介绍的JDBC模板

00:48:14.309 --> 00:48:18.349
或像 Spring 长者

00:48:18.450 --> 00:48:26.029
是的，非常酷，谢谢你的加里

00:48:22.349 --> 00:48:30.750
是的，让我们接下来的问题是

00:48:26.029 --> 00:48:33.869
米奇柔软的灯芯，两只眼睛凉爽

00:48:30.750 --> 00:48:37.250
嗯，他的问题是呃，我该怎么办

00:48:33.869 --> 00:48:42.359
我想使用非头等舱的情况

00:48:37.250 --> 00:48:45.269
组件正确，所以我想我想我

00:48:42.359 --> 00:48:48.089
覆盖，就像我的屏幕一样

00:48:45.269 --> 00:48:51.990
仍然脱落是的，好像是的， 

00:48:48.089 --> 00:48:53.970
搜索很好，因此在这种情况下，MQTT 

00:48:51.990 --> 00:48:57.299
我们不，我们没有封闭式课程

00:48:53.970 --> 00:49:03.720
支持mqtt对，所以我实际上

00:48:57.299 --> 00:49:05.700
我想从

00:49:03.720 --> 00:49:09.269
 MQTT适配器很好，我没有，我不能

00:49:05.700 --> 00:49:10.710
说你知道我们是否有一流的

00:49:09.269 --> 00:49:15.690
支持，那么我们会喜欢

00:49:10.710 --> 00:49:18.839
此MQTT点入站，然后您知道

00:49:15.690 --> 00:49:21.119
为此一些配置

00:49:18.839 --> 00:49:24.029
我们实际上可以流畅地使用DSL 

00:49:21.119 --> 00:49:25.769
用于构建和mqtt适配器的API 

00:49:24.029 --> 00:49:28.079
我们不，我们今天没有

00:49:25.769 --> 00:49:32.099
还没有，所以方式

00:49:28.079 --> 00:49:34.619
我们这样做就是我们只是创建

00:49:32.099 --> 00:49:40.589
阿鲁姆QTT适配器在这里，所以我们可以

00:49:34.619 --> 00:49:43.980
只是只是建立我们的建立我们的

00:49:40.589 --> 00:49:47.700
适配器在这里，我们需要一些我们需要的

00:49:43.980 --> 00:49:50.150
我记得有一些特性

00:49:47.700 --> 00:49:50.150
正确地

00:49:53.260 --> 00:49:57.910
就像我们需要您知道我们需要一个URL 

00:49:56.020 --> 00:50:02.440
您的客户ID之类的东西，所以我们

00:49:57.910 --> 00:50:10.000
将只建立我们只建立

00:50:02.440 --> 00:50:20.650
适配器，这是URL和客户端

00:50:10.000 --> 00:50:22.540
 ID等，因此我们只需构建即可

00:50:20.650 --> 00:50:27.130
否则我们需要做配置

00:50:22.540 --> 00:50:28.960
那么我们将只返回适配器

00:50:27.130 --> 00:50:31.300
我们知道我们没有一流的

00:50:28.960 --> 00:50:35.619
在构建器API方面的支持

00:50:31.300 --> 00:50:39.220
 mqtt适配器，非常容易

00:50:35.619 --> 00:50:42.160
直接调用此消息处理程序

00:50:39.220 --> 00:50:43.810
从流所以在这种情况下

00:50:42.160 --> 00:50:46.090
我们实际上是在接收乐队，我说我们

00:50:43.810 --> 00:50:49.300
想做某事，假设我们要

00:50:46.090 --> 00:50:53.710
从mqtt接收，然后进行转换

00:50:49.300 --> 00:50:57.280
无论转换是什么

00:50:53.710 --> 00:51:02.440
然后我们要发送给一些

00:50:57.280 --> 00:51:03.910
其他mqt让我只要进入我们

00:51:02.440 --> 00:51:06.910
就算我们要发送给

00:51:03.910 --> 00:51:11.530
另一个到出站MQTT适配器，然后

00:51:06.910 --> 00:51:15.130
我们将建立一个我们甚至可以做到的

00:51:11.530 --> 00:51:18.130
在这里mq TC我有一个消息处理程序

00:51:15.130 --> 00:51:21.430
你知道只是建立

00:51:18.130 --> 00:51:23.280
适配器就在其中

00:51:21.430 --> 00:51:27.190
工作

00:51:23.280 --> 00:51:29.050
所以我不想我不想结束

00:51:27.190 --> 00:51:31.090
强调我的意思是

00:51:29.050 --> 00:51:32.800
一流的支持才是我们真正的目标

00:51:31.090 --> 00:51:35.380
谈论的实际上是

00:51:32.800 --> 00:51:37.600
流畅的API用于构建这些

00:51:35.380 --> 00:51:40.630
您可以随时构建的组件

00:51:37.600 --> 00:51:44.710
使用传统Java的组件

00:51:40.630 --> 00:51:49.270
很棒的配置Gary如此谢谢

00:51:44.710 --> 00:51:51.160
好吧，让我看看我

00:51:49.270 --> 00:51:54.970
认为我们只是最后一个问题

00:51:51.160 --> 00:51:57.010
来自埃里克·罗德里格斯（Eric Rodriguez） 

00:51:54.970 --> 00:51:58.630
乡亲，你知道你是否有

00:51:57.010 --> 00:51:59.200
现在是时候提问了，所以请

00:51:58.630 --> 00:52:02.680
不要害羞

00:51:59.200 --> 00:52:04.810
嗯，埃里克（Eric）问他不确定这是否是

00:52:02.680 --> 00:52:06.030
确实是一个有效的用例，但是在那里

00:52:04.810 --> 00:52:07.580
其他任何 Spring 

00:52:06.030 --> 00:52:12.030
可以与

00:52:07.580 --> 00:52:14.790
Spring 集成以提供CQRS 

00:52:12.030 --> 00:52:19.800
事件采购像轴突

00:52:14.790 --> 00:52:21.210
框架我不是特别的我不是

00:52:19.800 --> 00:52:24.180
熟悉那个细节

00:52:21.210 --> 00:52:27.390
构架自己，但是的，我是说我

00:52:24.180 --> 00:52:29.970
几乎任何集成

00:52:27.390 --> 00:52:32.130
有能力知道你可以很容易地

00:52:29.970 --> 00:52:34.470
整合到整合中

00:52:32.130 --> 00:52:38.190
框架我想做的一件事

00:52:34.470 --> 00:52:39.600
提到我未能做到的

00:52:38.190 --> 00:52:44.780
使用Spring 集成

00:52:39.600 --> 00:52:50.390
在XD春季之内

00:52:44.780 --> 00:52:50.390
 Spring XD回到

00:52:51.640 --> 00:53:04.520
对不起，所以我加里受伤了

00:53:02.270 --> 00:53:05.900
看过这个缩写词，但没有伤害我

00:53:04.520 --> 00:53:08.570
不知道到底是什么意思

00:53:05.900 --> 00:53:10.490
显然，CQRS代表一个共同点

00:53:08.570 --> 00:53:12.950
命令酷儿请问命令和

00:53:10.490 --> 00:53:16.400
查询责任隔离我不

00:53:12.950 --> 00:53:18.230
知道是否有帮助，但是是的

00:53:16.400 --> 00:53:21.350
我们有点

00:53:18.230 --> 00:53:23.120
您知道频道之前适应过的方框

00:53:21.350 --> 00:53:27.890
是的，你是说你知道我们一样

00:53:23.120 --> 00:53:29.930
刚看对就很容易做到

00:53:27.890 --> 00:53:32.570
典型的是什么

00:53:29.930 --> 00:53:35.720
这些事情的进展是否存在

00:53:32.570 --> 00:53:37.700
如果有的话

00:53:35.720 --> 00:53:39.530
需求然后我们通常

00:53:37.700 --> 00:53:41.720
将其正确地放入核心

00:53:39.530 --> 00:53:43.760
框架，现在我们收到了很多请求

00:53:41.720 --> 00:53:46.400
对于像mqtt一样的东西

00:53:43.760 --> 00:53:48.170
相当普遍，然后

00:53:46.400 --> 00:53:49.910
但是有一点，所以我们从

00:53:48.170 --> 00:53:51.470
扩展和人们可以

00:53:49.910 --> 00:53:53.510
贡献扩展，然后

00:53:51.470 --> 00:53:58.220
最终他们被提升为

00:53:53.510 --> 00:54:00.920
我只想触摸的核心项目

00:53:58.220 --> 00:54:03.650
在这方面，他们做了 Spring 

00:54:00.920 --> 00:54:05.110
 XD一个即将面世， 

00:54:03.650 --> 00:54:12.440
他们所做的其中一件事情

00:54:05.110 --> 00:54:16.040
一是Java的支持

00:54:12.440 --> 00:54:19.730
 DSL Java Java DSL模块在此

00:54:16.040 --> 00:54:22.670
特殊情况很简单

00:54:19.730 --> 00:54:25.550
简单的变压器模块，但是它们

00:54:22.670 --> 00:54:28.280
您现在无法构建XML，而您可以构建

00:54:25.550 --> 00:54:30.590
直接通过DSL弹出XD模块

00:54:28.280 --> 00:54:33.440
只是看那个例子，如果

00:54:30.590 --> 00:54:35.590
你去春季XD样品，你会看到

00:54:33.440 --> 00:54:40.700
落在达勒姆身上

00:54:35.590 --> 00:54:42.650
在这个小岛屿发展中国家的模块下

00:54:40.700 --> 00:54:44.210
我认为这太好了，这是小姐

00:54:42.650 --> 00:54:46.460
你把这个例子提起来的孩子

00:54:44.210 --> 00:54:49.370
因为你知道埃里克的问题是

00:54:46.460 --> 00:54:50.990
关于一种事件源，我不是

00:54:49.370 --> 00:54:52.730
从框架上列出的支持

00:54:50.990 --> 00:54:55.730
只是因为他说事件来源

00:54:52.730 --> 00:54:57.680
对我来说，你知道这听起来像

00:54:55.730 --> 00:55:00.620
听起来可能有点像

00:54:57.680 --> 00:55:04.090
下沉或您知道流媒体或其他内容

00:55:00.620 --> 00:55:06.130
这样，Exedy是Spring XD的一种

00:55:04.090 --> 00:55:08.320
它代表了一种快速

00:55:06.130 --> 00:55:11.080
甚至以上的应用程序开发

00:55:08.320 --> 00:55:13.690
在 Spring Integration 的基础上， 

00:55:11.080 --> 00:55:16.240
特别是在很多情况下

00:55:13.690 --> 00:55:18.820
处理流处理，您

00:55:16.240 --> 00:55:20.800
知道处理高吞吐量事件

00:55:18.820 --> 00:55:23.050
所以即使你不知道

00:55:20.800 --> 00:55:24.280
没有螺栓，因为

00:55:23.050 --> 00:55:26.260
他的问题是嘿，我不确定

00:55:24.280 --> 00:55:28.660
是有效的用例权利，我是

00:55:26.260 --> 00:55:31.120
想着也许他意味着我

00:55:28.660 --> 00:55:32.860
不应该在某种事情上发生

00:55:31.120 --> 00:55:35.470
知道高速事件框架

00:55:32.860 --> 00:55:37.420
Spring 整合，你知道MAME 

00:55:35.470 --> 00:55:39.280
可能是无效的用例

00:55:37.420 --> 00:55:39.520
但是Spring XD显然是可以做到的

00:55:39.280 --> 00:55:43.090
那

00:55:39.520 --> 00:55:45.190
而且您知道直接建立在Spring 上

00:55:43.090 --> 00:55:47.950
集成权，所以我认为这是一个

00:55:45.190 --> 00:55:51.550
有效的用例，我认为jxt提供了

00:55:47.950 --> 00:55:53.410
挂钩的额外价值

00:55:51.550 --> 00:55:57.250
进入溪流或戳入

00:55:53.410 --> 00:55:58.840
高吞吐量异步类型框架

00:55:57.250 --> 00:56:00.400
我将快速浏览轴突

00:55:58.840 --> 00:56:01.780
我们正在谈论框架Walter 

00:56:00.400 --> 00:56:05.110
因为我只是一种

00:56:01.780 --> 00:56:08.680
现在很好奇

00:56:05.110 --> 00:56:10.420
 XD，而我们正在针对这些主题

00:56:08.680 --> 00:56:12.280
还没有看过它，我是说真的

00:56:10.420 --> 00:56:15.400
确实基于spring集成，但它

00:56:12.280 --> 00:56:21.240
确实带来了一些重大价值

00:56:15.400 --> 00:56:23.950
即使您知道非数据也可以添加

00:56:21.240 --> 00:56:28.120
使用spring的密集型应用程序

00:56:23.950 --> 00:56:33.330
集成，例如spring spring XD 

00:56:28.120 --> 00:56:36.580
具有故障转移的能力，并且

00:56:33.330 --> 00:56:39.940
它管理着你的 Spring 的实例

00:56:36.580 --> 00:56:42.810
整合流程，例如

00:56:39.940 --> 00:56:46.420
说我们有一个FTP适配器

00:56:42.810 --> 00:56:48.430
轮询共享资源（例如NFS） 

00:56:46.420 --> 00:56:49.930
共享或某些东西，然后其中之一

00:56:48.430 --> 00:56:53.050
经典的例子之一

00:56:49.930 --> 00:56:56.200
问题是我如何使自己具有韧性

00:56:53.050 --> 00:56:58.120
因此，如果我丢失服务器，就知道我已经

00:56:56.200 --> 00:57:00.820
失去了我的能力，但另一方面

00:56:58.120 --> 00:57:02.590
手你不想要你不想要两个

00:57:00.820 --> 00:57:04.600
实例正在运行，因为它们都可以

00:57:02.590 --> 00:57:07.480
相同的文件，除非您执行某种操作

00:57:04.600 --> 00:57:09.190
全局锁定策略

00:57:07.480 --> 00:57:11.830
电缆现已在春季上市

00:57:09.190 --> 00:57:14.860
集成，但通常您可能

00:57:11.830 --> 00:57:17.290
想考虑使用Spring 

00:57:14.860 --> 00:57:19.720
 XD托管您的X集成

00:57:17.290 --> 00:57:22.150
应用程序，因为如果XD管理员

00:57:19.720 --> 00:57:28.090
它检测到FTP适配器

00:57:22.150 --> 00:57:30.340
向下它可以然后发射另一个

00:57:28.090 --> 00:57:31.690
实例，所以就是这样

00:57:30.340 --> 00:57:34.510
绝对是要寻找的东西

00:57:31.690 --> 00:57:37.090
弹性和故障转移等

00:57:34.510 --> 00:57:39.790
作为X的动态缩放

00:57:37.090 --> 00:57:44.470
执事可以添加吗

00:57:39.790 --> 00:57:45.790
容器，如果您的工作量增加

00:57:44.470 --> 00:57:48.310
加里，我只是快速浏览了一下

00:57:45.790 --> 00:57:52.270
因为我很好奇它看起来像轴突

00:57:48.310 --> 00:57:54.490
是一种异步形式，看起来像是

00:57:52.270 --> 00:57:56.020
有点像你知道的具体化

00:57:54.490 --> 00:58:00.220
一种特定的设计模式

00:57:56.020 --> 00:58:04.890
异步处理等

00:58:00.220 --> 00:58:08.650
而且无论如何只是兴趣点

00:58:04.890 --> 00:58:11.040
让我们看看莱昂纳多·席尔瓦（Leonardo Silva）问

00:58:08.650 --> 00:58:13.330
有任何方法可以监控这些流量

00:58:11.040 --> 00:58:16.210
阿耳emi弥斯深思你知道你的意思

00:58:13.330 --> 00:58:19.570
像杰伊·麦克斯（Jay Max），他说很好，你知道

00:58:16.210 --> 00:58:21.840
也许嗯，但你知道他在找一个

00:58:19.570 --> 00:58:26.530
他可以看到其运行时流的地方

00:58:21.840 --> 00:58:44.830
响应时间是危机的状态，所以如果

00:58:26.530 --> 00:58:47.350
你，如果你启用一个JMX，我不

00:58:44.830 --> 00:58:50.140
记住什么时候注释是什么

00:58:47.350 --> 00:58:52.420
使用XML，但是如果启用jmx 

00:58:50.140 --> 00:58:55.330
然后所有的整合

00:58:52.420 --> 00:58:59.470
组件将保持统计信息，因此每个

00:58:55.330 --> 00:59:04.000
频道，以便您可以查看发送价格

00:58:59.470 --> 00:59:06.010
可以看到QQ深度，可以看到各种

00:59:04.000 --> 00:59:08.410
通过

00:59:06.010 --> 00:59:10.930
系统，因此JM x是第一个phys 

00:59:08.410 --> 00:59:15.670
确定要调整的地方

00:59:10.930 --> 00:59:20.560
只需启用J max是

00:59:15.670 --> 00:59:22.930
优秀的嗯，然后我实际上想

00:59:20.560 --> 00:59:24.640
回到Eric的问题

00:59:22.930 --> 00:59:28.390
只是第二个真正的快速而公正

00:59:24.640 --> 00:59:30.480
提到我们在谈论你

00:59:28.390 --> 00:59:32.710
知道插入诸如事件之类的东西

00:59:30.480 --> 00:59:34.120
就像轴突一样，你知道的一代流

00:59:32.710 --> 00:59:36.310
或者你知道我们说它像RX 

00:59:34.120 --> 00:59:39.940
 Java或您知道类似的东西或

00:59:36.310 --> 00:59:44.200
反应堆也许你知道，但是反应堆

00:59:39.940 --> 00:59:46.780
我们实际上已经有一个资源

00:59:44.200 --> 00:59:49.120
从 Spring 开始

00:59:46.780 --> 00:59:50.740
 XD级我不太记得

00:59:49.120 --> 00:59:55.540
我们将其作为 Spring Integration 

00:59:50.740 --> 00:59:57.400
水平与否，但你知道

00:59:55.540 --> 00:59:59.890
如果您正在寻找

00:59:57.400 --> 01:00:02.230
延伸Spring 整合延伸

00:59:59.890 --> 01:00:04.900
Spring 集成完全建立在

01:00:02.230 --> 01:00:06.880
与建造Spring 一样的经验

01:00:04.900 --> 01:00:09.390
集成通道适配器，所以您知道

01:00:06.880 --> 01:00:13.090
该怎么做，你知道如何扩展

01:00:09.390 --> 01:00:15.490
 Spring XD的模块，这是一个很好的选择

01:00:13.090 --> 01:00:18.730
一样是因为XT实际上是构建的

01:00:15.490 --> 01:00:21.070
直接在权利和和

01:00:18.730 --> 01:00:22.600
实际上您知道新的通道适配器

01:00:21.070 --> 01:00:25.090
真的很容易，我是说他们你

01:00:22.600 --> 01:00:28.600
实施或扩展经典

01:00:25.090 --> 01:00:31.170
消息生产者的支持和支持

01:00:28.600 --> 01:00:34.510
然后，课程使您能够

01:00:31.170 --> 01:00:37.600
向发出消息

01:00:34.510 --> 01:00:39.490
我们正在研究的框架以及

01:00:37.600 --> 01:00:40.930
与项目反应物的更多整合

01:00:39.490 --> 01:00:43.870
您提到的Spring 整合

01:00:40.930 --> 01:00:46.600
我们在XD中正在进行一些工作

01:00:43.870 --> 01:00:49.510
在Spring Integration 4.1中也有

01:00:46.600 --> 01:00:51.180
我们有基于承诺的网关通知

01:00:49.510 --> 01:00:53.560
当您向您发送消息时

01:00:51.180 --> 01:00:56.370
您回来的Spring集成网关

01:00:53.560 --> 01:01:00.250
一个承诺，以便继续

01:00:56.370 --> 01:01:01.720
不反应很酷好有趣

01:01:00.250 --> 01:01:03.910
好吧，我不谢谢你，我没有

01:01:01.720 --> 01:01:07.260
意识到，我们真棒

01:01:03.910 --> 01:01:09.850
 10分钟后，我想我们有

01:01:07.260 --> 01:01:11.410
暂时用尽了问题队列

01:01:09.850 --> 01:01:13.750
伙计们，我要给你你知道

01:01:11.410 --> 01:01:16.270
仍然有60个人

01:01:13.750 --> 01:01:18.820
电话，我再给你一分钟或

01:01:16.270 --> 01:01:21.430
我有点想问两个问题

01:01:18.820 --> 01:01:24.220
今天在这里为我们做一个快速总结

01:01:21.430 --> 01:01:27.010
所以我只想提一下

01:01:24.220 --> 01:01:28.720
如果您正在录制网络研讨会， 

01:01:27.010 --> 01:01:31.690
想要分享记录

01:01:28.720 --> 01:01:35.260
与您的同事所有您需要做的

01:01:31.690 --> 01:01:37.089
订阅去 Spring 

01:01:35.260 --> 01:01:41.470
点IO网站，并进入The Spring Blog

01:01:37.089 --> 01:01:43.210
点IO正斜杠博客，是的

01:01:41.470 --> 01:01:45.280
然后订阅原子供稿

01:01:43.210 --> 01:01:47.349
在那里，一旦我们重播

01:01:45.280 --> 01:01:49.780
我们总是发表博客文章， 

01:01:47.349 --> 01:01:51.670
将YouTube视频嵌入博客文章中

01:01:49.780 --> 01:01:54.190
因此您会收到一条通知， 

01:01:51.670 --> 01:01:56.410
重播也可以通过

01:01:54.190 --> 01:01:58.660
订阅原子饲料，您将获得全部

01:01:56.410 --> 01:02:02.020
 Spring 的精彩博客内容

01:01:58.660 --> 01:02:04.000
您的工程小组都知道

01:02:02.020 --> 01:02:06.849
春季重播，很多很多， 

01:02:04.000 --> 01:02:09.730
还有很多其他很棒的东西

01:02:06.849 --> 01:02:13.450
随时获得通知的好方法

01:02:09.730 --> 01:02:15.339
将链接发布到此幻灯片，以便您

01:02:13.450 --> 01:02:17.520
知道加里也将发布他的幻灯片

01:02:15.339 --> 01:02:20.829
虽然不是很多

01:02:17.520 --> 01:02:24.460
分散剂啊所以也许我应该说

01:02:20.829 --> 01:02:26.440
他将只发布几个链接来发布他的幻灯片

01:02:24.460 --> 01:02:28.780
仅是几个重要的链接

01:02:26.440 --> 01:02:30.250
我看过的一些东西

01:02:28.780 --> 01:02:32.500
另一件事是你可以一直在

01:02:30.250 --> 01:02:36.250
博客你可以永远你可以永远

01:02:32.500 --> 01:02:38.500
搜索收入重播，是的，我

01:02:36.250 --> 01:02:40.089
就是说你可以写的真的是

01:02:38.500 --> 01:02:42.160
是的，是的，我真的很想成为

01:02:40.089 --> 01:02:46.000
与命名约定一致

01:02:42.160 --> 01:02:47.650
正是因为这个原因，所以我们

01:02:46.000 --> 01:02:51.220
始终具有相同的命名约定

01:02:47.650 --> 01:02:53.619
然后，重播视图将是

01:02:51.220 --> 01:02:55.540
通常我们通常会尝试

01:02:53.619 --> 01:02:57.760
在一周内或过于频繁地完成

01:02:55.540 --> 01:02:59.890
快点取决于裂缝

01:02:57.760 --> 01:03:01.030
依此类推，但在外面您会看到

01:02:59.890 --> 01:03:02.470
你有两周的重放

01:03:01.030 --> 01:03:05.829
您可以与您的同事分享， 

01:03:02.470 --> 01:03:07.839
回去分析加里的每一个字

01:03:05.829 --> 01:03:12.760
然后我说出话来叫我们到垫子上

01:03:07.839 --> 01:03:16.210
说一些不正确的话，嗯，如果

01:03:12.760 --> 01:03:18.280
您想获得我们的软件

01:03:16.210 --> 01:03:20.560
请注意，我们并未真正启用

01:03:18.280 --> 01:03:22.660
禁用了以下的直接HTTP下载

01:03:20.560 --> 01:03:24.579
 Spring 二进制文件前一段时间

01:03:22.660 --> 01:03:26.560
因为维护是或Gradle是

01:03:24.579 --> 01:03:29.470
如果您真的是一个很棒的体验

01:03:26.560 --> 01:03:30.790
只是渴望HTTP下载你

01:03:29.470 --> 01:03:31.690
知道您在军事网络中或

01:03:30.790 --> 01:03:33.460
你在政府或衣服上

01:03:31.690 --> 01:03:36.520
网络，或者您知道自己落后20 

01:03:33.460 --> 01:03:37.780
层代理服务器只是去回购

01:03:36.520 --> 01:03:39.970
 Spring 做

01:03:37.780 --> 01:03:41.440
那是我们的人工服务器礼貌

01:03:39.970 --> 01:03:44.440
周杰伦青蛙和

01:03:41.440 --> 01:03:46.510
您可以获取HTTP下载

01:03:44.440 --> 01:03:48.670
如果你在这里就需要那里

01:03:46.510 --> 01:03:51.520
绝望，但一如既往，请给

01:03:48.670 --> 01:03:52.810
在真正释放世界

01:03:51.520 --> 01:03:56.109
对您的反馈意见感到好奇，我们认为

01:03:52.810 --> 01:03:58.440
对于 Spring Integration 而言意义重大， 

01:03:56.109 --> 01:04:01.660
祝贺我们的需求和加里

01:03:58.440 --> 01:04:04.869
忘记了完成并给我们

01:04:01.660 --> 01:04:06.640
您对Spring Central um的反馈意见

01:04:04.869 --> 01:04:08.710
就像我们最后一个问题突然出现

01:04:06.640 --> 01:04:12.130
加里，您可以以

01:04:08.710 --> 01:04:14.589
问题麻烦好吧，埃里克，那个家伙， 

01:04:12.130 --> 01:04:17.650
问了一个关于亚当的大问题

01:04:14.589 --> 01:04:19.180
对不起，我对他的轴心感到好奇

01:04:17.650 --> 01:04:21.760
用什么区别

01:04:19.180 --> 01:04:25.359
在Spring XD加Spring 之间

01:04:21.760 --> 01:04:32.440
集成和Spring Batch处理，所以这是

01:04:25.359 --> 01:04:35.410
垒球好吧，好吧

01:04:32.440 --> 01:04:37.810
实际上是 Spring 的XD我有点偷了

01:04:35.410 --> 01:04:40.089
说一点点XD雷声

01:04:37.810 --> 01:04:42.280
 spring XD是基于spring的

01:04:40.089 --> 01:04:44.230
整合实际上是由

01:04:42.280 --> 01:04:47.859
Spring 整合和Spring 批处理

01:04:44.230 --> 01:04:52.780
所以 Spring XD以及有流

01:04:47.859 --> 01:04:55.599
端到端数据处理

01:04:52.780 --> 01:05:00.460
管道和改造等，我们也有

01:04:55.599 --> 01:05:03.910
部署作业的能力

01:05:00.460 --> 01:05:08.050
 Spring XD，所以我们可以做些事情

01:05:03.910 --> 01:05:12.839
例如通过Spring XD和的发布工作

01:05:08.050 --> 01:05:15.640
当然，Spring Batch处理项目本身

01:05:12.839 --> 01:05:17.980
有一个用于Spring Batch处理的模块

01:05:15.640 --> 01:05:19.420
管理员，但是这里有一个模块

01:05:17.980 --> 01:05:22.270
Spring Batch称为Spring Batch

01:05:19.420 --> 01:05:26.170
集成实际上具有挂钩

01:05:22.270 --> 01:05:28.750
做诸如启动批处理之类的事情

01:05:26.170 --> 01:05:30.190
Spring 整合流程中的工作

01:05:28.750 --> 01:05:32.380
你可以有Spring 集成流程

01:05:30.190 --> 01:05:35.829
从以下位置下载文件的示例

01:05:32.380 --> 01:05:37.210
 FTP在该文件存储上做了一些工作

01:05:35.829 --> 01:05:39.010
该文件在其他地方，然后

01:05:37.210 --> 01:05:41.859
启动一个批处理作业来处理

01:05:39.010 --> 01:05:43.180
文件，那是一回事， 

01:05:41.859 --> 01:05:45.970
那么另一个方向是

01:05:43.180 --> 01:05:48.579
你可以在春季Spring Batch中

01:05:45.970 --> 01:05:51.670
您可以启动Spring集成的工作

01:05:48.579 --> 01:05:54.070
在物品阅读器内流动或

01:05:51.670 --> 01:05:56.140
如果您需要作家将有您

01:05:54.070 --> 01:05:57.910
或需要外出的物品处理

01:05:56.140 --> 01:05:59.830
你可以调用Spring 

01:05:57.910 --> 01:06:01.810
从 Spring 开始的整合流程

01:05:59.830 --> 01:06:05.320
批处理作业，并且有很多示例

01:06:01.810 --> 01:06:07.780
在Spring Batch量项目中

01:06:05.320 --> 01:06:10.869
但是正如我所说的，Spring XD本身确实

01:06:07.780 --> 01:06:13.990
封装工作，它做一个

01:06:10.869 --> 01:06:17.310
分区特别好

01:06:13.990 --> 01:06:20.430
实际上使用XD的作业

01:06:17.310 --> 01:06:24.070
集装箱基础设施和动物园管理员

01:06:20.430 --> 01:06:27.040
用于维护实例的东西

01:06:24.070 --> 01:06:31.000
实际进行工作分区，因此开始

01:06:27.040 --> 01:06:33.490
分区作业和启动发布日

01:06:31.000 --> 01:06:36.280
他们的启动分区是

01:06:33.490 --> 01:06:37.990
在不同的XD容器中处理

01:06:36.280 --> 01:06:39.609
然后结果全部累加

01:06:37.990 --> 01:06:43.030
返回到分区作业（如果有） 

01:06:39.609 --> 01:06:45.070
需要大量工作的巨大工作

01:06:43.030 --> 01:06:47.470
处理甚至多个JVM 

01:06:45.070 --> 01:06:51.160
实际完成工作，那么xtn是

01:06:47.470 --> 01:06:55.030
另一个出色的跑步平台

01:06:51.160 --> 01:06:57.070
这样的工作太棒了，谢谢Gary是的

01:06:55.030 --> 01:07:01.810
只是很有趣，我要提醒自己

01:06:57.070 --> 01:07:04.840
一直都在思考XD 

01:07:01.810 --> 01:07:06.550
是这种无缝扩展

01:07:04.840 --> 01:07:08.980
批处理和集成，您

01:07:06.550 --> 01:07:10.570
不能真正思考或谈论

01:07:08.980 --> 01:07:13.600
批量集成，无需

01:07:10.570 --> 01:07:15.790
想着XD然后

01:07:13.600 --> 01:07:18.250
而且你知道，不管你知道什么

01:07:15.790 --> 01:07:20.380
是，但是有些你知道

01:07:18.250 --> 01:07:21.580
认识您的电话中的每个人

01:07:20.380 --> 01:07:24.040
知道这有点

01:07:21.580 --> 01:07:25.450
与传统不同的权利

01:07:24.040 --> 01:07:27.040
可嵌入的spring库

01:07:25.450 --> 01:07:29.530
您的应用程序，您的spring XD是

01:07:27.040 --> 01:07:31.240
运行时，如果你看看我们的 Spring 

01:07:29.530 --> 01:07:33.280
爱荷华州平台图，我的意思是

01:07:31.240 --> 01:07:35.530
执行层的一部分，这是一部分

01:07:33.280 --> 01:07:37.960
你知道的那种运行时间

01:07:35.530 --> 01:07:40.600
特定于域的运行时的概念

01:07:37.960 --> 01:07:42.070
我们一直在进步，你知道

01:07:40.600 --> 01:07:44.770
它与某些

01:07:42.070 --> 01:07:46.060
您传统的Spring Dome项目

01:07:44.770 --> 01:07:47.859
只是可嵌入的库

01:07:46.060 --> 01:07:49.510
这实际上是一个

01:07:47.859 --> 01:07:52.420
服务器，因为这是你可以做一些

01:07:49.510 --> 01:07:56.109
真的很有趣，它可以做一些真正的

01:07:52.420 --> 01:07:58.690
有趣的事情对不起，所以Gary um 

01:07:56.109 --> 01:08:00.820
非常感谢，我知道阿尔Art 

01:07:58.690 --> 01:08:02.350
你在排队，然后帮忙

01:08:00.820 --> 01:08:03.550
聊天，恭喜双方

01:08:02.350 --> 01:08:05.980
你们这绝对是史诗般的

01:08:03.550 --> 01:08:08.140
发布，嗯，谢谢你们

01:08:05.980 --> 01:08:12.910
与您一起度过的时光

01:08:08.140 --> 01:08:15.280
今天和嗯

01:08:12.910 --> 01:08:16.779
将会在

01:08:15.280 --> 01:08:20.410
一两周您想发表的任何评论

01:08:16.779 --> 01:08:22.420
像平常一样将其关闭

01:08:20.410 --> 01:08:24.940
资源与堆栈溢出

01:08:22.420 --> 01:08:27.549
 spring集成标签（如果有） 

01:08:24.940 --> 01:08:30.009
问题，您有任何新功能

01:08:27.549 --> 01:08:32.920
我们可以开始传播的建议

01:08:30.009 --> 01:08:35.830
堆栈溢出和其他进度或

01:08:32.920 --> 01:08:39.580
直接去JIRA问一下

01:08:35.830 --> 01:08:41.890
要求Spring 整合超过

01:08:39.580 --> 01:08:44.049
目前，SL是通过

01:08:41.890 --> 01:08:46.210
我提到的集成扩展

01:08:44.049 --> 01:08:48.040
这是它自己的生命周期

01:08:46.210 --> 01:08:52.600
现在，您可以在

01:08:48.040 --> 01:08:54.190
在JIRA的文本项目中

01:08:52.600 --> 01:08:56.109
可以放进去，因为正如我所说

01:08:54.190 --> 01:08:59.859
最终它将被折叠

01:08:56.109 --> 01:09:02.470
陷入Spring 整合问题

01:08:59.859 --> 01:09:06.549
堆栈溢出到第一位

01:09:02.470 --> 01:09:10.690
问题等等，JIRA和

01:09:06.549 --> 01:09:15.569
当然如彼得所说，如果你继续

01:09:10.690 --> 01:09:21.069
看着 Spring 的博客，然后我们

01:09:15.569 --> 01:09:23.650
通常在那儿张贴可能

01:09:21.069 --> 01:09:26.170
对社区肯定很有趣

01:09:23.650 --> 01:09:28.810
谢谢，好吧，谢谢大家

01:09:26.170 --> 01:09:32.049
祝您有个愉快的一天

01:09:28.810 --> 01:09:35.190
下一次网络研讨会，如果我们确实很不错

01:09:32.049 --> 01:09:38.380
如果您不好意思，请参加

01:09:35.190 --> 01:09:40.960
接下来的几场网络研讨会已经开始

01:09:38.380 --> 01:09:42.190
在春季现场，但我们有

01:09:40.960 --> 01:09:45.640
 Spring 来了一些好东西

01:09:42.190 --> 01:09:47.739
 2月的会议上，您应该参加

01:09:45.640 --> 01:09:49.359
看二月的阵容

01:09:47.739 --> 01:09:52.359
好东西，像是春季会议

01:09:49.359 --> 01:09:54.940
我们有一个方便的威尔金森网络研讨会

01:09:52.359 --> 01:09:57.130
关于记录 rest api 的讨论

01:09:54.940 --> 01:09:59.250
你知道昂首阔步的阿尔卑斯山，你知道怎么做

01:09:57.130 --> 01:10:03.820
你如何处理元数据

01:09:59.250 --> 01:10:05.320
还有一个实际上是主题

01:10:03.820 --> 01:10:08.020
逃避此刻，但继续

01:10:05.320 --> 01:10:10.060
看看Springdale博客，如果您

01:10:08.020 --> 01:10:11.800
看看这个星期的 Spring 通常是

01:10:10.060 --> 01:10:13.420
任何网络研讨会的快速总结

01:10:11.800 --> 01:10:15.610
来吧，所以总是很好

01:10:13.420 --> 01:10:16.690
不仅在此找到他们的地方

01:10:15.610 --> 01:10:17.800
遍历博客平面树

01:10:16.690 --> 01:10:20.320
感谢大家

01:10:17.800 --> 01:10:22.380
祝你有个愉快的一周再见

01:10:20.320 --> 01:10:22.380
您

