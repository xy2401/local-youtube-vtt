WEBVTT
Kind: captions
Language: zh-Hans

00:00:13.110 --> 00:00:20.820
欢迎大家在我身边打招呼

00:00:17.330 --> 00:00:24.060
欢迎从春季参加网络研讨会

00:00:20.820 --> 00:00:26.400
虽然实际上覆盖了照片

00:00:24.060 --> 00:00:29.730
即将发布的照片​​的状态

00:00:26.400 --> 00:00:32.480
那个版本，所以你得到

00:00:29.730 --> 00:00:35.130
这是DOE的最新消息

00:00:32.480 --> 00:00:39.060
预定在星期一发布

00:00:35.130 --> 00:00:41.610
几天后在这里，有一个

00:00:39.060 --> 00:00:43.649
我实际上特定于的一两个便笺

00:00:41.610 --> 00:00:46.530
即使在这个演讲中

00:00:43.649 --> 00:00:49.980
在这里，但从根本上讲

00:00:46.530 --> 00:00:52.559
春季电影完整版

00:00:49.980 --> 00:00:54.989
是第四代

00:00:52.559 --> 00:00:58.800
春天特别从它开始

00:00:54.989 --> 00:01:01.559
第一次，如果我们真的提高

00:00:58.800 --> 00:01:05.309
春季框架之后的基线

00:01:01.559 --> 00:01:09.360
三门释放我们花了相当多的时间

00:01:05.309 --> 00:01:11.700
三人组与春天的时间

00:01:09.360 --> 00:01:14.640
 Frio系列我们介绍了Spring Framework 

00:01:11.700 --> 00:01:18.420
 3.1具有非常重要的新功能

00:01:14.640 --> 00:01:20.580
那时我们有点结束那条线

00:01:18.420 --> 00:01:24.300
三到两代

00:01:20.580 --> 00:01:28.010
仍积极保持春季热

00:01:24.300 --> 00:01:30.930
为我们提供了一个机会

00:01:28.010 --> 00:01:33.750
基本上重新审视整个框架

00:01:30.930 --> 00:01:36.300
这就是本次网络研讨会的内容

00:01:33.750 --> 00:01:38.910
真的我会解释一下

00:01:36.300 --> 00:01:41.970
关于动机的一点

00:01:38.910 --> 00:01:44.570
我们在这里的使命是什么

00:01:41.970 --> 00:01:48.180
专注于我们所驱动的

00:01:44.570 --> 00:01:50.730
我也要专门

00:01:48.180 --> 00:01:51.900
解释一些关于

00:01:50.730 --> 00:01:54.750
升级程序

00:01:51.900 --> 00:01:57.060
所以这与介绍有关

00:01:54.750 --> 00:02:00.690
源于mokoro框架本身

00:01:57.060 --> 00:02:02.850
因为它也是关于引入弹簧的

00:02:00.690 --> 00:02:04.320
发布到您的框架

00:02:02.850 --> 00:02:05.880
部署环境到您的

00:02:04.320 --> 00:02:08.440
开发环境和您的

00:02:05.880 --> 00:02:12.160
部署环境

00:02:08.440 --> 00:02:14.980
因为我们真的付出了额外的努力

00:02:12.160 --> 00:02:16.540
确保升级顺利

00:02:14.980 --> 00:02:18.670
从春季到挤出机

00:02:16.540 --> 00:02:21.820
特别肯定地认为

00:02:18.670 --> 00:02:26.170
升级，我们将重新审视这是什么

00:02:21.820 --> 00:02:28.270
网络研讨会的结束首先，让我们

00:02:26.170 --> 00:02:29.830
只是看看它实际在哪里

00:02:28.270 --> 00:02:30.459
实际位于我们的投资组合中

00:02:29.830 --> 00:02:32.890
这些日子

00:02:30.459 --> 00:02:35.290
春季面料沟是基础

00:02:32.890 --> 00:02:37.810
我们特别要做的许多事情

00:02:35.290 --> 00:02:41.080
这是我们所谓的基础

00:02:37.810 --> 00:02:43.390
春季石油平台将看到

00:02:41.080 --> 00:02:47.080
第一次发布实际上不远

00:02:43.390 --> 00:02:50.290
从这里春天出来

00:02:47.080 --> 00:02:52.840
沟是容易的基础层

00:02:50.290 --> 00:02:54.430
下一代顶级产品

00:02:52.840 --> 00:02:57.459
 Grails运行在春天的顶部

00:02:54.430 --> 00:03:01.090
明天我们的春季启动计划

00:02:57.459 --> 00:03:02.470
完全是Spring框架

00:03:01.090 --> 00:03:04.900
春季起皱的面团

00:03:02.470 --> 00:03:08.410
真正启用引导可以

00:03:04.900 --> 00:03:12.370
这样做，我们的春季XP计划将继续进行

00:03:08.410 --> 00:03:16.299
大数据场景中的数据摄取

00:03:12.370 --> 00:03:18.160
考虑这些的全新方法

00:03:16.299 --> 00:03:20.560
所有这些类型的架构

00:03:18.160 --> 00:03:22.720
东西是来自珊瑚的春天

00:03:20.560 --> 00:03:27.250
来自乌鸦的春天

00:03:22.720 --> 00:03:28.570
非常非常新的未来，所以我们要去

00:03:27.250 --> 00:03:30.690
专注于Spring框架

00:03:28.570 --> 00:03:33.310
演示文稿的其余部分，但

00:03:30.690 --> 00:03:34.959
肯定检查其他一些

00:03:33.310 --> 00:03:38.260
春天我们在这里做的项目

00:03:34.959 --> 00:03:40.660
帅哥，我要特别谈

00:03:38.260 --> 00:03:43.959
关于它只是一点点参考

00:03:40.660 --> 00:03:45.280
如果你再几次的话

00:03:43.959 --> 00:03:47.230
演讲是关于春天的

00:03:45.280 --> 00:03:50.200
框架视角本身

00:03:47.230 --> 00:03:51.970
传统上面向框架，但

00:03:50.200 --> 00:03:54.700
请记住，有新鲜的新方法

00:03:51.970 --> 00:03:57.190
实际使用spring框架

00:03:54.700 --> 00:03:59.709
中间件方面的春天

00:03:57.190 --> 00:04:02.010
与其他项目中的功能

00:03:59.709 --> 00:04:07.030
作品集

00:04:02.010 --> 00:04:10.770
因此，我们先来回顾一下

00:04:07.030 --> 00:04:10.770
最先进的

00:04:11.470 --> 00:04:18.760
我只喜欢你们两个理论

00:04:16.120 --> 00:04:20.739
通过几张指示代码的幻灯片来指导我

00:04:18.760 --> 00:04:24.160
显示代码示例的示例

00:04:20.739 --> 00:04:25.960
表示中的一些重要功能

00:04:24.160 --> 00:04:27.490
 Spring框架三代

00:04:25.960 --> 00:04:29.290
这基本上是

00:04:27.490 --> 00:04:31.810
基于注释的组件模型

00:04:29.290 --> 00:04:34.090
组件栏看起来像什么

00:04:31.810 --> 00:04:36.550
在春季框架三代

00:04:34.090 --> 00:04:40.860
让我们从这里的组件开始

00:04:36.550 --> 00:04:43.840
那只是一个普通的Java类

00:04:40.860 --> 00:04:46.960
带有少量注释的注释

00:04:43.840 --> 00:04:49.480
春天的头等公民

00:04:46.960 --> 00:04:51.820
组件模型，我们实际上看到了

00:04:49.480 --> 00:04:53.920
这里有三种注释

00:04:51.820 --> 00:04:57.310
在顶部的X服务注释是

00:04:53.920 --> 00:04:59.710
刻板印象，基本上告诉我们

00:04:57.310 --> 00:05:01.420
关于班级的一些事情

00:04:59.710 --> 00:05:04.660
正式地告诉我们有关

00:05:01.420 --> 00:05:06.430
课堂基本上是一种正式的表达方式

00:05:04.660 --> 00:05:10.750
这是一类特殊的

00:05:06.430 --> 00:05:14.770
汽车上的服务类别

00:05:10.750 --> 00:05:16.390
怀亚特（Wyatt）是一个很好的例子

00:05:14.770 --> 00:05:19.600
依赖注入注解你

00:05:16.390 --> 00:05:22.150
也可以在此处使用JSF 3:38注入，或

00:05:19.600 --> 00:05:25.060
您可以在有价值的地方使用Springs 

00:05:22.150 --> 00:05:26.350
那些表达类似的地方

00:05:25.060 --> 00:05:30.070
都是依赖注入和

00:05:26.350 --> 00:05:32.470
符号基本上可以识别

00:05:30.070 --> 00:05:35.530
此处的构造函数作为主要目标

00:05:32.470 --> 00:05:38.080
如果没有其他适应症，则应注射

00:05:35.530 --> 00:05:40.990
如果没有其他元数据，则给出

00:05:38.080 --> 00:05:43.180
影响这一点的容器将

00:05:40.990 --> 00:05:45.400
在一个简单的场景中选择这个

00:05:43.180 --> 00:05:48.520
这也是为什么它也可以用于

00:05:45.400 --> 00:05:50.860
当然是第三种领域和方法

00:05:48.520 --> 00:05:53.350
类别下有交易

00:05:50.860 --> 00:05:57.370
声明式服务的示例

00:05:53.350 --> 00:05:59.860
注解当然会有

00:05:57.370 --> 00:06:02.140
预定在其他域中的其他人

00:05:59.860 --> 00:06:05.290
紧缩必不可少的例子

00:06:02.140 --> 00:06:07.360
它们都允许您利用

00:06:05.290 --> 00:06:09.610
中间件服务

00:06:07.360 --> 00:06:12.849
通过使用组件级

00:06:09.610 --> 00:06:14.439
批注，但这就是运行时间

00:06:12.849 --> 00:06:19.800
影响总是存在运行时

00:06:14.439 --> 00:06:22.810
冲击弹簧作为一个组件

00:06:19.800 --> 00:06:24.939
容器可以发现

00:06:22.810 --> 00:06:26.979
全班通过寻找

00:06:24.939 --> 00:06:29.169
遵守定型观念的成见

00:06:26.979 --> 00:06:31.750
所以在服务之上可以实际服务

00:06:29.169 --> 00:06:34.229
作为一种识别标记

00:06:31.750 --> 00:06:35.949
全班通行证

00:06:34.229 --> 00:06:37.900
在怀亚特

00:06:35.949 --> 00:06:39.969
当然会有随机的影响

00:06:37.900 --> 00:06:41.979
春天选择此构造函数或其中之一

00:06:39.969 --> 00:06:43.900
带注释的构造函数何时

00:06:41.979 --> 00:06:46.090
创建该销售的新实例

00:06:43.900 --> 00:06:48.099
对具有明显特征的交易进行分类

00:06:46.090 --> 00:06:49.960
整场比赛对吧

00:06:48.099 --> 00:06:51.729
容器将开始

00:06:49.960 --> 00:06:53.740
交易在调用您的

00:06:51.729 --> 00:06:55.710
方法实现，它将提交

00:06:53.740 --> 00:06:57.849
或在最后回滚

00:06:55.710 --> 00:07:01.080
那是那些对运行时间的影响

00:06:57.849 --> 00:07:03.370
事情，但这让我们退后一步

00:07:01.080 --> 00:07:06.279
我们在这里看一段源代码

00:07:03.370 --> 00:07:08.560
这些注释与

00:07:06.279 --> 00:07:10.930
该源代码的可读性为

00:07:08.560 --> 00:07:12.909
它们与运行时的影响有关，因此请忘记

00:07:10.930 --> 00:07:15.550
关于暂时的影响

00:07:12.909 --> 00:07:17.319
在F服务中看到Java类

00:07:15.550 --> 00:07:19.479
记号告诉我们有关

00:07:17.319 --> 00:07:22.750
那个班级实际上在

00:07:19.479 --> 00:07:24.789
每个描述性的无效方式

00:07:22.750 --> 00:07:28.240
交易性的东西或关于

00:07:24.789 --> 00:07:29.949
方法是事务性的

00:07:28.240 --> 00:07:32.379
基本上正式定义

00:07:29.949 --> 00:07:34.089
该方法的特点是

00:07:32.379 --> 00:07:37.300
对读者来说也很重要

00:07:34.089 --> 00:07:39.099
甚至根本就不及悦

00:07:37.300 --> 00:07:41.949
赢得这个建设者是或怀亚特

00:07:39.099 --> 00:07:44.469
如果没有提供其他信息，那么他们

00:07:41.949 --> 00:07:46.990
那些真的是描述性的元数据

00:07:44.469 --> 00:07:49.389
您的源代码中的元素就是

00:07:46.990 --> 00:07:51.190
注释最初是来自

00:07:49.389 --> 00:07:54.250
他们就是设计观点

00:07:51.190 --> 00:07:57.610
主要应该是ram输入运行时

00:07:54.250 --> 00:08:00.009
随之而来的影响

00:07:57.610 --> 00:08:03.550
这是典型的组件类

00:08:00.009 --> 00:08:06.370
组件类的许多模仿

00:08:03.550 --> 00:08:07.539
春季时可合成

00:08:06.370 --> 00:08:10.180
通过那一个如果雷塔两个

00:08:07.539 --> 00:08:13.750
特殊的可组合方式意味着您可以

00:08:10.180 --> 00:08:15.310
建立自己的限制和使用

00:08:13.750 --> 00:08:17.050
用于标准注释的弹簧

00:08:15.310 --> 00:08:20.050
现成的注释作为元

00:08:17.050 --> 00:08:22.030
注释，这可能有点不寻常

00:08:20.050 --> 00:08:25.150
最初但从根本上讲

00:08:22.030 --> 00:08:27.939
完全正常的事情要做

00:08:25.150 --> 00:08:29.590
您的代码库中的新类型不是

00:08:27.939 --> 00:08:32.560
界面，不是课程，而是广告

00:08:29.590 --> 00:08:34.659
界面，它是一种注释类型

00:08:32.560 --> 00:08:36.669
为了定义您添加的类型

00:08:34.659 --> 00:08:39.279
该类型顶部的注释

00:08:36.669 --> 00:08:42.479
所以这里显示的我的服务注释是

00:08:39.279 --> 00:08:45.040
以您的自定义注释为例

00:08:42.479 --> 00:08:47.079
基本结合特点

00:08:45.040 --> 00:08:50.260
标准弹簧维修服务

00:08:47.079 --> 00:08:52.839
将范围默认为会话标记

00:08:50.260 --> 00:08:54.550
它是主要的，这意味着如果类型

00:08:52.839 --> 00:08:56.560
比赛不是唯一的，这是

00:08:54.550 --> 00:08:59.620
最好注入其他

00:08:56.560 --> 00:09:03.100
组件和默认交易

00:08:59.620 --> 00:09:05.680
即使这些规则基本上是

00:09:03.100 --> 00:09:08.500
为我服务合二为一

00:09:05.680 --> 00:09:10.750
从这个角度来看，这是一个

00:09:08.500 --> 00:09:11.920
每次都有一种捷径模型

00:09:10.750 --> 00:09:14.589
你说我的服务

00:09:11.920 --> 00:09:16.720
你实际上是在说

00:09:14.589 --> 00:09:18.810
痴迷于初级感觉

00:09:16.720 --> 00:09:21.820
事务性滚筒客车

00:09:18.810 --> 00:09:24.730
但是捷径有点像

00:09:21.820 --> 00:09:27.190
真正的好处是

00:09:24.730 --> 00:09:29.380
短名称

00:09:27.190 --> 00:09:31.750
削减我的服务可能不是

00:09:29.380 --> 00:09:34.120
世界上最伟大的名字，但名字

00:09:31.750 --> 00:09:36.970
基本上取决于您，您可以自由选择

00:09:34.120 --> 00:09:39.630
选择你自己的名字，我会

00:09:36.970 --> 00:09:42.370
绝对建议使用一个好的

00:09:39.630 --> 00:09:44.589
您内的有意义的表达性名称

00:09:42.370 --> 00:09:46.779
您的应用程序中的布局

00:09:44.589 --> 00:09:50.100
建筑也许所有的服务

00:09:46.779 --> 00:09:53.620
帐户服务或特定类型的

00:09:50.100 --> 00:09:56.649
服务角色对您有意义

00:09:53.620 --> 00:09:58.269
如果您是

00:09:56.649 --> 00:10:01.510
建立自定义注释选择好

00:09:58.269 --> 00:10:05.130
实际与之相关的名称

00:10:01.510 --> 00:10:07.830
基本上是您架构中的术语

00:10:05.130 --> 00:10:09.780
我当然要为英雄服务

00:10:07.830 --> 00:10:12.240
这样的注释可以在任何

00:10:09.780 --> 00:10:14.730
类型的数量，以便从中受益

00:10:12.240 --> 00:10:16.380
这些东西的捷径是你

00:10:14.730 --> 00:10:18.390
可以在数百种类型上使用它们

00:10:16.380 --> 00:10:21.350
必要的，他们总是表达

00:10:18.390 --> 00:10:23.880
以上特征的组合

00:10:21.350 --> 00:10:26.700
这是一种刻板印象

00:10:23.880 --> 00:10:29.220
组成了许多其他类型的注释

00:10:26.700 --> 00:10:31.170
在春天可以组成在同一

00:10:29.220 --> 00:10:33.090
建立自定义范围的方式

00:10:31.170 --> 00:10:35.700
您可以构建自定义的注释

00:10:33.090 --> 00:10:38.880
交易注释甚至可以自定义

00:10:35.700 --> 00:10:40.530
定义注释或自定义

00:10:38.880 --> 00:10:42.780
注入注释正确

00:10:40.530 --> 00:10:46.080
构图模型在这里基本起作用

00:10:42.780 --> 00:10:48.710
适用于几乎所有类型的注释

00:10:46.080 --> 00:10:48.710
春季框架

00:10:50.180 --> 00:10:58.680
我们配置的重要组成部分

00:10:55.440 --> 00:11:01.190
春季3代的模型

00:10:58.680 --> 00:11:03.240
配置配置类

00:11:01.190 --> 00:11:07.830
配置类基本上是

00:11:03.240 --> 00:11:11.040
工厂方法的集合

00:11:07.830 --> 00:11:14.100
与特定注释结合

00:11:11.040 --> 00:11:16.140
充当春天的终点

00:11:14.100 --> 00:11:18.089
豆，所以基本上您可以定义任何

00:11:16.140 --> 00:11:20.820
通过的春豆数量

00:11:18.089 --> 00:11:23.520
配置类，而不是放置

00:11:20.820 --> 00:11:26.310
按名称将它们转换为XML bean定义

00:11:23.520 --> 00:11:28.260
和类型，并在一些外部

00:11:26.310 --> 00:11:29.790
设置的属性

00:11:28.260 --> 00:11:32.220
我们基本上是在改变重点， 

00:11:29.790 --> 00:11:34.290
我们说的一切都很好

00:11:32.220 --> 00:11:37.440
是构建方法的工厂方法

00:11:34.290 --> 00:11:39.060
像这样的实例我的书管理员

00:11:37.440 --> 00:11:41.399
服务消息传递的名称

00:11:39.060 --> 00:11:44.209
工厂方法是默认的bean名称

00:11:41.399 --> 00:11:46.529
返回类型用作

00:11:44.209 --> 00:11:49.980
最初的bean类型是我们构建的

00:11:46.529 --> 00:11:52.860
实例添加bean注释

00:11:49.980 --> 00:11:54.360
基本上将其标记为生产咖啡豆

00:11:52.860 --> 00:11:56.190
您还可以指定定义

00:11:54.360 --> 00:11:59.400
该级别的其他特征

00:11:56.190 --> 00:12:02.279
可以添加一个主要的惰性符号

00:11:59.400 --> 00:12:05.100
记号在

00:12:02.279 --> 00:12:06.810
此级别的配置类可以

00:12:05.100 --> 00:12:09.480
有很多这样的表演方法

00:12:06.810 --> 00:12:12.029
他们可以互相打个招呼

00:12:09.480 --> 00:12:13.980
生命周期中的语义

00:12:12.029 --> 00:12:16.730
管理仍然非常适用

00:12:13.980 --> 00:12:18.930
用于存在方式内的调用

00:12:16.730 --> 00:12:20.880
在上面有一个刻板印象

00:12:18.930 --> 00:12:22.860
配置基本上说我们

00:12:20.880 --> 00:12:25.170
在特殊的课堂上

00:12:22.860 --> 00:12:27.870
在配置类spring中

00:12:25.170 --> 00:12:29.520
刻板印象模式为此而行动

00:12:27.870 --> 00:12:30.650
框配置类模式的

00:12:29.520 --> 00:12:32.900
层

00:12:30.650 --> 00:12:34.670
可以有任意数量的

00:12:32.900 --> 00:12:37.610
您系统中的配置类

00:12:34.670 --> 00:12:39.110
可以有一百个有一百个

00:12:37.610 --> 00:12:40.730
民族方法或一百

00:12:39.110 --> 00:12:43.790
一加的配置类

00:12:40.730 --> 00:12:48.860
方法取决于你，所以他们

00:12:43.790 --> 00:12:51.050
也是结合某某的单位

00:12:48.860 --> 00:12:54.200
范围意味着您基本上可以使用

00:12:51.050 --> 00:12:56.300
它们作为一种结构元素

00:12:54.200 --> 00:12:58.850
结构化您的配置

00:12:56.300 --> 00:13:01.640
全面安排

00:12:58.850 --> 00:13:03.950
你也知道穿制服

00:13:01.640 --> 00:13:08.990
让您跟随自己

00:13:03.950 --> 00:13:10.730
实际上意味着要考虑

00:13:08.990 --> 00:13:13.580
此处显示的其他注释

00:13:10.730 --> 00:13:16.370
很快便有关于他们的注释

00:13:13.580 --> 00:13:19.790
在其个人资料上方的广告个人资料是

00:13:16.370 --> 00:13:22.180
一种简单的存在状态

00:13:19.790 --> 00:13:24.800
基本上说的定义条件

00:13:22.180 --> 00:13:27.110
此配置定义的bean 

00:13:24.800 --> 00:13:30.440
我只实际注册的课程

00:13:27.110 --> 00:13:32.930
如果配置文件调用容器

00:13:30.440 --> 00:13:36.650
独立服务器标记为在

00:13:32.930 --> 00:13:39.470
然后启动，只有那时

00:13:36.650 --> 00:13:40.880
任何数量的个人资料，因此您可以

00:13:39.470 --> 00:13:43.940
就像整个矩阵一样

00:13:40.880 --> 00:13:46.730
如果要合并的个人资料

00:13:43.940 --> 00:13:49.430
设置您的不同变体

00:13:46.730 --> 00:13:53.060
从您的申请到通过

00:13:49.430 --> 00:13:56.630
像是个人资料的组合

00:13:53.060 --> 00:13:58.700
是指特定的配置文件

00:13:56.630 --> 00:14:00.590
您的架构中的垂直行业

00:13:58.700 --> 00:14:05.750
或者您可以具有特定的配置文件

00:14:00.590 --> 00:14:08.240
随机随机平台或针对特定

00:14:05.750 --> 00:14:11.030
目标中间件，即您是您

00:14:08.240 --> 00:14:13.070
配置为与个人资料交互

00:14:11.030 --> 00:14:14.780
是一个非常灵活的机制，但是

00:14:13.070 --> 00:14:17.690
他们基本上是静态的

00:14:14.780 --> 00:14:19.940
配置文件的名称是那些配置文件名称

00:14:17.690 --> 00:14:22.520
可能被设置为在启动时处于活动状态

00:14:19.940 --> 00:14:24.320
基本上，我们将重新讨论这一点

00:14:22.520 --> 00:14:29.540
从春季框架的角度来看

00:14:24.320 --> 00:14:32.650
再过几个月又很快

00:14:29.540 --> 00:14:36.220
专注于此

00:14:32.650 --> 00:14:39.010
零部件模型类型匹配播放播放

00:14:36.220 --> 00:14:41.740
您可以参考的重要角色

00:14:39.010 --> 00:14:45.190
具体要用我的名字

00:14:41.740 --> 00:14:46.660
传统上是用外部注射

00:14:45.190 --> 00:14:48.490
光束定义格式就是您所需要的

00:14:46.660 --> 00:14:51.070
会做那也是你会做的

00:14:48.490 --> 00:14:53.470
地址或环境卫生

00:14:51.070 --> 00:14:57.130
但是基于注释的组件模型

00:14:53.470 --> 00:14:59.800
我们添加了自动电线，他们也注入了

00:14:57.130 --> 00:15:02.500
基本上在这里表示类型匹配

00:14:59.800 --> 00:15:05.380
你是说我有一个构造函数或

00:15:02.500 --> 00:15:07.660
字段或其他构造函数

00:15:05.380 --> 00:15:09.280
有一个论点需要考虑

00:15:07.660 --> 00:15:10.660
存储库可以具有任意数量的

00:15:09.280 --> 00:15:12.730
参数，但在此示例中， 

00:15:10.660 --> 00:15:16.330
一个帐户存储库

00:15:12.730 --> 00:15:20.910
它基本上要求依赖

00:15:16.330 --> 00:15:20.910
按类型输入帐户存储库

00:15:21.320 --> 00:15:27.410
嘻嘻

00:15:23.240 --> 00:15:29.780
这个想法是在80％的情况下

00:15:27.410 --> 00:15:31.790
给定只有一场比赛

00:15:29.780 --> 00:15:34.910
在容器中注册的类型

00:15:31.790 --> 00:15:35.600
首先要记住类型匹配

00:15:34.910 --> 00:15:38.390
弹簧

00:15:35.600 --> 00:15:40.370
参考定义明确的光束

00:15:38.390 --> 00:15:42.860
当前在

00:15:40.370 --> 00:15:44.660
容器，所以实际上

00:15:42.860 --> 00:15:47.750
寄存器是定义

00:15:44.660 --> 00:15:49.130
这不是关于悬挂的任意光束

00:15:47.750 --> 00:15:49.940
在你上课的路上，碰巧

00:15:49.130 --> 00:15:52.190
匹配类型

00:15:49.940 --> 00:15:53.810
关于注册的组件类

00:15:52.190 --> 00:15:55.940
与该注册

00:15:53.810 --> 00:15:58.550
容器，例如配置文件

00:15:55.940 --> 00:16:00.410
之前显示的机制实际上可以预

00:15:58.550 --> 00:16:02.120
选择实际注册的内容

00:16:00.410 --> 00:16:03.710
该容器可以用作一种

00:16:02.120 --> 00:16:08.120
某些事情没有过滤机制

00:16:03.710 --> 00:16:10.010
在某些情况下进入

00:16:08.120 --> 00:16:11.470
任何形式的安排

00:16:10.010 --> 00:16:13.580
你有很多定义

00:16:11.470 --> 00:16:15.500
上面显示了一些注入点

00:16:13.580 --> 00:16:18.260
这一次在该国

00:16:15.500 --> 00:16:19.700
一些定义点通常在

00:16:18.260 --> 00:16:21.710
完全不同的角落

00:16:19.700 --> 00:16:26.090
系统一些配置类

00:16:21.710 --> 00:16:27.980
可能有一条光束定义了

00:16:26.090 --> 00:16:31.070
是定义光束的工厂方法

00:16:27.980 --> 00:16:33.470
键入相反的弹簧是

00:16:31.070 --> 00:16:35.570
基本上是关于建立连接

00:16:33.470 --> 00:16:37.250
当注射点说我

00:16:35.570 --> 00:16:40.670
想要在一个具体的位置或春天

00:16:37.250 --> 00:16:43.430
看着光束的集合找到匹配项

00:16:40.670 --> 00:16:46.580
按类型或帐户存储库（如果有） 

00:16:43.430 --> 00:16:49.790
如果有的话，只有一件是好的

00:16:46.580 --> 00:16:52.130
我们必须要进行的几场比赛

00:16:49.790 --> 00:16:54.770
依靠额外的元数据

00:16:52.130 --> 00:16:57.710
基本上帮助我们，我们在这里看到的

00:16:54.770 --> 00:17:01.460
我所服务的预选赛

00:16:57.710 --> 00:17:04.250
目的是您仅在以下情况下使用限定词

00:17:01.460 --> 00:17:05.900
类型匹配不是唯一的，因此帐户

00:17:04.250 --> 00:17:08.060
假设有更多存储库

00:17:05.900 --> 00:17:11.330
一场比赛或一场生产比赛

00:17:08.060 --> 00:17:13.340
在测试比赛中都注册了

00:17:11.330 --> 00:17:15.980
与容器同时

00:17:13.340 --> 00:17:17.870
您可以添加添加限定符表示法

00:17:15.980 --> 00:17:20.150
在这种情况下，使用弹簧预选赛

00:17:17.870 --> 00:17:23.390
生产到您上面的注射点

00:17:20.150 --> 00:17:25.100
您可以将相同的限定词添加到

00:17:23.390 --> 00:17:25.580
下面的定义点，所以工厂

00:17:25.100 --> 00:17:27.860
方法

00:17:25.580 --> 00:17:30.200
春天将立即没有任何

00:17:27.860 --> 00:17:33.440
进一步的设置会消耗掉额外的

00:17:30.200 --> 00:17:35.270
连接件时的信息

00:17:33.440 --> 00:17:37.220
在这里，所以它会说好的帐户

00:17:35.270 --> 00:17:38.930
它是存储库

00:17:37.220 --> 00:17:40.880
好，我们有合格的产品

00:17:38.930 --> 00:17:43.370
有一个与之匹配的帐户存储库

00:17:40.880 --> 00:17:46.010
也有合格的产品，所以那些

00:17:43.370 --> 00:17:48.980
显然一起去注入

00:17:46.010 --> 00:17:50.990
正是那个，那就是

00:17:48.980 --> 00:17:52.760
符合类型匹配时使用的条件

00:17:50.990 --> 00:17:54.320
不是唯一的，我们要重新审视

00:17:52.760 --> 00:17:55.780
春天来了

00:17:54.320 --> 00:17:58.630
透视

00:17:55.780 --> 00:18:01.419
最后但并非最不重要的一点

00:17:58.630 --> 00:18:03.880
最先进的NBC巡回演出控制器

00:18:01.419 --> 00:18:06.370
而且我不会谈论太多

00:18:03.880 --> 00:18:09.010
我想NBC会控制自己

00:18:06.370 --> 00:18:10.380
你们大多数人都熟悉他们

00:18:09.010 --> 00:18:13.090
从设计的角度来看他们

00:18:10.380 --> 00:18:15.130
他们在上面有一个刻板印象

00:18:13.090 --> 00:18:19.030
控制器它有很多方法

00:18:15.130 --> 00:18:20.650
方法级映射注释NBC 

00:18:19.030 --> 00:18:25.030
控制器基本上是一个端点

00:18:20.650 --> 00:18:28.000
他们定义基于HTTP端点的模型

00:18:25.030 --> 00:18:29.860
传入的HTTP请求被映射

00:18:28.000 --> 00:18:32.289
端点方法

00:18:29.860 --> 00:18:36.730
 3D特此请求管道注释

00:18:32.289 --> 00:18:38.289
我们使用的路径另外使用

00:18:36.730 --> 00:18:39.520
参数签名在这里，所以

00:18:38.289 --> 00:18:42.730
参数签名可能很漂亮

00:18:39.520 --> 00:18:46.000
对于我们发现的每种此类方法都很重要

00:18:42.730 --> 00:18:47.820
 book方法的ID很长， 

00:18:46.000 --> 00:18:51.130
本身并不意味着什么

00:18:47.820 --> 00:18:52.750
如果您记得源代码的可读性

00:18:51.130 --> 00:18:54.820
看一个长的主意，这是什么

00:18:52.750 --> 00:18:59.409
对，没有魔力法则

00:18:54.820 --> 00:19:01.690
如此容易，我们使用参数

00:18:59.409 --> 00:19:04.450
级别注释通常用于指示

00:19:01.690 --> 00:19:07.539
这在我们中是什么样的参数

00:19:04.450 --> 00:19:09.789
在这里，我们说长ID是ADD 

00:19:07.539 --> 00:19:11.980
路径变量，它是参数级别

00:19:09.789 --> 00:19:14.049
注释是否有几个

00:19:11.980 --> 00:19:16.380
每个方法的参数

00:19:14.049 --> 00:19:19.000
参数可能有自己的注释

00:19:16.380 --> 00:19:21.429
或通常每个

00:19:19.000 --> 00:19:22.179
在这种情况下，我们说它是一个

00:19:21.429 --> 00:19:24.580
路径变量

00:19:22.179 --> 00:19:26.350
此参数引用此方法

00:19:24.580 --> 00:19:27.940
这里的参数指的是路径

00:19:26.350 --> 00:19:30.460
公交车部分可变

00:19:27.940 --> 00:19:33.460
在其中定义了一个ID变量

00:19:30.460 --> 00:19:35.260
路径映射就是我们所说的

00:19:33.460 --> 00:19:38.409
可以是这些路径变量中的几个

00:19:35.260 --> 00:19:40.360
所以我们依靠参数名称来

00:19:38.409 --> 00:19:43.090
通过名称指向特定变量

00:19:40.360 --> 00:19:44.559
我们会自动将其转换为long 

00:19:43.090 --> 00:19:47.320
因为我们可以从

00:19:44.559 --> 00:19:48.820
签名，这是关于

00:19:47.320 --> 00:19:50.500
源代码的可读性源代码

00:19:48.820 --> 00:19:52.750
基本上应该说出它在做什么

00:19:50.500 --> 00:19:54.700
甚至对于那些

00:19:52.750 --> 00:19:56.860
对复杂的事物不那么熟悉

00:19:54.700 --> 00:19:59.490
的细节和随机行为

00:19:56.860 --> 00:20:01.570
源自相同注解的课程

00:19:59.490 --> 00:20:04.419
注释春天，今年春天

00:20:01.570 --> 00:20:06.580
调度程序servlet擅长于

00:20:04.419 --> 00:20:07.929
基本上要求介绍规格

00:20:06.580 --> 00:20:08.960
通讯所有参数

00:20:07.929 --> 00:20:11.250
注释和公正

00:20:08.960 --> 00:20:16.200
根据一个说法，这是正确的事情

00:20:11.250 --> 00:20:19.110
一组规则这里有一个具体说明

00:20:16.200 --> 00:20:20.610
我们已经探讨过的ID参数

00:20:19.110 --> 00:20:22.590
它的名称是相关的，可能有

00:20:20.610 --> 00:20:23.120
他们匹配的几个路径变量

00:20:22.590 --> 00:20:26.670
名称

00:20:23.120 --> 00:20:29.100
但是在标准Java中没有

00:20:26.670 --> 00:20:31.470
参数名称的表示形式

00:20:29.100 --> 00:20:35.060
方法的字节码

00:20:31.470 --> 00:20:38.940
参数和构造函数参数

00:20:35.060 --> 00:20:40.950
这些参数的名称位于

00:20:38.940 --> 00:20:43.080
 Java文件中的源代码，但是

00:20:40.950 --> 00:20:44.970
编译时不保留

00:20:43.080 --> 00:20:47.250
向下到字节码中的字节码

00:20:44.970 --> 00:20:51.330
只是类型的索引

00:20:47.250 --> 00:20:56.400
参数在JDK 6中没有名称，并且

00:20:51.330 --> 00:20:58.350
七，我们在Springfree上的工作

00:20:56.400 --> 00:21:01.380
春季3以及春季

00:20:58.350 --> 00:21:03.420
继续执行DQ 6和7，如果没有

00:21:01.380 --> 00:21:05.790
鉴于我们需要的更多信息

00:21:03.420 --> 00:21:07.800
知道那个名字，所以如果你不知道

00:21:05.790 --> 00:21:09.570
明确保存路径名称

00:21:07.800 --> 00:21:12.450
如果您可以在路径上执行此操作

00:21:09.570 --> 00:21:14.490
您可以使用变量和属性ID 

00:21:12.450 --> 00:21:16.680
可以这样帮助我们，但是你

00:21:14.490 --> 00:21:19.800
重复自己，我们不希望你

00:21:16.680 --> 00:21:21.840
再说一遍，所以这就是我们在这里看到的

00:21:19.800 --> 00:21:24.530
实际上是首选，但是我们需要

00:21:21.840 --> 00:21:27.000
在运行时了解名称

00:21:24.530 --> 00:21:30.210
只要您编译

00:21:27.000 --> 00:21:33.210
破折号调试编译器的类

00:21:30.210 --> 00:21:35.550
标志然后编译器基本上插入

00:21:33.210 --> 00:21:38.190
在调试符号中调试部分

00:21:35.550 --> 00:21:40.980
部分到您的类文件中

00:21:38.190 --> 00:21:42.780
碰巧包含用于的参数

00:21:40.980 --> 00:21:44.910
所有具有

00:21:42.780 --> 00:21:46.860
身体所以不是很严格和界面

00:21:44.910 --> 00:21:49.410
方法，但有四种方法

00:21:46.860 --> 00:21:52.470
我们所需的实施任务

00:21:49.410 --> 00:21:54.120
在这里，我们基本上阅读了调试符号

00:21:52.470 --> 00:21:56.370
使用ASM与

00:21:54.120 --> 00:21:58.920
调试单个部分，我们将其缓存

00:21:56.370 --> 00:22:01.020
当然，然后我们可以推断

00:21:58.920 --> 00:22:05.250
从那里的参数名称

00:22:01.020 --> 00:22:07.440
我们可以在JDK 6上做到最好

00:22:05.250 --> 00:22:10.880
将以zip方式重新访问

00:22:07.440 --> 00:22:15.280
您可能已经猜到了

00:22:10.880 --> 00:22:18.500
从照片上可以看到的春天是

00:22:15.280 --> 00:22:22.010
基本上是试图提高

00:22:18.500 --> 00:22:23.840
基线，我们将只解释一下

00:22:22.010 --> 00:22:27.530
片刻之后这实际上意味着什么

00:22:23.840 --> 00:22:29.060
但它也从根本上改善了

00:22:27.530 --> 00:22:31.370
春季业力三要素模型

00:22:29.060 --> 00:22:34.310
并将其实际提升到一个新的水平

00:22:31.370 --> 00:22:36.440
从许多细微的细节

00:22:34.310 --> 00:22:40.580
成分瓶的观点很多

00:22:36.440 --> 00:22:43.160
关于重新访问运行时和行为

00:22:40.580 --> 00:22:46.610
该程序的组件模型非常

00:22:43.160 --> 00:22:48.800
您曾经在其中工作过的很多东西

00:22:46.610 --> 00:22:50.870
 Spring Framework 3在这里，如果存在的话

00:22:48.800 --> 00:22:52.640
 Spring Framework 3次

00:22:50.870 --> 00:22:55.190
现有的Spring框架的三大诀窍

00:22:52.640 --> 00:22:57.590
可以前进，然后从

00:22:55.190 --> 00:23:00.020
在我们对其进行完善之前

00:22:57.590 --> 00:23:02.360
对其进行微调

00:23:00.020 --> 00:23:05.660
我们将其升级到7月8日

00:23:02.360 --> 00:23:09.490
在开始之前先水平

00:23:05.660 --> 00:23:11.930
定义基线我们在这里是什么意思

00:23:09.490 --> 00:23:13.760
从根本上讲电影四

00:23:11.930 --> 00:23:18.080
定义了框架的生成

00:23:13.760 --> 00:23:20.510
满足2014年及以后的需求

00:23:18.080 --> 00:23:24.740
这基本上是一个非常

00:23:20.510 --> 00:23:27.710
我们的前瞻性观点

00:23:24.740 --> 00:23:29.270
在这里申请我们接受申请

00:23:27.710 --> 00:23:31.580
正在使用的架构

00:23:29.270 --> 00:23:34.250
现在正在开发中

00:23:31.580 --> 00:23:35.750
现在不一定是你的

00:23:34.250 --> 00:23:36.590
基于传统的应用服务器

00:23:35.750 --> 00:23:38.810
建筑

00:23:36.590 --> 00:23:41.300
这是关于嵌入式Web服务的

00:23:38.810 --> 00:23:43.010
用一个自举程序

00:23:41.300 --> 00:23:45.710
嵌入式Web服务器是关于交谈

00:23:43.010 --> 00:23:47.690
非关系数据存储或其他

00:23:45.710 --> 00:23:50.420
各种非传统数据存储

00:23:47.690 --> 00:23:53.660
关于轻量级消息传递

00:23:50.420 --> 00:23:55.610
来自相当沉重的企业

00:23:53.660 --> 00:23:57.590
消息传递的集成风格

00:23:55.610 --> 00:23:59.210
那已经很普遍了

00:23:57.590 --> 00:24:00.830
 WebSockets文件通讯

00:23:59.210 --> 00:24:03.110
客户与

00:24:00.830 --> 00:24:05.720
服务器或服务器的不同部分

00:24:03.110 --> 00:24:08.230
系统，它通常是关于

00:24:05.720 --> 00:24:11.660
异步处理基本上关于

00:24:08.230 --> 00:24:13.700
编写应用程序的方式

00:24:11.660 --> 00:24:16.010
让您尽最大可能

00:24:13.700 --> 00:24:19.130
您拥有的处理能力

00:24:16.010 --> 00:24:21.380
在运行时可用，但如果您有

00:24:19.130 --> 00:24:23.810
您最好定义的多核计算机

00:24:21.380 --> 00:24:26.330
您的系统，所以要好好利用

00:24:23.810 --> 00:24:28.460
这些核心，但并非总是如此

00:24:26.330 --> 00:24:29.890
 Web应用程序容易泛滥成灾

00:24:28.460 --> 00:24:31.910
对于其他类型的应用

00:24:29.890 --> 00:24:33.620
应该，但是有很多种

00:24:31.910 --> 00:24:35.180
有很多种类的应用

00:24:33.620 --> 00:24:39.230
真正成为现实的系统

00:24:35.180 --> 00:24:41.780
挑战这里的想法来自

00:24:39.230 --> 00:24:45.260
我们在编程模型方面的观点

00:24:41.780 --> 00:24:47.150
没有做任何真正不可思议的事情，我们不是

00:24:45.260 --> 00:24:49.580
试图把你的代码，并

00:24:47.150 --> 00:24:52.760
以一种奇妙的方式解释它

00:24:49.580 --> 00:24:55.880
多核架构，我们允许您

00:24:52.760 --> 00:24:58.160
定义一个应用程序架构

00:24:55.880 --> 00:25:01.430
您的选择和框架基本上

00:24:58.160 --> 00:25:05.450
支持您应对挑战

00:25:01.430 --> 00:25:08.270
在构建系统的过程中

00:25:05.450 --> 00:25:12.350
那些情况下的

00:25:08.270 --> 00:25:14.840
通常，您相当明确地使用

00:25:12.350 --> 00:25:16.820
除了声明何时要去

00:25:14.840 --> 00:25:19.880
您显式构建的异步

00:25:16.820 --> 00:25:22.549
消息传递端点春季帮助您

00:25:19.880 --> 00:25:25.470
在干净方便的地方做到这一点

00:25:22.549 --> 00:25:29.080
不一致的方式

00:25:25.470 --> 00:25:32.260
我们将基准术语也解释为

00:25:29.080 --> 00:25:34.960
作为依存基准，从春季开始

00:25:32.260 --> 00:25:38.080
从文件夹（虽然是JDK 6 plus） 

00:25:34.960 --> 00:25:39.730
 Java SE 6 plus实际上甚至是

00:25:38.080 --> 00:25:43.930
甚至比我们多一点

00:25:39.730 --> 00:25:46.690
需要JDK 6 update 18作为API级别

00:25:43.930 --> 00:25:52.000
或以后，当然就像

00:25:46.690 --> 00:25:55.060
将JDK 6的2010年基准升级到

00:25:52.000 --> 00:25:58.780
包括exp 1.4和规范1至2 

00:25:55.060 --> 00:26:00.610
 IBM世界中发生的例子

00:25:58.780 --> 00:26:04.240
大约在同一时间，所以我们需要死

00:26:00.610 --> 00:26:07.870
至少从2010年初开始的API级别

00:26:04.240 --> 00:26:09.370
当然，JDK 7的依赖关系

00:26:07.870 --> 00:26:12.310
在这里的中心作用是

00:26:09.370 --> 00:26:16.570
主流的JDK那个spring框架

00:26:12.310 --> 00:26:18.880
预计最初将与我们一起使用

00:26:16.570 --> 00:26:21.610
也将基线提高到Java EE 6 

00:26:18.880 --> 00:26:23.230
另外，作为指导原则，它是关于

00:26:21.610 --> 00:26:26.980
关于个别规格

00:26:23.230 --> 00:26:30.460
这里不是关于v6作为平台级别的

00:26:26.980 --> 00:26:31.950
我们是否要求JPA给捐助者

00:26:30.460 --> 00:26:34.890
例

00:26:31.950 --> 00:26:37.460
我们还专注于服务器3，尽管两者

00:26:34.890 --> 00:26:40.680
它们是物理学的核心部分

00:26:37.460 --> 00:26:43.320
但是服务器3虽然我们在技术上

00:26:40.680 --> 00:26:45.810
只需要考虑发展，所以

00:26:43.320 --> 00:26:48.660
如果您想使用我们的模拟游戏

00:26:45.810 --> 00:26:50.040
一些东西，我们的几个

00:26:48.660 --> 00:26:52.800
 dpi标记，那么您必须先打开

00:26:50.040 --> 00:26:54.750
服务器3在那里部署

00:26:52.800 --> 00:26:57.170
时间我们送达5 

00:26:54.750 --> 00:27:00.060
兼容，只要您不使用

00:26:57.170 --> 00:27:03.480
实际的服务器3或功能

00:27:00.060 --> 00:27:04.830
幸运的是很容易识别

00:27:03.480 --> 00:27:06.690
只要您不使用Web应用程序

00:27:04.830 --> 00:27:09.030
您正在初始化或异步处理

00:27:06.690 --> 00:27:11.760
即使您的

00:27:09.030 --> 00:27:12.420
目标环境是为此的回路

00:27:11.760 --> 00:27:16.020
 5个容器

00:27:12.420 --> 00:27:18.780
非常明确地定义为

00:27:16.020 --> 00:27:20.820
方式，因为我们了解

00:27:18.780 --> 00:27:22.320
大量现有的运行时环境

00:27:20.820 --> 00:27:26.550
用服务器将大小容器取出来

00:27:22.320 --> 00:27:29.100
 Java 6上可以使用JP 800 

00:27:26.550 --> 00:27:32.190
碰到最安全的就是我们

00:27:29.100 --> 00:27:34.530
仍然想与我们兼容

00:27:32.190 --> 00:27:36.870
删除所有已弃用的机会

00:27:34.530 --> 00:27:38.610
包大多数

00:27:36.870 --> 00:27:41.400
复制了很长时间很久

00:27:38.610 --> 00:27:44.250
我们删除不应令人惊讶

00:27:41.400 --> 00:27:45.920
许多不推荐使用的方法以及

00:27:44.250 --> 00:27:48.630
它们保留，以防有人检查

00:27:45.920 --> 00:27:51.540
其中一些仍然存在，因为我们

00:27:48.630 --> 00:27:52.980
务实的我们了解到

00:27:51.540 --> 00:27:55.110
有预编译的第三方

00:27:52.980 --> 00:27:57.120
图书馆在和一些人聊天

00:27:55.110 --> 00:27:59.370
不推荐使用的方法

00:27:57.120 --> 00:28:01.790
我们保留其中一些方式

00:27:59.370 --> 00:28:05.310
如果我们知道有

00:28:01.790 --> 00:28:05.700
常用的预编译库

00:28:05.310 --> 00:28:08.520
那里

00:28:05.700 --> 00:28:10.880
他们不能轻易改变，我们不得不

00:28:08.520 --> 00:28:13.200
在某些情况下，我们会做出一些妥协

00:28:10.880 --> 00:28:15.440
升级我们投资组合中的其他项目

00:28:13.200 --> 00:28:17.880
与专业人士的弹簧兼容

00:28:15.440 --> 00:28:22.140
但在大多数情况下，您可以使用现有的

00:28:17.880 --> 00:28:23.580
您习惯的版本

00:28:22.140 --> 00:28:25.530
现有的Spring安全版本

00:28:23.580 --> 00:28:27.360
这个例子仍然适用于春季

00:28:25.530 --> 00:28:29.600
从文件夹，虽然不必

00:28:27.360 --> 00:28:34.429
立即升级

00:28:29.600 --> 00:28:36.500
春季当然是重点

00:28:34.429 --> 00:28:38.900
生成框架是我们的Java时代

00:28:36.500 --> 00:28:43.059
故事我们将基准提高到JDK六

00:28:38.900 --> 00:28:45.950
另外，我们以JDK 7为主流

00:28:43.059 --> 00:28:48.700
 JDK级别，但是最多

00:28:45.950 --> 00:28:51.530
有趣的部分来自JDK 

00:28:48.700 --> 00:28:55.640
观点当然是Java 8和

00:28:51.530 --> 00:28:57.460
 Spring Framework迫使人们成为一种

00:28:55.640 --> 00:29:00.740
 Java 8世界的好公民

00:28:57.460 --> 00:29:03.500
关于Java 8语言功能

00:29:00.740 --> 00:29:06.980
关于Java 8 API功能，它与

00:29:03.500 --> 00:29:09.650
与JDK 8的运行时兼容性是如此

00:29:06.980 --> 00:29:11.299
在某种程度上独立于

00:29:09.650 --> 00:29:14.299
语言功能当然是

00:29:11.299 --> 00:29:16.429
数据可能是我们最有趣的卡片

00:29:14.299 --> 00:29:18.919
将该表达式命名为

00:29:16.429 --> 00:29:22.460
对Java来说真的很不错

00:29:18.919 --> 00:29:24.650
我希望这是非常语言

00:29:22.460 --> 00:29:27.409
在不久的将来常用

00:29:24.650 --> 00:29:29.480
真的很好用

00:29:27.409 --> 00:29:32.419
案例，也非常适合

00:29:29.480 --> 00:29:34.909
 Springs API 5，我们将在

00:29:32.419 --> 00:29:37.580
片刻的方法引用很亲切

00:29:34.909 --> 00:29:41.169
的lambda表达式的变体

00:29:37.580 --> 00:29:41.169
 lambda表达式被编译为

00:29:41.230 --> 00:29:45.409
在此演示中，我们

00:29:43.730 --> 00:29:49.039
只专注于一些

00:29:45.409 --> 00:29:50.840
 Javaid空间中的选定功能

00:29:49.039 --> 00:29:53.330
如果您想了解更多信息，请点击这里

00:29:50.840 --> 00:29:55.580
我们已经在做Java 8 

00:29:53.330 --> 00:29:58.549
我们将要进行的定向演示

00:29:55.580 --> 00:29:59.900
彼此面向的网络研讨会

00:29:58.549 --> 00:30:02.270
在不久的将来，我们将潜水

00:29:59.900 --> 00:30:04.970
更深一点，但对于

00:30:02.270 --> 00:30:07.850
今天的目的让我们只专注于

00:30:04.970 --> 00:30:10.010
最重要的好处

00:30:07.850 --> 00:30:11.929
因此，我将向您展示

00:30:10.010 --> 00:30:14.780
使用lambda表达式

00:30:11.929 --> 00:30:17.210
再谈一下JSF 3/10的过时时间

00:30:14.780 --> 00:30:20.210
更多细节快速提及可重复

00:30:17.210 --> 00:30:23.360
注释我们可以用spring做些什么

00:30:20.210 --> 00:30:25.250
注释来支持它，让我

00:30:23.360 --> 00:30:26.960
在此也提及参数名称

00:30:25.250 --> 00:30:30.169
我们一直在谈论的发现

00:30:26.960 --> 00:30:32.390
能力之前的参数名称

00:30:30.169 --> 00:30:36.260
框架看起来为读取参数名称

00:30:32.390 --> 00:30:39.620
方法或构造函数以及

00:30:36.260 --> 00:30:42.020
从Java 8开始的应用程序类

00:30:39.620 --> 00:30:42.530
实际上是一流的Java 8功能

00:30:42.020 --> 00:30:45.800
来了

00:30:42.530 --> 00:30:50.000
 -参数编译器标志，允许

00:30:45.800 --> 00:30:52.670
您宁愿指示宽容

00:30:50.000 --> 00:30:56.420
编译器包含参数main 

00:30:52.670 --> 00:30:59.770
类文件中的部分

00:30:56.420 --> 00:31:02.750
本节基本上带有

00:30:59.770 --> 00:31:04.910
反射API支持，因此我们可以使用

00:31:02.750 --> 00:31:08.060
标准API读取参数名称

00:31:04.910 --> 00:31:09.770
从此类中，您确实需要指定

00:31:08.060 --> 00:31:11.720
该标志，所以它不会发生

00:31:09.770 --> 00:31:14.060
默认，但这是一流的功能

00:31:11.720 --> 00:31:16.340
您不必切换到调试

00:31:14.060 --> 00:31:20.030
您可以说的符号-参数

00:31:16.340 --> 00:31:21.680
就是这样，我们当然也支持

00:31:20.030 --> 00:31:23.570
您可以立即调试符号

00:31:21.680 --> 00:31:26.690
编译华丽的错误会编译

00:31:23.570 --> 00:31:28.430
两者都可以工作

00:31:26.690 --> 00:31:31.490
但无论如何都会有

00:31:28.430 --> 00:31:34.460
对此功能的一流支持

00:31:31.490 --> 00:31:37.370
 Java 8很棒，因为基本上

00:31:34.460 --> 00:31:41.360
使我们对依靠感到更好

00:31:37.370 --> 00:31:42.650
这在我们的编程模型中

00:31:41.360 --> 00:31:44.720
我们程序最干净的版本

00:31:42.650 --> 00:31:47.570
我们在技术上不依赖它的模型

00:31:44.720 --> 00:31:50.540
我们是重复自己并避免的方法

00:31:47.570 --> 00:31:53.120
提到的整洁，但仍然

00:31:50.540 --> 00:31:54.830
这是我们没有的一个很好的推动者

00:31:53.120 --> 00:31:57.320
使用ASM不必阅读课

00:31:54.830 --> 00:31:59.720
文件了，而JDK 

00:31:57.320 --> 00:32:04.400
本身使我们能够首先做到这一点

00:31:59.720 --> 00:32:06.140
类功能正确，所以我们要

00:32:04.400 --> 00:32:08.390
马上看几个例子

00:32:06.140 --> 00:32:10.810
但让我借此机会

00:32:08.390 --> 00:32:13.720
指出关于CDA的另一种观点

00:32:10.810 --> 00:32:16.610
这是关于

00:32:13.720 --> 00:32:17.590
现有应用程序部署到

00:32:16.610 --> 00:32:22.220
切诺基

00:32:17.590 --> 00:32:24.110
想象一下现在还不行的时候

00:32:22.220 --> 00:32:27.230
但想像在半年的时间里

00:32:24.110 --> 00:32:29.480
一年的时间JDK 8将会出现在

00:32:27.230 --> 00:32:31.190
某种形式的部署环境

00:32:29.480 --> 00:32:33.590
一些平台即服务一些云

00:32:31.190 --> 00:32:36.050
平台和一些数据中心实习生

00:32:33.590 --> 00:32:38.030
部署

00:32:36.050 --> 00:32:41.810
为之编译的现有应用程序

00:32:38.030 --> 00:32:43.970
 TDC 6或7-基于独特的e8 

00:32:41.810 --> 00:32:46.190
部署平台，我们真的不是

00:32:43.970 --> 00:32:48.680
依靠很多没有陀螺

00:32:46.190 --> 00:32:51.680
一种不使用的语言

00:32:48.680 --> 00:32:54.920
他们字节码或类似的东西

00:32:51.680 --> 00:32:56.510
与反射兼容

00:32:54.920 --> 00:32:58.850
行为

00:32:56.510 --> 00:33:00.920
只是一般的标准

00:32:58.850 --> 00:33:04.160
 GDK库中的实现

00:33:00.920 --> 00:33:06.850
这不完全是微不足道的，但是我们做到了

00:33:04.160 --> 00:33:09.110
实际花一些时间进行微调

00:33:06.850 --> 00:33:11.360
春天作为支持这一点的框架

00:33:09.110 --> 00:33:14.420
即使在

00:33:11.360 --> 00:33:15.980
小小的黑暗角落，因此

00:33:14.420 --> 00:33:17.750
现有的基于Spring的应用程序和

00:33:15.980 --> 00:33:20.050
部署到裁定平台

00:33:17.750 --> 00:33:22.850
也许是因为您想从中受益

00:33:20.050 --> 00:33:24.680
从G中的虚拟机增强功能

00:33:22.850 --> 00:33:26.500
十年中实际上有很多

00:33:24.680 --> 00:33:28.970
特别是内存管理

00:33:26.500 --> 00:33:31.790
可能有足够的理由

00:33:28.970 --> 00:33:33.980
部署专用于无

00:33:31.790 --> 00:33:36.920
不得不切换到Java 8 

00:33:33.980 --> 00:33:38.600
语言特点

00:33:36.920 --> 00:33:41.450
的场景被正式支持为

00:33:38.600 --> 00:33:43.790
从我们这边来的春天

00:33:41.450 --> 00:33:45.830
食物虽然主要在某种程度上

00:33:43.790 --> 00:33:48.650
还有最新的Spring框架

00:33:45.830 --> 00:33:51.700
通过现有的两个版本

00:33:48.650 --> 00:33:55.390
在孩子身上运行的应用程序

00:33:51.700 --> 00:34:00.490
好吧，让我们来看看语言

00:33:55.390 --> 00:34:03.130
特色贷款人是中央

00:34:00.490 --> 00:34:05.830
 Java语言实际上是一种

00:34:03.130 --> 00:34:09.370
闭包，但它们的lambda表达式

00:34:05.830 --> 00:34:11.950
它们是提供一个

00:34:09.370 --> 00:34:17.260
回调接口的实现

00:34:11.950 --> 00:34:19.470
从根本上说，整个背后的想法

00:34:17.260 --> 00:34:21.880
 lambda表达式是编译器

00:34:19.470 --> 00:34:24.100
是编译器功能，因此

00:34:21.880 --> 00:34:26.679
编译器实际上处理它们

00:34:24.100 --> 00:34:28.390
编译器内省lambda 

00:34:26.679 --> 00:34:31.000
表达式被应用了

00:34:28.390 --> 00:34:33.060
自动将其强制转换为

00:34:31.000 --> 00:34:35.140
回调接口的实现

00:34:33.060 --> 00:34:37.000
所以必须有那些规则

00:34:35.140 --> 00:34:39.960
拍手，他们必须

00:34:37.000 --> 00:34:42.520
基本上是单一方法接口

00:34:39.960 --> 00:34:46.540
在Java中称为功能接口

00:34:42.520 --> 00:34:50.200
春季幸运地使用了术语

00:34:46.540 --> 00:34:53.350
 api，您会发现许多这样的

00:34:50.200 --> 00:34:55.390
接口考虑JDBC模板

00:34:53.350 --> 00:34:57.190
已准备好连接回调

00:34:55.390 --> 00:35:00.310
罗马曾经发表过的声明

00:34:57.190 --> 00:35:03.400
提取器都是天然的

00:35:00.310 --> 00:35:05.890
功能接口Java 8 lambda 

00:35:03.400 --> 00:35:09.820
基本上从惯例上表达

00:35:05.890 --> 00:35:12.160
可以非常适用于那些春季ApS 

00:35:09.820 --> 00:35:14.940
很自然，实际上没有

00:35:12.160 --> 00:35:18.070
改变春天的api自己

00:35:14.940 --> 00:35:21.550
那些春季AP在很多情况下都过时了

00:35:18.070 --> 00:35:23.590
回到2004年和2005年

00:35:21.550 --> 00:35:25.270
时间甚至十年后

00:35:23.590 --> 00:35:26.710
爪哇八的自然公民

00:35:25.270 --> 00:35:29.320
语言惯例

00:35:26.710 --> 00:35:31.330
很高兴从外面看到春天

00:35:29.320 --> 00:35:33.730
框架必须做很多

00:35:31.330 --> 00:35:35.860
启用Java八件事

00:35:33.730 --> 00:35:37.830
语言功能的一般使用

00:35:35.860 --> 00:35:40.900
 1/8字节码级别，依此类推

00:35:37.830 --> 00:35:44.260
但是就API设计而言， 

00:35:40.900 --> 00:35:46.330
很自然，因此与JDBC有关

00:35:44.260 --> 00:35:48.520
模板GMS模板有很多

00:35:46.330 --> 00:35:49.930
这样的大接口，我们甚至有

00:35:48.520 --> 00:35:52.270
具有以下内容的交易模板

00:35:49.930 --> 00:35:54.850
我们拥有的事务回调接口

00:35:52.270 --> 00:35:57.880
任务主管与任务计划程序

00:35:54.850 --> 00:35:59.800
传递了可运行和可调用的参数

00:35:57.880 --> 00:36:02.500
再有一种叫做大的方法

00:35:59.800 --> 00:36:04.059
接口太多了

00:36:02.500 --> 00:36:05.650
发现

00:36:04.059 --> 00:36:07.150
让我们专注于两个基本模板

00:36:05.650 --> 00:36:08.619
因为我们将在

00:36:07.150 --> 00:36:11.259
短短的例子

00:36:08.619 --> 00:36:12.939
典型的JDBC模板调用可能是

00:36:11.259 --> 00:36:16.329
让我们这样做

00:36:12.939 --> 00:36:18.999
一个典型的GBC模板调用看起来

00:36:16.329 --> 00:36:21.309
像这样，这里唯一不寻常的部分是

00:36:18.999 --> 00:36:22.920
使用lambda表达式，但是

00:36:21.309 --> 00:36:27.219
从根本上说，这是正常的

00:36:22.920 --> 00:36:29.890
 JDBC模板查询调用查询

00:36:27.219 --> 00:36:30.269
这里使用的方法是一种

00:36:29.890 --> 00:36:32.979
串

00:36:30.269 --> 00:36:33.609
续集字符串准备好的语句

00:36:32.979 --> 00:36:37.119
二传手

00:36:33.609 --> 00:36:39.249
和角色映射器，我们看到了两个调用

00:36:37.119 --> 00:36:40.930
基本相同的通话，不同的

00:36:39.249 --> 00:36:43.900
源代码布局基本上是相同的

00:36:40.930 --> 00:36:46.630
用不同的层重复调用

00:36:43.900 --> 00:36:49.630
第一行是字符串参数

00:36:46.630 --> 00:36:51.849
续集声明第二个

00:36:49.630 --> 00:36:53.469
逗号后的第二个参数是

00:36:51.849 --> 00:36:55.660
准备好的语句集参数是

00:36:53.469 --> 00:36:59.229
不寻常的部分，我们有一个lambda 

00:36:55.660 --> 00:37:01.119
此处针对API指定的表达式

00:36:59.229 --> 00:37:04.559
期望准备好的语句设置器

00:37:01.119 --> 00:37:06.999
第三个论点基本上是

00:37:04.559 --> 00:37:10.989
与Roma Bahn Limited相匹配

00:37:06.999 --> 00:37:12.400
春天，所以我们把琴弦浇在

00:37:10.989 --> 00:37:14.949
准备好的语句设置器传入

00:37:12.400 --> 00:37:16.890
他们准备牛排的香气/面食和

00:37:14.949 --> 00:37:18.880
设置器，让我们切换一下

00:37:16.890 --> 00:37:21.029
准备好的声明说有一个

00:37:18.880 --> 00:37:23.679
回调方法名称无关

00:37:21.029 --> 00:37:26.140
设置无论如何准备的值

00:37:23.679 --> 00:37:27.309
声明很重要，所以

00:37:26.140 --> 00:37:29.170
这是一个同事界面

00:37:27.309 --> 00:37:31.269
准备进来的流程

00:37:29.170 --> 00:37:34.089
语句基本上可以设置任何数字

00:37:31.269 --> 00:37:36.429
参数，而这正是

00:37:34.089 --> 00:37:40.329
我们的lambda表达式在这里做PS 

00:37:36.429 --> 00:37:42.849
 PS部分指的是错误之前的部分

00:37:40.329 --> 00:37:44.349
到准备好的语句参数

00:37:42.849 --> 00:37:46.209
也可以用您声明的类型

00:37:44.349 --> 00:37:47.949
可以说准备好的声明PS，但您

00:37:46.209 --> 00:37:52.150
不必，您可以缩短它的显示时间

00:37:47.949 --> 00:37:55.029
在右侧，我们有TD 

00:37:52.150 --> 00:37:57.009
表达上或多或少的家庭

00:37:55.029 --> 00:37:58.719
样式，因此它不是完整的Java语句

00:37:57.009 --> 00:38:01.269
这是一种表达风格

00:37:58.719 --> 00:38:03.309
执行一组Java语句

00:38:01.269 --> 00:38:06.729
称为PR的字符串设置单个字符串

00:38:03.309 --> 00:38:09.190
关于该传入对象的声明

00:38:06.729 --> 00:38:11.890
基本上是准备好的陈述

00:38:09.190 --> 00:38:14.980
准备语句设置器方法正文

00:38:11.890 --> 00:38:16.240
你会在精神上

00:38:14.980 --> 00:38:18.190
我可能会想到

00:38:16.240 --> 00:38:20.829
可以传递匿名的内部类

00:38:18.190 --> 00:38:22.300
这是我准备的新的陈述莎拉

00:38:20.829 --> 00:38:24.190
实现设定值方法

00:38:22.300 --> 00:38:26.020
准备好的陈述出现在

00:38:24.190 --> 00:38:29.050
方法主体，我说的是PS该字符串

00:38:26.020 --> 00:38:32.339
作为一种心理模型

00:38:29.050 --> 00:38:35.140
好的，这基本上是一种捷径

00:38:32.339 --> 00:38:37.480
而不是实现匿名内部

00:38:35.140 --> 00:38:39.430
有很多像嘴巴和

00:38:37.480 --> 00:38:41.560
实际的方法签名

00:38:39.430 --> 00:38:43.780
有趣的代码，我们专注于

00:38:41.560 --> 00:38:47.560
我们只在这里指定有趣的代码

00:38:43.780 --> 00:38:49.540
方法主体就是这样

00:38:47.560 --> 00:38:52.390
下一行中的角色映射器

00:38:49.540 --> 00:38:55.150
 RS Realm在线罗马位于，但在我们的幻灯片上

00:38:52.390 --> 00:38:58.119
之前已产生RS介绍

00:38:55.150 --> 00:39:00.310
进来，它实际上返回

00:38:58.119 --> 00:39:03.359
地图对象Metro返回地图对象

00:39:00.310 --> 00:39:06.819
对于结果集中的每个角色，以及

00:39:03.359 --> 00:39:09.369
这就是我们没有lambda的情况

00:39:06.819 --> 00:39:11.859
表达式在这里RS滚动进来

00:39:09.369 --> 00:39:14.890
这里有两个参数

00:39:11.859 --> 00:39:17.170
按名称，所以我们可以说RS中的结果

00:39:14.890 --> 00:39:19.359
程序，但我们不必输入名称

00:39:17.170 --> 00:39:22.030
足够并且在右边

00:39:19.359 --> 00:39:24.880
方面，我们有一个lambda表达式

00:39:22.030 --> 00:39:27.819
说好吧，我们基本上建立了一个新的

00:39:24.880 --> 00:39:30.760
人称对象，我们称其为散射

00:39:27.819 --> 00:39:32.680
和RS进入那可能就像名字

00:39:30.760 --> 00:39:35.619
和年龄，我们将它们传递给人

00:39:32.680 --> 00:39:37.450
构建接受它们，我们返回

00:39:35.619 --> 00:39:38.920
他们，所以我们看不到回报

00:39:37.450 --> 00:39:41.200
声明在这里，但有一个隐含的

00:39:38.920 --> 00:39:43.119
在这里返回声明，因为地铁

00:39:41.200 --> 00:39:46.020
期望返回一个对象， 

00:39:43.119 --> 00:39:48.339
此表达式求值为一个对象

00:39:46.020 --> 00:39:50.890
所以基本上是最短的

00:39:48.339 --> 00:39:54.270
 JDBC模板调用的可能版本

00:39:50.890 --> 00:39:56.319
使用两个lambda表达式

00:39:54.270 --> 00:39:58.839
我个人觉得特别

00:39:56.319 --> 00:40:00.910
有趣的考虑它的例子

00:39:58.839 --> 00:40:02.560
多个长度表达式

00:40:00.910 --> 00:40:03.790
 lambda而不是即将来临的匿名

00:40:02.560 --> 00:40:06.520
在课堂里

00:40:03.790 --> 00:40:08.349
一开始就足够了，但是如果

00:40:06.520 --> 00:40:10.869
 Lambda表达式的力量真正表明

00:40:08.349 --> 00:40:14.710
当您接听一些电话时

00:40:10.869 --> 00:40:16.260
回调接口，如我们的示例

00:40:14.710 --> 00:40:19.150
这里

00:40:16.260 --> 00:40:21.369
下半部的第二个例子

00:40:19.150 --> 00:40:24.750
幻灯片基本上与上面相同

00:40:21.369 --> 00:40:27.490
但采用更传统的格式

00:40:24.750 --> 00:40:30.430
它使用了lambda的变体

00:40:27.490 --> 00:40:33.160
指向正则表达式

00:40:30.430 --> 00:40:35.770
 Java代码块更像常规Java 

00:40:33.160 --> 00:40:38.339
方法主体，您可能会这么认为

00:40:35.770 --> 00:40:41.309
 PS是其中的上一步

00:40:38.339 --> 00:40:44.710
有一个常规的Java代码块

00:40:41.309 --> 00:40:47.470
括号内的PS设置字符串调用

00:40:44.710 --> 00:40:49.480
它以分号结尾可能

00:40:47.470 --> 00:40:51.609
其中的几个这样的段是一个代码

00:40:49.480 --> 00:40:54.520
在常规的Java代码处进行阻止

00:40:51.609 --> 00:40:57.700
必须符合标准的Java代码

00:40:54.520 --> 00:41:00.300
阻止规则，这就是为什么

00:40:57.700 --> 00:41:04.390
分号等必须存在

00:41:00.300 --> 00:41:07.809
第二名贷款人RS rona成员

00:41:04.390 --> 00:41:09.490
针对行成员，如果再次出现在

00:41:07.809 --> 00:41:11.349
第二个例子是常规的Java代码

00:41:09.490 --> 00:41:14.079
阻止，所以它可能不止一个

00:41:11.349 --> 00:41:16.000
里面的声明，因为它是一个

00:41:14.079 --> 00:41:18.550
常规的Java代码块，它必须有一个

00:41:16.000 --> 00:41:22.809
您在这里看到的return语句和

00:41:18.550 --> 00:41:25.180
最后的分号是

00:41:22.809 --> 00:41:28.299
 Lambda表达式真的可以做什么

00:41:25.180 --> 00:41:31.210
你和你的代码，他们基本上是

00:41:28.299 --> 00:41:33.040
提供实现的方式

00:41:31.210 --> 00:41:35.319
同事界面编译器

00:41:33.040 --> 00:41:37.299
评估您的lambda表达式

00:41:35.319 --> 00:41:40.270
针对你的目标点

00:41:37.299 --> 00:41:44.049
应用它们，以便知道它们

00:41:40.270 --> 00:41:45.670
进入右侧，可以看到对GBC的呼叫

00:41:44.049 --> 00:41:49.059
模板非常方法，它知道

00:41:45.670 --> 00:41:50.799
目标地图的签名，然后

00:41:49.059 --> 00:41:53.349
将它们弯曲成的实现

00:41:50.799 --> 00:41:55.450
这些korvac接口在运行时

00:41:53.349 --> 00:41:58.809
 lambdas实际上被编译为方法

00:41:55.450 --> 00:42:02.230
参考-像合成私人

00:41:58.809 --> 00:42:04.390
包含类中的方法是

00:42:02.230 --> 00:42:06.220
实际上是一种非常有效的方法

00:42:04.390 --> 00:42:07.720
代表他们甚至

00:42:06.220 --> 00:42:10.480
比匿名更有效

00:42:07.720 --> 00:42:12.160
类将是但从概念上讲

00:42:10.480 --> 00:42:14.799
真的有助于他们善待自己

00:42:12.160 --> 00:42:16.599
一种实现

00:42:14.799 --> 00:42:18.190
在课堂上是匿名的，即使那是

00:42:16.599 --> 00:42:21.339
不完全是在运行时发生的情况

00:42:18.190 --> 00:42:22.809
我发现它在概念上很有用

00:42:21.339 --> 00:42:25.900
如果你看第二个例子

00:42:22.809 --> 00:42:28.059
下面看起来真的有点相似

00:42:25.900 --> 00:42:30.430
匿名内部类，让我们只是

00:42:28.059 --> 00:42:31.719
知道那只是没有上课的技术人员

00:42:30.430 --> 00:42:35.140
常规方法的方法签名

00:42:31.719 --> 00:42:36.960
哥们，离一个不远

00:42:35.140 --> 00:42:39.940
匿名内部阶级安排

00:42:36.960 --> 00:42:42.460
但是它适合这张幻灯片，我们

00:42:39.940 --> 00:42:44.979
有两个带有两个lambda的示例

00:42:42.460 --> 00:42:47.140
一张幻灯片上的表达式

00:42:44.979 --> 00:42:48.579
真的说一切都尝试过

00:42:47.140 --> 00:42:51.299
匿名内部类将用于

00:42:48.579 --> 00:42:54.009
在幻灯片上的课程中匿名

00:42:51.299 --> 00:42:55.809
所以这是lambda，这几乎是

00:42:54.009 --> 00:42:57.549
 Lambda的完整定义是

00:42:55.809 --> 00:43:00.460
 Lambda表达式基本上是做什么的

00:42:57.549 --> 00:43:02.920
我们几乎没有更多的东西了

00:43:00.460 --> 00:43:05.170
解释说我认为我们甚至涵盖了所有

00:43:02.920 --> 00:43:07.420
成员的变体或常规变体

00:43:05.170 --> 00:43:10.269
这不是一个特别复杂的功能

00:43:07.420 --> 00:43:12.249
如果您花费半小时或一个小时

00:43:10.269 --> 00:43:16.509
和他们一起尝试与他们一起玩

00:43:12.249 --> 00:43:19.119
例如IntelliJ IDEA中的IDE 

00:43:16.509 --> 00:43:21.519
即使在

00:43:19.119 --> 00:43:23.200
这一点你会发现他们真的

00:43:21.519 --> 00:43:25.719
真的非常有用，方便而且非常

00:43:23.200 --> 00:43:27.400
如果你尝试一个小时自然

00:43:25.719 --> 00:43:29.710
他们会觉得很自然

00:43:27.400 --> 00:43:31.869
规则很简单

00:43:29.710 --> 00:43:34.059
即使您想了解也很简单

00:43:31.869 --> 00:43:35.890
在运行时会发生什么

00:43:34.059 --> 00:43:38.049
根本上是一个简单的功能

00:43:35.890 --> 00:43:40.420
 Java的create补充

00:43:38.049 --> 00:43:42.549
自约定以来的语言

00:43:40.420 --> 00:43:44.710
可以与现有的api和

00:43:42.549 --> 00:43:46.839
库，只要您的运行时

00:43:44.710 --> 00:43:49.749
环境通常能够

00:43:46.839 --> 00:43:51.999
使用基于Java的八个代码

00:43:49.749 --> 00:43:55.150
因为您只能将其与

00:43:51.999 --> 00:43:58.239
源1或8级别，表示目标

00:43:55.150 --> 00:44:00.880
 1/8级，表示1.8个字节码

00:43:58.239 --> 00:44:03.759
只要您的班级文件中的格式

00:44:00.880 --> 00:44:06.249
您的运行时框架能够

00:44:03.759 --> 00:44:08.440
了解和使用1/8 

00:44:06.249 --> 00:44:11.619
字节码级别可供您使用

00:44:08.440 --> 00:44:14.229
现在记得JDK 8已发布

00:44:11.619 --> 00:44:18.190
截至本周的候选模式

00:44:14.229 --> 00:44:22.029
最近发布的开放式JDK 8 build 124 

00:44:18.190 --> 00:44:24.670
是发布候选版本

00:44:22.029 --> 00:44:27.309
一般可用性一般

00:44:24.670 --> 00:44:29.920
上市日期迟到

00:44:27.309 --> 00:44:31.839
三月，所以如果您愿意的话，距离不远

00:44:29.920 --> 00:44:34.779
开始一个新的开发项目

00:44:31.839 --> 00:44:35.290
现在考虑启动它甚至JDK 8 

00:44:34.779 --> 00:44:37.960
在

00:44:35.290 --> 00:44:40.510
这一点Spring框架4是

00:44:37.960 --> 00:44:42.070
基本上旨在为您提供支持

00:44:40.510 --> 00:44:43.750
从您开发的这一点开始

00:44:42.070 --> 00:44:45.850
努力，这就是为什么我们这么早

00:44:43.750 --> 00:44:49.930
支持Java可能不是

00:44:45.850 --> 00:44:52.420
打算部署到晚些时候

00:44:49.930 --> 00:44:54.850
 2014年甚至2015年，你知道的

00:44:52.420 --> 00:44:58.660
已经因为没有理由不

00:44:54.850 --> 00:44:59.920
考虑如果这样的项目偏离

00:44:58.660 --> 00:45:04.000
你知道它将可用

00:44:59.920 --> 00:45:05.650
明年生产给您

00:45:04.000 --> 00:45:08.020
对于八的未来来说太重要了

00:45:05.650 --> 00:45:11.680
快速考虑其他

00:45:08.020 --> 00:45:15.910
 GDK的八个基本功能是Joseph 

00:45:11.680 --> 00:45:20.430
 310日期和时间，基本上是一种

00:45:15.910 --> 00:45:22.900
一个孩子的继任者

00:45:20.430 --> 00:45:26.760
重新实现相同的概念

00:45:22.900 --> 00:45:29.440
还有哪一次不完全是

00:45:26.760 --> 00:45:31.750
如果你看的话就一样

00:45:29.440 --> 00:45:34.630
在某些情况下它的细节

00:45:31.750 --> 00:45:36.070
与明显不同

00:45:34.630 --> 00:45:39.190
一些安排和一些

00:45:36.070 --> 00:45:42.430
惯例，但起初至少是

00:45:39.190 --> 00:45:45.670
但它们与中央非常相似

00:45:42.430 --> 00:45:48.940
约瑟夫310的一部分具有新价值

00:45:45.670 --> 00:45:52.030
输入本地日期，本地日期时间等

00:45:48.940 --> 00:45:54.460
第四种物理表达价值类型

00:45:52.030 --> 00:45:57.760
用于您的域模型或

00:45:54.460 --> 00:45:59.560
您的值类型并替换java.util 

00:45:57.760 --> 00:46:02.140
他们从根本上还是java.util 

00:45:59.560 --> 00:46:03.760
日历，如果你真的有

00:46:02.140 --> 00:46:06.850
代表他们的唯一标准方法

00:46:03.760 --> 00:46:09.040
在此之前，您具有标准的表现力

00:46:06.850 --> 00:46:11.740
值类型（如果只是日期） 

00:46:09.040 --> 00:46:14.100
如果没有时间，请使用本地日期

00:46:11.740 --> 00:46:16.780
看是否是日期输入时间

00:46:14.100 --> 00:46:18.460
规范使用本地停滞时间

00:46:16.780 --> 00:46:22.270
只是一天之内的时间使用本地

00:46:18.460 --> 00:46:24.670
时间，如果是为该日期和时间定义的

00:46:22.270 --> 00:46:27.190
一个非常特定的时区使用声音

00:46:24.670 --> 00:46:29.020
日期/时间，因此对于任何此类情况

00:46:27.190 --> 00:46:31.300
有相应的场地类型

00:46:29.020 --> 00:46:34.690
那是正确的表示

00:46:31.300 --> 00:46:38.590
您的价值和价值含义

00:46:34.690 --> 00:46:39.910
在您的域模型中

00:46:38.590 --> 00:46:40.300
进入我们所关注的核心

00:46:39.910 --> 00:46:41.790
在做

00:46:40.300 --> 00:46:45.880
建立建筑领域模型

00:46:41.790 --> 00:46:48.430
表示弹簧中的数据类型

00:46:45.880 --> 00:46:49.210
观点，我们支持使用a310 

00:46:48.430 --> 00:46:51.190
格式

00:46:49.210 --> 00:46:54.580
以及具有约束力的框架，特别是

00:46:51.190 --> 00:46:56.170
进行某种程度的转换，但

00:46:54.580 --> 00:46:58.870
最重要的部分是格式化和

00:46:56.170 --> 00:47:01.540
考虑在白天绑定Springs 

00:46:58.870 --> 00:47:03.490
格式注释已经存在

00:47:01.540 --> 00:47:05.920
从春天开始，您可以注释

00:47:03.490 --> 00:47:09.580
领域，并说像这样是解析

00:47:05.920 --> 00:47:11.500
并为该值渲染模式

00:47:09.580 --> 00:47:13.240
最初被设计用于

00:47:11.500 --> 00:47:14.560
像旅行一样约会字段

00:47:13.240 --> 00:47:17.260
否则不会真的说他们

00:47:14.560 --> 00:47:18.550
这样的模式才是真正的

00:47:17.260 --> 00:47:20.740
将它们变成东西的唯一方法

00:47:18.550 --> 00:47:26.380
知道你在通过什么

00:47:20.740 --> 00:47:28.420
从约瑟夫记3:10 

00:47:26.380 --> 00:47:30.550
暂时支持您可以申请的数据

00:47:28.420 --> 00:47:32.620
一个非常具体的自定义解析， 

00:47:30.550 --> 00:47:35.470
呈现模式作为一种默认设置

00:47:32.620 --> 00:47:37.720
字符串传递公约

00:47:35.470 --> 00:47:39.610
该字段或该字段为

00:47:37.720 --> 00:47:42.790
呈现出某种文本

00:47:39.610 --> 00:47:45.250
基于HTML或JSON的表示形式

00:47:42.790 --> 00:47:47.490
或任何文字形式的

00:47:45.250 --> 00:47:50.770
数据是否有用

00:47:47.490 --> 00:47:53.920
但是服务器却很有趣

00:47:50.770 --> 00:47:56.710
细节是值类型现在是

00:47:53.920 --> 00:47:59.680
表现力足以使我们能够

00:47:56.710 --> 00:48:01.870
更积极地默认这里看

00:47:59.680 --> 00:48:04.090
出生上方的本地日期字段

00:48:01.870 --> 00:48:07.090
 date字段是一种日期时间格式

00:48:04.090 --> 00:48:09.730
注释被注释掉，因为它是

00:48:07.090 --> 00:48:11.530
基本上是默认行为，如果您

00:48:09.730 --> 00:48:13.690
不要在此处指定任何日期/时间形式

00:48:11.530 --> 00:48:15.160
 Springs绑定和格式化框架

00:48:13.690 --> 00:48:18.670
看值类型说

00:48:15.160 --> 00:48:20.740
当地日期说是日期，所以我们

00:48:18.670 --> 00:48:22.720
使用iOS L数据表示法更新

00:48:20.740 --> 00:48:25.900
我们刚刚支付的时间，因为设置了本地日期

00:48:22.720 --> 00:48:28.690
所以我们可以更明确地默认

00:48:25.900 --> 00:48:31.210
如果没有，我们使用的约定

00:48:28.690 --> 00:48:35.830
 Java给出了特定的约定

00:48:31.210 --> 00:48:37.960
 util date，那是不可能的，所以

00:48:35.830 --> 00:48:40.930
这真是Geni Kate的好东西

00:48:37.960 --> 00:48:43.900
从根本上说这是一个API功能，但是

00:48:40.930 --> 00:48:46.900
这是一个重要的API 

00:48:43.900 --> 00:48:49.240
真正的好处来自约瑟夫

00:48:46.900 --> 00:48:51.790
在这里要显示一次

00:48:49.240 --> 00:48:53.950
主流框架就像它们

00:48:51.790 --> 00:48:55.930
应用程序框架Web框架

00:48:53.950 --> 00:48:58.420
绑定框架持久性

00:48:55.930 --> 00:49:01.540
一旦他们都了解框架

00:48:58.420 --> 00:49:03.040
默认是310 

00:49:01.540 --> 00:49:06.430
展现力量

00:49:03.040 --> 00:49:09.670
的状态和时间值类型

00:49:06.430 --> 00:49:11.080
同时我们也支持Joe的设计

00:49:09.670 --> 00:49:13.480
当然我们一直在支持另外两个

00:49:11.080 --> 00:49:15.790
春天的三倍哦，我们仍然

00:49:13.480 --> 00:49:17.490
在春季，尽管我们需要两个

00:49:15.790 --> 00:49:20.050
现在其他时间到该区域，所以我们甚至

00:49:17.490 --> 00:49:21.370
它实际上已经改进并扩展到

00:49:20.050 --> 00:49:24.070
附带的其他时间支持

00:49:21.370 --> 00:49:26.530
春天的形式，所以如果您使用的是JDK 6和

00:49:24.070 --> 00:49:28.210
特别是七个考虑使用

00:49:26.530 --> 00:49:30.580
幼稚的时间，它将看起来非常相似

00:49:28.210 --> 00:49:32.890
到您在这里看到的只是使用

00:49:30.580 --> 00:49:36.460
 Childre时间输入，但输入的名称

00:49:32.890 --> 00:49:38.710
许多类型在很多情况下都是相同的

00:49:36.460 --> 00:49:40.630
弹簧容纳API 

00:49:38.710 --> 00:49:42.550
您可以在许多方面使用差异

00:49:40.630 --> 00:49:45.670
基准格式，因此您可以

00:49:42.550 --> 00:49:47.830
彼此相似的经历

00:49:45.670 --> 00:49:50.710
在JDK 6和7上，但是如果您在

00:49:47.830 --> 00:49:53.910
 GD 8然后一定要考虑

00:49:50.710 --> 00:49:53.910
标准Java时间类型

00:49:54.280 --> 00:50:00.140
好吧

00:49:57.020 --> 00:50:03.290
关于可重复注释的快速注释

00:50:00.140 --> 00:50:05.720
上面的例子是你可以做的

00:50:03.290 --> 00:50:08.300
现在在Java 8上添加spring ik 4 

00:50:05.720 --> 00:50:10.490
预定重复两次

00:50:08.300 --> 00:50:13.540
相同方法的不同共轭物

00:50:10.490 --> 00:50:16.880
对于JDK 6和7，这是不可能的，因为

00:50:13.540 --> 00:50:21.080
 JDK 8的注释

00:50:16.880 --> 00:50:24.230
据此宣布上述作品

00:50:21.080 --> 00:50:26.240
编译器会接受就好了，我们

00:50:24.230 --> 00:50:29.000
必须声明我们适用

00:50:26.240 --> 00:50:30.680
现在以可重复的形式注释

00:50:29.000 --> 00:50:33.320
那是我们从卷曲开始做的春天

00:50:30.680 --> 00:50:36.349
所以按计划然后和其他几个

00:50:33.320 --> 00:50:40.010
在春天基本上是注释

00:50:36.349 --> 00:50:43.099
语义上可以充分重复

00:50:40.010 --> 00:50:46.070
现在必须重复可重复

00:50:43.099 --> 00:50:49.790
 Java 8兼容表单（如果您使用） 

00:50:46.070 --> 00:50:52.430
您可以使用JDK 6和7的语法如下

00:50:49.790 --> 00:50:55.160
因此它包含按计划注释

00:50:52.430 --> 00:50:56.720
对于其他父亲的创新

00:50:55.160 --> 00:50:59.060
总是不同的容器注释

00:50:56.720 --> 00:51:01.520
那是你可以做的最好的事情，直到你得到

00:50:59.060 --> 00:51:03.890
 6和7当然也可以

00:51:01.520 --> 00:51:07.310
弹簧框架，但如果您运行JDK 8 

00:51:03.890 --> 00:51:09.200
绝对受益于更多

00:51:07.310 --> 00:51:13.180
更自然更自然

00:51:09.200 --> 00:51:13.180
上面更具可读性的版本

00:51:15.340 --> 00:51:20.650
对于Java 8来说非常正确

00:51:18.430 --> 00:51:23.020
向您展示其他一些重要的春季

00:51:20.650 --> 00:51:24.430
容器功能的框架

00:51:23.020 --> 00:51:26.860
只是一个快速导览，给您一个

00:51:24.430 --> 00:51:29.170
可以跟进的印象

00:51:26.860 --> 00:51:31.210
有很多细节有待发现

00:51:29.170 --> 00:51:34.720
在我们最近的参考文档中

00:51:31.210 --> 00:51:37.990
博客帖子等等很重要

00:51:34.720 --> 00:51:41.910
重点是在常规上

00:51:37.990 --> 00:51:45.790
这里的结果之一是

00:51:41.910 --> 00:51:48.780
定义格式，这是DSL的常规

00:51:45.790 --> 00:51:51.400
定义Spring bean的基于脚本

00:51:48.780 --> 00:51:54.820
它基本上类似于spring XML 

00:51:51.400 --> 00:51:56.500
外部的bean定义

00:51:54.820 --> 00:51:59.070
定义格式说像院长

00:51:56.500 --> 00:52:01.630
名称和类型以及传入的属性

00:51:59.070 --> 00:52:05.140
它甚至支持XML名称空间

00:52:01.630 --> 00:52:05.980
解析这种格式不是新来的

00:52:05.140 --> 00:52:08.130
来自Grails 

00:52:05.980 --> 00:52:10.780
它被称为Grails中的bean建筑

00:52:08.130 --> 00:52:13.360
我们称其为基于查询的定义

00:52:10.780 --> 00:52:15.460
春季热力4它基本上在移动

00:52:13.360 --> 00:52:18.430
从盲文到核心框架

00:52:15.460 --> 00:52:20.500
从下一代Grails开始

00:52:18.430 --> 00:52:22.600
谷物也会从那里消耗掉

00:52:20.500 --> 00:52:25.090
所以有一个地方

00:52:22.600 --> 00:52:27.340
系统维护，但是

00:52:25.090 --> 00:52:29.680
可供任何人立即使用

00:52:27.340 --> 00:52:31.150
一种基于弹簧的应用程序

00:52:29.680 --> 00:52:34.180
一种基于弹簧的应用程序

00:52:31.150 --> 00:52:35.560
架构定义格式

00:52:34.180 --> 00:52:37.240
本身很强大有一些

00:52:35.560 --> 00:52:39.280
因为它是非常好的元素

00:52:37.240 --> 00:52:40.780
从根本上讲，您可以做一个普通的脚本

00:52:39.280 --> 00:52:43.450
您可以随心所欲地做任何事情

00:52:40.780 --> 00:52:46.330
可以在上面导入通用类

00:52:43.450 --> 00:52:49.150
在下面使用条件语句

00:52:46.330 --> 00:52:53.200
真的很好，只是动态性更强

00:52:49.150 --> 00:52:56.160
那么灵活，然后是相当严格的XML 

00:52:53.200 --> 00:52:57.780
模式形式，但这是基础

00:52:56.160 --> 00:53:00.680
这是相同的配置

00:52:57.780 --> 00:53:03.869
用其他语言表达的风格

00:53:00.680 --> 00:53:06.180
同时groobie支持

00:53:03.869 --> 00:53:10.440
实际上，我们的意图与常规无关

00:53:06.180 --> 00:53:13.440
只是为了快速而已

00:53:10.440 --> 00:53:15.210
正确的想法考虑实施

00:53:13.440 --> 00:53:17.700
整个基于Spring的应用程序

00:53:15.210 --> 00:53:20.970
使用Ruby的Java无点Java 

00:53:17.700 --> 00:53:22.799
一直使用Ruby的文件

00:53:20.970 --> 00:53:24.240
定期实施弹簧组件

00:53:22.799 --> 00:53:25.770
带弹簧的弹簧组件

00:53:24.240 --> 00:53:27.780
刻板的限制弹簧

00:53:25.770 --> 00:53:29.039
配置类的一切

00:53:27.780 --> 00:53:30.390
您已经习惯了我们所拥有的一切

00:53:29.039 --> 00:53:32.579
一直在展示最新技术

00:53:30.390 --> 00:53:34.349
部分，然后才能使用

00:53:32.579 --> 00:53:37.319
提供Scooby支持所有这些

00:53:34.349 --> 00:53:41.569
实际上是Java语言元素

00:53:37.319 --> 00:53:41.569
尝试做起来真是太好了

00:53:41.830 --> 00:53:46.330
就像没有任何淋浴事实

00:53:43.510 --> 00:53:48.420
你可以走得很远，这是一个

00:53:46.330 --> 00:53:51.640
我们正式支持的使用模式

00:53:48.420 --> 00:53:54.580
但是在实践中，如果您只想

00:53:51.640 --> 00:53:55.810
有选择地使用自旋

00:53:54.580 --> 00:53:57.760
定义格式如下所示

00:53:55.810 --> 00:53:59.800
良好的起点可能是

00:53:57.760 --> 00:54:02.830
实现一些类也许只是

00:53:59.800 --> 00:54:05.500
您的groovy您的MVC控制器

00:54:02.830 --> 00:54:07.360
有很多方法可以整合一些

00:54:05.500 --> 00:54:12.160
将groovy应用于基于春季的

00:54:07.360 --> 00:54:15.130
除了bean之外的应用程序

00:54:12.160 --> 00:54:16.690
我们关心的定义格式

00:54:15.130 --> 00:54:19.720
细微的细节在这里，所以有很多

00:54:16.690 --> 00:54:22.720
调整我们正在或愿意做的

00:54:19.720 --> 00:54:24.130
自然支持

00:54:22.720 --> 00:54:31.020
时髦是一流的

00:54:24.130 --> 00:54:31.020
世界右翼的春天的市民

00:54:31.050 --> 00:54:35.670
穿着我们以前看到的

00:54:33.570 --> 00:54:38.220
配置文件是一种简单的

00:54:35.670 --> 00:54:39.570
选择特定手段的条件

00:54:38.220 --> 00:54:43.080
要在

00:54:39.570 --> 00:54:45.990
容器，我们有一个完整的反映

00:54:43.080 --> 00:54:47.520
从ik 4春季发布的版本

00:54:45.990 --> 00:54:49.440
现在称为条件模型

00:54:47.520 --> 00:54:51.720
字面上带有条件接口

00:54:49.440 --> 00:54:54.840
条件上下文进入，然后添加

00:54:51.720 --> 00:54:56.850
条件注释基本上可以说

00:54:54.840 --> 00:54:59.550
添加条件，然后实施

00:54:56.850 --> 00:55:01.470
程序性条件

00:54:59.550 --> 00:55:03.900
允许的回调

00:55:01.470 --> 00:55:07.410
评估是否再次注册

00:55:03.900 --> 00:55:09.600
注释在运行时有丰富

00:55:07.410 --> 00:55:11.610
上下文进入您可以做出反应

00:55:09.600 --> 00:55:13.740
现有光束定义的存在

00:55:11.610 --> 00:55:15.510
特定类型的基础架构

00:55:13.740 --> 00:55:19.740
连锁店，所以它是一个非常动态的

00:55:15.510 --> 00:55:22.530
模型和配置文件现在只是一个

00:55:19.740 --> 00:55:24.900
这种条件的执行

00:55:22.530 --> 00:55:26.850
字面条件和弹簧

00:55:24.900 --> 00:55:31.520
在剖析符号上满足注释

00:55:26.850 --> 00:55:32.720
在条件配置文件条件下

00:55:31.520 --> 00:55:34.820
这是

00:55:32.720 --> 00:55:36.830
当然，开放模型是可扩展的

00:55:34.820 --> 00:55:38.960
您可以定义自己的条件的模型

00:55:36.830 --> 00:55:41.350
您可以定义自己的文凭样式

00:55:38.960 --> 00:55:44.900
这样你就可以走得更远

00:55:41.350 --> 00:55:47.240
以自定义的方式，但我们也在

00:55:44.900 --> 00:55:49.850
同时在我们的其中之一中利用它

00:55:47.240 --> 00:55:52.370
姐姐计划春季启动

00:55:49.850 --> 00:55:54.490
特别是如果你看着春天

00:55:52.370 --> 00:55:56.360
靴子春季靴真的

00:55:54.490 --> 00:55:59.540
展示了这种力量

00:55:56.360 --> 00:56:02.480
条件模型

00:55:59.540 --> 00:56:04.250
可以进行真正积极的违约

00:56:02.480 --> 00:56:05.510
穿你指定的东西很

00:56:04.250 --> 00:56:07.730
最小的

00:56:05.510 --> 00:56:09.850
查看春季食物的例子

00:56:07.730 --> 00:56:12.380
例如我是NBC控制器

00:56:09.850 --> 00:56:14.540
 groovy实现，您只提供

00:56:12.380 --> 00:56:16.010
控制器没别的，你

00:56:14.540 --> 00:56:18.680
使用嵌入式Web服务器引导它

00:56:16.010 --> 00:56:20.930
几乎没有任何设置

00:56:18.680 --> 00:56:23.330
真正明智而激进的违约

00:56:20.930 --> 00:56:25.310
继续在这里，它基于

00:56:23.330 --> 00:56:26.840
来自不良状态模型，因此

00:56:25.310 --> 00:56:28.310
肯定检查洒不是

00:56:26.840 --> 00:56:32.210
本演讲的重点，但这是

00:56:28.310 --> 00:56:33.980
很好的跟进我们提供了链接

00:56:32.210 --> 00:56:36.140
到我们的新网站那里有 spring boot 

00:56:33.980 --> 00:56:38.510
在Umbridge主页上一定要检查一下

00:56:36.140 --> 00:56:41.030
它出来了，尽管我们的C1这很奇怪

00:56:38.510 --> 00:56:43.450
一周的春天建成100我们的C1是

00:56:41.030 --> 00:56:43.450
有空

00:56:43.880 --> 00:56:49.630
好吧，让我们回到注释

00:56:47.190 --> 00:56:52.359
模特片刻

00:56:49.630 --> 00:56:54.400
一个微妙但重要的新功能

00:56:52.359 --> 00:56:57.069
 spring框架是关于使用

00:56:54.400 --> 00:57:00.579
可组合中的注释属性

00:56:57.069 --> 00:57:02.529
您当然可以撰写模型

00:57:00.579 --> 00:57:04.359
自定义范围注释或自定义

00:57:02.529 --> 00:57:07.420
之前的交易注释

00:57:04.359 --> 00:57:09.309
完全有可能在春季3 

00:57:07.420 --> 00:57:12.430
可以使用属性的属性

00:57:09.309 --> 00:57:14.109
您可以将属性声明为我的

00:57:12.430 --> 00:57:17.799
上面的会话范围注释

00:57:14.109 --> 00:57:19.420
声明近端属性代理模式

00:57:17.799 --> 00:57:21.700
当然是指接近

00:57:19.420 --> 00:57:24.190
春季标准前警察的属性

00:57:21.700 --> 00:57:28.420
注释中有一个代理模式

00:57:24.190 --> 00:57:30.309
设置在那里，按照惯例，如果它是

00:57:28.420 --> 00:57:33.940
同名同名属性

00:57:30.309 --> 00:57:36.220
它指的是相同的属性

00:57:33.940 --> 00:57:37.930
元符号，因此没有其他

00:57:36.220 --> 00:57:40.180
您必须声明一组

00:57:37.930 --> 00:57:42.789
与您同名的边缘

00:57:40.180 --> 00:57:45.849
允许使用您的自定义注释

00:57:42.789 --> 00:57:49.029
指定代理模式，这是一个很好的选择

00:57:45.849 --> 00:57:51.430
设计元素，如果您

00:57:49.029 --> 00:57:54.339
设计像一组注释

00:57:51.430 --> 00:57:56.680
整个项目用作一种东西

00:57:54.339 --> 00:57:59.170
指导原则

00:57:56.680 --> 00:58:01.450
这一切的效果，然后此功能就可以

00:57:59.170 --> 00:58:04.440
变得非常强大，尤其是它

00:58:01.450 --> 00:58:06.670
全部是因为您不仅可以控制

00:58:04.440 --> 00:58:09.400
属性的可用性以及

00:58:06.670 --> 00:58:11.829
这种属性的默认外观

00:58:09.400 --> 00:58:14.980
在第二个示例中，我的交易

00:58:11.829 --> 00:58:17.200
在此下方有一个只读属性

00:58:14.980 --> 00:58:18.849
只读是指相同的命名

00:58:17.200 --> 00:58:21.279
春季不合格的属性a 

00:58:18.849 --> 00:58:24.160
事务注释，用作

00:58:21.279 --> 00:58:25.990
这里的转义词仅在春季读

00:58:24.160 --> 00:58:28.180
标准注释的默认值为

00:58:25.990 --> 00:58:30.339
假，所以如果您不指定它

00:58:28.180 --> 00:58:33.400
没有只读特征

00:58:30.339 --> 00:58:35.470
应用我的交易习惯

00:58:33.400 --> 00:58:38.789
我们在这里看到的注释有一个

00:58:35.470 --> 00:58:41.829
只读属性，无默认值

00:58:38.789 --> 00:58:43.690
根据Java注释规则， 

00:58:41.829 --> 00:58:47.440
表示该值必须为

00:58:43.690 --> 00:58:49.029
指定了您的我的每个用户

00:58:47.440 --> 00:58:51.519
每次交易注释

00:58:49.029 --> 00:58:54.720
用过的你需要指定只读

00:58:51.519 --> 00:58:58.630
等于true或只读等于false 

00:58:54.720 --> 00:59:00.789
这实际上是一个故意的功能

00:58:58.630 --> 00:59:03.580
在这里您可以使用它作为指导

00:59:00.789 --> 00:59:06.850
您所说的所有效果

00:59:03.580 --> 00:59:08.410
我想使用该注释进行推理

00:59:06.850 --> 00:59:10.600
关于阅读状态

00:59:08.410 --> 00:59:12.100
我希望他们明确的交易

00:59:10.600 --> 00:59:15.760
关于它思考和

00:59:12.100 --> 00:59:17.470
如果正确指定正确的标志值

00:59:15.760 --> 00:59:19.600
默认情况下，他们可能会忘记它

00:59:17.470 --> 00:59:21.280
他们没有看到正确的，所以在这里

00:59:19.600 --> 00:59:23.700
没有声明您要强制使用默认值

00:59:21.280 --> 00:59:26.230
他们考虑在指定的时间

00:59:23.700 --> 00:59:27.910
这样就超过了可写属性

00:59:26.230 --> 00:59:30.370
默认使用替代的用户适用

00:59:27.910 --> 00:59:34.020
贡献了一个非常好的补充

00:59:30.370 --> 00:59:36.970
春天的可组合注释模型

00:59:34.020 --> 00:59:40.480
让我们回顾一下模型的另一部分

00:59:36.970 --> 00:59:44.050
这是注射之间的匹配

00:59:40.480 --> 00:59:46.870
点和定义点我们所看到的

00:59:44.050 --> 00:59:49.300
以上是我们在服务之间的maipo 

00:59:46.870 --> 00:59:52.090
这个版本在这里需要我的

00:59:49.300 --> 00:59:55.420
仓库一般声明

00:59:52.090 --> 00:59:57.160
帐户，假设我的存储库是

00:59:55.420 --> 01:00:00.780
接口，并具有类型变量

00:59:57.160 --> 01:00:03.400
它管理的实体类型

01:00:00.780 --> 01:00:05.200
多年来变得很普遍，所以

01:00:03.400 --> 01:00:08.830
我们最近经常看到

01:00:05.200 --> 01:00:11.220
我们自己的 spring data 系统项目有

01:00:08.830 --> 01:00:14.760
像这样的存储库模型

01:00:11.220 --> 01:00:17.110
因此，对于这种模型，通常

01:00:14.760 --> 01:00:18.820
的多种实现

01:00:17.110 --> 01:00:21.790
系统中的存储库接口

01:00:18.820 --> 01:00:23.680
同时注册，因此如果

01:00:21.790 --> 01:00:26.440
注射点说我要在我的

01:00:23.680 --> 01:00:29.430
帐户存储什么

01:00:26.440 --> 01:00:31.750
容器所做的一切

01:00:29.430 --> 01:00:34.800
按主要类型匹配，所以我所有

01:00:31.750 --> 01:00:38.410
存储库，然后尝试查找

01:00:34.800 --> 01:00:41.590
一种泛型，全泛型

01:00:38.410 --> 01:00:43.990
类型声明实际上匹配，所以它

01:00:41.590 --> 01:00:46.570
说像我的存储库中是

01:00:43.990 --> 01:00:49.930
特别是一般的

01:00:46.570 --> 01:00:52.980
声明为帐户，如果是，那是我们的

01:00:49.930 --> 01:00:55.600
如果只请求一个，则匹配

01:00:52.980 --> 01:00:57.340
如您所见，这两者都是

01:00:55.600 --> 01:00:59.380
构造函数上方的参数

01:00:57.340 --> 01:01:02.170
为我的存储库声明的参数

01:00:59.380 --> 01:01:03.820
帐户，这也是HB方法

01:01:02.170 --> 01:01:05.380
通常在其他地方找到

01:01:03.820 --> 01:01:07.750
系统的一部分，就在

01:01:05.380 --> 01:01:10.780
该方法是的配置类

01:01:07.750 --> 01:01:14.339
也为我的存储库支架声明了

01:01:10.780 --> 01:01:16.699
此处返回类型的帐户

01:01:14.339 --> 01:01:18.689
春天才能解决这个问题

01:01:16.699 --> 01:01:20.880
信息需要存储

01:01:18.689 --> 01:01:23.249
某个地方，所以它需要在

01:01:20.880 --> 01:01:25.680
方法签名如下所示

01:01:23.249 --> 01:01:28.289
需要在范围或实施上

01:01:25.680 --> 01:01:30.779
为我们实现的签名

01:01:28.289 --> 01:01:34.170
对于我的帐户来说也足够了

01:01:30.779 --> 01:01:36.630
要实现的存储库输入类

01:01:34.170 --> 01:01:39.059
我在其存储库中的支架帐户

01:01:36.630 --> 01:01:40.859
它的声明只要

01:01:39.059 --> 01:01:43.229
此特定泛型信息

01:01:40.859 --> 01:01:45.209
信息在方法中

01:01:43.229 --> 01:01:47.339
向量II方法的签名或

01:01:45.209 --> 01:01:48.989
实现类层次结构

01:01:47.339 --> 01:01:51.509
能够找到它，我们能够

01:01:48.989 --> 01:01:53.039
将其用于匹配目的，即使

01:01:51.509 --> 01:01:55.469
我的仓库有几个，所以我们

01:01:53.039 --> 01:01:57.509
总是选择正确的

01:01:55.469 --> 01:02:01.019
春季特性框架

01:01:57.509 --> 01:02:03.299
从第三幕起，第二类通用

01:02:01.019 --> 01:02:05.369
被忽略，我们只是看着

01:02:03.299 --> 01:02:07.979
我的仓库我们会说

01:02:05.369 --> 01:02:09.689
我的几个存储库与之匹配

01:02:07.979 --> 01:02:12.749
不是唯一的，您需要添加其他

01:02:09.689 --> 01:02:15.180
元数据，因此在春季三

01:02:12.749 --> 01:02:18.089
必须添加像qualify这样的限定词

01:02:15.180 --> 01:02:21.689
构造函数级别的以上帐户

01:02:18.089 --> 01:02:23.910
以及春季的管理员级别

01:02:21.689 --> 01:02:26.369
从完全的课程能力

01:02:23.910 --> 01:02:28.890
匹配通用类型结构没有这样的

01:02:26.369 --> 01:02:31.049
只要没有资格

01:02:28.890 --> 01:02:33.089
类型声明本身就是表达性的

01:02:31.049 --> 01:02:35.640
足够使它更具可读性

01:02:33.089 --> 01:02:38.609
如果您有限定词，则开始

01:02:35.640 --> 01:02:40.319
排在它旁边的那不是真的

01:02:38.609 --> 01:02:43.890
表现力强而不可读

01:02:40.319 --> 01:02:45.509
这个版本领域再次如此

01:02:43.890 --> 01:02:49.160
关于源代码的可读性，以及

01:02:45.509 --> 01:02:52.650
关于不重复自己

01:02:49.160 --> 01:02:54.870
可以继续完善

01:02:52.650 --> 01:02:57.900
我只是想快速指出他们

01:02:54.870 --> 01:02:59.460
在这里，所以他们都在我们的最新消息中

01:02:57.900 --> 01:03:01.740
部分和参考中

01:02:59.460 --> 01:03:03.180
文档，但有很多

01:03:01.740 --> 01:03:06.180
我们在集装箱领域所做的更多工作

01:03:03.180 --> 01:03:10.350
例如您可以解释注射

01:03:06.180 --> 01:03:12.600
指向懒惰，这意味着

01:03:10.350 --> 01:03:15.270
您想要一个特定的注入点

01:03:12.600 --> 01:03:17.870
您想要的惰性初始化代理

01:03:15.270 --> 01:03:21.980
代理实现您声明的类型

01:03:17.870 --> 01:03:25.710
懒惰地指的是弹簧目标梁

01:03:21.980 --> 01:03:28.020
那基本上就是你可以做的

01:03:25.710 --> 01:03:30.780
之前与所谓的提供商

01:03:28.020 --> 01:03:33.450
接口提供商帐户关闭

01:03:30.780 --> 01:03:35.340
每次都使用get方法存储库

01:03:33.450 --> 01:03:38.400
您调用以获得我们实际使用的方法

01:03:35.340 --> 01:03:39.720
从容器中抓取一个物体

01:03:38.400 --> 01:03:41.910
他们在那里

01:03:39.720 --> 01:03:44.670
可能之前有过，但是懒惰的是

01:03:41.910 --> 01:03:46.020
现在将调用代理no get方法

01:03:44.670 --> 01:03:49.130
代理实现接口

01:03:46.020 --> 01:03:52.710
通常是目标类代理，并且是

01:03:49.130 --> 01:03:55.130
对该代理的每次调用

01:03:52.710 --> 01:03:58.140
委托给实际的目标实例

01:03:55.130 --> 01:04:00.390
只有当电话打进来的时候

01:03:58.140 --> 01:04:03.600
有点像中风的代理，但这是

01:04:00.390 --> 01:04:05.880
主要用于解决更复杂的问题

01:04:03.600 --> 01:04:08.520
较大范围内的依赖安排

01:04:05.880 --> 01:04:12.030
例如，单身青少年组

01:04:08.520 --> 01:04:14.160
组件可以明确地说我想要一个

01:04:12.030 --> 01:04:16.860
提到那个光束，但我不需要

01:04:14.160 --> 01:04:19.620
立即使用它，所以我说

01:04:16.860 --> 01:04:21.870
懒惰，我只希望它在那里

01:04:19.620 --> 01:04:24.240
只要我开始就必须在那里

01:04:21.870 --> 01:04:25.830
调用方法就是这样

01:04:24.240 --> 01:04:28.320
你是说自动的时候

01:04:25.830 --> 01:04:30.510
像懒惰一样轻盈，那是一个很好的选择

01:04:28.320 --> 01:04:32.640
可能的事物的变体

01:04:30.510 --> 01:04:36.120
以前但是他们闻到句法

01:04:32.640 --> 01:04:38.440
综合性很好，那时大多数印刷机

01:04:36.120 --> 01:04:42.190
所有的变体

01:04:38.440 --> 01:04:44.260
我们也可以为注射点接受

01:04:42.190 --> 01:04:46.420
我们总是可以做到的价格和清单

01:04:44.260 --> 01:04:49.119
那是现有功能，但是

01:04:46.420 --> 01:04:51.760
现在我们可以预购

01:04:49.119 --> 01:04:54.250
使用Springs或该接口的表格，或

01:04:51.760 --> 01:04:55.440
如果目标是所有注释

01:04:54.250 --> 01:04:57.640
豆子

01:04:55.440 --> 01:04:59.650
基本上符合那些订购

01:04:57.640 --> 01:05:02.530
规则，我们在注射之前先订购它们

01:04:59.650 --> 01:05:04.420
数组列出了很好的微调权

01:05:02.530 --> 01:05:06.460
您以预览订购的形式获得它

01:05:04.420 --> 01:05:10.630
不必对它们进行排序

01:05:06.460 --> 01:05:13.210
自己和一个不错的启用功能

01:05:10.630 --> 01:05:15.190
我们也在谈论代理

01:05:13.210 --> 01:05:18.819
目标的类别代理的类型和类型

01:05:15.190 --> 01:05:21.819
您可以在春季使用类代理

01:05:18.819 --> 01:05:23.410
声明目标类代理，而无需

01:05:21.819 --> 01:05:25.960
必须提供默认值

01:05:23.410 --> 01:05:27.579
以前必须要做的构造函数

01:05:25.960 --> 01:05:29.260
用于目标类代理的

01:05:27.579 --> 01:05:31.510
您可以自由使用的界面代理

01:05:29.260 --> 01:05:33.460
除了

01:05:31.510 --> 01:05:35.680
目标目标类代理我们在哪里

01:05:33.460 --> 01:05:37.930
使用实现类

01:05:35.680 --> 01:05:39.760
本身也适用于代理实例

01:05:37.930 --> 01:05:43.119
你必须有一个默认的构造函数

01:05:39.760 --> 01:05:46.359
只是为了代理的能力

01:05:43.119 --> 01:05:50.890
使用该类作为代理类

01:05:46.359 --> 01:05:53.349
限制已经消失，现在是我们

01:05:50.890 --> 01:05:55.240
正在使用目标库

01:05:53.349 --> 01:05:57.910
创建代理实例现在跨

01:05:55.240 --> 01:06:00.460
代理实例而不调用任何实例

01:05:57.910 --> 01:06:03.039
构造函数，因为从根本上讲

01:06:00.460 --> 01:06:05.319
正确的做法是

01:06:03.039 --> 01:06:07.240
目标实例就是

01:06:05.319 --> 01:06:08.980
包含状态的瞬间

01:06:07.240 --> 01:06:12.279
构造函数所在的实例

01:06:08.980 --> 01:06:14.410
调用与代理有关

01:06:12.279 --> 01:06:17.160
类只是方法的模板

01:06:14.410 --> 01:06:19.240
签名基本上是

01:06:17.160 --> 01:06:21.130
语义上正确，不调用

01:06:19.240 --> 01:06:24.099
那里的构造函数，这就是

01:06:21.130 --> 01:06:26.380
我们现在正在做的效果之一是

01:06:24.099 --> 01:06:30.460
您可以使用任何构造函数

01:06:26.380 --> 01:06:31.960
在您的目标课程上，以便您可以使用

01:06:30.460 --> 01:06:34.480
构造函数注入

01:06:31.960 --> 01:06:35.720
不需要默认构造函数

01:06:34.480 --> 01:06:37.490
不再

01:06:35.720 --> 01:06:39.200
您

01:06:37.490 --> 01:06:41.270
在复合感叹空间中

01:06:39.200 --> 01:06:43.700
将当前可能性扩展到

01:06:41.270 --> 01:06:44.960
测试中的测试上下文注释

01:06:43.700 --> 01:06:47.660
上下文框架有几种

01:06:44.960 --> 01:06:50.300
注释实际上还有一些

01:06:47.660 --> 01:06:52.089
他们三个在这里列出，他们也可以

01:06:50.300 --> 01:06:54.970
现在以可组合形式使用

01:06:52.089 --> 01:06:58.700
使用Springs建立您的领域

01:06:54.970 --> 01:07:01.520
注释作为元注释和最后

01:06:58.700 --> 01:07:03.859
但同样重要的是

01:07:01.520 --> 01:07:06.710
进一步完善清单的时间

01:07:03.859 --> 01:07:09.290
区域管理，所以在春季

01:07:06.710 --> 01:07:13.000
现有基础架构来管理

01:07:09.290 --> 01:07:15.530
 locale本地上下文解析器

01:07:13.000 --> 01:07:19.160
春季使馆数据中已经存在

01:07:15.530 --> 01:07:21.349
较低级别的苍白上下文持有者

01:07:19.160 --> 01:07:23.510
在不同部分的框架中

01:07:21.349 --> 01:07:25.010
框架的不同部分

01:07:23.510 --> 01:07:27.490
您的应用程序可以参考

01:07:25.010 --> 01:07:29.690
本质上管理助手线程

01:07:27.490 --> 01:07:33.170
 Spring MVC将为每个

01:07:29.690 --> 01:07:36.230
要求此现有基础结构具有

01:07:33.170 --> 01:07:38.660
几乎没有扩展到时区

01:07:36.230 --> 01:07:41.089
争取a310的支持和总时间

01:07:38.660 --> 01:07:44.330
支持，使那些立即消耗

01:07:41.089 --> 01:07:46.730
这样的时区，另外

01:07:44.330 --> 01:07:48.830
为每个设置特定的语言环境

01:07:46.730 --> 01:07:51.859
要求您还可以依靠设置

01:07:48.830 --> 01:07:55.599
如果您提供特定的时区

01:07:51.859 --> 01:07:55.599
适当的规则

01:07:56.460 --> 01:08:03.070
这么多的容器精炼

01:08:00.400 --> 01:08:04.510
这一点我想扩展我们的

01:08:03.070 --> 01:08:07.869
覆盖范围向中间一点

01:08:04.510 --> 01:08:10.960
空间和一个非常重要的话题

01:08:07.869 --> 01:08:14.020
从书4春季开始的是WebSockets 

01:08:10.960 --> 01:08:17.470
我们的WebSocket支持进来了

01:08:14.020 --> 01:08:19.690
基本上有两个层次

01:08:17.470 --> 01:08:21.430
 WebSocket支持原始WebSocket支持

01:08:19.690 --> 01:08:23.950
您与框架互动的地方

01:08:21.430 --> 01:08:26.350
并在

01:08:23.950 --> 01:08:27.850
原始套接字级别，但更多

01:08:26.350 --> 01:08:30.370
在我看来，有趣的部分是

01:08:27.850 --> 01:08:34.690
我们支持更高级别的消息传递

01:08:30.370 --> 01:08:37.299
协议在最上面，所以在这一点上

01:08:34.690 --> 01:08:39.850
真的变成了面向消息的

01:08:37.299 --> 01:08:43.569
架构变成了消息传递

01:08:39.850 --> 01:08:46.210
春季我们提供的风格

01:08:43.569 --> 01:08:48.540
在这里寻找哦，原因是

01:08:46.210 --> 01:08:51.370
所有这些东西的结合

01:08:48.540 --> 01:08:53.290
具有以下功能的低级WebSocket基础结构

01:08:51.370 --> 01:08:55.900
套接字是备用选项

01:08:53.290 --> 01:08:58.900
可以使用WebSocket样式进行通讯

01:08:55.900 --> 01:09:00.850
即使是在实际网络中

01:08:58.900 --> 01:09:02.580
服务器通讯是不可能的，但是

01:09:00.850 --> 01:09:05.620
一些实时浏览器不支持

01:09:02.580 --> 01:09:08.020
有一个自然的缘故

01:09:05.620 --> 01:09:10.720
可以轻松配置的选项

01:09:08.020 --> 01:09:14.290
我们提供了基础的WebSocket 

01:09:10.720 --> 01:09:17.230
支持层我们也提供一般

01:09:14.290 --> 01:09:19.960
带有规则的消息传递模块和

01:09:17.230 --> 01:09:23.650
通用注释和类型

01:09:19.960 --> 01:09:25.540
消息传递端点支持简单

01:09:23.650 --> 01:09:27.339
消息传递协议随之而来

01:09:25.540 --> 01:09:29.739
特别是对于这个普通的树桩

01:09:27.339 --> 01:09:32.230
协议，我们也支持

01:09:29.739 --> 01:09:34.390
组合脚基本上作为

01:09:32.230 --> 01:09:37.989
 Web套接字顶部的消息传递层

01:09:34.390 --> 01:09:40.270
沟通渠道，所以这真的

01:09:37.989 --> 01:09:42.279
非常有趣的东西，因为它是

01:09:40.270 --> 01:09:44.020
完全不同的促成因素

01:09:42.279 --> 01:09:47.049
应用程序架构的

01:09:44.020 --> 01:09:49.960
面向消息传递完全不同

01:09:47.049 --> 01:09:52.690
那种沟通方式，即使你

01:09:49.960 --> 01:09:55.300
正在构建一个Web应用程序，所以我们

01:09:52.690 --> 01:09:57.730
这是春天的工作区， 

01:09:55.300 --> 01:09:59.800
付出很大的努力

01:09:57.730 --> 01:10:01.690
我的同事罗森（Rossum）的报道

01:09:59.800 --> 01:10:05.170
锁杆的条款以及是否已记录

01:10:01.690 --> 01:10:07.960
谈到他真正深入的地方

01:10:05.170 --> 01:10:10.030
设计和实际使用

01:10:07.960 --> 01:10:13.520
这里的注意事项

01:10:10.030 --> 01:10:17.300
这非常符合春天

01:10:13.520 --> 01:10:19.460
强制任务支持并发

01:10:17.300 --> 01:10:21.470
处理架构消息传递

01:10:19.460 --> 01:10:24.050
架构，但也异步

01:10:21.470 --> 01:10:26.600
在期限内进行任何形式的处理

01:10:24.050 --> 01:10:29.240
例如，我们还提供了一个异步

01:10:26.600 --> 01:10:30.770
休息模板在哪里任何调用

01:10:29.240 --> 01:10:33.950
你实际上得到了逃犯

01:10:30.770 --> 01:10:36.110
可听的未来，您不必

01:10:33.950 --> 01:10:39.410
同步等待结果

01:10:36.110 --> 01:10:41.600
进来，所以您也可以定义HTTP 

01:10:39.410 --> 01:10:44.180
异步中的方向层

01:10:41.600 --> 01:10:48.560
使用DET异步休息样式

01:10:44.180 --> 01:10:50.690
模板，但这只是一个附加

01:10:48.560 --> 01:10:54.320
请注意，我只想向您展示

01:10:50.690 --> 01:10:57.710
 WebSockets感觉如何的示例

01:10:54.320 --> 01:11:01.520
在行级别上，这是WebSockets 

01:10:57.710 --> 01:11:02.840
级别的原始WebSocket处理程序之手

01:11:01.520 --> 01:11:04.520
手头的网站界面

01:11:02.840 --> 01:11:06.320
基本上是原始的WebSocket会话

01:11:04.520 --> 01:11:08.270
 WebSocket消息进来了

01:11:06.320 --> 01:11:11.660
身体无组织，无特定

01:11:08.270 --> 01:11:14.660
协议暗示您可以在上面看到

01:11:11.660 --> 01:11:17.150
在这是一个弹簧配置类

01:11:14.660 --> 01:11:19.070
甚至配置它的特定角色

01:11:17.150 --> 01:11:21.740
 WebSocket处理程序注册

01:11:19.070 --> 01:11:24.470
处理程序对注册表并通过

01:11:21.740 --> 01:11:27.110
袜子GS额外一点

01:11:24.470 --> 01:11:29.360
甚至在那里声明

01:11:27.110 --> 01:11:31.160
苏格拉底旋涡要立即

01:11:29.360 --> 01:11:36.590
这就是您需要做的所有工作

01:11:31.160 --> 01:11:38.740
在这里使甲板成功

01:11:36.590 --> 01:11:42.760
那基本上就是在

01:11:38.740 --> 01:11:44.780
来自消息传递的原始WebSocket级别

01:11:42.760 --> 01:11:48.350
角度来看这就是你想要的

01:11:44.780 --> 01:11:52.400
通常做一个控制器和端点

01:11:48.350 --> 01:11:54.410
方法中的方法排列

01:11:52.400 --> 01:11:57.800
符合传入的级别注释

01:11:54.410 --> 01:11:59.270
针对特定方法的消息

01:11:57.800 --> 01:12:02.420
交易消息映射示例

01:11:59.270 --> 01:12:04.670
以下接受特定

01:12:02.420 --> 01:12:06.710
来自传入目的地的消息

01:12:04.670 --> 01:12:09.170
从这里的特定目的地

01:12:06.710 --> 01:12:11.720
传入消息被映射到

01:12:09.170 --> 01:12:14.480
贸易有效载荷对象已预先转换

01:12:11.720 --> 01:12:16.310
传递给方法非常类似于

01:12:14.480 --> 01:12:20.210
中的Spring MVC样式控制器

01:12:16.310 --> 01:12:22.340
特别是对Spring Web Control的

01:12:20.210 --> 01:12:25.250
工艺休息风格还可以

01:12:22.340 --> 01:12:28.400
他们在这里看起来真的很相似，但是

01:12:25.250 --> 01:12:29.960
而不是映射到特定的HTTP 

01:12:28.400 --> 01:12:32.719
我们正在映射到特定的端点

01:12:29.960 --> 01:12:35.599
此处或特定的消息目的地

01:12:32.719 --> 01:12:39.650
诸如订阅事件之类的事件

01:12:35.599 --> 01:12:42.170
在某些方法中，在九种方法中

01:12:39.650 --> 01:12:44.330
端点模式以上非常相似

01:12:42.170 --> 01:12:46.699
统计到弹簧MSE控制器

01:12:44.330 --> 01:12:49.129
您甚至可以将其与Spring MVC结合使用

01:12:46.699 --> 01:12:54.519
控制器，如果您愿意的话

01:12:49.129 --> 01:12:58.789
所以就这么快

01:12:54.519 --> 01:13:00.559
例子给你一些想法

01:12:58.789 --> 01:13:02.659
 Springs消息导向的内容

01:13:00.559 --> 01:13:03.979
体系结构模型与其有关

01:13:02.659 --> 01:13:06.829
对树桩的特殊支持

01:13:03.979 --> 01:13:08.689
 WebSockets柔和的爵士后备

01:13:06.829 --> 01:13:11.730
这是一个非常全面的安排

01:13:08.689 --> 01:13:16.820
即使在这一点上

01:13:11.730 --> 01:13:21.780
可以在上面写一些笔记

01:13:16.820 --> 01:13:23.580
这个Java EE 7的三件事我们通常

01:13:21.780 --> 01:13:25.980
支持Java EE 7级别

01:13:23.580 --> 01:13:28.380
缓冲的弹簧规格哦

01:13:25.980 --> 01:13:28.740
列出了最重要的

01:13:28.380 --> 01:13:31.910
这里

01:13:28.740 --> 01:13:35.940
与春季相关的一些

01:13:31.910 --> 01:13:38.310
 JMS-更新不是特别重要

01:13:35.940 --> 01:13:41.550
令人兴奋的是，这基本上是第一个JMS 

01:13:38.310 --> 01:13:43.410
自2002年起发布的版本

01:13:41.550 --> 01:13:45.870
 GMS想要一个出来，所以真的

01:13:43.410 --> 01:13:48.390
真的交给了你，但实际上是什么

01:13:45.870 --> 01:13:50.820
那里更可能没有明显的东西

01:13:48.390 --> 01:13:52.080
特别令人兴奋的是，如果您跑步

01:13:50.820 --> 01:13:54.570
针对提供者的梦想者

01:13:52.080 --> 01:13:57.090
 springs JMS支持自动检测到它并

01:13:54.570 --> 01:13:59.460
支持一些额外的jamester工具

01:13:57.090 --> 01:14:03.630
交货延迟等功能

01:13:59.460 --> 01:14:05.070
例如，对于GTA 1或2， 

01:14:03.630 --> 01:14:06.810
附带的注释可以是

01:14:05.070 --> 01:14:08.730
用作弹簧的替代品

01:14:06.810 --> 01:14:10.260
如果您更喜欢交易限制

01:14:08.730 --> 01:14:12.390
 Java有标准注释

01:14:10.260 --> 01:14:14.310
外在的态度，他们是自动的

01:14:12.390 --> 01:14:17.550
没有检测到由Springs检测到的特定集合

01:14:14.310 --> 01:14:21.150
最有必要使用的

01:14:17.550 --> 01:14:23.460
这些的共同之处是JPA 

01:14:21.150 --> 01:14:26.580
如果您要升级到完全

01:14:23.460 --> 01:14:27.870
 JPA给一个提供商的三个春天

01:14:26.580 --> 01:14:30.120
完整的框架

01:14:27.870 --> 01:14:32.040
 JP 81的即用型方法不是

01:14:30.120 --> 01:14:33.420
在其中生存三个

01:14:32.040 --> 01:14:36.510
现在特别在当前文件夹中

01:14:33.420 --> 01:14:39.030
 dawood一个版本，这就是我们的全部

01:14:36.510 --> 01:14:42.530
支持才是3G的真正机柜

01:14:39.030 --> 01:14:45.420
版本及其小特性

01:14:42.530 --> 01:14:47.850
通过bean验证，那一个我们

01:14:45.420 --> 01:14:49.640
也要真正挖掘到

01:14:47.850 --> 01:14:53.040
我们支持沟通交流

01:14:49.640 --> 01:14:55.260
休眠验证器5 $ 2作为其

01:14:53.040 --> 01:14:56.670
如果您考虑参考实施

01:14:55.260 --> 01:14:58.800
升级以验证5 

01:14:56.670 --> 01:15:00.930
要做的todo spring框架

01:14:58.800 --> 01:15:06.030
完整的现成报告

01:15:00.930 --> 01:15:08.190
第一次和贾莎2 3 6也值得

01:15:06.030 --> 01:15:10.980
这里的笔记有点不同

01:15:08.190 --> 01:15:13.980
某种规格，但我们在

01:15:10.980 --> 01:15:16.590
 GSR 2到6的有趣方式是

01:15:13.980 --> 01:15:18.540
 Java util的一种扩展

01:15:16.590 --> 01:15:21.030
并发执行服务模型和

01:15:18.540 --> 01:15:23.240
我们在春天做的是得到我们的

01:15:21.030 --> 01:15:25.470
标准行政服务支持

01:15:23.240 --> 01:15:27.840
基本上是我们的适配器

01:15:25.470 --> 01:15:29.850
已经为Springs Task Scheduler发货

01:15:27.840 --> 01:15:32.730
 Java上的模型和任务执行器模型

01:15:29.850 --> 01:15:34.530
如果您将其设置为犯罪

01:15:32.730 --> 01:15:36.840
自动检测它们是否

01:15:34.530 --> 01:15:39.150
与之交互的有两个

01:15:36.840 --> 01:15:42.150
三六合规行政长官

01:15:39.150 --> 01:15:44.220
服务，如果他们这样做，他们会翻译

01:15:42.150 --> 01:15:47.250
您的来电请求来电

01:15:44.220 --> 01:15:48.810
尽可能做到最好

01:15:47.250 --> 01:15:51.990
如果他们在Jase上，则是2 3 6 

01:15:48.810 --> 01:15:54.900
你指定的是什么

01:15:51.990 --> 01:15:57.360
是cron触发器，我们将其转换为

01:15:54.900 --> 01:15:58.860
追逐者二三六触发如果

01:15:57.360 --> 01:16:00.780
不可用，我们有不同的代码

01:15:58.860 --> 01:16:02.220
需要定期执行的路径

01:16:00.780 --> 01:16:05.730
服务并处理触发器

01:16:02.220 --> 01:16:07.290
手动操作，因此我们尝试与

01:16:05.730 --> 01:16:10.170
目标平台面对目标威胁

01:16:07.290 --> 01:16:12.090
以最好的形式

01:16:10.170 --> 01:16:14.610
特别有趣

01:16:12.090 --> 01:16:17.130
我们管理的前瞻性说明

01:16:14.610 --> 01:16:20.550
同时使用Java EE 7服务和

01:16:17.130 --> 01:16:24.180
还有云平台等等

01:16:20.550 --> 01:16:25.950
公开GS a 2 3 6兼容线程池

01:16:24.180 --> 01:16:28.020
通过执行服务模型

01:16:25.950 --> 01:16:30.480
 Spring框架自动

01:16:28.020 --> 01:16:32.250
消费他们，如果指向它也

01:16:30.480 --> 01:16:34.440
检测它们并以最佳方式使用它们

01:16:32.250 --> 01:16:36.300
可能的方式

01:16:34.440 --> 01:16:37.920
这确实是促进

01:16:36.300 --> 01:16:39.420
异步处理架构

01:16:37.920 --> 01:16:45.840
在托管环境中运行时

01:16:39.420 --> 01:16:47.969
环境写下来一样

01:16:45.840 --> 01:16:50.850
以相同的角度来看目标

01:16:47.969 --> 01:16:53.040
服务这里只是一个摘要，可以

01:16:50.850 --> 01:16:56.390
也可以在我们的迁移页面上找到

01:16:53.040 --> 01:16:59.340
推荐服务器版本的github 

01:16:56.390 --> 01:17:02.610
我们的政策有些变化

01:16:59.340 --> 01:17:04.620
从技术上讲，我们的系统最少

01:17:02.610 --> 01:17:06.390
需求，您可以部署弹簧

01:17:04.620 --> 01:17:09.150
将申请转发到任何地方

01:17:06.390 --> 01:17:11.550
最低要求是匹配的

01:17:09.150 --> 01:17:13.260
从支持角度看

01:17:11.550 --> 01:17:16.949
复制角度（如果有） 

01:17:13.260 --> 01:17:19.680
是我们主动提出的要求

01:17:16.949 --> 01:17:22.560
至少在合理的近期维护中

01:17:19.680 --> 01:17:24.239
每个服务器的级别，因此您如果

01:17:22.560 --> 01:17:25.949
您正在部署到tomcat 6-尽管

01:17:24.239 --> 01:17:28.980
这是服务器到5个服务器

01:17:25.949 --> 01:17:30.989
很好，但请至少使用一个

01:17:28.980 --> 01:17:33.239
最新的维护版本

01:17:30.989 --> 01:17:37.110
与此处列出的目标相同

01:17:33.239 --> 01:17:40.050
适用于码头等

01:17:37.110 --> 01:17:42.810
还支持WebSphere 7，例如

01:17:40.050 --> 01:17:45.570
只要您使用j / p HRO在709上

01:17:42.810 --> 01:17:47.010
功能钉，您完全遮住了弹簧

01:17:45.570 --> 01:17:48.449
刚部署的应用程序框架

01:17:47.010 --> 01:17:51.210
很好，这是重要的部署

01:17:48.449 --> 01:17:53.550
春季的目标，当然还有网络

01:17:51.210 --> 01:17:56.430
 8:00和8:05也很好

01:17:53.550 --> 01:18:00.270
至少如果您至少在WebLogic上

01:17:56.430 --> 01:18:03.540
 JP 800在10.32 4上

01:18:00.270 --> 01:18:05.370
安装功能，然后弹簧

01:18:03.540 --> 01:18:08.550
应用程序即使部署也很好

01:18:05.370 --> 01:18:10.560
他们也在使用GA PA此页面

01:18:08.550 --> 01:18:13.620
列出WebSocket所在的位置

01:18:10.560 --> 01:18:14.640
支持和特别

01:18:13.620 --> 01:18:18.540
有趣的笔记

01:18:14.640 --> 01:18:20.610
 WebSockets支持标准追赶者2 3 5 

01:18:18.540 --> 01:18:23.250
已有6种兼容的WebSockets支持

01:18:20.610 --> 01:18:25.530
乞求移植到Tomcat 7 o 47及更高版本

01:18:23.250 --> 01:18:27.660
您不需要升级到短途约会

01:18:25.530 --> 01:18:29.880
使WebSockets得到7 o 47 

01:18:27.660 --> 01:18:31.890
整个就足够了

01:18:29.880 --> 01:18:35.400
当然，我也是JD 9 

01:18:31.890 --> 01:18:36.239
 o和来自国外的TD 9 1s后代

01:18:35.400 --> 01:18:39.180
那个那个那个

01:18:36.239 --> 01:18:41.280
我们还支持野生动物WebSockets 

01:18:39.180 --> 01:18:43.929
野蝇是下一代

01:18:41.280 --> 01:18:47.409
 Kapus应用程序服务器

01:18:43.929 --> 01:18:49.060
有关第三方的注释

01:18:47.409 --> 01:18:51.940
虚荣教育等图书馆

01:18:49.060 --> 01:18:53.590
法院判断，因为我们现在有一项政策

01:18:51.940 --> 01:18:55.510
我们支持三年

01:18:53.590 --> 01:18:58.210
从任何给定的春天开始

01:18:55.510 --> 01:19:01.659
准备当前版本的

01:18:58.210 --> 01:19:03.820
我们仍将支持的每个图书馆

01:19:01.659 --> 01:19:06.159
所以在这一点上，这意味着

01:19:03.820 --> 01:19:08.260
我们支持三到六

01:19:06.159 --> 01:19:10.420
并接受更高的高等教育

01:19:08.260 --> 01:19:12.699
高等法院八分之一以上

01:19:10.420 --> 01:19:16.030
这将很快提高

01:19:12.699 --> 01:19:17.949
 -现金给五个及更高级别的法院

01:19:16.030 --> 01:19:20.440
接受较低和较高的支票，直到俄亥俄州

01:19:17.949 --> 01:19:22.449
有三到六个支持的示例

01:19:20.440 --> 01:19:26.320
可能会保存很长时间

01:19:22.449 --> 01:19:28.510
因为那里很普通所以

01:19:26.320 --> 01:19:31.000
这是一项政策更改， 

01:19:28.510 --> 01:19:33.400
不支持聚会图书馆的方式

01:19:31.000 --> 01:19:35.380
回到历史，我们支持三个

01:19:33.400 --> 01:19:37.600
基本上可以追溯到几年前

01:19:35.380 --> 01:19:38.830
这些具体的简单指导规则

01:19:37.600 --> 01:19:42.600
版本可以在我们的网站上查看

01:19:38.830 --> 01:19:42.600
文档中的迁移患者

01:19:43.610 --> 01:19:47.820
所以我们已经在升级

01:19:45.660 --> 01:19:49.320
注意事项基本上是链接

01:19:47.820 --> 01:19:51.840
在中间，这是指向

01:19:49.320 --> 01:19:54.530
对github上的迁移页面具有吸引力

01:19:51.840 --> 01:19:57.240
如果您想查看一些详细信息

01:19:54.530 --> 01:19:59.550
一般来说，我们强烈建议

01:19:57.240 --> 01:20:02.040
如果没有，请升级到spring框架

01:19:59.550 --> 01:20:04.350
您正在考虑使用Java 8 

01:20:02.040 --> 01:20:08.940
语言特征这基本上是

01:20:04.350 --> 01:20:11.820
如果您使用的是GDK 6和7，则必须使用

01:20:08.940 --> 01:20:14.040
强烈推荐Spring Framework 3 

01:20:11.820 --> 01:20:17.040
 2已经处于维护模式

01:20:14.040 --> 01:20:19.020
很好，这将是看到3 

01:20:17.040 --> 01:20:22.290
周一7发布，因此它很活跃

01:20:19.020 --> 01:20:26.250
保持它是最近的

01:20:22.290 --> 01:20:29.730
水平支持许多最近的小事情

01:20:26.250 --> 01:20:31.380
仍然但从根本上讲

01:20:29.730 --> 01:20:33.710
维护模式新功能即将推出

01:20:31.380 --> 01:20:36.030
在这种X线Omni上可以看到

01:20:33.710 --> 01:20:38.370
我们有两个折叠订单，一个版本

01:20:36.030 --> 01:20:41.400
星期一就要来了

01:20:38.370 --> 01:20:45.480
下订单后立即发布

01:20:41.400 --> 01:20:48.390
 OpenJDK hga将于3月下旬发布，因此

01:20:45.480 --> 01:20:50.310
物理上很少有功能的地方

01:20:48.390 --> 01:20:55.250
进来还会以某种形式进来

01:20:50.310 --> 01:20:58.080
当3 2 X我变成一个基本上

01:20:55.250 --> 01:21:07.050
直接维护模式从3到7 

01:20:58.080 --> 01:21:09.570
从前瞻性角度来看

01:21:07.050 --> 01:21:12.660
总结这个定理，让我

01:21:09.570 --> 01:21:15.570
快速谈论我们的Spring框架

01:21:12.660 --> 01:21:17.990
一次都最有趣

01:21:15.570 --> 01:21:21.300
部分是我们有一个较短的迭代计划

01:21:17.990 --> 01:21:24.180
所以对于那个已经在

01:21:21.300 --> 01:21:27.030
我们打算发布的地平线

01:21:24.180 --> 01:21:29.520
候选人在六月准备好了，我们打算

01:21:27.030 --> 01:21:31.860
在八月份可以普遍使用

01:21:29.520 --> 01:21:35.310
从春季到现在有8个月的时间

01:21:31.860 --> 01:21:38.670
鲭鱼有很多

01:21:35.310 --> 01:21:40.980
主题计划4倍Web资源处理

01:21:38.670 --> 01:21:43.050
也许是最重要的之一

01:21:40.980 --> 01:21:46.410
我们有很多人的要求

01:21:43.050 --> 01:21:48.390
侧面用于缓存中的精细功能

01:21:46.410 --> 01:21:51.300
在资源的HTTP缓存控件中

01:21:48.390 --> 01:21:53.670
流水线有很多相关的小

01:21:51.300 --> 01:21:55.980
这些功能加起来有望真正实现

01:21:53.670 --> 01:21:57.010
全面的网络水晶采样

01:21:55.980 --> 01:21:59.559
我们正在努力

01:21:57.010 --> 01:22:01.630
到这里的可折叠目标

01:21:59.559 --> 01:22:03.519
自从

01:22:01.630 --> 01:22:06.219
 che cache希望我们的规格是

01:22:03.519 --> 01:22:07.989
即将进行最终定稿

01:22:06.219 --> 01:22:10.360
这一切都经历了，但他们只是

01:22:07.989 --> 01:22:12.849
还没有发布，所以我们要

01:22:10.360 --> 01:22:15.519
与它保持一致可能会支持

01:22:12.849 --> 01:22:18.460
一组注释将扩展我们的

01:22:15.519 --> 01:22:21.070
 che cache spi支持，我们已经

01:22:18.460 --> 01:22:23.380
有，我们还将添加一些

01:22:21.070 --> 01:22:28.539
用户要求对Springs进行增强

01:22:23.380 --> 01:22:31.719
在缓存模型上，JMS总体上确实是

01:22:28.539 --> 01:22:33.880
认为我们打算与我们的语言

01:22:31.719 --> 01:22:37.019
消息传递模块，使您可以使用

01:22:33.880 --> 01:22:39.760
我们已经看到的端点样式

01:22:37.019 --> 01:22:41.469
由我们的消息传递模块定义

01:22:39.760 --> 01:22:44.489
简单的端点样式

01:22:41.469 --> 01:22:47.980
消息传递目的以将GM绑定到

01:22:44.489 --> 01:22:50.650
经纪人，所以这是

01:22:47.980 --> 01:22:52.119
那个人的春天交通，我们

01:22:50.650 --> 01:22:55.449
通常关注表现

01:22:52.119 --> 01:22:58.239
改进这里的想法是，我们

01:22:55.449 --> 01:23:02.050
要去我在特定领域工作

01:22:58.239 --> 01:23:04.000
诸如

01:23:02.050 --> 01:23:06.460
使用咒语表达来编译咒语

01:23:04.000 --> 01:23:08.400
表达式在运行时快速下降

01:23:06.460 --> 01:23:12.489
字节码是一个有趣的实验

01:23:08.400 --> 01:23:14.289
大量使用咒语和

01:23:12.489 --> 01:23:16.329
改善入门者的表现

01:23:14.289 --> 01:23:21.010
特别是可以启动

01:23:16.329 --> 01:23:23.739
比较昂贵的聚会中间件

01:23:21.010 --> 01:23:27.210
有很多工作区

01:23:23.739 --> 01:23:30.610
我们乐于交付的地方

01:23:27.210 --> 01:23:32.559
在此发布的候选版本

01:23:30.610 --> 01:23:35.079
在下一次迭代中也要柔和

01:23:32.559 --> 01:23:37.179
大约需要8个月的时间

01:23:35.079 --> 01:23:39.750
像是Spring Framework photo 2 

01:23:37.179 --> 01:23:43.449
 2015年4月

01:23:39.750 --> 01:23:44.860
好了，这个工具非常感谢

01:23:43.449 --> 01:23:47.829
您所有的注意力都在这里

01:23:44.860 --> 01:23:49.449
我提到的其他指针检查

01:23:47.829 --> 01:23:51.639
 spring boot 有我们的新春天

01:23:49.449 --> 01:23:53.469
具有全新春季的I / O网站

01:23:51.639 --> 01:23:55.510
框架实际上完成了一些不错的

01:23:53.469 --> 01:23:57.369
信息如何获取最新

01:23:55.510 --> 01:23:59.230
快照，因此如果您愿意

01:23:57.369 --> 01:24:00.730
提供最新的Spring box文件夹

01:23:59.230 --> 01:24:02.769
女儿想要快照尝试

01:24:00.730 --> 01:24:04.869
基本上是发布候选快照

01:24:02.769 --> 01:24:07.119
因为将会公开

01:24:04.869 --> 01:24:09.849
星期一有空，请随时给

01:24:07.119 --> 01:24:10.840
尝试一下，我们的网站包含Navin 

01:24:09.849 --> 01:24:12.790
它的坐标

01:24:10.840 --> 01:24:15.280
并且有很多渠道

01:24:12.790 --> 01:24:18.760
我们发布演示文稿和网络研讨会

01:24:15.280 --> 01:24:22.060
像这样一个，所以有很多后续

01:24:18.760 --> 01:24:23.739
谢谢您一直在线

01:24:22.060 --> 01:24:26.530
这么长时间的介绍

01:24:23.739 --> 01:24:28.980
可能有一个或两个问题

01:24:26.530 --> 01:24:32.619
我们仍然可以在音频通道上接听

01:24:28.980 --> 01:24:34.150
是的，尤其是如果快速浏览耶

01:24:32.619 --> 01:24:36.190
我认为我只有一个

01:24:34.150 --> 01:24:37.360
我认为可能对你有好处

01:24:36.190 --> 01:24:39.699
评论，我认为其他所有人都有

01:24:37.360 --> 01:24:41.590
被回答，因为它可能会

01:24:39.699 --> 01:24:45.159
对那些

01:24:41.590 --> 01:24:47.110
拥有spring vs.或spring和Java 

01:24:45.159 --> 01:24:51.550
 EE辩论

01:24:47.110 --> 01:24:53.699
关于新浪之后的CDI 

01:24:51.550 --> 01:24:57.429
是的问题是我可以使用

01:24:53.699 --> 01:24:59.619
 CGI上下文和依赖项注入

01:24:57.429 --> 01:25:01.929
我的假期我想有一个

01:24:59.619 --> 01:25:06.460
问题，然后像在BEC春季

01:25:01.929 --> 01:25:09.040
面向应用程序从根本上讲CGI 

01:25:06.460 --> 01:25:11.710
定义了自己的框架

01:25:09.040 --> 01:25:14.250
这是一个非常重要的组成部分

01:25:11.710 --> 01:25:19.530
该平台的框架有很多方面

01:25:14.250 --> 01:25:21.489
所以这是一个完整的

01:25:19.530 --> 01:25:24.580
组件框架本身

01:25:21.489 --> 01:25:26.830
那就是如果你有艾米的话

01:25:24.580 --> 01:25:28.300
一些应用程序中的一些CGI用法

01:25:26.830 --> 01:25:31.449
意味着所有力量都可以

01:25:28.300 --> 01:25:33.610
不管用什么解决问题

01:25:31.449 --> 01:25:36.130
与Spring Darrow完美集成

01:25:33.610 --> 01:25:38.110
几个桥是否可用

01:25:36.130 --> 01:25:39.610
是否有单独的系统

01:25:38.110 --> 01:25:42.400
像其他端点一样

01:25:39.610 --> 01:25:45.010
交流，那么你甚至都不会

01:25:42.400 --> 01:25:46.300
做实际组件是必要的

01:25:45.010 --> 01:25:48.460
整合有很多方法

01:25:46.300 --> 01:25:50.739
结合那些技术，但是

01:25:48.460 --> 01:25:52.989
从根本上说，Spring编程和

01:25:50.739 --> 01:25:55.690
配置模型是完全

01:25:52.989 --> 01:25:58.030
本身就有综合模型

01:25:55.690 --> 01:26:00.610
有选择地整合标准

01:25:58.030 --> 01:26:02.500
如您所见GSR 334 

01:26:00.610 --> 01:26:05.530
依赖注入追踪器303可以是

01:26:02.500 --> 01:26:08.739
使JTA 1.2事务无效

01:26:05.530 --> 01:26:10.480
注释有很多标准化

01:26:08.739 --> 01:26:12.670
批注已集成到

01:26:10.480 --> 01:26:15.070
弹簧编程和配置

01:26:12.670 --> 01:26:16.840
模型，所以，如果你看起来像一个典型的

01:26:15.070 --> 01:26:18.610
 CGI组件是典型的弹簧

01:26:16.840 --> 01:26:21.130
组件，他们将看起来有些

01:26:18.610 --> 01:26:23.230
相似，但越看越近

01:26:21.130 --> 01:26:24.729
您将发现的差异

01:26:23.230 --> 01:26:26.559
弹簧组件

01:26:24.729 --> 01:26:29.349
几乎总是有一个刻板印象，他们

01:26:26.559 --> 01:26:31.269
被in中的构造型检测到

01:26:29.349 --> 01:26:32.769
 CDI组件通常没有

01:26:31.269 --> 01:26:35.679
被他们检测到的刻板印象

01:26:32.769 --> 01:26:38.110
存在于jar文件中，因此它以

01:26:35.679 --> 01:26:40.269
自举规则，它只会走

01:26:38.110 --> 01:26:42.309
从那里有很多差异

01:26:40.269 --> 01:26:44.619
细节语义差异

01:26:42.309 --> 01:26:48.239
弹道差异概念

01:26:44.619 --> 01:26:50.979
差异等等

01:26:48.239 --> 01:26:52.269
如果您熟悉CDI，我确定

01:26:50.979 --> 01:26:54.610
您会发现自己对

01:26:52.269 --> 01:26:58.780
春季编程模型，但

01:26:54.610 --> 01:27:01.659
请记住，春天有很多浪费

01:26:58.780 --> 01:27:05.789
有充分的理由拥有自己的方式

01:27:01.659 --> 01:27:08.050
基本上在最大的程度上使用spring 

01:27:05.789 --> 01:27:10.539
全面而令人信服的表格I 

01:27:08.050 --> 01:27:13.059
强烈建议使用它

01:27:10.539 --> 01:27:14.469
根据两个典型的弹簧

01:27:13.059 --> 01:27:15.969
建议就是力量所在

01:27:14.469 --> 01:27:18.280
显示通过那是

01:27:15.969 --> 01:27:21.670
对源代码的可读性影响

01:27:18.280 --> 01:27:24.550
真的显示出来，所以我们真的

01:27:21.670 --> 01:27:28.409
为此我们尽力而为

01:27:24.550 --> 01:27:34.479
成为一个全面而公正的人

01:27:28.409 --> 01:27:38.440
自行清洁，就是这样

01:27:34.479 --> 01:27:39.999
如果问题基本上是关于

01:27:38.440 --> 01:27:42.340
你得到最好的体验吗

01:27:39.999 --> 01:27:44.769
我会用春天

01:27:42.340 --> 01:27:47.889
推荐Springs编程和

01:27:44.769 --> 01:27:50.530
配置模型为主

01:27:47.889 --> 01:27:52.389
观点，你会得到感谢，所以

01:27:50.530 --> 01:27:53.679
对于那个嗯，我认为这很漂亮

01:27:52.389 --> 01:27:55.599
我们已经回答了很多

01:27:53.679 --> 01:27:57.489
聊天中的问题，所以我们

01:27:55.599 --> 01:27:59.760
振作起来，我们快一个小时了

01:27:57.489 --> 01:28:02.880
一半在这里，谢谢你的英勇

01:27:59.760 --> 01:28:06.429
对于此网络研讨会的重复

01:28:02.880 --> 01:28:08.679
不客气，我非常适合

01:28:06.429 --> 01:28:10.389
谢谢，我只想邀请所有人

01:28:08.679 --> 01:28:11.769
在电话上实际上还有

01:28:10.389 --> 01:28:13.599
很多人在线

01:28:11.769 --> 01:28:16.929
好像有，所以你知道一百

01:28:13.599 --> 01:28:20.499
加上我们有一个很棒的网络研讨会

01:28:16.929 --> 01:28:22.869
下个月2月11日Stuart Williams 

01:28:20.499 --> 01:28:24.429
和Apache Tomcat的提交者将

01:28:22.869 --> 01:28:25.300
丹尼尔·尼古拉斯（Daniel Nicholas）也加入了

01:28:24.429 --> 01:28:27.010
他们将要谈论

01:28:25.300 --> 01:28:30.760
引言

01:28:27.010 --> 01:28:33.280
 Apache Tomcat 8，即二月份

01:28:30.760 --> 01:28:35.499
第十一次注册是开放的，所以如果

01:28:33.280 --> 01:28:37.510
您只想加入一些

01:28:35.499 --> 01:28:38.670
该事件刚到IO 

01:28:37.510 --> 01:28:40.500
 /博客

01:28:38.670 --> 01:28:43.190
然后您会在那看到帖子

01:28:40.500 --> 01:28:46.320
同样在下个月，我们将要

01:28:43.190 --> 01:28:48.720
除了弹簧数据引线

01:28:46.320 --> 01:28:50.580
项目负责人

01:28:48.720 --> 01:28:52.140
托马斯奶业的妈妈，他们将成为

01:28:50.580 --> 01:28:54.720
谈论 spring data 存储库

01:28:52.140 --> 01:28:56.370
以及围绕这些最佳做法的一些最佳做法

01:28:54.720 --> 01:28:59.580
钩住他们，你知道如何使用

01:28:56.370 --> 01:29:01.500
诸如查询DSL等之类的东西

01:28:59.580 --> 01:29:02.460
将会是2月18日，所以我们

01:29:01.500 --> 01:29:04.200
很想邀请你参加那些

01:29:02.460 --> 01:29:06.810
网络研讨会，希望在那里见到您

01:29:04.200 --> 01:29:09.330
今天的报告将发布到

01:29:06.810 --> 01:29:11.610
春天的生物/视频只是一个

01:29:09.330 --> 01:29:13.770
重定向到YouTube，我们将发布一个

01:29:11.610 --> 01:29:16.710
注意我们的原子在春天

01:29:13.770 --> 01:29:19.530
爱荷华州博客那个的录音

01:29:16.710 --> 01:29:22.500
网络研讨会应该在今天发布

01:29:19.530 --> 01:29:26.220
嗯，所以要注意那个嗯， 

01:29:22.500 --> 01:29:28.980
然后，作为一个简短的说明，我们还没有

01:29:26.220 --> 01:29:30.960
为Spring启用了直接HTTP下载

01:29:28.980 --> 01:29:33.720
春季爱荷华州网站上的二进制文件

01:29:30.960 --> 01:29:36.000
目前，如果您是少数几个

01:29:33.720 --> 01:29:39.020
确实需要通过HTTP下载

01:29:36.000 --> 01:29:40.920
某些原因，嗯，有一个

01:29:39.020 --> 01:29:42.540
您可以从

01:29:40.920 --> 01:29:43.770
人工服务器，我们只有那个

01:29:42.540 --> 01:29:45.750
偶尔问，所以我想

01:29:43.770 --> 01:29:47.520
提起它，有一个春天

01:29:45.750 --> 01:29:49.260
我真的可以

01:29:47.520 --> 01:29:50.850
引导您了解发生的情况

01:29:49.260 --> 01:29:52.140
但总的来说，我们真的很期待

01:29:50.850 --> 01:29:54.210
听到您对春季的反馈

01:29:52.140 --> 01:29:54.930
哦和一些框架

01:29:54.210 --> 01:29:57.240
你要做的其他事情

01:29:54.930 --> 01:29:59.610
今天感动，所以请打给我们

01:29:57.240 --> 01:30:02.670
 Twitter是Frank中央大学，否则

01:29:59.610 --> 01:30:03.540
我们在社交媒体等上，让我们

01:30:02.670 --> 01:30:05.610
知道您的想法我们很想听听

01:30:03.540 --> 01:30:06.990
您的反馈感谢大家

01:30:05.610 --> 01:30:08.790
还有你的伊恩

01:30:06.990 --> 01:30:12.120
评论让我们开始吧，然后

01:30:08.790 --> 01:30:15.060
说走就说再见-谢谢

01:30:12.120 --> 01:30:17.100
大家的关注，并有一个

01:30:15.060 --> 01:30:19.500
从春天尝试春天的丰富经验

01:30:17.100 --> 01:30:22.080
一个第一的面团

01:30:19.500 --> 01:30:23.790
一旦星期一出来，如果有

01:30:22.080 --> 01:30:25.680
那里的迁移有什么问题吗

01:30:23.790 --> 01:30:26.160
没有内饰，我们真的在那里

01:30:25.680 --> 01:30:32.150
帮你

01:30:26.160 --> 01:30:32.150
谢谢大家

01:30:33.260 --> 01:30:35.320
您

01:30:36.920 --> 01:30:38.980
您

