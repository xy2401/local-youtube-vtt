WEBVTT
Kind: captions
Language: zh-Hans

00:00:24.580 --> 00:00:28.640
嗨， Spring 粉丝在本期中

00:00:27.170 --> 00:00:30.800
 Spring 的技巧，我们将看看如何

00:00:28.640 --> 00:00:32.300
测试第一个api的微服务在

00:00:30.800 --> 00:00:33.590
首先，我们要建立一个

00:00:32.300 --> 00:00:34.520
新服务，所以我要建立一个

00:00:33.590 --> 00:00:35.840
将要调用的服务

00:00:34.520 --> 00:00:37.160
客户服务我们将使用spring 

00:00:35.840 --> 00:00:41.120
支持构建Web应用程序

00:00:37.160 --> 00:00:43.430
将使用JPA和h2我们使用验证程序

00:00:41.120 --> 00:00:45.410
 Spring Cloud Contract验证程序和

00:00:43.430 --> 00:00:46.730
当然只是为了我的旅行

00:00:45.410 --> 00:00:47.690
我们将更容易使用龙目岛

00:00:46.730 --> 00:00:50.450
这是一个编译时间

00:00:47.690 --> 00:00:51.920
注释处理器好，然后仁

00:00:50.450 --> 00:00:58.910
生成一个我们可以打开的新项目

00:00:51.920 --> 00:01:01.430
在我们的IDE中，所以我现在将在

00:00:58.910 --> 00:01:06.190
客户服务CD客户服务

00:01:01.430 --> 00:01:06.190
鹦鹉螺打开它

00:01:16.850 --> 00:01:21.780
好吧，现在我们有了一个新的

00:01:18.659 --> 00:01:23.310
应用程序和您知道的我们的应用程序

00:01:21.780 --> 00:01:25.619
我们应该先进行测试

00:01:23.310 --> 00:01:27.329
保持良好的测试修剪习惯，我们

00:01:25.619 --> 00:01:30.329
应该先写测试，所以说

00:01:27.329 --> 00:01:36.390
我们有一个新的API，当我们调用

00:01:30.329 --> 00:01:38.640
此客户 rest controller 测试

00:01:36.390 --> 00:01:40.619
好的，这是我们的新测试

00:01:38.640 --> 00:01:43.979
将使用Spring Boot测试框架

00:01:40.619 --> 00:01:45.390
我们要和春跑者一起跑步

00:01:43.979 --> 00:01:48.090
对，这是 Spring 跑步者

00:01:45.390 --> 00:01:49.649
与J单元4和5合作，这是

00:01:48.090 --> 00:01:51.659
将是一个 spring boot 测试， 

00:01:49.649 --> 00:01:54.659
在模拟天气环境中工作，因此

00:01:51.659 --> 00:01:56.250
我们会说一个模拟，我想就是这样

00:01:54.659 --> 00:01:58.189
现在就可以了，我们要使用

00:01:56.250 --> 00:02:00.539
模拟可以BC支持和 Spring 

00:01:58.189 --> 00:02:02.369
 spring boot 我们也会用

00:02:00.539 --> 00:02:05.729
这样我们就可以自动连线和模拟

00:02:02.369 --> 00:02:07.799
 MVC客户端在这里，模拟可以是C 

00:02:05.729 --> 00:02:10.140
我们可以与之合作的客户

00:02:07.799 --> 00:02:14.190
对数据库发出请求，因此

00:02:10.140 --> 00:02:15.480
我们会说公共虚空应该归还所有

00:02:14.190 --> 00:02:17.910
客户，我们将有一个

00:02:15.480 --> 00:02:19.650
我们认为将返回的端点

00:02:17.910 --> 00:02:23.190
所有客户数据正确，所以我们可以说

00:02:19.650 --> 00:02:27.870
这个模拟NB C点执行模拟MVC 

00:02:23.190 --> 00:02:32.870
结果成熟点得到我很抱歉的请求

00:02:27.870 --> 00:02:32.870
床垫模拟MVC请求床垫

00:02:33.440 --> 00:02:39.840
建设者点得到我要说我们做

00:02:37.500 --> 00:02:42.209
它发布到它使其到达

00:02:39.840 --> 00:02:43.500
来宾，您会吸引客户，并

00:02:42.209 --> 00:02:45.930
我们将在何时发送

00:02:43.500 --> 00:02:48.329
我们实际上不在乎的内容类型

00:02:45.930 --> 00:02:49.829
所以我们会没事的

00:02:48.329 --> 00:02:53.310
某些事情回来了，所以我要走了

00:02:49.829 --> 00:02:58.349
说一个模拟MVC结果很重要

00:02:53.310 --> 00:03:02.280
状态不会有问题，我们

00:02:58.349 --> 00:03:04.950
期望内容类型

00:03:02.280 --> 00:03:08.099
将是众所周知的它将是一种媒体类型

00:03:04.950 --> 00:03:10.049
应用程序JSON utf-8例如， 

00:03:08.099 --> 00:03:11.630
我们还要说什么我们想

00:03:10.049 --> 00:03:13.919
说这引发异常

00:03:11.630 --> 00:03:15.780
可以解决这个问题，我认为我们应该

00:03:13.919 --> 00:03:17.280
你也知道有一个描述

00:03:15.780 --> 00:03:18.450
关于有效载荷的形状

00:03:17.280 --> 00:03:20.639
应该是回来的时候，所以我们

00:03:18.450 --> 00:03:23.370
要说我们期望

00:03:20.639 --> 00:03:26.349
有效负载以匹配JSON路径，所以我

00:03:23.370 --> 00:03:30.709
要说标记MVC结果

00:03:26.349 --> 00:03:32.660
内容点JSON路径，然后您知道

00:03:30.709 --> 00:03:35.810
我们甚至可以使用JSON矩阵

00:03:32.660 --> 00:03:37.540
像这样的JSON路径就是这样

00:03:35.810 --> 00:03:41.989
我们要去做，所以我们要在

00:03:37.540 --> 00:03:44.720
点让我们说第一个记录点

00:03:41.989 --> 00:03:52.870
我说ID等于1时该怎么说

00:03:44.720 --> 00:03:59.690
对，我们会说等于一等于

00:03:52.870 --> 00:04:02.810
那不是空值，我们去一个

00:03:59.690 --> 00:04:05.660
我们也可以说名字

00:04:02.810 --> 00:04:08.720
或是说名字

00:04:05.660 --> 00:04:12.319
好吧，这个名字就等于鲍勃

00:04:08.720 --> 00:04:15.410
好吧，或者简，我们走得很好

00:04:12.319 --> 00:04:18.350
所以我们在那里没有名字，我们有

00:04:15.410 --> 00:04:19.280
现在我们已经断言了一些基本的

00:04:18.350 --> 00:04:20.780
关于我们的结构的事情

00:04:19.280 --> 00:04:22.669
假设你知道这里的语法

00:04:20.780 --> 00:04:23.750
意思是看进来的杰森

00:04:22.669 --> 00:04:24.979
返回它将是一个数组

00:04:23.750 --> 00:04:26.630
这意味着遍历所有数组， 

00:04:24.979 --> 00:04:28.100
运行一个谓词，我们将取消引用

00:04:26.630 --> 00:04:29.540
再次出现的第一个元素

00:04:28.100 --> 00:04:31.789
在数组中，我们要断言

00:04:29.540 --> 00:04:33.200
第一个记录应该是简和

00:04:31.789 --> 00:04:35.030
回来的内容将是

00:04:33.200 --> 00:04:37.729
类型为JSON的应用程序，让我们运行

00:04:35.030 --> 00:04:41.210
这段代码看看我们能做什么，所以运行

00:04:37.729 --> 00:04:43.250
运行运行，当然这将

00:04:41.210 --> 00:04:45.260
失败了灾难性的李我们

00:04:43.250 --> 00:04:46.550
写了比我们需要更多的测试

00:04:45.260 --> 00:04:48.350
至此，但我们确实知道

00:04:46.550 --> 00:04:51.020
将会失败，所以现在这是我们的工作

00:04:48.350 --> 00:04:52.250
实施生产代码，确保

00:04:51.020 --> 00:04:53.780
这种工作是正确的， 

00:04:52.250 --> 00:04:56.030
通常在《圣经》发展中

00:04:53.780 --> 00:04:57.710
你只想写一个测试

00:04:56.030 --> 00:04:59.690
它返回好，然后您返回到

00:04:57.710 --> 00:05:00.889
生产代码，您就可以做到

00:04:59.690 --> 00:05:02.900
返回好，然后它说好，我

00:05:00.889 --> 00:05:04.520
将返回JSON应用程序J和

00:05:02.900 --> 00:05:05.780
那么您要确保返回的结果与您一样

00:05:04.520 --> 00:05:07.760
期待，你知道你回去

00:05:05.780 --> 00:05:09.020
来吧，但让我跳过

00:05:07.760 --> 00:05:11.360
这里我要写一点

00:05:09.020 --> 00:05:14.300
测试我所期望的一种

00:05:11.360 --> 00:05:16.729
为此设置的最小功能集

00:05:14.300 --> 00:05:18.740
结束点，让我们现在回到

00:05:16.729 --> 00:05:20.330
我们没有的客户风险控制者

00:05:18.740 --> 00:05:22.460
正确，所以我们必须走

00:05:20.330 --> 00:05:25.460
回到我们的代码将在这里，我们将

00:05:22.460 --> 00:05:30.590
说出主要的Java comm示例

00:05:25.460 --> 00:05:32.790
客户服务插入客户休息

00:05:30.590 --> 00:05:35.610
控制者

00:05:32.790 --> 00:05:39.380
我们将插入剩下的控制器

00:05:35.610 --> 00:05:41.220
就像这样，我们将在风险控制人员处说

00:05:39.380 --> 00:05:42.600
我们这里有一些终点

00:05:41.220 --> 00:05:44.250
要说我们将要结束

00:05:42.600 --> 00:05:47.190
返回客户的点

00:05:44.250 --> 00:05:50.490
返回客户记录的集合

00:05:47.190 --> 00:05:52.230
所以我们希望有

00:05:50.490 --> 00:05:55.020
我们遇到了一些我们需要的麻烦

00:05:52.230 --> 00:05:57.030
一些客户数据，所以我们可以说

00:05:55.020 --> 00:05:59.250
获得所有客户我们需要一个客户

00:05:57.030 --> 00:06:03.060
记录，所以我们假设这是一个

00:05:59.250 --> 00:06:06.870
 JPA实体它将有一个长主键

00:06:03.060 --> 00:06:07.560
 ID为生成器值的ID，我将

00:06:06.870 --> 00:06:08.850
有一个字符串

00:06:07.560 --> 00:06:11.760
好吧，我们在测试中说了什么

00:06:08.850 --> 00:06:13.350
测试将测试名称

00:06:11.760 --> 00:06:17.910
那是我们的名字好吧，我们要

00:06:13.350 --> 00:06:19.380
希望这是他们的所有字符串名称

00:06:17.910 --> 00:06:20.670
对，所以我们去那里是我们的基本

00:06:19.380 --> 00:06:23.880
现在的实体当然需要

00:06:20.670 --> 00:06:28.920
鳄鱼和二传手，所以我要用龙目岛

00:06:23.880 --> 00:06:34.950
为我创造那个，我们可以

00:06:28.920 --> 00:06:36.810
所以我们现在有两个实体

00:06:34.950 --> 00:06:38.070
现在我们可以执行此操作了

00:06:36.810 --> 00:06:40.260
知道我们将需要能够

00:06:38.070 --> 00:06:42.360
将数据持久保存到数据库中，因此我们

00:06:40.260 --> 00:06:46.190
应该在这里使用spring数据JPA 

00:06:42.360 --> 00:06:49.470
会创建一个Java类的客户

00:06:46.190 --> 00:06:50.430
好的仓库，这实际上是

00:06:49.470 --> 00:06:52.350
不在课堂上，它将是一个

00:06:50.430 --> 00:06:53.430
界面和界面很好

00:06:52.350 --> 00:06:54.900
足以足以获得

00:06:53.430 --> 00:06:56.880
我们知道的是我们想要的，所以现在我们

00:06:54.900 --> 00:07:01.290
可以将该存储库注入此处私有

00:06:56.880 --> 00:07:02.970
最终客户资料库和亲爱的

00:07:01.290 --> 00:07:06.870
从构造函数设置然后返回

00:07:02.970 --> 00:07:10.920
该客户暂停所有已定义的

00:07:06.870 --> 00:07:14.210
对，所以我们必须实际扩展JPA 

00:07:10.920 --> 00:07:17.760
可以正常工作的存储库

00:07:14.210 --> 00:07:19.830
非常好，所以那里的基本界面

00:07:17.760 --> 00:07:21.150
这使得我们有

00:07:19.830 --> 00:07:22.650
声明式数据管理

00:07:21.150 --> 00:07:24.300
我们提供的功能

00:07:22.650 --> 00:07:25.680
借助Spring数据JPA开箱即用

00:07:24.300 --> 00:07:28.050
这意味着我们可以回到我们的

00:07:25.680 --> 00:07:30.320
测试这里他们测试，让我们看看

00:07:28.050 --> 00:07:30.320
发生

00:07:32.090 --> 00:07:37.100
当然这也会失败

00:07:34.330 --> 00:07:38.870
首先，假设我和我都可以

00:07:37.100 --> 00:07:42.169
认为它应该工作，但是是的，基本上

00:07:38.870 --> 00:07:44.150
我们期望有一定的数据集

00:07:42.169 --> 00:07:46.100
结果中当然没有

00:07:44.150 --> 00:07:47.900
数据，所以我们需要做的是模拟

00:07:46.100 --> 00:07:49.460
出日期访问层，这使得

00:07:47.900 --> 00:07:53.060
感觉我们正在尝试在这里进行测试

00:07:49.460 --> 00:07:54.139
这层是我们与

00:07:53.060 --> 00:07:55.669
与数据库，但与其余

00:07:54.139 --> 00:07:57.470
端点，我们试图断言

00:07:55.669 --> 00:07:58.850
给定某种形状的要求

00:07:57.470 --> 00:08:02.419
我们得到某种形状的反应

00:07:58.850 --> 00:08:04.760
返回，让我们使用spring boot测试

00:08:02.419 --> 00:08:06.620
框架支持模拟 bean 

00:08:04.760 --> 00:08:09.320
基本上我们可以注入客户

00:08:06.620 --> 00:08:11.180
存储库，但当然会启动我们的靴子

00:08:09.320 --> 00:08:12.860
已经看到我们有一个真正的

00:08:11.180 --> 00:08:16.250
客户假设Ori，那么这个模拟会是什么

00:08:12.860 --> 00:08:17.810
注释说准备模拟

00:08:16.250 --> 00:08:20.180
使用模仿对象

00:08:17.810 --> 00:08:23.000
然后让询问的客户

00:08:20.180 --> 00:08:25.160
测试器让我们在其中准备一个模拟对象

00:08:23.000 --> 00:08:28.940
我们的测试，然后替换任何指针

00:08:25.160 --> 00:08:31.340
为此，此存储库中的

00:08:28.940 --> 00:08:33.380
模拟的应用程序上下文

00:08:31.340 --> 00:08:36.979
我们将在此处配置的版本

00:08:33.380 --> 00:08:38.300
好的，让我们对其进行配置，以便

00:08:36.979 --> 00:08:40.760
不只是一个模拟，它实际上是一个存根

00:08:38.300 --> 00:08:42.440
你会知道它将返回某些数据

00:08:40.760 --> 00:08:44.390
当被问到你知道它会跟随

00:08:42.440 --> 00:08:46.940
我们的协议，因此该客户提出了

00:08:44.390 --> 00:08:49.790
 findall然后返回并赢得返回

00:08:46.940 --> 00:08:54.670
 ArrayList的客户对，所以很新

00:08:49.790 --> 00:09:00.740
客户的第一个将是简

00:08:54.670 --> 00:09:03.290
第二个人是鲍勃，我们去了

00:09:00.740 --> 00:09:08.300
好的，所以我们在其中有一些记录

00:09:03.290 --> 00:09:09.710
现在回来的结果我们有你

00:09:08.300 --> 00:09:11.150
知道我们不必做很多额外的事情

00:09:09.710 --> 00:09:12.740
在这里工作 Spring 很聪明

00:09:11.150 --> 00:09:14.270
足以知道取代真实

00:09:12.740 --> 00:09:16.070
这个模拟版本的东西

00:09:14.270 --> 00:09:17.839
该测试的特定目的以及

00:09:16.070 --> 00:09:19.760
似乎有效，所以我们知道了

00:09:17.839 --> 00:09:22.580
正如我们期望的那样，它还在工作

00:09:19.760 --> 00:09:24.320
通过篡改

00:09:22.580 --> 00:09:26.390
在这里测试，我们可以证明测试是

00:09:24.320 --> 00:09:30.950
通过打破测试来工作

00:09:26.390 --> 00:09:32.390
如果你永远不知道那是可行的

00:09:30.950 --> 00:09:35.420
正如我们所期望的那样好，所以我们现在处于

00:09:32.390 --> 00:09:36.830
好的情况，现在我们有服务了

00:09:35.420 --> 00:09:38.870
让我们去建立客户让我们去建立

00:09:36.830 --> 00:09:42.740
客户与所有服务进行交谈

00:09:38.870 --> 00:09:44.630
对，所以我们要建立一个新的

00:09:42.740 --> 00:09:46.080
客户在这里从 Spring 开始

00:09:44.630 --> 00:09:47.670
我要打电话给这个客户

00:09:46.080 --> 00:09:50.870
客户，在这种情况下，我们不需要

00:09:47.670 --> 00:09:53.730
 JPA支持，我们也不知道H2 

00:09:50.870 --> 00:09:55.620
支持，但我们可以使用这个固执的人

00:09:53.730 --> 00:09:57.930
在这里，我们将使用Spring Cloud Contract 

00:09:55.620 --> 00:09:59.730
踩跑者，否则看起来很好

00:09:57.930 --> 00:10:01.740
我，所以我们将产生那个

00:09:59.730 --> 00:10:05.640
给我们一个新项目，所以我们去

00:10:01.740 --> 00:10:10.050
下载目录解压此摘录

00:10:05.640 --> 00:10:17.010
好的客户客户的文件打开

00:10:10.050 --> 00:10:19.200
打开并打开，现在是客户

00:10:17.010 --> 00:10:21.060
客户端将成为客户端API 

00:10:19.200 --> 00:10:22.470
别人可以用来交谈的那个客户

00:10:21.060 --> 00:10:25.320
您知道我们可以为您提供这项服务

00:10:22.470 --> 00:10:27.060
关于多少魔法的很多讨论

00:10:25.320 --> 00:10:28.709
该代码中是否应该包含和

00:10:27.060 --> 00:10:32.760
所有这些，但出于我们的目的，我们只是

00:10:28.709 --> 00:10:34.110
让我们建立一个简单的客户端， 

00:10:32.760 --> 00:10:36.029
确保里面没有魔术

00:10:34.110 --> 00:10:37.350
然后是服务本身

00:10:36.029 --> 00:10:39.990
自己和其他语言站立

00:10:37.350 --> 00:10:41.850
其他协议可以将其与

00:10:39.990 --> 00:10:43.920
有罪不罚，但就我们的目的而言， 

00:10:41.850 --> 00:10:46.680
你知道我们会写一些代码吗

00:10:43.920 --> 00:10:54.209
在这里使其尽可能简单

00:10:46.680 --> 00:10:57.839
对，所以我们像往常一样有一个包裹

00:10:54.209 --> 00:11:00.690
我们将建立一个客户客户对象

00:10:57.839 --> 00:11:03.660
好的，在客户端对象中，我们知道

00:11:00.690 --> 00:11:05.310
我们要进行测试，所以让我们开始吧

00:11:03.660 --> 00:11:07.470
测试一下，我们将创建一个

00:11:05.310 --> 00:11:10.140
客户客户的新测试

00:11:07.470 --> 00:11:11.670
测试，我们将拥有一个

00:11:10.140 --> 00:11:13.649
情报帮助我们实现这项权利

00:11:11.670 --> 00:11:15.540
在那里同步我们的代码

00:11:13.649 --> 00:11:17.190
我们将使用相同的测试

00:11:15.540 --> 00:11:18.660
像以前一样的机制

00:11:17.190 --> 00:11:22.520
 spring boot 测试，我们将与

00:11:18.660 --> 00:11:24.779
 Spring 跑步者班

00:11:22.520 --> 00:11:26.850
使用客户客户应用程序

00:11:24.779 --> 00:11:28.529
虽然希望对您大多数人来说

00:11:26.850 --> 00:11:30.810
使用自动配置的客户端

00:11:28.529 --> 00:11:32.100
 spring boot 消费者可以添加

00:11:30.810 --> 00:11:33.149
图书馆过去的道路和

00:11:32.100 --> 00:11:34.890
 Bean将在

00:11:33.149 --> 00:11:36.660
应用程序上下文，但出于我们的目的

00:11:34.890 --> 00:11:38.070
假设我们只有一本手册

00:11:36.660 --> 00:11:39.690
指向应用程序上下文的指针

00:11:38.070 --> 00:11:42.300
某个地方，我们有一个配置

00:11:39.690 --> 00:11:47.699
类，所以我将定义一个测试

00:11:42.300 --> 00:11:52.500
测试我们与客户的互动

00:11:47.699 --> 00:11:52.649
服务还可以，客户应该回到我们那里

00:11:52.500 --> 00:11:55.620
是

00:11:52.649 --> 00:11:57.360
因此引发异常，并在代码中

00:11:55.620 --> 00:11:58.980
我们将需要

00:11:57.360 --> 00:12:02.749
客户客户，所以让我们注入

00:11:58.980 --> 00:12:06.329
这里当然是私人客户客户

00:12:02.749 --> 00:12:11.029
不错，所以现在我们说BDD 

00:12:06.329 --> 00:12:14.489
断言停止，然后此点客户端点

00:12:11.029 --> 00:12:17.160
点正确的方法在哪里

00:12:14.489 --> 00:12:18.509
所有客户都行得通

00:12:17.160 --> 00:12:20.429
所以我们要做的第一件事是

00:12:18.509 --> 00:12:22.589
正确创建该方法

00:12:20.429 --> 00:12:24.869
客户，我们将返回一个

00:12:22.589 --> 00:12:27.629
收集什么客户权利我们

00:12:24.869 --> 00:12:29.549
也需要一个客户，所以我们需要

00:12:27.629 --> 00:12:32.220
创建那个DTO那个表示

00:12:29.549 --> 00:12:34.649
在那里，我们将其全部创建

00:12:32.220 --> 00:12:37.079
对，我们可以对数据说，我们会给

00:12:34.649 --> 00:12:39.689
我们知道这是一个长ID和一个

00:12:37.079 --> 00:12:42.929
私有字符串姓好

00:12:39.689 --> 00:12:44.339
我们去那里是我们的DTO， 

00:12:42.929 --> 00:12:46.709
为了这个工作，你知道我们可以返回

00:12:44.339 --> 00:12:48.179
现在只看一个新的ArrayList 

00:12:46.709 --> 00:12:50.459
我们可以参加多少测试

00:12:48.179 --> 00:12:54.480
通过那里，我们走了，所以现在回到

00:12:50.459 --> 00:12:57.329
工作，那么我们可以说大小是

00:12:54.480 --> 00:13:00.029
等于两个，所以说

00:12:57.329 --> 00:13:02.360
两个记录又回来了，好吧，让我们看看

00:13:00.029 --> 00:13:02.360
如果可行

00:13:07.680 --> 00:13:13.800
当然，这是行不通的

00:13:09.180 --> 00:13:16.740
首先有几个原因

00:13:13.800 --> 00:13:19.320
该Web应用程序只是应用程序

00:13:16.740 --> 00:13:20.750
已添加到Web应用程序中，因此我们需要

00:13:19.320 --> 00:13:21.900
确保它不会在端口上启动

00:13:20.750 --> 00:13:25.380
 8081 

00:13:21.900 --> 00:13:26.940
以及另一件事是我们不

00:13:25.380 --> 00:13:28.320
无论如何都要配置这个光束

00:13:26.940 --> 00:13:30.120
这没有在应用程序中注册

00:13:28.320 --> 00:13:31.260
上下文不是组件，所以我们需要

00:13:30.120 --> 00:13:34.770
在这里的配置中

00:13:31.260 --> 00:13:37.650
所以我们可以去这里创建一个新的

00:13:34.770 --> 00:13:44.070
客户客户配置客户

00:13:37.650 --> 00:13:45.570
客户端配置，我们将移动

00:13:44.070 --> 00:13:46.190
客户也可以选择自己的类型

00:13:45.570 --> 00:13:48.270
我们在那里

00:13:46.190 --> 00:13:53.760
客户客户端配置将生效

00:13:48.270 --> 00:13:57.390
在这里，我们将注册客户

00:13:53.760 --> 00:14:00.720
客户没事，所以还可以

00:13:57.390 --> 00:14:02.400
客户客户很好，现在我们已经

00:14:00.720 --> 00:14:05.790
有一个简单的服务，让我们现在尝试

00:14:02.400 --> 00:14:07.890
该客户客户代码再次很好

00:14:05.790 --> 00:14:14.040
这次以某种方式测试工作，我对此表示怀疑

00:14:07.890 --> 00:14:16.080
但是我们可以尝试再次失败的确定

00:14:14.040 --> 00:14:17.730
对的，这一次失败了

00:14:16.080 --> 00:14:19.650
从更多现实主义者那里你知道合理

00:14:17.730 --> 00:14:23.660
我们返回零的原因，但这是

00:14:19.650 --> 00:14:25.920
期待两个，所以现在我们需要

00:14:23.660 --> 00:14:27.660
实际实施足够的肉

00:14:25.920 --> 00:14:28.890
测试此客户，而不是让我们

00:14:27.660 --> 00:14:29.400
可以得到我们想要完成的事情

00:14:28.890 --> 00:14:31.470
做完了

00:14:29.400 --> 00:14:34.529
对，我们需要其余的模板，所以我们

00:14:31.470 --> 00:14:37.650
可以打电话给我们，然后我们去

00:14:34.529 --> 00:14:39.390
注入到代码库和

00:14:37.650 --> 00:14:41.550
当然，这意味着我们要

00:14:39.390 --> 00:14:42.990
其余需要配置

00:14:41.550 --> 00:14:46.890
模板，所以让我们在这里创建

00:14:42.990 --> 00:14:51.600
说在梁休息模板返回新

00:14:46.890 --> 00:14:54.170
像这样休息模板，我们将注入

00:14:51.600 --> 00:14:56.250
其余模板在那里其余模板RT 

00:14:54.170 --> 00:14:57.990
我们现在在这里做饭，所以现在我们

00:14:56.250 --> 00:15:00.000
有一个休息模板，我们有

00:14:57.990 --> 00:15:02.670
客户客户和客户测试是

00:15:00.000 --> 00:15:04.410
将基于返回一个数据

00:15:02.670 --> 00:15:05.670
调用网络服务，让我们写

00:15:04.410 --> 00:15:07.890
该代码在这里，而不是返回一个

00:15:05.670 --> 00:15:10.290
空数组列表，我们可以说这个点

00:15:07.890 --> 00:15:16.320
此模板点交换HTTP 

00:15:10.290 --> 00:15:17.790
本地主机8080正斜杠客户

00:15:16.320 --> 00:15:19.329
对，所以我们知道那会很好

00:15:17.790 --> 00:15:21.069
接到电话

00:15:19.329 --> 00:15:22.689
我们不会发送任何数据给

00:15:21.069 --> 00:15:24.489
服务，我们知道我们需要

00:15:22.689 --> 00:15:25.779
告诉其余模板什么样的数据

00:15:24.489 --> 00:15:29.889
我们要回来，所以我们要说一个

00:15:25.779 --> 00:15:33.480
收集客户数据权PTR 

00:15:29.889 --> 00:15:38.139
等于新的参数化类型引用

00:15:33.480 --> 00:15:39.699
客户的类型集合可以吗

00:15:38.139 --> 00:15:41.199
现在那个超级类型花了

00:15:39.699 --> 00:15:44.470
实施为我们提供了一切

00:15:41.199 --> 00:15:47.920
然后需要将数据返回

00:15:44.470 --> 00:15:48.939
我们可以把它放在这里做

00:15:47.920 --> 00:15:50.980
您引用响应，因此得到一个

00:15:48.939 --> 00:15:53.379
有效载荷类型为响应实体

00:15:50.980 --> 00:15:55.660
收集客户，然后我们可以

00:15:53.379 --> 00:15:58.269
那你参考的身体是

00:15:55.660 --> 00:15:59.799
在这里，我们没事了，我们有

00:15:58.269 --> 00:16:01.689
有效载荷和我们所需要的一切

00:15:59.799 --> 00:16:02.799
好，现在有一些讨论， 

00:16:01.689 --> 00:16:06.670
有人提出我们可以

00:16:02.799 --> 00:16:08.499
正在使用你知道塔恩之类的东西

00:16:06.670 --> 00:16:10.899
在这种情况下更简洁，但对于我们

00:16:08.499 --> 00:16:12.279
目的足以将事物保留为

00:16:10.899 --> 00:16:15.339
所以现在我们有了一个实际的

00:16:12.279 --> 00:16:18.339
服务，我们可以尝试一下

00:16:15.339 --> 00:16:20.670
让我们再看一次

00:16:18.339 --> 00:16:24.489
实际的客户，我们现在可以尝试

00:16:20.670 --> 00:16:26.290
好吧，那又一次失败了，我

00:16:24.489 --> 00:16:26.649
想你能猜出为什么没有

00:16:26.290 --> 00:16:29.169
服务

00:16:26.649 --> 00:16:31.089
对，这实际上是

00:16:29.169 --> 00:16:33.220
问题，如果您愿意使用微服务

00:16:31.089 --> 00:16:36.790
为了让我们有效地测试

00:16:33.220 --> 00:16:39.819
为了我们有效地测试

00:16:36.790 --> 00:16:43.360
这个客户的边界，而不是我

00:16:39.819 --> 00:16:44.919
需要有API，好吧，我不需要

00:16:43.360 --> 00:16:46.660
想真正站起来我所有的api 

00:16:44.919 --> 00:16:48.279
每次我想运行测试时

00:16:46.660 --> 00:16:50.319
意味着我现在所有的单元测试

00:16:48.279 --> 00:16:51.819
当我搬到

00:16:50.319 --> 00:16:53.110
听起来微服务的世界

00:16:51.819 --> 00:16:54.429
像初学者一样，因为我非常

00:16:53.110 --> 00:16:56.470
很快就遇到了我

00:16:54.429 --> 00:16:58.749
不得不等20-30分钟

00:16:56.470 --> 00:17:00.459
部署并只是整合您就知道我

00:16:58.749 --> 00:17:01.839
简单的客户权利，那就是

00:17:00.459 --> 00:17:04.689
没有起步，如果变得更糟

00:17:01.839 --> 00:17:06.100
你说的是可怜的html5和iPhone 

00:17:04.689 --> 00:17:07.839
和谁需要谁的Android开发人员

00:17:06.100 --> 00:17:09.970
理论上将不得不部署整个

00:17:07.839 --> 00:17:11.949
系统只是为了能够测试代码

00:17:09.970 --> 00:17:15.250
他们正在为客户写信

00:17:11.949 --> 00:17:17.949
体验正确，所以我们需要

00:17:15.250 --> 00:17:19.949
综合起来，如果这是你

00:17:17.949 --> 00:17:22.779
知道我们可以期待所有客户

00:17:19.949 --> 00:17:24.250
每个服务的运行彼此

00:17:22.779 --> 00:17:27.039
服务和所有相关服务

00:17:24.250 --> 00:17:27.789
只是为了能够通过

00:17:27.039 --> 00:17:29.200
持续整合环境

00:17:27.789 --> 00:17:31.299
记住微点

00:17:29.200 --> 00:17:33.120
服务是为了优化敏捷性

00:17:31.299 --> 00:17:35.790
加快速度

00:17:33.120 --> 00:17:37.380
变化，如果我们放弃放弃

00:17:35.790 --> 00:17:39.210
我们快速测试并快速获得能力

00:17:37.380 --> 00:17:40.410
反馈，那么到底有什么意义

00:17:39.210 --> 00:17:43.020
对，我们要确保我们拥有

00:17:40.410 --> 00:17:45.450
快速的反馈，好吧，让我们模拟一下

00:17:43.020 --> 00:17:47.550
 API，在这里我们可以利用

00:17:45.450 --> 00:17:49.200
电线模拟的客户客户测试

00:17:47.550 --> 00:17:51.780
好的，我们可以自动配置电线模拟

00:17:49.200 --> 00:17:54.990
这是Spring Cloud合同的一部分

00:17:51.780 --> 00:17:57.150
这对于api来说很棒， 

00:17:54.990 --> 00:17:59.309
如果我们知道这是不控制的权利

00:17:57.150 --> 00:18:00.870
一个稳定的API，我们没有

00:17:59.309 --> 00:18:03.180
然后控制该服务的能力

00:18:00.870 --> 00:18:05.400
我们可以使用电线模拟来构建假API 

00:18:03.180 --> 00:18:09.090
为了我们，所以我们要说的是我们的模拟

00:18:05.400 --> 00:18:14.480
电线模拟点URL的复制等于电线

00:18:09.090 --> 00:18:18.920
嘲笑对不起被嘲笑我可以好起来的

00:18:14.480 --> 00:18:21.390
为什么模拟网址等于客户，并且

00:18:18.920 --> 00:18:23.940
我们还说客户还有什么需要

00:18:21.390 --> 00:18:27.600
客户需求应该得到

00:18:23.940 --> 00:18:29.160
客户一些端口8081让我们做到

00:18:27.600 --> 00:18:29.730
在8081上，我们知道服务将会开启

00:18:29.160 --> 00:18:32.400
 8081 

00:18:29.730 --> 00:18:35.600
所以我要配置电线模拟

00:18:32.400 --> 00:18:37.440
从8081端口开始好的，还有

00:18:35.600 --> 00:18:42.179
我们还需要什么，我们知道

00:18:37.440 --> 00:18:44.700
回来的有效载荷将是

00:18:42.179 --> 00:18:47.220
作为JSON的一组客户

00:18:44.700 --> 00:18:48.540
所以我们要成为客户客户是

00:18:47.220 --> 00:18:49.800
使用其余的模板和餐厅

00:18:48.540 --> 00:18:52.080
它将数据转换为

00:18:49.800 --> 00:18:55.290
类型的客户实体集合

00:18:52.080 --> 00:18:57.890
 JSON，所以ID和姓都可以

00:18:55.290 --> 00:19:04.080
对，所以让我们尝试一下，现在

00:18:57.890 --> 00:19:13.350
返回响应线模拟点a 

00:19:04.080 --> 00:19:14.910
响应和响应点将具有

00:19:13.350 --> 00:19:16.350
身体，我的状态码为

00:19:14.910 --> 00:19:18.150
自然地输入200，因为它将

00:19:16.350 --> 00:19:19.980
太好了，我们会有一个身体

00:19:18.150 --> 00:19:21.780
现在我们可以传入一个字节数组

00:19:19.980 --> 00:19:23.100
传入您知道的字符串，这是

00:19:21.780 --> 00:19:25.559
在这里变得非常有用

00:19:23.100 --> 00:19:27.750
支持自动测试内部的JSON 

00:19:25.559 --> 00:19:30.300
Spring 测试的梦想Spring 环测试

00:19:27.750 --> 00:19:33.120
框架在这里我们可以注入一个对象

00:19:30.300 --> 00:19:37.350
映射器，并用它来产生很大的效果

00:19:33.120 --> 00:19:41.120
为一些客户获取一些JSON 

00:19:37.350 --> 00:19:43.940
记录好，所以如果客户客户

00:19:41.120 --> 00:19:46.490
客户很好，所以我们要做的是

00:19:43.940 --> 00:19:51.399
我们将创建一个ArrayList数组

00:19:46.490 --> 00:19:51.399
点作为这些客户的列表，以及

00:19:51.549 --> 00:19:58.120
使用此对象将其转换为JSON 

00:19:55.970 --> 00:20:00.710
映射器点右值是字符串

00:19:58.120 --> 00:20:02.419
客户名单等，这当然

00:20:00.710 --> 00:20:04.159
抛出异常，所以我们说抛出

00:20:02.419 --> 00:20:05.960
异常非常好，所以我们有

00:20:04.159 --> 00:20:09.320
客户列表，我们将使用

00:20:05.960 --> 00:20:12.259
该自定义方法在那里返回

00:20:09.320 --> 00:20:13.340
数据，因此主体将为JSON 

00:20:12.259 --> 00:20:14.990
客户，我要回到

00:20:13.340 --> 00:20:18.980
我们知道的客户

00:20:14.990 --> 00:20:20.119
我们说了什么我们期望很好

00:20:18.980 --> 00:20:21.769
只有一张有两张唱片

00:20:20.119 --> 00:20:23.899
说我们需要编码两个客户，所以

00:20:21.769 --> 00:20:25.940
假设我们有两个客户

00:20:23.899 --> 00:20:27.950
认为我们需要一个构造函数来

00:20:25.940 --> 00:20:30.499
有点有趣，所以所有争论

00:20:27.950 --> 00:20:34.249
构造函数无参数构造函数

00:20:30.499 --> 00:20:38.450
好，我们要传递一个ID 

00:20:34.249 --> 00:20:46.820
而名字叫Jane和

00:20:38.450 --> 00:20:50.029
第二个是鲍勃，好吧， 

00:20:46.820 --> 00:20:52.940
我们的两个记录以及我们还需要什么

00:20:50.029 --> 00:20:54.230
我们需要我认为就是这样

00:20:52.940 --> 00:20:56.470
那实际上是哦，您可能需要我们

00:20:54.230 --> 00:21:00.730
需要正确的内容类型，以便带有标题

00:20:56.470 --> 00:21:04.369
 HTTP标头点内容类型媒体类型

00:21:00.730 --> 00:21:06.289
等于应用程序JSON utf-8值，并且

00:21:04.369 --> 00:21:08.450
应该是应该是一个非常

00:21:06.289 --> 00:21:09.860
简单的互动，我们应该有两个

00:21:08.450 --> 00:21:11.539
记录我们是否再次运行测试

00:21:09.860 --> 00:21:17.210
一切都应该是黄金成分

00:21:11.539 --> 00:21:18.590
对非常好，现在让我们来一点

00:21:17.210 --> 00:21:20.210
要求更高一点，让我们确保我们

00:21:18.590 --> 00:21:25.429
来回整理数据

00:21:20.210 --> 00:21:26.450
正确地说，数据

00:21:25.429 --> 00:21:27.619
我们将其存储在

00:21:26.450 --> 00:21:30.249
首先我们要收集

00:21:27.619 --> 00:21:33.049
引用它并将其用作变量，以便

00:21:30.249 --> 00:21:38.019
客户去那里，现在我们

00:21:33.049 --> 00:21:38.019
要说收藏我说顾客点

00:21:39.770 --> 00:21:51.740
客户点迭代器点下一个点得到

00:21:45.320 --> 00:21:57.020
 ID等于一个L对，我们要

00:21:51.740 --> 00:22:00.380
说第一个是简，所以

00:21:57.020 --> 00:22:05.720
您可以看到我们已经将这些

00:22:00.380 --> 00:22:08.630
方便的断言J api的这些

00:22:05.720 --> 00:22:09.710
流利的测试，所以一直非常

00:22:08.630 --> 00:22:12.200
这里方便，因为我正在探索

00:22:09.710 --> 00:22:13.429
探索我刚打过的测试的API 

00:22:12.200 --> 00:22:14.659
基本控制空间和测试

00:22:13.429 --> 00:22:16.610
写自己看起来不错

00:22:14.659 --> 00:22:18.200
事情正在按预期进行

00:22:16.610 --> 00:22:20.179
所以我们知道有两个记录

00:22:18.200 --> 00:22:21.529
我们知道第一个有数据

00:22:20.179 --> 00:22:23.149
我们期望如此，所以我没有理由

00:22:21.529 --> 00:22:26.210
怀疑第二个不会

00:22:23.149 --> 00:22:31.010
也有很好，所以现在很好

00:22:26.210 --> 00:22:32.390
我们有客户和服务，可能

00:22:31.010 --> 00:22:33.710
足够，你知道可能就足够

00:22:32.390 --> 00:22:37.159
为什么模拟当然可以帮助我们，如果

00:22:33.710 --> 00:22:38.450
如果该API保持稳定，那么这

00:22:37.159 --> 00:22:40.549
不会有什么大问题，因为

00:22:38.450 --> 00:22:42.140
我们可以使用这个电线标记存根

00:22:40.549 --> 00:22:44.360
我们知道这次我们做对了

00:22:42.140 --> 00:22:46.399
所以只要不改变

00:22:44.360 --> 00:22:48.590
我们会没事的，当然，麻烦是

00:22:46.399 --> 00:22:50.240
那为什么不该API会改变

00:22:48.590 --> 00:22:52.399
他们会改变很多，当他们这样做

00:22:50.240 --> 00:22:55.029
改变，我们不再会有这种风险

00:22:52.399 --> 00:22:57.710
是有效的，另外

00:22:55.029 --> 00:22:59.630
制片人可能不知道他们已经

00:22:57.710 --> 00:23:02.059
打破了一定的经验

00:22:59.630 --> 00:23:03.320
客户或客户宁愿有一个开始

00:23:02.059 --> 00:23:05.840
决定习惯

00:23:03.320 --> 00:23:08.240
他们开始期望，所以他们会

00:23:05.840 --> 00:23:10.279
快乐地发展他们的服务， 

00:23:08.240 --> 00:23:12.559
也许是不必要和偶然的

00:23:10.279 --> 00:23:14.690
打破客户之间的互动

00:23:12.559 --> 00:23:16.909
有所以这都不理想

00:23:14.690 --> 00:23:19.010
方面，我们知道是否有需要

00:23:16.909 --> 00:23:21.320
在某种程度上分类目录

00:23:19.010 --> 00:23:23.750
交互并确保的场景

00:23:21.320 --> 00:23:25.549
双方都同意这个定义

00:23:23.750 --> 00:23:28.240
在那种情况下的互动

00:23:25.549 --> 00:23:31.220
这就是消费者驱动的

00:23:28.240 --> 00:23:32.960
合同测试或您知道合同

00:23:31.220 --> 00:23:34.760
给我们权利，我们有一个项目正在

00:23:32.960 --> 00:23:37.789
 Spring 投资组合称为 Spring Cloud 

00:23:34.760 --> 00:23:41.029
合同spring-cloud-contract给了我们

00:23:37.789 --> 00:23:42.799
描述场景的能力

00:23:41.029 --> 00:23:44.720
不是一个架构，让我们非常清楚

00:23:42.799 --> 00:23:48.020
关于这实际上是一个

00:23:44.720 --> 00:23:49.940
有关如何一位客户的文档

00:23:48.020 --> 00:23:52.650
希望与我们的服务互动

00:23:49.940 --> 00:23:55.230
让我们在这里回到我们的服务

00:23:52.650 --> 00:23:57.450
我们已经完成了这项测试

00:23:55.230 --> 00:24:00.000
书面，这是该测试断言

00:23:57.450 --> 00:24:03.660
我们如何期望的结构

00:24:00.000 --> 00:24:06.090
你从中知道的反应

00:24:03.660 --> 00:24:07.380
生产者方面，但同样，我们在

00:24:06.090 --> 00:24:08.790
这种不同步的风险

00:24:07.380 --> 00:24:11.010
客户的实际期望

00:24:08.790 --> 00:24:14.040
让我们写一个不能让我们捕捉到什么

00:24:11.010 --> 00:24:16.380
我们希望在给定的测试中发生

00:24:14.040 --> 00:24:17.970
立即进行互动

00:24:16.380 --> 00:24:20.780
对，所以我要使用文件

00:24:17.970 --> 00:24:23.400
我说测试资源时的目录

00:24:20.780 --> 00:24:26.160
合同，我们将创建一个新的

00:24:23.400 --> 00:24:29.810
合同，这只是GU VDSL，所以

00:24:26.160 --> 00:24:32.670
我们应该把所有的顾客都放下吗？ 

00:24:29.810 --> 00:24:37.920
这是一种类型安全的DSL，所以我要说

00:24:32.670 --> 00:24:41.990
合约点制造，我们将

00:24:37.920 --> 00:24:44.880
提供说明应返回所有

00:24:41.990 --> 00:24:46.260
客户要求将有一个

00:24:44.880 --> 00:24:47.760
一定的形状，所以我们将描述

00:24:46.260 --> 00:24:49.890
在这里，响应将有一个

00:24:47.760 --> 00:24:51.750
一定的形状，所以现在只是给你

00:24:49.890 --> 00:24:52.710
有点给你一点

00:24:51.750 --> 00:24:54.510
前奏一点铺垫

00:24:52.710 --> 00:24:57.930
在这里，我们在说

00:24:54.510 --> 00:24:59.790
我们希望进行测试

00:24:57.930 --> 00:25:02.310
为我们自动生成

00:24:59.790 --> 00:25:05.970
这部电影DSL的内容是什么

00:25:02.310 --> 00:25:08.280
该测试将针对我们

00:25:05.970 --> 00:25:10.350
 API与我们的实际测试相同

00:25:08.280 --> 00:25:12.900
那就是我们辛苦劳动的那个

00:25:10.350 --> 00:25:15.480
几分钟前现在就这样做了

00:25:12.900 --> 00:25:17.130
测试将捕获所有相同的

00:25:15.480 --> 00:25:19.290
正确的事情将捕获如何

00:25:17.130 --> 00:25:20.820
我们希望可以进行一次互动，因此

00:25:19.290 --> 00:25:23.490
我们是说我们期待一个请求

00:25:20.820 --> 00:25:28.890
四个斜线客户

00:25:23.490 --> 00:25:29.790
具有一定确定性的get类型的端点

00:25:28.890 --> 00:25:32.010
你知道它可能有一定的

00:25:29.790 --> 00:25:35.130
标头集合，我们希望

00:25:32.010 --> 00:25:36.360
产生回应的一种请求

00:25:35.130 --> 00:25:40.530
看起来像这样

00:25:36.360 --> 00:25:42.330
类型200的标题可能是

00:25:40.530 --> 00:25:47.580
内容类型正确，所以我们可以说标题

00:25:42.330 --> 00:25:49.950
标头HTTP标头内容类型媒体

00:25:47.580 --> 00:25:52.950
输入您提示的等于应用程序JSON 

00:25:49.950 --> 00:25:54.690
它的价值和身体将是一个

00:25:52.950 --> 00:25:56.520
您知道的地图J发送了地图，我们可以

00:25:54.690 --> 00:25:58.710
变成JSON结构

00:25:56.520 --> 00:26:01.230
从字面上看，我们可以

00:25:58.710 --> 00:26:02.190
产生出您几乎知道的任何清单

00:26:01.230 --> 00:26:04.740
你甚至可以做很多不同的事情

00:26:02.190 --> 00:26:06.120
只返回一个字符串，但在我们这里，我是

00:26:04.740 --> 00:26:08.850
好的，哪一个

00:26:06.120 --> 00:26:11.130
正确的地图集合，这就是

00:26:08.850 --> 00:26:12.150
语法在这里，但是实际上这是一个

00:26:11.130 --> 00:26:13.680
列表，但我们正在做的是

00:26:12.150 --> 00:26:16.350
创建地图，我们将切割

00:26:13.680 --> 00:26:19.230
对象动态地图，因此我们可以使用

00:26:16.350 --> 00:26:24.120
高飞语法，在这里我们要说ID 1 L 

00:26:19.230 --> 00:26:27.900
然后是姓或名，让我们看看

00:26:24.120 --> 00:26:29.460
我们在这里有什么名字，所以我会去

00:26:27.900 --> 00:26:32.330
他们将被称为名称和

00:26:29.460 --> 00:26:35.240
第一个叫简和

00:26:32.330 --> 00:26:38.790
我们将创建另一个记录ID 2， 

00:26:35.240 --> 00:26:41.760
名字等于鲍勃，好吧，所以

00:26:38.790 --> 00:26:43.910
返回此数据是不实际的

00:26:41.760 --> 00:26:46.530
数据是我们期望的数据

00:26:43.910 --> 00:26:47.910
我们的测试再次正确，这意味着

00:26:46.530 --> 00:26:49.590
我们将需要采取行动，你知道吗

00:26:47.910 --> 00:26:51.720
与以前一样的工作

00:26:49.590 --> 00:26:53.460
模拟数据访问存储库

00:26:51.720 --> 00:26:54.810
因为这实际上是在打电话

00:26:53.460 --> 00:26:56.850
 REST API的方式与

00:26:54.810 --> 00:26:58.350
之前已经完成了模拟MVC 

00:26:56.850 --> 00:27:04.110
客户权利，所以我们需要确保

00:26:58.350 --> 00:27:05.880
该模拟互动被捕获

00:27:04.110 --> 00:27:09.990
对，我们需要在某个地方进行设置

00:27:05.880 --> 00:27:12.090
让我们来配置构建过程

00:27:09.990 --> 00:27:14.070
尊重这些合同并对待

00:27:12.090 --> 00:27:16.110
他们作为测试确实可以生成测试

00:27:14.070 --> 00:27:18.330
从他们那里，这种机制就是为什么我们

00:27:16.110 --> 00:27:21.780
说这是合同，因为

00:27:18.330 --> 00:27:24.660
通过执行编译来保持合同

00:27:21.780 --> 00:27:27.260
在构建中，API可以按预期工作

00:27:24.660 --> 00:27:29.490
对，我们无法安装或部署我们的

00:27:27.260 --> 00:27:32.460
如果这些合同不是服务

00:27:29.490 --> 00:27:36.300
过去，客户也不会

00:27:32.460 --> 00:27:39.210
能够消耗一个的定义

00:27:36.300 --> 00:27:40.650
合同，如果他们没有能力

00:27:39.210 --> 00:27:44.370
部署并安装它，所以我们

00:27:40.650 --> 00:27:47.640
将在这里使用一个名为

00:27:44.370 --> 00:27:53.370
 Spring Cloud Contract插件对吧

00:27:47.640 --> 00:27:55.200
在这里，我们去 Spring 的云，我想我们

00:27:53.370 --> 00:27:58.080
首先需要艺术小组的想法或

00:27:55.200 --> 00:28:02.550
解释框架云 Spring Cloud 

00:27:58.080 --> 00:28:05.550
合约Maven插件，我们需要一个

00:28:02.550 --> 00:28:06.360
我们可以说1.1.1版本是

00:28:05.550 --> 00:28:07.890
精细

00:28:06.360 --> 00:28:09.210
还有其他一些

00:28:07.890 --> 00:28:10.710
配置我们要做的第一件事

00:28:09.210 --> 00:28:12.840
要做的就是配置它与

00:28:10.710 --> 00:28:14.760
扩展肯定，另一件事是

00:28:12.840 --> 00:28:16.500
我们需要做的是给它一个想法

00:28:14.760 --> 00:28:18.330
我说哪里可以找到基类

00:28:16.500 --> 00:28:19.590
基类我的意思是我们需要一些

00:28:18.330 --> 00:28:21.600
这个动态的类

00:28:19.590 --> 00:28:23.039
生成动态测试

00:28:21.600 --> 00:28:26.340
生成的测试将

00:28:23.039 --> 00:28:28.529
创造良好将延伸正确，所以我们需要

00:28:26.340 --> 00:28:30.960
可以的某种基类

00:28:28.529 --> 00:28:32.850
扩展，我们可以做任何事情

00:28:30.960 --> 00:28:37.049
各种测试设置，让我们创建一个

00:28:32.850 --> 00:28:41.100
测试的基础类，我们将创建一个

00:28:37.049 --> 00:28:42.480
这里的新基类这里的Java基类

00:28:41.100 --> 00:28:44.159
我们去，所以这是我们的基础课

00:28:42.480 --> 00:28:45.929
我们将在稍后再讨论，但让我们

00:28:44.159 --> 00:28:48.360
确保我们在这里完成想法

00:28:45.929 --> 00:28:50.730
淡化示例点客户服务

00:28:48.360 --> 00:28:52.529
基类很好，所以我们已经有了

00:28:50.730 --> 00:28:54.419
现在我们需要实际实施

00:28:52.529 --> 00:28:56.669
该基类将是的基类

00:28:54.419 --> 00:28:58.260
一个Spring 启动测试，它将与

00:28:56.669 --> 00:29:03.870
这个 Spring 的跑步者，所以我们要去

00:28:58.260 --> 00:29:05.789
使用它，我们将自动

00:29:03.870 --> 00:29:07.110
配置模拟可以BC很好

00:29:05.789 --> 00:29:08.640
实际上不需要我不认为我们

00:29:07.110 --> 00:29:10.140
甚至需要这样做，我们必须要做

00:29:08.640 --> 00:29:13.770
一些设置，虽然不是，我们需要

00:29:10.140 --> 00:29:15.630
设置放心的测试

00:29:13.770 --> 00:29:19.260
对，我们没有使用标准

00:29:15.630 --> 00:29:22.020
根据测试本身不使用

00:29:19.260 --> 00:29:23.850
标准的模拟MVC spring机械师a 

00:29:22.020 --> 00:29:26.520
他们使用Prada与其余部分整合

00:29:23.850 --> 00:29:27.659
放心，所以设置起来并不难

00:29:26.520 --> 00:29:29.730
你说你需要说

00:29:27.659 --> 00:29:32.520
放心maka MVC独立安装

00:29:29.730 --> 00:29:35.100
您可以在Web应用程序上下文中传递

00:29:32.520 --> 00:29:36.840
您可以传递一个控制器

00:29:35.100 --> 00:29:39.029
应该使用或配置您可以做的

00:29:36.840 --> 00:29:40.380
我喜欢在这里使用各种各样的东西

00:29:39.029 --> 00:29:42.510
此超时独立设置，然后

00:29:40.380 --> 00:29:46.679
只是注入测试中的存储库

00:29:42.510 --> 00:29:51.840
所以我会说私人客户休息

00:29:46.679 --> 00:29:55.020
控制器，我们将说这个点

00:29:51.840 --> 00:29:56.190
客户 rest controller ，然后我们

00:29:55.020 --> 00:29:58.799
需要进行相同的设置

00:29:56.190 --> 00:30:00.750
我们在他们面前做了嘲笑

00:29:58.799 --> 00:30:03.990
数据层正确，让我们进行测试

00:30:00.750 --> 00:30:05.820
从以前开始，只是借用这一点

00:30:03.990 --> 00:30:08.250
在这里，当我们使用

00:30:05.820 --> 00:30:12.529
用于自定义存储库的模拟bean，因此

00:30:08.250 --> 00:30:16.830
我们去基础课好

00:30:12.529 --> 00:30:20.730
我们将使用at模拟 bean private 

00:30:16.830 --> 00:30:24.120
客户资料库非常好，所以

00:30:20.730 --> 00:30:28.490
我们的基本设置我们的基本测试

00:30:24.120 --> 00:30:30.570
我们可以再运行一次此代码

00:30:28.490 --> 00:30:33.330
否则我们实际上无法运行它

00:30:30.570 --> 00:30:34.980
通过运行运行代码

00:30:33.330 --> 00:30:38.840
编译器正确，所以我们转到命令

00:30:34.980 --> 00:30:41.640
在这里排队，我们将做清理

00:30:38.840 --> 00:30:42.840
安装就足够了

00:30:41.640 --> 00:30:44.850
同时，我们实际上并不需要这个

00:30:42.840 --> 00:30:46.080
测试我写了这个测试，但是结果

00:30:44.850 --> 00:30:48.000
这是没有意义的，让我们摆脱它

00:30:46.080 --> 00:30:55.980
我们将再次开始编译

00:30:48.000 --> 00:30:58.530
行家干净安装好，所以我们跑了

00:30:55.980 --> 00:31:00.030
测试我们没有找到我们没有给我们

00:30:58.530 --> 00:31:02.190
测试我们的基类足够的信息

00:31:00.030 --> 00:31:03.720
找到Spring 应用程序

00:31:02.190 --> 00:31:07.110
上下文，所以我们回到基础课

00:31:03.720 --> 00:31:08.610
在这里，我们说的是

00:31:07.110 --> 00:31:13.220
它应该使用的是客户服务

00:31:08.610 --> 00:31:13.220
应用程序点类再次回到这里

00:31:18.740 --> 00:31:23.580
好吧，看起来还好，所以

00:31:21.390 --> 00:31:24.930
那是我们的合同，现在我们可以再次

00:31:23.580 --> 00:31:28.320
我们应该证明负面因素吧

00:31:24.930 --> 00:31:32.190
回到我们回到

00:31:28.320 --> 00:31:35.150
在这里编写代码，然后将Jane更改为Janet， 

00:31:32.190 --> 00:31:35.150
 maven再次干净安装

00:31:39.570 --> 00:31:43.570
您会看到它失败了，如果

00:31:41.769 --> 00:31:45.460
你看看发生了什么，有一个测试

00:31:43.570 --> 00:31:49.269
这是一个错误合同验证程序

00:31:45.460 --> 00:31:53.139
测试一下，如果你去那只猫合同

00:31:49.269 --> 00:31:57.429
验证程序测试或猫目标，我将在这里安装CD 

00:31:53.139 --> 00:32:03.399
目标找到我命名合同验证者

00:31:57.429 --> 00:32:11.109
测试正确，我们看看最后一个

00:32:03.399 --> 00:32:15.340
抓取Java猫脚本Java可以

00:32:11.109 --> 00:32:17.109
所以猫这一个，你可以看到

00:32:15.340 --> 00:32:19.119
这实际上是生成的测试

00:32:17.109 --> 00:32:20.859
对于此合同，验证测试将其扩展

00:32:19.119 --> 00:32:22.840
基类和每种测试方法

00:32:20.859 --> 00:32:25.330
对应于您可以拥有的合约

00:32:22.840 --> 00:32:26.799
一，十或一千份合同

00:32:25.330 --> 00:32:29.499
描述某些情况

00:32:26.799 --> 00:32:31.119
与您互动的所有内容

00:32:29.499 --> 00:32:32.619
期望在这里就在这里，所以

00:32:31.119 --> 00:32:34.149
就是说期待着回应

00:32:32.619 --> 00:32:37.029
回来，上面有一个状态码

00:32:34.149 --> 00:32:39.399
等于200的标头等于

00:32:37.029 --> 00:32:41.679
以下，我们正在使用JSON路径

00:32:39.399 --> 00:32:43.779
审问

00:32:41.679 --> 00:32:45.940
从服务返回的对象

00:32:43.779 --> 00:32:47.470
所以这基本上是测试

00:32:45.940 --> 00:32:49.989
我们测试之前，正是

00:32:47.470 --> 00:32:51.970
与我们在测试中所做的相同

00:32:49.989 --> 00:32:53.830
我们之前的测试只是

00:32:51.970 --> 00:32:55.179
自动完成，我们得到了

00:32:53.830 --> 00:32:56.289
是免费的，但这会而且那会

00:32:55.179 --> 00:32:58.119
本身就很有趣，因为我

00:32:56.289 --> 00:33:01.149
认为这实际上有点容易

00:32:58.119 --> 00:33:02.830
比测试更了解和阅读

00:33:01.149 --> 00:33:05.470
我写的代码，但这是这个

00:33:02.830 --> 00:33:07.749
实际上还有另一个更有希望的

00:33:05.470 --> 00:33:09.759
好处是我现在可以出口

00:33:07.749 --> 00:33:12.600
这些合同，让我们继续

00:33:09.759 --> 00:33:15.970
并修复我们的测试，并确保

00:33:12.600 --> 00:33:18.100
事情按我们预期的那样很好，所以简

00:33:15.970 --> 00:33:19.409
会简做一个行家清洁

00:33:18.100 --> 00:33:23.159
再安装一次

00:33:19.409 --> 00:33:23.159
 Maven全新安装

00:33:30.350 --> 00:33:34.530
好吧，现在我们已经安装

00:33:32.910 --> 00:33:37.169
一切都是绿色的你

00:33:34.530 --> 00:33:40.169
可以看到这里有三个

00:33:37.169 --> 00:33:43.470
安装安装定制服务

00:33:40.169 --> 00:33:46.440
快照jar安装客户服务

00:33:43.470 --> 00:33:47.270
快照手掌，最后这是

00:33:46.440 --> 00:33:49.860
它变得有趣

00:33:47.270 --> 00:33:52.740
安装客户服务快照

00:33:49.860 --> 00:33:54.419
存根是存根是

00:33:52.740 --> 00:33:56.100
我们正在使用的插件的工件

00:33:54.419 --> 00:33:59.070
 Spring Cloud的Maven插件

00:33:56.100 --> 00:34:04.789
合约存根包含JSON 

00:33:59.070 --> 00:34:08.970
文档，所以如果我们去这里jar xvf 

00:34:04.789 --> 00:34:12.169
客户服务存根罐，您可以

00:34:08.970 --> 00:34:15.869
请参阅meta incom示例客户服务

00:34:12.169 --> 00:34:18.240
映射猫应该返回所有客户

00:34:15.869 --> 00:34:20.760
完成JSON，这是本机

00:34:18.240 --> 00:34:23.700
电线模拟的配置文件格式

00:34:20.760 --> 00:34:25.379
这样我们就可以编码了

00:34:23.700 --> 00:34:28.710
捕获了您的合同

00:34:25.379 --> 00:34:32.659
只要我们提供并且我们已经使用

00:34:28.710 --> 00:34:35.450
把它变成电线模拟

00:34:32.659 --> 00:34:37.470
然后我们可以输入的文件

00:34:35.450 --> 00:34:38.850
以及任何支持电线标记的东西

00:34:37.470 --> 00:34:41.340
已经可以在客户端使用了

00:34:38.850 --> 00:34:43.800
站起来的假API看起来和

00:34:41.340 --> 00:34:45.990
就像我们在

00:34:43.800 --> 00:34:50.909
我们的DSL，让我们去吧

00:34:45.990 --> 00:34:52.710
我们的客户现在在这里，然后返回

00:34:50.909 --> 00:34:54.600
我们的构建并记住我们的构建

00:34:52.710 --> 00:34:56.700
我们已经有了Spring Cloud Starter 

00:34:54.600 --> 00:34:59.820
合同存根转轮，所以我们可以去这里

00:34:56.700 --> 00:35:02.280
测试，我们要做的就是使用

00:34:59.820 --> 00:35:03.630
存根赛跑者站起来假API 

00:35:02.280 --> 00:35:05.580
所以我们不再需要电线模拟了

00:35:03.630 --> 00:35:06.780
对，我们实际上可以，我的意思是我们可以

00:35:05.580 --> 00:35:11.130
使用JSON，但我们实际上并不需要

00:35:06.780 --> 00:35:15.119
所以我们需要的是自动配置的步骤

00:35:11.130 --> 00:35:17.130
跑步者，我们现在的工作是指定

00:35:15.119 --> 00:35:20.010
存根赛跑者在哪里找到存根

00:35:17.130 --> 00:35:20.940
我们需要的定义

00:35:20.010 --> 00:35:22.859
能够运行此测试，所以让我们

00:35:20.940 --> 00:35:25.200
在我们不需要的所有地方发表评论

00:35:22.859 --> 00:35:27.030
可以说ID相等并且可以离线工作

00:35:25.200 --> 00:35:28.830
等于真正的离线工作意味着

00:35:27.030 --> 00:35:31.020
会在当地m2中寻找存根

00:35:28.830 --> 00:35:32.250
仓库不仅在Maven Central或

00:35:31.020 --> 00:35:33.720
人工制品或其他

00:35:32.250 --> 00:35:36.119
您拥有的存储库

00:35:33.720 --> 00:35:38.040
环境和ID 

00:35:36.119 --> 00:35:38.800
 Maven协调Maven风格

00:35:38.040 --> 00:35:40.330
坐标或

00:35:38.800 --> 00:35:43.900
常春藤坐标或任何你知道的

00:35:40.330 --> 00:35:46.120
解决该特定问题的语法

00:35:43.900 --> 00:35:48.640
定义我们只是存根罐

00:35:46.120 --> 00:35:51.820
创建，所以它会很平静的例子： 

00:35:48.640 --> 00:35:53.140
客户服务：然后我们

00:35:51.820 --> 00:35:55.480
应该提供一个很好的版本

00:35:53.140 --> 00:35:58.240
当然，从定义上讲，我们希望

00:35:55.480 --> 00:36:01.120
客户要成功获取最新信息

00:35:58.240 --> 00:36:03.280
部署并生成存根定义，以便

00:36:01.120 --> 00:36:04.660
如果那个测试没有通过，那么我们

00:36:03.280 --> 00:36:06.550
不可能运行Maven 

00:36:04.660 --> 00:36:08.110
全新安装，您可以想象

00:36:06.550 --> 00:36:09.790
行家干净部署和真实的东西，但

00:36:08.110 --> 00:36:12.040
足以说我们还有另一个本地人

00:36:09.790 --> 00:36:13.630
 man m2存储库，以及是否

00:36:12.040 --> 00:36:15.190
它已部署，还有其他一些存储库

00:36:13.630 --> 00:36:18.040
我们要确保我们本地

00:36:15.190 --> 00:36:19.960
总是有最新最好的存根

00:36:18.040 --> 00:36:21.550
定义，因为那代表

00:36:19.960 --> 00:36:23.440
大概在生产中的代码

00:36:21.550 --> 00:36:25.780
对，如果我什至可以干净地部署我的

00:36:23.440 --> 00:36:27.220
我的API，那么我希望您能

00:36:25.780 --> 00:36:28.720
连续交付也可以部署

00:36:27.220 --> 00:36:30.700
投入生产，我想

00:36:28.720 --> 00:36:32.410
确保我的客户匹配任何

00:36:30.700 --> 00:36:34.300
在生产中，我要说的是

00:36:32.410 --> 00:36:36.850
这意味着最新的，然后我

00:36:34.300 --> 00:36:38.020
会告诉它在

00:36:36.850 --> 00:36:40.240
端口8081 

00:36:38.020 --> 00:36:41.380
正确的，符合现实

00:36:40.240 --> 00:36:44.680
我们在这里试图做的是

00:36:41.380 --> 00:36:47.140
试图说出客户端何时调用HTTP 

00:36:44.680 --> 00:36:49.030
本地主机8080这样的客户我们

00:36:47.140 --> 00:36:50.830
希望一些数据回来，所以

00:36:49.030 --> 00:36:51.940
没关系，我们不需要这个

00:36:50.830 --> 00:36:54.400
不再是我们了

00:36:51.940 --> 00:36:55.860
现在我们自己序列化数据，让我们

00:36:54.400 --> 00:37:03.310
尝试一下，看看会发生什么

00:36:55.860 --> 00:37:06.700
我现在进行客户客户测试

00:37:03.310 --> 00:37:07.870
期待有什么破坏，让我们看看

00:37:06.700 --> 00:37:14.920
我们到那里去了

00:37:07.870 --> 00:37:17.380
所以不同的领域

00:37:14.920 --> 00:37:20.350
客户与以下字段不同

00:37:17.380 --> 00:37:23.980
我们在其中拥有姓氏的服务

00:37:20.350 --> 00:37:29.410
客户和真实的东西

00:37:23.980 --> 00:37:31.930
服务，我们有名字，所以我们知道一个

00:37:29.410 --> 00:37:33.640
这些不再是无效的

00:37:31.930 --> 00:37:35.200
从未有效过，但我们的测试是

00:37:33.640 --> 00:37:37.030
绿色，您可能会说您可能会宣布

00:37:35.200 --> 00:37:39.160
是的，他们是绿色的，但他们是

00:37:37.030 --> 00:37:40.510
他们没有反映现实

00:37:39.160 --> 00:37:42.250
唯一的办法

00:37:40.510 --> 00:37:44.380
在做适当的事情之前就意识到

00:37:42.250 --> 00:37:46.270
集成测试，是的，我们有云

00:37:44.380 --> 00:37:49.690
计算技术和耶云

00:37:46.270 --> 00:37:50.050
 Foundry具有出色的反应式Java客户端

00:37:49.690 --> 00:37:52.420
你能行

00:37:50.050 --> 00:37:53.860
使用Java代码部署所有

00:37:52.420 --> 00:37:55.660
应用程序将它们按比例放大

00:37:53.860 --> 00:37:57.220
等，但即使那样会带你

00:37:55.660 --> 00:37:58.360
知道分钟，你不想对你

00:37:57.220 --> 00:37:59.980
不想为此陷入困境

00:37:58.360 --> 00:38:01.720
更好地找到这种东西

00:37:59.980 --> 00:38:03.610
真的非常快地退出，所以现在让我们

00:38:01.720 --> 00:38:09.660
再运行一次测试，让我们看看

00:38:03.610 --> 00:38:09.660
那行得通哦，好吧，取名字好吧

00:38:15.540 --> 00:38:20.980
嘿，看它起作用了，所以我们

00:38:18.190 --> 00:38:23.560
知道我们知道它在

00:38:20.980 --> 00:38:25.390
捕获集成问题，因为

00:38:23.560 --> 00:38:27.670
首先不会成功

00:38:25.390 --> 00:38:29.320
时间，我们知道，如果生产者

00:38:27.670 --> 00:38:31.300
以某种方式更改其API 

00:38:29.320 --> 00:38:32.830
破坏了我们的客户，我们将捕捉到

00:38:31.300 --> 00:38:34.810
因为我们将永远消耗

00:38:32.830 --> 00:38:37.030
最新和最好的存根定义

00:38:34.810 --> 00:38:38.500
对，这样非常方便， 

00:38:37.030 --> 00:38:40.900
这有助于我做到这一点，这意味着

00:38:38.500 --> 00:38:42.640
对我们来说编写代码很容易

00:38:40.900 --> 00:38:46.060
快速的权利，您可以看到测试已运行

00:38:42.640 --> 00:38:47.710
 137毫秒，简洁明快

00:38:46.060 --> 00:38:50.290
实际上这是更少的代码

00:38:47.710 --> 00:38:53.920
认知开销然后另一个

00:38:50.290 --> 00:38:56.260
东西，最重要的是它是可扩展的

00:38:53.920 --> 00:38:57.970
对，所以我实际上可以为所有人做到这一点

00:38:56.260 --> 00:39:01.990
我所有服务可以使用的服务

00:38:57.970 --> 00:39:03.550
合同，这样做，他们我

00:39:01.990 --> 00:39:05.530
不再需要一个客户

00:39:03.550 --> 00:39:07.450
部署我可以的每一项服务

00:39:05.530 --> 00:39:09.160
只是消耗合同，我知道

00:39:07.450 --> 00:39:11.230
和服务一样好

00:39:09.160 --> 00:39:12.940
因为它与

00:39:11.230 --> 00:39:15.340
服务的生产者习惯于

00:39:12.940 --> 00:39:17.200
验证自己的API，因此您知道

00:39:15.340 --> 00:39:19.000
处理器正在运行合同，并且

00:39:17.200 --> 00:39:20.620
将其用作测试工具并重用

00:39:19.000 --> 00:39:23.650
合同作为测试工具

00:39:20.620 --> 00:39:25.300
现在当然有相同的合同

00:39:23.650 --> 00:39:26.620
有一些穷人

00:39:25.300 --> 00:39:28.510
在外面不使用的人

00:39:26.620 --> 00:39:30.310
 Spring ，我听说过这些

00:39:28.510 --> 00:39:33.280
了解那些人的存在

00:39:30.310 --> 00:39:36.070
当然有很大的支持

00:39:33.280 --> 00:39:37.660
运行此-使用这些存根

00:39:36.070 --> 00:39:39.310
 Spring 之外的定义

00:39:37.660 --> 00:39:40.690
环境很方便

00:39:39.310 --> 00:39:42.190
可以说自动配置存根

00:39:40.690 --> 00:39:44.110
赛跑者，然后在你的一生中

00:39:42.190 --> 00:39:46.180
测试我有这个的所有存根

00:39:44.110 --> 00:39:47.710
神器站起来为你揭露

00:39:46.180 --> 00:39:49.000
某个港口，但那也许

00:39:47.710 --> 00:39:50.770
您是iPhone开发人员，也许您是

00:39:49.000 --> 00:39:51.930
一个Android开发人员html5开发人员，以及

00:39:50.770 --> 00:39:54.850
你不想学习如何

00:39:51.930 --> 00:39:57.640
进行安装和部署Java服务

00:39:54.850 --> 00:39:59.290
任何方式都可以，因此您可以

00:39:57.640 --> 00:40:01.900
仍然要对这些存根进行管理

00:39:59.290 --> 00:40:03.100
可以去我们我们可以看到我们的存根

00:40:01.900 --> 00:40:03.390
看到他们已经在那里，所以

00:40:03.100 --> 00:40:05.340
让我们

00:40:03.390 --> 00:40:08.970
现在转到桌面，您可以使用

00:40:05.340 --> 00:40:12.000
所谓的存根赛跑者

00:40:08.970 --> 00:40:15.170
启动罐，我碰巧有一个版本

00:40:12.000 --> 00:40:17.520
它的下载，所以我要去

00:40:15.170 --> 00:40:20.640
目录在这里，我很固执

00:40:17.520 --> 00:40:23.490
引导罐就在那里，语法是

00:40:20.640 --> 00:40:25.920
轻松地说出Java漂亮的jar步骤即可运行

00:40:23.490 --> 00:40:30.600
开机，你说存根跑步者点ID 

00:40:25.920 --> 00:40:35.640
等于示例客户的通信- 

00:40:30.600 --> 00:40:39.840
服务加8081，你说存根

00:40:35.640 --> 00:40:42.990
离线运行亚军等于true， 

00:40:39.840 --> 00:40:44.160
您像我们一样简单地启动它

00:40:42.990 --> 00:40:47.810
正确之前

00:40:44.160 --> 00:40:53.010
所以现在应该从端口8081开始

00:40:47.810 --> 00:40:55.080
本地主机8080 81位客户

00:40:53.010 --> 00:40:57.390
我们的数据我们知道的实际数据

00:40:55.080 --> 00:40:58.680
它是由那个存根驱动的，我们

00:40:57.390 --> 00:41:00.360
只要我们知道

00:40:58.680 --> 00:41:02.070
坐标，我们可以越过

00:41:00.360 --> 00:41:03.090
罐子周围没人需要知道

00:41:02.070 --> 00:41:04.710
他们不需要部署的其他任何东西

00:41:03.090 --> 00:41:05.790
我们的数据库和您的服务

00:41:04.710 --> 00:41:07.530
不需要等待，他们不必

00:41:05.790 --> 00:41:09.300
有自己的混杂集群

00:41:07.530 --> 00:41:11.100
空间或他们可以测试的任何东西

00:41:09.300 --> 00:41:13.770
在本地快速迭代并发展

00:41:11.100 --> 00:41:15.930
好吧，值得理解的是

00:41:13.770 --> 00:41:17.820
我们已经研究了如何测试API 

00:41:15.930 --> 00:41:19.680
使用Spring Cloud Contract的REST API 

00:41:17.820 --> 00:41:21.330
还有许多其他可能性

00:41:19.680 --> 00:41:23.820
您可以使用Spring Cloud Contract来

00:41:21.330 --> 00:41:25.500
使用以下命令测试基于消息传递的微服务

00:41:23.820 --> 00:41:27.660
 Spring 的云流或 Spring 

00:41:25.500 --> 00:41:29.550
整合或骆驼，您可以使用它来

00:41:27.660 --> 00:41:31.500
模拟出您的服务注册表，以便

00:41:29.550 --> 00:41:32.640
想象一下您所有的 Spring Cloud 代码

00:41:31.500 --> 00:41:35.220
您拥有发现客户端的位置

00:41:32.640 --> 00:41:37.770
您已经基于Spring Cloud Contract 

00:41:35.220 --> 00:41:40.020
正在进行的服务或存根

00:41:37.770 --> 00:41:42.120
由模拟服务注册表引用，因此

00:41:40.020 --> 00:41:43.470
现在，您可以在整个已知的负载均衡

00:41:42.120 --> 00:41:44.760
您的实际服务

00:41:43.470 --> 00:41:46.380
自己去存根，你不必

00:41:44.760 --> 00:41:47.730
部署真实的东西，所以有很多

00:41:46.380 --> 00:41:49.590
除了我们向您展示的以外，还有其他选择

00:41:47.730 --> 00:41:51.090
在这里，实际上还有一个整体

00:41:49.590 --> 00:41:53.820
工作流程称为消费者给予

00:41:51.090 --> 00:41:55.470
您最终以合同形式

00:41:53.820 --> 00:41:58.320
客户最终推动了发展

00:41:55.470 --> 00:42:00.900
在这种情况下，我们做到了

00:41:58.320 --> 00:42:02.340
但是有一种整体方法

00:42:00.900 --> 00:42:03.810
可以看到很多

00:42:02.340 --> 00:42:05.340
使用spring的好处

00:42:03.810 --> 00:42:07.170
和我的朋友们签约

00:42:05.340 --> 00:42:09.710
非常感谢您的收看，我们会

00:42:07.170 --> 00:42:09.710
下次见

00:42:15.770 --> 00:42:17.830
您

