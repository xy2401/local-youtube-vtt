WEBVTT
Kind: captions
Language: zh-Hans

00:00:24.720 --> 00:00:29.369
我 Spring 的歌迷欢迎来到另一个

00:00:27.480 --> 00:00:30.269
在此安装Spring 提示

00:00:29.369 --> 00:00:33.809
我们将要讨论的分期付款

00:00:30.269 --> 00:00:35.910
基于反应性续集的数据访问

00:00:33.809 --> 00:00:37.530
当然，如果有人在关注

00:00:35.910 --> 00:00:39.780
我们一直在谈论很多

00:00:37.530 --> 00:00:41.699
最近和之后的反应式编程

00:00:39.780 --> 00:00:44.940
有充分的理由，因为它为我们提供了一种方法

00:00:41.699 --> 00:00:46.800
描述潜在的潜在

00:00:44.940 --> 00:00:49.260
异步输入和输出

00:00:46.800 --> 00:00:51.510
异步I / O并提供一种

00:00:49.260 --> 00:00:52.980
包装类型的类型，然后我们可以

00:00:51.510 --> 00:00:55.949
在该异步I / O上使用

00:00:52.980 --> 00:00:57.059
模拟世界思维的基础

00:00:55.949 --> 00:00:58.920
关于世界的思考

00:00:57.059 --> 00:01:01.470
组件之间的集成

00:00:58.920 --> 00:01:04.229
世界以及当我们转向被动时

00:01:01.470 --> 00:01:06.360
我们转向异步编程

00:01:04.229 --> 00:01:09.270
基于程序的编程，我们需要注意

00:01:06.360 --> 00:01:10.950
数据潜在的事实

00:01:09.270 --> 00:01:12.509
无限的数据将是你知道的

00:01:10.950 --> 00:01:16.080
我们正在发送的字节

00:01:12.509 --> 00:01:17.880
例如，频道上的

00:01:16.080 --> 00:01:20.189
将被发送，我们可能会得到

00:01:17.880 --> 00:01:22.229
确认之后，你知道

00:01:20.189 --> 00:01:24.270
相反，我们期望的数据

00:01:22.229 --> 00:01:26.040
从阅读中可能会到达

00:01:24.270 --> 00:01:27.810
十亿分之一秒，这可能很重要，您知道我

00:01:26.040 --> 00:01:29.460
可能会在一周内到达

00:01:27.810 --> 00:01:31.680
对，它是异步的，这是潜在的

00:01:29.460 --> 00:01:33.300
还有一个潜在的无限

00:01:31.680 --> 00:01:36.150
可能有很多，所以

00:01:33.300 --> 00:01:38.970
这些想法使我们能够

00:01:36.150 --> 00:01:41.880
现在编写垄断线程的代码

00:01:38.970 --> 00:01:43.650
尽可能少的好处

00:01:41.880 --> 00:01:46.050
那就是我们可以移动输入

00:01:43.650 --> 00:01:48.720
输出到单个太阳

00:01:46.050 --> 00:01:51.120
您平台的机制

00:01:48.720 --> 00:01:53.100
那个那个那个那个那个那个那个那个频道的东西

00:01:51.120 --> 00:01:54.659
机制可以处理移动工作

00:01:53.100 --> 00:01:55.979
跨缓冲区来回传输数据

00:01:54.659 --> 00:01:58.110
而且只有当

00:01:55.979 --> 00:02:00.960
对数据进行处理

00:01:58.110 --> 00:02:02.130
然后回到线程，然后

00:02:00.960 --> 00:02:04.049
之所以这么多是因为

00:02:02.130 --> 00:02:06.600
线程很昂贵，它们占用很多

00:02:04.049 --> 00:02:08.330
实际RAM之类的资源

00:02:06.600 --> 00:02:10.500
电脑，他们很难安排

00:02:08.330 --> 00:02:13.140
正确有效，所以需要很多

00:02:10.500 --> 00:02:15.239
输入和输出的很多很多

00:02:13.140 --> 00:02:19.140
确实超出了输入和输出的范围

00:02:15.239 --> 00:02:21.000
有效地使用线程，所以我们想

00:02:19.140 --> 00:02:22.439
重新利用我们现有的线程，因为

00:02:21.000 --> 00:02:24.330
他们很珍贵，那里有一个

00:02:22.439 --> 00:02:25.650
尽可能少地

00:02:24.330 --> 00:02:26.610
异步I / O和反应式

00:02:25.650 --> 00:02:28.920
在此基础上进行编程

00:02:26.610 --> 00:02:31.260
异步I / O启用

00:02:28.920 --> 00:02:32.640
所以人们对此感到兴奋

00:02:31.260 --> 00:02:34.770
想转向反应式编程

00:02:32.640 --> 00:02:37.220
你知道我们很久以来一直在和

00:02:34.770 --> 00:02:38.690
与人们谈论你如何拥有一些

00:02:37.220 --> 00:02:41.150
关于持久性的选择

00:02:38.690 --> 00:02:43.180
当然，我们已经看到了

00:02:41.150 --> 00:02:46.010
 The Spring Team 已经亮相

00:02:43.180 --> 00:02:48.920
Spring 数据和Spring 数据Finchley和

00:02:46.010 --> 00:02:50.780
抱歉， spring data 凯和更多

00:02:48.920 --> 00:02:53.330
支持的反应式数据访问选项

00:02:50.780 --> 00:02:54.980
包括Redis反应式的选项

00:02:53.330 --> 00:02:57.530
 Redis反应性Couchbase反应性

00:02:54.980 --> 00:03:03.520
 Cassandra和反应式MongoDB以及这些

00:02:57.530 --> 00:03:06.020
在大多数情况下不只是

00:03:03.520 --> 00:03:08.590
您所拥有的反应性等效物

00:03:06.020 --> 00:03:10.940
同步和阻塞

00:03:08.590 --> 00:03:13.490
替代品，没有我没有参加的实例

00:03:10.940 --> 00:03:16.450
很多情况下，您实际上得到的更多

00:03:13.490 --> 00:03:19.700
功能的基础

00:03:16.450 --> 00:03:22.160
实现的依据是

00:03:19.700 --> 00:03:24.890
这个异步反应驱动程序

00:03:22.160 --> 00:03:26.720
我们使用代替，而不是使用

00:03:24.890 --> 00:03:29.180
同步和阻塞驱动程序

00:03:26.720 --> 00:03:31.040
例如常规Spring 

00:03:29.180 --> 00:03:33.230
数据MongoDB我们完全使用了

00:03:31.040 --> 00:03:35.180
支持的不同驱动程序

00:03:33.230 --> 00:03:37.670
用于Spring 数据的异步I / O 

00:03:35.180 --> 00:03:39.200
反应性MongoDB驱动程序，所以我们可以做

00:03:37.670 --> 00:03:40.810
有些事情不那么容易

00:03:39.200 --> 00:03:43.310
不那么优雅不干净

00:03:40.810 --> 00:03:45.650
或者在MongoDB中为

00:03:43.310 --> 00:03:47.120
这个例子是关于查询的故事

00:03:45.650 --> 00:03:48.650
真的很不错吧

00:03:47.120 --> 00:03:51.260
 MongoDB是戴维斯的一个很好的例子

00:03:48.650 --> 00:03:54.080
我认为更好的驱动程序

00:03:51.260 --> 00:03:56.300
现在我给了反应式编程

00:03:54.080 --> 00:03:58.370
您所支持的反应式列表

00:03:56.300 --> 00:04:01.010
数据库选项，您会注意到

00:03:58.370 --> 00:04:02.480
我没有提到续集

00:04:01.010 --> 00:04:04.640
数据存储区，这是因为直到

00:04:02.480 --> 00:04:05.959
最近没有很多

00:04:04.640 --> 00:04:10.430
这里的好选择很多好选择

00:04:05.959 --> 00:04:13.519
我们拥有了我所必须的小天使

00:04:10.430 --> 00:04:15.530
李打电话给乐观的努力

00:04:13.519 --> 00:04:19.419
支持异步数据库访问

00:04:15.530 --> 00:04:20.900
在甲骨文公司宣布的一项DBA工作

00:04:19.419 --> 00:04:25.400
 2016年

00:04:20.900 --> 00:04:28.550
那几乎是几乎可以肯定的

00:04:25.400 --> 00:04:30.530
两年多以前

00:04:28.550 --> 00:04:33.940
在过渡期间已经付出了一些努力

00:04:30.530 --> 00:04:35.990
但它不在GA附近，然后

00:04:33.940 --> 00:04:37.850
我想与那口井同时

00:04:35.990 --> 00:04:41.479
随后，然后与

00:04:37.850 --> 00:04:42.890
那是我们的r2 DBC项目和r2 

00:04:41.479 --> 00:04:46.599
 BC是一个开源项目，我们

00:04:42.890 --> 00:04:50.530
坚持github.com 

00:04:46.599 --> 00:04:53.080
 r2 DBC很好

00:04:50.530 --> 00:04:56.530
是反应型关系数据库

00:04:53.080 --> 00:04:58.560
连接性API，它旨在

00:04:56.530 --> 00:05:01.330
提供一个SPI您在这里看到的内容

00:04:58.560 --> 00:05:04.450
然后是SPI的几种实现

00:05:01.330 --> 00:05:05.950
建立在适当的本机上

00:05:04.450 --> 00:05:09.040
反应性的或至少本机的

00:05:05.950 --> 00:05:12.970
异步驱动程序，然后我们浮出水面

00:05:09.040 --> 00:05:15.880
作为实施权

00:05:12.970 --> 00:05:18.280
如果您愿意，我们将具有约束力

00:05:15.880 --> 00:05:21.610
现在他们有三个有趣的绑定

00:05:18.280 --> 00:05:24.840
 PostgreSQL我们有h2，我们只有

00:05:21.610 --> 00:05:27.280
最近微软续集服务器

00:05:24.840 --> 00:05:29.560
实施，你知道敲门

00:05:27.280 --> 00:05:32.980
希望有更多的木头

00:05:29.560 --> 00:05:36.550
这些实际上是基于异步的

00:05:32.980 --> 00:05:40.300
司机对不同的司机，他们

00:05:36.550 --> 00:05:44.830
是我们希望的第一个

00:05:40.300 --> 00:05:47.800
很多权利，我们也有一个

00:05:44.830 --> 00:05:52.480
 DBA，所以如果一个DBA变得多产

00:05:47.800 --> 00:05:54.610
而且你知道人们想要适应

00:05:52.480 --> 00:05:58.479
很好，我们希望我们到卑诗省

00:05:54.610 --> 00:05:59.860
将成为基础图书馆

00:05:58.479 --> 00:06:01.810
其他还有其他

00:05:59.860 --> 00:06:03.640
将构建方便的抽象

00:06:01.810 --> 00:06:05.950
就像JDBC不是

00:06:03.640 --> 00:06:07.930
大多数人都与之互动的东西

00:06:05.950 --> 00:06:09.430
直接通常有某种

00:06:07.930 --> 00:06:11.050
那里的中介

00:06:09.430 --> 00:06:12.850
就像JDBC模板一样

00:06:11.050 --> 00:06:17.470
正确的，使较低的工作

00:06:12.850 --> 00:06:23.470
级别spi更可口，因此RT BC是

00:06:17.470 --> 00:06:26.320
没有别的了

00:06:23.470 --> 00:06:28.240
基本面的方法

00:06:26.320 --> 00:06:31.360
基于续集的反应式数据访问

00:06:28.240 --> 00:06:33.550
数据库是一个SPI，它是一个

00:06:31.360 --> 00:06:35.500
我们想成为的基础

00:06:33.550 --> 00:06:37.390
尽可能互操作，因此，如果DBA 

00:06:35.500 --> 00:06:40.479
如果有用的话，任何地方都可以

00:06:37.390 --> 00:06:43.950
我们会准备好了，嘿，谁知道

00:06:40.479 --> 00:06:46.060
也许DBA会变得完美

00:06:43.950 --> 00:06:48.820
实施，在那种情况下

00:06:46.060 --> 00:06:50.650
希望讨论我们TBC的使用，以便

00:06:48.820 --> 00:06:51.910
也许这会变得很薄

00:06:50.650 --> 00:06:54.190
我不知道的包装

00:06:51.910 --> 00:06:56.590
这就是为什么目前至少

00:06:54.190 --> 00:06:58.570
不建议用于生产排序

00:06:56.590 --> 00:07:00.310
的东西，但肯定很有趣

00:06:58.570 --> 00:07:01.720
我希望你会考虑反馈

00:07:00.310 --> 00:07:03.490
里面有很多人

00:07:01.720 --> 00:07:04.240
为此，我们当然希望

00:07:03.490 --> 00:07:07.870
这是信息

00:07:04.240 --> 00:07:11.860
但是你知道我们很愿意成为

00:07:07.870 --> 00:07:17.220
不对，我们愿意接受

00:07:11.860 --> 00:07:20.289
只是一个灵感吧，好吧，所以

00:07:17.220 --> 00:07:21.520
考虑到这一点，我们要做的是

00:07:20.289 --> 00:07:23.169
我们将使用一些新东西

00:07:21.520 --> 00:07:25.810
我们将直接通过我们使用它

00:07:23.169 --> 00:07:27.009
 TBC，然后我们将使用它

00:07:25.810 --> 00:07:29.080
一个全新的项目是

00:07:27.009 --> 00:07:30.520
反应性模拟到另一个新

00:07:29.080 --> 00:07:33.789
我们都宣布的项目

00:07:30.520 --> 00:07:37.360
春季一个平台2018年第一个是

00:07:33.789 --> 00:07:40.180
 spring数据JDBC现在spring数据JDBC是

00:07:37.360 --> 00:07:43.509
它本身不是一个新项目

00:07:40.180 --> 00:07:46.120
迄今为止的开源社区

00:07:43.509 --> 00:07:48.610
分开而分开的努力

00:07:46.120 --> 00:07:50.199
从 Spring 你知道

00:07:48.610 --> 00:07:53.190
春季投资组合项目正式

00:07:50.199 --> 00:07:57.430
从Spring-项目开始

00:07:53.190 --> 00:07:58.659
那是一个你知道一个非常

00:07:57.430 --> 00:08:00.430
有趣的努力

00:07:58.659 --> 00:08:01.870
正式折叠到

00:08:00.430 --> 00:08:03.430
项目，我鼓励您参加

00:08:01.870 --> 00:08:06.190
看看你的同步和

00:08:03.430 --> 00:08:09.009
阻止续集数据访问需求

00:08:06.190 --> 00:08:12.219
也有Spring 数据r2 DBC 

00:08:09.009 --> 00:08:15.550
你可以想像就知道

00:08:12.219 --> 00:08:17.169
与 spring data JBC集成了排序

00:08:15.550 --> 00:08:22.030
基础JDBC或在这种情况下

00:08:17.169 --> 00:08:24.940
 TBC SPI提供 spring data 习惯用法

00:08:22.030 --> 00:08:28.570
像模板一样

00:08:24.940 --> 00:08:31.000
这种情况下的客户，也支持

00:08:28.570 --> 00:08:32.560
仓库，所以我们来看看

00:08:31.000 --> 00:08:35.979
当我们同时查看两个

00:08:32.560 --> 00:08:38.529
关于那些项目RTD BC和

00:08:35.979 --> 00:08:41.500
 spring data 是今天的TBC 

00:08:38.529 --> 00:08:43.329
安装Spring 头的顺序

00:08:41.500 --> 00:08:46.360
为此，我们将建立一个新的

00:08:43.329 --> 00:08:51.190
一个或两个DBC项目，我们将

00:08:46.360 --> 00:08:52.270
用龙目岛，我会很好用的

00:08:51.190 --> 00:08:55.450
假设就是这样，我想就是全部

00:08:52.270 --> 00:08:58.570
真的需要证明一切

00:08:55.450 --> 00:09:00.130
我们将引入反应式网络

00:08:58.570 --> 00:09:01.899
因为拥有反应性的网站真是太好了

00:09:00.130 --> 00:09:03.760
我想这很容易

00:09:01.899 --> 00:09:05.380
但是我们要做的其他一切

00:09:03.760 --> 00:09:06.850
手动添加，所以我要去

00:09:05.380 --> 00:09:09.640
使用最新的Greater Spring Boot 

00:09:06.850 --> 00:09:13.270
然后我们将手动更改

00:09:09.640 --> 00:09:16.230
内置在其他Maven构建中

00:09:13.270 --> 00:09:16.230
我们想要的附录

00:09:28.480 --> 00:09:33.920
已经可以打开了

00:09:32.360 --> 00:09:36.230
我们要做的第一件事是添加

00:09:33.920 --> 00:09:37.819
里程碑存储库（如果尚未安装） 

00:09:36.230 --> 00:09:40.220
已经做到了，如果你还没有

00:09:37.819 --> 00:09:41.839
使用Spring Boot的里程碑版本

00:09:40.220 --> 00:09:44.269
当您生成项目时

00:09:41.839 --> 00:09:49.629
你会想要做的正确的

00:09:44.269 --> 00:09:55.730
没有步骤可向EBC抄送给我， 

00:09:49.629 --> 00:09:59.420
我要去我的家好，那该怎么办

00:09:55.730 --> 00:10:00.680
我们得到了那四个锅

00:09:59.420 --> 00:10:06.559
我们需要的存储库

00:10:00.680 --> 00:10:14.329
在存储库标签中，可以粘贴

00:10:06.559 --> 00:10:15.649
那里好吧，面对这些

00:10:14.329 --> 00:10:19.329
是我们需要的依赖

00:10:15.649 --> 00:10:22.129
我们的TBC，所以将它们粘贴在这里

00:10:19.329 --> 00:10:23.120
所以 spring data 是公元前2d 

00:10:22.129 --> 00:10:25.430
最新最好的

00:10:23.120 --> 00:10:28.639
大约一个星期前宣布，这是

00:10:25.430 --> 00:10:30.290
我们的TBC研究生，这是

00:10:28.639 --> 00:10:31.879
 Postgres，正如我所说，有一个

00:10:30.290 --> 00:10:33.559
这是几个版本

00:10:31.879 --> 00:10:36.439
我知道可以很好地处理挥杆数据或

00:10:33.559 --> 00:10:40.189
 TBC，所以我们用它，在我们的代码中

00:10:36.439 --> 00:10:41.600
将以低水位或公元前2d开始

00:10:40.189 --> 00:10:43.879
为了做到这一点，以开始任何

00:10:41.600 --> 00:10:45.259
为此，我们需要一个连接

00:10:43.879 --> 00:10:47.360
工厂不是，我们实际上需要一个

00:10:45.259 --> 00:10:49.689
连接到Postgres数据库，所以我

00:10:47.360 --> 00:10:51.649
我要建立一个连接工厂

00:10:49.689 --> 00:10:53.269
配置，我再次期望

00:10:51.649 --> 00:10:54.889
这将是

00:10:53.269 --> 00:10:56.749
最适合我们的

00:10:54.889 --> 00:11:00.589
到 spring boot ，希望很快有一天

00:10:56.749 --> 00:11:02.899
而不是后来的 spring boot 

00:11:00.589 --> 00:11:04.790
可以自动配置连接

00:11:02.899 --> 00:11:07.459
自动配置

00:11:04.790 --> 00:11:10.639
今天我们的数据源瑞安，所以我

00:11:07.459 --> 00:11:12.649
你会知道手指交叉那会

00:11:10.639 --> 00:11:15.410
成为我们将来可以享受的东西

00:11:12.649 --> 00:11:17.689
现在要做的很自然的事情是

00:11:15.410 --> 00:11:18.889
知道那 spring boot 

00:11:17.689 --> 00:11:19.910
有一天可能会支持它，并且

00:11:18.889 --> 00:11:23.179
可能会以

00:11:19.910 --> 00:11:24.379
熟悉并且您知道一些兼容

00:11:23.179 --> 00:11:26.569
利用我们已经在做的事情，您可以

00:11:24.379 --> 00:11:28.129
将您的连接字符串放入York 

00:11:26.569 --> 00:11:30.230
做BC连接线和Spring 

00:11:28.129 --> 00:11:32.629
数据源，然后输入URL 

00:11:30.230 --> 00:11:34.790
手动输入到您的代码中

00:11:32.629 --> 00:11:36.319
以至于你知道你会

00:11:34.790 --> 00:11:39.100
实际上使用诸如

00:11:36.319 --> 00:11:47.649
所以增加价值

00:11:39.100 --> 00:11:51.170
而且您知道Spring数据源该URL 

00:11:47.649 --> 00:11:54.649
字符串网址好，所以这是您的一种选择

00:11:51.170 --> 00:11:55.939
我能做的只是硬编码我的

00:11:54.649 --> 00:11:57.829
我不在乎用户名和密码

00:11:55.939 --> 00:12:00.230
我已经在我的本地机器上了

00:11:57.829 --> 00:12:01.730
如果要注射，就必须团结

00:12:00.230 --> 00:12:05.869
您将拥有的连接字符串

00:12:01.730 --> 00:12:08.689
挑选信息，你

00:12:05.869 --> 00:12:11.749
知道我相信你可以做到这一点

00:12:08.689 --> 00:12:12.649
我手下的java net URI 

00:12:11.749 --> 00:12:14.119
会用老式的方式

00:12:12.649 --> 00:12:18.079
我们将返回一个新的连接

00:12:14.119 --> 00:12:20.779
工厂，这需要一些

00:12:18.079 --> 00:12:21.769
配置我们的配置对象

00:12:20.779 --> 00:12:24.199
要提取到本地

00:12:21.769 --> 00:12:27.170
那里的变量，它会说Postgres 

00:12:24.199 --> 00:12:30.110
连接工厂建立它建立我

00:12:27.170 --> 00:12:34.279
要说点构建器点数据库

00:12:30.110 --> 00:12:42.619
命令密码通过什么密码

00:12:34.279 --> 00:12:45.579
订单ORS好的用户名订单和

00:12:42.619 --> 00:12:48.949
是的，我认为数据库主机

00:12:45.579 --> 00:12:50.449
本地主机好，应该是这样

00:12:48.949 --> 00:12:52.699
这是配置

00:12:50.449 --> 00:12:53.929
现在连接工厂

00:12:52.699 --> 00:12:59.779
让我们开始，这将给我们一个基本的

00:12:53.929 --> 00:13:02.600
 r2 DBC机械，我们可能还需要一个

00:12:59.779 --> 00:13:06.230
与之兼容的数据库客户端

00:13:02.600 --> 00:13:09.050
数据库客户端是一个对象

00:13:06.230 --> 00:13:11.809
支持反应式数据访问

00:13:09.050 --> 00:13:14.120
通过我们的TBC，有点像

00:13:11.809 --> 00:13:15.319
 JDBC模板的类似物，以及

00:13:14.120 --> 00:13:17.569
他们反应的世界，你注意到

00:13:15.319 --> 00:13:19.399
在某些情况下，我们已经从

00:13:17.569 --> 00:13:22.160
模板对象到客户端对象，因此

00:13:19.399 --> 00:13:23.929
反应性网络域，我们已经

00:13:22.160 --> 00:13:25.699
 spring webflix项目，然后在那里

00:13:23.929 --> 00:13:27.589
有一个网络客户端，而不是休息

00:13:25.699 --> 00:13:28.939
模板，现在我们有了

00:13:27.589 --> 00:13:31.399
 JDBC内部的数据库客户端

00:13:28.939 --> 00:13:34.699
模板，这样您就知道了

00:13:31.399 --> 00:13:38.319
好了，现在我们需要该数据库

00:13:34.699 --> 00:13:38.319
客户在这里

00:13:40.950 --> 00:13:47.640
在这里我们可以使用Builder 

00:13:43.680 --> 00:13:49.590
就像连接工厂之前一样

00:13:47.640 --> 00:13:51.300
我们现在我们稍后会看到我们可以

00:13:49.590 --> 00:13:53.070
实际上稍后再评论

00:13:51.300 --> 00:13:56.610
现在我们可以了，我想做的是

00:13:53.070 --> 00:13:58.110
想要构建一个可以运行的应用程序

00:13:56.610 --> 00:14:01.020
与并管理类型的实体

00:13:58.110 --> 00:14:04.320
您可以想象的预订和我的

00:14:01.020 --> 00:14:05.790
您已经很熟悉预订

00:14:04.320 --> 00:14:08.160
我看过一百万次

00:14:05.790 --> 00:14:12.780
您曾经看过我的演讲，所以ID为私人

00:14:08.160 --> 00:14:14.220
我们只是整数ID私有字符串

00:14:12.780 --> 00:14:17.220
会叫这个名字好，所以

00:14:14.220 --> 00:14:20.550
我要用龙目岛的东西

00:14:17.220 --> 00:14:29.520
创建吸气剂和二传手很好

00:14:20.550 --> 00:14:30.840
有我的三个领域，从那里

00:14:29.520 --> 00:14:32.640
我们要读一些数据给戴维斯

00:14:30.840 --> 00:14:33.720
我要手动创建一个存储库

00:14:32.640 --> 00:14:35.220
在这里，我要去做老式的

00:14:33.720 --> 00:14:35.880
我们要写我们的续集的方式

00:14:35.220 --> 00:14:39.000
我知道的手

00:14:35.880 --> 00:14:41.640
喘着粗气，但好处是我们可以

00:14:39.000 --> 00:14:43.760
查看一些低级RVT CSPI或

00:14:41.640 --> 00:14:45.420
 api，如果它的确不是那么糟糕

00:14:43.760 --> 00:14:48.030
实际上很平易近人

00:14:45.420 --> 00:14:50.400
当然可以平易近人

00:14:48.030 --> 00:14:52.170
比您所了解的常规JDBC 

00:14:50.400 --> 00:14:55.380
我们，所以它所做的工作做得很好

00:14:52.170 --> 00:14:56.850
同样，所以无需知道需要

00:14:55.380 --> 00:15:02.220
我一直都很胖

00:14:56.850 --> 00:15:03.300
如您所知，JDBC粉丝现在

00:15:02.220 --> 00:15:04.860
我们在其中完成的其他视频

00:15:03.300 --> 00:15:07.230
春季秘诀系列，我们制作了一些视频， 

00:15:04.860 --> 00:15:10.970
例如看我的beta 

00:15:07.230 --> 00:15:10.970
看着冬眠，我们看着

00:15:11.210 --> 00:15:19.590
 Jo Java或Q，您知道Duke项目

00:15:15.390 --> 00:15:22.590
有很多不同的努力来支持

00:15:19.590 --> 00:15:24.990
并简化使用JDBC的工作

00:15:22.590 --> 00:15:28.110
但最终我认为JDBC很漂亮

00:15:24.990 --> 00:15:29.070
强大，好的，所以我们已经有了

00:15:28.110 --> 00:15:30.540
我当然知道我们的影片

00:15:29.070 --> 00:15:32.580
看着JDBC模板，我做了一个

00:15:30.540 --> 00:15:33.840
几个看云的视频

00:15:32.580 --> 00:15:35.190
平台在那里，我

00:15:33.840 --> 00:15:36.840
介绍了如何与续集对话

00:15:35.190 --> 00:15:38.310
 JDBC模板方面的数据库

00:15:36.840 --> 00:15:43.770
因为为什么不

00:15:38.310 --> 00:15:45.780
所以在这里我们有一个预订库

00:15:43.770 --> 00:15:47.160
栓剂将支持

00:15:45.780 --> 00:15:49.140
一些通常的事情

00:15:47.160 --> 00:15:53.779
支持删除

00:15:49.140 --> 00:16:02.040
通过IE，我想将是一个整数ID 

00:15:53.779 --> 00:16:04.019
好吧，我们将回到这一点，它将

00:16:02.040 --> 00:16:11.370
支持我们只支持返回一个

00:16:04.019 --> 00:16:16.320
预订的发布者这样还行

00:16:11.370 --> 00:16:24.980
并且将支持返回保存的

00:16:16.320 --> 00:16:24.980
保留好，我会再说一遍

00:16:26.750 --> 00:16:31.920
好吧，我想，我们想删除

00:16:29.279 --> 00:16:33.750
通过ID，我们必须找到全部，并且

00:16:31.920 --> 00:16:35.100
必须保存好，所以现在让我们

00:16:33.750 --> 00:16:36.930
实施温迪的，我想我们可以

00:16:35.100 --> 00:16:38.130
从更有趣的一个开始

00:16:36.930 --> 00:16:41.190
喜欢找到我一直喜欢做的一切

00:16:38.130 --> 00:16:42.269
查询，因为您知道谁想要

00:16:41.190 --> 00:16:44.750
将数据放到那里更有趣

00:16:42.269 --> 00:16:46.740
读出来并与之一起使用

00:16:44.750 --> 00:16:48.510
我们将开始，我需要一个

00:16:46.740 --> 00:16:50.820
连接好，所以我需要一个

00:16:48.510 --> 00:16:53.279
连接才能做到这一点，所以我

00:16:50.820 --> 00:16:54.540
要在这里建立联系，我

00:16:53.279 --> 00:16:55.829
只会有一个小发现者

00:16:54.540 --> 00:17:07.400
方法这里有点方便

00:16:55.829 --> 00:17:12.209
私人单声道连接还可以，这里

00:17:07.400 --> 00:17:15.990
此连接工厂的单点

00:17:12.209 --> 00:17:19.770
点创建好，所以这可能会发布我的

00:17:15.990 --> 00:17:22.270
当我说这话时，我的连接就弹出了

00:17:19.770 --> 00:17:24.730
开始连接

00:17:22.270 --> 00:17:27.250
我想做的就是找到

00:17:24.730 --> 00:17:31.630
我要说的所有结果都解除了

00:17:27.250 --> 00:17:34.950
连接让我们处理数据并继续

00:17:31.630 --> 00:17:41.500
通过结果，流量从

00:17:34.950 --> 00:17:46.030
连接点创建语句选择

00:17:41.500 --> 00:17:48.510
全部来自保留好

00:17:46.030 --> 00:17:59.290
我们将执行该查询

00:17:48.510 --> 00:18:07.270
和那个哎呀

00:17:59.290 --> 00:18:10.120
从此完成一个迷你地图

00:18:07.270 --> 00:18:12.130
点平面图确定

00:18:10.120 --> 00:18:13.870
我们要去吵一架，我们要

00:18:12.130 --> 00:18:15.130
我要说的是行点图

00:18:13.870 --> 00:18:18.280
这就是卷起马普顿

00:18:15.130 --> 00:18:20.950
到G GTP的模板Road up map我猜

00:18:18.280 --> 00:18:22.929
我们可以简称为R 

00:18:20.950 --> 00:18:24.309
取消引用，当我们拥有

00:18:22.929 --> 00:18:26.830
我们要lambda，所以要排

00:18:24.309 --> 00:18:29.830
和行元数据是关于的元数据

00:18:26.830 --> 00:18:34.440
该行，我们将处理所有

00:18:29.830 --> 00:18:36.340
然后变成了一个物体，所以Rho dot 

00:18:34.440 --> 00:18:37.809
再次看起来很熟悉

00:18:36.340 --> 00:18:38.980
这应该看起来像行映射器，如果

00:18:37.809 --> 00:18:41.170
您曾经使用过行成员和JDBC 

00:18:38.980 --> 00:18:42.910
我们给它一个指针的模板

00:18:41.170 --> 00:18:45.700
当前结果集和当前

00:18:42.910 --> 00:18:47.140
向右偏移结果上的索引

00:18:45.700 --> 00:18:49.450
设置与行映射器非常相似

00:18:47.140 --> 00:18:51.970
春季在JDBC模板中签约

00:18:49.450 --> 00:18:54.250
 Springs常规的JDBC支持，但这是

00:18:51.970 --> 00:18:56.350
我认为所有用途都比较明智

00:18:54.250 --> 00:18:58.360
人们可能会遇到的情况

00:18:56.350 --> 00:19:01.660
在这里可能已经很熟悉了

00:18:58.360 --> 00:19:06.010
所以这里我们要返回一个整数

00:19:01.660 --> 00:19:08.230
鸭子类的ID，当我们打开一个

00:19:06.010 --> 00:19:13.780
我能得到的名字的路

00:19:08.230 --> 00:19:16.710
串那个课好吗

00:19:13.780 --> 00:19:20.410
所以我们在说什么

00:19:16.710 --> 00:19:22.240
当有人建立联系时使用

00:19:20.410 --> 00:19:26.170
连接和采取，当我们有

00:19:22.240 --> 00:19:27.850
我们要创建结果的连接

00:19:26.170 --> 00:19:29.860
提示，好的，我们要

00:19:27.850 --> 00:19:32.320
执行这个，那会给我们一个

00:19:29.860 --> 00:19:33.760
结果发布者，然后与每个

00:19:32.320 --> 00:19:35.770
结果我们回来了

00:19:33.760 --> 00:19:37.000
将结果平面化，因为它是

00:19:35.770 --> 00:19:38.830
反应性的是出版商，所以我要

00:19:37.000 --> 00:19:40.630
你参考我们要打开包装吗

00:19:38.830 --> 00:19:42.490
中间发布者，然后

00:19:40.630 --> 00:19:48.760
自己访问结果，因此

00:19:42.490 --> 00:19:53.260
每个结果每个结果都像

00:19:48.760 --> 00:19:56.050
这对于每个RTP来说，结果都是

00:19:53.260 --> 00:19:57.400
给定行映射结果，然后

00:19:56.050 --> 00:19:59.860
将行元数据转换为保留

00:19:57.400 --> 00:20:02.440
对象，我将通过拆包来做到这一点

00:19:59.860 --> 00:20:04.990
阅读和

00:20:02.440 --> 00:20:07.450
结果对象放入我的构造函数中

00:20:04.990 --> 00:20:10.180
新的保留及其结果

00:20:07.450 --> 00:20:11.740
当然将是保留的潮流

00:20:10.180 --> 00:20:13.510
对，这就是这里的合同，所以

00:20:11.740 --> 00:20:15.910
那是相当简单的权利

00:20:13.510 --> 00:20:17.890
我们只是反应式的行映射

00:20:15.910 --> 00:20:23.110
我喜欢的数据

00:20:17.890 --> 00:20:25.630
我们想要保存一些数据，所以让

00:20:23.110 --> 00:20:31.210
看到为了保存预订我们

00:20:25.630 --> 00:20:35.980
想说我们想说这个，但是

00:20:31.210 --> 00:20:37.870
连接点黑色地图迷你和什么

00:20:35.980 --> 00:20:42.340
我们要去做，我们要说给定

00:20:37.870 --> 00:20:48.750
骗局创建一个声明，以及何时

00:20:42.340 --> 00:20:52.170
插入预订名称值

00:20:48.750 --> 00:20:56.980
水边一现在美元符号之一是

00:20:52.170 --> 00:20:59.830
这是我们在spring数据中绑定的方式

00:20:56.980 --> 00:21:07.390
到DBC和我们的CBC，所以当我

00:20:59.830 --> 00:21:11.440
说绑定美元符号一个看到得到我们

00:21:07.390 --> 00:21:14.190
不要叫好名字，我要加​​上

00:21:11.440 --> 00:21:17.590
这到我要执行的数据库

00:21:14.190 --> 00:21:20.070
是的，那给我们带来了什么

00:21:17.590 --> 00:21:20.070
给我们

00:21:20.950 --> 00:21:28.940
这使我们成为结果的发布者，并且

00:21:27.500 --> 00:21:33.920
然后我们要切换

00:21:28.940 --> 00:21:40.820
绘制每个地图并出租

00:21:33.920 --> 00:21:43.340
好，所以有我们的数据，您知道我们可以

00:21:40.820 --> 00:21:46.730
其实只是说return plat map mini 

00:21:43.340 --> 00:21:53.150
我必须切换地图，然后返回

00:21:46.730 --> 00:21:55.580
我们并返回一个发布者，让我们

00:21:53.150 --> 00:22:07.450
现在就做吧好吧新

00:21:55.580 --> 00:22:07.450
预订我们的鸭子获得IP哦，谢谢

00:22:09.309 --> 00:22:13.460
好吧名字

00:22:12.169 --> 00:22:17.389
我们去那里有我们的保存

00:22:13.460 --> 00:22:18.980
很简单，我们还有什么

00:22:17.389 --> 00:22:22.639
需要在80之前删除，所以不要这样

00:22:18.980 --> 00:22:24.110
在这里这个开始连接这个

00:22:22.639 --> 00:22:30.169
这个简单，我们只说平面图很多

00:22:24.110 --> 00:22:34.850
看，我要说C点很棒

00:22:30.169 --> 00:22:41.559
声明从保留位置删除

00:22:34.850 --> 00:22:41.559
 ID等于1，我们将绑定点1 

00:22:42.159 --> 00:22:49.869
到ID，我们要说执行然后

00:22:47.330 --> 00:22:52.279
我们坐下来然后给我们一个单声道避免

00:22:49.869 --> 00:22:55.850
很简单，因为可以，所以这些

00:22:52.279 --> 00:22:57.799
我们的简单存储库

00:22:55.850 --> 00:23:00.019
实体，我们有一个连接工厂

00:22:57.799 --> 00:23:01.340
这就是我们需要的常规TBC 

00:23:00.019 --> 00:23:03.379
现在让我们继续测试此代码

00:23:01.340 --> 00:23:04.940
那实际上只是写一些代码

00:23:03.379 --> 00:23:06.049
锻炼这个，所以我们要做

00:23:04.940 --> 00:23:08.389
要创建预订

00:23:06.049 --> 00:23:11.440
此处的存储库测试

00:23:08.389 --> 00:23:16.369
好吧，我要使用反应堆环境

00:23:11.440 --> 00:23:22.159
测试支持好吧，我们就说 Spring 

00:23:16.369 --> 00:23:24.259
使用SpringRunner类进行引导测试运行

00:23:22.159 --> 00:23:29.559
好吧，我要注入

00:23:24.259 --> 00:23:38.480
预订像这样的故事

00:23:29.559 --> 00:23:40.880
创建一个测试公众无效

00:23:38.480 --> 00:23:41.960
只是为了真正测试一切

00:23:40.880 --> 00:23:43.280
一个不好的测试，但我们只想

00:23:41.960 --> 00:23:45.380
证明一切正常

00:23:43.280 --> 00:23:51.679
假设这是预订的掌声

00:23:45.380 --> 00:23:53.900
欢乐点找到所有以为平面图是

00:23:51.679 --> 00:23:58.240
库存预订正按ID删除

00:23:53.900 --> 00:24:02.000
 r点获取ID，所以我现在正在测试

00:23:58.240 --> 00:24:03.710
好，那是我要验证的一件事

00:24:02.000 --> 00:24:06.020
可行的方法，我将使用步骤验证器

00:24:03.710 --> 00:24:07.250
我会说一个板条箱删除了我们的空洞通量

00:24:06.020 --> 00:24:13.790
那会叫那个，但我要

00:24:07.250 --> 00:24:21.650
重命名以删除所有预期的OK点

00:24:13.790 --> 00:24:26.690
下一个计数将为零

00:24:21.650 --> 00:24:29.270
验证完好，然后我们

00:24:26.690 --> 00:24:32.809
要说我想写一些数据到

00:24:29.270 --> 00:24:35.120
 Devi，所以我会说运气开始

00:24:32.809 --> 00:24:39.620
要写一些电子邮件，例如

00:24:35.120 --> 00:24:43.010
只是名字，我猜所以第一，第二，第三

00:24:39.620 --> 00:24:49.450
然后我要映射每个

00:24:43.010 --> 00:24:54.559
名称进入新的预订知道名称

00:24:49.450 --> 00:25:00.790
我要把每个人都映射到一个

00:24:54.559 --> 00:25:07.280
书面数据保存可以

00:25:00.790 --> 00:25:11.049
我想确认我们有

00:25:07.280 --> 00:25:11.049
数据库中的预期数量

00:25:14.020 --> 00:25:18.850
如果我完成得很好，那里是三

00:25:17.110 --> 00:25:20.590
最后我想得到所有

00:25:18.850 --> 00:25:25.080
数据，只需确认它是

00:25:20.590 --> 00:25:25.080
像我们期望的那样工作

00:25:27.270 --> 00:25:35.470
好，就是这样，我们要说

00:25:30.190 --> 00:25:41.890
我创建了所有步骤验证器dot-com 

00:25:35.470 --> 00:25:47.500
期待下一次计数三验证

00:25:41.890 --> 00:25:50.260
完成那里，我们去了所有三个

00:25:47.500 --> 00:25:52.210
其中非常简单的是三个

00:25:50.260 --> 00:25:53.529
你知道被锻炼的方法

00:25:52.210 --> 00:25:55.840
我想我可以在这里一点

00:25:53.529 --> 00:25:58.210
将它们分别提取出来

00:25:55.840 --> 00:26:01.210
测试，但我试图看到它会工作

00:25:58.210 --> 00:26:04.380
所以让我们继续前进

00:26:01.210 --> 00:26:04.380
我们有我们应该没事的

00:26:08.280 --> 00:26:14.580
哎呀分号是必需的，这不是

00:26:11.830 --> 00:26:14.580
毕竟卡特曼

00:26:23.390 --> 00:26:31.160
 Dubi Dubi工作来了，我们继续

00:26:40.269 --> 00:26:45.279
我想我酷的是绿色的工作

00:26:43.059 --> 00:26:49.950
应该给你看数据库吧

00:26:45.279 --> 00:26:49.950
 P续集-您订购订单

00:26:50.609 --> 00:26:57.009
你知道我需要让我们再试一次

00:26:53.229 --> 00:26:59.139
从保留我的意思是我摆脱了

00:26:57.009 --> 00:27:01.649
三个记录，我们要运行

00:26:59.139 --> 00:27:01.649
再次测试

00:27:06.810 --> 00:27:15.030
好吧，从预订中选择所有

00:27:12.390 --> 00:27:16.260
我们去了，所以我们的记录是正确的

00:27:15.030 --> 00:27:18.720
这样就可以了那很好

00:27:16.260 --> 00:27:20.370
这是我们两个DBC非常底层的基础

00:27:18.720 --> 00:27:21.900
但还不错，我认为这非常

00:27:20.370 --> 00:27:22.950
功能真的很干净很容易

00:27:21.900 --> 00:27:28.500
跟...共事

00:27:22.950 --> 00:27:30.240
太好了，我们现在需要

00:27:28.500 --> 00:27:34.640
再走一步，我们需要走一步

00:27:30.240 --> 00:27:37.140
更进一步，让我们现在使用spring数据

00:27:34.640 --> 00:27:38.840
或两个卑诗省项目我要做的是

00:27:37.140 --> 00:27:41.190
我要评论这个仓库

00:27:38.840 --> 00:27:42.810
很有帮助，尽管已经很容易了

00:27:41.190 --> 00:27:44.610
虽然足够简洁，但我们要

00:27:42.810 --> 00:27:47.190
评论说我要用Spring 

00:27:44.610 --> 00:27:50.490
数据是送往卑诗省的，这将使我们

00:27:47.190 --> 00:27:53.760
生活明显容易了

00:27:50.490 --> 00:27:55.080
尽管以某种方式还不容易

00:27:53.760 --> 00:27:59.070
我要离开这里，这很好

00:27:55.080 --> 00:28:00.030
但是我们实际上并不需要这个

00:27:59.070 --> 00:28:01.290
只是要创建另一个配置

00:28:00.030 --> 00:28:03.540
上课，但没有理由

00:28:01.290 --> 00:28:06.780
可能与您认识的不一样

00:28:03.540 --> 00:28:12.480
主要配置类扩展

00:28:06.780 --> 00:28:14.640
当我覆盖此时，抽象是2d BC 

00:28:12.480 --> 00:28:16.700
方法中的连接因子方法

00:28:14.640 --> 00:28:19.650
为了提供那个回应

00:28:16.700 --> 00:28:22.470
我们只是注入连接

00:28:19.650 --> 00:28:26.340
我们已经创造的因素

00:28:22.470 --> 00:28:30.590
我经常说的构造函数返回

00:28:26.340 --> 00:28:37.160
点连接工厂我要说的

00:28:30.590 --> 00:28:39.960
启用Archie vc +的配置

00:28:37.160 --> 00:28:42.150
好吧，那就是很难

00:28:39.960 --> 00:28:44.640
我们需要做的工作

00:28:42.150 --> 00:28:47.400
注释我们的东西我们的实体

00:28:44.640 --> 00:28:49.020
 ID，所以我们已经中途回家了

00:28:47.400 --> 00:28:50.490
然后我们需要创建一个新的存储库

00:28:49.020 --> 00:28:53.220
没办法，所以我们可以很容易地做到这一点

00:28:50.490 --> 00:28:58.320
我们可以说接口保留

00:28:53.220 --> 00:29:00.810
存储库扩展了反应堆

00:28:58.320 --> 00:29:04.860
存储库管理其预订

00:29:00.810 --> 00:29:06.690
类型为整数的主键，即

00:29:04.860 --> 00:29:08.250
这就是配置

00:29:06.690 --> 00:29:09.840
部分ABC，我们目前需要

00:29:08.250 --> 00:29:12.180
希望在一天之内

00:29:09.840 --> 00:29:14.730
遥不可及的未来，自动配置的

00:29:12.180 --> 00:29:17.340
意思是说这并不难

00:29:14.730 --> 00:29:19.260
说对了，但是它仍然是代码

00:29:17.340 --> 00:29:19.600
我可以轻松想象 spring boot 在做什么

00:29:19.260 --> 00:29:21.429
形成

00:29:19.600 --> 00:29:24.130
这样我就可以创建这个界面

00:29:21.429 --> 00:29:26.850
在这个实体上，在我的路上，我们可以

00:29:24.130 --> 00:29:26.850
回到我们的测试

00:29:38.080 --> 00:29:45.760
好吧那怎么样，所以我我们做得很好

00:29:44.260 --> 00:29:48.310
看那个吧

00:29:45.760 --> 00:29:51.040
有一个简单的测试，一切都是

00:29:48.310 --> 00:29:52.840
工作很好，你知道我们可以

00:29:51.040 --> 00:29:59.730
应该让我删除数据

00:29:52.840 --> 00:29:59.730
万一有再次运行

00:30:06.660 --> 00:30:12.990
看这里，我们走了，所以有我们的数据，所以

00:30:09.750 --> 00:30:15.450
您会看到这是一个很好的简便方法

00:30:12.990 --> 00:30:17.850
得到一个反应性的续集基础

00:30:15.450 --> 00:30:19.320
积极显然这是你知道的

00:30:17.850 --> 00:30:24.360
您也可以创建自定义查询

00:30:19.320 --> 00:30:29.280
我可以说找到所有的保留

00:30:24.360 --> 00:30:31.590
名称字符串名称正确，不是

00:30:29.280 --> 00:30:32.610
支持基于查询的自动派生

00:30:31.590 --> 00:30:34.470
在方法名称上

00:30:32.610 --> 00:30:39.990
因此，为了做到这一点，您必须说

00:30:34.470 --> 00:30:44.070
添加查询从预订中全选

00:30:39.990 --> 00:30:45.930
名字在哪儿发表，然后我们

00:30:44.070 --> 00:30:48.420
可以在这里实际测试

00:30:45.930 --> 00:30:51.810
实际上现在说这个点保留

00:30:48.420 --> 00:30:54.960
我通过名称和名称找到存储库

00:30:51.810 --> 00:30:59.670
将是第一个并断言会给

00:30:54.960 --> 00:31:02.880
我们一个结果，我要说找到

00:30:59.670 --> 00:31:05.490
首先我们要期待一个

00:31:02.880 --> 00:31:07.830
返回，然后验证其是否完全正常

00:31:05.490 --> 00:31:10.370
这就是我们的自定义查询

00:31:07.830 --> 00:31:10.370
看起来像什么

00:31:20.320 --> 00:31:24.100
好的还不错吧，所以我们能够

00:31:22.690 --> 00:31:26.890
当我们走回去时，我们找到了一个

00:31:24.100 --> 00:31:29.410
我们以为我们期望这可以使生活

00:31:26.890 --> 00:31:31.480
容易，现在我们还有很长的路要走

00:31:29.410 --> 00:31:32.800
想想这一切就像你知道的那样

00:31:31.480 --> 00:31:35.080
这为每个人解决了所有问题

00:31:32.800 --> 00:31:36.610
当然不是明天了

00:31:35.080 --> 00:31:37.630
有很多有趣的事情

00:31:36.610 --> 00:31:39.610
您现在可以在这里做的可能性

00:31:37.630 --> 00:31:43.960
我们获得基于反应性续集的数据访问

00:31:39.610 --> 00:31:45.700
反应式编程的好处之一

00:31:43.960 --> 00:31:47.110
一件事是你知道的一种

00:31:45.700 --> 00:31:48.640
有趣的是看

00:31:47.110 --> 00:31:50.380
我们可以在此处选择互操作性

00:31:48.640 --> 00:31:53.770
其实那里有项目

00:31:50.380 --> 00:31:56.020
旨在支持整合

00:31:53.770 --> 00:31:57.730
例如Zipkin并分发赛车

00:31:56.020 --> 00:31:59.530
和千分尺

00:31:57.730 --> 00:32:01.180
与这些项目积累权利

00:31:59.530 --> 00:32:02.500
已经有连接池了

00:32:01.180 --> 00:32:03.760
正在开发支持我的意思是

00:32:02.500 --> 00:32:07.420
有各种各样有趣的东西

00:32:03.760 --> 00:32:09.190
在艺术家内外发生

00:32:07.420 --> 00:32:10.600
独特的项目和生态系统

00:32:09.190 --> 00:32:12.220
围绕它创建

00:32:10.600 --> 00:32:16.180
所以让我很有趣地看看

00:32:12.220 --> 00:32:16.690
我认为这个API确实是

00:32:16.180 --> 00:32:19.200
方便

00:32:16.690 --> 00:32:22.900
我本身喜欢rgbc API，也喜欢

00:32:19.200 --> 00:32:25.120
我们的TBC支持的反应性Spring数据为

00:32:22.900 --> 00:32:27.660
好吧，你可以看到我能够

00:32:25.120 --> 00:32:32.110
落入我只是评论出来

00:32:27.660 --> 00:32:33.250
添加了ID注释和一个表I 

00:32:32.110 --> 00:32:35.410
必须创建这个样板

00:32:33.250 --> 00:32:37.780
在这里配置，但这不是很大

00:32:35.410 --> 00:32:39.480
真正做到了

00:32:37.780 --> 00:32:41.890
你知道的代码

00:32:39.480 --> 00:32:43.570
我必须支付的开销，我什至

00:32:41.890 --> 00:32:46.000
得到我免费得到的所有东西

00:32:43.570 --> 00:32:47.650
我做到了我得到的同样的东西

00:32:46.000 --> 00:32:49.150
必须找到所有的tallit和所有这一切

00:32:47.650 --> 00:32:51.070
如果我免费得到，我得到了

00:32:49.150 --> 00:32:53.260
新方法，这是一个自定义查询

00:32:51.070 --> 00:32:55.000
使用以下命令将我的平板映射到此参数

00:32:53.260 --> 00:32:58.000
几乎没有没有努力没有

00:32:55.000 --> 00:32:59.950
映射否否排队或

00:32:58.000 --> 00:33:01.720
像这样的东西

00:32:59.950 --> 00:33:05.050
我希望你也喜欢

00:33:01.720 --> 00:33:07.030
显然这是非常自然的契合

00:33:05.050 --> 00:33:09.310
用spring webflix，所以如果你想

00:33:07.030 --> 00:33:10.840
从创建一个状态反应端

00:33:09.310 --> 00:33:12.370
数据库循环一直撕到

00:33:10.840 --> 00:33:13.810
 Web层并通过安全层

00:33:12.370 --> 00:33:14.860
还有所有这些东西，然后又回来

00:33:13.810 --> 00:33:16.870
现在就可以做到

00:33:14.860 --> 00:33:19.180
Spring 腹板通量端点

00:33:16.870 --> 00:33:21.700
提供了这些数据，您也可以

00:33:19.180 --> 00:33:25.870
与我们的插座一起使用

00:33:21.700 --> 00:33:27.640
由开发的协议

00:33:25.870 --> 00:33:30.340
支持反应性的Facebook 

00:33:27.640 --> 00:33:31.550
互操作性是有线协议

00:33:30.340 --> 00:33:32.900
有一个

00:33:31.550 --> 00:33:34.850
目前至少三个不同

00:33:32.900 --> 00:33:36.880
客户端使用JavaScript时使用C ++ 

00:33:34.850 --> 00:33:40.190
当然是Java中的一个

00:33:36.880 --> 00:33:41.710
由电抗器提供动力，您可以使用

00:33:40.190 --> 00:33:44.650
要知道火就忘了

00:33:41.710 --> 00:33:46.520
请求/响应发布/订阅和完整

00:33:44.650 --> 00:33:48.200
双向复用和

00:33:46.520 --> 00:33:49.940
流媒体，我的意思是你可以各种各样

00:33:48.200 --> 00:33:51.980
有趣的东西，并且内置

00:33:49.940 --> 00:33:54.770
在协议级别支持

00:33:51.980 --> 00:33:57.740
传达可用性，以便您可以

00:33:54.770 --> 00:34:01.030
使用这个，你会知道像r2这样的技术

00:33:57.740 --> 00:34:02.960
 DBC和spring是两个DBC 

00:34:01.030 --> 00:34:04.970
像我们的插座和

00:34:02.960 --> 00:34:10.130
像Spring Web Flex这样的技术

00:34:04.970 --> 00:34:12.620
一个完全打算的反应堆

00:34:10.130 --> 00:34:16.610
了解我们可能想到的

00:34:12.620 --> 00:34:18.320
有点像传统的api 

00:34:16.610 --> 00:34:19.669
是的，所以我的朋友们非常感谢

00:34:18.320 --> 00:34:23.360
我希望你从中得到一些东西

00:34:19.669 --> 00:34:27.429
一如既往的热烈感谢

00:34:23.360 --> 00:34:27.429
看，下次见

00:34:32.630 --> 00:34:34.690
您

