WEBVTT
Kind: captions
Language: zh-Hans

00:00:13.870 --> 00:00:16.180
我们要看春天

00:00:15.100 --> 00:00:19.000
整合是整合的一种方式

00:00:16.180 --> 00:00:21.330
否则，将保留两个数据源，并且

00:00:19.000 --> 00:00:24.910
服务和春季灌溉

00:00:21.330 --> 00:00:27.250
从中汲取灵感

00:00:24.910 --> 00:00:28.779
鲍比·霍普和格里高尔的精彩著作

00:00:27.250 --> 00:00:30.730
沃尔夫称企业模式

00:00:28.779 --> 00:00:32.050
应用程序集成和整体

00:00:30.730 --> 00:00:34.300
该框架的重点是使

00:00:32.050 --> 00:00:36.580
整合原本完全不同的

00:00:34.300 --> 00:00:39.010
服务和数据源提升数据

00:00:36.580 --> 00:00:39.940
资料来源还不错，就这样，就这样

00:00:39.010 --> 00:00:41.379
关于做不做的事情

00:00:39.940 --> 00:00:43.449
一定知道如何与每个人交谈

00:00:41.379 --> 00:00:45.190
对方互相交谈，最容易

00:00:43.449 --> 00:00:46.719
做到这一点的方法是考虑

00:00:45.190 --> 00:00:51.450
就事件而言，世界还是

00:00:46.719 --> 00:00:54.190
消息，所以也许我想要我想要

00:00:51.450 --> 00:00:55.149
观察文件系统上的文件

00:00:54.190 --> 00:00:56.860
一旦有一个新文件，我就要

00:00:55.149 --> 00:00:59.500
发布事件，然后我们生成

00:00:56.860 --> 00:01:01.989
那个权利，或者我想观察

00:00:59.500 --> 00:01:05.350
电子邮件和收件箱中

00:01:01.989 --> 00:01:07.149
想观察您知道新记录添加

00:01:05.350 --> 00:01:09.430
将其发送到数据源，数据库权限或

00:01:07.149 --> 00:01:11.140
或这些东西是什么

00:01:09.430 --> 00:01:12.880
各种各样的不同，你知道这些

00:01:11.140 --> 00:01:14.350
这些都暗示着不同的API， 

00:01:12.880 --> 00:01:16.720
不同的技术，但春天

00:01:14.350 --> 00:01:18.610
整合表明底层

00:01:16.720 --> 00:01:19.990
细节为您隐藏了，所以现在您

00:01:18.610 --> 00:01:21.820
可以认为它只是一个

00:01:19.990 --> 00:01:24.340
消息被发布，并且有

00:01:21.820 --> 00:01:25.960
一个适配器，它将发布

00:01:24.340 --> 00:01:27.610
给您的消息，显然您有

00:01:25.960 --> 00:01:29.770
插入，但春天的否定

00:01:27.610 --> 00:01:32.560
带有一个完整的工具箱

00:01:29.770 --> 00:01:34.210
创新创新适配器，然后

00:01:32.560 --> 00:01:36.220
消息发布后，您将拥有

00:01:34.210 --> 00:01:38.439
然后处理的能力

00:01:36.220 --> 00:01:39.549
接受并执行消息的权利

00:01:38.439 --> 00:01:41.799
有趣的事情也许你

00:01:39.549 --> 00:01:43.600
想要延续下去并转型

00:01:41.799 --> 00:01:44.890
有效载荷或它们或元数据

00:01:43.600 --> 00:01:47.710
关于称为编辑的消息

00:01:44.890 --> 00:01:50.020
也许你想把它分成你自己

00:01:47.710 --> 00:01:53.470
知道很多小的消息

00:01:50.020 --> 00:01:54.820
想要有选择地路由消息

00:01:53.470 --> 00:01:57.250
根据某种条件

00:01:54.820 --> 00:01:58.990
另一个组件可能想要

00:01:57.250 --> 00:02:00.820
与拆分相反，可能想要

00:01:58.990 --> 00:02:03.159
当我很棒的时候

00:02:00.820 --> 00:02:04.329
拆分成一条消息的结果

00:02:03.159 --> 00:02:06.909
然后使该信息永久存在

00:02:04.329 --> 00:02:08.619
下游，所以你知道很多

00:02:06.909 --> 00:02:11.739
您可以用

00:02:08.619 --> 00:02:15.360
看到消息后立即发送消息

00:02:11.739 --> 00:02:17.470
一旦发布，最后

00:02:15.360 --> 00:02:20.230
收到消息后，您便可以

00:02:17.470 --> 00:02:23.470
将其发送到下游组件

00:02:20.230 --> 00:02:26.170
像适配器或网关一样

00:02:23.470 --> 00:02:27.880
而不是适应数据

00:02:26.170 --> 00:02:30.970
在你可以接受消息

00:02:27.880 --> 00:02:32.590
适于将其发送给

00:02:30.970 --> 00:02:34.120
将其发送到

00:02:32.590 --> 00:02:35.790
外面的世界，所以也许他们也许

00:02:34.120 --> 00:02:38.830
信息的起源

00:02:35.790 --> 00:02:40.930
处理流程来自一个

00:02:38.830 --> 00:02:43.210
文件系统，但可能是由于

00:02:40.930 --> 00:02:44.800
您要上传的处理

00:02:43.210 --> 00:02:46.690
 FTP服务器上的内容，或者

00:02:44.800 --> 00:02:49.690
也许您想在

00:02:46.690 --> 00:02:51.250
例如，以QP Rabbitmq经纪人的名字

00:02:49.690 --> 00:02:53.200
对，这些都是截然不同的

00:02:51.250 --> 00:02:55.450
可能性，但是通过写你的

00:02:53.200 --> 00:02:57.550
您可以使用Spring Novation编写的代码

00:02:55.450 --> 00:03:00.690
一个组件模型，然后您知道

00:02:57.550 --> 00:03:03.490
撰写更强大，更强大的解决方案

00:03:00.690 --> 00:03:05.110
从这些较小的单独关注的类别中

00:03:03.490 --> 00:03:06.820
组件，所以让我们看一下

00:03:05.110 --> 00:03:08.770
今天我们要去

00:03:06.820 --> 00:03:10.140
回到提到的例子，否则我们

00:03:08.770 --> 00:03:12.820
要建立一个整合

00:03:10.140 --> 00:03:16.060
监视充满文件的目录并

00:03:12.820 --> 00:03:18.040
然后取出文件，然后

00:03:16.060 --> 00:03:20.350
处理它们以某种方式处理它们

00:03:18.040 --> 00:03:22.210
然后将它们上传到FTP服务器

00:03:20.350 --> 00:03:24.330
我碰巧有一个FTP服务器

00:03:22.210 --> 00:03:32.170
在我的机器上，所以我要说

00:03:24.330 --> 00:03:35.440
 FTP抱歉的文件-文件以及我们所需要的

00:03:32.170 --> 00:03:36.970
要做文件监控文件

00:03:35.440 --> 00:03:39.220
集成好，所以我们要打电话给

00:03:36.970 --> 00:03:40.690
那我要带一个新的

00:03:39.220 --> 00:03:42.790
件支持，我们将其引入此处

00:03:40.690 --> 00:03:44.320
我们要带来春天

00:03:42.790 --> 00:03:46.480
整合正确，所以有

00:03:44.320 --> 00:03:53.380
我们也需要这里的集成支持

00:03:46.480 --> 00:03:55.200
我们需要他们，我想那会做

00:03:53.380 --> 00:03:57.370
实际上，那应该足够

00:03:55.200 --> 00:03:59.620
现在我们要带一些

00:03:57.370 --> 00:04:03.760
单个Spring 集成模块

00:03:59.620 --> 00:04:05.170
为她的文件和FTP，但那

00:04:03.760 --> 00:04:07.420
应该这样做，所以让我们继续前进

00:04:05.170 --> 00:04:08.830
生成，我们将获得一个zip文件

00:04:07.420 --> 00:04:10.030
我们可以在ID中打开文件

00:04:08.830 --> 00:04:12.790
你真的不知道吗

00:04:10.030 --> 00:04:14.350
不管是哪个IDE，所以我要去

00:04:12.790 --> 00:04:16.060
说文件集成我想要

00:04:14.350 --> 00:04:18.820
我要做的是要监视一个

00:04:16.060 --> 00:04:21.220
目录，然后如果有新文件

00:04:18.820 --> 00:04:23.350
我要获取该文件的净目录

00:04:21.220 --> 00:04:24.790
我想以某种方式改变它

00:04:23.350 --> 00:04:27.610
然后我要发送转换后的

00:04:24.790 --> 00:04:29.530
数据发送到下游系统

00:04:27.610 --> 00:04:32.620
一个FTP服务器，所以我们要

00:04:29.530 --> 00:04:34.540
使用

00:04:32.620 --> 00:04:37.300
 Spring集成Java配置

00:04:34.540 --> 00:04:39.910
 DSL，因为

00:04:37.300 --> 00:04:40.280
 Spring Boot 1.4包含在

00:04:39.910 --> 00:04:42.500
Spring 

00:04:40.280 --> 00:04:43.970
入门集成的依赖性，所以这里

00:04:42.500 --> 00:04:46.010
就在这里，我认为Java 

00:04:43.970 --> 00:04:47.450
 DSL是最酷的事物之一

00:04:46.010 --> 00:04:49.460
曾经发生过，这是pregnan，我说

00:04:47.450 --> 00:04:51.080
作为一个在春季工作的人

00:04:49.460 --> 00:04:53.150
创造很多你知道很多

00:04:51.080 --> 00:04:55.490
不同的年份，你知道说话

00:04:53.150 --> 00:04:58.190
在过去十年的大部分时间里

00:04:55.490 --> 00:05:00.139
爱春季灌溉，所以DSL给我

00:04:58.190 --> 00:05:03.139
那是很重要的事情，我不会

00:05:00.139 --> 00:05:04.280
认为它在阳光下有足够的时间，所以

00:05:03.139 --> 00:05:06.290
我们要谈论它，我们要

00:05:04.280 --> 00:05:08.570
今天就构建一个应用程序而言

00:05:06.290 --> 00:05:12.020
整合的基础，让我们构建我们的

00:05:08.570 --> 00:05:13.220
我说什么的时候第一次整合好

00:05:12.020 --> 00:05:17.630
我要做的是建立一个

00:05:13.220 --> 00:05:18.560
在一个数据中寻找数据的直觉

00:05:17.630 --> 00:05:20.110
目录，所以我要建立一个

00:05:18.560 --> 00:05:24.650
集成流程我将其称为

00:05:20.110 --> 00:05:27.140
文件权和目录

00:05:24.650 --> 00:05:31.940
目录，我将只提供信息

00:05:27.140 --> 00:05:36.500
称它为输入目录，否则我将

00:05:31.940 --> 00:05:39.200
默认为这里我的硬编码路径

00:05:36.500 --> 00:05:41.690
目录中的桌面，我们将其称为文件

00:05:39.200 --> 00:05:44.600
好的，那将只是Java IO文件

00:05:41.690 --> 00:05:46.520
我将使用spring属性

00:05:44.600 --> 00:05:49.160
占位符分辨率，以使

00:05:46.520 --> 00:05:51.080
价值真实，我将使用dlci DSL 

00:05:49.160 --> 00:05:53.840
在这里我要说的是

00:05:51.080 --> 00:05:55.460
来自某物的新记录

00:05:53.840 --> 00:05:57.890
这种情况下，我需要提供入站

00:05:55.460 --> 00:06:00.229
适配器的权利是

00:05:57.890 --> 00:06:01.820
我要去的消息流的起源

00:06:00.229 --> 00:06:04.039
回应，我将开始这个

00:06:01.820 --> 00:06:05.870
有消息时的处理流程

00:06:04.039 --> 00:06:08.750
来自此带内适配器的

00:06:05.870 --> 00:06:10.580
嵌入式Apter将成为

00:06:08.750 --> 00:06:13.070
 ftp适配器，所以我需要带Spring 

00:06:10.580 --> 00:06:15.979
集成FTP，在那里您可以看到

00:06:13.070 --> 00:06:17.180
这里还有很多其他模块

00:06:15.979 --> 00:06:18.740
然后当然还有更多

00:06:17.180 --> 00:06:21.289
除了开源

00:06:18.740 --> 00:06:24.070
春天没有的世界

00:06:21.289 --> 00:06:26.419
位置本身，所以我会说文件点

00:06:24.070 --> 00:06:29.120
入站适配器，我想做的是

00:06:26.419 --> 00:06:31.130
我要监视

00:06:29.120 --> 00:06:32.570
目录非常好，我不需要

00:06:31.130 --> 00:06:34.490
提供一个比较器，所以我将其保留为

00:06:32.570 --> 00:06:36.169
是，我要指定您是否认为

00:06:34.490 --> 00:06:37.340
我要说的是我要自动

00:06:36.169 --> 00:06:40.669
创建目录（如果不存在） 

00:06:37.340 --> 00:06:42.050
绝对我想防止重复

00:06:40.669 --> 00:06:45.140
很公平

00:06:42.050 --> 00:06:47.060
我认为那就足够了

00:06:45.140 --> 00:06:48.680
现在我想做的是

00:06:47.060 --> 00:06:50.900
改变它，我们会回到什么

00:06:48.680 --> 00:06:52.460
我稍后会处理这个

00:06:50.900 --> 00:06:54.289
现在我要创建一个

00:06:52.460 --> 00:06:55.969
告诉它使用这个变压器

00:06:54.289 --> 00:06:58.039
变压器的合同是

00:06:55.969 --> 00:06:59.869
其实很简单

00:06:58.039 --> 00:07:02.569
这是我们要使用的通用变压器

00:06:59.869 --> 00:07:08.749
将类型文件的有效负载

00:07:02.569 --> 00:07:11.119
我们将发送一个字符串，我们

00:07:08.749 --> 00:07:12.559
必须执行该合同，所以有

00:07:11.119 --> 00:07:15.099
这项权利，实际上可以是

00:07:12.559 --> 00:07:17.589
 lambda对，因此很自然

00:07:15.099 --> 00:07:22.399
 lambda如果我们想要我们只需要

00:07:17.589 --> 00:07:24.169
指定这个，然后我们可以摆脱

00:07:22.399 --> 00:07:32.330
可以带来很多好处的所有权利

00:07:24.169 --> 00:07:34.699
清洁工哎呀，然后我要我

00:07:32.330 --> 00:07:37.219
要发送出去，所以我会处理

00:07:34.699 --> 00:07:39.649
一个适配器的结果另一个适配器

00:07:37.219 --> 00:07:42.289
在这种情况下，我要做的是

00:07:39.649 --> 00:07:45.020
我将其发送到FTP服务器

00:07:42.289 --> 00:07:46.249
出站适配器，我不能

00:07:45.020 --> 00:07:48.020
你不知道那是行不通的吗

00:07:46.249 --> 00:07:50.119
像这样，实际上有一个非常

00:07:48.020 --> 00:07:53.389
预期的便捷界面

00:07:50.119 --> 00:07:55.430
这里称为需要一个

00:07:53.389 --> 00:07:58.759
适配器对象和消息手

00:07:55.430 --> 00:08:00.919
重新指定，以便我们是否仅提供此lambda 

00:07:58.759 --> 00:08:04.580
然后我们可以在这里使用适配器方法

00:08:00.919 --> 00:08:07.519
在这里建立我们的流程

00:08:04.580 --> 00:08:10.209
接受了期望它期待一个FTP会话

00:08:07.519 --> 00:08:15.289
我说我现在有一家工厂

00:08:10.209 --> 00:08:15.649
在我的um上运行的FTP服务器

00:08:15.289 --> 00:08:17.659
机

00:08:15.649 --> 00:08:21.610
所以我们只创建一个简单的会话

00:08:17.659 --> 00:08:25.339
适用于FTP文件的工厂

00:08:21.610 --> 00:08:27.199
好吧，看来我没有

00:08:25.339 --> 00:08:33.139
为此，请在类路径上输入

00:08:27.199 --> 00:08:41.719
带来 Spring Integration FTP 

00:08:33.139 --> 00:08:44.420
好的FTP文件，我想那是

00:08:41.719 --> 00:08:48.230
足以让我看到我们想要默认值

00:08:44.420 --> 00:08:50.240
 FTP会话工厂正确，所以保存

00:08:48.230 --> 00:08:56.360
自己从痛苦中我们将要

00:08:50.240 --> 00:08:59.449
这样说，我将设置

00:08:56.360 --> 00:09:01.310
端口等于21 21你知道正确的

00:08:59.449 --> 00:09:06.510
顺便说一句在这里要做的就是使用

00:09:01.310 --> 00:09:10.140
属性，所以我应该说您知道FTP 

00:09:06.510 --> 00:09:14.490
端口21 21进入端口

00:09:10.140 --> 00:09:18.570
我想要一个用户名，我只提供

00:09:14.490 --> 00:09:22.050
一些默认值，因此用户名

00:09:18.570 --> 00:09:25.820
将会是J long的默认值，而我会

00:09:22.050 --> 00:09:28.700
使用密码，所以我会说ftp密码

00:09:25.820 --> 00:09:31.740
否则我们输入密码

00:09:28.700 --> 00:09:34.140
我们去那里，然后我们就可以

00:09:31.740 --> 00:09:35.910
配置我必须是会话工厂

00:09:34.140 --> 00:09:42.950
这些默认值，所以我们将说FTP 

00:09:35.910 --> 00:09:47.070
会话工厂密码关闭PW和

00:09:42.950 --> 00:09:51.690
我们说设置用户名等于的FTP 

00:09:47.070 --> 00:09:53.520
用户名，我认为不会这样做

00:09:51.690 --> 00:09:56.070
我们会像完成操作一样将其返回

00:09:53.520 --> 00:09:58.200
我们已经配置好了，现在

00:09:56.070 --> 00:10:00.540
您可以使用只需要的相同代码

00:09:58.200 --> 00:10:02.070
通过-T参数提供属性

00:10:00.540 --> 00:10:04.640
或在应用程序中呃属性或

00:10:02.070 --> 00:10:07.140
让我们从FTP点开始

00:10:04.640 --> 00:10:08.970
所以我们现在已经完成了

00:10:07.140 --> 00:10:11.400
需要告诉春天注入

00:10:08.970 --> 00:10:13.800
这里作为合作对象，所以我们将

00:10:11.400 --> 00:10:16.230
我们将指定想要FTP会话

00:10:13.800 --> 00:10:21.240
工厂或默认的FTP会话

00:10:16.230 --> 00:10:23.760
工厂在这里，我们去了，什么

00:10:21.240 --> 00:10:25.140
将会发生的事情

00:10:23.760 --> 00:10:29.960
是我们要运行此适配器

00:10:25.140 --> 00:10:35.910
这将需要

00:10:29.960 --> 00:10:37.110
为我们生成一个文件

00:10:35.910 --> 00:10:39.870
去看看它会尝试和

00:10:37.110 --> 00:10:42.570
为我们创建文件，所以我们需要

00:10:39.870 --> 00:10:43.890
给它一种方法去做，而我

00:10:42.570 --> 00:10:46.560
要跳过这里我要去

00:10:43.890 --> 00:10:47.490
继续并创建一个临时的

00:10:46.560 --> 00:10:55.080
对不起，我要继续前进， 

00:10:47.490 --> 00:10:59.970
创建一个远程目录

00:10:55.080 --> 00:11:01.500
目录我要查找的文件名

00:10:59.970 --> 00:11:06.660
用于查找实施文件

00:11:01.500 --> 00:11:07.680
名称表达式生成器文件名

00:11:06.660 --> 00:11:10.170
发电机，我们要去

00:11:07.680 --> 00:11:11.820
提供一个新的文件名生成器并

00:11:10.170 --> 00:11:12.930
我们的文件名生成器将是

00:11:11.820 --> 00:11:14.850
根据头部空间，我们将

00:11:12.930 --> 00:11:16.380
我们将看看传入的

00:11:14.850 --> 00:11:18.870
消息正确的 Spring Integration 

00:11:16.380 --> 00:11:19.930
我将从中提取的消息

00:11:18.870 --> 00:11:24.040
留言

00:11:19.930 --> 00:11:27.520
标头叫做正确的文件名

00:11:24.040 --> 00:11:29.710
我们在这里有文件名，我将

00:11:27.520 --> 00:11:33.010
让我们将其提取出来并作为

00:11:29.710 --> 00:11:36.570
珍惜这里，我会说我想

00:11:33.010 --> 00:11:42.990
获取值字符串文件名等于

00:11:36.570 --> 00:11:47.200
弦类演员哦，唐纳德和所有

00:11:42.990 --> 00:11:48.399
返回文件名点和我们

00:11:47.200 --> 00:11:51.580
要在这里做我的朋友是我们

00:11:48.399 --> 00:11:53.230
将要接收传入的文件

00:11:51.580 --> 00:11:54.940
应该是正确的图像，就我而言

00:11:53.230 --> 00:11:56.830
我期待图像，我们将

00:11:54.940 --> 00:11:58.120
拆分我们要去的数据

00:11:56.830 --> 00:12:00.640
要处理数据并打开它

00:11:58.120 --> 00:12:02.890
并问你我们的代表

00:12:00.640 --> 00:12:04.209
该图像的所以它将是一个

00:12:02.890 --> 00:12:06.880
文本文件，所以我要做的是

00:12:04.209 --> 00:12:09.880
将拆分传入的文件

00:12:06.880 --> 00:12:12.100
使用正则表达式命名

00:12:09.880 --> 00:12:15.550
期间，然后我会说我

00:12:12.100 --> 00:12:17.740
想要使用的第一部分

00:12:15.550 --> 00:12:21.070
名称，然后我将其重命名为

00:12:17.740 --> 00:12:23.890
点txt可以，如果是点jpg 

00:12:21.070 --> 00:12:25.510
那我们就把它当成jpg的食物吧

00:12:23.890 --> 00:12:27.490
我们应该在文件系统中将其命名为

00:12:25.510 --> 00:12:30.820
 FTP服务器，我们将其命名为

00:12:27.490 --> 00:12:36.250
食物在txt而不是好的，所以我们在那里

00:12:30.820 --> 00:12:37.930
这是我不知道这是否很好

00:12:36.250 --> 00:12:41.040
 lambda候选人，我们在那里

00:12:37.930 --> 00:12:45.820
是的看起来不错，所以我们可以离开

00:12:41.040 --> 00:12:48.100
我们也不需要这个

00:12:45.820 --> 00:12:49.810
那比较干净，所以我认为那是

00:12:48.100 --> 00:12:51.910
不错，我们有一个

00:12:49.810 --> 00:12:55.990
适配器在那里，我们最终需要

00:12:51.910 --> 00:12:58.360
现在返回数据，我们必须处理

00:12:55.990 --> 00:13:00.520
这个改造权和这个

00:12:58.360 --> 00:13:02.620
其实你知道一些也许你

00:13:00.520 --> 00:13:05.050
可能会在一个单独的表达式中做

00:13:02.620 --> 00:13:06.430
将其提取出来并编写代码

00:13:05.050 --> 00:13:08.020
单独地你甚至可以把它放进去

00:13:06.430 --> 00:13:09.820
单独上课，然后更适当

00:13:08.020 --> 00:13:13.480
对其进行单元测试，但出于我们的目的

00:13:09.820 --> 00:13:18.790
足够只是在执行代码

00:13:13.480 --> 00:13:21.610
的地方，所以我们要做的是

00:13:18.790 --> 00:13:25.810
将要接收的数据

00:13:21.610 --> 00:13:28.990
该文件，我们将创建一个

00:13:25.810 --> 00:13:31.699
图片横幅，所以我要说的是

00:13:28.990 --> 00:13:33.769
要创建图像横幅

00:13:31.699 --> 00:13:36.439
这是春天的新功能

00:13:33.769 --> 00:13:37.489
 1.4这是所有的愤怒，当然是

00:13:36.439 --> 00:13:41.029
有史以来最重要的事情

00:13:37.489 --> 00:13:43.489
春天发生的能力是

00:13:41.029 --> 00:13:46.129
将图像转换为ASCII艺术品

00:13:43.489 --> 00:13:48.230
自动向社区表示感谢

00:13:46.129 --> 00:13:50.600
成员克雷格（Craig）振作，然后我带

00:13:48.230 --> 00:13:53.299
在源代码中，好吧，这是我们的

00:13:50.600 --> 00:13:54.619
图片横幅，我要写

00:13:53.299 --> 00:13:55.939
图片横幅出来，我要打印它

00:13:54.619 --> 00:13:57.350
所以我需要那里的环境

00:13:55.939 --> 00:13:59.419
可以看到这是必要条件

00:13:57.350 --> 00:14:01.790
这是春天的环境

00:13:59.419 --> 00:14:04.459
抽象，所以我将其注入

00:14:01.790 --> 00:14:05.629
而且我还需要一个不需要的课程

00:14:04.459 --> 00:14:07.910
真正重要的是哪一个只适合

00:14:05.629 --> 00:14:09.619
类加载，然后我需要打印

00:14:07.910 --> 00:14:15.199
可以串流，所以我要

00:14:09.619 --> 00:14:18.829
我要说的是印刷流PS 

00:14:15.199 --> 00:14:20.989
等于新的打印流和您所知道的

00:14:18.829 --> 00:14:22.699
就像我所有的一切一样

00:14:20.989 --> 00:14:24.949
哦，我希望这是自动的

00:14:22.699 --> 00:14:27.139
在其范围的末尾关闭

00:14:24.949 --> 00:14:29.329
用法，所以我要自动包装

00:14:27.139 --> 00:14:31.699
引入了可封闭的块

00:14:29.329 --> 00:14:33.259
 Java 7我的打印流需要一个字节

00:14:31.699 --> 00:14:34.519
数组输出

00:14:33.259 --> 00:14:36.919
你知道我需要一个输出流，所以我

00:14:34.519 --> 00:14:47.529
将创建一个字节数组输出

00:14:36.919 --> 00:14:51.739
这样好吧，会吧

00:14:47.529 --> 00:14:55.789
哎呀字节数组输出流在那里

00:14:51.739 --> 00:14:57.470
是，我需要处理这个例外

00:14:55.789 --> 00:15:00.019
我被邀请进入我的世界

00:14:57.470 --> 00:15:06.739
在这里，所以我们会说反思

00:15:00.019 --> 00:15:12.199
 utils点我们抛出方法我们抛出一个

00:15:06.739 --> 00:15:14.149
时间例外II，现在我们将通过

00:15:12.199 --> 00:15:17.389
该字节数组输出流到我们

00:15:14.149 --> 00:15:22.129
打印流，然后将传递给

00:15:17.389 --> 00:15:26.239
好的，一旦完成，我可以说

00:15:22.129 --> 00:15:28.399
字节数组输出流点两个字节

00:15:26.239 --> 00:15:32.980
数组和所有创建一个字符串

00:15:28.399 --> 00:15:36.829
你知道横幅文字等于新字符串

00:15:32.980 --> 00:15:38.539
这样，我们将返回横幅

00:15:36.829 --> 00:15:40.819
如此努力的文字

00:15:38.539 --> 00:15:42.169
我们现在将获得我们的结果，我们可以

00:15:40.819 --> 00:15:43.789
就在我们身上，这似乎都很容易

00:15:42.169 --> 00:15:45.529
足够，我们将使用它

00:15:43.789 --> 00:15:47.360
变压器在这里，所以已经

00:15:45.529 --> 00:15:49.220
插入正确，上面写着transform and 

00:15:47.360 --> 00:15:50.509
请记住，我本来可以做各种各样的事情

00:15:49.220 --> 00:15:53.209
还有这里的其他事情

00:15:50.509 --> 00:15:55.040
向您展示了我的转型

00:15:53.209 --> 00:15:56.839
选择你的手柄如何做手柄， 

00:15:55.040 --> 00:15:59.149
依此类推，但我可以将其拆分， 

00:15:56.839 --> 00:16:01.910
索赔支票我可以做到，你知道我可以

00:15:59.149 --> 00:16:03.889
丰富的数据，我可以过滤它，你

00:16:01.910 --> 00:16:06.889
知道重新排序也可以做cuz custom 

00:16:03.889 --> 00:16:09.230
路由到其他类型的流，并

00:16:06.889 --> 00:16:10.879
等等，但这是我认为非常非常

00:16:09.230 --> 00:16:13.430
我们正在尝试的简单示例

00:16:10.879 --> 00:16:22.819
这样做，让我们继续并保持原样

00:16:13.430 --> 00:16:26.569
因为我们现在就拥有它

00:16:22.819 --> 00:16:32.809
工作，我们应该看到我们应该得到的数据

00:16:26.569 --> 00:16:35.180
自动查看任何输入的jpg文件

00:16:32.809 --> 00:16:37.610
在FTP中显示为结果文件

00:16:35.180 --> 00:16:39.889
服务器，让我们再次来吧，让我们

00:16:37.610 --> 00:16:42.410
确保无论什么性质

00:16:39.889 --> 00:16:44.870
该文件仅接受

00:16:42.410 --> 00:16:46.089
您知道该流程仅适用于jpg 

00:16:44.870 --> 00:16:53.000
文件，所以我们要继续

00:16:46.089 --> 00:16:54.319
在这里进一步自定义我们的模式

00:16:53.000 --> 00:16:58.730
我们愿意做的事情

00:16:54.319 --> 00:16:59.809
接受，所以我想我想我们

00:16:58.730 --> 00:17:02.809
可以尝试这个可能会起作用

00:16:59.809 --> 00:17:04.220
让我们看看是否可以，所以

00:17:02.809 --> 00:17:07.100
也许我们可以蚂蚁路径表达

00:17:04.220 --> 00:17:10.909
通过查看确认尽可能多

00:17:07.100 --> 00:17:19.780
它说的模式和新的简单

00:17:10.909 --> 00:17:23.120
模式文件列表过滤器和过滤器

00:17:19.780 --> 00:17:24.740
这是一个N样式和样式路径

00:17:23.120 --> 00:17:28.039
表达，是的，应该是这样

00:17:24.740 --> 00:17:31.190
应该和风格一样正确找到

00:17:28.039 --> 00:17:33.919
星号点jpg好，所以现在我们

00:17:31.190 --> 00:17:36.020
有一个可以听的整合流程

00:17:33.919 --> 00:17:39.140
对于这里的数据转换传入

00:17:36.020 --> 00:17:41.690
文件，使用我们的文件将字符串通用

00:17:39.140 --> 00:17:46.640
变压器，然后路由

00:17:41.690 --> 00:17:47.840
现在最后一个之外的结果字符串

00:17:46.640 --> 00:17:50.000
我们需要做的是

00:17:47.840 --> 00:17:51.890
确保具有

00:17:50.000 --> 00:17:53.899
其中的文件名是永久的，因此

00:17:51.890 --> 00:17:55.700
而不只是发送一个字符串，我们

00:17:53.899 --> 00:17:58.789
去我们要发送一条消息

00:17:55.700 --> 00:17:59.330
正确的字符串，这是一个包装器

00:17:58.789 --> 00:18:04.880
宾语

00:17:59.330 --> 00:18:06.740
Spring Framework本身期望，我们

00:18:04.880 --> 00:18:08.720
我们会义务正确吗，我要走了

00:18:06.740 --> 00:18:11.270
说消息生成器，这是

00:18:08.720 --> 00:18:12.740
这实际上是一个Spring Framework ISM 

00:18:11.270 --> 00:18:15.260
我们将建立一个自定义信封

00:18:12.740 --> 00:18:16.760
对象，我要去的消息

00:18:15.260 --> 00:18:18.500
建立它，但是在我们建立它之前，我们想要

00:18:16.760 --> 00:18:21.710
设置标题，所以我们要设置

00:18:18.500 --> 00:18:25.340
标头是文件名本身

00:18:21.710 --> 00:18:30.890
文件名当然是

00:18:25.340 --> 00:18:37.180
传入的文件源，因此获取绝对值

00:18:30.890 --> 00:18:39.920
文件点获取名称好，所以有

00:18:37.180 --> 00:18:41.600
然后我们开始进行简单的流程

00:18:39.920 --> 00:18:44.720
这样下游组件

00:18:41.600 --> 00:18:46.580
也就是说我们的出站ftp 

00:18:44.720 --> 00:18:50.000
适配器将能够

00:18:46.580 --> 00:18:51.290
传入文件头并将其拆分

00:18:50.000 --> 00:18:53.030
成功，否则该标头

00:18:51.290 --> 00:18:54.830
可能不在那里，所以这很好

00:18:53.030 --> 00:18:55.970
有机会看看你知道春天如何

00:18:54.830 --> 00:18:57.560
引擎盖下发生了什么

00:18:55.970 --> 00:18:59.840
即使我们的组件是书面的

00:18:57.560 --> 00:19:02.230
在字符串和文件等方面

00:18:59.840 --> 00:19:04.400
真正发生的是春天是

00:19:02.230 --> 00:19:06.470
使具有以下内容的消息对象永久存在

00:19:04.400 --> 00:19:07.940
有效载荷，这就是为什么这些组件

00:19:06.470 --> 00:19:09.800
工作是因为所有这些组成部分

00:19:07.940 --> 00:19:12.410
真的很在乎

00:19:09.800 --> 00:19:14.480
水平是或他们关心未输入您的信息

00:19:12.410 --> 00:19:16.580
知道消息类型的通用对象

00:19:14.480 --> 00:19:17.900
有有效载荷和头

00:19:16.580 --> 00:19:20.330
依次是键和值

00:19:17.900 --> 00:19:21.560
所以没有任何理由

00:19:20.330 --> 00:19:23.180
他们不应该在那里一起工作

00:19:21.560 --> 00:19:25.010
他们注定要一起工作，即使

00:19:23.180 --> 00:19:27.590
有效载荷等等是不同的， 

00:19:25.010 --> 00:19:31.040
您实际上可以切换行为

00:19:27.590 --> 00:19:33.620
通过关闭上游组件

00:19:31.040 --> 00:19:35.300
还是下游，所以让我们继续吧

00:19:33.620 --> 00:19:37.430
看看是否可行，应该

00:19:35.300 --> 00:19:41.300
是一个非常简单的例子，这将

00:19:37.430 --> 00:19:45.560
是我们的 Spring Integration 流程，让我走吧

00:19:41.300 --> 00:19:48.130
到我的桌面上，让我进入

00:19:45.560 --> 00:19:48.130
桌面在这里

00:19:51.280 --> 00:20:00.220
现在删除输入目录，将

00:19:56.700 --> 00:20:02.590
我们在FTPS目录和FTP 

00:20:00.220 --> 00:20:05.050
服务器，我什么都没有

00:20:02.590 --> 00:20:08.590
现在我要你知道我是

00:20:05.050 --> 00:20:11.170
希望一次看到txt文件

00:20:08.590 --> 00:20:12.370
我们已经将图片添加到了in目录中

00:20:11.170 --> 00:20:14.080
因此，让我们继续尝试，我们将继续

00:20:12.370 --> 00:20:15.550
向前并旋转一切

00:20:14.080 --> 00:20:19.890
一切都应该按计划进行

00:20:15.550 --> 00:20:23.620
但是我之前已经说过，所以我们会看到

00:20:19.890 --> 00:20:26.500
啊哈，所以学习的时候尝试了二没有

00:20:23.620 --> 00:20:28.270
控制我没有配置和极地

00:20:26.500 --> 00:20:31.330
对，我没有控制极性配置

00:20:28.270 --> 00:20:32.970
对于我的入站适配器，这使得

00:20:31.330 --> 00:20:36.550
所以记得Spring 整合是

00:20:32.970 --> 00:20:39.400
让我们像那样编写代码

00:20:36.550 --> 00:20:41.530
消息将作为事件而来

00:20:39.400 --> 00:20:44.050
下游组件不需要

00:20:41.530 --> 00:20:45.550
关心这些这些传入的地方

00:20:44.050 --> 00:20:47.350
消息正确，例如

00:20:45.550 --> 00:20:49.180
转换组件在这里提交了

00:20:47.350 --> 00:20:51.370
没有的字符串通用组件

00:20:49.180 --> 00:20:55.180
这个传入文件来自哪里的想法

00:20:51.370 --> 00:20:57.250
但我们知道你知道还是我们知道

00:20:55.180 --> 00:20:59.680
消息来自上游

00:20:57.250 --> 00:21:04.000
此入站适配器入站适配器

00:20:59.680 --> 00:21:06.880
将要响应新消息，并且

00:21:04.000 --> 00:21:08.620
它通过拉文件系统来做到这一点

00:21:06.880 --> 00:21:11.260
也就是说它扫描文件系统

00:21:08.620 --> 00:21:12.490
每隔一段时间，我们需要

00:21:11.260 --> 00:21:15.160
配置该间隔，我们需要

00:21:12.490 --> 00:21:18.640
配置您知道应该多久一次

00:21:15.160 --> 00:21:24.330
这样做，但并非所有系统都具有此功能

00:21:18.640 --> 00:21:24.330
要求权不是所有系统都

00:21:25.080 --> 00:21:29.890
不能为此而正确

00:21:27.520 --> 00:21:31.480
例如IMAP空闲IMAP空闲有一个

00:21:29.890 --> 00:21:33.400
推送通知的方式

00:21:31.480 --> 00:21:37.990
需要不断审问你

00:21:33.400 --> 00:21:39.490
可以异步听

00:21:37.990 --> 00:21:42.100
被告知消息何时存在

00:21:39.490 --> 00:21:44.320
同样，您知道您的消息队列

00:21:42.100 --> 00:21:46.390
例如rabbitmq，然后是大多数贾米斯

00:21:44.320 --> 00:21:48.610
和Jamis经纪人等等，或者

00:21:46.390 --> 00:21:50.740
春天做同样的事情的方式

00:21:48.610 --> 00:21:52.150
否定的想法是极地

00:21:50.740 --> 00:21:53.890
那些没有这个主意的系统

00:21:52.150 --> 00:21:55.570
这样，从我们的角度来看，我们可以

00:21:53.890 --> 00:21:57.100
编写代码，就像消息将

00:21:55.570 --> 00:21:58.660
异步交付

00:21:57.100 --> 00:22:01.420
原来的没关系

00:21:58.660 --> 00:22:03.430
系统实际上支持它，我们会

00:22:01.420 --> 00:22:04.800
让它一个接一个地工作，所以我要

00:22:03.430 --> 00:22:09.180
说我想拉

00:22:04.800 --> 00:22:10.830
每秒钟所有目录1000 

00:22:09.180 --> 00:22:20.070
毫秒，让我们继续前进， 

00:22:10.830 --> 00:22:22.140
在这里重启这个好东西，所以

00:22:20.070 --> 00:22:24.390
这些是我们简单的集成流程

00:22:22.140 --> 00:22:27.600
让我们继续尝试一下，这样我

00:22:24.390 --> 00:22:31.530
将此处的Google徽标复制到

00:22:27.600 --> 00:22:35.810
输入目录，我们看到它

00:22:31.530 --> 00:22:39.090
彻底彻底失败

00:22:35.810 --> 00:22:42.110
远程目录表达式AHA I 

00:22:39.090 --> 00:22:47.100
忘记指定我想要的位置

00:22:42.110 --> 00:22:49.290
传入您知道的文件是

00:22:47.100 --> 00:22:51.200
写的，所以我要称它为

00:22:49.290 --> 00:22:57.950
我是否说过最后一个目录是什么

00:22:51.200 --> 00:22:57.950
可以上传

00:23:05.630 --> 00:23:11.780
现在，该文件仍然存在的消息

00:23:08.450 --> 00:23:13.429
驻留在目录中，以便

00:23:11.780 --> 00:23:16.580
再次启动时，它注意到

00:23:13.429 --> 00:23:17.840
它，你知道成功创建

00:23:16.580 --> 00:23:19.940
消息，它发送了消息

00:23:17.840 --> 00:23:23.000
通过处理链，使用户

00:23:19.940 --> 00:23:25.700
谷歌jpg桌面上的监狱是

00:23:23.000 --> 00:23:27.679
创建，然后终于在这里

00:23:25.700 --> 00:23:29.419
我们看到文件的FTP会话逻辑

00:23:27.679 --> 00:23:32.450
已成功转移到上传

00:23:29.419 --> 00:23:34.250
谷歌点txt点写作然后

00:23:32.450 --> 00:23:37.039
最终它被重命名为上传统计信息

00:23:34.250 --> 00:23:39.110
 Google txt，所以在这里我们已经得到了一些

00:23:37.039 --> 00:23:42.080
好处，你可以看到这是一个

00:23:39.110 --> 00:23:43.970
 Spring Innovation出站FTP适配器

00:23:42.080 --> 00:23:46.220
在做一些非常聪明的事情

00:23:43.970 --> 00:23:48.020
可能还有可能

00:23:46.220 --> 00:23:50.299
其他系统甚至其他系统

00:23:48.020 --> 00:23:53.350
正在等待的下游系统

00:23:50.299 --> 00:23:56.210
该文件以及下游的那些系统

00:23:53.350 --> 00:23:58.970
可能正在做同样的事情，也许

00:23:56.210 --> 00:24:00.049
他们将FTP服务器作为

00:23:58.970 --> 00:24:01.970
你知道那是他们分期的方式

00:24:00.049 --> 00:24:03.440
他们正在等待50 P服务器到达

00:24:01.970 --> 00:24:05.030
他们正在等待文件的FT 

00:24:03.440 --> 00:24:06.440
到达FTP服务器，然后他们

00:24:05.030 --> 00:24:09.799
想在合适的地方进行处理

00:24:06.440 --> 00:24:14.210
如果我们正在上传文件和该文件

00:24:09.799 --> 00:24:16.190
被命名为下导管系统

00:24:14.210 --> 00:24:19.010
期望它被命名，然后那些

00:24:16.190 --> 00:24:20.809
下游系统可能会观察到它们

00:24:19.010 --> 00:24:22.730
注意到他们或在那里感知他们

00:24:20.809 --> 00:24:24.559
刚开始下载它们，以便他们

00:24:22.730 --> 00:24:26.690
可以开始处理它们，即使我们

00:24:24.559 --> 00:24:28.340
还没有上传完，怎么办

00:24:26.690 --> 00:24:30.380
我们在这里做的是春季否定

00:24:28.340 --> 00:24:32.450
出站适配器使用

00:24:30.380 --> 00:24:34.610
它是不同的名称，用点号将其修复

00:24:32.450 --> 00:24:36.980
写作，所以希望下游

00:24:34.610 --> 00:24:39.350
系统掩码是这样的

00:24:36.980 --> 00:24:40.760
寻找以点写结尾的文件

00:24:39.350 --> 00:24:42.860
对，然后当一切都结束时

00:24:40.760 --> 00:24:45.350
上传我们只是重命名它，然后

00:24:42.860 --> 00:24:48.950
一种伪原子或至少

00:24:45.350 --> 00:24:50.450
非常非常快，效果很好，所以在那里

00:24:48.950 --> 00:24:53.270
我们去，以便我们实际上有工作

00:24:50.450 --> 00:24:57.530
现在是一个ASCII艺术品文件

00:24:53.270 --> 00:25:01.039
此处的桌面，以便ftp WS上传

00:24:57.530 --> 00:25:02.299
有我们的Google徽标和侦察员作品

00:25:01.039 --> 00:25:08.380
你真的不能在这里看到它，我想知道

00:25:02.299 --> 00:25:10.490
我可以在这里照顾好猫

00:25:08.380 --> 00:25:12.650
那里我们在问我们的工作

00:25:10.490 --> 00:25:16.909
控制台这是一件美丽的事，我

00:25:12.650 --> 00:25:19.280
想你现在会同意一件事

00:25:16.909 --> 00:25:20.780
可能想知道如何重新使用

00:25:19.280 --> 00:25:22.490
功能失调，我该怎么办？ 

00:25:20.780 --> 00:25:25.250
完成了所有这些逻辑后，我该怎么办

00:25:22.490 --> 00:25:27.140
封装它也许我想拿

00:25:25.250 --> 00:25:28.790
所有入站文件的优势

00:25:27.140 --> 00:25:30.380
监控和安全

00:25:28.790 --> 00:25:32.330
转型，但也许我想拥有

00:25:30.380 --> 00:25:33.860
与我不同的两个终点

00:25:32.330 --> 00:25:37.400
结果消息也许我想发送

00:25:33.860 --> 00:25:40.130
将其发送到FTP服务器并将其作为

00:25:37.400 --> 00:25:42.770
给rabbitmq经纪人的消息等等

00:25:40.130 --> 00:25:44.600
再次春天否定是不是

00:25:42.770 --> 00:25:47.330
非常合适，所以我们在这里做什么

00:25:44.600 --> 00:25:48.950
是从一个隐式发送数据

00:25:47.330 --> 00:25:50.540
组件嵌入到

00:25:48.950 --> 00:25:53.110
变压器到出站

00:25:50.540 --> 00:25:55.040
适配器，我们没有明确

00:25:53.110 --> 00:25:57.470
描述该消息的流向

00:25:55.040 --> 00:25:59.470
在组件之间只是假设

00:25:57.470 --> 00:26:04.490
我们春天到北京，我们称之为

00:25:59.470 --> 00:26:07.070
链流正确，但我们可以做到

00:26:04.490 --> 00:26:08.900
明确的运输方式，这实际上是

00:26:07.070 --> 00:26:10.820
对我们有利的是

00:26:08.900 --> 00:26:12.260
消息通道消息通道和

00:26:10.820 --> 00:26:13.970
 Spring Integration 是指一个命名

00:26:12.260 --> 00:26:16.550
导管是一条穿过的管道

00:26:13.970 --> 00:26:20.890
传递哪个消息，我们可以使用

00:26:16.550 --> 00:26:23.360
用于分流一个流的输出的通道

00:26:20.890 --> 00:26:25.010
交付给另一个流程，所以我们开始吧

00:26:23.360 --> 00:26:27.290
向前并打破这一点，让我们开始吧

00:26:25.010 --> 00:26:30.110
向前移动处理

00:26:27.290 --> 00:26:32.510
 FTP到另一个流，然后我们将添加

00:26:30.110 --> 00:26:33.620
另一股流仍然，所以你知道

00:26:32.510 --> 00:26:35.330
我们将拥有原始的

00:26:33.620 --> 00:26:38.290
流它会在

00:26:35.330 --> 00:26:40.430
频道，我们将有两个不同的频道

00:26:38.290 --> 00:26:41.810
该渠道末端的消费者

00:26:40.430 --> 00:26:43.100
该通道的另一侧

00:26:41.810 --> 00:26:45.650
处理正确，所以我们要走了

00:26:43.100 --> 00:26:48.980
前进，现在建立一个渠道会说

00:26:45.650 --> 00:26:50.930
信息频道，我要打电话

00:26:48.980 --> 00:26:57.700
这你知道我要打电话

00:26:50.930 --> 00:27:00.800
通过我猜的文件处理器

00:26:57.700 --> 00:27:02.630
更加有意义的ASCII处理器

00:27:00.800 --> 00:27:04.160
不是吗，所以我们将其称为ASCII 

00:27:02.630 --> 00:27:07.040
处理器，我们将转向

00:27:04.160 --> 00:27:11.660
一个消息通道，再一个消息

00:27:07.040 --> 00:27:13.460
通道没有任何隐含功能

00:27:11.660 --> 00:27:15.980
默认情况下，它只是一个命名

00:27:13.460 --> 00:27:17.210
就像一个Java util Q 

00:27:15.980 --> 00:27:24.560
正确的案例，所以我要建立

00:27:17.210 --> 00:27:26.900
一个发布/订阅频道，这里

00:27:24.560 --> 00:27:29.510
我们走，我们要继续前进，并建立

00:27:26.900 --> 00:27:32.390
这样，我们将使用它

00:27:29.510 --> 00:27:32.930
发送此数据的渠道

00:27:32.390 --> 00:27:34.580
代替

00:27:32.930 --> 00:27:38.050
说带适配器的手柄，我会切

00:27:34.580 --> 00:27:40.970
出来，我会说句“不好意思”或“抱歉”的频道

00:27:38.050 --> 00:27:42.860
这个点ascii处理器，所以现在

00:27:40.970 --> 00:27:44.390
被发送到我们不接收的频道

00:27:42.860 --> 00:27:45.890
知道，但我们也不在乎我们

00:27:44.390 --> 00:27:47.330
只是注意到这是其他下游

00:27:45.890 --> 00:27:49.820
组件将对此做出响应，所以现在

00:27:47.330 --> 00:27:54.230
让我们继续并恢复ftp 

00:27:49.820 --> 00:28:00.080
流程，我们要说FTP，我们将

00:27:54.230 --> 00:28:04.400
从中返回积分流点

00:28:00.080 --> 00:28:07.010
点ASCII处理器，我们会知道

00:28:04.400 --> 00:28:10.270
除了我们

00:28:07.010 --> 00:28:13.430
从传入的数据中获取数据

00:28:10.270 --> 00:28:15.410
渠道，所以现在我们的代码变得有点

00:28:13.430 --> 00:28:16.820
更具模块化的编写方式，因此我们可以

00:28:15.410 --> 00:28:19.730
现在通过使用渠道获得收益

00:28:16.820 --> 00:28:22.100
可以推理，我们可以测试子

00:28:19.730 --> 00:28:24.080
部分流程的处理

00:28:22.100 --> 00:28:26.360
流动而不必测试所有内容

00:28:24.080 --> 00:28:28.670
对，我们可以孤立地进入您

00:28:26.360 --> 00:28:30.890
可以看到此流程用于发送

00:28:28.670 --> 00:28:33.230
消息到ftp服务器实际上起作用

00:28:30.890 --> 00:28:35.690
您可以只注入这个频道

00:28:33.230 --> 00:28:37.130
本身进入您的代码并发送消息

00:28:35.690 --> 00:28:39.440
进入该频道，您不必

00:28:37.130 --> 00:28:42.200
你知道Spring 整合

00:28:39.440 --> 00:28:43.490
例如组件，以便在您

00:28:42.200 --> 00:28:46.130
知道你是否这样做，你会看到

00:28:43.490 --> 00:28:47.420
消息通过ftp逻辑直到

00:28:46.130 --> 00:28:48.560
你得到了正确的，直到

00:28:47.420 --> 00:28:52.310
以您期望的方式工作，例如

00:28:48.560 --> 00:28:53.660
好吧，现在我已经将它们解耦了

00:28:52.310 --> 00:28:57.470
否则我可以继续吗

00:28:53.660 --> 00:28:58.940
发送消息到AMQP，以便

00:28:57.470 --> 00:29:00.490
这一点我实际上有两个

00:28:58.940 --> 00:29:10.310
我有不同的担忧不会消失

00:29:00.490 --> 00:29:13.190
 FTP配置，我已经

00:29:10.310 --> 00:29:15.590
 amqp RabbitMQ配置，让我们开始吧

00:29:13.190 --> 00:29:19.310
领先和协调从

00:29:15.590 --> 00:29:21.350
彼此那里我们去这是一个嵌套

00:29:19.310 --> 00:29:22.670
Spring 看到时的配置类

00:29:21.350 --> 00:29:27.800
它会像其他任何东西一样评估

00:29:22.670 --> 00:29:30.160
配置类，我们将要

00:29:27.800 --> 00:29:33.020
继续，现在做同样的事情

00:29:30.160 --> 00:29:39.680
 AMQP将说配置公开

00:29:33.020 --> 00:29:40.670
静态类mq p配置以及什么

00:29:39.680 --> 00:29:42.920
我们要做的是定义

00:29:40.670 --> 00:29:44.960
中间件基础架构

00:29:42.920 --> 00:29:46.029
那是p和春天的春天

00:29:44.960 --> 00:29:49.359
整合需求

00:29:46.029 --> 00:29:56.399
与mqp交谈，所以我需要

00:29:49.359 --> 00:30:04.419
在这里引入春季集成mqp 

00:29:56.399 --> 00:30:07.989
依赖，我们需要定义我们需要的

00:30:04.419 --> 00:30:10.749
定义基础架构

00:30:07.989 --> 00:30:12.879
反对Rabbitmq上的结构

00:30:10.749 --> 00:30:14.799
经纪人和我碰巧有rabbitmq 

00:30:12.879 --> 00:30:16.989
现在在我的机器上运行，所以

00:30:14.799 --> 00:30:19.029
已经在我不需要的同一台机器上

00:30:16.989 --> 00:30:21.129
去做别的事情我只是不我

00:30:19.029 --> 00:30:22.539
只是在本地运行并凭借

00:30:21.129 --> 00:30:24.999
我在春天带来的事实

00:30:22.539 --> 00:30:26.919
我会得到的靴子启动器AMQP 

00:30:24.999 --> 00:30:28.239
得到一个指向的连接工厂

00:30:26.919 --> 00:30:29.830
到本地主机，所以这是默认设置

00:30:28.239 --> 00:30:31.029
我自然可以去看重

00:30:29.830 --> 00:30:33.909
应用我们的属性并说

00:30:31.029 --> 00:30:36.249
 spring Rabbitmq并指定任何数字

00:30:33.909 --> 00:30:37.869
这些是用于指定如何使用的属性

00:30:36.249 --> 00:30:41.279
寻找经纪人，但出于我们的目的

00:30:37.869 --> 00:30:43.419
很好，因为我要创建一个

00:30:41.279 --> 00:30:45.580
其中一些服务器端基础架构

00:30:43.419 --> 00:30:49.210
这是必需的，所以在春天对不起

00:30:45.580 --> 00:30:51.549
 rabbitmq你有经纪人的想法

00:30:49.210 --> 00:30:52.899
经纪人在接受消息

00:30:51.549 --> 00:30:55.599
所谓的交流是

00:30:52.899 --> 00:30:58.479
有点像一扇门或一扇门

00:30:55.599 --> 00:31:00.729
交换然后路由它发送

00:30:58.479 --> 00:31:02.289
消息发送到某种队列，所以在那里

00:31:00.729 --> 00:31:04.269
是不同类型的交流，如果

00:31:02.289 --> 00:31:06.820
你想做发布/订阅你知道的

00:31:04.269 --> 00:31:08.440
广播形式的公共传播

00:31:06.820 --> 00:31:09.789
如果你有一个交换

00:31:08.440 --> 00:31:12.249
想要直接沟通

00:31:09.789 --> 00:31:16.149
交换交换，如果你

00:31:12.249 --> 00:31:17.529
想做分层主题

00:31:16.149 --> 00:31:19.450
您无法真正使用的功能

00:31:17.529 --> 00:31:21.369
例如，标准的JMS 

00:31:19.450 --> 00:31:23.979
交换实际上是交换

00:31:21.369 --> 00:31:25.749
也用作联盟的一种方式

00:31:23.979 --> 00:31:27.309
对的你可以从你那里复制

00:31:25.749 --> 00:31:28.899
知道主动主动复制的种类

00:31:27.309 --> 00:31:31.809
从一个节点到另一个节点

00:31:28.899 --> 00:31:35.080
他们也是随机队列

00:31:31.809 --> 00:31:36.309
支持与其他协议通话

00:31:35.080 --> 00:31:39.009
如果您想发送消息到

00:31:36.309 --> 00:31:40.539
您将RabbitMQ发送到交易所， 

00:31:39.009 --> 00:31:43.479
它可以为您重写它吗

00:31:40.539 --> 00:31:44.769
并将其作为XMPP发送出去

00:31:43.479 --> 00:31:46.809
例子或类似的东西，所以

00:31:44.769 --> 00:31:48.460
所以你在这方面有很大的灵活性

00:31:46.809 --> 00:31:51.309
交换构造它增加了能力

00:31:48.460 --> 00:31:52.839
在代理本身中进行路由

00:31:51.309 --> 00:31:55.839
那不是你得到的

00:31:52.839 --> 00:31:58.239
非常简单的JMS模型和JMS 

00:31:55.839 --> 00:31:59.750
信息到达目的地，然后

00:31:58.239 --> 00:32:02.330
消费者聆听命运

00:31:59.750 --> 00:32:04.520
没有中介，所以你

00:32:02.330 --> 00:32:07.280
再加上那些东西可以

00:32:04.520 --> 00:32:09.530
永不改变，让我们继续前进，让我们

00:32:07.280 --> 00:32:13.250
在这里定义相关的位，所以我们

00:32:09.530 --> 00:32:14.870
关心交流，确定我们正确

00:32:13.250 --> 00:32:18.770
需要 Spring AMQP 交换

00:32:14.870 --> 00:32:23.960
好吧，我们将使用交易所生成器

00:32:18.770 --> 00:32:26.659
在 Spring AMQP ，我们将使用直接

00:32:23.960 --> 00:32:30.890
交流，你知道这里的交流

00:32:26.659 --> 00:32:34.429
一切都会被称为ASCII 

00:32:30.890 --> 00:32:38.780
将是ASCII，所以好的，它将是

00:32:34.429 --> 00:32:44.140
我希望它的名称持久

00:32:38.780 --> 00:32:46.520
难道我们会建立的吗

00:32:44.140 --> 00:32:50.299
这意味着数据将是

00:32:46.520 --> 00:32:52.330
交换将保留，我们要发送

00:32:50.299 --> 00:32:55.100
交换中的数据

00:32:52.330 --> 00:32:56.960
通过一个到队列，所以我们将

00:32:55.100 --> 00:32:59.900
在这里创建一个队列，我们​​会说， 

00:32:56.960 --> 00:33:04.780
将使用队列生成器，我们将

00:32:59.900 --> 00:33:09.049
使它也耐用，所以我们说Q 

00:33:04.780 --> 00:33:14.690
给它起一个点的名称

00:33:09.049 --> 00:33:16.130
建立好，找到正确的我们

00:33:14.690 --> 00:33:18.110
需要在这里建立绑定，所以我们

00:33:16.130 --> 00:33:26.059
要建立绑定，我们会说

00:33:18.110 --> 00:33:38.110
返回绑定生成器点绑定X 

00:33:26.059 --> 00:33:38.110
这样交换到你知道的Q 

00:33:38.470 --> 00:33:47.090
或将QI假设绑定到交易所

00:33:42.760 --> 00:33:49.940
可以使用路由键和路由

00:33:47.090 --> 00:33:56.750
关键是一个是春天的头

00:33:49.940 --> 00:33:59.030
 rabbim q将用来决定

00:33:56.750 --> 00:34:00.200
确定发送消息的队列

00:33:59.030 --> 00:34:01.970
对，所以消息即将到来

00:34:00.200 --> 00:34:03.620
进入交易所，rabbim q将

00:34:01.970 --> 00:34:05.750
说好吧，我怎么知道去哪里

00:34:03.620 --> 00:34:08.330
发送这个，一个常见的模式是使用

00:34:05.750 --> 00:34:10.429
一个头，一个特殊的魔术头，我很好

00:34:08.330 --> 00:34:11.839
称为路由关键字的已知标头

00:34:10.429 --> 00:34:13.280
在这种情况下选择旅行钥匙

00:34:11.839 --> 00:34:16.460
是因为

00:34:13.280 --> 00:34:18.889
消息有写作团队

00:34:16.460 --> 00:34:20.510
将是ASCII右表达式

00:34:18.889 --> 00:34:21.830
那就是名字，所以我正在使用

00:34:20.510 --> 00:34:23.360
传统的沉思工程

00:34:21.830 --> 00:34:28.790
巧合在这里，让一切

00:34:23.360 --> 00:34:30.260
排队，现在我们需要建立

00:34:28.790 --> 00:34:31.450
集成流程以支持该权利

00:34:30.260 --> 00:34:35.060
所以我要说的是

00:34:31.450 --> 00:34:40.370
当数据输入时，我会有另一个

00:34:35.060 --> 00:34:45.500
集成流程mqp，我们将说

00:34:40.370 --> 00:34:48.560
从该点到

00:34:45.500 --> 00:34:51.470
倾斜的处理器，我们将说句柄

00:34:48.560 --> 00:34:53.360
与适配器，我们将要做

00:34:51.470 --> 00:34:55.909
除了这次对nqp再次相同

00:34:53.360 --> 00:34:59.750
 mqp位将需要一个名称

00:34:55.909 --> 00:35:01.390
 QP模板正确，所以我们将注入

00:34:59.750 --> 00:35:03.440
 AMQP模板是

00:35:01.390 --> 00:35:06.140
春季自动为我们提供

00:35:03.440 --> 00:35:09.290
嘘尝试自动配置

00:35:06.140 --> 00:35:12.980
这以及很好的交换名称

00:35:09.290 --> 00:35:17.330
当然将是ASCII，所以我

00:35:12.980 --> 00:35:18.860
猜想我们应该很好地实现这一价值

00:35:17.330 --> 00:35:20.840
即使你知道这种流动会怎样

00:35:18.860 --> 00:35:22.820
实际上在该配置本地

00:35:20.840 --> 00:35:25.490
这实际上是另一个

00:35:22.820 --> 00:35:29.870
这种方便的副作用

00:35:25.490 --> 00:35:31.280
建模ISM我们知道，尽管现在

00:35:29.870 --> 00:35:32.960
当然，频道无法正常运作

00:35:31.280 --> 00:35:34.730
也许最好把它弄平

00:35:32.960 --> 00:35:38.750
现在让我们把它弄平

00:35:34.730 --> 00:35:41.480
我要说的配置名称空间

00:35:38.750 --> 00:35:44.960
数据是什么

00:35:41.480 --> 00:35:52.010
将以ASCII格式传送， 

00:35:44.960 --> 00:35:54.620
路由密钥将是此ASCII格式，所以

00:35:52.010 --> 00:35:56.060
当我们有整合流程时

00:35:54.620 --> 00:35:59.360
从这个频道进来

00:35:56.060 --> 00:36:02.410
发送到我们正在使用的AMQP适配器上

00:35:59.360 --> 00:36:05.180
只是要发送到那个交易所

00:36:02.410 --> 00:36:07.400
使用这个路由键好吧，你

00:36:05.180 --> 00:36:09.470
知道它应该能按预期工作

00:36:07.400 --> 00:36:11.390
被送到队列，并希望

00:36:09.470 --> 00:36:14.690
另一边的东西将能够

00:36:11.390 --> 00:36:16.580
回应它好吧，让我们开始吧

00:36:14.690 --> 00:36:18.680
继续尝试，现在就尝试一下

00:36:16.580 --> 00:36:21.170
去计划，我们应该看到结果

00:36:18.680 --> 00:36:23.000
在RabbitMQ经纪人中，让我

00:36:21.170 --> 00:36:25.250
通过登录rabbim队列进行确认

00:36:23.000 --> 00:36:27.170
并清理我们得到的一切

00:36:25.250 --> 00:36:28.520
已经在那里，所以我有三个烂摊子

00:36:27.170 --> 00:36:35.150
 Edge让我继续清除它

00:36:28.520 --> 00:36:38.990
现在就可以清除删除，即使

00:36:35.150 --> 00:36:41.710
我们想从零开始，然后我们去

00:36:38.990 --> 00:36:41.710
提前重启

00:37:00.890 --> 00:37:07.100
啊，看来我已经在里面了

00:37:04.660 --> 00:37:09.260
我已经有了这个经纪人

00:37:07.100 --> 00:37:12.620
交换等等，所以我需要删除

00:37:09.260 --> 00:37:16.190
所有这些，以便我的配置

00:37:12.620 --> 00:37:18.550
我提供与什么不冲突

00:37:16.190 --> 00:37:19.940
实际上在练习中是正确的，所以

00:37:18.550 --> 00:37:25.280
 s列

00:37:19.940 --> 00:37:26.690
交流已经过去了， 

00:37:25.280 --> 00:37:28.730
重新启动，让新

00:37:26.690 --> 00:37:36.110
配置覆盖了我的一切

00:37:28.730 --> 00:37:37.580
之前很酷，所以我们看到了文件

00:37:36.110 --> 00:37:39.950
仍然在目录中，所以它已经

00:37:37.580 --> 00:37:45.040
上载到服务器替换它

00:37:39.950 --> 00:37:45.040
现在，如果我们去这里，我们应该看到

00:37:45.430 --> 00:37:50.300
 ASCII那里就是那些

00:37:47.450 --> 00:37:51.500
 ASCII交换让我们看看其中的内容

00:37:50.300 --> 00:37:53.720
队列实际上是数据所在的位置

00:37:51.500 --> 00:37:56.870
毕竟存储了，只有一条信息

00:37:53.720 --> 00:37:59.090
尚未处理

00:37:56.870 --> 00:38:02.150
所以我们可以在这里给他们消息

00:37:59.090 --> 00:38:04.700
通过说出获取消息，就可以了

00:38:02.150 --> 00:38:06.290
和所有的荣耀

00:38:04.700 --> 00:38:08.480
为Google信息工作，因此我们的

00:38:06.290 --> 00:38:10.610
谷歌徽标，所以我们走了，我们已经

00:38:08.480 --> 00:38:13.220
使用了春季磨料，我们上演了

00:38:10.610 --> 00:38:15.860
现在我们通过渠道进行处理

00:38:13.220 --> 00:38:17.420
渠道概念将会非常非常

00:38:15.860 --> 00:38:19.490
稍后会很有用，所以如果您使用

00:38:17.420 --> 00:38:21.290
您可以使用的Spring Framework 本身

00:38:19.490 --> 00:38:23.120
与WebSockets配合使用的通道

00:38:21.290 --> 00:38:25.580
和春季MVC是的，如果您使用的是

00:38:23.120 --> 00:38:27.110
春天俱乐部流然后通道

00:38:25.580 --> 00:38:29.390
变成一种结缔组织

00:38:27.110 --> 00:38:31.520
基于消息的微服务之间

00:38:29.390 --> 00:38:33.590
我希望在以后再讨论这个

00:38:31.520 --> 00:38:37.270
进一步的分期付款但是

00:38:33.590 --> 00:38:37.270
非常感谢，下次见

