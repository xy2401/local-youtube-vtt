WEBVTT
Kind: captions
Language: zh-Hans

00:00:26.040 --> 00:00:30.510
欢迎来到另一期

00:00:28.350 --> 00:00:32.580
在本期的 spring 技巧 中，我们

00:00:30.510 --> 00:00:34.560
要去看阿帕奇骆驼阿帕奇

00:00:32.580 --> 00:00:37.739
骆驼与企业整合

00:00:34.560 --> 00:00:40.110
框架从Apache当然

00:00:37.739 --> 00:00:42.239
来自Red Hat的很多开发人员

00:00:40.110 --> 00:00:44.220
工作已经存在了很长时间

00:00:42.239 --> 00:00:46.350
它已经存在了至少

00:00:44.220 --> 00:00:48.660
例如 Spring 创新，因此

00:00:46.350 --> 00:00:50.129
技术已经变得根深蒂固

00:00:48.660 --> 00:00:52.830
很多人正在使用它，所以

00:00:50.129 --> 00:00:55.470
当我喜欢 Spring 创新时

00:00:52.830 --> 00:00:57.120
探索apache的美好世界

00:00:55.470 --> 00:01:00.300
骆驼，我要特别感谢

00:00:57.120 --> 00:01:02.100
我的朋友克劳斯不在，谁花了

00:01:00.300 --> 00:01:03.360
和我在一起一段时间让我感兴趣

00:01:02.100 --> 00:01:06.420
直到所有最新和最伟大的东西

00:01:03.360 --> 00:01:09.390
在支持骆驼的 Spring 

00:01:06.420 --> 00:01:12.420
今天启动，我们来看看

00:01:09.390 --> 00:01:13.500
 spring boot 1.5这只是一点点

00:01:12.420 --> 00:01:17.280
旧的，实际上你知道我们现在

00:01:13.500 --> 00:01:19.560
在 spring boot 的2.0 X下，但有

00:01:17.280 --> 00:01:23.159
支持 spring boot 龙卷风

00:01:19.560 --> 00:01:24.479
 apache骆驼到2.2到期的管道

00:01:23.159 --> 00:01:26.340
我认为很棒

00:01:24.479 --> 00:01:28.650
正确的 spring boot -他是故意的

00:01:26.340 --> 00:01:30.660
给它-那-超级好

00:01:28.650 --> 00:01:31.920
很酷，所以来了，就像我

00:01:30.660 --> 00:01:33.870
了解下个月

00:01:31.920 --> 00:01:36.630
左右，但是您知道开源时间表

00:01:33.870 --> 00:01:38.430
作为他们不持有的东西不要

00:01:36.630 --> 00:01:40.320
让我坚信他们可能很好

00:01:38.430 --> 00:01:42.480
也许改变的原因

00:01:40.320 --> 00:01:45.900
但无论如何，宜早不宜迟， 

00:01:42.480 --> 00:01:47.220
在此期间，我们当然可以使用

00:01:45.900 --> 00:01:50.160
快照版本（如果可以） 

00:01:47.220 --> 00:01:53.130
只需添加的Maven存储库

00:01:50.160 --> 00:01:56.040
 Apache具有用于快照或在此

00:01:53.130 --> 00:01:58.830
情况下，我们可以使用 spring boot 1.125 

00:01:56.040 --> 00:02:00.450
系列，仅使用Apache骆驼GA位

00:01:58.830 --> 00:02:02.910
现在有了它，所以有

00:02:00.450 --> 00:02:06.020
对 spring boot 的支持很好

00:02:02.910 --> 00:02:09.840
支持apache骆驼的 spring boot 

00:02:06.020 --> 00:02:12.209
自骆驼2.15以来，这种支持

00:02:09.840 --> 00:02:13.590
变得越来越好

00:02:12.209 --> 00:02:14.459
现在我简直不敢相信我

00:02:13.590 --> 00:02:18.180
还没做过关于这个东西的视频

00:02:14.459 --> 00:02:21.300
在这之前是一个非常完整的整体

00:02:18.180 --> 00:02:24.269
 Spring 木材生态系统的怀抱和

00:02:21.300 --> 00:02:25.530
所以我们将只走一些

00:02:24.269 --> 00:02:27.599
这里的基础知识，我们将看一些

00:02:25.530 --> 00:02:29.069
他们其中一些你可以

00:02:27.599 --> 00:02:30.470
用阿帕奇骆驼做，然后

00:02:29.069 --> 00:02:32.580
特别是你如何做

00:02:30.470 --> 00:02:34.170
带有Spring 和 spring boot 

00:02:32.580 --> 00:02:35.670
特别的，然后我们来看看

00:02:34.170 --> 00:02:38.099
我认为最有争议的是

00:02:35.670 --> 00:02:39.090
阿帕奇骆驼的重要组成部分

00:02:38.099 --> 00:02:41.430
玉米是这个

00:02:39.090 --> 00:02:45.620
连接器的目录，我知道

00:02:41.430 --> 00:02:49.319
集成框架在某种程度上

00:02:45.620 --> 00:02:51.780
非常关于它的筏子

00:02:49.319 --> 00:02:53.069
物联网的稳定性

00:02:51.780 --> 00:02:56.519
它可以与之整合的

00:02:53.069 --> 00:03:00.269
这里的阿帕奇骆驼没有懈怠，然后

00:02:56.519 --> 00:03:02.190
当然，最后我们来看一下

00:03:00.269 --> 00:03:04.230
在帕特里克骆驼的世界以及如何

00:03:02.190 --> 00:03:07.019
适用于 Spring ，尤其是

00:03:04.230 --> 00:03:09.330
随着 Spring 的发展

00:03:07.019 --> 00:03:11.100
正确处理消息通道的系统

00:03:09.330 --> 00:03:12.690
包括例如

00:03:11.100 --> 00:03:15.480
 Spring 创新 Spring Cloud Stream 

00:03:12.690 --> 00:03:18.840
不断涌现的云数据流和网站

00:03:15.480 --> 00:03:20.700
 Web服务重新支持WebSocket 

00:03:18.840 --> 00:03:22.220
 Spring 游戏，您会看到很多好处

00:03:20.700 --> 00:03:24.480
今天要看的东西

00:03:22.220 --> 00:03:26.250
专注于所有这些不同的组成部分

00:03:24.480 --> 00:03:27.060
对，我们要看所有这些

00:03:26.250 --> 00:03:28.410
不同的组成部分

00:03:27.060 --> 00:03:29.849
我们将专注于不同

00:03:28.410 --> 00:03:31.590
今天的组件列表很棒

00:03:29.849 --> 00:03:34.380
我只是想确保我们

00:03:31.590 --> 00:03:36.480
叫那只在或

00:03:34.380 --> 00:03:39.690
寻找HTML和

00:03:36.480 --> 00:03:40.860
我们将照常从这里开始我们的旅程

00:03:39.690 --> 00:03:42.900
初始化程序，所以我要继续

00:03:40.860 --> 00:03:44.430
并建立一个新的应用程序

00:03:42.900 --> 00:03:46.230
请记住，我们有两个死亡的氧气

00:03:44.430 --> 00:03:48.090
现在我可以使用它了

00:03:46.230 --> 00:03:51.420
使用这个但是初始化

00:03:48.090 --> 00:03:53.340
复选框很好禁用自身，因为

00:03:51.420 --> 00:03:55.650
没有那个Ogier的肚子

00:03:53.340 --> 00:03:57.269
候选版本的Apache骆驼和

00:03:55.650 --> 00:03:59.400
它马上就要来了

00:03:57.269 --> 00:04:01.799
这样，您甚至可以获取此代码以

00:03:59.400 --> 00:04:04.769
与今天的美国能源部合作，但出于我们的目的

00:04:01.799 --> 00:04:06.329
因为代码几乎相同

00:04:04.769 --> 00:04:09.359
我们只需要五分之一就可以使用

00:04:06.329 --> 00:04:12.630
我们将在这里创建一个例子

00:04:09.359 --> 00:04:14.880
叫做骆驼，我们现在使用Apache骆驼

00:04:12.630 --> 00:04:17.850
我们也想使用让我们看看我们想

00:04:14.880 --> 00:04:22.229
使用ActiveMQ，所以我们使用Jamis activemq 

00:04:17.850 --> 00:04:24.780
实例，我们将使用其他方法简化运行

00:04:22.229 --> 00:04:25.710
可能会损害Spring 整合的龙目岛

00:04:24.780 --> 00:04:27.090
好吧，一个需要这个前提

00:04:25.710 --> 00:04:29.280
集成支持，我们将回到

00:04:27.090 --> 00:04:33.570
只是一点

00:04:29.280 --> 00:04:35.700
我认为现在应该这样做

00:04:33.570 --> 00:04:38.580
让我们有能力做一些基本的

00:04:35.700 --> 00:04:41.970
东西，我们再来看一下

00:04:38.580 --> 00:04:43.350
他们是你的机会，知道什么

00:04:41.970 --> 00:04:47.250
他们有什么机会在那里

00:04:43.350 --> 00:04:49.140
我们将进一步扩展这个例子

00:04:47.250 --> 00:04:51.000
我们到了这一点，但现在我想

00:04:49.140 --> 00:04:52.190
这是一个好的开始，所以我们继续

00:04:51.000 --> 00:04:54.260
并生成项目

00:04:52.190 --> 00:04:55.610
当我像往常一样在

00:04:54.260 --> 00:05:02.330
 IDE，所以我们在这里

00:04:55.610 --> 00:05:03.680
 CD下载ueo骆驼点zip以及什么

00:05:02.330 --> 00:05:04.970
我们要做的就是开始

00:05:03.680 --> 00:05:08.870
你可以做的简单的事情

00:05:04.970 --> 00:05:15.980
可能做对了，所以让我们看看这里

00:05:08.870 --> 00:05:19.460
我们去那会开始，我们

00:05:15.980 --> 00:05:23.560
要打开属性文件去了

00:05:19.460 --> 00:05:23.560
到这里的构建负载，让我们看看

00:05:41.190 --> 00:05:46.080
好的，因此应用程序已加载

00:05:43.320 --> 00:05:49.560
现在我们可以构建一个应用程序

00:05:46.080 --> 00:05:51.750
利用了阿帕奇骆驼，所以

00:05:49.560 --> 00:05:53.540
这里要记住的几件事是

00:05:51.750 --> 00:05:59.190
我们用初始化程序完成的一切

00:05:53.540 --> 00:06:01.530
正在加载骆驼Spring 启动启动器

00:05:59.190 --> 00:06:05.220
这给了我们骆驼的补丁

00:06:01.530 --> 00:06:08.370
到朱迪思去那一个

00:06:05.220 --> 00:06:10.350
一个，这疣当然有效

00:06:08.370 --> 00:06:14.070
这不是Apache的有效版本

00:06:10.350 --> 00:06:15.600
骆驼，但事实是，这是

00:06:14.070 --> 00:06:19.190
可能不是使用Apache的最佳方法

00:06:15.600 --> 00:06:20.460
骆驼，你看到阿帕奇骆驼有一个巨大的

00:06:19.190 --> 00:06:23.250
惊人

00:06:20.460 --> 00:06:25.440
我的意思是炸毁了稳定的组件

00:06:23.250 --> 00:06:28.200
所以我想做的第一件事是

00:06:25.440 --> 00:06:30.420
更改我的构建以使用依赖项

00:06:28.200 --> 00:06:32.910
管理部分，以便我可以导入

00:06:30.420 --> 00:06:34.350
这些依赖项不合格

00:06:32.910 --> 00:06:36.810
对，以便我们做什么

00:06:34.350 --> 00:06:39.570
我们需要添加一个依赖项

00:06:36.810 --> 00:06:41.820
依赖管理部分在这里像

00:06:39.570 --> 00:06:44.160
所以，我们要添加一个依赖项

00:06:41.820 --> 00:06:45.720
看起来像您的管理部分

00:06:44.160 --> 00:06:47.940
知道你以前见过的任何其他东西

00:06:45.720 --> 00:06:50.580
例如，Spring Cloud So org 

00:06:47.940 --> 00:06:53.340
 apache camel oops对不起

00:06:50.580 --> 00:06:56.730
依赖已经超越了我自己

00:06:53.340 --> 00:07:00.560
他们的依赖关系，我们想添加

00:06:56.730 --> 00:07:03.540
骆驼 Spring -但--依赖

00:07:00.560 --> 00:07:04.919
支持请正确，我希望那是

00:07:03.540 --> 00:07:10.800
正确，看起来正确org 

00:07:04.919 --> 00:07:15.330
 apache camel all right org apache camel 

00:07:10.800 --> 00:07:18.270
版本将是骆驼点

00:07:15.330 --> 00:07:22.080
版本和该版本的骆驼

00:07:18.270 --> 00:07:23.540
在这里定义骆驼点版本和

00:07:22.080 --> 00:07:29.430
我们将使用的骆驼配音版本

00:07:23.540 --> 00:07:33.050
是2.2 1.1对，就是这样

00:07:29.430 --> 00:07:35.370
是物料清单炸弹的炸弹

00:07:33.050 --> 00:07:39.180
导入，因此我们将使其导入

00:07:35.370 --> 00:07:41.820
掌心型，我们在那里

00:07:39.180 --> 00:07:45.600
这里是我们的依赖

00:07:41.820 --> 00:07:47.460
我们是，就是这样

00:07:45.600 --> 00:07:49.200
我认为就是这样，所以我们现在我们

00:07:47.460 --> 00:07:52.200
首先我们可以改变我们

00:07:49.200 --> 00:07:52.990
可以从这里的构建中删除

00:07:52.200 --> 00:07:54.910
我们不需要

00:07:52.990 --> 00:07:56.050
我最终自动来了

00:07:54.910 --> 00:07:57.010
我们可以引入所有其他东西

00:07:56.050 --> 00:07:59.020
我们想用其他所有权利

00:07:57.010 --> 00:08:01.480
我们想要使用的有趣的地方

00:07:59.020 --> 00:08:03.610
今天让我们关注一个非常简单的

00:08:01.480 --> 00:08:05.230
我们来看的第一个例子

00:08:03.610 --> 00:08:07.960
 J您知道我们将研究文件系统

00:08:05.230 --> 00:08:09.700
和Jane的JMS现在是我们

00:08:07.960 --> 00:08:12.010
使用JMS是因为我们有一个很好的自动

00:08:09.700 --> 00:08:14.230
 spring boot 的配置

00:08:12.010 --> 00:08:16.420
允许我配置嵌入式

00:08:14.230 --> 00:08:18.340
活跃的急性事件的记忆类型

00:08:16.420 --> 00:08:20.230
与我的工作申请相同的节点

00:08:18.340 --> 00:08:21.910
这意味着对于你们这些人

00:08:20.230 --> 00:08:23.140
在家玩就可以跑步

00:08:21.910 --> 00:08:25.330
该程序，您不必安装

00:08:23.140 --> 00:08:27.160
 JMS经纪人就是您的典型代表

00:08:25.330 --> 00:08:28.900
当然会在JMS中完成

00:08:27.160 --> 00:08:30.430
使用适当的独立消息代理

00:08:28.900 --> 00:08:33.010
这是你会做的典型

00:08:30.430 --> 00:08:34.630
 Apache来了哦，不，我的意思是没人

00:08:33.010 --> 00:08:37.600
我不认为任何人

00:08:34.630 --> 00:08:38.820
对JMS演示印象深刻，但是我想要什么

00:08:37.600 --> 00:08:40.720
您要了解的是，这是一个

00:08:38.820 --> 00:08:42.370
消息传递系统

00:08:40.720 --> 00:08:44.530
中间件，它是其中之一

00:08:42.370 --> 00:08:45.820
超过200种不同的产品和

00:08:44.530 --> 00:08:48.400
您拥有的产品和选项

00:08:45.820 --> 00:08:49.630
骆驼生态系统，所以如果JMS不是

00:08:48.400 --> 00:08:51.880
你想要也许有卡夫卡

00:08:49.630 --> 00:08:53.650
有rabbitmq也许有一个s2 

00:08:51.880 --> 00:08:55.630
也许你知道那里有什么

00:08:53.650 --> 00:08:57.520
只是事情的扩散

00:08:55.630 --> 00:08:59.800
你应该知道好吧，让我们

00:08:57.520 --> 00:09:01.540
让我们添加一些我们想要的支持

00:08:59.800 --> 00:09:02.980
在这里使用，所以我们要添加我有

00:09:01.540 --> 00:09:06.210
首先，我想想要执行器

00:09:02.980 --> 00:09:09.580
执行器，Spring 启动器

00:09:06.210 --> 00:09:10.870
执行器Spring 启动启动器我应该

00:09:09.580 --> 00:09:14.140
已将这些添加回初始值设定项

00:09:10.870 --> 00:09:16.180
但我是铅垂忘了我们想要的

00:09:14.140 --> 00:09:19.710
 Spring Boot集成支持，我们将

00:09:16.180 --> 00:09:22.630
回到最后

00:09:19.710 --> 00:09:24.730
好吧，已经有我们的门了

00:09:22.630 --> 00:09:26.830
你有那个好的，所以有

00:09:24.730 --> 00:09:29.410
我们有活跃的活跃

00:09:26.830 --> 00:09:32.140
我们现在想要的JMS支持的qubit 

00:09:29.410 --> 00:09:33.480
如果我没有误会阿帕奇骆驼

00:09:32.140 --> 00:09:35.920
在这里回顾这些我们有组织

00:09:33.480 --> 00:09:40.210
帕奇骆驼

00:09:35.920 --> 00:09:41.520
让我们看看还是可怜的老骆驼不是

00:09:40.210 --> 00:09:45.900
对对对

00:09:41.520 --> 00:09:48.010
记忆有点不好，但你知道我

00:09:45.900 --> 00:09:52.000
认为我们会到达那里，这是一个

00:09:48.010 --> 00:09:54.580
不做手动构建的缺点

00:09:52.000 --> 00:09:56.230
通常是因为我大多数时候都使用 spring boot 

00:09:54.580 --> 00:10:00.540
我的工作我不记得该怎么做

00:09:56.230 --> 00:10:02.830
这一段时间了，所以骆驼的 Spring -引导

00:10:00.540 --> 00:10:04.660
首先看看我们在看什么

00:10:02.830 --> 00:10:07.080
那就是 Spring 的木头

00:10:04.660 --> 00:10:07.080
起动机

00:10:07.360 --> 00:10:11.020
我们想要的实际上不是我们想要的

00:10:08.920 --> 00:10:12.370
骆驼贾米斯首发吧，有一个

00:10:11.020 --> 00:10:14.020
数量不同的启动器，那就是

00:10:12.370 --> 00:10:16.840
实际上是另一个重要的

00:10:14.020 --> 00:10:18.760
明白这里有200个奇数

00:10:16.840 --> 00:10:21.330
组件或这种情况下的组件

00:10:18.760 --> 00:10:23.200
指的是骆驼术语

00:10:21.330 --> 00:10:25.780
整合基本上你就知道

00:10:23.200 --> 00:10:28.480
那只骆驼可以说话，你可以

00:10:25.780 --> 00:10:30.100
没有 Spring 就用骆驼我知道你是

00:10:28.480 --> 00:10:33.400
和我一样恐惧

00:10:30.100 --> 00:10:36.700
这种奇怪的希望越来越罕见

00:10:33.400 --> 00:10:38.230
上下文中还有更多

00:10:36.700 --> 00:10:39.580
选择还有更多选择

00:10:38.230 --> 00:10:41.890
可供您使用，然后有

00:10:39.580 --> 00:10:43.030
那些在 Spring 用骆驼的人

00:10:41.890 --> 00:10:44.770
心情，但是这些不是

00:10:43.030 --> 00:10:46.270
 Spring 的心情真的很有意义

00:10:44.770 --> 00:10:48.130
像OSGi这样的应用程序

00:10:46.270 --> 00:10:51.540
对，你不会，你不会

00:10:48.130 --> 00:10:55.720
用骆驼和 Spring 的心情，这是胃肠道

00:10:51.540 --> 00:10:58.390
在一起，那不是希望

00:10:55.720 --> 00:10:59.680
在这种情况下保持冷静，所以在那里

00:10:58.390 --> 00:11:01.240
对此没有支持吗？ 

00:10:59.680 --> 00:11:02.380
这是完全可以理解的，但是所有

00:11:01.240 --> 00:11:04.710
有趣的东西，所有你的东西

00:11:02.380 --> 00:11:08.110
可能想谈谈我的清单

00:11:04.710 --> 00:11:09.220
观点谦虚有趣

00:11:08.110 --> 00:11:10.600
我当然想要的东西

00:11:09.220 --> 00:11:12.250
与所有仍然有效的对话

00:11:10.600 --> 00:11:15.520
 Springwood，实际上迈出了一步

00:11:12.250 --> 00:11:19.680
更进一步，您会发现有骆驼JMS 

00:11:15.520 --> 00:11:22.990
支持，然后有一个整体

00:11:19.680 --> 00:11:25.870
自动生成的自动配置

00:11:22.990 --> 00:11:30.190
 spring boot 权，这些自动

00:11:25.870 --> 00:11:32.170
配置了解所有

00:11:30.190 --> 00:11:33.670
与这些不同相关的元数据

00:11:32.170 --> 00:11:35.050
组件，让我们来看看

00:11:33.670 --> 00:11:37.000
他们的组成部分，所以看看什么

00:11:35.050 --> 00:11:38.860
这意味着对于 spring boot 用户，我们

00:11:37.000 --> 00:11:39.730
拥有一些正确的组件

00:11:38.860 --> 00:11:42.040
看所有这些不同的组成部分

00:11:39.730 --> 00:11:44.320
 mqp支持PMA，您知道这是Apple 

00:11:42.040 --> 00:11:47.500
通知气氛WebSockets atom 

00:11:44.320 --> 00:11:51.550
 Avro AWS不同ats位的数量

00:11:47.500 --> 00:11:55.840
在那里验证Box API的大脑输入

00:11:51.550 --> 00:12:00.490
 API缓存API我的意思就是这么多

00:11:55.840 --> 00:12:04.860
现在在这里cxf数据集直接DNS 

00:12:00.490 --> 00:12:07.780
破坏者是EJB，每个缓存

00:12:04.860 --> 00:12:08.860
如果您在CD Spring 活动中使用elasticsearch 

00:12:07.780 --> 00:12:12.940
想要将事件发布到

00:12:08.860 --> 00:12:14.710
应用程序上下文我们还得到了什么

00:12:12.940 --> 00:12:19.420
 Facebook，我的意思是文件当然平坦

00:12:14.710 --> 00:12:21.250
包我的意思是眨眼，你知道任务

00:12:19.420 --> 00:12:24.030
右边是数据处理FTP 

00:12:21.250 --> 00:12:27.240
 FTPS神经节急救

00:12:24.030 --> 00:12:31.650
对于Google App Engine来说， 

00:12:27.240 --> 00:12:34.000
 G登录Google日历Google Mail Gora 

00:12:31.650 --> 00:12:39.790
地理宿舍哦，我的天哪

00:12:34.000 --> 00:12:42.960
榛树很漂亮，施了魔法

00:12:39.790 --> 00:12:45.820
从CFS HTS到HipChat 

00:12:42.960 --> 00:12:48.340
 hl7 for Healthcare对医疗保健

00:12:45.820 --> 00:12:51.270
健身锅里的世界就是红帽

00:12:48.340 --> 00:12:53.500
我做这个之前的数据库鱿鱼HTTP 

00:12:51.270 --> 00:12:56.890
点燃这是一个补丁点燃它的

00:12:53.500 --> 00:13:01.030
另一个数据网格IMAP我是PEZ铁MQ 

00:12:56.890 --> 00:13:04.150
 Java空间我不是这个

00:13:01.030 --> 00:13:09.850
我是Java的忠实粉丝，这让我感到难过

00:13:04.150 --> 00:13:10.680
所以杰克云J缓存JDBC码头J 

00:13:09.850 --> 00:13:16.960
 JIRA小组

00:13:10.680 --> 00:13:18.730
 JMS JM x JP是一个震撼的JS cj SCH 

00:13:16.960 --> 00:13:21.490
您曾经使用过的SCP协议

00:13:18.730 --> 00:13:24.430
安全地复制我是米歇尔的东西

00:13:21.490 --> 00:13:26.050
一个UNIX节点到另一个

00:13:24.430 --> 00:13:29.230
嘉实多这是我认为的

00:13:26.050 --> 00:13:30.790
 Twitter高度可扩展的消息队列

00:13:29.230 --> 00:13:33.490
从几年前

00:13:30.790 --> 00:13:34.450
你有Cora你有LDAP 

00:13:33.490 --> 00:13:37.480
支持LinkedIn 

00:13:34.450 --> 00:13:39.610
日志亮氨酸伐木工人指标阿帕奇

00:13:37.480 --> 00:13:41.290
 Mina是内存的电子邮件服务器

00:13:39.610 --> 00:13:43.560
供应

00:13:41.290 --> 00:13:46.800
哦，对不起，那肉是

00:13:43.560 --> 00:13:46.800
那是什么

00:13:49.329 --> 00:13:58.519
这是我的想法

00:13:57.829 --> 00:14:10.990
其他的东西

00:13:58.519 --> 00:14:10.990
米娜是什么是米娜

00:14:13.430 --> 00:14:17.360
网络应用程序框架还可以

00:14:15.290 --> 00:14:18.680
我正在考虑一个电子邮件服务器

00:14:17.360 --> 00:14:21.110
现在就建在我身上

00:14:18.680 --> 00:14:23.690
阿帕奇生产的我

00:14:21.110 --> 00:14:29.450
回想起带来的好处

00:14:23.690 --> 00:14:30.740
你知道mqtt支持MSV小胡子吗

00:14:29.450 --> 00:14:33.230
否则你会明白我的意思是

00:14:30.740 --> 00:14:33.950
在Nagios上，我的意思是Neddie Neddie HTTP 

00:14:33.230 --> 00:14:36.700
开班

00:14:33.950 --> 00:14:39.589
 paho来了bajo，同样qtt支持

00:14:36.700 --> 00:14:41.990
您知道排放邮政编码的PDF代理

00:14:39.589 --> 00:14:45.290
事件电子邮件有流行音乐和流行音乐三

00:14:41.990 --> 00:14:50.029
打印机属性石英作业rabbim q 

00:14:45.290 --> 00:14:53.240
 rs'让我们大摇大摆是NC放松先生

00:14:50.029 --> 00:14:56.180
 ng紧凑型系统路由箱RSS 

00:14:53.240 --> 00:14:58.880
 salesforce的AP netweaver模式

00:14:56.180 --> 00:15:01.970
我不确定这是什么

00:14:58.880 --> 00:15:03.680
迷彩内部的图案

00:15:01.970 --> 00:15:05.240
您可以，您可以将呼叫转接至

00:15:03.680 --> 00:15:08.390
同一应用程序中的另一个端点

00:15:05.240 --> 00:15:12.020
相同的骆驼应用程序的IP 

00:15:08.390 --> 00:15:14.270
语音对，我的意思是说JMS是一种基础

00:15:12.020 --> 00:15:19.100
 JMS客户端批处理的实现

00:15:14.270 --> 00:15:20.420
支持SMPP的安全权SNMP太阳能

00:15:19.100 --> 00:15:22.760
 apache spark spark火花

00:15:20.420 --> 00:15:24.170
 Splunk Spring Batch Spring 创新

00:15:22.760 --> 00:15:26.480
 Spring LDAP Spring Redis Spring Web 

00:15:24.170 --> 00:15:30.440
服务续集支持存储过程

00:15:26.480 --> 00:15:33.200
支持SSH我还有什么我需要的

00:15:30.440 --> 00:15:36.080
善良Twitter突显了顶点虚拟

00:15:33.200 --> 00:15:38.029
机器WebSockets XML安全性XMPP 

00:15:36.080 --> 00:15:40.070
 Yammer zookeeper哦，天哪，我的意思是

00:15:38.029 --> 00:15:42.290
有太多事情可以

00:15:40.070 --> 00:15:47.089
使用，甚至有很多

00:15:42.290 --> 00:15:48.620
在那里，但它们不属于

00:15:47.089 --> 00:15:50.630
实际分配的

00:15:48.620 --> 00:15:52.490
与阿帕奇骆驼，此列表是

00:15:50.630 --> 00:15:54.589
令人印象深刻的还有很多

00:15:52.490 --> 00:15:56.959
这里真的很酷的东西，所以你再次

00:15:54.589 --> 00:15:59.270
忽略这种财富是愚蠢的

00:15:56.959 --> 00:16:01.310
集成，如果仅仅是因为

00:15:59.270 --> 00:16:02.779
有一个食谱很不错

00:16:01.310 --> 00:16:04.459
能够正确谈论所有这些事情

00:16:02.779 --> 00:16:05.510
我确定您可以编写代码并

00:16:04.459 --> 00:16:06.470
当然，所有人都有整合

00:16:05.510 --> 00:16:09.140
这些东西在最大的 Spring 

00:16:06.470 --> 00:16:11.060
生态系统，但是没有一个伟大的

00:16:09.140 --> 00:16:14.029
没有一个统一的界面

00:16:11.060 --> 00:16:16.400
这些东西，所以真的骆驼可以

00:16:14.029 --> 00:16:18.170
看看这是一个图书馆

00:16:16.400 --> 00:16:20.060
与EDI解析支持一起使用

00:16:18.170 --> 00:16:21.350
使用我称之为“窥探”的东西

00:16:20.060 --> 00:16:22.579
从来没有听说过，但这是

00:16:21.350 --> 00:16:24.320
真的很有趣

00:16:22.579 --> 00:16:26.300
有趣的东西在那里，所以重点

00:16:24.320 --> 00:16:26.910
是我所有这些组件

00:16:26.300 --> 00:16:29.220
提到

00:16:26.910 --> 00:16:35.490
我在哪里把那个列表放在Apache那里

00:16:29.220 --> 00:16:39.180
叫这个，我要叫这个

00:16:35.490 --> 00:16:40.230
组件在这里，我们是此列表中的您

00:16:39.180 --> 00:16:42.450
知道很多不同的组件

00:16:40.230 --> 00:16:44.700
我们使用，我们可以看到那些

00:16:42.450 --> 00:16:51.060
 git存储库中的组件在这里，所以

00:16:44.700 --> 00:16:53.400
 github.com apache camel now 

00:16:51.060 --> 00:16:55.200
骆驼有一个大型的整体仓库

00:16:53.400 --> 00:16:57.740
所有不同的位都是

00:16:55.200 --> 00:17:01.830
在这里的components目录中

00:16:57.740 --> 00:17:03.360
你可以看到其中一些

00:17:01.830 --> 00:17:05.520
所有这些东西

00:17:03.360 --> 00:17:06.960
信息所有与

00:17:05.520 --> 00:17:07.740
支持所有这些不同的选择

00:17:06.960 --> 00:17:10.410
那些不同的东西

00:17:07.740 --> 00:17:17.550
支持进入

00:17:10.410 --> 00:17:19.170
初学者，所以初学者，让我们在那里看看

00:17:17.550 --> 00:17:23.370
你去，所以你可以看到它说平台

00:17:19.170 --> 00:17:27.060
 spring boot 组件启动器和这里

00:17:23.370 --> 00:17:28.350
是所有不同的自动生成的

00:17:27.060 --> 00:17:30.840
再次，这是自动生成的石头

00:17:28.350 --> 00:17:32.880
编码为

00:17:30.840 --> 00:17:34.500
 Pecha的不同骆驼组件

00:17:32.880 --> 00:17:36.570
骆驼对，这一直在那里

00:17:34.500 --> 00:17:37.890
只要Pecha骆驼在附近

00:17:36.570 --> 00:17:40.170
最少要长时间支持

00:17:37.890 --> 00:17:41.340
工具自动需要的元数据

00:17:40.170 --> 00:17:43.490
完成，我们实际上会看到

00:17:41.340 --> 00:17:45.930
在这里，我们在这里

00:17:43.490 --> 00:17:47.190
我在IntelliJ中的Springwood应用程序

00:17:45.930 --> 00:17:49.410
现在运行IntelliJ 

00:17:47.190 --> 00:17:53.150
已加载的插件支持

00:17:49.410 --> 00:17:55.530
 apache骆驼解析路由语法

00:17:53.150 --> 00:17:57.450
在ID内进行修改，这样

00:17:55.530 --> 00:17:59.460
元数据从元数据派生

00:17:57.450 --> 00:18:00.780
编码在这些不同的组件中

00:17:59.460 --> 00:18:02.250
可通过阿帕奇骆驼获得

00:18:00.780 --> 00:18:04.080
嗯，有一个插件，他们使用

00:18:02.250 --> 00:18:06.030
构建插件，使一切

00:18:04.080 --> 00:18:07.650
元数据转换成自动配置

00:18:06.030 --> 00:18:08.760
您可以的配置属性

00:18:07.650 --> 00:18:10.590
用于配置这些不同的

00:18:08.760 --> 00:18:11.580
您可能会使用的方式

00:18:10.590 --> 00:18:14.130
斯普林伍德的其他一切

00:18:11.580 --> 00:18:16.140
生态系统，当您添加这些

00:18:14.130 --> 00:18:19.080
您获得的类路径的依赖

00:18:16.140 --> 00:18:19.950
默认配置的组件

00:18:19.080 --> 00:18:21.930
您想使用就不必

00:18:19.950 --> 00:18:24.060
实际添加或自己配置

00:18:21.930 --> 00:18:26.630
那真的很酷，我是说

00:18:24.060 --> 00:18:29.250
真的真的很酷，所以让我们

00:18:26.630 --> 00:18:31.500
让我们开始看看

00:18:29.250 --> 00:18:34.890
使用apache构建应用程序

00:18:31.500 --> 00:18:36.210
骆驼我们创建一个路线构建器，所以

00:18:34.890 --> 00:18:38.410
假设我要创建一条路线

00:18:36.210 --> 00:18:41.680
型式横梁返回

00:18:38.410 --> 00:18:45.460
新路线生成器，我要添加

00:18:41.680 --> 00:18:47.590
骆驼的路线-上下文

00:18:45.460 --> 00:18:49.630
做到这一点的一种方法肯定是

00:18:47.590 --> 00:18:54.370
如果我们愿意，我们实际上可以做到这一点

00:18:49.630 --> 00:18:58.800
我想覆盖configure方法

00:18:54.370 --> 00:18:58.800
虽然不是这个，所以让我们来看看

00:19:02.860 --> 00:19:13.370
哦哦

00:19:05.510 --> 00:19:16.370
路线建设者路线到建设者那里

00:19:13.370 --> 00:19:18.110
那里有些微妙，我要

00:19:16.370 --> 00:19:20.480
点击配置好，这样

00:19:18.110 --> 00:19:21.559
现在，当我进入这个API时，我的意思是

00:19:20.480 --> 00:19:22.760
只是 Spring 的意思

00:19:21.559 --> 00:19:24.980
我们正在变 Spring 意味着您已经

00:19:22.760 --> 00:19:26.059
可以看到这是你非常

00:19:24.980 --> 00:19:27.710
 spring boot 世界没什么不同

00:19:26.059 --> 00:19:30.679
关于这个，一旦你在那里，你可以

00:19:27.710 --> 00:19:33.200
配置非常简单的路由

00:19:30.679 --> 00:19:36.890
所以我们要做的就是在这里说

00:19:33.200 --> 00:19:38.330
我们想从JMS阅读，然后

00:19:36.890 --> 00:19:40.220
将该数据写入文件，这将

00:19:38.330 --> 00:19:41.840
只是最公正甚至

00:19:40.220 --> 00:19:45.500
最好让我们做一个简单的文件

00:19:41.840 --> 00:19:47.710
文件，所以我要从文件说，然后

00:19:45.500 --> 00:19:50.179
我想实际引用一个属性

00:19:47.710 --> 00:19:53.030
来自房地产的 Spring 心情

00:19:50.179 --> 00:19:54.940
好骆驼自动桥接

00:19:53.030 --> 00:19:57.740
妈妈，我知道我可以在那里

00:19:54.940 --> 00:19:59.960
那是因为对

00:19:57.740 --> 00:20:01.460
骆驼，所以如果我点击这个我可以打

00:19:59.960 --> 00:20:03.799
控制空间，这告诉我

00:20:01.460 --> 00:20:04.940
这是一个参数，所以

00:20:03.799 --> 00:20:07.520
我正在做的是我正在使用组件

00:20:04.940 --> 00:20:08.750
每个组件都有一个

00:20:07.520 --> 00:20:10.850
你到底是哪个目标

00:20:08.750 --> 00:20:13.790
是眼睛，但每个组件都有一个URM 

00:20:10.850 --> 00:20:16.790
语法，它以开头

00:20:13.790 --> 00:20:19.210
看到这里它以名字开头

00:20:16.790 --> 00:20:22.940
组件，那么你知道这个

00:20:19.210 --> 00:20:25.010
您使用的URI可以告诉您一些

00:20:22.940 --> 00:20:26.450
支持的选项有

00:20:25.010 --> 00:20:28.220
你可以看到很多东西是可选的

00:20:26.450 --> 00:20:31.340
以及需要指定的内容

00:20:28.220 --> 00:20:34.030
图腾，但它们的名字因此而得名

00:20:31.340 --> 00:20:38.690
组件拥有自己的位置，并且

00:20:34.030 --> 00:20:41.059
通常，如果我想配置自己的

00:20:38.690 --> 00:20:42.919
如果我想你就在

00:20:41.059 --> 00:20:44.870
配置自己的应用程序

00:20:42.919 --> 00:20:45.230
组件，那么我将不得不做

00:20:44.870 --> 00:20:47.330
我

00:20:45.230 --> 00:20:49.070
所以说我想在我们得到之前

00:20:47.330 --> 00:20:50.900
实际上，在我们走得太远之前

00:20:49.070 --> 00:20:52.460
沿着那条线，说我想

00:20:50.900 --> 00:20:53.960
配置我自己的组件，让我们

00:20:52.460 --> 00:20:56.000
说我想配置自己的JMS 

00:20:53.960 --> 00:20:58.309
组件权我不得不说

00:20:56.000 --> 00:21:00.200
私人最终骆驼语境，我可以

00:20:58.309 --> 00:21:02.210
只是注入这个，这就是

00:21:00.200 --> 00:21:04.490
我要去的Apache骆驼API 

00:21:02.210 --> 00:21:07.250
将其注入到应用程序中，然后

00:21:04.490 --> 00:21:09.860
在那里我会说点骆驼语境

00:21:07.250 --> 00:21:11.600
点添加组件，在这里我可以说我的

00:21:09.860 --> 00:21:14.390
 JMS 

00:21:11.600 --> 00:21:16.310
 Jamis组件点Jamis组件和

00:21:14.390 --> 00:21:18.770
通常您会看到连接

00:21:16.310 --> 00:21:21.410
很好，我们有嵌入式

00:21:18.770 --> 00:21:23.480
 ActiveMQ对交叉路径的支持使我

00:21:21.410 --> 00:21:25.790
可以说首席财务官，那会给我一个

00:21:23.480 --> 00:21:29.470
自动配置，你知道 Spring 会

00:21:25.790 --> 00:21:32.270
自动配置内嵌的activemq 

00:21:29.470 --> 00:21:34.070
 apache activemq实例在那里，我可以

00:21:32.270 --> 00:21:35.690
用它来配置我自己的自定义

00:21:34.070 --> 00:21:37.450
事情，但如果由于我们正在使用

00:21:35.690 --> 00:21:40.250
入门者，而不仅仅是股票标准

00:21:37.450 --> 00:21:41.240
 spring boot ，我开始了一个骆驼我们

00:21:40.250 --> 00:21:42.620
不需要做那个正确的

00:21:41.240 --> 00:21:44.210
实际上已经为我们完成了

00:21:42.620 --> 00:21:47.560
有一个默认的名称默认

00:21:44.210 --> 00:21:51.530
在这种情况下，名称是JMS如此有效

00:21:47.560 --> 00:21:57.770
让我们看看JME是的，你去了

00:21:51.530 --> 00:22:01.460
 q1 ActiveMQ I是否有活动

00:21:57.770 --> 00:22:04.160
认为我们可以略有不同

00:22:01.460 --> 00:22:05.480
使用JMS是我们要做的，那就是

00:22:04.160 --> 00:22:06.740
这实际上是我们的组成部分

00:22:05.480 --> 00:22:09.380
使用的是它备份的JMS组件

00:22:06.740 --> 00:22:13.160
在那里，已经为我们配置了

00:22:09.380 --> 00:22:16.310
我们可以看到在这里我们可以看到JMS 

00:22:13.160 --> 00:22:19.100
组件自动配置

00:22:16.310 --> 00:22:21.200
一个错误的JMS组件自动

00:22:19.100 --> 00:22:23.180
来自orga pachi骆驼的配置

00:22:21.200 --> 00:22:26.780
组件JMS spring boot，您可以

00:22:23.180 --> 00:22:27.980
看到不是，不是两个不同

00:22:26.780 --> 00:22:32.210
您期望有的电话

00:22:27.980 --> 00:22:33.830
只是一套西装，这里的代码还可以

00:22:32.210 --> 00:22:35.570
看一下骆驼产生的

00:22:33.830 --> 00:22:37.670
打包maven插件，所以这就是

00:22:35.570 --> 00:22:39.680
根据以下内容自动生成

00:22:37.670 --> 00:22:41.450
元数据和验证

00:22:39.680 --> 00:22:43.670
这发生在

00:22:41.450 --> 00:22:45.170
初始化和注册

00:22:43.670 --> 00:22:47.480
我们所需要的一切就是

00:22:45.170 --> 00:22:49.670
真的很棒，这就是全部

00:22:47.480 --> 00:22:51.230
在那里，结果是我不必

00:22:49.670 --> 00:22:52.940
担心这个，所以我们可以参考

00:22:51.230 --> 00:22:54.920
这些文件（如果我离开的话） 

00:22:52.940 --> 00:22:56.780
就像我已经离开我们那里一样

00:22:54.920 --> 00:22:59.030
想参考一条消息

00:22:56.780 --> 00:23:03.380
那个贾米斯立方体，然后我会

00:22:59.030 --> 00:23:06.440
说从我的JMS和提示名称会

00:23:03.380 --> 00:23:08.480
是我的提示，所以那将是

00:23:06.440 --> 00:23:10.900
我将作为一个示例语法

00:23:08.480 --> 00:23:15.980
会产生讯息的东西

00:23:10.900 --> 00:23:18.950
所以让我们删除它，我们会回来

00:23:15.980 --> 00:23:20.900
一分钟后就可以了

00:23:18.950 --> 00:23:22.670
冒号，然后是某种文件系统

00:23:20.900 --> 00:23:25.210
参考，所以在这里我想参考一个

00:23:22.670 --> 00:23:26.980
来自财产来源的财产

00:23:25.210 --> 00:23:29.649
从 spring boot 的属性源

00:23:26.980 --> 00:23:31.169
知道所以我会说卷曲刹车

00:23:29.649 --> 00:23:33.700
大括号是它的语法

00:23:31.169 --> 00:23:36.490
骆驼路线骆驼了解

00:23:33.700 --> 00:23:38.679
语法，但这也弥合了

00:23:36.490 --> 00:23:40.450
简单的表达方式

00:23:38.679 --> 00:23:42.879
语言已经与

00:23:40.450 --> 00:23:44.110
 Spring 的财产来源引导它

00:23:42.879 --> 00:23:45.340
了解 Spring 的特性

00:23:44.110 --> 00:23:46.990
引导他们无论是什么，如果他们是

00:23:45.340 --> 00:23:48.340
来自配置服务器，如果

00:23:46.990 --> 00:23:49.659
他们来自--论点

00:23:48.340 --> 00:23:52.029
属性的应用

00:23:49.659 --> 00:23:53.919
了解有关属性来源spi的信息

00:23:52.029 --> 00:23:56.919
 spring boot ，所以我只能说用户

00:23:53.919 --> 00:23:58.450
家，这给了我你所知道的

00:23:56.919 --> 00:24:00.730
我的案件回家一天

00:23:58.450 --> 00:24:06.450
无论如何，那么它将成为

00:24:00.730 --> 00:24:08.409
家用台式机，我们要说- 

00:24:06.450 --> 00:24:13.330
 JMS没事

00:24:08.409 --> 00:24:15.580
或更好的另一个目录

00:24:13.330 --> 00:24:16.929
我们要做一个非常简单非常简单

00:24:15.580 --> 00:24:23.220
说唱只是一条非常简单的路线

00:24:16.929 --> 00:24:23.220
我要说的是文件用户点回家

00:24:23.940 --> 00:24:34.179
桌面，您知道吗？ 

00:24:30.360 --> 00:24:35.379
所以没事就这么简单

00:24:34.179 --> 00:24:37.840
因为真的我不认为你可以

00:24:35.379 --> 00:24:39.369
比这简单得多，并保持我们

00:24:37.840 --> 00:24:41.559
实际上暂时不需要这个

00:24:39.369 --> 00:24:43.149
给我这个好吧，让我们看看

00:24:41.559 --> 00:24:44.679
看起来我要继续前进

00:24:43.149 --> 00:24:46.360
这个应用程序并顺利运行

00:24:44.679 --> 00:24:49.529
这个代码的第一个问题是

00:24:46.360 --> 00:24:49.529
写得很好

00:24:55.010 --> 00:25:02.060
是的，我们首先是我们的第一个问题

00:25:03.140 --> 00:25:07.410
用钥匙正确哦忘记了这一点

00:25:06.630 --> 00:25:09.030
不是我的第一个问题

00:25:07.410 --> 00:25:11.390
期待，虽然很好

00:25:09.030 --> 00:25:11.390
被抓

00:25:24.920 --> 00:25:30.320
好吧，这是我们的第一个问题

00:25:26.870 --> 00:25:31.910
应用程序已经关闭了

00:25:30.320 --> 00:25:33.560
所以没有什么可以保留主要

00:25:31.910 --> 00:25:34.760
线程还活着，或者我想那是

00:25:33.560 --> 00:25:36.950
保持生命的东西，但是

00:25:34.760 --> 00:25:38.660
远不是阿帕奇骆驼

00:25:36.950 --> 00:25:39.290
就其而言，它不会留下来

00:25:38.660 --> 00:25:40.940
活

00:25:39.290 --> 00:25:42.290
那可能是正确的

00:25:40.940 --> 00:25:44.120
因为我们知道我们没什么要

00:25:42.290 --> 00:25:45.680
显式延长线程，以便

00:25:44.120 --> 00:25:47.140
为了使它正常工作，我们必须设置

00:25:45.680 --> 00:25:49.070
这里的财产，这是

00:25:47.140 --> 00:25:51.830
我们可以设置的属性

00:25:49.070 --> 00:25:55.190
阿帕奇骆驼，那个财产是

00:25:51.830 --> 00:25:58.100
让我们看看它叫做 Spring ，但是-骆驼

00:25:55.190 --> 00:26:02.990
点Spring 但-主控制器

00:25:58.100 --> 00:26:03.890
等于真正的真实时代，所以他们可以走

00:26:02.990 --> 00:26:06.380
顺便说一句，你看到所有那些

00:26:03.890 --> 00:26:07.400
骆驼的财产全部来自

00:26:06.380 --> 00:26:09.200
不同的属性是

00:26:07.400 --> 00:26:10.760
支持这些不同的组件

00:26:09.200 --> 00:26:12.920
对其中一些在类路径上

00:26:10.760 --> 00:26:14.540
已经，但是其中有无数

00:26:12.920 --> 00:26:15.830
不在课程路径上，所以

00:26:14.540 --> 00:26:18.980
令人惊讶的是我们拥有所有这些支持

00:26:15.830 --> 00:26:20.510
现在我们可以再次运行该框了

00:26:18.980 --> 00:26:25.430
希望这次可以参加JMS 

00:26:20.510 --> 00:26:27.010
支持不会立即崩溃

00:26:25.430 --> 00:26:29.300
正确的看起来我们在做生意，所以

00:26:27.010 --> 00:26:32.480
忽略ActiveMQ的东西，因为我

00:26:29.300 --> 00:26:33.470
所以我们现在还没有使用它，但是让我们

00:26:32.480 --> 00:26:35.300
谈论这个，我们现在有了

00:26:33.470 --> 00:26:43.160
我们有进出的应用程序

00:26:35.300 --> 00:26:44.840
目录，如果我进入桌面，我可以

00:26:43.160 --> 00:26:50.050
我可以删除的方式

00:26:44.840 --> 00:26:50.050
删除并重新开始

00:26:52.809 --> 00:26:59.870
在右边，所以骆驼为它创建了

00:26:56.059 --> 00:27:01.160
我好吧，这里我们随机回显

00:26:59.870 --> 00:27:08.540
我要在这里使用随机变量

00:27:01.160 --> 00:27:13.250
说随机点txt回声到随机txt 

00:27:08.540 --> 00:27:15.950
现在在这里，我要看

00:27:13.250 --> 00:27:21.170
之前的输出目录，所以我将

00:27:15.950 --> 00:27:22.250
说手表-n 1 LS la好说话

00:27:21.170 --> 00:27:24.950
每秒钟我都会看这个

00:27:22.250 --> 00:27:27.620
目录，所以如果我再次这样做，您可以

00:27:24.950 --> 00:27:30.320
看到它很快就会恢复

00:27:27.620 --> 00:27:31.780
很棒的新文件，所以

00:27:30.320 --> 00:27:35.300
很酷，我们非常简单

00:27:31.780 --> 00:27:37.610
骆驼的支持现在我们可以在那里

00:27:35.300 --> 00:27:39.860
是文件组件的选项

00:27:37.610 --> 00:27:42.290
这是数据的生产者，这是

00:27:39.860 --> 00:27:43.850
消费者，我们对此有选择

00:27:42.290 --> 00:27:44.960
组件以及是否要指定它们

00:27:43.850 --> 00:27:46.490
你可以做几个不同的事情

00:27:44.960 --> 00:27:48.530
让我们看看最简单的方法

00:27:46.490 --> 00:27:53.360
您所在的位置或URL中的

00:27:48.530 --> 00:27:58.220
语法正确，所以文件还可以， 

00:27:53.360 --> 00:28:00.830
通常在这里找到所有选项

00:27:58.220 --> 00:28:02.690
对，所以我想自动创建它

00:28:00.830 --> 00:28:08.950
可以说自动付款等于假

00:28:02.690 --> 00:28:11.660
正确，因此自动创建等于false并且

00:28:08.950 --> 00:28:14.540
看看如果我击中控制空间

00:28:11.660 --> 00:28:16.490
 IDE支持给了我所有这些不同

00:28:14.540 --> 00:28:19.670
此处的选项dunno文件名可以

00:28:16.490 --> 00:28:22.880
例如做得好，那就是

00:28:19.670 --> 00:28:25.190
将创建到的文件名

00:28:22.880 --> 00:28:27.020
向某种消费者过程发出信号

00:28:25.190 --> 00:28:29.660
该文件已经完全

00:28:27.020 --> 00:28:32.600
写到目的地的权利，所以

00:28:29.660 --> 00:28:35.030
消费者会知道不摄取

00:28:32.600 --> 00:28:36.950
读取或处理仅

00:28:35.030 --> 00:28:38.420
被复制直到看到完成的文件

00:28:36.950 --> 00:28:40.370
对，这是一个非常常见的模式

00:28:38.420 --> 00:28:45.980
您会在邮件系统中看到正确的信息

00:28:40.370 --> 00:28:47.720
你可以说你可以说你想

00:28:45.980 --> 00:28:50.390
提供一个不同的文件名

00:28:47.720 --> 00:28:51.530
说你知道它存在并且它你

00:28:50.390 --> 00:28:53.630
知道你有什么选择

00:28:51.530 --> 00:28:55.010
存在，您可以追加失败忽略移动

00:28:53.630 --> 00:28:58.550
覆盖很多不同的权利

00:28:55.010 --> 00:28:59.900
那里的选择是很多不同

00:28:58.550 --> 00:29:01.460
这里有很多不同的有用选项

00:28:59.900 --> 00:29:02.630
移动现有的力量

00:29:01.460 --> 00:29:03.860
权利，我是说所有这些不同的种类

00:29:02.630 --> 00:29:06.559
大胆的东西

00:29:03.860 --> 00:29:07.580
经常使用或推荐的

00:29:06.559 --> 00:29:09.290
这些是你应该付的

00:29:07.580 --> 00:29:11.179
对其他人的关注较少

00:29:09.290 --> 00:29:13.040
有趣，但是它们很有用，所以

00:29:11.179 --> 00:29:14.420
所有的支持都在那里，我向您展示

00:29:13.040 --> 00:29:15.740
智能插件，但你不是

00:29:14.420 --> 00:29:17.330
使用IntelliJ就可以了

00:29:15.740 --> 00:29:20.179
那东西就是它正在产生

00:29:17.330 --> 00:29:21.860
直接从相同的信息

00:29:20.179 --> 00:29:24.020
生成此表的相同来源

00:29:21.860 --> 00:29:25.250
充满了元数据的旋转

00:29:24.020 --> 00:29:31.250
启动启动器和配置

00:29:25.250 --> 00:29:32.570
是的，所以很多

00:29:31.250 --> 00:29:36.590
非常有趣的东西，我是你

00:29:32.570 --> 00:29:38.179
知道真正给它留下深刻印象的是

00:29:36.590 --> 00:29:39.830
一个很简单的例子好吧，让我们

00:29:38.179 --> 00:29:41.179
再尝试一点点

00:29:39.830 --> 00:29:44.480
精致的好

00:29:41.179 --> 00:29:45.740
只是一点点，所以现在让我们看一下JMS 

00:29:44.480 --> 00:29:47.710
好吧

00:29:45.740 --> 00:29:50.240
顺便说一下，我们的应用程序具有路线名称

00:29:47.710 --> 00:29:54.020
在我开始之前，我要继续前进，所以让我们

00:29:50.240 --> 00:29:56.590
说我们要给我们一个路线ID 

00:29:54.020 --> 00:29:58.940
被称为一条路线，所以它将在

00:29:56.590 --> 00:30:00.230
两个出来，然后变得有用

00:29:58.940 --> 00:30:01.640
因为当您添加更多路线到

00:30:00.230 --> 00:30:03.260
系统，您将需要能够

00:30:01.640 --> 00:30:05.299
识别正在做什么和在哪里做

00:30:03.260 --> 00:30:06.500
错误即将来临，所以现在

00:30:05.299 --> 00:30:08.660
可以看到该应用程序何时启动

00:30:06.500 --> 00:30:10.850
它说一共有一条路线

00:30:08.660 --> 00:30:12.650
您知道哪一个开始了

00:30:10.850 --> 00:30:15.559
一条路线很好，这是通用名称

00:30:12.650 --> 00:30:17.480
从那条路线上得到的，但我们可以

00:30:15.559 --> 00:30:19.730
给它起一个更人性化的名字

00:30:17.480 --> 00:30:22.160
那里现在是人类可识别的名字

00:30:19.730 --> 00:30:25.970
我们要说我们要处理

00:30:22.160 --> 00:30:27.230
文件，然后将其转换为

00:30:25.970 --> 00:30:30.110
字符串，然后将其发送到

00:30:27.230 --> 00:30:32.570
 JMS好的，所以这要稍微多一点

00:30:30.110 --> 00:30:40.700
涉及的例子，所以在这里我要

00:30:32.570 --> 00:30:43.280
说文件用户点主页仅位于前两个JMS 

00:30:40.700 --> 00:30:44.570
好的，我要说的是路线ID 

00:30:43.280 --> 00:30:45.980
将会一次又一次完全

00:30:44.570 --> 00:30:48.080
任意的，您不必指定

00:30:45.980 --> 00:30:52.400
正确的主意，但我要说文件- 

00:30:48.080 --> 00:30:57.230
路径ID或对不起文件-JMS和此处

00:30:52.400 --> 00:31:01.190
我将其发送到JMS，然后

00:30:57.230 --> 00:31:02.840
将其设置为Q，Q是正确的

00:31:01.190 --> 00:31:04.760
这是一个Qo，并将其发送给Q in 

00:31:02.840 --> 00:31:06.169
这种情况是任意的，我只是

00:31:04.760 --> 00:31:07.460
称它为文件正是我想要的

00:31:06.169 --> 00:31:09.740
我想在其中称呼它

00:31:07.460 --> 00:31:11.179
 ActiveMQ经纪人现在可以了，这是我

00:31:09.740 --> 00:31:12.559
想在这里足够

00:31:11.179 --> 00:31:16.770
真正让你知道这会工作

00:31:12.559 --> 00:31:18.690
但是我们真的不能

00:31:16.770 --> 00:31:21.180
你知道我们得到什么我们得到什么

00:31:18.690 --> 00:31:23.000
从这个组件出来的

00:31:21.180 --> 00:31:26.250
生产出来的东西

00:31:23.000 --> 00:31:27.600
不一定属于一个

00:31:26.250 --> 00:31:29.340
 JMS代理，因此无论实际想要

00:31:27.600 --> 00:31:30.870
我要做的就是拿走生产出来的

00:31:29.340 --> 00:31:33.390
从这个文件出来的东西

00:31:30.870 --> 00:31:35.070
某种适应它，你知道一个

00:31:33.390 --> 00:31:37.890
把它变成我可以的东西

00:31:35.070 --> 00:31:39.480
然后发送到下游下游

00:31:37.890 --> 00:31:42.270
 Jamis经纪人，所以我要做的是

00:31:39.480 --> 00:31:44.130
我要说的是转变，当我

00:31:42.270 --> 00:31:46.950
转换它，我想指定

00:31:44.130 --> 00:31:49.020
我想在这种情况下进行转换的一部分

00:31:46.950 --> 00:31:51.060
好好变换身体，我要走了

00:31:49.020 --> 00:31:53.010
说那个身体我是一个身体

00:31:51.060 --> 00:31:54.800
期望是一种通用文件，所以

00:31:53.010 --> 00:31:58.290
我将在这里使用类型令牌

00:31:54.800 --> 00:31:59.670
直接文件点类，我要去

00:31:58.290 --> 00:32:01.470
在这里写并创建一个小lambda 

00:31:59.670 --> 00:32:05.730
我将使用一个不错的功能性API 

00:32:01.470 --> 00:32:07.800
把那个gf变成我可以的东西

00:32:05.730 --> 00:32:11.640
然后向后发送或向右发送

00:32:07.800 --> 00:32:13.290
所以我要说尝试一下bufferedreader 

00:32:11.640 --> 00:32:16.050
知道我在这里是我有一个GF， 

00:32:13.290 --> 00:32:18.230
 GF有一个点文件，我可以阅读

00:32:16.050 --> 00:32:25.560
这样的文件我可以说文件类点

00:32:18.230 --> 00:32:28.320
投下并转好，我可以

00:32:25.560 --> 00:32:36.350
现在，我想把它变成gf，所以

00:32:28.320 --> 00:32:40.220
让我们看看什么是GF gf通用文件

00:32:36.350 --> 00:32:40.220
是的，似乎还可以

00:32:42.520 --> 00:32:50.710
是的，好的，为什么你不满意它

00:32:50.740 --> 00:32:57.490
文件F等于文件实际文件

00:32:58.650 --> 00:33:08.279
得到文件啊对，因为我需要演员

00:33:01.740 --> 00:33:10.640
这个文件躲避类点全部

00:33:08.279 --> 00:33:15.120
好吧，只是在这里撒了粉

00:33:10.640 --> 00:33:16.500
让事情变得更艰难，让我们看看

00:33:15.120 --> 00:33:21.690
没告诉你你过得很不好

00:33:16.500 --> 00:33:23.820
让我们尝试暂时不返回只是为了啊

00:33:21.690 --> 00:33:25.260
在那里，有些东西已经准备好了

00:33:23.820 --> 00:33:26.789
 IntelliJ和

00:33:25.260 --> 00:33:29.490
编译器没问题，所以我们现在知道了

00:33:26.789 --> 00:33:31.020
我们有实际的文件，我们想

00:33:29.490 --> 00:33:32.370
拿走文件，我们要解压

00:33:31.020 --> 00:33:34.590
该文件中的数据，因此我将创建

00:33:32.370 --> 00:33:39.179
文件输入流，我要包装

00:33:34.590 --> 00:33:40.320
在输入流阅读器中，我是

00:33:39.179 --> 00:33:41.909
要将其包装在bufferedreader中，这样

00:33:40.320 --> 00:33:44.220
我要做很多不同的事情

00:33:41.909 --> 00:33:46.559
需要成为我需要的资源

00:33:44.220 --> 00:33:48.299
资源化然后破坏

00:33:46.559 --> 00:33:50.190
自然，这对于

00:33:48.299 --> 00:33:51.480
尝试使用可关闭模式

00:33:50.190 --> 00:33:54.149
在Java 7中，我要说

00:33:51.480 --> 00:33:58.919
等于新缓冲的bufferedreader 

00:33:54.149 --> 00:34:01.590
阅读器新输入流阅读器新文件

00:33:58.919 --> 00:34:04.200
输入流，我要传递

00:34:01.590 --> 00:34:06.779
实际文件，当然这

00:34:04.200 --> 00:34:09.990
创建一个可能的异常，所以我将添加

00:34:06.779 --> 00:34:12.089
一个catch子句，我们将抛出

00:34:09.990 --> 00:34:13.050
这段代码我会抛出这个异常

00:34:12.089 --> 00:34:14.790
如果我们应该看到它，因为

00:34:13.050 --> 00:34:15.839
我们真的无能为力

00:34:14.790 --> 00:34:18.030
只是在流程中间

00:34:15.839 --> 00:34:23.060
如果我们在这里不能处理

00:34:18.030 --> 00:34:29.970
今晚无法处理，所以好

00:34:23.060 --> 00:34:31.129
在这里，我们要说，我们想

00:34:29.970 --> 00:34:35.310
获取数据，所以我要说返回

00:34:31.129 --> 00:34:38.790
点读线或那里缓冲的

00:34:35.310 --> 00:34:40.710
但以点线我要

00:34:38.790 --> 00:34:44.339
 lines是Java 8的代码流

00:34:40.710 --> 00:34:48.419
我要把它们收集到一个

00:34:44.339 --> 00:34:51.859
字符串收集者用餐我知道那会

00:34:48.419 --> 00:34:52.980
你知道对我来说变成一串

00:34:51.859 --> 00:34:54.149
好的

00:34:52.980 --> 00:34:55.379
我们去了，所以我实际上只是在服用

00:34:54.149 --> 00:34:57.359
来自通用的数据

00:34:55.379 --> 00:34:59.369
文件是一个骆驼包装

00:34:57.359 --> 00:35:01.320
文件转换为具有

00:34:59.369 --> 00:35:02.400
有关的信息元信息

00:35:01.320 --> 00:35:03.570
文件，但实际上并不一定要

00:35:02.400 --> 00:35:05.190
一个有趣的Java文件

00:35:03.570 --> 00:35:07.770
这可能是通用文件

00:35:05.190 --> 00:35:08.970
例如可能是包装纸

00:35:07.770 --> 00:35:09.880
用于ftp服务器的东西

00:35:08.970 --> 00:35:12.370
否则对

00:35:09.880 --> 00:35:15.580
你你的不可知论者

00:35:12.370 --> 00:35:20.530
基础资源很好，所以我们去了

00:35:15.580 --> 00:35:22.720
现在我们想要什么我们希望看到

00:35:20.530 --> 00:35:24.580
该文件，该信息

00:35:22.720 --> 00:35:26.650
无论该文件中的内容如何发送

00:35:24.580 --> 00:35:28.870
到这个Ja那教广场，所以终于到了这里

00:35:26.650 --> 00:35:30.960
让我们建立一个例子

00:35:28.870 --> 00:35:36.670
侦听该队列中的传入消息

00:35:30.960 --> 00:35:38.740
通知，因此来自JMS队列文件和

00:35:36.670 --> 00:35:40.500
我要做的就是处理数据

00:35:38.740 --> 00:35:43.500
对，我要创建一个新处理器

00:35:40.500 --> 00:35:45.460
这里

00:35:43.500 --> 00:35:46.750
或更好，但我们只写给

00:35:45.460 --> 00:35:49.600
文件系统是个好主意

00:35:46.750 --> 00:35:55.470
我们可以这样做，所以只需将其写到

00:35:49.600 --> 00:35:55.470
我们会向用户点home发出的文件

00:35:57.270 --> 00:36:04.050
可以从JMS桌面下载，所以我们

00:36:02.500 --> 00:36:07.120
做一个真正的外接看这是谁

00:36:04.050 --> 00:36:11.050
来自文件系统的路由

00:36:07.120 --> 00:36:13.060
到JMS到骆驼，然后到文件

00:36:11.050 --> 00:36:14.260
系统再次，我们只是花了很长时间

00:36:13.060 --> 00:36:16.690
只是为了表明我们可以

00:36:14.260 --> 00:36:18.700
这个我有点可爱但是嘿

00:36:16.690 --> 00:36:21.040
有点有趣吧

00:36:18.700 --> 00:36:22.450
所以，我们想称这条路线为

00:36:21.040 --> 00:36:32.940
应该给它起个名字，因为我们相信

00:36:22.450 --> 00:36:34.210
名称中的名称应该来自于JMS两个

00:36:32.940 --> 00:36:37.540
档案

00:36:34.210 --> 00:36:40.470
好的怎么样，现在让我们尝试一下

00:36:37.540 --> 00:36:40.470
我们去重新启动应用程序

00:36:48.859 --> 00:36:54.589
好吧，我做错了什么连接

00:36:51.979 --> 00:36:56.809
必须正确指定工厂，以便

00:36:54.589 --> 00:36:59.180
这是一个属性，需要

00:36:56.809 --> 00:37:01.759
在JMS配置中指定

00:36:59.180 --> 00:37:05.390
如果您看一下Jamis的配置

00:37:01.759 --> 00:37:07.459
这实际上是

00:37:05.390 --> 00:37:10.009
属性可能是一回事

00:37:07.459 --> 00:37:12.319
由配置指定

00:37:10.009 --> 00:37:19.450
属性，以便找到用法，您可以

00:37:12.319 --> 00:37:22.329
看到这里贾米斯配置

00:37:19.450 --> 00:37:26.719
 Jamis汽车的国家在哪里Jamis 

00:37:22.329 --> 00:37:29.839
组件自动配置，这是

00:37:26.719 --> 00:37:31.190
从阿帕奇骆驼那里，你可以看到

00:37:29.839 --> 00:37:33.049
它具有Jamis组件

00:37:31.190 --> 00:37:35.869
配置就可以了

00:37:33.049 --> 00:37:38.450
我们想注入的是

00:37:35.869 --> 00:37:41.089
也就是您知道它被标记为

00:37:38.450 --> 00:37:41.989
配置属性POJO，所以这是

00:37:41.089 --> 00:37:44.479
具有所有这些不同的东西

00:37:41.989 --> 00:37:45.650
我们要使用的属性有

00:37:44.479 --> 00:37:47.509
是根据

00:37:45.650 --> 00:37:51.109
元数据而不是Apache骆驼

00:37:47.509 --> 00:37:52.459
插件，我们已经在这里，我们想要

00:37:51.109 --> 00:37:54.859
能够指定那些属性

00:37:52.459 --> 00:37:57.289
我们可以肯定可以尝试一下

00:37:54.859 --> 00:37:59.420
意思是我们可以说

00:37:57.289 --> 00:38:02.209
 DMF星型连接工厂的组件

00:37:59.420 --> 00:38:04.099
然后这是财产有多好

00:38:02.209 --> 00:38:06.019
它期待一个指向连接的指针

00:38:04.099 --> 00:38:08.569
工厂，所以这不是一个很好的选择

00:38:06.019 --> 00:38:09.829
因为我们正在尝试做的是

00:38:08.569 --> 00:38:12.829
想要使用属性文件来做到这一点

00:38:09.829 --> 00:38:15.229
因此，我们将使用

00:38:12.829 --> 00:38:16.670
组件定制程序好吧，我们要

00:38:15.229 --> 00:38:19.690
注入我们要告诉我们

00:38:16.670 --> 00:38:21.920
给它这个配置的参考

00:38:19.690 --> 00:38:23.719
连接工厂就像我们之前所做的那样

00:38:21.920 --> 00:38:28.789
记得我说过这个文档骆驼语境

00:38:23.719 --> 00:38:32.420
上帝添加组件我的JMS，我不得不

00:38:28.789 --> 00:38:34.549
给它一个指向连接的指针

00:38:32.420 --> 00:38:35.569
那里的工厂我不会

00:38:34.549 --> 00:38:38.329
知道我需要做这样的事情

00:38:35.569 --> 00:38:41.719
仍然，但是我需要影响现有的

00:38:38.329 --> 00:38:43.729
 Springwood Auto配置的JMS组件

00:38:41.719 --> 00:38:45.559
 Petrikov而不是实例化

00:38:43.729 --> 00:38:46.579
并如此管理自己的一切

00:38:45.559 --> 00:38:48.680
大多数组件将具有

00:38:46.579 --> 00:38:49.729
那样的建造者不是

00:38:48.680 --> 00:38:52.339
自动生成只是其中的一部分

00:38:49.729 --> 00:38:53.859
 API现在在这种情况下，我需要使用

00:38:52.339 --> 00:38:57.440
组件定制器，所以我要说

00:38:53.859 --> 00:39:01.990
静态类

00:38:57.440 --> 00:39:05.780
默认的JMS组件定制器

00:39:01.990 --> 00:39:08.030
实现组件的定制程序

00:39:05.780 --> 00:39:10.010
 JMS组件，这是一个接口

00:39:08.030 --> 00:39:12.110
骆驼回调接口

00:39:10.010 --> 00:39:15.050
 Spring Boot自动配置感知

00:39:12.110 --> 00:39:18.290
它会呼叫并给

00:39:15.050 --> 00:39:20.060
覆盖此特定组件是

00:39:18.290 --> 00:39:23.600
这个特殊的植入

00:39:20.060 --> 00:39:26.180
组件，并按类型键入

00:39:23.600 --> 00:39:28.040
现在我们有了Jamis组件

00:39:26.180 --> 00:39:30.470
我要说的是组件点集

00:39:28.040 --> 00:39:32.630
连接工厂，我想给它

00:39:30.470 --> 00:39:34.310
指向该连接因子的指针

00:39:32.630 --> 00:39:35.960
我们获得自动的JMS连接因子

00:39:34.310 --> 00:39:39.500
由Springwood本身为我们配置

00:39:35.960 --> 00:39:41.950
好的，这样完成后，让我们尝试

00:39:39.500 --> 00:39:41.950
再来一次

00:39:49.279 --> 00:39:53.729
好吧，一切似乎都好，我们

00:39:52.019 --> 00:39:55.049
你知道我们有不同的路线

00:39:53.729 --> 00:40:01.049
从这里开始的总共三条路线

00:39:55.049 --> 00:40:02.910
好吧，让我们开始公开

00:40:01.049 --> 00:40:04.529
目录，我们要对JMS说

00:40:02.910 --> 00:40:06.329
这是一次目录

00:40:04.529 --> 00:40:15.619
我知道您会为此写入数据

00:40:06.329 --> 00:40:20.309
希望它反映在这里好吧，所以去

00:40:15.619 --> 00:40:21.660
来自JMS，我们可以看到

00:40:20.309 --> 00:40:23.459
档案84101 

00:40:21.660 --> 00:40:26.009
好了，所以我们有一个文本文件

00:40:23.459 --> 00:40:26.969
刚刚创建的，这正是我们

00:40:26.009 --> 00:40:30.239
想看对的就是那

00:40:26.969 --> 00:40:32.009
实际上通过嵌入式JMS 

00:40:30.239 --> 00:40:33.479
消息队列，它已经进入Janus 

00:40:32.009 --> 00:40:38.579
我已经写在这里

00:40:33.479 --> 00:40:41.069
现在非常有我们了

00:40:38.579 --> 00:40:46.890
知道我们已经满足于离开

00:40:41.069 --> 00:40:48.239
文件名，最多与其匹配

00:40:46.890 --> 00:40:50.819
输入文件基本上已经

00:40:48.239 --> 00:40:53.999
保留在标题中，因此当

00:40:50.819 --> 00:40:56.279
消息来自的消息

00:40:53.999 --> 00:40:58.680
这个文件系统有一些头

00:40:56.279 --> 00:41:00.599
该消息中编码的

00:40:58.680 --> 00:41:02.670
永久存在于JMS中，并且

00:41:00.599 --> 00:41:04.799
消费者对事物可见

00:41:02.670 --> 00:41:06.329
这消除了主要信息

00:41:04.799 --> 00:41:08.069
 JMS，然后将其写入数据库

00:41:06.329 --> 00:41:09.359
尽管我们可以覆盖其中的一些

00:41:08.069 --> 00:41:10.709
可以处理这些数据，我们可以做的一切

00:41:09.359 --> 00:41:12.150
有趣的事情，所以让我们

00:41:10.709 --> 00:41:13.769
说说其中的一些，让我们说

00:41:12.150 --> 00:41:16.259
假设我想例如

00:41:13.769 --> 00:41:18.239
更改标题或很好地设置击球手

00:41:16.259 --> 00:41:22.009
有一些知名的标题

00:41:18.239 --> 00:41:24.809
骆驼文件名

00:41:22.009 --> 00:41:26.789
组件正确，所以这里要问

00:41:24.809 --> 00:41:29.309
我另一个提供了这样的表达

00:41:26.789 --> 00:41:31.079
例如我可以使用一个简单的

00:41:29.309 --> 00:41:35.219
如果我在这里表达语言

00:41:31.079 --> 00:41:37.109
我想可以做身体点

00:41:35.219 --> 00:41:38.940
你有很多不同的东西

00:41:37.109 --> 00:41:40.319
可以在那里做，这是一种表达

00:41:38.940 --> 00:41:42.869
骆驼修补所特有的语言

00:41:40.319 --> 00:41:44.549
但也支持其他类型的

00:41:42.869 --> 00:41:46.680
表达语言有拼写吗

00:41:44.549 --> 00:41:48.749
可能有咒语，有很多

00:41:46.680 --> 00:41:52.469
差异权是一种选择，否则我们

00:41:48.749 --> 00:41:53.849
可以使用供应商Java 8供应商，以便

00:41:52.469 --> 00:41:56.819
那就是我要在这里做的

00:41:53.849 --> 00:42:00.349
说如果您要我的价值，我会

00:41:56.819 --> 00:42:04.039
只是说UUID点随机2个字符串点

00:42:00.349 --> 00:42:05.359
点txt没问题，所以我已经更新了

00:42:04.039 --> 00:42:12.710
标头现在让我们继续前进，我们进入了

00:42:05.359 --> 00:42:14.270
这段代码，看看是否可以

00:42:12.710 --> 00:42:17.539
这样您就可以看到旧的语法

00:42:14.270 --> 00:42:22.490
编号JMS的旧方法是

00:42:17.539 --> 00:42:24.109
这让我们写下来

00:42:22.490 --> 00:42:33.020
其实我想跟贾米斯说

00:42:24.109 --> 00:42:35.390
看-n L SLA好吧，我们去了

00:42:33.020 --> 00:42:37.099
您会看到新文件有一个

00:42:35.390 --> 00:42:38.569
完全不同的名称，所以这是一个

00:42:37.099 --> 00:42:40.579
基本影响管道的方式

00:42:38.569 --> 00:42:42.079
因为您可以覆盖众所周知的标题

00:42:40.579 --> 00:42:44.119
这些标题当然也是

00:42:42.079 --> 00:42:46.039
有据可查，所以如果你去这里

00:42:44.119 --> 00:42:47.450
查看所有不同的属性和

00:42:46.039 --> 00:42:50.150
这是您的一些标题

00:42:47.450 --> 00:42:52.549
您可以期望了解一下吗

00:42:50.150 --> 00:42:54.170
为此这些不同的术语

00:42:52.549 --> 00:42:55.819
不同的组件，这是

00:42:54.170 --> 00:42:57.500
全部允许这是自动的

00:42:55.819 --> 00:43:00.940
根据组件生成

00:42:57.500 --> 00:43:03.440
本身，所以这不受

00:43:00.940 --> 00:43:04.849
有人很勤奋我的意思是对不起

00:43:03.440 --> 00:43:06.380
我只是很勤奋

00:43:04.849 --> 00:43:08.210
说这不受某人的约束

00:43:06.380 --> 00:43:09.680
每更新一次文档

00:43:08.210 --> 00:43:10.940
时间有一个代码更改这只是

00:43:09.680 --> 00:43:14.539
自动完成，这很棒

00:43:10.940 --> 00:43:17.720
现在啊，这是改变的一种方式

00:43:14.539 --> 00:43:19.279
或自定义路线，我们有一个

00:43:17.720 --> 00:43:21.500
我们从这里说的非常简单的路线

00:43:19.279 --> 00:43:22.809
端点改变标题，他们已经

00:43:21.500 --> 00:43:26.510
传送到这个端点很棒

00:43:22.809 --> 00:43:29.510
在这里，我们要说我想吃

00:43:26.510 --> 00:43:31.099
来自JMS的文件将其转换为

00:43:29.510 --> 00:43:32.569
某种方式然后将其发送出去

00:43:31.099 --> 00:43:33.770
可以做得更多，还有很多

00:43:32.569 --> 00:43:35.750
其他模式很多整合

00:43:33.770 --> 00:43:37.430
不仅仅是转换和

00:43:35.750 --> 00:43:39.349
这样就可以进行索赔检查了

00:43:37.430 --> 00:43:41.359
改变身体，你可以延迟它，你可以

00:43:39.349 --> 00:43:43.730
尝试使用表达式的动态路由器

00:43:41.359 --> 00:43:45.890
你可以做一个丰富的事情

00:43:43.730 --> 00:43:47.450
说你知道聚合和

00:43:45.890 --> 00:43:49.849
分裂你可以做一个独立的

00:43:47.450 --> 00:43:52.160
消费者消费者您可以做电路

00:43:49.849 --> 00:43:54.049
断路器，你可以做一个弹跳你的负载

00:43:52.160 --> 00:43:55.640
知道是否要添加跟踪

00:43:54.049 --> 00:43:57.650
你可以做各种各样非常有趣的事

00:43:55.640 --> 00:44:00.049
只是通过使用其中一些

00:43:57.650 --> 00:44:02.690
正确的回调方法和

00:44:00.049 --> 00:44:04.240
结果是您获得了整合

00:44:02.690 --> 00:44:06.529
您想要的流程而不会放弃

00:44:04.240 --> 00:44:09.960
在这里不放弃任何灵活性

00:44:06.529 --> 00:44:11.880
所以我鼓励你仔细阅读

00:44:09.960 --> 00:44:16.130
稍后当然是最有用的之一

00:44:11.880 --> 00:44:16.130
和方法，这里我的名字很有用

00:44:18.140 --> 00:44:22.859
转型就是消费者

00:44:20.760 --> 00:44:24.510
流程正确，因此流程为您提供了

00:44:22.859 --> 00:44:27.780
您可以做的许多不同的事情

00:44:24.510 --> 00:44:30.950
处理通过的数据

00:44:27.780 --> 00:44:34.980
它，这样我就可以使用此身体

00:44:30.950 --> 00:44:36.540
发布此正文和标题或发布此

00:44:34.980 --> 00:44:41.160
身体，给它一个你知道的类型

00:44:36.540 --> 00:44:42.990
显式类型或过程交换

00:44:41.160 --> 00:44:44.280
这实际上是其中之一

00:44:42.990 --> 00:44:47.790
有趣或带来信息

00:44:44.280 --> 00:44:49.560
交流是进进出出

00:44:47.790 --> 00:44:52.950
代表桥梁的东西

00:44:49.560 --> 00:44:54.540
在两个人之间的门之间

00:44:52.950 --> 00:44:56.720
知道一个组件比另一个好

00:44:54.540 --> 00:44:58.950
所以我实际上可以处理这个交换

00:44:56.720 --> 00:45:03.349
我可以知道我不必做

00:44:58.950 --> 00:45:07.800
你只能说回来的话

00:45:03.349 --> 00:45:10.410
交换，我们转身，然后我们可以说

00:45:07.800 --> 00:45:12.810
交换点输入消息

00:45:10.410 --> 00:45:15.480
交易所的消息是

00:45:12.810 --> 00:45:16.820
进来你可以参考一下吗

00:45:15.480 --> 00:45:20.580
这里

00:45:16.820 --> 00:45:22.380
传入的好，现在我要做的就是

00:45:20.580 --> 00:45:26.760
打印出来的数据，所以我会说

00:45:22.380 --> 00:45:29.160
点得到我猜想的身体，我们知道

00:45:26.760 --> 00:45:32.040
这将是一个字符串点

00:45:29.160 --> 00:45:34.320
类字符串，所以主体将是这个

00:45:32.040 --> 00:45:37.830
假设我只是想打印出来

00:45:34.320 --> 00:45:46.200
我在这里看到的内容，以便获取日志

00:45:37.830 --> 00:45:47.609
班级点信息正文是怎么回事

00:45:46.200 --> 00:45:48.750
所以我只是要处理数据

00:45:47.609 --> 00:45:50.400
否则，它将通过

00:45:48.750 --> 00:45:53.520
通过这段代码，直接进入

00:45:50.400 --> 00:45:55.730
两个文件组件正确，所以尝试

00:45:53.520 --> 00:45:55.730
再次

00:45:59.999 --> 00:46:04.949
好的，现在让我们再试一次

00:46:06.809 --> 00:46:14.109
我们可以看到身体向所有人说了声

00:46:12.579 --> 00:46:15.880
对，所以我们只是可以插入自己

00:46:14.109 --> 00:46:16.689
在这个过程中，有很多

00:46:15.880 --> 00:46:18.759
不同的步调可以

00:46:16.689 --> 00:46:21.279
在此过程中可以进行控制

00:46:18.759 --> 00:46:24.400
你可以消耗掉交换

00:46:21.279 --> 00:46:25.839
本身就是身体，如果你想要一个有类型的身体

00:46:24.400 --> 00:46:27.339
在这种情况下，您可以说身体是

00:46:25.839 --> 00:46:28.660
键入字符串，我想将其用作

00:46:27.339 --> 00:46:30.609
一个实际上会更容易的字符串

00:46:28.660 --> 00:46:33.670
所以在这里而不是做所有的事情

00:46:30.609 --> 00:46:38.369
像我一样打开包装，我可以说一个字符串

00:46:33.670 --> 00:46:46.779
然后只记录工厂点获取日志

00:46:38.369 --> 00:46:49.089
点信息字符串主体为字符串all 

00:46:46.779 --> 00:46:51.069
对，所以还有其他选择

00:46:49.089 --> 00:46:55.140
当然你需要重新开始

00:46:51.069 --> 00:46:55.140
站在那里，所以我们尝试

00:47:02.809 --> 00:47:10.519
好的，琴弦的身体很高，所以

00:47:07.009 --> 00:47:12.709
还有另一个，最后在那里

00:47:10.519 --> 00:47:13.819
是消息对象的消息

00:47:12.709 --> 00:47:15.319
交流是我认为最强大的

00:47:13.819 --> 00:47:17.029
您可以访问那里的所有内容，但

00:47:15.319 --> 00:47:19.219
您可以使用该消息是

00:47:17.029 --> 00:47:20.809
很高兴您说出讯息，我可以得到

00:47:19.219 --> 00:47:22.039
现在访问此我可以访问

00:47:20.809 --> 00:47:23.809
我可以接触到的身体

00:47:22.039 --> 00:47:26.059
我可以添加标题我可以添加标题

00:47:23.809 --> 00:47:27.289
您知道可以做的附件

00:47:26.059 --> 00:47:29.179
您可以设置一个有趣的东西

00:47:27.289 --> 00:47:32.119
是否有错误可以

00:47:29.179 --> 00:47:33.380
在这里也做两个有趣的事情，但是

00:47:32.119 --> 00:47:35.539
我想你会坚持下去

00:47:33.380 --> 00:47:36.380
身体或交换有时

00:47:35.539 --> 00:47:38.150
你想使用一条消息

00:47:36.380 --> 00:47:41.239
无论哪种方式，您都可以完全控制

00:47:38.150 --> 00:47:43.609
真的很酷，所以我们是的，我们喜欢

00:47:41.239 --> 00:47:45.559
现在让我们假设一个人做某事

00:47:43.609 --> 00:47:46.969
有条件的，这是一个你知道的

00:47:45.559 --> 00:47:49.309
点对点的东西没有

00:47:46.969 --> 00:47:51.169
路线偏差当然可以

00:47:49.309 --> 00:47:54.799
用于某种异常处理，但是

00:47:51.169 --> 00:47:58.339
你也可以做出选择

00:47:54.799 --> 00:48:02.630
好的，当我有一条路线时

00:47:58.339 --> 00:48:04.569
匹配获胜时，请参见新谓词

00:48:02.630 --> 00:48:08.869
交易所符合一定条件

00:48:04.569 --> 00:48:12.709
然后我们可以做一些有趣的事情

00:48:08.869 --> 00:48:18.979
事情，所以当我们可以说可以

00:48:12.709 --> 00:48:24.229
与此匹配到JMS队列错误

00:48:18.979 --> 00:48:32.049
对，所以如果数学点随机数大于

00:48:24.229 --> 00:48:41.420
 0.5，因此我们将注销此布尔错误

00:48:32.049 --> 00:48:43.920
和日志工厂获取日志错误

00:48:41.420 --> 00:48:46.140
时代，你当然会犯错

00:48:43.920 --> 00:48:47.310
在这里你知道你会有一些

00:48:46.140 --> 00:48:49.380
在这里提出逻辑有点错误

00:48:47.310 --> 00:48:50.820
也可以，但是你可以说可以

00:48:49.380 --> 00:48:52.890
检查那个交流看看

00:48:50.820 --> 00:48:54.180
标头查看正文，确定位置

00:48:52.890 --> 00:48:55.740
应该基于某种条件

00:48:54.180 --> 00:48:57.900
在这里，我将其用于错误处理

00:48:55.740 --> 00:49:00.900
说发送给错误端点

00:48:57.900 --> 00:49:03.060
然后结束选择，然后

00:49:00.900 --> 00:49:07.140
否则，您知道将其发送到JMS队列

00:49:03.060 --> 00:49:09.570
一个非常简单的例子，让我们来看一个

00:49:07.140 --> 00:49:11.760
错误，这是科布以前是一个

00:49:09.570 --> 00:49:13.170
愚蠢的例子对，让我们来看看

00:49:11.760 --> 00:49:14.010
实际上，我们不能做点什么

00:49:13.170 --> 00:49:26.730
稍微有趣一点，让我们尝试一下

00:49:14.010 --> 00:49:34.590
哦，打个招呼交换点送身体礼物

00:49:26.730 --> 00:49:45.180
主体字符串，该类字符串你好， 

00:49:34.590 --> 00:49:52.680
我们可以说金条你好等于你好是

00:49:45.180 --> 00:49:59.180
你好点包含你好我们去

00:49:52.680 --> 00:49:59.180
蚂蚁，如果它是你好，那么我们说

00:50:00.500 --> 00:50:04.440
我们想把它还给你

00:50:03.300 --> 00:50:08.910
排队，否则我们将其发送到

00:50:04.440 --> 00:50:09.330
高Q好吧或其他所有Q如此

00:50:08.910 --> 00:50:13.250
我们去

00:50:09.330 --> 00:50:13.250
所以我们来试试吧

00:50:14.690 --> 00:50:20.270
让我们看看我的语法是否正确

00:50:18.260 --> 00:50:33.290
有时候我确实弄错了

00:50:20.270 --> 00:50:39.680
还是跟贾米斯说， 

00:50:33.290 --> 00:50:41.780
文件10正确，因此JMS队列文件可以

00:50:39.680 --> 00:50:45.230
我认为那是对的

00:50:41.780 --> 00:50:52.760
是的，没错，这又是

00:50:45.230 --> 00:50:54.170
 lambda并格外小心

00:50:52.760 --> 00:50:57.230
 IDS支持的优势

00:50:54.170 --> 00:50:59.780
缩进格式器时请记住这一点： 

00:50:57.230 --> 00:51:02.540
 Spring 我用它们的绝招

00:50:59.780 --> 00:51:11.390
安全它，它适合这里

00:51:02.540 --> 00:51:14.870
好吧，Tab选项卡好吧，所以当它

00:51:11.390 --> 00:51:18.220
这个我想我们可以整理一下

00:51:14.870 --> 00:51:18.220
捷径这一点

00:51:19.390 --> 00:51:24.670
大家，所以当你打招呼时

00:51:22.420 --> 00:51:28.140
否则那然后别人结束

00:51:24.670 --> 00:51:36.730
好吧，我们将摆脱它

00:51:28.140 --> 00:51:37.750
好的，格式化或不格式化，而是我们

00:51:36.730 --> 00:51:38.790
想要重新打开它，以便

00:51:37.750 --> 00:51:42.600
其他所有内容都正确格式化

00:51:38.790 --> 00:51:42.600
太好了，让我们现在尝试

00:51:49.170 --> 00:51:53.549
我们没有办法看到我想

00:51:51.809 --> 00:51:55.049
我们知道如果它被发送到

00:51:53.549 --> 00:51:57.480
你好，没有什么下游

00:51:55.049 --> 00:51:59.549
处理它，所以不会看到

00:51:57.480 --> 00:52:00.930
某些东西到达输出

00:51:59.549 --> 00:52:02.700
目录我想这已经足够了

00:52:00.930 --> 00:52:04.670
测试人员一切正常，让我们尝试一下

00:52:02.700 --> 00:52:06.690
工作让我们看看是否可行

00:52:04.670 --> 00:52:08.609
传递到输出

00:52:06.690 --> 00:52:16.200
目录，正如我们期望的那样

00:52:08.609 --> 00:52:17.369
只是在这里和那里杀死文件

00:52:16.200 --> 00:52:22.460
去吧，那个目录里什么都没有

00:52:17.369 --> 00:52:31.819
让我们再试一次

00:52:22.460 --> 00:52:31.819
那一那一那

00:52:32.070 --> 00:52:41.300
好，这样就可以按我们期望的那样工作

00:52:34.560 --> 00:52:41.300
现在你好

00:52:42.590 --> 00:52:48.210
没事，所以我们看不到

00:52:46.380 --> 00:52:49.890
因为这是你而成为河

00:52:48.210 --> 00:52:51.480
知道路径是岔路的

00:52:49.890 --> 00:52:52.920
不同的方向，这就是我们

00:52:51.480 --> 00:52:54.620
期望如此，您就可以在这里进行流量控制

00:52:52.920 --> 00:52:56.760
有能力动态

00:52:54.620 --> 00:52:58.710
改造两条路线做各种

00:52:56.760 --> 00:53:02.430
您想要与之通信的事情

00:52:58.710 --> 00:53:04.320
现在有一个消息传递系统

00:53:02.430 --> 00:53:05.640
可能不会有一个路线建设者

00:53:04.320 --> 00:53:06.930
你可以有很多不同的

00:53:05.640 --> 00:53:09.600
路线，例如不同的应用

00:53:06.930 --> 00:53:12.390
你知道我一直都在

00:53:09.600 --> 00:53:15.060
很清楚你知道我已经工作了

00:53:12.390 --> 00:53:16.320
他们很难给这些东西提供路线

00:53:15.060 --> 00:53:18.150
 ID和我们关心的原因

00:53:16.320 --> 00:53:19.350
那是因为我们希望能够

00:53:18.150 --> 00:53:21.600
查看应用程序在做什么或

00:53:19.350 --> 00:53:22.800
无法管理这些路线，因此

00:53:21.600 --> 00:53:25.620
宁愿拥有一个生命周期

00:53:22.800 --> 00:53:27.720
爱的路线很有趣，所以

00:53:25.620 --> 00:53:29.010
我们想观察它们以及我们可以采取的方式

00:53:27.720 --> 00:53:30.720
当然可以用执行器来支持

00:53:29.010 --> 00:53:31.710
所以让我们设置一些

00:53:30.720 --> 00:53:33.540
对执行器的需求我们要说

00:53:31.710 --> 00:53:35.070
管理安全性已启用Eagles false 

00:53:33.540 --> 00:53:36.960
只是现在您可以设置Spring 

00:53:35.070 --> 00:53:39.750
安全，如果您愿意，但就我而言，我们

00:53:36.960 --> 00:53:43.190
不需要它，因此上下文路径管理

00:53:39.750 --> 00:53:46.110
上下文路径等于执行器

00:53:43.190 --> 00:53:51.950
我想把终点

00:53:46.110 --> 00:53:54.480
骆驼不仅会路由端点

00:53:51.950 --> 00:53:55.860
权利，我希望他们成为我

00:53:54.480 --> 00:53:58.650
能够发布给他们并进行操纵

00:53:55.860 --> 00:54:00.770
他们，所以这是执行器的支持

00:53:58.650 --> 00:54:00.770
这里

00:54:02.970 --> 00:54:12.579
现在，当我运行应用程序时

00:54:06.329 --> 00:54:18.250
 curl HTTP本地主机：8080正斜杠

00:54:12.579 --> 00:54:22.930
执行器/ r输出是让我们看看

00:54:18.250 --> 00:54:29.880
执行器的输出在这里

00:54:22.930 --> 00:54:29.880
执行器骆驼路线，所以骆驼路线

00:54:32.190 --> 00:54:36.369
好，所以我们可以看到输出

00:54:34.960 --> 00:54:37.690
有不同的路线，假设我要

00:54:36.369 --> 00:54:40.869
停下来我只想停下来

00:54:37.690 --> 00:54:42.220
处理成不是

00:54:40.869 --> 00:54:51.460
现在需要，所以我可以

00:54:42.220 --> 00:54:56.020
发布到这里，我要发送一个

00:54:51.460 --> 00:55:01.150
空它应该张贴所以卷曲-d2 

00:54:56.020 --> 00:55:03.790
路由端点，然后看一看你

00:55:01.150 --> 00:55:06.760
可以看到进出已停止

00:55:03.790 --> 00:55:09.730
是的，所以我以前跑步了

00:55:06.760 --> 00:55:10.869
然后我停止了那是你知道的

00:55:09.730 --> 00:55:12.400
这很方便，我们可以使用

00:55:10.869 --> 00:55:16.780
执行器Springwood执行器

00:55:12.400 --> 00:55:18.790
进行内省和管理的端点

00:55:16.780 --> 00:55:23.349
我认为的路线本身

00:55:18.790 --> 00:55:27.609
超级方便，现在我们看起来很

00:55:23.349 --> 00:55:28.900
远不及骆驼的一些精美之处

00:55:27.609 --> 00:55:32.560
为我们带来的Spring开发人员

00:55:28.900 --> 00:55:33.970
看了它提供的漂亮的DSL 

00:55:32.560 --> 00:55:35.740
在这里建立定义

00:55:33.970 --> 00:55:36.910
值得一提的是

00:55:35.740 --> 00:55:41.050
想要使用的人中有一个

00:55:36.910 --> 00:55:43.240
基于springs XML支持的XML DSL 

00:55:41.050 --> 00:55:45.220
可以用在骆驼上，但我宁愿

00:55:43.240 --> 00:55:47.140
我也喜欢这种方法

00:55:45.220 --> 00:55:48.280
在这里注入骆驼上下文

00:55:47.140 --> 00:55:49.420
通过构造函数，因为它是

00:55:48.280 --> 00:55:51.220
只是普通的光束，你可以做到

00:55:49.420 --> 00:55:54.910
但是还有一个叫做

00:55:51.220 --> 00:55:57.819
骆驼上下文感知正确，所以您可以

00:55:54.910 --> 00:56:00.010
实际上告诉 Spring 骆驼- 

00:55:57.819 --> 00:56:03.310
请给那个骆驼注入一个指针

00:56:00.010 --> 00:56:06.190
上下文当然是一种选择， 

00:56:03.310 --> 00:56:08.500
我们看过了，你知道如何

00:56:06.190 --> 00:56:10.450
自定义默认行为以及如何

00:56:08.500 --> 00:56:11.319
这是有效的，我们研究了事实

00:56:10.450 --> 00:56:13.210
我们看着一个事实，你可以

00:56:11.319 --> 00:56:15.090
实际上自定义注册不同

00:56:13.210 --> 00:56:16.920
组件，例如不是

00:56:15.090 --> 00:56:19.800
作为它们的一部分自动生成

00:56:16.920 --> 00:56:21.480
你知道的 spring boot 入门插件

00:56:19.800 --> 00:56:24.060
他们那里的东西

00:56:21.480 --> 00:56:25.650
骆驼项目我们看了一些

00:56:24.060 --> 00:56:28.380
在其中的可观察性支持

00:56:25.650 --> 00:56:31.730
开箱即用，我想和你谈谈

00:56:28.380 --> 00:56:33.810
关于拿走我们这里得到的东西

00:56:31.730 --> 00:56:35.460
将其连接到 Spring ，所以我们

00:56:33.810 --> 00:56:39.150
将使用spring集成，因为

00:56:35.460 --> 00:56:40.530
 Spring Integration 只是一个简单的

00:56:39.150 --> 00:56:43.200
一个很好的集成API，但是

00:56:40.530 --> 00:56:45.030
但特别是消息通道

00:56:43.200 --> 00:56:47.460
何时使用或何时使用

00:56:45.030 --> 00:56:49.080
您在我们的Apache骆驼中使用组件

00:56:47.460 --> 00:56:50.880
具体的应用

00:56:49.080 --> 00:56:52.320
旨在将邮件转发到

00:56:50.880 --> 00:56:54.570
Spring 集成通道

00:56:52.320 --> 00:56:56.280
如果我想要一个 Spring 的例子

00:56:54.570 --> 00:56:57.570
云流，我们不是，我们做到了

00:56:56.280 --> 00:56:59.580
看着 Spring 的云流

00:56:57.570 --> 00:57:01.710
较早的 spring 技巧 分期付款有关

00:56:59.580 --> 00:57:03.930
一年前，在那一期中

00:57:01.710 --> 00:57:05.670
看到一个通道绑定在

00:57:03.930 --> 00:57:10.050
 Spring代码流仅仅是一个接口

00:57:05.670 --> 00:57:13.020
定义谁是谁，他们的绑定是

00:57:10.050 --> 00:57:15.480
基本上您知道的频道讯息

00:57:13.020 --> 00:57:16.770
通道空间食物括号

00:57:15.480 --> 00:57:19.050
用括号括起来的分号对吧

00:57:16.770 --> 00:57:21.030
具有通道的接口方法

00:57:19.050 --> 00:57:23.520
定义和那个子定义

00:57:21.030 --> 00:57:26.310
变成了真正的连接

00:57:23.520 --> 00:57:29.100
与经纪人的水合作用

00:57:26.310 --> 00:57:30.960
 RabbitMQ Pecha Kafka Google云

00:57:29.100 --> 00:57:33.120
 pub / sub，你知道它是什么

00:57:30.960 --> 00:57:34.500
您选择使用的粘合剂

00:57:33.120 --> 00:57:35.640
流卡夫卡流，或者你看着

00:57:34.500 --> 00:57:37.020
以及最近的一些

00:57:35.640 --> 00:57:37.740
 Spring 的提示有很多不同

00:57:37.020 --> 00:57:40.110
绑定在那里

00:57:37.740 --> 00:57:43.940
您可以使用任何您想要的东西

00:57:40.110 --> 00:57:46.830
想要但出站的定义

00:57:43.940 --> 00:57:48.780
与该经纪人的联系仅仅是

00:57:46.830 --> 00:57:51.780
 Java代码中的接口any 

00:57:48.780 --> 00:57:54.120
配置位于属性中

00:57:51.780 --> 00:57:56.610
文件正确，因此与

00:57:54.120 --> 00:57:58.530
卡夫卡的话题是根据

00:57:56.610 --> 00:58:00.480
在属性文件中配置

00:57:58.530 --> 00:58:03.000
与界面有关

00:58:00.480 --> 00:58:06.240
我们的Java代码中的定义

00:58:03.000 --> 00:58:08.310
事情很方便就可以

00:58:06.240 --> 00:58:09.990
实际混合并混合并混合这些

00:58:08.310 --> 00:58:10.860
在一起的事情就是我们

00:58:09.990 --> 00:58:13.290
想在这里想利用

00:58:10.860 --> 00:58:17.700
例如丰富的生态系统

00:58:13.290 --> 00:58:20.790
 Kafka是一种骆驼组件， 

00:58:17.700 --> 00:58:23.070
然后将其转发到频道

00:58:20.790 --> 00:58:24.390
然后我们可以做各种事情

00:58:23.070 --> 00:58:25.920
该渠道的事情可能只是

00:58:24.390 --> 00:58:27.450
轻松成为

00:58:25.920 --> 00:58:28.620
 Spring 自动为我们创建

00:58:27.450 --> 00:58:30.780
码流

00:58:28.620 --> 00:58:32.850
可能是进入的渠道

00:58:30.780 --> 00:58:34.950
 Spring数据流可能是一个通道

00:58:32.850 --> 00:58:36.180
那一定会交付给你的

00:58:34.950 --> 00:58:38.940
知道谁的有效载荷的内容

00:58:36.180 --> 00:58:41.790
势必通过Springs spring交付

00:58:38.940 --> 00:58:44.100
 NBC特别是在佛罗里达州

00:58:41.790 --> 00:58:47.300
 meeseeks WebSocket支持，因此所有

00:58:44.100 --> 00:58:52.440
这些东西都是这些目的地

00:58:47.300 --> 00:58:53.760
对于apache骆驼用户来说是合理的，所以

00:58:52.440 --> 00:58:55.860
你可以混合搭配

00:58:53.760 --> 00:58:57.470
用骆驼跟这些东西说话

00:58:55.860 --> 00:59:00.360
可能不存在

00:58:57.470 --> 00:59:01.800
 Spring 支持，例如我不

00:59:00.360 --> 00:59:04.950
知道Spring 取反适配器

00:59:01.800 --> 00:59:06.240
如果您使用骆驼交谈，则执行s2 

00:59:04.950 --> 00:59:08.520
你可以用骆驼说话

00:59:06.240 --> 00:59:10.230
无论我的意思是我们看到的

00:59:08.520 --> 00:59:12.630
那里有一个非常丰富的目录， 

00:59:10.230 --> 00:59:14.190
然后您可以将这些消息转发到

00:59:12.630 --> 00:59:16.140
一个频道，让我们做一个

00:59:14.190 --> 00:59:21.510
这里的Spring 集成流程非常简单

00:59:16.140 --> 00:59:22.890
说整合流程，我想我

00:59:21.510 --> 00:59:26.450
可以使用 Spring 的云流，但是

00:59:22.890 --> 00:59:31.260
尽量保持简单哦

00:59:26.450 --> 00:59:33.180
频道传入转弯，我将

00:59:31.260 --> 00:59:36.390
现在直接创建频道

00:59:33.180 --> 00:59:39.480
Spring 集成称为管道

00:59:36.390 --> 00:59:43.980
通过消息流，我想要

00:59:39.480 --> 00:59:45.420
发送一条到达的消息

00:59:43.980 --> 00:59:50.430
我们发送一条消息，到达

00:59:45.420 --> 00:59:52.740
让我们创建一条路线

00:59:50.430 --> 00:59:57.270
来自JMS hello的数据

00:59:52.740 --> 00:59:58.920
排队，我们将其发送到 Spring 

00:59:57.270 --> 01:00:08.570
移民好吧，让我们这样做

00:59:58.920 --> 01:00:13.500
所以在这里说的很好，从JMS队列向

01:00:08.570 --> 01:00:17.940
 Spring 整合，让我们看看

01:00:13.500 --> 01:00:20.870
该组件看起来像那个 Spring 

01:00:17.940 --> 01:00:20.870
积分

01:00:21.460 --> 01:00:28.670
在那里，我们就是这样

01:00:23.870 --> 01:00:31.670
说 Spring 灌溉渠道

01:00:28.670 --> 01:00:33.050
将被称为传入有一些

01:00:31.670 --> 01:00:34.430
希望它进出的选项

01:00:33.050 --> 01:00:36.290
想成为你知道什么是输出

01:00:34.430 --> 01:00:38.510
就是这样，它是水槽休息

01:00:36.290 --> 01:00:39.950
这是对还是错的权利，所以

01:00:38.510 --> 01:00:41.360
我们实际上需要知道的碱基对

01:00:39.950 --> 01:00:43.070
这就是我不想要的全部

01:00:41.360 --> 01:00:44.270
必须为此做任何属性

01:00:43.070 --> 01:00:45.680
可以正常运行，因为它正在内部运行

01:00:44.270 --> 01:00:48.590
 Spring 的事，所以当

01:00:45.680 --> 01:00:50.150
消息到达你好你好我们有

01:00:48.590 --> 01:00:51.200
他们没有出路之前，我们会

01:00:50.150 --> 01:00:53.090
本来希望看到他们在

01:00:51.200 --> 01:00:56.090
文件终结点，但我们得到了

01:00:53.090 --> 01:00:57.320
删除该代码，所以现在如果消息

01:00:56.090 --> 01:01:03.920
说你好，它将去你好

01:00:57.320 --> 01:01:06.410
在我们经纪人的贾米斯目的地，然后

01:01:03.920 --> 01:01:08.270
我们的，然后最终它将弹出

01:01:06.410 --> 01:01:09.320
 Spring 的否定之流

01:01:08.270 --> 01:01:11.180
频道，让我们继续进行

01:01:09.320 --> 01:01:13.400
现在让我们写 Spring 的否定

01:01:11.180 --> 01:01:14.900
处理代码以处理消息

01:01:13.400 --> 01:01:16.910
从那里出来，我只是在做

01:01:14.900 --> 01:01:18.620
这是因为我希望我们必须拥有

01:01:16.910 --> 01:01:20.900
消息消息必须得到处理

01:01:18.620 --> 01:01:22.190
我们不能只知道缓冲它们， 

01:01:20.900 --> 01:01:23.720
不与他们做任何事情，但我们不

01:01:22.190 --> 01:01:25.310
真的需要我用这个配方

01:01:23.720 --> 01:01:26.300
只是因为这是一个简单的例子

01:01:25.310 --> 01:01:28.690
在这种情况下真的不需要它吧

01:01:26.300 --> 01:01:32.060
我们只需要一些东西来处理

01:01:28.690 --> 01:01:37.270
我会看到的传入消息

01:01:32.060 --> 01:01:37.270
在流量配置中

01:01:38.990 --> 01:01:48.109
好的，顺其自然，我们要说

01:01:43.220 --> 01:01:51.050
从此返回积分流点

01:01:48.109 --> 01:01:53.839
明星来了，我要做的就是

01:01:51.050 --> 01:01:55.940
只要你知道打印我们看到的那么新

01:01:53.839 --> 01:01:58.510
通用处理程序和我们所需要的数据

01:01:55.940 --> 01:02:01.069
期望是我们将会看到一条消息

01:01:58.510 --> 01:02:03.579
从队列中消失，我们不知道

01:02:01.069 --> 01:02:05.869
那是什么样的，让我们继续吧

01:02:03.579 --> 01:02:10.150
宣布我们有消息

01:02:05.869 --> 01:02:10.150
日志因子不获取日志踢类

01:02:10.210 --> 01:02:19.400
在这里打印出来，我们会说日志

01:02:14.210 --> 01:02:22.819
有信息新消息，将所有字符串

01:02:19.400 --> 01:02:26.750
对，所以那还不错

01:02:22.819 --> 01:02:28.130
我们可以在此处建立一个断点

01:02:26.750 --> 01:02:29.569
流程，我们完成了，那就是

01:02:28.130 --> 01:02:31.119
整合流程我们基本上是在说

01:02:29.569 --> 01:02:33.980
频道收到什么消息

01:02:31.119 --> 01:02:35.960
只需将其传递给处理程序，这是一种

01:02:33.980 --> 01:02:38.450
像骆驼中的处理器，然后

01:02:35.960 --> 01:02:40.190
一个你知道停止流动停止流动

01:02:38.450 --> 01:02:41.480
如果我们退还了我的名义价值

01:02:40.190 --> 01:02:44.890
然后流量会继续，但是

01:02:41.480 --> 01:02:53.420
在这种情况下，我们返回的值没有

01:02:44.890 --> 01:02:55.250
好吧，我在那里做错了什么

01:02:53.420 --> 01:02:57.740
忘了注册Spring 

01:02:55.250 --> 01:03:02.799
集成启动器，我有吗

01:02:57.740 --> 01:03:02.799
不，我忘了注册骆驼

01:03:03.089 --> 01:03:16.249
 Spring Integration 入门或早期

01:03:09.059 --> 01:03:16.249
 Spring ，对不起，org apache camel 

01:03:27.710 --> 01:03:33.350
看起来还不错不错，所以有

01:03:30.200 --> 01:03:43.520
让我们看看我们现在所拥有的

01:03:33.350 --> 01:03:50.290
希望在这里回显这个输出，所以

01:03:43.520 --> 01:03:54.860
你好，新消息是你好，所以

01:03:50.290 --> 01:03:57.320
您的留言打招呼，所以我们去了

01:03:54.860 --> 01:03:59.600
几乎没有代码的朋友，我们

01:03:57.320 --> 01:04:01.490
设法看了一下Apache骆驼

01:03:59.600 --> 01:04:04.790
这是一个丰富的框架，其中包含很多

01:04:01.490 --> 01:04:06.140
我们可能会整合

01:04:04.790 --> 01:04:09.710
我们绝对应该感受到

01:04:06.140 --> 01:04:12.800
随时随地使用它，他们当然

01:04:09.710 --> 01:04:15.200
 Spring 的 Spring 引导支持

01:04:12.800 --> 01:04:18.260
退休金骆驼真的很棒

01:04:15.200 --> 01:04:19.610
做得很好做得很好

01:04:18.260 --> 01:04:22.490
有很多不同的选择

01:04:19.610 --> 01:04:24.170
我确定他们没有做所有的事情

01:04:22.490 --> 01:04:27.170
只是我们将忽略这些财富

01:04:24.170 --> 01:04:29.030
当然可以肯定的选择

01:04:27.170 --> 01:04:31.010
大量使用apache的spring用户

01:04:29.030 --> 01:04:32.300
骆驼，也许他们不知道

01:04:31.010 --> 01:04:34.490
所有这伟大的 Spring 蓝色支持

01:04:32.300 --> 01:04:36.980
他们，所以这个视频只是为了

01:04:34.490 --> 01:04:39.050
只是暗示着要逗弄一些

01:04:36.980 --> 01:04:40.130
这些人的绝佳机会

01:04:39.050 --> 01:04:41.720
我们谁喜欢我的整合

01:04:40.130 --> 01:04:43.700
当然背景是消息传递和

01:04:41.720 --> 01:04:45.380
集成我喜欢消息传递

01:04:43.700 --> 01:04:46.520
我在 Spring 进行的一项创新

01:04:45.380 --> 01:04:48.230
整合颇多，我爱 Spring 

01:04:46.520 --> 01:04:50.540
整合我爱迷彩我爱任何东西

01:04:48.230 --> 01:04:53.030
这使得它很容易

01:04:50.540 --> 01:04:55.610
连接其他完全不同的服务，以及

01:04:53.030 --> 01:04:57.290
现在的数据都是轻量级的

01:04:55.610 --> 01:04:58.580
我喜欢轻型插管框架

01:04:57.290 --> 01:05:00.800
干扰这些东西的指示

01:04:58.580 --> 01:05:02.180
挂在服务的一边

01:05:00.800 --> 01:05:03.680
他们提供了各种机会

01:05:02.180 --> 01:05:05.270
有趣的事情现在有

01:05:03.680 --> 01:05:07.010
实际上是这里的初步支持

01:05:05.270 --> 01:05:08.270
 Apache Campbell面向 Spring Cloud 二

01:05:07.010 --> 01:05:10.310
他们确实有一些东西

01:05:08.270 --> 01:05:12.650
酿造与例如

01:05:10.310 --> 01:05:13.970
发现客户抽象

01:05:12.650 --> 01:05:15.290
还有很多其他的

01:05:13.970 --> 01:05:16.670
这里发生的事情我们没有

01:05:15.290 --> 01:05:18.410
谈谈我们没有的数据格式

01:05:16.670 --> 01:05:20.630
谈论所有不同

01:05:18.410 --> 01:05:23.380
各种组件什么都没发生

01:05:20.630 --> 01:05:25.700
今天所有不同的人

01:05:23.380 --> 01:05:27.440
他们称为API或SPI的是什么

01:05:25.700 --> 01:05:29.690
而是在阿帕奇骆驼中

01:05:27.440 --> 01:05:30.770
组件等等，但是有

01:05:29.690 --> 01:05:33.050
我们本来可以看的其他东西

01:05:30.770 --> 01:05:34.910
所以我们真的才刚刚开始

01:05:33.050 --> 01:05:37.460
我当然会鼓励一项服务

01:05:34.910 --> 01:05:38.660
您可以休闲地这样做

01:05:37.460 --> 01:05:40.580
我的朋友们非常感谢你

01:05:38.660 --> 01:05:42.640
看，下次见

01:05:40.580 --> 01:05:42.640
您

01:05:49.029 --> 01:05:51.089
您

