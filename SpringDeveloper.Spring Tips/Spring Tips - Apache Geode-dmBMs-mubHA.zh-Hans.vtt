WEBVTT
Kind: captions
Language: zh-Hans

00:00:25.300 --> 00:00:29.590
嗨， Spring 粉丝们欢迎来到另一个

00:00:27.699 --> 00:00:30.579
在这里的秋千技巧的分期付款

00:00:29.590 --> 00:00:32.619
分期付款，我们将看看

00:00:30.579 --> 00:00:36.040
 Apache Geo项目及其集成

00:00:32.619 --> 00:00:38.920
通过 spring data geode项目

00:00:36.040 --> 00:00:40.629
现在Spring Data Geode支持Apache 

00:00:38.920 --> 00:00:44.530
乔德，你可能已经听说过

00:00:40.629 --> 00:00:46.360
 Apache geode作为宝石之火，所以Jim 

00:00:44.530 --> 00:00:48.400
火实际上是一种产品

00:00:46.360 --> 00:00:49.780
存在的大部分

00:00:48.400 --> 00:00:53.440
已有二十年了

00:00:49.780 --> 00:00:57.910
时间，它早于

00:00:53.440 --> 00:01:00.399
早于关键

00:00:57.910 --> 00:01:02.170
 Spring 团队在VMware的时间，但是

00:01:00.399 --> 00:01:04.539
在

00:01:02.170 --> 00:01:07.869
通过获取Spring 源

00:01:04.539 --> 00:01:09.700
 VMware，这就是其中之一

00:01:07.869 --> 00:01:11.710
如果你有一个用例

00:01:09.700 --> 00:01:13.720
该产品提供的产品，然后您

00:01:11.710 --> 00:01:15.160
绝对了解这项技术

00:01:13.720 --> 00:01:17.920
这是你可能会做的事

00:01:15.160 --> 00:01:20.080
已经研究了并且很有可能

00:01:17.920 --> 00:01:23.350
使用正确，这就是为什么其中之一

00:01:20.080 --> 00:01:26.140
最好保密的东西

00:01:23.350 --> 00:01:27.880
只是人们已经习惯了

00:01:26.140 --> 00:01:30.640
必须刊登广告，我们已经

00:01:27.880 --> 00:01:32.590
我们在与人之间取得了很大的成功

00:01:30.640 --> 00:01:33.940
自然地发现它

00:01:32.590 --> 00:01:35.380
他们正在有机地寻求解决

00:01:33.940 --> 00:01:37.390
某个问题和那个问题

00:01:35.380 --> 00:01:39.429
域是分布式数据网格

00:01:37.390 --> 00:01:41.800
技术对他们想要的东西

00:01:39.429 --> 00:01:43.630
可以充当巨大的Ram云

00:01:41.800 --> 00:01:46.030
但您知道复制或分区

00:01:43.630 --> 00:01:48.130
跨越庞大的节点集群

00:01:46.030 --> 00:01:50.610
支持例如数据缓存

00:01:48.130 --> 00:01:53.860
从快速闪电快速访问

00:01:50.610 --> 00:01:56.770
您知道的连续查询

00:01:53.860 --> 00:01:58.690
分析以及何时复制

00:01:56.770 --> 00:02:01.149
就是说我想从一个

00:01:58.690 --> 00:02:03.069
数据中心，然后复制数据

00:02:01.149 --> 00:02:05.649
如有必要，另两个数据中心

00:02:03.069 --> 00:02:07.509
全球范围内正确的观点

00:02:05.649 --> 00:02:09.340
的数据，尤其是

00:02:07.509 --> 00:02:13.420
这种水平可伸缩性和

00:02:09.340 --> 00:02:15.610
这种无限的可复制性

00:02:13.420 --> 00:02:17.290
跨不同的节点，这是

00:02:15.610 --> 00:02:19.450
在云原生环境中特别有用

00:02:17.290 --> 00:02:20.530
世界当然回想起Netflix 

00:02:19.450 --> 00:02:23.110
他们在云端旅行

00:02:20.530 --> 00:02:25.120
你说的大约2009年的当地人

00:02:23.110 --> 00:02:27.720
关于他们远离的运动

00:02:25.120 --> 00:02:31.330
传统的存储技术，例如

00:02:27.720 --> 00:02:33.430
基于续集的续集数据库

00:02:31.330 --> 00:02:35.350
像Cassandra这样的分布式技术

00:02:33.430 --> 00:02:36.420
没有一点的东西

00:02:35.350 --> 00:02:38.250
失败

00:02:36.420 --> 00:02:41.490
乔德

00:02:38.250 --> 00:02:43.380
现在非常以同样的方式

00:02:41.490 --> 00:02:45.990
我说行为是指吉姆·火灾

00:02:43.380 --> 00:02:47.580
 Jim fire是产品，但自

00:02:45.990 --> 00:02:49.140
开源一点点

00:02:47.580 --> 00:02:51.090
您想要的所有有趣的东西

00:02:49.140 --> 00:02:53.700
而您要使用的是

00:02:51.090 --> 00:02:56.010
阿帕奇交易，所以当我们

00:02:53.700 --> 00:02:59.700
今天要看到不同的API 

00:02:56.010 --> 00:03:02.690
在某些情况下指

00:02:59.700 --> 00:03:05.280
你知道吉姆开枪没有

00:03:02.690 --> 00:03:06.780
从根本上说，这是一个

00:03:05.280 --> 00:03:09.810
称为Apache geo的开源技术

00:03:06.780 --> 00:03:12.600
实际上，它们是可互换的

00:03:09.810 --> 00:03:14.640
此时此刻，正确的是

00:03:12.600 --> 00:03:16.410
这是一段漫长的旅程

00:03:14.640 --> 00:03:18.690
知道我们过了一段漫长的旅程

00:03:16.410 --> 00:03:20.850
看这个产品开源

00:03:18.690 --> 00:03:22.170
作为其承诺的一部分至关重要

00:03:20.850 --> 00:03:24.420
开源我们向所有我们开源

00:03:22.170 --> 00:03:27.540
几年前的数据技术

00:03:24.420 --> 00:03:31.140
青梅，你知道我们看到的是

00:03:27.540 --> 00:03:33.120
在吉姆之火和所有这些事情中工作

00:03:31.140 --> 00:03:35.550
这些大数据技术变得开放

00:03:33.120 --> 00:03:37.950
来源，所以我们要看一下

00:03:35.550 --> 00:03:39.300
今天的技术，我就是我

00:03:37.950 --> 00:03:40.830
继续说我很抱歉

00:03:39.300 --> 00:03:42.269
对不起，这还没有完成

00:03:40.830 --> 00:03:42.750
对此我们还没有Spring 提示

00:03:42.269 --> 00:03:47.250
之前

00:03:42.750 --> 00:03:48.750
 Jim fire和geode对我来说是

00:03:47.250 --> 00:03:50.489
最有趣的技术

00:03:48.750 --> 00:03:53.340
太阳，它们异常强大

00:03:50.489 --> 00:03:54.810
正如我所说，我们不会

00:03:53.340 --> 00:03:56.489
真的必须做广告，我

00:03:54.810 --> 00:03:58.560
回想在VMware，我们有客户

00:03:56.489 --> 00:04:02.400
会来找我们说哇你知道我们

00:03:58.560 --> 00:04:06.260
刚付钱就知道一些淫秽的数字

00:04:02.400 --> 00:04:06.260
只能由um来证明

00:04:06.470 --> 00:04:09.840
那只能是买它而已

00:04:08.370 --> 00:04:11.519
通过某种理由

00:04:09.840 --> 00:04:13.650
高尔夫游戏，他们付某种钱

00:04:11.519 --> 00:04:15.690
这个高尔夫比赛的可怕价格

00:04:13.650 --> 00:04:18.060
他们最终将获得这些额外的许可证

00:04:15.690 --> 00:04:19.560
连贯的权利不是那样的

00:04:18.060 --> 00:04:21.959
他们不是像他们想要的那样

00:04:19.560 --> 00:04:23.700
他们所拥有的权利，他们会

00:04:21.959 --> 00:04:25.530
来找我们说我们真的很想使用

00:04:23.700 --> 00:04:27.810
宝石之火就是技术

00:04:25.530 --> 00:04:29.220
确实做到了，但是

00:04:27.810 --> 00:04:30.660
它确实做到了

00:04:29.220 --> 00:04:34.320
这些功能，这是战斗

00:04:30.660 --> 00:04:36.990
经过测试的《财富》 100强公司

00:04:34.320 --> 00:04:39.330
他们中的很大一部分正在使用Jim fire 

00:04:36.990 --> 00:04:42.680
甚至在我们之后

00:04:39.330 --> 00:04:44.460
开源它能够

00:04:42.680 --> 00:04:45.900
让客户满意，因为他们

00:04:44.460 --> 00:04:47.820
他们对此一直感到满意

00:04:45.900 --> 00:04:49.169
技术，这就是其中之一

00:04:47.820 --> 00:04:50.460
真的是真的

00:04:49.169 --> 00:04:51.370
真的很好，真的

00:04:50.460 --> 00:04:53.350
对...有好处

00:04:51.370 --> 00:04:56.169
很长一段时间了，我们不必做

00:04:53.350 --> 00:04:59.380
任何形式的传统营销

00:04:56.169 --> 00:05:03.970
支持那个，它也是其中之一

00:04:59.380 --> 00:05:06.310
因为它很好用的地方

00:05:03.970 --> 00:05:08.199
 Spring 来了

00:05:06.310 --> 00:05:11.040
 Spring 的生态系统，因为我们已经

00:05:08.199 --> 00:05:13.780
有人花了很长时间

00:05:11.040 --> 00:05:16.900
受益于 Spring 

00:05:13.780 --> 00:05:20.740
简约和 Spring 从中受益

00:05:16.900 --> 00:05:23.710
它的力量，灵活性等等

00:05:20.740 --> 00:05:25.570
与宝石之火的旅程

00:05:23.710 --> 00:05:27.460
与Jim Fire的整合已经

00:05:25.570 --> 00:05:29.620
我的天哪，我记得很长一段时间

00:05:27.460 --> 00:05:32.289
第一次融入 Spring 

00:05:29.620 --> 00:05:34.720
家庭Spring 源工程师Causton 

00:05:32.289 --> 00:05:37.900
 Lau正在努力地工作，他当时还是一个

00:05:34.720 --> 00:05:39.100
如果您查看的是最早的代码

00:05:37.900 --> 00:05:40.240
 Spring 爸爸，他读了他的项目

00:05:39.100 --> 00:05:42.400
你也会在那里看到他的名字

00:05:40.240 --> 00:05:44.650
意思是他是他，他也在 Spring 

00:05:42.400 --> 00:05:47.380
框架本身就是他之一

00:05:44.650 --> 00:05:51.850
原始杂色的传说

00:05:47.380 --> 00:05:55.990
组成Spring 源的船员

00:05:51.850 --> 00:05:58.090
所以他有那些优秀的

00:05:55.990 --> 00:05:59.950
技术印章正在研究中

00:05:58.090 --> 00:06:02.289
整合的吉姆，你知道

00:05:59.950 --> 00:06:04.060
让我们在这里说实话

00:06:02.289 --> 00:06:06.550
整合可能的整合

00:06:04.060 --> 00:06:10.389
我们可以用 Spring 来袭

00:06:06.550 --> 00:06:12.130
最多2010年占用了2010年或11年，我们没有

00:06:10.389 --> 00:06:14.260
像我们今天可以做的那样优雅

00:06:12.130 --> 00:06:16.360
产品本身已经变得越来越多

00:06:14.260 --> 00:06:19.210
历史上以开发者为中心

00:06:16.360 --> 00:06:22.060
曾经是数据分析师平台

00:06:19.210 --> 00:06:23.380
专门用于数据排序的技术

00:06:22.060 --> 00:06:24.990
人们正确的人在

00:06:23.380 --> 00:06:26.979
关心数据的组织

00:06:24.990 --> 00:06:28.630
起源，他们关心数据

00:06:26.979 --> 00:06:32.020
所有这些类型的分析和仓储

00:06:28.630 --> 00:06:33.550
用例，因此现在

00:06:32.020 --> 00:06:35.380
能够弥合差距坐

00:06:33.550 --> 00:06:37.419
两个世界都舒适地拥有

00:06:35.380 --> 00:06:38.650
工具和集成

00:06:37.419 --> 00:06:41.080
可供双方使用

00:06:38.650 --> 00:06:42.580
众所周知的房子

00:06:41.080 --> 00:06:45.550
区分很多技术

00:06:42.580 --> 00:06:48.220
专注于，如果，甚至甚至不

00:06:45.550 --> 00:06:50.620
一定会成功的一方面

00:06:48.220 --> 00:06:53.190
房子，所以我认为这是一个非常

00:06:50.620 --> 00:06:55.360
人们现在使用的有趣技术

00:06:53.190 --> 00:06:57.370
就像我所说的巨人

00:06:55.360 --> 00:06:59.409
分布式RAM云基本上是

00:06:57.370 --> 00:07:00.490
数据网格，我们称其为

00:06:59.409 --> 00:07:04.340
他们使用它的很多不同的用例

00:07:00.490 --> 00:07:08.230
用于缓冲，所以我用了

00:07:04.340 --> 00:07:10.910
你知道我用过其他技术

00:07:08.230 --> 00:07:13.700
像生产前的连贯性

00:07:10.910 --> 00:07:20.960
对，这对很多人都有好处

00:07:13.700 --> 00:07:22.910
相同的用例可以满足很多

00:07:20.960 --> 00:07:24.889
相同的用例，假设我有一个

00:07:22.910 --> 00:07:26.330
我想要的全部数据

00:07:24.889 --> 00:07:28.550
缓冲区我要写到后端

00:07:26.330 --> 00:07:30.280
数据存储，但那又回来了

00:07:28.550 --> 00:07:32.660
数据存储中的速度很慢

00:07:30.280 --> 00:07:35.060
那就是说它不能接受写为

00:07:32.660 --> 00:07:38.180
尽我所能尽我所能

00:07:35.060 --> 00:07:40.790
可以使用此数据网格来缓冲

00:07:38.180 --> 00:07:44.720
吸收他们的权利，然后

00:07:40.790 --> 00:07:47.810
尽可能将它们写到B到

00:07:44.720 --> 00:07:49.640
数据网格后面的数据存储

00:07:47.810 --> 00:07:51.370
我们称其为

00:07:49.640 --> 00:07:55.700
交互即消息交换

00:07:51.370 --> 00:08:00.130
被称为if的协议

00:07:55.700 --> 00:08:04.880
您想读取数据，假设您

00:08:00.130 --> 00:08:08.120
假设您想从中读取数据

00:08:04.880 --> 00:08:09.710
缓慢的东西吧

00:08:08.120 --> 00:08:14.360
您从备份数据存储中读取数据

00:08:09.710 --> 00:08:16.550
但是很慢，但是你要确保

00:08:14.360 --> 00:08:18.860
随后的读取很快，所以

00:08:16.550 --> 00:08:21.080
这称为通读，即读即读

00:08:18.860 --> 00:08:22.760
通过高速缓存读取高速缓存可以

00:08:21.080 --> 00:08:24.530
然后进行编程以从

00:08:22.760 --> 00:08:26.870
原始来源的东西会查找

00:08:24.530 --> 00:08:29.120
记录它会解决结果

00:08:26.870 --> 00:08:30.500
记录，它将返回记录，但是

00:08:29.120 --> 00:08:32.390
然后它将缓存该记录，以便

00:08:30.500 --> 00:08:35.000
随后读取相同的键

00:08:32.390 --> 00:08:36.589
该数据网格将导致缓存

00:08:35.000 --> 00:08:38.539
对象，您可以做类似的事情

00:08:36.589 --> 00:08:40.669
您可以说我想要的价值到期

00:08:38.539 --> 00:08:42.320
通读，但它说如果有

00:08:40.669 --> 00:08:44.120
闲着，没人读

00:08:42.320 --> 00:08:45.680
无论X分钟的时间，还是

00:08:44.120 --> 00:08:46.970
几小时或一秒钟

00:08:45.680 --> 00:08:49.400
前进并以这种方式到期，下一个

00:08:46.970 --> 00:08:51.320
每当我读到它，我就会被强迫

00:08:49.400 --> 00:08:53.150
再次解析原始对象，然后

00:08:51.320 --> 00:08:58.000
我将重新阅读，您也可以这样做

00:08:53.150 --> 00:09:01.070
成为非常有趣的事情

00:08:58.000 --> 00:09:03.380
这些是经典的缓存模式， 

00:09:01.070 --> 00:09:05.300
他们当然是我的共同点， 

00:09:03.380 --> 00:09:07.940
那么确实您会看到 Spring 有一个

00:09:05.300 --> 00:09:09.530
缓存管理器集成等等

00:09:07.940 --> 00:09:12.320
我很想谈谈缓存管理器

00:09:09.530 --> 00:09:13.400
整合，当我们知道

00:09:12.320 --> 00:09:16.310
例如当我们看时

00:09:13.400 --> 00:09:17.350
 Redis支持和spring数据Redis 

00:09:16.310 --> 00:09:19.150
我想要的

00:09:17.350 --> 00:09:19.990
看看今天的整合，我们

00:09:19.150 --> 00:09:22.510
将专注于更多

00:09:19.990 --> 00:09:23.920
晶莹剔透的我有趣的特征

00:09:22.510 --> 00:09:25.720
不想在上面停留太多

00:09:23.920 --> 00:09:26.860
这些较低级别的作品，你可以

00:09:25.720 --> 00:09:28.390
绝对给他们工作，他们不是

00:09:26.860 --> 00:09:31.090
很大，但是我们要专注于一些

00:09:28.390 --> 00:09:33.250
新集成的实现

00:09:31.090 --> 00:09:34.450
 spring data Jim fire或 spring data Geo 

00:09:33.250 --> 00:09:37.230
取决于您要调用的名称

00:09:34.450 --> 00:09:39.610
和Spring Boot数据Geode 

00:09:37.230 --> 00:09:42.160
集成，所以有点

00:09:39.610 --> 00:09:43.570
令人困惑的不是图书馆的名字

00:09:42.160 --> 00:09:45.400
那是在 spring boot 本身

00:09:43.570 --> 00:09:48.070
而不是Spring 启动启动器

00:09:45.400 --> 00:09:51.850
由Spring Data Geode团队提供

00:09:48.070 --> 00:09:53.140
好的，如果我说了，我就是

00:09:51.850 --> 00:09:56.200
如果我在处错误地命名了它是错误的

00:09:53.140 --> 00:09:57.970
至少我希望我能正确表达

00:09:56.200 --> 00:10:00.910
这是什么，你可能会做什么

00:09:57.970 --> 00:10:02.470
逻辑上希望现在能按顺序找到它

00:10:00.910 --> 00:10:03.940
为此，我们将建立一个客户

00:10:02.470 --> 00:10:05.590
和服务，所以我们将在这里

00:10:03.940 --> 00:10:06.970
当然，目前仅用于

00:10:05.590 --> 00:10:09.460
那一刻我们没有太多可以

00:10:06.970 --> 00:10:11.380
除了生成一个新项目，在这里做

00:10:09.460 --> 00:10:14.710
我们将其称为服务器

00:10:11.380 --> 00:10:17.800
好吧，我要花很多钱，当我们

00:10:14.710 --> 00:10:20.200
使用最新和最伟大的101 

00:10:17.800 --> 00:10:23.020
 om4我要点击“生成”，然后我将

00:10:20.200 --> 00:10:25.230
建立一个客户，同样的事情，我

00:10:23.020 --> 00:10:28.870
打generate，就是我的两个

00:10:25.230 --> 00:10:30.070
依赖我有我的zip文件我的zip 

00:10:28.870 --> 00:10:33.040
文件在这里，所以我们将从

00:10:30.070 --> 00:10:36.880
一台服务器，该服务器将是

00:10:33.040 --> 00:10:39.580
正如我所说的，这将存储

00:10:36.880 --> 00:10:42.040
数据现在在大地测量零件损失中

00:10:39.580 --> 00:10:45.220
给定有几个运动部分

00:10:42.040 --> 00:10:45.760
集群服务器是要存储的东西

00:10:45.220 --> 00:10:48.850
数据

00:10:45.760 --> 00:10:50.470
它是一个将数据存储在服务器中的节点

00:10:48.850 --> 00:10:52.840
你有所谓的区域区域

00:10:50.470 --> 00:10:54.130
是lerna的逻辑分区，我应该

00:10:52.840 --> 00:10:57.610
避免使用分区字

00:10:54.130 --> 00:10:59.680
他们的服务器的逻辑块

00:10:57.610 --> 00:11:01.470
对应于数据库模式

00:10:59.680 --> 00:11:04.240
例如，您可能有一个

00:11:01.470 --> 00:11:06.490
那个叫人的区域

00:11:04.240 --> 00:11:08.170
您拥有键和值的区域

00:11:06.490 --> 00:11:09.640
嗯，最终是地图

00:11:08.170 --> 00:11:10.900
这是一本字典，如果你愿意的话

00:11:09.640 --> 00:11:13.300
您可以在其中保留一把钥匙

00:11:10.900 --> 00:11:15.040
从那些键解析值是什么样的

00:11:13.300 --> 00:11:15.790
的键真的很复杂

00:11:15.040 --> 00:11:18.310
 Java中的对象

00:11:15.790 --> 00:11:20.470
任何你想要的想法

00:11:18.310 --> 00:11:26.380
知道一个foo吧，无论你想要什么骄傲

00:11:20.470 --> 00:11:28.330
可以是键或值，您可以

00:11:26.380 --> 00:11:30.980
用它来解决这些参考

00:11:28.330 --> 00:11:32.630
服务器不是您的第一台

00:11:30.980 --> 00:11:35.120
接触不是您的第一要点

00:11:32.630 --> 00:11:37.850
与客户联系，因此

00:11:35.120 --> 00:11:40.610
善良的东西会和

00:11:37.850 --> 00:11:42.589
集群，它将解析数据，但是

00:11:40.610 --> 00:11:43.970
需要基本上派到那里

00:11:42.589 --> 00:11:46.670
需要是可以告诉它的东西

00:11:43.970 --> 00:11:50.449
在哪里找到这些数据，以便

00:11:46.670 --> 00:11:57.410
通常生活在定位器和定位器中

00:11:50.449 --> 00:12:01.279
是一个您知道充当的组件

00:11:57.410 --> 00:12:02.779
作为负载均衡器的调度程序，以及

00:12:01.279 --> 00:12:05.089
服务注册中心会告诉您在哪里

00:12:02.779 --> 00:12:06.920
查找便笺告诉客户在哪里

00:12:05.089 --> 00:12:09.050
找到鼻子，并为其提供有关的元数据

00:12:06.920 --> 00:12:10.730
集群本身的拓扑

00:12:09.050 --> 00:12:13.100
已经解决，通常

00:12:10.730 --> 00:12:15.050
客户端将连接到许多

00:12:13.100 --> 00:12:17.630
定位器通常会适合您

00:12:15.050 --> 00:12:20.750
至少有三个定位器

00:12:17.630 --> 00:12:25.250
解决后的应用程序之一

00:12:20.750 --> 00:12:26.300
定位器会找到一个

00:12:25.250 --> 00:12:27.649
节点，他们将连接到该节点

00:12:26.300 --> 00:12:29.120
然后随后的咒语

00:12:27.649 --> 00:12:31.610
随后的调用将起作用

00:12:29.120 --> 00:12:34.190
直接与节点对它会

00:12:31.610 --> 00:12:35.810
节点一旦连接就会给它

00:12:34.190 --> 00:12:39.589
如果连接到客户端到其他节点

00:12:35.810 --> 00:12:40.670
它需要所以为什么我们有三个

00:12:39.589 --> 00:12:43.190
位置很好，这是一个好问题

00:12:40.670 --> 00:12:45.529
对，我们至少有三个定位器

00:12:43.190 --> 00:12:46.940
考虑一下这个定位器就是你

00:12:45.529 --> 00:12:49.310
知道这是所有人的大脑

00:12:46.940 --> 00:12:50.860
第一次为客户建立联系

00:12:49.310 --> 00:12:53.660
很重要，你不想输

00:12:50.860 --> 00:12:57.370
当您在应用程序中

00:12:53.660 --> 00:13:01.519
需要它，所以想我想

00:12:57.370 --> 00:13:05.510
部署您知道我的1.1版

00:13:01.519 --> 00:13:07.069
我的定位器节点的定位器代码，所以我

00:13:05.510 --> 00:13:11.690
必须把定位器放好

00:13:07.069 --> 00:13:12.829
我当然需要备份

00:13:11.690 --> 00:13:14.779
首先要备份

00:13:12.829 --> 00:13:17.120
情况一，你有备份，但是

00:13:14.779 --> 00:13:19.339
然后假设我要部署1.1版

00:13:17.120 --> 00:13:20.870
的以下字节之一的定位符的

00:13:19.339 --> 00:13:22.370
警告正在运行的实例之一

00:13:20.870 --> 00:13:24.230
好吧，我现在必须把它记下来

00:13:22.370 --> 00:13:26.060
我只剩下一个实例

00:13:24.230 --> 00:13:27.740
所以在这种情况下，备份

00:13:26.060 --> 00:13:29.600
现在需要备份，所以总是很好

00:13:27.740 --> 00:13:31.970
最少要三个

00:13:29.600 --> 00:13:33.800
更多，但有一个有用的

00:13:31.970 --> 00:13:35.209
没有技术上的限制

00:13:33.800 --> 00:13:37.069
但是有一个有用的限制，因为

00:13:35.209 --> 00:13:39.470
这些东西很健谈，所以

00:13:37.069 --> 00:13:42.350
你想你知道你会拥有你

00:13:39.470 --> 00:13:44.300
至少知道三个定位器，也许

00:13:42.350 --> 00:13:46.430
多一点，但在那之后十字架

00:13:44.300 --> 00:13:48.290
会变得很吵

00:13:46.430 --> 00:13:51.580
网络，所以我们想尽可能地限制

00:13:48.290 --> 00:13:54.500
现在就尽可能

00:13:51.580 --> 00:13:56.900
我们将要构建一个应用程序

00:13:54.500 --> 00:13:59.600
将会是第一个这样的定位器

00:13:56.900 --> 00:14:01.340
都是缓存服务器，所以我们

00:13:59.600 --> 00:14:03.290
要说这将是一个缓存

00:14:01.340 --> 00:14:04.850
服务器，但为了我们做到这一点

00:14:03.290 --> 00:14:06.680
当然，我们确实需要引入

00:14:04.850 --> 00:14:08.300
必需的依赖不是我们，所以我们

00:14:06.680 --> 00:14:09.470
有一些我们需要的依赖

00:14:08.300 --> 00:14:12.380
带进来，我要继续

00:14:09.470 --> 00:14:14.150
并立即手动执行这些操作

00:14:12.380 --> 00:14:16.940
这些启动器不是的复选框

00:14:14.150 --> 00:14:18.980
反映在 Spring 和缓和剂

00:14:16.940 --> 00:14:23.030
有点可惜，但是有

00:14:18.980 --> 00:14:25.700
里程碑，但仍处于初期阶段，并保持不变

00:14:23.030 --> 00:14:31.750
介意我确实使用了一个

00:14:25.700 --> 00:14:40.520
在这里提供支持，以便 Spring geode入门

00:14:31.750 --> 00:14:47.150
 org spring framework geode和

00:14:40.520 --> 00:14:51.340
版本将是100 M 3 100 M 3 

00:14:47.150 --> 00:14:53.750
我接下来要介绍的是

00:14:51.340 --> 00:14:55.310
我已经把龙目岛做好了，所以我想

00:14:53.750 --> 00:14:59.990
引入spring shell依赖

00:14:55.310 --> 00:15:07.480
在这里， Spring ，壳组织 Spring 

00:14:59.990 --> 00:15:10.459
框架外壳和

00:15:07.480 --> 00:15:14.240
那将被固定在1.29哦

00:15:10.459 --> 00:15:15.949
现在发布，III希望

00:15:14.240 --> 00:15:17.959
时间这种依赖将是

00:15:15.949 --> 00:15:20.720
提供给我，这将被暗示或

00:15:17.959 --> 00:15:22.670
删除或无论我为什么这样做

00:15:20.720 --> 00:15:24.679
开始，但现在仅出于我们的目的

00:15:22.670 --> 00:15:26.829
现在在这里，我们将留在那里

00:15:24.679 --> 00:15:30.499
好吧，所以我们去那里是我们的

00:15:26.829 --> 00:15:31.369
我们要去的最低限度的代码定位器

00:15:30.499 --> 00:15:32.749
说这是一个定位器

00:15:31.369 --> 00:15:34.579
为了使其成为一个应用程序

00:15:32.749 --> 00:15:36.499
定位器应用程序我们需要确定

00:15:34.579 --> 00:15:39.050
我首先说过的事情

00:15:36.499 --> 00:15:41.629
需要成为缓存服务器，这样

00:15:39.050 --> 00:15:43.759
它既是定位器又是服务器的节点

00:15:41.629 --> 00:15:45.439
节点，这也是另一件事

00:15:43.759 --> 00:15:48.110
叫定位器，所以当我告诉它

00:15:45.439 --> 00:15:52.550
基本上是自言自语地写定位器

00:15:48.110 --> 00:15:54.050
位置等于1000 3 3或4并且

00:15:52.550 --> 00:15:56.269
你会想起那个

00:15:54.050 --> 00:15:58.429
这是常见的常见默认设置，所以

00:15:56.269 --> 00:16:01.069
记住这一点，最后我们

00:15:58.429 --> 00:16:02.809
要创建一个，因为有一个

00:16:01.069 --> 00:16:05.360
双重性在这里，我们都是

00:16:02.809 --> 00:16:08.059
服务器和定位器，我们要去

00:16:05.360 --> 00:16:14.499
单独创建一个配置类

00:16:08.059 --> 00:16:17.089
除了我们的locator类static 

00:16:14.499 --> 00:16:20.929
正在寻找服务器部分，您知道

00:16:17.089 --> 00:16:23.540
说，班级定位器很好的形象

00:16:20.929 --> 00:16:29.689
并不需要那样

00:16:23.540 --> 00:16:31.069
可以的方式可以分层

00:16:29.689 --> 00:16:32.959
这些你可以将它们堆叠在

00:16:31.069 --> 00:16:36.040
 Spring 良好的应用程序注释如果

00:16:32.959 --> 00:16:38.929
你喜欢对，所以在一个干练的经理那里， 

00:16:36.040 --> 00:16:40.790
开始将等于真正的好吧，所以

00:16:38.929 --> 00:16:42.980
我们在那里，这是我们非常非常基本的

00:16:40.790 --> 00:16:44.929
配置以使其正常工作

00:16:42.980 --> 00:16:46.910
我们需要一些配置我们需要一些

00:16:44.929 --> 00:16:50.089
我们要的基本特性

00:16:46.910 --> 00:16:53.149
会玩，所以这些

00:16:50.089 --> 00:16:58.610
属性尚未自动

00:16:53.149 --> 00:17:03.619
完成，所以他们带来 Spring 点

00:16:58.610 --> 00:17:08.539
数据点DEM火缓存点名称等于

00:17:03.619 --> 00:17:12.350
随机值和字符串点数据

00:17:08.539 --> 00:17:15.649
 Jim Fire点高速缓存服务器点端口

00:17:12.350 --> 00:17:19.100
等于0，当然0告诉它

00:17:15.649 --> 00:17:22.130
找到第一个未使用的端口，然后

00:17:19.100 --> 00:17:24.230
用那好吧，所以我们去那里是我们的

00:17:22.130 --> 00:17:25.579
定位符请尝试我们需要

00:17:24.230 --> 00:17:27.709
在我们可以拥有定位器之前

00:17:25.579 --> 00:17:34.840
服务器，所以这是漂亮

00:17:27.709 --> 00:17:34.840
直接好吗

00:17:40.540 --> 00:17:49.340
好吧，我做错了什么，让我们看看

00:17:43.520 --> 00:17:53.210
出现某种错误，是的，很好

00:17:49.340 --> 00:17:56.650
看起来我在干什么

00:17:53.210 --> 00:17:56.650
可能是太多的三分球

00:18:07.230 --> 00:18:11.580
现在我该怎么做

00:18:14.690 --> 00:18:22.970
它抱怨未知的主机

00:18:18.840 --> 00:18:22.970
 localhost 

00:18:36.940 --> 00:18:41.559
好吧，好像已经启动了

00:18:38.919 --> 00:18:43.479
很好，正如我们期望的那样

00:18:41.559 --> 00:18:45.580
现在我要做的就是我要

00:18:43.479 --> 00:18:46.869
建立一个服务器说明写一个实际的

00:18:45.580 --> 00:18:48.279
服务器是一个适当的服务器

00:18:46.869 --> 00:18:49.899
独立，因为我和我将拥有

00:18:48.279 --> 00:18:51.009
更多的服务器，它将有

00:18:49.899 --> 00:18:55.720
定位器，所以我要建立一个新的

00:18:51.009 --> 00:18:57.519
打包在这里服务器，这与您一样

00:18:55.720 --> 00:18:59.169
可以想象这会简单一些

00:18:57.519 --> 00:19:01.239
因为它是我们事物的一部分

00:18:59.169 --> 00:19:05.070
至少现在需要定位器

00:19:01.239 --> 00:19:11.429
这样服务器应用程序就可以了

00:19:05.070 --> 00:19:14.049
公共静态void主字符串args和

00:19:11.429 --> 00:19:20.080
这里我要说 Spring 申请

00:19:14.049 --> 00:19:22.090
运行服务器应用程序类args可以

00:19:20.080 --> 00:19:24.820
很好，好的，有我们的服务器

00:19:22.090 --> 00:19:26.379
申请并为此

00:19:24.820 --> 00:19:31.200
工作当然必须是有效的

00:19:26.379 --> 00:19:34.389
像这样的Spring Boot应用程序和

00:19:31.200 --> 00:19:37.210
让我们利用这个优势

00:19:34.389 --> 00:19:40.479
复制和粘贴并为了

00:19:37.210 --> 00:19:41.559
工作，我想就是我想

00:19:40.479 --> 00:19:44.379
这就是我们真正需要的

00:19:41.559 --> 00:19:50.019
这就是让我考虑一下

00:19:44.379 --> 00:19:54.940
是的，我是说现在

00:19:50.019 --> 00:19:59.019
大概没关系，现在我们有了

00:19:54.940 --> 00:20:02.919
服务器和我要在服务器中

00:19:59.019 --> 00:20:04.330
定义一个正确的区域，因此该区域

00:20:02.919 --> 00:20:06.220
我需要定义一个地方，我要

00:20:04.330 --> 00:20:08.139
按照实体和

00:20:06.220 --> 00:20:11.019
我将存储在通用包装中的实体

00:20:08.139 --> 00:20:12.879
现在自然可以，而且更多

00:20:11.019 --> 00:20:14.979
更常见的是将其提取出来

00:20:12.879 --> 00:20:17.139
放入单独的通用包装并创建

00:20:14.979 --> 00:20:19.749
任何类型的实体，我要去

00:20:17.139 --> 00:20:21.369
将那些实体存储在这里

00:20:19.749 --> 00:20:24.279
创造存储温度的东西

00:20:21.369 --> 00:20:26.200
传感器数据对，这是一个非常领域

00:20:24.279 --> 00:20:29.259
灵感来自于我所看到的演示

00:20:26.200 --> 00:20:33.519
 spring data Geode负责人John Bloom和

00:20:29.259 --> 00:20:35.159
和geode主题专家卢克

00:20:33.519 --> 00:20:37.659
香农，所以我要继续

00:20:35.159 --> 00:20:39.099
借用或适当使用该样本

00:20:37.659 --> 00:20:41.739
因为我觉得效果很好

00:20:39.099 --> 00:20:44.320
假设您有高速传感器

00:20:41.739 --> 00:20:46.509
指示温度的反馈

00:20:44.320 --> 00:20:47.889
各个城市或地区，尽管在

00:20:46.509 --> 00:20:49.990
这个世界还好，所以我们要

00:20:47.889 --> 00:20:52.360
在此输入

00:20:49.990 --> 00:20:54.550
将要存储的温度

00:20:52.360 --> 00:20:55.960
有关猜测温度的信息

00:20:54.550 --> 00:20:57.760
读数，所以我当然会用

00:20:55.960 --> 00:21:01.420
龙目岛我爱龙目岛它使我的生活

00:20:57.760 --> 00:21:03.070
那样容易得多，它将

00:21:01.420 --> 00:21:05.800
成为要存储在一个对象中的对象

00:21:03.070 --> 00:21:12.420
地区和该地区，我将其称为timpz 

00:21:05.800 --> 00:21:18.400
这样我就有一个ID 

00:21:12.420 --> 00:21:22.950
私人双温和私人

00:21:18.400 --> 00:21:25.570
弦城好吧，我们在那里， 

00:21:22.950 --> 00:21:28.809
 ID好的，所以有我们的 spring data 

00:21:25.570 --> 00:21:30.880
映射类型，我想告诉我的服务器

00:21:28.809 --> 00:21:32.500
关于这个东西的应用

00:21:30.880 --> 00:21:36.460
刚创建，所以我想实际上我

00:21:32.500 --> 00:21:37.960
想要将其包括在的扫描中

00:21:36.460 --> 00:21:43.110
代码正确，所以我要包括

00:21:37.960 --> 00:21:46.840
再加上实际的应用程序本身

00:21:43.110 --> 00:21:49.150
所以我说组件可以基础包装

00:21:46.840 --> 00:21:53.140
类，我将告诉它查找服务器

00:21:49.150 --> 00:21:58.840
应用类别和温度点

00:21:53.140 --> 00:22:00.660
上课好吧，瞧，他们只是

00:21:58.840 --> 00:22:04.540
覆盖 spring boot 默认

00:22:00.660 --> 00:22:07.420
组件可以行为以便拥有它

00:22:04.540 --> 00:22:11.380
拿起那个组件，所以现在我们

00:22:07.420 --> 00:22:12.970
我们可以启动我很高兴的定位器吗

00:22:11.380 --> 00:22:14.890
这样，让我们​​继续，现在重新启动

00:22:12.970 --> 00:22:19.690
更改服务器后的服务器

00:22:14.890 --> 00:22:23.610
配置，使服务器非常酷

00:22:19.690 --> 00:22:23.610
申请去

00:22:33.000 --> 00:22:37.620
好吧，我们有一个定位器和一个

00:22:36.330 --> 00:22:40.470
服务器启动并运行，因此非常

00:22:37.620 --> 00:22:42.390
好，现在我们要回到这个

00:22:40.470 --> 00:22:44.000
对，我们一定会回到

00:22:42.390 --> 00:22:46.980
现在，让我们继续前进， 

00:22:44.000 --> 00:22:53.039
您是否知道我们的进步

00:22:46.980 --> 00:23:00.990
我们的客户和客户代码中

00:22:53.039 --> 00:23:06.740
让我们在这里看看访问文件CD 

00:23:00.990 --> 00:23:06.740
植物，我们已经完成了ueo客户的zip 

00:23:08.450 --> 00:23:13.049
好的，在客户端代码中，您知道

00:23:11.909 --> 00:23:14.760
我们将做同样的事情

00:23:13.049 --> 00:23:17.700
循环的常见依赖关系，所以我们将

00:23:14.760 --> 00:23:21.679
复制做一些复制面食复制和

00:23:17.700 --> 00:23:21.679
从这里粘贴那些依赖项并

00:23:24.679 --> 00:23:33.570
将它们粘贴到XML正确的pom中

00:23:30.929 --> 00:23:34.980
非常好，这样可以为我们节省很多

00:23:33.570 --> 00:23:36.900
我在仪式上做了一些设置

00:23:34.980 --> 00:23:41.100
因为我讨厌仪式而高兴

00:23:36.900 --> 00:23:43.860
在客户端让我们摆脱这些

00:23:41.100 --> 00:23:48.360
像以前一样有一套

00:23:43.860 --> 00:23:50.030
的包装在这里供客户使用，然后

00:23:48.360 --> 00:24:00.090
在那里将创建一个名为

00:23:50.030 --> 00:24:08.000
客户应用程序，我们的课程是

00:24:00.090 --> 00:24:12.320
 Spring 良好的应用程序字符串参数

00:24:08.000 --> 00:24:12.320
 Spring 申请运行

00:24:17.400 --> 00:24:26.710
工厂应用程序类ARB可以

00:24:22.840 --> 00:24:28.660
很好，就是这样，我们的客户

00:24:26.710 --> 00:24:30.430
应用程序会做一些事情

00:24:28.660 --> 00:24:32.260
它实际上将连接到数据

00:24:30.430 --> 00:24:35.020
存储它会写数据到

00:24:32.260 --> 00:24:38.380
现在为我们提供数据库

00:24:35.020 --> 00:24:40.660
做到这一点也将有

00:24:38.380 --> 00:24:42.880
正确的普通类型，所以我们要

00:24:40.660 --> 00:24:44.290
要和我们地区谈谈，所以我们

00:24:42.880 --> 00:24:46.450
需要使用相同的类型

00:24:44.290 --> 00:24:49.030
将其提取到一个有用的

00:24:46.450 --> 00:24:50.830
分开的罐子，然后分享给大家

00:24:49.030 --> 00:24:53.080
但是为了我们的目的只是为了保留东西

00:24:50.830 --> 00:24:54.370
尽可能简单，我们只是

00:24:53.080 --> 00:24:55.840
复制并粘贴好吧，这不是

00:24:54.370 --> 00:24:58.180
一定是你在典型情况下会做的

00:24:55.840 --> 00:24:59.200
职业，但再次出于我们的目的

00:24:58.180 --> 00:25:00.580
这里有两个部分

00:24:59.200 --> 00:25:02.290
实际存储数据的服务器

00:25:00.580 --> 00:25:03.490
所以你不会那样的

00:25:02.290 --> 00:25:04.780
单独的事情将是

00:25:03.490 --> 00:25:09.340
不依赖于我们在这里和

00:25:04.780 --> 00:25:12.750
然后在客户端应用程序中，我们

00:25:09.340 --> 00:25:17.800
想要构建一个应用程序

00:25:12.750 --> 00:25:19.390
拿走它看到的数据

00:25:17.800 --> 00:25:22.930
数据进入我要说的区域

00:25:19.390 --> 00:25:24.750
启用实体定义区域基础

00:25:22.930 --> 00:25:31.150
包装类别将包括温度

00:25:24.750 --> 00:25:37.800
上课，我们要参加

00:25:31.150 --> 00:25:40.590
集群定义就在那里

00:25:37.800 --> 00:25:42.070
好吧，它将群集

00:25:40.590 --> 00:25:44.260
组态

00:25:42.070 --> 00:25:46.000
我知道那看起来很奇怪，所以我们

00:25:44.260 --> 00:25:48.160
现在有了这个，我们有了基本的

00:25:46.000 --> 00:25:49.900
客户应用程序，这就是这个

00:25:48.160 --> 00:25:52.390
这部分超级熟悉的权利，这是一个

00:25:49.900 --> 00:25:53.950
这是我认为对于我们大多数人来说，我们幸福

00:25:52.390 --> 00:25:56.680
正确的道路就像我们

00:25:53.950 --> 00:25:58.240
所有以前都知道要做的事，我们采取一种

00:25:56.680 --> 00:26:01.540
我要放一个仓库

00:25:58.240 --> 00:26:03.070
在这里扩展crud存储库

00:26:01.540 --> 00:26:04.750
要管理实体草药的实例

00:26:03.070 --> 00:26:09.130
具有其主键为

00:26:04.750 --> 00:26:10.600
键入长，我们将保存该内容，然后

00:26:09.130 --> 00:26:12.910
要创建一个写数据的东西

00:26:10.600 --> 00:26:14.560
像这样实现到数据库

00:26:12.910 --> 00:26:15.430
应用程序运行程序将是一件事情

00:26:14.560 --> 00:26:17.680
当

00:26:15.430 --> 00:26:24.220
应用程序启动，因此应用程序

00:26:17.680 --> 00:26:25.510
准备好的活动，我们将会

00:26:24.220 --> 00:26:28.620
申请时回电

00:26:25.510 --> 00:26:34.990
启动，因此实现那些方法

00:26:28.620 --> 00:26:47.310
我们会说添加组件，对不起

00:26:34.990 --> 00:26:55.450
大家好，应用程序监听器

00:26:47.310 --> 00:26:58.240
好的，有我们的活动，我们有什么

00:26:55.450 --> 00:27:00.340
我们要做的是

00:26:58.240 --> 00:27:02.680
应用程序启动将数据写入

00:27:00.340 --> 00:27:04.240
数据库，所以我要使用存储库

00:27:02.680 --> 00:27:05.440
我们刚刚创建了那个 spring data 

00:27:04.240 --> 00:27:08.800
将为它注入而创建

00:27:05.440 --> 00:27:10.930
该存储库要做的是

00:27:08.800 --> 00:27:12.310
你知道创作阅读更新和

00:27:10.930 --> 00:27:15.100
删除数据，以便我们做

00:27:12.310 --> 00:27:17.110
在这里in应用程序启动

00:27:15.100 --> 00:27:19.390
所以这只是创建一个非常简单的流程

00:27:17.110 --> 00:27:21.040
我要说好吧，什么时候找到

00:27:19.390 --> 00:27:22.420
该应用程序启动，然后

00:27:21.040 --> 00:27:24.670
我要称呼它的每个人

00:27:22.420 --> 00:27:31.480
将正温度删除，例如

00:27:24.670 --> 00:27:32.650
所以传入T吧，好吧， 

00:27:31.480 --> 00:27:34.300
当然有方法参考

00:27:32.650 --> 00:27:36.190
等待在那里使用，我们现在就去

00:27:34.300 --> 00:27:38.500
如果有的话，我们将重置所有内容

00:27:36.190 --> 00:27:40.420
数据全部消失了，然后终于

00:27:38.500 --> 00:27:43.350
我想写一些数据到

00:27:40.420 --> 00:27:47.800
数据库，所以我要插入一些数据

00:27:43.350 --> 00:27:54.100
插入，然后我们要说int 

00:27:47.800 --> 00:27:57.400
我左0眼然后是int max或我想

00:27:54.100 --> 00:28:00.750
这是一个开始，让我们抵消吧

00:27:57.400 --> 00:28:04.180
不会从随机偏移开始

00:28:00.750 --> 00:28:11.050
我们要说数学点，你知道吗

00:28:04.180 --> 00:28:15.030
在next int和int之间做随机点

00:28:11.050 --> 00:28:19.060
会是一千个整数

00:28:15.030 --> 00:28:24.460
随机偏移可以吗

00:28:19.060 --> 00:28:26.740
假设随机偏移量我加上加上所以

00:28:24.460 --> 00:28:30.630
我会加100就是这样

00:28:26.740 --> 00:28:35.290
保证至少100正常，并且

00:28:30.630 --> 00:28:37.660
一旦完成，我们将要写

00:28:35.290 --> 00:28:38.620
数据到数据库好了，我在这里

00:28:37.660 --> 00:28:40.750
只是要创建一个小方法

00:28:38.620 --> 00:28:40.990
实际上将处理插入

00:28:40.750 --> 00:28:42.460
我

00:28:40.990 --> 00:28:44.769
好吧，现在插入

00:28:42.460 --> 00:28:47.230
现在输入代码，然后插入

00:28:44.769 --> 00:28:48.159
相当简单，您知道代码

00:28:47.230 --> 00:28:53.559
我说的是让我们创建一个新的

00:28:48.159 --> 00:28:55.480
你知道我不知道

00:28:53.559 --> 00:28:58.029
实际上有一个传感器来连接我的

00:28:55.480 --> 00:28:59.320
应用程序，所以我们将

00:28:58.029 --> 00:29:02.940
老式的数据访问方式

00:28:59.320 --> 00:29:07.179
手动好吧，所以下一个新的随机点

00:29:02.940 --> 00:29:16.600
长，我们想要的下一个值是

00:29:07.179 --> 00:29:20.110
温度那么新的随机点

00:29:16.600 --> 00:29:21.850
加倍，然后我们需要一个随机城市

00:29:20.110 --> 00:29:25.690
我当然会把它提取出来

00:29:21.850 --> 00:29:33.480
单独的方法使其更容易，因此

00:29:25.690 --> 00:29:36.669
弦城市和我在的Fran Cisco 

00:29:33.480 --> 00:29:42.940
当下我美丽的多伦多

00:29:36.669 --> 00:29:56.909
写这个沙子拉蒙和加布里埃尔·洛斯

00:29:42.940 --> 00:29:59.799
安吉利斯巴黎上海东京首尔开罗

00:29:56.909 --> 00:30:04.179
等等好，所以我现在有一堆

00:29:59.799 --> 00:30:07.090
城市让我们继续前进，创造一个

00:30:04.179 --> 00:30:11.980
数组将其划分为现在和每个

00:30:07.090 --> 00:30:15.009
我要去的城市中的弦城市

00:30:11.980 --> 00:30:16.149
可以将数据写入数据库

00:30:15.009 --> 00:30:17.470
抱歉，我想要的每个城市

00:30:16.149 --> 00:30:19.649
我随机返回一个，所以我有

00:30:17.470 --> 00:30:23.340
我要说的硬核名单

00:30:19.649 --> 00:30:23.340
新随机

00:30:25.690 --> 00:30:38.350
点next int城市的点长int索引

00:30:35.160 --> 00:30:44.680
好吧，我要说的是我的索引

00:30:38.350 --> 00:30:45.880
返回城市指数，我们可以

00:30:44.680 --> 00:30:47.290
所以我要回来我只是要

00:30:45.880 --> 00:30:48.490
产生一个随机的

00:30:47.290 --> 00:30:50.410
数组中元素的数量和

00:30:48.490 --> 00:30:52.540
我将随机偏移量返回

00:30:50.410 --> 00:30:55.330
受其限制的数组，因此不是

00:30:52.540 --> 00:30:57.370
会不止于此，然后

00:30:55.330 --> 00:30:59.940
我将用它来创建这个温度

00:30:57.370 --> 00:31:01.870
对象，您会注意到我有一个

00:30:59.940 --> 00:31:04.930
开始的不同城市数

00:31:01.870 --> 00:31:07.390
和山姆说对了，所以我们以后再用

00:31:04.930 --> 00:31:08.770
巡回演出以演示一些分析

00:31:07.390 --> 00:31:11.170
功能还可以，所以现在我们有了

00:31:08.770 --> 00:31:13.180
我们现在有原始的，让我们保存它

00:31:11.170 --> 00:31:17.140
所以这个卡在温度仓库

00:31:13.180 --> 00:31:22.120
保存传递的温度好吧，所以

00:31:17.140 --> 00:31:24.940
保存的记录非常简单，如果

00:31:22.120 --> 00:31:27.070
你曾经用过Spring 数据，现在我

00:31:24.940 --> 00:31:30.100
想说这个温度库

00:31:27.070 --> 00:31:35.860
找到我的ID已保存

00:31:30.100 --> 00:31:40.780
 doc可以获取您想说是否的ID 

00:31:35.860 --> 00:31:44.740
如果它通过ID存在，那么我要

00:31:40.780 --> 00:31:51.970
映射它，我说给我的ID 

00:31:44.740 --> 00:32:02.500
当然，温度会获得ID，然后或

00:31:51.970 --> 00:32:05.560
否则不行，所以有那个ID和什么

00:32:02.500 --> 00:32:11.560
我想确认的是

00:32:05.560 --> 00:32:14.790
我已经从缓存匹配中返回

00:32:11.560 --> 00:32:16.750
没错，让我们尝试这是一个

00:32:14.790 --> 00:32:18.700
 Spring Framework类适合

00:32:16.750 --> 00:32:20.260
对您熟悉的生产代码DBC 

00:32:18.700 --> 00:32:24.310
按合同设计断言

00:32:20.260 --> 00:32:28.600
我要说的是真的等于等于

00:32:24.310 --> 00:32:31.000
说等于保存的获取ID，所以我

00:32:28.600 --> 00:32:36.210
应该能够在其中写入数据

00:32:31.000 --> 00:32:36.210
然后把它拉回来就好了，所以

00:32:36.640 --> 00:32:58.440
让我们看看数据库中应该存在

00:32:55.300 --> 00:33:04.300
好吧，我们去，所以有我的

00:32:58.440 --> 00:33:06.670
更新代码很酷，所以现在我们

00:33:04.300 --> 00:33:08.020
现在在这里写了许多记录

00:33:06.670 --> 00:33:09.100
正确的时候申请

00:33:08.020 --> 00:33:11.170
启动我们正在运行数据到

00:33:09.100 --> 00:33:13.840
现在我认为这实际上是一个数据库

00:33:11.170 --> 00:33:17.140
很好的开始，让我们继续

00:33:13.840 --> 00:33:20.500
并看到它现在可以工作了

00:33:17.140 --> 00:33:23.880
我们这样做，让我们使用G鱼连接

00:33:20.500 --> 00:33:27.970
我在此专栏中

00:33:23.880 --> 00:33:30.520
 Patchi地理发行目录和

00:33:27.970 --> 00:33:32.500
我有一个我的意思是bin目录

00:33:30.520 --> 00:33:34.720
而且我有很多shell实用程序

00:33:32.500 --> 00:33:37.690
包括一些叫做GG鱼的东西

00:33:34.720 --> 00:33:42.160
是宝石之火或假想的外壳

00:33:37.690 --> 00:33:43.840
在G鱼中，您有很多

00:33:42.160 --> 00:33:46.270
这里的功能，所以我可以说我很好

00:33:43.840 --> 00:33:48.490
要连接，它会问我

00:33:46.270 --> 00:33:50.890
给定定位器的连接，您会看到

00:33:48.490 --> 00:33:53.260
之前如何运作的，所以我要

00:33:50.890 --> 00:33:56.350
说只是连接，默认情况下它将

00:33:53.260 --> 00:33:58.000
连接它是 localhost 10 0 3 3 4 

00:33:56.350 --> 00:34:00.070
我们本来可以做到的

00:33:58.000 --> 00:34:03.580
花了我站着我可以说连接-- 

00:34:00.070 --> 00:34:05.230
定位器 localhost 10 3 3 4 

00:34:03.580 --> 00:34:07.360
这个外壳看起来很熟悉

00:34:05.230 --> 00:34:10.810
您可能会回忆起我们的 Spring 

00:34:07.360 --> 00:34:13.630
壳Spring 提示视频从一点

00:34:10.810 --> 00:34:14.919
回来的时候，我们知道这些

00:34:13.630 --> 00:34:16.390
这些都是你的能力

00:34:14.919 --> 00:34:18.820
会进入Spring Shell，这是因为

00:34:16.390 --> 00:34:21.100
 G fish秀基于弹壳

00:34:18.820 --> 00:34:22.990
基于相同的项目，实际上

00:34:21.100 --> 00:34:25.000
您甚至可能会争辩说它诞生了

00:34:22.990 --> 00:34:30.820
因为它需要整合和

00:34:25.000 --> 00:34:34.000
支持吉姆，好吧，现在我们想要什么

00:34:30.820 --> 00:34:36.040
说列表区域，让我们看看是否可以

00:34:34.000 --> 00:34:38.770
做那没发现的事，我们还没有

00:34:36.040 --> 00:34:40.810
启动客户端

00:34:38.770 --> 00:34:43.869
让我们这样做，让我们现在运行它，我们

00:34:40.810 --> 00:34:48.720
知道我们有这个东西会找到

00:34:43.869 --> 00:34:48.720
那里运行良好的区域

00:34:59.820 --> 00:35:07.800
哦，我做错了什么吧

00:35:04.070 --> 00:35:08.940
没有可用的服务器

00:35:07.800 --> 00:35:11.430
连接啊，那是因为我需要

00:35:08.940 --> 00:35:13.590
在属性文件中进行配置

00:35:11.430 --> 00:35:14.820
客户端好吧好吧，所以你不能

00:35:13.590 --> 00:35:17.280
知道同一件事，我有一点

00:35:14.820 --> 00:35:18.750
使用时此处暗含的配置

00:35:17.280 --> 00:35:21.810
客户端，就像我们在服务器上一样

00:35:18.750 --> 00:35:24.410
但是这里的配置也不是

00:35:21.810 --> 00:35:25.620
尚未得到酒店的支持

00:35:24.410 --> 00:35:27.780
自动完成

00:35:25.620 --> 00:35:30.450
在 Spring ，但是-但是那将会是

00:35:27.780 --> 00:35:32.190
这是正确的方式，所以对于我们

00:35:30.450 --> 00:35:33.750
目的是你知道没什么大不了的

00:35:32.190 --> 00:35:39.980
我们说的只是一个简单的客户

00:35:33.750 --> 00:35:45.810
扭伤数据宝石火点池点

00:35:39.980 --> 00:35:46.700
定位器等于 localhost 的十个334外观

00:35:45.810 --> 00:35:50.360
熟悉的

00:35:46.700 --> 00:35:50.360
好吧拿两个

00:36:03.200 --> 00:36:07.700
好吧，似乎已经成功了

00:36:06.230 --> 00:36:09.380
没有熬夜，因为什么都没有

00:36:07.700 --> 00:36:11.089
熬夜，没有，你不知道

00:36:09.380 --> 00:36:12.200
它是无状态的，它刚启动

00:36:11.089 --> 00:36:13.819
并做它会关闭

00:36:12.200 --> 00:36:15.319
没有类似的Web服务器或服务

00:36:13.819 --> 00:36:18.020
说话，一切都不对劲

00:36:15.319 --> 00:36:20.270
实际上是一台服务器，所以我们可以去这里

00:36:18.020 --> 00:36:22.640
现在这个地区，你现在可以看到

00:36:20.270 --> 00:36:25.460
知道我们的温度是正确的

00:36:22.640 --> 00:36:28.490
显然能够与我们合作

00:36:25.460 --> 00:36:30.079
温度很酷，我们

00:36:28.490 --> 00:36:31.970
实际上那里也有数据，我们

00:36:30.079 --> 00:36:34.040
我们可以运行查询吗，让我们进行查询

00:36:31.970 --> 00:36:36.589
查询等于，它需要一些东西

00:36:34.040 --> 00:36:43.359
称为oql ochio是对象查询

00:36:36.589 --> 00:36:47.869
语言，所以我可以说从中选择计数

00:36:43.359 --> 00:36:50.390
临时工实际上只是在那里做

00:36:47.869 --> 00:36:53.119
你去了374，让我们看一下

00:36:50.390 --> 00:36:59.150
记录说我要打开包装

00:36:53.119 --> 00:37:05.150
 ID和城市好吗，我们去了

00:36:59.150 --> 00:37:07.309
现在标识临时救援人员和城市

00:37:05.150 --> 00:37:08.930
因为它首先是保持

00:37:07.309 --> 00:37:10.130
请记住，这就是Java 

00:37:08.930 --> 00:37:12.020
这些是Java中的记录

00:37:10.130 --> 00:37:17.750
我没有的Java代码中的数据库

00:37:12.020 --> 00:37:20.510
讲任何我没有教过的宝石之火或

00:37:17.750 --> 00:37:22.430
对我们没有的数据进行大地测量

00:37:20.510 --> 00:37:25.309
告诉它如何坚持我没有

00:37:22.430 --> 00:37:27.290
甚至实现了我所做的可序列化

00:37:25.309 --> 00:37:28.880
用那个区域和它注释

00:37:27.290 --> 00:37:31.640
只是暗示了这个的布局

00:37:28.880 --> 00:37:32.869
使用反射对象，这是

00:37:31.640 --> 00:37:35.780
不是存储数据的唯一方法

00:37:32.869 --> 00:37:37.099
正确，您可以实际使用

00:37:35.780 --> 00:37:38.089
首先它是正确的

00:37:37.099 --> 00:37:42.799
一切都很好

00:37:38.089 --> 00:37:45.250
使用这种格式，但并非总是如此

00:37:42.799 --> 00:37:47.990
最好的情况是我想

00:37:45.250 --> 00:37:51.140
针对某些字段运行查询

00:37:47.990 --> 00:37:54.200
在更多得多

00:37:51.140 --> 00:37:58.220
在这种情况下，我会设置大量数据

00:37:54.200 --> 00:37:59.569
需要引擎数据库

00:37:58.220 --> 00:38:03.079
平台本身和下一个平台

00:37:59.569 --> 00:38:05.809
需要不撒谎或DCO撒谎

00:38:03.079 --> 00:38:09.200
中的每个温度Java对象

00:38:05.809 --> 00:38:11.130
然后缓存对其进行测试，并

00:38:09.200 --> 00:38:13.770
然后结果你知道

00:38:11.130 --> 00:38:15.420
如果我要运行条件或

00:38:13.770 --> 00:38:17.310
仅针对谓词进行测试

00:38:15.420 --> 00:38:18.690
例如我必须反序列化或

00:38:17.310 --> 00:38:21.270
我愿意，但平台会

00:38:18.690 --> 00:38:22.920
它会被消毒吗

00:38:21.270 --> 00:38:25.260
参考温度值运行

00:38:22.920 --> 00:38:27.570
我们想要的任何查询或谓词

00:38:25.260 --> 00:38:29.040
针对该温度值，然后

00:38:27.570 --> 00:38:31.770
继续在右边积累

00:38:29.040 --> 00:38:34.440
结果变成一个结果集

00:38:31.770 --> 00:38:36.510
过程使事情变慢了

00:38:34.440 --> 00:38:37.650
数量，但确实如此，如果您想

00:38:36.510 --> 00:38:41.400
避免你可以有事

00:38:37.650 --> 00:38:45.330
称为PD X，这是一种编码格式

00:38:41.400 --> 00:38:46.650
专用于对其他数据进行大地测量

00:38:45.330 --> 00:38:48.060
拥有类似的东西是件好事

00:38:46.650 --> 00:38:50.160
例如使用连贯性

00:38:48.060 --> 00:38:52.050
有一种叫做“暂停POF便携式”的东西

00:38:50.160 --> 00:38:54.240
对象格式，这是相同的想法

00:38:52.050 --> 00:38:56.040
这是一个接口，它是一种类型

00:38:54.240 --> 00:38:57.690
您定义的定义语言

00:38:56.040 --> 00:39:00.390
与任何一个特定的事物无关

00:38:57.690 --> 00:39:03.360
语言或运行时，基本上

00:39:00.390 --> 00:39:05.280
您基本上定义了

00:39:03.360 --> 00:39:06.810
正确的对象，它是一个类型def 

00:39:05.280 --> 00:39:08.640
基本上，如果您已经做过C 

00:39:06.810 --> 00:39:09.990
你说的是一个结构

00:39:08.640 --> 00:39:12.510
你在说，你在说

00:39:09.990 --> 00:39:15.960
运行时如何布置内存以及什么

00:39:12.510 --> 00:39:18.390
田野去哪里，你知道我是否看

00:39:15.960 --> 00:39:20.910
在第三个字段中输入什么类型

00:39:18.390 --> 00:39:22.680
我能找到的是一个字符串

00:39:20.910 --> 00:39:26.910
日期作为对象是一个布尔值

00:39:22.680 --> 00:39:29.550
等，这样的讨论

00:39:26.910 --> 00:39:31.920
理解有助于运行时

00:39:29.550 --> 00:39:33.900
因为它只能解开一个领域

00:39:31.920 --> 00:39:35.550
你在寻找正确的不是

00:39:33.900 --> 00:39:38.670
只是要打开这个斑点，就是你的

00:39:35.550 --> 00:39:40.860
然后再调用Java对象

00:39:38.670 --> 00:39:42.990
基于反射的方法可以说哦

00:39:40.860 --> 00:39:44.520
您正在寻找温度

00:39:42.990 --> 00:39:46.470
我称之为温度的领域

00:39:44.520 --> 00:39:48.080
碰巧知道是一个双，因此

00:39:46.470 --> 00:39:54.150
那些少于字节

00:39:48.080 --> 00:39:56.580
偏移到有效载荷中，您可以

00:39:54.150 --> 00:39:59.370
看到实际上是在幕后

00:39:56.580 --> 00:40:00.840
缓存了PDX类型，实际上它具有

00:39:59.370 --> 00:40:03.180
这个定义是为我们创造的

00:40:00.840 --> 00:40:05.130
自动，但如果我们给它，如果我们

00:40:03.180 --> 00:40:07.260
提前给PDX运行时，我们

00:40:05.130 --> 00:40:08.940
预先存储东西

00:40:07.260 --> 00:40:14.030
使用PDX，我们可以获得一些性能

00:40:08.940 --> 00:40:18.930
您可以在类型中实现的好处

00:40:14.030 --> 00:40:21.570
在这里实现了PDX是什么作家

00:40:18.930 --> 00:40:23.250
是的作家，然后如果您实施

00:40:21.570 --> 00:40:23.930
你已经收集了这些方法

00:40:23.250 --> 00:40:25.280
您

00:40:23.930 --> 00:40:28.970
在乎，所以我不会用你的

00:40:25.280 --> 00:40:30.830
还有一个单独的类型，你会

00:40:28.970 --> 00:40:33.760
实现您知道独立的通用

00:40:30.830 --> 00:40:37.100
任何称为PDX的实体

00:40:33.760 --> 00:40:39.200
序列化器或编码器或类似的东西

00:40:37.100 --> 00:40:41.300
这是你通过实体的事情

00:40:39.200 --> 00:40:43.550
进入，它将知道如何编码

00:40:41.300 --> 00:40:44.780
这些就是这样做的事情

00:40:43.550 --> 00:40:45.770
通常不会为您工作

00:40:44.780 --> 00:40:49.270
实现所有可能的方法

00:40:45.770 --> 00:40:53.810
从基础扩展，从而扩展PDX 

00:40:49.270 --> 00:40:58.880
不是作家的权利或淘气鬼也许是正确的

00:40:53.810 --> 00:41:01.850
那是什么让我对

00:40:58.880 --> 00:41:03.260
所以你必须要做类似的事情

00:41:01.850 --> 00:41:06.230
在这些类型中，有一个

00:41:03.260 --> 00:41:08.240
基地之一，如你所见，我还没有

00:41:06.230 --> 00:41:09.950
最近做过，但是如果你做得到

00:41:08.240 --> 00:41:13.100
需要高性能和利益

00:41:09.950 --> 00:41:15.860
那就是你被迫进入

00:41:13.100 --> 00:41:17.990
在解压您的类型并进行解释时

00:41:15.860 --> 00:41:19.910
并阐明其结构的形状

00:41:17.990 --> 00:41:22.520
该类型的运行时

00:41:19.910 --> 00:41:24.470
被迫对事实作出让步

00:41:22.520 --> 00:41:27.110
那只是一堆字节说

00:41:24.470 --> 00:41:30.290
某个地方，那些字节有

00:41:27.110 --> 00:41:32.270
易于阅读，但是当您这样做时

00:41:30.290 --> 00:41:34.930
您现在就可以

00:41:32.270 --> 00:41:36.920
该PDX定义该类型定义

00:41:34.930 --> 00:41:38.810
您明确定义为

00:41:36.920 --> 00:41:41.450
反对我们在这里隐式定义

00:41:38.810 --> 00:41:44.360
并使用另一个平台，以便您可以

00:41:41.450 --> 00:41:46.340
从网络中读取相同类型的内容

00:41:44.360 --> 00:41:47.510
从信号加上任何东西看

00:41:46.340 --> 00:41:48.410
有约束力，有很多

00:41:47.510 --> 00:41:51.080
他们不同的客户端库

00:41:48.410 --> 00:41:52.460
与UM交谈，与该网格交谈，这样可以

00:41:51.080 --> 00:41:54.470
如果愿意的话，成为一个很棒的插管店

00:41:52.460 --> 00:41:56.720
有一个可以提供服务的地方

00:41:54.470 --> 00:41:58.730
他们可以互相融合

00:41:56.720 --> 00:42:00.800
知道你可以阅读C代码

00:41:58.730 --> 00:42:02.390
传感器硬件上的数据

00:42:00.800 --> 00:42:03.770
这可能是写给

00:42:02.390 --> 00:42:06.170
这个网格，然后Java代码可能是

00:42:03.770 --> 00:42:12.620
进行复杂的事件处理

00:42:06.170 --> 00:42:15.170
数据还可以，所以我们来谈谈处理

00:42:12.620 --> 00:42:19.820
首先让我们谈谈分析

00:42:15.170 --> 00:42:21.820
嗯，我想实际处理一些

00:42:19.820 --> 00:42:24.530
这些数据我希望能够

00:42:21.820 --> 00:42:26.030
针对您可以执行查询

00:42:24.530 --> 00:42:27.530
您可以在中创建自定义查找器方法

00:42:26.030 --> 00:42:29.330
仓库只是Spring 数据

00:42:27.530 --> 00:42:30.800
毕竟，但我想做的是

00:42:29.330 --> 00:42:34.250
我想创建一个自定义查找器

00:42:30.800 --> 00:42:37.290
那个方法

00:42:34.250 --> 00:42:38.970
数据可用时通知我

00:42:37.290 --> 00:42:42.060
这是不同于

00:42:38.970 --> 00:42:45.570
也许你已经习惯了我

00:42:42.060 --> 00:42:51.540
想在这里做的就是我想要的东西

00:42:45.570 --> 00:42:52.920
我是我想要lis数据网格

00:42:51.540 --> 00:42:54.840
告诉我什么时候有新数据反对

00:42:52.920 --> 00:42:56.820
对我而言，不断拉动数据网格

00:42:54.840 --> 00:42:58.590
通过所有的结果

00:42:56.820 --> 00:43:00.869
客户，然后找到记录

00:42:58.590 --> 00:43:02.670
符合我可能没有的条件

00:43:00.869 --> 00:43:04.740
再次符合该条件或

00:43:02.670 --> 00:43:06.840
分钟前或一周前，我只

00:43:04.740 --> 00:43:08.790
在这里有几百条记录，但是

00:43:06.840 --> 00:43:11.609
拥有数十亿条记录的情况并不少见

00:43:08.790 --> 00:43:14.490
所以你知道这是大型的

00:43:11.609 --> 00:43:17.490
数据，从最真实的意义上讲， 

00:43:14.490 --> 00:43:21.060
这将是低效率的，令人遗憾的

00:43:17.490 --> 00:43:22.800
如果您所做的只是使用Jim fire作为

00:43:21.060 --> 00:43:25.050
你可能需要续集数据库

00:43:22.800 --> 00:43:26.190
数据并处理它，或者如果您要去

00:43:25.050 --> 00:43:27.780
像对待续集数据库一样对待它

00:43:26.190 --> 00:43:30.240
至少将其视为续集数据库

00:43:27.780 --> 00:43:32.040
并使用一些更有趣的

00:43:30.240 --> 00:43:34.260
续集数据库的功能

00:43:32.040 --> 00:43:36.060
等价于存储过程

00:43:34.260 --> 00:43:37.280
我想在这里做，所以甚至都没有

00:43:36.060 --> 00:43:39.150
就像存储过程一样， 

00:43:37.280 --> 00:43:41.130
更像是复杂的事件处理

00:43:39.150 --> 00:43:42.660
碰巧像存储引擎一样运行的引擎

00:43:41.130 --> 00:43:45.630
程序对，我想说的是

00:43:42.660 --> 00:43:48.300
当有事实是真实的，让我

00:43:45.630 --> 00:43:50.310
知道我要网格负责

00:43:48.300 --> 00:43:52.020
用于运行查询以及何时存在

00:43:50.310 --> 00:43:53.090
匹配的结果让我知道，但我

00:43:52.020 --> 00:43:55.619
不想我不想成为

00:43:53.090 --> 00:43:58.109
困扰于不断拉

00:43:55.619 --> 00:43:59.910
网格，不得不将数据拉下来

00:43:58.109 --> 00:44:02.280
效率很低的网格可以运行

00:43:59.910 --> 00:44:04.020
向我查询它可以分发

00:44:02.280 --> 00:44:05.970
整个网格而不是我的查询

00:44:04.020 --> 00:44:09.060
跨网格分布数据

00:44:05.970 --> 00:44:13.890
对，所以我们要做的是

00:44:09.060 --> 00:44:16.560
要创建一个连续查询

00:44:13.890 --> 00:44:20.400
好的，现在我们可以

00:44:16.560 --> 00:44:21.570
连续查询，我们需要您知道我们

00:44:20.400 --> 00:44:23.100
在这里结束了一点代码而不是

00:44:21.570 --> 00:44:32.820
大不了的事会在

00:44:23.100 --> 00:44:41.640
客户端模块CQ Java类中的

00:44:32.820 --> 00:44:47.390
 CQ应用程序公共静态无效主体

00:44:41.640 --> 00:44:53.010
字符串args spring应用程序点运行

00:44:47.390 --> 00:44:57.740
 CQ应用程序类args，想知道吗

00:44:53.010 --> 00:45:00.150
这就是我们的骨架

00:44:57.740 --> 00:45:02.400
过去到 Spring 很好的应用

00:45:00.150 --> 00:45:05.640
我自然要说，他们会

00:45:02.400 --> 00:45:07.950
集群配置很棒

00:45:05.640 --> 00:45:09.960
然后真的我们可以把这个

00:45:07.950 --> 00:45:10.980
在什么地方连续查询

00:45:09.960 --> 00:45:12.480
会发生的是我们要开始这个

00:45:10.980 --> 00:45:14.100
应用程序，我们需要确保它

00:45:12.480 --> 00:45:21.870
不会消失，所以我要说新的

00:45:14.100 --> 00:45:24.690
扫描仪系统，但不是点读

00:45:21.870 --> 00:45:27.030
接下来不是吗，是的，他们接下来要去

00:45:24.690 --> 00:45:28.260
要解析下一个令牌，我们

00:45:27.030 --> 00:45:32.040
只是要在这里连续查询

00:45:28.260 --> 00:45:33.650
因此，我们添加连续查询和

00:45:32.040 --> 00:45:38.820
查询名称将是新的

00:45:33.650 --> 00:45:43.800
温度读数有点无关紧要

00:45:38.820 --> 00:45:52.410
但很高兴精确地选择所有

00:45:43.800 --> 00:45:53.730
市区内有山姆的临时工

00:45:52.410 --> 00:45:56.220
看看我在做什么我实际上在

00:45:53.730 --> 00:45:59.550
编写使用对象的查询

00:45:56.220 --> 00:46:01.350
正确，这是一个Java对象，我可以说doc 

00:45:59.550 --> 00:46:05.160
我在这里可以做同样的事情

00:46:01.350 --> 00:46:07.470
可以说点子字符串，例如零

00:46:05.160 --> 00:46:08.610
三个正确，我回来了

00:46:07.470 --> 00:46:11.340
我实际上在呼叫的前三个记录

00:46:08.610 --> 00:46:12.990
字符串上的Java方法，所以我要

00:46:11.340 --> 00:46:17.840
说什么时候该方法被调用

00:46:12.990 --> 00:46:22.710
该查询与新温带或

00:46:17.840 --> 00:46:26.760
给我这个均衡器事件，然后我想

00:46:22.710 --> 00:46:33.930
我要说好的过程，如果

00:46:26.760 --> 00:46:36.870
活动在那里，我要拆包

00:46:33.930 --> 00:46:38.040
所以我会说你知道这个点越来越新

00:46:36.870 --> 00:46:39.390
值，你可以看到我很老

00:46:38.040 --> 00:46:41.550
值，我有钥匙，你有

00:46:39.390 --> 00:46:43.410
查询影响它的任何异常

00:46:41.550 --> 00:46:44.910
我让三角洲与众不同

00:46:43.410 --> 00:46:46.830
知道旧值之间的字节数

00:46:44.910 --> 00:46:49.050
新价值的家伙，如果我想让你知道很多

00:46:46.830 --> 00:46:52.020
有趣的信息，但我

00:46:49.050 --> 00:46:54.630
想要是一个新的价值，我要说

00:46:52.020 --> 00:46:57.299
在地图上显示它

00:46:54.630 --> 00:47:00.480
到一个好的温度我要说

00:46:57.299 --> 00:47:05.849
蒂姆，我会把它打印出来好

00:47:00.480 --> 00:47:09.630
系统奇数温度已达到且

00:47:05.849 --> 00:47:11.730
当然这可能是CQ活动

00:47:09.630 --> 00:47:13.859
好的，这是我的CQ方法

00:47:11.730 --> 00:47:15.150
基本上只要有事实

00:47:13.859 --> 00:47:16.289
符合此查询

00:47:15.150 --> 00:47:17.730
每当有记录

00:47:16.289 --> 00:47:19.529
写入与此匹配的Navis 

00:47:17.730 --> 00:47:20.880
查询此方法将被调用

00:47:19.529 --> 00:47:22.380
我将有机会正确处理它

00:47:20.880 --> 00:47:24.599
可以写出来我可以做有趣的事

00:47:22.380 --> 00:47:28.019
这样的事情，所以现在我有了

00:47:24.599 --> 00:47:30.660
客户服务的CQ应用程序

00:47:28.019 --> 00:47:33.329
继续并运行此行，我们将运行

00:47:30.660 --> 00:47:36.599
此代码，我们将看到那应该

00:47:33.329 --> 00:47:37.859
希望保持清醒，什么都不会

00:47:36.599 --> 00:47:40.650
发生在它开始时会坐

00:47:37.859 --> 00:47:41.910
有某种等待输入或或等待

00:47:40.650 --> 00:47:46.109
写下一些东西给

00:47:41.910 --> 00:47:50.099
输出一个希望好吧，所以有

00:47:46.109 --> 00:47:52.289
现在让我们去我们的客户并运行

00:47:50.099 --> 00:47:54.480
再次申请，我要

00:47:52.289 --> 00:47:57.680
快速切换回CQ 

00:47:54.480 --> 00:48:00.059
一旦启动并运行

00:47:57.680 --> 00:48:03.180
所以我们在CQ应用程序中说

00:48:00.059 --> 00:48:06.750
开始寻找应用程序，我们去你那里

00:48:03.180 --> 00:48:08.819
可以看到你几乎立即知道

00:48:06.750 --> 00:48:10.529
我刚刚完成的所有这些权利

00:48:08.819 --> 00:48:13.529
客户端应用程序中的另一个线程

00:48:10.529 --> 00:48:15.210
和匹配Sam的其他过程

00:48:13.529 --> 00:48:17.640
而且你知道其中有一些

00:48:15.210 --> 00:48:19.380
在我们的数据集中返回

00:48:17.640 --> 00:48:21.359
立即马上就不需要

00:48:19.380 --> 00:48:22.890
根本没有时间，那在哪里

00:48:21.359 --> 00:48:24.990
我们是在一千个节点上运行还是

00:48:22.890 --> 00:48:27.869
就像我在此的一个音符

00:48:24.990 --> 00:48:29.400
实例正确，所以很酷吧

00:48:27.869 --> 00:48:30.539
我喜欢我，我爱继续

00:48:29.400 --> 00:48:31.980
创建以为您可以将其用于

00:48:30.539 --> 00:48:34.589
 pub / sub之类的事情你可以说还可以

00:48:31.980 --> 00:48:36.059
我对任何新消息都很感兴趣

00:48:34.589 --> 00:48:37.440
这意味着什么给我一个

00:48:36.059 --> 00:48:39.450
选择全部四个的连续查询

00:48:37.440 --> 00:48:41.430
消息没有比这更简单的了

00:48:39.450 --> 00:48:43.079
有新消息时，通知我

00:48:41.430 --> 00:48:43.319
消息中的新消息呢

00:48:43.079 --> 00:48:46.410
聊天室

00:48:43.319 --> 00:48:48.210
好吧，从聊天中全选

00:48:46.410 --> 00:48:49.500
您知道会话ID等于

00:48:48.210 --> 00:48:52.710
不管你能做什么， 

00:48:49.500 --> 00:48:54.809
有趣的事情，好吧，我会，我

00:48:52.710 --> 00:48:57.299
这样，但是如果我想要一些东西

00:48:54.809 --> 00:49:00.480
我无法真正与G表达

00:48:57.299 --> 00:49:01.890
与oql对，oql是对象查询

00:49:00.480 --> 00:49:04.079
语言我喜欢我们的语言对象

00:49:01.890 --> 00:49:06.690
但是很多时候我需要做定制

00:49:04.079 --> 00:49:07.430
处理数据并在此处进行大地测量

00:49:06.690 --> 00:49:09.380
进入

00:49:07.430 --> 00:49:11.119
因为如果你想做点什么

00:49:09.380 --> 00:49:13.279
后续数据存储中的Java代码或

00:49:11.119 --> 00:49:15.289
 MongoDB或类似的东西

00:49:13.279 --> 00:49:17.029
将数据提取到您拥有的某些内存中

00:49:15.289 --> 00:49:18.349
将其拉入客户端，然后

00:49:17.029 --> 00:49:20.630
您知道从数据流中获利

00:49:18.349 --> 00:49:22.609
在客户中，你不知道

00:49:20.630 --> 00:49:24.230
除非您竭尽所能

00:49:22.609 --> 00:49:25.940
引入线程等等，你不能

00:49:24.230 --> 00:49:27.710
真正平行的眼睛

00:49:25.940 --> 00:49:29.420
当然可以肯定，如果其中任何一项工作是我/我

00:49:27.710 --> 00:49:32.089
一定你无法扩展

00:49:29.420 --> 00:49:33.619
你肯定无限地知道

00:49:32.089 --> 00:49:35.390
你不会在一个

00:49:33.619 --> 00:49:36.650
单节点单个实例，所以现在您

00:49:35.390 --> 00:49:38.450
必须涉足尝试

00:49:36.650 --> 00:49:40.250
使其在不同节点之间并行化

00:49:38.450 --> 00:49:42.140
并确定有类似的技术

00:49:40.250 --> 00:49:43.700
 Spring批处理远程分块

00:49:42.140 --> 00:49:45.380
支持这一点，但现在又在

00:49:43.700 --> 00:49:47.059
完全不同的范式

00:49:45.380 --> 00:49:49.250
我想说的是

00:49:47.059 --> 00:49:51.799
处理功能，我会

00:49:49.250 --> 00:49:54.020
喜欢做的请运行处理

00:49:51.799 --> 00:49:56.539
我所有地区的逻辑

00:49:54.020 --> 00:49:59.150
系统还可以，这就是我们可以做到的

00:49:56.539 --> 00:50:00.890
使用自定义功能好这些

00:49:59.150 --> 00:50:02.690
他们可以做一些非常有用的功能

00:50:00.890 --> 00:50:05.299
他们可以做一些非常有趣的事情

00:50:02.690 --> 00:50:06.710
有趣的事情，你可能不会

00:50:05.299 --> 00:50:08.960
你可能没有想过

00:50:06.710 --> 00:50:13.549
例如，假设一个例子

00:50:08.960 --> 00:50:16.400
您有一堆CSV文件，这是

00:50:13.549 --> 00:50:18.170
你知道一些常见的例子

00:50:16.400 --> 00:50:19.309
人们有，你知道有数据吗

00:50:18.170 --> 00:50:20.869
摄取他们想要装载一大堆

00:50:19.309 --> 00:50:22.910
记录到内存中，然后

00:50:20.869 --> 00:50:24.589
处理它，或者您知道分析它是

00:50:22.910 --> 00:50:27.349
一个，但他们需要加载数据

00:50:24.589 --> 00:50:29.839
假设我摄取本身很乏味

00:50:27.349 --> 00:50:32.900
在每个节点中都有一个群集

00:50:29.839 --> 00:50:35.900
云平台和顺便说一下云

00:50:32.900 --> 00:50:37.400
技术对此非常有用，因为

00:50:35.900 --> 00:50:38.930
他们可以扩展这个东西

00:50:37.400 --> 00:50:40.579
水平无限

00:50:38.930 --> 00:50:43.279
动态正确，所以如果您使用

00:50:40.579 --> 00:50:45.020
像PCC这样的关键云

00:50:43.279 --> 00:50:47.059
缓存在Cloud Foundry上，那只是

00:50:45.020 --> 00:50:48.710
轻而易举的事，您只需部署它，然后您

00:50:47.059 --> 00:50:51.349
可以从许多

00:50:48.710 --> 00:50:54.650
您在i上的不同节点

00:50:51.349 --> 00:50:56.960
作为平台，例如AWS或GCP 

00:50:54.650 --> 00:50:58.549
或者说谁当然也很棒

00:50:56.960 --> 00:51:00.650
我的意思是选择，让我们

00:50:58.549 --> 00:51:02.900
假设您有这样一个部署中心

00:51:00.650 --> 00:51:04.549
为每个虚拟节点放置拓扑

00:51:02.900 --> 00:51:06.980
例如，机器上的屁股

00:51:04.549 --> 00:51:10.549
可以连接到共享存储

00:51:06.980 --> 00:51:13.339
有一个你有你可以的数量

00:51:10.549 --> 00:51:16.579
读取您具有批处理数据CSV数据的数据

00:51:13.339 --> 00:51:20.030
无论您认识每个区域

00:51:16.579 --> 00:51:22.760
可以实际写入网格

00:51:20.030 --> 00:51:24.500
一堆钥匙，钥匙可以

00:51:22.760 --> 00:51:26.960
只是键，然后是空值， 

00:51:24.500 --> 00:51:29.030
然后您可以运行处理程序并

00:51:26.960 --> 00:51:30.500
将会公平地分布在所有

00:51:29.030 --> 00:51:32.300
集群中的节点正确

00:51:30.500 --> 00:51:33.620
不仅会在一个节点上，还会被加载

00:51:32.300 --> 00:51:35.480
平衡，如果您想通过方式

00:51:33.620 --> 00:51:38.690
可以指定您可以说的冗余

00:51:35.480 --> 00:51:41.660
这个节点请复制到这个

00:51:38.690 --> 00:51:44.120
例如其他节点权利，或者您知道

00:51:41.660 --> 00:51:45.860
您指定要复制

00:51:44.120 --> 00:51:47.150
您可以连连的不同时间数

00:51:45.860 --> 00:51:50.170
正确进行交易

00:51:47.150 --> 00:51:52.640
可以访问数据存储说我

00:51:50.170 --> 00:51:53.960
坚持要能够回滚

00:51:52.640 --> 00:51:57.080
出问题了，甚至

00:51:53.960 --> 00:51:58.460
在geode中支持JTA，我的意思是

00:51:57.080 --> 00:51:59.600
一切真的只是一个

00:51:58.460 --> 00:52:01.880
企业

00:51:59.600 --> 00:52:04.310
你深思熟虑的东西我

00:52:01.880 --> 00:52:05.510
不会使用DTA，但是如果您需要

00:52:04.310 --> 00:52:06.650
关键是这是你的那些事之一

00:52:05.510 --> 00:52:09.620
可以和你一起使用

00:52:06.650 --> 00:52:13.640
那，例如JMS或其他

00:52:09.620 --> 00:52:14.960
对，但是它也有逻辑

00:52:13.640 --> 00:52:16.220
资源本地交易是

00:52:14.960 --> 00:52:17.810
你可以做多次写的另一件事

00:52:16.220 --> 00:52:19.520
然后我同时开始转弯

00:52:17.810 --> 00:52:20.630
实际写或回滚我

00:52:19.520 --> 00:52:21.410
意味着这些都超出了

00:52:20.630 --> 00:52:25.040
我们要谈论的范围

00:52:21.410 --> 00:52:27.170
今天在这里，但你也可以坚持

00:52:25.040 --> 00:52:29.210
我写的时候坚持要

00:52:27.170 --> 00:52:31.250
保证已被复制

00:52:29.210 --> 00:52:33.950
跨越一或两个或三个或五个或n 

00:52:31.250 --> 00:52:35.300
或者你知道其他一些策略

00:52:33.950 --> 00:52:36.860
达成任何策略

00:52:35.300 --> 00:52:39.260
用于确定您还有多少个其他节点

00:52:36.860 --> 00:52:48.110
可以坚持达到最低要求

00:52:39.260 --> 00:52:51.800
某种复制集好吧，是的

00:52:48.110 --> 00:52:54.110
像这样更好是真正的

00:52:51.800 --> 00:52:58.010
现在TOD真正引人注目的功能

00:52:54.110 --> 00:53:00.440
我想运行一个函数，如果我有

00:52:58.010 --> 00:53:02.630
我可以针对这种数据提取方案

00:53:00.440 --> 00:53:04.610
示例将一堆钥匙插入

00:53:02.630 --> 00:53:06.740
切入群集，然后我可以

00:53:04.610 --> 00:53:08.930
运行访问每个节点的此功能

00:53:06.740 --> 00:53:10.600
在集群中，然后我可以查找

00:53:08.930 --> 00:53:14.180
我目前能找到所有的钥匙

00:53:10.600 --> 00:53:16.460
使用该节点上的当前节点

00:53:14.180 --> 00:53:19.550
该功能正在执行

00:53:16.460 --> 00:53:21.410
节点作为主节点

00:53:19.550 --> 00:53:25.540
最初写此写的内容

00:53:21.410 --> 00:53:25.540
右边还有其他节点

00:53:25.750 --> 00:53:29.510
有具有

00:53:28.280 --> 00:53:31.880
正确的还有复制

00:53:29.510 --> 00:53:33.319
节点，但这是领导节点

00:53:31.880 --> 00:53:34.789
我可以写信给

00:53:33.319 --> 00:53:36.859
所有这些不同的领导者节点和

00:53:34.789 --> 00:53:38.989
我可以运行我可以说的功能

00:53:36.859 --> 00:53:43.069
给定权限的领导节点

00:53:38.989 --> 00:53:46.699
我想处理其中的钥匙

00:53:43.069 --> 00:53:49.849
那个权利，然后我会除草

00:53:46.699 --> 00:53:51.469
在该节点上运行所有CSV文件

00:53:49.849 --> 00:53:53.869
与驻留在其中的键匹配

00:53:51.469 --> 00:53:56.569
该节点，仅此而已

00:53:53.869 --> 00:53:58.519
会被指控你知道我会

00:53:56.569 --> 00:54:00.410
读取我需要读取的任何CSV文件

00:53:58.519 --> 00:54:01.670
在一个节点上，在所有其他节点上

00:54:00.410 --> 00:54:03.680
会读取CSV文件

00:54:01.670 --> 00:54:05.509
驻留在那个节点上，这样

00:54:03.680 --> 00:54:07.190
并行化，我可以调用

00:54:05.509 --> 00:54:09.680
此功能一次来自客户端

00:54:07.190 --> 00:54:13.430
遍布你的工作

00:54:09.680 --> 00:54:14.660
知道群集中的n个节点可能是- 

00:54:13.430 --> 00:54:17.209
可能一千个就可以

00:54:14.660 --> 00:54:19.190
并行可以做任何类似的工作

00:54:17.209 --> 00:54:21.049
这样你就很合乎逻辑

00:54:19.190 --> 00:54:22.519
分布，即使你不是

00:54:21.049 --> 00:54:24.259
即使您不关心

00:54:22.519 --> 00:54:26.839
如果您只想要一个数据分片

00:54:24.259 --> 00:54:28.940
公平的调度程序，这真的是

00:54:26.839 --> 00:54:30.529
有趣的事情，让我们写

00:54:28.940 --> 00:54:33.609
一个简单的功能不是什么都没有

00:54:30.529 --> 00:54:35.839
就像我刚才所说的那样复杂

00:54:33.609 --> 00:54:37.489
明确表达，但有趣的是

00:54:35.839 --> 00:54:39.410
本身还可以，所以我们要做的是

00:54:37.489 --> 00:54:43.099
写一个函数，我们必须创建一个

00:54:39.410 --> 00:54:49.779
该功能的客户端视图还可以

00:54:43.099 --> 00:54:53.029
所以当我说平均温度

00:54:49.779 --> 00:54:56.449
功能还可以

00:54:53.029 --> 00:54:58.009
调用者II不，你可以叫做什么

00:54:56.449 --> 00:54:59.959
您希望它只是一个接口就对了

00:54:58.009 --> 00:55:03.769
我非常非常 Spring 的数据

00:54:59.959 --> 00:55:08.599
要说我想在

00:55:03.769 --> 00:55:12.739
我们没有打电话到的叫temps的地区

00:55:08.599 --> 00:55:14.630
暂时没事，那就太好了

00:55:12.739 --> 00:55:17.869
如果你很快把它洒了

00:55:14.630 --> 00:55:19.130
我显然没有能力，但是你

00:55:17.869 --> 00:55:20.839
其实我不必知道

00:55:19.130 --> 00:55:22.579
不重要不不不

00:55:20.839 --> 00:55:24.829
重要性放在名称上

00:55:22.579 --> 00:55:28.099
接口本身不正确

00:55:24.829 --> 00:55:29.809
但是对于函数的名称我

00:55:28.099 --> 00:55:35.089
认为我们可以做到这一点，我认为我们可以

00:55:29.809 --> 00:55:37.190
说双倍平均温度还可以

00:55:35.089 --> 00:55:38.390
让我们尝试一下，这就是

00:55:37.190 --> 00:55:40.910
功能，我们必须定义

00:55:38.390 --> 00:55:42.739
在客户端起作用，所以实际上

00:55:40.910 --> 00:55:44.900
在欠我们之前，而是在服务器中

00:55:42.739 --> 00:55:46.560
但在我们这样做之前，让我们先注入

00:55:44.900 --> 00:55:50.980
该代码并使其正常工作

00:55:46.560 --> 00:55:51.820
私人最终平均气温

00:55:50.980 --> 00:55:56.320
调用者

00:55:51.820 --> 00:56:04.890
我称它为调用者添加参数

00:55:56.320 --> 00:56:08.910
在这里调用函数我想说点

00:56:04.890 --> 00:56:13.120
平均温度，那应该

00:56:08.910 --> 00:56:14.590
参观每个地区并计算

00:56:13.120 --> 00:56:16.750
所有温度的平均值

00:56:14.590 --> 00:56:18.820
地区和其他地方，然后从

00:56:16.750 --> 00:56:22.870
我要去那里参观

00:56:18.820 --> 00:56:26.530
那里的温度并计算平均值

00:56:22.870 --> 00:56:31.620
所以平均要翻倍，我只说x 

00:56:26.530 --> 00:56:40.480
等于x这是一个恒等函数， 

00:56:31.620 --> 00:56:41.800
平均光泽平均好吧，我们

00:56:40.480 --> 00:56:45.960
写下我可以使用龙目岛

00:56:41.800 --> 00:56:49.620
在这里我什么都不是什么都不懒

00:56:45.960 --> 00:56:55.690
都是说日志点信息集群

00:56:49.620 --> 00:56:58.600
平均，还好我的

00:56:55.690 --> 00:56:59.980
集群平均温度好，所以我们

00:56:58.600 --> 00:57:02.380
现在我们需要编写处理代码

00:56:59.980 --> 00:57:04.000
您可以想象我们的功能是

00:57:02.380 --> 00:57:06.340
会寻找与此相似的东西

00:57:04.000 --> 00:57:07.810
但是我们不讨厌破坏剧情

00:57:06.340 --> 00:57:09.340
你可能我可能已经提取了这个

00:57:07.810 --> 00:57:13.540
变成共享的通用方法

00:57:09.340 --> 00:57:16.330
在客户端和服务器之间，但是你呢

00:57:13.540 --> 00:57:19.180
知道那很酷，我很好，我很好，我

00:57:16.330 --> 00:57:21.310
高兴地离开它，所以让我们现在

00:57:19.180 --> 00:57:24.280
回到我们的服务器

00:57:21.310 --> 00:57:26.260
好吧，在服务器代码中

00:57:24.280 --> 00:57:29.860
首先，我们需要告诉

00:57:26.260 --> 00:57:31.900
关于功能的定位器，所以我们

00:57:29.860 --> 00:57:35.110
通过创建函数来做到这一点

00:57:31.900 --> 00:57:38.760
该功能将放置在

00:57:35.110 --> 00:57:38.760
在服务器中

00:57:40.800 --> 00:57:47.910
好的，我们将实施

00:57:44.590 --> 00:57:52.570
函数将被称为平均值

00:57:47.910 --> 00:57:53.620
例如温度功能

00:57:52.570 --> 00:57:54.760
不必叫它我的意思是

00:57:53.620 --> 00:57:59.580
可以叫你真正想要的

00:57:54.760 --> 00:58:02.880
它只是组件上的Spring 梁

00:57:59.580 --> 00:58:09.610
这将是一个宝石射击功能

00:58:02.880 --> 00:58:11.790
公共无效计算平均值或否

00:58:09.610 --> 00:58:18.490
这是平均温度

00:58:11.790 --> 00:58:22.870
只是这里的方法，我要注入

00:58:18.490 --> 00:58:33.160
区域数据将是

00:58:22.870 --> 00:58:39.940
串到温度好吧

00:58:33.160 --> 00:58:44.950
数据，我需要告诉我的定位器

00:58:39.940 --> 00:58:46.140
所以我会说这是一个

00:58:44.950 --> 00:58:54.430
将不得不进行组件扫描

00:58:46.140 --> 00:58:56.650
看着那里好吧，多余的我

00:58:54.430 --> 00:58:59.590
认为我在这里很多余，但是

00:58:56.650 --> 00:59:02.320
以防万一你肯定不需要

00:58:59.590 --> 00:59:05.080
好，所以我的组件可以

00:59:02.320 --> 00:59:06.790
在那里，我们是否需要同样的东西

00:59:05.080 --> 00:59:10.420
服务器，我们可能需要同样的东西

00:59:06.790 --> 00:59:15.670
在服务器上我不是百分之一百

00:59:10.420 --> 00:59:16.900
当然可以，但我认为我们现在还可以

00:59:15.670 --> 00:59:21.850
让我们继续前进，将其保留

00:59:16.900 --> 00:59:24.370
现在，嗯，应该没关系

00:59:21.850 --> 00:59:28.050
应该很好，让我们尝试一下

00:59:24.370 --> 00:59:31.890
这就是定位器的功能

00:59:28.050 --> 00:59:31.890
好，所以我们知道了

00:59:32.690 --> 00:59:43.520
继续前进，然后重新启动

00:59:37.340 --> 00:59:45.560
定位器本身，实际上你知道

00:59:43.520 --> 00:59:49.850
在我这样做之前，我应该先实现

00:59:45.560 --> 00:59:57.200
所以我说数据点值点流

00:59:49.850 --> 00:59:58.550
点图温度获取温度和

00:59:57.200 --> 01:00:01.700
我会说我想得到双打

00:59:58.550 --> 01:00:03.380
此所有数据的平均值

01:00:01.700 --> 01:00:05.630
当前节点中的当前区域

01:00:03.380 --> 01:00:07.850
我正在处理，所以我会得到所有

01:00:05.630 --> 01:00:09.410
我要从那里收集数据

01:00:07.850 --> 01:00:14.600
所以实际上我不知道不要

01:00:09.410 --> 01:00:20.440
说点地图文档将平均值收集到

01:00:14.600 --> 01:00:26.450
双XX身份与以前相同

01:00:20.440 --> 01:00:33.550
一般还好，我们在这里很傻

01:00:26.450 --> 01:00:33.550
所以log4j，我要说日志有信息

01:00:34.930 --> 01:00:39.850
平均到达

01:00:43.849 --> 01:00:52.039
一般还可以，然后我们就

01:00:46.039 --> 01:00:55.970
返回结果转弯平均值我想我

01:00:52.039 --> 01:00:58.130
需要有意义的返回类型

01:00:55.970 --> 01:01:04.089
关闭并且您不想返回类型

01:00:58.130 --> 01:01:08.890
我想我要加倍

01:01:04.089 --> 01:01:08.890
那两倍将是平均值

01:01:16.539 --> 01:01:23.930
已经可以了，看起来不错

01:01:19.099 --> 01:01:25.099
我想我们可以现在就把它留在那里

01:01:23.930 --> 01:01:25.970
这很简单，让我们

01:01:25.099 --> 01:01:28.130
离开那边，我们得到了

01:01:25.970 --> 01:01:29.720
小日志声明，以确认我们

01:01:28.130 --> 01:01:32.690
拜访了这个节点，所以我们实际上可以看到

01:01:29.720 --> 01:01:34.880
工作随心所欲

01:01:32.690 --> 01:01:37.099
所以我们从定位器开始

01:01:34.880 --> 01:01:45.609
否则我们首先需要一个定位器

01:01:37.099 --> 01:01:45.609
哦，我又做了一次，不是吗

01:01:47.820 --> 01:01:53.690
改名为Ever Ridge 

01:02:01.369 --> 01:02:08.650
好的，那很好，然后我们的服务器

01:02:06.140 --> 01:02:08.650
开始那个

01:02:22.880 --> 01:02:29.819
好吧，让我们回到G鱼

01:02:27.059 --> 01:02:35.029
确认一切如我们所愿

01:02:29.819 --> 01:02:37.640
我会默认连接好列表

01:02:35.029 --> 01:02:39.809
职能

01:02:37.640 --> 01:02:41.910
这是我们的平均温度函数

01:02:39.809 --> 01:02:56.099
哦，那是平均水平的两倍

01:02:41.910 --> 01:03:02.239
温度功能删除删除否

01:02:56.099 --> 01:03:08.839
地区临时工不是第一位-我

01:03:02.239 --> 01:03:08.839
就是说我们去那里了

01:03:09.289 --> 01:03:16.579
嘿，我的意思是

01:03:13.140 --> 01:03:18.959
应该很好我不知道我没有

01:03:16.579 --> 01:03:20.459
我们会没事的，让我们看看

01:03:18.959 --> 01:03:22.380
发生的就是这样，你知道我们可以

01:03:20.459 --> 01:03:23.729
实际上使它更简单一点

01:03:22.380 --> 01:03:25.829
只是为了让我们知道我们在

01:03:23.729 --> 01:03:30.779
在同一页面上，它将是应用程序

01:03:25.829 --> 01:03:33.119
叫做平均值，我们将称之为

01:03:30.779 --> 01:03:34.529
平均还可以，非常无聊，但是

01:03:33.119 --> 01:03:39.469
我们知道发生的方式，所以让我

01:03:34.529 --> 01:03:42.469
重写它，当我们开始

01:03:39.469 --> 01:03:42.469
客户

01:03:52.480 --> 01:03:55.839
我们开始

01:04:06.110 --> 01:04:12.260
好的，所以我们得到了平均值

01:04:07.970 --> 01:04:16.690
那是客户端应用程序返回

01:04:12.260 --> 01:04:16.690
这个或运行这个

01:04:24.530 --> 01:04:29.110
好的呐喊

01:04:38.890 --> 01:04:46.590
右功能未注册

01:04:41.040 --> 01:04:50.970
公平地说，让我们回到这里， 

01:04:46.590 --> 01:04:50.970
重新启动定位器

01:05:06.460 --> 01:05:10.109
好的服务器

01:05:19.930 --> 01:05:27.500
好吧，现在，如果我们去列表，我们是

01:05:23.600 --> 01:05:28.580
要连接此功能，有

01:05:27.500 --> 01:05:29.780
我们的平均功能

01:05:28.580 --> 01:05:31.700
哦，编织两次就可以了

01:05:29.780 --> 01:05:34.720
这样做效果还好吗，所以

01:05:31.700 --> 01:05:40.430
然后我们回到客户那里

01:05:34.720 --> 01:05:41.510
客户应用程序，希望这

01:05:40.430 --> 01:05:43.700
可以工作，我不确定要回来

01:05:41.510 --> 01:05:46.240
来自函数调用程序的对象，或者

01:05:43.700 --> 01:05:47.770
可以像这样沮丧

01:05:46.240 --> 01:05:53.750
我们拭目以待

01:05:47.770 --> 01:05:55.070
最坏的情况似乎还可以

01:05:53.750 --> 01:05:58.340
我们得到的结果是均匀的

01:05:55.070 --> 01:06:00.380
困扰客户应用程序集群

01:05:58.340 --> 01:06:03.440
平均看那一点四点九点

01:06:00.380 --> 01:06:05.120
那就是调用读取

01:06:03.440 --> 01:06:07.030
计入了计算

01:06:05.120 --> 01:06:09.140
我们可以通过

01:06:07.030 --> 01:06:11.090
到达平均等等等等

01:06:09.140 --> 01:06:13.160
这个服务器节点，如果我们有

01:06:11.090 --> 01:06:16.250
我们将看到多个节点打印出来

01:06:13.160 --> 01:06:17.630
每一刻都好

01:06:16.250 --> 01:06:19.430
朋友，我们才刚刚开始

01:06:17.630 --> 01:06:21.650
希望你能体会到

01:06:19.430 --> 01:06:23.030
我们没有的一些机会

01:06:21.650 --> 01:06:24.500
甚至看我们没有的缓存管理器

01:06:23.030 --> 01:06:27.080
甚至看基本的键值存储

01:06:24.500 --> 01:06:28.940
我觉得就像把宝石火geode当作

01:06:27.080 --> 01:06:30.200
只是一个常规的键值存储它是一个

01:06:28.940 --> 01:06:33.200
误入歧途，您真的错过了

01:06:30.200 --> 01:06:35.270
在一些最高的

01:06:33.200 --> 01:06:37.010
速度之一是

01:06:35.270 --> 01:06:39.530
世界如此希望你已经

01:06:37.010 --> 01:06:42.050
旅途中有些事谢谢

01:06:39.530 --> 01:06:44.710
这么多的观看，我们将一如既往

01:06:42.050 --> 01:06:44.710
下次见

01:06:50.599 --> 01:06:52.660
您

