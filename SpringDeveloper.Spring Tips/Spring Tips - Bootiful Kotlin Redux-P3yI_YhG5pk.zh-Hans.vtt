WEBVTT
Kind: captions
Language: zh-Hans

00:00:24.690 --> 00:00:29.170
嗨， Spring 粉丝们欢迎来到另一个

00:00:27.130 --> 00:00:30.580
这次的 spring 技巧 分期付款

00:00:29.170 --> 00:00:32.169
我们将重温Kotlin

00:00:30.580 --> 00:00:33.610
较早的编程语言

00:00:32.169 --> 00:00:35.260
我们看了一个电话的视频及其

00:00:33.610 --> 00:00:37.420
与Spring基本新生

00:00:35.260 --> 00:00:38.470
生态系统中的社区，我只是

00:00:37.420 --> 00:00:39.700
想重新访问它，因为很多

00:00:38.470 --> 00:00:41.170
已经取得进展，我想

00:00:39.700 --> 00:00:42.670
从今天开始，很简单

00:00:41.170 --> 00:00:45.070
牛油Spring 的应用和

00:00:42.670 --> 00:00:46.930
然后朝着更加Kotlin前进

00:00:45.070 --> 00:00:48.010
原生的构建方法

00:00:46.930 --> 00:00:50.650
 Spring 申请，所以我要开始

00:00:48.010 --> 00:00:54.040
基本的JBC排序

00:00:50.650 --> 00:00:55.239
我将使用H2的Web应用程序

00:00:54.040 --> 00:00:57.430
这是一个内存嵌入式数据库

00:00:55.239 --> 00:00:58.840
我们使用JDBC支持我们使用spring 

00:00:57.430 --> 00:01:02.649
网络支持，我们将使用

00:00:58.840 --> 00:01:03.850
常见的自然和 spring boot 2005 

00:01:02.649 --> 00:01:05.350
当我点击“生成”时，我会给我们一个

00:01:03.850 --> 00:01:08.740
新项目，我要打开这个

00:01:05.350 --> 00:01:09.640
我的IDE中的应用程序

00:01:08.740 --> 00:01:11.680
我做什么都不重要

00:01:09.640 --> 00:01:15.450
当然使用，但这是在治疗

00:01:11.680 --> 00:01:15.450
通用本体是一个不错的选择

00:01:20.920 --> 00:01:24.290
现在我有了一个新的面包和黄油

00:01:23.060 --> 00:01:26.000
应用程序，所以我要做的第一件事

00:01:24.290 --> 00:01:28.340
为此，我知道您知道管理我的

00:01:26.000 --> 00:01:29.600
数据，我将使用

00:01:28.340 --> 00:01:31.610
对classpath的依赖

00:01:29.600 --> 00:01:34.370
我有我的年龄来支持我有我的

00:01:31.610 --> 00:01:35.840
 JDBC支持我也有能力

00:01:34.370 --> 00:01:38.990
标准库和反映

00:01:35.840 --> 00:01:41.180
支持那里，我有来历

00:01:38.990 --> 00:01:42.920
 Cotton Maven插件，我有一个

00:01:41.180 --> 00:01:45.050
 Maven插件中的编译器插件

00:01:42.920 --> 00:01:50.360
本身和编译器插件用于

00:01:45.050 --> 00:01:52.250
 Spring ，您会看到我们有需要

00:01:50.360 --> 00:01:54.220
 Spring 来扩展您的课程

00:01:52.250 --> 00:01:57.410
让他们思考方式

00:01:54.220 --> 00:02:00.740
这些东西大部分都受支持了

00:01:57.410 --> 00:02:02.810
 Spring 提供了代理，然后扩展

00:02:00.740 --> 00:02:05.300
您的类最终在运行时

00:02:02.810 --> 00:02:07.130
你利用了你的事实

00:02:05.300 --> 00:02:08.660
利用的性质

00:02:07.130 --> 00:02:12.200
我可以的李斯科夫替代原理

00:02:08.660 --> 00:02:13.970
用a类型的任何对象代替a 

00:02:12.200 --> 00:02:15.709
权利的子类即收益

00:02:13.970 --> 00:02:17.900
这就是那的基础

00:02:15.709 --> 00:02:19.700
我可以描述依赖注入

00:02:17.900 --> 00:02:20.959
根据我需要的类型进行编码

00:02:19.700 --> 00:02:23.030
只要我得到那种类型的东西

00:02:20.959 --> 00:02:25.630
专门针对这种类型，它将看起来如此

00:02:23.030 --> 00:02:27.440
我可以换掉或者至少换一个子类

00:02:25.630 --> 00:02:29.360
特定类型，然后提供

00:02:27.440 --> 00:02:31.190
相反，我得到了增强

00:02:29.360 --> 00:02:33.110
无需更改我的行为

00:02:31.190 --> 00:02:35.180
取决于该类型的代码

00:02:33.110 --> 00:02:37.820
有效，因为我们可以扩展您的课程

00:02:35.180 --> 00:02:41.060
默认情况下，在Kotlin中，您必须指定

00:02:37.820 --> 00:02:42.980
开放给所有类的子类

00:02:41.060 --> 00:02:45.709
如果您保留原样，则默认

00:02:42.980 --> 00:02:48.769
相当于说最终

00:02:45.709 --> 00:02:50.840
 Java中的GBC类应用程序等等

00:02:48.769 --> 00:02:53.239
我们在Java中，您必须选择加入

00:02:50.840 --> 00:02:55.220
在Kotlin锁定课程

00:02:53.239 --> 00:02:56.269
必须选择退出，所以你想成为

00:02:55.220 --> 00:02:59.299
能够使它尽可能容易

00:02:56.269 --> 00:03:00.650
因为 Spring 需要你顶

00:02:59.299 --> 00:03:02.330
与Spring 配合使用的所有组件

00:03:00.650 --> 00:03:04.519
所以这就是所有陷入Maven的原因

00:03:02.330 --> 00:03:06.049
打开插件会说你什么时候

00:03:04.519 --> 00:03:08.269
看到像添加的Spring 注释

00:03:06.049 --> 00:03:10.730
组件或配置

00:03:08.269 --> 00:03:12.080
用于描述的注释

00:03:10.730 --> 00:03:12.440
这是 Spring 的一部分

00:03:12.080 --> 00:03:14.600
管理

00:03:12.440 --> 00:03:16.880
每当他们只要这种情况

00:03:14.600 --> 00:03:18.320
见面，然后上课

00:03:16.880 --> 00:03:20.360
默认是这个插件的作用

00:03:18.320 --> 00:03:22.519
以及编译器插件，所以我们

00:03:20.360 --> 00:03:23.600
现在有了这个，我们可以建立一个新的

00:03:22.519 --> 00:03:24.950
我们将要构建的应用程序

00:03:23.600 --> 00:03:26.299
这样管理数据的应用程序

00:03:24.950 --> 00:03:28.120
当然，我们将创建一个名为

00:03:26.299 --> 00:03:32.630
谁的客户

00:03:28.120 --> 00:03:37.840
 var var name will 

00:03:32.630 --> 00:03:41.000
字符串，VAR ID将为no 

00:03:37.840 --> 00:03:43.390
知道很久，所以我要两个

00:03:41.000 --> 00:03:46.700
此处的字段可能为空Val 

00:03:43.390 --> 00:03:48.710
它是只读的，一次不能写

00:03:46.700 --> 00:03:49.730
你已经建造好了，这就是这些

00:03:48.710 --> 00:03:52.190
是构造函数，这是

00:03:49.730 --> 00:03:54.470
当然，构造函数原型

00:03:52.190 --> 00:03:56.780
创建一个您知道已读的可变项， 

00:03:54.470 --> 00:03:57.770
写出具有延展性的财产

00:03:56.780 --> 00:04:00.050
问号是什么，那是

00:03:57.770 --> 00:04:01.640
什么以及该默认值将为null 

00:04:00.050 --> 00:04:03.560
这就是等于null的意思

00:04:01.640 --> 00:04:04.790
你会为此付出很多

00:04:03.560 --> 00:04:06.080
看看这个，我的意思是我们有一个

00:04:04.790 --> 00:04:07.700
带有吸气剂和吸气剂的整个对象

00:04:06.080 --> 00:04:09.830
和等于和哈希码和构造函数

00:04:07.700 --> 00:04:11.270
并且我们已经指定了

00:04:09.830 --> 00:04:12.860
事物是可读且可读或可写的

00:04:11.270 --> 00:04:14.420
我们可以做各种各样的事情

00:04:12.860 --> 00:04:16.280
那基本的定义，那就是

00:04:14.420 --> 00:04:18.440
好，所以我们现在可以使用它来与

00:04:16.280 --> 00:04:20.660
数据库，所以让我们创建一个服务

00:04:18.440 --> 00:04:22.040
但实际上我们今天在我们的谈话中

00:04:20.660 --> 00:04:25.010
今天聚会的时间，我们要去

00:04:22.040 --> 00:04:26.750
看两个不同的服务

00:04:25.010 --> 00:04:28.910
它提供相同的接口或

00:04:26.750 --> 00:04:29.630
实现相同的接口，所以我们

00:04:28.910 --> 00:04:33.190
要做到这一点，我们实际上

00:04:29.630 --> 00:04:36.980
首先提供或定义一个接口

00:04:33.190 --> 00:04:38.930
方法将返回所有

00:04:36.980 --> 00:04:43.480
记录是否收集所有客户

00:04:38.930 --> 00:04:48.380
第二个将通过ID ID说

00:04:43.480 --> 00:04:50.360
长期的客户问号，所以我们

00:04:48.380 --> 00:04:52.010
会说通过ID查找记录

00:04:50.360 --> 00:04:53.180
存在，可能不存在，如果存在

00:04:52.010 --> 00:04:54.680
不存在，如果存在则返回null 

00:04:53.180 --> 00:04:56.030
存在返回实际的东西，我是

00:04:54.680 --> 00:04:58.220
将有另一种插入方法

00:04:56.030 --> 00:05:00.170
客户类型的对象进入

00:04:58.220 --> 00:05:01.490
数据库，所以我们有客户服务

00:05:00.170 --> 00:05:03.530
界面，让我们提供第一个

00:05:01.490 --> 00:05:05.660
实施，这将是

00:05:03.530 --> 00:05:07.990
基于JDBC模板的客户

00:05:05.660 --> 00:05:12.410
服务类型正确，所以我要说

00:05:07.990 --> 00:05:14.680
私人犯规JDBC模板以及何时

00:05:12.410 --> 00:05:20.660
执行客户服务合同

00:05:14.680 --> 00:05:25.090
好吧，让我们看看这里，我们有

00:05:20.660 --> 00:05:27.700
在服务时覆盖这些方法

00:05:25.090 --> 00:05:30.580
交易性的

00:05:27.700 --> 00:05:34.180
我们必须返回所有记录，以便

00:05:30.580 --> 00:05:39.250
这，但JBC template.dot查询选择

00:05:34.180 --> 00:05:40.990
全部来自客户，我们需要

00:05:39.250 --> 00:05:42.850
提供路线图标准

00:05:40.990 --> 00:05:45.100
签名表明我们需要

00:05:42.850 --> 00:05:47.230
某种功能接口

00:05:45.100 --> 00:05:48.310
最后一个参数，这非常有效

00:05:47.230 --> 00:05:51.130
与我们正在尝试做的很好

00:05:48.310 --> 00:05:52.690
 lembeh的共同点，而是你看看我们

00:05:51.130 --> 00:05:54.940
需要一个lambda作为最后一个参数

00:05:52.690 --> 00:05:56.920
可以指定在调用之外

00:05:54.940 --> 00:05:58.900
这就是你知道的衣服

00:05:56.920 --> 00:06:00.880
就在这里是调用的结尾

00:05:58.900 --> 00:06:02.590
在这里，我开始这个奇怪的事情

00:06:00.880 --> 00:06:04.570
块，但这实际上是一个lambda， 

00:06:02.590 --> 00:06:06.400
这是规则映射器类型的lambda 

00:06:04.570 --> 00:06:09.250
它将执行相同的合同

00:06:06.400 --> 00:06:11.650
所以我会说我要去地图

00:06:09.250 --> 00:06:13.720
结果集是这个和

00:06:11.650 --> 00:06:16.180
 offset是整数

00:06:13.720 --> 00:06:19.690
结果集，我将其映射到

00:06:16.180 --> 00:06:21.820
客户对象，您知道要拆箱

00:06:19.690 --> 00:06:23.170
所有结果中的一些值

00:06:21.820 --> 00:06:24.700
对的那是相当的

00:06:23.170 --> 00:06:27.220
直截了当，然后还不错

00:06:24.700 --> 00:06:28.930
让我们尝试一下

00:06:27.220 --> 00:06:33.010
谓词的参与程度略高

00:06:28.930 --> 00:06:36.610
在这里等于，在这里我们要看

00:06:33.010 --> 00:06:41.710
对于特定的记录，我们不能只是

00:06:36.610 --> 00:06:43.660
说我们需要一个，我们需要指定

00:06:41.710 --> 00:06:45.010
一种权利，所以我们需要提供一个

00:06:43.660 --> 00:06:47.650
参数在这里，所以我要传递

00:06:45.010 --> 00:06:49.780
这个ID，当然这不是

00:06:47.650 --> 00:06:52.150
编译我必须告诉他们你看到了

00:06:49.780 --> 00:06:54.370
 IntelliJ的建议说我们

00:06:52.150 --> 00:06:56.740
有一个选择给你，因为

00:06:54.370 --> 00:07:00.490
如果您查看查询的默认值

00:06:56.740 --> 00:07:02.830
 GL人员的对象方法

00:07:00.490 --> 00:07:04.270
支持它给你一行字符串

00:07:02.830 --> 00:07:05.650
映射器，然后是一个非常阁楼的数组

00:07:04.270 --> 00:07:07.330
我不想提供论点

00:07:05.650 --> 00:07:09.190
争论不休，否则我会输

00:07:07.330 --> 00:07:10.630
在我可以方便的地方

00:07:09.190 --> 00:07:12.280
提供lambda作为最后一个参数

00:07:10.630 --> 00:07:14.200
并将其写在

00:07:12.280 --> 00:07:15.700
调用，所以我想要

00:07:14.200 --> 00:07:16.960
首先要论证，然后我要

00:07:15.700 --> 00:07:18.820
行映射器，所以我们称之为

00:07:16.960 --> 00:07:20.350
扩展在这里做到了

00:07:18.820 --> 00:07:22.930
说查询对象等于字符串

00:07:20.350 --> 00:07:25.420
在carlin和

00:07:22.930 --> 00:07:27.100
那么lambda定义就是这个

00:07:25.420 --> 00:07:28.840
说我在乎结果集和

00:07:27.100 --> 00:07:30.670
整数，我要返回T 

00:07:28.840 --> 00:07:31.720
并没有说我需要一个行映射器

00:07:30.670 --> 00:07:33.510
对，我们不必做一个功能

00:07:31.720 --> 00:07:36.610
界面，我们只是提供一个实际的

00:07:33.510 --> 00:07:38.260
诚实至善的Lambda，然后

00:07:36.610 --> 00:07:39.490
映射到查询对象

00:07:38.260 --> 00:07:41.380
以行映射器

00:07:39.490 --> 00:07:45.010
你知道覆盖结果集

00:07:41.380 --> 00:07:46.630
等等等等等等，所以我们

00:07:45.010 --> 00:07:48.280
是免费的，这是附加电话信息

00:07:46.630 --> 00:07:49.450
在Spring Framework中，五个您可以

00:07:48.280 --> 00:07:51.550
看到那是在课堂上，但已经

00:07:49.450 --> 00:07:53.680
它在Spring Framework或极端形式上

00:07:51.550 --> 00:07:54.700
如果使用Java，GBC核心将永远不会

00:07:53.680 --> 00:07:56.260
看到它，你永远不会知道它，你

00:07:54.700 --> 00:07:58.750
不在乎，但如果您在Kotlin那

00:07:56.260 --> 00:08:01.690
代码会为您工作

00:07:58.750 --> 00:08:03.760
所以最后一位客户我们必须插入

00:08:01.690 --> 00:08:06.400
一些数据，所以我们会说这些东西

00:08:03.760 --> 00:08:12.640
 Jaime执行插入的模板

00:08:06.400 --> 00:08:15.580
进入客户名称值问号

00:08:12.640 --> 00:08:17.320
而这里可能是lambda和

00:08:15.580 --> 00:08:19.360
默认为lambda将是

00:08:17.320 --> 00:08:21.760
我可以指定一份准备好的陈述

00:08:19.360 --> 00:08:23.050
如果我想，但我也可以飞

00:08:21.760 --> 00:08:25.390
抓住他们给我一个隐含的

00:08:23.050 --> 00:08:27.550
它是准备好的参数

00:08:25.390 --> 00:08:30.280
声明对不起，以为设置了字符串

00:08:27.550 --> 00:08:34.210
一个将等于客户点

00:08:30.280 --> 00:08:40.000
名称，它不执行，我们在

00:08:34.210 --> 00:08:41.950
所以我重写了insert方法

00:08:40.000 --> 00:08:43.720
在那里，我提供了定义，我是

00:08:41.950 --> 00:08:45.280
使用JDBC模板将数据写入

00:08:43.720 --> 00:08:47.200
数据库当然是问题

00:08:45.280 --> 00:08:48.820
什么数据库是什么架构表

00:08:47.200 --> 00:08:51.430
我们可以利用一种机制

00:08:48.820 --> 00:08:54.520
这里和 Spring 本身甚至没有

00:08:51.430 --> 00:08:57.600
我可以说架构

00:08:54.520 --> 00:08:59.680
那是相等的，如果我说插入

00:08:57.600 --> 00:09:02.610
客户，对不起，我想创建

00:08:59.680 --> 00:09:06.190
表并说创建表客户

00:09:02.610 --> 00:09:07.510
我要提供一个分号

00:09:06.190 --> 00:09:09.790
你唯一要见我的分号

00:09:07.510 --> 00:09:13.210
为此安装输入

00:09:09.790 --> 00:09:16.390
将会有一个ID big int自动递增

00:09:13.210 --> 00:09:19.660
主键和一个名称var car两个5 

00:09:16.390 --> 00:09:22.720
五个不为零，好吧，那是我的

00:09:19.660 --> 00:09:24.010
 DDL上的方案和Spring 将运行

00:09:22.720 --> 00:09:25.660
当应用程序启动时

00:09:24.010 --> 00:09:26.740
这将起作用，所以现在让我们继续

00:09:25.660 --> 00:09:28.000
并锻炼它会创建一个

00:09:26.740 --> 00:09:30.310
实现我们正在创建一个对象

00:09:28.000 --> 00:09:32.230
实际上行使服务

00:09:30.310 --> 00:09:33.520
它将会获得应用程序的赢家，所以

00:09:32.230 --> 00:09:36.640
我可以做我通常会做的事

00:09:33.520 --> 00:09:40.540
只能说你知道数据初始化器

00:09:36.640 --> 00:09:43.600
并覆盖应用程序运行程序和

00:09:40.540 --> 00:09:46.840
在这里注入此私人Val客户

00:09:43.600 --> 00:09:49.180
服务，并使其定期旋转

00:09:46.840 --> 00:09:50.920
组件，所有这些都很好，我的意思是

00:09:49.180 --> 00:09:52.900
那肯定会工作，但是有

00:09:50.920 --> 00:09:56.040
实际上是科林式的

00:09:52.900 --> 00:09:56.040
我们可以使用的正确方法

00:09:56.100 --> 00:10:01.300
功能光束配准正确

00:09:58.900 --> 00:10:03.040
而不是使用Java config或

00:10:01.300 --> 00:10:10.120
组件扫描在这里，我们说 Spring 

00:10:03.040 --> 00:10:13.930
应用程序构建器点初始化器

00:10:10.120 --> 00:10:14.830
 bean提供了bean的定义和

00:10:13.930 --> 00:10:16.510
我们将回到那一秒钟

00:10:14.830 --> 00:10:19.030
就像我们想在什么时候使用的DSL 

00:10:16.510 --> 00:10:22.150
我将在此指定要使用的类

00:10:19.030 --> 00:10:24.670
案例GV应用程序类Java，我们

00:10:22.150 --> 00:10:28.480
可以告诉它运行通过

00:10:24.670 --> 00:10:31.210
参数，所以这是

00:10:28.480 --> 00:10:34.120
要提供的参数和DSL 

00:10:31.210 --> 00:10:36.430
让我们只定义使用这个方法

00:10:34.120 --> 00:10:38.920
不错的DSL，它将与

00:10:36.430 --> 00:10:40.360
现在注册的应用程序上下文

00:10:38.920 --> 00:10:41.410
不，有一个类似的东西

00:10:40.360 --> 00:10:43.480
有功能可以做功能

00:10:41.410 --> 00:10:45.280
也意味着Java中的定义，但

00:10:43.480 --> 00:10:48.190
 DSL中的此呼叫是常见的

00:10:45.280 --> 00:10:49.960
正确，我认为它读得更多

00:10:48.190 --> 00:10:51.760
很好，所以在这里我们要创建一个光束

00:10:49.960 --> 00:10:53.110
类型的应用程序运行程序和

00:10:51.760 --> 00:10:56.260
应用程序运行程序，我们需要一个指向

00:10:53.110 --> 00:10:58.060
客户服务，所以通常我们会

00:10:56.260 --> 00:11:00.070
要求 Spring 给我们注入 Bean type 

00:10:58.060 --> 00:11:02.260
提供者方法在这里，我们说给我一个

00:11:00.070 --> 00:11:04.060
引用它，您可以通过

00:11:02.260 --> 00:11:06.460
通过致电裁判索取该裁判

00:11:04.060 --> 00:11:07.900
方法此ref方法不需要

00:11:06.460 --> 00:11:08.920
类字面量正确，请记住

00:11:07.900 --> 00:11:10.300
最终要做的是

00:11:08.920 --> 00:11:12.220
转到应用程序上下文并

00:11:10.300 --> 00:11:14.020
说好好给我这种 bean 

00:11:12.220 --> 00:11:16.900
这种类型只是你知道我们没有

00:11:14.020 --> 00:11:20.710
一类小毛发，但完整

00:11:16.900 --> 00:11:23.050
不错的功能和phi phi泛型

00:11:20.710 --> 00:11:24.910
签名是关于

00:11:23.050 --> 00:11:29.200
内联方法，所以如果你看这个

00:11:24.910 --> 00:11:31.180
说，如果我愿意，那么内联趣味雷

00:11:29.200 --> 00:11:33.820
返回T，所以这具有

00:11:31.180 --> 00:11:35.560
基本捕获通用类型

00:11:33.820 --> 00:11:37.450
在这里签名并说我可以

00:11:35.560 --> 00:11:39.430
将此作为类文字TD I谈论

00:11:37.450 --> 00:11:41.490
我现在不能上Java 

00:11:39.430 --> 00:11:44.440
能够说基本的T 

00:11:41.490 --> 00:11:45.100
这是可能的，因为当它

00:11:44.440 --> 00:11:47.020
内联说

00:11:45.100 --> 00:11:49.330
这意味着该功能具有

00:11:47.020 --> 00:11:51.460
复制并粘贴到通话中

00:11:49.330 --> 00:11:53.230
网站，如果您愿意，这是一个宏

00:11:51.460 --> 00:11:55.390
没有堆栈，实际上只是

00:11:53.230 --> 00:11:56.830
复制并粘贴该代码，并在

00:11:55.390 --> 00:11:59.380
你打电话的地方，它是

00:11:56.830 --> 00:12:01.930
能够按需捕获论点

00:11:59.380 --> 00:12:03.010
那是因为美浓

00:12:01.930 --> 00:12:05.620
你没有绕过它，只是

00:12:03.010 --> 00:12:06.730
编织在那里可以捕捉

00:12:05.620 --> 00:12:08.320
并将其保留在隐式

00:12:06.730 --> 00:12:09.580
你知道的变量

00:12:08.320 --> 00:12:12.220
从您的代码中，您不必担心

00:12:09.580 --> 00:12:13.900
这不是真正的修正，而是为了我们

00:12:12.220 --> 00:12:16.390
目的是正确的，这是这个

00:12:13.900 --> 00:12:18.130
此ref方法在运行时或具有

00:12:16.390 --> 00:12:18.790
指向您使用过的类型的指针

00:12:18.130 --> 00:12:20.710
这里

00:12:18.790 --> 00:12:21.790
然后我们可以用它来写一些

00:12:20.710 --> 00:12:30.120
数据存储到数据库中，所以让我们这样做

00:12:21.790 --> 00:12:34.660
让我们来看看Tammy Mario Andrew 

00:12:30.120 --> 00:12:36.610
和科妮莉亚，我们还好，所以

00:12:34.660 --> 00:12:39.160
就是这样，我要去参观每个

00:12:36.610 --> 00:12:41.110
我要映射每个我想的一个

00:12:39.160 --> 00:12:44.230
所以我们说将每个人映射到一个客户

00:12:41.110 --> 00:12:46.510
其名字等于它然后赢

00:12:44.230 --> 00:12:49.540
我们对于每个人都会说

00:12:46.510 --> 00:12:54.550
名字a，所以我们说客户服务

00:12:49.540 --> 00:12:56.050
点插入好吧，这是我们的

00:12:54.550 --> 00:13:00.370
记录，我想说客户

00:12:56.050 --> 00:13:03.880
每个服务点都已完成并打印

00:13:00.370 --> 00:13:09.030
出来的结果在这里我们还可以，所以我

00:13:03.880 --> 00:13:09.030
将运行，让我们看看我们得到了什么

00:13:17.910 --> 00:13:24.000
您可以看到编译器告诉我们

00:13:21.420 --> 00:13:25.650
在某些情况下，这些AI参数

00:13:24.000 --> 00:13:27.060
从未使用过，可以重命名

00:13:25.650 --> 00:13:29.700
只是强调表示

00:13:27.060 --> 00:13:31.200
尽管我们需要满足该参数

00:13:29.700 --> 00:13:33.180
为的构造函数

00:13:31.200 --> 00:13:34.560
界面，它们是无用的，我们不需要

00:13:33.180 --> 00:13:36.300
他们不用担心他们不要不要

00:13:34.560 --> 00:13:38.280
浪费认知努力认知努力

00:13:36.300 --> 00:13:40.770
试图感觉他们所做的一切都很好

00:13:38.280 --> 00:13:42.660
在数据库上有结果

00:13:40.770 --> 00:13:45.060
似乎正常工作的控制台似乎

00:13:42.660 --> 00:13:46.890
已经工作了，你知道那不是

00:13:45.060 --> 00:13:49.560
令人惊讶的是，这是一个非常简单的代码

00:13:46.890 --> 00:13:52.170
我们可以很容易地猜测

00:13:49.560 --> 00:13:53.460
如果我们要查询什么

00:13:52.170 --> 00:13:56.070
有一些更复杂的东西

00:13:53.460 --> 00:14:00.660
可能想做一些使

00:13:56.070 --> 00:14:03.420
获得正确结果更容易键入

00:14:00.660 --> 00:14:04.800
安全在这里可能非常有价值

00:14:03.420 --> 00:14:06.780
我们可以使用第三方库

00:14:04.800 --> 00:14:10.290
 JetBrains的公共库

00:14:06.780 --> 00:14:12.180
冒充科林的伪装者称其为

00:14:10.290 --> 00:14:13.620
一个非常有效的规范框架

00:14:12.180 --> 00:14:14.390
很好地与 Spring ，所以让我们做到这一点

00:14:13.620 --> 00:14:18.330
代替

00:14:14.390 --> 00:14:22.310
好用暴露，我将复制并粘贴

00:14:18.330 --> 00:14:26.220
这，我们使用 Spring 交易， 

00:14:22.310 --> 00:14:28.500
暴露需要一个很好的让我们先评论

00:14:26.220 --> 00:14:30.060
这个出来并暴露出来，以做到其

00:14:28.500 --> 00:14:32.100
工作它需要模式，我们已经有一个

00:14:30.060 --> 00:14:36.330
模式文件，但让我们将其重命名为

00:14:32.100 --> 00:14:39.270
 schema.org好的，然后在架构中

00:14:36.330 --> 00:14:41.610
定义或由我们提供

00:14:39.270 --> 00:14:46.230
模式定义，我们必须提供

00:14:41.610 --> 00:14:49.290
现在扩展表的对象客户

00:14:46.230 --> 00:14:51.300
在Kotlin中的这种语法非常

00:14:49.290 --> 00:14:52.770
很难有静态字段或方法

00:14:51.300 --> 00:14:54.960
一个类，您必须创建一个单独的类

00:14:52.770 --> 00:14:56.550
反对一个单身的对象，你可以

00:14:54.960 --> 00:14:58.680
在那里存储东西，所以这是

00:14:56.550 --> 00:15:00.810
独立的，这是一个独立的结构

00:14:58.680 --> 00:15:01.890
一个类，它是一个具有

00:15:00.810 --> 00:15:04.020
单一功能

00:15:01.890 --> 00:15:06.570
命名空间两件事就像静态方法

00:15:04.020 --> 00:15:07.740
在Java中，在这里我们将定义我们的

00:15:06.570 --> 00:15:09.720
细节，如果我们要说有

00:15:07.740 --> 00:15:12.690
将是一个称为ID的字段

00:15:09.720 --> 00:15:13.980
长字段称为ID，它将是自动的

00:15:12.690 --> 00:15:16.290
递增，它将是主要的

00:15:13.980 --> 00:15:20.010
关键是我们要有一个命名字段

00:15:16.290 --> 00:15:22.140
将会是var的汽车名称，仅此而已

00:15:20.010 --> 00:15:26.340
那就是我们的定义那就是我们的DDL 

00:15:22.140 --> 00:15:28.340
我想创建一个暴露的客户

00:15:26.340 --> 00:15:31.950
服务

00:15:28.340 --> 00:15:37.760
这将实现客户

00:15:31.950 --> 00:15:44.490
服务合同没事

00:15:37.760 --> 00:15:46.710
这很好，现在是

00:15:44.490 --> 00:15:49.710
像以前一样的Spring 梁

00:15:46.710 --> 00:15:51.750
像以前和之前一样进行广告交易

00:15:49.710 --> 00:15:53.610
为了让我们创建该DDL，我们需要

00:15:51.750 --> 00:15:55.170
有一个生命周期回电，我们

00:15:53.610 --> 00:15:56.940
要告诉 Spring 叫这个

00:15:55.170 --> 00:15:58.740
应用程序启动时的方法

00:15:56.940 --> 00:16:02.820
在那里，我们将调用架构实用程序

00:15:58.740 --> 00:16:04.800
点创建客户这必须发生

00:16:02.820 --> 00:16:06.840
在交易范围内

00:16:04.800 --> 00:16:09.300
尽管我们添加了交易性的

00:16:06.840 --> 00:16:10.650
这种方法的内容发生了什么

00:16:09.300 --> 00:16:12.510
在这里不会被交易

00:16:10.650 --> 00:16:14.250
此方法之后发生的默认设置

00:16:12.510 --> 00:16:15.690
被称为，所以我们需要将其包装在

00:16:14.250 --> 00:16:17.750
交易边界和我是什么

00:16:15.690 --> 00:16:20.040
要做的就是使用私有val 

00:16:17.750 --> 00:16:23.040
交易模板还可以

00:16:20.040 --> 00:16:25.500
 Spring 的交易模板是

00:16:23.040 --> 00:16:27.150
物体旋转Spring 不止一个

00:16:25.500 --> 00:16:28.920
十年，这是一个包装

00:16:27.150 --> 00:16:31.920
平台内容和交易管理器

00:16:28.920 --> 00:16:35.339
为了我们的目的，抽象允许

00:16:31.920 --> 00:16:37.260
我们说我们想运行这段代码

00:16:35.339 --> 00:16:41.220
在交易边界中

00:16:37.260 --> 00:16:43.170
 execute方法本身会执行

00:16:41.220 --> 00:16:44.550
方法本身需要进行交易

00:16:43.170 --> 00:16:46.320
回调当然是功能

00:16:44.550 --> 00:16:48.330
具有一种类型方法的接口

00:16:46.320 --> 00:16:50.460
做一次交易

00:16:48.330 --> 00:16:51.870
在这种情况下，我们可以依靠

00:16:50.460 --> 00:16:52.980
隐式参数

00:16:51.870 --> 00:16:54.510
这就是交易状态，所以我们

00:16:52.980 --> 00:16:56.820
不需要它，我们可以声明它，并且

00:16:54.510 --> 00:16:58.860
我们可以说TS等于

00:16:56.820 --> 00:16:59.880
无论哪种方式，我们都将运行这个

00:16:58.860 --> 00:17:01.230
自定义中的少量代码

00:16:59.880 --> 00:17:03.709
事务性阻止其余的这些

00:17:01.230 --> 00:17:06.689
将自动为我们管理

00:17:03.709 --> 00:17:09.089
好的，让我们在以下方面实施我们的服务

00:17:06.689 --> 00:17:10.860
此新集成的条款，请选择

00:17:09.089 --> 00:17:12.829
全部，我将映射结果

00:17:10.860 --> 00:17:18.390
要说给我回顾客

00:17:12.829 --> 00:17:25.680
我在哪里映射IT客户点名称

00:17:18.390 --> 00:17:27.810
 IT客户的点号是

00:17:25.680 --> 00:17:29.250
我的遗漏是它是类型安全的DSL 

00:17:27.810 --> 00:17:31.080
对，我不必做

00:17:29.250 --> 00:17:33.230
除了我要做的以外

00:17:31.080 --> 00:17:35.280
同样的事情在这里让客户点

00:17:33.230 --> 00:17:37.860
选择，在这里我需要提供一个

00:17:35.280 --> 00:17:40.130
谓语我需要说客户

00:17:37.860 --> 00:17:42.560
等于的ID 

00:17:40.130 --> 00:17:46.280
艾迪（Eydie）对，让我们预言未来的到来

00:17:42.560 --> 00:17:50.920
方法，然后我们说map和

00:17:46.280 --> 00:17:50.920
我将在这里重用此定义

00:17:51.730 --> 00:18:01.460
好吧，我们先说还是诺尔

00:17:55.820 --> 00:18:04.430
所以我们要创建一个映射

00:18:01.460 --> 00:18:05.690
地图，我们要说全选

00:18:04.430 --> 00:18:06.830
进入物体，然后先给我

00:18:05.690 --> 00:18:09.800
一个或没有，这就是为什么我们有这个

00:18:06.830 --> 00:18:11.900
问号在那里，然后终于

00:18:09.800 --> 00:18:17.180
插入它也非常严格

00:18:11.900 --> 00:18:19.070
我们说客户点插入，我们

00:18:17.180 --> 00:18:23.960
要说的是客户的ID 

00:18:19.070 --> 00:18:26.270
我们的名字等于客户点的名字

00:18:23.960 --> 00:18:27.980
对，所以我们走了，我们拥有了一切

00:18:26.270 --> 00:18:32.330
我们需要能够使用它

00:18:27.980 --> 00:18:33.620
一个非常简单的盒子

00:18:32.330 --> 00:18:36.590
安全SL，但您可以做的很复杂

00:18:33.620 --> 00:18:38.690
事物非常非常强大，复杂的事物

00:18:36.590 --> 00:18:39.980
像联接等等，都是这种类型的

00:18:38.690 --> 00:18:42.380
安全SL，您无需掉落

00:18:39.980 --> 00:18:45.680
甚至极度续集，甚至

00:18:42.380 --> 00:18:46.520
 DDL本身的定义

00:18:45.680 --> 00:18:48.920
为您完成

00:18:46.520 --> 00:18:50.420
使用这种类型的安全DSL，现在让我们

00:18:48.920 --> 00:18:52.640
重新运行此代码，我已经注释掉了

00:18:50.420 --> 00:18:54.590
 JDBC实现

00:18:52.640 --> 00:18:56.540
实施客户服务

00:18:54.590 --> 00:18:57.920
为此我们的初始化程序的合同

00:18:56.540 --> 00:19:05.270
取决于客户服务将

00:18:57.920 --> 00:19:07.730
仍在工作，让我们运行哦，我需要

00:19:05.270 --> 00:19:11.140
指定长度和编译器

00:19:07.730 --> 00:19:11.140
以为我

00:19:12.760 --> 00:19:21.980
现在暴露需要乔达时间

00:19:16.190 --> 00:19:23.240
而且还需要集成抱歉

00:19:21.980 --> 00:19:24.649
它要求它不记录到

00:19:23.240 --> 00:19:26.240
需要与我们整合的时间

00:19:24.649 --> 00:19:28.730
交易管理机制

00:19:26.240 --> 00:19:30.620
来这里这个错误是说请

00:19:28.730 --> 00:19:32.269
打电话给Davies在运行之前开始连接

00:19:30.620 --> 00:19:33.679
此代码，并向我表明

00:19:32.269 --> 00:19:35.210
它实际上并没有承诺

00:19:33.679 --> 00:19:36.440
之前的交易，所以我们实际上

00:19:35.210 --> 00:19:38.480
完成，但它正在寻找我们已经完成

00:19:36.440 --> 00:19:40.640
这里，但是这个交易模板

00:19:38.480 --> 00:19:42.140
不知道我们的平台

00:19:40.640 --> 00:19:44.059
交易经理计划检查

00:19:42.140 --> 00:19:45.649
交易模板了解Springs 

00:19:44.059 --> 00:19:47.389
平台交易管理器界面

00:19:45.649 --> 00:19:49.490
有很多不同的实现

00:19:47.389 --> 00:19:51.830
该界面针对不同种类的

00:19:49.490 --> 00:19:53.450
您从不同种类了解的资源

00:19:51.830 --> 00:19:55.610
我们需要提供的交易

00:19:53.450 --> 00:20:00.320
暴露了一项叫做 Spring 交易的交易

00:19:55.610 --> 00:20:01.909
经理，我们可以在这里做到

00:20:00.320 --> 00:20:03.649
它希望参考我们的数据

00:20:01.909 --> 00:20:06.590
权利，我们将提供

00:20:03.649 --> 00:20:07.940
正如我之前所说的，这里已经过验证

00:20:06.590 --> 00:20:09.830
今年 Spring 你会知道的

00:20:07.940 --> 00:20:11.360
交易经理期待数据

00:20:09.830 --> 00:20:14.269
来源，已经知道

00:20:11.360 --> 00:20:17.350
当然是

00:20:14.269 --> 00:20:19.639
 JetBrains依次将库暴露出来

00:20:17.350 --> 00:20:21.049
扩展Springs自己的数据源

00:20:19.639 --> 00:20:22.880
交易经理

00:20:21.049 --> 00:20:23.929
扩展抽象平台

00:20:22.880 --> 00:20:25.850
交易经理

00:20:23.929 --> 00:20:29.330
实施平台交易管理器

00:20:25.850 --> 00:20:34.220
所以我们现在可以重用该实现

00:20:29.330 --> 00:20:39.080
在这里，希望它不起作用，让我们

00:20:34.220 --> 00:20:39.559
运行此代码哦，确实需要

00:20:39.080 --> 00:20:41.269
乔达时间

00:20:39.559 --> 00:20:43.220
是的，所以我们也将其引入

00:20:41.269 --> 00:20:45.260
不知道为什么一次需要两个

00:20:43.220 --> 00:20:46.429
我很想知道为什么我必须带

00:20:45.260 --> 00:20:50.350
那以及为什么它不只是这样做

00:20:46.429 --> 00:20:50.350
对我来说，但我们会留在这里

00:20:55.289 --> 00:21:00.129
很好很好所以有记录

00:20:58.059 --> 00:21:01.869
在数据库中的所有四个记录是

00:21:00.129 --> 00:21:03.100
一种非常简单的面包和黄油

00:21:01.869 --> 00:21:05.080
我们可以建立一个应用程序

00:21:03.100 --> 00:21:07.749
控制器，我们可以说客户休息

00:21:05.080 --> 00:21:12.549
控制器使用spring MVC等并获得

00:21:07.749 --> 00:21:15.210
为客户映射有趣的客户等于

00:21:12.549 --> 00:21:19.169
我们想注入私人瓦尔

00:21:15.210 --> 00:21:23.259
风险控制人员的客户服务

00:21:19.169 --> 00:21:27.419
等于这个客户服务点

00:21:23.259 --> 00:21:27.419
全部并再次运行代码

00:21:28.080 --> 00:21:33.399
本地主机：8080 

00:21:29.549 --> 00:21:35.830
客户哦，它阻止了Kotlin 

00:21:33.399 --> 00:21:38.049
默认集成智能

00:21:35.830 --> 00:21:39.909
普通不足以设置单身

00:21:38.049 --> 00:21:42.940
仅实例，所以我正在运行Spring 

00:21:39.909 --> 00:21:44.080
好的应用程序会与

00:21:42.940 --> 00:21:46.119
正在运行的现有应用程序

00:21:44.080 --> 00:21:48.129
同一端口，其中一个将失败

00:21:46.119 --> 00:21:50.470
所以这个第二个在这里失败了

00:21:48.129 --> 00:21:55.169
我要杀掉那个

00:21:50.470 --> 00:21:59.529
再次应用localhost客户

00:21:55.169 --> 00:22:02.379
好吧，让我们看看我选择的客户我

00:21:59.529 --> 00:22:05.499
选择了错误的网址，但是如果我有

00:22:02.379 --> 00:22:06.850
指定s，因为我应该有

00:22:05.499 --> 00:22:08.409
一切都很好，所以我们有

00:22:06.850 --> 00:22:09.999
现在是一个非常简单的spring应用程序

00:22:08.409 --> 00:22:12.039
使用面包和黄油技术

00:22:09.999 --> 00:22:13.720
再次，我们使用JDBC和spring MVC 

00:22:12.039 --> 00:22:16.960
反过来基于servlet 

00:22:13.720 --> 00:22:21.730
东西，所以你知道这很干净

00:22:16.960 --> 00:22:26.190
非常自动，非常现代

00:22:21.730 --> 00:22:28.960
的方法和方式

00:22:26.190 --> 00:22:32.230
拥有数十年历史的技术

00:22:28.960 --> 00:22:33.909
我的意思是JDBC和servlet很老

00:22:32.230 --> 00:22:35.320
他们很好，他们在那里

00:22:33.909 --> 00:22:39.669
你知道我说的是面包和黄油

00:22:35.320 --> 00:22:42.129
好东西，但是当我们得到一些

00:22:39.669 --> 00:22:44.320
受益于棉花延伸

00:22:42.129 --> 00:22:46.509
传统的 Spring api正确的地方

00:22:44.320 --> 00:22:48.129
认为真的有很多

00:22:46.509 --> 00:22:50.169
比新的api有趣的东西

00:22:48.129 --> 00:22:52.389
现在让我们构建一个新的应用程序

00:22:50.169 --> 00:22:55.119
与这口井相似，回到

00:22:52.389 --> 00:22:57.279
今天从 Spring 开始哦，我们将使用

00:22:55.119 --> 00:22:59.470
反应性物质反应性支持和

00:22:57.279 --> 00:23:03.149
 Spring 的webflix，这反过来又是

00:22:59.470 --> 00:23:05.320
 Spring Framework 5，所以我使用Spring Mutoh 

00:23:03.149 --> 00:23:08.320
科特曼当然

00:23:05.320 --> 00:23:09.220
我要使用反应式网页

00:23:08.320 --> 00:23:14.140
反应性

00:23:09.220 --> 00:23:15.910
 MongoDB，我们将使用网关

00:23:14.140 --> 00:23:19.330
 Spring Cloud Gateway好的新项目

00:23:15.910 --> 00:23:21.250
用于站起来的API网关，所以我已经

00:23:19.330 --> 00:23:25.770
知道了，假设您的AoE活跃

00:23:21.250 --> 00:23:25.770
 zip在IDE上打开它

00:23:45.150 --> 00:23:51.660
好的，所以我们有一个新的应用程序

00:23:48.120 --> 00:23:54.180
和之前一样，我们将创建一个数据

00:23:51.660 --> 00:23:56.100
实体数据类客户，但这

00:23:54.180 --> 00:23:58.380
一个将映射到数据库，所以使用

00:23:56.100 --> 00:24:02.010
 MongoDB，所以我们的想法很紧张

00:23:58.380 --> 00:24:04.380
问题运行我们所有的名称字符串

00:24:02.010 --> 00:24:06.390
问号完全等于

00:24:04.380 --> 00:24:08.610
作为文档，让我们关闭一个MongoDB 

00:24:06.390 --> 00:24:11.760
文档，它将有一个主键

00:24:08.610 --> 00:24:14.610
其ID为5 ID，仅此而已

00:24:11.760 --> 00:24:16.050
我们类型的基本定义和

00:24:14.610 --> 00:24:17.490
我们将使用Spring 数据

00:24:16.050 --> 00:24:19.020
将成为一个反应性的MongoDB 

00:24:17.490 --> 00:24:24.990
存储库支持，所以我要说

00:24:19.020 --> 00:24:27.030
客户服务成本反应式Mongo 

00:24:24.990 --> 00:24:28.890
类型的存储库管理实体

00:24:27.030 --> 00:24:33.720
主键是类型的客户

00:24:28.890 --> 00:24:35.610
字符串，现在我们要保存一些

00:24:33.720 --> 00:24:39.540
数据再次存储到数据库中

00:24:35.610 --> 00:24:46.410
时间我们要说 Spring 申请

00:24:39.540 --> 00:24:49.440
构建器点初始化器bean alt输入

00:24:46.410 --> 00:24:55.290
当我说来源等于反应性

00:24:49.440 --> 00:25:00.320
应用程序反应式应用程序类

00:24:55.290 --> 00:25:00.320
 Java，我要告诉它运行

00:25:01.490 --> 00:25:07.659
在这里好吗

00:25:04.690 --> 00:25:09.220
通过组织在那里

00:25:07.659 --> 00:25:10.179
和光束中的初始值设定项

00:25:09.220 --> 00:25:11.979
我要做的第一件事就是我要

00:25:10.179 --> 00:25:16.330
像我们一样每天写一些基础

00:25:11.979 --> 00:25:21.479
较早，因此客户存储库等于

00:25:16.330 --> 00:25:25.989
 ref客户资料库或客户

00:25:21.479 --> 00:25:27.190
仓库在这里我们还好

00:25:25.989 --> 00:25:29.440
本来可以是客户服务

00:25:27.190 --> 00:25:32.139
不能，我会没事的

00:25:29.440 --> 00:25:33.879
猜猜还好吧，那里的裁判

00:25:32.139 --> 00:25:34.869
我们当然需要创建一个光束

00:25:33.879 --> 00:25:36.729
这可能是在那个意思里面

00:25:34.869 --> 00:25:38.609
定义，我们要写一些

00:25:36.729 --> 00:25:46.690
数据出来，所以我们要说保存

00:25:38.609 --> 00:25:47.710
客户ID，所以我们的名字等于

00:25:46.690 --> 00:25:49.539
好吧，我想创建一些

00:25:47.710 --> 00:25:51.369
记录并被动地保存它们，以便

00:25:49.539 --> 00:25:52.899
让我们使用另一个

00:25:51.369 --> 00:26:02.039
扩展这里，我们将使用列表

00:25:52.899 --> 00:26:02.039
你们知道玛格丽特垫米歇尔

00:26:02.549 --> 00:26:07.929
迈克尔好吧，对于MS，我想

00:26:06.009 --> 00:26:11.559
变成出版商

00:26:07.929 --> 00:26:14.289
类型的通量，这是它的上下文

00:26:11.559 --> 00:26:16.179
 Kotlin序列棉的扩展

00:26:14.289 --> 00:26:19.090
将其变成通量的集合

00:26:16.179 --> 00:26:22.539
而通量法则来自

00:26:19.090 --> 00:26:24.759
反应堆堆芯集成通用

00:26:22.539 --> 00:26:26.080
对，这是常见的扩展名，所以

00:26:24.759 --> 00:26:27.879
把它变成发布者的指令

00:26:26.080 --> 00:26:29.739
 Steam发行商，然后我们可以访问

00:26:27.879 --> 00:26:32.220
我们要说的每个地图

00:26:29.739 --> 00:26:35.320
每个给客户

00:26:32.220 --> 00:26:38.950
那些游戏等于我想要的

00:26:35.320 --> 00:26:42.340
转过来看这一切，我要去看看

00:26:38.950 --> 00:26:43.929
映射，然后通过

00:26:42.340 --> 00:26:47.609
将其保存在数据库中，以便客户

00:26:43.929 --> 00:26:54.369
在保存通过时暂停，然后

00:26:47.609 --> 00:26:58.799
这将使我们的Val客户等于

00:26:54.369 --> 00:27:01.149
客户的发布者，我是Eric， 

00:26:58.799 --> 00:27:05.429
我们可以保存可以说客户的数据

00:27:01.149 --> 00:27:12.489
暂停一下，然后删除所有

00:27:05.429 --> 00:27:16.960
那么许多客户提出的客户

00:27:12.489 --> 00:27:20.440
还是找不到所有的点订阅权

00:27:16.960 --> 00:27:26.200
打印我的IT非常好，所以我们现在有

00:27:20.440 --> 00:27:27.130
出版商名单和晚宴

00:27:26.200 --> 00:27:28.510
应该在什么时候写到数据库中

00:27:27.130 --> 00:27:32.670
该应用程序启动，让我们确认

00:27:28.510 --> 00:27:32.670
通过运行应用程序

00:27:44.140 --> 00:27:48.070
好的，这样工作就可以了

00:27:46.600 --> 00:27:49.480
数据库中的四个记录

00:27:48.070 --> 00:27:51.310
得到他们的身份证，所有的东西只是

00:27:49.480 --> 00:27:53.320
像我们期望的那样工作

00:27:51.310 --> 00:27:55.750
到目前为止的代码，让我们构建一个REST API，以便

00:27:53.320 --> 00:27:57.910
再次在这里我们可以使用一个不错的新功能

00:27:55.750 --> 00:28:00.580
在Spring Framework 5和Spring Webb中

00:27:57.910 --> 00:28:02.350
在这里修改反应式Web运行时

00:28:00.580 --> 00:28:04.330
可以说我们想定义我们的

00:28:02.350 --> 00:28:05.860
使用功能性反应的端点

00:28:04.330 --> 00:28:08.170
端点，我们可以再次使用

00:28:05.860 --> 00:28:09.790
随着我们的MVC样式控制器的出现

00:28:08.170 --> 00:28:12.010
在上一个示例中做了，但这是我

00:28:09.790 --> 00:28:13.660
认为这会多一点

00:28:12.010 --> 00:28:15.310
如果你做的话很平易近人

00:28:13.660 --> 00:28:17.860
科特勒，你想知道得最少

00:28:15.310 --> 00:28:19.270
结果的代码量如何

00:28:17.860 --> 00:28:20.470
我们要去做我们要做的

00:28:19.270 --> 00:28:22.750
只是想使用它的功能

00:28:20.470 --> 00:28:25.360
反应性终点，我们使用Kotlin 

00:28:22.750 --> 00:28:30.430
 DSL使得它更加简洁

00:28:25.360 --> 00:28:33.820
赢得客户，我们的工作是

00:28:30.430 --> 00:28:36.130
返回一个好的服务器响应

00:28:33.820 --> 00:28:40.900
我们将需要客户

00:28:36.130 --> 00:28:44.650
仓库，因此客户仓库等于

00:28:40.900 --> 00:28:47.740
纵容客户资源库，我们将

00:28:44.650 --> 00:28:50.140
说客户存储库找不到全部

00:28:47.740 --> 00:28:52.660
这是客户流向的回报

00:28:50.140 --> 00:28:54.580
客户发布者注意到我们

00:28:52.660 --> 00:28:56.470
被提供了扩展，我们可以

00:28:54.580 --> 00:28:58.510
与我们互动，我们想要该扩展

00:28:56.470 --> 00:29:00.250
因为否则没有扩展名

00:28:58.510 --> 00:29:03.430
我们必须提供一个类文字或

00:29:00.250 --> 00:29:04.990
您知道的超级类型令牌

00:29:03.430 --> 00:29:06.640
由参数化类型表示

00:29:04.990 --> 00:29:08.890
在 Spring 生态系统中提到

00:29:06.640 --> 00:29:11.440
告诉发布者告诉网络运行时

00:29:08.890 --> 00:29:13.510
在哪里做数据构架请记住

00:29:11.440 --> 00:29:15.520
发布者可以产生一个您知道的

00:29:13.510 --> 00:29:18.040
万亿价值，它可能永远持续下去

00:29:15.520 --> 00:29:20.950
它永远不会停止，那是完美的

00:29:18.040 --> 00:29:23.110
 Web运行时需要在语义上还可以

00:29:20.950 --> 00:29:24.460
知道何时制定响应

00:29:23.110 --> 00:29:25.810
虽然什么时候知道你不想要

00:29:24.460 --> 00:29:27.610
等待最后一个字节，特别是如果

00:29:25.810 --> 00:29:30.130
最后一个字节永远不会到达所以

00:29:27.610 --> 00:29:31.420
该发布者需要有关何时的线索

00:29:30.130 --> 00:29:33.460
它应该开始你知道什么时候应该

00:29:31.420 --> 00:29:34.810
你知道应该在什么时候

00:29:33.460 --> 00:29:36.850
它有什么，然后将其发送回

00:29:34.810 --> 00:29:38.830
客户，我们要说发送

00:29:36.850 --> 00:29:40.930
为每个客户实体返回

00:29:38.830 --> 00:29:42.730
需要知道什么形状

00:29:40.930 --> 00:29:44.730
该客户的形状是，我们这样做

00:29:42.730 --> 00:29:47.260
通常在Java API中，通过提供

00:29:44.730 --> 00:29:49.270
客户类Java作为类

00:29:47.260 --> 00:29:51.280
引用我们的类文字，但是因为

00:29:49.270 --> 00:29:53.080
我们有这个共同的扩展名是ray 

00:29:51.280 --> 00:29:54.610
如果我正确的话，它已经被捕获了

00:29:53.080 --> 00:29:56.230
根据网站的调用在那里

00:29:54.610 --> 00:29:58.750
现在我们有这个

00:29:56.230 --> 00:30:00.370
对将起作用的端点API做出反应

00:29:58.750 --> 00:30:03.460
很好，让我们开始

00:30:00.370 --> 00:30:05.380
现在这是你知道这是一个好

00:30:03.460 --> 00:30:06.490
我应该杀死的API声音示例

00:30:05.380 --> 00:30:09.940
另一个，否则我们会遇到

00:30:06.490 --> 00:30:14.620
同样的问题，这是一个很好的例子

00:30:09.940 --> 00:30:17.140
您知道的API正常工作

00:30:14.620 --> 00:30:18.730
当然使用反应性材料

00:30:17.140 --> 00:30:20.440
这不仅仅是一项服务，我们

00:30:18.730 --> 00:30:22.210
说这也是一项边缘服务

00:30:20.440 --> 00:30:23.740
不只是带有边缘服务的REST API 

00:30:22.210 --> 00:30:27.610
它是前端的后端，或者

00:30:23.740 --> 00:30:30.760
与您的整合

00:30:27.610 --> 00:30:33.220
其他一些技术

00:30:30.760 --> 00:30:34.600
也许是那个东西

00:30:33.220 --> 00:30:35.590
请求的第一个呼叫端口

00:30:34.600 --> 00:30:39.580
从外到下游

00:30:35.590 --> 00:30:40.840
提供我们想要代理的服务

00:30:39.580 --> 00:30:43.090
一些数据从一个地方到另一个地方

00:30:40.840 --> 00:30:44.290
在这里我们可以使用ool，但是Zul有一个

00:30:43.090 --> 00:30:46.000
限制数量有一个

00:30:44.290 --> 00:30:48.190
来自Netflix的项目，我们进行了整合

00:30:46.000 --> 00:30:51.670
与 Spring 的云，我们做了很多

00:30:48.190 --> 00:30:53.020
使其强大的工作，但并非如此

00:30:51.670 --> 00:30:55.660
非常适合被动式

00:30:53.020 --> 00:30:57.040
基于流的应用程序

00:30:55.660 --> 00:30:59.710
不支持其他协议

00:30:57.040 --> 00:31:01.630
 HTTP和API有点笨拙

00:30:59.710 --> 00:31:03.160
如果您害怕过滤器，或者

00:31:01.630 --> 00:31:04.570
试图整合其功能

00:31:03.160 --> 00:31:06.760
 Spring 的生态系统，所以我们有了一个新的

00:31:04.570 --> 00:31:10.870
名为Spring Cloud Gateway的项目

00:31:06.760 --> 00:31:12.400
 Spring Cloud Gateway就是

00:31:10.870 --> 00:31:14.680
它基于Spring的网关技术

00:31:12.400 --> 00:31:16.030
框架5当然是

00:31:14.680 --> 00:31:17.320
我们正在使用的化身只是

00:31:16.030 --> 00:31:19.690
在 Spring 工厂Finchley和

00:31:17.320 --> 00:31:21.670
我们将使用反应性化身

00:31:19.690 --> 00:31:24.670
而不是Kotlin扩展

00:31:21.670 --> 00:31:27.550
那也将帮助我们，所以我们

00:31:24.670 --> 00:31:29.410
在课堂上有Spring Cloud

00:31:27.550 --> 00:31:32.100
网关，我们需要引入

00:31:29.410 --> 00:31:35.170
 Kotlin扩展名，这是临时的

00:31:32.100 --> 00:31:36.220
正确的棉花延伸情况

00:31:35.170 --> 00:31:37.600
最终将处于同一状态

00:31:36.220 --> 00:31:39.820
代码库，您无需引入

00:31:37.600 --> 00:31:41.410
一个单独的图书馆，但现在您知道了

00:31:39.820 --> 00:31:42.930
我们要做我们必须要做的

00:31:41.410 --> 00:31:44.950
没什么大不了的，所以这就是你

00:31:42.930 --> 00:31:46.450
在这里描述网关

00:31:44.950 --> 00:31:48.370
使用以下命令在此处创建配置

00:31:46.450 --> 00:31:50.980
棉花DSL这是我们非常好的DSL 

00:31:48.370 --> 00:31:54.310
要说我们要创建一条路线

00:31:50.980 --> 00:31:57.090
代理调用我们的端点以

00:31:54.310 --> 00:32:02.770
我们的本地节点，然后将其路由到

00:31:57.090 --> 00:32:05.440
到博客输出博客提要RSS 

00:32:02.770 --> 00:32:08.150
为我们的 Spring 喂原子饲料

00:32:05.440 --> 00:32:12.440
 IO博客好，所以我们在这里

00:32:08.150 --> 00:32:15.500
然后复制并粘贴该网址，这样我就可以

00:32:12.440 --> 00:32:21.500
说是否有匹配的请求

00:32:15.500 --> 00:32:23.000
用户请求网关时的路径博客

00:32:21.500 --> 00:32:28.130
处理程序谓词包装器票证路径

00:32:23.000 --> 00:32:30.830
或走到亚当的路上，注意我们正在使用

00:32:28.130 --> 00:32:33.980
这是这里的方法

00:32:30.830 --> 00:32:35.600
实际上是Kotlin中的中缀函数

00:32:33.980 --> 00:32:38.270
不必提供方法

00:32:35.600 --> 00:32:39.950
括号，所以它允许我这样做

00:32:38.270 --> 00:32:42.050
因为它被称为中缀函数

00:32:39.950 --> 00:32:46.010
结果是我可以写这些

00:32:42.050 --> 00:32:47.810
干净的DSL，我有这个

00:32:46.010 --> 00:32:50.120
通量表示法，这只是工作

00:32:47.810 --> 00:32:52.030
现在对我来说我可以说你什么时候比赛

00:32:50.120 --> 00:32:56.080
当某物与之匹配时

00:32:52.030 --> 00:33:02.480
模式代理它到这个端点我

00:32:56.080 --> 00:33:04.580
可以使用较低的跳出网址

00:33:02.480 --> 00:33:07.490
好的，我实际上可以拥有一个URI 

00:33:04.580 --> 00:33:09.800
达到磅，这是负载弹跳器

00:33:07.490 --> 00:33:12.490
傻瓜-服务我将成为负载的保镖

00:33:09.800 --> 00:33:14.930
在这种情况下，你会知道

00:33:12.490 --> 00:33:17.450
 Netflix功能区工作

00:33:14.930 --> 00:33:19.180
与一种发现相结合

00:33:17.450 --> 00:33:21.110
 Spring Cloud 发现客户端

00:33:19.180 --> 00:33:23.090
可以与之交谈的实现

00:33:21.110 --> 00:33:25.460
诸如Apache zookeeper和Netflix之类的东西

00:33:23.090 --> 00:33:26.870
你一周哈希的核心控制台等，所以我

00:33:25.460 --> 00:33:28.220
当然可以做到，我什至可以

00:33:26.870 --> 00:33:29.480
做其他有趣的事情，例如

00:33:28.220 --> 00:33:31.190
您可以提供的网关过滤器

00:33:29.480 --> 00:33:35.060
支持诸如负载平衡之类的功能

00:33:31.190 --> 00:33:36.170
限速和断路

00:33:35.060 --> 00:33:38.240
好吧，我也可以做所有的事情

00:33:36.170 --> 00:33:40.430
但出于我们的目的，可能还不错

00:33:38.240 --> 00:33:42.980
只是保持原样并摆脱它

00:33:40.430 --> 00:33:45.430
这样做，然后重新运行

00:33:42.980 --> 00:33:45.430
应用

00:33:52.230 --> 00:34:01.539
好吧，所以本地客户那里

00:33:58.720 --> 00:34:06.610
那我们去咨询一下

00:34:01.539 --> 00:34:10.960
最后看这里，我们要说卷曲

00:34:06.610 --> 00:34:12.790
减V并得到那么好，我们也

00:34:10.960 --> 00:34:15.450
有这个叫博客的人看看

00:34:12.790 --> 00:34:18.100
回到嘴唇头的头

00:34:15.450 --> 00:34:20.020
当我们这样做时，我们可以看到我们

00:34:18.100 --> 00:34:22.359
得到这些，当然是RSS提要

00:34:20.020 --> 00:34:24.340
原子饲料，而我们得到的内容

00:34:22.359 --> 00:34:25.480
类型以及我们拥有的所有东西

00:34:24.340 --> 00:34:27.159
害怕叫服务

00:34:25.480 --> 00:34:28.750
直接，所以我们实际上是代理

00:34:27.159 --> 00:34:31.810
使用这种高效的结果

00:34:28.750 --> 00:34:33.100
反应性网关项目还可以

00:34:31.810 --> 00:34:35.200
我们只看了一些

00:34:33.100 --> 00:34:37.659
 Spring 不同的技术

00:34:35.200 --> 00:34:39.790
我们研究过的生态系统

00:34:37.659 --> 00:34:41.500
这些是使用新项目的种子

00:34:39.790 --> 00:34:42.909
通话和所有打开的插件以及

00:34:41.500 --> 00:34:44.200
 Spring初始值设定项和Complan 

00:34:42.909 --> 00:34:46.030
支持那里，我们研究了如何使用

00:34:44.200 --> 00:34:47.619
我们看过的功能光束定义

00:34:46.030 --> 00:34:50.470
与Kotlin社区整合

00:34:47.619 --> 00:34:51.730
像暴露和观察的技术

00:34:50.470 --> 00:34:52.840
您如何知道与

00:34:51.730 --> 00:34:54.820
平台式Spring 装置

00:34:52.840 --> 00:34:58.060
我们使用的交易管理器

00:34:54.820 --> 00:35:00.400
 Spring MVC样式控制器，然后我们

00:34:58.060 --> 00:35:03.190
看了怎么知道你怎么用

00:35:00.400 --> 00:35:04.770
 Spring Framework中的反应式支持

00:35:03.190 --> 00:35:08.290
 5和 Spring butoh 

00:35:04.770 --> 00:35:09.700
此处用于功能性反应性端点

00:35:08.290 --> 00:35:11.290
我们通过反应功能做到了这一点

00:35:09.700 --> 00:35:13.570
那里的端点，然后我们也看了看

00:35:11.290 --> 00:35:15.670
在喷水网关及其DSL上

00:35:13.570 --> 00:35:16.690
这一点你知道这看起来不

00:35:15.670 --> 00:35:18.130
像你可能看到的任何东西

00:35:16.690 --> 00:35:20.530
在功能束定义之前

00:35:18.130 --> 00:35:22.180
这个DSL，这是整个 Spring 的结果

00:35:20.530 --> 00:35:24.280
在由...管理的对象中

00:35:22.180 --> 00:35:26.109
应用程序上下文对同样的事情

00:35:24.280 --> 00:35:27.040
这给了我这个结果

00:35:26.109 --> 00:35:29.320
由管理的对象

00:35:27.040 --> 00:35:30.700
应用程序上下文全部完成

00:35:29.320 --> 00:35:33.609
为你，你不必担心

00:35:30.700 --> 00:35:34.990
关于你知道搞清楚，但是

00:35:33.609 --> 00:35:36.880
只是对象，这些只是对象

00:35:34.990 --> 00:35:38.770
您可以将它们拆开并更换

00:35:36.880 --> 00:35:40.119
他们的一部分，等等，你得到了所有

00:35:38.770 --> 00:35:42.640
一整分钟的时间

00:35:40.119 --> 00:35:45.850
更简洁的方法

00:35:42.640 --> 00:35:48.910
来构建应用程序，我可以

00:35:45.850 --> 00:35:52.230
看看为什么例如

00:35:48.910 --> 00:35:54.040
 Gradle团队也支持

00:35:52.230 --> 00:35:56.200
 Kotlin是建立伟大的语言

00:35:54.040 --> 00:35:58.359
好了Gradle非常简洁

00:35:56.200 --> 00:35:59.410
用于构建构建文件的DSL 

00:35:58.359 --> 00:36:02.109
描述构建文件，有一个

00:35:59.410 --> 00:36:04.549
他们正在使用Kotlin I的不错的Typesafe DSL 

00:36:02.109 --> 00:36:05.749
当然希望有一天

00:36:04.549 --> 00:36:07.999
您将可以开始

00:36:05.749 --> 00:36:09.829
 IO，然后选择Kotlin和

00:36:07.999 --> 00:36:11.569
您将获得一个build.gradle文件

00:36:09.829 --> 00:36:12.799
 Kotlin不仅仅是愚蠢的我希望

00:36:11.569 --> 00:36:14.959
那就是一天会发生的事情

00:36:12.799 --> 00:36:16.219
好吧，现在我们才有了Maven 

00:36:14.959 --> 00:36:19.910
在Gradle中，但想像一下您是否拥有Gradle 

00:36:16.219 --> 00:36:21.920
除了常见的

00:36:19.910 --> 00:36:23.599
好极了的时髦语言

00:36:21.920 --> 00:36:26.529
和我的朋友非常感谢

00:36:23.599 --> 00:36:26.529
看，下次见

00:36:33.080 --> 00:36:35.140
您

