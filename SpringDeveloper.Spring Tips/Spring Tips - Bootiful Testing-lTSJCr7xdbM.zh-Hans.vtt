WEBVTT
Kind: captions
Language: zh-Hans

00:00:26.050 --> 00:00:30.640
欢迎来到另一期

00:00:28.420 --> 00:00:32.200
在本期的春季技巧中，我们

00:00:30.640 --> 00:00:35.110
看看如何进行测试

00:00:32.200 --> 00:00:36.700
 TDD我们当然会看

00:00:35.110 --> 00:00:38.590
 Spring Boot中的功能，因此我们将

00:00:36.700 --> 00:00:40.510
从一个新的项目开始

00:00:38.590 --> 00:00:42.760
春天，我哦，现在我们要去

00:00:40.510 --> 00:00:44.320
遵循测试驱动的三个规则

00:00:42.760 --> 00:00:47.020
我见过最好的发展

00:00:44.320 --> 00:00:49.270
鲍勃·马丁解释鲍勃·马丁说

00:00:47.020 --> 00:00:50.739
在做的时候有三个规则

00:00:49.270 --> 00:00:54.670
测试驱动的开发，所以这三个规则

00:00:50.739 --> 00:00:58.239
 TDD Bob Martin的作品，您会发现

00:00:54.670 --> 00:00:59.980
成为一个有用的博客，这是第一个

00:00:58.239 --> 00:01:01.720
规则是你不允许写任何东西

00:00:59.980 --> 00:01:04.330
生产代码，除非要制作

00:01:01.720 --> 00:01:05.560
单元测试失败通过第二条规则

00:01:04.330 --> 00:01:07.479
是不允许你写任何

00:01:05.560 --> 00:01:09.430
单元测试多于足够

00:01:07.479 --> 00:01:12.310
失败，编译失败是

00:01:09.430 --> 00:01:13.660
失败和第三，最后你是

00:01:12.310 --> 00:01:16.420
不允许再写任何作品

00:01:13.660 --> 00:01:18.490
足以通过一个的代码

00:01:16.420 --> 00:01:19.840
测试失败，所以基本上不会动

00:01:18.490 --> 00:01:22.660
太遥远了，你会留在里面

00:01:19.840 --> 00:01:24.399
编写一个循环时保持循环

00:01:22.660 --> 00:01:25.930
测试你应该写生产

00:01:24.399 --> 00:01:27.250
通过测试的代码，然后

00:01:25.930 --> 00:01:28.420
一旦你写的足够使

00:01:27.250 --> 00:01:30.789
那测试合格你回去写

00:01:28.420 --> 00:01:32.440
更多测试，您不再写

00:01:30.789 --> 00:01:36.130
测试而不是制作生产代码

00:01:32.440 --> 00:01:37.330
对的失败，让您保持周期

00:01:36.130 --> 00:01:38.530
你经常回去的地方

00:01:37.330 --> 00:01:39.640
在生产代码和测试之间

00:01:38.530 --> 00:01:42.670
代码，测试代码和生产代码

00:01:39.640 --> 00:01:46.240
而且你知道理想上你不应该花钱

00:01:42.670 --> 00:01:47.920
任何人都可以说30秒以上

00:01:46.240 --> 00:01:51.729
对吧，你知道你是

00:01:47.920 --> 00:01:53.560
会一直处于这个循环中

00:01:51.729 --> 00:01:57.429
这样做的结果

00:01:53.560 --> 00:02:00.280
首先要移动到这许多折

00:01:57.429 --> 00:02:01.569
最终编写了可测试的软件

00:02:00.280 --> 00:02:03.220
对，这是最重要的

00:02:01.569 --> 00:02:06.550
通过编写软件来暗示这一点

00:02:03.220 --> 00:02:09.160
是可测试的，你必须强迫

00:02:06.550 --> 00:02:11.860
待划分的代码

00:02:09.160 --> 00:02:14.709
容易被边缘化的权利

00:02:11.860 --> 00:02:16.300
界定合作场景

00:02:14.709 --> 00:02:18.400
必须清楚地标出对象

00:02:16.300 --> 00:02:20.650
因为那是唯一可以嘲笑的方式

00:02:18.400 --> 00:02:22.900
遍及应用程序的不同层

00:02:20.650 --> 00:02:24.580
对，你可以模拟出这些碎片

00:02:22.900 --> 00:02:28.540
你不在乎取代

00:02:24.580 --> 00:02:29.709
依赖与模拟等等

00:02:28.540 --> 00:02:31.180
使自己倒置

00:02:29.709 --> 00:02:34.930
控制和依赖注入

00:02:31.180 --> 00:02:36.430
万物的基础是另一个

00:02:34.930 --> 00:02:38.800
转向这种架构的好处

00:02:36.430 --> 00:02:39.880
这种方法当然是当

00:02:38.800 --> 00:02:42.250
你写软件

00:02:39.880 --> 00:02:44.230
你得到多巴胺击中

00:02:42.250 --> 00:02:46.270
多巴胺打击与实现

00:02:44.230 --> 00:02:49.480
或完成某件事时

00:02:46.270 --> 00:02:50.470
编写有效的软件，然后

00:02:49.480 --> 00:02:52.240
你写测试不是很好

00:02:50.470 --> 00:02:54.040
很满意，感觉就像你已经

00:02:52.240 --> 00:02:55.810
不得不做一个琐事，你回去

00:02:54.040 --> 00:02:57.700
文档，然后您回去

00:02:55.810 --> 00:02:59.410
你写了测试但是你已经

00:02:57.700 --> 00:03:01.540
知道作品，如果你被迫

00:02:59.410 --> 00:03:03.430
时间，你可能会很想你

00:03:01.540 --> 00:03:04.660
可以跳过该特定步骤

00:03:03.430 --> 00:03:08.650
因为它毕竟已经在工作

00:03:04.660 --> 00:03:09.940
那是一个不好的心态

00:03:08.650 --> 00:03:11.950
所以最好写成

00:03:09.940 --> 00:03:15.160
代码或测试，然后再编写

00:03:11.950 --> 00:03:16.930
满足那个的令人满意的测试

00:03:15.160 --> 00:03:18.490
而不是写令人满意的

00:03:16.930 --> 00:03:20.050
满足测试的生产代码

00:03:18.490 --> 00:03:21.670
所以现在你有两个为一

00:03:20.050 --> 00:03:23.740
工作代码，您已经拥有了

00:03:21.670 --> 00:03:25.510
多巴胺命中与获得

00:03:23.740 --> 00:03:27.430
您的代码在编写时变为绿色

00:03:25.510 --> 00:03:28.600
以这种方式编写代码，所有代码开始

00:03:27.430 --> 00:03:29.920
通过测试，所以你知道自己很好

00:03:28.600 --> 00:03:31.540
覆盖范围，因为您无法拥有

00:03:29.920 --> 00:03:33.970
写了一行压缩代码，没有

00:03:31.540 --> 00:03:36.640
已经写了相关测试

00:03:33.970 --> 00:03:39.310
您现在有了一个测试套件，可以利用

00:03:36.640 --> 00:03:40.720
你可以相信你可以重构

00:03:39.310 --> 00:03:42.490
逍遥法外，你知道你已经

00:03:40.720 --> 00:03:44.080
涵盖了一切，所以当你做

00:03:42.490 --> 00:03:47.500
变化，您知道线束会

00:03:44.080 --> 00:03:49.710
正确捕获所有内容，以便您获得

00:03:47.500 --> 00:03:52.660
我从这种方法中获得了很多好处

00:03:49.710 --> 00:03:55.570
认为值得我们在关键

00:03:52.660 --> 00:03:57.960
在关键实验室的课程中，我们做了很多

00:03:55.570 --> 00:04:00.310
配对编程正确的配对编程

00:03:57.960 --> 00:04:02.110
有很多好处，所以就像我

00:04:00.310 --> 00:04:03.810
可以永远持续下去，但其中之一

00:04:02.110 --> 00:04:05.860
好处是这对编程

00:04:03.810 --> 00:04:07.810
当您进行测试时，我们会做

00:04:05.860 --> 00:04:10.300
红绿重构，有人写道

00:04:07.810 --> 00:04:11.860
测试失败，所以我们写了

00:04:10.300 --> 00:04:14.230
测试失败，然后该对

00:04:11.860 --> 00:04:16.420
编写设置测试的代码

00:04:14.230 --> 00:04:17.739
向右走，所以你来回走

00:04:16.420 --> 00:04:19.209
您可以发送给他们，也可以切换角色

00:04:17.739 --> 00:04:20.530
当然，一个人可以写

00:04:19.209 --> 00:04:26.290
生产代码和另一个

00:04:20.530 --> 00:04:27.760
天。测试，你得到两个

00:04:26.290 --> 00:04:28.960
两侧两个黄铜专注于相同

00:04:27.760 --> 00:04:30.310
问题，你不觉得自己

00:04:28.960 --> 00:04:32.640
跨步或跨步

00:04:30.310 --> 00:04:35.470
别人的脚，你实际上在写

00:04:32.640 --> 00:04:36.910
规范，然后是测试

00:04:35.470 --> 00:04:39.130
您正在实施该规范

00:04:36.910 --> 00:04:42.220
对，所以很多好处正在转移到

00:04:39.130 --> 00:04:43.510
我肯定会推荐这种方法

00:04:42.220 --> 00:04:44.520
进一步研究它，我们将

00:04:43.510 --> 00:04:46.870
今天我们要做的就是看

00:04:44.520 --> 00:04:47.950
测试驱动的开发，但我们不是

00:04:46.870 --> 00:04:49.570
要做，我们也要流连忘返

00:04:47.950 --> 00:04:50.800
关于测试的概念由来已久

00:04:49.570 --> 00:04:53.350
测试驱动的开发将看起来

00:04:50.800 --> 00:04:54.850
在春季支持测试，所以

00:04:53.350 --> 00:04:56.950
让我们在创建一个新项目时

00:04:54.850 --> 00:04:58.350
通常会开始春天

00:04:56.950 --> 00:05:00.460
我欠的，虽然会叫这个

00:04:58.350 --> 00:05:01.630
引导测试以及我以前

00:05:00.460 --> 00:05:04.360
带来来自网络建设的支持

00:05:01.630 --> 00:05:06.280
我们使用JPA的应用程序我们使用h2 Islam 

00:05:04.360 --> 00:05:07.960
降压，我们将点击生成，现在我不是

00:05:06.280 --> 00:05:09.910
你知道那并不重要

00:05:07.960 --> 00:05:11.890
春季靴的版本，您使用所有

00:05:09.910 --> 00:05:14.050
不起作用的东西一直在

00:05:11.890 --> 00:05:17.230
春季以来，或者说 spring boot 

00:05:14.050 --> 00:05:19.060
从第四点开始，我们就坚定了

00:05:17.230 --> 00:05:24.450
不管我们使用这些版本的版本

00:05:19.060 --> 00:05:24.450
天，所以我们将打开发布

00:05:34.560 --> 00:05:40.720
现在我们有一个新的应用程序

00:05:37.060 --> 00:05:43.210
我们可以从这里开始，但是当我再次

00:05:40.720 --> 00:05:45.160
首先写测试，这样一个社区

00:05:43.210 --> 00:05:46.419
这里的命令是

00:05:45.160 --> 00:05:48.160
 telogen它带您到

00:05:46.419 --> 00:05:49.720
在这种情况下，我们不进行相应的测试

00:05:48.160 --> 00:05:51.639
其实想要那个对应的测试

00:05:49.720 --> 00:05:53.470
我们首先要说简单

00:05:51.639 --> 00:05:55.599
你知道我们可以内置到系统中

00:05:53.470 --> 00:05:58.180
我们要测试的第一件事是

00:05:55.599 --> 00:05:59.349
基本实体我们是保留实体

00:05:58.180 --> 00:06:00.490
甚至不打算用术语谈论它

00:05:59.349 --> 00:06:02.620
的实体，您不会在其中谈论它

00:06:00.490 --> 00:06:05.050
我们要测试的对象的条件

00:06:02.620 --> 00:06:11.319
这个实体的健全性，所以在可以的时候

00:06:05.050 --> 00:06:13.840
预订测试，并会测试

00:06:11.319 --> 00:06:18.430
对象的创建对吧

00:06:13.840 --> 00:06:23.949
测试公共无效创建权，我将

00:06:18.430 --> 00:06:26.199
我会学会拼写有R 

00:06:23.949 --> 00:06:27.610
我想测试中的对象

00:06:26.199 --> 00:06:29.830
确认当我创建一个对象时

00:06:27.610 --> 00:06:31.449
类型保留，我给它一些数据

00:06:29.830 --> 00:06:33.460
在构造函数中

00:06:31.449 --> 00:06:35.460
正确的事情，所以创建了一个记录

00:06:33.460 --> 00:06:37.389
表格已经测试失败了

00:06:35.460 --> 00:06:39.310
而是我们需要实际创建

00:06:37.389 --> 00:06:40.659
这个生产课我们可以按alt 

00:06:39.310 --> 00:06:42.969
输入将在

00:06:40.659 --> 00:06:44.500
我要提供的相应包裹

00:06:42.969 --> 00:06:46.659
构造函数中的值显然是

00:06:44.500 --> 00:06:48.340
现在我也需要做

00:06:46.659 --> 00:06:52.300
我可以自己创建构造函数

00:06:48.340 --> 00:06:56.469
说长预定L，你知道然后

00:06:52.300 --> 00:06:58.419
字符串名称正确，但是我想做什么

00:06:56.469 --> 00:06:59.740
实际上是采取一些简短的捷径

00:06:58.419 --> 00:07:02.680
在这里，我将使用龙目岛

00:06:59.740 --> 00:07:05.770
注释，你知道我要去

00:07:02.680 --> 00:07:07.780
认为在这种情况下

00:07:05.770 --> 00:07:10.780
我的物件的状态与

00:07:07.780 --> 00:07:12.520
我警报的结构，所以所有创建

00:07:10.780 --> 00:07:17.789
字段到您的私人长ID和

00:07:12.520 --> 00:07:20.770
私有字符串保留名称，如下所示

00:07:17.789 --> 00:07:24.250
字符串保留名称，所以在那里

00:07:20.770 --> 00:07:26.469
我们有两个领域

00:07:24.250 --> 00:07:29.020
在所有的args构造函数和数据

00:07:26.469 --> 00:07:31.419
注解我得到一个构造函数

00:07:29.020 --> 00:07:33.250
你知道在这里工作，当然我现在

00:07:31.419 --> 00:07:35.169
可以说我获得身份证获得预订

00:07:33.250 --> 00:07:39.669
名称等让我写一些测试

00:07:35.169 --> 00:07:42.520
所以我可以说断言等于或获得ID和

00:07:39.669 --> 00:07:45.430
我想说等于1升

00:07:42.520 --> 00:07:46.480
对，所以我要上演

00:07:45.430 --> 00:07:51.460
促进正确

00:07:46.480 --> 00:07:54.910
那是一个未装箱的整数或长整数

00:07:51.460 --> 00:07:57.700
而不是到那里的java.lang 

00:07:54.910 --> 00:08:04.440
先生，我正在运行，所以我们可以运行

00:07:57.700 --> 00:08:04.440
现在进行此测试，让我们看看运行该代码

00:08:05.790 --> 00:08:09.820
一些团队曾经表现良好，这是一个

00:08:08.410 --> 00:08:11.650
当然可以做到的方式

00:08:09.820 --> 00:08:13.420
我们可以使用基本的j init方法

00:08:11.650 --> 00:08:16.240
自从你永远知道以来一直在监狱里

00:08:13.420 --> 00:08:21.070
有一天我们也可以使用断言

00:08:16.240 --> 00:08:23.080
该差异权利如此认定，并且

00:08:21.070 --> 00:08:25.660
这需要一个类型匹配器的对象

00:08:23.080 --> 00:08:27.220
现在由于种种原因，我并不是真的

00:08:25.660 --> 00:08:29.110
了解甚至关心，因为

00:08:27.220 --> 00:08:33.729
你真的不应该这样

00:08:29.110 --> 00:08:36.130
使用匹配器，您会看到匹配器

00:08:33.729 --> 00:08:38.350
有这个很棒的方法，说不要

00:08:36.130 --> 00:08:40.330
实施的事情当然是乞讨

00:08:38.350 --> 00:08:44.050
问题你为什么把那放进去

00:08:40.330 --> 00:08:45.700
我怀疑第一名

00:08:44.050 --> 00:08:47.830
 Java中默认方法的可用性

00:08:45.700 --> 00:08:50.170
这8天他们本来不会

00:08:47.830 --> 00:08:51.550
同样的决定

00:08:50.170 --> 00:08:53.140
我们只需要扩展的目的

00:08:51.550 --> 00:08:54.400
指标，以便您可以创建自己的自定义

00:08:53.140 --> 00:08:56.740
床垫和这件事的好处

00:08:54.400 --> 00:08:58.450
方法是这些事情可以

00:08:56.740 --> 00:08:59.970
打包，您可以打包它们， 

00:08:58.450 --> 00:09:04.000
分发它们，以便您现在可以重复使用

00:08:59.970 --> 00:09:05.590
复杂的测试复杂的断言和

00:09:04.000 --> 00:09:07.360
功能在那里，为我们

00:09:05.590 --> 00:09:10.090
目的，尽管我们只是要使用

00:09:07.360 --> 00:09:11.200
一些预制的床垫，或者

00:09:10.090 --> 00:09:13.630
更少地反映我们所要的东西

00:09:11.200 --> 00:09:15.520
有了基本的达娜

00:09:13.630 --> 00:09:17.770
星号方法，这些来自项目

00:09:15.520 --> 00:09:19.270
图书馆叫做hamcrest，有一个

00:09:17.770 --> 00:09:21.880
我们可以在这里找到不同的比赛数量

00:09:19.270 --> 00:09:23.860
说我们要断言这个ID 

00:09:21.880 --> 00:09:27.090
等于1 L对，所以有

00:09:23.860 --> 00:09:27.090
现在让我们再次运行该代码

00:09:30.140 --> 00:09:35.899
好吧，那似乎很好

00:09:33.110 --> 00:09:37.490
让我们更进一步

00:09:35.899 --> 00:09:41.720
使用一个称为特定J的库

00:09:37.490 --> 00:09:43.459
这里的测试有一个通用的

00:09:41.720 --> 00:09:45.350
约束，但不是真的

00:09:43.459 --> 00:09:47.529
你知道关于什么没有指导

00:09:45.350 --> 00:09:50.000
是适合放在这里的匹配器

00:09:47.529 --> 00:09:51.500
给定类型给定参数

00:09:50.000 --> 00:09:53.329
在左边所以匹配器在右边

00:09:51.500 --> 00:09:56.360
不一定被告知或由其驱动

00:09:53.329 --> 00:09:58.910
左边的参数

00:09:56.360 --> 00:10:03.320
使用断言中的断言库

00:09:58.910 --> 00:10:05.269
 J你可以说R get ID等于1 l 

00:10:03.320 --> 00:10:07.610
对，它会自动完成

00:10:05.269 --> 00:10:10.370
所以我更喜欢正确的选择

00:10:07.610 --> 00:10:12.440
保留名称看到的作品，但我

00:10:10.370 --> 00:10:18.110
可以看到它还说它不是空白

00:10:12.440 --> 00:10:20.779
我可以说那等于简，所以我

00:10:18.110 --> 00:10:23.630
得到这个非常非常方便的

00:10:20.779 --> 00:10:25.220
在功能上键入安全匹配

00:10:23.630 --> 00:10:26.570
测试功能和测试

00:10:25.220 --> 00:10:28.160
基本上写自己让我们打破

00:10:26.570 --> 00:10:30.620
在这里测试，让我们说它等于

00:10:28.160 --> 00:10:32.300
珍妮特，看看会发生什么

00:10:30.620 --> 00:10:34.130
错误消息在这里非常有用

00:10:32.300 --> 00:10:38.269
这样您就可以获得所有功能

00:10:34.130 --> 00:10:43.910
很快，您就知道一切都很好，让我们

00:10:38.269 --> 00:10:45.740
现在关闭它，我只是使用

00:10:43.910 --> 00:10:47.899
断言库很好，但是

00:10:45.740 --> 00:10:52.010
也很有趣，有一个BDD 

00:10:47.899 --> 00:10:53.300
某天的断言类

00:10:52.010 --> 00:10:55.070
给你基本相同

00:10:53.300 --> 00:10:57.199
功能，但带有then关键字，因此

00:10:55.070 --> 00:10:59.029
您可以说在使用BD时给出了

00:10:57.199 --> 00:11:00.050
测试风格，这值得您

00:10:59.029 --> 00:11:02.120
如果您正在做的话也要考虑

00:11:00.050 --> 00:11:04.250
 BDD，你应该是我的意思是有一个

00:11:02.120 --> 00:11:05.959
用例的权利，所以我永远不会说

00:11:04.250 --> 00:11:08.120
从来没有，但出于我们的目的，我认为

00:11:05.959 --> 00:11:09.709
惊喜拖延了他们在这里的事情

00:11:08.120 --> 00:11:13.670
现在我们想要的下一件事

00:11:09.709 --> 00:11:15.350
要测试的是JPA映射，所以

00:11:13.670 --> 00:11:17.029
我们有一堂课，但不是实体， 

00:11:15.350 --> 00:11:18.230
只是知道从结构上讲

00:11:17.029 --> 00:11:22.130
当我给它一个构造函数时是对的

00:11:18.230 --> 00:11:23.660
参数会弹出给定

00:11:22.130 --> 00:11:25.279
对访问器的调用是正确的

00:11:23.660 --> 00:11:27.880
那行得通，我们可以说一个

00:11:25.279 --> 00:11:33.290
预约JPA测试

00:11:27.880 --> 00:11:36.019
好的，有这个，我们可以说

00:11:33.290 --> 00:11:39.170
测试公众空白以及我们将要做什么

00:11:36.019 --> 00:11:41.209
我要做的就是测试映射，所以我想要

00:11:39.170 --> 00:11:43.069
在这里测试GOP的映射

00:11:41.209 --> 00:11:43.660
与Jaypee互动时的实体

00:11:43.069 --> 00:11:47.620
和任何

00:11:43.660 --> 00:11:51.250
经理好，我可以知道模拟还是我

00:11:47.620 --> 00:11:52.510
可以配置所有的JPA和数据

00:11:51.250 --> 00:11:54.400
来源和所有这些东西，但我忘了

00:11:52.510 --> 00:11:55.930
春天和春天已经知道

00:11:54.400 --> 00:11:58.240
所有的布线，所以我为什么要重新创建

00:11:55.930 --> 00:12:01.000
这样我就可以实际使用

00:11:58.240 --> 00:12:03.880
与春季跑步者班和春季

00:12:01.000 --> 00:12:06.670
赛跑者是一个测试赛跑者，我们

00:12:03.880 --> 00:12:08.830
在春季提供布恩和春季

00:12:06.670 --> 00:12:13.480
框架，它是一个测试运行器

00:12:08.830 --> 00:12:15.250
你知道这是Gena的一种机制

00:12:13.480 --> 00:12:18.370
本身就暴露这件事

00:12:15.250 --> 00:12:23.590
这是从j-unit可以用来

00:12:18.370 --> 00:12:25.630
告诉春天-你可以告诉吉娜- 

00:12:23.590 --> 00:12:27.100
让春天参与您的执行

00:12:25.630 --> 00:12:28.660
测试并提供

00:12:27.100 --> 00:12:30.280
协作对象等等

00:12:28.660 --> 00:12:31.630
这非常方便，您需要

00:12:30.280 --> 00:12:33.250
通过这种方式提供更多信息

00:12:31.630 --> 00:12:36.220
会说激活所需的机器

00:12:33.250 --> 00:12:38.680
跑春天，但你知道会发生什么

00:12:36.220 --> 00:12:42.490
情境上下文什么配置

00:12:38.680 --> 00:12:43.960
他们在这里上了很多东西

00:12:42.490 --> 00:12:46.390
需要很多东西

00:12:43.960 --> 00:12:48.010
无法识别的要求

00:12:46.390 --> 00:12:50.290
我们将要参与春天

00:12:48.010 --> 00:12:53.170
以某种方式让我们可以在春季启动时说

00:12:50.290 --> 00:12:54.700
测试，你知道有一个课程

00:12:53.170 --> 00:12:56.440
参数或属性是

00:12:54.700 --> 00:12:57.760
期望配置类

00:12:56.440 --> 00:12:59.500
我们想跑步，我们当然可以做

00:12:57.760 --> 00:13:04.080
那当然是一种选择

00:12:59.500 --> 00:13:08.890
这个问题当然是

00:13:04.080 --> 00:13:10.630
弹簧靴的默认行为

00:13:08.890 --> 00:13:13.570
测试注解是加载整个

00:13:10.630 --> 00:13:16.300
应用程序上下文以及我们正在尝试的一切

00:13:13.570 --> 00:13:18.700
要做的是测试我们与

00:13:16.300 --> 00:13:19.960
 JPA只是entitymanager映射的权利

00:13:18.700 --> 00:13:21.880
只是能量之间的相互作用

00:13:19.960 --> 00:13:24.580
经理和我的实体上的注释

00:13:21.880 --> 00:13:27.400
所以我不想只启动Tomcat 

00:13:24.580 --> 00:13:30.070
测试我更愿意代替

00:13:27.400 --> 00:13:31.570
开始的

00:13:30.070 --> 00:13:34.750
与以下内容相关的应用程序上下文

00:13:31.570 --> 00:13:37.780
持久性和JPA并运行

00:13:34.750 --> 00:13:39.550
然后隔离测试那里的东西

00:13:37.780 --> 00:13:41.260
我们关心的，然后省去

00:13:39.550 --> 00:13:43.750
其余的权利，那更容易做到

00:13:41.260 --> 00:13:46.330
之前的手册世界

00:13:43.750 --> 00:13:47.380
与您一起配置一切

00:13:46.330 --> 00:13:49.690
了解不同的弹簧应用

00:13:47.380 --> 00:13:51.820
上下文xml和配置类

00:13:49.690 --> 00:13:54.310
你当然可以切成薄片

00:13:51.820 --> 00:13:55.420
在层次上的应用

00:13:54.310 --> 00:13:56.710
有点容易做，因为

00:13:55.420 --> 00:13:57.490
他们将有多个配置文件

00:13:56.710 --> 00:13:59.260
你可以

00:13:57.490 --> 00:14:02.020
在您的测试中仅实例化一个

00:13:59.260 --> 00:14:03.940
应用程序上下文XML并忽略

00:14:02.020 --> 00:14:05.950
休息那当然是我的选择

00:14:03.940 --> 00:14:08.140
虽然我不想回到那个

00:14:05.950 --> 00:14:10.330
宁可让spring boot编写

00:14:08.140 --> 00:14:12.610
我很满意的配置

00:14:10.330 --> 00:14:16.029
那，我还剩下什么

00:14:12.610 --> 00:14:18.250
测试自己，说我不想

00:14:16.029 --> 00:14:20.560
运行整个应用程序只是为了测试

00:14:18.250 --> 00:14:24.310
功能的一部分，因此启动了春季

00:14:20.560 --> 00:14:26.350
 1.4具有测试切片的概念，因此

00:14:24.310 --> 00:14:28.870
而不是在春季启动测试中使用

00:14:26.350 --> 00:14:30.010
就像这是其中的一部分

00:14:28.870 --> 00:14:31.720
整体上等于

00:14:30.010 --> 00:14:34.180
整个馅饼基本上而不是使用

00:14:31.720 --> 00:14:36.610
我将要使用数据JPA测试

00:14:34.180 --> 00:14:37.690
类，在这里可以提供一个数字

00:14:36.610 --> 00:14:40.420
不同的东西，但这是什么

00:14:37.690 --> 00:14:41.770
首先要说的是

00:14:40.420 --> 00:14:45.070
要做这三件事

00:14:41.770 --> 00:14:46.839
要注册它将删除

00:14:45.070 --> 00:14:49.060
外部配置

00:14:46.839 --> 00:14:51.040
默认情况下，它将基本上设置为

00:14:49.060 --> 00:14:52.810
将所有的配置类归零

00:14:51.040 --> 00:14:54.370
春天，但通常会运行然后

00:14:52.810 --> 00:14:56.529
将提供一些配置

00:14:54.370 --> 00:14:59.260
应该运行的类，然后

00:14:56.529 --> 00:15:02.470
将贡献我们将要做的事情

00:14:59.260 --> 00:15:03.850
需要有效地测试这种

00:15:02.470 --> 00:15:06.640
东西，包括你的东西

00:15:03.850 --> 00:15:08.410
否则不会进入汽车

00:15:06.640 --> 00:15:09.940
生产代码的配置

00:15:08.410 --> 00:15:12.640
对，这是有价值的东西

00:15:09.940 --> 00:15:14.260
仅在测试环境中并且也是

00:15:12.640 --> 00:15:17.770
它会设置一些默认值

00:15:14.260 --> 00:15:19.570
例如那个测试方法

00:15:17.770 --> 00:15:21.399
这是交易权，因此您可以

00:15:19.570 --> 00:15:23.079
看到这里有很多

00:15:21.399 --> 00:15:25.930
这里发生的事情说这是

00:15:23.079 --> 00:15:28.450
将要覆盖自动

00:15:25.930 --> 00:15:30.370
配置将要排除

00:15:28.450 --> 00:15:32.020
应用程序中的某些类

00:15:30.370 --> 00:15:33.579
我们告诉春天的背景不要

00:15:32.020 --> 00:15:35.079
打扰某些类型只是忽略

00:15:33.579 --> 00:15:37.000
他们假装他们没有注册

00:15:35.079 --> 00:15:37.660
我们不希望他们在此代码库中

00:15:37.000 --> 00:15:39.310
无论如何

00:15:37.660 --> 00:15:40.660
我们要告诉它自动

00:15:39.310 --> 00:15:43.060
配置某些东西，这些

00:15:40.660 --> 00:15:44.980
注释还具有以下属性

00:15:43.060 --> 00:15:49.860
有时会映射到属性，因此

00:15:44.980 --> 00:15:52.209
例如让我们看看回到这里

00:15:49.860 --> 00:15:54.670
我们去那里，我们可以看到缓存

00:15:52.209 --> 00:15:57.459
自动的提供者属性

00:15:54.670 --> 00:15:59.950
配置缓存映射到spring 

00:15:57.459 --> 00:16:01.570
您知道值称为的启动属性文件

00:15:59.950 --> 00:16:03.579
弹簧缓存该类型，因此如果您在

00:16:01.570 --> 00:16:04.600
您的测试文件夹有一个应用程序

00:16:03.579 --> 00:16:06.070
是的购物中心或应用程序是

00:16:04.600 --> 00:16:09.160
具有弹簧缓存的属性

00:16:06.070 --> 00:16:10.630
该类型等于将要设置的类型

00:16:09.160 --> 00:16:13.120
在这个注释上

00:16:10.630 --> 00:16:15.700
用于告知此测试的行为

00:16:13.120 --> 00:16:18.190
仅在测试代码中正确，这样您就可以

00:16:15.700 --> 00:16:21.340
这里很多很多好处

00:16:18.190 --> 00:16:22.510
您还会注意到我们有这个

00:16:21.340 --> 00:16:24.700
在我们有这个之前看了这个

00:16:22.510 --> 00:16:27.700
覆盖自动配置，这告诉

00:16:24.700 --> 00:16:28.540
春天春天引导而不是哦和

00:16:27.700 --> 00:16:31.480
我们还有其他属性的方式

00:16:28.540 --> 00:16:33.670
在这里，我刚刚看到春天的JPSO节目

00:16:31.480 --> 00:16:35.230
等于等于您可以的真实权利

00:16:33.670 --> 00:16:37.780
覆盖它，但等于true 

00:16:35.230 --> 00:16:41.200
默认设置，因此稍后您会看到

00:16:37.780 --> 00:16:43.030
我们使用jpay可以向我们展示

00:16:41.200 --> 00:16:45.160
用于创建实体的DDL 

00:16:43.030 --> 00:16:46.630
嗯，这件事很好

00:16:45.160 --> 00:16:48.450
覆盖自动配置是

00:16:46.630 --> 00:16:50.650
我们告诉春天让你知道

00:16:48.450 --> 00:16:52.990
删除所有自动配置并

00:16:50.650 --> 00:16:55.450
然后让我们从零开始重新创建

00:16:52.990 --> 00:16:59.830
执行JPA所需的配置

00:16:55.450 --> 00:17:01.750
在那个世界中测试我们可以提供

00:16:59.830 --> 00:17:03.610
我们自己的自动配置

00:17:01.750 --> 00:17:05.290
可以说你知道春天工厂的

00:17:03.610 --> 00:17:06.790
元介绍中的文本文件

00:17:05.290 --> 00:17:09.339
可以创建我们自己的文本文件

00:17:06.790 --> 00:17:12.220
该批注的名称org spring 

00:17:09.339 --> 00:17:13.780
框架启动测试Orem JPA进行了APA测试

00:17:12.220 --> 00:17:15.579
等于然后我们自己的汽车

00:17:13.780 --> 00:17:16.870
配置，以便每当我们使用

00:17:15.579 --> 00:17:18.280
日常支付测试我们自己的汽车

00:17:16.870 --> 00:17:20.500
以及配置

00:17:18.280 --> 00:17:22.209
超越这里发生的事情

00:17:20.500 --> 00:17:24.160
整个机制的方式

00:17:22.209 --> 00:17:26.230
当然可以完全重用

00:17:24.160 --> 00:17:28.420
创建自己的测试Isis也许

00:17:26.230 --> 00:17:29.980
你有一些方面

00:17:28.420 --> 00:17:32.460
应在以下位置进行测试的应用程序

00:17:29.980 --> 00:17:34.570
独立于默认值的隔离

00:17:32.460 --> 00:17:35.860
 Spring Boot中的配置和你

00:17:34.570 --> 00:17:37.930
绝对可以做到，你可以打包

00:17:35.860 --> 00:17:39.910
像测试切片注解一样

00:17:37.930 --> 00:17:42.670
这个，然后愚蠢的那个，那个

00:17:39.910 --> 00:17:44.890
一种可行的机制

00:17:42.670 --> 00:17:48.010
仅实例化您的位

00:17:44.890 --> 00:17:50.880
关心什么时候测试让我们看看

00:17:48.010 --> 00:17:54.430
否则我们在这里关心吗

00:17:50.880 --> 00:17:57.220
排除了我们在哈里森

00:17:54.430 --> 00:17:58.840
得到了自动配置啊我们该怎么办

00:17:57.220 --> 00:18:00.760
在这里有自动配置

00:17:58.840 --> 00:18:03.130
很有意义，这只是基础

00:18:00.760 --> 00:18:04.690
春季数据GPA当然也是

00:18:03.130 --> 00:18:07.000
会像我们期望的那样工作，这是现金

00:18:04.690 --> 00:18:09.940
支持，但这将创建一个测试

00:18:07.000 --> 00:18:12.280
数据库，所以在我的构建中

00:18:09.940 --> 00:18:15.340
有一个弹簧启动启动器数据JPA和

00:18:12.280 --> 00:18:16.780
它在这里有一个H2数据库

00:18:15.340 --> 00:18:18.670
对，这是默认设置

00:18:16.780 --> 00:18:22.060
方便，你看我经常用

00:18:18.670 --> 00:18:23.410
我使用h2的各种 spring boot 视频

00:18:22.060 --> 00:18:23.750
因为它嵌入在内存中

00:18:23.410 --> 00:18:26.300
它的

00:18:23.750 --> 00:18:27.530
站起来，我不需要配置

00:18:26.300 --> 00:18:29.030
我不需要的数据源

00:18:27.530 --> 00:18:30.770
任何运行我的本地计算机的东西

00:18:29.030 --> 00:18:32.300
通过扩展意味着您不会

00:18:30.770 --> 00:18:33.860
如果你想玩代码，但是

00:18:32.300 --> 00:18:35.420
当然的基本假设

00:18:33.860 --> 00:18:36.410
永远是你可能不会

00:18:35.420 --> 00:18:37.940
在生产中使用它，你会去

00:18:36.410 --> 00:18:39.410
申请财产并说

00:18:37.940 --> 00:18:41.300
弹出该密码的数据源

00:18:39.410 --> 00:18:42.860
用户名或URL或其他任何内容

00:18:41.300 --> 00:18:44.990
就像我的续集或

00:18:42.860 --> 00:18:46.520
 Postgres或Oracle或其他权利

00:18:44.990 --> 00:18:47.720
续集服务器，您知道这些

00:18:46.520 --> 00:18:49.790
天

00:18:47.720 --> 00:18:52.700
你当然可以做到，你

00:18:49.790 --> 00:18:54.410
可能会说那是

00:18:52.700 --> 00:18:56.900
不会成为您要测试的对象

00:18:54.410 --> 00:18:58.220
我不希望您测试您的

00:18:56.900 --> 00:19:00.260
针对您的生产的应用

00:18:58.220 --> 00:19:01.700
 Oracle数据库太疯狂了，所以

00:19:00.260 --> 00:19:04.280
相反，您将要模拟或

00:19:01.700 --> 00:19:05.210
至少指向不同的数据

00:19:04.280 --> 00:19:07.460
来源，您可以通过

00:19:05.210 --> 00:19:09.020
覆盖属性，但得到

00:19:07.460 --> 00:19:11.930
要非常乏味，您必须现在

00:19:09.020 --> 00:19:13.430
让您知道您的甲骨文

00:19:11.930 --> 00:19:15.830
在某处安装只是为了运行您的

00:19:13.430 --> 00:19:17.630
单元测试，而且评分更高

00:19:15.830 --> 00:19:18.950
因为我们不在乎口腔颜色

00:19:17.630 --> 00:19:22.820
在这一点上，我们正在尝试证明

00:19:18.950 --> 00:19:24.650
是当我映射我的实体时，jpay 

00:19:22.820 --> 00:19:26.180
知道要怎么做

00:19:24.650 --> 00:19:27.590
这就是我们要在这里证明的全部

00:19:26.180 --> 00:19:29.990
我们不需要您的数据库

00:19:27.590 --> 00:19:31.370
知道我们想要一些我们想要的数据库

00:19:29.990 --> 00:19:32.390
那里有东西，但实际上我们只是

00:19:31.370 --> 00:19:34.340
试图证明它是正确的

00:19:32.390 --> 00:19:35.630
将注解映射到位，这是一个

00:19:34.340 --> 00:19:36.590
我们不在乎的下面的一层

00:19:35.630 --> 00:19:38.780
我已经想把它嘲笑了

00:19:36.590 --> 00:19:40.130
我不在乎的人

00:19:38.780 --> 00:19:42.770
注释将要做什么

00:19:40.130 --> 00:19:45.470
它会创建一个内存中的h2 

00:19:42.770 --> 00:19:47.780
即使现在我的数据库

00:19:45.470 --> 00:19:49.400
应用程序正在使用H2我可以说使用

00:19:47.780 --> 00:19:51.140
发布测验，这仍然会创建一个

00:19:49.400 --> 00:19:53.660
测试中为我们提供的内存h2数据库

00:19:51.140 --> 00:19:55.520
上下文，所以我的读写是

00:19:53.660 --> 00:19:57.260
都是这种短暂的记忆

00:19:55.520 --> 00:19:59.090
数据库，它真的非常快

00:19:57.260 --> 00:20:01.250
我们还将自动配置一个

00:19:59.090 --> 00:20:04.310
测试实体经理（如果您曾经交易过） 

00:20:01.250 --> 00:20:07.700
具有低级JPA持久性上下文

00:20:04.310 --> 00:20:11.540
给任何经理加注释，那么你知道

00:20:07.700 --> 00:20:13.070
任何经理都是通用友善的

00:20:11.540 --> 00:20:16.460
休眠会话的版本

00:20:13.070 --> 00:20:17.900
基本上，这是非常低级的，如果

00:20:16.460 --> 00:20:20.870
我们正在尝试用什么做事

00:20:17.900 --> 00:20:22.550
然后测试用例

00:20:20.870 --> 00:20:24.710
测试中的模式将是

00:20:22.550 --> 00:20:26.090
与您的互动不同

00:20:24.710 --> 00:20:29.030
编写作品时可能会期望

00:20:26.090 --> 00:20:30.920
使用实体管理器的代码

00:20:29.030 --> 00:20:32.750
创建一个新对象，它有助于

00:20:30.920 --> 00:20:34.429
仅在

00:20:32.750 --> 00:20:36.230
测试的上下文，该对象是

00:20:34.429 --> 00:20:37.640
叫猜测什么测试敌人经理

00:20:36.230 --> 00:20:39.230
它提供了一些方便

00:20:37.640 --> 00:20:42.290
所以我们也会利用它

00:20:39.230 --> 00:20:45.040
所以在这里，我们可以更好地映射

00:20:42.290 --> 00:20:50.900
将自动连接测试实体经理

00:20:45.040 --> 00:20:52.070
好的，我们将使用

00:20:50.900 --> 00:20:54.679
测试任何经理愿意说的

00:20:52.070 --> 00:20:57.049
这个TEM以及当我们称为持久冲洗时

00:20:54.679 --> 00:20:58.640
找到所以这将是你

00:20:57.049 --> 00:21:00.260
知道它要写三四个

00:20:58.640 --> 00:21:01.730
要将记录写到我们的内存中

00:21:00.260 --> 00:21:03.350
数据库测试你知道测试数据库

00:21:01.730 --> 00:21:05.150
我们有它要冲洗

00:21:03.350 --> 00:21:06.890
会话，然后它将检索

00:21:05.150 --> 00:21:09.080
通过其ID的记录合而为一

00:21:06.890 --> 00:21:10.640
猛扑，所以我们可以证明我们到底是什么

00:21:09.080 --> 00:21:13.429
试图证明给定一个

00:21:10.640 --> 00:21:20.690
新预订哦

00:21:13.429 --> 00:21:23.870
以下形式的null和链

00:21:20.690 --> 00:21:25.429
我们得到了我们期望的记录

00:21:23.870 --> 00:21:31.940
所以有珍妮，我们要说

00:21:25.429 --> 00:21:36.590
断言点简点得到保留

00:21:31.940 --> 00:21:45.429
这个名字等于简·古德，我是

00:21:36.590 --> 00:21:47.090
会说获得身份证不知道是对的

00:21:45.429 --> 00:21:49.419
还有那个

00:21:47.090 --> 00:21:52.100
所以我们有这两种不同的方法

00:21:49.419 --> 00:21:55.250
我们要说的是研究

00:21:52.100 --> 00:21:57.530
保留名等于

00:21:55.250 --> 00:21:58.820
吉恩（Jean）和身份证将不知道我们

00:21:57.530 --> 00:22:01.669
也想说ID应该是

00:21:58.820 --> 00:22:03.860
例如大于一零

00:22:01.669 --> 00:22:06.620
我们不是，这是不言而喻的

00:22:03.860 --> 00:22:07.910
这里的主键好吧，让我们看看

00:22:06.620 --> 00:22:15.169
该代码看起来像什么，让我们运行它

00:22:07.910 --> 00:22:16.730
代码，当然失败了，因为

00:22:15.169 --> 00:22:19.160
我们首先要测试错误的东西

00:22:16.730 --> 00:22:22.040
我忘了撤消旧测试我很高兴

00:22:19.160 --> 00:22:26.559
我们运行了它，所以我们可以修复它，所以让我们

00:22:22.040 --> 00:22:26.559
查看预订

00:22:28.789 --> 00:22:40.049
 jp8测试，这是一个保留

00:22:36.080 --> 00:22:41.070
测试我们更早打破了这个只是为了证明

00:22:40.049 --> 00:22:41.640
会发生什么，我忘了

00:22:41.070 --> 00:22:43.470
恢复它

00:22:41.640 --> 00:22:46.529
好吧，这就是现在

00:22:43.470 --> 00:22:50.220
映射我们将通过运行它进行测试

00:22:46.529 --> 00:22:56.520
相反，现在好了，现在我们运行

00:22:50.220 --> 00:22:58.650
这是映射测试好吗

00:22:56.520 --> 00:23:00.179
可以预见的是， 

00:22:58.650 --> 00:23:01.440
我们有一个未知的实体

00:23:00.179 --> 00:23:03.840
足够公平，让我们回到我们的

00:23:01.440 --> 00:23:07.020
实体并将Jaypee带入

00:23:03.840 --> 00:23:11.309
注释，我们可以运行相同的代码

00:23:07.020 --> 00:23:13.890
再次映射现在打破了另一种方式

00:23:11.309 --> 00:23:16.860
我希望没有标识符

00:23:13.890 --> 00:23:20.070
为实体指定，因此ID为

00:23:16.860 --> 00:23:26.340
产生的价值就在这里

00:23:20.070 --> 00:23:27.779
让我们再运行一​​次

00:23:26.340 --> 00:23:31.020
所以看起来很好而且绿色

00:23:27.779 --> 00:23:33.799
现在让我们测试存储库

00:23:31.020 --> 00:23:36.600
所以我们要说预订

00:23:33.799 --> 00:23:39.990
存储库测试以及我们正在尝试的

00:23:36.600 --> 00:23:41.309
这样做是为了证明我们的习惯

00:23:39.990 --> 00:23:42.779
 Feiner方法行得通，我们不是

00:23:41.309 --> 00:23:44.549
要测试存储库本身，我们

00:23:42.779 --> 00:23:46.409
知道弹簧数据可以正常工作

00:23:44.549 --> 00:23:48.000
不需要证明最终

00:23:46.409 --> 00:23:49.770
方法和保存方法以及所有这些

00:23:48.000 --> 00:23:51.299
东西按预期工作

00:23:49.770 --> 00:23:52.890
一次又一次地测试

00:23:51.299 --> 00:23:53.730
许多其他人或我们

00:23:52.890 --> 00:23:55.860
不必担心那是

00:23:53.730 --> 00:23:58.020
建立框架的好处，但是

00:23:55.860 --> 00:23:59.730
如果我们自定义存储库， 

00:23:58.020 --> 00:24:01.919
提供可以的自定义查找器方法

00:23:59.730 --> 00:24:04.230
有助于验证其是否有效

00:24:01.919 --> 00:24:06.480
正如我们期望的那样，让我们​​做同样的事情

00:24:04.230 --> 00:24:09.779
就像我们在公共场合无效之前所做的一样

00:24:06.480 --> 00:24:12.539
要测试通过预订名称定义

00:24:09.779 --> 00:24:17.120
方法，这当然是您的

00:24:12.539 --> 00:24:22.770
春季跑步者，很抱歉与

00:24:17.120 --> 00:24:25.080
春天赛跑者点类，那将是

00:24:22.770 --> 00:24:28.350
当然是数据jjjp 

00:24:25.080 --> 00:24:36.149
测试我们不好，我们要去

00:24:28.350 --> 00:24:37.919
注入我们所有的预订库

00:24:36.149 --> 00:24:40.020
在这里，我们就是这样的仓库

00:24:37.919 --> 00:24:41.050
当然不存在，所以我们将创建

00:24:40.020 --> 00:24:43.660
那

00:24:41.050 --> 00:24:45.730
否则我们的测试会失败

00:24:43.660 --> 00:24:49.630
我们将在以下情况下使用存储库

00:24:45.730 --> 00:24:51.580
我说这不是我们保存的资料库

00:24:49.630 --> 00:24:53.860
当然，我们要等到新记录才能保存

00:24:51.580 --> 00:24:56.940
我们有save方法，所以我们已经

00:24:53.860 --> 00:24:59.230
在我们第一次失败的测试中，让我们修复一下

00:24:56.940 --> 00:25:01.000
好吧，我会重新创建这个

00:24:59.230 --> 00:25:03.490
方法我们可以做到，但是我们当然

00:25:01.000 --> 00:25:05.020
我们都知道弹簧数据可以

00:25:03.490 --> 00:25:07.450
对于我们来说，所以我们要说@jp a 

00:25:05.020 --> 00:25:09.070
仓库预订管理实体

00:25:07.450 --> 00:25:11.620
我们在那里花了很长时间

00:25:09.070 --> 00:25:13.060
这将给我们保存的记录

00:25:11.620 --> 00:25:15.760
数据库，我们应该能够

00:25:13.060 --> 00:25:20.350
基于此，使用我们的存储库查找

00:25:15.760 --> 00:25:22.150
通过在简和中传递的预订名称

00:25:20.350 --> 00:25:24.310
当然这种方法不存在， 

00:25:22.150 --> 00:25:25.330
那是我们要解决的问题

00:25:24.310 --> 00:25:26.620
必须实际实施

00:25:25.330 --> 00:25:30.660
那是我们的，那将是

00:25:26.620 --> 00:25:30.660
在测试中，所以我们在这里

00:25:30.870 --> 00:25:36.910
保留字符串，我们被命名为

00:25:34.710 --> 00:25:40.420
气道有自定义查找器方法

00:25:36.910 --> 00:25:43.480
现在我们应该测试我们是否应该收集

00:25:40.420 --> 00:25:47.890
你们知道通过预订名称结果

00:25:43.480 --> 00:25:51.940
我们可以说断言

00:25:47.890 --> 00:25:53.230
保留名称，其大小等于1 

00:25:51.940 --> 00:25:54.340
正确的记住我们正在使用测试

00:25:53.230 --> 00:25:56.740
数据库，所以不超过一个

00:25:54.340 --> 00:26:00.910
记录在数据库中，我们想要

00:25:56.740 --> 00:26:07.900
说迭​​代器点下一个点得到

00:26:00.910 --> 00:26:09.370
 ID大于0，我们将

00:26:07.900 --> 00:26:11.830
重新创建迭代器，以便我们获得

00:26:09.370 --> 00:26:13.990
相同的记录又回来了，我们要

00:26:11.830 --> 00:26:17.470
现在得到我要去的预订名称

00:26:13.990 --> 00:26:20.340
说等于简·所有

00:26:17.470 --> 00:26:24.060
好的，让我们现在尝试运行那个

00:26:20.340 --> 00:26:24.060
查找预订名称

00:26:27.270 --> 00:26:32.550
好东西好，所以我们现在有一个

00:26:29.730 --> 00:26:34.830
测试证明我们的互动

00:26:32.550 --> 00:26:36.600
仓库作为

00:26:34.830 --> 00:26:37.860
希望我们可以顺便看到

00:26:36.600 --> 00:26:39.750
我提到的DDL 

00:26:37.860 --> 00:26:41.970
发生得更早，我们可以看到DDL 

00:26:39.750 --> 00:26:43.920
在这里反映在控制台上

00:26:41.970 --> 00:26:46.080
因此，我们现在已经在那里进行了测试

00:26:43.920 --> 00:26:47.880
建立武器API，让我们测试其余的

00:26:46.080 --> 00:26:51.360
我们首先要制造的包装

00:26:47.880 --> 00:26:55.470
我当然要说休息

00:26:51.360 --> 00:26:56.940
控制器测试，这里代替

00:26:55.470 --> 00:26:58.950
使用寿命支持数据

00:26:56.940 --> 00:27:00.240
访问，我们将使用Web MVC 

00:26:58.950 --> 00:27:03.090
测试和测试切片，所以我要使用

00:27:00.240 --> 00:27:03.450
那和春季赛跑者圆点班

00:27:03.090 --> 00:27:07.559
对

00:27:03.450 --> 00:27:09.690
而且at web MVC测试无法计算

00:27:07.559 --> 00:27:12.480
对我们来说，现金支持Web MVC 

00:27:09.690 --> 00:27:13.290
支持模拟NB c--并排除某些

00:27:12.480 --> 00:27:15.030
我们不在乎的对象

00:27:13.290 --> 00:27:17.220
包括那些与

00:27:15.030 --> 00:27:19.380
持久性，所以这不是正确的层

00:27:17.220 --> 00:27:20.490
我们已经存在的测试持久性逻辑

00:27:19.380 --> 00:27:22.320
做到这一点，所以我们想

00:27:20.490 --> 00:27:25.590
理所当然，所以我们要利用

00:27:22.320 --> 00:27:27.179
预先配置的模拟NB C客户端

00:27:25.590 --> 00:27:28.470
正确的就是为此配置的

00:27:27.179 --> 00:27:33.809
我们和我要创建一个新测试

00:27:28.470 --> 00:27:38.040
公共无效得到预订，所以我们

00:27:33.809 --> 00:27:39.450
将证明给定一个要求

00:27:38.040 --> 00:27:43.040
我们得到正确的回应，所以标记亩C 

00:27:39.450 --> 00:27:49.350
执行Muk mu C结果床垫点

00:27:43.040 --> 00:27:52.080
状态还可以，对不起，我们有

00:27:49.350 --> 00:27:56.730
正确执行此结果请求

00:27:52.080 --> 00:28:01.020
在那得到预订的建筑商

00:27:56.730 --> 00:28:03.630
去期待没事

00:28:01.020 --> 00:28:06.000
现在我们在这里添加例外

00:28:03.630 --> 00:28:08.820
这是我们最简单的测试

00:28:06.000 --> 00:28:12.780
那是我可以写的

00:28:08.820 --> 00:28:16.550
现在全部失败amok mu C客户

00:28:12.780 --> 00:28:19.470
这是一种工程

00:28:16.550 --> 00:28:21.720
其余框架之间的协议

00:28:19.470 --> 00:28:26.250
框架错误当然是MVC和

00:28:21.720 --> 00:28:28.710
测试代码在这里我们不是

00:28:26.250 --> 00:28:30.960
实际创建真正的HTTP调用

00:28:28.710 --> 00:28:32.670
这里没有使用HTTP打开的套接字

00:28:30.960 --> 00:28:34.170
穿过电线的有效载荷是什么

00:28:32.670 --> 00:28:36.870
发生的是我们正在提出要求

00:28:34.170 --> 00:28:39.809
通过客户的服务，但是

00:28:36.870 --> 00:28:40.900
客户正在与Spring NB C交谈

00:28:39.809 --> 00:28:42.760
本身不是

00:28:40.900 --> 00:28:44.350
 -Tomcat或类似Tomcat之类的东西

00:28:42.760 --> 00:28:46.510
没有服务器套接字监听

00:28:44.350 --> 00:28:49.150
要求，所以这是直的

00:28:46.510 --> 00:28:50.680
弹簧MVC弹簧MVC正在处理

00:28:49.150 --> 00:28:52.690
好像是实际的请求

00:28:50.680 --> 00:28:54.640
来自网络的请求

00:28:52.690 --> 00:28:57.550
所有处理阶段都在进行

00:28:54.640 --> 00:28:59.230
通过HTTP消息传递

00:28:57.550 --> 00:29:01.390
翻译和消息转换器

00:28:59.230 --> 00:29:04.420
验证您知道的一切

00:29:01.390 --> 00:29:07.350
与处理请求有关的东西

00:29:04.420 --> 00:29:09.610
在这个Tomcat把它变成一个

00:29:07.350 --> 00:29:11.260
 httpservlet请求正确的所有东西

00:29:09.610 --> 00:29:12.850
为我们所做的就像我们

00:29:11.260 --> 00:29:14.170
实际上已经发出了请求，但是

00:29:12.850 --> 00:29:15.280
好处是我们没有启动Tomcat 

00:29:14.170 --> 00:29:18.400
因为我们不在乎Tomcat 

00:29:15.280 --> 00:29:20.350
知道Tomcat可以工作，所以让我们开始吧

00:29:18.400 --> 00:29:22.350
这个基本的测试工作让我们继续

00:29:20.350 --> 00:29:27.480
然后去我们的预订控制器

00:29:22.350 --> 00:29:31.360
再次非常方便，我们可以去这里

00:29:27.480 --> 00:29:40.360
预约休息控制预约

00:29:31.360 --> 00:29:42.580
休息控制器，我们会说确定

00:29:40.360 --> 00:29:45.450
哦，对不起，我们不会在get说

00:29:42.580 --> 00:29:50.679
映射，它将是四个斜线

00:29:45.450 --> 00:29:53.080
保留和观点，我们所有

00:29:50.679 --> 00:29:58.990
要做的是返回一个空数组列表

00:29:53.080 --> 00:30:01.390
正确，因此收藏集的内容为空，我们将

00:29:58.990 --> 00:30:05.230
说休息控制器，我们是如此

00:30:01.390 --> 00:30:07.620
我们将回到这里进行测试并运行

00:30:05.230 --> 00:30:07.620
再来一次

00:30:13.299 --> 00:30:18.019
好了，让我们做更多的事情

00:30:16.100 --> 00:30:23.509
充实的我们也会说我们

00:30:18.019 --> 00:30:28.639
期望内容类型的内容

00:30:23.509 --> 00:30:33.559
等于像这样的应用程序JSON，所以我们

00:30:28.639 --> 00:30:35.240
开始这似乎是好的

00:30:33.559 --> 00:30:36.440
工作良好，让我们现在做点什么

00:30:35.240 --> 00:30:38.659
只是比

00:30:36.440 --> 00:30:42.649
我们实际上会戳结果

00:30:38.659 --> 00:30:46.250
回来，所以标记MVC结果垫

00:30:42.649 --> 00:30:49.100
衬衫点JSON路径，我们将

00:30:46.250 --> 00:30:50.899
说零点ID将是

00:30:49.100 --> 00:30:53.690
等于一升，我们要说

00:30:50.899 --> 00:30:55.279
我再次写的预订名称

00:30:53.690 --> 00:30:57.730
两项测试而不是一项，我不应该做

00:30:55.279 --> 00:31:01.429
它将等于简和

00:30:57.730 --> 00:31:06.019
我们将再次运行它，应该

00:31:01.429 --> 00:31:08.299
好吧，基本上失败吧，所以我们

00:31:06.019 --> 00:31:10.309
知道那个JSON没有价值

00:31:08.299 --> 00:31:10.970
路径表达式，这里我们使用的是J 

00:31:10.309 --> 00:31:13.009
方式

00:31:10.970 --> 00:31:14.360
杰森路径匹配来写集

00:31:13.009 --> 00:31:16.340
我们的支持者，我们不必导入

00:31:14.360 --> 00:31:18.320
任何有效的方法，我们需要

00:31:16.340 --> 00:31:21.019
实际配置我们需要响应

00:31:18.320 --> 00:31:22.700
在响应中添加数据，我们可以

00:31:21.019 --> 00:31:24.320
当然可以通过注入

00:31:22.700 --> 00:31:26.690
资料库，所以这是私人决赛

00:31:24.320 --> 00:31:28.850
预订存储库注入

00:31:26.690 --> 00:31:30.830
进入构造函数，然后在这里我们将

00:31:28.850 --> 00:31:32.840
说返回此类型的保留

00:31:30.830 --> 00:31:34.429
如果我回去，现在查找全部内容

00:31:32.840 --> 00:31:36.200
这次测验你认为会怎样

00:31:34.429 --> 00:31:41.269
碰巧，这行不通，我们知道

00:31:36.200 --> 00:31:43.460
对，没错，它说没有

00:31:41.269 --> 00:31:46.100
光束定义异常无合格

00:31:43.460 --> 00:31:47.809
进行通讯启动测试

00:31:46.100 --> 00:31:49.399
可以预订爪子

00:31:47.809 --> 00:31:51.080
那是因为它被排除在外

00:31:49.399 --> 00:31:52.250
应用程序上下文

00:31:51.080 --> 00:31:53.899
设计我们想要的最后一件事

00:31:52.250 --> 00:31:55.009
测试是我们的数据库层，我们不是

00:31:53.899 --> 00:31:56.539
试图测试我们知道

00:31:55.009 --> 00:31:58.039
我们已经做了大量的工作

00:31:56.539 --> 00:31:59.600
测试量以及该层和

00:31:58.039 --> 00:32:00.919
在它下面证明这行得通

00:31:59.600 --> 00:32:02.840
相反，我们需要做的是模拟

00:32:00.919 --> 00:32:04.820
出预订库必须

00:32:02.840 --> 00:32:06.049
告诉我们的风险控制者使用

00:32:04.820 --> 00:32:08.679
预订资料库，但我们要

00:32:06.049 --> 00:32:10.970
给它一个该对象的伪造版本

00:32:08.679 --> 00:32:12.919
你知道我们知道这是一个界面

00:32:10.970 --> 00:32:15.559
我们可以提供任何实现

00:32:12.919 --> 00:32:16.970
我们想要，这将是可能的

00:32:15.559 --> 00:32:18.409
可以贡献自己的风俗

00:32:16.970 --> 00:32:20.380
我可以说配置类对

00:32:18.409 --> 00:32:24.840
你懂

00:32:20.380 --> 00:32:27.130
让我看看我能不能说我

00:32:24.840 --> 00:32:28.360
猜猜我不能希望你在用

00:32:27.130 --> 00:32:31.149
您可以提供自己的Spring Boot测试

00:32:28.360 --> 00:32:34.059
自定义配置类，我想你

00:32:31.149 --> 00:32:36.730
实际上可以说我的配置并

00:32:34.059 --> 00:32:37.809
这是一个配置类，然后

00:32:36.730 --> 00:32:40.210
提供你自己的类型

00:32:37.809 --> 00:32:42.909
我猜是保留库

00:32:40.210 --> 00:32:48.509
这是一个选择，让我们看看会发生什么

00:32:42.909 --> 00:32:52.179
如果我们做对了，那么模仿点模拟

00:32:48.509 --> 00:32:56.080
班级预订资料库

00:32:52.179 --> 00:33:01.629
会给您答复以及我们的

00:32:56.080 --> 00:33:06.820
当模拟点时要说模拟点

00:33:01.629 --> 00:33:10.779
找到所有点然后返回提高点通过

00:33:06.820 --> 00:33:13.750
列出新的预订，它将是一个l 

00:33:10.779 --> 00:33:17.379
和简，我认为那是我的想法

00:33:13.750 --> 00:33:19.870
那会起作用的，所以让我们看一下返回模拟

00:33:17.379 --> 00:33:21.669
通常可以正常工作，我知道你可以做到

00:33:19.870 --> 00:33:27.600
春天的战利品

00:33:21.669 --> 00:33:27.600
测试框架支持可以正常工作

00:33:28.570 --> 00:33:32.480
好吧，内容类型还没有

00:33:30.800 --> 00:33:34.850
设置，所以我们为不同而输

00:33:32.480 --> 00:33:39.430
原因让我们尝试解决风险

00:33:34.850 --> 00:33:47.620
控制器在这里产生媒体类型

00:33:39.430 --> 00:33:53.570
应用程序JSON utf-8值还可以

00:33:47.620 --> 00:33:59.330
内容类型设置不正确

00:33:53.570 --> 00:34:03.770
我敢打赌这是要做的

00:33:59.330 --> 00:34:05.870
我笨拙地嘲笑对象

00:34:03.770 --> 00:34:07.580
在这里，没关系，实际上

00:34:05.870 --> 00:34:10.159
很好，因为这不合适

00:34:07.580 --> 00:34:11.630
解决问题的方法是我的意思是什么

00:34:10.159 --> 00:34:14.900
我们需要做的是标记该对象

00:34:11.630 --> 00:34:17.060
并用一个模拟豆替换它，这样

00:34:14.900 --> 00:34:18.140
我们可以尝试将其雕刻出来

00:34:17.060 --> 00:34:20.840
自己，并提供一个习惯

00:34:18.140 --> 00:34:23.179
配置类以及您

00:34:20.840 --> 00:34:24.080
看到它是我不确定

00:34:23.179 --> 00:34:25.400
在这方面可能

00:34:24.080 --> 00:34:26.990
配置然后无论哪种方式

00:34:25.400 --> 00:34:28.400
错误的方式来代替我们可以采取

00:34:26.990 --> 00:34:30.890
称为标记豆的对象的优势

00:34:28.400 --> 00:34:33.770
定位而不是模拟豆什么

00:34:30.890 --> 00:34:36.260
这是它为您提供了一个

00:34:33.770 --> 00:34:37.790
地狱春天，这种类型应该是

00:34:36.260 --> 00:34:40.820
有助于应用程序上下文

00:34:37.790 --> 00:34:42.980
它不存在，如果确实存在

00:34:40.820 --> 00:34:44.840
应该用这个模拟对象代替

00:34:42.980 --> 00:34:46.760
所以这里要贡献一个

00:34:44.840 --> 00:34:47.960
输入将要保留的预订存储库

00:34:46.760 --> 00:34:49.820
做一个模拟和房子我不会

00:34:47.960 --> 00:34:51.590
创建得很好，它将只使用mockito 

00:34:49.820 --> 00:34:53.600
就像我在一分钟前尝试使用

00:34:51.590 --> 00:34:57.050
该自定义笨拙的配置类

00:34:53.600 --> 00:34:58.160
你现在春天知道的这个模拟游戏

00:34:57.050 --> 00:35:00.020
启动它会注入这个

00:34:58.160 --> 00:35:01.670
预订存储库将起作用

00:35:00.020 --> 00:35:04.010
它将达到构造函数的范围

00:35:01.670 --> 00:35:05.810
指针将指向模拟对象，并且

00:35:04.010 --> 00:35:07.730
一切都会好起来的

00:35:05.810 --> 00:35:09.380
直到我们到达这一行，我们正在尝试

00:35:07.730 --> 00:35:11.060
从最终方法返回数据

00:35:09.380 --> 00:35:13.610
那当然是行不通的

00:35:11.060 --> 00:35:15.410
因为根据定义模拟是空的

00:35:13.610 --> 00:35:17.330
提供它提供的存根的对象

00:35:15.410 --> 00:35:20.300
抱歉，它提供了默认值

00:35:17.330 --> 00:35:22.100
零和假对吧

00:35:20.300 --> 00:35:24.950
完善它提供的功能

00:35:22.100 --> 00:35:26.930
这基本上是一个空壳

00:35:24.950 --> 00:35:29.210
它将帮助我们超越

00:35:26.930 --> 00:35:30.740
施工阶段在这里，但如果我们需要

00:35:29.210 --> 00:35:32.990
除了站稳脚跟，还能做更多的事情

00:35:30.740 --> 00:35:35.150
只是为了占据空间并过去

00:35:32.990 --> 00:35:36.740
偶然的某个老科本

00:35:35.150 --> 00:35:39.110
那是行不通的，我们需要的是

00:35:36.740 --> 00:35:41.330
存根是一个具有

00:35:39.110 --> 00:35:42.050
预先设定的行为，所以我们在这里

00:35:41.330 --> 00:35:44.150
回到我们的身边

00:35:42.050 --> 00:35:50.930
赖信休息控制器测试，我们

00:35:44.150 --> 00:35:53.300
要说Marketo ma ki toh dot when 

00:35:50.930 --> 00:35:56.710
我发现这个点保留暂停

00:35:53.300 --> 00:36:00.710
然后所有返回的集合点

00:35:56.710 --> 00:36:03.980
单身人士单身人士清单新预订

00:36:00.710 --> 00:36:06.140
所以这里是L和Jane 

00:36:03.980 --> 00:36:08.330
对，所以我们让您知道我们要去

00:36:06.140 --> 00:36:10.250
预编程几乎是空的

00:36:08.330 --> 00:36:16.190
空列表或仅包含一个值，并且

00:36:10.250 --> 00:36:17.270
我要再次运行该测试，所以

00:36:16.190 --> 00:36:18.170
你去那里，你可以看到

00:36:17.270 --> 00:36:20.840
作品

00:36:18.170 --> 00:36:22.520
我们实际上回到了那里

00:36:20.840 --> 00:36:24.110
我们期望的内容类型是

00:36:22.520 --> 00:36:27.170
等于或与应用程序兼容

00:36:24.110 --> 00:36:29.540
天和utf-8，我们的应用程序是

00:36:27.170 --> 00:36:34.100
现在已经过全面测试，所以如果我们去

00:36:29.540 --> 00:36:42.530
命令行CD下载精美

00:36:34.100 --> 00:36:44.750
测试甚至可以清洁包装

00:36:42.530 --> 00:36:47.750
看到测试很快

00:36:44.750 --> 00:36:48.650
清洁光束，我们应该现在

00:36:47.750 --> 00:36:50.540
工作

00:36:48.650 --> 00:36:52.510
 Springwood应用程序现在的概念

00:36:50.540 --> 00:36:54.590
我们在这里看过的是

00:36:52.510 --> 00:36:56.630
诸如此类的概念的基础

00:36:54.590 --> 00:36:58.550
消费者驱动的合同测试休息

00:36:56.630 --> 00:37:01.060
而且我们至少已经看过

00:36:58.550 --> 00:37:03.230
我们期待一些

00:37:01.060 --> 00:37:04.820
在更早的时候

00:37:03.230 --> 00:37:06.710
我们在哪里安装弹簧头

00:37:04.820 --> 00:37:09.140
看着春天的云合约， 

00:37:06.710 --> 00:37:10.790
支持模拟HTTP服务

00:37:09.140 --> 00:37:12.260
还有更多可以讨论的地方

00:37:10.790 --> 00:37:15.260
谈论消息传递，例如

00:37:12.260 --> 00:37:18.290
这也使我们很好地进入

00:37:15.260 --> 00:37:19.550
关于j单元5的另一个讨论

00:37:18.290 --> 00:37:21.170
零5当然是不同的

00:37:19.550 --> 00:37:23.750
编程模型，它不向后

00:37:21.170 --> 00:37:25.430
兼容性不是，不是很好

00:37:23.750 --> 00:37:28.250
向后兼容，说很容易

00:37:25.430 --> 00:37:30.620
足以将代码移至其中

00:37:28.250 --> 00:37:32.930
是一个非常非常强大的范例

00:37:30.620 --> 00:37:34.850
给我们带来很多好处，其中之一

00:37:32.930 --> 00:37:36.320
当然是我不必使用

00:37:34.850 --> 00:37:37.550
这样的有线私人领域我可以

00:37:36.320 --> 00:37:39.410
实际上有构造函数注入

00:37:37.550 --> 00:37:41.360
我的测试还有很多其他的

00:37:39.410 --> 00:37:43.070
令人信服的事情

00:37:41.360 --> 00:37:44.780
大部分是春季测试

00:37:43.070 --> 00:37:47.360
仪器也一样好，我们不能

00:37:44.780 --> 00:37:49.370
使用它们与注释一起运行

00:37:47.360 --> 00:37:52.580
成为简的扩展， 

00:37:49.370 --> 00:37:54.619
五个木星世界，但是

00:37:52.580 --> 00:37:56.479
值得研究，所以

00:37:54.619 --> 00:37:58.969
也许那将是另一个话题

00:37:56.479 --> 00:38:01.489
弹簧在某些时候提示绝缘

00:37:58.969 --> 00:38:02.719
未来还可以，所以我的

00:38:01.489 --> 00:38:05.380
朋友非常感谢您的观看和

00:38:02.719 --> 00:38:05.380
下次见

00:38:12.290 --> 00:38:14.350
您

