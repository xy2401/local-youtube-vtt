WEBVTT
Kind: captions
Language: zh-Hans

00:00:24.850 --> 00:00:29.150
我们的 Spring 粉丝欢迎来到另一个

00:00:27.290 --> 00:00:30.470
在此安装Spring 提示

00:00:29.150 --> 00:00:32.989
分期付款，我们将看看

00:00:30.470 --> 00:00:34.160
 Scala编程语言，让我们

00:00:32.989 --> 00:00:35.630
建立一个新的应用程序，我们将去

00:00:34.160 --> 00:00:38.270
像往常一样开始 Spring Tadeo， 

00:00:35.630 --> 00:00:40.430
我们要用spring boo那个om 

00:00:38.270 --> 00:00:41.930
为了他们最新的

00:00:40.430 --> 00:00:43.489
我们只是将其称为“让我们

00:00:41.930 --> 00:00:45.770
呼叫工件只是因为它是一个演示

00:00:43.489 --> 00:00:47.960
正确，我们将使用响应式Web支持

00:00:45.770 --> 00:00:49.460
将使用反应式MongoDB支持，并且

00:00:47.960 --> 00:00:51.290
我们点击生成，现在注意我们

00:00:49.460 --> 00:00:52.940
当然没有指定

00:00:51.290 --> 00:00:55.580
这里的语言，我们没有任何语言

00:00:52.940 --> 00:00:57.020
开箱即用的默认支持

00:00:55.580 --> 00:00:58.910
学者，但添加起来很简单

00:00:57.020 --> 00:01:01.340
而且没有理由你不能使用

00:00:58.910 --> 00:01:03.170
任何语言，甚至是我们不知道的语言

00:01:01.340 --> 00:01:06.020
在这里有支持注释和

00:01:03.170 --> 00:01:07.280
 JVM上的对象，这有点

00:01:06.020 --> 00:01:11.030
我们将在这里展示什么

00:01:07.280 --> 00:01:15.320
现在在视频中，我们有了一个新的邮政编码

00:01:11.030 --> 00:01:19.780
文件已下载到此处

00:01:15.320 --> 00:01:19.780
好，打开那

00:01:32.439 --> 00:01:36.470
好的，所以我们第一件事

00:01:34.909 --> 00:01:38.420
需要做的是更改Maven构建

00:01:36.470 --> 00:01:39.799
反映我们将要

00:01:38.420 --> 00:01:41.630
使用头骨而不使用Java 

00:01:39.799 --> 00:01:43.880
我们需要做一些事情

00:01:41.630 --> 00:01:47.960
在这里做，让我们来看一下

00:01:43.880 --> 00:01:49.340
我有可以借用的学前班，所以

00:01:47.960 --> 00:01:52.700
我们要做的第一件事就是改变

00:01:49.340 --> 00:01:56.420
构建节正确，所以我们下去

00:01:52.700 --> 00:01:58.100
在这里，构建架包含

00:01:56.420 --> 00:01:59.479
我们的Maven spring boot 插件

00:01:58.100 --> 00:02:02.119
我们仍然想要，但我们想添加一个

00:01:59.479 --> 00:02:04.659
更多插件，所以我要添加Scala 

00:02:02.119 --> 00:02:07.729
 Maven插件非常非常非常

00:02:04.659 --> 00:02:09.200
流行相当流行的依赖

00:02:07.729 --> 00:02:11.510
您可以使用一个非常受欢迎的插件

00:02:09.200 --> 00:02:13.450
您可以用来编译学者代码和

00:02:11.510 --> 00:02:15.799
当然，它依赖于

00:02:13.450 --> 00:02:18.769
此来源表示通话和来源测试

00:02:15.799 --> 00:02:20.390
 Scala目录，所以我们应该注意

00:02:18.769 --> 00:02:24.190
其实我很棒

00:02:20.390 --> 00:02:24.190
重命名这个，所以如果有疤痕

00:02:24.670 --> 00:02:33.160
好的，可以在这里重命名

00:02:30.500 --> 00:02:33.160
显示文件

00:02:37.730 --> 00:02:40.599
好吧

00:02:45.810 --> 00:02:51.709
好吧，我们导入项目

00:02:53.480 --> 00:03:07.980
好的，Scala我们当然不需要这个

00:03:03.140 --> 00:03:10.470
所以让我们进入所有这些，我们不

00:03:07.980 --> 00:03:13.550
需要测试代码，所以我们会得到

00:03:10.470 --> 00:03:18.750
摆脱了这一点，现在我们有了build插件

00:03:13.550 --> 00:03:24.860
现在让我们导入依赖项

00:03:18.750 --> 00:03:24.860
管理，所以我们也会做到这一点， 

00:03:25.400 --> 00:03:30.780
在这里粘贴，这是因为我们需要

00:03:29.489 --> 00:03:32.340
这个通话库，我们需要确保

00:03:30.780 --> 00:03:34.170
他们有正确的版本

00:03:32.340 --> 00:03:36.180
编译器希望

00:03:34.170 --> 00:03:39.450
在类路径上的运行时，这是

00:03:36.180 --> 00:03:40.680
因为我们将使用不同的

00:03:39.450 --> 00:03:43.040
支持三个活跃项目

00:03:40.680 --> 00:03:46.200
流规格包括力

00:03:43.040 --> 00:03:47.940
项目反应堆和Spring 腹板流量

00:03:46.200 --> 00:03:49.080
也将在以后看到其他

00:03:47.940 --> 00:03:51.329
项目，他们想要另一个

00:03:49.080 --> 00:03:53.160
项目想要稍微更新一点的

00:03:51.329 --> 00:03:55.980
几个月新版本的React 

00:03:53.160 --> 00:03:57.239
流1.1，这很好，我们可以

00:03:55.980 --> 00:03:58.860
没有理由不使用它

00:03:57.239 --> 00:03:59.790
向后兼容，因此我们将其添加

00:03:58.860 --> 00:04:01.560
上课的路径，并确保

00:03:59.790 --> 00:04:04.890
一切都上升到那个

00:04:01.560 --> 00:04:08.370
修订，让我们来看看

00:04:04.890 --> 00:04:11.280
否则我们这里有家属

00:04:08.370 --> 00:04:17.120
我们需要自己泡一下

00:04:11.280 --> 00:04:17.120
然后将其复制到剪贴板， 

00:04:18.019 --> 00:04:26.039
在那里带上Scala库

00:04:20.489 --> 00:04:30.030
我们去，最后我们需要确保

00:04:26.039 --> 00:04:32.750
我们的构建插件引用

00:04:30.030 --> 00:04:35.100
我们这里的属性称为版本

00:04:32.750 --> 00:04:36.419
实际上引用是有效的属性

00:04:35.100 --> 00:04:38.970
对，所以我要带那些

00:04:36.419 --> 00:04:43.560
这里的属性也很好

00:04:38.970 --> 00:04:45.150
 maven重新导入，现在我们有了一个

00:04:43.560 --> 00:04:47.010
应该作为的目录结构

00:04:45.150 --> 00:04:49.380
如预期的那样，让我们​​创建一个新的

00:04:47.010 --> 00:04:51.360
打包在这里，我们可以称之为推文

00:04:49.380 --> 00:04:53.039
包，因此域模型将成为

00:04:51.360 --> 00:04:55.130
我从某些地方借来的东西

00:04:53.039 --> 00:04:55.130
的

00:04:55.160 --> 00:05:00.980
一个很常见的例子

00:04:56.990 --> 00:05:02.840
对，所以我在这里用它，所以Scala 

00:05:00.980 --> 00:05:05.200
鸣叫，我们现在有一个软件包

00:05:02.840 --> 00:05:09.620
得到一个新的代码页，我们要说

00:05:05.200 --> 00:05:11.950
鸣叫Scala点，我们将指定

00:05:09.620 --> 00:05:14.990
打包Ryan，所以我会说打包tweets 

00:05:11.950 --> 00:05:16.130
然后我们将创建一些类

00:05:14.990 --> 00:05:17.930
他们需要做的第一件事是创建

00:05:16.130 --> 00:05:22.190
斯普林伍德的入口

00:05:17.930 --> 00:05:27.080
应用程序类 Spring 

00:05:22.190 --> 00:05:30.320
现在就可以启动应用程序了

00:05:27.080 --> 00:05:32.720
 Kotlin Scala程序确实没有

00:05:30.320 --> 00:05:35.210
静力学的概念，以便您创建

00:05:32.720 --> 00:05:39.020
像这样的对象对等体

00:05:35.210 --> 00:05:40.610
它的对象对等体将扩展

00:05:39.020 --> 00:05:43.430
在这种情况下，它称为管道app 

00:05:40.610 --> 00:05:44.840
而且您不必做任何其他事情

00:05:43.430 --> 00:05:49.460
您可以只在其中编写代码

00:05:44.840 --> 00:05:54.980
它的中心，它将起作用

00:05:49.460 --> 00:05:57.800
应用类别，当然还有

00:05:54.980 --> 00:06:01.070
第二个参数或参数，例如

00:05:57.800 --> 00:06:03.500
很好，所以有我们的

00:06:01.070 --> 00:06:05.930
我们的论据是我们的 Spring 

00:06:03.500 --> 00:06:07.250
应用程序本身以及我们只是

00:06:05.930 --> 00:06:08.870
将在这里使用简单的领域模型

00:06:07.250 --> 00:06:10.400
我们将使用推文的域

00:06:08.870 --> 00:06:12.440
对，所以我要将该域名存储在

00:06:10.400 --> 00:06:15.680
数据库，所以我们需要先设计

00:06:12.440 --> 00:06:18.980
所以说基思的班级作者

00:06:15.680 --> 00:06:21.140
然后我们将处理作者的问题

00:06:18.980 --> 00:06:28.040
那里我们还会有另一种情况

00:06:21.140 --> 00:06:31.760
给一个标签标签字符串分类我会的

00:06:28.040 --> 00:06:37.190
还有另一种案例类推文

00:06:31.760 --> 00:06:40.420
具有文本字符串和作者作者

00:06:37.190 --> 00:06:43.340
现在，Scala中的案例类是

00:06:40.420 --> 00:06:45.980
定义对象的简便方法

00:06:43.340 --> 00:06:48.250
具有该或用于的简单属性

00:06:45.980 --> 00:06:51.140
我们想要有吸气剂的人

00:06:48.250 --> 00:06:53.000
和属性自动生成

00:06:51.140 --> 00:06:56.270
对的，所以我们只是免费获得

00:06:53.000 --> 00:06:57.920
定义这个我们可以映射的案例类

00:06:56.270 --> 00:06:59.810
要知道，我们可以像使用它一样

00:06:57.920 --> 00:07:02.060
任何其他对象只是编辑它有一个

00:06:59.810 --> 00:07:03.350
天空中的特殊利益

00:07:02.060 --> 00:07:04.700
语言，因为您也可以将其用于

00:07:03.350 --> 00:07:07.130
图案

00:07:04.700 --> 00:07:09.740
对，这稍微先进一点

00:07:07.130 --> 00:07:12.590
功能，您可以看到很多

00:07:09.740 --> 00:07:14.900
在学者世界里好吧，所以我

00:07:12.590 --> 00:07:19.010
我想在这里获取MongoDB文档

00:07:14.900 --> 00:07:21.830
告诉Scala转到这些字段

00:07:19.010 --> 00:07:23.540
这些构成了我们的赠款

00:07:21.830 --> 00:07:28.450
 javabean属性，所以我会说

00:07:23.540 --> 00:07:28.450
财产权，所以我一直是财产

00:07:28.750 --> 00:07:34.580
是的，最后我想告诉它

00:07:32.450 --> 00:07:38.510
把这些这些个别的东西

00:07:34.580 --> 00:07:45.620
这里变成spring数据文档ID，所以我

00:07:38.510 --> 00:07:46.820
 ID和ID，我们将执行相同的操作

00:07:45.620 --> 00:07:48.620
其实没关系，我们可以离开

00:07:46.820 --> 00:07:55.910
就像他们一样，我们可以做同样的事情

00:07:48.620 --> 00:07:57.440
现在此推文将有一个

00:07:55.910 --> 00:07:59.420
主题标签的嵌套集合，但那些

00:07:57.440 --> 00:08:02.270
主题标签将基于

00:07:59.420 --> 00:08:03.590
推文本身的文字，所以让我们

00:08:02.270 --> 00:08:06.620
在这里创建，我们将说标签

00:08:03.590 --> 00:08:10.640
等于，它将成为一个Java util 

00:08:06.620 --> 00:08:12.200
标签的点集等于，我们

00:08:10.640 --> 00:08:16.010
将身体作为构造函数

00:08:12.200 --> 00:08:19.910
在那里争论文本，我们将分开

00:08:16.010 --> 00:08:26.120
放入其中，然后我们将收集

00:08:19.910 --> 00:08:28.760
结果，让我们来看点收集

00:08:26.120 --> 00:08:30.880
我们正在转这个，我们会说我们

00:08:28.760 --> 00:08:33.700
想说的是，当我得到

00:08:30.880 --> 00:08:35.539
数组中的元素，我们想要

00:08:33.700 --> 00:08:36.680
将它们合并在一起，我们将

00:08:35.539 --> 00:08:38.479
收集在一起，所以我们只说

00:08:36.680 --> 00:08:40.700
在这里使用模式匹配

00:08:38.479 --> 00:08:43.909
在模式匹配中使用便利

00:08:40.700 --> 00:08:45.980
允许自动向下键入

00:08:43.909 --> 00:08:53.480
这里我们要说的论点

00:08:45.980 --> 00:08:56.720
情况T如果T以T开头，那么让我们

00:08:53.480 --> 00:09:00.500
正确返回主题标签和我们的方式

00:08:56.720 --> 00:09:04.490
我们要做的就是说T点

00:09:00.500 --> 00:09:05.870
全部替换，因此请记住我们有

00:09:04.490 --> 00:09:07.730
字符串在这里，我们要确保

00:09:05.870 --> 00:09:09.339
无论我们得到什么弦，我们都会

00:09:07.730 --> 00:09:13.010
取代一言不发的一切

00:09:09.339 --> 00:09:15.200
只有一个空的空间，所以我们经常

00:09:13.010 --> 00:09:19.480
这里的表达将被替换

00:09:15.200 --> 00:09:25.160
一切不是这个，一个字

00:09:19.480 --> 00:09:26.630
这只是一个空的空白空间， 

00:09:25.160 --> 00:09:29.380
这也小写它只是为了得到一个

00:09:26.630 --> 00:09:31.910
规范的定义在这里和

00:09:29.380 --> 00:09:34.160
我们将其恢复为a 

00:09:31.910 --> 00:09:36.620
到Scala集合中现在这不是Java 

00:09:34.160 --> 00:09:38.150
设置以便获得差异

00:09:36.620 --> 00:09:40.970
我们需要实际使用Java 

00:09:38.150 --> 00:09:44.209
根据学者的转换器类型

00:09:40.970 --> 00:09:49.959
集合，我们可以将其变成

00:09:44.209 --> 00:09:53.300
这里有一个Java集，所以我们有

00:09:49.959 --> 00:09:55.430
或哈希标签字段

00:09:53.300 --> 00:09:57.170
变成一个bean属性，然后我们去

00:09:55.430 --> 00:09:58.760
这将很好地工作

00:09:57.170 --> 00:10:00.830
与您完全了解您的

00:09:58.760 --> 00:10:03.110
标准编组基础结构

00:10:00.830 --> 00:10:04.250
例如，杰克（Jack）现在上班了

00:10:03.110 --> 00:10:06.010
实际上有一些样本数据

00:10:04.250 --> 00:10:10.130
数据库，所以让我们创建一个

00:10:06.010 --> 00:10:11.420
初始化对象和这个

00:10:10.130 --> 00:10:13.279
初始化对象只是要

00:10:11.420 --> 00:10:16.370
如您所见，成为应用程序渲染

00:10:13.279 --> 00:10:19.930
我之前做过很多次，所以我们

00:10:16.370 --> 00:10:24.400
要在这里初始化一些数据， 

00:10:19.930 --> 00:10:24.400
我们将返回应用程序运行程序

00:10:26.120 --> 00:10:32.279
好吧，它本身就是一个lambda 

00:10:30.360 --> 00:10:33.570
成为lambda，所以你知道它会

00:10:32.279 --> 00:10:35.730
期待争论，理查德

00:10:33.570 --> 00:10:37.200
抛出异常，否则是

00:10:35.730 --> 00:10:41.660
非常简单，所以我们可以

00:10:37.200 --> 00:10:44.580
实际上现在在这里定义lambda 

00:10:41.660 --> 00:10:46.649
这是你第一次见到我

00:10:44.580 --> 00:10:48.029
在这里找到自定义lambda 

00:10:46.649 --> 00:10:49.980
在前面输入文字，所以它已经知道

00:10:48.029 --> 00:10:52.380
这是应用程序参数

00:10:49.980 --> 00:10:54.240
这是该接口所期望的

00:10:52.380 --> 00:10:55.850
它支持相同的功能

00:10:54.240 --> 00:10:57.600
 Java八接口机制

00:10:55.850 --> 00:11:00.899
介绍正确，所以这是非常

00:10:57.600 --> 00:11:03.540
方便，但在Scala功能中，我们

00:11:00.899 --> 00:11:04.830
方法是一流的公民，所以你

00:11:03.540 --> 00:11:07.230
可以创建一个没有的lambda 

00:11:04.830 --> 00:11:08.220
与功能的任何关系

00:11:07.230 --> 00:11:10.770
界面，您可以只创建一个lambda 

00:11:08.220 --> 00:11:13.200
那你知道一个独立的

00:11:10.770 --> 00:11:15.570
存在的lambda只是为了

00:11:13.200 --> 00:11:18.450
现有的，它不必符合

00:11:15.570 --> 00:11:20.339
到特定类型，因此在这种情况下

00:11:18.450 --> 00:11:22.410
我们有一个我们有一个 bean 

00:11:20.339 --> 00:11:24.630
返回此函数接口，并

00:11:22.410 --> 00:11:26.550
的实现，在此我们

00:11:24.630 --> 00:11:29.459
要初始化数据库本身，所以

00:11:26.550 --> 00:11:32.910
让我们创建一个存储库来操作

00:11:29.459 --> 00:11:35.300
可以使用存储库的推文

00:11:32.910 --> 00:11:38.160
 Spring 的数据再次，但在斯卡拉

00:11:35.300 --> 00:11:39.570
接口是所谓的

00:11:38.160 --> 00:11:42.660
特质，他们也有能力

00:11:39.570 --> 00:11:45.570
指定类似于Java的行为

00:11:42.660 --> 00:11:50.040
八个接口现在可以编写，所以特质

00:11:45.570 --> 00:11:51.900
就我们的目的而言，与

00:11:50.040 --> 00:11:53.430
我们知道您是界面，但他们可以做到

00:11:51.900 --> 00:11:59.480
还有很多，所以我要说鸣叫

00:11:53.430 --> 00:12:02.640
存储库扩展了反应性Mongo 

00:11:59.480 --> 00:12:04.320
仓库管理实体和通知

00:12:02.640 --> 00:12:06.870
括号在这里是

00:12:04.320 --> 00:12:09.300
等效于成角度的电流

00:12:06.870 --> 00:12:11.459
 Java中的括号，以便进行管理

00:12:09.300 --> 00:12:14.850
推文类型

00:12:11.459 --> 00:12:17.190
其主键为string类型，我们

00:12:14.850 --> 00:12:22.110
现在可以将其注入到我们的bean中

00:12:17.190 --> 00:12:25.140
定义TR推文存储库

00:12:22.110 --> 00:12:29.040
而且你知道只是为了缩短

00:12:25.140 --> 00:12:32.160
我要去的事

00:12:29.040 --> 00:12:36.180
预选了一些我们发布的推文

00:12:32.160 --> 00:12:38.790
可以使用，所以有一些推文

00:12:36.180 --> 00:12:40.350
来自社区中的一些人

00:12:38.790 --> 00:12:43.649
包括我自己，然后是两个人

00:12:40.350 --> 00:12:46.529
 Scala和Akka和我的Pin社区

00:12:43.649 --> 00:12:48.060
我们将使用他们知道的用途

00:12:46.529 --> 00:12:50.990
该样本数据在这里

00:12:48.060 --> 00:12:53.510
作为我们的榜样，所以我们要

00:12:50.990 --> 00:12:56.790
首先要通话全部删除

00:12:53.510 --> 00:12:59.880
从你知道删除的一切

00:12:56.790 --> 00:13:02.930
数据库，然后我们将保存

00:12:59.880 --> 00:13:08.579
一切都用这个仓库

00:13:02.930 --> 00:13:09.450
在那儿传递推文，然后

00:13:08.579 --> 00:13:11.010
会得到另一件事

00:13:09.450 --> 00:13:15.079
然后从数据库返回所有内容

00:13:11.010 --> 00:13:20.519
我们将订阅该数据， 

00:13:15.079 --> 00:13:22.589
在这里，你看到我，你知道我在做

00:13:20.519 --> 00:13:24.089
应该很简单的东西

00:13:22.589 --> 00:13:26.220
如果您曾经使用过，看起来非常熟悉

00:13:24.089 --> 00:13:30.000
项目反应堆直接进入我们的项目

00:13:26.220 --> 00:13:32.490
反应堆是支持的反应性API 

00:13:30.000 --> 00:13:36.380
 Spring Webb Flux Web运行时和

00:13:32.490 --> 00:13:38.670
 Spring 2.0和Spring Framework 五

00:13:36.380 --> 00:13:40.829
您最终有能力

00:13:38.670 --> 00:13:43.589
在一天结束时与

00:13:40.829 --> 00:13:45.390
反应堆特定项目的架设

00:13:43.589 --> 00:13:48.839
项目特定类型称为磁通和

00:13:45.390 --> 00:13:51.390
这些是模型的的子类型

00:13:48.839 --> 00:13:53.010
称为发布者和发布者的接口

00:13:51.390 --> 00:13:54.140
代码来自反应流

00:13:53.010 --> 00:13:56.250
主动的权利，所以我们看到了

00:13:54.140 --> 00:13:59.430
我们在这里看到的对工艺路线的依赖

00:13:56.250 --> 00:14:03.000
反应堆上的反应流类型101 

00:13:59.430 --> 00:14:04.949
课堂路径，所以我们将在这里使用

00:14:03.000 --> 00:14:07.199
在我们的代码中，我们将采取

00:14:04.949 --> 00:14:08.040
那里的共同点的优势

00:14:07.199 --> 00:14:10.140
我们将利用这一事实

00:14:08.040 --> 00:14:11.910
与其他项目整合

00:14:10.140 --> 00:14:13.829
像我们一样的反应式流倡议

00:14:11.910 --> 00:14:15.420
为右滴做，所以我们要用

00:14:13.829 --> 00:14:17.490
在这里，我们要说我想

00:14:15.420 --> 00:14:19.709
打印有关此推文的信息

00:14:17.490 --> 00:14:21.870
所以很明显，我们将使用

00:14:19.709 --> 00:14:24.180
多行字符串在这里还有另一件事

00:14:21.870 --> 00:14:32.000
真的很好，在scala里面

00:14:24.180 --> 00:14:32.000
我们会说

00:14:36.340 --> 00:14:46.200
点作者点句柄，我们将打印

00:14:42.250 --> 00:14:48.400
删除主题标签，使T点主题标签和

00:14:46.200 --> 00:14:59.770
然后我们将打印出一个新字符串

00:14:48.400 --> 00:15:02.589
我们来看一下T点txt和

00:14:59.770 --> 00:15:05.980
我们这样做实际上还可以打印出来

00:15:02.589 --> 00:15:07.720
换行了，所以我们就是

00:15:05.980 --> 00:15:09.520
在Scala中使用多行字符串

00:15:07.720 --> 00:15:11.200
我们使用令牌非常方便

00:15:09.520 --> 00:15:12.520
你知道有一个标记化

00:15:11.200 --> 00:15:15.940
实际上让我们的机制

00:15:12.520 --> 00:15:17.260
实际在变量中取消引用

00:15:15.940 --> 00:15:19.570
自己串起来我的意思是你知道

00:15:17.260 --> 00:15:21.010
他们被插值到

00:15:19.570 --> 00:15:22.660
为我们自动设置字符串

00:15:21.010 --> 00:15:25.360
这些生活模板的种类

00:15:22.660 --> 00:15:26.410
很酷，然后我们将打印

00:15:25.360 --> 00:15:28.089
当我们看到正确的一切时， 

00:15:26.410 --> 00:15:30.460
我们是这是我们提供的消费者

00:15:28.089 --> 00:15:32.740
一个lambda在这里，所以应该看起来你知道

00:15:30.460 --> 00:15:35.860
如果你要来的话很简单

00:15:32.740 --> 00:15:38.380
来自Java 8 

00:15:35.860 --> 00:15:41.200
这个例子不应该太多

00:15:38.380 --> 00:15:42.970
肉背很大

00:15:41.200 --> 00:15:44.800
从认知上讲，您会注意到的唯一一件事

00:15:42.970 --> 00:15:47.260
是我们必须在等号中使用

00:15:44.800 --> 00:15:50.800
负号的正确Java是负号

00:15:47.260 --> 00:15:52.480
符号等于4 Scala，否则为

00:15:50.800 --> 00:15:55.300
如果看起来应该很简单

00:15:52.480 --> 00:15:57.970
你，如果你用过卡门，这看起来

00:15:55.300 --> 00:15:59.350
也相当简单

00:15:57.970 --> 00:16:00.280
这里有很多很棒的东西

00:15:59.350 --> 00:16:03.370
让我们看看是否可行，让我们继续

00:16:00.280 --> 00:16:06.250
并运行该应用程序并确认

00:16:03.370 --> 00:16:09.550
我们已经成功地写了

00:16:06.250 --> 00:16:10.960
这六个不同的推文及其

00:16:09.550 --> 00:16:13.060
您知道的作者您可以看到

00:16:10.960 --> 00:16:15.220
反映到这里到控制台

00:16:13.060 --> 00:16:16.900
数据库相当好，我们就这样

00:16:15.220 --> 00:16:21.400
有我们的数据，您知道主题标签

00:16:16.900 --> 00:16:23.760
以及作者和内容

00:16:21.400 --> 00:16:27.700
正确的推文就在那里

00:16:23.760 --> 00:16:29.470
现在我们想建立一个服务，所以

00:16:27.700 --> 00:16:32.070
让我们建立一个服务，以便我们可以

00:16:29.470 --> 00:16:37.390
建立一个REST API，所以我们说类

00:16:32.070 --> 00:16:40.870
推特服务，我们将利用

00:16:37.390 --> 00:16:44.770
信息库和服务的信息

00:16:40.870 --> 00:16:48.490
刚刚添加到Java中，您知道它是一个

00:16:44.770 --> 00:16:50.170
带有M的Spring 对象

00:16:48.490 --> 00:16:54.250
使用原型注释服务

00:16:50.170 --> 00:16:56.680
对于我们的第一功能

00:16:54.250 --> 00:16:58.990
我们将有一个端点或服务

00:16:56.680 --> 00:17:04.240
称为推文，这一切都将要做

00:16:58.990 --> 00:17:06.610
只是返回所有推文，但是你

00:17:04.240 --> 00:17:09.280
知道我们现在可以使用它来发送一个

00:17:06.610 --> 00:17:11.890
 REST API，所以我想第一种方法

00:17:09.280 --> 00:17:14.530
要做那将是休息一下

00:17:11.890 --> 00:17:22.930
控制器spring web flex控制器

00:17:14.530 --> 00:17:26.500
好的，我们要说鸣叫休息

00:17:22.930 --> 00:17:36.330
控制器好了，这里的端点

00:17:26.500 --> 00:17:38.830
映射数组鸣叫聋的鸣叫和

00:17:36.330 --> 00:17:46.230
我们将注入推文

00:17:38.830 --> 00:17:48.850
服务，所以TR tweet服务点tweets 

00:17:46.230 --> 00:17:53.410
好的，我们走了，所以有我们的

00:17:48.850 --> 00:17:54.670
还有我们的其余端点，让我们继续

00:17:53.410 --> 00:17:57.280
看看现在是否有效，您会注意到

00:17:54.670 --> 00:17:59.080
这种智慧暗示着我

00:17:57.280 --> 00:18:01.150
应该做得更好我应该非常

00:17:59.080 --> 00:18:02.620
在这里明确返回值

00:18:01.150 --> 00:18:05.080
对，我，那可能很好

00:18:02.620 --> 00:18:07.360
建议，但正因为如此

00:18:05.080 --> 00:18:08.800
 Scala中的复杂类型推断

00:18:07.360 --> 00:18:11.080
这将实际上

00:18:08.800 --> 00:18:13.270
如果我们将其正确放置就可以了

00:18:11.080 --> 00:18:15.670
这就是我要的

00:18:13.270 --> 00:18:16.990
这样做是明确的，然后返回

00:18:15.670 --> 00:18:18.280
价值，这可能是一个好主意

00:18:16.990 --> 00:18:21.370
特别是如果您要确保他们

00:18:18.280 --> 00:18:24.070
不要破坏你知道的东西

00:18:21.370 --> 00:18:25.810
这样的话运行时就是消费者哦

00:18:24.070 --> 00:18:28.270
它因为门廊而失败了，所以

00:18:25.810 --> 00:18:29.950
在这种情况下，运行时是

00:18:28.270 --> 00:18:33.610
此方法的消费者对

00:18:29.950 --> 00:18:34.330
此方法的调用者，但是您知道

00:18:33.610 --> 00:18:37.780
我会做正确的事

00:18:34.330 --> 00:18:39.640
我们是否返回了一个合理的对象，但是

00:18:37.780 --> 00:18:40.930
并非总是如此

00:18:39.640 --> 00:18:44.220
那可能是个好建议，让我们看看

00:18:40.930 --> 00:18:46.060
鸣叫那里是我们的

00:18:44.220 --> 00:18:48.960
来自戴维斯的推文

00:18:46.060 --> 00:18:51.220
我现在似乎在工作

00:18:48.960 --> 00:18:53.080
想要创建另一个端点

00:18:51.220 --> 00:18:55.480
仅返回所有

00:18:53.080 --> 00:18:57.580
所有这些不同的主题标签

00:18:55.480 --> 00:18:58.780
推文归一化对，我想返回

00:18:57.580 --> 00:19:01.750
唯一的主题标签，因为一些

00:18:58.780 --> 00:19:03.340
在这里将标签多于一次

00:19:01.750 --> 00:19:03.920
我不想拥有的不同推文

00:19:03.340 --> 00:19:05.870
商场

00:19:03.920 --> 00:19:09.020
想得到你知道的我

00:19:05.870 --> 00:19:10.840
一次让所有人发推特标签

00:19:09.020 --> 00:19:15.950
所以在这里创建一个新的端点

00:19:10.840 --> 00:19:18.320
称为hashtags聋子hashtags和

00:19:15.950 --> 00:19:20.480
为了使这个工作，我们将使用

00:19:18.320 --> 00:19:24.650
 akka流库现在akka 

00:19:20.480 --> 00:19:26.030
流是我固定的一个图书馆

00:19:24.650 --> 00:19:28.220
以前称为潮汐安全区

00:19:26.030 --> 00:19:32.630
他们是斯卡拉的牧羊人

00:19:28.220 --> 00:19:33.830
语言和Akka流有一些非常

00:19:32.630 --> 00:19:38.810
有趣的功能

00:19:33.830 --> 00:19:41.390
引人注目的功能II认为这是一个

00:19:38.810 --> 00:19:43.160
在这个简单的例子中我正在做什么

00:19:41.390 --> 00:19:45.640
可能只用就可以摆脱

00:19:43.160 --> 00:19:49.070
反应堆，但说有一些

00:19:45.640 --> 00:19:53.390
集成了有趣的集成

00:19:49.070 --> 00:19:54.830
超越你的阿卡溪流

00:19:53.390 --> 00:19:58.070
知道我们在这里做什么

00:19:54.830 --> 00:20:00.050
应该调查一下，那就是

00:19:58.070 --> 00:20:00.770
整点我们现在不是

00:20:00.050 --> 00:20:03.260
我想证明的是

00:20:00.770 --> 00:20:05.990
因为它只是一种JVM语言

00:20:03.260 --> 00:20:07.880
因为我们在

00:20:05.990 --> 00:20:12.590
指令流的条款有

00:20:07.880 --> 00:20:14.090
没有理由你的世界对你

00:20:12.590 --> 00:20:16.430
知道有点忽略这个宝藏

00:20:14.090 --> 00:20:17.780
大量的功能

00:20:16.430 --> 00:20:19.400
您可以从中使用很多东西

00:20:17.780 --> 00:20:21.050
该生态系统的社区，而您

00:20:19.400 --> 00:20:24.020
应该绝对这样做吧

00:20:21.050 --> 00:20:26.540
扩展您的应用程序的丰富性

00:20:24.020 --> 00:20:29.240
通过引进最好的

00:20:26.540 --> 00:20:30.980
组件，所以这只是一个简单的

00:20:29.240 --> 00:20:33.320
现在的例子，您知道以便我们

00:20:30.980 --> 00:20:34.220
在中获取akka流库

00:20:33.320 --> 00:20:37.640
工艺路线，我们需要引入

00:20:34.220 --> 00:20:41.630
依赖关系，因此它将说DEP开始为

00:20:37.640 --> 00:20:45.440
复制到剪贴板，我们将

00:20:41.630 --> 00:20:47.570
带来了以后会说我们要

00:20:45.440 --> 00:20:50.840
使用ARCA流依赖版本

00:20:47.570 --> 00:20:52.910
已经为Scala编译的

00:20:50.840 --> 00:20:55.100
十二，这又一次，你知道它将

00:20:52.910 --> 00:20:56.240
碰巧你有不同的图书馆

00:20:55.100 --> 00:20:59.510
编译为不同版本的

00:20:56.240 --> 00:21:01.400
 Scala，因为有时不容易

00:20:59.510 --> 00:21:02.510
保持互操作性或向后

00:21:01.400 --> 00:21:06.380
当他们改变

00:21:02.510 --> 00:21:07.610
正确的语言，就是你知道的

00:21:06.380 --> 00:21:09.800
事实是对的

00:21:07.610 --> 00:21:11.600
没关系，这没什么大不了的

00:21:09.800 --> 00:21:13.070
在实践中，所以你可以看到我们已经

00:21:11.600 --> 00:21:14.810
引入正确的版本，我们已经

00:21:13.070 --> 00:21:16.490
在这里有一个名为Scala major的物业

00:21:14.810 --> 00:21:19.700
我们使用的那个版本叫做

00:21:16.490 --> 00:21:23.710
 12人中有2人是这样

00:21:19.700 --> 00:21:28.420
现在我们要说我们想

00:21:23.710 --> 00:21:30.710
取所有数据，所以我们说源

00:21:28.420 --> 00:21:33.620
对，我们要引入一个源类型

00:21:30.710 --> 00:21:38.750
从极端使用DSL的头骨和

00:21:33.620 --> 00:21:42.290
我们要说给我们所有的一切

00:21:38.750 --> 00:21:46.010
在这条推文中，这可能是发布者

00:21:42.290 --> 00:21:48.500
记住反应堆中的通量和

00:21:46.010 --> 00:21:51.800
单一型从发布者延伸而来

00:21:48.500 --> 00:21:53.120
极端z'他们有自己的

00:21:51.800 --> 00:21:56.690
它自己的处理模型

00:21:53.120 --> 00:22:00.740
管道定义模型，这很容易

00:21:56.690 --> 00:22:04.100
足以产生数据

00:22:00.740 --> 00:22:07.460
进入极端管道

00:22:04.100 --> 00:22:09.860
从反应流中很容易

00:22:07.460 --> 00:22:11.780
生成馈送的数据

00:22:09.860 --> 00:22:13.760
从一个极端的管道

00:22:11.780 --> 00:22:14.990
反应性流发布者，所以

00:22:13.760 --> 00:22:17.000
我们正在说的是创建一个

00:22:14.990 --> 00:22:19.760
来自反应堆的回声流源

00:22:17.000 --> 00:22:22.940
流发布者，然后我们拥有

00:22:19.760 --> 00:22:25.850
是我们有收藏的地方

00:22:22.940 --> 00:22:27.950
的推文，但我们不想要这个

00:22:25.850 --> 00:22:30.500
不想标签不是我们想要的

00:22:27.950 --> 00:22:34.460
我们想要获取主题标签的每条推文

00:22:30.500 --> 00:22:42.490
对，我们要说Java转换器

00:22:34.460 --> 00:22:46.850
 Scala将点设置为可以并设置

00:22:42.490 --> 00:22:54.230
那么我们想获取来的数据

00:22:46.850 --> 00:22:58.210
返回，我们想要减少它

00:22:54.230 --> 00:22:59.870
所以我们想创建一个

00:22:58.210 --> 00:23:03.679
这里的收藏，所以我们要

00:22:59.870 --> 00:23:05.150
说一个B，我们将要加入

00:23:03.679 --> 00:23:09.320
他们在一起，这些都是

00:23:05.150 --> 00:23:10.850
我们将向您发送的收藏集添加

00:23:09.320 --> 00:23:13.040
他们彼此之间基本上就是这样

00:23:10.850 --> 00:23:14.300
这是在添加

00:23:13.040 --> 00:23:15.920
彼此之间或等待它们

00:23:14.300 --> 00:23:18.050
彼此然后从那里我们想要

00:23:15.920 --> 00:23:19.160
以极限压平一切

00:23:18.050 --> 00:23:23.150
我们将收集

00:23:19.160 --> 00:23:24.919
集合并将其展平为一个

00:23:23.150 --> 00:23:26.140
我们所拥有的东西的集合

00:23:24.919 --> 00:23:29.090
正确的收藏，所以当您使用

00:23:26.140 --> 00:23:30.169
地图concat回调在这里，我们

00:23:29.090 --> 00:23:31.460
会告诉它使用这个放克

00:23:30.169 --> 00:23:34.460
所谓的身份，基本上说

00:23:31.460 --> 00:23:36.049
给定我们转向权利的迭代

00:23:34.460 --> 00:23:41.859
所以我们要做的就是

00:23:36.049 --> 00:23:46.489
在那里，最后我们要带

00:23:41.859 --> 00:23:49.999
我们从中得到的数据

00:23:46.489 --> 00:23:53.149
该源，我们想运行它，我们

00:23:49.999 --> 00:23:55.039
想要实际终止

00:23:53.149 --> 00:23:56.539
定义并做得好

00:23:55.039 --> 00:23:59.450
在这里，我们有许多不同的

00:23:56.539 --> 00:24:03.139
我们可以做但我想要的事情

00:23:59.450 --> 00:24:07.519
我要做的就是获取数据并使用

00:24:03.139 --> 00:24:09.399
正确的下沉，所以我先说

00:24:07.519 --> 00:24:12.639
所有尝试并获得进口

00:24:09.399 --> 00:24:12.639
好吧

00:24:12.789 --> 00:24:22.210
作为发布者，真实且为了我们

00:24:18.139 --> 00:24:26.679
使用这个我们需要提供一个

00:24:22.210 --> 00:24:29.899
实现者实现者实现者

00:24:26.679 --> 00:24:33.649
很好地在阿卡实现机制

00:24:29.899 --> 00:24:36.950
流是它用的是什么

00:24:33.649 --> 00:24:39.379
部署然后运行

00:24:36.950 --> 00:24:41.809
在这里定义管道，所以它说

00:24:39.379 --> 00:24:43.909
您知道发布者的来源

00:24:41.809 --> 00:24:45.619
这些处理操作会发生， 

00:24:43.909 --> 00:24:47.690
所以我们必须要做的只是

00:24:45.619 --> 00:24:49.700
一张图，如果你要一直到这里

00:24:47.690 --> 00:24:53.659
有一个图形定义，但没有

00:24:49.700 --> 00:24:55.700
告诉那些在哪里

00:24:53.659 --> 00:24:57.470
图中的组件将获得

00:24:55.700 --> 00:24:58.220
被处死，所以你跟你谈谈

00:24:57.470 --> 00:24:59.960
物化器

00:24:58.220 --> 00:25:01.460
好一个物化器，非常

00:24:59.960 --> 00:25:02.989
方便被称为演员

00:25:01.460 --> 00:25:05.419
物化器只是物化器

00:25:02.989 --> 00:25:07.700
代表演员akka的代表

00:25:05.419 --> 00:25:10.100
在这种情况下运行的系统是

00:25:07.700 --> 00:25:13.190
当地演员，所以我们要说我们知道

00:25:10.100 --> 00:25:16.639
创造一个演员基比兹，你知道我们

00:25:13.190 --> 00:25:18.499
知道akka演员系统中的k 

00:25:16.639 --> 00:25:25.639
演员中间层的眼睛是基于

00:25:18.499 --> 00:25:30.340
对，所以配置梁聋人演员

00:25:25.639 --> 00:25:34.369
系统等于actor系统点创建

00:25:30.340 --> 00:25:38.499
美丽的斯卡拉好吧，然后我们创建

00:25:34.369 --> 00:25:40.599
另一个光束在这里聋人演员

00:25:38.499 --> 00:25:43.760
物化器

00:25:40.599 --> 00:25:47.270
等于演员物化点

00:25:43.760 --> 00:25:47.420
在这里创建这个点演员系统

00:25:47.270 --> 00:25:49.010
是

00:25:47.420 --> 00:25:52.130
所以我们现在有了这两个不同的

00:25:49.010 --> 00:25:53.680
组件，我们将采取

00:25:52.130 --> 00:25:57.770
这里成熟的激光的优势

00:25:53.680 --> 00:26:01.960
我们会说是行事或实现权利

00:25:57.770 --> 00:26:04.100
非常好，我们会通过，所以我

00:26:01.960 --> 00:26:06.230
现在注意，我在这里提供了

00:26:04.100 --> 00:26:07.970
我可以定义隐式参数

00:26:06.230 --> 00:26:09.590
作为某个地方或我的隐式变量

00:26:07.970 --> 00:26:11.150
可以明确证明它通过了

00:26:09.590 --> 00:26:12.710
这就是我正在做的

00:26:11.150 --> 00:26:15.080
可选参数（如果有） 

00:26:12.710 --> 00:26:16.760
隐式类型在某处

00:26:15.080 --> 00:26:20.870
在其中定义了一个隐式变量

00:26:16.760 --> 00:26:23.120
范围然后该类型是

00:26:20.870 --> 00:26:25.340
定义或任何类型的任何地方

00:26:23.120 --> 00:26:27.320
需要那种类型的地方

00:26:25.340 --> 00:26:30.860
标记为隐式，此呼叫者将看起来

00:26:27.320 --> 00:26:32.780
在封闭范围或封闭范围内

00:26:30.860 --> 00:26:34.910
范围并寻找一些东西

00:26:32.780 --> 00:26:38.140
定义该类型，它将提供它

00:26:34.910 --> 00:26:40.610
自动为我们服务，如果您有

00:26:38.140 --> 00:26:42.590
传递给方法的参数

00:26:40.610 --> 00:26:44.180
调用多个连续方法

00:26:42.590 --> 00:26:45.380
打电话，但是你知道你要

00:26:44.180 --> 00:26:47.030
一次定义就可以了

00:26:45.380 --> 00:26:48.620
在您调用那些不同的方法之前

00:26:47.030 --> 00:26:50.810
调用您可以将其定义为隐式

00:26:48.620 --> 00:26:53.030
范围的东西，它将只是

00:26:50.810 --> 00:26:55.100
自动假定为

00:26:53.030 --> 00:26:56.240
参数，这是一个魔术

00:26:55.100 --> 00:26:59.420
如果您以前没看过，但是

00:26:56.240 --> 00:27:01.060
确实使事情更加简洁

00:26:59.420 --> 00:27:05.150
知道然后有助于建设

00:27:01.060 --> 00:27:06.290
 DSL很好，在这种情况下，所以

00:27:05.150 --> 00:27:08.150
我们只是非常明确的

00:27:06.290 --> 00:27:09.860
要说用这个演员物化器

00:27:08.150 --> 00:27:11.600
这是提供Spring 的那个

00:27:09.860 --> 00:27:13.250
对我们来说，这是

00:27:11.600 --> 00:27:15.080
构造函数语法，如果您曾经使用过

00:27:13.250 --> 00:27:17.000
在此之前致电评论似乎非常

00:27:15.080 --> 00:27:18.260
熟悉，这是一个构造函数，不是

00:27:17.000 --> 00:27:20.500
当然唯一，但是我们

00:27:18.260 --> 00:27:23.470
创建一个我们要告诉的构造函数

00:27:20.500 --> 00:27:26.330
我们要创建Java Java的Scala 

00:27:23.470 --> 00:27:28.820
具有构造函数的JVM对象

00:27:26.330 --> 00:27:30.730
两个属性之一称为TR，而当

00:27:28.820 --> 00:27:34.970
叫做am，我们可以参考

00:27:30.730 --> 00:27:36.740
这些构造函数参数

00:27:34.970 --> 00:27:38.890
方法的主体，好像我们有一个

00:27:36.740 --> 00:27:42.620
构造函数加上一个正确的字段

00:27:38.890 --> 00:27:46.040
参考那里没事，所以给

00:27:42.620 --> 00:27:47.900
我们支持发行商，让我们变得非常

00:27:46.040 --> 00:27:50.270
清楚明确，但确实可以

00:27:47.900 --> 00:27:54.710
它给了我们可以使用的发布者

00:27:50.270 --> 00:27:57.500
这里有一个tweet的发布者

00:27:54.710 --> 00:27:59.420
而且因为spring web flex 

00:27:57.500 --> 00:28:01.130
不，它本来就知道如何处理

00:27:59.420 --> 00:28:03.470
发布者，这应该工作正常

00:28:01.130 --> 00:28:04.940
我没有使用反应堆或其他任何东西

00:28:03.470 --> 00:28:07.190
我只是使用三个活动流

00:28:04.940 --> 00:28:10.340
主动和 Spring 与

00:28:07.190 --> 00:28:13.670
围绕反应式构建的API 

00:28:10.340 --> 00:28:17.150
流规范好了，让我们

00:28:13.670 --> 00:28:19.940
看到它再次运行，我们只想

00:28:17.150 --> 00:28:24.680
有一个休息的终点不要李，所以我们会

00:28:19.940 --> 00:28:30.100
说一个标签标签数组，我将其称为

00:28:24.680 --> 00:28:36.580
主题标签唯一端点主题标签

00:28:30.100 --> 00:28:39.160
 ash标签的发布者等于T点

00:28:36.580 --> 00:28:47.920
主题标签

00:28:39.160 --> 00:28:47.920
好吧，再次运行

00:28:51.140 --> 00:29:01.049
标签唯一好

00:28:57.260 --> 00:29:03.210
所以我们创建了新的端点

00:29:01.049 --> 00:29:05.370
使用回声流项目等等

00:29:03.210 --> 00:29:06.720
我们知道您刚刚创建了一个非常

00:29:05.370 --> 00:29:08.640
简单的例子在这里，我们有一个

00:29:06.720 --> 00:29:09.720
很简单的例子，但是有

00:29:08.640 --> 00:29:11.330
应该突出的几件事

00:29:09.720 --> 00:29:13.919
首先这还不是全部

00:29:11.330 --> 00:29:15.929
与Kotlin或groovy或

00:29:13.919 --> 00:29:17.220
任何其他现代语言

00:29:15.929 --> 00:29:20.070
有些尊重，一切都不同

00:29:17.220 --> 00:29:22.380
 Java 8 Rande的开发者谨记

00:29:20.070 --> 00:29:25.200
马丁·诺德（Martin Nordisk）他是马丁还是

00:29:22.380 --> 00:29:27.390
几内亚Scala的创建者是一位

00:29:25.200 --> 00:29:31.590
在Java上工作的人

00:29:27.390 --> 00:29:33.270
本身，所以他保留了很多

00:29:31.590 --> 00:29:36.450
 Java的好东西很多

00:29:33.270 --> 00:29:39.299
不需要改变就不对

00:29:36.450 --> 00:29:41.760
所以您注意到我们使用了这个词

00:29:39.299 --> 00:29:43.679
扩展以扩展其他类型

00:29:41.760 --> 00:29:45.450
正确的例子，所以你知道很多

00:29:43.679 --> 00:29:47.250
事情应该感到非常非常

00:29:45.450 --> 00:29:48.540
熟悉并且有让步

00:29:47.250 --> 00:29:51.000
您需要能够

00:29:48.540 --> 00:29:52.049
中断其他JVM技术

00:29:51.000 --> 00:29:54.840
这就是为什么你有这种能力

00:29:52.049 --> 00:29:58.230
合理地合成bean属性

00:29:54.840 --> 00:30:00.240
随便我们看看功能

00:29:58.230 --> 00:30:03.030
在这里编程，您可以看到它非常

00:30:00.240 --> 00:30:07.169
即使没有任何反应也很容易

00:30:03.030 --> 00:30:08.940
处理数据以进行拆分的上下文

00:30:07.169 --> 00:30:10.710
它可以在此使用模式匹配

00:30:08.940 --> 00:30:14.880
情况就是我们在这里做的

00:30:10.710 --> 00:30:18.090
用案例2简化

00:30:14.880 --> 00:30:19.559
否则T是一种

00:30:18.090 --> 00:30:20.940
处理这种类型的

00:30:19.559 --> 00:30:22.290
事情本来应该是一个if语句

00:30:20.940 --> 00:30:24.030
那不会是一个

00:30:22.290 --> 00:30:26.100
表达，因为一切都在

00:30:24.030 --> 00:30:28.590
 Scala是一种表达，它变成了

00:30:26.100 --> 00:30:30.480
我可以组成的很干净的东西

00:30:28.590 --> 00:30:32.429
可以写成一堆表达式

00:30:30.480 --> 00:30:33.780
一个接一个地与拥有

00:30:32.429 --> 00:30:34.919
中间变量是

00:30:33.780 --> 00:30:37.380
那很方便

00:30:34.919 --> 00:30:40.169
我们也有这些案例类

00:30:37.380 --> 00:30:42.720
这些使定义您的工作变得很简单

00:30:40.169 --> 00:30:44.340
知道非常普遍的事情GTO，或者你知道

00:30:42.720 --> 00:30:47.160
我们使用的东西只是非常数据

00:30:44.340 --> 00:30:48.990
从一层来回

00:30:47.160 --> 00:30:52.650
堆叠到另一个，这是

00:30:48.990 --> 00:30:54.240
用scala编写很自然，但是它也可以

00:30:52.650 --> 00:30:57.559
就像我们预期的那样工作正常

00:30:54.240 --> 00:31:00.740
 Spring ，等等

00:30:57.559 --> 00:31:08.570
我们您知道您可以看到

00:31:00.740 --> 00:31:10.220
你在 Spring 写的代码是你

00:31:08.570 --> 00:31:12.590
知道它仍然在工作仍然很有价值

00:31:10.220 --> 00:31:15.410
在这里仍然有用，但您也可以

00:31:12.590 --> 00:31:16.429
其他一些项目的优势

00:31:15.410 --> 00:31:18.050
还有其他一些

00:31:16.429 --> 00:31:18.980
您可能想承担的项目

00:31:18.050 --> 00:31:20.480
优势，也许

00:31:18.980 --> 00:31:22.370
相反，也许你已经有了他们

00:31:20.480 --> 00:31:24.410
而且您还想利用

00:31:22.370 --> 00:31:26.929
 Spring 的生态系统

00:31:24.410 --> 00:31:28.610
到目前为止，我们已经看过一种非常

00:31:26.929 --> 00:31:31.160
传统的 Spring 

00:31:28.610 --> 00:31:32.900
应用程序，我正在休息

00:31:31.160 --> 00:31:34.130
控制器在这里我用的是我的

00:31:32.900 --> 00:31:36.050
休息控制我正在使用 rest controller 

00:31:34.130 --> 00:31:37.640
在这里定义其余的端点

00:31:36.050 --> 00:31:39.320
说值得记住的是

00:31:37.640 --> 00:31:42.110
由于功能性反应

00:31:39.320 --> 00:31:43.820
Spring 5内的端点，我们可以

00:31:42.110 --> 00:31:49.610
也让我们用一种不同的方式说

00:31:43.820 --> 00:31:52.010
类推文路由配置正确

00:31:49.610 --> 00:31:54.830
鸣叫路由配置，这只是一个

00:31:52.010 --> 00:32:02.179
配置对象，在这里我要

00:31:54.830 --> 00:32:08.390
定义路线定义

00:32:02.179 --> 00:32:10.760
功能点路线，我们会说和

00:32:08.390 --> 00:32:12.470
当然，我们将在这里做什么

00:32:10.760 --> 00:32:15.380
相反，我们要说他们想

00:32:12.470 --> 00:32:19.460
向Twitter注入推文服务，以便

00:32:15.380 --> 00:32:22.130
有这个，我们会说我们想要

00:32:19.460 --> 00:32:28.900
打个惠普电话，所以要求

00:32:22.130 --> 00:32:33.590
谓词没有得到，我们会说

00:32:28.900 --> 00:32:35.390
鸣叫，我必须提供处理程序

00:32:33.590 --> 00:32:36.770
再次运行，这是相当容易的

00:32:35.390 --> 00:32:40.750
要做的事情，因为它是功能

00:32:36.770 --> 00:32:40.750
界面，我要说要求

00:32:41.080 --> 00:32:51.080
服务器响应点ok点主体等于

00:32:46.700 --> 00:32:53.360
推特服务点推特指定

00:32:51.080 --> 00:32:57.850
这里的第二个参数是

00:32:53.360 --> 00:32:57.850
好的推文类

00:32:58.070 --> 00:33:02.540
好了，现在有几个

00:33:00.770 --> 00:33:04.220
事情在这里发生，这是一种

00:33:02.540 --> 00:33:05.630
首先值得我们了解

00:33:04.220 --> 00:33:08.270
这里有很多额外的类型

00:33:05.630 --> 00:33:10.640
您知道谓词类型或合格的

00:33:08.270 --> 00:33:11.900
输入类型引用，以便我们可以使用

00:33:10.640 --> 00:33:13.760
等价于此处的静态导入

00:33:11.900 --> 00:33:16.700
说导入那个的所有成员

00:33:13.760 --> 00:33:19.640
这使得它更干净一点

00:33:16.700 --> 00:33:20.900
看看那边我们也有一个lambda 

00:33:19.640 --> 00:33:23.180
但我真的不在乎

00:33:20.900 --> 00:33:25.040
参数我根本不使用它

00:33:23.180 --> 00:33:26.450
真的没用我可以放下

00:33:25.040 --> 00:33:28.970
名称，在Scala中很常见

00:33:26.450 --> 00:33:30.320
看下划线，只是说给它

00:33:28.970 --> 00:33:32.030
是任何旧名字，是的

00:33:30.320 --> 00:33:33.740
承认它在那里，但我们

00:33:32.030 --> 00:33:37.310
不在乎，这是一个

00:33:33.740 --> 00:33:39.760
没关系好吧，这就是现在的路线

00:33:37.310 --> 00:33:42.320
我想有另一条路线

00:33:39.760 --> 00:33:44.660
标签，所以我要创建另一个

00:33:42.320 --> 00:33:51.350
路线获取推文，我将其称为

00:33:44.660 --> 00:33:56.410
主题标签唯一唯一且与

00:33:51.350 --> 00:34:02.900
好的点之前，身体鸣叫服务点

00:33:56.410 --> 00:34:04.040
 hashtags类的hashtag在那里

00:34:02.900 --> 00:34:05.960
如果运行此命令，我们现在是如此

00:34:04.040 --> 00:34:08.390
你知道这是配置

00:34:05.960 --> 00:34:12.590
功能反应式建筑

00:34:08.390 --> 00:34:14.060
我认为REST API非常方便

00:34:12.590 --> 00:34:16.130
在这种情况下更加简洁，让我们

00:34:14.060 --> 00:34:18.380
继续并立即重新启动

00:34:16.130 --> 00:34:20.630
在这种情况下简明扼要，最终得到

00:34:18.380 --> 00:34:21.830
同样的结果，只是一个

00:34:20.630 --> 00:34:25.910
风格的问题只是什么的问题

00:34:21.830 --> 00:34:27.770
您希望可以，所以我们已经研究了

00:34:25.910 --> 00:34:29.060
一个你知道我们看过它的学者我们

00:34:27.770 --> 00:34:31.280
看着在建立一个新项目

00:34:29.060 --> 00:34:32.300
 Scala我们构建了一个简单的REST API， 

00:34:31.280 --> 00:34:34.730
然后我们把它变成一个功能

00:34:32.300 --> 00:34:38.390
反应性逮捕API（如果您看到了我的任何

00:34:34.730 --> 00:34:40.730
 spring 5和以前的视频或讲座

00:34:38.390 --> 00:34:42.950
 Spring 的webflix不应该全部

00:34:40.730 --> 00:34:44.710
对你不熟悉的，如果你已经

00:34:42.950 --> 00:34:47.660
看过我以前的任何演讲

00:34:44.710 --> 00:34:50.660
与 Spring 共同使用以及如何

00:34:47.660 --> 00:34:52.970
不应该感到不熟悉

00:34:50.660 --> 00:34:54.710
你，如果你看过我的演讲

00:34:52.970 --> 00:34:56.720
关于使用 Spring 展位，然后再次

00:34:54.710 --> 00:34:59.900
不应该感到不熟悉

00:34:56.720 --> 00:35:02.600
你真的真的Scala是一种很好的语言

00:34:59.900 --> 00:35:04.640
你知道那只是一点点

00:35:02.600 --> 00:35:05.900
这里不同，因此共同点

00:35:04.640 --> 00:35:07.970
您可能要做的事情

00:35:05.900 --> 00:35:10.850
特别是在与

00:35:07.970 --> 00:35:13.610
 Spring 生态系统（如果有） 

00:35:10.850 --> 00:35:15.110
耐心架设什么小东西

00:35:13.610 --> 00:35:16.880
我们必须在这里设置才能获得

00:35:15.110 --> 00:35:18.560
建立下去，那么你可以很

00:35:16.880 --> 00:35:21.950
我很快就知道了很多

00:35:18.560 --> 00:35:23.180
使用多种语言的人群

00:35:21.950 --> 00:35:24.770
除了Java外，您还了解很多

00:35:23.180 --> 00:35:27.620
除了Java与其他角度不同

00:35:24.770 --> 00:35:30.590
充满希望的 Spring 生态系统

00:35:27.620 --> 00:35:32.060
这使您开始工作并富有成效，所以

00:35:30.590 --> 00:35:34.540
感谢您的收看，我们将

00:35:32.060 --> 00:35:34.540
下次见

00:35:40.760 --> 00:35:42.820
您

