WEBVTT
Kind: captions
Language: zh-Hans

00:00:14.099 --> 00:00:18.189
嘿，春季粉丝

00:00:17.020 --> 00:00:20.410
春天的提示，我们将看看如何

00:00:18.189 --> 00:00:22.140
建立功能强大的服务

00:00:20.410 --> 00:00:24.490
即使面对

00:00:22.140 --> 00:00:25.990
下游服务中断或故障

00:00:24.490 --> 00:00:27.430
因此，让我们继续构建一个简单的

00:00:25.990 --> 00:00:30.490
应用程序，我们将使用

00:00:27.430 --> 00:00:31.630
一个你知道春天引导春天一些

00:00:30.490 --> 00:00:33.370
Spring 云中的组件

00:00:31.630 --> 00:00:35.379
让我们构建一个名为

00:00:33.370 --> 00:00:37.180
强大的客户，我们将使用Springs 

00:00:35.379 --> 00:00:39.970
网络支持我们自然使用致动器

00:00:37.180 --> 00:00:41.320
我们将使用Spring 重试

00:00:39.970 --> 00:00:44.350
重试库，我将使用

00:00:41.320 --> 00:00:46.570
 Netflix歇斯底里断路器好吗

00:00:44.350 --> 00:00:48.430
现在我们点击生成，但是我不想

00:00:46.570 --> 00:00:50.290
只使用春季试用版

00:00:48.430 --> 00:00:53.039
我们在扣式应用程序上拥有的

00:00:50.290 --> 00:00:58.960
要继续，而是添加一个

00:00:53.039 --> 00:01:02.410
春天的初步版本，我们尝试

00:00:58.960 --> 00:01:03.670
我们建立的这个版本是1.2 rc1 

00:01:02.410 --> 00:01:05.560
版本尚未发布，是我

00:01:03.670 --> 00:01:08.470
就是说版本本身就是

00:01:05.560 --> 00:01:11.200
已发布，但不是GA，因此我们要

00:01:08.470 --> 00:01:14.970
利用GA上的ga unnhhh 

00:01:11.200 --> 00:01:18.369
转到我们的构建，然后查看非GA代码

00:01:14.970 --> 00:01:19.840
更改依赖项，添加

00:01:18.369 --> 00:01:22.060
快照存储库是里程碑

00:01:19.840 --> 00:01:24.610
我们构建的存储库，我们想

00:01:22.060 --> 00:01:27.039
通过重新定义属性来促进

00:01:24.610 --> 00:01:30.340
打算晋升，否则你就会知道

00:01:27.039 --> 00:01:34.149
春天版本重试到这里1 

00:01:30.340 --> 00:01:35.759
到1个点即可做到c1和

00:01:34.149 --> 00:01:38.170
我们可以构建一个应用程序，所以让我们

00:01:35.759 --> 00:01:40.300
让我们继续并设置好舞台

00:01:38.170 --> 00:01:45.759
让我们构建一个名为

00:01:40.300 --> 00:01:48.550
摇摇欲坠的商务服务好，这是

00:01:45.759 --> 00:01:50.649
去这个可能会叫一些

00:01:48.550 --> 00:01:52.720
其他你知道的Web服务吧

00:01:50.649 --> 00:01:53.770
他们会打电话给其他人做吗

00:01:52.720 --> 00:01:55.509
一些有趣的事情，所以我想做

00:01:53.770 --> 00:01:56.830
对，我们将得出某种

00:01:55.509 --> 00:02:01.989
我们实际上不会去的数字

00:01:56.830 --> 00:02:03.130
麻烦打另一个服务，因为

00:02:01.989 --> 00:02:05.890
我们可以伪造它，我们可以

00:02:03.130 --> 00:02:08.200
如果数学点随机数大于0.5 

00:02:05.890 --> 00:02:11.170
那我们就抛出一个异常

00:02:08.200 --> 00:02:12.190
抛出新的运行时异常信号

00:02:11.170 --> 00:02:14.340
那是错的，什么时候

00:02:12.190 --> 00:02:16.840
发生，我们也会睡觉，所以我们会

00:02:14.340 --> 00:02:18.220
如果您愿意，我们将模拟超时

00:02:16.840 --> 00:02:20.860
叫它一些服务会睡觉

00:02:18.220 --> 00:02:23.020
 3秒钟，它将引用你知道的

00:02:20.860 --> 00:02:24.700
相应地添加异常

00:02:23.020 --> 00:02:26.290
我们只返回1，所以如果一切

00:02:24.700 --> 00:02:27.140
正常，我们将返回1，否则返回

00:02:26.290 --> 00:02:29.060
好

00:02:27.140 --> 00:02:30.410
称这个为吉姆服务

00:02:29.060 --> 00:02:32.840
虚构的服务，总有一天会发生

00:02:30.410 --> 00:02:36.319
错误，我们希望能够锻炼

00:02:32.840 --> 00:02:38.110
这项可能不稳定的服务

00:02:36.319 --> 00:02:42.950
创建一个 rest controller ，所以我会说

00:02:38.110 --> 00:02:44.480
不稳定的 rest controller 和我们的风险

00:02:42.950 --> 00:02:46.040
控制器将利用

00:02:44.480 --> 00:02:48.080
新创建的摇摇欲坠的商务服务

00:02:46.040 --> 00:02:52.730
会拒绝他们创建

00:02:48.080 --> 00:02:55.190
我们在这里的接线员会说

00:02:52.730 --> 00:02:56.840
这种摇摇欲坠的商业服务等于摇摇欲坠

00:02:55.190 --> 00:02:58.340
商业服务，我们将

00:02:56.840 --> 00:03:03.440
创建一个将要

00:02:58.340 --> 00:03:05.769
暴露于公共诠释热潮中，而我们

00:03:03.440 --> 00:03:10.940
我们要做的是将

00:03:05.769 --> 00:03:11.959
驱动器号（如果可能），我们将

00:03:10.940 --> 00:03:13.489
处理异常，那该怎么办

00:03:11.959 --> 00:03:15.620
发生是如果有例外权利

00:03:13.489 --> 00:03:18.890
现在该异常会冒出来- 

00:03:15.620 --> 00:03:22.820
春天的MVC，然后将报告它

00:03:18.890 --> 00:03:24.320
应该是HTTP状态码500 

00:03:22.820 --> 00:03:26.120
回应，让我们继续尝试

00:03:24.320 --> 00:03:32.060
让我们继续前进，看看我们得到了什么

00:03:26.120 --> 00:03:35.989
为此，我们将看到它旋转起来

00:03:32.060 --> 00:03:44.360
端口8080零，对不起80转发

00:03:35.989 --> 00:03:47.390
那里的砍伐热潮还可以

00:03:44.360 --> 00:03:49.670
例外，它超时并冒泡

00:03:47.390 --> 00:03:52.040
直到Spring MVC处理程序层和

00:03:49.670 --> 00:03:53.510
我们得到了状态码500 

00:03:52.040 --> 00:03:55.850
服务器出现处理错误

00:03:53.510 --> 00:03:57.049
这是一个一般性错误，我们的客户

00:03:55.850 --> 00:03:59.239
不会知道该怎么办

00:03:57.049 --> 00:04:00.170
对，最好不要放那个客户

00:03:59.239 --> 00:04:01.910
在第一的位置

00:04:00.170 --> 00:04:04.299
相反，如果可以的话，我们应该处理

00:04:01.910 --> 00:04:06.440
然后可能会优雅降级

00:04:04.299 --> 00:04:08.510
我们要确保如果有

00:04:06.440 --> 00:04:10.250
我们做某事的错

00:04:08.510 --> 00:04:12.769
比传播大量脂肪更好

00:04:10.250 --> 00:04:14.510
 Java堆栈跟踪或更重要的是

00:04:12.769 --> 00:04:17.390
一个国家应该是这样的状态代码

00:04:14.510 --> 00:04:19.010
给客户或潜在的iPhone客户

00:04:17.390 --> 00:04:20.419
或的html5 JavaScript客户端

00:04:19.010 --> 00:04:24.200
例如，他们不会有任何想法

00:04:20.419 --> 00:04:25.460
该怎么办所以我们知道

00:04:24.200 --> 00:04:27.650
让我们介绍一个后备机制

00:04:25.460 --> 00:04:30.380
有几种方法可以做到这一点

00:04:27.650 --> 00:04:31.700
当然我是，我想你们很多

00:04:30.380 --> 00:04:34.460
已经知道这是我们可以使用

00:04:31.700 --> 00:04:35.900
 Netflix歇斯底里断路器

00:04:34.460 --> 00:04:38.120
库，我在类路径上

00:04:35.900 --> 00:04:40.220
这是春天的云启动器

00:04:38.120 --> 00:04:41.690
历史

00:04:40.220 --> 00:04:44.240
为了激活它，我只需要

00:04:41.690 --> 00:04:45.500
配置我需要激活

00:04:44.240 --> 00:04:48.730
那里的断路器，你会说

00:04:45.500 --> 00:04:52.430
启用断路器，然后我

00:04:48.730 --> 00:04:54.410
注释我可能不稳定的业务

00:04:52.430 --> 00:04:56.410
我在hystrix注释的逻辑

00:04:54.410 --> 00:04:58.850
命令现在这实际上是一个

00:04:56.410 --> 00:05:04.000
来自第三方库的注释

00:04:58.850 --> 00:05:08.200
名为Jovanka和japonica的

00:05:04.000 --> 00:05:10.490
基础断路器库

00:05:08.200 --> 00:05:12.170
Spring 组件模型

00:05:10.490 --> 00:05:14.030
提供这个不错的注释，我不是

00:05:12.170 --> 00:05:16.280
真的非常喜欢打电话或

00:05:14.030 --> 00:05:18.080
告诉它使用字符串调用什么

00:05:16.280 --> 00:05:21.350
对，这有点丑陋，但是

00:05:18.080 --> 00:05:23.840
 hystrix本身有很多好处

00:05:21.350 --> 00:05:26.060
对，所以我们在这里说的是

00:05:23.840 --> 00:05:27.740
想调用它的后备方法

00:05:26.060 --> 00:05:29.240
除了名字外，签名相同

00:05:27.740 --> 00:05:31.100
当然具有相同的签名

00:05:29.240 --> 00:05:33.890
我们是说我们想打电话

00:05:31.100 --> 00:05:35.360
该方法，然后只返回两个

00:05:33.890 --> 00:05:36.560
而不是一个，所以你知道很多

00:05:35.360 --> 00:05:38.240
高效能的网站会做到这一点

00:05:36.560 --> 00:05:40.310
他们会说些好话的

00:05:38.240 --> 00:05:41.780
前往搜寻引擎服务

00:05:40.310 --> 00:05:43.760
而且现在不可用，所以

00:05:41.780 --> 00:05:45.380
相反，这里有一些机器学习

00:05:43.760 --> 00:05:48.380
来自网络的建议是

00:05:45.380 --> 00:05:49.910
它不是你想要的，但是

00:05:48.380 --> 00:05:52.220
总比没有好，所以肯定

00:05:49.910 --> 00:05:53.530
现在给我们带来了一些好处

00:05:52.220 --> 00:05:55.910
实际发生的场景是

00:05:53.530 --> 00:05:57.350
页面技巧正在创建所谓的

00:05:55.910 --> 00:06:00.290
命令对象，基本上是一个

00:05:57.350 --> 00:06:01.490
上下文是一个可运行的，但是

00:06:00.290 --> 00:06:03.610
在内部管理

00:06:01.490 --> 00:06:07.580
这种断路器的上下文和

00:06:03.610 --> 00:06:10.250
断路器提供隔离

00:06:07.580 --> 00:06:11.600
以两种不同的方式之一，我们

00:06:10.250 --> 00:06:13.580
想要确保的是，如果此方法

00:06:11.600 --> 00:06:15.200
如果扔掉，它会脱离轨道

00:06:13.580 --> 00:06:20.180
抛出一个我们不运行的异常

00:06:15.200 --> 00:06:21.440
永久封锁的风险

00:06:20.180 --> 00:06:24.110
例子或永久失去我们的

00:06:21.440 --> 00:06:26.450
控制该线程的一种方式

00:06:24.110 --> 00:06:29.060
可以隔离潜在不稳定的服务

00:06:26.450 --> 00:06:31.090
服务电话是使用隔离

00:06:29.060 --> 00:06:33.919
模式称为线程右，这是一个

00:06:31.090 --> 00:06:35.600
神秘中的可配置设置

00:06:33.919 --> 00:06:37.880
最终导致产生的断路器

00:06:35.600 --> 00:06:39.470
每次调用一个新线程

00:06:37.880 --> 00:06:42.380
这样使用断路器的方法

00:06:39.470 --> 00:06:44.780
它包装了此方法调用

00:06:42.380 --> 00:06:46.520
在线程的主体之内

00:06:44.780 --> 00:06:48.140
表示如果您有任何一种

00:06:46.520 --> 00:06:49.940
使用或依赖的组件

00:06:48.140 --> 00:06:52.270
在本地线程上，有很多

00:06:49.940 --> 00:06:53.930
他们中的平均数

00:06:52.270 --> 00:06:55.520
应用

00:06:53.930 --> 00:06:57.169
还是现在不尝试

00:06:55.520 --> 00:06:57.470
如果您要管理交易

00:06:57.169 --> 00:06:58.970
做

00:06:57.470 --> 00:07:00.350
追踪，如果你想做春天

00:06:58.970 --> 00:07:02.780
安全，我的意思是有各种各样的

00:07:00.350 --> 00:07:03.710
那里毛茸茸的地方，然后你

00:07:02.780 --> 00:07:05.539
需要知道那个权利

00:07:03.710 --> 00:07:06.770
变成一种东西

00:07:05.539 --> 00:07:07.550
在您的代码下面，您可能不会

00:07:06.770 --> 00:07:10.490
知道那件事

00:07:07.550 --> 00:07:13.220
现在可能会出错，它可以继续

00:07:10.490 --> 00:07:15.560
错误和非常沉默的神秘方式

00:07:13.220 --> 00:07:17.690
隔离事物的另一种方法是

00:07:15.560 --> 00:07:19.430
使用信号量，这限制了

00:07:17.690 --> 00:07:21.199
可以称为它的线程限制了

00:07:19.430 --> 00:07:23.930
可以调用的调用数

00:07:21.199 --> 00:07:25.970
通过将调用限制为

00:07:23.930 --> 00:07:27.530
信号量，而带有线程选项

00:07:25.970 --> 00:07:29.300
您限制了调用的数量

00:07:27.530 --> 00:07:31.970
可以通过限制数量来调用

00:07:29.300 --> 00:07:33.080
池中的线程，您知道它们是

00:07:31.970 --> 00:07:36.020
他们权衡了信号量

00:07:33.080 --> 00:07:37.460
这种方法显然要便宜得多

00:07:36.020 --> 00:07:38.990
资源条件等

00:07:37.460 --> 00:07:41.090
它不会创建一个新线程

00:07:38.990 --> 00:07:44.210
为对方的每一次该死的坟墓服务

00:07:41.090 --> 00:07:47.360
手，如果你有可能

00:07:44.210 --> 00:07:48.560
永远封锁，你知道这一点

00:07:47.360 --> 00:07:50.120
断路器级别没有办法

00:07:48.560 --> 00:07:52.789
想重新获得没有办法

00:07:50.120 --> 00:07:55.039
断路器只是垃圾

00:07:52.789 --> 00:07:56.060
正确收集或哭泣丢失的线程

00:07:55.039 --> 00:07:57.800
那可能永远持续下去

00:07:56.060 --> 00:08:00.199
而如果您正在使用线程

00:07:57.800 --> 00:08:02.630
由线程管理线程的隔离

00:08:00.199 --> 00:08:03.440
线程执行或任务执行或

00:08:02.630 --> 00:08:06.500
像这样的权利是正确的

00:08:03.440 --> 00:08:08.030
很酷，您可以管理更多

00:08:06.500 --> 00:08:11.419
明确地，你可以摧毁它

00:08:08.030 --> 00:08:13.820
你知道那种正弦光

00:08:11.419 --> 00:08:15.500
副业过程，所以选择是

00:08:13.820 --> 00:08:17.419
你知道那里有压力

00:08:15.500 --> 00:08:21.919
你可以有各种各样的事情

00:08:17.419 --> 00:08:25.280
做调整和完善您的表现

00:08:21.919 --> 00:08:26.990
特点还可以，让我们来看看

00:08:25.280 --> 00:08:33.020
这是我们介绍的样子

00:08:26.990 --> 00:08:34.490
断路器或立即重启

00:08:33.020 --> 00:08:38.209
我说他们一定要一样

00:08:34.490 --> 00:08:39.709
签名假设我有一个路径变量

00:08:38.209 --> 00:08:41.810
摇摆你在这里看到路径变量

00:08:39.709 --> 00:08:43.760
例如路径变量和我

00:08:41.810 --> 00:08:47.029
想要匹配中的某个参数

00:08:43.760 --> 00:08:49.940
我必须声明的路径

00:08:47.029 --> 00:08:51.020
甚至在那里的字符串类型

00:08:49.940 --> 00:08:53.690
尽管这不是至高无上的，你知道我有

00:08:51.020 --> 00:08:56.020
相同相同相同参数

00:08:53.690 --> 00:09:00.740
在那里，请记住这一点，好吧，所以

00:08:56.020 --> 00:09:01.520
当地人8080繁荣现在可以了吗

00:09:00.740 --> 00:09:03.680
看起来很犹豫

00:09:01.520 --> 00:09:06.770
有两个所以发生了什么事

00:09:03.680 --> 00:09:11.660
例外，你知道我们得到了

00:09:06.770 --> 00:09:13.580
摇摇欲坠的范围块，犹豫了

00:09:11.660 --> 00:09:17.020
通过一个异常第二，我们得到

00:09:13.580 --> 00:09:20.390
断路器好犹豫

00:09:17.020 --> 00:09:23.440
犹豫，犹豫，让我们看看是否

00:09:20.390 --> 00:09:25.970
可以在这里呼叫足够的这些服务

00:09:23.440 --> 00:09:29.600
现在你去了，你看到我打电话时

00:09:25.970 --> 00:09:31.070
我现在拨打端点时第二

00:09:29.600 --> 00:09:33.410
它直接变成两个，而不是

00:09:31.070 --> 00:09:35.390
犹豫了，所以我们得到的是

00:09:33.410 --> 00:09:38.149
如果一切都快乐，那么两个就是我们

00:09:35.390 --> 00:09:40.760
获得是否有异常权利

00:09:38.149 --> 00:09:42.140
这是后备方法，但在

00:09:40.760 --> 00:09:44.390
我们称呼之初

00:09:42.140 --> 00:09:45.800
后备方法会很犹豫

00:09:44.390 --> 00:09:48.170
首先，最终我们受够了

00:09:45.800 --> 00:09:49.610
我们会看到此停止的后备方法

00:09:48.170 --> 00:09:51.880
犹豫，现在直接

00:09:49.610 --> 00:09:55.670
第二好，这是我可以去的地方

00:09:51.880 --> 00:09:56.810
现在让我们看看是否可以

00:09:55.670 --> 00:09:58.279
甚至毫不犹豫地只是

00:09:56.810 --> 00:09:59.990
进入第二名发生了什么事

00:09:58.279 --> 00:10:02.690
断路器不仅仅是一个

00:09:59.990 --> 00:10:04.459
 try-catch块不仅花哨

00:10:02.690 --> 00:10:07.850
尝试捕获块的方法是

00:10:04.459 --> 00:10:10.040
有状态的它监视某种途径

00:10:07.850 --> 00:10:10.820
在客户端和客户端之间

00:10:10.040 --> 00:10:12.800
下游服务

00:10:10.820 --> 00:10:14.930
它监视其中的逻辑

00:10:12.800 --> 00:10:17.120
断路器，如果看够了

00:10:14.930 --> 00:10:18.709
连续的尝试都失败了

00:10:17.120 --> 00:10:20.270
切换火车轨道

00:10:18.709 --> 00:10:21.920
将流量引向后备

00:10:20.270 --> 00:10:23.630
这直接给了我们下游

00:10:21.920 --> 00:10:25.190
服务时间可以恢复，因此，如果您

00:10:23.630 --> 00:10:27.050
打电话给下游服务

00:10:25.190 --> 00:10:28.880
服务没有回应最后一件事

00:10:27.050 --> 00:10:30.470
你应该做的是继续一天

00:10:28.880 --> 00:10:32.029
在请求时丢失它

00:10:30.470 --> 00:10:33.620
试图恢复，所以这给了

00:10:32.029 --> 00:10:35.329
下游呼吸时间

00:10:33.620 --> 00:10:36.980
如果有的话，它有时间恢复

00:10:35.329 --> 00:10:38.480
有类似Cloud Foundry Cloud之类的东西

00:10:36.980 --> 00:10:39.050
铸造将使天地万物

00:10:38.480 --> 00:10:41.270
白天和整夜

00:10:39.050 --> 00:10:43.220
重新启动该服务，它将

00:10:41.270 --> 00:10:45.020
最终在完成后重新联机

00:10:43.220 --> 00:10:47.060
回来网上我们要重新介绍

00:10:45.020 --> 00:10:49.880
交通，因此断路器具有

00:10:47.060 --> 00:10:52.640
重置超时它将尝试

00:10:49.880 --> 00:10:54.620
在可能的情况下重新引入流量

00:10:52.640 --> 00:10:56.750
在这里你可以看到我知道你已经计时了

00:10:54.620 --> 00:11:00.350
出来我有断路器，但你

00:10:56.750 --> 00:11:02.060
即使我跳开电路也知道我

00:11:00.350 --> 00:11:03.410
断路器，即使我最终将其打开

00:11:02.060 --> 00:11:04.970
将重新引入流量，我能够

00:11:03.410 --> 00:11:08.540
回到第一，所以不是

00:11:04.970 --> 00:11:10.430
永久设置为这种开关

00:11:08.540 --> 00:11:13.610
跟踪模式，它可以返回到

00:11:10.430 --> 00:11:15.260
我们现在期望的主要途径是

00:11:13.610 --> 00:11:16.850
都非常有用，但我认为其中之一

00:11:15.260 --> 00:11:19.670
关于历史的最有趣的事情

00:11:16.850 --> 00:11:20.630
与其说是这种行为，不如说是

00:11:19.670 --> 00:11:22.670
你可以MA的事实

00:11:20.630 --> 00:11:25.040
您可以使用

00:11:22.670 --> 00:11:27.589
 hist探索了您看到的每条电路

00:11:25.040 --> 00:11:30.410
断路器提供服务和事件

00:11:27.589 --> 00:11:31.880
如果您注册了心跳流

00:11:30.410 --> 00:11:33.199
上课路线中的 spring boot 执行器

00:11:31.880 --> 00:11:35.149
如果你在上课的路上有那个

00:11:33.199 --> 00:11:37.850
这是历史代码流

00:11:35.149 --> 00:11:40.519
执行器管理就是这一点

00:11:37.850 --> 00:11:41.720
包含有关的信息

00:11:40.519 --> 00:11:45.230
断路器电路状态

00:11:41.720 --> 00:11:46.699
断路器，您可以将其用于您的

00:11:45.230 --> 00:11:47.660
自己的目的，或者您可以将其插入

00:11:46.699 --> 00:11:49.730
叫他的小鸡的东西

00:11:47.660 --> 00:11:53.720
仪表板，让我们这样做，这很严重

00:11:49.730 --> 00:11:55.610
在这里快点hystrix仪表板，我们将

00:11:53.720 --> 00:11:57.019
使用springs网站支持，我们使用历史记录

00:11:55.610 --> 00:12:01.130
仪表板本身，我们将点击

00:11:57.019 --> 00:12:02.690
产生打开这个，我要

00:12:01.130 --> 00:12:03.769
在其他端口上运行此应用程序

00:12:02.690 --> 00:12:05.600
对，我们要在其他位置运行

00:12:03.769 --> 00:12:08.240
港口，因为我们已经有东西

00:12:05.600 --> 00:12:12.500
在8080端口上运行，那是

00:12:08.240 --> 00:12:15.199
我们的应用程序，所以我们说广告十，我们将

00:12:12.500 --> 00:12:18.110
在此处配置历史记录X仪表板

00:12:15.199 --> 00:12:19.880
然后这样做，让我们旋转一下

00:12:18.110 --> 00:12:21.740
向上旋转将在端口10中旋转并

00:12:19.880 --> 00:12:24.529
它期望什么作为输入

00:12:21.740 --> 00:12:29.589
这是服务结束事件心跳吗

00:12:24.529 --> 00:12:33.050
流所以本地主机的10 hystrix HTML 

00:12:29.589 --> 00:12:37.550
在那里我们将其粘贴在那里

00:12:33.050 --> 00:12:42.740
显示器，现在您可以看到

00:12:37.550 --> 00:12:44.089
向左移动请求

00:12:42.740 --> 00:12:46.819
右边的平均值在上升

00:12:44.089 --> 00:12:48.529
显示红色是否表示40％43％ 

00:12:46.819 --> 00:12:50.480
这些是请求的数量

00:12:48.529 --> 00:12:52.970
正在通过，然后我有

00:12:50.480 --> 00:12:54.949
电话错误，因此有42％ 

00:12:52.970 --> 00:12:56.720
请求失败，大致就是

00:12:54.949 --> 00:12:59.019
我们期望是正确的，我们说的大概是

00:12:56.720 --> 00:13:01.519
大于一半会跳闸

00:12:59.019 --> 00:13:02.839
最终我们得到足够的例外

00:13:01.519 --> 00:13:04.910
连续尝试，您可以看到

00:13:02.839 --> 00:13:06.970
电路现已打开，所以我们可以看到

00:13:04.910 --> 00:13:09.410
反映出这里有问题

00:13:06.970 --> 00:13:10.970
记住我们不能改变别人的

00:13:09.410 --> 00:13:13.639
服务，我们无法添加我们的

00:13:10.970 --> 00:13:15.500
对其进行仪器监控

00:13:13.639 --> 00:13:18.290
他们所能做的就是监控系统

00:13:15.500 --> 00:13:20.060
进出的种类

00:13:18.290 --> 00:13:22.399
和我们应用程序中的出口点

00:13:20.060 --> 00:13:24.050
监控来自我们的流量

00:13:22.399 --> 00:13:25.519
节点通过电路到达其节点

00:13:24.050 --> 00:13:29.569
断路器仪表板

00:13:25.519 --> 00:13:31.250
实际上是一种监视

00:13:29.569 --> 00:13:32.720
为他们的服务，如果断路器

00:13:31.250 --> 00:13:34.070
是开放的，那么我们知道他们的服务

00:13:32.720 --> 00:13:35.540
是正确的

00:13:34.070 --> 00:13:38.600
这非常有用，因为现在我们有了

00:13:35.540 --> 00:13:41.540
一览无余

00:13:38.600 --> 00:13:43.190
我自然只有一种可见性

00:13:41.540 --> 00:13:44.810
一台断路器一台

00:13:43.190 --> 00:13:46.550
目前在一项服务中实例

00:13:44.810 --> 00:13:48.410
但是如果我不止一个，我会想要

00:13:46.550 --> 00:13:50.390
多路复用所有这些电路

00:13:48.410 --> 00:13:52.760
断路器进入一个屏幕，为此，我

00:13:50.390 --> 00:13:54.560
可以使用Spring 云轮机

00:13:52.760 --> 00:13:55.940
让我把所有的电路

00:13:54.560 --> 00:13:59.150
来自所有不同节点的断路器

00:13:55.940 --> 00:14:00.710
系统并对其进行汇总

00:13:59.150 --> 00:14:02.590
进入一个流，然后我可以插入

00:14:00.710 --> 00:14:04.580
进入这个仪表板，我将拥有

00:14:02.590 --> 00:14:07.010
数十或数百或数千或

00:14:04.580 --> 00:14:10.340
但是许多小部件都在一页上

00:14:07.010 --> 00:14:13.850
加圈或理解力好吧

00:14:10.340 --> 00:14:14.990
这当然是实现的一种方法

00:14:13.850 --> 00:14:17.000
我们正在尝试做的是

00:14:14.990 --> 00:14:18.470
引入更多的鲁棒性

00:14:17.000 --> 00:14:19.490
在代码中，以确保是否

00:14:18.470 --> 00:14:21.800
链接在下游出错

00:14:19.490 --> 00:14:23.960
服务，我们可以做正确的事

00:14:21.800 --> 00:14:26.960
但是我真的想跟你说

00:14:23.960 --> 00:14:31.090
今天大约是Spring Retry

00:14:26.960 --> 00:14:33.490
所以Spring Retry是另一种方法

00:14:31.090 --> 00:14:35.510
我们尝试的春天是一个图书馆

00:14:33.490 --> 00:14:37.940
最初在春季内开发

00:14:35.510 --> 00:14:40.430
批量和Spring Retry已

00:14:37.940 --> 00:14:41.810
从回弹中提取出来的

00:14:40.430 --> 00:14:43.460
独立的图书馆，很多人都在使用

00:14:41.810 --> 00:14:44.900
春天不同的其他项目

00:14:43.460 --> 00:14:46.880
当然这批春季云数据流

00:14:44.900 --> 00:14:49.490
你用spring批处理哪个spring 

00:14:46.880 --> 00:14:51.890
整合和其他几个项目

00:14:49.490 --> 00:14:53.960
在春季生态系统中使用Spring Retry

00:14:51.890 --> 00:14:56.030
所以你知道这是我们最受欢迎的之一

00:14:53.960 --> 00:14:57.980
以及最受欢迎的下载库

00:14:56.030 --> 00:14:59.840
即使不一定是顶级的

00:14:57.980 --> 00:15:01.190
项目，尽管如果你问我

00:14:59.840 --> 00:15:03.160
认为真的应该是对的

00:15:01.190 --> 00:15:05.300
本身非常非常有用的库

00:15:03.160 --> 00:15:09.680
新功能之一，尼斯

00:15:05.300 --> 00:15:12.350
 spring retry 1.20 rc1和

00:15:09.680 --> 00:15:14.420
而且不知道您即将成为GA 

00:15:12.350 --> 00:15:16.490
支持断路器，让我们

00:15:14.420 --> 00:15:17.870
看一下断路器，让我们看一下

00:15:16.490 --> 00:15:19.490
在春天，我们尝试不带电路

00:15:17.870 --> 00:15:21.410
首先是断路器，然后我们来看

00:15:19.490 --> 00:15:24.110
在如何打开断路器

00:15:21.410 --> 00:15:26.000
功能，这是我们的后备

00:15:24.110 --> 00:15:28.280
方法，这是我们潜在的不稳定

00:15:26.000 --> 00:15:30.380
服务到服务电话，我们将

00:15:28.280 --> 00:15:32.720
继续进行Spring Retry，这样

00:15:30.380 --> 00:15:35.780
我们会在启用重试中说

00:15:32.720 --> 00:15:37.640
当然，期望是

00:15:35.780 --> 00:15:39.620
人们打算从那里消费这些东西

00:15:37.640 --> 00:15:43.340
 spring boot ，这就是您所需要的， 

00:15:39.620 --> 00:15:46.030
那么我们这里有同样的事情

00:15:43.340 --> 00:15:46.030
你有一个

00:15:46.130 --> 00:15:53.300
我们旅行正确，这里我们要

00:15:48.740 --> 00:15:54.410
说我们要包括某个

00:15:53.300 --> 00:15:55.850
如果我们不包括例外权

00:15:54.410 --> 00:15:56.540
任何事情，所有例外都会

00:15:55.850 --> 00:16:00.620
将会

00:15:56.540 --> 00:16:03.290
我们将触发我们尝试，在这里我们有

00:16:00.620 --> 00:16:06.019
一个技巧把戏和我们期望的

00:16:03.290 --> 00:16:08.720
通过这里是我们的类型

00:16:06.019 --> 00:16:11.029
我们想处理的异常，所以我可以

00:16:08.720 --> 00:16:16.490
只是保持原样，然后决定

00:16:11.029 --> 00:16:18.589
是的，我可以处理运行时异常

00:16:16.490 --> 00:16:21.139
可以在这里博客例外，这样

00:16:18.589 --> 00:16:22.910
配对，如果他们匹配

00:16:21.139 --> 00:16:24.949
该方法将引发异常

00:16:22.910 --> 00:16:27.110
此方法作为as调用

00:16:24.949 --> 00:16:30.500
现在，让我们创建恢复处理程序

00:16:27.110 --> 00:16:31.699
自定义例外

00:16:30.500 --> 00:16:32.930
具体来展示一些

00:16:31.699 --> 00:16:36.829
配置，所以我们说繁荣

00:16:32.930 --> 00:16:38.300
异常扩展了运行时异常，并且

00:16:36.829 --> 00:16:41.509
我们将覆盖构造函数

00:16:38.300 --> 00:16:45.980
在这里传递一个字符串，它会说

00:16:41.509 --> 00:16:47.420
我们想包括繁荣例外

00:16:45.980 --> 00:16:49.220
所以就是这样

00:16:47.420 --> 00:16:51.769
所有其他例外

00:16:49.220 --> 00:16:54.500
触发500状态代码

00:16:51.769 --> 00:16:57.579
直到春季MVC层，我们将

00:16:54.500 --> 00:17:03.079
看到这反映了繁荣景象， 

00:16:57.579 --> 00:17:04.669
在这里，我们有一种通用的

00:17:03.079 --> 00:17:05.510
让我们的通用方法失败并

00:17:04.669 --> 00:17:09.169
我们可以将其保留为运行时异常

00:17:05.510 --> 00:17:10.939
或者我们可以非常具体和分类

00:17:09.169 --> 00:17:12.319
只处理这种特定类型的

00:17:10.939 --> 00:17:14.120
例外，我们可以有多个

00:17:12.319 --> 00:17:16.100
恢复同一组件中的方法

00:17:14.120 --> 00:17:17.449
对吧，现在真的不重要了

00:17:16.100 --> 00:17:19.760
就像有历史的断路器一样

00:17:17.449 --> 00:17:22.159
断路器而不是签名

00:17:19.760 --> 00:17:24.650
匹配，所以我们有这个，你知道我们

00:17:22.159 --> 00:17:26.689
像我们以前一样拥有这两个

00:17:24.650 --> 00:17:29.240
让我们继续并重新启动这个

00:17:26.689 --> 00:17:31.000
只是重试能力，这不是

00:17:29.240 --> 00:17:34.850
像断路器一样聪明

00:17:31.000 --> 00:17:38.030
它没有保持足够的状态

00:17:34.850 --> 00:17:39.950
火车的永久路线

00:17:38.030 --> 00:17:41.720
跟踪到下游服务

00:17:39.950 --> 00:17:44.210
始终尝试致电服务， 

00:17:41.720 --> 00:17:45.490
然后如果失败，它将重试，因此

00:17:44.210 --> 00:17:54.340
让我们看看看起来像什么

00:17:45.490 --> 00:17:56.750
在这里，我们去异常失败

00:17:54.340 --> 00:18:00.170
它试图多次调用

00:17:56.750 --> 00:18:01.550
服务，我们正在等待

00:18:00.170 --> 00:18:02.870
最终通过这样的回应

00:18:01.550 --> 00:18:05.000
如果没有，如果不能尝试

00:18:02.870 --> 00:18:07.340
它无法获得足够的结果

00:18:05.000 --> 00:18:10.910
次，我们将看到它最终

00:18:07.340 --> 00:18:13.570
调用后备广告，让我们使用记录器

00:18:10.910 --> 00:18:22.520
实际上我可以在这里打印出来

00:18:13.570 --> 00:18:26.120
拨打驱动器号码好吧，我们将添加

00:18:22.520 --> 00:18:28.880
到那里的输出或重新启动，所以

00:18:26.120 --> 00:18:30.110
现在，因为它调用了方法

00:18:28.880 --> 00:18:32.420
应该看到它被重试

00:18:30.110 --> 00:18:35.090
多次，这是理想的东西

00:18:32.420 --> 00:18:39.740
一样的

00:18:35.090 --> 00:18:41.480
拨打正确的号码，看看我不是

00:18:39.740 --> 00:18:43.190
调用它只是在打印出来

00:18:41.480 --> 00:18:44.990
控制台，最终它放弃了

00:18:43.190 --> 00:18:47.720
但最终还是成为礼物

00:18:44.990 --> 00:18:50.210
结果成功或超时

00:18:47.720 --> 00:18:50.540
我们得到了后备方法，所以

00:18:50.210 --> 00:18:52.070
我们是

00:18:50.540 --> 00:18:54.320
一切似乎都很好，现在

00:18:52.070 --> 00:18:55.760
再做一次，我没有碰过

00:18:54.320 --> 00:18:57.890
键盘只是调用它的三个

00:18:55.760 --> 00:19:00.680
连续几次或多次

00:18:57.890 --> 00:19:02.540
对我们的继承，所以这是

00:19:00.680 --> 00:19:04.070
春小麦饭的标准行为

00:19:02.540 --> 00:19:05.420
春小麦对没有

00:19:04.070 --> 00:19:08.180
隔离事物的能力

00:19:05.420 --> 00:19:10.730
信号量或线程，但我会

00:19:08.180 --> 00:19:13.400
认为实际上你不知道

00:19:10.730 --> 00:19:14.990
确实有问题，因为我们可以在

00:19:13.400 --> 00:19:17.780
例如水槽，您可以在

00:19:14.990 --> 00:19:20.150
下沉这是旋转的注释

00:19:17.780 --> 00:19:22.220
春天在春天3.1和基本上什么时候

00:19:20.150 --> 00:19:23.570
您将此添加到它调用一个方法

00:19:22.220 --> 00:19:26.090
线程池中的方法，这样您

00:19:23.570 --> 00:19:28.010
可以说在启用接收器时指定一个

00:19:26.090 --> 00:19:30.020
任务执行器，然后得到

00:19:28.010 --> 00:19:33.770
这样就可以了，现在您还有更多

00:19:30.020 --> 00:19:35.930
显式控制，您可以看到

00:19:33.770 --> 00:19:38.270
将会有某种形式的

00:19:35.930 --> 00:19:39.800
您知道的代码中的线程逻辑

00:19:38.270 --> 00:19:41.780
这非常关注服务水平

00:19:39.800 --> 00:19:45.410
现在你知道了另一件事

00:19:41.780 --> 00:19:47.270
是我们真的不喜欢

00:19:45.410 --> 00:19:49.880
一样的断路器

00:19:47.270 --> 00:19:51.830
功能正确，所以我们实际上需要

00:19:49.880 --> 00:19:53.960
我们要去

00:19:51.830 --> 00:19:57.890
提前利用现在的优势

00:19:53.960 --> 00:19:59.060
春天的新功能，我们尝试称为

00:19:57.890 --> 00:20:02.480
断路器，我希望这

00:19:59.060 --> 00:20:04.550
断路器注释将排序

00:20:02.480 --> 00:20:05.780
与at使能电路集成

00:20:04.550 --> 00:20:06.220
断路器注释而不是Spring 

00:20:05.780 --> 00:20:07.600
试用

00:20:06.220 --> 00:20:09.940
最终，这样您就可以选择

00:20:07.600 --> 00:20:12.010
选择hystrix或使用spring 

00:20:09.940 --> 00:20:14.049
我们尝试，它们都会被激活

00:20:12.010 --> 00:20:16.000
通过表电路激活

00:20:14.049 --> 00:20:17.650
就像我们对历史所做的那样

00:20:16.000 --> 00:20:19.330
但就我们而言，我们唯一的

00:20:17.650 --> 00:20:22.419
需要改变的是断路器本身

00:20:19.330 --> 00:20:25.090
你知道其他所有的事情

00:20:22.419 --> 00:20:27.070
差不多，我们有不同

00:20:25.090 --> 00:20:29.950
此处的参数复位超时为

00:20:27.070 --> 00:20:32.049
基本上是20,000毫秒

00:20:29.950 --> 00:20:33.850
表示要等待20秒

00:20:32.049 --> 00:20:36.400
在尝试重新引入之前

00:20:33.850 --> 00:20:37.780
交通顺畅，所以我们会说我们只是

00:20:36.400 --> 00:20:39.039
离开它，因为这实际上很好

00:20:37.780 --> 00:20:42.700
所以让我们继续前进

00:20:39.039 --> 00:20:43.770
该断路器提供的断路器

00:20:42.700 --> 00:20:45.850
我们需要的一切

00:20:43.770 --> 00:20:47.799
除了那个干扰和事件

00:20:45.850 --> 00:20:49.630
心跳流正确，所以我喜欢这个

00:20:47.799 --> 00:20:52.450
我认为这是一种更清洁的模型

00:20:49.630 --> 00:20:54.340
从以下方面设计恢复方法

00:20:52.450 --> 00:20:55.659
异常类型比设计异常

00:20:54.340 --> 00:20:59.289
使用这类字符串lis类型

00:20:55.659 --> 00:21:01.150
注释规范，所以我们开始

00:20:59.289 --> 00:21:08.289
叫下游服务

00:21:01.150 --> 00:21:12.900
犹豫不决

00:21:08.289 --> 00:21:14.679
叫口吃我们去

00:21:12.900 --> 00:21:16.480
现在您可以看到它正在调用

00:21:14.679 --> 00:21:17.980
下游服务，直接进行

00:21:16.480 --> 00:21:22.000
第二，它直接进入

00:21:17.980 --> 00:21:24.010
后备，因为你知道它是

00:21:22.000 --> 00:21:26.200
现在正在做的断路器

00:21:24.010 --> 00:21:28.390
和我们的历史一样

00:21:26.200 --> 00:21:31.270
断路器正在这样做，这非常

00:21:28.390 --> 00:21:32.890
在实践中您知道的便利

00:21:31.270 --> 00:21:34.360
术语，它们在功能上是等效的

00:21:32.890 --> 00:21:36.130
考虑服务和事件

00:21:34.360 --> 00:21:37.929
心跳流我很好

00:21:36.130 --> 00:21:40.090
权威，以建立中风

00:21:37.929 --> 00:21:41.799
您知道的断路器

00:21:40.090 --> 00:21:43.030
事件心跳流以某种方式

00:21:41.799 --> 00:21:45.250
与历史兼容

00:21:43.030 --> 00:21:46.780
状态板不应该太难，所以

00:21:45.250 --> 00:21:49.840
也许我们会看到出现

00:21:46.780 --> 00:21:51.640
在GA之前，我都知道

00:21:49.840 --> 00:21:54.640
鼓励你出去抓

00:21:51.640 --> 00:21:56.440
踢轮胎，玩得开心

00:21:54.640 --> 00:21:57.940
建立正确的服务

00:21:56.440 --> 00:22:00.299
面对服务中断的事情

00:21:57.940 --> 00:22:00.299
失败

00:22:07.840 --> 00:22:09.900
您

