WEBVTT
Kind: captions
Language: zh-Hans

00:00:13.700 --> 00:00:18.680
 Spring 小贴士中的粉丝

00:00:16.190 --> 00:00:20.840
我们现在来看Cloud Foundry 

00:00:18.680 --> 00:00:22.420
云基金是一个开源平台

00:00:20.840 --> 00:00:24.529
这是基于云的薄荷糖

00:00:22.420 --> 00:00:27.080
应用程序自然是

00:00:24.529 --> 00:00:29.180
针对特定应用进行了优化

00:00:27.080 --> 00:00:31.250
那就是说还有其他

00:00:29.180 --> 00:00:33.530
存在于较低层次的关注

00:00:31.250 --> 00:00:35.750
每个应用程序堆栈都不是

00:00:33.530 --> 00:00:37.430
可见，正如您所期望的那样

00:00:35.750 --> 00:00:39.500
如果您来自较低级别

00:00:37.430 --> 00:00:41.870
像基础架构这样的组件

00:00:39.500 --> 00:00:44.379
服务提供类似亚马逊的服务

00:00:41.870 --> 00:00:46.640
网络服务或Google计算引擎或

00:00:44.379 --> 00:00:49.309
 Microsoft Azure等，这些是

00:00:46.640 --> 00:00:52.489
这些服务主要是

00:00:49.309 --> 00:00:54.500
现在把重点放在他们身上

00:00:52.489 --> 00:00:59.330
允许您租用然后与

00:00:54.500 --> 00:01:02.750
和Maple 8服务器就位了

00:00:59.330 --> 00:01:05.330
和与服务器相关的部分

00:01:02.750 --> 00:01:07.190
所以硬盘Rams CPU等

00:01:05.330 --> 00:01:09.470
您关心的各种能力

00:01:07.190 --> 00:01:11.150
这么低的水平肯定在那里

00:01:09.470 --> 00:01:13.130
但是我们不在乎他们，我们

00:01:11.150 --> 00:01:15.560
提供最重要的东西

00:01:13.130 --> 00:01:17.119
是的业务价值应用程序集

00:01:15.560 --> 00:01:19.159
功能正确，因此Cloud Foundry 

00:01:17.119 --> 00:01:20.990
使您能够自动执行

00:01:19.159 --> 00:01:23.329
很多较低级别的东西

00:01:20.990 --> 00:01:26.259
专注于特定类型的

00:01:23.329 --> 00:01:28.340
应用程序在线交易

00:01:26.259 --> 00:01:30.079
应用我的交易我是真的

00:01:28.340 --> 00:01:33.920
是否要求或回复在线

00:01:30.079 --> 00:01:36.259
应用程序，这是一个特别的

00:01:33.920 --> 00:01:37.759
这是一个无状态的应用程序

00:01:36.259 --> 00:01:39.710
当然，如果

00:01:37.759 --> 00:01:42.380
需要存在，但状态是

00:01:39.710 --> 00:01:44.990
通常在其他地方举行，如果你

00:01:42.380 --> 00:01:47.299
像您那样将状态设为复杂状态

00:01:44.990 --> 00:01:48.170
例如在自定义数据库中

00:01:47.299 --> 00:01:50.469
众筹

00:01:48.170 --> 00:01:53.570
不是，不一定是最简单的

00:01:50.469 --> 00:01:55.759
或最正确的运行方式

00:01:53.570 --> 00:01:57.289
如果您想要

00:01:55.759 --> 00:01:59.289
您正在尝试建立无状态的网站

00:01:57.289 --> 00:02:02.390
应用程序或服务或其他

00:01:59.289 --> 00:02:04.219
处理实习生与

00:02:02.390 --> 00:02:06.469
有状态服务，非常适合

00:02:04.219 --> 00:02:08.420
云家庭，但您知道CloudFront 

00:02:06.469 --> 00:02:10.250
本身并未针对运行进行优化

00:02:08.420 --> 00:02:12.050
为运行而优化的数据库

00:02:10.250 --> 00:02:14.360
应用程序，并且有方法可以

00:02:12.050 --> 00:02:16.490
连接服务支持服务事物

00:02:14.360 --> 00:02:19.760
保持状态，例如消息队列和

00:02:16.490 --> 00:02:23.480
数据库和缓存等

00:02:19.760 --> 00:02:24.980
云资金现已开放Cloud Foundry已开放

00:02:23.480 --> 00:02:26.629
就像我说的，这是它的一部分

00:02:24.980 --> 00:02:27.380
一个基金会实际上是由

00:02:26.629 --> 00:02:29.030
的Linux 

00:02:27.380 --> 00:02:30.770
基础与

00:02:29.030 --> 00:02:33.620
管理他们的Linux开源项目

00:02:30.770 --> 00:02:35.330
它有很多不同的贡献者

00:02:33.620 --> 00:02:38.600
来自各地的生态系统

00:02:35.330 --> 00:02:40.880
包括惠普在内的行业

00:02:38.600 --> 00:02:43.010
认为百度在那里肯定是关键的

00:02:40.880 --> 00:02:44.420
 iBM在里面，所以这些是

00:02:43.010 --> 00:02:46.580
都采取了

00:02:44.420 --> 00:02:49.250
原始的开源Cloud Foundry代码

00:02:46.580 --> 00:02:51.080
我们这些人具有关键性

00:02:49.250 --> 00:02:54.440
以前在VMware开发并

00:02:51.080 --> 00:02:55.520
他们知道你加入了

00:02:54.440 --> 00:02:57.460
他们加入了倡议

00:02:55.520 --> 00:03:00.530
其中一些公司有自己的

00:02:57.460 --> 00:03:02.750
云铸造厂提供他们拥有的权利

00:03:00.530 --> 00:03:04.430
他们自己的实现，他们

00:03:02.750 --> 00:03:07.070
包装运输并销售至

00:03:04.430 --> 00:03:09.290
对我工作的公司至关重要

00:03:07.070 --> 00:03:13.220
当然有自己的分布

00:03:09.290 --> 00:03:14.510
称为关键Cloud Foundry 

00:03:13.220 --> 00:03:16.970
分配那个特殊的

00:03:14.510 --> 00:03:20.990
分发是本地服务

00:03:16.970 --> 00:03:23.090
那就是说你得到盒子和

00:03:20.990 --> 00:03:25.490
众所周知的盒子显然是一个下载

00:03:23.090 --> 00:03:27.350
但是您获得了软件许可证

00:03:25.490 --> 00:03:29.000
得到的位，你可以安装它

00:03:27.350 --> 00:03:32.260
任何您想要的地方都有自己的

00:03:29.000 --> 00:03:35.540
可以运行的私有云

00:03:32.260 --> 00:03:37.340
可以在OpenStack上运行的vSphere 

00:03:35.540 --> 00:03:39.860
在可以运行的Google计算引擎上运行

00:03:37.340 --> 00:03:42.800
在Microsoft Azure上它可以在亚马逊上运行

00:03:39.860 --> 00:03:44.330
网络服务等等等，因此您可以

00:03:42.800 --> 00:03:46.580
部署在任何这些不同的

00:03:44.330 --> 00:03:48.080
基础设施层和应用

00:03:46.580 --> 00:03:49.580
为Cloud Foundry写的

00:03:48.080 --> 00:03:51.230
可在所有这些不同的地方轻松运行

00:03:49.580 --> 00:03:53.570
分层，因此，如果您是一个组织

00:03:51.230 --> 00:03:56.000
想移到云端，但是

00:03:53.570 --> 00:03:58.940
也许您还没有迈向

00:03:56.000 --> 00:04:01.010
有点像云中的公共主机

00:03:58.940 --> 00:04:02.090
环境，然后您可以安装Cloud 

00:04:01.010 --> 00:04:04.670
铸造并获得这种速度

00:04:02.090 --> 00:04:06.830
迁移到云环境中

00:04:04.670 --> 00:04:09.380
您在自己的本地数据中心中

00:04:06.830 --> 00:04:11.300
然后当时间到了

00:04:09.380 --> 00:04:13.070
到公共云就可以了

00:04:11.300 --> 00:04:14.990
将其安装在那里，了解它的正确性

00:04:13.070 --> 00:04:16.370
相同的平台

00:04:14.990 --> 00:04:18.280
其实你可以知道

00:04:16.370 --> 00:04:20.330
容易混合

00:04:18.280 --> 00:04:23.240
您具有本地配置的配置

00:04:20.330 --> 00:04:26.090
私有数据中心有点云

00:04:23.240 --> 00:04:28.760
现在也是公共托管的云

00:04:26.090 --> 00:04:31.240
我们今天要看的东西

00:04:28.760 --> 00:04:34.220
被称为关键网络服务，这是一个

00:04:31.240 --> 00:04:36.710
托管Cloud Foundry的实施

00:04:34.220 --> 00:04:40.130
这只是常规的Cloud Foundry 

00:04:36.710 --> 00:04:40.700
它部署在Amazon East上，因此

00:04:40.130 --> 00:04:43.850
继续

00:04:40.700 --> 00:04:45.290
服务，这不是私人权利

00:04:43.850 --> 00:04:45.860
您在关键网络上获得了一个帐户

00:04:45.290 --> 00:04:47.480
服务

00:04:45.860 --> 00:04:50.540
这是一个多租户环境

00:04:47.480 --> 00:04:51.740
显然，与您一起了解是安全的

00:04:50.540 --> 00:04:53.390
知道应用程序不应该看到每个

00:04:51.740 --> 00:04:56.810
其他人知道，但是理论上你可以

00:04:53.390 --> 00:04:59.180
与其他人共享一台计算机

00:04:56.810 --> 00:05:00.590
正确的应用程序，这是一个绝佳的选择

00:04:59.180 --> 00:05:01.910
从Cloud Foundry I开始您的旅程

00:05:00.590 --> 00:05:04.280
思考，因为它是对的，你知道它是

00:05:01.910 --> 00:05:07.100
非常非常合理的价格很便宜

00:05:04.280 --> 00:05:07.820
用于小型应用

00:05:07.100 --> 00:05:10.430
合理的价格

00:05:07.820 --> 00:05:13.730
之后，它不需要您

00:05:10.430 --> 00:05:16.070
放下一个集群，放下一个

00:05:13.730 --> 00:05:18.710
整个拓扑您只需一个帐户

00:05:16.070 --> 00:05:20.930
并开始使用它，所以我们将建立

00:05:18.710 --> 00:05:22.790
一个简单的应用程序首先只是

00:05:20.930 --> 00:05:24.380
常规 Spring 申请数据

00:05:22.790 --> 00:05:27.680
我要打电话给中心应用程序

00:05:24.380 --> 00:05:30.380
我将要使用的CF数据演示

00:05:27.680 --> 00:05:34.730
续集，我们将使用网络支持

00:05:30.380 --> 00:05:37.340
仓库支持执行器支持和

00:05:34.730 --> 00:05:40.670
我认为我们将拥有JPA，因此我们使用

00:05:37.340 --> 00:05:46.490
 JP也是如此，我们将点击generate Give 

00:05:40.670 --> 00:05:47.600
给我们自己一个新的zip文件，好吧

00:05:46.490 --> 00:05:49.970
我们要做的是

00:05:47.600 --> 00:05:51.830
只是将一些数据存储在我的续集中

00:05:49.970 --> 00:05:53.450
数据库以及我们使用我的原因

00:05:51.830 --> 00:05:54.890
续集，因为这实际上是其中之一

00:05:53.450 --> 00:05:58.820
我们可以提供的许多支持服务

00:05:54.890 --> 00:06:02.240
在Cloud Foundry上使用，因此我们需要

00:05:58.820 --> 00:06:05.060
我们的应用程序创建了一些数据，我

00:06:02.240 --> 00:06:07.720
认为我们会在这里修补一些猫

00:06:05.060 --> 00:06:14.620
对的猫很好，所以我们会用一些

00:06:07.720 --> 00:06:23.530
猫好了实体好了

00:06:14.620 --> 00:06:29.350
私人长ID身份证ID私人字符串

00:06:23.530 --> 00:06:29.350
保留名称创建构造函数

00:06:32.050 --> 00:06:35.560
创造价值

00:06:40.080 --> 00:06:46.600
创建另一个构造函数

00:06:42.370 --> 00:06:48.640
 JPA好吧，也许是这样

00:06:46.600 --> 00:06:49.990
牙线好，我们要做什么

00:06:48.640 --> 00:06:51.940
现在想在其中保存一些数据

00:06:49.990 --> 00:06:53.950
数据库，所以我将创建一个命令行

00:06:51.940 --> 00:06:57.100
运行程序和命令行运行程序

00:06:53.950 --> 00:07:00.610
我们将通过以下方式初始化一些示例数据

00:06:57.100 --> 00:07:02.590
使用预订存储库

00:07:00.610 --> 00:07:07.450
我们将使用Spring 数据进行创建

00:07:02.590 --> 00:07:11.170
所以预订资料库还是可以的

00:07:07.450 --> 00:07:13.960
然后当然举起

00:07:11.170 --> 00:07:18.130
 ID可以在这里完成工作，所以

00:07:13.960 --> 00:07:22.710
这将JPA存储库扩展为四种类型

00:07:18.130 --> 00:07:27.820
猫在这里

00:07:22.710 --> 00:07:33.190
我的头脑猫仓库有类型

00:07:27.820 --> 00:07:34.300
猫还可以，现在我们去那里

00:07:33.190 --> 00:07:38.320
想要做的就是将其注入

00:07:34.300 --> 00:07:40.690
构造函数，所以有了这个，我们将

00:07:38.320 --> 00:07:43.590
保存一些记录到

00:07:40.690 --> 00:07:52.300
这里我们要说的数据库流

00:07:43.590 --> 00:07:58.150
想起了和菲利克斯·加菲尔德，你知道

00:07:52.300 --> 00:08:00.340
有什么惊喜，所以我们去

00:07:58.150 --> 00:08:01.720
通过这些名称和每个名称

00:08:00.340 --> 00:08:08.370
我们将记录写入数据库

00:08:01.720 --> 00:08:13.900
在这里使用我们的猫仓库很好

00:08:08.370 --> 00:08:18.970
现在这将运行并与

00:08:13.900 --> 00:08:20.590
我的续集实例，所以我们需要

00:08:18.970 --> 00:08:25.930
相应地配置一些东西

00:08:20.590 --> 00:08:30.010
要说的是Spring 点数据源

00:08:25.930 --> 00:08:35.410
首先，JPA点数据库等于我的

00:08:30.010 --> 00:08:37.180
续集，我有这个，JPA 

00:08:35.410 --> 00:08:39.039
让它为我们创建一个架构

00:08:37.180 --> 00:08:42.669
开始，一个人想要

00:08:39.039 --> 00:08:45.940
在配置连接时创建

00:08:42.669 --> 00:08:49.600
到我们本地的本地大卫数据源

00:08:45.940 --> 00:08:52.210
好的，所以我们要说

00:08:49.600 --> 00:08:52.440
在中配置连接信息

00:08:52.210 --> 00:08:54.150
的

00:08:52.440 --> 00:08:57.650
故障概况，所以如果没有其他

00:08:54.150 --> 00:09:03.630
指定的配置文件将使用此配置

00:08:57.650 --> 00:09:07.290
这里我们要说数据源点

00:09:03.630 --> 00:09:13.040
用户名您的用户名等于cats， 

00:09:07.290 --> 00:09:16.850
我们也将使用密码为cats， 

00:09:13.040 --> 00:09:28.350
我们将说Spring 点数据源

00:09:16.850 --> 00:09:33.720
点URL等于JDBC：我的续集：4/4 / 

00:09:28.350 --> 00:09:38.340
本地主机--猫问号使用

00:09:33.720 --> 00:09:40.440
 SSL现在等于false，应该

00:09:38.340 --> 00:09:42.570
这样做应该是我的续集特定的

00:09:40.440 --> 00:09:45.120
与猫呆聊天的信息

00:09:42.570 --> 00:09:47.400
基于这个节点，所以如果我们开始这个

00:09:45.120 --> 00:09:50.090
我们唯一需要的是

00:09:47.400 --> 00:09:52.820
 REST API，以便做到这一点

00:09:50.090 --> 00:09:59.970
有趣，所以我们将在这里转到

00:09:52.820 --> 00:10:02.850
存储库并相应地对其进行注释

00:09:59.970 --> 00:10:04.740
严格来说这不是必需的

00:10:02.850 --> 00:10:06.480
因为我们有 Spring 的 spring boot 

00:10:04.740 --> 00:10:08.730
开始在上课路上被捕， 

00:10:06.480 --> 00:10:10.620
我们有一个公共类型，让我们开始吧

00:10:08.730 --> 00:10:12.650
向前并开始，看看有什么

00:10:10.620 --> 00:10:12.650
发生

00:10:19.769 --> 00:10:32.360
好的localhost：8080这样的

00:10:26.009 --> 00:10:32.360
保留呼声

00:10:49.470 --> 00:10:59.669
似乎我忘了指定正确的

00:10:51.749 --> 00:11:03.509
数据库，所以我们会再试一次

00:10:59.669 --> 00:11:06.329
现在有我们的应用猫

00:11:03.509 --> 00:11:07.439
有我们的猫，所以现在我们有一个

00:11:06.329 --> 00:11:09.449
应用程序已启动并正在运行

00:11:07.439 --> 00:11:10.799
运行到我们的本地数据库

00:11:09.449 --> 00:11:11.939
准备去云端，我们已经

00:11:10.799 --> 00:11:14.699
一个我不需要的非常简单的应用程序

00:11:11.939 --> 00:11:16.079
停留太久，但这是典型的

00:11:14.699 --> 00:11:18.119
 Spring 的良好应用权

00:11:16.079 --> 00:11:20.339
它使用的是

00:11:18.119 --> 00:11:22.139
我的续集同样是应用程序本身

00:11:20.339 --> 00:11:23.789
 REST API或单个页面且效果不佳

00:11:22.139 --> 00:11:25.739
甚至是带有会话的应用程序

00:11:23.789 --> 00:11:27.929
状态，但我们将研究如何覆盖

00:11:25.739 --> 00:11:30.179
在稍后的另一个讨论中

00:11:27.929 --> 00:11:32.579
当我们看 Spring 会议时， 

00:11:30.179 --> 00:11:40.919
现在我们可以部署它，让我们转到

00:11:32.579 --> 00:11:50.809
我们的命令行在这里行了

00:11:40.919 --> 00:11:54.749
 -d跳过测试全新安装CD目标

00:11:50.809 --> 00:11:57.209
 CF push-P和我们现在要做什么

00:11:54.749 --> 00:11:59.970
是我们要将此应用程序推送到

00:11:57.209 --> 00:12:01.559
云平台再次出现

00:11:59.970 --> 00:12:02.729
我有很多不同版本的俱乐部

00:12:01.559 --> 00:12:05.249
就是说没有那种东西

00:12:02.729 --> 00:12:05.909
真正的Cloud Foundry，所以我有一个罐子

00:12:05.249 --> 00:12:09.029
在这里归档

00:12:05.909 --> 00:12:10.739
我想登录我的云查找器

00:12:09.029 --> 00:12:13.679
我正在登录云基金

00:12:10.739 --> 00:12:15.239
在发条式测功机上运行

00:12:13.679 --> 00:12:17.009
通常你会指定你什么时候

00:12:15.239 --> 00:12:19.409
进行CF登录，您将定位到

00:12:17.009 --> 00:12:21.629
 API端点我已经在EPA 

00:12:19.409 --> 00:12:22.919
已经针对其API点运行了

00:12:21.629 --> 00:12:25.350
总的IO，但如果您使用一些

00:12:22.919 --> 00:12:27.269
如果您正在使用或正在使用其他云

00:12:25.350 --> 00:12:29.399
您自己的云，可能是您知道API 

00:12:27.269 --> 00:12:31.949
例如您的环境列

00:12:29.399 --> 00:12:34.139
无论哪种方式，我们都将目标定位为

00:12:31.949 --> 00:12:37.489
适当的，我要在这里登录

00:12:34.139 --> 00:12:41.879
没有发送给凯特，所以在我的电子邮件中加上

00:12:37.489 --> 00:12:43.589
指定我的密码，一次指定一次

00:12:41.879 --> 00:12:45.149
我已经完成要求我指定

00:12:43.589 --> 00:12:46.709
我想与哪个组织合作

00:12:45.149 --> 00:12:49.289
现在这是说这是

00:12:46.709 --> 00:12:50.789
就像你可以属于许多人一样

00:12:49.289 --> 00:12:54.899
 github上的不同组织

00:12:50.789 --> 00:12:58.109
例如，我呃你不必

00:12:54.899 --> 00:12:59.549
使用一种工具，当我使用用户名时

00:12:58.109 --> 00:13:01.550
和密码从多个变成一个

00:12:59.549 --> 00:13:03.680
内部组织

00:13:01.550 --> 00:13:06.140
您正在使用的帐户是正确的

00:13:03.680 --> 00:13:08.380
所以我有多个帐户

00:13:06.140 --> 00:13:10.180
我所属的组织

00:13:08.380 --> 00:13:12.980
关键网络服务

00:13:10.180 --> 00:13:18.850
现在，我要指定

00:13:12.980 --> 00:13:21.920
第二平台工程和

00:13:18.850 --> 00:13:26.360
瞧我已经登录了

00:13:21.920 --> 00:13:29.029
空间，现在空间是一种排序方式

00:13:26.360 --> 00:13:30.200
划分工作流程或您

00:13:29.029 --> 00:13:32.870
了解工作环境，因此您可能有

00:13:30.200 --> 00:13:35.480
您可能会进行的开发问答

00:13:32.870 --> 00:13:37.880
对于给定的组织而言是正确的

00:13:35.480 --> 00:13:40.610
这是一个做善事的好地方

00:13:37.880 --> 00:13:43.610
隔离测试也很好

00:13:40.610 --> 00:13:45.260
部署范围排序的地方

00:13:43.610 --> 00:13:47.959
在应用程序中可以

00:13:45.260 --> 00:13:49.940
完成我没有可以的应用程序

00:13:47.959 --> 00:13:51.860
通过转到CF应用程序进行确认，并

00:13:49.940 --> 00:13:53.750
我知道我要去的地方

00:13:51.860 --> 00:13:55.310
正确停止的应用程序

00:13:53.750 --> 00:13:56.660
这些都不在工作

00:13:55.310 --> 00:13:58.339
他们没有实例，他们不是

00:13:56.660 --> 00:13:59.959
占用他们绑定的所有内存

00:13:58.339 --> 00:14:02.420
 URL，我想做的是

00:13:59.959 --> 00:14:08.329
推送我的应用程序，但我想推送

00:14:02.420 --> 00:14:09.380
一旦创建了数据源， 

00:14:08.329 --> 00:14:10.910
我要做的是我要推动它，但是

00:14:09.380 --> 00:14:14.930
我不会先开始

00:14:10.910 --> 00:14:16.940
说CF做好标记，我要推动它

00:14:14.930 --> 00:14:19.040
但你知道我会推动它并开始

00:14:16.940 --> 00:14:20.630
在我实际服务峡谷之后

00:14:19.040 --> 00:14:23.870
那可能是一个更好的选择

00:14:20.630 --> 00:14:27.350
想法，所以我们要做的是

00:14:23.870 --> 00:14:28.820
要去CF市场，我们知道我

00:14:27.350 --> 00:14:30.680
如果我尝试推动

00:14:28.820 --> 00:14:31.790
应用程序现在这行不通

00:14:30.680 --> 00:14:34.160
所以我要做的就是去

00:14:31.790 --> 00:14:37.430
这里的市场，等待

00:14:34.160 --> 00:14:42.529
目录从这里流下来

00:14:37.430 --> 00:14:44.450
现在的酒店，这个市场的目录

00:14:42.529 --> 00:14:46.459
只是某种程度上

00:14:44.450 --> 00:14:49.310
不同支持服务的目录

00:14:46.459 --> 00:14:51.140
您可以用来丰富

00:14:49.310 --> 00:14:53.209
您的应用程序的行为以及

00:14:51.140 --> 00:14:55.850
这里有很多不同的选择

00:14:53.209 --> 00:15:00.050
我想做的是我想用我的

00:14:55.850 --> 00:15:02.870
续集的实现，所以我可以使用

00:15:00.050 --> 00:15:04.640
清晰的DVD我可以说我想使用

00:15:02.870 --> 00:15:07.430
火花

00:15:04.640 --> 00:15:10.010
计划是明确的免费计划

00:15:07.430 --> 00:15:11.480
成为迈克的续集，然后我

00:15:10.010 --> 00:15:12.320
需要给它一个逻辑名称，所以我想要

00:15:11.480 --> 00:15:14.029
说

00:15:12.320 --> 00:15:20.569
碳纤维

00:15:14.029 --> 00:15:22.310
创建cf创建-服务，那就是

00:15:20.569 --> 00:15:28.160
要问我什么信息

00:15:22.310 --> 00:15:29.689
我会说火花Claire DB spark然后

00:15:28.160 --> 00:15:38.420
我在这里不给它一个逻辑名称

00:15:29.689 --> 00:15:39.500
称它为我的续集吧，那是

00:15:38.420 --> 00:15:40.579
将要做的是创建一个

00:15:39.500 --> 00:15:42.709
实例实际上是外出

00:15:40.579 --> 00:15:44.509
现在提供数据库，这些不同

00:15:42.709 --> 00:15:46.759
你知道他们不同意的计划

00:15:44.509 --> 00:15:49.040
所有不同服务中的事物

00:15:46.759 --> 00:15:51.410
你能知道这些是任意的吗

00:15:49.040 --> 00:15:52.759
定义仲裁这些名称

00:15:51.410 --> 00:15:54.680
这些服务是不同的服务

00:15:52.759 --> 00:15:56.800
通常在关键Web服务中

00:15:54.680 --> 00:16:00.139
由实际的第三方提供

00:15:56.800 --> 00:16:02.240
 Web服务发生的在线服务

00:16:00.139 --> 00:16:05.449
与枢纽融合

00:16:02.240 --> 00:16:06.860
 Web服务平台，所以我们不能

00:16:05.449 --> 00:16:08.480
知道我们不控制价格

00:16:06.860 --> 00:16:10.550
他们的产品，他们只是

00:16:08.480 --> 00:16:12.290
指定不同的标签和帐单

00:16:10.550 --> 00:16:14.149
如果您选择一个将处理

00:16:12.290 --> 00:16:16.310
不同的计划，那已经只是

00:16:14.149 --> 00:16:18.079
现在我已经建立到您的帐户中了

00:16:16.310 --> 00:16:26.089
要打CF创建服务清除数据库

00:16:18.079 --> 00:16:28.100
现在激发我的不平等

00:16:26.089 --> 00:16:30.259
我要做的是推送应用程序吗

00:16:28.100 --> 00:16:32.689
我会说CF推减P，我就是

00:16:30.259 --> 00:16:36.949
将指定cat应用程序

00:16:32.689 --> 00:16:39.370
好的，我要给它一个

00:16:36.949 --> 00:16:46.220
逻辑名称，我将其称为CF猫

00:16:39.370 --> 00:16:51.290
你知道数据演示，在我这样做之前

00:16:46.220 --> 00:16:53.449
我要破折号-不-开始

00:16:51.290 --> 00:16:55.399
这将推动应用程序

00:16:53.449 --> 00:16:56.660
进入云平台，因此

00:16:55.399 --> 00:16:58.519
将会发生的是

00:16:56.660 --> 00:17:00.860
上载那个jar文件

00:16:58.519 --> 00:17:02.629
只是一个zip文件，它将尝试

00:17:00.860 --> 00:17:06.350
并了解什么样的应用

00:17:02.629 --> 00:17:07.909
被赋予它将要运行它

00:17:06.350 --> 00:17:09.079
通过一系列测试，它将尝试

00:17:07.909 --> 00:17:10.939
找出什么样的应用

00:17:09.079 --> 00:17:14.569
在这种情况下，它将看到一个罐子

00:17:10.939 --> 00:17:16.039
好的，这是一个Java应用程序

00:17:14.569 --> 00:17:17.240
有一个主要方法-这是一个Java 

00:17:16.039 --> 00:17:22.429
可以运行主要方法的应用程序

00:17:17.240 --> 00:17:23.899
然后它会放下你知道的

00:17:22.429 --> 00:17:26.390
它会做所有需要做的事

00:17:23.899 --> 00:17:26.990
准备好使用该应用程序，但

00:17:26.390 --> 00:17:29.960
不是

00:17:26.990 --> 00:17:31.840
喜欢开始或开始就可以了

00:17:29.960 --> 00:17:37.210
我们想要做的是我们要绑定

00:17:31.840 --> 00:17:40.549
我们最近创建的我们最近创建的

00:17:37.210 --> 00:17:45.799
支持服务是我的续集

00:17:40.549 --> 00:17:47.330
实例到我们新创建的或

00:17:45.799 --> 00:17:49.880
新推的应用程序，所以我要

00:17:47.330 --> 00:17:52.850
说绑定服务，然后它将

00:17:49.880 --> 00:17:54.799
说我们必须将应用程序绑定到

00:17:52.850 --> 00:18:02.960
数据库正确，因此该应用被调用

00:17:54.799 --> 00:18:05.529
 CF帽，我将其绑定到我的

00:18:02.960 --> 00:18:05.529
我的续集

00:18:16.620 --> 00:18:28.530
 çF猫演示-我的续集和其他内容

00:18:27.150 --> 00:18:34.470
这将要做的是创建

00:18:28.530 --> 00:18:36.660
一个链接，如果你愿意的话

00:18:34.470 --> 00:18:40.980
在Cloud Funder中工作的服务是

00:18:36.660 --> 00:18:44.400
关于如何的信息

00:18:40.980 --> 00:18:47.160
连接到支持服务已暴露

00:18:44.400 --> 00:18:49.080
作为环境应用

00:18:47.160 --> 00:18:54.270
变量和这些环境

00:18:49.080 --> 00:18:55.860
变量是您知道对X可见的X 

00:18:54.270 --> 00:18:57.870
到我们要尝试的应用程序

00:18:55.860 --> 00:19:00.450
用所以我要说我们要去

00:18:57.870 --> 00:19:01.650
继续并启动应用程序

00:19:00.450 --> 00:19:03.720
应用程序将查看环境

00:19:01.650 --> 00:19:05.790
变量，然后它将了解

00:19:03.720 --> 00:19:09.210
所需的连接信息

00:19:05.790 --> 00:19:11.280
为我的续集实例或

00:19:09.210 --> 00:19:12.840
收入或用于电子邮件服务器

00:19:11.280 --> 00:19:14.370
现金或其中的任何现金

00:19:12.840 --> 00:19:16.620
环境变量将其插入

00:19:14.370 --> 00:19:18.660
然后使用它们来配置

00:19:16.620 --> 00:19:20.490
某种数据源或消息队列或

00:19:18.660 --> 00:19:22.650
或它试图连接的任何东西

00:19:20.490 --> 00:19:24.210
所以这是一个很好的模式，因为它

00:19:22.650 --> 00:19:26.580
表示我可以更改应用程序

00:19:24.210 --> 00:19:29.010
我可以做任何我想做的事，只要

00:19:26.580 --> 00:19:30.570
我可以解压缩该配置

00:19:29.010 --> 00:19:32.880
那些环境造反并适用

00:19:30.570 --> 00:19:35.160
它到我的基础设施我的中间件

00:19:32.880 --> 00:19:37.470
我知道我对数据源的绑定

00:19:35.160 --> 00:19:38.820
这样就没关系了

00:19:37.470 --> 00:19:40.140
我得到那些环境螺栓的地方

00:19:38.820 --> 00:19:42.360
在我的本地计算机或云中

00:19:40.140 --> 00:19:45.630
环境，或者您知道CI服务器，或者

00:19:42.360 --> 00:19:47.730
无论如何，甚至更好，因为我们

00:19:45.630 --> 00:19:50.340
在令人羡慕的地方使用Spring 

00:19:47.730 --> 00:19:51.809
隐藏的地方

00:19:50.340 --> 00:19:53.940
需要间接支持

00:19:51.809 --> 00:19:56.820
您可以在附近的特定网站上做

00:19:53.940 --> 00:19:58.830
你可以做不同的

00:19:56.820 --> 00:20:00.330
配置，它只是在Java中

00:19:58.830 --> 00:20:03.600
 Spring 的配置，这不在你的

00:20:00.330 --> 00:20:05.070
代码，然后您就可以知道您的

00:20:03.600 --> 00:20:07.110
代码是它所不知道的明智之举

00:20:05.070 --> 00:20:08.850
或关心数据源来自哪里

00:20:07.110 --> 00:20:10.410
如果它是一个嵌入式数据源

00:20:08.850 --> 00:20:12.330
本地机器，但这是我的顺序，因为

00:20:10.410 --> 00:20:14.460
在Cloud Foundry下运行，您知道谁

00:20:12.330 --> 00:20:17.490
很好，所以我们所做的就是

00:20:14.460 --> 00:20:18.840
将应用上传

00:20:17.490 --> 00:20:21.150
平台会看到它是一个Java 

00:20:18.840 --> 00:20:23.370
像我们说的它将运行的应用程序

00:20:21.150 --> 00:20:25.320
一系列的构建包，现在这些

00:20:23.370 --> 00:20:26.640
构建包是这些

00:20:25.320 --> 00:20:28.770
默认的构建包集为

00:20:26.640 --> 00:20:29.980
在Cloud Foundry中提供，并且仅

00:20:28.770 --> 00:20:32.200
提供你知道

00:20:29.980 --> 00:20:35.139
他们提供了一套著名的

00:20:32.200 --> 00:20:36.490
 Java开箱即用的账单包

00:20:35.139 --> 00:20:39.450
 Ruby的dotnet 

00:20:36.490 --> 00:20:43.529
二进制应用程序PHP应用程序等

00:20:39.450 --> 00:20:45.190
 Python nodejs，但是这些是

00:20:43.529 --> 00:20:46.720
最终在一天结束时

00:20:45.190 --> 00:20:49.450
只是充满脚本的目录和

00:20:46.720 --> 00:20:52.210
被执行等知名职位

00:20:49.450 --> 00:20:53.710
在某个周期内

00:20:52.210 --> 00:20:56.649
应用程序被推入云端

00:20:53.710 --> 00:20:58.570
我们检测到要使用的构建包

00:20:56.649 --> 00:21:00.340
在这种情况下分配给应用程序

00:20:58.570 --> 00:21:02.169
它意识到需要使用Java 

00:21:00.340 --> 00:21:04.090
 Villa Pack和鼓手Bill Peck 

00:21:02.169 --> 00:21:06.490
然后拿走工件，然后下载

00:21:04.090 --> 00:21:08.409
并放置一个文件系统， 

00:21:06.490 --> 00:21:10.630
包含所需的一切

00:21:08.409 --> 00:21:13.510
运行Java Spring Blue的此应用程序

00:21:10.630 --> 00:21:14.769
文件系统将要转到的应用程序

00:21:13.510 --> 00:21:16.419
为我们自动创建

00:21:14.769 --> 00:21:18.940
从头开始是全新的，所以没有

00:21:16.419 --> 00:21:19.990
某种国家的上限

00:21:18.940 --> 00:21:22.179
像这样的东西是可变的

00:21:19.990 --> 00:21:23.620
基础设施正确的配方

00:21:22.179 --> 00:21:24.880
创建该文件系统位于

00:21:23.620 --> 00:21:26.860
构建包，如果您不喜欢我们的

00:21:24.880 --> 00:21:28.720
特定的食谱，那么您可以提供

00:21:26.860 --> 00:21:30.580
自定义构建包，但好处

00:21:28.720 --> 00:21:32.860
使用构建包是我们现在有一个

00:21:30.580 --> 00:21:34.389
建立您的标准化模板

00:21:32.860 --> 00:21:36.070
知道将要运行的图像

00:21:34.389 --> 00:21:38.500
工作申请和图像

00:21:36.070 --> 00:21:40.990
运行一些运行dotnet的东西

00:21:38.500 --> 00:21:43.120
举例说明您想使用的那个

00:21:40.990 --> 00:21:45.269
构建包可以为您做到这一点

00:21:43.120 --> 00:21:47.889
创建文件系统后

00:21:45.269 --> 00:21:49.870
从你知道检查和工作

00:21:47.889 --> 00:21:52.720
与您上传的工件或罐子一起

00:21:49.870 --> 00:21:54.909
青蛙罐子文件在这种情况下，它将

00:21:52.720 --> 00:21:57.070
创建一个容器并将其部署

00:21:54.909 --> 00:21:59.110
整个集群中的容器并使其

00:21:57.070 --> 00:22:01.899
可用于交通，它给了

00:21:59.110 --> 00:22:03.909
也给它一个URL，所以这是

00:22:01.899 --> 00:22:07.809
我们获得CF的默认网址- 

00:22:03.909 --> 00:22:12.220
如果我将cats演示为I / O应用程序的C 

00:22:07.809 --> 00:22:14.289
去这里，去水库或更喜欢你

00:22:12.220 --> 00:22:16.269
可以看到数据在那里

00:22:14.289 --> 00:22:23.919
如果我在云应用程序中运行

00:22:16.269 --> 00:22:27.240
进入我的应用程序似乎

00:22:23.919 --> 00:22:29.740
浏览器插件不起作用

00:22:27.240 --> 00:22:34.630
索引我们去

00:22:29.740 --> 00:22:36.429
您可以看到它表示x中的实例

00:22:34.630 --> 00:22:38.460
等于零，所以我的意思是

00:22:36.429 --> 00:22:42.700
有一个应用程序实例

00:22:38.460 --> 00:22:45.609
现在可以消费了

00:22:42.700 --> 00:22:47.619
如果我的能力，如果我的需求应该

00:22:45.609 --> 00:22:50.980
如果我的申请，明天加倍

00:22:47.619 --> 00:22:53.499
出现在reddit上，或者您知道

00:22:50.980 --> 00:22:54.970
以前我们谈论斜线点

00:22:53.499 --> 00:22:56.679
我将能够处理该升级

00:22:54.970 --> 00:22:59.139
能力，所以我要做的就是

00:22:56.679 --> 00:23:05.859
要扩大规模，我会说我

00:22:59.139 --> 00:23:12.999
想说CF秤-I-CF猫演示

00:23:05.859 --> 00:23:15.340
所以我将其扩展到两个实例

00:23:12.999 --> 00:23:17.230
将I参数I缩放为

00:23:15.340 --> 00:23:19.960
我还可以扩展两个实例

00:23:17.230 --> 00:23:21.399
光盘，我可以扩展内存，我可以做

00:23:19.960 --> 00:23:22.690
这里有各种各样的事情，但我是

00:23:21.399 --> 00:23:24.340
其实我是在告诉

00:23:22.690 --> 00:23:25.960
拿走现有集装箱的平台

00:23:24.340 --> 00:23:27.279
它已经为我们建立，然后

00:23:25.960 --> 00:23:29.739
只是在某处剪切了一个新实例

00:23:27.279 --> 00:23:32.679
所以如果我们给它一些时间

00:23:29.739 --> 00:23:34.690
几秒钟，它将最终看到它

00:23:32.679 --> 00:23:36.489
开始负载平衡，所以现在

00:23:34.690 --> 00:23:49.869
说我们已经在实例上

00:23:36.489 --> 00:23:52.389
索引保存0 0 0 1所以有

00:23:49.869 --> 00:23:58.299
如果有我们的应用实例

00:23:52.389 --> 00:24:00.700
我们继续前进0 0 0 1等等，正确的是

00:23:58.299 --> 00:24:03.999
它来来回回，它看到

00:24:00.700 --> 00:24:06.220
更新的值，现在没有反弹

00:24:03.999 --> 00:24:08.409
跨两个不同节点的工作

00:24:06.220 --> 00:24:10.299
我们甚至可以配置自动扫描仪

00:24:08.409 --> 00:24:10.720
如果流量比我们多

00:24:10.299 --> 00:24:11.919
处理

00:24:10.720 --> 00:24:13.570
它会自动查看例如

00:24:11.919 --> 00:24:17.679
内存和CPU等

00:24:13.570 --> 00:24:18.909
现在根据这些指标进行扩展

00:24:17.679 --> 00:24:21.309
是与

00:24:18.909 --> 00:24:23.409
应用程序，我们可以看到我们有CF 

00:24:21.309 --> 00:24:26.049
正确的服务向我们展示了创造

00:24:23.409 --> 00:24:30.429
我们创建的服务

00:24:26.049 --> 00:24:31.899
 CF应用程序，您知道我们也可以看到

00:24:30.429 --> 00:24:34.119
推送应用程序有多容易

00:24:31.899 --> 00:24:35.980
等等，但是有时候你想看

00:24:34.119 --> 00:24:37.869
在内容上看数据本身

00:24:35.980 --> 00:24:40.179
还有一种更人性化的方式

00:24:37.869 --> 00:24:43.149
我们要去控制台上运行

00:24:40.179 --> 00:24:46.259
关键在于IO本身并登录并

00:24:43.149 --> 00:24:46.259
我们将看到我们的应用程序

00:24:55.960 --> 00:25:04.250
当您拥有关键网络时，现在好了

00:24:58.280 --> 00:25:06.530
服务，现在我已登录

00:25:04.250 --> 00:25:08.420
帐户，这表明我已经

00:25:06.530 --> 00:25:10.880
每个都有很多不同的应用程序

00:25:08.420 --> 00:25:12.050
我要去的这些不同的组织

00:25:10.880 --> 00:25:14.930
在这里选择合适的组织

00:25:12.050 --> 00:25:18.590
平台工程，我可以看到

00:25:14.930 --> 00:25:19.700
我有三个应用程序，其中两个

00:25:18.590 --> 00:25:21.440
刚刚停止了其中之一正在运行

00:25:19.700 --> 00:25:24.170
在一分钟前开始了

00:25:21.440 --> 00:25:27.320
的两个实例的运行我可以单击

00:25:24.170 --> 00:25:30.560
在此获取详细信息

00:25:27.320 --> 00:25:32.270
应用程序，我可以看到的服务

00:25:30.560 --> 00:25:35.270
我知道您已经准备好了

00:25:32.270 --> 00:25:37.280
在这里指定和你知道的计划

00:25:35.270 --> 00:25:39.980
可以在这里更改所有这些东西

00:25:37.280 --> 00:25:41.500
好改变设置

00:25:39.980 --> 00:25:44.900
也许重命名它，无论我想做什么

00:25:41.500 --> 00:25:48.860
而且你也知道

00:25:44.900 --> 00:25:54.470
对，当然是我最喜欢的之一

00:25:48.860 --> 00:25:56.180
对此的看法是

00:25:54.470 --> 00:25:58.360
您在PCF指标中获得的信息

00:25:56.180 --> 00:26:01.070
在这里正确，因此，如果您单击指标

00:25:58.360 --> 00:26:03.080
 PCF指标可为您提供实时排序

00:26:01.070 --> 00:26:04.430
分析进入的流量

00:26:03.080 --> 00:26:05.780
应用程序显示请求

00:26:04.430 --> 00:26:07.490
错误所有的东西，它

00:26:05.780 --> 00:26:09.260
向您展示了一种与之相关的视图

00:26:07.490 --> 00:26:11.900
日志还是请求日志

00:26:09.260 --> 00:26:13.250
这样您就可以获得很多信息

00:26:11.900 --> 00:26:14.480
推动此应用程序，您将获得一个内置的

00:26:13.250 --> 00:26:16.850
在仪表板中，您会得到很多

00:26:14.480 --> 00:26:18.500
您想要的有趣信息

00:26:16.850 --> 00:26:19.850
了解应用程序

00:26:18.500 --> 00:26:21.820
正在运行的容器

00:26:19.850 --> 00:26:24.110
应用所有的东西都在这里

00:26:21.820 --> 00:26:25.700
自动为您提供现场

00:26:24.110 --> 00:26:28.130
对，这是交互式的，因此您可以

00:26:25.700 --> 00:26:29.780
外观和非常小的粒度

00:26:28.130 --> 00:26:32.240
非常大的，以此类推

00:26:29.780 --> 00:26:33.320
这类信息而已

00:26:32.240 --> 00:26:35.060
由于我们推动了

00:26:33.320 --> 00:26:37.130
我们刚刚建立的应用程序

00:26:35.060 --> 00:26:40.160
启动 Spring 一个I / O现在一个问题

00:26:37.130 --> 00:26:42.530
您可能想知道是怎么知道的

00:26:40.160 --> 00:26:46.010
它应该写入哪个数据库

00:26:42.530 --> 00:26:48.920
我在

00:26:46.010 --> 00:26:51.350
本地机器，然后我看到我已经推

00:26:48.920 --> 00:26:53.240
它到一个云平台和一些

00:26:51.350 --> 00:26:54.800
这些东西仍在工作或至少

00:26:53.240 --> 00:26:56.840
它似乎正在工作，您可能会

00:26:54.800 --> 00:26:58.460
想知道这是怎么回事

00:26:56.840 --> 00:27:00.200
发生的是 Spring 不愿

00:26:58.460 --> 00:27:01.610
从梅西百货切下来的时候

00:27:00.200 --> 00:27:05.660
在这种情况下可以识别的类型

00:27:01.610 --> 00:27:07.770
 Java，如果愿意，它会重写

00:27:05.660 --> 00:27:10.470
尽力做到

00:27:07.770 --> 00:27:12.930
我们放置不同种类的定义

00:27:10.470 --> 00:27:22.260
传入中的数据源定义

00:27:12.930 --> 00:27:24.200
在这种情况下，您知道

00:27:22.260 --> 00:27:26.700
在这种情况下，它代替了它

00:27:24.200 --> 00:27:29.850
以编程方式添加一个bean工厂

00:27:26.700 --> 00:27:32.040
取代任何Spring 的后处理器

00:27:29.850 --> 00:27:33.930
用于数据源类型的bean 

00:27:32.040 --> 00:27:35.640
它为我们创造了一个

00:27:33.930 --> 00:27:37.740
自动指向

00:27:35.640 --> 00:27:39.530
正确配置了我的顺序，因为

00:27:37.740 --> 00:27:42.030
在这种云友好环境中运行

00:27:39.530 --> 00:27:45.360
环境，所以这是伟大的作品

00:27:42.030 --> 00:27:47.670
如果您是我的续集或

00:27:45.360 --> 00:27:49.560
一个rabbitmq，对于

00:27:47.670 --> 00:27:51.660
您知道后勤服务应该是

00:27:49.560 --> 00:27:53.280
它应该被应用或者你是

00:27:51.660 --> 00:27:55.170
已连接，但如果您有超过

00:27:53.280 --> 00:27:57.570
一个然后变得非常有用

00:27:55.170 --> 00:27:59.280
能够消除歧义，为此，我们

00:27:57.570 --> 00:28:02.520
有Spring 云连接器，所以如果

00:27:59.280 --> 00:28:06.450
你去开始 Spring 那个IO和你

00:28:02.520 --> 00:28:07.980
看一下这些连接器

00:28:06.450 --> 00:28:09.930
将提供额外的

00:28:07.980 --> 00:28:13.010
间接地以编程方式

00:28:09.930 --> 00:28:14.970
 Spring Java Config友好的方式

00:28:13.010 --> 00:28:16.710
补充不同的数据源和

00:28:14.970 --> 00:28:19.500
 RabbitMQ实例和消息队列

00:28:16.710 --> 00:28:21.570
等等，您知道缓存等等

00:28:19.500 --> 00:28:23.370
取决于时间和类型

00:28:21.570 --> 00:28:25.470
您要使用的对象，然后

00:28:23.370 --> 00:28:28.440
将其指向支持服务

00:28:25.470 --> 00:28:30.780
服务ID名称，而不是硬编码

00:28:28.440 --> 00:28:33.720
用户名，密码和主机等

00:28:30.780 --> 00:28:37.200
这样我们就有了一个应用

00:28:33.720 --> 00:28:39.270
在云中，我们可以获得可见性

00:28:37.200 --> 00:28:42.120
调查这里发生的事情

00:28:39.270 --> 00:28:43.710
在如何扩大规模等等，现在我们

00:28:42.120 --> 00:28:45.510
也可以看一下日志，所以我

00:28:43.710 --> 00:28:47.820
显示您的日志在那里，但这是一回事

00:28:45.510 --> 00:28:50.130
你应该欣赏的是，他们是

00:28:47.820 --> 00:28:54.260
这里的日志正在多路复用

00:28:50.130 --> 00:28:54.260
森林自动，所以我可以说CF日志

00:28:59.650 --> 00:29:04.659
所以有请求的日志

00:29:01.630 --> 00:29:08.340
已经发送到我们的应用程序中

00:29:04.659 --> 00:29:08.340
我们可以像这样尾巴

00:29:13.470 --> 00:29:21.710
好吧，如果我在这里提出一些要求

00:29:16.830 --> 00:29:23.789
在那里排队，我们可以看到

00:29:21.710 --> 00:29:27.480
信息通过两者路由

00:29:23.789 --> 00:29:30.330
您在一日志中知道的实例一日志

00:29:27.480 --> 00:29:32.789
流，您可以配置自定义种类的

00:29:30.330 --> 00:29:36.029
支持系统日志流失的服务

00:29:32.789 --> 00:29:38.850
那个流失只是服务X 

00:29:36.029 --> 00:29:42.629
说出您知道的syslog协议

00:29:38.850 --> 00:29:44.669
 Unix，然后接受

00:29:42.629 --> 00:29:46.590
从此多路复用器生成

00:29:44.669 --> 00:29:47.850
这叫做对数辐射器，它是

00:29:46.590 --> 00:29:50.700
只是Cloud Foundry中的另一个组件

00:29:47.850 --> 00:29:52.500
如果您正在使用排水管，可以

00:29:50.700 --> 00:29:54.480
指定任何您知道有效的子弹

00:29:52.500 --> 00:29:57.450
端点像elasticsearch这样

00:29:54.480 --> 00:29:58.529
纸迹喜欢布兰奇等，这

00:29:57.450 --> 00:30:01.320
信息将自动

00:29:58.529 --> 00:30:03.480
出现在您的支持服务中

00:30:01.320 --> 00:30:04.740
好吧，现在我们有一个

00:30:03.480 --> 00:30:07.409
我们在生产中的应用

00:30:04.740 --> 00:30:08.519
如何添加支持服务

00:30:07.409 --> 00:30:11.340
我们研究了如何构建应用程序

00:30:08.519 --> 00:30:12.750
可以推入云端

00:30:11.340 --> 00:30:15.330
看了一些操作工具

00:30:12.750 --> 00:30:16.830
以及您获得的可观察性工具，以及

00:30:15.330 --> 00:30:18.990
所以我希望你现在有所赞赏

00:30:16.830 --> 00:30:21.210
因为这里可能，我会

00:30:18.990 --> 00:30:23.070
可以得到的很多速度

00:30:21.210 --> 00:30:24.120
使用诸如卡片正面之类的东西

00:30:23.070 --> 00:30:26.370
这很棒，因为这意味着

00:30:24.120 --> 00:30:27.570
想要的高绩效组织

00:30:26.370 --> 00:30:29.190
投入生产并想要担心

00:30:27.570 --> 00:30:31.230
关于最重要的事情

00:30:29.190 --> 00:30:32.070
参与他们的组织和

00:30:31.230 --> 00:30:33.629
他们最重要的事情

00:30:32.070 --> 00:30:35.879
编写软件的组织

00:30:33.629 --> 00:30:37.710
他们可以只专注于

00:30:35.879 --> 00:30:40.649
在这种情况下，Spring 应用是

00:30:37.710 --> 00:30:43.289
非常非常有生产力，而且实际上没有

00:30:40.649 --> 00:30:46.620
关于那之前的东西

00:30:43.289 --> 00:30:49.019
正确设置服务器，您

00:30:46.620 --> 00:30:50.759
知道配置CPU和Linux内核

00:30:49.019 --> 00:30:53.100
和安全以及所有这些东西

00:30:50.759 --> 00:30:54.629
好了，非常感谢你，我

00:30:53.100 --> 00:30:56.690
希望你喜欢这个，我会见到你

00:30:54.629 --> 00:30:56.690
周围

00:31:02.860 --> 00:31:04.920
您

