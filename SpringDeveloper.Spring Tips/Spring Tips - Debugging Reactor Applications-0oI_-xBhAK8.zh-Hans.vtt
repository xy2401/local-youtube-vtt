WEBVTT
Kind: captions
Language: zh-Hans

00:00:25.500 --> 00:00:30.099
嗨，春季粉丝们欢迎来到另一个

00:00:27.910 --> 00:00:32.800
在这一部分中的Spring 提示

00:00:30.099 --> 00:00:35.140
我们将看看您知道的

00:00:32.800 --> 00:00:36.699
我经常被问到哪个问题

00:00:35.140 --> 00:00:39.220
我正在使用一个全新的应用程序

00:00:36.699 --> 00:00:41.110
您知道的新的反应式支持

00:00:39.220 --> 00:00:43.930
你希望听到我谈论

00:00:41.110 --> 00:00:45.100
最近的两个多奇年和 Spring 

00:00:43.930 --> 00:00:48.100
整个团队，您已经知道

00:00:45.100 --> 00:00:51.909
春季L博客和

00:00:48.100 --> 00:00:53.710
有关该主题的很多视频

00:00:51.909 --> 00:00:56.050
来自各种会议

00:00:53.710 --> 00:00:58.780
 Spring 一个平台表明我的意思是不

00:00:56.050 --> 00:01:00.010
提到你真的知道数百

00:00:58.780 --> 00:01:03.100
我的意思是世界各地的会议

00:01:00.010 --> 00:01:04.899
希望在这一点上你被说服

00:01:03.100 --> 00:01:07.090
对，我希望你能体谅

00:01:04.899 --> 00:01:09.250
反应式编程为您提供了

00:01:07.090 --> 00:01:10.960
能够更快地构建更好的软件

00:01:09.250 --> 00:01:13.229
它给了您更多的能力

00:01:10.960 --> 00:01:15.490
确切地说是在技术上

00:01:13.229 --> 00:01:17.710
利用以下优势的应用程序

00:01:15.490 --> 00:01:19.810
异步I / O，以更好地支持

00:01:17.710 --> 00:01:21.670
吞吐能力更好

00:01:19.810 --> 00:01:23.740
可扩展性，因此您可以处理更多

00:01:21.670 --> 00:01:25.390
使用同一台计算机进行交易

00:01:23.740 --> 00:01:27.640
因为你不再坐在

00:01:25.390 --> 00:01:29.950
给定线程垄断一个线程

00:01:27.640 --> 00:01:33.280
使其他人无法使用

00:01:29.950 --> 00:01:35.170
通过这样做您就可以构建

00:01:33.280 --> 00:01:36.939
可以处理更多用户的软件

00:01:35.170 --> 00:01:42.340
权利相同，成本相同

00:01:36.939 --> 00:01:43.780
或者您可以拥有数据中心

00:01:42.340 --> 00:01:44.890
建立正确，而不是加倍

00:01:43.780 --> 00:01:47.710
你可以拥有的用户数量

00:01:44.890 --> 00:01:49.799
使用您知道1/2 + 2 X一样简单

00:01:47.710 --> 00:01:52.240
数字，但关键是你可以

00:01:49.799 --> 00:01:55.060
以相同的费用处理更多的用户，或者

00:01:52.240 --> 00:01:56.680
您可以花更少的钱处理相同的用户

00:01:55.060 --> 00:01:58.479
成本权，那就是其中之一

00:01:56.680 --> 00:01:59.829
这里最大的好处，它可以让你

00:01:58.479 --> 00:02:02.619
正确扩展它可以使您

00:01:59.829 --> 00:02:04.420
处理更大的能力

00:02:02.619 --> 00:02:06.460
请求数，这是

00:02:04.420 --> 00:02:08.920
当您移至

00:02:06.460 --> 00:02:10.450
微服务转变为物联网转变为大数据

00:02:08.920 --> 00:02:12.340
你的地方越来越大

00:02:10.450 --> 00:02:14.860
通过连接的数据量

00:02:12.340 --> 00:02:17.049
通过网络缓冲区来表示网络

00:02:14.860 --> 00:02:18.910
输入和输出无功编程

00:02:17.049 --> 00:02:21.609
全部关于输入和输出

00:02:18.910 --> 00:02:23.140
我的意思是我想你可以说

00:02:21.609 --> 00:02:25.870
关于其他一些用例吧

00:02:23.140 --> 00:02:27.160
有一个事实，即反应性

00:02:25.870 --> 00:02:30.450
编程使您能够

00:02:27.160 --> 00:02:32.650
关于您的错误的更好原因

00:02:30.450 --> 00:02:35.349
您知道的处理流程

00:02:32.650 --> 00:02:36.849
数据，为您提供实用的样式方式

00:02:35.349 --> 00:02:38.160
使它看起来也是如此

00:02:36.849 --> 00:02:39.450
更优雅和

00:02:38.160 --> 00:02:42.240
它给你一个构图模型

00:02:39.450 --> 00:02:44.460
是基于或的解耦

00:02:42.240 --> 00:02:46.410
某种程度的组装分离

00:02:44.460 --> 00:02:47.940
来自

00:02:46.410 --> 00:02:49.770
订阅管道处理

00:02:47.940 --> 00:02:52.020
管道，我们说，大会

00:02:49.770 --> 00:02:55.140
的管道很冷，对

00:02:52.020 --> 00:02:56.220
冷数据流就像

00:02:55.140 --> 00:02:58.050
一系列的管道已经

00:02:56.220 --> 00:02:59.190
连接在一起但直到倒

00:02:58.050 --> 00:03:01.500
把水倒进那些管子里

00:02:59.190 --> 00:03:05.250
那是订阅或执行

00:03:01.500 --> 00:03:07.260
时间，然后我们说那是感冒

00:03:05.250 --> 00:03:09.390
当它里面有水时流

00:03:07.260 --> 00:03:11.790
管道，然后是热流吧

00:03:09.390 --> 00:03:13.350
您现在处于执行时间，所以您

00:03:11.790 --> 00:03:16.140
定义管道数据通过它

00:03:13.350 --> 00:03:17.520
然后这两件事可能发生

00:03:16.140 --> 00:03:19.290
您可以分别定义管道

00:03:17.520 --> 00:03:23.130
数据有时会流过

00:03:19.290 --> 00:03:25.350
从现在开始一个小时的管道

00:03:23.130 --> 00:03:28.290
这样做的好处是

00:03:25.350 --> 00:03:31.440
有机会干预你

00:03:28.290 --> 00:03:33.270
可以实际上您可以拥有

00:03:31.440 --> 00:03:35.220
操作员，您可以安排调度员

00:03:33.270 --> 00:03:36.720
可以拥有知道的框架

00:03:35.220 --> 00:03:37.620
这个管道，它知道如何

00:03:36.720 --> 00:03:39.300
这些东西粘在一起

00:03:37.620 --> 00:03:41.730
您可以代表您进行干预

00:03:39.300 --> 00:03:44.580
这样它就可以重新组装东西

00:03:41.730 --> 00:03:46.680
添加额外的步骤，例如进行审核

00:03:44.580 --> 00:03:48.090
或进行调试，它可以做各种

00:03:46.680 --> 00:03:50.610
有趣的事情也可以重新排列

00:03:48.090 --> 00:03:52.709
看到可能的优化的事情

00:03:50.610 --> 00:03:54.270
并且可能能够融合某些

00:03:52.709 --> 00:03:55.860
你可能会知道两个运算符

00:03:54.270 --> 00:03:58.050
可以合二为一的步骤

00:03:55.860 --> 00:04:00.360
因为你有一个临时的

00:03:58.050 --> 00:04:01.920
编译器发生的事情

00:04:00.360 --> 00:04:03.450
场景不是真的，但是你

00:04:01.920 --> 00:04:05.520
有优化就可以了

00:04:03.450 --> 00:04:08.340
搬家有很多机会

00:04:05.520 --> 00:04:09.540
进行反应式编程并移至

00:04:08.340 --> 00:04:12.090
一个给你能力的框架

00:04:09.540 --> 00:04:14.489
用这种方式思考事情， 

00:04:12.090 --> 00:04:15.930
因此，你也有更多

00:04:14.489 --> 00:04:18.090
一次有趣的机会

00:04:15.930 --> 00:04:22.160
进行思考和思考的地方

00:04:18.090 --> 00:04:25.010
关于错误，还有我

00:04:22.160 --> 00:04:27.810
认为这是一种自然的思考方式

00:04:25.010 --> 00:04:29.010
整合，因为如果您必须考虑

00:04:27.810 --> 00:04:31.470
关于如何与他人互动

00:04:29.010 --> 00:04:35.370
系统，如果您必须选择一个

00:04:31.470 --> 00:04:38.850
方式选择我想要的同步权利

00:04:35.370 --> 00:04:40.770
连接两种不同类型的数据

00:04:38.850 --> 00:04:41.880
那里有些系统很容易

00:04:40.770 --> 00:04:45.180
与...整合

00:04:41.880 --> 00:04:48.539
同步API，有些很容易

00:04:45.180 --> 00:04:51.900
集成在异步API中，但是您

00:04:48.539 --> 00:04:57.030
你不能不能合成或伪造

00:04:51.900 --> 00:04:58.770
阻止互动的问题，对不起， 

00:04:57.030 --> 00:05:00.509
阻止无法伪造的互动

00:04:58.770 --> 00:05:03.030
与...同步互动

00:05:00.509 --> 00:05:04.470
异步集成，所以如果我想

00:05:03.030 --> 00:05:06.360
谈论出版的东西

00:05:04.470 --> 00:05:07.949
异步消息是不可能的

00:05:06.360 --> 00:05:09.990
做到这一点，除了异步

00:05:07.949 --> 00:05:11.639
另一方面，如果我想服用

00:05:09.990 --> 00:05:13.380
异步的东西

00:05:11.639 --> 00:05:15.150
然后以阻塞的方式消耗它

00:05:13.380 --> 00:05:16.860
这样做我可以正确模拟，所以如果

00:05:15.150 --> 00:05:19.199
你必须选择一种类型

00:05:16.860 --> 00:05:21.479
首先异步，所以当你

00:05:19.199 --> 00:05:23.300
处理反应堆API和

00:05:21.479 --> 00:05:25.410
您正在处理的反应式API 

00:05:23.300 --> 00:05:28.139
异步API，这为您提供了

00:05:25.410 --> 00:05:29.880
认识世界的好方法

00:05:28.139 --> 00:05:32.130
可以在这个方面与世界打交道

00:05:29.880 --> 00:05:33.840
一种反应流

00:05:32.130 --> 00:05:36.120
数据，因此无论您是在与

00:05:33.840 --> 00:05:38.010
 REST API或从中获取数据

00:05:36.120 --> 00:05:39.440
数据库或进行消息传递，或者您正在

00:05:38.010 --> 00:05:41.880
在做WebSockets或在做

00:05:39.440 --> 00:05:43.650
应用JSON仅五条记录

00:05:41.880 --> 00:05:45.720
知道你在做什么就可以应付

00:05:43.650 --> 00:05:47.389
就此发布者API而言

00:05:45.720 --> 00:05:50.039
这是反应流的核心

00:05:47.389 --> 00:05:52.289
规格还可以，您可以在其中处理

00:05:50.039 --> 00:05:53.940
附带的运营商条款

00:05:52.289 --> 00:05:55.229
电抗器和电抗器使其易于

00:05:53.940 --> 00:05:56.460
建立这种反应性

00:05:55.229 --> 00:05:58.139
应用程序，我已经谈了很多

00:05:56.460 --> 00:06:00.180
关于所有这些东西，在我不这样做之前

00:05:58.139 --> 00:06:03.539
真的很想深入了解

00:06:00.180 --> 00:06:05.699
但在本期 spring 技巧 中

00:06:03.539 --> 00:06:09.270
我的朋友们，我们来看看

00:06:05.699 --> 00:06:11.639
它是建立应用程序

00:06:09.270 --> 00:06:12.659
反应性以及调试的内容

00:06:11.639 --> 00:06:14.490
他们正确的是一些

00:06:12.659 --> 00:06:17.099
我们有机会隔离

00:06:14.490 --> 00:06:18.330
反应性应用程序中的问题

00:06:17.099 --> 00:06:20.370
因为正如我刚刚确定的

00:06:18.330 --> 00:06:22.470
反应性应用至少在

00:06:20.370 --> 00:06:24.270
程序模型术语异步

00:06:22.470 --> 00:06:25.889
默认情况下，我们将建立一个

00:06:24.270 --> 00:06:29.449
在这里申请开始 Spring 

00:06:25.889 --> 00:06:32.699
 I / O我们将称之为调试

00:06:29.449 --> 00:06:34.080
反应堆好了，我们将使用

00:06:32.699 --> 00:06:35.760
我要使用反应式网络支持

00:06:34.080 --> 00:06:37.169
真的不想要我不想要的网络服务器

00:06:35.760 --> 00:06:39.210
关心我只想要的Web服务器

00:06:37.169 --> 00:06:41.220
会带进反应堆的东西

00:06:39.210 --> 00:06:43.110
所有这些东西，还有这个

00:06:41.220 --> 00:06:46.349
具有启动网络的好处

00:06:43.110 --> 00:06:47.610
服务器，因此它将保留Java 

00:06:46.349 --> 00:06:50.520
进程运行否则我的

00:06:47.610 --> 00:06:52.650
您知道异步API 

00:06:50.520 --> 00:06:54.960
他们不是，他们不会继续这一过程

00:06:52.650 --> 00:06:57.599
除非我做点什么才能跑步

00:06:54.960 --> 00:06:59.460
他们是老恶魔，所以我只用它来

00:06:57.599 --> 00:07:01.469
解决这个问题好吧，然后

00:06:59.460 --> 00:07:05.310
我们只是要点击生成我们

00:07:01.469 --> 00:07:05.830
好的，所以我认为这可能是

00:07:05.310 --> 00:07:09.009
最简单的

00:07:05.830 --> 00:07:10.659
根据我所拥有的依赖关系进行演示

00:07:09.009 --> 00:07:11.620
曾经为你做过我的好朋友，所以

00:07:10.659 --> 00:07:12.970
那是割伤

00:07:11.620 --> 00:07:14.470
我现在想起来很有趣

00:07:12.970 --> 00:07:16.270
甚至没有龙目岛那有多酷

00:07:14.470 --> 00:07:17.590
我也许应该在其中放广告

00:07:16.270 --> 00:07:19.449
龙目岛我不知道你会看到我会

00:07:17.590 --> 00:07:21.940
添加一些依赖关系，也许我

00:07:19.449 --> 00:07:25.449
我们不应该超越自己

00:07:21.940 --> 00:07:26.710
要做的只是展示一些

00:07:25.449 --> 00:07:30.639
调试的机会

00:07:26.710 --> 00:07:31.030
 IntelliJ做的事情我们想要在那里

00:07:30.639 --> 00:07:34.409
我们去

00:07:31.030 --> 00:07:38.349
我的应用程序是什么

00:07:34.409 --> 00:07:38.860
我们要走了，我们要生活

00:07:38.349 --> 00:07:40.569
更轻松

00:07:38.860 --> 00:07:42.819
对，我将是第一个承认

00:07:40.569 --> 00:07:45.639
转移到异步世界

00:07:42.819 --> 00:07:47.409
处理的执行可以跳到哪里

00:07:45.639 --> 00:07:50.560
从一个线程到另一个

00:07:47.409 --> 00:07:53.199
你知道缓解和几乎令人震惊的趋势

00:07:50.560 --> 00:07:54.550
有点不透明可能会让人望而生畏

00:07:53.199 --> 00:07:56.020
首先，尤其是如果您不是

00:07:54.550 --> 00:07:57.849
习惯于函数式编程（如果您

00:07:56.020 --> 00:08:01.210
不习惯函数编程

00:07:57.849 --> 00:08:02.830
可能是从

00:08:01.210 --> 00:08:04.210
非功能命令式编程

00:08:02.830 --> 00:08:06.190
他自己的函数式编程

00:08:04.210 --> 00:08:09.159
事情然后再加倍

00:08:06.190 --> 00:08:11.050
我想让它变得更加艰巨

00:08:09.159 --> 00:08:12.849
有些人就是这一切

00:08:11.050 --> 00:08:14.409
异步的，所以你有你

00:08:12.849 --> 00:08:16.960
知道工作的移动

00:08:14.409 --> 00:08:17.889
争用不同的线程边界

00:08:16.960 --> 00:08:20.289
与以及可以做到这一点

00:08:17.889 --> 00:08:21.789
今晚很难，我知道你是什么

00:08:20.289 --> 00:08:24.009
在这一点上，我想你知道GE 

00:08:21.789 --> 00:08:25.630
你怎么做才能做到这一点

00:08:24.009 --> 00:08:27.219
乔希（Josh）更难

00:08:25.630 --> 00:08:28.870
像这样会成为一个

00:08:27.219 --> 00:08:30.130
上坡，我不认为那是

00:08:28.870 --> 00:08:32.289
是的，我认为这需要一些练习

00:08:30.130 --> 00:08:34.630
还有一点肌肉记忆可以欣赏

00:08:32.289 --> 00:08:36.459
该工具和API并开始

00:08:34.630 --> 00:08:38.440
编写代码只是为了看到它

00:08:36.459 --> 00:08:40.089
以您认为的方式运作，而且大多数

00:08:38.440 --> 00:08:41.469
如果你不知道的时候

00:08:40.089 --> 00:08:44.800
在一个友好的社区工作，或者

00:08:41.469 --> 00:08:47.860
你知道歌剧自我描述的方法

00:08:44.800 --> 00:08:51.910
你可以打电话或类似的东西，但

00:08:47.860 --> 00:08:53.350
可能是我想在

00:08:51.910 --> 00:08:54.699
首先，特别是如果

00:08:53.350 --> 00:08:57.070
你都没有做过而你

00:08:54.699 --> 00:08:58.660
可能在想，我知道我会

00:08:57.070 --> 00:09:00.250
宁愿移到太阳表面我

00:08:58.660 --> 00:09:01.930
意味着这看起来更容易

00:09:00.250 --> 00:09:05.980
好问我这样做，但事实并非如此

00:09:01.930 --> 00:09:07.029
不好吧，好吧，让我们谈谈

00:09:05.980 --> 00:09:09.130
谈论一些明显的东西

00:09:07.029 --> 00:09:12.190
好，所以我有一个应用程序

00:09:09.130 --> 00:09:14.380
将会成为事件监听器，并在

00:09:12.190 --> 00:09:17.740
事件监听器，我要听一个

00:09:14.380 --> 00:09:19.360
事件应用程序就绪事件，以及

00:09:17.740 --> 00:09:20.980
这就是我

00:09:19.360 --> 00:09:23.680
启动我只是在等待

00:09:20.980 --> 00:09:25.420
应用程序启动，我将运行

00:09:23.680 --> 00:09:26.860
一些代码，代码将是

00:09:25.420 --> 00:09:28.959
可以使用的简单演示代码

00:09:26.860 --> 00:09:29.769
你还好，让我们来看看其他一些

00:09:28.959 --> 00:09:35.740
这里的机会

00:09:29.769 --> 00:09:37.720
首先，我想说

00:09:35.740 --> 00:09:40.510
生成数据流，所以我会说

00:09:37.720 --> 00:09:43.720
弹性点生成或实际上更好

00:09:40.510 --> 00:09:45.250
证明那是公正的，而我正在做的是

00:09:43.720 --> 00:09:47.290
在这里创建一个反应类型，好吧

00:09:45.250 --> 00:09:49.240
创建一个支持0的发布商

00:09:47.290 --> 00:09:53.860
到X记录的流量

00:09:49.240 --> 00:09:56.890
 Monos支持交互式类型，它

00:09:53.860 --> 00:09:59.260
支持0或1条记录，所以这些是

00:09:56.890 --> 00:10:02.440
两者都来自反应堆

00:09:59.260 --> 00:10:04.420
的发布者界面

00:10:02.440 --> 00:10:07.000
他们都反应流规格

00:10:04.420 --> 00:10:08.709
向订阅者发布数据流

00:10:07.000 --> 00:10:11.740
这些订阅者可以在

00:10:08.709 --> 00:10:13.480
不同的线程和出版物

00:10:11.740 --> 00:10:18.810
数据也可以单独发生

00:10:13.480 --> 00:10:25.769
线程，所以我要创建abcd 

00:10:18.810 --> 00:10:28.810
是的，好吧，只是一连串的信件和

00:10:25.769 --> 00:10:30.670
现在我要做的是我要登录我

00:10:28.810 --> 00:10:32.140
猜猜你可以做的最明显的事情

00:10:30.670 --> 00:10:34.300
调试东西是你可以用来

00:10:32.140 --> 00:10:36.990
订阅你们的订阅权， 

00:10:34.300 --> 00:10:38.890
如果您使用

00:10:36.990 --> 00:10:40.870
反应流规格

00:10:38.890 --> 00:10:43.120
实现订阅需要一个

00:10:40.870 --> 00:10:45.220
订户和订户有点

00:10:43.120 --> 00:10:47.620
详细的界面，您可以在这里看到

00:10:45.220 --> 00:10:49.870
对，所以订户，然后有

00:10:47.620 --> 00:10:52.449
订阅接下来是

00:10:49.870 --> 00:10:53.320
错误，总的来说，我不要你

00:10:52.449 --> 00:10:55.480
从事写作

00:10:53.320 --> 00:10:57.730
订户，我可能不需要

00:10:55.480 --> 00:10:59.350
大多数时候使用一个

00:10:57.730 --> 00:11:01.959
重载方法

00:10:59.350 --> 00:11:03.850
所以这是消费者，我可以

00:11:01.959 --> 00:11:05.529
你知道这需要字符串参数

00:11:03.850 --> 00:11:07.720
你知道我们已经收到的那封信

00:11:05.529 --> 00:11:09.490
在这里表达，它可以让你做

00:11:07.720 --> 00:11:11.050
有东西，所以我应该

00:11:09.490 --> 00:11:13.300
带了龙目岛哦，我已经后悔了

00:11:11.050 --> 00:11:14.740
好的，私人决赛，你知道我是什么

00:11:13.300 --> 00:11:16.570
要带龙目岛我就是那种

00:11:14.740 --> 00:11:21.370
家伙，我很懒，我宁愿加一个

00:11:16.570 --> 00:11:26.529
然后编写额外的代码

00:11:21.370 --> 00:11:30.029
渴望J没有错一个龙目岛好

00:11:26.529 --> 00:11:32.770
好吧，你看到我怎么样了吗

00:11:30.029 --> 00:11:36.339
刚唱歌

00:11:32.770 --> 00:11:39.070
我只唱了长钱这个词，然后

00:11:36.339 --> 00:11:40.720
几乎就像是魔术般

00:11:39.070 --> 00:11:41.290
看起来很酷，我不喜欢

00:11:40.720 --> 00:11:46.270
知道什么

00:11:41.290 --> 00:11:50.410
无论如何um log4j-谢谢

00:11:46.270 --> 00:11:56.279
好东西，现在有我的记录器，我

00:11:50.410 --> 00:12:00.490
现在可以注销了，没有字母了

00:11:56.279 --> 00:12:03.339
好东西好吧

00:12:00.490 --> 00:12:05.440
有这个，我只是在记录

00:12:03.339 --> 00:12:07.690
数据，但是如果有错误怎么办？ 

00:12:05.440 --> 00:12:12.250
如果我想要某种东西的话

00:12:07.690 --> 00:12:14.140
这里的错误，所以让我们说

00:12:12.250 --> 00:12:16.180
我要去做一张地图我要说好

00:12:14.140 --> 00:12:18.339
好还是更好，但我会做到的

00:12:16.180 --> 00:12:25.170
地图，然后在地图上

00:12:18.339 --> 00:12:35.070
异常好吧，如果X是它的字母，那么好吧

00:12:25.170 --> 00:12:35.070
如果字母点e等于当然

00:12:36.990 --> 00:12:52.070
好吧等于F然后返回我要去

00:12:46.530 --> 00:12:57.900
在这里做平面地图然后返回单声道错误

00:12:52.070 --> 00:13:02.430
合法的，比如说静态类是非法的

00:12:57.900 --> 00:13:06.990
由于某种原因造成的信件异常

00:13:02.430 --> 00:13:08.490
选择让很难

00:13:06.990 --> 00:13:10.470
流中的字母F我不知道为什么

00:13:08.490 --> 00:13:12.150
不管实际上不重要，我们

00:13:10.470 --> 00:13:15.240
只想要某种错误情况就可以了

00:13:12.150 --> 00:13:29.480
所以我们会说新的非法信件

00:13:15.240 --> 00:13:29.480
例外，没事，好东西

00:13:33.020 --> 00:13:40.320
好东西

00:13:37.010 --> 00:13:42.750
所以实际上我们甚至不需要

00:13:40.320 --> 00:13:44.520
所以当我们扔的时候

00:13:42.750 --> 00:13:47.930
假设它是F，则应始终

00:13:44.520 --> 00:13:52.070
抛出一个错误，那还可以

00:13:47.930 --> 00:13:54.840
我们要说返回单字型

00:13:52.070 --> 00:13:57.510
信，所以我要回来，我会继续

00:13:54.840 --> 00:13:59.310
除F以外的所有字母

00:13:57.510 --> 00:14:01.440
任意原因只是真的

00:13:59.310 --> 00:14:06.120
不喜欢，所以我们要摆脱

00:14:01.440 --> 00:14:08.430
其中，并会继续监视我的

00:14:06.120 --> 00:14:09.900
你知道字母，否则好东西

00:14:08.430 --> 00:14:11.370
所以现在我实际上只是将地图

00:14:09.900 --> 00:14:12.540
数据我顺便说一句

00:14:11.370 --> 00:14:15.090
这就是我们的意思，假设我们有一个

00:14:12.540 --> 00:14:17.340
我们的河很冷，所以我

00:14:15.090 --> 00:14:20.580
实际上在这里产生冷的蒸汽

00:14:17.340 --> 00:14:23.370
信件，所以你去了，我感冒了

00:14:20.580 --> 00:14:25.650
流，如果我突然订阅它

00:14:23.370 --> 00:14:26.460
我正在订阅时变得热门

00:14:25.650 --> 00:14:29.940
对此

00:14:26.460 --> 00:14:32.550
你实际上可以服用一些

00:14:29.940 --> 00:14:34.380
冷流变成热

00:14:32.550 --> 00:14:36.510
流，所以基本上是冷流意味着

00:14:34.380 --> 00:14:40.050
那是一条空管道，一无所有

00:14:36.510 --> 00:14:42.000
正在流过它，所以你

00:14:40.050 --> 00:14:43.440
知道它将重播整个管道

00:14:42.000 --> 00:14:46.650
从一开始就从通量开始

00:14:43.440 --> 00:14:48.390
只是一个，然后是平面图，然后您

00:14:46.650 --> 00:14:49.710
知道什么权利，然后继续前进

00:14:48.390 --> 00:14:51.180
通过运营商，我可以做过滤器

00:14:49.710 --> 00:14:54.390
以及它会做的所有事情

00:14:51.180 --> 00:14:56.190
每次您订阅

00:14:54.390 --> 00:14:58.590
示例或每次您调用阻止或

00:14:56.190 --> 00:15:01.830
每次你打电话给这些东西

00:14:58.590 --> 00:15:04.050
最终会产生

00:15:01.830 --> 00:15:06.180
基本上在管道里倒水， 

00:15:04.050 --> 00:15:07.770
那是你知道那是那是那

00:15:06.180 --> 00:15:09.090
现在当它成为热门

00:15:07.770 --> 00:15:12.600
如果我流得很冷，你可以

00:15:09.090 --> 00:15:14.280
其实很冷，创造

00:15:12.600 --> 00:15:16.110
实际上是另一条冷流

00:15:14.280 --> 00:15:18.600
例如一个热流

00:15:16.110 --> 00:15:22.920
是你可以说字母点分享

00:15:18.600 --> 00:15:24.510
在这种情况下，它不会从

00:15:22.920 --> 00:15:26.780
开始是因为份额所做的是

00:15:24.510 --> 00:15:31.890
现在，当订户订阅此

00:15:26.780 --> 00:15:34.760
喜欢这些可以订阅的共享

00:15:31.890 --> 00:15:34.760
实际提取出来

00:15:35.890 --> 00:15:49.340
字符串消费者，所以当我们当我们

00:15:41.200 --> 00:15:51.530
记录数据的好东西，你去吧

00:15:49.340 --> 00:15:54.230
现在，当我们记录数据时，您会看到

00:15:51.530 --> 00:15:56.960
这是共享订户

00:15:54.230 --> 00:15:58.160
其实看到也许你知道只有

00:15:56.960 --> 00:16:00.200
您根本看不到一个

00:15:58.160 --> 00:16:02.420
将获得实时数据流

00:16:00.200 --> 00:16:06.350
好吧，我可以保证的一种方法是

00:16:02.420 --> 00:16:07.490
通过延迟数据我可以

00:16:06.350 --> 00:16:10.660
实际上错开了一点

00:16:07.490 --> 00:16:14.480
我可以说延迟元素的持续时间

00:16:10.660 --> 00:16:20.210
第二个，然后我可以说线程

00:16:14.480 --> 00:16:22.010
睡两次，你去那里等等

00:16:20.210 --> 00:16:24.310
从理论上讲，我现在应该只会看到你知道

00:16:22.010 --> 00:16:27.440
也许是B但可能不是，但你知道

00:16:24.310 --> 00:16:29.090
 cdef是正确的，所以脱离共享

00:16:27.440 --> 00:16:31.070
好的，那是因为分享

00:16:29.090 --> 00:16:32.810
达不到不会重播整个

00:16:31.070 --> 00:16:34.760
管道，它没有启动

00:16:32.810 --> 00:16:36.530
再次处理它实际上是在点击

00:16:34.760 --> 00:16:39.410
进入现有的机上

00:16:36.530 --> 00:16:40.550
数据流还可以，所以希望对您有所帮助

00:16:39.410 --> 00:16:42.200
那不是我原来的样子

00:16:40.550 --> 00:16:45.190
试图向您展示这里，但确实有帮助

00:16:42.200 --> 00:16:48.890
您希望能欣赏其中的一些

00:16:45.190 --> 00:16:51.170
您知道组装的好处与

00:16:48.890 --> 00:16:53.450
执行好吧，好吧，让我们

00:16:51.170 --> 00:16:56.890
运行这个，我们得到什么，让我们发生吧

00:16:53.450 --> 00:16:56.890
如果我们运行该程序会发生什么

00:17:06.770 --> 00:17:09.520
好的

00:17:11.230 --> 00:17:18.039
所以我收到了非法信件例外

00:17:15.399 --> 00:17:21.399
我不能是F吧，我想

00:17:18.039 --> 00:17:22.539
那很公平，您可以看到

00:17:21.399 --> 00:17:24.579
错误，您可以在那里看到异常

00:17:22.539 --> 00:17:26.559
现在在这种情况下例外

00:17:24.579 --> 00:17:28.510
在这种情况下，它设法冒出来

00:17:26.559 --> 00:17:32.559
并非总是如此的顶部

00:17:28.510 --> 00:17:33.760
因此，您将要订阅

00:17:32.559 --> 00:17:35.500
您可以实际处理的错误

00:17:33.760 --> 00:17:37.840
错误，那就是您之前看到的

00:17:35.500 --> 00:17:41.139
您看到一个订阅或订阅者

00:17:37.840 --> 00:17:43.480
来自新指标James Beck的非

00:17:41.139 --> 00:17:45.639
当我们得到错误时使用错误方法

00:17:43.480 --> 00:17:47.019
任何例外，但我们没有

00:17:45.639 --> 00:17:52.389
单独的控制电话机制权利

00:17:47.019 --> 00:17:53.620
这是任何错误都被视为数据

00:17:52.389 --> 00:17:55.600
就像另一种

00:17:53.620 --> 00:17:58.269
数据就像下一个一样，所以当我们

00:17:55.600 --> 00:18:00.130
订阅错误中的数据我们

00:17:58.269 --> 00:18:03.309
获取该数据，这将阻止

00:18:00.130 --> 00:18:04.720
通过管道传输数据不是孩子

00:18:03.309 --> 00:18:06.399
简单的控制流程，我们不去尝试

00:18:04.720 --> 00:18:07.809
等待，因为try-catch会很奇怪

00:18:06.399 --> 00:18:09.730
正确的try-catch假定一切都在

00:18:07.809 --> 00:18:10.510
相同的执行线程

00:18:09.730 --> 00:18:13.450
这里发生了什么事

00:18:10.510 --> 00:18:16.179
因此错误会在流中处理

00:18:13.450 --> 00:18:19.240
本身，我们有一个超载版本

00:18:16.179 --> 00:18:21.190
订阅处理

00:18:19.240 --> 00:18:29.889
错误，所以您可以看到第二个是

00:18:21.190 --> 00:18:32.889
给定一个可抛出的日志错误，并且

00:18:29.889 --> 00:18:34.779
我当然可以做到这一点，因为它

00:18:32.889 --> 00:18:41.340
你知道我们知道它永远不会成功

00:18:34.779 --> 00:18:41.340
到目前为止好东西

00:18:41.850 --> 00:18:46.720
实际上发生在我身上，我可以

00:18:44.770 --> 00:18:48.850
因为我们的演示使这一过程变得更简单

00:18:46.720 --> 00:18:50.740
很好，现在我要说的是日志

00:18:48.850 --> 00:18:56.830
通过我们不需要共享版本

00:18:50.740 --> 00:19:01.480
保持我们的演示简单简单，所以现在我们

00:18:56.830 --> 00:19:10.140
我想我们实际上可以让我们

00:19:01.480 --> 00:19:17.200
看到无效错误抛出键日志

00:19:10.140 --> 00:19:24.610
信息哦，是，然后记录错误茶

00:19:17.200 --> 00:19:27.250
好的，就是这样，所以我要

00:19:24.610 --> 00:19:30.430
现在将其更改为此，而不是日志和

00:19:27.250 --> 00:19:32.880
那将是其他一切，所以我们

00:19:30.430 --> 00:19:32.880
开始这个

00:19:38.910 --> 00:19:44.060
好的

00:19:41.280 --> 00:19:44.060
所以

00:19:44.680 --> 00:19:49.090
那里是对的我们有自己的哦

00:19:46.720 --> 00:19:50.830
那是最明显的机会

00:19:49.090 --> 00:19:53.230
我们与互动错误一起工作

00:19:50.830 --> 00:19:54.270
现在，在这种情况下，我知道了

00:19:53.230 --> 00:19:56.860
一切都只是

00:19:54.270 --> 00:20:00.030
直截了当这是一个单一的

00:19:56.860 --> 00:20:01.870
此时确实是单线程

00:20:00.030 --> 00:20:05.050
看起来好像没有移动

00:20:01.870 --> 00:20:06.100
不同的线程，但您可以移动它

00:20:05.050 --> 00:20:08.400
跨不同的权利，你实际上可以

00:20:06.100 --> 00:20:10.000
说我想将其发布在

00:20:08.400 --> 00:20:19.860
不同的时间表

00:20:10.000 --> 00:20:23.340
好的，所以调度程序点弹性正确

00:20:19.860 --> 00:20:23.340
所以你可以做到

00:20:25.120 --> 00:20:28.110
现在看起来像什么

00:20:32.070 --> 00:20:40.400
下一个不能是Lambda平面图

00:20:35.570 --> 00:20:42.600
调试这还不是很清楚

00:20:40.400 --> 00:20:44.370
确实做了那个工作

00:20:42.600 --> 00:20:47.700
我想我会a一口

00:20:44.370 --> 00:20:50.490
应该记录线程数据，所以你

00:20:47.700 --> 00:20:51.600
实际上可以将执行从一个

00:20:50.490 --> 00:20:52.919
线程到另一个，或者你可以做

00:20:51.600 --> 00:20:55.910
而不是发布您可以说

00:20:52.919 --> 00:20:59.309
订阅吧，我要

00:20:55.910 --> 00:21:00.900
调度程序点弹性，然后

00:20:59.309 --> 00:21:03.900
第二个参数是对

00:21:00.900 --> 00:21:06.200
单独的线程true，我们将运行它

00:21:03.900 --> 00:21:06.200
再次

00:21:10.050 --> 00:21:18.000
好吧，理论上管道

00:21:15.330 --> 00:21:20.280
颁布执行威胁，我们可以

00:21:18.000 --> 00:21:24.090
可以看到这里的内部

00:21:20.280 --> 00:21:25.140
执行威胁在另外一个地方

00:21:24.090 --> 00:21:27.930
线程比它所受到的威胁

00:21:25.140 --> 00:21:31.440
发射好了，我没有工会

00:21:27.930 --> 00:21:32.730
记录员看到，让我们看看是什么

00:21:31.440 --> 00:21:42.300
做到这一点的最佳方法，让我们提出一个方法

00:21:32.730 --> 00:21:51.060
此处无效信息字符串字母日志信息

00:21:42.300 --> 00:21:53.220
当前值是字母还可以，我

00:21:51.060 --> 00:21:58.410
还要记录名称，以便记录

00:21:53.220 --> 00:22:01.470
信息线程获得了当前线程我得到了

00:21:58.410 --> 00:22:05.600
我将为这个名称做同样的事情

00:22:01.470 --> 00:22:05.600
已经有错误

00:22:09.830 --> 00:22:16.680
这样就可以了

00:22:14.310 --> 00:22:22.850
更新的代码，让我们重新启动

00:22:16.680 --> 00:22:22.850
这而不是日志信息好，我们开始

00:22:30.789 --> 00:22:37.269
好的，所以您现在可以看到

00:22:34.419 --> 00:22:39.279
在某个时候你首先知道

00:22:37.269 --> 00:22:40.839
我们也在这条线上有弹性，我们

00:22:39.279 --> 00:22:44.379
保持弹性，那就是当我们

00:22:40.839 --> 00:22:46.959
注销您没有的错误

00:22:44.379 --> 00:22:48.609
流中的其他项目，因为

00:22:46.959 --> 00:22:51.070
你知道这个第一阶段要先运行

00:22:48.609 --> 00:22:52.869
所以基本上我们在跨

00:22:51.070 --> 00:22:55.149
不同的线程，我们正在前进

00:22:52.869 --> 00:22:56.709
到不同的执行线程

00:22:55.149 --> 00:22:59.109
处理我们的数据，那会怎样

00:22:56.709 --> 00:23:01.149
堆栈跟踪看起来像正确的那样

00:22:59.109 --> 00:23:02.619
一位战略家女演员看起来如果

00:23:01.149 --> 00:23:04.299
我们实际上抛出了一个例外，如果我

00:23:02.619 --> 00:23:06.069
有一个空指针，那会是什么样子

00:23:04.299 --> 00:23:08.649
就像让我们尝试一下，所以

00:23:06.069 --> 00:23:11.139
做一个平面图，这是一个很好的

00:23:08.649 --> 00:23:18.159
有组织的方法来做点图

00:23:11.139 --> 00:23:25.139
和L我会返回L我会说返回

00:23:18.159 --> 00:23:29.979
 L，我会说L是否等于F 

00:23:25.139 --> 00:23:35.579
抛出一个空指针或实际上

00:23:29.979 --> 00:23:35.579
法律函件例外，好的，有这个

00:23:42.850 --> 00:23:47.139
好，基本上结果是一样的

00:23:45.669 --> 00:23:50.529
对，我们实际上也可以看到

00:23:47.139 --> 00:23:52.480
好吧，有很多不同的方法

00:23:50.529 --> 00:23:54.159
可以看到数据通过

00:23:52.480 --> 00:23:57.220
我们创建了平面图的管道，我

00:23:54.159 --> 00:23:59.769
我是否处理了我遇到的错误并

00:23:57.220 --> 00:24:01.840
如果可以，我可以在这里我可以

00:23:59.769 --> 00:24:03.639
在其中包含有关的信息

00:24:01.840 --> 00:24:05.200
向右箭头回调，与此同时

00:24:03.639 --> 00:24:06.429
我只是抛出一个异常， 

00:24:05.200 --> 00:24:08.080
框架捕获了我可以得到的

00:24:06.429 --> 00:24:09.580
以相同的方式冒泡，但是

00:24:08.080 --> 00:24:11.139
没有一张好照片

00:24:09.580 --> 00:24:13.630
你可以看到我一直在努力

00:24:11.139 --> 00:24:15.009
找出数据的去向

00:24:13.630 --> 00:24:16.750
以及如何融合在一起，为什么

00:24:15.009 --> 00:24:18.610
到了我可以看到我曾经犯过的错误

00:24:16.750 --> 00:24:19.600
关于添加此异常非常好

00:24:18.610 --> 00:24:21.700
我一直都很好

00:24:19.600 --> 00:24:24.009
记录我在这里发生的事情

00:24:21.700 --> 00:24:25.659
得到了这些回调，你真的知道

00:24:24.009 --> 00:24:27.580
尽力给自己

00:24:25.659 --> 00:24:29.519
尽可能多的信息，但我不是

00:24:27.580 --> 00:24:31.659
知道你是否在这里看过这个

00:24:29.519 --> 00:24:34.120
你不会感激

00:24:31.659 --> 00:24:38.950
此步骤或之前的任何其他步骤

00:24:34.120 --> 00:24:44.190
没错，我做了L映射

00:24:38.950 --> 00:24:44.190
现在将其转换为小写字母

00:24:52.640 --> 00:25:00.429
好吧，现在我们有多余的步骤了

00:24:56.679 --> 00:25:00.429
我们正在将其注销

00:25:04.670 --> 00:25:10.280
哦，它是小写的，所以实际上

00:25:08.570 --> 00:25:16.880
不好意思，让我们再试一次，对不起

00:25:10.280 --> 00:25:18.530
错误的测试，现在小写

00:25:16.880 --> 00:25:19.670
的情况，因为我回到那个

00:25:18.530 --> 00:25:22.100
麻烦我们去了，所以我们有

00:25:19.670 --> 00:25:24.860
同样的问题，您可以看到我们必须

00:25:22.100 --> 00:25:26.150
再次出现相同的错误，但我们没有看到

00:25:24.860 --> 00:25:27.890
在我们之前有几个步骤

00:25:26.150 --> 00:25:30.230
不知道这东西是怎么在一起的

00:25:27.890 --> 00:25:31.910
我们不知道这是什么组装

00:25:30.230 --> 00:25:34.220
管道看起来像没有那个

00:25:31.910 --> 00:25:35.480
我们没有上下文可使用的信息

00:25:34.220 --> 00:25:37.850
调试它，我们不得不

00:25:35.480 --> 00:25:42.830
对代码本身感到困惑，所以一种方式

00:25:37.850 --> 00:25:44.450
可以做到这一点是我想添加调试

00:25:42.830 --> 00:25:45.980
信息，就像我们对

00:25:44.450 --> 00:25:47.570
登录并继续进行所有操作

00:25:45.980 --> 00:25:52.460
另一种方法是调用点

00:25:47.570 --> 00:25:56.059
记录，所以说点记录，您可以

00:25:52.460 --> 00:25:57.679
甚至插入记录器或类别，或者

00:25:56.059 --> 00:26:01.330
随便你怎么想我都一样

00:25:57.679 --> 00:26:01.330
默认情况下，它只是重新运行同一程序

00:26:05.560 --> 00:26:13.790
好的，所以在这里您可以看到我们可以看到

00:26:12.350 --> 00:26:15.650
发生了什么我们可以看到哦

00:26:13.790 --> 00:26:17.920
随后的订户

00:26:15.650 --> 00:26:22.550
已订阅并被订阅

00:26:17.920 --> 00:26:25.130
订阅权，然后我们

00:26:22.550 --> 00:26:28.010
请求缓冲区，因此默认情况下您

00:26:25.130 --> 00:26:29.390
我们是您的订户，您知道

00:26:28.010 --> 00:26:32.090
包装我们的消费者是

00:26:29.390 --> 00:26:33.550
然后再请求32个订阅者

00:26:32.090 --> 00:26:35.780
一次记录很小的缓冲区

00:26:33.550 --> 00:26:39.220
显然我们不需要32条记录

00:26:35.780 --> 00:26:42.080
我们只是让您知道cdef正确

00:26:39.220 --> 00:26:44.630
我们可以看到它在接下来的处理

00:26:42.080 --> 00:26:47.060
一直到第二阶段

00:26:44.630 --> 00:26:48.230
当涉及到某些错误时，我们

00:26:47.060 --> 00:26:50.120
知道这是F权利，显然

00:26:48.230 --> 00:26:52.430
我们的例外情况很好，自我

00:26:50.120 --> 00:26:53.960
记录，以便我们记录信息

00:26:52.430 --> 00:26:55.610
加到管道的末尾

00:26:53.960 --> 00:26:57.800
他们给我们有关什么的信息

00:26:55.610 --> 00:27:00.380
发生的事情还不错，顺便说一句

00:26:57.800 --> 00:27:01.880
而不是执行SUBSCRIBE 

00:27:00.380 --> 00:27:04.130
如果您不想做的话

00:27:01.880 --> 00:27:07.850
现在这就像我在做错误

00:27:04.130 --> 00:27:09.410
订户中的东西，但这是

00:27:07.850 --> 00:27:11.450
并非总是这样

00:27:09.410 --> 00:27:14.890
实际上让我们说什么时候方法

00:27:11.450 --> 00:27:18.190
在这里，所以流程发布者无效

00:27:14.890 --> 00:27:22.700
对，这将是

00:27:18.190 --> 00:27:24.260
类型字符串可能是

00:27:22.700 --> 00:27:27.590
此时他们的车我意识到

00:27:24.260 --> 00:27:28.820
现在，但是用标签Yolo好，那么现在

00:27:27.590 --> 00:27:32.180
我要说字母点

00:27:28.820 --> 00:27:34.220
订阅我必须让用户

00:27:32.180 --> 00:27:36.230
担心那个权利，如果我想

00:27:34.220 --> 00:27:38.030
有一个内置的东西可以处理

00:27:36.230 --> 00:27:42.290
发布商中的错误，所以在这里

00:27:38.030 --> 00:27:44.750
我要看看我是否写这封信

00:27:42.290 --> 00:27:45.980
点酒吧你知道什么，所以这是

00:27:44.750 --> 00:27:47.420
实际上正在处理的东西

00:27:45.980 --> 00:27:49.190
数据我不知道这个发布者在哪里

00:27:47.420 --> 00:27:51.320
来自我，你不知道我不要

00:27:49.190 --> 00:27:54.920
必须要求用户记住

00:27:51.320 --> 00:27:59.300
呼叫错误使用者以提供

00:27:54.920 --> 00:28:01.730
当它使用这个，所以一个人等待

00:27:59.300 --> 00:28:05.030
这样做将其构建到管道中是

00:28:01.730 --> 00:28:08.180
将其添加为错误，则执行一个错误

00:28:05.030 --> 00:28:12.070
回调，所以在这里我可以说我做错了

00:28:08.180 --> 00:28:21.210
你会得到同样的机会

00:28:12.070 --> 00:28:24.159
所以这个点可以做相同的确切代码

00:28:21.210 --> 00:28:26.710
很酷，所以现在不再需要

00:28:24.159 --> 00:28:28.029
它将有一个非错误的回调

00:28:26.710 --> 00:28:30.309
不管发行人是什么

00:28:28.029 --> 00:28:31.779
订户是否知道要提供

00:28:30.309 --> 00:28:33.159
一个或不，所以如果你进入那里，你

00:28:31.779 --> 00:28:34.690
可以有一些通用的东西，你知道

00:28:33.159 --> 00:28:36.460
那里的一般行为

00:28:34.690 --> 00:28:38.169
实际上像某种贡献

00:28:36.460 --> 00:28:39.279
看起来很预处理

00:28:38.169 --> 00:28:42.549
正在创建的发布者

00:28:39.279 --> 00:28:43.989
组织，然后你知道

00:28:42.549 --> 00:28:45.909
仪器做正确的事

00:28:43.989 --> 00:28:52.749
那里有很多机会

00:28:45.909 --> 00:28:56.289
东西好吧好吧，我们回到了那里

00:28:52.749 --> 00:28:58.840
我们当时可以通过日志看到

00:28:56.289 --> 00:29:02.529
操作中，我们可以了解什么

00:28:58.840 --> 00:29:05.139
发生我喜欢那样，但我也

00:29:02.529 --> 00:29:06.729
对堆栈跟踪的事实持怀疑态度

00:29:05.139 --> 00:29:08.440
不是真的有帮助，我的意思是

00:29:06.729 --> 00:29:11.529
这种情况似乎还可以

00:29:08.440 --> 00:29:14.109
但是如果我将工作从一个线程转移到

00:29:11.529 --> 00:29:15.429
如果我做了类似的事情，如果我

00:29:14.109 --> 00:29:18.549
包含部分应用程序

00:29:15.429 --> 00:29:20.320
如果我有部分互动

00:29:18.549 --> 00:29:21.849
然后发生在不同的线程上

00:29:20.320 --> 00:29:25.389
事情会变得困难

00:29:21.849 --> 00:29:27.759
对，所以我想说

00:29:25.389 --> 00:29:30.849
我想现在获得更好的视野

00:29:27.759 --> 00:29:34.059
程序集的堆栈跟踪不仅仅是

00:29:30.849 --> 00:29:37.239
堆栈跟踪，因此请再次记住我们

00:29:34.059 --> 00:29:42.389
正确地收集了数据

00:29:37.239 --> 00:29:44.859
数据汇编将我们的

00:29:42.389 --> 00:29:49.720
跨不同的执行

00:29:44.859 --> 00:29:50.979
线程，所以我不是我不是我不要

00:29:49.720 --> 00:29:51.549
堆栈跟踪堆栈跟踪不

00:29:50.979 --> 00:29:53.710
有道理

00:29:51.549 --> 00:29:55.299
根据定义，堆栈跟踪为字符串

00:29:53.710 --> 00:29:57.940
在一个单线程中

00:29:55.299 --> 00:30:00.609
想要执行我想要的错误

00:29:57.940 --> 00:30:01.119
告诉我错误的图形

00:30:00.609 --> 00:30:02.710
发生了

00:30:01.119 --> 00:30:04.090
从一开始就

00:30:02.710 --> 00:30:06.340
不同的线程一直到哪里

00:30:04.090 --> 00:30:08.200
我们是对的，这不仅仅是一个线程

00:30:06.340 --> 00:30:11.889
跟踪线程堆栈跟踪，因此在此

00:30:08.200 --> 00:30:15.369
如果我在这里有两个选择

00:30:11.889 --> 00:30:16.899
可以在我之前用钩子哦

00:30:15.369 --> 00:30:22.570
忘记我不是要忘记一件事

00:30:16.899 --> 00:30:23.800
你也可以做到这一点

00:30:22.570 --> 00:30:26.200
可以做检查点

00:30:23.800 --> 00:30:33.910
好，所以你实际上可以说我想

00:30:26.200 --> 00:30:37.000
想要显示此消息的错误，我

00:30:33.910 --> 00:30:39.010
可以说用堆栈跟踪强制好吗

00:30:37.000 --> 00:30:40.810
当这涉及到这一部分时

00:30:39.010 --> 00:30:42.610
会在这个管道中强迫

00:30:40.810 --> 00:30:45.250
管道中的这一点

00:30:42.610 --> 00:30:47.110
注销数据注销字符串，然后

00:30:45.250 --> 00:30:51.700
然后抛出一个日志退出堆栈跟踪，所以我

00:30:47.110 --> 00:30:59.680
可以说可以退出，知道资本

00:30:51.700 --> 00:31:01.810
字母还可以，小写字母

00:30:59.680 --> 00:31:12.360
我给自己断点信息

00:31:01.810 --> 00:31:12.360
在这里让我们运行这个哦对

00:31:14.070 --> 00:31:16.910
所以

00:31:19.970 --> 00:31:25.000
好，所以我们去

00:31:35.410 --> 00:31:41.740
我们在这里到达最后的检查站

00:31:38.669 --> 00:31:43.510
那是最后一个，我想那是

00:31:41.740 --> 00:31:47.500
一个显示在这里，所以我们可以看到我

00:31:43.510 --> 00:31:49.750
想要一个错误来显示此消息

00:31:47.500 --> 00:31:53.169
它在那里，那里在那里，所以你可以

00:31:49.750 --> 00:31:54.610
看到我们得到这样的输出，我猜

00:31:53.169 --> 00:31:56.260
我想最后一个检查点就是那个

00:31:54.610 --> 00:31:57.280
真的很荣幸

00:31:56.260 --> 00:31:59.380
可以肯定的

00:31:57.280 --> 00:32:04.150
哦，不，这就是为什么令人困惑的原因

00:31:59.380 --> 00:32:06.549
我告诉我的UM，我都说过

00:32:04.150 --> 00:32:08.620
给我看一下堆栈跟踪

00:32:06.549 --> 00:32:11.130
不需要这个让我们看看会发生什么

00:32:08.620 --> 00:32:11.130
没有那些

00:32:22.880 --> 00:32:29.690
好吧，检查点

00:32:26.120 --> 00:32:31.100
所以这是唯一的检查点是

00:32:29.690 --> 00:32:32.330
更好的是，我实际上显示了更少的堆栈

00:32:31.100 --> 00:32:34.460
痕迹，我觉得自己一样

00:32:32.330 --> 00:32:35.779
堆栈跟踪的数量还可以吗

00:32:34.460 --> 00:32:37.190
并不是要迷失我所拥有的一切

00:32:35.779 --> 00:32:38.690
试图说是检查站是

00:32:37.190 --> 00:32:40.610
出现错误的东西

00:32:38.690 --> 00:32:43.370
在发生错误之后，这是

00:32:40.610 --> 00:32:45.409
第一个检查点

00:32:43.370 --> 00:32:48.500
异常好，所以这是那个

00:32:45.409 --> 00:32:51.770
我们看到我在这里有检查站，如果

00:32:48.500 --> 00:32:52.880
这个或这个有错误

00:32:51.770 --> 00:32:54.200
那么我们会看到这些

00:32:52.880 --> 00:32:55.940
检查点还可以

00:32:54.200 --> 00:32:57.529
我不确定我不确定什么力量

00:32:55.940 --> 00:32:59.330
这个显示stacktrace的东西是什么

00:32:57.529 --> 00:33:01.490
其实买我就是这就是为什么

00:32:59.330 --> 00:33:02.990
有点困惑，我们有

00:33:01.490 --> 00:33:04.429
检查点非常有用，但我

00:33:02.990 --> 00:33:05.450
仍然想要程序集stacktrace 

00:33:04.429 --> 00:33:07.010
那就是我想要谈论的

00:33:05.450 --> 00:33:08.570
在我想要看到的能力之前

00:33:07.010 --> 00:33:11.000
我想看大图

00:33:08.570 --> 00:33:12.980
以到达的方式组装

00:33:11.000 --> 00:33:15.289
这个特殊的错误这个特殊的

00:33:12.980 --> 00:33:17.299
流数据的凝结

00:33:15.289 --> 00:33:19.580
数据到达这种特定种类

00:33:17.299 --> 00:33:22.760
错误，所以一种方法是使用

00:33:19.580 --> 00:33:27.350
可以添加用于反应的钩子

00:33:22.760 --> 00:33:32.990
代码，以便您可以在调试时说钩点

00:33:27.350 --> 00:33:35.260
或操作员调试好，然后我们

00:33:32.990 --> 00:33:35.260
开始

00:33:41.400 --> 00:33:57.950
好吧，现在您可以看到更多有用的信息

00:33:48.410 --> 00:34:01.400
那是个例外，好吧，下去

00:33:57.950 --> 00:34:05.450
我们可以看到痕迹，所以我们可以看到

00:34:01.400 --> 00:34:07.800
地图操作员中发生错误

00:34:05.450 --> 00:34:09.149
对，对，对，我不必

00:34:07.800 --> 00:34:12.629
我们不知道没有断开

00:34:09.149 --> 00:34:14.340
从何处来

00:34:12.629 --> 00:34:18.360
实际上我认为这样会更有用

00:34:14.340 --> 00:34:21.179
如果我们显示这个版本只是为了

00:34:18.360 --> 00:34:23.669
了解我们正在提取数据

00:34:21.179 --> 00:34:25.730
从特定的地方尝试

00:34:23.669 --> 00:34:25.730
再次

00:34:34.170 --> 00:34:45.080
哦，看看他们是否相等

00:34:40.020 --> 00:34:45.080
你的案子让它弥补了

00:34:50.720 --> 00:35:01.980
好吧，所以在这里我们可以做同样的事情

00:35:00.150 --> 00:35:04.860
看到平面图是哪里的错误

00:35:01.980 --> 00:35:07.380
发生正确，我们可以看到方法

00:35:04.860 --> 00:35:08.970
在对应于flat的flux Java中

00:35:07.380 --> 00:35:11.610
地图，我们可以看到它被调用了

00:35:08.970 --> 00:35:12.960
再来一次，我们不是没有

00:35:11.610 --> 00:35:15.420
确保这会在

00:35:12.960 --> 00:35:18.000
事实上，与正确的线程相同

00:35:15.420 --> 00:35:19.260
相反，我们很确定这是

00:35:18.000 --> 00:35:21.930
不会在与同一线程中执行

00:35:19.260 --> 00:35:23.790
向右走，但我们仍然可以看到

00:35:21.930 --> 00:35:25.230
它从这里开始，然后到那里结束

00:35:23.790 --> 00:35:28.020
原因是因为我们有这个

00:35:25.230 --> 00:35:35.610
钩上操作员调试该信息

00:35:28.020 --> 00:35:37.410
告诉我们是否先显示X 

00:35:35.610 --> 00:35:39.170
它首先显示了异常

00:35:37.410 --> 00:35:42.180
一些有用的信息

00:35:39.170 --> 00:35:43.740
然后它向我们展示了线程堆栈

00:35:42.180 --> 00:35:45.750
跟踪只是执行流程

00:35:43.740 --> 00:35:47.460
在给定的线程不是超级

00:35:45.750 --> 00:35:49.680
对于反应式编程很有用，但是

00:35:47.460 --> 00:35:51.570
以下部分提供信息

00:35:49.680 --> 00:35:53.640
关于装配轨迹

00:35:51.570 --> 00:35:57.240
发布商，因此我们可以在此处确认

00:35:53.640 --> 00:36:00.230
错误最初是在中产生的

00:35:57.240 --> 00:36:02.520
平面图方法

00:36:00.230 --> 00:36:04.680
链接到go方法的右侧

00:36:02.520 --> 00:36:06.860
第三部分中的运算符

00:36:04.680 --> 00:36:10.350
第三部分我们终于在这里看到

00:36:06.860 --> 00:36:13.740
在那里都被正确观察到了，所以我们

00:36:10.350 --> 00:36:18.480
可以看到操作员观察到了

00:36:13.740 --> 00:36:19.980
错误，我们可以看到，我们可以看到

00:36:18.480 --> 00:36:21.120
对不起，我们可以在本节中看到

00:36:19.980 --> 00:36:24.990
观察错误的操作员

00:36:21.120 --> 00:36:27.630
在第一次触发空气之后

00:36:24.990 --> 00:36:29.040
他们是哪个用户类别

00:36:27.630 --> 00:36:30.450
触发和束缚

00:36:29.040 --> 00:36:33.090
以及我们这样做的方式

00:36:30.450 --> 00:36:37.200
这实际上是通过添加很多

00:36:33.090 --> 00:36:39.030
对发布者来说是额外的重量，所以

00:36:37.200 --> 00:36:40.410
基本上有很多

00:36:39.030 --> 00:36:42.330
仪表很多额外的

00:36:40.410 --> 00:36:43.740
必须创建的信息

00:36:42.330 --> 00:36:45.540
基本上我们创建一个异常

00:36:43.740 --> 00:36:47.040
为每个创建一个堆栈跟踪

00:36:45.540 --> 00:36:49.380
运算符，然后将其附加到

00:36:47.040 --> 00:36:50.700
运算符，并将其永久保存， 

00:36:49.380 --> 00:36:53.580
所以后来当事情发生时

00:36:50.700 --> 00:36:55.650
错误的，我们可以一起调用所有这些， 

00:36:53.580 --> 00:36:58.080
然后用它来建立这个

00:36:55.650 --> 00:37:00.240
装配图，但这很多

00:36:58.080 --> 00:37:02.650
运行时开销好吗

00:37:00.240 --> 00:37:03.970
开销可能

00:37:02.650 --> 00:37:05.620
不理想，我不认为这是

00:37:03.970 --> 00:37:06.730
例如在生产中理想，但

00:37:05.620 --> 00:37:09.130
您仍然需要此信息

00:37:06.730 --> 00:37:11.470
信息真的很有用，所以我们有

00:37:09.130 --> 00:37:13.690
我不认为经纪人有这种事

00:37:11.470 --> 00:37:15.190
从技术上讲严格来说

00:37:13.690 --> 00:37:17.410
 Java代理，但效果相同

00:37:15.190 --> 00:37:18.960
这是它预处理代码

00:37:17.410 --> 00:37:21.400
类加载器中应用程序的代码

00:37:18.960 --> 00:37:23.260
在应用程序启动之前

00:37:21.400 --> 00:37:24.940
这就是所谓的反应堆调试代理

00:37:23.260 --> 00:37:26.290
您可以将其添加到您的构建中，如果

00:37:24.940 --> 00:37:27.340
您正在使用它们，您是否知道

00:37:26.290 --> 00:37:29.110
还没有里程碑或

00:37:27.340 --> 00:37:31.870
快照依赖关系确保您执行

00:37:29.110 --> 00:37:34.210
我们从开始的项目开始

00:37:31.870 --> 00:37:36.460
在Springdale使用Spring 轴spring 

00:37:34.210 --> 00:37:37.840
快照和春季里程碑等

00:37:36.460 --> 00:37:39.880
有了这些，我真正需要的就是

00:37:37.840 --> 00:37:42.730
要做的就是添加反应堆工具

00:37:39.880 --> 00:37:45.190
依赖好吧，我希望我能

00:37:42.730 --> 00:37:48.670
希望这将合并到主要

00:37:45.190 --> 00:37:52.380
反应堆堆芯稍后但现在

00:37:48.670 --> 00:37:53.880
这是一件单独的事，没什么大不了的

00:37:52.380 --> 00:37:58.900
好的

00:37:53.880 --> 00:38:04.540
好的，所以依赖IO点好了

00:37:58.900 --> 00:38:06.130
这是反应堆工具，是我做的

00:38:04.540 --> 00:38:08.470
这个不要做那不是那个

00:38:06.130 --> 00:38:14.890
工具就是IO项目反应堆

00:38:08.470 --> 00:38:16.780
好吧，点一个，你加上这个然后你

00:38:14.890 --> 00:38:21.900
现在就安装它，而不要这样做

00:38:16.780 --> 00:38:25.960
我可以说反应堆调试代理点初始化

00:38:21.900 --> 00:38:29.320
反应堆调试代理点过程已存在

00:38:25.960 --> 00:38:31.810
在理论上这是很好的III 

00:38:29.320 --> 00:38:33.910
我的应用程序不需要这个，但是

00:38:31.810 --> 00:38:35.770
嗯，我要继续把它留在那里

00:38:33.910 --> 00:38:39.000
反正好吧，我想我确实需要它，我不是

00:38:35.770 --> 00:38:42.370
确定为什么会这样，我们要开始运行

00:38:39.000 --> 00:38:43.690
从理论上讲，您可以稍后再进行此操作

00:38:42.370 --> 00:38:45.610
例如在公共静态无效之后

00:38:43.690 --> 00:38:47.860
主要已经开始，所以你已经存在

00:38:45.610 --> 00:38:49.480
启动应用程序的代码

00:38:47.860 --> 00:38:52.600
如果你去就不需要这样做

00:38:49.480 --> 00:38:54.070
之前，但嗯，我想你似乎

00:38:52.600 --> 00:38:56.050
就像我需要 spring boot 一样

00:38:54.070 --> 00:38:57.970
因此，出于您的目的，请执行此操作

00:38:56.050 --> 00:39:00.460
知道最坏的情况是有点多余

00:38:57.970 --> 00:39:02.250
启动慢一点好吗

00:39:00.460 --> 00:39:05.620
所以你去那里是实际的

00:39:02.250 --> 00:39:07.090
这里有整个堆栈跟踪

00:39:05.620 --> 00:39:09.130
是实际的，它是做什么的

00:39:07.090 --> 00:39:12.220
它重写你的歌剧你

00:39:09.130 --> 00:39:13.480
发布您的反应流并进行排序

00:39:12.220 --> 00:39:15.970
使得它在

00:39:13.480 --> 00:39:18.310
在字节码级别正确

00:39:15.970 --> 00:39:21.030
那很酷，现在您已经拥有了

00:39:18.310 --> 00:39:23.500
像以前一样的信息

00:39:21.030 --> 00:39:25.240
无需构建整个

00:39:23.500 --> 00:39:28.359
无需额外建造

00:39:25.240 --> 00:39:30.250
在运行时提供信息

00:39:28.359 --> 00:39:32.530
从理论上讲，您实际上可以

00:39:30.250 --> 00:39:35.190
显然将其投入生产

00:39:32.530 --> 00:39:38.290
应该相应地更改您的日志记录

00:39:35.190 --> 00:39:40.000
像反应堆调试代理一样，因为它

00:39:38.290 --> 00:39:41.589
只是给我安全，你知道这就像

00:39:40.000 --> 00:39:44.320
这是一条相当不错的路

00:39:41.589 --> 00:39:48.310
额外的运行时间之间的折衷

00:39:44.320 --> 00:39:48.760
信息，启动速度稍慢

00:39:48.310 --> 00:39:52.030
时间

00:39:48.760 --> 00:39:55.349
但是作为交换，我得到了更多的见识

00:39:52.030 --> 00:39:58.119
然后我在那里支付实际罚款

00:39:55.349 --> 00:40:00.280
人们经常问的一件事是

00:39:58.119 --> 00:40:01.630
好吧，我怎么知道我是否真的在写

00:40:00.280 --> 00:40:10.260
反应性代码，如果我正在处理

00:40:01.630 --> 00:40:10.260
反过来阻止的东西

00:40:10.950 --> 00:40:17.109
所以你知道我该怎么做我该怎么做

00:40:14.230 --> 00:40:19.180
确保这实际上像我一样

00:40:17.109 --> 00:40:20.500
如果我反应灵敏，期望它是对的

00:40:19.180 --> 00:40:22.359
代码，由于某种原因它正在变慢

00:40:20.500 --> 00:40:24.190
倒或者我的内存不足

00:40:22.359 --> 00:40:26.230
我用尽了线程告诉我

00:40:24.190 --> 00:40:29.890
管道中的东西不是

00:40:26.230 --> 00:40:31.390
公平地说实际上是在偷时间

00:40:29.890 --> 00:40:33.160
在线程上时它应该只是

00:40:31.390 --> 00:40:34.750
尽可能的快一点

00:40:33.160 --> 00:40:35.950
这种反应性范式是

00:40:34.750 --> 00:40:37.930
没有很多线程，因为每个线程

00:40:35.950 --> 00:40:39.220
线程是您必须执行的事件循环

00:40:37.930 --> 00:40:41.020
选择您的线程，然后分派

00:40:39.220 --> 00:40:42.040
到其他线程，您就可以完成工作

00:40:41.020 --> 00:40:43.990
很快就到了

00:40:42.040 --> 00:40:45.790
对，所以你有你知道的

00:40:43.990 --> 00:40:47.619
总共只有很少的线程，这仅

00:40:45.790 --> 00:40:49.119
如果您正在做的工作是可行的

00:40:47.619 --> 00:40:54.160
异步I / O，可以做到

00:40:49.119 --> 00:40:56.200
基本脱线，您会发现

00:40:54.160 --> 00:40:57.550
如果您尝试整合封锁

00:40:56.200 --> 00:40:59.170
代码输入您的API，然后尝试

00:40:57.550 --> 00:41:00.339
部署它甚至可以工作，这是

00:40:59.170 --> 00:41:01.839
它甚至可能是最阴险的部分

00:41:00.339 --> 00:41:03.790
在您的开发环境中工作，但

00:41:01.839 --> 00:41:05.200
当您部署到生产中时，您将

00:41:03.790 --> 00:41:07.720
请注意，您正在饿死线程

00:41:05.200 --> 00:41:08.650
对，因为您现在有了规模

00:41:07.720 --> 00:41:11.369
所以这是你必须要做的

00:41:08.650 --> 00:41:13.660
非常小心，所以我们真的很疯狂

00:41:11.369 --> 00:41:16.690
令人称奇的软件

00:41:13.660 --> 00:41:17.079
我们的团队之一开发的阻止计数

00:41:16.690 --> 00:41:23.859
成员

00:41:17.079 --> 00:41:27.250
 sergej和块磅简直是疯了

00:41:23.859 --> 00:41:29.600
实际上也做一些本机代码

00:41:27.250 --> 00:41:30.800
但你不知道那只是

00:41:29.600 --> 00:41:32.480
做完了，我看看你不喜欢的东西

00:41:30.800 --> 00:41:33.740
需要担心的是，这就是

00:41:32.480 --> 00:41:37.040
我要安装块

00:41:33.740 --> 00:41:40.460
像那Spring Cloud Contract一样向下

00:41:37.040 --> 00:41:42.530
项目反应工具不一样

00:41:40.460 --> 00:41:46.280
作为反应堆工具包装

00:41:42.530 --> 00:41:52.160
有点混乱，你把它带进来

00:41:46.280 --> 00:41:53.350
只是说块计数安装所以在这里

00:41:52.160 --> 00:41:55.250
好的

00:41:53.350 --> 00:41:56.420
其实没关系，我猜我

00:41:55.250 --> 00:41:57.050
你不知道我想那是

00:41:56.420 --> 00:41:59.810
可能还好

00:41:57.050 --> 00:42:04.390
但是现在保持简单

00:41:59.810 --> 00:42:04.390
值得一看的东西

00:42:16.790 --> 00:42:20.830
我感觉像

00:42:33.349 --> 00:42:41.059
是的，我应该停电

00:42:36.549 --> 00:42:47.779
困惑好吧，让我们看看，让我们看看

00:42:41.059 --> 00:42:50.779
这是的，甚至有可能

00:42:47.779 --> 00:42:54.489
重新导入我要宣誓要设定

00:42:50.779 --> 00:42:54.489
在某个时候，但让我们看看

00:43:06.200 --> 00:43:15.590
好吧，这令人困惑，所以我们

00:43:13.820 --> 00:43:18.950
寻找合适的步行方式

00:43:15.590 --> 00:43:27.950
我知道我会做出反应

00:43:18.950 --> 00:43:30.760
工具阻止了一个，但om3和我已经

00:43:27.950 --> 00:43:30.760
得到了快照

00:43:50.710 --> 00:43:57.200
似乎应该在那里

00:43:53.350 --> 00:43:59.420
看看那里怎么样

00:43:57.200 --> 00:44:01.730
现在我们在做饭，所以我只需要

00:43:59.420 --> 00:44:04.250
不知道摇一棵树或其他东西

00:44:01.730 --> 00:44:06.440
现在终于可以正常工作了，所以

00:44:04.250 --> 00:44:08.870
现在我已经安装了黑色

00:44:06.440 --> 00:44:10.910
进行块计数集成

00:44:08.870 --> 00:44:13.070
实际上可以使用不同

00:44:10.910 --> 00:44:15.230
没有反应堆的猎犬

00:44:13.070 --> 00:44:16.940
在您想要的任何地方检测阻止代码

00:44:15.230 --> 00:44:18.350
它在右边有一个默认块

00:44:16.940 --> 00:44:22.130
猎犬集成，并加载

00:44:18.350 --> 00:44:23.720
自动为反应堆贡献

00:44:22.130 --> 00:44:25.130
正确，您可以在反应堆块上看到块

00:44:23.720 --> 00:44:30.710
计数集成还有一个

00:44:25.130 --> 00:44:31.760
正确地实现了Java 2，因此您可以使用它

00:44:30.710 --> 00:44:33.290
知道你想要什么，有很多

00:44:31.760 --> 00:44:34.880
不同的有一个

00:44:33.290 --> 00:44:37.430
记录是否有电话记录

00:44:34.880 --> 00:44:39.050
这可以阻止您通过

00:44:37.430 --> 00:44:47.030
默认一个可用的

00:44:39.050 --> 00:44:49.070
 for for反应堆已经加载

00:44:47.030 --> 00:44:51.200
因为块计数使用服务

00:44:49.070 --> 00:44:54.320
加载程序机制，因此您可以在这里看到

00:44:51.200 --> 00:44:56.570
这个包装上写着meta imp services 

00:44:54.320 --> 00:44:59.060
反应器块计数（按计数）积分

00:44:56.570 --> 00:45:01.940
集成并加载此类

00:44:59.060 --> 00:45:03.170
 Java六个服务负载或API结果

00:45:01.940 --> 00:45:05.110
在加载该类时

00:45:03.170 --> 00:45:07.520
自动注册，然后

00:45:05.110 --> 00:45:10.310
自动注册权利

00:45:07.520 --> 00:45:11.810
用于反应堆的集成，因此您无需

00:45:10.310 --> 00:45:13.220
需要自己做，但是你可以

00:45:11.810 --> 00:45:15.290
在此处提供其他反应式集成

00:45:13.220 --> 00:45:16.370
您实际上可以覆盖或其他

00:45:15.290 --> 00:45:17.600
您可以像这样留下它

00:45:16.370 --> 00:45:19.670
默认值就是我们要

00:45:17.600 --> 00:45:20.570
现在，我们要更改代码

00:45:19.670 --> 00:45:23.660
在这里，我们实际上会

00:45:20.570 --> 00:45:26.590
创建一个阻塞的API好吧，让我们开始吧

00:45:23.660 --> 00:45:29.180
消除错误，让我们可以

00:45:26.590 --> 00:45:36.250
好吧，这里实际上只是评论

00:45:29.180 --> 00:45:36.250
好东西好了

00:45:36.480 --> 00:45:40.810
好，所以现在我只返回

00:45:38.500 --> 00:45:43.930
信总是可以的，没有错误

00:45:40.810 --> 00:45:47.310
永远不会成为问题，一切都会

00:45:43.930 --> 00:45:51.760
继续快乐，我们可以专注于

00:45:47.310 --> 00:45:58.930
更大更好的事情或发生了什么

00:45:51.760 --> 00:46:01.660
有好东西好吗

00:45:58.930 --> 00:46:04.570
所以现在我要阻止了，我们可以

00:46:01.660 --> 00:46:07.690
现在记住的API 

00:46:04.570 --> 00:46:09.010
在这里，我预定的是

00:46:07.690 --> 00:46:10.359
不同的线程

00:46:09.010 --> 00:46:12.340
好吧，我正在订阅其他线程

00:46:10.359 --> 00:46:15.280
调度程序池是允许的

00:46:12.340 --> 00:46:17.710
反应器找出它的螺纹

00:46:15.280 --> 00:46:19.990
现在可以在使用

00:46:17.710 --> 00:46:23.109
反应堆调度程序中的调度程序是

00:46:19.990 --> 00:46:25.810
通常，您知道线程池

00:46:23.109 --> 00:46:27.580
某种形式，但有不同

00:46:25.810 --> 00:46:30.490
各种线程池（肯定不是） 

00:46:27.580 --> 00:46:38.760
所有人都平等，好吧，如果你是

00:46:30.490 --> 00:46:41.260
例如使用弹性然后

00:46:38.760 --> 00:46:46.119
对不起，如果使用弹性调度程序

00:46:41.260 --> 00:46:48.880
弹性这意味着可以扩展所有

00:46:46.119 --> 00:46:50.440
对，这是一个调度程序

00:46:48.880 --> 00:46:52.540
根据需要扩展

00:46:50.440 --> 00:46:54.550
所以我要说的是

00:46:52.540 --> 00:46:56.650
会阻塞的东西

00:46:54.550 --> 00:46:59.320
需要更多使用

00:46:56.650 --> 00:47:02.200
线程，所以我需要充分准备

00:46:59.320 --> 00:47:04.359
以便扩大规模，或者您知道

00:47:02.200 --> 00:47:05.740
我已经准备充分了

00:47:04.359 --> 00:47:07.000
东西要封锁，所以如果你有

00:47:05.740 --> 00:47:08.740
您将要使用JDBC进行的操作

00:47:07.000 --> 00:47:10.780
数据源或您使用的东西

00:47:08.740 --> 00:47:13.359
这是弹性的时间表，因为它会

00:47:10.780 --> 00:47:15.040
它会在那里做正确的事

00:47:13.359 --> 00:47:16.960
好吧，这显然意味着您

00:47:15.040 --> 00:47:19.510
应用程序现在受到您的限制

00:47:16.960 --> 00:47:20.650
能够添加手柄以添加更多

00:47:19.510 --> 00:47:26.080
威胁已经失去了很多

00:47:20.650 --> 00:47:30.220
使用你的好处知道反应

00:47:26.080 --> 00:47:33.990
 API可以，因此现金又可以创建一个线程

00:47:30.220 --> 00:47:38.070
这些代码调度程序在哪里

00:47:33.990 --> 00:47:38.070
让我们看看

00:47:38.350 --> 00:47:50.410
的非阻塞yes实例

00:47:42.080 --> 00:47:52.850
非阻塞，您可以看到查找用法

00:47:50.410 --> 00:47:57.110
一些线程

00:47:52.850 --> 00:48:01.340
由线程池创建

00:47:57.110 --> 00:48:03.110
阻止，或者说不阻止

00:48:01.340 --> 00:48:05.450
这些线程将从

00:48:03.110 --> 00:48:07.400
另一个班级有这个

00:48:05.450 --> 00:48:09.440
界面，您可以检测到

00:48:07.400 --> 00:48:10.910
所以如果您想知道哪种皮肤

00:48:09.440 --> 00:48:13.160
哪个调度程序是哪三分之一

00:48:10.910 --> 00:48:14.090
阻止和哪些没有阻止

00:48:13.160 --> 00:48:15.770
友好

00:48:14.090 --> 00:48:17.840
这是一个友好的封锁

00:48:15.770 --> 00:48:19.760
调度程序，所以这不会引起任何问题

00:48:17.840 --> 00:48:22.690
但是我想有一个

00:48:19.760 --> 00:48:26.360
那会消失的权利

00:48:22.690 --> 00:48:27.620
肯定会导致

00:48:26.360 --> 00:48:29.540
问题，因为这不是极限

00:48:27.620 --> 00:48:31.310
将无限地创建新线程，因此

00:48:29.540 --> 00:48:33.170
在这里我要创建一个线程池

00:48:31.310 --> 00:48:34.580
限制它实际上是十个线程

00:48:33.170 --> 00:48:36.440
知道你不应该有更多的线程

00:48:34.580 --> 00:48:38.150
例如，在这种情况下，您有核心

00:48:36.440 --> 00:48:39.890
顺便说一下，默认情况下，您已经

00:48:38.150 --> 00:48:46.730
有一个受限制的调度程序

00:48:39.890 --> 00:48:48.740
我们有多少个CPU 

00:48:46.730 --> 00:48:49.700
你有很多核心，所以你不应该

00:48:48.740 --> 00:48:51.530
需要这样做，但是如果你想

00:48:49.700 --> 00:48:55.760
覆盖你可以的，所以我在这里

00:48:51.530 --> 00:48:59.090
说好吧，让我们订阅这个

00:48:55.760 --> 00:49:00.230
安排好时间表，我要什么

00:48:59.090 --> 00:49:01.790
我要做的是创建一个街区

00:49:00.230 --> 00:49:04.070
它会最终结束

00:49:01.790 --> 00:49:05.360
阻碍执行流程

00:49:04.070 --> 00:49:10.160
为了阻止我要创建一个方法

00:49:05.360 --> 00:49:14.810
这里称为空块和空块

00:49:10.160 --> 00:49:17.780
好吧，我要睡觉了

00:49:14.810 --> 00:49:18.920
任意一秒钟，这是

00:49:17.780 --> 00:49:20.330
将会扔出一个东西

00:49:18.920 --> 00:49:22.280
例外，所以我要用龙目岛

00:49:20.330 --> 00:49:23.810
吞下例外，否则你就知道

00:49:22.280 --> 00:49:26.810
隐藏它，所以我不会把它包起来

00:49:23.810 --> 00:49:29.390
尝试一下，然后我要

00:49:26.810 --> 00:49:31.370
做一个平面图好吧，我要去平面图

00:49:29.390 --> 00:49:33.260
我要去做的下一个甚至

00:49:31.370 --> 00:49:35.710
更好，我不必做任何工作，所以

00:49:33.260 --> 00:49:35.710
这个

00:49:37.049 --> 00:49:45.509
我觉得应该是这样

00:49:41.269 --> 00:49:47.640
好，是的，所以我只是每个人都吃

00:49:45.509 --> 00:49:50.219
记录它被消耗了，我要

00:49:47.640 --> 00:49:51.749
减慢第三步的处理

00:49:50.219 --> 00:49:53.219
我要坐在我们的线程上

00:49:51.749 --> 00:49:55.049
在第三个池中使用，我们知道

00:49:53.219 --> 00:49:56.789
该线程池将成为一个

00:49:55.049 --> 00:49:58.589
不能阻止每个线程

00:49:56.789 --> 00:49:59.640
你知道这个新的平行脚池吗

00:49:58.589 --> 00:50:01.349
只有五条鱼，所以如果你是

00:49:59.640 --> 00:50:02.759
阻止某人饿死

00:50:01.349 --> 00:50:04.619
收到六个请求后立即启动引擎

00:50:02.759 --> 00:50:06.719
你将无法使用它，所以

00:50:04.619 --> 00:50:09.589
块八块计数将检测

00:50:06.719 --> 00:50:09.589
首先让我们尝试一下

00:50:21.240 --> 00:50:28.970
很酷，我有很多错误，我们应该

00:50:26.450 --> 00:50:31.740
封锁并呼叫您去

00:50:28.970 --> 00:50:33.720
下颌线错误阻止呼叫，您可以

00:50:31.740 --> 00:50:35.610
实际看到又变成了

00:50:33.720 --> 00:50:37.110
管道中其余的错误

00:50:35.610 --> 00:50:39.090
其余的错误处理代码

00:50:37.110 --> 00:50:41.220
我们实际捕捉到的

00:50:39.090 --> 00:50:42.480
那很酷，所以他们走了，所以你

00:50:41.220 --> 00:50:44.250
你能看到这是我们的地方吗

00:50:42.480 --> 00:50:47.010
花我们的时间有人正在

00:50:44.250 --> 00:50:49.380
打电话给你，你知道我们可以看到

00:50:47.010 --> 00:50:51.210
血液计数是我们的工具

00:50:49.380 --> 00:50:52.920
代码在那里，我们可以看到它是

00:50:51.210 --> 00:50:53.310
实际发生在不是吗

00:50:52.920 --> 00:50:55.380
凉

00:50:53.310 --> 00:50:56.760
所以现在我们有能力找到

00:50:55.380 --> 00:50:58.260
我们正在阻塞管道

00:50:56.760 --> 00:51:00.090
即使是别人的API和

00:50:58.260 --> 00:51:01.230
现在被阻止了

00:51:00.090 --> 00:51:01.620
展示给你看我在说什么

00:51:01.230 --> 00:51:03.120
关于

00:51:01.620 --> 00:51:08.180
其实我只是改好了

00:51:03.120 --> 00:51:15.390
这可以阻止这么新，它没有弹性

00:51:08.180 --> 00:51:17.900
你去那里就可以阻止我们

00:51:15.390 --> 00:51:17.900
开始这个

00:51:24.500 --> 00:51:27.920
所以你现在就去

00:51:25.970 --> 00:51:29.030
幕后，我们正在创建一个新的

00:51:27.920 --> 00:51:33.890
线程，你可以看到它说在这里

00:51:29.030 --> 00:51:35.510
线程1 2 3 4 5 6，如果我有

00:51:33.890 --> 00:51:36.560
一万亿条记录，它将继续尝试

00:51:35.510 --> 00:51:37.880
创建新线程，只要它

00:51:36.560 --> 00:51:41.119
需要处理数据权

00:51:37.880 --> 00:51:42.740
因为你知道我们会走出我们

00:51:41.119 --> 00:51:44.119
将拥有我们将要使用的所有东西

00:51:42.740 --> 00:51:46.730
在任何给定时间的所有其他

00:51:44.119 --> 00:51:47.720
那不是一个好方法，你

00:51:46.730 --> 00:51:49.880
应该注意

00:51:47.720 --> 00:51:52.490
测试您是否正在使用该线程

00:51:49.880 --> 00:51:54.770
通过使用

00:51:52.490 --> 00:51:58.910
调度程序是一个正在阻止线程

00:51:54.770 --> 00:52:00.950
好的，我想就是我想

00:51:58.910 --> 00:52:02.390
几乎涵盖了我所能

00:52:00.950 --> 00:52:03.920
想像要给你看我想我

00:52:02.390 --> 00:52:06.859
希望你从中得到一些东西

00:52:03.920 --> 00:52:08.210
希望今天我们在旅途中看到一些

00:52:06.859 --> 00:52:11.000
可以帮助您的工具

00:52:08.210 --> 00:52:12.830
基本上这些反应式调试代理

00:52:11.000 --> 00:52:15.050
封锁，是你的朋友，他们是

00:52:12.830 --> 00:52:17.450
他们的代理商实际上在处理代码

00:52:15.050 --> 00:52:19.000
或字节码在那里处理

00:52:17.450 --> 00:52:21.380
如果愿意，可以在类加载器上工作

00:52:19.000 --> 00:52:23.630
级别不在运行时级别，因此

00:52:21.380 --> 00:52:25.040
他们实际上是相当有效的

00:52:23.630 --> 00:52:27.460
不能说他们不添加任何东西

00:52:25.040 --> 00:52:29.930
开销，但他们比

00:52:27.460 --> 00:52:32.210
没有办法发现那里的

00:52:29.930 --> 00:52:34.310
某些事情，即使您只使用

00:52:32.210 --> 00:52:35.690
他们在开发时就知道

00:52:34.310 --> 00:52:37.400
那里会有一些好处， 

00:52:35.690 --> 00:52:39.230
如果您将其用于生产，则知道

00:52:37.400 --> 00:52:40.880
你知道你在做什么，需要什么

00:52:39.230 --> 00:52:44.200
有能力恢复一切

00:52:40.880 --> 00:52:47.359
关于如何优雅地降级以及

00:52:44.200 --> 00:52:50.930
而且你知道我认为这些api是

00:52:47.359 --> 00:52:52.280
真的很强大，这并不多

00:52:50.930 --> 00:52:54.109
比Java 8流更复杂

00:52:52.280 --> 00:52:55.520
您实际上没有做的API权利

00:52:54.109 --> 00:52:57.260
更糟或更严重的事情

00:52:55.520 --> 00:52:59.930
比Java Streams API复杂

00:52:57.260 --> 00:53:01.190
只是您获得了更好的规模

00:52:59.930 --> 00:53:05.050
对，你得到的规模比

00:53:01.190 --> 00:53:08.650
写了同步或阻塞代码我

00:53:05.050 --> 00:53:10.490
感谢您一如既往的倾听， 

00:53:08.650 --> 00:53:14.210
你知道你是否喜欢这个

00:53:10.490 --> 00:53:16.460
显然竖起大拇指或发表评论

00:53:14.210 --> 00:53:19.359
在视频上，一如既往的感谢

00:53:16.460 --> 00:53:19.359
下次我们再见

00:53:24.770 --> 00:53:26.830
您

