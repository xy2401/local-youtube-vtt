WEBVTT
Kind: captions
Language: zh-Hans

00:00:25.400 --> 00:00:29.579
嗨，今天的文章中的春季粉丝

00:00:28.289 --> 00:00:31.890
我们要谈论分布式

00:00:29.579 --> 00:00:34.920
事务或分布式锁

00:00:31.890 --> 00:00:38.910
与 Spring Integration 现在这个功能

00:00:34.920 --> 00:00:40.320
领导选举是

00:00:38.910 --> 00:00:42.480
其实是从

00:00:40.320 --> 00:00:45.780
 Spring Cloud 中的另一个项目

00:00:42.480 --> 00:00:47.100
因为已经放在一起了

00:00:45.780 --> 00:00:48.300
今天的春季创新

00:00:47.100 --> 00:00:51.510
分期付款，我们将非常简短

00:00:48.300 --> 00:00:56.430
看分布式锁，我们

00:00:51.510 --> 00:00:58.830
当然要用我的第二个

00:00:56.430 --> 00:01:03.180
互联网上最喜欢的地方

00:00:58.830 --> 00:01:06.180
那个 Spring 的家伙，哦，没有跑一个开始饮食

00:01:03.180 --> 00:01:08.490
是的，我们已经建立了应用程序

00:01:06.180 --> 00:01:11.610
这里是三个到三个

00:01:08.490 --> 00:01:14.280
称之为锁，我们将建立一个

00:01:11.610 --> 00:01:15.479
使用JDBC和

00:01:14.280 --> 00:01:19.259
 PostgreSQL的

00:01:15.479 --> 00:01:20.310
和 Spring Integration ，仅此而已

00:01:19.259 --> 00:01:23.130
其他依赖项，我们只需要

00:01:20.310 --> 00:01:29.240
在那里手动添加好吧，我想我们可以

00:01:23.130 --> 00:01:32.400
用Spring 做分布式锁

00:01:29.240 --> 00:01:37.470
集成比它好

00:01:32.400 --> 00:01:39.740
安全胜过遗憾，我们将打开

00:01:37.470 --> 00:01:39.740
那个

00:01:55.789 --> 00:02:04.250
现在为了使这项工作

00:01:59.340 --> 00:02:04.250
需要在这里添加一些依赖

00:02:05.990 --> 00:02:10.319
我们要带来 Spring 

00:02:07.920 --> 00:02:12.510
集成了JDBC支持，因此

00:02:10.319 --> 00:02:14.760
自定义依赖关系和 Spring 

00:02:12.510 --> 00:02:17.250
集成项目，但值得庆幸的是

00:02:14.760 --> 00:02:23.489
通过 Spring Integration 为我们管理

00:02:17.250 --> 00:02:27.720
材料清单，以便我们可以导入

00:02:23.489 --> 00:02:30.420
没有资格就可以了

00:02:27.720 --> 00:02:38.220
好东西，现在让我们来看看

00:02:30.420 --> 00:02:46.590
应用程序，我将重命名此锁

00:02:38.220 --> 00:02:49.410
还是好东西好吗

00:02:46.590 --> 00:02:51.870
现在有我们的应用程序

00:02:49.410 --> 00:02:55.200
要做好，我们要和一个

00:02:51.870 --> 00:02:58.410
数据库，所以我们使用一个我们要移动的数据库

00:02:55.200 --> 00:03:00.840
在这里，我们正在尝试什么

00:02:58.410 --> 00:03:03.540
要做的是创造一个可以

00:03:00.840 --> 00:03:05.940
允许我们限制某种访问

00:03:03.540 --> 00:03:07.380
跨多个节点的状态

00:03:05.940 --> 00:03:08.880
群集，因此您可能有10个不同的

00:03:07.380 --> 00:03:10.620
微服务，您要确保

00:03:08.880 --> 00:03:13.290
在任何给定的时间里只有一个

00:03:10.620 --> 00:03:16.230
正在某种有趣的方式上进行操作

00:03:13.290 --> 00:03:17.730
状态，这可能是一个资源

00:03:16.230 --> 00:03:19.350
数据库可能是文件上的文件

00:03:17.730 --> 00:03:21.359
系统可能是任何东西

00:03:19.350 --> 00:03:23.430
甚至可能是您要序列化

00:03:21.359 --> 00:03:25.440
处理特定请求

00:03:23.430 --> 00:03:27.060
用户，因此您想确保

00:03:25.440 --> 00:03:29.069
一个节点更新时有人更新

00:03:27.060 --> 00:03:30.780
处理打算更新的消息

00:03:29.069 --> 00:03:33.290
特定用户的状态没人

00:03:30.780 --> 00:03:35.519
其他在系统中处理相同

00:03:33.290 --> 00:03:37.380
基本上没有人更新

00:03:35.519 --> 00:03:40.230
更新中与此相关的过程

00:03:37.380 --> 00:03:42.180
实体，直到一个节点有机会

00:03:40.230 --> 00:03:44.010
做到这一点，无论用例是什么

00:03:42.180 --> 00:03:47.370
分布式锁非常宝贵， 

00:03:44.010 --> 00:03:49.260
确保某些种类的不一致

00:03:47.370 --> 00:03:51.000
用例和spring集成

00:03:49.260 --> 00:03:54.030
提供了一组不错的原语

00:03:51.000 --> 00:03:56.780
我们可以用来支持它，所以我们

00:03:54.030 --> 00:04:02.050
要在这里与邮政编码数据库交谈

00:03:56.780 --> 00:04:13.800
在这里可用

00:04:02.050 --> 00:04:22.440
和本地主机5432，命令还可以

00:04:13.800 --> 00:04:28.000
用户名等于命令和密码

00:04:22.440 --> 00:04:31.720
等于命令好吧，这是我的事

00:04:28.000 --> 00:04:33.070
我要去法庭上发球

00:04:31.720 --> 00:04:34.630
等于零，所以因为我要

00:04:33.070 --> 00:04:36.580
毕竟启动多个实例

00:04:34.630 --> 00:04:38.500
我想让我想要每个实例

00:04:36.580 --> 00:04:39.550
得到他自己独特的报告，然后

00:04:38.500 --> 00:04:42.040
我们要编写的应用程序

00:04:39.550 --> 00:04:43.540
要保存的一点积极代码

00:04:42.040 --> 00:04:45.970
东西数据到数据库，我是什么

00:04:43.540 --> 00:04:48.670
甚至没有什么太花哨的发型

00:04:45.970 --> 00:04:51.400
做一个自定义的仓库很简单

00:04:48.670 --> 00:05:01.260
使用JDBC的存储库使其保持简单

00:04:51.400 --> 00:05:03.130
好吧，我知道我需要一个角色映射器

00:05:01.260 --> 00:05:05.640
我需要什么类型的实体

00:05:03.130 --> 00:05:05.640
保留

00:05:23.560 --> 00:05:31.129
所以我们只使用常规的Big Easy 

00:05:26.360 --> 00:05:33.560
模板旋转Spring 永远不会

00:05:31.129 --> 00:05:36.620
活着的代码不是很多

00:05:33.560 --> 00:05:38.479
写我们可以只用龙目岛带来

00:05:36.620 --> 00:05:40.360
正确的依赖者再培训

00:05:38.479 --> 00:05:42.740
帮助我们解决这些难题

00:05:40.360 --> 00:05:44.270
构造函数是将字符串

00:05:42.740 --> 00:05:48.080
哈希码等这类东西

00:05:44.270 --> 00:05:51.520
我们在这里做，数据是

00:05:48.080 --> 00:05:58.520
构造函数，似乎没有构造函数

00:05:51.520 --> 00:06:01.729
还有一个可以的电话

00:05:58.520 --> 00:06:10.310
这样的停顿三个好东西好吗

00:06:01.729 --> 00:06:13.009
所以现在我们想要我们想要一个

00:06:10.310 --> 00:06:23.860
这里有几种可选的方法

00:06:13.009 --> 00:06:26.949
保留好找到我的ID整数ID 

00:06:23.860 --> 00:06:35.139
我一会儿再讲

00:06:26.949 --> 00:06:35.139
然后我们将保留预订

00:06:36.730 --> 00:06:47.720
好吧，再过一秒钟再说

00:06:41.660 --> 00:06:52.460
我们将有一个集合来找到所有没事的

00:06:47.720 --> 00:06:54.650
预订很好，我知道我会来

00:06:52.460 --> 00:06:56.120
回到第二点，现在开始

00:06:54.650 --> 00:07:02.000
首先，我想很简单

00:06:56.120 --> 00:07:10.910
所以我们说模板查询全选

00:07:02.000 --> 00:07:13.580
从保留，我要去

00:07:10.910 --> 00:07:15.260
使用行映射器，然后我们去

00:07:13.580 --> 00:07:17.030
这就是我们要做的全部事情

00:07:15.260 --> 00:07:20.600
通过ID可以罚款

00:07:17.030 --> 00:07:26.480
不存在，那么我们想转向

00:07:20.600 --> 00:07:28.750
空可选好吧那是什么

00:07:26.480 --> 00:07:28.750
给我们

00:07:29.879 --> 00:07:39.659
好，我们将提供续集

00:07:36.599 --> 00:07:41.129
查询行映射器和参数

00:07:39.659 --> 00:07:44.520
我说的时候参数就是ID 

00:07:41.129 --> 00:07:52.369
 ID等于问题的保留

00:07:44.520 --> 00:07:55.999
标记好了，可以避开它，如果说

00:07:52.369 --> 00:08:01.339
大小大于零的保留

00:07:55.999 --> 00:08:05.490
然后我们可以返回很多

00:08:01.339 --> 00:08:11.689
显着的保留率或点

00:08:05.490 --> 00:08:15.300
接下来的其他只是返回可选的空

00:08:11.689 --> 00:08:17.309
好的，那就是下一个

00:08:15.300 --> 00:08:20.309
最后我们需要保存数据

00:08:17.309 --> 00:08:22.439
当被问到，所以这是非常

00:08:20.309 --> 00:08:26.099
坦率的信不信由你

00:08:22.439 --> 00:08:31.009
一个是我要执行的模板

00:08:26.099 --> 00:08:34.319
当我说更新或您知道时，它会很清楚

00:08:31.009 --> 00:08:34.829
是的，当我有那个时，你想更新

00:08:34.319 --> 00:08:40.349
好的

00:08:34.829 --> 00:08:42.689
因此更新预订集名称等于

00:08:40.349 --> 00:08:45.089
 ID等于问题的问号

00:08:42.689 --> 00:08:47.819
标记，然后我们有一个准备

00:08:45.089 --> 00:08:53.970
语句设置器，这是一个新的准备

00:08:47.819 --> 00:08:58.519
全部保留的语句回调

00:08:53.970 --> 00:08:58.519
对，我要说

00:09:00.940 --> 00:09:10.990
准备好的陈述将英寸等于1 

00:09:05.860 --> 00:09:19.120
两个保留都得到了所有的名字

00:09:10.990 --> 00:09:27.670
对不起，我说了字符串，然后这个

00:09:19.120 --> 00:09:31.470
会好好坐着，然后

00:09:27.670 --> 00:09:36.270
然后终于找到结果了

00:09:31.470 --> 00:09:42.820
按ID查找预订未获取ID 

00:09:36.270 --> 00:09:46.050
点开始假设到这一点

00:09:42.820 --> 00:09:46.050
有有效记录

00:10:02.989 --> 00:10:09.389
好的，好的，这些都是

00:10:06.600 --> 00:10:13.410
我们的代码，我们可以返回的结果

00:10:09.389 --> 00:10:14.639
当然丢掉那个好，所以这是一个

00:10:13.410 --> 00:10:16.619
我们并不真正在乎的存储库

00:10:14.639 --> 00:10:18.869
仓库太多了，我们只需要

00:10:16.619 --> 00:10:22.799
表编写使用它的代码

00:10:18.869 --> 00:10:25.589
好吧，现在放下，现在我们可以说

00:10:22.799 --> 00:10:27.419
让我们创建一个允许的风险控制器

00:10:25.589 --> 00:10:28.619
我们来证明这里发生了什么，所以我

00:10:27.419 --> 00:10:35.629
假设我应该带进去

00:10:28.619 --> 00:10:35.629
 Web支持Spring Boot可以

00:10:36.049 --> 00:10:56.129
 Web列表控制器类锁定的操作

00:10:46.289 --> 00:11:01.439
失去了资源控制器，我们会

00:10:56.129 --> 00:11:04.859
在这里有一个端点称为update 

00:11:01.439 --> 00:11:08.879
想到了我们想要的东西

00:11:04.859 --> 00:11:12.439
名字想给它和时间我们

00:11:08.879 --> 00:11:18.659
想要稍后再等，所以保留

00:11:12.439 --> 00:11:24.739
更新包变量整数ID a 

00:11:18.659 --> 00:11:28.949
可靠的勺子名字包动物长

00:11:24.739 --> 00:11:31.529
正确的时间，所以我们有终点

00:11:28.949 --> 00:11:34.129
当您使用我们的预订时

00:11:31.529 --> 00:11:34.129
或姿势正确

00:11:35.329 --> 00:11:47.190
好，我们去了，所以这是怎么回事

00:11:44.610 --> 00:11:49.440
将会发生，我们想建立正确的我们

00:11:47.190 --> 00:11:50.790
想能够更新数据，所以

00:11:49.440 --> 00:11:53.790
这是业务的业务逻辑

00:11:50.790 --> 00:12:01.220
逻辑是执行以下正确的操作，所以我们

00:11:53.790 --> 00:12:15.800
会说我们想避免

00:12:01.220 --> 00:12:20.790
做一个8或整数ID好的名称，然后在这里

00:12:15.800 --> 00:12:23.790
假设患者我们要说我们

00:12:20.790 --> 00:12:26.750
要说找到存储库，找到

00:12:23.790 --> 00:12:31.850
如果有数据，则按其ID记录

00:12:26.750 --> 00:12:35.939
然后我们使用编辑器设置名称

00:12:31.850 --> 00:12:38.810
为此，然后我们保存它，所以我们说

00:12:35.939 --> 00:12:40.040
这些是不可能保存或更新的

00:12:38.810 --> 00:12:48.600
好的

00:12:40.040 --> 00:12:52.440
一旦完成

00:12:48.600 --> 00:13:01.850
我们想找到数据，所以找到我的主意

00:12:52.440 --> 00:13:01.850
再次ID不正确

00:13:02.110 --> 00:13:10.000
现在我们有了业务对象

00:13:04.600 --> 00:13:13.840
预订结果等于您更新

00:13:10.000 --> 00:13:16.510
为您的名字ID我们现在要

00:13:13.840 --> 00:13:18.220
保护此代码将此行拍为此行

00:13:16.510 --> 00:13:19.900
您想要保护它，以便只有一个

00:13:18.220 --> 00:13:22.210
整个系统中的事情可以做到

00:13:19.900 --> 00:13:24.460
一次针对特定用户

00:13:22.210 --> 00:13:26.770
如果用户知道您将要做什么

00:13:24.460 --> 00:13:28.720
使用用户的ID作为密钥，因此我们

00:13:26.770 --> 00:13:31.330
不要介意别人是否执行此操作

00:13:28.720 --> 00:13:33.520
其他用户的方法，但如果两个

00:13:31.330 --> 00:13:35.920
节点执行相同的代码路径

00:13:33.520 --> 00:13:37.600
对于同一用户，我们想要您

00:13:35.920 --> 00:13:40.120
知道让它独占一件事

00:13:37.600 --> 00:13:43.330
可以一次更新该用户

00:13:40.120 --> 00:13:47.290
一个特定的用户，所以我们可以在这里使用

00:13:43.330 --> 00:13:51.130
锁支持好吧，我要说

00:13:47.290 --> 00:14:02.860
我们想要创建一个默认锁

00:13:51.130 --> 00:14:07.680
存储库可以，请打开新的默认块

00:14:02.860 --> 00:14:07.680
数据源中传递的小径故事

00:14:09.900 --> 00:14:19.600
已经传递了，然后返回

00:14:16.180 --> 00:14:20.890
它到JDBC锁定注册表和jeebies 

00:14:19.600 --> 00:14:23.410
就像注册表一样，这就是你的事情

00:14:20.890 --> 00:14:27.700
你能知道那是支持的东西吗

00:14:23.410 --> 00:14:28.900
 VM实施的数据

00:14:27.700 --> 00:14:31.180
存储有关锁的信息，并

00:14:28.900 --> 00:14:32.350
这就是为什么我们可以看到相同的状态

00:14:31.180 --> 00:14:35.460
跨多个节点，因为我们

00:14:32.350 --> 00:14:39.070
与JDBC交谈当然有

00:14:35.460 --> 00:14:41.800
其他类型的锁，这是核心

00:14:39.070 --> 00:14:43.060
你可以看到这个JDBC的抽象

00:14:41.800 --> 00:14:45.280
还有其他一些

00:14:43.060 --> 00:14:47.080
如果使用 Spring 的话，威尼斯就设一个

00:14:45.280 --> 00:14:49.420
融入威尼斯，让您知道自己

00:14:47.080 --> 00:14:53.020
有选项，它不一定是JDBC I 

00:14:49.420 --> 00:14:56.880
碰巧喜欢它，我们需要

00:14:53.020 --> 00:15:02.620
锁定存储库就在这里

00:14:56.880 --> 00:15:05.280
好吧，现在我们可以在这里使用锁

00:15:02.620 --> 00:15:05.280
注册表

00:15:05.620 --> 00:15:13.090
还有豹子树，我们说好

00:15:09.090 --> 00:15:16.570
获得的注册表点以及使用时

00:15:13.090 --> 00:15:26.230
这里的钥匙，所以Spring 钥匙等于

00:15:16.570 --> 00:15:29.020
整数到字符串ID好好好了

00:15:26.230 --> 00:15:31.360
锁，然后我们将尝试

00:15:29.020 --> 00:15:34.270
获得法律或获得法律参考

00:15:31.360 --> 00:15:35.560
所以我们会说尝试锁定更好

00:15:34.270 --> 00:15:37.330
指定一个超时，所以我要说我

00:15:35.560 --> 00:15:39.870
想等一下我愿意

00:15:37.330 --> 00:15:42.010
等待一秒钟的结果

00:15:39.870 --> 00:15:43.840
好吧，这可能会引发异常

00:15:42.010 --> 00:15:46.290
玩这些偷偷摸摸的掷球告诉

00:15:43.840 --> 00:15:52.680
龙目岛吞噬了这种潜力

00:15:46.290 --> 00:15:55.230
异常，我可以说获得锁

00:15:52.680 --> 00:15:57.940
问号可以关闭

00:15:55.230 --> 00:16:05.110
直到我们对锁说好

00:15:57.940 --> 00:16:08.160
获得然后做那好吧，实际上

00:16:05.110 --> 00:16:20.370
也想这样做

00:16:08.160 --> 00:16:20.370
终于，所以解锁就可以了

00:16:21.840 --> 00:16:31.140
现在，我们已经完成了锁定

00:16:29.190 --> 00:16:35.490
带有锁的内部业务逻辑

00:16:31.140 --> 00:16:41.040
然后我们安排了当

00:16:35.490 --> 00:16:45.900
工作已经完成，我们可以解锁，如果我们

00:16:41.040 --> 00:16:48.480
没有锁，那么你实际上知道

00:16:45.900 --> 00:16:51.770
我们可以做到，我们实际上可以清洁

00:16:48.480 --> 00:16:51.770
这一点使这无效

00:16:58.390 --> 00:17:03.640
所以有生意，有

00:17:00.100 --> 00:17:06.309
建造耶稣的骨骼模式权利

00:17:03.640 --> 00:17:08.679
我们说的是业务逻辑，但是

00:17:06.309 --> 00:17:11.049
仅用于锁内，如果

00:17:08.679 --> 00:17:16.959
在锁中，然后确保将其解锁

00:17:11.049 --> 00:17:20.079
当你完蛋的时候好

00:17:16.959 --> 00:17:21.819
好吧，让我们尝试一下，让我们开始吧

00:17:20.079 --> 00:17:29.770
这两个不同的时间才能运行

00:17:21.819 --> 00:17:32.309
两次我需要摆脱这个，我们

00:17:29.770 --> 00:17:32.309
在程序中

00:17:43.080 --> 00:17:45.769
你好

00:17:55.550 --> 00:18:09.910
我们需要名称中的ID知道

00:17:58.970 --> 00:18:09.910
所以RS点会得到int ID和好东西

00:18:15.040 --> 00:18:18.330
当然是lambda 

00:18:22.860 --> 00:18:34.640
好的

00:18:25.510 --> 00:18:37.660
所以现在本地80:84的localhost：8080 

00:18:34.640 --> 00:18:41.780
斜杠然后正确更新，所以我们说

00:18:37.660 --> 00:18:55.000
更新ID，让我们看看我们的想法

00:18:41.780 --> 00:19:02.480
续集好吧，让我们更新

00:18:55.000 --> 00:19:04.540
预订集名称等于81，而我

00:19:02.480 --> 00:19:08.690
得到简和约翰·简是第一

00:19:04.540 --> 00:19:19.360
好的，我们将使用默认值

00:19:08.690 --> 00:19:23.570
在这里移植一个更新一位获胜者

00:19:19.360 --> 00:19:29.900
要睡30秒就是30 

00:19:23.570 --> 00:19:33.880
秒纸在这里，我们要

00:19:29.900 --> 00:19:39.470
甚至睡一秒钟或十秒钟

00:19:33.880 --> 00:19:44.030
对，所以让我们尝试一下

00:19:39.470 --> 00:19:45.230
这是30秒，如果这样想

00:19:44.030 --> 00:19:48.500
关于将会发生什么我会

00:19:45.230 --> 00:19:50.240
调用30秒就会

00:19:48.500 --> 00:19:52.340
基本上把锁打开30 

00:19:50.240 --> 00:19:54.440
秒，然后在更少的时间内很快

00:19:52.340 --> 00:19:56.450
时间超过30秒，我要过去

00:19:54.440 --> 00:19:58.130
在那里开始第二个选项卡， 

00:19:56.450 --> 00:20:01.340
那将在

00:19:58.130 --> 00:20:03.830
第一个完成，因为他们在

00:20:01.340 --> 00:20:07.760
锁定第二个永远不会得到一个

00:20:03.830 --> 00:20:10.130
有机会更新记录的状态

00:20:07.760 --> 00:20:11.510
在数据库中匹配名称

00:20:10.130 --> 00:20:16.540
我们给他，所以它永远不会出现

00:20:11.510 --> 00:20:21.970
作为新的威慑力，并牢记

00:20:16.540 --> 00:20:30.360
我们在这里有更新哦，我们必须

00:20:21.970 --> 00:20:35.149
做线程睡眠时间还可以

00:20:30.360 --> 00:20:35.149
我要吃两次午餐

00:21:02.200 --> 00:21:15.669
好吧，所以第一个节点只写

00:21:07.279 --> 00:21:15.669
这个板还可以，第二个节点

00:21:16.929 --> 00:21:25.580
不要让它花十秒钟

00:21:20.659 --> 00:21:31.100
可以将它加载到此笔记端口上，所以在这里

00:21:25.580 --> 00:21:32.929
我们走了三十秒十秒，所以

00:21:31.100 --> 00:21:36.470
第一个已经回来，你可以看到

00:21:32.929 --> 00:21:38.570
它没有说简

00:21:36.470 --> 00:21:43.730
它没有说失败者，而是说简

00:21:38.570 --> 00:21:44.210
或约翰，您可以在后台看到

00:21:43.730 --> 00:21:49.610
那里

00:21:44.210 --> 00:21:52.390
第一个还在旋转

00:21:49.610 --> 00:21:52.390
等待30秒

00:22:11.720 --> 00:22:13.720
哦

00:22:14.320 --> 00:22:21.730
我做错了什么哦，我总是这么做

00:22:21.310 --> 00:22:24.940
错误

00:22:21.730 --> 00:22:27.270
配对的语句点执行正常

00:22:24.940 --> 00:22:27.270
拿两个

00:22:44.850 --> 00:22:53.870
好的，现在这是第一个音符

00:22:48.809 --> 00:22:53.870
它在港口五一三九十三

00:22:55.009 --> 00:23:09.750
然后这个是第二个节点

00:23:00.230 --> 00:23:12.080
四五一四等所以第二

00:23:09.750 --> 00:23:12.080
一个说

00:23:17.840 --> 00:23:23.530
失败者我们为什么

00:23:56.620 --> 00:24:09.500
好吧，让我们再像这样尝试一次

00:24:02.590 --> 00:24:11.260
这是第一个30秒

00:24:09.500 --> 00:24:19.159
第二个

00:24:11.260 --> 00:24:25.700
这是这里的第一个港口

00:24:19.159 --> 00:24:35.779
在窗户一侧，然后在这里

00:24:25.700 --> 00:24:38.350
失败者那边在那边好

00:24:35.779 --> 00:24:38.350
准备

00:24:40.890 --> 00:24:43.670
他们去

00:24:46.370 --> 00:24:53.130
所以你可以看到失败者永远不会是

00:24:51.330 --> 00:24:54.990
旧的价值，记住这仍然是旧的

00:24:53.130 --> 00:24:56.220
价值，让它完成，但它已经

00:24:54.990 --> 00:24:58.080
更新状态，您可以看到

00:24:56.220 --> 00:24:59.850
因为它在我查询时返回

00:24:58.080 --> 00:25:01.890
我问我现在的状态

00:24:59.850 --> 00:25:04.830
在失败者这边的赢家

00:25:01.890 --> 00:25:07.410
还没有更新自己，所以请记住

00:25:04.830 --> 00:25:08.850
它运行的东西写

00:25:07.410 --> 00:25:13.860
状态到数据库，然后休眠

00:25:08.850 --> 00:25:16.340
所以如果我超过了，这里的价值就是赢家

00:25:13.860 --> 00:25:18.660
这是赢家，这意味着它永远不会

00:25:16.340 --> 00:25:23.760
你知道它永远都没有意义

00:25:18.660 --> 00:25:26.700
让失败者进入或执行，所以在那里

00:25:23.760 --> 00:25:28.140
你去那里有一个非常简单的分布式

00:25:26.700 --> 00:25:32.670
锁算法，你知道吗

00:25:28.140 --> 00:25:33.840
情况或例子酷我

00:25:32.670 --> 00:25:35.670
没有机会真正玩

00:25:33.840 --> 00:25:36.750
这些东西以前，但你知道我可以

00:25:35.670 --> 00:25:38.760
可以看到很多不同的用例

00:25:36.750 --> 00:25:40.980
显然，如果您

00:25:38.760 --> 00:25:41.940
像消息重新排序或

00:25:40.980 --> 00:25:45.120
如果您想确保某种东西

00:25:41.940 --> 00:25:46.560
您只有一个人更新

00:25:45.120 --> 00:25:48.750
如果您有一个鸡蛋，一次一次

00:25:46.560 --> 00:25:51.330
某种有状态的东西，例如文件

00:25:48.750 --> 00:25:53.820
在文件系统中，或者您知道某种

00:25:51.330 --> 00:25:55.260
您要控制的会话

00:25:53.820 --> 00:25:56.310
不管你实际上可以做些什么

00:25:55.260 --> 00:25:58.800
这些非常有趣的事情

00:25:56.310 --> 00:26:00.120
我正在使用JDBC的分布式锁

00:25:58.800 --> 00:26:01.230
基于一个，因为我怀疑很多

00:26:00.120 --> 00:26:02.760
有基础设施

00:26:01.230 --> 00:26:04.380
在机器上或在他们的机器上可用

00:26:02.760 --> 00:26:05.580
服务，但您可以使用这些东西

00:26:04.380 --> 00:26:07.290
有一个Redis隔开的，我认为

00:26:05.580 --> 00:26:08.910
最红的可能是

00:26:07.290 --> 00:26:10.950
更快，我不知道，但是

00:26:08.910 --> 00:26:12.210
期望您知道我们所知道的

00:26:10.950 --> 00:26:14.280
关于Redis，它有多快以及如何

00:26:12.210 --> 00:26:16.560
调整此特定用途

00:26:14.280 --> 00:26:19.770
情况下，我敢打赌，如果

00:26:16.560 --> 00:26:21.750
你确定他们什么时候拍的

00:26:19.770 --> 00:26:26.210
我的朋友们，我希望你喜欢

00:26:21.750 --> 00:26:26.210
总是，我们下次见

00:26:33.860 --> 00:26:35.920
您

