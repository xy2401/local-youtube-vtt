WEBVTT
Kind: captions
Language: zh-Hans

00:00:13.740 --> 00:00:18.099
嘿，今天的春季球迷，我们要

00:00:16.510 --> 00:00:20.619
谈论一些新功能

00:00:18.099 --> 00:00:23.140
Spring 5内部的反应性终点

00:00:20.619 --> 00:00:26.199
现在 spring 5还没到呢

00:00:23.140 --> 00:00:28.480
明年上半年，但他们

00:00:26.199 --> 00:00:30.070
做出色的早期发布候选人

00:00:28.480 --> 00:00:32.710
您现在可以签出

00:00:30.070 --> 00:00:34.059
发挥真正的大功能

00:00:32.710 --> 00:00:36.730
有点像我认为的杀手级功能

00:00:34.059 --> 00:00:39.610
在 spring 5是新的反应

00:00:36.730 --> 00:00:42.969
编程支持，直到现在

00:00:39.610 --> 00:00:44.530
支持基本上是

00:00:42.969 --> 00:00:47.789
重新构想的基础

00:00:44.530 --> 00:00:51.089
 Spring Framework和Spring MVC本身

00:00:47.789 --> 00:00:54.339
支持完全反应性的管道，因此

00:00:51.089 --> 00:00:56.890
基本上我们已经改装了一些

00:00:54.339 --> 00:00:58.809
现有的Spring MVC组件模型和

00:00:56.890 --> 00:01:02.260
把它放在一个neti之上

00:00:58.809 --> 00:01:03.940
基于neti的引擎，现在您可以使用一些

00:01:02.260 --> 00:01:06.880
这些反应性特征中的一种

00:01:03.940 --> 00:01:09.820
 Servlet 3.1之上的降级模式

00:01:06.880 --> 00:01:12.540
基本容器，但真正的力量来了

00:01:09.820 --> 00:01:14.409
当您进入此基于neti 

00:01:12.540 --> 00:01:17.560
为我们开发的运行时提供引擎

00:01:14.409 --> 00:01:19.930
现在支持被动式工作负载

00:01:17.560 --> 00:01:23.200
移植到现有的好处

00:01:19.930 --> 00:01:24.640
 Spring MVC组件是您可以

00:01:23.200 --> 00:01:27.130
利用现有的应用程序并移动

00:01:24.640 --> 00:01:28.360
他们零零碎碎，仅此而已

00:01:27.130 --> 00:01:30.340
我确定很好，很好的金属

00:01:28.360 --> 00:01:32.320
会很有趣

00:01:30.340 --> 00:01:34.690
换个话题再讨论

00:01:32.320 --> 00:01:38.530
但今天我想谈谈

00:01:34.690 --> 00:01:42.250
那个 Spring 的反动忍者Arion Poots 

00:01:38.530 --> 00:01:46.560
妈妈几天前刚刚掉线

00:01:42.250 --> 00:01:50.340
关于他们新的功能反应

00:01:46.560 --> 00:01:52.030
终结点，所以如果您看到这个博客，我

00:01:50.340 --> 00:01:53.940
鼓励您，如果您还没有看到这个

00:01:52.030 --> 00:01:56.170
博客Anchorage区域（如果已看到） 

00:01:53.940 --> 00:01:57.700
然后再读一遍，因为它真的

00:01:56.170 --> 00:01:59.230
对我们即将要做的事情真的很关键

00:01:57.700 --> 00:02:01.870
今天在这里做，春季和 spring 5 

00:01:59.230 --> 00:02:03.730
功能性网络框架，这是一个

00:02:01.870 --> 00:02:05.220
不同的组件模型和某些

00:02:03.730 --> 00:02:07.480
对于某些人来说，这将是

00:02:05.220 --> 00:02:08.590
正是他们长期以来想要的

00:02:07.480 --> 00:02:10.840
对，这将是非常熟悉的

00:02:08.590 --> 00:02:14.739
以工作的人为例

00:02:10.840 --> 00:02:17.349
与Skeletor Sinatra甚至火花

00:02:14.739 --> 00:02:20.470
 Java或其他类似的技术

00:02:17.349 --> 00:02:22.630
认为这是 Spring 的自然补充

00:02:20.470 --> 00:02:24.700
 MVC是一个非常自然的补充

00:02:22.630 --> 00:02:27.100
我们正在尝试使用Spring MVC 

00:02:24.700 --> 00:02:28.000
要更强大，以提供

00:02:27.100 --> 00:02:29.880
更好

00:02:28.000 --> 00:02:31.810
并支持您知道混搭

00:02:29.880 --> 00:02:34.030
组件模型在适当的地方

00:02:31.810 --> 00:02:35.770
今天我们要去一点

00:02:34.030 --> 00:02:37.870
超越了我们伊恩在他的著作中所做的

00:02:35.770 --> 00:02:39.340
我们将要介绍的博客文章

00:02:37.870 --> 00:02:43.000
前进并构建一个简单的 spring boot 

00:02:39.340 --> 00:02:47.440
现在正在申请工作

00:02:43.000 --> 00:02:51.220
持续不断地

00:02:47.440 --> 00:02:53.290
 spring 5也有工作要做

00:02:51.220 --> 00:02:54.880
 Spring Boot团队整合了一些

00:02:53.290 --> 00:02:56.890
新位的自动

00:02:54.880 --> 00:02:59.410
 spring boot 的配置，因此

00:02:56.890 --> 00:03:00.520
经验应该类似于

00:02:59.410 --> 00:03:03.310
如果您正在使用，现在会得到什么

00:03:00.520 --> 00:03:04.930
雄猫或码头或

00:03:03.310 --> 00:03:07.600
嵌入式模式下的示例

00:03:04.930 --> 00:03:09.730
只是能够选中一个框并启动

00:03:07.600 --> 00:03:11.560
一个Spring Boot应用程序，并具有完整

00:03:09.730 --> 00:03:13.600
访问反应式运行时，但作为

00:03:11.560 --> 00:03:16.360
我们的功能端点

00:03:13.600 --> 00:03:18.640
即将讨论的是很新的意愿

00:03:16.360 --> 00:03:20.200
放弃一些自动配置

00:03:18.640 --> 00:03:21.910
但我们将以该自动开始

00:03:20.200 --> 00:03:24.700
配置是我们的基础

00:03:21.910 --> 00:03:26.110
项目并将其用作引入方式

00:03:24.700 --> 00:03:28.690
正确的库，所以我们要去

00:03:26.110 --> 00:03:31.920
进入 Spring ，我们当然是

00:03:28.690 --> 00:03:35.560
要建立一个美丽的反应

00:03:31.920 --> 00:03:37.330
我们使用Springs反应网的应用程序

00:03:35.560 --> 00:03:39.400
您可以看到的实验性支持

00:03:37.330 --> 00:03:43.540
这里标记为实验性的，我们将使用

00:03:39.400 --> 00:03:48.100
 MongoDB Spring数据不是MongoDB 

00:03:43.540 --> 00:03:49.990
我们会用我认为那会做到的

00:03:48.100 --> 00:03:51.040
实际上应该足以让我们

00:03:49.990 --> 00:03:53.140
开始吧，让我们继续前进

00:03:51.040 --> 00:03:54.940
生成，我们将获得一个新的zip文件

00:03:53.140 --> 00:03:57.459
我们只是要打开这个拉链

00:03:54.940 --> 00:04:01.110
文件，我们将获得一个新项目，我们

00:03:57.459 --> 00:04:01.110
可以将其导入IDE 

00:04:06.319 --> 00:04:12.810
现在Spring 反应性支撑

00:04:10.380 --> 00:04:15.510
自动配置很年轻

00:04:12.810 --> 00:04:17.250
因为它带来了一些图书馆

00:04:15.510 --> 00:04:18.570
我们需要的，它使我们有了

00:04:17.250 --> 00:04:22.169
拿起这个东西需要什么

00:04:18.570 --> 00:04:23.160
和工作，但我们不需要所有

00:04:22.169 --> 00:04:25.260
这些位，所以实际上我们要

00:04:23.160 --> 00:04:28.620
拆开我们要拆除它

00:04:25.260 --> 00:04:29.910
您知道将其删除，我们只会保留

00:04:28.620 --> 00:04:32.040
我们需要的位

00:04:29.910 --> 00:04:35.610
具体示例工作方式

00:04:32.040 --> 00:04:36.830
在那种轨道之外

00:04:35.610 --> 00:04:41.010
现在好了，所以我们要用Spring 

00:04:36.830 --> 00:04:46.530
网络反应式，这是一个 Spring Framework 

00:04:41.010 --> 00:04:49.890
图书馆在这里，我们将带来neti 

00:04:46.530 --> 00:04:51.870
缓冲网是I / O库

00:04:49.890 --> 00:04:53.100
如果阅读

00:04:51.870 --> 00:04:55.830
许多反应技术和

00:04:53.100 --> 00:04:59.310
包括实现，我们带来了

00:04:55.830 --> 00:05:02.280
在反应堆洗手间库中，现在是

00:04:59.310 --> 00:05:07.139
该项目反应堆权利IOTA项目

00:05:02.280 --> 00:05:10.350
支持我们的反应堆点IPC模块

00:05:07.139 --> 00:05:16.220
与Nettie集成以进行活动

00:05:10.350 --> 00:05:16.220
通风的IO，也将带来

00:05:17.030 --> 00:05:29.700
 Jackson的数据绑定模块是这样的

00:05:20.430 --> 00:05:31.830
您必须能够绑定Jackson数据

00:05:29.700 --> 00:05:34.080
拼写这个可以正常工作

00:05:31.830 --> 00:05:36.270
是的，我想现在会再做一次

00:05:34.080 --> 00:05:38.070
当你当这是最后的决定时

00:05:36.270 --> 00:05:39.840
当你有实际的位时

00:05:38.070 --> 00:05:41.490
实际上不需要做太多事情

00:05:39.840 --> 00:05:43.530
我希望很多事情都会消失

00:05:41.490 --> 00:05:45.150
在下一个发行版中

00:05:43.530 --> 00:05:46.950
功能性反应性材料非常新，所以

00:05:45.150 --> 00:05:48.810
尚未自动集成

00:05:46.950 --> 00:05:51.990
对我们来说，但是选择 Spring 

00:05:48.810 --> 00:05:53.490
反应性支持，我们得到了

00:05:51.990 --> 00:05:55.800
里程碑，我们得到这个特别

00:05:53.490 --> 00:05:57.600
依赖关系建立了一件事，你

00:05:55.800 --> 00:05:59.640
应该知道的是，如果你

00:05:57.600 --> 00:06:02.370
偶然地忽视了我

00:05:59.640 --> 00:06:03.570
将 spring boot 指定为o 

00:06:02.370 --> 00:06:08.789
你会遇到不好的经历，所以

00:06:03.570 --> 00:06:14.099
确保将其推向2.0版本

00:06:08.789 --> 00:06:15.300
 -快照好了，现在我们要做什么

00:06:14.099 --> 00:06:17.460
我们要做的是建立一个简单的

00:06:15.300 --> 00:06:18.990
使用MongoDB的应用程序

00:06:17.460 --> 00:06:20.400
去你知道我们要

00:06:18.990 --> 00:06:22.020
尽我们所能去做

00:06:20.400 --> 00:06:23.370
我们将要构建的应用程序

00:06:22.020 --> 00:06:26.069
我将在这里建立一个实体

00:06:23.370 --> 00:06:29.190
借鉴我们伊恩（Ian）的例子

00:06:26.069 --> 00:06:31.410
博客类型人的实体，所以我会

00:06:29.190 --> 00:06:36.180
使用spring数据文档注释

00:06:31.410 --> 00:06:37.560
在这里，我们将为创建一个字符串

00:06:36.180 --> 00:06:38.660
很自然的ID权利

00:06:37.560 --> 00:06:42.449
文件编号

00:06:38.660 --> 00:06:45.150
与JDBC JP不同，您在哪里

00:06:42.449 --> 00:06:46.860
可能会使用长MongoDB之类的ID 

00:06:45.150 --> 00:06:49.110
首选自动字符串

00:06:46.860 --> 00:06:52.410
增加唯一值，我们

00:06:49.110 --> 00:06:54.449
将给它一个名称值字段，并

00:06:52.410 --> 00:06:57.710
我们给它一个年龄，我们给

00:06:54.449 --> 00:07:00.750
名为okay的人和构造函数，以及

00:06:57.710 --> 00:07:03.240
另一个构造器，尽管我不是

00:07:00.750 --> 00:07:06.150
甚至确定我们是否需要

00:07:03.240 --> 00:07:07.770
吸气剂自然而然地

00:07:06.150 --> 00:07:09.599
用户调试非常好，所以现在我们有了

00:07:07.770 --> 00:07:11.310
那，我们希望能够阅读和

00:07:09.599 --> 00:07:13.430
与两个这种类型的实体一起工作

00:07:11.310 --> 00:07:17.729
所以我会说一个仓库

00:07:13.430 --> 00:07:19.680
扩展Mongo存储库，我要去

00:07:17.729 --> 00:07:22.979
管理类型为person的实体

00:07:19.680 --> 00:07:28.139
主键是一个类型字符串

00:07:22.979 --> 00:07:30.300
是，我将要迭代

00:07:28.139 --> 00:07:32.550
通过可能无限量的

00:07:30.300 --> 00:07:33.539
数据量很大，所以我要去

00:07:32.550 --> 00:07:35.940
充分利用

00:07:33.539 --> 00:07:37.740
自去年以来已经在 spring data 中a 

00:07:35.940 --> 00:07:41.430
让我定义取景器的功能

00:07:37.740 --> 00:07:43.530
使用延迟或基于流的方法

00:07:41.430 --> 00:07:47.030
类型，例如，我可以说

00:07:43.530 --> 00:07:49.650
想得到一连串的人和我

00:07:47.030 --> 00:07:51.599
想找到所有正确的人，所以我会

00:07:49.650 --> 00:07:53.789
只是说我将提供自定义查询

00:07:51.599 --> 00:07:55.770
像这样在MongoDB上使用

00:07:53.789 --> 00:07:59.669
基本查询所有内容的语法

00:07:55.770 --> 00:08:02.039
我想在一个特定的取景器上

00:07:59.669 --> 00:08:04.800
具体的人，所以我说给我一个

00:08:02.039 --> 00:08:09.060
可以完成的未来都写这两个

00:08:04.800 --> 00:08:11.729
案例自然地映射到

00:08:09.060 --> 00:08:13.849
反应性编程，所以我们将

00:08:11.729 --> 00:08:16.949
为我们的利益利用这里的人好

00:08:13.849 --> 00:08:18.270
现在我们想创建一些记录为

00:08:16.949 --> 00:08:21.509
总是这样，我要创建一些

00:08:18.270 --> 00:08:25.130
样本数据我会说课样本数据

00:08:21.509 --> 00:08:28.889
 CLR执行命令行Runner和

00:08:25.130 --> 00:08:31.260
将覆盖命令行

00:08:28.889 --> 00:08:32.390
渲染接口提供回调

00:08:31.260 --> 00:08:35.810
这里

00:08:32.390 --> 00:08:39.710
我们将注入人员存储库，以便

00:08:35.810 --> 00:08:43.730
我们拥有它，以便我们拥有它

00:08:39.710 --> 00:08:46.040
从4.3春季及以后开始使用

00:08:43.730 --> 00:08:48.800
我们不需要此自动连线注释

00:08:46.040 --> 00:08:50.060
所以我实际上是想记住

00:08:48.800 --> 00:08:52.490
离开它，但我意识到

00:08:50.060 --> 00:08:54.440
我们很多人仍然习惯于

00:08:52.490 --> 00:08:56.060
添加它，所以也许我应该离开

00:08:54.440 --> 00:08:58.690
我不知道我们会怎么看

00:08:56.060 --> 00:09:01.130
当我做更多这些事情时， 

00:08:58.690 --> 00:09:03.170
我们将创建一些记录，以便我命名

00:09:01.130 --> 00:09:06.980
乔希自然很高兴认识你

00:09:03.170 --> 00:09:09.200
很高兴认识你，我当然也加入了

00:09:06.980 --> 00:09:11.570
我的英雄和朋友史蒂芬·马尔蒂尼

00:09:09.200 --> 00:09:13.220
反应堆项目负责人

00:09:11.570 --> 00:09:15.770
支持WebSocket和

00:09:13.220 --> 00:09:18.550
涌现并支持反应

00:09:15.770 --> 00:09:22.070
 Web运行时和Spring 5非常非常

00:09:18.550 --> 00:09:26.210
关键人物，当然还有我们

00:09:22.070 --> 00:09:30.890
放马谁谁是一个了不起的博客文章

00:09:26.210 --> 00:09:34.070
使我着迷于这个课程的罗森故事

00:09:30.890 --> 00:09:36.230
在爱上另一个 Spring 的网络忍者

00:09:34.070 --> 00:09:37.730
我们去那是一个很小的也许我们

00:09:36.230 --> 00:09:41.500
应该添加一些规范，为什么不更多

00:09:37.730 --> 00:09:46.490
对一件事值得

00:09:41.500 --> 00:09:48.380
强调我们可以很好

00:09:46.490 --> 00:09:50.930
使用

00:09:48.380 --> 00:09:53.210
我们将要研究的方法

00:09:50.930 --> 00:09:54.800
所以我的简单样本数据仅用于

00:09:53.210 --> 00:09:57.200
只是样本数据而已

00:09:54.800 --> 00:09:58.760
因此，对于每个名称，我们将保存一个

00:09:57.200 --> 00:10:00.890
记录在数据库中，我们要

00:09:58.760 --> 00:10:05.590
说保存新的人资料库

00:10:00.890 --> 00:10:10.160
人，我们会输入名称和

00:10:05.590 --> 00:10:11.510
我们会传递一个我不想传递的ID 

00:10:10.160 --> 00:10:16.760
在这里的名称和构造函数中

00:10:11.510 --> 00:10:18.950
直到那天，谢谢你的主意

00:10:16.760 --> 00:10:22.780
我想通过它，所以我们说名字

00:10:18.950 --> 00:10:27.200
我将使用新的随机数来获得

00:10:22.780 --> 00:10:29.840
我们在那里，我们去那里的随机整数

00:10:27.200 --> 00:10:31.850
所以有我的样本记录

00:10:29.840 --> 00:10:33.860
我认为我们现在有足够的权利了吗

00:10:31.850 --> 00:10:38.540
我们需要合作的一切

00:10:33.860 --> 00:10:40.460
 MongoDB并看到它反映在

00:10:38.540 --> 00:10:43.760
一两个控制台，所以我可以说找到

00:10:40.460 --> 00:10:45.620
所有用于打印线的系统

00:10:43.760 --> 00:10:45.980
所以我将基本上使用一种方法

00:10:45.620 --> 00:10:48.770
参考

00:10:45.980 --> 00:10:50.090
金属引用以迭代到

00:10:48.770 --> 00:10:54.260
结果，顺便说一句，我认为

00:10:50.090 --> 00:10:56.720
这些组件的主要区别

00:10:54.260 --> 00:10:59.330
模仿了我们在这里所做的很多事情

00:10:56.720 --> 00:11:00.890
反应性的东西和Java DSL 

00:10:59.330 --> 00:11:03.200
春季的Java配置DSL 

00:11:00.890 --> 00:11:05.210
整合spring security的东西

00:11:03.200 --> 00:11:06.470
很多非常酷的事情

00:11:05.210 --> 00:11:10.310
我们正在做的，我们能够做的

00:11:06.470 --> 00:11:12.590
 Spring ，这几天是因为 Spring ，你

00:11:10.310 --> 00:11:14.540
知道相当的Java 8这么大

00:11:12.590 --> 00:11:17.750
它是如此受欢迎，如此大的书面和

00:11:14.540 --> 00:11:19.820
这是一个显而易见的好主意吧

00:11:17.750 --> 00:11:21.740
有很多好的功能

00:11:19.820 --> 00:11:23.360
包括lambda，以便让我们

00:11:21.740 --> 00:11:25.670
建立大量的DSL，否则

00:11:23.360 --> 00:11:28.610
成为其他人的专属权限

00:11:25.670 --> 00:11:30.230
语言，所以我很高兴看到这个

00:11:28.610 --> 00:11:31.910
方法变得更加突出

00:11:30.230 --> 00:11:33.590
我们去那里有我们的记录

00:11:31.910 --> 00:11:34.700
数据库，现在让我们建立一个简单的REST 

00:11:33.590 --> 00:11:40.700
我们将要使用的API 

00:11:34.700 --> 00:11:42.140
使用自定义服务器，我们必须

00:11:40.700 --> 00:11:42.950
在这里站起一台服务器，这又是

00:11:42.140 --> 00:11:45.770
不是你必须要做的

00:11:42.950 --> 00:11:47.480
期望经常做，对吧？ 

00:11:45.770 --> 00:11:48.530
经常这样做，但是我们需要

00:11:47.480 --> 00:11:54.470
这次要做，所以我们将创建一个

00:11:48.530 --> 00:12:03.430
服务器，我们的服务器将需要一个HTTP 

00:11:54.470 --> 00:12:07.820
处理程序，我们可以通过创建一个处理程序

00:12:03.430 --> 00:12:10.970
传递路由器功能，这是

00:12:07.820 --> 00:12:13.370
我们需要定义什么，但现在让我们

00:12:10.970 --> 00:12:15.890
假设已在此处定义

00:12:13.370 --> 00:12:18.860
很快它将被定义

00:12:15.890 --> 00:12:19.670
我们将继续定义该HTTP 

00:12:18.860 --> 00:12:22.700
服务器，因此我们将定义一个

00:12:19.670 --> 00:12:24.470
需要的处理程序

00:12:22.700 --> 00:12:25.640
来自此路由器的指令

00:12:24.470 --> 00:12:28.280
要建立这个路由器功能

00:12:25.640 --> 00:12:32.110
如果您愿意，这就是路线

00:12:28.280 --> 00:12:33.980
我们的功能性Spring MVC端点还可以

00:12:32.110 --> 00:12:38.060
然后我们将创建一个H 

00:12:33.980 --> 00:12:40.940
当我经过HP服务器时，服务器在这里

00:12:38.060 --> 00:12:43.160
在自定义端口8080或那里

00:12:40.940 --> 00:12:44.840
走，自然这就是你知道的

00:12:43.160 --> 00:12:46.970
是你会放进去的东西

00:12:44.840 --> 00:12:49.550
属性文件，或者甚至可能只是

00:12:46.970 --> 00:12:51.110
注入服务器属性

00:12:49.550 --> 00:12:52.790
 Spring Boot Server属性在这里和

00:12:51.110 --> 00:12:54.770
你可以说服务起来

00:12:52.790 --> 00:12:56.450
潜入港口的权利，实际上

00:12:54.770 --> 00:12:58.520
给我们一些东西，所以如果我们看看

00:12:56.450 --> 00:12:59.680
默认服务器属性，我们可以

00:12:58.520 --> 00:13:03.910
看到

00:12:59.680 --> 00:13:08.020
在默认端口上

00:13:03.910 --> 00:13:14.110
未指明是真的，所以也许我们

00:13:08.020 --> 00:13:17.350
如果值是

00:13:14.110 --> 00:13:19.930
在春季未指定，但在春季

00:13:17.350 --> 00:13:23.320
使用套接字工具找到一个

00:13:19.930 --> 00:13:25.089
否则未使用的端口和时间，但是

00:13:23.320 --> 00:13:26.890
我们的目的是让我们

00:13:25.089 --> 00:13:31.120
只要保持简单就可以理解

00:13:26.890 --> 00:13:38.080
这里发生了什么事，所以那里8080 

00:13:31.120 --> 00:13:41.680
你走的很好，现在我们需要开始

00:13:38.080 --> 00:13:43.480
通过使用新的反应式HTTP服务器

00:13:41.680 --> 00:13:46.510
处理程序适配器，我们将适应我们的

00:13:43.480 --> 00:13:51.850
自定义手就在这里，我们要去

00:13:46.510 --> 00:13:54.220
返回服务器HTTP服务器，并

00:13:51.850 --> 00:13:56.110
我们去那是我们的那是

00:13:54.220 --> 00:13:57.399
简单的机械，还有很多

00:13:56.110 --> 00:13:59.470
我们可以在这里做的其他事情

00:13:57.399 --> 00:14:04.330
我们创建的是一个HTTP引擎

00:13:59.470 --> 00:14:06.670
反应器HTTP服务器组件

00:14:04.330 --> 00:14:08.380
来自项目反应堆本身，然后

00:14:06.670 --> 00:14:10.120
运行时组件的种类

00:14:08.380 --> 00:14:11.980
反应Spring 的模型

00:14:10.120 --> 00:14:14.230
此处提供组件模型

00:14:11.980 --> 00:14:18.970
通过此反应式HTTP处理程序适配器

00:14:14.230 --> 00:14:20.920
和HTTP处理程序在这里

00:14:18.970 --> 00:14:23.500
让我们来谈谈路由器的里亚德

00:14:20.920 --> 00:14:24.670
功能才是真正的本源

00:14:23.500 --> 00:14:26.410
特别的三明治就是那个东西

00:14:24.670 --> 00:14:28.209
我们在这里关心，所以我们

00:14:26.410 --> 00:14:32.680
会说我们要找到一个

00:14:28.209 --> 00:14:39.190
路由器荒唐的功能和路由器做

00:14:32.680 --> 00:14:41.290
所以我们需要返回一条这样的路线

00:14:39.190 --> 00:14:44.500
我们将做长版

00:14:41.290 --> 00:14:46.750
使用完全限定的static 

00:14:44.500 --> 00:14:48.700
类中的方法，但随后您将看到

00:14:46.750 --> 00:14:52.180
 DSL变得更干净了

00:14:48.700 --> 00:14:54.339
一旦你消除了那种静态

00:14:52.180 --> 00:14:59.250
使用静态方法引用

00:14:54.339 --> 00:14:59.250
导入还可以，所以我们将使用get 

00:14:59.310 --> 00:15:05.680
人们好吧，这变成这是

00:15:03.130 --> 00:15:07.300
实际要求谓词2所以

00:15:05.680 --> 00:15:09.850
那是

00:15:07.300 --> 00:15:12.160
那然后是预期的

00:15:09.850 --> 00:15:13.300
 lambda处理该请求

00:15:12.160 --> 00:15:16.120
到达

00:15:13.300 --> 00:15:17.800
根据个人的任何要求，我们可以

00:15:16.120 --> 00:15:19.930
当然更具体，我们可以

00:15:17.800 --> 00:15:25.060
指定很多不同的路线，所以在这里

00:15:19.930 --> 00:15:33.750
我们可以说并要求谓词点

00:15:25.060 --> 00:15:36.790
路线点获取确切的人的ID和

00:15:33.750 --> 00:15:39.790
然后指定每个要处理的lambda 

00:15:36.790 --> 00:15:46.290
这个要求也好，所以我是对的

00:15:39.790 --> 00:15:49.329
现在我传递的只是一个非常公正的

00:15:46.290 --> 00:15:52.029
默认的lambdas在这里不起作用

00:15:49.329 --> 00:15:53.500
自然这是行不通的，但是我们可以修复

00:15:52.029 --> 00:15:55.540
一旦我们有了那种

00:15:53.500 --> 00:15:58.950
脚手架做完了，我发现它有助于

00:15:55.540 --> 00:16:02.890
充实我们想在这里做什么

00:15:58.950 --> 00:16:04.420
然后提供实际的定义

00:16:02.890 --> 00:16:05.829
对于那些lambda或那些确定的你

00:16:04.420 --> 00:16:07.149
知道那些对象，我们会做的

00:16:05.829 --> 00:16:09.130
其实在另一个班上

00:16:07.149 --> 00:16:11.740
原因不是特别

00:16:09.130 --> 00:16:13.000
对实施该代码很有价值

00:16:11.740 --> 00:16:14.890
在这里，因为它变成了一种

00:16:13.000 --> 00:16:18.970
眼睛很对，所以我们要去的是

00:16:14.890 --> 00:16:20.770
如果您愿意，我们会告诉您简单的映射

00:16:18.970 --> 00:16:22.329
这是很多事情

00:16:20.770 --> 00:16:25.570
这是应该做的事情

00:16:22.329 --> 00:16:28.690
现在在Spring MVC中处理程序映射的说明

00:16:25.570 --> 00:16:32.410
当然可以做得更多

00:16:28.690 --> 00:16:34.209
例如使用其他掠食者可以进一步

00:16:32.410 --> 00:16:37.810
断言我的请求你知道我可以

00:16:34.209 --> 00:16:39.730
进一步压缩排位赛

00:16:37.810 --> 00:16:43.120
请求，我可以说例如

00:16:39.730 --> 00:16:45.940
请求谓词点接受媒体

00:16:43.120 --> 00:16:47.980
正确输入应用程序JSON，因此

00:16:45.940 --> 00:16:50.620
我只会在这种情况下

00:16:47.980 --> 00:16:52.810
要响应两个传入的客户端

00:16:50.620 --> 00:16:56.560
将会接受Jason的申请

00:16:52.810 --> 00:16:57.910
媒体类型好吧，它变得有点

00:16:56.560 --> 00:16:59.470
在我们看来，这样做是多余的

00:16:57.910 --> 00:17:00.899
我们就不用管它了，但是就足够了

00:16:59.470 --> 00:17:03.130
说那里现在有很多力量

00:17:00.899 --> 00:17:07.410
让我们来谈谈那些兰多吧

00:17:03.130 --> 00:17:10.419
在Arion谈论这些实现

00:17:07.410 --> 00:17:12.220
在他认为的博客中有一个好主意

00:17:10.419 --> 00:17:15.250
允许将此代码放入单独的

00:17:12.220 --> 00:17:17.380
上课，然后他就重用了

00:17:15.250 --> 00:17:18.459
在开发一个例子，我认为

00:17:17.380 --> 00:17:20.199
这是一个好主意，因为它做到了

00:17:18.459 --> 00:17:21.730
测试起来更容易

00:17:20.199 --> 00:17:24.040
它消除了很多生意

00:17:21.730 --> 00:17:25.689
逻辑远离路由定义

00:17:24.040 --> 00:17:26.709
对，所以我们要创建我们不

00:17:25.689 --> 00:17:28.000
在这里做同样的事情

00:17:26.709 --> 00:17:30.159
知道我们将不得不

00:17:28.000 --> 00:17:31.390
为这些不同提供两种方法

00:17:30.159 --> 00:17:34.720
终点，我们很棒的自定义课程

00:17:31.390 --> 00:17:38.980
这里叫人经理好吧

00:17:34.720 --> 00:17:43.179
假设是班级人员经理，我们

00:17:38.980 --> 00:17:47.529
必须回应，让我们

00:17:43.179 --> 00:17:48.909
Spring 反应有效载荷，如果您愿意

00:17:47.529 --> 00:17:50.230
响应的信封有效载荷

00:17:48.909 --> 00:17:51.490
我们要寄回去， 

00:17:50.230 --> 00:17:52.840
去我们要去这将要

00:17:51.490 --> 00:17:54.490
可以处理所有

00:17:52.840 --> 00:17:57.399
记录正确，然后我们有另一个

00:17:54.490 --> 00:18:01.929
一个只会回应

00:17:57.399 --> 00:18:04.149
通过ID记录，因此请记住这一点

00:18:01.929 --> 00:18:05.649
我们全都没有考虑到这一点

00:18:04.149 --> 00:18:08.230
方法将被轮流

00:18:05.649 --> 00:18:09.429
一个人在反应堆中的实例

00:18:08.230 --> 00:18:10.929
我们想要做的世界不是

00:18:09.429 --> 00:18:12.130
我们不试图返回收藏

00:18:10.929 --> 00:18:14.770
请记住，我们正在尝试返回

00:18:12.130 --> 00:18:17.350
代表潜在的对象

00:18:14.770 --> 00:18:22.140
无休止的价值流，所以一个集合

00:18:17.350 --> 00:18:23.950
我们尝试退货并不适合

00:18:22.140 --> 00:18:26.049
潜在的无休止的价值流

00:18:23.950 --> 00:18:29.260
那会给我们通知

00:18:26.049 --> 00:18:32.980
当新值可用时，这样

00:18:29.260 --> 00:18:34.690
因此在反应式流API中

00:18:32.980 --> 00:18:38.200
活动流API是一个隐式

00:18:34.690 --> 00:18:40.899
某种商定的语言

00:18:38.200 --> 00:18:44.020
描述它的反作用背压

00:18:40.899 --> 00:18:46.210
东西--关键和其他

00:18:44.020 --> 00:18:48.940
像Light Bend这样的利益相关者

00:18:46.210 --> 00:18:53.020
 ibaka和红色帽子的祖先

00:18:48.940 --> 00:18:57.130
他们的顶点和Netflix 

00:18:53.020 --> 00:18:58.779
 RX RX Java 1.0当然不会

00:18:57.130 --> 00:19:02.049
具有反应流实施

00:18:58.779 --> 00:19:04.270
支持但在反应流中很好

00:19:02.049 --> 00:19:06.760
 Roderick的Java而不是-所有这些

00:19:04.270 --> 00:19:10.450
签名者定义语言

00:19:06.760 --> 00:19:13.179
反应流和反压

00:19:10.450 --> 00:19:16.659
在那方面做得很好

00:19:13.179 --> 00:19:20.200
基本定义现在是JDK 9的一部分

00:19:16.659 --> 00:19:22.690
因此JDK 9 Java 9将拥有Java 

00:19:20.200 --> 00:19:28.590
 util并发流程包基于

00:19:22.690 --> 00:19:31.470
在这个这个做的工作

00:19:28.590 --> 00:19:34.450
说明这是这份文件还可以

00:19:31.470 --> 00:19:36.460
所以在那个世界里，我们有一个

00:19:34.450 --> 00:19:40.150
发布者，发布者可以发布它

00:19:36.460 --> 00:19:42.670
这是一个潜在的无限

00:19:40.150 --> 00:19:45.160
可以发布或为零的值

00:19:42.670 --> 00:19:47.140
或不计其数的数字

00:19:45.160 --> 00:19:49.620
价值观有专业化

00:19:47.140 --> 00:19:52.180
为了方便起见，这四个

00:19:49.620 --> 00:19:54.370
反应堆项目写我们的反应堆

00:19:52.180 --> 00:19:57.580
项目反应堆反应堆三达多在

00:19:54.370 --> 00:20:00.670
具体的，所以如果我们要返回

00:19:57.580 --> 00:20:02.290
返回一个或多个值的流

00:20:00.670 --> 00:20:08.170
这就是所谓的通量

00:20:02.290 --> 00:20:12.310
好吧，人流当然是两个

00:20:08.170 --> 00:20:14.640
处理响应

00:20:12.310 --> 00:20:17.200
处理我们需要的回应

00:20:14.640 --> 00:20:22.810
询问并处理请求，以便

00:20:17.200 --> 00:20:25.060
我们将其传递给这里，好使

00:20:22.810 --> 00:20:27.670
现在暂时没有

00:20:25.060 --> 00:20:30.910
除了不返回通量，我们

00:20:27.670 --> 00:20:33.460
将只返回一个对象

00:20:30.910 --> 00:20:34.960
值一或零值基本上是

00:20:33.460 --> 00:20:36.610
它在那儿，或者不是，但那是

00:20:34.960 --> 00:20:38.800
不会超过一个值，并且

00:20:36.610 --> 00:20:41.560
在反应堆世界中，这是

00:20:38.800 --> 00:20:47.020
都叫做单声道工具，两者都是

00:20:41.560 --> 00:20:48.760
发布者的子类好，所以我们

00:20:47.020 --> 00:20:50.170
得到所有我们的理解

00:20:48.760 --> 00:20:52.180
通过使用正确的两个流API 

00:20:50.170 --> 00:20:57.160
我们从所有人那里受益

00:20:52.180 --> 00:20:58.540
那，但是我们有能力做更多

00:20:57.160 --> 00:20:59.800
现在我们知道我们有趣的事情

00:20:58.540 --> 00:21:01.480
有一定的界限，我们了解

00:20:59.800 --> 00:21:04.960
我们将获得的数据约束

00:21:01.480 --> 00:21:07.320
我们可能会没事的，所以对于所有人

00:21:04.960 --> 00:21:11.530
方法和按ID方法

00:21:07.320 --> 00:21:13.990
你知道我们已经把它存根了

00:21:11.530 --> 00:21:18.160
我们正在尝试做，现在我们可以重复使用

00:21:13.990 --> 00:21:20.260
我们可以告诉Spring的处理程序

00:21:18.160 --> 00:21:23.110
您知道要将该对象注入

00:21:20.260 --> 00:21:28.780
在此处将其用作aa参数

00:21:23.110 --> 00:21:32.890
所以我们会说处理程序一切正常，然后

00:21:28.780 --> 00:21:33.910
我们将使用ID说出处理程序

00:21:32.890 --> 00:21:35.350
方法参考这里，我认为

00:21:33.910 --> 00:21:36.970
那很干净对，我们不是

00:21:35.350 --> 00:21:38.590
担心我们的业务逻辑

00:21:36.970 --> 00:21:40.960
只是知道这个lambda要

00:21:38.590 --> 00:21:43.260
被调用，我们可以做更多

00:21:40.960 --> 00:21:46.390
随便测试一下，我认为这很好

00:21:43.260 --> 00:21:47.740
在 Spring 之间折衷

00:21:46.390 --> 00:21:49.360
 MVC剪辑经典的春季MVC 

00:21:47.740 --> 00:21:53.020
组件模型以及我们所需要的东西

00:21:49.360 --> 00:21:53.830
现在在这里做的所有用例是

00:21:53.020 --> 00:21:55.419
漂亮

00:21:53.830 --> 00:21:59.890
简单，不是吗，我们只需要

00:21:55.419 --> 00:22:03.159
从我们的人那里获取数据

00:21:59.890 --> 00:22:06.610
存储库，并根据请求将其发送回

00:22:03.159 --> 00:22:08.860
然后我将提供一个

00:22:06.610 --> 00:22:11.529
显式构造函数，所以我们说一个

00:22:08.860 --> 00:22:13.630
人员存储库全部点缀，我们得到一个

00:22:11.529 --> 00:22:16.529
流，所以我想做的就是

00:22:13.630 --> 00:22:20.740
采取这个我想采取的流和

00:22:16.529 --> 00:22:24.850
然后将其调整为通量，这样我就

00:22:20.740 --> 00:22:29.620
说给我一个通量，然后我需要

00:22:24.850 --> 00:22:30.940
将结果值包装在那里

00:22:29.620 --> 00:22:34.059
结果值我想把它包装在

00:22:30.940 --> 00:22:38.620
回应，然后将其发送回去，所以我们

00:22:34.059 --> 00:22:40.480
可以说现在响应点还可以

00:22:38.620 --> 00:22:42.639
自然知道还有其他建造者

00:22:40.480 --> 00:22:44.980
这里的方法还可以，不好的要求不是

00:22:42.639 --> 00:22:48.309
发现等等，这非常类似于

00:22:44.980 --> 00:22:50.169
春季MBC回应实体，您将

00:22:48.309 --> 00:22:51.730
你知道回去很自然

00:22:50.169 --> 00:22:53.529
在一个程序模型和

00:22:51.730 --> 00:22:56.260
其他我会说回应不好

00:22:53.529 --> 00:22:58.840
点，我们现在需要创建一个主体

00:22:56.260 --> 00:23:00.850
记住这是然后这是一个

00:22:58.840 --> 00:23:03.190
针对处理而优化的引擎

00:23:00.850 --> 00:23:06.669
可能无限量的数据，因此

00:23:03.190 --> 00:23:08.590
我们对回应主体的概念

00:23:06.669 --> 00:23:09.970
这些东西的内容长度很多

00:23:08.590 --> 00:23:12.610
我们理所当然地认为

00:23:09.970 --> 00:23:14.740
传统的HTTP这些东西必须

00:23:12.610 --> 00:23:18.159
特别考虑一下

00:23:14.740 --> 00:23:20.830
正确传输JSON是什么意思

00:23:18.159 --> 00:23:24.840
与JSON一起使用，我们真的不知道

00:23:20.830 --> 00:23:27.460
如果我们有大量的数据

00:23:24.840 --> 00:23:30.580
自然地，所以有额外的工作

00:23:27.460 --> 00:23:32.590
在引擎下面做

00:23:30.580 --> 00:23:35.500
 JSON的渲染，我们已经

00:23:32.590 --> 00:23:37.000
当然可以做到，但是就目前而言

00:23:35.500 --> 00:23:39.130
这些东西很多

00:23:37.000 --> 00:23:41.860
这个身体插入器的条款

00:23:39.130 --> 00:23:43.149
界面正确，因此我们将使用

00:23:41.860 --> 00:23:47.679
在这里我们要说身体

00:23:43.149 --> 00:23:49.929
插入点，我们将创建

00:23:47.679 --> 00:23:52.090
基于发布者的插入器

00:23:49.929 --> 00:23:54.220
我们将数据写入身体

00:23:52.090 --> 00:23:56.889
当它通过以下方式将数据验证到正文中时

00:23:54.220 --> 00:24:03.480
消耗来自该流量的数据

00:23:56.889 --> 00:24:07.179
好吧，我们在那里弯曲

00:24:03.480 --> 00:24:08.320
那应该解决不了的方法哦

00:24:07.179 --> 00:24:09.850
我们需要做的另一件事就是像我

00:24:08.320 --> 00:24:12.070
说我们需要给它一个框架，我们

00:24:09.850 --> 00:24:13.870
需要这个非常类似于TCP或

00:24:12.070 --> 00:24:15.910
经典TTP和经典网络

00:24:13.870 --> 00:24:17.230
编程我们现在有一个消息框

00:24:15.910 --> 00:24:18.880
对，因为我们正在流式传输

00:24:17.230 --> 00:24:21.040
我们可能无限量的数据

00:24:18.880 --> 00:24:22.299
需要帮助框架本身框架

00:24:21.040 --> 00:24:24.220
数据，它需要这样做

00:24:22.299 --> 00:24:26.770
您如何知道这意味着什么的术语

00:24:24.220 --> 00:24:29.679
在一个人中成为一个人

00:24:26.770 --> 00:24:32.350
基本上是无限的

00:24:29.679 --> 00:24:33.790
人，这就是边界

00:24:32.350 --> 00:24:36.100
为什么我们必须提供这个不是

00:24:33.790 --> 00:24:37.870
泛型，但因为现在

00:24:36.100 --> 00:24:39.580
其他方法多一点

00:24:37.870 --> 00:24:42.160
有趣，因为我们不知道我们

00:24:39.580 --> 00:24:45.910
希望对了，我们期望我们将

00:24:42.160 --> 00:24:48.010
有一个ID一个参数这里是一个路径

00:24:45.910 --> 00:24:49.990
传入的变量是一个ID，因此

00:24:48.010 --> 00:24:52.059
让我们用

00:24:49.990 --> 00:24:55.090
假设可能不存在

00:24:52.059 --> 00:24:58.540
我们说请求点路径变量ID 

00:24:55.090 --> 00:25:05.169
如果在那里，我们得到的是

00:24:58.540 --> 00:25:10.570
 Java 8可选权，因此ID可选或

00:25:05.169 --> 00:25:13.390
您说可选的地图ID，然后我们

00:25:10.570 --> 00:25:14.970
可以说我们要获取数据

00:25:13.390 --> 00:25:17.860
从存储库中，所以我们将获得

00:25:14.970 --> 00:25:21.160
通过在此传递ID的ID找到它

00:25:17.860 --> 00:25:26.919
如果我们找到它，那么我们想映射

00:25:21.160 --> 00:25:34.660
变成一个单声道，所以我们要

00:25:26.919 --> 00:25:36.190
说人或人的单点

00:25:34.660 --> 00:25:38.049
未来，因为我们将获得

00:25:36.190 --> 00:25:39.880
电脑可以在这里完成的未来

00:25:38.049 --> 00:25:43.919
呃我们的界面在哪里

00:25:39.880 --> 00:25:48.130
可以完成的未来

00:25:43.919 --> 00:25:51.520
然后，如果我们不知道，那么我们是否

00:25:48.130 --> 00:25:56.350
如果我们想创建一个

00:25:51.520 --> 00:26:01.809
保持正确的回应

00:25:56.350 --> 00:26:05.830
我们之前做过，所以我们会说单声道会

00:26:01.809 --> 00:26:09.880
使用响应好点体包裹起来

00:26:05.830 --> 00:26:13.630
在这里，我们将使用身体

00:26:09.880 --> 00:26:15.800
在搜索者中再次从发布商Mono获得

00:26:13.630 --> 00:26:18.160
当你做

00:26:15.800 --> 00:26:23.390
如果你愿意的话，在那里服药

00:26:18.160 --> 00:26:26.180
然后我们应该能够

00:26:23.390 --> 00:26:27.980
要做的就是我们还有一件事

00:26:26.180 --> 00:26:29.390
我们需要处理情况

00:26:27.980 --> 00:26:32.000
不存在的地方就是

00:26:29.390 --> 00:26:33.860
否则抛出一些条款，我们要

00:26:32.000 --> 00:26:36.440
说如果我们找不到

00:26:33.860 --> 00:26:38.180
如果我们无法加载数据，我们应该

00:26:36.440 --> 00:26:39.890
抛出适当的自定义异常，但

00:26:38.180 --> 00:26:42.100
让我们只是说说我们

00:26:39.890 --> 00:26:44.870
没有正确的状态

00:26:42.100 --> 00:26:46.760
哎呀，我们走了，所以我鼓励你

00:26:44.870 --> 00:26:48.950
做得比我好得多

00:26:46.760 --> 00:26:50.810
现在我们可以看到ID为

00:26:48.950 --> 00:26:53.900
提供帮助我们在这里想要帮助

00:26:50.810 --> 00:26:55.880
我们真的很不好看用途

00:26:53.900 --> 00:26:58.280
本来可以作为方法的事物

00:26:55.880 --> 00:26:59.480
引用，并且看起来不，它们是静态的

00:26:58.280 --> 00:27:01.130
导入，因此我们将在

00:26:59.480 --> 00:27:02.630
其次，让我们确认一下

00:27:01.130 --> 00:27:17.660
正在工作，让我们继续前进， 

00:27:02.630 --> 00:27:20.060
启动它和localhost：8080以及什么

00:27:17.660 --> 00:27:23.900
我们是不是说我们称呼这个人的

00:27:20.060 --> 00:27:26.420
终结点，所以人们大呼这不是一个

00:27:23.900 --> 00:27:35.570
因为那个ID不存在就是这些

00:27:26.420 --> 00:27:39.880
这里的名字很高兴在那里吃那个

00:27:35.570 --> 00:27:42.710
所以有唱片就在我身旁

00:27:39.880 --> 00:27:49.100
可以根据需要查找尽可能多的数据

00:27:42.710 --> 00:27:50.900
得到我期望的结果，让我们开始吧

00:27:49.100 --> 00:27:52.400
回到我们的数据现在让我们回到

00:27:50.900 --> 00:27:53.570
到我们的代码，然后清理它

00:27:52.400 --> 00:27:55.250
我想我们在一个好地方， 

00:27:53.570 --> 00:27:58.940
我想你已经知道了

00:27:55.250 --> 00:28:01.520
很自然地适应 Spring 

00:27:58.940 --> 00:28:03.920
数据支持，并将其与

00:28:01.520 --> 00:28:05.600
现在，反应式API可以

00:28:03.920 --> 00:28:07.130
说说对支持的反应

00:28:05.600 --> 00:28:08.870
Spring 数据模块首先是

00:28:07.130 --> 00:28:13.130
仅限于模块的一个子集

00:28:08.870 --> 00:28:14.240
支持响应式API，因此在春季

00:28:13.130 --> 00:28:17.600
本身，您可以使用它

00:28:14.240 --> 00:28:19.070
具有JPA的MongoDB和Couchbase，但这

00:28:17.600 --> 00:28:21.050
取决于底层

00:28:19.070 --> 00:28:23.570
实施，您不会

00:28:21.050 --> 00:28:25.490
总是有反应性语义，也许

00:28:23.570 --> 00:28:28.250
您将拥有流式语义，即

00:28:25.490 --> 00:28:30.150
比您知道的还要好选择所有

00:28:28.250 --> 00:28:33.010
有点

00:28:30.150 --> 00:28:35.680
方法，但并不完全相同

00:28:33.010 --> 00:28:37.480
事情有一些有趣的消息

00:28:35.680 --> 00:28:39.070
上周刚从Java出来

00:28:37.480 --> 00:28:42.250
甲骨文宣布他们

00:28:39.070 --> 00:28:44.320
在某种程度上不是对

00:28:42.250 --> 00:28:47.020
 JDBC，但另一个并行项目

00:28:44.320 --> 00:28:50.770
努力引入反应式编程

00:28:47.020 --> 00:28:52.960
我对数据库驱动程序的支持

00:28:50.770 --> 00:28:56.740
不知道这是JDBC本身还是

00:28:52.960 --> 00:28:58.410
它是侧面分支还是

00:28:56.740 --> 00:29:00.400
那样的东西，但重点是

00:28:58.410 --> 00:29:01.960
显然他们至少在想

00:29:00.400 --> 00:29:03.370
关于这个，所以这可能

00:29:01.960 --> 00:29:06.970
对于我们中的那些人来说可能是个好兆头

00:29:03.370 --> 00:29:12.610
试图与一个被动的你一起工作

00:29:06.970 --> 00:29:17.650
知道续集数据库好了，现在我们

00:29:12.610 --> 00:29:19.690
要删除它，所以我们说添加

00:29:17.650 --> 00:29:21.940
路由器的按需静态导入

00:29:19.690 --> 00:29:24.790
实用的Cray功能

00:29:21.940 --> 00:29:26.830
按需添加谓词

00:29:24.790 --> 00:29:28.390
极大的帮助，我

00:29:26.830 --> 00:29:30.760
以为你同意那实际上不是

00:29:28.390 --> 00:29:35.130
在这一点上不好，变成一个

00:29:30.760 --> 00:29:39.430
很干净的一线，所以有

00:29:35.130 --> 00:29:44.920
在这里，我们可以使用方法引用

00:29:39.430 --> 00:29:47.500
在这里还可以，我们还不错，我

00:29:44.920 --> 00:29:49.690
甚至可以用这个我可以用我刚刚见过的

00:29:47.500 --> 00:29:54.160
可以使用for的按需静态

00:29:49.690 --> 00:29:56.140
这里的谓词也可以

00:29:54.160 --> 00:30:01.210
我想我的朋友是一个快速的眼神

00:29:56.140 --> 00:30:04.090
在反应性功能端点和

00:30:01.210 --> 00:30:06.910
春季MVC五个，希望您能参加

00:30:04.090 --> 00:30:09.310
启动Spring ，IO，并踢

00:30:06.910 --> 00:30:11.350
得到一点点，如果你踢轮胎

00:30:09.310 --> 00:30:13.750
将查看我们伊恩的精彩博客

00:30:11.350 --> 00:30:16.530
并继续关注其中的四个

00:30:13.750 --> 00:30:16.530
视频非常感谢

00:30:25.149 --> 00:30:27.210
您

