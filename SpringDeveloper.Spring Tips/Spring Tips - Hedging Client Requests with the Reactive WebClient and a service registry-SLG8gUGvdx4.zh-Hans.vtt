WEBVTT
Kind: captions
Language: zh-Hans

00:00:24.960 --> 00:00:29.289
嗨， Spring 粉丝们欢迎来到另一个

00:00:27.429 --> 00:00:30.910
在此安装Spring 提示

00:00:29.289 --> 00:00:32.290
分期付款，我们将看一个非常

00:00:30.910 --> 00:00:35.670
我最近的有趣模式

00:00:32.290 --> 00:00:38.530
想起了被称为对冲现在的对冲

00:00:35.670 --> 00:00:40.540
是一种易于操作的模式

00:00:38.530 --> 00:00:42.150
有期限或SLA的客户

00:00:40.540 --> 00:00:44.530
某种驱动的用例

00:00:42.150 --> 00:00:47.170
通过制作多个来实现该用例

00:00:44.530 --> 00:00:49.210
并发调用并响应

00:00:47.170 --> 00:00:50.980
基本返回的第一个请求

00:00:49.210 --> 00:00:52.059
因此，如果您致电服务， 

00:00:50.980 --> 00:00:54.850
该服务将成为垃圾

00:00:52.059 --> 00:00:57.250
垃圾收集暂停或已关闭或

00:00:54.850 --> 00:00:59.050
会有一些延迟或其他

00:00:57.250 --> 00:01:01.660
知道可能是什么打h 

00:00:59.050 --> 00:01:04.089
麻烦就解决了

00:01:01.660 --> 00:01:06.340
多次通话，您对冲您的赌注

00:01:04.089 --> 00:01:07.690
他们中的一个会及时返回

00:01:06.340 --> 00:01:09.520
拨打多个电话，以便您拥有

00:01:07.690 --> 00:01:11.679
一个你会成功的人

00:01:09.520 --> 00:01:13.119
如果其他人来的话

00:01:11.679 --> 00:01:14.619
返回伟大，你知道，但如果他们不知道

00:01:13.119 --> 00:01:16.149
很好，你也可以丢弃

00:01:14.619 --> 00:01:20.560
他们对，你不需要他们的

00:01:16.149 --> 00:01:22.360
课程只有在您可以拨打电话的情况下才有效

00:01:20.560 --> 00:01:24.009
多次，你知道他们必须

00:01:22.360 --> 00:01:25.390
他们必须是无能的权利

00:01:24.009 --> 00:01:29.050
能够承受多次通话

00:01:25.390 --> 00:01:31.090
没有任何不必要的观察到的一面

00:01:29.050 --> 00:01:34.989
效果，所以非常有趣

00:01:31.090 --> 00:01:36.640
模式，这是其中一种

00:01:34.989 --> 00:01:38.229
需要服务的模式

00:01:36.640 --> 00:01:40.390
注册表中有很多东西

00:01:38.229 --> 00:01:41.590
我们可以做的，我们在

00:01:40.390 --> 00:01:42.910
我们谈论的认知架构

00:01:41.590 --> 00:01:45.580
服务注册中心很多，因为

00:01:42.910 --> 00:01:47.890
许多超越我们的模式

00:01:45.580 --> 00:01:51.429
可以使用常规DNS进行正确的DNS 

00:01:47.890 --> 00:01:55.179
是有用的，但不是很多

00:01:51.429 --> 00:01:57.610
用例足够，所以DNS告诉我

00:01:55.179 --> 00:01:59.379
本应居住的地方

00:01:57.610 --> 00:02:01.390
如果它还活着，那区别

00:01:59.379 --> 00:02:03.879
了解服务是否重要很重要

00:02:01.390 --> 00:02:06.119
醒着，还活着并且能够回应它

00:02:03.879 --> 00:02:09.459
与知道您有很大不同

00:02:06.119 --> 00:02:10.869
该服务的位置我需要

00:02:09.459 --> 00:02:12.640
为了能够做

00:02:10.869 --> 00:02:13.989
不同种类的负载反弹客户端

00:02:12.640 --> 00:02:16.180
边注平衡我能够

00:02:13.989 --> 00:02:17.290
控制我想要的客户端

00:02:16.180 --> 00:02:19.660
建立更多的控制权

00:02:17.290 --> 00:02:21.310
从客户端路由到服务，我

00:02:19.660 --> 00:02:24.489
也可以在客户端上控制

00:02:21.310 --> 00:02:27.040
所以这是另一个用例

00:02:24.489 --> 00:02:28.690
与服务对话的能力

00:02:27.040 --> 00:02:30.519
注册表，然后询问服务

00:02:28.690 --> 00:02:31.750
注册表中的任何一个

00:02:30.519 --> 00:02:32.950
不同的服务在那里

00:02:31.750 --> 00:02:34.840
然后能够做出决定

00:02:32.950 --> 00:02:37.480
基于任何类型的标准或

00:02:34.840 --> 00:02:37.960
谓词可以是什么

00:02:37.480 --> 00:02:39.870
很

00:02:37.960 --> 00:02:41.950
特别是如果你非常特别

00:02:39.870 --> 00:02:43.150
负载均衡的各种用例

00:02:41.950 --> 00:02:46.090
这个例子假设你想做

00:02:43.150 --> 00:02:47.350
多租户或数据中心意识

00:02:46.090 --> 00:02:49.870
或这些东西分片

00:02:47.350 --> 00:02:51.760
不管是什么，如果您可以这样做

00:02:49.870 --> 00:02:53.290
了解给定的实例数

00:02:51.760 --> 00:02:56.740
您所拥有的服务及其位置

00:02:53.290 --> 00:02:58.390
 DNS也有一些限制，您

00:02:56.740 --> 00:02:59.650
可以很容易地绕过他们

00:02:58.390 --> 00:03:01.480
但这只是其中之一

00:02:59.650 --> 00:03:04.480
你要记得做例如

00:03:01.480 --> 00:03:06.850
像Java这样的DNS客户端将缓存

00:03:04.480 --> 00:03:08.800
解析的IP地址，所以如果您转到

00:03:06.850 --> 00:03:10.630
 DNS服务器DNS服务器为您提供了

00:03:08.800 --> 00:03:13.570
 Java客户端将保留的IP地址

00:03:10.630 --> 00:03:15.670
然后路由后续请求

00:03:13.570 --> 00:03:17.950
而不是DNS服务器，而是IP 

00:03:15.670 --> 00:03:19.180
地址，所以这意味着

00:03:17.950 --> 00:03:21.760
客户最终会受到不公平的对待

00:03:19.180 --> 00:03:24.100
跟踪第一个IP地址

00:03:21.760 --> 00:03:25.300
接下来在NJ Miam中解决了

00:03:24.100 --> 00:03:27.490
当您重新启动JVM时，它可能

00:03:25.300 --> 00:03:29.410
解决显然可以解决此问题

00:03:27.490 --> 00:03:31.270
设置您的DNS有时间

00:03:29.410 --> 00:03:32.500
值为0，然后您知道爬升

00:03:31.270 --> 00:03:33.580
他们做正确的事，但你知道

00:03:32.500 --> 00:03:34.870
这些是您必须要做的事情

00:03:33.580 --> 00:03:37.270
记住，他们并不完全在前面

00:03:34.870 --> 00:03:39.450
和中心，他们被埋葬，我想

00:03:37.270 --> 00:03:41.620
我们大多数人会考虑某种神秘的东西

00:03:39.450 --> 00:03:42.610
配置参数，所以我们不

00:03:41.620 --> 00:03:45.880
我在这些类型上要做的

00:03:42.610 --> 00:03:46.930
事情，所以这种模式对冲是

00:03:45.880 --> 00:03:48.010
这些只是其中之一

00:03:46.930 --> 00:03:50.290
真的可以很好地服务

00:03:48.010 --> 00:03:53.500
注册表，因为您需要具备以下能力

00:03:50.290 --> 00:03:55.600
问两三个或三个你

00:03:53.500 --> 00:03:57.250
知道给定的不同实例

00:03:55.600 --> 00:03:59.020
服务，所以我们要做的就是

00:03:57.250 --> 00:04:00.340
将使用服务注册表，它可以

00:03:59.020 --> 00:04:02.140
在其中使用您可以使用任何服务

00:04:00.340 --> 00:04:04.270
 Spring Cloud支持的注册表

00:04:02.140 --> 00:04:06.160
 Spring 俱乐部的仪式得到了发现

00:04:04.270 --> 00:04:07.480
客户端抽象和发现

00:04:06.160 --> 00:04:09.850
善良的抽象为您提供了能力

00:04:07.480 --> 00:04:11.770
问一个问题是什么实例

00:04:09.850 --> 00:04:13.240
给了一个服务ID，还有一个

00:04:11.770 --> 00:04:16.060
此接口的实现

00:04:13.240 --> 00:04:19.180
支持Cloud Foundry支持

00:04:16.060 --> 00:04:21.940
支持Netflix的kubernetes是

00:04:19.180 --> 00:04:24.340
尤里卡·阿帕奇 Zookeeper 叫她

00:04:21.940 --> 00:04:26.290
控制台，我的意思是你可能知道更多

00:04:24.340 --> 00:04:29.650
我忘了我们要走了

00:04:26.290 --> 00:04:31.870
前进并建立新的服务

00:04:29.650 --> 00:04:33.850
使用Spring的服务注册表

00:04:31.870 --> 00:04:35.320
这里的初始化程序称为Eureka 

00:04:33.850 --> 00:04:38.110
我只是要使其成为ravika服务器

00:04:35.320 --> 00:04:41.470
像这样，我们将点击生成，我们将

00:04:38.110 --> 00:04:46.150
在我们的IDE中打开它

00:04:41.470 --> 00:04:49.210
所以我们要说打开这个

00:04:46.150 --> 00:04:51.169
在这里使用我的小命令行脚本

00:04:49.210 --> 00:04:54.199
当然也一如既往

00:04:51.169 --> 00:04:55.849
打开项目，但我知道

00:04:54.199 --> 00:05:05.960
你可以用向导和潮汐

00:04:55.849 --> 00:05:07.039
就像你一样聪明

00:05:05.960 --> 00:05:17.360
第二好

00:05:07.039 --> 00:05:21.610
所以我要打开它了

00:05:17.360 --> 00:05:24.349
属性的应用谢谢和

00:05:21.610 --> 00:05:28.870
您想要Rika服务器应用程序

00:05:24.349 --> 00:05:32.719
云母服务器本身的好与坏

00:05:28.870 --> 00:05:35.060
非常好，我们的工作只是

00:05:32.719 --> 00:05:36.319
进行配置，以便在

00:05:35.060 --> 00:05:39.469
我们可以期待的标准地方

00:05:36.319 --> 00:05:41.539
在761找到不持有的东西

00:05:39.469 --> 00:05:44.120
注册自己，而不是获取

00:05:41.539 --> 00:05:47.360
基本上就是他自己的数据

00:05:44.120 --> 00:05:51.729
一旦我这样做，通常不会

00:05:47.360 --> 00:05:53.389
足够，但是我们在Java 11和

00:05:51.729 --> 00:05:55.339
实际上我什至不确定这是否会

00:05:53.389 --> 00:05:57.169
工作，我们将尝试它，但我们需要Java 11 

00:05:55.339 --> 00:05:59.360
我要用的地方是11 

00:05:57.169 --> 00:06:01.969
 Java 11正常工作，我是Davin 8 

00:05:59.360 --> 00:06:04.939
当然，大概是9和10但

00:06:01.969 --> 00:06:07.310
在约翰福音11章中，他们搬出了一些API 

00:06:04.939 --> 00:06:09.919
是Java EE的一部分，不是

00:06:07.310 --> 00:06:12.620
不再捆绑在核心JDK中

00:06:09.919 --> 00:06:15.080
总的来说，这是一件很棒的事情

00:06:12.620 --> 00:06:17.149
 JDK团队加快行动速度等等

00:06:15.080 --> 00:06:20.360
但与此同时，这意味着我们

00:06:17.149 --> 00:06:21.740
必须穿合适的捆绑罐

00:06:20.360 --> 00:06:23.089
手动，那没什么大不了的

00:06:21.740 --> 00:06:25.370
这就是依赖的本质

00:06:23.089 --> 00:06:27.409
暂时的管理

00:06:25.370 --> 00:06:30.649
至尊云照顾我们

00:06:27.409 --> 00:06:32.839
但我怀疑这肯定会解决

00:06:30.649 --> 00:06:35.569
时间，所以现在我要做的就是

00:06:32.839 --> 00:06:39.139
添加了Jax be API，在这里杰克讲

00:06:35.569 --> 00:06:42.289
或Jax是隐式回避的东西， 

00:06:39.139 --> 00:06:45.649
再次，这都是很好的提取

00:06:42.289 --> 00:06:48.800
进入像这样的属性

00:06:45.649 --> 00:06:50.569
版本可以替换所有非常好的

00:06:48.800 --> 00:06:52.639
所以你去那里，现在就是我可以

00:06:50.569 --> 00:06:55.689
一处改变现在让我们

00:06:52.639 --> 00:06:55.689
继续并开始

00:07:09.700 --> 00:07:15.400
好吧，如果有，那就在那里

00:07:12.730 --> 00:07:18.580
运行它可以使用，我们

00:07:15.400 --> 00:07:21.100
可以通过访问

00:07:18.580 --> 00:07:22.150
端口上已配置主机上的服务

00:07:21.100 --> 00:07:28.240
在这种情况下，哪个当然是

00:07:22.150 --> 00:07:30.130
 localhost 87-61，所以我们没有

00:07:28.240 --> 00:07:32.020
实例还没有什么都没有注册

00:07:30.130 --> 00:07:33.670
所以现在让我们继续构建一个简单的

00:07:32.020 --> 00:07:36.850
服务，我们将建立一个品牌

00:07:33.670 --> 00:07:38.710
该服务将要提供的新服务

00:07:36.850 --> 00:07:40.810
拥有需要的智慧

00:07:38.710 --> 00:07:42.460
向他注册

00:07:40.810 --> 00:07:44.890
注册表，所以我叫这个你知道

00:07:42.460 --> 00:07:47.680
想象它真的足够的服务，我们

00:07:44.890 --> 00:07:51.610
使用尤里卡支持，你一周吗

00:07:47.680 --> 00:07:53.440
客户支持weenies龙目岛和

00:07:51.610 --> 00:07:54.940
响应式网络支持，好的，我们要

00:07:53.440 --> 00:07:56.080
建立一个应用程序，这是另一个

00:07:54.940 --> 00:07:57.400
这种模式的优点是

00:07:56.080 --> 00:07:59.890
它适合于反应式编程

00:07:57.400 --> 00:08:02.080
实际上，这是一个很好的例子

00:07:59.890 --> 00:08:06.010
这两件事真的相互补充

00:08:02.080 --> 00:08:07.210
其他他们他们他们他们相乘

00:08:06.010 --> 00:08:09.400
好的，所以我们要继续

00:08:07.210 --> 00:08:14.430
点击生成，这会给我们一个

00:08:09.400 --> 00:08:23.230
这里的另一个项目会下载您一个

00:08:14.430 --> 00:08:24.490
服务下降，我们认为我们的服务是

00:08:23.230 --> 00:08:25.690
直截了当，我们不是你

00:08:24.490 --> 00:08:27.970
知道我们实际上不是在尝试测试

00:08:25.690 --> 00:08:31.270
我们可以写一个服务

00:08:27.970 --> 00:08:35.050
尝试测试的是，我们可以知道吗

00:08:31.270 --> 00:08:38.560
多次呼吁

00:08:35.050 --> 00:08:39.940
服务，因此服务本身就是

00:08:38.560 --> 00:08:42.100
它没有

00:08:39.940 --> 00:08:43.360
不必特别

00:08:42.100 --> 00:08:44.920
有趣的是，我们要做的是

00:08:43.360 --> 00:08:48.400
能够创造人造物的东西

00:08:44.920 --> 00:08:51.790
延迟将能够

00:08:48.400 --> 00:08:53.680
随机延长寿命

00:08:51.790 --> 00:08:56.830
一个请求，所以我们可以看到一个

00:08:53.680 --> 00:08:58.710
返回之前，让我们做

00:08:56.830 --> 00:09:01.840
我们在这里为我们服务

00:08:58.710 --> 00:09:02.980
应用程序，最简单的事情是什么

00:09:01.840 --> 00:09:05.500
我们可以做到，我想我们只想要一个

00:09:02.980 --> 00:09:07.150
端点反应性端点或不是

00:09:05.500 --> 00:09:08.200
知道我们只需要任何端点

00:09:07.150 --> 00:09:09.240
假设这部分不必是

00:09:08.200 --> 00:09:15.110
完全没有反应

00:09:09.240 --> 00:09:20.840
所以得到映射嗨

00:09:15.110 --> 00:09:22.700
串小麦和我们想做什么

00:09:20.840 --> 00:09:26.690
想拥有一个正确的 rest controller 

00:09:22.700 --> 00:09:29.690
这是一个 rest controller ，我们想要这个

00:09:26.690 --> 00:09:34.430
成为一个将具有

00:09:29.690 --> 00:09:35.900
延迟，我们的延迟将是我们想要的

00:09:34.430 --> 00:09:36.800
在这里有一点随机性

00:09:35.900 --> 00:09:39.770
所以我们要做的是

00:09:36.800 --> 00:09:44.420
说给我最长的两个随机

00:09:39.770 --> 00:09:48.350
数字还可以，我想我们不会

00:09:44.420 --> 00:10:02.650
想要在这里让我们看看虚无随机

00:09:48.350 --> 00:10:08.960
下一个很长一段时间随机

00:10:02.650 --> 00:10:12.040
我要乘这个倍

00:10:08.960 --> 00:10:19.190
秒数乘以一千

00:10:12.040 --> 00:10:23.390
几秒钟还可以，我们

00:10:19.190 --> 00:10:24.860
要一个人回来所以我们说

00:10:23.390 --> 00:10:26.330
好吧，看起来还不错

00:10:24.860 --> 00:10:29.590
对我来说很简单，所以我要

00:10:26.330 --> 00:10:32.900
说给我两个数字中最长的一个

00:10:29.590 --> 00:10:36.170
两个随机的持续时间

00:10:32.900 --> 00:10:38.300
这两个延迟中的任何一个都会导致

00:10:36.170 --> 00:10:40.190
最长我要用那个然后

00:10:38.300 --> 00:10:41.870
我要人为地睡觉

00:10:40.190 --> 00:10:44.090
是最不优雅的东西，但你

00:10:41.870 --> 00:10:45.770
知道它在这里和

00:10:44.090 --> 00:10:47.930
当然需要一个例外

00:10:45.770 --> 00:10:49.700
这是方法签名，然后

00:10:47.930 --> 00:10:53.830
终于做了所有的努力

00:10:49.700 --> 00:10:57.080
我要说屏幕信息等于

00:10:53.830 --> 00:11:00.490
你好，那个果冻看起来果冻，但不是

00:10:57.080 --> 00:11:00.490
那你好你好

00:11:01.480 --> 00:11:08.080
你知道比赛后

00:11:10.100 --> 00:11:16.860
女士好，那么我们只是搅动一下

00:11:14.130 --> 00:11:19.410
信息，这样我们将有能力

00:11:16.860 --> 00:11:21.750
看看服务多久了

00:11:19.410 --> 00:11:24.110
你知道等我们好还是多久

00:11:21.750 --> 00:11:27.360
我们不得不等待那个服务电话

00:11:24.110 --> 00:11:30.120
好吧，现在我们去了

00:11:27.360 --> 00:11:32.100
服务足够我想我们需要

00:11:30.120 --> 00:11:33.899
到我们需要的位置，所以我要运行此

00:11:32.100 --> 00:11:36.060
多次申请等等

00:11:33.899 --> 00:11:37.050
结果我要让它与众不同

00:11:36.060 --> 00:11:38.940
给它一些独特的

00:11:37.050 --> 00:11:40.800
配置，以便我可以运行

00:11:38.940 --> 00:11:44.310
多次申请并且没有

00:11:40.800 --> 00:11:46.500
它足了你所不知道的每一个

00:11:44.310 --> 00:11:48.720
实例彼此踩踏

00:11:46.500 --> 00:11:50.579
再次主持这不是什么大不了的

00:11:48.720 --> 00:11:52.800
不同的主机，但它变得更多

00:11:50.579 --> 00:11:54.839
在这样的演示场景中很有趣

00:11:52.800 --> 00:11:57.450
所以首先我要说我要你跑步

00:11:54.839 --> 00:11:59.250
在另一个端口0上，然后

00:11:57.450 --> 00:12:01.620
第二，我要给它起一个名字frança 

00:11:59.250 --> 00:12:03.120
应用程序名称等于服务，这是

00:12:01.620 --> 00:12:07.260
它将在其中注册的名称

00:12:03.120 --> 00:12:11.070
注册表我要给他身份证

00:12:07.260 --> 00:12:12.779
和我将要派生的ID 

00:12:11.070 --> 00:12:15.120
希望这个问题能够解决一次，所以我会

00:12:12.779 --> 00:12:18.360
只需将其提取到表中

00:12:15.120 --> 00:12:20.160
将使用您知道的伪属性

00:12:18.360 --> 00:12:25.640
一个内部非常有趣的属性

00:12:20.160 --> 00:12:28.579
 Spring 叫做随机点整数，这里

00:12:25.640 --> 00:12:32.730
我要提供一个范围

00:12:28.579 --> 00:12:37.890
 999，然后我将使用它来

00:12:32.730 --> 00:12:40.589
在这里创建您Iike instanceid好的

00:12:37.890 --> 00:12:42.779
是的，这将给我一个

00:12:40.589 --> 00:12:44.610
每个实例每个随机命名

00:12:42.779 --> 00:12:45.959
在注册表中注册的客户端

00:12:44.610 --> 00:12:47.519
基本上会有不同的标签

00:12:45.959 --> 00:12:49.199
它被分配给它，我们要

00:12:47.519 --> 00:12:51.360
一次建立那个标签

00:12:49.199 --> 00:12:55.709
在整个生命周期中保持一致

00:12:51.360 --> 00:12:57.390
这项服务好了，我们不必做

00:12:55.709 --> 00:12:58.680
其他任何事情，因为默认情况下正确

00:12:57.390 --> 00:13:00.180
您的Miko在默认端口上运行

00:12:58.680 --> 00:13:01.740
它会使用 Spring 的云

00:13:00.180 --> 00:13:07.769
发现客户端抽象

00:13:01.740 --> 00:13:10.079
实现与之交谈，是的

00:13:07.769 --> 00:13:11.190
让我们继续前进，哦，我们必须做

00:13:10.079 --> 00:13:13.230
 telogen中还有另一件事

00:13:11.190 --> 00:13:19.670
关闭仅单个实例

00:13:13.230 --> 00:13:19.670
申请并继续前进，让我们看看成功吧

00:13:19.960 --> 00:13:55.390
一个可以，两个可以，并且很好

00:13:47.709 --> 00:13:58.209
这只是第三次，如果我们

00:13:55.390 --> 00:13:59.740
去我们的注册表，我们看到我们有三个

00:13:58.209 --> 00:14:01.660
这里的服务实例

00:13:59.740 --> 00:14:04.959
正确的是它说三个

00:14:01.660 --> 00:14:06.760
实例，它们被称为服务

00:14:04.959 --> 00:14:09.100
七一一五服务三九

00:14:06.760 --> 00:14:10.839
三八九六和服务七

00:14:09.100 --> 00:14:12.700
一四八好吧，现在他们是

00:14:10.839 --> 00:14:14.080
如果我可以访问，它们是可见的

00:14:12.700 --> 00:14:16.209
指向其他服务

00:14:14.080 --> 00:14:17.890
我可以连接到服务注册表的节点

00:14:16.209 --> 00:14:20.110
以编程方式询问多少

00:14:17.890 --> 00:14:22.089
实例在那里

00:14:20.110 --> 00:14:24.010
服务我不回三服务

00:14:22.089 --> 00:14:27.600
实例，这就是我们要做的

00:14:24.010 --> 00:14:29.800
现在与另一位客户与我们交谈

00:14:27.600 --> 00:14:32.230
通过搜索者提供服务

00:14:29.800 --> 00:14:34.720
通过服务解析实例

00:14:32.230 --> 00:14:37.390
注册表现在这是这也是

00:14:34.720 --> 00:14:39.670
将像以前一样使用

00:14:37.390 --> 00:14:41.980
注册表支持，因此尤里卡发现

00:14:39.670 --> 00:14:44.920
将使用龙目岛，我们使用反应堆

00:14:41.980 --> 00:14:49.450
支持执行器只是因为

00:14:44.920 --> 00:14:52.570
好的清洁云卫生对，我

00:14:49.450 --> 00:14:56.560
认为那是我做不到的

00:14:52.570 --> 00:14:58.810
想象我们还需要什么

00:14:56.560 --> 00:15:02.260
反应网得到尤里卡得到了执行器

00:14:58.810 --> 00:15:03.700
我们有腰部支撑和反应器

00:15:02.260 --> 00:15:11.040
被自动带入，所以我会

00:15:03.700 --> 00:15:11.040
打客户它吉米，你一个哦，我的

00:15:17.310 --> 00:15:24.550
好吧，现在和我们需要的一样

00:15:23.110 --> 00:15:26.710
该应用程序启动，它是

00:15:24.550 --> 00:15:32.070
假设我们应该选择其他

00:15:26.710 --> 00:15:32.070
港口以防万一

00:15:32.140 --> 00:15:38.140
我们的应用程序将是

00:15:35.950 --> 00:15:41.500
 REST API本身将使

00:15:38.140 --> 00:15:43.810
反应性Web客户端调用到另一个节点

00:15:41.500 --> 00:15:49.450
所以我们会说这将是一个

00:15:43.810 --> 00:15:55.770
第10类dig lesson2文件夹

00:15:49.450 --> 00:15:58.089
我们会说 rest controller 和我们的

00:15:55.770 --> 00:16:01.330
这就是我们想要的想法

00:15:58.089 --> 00:16:04.230
得到正确的信息，所以我们将在

00:16:01.330 --> 00:16:08.620
点这里返回一个字符串问候

00:16:04.230 --> 00:16:10.450
为了打电话，你知道

00:16:08.620 --> 00:16:14.890
一些很好的情况，虽然

00:16:10.450 --> 00:16:16.930
客户会打电话给您套期保值

00:16:14.890 --> 00:16:19.510
知道那样，然后使

00:16:16.930 --> 00:16:21.880
那个电话我们需要一个反应式的网络客户端

00:16:19.510 --> 00:16:24.910
这是一个有趣的HTTP客户端

00:16:21.880 --> 00:16:26.950
框架5或更高版本，它是

00:16:24.910 --> 00:16:29.980
反应性的，因此不会阻止客户端

00:16:26.950 --> 00:16:31.180
客户端线程（如果可能的话） 

00:16:29.980 --> 00:16:33.310
我们需要实例化，我们需要

00:16:31.180 --> 00:16:34.650
工厂的一个实例，所以我们创建

00:16:33.310 --> 00:16:39.040
网络客户端

00:16:34.650 --> 00:16:43.570
 bean 在这里打开Web客户端生成器

00:16:39.040 --> 00:16:44.770
现在建立所有这不在

00:16:43.570 --> 00:16:46.920
本身就足够了，我们实际上需要

00:16:44.770 --> 00:16:49.030
配置一个可以完成工作的过滤器

00:16:46.920 --> 00:16:51.220
做对冲，让我们看看

00:16:49.030 --> 00:16:57.459
天真的版本，没有套期保值的外观

00:16:51.220 --> 00:17:02.260
像小圆点URI正斜杠

00:16:57.459 --> 00:17:03.520
服务/ pi好的，然后我们将

00:17:02.260 --> 00:17:06.220
说我们检索返回的数据

00:17:03.520 --> 00:17:08.829
并把它变成类型的有效载荷

00:17:06.220 --> 00:17:10.390
该类中的类字符串相当

00:17:08.829 --> 00:17:11.770
这实际上会让我们假设

00:17:10.390 --> 00:17:14.110
这是一个有效的主机名

00:17:11.770 --> 00:17:15.429
工作，有些人可能知道你

00:17:14.110 --> 00:17:18.280
甚至可以做到

00:17:15.429 --> 00:17:19.780
 Spring Cloud中的负载平衡注释

00:17:18.280 --> 00:17:23.199
而有效的方式就是您说网络

00:17:19.780 --> 00:17:25.689
客户点生成器生成器，在此

00:17:23.199 --> 00:17:27.190
如果你实际上没有建立

00:17:25.689 --> 00:17:28.510
建立你自己

00:17:27.190 --> 00:17:30.580
您自己使用Builder的网站

00:17:28.510 --> 00:17:32.500
然后您继续自定义它，但是

00:17:30.580 --> 00:17:35.740
基本上Spring Cloud会自动

00:17:32.500 --> 00:17:38.500
配置您要构建的构建器实例

00:17:35.740 --> 00:17:39.880
知道我已经准备好为您构建

00:17:38.500 --> 00:17:42.520
在这里做或进一步定制

00:17:39.880 --> 00:17:45.790
但在这种情况下，因为我在

00:17:42.520 --> 00:17:47.020
负载均衡我已经告诉Spring Cloud 

00:17:45.790 --> 00:17:49.750
创建Web构建器Web客户端

00:17:47.020 --> 00:17:52.210
我的构建器并配置负载

00:17:49.750 --> 00:17:54.610
平衡过滤器交换过滤器

00:17:52.210 --> 00:17:56.680
并处理该预

00:17:54.610 --> 00:17:59.320
处理我发出的每个HTTP请求

00:17:56.680 --> 00:18:01.120
在这种情况下，它将被提取

00:17:59.320 --> 00:18:02.530
找出主机名

00:18:01.120 --> 00:18:04.900
它会将其视为

00:18:02.530 --> 00:18:06.100
服务注册表中的服务ID和

00:18:04.900 --> 00:18:08.350
要和服务注册中心谈谈

00:18:06.100 --> 00:18:11.320
使用发现客户端抽象

00:18:08.350 --> 00:18:13.630
所以这就是我们想要的，但是我们

00:18:11.320 --> 00:18:15.700
想要那种避险行为，所以这

00:18:13.630 --> 00:18:18.760
到底是不是我们想要的一样

00:18:15.700 --> 00:18:19.960
事情，所以你知道记住这一点

00:18:18.760 --> 00:18:22.120
还有我今天要告诉你的

00:18:19.960 --> 00:18:24.430
可以提取到这样的过滤器中

00:18:22.120 --> 00:18:26.050
你能知道创建音频配置吗

00:18:24.430 --> 00:18:27.820
你知道加树篱之类的东西

00:18:26.050 --> 00:18:29.890
像那样，我不是，但是那肯定是

00:18:27.820 --> 00:18:31.870
下一个视频的练习者

00:18:29.890 --> 00:18:33.310
知道你知道，但与此同时我们会

00:18:31.870 --> 00:18:37.270
自己建造它，所以我们有

00:18:33.310 --> 00:18:39.370
完全可以自定义的能力

00:18:37.270 --> 00:18:41.320
就是这个，现在我们要做的是

00:18:39.370 --> 00:18:43.390
完全过滤，所以我说了

00:18:41.320 --> 00:18:47.700
这项工作的实质将在

00:18:43.390 --> 00:18:52.840
过滤器，但我要称呼树篱

00:18:47.700 --> 00:18:54.940
交换过滤器功能这是要去的

00:18:52.840 --> 00:18:57.820
实现交换过滤器

00:18:54.940 --> 00:19:00.940
履行 Spring A类合同

00:18:57.820 --> 00:19:06.130
 Spring 五学期还好

00:19:00.940 --> 00:19:09.340
而且您知道工作相当简单

00:19:06.130 --> 00:19:11.800
我们想要UM实施过滤器

00:19:09.340 --> 00:19:13.150
方法这里过滤器是唯一的

00:19:11.800 --> 00:19:15.010
那是必需的，其余的是

00:19:13.150 --> 00:19:17.500
实际上是默认功能，因此您可以

00:19:15.010 --> 00:19:20.740
看到它说默认，然后默认

00:19:17.500 --> 00:19:24.460
应用等我们可以做到，因为这

00:19:20.740 --> 00:19:27.820
 API假定Spring 框架为5， 

00:19:24.460 --> 00:19:32.650
假定Java 8并且假定默认

00:19:27.820 --> 00:19:36.550
方法还可以，所以我们现在有一个过滤器

00:19:32.650 --> 00:19:39.640
这将有机会

00:19:36.550 --> 00:19:41.320
处理请求，然后处理

00:19:39.640 --> 00:19:43.389
转发给下一个过滤器

00:19:41.320 --> 00:19:46.450
如果这看起来像

00:19:43.389 --> 00:19:47.830
 servlet过滤器API很好，现在可以了

00:19:46.450 --> 00:19:49.149
应该对什么有一个很好的主意

00:19:47.830 --> 00:19:50.409
发生在这里，我们实际上有一个你

00:19:49.149 --> 00:19:54.070
有一系列不同的过滤器

00:19:50.409 --> 00:19:55.840
将在这里发挥作用，我们

00:19:54.070 --> 00:19:57.970
想要使用它们来处理此请求

00:19:55.840 --> 00:20:00.610
我要做很多相同的工作

00:19:57.970 --> 00:20:01.990
负载弹跳器更换过滤器

00:20:00.610 --> 00:20:03.070
函数用Hat加载一个

00:20:01.990 --> 00:20:05.289
平衡，所以我们要做很多

00:20:03.070 --> 00:20:07.570
相同的工作，因为我们毕竟需要

00:20:05.289 --> 00:20:10.179
通过DNS解决这个问题，我很抱歉

00:20:07.570 --> 00:20:12.880
服务注册表，但我们需要做

00:20:10.179 --> 00:20:14.679
因此，鉴于这些选择，我们需要

00:20:12.880 --> 00:20:17.470
挑选一个最先回来的

00:20:14.679 --> 00:20:21.009
这是一个不同的目标，不是吗？ 

00:20:17.470 --> 00:20:23.879
一点点，所以我们我们的交流

00:20:21.009 --> 00:20:27.850
过滤器功能将取决于

00:20:23.879 --> 00:20:33.820
发现客户端Spring Cloud发现

00:20:27.850 --> 00:20:34.840
客户将取决于其他我们

00:20:33.820 --> 00:20:37.809
需要我猜我们需要一个负载均衡器

00:20:34.840 --> 00:20:39.399
客户端，这是负载均衡器客户端

00:20:37.809 --> 00:20:41.440
 Spring 的云是用来

00:20:39.399 --> 00:20:43.929
将最新的默认值更改为ribon ribon 

00:20:41.440 --> 00:20:45.549
也是客户端负载均衡器

00:20:43.929 --> 00:20:46.840
关于我的Netflix但这个负载

00:20:45.549 --> 00:20:48.940
下行程线使其适应

00:20:46.840 --> 00:20:51.340
不只与Netflix合作

00:20:48.940 --> 00:20:53.500
类型和Netflix项目（例如Netflix） 

00:20:51.340 --> 00:20:56.860
尤里卡和我想我们去了一些

00:20:53.500 --> 00:21:00.669
你的定义知道多少次尝试

00:20:56.860 --> 00:21:03.789
我们要制造然后最大

00:21:00.669 --> 00:21:09.700
尝试正确，所以我们想

00:21:03.789 --> 00:21:11.019
打了三个电话，但你不知道

00:21:09.700 --> 00:21:14.679
工作，所以当我继续时你想逃跑

00:21:11.019 --> 00:21:16.000
尝试直到最大okay okay这样

00:21:14.679 --> 00:21:18.370
我们去那里，所以这是三个变量

00:21:16.000 --> 00:21:20.500
是对不起是四个参数

00:21:18.370 --> 00:21:22.659
好的，这些是构造函数参数

00:21:20.500 --> 00:21:24.610
当然你可以想象这些

00:21:22.659 --> 00:21:25.889
将是配置值或

00:21:24.610 --> 00:21:28.960
像是由

00:21:25.889 --> 00:21:33.570
我们的配置属性

00:21:28.960 --> 00:21:37.539
目的是我们要说我们想要

00:21:33.570 --> 00:21:39.340
最大尝试次数为尝试次数

00:21:37.539 --> 00:21:45.100
两个还好

00:21:39.340 --> 00:21:47.379
和你自己的尝试

00:21:45.100 --> 00:21:48.789
我想我想这甚至都没有

00:21:47.379 --> 00:21:50.679
需要在这里定义，我们可以使

00:21:48.789 --> 00:21:53.200
现在更简单，您可以私有化

00:21:50.679 --> 00:21:54.570
事情事后让您满意

00:21:53.200 --> 00:21:57.120
让我们保持简单

00:21:54.570 --> 00:21:58.710
好吧，我们要使用负载平衡器

00:21:57.120 --> 00:22:01.789
使用发现客户端时的客户端

00:21:58.710 --> 00:22:06.350
我们可以使用尝试然后

00:22:01.789 --> 00:22:08.549
那么我们确实需要一些默认值

00:22:06.350 --> 00:22:10.799
配置，所以我想，我想

00:22:08.549 --> 00:22:12.659
我有一个单独的构造函数

00:22:10.799 --> 00:22:15.929
只需要使用组件扫描

00:22:12.659 --> 00:22:18.179
告诉Spring Cloud如何解决这个问题

00:22:15.929 --> 00:22:22.529
这种依赖，我想为此

00:22:18.179 --> 00:22:27.019
我将只使用一个负载平衡器客户端， 

00:22:22.529 --> 00:22:31.950
我发现将是CTC的客户

00:22:27.019 --> 00:22:35.399
我们只是假设您给了我们一个

00:22:31.950 --> 00:22:38.190
假设其默认值为3 

00:22:35.399 --> 00:22:40.379
因为这就是我们在

00:22:38.190 --> 00:22:42.269
机器现在不行，所以

00:22:40.379 --> 00:22:44.669
表示很好，所以我们现在就知道了

00:22:42.269 --> 00:22:46.440
现在，对于实际工作来说， 

00:22:44.669 --> 00:22:47.610
在其中工作，我将其与空气一起使用

00:22:46.440 --> 00:22:49.200
在这里引用，因为它没有那么大

00:22:47.610 --> 00:22:51.960
处理我们要做的是

00:22:49.200 --> 00:22:55.590
说当请求进入想要

00:22:51.960 --> 00:22:58.710
获取原始URI写原始URI 

00:22:55.590 --> 00:23:00.570
来自java.net的请求中

00:22:58.710 --> 00:23:03.240
该请求当然在URL上

00:23:00.570 --> 00:23:05.639
本身，然后从那里我们想要

00:23:03.240 --> 00:23:08.250
获取我认为的字符串服务ID 

00:23:05.639 --> 00:23:11.940
这将是原始URI获取

00:23:08.250 --> 00:23:16.759
主机，然后从那里我们想要得到

00:23:11.940 --> 00:23:16.759
集合的服务实例列表

00:23:16.850 --> 00:23:25.860
与此服务ID相匹配的服务，以及

00:23:21.720 --> 00:23:30.629
我们使用发现客户端来做到这一点

00:23:25.860 --> 00:23:32.669
获取服务ID的实例好

00:23:30.629 --> 00:23:37.669
没关系，我在那里忘记了足够的空间

00:23:32.669 --> 00:23:41.789
好，然后从那里算什么

00:23:37.669 --> 00:23:44.309
所以我们要说为什么我们不想

00:23:41.789 --> 00:23:46.379
在发起多个不同的通话

00:23:44.309 --> 00:23:49.350
好的，所以我们需要

00:23:46.379 --> 00:23:50.789
存放每艘发射船

00:23:49.350 --> 00:23:52.019
基本上每种方式你知道什么时候

00:23:50.789 --> 00:23:54.269
发射了一堆船到深夜

00:23:52.019 --> 00:23:56.549
基本上，每艘船都会出去

00:23:54.269 --> 00:24:00.019
提出要求，然后再回来找我们

00:23:56.549 --> 00:24:04.100
一切先回来都会保持

00:24:00.019 --> 00:24:04.100
所以新的哈希图

00:24:04.430 --> 00:24:09.260
你知道我刚刚意识到的

00:24:07.400 --> 00:24:12.530
因为我们要运行这个

00:24:09.260 --> 00:24:14.060
我们要推出我要

00:24:12.530 --> 00:24:15.800
要求我们只会得到第一个

00:24:14.060 --> 00:24:17.120
一个回来了，所以我们不会

00:24:15.800 --> 00:24:19.100
看看其他人花了多长时间，所以我们

00:24:17.120 --> 00:24:21.230
需要在这里实际宣布

00:24:19.100 --> 00:24:24.080
我第二次建立的服务

00:24:21.230 --> 00:24:27.860
让我们回到该服务并进行

00:24:24.080 --> 00:24:38.260
确保我们启动或注销您知道的

00:24:27.860 --> 00:24:38.260
这个消息好再见

00:24:39.860 --> 00:24:42.760
再见

00:24:45.960 --> 00:24:51.679
好吧，我们在这里使用龙目岛

00:25:00.679 --> 00:25:03.679
信息

00:25:08.760 --> 00:25:16.330
已经在转弯，所以有我们的信息

00:25:15.070 --> 00:25:17.980
好的，这样我们就可以在

00:25:16.330 --> 00:25:20.620
控制台，所以我们会看到可能

00:25:17.980 --> 00:25:21.940
可以说我们没有走这条路

00:25:20.620 --> 00:25:23.110
现在不需要运行这些，让我们

00:25:21.940 --> 00:25:23.770
只需回到我们的代码，我们将阅读

00:25:23.110 --> 00:25:26.080
他们在一秒钟内

00:25:23.770 --> 00:25:29.710
好吧，现在我们有一张地图可以存储

00:25:26.080 --> 00:25:33.250
所有不同的在飞行中发射

00:25:29.710 --> 00:25:37.570
请求，我们要说的是

00:25:33.250 --> 00:25:42.370
地图的尺寸​​小于此起点

00:25:37.570 --> 00:25:49.870
尝试和计数器小于

00:25:42.370 --> 00:25:51.730
这个最大尝试，然后我们要加载

00:25:49.870 --> 00:25:54.520
使用负载均衡器进行均衡

00:25:51.730 --> 00:25:58.210
客户，我要选择

00:25:54.520 --> 00:25:59.920
在服务ID中，这将给

00:25:58.210 --> 00:26:07.030
我们返回一个服务实例，然后从

00:25:59.920 --> 00:26:15.040
在那里我们想要获取的URI 

00:26:07.030 --> 00:26:17.950
实例lb点URI到ASCII字符串和

00:26:15.040 --> 00:26:19.180
然后从那里我们要确保

00:26:17.950 --> 00:26:23.490
那我们还没看过

00:26:19.180 --> 00:26:27.400
在此之前，如果不发货，码头包含钥匙

00:26:23.490 --> 00:26:32.740
 ASCII字符串（如果尚未存在） 

00:26:27.400 --> 00:26:33.910
那我们要说的是舰船，而我

00:26:32.740 --> 00:26:37.960
实际上我想我们可以完成

00:26:33.910 --> 00:26:39.520
而是吧，但这需要

00:26:37.960 --> 00:26:40.870
我们实际计算结果

00:26:39.520 --> 00:26:42.970
我不想这么做，所以我们知道

00:26:40.870 --> 00:26:44.140
要避免我想我们可以

00:26:42.970 --> 00:26:46.540
做到这一点实际上现在将有一个

00:26:44.140 --> 00:26:48.970
更容易-是的，让我们尝试一下，让我们

00:26:46.540 --> 00:26:52.060
让我们这样做，所以我

00:26:48.970 --> 00:26:55.960
要说计算，如果不存在，那是

00:26:52.060 --> 00:26:59.110
将是ASCII字符串，我们将

00:26:55.960 --> 00:27:01.540
说如果该字符串不存在，那么

00:26:59.110 --> 00:27:04.420
用给我们钥匙，我们用钥匙

00:27:01.540 --> 00:27:05.620
以获得必须的价值

00:27:04.420 --> 00:27:07.750
存储在这种情况下要去的地方

00:27:05.620 --> 00:27:08.980
成为克莱尔回应的座右铭，因此

00:27:07.750 --> 00:27:10.900
那就是我们真正要去的地方

00:27:08.980 --> 00:27:12.730
实际发出此请求的电话

00:27:10.900 --> 00:27:16.510
让我们将其提取出来

00:27:12.730 --> 00:27:18.960
客户的座右铭

00:27:16.510 --> 00:27:18.960
响应

00:27:21.169 --> 00:27:28.200
大量，我们将在

00:27:25.529 --> 00:27:30.799
第二，那我该怎么办

00:27:28.200 --> 00:27:33.659
猜猜这会说很多

00:27:30.799 --> 00:27:34.259
好吧，看起来很简单

00:27:33.659 --> 00:27:44.090
不是吗

00:27:34.259 --> 00:27:46.350
所以不好，我们实际上需要

00:27:44.090 --> 00:27:49.409
参数化我们不那么好吧

00:27:46.350 --> 00:27:50.909
在发生这种情况时，您知道

00:27:49.409 --> 00:27:53.009
完成后将会发生

00:27:50.909 --> 00:27:54.149
一堆带有客户响应的地图

00:27:53.009 --> 00:27:55.799
他们正确，我们将在地图上

00:27:54.149 --> 00:27:57.480
一堆客户反应我的鼻子和

00:27:55.799 --> 00:27:59.970
现在，发布商对这些有反应

00:27:57.480 --> 00:28:01.889
类型尚未执行，正确的是

00:27:59.970 --> 00:28:04.320
整个要点是

00:28:01.889 --> 00:28:06.210
还没有执行，原因

00:28:04.320 --> 00:28:11.749
有趣的是，因为他们只

00:28:06.210 --> 00:28:14.429
一旦他们在那里就被执行

00:28:11.749 --> 00:28:16.169
订阅了他们的耐力

00:28:14.429 --> 00:28:17.789
就像加拿大的Java 8流一样

00:28:16.169 --> 00:28:21.059
必须激活它们，你必须

00:28:17.789 --> 00:28:24.600
执行我们必须订阅

00:28:21.059 --> 00:28:26.580
给他们排干好吧，我不确定

00:28:24.600 --> 00:28:27.299
我需要看到它，也许我们会离开它

00:28:26.580 --> 00:28:29.519
那里

00:28:27.299 --> 00:28:30.629
然后就知道了，基本上我们可以

00:28:29.519 --> 00:28:32.580
创建任意数量的这些，但是

00:28:30.629 --> 00:28:34.529
我们定义的只是管道而不是

00:28:32.580 --> 00:28:36.330
通过电线的实际要求，我们可以

00:28:34.529 --> 00:28:38.519
当我们提出要求时，因为

00:28:36.330 --> 00:28:40.379
反应性的调度程序可以调度

00:28:38.519 --> 00:28:42.600
这些东西并发，这是非常

00:28:40.379 --> 00:28:45.440
方便，好的，现在就提出要求

00:28:42.600 --> 00:28:50.700
本身用于调用请求

00:28:45.440 --> 00:28:53.119
我们需要我们需要服务

00:28:50.700 --> 00:29:00.299
实例，我认为这似乎很有用

00:28:53.119 --> 00:29:03.330
所以我们的实例是LV，我们

00:29:00.299 --> 00:29:04.830
想拥有原始URI，我们

00:29:03.330 --> 00:29:06.169
想要请求，我们想要

00:29:04.830 --> 00:29:10.590
在链中有下一个

00:29:06.169 --> 00:29:15.679
好吧，让我们将签名更改为

00:29:10.590 --> 00:29:20.879
容纳这个服务实例好

00:29:15.679 --> 00:29:24.119
客户现在就要求我们

00:29:20.879 --> 00:29:26.149
将要调用它，这将在

00:29:24.119 --> 00:29:26.149
转

00:29:27.170 --> 00:29:32.810
进而需要我们实际

00:29:31.460 --> 00:29:33.860
打电话，我们该怎么做，让我们

00:29:32.810 --> 00:29:38.960
考虑一下，我们已经提供了服务

00:29:33.860 --> 00:29:40.010
实例，我们有URI，所以我们只是

00:29:38.960 --> 00:29:41.480
需要实际做出正确的请求

00:29:40.010 --> 00:29:42.790
这在这段代码中或多或少

00:29:41.480 --> 00:29:45.770
确切地说，您会在

00:29:42.790 --> 00:29:48.200
负载均衡交换过滤功能

00:29:45.770 --> 00:29:50.720
以及，所以你知道我们要去做

00:29:48.200 --> 00:29:52.090
所以一旦URI正确就等于

00:29:50.720 --> 00:29:53.990
客户获得的点负载平衡

00:29:52.090 --> 00:29:56.480
重建你的我，那会是什么

00:29:53.990 --> 00:29:57.860
要做的是提供服务

00:29:56.480 --> 00:30:01.310
我们选择并给出的实例

00:29:57.860 --> 00:30:03.950
您知道原始的原始URI 

00:30:01.310 --> 00:30:05.450
你我说你知道HTTP要求

00:30:03.950 --> 00:30:07.340
这样的服务将

00:30:05.450 --> 00:30:09.470
将其替换为

00:30:07.340 --> 00:30:13.580
服务实例（如果服务实例具有） 

00:30:09.470 --> 00:30:14.780
主机和端口以及方案等

00:30:13.580 --> 00:30:16.070
你我，所以很好，就是

00:30:14.780 --> 00:30:17.840
要为我们非常处理该网址

00:30:16.070 --> 00:30:20.200
很好，它将建立一个新的URI 

00:30:17.840 --> 00:30:22.430
使用Java net容易做到

00:30:20.200 --> 00:30:26.840
 URI，因为构建一个

00:30:22.430 --> 00:30:28.640
以这种方式奖励是的，所以客户要求我们

00:30:26.840 --> 00:30:30.830
这将是新的要求不是

00:30:28.640 --> 00:30:34.720
所以这将是新的要求， 

00:30:30.830 --> 00:30:39.980
我会说客户请求点创建

00:30:34.720 --> 00:30:40.310
请求点方法以及我们还有什么

00:30:39.980 --> 00:30:48.950
想

00:30:40.310 --> 00:30:53.750
哦，我们已经需要网址了，我们会说

00:30:48.950 --> 00:30:56.840
标头，我们要说一次伊洛娜

00:30:53.750 --> 00:31:01.010
我们要做的就是复制所有

00:30:56.840 --> 00:31:04.630
从旧的东西到新的东西

00:31:01.010 --> 00:31:08.090
一种权利，所以头已完成，所有

00:31:04.630 --> 00:31:15.200
标头正确，但我想我们会做

00:31:08.090 --> 00:31:21.230
饼干的C点在这里也是一样

00:31:15.200 --> 00:31:23.710
是的，对，就是

00:31:21.230 --> 00:31:23.710
请求

00:31:25.220 --> 00:31:36.749
要求荷兰饼干，并要求

00:31:29.850 --> 00:31:39.840
标头还可以，请致电H 

00:31:36.749 --> 00:31:42.059
更容易解析，所以标头是

00:31:39.840 --> 00:31:46.470
对于每个标题H和每个设置的cookie 

00:31:42.059 --> 00:31:48.979
看到你知道他们是否可以解决这个问题

00:31:46.470 --> 00:31:50.940
从请求本身添加东西

00:31:48.979 --> 00:31:53.340
然后我们将拥有属性

00:31:50.940 --> 00:31:55.080
请求正确的属性，所以我必须

00:31:53.340 --> 00:31:57.149
查看它到地铁我保持自动

00:31:55.080 --> 00:32:02.340
竞争那些

00:31:57.149 --> 00:32:06.889
这些东西的单数形式所以我

00:32:02.340 --> 00:32:11.970
放所有，这将是

00:32:06.889 --> 00:32:13.499
请求点属性以及其他功能

00:32:11.970 --> 00:32:21.529
我们需要不确定我是否就是这样

00:32:13.499 --> 00:32:24.450
身体会要求点身体好，并且

00:32:21.529 --> 00:32:25.859
看起来它是一个相当不错的克隆

00:32:24.450 --> 00:32:30.269
希望我没有错过

00:32:25.859 --> 00:32:33.479
重要的事情，但是你知道我们会的

00:32:30.269 --> 00:32:35.099
看到我的感觉，所以接下来我们

00:32:33.479 --> 00:32:38.669
终于完成了，让我们调用

00:32:35.099 --> 00:32:41.609
接下来你知道下游的东西

00:32:38.669 --> 00:32:43.619
链交换新请求，因此

00:32:41.609 --> 00:32:45.629
过滤器的下游部分将看到

00:32:43.619 --> 00:32:47.129
新的机构，您知道的新要求

00:32:45.629 --> 00:32:49.049
即使在

00:32:47.129 --> 00:32:51.119
过滤器，甚至Java servlet过滤器

00:32:49.049 --> 00:32:52.559
 API的东西，但这当然是

00:32:51.119 --> 00:32:54.179
客户端而不是服务器端，所以

00:32:52.559 --> 00:32:56.249
以相同的方式工作，但绝不是

00:32:54.179 --> 00:32:57.419
同样是异步的我

00:32:56.249 --> 00:32:58.979
无阻塞和反应性

00:32:57.419 --> 00:33:01.019
没有涉及该API的服务器

00:32:58.979 --> 00:33:02.909
在这里，当然是在

00:33:01.019 --> 00:33:05.129
服务器的客户端，所以我要去做

00:33:02.909 --> 00:33:09.029
终于我要说我要

00:33:05.129 --> 00:33:10.679
宣布我所拥有的每艘发射船

00:33:09.029 --> 00:33:13.320
要通过注销来做到这一点，所以我们

00:33:10.679 --> 00:33:14.580
有某种能力看

00:33:13.320 --> 00:33:18.989
盘子和盘子上发生了什么

00:33:14.580 --> 00:33:27.259
服务器，我说这个点日志就像

00:33:18.989 --> 00:33:29.110
登录，然后我们说启动新请求

00:33:27.259 --> 00:33:33.180
 URI 

00:33:29.110 --> 00:33:36.700
好吧，看起来不错，看起来

00:33:33.180 --> 00:33:41.200
我想这很简单

00:33:36.700 --> 00:33:44.370
终于是中间橡胶相遇的地方

00:33:41.200 --> 00:33:46.810
正确的道路，所以当您说通量点

00:33:44.370 --> 00:33:49.960
首先很方便给它一个

00:33:46.810 --> 00:33:51.280
事物发布者订阅所有内容

00:33:49.960 --> 00:33:53.950
他们在第一个是你知道的

00:33:51.280 --> 00:33:55.960
完成我们确定正确的，所以有

00:33:53.950 --> 00:33:57.490
如果这是算法的魔力， 

00:33:55.960 --> 00:34:00.970
你好，仅此而已

00:33:57.490 --> 00:34:02.320
正确的部分，然后我们就

00:34:00.970 --> 00:34:04.720
要说给我第一个

00:34:02.320 --> 00:34:07.240
或非常简单的空模型

00:34:04.720 --> 00:34:08.470
无法简单确定，所以我们

00:34:07.240 --> 00:34:09.370
使用地图真的只是为了确保

00:34:08.470 --> 00:34:11.260
我们有任何没有

00:34:09.370 --> 00:34:12.790
重复，这就是我们使用

00:34:11.260 --> 00:34:15.370
地图，但是我们扔掉钥匙

00:34:12.790 --> 00:34:17.320
在我们完成契约之后

00:34:15.370 --> 00:34:22.000
出版商名单或馆藏

00:34:17.320 --> 00:34:24.490
出版商的集合，然后我们

00:34:22.000 --> 00:34:24.970
用它来找出哪一个来

00:34:24.490 --> 00:34:27.850
先回

00:34:24.970 --> 00:34:29.710
好的，所以很简单，不是

00:34:27.850 --> 00:34:31.480
很大，我的意思不是很多代码

00:34:29.710 --> 00:34:34.590
有很多颜色，但是我

00:34:31.480 --> 00:34:36.940
认为您知道构造函数的变量

00:34:34.590 --> 00:34:38.170
知道他们的建设者真的不是

00:34:36.940 --> 00:34:41.890
我要说的是很多代码

00:34:38.170 --> 00:34:48.700
这是大多数要求的62 

00:34:41.890 --> 00:34:51.040
到77所以15然后是85 

00:34:48.700 --> 00:34:53.880
 96，所以11对，所以不是很多

00:34:51.040 --> 00:34:56.310
代码正确，更不用说我了

00:34:53.880 --> 00:34:58.330
猜猜我不需要这个，我想知道为什么我

00:34:56.310 --> 00:35:00.520
会以为我会与

00:34:58.330 --> 00:35:01.960
我想知道那是否很重要

00:35:00.520 --> 00:35:03.130
有一些意图，我的意思是我们是我们

00:35:01.960 --> 00:35:04.300
一起写这段代码

00:35:03.130 --> 00:35:08.680
我不记得为什么写信的朋友

00:35:04.300 --> 00:35:12.430
你觉得那可能

00:35:08.680 --> 00:35:14.140
有用哦，你知道你知道我们

00:35:12.430 --> 00:35:18.940
本来可以做的让我们离开

00:35:14.140 --> 00:35:23.380
在这里，请确保您没有

00:35:18.940 --> 00:35:27.430
为此，但是我们要

00:35:23.380 --> 00:35:32.010
确保存在以下情况

00:35:27.430 --> 00:35:32.010
这项服务，否则我们将成为

00:35:32.310 --> 00:35:40.220
永远不会得到我们想要的东西，所以

00:35:34.930 --> 00:35:51.560
至少必须有这个提示

00:35:40.220 --> 00:35:53.610
服务实例，所以技术人员还可以

00:35:51.560 --> 00:35:55.110
所以有我们，我们要做

00:35:53.610 --> 00:35:56.610
在尝试之前，请确保我们知道

00:35:55.110 --> 00:35:58.860
负载平衡以及所有这些东西

00:35:56.610 --> 00:36:00.480
如果您要我们给三个不同的人打电话

00:35:58.860 --> 00:36:01.740
有三个不同的实例

00:36:00.480 --> 00:36:04.140
实例，因为那将是

00:36:01.740 --> 00:36:06.090
发生在下一行或下一行

00:36:04.140 --> 00:36:06.810
我们要数几行

00:36:06.090 --> 00:36:09.630
会说好的

00:36:06.810 --> 00:36:11.520
而我们建立的地图

00:36:09.630 --> 00:36:14.970
累积所有不同的飞行中

00:36:11.520 --> 00:36:19.100
正在建立请求，正在建立

00:36:14.970 --> 00:36:21.630
针对唯一网址（如果这些唯一网址） 

00:36:19.100 --> 00:36:23.490
你知道如果如果我们尝试添加

00:36:21.630 --> 00:36:29.570
已经是的东西是

00:36:23.490 --> 00:36:31.890
已经被看到，那么它将

00:36:29.570 --> 00:36:33.090
好吧，我的意思是让我们知道您会尝试的

00:36:31.890 --> 00:36:37.620
再次哀悼并尝试选择

00:36:33.090 --> 00:36:39.180
另一个，我们不想要那样

00:36:37.620 --> 00:36:41.100
不好，你知道另一件事

00:36:39.180 --> 00:36:44.370
我想到的是在这种情况下

00:36:41.100 --> 00:36:46.250
我们实际上是在使用负载弹跳器

00:36:44.370 --> 00:36:48.600
我正在使用负载均衡器

00:36:46.250 --> 00:36:51.930
使用负载均衡器算法

00:36:48.600 --> 00:36:53.670
我们从其中选择了一个

00:36:51.930 --> 00:36:55.500
配置实例，如果您不在乎

00:36:53.670 --> 00:36:58.380
关于那个负载弹跳器，你可以

00:36:55.500 --> 00:37:00.690
抛出前三个服务实例

00:36:58.380 --> 00:37:02.430
来自地图中此收藏的权利

00:37:00.690 --> 00:37:04.800
是的，只要这个清单是

00:37:02.430 --> 00:37:07.020
大于或等于尝试

00:37:04.800 --> 00:37:09.330
算你可以丢实例

00:37:07.020 --> 00:37:12.450
在那里你知道

00:37:09.330 --> 00:37:14.490
之前或达到我们的预算

00:37:12.450 --> 00:37:17.160
我们希望您可以投入的配额

00:37:14.490 --> 00:37:19.170
那些在地图上的，只是你知道

00:37:17.160 --> 00:37:20.640
忽略负载弹跳只是选择任何

00:37:19.170 --> 00:37:21.750
他们是正确的，但那不是你

00:37:20.640 --> 00:37:23.340
将无法利用

00:37:21.750 --> 00:37:25.620
正确的负载平衡器算法

00:37:23.340 --> 00:37:27.510
您可能不在乎，它会

00:37:25.620 --> 00:37:29.160
成为一个电话的好处

00:37:27.510 --> 00:37:31.440
知道需要一个电话才能获得

00:37:29.160 --> 00:37:33.530
所有这三个，而可以想象

00:37:31.440 --> 00:37:36.030
此负载均衡器客户端可能有

00:37:33.530 --> 00:37:37.830
调用其他具有元数据的事物

00:37:36.030 --> 00:37:40.140
你想问的

00:37:37.830 --> 00:37:44.550
好，那是个讨论，也许你

00:37:40.140 --> 00:37:49.020
性能分析回来，我需要

00:37:44.550 --> 00:37:51.900
你做运动好吧，所以我们需要做

00:37:49.020 --> 00:37:52.410
我们在这里的最后一件事是教我们

00:37:51.900 --> 00:38:01.470
客户

00:37:52.410 --> 00:38:03.780
关于它EFS好的过滤器BFF都不错

00:38:01.470 --> 00:38:05.280
好的，让我们看看会发生什么

00:38:03.780 --> 00:38:07.770
确实有一个我们可以用来终结的端点

00:38:05.280 --> 00:38:09.390
测试这个我们做对冲，我们已经

00:38:07.770 --> 00:38:14.880
客户我们正在致电体育

00:38:09.390 --> 00:38:17.700
服务还可以，我们实际上应该启动

00:38:14.880 --> 00:38:25.340
该服务实际上现在在哪里，我们的在哪里

00:38:17.700 --> 00:38:25.340
服务到这里去

00:38:29.839 --> 00:38:35.529
一二

00:38:45.310 --> 00:38:54.500
哦，哦，哦，我是一个模棱两可的人，你知道我

00:38:52.849 --> 00:38:55.849
有两个构造函数spring没有

00:38:54.500 --> 00:38:57.640
知道跟哪一个一起去

00:38:55.849 --> 00:39:03.410
在注释上使用该应用程序

00:38:57.640 --> 00:39:04.579
它消除了歧义，不是吗

00:39:03.410 --> 00:39:06.109
刚刚重新启动了错误的

00:39:04.579 --> 00:39:11.900
您一周的服务，然后我们

00:39:06.109 --> 00:39:13.750
开始很好，所以这是这里的客户

00:39:11.900 --> 00:39:19.579
我们去服务随地吐痰

00:39:13.750 --> 00:39:20.810
这是我们的服务重启，我不确定

00:39:19.579 --> 00:39:31.990
我们从哪开始的

00:39:20.810 --> 00:39:35.890
工作正常，这似乎还可以

00:39:31.990 --> 00:39:35.890
好吧，他们三个

00:39:40.549 --> 00:39:44.239
好吧，所以要尝试所有三个

00:39:42.769 --> 00:39:46.069
在这种情况下，如果我们做了四个

00:39:44.239 --> 00:39:47.539
希望会尝试三个而不是全部

00:39:46.069 --> 00:39:51.099
四个，但很高兴知道它有

00:39:47.539 --> 00:40:03.369
如果需要，可以尝试

00:39:51.099 --> 00:40:09.349
现在我们要说一下curl HTTP 

00:40:03.369 --> 00:40:13.420
 localhost 8080 881对，我们不是

00:40:09.349 --> 00:40:19.819
说我在说有服务

00:40:13.420 --> 00:40:23.509
客户端应用程序哪个服务器端口是

00:40:19.819 --> 00:40:28.249
这在港口是肯定的

00:40:23.509 --> 00:40:36.640
窒息在这里运行客户端80 81对

00:40:28.249 --> 00:40:36.640
好，端点称为边缘

00:40:38.529 --> 00:40:42.249
好，我们做错了什么

00:40:47.670 --> 00:40:52.309
无法处理此启动它

00:40:50.069 --> 00:40:52.309
那

00:41:06.230 --> 00:41:09.349
好吧，有趣的是我有一些吗

00:41:07.670 --> 00:41:15.760
有点奇怪的DNS问题是因为

00:41:09.349 --> 00:41:18.020
我酒店的Wi-Fi，看起来像我一样

00:41:15.760 --> 00:41:21.980
那里发生的事情无法解决

00:41:18.020 --> 00:41:23.750
所以当然不行，所以

00:41:21.980 --> 00:41:28.130
让我们看看你是因为说尤里卡

00:41:23.750 --> 00:41:32.660
说有一个客户和三个

00:41:28.130 --> 00:41:35.660
服务实例和服务以及

00:41:32.660 --> 00:41:39.820
例如客户端是未知的

00:41:35.660 --> 00:41:39.820
 Mostaza好的，这很有趣

00:41:53.050 --> 00:41:56.140
值为负，因此通过

00:41:54.910 --> 00:42:03.660
这是一个例外

00:41:56.140 --> 00:42:03.660
啊哈，所以发生了什么事我们感到愤怒- 

00:42:07.700 --> 00:42:13.080
 [音乐] 

00:42:09.330 --> 00:42:13.080
真的是负面的吗

00:42:26.140 --> 00:42:34.619
我猜那是我的意思，看来我

00:42:28.680 --> 00:42:45.970
不知道这会带来负面影响

00:42:34.619 --> 00:42:47.940
让我们第二次看到下一个int 

00:42:45.970 --> 00:42:56.519
你去看起来更容易

00:42:47.940 --> 00:42:56.519
所以没关系，让我们杀死这个

00:43:08.350 --> 00:43:11.070
一

00:43:13.640 --> 00:43:16.299
至

00:43:21.950 --> 00:43:30.890
三个好，所以旧的不见了

00:43:29.180 --> 00:43:35.480
但是仍然有三个品牌

00:43:30.890 --> 00:43:37.400
新的这里很好，所以服务是

00:43:35.480 --> 00:43:39.349
回应，那不是

00:43:37.400 --> 00:43:41.510
 localhost ，但仍然是IP地址

00:43:39.349 --> 00:43:45.140
我在本地机器上拥有的

00:43:41.510 --> 00:43:47.470
我认为客户可以解决

00:43:45.140 --> 00:43:55.880
这三个让我们希望

00:43:47.470 --> 00:43:57.470
关闭，关闭，所以现在必须

00:43:55.880 --> 00:44:01.820
是服务中的三个实例

00:43:57.470 --> 00:44:03.800
现在运行我的客户是

00:44:01.820 --> 00:44:10.160
客户端的心跳事件尚未发生

00:44:03.800 --> 00:44:11.780
正确地填充回去，所以我想我们

00:44:10.160 --> 00:44:13.670
可以强迫它，通常需要

00:44:11.780 --> 00:44:14.869
 30秒后重新建立

00:44:13.670 --> 00:44:16.099
服务注册表上的连接，以及

00:44:14.869 --> 00:44:17.960
然后发生一个心跳事件

00:44:16.099 --> 00:44:19.940
提供给客户

00:44:17.960 --> 00:44:21.800
然后刷新摩奇拉斯视图

00:44:19.940 --> 00:44:23.780
服务，但由于我们没有

00:44:21.800 --> 00:44:26.869
这样的时间，我不想

00:44:23.780 --> 00:44:31.790
立即打扰配置或

00:44:26.869 --> 00:44:37.250
从零开始重新开始

00:44:31.790 --> 00:44:38.810
好的，三秒钟后你好

00:44:37.250 --> 00:44:43.040
 3,000毫秒是3秒

00:44:38.810 --> 00:44:47.180
正确，让我们看看控制台显示的内容

00:44:43.040 --> 00:44:50.020
这是客户这是尤里卡

00:44:47.180 --> 00:44:53.800
这是三点后的服务

00:44:50.020 --> 00:44:58.190
四毫秒后的毫秒

00:44:53.800 --> 00:45:00.369
四毫秒后，让我们尝试

00:44:58.190 --> 00:45:00.369
再来一次

00:45:03.780 --> 00:45:13.059
这样一人花了三毫秒

00:45:10.270 --> 00:45:19.599
一个人花了两毫秒

00:45:13.059 --> 00:45:21.990
对不起，您再说两三遍

00:45:19.599 --> 00:45:27.099
我们将拥有的那两个之一

00:45:21.990 --> 00:45:28.270
一种权利，它将归还

00:45:27.099 --> 00:45:30.130
说两毫秒后，所以你在那里

00:45:28.270 --> 00:45:31.359
去第一个返回的是那个

00:45:30.130 --> 00:45:32.530
我们回来了，我们

00:45:31.359 --> 00:45:33.670
不抛弃其他人，而是

00:45:32.530 --> 00:45:37.359
至少如果我们有最后期限

00:45:33.670 --> 00:45:38.920
如果我们绝对必须回到这里

00:45:37.359 --> 00:45:40.780
时间，这是一个非常有用的

00:45:38.920 --> 00:45:43.030
技术显然你可以混合和

00:45:40.780 --> 00:45:44.349
将此技术与其他事物相匹配

00:45:43.030 --> 00:45:46.540
内置到反应堆中

00:45:44.349 --> 00:45:49.000
例如，指定一个

00:45:46.540 --> 00:45:51.040
这些请求超时，因为您

00:45:49.000 --> 00:45:53.799
知道即使他们不归还

00:45:51.040 --> 00:45:55.930
如果他们不再有时间服务

00:45:53.799 --> 00:45:59.410
客户要求您仍然不想要

00:45:55.930 --> 00:46:01.030
他们在那里，只是你知道在

00:45:59.410 --> 00:46:02.530
通常荒野只是在等待

00:46:01.030 --> 00:46:03.940
永远不会发生的事

00:46:02.530 --> 00:46:07.030
应该指定一个积极的客户端

00:46:03.940 --> 00:46:09.339
超时以释放资源

00:46:07.030 --> 00:46:11.079
我们知道该请求代表

00:46:09.339 --> 00:46:13.930
在客户端中，因此您可以指定

00:46:11.079 --> 00:46:16.690
超时，您也可以正确重试

00:46:13.930 --> 00:46:17.829
如果使用反应器则是反应性的

00:46:16.690 --> 00:46:20.859
项目就是那个

00:46:17.829 --> 00:46:23.380
支持反应式Web客户端或

00:46:20.859 --> 00:46:25.359
反应支架和Spring 框架

00:46:23.380 --> 00:46:26.589
五支持重试

00:46:25.359 --> 00:46:29.410
对，我的意思是，还有两件事

00:46:26.589 --> 00:46:31.750
你可以在这里做，但你知道

00:46:29.410 --> 00:46:34.180
我们让她度过的速度收益

00:46:31.750 --> 00:46:37.059
并行对其他事情

00:46:34.180 --> 00:46:38.680
确保您的系统在清理后

00:46:37.059 --> 00:46:40.359
本身就是您不浪费资源

00:46:38.680 --> 00:46:42.880
这很有价值，但是为了满足

00:46:40.359 --> 00:46:44.440
您的截止日期，我们将散发出

00:46:42.880 --> 00:46:48.190
我们可以同时进行许多通话， 

00:46:44.440 --> 00:46:50.440
他们立即返回，并且

00:46:48.190 --> 00:46:56.369
好处当然是在这里

00:46:50.440 --> 00:46:58.960
在客户端中的客户端应用程序中

00:46:56.369 --> 00:47:00.790
我们只是打电话，我们有一个

00:46:58.960 --> 00:47:03.520
具有一种价值的发布者

00:47:00.790 --> 00:47:06.280
是我们的字符串信息，我们不知道

00:47:03.520 --> 00:47:07.839
这反过来会导致三个

00:47:06.280 --> 00:47:09.430
其他调用我们不在乎我们的代码

00:47:07.839 --> 00:47:10.510
从逻辑上讲要简单得多，因为我们

00:47:09.430 --> 00:47:12.309
只是知道我们在他们的第一

00:47:10.510 --> 00:47:14.800
返回，然后我们可以实际构建

00:47:12.309 --> 00:47:16.990
使用同一Web客户端进行多个呼叫

00:47:14.800 --> 00:47:19.300
所有服务都在服务中看

00:47:16.990 --> 00:47:22.180
我可以使用助焊剂拉链

00:47:19.300 --> 00:47:24.430
对，我可以说叫a和B 

00:47:22.180 --> 00:47:27.310
其结果是，如果它是通量，那就是

00:47:24.430 --> 00:47:30.940
具有第一个元组的发布者

00:47:27.310 --> 00:47:34.330
 t1是操作数的类型

00:47:30.940 --> 00:47:37.480
 a和a的通量的通用参数

00:47:34.330 --> 00:47:39.490
然后输入-t2是

00:47:37.480 --> 00:47:41.320
 B通量的遗传参数

00:47:39.490 --> 00:47:43.000
对，这样您就可以做一些非常

00:47:41.320 --> 00:47:44.290
有趣的事情在哪里你打电话给你

00:47:43.000 --> 00:47:46.480
知道两种不同的服务，然后

00:47:44.290 --> 00:47:48.220
将结果组合成一个流

00:47:46.480 --> 00:47:49.720
知道你从左侧拉一个

00:47:48.220 --> 00:47:51.460
从右侧拉

00:47:49.720 --> 00:47:52.930
左侧等像是一个拉链

00:47:51.460 --> 00:47:54.940
为什么叫zip，您可以做各种各样的事情

00:47:52.930 --> 00:47:56.860
像这样的有趣的事情

00:47:54.940 --> 00:47:58.570
是并发的，你知道它的工作原理

00:47:56.860 --> 00:48:00.190
您期望的方式就是您可以

00:47:58.570 --> 00:48:01.930
打电话给三个服务-显然我只是

00:48:00.190 --> 00:48:03.880
谈论一些非常简单的案例

00:48:01.930 --> 00:48:06.130
在这里，但代码每个

00:48:03.880 --> 00:48:07.570
现在可能会导致三个通话

00:48:06.130 --> 00:48:08.950
您是否需要担心

00:48:07.570 --> 00:48:09.910
只要你不在就安排

00:48:08.950 --> 00:48:11.560
阻止你知道然后

00:48:09.910 --> 00:48:14.200
默认配置上的调度程序

00:48:11.560 --> 00:48:16.150
应该可以，当然可以

00:48:14.200 --> 00:48:18.460
您可以自定义调度程序对象

00:48:16.150 --> 00:48:21.940
在反应堆中用来改变

00:48:18.460 --> 00:48:24.070
我想再想一想的行为

00:48:21.940 --> 00:48:25.510
认为约翰·施耐德（John Schneider）使我想起

00:48:24.070 --> 00:48:28.450
这种模式John Schneider当然是

00:48:25.510 --> 00:48:31.930
在千分尺的引导下，他是一个真正的

00:48:28.450 --> 00:48:32.560
聪明的家伙，你看代码

00:48:31.930 --> 00:48:35.020
千分尺和

00:48:32.560 --> 00:48:37.210
你可以看到这是我们很幸运的

00:48:35.020 --> 00:48:40.930
有人，我来了 Spring 的云

00:48:37.210 --> 00:48:44.260
团队帮助建立最强大的

00:48:40.930 --> 00:48:47.830
微服务框架可以

00:48:44.260 --> 00:48:50.370
谢谢你我的朋友们，有了这些，我们将

00:48:47.830 --> 00:48:50.370
下次见

00:48:56.320 --> 00:48:58.380
您

