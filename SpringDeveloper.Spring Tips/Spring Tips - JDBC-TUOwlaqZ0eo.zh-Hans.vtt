WEBVTT
Kind: captions
Language: zh-Hans

00:00:25.810 --> 00:00:29.830
嗨斯普林斯，欢迎来到另一个

00:00:27.910 --> 00:00:32.140
 Spring 小贴士和听

00:00:29.830 --> 00:00:34.600
峰会不会看GBC是LBC 

00:00:32.140 --> 00:00:36.730
数据库的基本驱动程序层

00:00:34.600 --> 00:00:38.110
连接Java Java数据库踢

00:00:36.730 --> 00:00:40.449
延迟我们可以用来与之交谈

00:00:38.110 --> 00:00:42.940
基于秘密的数据源，我的意思是

00:00:40.449 --> 00:00:46.269
一切正常，如我的墨西哥服务器

00:00:42.940 --> 00:00:48.220
甲骨文发布坟墓我的续集续集

00:00:46.269 --> 00:00:52.329
您知道我的意思是Microsoft Access 

00:00:48.220 --> 00:00:53.680
 Informix Sybase H2H续集Derby 

00:00:52.329 --> 00:00:56.079
你想像得到的一切

00:00:53.680 --> 00:00:59.080
跟我们聊续集

00:00:56.079 --> 00:01:01.809
您可以支持这种肥胖性角膜炎， 

00:00:59.080 --> 00:01:03.790
现在非常著名的程序模型

00:01:01.809 --> 00:01:05.950
 JDBC是年轻的罗斯，它非常强大

00:01:03.790 --> 00:01:08.049
并不是所有的一切

00:01:05.950 --> 00:01:10.689
他们使用起来不方便，这

00:01:08.049 --> 00:01:12.189
已经有20多年的历史了，所以

00:01:10.689 --> 00:01:15.340
好吧，上面有很多地面

00:01:12.189 --> 00:01:16.960
在其上提供简单性和

00:01:15.340 --> 00:01:19.210
力量，因此生态系统已寻求

00:01:16.960 --> 00:01:20.680
填补这一空白，最早

00:01:19.210 --> 00:01:22.000
仍然是最多样化的

00:01:20.680 --> 00:01:25.420
我认为该空间的强大入口

00:01:22.000 --> 00:01:26.590
是 Spring 我想一些 Spring 

00:01:25.420 --> 00:01:28.210
实际上已经存在的支持

00:01:26.590 --> 00:01:30.369
从 Spring 开始

00:01:28.210 --> 00:01:31.929
您最早知道的事情之一

00:01:30.369 --> 00:01:34.539
我们在 Spring 所做的是简化工作

00:01:31.929 --> 00:01:36.399
 JDBC和很多人

00:01:34.539 --> 00:01:38.499
包括我自己在内，这确实是一个

00:01:36.399 --> 00:01:42.009
我们看到的第一件事

00:01:38.499 --> 00:01:45.009
你在 Spring 看到了代表

00:01:42.009 --> 00:01:46.990
我们想要的实用工具

00:01:45.009 --> 00:01:51.189
一周的 Spring ，以便能够

00:01:46.990 --> 00:01:53.619
使用权，因此JDBC是一个古老的话题， 

00:01:51.189 --> 00:01:55.270
似乎没有尽头的兴趣

00:01:53.619 --> 00:01:56.740
自然而然地，有很多

00:01:55.270 --> 00:01:58.899
真正有用的技术

00:01:56.740 --> 00:02:00.369
使其成为一个强大的地方

00:01:58.899 --> 00:02:01.840
构建应用程序的强大方法

00:02:00.369 --> 00:02:03.310
所以今天我要花时间

00:02:01.840 --> 00:02:05.289
看一些不同的东西

00:02:03.310 --> 00:02:07.030
在基本 Spring 中得到支持

00:02:05.289 --> 00:02:08.619
还有一些生态系统，所以我要

00:02:07.030 --> 00:02:09.940
建立它，我们需要的应用程序

00:02:08.619 --> 00:02:11.530
和我的续集谈谈

00:02:09.940 --> 00:02:13.660
在我当地跑的秘密女士

00:02:11.530 --> 00:02:15.010
机在这里，所以我们用我的圈子

00:02:13.660 --> 00:02:18.910
用龙目岛做一个简短的工作

00:02:15.010 --> 00:02:21.910
清理，以便DTL实体类型记录

00:02:18.910 --> 00:02:24.910
今天或一个盘子是一个应用程序

00:02:21.910 --> 00:02:26.110
使用jb support和spring和

00:02:24.910 --> 00:02:29.590
 spring boot 本身，所以我要带

00:02:26.110 --> 00:02:31.150
那就是现在，我们需要我的

00:02:29.590 --> 00:02:32.530
我正在使用的续集

00:02:31.150 --> 00:02:34.560
这里的一些默认复选框

00:02:32.530 --> 00:02:37.569
这里有一些选择

00:02:34.560 --> 00:02:40.390
你知道没人是否不同的J 

00:02:37.569 --> 00:02:42.819
例如支持bases h2 

00:02:40.390 --> 00:02:44.230
危机后也在那里让我们看看

00:02:42.819 --> 00:02:45.939
如果微软在那边排序

00:02:44.230 --> 00:02:47.319
还有很多不同的

00:02:45.939 --> 00:02:50.049
您可以在此处设置的选项

00:02:47.319 --> 00:02:51.400
但这绝不是详尽的

00:02:50.049 --> 00:02:53.560
 Spring 支持的事情清单

00:02:51.400 --> 00:02:55.420
显然，这些只是一种

00:02:53.560 --> 00:02:57.099
开箱即用的有用的东西，让我们开始吧

00:02:55.420 --> 00:02:59.290
向前并抛出Downloads目录

00:02:57.099 --> 00:03:02.159
在这里我想我已经有一个副本

00:02:59.290 --> 00:03:06.819
目录再见了

00:03:02.159 --> 00:03:08.139
产生的好机会，还有我的

00:03:06.819 --> 00:03:10.540
 zip文件，以便将其打开

00:03:08.139 --> 00:03:12.639
 IDE，我们可以继续

00:03:10.540 --> 00:03:13.780
与我的续集有关的出版物

00:03:12.639 --> 00:03:16.620
现在再次在本地

00:03:13.780 --> 00:03:18.280
在主机下运行的计算机

00:03:16.620 --> 00:03:26.230
在我本地运行的血清

00:03:18.280 --> 00:03:31.260
机器，所以我的续集，你看到RM hh 

00:03:26.230 --> 00:03:33.579
等于CM p，然后血清p是

00:03:31.260 --> 00:03:38.549
要求我正确发送密码，以便

00:03:33.579 --> 00:03:44.440
如果我这样做，我将显示表格下降

00:03:38.549 --> 00:03:45.400
表客户放弃表订单

00:03:44.440 --> 00:03:49.239
好了，我们在那里

00:03:45.400 --> 00:03:50.709
所以显示表，现在我们什么都没有了

00:03:49.239 --> 00:03:54.659
将建立一个可以交谈的应用程序

00:03:50.709 --> 00:03:57.280
到我的数据库，为了做到这一点，我

00:03:54.659 --> 00:03:59.199
我可以手动创建数据源吗

00:03:57.280 --> 00:04:01.389
这样我实际上可以进入

00:03:59.199 --> 00:04:05.019
弹起并创建数据类型的光束

00:04:01.389 --> 00:04:06.909
像这样的来源，这本日报可能是

00:04:05.019 --> 00:04:08.470
你知道它可能是一个数据源

00:04:06.909 --> 00:04:10.209
我现在很自然地与数据库对话

00:04:08.470 --> 00:04:12.069
知道我能够做到这一点

00:04:10.209 --> 00:04:13.150
知道我必须访问

00:04:12.069 --> 00:04:15.459
在这里输入，这样我就可以真正

00:04:13.150 --> 00:04:17.560
摆脱Maven运行时前缀

00:04:15.459 --> 00:04:19.030
保存数据源，我需要某种

00:04:17.560 --> 00:04:20.739
数据源实现良好

00:04:19.030 --> 00:04:22.389
当然在这里我可以用Spring 

00:04:20.739 --> 00:04:26.409
框架一个简单的驱动程序数据源

00:04:22.389 --> 00:04:29.860
例如这样，这很棒

00:04:26.409 --> 00:04:32.979
用于开发SDS之类的东西

00:04:29.860 --> 00:04:34.449
新的简单驱动程序数据源及其

00:04:32.979 --> 00:04:36.699
将需要做它的工作，它将

00:04:34.449 --> 00:04:39.210
需要驱动程序类型，所以我们需要尝试

00:04:36.699 --> 00:04:41.480
我的续集司机在这里，我会说司机

00:04:39.210 --> 00:04:44.690
等于新司机

00:04:41.480 --> 00:04:51.560
当然，为了

00:04:44.690 --> 00:04:53.720
它要做它的工作，我们需要看看

00:04:51.560 --> 00:04:55.100
它引发了他们不需要的异常

00:04:53.720 --> 00:04:58.790
还有一些配置，请驱动它

00:04:55.100 --> 00:05:00.890
设置任何连接您的L 

00:04:58.790 --> 00:05:03.650
属性等等等等，你知道

00:05:00.890 --> 00:05:08.810
你把那个放在那里，然后

00:05:03.650 --> 00:05:12.350
您输入URL用户密码等

00:05:08.810 --> 00:05:13.370
等等，然后返回SDS，如果得到

00:05:12.350 --> 00:05:15.500
工作

00:05:13.370 --> 00:05:17.450
你仍然没人接近

00:05:15.500 --> 00:05:19.670
这是正确的方法，所以我们拥有

00:05:17.450 --> 00:05:21.050
这是一个简单的驱动程序数据源

00:05:19.670 --> 00:05:23.090
驱动程序做了药物数据源是

00:05:21.050 --> 00:05:26.000
数据源是驱动程序是随机驱动程序

00:05:23.090 --> 00:05:28.340
通常你是低层的方式

00:05:26.000 --> 00:05:31.040
与续集数据库对话

00:05:28.340 --> 00:05:33.320
如果您连接，将为您建立连接

00:05:31.040 --> 00:05:34.670
这样的权利，所以你去耶鲁

00:05:33.320 --> 00:05:37.100
给一些属性，它会给你

00:05:34.670 --> 00:05:43.730
 Java中的连接会产生续集

00:05:37.100 --> 00:05:46.160
那样的联系和那些

00:05:43.730 --> 00:05:47.840
连接很昂贵，所以这

00:05:46.160 --> 00:05:49.610
连接是您想要的东西

00:05:47.840 --> 00:05:51.650
保留您不必重新创建它们

00:05:49.610 --> 00:05:53.000
每次这个简单的图形数据源

00:05:51.650 --> 00:05:55.460
仅仅是因为它很简单

00:05:53.000 --> 00:05:57.020
真正的发展和第一件事

00:05:55.460 --> 00:05:58.730
您应该注意的是，这不是

00:05:57.020 --> 00:06:00.080
自然连接池不

00:05:58.730 --> 00:06:01.790
实际上拉它只是服务的连接

00:06:00.080 --> 00:06:03.410
作为成熟产品的简单替代品

00:06:01.790 --> 00:06:05.000
实现相同的连接池

00:06:03.410 --> 00:06:06.530
标准界面，但创建新的

00:06:05.000 --> 00:06:09.080
我记得重点是

00:06:06.530 --> 00:06:12.560
如果您正在测试您的开发， 

00:06:09.080 --> 00:06:14.210
是个好主意，但作为本文档

00:06:12.560 --> 00:06:15.530
如果需要，可以很清楚地说明

00:06:14.210 --> 00:06:17.690
 Java外部的真实连接池

00:06:15.530 --> 00:06:18.740
 EE容器考虑使用Apache 

00:06:17.690 --> 00:06:22.280
注释dbcp 

00:06:18.740 --> 00:06:25.490
或c-3po或您知道Patchett 

00:06:22.280 --> 00:06:26.870
 Tomcat获得了一个连接池或一个呼叫

00:06:25.490 --> 00:06:29.510
 ECP，所以已经存在了很长时间

00:06:26.870 --> 00:06:31.280
时间，但绝不是什么

00:06:29.510 --> 00:06:33.080
我们将要使用，所以我们想要

00:06:31.280 --> 00:06:36.440
配置更坚固的东西

00:06:33.080 --> 00:06:39.860
 Hikari CP或Apache Tomcat Tomcats dbcp 

00:06:36.440 --> 00:06:41.210
或什么都没有，只是让 Spring 

00:06:39.860 --> 00:06:42.890
开机再在 spring boot 

00:06:41.210 --> 00:06:46.100
如果我们问得好，就为我们做

00:06:42.890 --> 00:06:48.410
给一些属性，如果我们有

00:06:46.100 --> 00:06:49.729
他们在类路径h2上拥有的类路径

00:06:48.410 --> 00:06:51.680
或si 

00:06:49.729 --> 00:06:54.229
您的H续集会自动

00:06:51.680 --> 00:06:56.330
为我们创建这些数据源，以便我们

00:06:54.229 --> 00:06:58.639
不必做很多事情就可以做到这一点

00:06:56.330 --> 00:07:00.110
工作，但由于我们不这样做，所以我们不是

00:06:58.639 --> 00:07:01.129
使用我们发明的那些之一

00:07:00.110 --> 00:07:03.740
将创建我们自己的数据源

00:07:01.129 --> 00:07:04.909
使用属性，所以我们在这里可以

00:07:03.740 --> 00:07:06.680
看到我们这里有一些属性

00:07:04.909 --> 00:07:08.870
使URL上的数据源等于

00:07:06.680 --> 00:07:12.529
在这里，我们需要告诉它去哪里

00:07:08.870 --> 00:07:13.969
找到我们的续集数据源， 

00:07:12.529 --> 00:07:16.419
我们给它一个用户名和密码

00:07:13.969 --> 00:07:25.069
以及这样的数据源

00:07:16.419 --> 00:07:25.490
该URL用户名数据源点用户

00:07:25.069 --> 00:07:31.839
名称

00:07:25.490 --> 00:07:38.300
好吧，让我们看看密码，就是CRM 

00:07:31.839 --> 00:07:39.789
 CRM，URL是JDBC：我的续集

00:07:38.300 --> 00:07:43.909
冒号正斜杠

00:07:39.789 --> 00:07:47.300
本地主机3306 CRM，此部分始终

00:07:43.909 --> 00:07:48.529
让我使用SSL等于他们添加的false 

00:07:47.300 --> 00:07:49.819
如果几年前有这个要求

00:07:48.529 --> 00:07:51.499
如果你是开发模式

00:07:49.819 --> 00:07:53.389
不使用SSL连接，您应该

00:07:51.499 --> 00:07:54.649
但是如果您不适合当地人

00:07:53.389 --> 00:07:58.580
发展，那么你必须说用户

00:07:54.649 --> 00:07:59.719
使用SSL等于false使用SSL等于

00:07:58.580 --> 00:08:02.930
假

00:07:59.719 --> 00:08:05.389
我也需要一个主机

00:08:02.930 --> 00:08:07.490
其他，我们想指定一个十字架

00:08:05.389 --> 00:08:09.499
类名中的名称驱动程序类名

00:08:07.490 --> 00:08:11.990
等同于调用我的续集JDBC 

00:08:09.499 --> 00:08:13.550
司机和幕后

00:08:11.990 --> 00:08:16.719
连接池将为此配置

00:08:13.550 --> 00:08:19.550
我们现在在 Spring ，在托莱多之前

00:08:16.719 --> 00:08:24.080
连接池是Apache Commons DB的

00:08:19.550 --> 00:08:26.659
这是一个Patrick Tomcat连接池

00:08:24.080 --> 00:08:28.789
这是一个不错的选择，但是我们已经

00:08:26.659 --> 00:08:31.069
听起来很多用户都感觉更好

00:08:28.789 --> 00:08:33.529
用车CP运气好，所以我们做到了

00:08:31.069 --> 00:08:35.839
 Spring 的默认值，我们认为是

00:08:33.529 --> 00:08:37.310
更快，效果更好，所以你

00:08:35.839 --> 00:08:39.050
如果您愿意，将不会注意到这一点

00:08:37.310 --> 00:08:41.209
注意您的应用程序更快

00:08:39.050 --> 00:08:42.709
对，那很好，另一件事是

00:08:41.209 --> 00:08:43.880
我们想要初始化一些数据

00:08:42.709 --> 00:08:47.630
我们将给它一些默认值

00:08:43.880 --> 00:08:49.190
模式和默认数据续集文件

00:08:47.630 --> 00:08:51.290
所以我要去续集

00:08:49.190 --> 00:08:52.519
我是在续集文件和 Spring 完成的

00:08:51.290 --> 00:08:53.930
自动初始化

00:08:52.519 --> 00:08:55.490
数据源的应用

00:08:53.930 --> 00:08:57.620
这些默认文件，但我们必须告诉

00:08:55.490 --> 00:08:59.300
它针对每种数据执行此操作

00:08:57.620 --> 00:09:01.440
不只是嵌入式类型对

00:08:59.300 --> 00:09:04.350
所以总是嵌入它或

00:09:01.440 --> 00:09:05.910
所以在这里我们删除了那些表

00:09:04.350 --> 00:09:07.230
看到我删除了这些表，所以现在我们

00:09:05.910 --> 00:09:09.120
需要手动创建它们，所以我

00:09:07.230 --> 00:09:13.860
将创建一个名为schema的续集文件

00:09:09.120 --> 00:09:18.389
续集好了，然后转到我的桌面

00:09:13.860 --> 00:09:21.959
你会看到我已经复制了这些数据

00:09:18.389 --> 00:09:26.639
续集下载JBC源码主要

00:09:21.959 --> 00:09:27.500
后续复制架构的资源数据

00:09:26.639 --> 00:09:31.730
那个续集

00:09:27.500 --> 00:09:34.019
下载JDBC源主要资源

00:09:31.730 --> 00:09:36.000
我的狗续集还好，所以我只是

00:09:34.019 --> 00:09:40.410
在这里复制这两个文件，您可以

00:09:36.000 --> 00:09:44.550
看到创建的表非常

00:09:40.410 --> 00:09:44.970
我很简单，我有两个

00:09:44.550 --> 00:09:46.440
类型

00:09:44.970 --> 00:09:49.980
我有两张桌子的顾客

00:09:46.440 --> 00:09:52.769
命令两种类型的表是

00:09:49.980 --> 00:09:56.070
那个客户彼此相关

00:09:52.769 --> 00:09:58.320
是一个的一对多方面

00:09:56.070 --> 00:09:59.519
 -一对多关系订单

00:09:58.320 --> 00:10:02.100
是一对多的主要方面

00:09:59.519 --> 00:10:05.430
关系，所以有一个客户

00:10:02.100 --> 00:10:09.360
和0到n个订单，由

00:10:05.430 --> 00:10:11.040
外键，你知道的就是这样

00:10:09.360 --> 00:10:13.230
这很简单，我正在使用我的

00:10:11.040 --> 00:10:14.820
续集与我有些细微差别

00:10:13.230 --> 00:10:17.040
续集有些不同

00:10:14.820 --> 00:10:21.779
其他数据库，也许您可​​以使用

00:10:17.040 --> 00:10:23.100
串行和邮政车，例如全部

00:10:21.779 --> 00:10:24.930
对，所以我们有那些东西

00:10:23.100 --> 00:10:26.399
 spring boot 会自动点击

00:10:24.930 --> 00:10:28.140
这些桌子对我们来说将会学到

00:10:26.399 --> 00:10:29.399
假期开始时为我们提供的模式

00:10:28.140 --> 00:10:31.170
现在可能不是

00:10:29.399 --> 00:10:32.970
您想在生产中发生的

00:10:31.170 --> 00:10:34.470
例如，所以您可能实际上想要

00:10:32.970 --> 00:10:37.829
说你知道你可能想放

00:10:34.470 --> 00:10:40.680
这个属性在这里你知道

00:10:37.829 --> 00:10:42.329
应用程序-开发该属性和

00:10:40.680 --> 00:10:43.350
然后确保当您启动时

00:10:42.329 --> 00:10:45.000
开发中的应用程序

00:10:43.350 --> 00:10:46.380
您激活Spring 的环境

00:10:45.000 --> 00:10:48.569
个人资料称为dev，因此仅

00:10:46.380 --> 00:10:50.490
在开发人员上运行，从不生产

00:10:48.569 --> 00:10:53.010
重新设置，因为它会-您知道

00:10:50.490 --> 00:10:56.069
模式将破坏所有现有的

00:10:53.010 --> 00:10:57.420
确实不是一个好主意的数据

00:10:56.069 --> 00:10:59.010
知道有人可能会更进一步

00:10:57.420 --> 00:11:00.029
采取一切，然后走一步

00:10:59.010 --> 00:11:02.220
进一步使用诸如

00:11:00.029 --> 00:11:04.410
液体基或花都是

00:11:02.220 --> 00:11:05.639
数据库迁移工具

00:11:04.410 --> 00:11:08.100
演化您要确保的架构

00:11:05.639 --> 00:11:11.040
您具有可追溯性

00:11:08.100 --> 00:11:13.260
哪些步骤进行了哪些更改

00:11:11.040 --> 00:11:13.540
到方案和科尔沃的曾经

00:11:13.260 --> 00:11:15.430
新

00:11:13.540 --> 00:11:18.220
基本上你知道的一种迁移

00:11:15.430 --> 00:11:20.980
从一个架构状态到

00:11:18.220 --> 00:11:23.860
接下来，你知道那种方式，你知道你的

00:11:20.980 --> 00:11:25.959
开发人员环境已建立架构

00:11:23.860 --> 00:11:27.550
直到第五步，但您的生产

00:11:25.959 --> 00:11:29.889
数据库只有方案到第二步

00:11:27.550 --> 00:11:31.449
所以戴维斯移民会知道

00:11:29.889 --> 00:11:33.579
现状和生产

00:11:31.449 --> 00:11:34.990
数据库是两个，因此在部署时

00:11:33.579 --> 00:11:37.240
您的申请是第一次

00:11:34.990 --> 00:11:40.480
应用您知道的步骤或我的目标或其他步骤

00:11:37.240 --> 00:11:43.060
他们称迁移为第三步，第四步

00:11:40.480 --> 00:11:45.009
五正确的结果是，你的

00:11:43.060 --> 00:11:47.440
系统将被提升到大约

00:11:45.009 --> 00:11:49.540
两个到当前状态

00:11:47.440 --> 00:11:51.279
开发代码，并且每次运行

00:11:49.540 --> 00:11:52.509
一次，所以你也很高兴

00:11:51.279 --> 00:11:54.699
了解其中一些原因

00:11:52.509 --> 00:11:56.380
给您建模回滚的方法等等

00:11:54.699 --> 00:11:58.389
所以那里真的有很好的支持

00:11:56.380 --> 00:12:00.190
现在也许是另一个的视频

00:11:58.389 --> 00:12:01.870
今天为了我们的目的，这将

00:12:00.190 --> 00:12:03.430
这将使我们得到我们现在想要的

00:12:01.870 --> 00:12:05.319
说你想利用什么

00:12:03.430 --> 00:12:07.120
我们是人偶，你应该随便

00:12:05.319 --> 00:12:09.250
利用您的IDE支持

00:12:07.120 --> 00:12:12.160
我整个监狱都有不同的数据库

00:12:09.250 --> 00:12:13.750
这里工作的很好的支持

00:12:12.160 --> 00:12:15.370
与不同的数据库甚至有一个

00:12:13.750 --> 00:12:17.769
分开的产品

00:12:15.370 --> 00:12:18.940
您可以购买或我认为的产品

00:12:17.769 --> 00:12:20.860
可能有一个开源版本

00:12:18.940 --> 00:12:24.100
我不确定，但肯定有

00:12:20.860 --> 00:12:25.060
您可以购买的版本

00:12:24.100 --> 00:12:30.750
让您与众不同

00:12:25.060 --> 00:12:34.120
数据库，让我们来看看CRM 

00:12:30.750 --> 00:12:35.889
密码测试良好，所以现在我已连接

00:12:34.120 --> 00:12:38.920
结果是我得到了

00:12:35.889 --> 00:12:41.889
控制台在这里，所以我可以说你知道表演

00:12:38.920 --> 00:12:42.490
运行表，您可以看到

00:12:41.889 --> 00:12:44.529
那里空无一物

00:12:42.490 --> 00:12:46.300
好吧，让我们运行这个应用程序

00:12:44.529 --> 00:12:52.389
只是运行它而已

00:12:46.300 --> 00:12:57.240
好的应用程序，当我去的时候

00:12:52.389 --> 00:13:04.420
回到这里到我的续集控制台

00:12:57.240 --> 00:13:05.500
数据库工具控制台提示，我想

00:13:04.420 --> 00:13:08.310
用光是的

00:13:05.500 --> 00:13:08.310
创建游戏

00:13:09.810 --> 00:13:14.470
我们去那里，所以我可以看到我有那些

00:13:11.830 --> 00:13:16.030
那里有两个两张桌子，我有一些

00:13:14.470 --> 00:13:19.780
数据正确，所以如果你看看我的

00:13:16.030 --> 00:13:21.460
模式我已经有了这个的定义

00:13:19.780 --> 00:13:24.460
对象印度和数据库以及

00:13:21.460 --> 00:13:28.240
数据伊万现在是什么一二

00:13:24.460 --> 00:13:30.220
三六个记录，我有大卫一世

00:13:28.240 --> 00:13:36.910
正在写或正在写

00:13:30.220 --> 00:13:38.800
我是乔什（Josh）的简（Jane）和鲍勃（Bob）的

00:13:36.910 --> 00:13:40.840
米歇尔，所以米歇尔有三个鲍勃

00:13:38.800 --> 00:13:42.730
获得两个，乔希有三个

00:13:40.840 --> 00:13:44.110
记录还可以，所以其中一些为零

00:13:42.730 --> 00:13:46.570
这很重要，我们将回到

00:13:44.110 --> 00:13:49.510
现在稍后我们要做的是

00:13:46.570 --> 00:13:50.860
想锻炼你知道的

00:13:49.510 --> 00:13:52.810
利用某些优势的应用程序

00:13:50.860 --> 00:13:54.370
 Springfield的基本支持

00:13:52.810 --> 00:13:55.900
本身，所以我们要开始简单

00:13:54.370 --> 00:13:58.330
用我们所知道并走的路

00:13:55.900 --> 00:14:00.610
通过更多有趣的更多

00:13:58.330 --> 00:14:03.490
复杂的，也许是奇特的报价

00:14:00.610 --> 00:14:06.940
 JDBC访问spring的选项

00:14:03.490 --> 00:14:10.180
做很多类似的事情时要克服

00:14:06.940 --> 00:14:11.710
演示，但我们要知道我

00:14:10.180 --> 00:14:13.030
要重复，我要写很多

00:14:11.710 --> 00:14:14.320
同一代码页中的类似内容

00:14:13.030 --> 00:14:16.510
在这里，我要创造一个非常整洁的

00:14:14.320 --> 00:14:19.060
这里的灵活性只是为了写出

00:14:16.510 --> 00:14:23.980
尝试那个联盟，我们可以看到哪里

00:14:19.060 --> 00:14:27.340
我们的输出如此行而已

00:14:23.980 --> 00:14:29.800
要做的就是使用log4j更长的时间

00:14:27.340 --> 00:14:33.120
在那里，我会说很长一段时间的信息， 

00:14:29.800 --> 00:14:38.890
我会打印一行

00:14:33.120 --> 00:14:43.090
那里我们很简单，现在说

00:14:38.890 --> 00:14:45.640
在第一个示例中，我们将要

00:14:43.090 --> 00:14:49.320
有一个应用程序运行器是光束

00:14:45.640 --> 00:14:52.030
那将启动，它将注销

00:14:49.320 --> 00:14:54.460
数据库中的信息

00:14:52.030 --> 00:14:59.920
产生一份报告，所以我要创建

00:14:54.460 --> 00:15:01.390
客户和订单计数，这是

00:14:59.920 --> 00:15:02.740
我将成为应用程序赛跑者

00:15:01.390 --> 00:15:04.210
知道这应该是一个单位

00:15:02.740 --> 00:15:05.380
测试之类的东西，但我们只是在尝试

00:15:04.210 --> 00:15:07.960
展示不同事物如何运作

00:15:05.380 --> 00:15:10.600
所以我们的应用程序运行者将

00:15:07.960 --> 00:15:13.360
利用这种情况，JDBC 

00:15:10.600 --> 00:15:16.180
现在的JDBC模板是I 

00:15:13.360 --> 00:15:17.770
认为最有趣的一种

00:15:16.180 --> 00:15:18.220
 JDBC中的对象是支持和

00:15:17.770 --> 00:15:20.440
Spring 

00:15:18.220 --> 00:15:21.990
在一天中永远存在

00:15:20.440 --> 00:15:23.459
使短期工作

00:15:21.990 --> 00:15:25.529
工作中涉及很多事情

00:15:23.459 --> 00:15:27.720
与续集，所以让我们有一个

00:15:25.529 --> 00:15:31.279
如果您查看Spring文档

00:15:27.720 --> 00:15:36.060
在这里 Spring ，IO用于辅助项目

00:15:31.279 --> 00:15:39.360
地板窗框Spring Framework看看

00:15:36.060 --> 00:15:42.060
数据访问文档转到数据

00:15:39.360 --> 00:15:44.610
使用JDBC进行访问，您会发现这很神奇

00:15:42.060 --> 00:15:45.690
专栏这张桌子错过了所有

00:15:44.610 --> 00:15:47.910
任何必需的东西

00:15:45.690 --> 00:15:50.790
通过JDBC与续集进行交互

00:15:47.910 --> 00:15:53.130
续集连接和资源何时

00:15:50.790 --> 00:15:54.120
您正在使用JDBC等

00:15:53.130 --> 00:15:55.800
您必须管理的东西

00:15:54.120 --> 00:15:57.630
定义连接参数，打开

00:15:55.800 --> 00:15:59.279
连接说明续集引物或

00:15:57.630 --> 00:16:00.540
定义较为明确的陈述包括

00:15:59.279 --> 00:16:02.880
声明参数并提供

00:16:00.540 --> 00:16:05.040
参数值准备并执行

00:16:02.880 --> 00:16:07.410
语句设置任何设置和循环

00:16:05.040 --> 00:16:09.300
通过任何工作的结果

00:16:07.410 --> 00:16:11.279
在每次迭代中处理异常

00:16:09.300 --> 00:16:12.540
并且所有交易关闭

00:16:11.279 --> 00:16:13.680
连接语句最终结果集不正确

00:16:12.540 --> 00:16:15.690
提及您必须进行的交易

00:16:13.680 --> 00:16:16.589
进来吧，所以分析师的东西就是东西

00:16:15.690 --> 00:16:19.529
当然要做好

00:16:16.589 --> 00:16:21.660
 Spring 让你知道，除了那些

00:16:19.529 --> 00:16:24.209
事情消失了，它回叫你

00:16:21.660 --> 00:16:25.560
你所可能做的事情

00:16:24.209 --> 00:16:27.360
真的应该参与其中，所以

00:16:25.560 --> 00:16:28.440
诸如指定秘密之类的事情

00:16:27.360 --> 00:16:30.000
这种说法自然很

00:16:28.440 --> 00:16:31.640
重要的是您在这里

00:16:30.000 --> 00:16:34.649
正确的做法是提供自定义查询

00:16:31.640 --> 00:16:36.120
你在这里定义去的参数

00:16:34.649 --> 00:16:39.600
进入续集原始陈述集

00:16:36.120 --> 00:16:41.820
足够的权利，我们在这里做

00:16:39.600 --> 00:16:43.829
看起来很明显的定义联系

00:16:41.820 --> 00:16:45.149
为每个计划者定义

00:16:43.829 --> 00:16:47.490
我们只做的连接参数

00:16:45.149 --> 00:16:50.579
就像我们在这里所做的那样

00:16:47.490 --> 00:16:52.649
不会说这很容易，但事实并非如此

00:16:50.579 --> 00:16:53.579
很难，就像我的意思是你知道

00:16:52.649 --> 00:16:55.260
困难的部分实际上是建立

00:16:53.579 --> 00:16:59.220
数据库本身肯定在我的续集中

00:16:55.260 --> 00:17:00.990
没有这个权利，所以我们有一个JDBC 

00:16:59.220 --> 00:17:02.310
模板，这是你知道的

00:17:00.990 --> 00:17:04.980
很多我们不想做的事情

00:17:02.310 --> 00:17:07.679
所以说流线utils点线

00:17:04.980 --> 00:17:11.100
好，我们要做的是其中之一

00:17:07.679 --> 00:17:13.500
创建数据库中的所有数据

00:17:11.100 --> 00:17:16.770
猪肉的生产者和报告

00:17:13.500 --> 00:17:18.630
将有关于每个的信息

00:17:16.770 --> 00:17:21.920
客户和阿里订单分配给

00:17:18.630 --> 00:17:25.949
他们是公共静态类的客户

00:17:21.920 --> 00:17:32.049
订单报告，我们将获得字符串

00:17:25.949 --> 00:17:36.020
姓名电子邮件私人int订单

00:17:32.049 --> 00:17:38.330
计数和长ID好吧，那是

00:17:36.020 --> 00:17:39.860
我猜那是什么客户ID 

00:17:38.330 --> 00:17:43.190
我们可以称之为非常具体

00:17:39.860 --> 00:17:45.260
所以他们把细节

00:17:43.190 --> 00:17:47.929
现在该报告数据是为了

00:17:45.260 --> 00:17:50.630
生成该查询，我将有一个查询

00:17:47.929 --> 00:17:54.340
看起来像这个选择看到

00:17:50.630 --> 00:17:57.919
星号，我将选择一个

00:17:54.340 --> 00:18:00.190
子查询具有子快速计数

00:17:57.919 --> 00:18:05.120
该a的错误数量

00:18:00.190 --> 00:18:11.090
客户，请选择数量

00:18:05.120 --> 00:18:14.840
哦，订单中的ID哦，我们老了

00:18:11.090 --> 00:18:18.620
客户下划线FK等于C ID写

00:18:14.840 --> 00:18:21.770
作为计数，所以让我们看看我们现在得到了什么

00:18:18.620 --> 00:18:24.490
我将使用

00:18:21.770 --> 00:18:28.160
 JDBC模板，所以这里是TVC模板

00:18:24.490 --> 00:18:29.330
查询我们不想得到我们不

00:18:28.160 --> 00:18:30.470
等同于整个对象

00:18:29.330 --> 00:18:31.910
顺便说一句整个方法

00:18:30.470 --> 00:18:33.320
所以我要讲一些我的

00:18:31.910 --> 00:18:35.450
最喜欢的，但是大多数时候我都在使用

00:18:33.320 --> 00:18:37.640
查询，有时我会使用update或

00:18:35.450 --> 00:18:38.660
执行，但有一堆

00:18:37.640 --> 00:18:43.160
他们的变体，所以我们将讨论

00:18:38.660 --> 00:18:50.360
今天一些，所以我们把它放在

00:18:43.160 --> 00:18:53.000
在这里，第二个参数是一个实数

00:18:50.360 --> 00:18:57.919
映射器现在一个真正的映射器是什么

00:18:53.000 --> 00:18:59.990
如果数据是

00:18:57.919 --> 00:19:01.040
如果返回的结果是

00:18:59.990 --> 00:19:03.290
查询您要返回的

00:19:01.040 --> 00:19:05.210
一对一映射到一个对象，所以如果每个

00:19:03.290 --> 00:19:06.770
结果集中的记录映射到

00:19:05.210 --> 00:19:08.240
对象，那么您应该使用一个真实的映射器

00:19:06.770 --> 00:19:10.580
对，因为您可以直接映射它们

00:19:08.240 --> 00:19:14.830
物体，所以我要回去

00:19:10.580 --> 00:19:18.530
客户订单报告的收集

00:19:14.830 --> 00:19:19.850
这样，让我得到

00:19:18.530 --> 00:19:23.690
回来得到那个优点，看看如何

00:19:19.850 --> 00:19:26.000
聪明，直到它现在意识到

00:19:23.690 --> 00:19:27.110
你知道我正在查询的事实

00:19:26.000 --> 00:19:28.970
依靠我当地的资源，所以我可以

00:19:27.110 --> 00:19:31.520
实际点击例如织田

00:19:28.970 --> 00:19:37.910
客户同意或类似的事情

00:19:31.520 --> 00:19:39.860
在这里，它会很聪明地看到

00:19:37.910 --> 00:19:40.190
我正在尝试做的是什么

00:19:39.860 --> 00:19:42.740
说

00:19:40.190 --> 00:19:45.220
我不会失去所有客户，为什么你

00:19:42.740 --> 00:19:45.220
认为那是

00:19:46.810 --> 00:19:52.400
很简单，很聪明哦，凯特

00:19:48.890 --> 00:19:59.660
我想让我们来看看

00:19:52.400 --> 00:20:00.980
我们将再次打开它们

00:19:59.660 --> 00:20:02.570
我不确定这没关系

00:20:00.980 --> 00:20:04.580
要么等待音乐非常聪明，你

00:20:02.570 --> 00:20:06.380
可以真正来点击令牌

00:20:04.580 --> 00:20:08.090
续集声明，它将

00:20:06.380 --> 00:20:10.070
知道你现在想做什么

00:20:08.090 --> 00:20:11.930
每次都给一个回调，所以

00:20:10.070 --> 00:20:14.540
去拜访我要给箱子

00:20:11.930 --> 00:20:15.770
然后它将遍历所有

00:20:14.540 --> 00:20:18.440
记录，这将使我心血来潮

00:20:15.770 --> 00:20:23.000
永远回来这是一个正确的接口， 

00:20:18.440 --> 00:20:24.590
界面是背面

00:20:23.000 --> 00:20:25.940
我得到过去的结果集的时间

00:20:24.590 --> 00:20:27.590
结果集加上当前行

00:20:25.940 --> 00:20:29.210
数字，如果我愿意，我可以做

00:20:27.590 --> 00:20:31.430
但它希望我将其映射到

00:20:29.210 --> 00:20:35.210
自定义订单，所以在这里我要说

00:20:31.430 --> 00:20:40.280
好吧，你知道第一个ID 

00:20:35.210 --> 00:20:43.940
回来后，我们将此ID称为

00:20:40.280 --> 00:20:48.200
想法回来，然后

00:20:43.940 --> 00:20:52.400
艺术家获得字符串名称以及所有这些

00:20:48.200 --> 00:20:58.730
获取字符串电子邮件，然后诚实获取

00:20:52.400 --> 00:21:00.170
算错了好吧，我们可以打电话

00:20:58.730 --> 00:21:02.600
如果你想要的话没关系

00:21:00.170 --> 00:21:05.270
但是它必须匹配我们

00:21:02.600 --> 00:21:07.070
在这里指定好了，这样就完成了

00:21:05.270 --> 00:21:08.300
要记住的一件事是

00:21:07.070 --> 00:21:11.930
 API太旧了

00:21:08.300 --> 00:21:14.480
好吧，这个API就是看这个

00:21:11.930 --> 00:21:16.970
最初写于2001年，所以这是

00:21:14.480 --> 00:21:18.920
已有17年历史的API，但它甚至可以正常工作

00:21:16.970 --> 00:21:21.530
今天比以前更好

00:21:18.920 --> 00:21:23.750
首先想到你看到这些车回来

00:21:21.530 --> 00:21:25.190
接口这是一个模板对象

00:21:23.750 --> 00:21:27.410
在设计模式之后

00:21:25.190 --> 00:21:29.180
模板对象并基本上填充它

00:21:27.410 --> 00:21:30.350
你知道你填写了

00:21:29.180 --> 00:21:31.970
对你很重要，其余的事

00:21:30.350 --> 00:21:33.170
包括所有交易管理

00:21:31.970 --> 00:21:34.760
资源中的初始化

00:21:33.170 --> 00:21:36.290
那种定位和破坏

00:21:34.760 --> 00:21:38.000
的东西已经为您完成，结果

00:21:36.290 --> 00:21:39.410
就是你只是扮演角色

00:21:38.000 --> 00:21:43.030
你在历史上很在意

00:21:39.410 --> 00:21:44.900
 Java 5之前的版本对不起Gadwal 8 

00:21:43.030 --> 00:21:47.060
从历史上讲，那本来是

00:21:44.900 --> 00:21:48.830
像这样的匿名接口

00:21:47.060 --> 00:21:50.540
这些接口适合

00:21:48.830 --> 00:21:52.750
我认为这是真的

00:21:50.540 --> 00:21:55.539
方便，所以我们这里有什么

00:21:52.750 --> 00:21:59.799
好的，请看这是一个

00:21:55.539 --> 00:22:01.030
你不知道不可能结束吗

00:21:59.799 --> 00:22:04.000
更好，我认为这真的很好

00:22:01.030 --> 00:22:06.520
该API可以很好地与

00:22:04.000 --> 00:22:08.049
 Java中的lambdas这个呃，所以现在我们

00:22:06.520 --> 00:22:09.580
有报告，我们要说

00:22:08.049 --> 00:22:14.909
每个，我们只是要打印出来

00:22:09.580 --> 00:22:14.909
每一个都好，我要使用log4j 

00:22:15.120 --> 00:22:19.510
记录器好吧，这是龙目岛，我正在使用

00:22:17.530 --> 00:22:21.460
贷款簿以综合这些领域

00:22:19.510 --> 00:22:25.059
在编译时，好像我已经

00:22:21.460 --> 00:22:28.409
我自己写给他们，好吧，让我们看看

00:22:25.059 --> 00:22:28.409
让我们运行该应用程序

00:22:31.049 --> 00:22:38.289
好吧没有得到这是我们的

00:22:36.490 --> 00:22:40.059
六个记录好了，所以我们得到了

00:22:38.289 --> 00:22:42.730
记录，我们可以看到它正在工作，我们可以

00:22:40.059 --> 00:22:45.070
看我只能数到三等

00:22:42.730 --> 00:22:46.150
很好，很简单，您可能已经看过

00:22:45.070 --> 00:22:49.360
像以前那样

00:22:46.150 --> 00:22:52.450
让我们再往前走一点

00:22:49.360 --> 00:22:54.429
让我们做一对多，这是

00:22:52.450 --> 00:22:55.690
实际上，每条记录都非常简单

00:22:54.429 --> 00:22:57.850
我们回到了结果集中

00:22:55.690 --> 00:22:59.590
映射到一个对象，这很简单

00:22:57.850 --> 00:23:03.270
现在我们要做一对多

00:22:59.590 --> 00:23:05.289
每个记录可能必须汇总到一个

00:23:03.270 --> 00:23:07.150
聚集我们的客户将获得

00:23:05.289 --> 00:23:08.289
所有的客户和所有的错误和

00:23:07.150 --> 00:23:09.370
我们不想做某事

00:23:08.289 --> 00:23:11.260
效率低下，我们不想设置所有

00:23:09.370 --> 00:23:13.720
客户，然后访问每个

00:23:11.260 --> 00:23:15.309
循环，然后在

00:23:13.720 --> 00:23:16.330
具有所有记录的数据库

00:23:15.309 --> 00:23:18.220
那最大的效率会很低

00:23:16.330 --> 00:23:22.330
我们做到了n加一

00:23:18.220 --> 00:23:30.690
问题，而不是那样做，让我们去做

00:23:22.330 --> 00:23:32.890
创建客户和订单的示例

00:23:30.690 --> 00:23:34.950
没有数，所以我们说我们

00:23:32.890 --> 00:23:38.919
实际上会得到油

00:23:34.950 --> 00:23:42.210
命令自己还好，和

00:23:38.919 --> 00:23:45.760
在使用JDBC模板之前

00:23:42.210 --> 00:23:46.990
好的，我们将使用JB的

00:23:45.760 --> 00:23:49.780
进行呼叫的模板

00:23:46.990 --> 00:23:53.780
数据库，所以我们想说字符串utils 

00:23:49.780 --> 00:23:56.150
线还可以

00:23:53.780 --> 00:24:01.670
我们要说的是杰米的

00:23:56.150 --> 00:24:11.560
告诉它查询选择看到该ID 

00:24:01.670 --> 00:24:16.220
 di作为CID哦，那个ID作为oh ID和O 

00:24:11.560 --> 00:24:20.860
星号不想看到

00:24:16.220 --> 00:24:20.860
星号为什么不从中看到那个星号

00:24:21.160 --> 00:24:31.610
从客户那里看到左加入订单o 

00:24:27.130 --> 00:24:33.620
看到ID等于老客户FK 

00:24:31.610 --> 00:24:36.080
好吧，所以我们在做左外

00:24:33.620 --> 00:24:37.370
加入这里，我们将带你回去

00:24:36.080 --> 00:24:43.160
知道你能想象得到的吗

00:24:37.370 --> 00:24:48.830
回来，你知道让我们看看我们会

00:24:43.160 --> 00:24:54.290
回来，你知道行，你知道Josh josh 

00:24:48.830 --> 00:24:57.560
乔希，你知道，然后再说一个

00:24:54.290 --> 00:24:59.150
然后我们将其合并

00:24:57.560 --> 00:25:03.110
连同订单结果

00:24:59.150 --> 00:25:04.670
所以会是ABC，然后您就会知道OID 

00:25:03.110 --> 00:25:06.740
等于1 etcetera，所以我有

00:25:04.670 --> 00:25:08.900
那然后下一行将是

00:25:06.740 --> 00:25:12.560
基本相同，除了这将是2 

00:25:08.900 --> 00:25:19.820
这将是def和下一行

00:25:12.560 --> 00:25:21.920
会是G，你知道FGHI等，所以

00:25:19.820 --> 00:25:24.500
来自客户的信息是

00:25:21.920 --> 00:25:26.150
这是在左列不足

00:25:24.500 --> 00:25:28.640
最后两列，但之后的所有内容

00:25:26.150 --> 00:25:29.720
那是订单ID，所以怎么办

00:25:28.640 --> 00:25:31.040
女人是在做左外连接吗

00:25:29.720 --> 00:25:33.620
意味着我们至少会得到

00:25:31.040 --> 00:25:35.150
一次又一次的信息

00:25:33.620 --> 00:25:37.100
如果没有订单，则可能为null 

00:25:35.150 --> 00:25:38.630
如果有

00:25:37.100 --> 00:25:40.640
一个以上的订单

00:25:38.630 --> 00:25:42.110
重复记录在左侧所有

00:25:40.640 --> 00:25:43.490
这些剩下的所有这些信息是

00:25:42.110 --> 00:25:44.330
复制但我们得到他们的真实

00:25:43.490 --> 00:25:46.520
我们关心的信息

00:25:44.330 --> 00:25:50.320
现在我们到达另一个订单

00:25:46.520 --> 00:25:52.820
像这样录制然后我们将开始看到

00:25:50.320 --> 00:25:54.650
你知道小学的，你可能知道

00:25:52.820 --> 00:25:59.480
会循环简，我猜是什么

00:25:54.650 --> 00:26:02.670
简和简简冷静写作等等

00:25:59.480 --> 00:26:05.250
这将是詹姆斯的信息

00:26:02.670 --> 00:26:08.610
她可能会让你知道与众不同

00:26:05.250 --> 00:26:10.740
订单等等

00:26:08.610 --> 00:26:12.150
同样的技能好吧，在这种情况下

00:26:10.740 --> 00:26:14.820
我们将遍历所有

00:26:12.150 --> 00:26:16.950
记录以及任何记录之一

00:26:14.820 --> 00:26:18.720
是无论

00:26:16.950 --> 00:26:20.400
客户与这里不同，或者

00:26:18.720 --> 00:26:22.470
打破，我们是一个新的聚合对象

00:26:20.400 --> 00:26:24.179
并积累和结束，与此同时

00:26:22.470 --> 00:26:26.010
正如我们正在经历的，想法是

00:26:24.179 --> 00:26:27.630
同样，我们将累积所有

00:26:26.010 --> 00:26:28.530
记录到我们已经汇总

00:26:27.630 --> 00:26:32.240
创建了，所以我要创建一个

00:26:28.530 --> 00:26:36.419
聚合从此处开始

00:26:32.240 --> 00:26:39.299
总的来说，我的意思是我会得到国王

00:26:36.419 --> 00:26:40.500
再次记入订单汇总，因此

00:26:39.299 --> 00:26:42.030
好的，所以当下线时

00:26:40.500 --> 00:26:43.980
并告诉最终我们拥有所有数据

00:26:42.030 --> 00:26:45.510
在信息收集中

00:26:43.980 --> 00:26:46.440
这意味着我们必须能够

00:26:45.510 --> 00:26:48.030
遍历不同的记录

00:26:46.440 --> 00:26:49.860
直到我们满足特定条件

00:26:48.030 --> 00:26:52.200
这意味着真正的

00:26:49.860 --> 00:26:53.220
我们之前使用的地图方法

00:26:52.200 --> 00:26:54.750
我们在这里工作不充分

00:26:53.220 --> 00:26:56.760
使我们有能力

00:26:54.750 --> 00:26:59.460
遍历数据，所以在这里我们使用

00:26:56.760 --> 00:27:02.190
结果集提取器好，所以我要去

00:26:59.460 --> 00:27:06.110
创建结果集提取器以

00:27:02.190 --> 00:27:10.380
创建客户记录的集合

00:27:06.110 --> 00:27:12.470
所以我们需要一个客户类型

00:27:10.380 --> 00:27:16.790
可以以此为基础，但这不是

00:27:12.470 --> 00:27:16.790
任何延伸的最终代表

00:27:17.600 --> 00:27:27.120
不能客户，什么是ID和

00:27:24.120 --> 00:27:31.890
我们需要，所以我们想要一套人才

00:27:27.120 --> 00:27:32.600
的订单有些订单等于新的哈希

00:27:31.890 --> 00:27:35.740
组

00:27:32.600 --> 00:27:35.740
 [掌声] 

00:27:37.160 --> 00:27:48.260
公共静态类顺序私有字符串

00:27:42.320 --> 00:28:00.720
私人长ID私人字符串仍然

00:27:48.260 --> 00:28:02.190
偏斜对这个有好处，好吗

00:28:00.720 --> 00:28:10.790
我们有客户，我们有

00:28:02.190 --> 00:28:10.790
现在订购，我们已经有了这两件事

00:28:12.080 --> 00:28:17.040
我们想要做的是

00:28:14.520 --> 00:28:19.350
是提取器访问每个

00:28:17.040 --> 00:28:21.060
这些记录中的一个

00:28:19.350 --> 00:28:22.140
影响我们刚刚描述的逻辑

00:28:21.060 --> 00:28:24.030
在这里，有点混乱

00:28:22.140 --> 00:28:25.470
但我认为这很容易

00:28:24.030 --> 00:28:27.630
了解您何时会看到它

00:28:25.470 --> 00:28:28.800
行动，所以首先我们开始

00:28:27.630 --> 00:28:31.910
 while循环正确，所以我们键入

00:28:28.800 --> 00:28:34.200
 while循环在这里哇，我们父亲有下一个

00:28:31.910 --> 00:28:35.880
让我们访问每个记录，现在我们有一个

00:28:34.200 --> 00:28:38.160
我们必须积累的条件，让我们

00:28:35.880 --> 00:28:41.370
得到当前的ID ID等于说实话

00:28:38.160 --> 00:28:44.700
久了，那将是客户ID 

00:28:41.370 --> 00:28:48.930
 sub C积累了，现在我们要说

00:28:44.700 --> 00:28:51.960
当我们现在停下来，然后我们有

00:28:48.930 --> 00:28:54.270
我们说一个条件，如果当前

00:28:51.960 --> 00:28:57.800
我们尚未定义的客户

00:28:54.270 --> 00:29:03.630
我们将创建一个当前客户

00:28:57.800 --> 00:29:08.850
让我们说这个，如果当前

00:29:03.630 --> 00:29:13.700
客户，如果当前客户应该

00:29:08.850 --> 00:29:17.430
等于null或当前客户获取ID 

00:29:13.700 --> 00:29:19.680
不等于ID正确，然后

00:29:17.430 --> 00:29:21.960
这个工作，我们还需要订购这个

00:29:19.680 --> 00:29:24.420
根据ID，我们不是，所以我们需要查看订单

00:29:21.960 --> 00:29:28.320
通过CID，它将始终存在

00:29:24.420 --> 00:29:31.740
那个顺序，所以我们的意思是我们还好

00:29:28.320 --> 00:29:35.970
而这将使我们

00:29:31.740 --> 00:29:37.200
给我们一个客户集合，就像我们

00:29:35.970 --> 00:29:41.890
想要好的

00:29:37.200 --> 00:29:45.020
有我们的有我们的

00:29:41.890 --> 00:29:47.059
告诉你你可能会感到困惑

00:29:45.020 --> 00:29:52.820
我同意，你知道我们有这个， 

00:29:47.059 --> 00:29:56.870
现在我们说这是否为空

00:29:52.820 --> 00:30:00.080
如果为空或当前客户

00:29:56.870 --> 00:30:02.809
 ID不相等，则我们支付了当前

00:30:00.080 --> 00:30:04.159
客户，因此当前客户等于

00:30:02.809 --> 00:30:06.380
我们必须创建一个新客户

00:30:04.159 --> 00:30:07.580
结果设置了我们的新客户， 

00:30:06.380 --> 00:30:11.899
我们要给它一个结果集

00:30:07.580 --> 00:30:18.200
这里的信息很诚实

00:30:11.899 --> 00:30:22.309
 CID RS获取字符串名称RS获取字符串

00:30:18.200 --> 00:30:24.740
电子邮件，然后为

00:30:22.309 --> 00:30:27.830
订单，我要添加一些东西

00:30:24.740 --> 00:30:31.940
当我们经历现在的客户时

00:30:27.830 --> 00:30:36.890
点得到订单好，我们必须映射

00:30:31.940 --> 00:30:38.630
当前信息（如果有） 

00:30:36.890 --> 00:30:41.270
该记录，所以当我们要

00:30:38.630 --> 00:30:43.070
一旦有订单就创建订单

00:30:41.270 --> 00:30:46.070
我们必须从订单中取出订单

00:30:43.070 --> 00:30:49.760
当前结果并尝试创建

00:30:46.070 --> 00:30:52.580
这是我们的新订单，订单是

00:30:49.760 --> 00:30:56.630
期待一个ID和一个SKU，让我们开始吧

00:30:52.580 --> 00:31:10.309
一些防御性编码，我们要

00:30:56.630 --> 00:31:15.890
说c RS获得长o ID和字符串SKU 

00:31:10.309 --> 00:31:21.200
等于R的股票得到字符串XQ，所以现在

00:31:15.890 --> 00:31:26.470
我们是说创建OID并倾斜

00:31:21.200 --> 00:31:26.470
如果所有aidid不等于null 

00:31:29.950 --> 00:31:33.130
好吧

00:31:36.039 --> 00:31:43.490
永远都是正确的，也许并非永远都是真的

00:31:41.299 --> 00:31:47.929
好吧，我会好好投掷

00:31:43.490 --> 00:31:51.950
我想是例外，无论如何

00:31:47.929 --> 00:31:54.350
不想为此担心，但我们想要

00:31:51.950 --> 00:31:55.730
将这些东西添加到

00:31:54.350 --> 00:31:57.590
当前集合，所以我们将其包装

00:31:55.730 --> 00:31:59.870
订单，基本上想创建它

00:31:57.590 --> 00:32:04.700
只有当它是正确的权利，所以我们会

00:31:59.870 --> 00:32:08.029
现在说获得订单的当前客户

00:32:04.700 --> 00:32:11.149
加上等于顺序的权利，所以他们

00:32:08.029 --> 00:32:14.090
遍历您的数据，我们

00:32:11.149 --> 00:32:16.460
确保在添加数据时

00:32:14.090 --> 00:32:19.639
当你积累到

00:32:16.460 --> 00:32:21.200
现在要收集订单

00:32:19.639 --> 00:32:22.820
窃取我们拥有的所有客户

00:32:21.200 --> 00:32:24.049
对，因为我们要去

00:32:22.820 --> 00:32:25.610
最终达到这种条件，我们

00:32:24.049 --> 00:32:28.039
必须重置客户，所以我要

00:32:25.610 --> 00:32:29.750
经常将客户保存给某人

00:32:28.039 --> 00:32:33.440
待会儿再来，所以我要搅拌一下

00:32:29.750 --> 00:32:35.389
在主要方面

00:32:33.440 --> 00:32:37.429
客户在那里的钥匙，我们将

00:32:35.389 --> 00:32:40.970
稍后再回来，以便客户映射

00:32:37.429 --> 00:32:42.350
等于新的哈希图，记住要更改

00:32:40.970 --> 00:32:46.429
进入并发映射（如果有） 

00:32:42.350 --> 00:32:50.480
使这个多线程和

00:32:46.429 --> 00:32:52.730
并发我可以自定义地图，如果

00:32:50.480 --> 00:32:59.269
那不是正常的，等等，很好

00:32:52.730 --> 00:33:01.940
然后自定义地图，这样

00:32:59.269 --> 00:33:04.340
我们将再次走同样的路， 

00:33:01.940 --> 00:33:06.350
再次多次，所以理论上想要

00:33:04.340 --> 00:33:08.269
打电话给那么多订单

00:33:06.350 --> 00:33:09.830
所有这些都可能导致我们

00:33:08.269 --> 00:33:11.419
完成输入，但同样是按键操作

00:33:09.830 --> 00:33:13.399
它永远不会得到它不是一个

00:33:11.419 --> 00:33:16.490
我们会加一些东西，让您知道更多

00:33:13.399 --> 00:33:18.950
客户或相同的密钥，所以很好

00:33:16.490 --> 00:33:24.259
稍后再利用它

00:33:18.950 --> 00:33:26.779
所以你去那里就是我们当前的

00:33:24.259 --> 00:33:28.370
我们知道的逻辑然后又有趣

00:33:26.779 --> 00:33:32.990
返回数据我想返回

00:33:28.370 --> 00:33:36.049
客户地图点值使我们

00:33:32.990 --> 00:33:39.880
这样可以收集客户

00:33:36.049 --> 00:33:46.250
这是怎么了

00:33:39.880 --> 00:33:53.620
 RS那下一个我不知道的样子

00:33:46.250 --> 00:33:53.620
它应该在我看来

00:33:56.140 --> 00:34:00.530
好吧，我不知道智能会不会

00:33:58.520 --> 00:34:02.420
不同意我不同意

00:34:00.530 --> 00:34:06.920
朋友，所以我们现在有了这个while循环

00:34:02.420 --> 00:34:12.710
而这就是为什么它不会循环的原因

00:34:06.920 --> 00:34:15.610
你是对的，所以摆脱它，我们

00:34:12.710 --> 00:34:20.990
现在有了我们简单的逻辑

00:34:15.610 --> 00:34:22.190
很好地积累一切的逻辑

00:34:20.990 --> 00:34:24.020
对我们而言，这再次非常繁琐

00:34:22.190 --> 00:34:26.240
这有点复杂，但可以肯定

00:34:24.020 --> 00:34:27.980
胜过管理所有交易

00:34:26.240 --> 00:34:29.630
并正确地做到这一点，至少我们

00:34:27.980 --> 00:34:31.220
从中获得一些收益

00:34:29.630 --> 00:34:33.290
这也使自己成为lambda 

00:34:31.220 --> 00:34:36.700
所以我们在那儿写一点

00:34:33.290 --> 00:34:40.280
去那里是我们的结果集提取器， 

00:34:36.700 --> 00:34:43.700
我们将使用结果六结果

00:34:40.280 --> 00:34:46.909
在这里设置提取器以获取数据

00:34:43.700 --> 00:34:50.750
现在向客户说每个日志信息

00:34:46.909 --> 00:34:59.360
然后我们又离开了记录仪，我们得到了

00:34:50.750 --> 00:35:00.650
通过log4j记录器可以，所以在那里

00:34:59.360 --> 00:35:02.360
让我们看看它给我们带来了什么

00:35:00.650 --> 00:35:03.490
马里亚诺开始订购这些，以便我们

00:35:02.360 --> 00:35:06.140
可以看到最伟大的最新消息

00:35:03.490 --> 00:35:08.780
最后，因为我们有多个

00:35:06.140 --> 00:35:11.240
应用程序运行者，让我回头

00:35:08.780 --> 00:35:17.030
并让这个数字一开始

00:35:11.240 --> 00:35:18.470
首先发布，重置应用程序，然后

00:35:17.030 --> 00:35:23.660
我做了什么

00:35:18.470 --> 00:35:28.960
看到我不存在客户吗

00:35:23.660 --> 00:35:33.579
我不知道

00:35:28.960 --> 00:35:35.980
哦kutiman哈哈好的好聪明

00:35:33.579 --> 00:35:37.630
不是疯了，现在是我

00:35:35.980 --> 00:35:40.660
我曾两次猜测开斋节

00:35:37.630 --> 00:35:47.230
今晚，我错了，那不是

00:35:40.660 --> 00:35:49.480
好订单，很明显

00:35:47.230 --> 00:35:53.910
看看我是否在做某事

00:35:49.480 --> 00:35:53.910
傻在这里留下加盟订单哦哦

00:35:54.059 --> 00:35:57.450
让我们再试一次

00:36:06.140 --> 00:36:17.819
源主要资源数据及其续集

00:36:08.959 --> 00:36:23.390
续集性感ID的架构会看到我

00:36:17.819 --> 00:36:23.390
重复订单OID可以

00:36:33.869 --> 00:36:41.599
左-ID消失的偶像哦

00:36:36.869 --> 00:36:48.199
客户FK这样的数据模式

00:36:41.599 --> 00:36:52.369
客户FK和我的朋友Lucas编辑

00:36:48.199 --> 00:36:56.729
他是驾驶员Jacobs的创造者

00:36:52.369 --> 00:36:59.099
面向对象的查询API我敢肯定

00:36:56.729 --> 00:37:01.019
现在嘲笑我说这是

00:36:59.099 --> 00:37:03.449
到底为什么要使用类型安全

00:37:01.019 --> 00:37:04.650
通过Java启用的续集或

00:37:03.449 --> 00:37:06.449
排队，他可能有一个好点

00:37:04.650 --> 00:37:07.890
在那里，这是一个很好的理由去看看

00:37:06.449 --> 00:37:10.789
我在那做的另一个 spring 技巧 视频

00:37:07.890 --> 00:37:14.249
还有我的蜜蜂，所以这只是另一个

00:37:10.789 --> 00:37:16.739
以续集为中心或M型的东西

00:37:14.249 --> 00:37:23.670
像Java OQ这样的，好吧， 

00:37:16.739 --> 00:37:25.920
 ID CID好吧，让我们看看这是否给我们

00:37:23.670 --> 00:37:30.089
我们一直期望的结果

00:37:25.920 --> 00:37:33.319
尽可能使用自己的工具

00:37:30.089 --> 00:37:36.319
像它会工作应该很好

00:37:33.319 --> 00:37:36.319
所以

00:37:40.790 --> 00:37:45.960
是的，那应该正是我们

00:37:42.900 --> 00:37:57.990
期待，让我们继续，现在运行

00:37:45.960 --> 00:37:59.250
这段代码再次哈哈，他们很酷，所以那里

00:37:57.990 --> 00:38:06.390
你去那些有结果

00:37:59.250 --> 00:38:18.020
我们所期望的，除了发生了什么

00:38:06.390 --> 00:38:18.020
循环中有e 

00:38:28.109 --> 00:38:38.829
等一下我的续集在哪

00:38:30.640 --> 00:38:43.869
声明在这里再次运行这个是的

00:38:38.829 --> 00:38:46.319
看起来不错，所以我们应该拥有我们应该

00:38:43.869 --> 00:38:46.319
有

00:38:58.540 --> 00:39:05.110
哦，我已经两次没有开玩笑了

00:39:01.810 --> 00:39:06.520
好吧，我在那里做了两次

00:39:05.110 --> 00:39:08.380
好，所以我们又参加了这个程序

00:39:06.520 --> 00:39:09.280
她看起来的时间以及那是什么时候

00:39:08.380 --> 00:39:12.130
小挑逗好吗

00:39:09.280 --> 00:39:15.610
哦，我们去看看那个，所以现在我们

00:39:12.130 --> 00:39:18.880
有六个记录，正如我们期望的那样

00:39:15.610 --> 00:39:25.350
其中有数据，而有些则没有

00:39:18.880 --> 00:39:32.230
因此，定单作为具有0到no的订单

00:39:25.350 --> 00:39:36.310
为什么这样，当我说如果海蒂不是

00:39:32.230 --> 00:39:42.600
等于null并查看结果

00:39:36.310 --> 00:39:42.600
从这个结束

00:39:51.590 --> 00:39:56.590
如果客户FK否，请尝试

00:39:55.610 --> 00:39:59.560
一

00:39:56.590 --> 00:40:11.380
为什么呢？为什么IDE如此确定

00:39:59.560 --> 00:40:11.380
那应该没有哦，好吧

00:40:12.660 --> 00:40:25.340
我可以

00:40:31.730 --> 00:40:36.859
啊，让它变得更好，好吧，我们可以

00:40:34.790 --> 00:40:38.540
看到空订单空订单，但我们

00:40:36.859 --> 00:40:40.970
剩下的订单都可以了

00:40:38.540 --> 00:40:42.530
现在我们有一个非常简单的例子

00:40:40.970 --> 00:40:43.849
有一对多的关系，是的

00:40:42.530 --> 00:40:46.040
那有点乏味，那是一个

00:40:43.849 --> 00:40:47.119
进行了一些心理体操

00:40:46.040 --> 00:40:49.040
那个样子，但我们了解我们在做什么

00:40:47.119 --> 00:40:50.540
这样做，然后比如果

00:40:49.040 --> 00:40:52.070
您必须手动完成

00:40:50.540 --> 00:40:54.109
所以我很高兴我们有机会做

00:40:52.070 --> 00:40:56.150
这是因为它确实展示了什么

00:40:54.109 --> 00:40:57.140
现在可能会更糟，这就是

00:40:56.150 --> 00:40:59.660
实际上并非唯一的方法

00:40:57.140 --> 00:41:01.730
实际上还有一些空间

00:40:59.660 --> 00:41:03.859
即使在这里也有所改善

00:41:01.730 --> 00:41:05.480
示例，让我们以这个示例为例

00:41:03.859 --> 00:41:08.690
更进一步，我将使用第三方

00:41:05.480 --> 00:41:13.820
生态系统图书馆称为简单公寓

00:41:08.690 --> 00:41:20.690
映射器好吧，知道这个，让我们看看这个

00:41:13.820 --> 00:41:21.410
例子，我们要命名简单的公寓

00:41:20.690 --> 00:41:25.670
映射器

00:41:21.410 --> 00:41:27.890
让我们订购三个相同的基本域

00:41:25.670 --> 00:41:30.320
模型，我们只是要使用第三方

00:41:27.890 --> 00:41:31.910
这里的库称为简单平面映射器

00:41:30.320 --> 00:41:33.890
我没有在十字路口

00:41:31.910 --> 00:41:35.510
只是，现在还不是

00:41:33.890 --> 00:41:38.540
现在它的复选框很简单

00:41:35.510 --> 00:41:43.000
映射器是值得一提的产品

00:41:38.540 --> 00:41:48.410
这是一个第三方项目

00:41:43.000 --> 00:41:50.599
允许您通过知道CSV的方式映射数据

00:41:48.410 --> 00:41:52.250
数据X和所有数据（无论后续数据） 

00:41:50.599 --> 00:41:53.720
它与许多

00:41:52.250 --> 00:41:56.839
各种有趣的图书馆

00:41:53.720 --> 00:41:59.240
在那里，你知道其中之一

00:41:56.839 --> 00:42:02.990
整合当然是 Spring 了，那又如何呢？ 

00:41:59.240 --> 00:42:04.579
是3.1 8.0，我认为我们是如此

00:42:02.990 --> 00:42:05.119
我们将使用这个，我们使用一个简单的

00:42:04.579 --> 00:42:08.150
思维导图

00:42:05.119 --> 00:42:10.369
使所有这些可怕的代码

00:42:08.150 --> 00:42:13.310
就走了，所以它变得简单得多

00:42:10.369 --> 00:42:14.390
现在的代码只是几行

00:42:13.310 --> 00:42:15.950
我们要做的是替换

00:42:14.390 --> 00:42:17.990
所有逻辑所有手册

00:42:15.950 --> 00:42:21.819
结果集的累加逻辑

00:42:17.990 --> 00:42:27.050
使用我们为我们创建的提取器

00:42:21.819 --> 00:42:31.280
简化，永不让RS e等于JDBC 

00:42:27.050 --> 00:42:37.869
模板Joosten是一个制图厂

00:42:31.280 --> 00:42:44.769
点新实例点添加键

00:42:37.869 --> 00:42:46.450
钥匙就是钥匙

00:42:44.769 --> 00:42:48.700
我们想在右边打破

00:42:46.450 --> 00:42:50.079
积累密钥，然后新

00:42:48.700 --> 00:42:54.670
提取器将是类型的结果

00:42:50.079 --> 00:42:56.109
不是用户客户的鸭子类就可以了

00:42:54.670 --> 00:43:02.410
那正确吗

00:42:56.109 --> 00:43:06.519
看起来不错，是新实例

00:43:02.410 --> 00:43:08.969
引用正确的客户外观

00:43:06.519 --> 00:43:08.969
对我好

00:43:11.570 --> 00:43:19.190
好吧，这是一个隐含的好吧，因为

00:43:15.140 --> 00:43:21.380
从那个特别是不是

00:43:19.190 --> 00:43:28.280
是的结果是提取了她的另一个词

00:43:21.380 --> 00:43:29.750
 Spring 还好，基本上我可以

00:43:28.280 --> 00:43:33.650
重写测验一点点

00:43:29.750 --> 00:43:36.350
在这里反映这一点，你知道要反映

00:43:33.650 --> 00:43:38.960
为我们管理的事实

00:43:36.350 --> 00:43:40.670
通过这个基于约定的东西，但这是

00:43:38.960 --> 00:43:44.570
没什么大不了的，所以我们要做的是说

00:43:40.670 --> 00:43:45.790
选择CID作为ID，让我们写这个

00:43:44.570 --> 00:43:51.050
在这里创建一点

00:43:45.790 --> 00:43:55.670
 sexy IDs ID看到的名字就是名字

00:43:51.050 --> 00:43:58.010
那个电子邮件像电子邮件一样整洁有序

00:43:55.670 --> 00:43:59.600
再一次，你知道一个收藏

00:43:58.010 --> 00:44:01.640
在很多方面，很多方面是

00:43:59.600 --> 00:44:03.530
每个订单的托收订单ID为

00:44:01.640 --> 00:44:13.930
叫一个ID，所以它的订单下划线是ID 

00:44:03.530 --> 00:44:23.200
 o点SKU作为订单SKU，并从

00:44:13.930 --> 00:44:31.720
客户看到左加入我们加入

00:44:23.200 --> 00:44:40.640
 C点客户FK上的订单o等于o 

00:44:31.720 --> 00:44:42.770
通过ID顺序查看ID旁边的ID 

00:44:40.640 --> 00:44:43.850
对我来说看起来不错，让我们现在尝试一下， 

00:44:42.770 --> 00:44:46.600
我们应该给这个

00:44:43.850 --> 00:44:46.600
像以前一样的结果

00:44:49.460 --> 00:44:55.890
让我们看看我们已经错了哦

00:44:54.740 --> 00:44:59.069
抱歉

00:44:55.890 --> 00:45:07.019
哦那个哦

00:44:59.069 --> 00:45:09.650
等于看到ID得到那些

00:45:07.019 --> 00:45:09.650
事情倒退

00:45:12.250 --> 00:45:19.359
好看，我还不错

00:45:14.800 --> 00:45:22.690
是的，我这样做了，如果你看看这个，我们可以

00:45:19.359 --> 00:45:25.780
看到在这种情况下不是这样

00:45:22.690 --> 00:45:27.580
足以创建无订单清空

00:45:25.780 --> 00:45:28.930
正确的行，所以有点

00:45:27.580 --> 00:45:31.180
真可惜你可以参观

00:45:28.930 --> 00:45:33.400
记录并查看是否

00:45:31.180 --> 00:45:37.180
他们不是，例如让我们左看

00:45:33.400 --> 00:45:47.740
外连接确实有所作为我

00:45:37.180 --> 00:45:49.660
想知道现在是否在这里有所作为

00:45:47.740 --> 00:45:52.000
它给了我们诺尔斯，这有点

00:45:49.660 --> 00:45:54.490
不幸的是，但是你可以再次得到

00:45:52.000 --> 00:45:56.500
 99％的代码会自动在那里

00:45:54.490 --> 00:45:58.510
您所要做的就是访问

00:45:56.500 --> 00:46:00.700
结果，然后将其发送回

00:45:58.510 --> 00:46:04.540
客户对，所以我可以说客户

00:46:00.700 --> 00:46:12.250
思想流点图，你知道看

00:46:04.540 --> 00:46:13.960
看到获取订单流，您知道您

00:46:12.250 --> 00:46:17.830
可以取代它，所以我会你

00:46:13.960 --> 00:46:24.750
要像这样过滤每个人，然后

00:46:17.830 --> 00:46:33.700
你会说我是C点订单点

00:46:24.750 --> 00:46:34.660
拥有或拥有权利的流

00:46:33.700 --> 00:46:39.070
看到任何比赛

00:46:34.660 --> 00:46:47.650
哦，哦，获取ID应该等于null 

00:46:39.070 --> 00:46:51.430
如果没有，则正确的布尔值没有值

00:46:47.650 --> 00:46:56.010
您知道的价值返回没有价值

00:46:51.430 --> 00:46:56.010
所以基本上我们要说保持

00:46:57.300 --> 00:47:03.040
过滤器实际上我们甚至可以做一个过滤器

00:46:59.580 --> 00:47:05.320
所以如果它不为空，那么我们保持

00:47:03.040 --> 00:47:10.200
否则就不行了，所以我们得到了结果

00:47:05.320 --> 00:47:14.650
是我们可以收集的信息流

00:47:10.200 --> 00:47:16.660
要设置的收藏家将其放入

00:47:14.650 --> 00:47:20.589
更新集

00:47:16.660 --> 00:47:25.180
它被正确更新，然后变成

00:47:20.589 --> 00:47:28.660
我们实际上保持的东西

00:47:25.180 --> 00:47:37.690
如果您这样做正确的话，这是更新的

00:47:28.660 --> 00:47:43.539
没有地图没有较早的值，好吧

00:47:37.690 --> 00:47:48.329
看看是否没有订单值，然后看看

00:47:43.539 --> 00:47:49.780
设置订单等于新的哈希集

00:47:48.329 --> 00:47:50.799
我们去

00:47:49.780 --> 00:47:54.819
那好多了，所以现在我只是

00:47:50.799 --> 00:47:55.660
返回到c返回c好，所以

00:47:54.819 --> 00:47:57.490
清洁工还可以

00:47:55.660 --> 00:48:02.950
结果当然是我现在有一个

00:47:57.490 --> 00:48:04.359
更新了客户设置，我们甚至可以

00:48:02.950 --> 00:48:06.880
只是给顾客起个名字而已

00:48:04.359 --> 00:48:08.200
肮脏，但又没人会知道

00:48:06.880 --> 00:48:10.089
那会藏在没有人的代码后面

00:48:08.200 --> 00:48:13.780
其他人会看到，它仍然便宜

00:48:10.089 --> 00:48:18.250
比做一个N加1的查询

00:48:13.780 --> 00:48:19.240
那里的东西，所以现在空了

00:48:18.250 --> 00:48:22.359
数组列表

00:48:19.240 --> 00:48:23.650
好，非常非常快，现在我们有几个

00:48:22.359 --> 00:48:25.960
写入数据的不同方式

00:48:23.650 --> 00:48:28.660
看看效果不错

00:48:25.960 --> 00:48:31.510
在这种情况下，复杂度大大降低

00:48:28.660 --> 00:48:33.369
对，加工的真正肉是

00:48:31.510 --> 00:48:36.760
在那里，这是你知道的

00:48:33.369 --> 00:48:38.650
实际上比然后更快

00:48:36.760 --> 00:48:40.480
手写查询，因为它正在执行

00:48:38.650 --> 00:48:41.799
很多简短的汇编之类的

00:48:40.480 --> 00:48:44.079
东西，所以这是你合理地知道

00:48:41.799 --> 00:48:45.460
有效率的时候

00:48:44.079 --> 00:48:46.779
这样做是为了进行成本效益分析

00:48:45.460 --> 00:48:48.010
必须参与以确定是否

00:48:46.779 --> 00:48:51.220
实际收益是

00:48:48.010 --> 00:48:55.329
性能提升，希望您会继续

00:48:51.220 --> 00:48:57.940
现在当然是活动的一面

00:48:55.329 --> 00:48:59.920
让他们我们读了一些数据让我们

00:48:57.940 --> 00:49:02.589
看看看数据看

00:48:59.920 --> 00:49:04.150
所以在这里我将使用我们已经阅读的

00:49:02.589 --> 00:49:07.599
那我们不要看写数据，所以

00:49:04.150 --> 00:49:11.829
模板中的JDBC模板更改

00:49:07.599 --> 00:49:14.400
客服让我们来做JB Simplot 

00:49:11.829 --> 00:49:16.980
作家，我们去

00:49:14.400 --> 00:49:21.849
实现应用程序运行程序并

00:49:16.980 --> 00:49:23.650
在这里它将是一个组件或

00:49:21.849 --> 00:49:25.260
甚至更好的配置，因为

00:49:23.650 --> 00:49:28.200
我们可能会在里面创建其他一些beans

00:49:25.260 --> 00:49:31.170
这将是一个配置类型

00:49:28.200 --> 00:49:34.589
有一个命令，我们怎么说最后一个

00:49:31.170 --> 00:49:38.820
一个是3，所以在此之前，它将有

00:49:34.589 --> 00:49:39.869
一个记录器好吧，这就是

00:49:38.820 --> 00:49:42.690
为了我们做到这一点，我们要

00:49:39.869 --> 00:49:47.579
需要注入JDBC writer，这是一个

00:49:42.690 --> 00:49:51.030
私人先生jvc模板好吧

00:49:47.579 --> 00:49:52.320
添加构造函数参数，然后在这里

00:49:51.030 --> 00:49:53.869
我们想写一些数据到

00:49:52.320 --> 00:49:55.980
我要创建服务的数据库

00:49:53.869 --> 00:49:59.040
我们可以用来实际写入数据

00:49:55.980 --> 00:50:00.480
到数据库，所以实际上我们可以

00:49:59.040 --> 00:50:03.890
想在这里创建服务

00:50:00.480 --> 00:50:06.839
公共静态类客户服务

00:50:03.890 --> 00:50:09.270
好吧，我们要做的就是

00:50:06.839 --> 00:50:14.630
要和戴维斯约会， 

00:50:09.270 --> 00:50:21.869
证明它正在工作，所以公共无效

00:50:14.630 --> 00:50:24.000
插入字符串，你知道我们甚至可以

00:50:21.869 --> 00:50:29.970
直接执行此操作，让我们取笑jbz 

00:50:24.000 --> 00:50:32.250
模板直接优先jvc模板

00:50:29.970 --> 00:50:34.230
构造函数参数，这里是什么

00:50:32.250 --> 00:50:40.170
我会说的是JDBC， 

00:50:34.230 --> 00:50:41.490
模板点是啊，执行不正确

00:50:40.170 --> 00:50:42.900
好吧，我会更新一些数据，所以我想

00:50:41.490 --> 00:50:45.329
更新，这里我们有一些

00:50:42.900 --> 00:50:47.940
不同的重载，但我们想放

00:50:45.329 --> 00:50:49.650
访问生成的唯一密钥，因此我们

00:50:47.940 --> 00:50:51.270
真的只能在这里使用第三个

00:50:49.650 --> 00:50:54.390
所以我们创建一个新的准备好的语句

00:50:51.270 --> 00:50:58.730
创建者，然后我们使用生成的密钥

00:50:54.390 --> 00:51:03.569
持有人所有生成的密钥持有人

00:50:58.730 --> 00:51:06.750
好的，我们只需访问一次密钥持有者

00:51:03.569 --> 00:51:07.800
权利已经完成，所以我们在这里

00:51:06.750 --> 00:51:10.760
将创建准备好的语句

00:51:07.800 --> 00:51:20.329
创作者的缘故，准备一份声明

00:51:10.760 --> 00:51:24.869
插入客户姓名电子邮件值

00:51:20.329 --> 00:51:27.090
问号问号，我说

00:51:24.869 --> 00:51:30.690
我写的声明

00:51:27.090 --> 00:51:33.660
当我回来的时候

00:51:30.690 --> 00:51:36.540
生成的密钥，然后我们想要

00:51:33.660 --> 00:51:37.620
以准备好的前提为前提

00:51:36.540 --> 00:51:39.480
声明，所以准备好的声明是

00:51:37.620 --> 00:51:40.860
已编译的已编译语句

00:51:39.480 --> 00:51:43.470
由引擎由驾驶员

00:51:40.860 --> 00:51:45.030
续集服务器引擎，你知道一些

00:51:43.470 --> 00:51:46.920
正在编译它，以便我们没有

00:51:45.030 --> 00:51:50.100
以便引擎不必做

00:51:46.920 --> 00:51:51.840
的所有语法树解析

00:51:50.100 --> 00:51:53.340
现在就尽可能地进行续集查询

00:51:51.840 --> 00:51:54.770
用任何一种编译语言来想象

00:51:53.340 --> 00:51:56.490
一般而言，任何一种语言都有

00:51:54.770 --> 00:51:58.650
准备阶段有一个汇编

00:51:56.490 --> 00:52:01.440
看着弦并转动的阶段

00:51:58.650 --> 00:52:04.080
知道ast是抽象语法

00:52:01.440 --> 00:52:05.760
树木，然后将其转化为操作码

00:52:04.080 --> 00:52:07.950
然后变成字节码和

00:52:05.760 --> 00:52:09.750
然后将其缓存在正确的位置

00:52:07.950 --> 00:52:11.640
家伙可能会在某个地方被打扰

00:52:09.750 --> 00:52:14.070
他们可以很容易地我们去了

00:52:11.640 --> 00:52:16.200
内存，在这种情况下，它存储在

00:52:14.070 --> 00:52:18.150
续集引擎，所以我们想要这个

00:52:16.200 --> 00:52:21.060
声明这是时候了

00:52:18.150 --> 00:52:23.250
所有的引擎请缓存它，你

00:52:21.060 --> 00:52:25.470
知道那样，我们就可以发布

00:52:23.250 --> 00:52:26.940
查询但仅提供新参数

00:52:25.470 --> 00:52:28.410
现在我们不必重新编译

00:52:26.940 --> 00:52:31.050
一切，所以我要说准备

00:52:28.410 --> 00:52:33.210
语句设置字符串一，然后

00:52:31.050 --> 00:52:35.280
您知道数据的第一个字符串

00:52:33.210 --> 00:52:37.800
它将运行正确，所以再次让我们

00:52:35.280 --> 00:52:39.000
想象我们有一个你知道的

00:52:37.800 --> 00:52:40.920
实际上我们确实做到了，我们可以

00:52:39.000 --> 00:52:45.360
实际上在这里创建服务方法

00:52:40.920 --> 00:52:49.160
公众无效或公共客户，我们

00:52:45.360 --> 00:52:51.780
想要我们这里的客户

00:52:49.160 --> 00:52:53.870
在这里，我们将忽略我们的订单

00:52:51.780 --> 00:52:53.870
现在

00:52:55.460 --> 00:53:02.059
好吧，这是我们的客户类型和需求

00:53:00.770 --> 00:53:06.740
有公共场合的空虚

00:53:02.059 --> 00:53:09.760
抱歉，现在我要插入公共客户

00:53:06.740 --> 00:53:18.380
会说字符串名称字符串电子邮件

00:53:09.760 --> 00:53:22.789
我们把这一切放在这里和现在

00:53:18.380 --> 00:53:25.130
我们已经有了生成的密钥持有人， 

00:53:22.789 --> 00:53:27.020
我们需要我们有它的参数

00:53:25.130 --> 00:53:29.450
这里的字符串第一个字符串是

00:53:27.020 --> 00:53:33.829
正确的名称，然后是第二个

00:53:29.450 --> 00:53:36.529
是电子邮件，所以有这个，然后

00:53:33.829 --> 00:53:37.930
好笑，我们返回准备好的声明

00:53:36.529 --> 00:53:39.650
所以我们正在创建准备好的语句

00:53:37.930 --> 00:53:41.359
创建参数设置

00:53:39.650 --> 00:53:43.730
参数，然后将其返回

00:53:41.359 --> 00:53:49.250
这当然写得很好

00:53:43.730 --> 00:53:50.809
 lambda以及我们做什么时会拥有什么

00:53:49.250 --> 00:53:52.160
好吧，我们不需要实际更新

00:53:50.809 --> 00:53:53.359
打电话我们不需要这是

00:53:52.160 --> 00:53:54.079
不影响的行数

00:53:53.359 --> 00:53:56.960
其实在乎

00:53:54.079 --> 00:53:58.910
我们关心的是这个的结果

00:53:56.960 --> 00:54:00.799
生成密钥持有人，以便我们获取密钥

00:53:58.910 --> 00:54:04.299
这是我要转的号码

00:54:00.799 --> 00:54:08.630
将其转换为新的长值ID 

00:54:04.299 --> 00:54:11.299
客户，然后我们可以用它来

00:54:08.630 --> 00:54:12.410
查找记录，或者每执行一次

00:54:11.299 --> 00:54:14.990
对，所以通常

00:54:12.410 --> 00:54:19.839
随便说你知道返回戴维西

00:54:14.990 --> 00:54:23.359
模板查询全选C点

00:54:19.839 --> 00:54:26.000
客户看到ID到哪里

00:54:23.359 --> 00:54:29.660
问号，然后将其传递

00:54:26.000 --> 00:54:38.859
当然他们行映射器，所以新的行

00:54:29.660 --> 00:54:41.859
客户类型的映射器，我们有一个

00:54:38.859 --> 00:54:41.859
较重

00:54:42.339 --> 00:54:51.890
参数和参数已创建

00:54:48.230 --> 00:54:53.750
对于对象和参数去这里是

00:54:51.890 --> 00:55:00.440
我从来没有担任过第二个

00:54:53.750 --> 00:55:02.510
一个或第三个好吧，所以您的ID 

00:55:00.440 --> 00:55:04.520
客户和您之前认识相同的人

00:55:02.510 --> 00:55:08.599
与以前一样正确，所以我们不要

00:55:04.520 --> 00:55:12.829
长ID Horace目标字符串名称为

00:55:08.599 --> 00:55:15.380
是的，然后是艺术家艺术

00:55:12.829 --> 00:55:17.119
字符串电子邮件好了，所以我们去了

00:55:15.380 --> 00:55:20.680
那是一个很好的lambda 

00:55:17.119 --> 00:55:20.680
好，结果是我们现在可以

00:55:22.089 --> 00:55:26.660
现在和现在的红色日期作为基准

00:55:25.670 --> 00:55:33.160
得到结果，所以让我们尝试一下

00:55:26.660 --> 00:55:38.030
在这里好吧，所以B的流点

00:55:33.160 --> 00:55:41.660
看到每个名字，我们可以喜欢

00:55:38.030 --> 00:55:46.510
今天做了，所以我可以说插入并记录

00:55:41.660 --> 00:55:57.020
当然要插入名称的结果

00:55:46.510 --> 00:56:00.530
在name.com上命名，好吧，我们只是

00:55:57.020 --> 00:56:01.819
当我们阅读本文时，我们应该看到然后

00:56:00.530 --> 00:56:03.349
应该看到我们应该去得到所有

00:56:01.819 --> 00:56:05.480
从中返回的数据

00:56:03.349 --> 00:56:09.740
数据库，然后说这次京东的模板

00:56:05.480 --> 00:56:11.900
该查询从客户中选择全部， 

00:56:09.740 --> 00:56:17.030
你知道在这一点上我有两个

00:56:11.900 --> 00:56:22.210
这些，但我会私下重用

00:56:17.030 --> 00:56:22.210
真正的地图绘制者客户

00:56:24.930 --> 00:56:36.190
好的，所以现在有了这个

00:56:29.700 --> 00:56:40.630
客户角色映射器和自定义真实

00:56:36.190 --> 00:56:42.010
每个日志信息的映射器

00:56:40.630 --> 00:56:52.380
好吧，让我们运行它，看看

00:56:42.010 --> 00:56:52.380
我们得到的私人最终利益

00:56:55.420 --> 00:57:14.260
啊，你可以看到那个伯爵，我做到了

00:57:12.039 --> 00:57:17.950
忘记一些很重要的东西

00:57:14.260 --> 00:57:19.769
我忘了字符串utils行

00:57:17.950 --> 00:57:25.390
我们去那里，所以他们在那里

00:57:19.769 --> 00:57:28.900
那里是我们现有的六个权利

00:57:25.390 --> 00:57:32.339
似乎没有特别的顺序

00:57:28.900 --> 00:57:32.339
我坐在这里

00:57:42.230 --> 00:57:46.580
我们有什么客户

00:57:56.960 --> 00:58:17.250
按ID排序最好看起来不是

00:58:10.620 --> 00:58:21.090
实际上不是那里发生了什么

00:58:17.250 --> 00:58:24.180
运行应用程序，我们有七个

00:58:21.090 --> 00:58:27.360
八九为什么我们没有七八

00:58:24.180 --> 00:58:30.030
九次两次哦，因为我正在打印

00:58:27.360 --> 00:58:31.530
插入正确，所以我在这里登录

00:58:30.030 --> 00:58:38.700
插入，我们不需要这样做

00:58:31.530 --> 00:58:39.810
让我们摆脱它吧

00:58:38.700 --> 00:58:42.360
我们知道插入物，我们知道它

00:58:39.810 --> 00:58:44.540
工作了哦，我们去了那里，所以

00:58:42.360 --> 00:58:46.650
我们期望的九个

00:58:44.540 --> 00:58:48.780
如果我恢复了我们拥有的代码

00:58:46.650 --> 00:58:51.030
在您看到我能够

00:58:48.780 --> 00:58:52.440
访问新生成的密钥

00:58:51.030 --> 00:58:53.760
从生成的密钥

00:58:52.440 --> 00:58:59.300
还有一个提交列

00:58:53.760 --> 00:59:06.450
你知道我们可以说一个博客

00:58:59.300 --> 00:59:08.070
结果无论如何现在你去

00:59:06.450 --> 00:59:09.390
七八九这些是新

00:59:08.070 --> 00:59:11.070
生成的ID可以，所以

00:59:09.390 --> 00:59:12.660
工作很好，所以现在这很简单

00:59:11.070 --> 00:59:14.430
使用插入的示例

00:59:12.660 --> 00:59:16.080
你知道周围所有的子东西吗

00:59:14.430 --> 00:59:18.270
生成结果并确认

00:59:16.080 --> 00:59:19.860
我们得到的你知道你已经看到了

00:59:18.270 --> 00:59:21.990
在正确的非常简单的示例之前使用

00:59:19.860 --> 00:59:24.630
 JTP模板现在是JDBC模板

00:59:21.990 --> 00:59:26.760
就像我说的，它有一个很好的方法

00:59:24.630 --> 00:59:28.560
写入数据，但整个过程非常重要

00:59:26.760 --> 00:59:30.510
 API以jb的模板为中心，并且

00:59:28.560 --> 00:59:32.730
你要记住这个食谱吧

00:59:30.510 --> 00:59:34.770
所有这一切

00:59:32.730 --> 00:59:35.910
使用JDBC时间的整个方法，但是

00:59:34.770 --> 00:59:37.800
您每次都要重复一次

00:59:35.910 --> 00:59:39.210
用JDBC实现相同的目的

00:59:37.800 --> 00:59:40.530
模板很不错，可以包装

00:59:39.210 --> 00:59:42.570
对象内部的东西，然后

00:59:40.530 --> 00:59:44.370
能够重新利用它，因为大多数

00:59:42.570 --> 00:59:45.720
人们不必记住所有

00:59:44.370 --> 00:59:47.400
我要做的不同的小事情

00:59:45.720 --> 00:59:49.080
在这里让它工作有一个

00:59:47.400 --> 00:59:51.030
建立实例化或调用

00:59:49.080 --> 00:59:52.200
东西，让你的游戏在

00:59:51.030 --> 00:59:55.110
当前他们将数据取回

00:59:52.200 --> 00:59:57.510
您正在投放广告，因此

00:59:55.110 --> 00:59:58.850
这个 Spring 有一点不同

00:59:57.510 --> 01:00:00.650
方法实际上有两个不同

00:59:58.850 --> 01:00:02.700
层次结构，如果您选择一个

01:00:00.650 --> 01:00:06.310
接近两个权利

01:00:02.700 --> 01:00:08.020
使用using Spring Framework 和

01:00:06.310 --> 01:00:09.610
第二种策略是围绕物体

01:00:08.020 --> 01:00:12.970
我们一直在使用JDBC模板

01:00:09.610 --> 01:00:16.420
在 Spring 

01:00:12.970 --> 01:00:20.800
框架JBC核心软件包，很难

01:00:16.420 --> 01:00:27.280
 JDBC包让我们看看它是核心

01:00:20.800 --> 01:00:29.560
噢，戴夫的模版在这里

01:00:27.280 --> 01:00:31.900
 jbz核心权利，但有一个整体

01:00:29.560 --> 01:00:36.250
其他包称为对象和那个

01:00:31.900 --> 01:00:38.470
其他包裹住在这里和这里

01:00:36.250 --> 01:00:41.200
可以看到操作周围的包装器

01:00:38.470 --> 01:00:43.600
像查询更新一样，所以程序续集

01:00:41.200 --> 01:00:45.910
调用续集函数续集查询

01:00:43.600 --> 01:00:48.820
等，这些基本上是您创建的

01:00:45.910 --> 01:00:49.840
包裹咒语的物体

01:00:48.820 --> 01:00:51.700
您正在尝试执行操作

01:00:49.840 --> 01:00:53.890
您正在尝试做的事情，所以您可以

01:00:51.700 --> 01:00:56.200
创建甚至这些不同的工厂

01:00:53.890 --> 01:00:58.180
对象，然后重用它们，让我们开始吧

01:00:56.200 --> 01:00:59.950
现在可以了，所以不用这样做

01:00:58.180 --> 01:01:02.470
让我们只复制我们的骨架

01:00:59.950 --> 01:01:07.090
前面的例子是

01:01:02.470 --> 01:01:11.830
仍然是四个，现在是四个，现在五个

01:01:07.090 --> 01:01:20.770
这将使用T 

01:01:11.830 --> 01:01:27.370
对象jvc对象编写器好粘贴

01:01:20.770 --> 01:01:29.470
在那里，还有其他一切

01:01:27.370 --> 01:01:31.300
除了插入还可以

01:01:29.470 --> 01:01:33.340
还有我们要阅读的创作者

01:01:31.300 --> 01:01:34.330
并重做查询

01:01:33.340 --> 01:01:39.580
展示两种不同的方式

01:01:34.330 --> 01:01:42.610
在这里实现相同的目的

01:01:39.580 --> 01:01:45.430
一些在一秒钟内重新审视

01:01:42.610 --> 01:01:47.530
好了，现在我们有了插入

01:01:45.430 --> 01:01:50.200
需要一个查询好，所以我们插入

01:01:47.530 --> 01:01:52.300
使用简单的JDBC来实现

01:01:50.200 --> 01:01:53.800
插入，这是一个对象

01:01:52.300 --> 01:01:55.960
实际上是我们需要做的事情

01:01:53.800 --> 01:02:04.410
管理正确，这样我们就可以创建它

01:01:55.960 --> 01:02:04.410
私有最终简单JDBC插入

01:02:04.769 --> 01:02:07.469
它将需要数据源

01:02:06.420 --> 01:02:12.180
所以我需要这个，我要

01:02:07.469 --> 01:02:16.170
说简单的JDBC插入等于新的简单

01:02:12.180 --> 01:02:17.910
 JDBC插入GBC模板数据源或

01:02:16.170 --> 01:02:21.869
我们可以检查数据源

01:02:17.910 --> 01:02:25.920
本身的表名是客户， 

01:02:21.869 --> 01:02:27.809
我们要使用生成的键列和

01:02:25.920 --> 01:02:30.660
生成键列将是

01:02:27.809 --> 01:02:32.519
叫ID没办法存储一个

01:02:30.660 --> 01:02:33.660
我们使用信引用此

01:02:32.519 --> 01:02:36.959
那是笔记，那是一件好事

01:02:33.660 --> 01:02:38.729
关于这一点，我们可以重用这些

01:02:36.959 --> 01:02:40.349
引用权就是这些

01:02:38.729 --> 01:02:45.599
旨在保持持久性并在

01:02:40.349 --> 01:02:48.479
时间这么好，现在好了，我们

01:02:45.599 --> 01:02:49.559
解决了续集操作和

01:02:48.479 --> 01:02:50.579
续集操作相当

01:02:49.559 --> 01:02:52.130
很简单，实际上

01:02:50.579 --> 01:02:54.680
简单易懂，所以我们可以有地图

01:02:52.130 --> 01:03:01.579
包含字符串和对象

01:02:54.680 --> 01:03:07.859
参数等于新的哈希映射名称name和

01:03:01.579 --> 01:03:09.569
我一直在用Java 10修复该问题

01:03:07.859 --> 01:03:11.789
实际上可以有一个地图构建器

01:03:09.569 --> 01:03:19.009
和其他东西，但与此同时我

01:03:11.789 --> 01:03:22.709
追溯过去，所以将姓名命名为电子邮件

01:03:19.009 --> 01:03:25.289
电子邮件，他遇到了关键是

01:03:22.709 --> 01:03:27.630
续表中列的名称

01:03:25.289 --> 01:03:30.089
好的，所以我要做的是

01:03:27.630 --> 01:03:33.930
我将使用插入操作

01:03:30.089 --> 01:03:36.359
这有简单的JDBC插入我要

01:03:33.930 --> 01:03:40.650
说使用执行并返回键

01:03:36.359 --> 01:03:46.529
这些参数，结果是

01:03:40.650 --> 01:03:51.539
 ID正确，所以我们可以说长ID等于

01:03:46.529 --> 01:03:52.739
长值及其结果是

01:03:51.539 --> 01:03:53.969
我们要回报的是你知道我们

01:03:52.739 --> 01:03:55.259
用它来回报顾客

01:03:53.969 --> 01:03:57.859
现在让我们谈谈获得

01:03:55.259 --> 01:04:01.199
客户让我们现在谈谈

01:03:57.859 --> 01:04:02.459
我们现在将以另一种方式使用

01:04:01.199 --> 01:04:04.339
那就是我们知道我们可以回到这个

01:04:02.459 --> 01:04:06.329
一秒钟我想我们会得到一个

01:04:04.339 --> 01:04:10.319
我们要去找顾客

01:04:06.329 --> 01:04:11.670
惊人的续集映射续集查询

01:04:10.319 --> 01:04:13.410
好吧，我们将要创建一个通用的

01:04:11.670 --> 01:04:16.320
我们要子类映射的续集

01:04:13.410 --> 01:04:17.850
查询以仅将事物参数化

01:04:16.320 --> 01:04:19.800
对我们而言，我们必须

01:04:17.850 --> 01:04:21.330
我们想要获得全部用例的用例

01:04:19.800 --> 01:04:23.520
记录要通过ID获得一个

01:04:21.330 --> 01:04:27.960
当我得到所有记录之后

01:04:23.520 --> 01:04:29.580
就像我们在正确做所有事情之前所做的一样

01:04:27.960 --> 01:04:32.430
我们找到该子类，这将

01:04:29.580 --> 01:04:37.920
允许我们轻松地做到这一点，如此私密

01:04:32.430 --> 01:04:41.970
静态类客户映射续集

01:04:37.920 --> 01:04:47.790
查询实现映射续集

01:04:41.970 --> 01:04:51.480
从Spring查询而不是从简单查询

01:04:47.790 --> 01:04:53.610
平面映射器将映射到客户，并且

01:04:51.480 --> 01:04:57.900
为了完成这项工作，我们需要您

01:04:53.610 --> 01:05:01.890
知道那是在新客户RS得到之前

01:04:57.900 --> 01:05:06.810
只要它的ID诚实是字符串

01:05:01.890 --> 01:05:10.230
名称是为了获得强度电子邮件，那就是

01:05:06.810 --> 01:05:16.380
我想那是第一位

01:05:10.230 --> 01:05:17.970
我们关心的首先扩展

01:05:16.380 --> 01:05:20.340
有点相机，但是我们有

01:05:17.970 --> 01:05:21.930
还配置数据源

01:05:20.340 --> 01:05:23.850
续集声明和一些续集入门

01:05:21.930 --> 01:05:25.500
所以我要创建一个构造器

01:05:23.850 --> 01:05:32.930
有我们关心的所有这些东西

01:05:25.500 --> 01:05:38.850
好的，所以数据源TS字符串续集和

01:05:32.930 --> 01:05:42.210
续集参数参数没关系，所以

01:05:38.850 --> 01:05:48.330
设置数据源等于数据源坐

01:05:42.210 --> 01:05:52.440
续集续集坐姿参数等于

01:05:48.330 --> 01:05:54.800
参数，我们需要声明

01:05:52.440 --> 01:05:59.430
参数在那里

01:05:54.800 --> 01:06:02.250
所以实际上您知道它的外观

01:05:59.430 --> 01:06:03.930
如果我说设置参数但实际

01:06:02.250 --> 01:06:05.430
像这样工作，然后

01:06:03.930 --> 01:06:07.170
有趣的是，我们需要正确编译它， 

01:06:05.430 --> 01:06:08.880
实际上，这通常是为您完成的，如果

01:06:07.170 --> 01:06:10.410
您在属性设置屏幕后调用

01:06:08.880 --> 01:06:13.110
如果声明此属性，则调用ft属性集

01:06:10.410 --> 01:06:16.140
作为光束，所以也许更好

01:06:13.110 --> 01:06:17.550
只是这样做，但如果您手动

01:06:16.140 --> 01:06:19.110
实例化此类的实例，并

01:06:17.550 --> 01:06:20.490
然后你就不去管理 Spring 了

01:06:19.110 --> 01:06:22.170
设置属性后可能会忘记调用

01:06:20.490 --> 01:06:23.850
这反过来又是一个错误

01:06:22.170 --> 01:06:25.410
调用编译，您需要这样做

01:06:23.850 --> 01:06:26.950
我要自己叫这个

01:06:25.410 --> 01:06:28.869
直接但是

01:06:26.950 --> 01:06:31.060
你知道你可能会

01:06:28.869 --> 01:06:33.430
像 Spring 一样疯狂

01:06:31.060 --> 01:06:35.890
这样完成后，我就可以创建它们了

01:06:33.430 --> 01:06:40.450
我创建它们的实例以返回

01:06:35.890 --> 01:06:43.630
私人的，这是私人的最终客户

01:06:40.450 --> 01:06:46.270
映射续集测验都是新的

01:06:43.630 --> 01:06:48.099
客户映射续集查询这将

01:06:46.270 --> 01:06:53.619
只需加载所有数据，然后全选

01:06:48.099 --> 01:06:56.890
来自客户和我们的数据源

01:06:53.619 --> 01:07:03.930
也要注射，所以我想我们

01:06:56.890 --> 01:07:13.420
必须在构造函数中执行此操作

01:07:03.930 --> 01:07:20.970
通过ID，这等于新客户

01:07:13.420 --> 01:07:23.500
映射续集查询des并全选

01:07:20.970 --> 01:07:31.650
来自客户的所有权利

01:07:23.500 --> 01:07:36.720
而这个ID等于新客户

01:07:31.650 --> 01:07:40.589
获取数据源全选

01:07:36.720 --> 01:07:43.359
我等于问号的客户

01:07:40.589 --> 01:07:47.170
我要找到一个新的续集参数

01:07:43.359 --> 01:07:50.109
这是该类型的包装

01:07:47.170 --> 01:07:52.810
在那里声明的类型，所以我们给它一个

01:07:50.109 --> 01:07:58.200
是Java类型吗

01:07:52.810 --> 01:07:58.200
输入到漂移，这就是我们的

01:07:58.680 --> 01:08:02.200
实现，这就是实例

01:08:00.430 --> 01:08:04.869
我们需要实例的事件

01:08:02.200 --> 01:08:06.640
我们需要的就是可以重复使用的

01:08:04.869 --> 01:08:08.410
那些现在大多数的知识

01:08:06.640 --> 01:08:10.119
调用运行此的那些查询

01:08:08.410 --> 01:08:11.710
测验现在封装在那些

01:08:10.119 --> 01:08:14.880
对象是命令对象

01:08:11.710 --> 01:08:23.319
好吧，我们要在这里搅拌一下

01:08:14.880 --> 01:08:30.609
好，让我们重用它，所以在这里我们说

01:08:23.319 --> 01:08:34.600
这个点通过ID点找到对象传递

01:08:30.609 --> 01:08:38.890
一件容易的身份证件，为此，我们

01:08:34.600 --> 01:08:39.900
说所有的思想执行

01:08:38.890 --> 01:08:44.130
吃的

01:08:39.900 --> 01:08:45.570
长信息也很容易，您可以

01:08:44.130 --> 01:08:47.550
再次，您可以轻松地看到如何

01:08:45.570 --> 01:08:48.810
让你知道的东西

01:08:47.550 --> 01:08:50.160
可能会略有不同

01:08:48.810 --> 01:08:52.080
甚至创建一些这样的类

01:08:50.160 --> 01:08:53.220
已经有了您知道的数据排序

01:08:52.080 --> 01:08:55.350
构造函数只包含数据

01:08:53.220 --> 01:08:56.790
源，然后是序列语句

01:08:55.350 --> 01:08:58.110
参数刚刚完成

01:08:56.790 --> 01:09:00.090
您会自动对，因此您将拥有

01:08:58.110 --> 01:09:02.970
只需要的客户映射续集

01:09:00.090 --> 01:09:05.490
一生一世

01:09:02.970 --> 01:09:07.890
例如一个特定的

01:09:05.490 --> 01:09:10.110
原谅非常查询

01:09:07.890 --> 01:09:11.280
你肯定只是想与众不同

01:09:10.110 --> 01:09:12.510
尽可能地隐藏

01:09:11.280 --> 01:09:16.710
您只拥有可以的对象的方式

01:09:12.510 --> 01:09:18.090
现在轻松测试，让我们看看

01:09:16.710 --> 01:09:29.640
发生，让我们看看如果我们跑步会得到什么

01:09:18.090 --> 01:09:31.200
这段代码再次正确，所以再次

01:09:29.640 --> 01:09:33.690
记录我们不想做的数据

01:09:31.200 --> 01:09:36.060
再次，但不是，不是

01:09:33.690 --> 01:09:44.510
伤害我们以证明这一点，但这是多余的

01:09:36.060 --> 01:09:44.510
我想让我们看看是否可以摆脱这种情况

01:09:47.480 --> 01:09:53.840
摆脱掉多余的括号

01:09:51.060 --> 01:09:53.840
也是上流

01:09:57.000 --> 01:10:07.290
已经，所以您现在可以看到我们有ABC 

01:10:05.460 --> 01:10:08.760
再写一遍，说得对

01:10:07.290 --> 01:10:11.400
这是规则，再次在

01:10:08.760 --> 01:10:12.840
第二个应用程序运行者，那就是

01:10:11.400 --> 01:10:14.550
工作，所以我们可以看到

01:10:12.840 --> 01:10:16.860
更新工作了议程BC对象

01:10:14.550 --> 01:10:18.270
作者工作查询工作线程

01:10:16.860 --> 01:10:19.470
映射续集查询效果明显

01:10:18.270 --> 01:10:20.970
因为我们无法得到这个

01:10:19.470 --> 01:10:22.890
数据以及在

01:10:20.970 --> 01:10:24.960
控制台Ted无法正常工作，所以您也知道

01:10:22.890 --> 01:10:25.950
结果相同，但您注意到我们

01:10:24.960 --> 01:10:27.120
实际上并不需要我的数据源

01:10:25.950 --> 01:10:28.920
使用数据源来尊重

01:10:27.120 --> 01:10:30.330
到数据源

01:10:28.920 --> 01:10:34.590
我使用JB的模板，而不是一起使用

01:10:30.330 --> 01:10:35.790
获取指向数据的M的指针

01:10:34.590 --> 01:10:37.650
来源，但我本来可以注入

01:10:35.790 --> 01:10:40.860
那我应该早就听到了

01:10:37.650 --> 01:10:46.410
你直接注入了，所以是的

01:10:40.860 --> 01:10:48.480
一路变得干净多了

01:10:46.410 --> 01:10:49.800
好了，所以我们去了更清洁

01:10:48.480 --> 01:10:51.210
这不需要任何JB的

01:10:49.800 --> 01:10:54.090
模板，您可以封装所有

01:10:51.210 --> 01:10:55.530
这些自定义操作中的逻辑

01:10:54.090 --> 01:10:57.780
你想要操作对象，我喜欢

01:10:55.530 --> 01:10:59.400
我喜欢这种风格，因为是你

01:10:57.780 --> 01:11:02.300
知道你在封装业务

01:10:59.400 --> 01:11:05.370
这里的逻辑尽可能好不

01:11:02.300 --> 01:11:07.950
所以现在我们的内容非常简洁

01:11:05.370 --> 01:11:10.170
还是有点乏味

01:11:07.950 --> 01:11:12.450
比那些习惯的人

01:11:10.170 --> 01:11:13.560
 om软件可能期望如此，我们

01:11:12.450 --> 01:11:16.020
现在要做的就是我们要接受这个

01:11:13.560 --> 01:11:17.870
再上一步，看看我们能否

01:11:16.020 --> 01:11:20.520
在OEM与

01:11:17.870 --> 01:11:22.500
我们基于低级的续集

01:11:20.520 --> 01:11:25.050
访问，我们将使用全新的

01:11:22.500 --> 01:11:27.180
协议spring数据JDBC现在由

01:11:25.050 --> 01:11:28.650
没什么意思，是GA项目，我不想要

01:11:27.180 --> 01:11:30.360
鼓励大家用尽

01:11:28.650 --> 01:11:31.650
在这里开始使用它，您的代码

01:11:30.360 --> 01:11:33.720
现在，仅此而已

01:11:31.650 --> 01:11:35.400
周围已经有一段时间了

01:11:33.720 --> 01:11:38.010
在

01:11:35.400 --> 01:11:40.010
社区，最近被带来

01:11:38.010 --> 01:11:42.330
进入官方 spring data 保护伞

01:11:40.010 --> 01:11:44.610
投资组合，所以我们要添加这个

01:11:42.330 --> 01:11:46.470
我们产品的构建

01:11:44.610 --> 01:11:49.980
在这里，我们要将此产品添加到我们的

01:11:46.470 --> 01:11:52.860
用一些方法建立老式的方法

01:11:49.980 --> 01:11:55.700
这里的依赖

01:11:52.860 --> 01:11:59.040
 SD，所以我们需要一些东西

01:11:55.700 --> 01:12:02.240
为了使用它，我们将

01:11:59.040 --> 01:12:04.080
在这里添加，然后我们需要

01:12:02.240 --> 01:12:06.530
我们需要的依赖版本

01:12:04.080 --> 01:12:09.650
依赖本身

01:12:06.530 --> 01:12:12.050
必要的部分是

01:12:09.650 --> 01:12:13.190
 spring data 发布火车本身不得不

01:12:12.050 --> 01:12:15.680
进行升级，因此我们需要使用快照

01:12:13.190 --> 01:12:17.450
或至少是一个里程碑

01:12:15.680 --> 01:12:19.100
我们正在使用的快速跟踪轨道

01:12:17.450 --> 01:12:21.020
 spring data lovelace，所以我们不使用

01:12:19.100 --> 01:12:22.850
 K不再从K中冒出来，而是

01:12:21.020 --> 01:12:26.360
 Spring 是下一个版本

01:12:22.850 --> 01:12:29.720
还没有发布，所以这里

01:12:26.360 --> 01:12:31.280
我们去那会做的Lovelace 

01:12:29.720 --> 01:12:34.280
这样我们就可以继续

01:12:31.280 --> 01:12:35.270
建立一个仓库，这就是这个

01:12:34.280 --> 01:12:37.250
如果您曾经有过，应该非常熟悉

01:12:35.270 --> 01:12:42.230
存储库之前使用的spring数据

01:12:37.250 --> 01:12:47.510
只是拿一个处理

01:12:42.230 --> 01:12:49.850
乏味，你知道乏味的索洛奈

01:12:47.510 --> 01:12:51.590
任何无聊乏味的创作阅读

01:12:49.850 --> 01:12:53.540
更新和删除up数据和

01:12:51.590 --> 01:12:54.830
这将是一个配置类

01:12:53.540 --> 01:12:57.080
我们将必须配置

01:12:54.830 --> 01:13:02.000
首先，我们将启用enable JBC 

01:12:57.080 --> 01:13:03.410
仓库，在这里我们可以做一些

01:13:02.000 --> 01:13:08.630
我们加载的东西我们将要创建

01:13:03.410 --> 01:13:10.250
使用存储库的应用程序

01:13:08.630 --> 01:13:12.490
所以我们去做

01:13:10.250 --> 01:13:18.020
在存储库中创建一个存储库

01:13:12.490 --> 01:13:22.570
界面客户资料库扩展

01:13:18.020 --> 01:13:28.070
当我有一个信用库

01:13:22.570 --> 01:13:30.050
在这里自定义顶级客户

01:13:28.070 --> 01:13:32.270
要创建一个客户，这将是

01:13:30.050 --> 01:13:34.340
最高一级，他们将拥有ID或

01:13:32.270 --> 01:13:36.140
类型为long的私钥

01:13:34.340 --> 01:13:38.960
现在复制其中任何一个，我可以知道吗

01:13:36.140 --> 01:13:40.100
想要知道并且它是一致的

01:13:38.960 --> 01:13:41.570
时尚与我所拥有的其他一切

01:13:40.100 --> 01:13:42.980
在这里完成，我很想拥有所有这些

01:13:41.570 --> 01:13:45.050
跨班的东西，但

01:13:42.980 --> 01:13:46.340
记得这是 Spring 的 bean 

01:13:45.050 --> 01:13:47.990
 Spring 需要找到的接口

01:13:46.340 --> 01:13:49.730
比刚刚定义的更好的东西

01:13:47.990 --> 01:13:51.910
因此，因为我将其保持在顶部

01:13:49.730 --> 01:13:53.630
级别，因为它不查找嵌套

01:13:51.910 --> 01:13:55.880
接口，尽管它确实在寻找

01:13:53.630 --> 01:13:57.290
正确的Spring 嵌套组件将做

01:13:55.880 --> 01:14:01.010
所以我们要有这个习惯

01:13:57.290 --> 01:14:04.790
界面，然后自定义

01:14:01.010 --> 01:14:06.440
存储库和客户，然后

01:14:04.790 --> 01:14:13.460
就是这样，我想我们实际上可以创建

01:14:06.440 --> 01:14:15.530
类型应用程序运行器的光束

01:14:13.460 --> 01:14:17.650
将使用此数据，让我们看看

01:14:15.530 --> 01:14:23.330
这里

01:14:17.650 --> 01:14:27.890
上课让我们做这个

01:14:23.330 --> 01:14:33.050
配置使其成为JBC 

01:14:27.890 --> 01:14:38.200
应用程序运行程序所有正确的应用程序

01:14:33.050 --> 01:14:50.960
跑步者，这里我们将使用存储库

01:14:38.200 --> 01:14:54.380
像这样，该组件现在是什么

01:14:50.960 --> 01:14:56.060
将访问所有的数据

01:14:54.380 --> 01:14:57.680
回来，我们可以做几个

01:14:56.060 --> 01:14:58.970
我们实际上可以做得好的方法

01:14:57.680 --> 01:15:02.660
首先，我们创建一个自定义

01:14:58.970 --> 01:15:08.740
查询，让我们进行自定义查询选择

01:15:02.660 --> 01:15:16.060
全部来自客户C，其中C点电子邮件

01:15:08.740 --> 01:15:16.060
等于您知道客户的集合

01:15:16.570 --> 01:15:25.630
找到您知道的字符串电子邮件就可以了

01:15:22.060 --> 01:15:27.970
并且我们的客户实体输入客户

01:15:25.630 --> 01:15:32.270
我们将通过一个实体来管理的实体

01:15:27.970 --> 01:15:33.350
你知道的 spring data 就像

01:15:32.270 --> 01:15:36.100
除了我们要注释他们

01:15:33.350 --> 01:15:41.390
必须带数据共享ID注解

01:15:36.100 --> 01:15:42.290
就是这样，让我们​​现在来看吧

01:15:41.390 --> 01:15:47.360
提前写给他们去

01:15:42.290 --> 01:15:49.370
和以前一样在这里复制数据库并

01:15:47.360 --> 01:15:53.240
我们要说拜访每个

01:15:49.370 --> 01:15:58.180
记录和客户反对的这个

01:15:53.240 --> 01:16:02.590
保存并保存新客户否

01:15:58.180 --> 01:16:08.330
这样好吧，然后我让

01:16:02.590 --> 01:16:14.200
 log4j在这里我要说一个记录器

01:16:08.330 --> 01:16:19.700
通过电子邮件找到的该客户Pastore 

01:16:14.200 --> 01:16:23.650
你一定会保持冷静

01:16:19.700 --> 01:16:29.540
并将访问结果

01:16:23.650 --> 01:16:33.730
好吧，让我们确认一下

01:16:29.540 --> 01:16:33.730
找到一切都应该工作

01:16:34.119 --> 01:16:47.090
像这样，他们很酷，我们知道了

01:16:37.909 --> 01:16:49.520
所以现在把数据写出来

01:16:47.090 --> 01:16:51.739
会有问题，因为桌子

01:16:49.520 --> 01:16:54.110
匹配不正确，所以表看到我是

01:16:51.739 --> 01:16:56.030
以名称命名的客户

01:16:54.110 --> 01:16:58.040
该类型与

01:16:56.030 --> 01:17:00.440
数据库，因此我们需要自定义

01:16:58.040 --> 01:17:04.610
命名策略，在这里我们可以做到

01:17:00.440 --> 01:17:07.489
在这样命名的配置中

01:17:04.610 --> 01:17:09.110
战略，我们可以回到

01:17:07.489 --> 01:17:13.670
第四种节省一种方法

01:17:09.110 --> 01:17:15.949
会覆盖获取表名，好的

01:17:13.670 --> 01:17:19.400
会说点号得到简单的名字下降

01:17:15.949 --> 01:17:26.600
小写，所以用s修复并返回

01:17:19.400 --> 01:17:31.489
这就像分号一样，现在是什么

01:17:26.600 --> 01:17:33.110
发生了，我们需要提供方法

01:17:31.489 --> 01:17:36.199
在引物名称之外的名称

01:17:33.110 --> 01:17:43.400
自定义存储库查询足够公平，因此

01:17:36.199 --> 01:17:44.780
计划电子邮件，我想我们是否已完成

01:17:43.400 --> 01:17:46.639
问号，只是省略了它

01:17:44.780 --> 01:17:50.300
根据位置，效果也会很好

01:17:46.639 --> 01:17:53.630
自豪您知道定位底漆底漆

01:17:50.300 --> 01:17:56.420
您的位置，但是很好

01:17:53.630 --> 01:17:58.850
所以我们去那里，我们的结果是什么

01:17:56.420 --> 01:18:00.560
我们说我们要寻找，然后我

01:17:58.850 --> 01:18:03.290
给这个写这将是

01:18:00.560 --> 01:18:09.729
点什么，我不知道，让我们

01:18:03.290 --> 01:18:19.610
说不是七，我认为是七点五

01:18:09.729 --> 01:18:29.119
跳过一个，让我们做六个就可以了

01:18:19.610 --> 01:18:31.420
我们得到了什么，所以最后一个是B 

01:18:29.119 --> 01:18:31.420
对

01:18:33.510 --> 01:18:45.210
通过电子邮件找到哦，是的，真的

01:18:43.199 --> 01:18:47.219
我们稍后插入，让我们尝试

01:18:45.210 --> 01:18:48.210
做一个独特的，我们插入了三个

01:18:47.219 --> 01:18:51.210
在此过程中不同的

01:18:48.210 --> 01:18:53.190
程序，但只是要确保保存新

01:18:51.210 --> 01:18:56.579
客户空

01:18:53.190 --> 01:19:03.150
 foo bar好吧，我们去吧，等等

01:18:56.579 --> 01:19:08.010
现在适合foo或兄弟酒吧

01:19:03.150 --> 01:19:08.519
应该得到一个记录回来嘿嘿看

01:19:08.010 --> 01:19:11.190
在那个

01:19:08.519 --> 01:19:13.380
好的，所以他们离开了，这是自定义的渴望

01:19:11.190 --> 01:19:15.000
使用spring数据JDBC，我们仍然可以吃饱

01:19:13.380 --> 01:19:16.800
控制码头，我想知道这是否

01:19:15.000 --> 01:19:18.869
我不知道它是否足够聪明

01:19:16.800 --> 01:19:20.159
他们，并进一步查询与

01:19:18.869 --> 01:19:21.960
其他spring数据模块，让我们

01:19:20.159 --> 01:19:24.239
一起拆下线圈，看看是否

01:19:21.960 --> 01:19:26.159
如果您根据名称算出

01:19:24.239 --> 01:19:27.329
该方法的很多

01:19:26.159 --> 01:19:32.639
其他spring数据模块将用于

01:19:27.329 --> 01:19:34.800
你，你猜不是没有折痕

01:19:32.639 --> 01:19:36.960
很好，我们可以不想给

01:19:34.800 --> 01:19:38.880
当我们移到这个很好的你时，开始测验

01:19:36.960 --> 01:19:40.829
知道使用查询的范例，所以我

01:19:38.880 --> 01:19:43.199
好，我们现在看了一些

01:19:40.829 --> 01:19:45.900
使用低级别的不同方法

01:19:43.199 --> 01:19:47.099
在 Spring 支持JDBC访问和

01:19:45.900 --> 01:19:48.809
再次，我认为这很好

01:19:47.099 --> 01:19:51.239
替代品，特别是Spring 导引

01:19:48.809 --> 01:19:53.250
 GBC尤其是简单的平板之类的东西

01:19:51.239 --> 01:19:56.159
地图，但我认为当您开始使用时

01:19:53.250 --> 01:19:58.889
此主要级别的JDBC看到了JDBC支持

01:19:56.159 --> 01:20:01.739
在 Spring 以及JDBC 

01:19:58.889 --> 01:20:04.949
模板和项目，例如spring数据

01:20:01.739 --> 01:20:06.690
通过JDBC，您可以开展很多业务

01:20:04.949 --> 01:20:08.250
得到很多速度，你得到很多

01:20:06.690 --> 01:20:10.199
我们想要从数据访问中获取的东西

01:20:08.250 --> 01:20:12.179
技术而不受束缚

01:20:10.199 --> 01:20:13.289
我写了很多代码

01:20:12.179 --> 01:20:15.210
一百六十三行代码，但是

01:20:13.289 --> 01:20:16.829
我又做了六个不同的版本

01:20:15.210 --> 01:20:18.380
相同的程序，它仍然

01:20:16.829 --> 01:20:20.820
只有三和六十三行代码

01:20:18.380 --> 01:20:23.550
你知道这并没有变得更简单

01:20:20.820 --> 01:20:25.619
比我要感谢你的

01:20:23.550 --> 01:20:29.179
时间，希望你得到了无尽的东西

01:20:25.619 --> 01:20:29.179
和往常一样，我们下次见

01:20:36.239 --> 01:20:38.300
您

