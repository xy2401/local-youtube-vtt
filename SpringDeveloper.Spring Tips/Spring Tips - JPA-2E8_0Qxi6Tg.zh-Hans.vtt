WEBVTT
Kind: captions
Language: zh-Hans

00:00:25.840 --> 00:00:30.640
粉丝们欢迎收看另一期

00:00:28.660 --> 00:00:31.960
今天的分期付款的 Spring 小贴士

00:00:30.640 --> 00:00:35.590
将在Java上查看JPA 

00:00:31.960 --> 00:00:37.239
持久性API现在DP是一个

00:00:35.590 --> 00:00:39.550
长期存在的API 

00:00:37.239 --> 00:00:41.260
永远在一天内，它肯定

00:00:39.550 --> 00:00:43.570
在 Spring 非常有用

00:00:41.260 --> 00:00:45.550
生态系统，尤其是生态系统

00:00:43.570 --> 00:00:49.239
其最著名的实现混合8 

00:00:45.550 --> 00:00:52.300
与 Spring 我有悠久的历史

00:00:49.239 --> 00:00:54.760
认为其中一种真的非常强大

00:00:52.300 --> 00:00:56.829
那种可乘的东西

00:00:54.760 --> 00:00:58.930
让 Spring 繁荣昌盛

00:00:56.829 --> 00:01:00.820
死亡拥抱冬眠例如

00:00:58.930 --> 00:01:03.879
拥抱还是嗯，这做得很好

00:01:00.820 --> 00:01:05.979
在适当的时间管理持久性和

00:01:03.879 --> 00:01:08.170
所以我们要休眠

00:01:05.979 --> 00:01:11.020
尽管jpay本身是一个

00:01:08.170 --> 00:01:13.150
规格，它可以与

00:01:11.020 --> 00:01:15.010
的不同实现数量

00:01:13.150 --> 00:01:16.570
哪个休眠只是它发生的一种

00:01:15.010 --> 00:01:19.000
成为最受欢迎和最

00:01:16.570 --> 00:01:21.970
无处不在，但那只是其中之一

00:01:19.000 --> 00:01:25.360
其他，例如Eclipse链接和

00:01:21.970 --> 00:01:26.680
 spring boot 本身当然是凭借着

00:01:25.360 --> 00:01:30.070
它是实施的事实

00:01:26.680 --> 00:01:31.780
支持不是基于JPA的

00:01:30.070 --> 00:01:33.549
关心您可以使用哪种实现

00:01:31.780 --> 00:01:35.560
例如，您可以使用Eclipse链接

00:01:33.549 --> 00:01:37.719
你知道冬眠的人数

00:01:35.560 --> 00:01:39.100
不同的，所以今天，如果我们

00:01:37.719 --> 00:01:40.590
要结合起来，只是使用

00:01:39.100 --> 00:01:44.200
休眠我们要建立一个新的

00:01:40.590 --> 00:01:46.390
像往常一样在这里开始应用

00:01:44.200 --> 00:01:49.210
那年 Spring 那个IO，我们称之为

00:01:46.390 --> 00:01:51.189
 JPA我们将使用我的续集

00:01:49.210 --> 00:01:53.109
使用lumba做短时的支持

00:01:51.189 --> 00:01:56.170
 Java工作的一些乏味

00:01:53.109 --> 00:01:58.299
我们使用时间片和网络支持

00:01:56.170 --> 00:02:01.539
我们会回到一点，我们

00:01:58.299 --> 00:02:03.729
会自然使用JPA，我认为

00:02:01.539 --> 00:02:05.590
现在就足够了

00:02:03.729 --> 00:02:08.770
首先，我们有我的龙目岛

00:02:05.590 --> 00:02:10.240
续集及时的网络和JPA深受好评

00:02:08.770 --> 00:02:15.160
生成信件给我们一个新项目

00:02:10.240 --> 00:02:19.810
我将在这里在我的ID IDE中打开

00:02:15.160 --> 00:02:20.890
那个拉链的JK，我们要开始了

00:02:19.810 --> 00:02:24.760
一个非常简单的应用程序

00:02:20.890 --> 00:02:27.100
将两个实体映射到一个表

00:02:24.760 --> 00:02:28.990
一个数据库而不是我的两个表

00:02:27.100 --> 00:02:30.550
数据库，并且我正在运行数据库

00:02:28.990 --> 00:02:32.050
在我的本地机器上，我有一个续集

00:02:30.550 --> 00:02:35.709
在本地计算机上运行的实例

00:02:32.050 --> 00:02:37.180
称为CRM，这是一个架构，没有

00:02:35.709 --> 00:02:39.010
那里的桌子

00:02:37.180 --> 00:02:41.980
但我们将继续使用API 

00:02:39.010 --> 00:02:45.310
用Bailey的创建这些实例

00:02:41.980 --> 00:02:46.989
桌子，所以我们要做的就是告诉

00:02:45.310 --> 00:02:48.909
Spring 如何连接数据库

00:02:46.989 --> 00:02:50.799
这是第一件事，这不是

00:02:48.909 --> 00:02:53.349
任何与您将要做的不同

00:02:50.799 --> 00:02:56.739
其他基于JDBC的技术，所以我的beta 

00:02:53.349 --> 00:03:00.909
是Jo q JP a还是直接的JDBC I 

00:02:56.739 --> 00:03:03.040
涵盖了JBC我的Vedas和Jo Q等

00:03:00.909 --> 00:03:05.230
 Spring 技巧分期付款，所以这应该

00:03:03.040 --> 00:03:07.389
看着这一点非常熟悉，所以我

00:03:05.230 --> 00:03:11.859
要说 Spring 那个数据源URL 

00:03:07.389 --> 00:03:14.769
它将是JDBC：我的后继作品：四个

00:03:11.859 --> 00:03:18.700
斜线四个斜杠主机名端口是

00:03:14.769 --> 00:03:20.799
通常是3306模式名称

00:03:18.700 --> 00:03:25.180
在这种情况下是CRM，我们

00:03:20.799 --> 00:03:27.340
要告诉我的续集不要在

00:03:25.180 --> 00:03:30.129
我的本地节点，我们需要配置一个

00:03:27.340 --> 00:03:32.200
密码，我将成为CRM，我们需要

00:03:30.129 --> 00:03:35.200
配置用户名，当然

00:03:32.200 --> 00:03:38.530
这将是用户名将是血清

00:03:35.200 --> 00:03:39.870
现在好吧，这不应该存在

00:03:38.530 --> 00:03:43.000
实际应用程序中的属性文件

00:03:39.870 --> 00:03:46.659
但嗯，您现在知道我们只是在使用

00:03:43.000 --> 00:03:49.060
那里好吧，那就是

00:03:46.659 --> 00:03:54.329
我们配置的基本要素

00:03:49.060 --> 00:03:56.620
需要，但我们也想告诉JP a 

00:03:54.329 --> 00:04:00.069
为我们制作续集，然后说

00:03:56.620 --> 00:04:01.510
是的，它将基于

00:04:00.069 --> 00:04:03.519
模式表等等

00:04:01.510 --> 00:04:06.609
构造和主键等

00:04:03.519 --> 00:04:08.829
通过查看我们的自动

00:04:06.609 --> 00:04:10.090
对象现在记住您不想要的

00:04:08.829 --> 00:04:12.189
此属性在生产中，您应该

00:04:10.090 --> 00:04:14.590
绝对不会获得此属性

00:04:12.189 --> 00:04:16.000
生产，实际上我通常会把

00:04:14.590 --> 00:04:18.310
在单独的属性文件下

00:04:16.000 --> 00:04:20.320
称为应用程序-例如dev 

00:04:18.310 --> 00:04:23.110
 dev是 Spring 的名字

00:04:20.320 --> 00:04:25.300
您仅在自己的个人资料上激活的个人资料

00:04:23.110 --> 00:04:26.889
本地开发机器，因此如果您部署到

00:04:25.300 --> 00:04:28.630
生产，你不知道

00:04:26.889 --> 00:04:32.470
Spring 的轮廓等于

00:04:28.630 --> 00:04:34.449
开发人员，那么它将无法正确激活，否则

00:04:32.470 --> 00:04:37.090
更进一步，使用类似

00:04:34.449 --> 00:04:38.530
轻量级或白酒基地激励我们

00:04:37.090 --> 00:04:40.720
数据库迁移工具是

00:04:38.530 --> 00:04:43.210
专为管理演变而设计

00:04:40.720 --> 00:04:45.090
模式并在必要时回滚

00:04:43.210 --> 00:04:47.860
所有的都是

00:04:45.090 --> 00:04:50.530
您可以与此同时使用，但

00:04:47.860 --> 00:04:54.730
当然，您不会用它代替

00:04:50.530 --> 00:04:56.650
现在我们将使用生成

00:04:54.730 --> 00:04:59.310
生成我们想要的GDL 

00:04:56.650 --> 00:05:04.540
展示将会出现的续集

00:04:59.310 --> 00:05:06.310
在这里输出，所以GK只是一个巨人或

00:05:04.540 --> 00:05:09.160
这是一个对象关系映射器及其

00:05:06.310 --> 00:05:11.350
工作是采用我们的Java对象或JVM 

00:05:09.160 --> 00:05:13.210
对象并将其映射到

00:05:11.350 --> 00:05:16.770
我们数据库中的适当构造

00:05:13.210 --> 00:05:19.150
层，什么时候做，有时

00:05:16.770 --> 00:05:23.770
有时候做得不好

00:05:19.150 --> 00:05:26.080
我们必须在这里提示一下

00:05:23.770 --> 00:05:27.790
那里该怎么办，我们不知道

00:05:26.080 --> 00:05:30.310
它做得很差，而且我们可以

00:05:27.790 --> 00:05:32.440
看到产生的续集

00:05:30.310 --> 00:05:35.620
例子，有这个很有用

00:05:32.440 --> 00:05:37.240
声明特别在

00:05:35.620 --> 00:05:41.290
再次发展，这两件事可能

00:05:37.240 --> 00:05:43.810
忙于崩溃或发展

00:05:41.290 --> 00:05:45.960
好吧，现在我们有了

00:05:43.810 --> 00:05:49.030
应用程序，我们将进行管理

00:05:45.960 --> 00:05:52.180
两种类型的记录之一称为

00:05:49.030 --> 00:05:53.860
客户和客户将是一件事情

00:05:52.180 --> 00:05:55.660
你会知道戴维斯是

00:05:53.860 --> 00:05:59.100
用来管理客户的记录

00:05:55.660 --> 00:06:02.800
信息，然后分类客户，然后

00:05:59.100 --> 00:06:04.840
客户将拥有他们的记录

00:06:02.800 --> 00:06:07.540
订单已完成的订单数

00:06:04.840 --> 00:06:12.640
对，然后发出信号，这些是

00:06:07.540 --> 00:06:18.910
创建这样的实体，我们将给

00:06:12.640 --> 00:06:21.610
每个一个主键值，那是

00:06:18.910 --> 00:06:23.050
会变成一个顺便说一句

00:06:21.610 --> 00:06:24.700
重要提示，我正在

00:06:23.050 --> 00:06:27.160
给定使用Spring 之间的选择

00:06:24.700 --> 00:06:28.420
数据ID注释非常有用，并且

00:06:27.160 --> 00:06:30.940
许多不同的Spring 数据

00:06:28.420 --> 00:06:34.420
现在的模块，尽管几乎所有模块

00:06:30.940 --> 00:06:36.670
实际上，除了JPA，因此我们将使用

00:06:34.420 --> 00:06:39.760
付钱确保做正确的事

00:06:36.670 --> 00:06:42.260
当它同时给汽车和

00:06:39.760 --> 00:06:44.420
授予唯一

00:06:42.260 --> 00:06:46.520
 ID正确，所以这不是自然的想法

00:06:44.420 --> 00:06:48.650
这些只是自动化我们的哀叹

00:06:46.520 --> 00:06:49.580
代理ID，我们可以使用它和

00:06:48.650 --> 00:06:51.890
没关系

00:06:49.580 --> 00:06:54.320
现在我们的客户会有一些

00:06:51.890 --> 00:06:56.990
领域，所以我要说第一个领域

00:06:54.320 --> 00:06:57.980
首先被称为订单，然后被称为第一

00:06:56.990 --> 00:07:00.200
名字宁可叫第一个

00:06:57.980 --> 00:07:04.940
不，我想控制

00:07:00.200 --> 00:07:06.680
用来存储它的列

00:07:04.940 --> 00:07:08.180
可以捕获此数据，所以在Java代码中

00:07:06.680 --> 00:07:10.100
它会首先被调用，但是在

00:07:08.180 --> 00:07:11.510
我们称为名字的续集模式

00:07:10.100 --> 00:07:13.220
默认情况下，它只会以

00:07:11.510 --> 00:07:15.290
领域，如果他们做了什么

00:07:13.220 --> 00:07:17.480
就像名字一样，那样就可以了

00:07:15.290 --> 00:07:18.710
他们会强调

00:07:17.480 --> 00:07:20.810
早先会做我们所拥有的

00:07:18.710 --> 00:07:22.880
问你是否要求它做一个

00:07:20.810 --> 00:07:25.790
策略，但在这种情况下，我们只是

00:07:22.880 --> 00:07:28.340
将在网站上覆盖它

00:07:25.790 --> 00:07:30.680
差异好，所以有第一个

00:07:28.340 --> 00:07:34.070
和姓氏，然后我们当然

00:07:30.680 --> 00:07:35.120
想要收集订单的东西，我是

00:07:34.070 --> 00:07:36.950
因为我不打算使用一套

00:07:35.120 --> 00:07:39.980
真正关心数据的顺序

00:07:36.950 --> 00:07:43.940
只要我有西红柿就回来了

00:07:39.980 --> 00:07:46.060
哦，您现在设置了，这是一个

00:07:43.940 --> 00:07:51.170
我要拥有的一对多收藏

00:07:46.060 --> 00:07:52.730
一位客户，可能有很多订单

00:07:51.170 --> 00:07:55.340
和那些订单，如果你看

00:07:52.730 --> 00:07:59.210
模式将基于

00:07:55.340 --> 00:08:02.360
订单表中的外键表示

00:07:59.210 --> 00:08:05.510
指向当前客户，所以我们

00:08:02.360 --> 00:08:09.140
想加入我们要告诉ORM 

00:08:05.510 --> 00:08:11.480
加载客户，然后加载全部

00:08:09.140 --> 00:08:13.640
他们所有的订单和一个单独的

00:08:11.480 --> 00:08:15.320
在一个查询中查询并全部加载

00:08:13.640 --> 00:08:18.110
通过查找订单来订购

00:08:15.320 --> 00:08:21.140
具有外键的

00:08:18.110 --> 00:08:22.910
该客户的ID，以及两个

00:08:21.140 --> 00:08:24.920
为了映射和说

00:08:22.910 --> 00:08:27.440
这是一对多的关系

00:08:24.920 --> 00:08:30.440
假设所有操作都应该

00:08:27.440 --> 00:08:32.870
在此级联到下级对象

00:08:30.440 --> 00:08:35.450
然后我们还要说想要

00:08:32.870 --> 00:08:37.520
删除孤立记录（如果有） 

00:08:35.450 --> 00:08:39.080
是的，所以我们基本上不

00:08:37.520 --> 00:08:41.060
想要周围的任何额外订单

00:08:39.080 --> 00:08:43.190
如果我们应该删除客户权限

00:08:41.060 --> 00:08:45.850
所以就在那里，然后我们也

00:08:43.190 --> 00:08:48.770
需要提供有关加入的线索

00:08:45.850 --> 00:08:50.060
叫他们使用，所以当我说加入

00:08:48.770 --> 00:08:52.430
柱

00:08:50.060 --> 00:08:55.550
名字等于，我要说，让我们

00:08:52.430 --> 00:08:58.400
只是说我们要订购表

00:08:55.550 --> 00:09:02.330
有一个称为客户FK的外键

00:08:58.400 --> 00:09:03.710
好吧，这是另一个实例

00:09:02.330 --> 00:09:05.300
知道这一点，我想着

00:09:03.710 --> 00:09:09.620
产品订单，例如网站上的订单

00:09:05.300 --> 00:09:13.250
那就是那很有趣

00:09:09.620 --> 00:09:16.160
表名，因为订单是保留的

00:09:13.250 --> 00:09:18.380
和中的某些方言中的关键字

00:09:16.160 --> 00:09:21.110
我喜欢确定的顺序

00:09:18.380 --> 00:09:24.170
续集的方言正确，我们不想要

00:09:21.110 --> 00:09:29.300
违反解析器的，所以我

00:09:24.170 --> 00:09:31.370
将该表重命名为orders， 

00:09:29.300 --> 00:09:38.180
你知道只是为了保持一致，我会

00:09:31.370 --> 00:09:39.200
重命名这个客户好吧

00:09:38.180 --> 00:09:41.900
我们在那里，有两个不同

00:09:39.200 --> 00:09:44.150
记录他们彼此相关

00:09:41.900 --> 00:09:45.350
你是一对多的关系

00:09:44.150 --> 00:09:47.510
知道你也可以双向

00:09:45.350 --> 00:09:49.100
你本来可以订购的东西

00:09:47.510 --> 00:09:51.080
如果需要，可以参考给客户

00:09:49.100 --> 00:09:53.780
在这种情况下，我真的不需要它

00:09:51.080 --> 00:09:57.370
这种情况，但很高兴我们也

00:09:53.780 --> 00:09:59.240
想找个借口，我认为

00:09:57.370 --> 00:10:01.250
复杂的，因为我们要去

00:09:59.240 --> 00:10:04.970
此域先生。园区产品代码

00:10:01.250 --> 00:10:06.290
现在我们的工作是将一些数据写入

00:10:04.970 --> 00:10:10.100
数据库，以便我们继续

00:10:06.290 --> 00:10:12.350
在我们使用Springs基本JP支持之前

00:10:10.100 --> 00:10:13.910
甚至可以获取 spring data 和一些

00:10:12.350 --> 00:10:15.590
我们将提供更完善的支持

00:10:13.910 --> 00:10:17.870
使用绝对的基本支持

00:10:15.590 --> 00:10:20.090
永远在 Spring ，我的意思是只有你

00:10:17.870 --> 00:10:23.210
知道，自从JP基本问世以来

00:10:20.090 --> 00:10:26.210
大约是什么时候JP a 

00:10:23.210 --> 00:10:30.250
你知道的相机早在2000年就可以了

00:10:26.210 --> 00:10:33.260
支持，让我们看看JP a 

00:10:30.250 --> 00:10:34.760
应用程序作者，我们只是

00:10:33.260 --> 00:10:37.060
使用以下命令将一些数据写入数据库

00:10:34.760 --> 00:10:42.100
我会在这里回船尾

00:10:37.060 --> 00:10:42.100
申请和亚军

00:10:42.560 --> 00:10:50.400
应用程序启动时将

00:10:46.140 --> 00:10:52.500
注入当前的实体经理，以便这些

00:10:50.400 --> 00:10:56.850
 Spring Framework 中的重要性

00:10:52.500 --> 00:10:59.420
以此类推，对于JPA，我认为

00:10:56.850 --> 00:11:02.670
你必须选择一个新的本地人

00:10:59.420 --> 00:11:05.010
实体经理工厂团队好吧

00:11:02.670 --> 00:11:08.700
这是当地的能源经理工厂

00:11:05.010 --> 00:11:11.550
 bean ，这东西已经存在

00:11:08.700 --> 00:11:14.850
因为Trudeau现在就开始

00:11:11.550 --> 00:11:17.450
在2018年中使用5的 Spring 形式

00:11:14.850 --> 00:11:20.460
的东西，你将要使用

00:11:17.450 --> 00:11:25.140
 Jaypee 2.1支持您必须拥有

00:11:20.460 --> 00:11:26.940
作为运行时映像，但嗯，但基本上

00:11:25.140 --> 00:11:30.170
所有这一切都是一个

00:11:26.940 --> 00:11:33.930
时间长了，最主要的是

00:11:30.170 --> 00:11:39.660
这主要是

00:11:33.930 --> 00:11:43.260
支持会给您一个实体

00:11:39.660 --> 00:11:45.360
知道 Spring 的经理

00:11:43.260 --> 00:11:47.400
基础设施之类的交易

00:11:45.360 --> 00:11:50.460
等等，它也给你一个实体

00:11:47.400 --> 00:11:55.200
线程安全的经理

00:11:50.460 --> 00:11:58.290
这是围绕着许多

00:11:55.200 --> 00:12:00.960
不同的实体经理

00:11:58.290 --> 00:12:02.970
本身是线程局部的，因此请保留

00:12:00.960 --> 00:12:07.410
介意实体经理的规范是

00:12:02.970 --> 00:12:10.140
不是线程安全的，这没关系

00:12:07.410 --> 00:12:12.510
因为规范是写的

00:12:10.140 --> 00:12:15.090
例如EJB 3之类的技术

00:12:12.510 --> 00:12:17.220
实体经理将在哪里

00:12:15.090 --> 00:12:20.790
假设你写

00:12:17.220 --> 00:12:26.550
像这样的持久性上下文

00:12:20.790 --> 00:12:27.600
实体，您的经理可以，您可以通过

00:12:26.550 --> 00:12:29.400
实际的工作方式

00:12:27.600 --> 00:12:31.830
 Spring ，我不是，我不是偶然喜欢

00:12:29.400 --> 00:12:34.470
这种风格我倾向于使用构造函数

00:12:31.830 --> 00:12:40.290
这样的私人决赛

00:12:34.470 --> 00:12:44.160
该样式假定

00:12:40.290 --> 00:12:46.050
包含对象只会永远

00:12:44.160 --> 00:12:48.210
请牢记一个线程使用

00:12:46.050 --> 00:12:49.950
Spring 物体只是一个提示

00:12:48.210 --> 00:12:51.960
不管有多少个

00:12:49.950 --> 00:12:53.970
线程，所以如果您继续注入

00:12:51.960 --> 00:12:54.970
指向服务的指针，例如

00:12:53.970 --> 00:12:59.889
用途

00:12:54.970 --> 00:13:01.269
和实体经理，您可以致电

00:12:59.889 --> 00:13:03.459
来自不同线程的服务

00:13:01.269 --> 00:13:06.310
例如许多不同的线程

00:13:03.459 --> 00:13:08.829
用于服务到达的请求

00:13:06.310 --> 00:13:10.300
每个servlet容器示例

00:13:08.829 --> 00:13:12.880
您致电该服务的时间

00:13:10.300 --> 00:13:14.800
您正在该服务中调用方法

00:13:12.880 --> 00:13:16.269
然后在中调用实体管理器

00:13:14.800 --> 00:13:18.160
中的那个线程，或者你知道

00:13:16.269 --> 00:13:19.959
结果是您原来的线程

00:13:18.160 --> 00:13:22.089
并发呼叫比任何经理

00:13:19.959 --> 00:13:24.069
你不应该做对的事情

00:13:22.089 --> 00:13:28.480
记住EJ蜜蜂的工作方式EJ蜜蜂是

00:13:24.069 --> 00:13:30.519
汇集您在一个对象中有多个对象

00:13:28.480 --> 00:13:34.740
池和容器的应用

00:13:30.519 --> 00:13:37.000
服务器获取该bean的实例， 

00:13:34.740 --> 00:13:39.819
每个都有一个该bean的实例

00:13:37.000 --> 00:13:41.740
传入请求，然后销毁

00:13:39.819 --> 00:13:43.990
那个beans或放回池中

00:13:41.740 --> 00:13:45.790
这整个钝化

00:13:43.990 --> 00:13:48.370
您必须处于的激活生命周期

00:13:45.790 --> 00:13:49.779
知道等等，这样你就知道了

00:13:48.370 --> 00:13:51.120
他们外出制造新的宝石

00:13:49.779 --> 00:13:54.910
确保您可以编写的代码是

00:13:51.120 --> 00:13:56.560
本质上是单线程的，即使

00:13:54.910 --> 00:13:59.259
它必须在多线程中使用

00:13:56.560 --> 00:14:00.370
 Spring 的世界很好，只有一颗 bean 

00:13:59.259 --> 00:14:01.779
你只有一个对象

00:14:00.370 --> 00:14:03.220
多线程它必须是

00:14:01.779 --> 00:14:05.410
多线程，无论您在其中做什么

00:14:03.220 --> 00:14:06.970
是多线程的，因此如果您使用

00:14:05.410 --> 00:14:08.980
您必须注意的实体经理

00:14:06.970 --> 00:14:10.930
直到 Spring 实际上创造了一个

00:14:08.980 --> 00:14:14.019
代理，我们为您提供实体的代理

00:14:10.930 --> 00:14:16.480
然后自己管理一个整体的经理

00:14:14.019 --> 00:14:18.819
实体管理者库并确保

00:14:16.480 --> 00:14:20.649
在那边有一个实体经理

00:14:18.819 --> 00:14:23.319
您正在制作的当前线程

00:14:20.649 --> 00:14:25.720
他们的要求，最终结果

00:14:23.319 --> 00:14:27.610
很好吗，它可以写

00:14:25.720 --> 00:14:31.240
看起来完全一样的代码

00:14:27.610 --> 00:14:33.459
在2005年的b3中见过，但是

00:14:31.240 --> 00:14:35.620
正确运作的好处是您可以

00:14:33.459 --> 00:14:37.600
只是编写代码并继续前进，所以现在我们

00:14:35.620 --> 00:14:39.910
现在有这个基本的实体经理

00:14:37.600 --> 00:14:42.490
需要使用我们实际上需要的感染

00:14:39.910 --> 00:14:45.250
直接在交易中运行此代码

00:14:42.490 --> 00:14:47.050
为了使其正常工作，请使用

00:14:45.250 --> 00:14:50.079
常规的裸体实体经理，您需要

00:14:47.050 --> 00:14:52.089
交易，所以我要用

00:14:50.079 --> 00:14:54.189
我正在建立可以使用的服务

00:14:52.089 --> 00:14:56.350
事务性添加交易

00:14:54.189 --> 00:14:58.899
服务上的注释，然后全部

00:14:56.350 --> 00:15:00.160
那里的方法，将在

00:14:58.899 --> 00:15:02.170
每当您调用那些交易时

00:15:00.160 --> 00:15:04.059
方法，但为了能够运行

00:15:02.170 --> 00:15:06.520
同一运行方法上有多个事物

00:15:04.059 --> 00:15:09.220
我要划定交易范围

00:15:06.520 --> 00:15:11.560
此处使用

00:15:09.220 --> 00:15:13.930
交易模板确定交易

00:15:11.560 --> 00:15:15.220
模板已经连接好了

00:15:13.930 --> 00:15:17.950
我们已经为我们配置了

00:15:15.220 --> 00:15:22.240
在 spring boot 上，它被赋予了

00:15:17.950 --> 00:15:29.530
指向JPA事务管理器的指针

00:15:22.240 --> 00:15:33.930
好的，JP，有交易经理

00:15:29.530 --> 00:15:35.800
这件事知道GPA 

00:15:33.930 --> 00:15:38.170
交易，所以这又是一个

00:15:35.800 --> 00:15:42.360
资源本地实施

00:15:38.170 --> 00:15:45.850
 JP中的交易管理工具

00:15:42.360 --> 00:15:51.640
该交易模板为我们提供了

00:15:45.850 --> 00:15:53.470
我们可以用来启动的统一API 

00:15:51.640 --> 00:15:55.450
并停止要使用的交易

00:15:53.470 --> 00:15:56.710
他们等等，所以你基本上只使用

00:15:55.450 --> 00:15:58.600
流量模板方法称为

00:15:56.710 --> 00:16:02.590
执行，里面的一切都会得到

00:15:58.600 --> 00:16:04.510
现在执行而不是交易

00:16:02.590 --> 00:16:07.510
我应该说的是，你可以

00:16:04.510 --> 00:16:10.720
也可以和JP一起使用，您可以使用JTA 

00:16:07.510 --> 00:16:12.430
 Java事务是API 

00:16:10.720 --> 00:16:14.470
 X的客户端中间件

00:16:12.430 --> 00:16:17.530
开放协议，我做了另一个

00:16:14.470 --> 00:16:19.180
我和JTA的 spring 技巧 分期付款

00:16:17.530 --> 00:16:20.260
鼓励您检查一下，如果

00:16:19.180 --> 00:16:23.230
您使用JTA 

00:16:20.260 --> 00:16:26.560
与休眠和与JP a和

00:16:23.230 --> 00:16:28.180
 Spring 足以说有一个

00:16:26.560 --> 00:16:31.260
您需要的整个星系

00:16:28.180 --> 00:16:34.030
正确并为了做到这一点

00:16:31.260 --> 00:16:36.040
但是spring boot下的spring boot 

00:16:34.030 --> 00:16:37.900
尽力做到这一点

00:16:36.040 --> 00:16:42.450
这样的事情对你有用，所以如果你

00:16:37.900 --> 00:16:45.520
在这里查看JPA自动配置

00:16:42.450 --> 00:16:48.730
休眠JP一个自动配置你

00:16:45.520 --> 00:16:50.650
可以看到这将使用

00:16:48.730 --> 00:16:53.110
本地容器实体管理者因素

00:16:50.650 --> 00:16:57.190
梁，它将导入

00:16:53.110 --> 00:17:00.520
休眠JP的配置，您可以

00:16:57.190 --> 00:17:02.470
看到这个配置是

00:17:00.520 --> 00:17:05.560
你不想写信我

00:17:02.470 --> 00:17:09.580
不想写这段代码，这段代码是

00:17:05.560 --> 00:17:13.270
配置休眠的代码及其

00:17:09.580 --> 00:17:15.459
配置JP，以便它

00:17:13.270 --> 00:17:17.830
配置一个JTA事务管理器

00:17:15.459 --> 00:17:19.049
基于任一应用程序服务器

00:17:17.830 --> 00:17:21.689
环境

00:17:19.049 --> 00:17:24.089
 JDI绑定的事务管理器和/或

00:17:21.689 --> 00:17:26.279
用户交易，然后进行配置

00:17:24.089 --> 00:17:27.509
休眠所需的属性

00:17:26.279 --> 00:17:29.309
了解特定于供应商的信息

00:17:27.509 --> 00:17:30.000
休眠需要知道的属性

00:17:29.309 --> 00:17:32.730
关于

00:17:30.000 --> 00:17:35.450
 -然后代表 Spring JK 

00:17:32.730 --> 00:17:38.039
交易经理，当然不在

00:17:35.450 --> 00:17:40.980
 Websphere当然会发生问题

00:17:38.039 --> 00:17:43.860
可怕的是因为韦伯斯特的怪异他们

00:17:40.980 --> 00:17:45.539
知道所有其他应用服务器，所以我们

00:17:43.860 --> 00:17:48.179
知道这段代码知道所有这些

00:17:45.539 --> 00:17:50.429
暴行，它使它适用于

00:17:48.179 --> 00:17:51.600
你基本上可以得到你可以使用

00:17:50.429 --> 00:17:53.429
这会为你做正确的事

00:17:51.600 --> 00:17:55.549
以及是否使用和如果要使用

00:17:53.429 --> 00:17:58.320
如其他视频中所述的JTA 

00:17:55.549 --> 00:18:00.000
你会你会知道它将起作用

00:17:58.320 --> 00:18:01.919
它就是正确的，嗯，那是

00:18:00.000 --> 00:18:04.080
你不写的代码相信我

00:18:01.919 --> 00:18:07.679
没有其他人想写，但是写完了

00:18:04.080 --> 00:18:09.029
现在为您准备的

00:18:07.679 --> 00:18:10.710
只是写到目前为止，这是非常非常非常

00:18:09.029 --> 00:18:12.840
使用

00:18:10.710 --> 00:18:14.460
进入经理API，所以我

00:18:12.840 --> 00:18:18.350
要说我要说TT点

00:18:14.460 --> 00:18:24.269
执行权实际上是模板

00:18:18.350 --> 00:18:28.649
这会给我一个回调，我

00:18:24.269 --> 00:18:29.879
回调期望我

00:18:28.649 --> 00:18:32.879
在这种情况下，我可以返回值

00:18:29.879 --> 00:18:35.730
返回null我实际上可以使用新

00:18:32.879 --> 00:18:37.529
事务回调，无无

00:18:35.730 --> 00:18:41.970
结果或类似的东西，如果我喜欢

00:18:37.529 --> 00:18:44.279
但在这里我将只使用

00:18:41.970 --> 00:18:46.320
需要返回值的版本

00:18:44.279 --> 00:18:47.909
因为我宁愿使用lambda形式

00:18:46.320 --> 00:18:50.039
而不是必须使用匿名

00:18:47.909 --> 00:18:52.769
内部类的形式

00:18:50.039 --> 00:18:54.720
现在请阅读差异请求

00:18:52.769 --> 00:18:57.090
数据今天的硬编码一些用户你

00:18:54.720 --> 00:18:59.279
知道我经常这样做，所以戴夫我要他们

00:18:57.090 --> 00:19:02.970
抱歉，我们写一些人作为客户

00:18:59.279 --> 00:19:05.429
菲尔-菲尔公共网络，当然

00:19:02.970 --> 00:19:07.320
标记逗号费舍尔，所以我们到了

00:19:05.429 --> 00:19:11.759
有一些名字我要分开名字

00:19:07.320 --> 00:19:15.680
里面有一个名字数组

00:19:11.759 --> 00:19:17.750
然后我要映射每个名字

00:19:15.680 --> 00:19:20.780
成一个元组，我要分割名称

00:19:17.750 --> 00:19:24.680
分为两成

00:19:20.780 --> 00:19:27.680
名和姓，然后最后

00:19:24.680 --> 00:19:30.620
我将拜访它的元组

00:19:27.680 --> 00:19:34.510
元组，我要保留我的数据

00:19:30.620 --> 00:19:37.670
要说这个DM持续新的

00:19:34.510 --> 00:19:39.260
客户，这里我有客户

00:19:37.670 --> 00:19:41.990
现在这个客户需要一个构造函数

00:19:39.260 --> 00:19:44.870
对于JP，我可能想

00:19:41.990 --> 00:19:46.100
想要得到错误和二传手

00:19:44.870 --> 00:19:49.010
和哈希码以及所有类似的东西

00:19:46.100 --> 00:19:50.840
所以我在这里我大量使用龙目岛

00:19:49.010 --> 00:19:53.809
所以我要说说我们所有的数据

00:19:50.840 --> 00:19:55.790
没有日志指导员的构造函数

00:19:53.809 --> 00:19:57.170
并记住您需要一个订单， 

00:19:55.790 --> 00:19:59.390
 JP的构造函数

00:19:57.170 --> 00:20:03.160
公开，但您确实需要，所以这

00:19:59.390 --> 00:20:05.750
您实际上可以接下来说的有用

00:20:03.160 --> 00:20:08.890
力等于真，你可以做所有

00:20:05.750 --> 00:20:11.900
您可能会说访问等于

00:20:08.890 --> 00:20:13.280
私人然后强迫它是真的，所以

00:20:11.900 --> 00:20:15.710
你可以做那样的事情

00:20:13.280 --> 00:20:19.490
但我不在乎你知道

00:20:15.710 --> 00:20:21.290
好吧，所以我们现在知道了， 

00:20:19.490 --> 00:20:24.230
现在我们要保存一些数据

00:20:21.290 --> 00:20:26.059
我们的构造函数

00:20:24.230 --> 00:20:28.010
 get是一个，它需要一个ID为null 

00:20:26.059 --> 00:20:31.070
 ID当然是名字

00:20:28.010 --> 00:20:32.900
元组的第一部分

00:20:31.070 --> 00:20:35.059
名称将是第二部分

00:20:32.900 --> 00:20:39.110
元组，然后我们将只返回给定

00:20:35.059 --> 00:20:40.820
它是一系列订单的清单

00:20:39.110 --> 00:20:42.860
空订单集，所以我们有

00:20:40.820 --> 00:20:46.900
持续存在于

00:20:42.860 --> 00:20:51.920
网关，现在我们将使用

00:20:46.900 --> 00:20:54.940
实体经理来创建查询，所以我

00:20:51.920 --> 00:20:58.760
要在此处创建查询，请从中选择C 

00:20:54.940 --> 00:21:00.020
客户知道那是什么

00:20:58.760 --> 00:21:02.960
其实我们就那样做，让我

00:21:00.020 --> 00:21:05.030
说一个客户类型列表

00:21:02.960 --> 00:21:08.870
数据返回我的意思是

00:21:05.030 --> 00:21:13.490
查询方法将带给我们一个头

00:21:08.870 --> 00:21:17.660
查询对象，所以我们是客户

00:21:13.490 --> 00:21:19.610
并因此我要

00:21:17.660 --> 00:21:20.090
结果这次拜访每一个来

00:21:19.610 --> 00:21:23.120
背部

00:21:20.090 --> 00:21:27.050
所以这是每个客户，我想

00:21:23.120 --> 00:21:32.150
注销我要合成龙目岛

00:21:27.050 --> 00:21:38.210
对我来说，一个log4j记录器也是

00:21:32.150 --> 00:21:40.480
日志信息类型的查询结果将为和

00:21:38.210 --> 00:21:43.280
然后在这里我将使用下议院土地

00:21:40.480 --> 00:21:44.570
注销我们获得的信息

00:21:43.280 --> 00:21:47.000
我们收到了反馈，因为我要做

00:21:44.570 --> 00:21:49.250
在我们当时的那段时间

00:21:47.000 --> 00:21:50.570
一起度过不同的时光

00:21:49.250 --> 00:21:51.020
结果有人只是说下议院线

00:21:50.570 --> 00:21:52.760
三

00:21:51.020 --> 00:21:54.080
我会把它放在版本中

00:21:52.760 --> 00:21:56.540
已经为我做好了，所以我只需要

00:21:54.080 --> 00:22:02.810
宣布它，然后在音乐中如此

00:21:56.540 --> 00:22:06.460
我要说日志点信息到字符串

00:22:02.810 --> 00:22:10.030
生成器点反射到字符串

00:22:06.460 --> 00:22:10.030
客户没事

00:22:10.250 --> 00:22:14.020
所以我们就已经被抢劫了

00:22:12.470 --> 00:22:18.350
因为我们不这样做，所以我们不需要

00:22:14.020 --> 00:22:22.000
再见，好吧，让我们看看如果得到

00:22:18.350 --> 00:22:22.000
我们按编写的方式运行此代码

00:22:29.930 --> 00:22:33.370
我们的服务器我认为你很困惑

00:22:32.240 --> 00:22:37.220
我的朋友也是

00:22:33.370 --> 00:22:39.980
是的，这是在混乱中完成的，所以

00:22:37.220 --> 00:22:47.890
我们有某种错误是什么

00:22:39.980 --> 00:22:47.890
错误哦零索引

00:22:51.160 --> 00:22:56.230
很好，看一下我们写的

00:22:54.250 --> 00:22:58.179
数据

00:22:56.230 --> 00:23:02.860
他们已经写了数据，我们可以看到

00:22:58.179 --> 00:23:05.320
休眠足以创建

00:23:02.860 --> 00:23:07.000
上次运行时为我们提供的表格

00:23:05.320 --> 00:23:09.610
我们必须在这里添加约束

00:23:07.000 --> 00:23:11.890
它仍然在做一些事情，这是

00:23:09.610 --> 00:23:14.410
插入调用分为三个不同的

00:23:11.890 --> 00:23:16.660
插入，然后插入我们刚才的查询

00:23:14.410 --> 00:23:19.360
我们只是跑了，因为没有一个

00:23:16.660 --> 00:23:21.160
还有其他我们不知道的记录

00:23:19.360 --> 00:23:22.900
我们没有访问任何这些记录， 

00:23:21.160 --> 00:23:24.580
得到了我们所期望的一切

00:23:22.900 --> 00:23:25.840
所以首先要有结果

00:23:24.580 --> 00:23:28.059
空订单中的姓氏

00:23:25.840 --> 00:23:31.480
收集好，这样算出来

00:23:28.059 --> 00:23:33.220
下次我还好

00:23:31.480 --> 00:23:38.380
让我们继续，现在添加一些订单

00:23:33.220 --> 00:23:40.150
看看我们有权看到什么

00:23:38.380 --> 00:23:42.340
我们可以使用嵌套或

00:23:40.150 --> 00:23:44.350
从属集合，但为了

00:23:42.340 --> 00:23:46.600
与JP一起工作

00:23:44.350 --> 00:23:48.700
比使用常规更容易

00:23:46.600 --> 00:23:51.040
您知道是公平的实体经理

00:23:48.700 --> 00:23:53.020
还不错，我们只是拒绝了

00:23:51.040 --> 00:23:55.540
用它来使生活变得美好

00:23:53.020 --> 00:23:57.100
我喜欢用Spring ，容易一些

00:23:55.540 --> 00:24:02.140
数据存储库好吧，我要

00:23:57.100 --> 00:24:04.120
创建一个客户存储库

00:24:02.140 --> 00:24:06.700
将扩展JPA存储库，并

00:24:04.120 --> 00:24:09.130
操作类型为的实体

00:24:06.700 --> 00:24:12.400
等级不是类型的客户

00:24:09.130 --> 00:24:13.809
很久以前，我认为这是

00:24:12.400 --> 00:24:16.510
对观众来说可能很有趣

00:24:13.809 --> 00:24:18.220
知道JPA信息库是

00:24:16.510 --> 00:24:19.990
支持的第一个存储库类型

00:24:18.220 --> 00:24:22.660
 spring data ，它来自

00:24:19.990 --> 00:24:25.150
第三方产品社区项目

00:24:22.660 --> 00:24:27.610
由现在的 Spring 所维护

00:24:25.150 --> 00:24:31.660
数据再次重新引导好吗

00:24:27.610 --> 00:24:32.890
 Hades hade s，它有一个你知道的东西

00:24:31.660 --> 00:24:36.309
有这个基于

00:24:32.890 --> 00:24:38.380
当前数据的机制还可以

00:24:36.309 --> 00:24:40.750
那是Jaypee资料库，我可以

00:24:38.380 --> 00:24:42.190
用它来读写，保存以及

00:24:40.750 --> 00:24:46.410
操作数据，以便我们做

00:24:42.190 --> 00:24:48.760
在这里，我们创建另一个交易

00:24:46.410 --> 00:24:50.110
好的我

00:24:48.760 --> 00:24:52.660
你知道我不在乎状态

00:24:50.110 --> 00:24:54.430
实际上并处于十大地位

00:24:52.660 --> 00:24:56.680
矢量我们要写数据到

00:24:54.430 --> 00:25:00.640
我们向每个数据库写入订单的数据库

00:24:56.680 --> 00:25:04.080
每个客户，所以我要说

00:25:00.640 --> 00:25:04.080
在这里注入正面的客户

00:25:04.860 --> 00:25:12.090
好吧，归功于最终客户

00:25:08.320 --> 00:25:14.650
 II，那是构造函数，很好

00:25:12.090 --> 00:25:16.150
现在我要把我们的数据写到

00:25:14.650 --> 00:25:20.050
那里的数据库说我们上交了旧的

00:25:16.150 --> 00:25:22.630
我们的状态并获取所有记录，以便

00:25:20.050 --> 00:25:24.250
积极寻找所有客户

00:25:22.630 --> 00:25:26.950
所有的顾客，然后从

00:25:24.250 --> 00:25:28.690
我想创建更多的每个客户

00:25:26.950 --> 00:25:33.520
数据，所以我要下订单

00:25:28.690 --> 00:25:39.580
要说int max等于数学点随机

00:25:33.520 --> 00:25:43.870
乘以五，我们想把它变成

00:25:39.580 --> 00:25:49.170
一个整数，然后正确测试

00:25:43.870 --> 00:25:52.900
这是我们的订单计数

00:25:49.170 --> 00:25:55.300
我们要说int我等于零我

00:25:52.900 --> 00:25:58.950
小于我加加的订单数

00:25:55.300 --> 00:26:04.300
我们将为客户添加一条记录

00:25:58.950 --> 00:26:06.430
订单收集使其保持一致

00:26:04.300 --> 00:26:11.110
正确查看，以便我们能够

00:26:06.430 --> 00:26:13.810
稍后查询，以便偏斜

00:26:11.110 --> 00:26:15.600
和小姐，我-这不是真实的你

00:26:13.810 --> 00:26:19.630
看起来像但是很好

00:26:15.600 --> 00:26:21.040
非常好，所以现在我们有一些

00:26:19.630 --> 00:26:22.840
不同的记录，每个记录是

00:26:21.040 --> 00:26:24.530
会有自己的真实身份证，但他们

00:26:22.840 --> 00:26:26.670
应该有

00:26:24.530 --> 00:26:28.740
好，应该有一个共同的坐姿

00:26:26.670 --> 00:26:32.100
在那边，当然我们需要保存

00:26:28.740 --> 00:26:33.150
对数据库的更改

00:26:32.100 --> 00:26:35.700
说我要说倡导者

00:26:33.150 --> 00:26:38.430
存储库通常映射到

00:26:35.700 --> 00:26:39.930
聚合，所以这个命令是我不是

00:26:38.430 --> 00:26:42.450
那个顾客就是总数

00:26:39.930 --> 00:26:44.430
好吧，所有这一切都会在

00:26:42.450 --> 00:26:49.550
一笔交易，所以我们当然是我

00:26:44.430 --> 00:26:52.080
那首诗在这里丢个例外

00:26:49.550 --> 00:26:54.510
即使我已经完成了所有这些工作

00:26:52.080 --> 00:26:55.890
到那时，一切都会回滚

00:26:54.510 --> 00:26:59.700
你不会看到它反映在这些

00:26:55.890 --> 00:27:02.300
现在在数据库中，让我们开始吧

00:26:59.700 --> 00:27:02.300
继续并运行这个

00:27:10.980 --> 00:27:16.619
好吧，看起来效果很好，所以

00:27:14.159 --> 00:27:18.179
我们知道它正在工作，让我们查询

00:27:16.619 --> 00:27:22.409
数据让我们实际询问

00:27:18.179 --> 00:27:23.730
数据更多，看看我们得到了什么

00:27:22.409 --> 00:27:26.970
我们如何查询它，所以我看着我

00:27:23.730 --> 00:27:29.039
使用实体撰写了手工职业

00:27:26.970 --> 00:27:31.139
经理你说你知道，然后选择

00:27:29.039 --> 00:27:33.059
客户从C看什么和IDE 

00:27:31.139 --> 00:27:35.700
正在尽最大努力为您提供帮助

00:27:33.059 --> 00:27:37.169
我在这里，但你知道我是一个大信徒

00:27:35.700 --> 00:27:38.850
如果代码中没有字符串

00:27:37.169 --> 00:27:40.499
你可以避免它，所以我要用

00:27:38.850 --> 00:27:42.480
存储库以创建自定义查找器

00:27:40.499 --> 00:27:45.359
方法，因此第一个Finder是

00:27:42.480 --> 00:27:46.889
将基于参数

00:27:45.359 --> 00:27:48.739
令人惊讶的谓词

00:27:46.889 --> 00:27:55.980
说给我一些顾客

00:27:48.739 --> 00:27:58.019
按字符串的第一个和最后一个字符串查找

00:27:55.980 --> 00:27:59.970
我会工作的，这会给我所有人

00:27:58.019 --> 00:28:03.830
客户的名字和

00:27:59.970 --> 00:28:03.830
他们的姓氏，让我们尝试一下

00:28:08.170 --> 00:28:17.770
翻笔记，在这里我们要说

00:28:14.890 --> 00:28:20.740
客户首先要找到并

00:28:17.770 --> 00:28:22.410
最后，戴夫（Dave）父亲，千万不要给我们

00:28:20.740 --> 00:28:30.010
匹配的人的集合

00:28:22.410 --> 00:28:32.770
戴夫的戴夫我要在这里注销戴夫

00:28:30.010 --> 00:28:36.400
好的，所以字符串生成器

00:28:32.770 --> 00:28:37.960
反射到字符串大卫非常好

00:28:36.400 --> 00:28:39.970
所以我们去那里，让我们看看是否

00:28:37.960 --> 00:28:49.140
该查询按预期运行

00:28:39.970 --> 00:28:49.140
确实有我们的

00:28:49.200 --> 00:28:56.890
我们在那里的不同记录，因此您可以

00:28:53.050 --> 00:28:58.210
看到我在这里有三张唱片

00:28:56.890 --> 00:29:00.460
因为我有三个

00:28:58.210 --> 00:29:02.350
多次运行此程序，我的

00:29:00.460 --> 00:29:03.730
续集保留了整个数据

00:29:02.350 --> 00:29:05.110
那些不同的跑步，所以我要去

00:29:03.730 --> 00:29:08.080
要做的就是保持环境清洁

00:29:05.110 --> 00:29:12.370
我只是说，我说我想要

00:29:08.080 --> 00:29:14.500
使用客户存储库删除

00:29:12.370 --> 00:29:16.450
一切首先只是清理

00:29:14.500 --> 00:29:19.050
这里的记录有点继续

00:29:16.450 --> 00:29:19.050
重新运行代码

00:29:19.940 --> 00:29:26.240
好吧，现在只有一天

00:29:22.450 --> 00:29:29.390
在控制台右侧，我们有零

00:29:26.240 --> 00:29:31.810
此特定订单再次尝试

00:29:29.390 --> 00:29:31.810
试试你的运气

00:29:36.620 --> 00:29:43.610
我们去那里，然后在这里跑

00:29:38.720 --> 00:29:47.059
您知道的一个以上订单

00:29:43.610 --> 00:29:49.519
依附于该客户，现在是

00:29:47.059 --> 00:29:51.379
非常自动的基于约定的排序

00:29:49.519 --> 00:29:54.529
查询位于

00:29:51.379 --> 00:29:56.090
此处的存储库基于约定

00:29:54.529 --> 00:29:58.039
这在所有

00:29:56.090 --> 00:29:59.690
您可以使用不同的 spring data 项目

00:29:58.039 --> 00:30:02.029
给它一个你可以创建查找器方法

00:29:59.690 --> 00:30:03.860
超出了默认支持

00:30:02.029 --> 00:30:05.509
这些常见的存储库

00:30:03.860 --> 00:30:08.450
存储库支持查找保存

00:30:05.509 --> 00:30:09.679
冲洗到需要等删除

00:30:08.450 --> 00:30:11.240
你知道什么适合

00:30:09.679 --> 00:30:13.399
手边的技术，您可以创造

00:30:11.240 --> 00:30:14.629
定制纤维当然也可以

00:30:13.399 --> 00:30:17.659
当然创建自己的自定义查找器

00:30:14.629 --> 00:30:20.509
与您知道的自定义工作人员的方法很奇怪

00:30:17.659 --> 00:30:24.470
名字等等五个全名字符串

00:30:20.509 --> 00:30:30.110
 F字符串你好，我要在这里使用

00:30:24.470 --> 00:30:32.990
那里的自定义同伴说从中选择C 

00:30:30.110 --> 00:30:38.240
客户首先看到的地方

00:30:32.990 --> 00:30:39.980
等于F并看到最后等于L和

00:30:38.240 --> 00:30:41.840
我指的是必须工作的 Spring 

00:30:39.980 --> 00:30:46.249
需要知道参数的名称

00:30:41.840 --> 00:30:49.730
所以我们给它一个婴儿车注解F和L 

00:30:46.249 --> 00:30:55.690
一切都设置好了，让我们重新来看一下

00:30:49.730 --> 00:30:59.889
完全相同的代码，全名和

00:30:55.690 --> 00:30:59.889
开始在这里分解一点

00:31:01.279 --> 00:31:08.629
好吧那又可以

00:31:11.950 --> 00:31:16.150
好吧，所以他们是相同的结果

00:31:14.410 --> 00:31:19.990
如您所料，没有什么特别

00:31:16.150 --> 00:31:21.130
在这里不同，所以我们有

00:31:19.990 --> 00:31:25.410
订购了一个客户，我们有

00:31:21.130 --> 00:31:27.820
订单，现在一切正常

00:31:25.410 --> 00:31:30.040
在这种情况下，我使用了自定义查询

00:31:27.820 --> 00:31:31.390
你知道我想做得更多

00:31:30.040 --> 00:31:35.400
有趣的事情

00:31:31.390 --> 00:31:35.400
必然映射到

00:31:35.760 --> 00:31:41.530
我可能会汇总手头的实体

00:31:38.740 --> 00:31:44.650
想做你知道的事情

00:31:41.530 --> 00:31:47.290
涉及数据权限的派生视图

00:31:44.650 --> 00:31:49.300
因此在这种情况下，我们可以使用本机查询

00:31:47.290 --> 00:31:51.160
好的，这是一个很好的功能

00:31:49.300 --> 00:31:54.430
在JP中，您实际上可以访问

00:31:51.160 --> 00:31:55.780
续集的全部力量有点

00:31:54.430 --> 00:31:58.480
麻烦，我认为这是其中之一

00:31:55.780 --> 00:32:02.200
使用类似规范的最大缺点

00:31:58.480 --> 00:32:04.150
 JP是您很长的路要走

00:32:02.200 --> 00:32:05.620
来自本地续集，但您仍然可以

00:32:04.150 --> 00:32:06.970
到达那里，只是您需要知道

00:32:05.620 --> 00:32:09.130
在哪里看

00:32:06.970 --> 00:32:11.250
好的，我们要创建一个报告

00:32:09.130 --> 00:32:14.710
基本上，当我得到一个新的端点时

00:32:11.250 --> 00:32:17.080
返回订单集合

00:32:14.710 --> 00:32:23.170
关于所有订单的摘要，所以我要

00:32:17.080 --> 00:32:25.510
说好订单摘要并为此订购

00:32:23.170 --> 00:32:27.490
工作当然我们需要一个项目

00:32:25.510 --> 00:32:29.170
类型称为订单摘要，因此在使用时

00:32:27.490 --> 00:32:30.040
所谓的投影和

00:32:29.170 --> 00:32:32.260
投影将是

00:32:30.040 --> 00:32:34.480
接口的实现

00:32:32.260 --> 00:32:38.170
我们要给JP， 

00:32:34.480 --> 00:32:43.300
投影将具有计数

00:32:38.170 --> 00:32:45.580
和SKU都很好，所以我们想

00:32:43.300 --> 00:32:49.840
创建一个使用该集合并

00:32:45.580 --> 00:32:52.060
我们需要告诉休眠和JPA， 

00:32:49.840 --> 00:32:54.580
这将被映射到本地

00:32:52.060 --> 00:32:56.440
查询和本机查询将是

00:32:54.580 --> 00:32:57.310
通过寻找其中之一解决

00:32:56.440 --> 00:33:00.220
我们已经注册的本地查询

00:32:57.310 --> 00:33:02.290
 JP a的名称顺序为

00:33:00.220 --> 00:33:05.770
无罪释放订单摘要，以便客户

00:33:02.290 --> 00:33:08.140
订单摘要，以便我们拥有

00:33:05.770 --> 00:33:11.160
该查询我们需要在此处注册

00:33:08.140 --> 00:33:14.020
我们的实体，所以我要说一下行为名称

00:33:11.160 --> 00:33:16.720
本机查询可以有多个

00:33:14.020 --> 00:33:19.040
与实体关联，例如在

00:33:16.720 --> 00:33:22.720
名为Nina的查询

00:33:19.040 --> 00:33:25.430
不休眠挑战持久性和

00:33:22.720 --> 00:33:30.850
机组人员的名字将是客户

00:33:25.430 --> 00:33:39.430
点顺序摘要和查询本身

00:33:30.850 --> 00:33:41.840
将选择偏斜作为偏斜以及我如何

00:33:39.430 --> 00:33:43.970
再挑战一次，这很重要

00:33:41.840 --> 00:33:45.680
需要在那里有别名，以便

00:33:43.970 --> 00:33:47.150
它们与我们的属性相匹配

00:33:45.680 --> 00:33:49.150
从这个会计师那里得到另一个

00:33:47.150 --> 00:33:52.850
在我们的投影中，它们是

00:33:49.150 --> 00:33:58.040
从，它被称为订单，当

00:33:52.850 --> 00:34:01.520
您需要按SKU确定订单组，这样

00:33:58.040 --> 00:34:03.890
这是我们的本机查询，不是

00:34:01.520 --> 00:34:13.580
我猜要做到这一点并不容易

00:34:03.890 --> 00:34:15.910
那是因为它猜测还可以，所以我们已经

00:34:13.580 --> 00:34:17.660
现在我们的实体我们有一个查询

00:34:15.910 --> 00:34:20.570
让我们看看它是否有效

00:34:17.660 --> 00:34:23.230
现在就可以运行此查询

00:34:20.570 --> 00:34:26.300
结果在那里，所以采取其中之一

00:34:23.230 --> 00:34:29.720
自定义存储库以订购摘要点

00:34:26.300 --> 00:34:36.169
对于每个摘要，我们要访问

00:34:29.720 --> 00:34:38.060
数据返回到同一

00:34:36.169 --> 00:34:41.960
和以前一样将字符串生成器a 

00:34:38.060 --> 00:34:45.640
已经反映到字符串摘要

00:34:41.960 --> 00:34:45.640
好东西让我们回到这个

00:34:49.770 --> 00:34:59.820
所以应该给我们一个代理，但是

00:34:55.980 --> 00:35:01.760
那不是我想要的，是我们想要的

00:34:59.820 --> 00:35:04.760
看数据

00:35:01.760 --> 00:35:04.760
嗯

00:35:11.960 --> 00:35:17.740
好吧，我想我们只需要打印它

00:35:14.240 --> 00:35:21.230
走出老式的方式

00:35:17.740 --> 00:35:29.000
是的，让我们这样做就好了，让我们

00:35:21.230 --> 00:35:34.100
说摘要点在夏天以Q表示Q 

00:35:29.000 --> 00:35:36.760
得到计数实例可以写

00:35:34.100 --> 00:35:36.760
再次编码

00:35:39.210 --> 00:35:43.109
好吧，你去那里，所以你可以看到

00:35:40.920 --> 00:35:46.559
有三个实例

00:35:43.109 --> 00:35:49.260
 q0的城市，您知道的三个实例

00:35:46.559 --> 00:35:52.260
倾斜一两个实例倾斜-一

00:35:49.260 --> 00:35:53.730
实例q3，所以实际上

00:35:52.260 --> 00:35:54.839
知道那意味着你知道你可以

00:35:53.730 --> 00:35:57.210
你可以在那里了解故障

00:35:54.839 --> 00:36:01.170
是的，我们有多少你知道的

00:35:57.210 --> 00:36:04.020
四个可能的偏斜，或者说五个

00:36:01.170 --> 00:36:07.079
可能歪斜什么多少

00:36:04.020 --> 00:36:09.089
您知道每个偏斜的实例都存在

00:36:07.079 --> 00:36:10.220
我们没有看过哪些客户

00:36:09.089 --> 00:36:12.359
客户在这里，我们只是看着

00:36:10.220 --> 00:36:15.450
这里总结使用汇总

00:36:12.359 --> 00:36:16.800
功能计数还可以，所以您可以获得

00:36:15.450 --> 00:36:18.480
访问我们，您可以访问

00:36:16.800 --> 00:36:20.490
低级续集，我认为这是一个

00:36:18.480 --> 00:36:22.829
我最喜欢的功能是

00:36:20.490 --> 00:36:24.930
能够使用低级续集

00:36:22.829 --> 00:36:26.339
引擎非常强大并具有

00:36:24.930 --> 00:36:28.770
自动映射到这些管道的

00:36:26.339 --> 00:36:31.470
他们强类型输入，对，这是

00:36:28.770 --> 00:36:33.869
我们到底要坚持什么

00:36:31.470 --> 00:36:37.290
它可以封送处理任何工作

00:36:33.869 --> 00:36:40.290
从这回到一个相当

00:36:37.290 --> 00:36:43.470
变成类型安全的表示形式

00:36:40.290 --> 00:36:45.480
我们可以吃得好，所以现在我们有一个习惯

00:36:43.470 --> 00:36:48.150
我们查询了不同的查询

00:36:45.480 --> 00:36:51.540
看着命名查询，所以我们现在在

00:36:48.150 --> 00:36:54.780
好看的好地方

00:36:51.540 --> 00:36:56.670
稍微高级一点的用例

00:36:54.780 --> 00:36:57.329
假设我想建立一个网站

00:36:56.670 --> 00:36:58.950
应用

00:36:57.329 --> 00:37:01.319
好的，让我们构建一个Web应用程序

00:36:58.950 --> 00:37:06.089
我很及时，你可能会想起时间

00:37:01.319 --> 00:37:08.190
使用视图模板引擎，我有

00:37:06.089 --> 00:37:10.530
 spring boot 在

00:37:08.190 --> 00:37:12.720
 classpath，所以这两个都会让

00:37:10.530 --> 00:37:14.369
我构建一个Web应用程序，然后

00:37:12.720 --> 00:37:15.780
建立与

00:37:14.369 --> 00:37:17.160
该数据与否无关紧要

00:37:15.780 --> 00:37:19.650
只是一个常规控制器

00:37:17.160 --> 00:37:24.299
被称为客户的视图

00:37:19.650 --> 00:37:28.650
控制器，我要注入客户

00:37:24.299 --> 00:37:31.829
在这里存储，我们将创建一个

00:37:28.650 --> 00:37:34.200
具有HTML页面和

00:37:31.829 --> 00:37:36.950
查看所有数据，现在考虑

00:37:34.200 --> 00:37:40.330
这里发生了什么我有数据

00:37:36.950 --> 00:37:43.690
客户点你知道

00:37:40.330 --> 00:37:49.680
没关系，没关系， 

00:37:43.690 --> 00:37:54.430
页面名称客户模型数据

00:37:49.680 --> 00:37:57.550
关闭客户我有一个看法， 

00:37:54.430 --> 00:37:59.050
该视图将渲染，并在

00:37:57.550 --> 00:38:01.390
视图，我们将在一分钟内查看V 

00:37:59.050 --> 00:38:03.550
但我认为所有

00:38:01.390 --> 00:38:05.200
客户记录以及其中的每一项

00:38:03.550 --> 00:38:07.780
我们以前看到的客户记录

00:38:05.200 --> 00:38:10.090
也有很多订单

00:38:07.780 --> 00:38:11.860
 JPA这个订单集合很懒

00:38:10.090 --> 00:38:14.650
您在结果中实际拥有的

00:38:11.860 --> 00:38:17.710
运行时应用程序对

00:38:14.650 --> 00:38:19.420
舱口盖，但这是一种代理类型

00:38:17.710 --> 00:38:20.770
来自冬眠的肠子

00:38:19.420 --> 00:38:23.320
不需要知道它是什么或如何

00:38:20.770 --> 00:38:25.060
可以，但是可以说这不是

00:38:23.320 --> 00:38:27.100
实际上所有下属记录

00:38:25.060 --> 00:38:30.100
您仅在以下情况下获得下属记录

00:38:27.100 --> 00:38:32.290
您触摸或遍历这些订单

00:38:30.100 --> 00:38:35.740
因此，如果您仅按住指向

00:38:32.290 --> 00:38:38.200
客户，不做任何事情

00:38:35.740 --> 00:38:40.270
与订单本身，然后没有数据

00:38:38.200 --> 00:38:41.590
将尽快从数据库中加载

00:38:40.270 --> 00:38:43.390
当您开始遍历那些

00:38:41.590 --> 00:38:44.980
像我一样记录

00:38:43.390 --> 00:38:47.470
使用字符串生成器

00:38:44.980 --> 00:38:49.300
递归地，你递归地知道它， 

00:38:47.470 --> 00:38:51.280
反思地下降到命令

00:38:49.300 --> 00:38:53.410
每当您开始收集时

00:38:51.280 --> 00:38:56.140
它不必从

00:38:53.410 --> 00:38:57.700
数据库权利，最好的情况是

00:38:56.140 --> 00:38:59.650
在最坏的情况下仅再进行一次额外查询

00:38:57.700 --> 00:39:01.720
如果你遇到n加一的问题

00:38:59.650 --> 00:39:04.690
您可以为每个选择一个

00:39:01.720 --> 00:39:05.580
订单，这是我们的另一个主题

00:39:04.690 --> 00:39:08.710
可以说一千种不同

00:39:05.580 --> 00:39:10.720
与查询优化有关的事情以及

00:39:08.710 --> 00:39:12.490
等等，但出于我们的目的，我们需要

00:39:10.720 --> 00:39:17.320
知道这是我的默认懒惰

00:39:12.490 --> 00:39:19.570
因此，如果您将此客户发送给

00:39:17.320 --> 00:39:21.250
当前之外的另一个上下文

00:39:19.570 --> 00:39:23.140
当前以外的交易

00:39:21.250 --> 00:39:25.390
使用JPA进行交易

00:39:23.140 --> 00:39:26.890
好吧，我们会遇到一些

00:39:25.390 --> 00:39:29.590
麻烦，如果我们尝试访问任何一个

00:39:26.890 --> 00:39:32.170
订单，所以如果你想像我们搬家

00:39:29.590 --> 00:39:36.040
该客户要呈现的视图

00:39:32.170 --> 00:39:38.140
好，对于Narender，我们需要

00:39:36.040 --> 00:39:40.030
能够确保获得的数据

00:39:38.140 --> 00:39:43.240
正确加载，所以我在这里

00:39:40.030 --> 00:39:45.220
没有什么可以照顾那些记录

00:39:43.240 --> 00:39:47.170
我仍然想在此渲染它

00:39:45.220 --> 00:39:48.800
视图，我必须创建此视图

00:39:47.170 --> 00:39:52.800
在这里创建视图

00:39:48.800 --> 00:39:55.230
马鬃毛资源模板创建一个

00:39:52.800 --> 00:39:57.090
这里的新文件称为eh- 

00:39:55.230 --> 00:40:00.990
不，那是时间的视图模板

00:39:57.090 --> 00:40:05.360
叶，如果不偷懒，我什么都不是

00:40:00.990 --> 00:40:06.570
朋友，所以我要在这里复制

00:40:05.360 --> 00:40:09.660
好的

00:40:06.570 --> 00:40:11.490
粘贴，您可以看到发生了什么

00:40:09.660 --> 00:40:14.970
这是一个非常简单的视图

00:40:11.490 --> 00:40:17.730
为每个客户见和客户

00:40:14.970 --> 00:40:19.370
模型属性打印出h2元素

00:40:17.730 --> 00:40:22.530
姓氏中的名字和

00:40:19.370 --> 00:40:26.520
然后访问每个订单并打印出

00:40:22.530 --> 00:40:27.560
 ID和SKU好吧，我想我们

00:40:26.520 --> 00:40:29.940
实际上可能是

00:40:27.560 --> 00:40:31.260
我猜这里有某种分隔符

00:40:29.940 --> 00:40:38.220
让我们考虑一下

00:40:31.260 --> 00:40:38.760
我可以的工作风格订单：1px卖给他们

00:40:38.220 --> 00:40:42.510
背部

00:40:38.760 --> 00:40:46.500
大卫走了，现在你可以希望看到

00:40:42.510 --> 00:40:49.710
我用CSS foo编写的HTML并不那么糟糕

00:40:46.500 --> 00:40:50.790
可以看到您知道可以看到的订单

00:40:49.710 --> 00:40:52.020
实际上所有不同的矿石

00:40:50.790 --> 00:40:53.820
线将在我们不需要的一侧

00:40:52.020 --> 00:40:55.620
那就让我们离开吧

00:40:53.820 --> 00:41:03.330
照原样，然后看看如果我们

00:40:55.620 --> 00:41:06.740
运行此代码，所以这是一个Spring MVC 

00:41:03.330 --> 00:41:10.620
控制器本地主机：8080 

00:41:06.740 --> 00:41:13.320
客户点视图，然后我们去

00:41:10.620 --> 00:41:14.940
可以看到此多维数据集的ID和XS Q 

00:41:13.320 --> 00:41:16.680
本身，我们可以看到有多少客户

00:41:14.940 --> 00:41:19.230
我们在数据库中，所以这又是

00:41:16.680 --> 00:41:21.510
随机的随机订单清单

00:41:19.230 --> 00:41:25.830
证明这一点，但嗯，你可以看到

00:41:21.510 --> 00:41:28.200
 SKU零不存在1 2 3倍

00:41:25.830 --> 00:41:30.330
好的，所以如果我们返回报告

00:41:28.200 --> 00:41:32.340
在这里您可以看到它说Q 0有

00:41:30.330 --> 00:41:33.990
三个实例，所以正在解决

00:41:32.340 --> 00:41:36.060
很好，我们实际上能够

00:41:33.990 --> 00:41:37.920
看看数据，即使我们已经移动

00:41:36.060 --> 00:41:39.480
它跨越外面的另一个边界

00:41:37.920 --> 00:41:41.430
交易方式

00:41:39.480 --> 00:41:45.360
这样做是默认情况下的 spring boot 

00:41:41.430 --> 00:41:47.970
配置打开的会话，然后您打开

00:41:45.360 --> 00:41:49.830
实体经理和视图模式，所以在这里

00:41:47.970 --> 00:41:52.530
这是一个开放的 Spring 开放API，可以查看

00:41:49.830 --> 00:41:54.330
如果我将其设置为false，则等于true 

00:41:52.530 --> 00:41:56.370
你可能想做，你知道你可能

00:41:54.330 --> 00:41:58.140
想要对自己通过的内容保持防御

00:41:56.370 --> 00:41:58.930
向下到视图层，这样

00:41:58.140 --> 00:42:01.900
点你不能

00:41:58.930 --> 00:42:03.760
他们打了数据库，所以如果我打那个

00:42:01.900 --> 00:42:06.250
如果我指定该属性并将其设置为

00:42:03.760 --> 00:42:11.530
是假的，让我们看看如果我现在会发生什么

00:42:06.250 --> 00:42:12.880
访问该页面去大错误

00:42:11.530 --> 00:42:14.619
我们刚刚得到的是

00:42:12.880 --> 00:42:16.329
它可以延迟初始化

00:42:14.619 --> 00:42:17.710
角色的集合等等等等等等

00:42:16.329 --> 00:42:20.800
就是告诉我没有

00:42:17.710 --> 00:42:23.740
会议开始，然后实现

00:42:20.800 --> 00:42:25.329
懒惰的数据收集，所以你

00:42:23.740 --> 00:42:27.550
你不知道你应该知道

00:42:25.329 --> 00:42:28.480
此功能正在配置中

00:42:27.550 --> 00:42:30.040
你自动

00:42:28.480 --> 00:42:32.109
我们会自动为其投放广告

00:42:30.040 --> 00:42:34.569
公开时间最长的实体经理

00:42:32.109 --> 00:42:36.220
一个新的过滤器就是这个东西， 

00:42:34.569 --> 00:42:37.780
 spring boot ，我不会只是

00:42:36.220 --> 00:42:39.460
如果您想在那里为您配置

00:42:37.780 --> 00:42:40.930
所以这已经永远存在了

00:42:39.460 --> 00:42:42.010
很高兴知道 Spring 食品有

00:42:40.930 --> 00:42:43.540
付出了更多的努力

00:42:42.010 --> 00:42:45.490
可用并使其适合您

00:42:43.540 --> 00:42:48.069
自动运行，以便一切正常

00:42:45.490 --> 00:42:50.410
好吧，所以现在我们有一个

00:42:48.069 --> 00:42:53.140
应用程序，它具有终结点HTML 

00:42:50.410 --> 00:42:55.390
应用程序HTML视图，但这是数据

00:42:53.140 --> 00:42:58.319
这是订单数据，所以您可能会说

00:42:55.390 --> 00:43:02.260
尤其是在

00:42:58.319 --> 00:43:05.140
你知道被黑客入侵

00:43:02.260 --> 00:43:07.089
而且我们是财务人员

00:43:05.140 --> 00:43:08.260
有点东西这种东西超级好

00:43:07.089 --> 00:43:10.690
重要的是我们拥有

00:43:08.260 --> 00:43:12.220
查看数据的能力

00:43:10.690 --> 00:43:14.220
能够看到发生了什么事， 

00:43:12.220 --> 00:43:17.349
因此，出于这个原因，我们将使用

00:43:14.220 --> 00:43:19.270
 spring数据支持审计还可以

00:43:17.349 --> 00:43:23.530
我们实际上将外部化

00:43:19.270 --> 00:43:25.690
将配置一些总和

00:43:23.530 --> 00:43:27.940
我们希望可见的信息

00:43:25.690 --> 00:43:29.680
在每条记录中，包括

00:43:27.940 --> 00:43:33.369
数据创建于日期

00:43:29.680 --> 00:43:35.170
修改，甚至可能是用户

00:43:33.369 --> 00:43:37.869
创建和/或修改该实体

00:43:35.170 --> 00:43:40.450
所以我们希望顺序可见

00:43:37.869 --> 00:43:41.980
为了做到这一点，我们需要先说

00:43:40.450 --> 00:43:44.760
我们必须经历的所有事情

00:43:41.980 --> 00:43:50.319
海军JP是

00:43:44.760 --> 00:43:52.480
和JPA奇数，然后对每个实体

00:43:50.319 --> 00:43:54.460
我们需要实际配置一个数字

00:43:52.480 --> 00:43:55.750
多余的东西，你的东西

00:43:54.460 --> 00:43:56.619
会认为我们可以集中精力， 

00:43:55.750 --> 00:43:58.630
实际上这就是我们要做的

00:43:56.619 --> 00:44:00.549
是我们要集中所有这些吗

00:43:58.630 --> 00:44:01.599
在整个过程中重复的事情

00:44:00.549 --> 00:44:04.420
不同的实体，让我们回头看看

00:44:01.599 --> 00:44:09.010
给我们的实体在这里的顺序和

00:44:04.420 --> 00:44:11.109
客户并创建地图超类

00:44:09.010 --> 00:44:12.400
这是JP是不是可以让您

00:44:11.109 --> 00:44:14.160
定义应该通用的东西

00:44:12.400 --> 00:44:16.540
跨给定实体的单个位置

00:44:14.160 --> 00:44:19.480
而新的需要只是扩展他们，所以

00:44:16.540 --> 00:44:23.980
类，让我们将此地图称为可审核

00:44:19.480 --> 00:44:25.510
如果这是一个词的基础，我要说

00:44:23.980 --> 00:44:28.000
我们想要应用

00:44:25.510 --> 00:44:31.000
 jp8实体侦听器好了，所以这是一个

00:44:28.000 --> 00:44:32.740
监听器叫审计并做

00:44:31.000 --> 00:44:34.750
这是来自 spring data GPA 

00:44:32.740 --> 00:44:39.880
再次，我们提供了支持

00:44:34.750 --> 00:44:41.440
框，您只需在JPA中回电

00:44:39.880 --> 00:44:43.930
在您知道的一个地方定义我们的ID 

00:44:41.440 --> 00:44:46.900
所有记录都会有一个

00:44:43.930 --> 00:44:51.069
善于折磨我们想要的主键

00:44:46.900 --> 00:44:52.420
了解何时该何时

00:44:51.069 --> 00:44:54.460
记录已创建，我要创建任何

00:44:52.420 --> 00:44:57.730
您还可以使用本地日期/时间字段

00:44:54.460 --> 00:45:00.849
 m8w直到日期，尽管我不是

00:44:57.730 --> 00:45:05.170
 Java到了2018年，请正确使用

00:45:00.849 --> 00:45:08.530
在这里，我们将使用一个

00:45:05.170 --> 00:45:15.520
最后修改日期，因此再次本地保存

00:45:08.530 --> 00:45:18.160
时间修改了，我们希望创造事物

00:45:15.520 --> 00:45:19.960
就是那个用户，我们会回来的

00:45:18.160 --> 00:45:21.880
一秒钟就完成了，但这是一个

00:45:19.960 --> 00:45:23.319
字符串，但它可能是一个好习惯

00:45:21.880 --> 00:45:26.370
成为您映射到的完整对象

00:45:23.319 --> 00:45:28.770
磁带将进入您的实体

00:45:26.370 --> 00:45:32.910
因为你想要但在这种情况下

00:45:28.770 --> 00:45:38.060
它只是名称的字符串

00:45:32.910 --> 00:45:38.060
创建者用户并通过修改进行了修改

00:45:38.600 --> 00:45:45.450
我会成为修正者，所以这些

00:45:43.830 --> 00:45:47.790
事情必须由这个提供

00:45:45.450 --> 00:45:49.470
审核实体侦听器，这是

00:45:47.790 --> 00:45:51.180
 Spring 的数据将为

00:45:49.470 --> 00:45:54.630
你寻找那些注释

00:45:51.180 --> 00:45:56.970
不管你叫什么名字

00:45:54.630 --> 00:45:58.740
并交替做所有事情

00:45:56.970 --> 00:46:00.960
利用钩子，你

00:45:58.740 --> 00:46:03.690
有，你也可以使用关节

00:46:00.960 --> 00:46:05.460
示例pre remove pre持久漂亮

00:46:03.690 --> 00:46:07.050
更新漂亮销毁帖子删除所有

00:46:05.460 --> 00:46:15.390
这些生命周期挂钩，所以如果您创建一个

00:46:07.050 --> 00:46:16.820
避免后删除的方法

00:46:15.390 --> 00:46:22.290
记录器在这里，我有两张照片要做

00:46:16.820 --> 00:46:24.030
好的，无论您可以登录

00:46:22.290 --> 00:46:25.710
每个人都在做什么

00:46:24.030 --> 00:46:27.840
这样的验证，那些东西

00:46:25.710 --> 00:46:29.310
有你在那儿，但我会

00:46:27.840 --> 00:46:32.880
离开这里，现在我们要

00:46:29.310 --> 00:46:33.960
扩展我们的订单和我们的客户

00:46:32.880 --> 00:46:36.770
该网站，所以让我们这样做

00:46:33.960 --> 00:46:42.710
我们的类型在哪里哦，是的，在这里

00:46:36.770 --> 00:46:45.310
扩展了映射的可审核面并

00:46:42.710 --> 00:46:47.590
扩展映射

00:46:45.310 --> 00:46:48.820
啊困难，在这种情况下，我们

00:46:47.590 --> 00:46:51.640
不再需要ID了

00:46:48.820 --> 00:46:53.920
我们的龙目岛配置，但想法

00:46:51.640 --> 00:47:03.280
基础课，所以我为此感到高兴

00:46:53.920 --> 00:47:13.000
让我们看看你再见，再见，好吧

00:47:03.280 --> 00:47:13.840
现在让我们再次运行代码，好吧

00:47:13.000 --> 00:47:18.190
在这里查看数据

00:47:13.840 --> 00:47:20.290
现在它说创建和修改，所以

00:47:18.190 --> 00:47:22.510
再次，这是日期和时间

00:47:20.290 --> 00:47:24.310
现在创建这些实例

00:47:22.510 --> 00:47:26.890
创建者字段和修饰符字段

00:47:24.310 --> 00:47:28.600
然后是用户名或我们

00:47:26.890 --> 00:47:31.360
可以用来追踪是谁做了这个改变

00:47:28.600 --> 00:47:32.530
为了我们现在缺席

00:47:31.360 --> 00:47:35.130
这样做是为了让我们拥有

00:47:32.530 --> 00:47:39.060
信息等待告诉斯皮内塔

00:47:35.130 --> 00:47:41.560
在哪里可以找到该信息

00:47:39.060 --> 00:47:43.840
这是任何常规的旧 Spring 

00:47:41.560 --> 00:47:46.660
我要称它为审计师

00:47:43.840 --> 00:47:48.760
实施审核员意识，并且必须

00:47:46.660 --> 00:47:51.970
产生正在寻找的信息

00:47:48.760 --> 00:47:55.320
为此，他们可以聘请Kurt审核员，并且- 

00:47:51.970 --> 00:47:57.730
你知道它没有人，那么它是空的

00:47:55.320 --> 00:47:59.620
这当然很好

00:47:57.730 --> 00:48:01.600
可能是我们可以使用Spring Security 

00:47:59.620 --> 00:48:03.790
对，如果我有Spring Security 保障

00:48:01.600 --> 00:48:07.420
我可以接受的classpath的缺点

00:48:03.790 --> 00:48:10.600
安全上下文点让您知道

00:48:07.420 --> 00:48:12.400
当前上下文等等等等，得到

00:48:10.600 --> 00:48:14.710
校长然后藏在那里

00:48:12.400 --> 00:48:16.270
可以返回可选的Java安全

00:48:14.710 --> 00:48:18.580
校长无论你在哪里

00:48:16.270 --> 00:48:21.520
想要做正确的事

00:48:18.580 --> 00:48:23.650
跟踪用户的机制是

00:48:21.520 --> 00:48:27.820
我们的情况下，我要注射

00:48:23.650 --> 00:48:30.190
用户名我的本地UNIX用户名

00:48:27.820 --> 00:48:31.750
用户，然后将其注入

00:48:30.190 --> 00:48:33.700
构造函数有一个非常简单的

00:48:31.750 --> 00:48:34.990
这个例子很愚蠢，但是很简单

00:48:33.700 --> 00:48:36.940
显然在生产应用中

00:48:34.990 --> 00:48:39.160
这将毫无意义，因为

00:48:36.940 --> 00:48:40.180
大多数代码都无法运行是的

00:48:39.160 --> 00:48:42.430
大多数时候，您会拥有我们的朋友

00:48:40.180 --> 00:48:44.410
前端网站，因此您想要

00:48:42.430 --> 00:48:46.240
知道谁是经过身份验证的用户

00:48:44.410 --> 00:48:48.460
不是

00:48:46.240 --> 00:48:49.690
他们处理多少东西或

00:48:48.460 --> 00:48:51.580
操作系统上的用户名

00:48:49.690 --> 00:48:55.990
一个根据这个应用程序

00:48:51.580 --> 00:48:58.860
正在运行，因此该用户是可选的

00:48:55.990 --> 00:49:02.110
好吧，所以我们在那里，还有我的我

00:48:58.860 --> 00:49:03.640
硬编码使用和密码的东西

00:49:02.110 --> 00:49:05.530
回调是重要的，所以

00:49:03.640 --> 00:49:07.570
实现该回调并告诉它

00:49:05.530 --> 00:49:10.080
在哪里找到数据，让我们看看

00:49:07.570 --> 00:49:10.080
是什么让我们

00:49:12.869 --> 00:49:17.640
已经，但是他们整天都在这个监狱里

00:49:15.809 --> 00:49:19.289
很长，所以现在正在填充这些领域

00:49:17.640 --> 00:49:22.380
就像我们希望的那样

00:49:19.289 --> 00:49:25.170
好吧，这是我认为这很好

00:49:22.380 --> 00:49:28.759
这是审核的良好第一步

00:49:25.170 --> 00:49:34.289
就是这样的数据

00:49:28.759 --> 00:49:36.329
那就是你知道的高风险

00:49:34.289 --> 00:49:38.640
您需要有一个环境

00:49:36.329 --> 00:49:40.589
每次更改的完整审核记录

00:49:38.640 --> 00:49:42.930
每一个单突变

00:49:40.589 --> 00:49:45.839
实体在系统中到处都是

00:49:42.930 --> 00:49:47.299
你在那种情况下，这可能

00:49:45.839 --> 00:49:49.559
你可能想看看还不够

00:49:47.299 --> 00:49:51.509
每一个变化每一个记录

00:49:49.559 --> 00:49:53.279
他们俩都去时光倒流

00:49:51.509 --> 00:49:54.480
看到了，所以有很多

00:49:53.279 --> 00:49:57.960
与此不同的其他用例

00:49:54.480 --> 00:49:59.759
牙科的好变化数据捕获是

00:49:57.960 --> 00:50:02.249
您可以看到的另一个用例

00:49:59.759 --> 00:50:04.289
对给定实体的更改，然后

00:50:02.249 --> 00:50:05.730
那我们以后再付钱给我

00:50:04.289 --> 00:50:09.299
意思是说你有很多原因

00:50:05.730 --> 00:50:11.160
可能想要这个，你应该拥有它

00:50:09.299 --> 00:50:13.170
有一个是我们必须有任何

00:50:11.160 --> 00:50:14.940
社区和关系数据库是

00:50:13.170 --> 00:50:17.339
擅长这种事情，所以我们

00:50:14.940 --> 00:50:25.079
将使用一个名为休眠的项目

00:50:17.339 --> 00:50:26.640
熊，那是我拼写的吗

00:50:25.079 --> 00:50:29.099
不确定从法国来的

00:50:26.640 --> 00:50:32.099
那里需要喜欢它

00:50:29.099 --> 00:50:36.720
介词，你知道我想我是

00:50:32.099 --> 00:50:40.259
不知道这里是什么，但我要用

00:50:36.720 --> 00:50:41.549
好吧，我什至在想那个

00:50:40.259 --> 00:50:43.799
其实我什至不知道我们不保释

00:50:41.549 --> 00:50:47.460
我，所以不管我们有这个介词

00:50:43.799 --> 00:50:49.559
我们有这个词，我是熊，我是熊， 

00:50:47.460 --> 00:50:51.569
当我继续并将其带入

00:50:49.559 --> 00:50:54.089
这里的项目，我们有一个模块

00:50:51.569 --> 00:50:56.329
那个Spring ，一个有效的模块

00:50:54.089 --> 00:50:59.039
与我们的熊好

00:50:56.329 --> 00:50:59.970
我们正在寻找我的数据，但我没有

00:50:59.039 --> 00:51:01.109
想很多人都知道

00:50:59.970 --> 00:51:03.569
可耻的部分，因为

00:51:01.109 --> 00:51:06.239
真的非常有用，所以我们需要

00:51:03.569 --> 00:51:08.489
首先，我们需要告诉我们

00:51:06.239 --> 00:51:13.680
需要告诉 Spring 和 Spring ，JP 

00:51:08.489 --> 00:51:15.690
特别是在哪里找到你知道的

00:51:13.680 --> 00:51:17.520
在哪里配置我们的仓库

00:51:15.690 --> 00:51:19.170
与我们的熊

00:51:17.520 --> 00:51:21.119
在混合中，所以我们有陷阱

00:51:19.170 --> 00:51:22.950
覆盖ojp a的默认值

00:51:21.119 --> 00:51:23.730
跳板中的存储库支持

00:51:22.950 --> 00:51:25.770
自动配置

00:51:23.730 --> 00:51:29.070
我们通过使用扶手来覆盖它

00:51:25.770 --> 00:51:32.720
修订版本库工厂梁和

00:51:29.070 --> 00:51:39.540
然后我们必须使我们的实体

00:51:32.720 --> 00:51:44.910
可审核的，所以让我们深入了解每个

00:51:39.540 --> 00:51:48.480
那里的实体，我们的审计在哪里

00:51:44.910 --> 00:51:50.670
立即订购并立即找到它

00:51:48.480 --> 00:51:53.609
这是来自休眠项目

00:51:50.670 --> 00:51:54.960
在熊上冬眠，这真的

00:51:53.609 --> 00:51:55.770
有用的项目，它将与

00:51:54.960 --> 00:51:57.330
冬眠，我们已经有

00:51:55.770 --> 00:52:02.670
休眠运行，因此我们不必做

00:51:57.330 --> 00:52:03.450
使它超出我们的工作范围还有很多

00:52:02.670 --> 00:52:06.720
有那里

00:52:03.450 --> 00:52:08.400
因此，让我们继续运行，然后运行

00:52:06.720 --> 00:52:10.560
看一下结果架构

00:52:08.400 --> 00:52:13.710
我们实际上应该审问

00:52:10.560 --> 00:52:14.580
储存库可以在一秒钟内完成

00:52:13.710 --> 00:52:16.800
让我们看看它是否像

00:52:14.580 --> 00:52:20.369
一切都会好起来的，所以你

00:52:16.800 --> 00:52:23.190
可以看到已经完成了

00:52:20.369 --> 00:52:24.960
一切都像以前一样，但是

00:52:23.190 --> 00:52:29.359
这些表显然称为客户

00:52:24.960 --> 00:52:32.820
澳元客户，但客户的澳元和

00:52:29.359 --> 00:52:35.700
有序广告，它的架构很棒

00:52:32.820 --> 00:52:38.640
所有-好的，所以从中选择所有

00:52:35.700 --> 00:52:41.880
这个buh-buh-bah创建以下表格的订单

00:52:38.640 --> 00:52:46.310
 AUD还有另一张桌子，如已读信息

00:52:41.880 --> 00:52:49.830
我们可以看到所有显示表

00:52:46.310 --> 00:52:54.270
我们在那里，所以我希望您的支持

00:52:49.830 --> 00:52:57.050
从订单关闭有我们的11行

00:52:54.270 --> 00:52:57.050
提供的季度

00:52:57.420 --> 00:53:01.090
所以我们会发现这很有趣

00:52:59.650 --> 00:53:02.470
在那里形成，但我们不必

00:53:01.090 --> 00:53:04.030
不用担心，我们不必

00:53:02.470 --> 00:53:05.260
必须向下钻取并找到反向

00:53:04.030 --> 00:53:07.330
尽管您可以设计该架构

00:53:05.260 --> 00:53:09.490
肯定在某个时候展示它

00:53:07.330 --> 00:53:11.500
要做的只是使用存储库

00:53:09.490 --> 00:53:13.180
为该数据进行交互，因此

00:53:11.500 --> 00:53:17.200
相当简单，我们只是

00:53:13.180 --> 00:53:19.630
转到我们的存储库并扩展

00:53:17.200 --> 00:53:21.760
另一个接口，修订版本库

00:53:19.630 --> 00:53:23.740
这将管理实体

00:53:21.760 --> 00:53:26.290
客户主键的类型，除了

00:53:23.740 --> 00:53:28.810
时间长短和修订类型

00:53:26.290 --> 00:53:31.600
用一个整数映射

00:53:28.810 --> 00:53:34.510
基本扩展到位，我们现在可以添加

00:53:31.600 --> 00:53:35.700
再打印一份，所以我们得到了

00:53:34.510 --> 00:53:39.280
在这里进行一些更改

00:53:35.700 --> 00:53:41.590
让我们看看我们有戴夫，但我们只有

00:53:39.280 --> 00:53:43.450
我们只改变了戴夫两次

00:53:41.590 --> 00:53:47.380
我们创建的所有其他内容

00:53:43.450 --> 00:53:49.270
我们创建的记录实际上

00:53:47.380 --> 00:53:52.360
到目前为止，我们已经两次修改了所有内容

00:53:49.270 --> 00:53:55.360
继续，现在修改Dave 

00:53:52.360 --> 00:54:01.150
特别是要说明这一点

00:53:55.360 --> 00:54:02.980
我会发现戴夫渴望访问戴夫

00:54:01.150 --> 00:54:05.650
是集合中的每条记录吗？ 

00:54:02.980 --> 00:54:09.640
回来，我们要换戴夫

00:54:05.650 --> 00:54:10.600
大卫，我不确定那是不是

00:54:09.640 --> 00:54:11.830
知道他是否喜欢被叫

00:54:10.600 --> 00:54:15.340
大卫，但它只会这样做，因为

00:54:11.830 --> 00:54:17.410
这是when的简称

00:54:15.340 --> 00:54:21.910
其他，我们要说客户和

00:54:17.410 --> 00:54:29.950
流行音乐是未保存的戴夫，现在又是另一个

00:54:21.910 --> 00:54:34.120
我要回去的交易

00:54:29.950 --> 00:54:35.860
记录好吧，这当然是我

00:54:34.120 --> 00:54:37.530
谈论医生给的好处

00:54:35.860 --> 00:54:41.040
父亲

00:54:37.530 --> 00:54:43.380
是朋友和英雄，所以我们开始

00:54:41.040 --> 00:54:51.990
我们要有大卫，我要

00:54:43.380 --> 00:54:54.600
得到ID，所以我忘了地图

00:54:51.990 --> 00:54:56.100
超类也应该在那个

00:54:54.600 --> 00:54:58.040
从龙目岛注解以获取

00:54:56.100 --> 00:55:01.530
吸气剂和二传手这使得

00:54:58.040 --> 00:55:02.970
更容易非常好，现在我要

00:55:01.530 --> 00:55:08.430
访问我要说的存储库

00:55:02.970 --> 00:55:13.620
找到ID的修订，仅此而已

00:55:08.430 --> 00:55:16.710
然后找到我为客户准备的

00:55:13.620 --> 00:55:18.510
实体的ID等于yes，因此我们

00:55:16.710 --> 00:55:21.750
实际上可以简化一点

00:55:18.510 --> 00:55:27.600
在这里，然后把每个修订

00:55:21.750 --> 00:55:45.060
回来，我们得到了什么，所以记录

00:55:27.600 --> 00:55:49.520
信息视觉也许我得到了元数据

00:55:45.060 --> 00:55:49.520
在那里有远见

00:55:49.990 --> 00:55:55.570
好吧，所以我要做的就是

00:55:53.109 --> 00:55:57.880
推出版本的修订元数据

00:55:55.570 --> 00:56:02.109
给定的实体，我们将看到它已记录

00:55:57.880 --> 00:56:07.570
在那里我正在寻找戴夫只是一个

00:56:02.109 --> 00:56:09.810
数据库规模好吧，让我们看看

00:56:07.570 --> 00:56:09.810
我们得到

00:56:12.120 --> 00:56:17.820
很酷，所以我们有三个

00:56:14.430 --> 00:56:19.680
在这里可以记录三个规定

00:56:17.820 --> 00:56:21.510
看到我们有ID 5，这是

00:56:19.680 --> 00:56:23.340
不同的日期吧8:26这些

00:56:21.510 --> 00:56:25.560
基本上都在同一时间

00:56:23.340 --> 00:56:28.260
点击它实际上是的，让我们

00:56:25.560 --> 00:56:30.500
给这个条目引入一个暂停

00:56:28.260 --> 00:56:30.500
在这里暂停

00:56:42.430 --> 00:56:48.339
两秒钟睡在那里，我们还好

00:56:46.510 --> 00:56:50.500
我们去那里，所以我们可以看到

00:56:48.339 --> 00:56:53.170
第二次改变发生在33 

00:56:50.500 --> 00:56:55.150
第三次换队后

00:56:53.170 --> 00:56:57.339
在三十五秒后，我们可以

00:56:55.150 --> 00:56:58.480
看到那里的数据，你也可以看到

00:56:57.339 --> 00:57:00.190
这些变化让您看到

00:56:58.480 --> 00:57:02.579
这是该记录的第一个实例

00:57:00.190 --> 00:57:05.710
叫戴夫，零订单

00:57:02.579 --> 00:57:08.500
这是该记录的第二个

00:57:05.710 --> 00:57:10.390
戴夫，这是所有的订单

00:57:08.500 --> 00:57:13.059
该记录的第三个实例

00:57:10.390 --> 00:57:15.520
大卫没有戴夫相同的数字顺序

00:57:13.059 --> 00:57:17.559
他可以看到关联的实体和

00:57:15.520 --> 00:57:19.089
这些变化发生的时间，所以我

00:57:17.559 --> 00:57:21.670
想想你是否需要那种东西

00:57:19.089 --> 00:57:24.069
现在我做到了，它非常非常强大

00:57:21.670 --> 00:57:26.740
只是对所有

00:57:24.069 --> 00:57:28.920
实体在我的应用程序中自然是你

00:57:26.740 --> 00:57:31.180
可能不希望每个人都这样

00:57:28.920 --> 00:57:33.609
所有的废话，你不需要

00:57:31.180 --> 00:57:35.170
您可以在审核时使用的文字

00:57:33.609 --> 00:57:37.630
您关心的实体

00:57:35.170 --> 00:57:41.859
您想接受审核，也可以

00:57:37.630 --> 00:57:43.690
然后从中排除其他实体

00:57:41.859 --> 00:57:45.280
例如，但如果您有实体

00:57:43.690 --> 00:57:46.839
例如引用另一个

00:57:45.280 --> 00:57:48.760
在这种情况下，客户参考是

00:57:46.839 --> 00:57:51.010
超过订单，那么他们俩都需要

00:57:48.760 --> 00:57:57.160
已审核，或者您需要排除它

00:57:51.010 --> 00:58:00.460
今晚，所以如果你这样做的话

00:57:57.160 --> 00:58:02.559
此处的字段将排除

00:58:00.460 --> 00:58:04.329
从审计它不会改变它

00:58:02.559 --> 00:58:06.520
不会捕获该版本的修订

00:58:04.329 --> 00:58:10.030
被推荐的下属集合

00:58:06.520 --> 00:58:13.290
它在这种情况下被捕获了，所以

00:58:10.030 --> 00:58:15.190
我们看过GPA GPA当然是

00:58:13.290 --> 00:58:20.470
值得信赖的技术

00:58:15.190 --> 00:58:23.890
我想了很久

00:58:20.470 --> 00:58:25.630
很多人JPA会成为你知道的

00:58:23.890 --> 00:58:27.549
这将是一个非常方便的选择

00:58:25.630 --> 00:58:29.230
它使您可以处理对象，如果

00:58:27.549 --> 00:58:31.420
你只是想拿一些东西

00:58:29.230 --> 00:58:34.210
在您的域模型中持续存在

00:58:31.420 --> 00:58:36.819
数据库，你不介意放弃

00:58:34.210 --> 00:58:40.500
对查询进行一些控制，然后您

00:58:36.819 --> 00:58:43.480
您应该看看APA吗

00:58:40.500 --> 00:58:48.299
有一些非常好的建议

00:58:43.480 --> 00:58:53.200
关于如何提高JP 

00:58:48.299 --> 00:58:55.700
性能，例如超级系统

00:58:53.200 --> 00:58:58.490
在这里向我大喊

00:58:55.700 --> 00:59:00.859
我朋友弗拉德（Vlad）的精彩著作

00:58:58.490 --> 00:59:03.290
有机会读这本书

00:59:00.859 --> 00:59:06.910
你可以在这里买它持久性太高

00:59:03.290 --> 00:59:10.700
我欠它的运行它是由高兴写的

00:59:06.910 --> 00:59:12.220
我怎么看呀，我什至没有我不

00:59:10.700 --> 00:59:14.450
想屠杀他的名字，但他是一个

00:59:12.220 --> 00:59:17.359
开发者拥护者，他是开发者

00:59:14.450 --> 00:59:19.760
冬眠团队的拥护者和你

00:59:17.359 --> 00:59:22.760
知道他有一些很好的例子

00:59:19.760 --> 00:59:24.650
关于如何使自己完全冬眠

00:59:22.760 --> 00:59:28.099
你知道的速度尖叫，所以我

00:59:24.650 --> 00:59:29.540
绝对建议我认为

00:59:28.099 --> 00:59:32.119
 BMS中最强大的部分

00:59:29.540 --> 00:59:33.500
是续集对，所以我不想放弃

00:59:32.119 --> 00:59:35.869
续集我不想控制我

00:59:33.500 --> 00:59:37.329
想失去控制权，所以你

00:59:35.869 --> 00:59:39.470
应该注意这些小事

00:59:37.329 --> 00:59:41.570
重新获得控制权的机会

00:59:39.470 --> 00:59:44.810
映射对象很好

00:59:41.570 --> 00:59:46.550
很好地适应了不同的结构

00:59:44.810 --> 00:59:48.050
在您的数据库中，但这并不意味着

00:59:46.550 --> 00:59:49.640
你失去控制，所以这是非常

00:59:48.050 --> 00:59:50.660
重要的是要记住什么

00:59:49.640 --> 00:59:52.160
发生在幕后的原因

00:59:50.660 --> 00:59:54.380
我做的第一件事就是

00:59:52.160 --> 00:59:56.150
说明所有不同的续集

00:59:54.380 --> 00:59:58.160
 RA此处执行的语句

00:59:56.150 --> 01:00:00.440
现在，当我们运行此代码时，请记住

00:59:58.160 --> 01:00:01.599
实际上并不是表演

01:00:00.440 --> 01:00:03.859
运行很多续集声明

01:00:01.599 --> 01:00:05.359
特别是如果您要分批处理

01:00:03.859 --> 01:00:07.010
在交易内部

01:00:05.359 --> 01:00:08.690
性能等同于这些条件中的每一项

01:00:07.010 --> 01:00:10.819
续集查询是单独的

01:00:08.690 --> 01:00:12.500
交易将非常非常缓慢

01:00:10.819 --> 01:00:13.760
但要连续三到四个续集

01:00:12.500 --> 01:00:18.650
单笔交易中的陈述

01:00:13.760 --> 01:00:21.109
你知道我们有没有痛苦

01:00:18.650 --> 01:00:22.849
看了JPA I的绝对基础

01:00:21.109 --> 01:00:25.579
没什么特别的

01:00:22.849 --> 01:00:27.440
我们实施的具体特点

01:00:25.579 --> 01:00:29.150
我们没有花很多时间在看

01:00:27.440 --> 01:00:31.790
映射有一个你知道有

01:00:29.150 --> 01:00:33.980
我确定如何绘制数十亿个页面

01:00:31.790 --> 01:00:36.530
实体到其他类型的实体我

01:00:33.980 --> 01:00:39.280
做了一个更有趣的例子

01:00:36.530 --> 01:00:41.150
这里有一个地图超类和一个

01:00:39.280 --> 01:00:42.770
一对多关系，但是有一个

01:00:41.150 --> 01:00:45.140
您可以做的其他事情的总数

01:00:42.770 --> 01:00:47.750
显然在这里我希望你会追求

01:00:45.140 --> 01:00:48.920
在您闲暇时，我们看着

01:00:47.750 --> 01:00:50.300
一些可能是

01:00:48.920 --> 01:00:51.770
被认为像这样的反模式开放

01:00:50.300 --> 01:00:53.270
实体经理并查看事物

01:00:51.770 --> 01:00:55.670
人们真的不喜欢

01:00:53.270 --> 01:00:59.140
实际上我认为它会启动

01:00:55.670 --> 01:00:59.140
出来吧，让我们看看

01:01:02.490 --> 01:01:12.630
学得好我认为这不是外国的

01:01:08.070 --> 01:01:14.700
是的，它实际上确实在看那个

01:01:12.630 --> 01:01:16.320
所以 Spring JPA打开并启用了视图

01:01:14.700 --> 01:01:18.600
因此默认情况下数据库查询

01:01:16.320 --> 01:01:20.369
也许四个可能在观看期间执行

01:01:18.600 --> 01:01:22.050
渲染显式配置

01:01:20.369 --> 01:01:23.970
今天早上有很多禁用功能，所以再次

01:01:22.050 --> 01:01:25.110
你不想要那个嗯，你知道那是

01:01:23.970 --> 01:01:26.280
很高兴知道它，所以必须拥有它

01:01:25.110 --> 01:01:27.510
如果您需要它，然后如果您只是

01:01:26.280 --> 01:01:29.070
尝试获取足够的应用程序

01:01:27.510 --> 01:01:31.410
并尽可能快地运行

01:01:29.070 --> 01:01:34.170
在这里做了那就是那个工具

01:01:31.410 --> 01:01:36.000
给你什么你可能想要得到的建议

01:01:34.170 --> 01:01:37.710
摆脱它，你知道你的里程可能

01:01:36.000 --> 01:01:39.810
开始移动这些导线时会有所不同

01:01:37.710 --> 01:01:41.100
其余的api等，因此您必须

01:01:39.810 --> 01:01:44.100
不得不在乎你必须在乎

01:01:41.100 --> 01:01:46.200
关于那件事

01:01:44.100 --> 01:01:47.220
朋友，我感谢你的收看，我

01:01:46.200 --> 01:01:50.150
希望你从中得到一些东西

01:01:47.220 --> 01:01:50.150
下次见

01:01:56.559 --> 01:01:58.619
您

