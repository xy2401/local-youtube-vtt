WEBVTT
Kind: captions
Language: zh-Hans

00:00:14.030 --> 00:00:19.130
嗨，春季球迷，所以今天就在今天

00:00:17.420 --> 00:00:22.040
分期付款，我们现在来看一下JT 

00:00:19.130 --> 00:00:24.050
 JT是一种Java事务API，它是一种

00:00:22.040 --> 00:00:26.990
分布式交易的管理

00:00:24.050 --> 00:00:28.220
整个交易资源

00:00:26.990 --> 00:00:29.869
客户端中间件

00:00:28.220 --> 00:00:31.939
客户端绑定称为

00:00:29.869 --> 00:00:34.040
 Java事务API或更确切地说

00:00:31.939 --> 00:00:36.250
客户端绑定称为

00:00:34.040 --> 00:00:39.620
 X开放协议现在X开放协议

00:00:36.250 --> 00:00:42.079
是一种允许不同的协议

00:00:39.620 --> 00:00:44.930
交易资源以争取

00:00:42.079 --> 00:00:48.019
由客户发起的交易

00:00:44.930 --> 00:00:50.059
客户，然后为此做准备

00:00:48.019 --> 00:00:52.159
交易，然后您知道

00:00:50.059 --> 00:00:53.179
信号然后提交或

00:00:52.159 --> 00:00:56.269
回滚

00:00:53.179 --> 00:00:58.249
这自然需要

00:00:56.269 --> 00:01:00.289
需要保持在外部的状态

00:00:58.249 --> 00:01:01.819
这些交易资源，所以您已经

00:01:00.289 --> 00:01:02.859
得到了同步到

00:01:01.819 --> 00:01:04.489
不一样的

00:01:02.859 --> 00:01:07.850
独立移动

00:01:04.489 --> 00:01:09.320
步调一致地推进实体和

00:01:07.850 --> 00:01:10.550
你有第三种资源

00:01:09.320 --> 00:01:12.440
必须添加到交易中

00:01:10.550 --> 00:01:14.750
结果分配动作可能非常

00:01:12.440 --> 00:01:16.700
慢，但是那有很多

00:01:14.750 --> 00:01:18.290
内置的应用程序

00:01:16.700 --> 00:01:19.939
去年，他们倾向于

00:01:18.290 --> 00:01:21.860
这些优势的分布

00:01:19.939 --> 00:01:23.990
交易，他们想知道

00:01:21.860 --> 00:01:25.790
关于它是否足够容易使用

00:01:23.990 --> 00:01:27.860
在我们内部使用这个代替

00:01:25.790 --> 00:01:29.390
春天的申请，所以肯定是我

00:01:27.860 --> 00:01:31.880
尽管有一个

00:01:29.390 --> 00:01:33.140
解决问题的方法很多

00:01:31.880 --> 00:01:34.280
获得不同的资源

00:01:33.140 --> 00:01:35.780
分别独立

00:01:34.280 --> 00:01:37.789
部署资源以达成共识

00:01:35.780 --> 00:01:40.340
分配更优雅的状态

00:01:37.789 --> 00:01:42.289
比JTA好，但是如果您碰巧有一个

00:01:40.340 --> 00:01:44.030
使用JTA的应用程序可能不是

00:01:42.289 --> 00:01:45.500
你想听到的答案，所以我是

00:01:44.030 --> 00:01:47.420
今天要告诉你怎么做

00:01:45.500 --> 00:01:49.219
充分利用JTA 

00:01:47.420 --> 00:01:51.049
支撑在弹簧内部

00:01:49.219 --> 00:01:52.250
特别是在 spring boot 中

00:01:51.049 --> 00:01:54.259
要看两个例子，两个很棒

00:01:52.250 --> 00:01:56.840
快速示例，第一个示例是

00:01:54.259 --> 00:01:59.149
春天会工作的应用程序

00:01:56.840 --> 00:02:02.960
有数据源和消息队列

00:01:59.149 --> 00:02:04.460
所以我要说XA D和Q，我们

00:02:02.960 --> 00:02:06.740
要用弹簧支撑来建造

00:02:04.460 --> 00:02:08.899
我们在内存中使用H2的Web应用程序

00:02:06.740 --> 00:02:10.910
我们将使用的嵌入式续集数据库

00:02:08.899 --> 00:02:14.830
 ActiveMQ是您知道的消息

00:02:10.910 --> 00:02:17.960
代理，我们使用JDBC支持，然后

00:02:14.830 --> 00:02:19.430
你知道那将是

00:02:17.960 --> 00:02:21.620
应用程序，但我们需要

00:02:19.430 --> 00:02:24.050
这是一个ajt应用程序，我们需要JTA 

00:02:21.620 --> 00:02:25.510
现在这是因为我想很多人

00:02:24.050 --> 00:02:29.739
困惑了

00:02:25.510 --> 00:02:32.890
是描述API的规范

00:02:29.739 --> 00:02:34.329
 API需要实现时

00:02:32.890 --> 00:02:36.069
人们考虑实施

00:02:34.329 --> 00:02:38.140
他们思考他们通常认为

00:02:36.069 --> 00:02:40.780
关于消费所谓的用户

00:02:38.140 --> 00:02:42.730
 JTA中的事务对象等

00:02:40.780 --> 00:02:46.239
规范中有两个关键对象

00:02:42.730 --> 00:02:48.280
用户交易本应是一种

00:02:46.239 --> 00:02:51.370
的客户端表示形式

00:02:48.280 --> 00:02:53.290
提供的交易管理器

00:02:51.370 --> 00:02:55.180
客户端的JT实现

00:02:53.290 --> 00:02:56.859
代表有你你知道你的

00:02:55.180 --> 00:02:58.810
日常管理方法

00:02:56.859 --> 00:03:00.609
工作联盟的工作机构

00:02:58.810 --> 00:03:02.379
分布式交易的起止

00:03:00.609 --> 00:03:04.959
提交回滚这类东西

00:03:02.379 --> 00:03:06.250
但这还不是全部

00:03:04.959 --> 00:03:08.290
交易经理有能力

00:03:06.250 --> 00:03:10.359
实际上，大多数交易经理也

00:03:08.290 --> 00:03:11.950
可以走得更远，他们可以做到

00:03:10.359 --> 00:03:13.959
事务初始化之类的东西

00:03:11.950 --> 00:03:16.000
并恢复和暂停，这样

00:03:13.959 --> 00:03:17.739
您可以做到，您不仅可以做更多的事情

00:03:16.000 --> 00:03:20.139
在该用户交易中暴露

00:03:17.739 --> 00:03:24.280
接口那些额外的功能是

00:03:20.139 --> 00:03:26.950
通常在JTA规范交易中找到

00:03:24.280 --> 00:03:31.569
方式管理器界面现在这个

00:03:26.950 --> 00:03:35.379
是Java EE中的单独接口

00:03:31.569 --> 00:03:38.919
应用程序服务器必须提供

00:03:35.379 --> 00:03:41.680
用户交易的实现

00:03:38.919 --> 00:03:43.989
在著名的J＆A地点下

00:03:41.680 --> 00:03:47.349
不需要提供井

00:03:43.989 --> 00:03:50.440
已知的事务管理器实现

00:03:47.349 --> 00:03:52.359
但实际上大多数应用程序服务器

00:03:50.440 --> 00:03:54.489
确实提供了一个实现

00:03:52.359 --> 00:03:56.590
不在同一种便携式JD下

00:03:54.489 --> 00:03:59.410
和位置，但春天知道所有

00:03:56.590 --> 00:04:01.120
常见的位置，这将需要

00:03:59.410 --> 00:04:03.459
两者的优势你们都知道

00:04:01.120 --> 00:04:05.980
具有最大的力量，它将使用

00:04:03.459 --> 00:04:08.680
如果可以的话，我们将使用什么

00:04:05.980 --> 00:04:11.500
我们要做的是使用

00:04:08.680 --> 00:04:13.720
我们自己的独立JTA实现

00:04:11.500 --> 00:04:15.630
再次春天不在乎豆子

00:04:13.720 --> 00:04:18.130
它需要类型的对象

00:04:15.630 --> 00:04:20.799
事务管理器和用户类型

00:04:18.130 --> 00:04:22.630
交易来自Jane di上下文

00:04:20.799 --> 00:04:24.729
在应用程序服务器中，或者如果它们来了

00:04:22.630 --> 00:04:26.080
来自一种独立的JTA 

00:04:24.729 --> 00:04:27.909
 spring boot 的实现

00:04:26.080 --> 00:04:28.570
自动为我们配置

00:04:27.909 --> 00:04:30.729
我们要做的是

00:04:28.570 --> 00:04:32.409
在我们的Springwood中配置JTA 

00:04:30.729 --> 00:04:34.870
应用程序，或者说我们拥有那个春天

00:04:32.409 --> 00:04:37.870
引导为我们立即配置JTA 

00:04:34.870 --> 00:04:38.860
如果我们跑春天，春天会

00:04:37.870 --> 00:04:40.990
内部的应用

00:04:38.860 --> 00:04:44.259
 Java应用程序上的应用程序服务器

00:04:40.990 --> 00:04:46.090
确保少数用例

00:04:44.259 --> 00:04:47.919
但以防万一这是您的用例

00:04:46.090 --> 00:04:48.969
这将自动为您工作

00:04:47.919 --> 00:04:51.819
甚至不需要独立

00:04:48.969 --> 00:04:53.800
实现它将检测到jndi 

00:04:51.819 --> 00:04:58.990
应用服务器上的类型

00:04:53.800 --> 00:05:01.050
它将配置包装并调整那些

00:04:58.990 --> 00:05:05.229
交易资源，如果他们

00:05:01.050 --> 00:05:07.210
实施他们需要的XA XA 

00:05:05.229 --> 00:05:10.419
正确的接口，所以有一个X 

00:05:07.210 --> 00:05:13.180
 JTA内部和内部的资源接口

00:05:10.419 --> 00:05:15.879
 JMS世界中用于消息传递的Java api 

00:05:13.180 --> 00:05:17.409
有一个X连接工厂

00:05:15.879 --> 00:05:19.990
是一个JMS连接因子， 

00:05:17.409 --> 00:05:22.330
实施XA资源合同，并

00:05:19.990 --> 00:05:24.550
然后在JBC规则中有一个X a数据

00:05:22.330 --> 00:05:27.939
源是一个数据源

00:05:24.550 --> 00:05:31.509
只要执行X合约

00:05:27.939 --> 00:05:32.620
当您使用Jane di设置您时

00:05:31.509 --> 00:05:35.289
了解连接因素和消息

00:05:32.620 --> 00:05:37.719
排队等，还有斯普林伍德

00:05:35.289 --> 00:05:39.870
自动配置将使用

00:05:37.719 --> 00:05:42.940
绑定的JT交易管理器

00:05:39.870 --> 00:05:44.500
在您的jndi目录中

00:05:42.940 --> 00:05:45.849
虽然在我们的例子中是应用服务器

00:05:44.500 --> 00:05:49.360
我们没有使用Java应用程序

00:05:45.849 --> 00:05:51.879
服务器，我们只是在猜测本地排序

00:05:49.360 --> 00:05:52.930
嵌入式喷头的应用

00:05:51.879 --> 00:05:54.849
我们将使用一个

00:05:52.930 --> 00:05:56.319
 Spring Boot自动配置JTA 

00:05:54.849 --> 00:05:58.029
对我们的实现和spring boot 

00:05:56.319 --> 00:06:00.789
开箱即用的支持三个

00:05:58.029 --> 00:06:03.400
流行的非常广泛使用的选择

00:06:00.789 --> 00:06:05.379
原子主机和启动Onix两者

00:06:03.400 --> 00:06:07.509
是Apache 2开放源代码的许可证等

00:06:05.379 --> 00:06:09.610
他们俩其实你都知道

00:06:07.509 --> 00:06:12.219
有趣的是，它们都起源于

00:06:09.610 --> 00:06:15.039
比利时有点琐事

00:06:12.219 --> 00:06:16.659
他们的原子O是我认为我们要

00:06:15.039 --> 00:06:17.800
使用它不是因为更好

00:06:16.659 --> 00:06:19.719
更糟或什么，但因为它开始

00:06:17.800 --> 00:06:22.659
你应该知道的一件事

00:06:19.719 --> 00:06:25.779
原子主机是它也有一个

00:06:22.659 --> 00:06:27.939
最高级的权利，所以你可以

00:06:25.779 --> 00:06:28.659
使用开源JTA的东西

00:06:27.939 --> 00:06:30.009
效果很好

00:06:28.659 --> 00:06:33.520
但是如果你想超越

00:06:30.009 --> 00:06:36.219
 JTA并处理一些更有趣的事情

00:06:33.520 --> 00:06:38.759
 JTA世界中的极端案例

00:06:36.219 --> 00:06:43.439
在多摩海岸牢房后面

00:06:38.759 --> 00:06:44.919
支持的企业级附加功能还可以

00:06:43.439 --> 00:06:48.219
好吧

00:06:44.919 --> 00:06:50.529
所以我们要点击generate，因为

00:06:48.219 --> 00:06:52.509
这是我们两个人的 spring boot 

00:06:50.529 --> 00:06:52.790
数据源和我们的消息队列将

00:06:52.509 --> 00:06:54.050
是

00:06:52.790 --> 00:06:55.760
实际上自动为我们配置

00:06:54.050 --> 00:06:57.320
将被嵌入，没有理由我们

00:06:55.760 --> 00:06:59.690
无法指定属性就是这一点

00:06:57.320 --> 00:07:01.400
单独知道数据

00:06:59.690 --> 00:07:03.620
源和消息队列正在运行

00:07:01.400 --> 00:07:05.930
过时了，但在我们这里我们不会

00:07:03.620 --> 00:07:07.430
真的需要我们只是试图

00:07:05.930 --> 00:07:08.390
得到一个例子，所以他们会

00:07:07.430 --> 00:07:10.760
自动为我们创建的

00:07:08.390 --> 00:07:13.400
在春季为我们配置好

00:07:10.760 --> 00:07:20.030
应用程序，我们要去这里，我们

00:07:13.400 --> 00:07:21.410
将创建一个具有

00:07:20.030 --> 00:07:25.850
 rest controller ，这样我们就可以保存公共信息

00:07:21.410 --> 00:07:30.620
静态类X的 rest controller 可以

00:07:25.850 --> 00:07:31.880
也许X是API rest控制器，我们

00:07:30.620 --> 00:07:35.000
会让它成为风险控制者，例如

00:07:31.880 --> 00:07:37.310
所以，在休息控制室，并有

00:07:35.000 --> 00:07:45.470
以其有效负载为单位的写方法

00:07:37.310 --> 00:07:46.940
字符串映射，我们称其为

00:07:45.470 --> 00:07:49.160
有效载荷，这将只是一个包装

00:07:46.940 --> 00:07:51.740
一个将为

00:07:49.160 --> 00:07:53.390
客户，我们想在这里

00:07:51.740 --> 00:07:56.990
发布地图，以便有人去写

00:07:53.390 --> 00:07:58.520
到这里的消息队列，我们

00:07:56.990 --> 00:08:00.290
希望能够在以下情况下引发异常

00:07:58.520 --> 00:08:04.330
一些如果应该出问题的话

00:08:00.290 --> 00:08:04.330
在这里，我们要说请求

00:08:05.350 --> 00:08:09.920
可选的，所以它将成为

00:08:07.550 --> 00:08:14.480
那里或者不会，如果不是

00:08:09.920 --> 00:08:16.640
那我们就可以给你

00:08:14.480 --> 00:08:20.270
知道优雅地处理这种情况

00:08:16.640 --> 00:08:22.520
如果正常检查的话很多

00:08:20.270 --> 00:08:26.780
我们要做的是

00:08:22.520 --> 00:08:28.430
使用自动配置JMS模板好吗

00:08:26.780 --> 00:08:30.850
这是客户端的接口

00:08:28.430 --> 00:08:34.570
与JMS合作，我将使用

00:08:30.850 --> 00:08:35.720
自动配置的JDBC模板

00:08:34.570 --> 00:08:37.490
好的

00:08:35.720 --> 00:08:39.229
在这里提供构造函数中的那些

00:08:37.490 --> 00:08:40.490
 Spring Boot自动配置

00:08:39.229 --> 00:08:41.930
他们我们只是注入他们使用

00:08:40.490 --> 00:08:42.890
他们，我们将要发送消息

00:08:41.930 --> 00:08:48.070
我们要做的就是发送一个

00:08:42.890 --> 00:08:50.600
消息到这里的JMS目标

00:08:48.070 --> 00:08:51.860
我只给它一个变量名

00:08:50.600 --> 00:08:55.190
为了容易记住，所以我们

00:08:51.860 --> 00:08:57.590
将其称为消息，我们将写

00:08:55.190 --> 00:08:59.420
他们将消息发送到数据库，我们将

00:08:57.590 --> 00:09:02.060
将其写入消息队列，如果我们

00:08:59.420 --> 00:09:05.390
需要这样做，但让我们看看我们要说的是

00:09:02.060 --> 00:09:12.730
这个点jvc模板实际上是点X 

00:09:05.390 --> 00:09:12.730
可爱地插入message-id 

00:09:15.130 --> 00:09:22.520
我们将其称为ID， 

00:09:17.390 --> 00:09:23.180
要称呼它，我想那会是

00:09:22.520 --> 00:09:26.230
精细

00:09:23.180 --> 00:09:33.260
值问号问号和

00:09:26.230 --> 00:09:34.910
我们将在此处传递一个ID和ID 

00:09:33.260 --> 00:09:39.020
好在以后的记录中，所以我们说

00:09:34.910 --> 00:09:43.640
 ID等于uu ID点随机字符串

00:09:39.020 --> 00:09:45.710
字符串还可以，并顺利传递消息

00:09:43.640 --> 00:09:49.010
在这里，消息将被导出

00:09:45.710 --> 00:09:53.140
从JSON主体的有效负载中

00:09:49.010 --> 00:10:00.610
我们会说请求或有效负载点得到

00:09:53.140 --> 00:10:07.190
名称字符串消息等于您好名称

00:10:00.610 --> 00:10:09.830
好，所以有消息说我们

00:10:07.190 --> 00:10:12.890
要发送更新将在那里工作

00:10:09.830 --> 00:10:14.960
我们想通过发送消息

00:10:12.890 --> 00:10:19.750
还有JMS模板，所以我们这样说

00:10:14.960 --> 00:10:22.250
点JMS模板JMS模板点

00:10:19.750 --> 00:10:23.600
转换并发送，我们要做的是

00:10:22.250 --> 00:10:28.220
要发送消息到目的地

00:10:23.600 --> 00:10:31.400
称为目的地，消息将

00:10:28.220 --> 00:10:33.020
我们就在这里吗

00:10:31.400 --> 00:10:34.700
所以我们要向网络发送消息

00:10:33.020 --> 00:10:35.990
我们要写给戴维斯

00:10:34.700 --> 00:10:38.150
我要发送事件或发布

00:10:35.990 --> 00:10:40.010
消息传递给经纪人或其他

00:10:38.150 --> 00:10:41.570
在同一节点中运行的组件或

00:10:40.010 --> 00:10:42.980
然后在另一个节点上运行

00:10:41.570 --> 00:10:45.020
收到它，所以现在就开始做吧

00:10:42.980 --> 00:10:49.960
好吧，我们在这里创建另一个组件

00:10:45.020 --> 00:10:56.510
 Jamis侦听器公共静态类

00:10:49.960 --> 00:10:59.570
消息通知侦听器和此处

00:10:56.510 --> 00:11:02.420
好吧，您知道这是一项服务， 

00:10:59.570 --> 00:11:07.430
我们只是宣布lis回应

00:11:02.420 --> 00:11:11.720
新消息权，有效负载将

00:11:07.430 --> 00:11:13.130
是消息本身，或者我们可以

00:11:11.720 --> 00:11:14.900
只要在正确的星期写身份证

00:11:13.130 --> 00:11:16.040
只是发送记录的想法

00:11:14.900 --> 00:11:16.970
被写在那里的索赔检查垫

00:11:16.040 --> 00:11:18.770
只要他们有我们的想法

00:11:16.970 --> 00:11:21.230
以后再查一下

00:11:18.770 --> 00:11:22.550
我会-我们将使用一个不错的功能

00:11:21.230 --> 00:11:26.120
在这里和最新版本之一

00:11:22.550 --> 00:11:28.310
春天的一个JMS侦听器

00:11:26.120 --> 00:11:29.779
注解，我认为这是春天

00:11:28.310 --> 00:11:32.060
框架也可以，但是你知道

00:11:29.779 --> 00:11:34.040
内存可能配对失败，并且

00:11:32.060 --> 00:11:41.600
我要做的就是打印出来

00:11:34.040 --> 00:11:43.550
新消息，所以消息ID可以了

00:11:41.600 --> 00:11:45.350
这个Jamis侦听器注释是一个

00:11:43.550 --> 00:11:46.670
方便的船在文本切割

00:11:45.350 --> 00:11:48.290
创造这种内在的信息

00:11:46.670 --> 00:11:50.480
容器，如果您曾经使用过

00:11:48.290 --> 00:11:52.250
消息监听容器或来自消息

00:11:50.480 --> 00:11:53.810
带动的豆，这远不止于此

00:11:52.250 --> 00:11:56.480
方便有类似的支持

00:11:53.810 --> 00:11:58.010
在MQP的春季AMQP内部

00:11:56.480 --> 00:12:00.230
听众还有其他支持， 

00:11:58.010 --> 00:12:01.880
其他春季项目，但足以满足

00:12:00.230 --> 00:12:04.459
说我们在那里有我们需要的一切

00:12:01.880 --> 00:12:06.080
好吧，我想最后一件事

00:12:04.459 --> 00:12:13.040
我们去过会很方便

00:12:06.080 --> 00:12:15.649
看是一种枚举任何

00:12:13.040 --> 00:12:17.149
数据库中的消息不会那样

00:12:15.649 --> 00:12:18.640
可能有用，让我们

00:12:17.149 --> 00:12:23.810
让我们来看看，所以我们要说

00:12:18.640 --> 00:12:26.510
公开绘制地图，我们将

00:12:23.810 --> 00:12:31.010
创建一个地图，该地图的集合

00:12:26.510 --> 00:12:34.700
留言或直接给我们打电话

00:12:31.010 --> 00:12:43.029
好的，我们将保存此想法

00:12:34.700 --> 00:12:48.260
 JBC模板点查询全选

00:12:43.029 --> 00:12:50.270
消息新行映射器好，所以我们

00:12:48.260 --> 00:12:51.050
刚获得经典，您知道JBC 

00:12:50.270 --> 00:12:53.270
模板

00:12:51.050 --> 00:12:55.370
查询，我们将为每个

00:12:53.270 --> 00:13:02.029
返回的结果让我们创建一个

00:12:55.370 --> 00:13:03.529
在这里映射一个哈希映射，我们将把

00:13:02.029 --> 00:13:06.649
那里的一些字段我们会说ID 

00:13:03.529 --> 00:13:11.450
等于结果集鸭子得到

00:13:06.649 --> 00:13:17.470
字符串ID，我会说这个旧集

00:13:11.450 --> 00:13:20.770
死得到字符串消息好

00:13:17.470 --> 00:13:22.600
现在当然有这个

00:13:20.770 --> 00:13:23.950
看着我，看到一个

00:13:22.600 --> 00:13:25.540
清除死者的机会很多

00:13:23.950 --> 00:13:27.700
代码，让我们摆脱它，我们不

00:13:25.540 --> 00:13:31.810
需要它可以是一个很好的lambda 

00:13:27.700 --> 00:13:33.870
很好，很好，很好，在那里

00:13:31.810 --> 00:13:35.980
走，那是我们的读取端点，所以

00:13:33.870 --> 00:13:38.140
我们需要关心的最后一件事

00:13:35.980 --> 00:13:39.550
大约在回滚交易，如果

00:13:38.140 --> 00:13:41.920
我们知道你要证明

00:13:39.550 --> 00:13:45.430
做到了我们所期望的，所以让我们

00:13:41.920 --> 00:13:46.750
使其成为交易端点

00:13:45.430 --> 00:13:48.640
我要说的是交易式

00:13:46.750 --> 00:13:49.810
在此弹出事务注释

00:13:48.640 --> 00:13:51.580
您可能已经看过javac存根

00:13:49.810 --> 00:13:54.640
交易的交易是

00:13:51.580 --> 00:13:56.560
 Java EE 7中的新功能发布于

00:13:54.640 --> 00:13:57.940
 2013年

00:13:56.560 --> 00:13:59.970
而春季交易

00:13:57.940 --> 00:14:01.930
注释涵盖了的超集

00:13:59.970 --> 00:14:04.930
支持那里，当然

00:14:01.930 --> 00:14:06.070
大约你知道12 12年10 

00:14:04.930 --> 00:14:10.420
至少几年

00:14:06.070 --> 00:14:14.620
所以我们会说如果回滚点否则

00:14:10.420 --> 00:14:22.950
等于错误抛出新的运行时间

00:14:14.620 --> 00:14:25.540
好的确定无法写消息

00:14:22.950 --> 00:14:30.520
好吧，我们在那里，所以那是我们的

00:14:25.540 --> 00:14:31.750
我们已经写过的消息

00:14:30.520 --> 00:14:32.950
应该做吧，看看是否

00:14:31.750 --> 00:14:34.900
工作，让我们继续进行配置

00:14:32.950 --> 00:14:37.540
现在又会发生的是

00:14:34.900 --> 00:14:42.340
要创建一个JMS连接工厂

00:14:37.540 --> 00:14:44.740
图像和JBC数据源是

00:14:42.340 --> 00:14:46.390
会看到两个豆都实现了

00:14:44.740 --> 00:14:48.070
 XA资源类型

00:14:46.390 --> 00:14:53.190
行，以便使他们成为候选人

00:14:48.070 --> 00:14:55.870
参与XA交易

00:14:53.190 --> 00:14:58.120
自动配置会将它们包装起来， 

00:14:55.870 --> 00:14:59.500
使它们适应原子宿主类型，以便

00:14:58.120 --> 00:15:01.120
我们将实际获得的数据源

00:14:59.500 --> 00:15:02.620
创建的实际上是一个原子宿主

00:15:01.120 --> 00:15:04.300
包装x8数据的数据源

00:15:02.620 --> 00:15:06.460
源，并且将有原子关闭

00:15:04.300 --> 00:15:08.860
包装X的连接因子

00:15:06.460 --> 00:15:10.930
连接工厂现在您所看到的

00:15:08.860 --> 00:15:12.520
控制台在这里是极地

00:15:10.930 --> 00:15:14.950
知道那种心跳

00:15:12.520 --> 00:15:17.250
由每个容器的消息创建

00:15:14.950 --> 00:15:20.520
你一直都在骑自行车，所以让我们

00:15:17.250 --> 00:15:20.520
看这里

00:15:21.000 --> 00:15:27.160
终端，我们说了什么数据

00:15:25.390 --> 00:15:29.980
对，我们要说我们说

00:15:27.160 --> 00:15:31.420
我们要根据名字写

00:15:29.980 --> 00:15:35.470
对，所以这是一个

00:15:31.420 --> 00:15:38.290
去这里的控制台，我们要

00:15:35.470 --> 00:15:39.940
发一个卷发，名字等于春天

00:15:38.290 --> 00:15:41.890
粉丝，它将拥有内容类型F 

00:15:39.940 --> 00:15:43.720
等于应用程序JSON，我们将

00:15:41.890 --> 00:15:44.829
发送到这个端点，我们不会

00:15:43.720 --> 00:15:48.490
触发一个异常，所以我要

00:15:44.829 --> 00:15:50.500
发送它，所以我们没有桌子

00:15:48.490 --> 00:15:55.450
好的，所以我们需要那个胶带

00:15:50.500 --> 00:16:01.000
错误，所以我们将在这里创建表

00:15:55.450 --> 00:16:09.540
以及此处的架构方案或ASCII数据

00:16:01.000 --> 00:16:09.540
模式点续集创建表消息

00:16:10.649 --> 00:16:25.600
好吧，那将是ID VAR car 255 not 

00:16:17.950 --> 00:16:32.190
空唯一性和消息栏汽车255不

00:16:25.600 --> 00:16:32.190
知道可以再试一次

00:16:45.030 --> 00:16:50.540
好吧，本地主机

00:16:48.390 --> 00:16:52.590
在阅读中，我们只有一条信息

00:16:50.540 --> 00:16:55.680
你知道让我们再做一个

00:16:52.590 --> 00:17:01.970
确认，我们将立即发送你好

00:16:55.680 --> 00:17:04.350
春季粉丝们你好再次春季粉丝们送

00:17:01.970 --> 00:17:05.550
我们现在有两个消息

00:17:04.350 --> 00:17:05.940
这一个在这里和春天的地狱

00:17:05.550 --> 00:17:09.450
粉丝

00:17:05.940 --> 00:17:11.100
现在让我们触发一个异常吧

00:17:09.450 --> 00:17:15.240
你知道，如果我们在控制台上看

00:17:11.100 --> 00:17:20.580
也在这里我们应该看到你知道的消息

00:17:15.240 --> 00:17:23.880
身份证只有两次就可以了

00:17:20.580 --> 00:17:26.580
说两个比赛，我的两个

00:17:23.880 --> 00:17:28.590
匹配意味着这就是你知道的

00:17:26.580 --> 00:17:30.750
邮件已发送两次，我们

00:17:28.590 --> 00:17:31.890
在控制台上看到您知道我们看到的

00:17:30.750 --> 00:17:32.880
在其余Napier的输出中

00:17:31.890 --> 00:17:36.990
它已经两次写入数据库

00:17:32.880 --> 00:17:40.890
所以现在一切都很好，例外

00:17:36.990 --> 00:17:42.450
回滚相当等于true我没有

00:17:40.890 --> 00:17:46.380
我们所说的回滚是

00:17:42.450 --> 00:17:47.670
这里的参数是回滚等于

00:17:46.380 --> 00:17:50.700
对抛出的异常为真

00:17:47.670 --> 00:17:52.140
瞧，如果我们走到终点，我们

00:17:50.700 --> 00:17:54.270
应该什么都没看到没得到

00:17:52.140 --> 00:17:59.280
毕竟，如果我们看一下

00:17:54.270 --> 00:18:00.840
 JMS侦听器中的控制台仍然在此处

00:17:59.280 --> 00:18:03.090
只有两场比赛，您看不到

00:18:00.840 --> 00:18:06.060
第三，所以即使我们扔了

00:18:03.090 --> 00:18:08.010
似乎都是贾米斯之后的例外

00:18:06.060 --> 00:18:09.750
模板和JBC模板已经完成

00:18:08.010 --> 00:18:11.100
他们的工作不是工作单位

00:18:09.750 --> 00:18:13.800
已提交，并且已回退

00:18:11.100 --> 00:18:15.870
我们会自动使用，因此我们使用了原子

00:18:13.800 --> 00:18:17.970
要知道正确招募这两个人

00:18:15.870 --> 00:18:19.950
交易资源并回滚

00:18:17.970 --> 00:18:22.260
好像从未发生过的承诺

00:18:19.950 --> 00:18:24.540
创建一个您知道一致状态的状态

00:18:22.260 --> 00:18:26.300
从外面好吧，这是一个

00:18:24.540 --> 00:18:28.350
一个简单的例子，我们有一个

00:18:26.300 --> 00:18:30.360
明确的数据源和

00:18:28.350 --> 00:18:32.010
明确的连接工厂，如果

00:18:30.360 --> 00:18:33.600
我们有两个不同的数据源

00:18:32.010 --> 00:18:35.040
这将需要更多

00:18:33.600 --> 00:18:37.890
工作，让我们来看看

00:18:35.040 --> 00:18:44.940
以此为例很好地关闭这个

00:18:37.890 --> 00:18:45.270
关闭关闭并开始春天

00:18:44.940 --> 00:18:49.440
 o 

00:18:45.270 --> 00:18:51.600
现在假设我们要创建两个

00:18:49.440 --> 00:18:52.950
数据源示例不使用任何种类

00:18:51.600 --> 00:18:56.190
 JMS只是两个不同的数据源

00:18:52.950 --> 00:18:58.730
我们再次使用h2我们将使用JTA 

00:18:56.190 --> 00:19:03.929
所以我们使用原子也使用

00:18:58.730 --> 00:19:11.010
再次需要我们的网络支持

00:19:03.929 --> 00:19:12.150
支持，我认为这将在

00:19:11.010 --> 00:19:13.679
这个例子我们要做的是

00:19:12.150 --> 00:19:15.390
首先要知道

00:19:13.679 --> 00:19:18.830
开机是自动配置的很多

00:19:15.390 --> 00:19:22.169
如果我们有一个

00:19:18.830 --> 00:19:23.429
然后在类路径上创建内存数据库

00:19:22.169 --> 00:19:24.840
它将自动创建数据源

00:19:23.429 --> 00:19:27.419
如果我们不提供自己的数据

00:19:24.840 --> 00:19:29.160
来源，如果做得不好， 

00:19:27.419 --> 00:19:30.630
我们有多个数据源，因此

00:19:29.160 --> 00:19:32.520
让我们继续创造两天

00:19:30.630 --> 00:19:33.419
在这里很好地了解我们自己，您知道我们

00:19:32.520 --> 00:19:37.650
需要多做一点

00:19:33.419 --> 00:19:38.669
手动操作，因此在我们的代码中，我们有一些

00:19:37.650 --> 00:19:39.809
我们需要配置的东西

00:19:38.669 --> 00:19:41.850
首先我们想要做的是

00:19:39.809 --> 00:19:48.799
自行配置数据源

00:19:41.850 --> 00:20:07.559
对，所以我们说光束数据源还可以

00:19:48.799 --> 00:20:17.130
光束数据源B数据源B好的好的

00:20:07.559 --> 00:20:19.460
有这个和一个，我们需要

00:20:17.130 --> 00:20:21.480
提供JDBC的实现

00:20:19.460 --> 00:20:24.900
我们想要的数据源类型

00:20:21.480 --> 00:20:29.490
情况下，我将使用h2数据源

00:20:24.900 --> 00:20:31.770
输入正确的，因此JDBC数据源是

00:20:29.490 --> 00:20:34.080
这个就在这上课

00:20:31.770 --> 00:20:36.630
路径，但现在它们是自动的

00:20:34.080 --> 00:20:38.130
配置的H2驱动程序仅是运行时

00:20:36.630 --> 00:20:45.240
因此，让我们使其编译时，以便

00:20:38.130 --> 00:20:54.690
看到类型，我会说新的等于

00:20:45.240 --> 00:20:57.480
这个设置的URL等于我们想要的是什么

00:20:54.690 --> 00:21:02.330
 URL，它是内存中的h2 

00:20:57.480 --> 00:21:02.330
字符串示例很好

00:21:03.770 --> 00:21:12.900
快速开始找到我们使用这个，我

00:21:11.370 --> 00:21:16.740
不想每个都是相同的文件

00:21:12.900 --> 00:21:19.010
时间，所以我将其本地化，您将

00:21:16.740 --> 00:21:25.110
在这里覆盖字符串，所以我说B 

00:21:19.010 --> 00:21:27.120
再加上一个随机的字符串hew ID点，我是

00:21:25.110 --> 00:21:29.100
在那里完成，我们可以

00:21:27.120 --> 00:21:31.740
实际上，如果我们

00:21:29.100 --> 00:21:32.910
就这样离开吧，所以我们

00:21:31.740 --> 00:21:36.360
将要创建一个内存数据库

00:21:32.910 --> 00:21:39.420
由数据源命名的

00:21:36.360 --> 00:21:48.180
被称为A和B，用户名将为

00:21:39.420 --> 00:21:50.490
 si密码是空转那

00:21:48.180 --> 00:21:52.230
好吧，我们现在有两个

00:21:50.490 --> 00:21:53.220
数据源，我们需要初始化

00:21:52.230 --> 00:21:54.660
正确的数据，所以这又是两个

00:21:53.220 --> 00:21:56.100
这是不同的数据源

00:21:54.660 --> 00:21:58.140
可能是我的续集，可能会发布

00:21:56.100 --> 00:22:01.080
克里斯碰巧他们俩

00:21:58.140 --> 00:22:02.430
您知道的数据源相同

00:22:01.080 --> 00:22:04.020
在这种情况下键入，但他们不需要

00:22:02.430 --> 00:22:06.660
是的，可能是甲骨文之一

00:22:04.020 --> 00:22:07.830
可能是削减人员谁在乎我们

00:22:06.660 --> 00:22:09.270
想做的就是想初始化

00:22:07.830 --> 00:22:10.710
数据，而且两者都正确，我们不这样做

00:22:09.270 --> 00:22:11.760
想要带开机自行运行

00:22:10.710 --> 00:22:14.070
我们要创建自己的初始化程序

00:22:11.760 --> 00:22:16.740
有助于

00:22:14.070 --> 00:22:19.260
定制数据也许会有一张桌子

00:22:16.740 --> 00:22:20.700
充满宠物，您知道带有名字的物体

00:22:19.260 --> 00:22:22.380
另一个将有一张满的桌子

00:22:20.700 --> 00:22:26.400
消息之前有相同的想法

00:22:22.380 --> 00:22:32.090
我们将创建一束数据类型

00:22:26.400 --> 00:22:37.050
我返回时在其中的源初始化

00:22:32.090 --> 00:22:40.020
我们需要提供一个数据源

00:22:37.050 --> 00:22:45.450
我们在这里需要的数据源

00:22:40.020 --> 00:22:48.540
可以，我要打个电话

00:22:45.450 --> 00:22:51.710
它也是，或者只是创建那个

00:22:48.540 --> 00:22:51.710
初始化方法

00:22:54.310 --> 00:22:59.110
好，我们将创建一个数据源

00:22:57.310 --> 00:23:03.400
现在是初始化器数据源初始化器

00:22:59.110 --> 00:23:05.680
是弹簧本身的一种方便类型

00:23:03.400 --> 00:23:07.330
你知道你可以用它

00:23:05.680 --> 00:23:13.180
您可以用来初始化数据库，以便

00:23:07.330 --> 00:23:15.910
这是我们的数据源，我们要

00:23:13.180 --> 00:23:16.930
创建一个填充我们的数据库

00:23:15.910 --> 00:23:18.490
将使用资源数据库

00:23:16.930 --> 00:23:21.730
大众资源数据库

00:23:18.490 --> 00:23:24.870
流行将需要一个新的班级

00:23:21.730 --> 00:23:28.450
路径资源，我们要说的是

00:23:24.870 --> 00:23:31.510
在顶部知道续集的名称点

00:23:28.450 --> 00:23:34.930
续集，那我想

00:23:31.510 --> 00:23:45.160
我认为这会给我们很多

00:23:34.930 --> 00:23:47.620
那里很好，现在我们需要运行

00:23:45.160 --> 00:23:50.050
其中有两种init方法，一种用于

00:23:47.620 --> 00:23:53.280
 B的一个数据库或另一个数据库

00:23:50.050 --> 00:23:53.280
数据库还可以

00:23:59.710 --> 00:24:06.120
很好，我们有两个数据

00:24:02.080 --> 00:24:09.820
源和两个初始化器和

00:24:06.120 --> 00:24:15.100
这应该足够了，我们需要禁用

00:24:09.820 --> 00:24:16.390
我们默认的初始化程序好了，我们

00:24:15.100 --> 00:24:17.980
需要在这里创建一些架构

00:24:16.390 --> 00:24:25.210
在此之前，我们将创建两个不同的

00:24:17.980 --> 00:24:36.310
表一叫点续集嘿爸爸

00:24:25.210 --> 00:24:41.130
续集包含我们的宠物表，可以

00:24:36.310 --> 00:24:41.130
和昵称

00:24:45.680 --> 00:25:01.160
很好所以有续集

00:24:50.150 --> 00:25:02.570
将包含消息表，您

00:25:01.160 --> 00:25:06.820
知道储蓄之前只会写一个

00:25:02.570 --> 00:25:09.920
消息到数据库现在可以了

00:25:06.820 --> 00:25:11.810
通过这种方式，我们有两个

00:25:09.920 --> 00:25:12.710
初始化程序和两个数据源

00:25:11.810 --> 00:25:14.180
知道你可能还有其他事情

00:25:12.710 --> 00:25:15.080
想要在这些数据源上进行配置

00:25:14.180 --> 00:25:16.430
对，你想在

00:25:15.080 --> 00:25:17.840
属性，您仍然可以这样做

00:25:16.430 --> 00:25:19.370
只是因为我们正在配置基础

00:25:17.840 --> 00:25:21.140
是否对象，此处的代码并不意味着

00:25:19.370 --> 00:25:24.440
你不能和配置

00:25:21.140 --> 00:25:26.150
您知道前缀的属性等于so 

00:25:24.440 --> 00:25:28.340
这样，如果您去了

00:25:26.150 --> 00:25:31.010
配置文件，或者那样

00:25:28.340 --> 00:25:35.210
我猜想进入配置配置

00:25:31.010 --> 00:25:39.920
两者都将具有属性

00:25:35.210 --> 00:25:41.150
对，你可以说一个点一个点， 

00:25:39.920 --> 00:25:42.980
您的属性，即JDBC数据源

00:25:41.150 --> 00:25:44.780
在这里输入支持将是

00:25:42.980 --> 00:25:46.880
直接引用，因此不会出现URL 

00:25:44.780 --> 00:25:48.980
我在代码中所做的任何一个点

00:25:46.880 --> 00:25:50.420
因为这是一个简单的例子，但是

00:25:48.980 --> 00:25:52.160
请注意，您绝对可以这样做

00:25:50.420 --> 00:25:53.540
好吧，我们有两个不同

00:25:52.160 --> 00:25:55.730
数据源，所以我们有两个不同的

00:25:53.540 --> 00:25:57.950
初始化程序让我们继续创建一个

00:25:55.730 --> 00:26:00.440
其余端点只是一个您知道我们想要

00:25:57.950 --> 00:26:01.820
将两个端点的数据写入十二个

00:26:00.440 --> 00:26:04.340
数据库，所以我们要公开

00:26:01.820 --> 00:26:09.850
静态类让我们摆脱这件事

00:26:04.340 --> 00:26:13.940
在这里暂停XA，您知道XA是api吗？ 

00:26:09.850 --> 00:26:23.350
 rest controller 称此为休息

00:26:13.940 --> 00:26:23.350
控权人公共无效权

00:26:23.920 --> 00:26:30.370
我们要做什么

00:26:26.680 --> 00:26:31.630
发送它的帖子，就像我们上一次一样

00:26:30.370 --> 00:26:33.160
希望这是交易权利，所以

00:26:31.630 --> 00:26:36.910
我们将在交易型和

00:26:33.160 --> 00:26:41.560
请求正文将与上次相同

00:26:36.910 --> 00:26:43.840
字符串有效负载的字符串映射可以

00:26:41.560 --> 00:26:49.180
而且我们可以选择扔一个

00:26:43.840 --> 00:26:55.770
如果那里有参数则异常

00:26:49.180 --> 00:27:01.780
所以我们说可选的布尔回滚

00:26:55.770 --> 00:27:03.720
好的，现在我们需要使用

00:27:01.780 --> 00:27:07.690
在这里创建不同的数据源

00:27:03.720 --> 00:27:09.580
 jvc是的，您知道我们不知道的JP模板

00:27:07.690 --> 00:27:11.890
有两个不同的JDBC模板，所以我们

00:27:09.580 --> 00:27:17.230
需要自己创建它们，所以我会

00:27:11.890 --> 00:27:20.560
说JB的模板a和B好吧，我会

00:27:17.230 --> 00:27:23.440
提供这两个数据

00:27:20.560 --> 00:27:24.490
此处提供两个来源

00:27:23.440 --> 00:27:27.700
这里的不同数据源

00:27:24.490 --> 00:27:36.190
构造函数，然后初始化一个新的

00:27:27.700 --> 00:27:40.210
 JBC模板，新的JBC模板B和

00:27:36.190 --> 00:27:43.570
瞧，现在我们可以开始工作了，所以

00:27:40.210 --> 00:27:48.040
到援助数据库的表

00:27:43.570 --> 00:27:54.340
的宠物，所以我们说这个点

00:27:48.040 --> 00:28:01.480
点执行或更新，而不是插入

00:27:54.340 --> 00:28:05.530
宠物ID昵称值问号

00:28:01.480 --> 00:28:11.380
问号，我们取这个名字

00:28:05.530 --> 00:28:19.740
这里的字符串名称等于有效负载点

00:28:11.380 --> 00:28:25.810
获取名称字符串消息等于你好

00:28:19.740 --> 00:28:28.540
名称，我们将名称写入

00:28:25.810 --> 00:28:34.730
这里的数据库，我们说我们有

00:28:28.540 --> 00:28:42.500
您也知道ID的ID 

00:28:34.730 --> 00:28:45.500
带一个随机的字符串好名字

00:28:42.500 --> 00:28:55.780
然后在B数据库中

00:28:45.500 --> 00:28:59.540
说插入消息中，并且

00:28:55.780 --> 00:29:00.980
我们将在此处传递此消息

00:28:59.540 --> 00:29:02.570
好，这样就可以了，然后

00:29:00.980 --> 00:29:06.320
当然和上次一样

00:29:02.570 --> 00:29:09.620
告诉我们是否要返回点，否则

00:29:06.320 --> 00:29:12.380
错误或如果不存在，那么我们不会

00:29:09.620 --> 00:29:14.570
麻烦，但如果它在那里，如果

00:29:12.380 --> 00:29:19.940
是的，那我们要扔一个

00:29:14.570 --> 00:29:25.460
运行时异常无法编写

00:29:19.940 --> 00:29:27.919
数据到数据库好了，瞧

00:29:25.460 --> 00:29:29.360
好的，应该这样做

00:29:27.919 --> 00:29:32.360
交易端点与以前一样

00:29:29.360 --> 00:29:35.210
除了现在，而不是使用JMS和

00:29:32.360 --> 00:29:36.799
 JDBC我们仅使用JDBC， 

00:29:35.210 --> 00:29:40.840
我们将发送类型为JSON的有效负载

00:29:36.799 --> 00:29:43.880
名称或具有名称类型的值a 

00:29:40.840 --> 00:29:49.549
想法等于四个宠物的B点

00:29:43.880 --> 00:29:51.140
续集是我们应该拥有的四个信息

00:29:49.549 --> 00:29:52.700
某种方式确认已完成

00:29:51.140 --> 00:29:55.549
我不应该，所以让我们创建两个

00:29:52.700 --> 00:29:58.669
此处读取数据的端点，因此我们将

00:29:55.549 --> 00:30:05.330
说出集合类型的两个端点

00:29:58.669 --> 00:30:11.049
串宠物的地图还可以，我们会说

00:30:05.330 --> 00:30:19.450
我可以得到要映射的宠物

00:30:11.049 --> 00:30:19.450
只需将此点返回一个点查询

00:30:19.929 --> 00:30:32.600
从pet new row mapper中全选，然后我

00:30:30.520 --> 00:30:34.330
甚至不需要这样做，我们就可以

00:30:32.600 --> 00:30:38.020
使它简单一点

00:30:34.330 --> 00:30:38.020
字符串集合

00:30:46.650 --> 00:30:58.390
获得转弯的转弯结果

00:30:51.180 --> 00:30:58.840
昵称非常适合lambda，好吗

00:30:58.390 --> 00:31:00.540
我们是

00:30:58.840 --> 00:31:04.890
这是我们的简单宠物端点， 

00:31:00.540 --> 00:31:04.890
在此处为消息创建另一个

00:31:10.780 --> 00:31:18.890
消息并正确接收消息

00:31:17.360 --> 00:31:20.150
那应该让我们确认

00:31:18.890 --> 00:31:22.490
一切正常，你知道我们会的

00:31:20.150 --> 00:31:23.930
对...有明显的副作用

00:31:22.490 --> 00:31:26.000
在外面，所以我们可以证明你知道我们可以

00:31:23.930 --> 00:31:31.910
看到只有我们期望的

00:31:26.000 --> 00:31:41.660
发生了实际上发生了什么

00:31:31.910 --> 00:31:44.380
错误或获取我们的JBC URL不正确

00:31:41.660 --> 00:31:47.710
正确的文件类型，所以我们可以说

00:31:44.380 --> 00:31:50.090
只需将其存储在本地文件系统中

00:31:47.710 --> 00:31:57.560
在与该目录相同的目录中

00:31:50.090 --> 00:32:01.720
运行这个程序好了

00:31:57.560 --> 00:32:04.700
跑步如此卷曲一个名字你好春季球迷

00:32:01.720 --> 00:32:05.900
除略有改变外，其他与之前相同

00:32:04.700 --> 00:32:09.200
不同的是我们不会推出这一

00:32:05.900 --> 00:32:13.280
反正还没有插入

00:32:09.200 --> 00:32:19.220
找不到消息表消息

00:32:13.280 --> 00:32:20.180
因为我忘了让这个是B 

00:32:19.220 --> 00:32:20.750
数据源记住他们是两个

00:32:20.180 --> 00:32:26.110
不同的东西

00:32:20.750 --> 00:32:26.110
好吧，我们从头开始

00:32:36.930 --> 00:32:40.550
从中删除数据

00:32:58.090 --> 00:33:00.929
这里

00:33:23.440 --> 00:33:26.190
好的

00:33:30.620 --> 00:33:34.749
 -找不到消息

00:33:49.460 --> 00:33:59.510
好吧，对不起上帝现在

00:33:57.260 --> 00:34:01.040
更明确地说，你可能有

00:33:59.510 --> 00:34:03.140
我可以用一个限定词

00:34:01.040 --> 00:34:05.690
这样的限定词，但在这种情况下

00:34:03.140 --> 00:34:07.070
自动命名，你知道

00:34:05.690 --> 00:34:12.680
变量名称将消除歧义

00:34:07.070 --> 00:34:13.880
好的，如果您使用过

00:34:12.680 --> 00:34:15.260
预选赛然后什么都没关系

00:34:13.880 --> 00:34:16.760
变量的名称是

00:34:15.260 --> 00:34:19.370
正是您要解决的问题

00:34:16.760 --> 00:34:24.320
避免，当然现在这是一个

00:34:19.370 --> 00:34:28.030
问题，所以我们的MRF很抱歉在这里摆脱了

00:34:24.320 --> 00:34:28.030
所有这些东西再见

00:34:32.230 --> 00:34:42.620
好的，好的，让我们发送

00:34:38.020 --> 00:34:46.490
运行良好的本地主机宠物

00:34:42.620 --> 00:34:48.470
那和消息都还好，所以我们

00:34:46.490 --> 00:34:50.150
信息和我们的宠物在那里

00:34:48.470 --> 00:34:51.500
期待一切都很好

00:34:50.150 --> 00:34:54.170
让我们继续发送另一个消息

00:34:51.500 --> 00:34:55.100
只是为了证明它再次起作用

00:34:54.170 --> 00:35:05.270
再次

00:34:55.100 --> 00:35:07.880
春天的粉丝，再次好吧，所以

00:35:05.270 --> 00:35:10.190
现在，让我们扔一个

00:35:07.880 --> 00:35:12.170
例外，所以我们要送春天

00:35:10.190 --> 00:35:18.020
再次成为粉丝，但这次我们要说“滚” 

00:35:12.170 --> 00:35:22.460
 back等于true，这就是入门

00:35:18.020 --> 00:35:22.760
我们使用正确的是回滚，所以这里

00:35:22.460 --> 00:35:24.140
我们去

00:35:22.760 --> 00:35:28.450
准备一二三去扔

00:35:24.140 --> 00:35:28.450
例外，我们只能看到

00:35:33.750 --> 00:35:43.950
我忘了让这个交易

00:35:37.950 --> 00:35:45.300
啊，这不是交易

00:35:43.950 --> 00:35:47.940
事务性的，但我忘了要做的是

00:35:45.300 --> 00:35:50.130
正确包装数据源，所以这是

00:35:47.940 --> 00:35:53.310
我们需要做的实际上是

00:35:50.130 --> 00:35:54.690
最后遗失的一块在这里，所以我们有

00:35:53.310 --> 00:35:56.570
我们有两个数据源

00:35:54.690 --> 00:35:58.470
快速初始化数据

00:35:56.570 --> 00:35:59.940
我们正在使用的事务管理器是

00:35:58.470 --> 00:36:01.320
事务性的，您知道这是一个JTA 

00:35:59.940 --> 00:36:03.359
交易经理，但不知道

00:36:01.320 --> 00:36:07.170
这些交易资源中的

00:36:03.359 --> 00:36:08.730
我们要做的最后一件事是

00:36:07.170 --> 00:36:11.340
自动初始化我们的数据

00:36:08.730 --> 00:36:17.099
资源并包装它们，我们可以做到这一点

00:36:11.340 --> 00:36:20.040
通过在此处向X注入数据源

00:36:17.099 --> 00:36:23.210
包装到我们的构造函数中

00:36:20.040 --> 00:36:27.210
应用程序，在这里我们说包装点

00:36:23.210 --> 00:36:37.130
 AB数据源等于此抛出一个

00:36:27.210 --> 00:36:37.130
例外，在这里做同样的事情

00:36:40.740 --> 00:36:46.930
现在我需要返回这些数据源

00:36:44.849 --> 00:36:52.839
好吧，我们可以返回类型， 

00:36:46.930 --> 00:36:54.220
应该没关系，所以这里有我们

00:36:52.839 --> 00:36:55.450
去吧，我们要返回一个数据源

00:36:54.220 --> 00:36:57.369
我们用一个

00:36:55.450 --> 00:36:59.109
包装器，然后其他所有东西

00:36:57.369 --> 00:37:12.339
基本上就像我们继续

00:36:59.109 --> 00:37:13.809
重启好吧，我们现在都设置它们

00:37:12.339 --> 00:37:14.950
在这里，我们再尝试一次

00:37:13.809 --> 00:37:16.930
我们做正确的事的时间

00:37:14.950 --> 00:37:18.220
列出了两个数据源

00:37:16.930 --> 00:37:20.380
使用数据源进行交易

00:37:18.220 --> 00:37:21.730
包装器接口的实现

00:37:20.380 --> 00:37:23.530
由汽车提供

00:37:21.730 --> 00:37:25.000
您可以想象的配置

00:37:23.530 --> 00:37:26.950
是三种不同的实现

00:37:25.000 --> 00:37:28.750
这种类型之间有一条Tomica线

00:37:26.950 --> 00:37:30.369
是Narayana的一个克隆，所以我们

00:37:28.750 --> 00:37:33.190
使用我们提供的

00:37:30.369 --> 00:37:35.470
实施，否则我们将发送

00:37:33.190 --> 00:37:39.700
春天的粉丝们，我们不会滚

00:37:35.470 --> 00:37:44.650
返回，如果我们去这里，他们都在那里

00:37:39.700 --> 00:37:48.250
消息和宠物或用户

00:37:44.650 --> 00:37:51.670
我想好的宠物可能是穷人

00:37:48.250 --> 00:37:53.079
春季球迷的名字好吗

00:37:51.670 --> 00:37:59.410
所以现在让我们回滚

00:37:53.079 --> 00:38:02.230
异常好，所以异常我们的回滚

00:37:59.410 --> 00:38:06.940
等于而不是回滚等于

00:38:02.230 --> 00:38:09.010
 true在一条消息中引发异常

00:38:06.940 --> 00:38:11.079
消息并指出一条消息，然后

00:38:09.010 --> 00:38:14.619
宠物就是这样，所以我们去了

00:38:11.079 --> 00:38:16.660
不写第二条注册消息

00:38:14.619 --> 00:38:18.250
正确，我们将其重写为端点

00:38:16.660 --> 00:38:19.599
当然得到了处理，但后来我们

00:38:18.250 --> 00:38:22.270
引发了异常，因此工作单元

00:38:19.599 --> 00:38:24.279
包裹这两个的操作都被撤消了

00:38:22.270 --> 00:38:25.510
好的，所以在本期的

00:38:24.279 --> 00:38:27.910
春天的技巧，我们已经研究了如何使用

00:38:25.510 --> 00:38:29.799
 JTA我们已经研究了底层

00:38:27.910 --> 00:38:32.529
抽象插入各种

00:38:29.799 --> 00:38:34.779
来自JTA API的相关文章

00:38:32.529 --> 00:38:36.849
在Java EE应用程序内部

00:38:34.779 --> 00:38:38.650
服务器或独立的嵌入式服务器

00:38:36.849 --> 00:38:40.750
关于时尚，我们还研究了如何

00:38:38.650 --> 00:38:42.940
处理多个数据源

00:38:40.750 --> 00:38:45.069
我认为这是一个非常常见的用例

00:38:42.940 --> 00:38:46.510
现在说我真的很想

00:38:45.069 --> 00:38:48.730
强调这不是一个很好的选择

00:38:46.510 --> 00:38:50.650
对于某种现代应用

00:38:48.730 --> 00:38:52.240
造成单点故障

00:38:50.650 --> 00:38:52.869
如果你是，那将不是你想要的

00:38:52.240 --> 00:38:54.510
试图处理多个

00:38:52.869 --> 00:38:56.820
微型服务

00:38:54.510 --> 00:38:59.130
仍然执行公认的协议

00:38:56.820 --> 00:39:01.020
它需要一个文件系统，我可以

00:38:59.130 --> 00:39:03.240
是指我知道该文件的Java 

00:39:01.020 --> 00:39:05.340
交易经理需要一个持久的文件

00:39:03.240 --> 00:39:06.869
 Java点IO点文件才能做

00:39:05.340 --> 00:39:08.640
他们的工作真是天真

00:39:06.869 --> 00:39:09.869
假设，因为在

00:39:08.640 --> 00:39:12.210
你真的不能认为云

00:39:09.869 --> 00:39:13.500
存在我们文件的可用性

00:39:12.210 --> 00:39:14.340
所以如果有某种更好的选择

00:39:13.500 --> 00:39:16.650
其他API的

00:39:14.340 --> 00:39:19.170
除了Java点IO点文件之外

00:39:16.650 --> 00:39:21.990
本身就是最终的权利，因此您可以使用

00:39:19.170 --> 00:39:24.540
我会存储某种其他耐用性

00:39:21.990 --> 00:39:26.850
好的，好的，非常感谢

00:39:24.540 --> 00:39:29.359
下降和调优，我们将看到你

00:39:26.850 --> 00:39:29.359
下一次左右

00:39:34.789 --> 00:39:36.849
您

