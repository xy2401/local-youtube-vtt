WEBVTT
Kind: captions
Language: zh-Hans

00:00:13.710 --> 00:00:17.030
我弹簧乐队和这部分

00:00:16.110 --> 00:00:18.560
春季小贴士

00:00:17.030 --> 00:00:20.540
头，看看程序化

00:00:18.560 --> 00:00:22.580
光束配准功能

00:00:20.540 --> 00:00:24.470
即将到来的Spring 5中的功能

00:00:22.580 --> 00:00:28.280
现在发布不会因为 spring 5 

00:00:24.470 --> 00:00:30.350
发行至2017年夏季，但

00:00:28.280 --> 00:00:31.400
确实有很大的潜力

00:00:30.350 --> 00:00:33.350
在这里，我想鼓励人们

00:00:31.400 --> 00:00:35.480
尝试一下，踢轮胎，以便

00:00:33.350 --> 00:00:37.700
说话，为了做到这一点，我们要

00:00:35.480 --> 00:00:39.500
走下配置路

00:00:37.700 --> 00:00:41.600
然后看一些选项， 

00:00:39.500 --> 00:00:44.510
在Spring Framework中受支持，直到

00:00:41.600 --> 00:00:47.150
现在，看看这种新方法

00:00:44.510 --> 00:00:48.350
现在在 spring 5推出

00:00:47.150 --> 00:00:49.580
为了做到这一点，我们需要弹簧启动

00:00:48.350 --> 00:00:52.220
那个那个当然在

00:00:49.580 --> 00:00:56.330
现在快照，因为它将

00:00:52.220 --> 00:00:59.870
取决于Spring 5现在Spring 5 build 

00:00:56.330 --> 00:01:03.199
在Java 8上，因此它具有Java 8 

00:00:59.870 --> 00:01:04.820
结果是我们可以做到的

00:01:03.199 --> 00:01:08.240
当我们做一些非常有趣的事情

00:01:04.820 --> 00:01:10.760
用spring定义套准应用

00:01:08.240 --> 00:01:12.590
让我们看看它是什么样子

00:01:10.760 --> 00:01:14.170
看看效果如何，我们将开始

00:01:12.590 --> 00:01:17.170
我们今天的例子非常简单

00:01:14.170 --> 00:01:18.860
基本上是空的Spring应用程序

00:01:17.170 --> 00:01:21.320
我要做的是

00:01:18.860 --> 00:01:23.210
脱去 spring boot 

00:01:21.320 --> 00:01:26.210
回到低级的Spring框架

00:01:23.210 --> 00:01:29.020
本身，我们来看看一些

00:01:26.210 --> 00:01:31.100
很基本，您知道正在注册

00:01:29.020 --> 00:01:33.049
接近你可能是其中的一些

00:01:31.100 --> 00:01:35.000
如果您曾经使用过，现在熟悉

00:01:33.049 --> 00:01:37.549
过去15年中的春天

00:01:35.000 --> 00:01:39.799
知道有使用xml的支持

00:01:37.549 --> 00:01:42.710
应用程序配置文件和我

00:01:39.799 --> 00:01:44.270
不会打扰表明这肯定是

00:01:42.710 --> 00:01:46.759
仍然可以工作，仍然可以

00:01:44.270 --> 00:01:49.340
但我有兴趣专注于

00:01:46.759 --> 00:01:51.799
我们使用Java进行注册的方式

00:01:49.340 --> 00:01:54.469
正确的代码就是

00:01:51.799 --> 00:01:55.939
这个特殊的弹簧尖端，让我们

00:01:54.469 --> 00:01:57.700
假设我们在这里有一个应用程序

00:01:55.939 --> 00:02:02.210
对，我们有两个豆子，我们称之为

00:01:57.700 --> 00:02:03.350
酒吧服务，我们还有另一个

00:02:02.210 --> 00:02:06.740
叫

00:02:03.350 --> 00:02:09.560
 foo服务，让我们假设foo 

00:02:06.740 --> 00:02:11.780
服务取决于酒吧先生，所以我们会

00:02:09.560 --> 00:02:13.550
在这里声明一个协作对象

00:02:11.780 --> 00:02:15.770
那是应该提供的东西

00:02:13.550 --> 00:02:17.750
构造函数，我们有几种方法

00:02:15.770 --> 00:02:19.190
我们可以告诉春天

00:02:17.750 --> 00:02:20.720
应用程序，让我们假设这是一个

00:02:19.190 --> 00:02:22.100
配置应用程序或

00:02:20.720 --> 00:02:23.630
配置类，而不是我们要去的

00:02:22.100 --> 00:02:26.360
用add注释它

00:02:23.630 --> 00:02:28.700
配置，假设我们

00:02:26.360 --> 00:02:29.470
仅使用常规应用程序上下文

00:02:28.700 --> 00:02:32.870
好的

00:02:29.470 --> 00:02:34.730
终于在春天，我们有了豆

00:02:32.870 --> 00:02:37.310
工厂，但豆类工厂只包含

00:02:34.730 --> 00:02:38.690
豆有一些原语

00:02:37.310 --> 00:02:39.890
使开发人员更轻松地工作

00:02:38.690 --> 00:02:41.870
与您在应用程序中认识的拥护者

00:02:39.890 --> 00:02:44.060
有一个他们称为应用程序

00:02:41.870 --> 00:02:46.340
反过来与bean一起工​​作的上下文

00:02:44.060 --> 00:02:47.810
工厂应用程序上下文

00:02:46.340 --> 00:02:50.540
提供生命周期管理等

00:02:47.810 --> 00:02:53.150
我们往往是最低的

00:02:50.540 --> 00:02:54.320
春天框架的切入点

00:02:53.150 --> 00:02:56.420
这些天，大多数人都很熟悉

00:02:54.320 --> 00:02:57.890
这样我们就不会使用spring 

00:02:56.420 --> 00:03:00.860
现在启动，我们将回到

00:02:57.890 --> 00:03:03.590
后来确实，如果我离开了

00:03:00.860 --> 00:03:05.150
这个运行方法的结果是

00:03:03.590 --> 00:03:08.600
实际的应用程序上下文权限，所以我

00:03:05.150 --> 00:03:11.000
我可以回到那里吗

00:03:08.600 --> 00:03:14.150
轻松地返回熟悉的地面

00:03:11.000 --> 00:03:14.990
但是让我们做些困难

00:03:14.150 --> 00:03:16.760
正确的方式，我们将展示

00:03:14.990 --> 00:03:21.920
注释或应用

00:03:16.760 --> 00:03:23.900
上下文EC等于新注释配置

00:03:21.920 --> 00:03:25.940
应用程序上下文及其含义

00:03:23.900 --> 00:03:27.950
期望是配置类权利

00:03:25.940 --> 00:03:31.700
所以我要通过

00:03:27.950 --> 00:03:33.410
这里的配置类

00:03:31.700 --> 00:03:35.330
给我们我们的第一种配置方式

00:03:33.410 --> 00:03:38.030
豆（如果您通过XML知道的话） 

00:03:35.330 --> 00:03:40.190
 XML提供了一种注册方法

00:03:38.030 --> 00:03:44.720
单个工件中的单个工件中的bean 

00:03:40.190 --> 00:03:46.130
 XML配置文件和Bean 

00:03:44.720 --> 00:03:48.350
定义是所有中央的

00:03:46.130 --> 00:03:50.780
应用程序中所有定义都在一个

00:03:48.350 --> 00:03:52.790
放置并看到我进行了某种调查或

00:03:50.780 --> 00:03:55.040
一目了然

00:03:52.790 --> 00:03:57.260
 Java配置样式

00:03:55.040 --> 00:03:58.670
给你同样的好处，这是

00:03:57.260 --> 00:04:02.480
也是非常明确的权利，我们不

00:03:58.670 --> 00:04:04.130
必须依靠它的推断

00:04:02.480 --> 00:04:07.209
关系的一切都是

00:04:04.130 --> 00:04:13.430
明确接线，所以我说全面服务

00:04:07.209 --> 00:04:17.410
恢复服务，我依靠

00:04:13.430 --> 00:04:20.540
我可以说酒吧服务

00:04:17.410 --> 00:04:22.430
现在返回新的酒吧服务，其中之一

00:04:20.540 --> 00:04:23.870
豆对另一个有依赖性

00:04:22.430 --> 00:04:27.169
我们可以告诉春天满足

00:04:23.870 --> 00:04:29.960
通过注入酒吧服务的依赖

00:04:27.169 --> 00:04:32.510
这样，或者我当然可以打电话

00:04:29.960 --> 00:04:33.830
那样的方法

00:04:32.510 --> 00:04:35.690
结果将有一个餐饮服务

00:04:33.830 --> 00:04:39.110
拥有合作对象的权利

00:04:35.690 --> 00:04:40.050
所以听着，我倾向于离开它

00:04:39.110 --> 00:04:42.210
这个

00:04:40.050 --> 00:04:43.680
如果我需要，这只是服务器方便

00:04:42.210 --> 00:04:46.889
复制定义并粘贴在那里

00:04:43.680 --> 00:04:48.810
所以这很明显，现在让我们测试

00:04:46.889 --> 00:04:51.270
这段代码我想测试一下

00:04:48.810 --> 00:04:52.740
实际上按照我们的预期工作， 

00:04:51.270 --> 00:04:56.190
我们有两个豆子，让我们来看一下

00:04:52.740 --> 00:04:58.800
我们的测试代码在这里，我们称之为

00:04:56.190 --> 00:05:01.979
上下文配置和Tatian 

00:04:58.800 --> 00:05:04.379
会告诉我们使用配置101 

00:05:01.979 --> 00:05:06.650
应用该类，我要去

00:05:04.379 --> 00:05:17.270
自己注入应用程序上下文

00:05:06.650 --> 00:05:21.360
这里我们去，这里我们要说断点

00:05:17.270 --> 00:05:24.419
这次不是没有申请时间

00:05:21.360 --> 00:05:36.409
服务那个班级的上下文豆

00:05:24.419 --> 00:05:36.409
正确，所以这里传出错误的断言可以

00:05:40.220 --> 00:05:43.370
有

00:05:50.449 --> 00:05:56.399
我们去那里，然后是第三

00:05:53.399 --> 00:05:58.229
我可以学到的东西是M条

00:05:56.399 --> 00:06:00.869
服务不知道，所以我们有两个豆子

00:05:58.229 --> 00:06:03.659
一个应该依赖另一个

00:06:00.869 --> 00:06:07.080
我想确认他们俩

00:06:03.659 --> 00:06:13.969
就像我们期望的那样到目前为止

00:06:07.080 --> 00:06:13.969
该类，让我们运行此测试，以便

00:06:19.699 --> 00:06:27.599
一切似乎都很好，让我们来证明

00:06:21.809 --> 00:06:28.860
他们说我们想要负面

00:06:27.599 --> 00:06:31.669
这是空的吧，让我们

00:06:28.860 --> 00:06:33.629
确保我们没有得到某种

00:06:31.669 --> 00:06:34.919
 uke幸回应并假设在这种情况下

00:06:33.629 --> 00:06:36.899
并不重要，但总是

00:06:34.919 --> 00:06:38.550
确保我们没有想象力很有用

00:06:36.899 --> 00:06:43.649
一切正常，所以我们正在运行正确的测试

00:06:38.550 --> 00:06:45.029
一切都在做着，很不了解

00:06:43.649 --> 00:06:47.189
现在好

00:06:45.029 --> 00:06:48.599
那个意思就是说

00:06:47.189 --> 00:06:49.499
关于春天，我们已经告诉过它了

00:06:48.599 --> 00:06:51.389
关于这两种豆，它们是

00:06:49.499 --> 00:06:53.459
现在注册，这有点乏味

00:06:51.389 --> 00:06:55.800
我必须管理每个实例

00:06:53.459 --> 00:06:56.990
因此，我可以将这些分层在一起

00:06:55.800 --> 00:07:01.740
有一个配置类

00:06:56.990 --> 00:07:03.629
导入其他一些配置类我

00:07:01.740 --> 00:07:05.279
我愿意的话可以做

00:07:03.629 --> 00:07:09.089
高阶配置莱斯利，但

00:07:05.279 --> 00:07:10.800
我还是想只能这样做

00:07:09.089 --> 00:07:11.879
我需要为什么不让我做些工作

00:07:10.800 --> 00:07:13.289
框架为我工作

00:07:11.879 --> 00:07:15.539
只要有可能，为此

00:07:13.289 --> 00:07:19.259
组件在组件中扫描

00:07:15.539 --> 00:07:20.459
扫描，而不是显式

00:07:19.259 --> 00:07:22.739
用弹簧定义一个

00:07:20.459 --> 00:07:24.469
这些bean中的隐含关系

00:07:22.739 --> 00:07:27.419
通过在

00:07:24.469 --> 00:07:29.519
组件和其他这样的刻板印象

00:07:27.419 --> 00:07:30.899
注释，所以这是一个成见

00:07:29.519 --> 00:07:32.819
注释，它在

00:07:30.899 --> 00:07:35.039
框架本身和spring将使用

00:07:32.819 --> 00:07:36.300
那种刻板印象的注释

00:07:35.039 --> 00:07:38.099
你知道这是一个术语

00:07:36.300 --> 00:07:42.050
应正确管理的组件

00:07:38.099 --> 00:07:42.050
因此，让我们回顾一下该测试

00:07:46.560 --> 00:07:51.240
我们去那里有我们的应用程序

00:07:48.980 --> 00:07:54.510
一切似乎都很好，所以现在我们已经

00:07:51.240 --> 00:07:55.560
完成了UH，我们已经完成了额外的任务

00:07:54.510 --> 00:07:57.690
我们不必显式定义的代码

00:07:55.560 --> 00:08:00.180
事实是这些豆是豆

00:07:57.690 --> 00:08:01.230
与组件本身一起生活

00:08:00.180 --> 00:08:06.020
可以混合搭配，没有

00:08:01.230 --> 00:08:10.350
您无法获得酒吧服务的原因

00:08:06.020 --> 00:08:12.120
像这样，我打开酒吧服务，然后

00:08:10.350 --> 00:08:14.820
然后在此处删除注释

00:08:12.120 --> 00:08:17.389
这里的酒吧服务很好，所以在这种情况下

00:08:14.820 --> 00:08:19.770
我们应该看到相同的结果以及

00:08:17.389 --> 00:08:21.270
预计现在他们很漂亮

00:08:19.770 --> 00:08:24.570
直接购买注册

00:08:21.270 --> 00:08:25.919
可以，我们可以降低一点

00:08:24.570 --> 00:08:27.780
有时能够

00:08:25.919 --> 00:08:30.510
根据某些条件注册bean 

00:08:27.780 --> 00:08:32.610
或某种动态状态，所以一种方法

00:08:30.510 --> 00:08:34.979
注册bean是使用bean 

00:08:32.610 --> 00:08:36.390
定义注册表后处理器

00:08:34.979 --> 00:08:42.469
合同权利，所以我可以公开地说

00:08:36.390 --> 00:08:44.820
静态类，我的ping博士PP实现

00:08:42.469 --> 00:08:47.279
处理器的定义注册表和

00:08:44.820 --> 00:08:48.810
这个回调是，这只是一个

00:08:47.279 --> 00:08:50.610
我要注册的bean在这里

00:08:48.810 --> 00:08:52.650
只是某种类型的光束

00:08:50.610 --> 00:08:57.150
回调使我有机会注册

00:08:52.650 --> 00:09:01.339
我实际上是正确的项链对象

00:08:57.150 --> 00:09:01.339
将注册较低级别的

00:09:02.870 --> 00:09:08.010
底层机制数据线

00:09:05.550 --> 00:09:09.630
那种运行时定义

00:09:08.010 --> 00:09:11.550
用它叫做光束

00:09:09.630 --> 00:09:13.560
定义，因此在春季得到了所有这些

00:09:11.550 --> 00:09:15.450
来自光束定义的输入

00:09:13.560 --> 00:09:18.180
或Java配置或组件

00:09:15.450 --> 00:09:19.860
扫描或其他所有合并

00:09:18.180 --> 00:09:22.380
装进一个大袋子里

00:09:19.860 --> 00:09:23.430
定义，我们可以实际工作

00:09:22.380 --> 00:09:26.040
有了那个权利，所以我有一个豆

00:09:23.430 --> 00:09:28.290
定义注册表在这里，我可以

00:09:26.040 --> 00:09:30.839
我要注册豆子

00:09:28.290 --> 00:09:32.190
可以说我要注册foo先生，我

00:09:30.839 --> 00:09:33.900
想注册一个酒吧，所以说我

00:09:32.190 --> 00:09:35.880
只想注册豆吧

00:09:33.900 --> 00:09:37.290
服务，它会期待一个bean 

00:09:35.880 --> 00:09:40.110
定义，我可以使用bean 

00:09:37.290 --> 00:09:43.560
定义生成器，所以我可以说

00:09:40.110 --> 00:09:46.410
通用通用bean定义传递

00:09:43.560 --> 00:09:49.170
在我要定义的课程中

00:09:46.410 --> 00:09:51.990
对吧酒吧服务日志类，我可以

00:09:49.170 --> 00:09:53.370
说给定的bean定义和那里

00:09:51.990 --> 00:09:54.450
我们有我的bean定义权

00:09:53.370 --> 00:09:56.880
所以让我看看是否可行

00:09:54.450 --> 00:09:59.430
继续对此发表评论，所以现在我们

00:09:56.880 --> 00:10:00.450
明确没有酒吧服务

00:09:59.430 --> 00:10:03.570
在任何地方定义

00:10:00.450 --> 00:10:04.920
为此保存光束定义

00:10:03.570 --> 00:10:07.080
注册表后处理器我在做什么

00:10:04.920 --> 00:10:08.460
我正在使用光束定义吗

00:10:07.080 --> 00:10:10.320
注册表是较低级别的类型

00:10:08.460 --> 00:10:12.060
在Springs应用程序上下文中

00:10:10.320 --> 00:10:13.890
我正在注册成为

00:10:12.060 --> 00:10:15.750
以编程方式给它一个光束ID和

00:10:13.890 --> 00:10:18.990
给它一个光束定义

00:10:15.750 --> 00:10:20.880
梁定义不是实际的对象

00:10:18.990 --> 00:10:22.380
他们最终变成了反思

00:10:20.880 --> 00:10:24.750
 Santee中使用的代码正确代码

00:10:22.380 --> 00:10:26.700
想法的定义和满意

00:10:24.750 --> 00:10:28.440
协作对象等

00:10:26.700 --> 00:10:33.090
但是我们已经注册了

00:10:28.440 --> 00:10:34.830
使用其他定义中的光束

00:10:33.090 --> 00:10:36.750
注册表后处理器只是为了证明

00:10:34.830 --> 00:10:39.420
那是行不通的，我只会

00:10:36.750 --> 00:10:41.580
证明我们在这里不是很幸运

00:10:39.420 --> 00:10:44.810
错误类型的注册光束

00:10:41.580 --> 00:10:47.280
看到事情分崩离析，所以春天是

00:10:44.810 --> 00:10:48.630
寻找酒吧服务，它是

00:10:47.280 --> 00:10:50.850
会得到的会得到的

00:10:48.630 --> 00:10:51.960
通过创建一个无参数的定义

00:10:50.850 --> 00:10:55.080
调用新的有机构造函数

00:10:51.960 --> 00:10:57.180
我们这里自然可以提供酒吧服务

00:10:55.080 --> 00:10:59.340
更复杂的注册

00:10:57.180 --> 00:11:01.290
所以让我们继续对此发表评论

00:10:59.340 --> 00:11:03.030
在这里注释，以便现在我们必须

00:11:01.290 --> 00:11:07.020
既可以注册又可以注册

00:11:03.030 --> 00:11:09.740
注册波束定义服务并

00:11:07.020 --> 00:11:13.170
这里我们要说光束定义

00:11:09.740 --> 00:11:17.640
注册表红色抱歉

00:11:13.170 --> 00:11:20.210
定义生成器点通用梁

00:11:17.640 --> 00:11:24.090
我要说的是谁的定义

00:11:20.210 --> 00:11:26.010
我想说的是

00:11:24.090 --> 00:11:28.080
这是遗传场景的定义

00:11:26.010 --> 00:11:32.690
我想提供某种类型，但

00:11:28.080 --> 00:11:32.690
我也想覆盖

00:11:32.990 --> 00:11:37.440
这个对象是如何构造的

00:11:35.280 --> 00:11:39.900
 Java和spring中有一个新功能

00:11:37.440 --> 00:11:42.480
 5意味着基于Java 8 

00:11:39.900 --> 00:11:45.990
一个供应商，所以我要说的是

00:11:42.480 --> 00:11:48.570
梁是真正的服务类别，但我

00:11:45.990 --> 00:11:51.060
想要定义该对象应该如何

00:11:48.570 --> 00:11:52.590
实例化正确，所以在这里我有一个

00:11:51.060 --> 00:11:57.080
 Java 8中使用的回调接口

00:11:52.590 --> 00:12:02.630
供应商权利，此Java为供应商

00:11:57.080 --> 00:12:05.400
会给我机会去

00:12:02.630 --> 00:12:07.470
工厂或建立我自己的

00:12:05.400 --> 00:12:09.270
光束，在这种情况下，我可以说新食物

00:12:07.470 --> 00:12:11.100
服务，然后是当然的问题

00:12:09.270 --> 00:12:12.360
是如何获得协作对象的

00:12:11.100 --> 00:12:14.430
好吧，这给了我一些棘手的权利

00:12:12.360 --> 00:12:17.160
需要垂头丧气

00:12:14.430 --> 00:12:19.590
光束定义注册表

00:12:17.160 --> 00:12:21.300
会给我那种类型的东西

00:12:19.590 --> 00:12:25.500
我想在这种情况下说

00:12:21.300 --> 00:12:30.300
这是梁厂，对不起

00:12:25.500 --> 00:12:34.170
坪厂种姓路过

00:12:30.300 --> 00:12:38.070
我想要合作的PDR 

00:12:34.170 --> 00:12:41.940
在这种情况下反对

00:12:38.070 --> 00:12:46.050
输入所有正确的信息，所以我实际上很沮丧

00:12:41.940 --> 00:12:50.580
铸造梁工厂，我正在使用

00:12:46.050 --> 00:12:52.400
梁厂来解决

00:12:50.580 --> 00:12:54.420
行进物体，如果我们运行

00:12:52.400 --> 00:12:56.690
一切现在仍然应该工作

00:12:54.420 --> 00:12:59.040
记得这个光束工厂要

00:12:56.690 --> 00:13:01.530
这个定义将是

00:12:59.040 --> 00:13:03.660
仅在spring尝试评估时

00:13:01.530 --> 00:13:05.400
工厂的餐饮服务，所以它在

00:13:03.660 --> 00:13:07.530
正确的时间没有工作

00:13:05.400 --> 00:13:09.900
真的没有任何早期风险

00:13:07.530 --> 00:13:11.460
初始化问题就对了

00:13:09.900 --> 00:13:14.250
要打电话给供应商

00:13:11.460 --> 00:13:16.410
准备这样做，所以你可以问

00:13:14.250 --> 00:13:18.390
上下文或相应的燃烧对象

00:13:16.410 --> 00:13:20.160
现在这就是你所知道的

00:13:18.390 --> 00:13:21.390
方便，这样您就可以

00:13:20.160 --> 00:13:23.010
回调接口，您拥有它

00:13:21.390 --> 00:13:25.080
这是一个机会

00:13:23.010 --> 00:13:26.370
定义注册表端口培育所以

00:13:25.080 --> 00:13:28.950
动态注册许多不同

00:13:26.370 --> 00:13:30.720
对象，在这里您会得到一种

00:13:28.950 --> 00:13:32.910
像您没有交易的Java 

00:13:30.720 --> 00:13:36.480
与您肯定正在处理

00:13:32.910 --> 00:13:37.740
低水平光束

00:13:36.480 --> 00:13:38.730
定义，您当然知道

00:13:37.740 --> 00:13:40.050
您正在处理的事实

00:13:38.730 --> 00:13:42.540
屏幕定义不正确

00:13:40.050 --> 00:13:44.310
初始化对象，但仍然非常

00:13:42.540 --> 00:13:46.980
以编程方式获得communit测试

00:13:44.310 --> 00:13:48.090
这是非常非常不错的一件事，我

00:13:46.980 --> 00:13:49.890
像这样当然是因为

00:13:48.090 --> 00:13:51.930
弄乱了语言，所以

00:13:49.890 --> 00:13:54.240
其实真的很方便吧

00:13:51.930 --> 00:13:56.610
这样，我们可以将其设为静态

00:13:54.240 --> 00:13:59.220
进口权，所以它不是一个

00:13:56.610 --> 00:14:01.100
当您现在查看代码时

00:13:59.220 --> 00:14:04.560
变得更干净，当然可以

00:14:01.100 --> 00:14:05.940
从搅拌机定义中移出

00:14:04.560 --> 00:14:08.460
这种情况下，您甚至根本不需要

00:14:05.940 --> 00:14:11.310
整个事情变成了

00:14:08.460 --> 00:14:13.860
单线真的，我认为是相当

00:14:11.310 --> 00:14:16.110
很好，所以有那个代码

00:14:13.860 --> 00:14:20.660
现在使用起来要简单得多

00:14:16.110 --> 00:14:23.270
给了我们程序化的光束

00:14:20.660 --> 00:14:26.780
定义或注册我们

00:14:23.270 --> 00:14:30.150
这里的应用程序上下文

00:14:26.780 --> 00:14:32.010
只是下架的情况下

00:14:30.150 --> 00:14:34.620
现在我们可以再次注册

00:14:32.010 --> 00:14:36.380
动态地发出光束，这是其中之一

00:14:34.620 --> 00:14:39.630
真正好的用例是纯粹的

00:14:36.380 --> 00:14:42.090
面向对象的乐趣，所以我

00:14:39.630 --> 00:14:44.040
要说注册光束，让我们

00:14:42.090 --> 00:14:46.680
现在假设我将我们的注释掉

00:14:44.040 --> 00:14:48.420
正在定义注册表信箱或

00:14:46.680 --> 00:14:50.370
所以实际上那是在我运行这个之前

00:14:48.420 --> 00:14:54.540
代码让我们注释掉并确认

00:14:50.370 --> 00:14:56.280
一切都坏了，所以

00:14:54.540 --> 00:14:58.170
一切都坏了，因为我

00:14:56.280 --> 00:14:59.550
评论了这两个豆

00:14:58.170 --> 00:15:03.210
单元如果失败，我现在想做

00:14:59.550 --> 00:15:05.970
我是否要向

00:15:03.210 --> 00:15:09.000
应用程序上下文

00:15:05.970 --> 00:15:10.560
使用新的通用新注册

00:15:09.000 --> 00:15:12.540
 bean函数在程序中

00:15:10.560 --> 00:15:14.660
定义和注册

00:15:12.540 --> 00:15:19.140
功能和弹簧五现在我

00:15:14.660 --> 00:15:21.030
可以在此应用程序上完成这项工作

00:15:19.140 --> 00:15:23.070
上下文实例本身，那是

00:15:21.030 --> 00:15:25.380
当然可以，但是我想

00:15:23.070 --> 00:15:28.170
使它可以使代码在

00:15:25.380 --> 00:15:29.250
与我同时作为单元测试权限

00:15:28.170 --> 00:15:30.870
我要账单以确保我的单位

00:15:29.250 --> 00:15:33.210
看到了变化并记住了

00:15:30.870 --> 00:15:34.020
单元测试不会运行这个主要的

00:15:33.210 --> 00:15:35.570
方法，它将有自己的

00:15:34.020 --> 00:15:37.430
上下文，它将运行自己的

00:15:35.570 --> 00:15:41.600
即时，因此我们需要提供一个

00:15:37.430 --> 00:15:41.600
应用程序上下文初始化程序

00:15:41.720 --> 00:15:48.780
定义式初始化程序

00:15:46.590 --> 00:15:53.190
对，这将要实施

00:15:48.780 --> 00:15:54.870
应用程序上下文初始化程序和

00:15:53.190 --> 00:15:57.090
在您的大小调整器中将代替工作

00:15:54.870 --> 00:16:00.240
具有通用应用程序的子类型

00:15:57.090 --> 00:16:02.580
你知道这个通用的上下文

00:16:00.240 --> 00:16:07.020
这里的应用程序上下文子类型

00:16:02.580 --> 00:16:10.260
所以我们要做的是

00:16:07.020 --> 00:16:13.860
告诉spring在当

00:16:10.260 --> 00:16:15.300
应用程序启动，有一些

00:16:13.860 --> 00:16:18.230
正确的方法有几种方法

00:16:15.300 --> 00:16:20.730
为此，我们可以告诉我们

00:16:18.230 --> 00:16:23.750
运行应用程序时的应用程序

00:16:20.730 --> 00:16:30.030
我们可以说交流点，而我们可以说我

00:16:23.750 --> 00:16:32.070
对此编程并调用初始化

00:16:30.030 --> 00:16:33.720
通过交流，那肯定会

00:16:32.070 --> 00:16:36.780
工作，你知道那不是问题

00:16:33.720 --> 00:16:39.030
但是我们真正想做的是

00:16:36.780 --> 00:16:39.960
无论我们是否

00:16:39.030 --> 00:16:41.640
做整合

00:16:39.960 --> 00:16:43.710
是否我们正在这样做，所以我要

00:16:41.640 --> 00:16:45.540
带回我要去的 spring boot 

00:16:43.710 --> 00:16:48.540
带回这两个 spring boot 

00:16:45.540 --> 00:16:49.800
注释同时被取代

00:16:48.540 --> 00:16:52.020
在温泉符号提供相同的

00:16:49.800 --> 00:16:56.630
真正受益，然后我将使用

00:16:52.020 --> 00:16:59.790
春季应用程序运行九个

00:16:56.630 --> 00:17:01.890
传入配置101设置缓存

00:16:59.790 --> 00:17:05.970
传递args和此的类

00:17:01.890 --> 00:17:09.089
这里的方法实际上是语法快捷方式

00:17:05.970 --> 00:17:10.860
对于新的春季申请，我要去

00:17:09.089 --> 00:17:14.520
正确添加一个初始化程序，所以添加

00:17:10.860 --> 00:17:16.650
初始化程序，这是我可以做到的一种方法

00:17:14.520 --> 00:17:19.350
但这在我的测试中看不到

00:17:16.650 --> 00:17:20.699
我真正想要的只是

00:17:19.350 --> 00:17:24.120
我可以定义这些的单个地方

00:17:20.699 --> 00:17:25.290
门牙，并具有主要代码

00:17:24.120 --> 00:17:27.179
然后测试代码找到它，那就是

00:17:25.290 --> 00:17:32.780
春天那家工厂是对的，如果我

00:17:27.179 --> 00:17:38.520
在这里创建我自己的meta教练ii 

00:17:32.780 --> 00:17:41.670
中的meta创建一个新的文本文件，称为

00:17:38.520 --> 00:17:43.050
春天那个工厂，这是相同的

00:17:41.670 --> 00:17:44.370
机制相同的服务加载程序

00:17:43.050 --> 00:17:48.179
您可能熟悉的机制

00:17:44.370 --> 00:17:50.010
如果您曾经定义过自己的汽车

00:17:48.179 --> 00:17:53.640
配置正确，我们将看到

00:17:50.010 --> 00:17:55.320
应用程序上下文初始化程序等于

00:17:53.640 --> 00:18:00.210
我们需要为其提供参考

00:17:55.320 --> 00:18:03.330
我们的程序化定义

00:18:00.210 --> 00:18:05.580
初始化器正确，所以当它春天

00:18:03.330 --> 00:18:07.290
启动它将要调用此方法

00:18:05.580 --> 00:18:11.000
让我们确认一下是否这样做

00:18:07.290 --> 00:18:18.179
我们说系统点空气点打印线

00:18:11.000 --> 00:18:22.200
你好初始化器好吧，我们去了

00:18:18.179 --> 00:18:24.150
让我们运行仍然会失败的代码

00:18:22.200 --> 00:18:26.490
当然，但我们应该看到你好

00:18:24.150 --> 00:18:29.970
初始化器在那里啊，我们需要

00:18:26.490 --> 00:18:35.730
也恢复我们的测试，所以我们很生气

00:18:29.970 --> 00:18:40.410
是配置一好，我们可以说春天

00:18:35.730 --> 00:18:42.440
引导测试到此为止

00:18:40.410 --> 00:18:46.590
实际上，我们甚至不需要

00:18:42.440 --> 00:18:49.200
删除它好再开始再去

00:18:46.590 --> 00:18:50.309
你可以看到你好

00:18:49.200 --> 00:18:52.590
哪一个

00:18:50.309 --> 00:18:54.359
你好初始化正确，所以有

00:18:52.590 --> 00:18:56.340
肯定是春天开始了

00:18:54.359 --> 00:18:58.529
在单元测试以及

00:18:56.340 --> 00:19:00.779
在主要代码中，这是我们的工作

00:18:58.529 --> 00:19:03.029
以编程方式注册

00:19:00.779 --> 00:19:05.190
我们很在乎，所以这是一个不错的新API 

00:19:03.029 --> 00:19:07.200
再次以Java 8为中心的应用程序

00:19:05.190 --> 00:19:10.200
上下文应用程序上下文

00:19:07.200 --> 00:19:11.849
注册bean，我们可以告诉类型

00:19:10.200 --> 00:19:14.999
在这种情况下，我们要注册一个酒吧

00:19:11.849 --> 00:19:16.830
与之前相同的服务等级

00:19:14.999 --> 00:19:19.080
很好，我们也有这个好

00:19:16.830 --> 00:19:21.869
供应商基础机制正确，所以foo 

00:19:19.080 --> 00:19:25.919
服务等级，然后我们只说

00:19:21.869 --> 00:19:28.379
想返回一个新的飞行服务

00:19:25.919 --> 00:19:30.629
期待这里的酒吧服务很好

00:19:28.379 --> 00:19:32.359
你知道我们可以使用

00:19:30.629 --> 00:19:35.879
应用程序上下文并获得成功

00:19:32.359 --> 00:19:41.849
像这样肯定会工作

00:19:35.879 --> 00:19:46.679
让我们尝试一下，这是一个例子

00:19:41.849 --> 00:19:49.469
让我们看看是否可以正常测试

00:19:46.679 --> 00:19:53.429
绿色，但我们实际上可以做到这一点

00:19:49.469 --> 00:19:57.419
简单一点，我们可以说酒吧服务等于

00:19:53.429 --> 00:20:00.149
新酒吧服务真正的服务等于新的

00:19:57.419 --> 00:20:02.999
在酒吧服务中传递的服务以及

00:20:00.149 --> 00:20:04.879
确实是这些产品的供应商

00:20:02.999 --> 00:20:06.719
可以只返回预先实例化的

00:20:04.879 --> 00:20:08.909
参考，现在我们甚至不必

00:20:06.719 --> 00:20:10.259
您知道显式调用

00:20:08.909 --> 00:20:12.269
如果我们不从上下文中申请

00:20:10.259 --> 00:20:15.389
想要简单的代码

00:20:12.269 --> 00:20:18.059
不需要一定寿命的组件

00:20:15.389 --> 00:20:21.119
周期经理还是满意之前

00:20:18.059 --> 00:20:22.379
参考权，所以我是foo 

00:20:21.119 --> 00:20:24.809
服务直接引用了

00:20:22.379 --> 00:20:26.099
酒吧服务先于

00:20:24.809 --> 00:20:27.779
春季生态系统和春季

00:20:26.099 --> 00:20:29.700
应用程序上下文（如果有机会） 

00:20:27.779 --> 00:20:32.669
对其进行后期处理并感到满意

00:20:29.700 --> 00:20:35.009
依赖关系，但同样会读取

00:20:32.669 --> 00:20:37.169
有点容易，它有一个

00:20:35.009 --> 00:20:38.339
看起来像这样的代码的好处

00:20:37.169 --> 00:20:39.570
你在单元测试中写的是

00:20:38.339 --> 00:20:43.289
嘲笑你的图书馆，所以

00:20:39.570 --> 00:20:45.210
让我们看看那里现在是什么样子

00:20:43.289 --> 00:20:47.580
我们去，那么应用程序已经

00:20:45.210 --> 00:20:50.339
开始它是一个正在注册

00:20:47.580 --> 00:20:52.169
动态地现在这种机制

00:20:50.339 --> 00:20:54.149
现在我们有能力与

00:20:52.169 --> 00:20:56.369
一豆一物一类

00:20:54.149 --> 00:20:58.739
根据条件或其他

00:20:56.369 --> 00:21:01.349
动态状态，您已注册一个或

00:20:58.739 --> 00:21:03.910
更多的对象，这里您已经有了实际

00:21:01.349 --> 00:21:05.920
活着你知道电线

00:21:03.910 --> 00:21:09.520
这些不是定义， 

00:21:05.920 --> 00:21:11.440
不用担心一次内省

00:21:09.520 --> 00:21:12.610
反射元数据，而不是

00:21:11.440 --> 00:21:15.400
您实际上可以只是的实际对象

00:21:12.610 --> 00:21:16.690
使用对象图本身和

00:21:15.400 --> 00:21:18.970
当然你可以混合搭配

00:21:16.690 --> 00:21:22.270
没有理由我不能只是

00:21:18.970 --> 00:21:25.330
注释掉然后吃

00:21:22.270 --> 00:21:27.160
明确定义的服务以获取

00:21:25.330 --> 00:21:28.390
来自应用程序上下文的光束

00:21:27.160 --> 00:21:30.400
当然提供了定义

00:21:28.390 --> 00:21:32.170
通过其他一些机制

00:21:30.400 --> 00:21:34.630
组件扫描或Java配置

00:21:32.170 --> 00:21:38.140
或梁定义注册表

00:21:34.630 --> 00:21:40.810
处理器，因此我们已经研究了

00:21:38.140 --> 00:21:42.940
几种不同的方式来记录光束和

00:21:40.810 --> 00:21:45.370
与我们查看的应用程序上下文

00:21:42.940 --> 00:21:47.140
 Java 8的一些不错的功能

00:21:45.370 --> 00:21:48.400
特别是这里的支持

00:21:47.140 --> 00:21:53.650
使用

00:21:48.400 --> 00:21:55.300
供应商和春季支持

00:21:53.650 --> 00:21:57.960
五为使用我们注册的光束

00:21:55.300 --> 00:22:01.090
方法也使用供应商的权利，所以

00:21:57.960 --> 00:22:03.870
非常感谢您的收看和

00:22:01.090 --> 00:22:03.870
下次见

