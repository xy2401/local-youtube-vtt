WEBVTT
Kind: captions
Language: zh-Hans

00:00:26.200 --> 00:00:30.410
欢迎来到春季的另一期

00:00:28.490 --> 00:00:33.020
今天的分期付款技巧

00:00:30.410 --> 00:00:35.570
看项目即兴和春天的云

00:00:33.020 --> 00:00:37.250
功能项目riff是一个新项目

00:00:35.570 --> 00:00:40.220
从关键到它是一个开源项目

00:00:37.250 --> 00:00:44.140
我们从去年开始

00:00:40.220 --> 00:00:46.580
提供功能作为服务运行时

00:00:44.140 --> 00:00:48.739
服务即功能已变得非常

00:00:46.580 --> 00:00:51.950
最近很受欢迎，因为他们

00:00:48.739 --> 00:00:55.010
提供更简洁的内容

00:00:51.950 --> 00:00:55.930
的简化部署模型

00:00:55.010 --> 00:00:58.780
功能性

00:00:55.930 --> 00:01:02.330
记住所有事物

00:00:58.780 --> 00:01:04.190
经济学指导建筑，所以我们

00:01:02.330 --> 00:01:05.960
看到很多人希望得到平衡

00:01:04.190 --> 00:01:07.550
更加敏捷，他们发现了一些

00:01:05.960 --> 00:01:09.590
他们设法描述的工作量

00:01:07.550 --> 00:01:12.110
某些工作量非常

00:01:09.590 --> 00:01:13.850
消息输出样式中的简单消息

00:01:12.110 --> 00:01:17.540
语义，我认为这实际上是

00:01:13.850 --> 00:01:20.960
真的很有趣

00:01:17.540 --> 00:01:22.340
我们周围的人

00:01:20.960 --> 00:01:25.010
足够长的时间可能会记住

00:01:22.340 --> 00:01:26.720
任职后勤办公室的想法，你

00:01:25.010 --> 00:01:29.450
有不属于热门的工作

00:01:26.720 --> 00:01:31.520
前端网的路径

00:01:29.450 --> 00:01:33.530
应用所需的工作

00:01:31.520 --> 00:01:35.210
完成可能需要更长的时间

00:01:33.530 --> 00:01:36.979
比例如的毫秒数

00:01:35.210 --> 00:01:39.530
您可以负担给定的要求

00:01:36.979 --> 00:01:41.390
响应，通常是历史记录

00:01:39.530 --> 00:01:43.820
传统上，这项工作本来是

00:01:41.390 --> 00:01:45.469
就排队给你来说，所以你

00:01:43.820 --> 00:01:46.969
本来可以把它放在一个

00:01:45.469 --> 00:01:49.789
排队，然后进行处理

00:01:46.969 --> 00:01:53.180
适当的权利，这是你

00:01:49.789 --> 00:01:55.039
知道这个想法听起来很简单

00:01:53.180 --> 00:01:55.969
是人们的根本原因

00:01:55.039 --> 00:01:58.189
必须开始思考

00:01:55.969 --> 00:02:00.409
建筑而不仅仅是耕作

00:01:58.189 --> 00:02:03.049
一切都变成一个巨大的Web应用程序

00:02:00.409 --> 00:02:05.119
对于很多人来说

00:02:03.049 --> 00:02:07.579
集成这是消息这是

00:02:05.119 --> 00:02:09.590
从他们身上出来的世界

00:02:07.579 --> 00:02:10.820
需要能够做一些事情

00:02:09.590 --> 00:02:13.670
花一点时间

00:02:10.820 --> 00:02:16.490
异步的东西，所以这整个

00:02:13.670 --> 00:02:17.870
世界这整个事物的现象

00:02:16.490 --> 00:02:20.600
我需要做的事情需要发生

00:02:17.870 --> 00:02:24.470
最终或不一定如此

00:02:20.600 --> 00:02:26.000
第二个仍然在那里

00:02:24.470 --> 00:02:29.030
我们当然有一些很好的

00:02:26.000 --> 00:02:30.800
解决这个问题的原语

00:02:29.030 --> 00:02:32.540
在早期的分期付款中

00:02:30.800 --> 00:02:35.480
春天的技巧，我们已经看过春天

00:02:32.540 --> 00:02:38.569
整合和Spring Cloud Stream和

00:02:35.480 --> 00:02:42.550
春季云数据流现在已满

00:02:38.569 --> 00:02:46.400
圈子中的云提供商现在有了一个

00:02:42.550 --> 00:02:48.319
离散单元建模的方法

00:02:46.400 --> 00:02:49.459
功能作为一个单一的功能和

00:02:48.319 --> 00:02:51.800
当他们说一个功能时，他们不是

00:02:49.459 --> 00:02:54.260
实际上是在谈论一个

00:02:51.800 --> 00:02:55.989
以语言为中心的功能概念

00:02:54.260 --> 00:02:59.510
但是相反，这东西需要

00:02:55.989 --> 00:03:01.069
参数，然后返回输出，因此它

00:02:59.510 --> 00:03:04.670
数据输入非常非常简单

00:03:01.069 --> 00:03:06.019
概念，如果您推断的话

00:03:04.670 --> 00:03:07.849
够了，这是一个可以

00:03:06.019 --> 00:03:11.239
扩展到多种语言并运行

00:03:07.849 --> 00:03:15.799
时间不只是Java或JavaScript或

00:03:11.239 --> 00:03:19.879
或类似的东西，所以你你

00:03:15.799 --> 00:03:20.569
你知道吗，请注意亚马逊的

00:03:19.879 --> 00:03:22.580
土地

00:03:20.569 --> 00:03:26.299
亚马逊的lambda是一个可疑的lambda是

00:03:22.580 --> 00:03:28.310
一个用于在其中部署功能的运行时

00:03:26.299 --> 00:03:32.540
某些语言并非所有语言

00:03:28.310 --> 00:03:35.959
运行时将启动一个实例

00:03:32.540 --> 00:03:38.480
您的应用程序和参数

00:03:35.959 --> 00:03:39.980
请求豌 bean 有效载荷被发送

00:03:38.480 --> 00:03:41.390
对那个功能对那个功能

00:03:39.980 --> 00:03:44.599
给您的功能一个运行的机会， 

00:03:41.390 --> 00:03:50.030
然后（可选）发送回复

00:03:44.599 --> 00:03:52.549
为此它将响应输出

00:03:50.030 --> 00:03:54.370
赋予另一个功能和结果

00:03:52.549 --> 00:03:57.409
是你可以一起改变事物

00:03:54.370 --> 00:03:59.510
我认为这可以说是第一个

00:03:57.409 --> 00:04:00.920
非常成功的流行功能

00:03:59.510 --> 00:04:03.079
服务运行时，但绝不是

00:04:00.920 --> 00:04:04.819
此时只有一个大

00:04:03.079 --> 00:04:06.860
三个在这里的空间

00:04:04.819 --> 00:04:10.549
 Google和我们所有人都非常

00:04:06.860 --> 00:04:11.840
竞争产品，现在有

00:04:10.549 --> 00:04:14.000
许多不同的开源

00:04:11.840 --> 00:04:14.689
运行时也是如此，显然

00:04:14.000 --> 00:04:18.560
打开拂尘

00:04:14.689 --> 00:04:20.930
这是运行时的开源

00:04:18.560 --> 00:04:22.400
那个甲骨文是什么

00:04:20.930 --> 00:04:23.780
刚刚达到一个甲骨文

00:04:22.400 --> 00:04:25.370
还有一个，所以有很多

00:04:23.780 --> 00:04:28.490
我们有一个不同的选择

00:04:25.370 --> 00:04:30.680
项目riff当然是riff 

00:04:28.490 --> 00:04:32.660
功能就是说即兴

00:04:30.680 --> 00:04:35.420
对于功能，即即兴

00:04:32.660 --> 00:04:37.940
是形式，它是递归的首字母缩写

00:04:35.420 --> 00:04:39.590
朋友，那一定是递归的

00:04:37.940 --> 00:04:42.680
首字母缩写词，否则它不会很酷

00:04:39.590 --> 00:04:48.080
我们有一个功能作为服务运行时

00:04:42.680 --> 00:04:49.729
且riff是一个多语言函数

00:04:48.080 --> 00:04:51.050
就像Cloud Foundry一样的服务运行时

00:04:49.729 --> 00:04:54.289
是一个多语种

00:04:51.050 --> 00:04:57.530
平台即服务和目标

00:04:54.289 --> 00:05:00.020
是为了支持部署和

00:04:57.530 --> 00:05:01.970
离散单位中的功能生命周期

00:05:00.020 --> 00:05:05.060
可以想到的功能

00:05:01.970 --> 00:05:06.409
作为功​​能，拥有

00:05:05.060 --> 00:05:09.229
这种区别实际上不是

00:05:06.409 --> 00:05:11.120
一定是语言级别的功能

00:05:09.229 --> 00:05:13.879
好吧，我们可以支持例如一批

00:05:11.120 --> 00:05:15.199
脚本或Shell脚本权利以及这些

00:05:13.879 --> 00:05:16.639
 Shell脚本可以接受参数和

00:05:15.199 --> 00:05:19.819
他们可以复制输出，因此标准

00:05:16.639 --> 00:05:22.699
标准输出RIF建立在

00:05:19.819 --> 00:05:25.490
 kubernetes这是一个部署它是一个

00:05:22.699 --> 00:05:27.050
在资源方面实施

00:05:25.490 --> 00:05:29.719
 kubernetes我们引入了一些新的

00:05:27.050 --> 00:05:33.680
资源之一是一个主题， 

00:05:29.719 --> 00:05:37.759
另一个是功能，您可以

00:05:33.680 --> 00:05:40.610
在任何kunas实例上管理riff 

00:05:37.759 --> 00:05:43.490
显然我们有一个PKS是kuben 

00:05:40.610 --> 00:05:47.150
是关键的kubernetes服务

00:05:43.490 --> 00:05:49.219
我认为运行时非常合适

00:05:47.150 --> 00:05:51.409
因为它可以很好地与云一起使用

00:05:49.219 --> 00:05:55.669
资金，但同样可以

00:05:51.409 --> 00:05:57.020
任何东西，所以我有即兴和kubernetes 

00:05:55.669 --> 00:05:58.789
在我的本地计算机上安装了文档

00:05:57.020 --> 00:06:00.949
这是非常彻底的

00:05:58.789 --> 00:06:03.259
安装riff的不同方法

00:06:00.949 --> 00:06:04.759
 Mac版Windows Mini Cube的docker 

00:06:03.259 --> 00:06:06.650
在您的本地虚拟机上

00:06:04.759 --> 00:06:08.630
我在这里的Linux盒子上使用的是什么

00:06:06.650 --> 00:06:11.599
当然Google Cloud Google容器

00:06:08.630 --> 00:06:13.550
引擎良好的Google kubernetes引擎

00:06:11.599 --> 00:06:15.620
在Google上所有这些都很好

00:06:13.550 --> 00:06:18.349
选择，再到其他任何地方

00:06:15.620 --> 00:06:20.840
工作正常，但安装

00:06:18.349 --> 00:06:22.430
没有那么复杂的要旨

00:06:20.840 --> 00:06:24.409
是你必须得到小茴香

00:06:22.430 --> 00:06:26.960
安装并以某种方式运行

00:06:24.409 --> 00:06:28.789
使用迷你立方体这很容易

00:06:26.960 --> 00:06:31.190
评估迷你立方体变暗

00:06:28.789 --> 00:06:33.110
环境，然后最后您使用

00:06:31.190 --> 00:06:35.930
 helm helm是以下产品的包装经理

00:06:33.110 --> 00:06:38.539
 kubernetes，所以使用掌舵我们部署我们

00:06:35.930 --> 00:06:41.750
将项目RIF分发为头盔图

00:06:38.539 --> 00:06:44.120
然后可以使用，一旦

00:06:41.750 --> 00:06:45.770
完成安装Kafka之后，您

00:06:44.120 --> 00:06:46.009
等待事物旋转起来，在那里

00:06:45.770 --> 00:06:48.110
是

00:06:46.009 --> 00:06:50.240
您有一个可以正常运行的运行时

00:06:48.110 --> 00:06:52.310
那么您唯一需要的就是CLI，因此

00:06:50.240 --> 00:06:54.169
您可以下载该CLI，然后

00:06:52.310 --> 00:06:56.870
安装调用者和这些调用者的

00:06:54.169 --> 00:06:58.340
是真正调用您的东西的东西

00:06:56.870 --> 00:07:00.279
正确的功能是

00:06:58.340 --> 00:07:03.289
在集装箱中运行的小车

00:07:00.279 --> 00:07:04.580
从队列中取出消息

00:07:03.289 --> 00:07:07.460
这种情况下卡夫卡

00:07:04.580 --> 00:07:09.410
然后为他们执行您的功能

00:07:07.460 --> 00:07:11.900
如果您的功能运行不正确，如果

00:07:09.410 --> 00:07:13.670
您还没有运行它，那么这辆挎斗车

00:07:11.900 --> 00:07:16.550
确保有一个实例

00:07:13.670 --> 00:07:19.070
可以处理它，如果有的话

00:07:16.550 --> 00:07:20.750
如果您发送一个请求，则不再有流量

00:07:19.070 --> 00:07:25.780
然后等待十五秒

00:07:20.750 --> 00:07:27.890
默认超时，那么您将获得一个

00:07:25.780 --> 00:07:29.360
您会看到该功能将

00:07:27.890 --> 00:07:31.280
缩小到零，您将得到零

00:07:29.360 --> 00:07:33.710
运行该函数的实例，如果

00:07:31.280 --> 00:07:34.790
但是有连续的请求

00:07:33.710 --> 00:07:37.340
有连续的请求

00:07:34.790 --> 00:07:40.280
发生在15秒间隔内

00:07:37.340 --> 00:07:42.230
同一张图片将被重新使用

00:07:40.280 --> 00:07:44.870
那些连续的多次调用

00:07:42.230 --> 00:07:48.020
如果您有大量的洪水

00:07:44.870 --> 00:07:50.680
无法有效处理的流量

00:07:48.020 --> 00:07:53.390
处理就是说你有空

00:07:50.680 --> 00:07:55.190
下来然后运行时将

00:07:53.390 --> 00:07:57.290
根据需要扩大规模，将扩大规模

00:07:55.190 --> 00:07:58.850
两个实例5个100 

00:07:57.290 --> 00:08:00.590
需要什么才能

00:07:58.850 --> 00:08:02.840
满足需求，然后最终

00:08:00.590 --> 00:08:05.510
正如我说的那样，它将缩小为零

00:08:02.840 --> 00:08:07.070
实例，这就是供应商在什么时候的意思

00:08:05.510 --> 00:08:09.590
他们说功能有一定

00:08:07.070 --> 00:08:12.890
时间或服务运行时间缩放为零

00:08:09.590 --> 00:08:15.200
当然扩展到

00:08:12.890 --> 00:08:18.200
零是你将不得不

00:08:15.200 --> 00:08:19.670
正确支付冷启动税，所以接下来

00:08:18.200 --> 00:08:21.260
有要求的时候

00:08:19.670 --> 00:08:23.900
启动具有您的图像

00:08:21.260 --> 00:08:25.610
功能包括边车和

00:08:23.900 --> 00:08:26.660
然后等它旋转好

00:08:25.610 --> 00:08:28.940
这意味着如果您正在运行

00:08:26.660 --> 00:08:29.720
 Python函数或Java函数或

00:08:28.940 --> 00:08:31.190
管他呢

00:08:29.720 --> 00:08:33.560
那么你必须等待那个运行时

00:08:31.190 --> 00:08:36.430
正确开始，这就是我的目的

00:08:33.560 --> 00:08:39.050
这就是为什么我认为这些都是理想的

00:08:36.430 --> 00:08:43.460
适合后勤工作

00:08:39.050 --> 00:08:45.170
第二个启动税不是这样

00:08:43.460 --> 00:08:46.730
有问题的，尤其是因为我们知道

00:08:45.170 --> 00:08:48.560
结果会到来，只是没有

00:08:46.730 --> 00:08:52.640
一定会马上来

00:08:48.560 --> 00:08:55.130
被排在队列中

00:08:52.640 --> 00:08:57.170
不会因为你而丢失大量数据

00:08:55.130 --> 00:08:58.700
有那些队列，让我们继续前进， 

00:08:57.170 --> 00:09:00.890
看看这个，让我们继续

00:08:58.700 --> 00:09:04.040
现在看一些简单的例子

00:09:00.890 --> 00:09:06.260
请记住，这是一个多多

00:09:04.040 --> 00:09:08.200
语言运行时多平台运行时

00:09:06.260 --> 00:09:10.310
从这些不同中可以看到

00:09:08.200 --> 00:09:12.440
调用者在这里有支持

00:09:10.310 --> 00:09:15.710
对于命令，这些是shell脚本

00:09:12.440 --> 00:09:18.020
知道bin sh shell脚本就可以了

00:09:15.710 --> 00:09:18.300
知道他们会用Java语言

00:09:18.020 --> 00:09:19.620
唯一的那个

00:09:18.300 --> 00:09:22.740
我们将大部分时间都花在

00:09:19.620 --> 00:09:24.960
今天的节点是一个nodejs，然后是

00:09:22.740 --> 00:09:26.190
当然是Python 3，所以这些都是我们的

00:09:24.960 --> 00:09:31.650
盒子的支持，它不会

00:09:26.190 --> 00:09:33.540
很难添加更多的支持

00:09:31.650 --> 00:09:34.920
运行时本身写在正确的位置

00:09:33.540 --> 00:09:36.960
所以我们有很多不同的选择

00:09:34.920 --> 00:09:39.510
这里有很多不同的支持

00:09:36.960 --> 00:09:40.380
技术还不错，让我们继续前进， 

00:09:39.510 --> 00:09:41.700
开始，我们将继续前进， 

00:09:40.380 --> 00:09:43.170
刚开始非常简单

00:09:41.700 --> 00:09:45.060
我在后台的例子

00:09:43.170 --> 00:09:46.380
 Coop的细节在手表上

00:09:45.060 --> 00:09:48.930
每1秒刷新一次

00:09:46.380 --> 00:09:50.130
 Coop的细节或双门轿跑车拥抱

00:09:48.930 --> 00:09:52.080
部署以获取所有

00:09:50.130 --> 00:09:54.180
正确的名称空间，所以我

00:09:52.080 --> 00:09:56.910
实际上会有所不同

00:09:54.180 --> 00:09:59.190
在这里，我将运行演示，它将向我展示

00:09:56.910 --> 00:10:00.840
对我来说，功能更多

00:09:59.190 --> 00:10:02.610
部署和暂停都可以

00:10:00.840 --> 00:10:06.080
你可以看到我什么都没有

00:10:02.610 --> 00:10:12.420
也有了RIF CLI，让我们评估一下

00:10:06.080 --> 00:10:14.670
迷你立方体docker env首先要做

00:10:12.420 --> 00:10:16.110
确保我们的Docker上下文指向

00:10:14.670 --> 00:10:19.770
到正确的时间和地点

00:10:16.110 --> 00:10:21.810
我会说重复列表

00:10:19.770 --> 00:10:23.100
现在什么都没有了

00:10:21.810 --> 00:10:24.480
我的目录中什么也没有

00:10:23.100 --> 00:10:25.560
我要去吧，我们去吧

00:10:24.480 --> 00:10:29.280
并建立一个非常非常简单的例子

00:10:25.560 --> 00:10:30.960
我们将从根本上开始

00:10:29.280 --> 00:10:32.760
我有点神圣的例子

00:10:30.960 --> 00:10:34.740
知道，但我们要去做，因为我

00:10:32.760 --> 00:10:35.610
想要我想要很多

00:10:34.740 --> 00:10:37.740
这里有不同的选择，所以我们要

00:10:35.610 --> 00:10:39.960
在创建示例时提起诉讼

00:10:37.740 --> 00:10:41.760
你知道一个非常非常非常

00:10:39.960 --> 00:10:45.270
简单的例子将扭转

00:10:41.760 --> 00:10:52.020
一串好吧，所以反向，我们要

00:10:45.270 --> 00:10:56.670
创建一个反向j / s文件，它只会

00:10:52.020 --> 00:10:59.370
成为节点模块，以便模块点导出

00:10:56.670 --> 00:11:01.220
等于我得到的字符串lambda语法

00:10:59.370 --> 00:11:03.240
搞混了，因为它是一个

00:11:01.220 --> 00:11:05.040
与Kaufmann和Java不同，但

00:11:03.240 --> 00:11:07.140
它类似于Scala，然后我们

00:11:05.040 --> 00:11:08.760
要拿进来的弦

00:11:07.140 --> 00:11:09.870
拆分它，我们正在做的是

00:11:08.760 --> 00:11:11.310
在这里创建一个lambda，所以

00:11:09.870 --> 00:11:13.770
输入是将要使用的字符串

00:11:11.310 --> 00:11:15.270
从客户端和客户端发送的

00:11:13.770 --> 00:11:17.100
方式将发布到函数

00:11:15.270 --> 00:11:19.620
服务网关HTTP网关

00:11:17.100 --> 00:11:21.930
这就是消息到达的方式

00:11:19.620 --> 00:11:24.150
系统，这样您就无法控制

00:11:21.930 --> 00:11:25.950
您无法控制的URL 

00:11:24.150 --> 00:11:27.720
任何人的地址能力

00:11:25.950 --> 00:11:29.920
特定功能就是它

00:11:27.720 --> 00:11:31.209
是又是这个

00:11:29.920 --> 00:11:33.040
我为什么要用这个来回

00:11:31.209 --> 00:11:34.660
在后台的东西

00:11:33.040 --> 00:11:37.420
工作，所以我要把弦和

00:11:34.660 --> 00:11:38.829
用空引号将其拆分，我会说这是

00:11:37.420 --> 00:11:39.790
会变成一个数组，每个数组都需要

00:11:38.829 --> 00:11:41.079
字符

00:11:39.790 --> 00:11:42.519
它会把每个角色都变成

00:11:41.079 --> 00:11:44.589
放入另一个数组中的元素中， 

00:11:42.519 --> 00:11:46.029
在一个数组中，然后我将反转

00:11:44.589 --> 00:11:46.779
数组，然后我将加入整个

00:11:46.029 --> 00:11:49.750
一起回来

00:11:46.779 --> 00:11:50.920
像这样再小例子

00:11:49.750 --> 00:11:53.350
它确实证明了我们正在努力

00:11:50.920 --> 00:11:54.699
做，现在我们在这里有这个文件

00:11:53.350 --> 00:11:58.660
目录称为反向，所以我想

00:11:54.699 --> 00:12:02.050
说riff创建节点，所以我要创建

00:11:58.660 --> 00:12:05.459
节点功能，并再次牢记

00:12:02.050 --> 00:12:11.880
我们将创建一个名为

00:12:05.459 --> 00:12:16.750
反向，我们希望这个功能是

00:12:11.880 --> 00:12:18.100
可在输入kafka主题上解决

00:12:16.750 --> 00:12:21.610
叫反向，所以每当有人

00:12:18.100 --> 00:12:23.320
将有效载荷发送到反向主题

00:12:21.610 --> 00:12:25.149
它会结束我们的功能，所以我

00:12:23.320 --> 00:12:27.550
现在将那个输入主题叫作反向

00:12:25.149 --> 00:12:29.769
我们可以指定一个输出主题

00:12:27.550 --> 00:12:31.420
我们会在一分钟内看到，但对于我们

00:12:29.769 --> 00:12:34.750
目的是Spice相信的是

00:12:31.420 --> 00:12:37.959
所以要说创建名为reverse的节点

00:12:34.750 --> 00:12:39.670
输入反向，文件路径为

00:12:37.959 --> 00:12:42.730
等于这个好吧，那会

00:12:39.670 --> 00:12:46.570
创建许多不同的工件

00:12:42.730 --> 00:12:49.930
在这里您可以看到我们有一个码头工人

00:12:46.570 --> 00:12:51.640
描述我们功能的文件

00:12:49.930 --> 00:12:53.050
可以看到docker文件确实是

00:12:51.640 --> 00:12:54.880
只是一个简单的医生父亲从

00:12:53.050 --> 00:12:57.459
节点函数调用者添加了

00:12:54.880 --> 00:13:00.490
小脚本并提供功能

00:12:57.459 --> 00:13:02.230
 URL正常和okra的节点功能

00:13:00.490 --> 00:13:04.779
会知道看看这个功能， 

00:13:02.230 --> 00:13:06.820
调用它，然后输出

00:13:04.779 --> 00:13:08.860
并将其放在输出卡夫卡上

00:13:06.820 --> 00:13:10.930
排队或将其作为

00:13:08.860 --> 00:13:12.100
如果您喜欢的话，请回复

00:13:10.930 --> 00:13:14.800
这个然后你可以看到那里

00:13:12.100 --> 00:13:16.240
 kubernetes llamo文件的配置文件

00:13:14.800 --> 00:13:18.510
他们在这里做不同的资源

00:13:16.240 --> 00:13:21.279
特别是你有反向主题

00:13:18.510 --> 00:13:23.140
没错，就是凯夫卡

00:13:21.279 --> 00:13:26.589
没事我通常不会

00:13:23.140 --> 00:13:28.690
通常不得不搞混，但是

00:13:26.589 --> 00:13:30.790
如果你想要它就在那里，然后反向

00:13:28.690 --> 00:13:32.350
功能llamo这要多一点

00:13:30.790 --> 00:13:35.110
有趣，所以你可以在这里看到

00:13:32.350 --> 00:13:36.339
这是你知道的很简单

00:13:35.110 --> 00:13:38.529
我们稍后会看到

00:13:36.339 --> 00:13:41.050
有时很有用

00:13:38.529 --> 00:13:42.850
此节中的此容器段

00:13:41.050 --> 00:13:43.720
在这里，但基本上我们是说这是

00:13:42.850 --> 00:13:45.730
一个功能

00:13:43.720 --> 00:13:49.030
输入将要输入

00:13:45.730 --> 00:13:52.330
您知道的G RPC协议上

00:13:49.030 --> 00:13:56.440
函数调用程序将trpc2讲给

00:13:52.330 --> 00:13:57.850
该功能，您知道它被打开了

00:13:56.440 --> 00:13:59.530
进入我们可以识别的有效载荷

00:13:57.850 --> 00:14:01.540
您可以与之合作，就是这样

00:13:59.530 --> 00:14:03.460
对，那是所有东西的总和

00:14:01.540 --> 00:14:05.650
让我们看看整个事情，现在，如果你

00:14:03.460 --> 00:14:06.790
即兴演奏列表，您可以看到我们有一个

00:14:05.650 --> 00:14:09.130
功能在那里，所以让我们继续

00:14:06.790 --> 00:14:12.100
尝试发布结果或请求

00:14:09.130 --> 00:14:14.770
宁可继续拼写

00:14:12.100 --> 00:14:17.410
输入，但所有这些不同

00:14:14.770 --> 00:14:20.080
您可以使用I和n的命令，所以我是

00:14:17.410 --> 00:14:22.600
输入和他的名字在这里我只需要

00:14:20.080 --> 00:14:24.370
因为我正在发送请求，所以我只需要

00:14:22.600 --> 00:14:27.220
指定输入卡夫卡

00:14:24.370 --> 00:14:30.430
我想要请求的Kafka主题

00:14:27.220 --> 00:14:32.710
到达所以我会说即兴发布和

00:14:30.430 --> 00:14:37.560
然后我们叫这个他们叫这个

00:14:32.710 --> 00:14:43.210
反向对，它就在那里

00:14:37.560 --> 00:14:46.060
在此命名，然后反向，然后我们将

00:14:43.210 --> 00:14:49.300
指定一些有效载荷一些数据，所以我们将

00:14:46.060 --> 00:14:50.530
打个招呼世界，然后我们

00:14:49.300 --> 00:14:52.090
要说我们要回应

00:14:50.530 --> 00:14:55.420
如果我们不指定回应，请回来

00:14:52.090 --> 00:14:56.380
减R或您知道期待答复，如果

00:14:55.420 --> 00:14:57.850
我们没有指定它将是

00:14:56.380 --> 00:14:59.440
一劳永逸，将其发送过来

00:14:57.850 --> 00:15:02.410
咖啡杯队列，它将

00:14:59.440 --> 00:15:03.520
在可能的情况下尽快交付但我

00:15:02.410 --> 00:15:05.380
想要我想看到的回应

00:15:03.520 --> 00:15:07.990
结果，所以我将等待该响应

00:15:05.380 --> 00:15:09.580
好吧，所以我们

00:15:07.990 --> 00:15:12.760
这是我们非常简单的世界

00:15:09.580 --> 00:15:14.890
再次不使用摘要的示例

00:15:12.760 --> 00:15:16.210
有点慢，很明显，有点

00:15:14.890 --> 00:15:19.060
慢，第一次是第一次

00:15:16.210 --> 00:15:21.730
发送请求，但如果我们做得足够

00:15:19.060 --> 00:15:23.650
时代，你会看到这是一个相当

00:15:21.730 --> 00:15:25.750
快速写结果，这将

00:15:23.650 --> 00:15:26.980
 Kafka队列命中功能被放置

00:15:25.750 --> 00:15:29.080
回到Kafka队列并发送回去

00:15:26.980 --> 00:15:31.930
我们做到了，您知道它已经发送了

00:15:29.080 --> 00:15:34.300
到或通过heb网关再返回

00:15:31.930 --> 00:15:36.730
你知道作为HTTP所有

00:15:34.300 --> 00:15:39.070
再等几秒钟

00:15:36.730 --> 00:15:40.900
但是如果我们等15秒钟才能成为

00:15:39.070 --> 00:15:42.010
精确，那么我们可以提出您的要求

00:15:40.900 --> 00:15:43.300
看到我们必须等待它旋转

00:15:42.010 --> 00:15:45.520
在这里，你可以看到它正在做

00:15:43.300 --> 00:15:50.250
在这里，您可以看到它旋转了

00:15:45.520 --> 00:15:52.510
你知道我们想要的那样

00:15:50.250 --> 00:15:54.100
好吧，现在我们有了反向功能

00:15:52.510 --> 00:15:57.839
这是一个节点，让我们继续进行创建

00:15:54.100 --> 00:16:01.199
 Java版本，因此在这里我们可以

00:15:57.839 --> 00:16:04.079
春天云功能现在春天云

00:16:01.199 --> 00:16:05.189
函数是来自的新项目

00:16:04.079 --> 00:16:08.730
Spring Cloud团队有

00:16:05.189 --> 00:16:10.649
不幸的是，还没有复选框

00:16:08.730 --> 00:16:12.329
在初始化器上，但是我有一个

00:16:10.649 --> 00:16:15.180
怀疑一个月后会在那里

00:16:12.329 --> 00:16:17.610
所以我们需要的是我的想法

00:16:15.180 --> 00:16:19.170
龙目岛的目的也许你可以使用

00:16:17.610 --> 00:16:20.220
再次使用任何语言在JVM上进行任何操作

00:16:19.170 --> 00:16:21.720
在任何地方都可以正常工作

00:16:20.220 --> 00:16:23.639
可以与之合作的Springwood包括

00:16:21.720 --> 00:16:27.360
例如Scala就可以了

00:16:23.639 --> 00:16:29.610
但是我们将其保留在Java中

00:16:27.360 --> 00:16:31.800
因为这很简单

00:16:29.610 --> 00:16:32.639
例子，所以我们将点击generate以及

00:16:31.800 --> 00:16:34.439
我们要做的是

00:16:32.639 --> 00:16:35.939
接受反向字符串的函数

00:16:34.439 --> 00:16:37.170
和大写字母，我们要

00:16:35.939 --> 00:16:38.550
将字符串大写，然后将其发送到

00:16:37.170 --> 00:16:42.769
另一个世界或相反

00:16:38.550 --> 00:16:45.089
功能，所以现在我已经大写了， 

00:16:42.769 --> 00:16:47.550
我要添加Spring Cloud功能

00:16:45.089 --> 00:16:49.470
现在它的春天云功能就像我

00:16:47.550 --> 00:16:50.699
说这是一个新项目，其目的是

00:16:49.470 --> 00:16:52.920
允许您编写函数，然后

00:16:50.699 --> 00:16:55.350
使它们适应不同的功能

00:16:52.920 --> 00:16:58.170
项目riff的服务运行时

00:16:55.350 --> 00:16:59.459
只是一个所以这是一个很好

00:16:58.170 --> 00:17:01.319
技术让我拥有

00:16:59.459 --> 00:17:03.329
我是一个github我可以链接到它

00:17:01.319 --> 00:17:05.850
和有关此示例的自述文件

00:17:03.329 --> 00:17:07.709
春季-有关github的技巧，您将看到

00:17:05.850 --> 00:17:09.209
为此的代码我有一个例子

00:17:07.709 --> 00:17:13.370
例如使用spring俱乐部功能

00:17:09.209 --> 00:17:15.329
部署您知道网关

00:17:13.370 --> 00:17:16.919
端点，函数本身以及所有

00:17:15.329 --> 00:17:19.620
 ATM需要的其他东西

00:17:16.919 --> 00:17:21.059
是lambda，所以使用起来很繁琐

00:17:19.620 --> 00:17:23.309
本机注册，因为lambda需要

00:17:21.059 --> 00:17:25.350
您在所有这些额外的类型

00:17:23.309 --> 00:17:27.899
工艺路径，以便它起作用

00:17:25.350 --> 00:17:30.750
洒水功能的目标是

00:17:27.899 --> 00:17:33.750
尽可能地适应您的功能

00:17:30.750 --> 00:17:34.830
可能来自基础或运行时

00:17:33.750 --> 00:17:36.570
或代理商从中解脱

00:17:34.830 --> 00:17:38.490
基础运行时，同时允许

00:17:36.570 --> 00:17:40.080
保持便携性，因此再次使用

00:17:38.490 --> 00:17:41.460
适配器和合适的专家

00:17:40.080 --> 00:17:43.080
配置可以使用此代码

00:17:41.460 --> 00:17:46.169
我们现在要在这里写

00:17:43.080 --> 00:17:49.200
最终与您一起了解更多

00:17:46.169 --> 00:17:51.179
配置使其可以在团队中工作

00:17:49.200 --> 00:17:52.200
花钱，这不是考虑

00:17:51.179 --> 00:17:54.120
因为春天是必需的

00:17:52.200 --> 00:17:57.299
由于davis lambda而配置

00:17:54.120 --> 00:18:01.620
这实际上是非常乏味的ATM 

00:17:57.299 --> 00:18:04.230
是lambda的一种易于使用的5 

00:18:01.620 --> 00:18:07.440
分钟演示用例，您将在其中记录

00:18:04.230 --> 00:18:09.330
在您上传jar时，点击部署单击

00:18:07.440 --> 00:18:10.500
复选框或两个或十个，您会得到一个

00:18:09.330 --> 00:18:11.490
网关，您可以请求

00:18:10.500 --> 00:18:13.070
门户但是

00:18:11.490 --> 00:18:15.330
想要自动化，然后得到

00:18:13.070 --> 00:18:17.220
特别沉重，所以我不会

00:18:15.330 --> 00:18:19.830
浪费下一个小时试图全力以赴

00:18:17.220 --> 00:18:21.780
在这里为我们所做的，你知道，因为我

00:18:19.830 --> 00:18:23.700
真的不是我不在乎，然后

00:18:21.780 --> 00:18:25.230
我们有派对旅行，这很简单

00:18:23.700 --> 00:18:30.450
所以我们要做的就是添加

00:18:25.230 --> 00:18:30.929
春天的云功能，它会做

00:18:30.450 --> 00:18:34.130
休息

00:18:30.929 --> 00:18:36.300
所以春天云功能依赖我

00:18:34.130 --> 00:18:37.559
如果您在我的本地课程路径中有这个

00:18:36.300 --> 00:18:40.730
不在您当地的课程路径中

00:18:37.559 --> 00:18:42.780
您将添加您需要添加行家

00:18:40.730 --> 00:18:43.410
春天的快照存储库，所以

00:18:42.780 --> 00:18:45.720
春天那个IO 

00:18:43.410 --> 00:18:46.650
你知道那儿在那里，是的，如果你

00:18:45.720 --> 00:18:48.900
去开始IO和

00:18:46.650 --> 00:18:51.000
为亚当选择快照

00:18:48.900 --> 00:18:52.470
自动为您添加它，但我没有

00:18:51.000 --> 00:18:55.800
我需要忘记这样做

00:18:52.470 --> 00:18:57.390
物质仍然起作用类型等于手掌

00:18:55.800 --> 00:18:59.070
好吧，所以我们在那里

00:18:57.390 --> 00:19:01.350
我需要的依赖项

00:18:59.070 --> 00:19:03.360
您不需要存储库的依赖项

00:19:01.350 --> 00:19:06.540
如果您从未用过，请添加节

00:19:03.360 --> 00:19:09.410
这个，最后我要走了

00:19:06.540 --> 00:19:14.309
提前添加spring-cloud-function

00:19:09.410 --> 00:19:17.850
入门网站好吧就是网站

00:19:14.309 --> 00:19:21.510
 Web对其的依赖

00:19:17.850 --> 00:19:22.830
现在的春季潮汐功能

00:19:21.510 --> 00:19:25.559
在课堂上，让我们继续前进

00:19:22.830 --> 00:19:28.710
在这里建立一个非常简单的功能

00:19:25.559 --> 00:19:29.880
整个重点是

00:19:28.710 --> 00:19:31.920
创建一个非常简单的功能

00:19:29.880 --> 00:19:34.410
大写一个字符串，所以你说函数

00:19:31.920 --> 00:19:36.600
字面上只是函数W直到其他8个

00:19:34.410 --> 00:19:37.980
这是Java 8或更好的功能，我们

00:19:36.600 --> 00:19:39.929
可以通过几种方式做到这一点

00:19:37.980 --> 00:19:46.520
我想取一个字符串然后返回

00:19:39.929 --> 00:19:50.040
像这样的字符串，所以你说返回输入

00:19:46.520 --> 00:19:52.260
输入变成输出的大写

00:19:50.040 --> 00:19:55.710
好吧那当然是一种选择

00:19:52.260 --> 00:20:00.059
无法简单化，或者我认为

00:19:55.710 --> 00:20:02.120
在很多情况下更有用

00:20:00.059 --> 00:20:05.280
可以使用反应流

00:20:02.120 --> 00:20:07.200
您知道类型和特定的发布者

00:20:05.280 --> 00:20:09.990
我们可以使用反应堆项目

00:20:07.200 --> 00:20:11.490
这是构建的反应式运行时

00:20:09.990 --> 00:20:15.540
除了反应流之外，我们可以使用

00:20:11.490 --> 00:20:18.300
反应堆反应堆项目

00:20:15.540 --> 00:20:21.750
描述传入的请求流

00:20:18.300 --> 00:20:23.740
作为通量，通量是出版商要思考的

00:20:21.750 --> 00:20:25.570
只是散发物品

00:20:23.740 --> 00:20:27.490
反应的流发布者实现了

00:20:25.570 --> 00:20:31.179
反应性流发布者界面，但是

00:20:27.490 --> 00:20:32.950
这是一个省略项目的东西，它

00:20:31.179 --> 00:20:34.990
可能是无限的，所以它有

00:20:32.950 --> 00:20:37.390
我们可以用来迭代的运算符

00:20:34.990 --> 00:20:39.520
遍历过滤器或

00:20:37.390 --> 00:20:43.780
就像我们想要的那样

00:20:39.520 --> 00:20:47.860
在这里我要说函数通量

00:20:43.780 --> 00:20:54.190
会产生助焊剂

00:20:47.860 --> 00:21:01.210
字符串正确，所以大写返回

00:20:54.190 --> 00:21:03.760
不，让我们得到这个编译通量

00:21:01.210 --> 00:21:06.390
错过它附录在这里看到春天的云

00:21:03.760 --> 00:21:06.390
功能

00:21:10.450 --> 00:21:21.270
入门功能网站，是的，我们全力以赴

00:21:16.870 --> 00:21:26.640
对，这样在这种情况下

00:21:21.270 --> 00:21:30.010
我要说来的助焊剂点图

00:21:26.640 --> 00:21:32.830
你知道那是字符串点

00:21:30.010 --> 00:21:35.080
大写，所以这又是一个反应

00:21:32.830 --> 00:21:36.790
 API对，我可以使用反应式

00:21:35.080 --> 00:21:38.320
 Spring Framework的Web客户端五

00:21:36.790 --> 00:21:40.150
这是所有引入的东西

00:21:38.320 --> 00:21:42.610
我没有导演会爬，但是

00:21:40.150 --> 00:21:44.530
如果我添加了反应式Web客户端类型

00:21:42.610 --> 00:21:45.310
我可以用它来呼叫其他服务

00:21:44.530 --> 00:21:48.910
我可以做各种有趣的事

00:21:45.310 --> 00:21:50.440
这里的东西和那些不阻塞的东西

00:21:48.910 --> 00:21:51.910
对，这在这里非常有价值

00:21:50.440 --> 00:21:53.650
在这种情况下，我们继续吧

00:21:51.910 --> 00:21:54.940
并在请求时保持原样

00:21:53.650 --> 00:21:57.130
进来，我们要拿来

00:21:54.940 --> 00:21:59.710
请求大写然后发送

00:21:57.130 --> 00:22:01.570
作为反应流向外流出

00:21:59.710 --> 00:22:02.620
将成为您所知道的输入或

00:22:01.570 --> 00:22:04.840
输出仍将由

00:22:02.620 --> 00:22:06.520
卡夫卡，但现在我们可以有这个好

00:22:04.840 --> 00:22:08.440
程序模型与

00:22:06.520 --> 00:22:09.760
其他想要你知道的事情

00:22:08.440 --> 00:22:14.850
我们想谈谈这些

00:22:09.760 --> 00:22:19.230
反应性类型可以，所以大写

00:22:14.850 --> 00:22:19.230
 Maven清洁包

00:22:24.090 --> 00:22:34.210
好吧，我要说我要

00:22:26.440 --> 00:22:39.370
说riff创建创建Java我输入

00:22:34.210 --> 00:22:41.650
再次记住大写的名字-和

00:22:39.370 --> 00:22:42.730
他的名字快捷方式是大写

00:22:41.650 --> 00:22:47.710
因为为什么不

00:22:42.730 --> 00:22:49.150
哦是相反的是卡夫卡

00:22:47.710 --> 00:22:51.610
想要的主题八

00:22:49.150 --> 00:22:53.200
回应，在这种情况下，我们将

00:22:51.610 --> 00:22:55.750
将其转发给我们的反向，这样它会

00:22:53.200 --> 00:22:56.590
会产生连锁效果

00:22:55.750 --> 00:22:57.970
用两种不同的东西写

00:22:56.590 --> 00:22:59.200
不同的语言，顺便说一下

00:22:57.970 --> 00:23:01.720
是真正的之一

00:22:59.200 --> 00:23:04.840
路径的有趣可能性

00:23:01.720 --> 00:23:05.920
与faz一样，您有能力

00:23:04.840 --> 00:23:07.090
混合搭配最佳品种

00:23:05.920 --> 00:23:08.440
用于手头工作的技术

00:23:07.090 --> 00:23:11.920
这些显然很轻巧

00:23:08.440 --> 00:23:13.060
琐碎的例子，但也许你想

00:23:11.920 --> 00:23:17.020
使用用Shell写的东西

00:23:13.060 --> 00:23:19.600
对或调用已写的内容

00:23:17.020 --> 00:23:22.930
好在里面更容易访问

00:23:19.600 --> 00:23:24.400
一个shell脚本，我认为

00:23:22.930 --> 00:23:26.260
我见过的最丑陋的代码

00:23:24.400 --> 00:23:27.730
与Java和

00:23:26.260 --> 00:23:32.550
例如，您可能会使用本机代码

00:23:27.730 --> 00:23:34.780
与J＆I或Java和操作系统一起使用

00:23:32.550 --> 00:23:37.390
您知道外壳的命令行实用程序

00:23:34.780 --> 00:23:39.040
脚本化到命令

00:23:37.390 --> 00:23:40.530
操作系统那种代码

00:23:39.040 --> 00:23:42.760
乏味，很难保证

00:23:40.530 --> 00:23:44.710
它可以工作，你知道那只是我的事

00:23:42.760 --> 00:23:46.060
喜欢保持孤立，如果你曾经

00:23:44.710 --> 00:23:48.190
例如用于imagemagick 

00:23:46.060 --> 00:23:50.470
 Java绑定你知道其中一些

00:23:48.190 --> 00:23:51.910
东西有时会泄漏正确，所以

00:23:50.470 --> 00:23:54.430
很高兴有这个机会

00:23:51.910 --> 00:23:56.800
这个选项说好，这是为了

00:23:54.430 --> 00:23:58.840
例如一个命令，它本身是关闭的

00:23:56.800 --> 00:24:00.940
我要开始做一些处理

00:23:58.840 --> 00:24:02.020
然后杀死容器并声称

00:24:00.940 --> 00:24:04.180
所有的记忆是不可能的

00:24:02.020 --> 00:24:06.250
我的Java应用程序泄漏的原因

00:24:04.180 --> 00:24:07.930
在这种情况下，我可以在这种情况下

00:24:06.250 --> 00:24:09.670
只是一个例子而已

00:24:07.930 --> 00:24:11.260
没什么游戏，但想像一下

00:24:09.670 --> 00:24:13.720
 imagemagick场景想像你

00:24:11.260 --> 00:24:15.550
想要做某件事

00:24:13.720 --> 00:24:17.860
有些人在Java中用Java做过一些事情， 

00:24:15.550 --> 00:24:19.240
然后将响应转发到图像

00:24:17.860 --> 00:24:22.150
设法做一些实际的图像调整大小

00:24:19.240 --> 00:24:23.500
好好使用，您可以使用API​​本身

00:24:22.150 --> 00:24:26.260
可以使用ffmpeg使用所有这些

00:24:23.500 --> 00:24:28.510
命令行实用程序很多

00:24:26.260 --> 00:24:29.790
您更容易知道在

00:24:28.510 --> 00:24:31.960
命令行，然后他们通过

00:24:29.790 --> 00:24:34.690
一些第三方

00:24:31.960 --> 00:24:36.400
 J9绑定例如好吧，即兴

00:24:34.690 --> 00:24:39.160
创建Java-我大写

00:24:36.400 --> 00:24:40.600
它是大写出来是反向的

00:24:39.160 --> 00:24:43.510
我们将其转发到我们的节点上

00:24:40.600 --> 00:24:45.690
这是一个处理程序，我们

00:24:43.510 --> 00:24:48.610
想用来运行这是大写

00:24:45.690 --> 00:24:50.350
快照jar，所以在使用前--文件

00:24:48.610 --> 00:24:51.550
路径，我说只是想办法

00:24:50.350 --> 00:24:52.960
在这里查看当前目录

00:24:51.550 --> 00:24:54.250
我很具体，有很多

00:24:52.960 --> 00:24:56.350
当前目录中的内容

00:24:54.250 --> 00:24:59.110
由于多重性

00:24:56.350 --> 00:25:01.720
目录文件系统和结构

00:24:59.110 --> 00:25:03.640
一个Java应用程序，然后我终于

00:25:01.720 --> 00:25:06.040
要告诉它要运行什么，所以我要

00:25:03.640 --> 00:25:08.350
说我要你运行这个功能

00:25:06.040 --> 00:25:10.300
在此类中称为大写

00:25:08.350 --> 00:25:12.610
我将把它分成两部分

00:25:10.300 --> 00:25:15.460
这里的信息是大写的

00:25:12.610 --> 00:25:19.090
功能本身，主要类别是

00:25:15.460 --> 00:25:21.040
现在，我希望

00:25:19.090 --> 00:25:24.070
 Java函数调用器达到目的

00:25:21.040 --> 00:25:25.690
我可以说好吧，你知道我不知道

00:25:24.070 --> 00:25:26.980
需要在这里指定处理程序

00:25:25.690 --> 00:25:28.510
罐子，这是一个很好的春季应用程序

00:25:26.980 --> 00:25:30.430
取出有它的beans

00:25:28.510 --> 00:25:31.900
实现功能或更佳

00:25:30.430 --> 00:25:35.140
在这里，你知道这是

00:25:31.900 --> 00:25:37.420
要查找的功能，但现在这是

00:25:35.140 --> 00:25:39.610
没什么大不了的，你可以看到我们的

00:25:37.420 --> 00:25:42.730
函数和我们的大写R拥有它们

00:25:39.610 --> 00:25:46.500
两者-已部署，您知道我们的

00:25:42.730 --> 00:25:46.500
反转中心大写字母R，但都

00:25:47.070 --> 00:25:51.400
部署，我们可以询问

00:25:49.510 --> 00:25:52.840
运行时，问一下我们有什么功能

00:25:51.400 --> 00:25:55.930
现在可供我们使用，所以这些是

00:25:52.840 --> 00:26:03.780
在那里，我想做的是

00:25:55.930 --> 00:26:03.780
想要发送请求到大写

00:26:04.020 --> 00:26:13.810
你好美丽的即兴即兴-T 

00:26:11.860 --> 00:26:15.880
像卷发一样是正确的数据吗

00:26:13.810 --> 00:26:17.260
命令，顺便说一句，如果你在做

00:26:15.880 --> 00:26:20.290
你想做的更复杂的事情

00:26:17.260 --> 00:26:21.370
 UM例如向您发送JSON节

00:26:20.290 --> 00:26:24.460
可以做到，你实际上可以说

00:26:21.370 --> 00:26:26.530
您知道内容类型等于的应用程序

00:26:24.460 --> 00:26:29.560
应用程序JSON，然后是这种情况

00:26:26.530 --> 00:26:33.250
字符串的变化可能是你的变化

00:26:29.560 --> 00:26:35.920
知道什么可以私人输入

00:26:33.250 --> 00:26:38.740
字符串值，然后您可能会有一个

00:26:35.920 --> 00:26:40.000
输入流量，然后确保您

00:26:38.740 --> 00:26:41.770
有吸气剂和二传手的轴突

00:26:40.000 --> 00:26:42.850
编组当然，但你知道

00:26:41.770 --> 00:26:44.470
只要你能正常工作

00:26:42.850 --> 00:26:45.970
指定它将执行的内容类型

00:26:44.470 --> 00:26:47.650
用绳子编组，所以

00:26:45.970 --> 00:26:48.700
默认情况下，运行时本身知道

00:26:47.650 --> 00:26:50.290
他们被移进去的弦

00:26:48.700 --> 00:26:52.420
但是没有理由你不能转身

00:26:50.290 --> 00:26:54.460
这些东西变成更有趣的类型

00:26:52.420 --> 00:26:59.650
根据您的语言支持

00:26:54.460 --> 00:27:02.890
编组等等，好吧，我们要

00:26:59.650 --> 00:27:05.770
说将其发布到大写的卡夫卡

00:27:02.890 --> 00:27:07.270
发送此消息的主题，我们不需要

00:27:05.770 --> 00:27:10.060
指定内容类型

00:27:07.270 --> 00:27:12.280
暗示就是这样，我们想要

00:27:10.060 --> 00:27:15.820
指定一个矮小的答复现在记得我已经

00:27:12.280 --> 00:27:17.950
将其链接以与Reverse交谈，因此我们

00:27:15.820 --> 00:27:21.160
应该看到它占用了我们的小写字母你好

00:27:17.950 --> 00:27:27.690
美丽的即兴大写字母它和反向

00:27:21.160 --> 00:27:27.690
好的，容器正在创建运行

00:27:29.700 --> 00:27:34.500
相反，它现在以

00:27:31.930 --> 00:27:37.990
好吧，我们去

00:27:34.500 --> 00:27:41.200
你好，战利品即兴好，这样工作

00:27:37.990 --> 00:27:44.590
这是两个非常简单的例子

00:27:41.200 --> 00:27:45.340
通过这种方式将功能链接在一起

00:27:44.590 --> 00:27:47.830
你可以做各种有趣的事

00:27:45.340 --> 00:27:49.870
这里的事情我的意思是你知道我给了你

00:27:47.830 --> 00:27:51.250
一些例子，但让我们谈谈

00:27:49.870 --> 00:27:52.840
更典型的情况是

00:27:51.250 --> 00:27:54.220
像我这样长期运行的II 

00:27:52.840 --> 00:27:55.300
提到图像魔术的东西，因为

00:27:54.220 --> 00:27:56.950
我确定我们所有人中都有代码

00:27:55.300 --> 00:27:59.260
系统必须要炮轰的地方

00:27:56.950 --> 00:28:01.000
这是很普通的事情，但即使在

00:27:59.260 --> 00:28:02.620
 Java我们拥有的东西

00:28:01.000 --> 00:28:04.900
宁愿在外面做

00:28:02.620 --> 00:28:06.910
我们的传统请求响应路径

00:28:04.900 --> 00:28:08.950
应用程序和一些东西

00:28:06.910 --> 00:28:11.800
我们可以肯定它最终会

00:28:08.950 --> 00:28:13.420
成功，我们可以使用例如

00:28:11.800 --> 00:28:16.120
异步，绝对是一种选择，但是那

00:28:13.420 --> 00:28:17.350
假设运行时总是

00:28:16.120 --> 00:28:21.040
那里的应用程序永远不会

00:28:17.350 --> 00:28:23.470
失去任何状态，所以我倾向于回避

00:28:21.040 --> 00:28:26.800
从那有用的虽然我尝试

00:28:23.470 --> 00:28:27.640
并通过排队让事情上演

00:28:26.800 --> 00:28:30.370
对上演的事件驱动

00:28:27.640 --> 00:28:32.590
建筑非常非常简单，所以

00:28:30.370 --> 00:28:36.010
我这样做的原因是因为如果我应该

00:28:32.590 --> 00:28:38.380
让你知道我的客户是否有事

00:28:36.010 --> 00:28:40.480
创造作品应该永远

00:28:38.380 --> 00:28:42.100
如果它应该失败，那么我可以在

00:28:40.480 --> 00:28:43.690
最少重启客户端一点

00:28:42.100 --> 00:28:45.640
重新处理他错过了错过的消息

00:28:43.690 --> 00:28:48.010
现在我们已经内置了

00:28:45.640 --> 00:28:49.030
这是免费的，保证的

00:28:48.010 --> 00:28:51.070
分阶段的事件驱动架构

00:28:49.030 --> 00:28:52.690
已经存在的方法

00:28:51.070 --> 00:28:54.550
可以免费使用，所以让我们

00:28:52.690 --> 00:28:57.310
来建造斯普林伍德

00:28:54.550 --> 00:28:58.540
发送电子邮件的应用程序以及什么

00:28:57.310 --> 00:29:01.630
我们要做的是发送电子邮件

00:28:58.540 --> 00:29:02.509
现在使用发送网格发送好是一封电子邮件

00:29:01.630 --> 00:29:04.909
作为一种服务

00:29:02.509 --> 00:29:07.489
运行时，这是一个令人遗憾的选择

00:29:04.909 --> 00:29:08.599
有一个API，它需要一个API密钥，因此

00:29:07.489 --> 00:29:14.289
这将是我们要做的是

00:29:08.599 --> 00:29:17.269
将使用SendGrid API只是为了

00:29:14.289 --> 00:29:19.729
进行身份验证，我们将使用客户端

00:29:17.269 --> 00:29:22.009
 Java绑定以创建正确的有效负载

00:29:19.729 --> 00:29:23.239
然后发送该请求，依此类推

00:29:22.009 --> 00:29:26.509
为了使它工作，尽管我们需要一个

00:29:23.239 --> 00:29:28.399
环境变量好吧，所以我们需要

00:29:26.509 --> 00:29:31.820
我们需要一些地方藏起来

00:29:28.399 --> 00:29:34.489
身份验证api密钥，让我们继续

00:29:31.820 --> 00:29:40.159
并关闭它并创建一个新功能

00:29:34.489 --> 00:29:41.389
这将被称为mailer all 

00:29:40.159 --> 00:29:43.940
右庄园

00:29:41.389 --> 00:29:45.019
所以，我不知道我们需要所有这些

00:29:43.940 --> 00:29:46.609
我想我们可以从中使用很多

00:29:45.019 --> 00:29:49.579
龙目岛，但实际上我们甚至不需要

00:29:46.609 --> 00:29:50.869
真的，所以这只是一个非常

00:29:49.579 --> 00:29:54.829
我将点击生成的简单Springwood应用程序

00:29:50.869 --> 00:29:55.729
这会给我们这个Maynard解压缩

00:29:54.829 --> 00:29:59.559
我们将会在我们的

00:29:55.729 --> 00:29:59.559
应用程序和我们的IDE 

00:30:06.309 --> 00:30:12.849
现在我们才能知道我们需要什么

00:30:09.940 --> 00:30:15.519
要做的是我们需要添加普通的东西

00:30:12.849 --> 00:30:25.320
我们在依赖之前所做的

00:30:15.519 --> 00:30:29.049
首先不是已经依赖

00:30:25.320 --> 00:30:35.019
依赖和洒水功能

00:30:29.049 --> 00:30:39.249
依赖项类型等于Palm作用域

00:30:35.019 --> 00:30:44.019
导入好吧，就是这样，我们

00:30:39.249 --> 00:30:47.499
需要弹簧代码功能启动器

00:30:44.019 --> 00:30:49.659
功能网络每个人都很好，所以有

00:30:47.499 --> 00:30:51.669
我们的依赖关系现在我们还需要

00:30:49.659 --> 00:30:54.099
 SendGrid API，我们需要相同的网格

00:30:51.669 --> 00:30:56.849
客户在这里的课堂路径上，所以让我们

00:30:54.099 --> 00:31:02.649
继续并为此添加依赖项

00:30:56.849 --> 00:31:06.639
好的，SendGrid依赖项位于

00:31:02.649 --> 00:31:13.509
冷静一下这是一个罪恶的网格Java 

00:31:06.639 --> 00:31:15.759
是的，我想是这样，4.2 1.1是

00:31:13.509 --> 00:31:19.119
和田好吧，那现在在我们那里

00:31:15.759 --> 00:31:24.099
主要是我们的代码，我们将创建一个

00:31:19.119 --> 00:31:25.089
发送给我们的简单功能

00:31:24.099 --> 00:31:28.210
有些会把它发送给我们自己

00:31:25.089 --> 00:31:29.469
基本上，我们要发送电子邮件至

00:31:28.210 --> 00:31:31.749
为了做到这一点，我们需要

00:31:29.469 --> 00:31:35.320
发送网格客户端，所以当我们说在

00:31:31.749 --> 00:31:37.779
发送网格API，这是我们的接口

00:31:35.320 --> 00:31:39.940
不如发送网格，我们可以

00:31:37.779 --> 00:31:41.769
称为此发送网格，并为了

00:31:39.940 --> 00:31:43.210
要正常工作需要这种环境

00:31:41.769 --> 00:31:45.099
反叛我碰巧有这种环境

00:31:43.210 --> 00:31:47.409
我的本地机器上的变量，所以任何

00:31:45.099 --> 00:31:49.029
我运行的测试可以工作，但这不是

00:31:47.409 --> 00:31:53.289
没有那种环境就可以工作

00:31:49.029 --> 00:31:54.399
变量在集群中

00:31:53.289 --> 00:31:56.139
创建了集群，所以我们需要实际

00:31:54.399 --> 00:31:58.089
设置好，我们将讨论秘密

00:31:56.139 --> 00:31:59.859
 kubernetes中的管理

00:31:58.089 --> 00:32:02.469
第二，所以我要说返回新的

00:31:59.859 --> 00:32:04.599
我需要实际的SendGrid哦

00:32:02.469 --> 00:32:09.029
实施具体一过

00:32:04.599 --> 00:32:14.080
在关键好事中得到了

00:32:09.029 --> 00:32:16.239
我们将创建一个函数

00:32:14.080 --> 00:32:19.500
字符串，这是电子邮件，它将

00:32:16.239 --> 00:32:22.260
返回正确发送的布尔值

00:32:19.500 --> 00:32:23.630
所以想像你有东西

00:32:22.260 --> 00:32:25.560
知道有人注册了帐户或

00:32:23.630 --> 00:32:26.970
这样的事情，你想做一个

00:32:25.560 --> 00:32:29.520
确认电子邮件或其他任何内容

00:32:26.970 --> 00:32:30.990
其中可能需要的事情之一

00:32:29.520 --> 00:32:32.760
比您准备的时间长一点

00:32:30.990 --> 00:32:33.900
等一下，你可能想格式化你的东西

00:32:32.760 --> 00:32:35.580
可能需要准备图像

00:32:33.900 --> 00:32:36.810
你这可能是那种东西

00:32:35.580 --> 00:32:39.000
您作为cron工作运行，可能是

00:32:36.810 --> 00:32:40.860
运行的报告或其他内容，这是

00:32:39.000 --> 00:32:43.200
这是一个完美的例子

00:32:40.860 --> 00:32:46.410
我会很高兴的那种工作

00:32:43.200 --> 00:32:47.910
投入到函数中

00:32:46.410 --> 00:32:50.910
我们以前谈论的服务平台

00:32:47.910 --> 00:32:53.160
元组空间，你知道一个

00:32:50.910 --> 00:32:55.080
一群工人然后可以

00:32:53.160 --> 00:32:56.610
积极消耗你知道这些是

00:32:55.080 --> 00:32:59.040
他们会贪婪的消费者

00:32:56.610 --> 00:33:01.110
积极工作直到他们上班

00:32:59.040 --> 00:33:04.880
不用排队处理他们的工作

00:33:01.110 --> 00:33:06.750
然后再消失吧

00:33:04.880 --> 00:33:09.060
这是我们想要的东西

00:33:06.750 --> 00:33:11.760
等待，我们知道我们可以发送支持

00:33:09.060 --> 00:33:14.010
自然使用功能

00:33:11.760 --> 00:33:20.430
运行时间，所以这里是一个新功能

00:33:14.010 --> 00:33:23.760
在我们的职能中，我们将采取

00:33:20.430 --> 00:33:26.910
电子邮件，我将确认

00:33:23.760 --> 00:33:32.130
它已发送，为了发送，我们需要

00:33:26.910 --> 00:33:32.850
使用我们需要使用发送好的

00:33:32.130 --> 00:33:36.120
客户还可以

00:33:32.850 --> 00:33:36.930
所以让我们看看我不知道我们是否

00:33:36.120 --> 00:33:45.210
需要那个

00:33:36.930 --> 00:33:47.800
可能没有通过电子邮件打招呼好吗

00:33:45.210 --> 00:33:54.900
现在让我们看看我是否还记得这个API 

00:33:47.800 --> 00:33:58.750
电子邮件来自新的电子邮件春季-的提示

00:33:54.900 --> 00:34:00.820
约什（Josh）冷静了好久

00:33:58.750 --> 00:34:02.580
电子邮件地址会是我

00:34:00.820 --> 00:34:06.790
实际上应该创建它

00:34:02.580 --> 00:34:14.650
主题将是美丽的即兴

00:34:06.790 --> 00:34:17.919
好的电子邮件-将-将是

00:34:14.650 --> 00:34:22.380
作为参数收到的电子邮件

00:34:17.919 --> 00:34:29.730
是不是所以我们去了内容

00:34:22.380 --> 00:34:29.730
内容让我们看看这等于

00:34:31.860 --> 00:34:42.210
我认为这只是文字上的记忆

00:34:35.530 --> 00:34:50.020
服务，它将变得美丽

00:34:42.210 --> 00:34:52.450
充当服务或您知道什么

00:34:50.020 --> 00:34:57.010
去传统的你好世界

00:34:52.450 --> 00:34:59.290
因为那是超级合适的邮件

00:34:57.010 --> 00:35:00.670
来自于的帮助对象

00:34:59.290 --> 00:35:01.750
 SendGrid API-因为我们在做什么

00:35:00.670 --> 00:35:04.180
是我们使用相同的出色API 

00:35:01.750 --> 00:35:06.010
发布到他们的休息api，所以我们真的

00:35:04.180 --> 00:35:07.290
刚刚得到了一些花哨的复合类型

00:35:06.010 --> 00:35:09.280
我们可以用来缩短

00:35:07.290 --> 00:35:13.060
来回封送他们的api 

00:35:09.280 --> 00:35:16.180
所以-然后让每个人都满意

00:35:13.060 --> 00:35:17.950
现在我们来行动吧

00:35:16.180 --> 00:35:20.050
现在出现了与

00:35:17.950 --> 00:35:20.980
他们相同的好客户，所以我们

00:35:20.050 --> 00:35:29.530
说的是要求

00:35:20.980 --> 00:35:31.660
等于等于新的要求和传递

00:35:29.530 --> 00:35:37.720
在

00:35:31.660 --> 00:35:43.480
他们说我们的点集方法

00:35:37.720 --> 00:35:53.200
等于发布我们的点集身体

00:35:43.480 --> 00:35:59.410
这将是邮件点构建没事了

00:35:53.200 --> 00:36:02.039
回到这里一次新的

00:35:59.410 --> 00:36:08.730
由客户决定的异常泡沫

00:36:02.039 --> 00:36:15.279
我还知道我们的n点是什么

00:36:08.730 --> 00:36:17.890
邮件发送，我认为就是这样

00:36:15.279 --> 00:36:20.710
这就是我们需要的关键线

00:36:17.890 --> 00:36:22.630
现在我们需要实际这样做

00:36:20.710 --> 00:36:28.140
让我们得到回应会说发送

00:36:22.630 --> 00:36:31.420
很棒的API点，是API y R 

00:36:28.140 --> 00:36:33.490
然后我会给我们回复

00:36:31.420 --> 00:36:36.460
然后使用我们想要的响应

00:36:33.490 --> 00:36:40.349
确认已发送响应点

00:36:36.460 --> 00:36:48.539
获取状态码应等于HTTP状态

00:36:40.349 --> 00:36:50.319
点好，返回值已发送好

00:36:48.539 --> 00:36:52.480
我们在那里，所以我们很简单

00:36:50.319 --> 00:36:53.710
功能，应该做到这一点

00:36:52.480 --> 00:36:55.930
很简单的例子显然你会

00:36:53.710 --> 00:36:56.710
有HTML和格式，我敢肯定

00:36:55.930 --> 00:36:59.140
你会有设计师，在那里

00:36:56.710 --> 00:37:00.599
某个地方，各种各样的东西都可以

00:36:59.140 --> 00:37:03.160
我们现在有一个非常简单的例子

00:37:00.599 --> 00:37:05.470
这是一个函数，它将被称为

00:37:03.160 --> 00:37:07.779
邮件并为其执行工作

00:37:05.470 --> 00:37:09.039
尽你所能，我们需要这个

00:37:07.779 --> 00:37:10.630
环境变量此键在这里

00:37:09.039 --> 00:37:13.319
通常我实际上可以走一步

00:37:10.630 --> 00:37:20.230
更进一步，我可以说你知道SendGrid 

00:37:13.319 --> 00:37:21.940
点API密钥，然后让我们带上它

00:37:20.230 --> 00:37:26.259
同样好的API密钥，实际上

00:37:21.940 --> 00:37:27.490
自动为我配置相同的网格对象

00:37:26.259 --> 00:37:29.680
这是一个Spring Boot自动配置

00:37:27.490 --> 00:37:37.040
所以我可以说春天是英格丽

00:37:29.680 --> 00:37:39.300
 API密钥等于此处

00:37:37.040 --> 00:37:43.830
所以我们在那里

00:37:39.300 --> 00:37:47.550
环境，这会给我一个

00:37:43.830 --> 00:37:49.500
 SendGrid对象，所以我很好，是的，所以

00:37:47.550 --> 00:37:50.430
它会创建http / 2这个孩子

00:37:49.500 --> 00:37:53.130
 SendGrid 

00:37:50.430 --> 00:37:54.150
像我一样的api键，所以我们可以使用

00:37:53.130 --> 00:37:56.100
那实际上可能甚至

00:37:54.150 --> 00:37:57.750
清洁工，让我们这样做

00:37:56.100 --> 00:38:02.870
实际上只是春天，但是- 

00:37:57.750 --> 00:38:05.310
他们现在在这里为我们工作

00:38:02.870 --> 00:38:05.700
我们有应用程序，我们有

00:38:05.310 --> 00:38:09.360
 SendGrid 

00:38:05.700 --> 00:38:11.430
实施我认为那就是我们

00:38:09.360 --> 00:38:14.190
需要我们现在需要部署它

00:38:11.430 --> 00:38:16.290
申请并为了我们做

00:38:14.190 --> 00:38:18.600
我们需要告诉kubernetes 

00:38:16.290 --> 00:38:21.390
该API密钥，因此这是获取密钥的地方

00:38:18.600 --> 00:38:29.070
我们需要潜水的乏味

00:38:21.390 --> 00:38:32.550
进入kubernetes的秘密，让我们拭目以待

00:38:29.070 --> 00:38:35.340
在这里我有这个价值

00:38:32.550 --> 00:38:37.590
我会说本地计算机echo SendGrid API 

00:38:35.340 --> 00:38:39.840
关键，我想写出来

00:38:37.590 --> 00:38:41.250
 API密钥txt文件

00:38:39.840 --> 00:38:42.570
我的环境适用于我

00:38:41.250 --> 00:38:44.250
我希望它在本地计算机上

00:38:42.570 --> 00:38:46.110
本地文件系统，如果我会原谅我

00:38:44.250 --> 00:38:51.110
不要在那儿反抗环境

00:38:46.110 --> 00:38:58.470
我要说的是Kubb CTL创建秘密

00:38:51.110 --> 00:39:01.530
通用的SendGrid API密钥，我要

00:38:58.470 --> 00:39:03.960
说我想来自文件，而我

00:39:01.530 --> 00:39:05.040
请注意，那里有一些

00:39:03.960 --> 00:39:08.370
我说的是这里发生的两件事

00:39:05.040 --> 00:39:12.560
创建一个名为SendGrid api密钥的秘密

00:39:08.370 --> 00:39:15.060
然后多数民众赞成在网格秘密可以有一个

00:39:12.560 --> 00:39:17.130
键和值的值字典

00:39:15.060 --> 00:39:19.110
信不信由你，关键不是

00:39:17.130 --> 00:39:21.180
只是一个关键，然后在价值上

00:39:19.110 --> 00:39:23.610
实际上是一把钥匙，然后会给你

00:39:21.180 --> 00:39:27.630
访问字典，所以我在这里

00:39:23.610 --> 00:39:30.150
现在再说一次SendGrid api键

00:39:27.630 --> 00:39:32.100
您是否知道您是否正在使用

00:39:30.150 --> 00:39:34.500
您具有来自的sanguin api密钥的密码

00:39:32.100 --> 00:39:36.540
文件等于用户名等于，然后

00:39:34.500 --> 00:39:39.740
文件中的值，然后-- 

00:39:36.540 --> 00:39:42.180
来自文件的密码等于，然后

00:39:39.740 --> 00:39:44.670
等于密码然后等于文件

00:39:42.180 --> 00:39:46.080
从密码文件中，所以我

00:39:44.670 --> 00:39:47.440
会说这是Ingrid API密钥等于

00:39:46.080 --> 00:39:50.870
点

00:39:47.440 --> 00:39:53.950
 API密钥点txt 

00:39:50.870 --> 00:39:57.920
好吧，所以，cood拥抱伟大的秘密

00:39:53.950 --> 00:40:03.020
文件中的通用sanguine API密钥

00:39:57.920 --> 00:40:05.240
 SendGrid-API关键点API关键点txt 

00:40:03.020 --> 00:40:10.310
现在，如果我看着我说

00:40:05.240 --> 00:40:17.830
小屋拥抱获得所有的秘密吧，我

00:40:10.310 --> 00:40:19.640
可以说小屋拥抱得到秘密的SendGrid 

00:40:17.830 --> 00:40:21.920
 API密钥

00:40:19.640 --> 00:40:22.880
哦，是的，所以我实际上我不需要

00:40:21.920 --> 00:40:25.310
为此，但这是一种

00:40:22.880 --> 00:40:27.290
有趣的是，您可以看到这是

00:40:25.310 --> 00:40:30.260
这个调用是这样的-哦

00:40:27.290 --> 00:40:32.480
 yeah mo告诉kubernetes写

00:40:30.260 --> 00:40:35.930
将该资源定义为

00:40:32.480 --> 00:40:39.890
配置文件进入杰森·阿梅尔的

00:40:35.930 --> 00:40:40.970
让我们站起来，我需要-然后，如果

00:40:39.890 --> 00:40:43.040
我想对版本进行控制

00:40:40.970 --> 00:40:45.770
实际上是这样的版本控制和

00:40:43.040 --> 00:40:47.390
然后用你知道的布谷鸟抱抱

00:40:45.770 --> 00:40:49.160
板条箱秘密，然后告诉就用这个

00:40:47.390 --> 00:40:54.530
文件而不是我做的人和

00:40:49.160 --> 00:41:01.640
命令行，就是那样

00:40:54.530 --> 00:41:03.380
我想做的是我想做的

00:41:01.640 --> 00:41:05.180
需要创建该功能，我需要

00:41:03.380 --> 00:41:06.710
实际上-我需要创建一个

00:41:05.180 --> 00:41:08.120
首先运行，我将不得不

00:41:06.710 --> 00:41:09.920
创建它，然后运行它基本我想要我

00:41:08.120 --> 00:41:12.260
想要II可以通过多种方式做到这一点，但是

00:41:09.920 --> 00:41:16.820
为了保持一致，我只想说

00:41:12.260 --> 00:41:20.330
创建功能-我的邮件

00:41:16.820 --> 00:41:22.760
 -n是庄园，就是名字-a是我

00:41:20.330 --> 00:41:23.680
意思是先做一个行家清洁包

00:41:22.760 --> 00:41:28.280
刚刚关系

00:41:23.680 --> 00:41:30.500
邮递员甚至可能会清洁包裹

00:41:28.280 --> 00:41:32.600
首先创建功能，然后

00:41:30.500 --> 00:41:34.220
失败但我不在乎然后我要去

00:41:32.600 --> 00:41:36.350
更新配置文件

00:41:34.220 --> 00:41:38.480
功能资源的资源

00:41:36.350 --> 00:41:42.040
我们在创建函数时得到

00:41:38.480 --> 00:41:48.580
所以我会说riff创建Java 

00:41:42.040 --> 00:41:54.800
 -我向目标庄园寄送邮件

00:41:48.580 --> 00:41:59.030
经理将是男性，主要将是

00:41:54.800 --> 00:42:03.180
等于冷静的例子

00:41:59.030 --> 00:42:05.220
但这是主要应用吗

00:42:03.180 --> 00:42:13.430
让我们将引用复制到

00:42:05.220 --> 00:42:17.010
该死的好吧，那是UM 

00:42:13.430 --> 00:42:20.670
我还好

00:42:17.010 --> 00:42:22.859
创建它，你可以看到我有

00:42:20.670 --> 00:42:25.890
这些新资源现在和以前一样

00:42:22.859 --> 00:42:27.150
我将打开这些功能

00:42:25.890 --> 00:42:29.849
在这里配置，这次我要

00:42:27.150 --> 00:42:32.819
更改它以反映我们的新秘密，所以我

00:42:29.849 --> 00:42:40.680
想去集装箱，我们会说e 

00:42:32.819 --> 00:42:49.380
和V，我们会说-名称将被发送

00:42:40.680 --> 00:42:50.549
网格API密钥的值

00:42:49.380 --> 00:42:55.230
我们将使用密钥

00:42:50.549 --> 00:42:57.569
引用，所以一个秘密密钥引用名称和

00:42:55.230 --> 00:42:59.970
这是字典的来源

00:42:57.569 --> 00:43:03.299
他们喜欢那本小字典里的钥匙

00:42:59.970 --> 00:43:08.250
如果您会使用一些好的API密钥， 

00:43:03.299 --> 00:43:10.160
我们希望它位于网格API密钥中的密钥

00:43:08.250 --> 00:43:12.779
好吧

00:43:10.160 --> 00:43:16.710
这就是我们要做的一切

00:43:12.779 --> 00:43:17.849
需要并在适当的地方

00:43:16.710 --> 00:43:20.630
在我们的环境中创建一个环境变量

00:43:17.849 --> 00:43:23.460
功能容器中的容器和

00:43:20.630 --> 00:43:25.319
制作循环并将其提供给

00:43:23.460 --> 00:43:28.289
 Java应用程序

00:43:25.319 --> 00:43:34.859
启动到位，所以现在我

00:43:28.289 --> 00:43:35.730
会说riff更新没事，所以

00:43:34.859 --> 00:43:39.029
好，所以我们去那里是我们的

00:43:35.730 --> 00:43:46.250
应用程序，现在让我们尝试一下吧

00:43:39.029 --> 00:43:49.260
我有这个，这是我的收件箱

00:43:46.250 --> 00:43:51.779
 Joshua Josh我在寻找歌曲平静

00:43:49.260 --> 00:43:53.339
 i谐即兴即兴主题在这里

00:43:51.779 --> 00:43:56.339
这就是这里，所以让我们

00:43:53.339 --> 00:44:00.359
继续，现在创造一些流量

00:43:56.339 --> 00:44:04.730
我将创建一些请求，这是我们的

00:44:00.359 --> 00:44:12.049
这里我们可以，我要说即兴

00:44:04.730 --> 00:44:12.049
发布-我犯了错误-D是Josh 

00:44:12.349 --> 00:44:20.789
乔什·朗·科姆（Josh Long com）-所以我们要去

00:44:17.130 --> 00:44:23.400
发送请求给庄园发布

00:44:20.789 --> 00:44:27.089
在那里，如果我们已经部署

00:44:23.400 --> 00:44:29.690
一切很快就会产生八封电子邮件

00:44:27.089 --> 00:44:35.510
只需一秒钟左右即可到达我的收件箱

00:44:29.690 --> 00:44:35.510
创建并运行容器

00:44:41.880 --> 00:44:54.690
失败了，我做错了什么，所以羽衣甘蓝- 

00:44:46.829 --> 00:44:58.699
 D mailer kales一个不错的命令行

00:44:54.690 --> 00:44:58.699
实用程序来调试这种东西

00:45:03.979 --> 00:45:07.309
它工作了吗

00:45:15.950 --> 00:45:19.029
看起来很有效

00:45:51.320 --> 00:45:55.310
好那里发生了什么

00:45:57.550 --> 00:46:01.480
显然它得到了信息

00:46:08.960 --> 00:46:13.249
我在代码中做错了吗

00:46:25.500 --> 00:46:41.700
一个很好奇的

00:46:28.380 --> 00:46:47.759
所以它跑了，我得到了一个错误，那就是

00:46:41.700 --> 00:46:56.759
工厂获取日志点信息II当我死时

00:46:47.759 --> 00:46:58.019
虽然不要在十二月王子踪影中吃饭

00:46:56.759 --> 00:46:59.940
似乎应该在那里

00:46:58.019 --> 00:47:02.970
无论如何，所以你知道我要去哪里

00:46:59.940 --> 00:47:07.499
继续尝试并控制这件事

00:47:02.970 --> 00:47:16.309
创建正在工作的SendGrid 

00:47:07.499 --> 00:47:25.220
 API密钥bean SendGrid API SendGrid API 

00:47:16.309 --> 00:47:30.479
该值将字符串键转换为新

00:47:25.220 --> 00:47:32.099
 SendGrid API密钥看起来不错

00:47:30.479 --> 00:47:37.339
应该是一样的

00:47:32.099 --> 00:47:45.359
所以我们说主题电子邮件中的电子邮件- 

00:47:37.339 --> 00:47:49.880
你知道-在这里你从内容中知道

00:47:45.359 --> 00:47:55.710
是纯文本的hello世界，不是来自

00:47:49.880 --> 00:48:01.710
视内容而定是请求方法

00:47:55.710 --> 00:48:04.099
邮件发送建立良好API的邮件

00:48:01.710 --> 00:48:04.099
请求

00:48:05.770 --> 00:48:08.770
好的

00:48:14.730 --> 00:48:17.660
你好

00:48:20.099 --> 00:48:29.380
功能世界您好-我想知道是否

00:48:26.950 --> 00:48:31.200
某种垃圾邮件过滤器

00:48:29.380 --> 00:48:39.160
功能世界

00:48:31.200 --> 00:48:55.020
好的，你好，我是肯特

00:48:39.160 --> 00:49:04.440
 Maven的清洁包和RIF更新评估

00:48:55.020 --> 00:49:04.440
我启动我多维数据集docker env 

00:49:06.839 --> 00:49:09.839
好的

00:49:18.580 --> 00:49:31.450
哦，等等，如果发送错误，我确实给了那些

00:49:28.140 --> 00:49:32.650
 8:19还有另外一个822 OS 

00:49:31.450 --> 00:49:34.480
让他们为什么会返回假哦

00:49:32.650 --> 00:49:36.580
有趣的是我得到了一些其他代码

00:49:34.480 --> 00:49:39.220
但是尽管如此，电子邮件确实到达了我

00:49:36.580 --> 00:49:41.740
只是没有刷新电子邮件顾问

00:49:39.220 --> 00:49:46.540
所以这很愚蠢，我有点问题

00:49:41.740 --> 00:49:50.530
还有um如果状态码是什么

00:49:46.540 --> 00:49:52.540
状态码响应的问题

00:49:50.530 --> 00:49:56.290
类型获取状态代码等于HTP可以

00:49:52.540 --> 00:49:57.640
该值是错误的，但它是

00:49:56.290 --> 00:49:59.140
在那里工作，所以功能很好

00:49:57.640 --> 00:50:01.210
一个好吧，这样就行了，所以你

00:49:59.140 --> 00:50:02.260
可以看到我的观点有机会

00:50:01.210 --> 00:50:04.570
那里你一定要明白

00:50:02.260 --> 00:50:06.670
在运行此示例之前很好，因此

00:50:04.570 --> 00:50:10.900
显然我需要在那里做得更好，但是

00:50:06.670 --> 00:50:15.280
确实有效的结果是我们可以

00:50:10.900 --> 00:50:16.990
发送带有以下内容的电子邮件

00:50:15.280 --> 00:50:20.140
现在只需要一点时间

00:50:16.990 --> 00:50:22.690
只是专注于正在发生的事情

00:50:20.140 --> 00:50:24.460
可以看到我正在发送即兴演奏

00:50:22.690 --> 00:50:29.140
已发布，实际上正在发布到

00:50:24.460 --> 00:50:31.020
它里面的HTTP网关是

00:50:29.140 --> 00:50:33.360
你知道实际上有一个

00:50:31.020 --> 00:50:36.460
你可以用来获得的咒语

00:50:33.360 --> 00:50:38.860
 HTTP网关用于项目riff和

00:50:36.460 --> 00:50:42.480
那个咒语，我想他们甚至

00:50:38.860 --> 00:50:42.480
足够好，可以放在博客上

00:50:42.840 --> 00:50:48.040
当我想起当你掌舵时

00:50:47.170 --> 00:50:49.420
图表实际上会向您显示

00:50:48.040 --> 00:50:51.580
您需要的环境变量

00:50:49.420 --> 00:50:54.400
能够到达相同的URL，所以您

00:50:51.580 --> 00:50:56.080
知道获取这些URL的秘密，并且

00:50:54.400 --> 00:50:57.430
我相信你会在

00:50:56.080 --> 00:50:58.780
有一点，所以你实际上可以发布

00:50:57.430 --> 00:51:00.340
您实际上不需要使用

00:50:58.780 --> 00:51:03.280
重新发布就可以

00:51:00.340 --> 00:51:05.650
发布到HTTP，您知道您的网关IP 

00:51:03.280 --> 00:51:07.510
以及此类会话请求的端口

00:51:05.650 --> 00:51:09.580
然后函数的名称，您将

00:51:07.510 --> 00:51:11.110
得到正确的回复我的

00:51:09.580 --> 00:51:12.360
我们曾经看过的朋友

00:51:11.110 --> 00:51:14.620
所以简要地讲一些不同的

00:51:12.360 --> 00:51:17.740
作为服务的功能方面

00:51:14.620 --> 00:51:19.510
他们与项目RIF新开放

00:51:17.740 --> 00:51:21.790
源Apache许可证功能

00:51:19.510 --> 00:51:23.860
关键和春天的服务运行时

00:51:21.790 --> 00:51:25.540
云功能构建的最简单方法

00:51:23.860 --> 00:51:26.530
可以在多个

00:51:25.540 --> 00:51:28.920
不同的功能和服务

00:51:26.530 --> 00:51:33.210
平台，无论

00:51:28.920 --> 00:51:34.800
他们是春季的目的地

00:51:33.210 --> 00:51:36.240
并利用各种

00:51:34.800 --> 00:51:37.640
您可能期望能够做的事情

00:51:36.240 --> 00:51:40.680
从春季良好的应用程序中使用

00:51:37.640 --> 00:51:42.450
包括属性等等，我们

00:51:40.680 --> 00:51:44.580
也将kubernetes的秘密视为

00:51:42.450 --> 00:51:46.950
你的方式知道你如何告诉你的

00:51:44.580 --> 00:51:49.530
关于这些的应用关于这些

00:51:46.950 --> 00:51:51.000
您需要的不同属性

00:51:49.530 --> 00:51:52.890
所以你可以使用组合器做到这一点

00:51:51.000 --> 00:51:53.820
秘密配置地图或只是或您可以

00:51:52.890 --> 00:51:55.770
实际上只是将它们硬编码在

00:51:53.820 --> 00:51:57.270
正确的功能资源不要放

00:51:55.770 --> 00:51:58.740
那里的密码不一定

00:51:57.270 --> 00:52:00.120
不要放在那儿，但要配置

00:51:58.740 --> 00:52:02.490
重视自己需要

00:52:00.120 --> 00:52:04.860
需要改变生产与

00:52:02.490 --> 00:52:06.150
您可以拥有的示例开发

00:52:04.860 --> 00:52:08.970
在您的开发环境中默认

00:52:06.150 --> 00:52:11.130
把你知道的非秘密非安全

00:52:08.970 --> 00:52:13.410
只是直接在函数中

00:52:11.130 --> 00:52:15.420
好的，我的朋友们，我希望你

00:52:13.410 --> 00:52:16.590
像往常一样从中得到一些东西

00:52:15.420 --> 00:52:18.830
谢谢收看，我们见

00:52:16.590 --> 00:52:18.830
下次

00:52:24.829 --> 00:52:26.890
您

