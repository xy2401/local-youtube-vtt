WEBVTT
Kind: captions
Language: zh-Hans

00:00:24.640 --> 00:00:29.320
我春天的歌迷欢迎来到另一个

00:00:27.580 --> 00:00:30.790
在此安装弹簧提示

00:00:29.320 --> 00:00:32.980
本周的分期付款，我们将再次

00:00:30.790 --> 00:00:34.420
现在在以前的版本中重新访问我们的套接字

00:00:32.980 --> 00:00:38.110
没有安装弹簧头的安装

00:00:34.420 --> 00:00:40.270
我们在我们的插座，我介绍了

00:00:38.110 --> 00:00:44.650
协议我们的套接字和客户端

00:00:40.270 --> 00:00:47.379
 Facebook开发的内置库

00:00:44.650 --> 00:00:49.629
在反应堆右边，在那个视频中

00:00:47.379 --> 00:00:52.840
我们看着我们说原始的插座

00:00:49.629 --> 00:00:55.570
只是一个低级或套接字而已

00:00:52.840 --> 00:00:58.960
预示着这一天的想法

00:00:55.570 --> 00:01:00.519
当一个甜蜜的日子，我们会得到支持

00:00:58.960 --> 00:01:02.680
在Spring框架中用于我们的插座

00:01:00.519 --> 00:01:04.390
那天本身已经很久了

00:01:02.680 --> 00:01:06.010
最后我的朋友，所以我想

00:01:04.390 --> 00:01:09.549
跟你说说今天是如何使用

00:01:06.010 --> 00:01:11.290
我们带弹簧的插座，看看

00:01:09.549 --> 00:01:13.479
现在这里有什么机会

00:01:11.290 --> 00:01:14.979
我认为是为了快速修订

00:01:13.479 --> 00:01:17.650
一天结束时的插座是

00:01:14.979 --> 00:01:20.080
协议，它是一种跨平台的语言

00:01:17.650 --> 00:01:22.450
设计的不可知协议

00:01:20.080 --> 00:01:24.729
来自Facebook的意见和设计

00:01:22.450 --> 00:01:28.780
来自Netflix的人们如何

00:01:24.729 --> 00:01:31.420
建立高可用性的微服务

00:01:28.780 --> 00:01:33.280
中心系统，这里的目标是

00:01:31.420 --> 00:01:35.950
提供一个应用协议

00:01:33.280 --> 00:01:38.110
以应用程序用例为中心的协议

00:01:35.950 --> 00:01:40.680
与HTTP相反，您可能会

00:01:38.110 --> 00:01:43.150
区分并称呼例如

00:01:40.680 --> 00:01:46.210
这些使用的文档检索协议

00:01:43.150 --> 00:01:47.590
情况是正交的，我认为

00:01:46.210 --> 00:01:49.030
补充对方，但不是

00:01:47.590 --> 00:01:51.060
同样的事情，为此

00:01:49.030 --> 00:01:52.990
该协议必要的原因

00:01:51.060 --> 00:01:56.830
有很多不同的

00:01:52.990 --> 00:01:58.990
 HTTP的局限性

00:01:56.830 --> 00:02:00.760
只是不适合

00:01:58.990 --> 00:02:02.560
同类交流显然

00:02:00.760 --> 00:02:05.050
最大的单一差异化特征

00:02:02.560 --> 00:02:06.790
是它扩展的互操作性

00:02:05.050 --> 00:02:08.800
给使用开放网络的人， 

00:02:06.790 --> 00:02:10.569
这是不容忽视的，当然

00:02:08.800 --> 00:02:13.480
不要睡在那个特殊的功能上

00:02:10.569 --> 00:02:16.780
但是如果你想的话

00:02:13.480 --> 00:02:20.500
支持一些更常见的消息

00:02:16.780 --> 00:02:21.879
交换模式，例如请求

00:02:20.500 --> 00:02:23.620
很自然地做出回应

00:02:21.879 --> 00:02:25.450
与HTTP，但怎么样

00:02:23.620 --> 00:02:27.069
开火忘了，你怎么坐

00:02:25.450 --> 00:02:28.659
你发送消息然后忽略

00:02:27.069 --> 00:02:30.610
响应并获得表现

00:02:28.659 --> 00:02:32.620
生产者和生产者的优化

00:02:30.610 --> 00:02:35.410
与该交易所建立联系的消费者

00:02:32.620 --> 00:02:36.700
关于请求一个或发送一个

00:02:35.410 --> 00:02:38.620
价值，然后得到

00:02:36.700 --> 00:02:41.830
值回无止境

00:02:38.620 --> 00:02:44.200
服务一定可以做到

00:02:41.830 --> 00:02:45.970
和事件，但源服务和事件

00:02:44.200 --> 00:02:48.310
以及嗯

00:02:45.970 --> 00:02:49.989
他们没有头的WebSockets 

00:02:48.310 --> 00:02:51.550
没办法流

00:02:49.989 --> 00:02:54.310
级别的消息

00:02:51.550 --> 00:02:57.129
没有办法永久保留令牌

00:02:54.310 --> 00:03:03.340
例子，所以这个新闻案例是

00:02:57.129 --> 00:03:05.980
只是服务不好这是一种用途

00:03:03.340 --> 00:03:08.200
这种情况在我们的服务中得不到很好的解决

00:03:05.980 --> 00:03:10.060
应用程序以及协议本身

00:03:08.200 --> 00:03:13.299
在平台上另一件事是

00:03:10.060 --> 00:03:14.980
有点有趣的是什么

00:03:13.299 --> 00:03:18.670
双向流式

00:03:14.980 --> 00:03:19.900
你知道继续沟通吗

00:03:18.670 --> 00:03:21.519
您可以为此使用WebSockets 

00:03:19.900 --> 00:03:23.560
再次使它有一些

00:03:21.519 --> 00:03:25.690
局限性，当然不是

00:03:23.560 --> 00:03:27.069
解决我该怎么办的问题

00:03:25.690 --> 00:03:28.810
有一些由

00:03:27.069 --> 00:03:30.579
服务器正确，为什么它必须是

00:03:28.810 --> 00:03:32.170
发出请求的消费者，然后

00:03:30.579 --> 00:03:34.780
发起讨论，为什么不能

00:03:32.170 --> 00:03:36.430
反之亦然

00:03:34.780 --> 00:03:38.200
这个用例，我们知道我们需要

00:03:36.430 --> 00:03:39.810
有点复杂

00:03:38.200 --> 00:03:43.120
我说我不是故意的

00:03:39.810 --> 00:03:45.760
我们已经拥有的一些新权利

00:03:43.120 --> 00:03:47.980
我们已经有了TCP我们已经有了

00:03:45.760 --> 00:03:49.600
这种机制在那里，使

00:03:47.980 --> 00:03:50.799
这只是一个低级的

00:03:49.600 --> 00:03:54.190
很容易在

00:03:50.799 --> 00:03:56.769
脚跟那种低水平的你

00:03:54.190 --> 00:03:59.760
懂运输，那是一回事

00:03:56.769 --> 00:04:02.440
另一件事是我们的坂

00:03:59.760 --> 00:04:03.940
与有效载荷无关的无关紧要

00:04:02.440 --> 00:04:06.430
您想通过电线发送什么

00:04:03.940 --> 00:04:08.470
它是二进制数据，您可以进行

00:04:06.430 --> 00:04:10.989
你自己甚至可以连接任何你喜欢的东西

00:04:08.470 --> 00:04:14.349
跨越那个运输它可以

00:04:10.989 --> 00:04:18.639
是JSON字符串，可能是二进制

00:04:14.349 --> 00:04:21.729
视频或数据流或其他

00:04:18.639 --> 00:04:23.710
这取决于您，因此使用HTTP怎么做

00:04:21.729 --> 00:04:26.380
您在base64上发送图像

00:04:23.710 --> 00:04:28.479
 base64编码二进制数据，然后

00:04:26.380 --> 00:04:30.990
另一方面，您使用base64编码

00:04:28.479 --> 00:04:33.180
它，然后将其读入二进制数据

00:04:30.990 --> 00:04:36.880
尽管事实上，最终

00:04:33.180 --> 00:04:38.620
 HTTP是您的幕后知识吗

00:04:36.880 --> 00:04:39.849
有二进制的权利，所以你去吧

00:04:38.620 --> 00:04:42.310
从二进制到文本

00:04:39.849 --> 00:04:44.979
 HTTP需要哪个表示

00:04:42.310 --> 00:04:46.300
然后进入base64的事情，然后你去

00:04:44.979 --> 00:04:49.330
回到二进制，它超级好

00:04:46.300 --> 00:04:50.770
效率低下，所以您知道这些只是

00:04:49.330 --> 00:04:51.860
我们想要另一种东西

00:04:50.770 --> 00:04:53.930
为了我们

00:04:51.860 --> 00:04:56.180
给你一个内置的框架

00:04:53.930 --> 00:04:58.580
适当的协议，使您能够

00:04:56.180 --> 00:05:02.389
传达可用性权利

00:04:58.580 --> 00:05:04.430
说客户可以问生产者

00:05:02.389 --> 00:05:05.900
消费者可以问生产者

00:05:04.430 --> 00:05:06.680
你有多少正常运行时间

00:05:05.900 --> 00:05:09.020
健康权

00:05:06.680 --> 00:05:11.289
春天，我们有了春天的靴子

00:05:09.020 --> 00:05:13.310
有执行器模块和那个模块

00:05:11.289 --> 00:05:16.849
悬挂在您的网络一侧

00:05:13.310 --> 00:05:18.919
 JMX或HTTP及其它的应用程序

00:05:16.849 --> 00:05:20.560
交流那种

00:05:18.919 --> 00:05:22.669
带外信息

00:05:20.560 --> 00:05:24.289
可用性信息就可以了

00:05:22.669 --> 00:05:25.849
频段健康信息指标

00:05:24.289 --> 00:05:28.669
像客户那样的事情

00:05:25.849 --> 00:05:30.529
如果知道的话可以去排序

00:05:28.669 --> 00:05:32.840
决定是否应该重写

00:05:30.529 --> 00:05:35.240
本身对另一个音符或一些

00:05:32.840 --> 00:05:37.189
某种中介基础设施可以

00:05:35.240 --> 00:05:38.779
还要确定服务是否生病

00:05:37.189 --> 00:05:40.370
好吧，这是必须要做的

00:05:38.779 --> 00:05:42.830
安排正确，这是之间的协议

00:05:40.370 --> 00:05:44.060
春季启动惯例

00:05:42.830 --> 00:05:46.219
执行器和工程师以及

00:05:44.060 --> 00:05:47.539
基础设施等等现在这个问题

00:05:46.219 --> 00:05:49.189
消失了，现在已经内置到

00:05:47.539 --> 00:05:50.779
正确的协议

00:05:49.189 --> 00:05:53.870
期望你会问

00:05:50.779 --> 00:05:55.039
这个问题，并有一个答案，所以我们

00:05:53.870 --> 00:05:57.500
通过使用我们的服务获得很多好处

00:05:55.039 --> 00:05:58.789
套接字，我们的套接字没有几个

00:05:57.500 --> 00:06:01.069
如果您使用常规的话就没事了

00:05:58.789 --> 00:06:02.479
我介绍的底层套接字

00:06:01.069 --> 00:06:04.879
在第一个视频中，您会注意到

00:06:02.479 --> 00:06:07.159
例如，不支持

00:06:04.879 --> 00:06:10.279
正确的路由是什么意思

00:06:07.159 --> 00:06:12.589
客户端连接到端口时很好

00:06:10.279 --> 00:06:15.259
你有一个开放的连接，那就是

00:06:12.589 --> 00:06:16.909
你知道你知道你怎么做

00:06:15.259 --> 00:06:18.469
划分逻辑你如何划分

00:06:16.909 --> 00:06:20.990
将业务逻辑放入不同的处理程序中

00:06:18.469 --> 00:06:23.389
使用HTTP和spring的时候

00:06:20.990 --> 00:06:26.150
通常说好吧，我有一个处理程序， 

00:06:23.389 --> 00:06:28.189
生活在URI的某个路径上

00:06:26.150 --> 00:06:30.139
这些可以帮助网络框架

00:06:28.189 --> 00:06:32.379
确定要调用的组件

00:06:30.139 --> 00:06:34.430
反应很好，没有明显的反应

00:06:32.379 --> 00:06:36.919
开箱即用的支持

00:06:34.430 --> 00:06:40.310
与适当的协议，但春天和

00:06:36.919 --> 00:06:41.689
我们的新消息传递模型提供了

00:06:40.310 --> 00:06:45.080
消息映射注释，而不是

00:06:41.689 --> 00:06:46.339
提供了另一件事

00:06:45.080 --> 00:06:48.560
不支持开箱即用

00:06:46.339 --> 00:06:50.750
它与这种特殊用途无关

00:06:48.560 --> 00:06:53.419
情况是如何融合的

00:06:50.750 --> 00:06:55.669
进行有效载荷你如何发送你

00:06:53.419 --> 00:07:00.560
知道从A点到B点的字节

00:06:55.669 --> 00:07:03.409
在我们的套接字中，您可以发送任何想要的信息

00:07:00.560 --> 00:07:04.550
而且没有办法弄清楚

00:07:03.409 --> 00:07:04.980
您必须要提供什么内容

00:07:04.550 --> 00:07:06.960
编码

00:07:04.980 --> 00:07:07.980
在标题中，您可以做什么，但我们可以

00:07:06.960 --> 00:07:11.610
为您，我们可以做消息

00:07:07.980 --> 00:07:13.200
在春季转换我们的插座

00:07:11.610 --> 00:07:14.460
支持，让我们来看看

00:07:13.200 --> 00:07:16.380
现在，我们对

00:07:14.460 --> 00:07:18.570
那里有什么不在那里

00:07:16.380 --> 00:07:20.040
我们对可能的感觉，让我们

00:07:18.570 --> 00:07:21.570
继续构建一个新的应用程序

00:07:20.040 --> 00:07:23.490
总是用我第二个最喜欢的地方

00:07:21.570 --> 00:07:24.930
互联网从那个春天开始

00:07:23.490 --> 00:07:28.170
我要用弹簧靴哦

00:07:24.930 --> 00:07:29.700
对不起2.20快照，我们来建立

00:07:28.170 --> 00:07:31.410
我是两个模块的生产者和消费者

00:07:29.700 --> 00:07:33.900
将使用are socket支持

00:07:31.410 --> 00:07:35.670
 by的复选框仅在

00:07:33.900 --> 00:07:38.910
我怀疑这是最新的

00:07:35.670 --> 00:07:40.680
现在可用于纹身2.0平方米，但

00:07:38.910 --> 00:07:43.590
现在我只是要约束自己

00:07:40.680 --> 00:07:45.810
到2.2快照，因为它在那里

00:07:43.590 --> 00:07:46.260
因为它不存在两个两个

00:07:45.810 --> 00:07:48.000
一

00:07:46.260 --> 00:07:51.690
好的，所以我要使用反应式网页

00:07:48.000 --> 00:07:54.750
好吧，让我们看看，就是这样

00:07:51.690 --> 00:07:56.190
足以让我们拥有一切

00:07:54.750 --> 00:08:00.780
我们需要引入开发工具， 

00:07:56.190 --> 00:08:05.840
那是制作人命中将产生的

00:08:00.780 --> 00:08:10.880
消费者的打击产生了好，现在

00:08:05.840 --> 00:08:10.880
你是哦制作人

00:08:37.919 --> 00:08:46.859
好的，现在我们有我们的消费者

00:08:41.549 --> 00:08:49.470
就在这里，所以消费者和

00:08:46.859 --> 00:08:50.819
我们要让制片人继续

00:08:49.470 --> 00:08:52.290
左，消费者在右

00:08:50.819 --> 00:08:54.059
我们将要建立的生产方

00:08:52.290 --> 00:08:54.989
我们的套接字服务没有HTTP 

00:08:54.059 --> 00:08:58.220
参与其中，所以我要继续前进， 

00:08:54.989 --> 00:09:00.989
在这里评论一下， 

00:08:58.220 --> 00:09:02.639
那里我们可以，所以现在我们有两个

00:09:00.989 --> 00:09:05.850
应用程序方面，让我们结束这一点

00:09:02.639 --> 00:09:07.439
在这里是生产者，这是

00:09:05.850 --> 00:09:09.209
消费者，我们将开发这些

00:09:07.439 --> 00:09:11.249
串联的东西现在自动

00:09:09.209 --> 00:09:12.689
 Swing Boot的配置将安装

00:09:11.249 --> 00:09:15.540
生产者方面，我们将建立一个

00:09:12.689 --> 00:09:19.019
假设我指定了我们的套接字服务器

00:09:15.540 --> 00:09:23.369
一个端口，因此我们的套接字端口等于

00:09:19.019 --> 00:09:26.339
说7,000，我会偷懒

00:09:23.369 --> 00:09:27.779
初始化很棒，我们就这样

00:09:26.339 --> 00:09:29.910
这是我们的套接字服务器，我们可以

00:09:27.779 --> 00:09:32.069
从消费者方面开始

00:09:29.910 --> 00:09:33.540
将使用我们的套接字请求打开

00:09:32.069 --> 00:09:35.609
自动自动配置不

00:09:33.540 --> 00:09:38.489
为我们提供，但您知道

00:09:35.609 --> 00:09:39.989
提供我们所需的大部分，直到我们

00:09:38.489 --> 00:09:41.429
可以依靠它，所以我要

00:09:39.989 --> 00:09:43.799
付钱，我要在这里创建我们的

00:09:41.429 --> 00:09:45.749
套接字连接，这又是

00:09:43.799 --> 00:09:48.089
相当，你知道这应该很熟悉

00:09:45.749 --> 00:09:50.309
如果你看第一个视频，那么我

00:09:48.089 --> 00:09:54.559
无法承受足够的压力

00:09:50.309 --> 00:10:03.809
注意，这样TCP客户端传输和

00:09:54.559 --> 00:10:06.199
他们做的起跑数据坝数据帧

00:10:03.809 --> 00:10:11.509
一个将成为mime type utils的mime类型

00:10:06.199 --> 00:10:14.279
应用程序Jason utf-8，我们想要

00:10:11.509 --> 00:10:17.699
运输我们要得到什么

00:10:14.279 --> 00:10:20.819
我们需要其他什么我们需要框架吗

00:10:17.699 --> 00:10:23.249
解码器有效负载解码器0复制并

00:10:20.819 --> 00:10:25.049
就是这样，我要使用我们的

00:10:23.249 --> 00:10:28.529
套接字请求者，这就像网络

00:10:25.049 --> 00:10:32.459
来自spring web的客户可以灵活地使用我们的套接字

00:10:28.529 --> 00:10:34.139
请求者还可以

00:10:32.459 --> 00:10:37.069
我要注入我们的插座

00:10:34.139 --> 00:10:40.529
参考，我将使用我的类型

00:10:37.069 --> 00:10:42.029
 utils应用程序的相邻值和

00:10:40.529 --> 00:10:44.129
然后最后我们需要我们的插座

00:10:42.029 --> 00:10:46.980
 Springs Auto的策略对象

00:10:44.129 --> 00:10:48.360
配置欢迎会

00:10:46.980 --> 00:10:50.560
自动等同于我们好吧，所以

00:10:48.360 --> 00:10:53.680
让我们放在那里

00:10:50.560 --> 00:10:56.440
这不必是它需要的值

00:10:53.680 --> 00:10:58.360
成为实际的你知道的对象好吗

00:10:56.440 --> 00:11:01.210
好，所以我们现在就将所有这些

00:10:58.360 --> 00:11:02.890
我们可以建立一个可以

00:11:01.210 --> 00:11:05.200
谈论我们的服务，我们的服务是

00:11:02.890 --> 00:11:10.750
只是我要打电话给的常规控制器

00:11:05.200 --> 00:11:15.100
这是我们的问候，我们看到了

00:11:10.750 --> 00:11:18.870
得到控制器好，我要去

00:11:15.100 --> 00:11:25.960
类型问候类的实体

00:11:18.870 --> 00:11:30.730
请求班级阅读答案好

00:11:25.960 --> 00:11:34.170
我们的请求将使用一个

00:11:30.730 --> 00:11:38.529
要打招呼，这将有一个

00:11:34.170 --> 00:11:43.270
问候好吧，现在非常非常简单，我

00:11:38.529 --> 00:11:46.000
想要记录我们所有的数据

00:11:43.270 --> 00:11:55.260
没有args好加上这些编译时间

00:11:46.000 --> 00:11:55.260
注释很好，现在我们要

00:11:56.040 --> 00:12:05.830
在这里创建一个构建器，它将

00:11:59.010 --> 00:12:11.190
带有确定字符串的读数请求

00:12:05.830 --> 00:12:14.020
我做完这个点后，消息变成这个

00:12:11.190 --> 00:12:19.720
对不起，我希望在响应中不要这样做

00:12:14.020 --> 00:12:22.710
在问候回应这里我们很好

00:12:19.720 --> 00:12:25.839
东西，所以这一步问候等于

00:12:22.710 --> 00:12:31.210
此处的消息信用构造函数

00:12:25.839 --> 00:12:32.620
你知道的一种常见情况

00:12:31.210 --> 00:12:36.040
我们会看到它的名字，我会

00:12:32.620 --> 00:12:44.190
对我们产生回应，所以我们说

00:12:36.040 --> 00:12:48.010
这个点，上面有你好名字

00:12:44.190 --> 00:12:52.029
即时点现在好了，这是一个

00:12:48.010 --> 00:12:55.180
反应好东西好吧，如果你给

00:12:52.029 --> 00:13:00.700
给我们起个名字，我们将创建一个默认的东西

00:12:55.180 --> 00:13:02.320
如果没有，我们会为您服务

00:13:00.700 --> 00:13:03.950
建造者好，所以没有争论

00:13:02.320 --> 00:13:06.980
那个版本

00:13:03.950 --> 00:13:08.600
所以我们走了，我们现在知道了

00:13:06.980 --> 00:13:11.269
我有一个创建的方坯

00:13:08.600 --> 00:13:12.769
迅速反应，我得到了

00:13:11.269 --> 00:13:14.899
请求细节的载体

00:13:12.769 --> 00:13:17.120
现在我要复制一个名字

00:13:14.899 --> 00:13:19.070
粘贴以方便互操作

00:13:17.120 --> 00:13:20.510
到生产者的另一边

00:13:19.070 --> 00:13:23.300
消费者，所以现在两者都相同

00:13:20.510 --> 00:13:25.459
类型显然你需要

00:13:23.300 --> 00:13:27.199
知道我以某种方式开始

00:13:25.459 --> 00:13:30.440
与共同共享的图书馆或其他东西

00:13:27.199 --> 00:13:31.610
喜欢还是不喜欢这个你

00:13:30.440 --> 00:13:32.839
可以创建自己的客户， 

00:13:31.610 --> 00:13:36.290
表示是否足够琐碎

00:13:32.839 --> 00:13:40.670
谁在乎，所以现在我们有了类型

00:13:36.290 --> 00:13:42.560
让我们在这里创建控制器吧

00:13:40.670 --> 00:13:43.910
控制器将让我们

00:13:42.560 --> 00:13:45.230
展示绝对最简单的东西

00:13:43.910 --> 00:13:47.930
可能首先工作

00:13:45.230 --> 00:13:49.279
所以消息映射好了，所有

00:13:47.930 --> 00:13:51.170
我们要做的是我们将返回一个

00:13:49.279 --> 00:13:54.079
单字符串，抱歉不是字符串，并且

00:13:51.170 --> 00:13:58.209
问候响应给出了以下要求

00:13:54.079 --> 00:14:01.399
是类型的问候请求还可以， 

00:13:58.209 --> 00:14:07.459
新的问候响应好吧，它将是

00:14:01.399 --> 00:14:09.019
请求获取名称是绝对的

00:14:07.459 --> 00:14:10.670
最简单的可行的

00:14:09.019 --> 00:14:11.959
您可以看到这不是

00:14:10.670 --> 00:14:13.579
就像我说的路由现在

00:14:11.959 --> 00:14:16.699
春天提供的东西

00:14:13.579 --> 00:14:18.350
说这个标签迎接地图的字符串

00:14:16.699 --> 00:14:20.750
如果要调用该逻辑

00:14:18.350 --> 00:14:22.640
必须传达一些信息

00:14:20.750 --> 00:14:25.339
字符串以一种可以理解的方式

00:14:22.640 --> 00:14:27.410
它们是我们的插座

00:14:25.339 --> 00:14:28.579
请求者将为您做到这一点，那又如何

00:14:27.410 --> 00:14:31.220
我要在这里做，我要创建一个

00:14:28.579 --> 00:14:32.899
客户实际上只是休息

00:14:31.220 --> 00:14:35.180
控制器，因此我们可以实际调用

00:14:32.899 --> 00:14:37.699
在浏览器中查看结果

00:14:35.180 --> 00:14:40.510
好的，所以问候休息控制器

00:14:37.699 --> 00:14:46.240
好了，这会有一个终点

00:14:40.510 --> 00:14:51.170
叫做greet，我们会说

00:14:46.240 --> 00:14:54.319
什么问候回应打招呼

00:14:51.170 --> 00:14:57.110
可变的字符串名称，我要说这个

00:14:54.319 --> 00:15:02.750
点打招呼，因为这个点，我们需要一个

00:14:57.110 --> 00:15:05.180
请求者现在写请求者添加

00:15:02.750 --> 00:15:07.190
给构造函数这个点请求者

00:15:05.180 --> 00:15:10.519
点路线，只是会见面

00:15:07.190 --> 00:15:14.770
当发送一些数据时，数据是

00:15:10.519 --> 00:15:19.250
会成为新的立足点

00:15:14.770 --> 00:15:20.810
新的问候请求和请求

00:15:19.250 --> 00:15:23.930
将具有将要通过的名称

00:15:20.810 --> 00:15:25.970
在那儿，我们期待得到回应

00:15:23.930 --> 00:15:28.130
在这种情况下，它只是一个值，所以

00:15:25.970 --> 00:15:31.430
我们会期待问候类型

00:15:28.130 --> 00:15:33.410
回应好吧，现在让我转一下

00:15:31.430 --> 00:15:34.460
我们已经重启了

00:15:33.410 --> 00:15:35.840
服务让我们确保我已经

00:15:34.460 --> 00:15:41.870
重新启动，我不确定何时阅读

00:15:35.840 --> 00:15:48.050
昨天我们开始了，然后

00:15:41.870 --> 00:15:50.450
在这里，我们将重新启动它，所以现在在

00:15:48.050 --> 00:15:52.990
客户端可以在端口8080上运行

00:15:50.450 --> 00:15:56.080
看到端口8080上有Web服务器

00:15:52.990 --> 00:16:00.590
我这里没有网络服务器

00:15:56.080 --> 00:16:01.400
看起来我摆脱了网络流网络

00:16:00.590 --> 00:16:04.700
塞神

00:16:01.400 --> 00:16:06.110
我确实有Nitti，我们的插座开始了

00:16:04.700 --> 00:16:07.400
另一面我没有MIDI我们

00:16:06.110 --> 00:16:09.440
套接字，因为我没有指定端口

00:16:07.400 --> 00:16:11.270
所以消费者自动配置

00:16:09.440 --> 00:16:13.400
踢进去，但除了能做所有的事

00:16:11.270 --> 00:16:15.770
用于启动Web服务器

00:16:13.400 --> 00:16:19.400
套接字服务器，这很好，因为我

00:16:15.770 --> 00:16:21.530
我可能想例如使用

00:16:19.400 --> 00:16:23.420
配置，但设置

00:16:21.530 --> 00:16:25.640
传输为Web套接字支持

00:16:23.420 --> 00:16:27.020
由我们的spring web flex引擎提供

00:16:25.640 --> 00:16:28.940
例如，这样您就可以实际执行

00:16:27.020 --> 00:16:30.530
例如，通过WebSockets进行套接字和

00:16:28.940 --> 00:16:31.970
春天春天引导自动

00:16:30.530 --> 00:16:34.580
配置可以为您服务

00:16:31.970 --> 00:16:35.840
如果你喜欢，但重点是你知道

00:16:34.580 --> 00:16:37.280
您必须选择加入这些

00:16:35.840 --> 00:16:39.500
不同的功能，如果你在这个

00:16:37.280 --> 00:16:40.550
我想做的就是代理客户

00:16:39.500 --> 00:16:42.590
例如我想要我们的插座

00:16:40.550 --> 00:16:44.870
为我整理工作的策略

00:16:42.590 --> 00:16:46.670
我需要一个客户我们的套接字参考

00:16:44.870 --> 00:16:48.550
但除此之外，一切都是

00:16:46.670 --> 00:16:52.040
已经为我提供了

00:16:48.550 --> 00:16:58.360
好吧，让我们看看，我们去

00:16:52.040 --> 00:17:01.520
本地主机欢迎世界，我

00:16:58.360 --> 00:17:05.380
今天没有提供名字我的名字在哪里

00:17:01.520 --> 00:17:05.380
哦，打招呼

00:17:06.760 --> 00:17:11.320
重新启动名称

00:17:16.819 --> 00:17:24.600
好吧，随着我的增加我在问候

00:17:22.770 --> 00:17:28.740
是刷新浏览器，您看到

00:17:24.600 --> 00:17:30.330
时间戳不断增加可以

00:17:28.740 --> 00:17:32.160
好吧，那进进出出只是

00:17:30.330 --> 00:17:33.930
一值一值

00:17:32.160 --> 00:17:36.450
这些值正在发送的场景

00:17:33.930 --> 00:17:38.460
周围当然是有效载荷

00:17:36.450 --> 00:17:39.630
也可以进行流式传输，例如

00:17:38.460 --> 00:17:42.420
假设我想要一个端点

00:17:39.630 --> 00:17:47.250
那是端点服务

00:17:42.420 --> 00:17:52.610
产生媒体类型右类型点

00:17:47.250 --> 00:17:53.910
文本事件流的值为weet SS e 

00:17:52.610 --> 00:17:59.720
名称

00:17:53.910 --> 00:17:59.720
好的，所以阅读反应的发布者

00:18:00.050 --> 00:18:10.890
路径变量字符串名称在这里

00:18:06.060 --> 00:18:13.290
要用这个东西让你流血

00:18:10.890 --> 00:18:15.060
知道流媒体好吧，我要打电话给

00:18:13.290 --> 00:18:17.850
迎接流端点和我们的数据

00:18:15.060 --> 00:18:22.830
当我们得到时，将像以前一样发送

00:18:17.850 --> 00:18:27.230
回来，好吧，所以就换个好吧

00:18:22.830 --> 00:18:27.230
在这种情况下检索

00:18:27.890 --> 00:18:34.590
回应，所以我称我们的

00:18:33.300 --> 00:18:36.870
使用我们的插座的插座终点

00:18:34.590 --> 00:18:38.730
请求者，我们知道它指向

00:18:36.870 --> 00:18:40.800
指向端口7000，因为那是

00:18:38.730 --> 00:18:42.030
我们现在在服务器上指定了

00:18:40.800 --> 00:18:44.520
我需要实际提供

00:18:42.030 --> 00:18:49.760
终结问候流终结点

00:18:44.520 --> 00:18:49.760
我会在邮件映射中说

00:18:49.970 --> 00:19:02.970
问候反应流杂草流

00:18:55.940 --> 00:19:07.380
迎接要求，我们的工作是说助焊剂

00:19:02.970 --> 00:19:11.760
流中的点生成新闻

00:19:07.380 --> 00:19:13.740
起火，然后延迟元素

00:19:11.760 --> 00:19:15.690
几秒钟的持续时间

00:19:13.740 --> 00:19:18.240
错开结果，你看到我这样做

00:19:15.690 --> 00:19:20.930
当我介绍一项服务和事件时

00:19:18.240 --> 00:19:24.210
例如，新的问候回应

00:19:20.930 --> 00:19:26.820
然后名称将从

00:19:24.210 --> 00:19:28.570
要求，就像现在这样

00:19:26.820 --> 00:19:30.880
我们要迭代

00:19:28.570 --> 00:19:32.880
而且您会提供很多价值

00:19:30.880 --> 00:19:36.790
时间戳会增加

00:19:32.880 --> 00:19:38.290
好吧，同样的事情打招呼，流打招呼

00:19:36.790 --> 00:19:40.210
流，我要发回发布者

00:19:38.290 --> 00:19:42.100
的问候回应，其结果将

00:19:40.210 --> 00:19:56.640
每隔一秒钟就会被错开

00:19:42.100 --> 00:20:04.110
一个新的，好吧，好吧，现在我们去这里

00:19:56.640 --> 00:20:05.500
流之前我说过我说过SSE世界

00:20:04.110 --> 00:20:07.510
你去

00:20:05.500 --> 00:20:08.650
所以我们正在流式传输数据

00:20:07.510 --> 00:20:10.900
通过网络实际流式传输数据

00:20:08.650 --> 00:20:13.060
这里不使用HTTP或类似的东西

00:20:10.900 --> 00:20:14.890
那是我们有一个网关的地方

00:20:13.060 --> 00:20:17.800
作为消费者的节点，它有一个

00:20:14.890 --> 00:20:20.230
客户端和用户界面是

00:20:17.800 --> 00:20:22.180
 HTTP API但实际逻辑实际

00:20:20.230 --> 00:20:24.010
数据正在从另一个流式传输

00:20:22.180 --> 00:20:25.780
我们的套接字服务器，我们得到了它

00:20:24.010 --> 00:20:27.250
只是它是反应性的

00:20:25.780 --> 00:20:28.600
通过所有这些很好的方式

00:20:27.250 --> 00:20:31.930
操作员和我可以使用背压

00:20:28.600 --> 00:20:34.150
我可以做所有这件事，我认为

00:20:31.930 --> 00:20:36.160
非常好的安排

00:20:34.150 --> 00:20:37.990
你实际上可以做一些非常

00:20:36.160 --> 00:20:39.880
有趣的事情，这不是更多

00:20:37.990 --> 00:20:41.710
比HTTP东西更难表达

00:20:39.880 --> 00:20:43.600
事实恰恰相反

00:20:41.710 --> 00:20:45.340
容易一些，你知道一些

00:20:43.600 --> 00:20:47.530
是春天，所以我们有

00:20:45.340 --> 00:20:49.240
对于句柄错误，您有一个不错的方法

00:20:47.530 --> 00:20:53.940
为此，您可以说好吧，让我们

00:20:49.240 --> 00:20:58.390
说我想退还的出版商

00:20:53.940 --> 00:21:03.900
给定的问候响应错误处理程序

00:20:58.390 --> 00:21:07.240
法律论据例外，我可以，所以

00:21:03.900 --> 00:21:10.630
助焊剂点刚刚

00:21:07.240 --> 00:21:11.830
问候回应点与问候哦

00:21:10.630 --> 00:21:14.320
没有

00:21:11.830 --> 00:21:16.180
所以如果出问题了

00:21:14.320 --> 00:21:18.340
端点引发非法论点

00:21:16.180 --> 00:21:19.510
出于某种原因的例外，那么这

00:21:18.340 --> 00:21:21.310
会打电话给我，我有机会

00:21:19.510 --> 00:21:25.420
提供对默认值的响应

00:21:21.310 --> 00:21:27.820
我想要而不是宁愿回应

00:21:25.420 --> 00:21:29.200
而不是向用户返回气泡

00:21:27.820 --> 00:21:29.830
所以我们在这里创建该端点

00:21:29.200 --> 00:21:34.110
信息

00:21:29.830 --> 00:21:38.710
映射错误好吧，这将是

00:21:34.110 --> 00:21:40.210
阅读响应错误，我要做的就是

00:21:38.710 --> 00:21:42.760
然后他们说返回单声道错误

00:21:40.210 --> 00:21:50.410
新法律

00:21:42.760 --> 00:21:54.220
论点哦，那会变的

00:21:50.410 --> 00:21:55.690
触摸错误，你可以，所以那是

00:21:54.220 --> 00:21:57.370
我在客户端的错误端点

00:21:55.690 --> 00:21:58.270
我们将创建一个端点

00:21:57.370 --> 00:22:05.290
可以打电话

00:21:58.270 --> 00:22:07.600
因此错误的发布者问候响应和

00:22:05.290 --> 00:22:13.240
我们当然会从这边开始

00:22:07.600 --> 00:22:19.059
我们会说错误和这个点请求者

00:22:13.240 --> 00:22:20.740
点路径错误点检索想要

00:22:19.059 --> 00:22:23.290
在有效负载中不发送任何内容，因此它将

00:22:20.740 --> 00:22:25.540
只是单点空我猜然后

00:22:23.290 --> 00:22:29.260
检索任何我们不在乎的权利

00:22:25.540 --> 00:22:36.429
问候响应点类，然后我们

00:22:29.260 --> 00:22:41.140
可以重新启动服务器，然后

00:22:36.429 --> 00:22:42.760
浏览器转播，它说哦不

00:22:41.140 --> 00:22:44.530
我们实际上得到了默认的后备

00:22:42.760 --> 00:22:46.690
我们想要正确的价值是

00:22:44.530 --> 00:22:48.700
实际上非常有用，所以现在我们有了

00:22:46.690 --> 00:22:50.559
我们的插座，我们已经看到了我们如何

00:22:48.700 --> 00:22:55.090
可以使用消息映射功能

00:22:50.559 --> 00:22:57.490
在Spring Framework 5.2和spring中

00:22:55.090 --> 00:22:58.870
启动2.2，我们研究了如何公开

00:22:57.490 --> 00:23:01.059
端点使用消息映射

00:22:58.870 --> 00:23:02.799
这些注解相当熟悉，如果

00:23:01.059 --> 00:23:06.250
您曾经使用过Web套接字支持

00:23:02.799 --> 00:23:07.900
在春天，还有更多

00:23:06.250 --> 00:23:10.240
要完成的工作，你知道事情是

00:23:07.900 --> 00:23:12.070
激动，我很高兴看到这片土地

00:23:10.240 --> 00:23:14.470
和Spring框架已经可以工作

00:23:12.070 --> 00:23:17.919
已经走了，他的是

00:23:14.470 --> 00:23:20.530
急于支持我们的插座

00:23:17.919 --> 00:23:22.690
和Spring Cloud Gateway，因此我们的

00:23:20.530 --> 00:23:24.610
 Spring Cog网关中的套接字支持

00:23:22.690 --> 00:23:26.230
好吧，我的意思是你可以想象一些

00:23:24.610 --> 00:23:29.020
您可以想象这里的可能性

00:23:26.230 --> 00:23:31.240
拥有一台服务器的示例

00:23:29.020 --> 00:23:33.010
完全锁定它是一个黑匣子

00:23:31.240 --> 00:23:34.059
然后启动与

00:23:33.010 --> 00:23:36.040
网关，因为您可以拥有

00:23:34.059 --> 00:23:39.130
有状态的万岁连接

00:23:36.040 --> 00:23:41.500
那种双向通讯

00:23:39.130 --> 00:23:42.640
网关可以保持开放连接

00:23:41.500 --> 00:23:44.380
从每个微服务中

00:23:42.640 --> 00:23:46.570
伸向Erol门，所以

00:23:44.380 --> 00:23:46.990
网关未连接到微型

00:23:46.570 --> 00:23:49.690
服务

00:23:46.990 --> 00:23:51.220
无论哪种方式都没有

00:23:49.690 --> 00:23:54.250
进入那些微服务，所以

00:23:51.220 --> 00:23:56.530
他们迫在眉睫，然后他们

00:23:54.250 --> 00:23:59.380
有能力

00:23:56.530 --> 00:24:01.410
网关可以是例如

00:23:59.380 --> 00:24:03.730
路由器可能会说哦，我有这个

00:24:01.410 --> 00:24:06.460
与此微服务的连接

00:24:03.730 --> 00:24:08.980
打开我问它有足够的容量

00:24:06.460 --> 00:24:11.020
足够的可用性和足够的

00:24:08.980 --> 00:24:12.760
有足够的时间健康，我该怎么办

00:24:11.020 --> 00:24:14.500
将请求正确路由到它，以便可以

00:24:12.760 --> 00:24:16.660
我是说它有能力问

00:24:14.500 --> 00:24:19.180
这个问题，然后无缝地你

00:24:16.660 --> 00:24:21.250
知道将流从一个节点移到

00:24:19.180 --> 00:24:23.680
另一个权利真的很多

00:24:21.250 --> 00:24:25.090
有趣的可能性在这里

00:24:23.680 --> 00:24:27.460
最好的事情还是一如既往，但我希望

00:24:25.090 --> 00:24:29.830
你给这个东西一个尝试反馈， 

00:24:27.460 --> 00:24:31.720
让我知道，不用我的朋友谢谢

00:24:29.830 --> 00:24:33.960
观看，一如既往，我们会见到你

00:24:31.720 --> 00:24:33.960
下一个

00:24:39.410 --> 00:24:41.470
您

