WEBVTT
Kind: captions
Language: zh-Hans

00:00:27.430 --> 00:00:31.820
 iSpring粉丝欢迎来到另一个

00:00:29.689 --> 00:00:33.650
在此安装弹簧提示

00:00:31.820 --> 00:00:35.239
分期付款，我们来看看

00:00:33.650 --> 00:00:37.010
暂时只为

00:00:35.239 --> 00:00:38.690
当下没有那么多

00:00:37.010 --> 00:00:40.850
与春天有关，但我认为是

00:00:38.690 --> 00:00:43.190
鉴于

00:00:40.850 --> 00:00:45.769
春天到哪里去了， 

00:00:43.190 --> 00:00:47.960
这有什么机会

00:00:45.769 --> 00:00:51.670
特殊的技术，我们将

00:00:47.960 --> 00:00:55.309
看看我们的插座，现在我们的插座是

00:00:51.670 --> 00:00:56.600
我们可以整天度过的

00:00:55.309 --> 00:01:01.280
真的可以花一整天

00:00:56.600 --> 00:01:04.729
说话，但我们的插座，但简短地我们

00:01:01.280 --> 00:01:09.470
套接字是已开发的协议

00:01:04.729 --> 00:01:11.450
在Facebook上，这是使用的结果

00:01:09.470 --> 00:01:14.090
在Facebook需要能够

00:01:11.450 --> 00:01:17.119
描述一个系统之间的插管

00:01:14.090 --> 00:01:21.049
平台和语言不可知的方式

00:01:17.119 --> 00:01:23.180
一个协议，正如我所说的运行时

00:01:21.049 --> 00:01:24.259
和plastun平台无关的

00:01:23.180 --> 00:01:27.049
在Java上运行是否重要

00:01:24.259 --> 00:01:28.609
 or.net或其他多个

00:01:27.049 --> 00:01:30.829
消费方式

00:01:28.609 --> 00:01:34.340
这是一个模仿的协议

00:01:30.829 --> 00:01:39.049
大型用例的种类

00:01:34.340 --> 00:01:41.329
服务，因此

00:01:39.049 --> 00:01:43.219
它本地集成了反应式

00:01:41.329 --> 00:01:45.560
在协议层流式传输概念

00:01:43.219 --> 00:01:47.479
在协议级别上实际上是

00:01:45.560 --> 00:01:51.590
支持反应流的协议

00:01:47.479 --> 00:01:53.299
概念和Facebook中的

00:01:51.590 --> 00:01:53.600
其中的实现

00:01:53.299 --> 00:01:55.219
三

00:01:53.600 --> 00:01:57.380
现在有一个C ++ 

00:01:55.219 --> 00:02:00.170
 JavaScript和Java的Java 

00:01:57.380 --> 00:02:03.590
基于自然的实现

00:02:00.170 --> 00:02:06.139
在反应堆等课程上

00:02:03.590 --> 00:02:09.410
春季队反应如何

00:02:06.139 --> 00:02:10.520
用于植入的插管库

00:02:09.410 --> 00:02:15.140
并支持反应流

00:02:10.520 --> 00:02:19.940
规格和问题

00:02:15.140 --> 00:02:23.120
当然是为什么插座正确，为什么，为什么

00:02:19.940 --> 00:02:25.430
为什么这种解决方案可能看起来像

00:02:23.120 --> 00:02:26.690
当你已经挤满了空间

00:02:25.430 --> 00:02:27.730
考虑我们在这里想要做什么

00:02:26.690 --> 00:02:31.190
我们正在尝试整合不同的

00:02:27.730 --> 00:02:33.580
绝望的不同

00:02:31.190 --> 00:02:36.590
服务和系统等

00:02:33.580 --> 00:02:38.330
反应性流，我想我们都可以

00:02:36.590 --> 00:02:40.760
同意它提供了良好的基础

00:02:38.330 --> 00:02:41.420
用Java建模集成

00:02:40.760 --> 00:02:43.790
放松

00:02:41.420 --> 00:02:45.980
反应流依赖异步

00:02:43.790 --> 00:02:47.870
消息传递以建立边界

00:02:45.980 --> 00:02:51.890
组件之间并确保松动

00:02:47.870 --> 00:02:53.120
复杂的耦合还有其他

00:02:51.890 --> 00:02:57.200
好处就在这里

00:02:53.120 --> 00:03:00.230
透明有隔离等，并且

00:02:57.200 --> 00:03:02.480
还有一个你真正知道的

00:03:00.230 --> 00:03:04.340
功能风格有一流的

00:03:02.480 --> 00:03:06.350
表示错误的方式

00:03:04.340 --> 00:03:12.220
处理和管理数据的方式

00:03:06.350 --> 00:03:14.240
管理和处理错误，因为您有

00:03:12.220 --> 00:03:16.610
消息传递您有异步

00:03:14.240 --> 00:03:18.710
集成之间的某种解耦

00:03:16.610 --> 00:03:24.010
您可以轻松地划分界限

00:03:18.710 --> 00:03:26.210
现在将消息传递模式应用于

00:03:24.010 --> 00:03:29.240
可以使用反应式代码的东西

00:03:26.210 --> 00:03:30.890
像负载平衡一样，您可以

00:03:29.240 --> 00:03:33.170
横向扩展就可以了

00:03:30.890 --> 00:03:35.540
 pub / sub，你可以做，你可以做

00:03:33.170 --> 00:03:36.650
通过推回生产者进行控制

00:03:35.540 --> 00:03:39.170
的消息，所以你有很多

00:03:36.650 --> 00:03:41.870
反应堆中非常有趣的想法

00:03:39.170 --> 00:03:44.900
流规范，这些是

00:03:41.870 --> 00:03:49.370
你想要的东西

00:03:44.900 --> 00:03:51.320
应用层协议现在有些

00:03:49.370 --> 00:03:52.910
可能也会看HTTP并说得好

00:03:51.320 --> 00:03:55.340
那不是应用层协议

00:03:52.910 --> 00:03:58.790
答案是不，不是

00:03:55.340 --> 00:04:01.970
这是一个更好的HTTP HTTP 

00:03:58.790 --> 00:04:04.820
是更有效的HTTP，但最终

00:04:01.970 --> 00:04:08.030
专为以下目的设计的HTTP策略

00:04:04.820 --> 00:04:10.550
文档检索所表达的动词

00:04:08.030 --> 00:04:14.000
在地图上有文档检索此

00:04:10.550 --> 00:04:15.350
不是应用层协议

00:04:14.000 --> 00:04:17.720
真的不支持什么

00:04:15.350 --> 00:04:20.900
要求回应有概念

00:04:17.720 --> 00:04:23.380
的推销承诺会纠正这个想法， 

00:04:20.900 --> 00:04:25.970
您可以抢先寄出

00:04:23.380 --> 00:04:27.830
信息传给客户，但那

00:04:25.970 --> 00:04:30.400
仍然需要一个明确的请求

00:04:27.830 --> 00:04:32.810
不是真正的双向通讯

00:04:30.400 --> 00:04:35.150
如果你想做类似的事情

00:04:32.810 --> 00:04:37.130
一劳永逸，你做不到

00:04:35.150 --> 00:04:40.520
这不是那么容易，因为你有

00:04:37.130 --> 00:04:41.600
您是Web服务器的机器

00:04:40.520 --> 00:04:43.960
仍将处理响应

00:04:41.600 --> 00:04:47.479
即使客户随后无视它

00:04:43.960 --> 00:04:51.740
所以您遇到问题并使用HTTP 

00:04:47.479 --> 00:04:55.759
对于应用程序级别而言， 

00:04:51.740 --> 00:05:02.599
我们的套接字网站解释了一些

00:04:55.759 --> 00:05:04.190
这些，但基本上有一些

00:05:02.599 --> 00:05:05.960
有一些问题

00:05:04.190 --> 00:05:08.479
从尝试使用HTTP冒泡

00:05:05.960 --> 00:05:11.360
这样一来，当您执行HTTP 1时

00:05:08.479 --> 00:05:12.770
点X，您会知道很多

00:05:11.360 --> 00:05:14.750
行阻塞，我们实际上是唯一的

00:05:12.770 --> 00:05:16.310
一个请求可以在一个

00:05:14.750 --> 00:05:18.110
一次连接不是

00:05:16.310 --> 00:05:20.300
以及当你时的局面

00:05:18.110 --> 00:05:22.460
有大规模，你需要能够

00:05:20.300 --> 00:05:25.639
排队，然后处理一堆

00:05:22.460 --> 00:05:27.979
工作尽可能是1.1 

00:05:25.639 --> 00:05:29.599
试图用流水线解决这个问题，但

00:05:27.979 --> 00:05:31.370
当然，它并没有完全解决

00:05:29.599 --> 00:05:34.669
问题大或反应慢会

00:05:31.370 --> 00:05:36.110
仍然阻止其他人

00:05:34.669 --> 00:05:37.819
流水线很难团队合作

00:05:36.110 --> 00:05:40.009
错误地，因为你有很多

00:05:37.819 --> 00:05:42.650
中间的中间件

00:05:40.009 --> 00:05:44.270
在管道中传输许多中间件

00:05:42.650 --> 00:05:46.009
在不同的生产者之间

00:05:44.270 --> 00:05:47.150
不一定知道的消费者

00:05:46.009 --> 00:05:49.699
您正在尝试做什么，以便他们可以

00:05:47.150 --> 00:05:52.039
他们最终可能会尝试代理

00:05:49.699 --> 00:05:55.759
例子不正确等等，所以我们

00:05:52.039 --> 00:05:56.900
然后看到有很多

00:05:55.759 --> 00:05:59.990
人们所依赖的启发式

00:05:56.900 --> 00:06:01.400
显然，多路复用修复了

00:05:59.990 --> 00:06:06.520
这可以让你拥有多个

00:06:01.400 --> 00:06:08.419
同时请求飞行中，但

00:06:06.520 --> 00:06:10.610
我们仍然没有我们需要的一切

00:06:08.419 --> 00:06:13.550
是的，我们还没有您拥有的一切

00:06:10.610 --> 00:06:14.930
需要，最终我们需要支持

00:06:13.550 --> 00:06:19.580
用于持久连接

00:06:14.930 --> 00:06:20.990
是的，所以持久连接有助于

00:06:19.580 --> 00:06:23.659
您减少开门次数

00:06:20.990 --> 00:06:26.030
一次正确的连接

00:06:23.659 --> 00:06:27.680
太多的开放连接是一件坏事

00:06:26.030 --> 00:06:29.030
因为这意味着您的网络

00:06:27.680 --> 00:06:30.979
基础设施现在正试图应对

00:06:29.030 --> 00:06:33.650
与拥挤，拥挤可以

00:06:30.979 --> 00:06:35.419
惩罚本来乖巧的人

00:06:33.650 --> 00:06:37.069
在同一环境中运行的应用程序

00:06:35.419 --> 00:06:39.020
在同一空间中的区域，因此您

00:06:37.069 --> 00:06:41.569
实质上是从其他地方窃取系统

00:06:39.020 --> 00:06:43.280
表现更好的应用程序

00:06:41.569 --> 00:06:47.330
这些都是有问题的问题

00:06:43.280 --> 00:06:49.819
与HTTP还有另一个问题

00:06:47.330 --> 00:06:51.199
只是作为一个玛丽而已

00:06:49.819 --> 00:06:53.419
简单，它支持请求响应

00:06:51.199 --> 00:06:56.509
基本上，如果你想做饱

00:06:53.419 --> 00:06:58.430
你知道的双向通讯

00:06:56.509 --> 00:07:00.199
使用HTTP无法做到这一点，所以您

00:06:58.430 --> 00:07:02.539
可以通过WebSockets在Web上实现

00:07:00.199 --> 00:07:03.740
例如WebSockets是一个

00:07:02.539 --> 00:07:05.590
您可能会做的有趣的选择

00:07:03.740 --> 00:07:09.770
像服务器这样的事件可以很好地发送事件

00:07:05.590 --> 00:07:11.170
 websockets提供消息培训

00:07:09.770 --> 00:07:13.790
就这样提供

00:07:11.170 --> 00:07:15.290
线上的有效载荷划分

00:07:13.790 --> 00:07:17.210
让它让你说这是一个

00:07:15.290 --> 00:07:18.590
整个事情就是这样，它没有给

00:07:17.210 --> 00:07:20.180
您还有其他应用程序级别的顾虑

00:07:18.590 --> 00:07:23.060
由开发人员来决定

00:07:20.180 --> 00:07:25.100
您可能会发送服务器的地址

00:07:23.060 --> 00:07:28.310
事件，这是一个简单的协议， 

00:07:25.100 --> 00:07:32.090
是文字和多孔的，你知道巴马

00:07:28.310 --> 00:07:33.890
苛刻的要求

00:07:32.090 --> 00:07:35.570
做消息框架，它仅用于

00:07:33.890 --> 00:07:38.180
一个方向是服务器端到客户端

00:07:35.570 --> 00:07:39.590
但这有点像

00:07:38.180 --> 00:07:42.820
有趣的是它也需要

00:07:39.590 --> 00:07:45.560
需要正确的文字，这是你必须

00:07:42.820 --> 00:07:49.310
以某种方式编码二进制数据

00:07:45.560 --> 00:07:50.390
用字符表示，所以我们有

00:07:49.310 --> 00:07:52.370
所有这些问题就这些

00:07:50.390 --> 00:07:55.220
有点像小问题

00:07:52.370 --> 00:07:57.590
他们特别庞大，但你知道

00:07:55.220 --> 00:08:00.230
死亡人数减少了一千

00:07:57.590 --> 00:08:03.290
尤其重要的是在Google和

00:08:00.230 --> 00:08:04.640
 Facebook和Netflix现在可以扩展，但是

00:08:03.290 --> 00:08:07.010
那对你来说可能也很重要

00:08:04.640 --> 00:08:09.380
特别是因为正如我所说的那样

00:08:07.010 --> 00:08:11.390
超出带宽和

00:08:09.380 --> 00:08:14.770
效率，我们只是那种

00:08:11.390 --> 00:08:16.790
 HTTP权限的有限性和有限性

00:08:14.770 --> 00:08:18.680
如果我要提出要求怎么办？ 

00:08:16.790 --> 00:08:21.200
然后就把它放在那里

00:08:18.680 --> 00:08:22.280
请求而没有得到回应我不是

00:08:21.200 --> 00:08:23.960
对回应感兴趣，我不是

00:08:22.280 --> 00:08:25.550
对确认感兴趣，等等

00:08:23.960 --> 00:08:27.380
没关系，那是一个非常

00:08:25.550 --> 00:08:29.150
常见的事情和消息

00:08:27.380 --> 00:08:30.890
架构和优化

00:08:29.150 --> 00:08:32.810
您可以在基础设施上进行

00:08:30.890 --> 00:08:35.030
你知道请求只是

00:08:32.810 --> 00:08:37.040
意欲被接受但从未

00:08:35.030 --> 00:08:41.030
对失去的权利做出回应

00:08:37.040 --> 00:08:43.340
那里的机会也差不多

00:08:41.030 --> 00:08:44.500
你知道发送大量数据

00:08:43.340 --> 00:08:49.310
再次，如果你想发送无限

00:08:44.500 --> 00:08:51.530
数据流，那么你就有点

00:08:49.310 --> 00:08:53.870
泡菜在这里，你啊WebSockets是

00:08:51.530 --> 00:08:57.080
这里的一个选择，但同样有一些

00:08:53.870 --> 00:08:59.840
限制，然后如果您想

00:08:57.080 --> 00:09:01.900
做服务器端推送和客户端推送

00:08:59.840 --> 00:09:03.920
你知道你想拥有一个频道

00:09:01.900 --> 00:09:05.810
双向渠道

00:09:03.920 --> 00:09:07.670
双方都穿可能发送

00:09:05.810 --> 00:09:09.230
无限的数据流再次

00:09:07.670 --> 00:09:11.830
可能在这里使用WebSockets，但再次

00:09:09.230 --> 00:09:14.750
列出您错过的申请

00:09:11.830 --> 00:09:16.160
语义具有应用程序级别的排序

00:09:14.750 --> 00:09:20.519
的

00:09:16.160 --> 00:09:26.730
框架语义等等

00:09:20.519 --> 00:09:30.329
以及HTTP，我们已经习惯了

00:09:26.730 --> 00:09:32.220
考虑它或者是

00:09:30.329 --> 00:09:34.709
一个响应或多个响应

00:09:32.220 --> 00:09:36.240
就像使用WebSockets一样，非常容易

00:09:34.709 --> 00:09:37.980
或服务，这很容易

00:09:36.240 --> 00:09:41.279
说我要发送一个潜在的

00:09:37.980 --> 00:09:42.750
无限的数据流与我

00:09:41.279 --> 00:09:44.910
这些应用程序将使用JSON 

00:09:42.750 --> 00:09:46.649
 JSON发送此的一个有限数组

00:09:44.910 --> 00:09:48.240
有八个记录的数据很好

00:09:46.649 --> 00:09:50.009
无需区分

00:09:48.240 --> 00:09:51.600
那里可能只是我发送一张记录

00:09:50.009 --> 00:09:53.819
我寄一千，如果我寄一

00:09:51.600 --> 00:09:55.230
一千然后我把它分块发送

00:09:53.819 --> 00:09:56.879
这意味着我不必等待

00:09:55.230 --> 00:09:58.560
整个反应积累起来我可以

00:09:56.879 --> 00:10:00.240
尽快开始处理

00:09:58.560 --> 00:10:02.100
可能这使一些非常

00:10:00.240 --> 00:10:03.480
特别有趣的可能性

00:10:02.100 --> 00:10:05.879
在带宽受限的环境中

00:10:03.480 --> 00:10:08.939
移动环境等

00:10:05.879 --> 00:10:11.720
我们在HTTP和其他版本中缺少的

00:10:08.939 --> 00:10:15.389
其他协议是你知道的

00:10:11.720 --> 00:10:18.870
基本的应用程序流程

00:10:15.389 --> 00:10:20.430
反应堆的控制保证

00:10:18.870 --> 00:10:22.439
流编写规范以具有

00:10:20.430 --> 00:10:23.730
你如何将你推回去

00:10:22.439 --> 00:10:26.189
生产者你如何施加背压

00:10:23.730 --> 00:10:28.290
当你确实背压

00:10:26.189 --> 00:10:30.389
你知道你真的可以放慢脚步

00:10:28.290 --> 00:10:31.860
客户的消费率

00:10:30.389 --> 00:10:33.689
数据的使用者会减慢速度

00:10:31.860 --> 00:10:36.089
生产者的消费

00:10:33.689 --> 00:10:38.699
少要求或少要求

00:10:36.089 --> 00:10:40.199
记录下一个响应

00:10:38.699 --> 00:10:41.579
要做一件事，但是有

00:10:40.199 --> 00:10:50.459
其他方向也正确

00:10:41.579 --> 00:10:53.899
方向是如果我是制片人

00:10:50.459 --> 00:10:57.689
可以发送信息给客户

00:10:53.899 --> 00:10:59.309
向消费者表明，我可以

00:10:57.689 --> 00:11:02.490
发送信息给消费者

00:10:59.309 --> 00:11:04.949
指示我的空房状况如何

00:11:02.490 --> 00:11:07.410
我有很多能力，你知道我的

00:11:04.949 --> 00:11:09.269
正常运行时间，您知道任何有趣的事情

00:11:07.410 --> 00:11:10.860
信息，无论我想要什么

00:11:09.269 --> 00:11:13.860
能够传达给

00:11:10.860 --> 00:11:15.899
消费者给我一个想法

00:11:13.860 --> 00:11:18.240
回应其要求的能力

00:11:15.899 --> 00:11:20.370
将启用负载平衡模式

00:11:18.240 --> 00:11:22.680
将使路由讨论和

00:11:20.370 --> 00:11:25.199
正确的决定是这个

00:11:22.680 --> 00:11:26.699
沟通是应该的

00:11:25.199 --> 00:11:28.500
在协议层进行处理

00:11:26.699 --> 00:11:30.630
我们经常不得不阅读

00:11:28.500 --> 00:11:33.990
对的所以把它放进去会更好

00:11:30.630 --> 00:11:35.190
协议本身，所以您可以看到

00:11:33.990 --> 00:11:36.360
这里有很多用例

00:11:35.190 --> 00:11:38.370
差不多有一千

00:11:36.360 --> 00:11:42.300
解决这些问题的不同方法

00:11:38.370 --> 00:11:44.430
问题，但我想某些时候

00:11:42.300 --> 00:11:46.920
点Facebook只是说看我们

00:11:44.430 --> 00:11:48.330
试图嫁接在HTTP之上

00:11:46.920 --> 00:11:51.480
 WebSockets和所有其他这些东西

00:11:48.330 --> 00:11:53.250
应用层关注何时

00:11:51.480 --> 00:11:56.010
并不是为了这个，所以让我们

00:11:53.250 --> 00:12:00.750
尝试并更有效地解决

00:11:56.010 --> 00:12:03.660
不同的方式，以便我们的套接字寻求

00:12:00.750 --> 00:12:05.250
减少感知的延迟并

00:12:03.660 --> 00:12:06.240
通过提高系统效率

00:12:05.250 --> 00:12:09.000
支持非阻塞

00:12:06.240 --> 00:12:11.190
双工异步应用程序通信

00:12:09.000 --> 00:12:12.360
具有多个流量控制

00:12:11.190 --> 00:12:15.930
来自多种不同的运输

00:12:12.360 --> 00:12:18.390
减少的语言减少了硬件

00:12:15.930 --> 00:12:20.190
通过增加CPU和内存来减少占用空间

00:12:18.390 --> 00:12:22.830
通过使用二进制效率

00:12:20.190 --> 00:12:24.630
编码并避免重复工作

00:12:22.830 --> 00:12:27.120
允许持久连接

00:12:24.630 --> 00:12:30.240
同样，我们避免在

00:12:27.120 --> 00:12:32.520
关联往返

00:12:30.240 --> 00:12:34.950
是的，我们减少了计算时间

00:12:32.520 --> 00:12:36.450
使用二进制编码，我们分配较少

00:12:34.950 --> 00:12:39.420
内存并减少垃圾收集

00:12:36.450 --> 00:12:42.510
这样花费，所以我们的插座有很多

00:12:39.420 --> 00:12:44.840
的好处，最终只是

00:12:42.510 --> 00:12:47.190
第五和第六层或tcp / ip 

00:12:44.840 --> 00:12:48.900
应用层协议，我认为

00:12:47.190 --> 00:12:50.580
这使其成为一个不错的选择

00:12:48.900 --> 00:12:52.020
应用程序开发人员不是唯一的

00:12:50.580 --> 00:12:54.390
您仍然可以使用休息的方式，您可以看到

00:12:52.020 --> 00:12:56.670
您使用HTTP很好，这有很多

00:12:54.390 --> 00:12:59.040
那里好东西，但这是一个很好

00:12:56.670 --> 00:13:01.410
电抗线协议，有一个

00:12:59.040 --> 00:13:03.270
不错的API，您今天就可以使用了

00:13:01.410 --> 00:13:06.900
要在上下文中查看我们的套接字

00:13:03.270 --> 00:13:09.240
春天的时候我们实际上不工作

00:13:06.900 --> 00:13:10.980
我们将在春季使用它

00:13:09.240 --> 00:13:14.220
申请但没有春天

00:13:10.980 --> 00:13:16.260
整合还可以，我还说

00:13:14.220 --> 00:13:19.050
因为我们宣布了一个春季

00:13:16.260 --> 00:13:23.190
我们将提供支持的2018平台

00:13:19.050 --> 00:13:24.930
 Spring Framework 5.2中的套接字

00:13:23.190 --> 00:13:26.910
会有很多组件模型

00:13:24.930 --> 00:13:29.070
 Spring MVC或Web套接字支持或

00:13:26.910 --> 00:13:31.860
 Spring Web Flex，因此您将拥有一个

00:13:29.070 --> 00:13:34.230
编译器模型，并与我

00:13:31.860 --> 00:13:36.150
期望注释，并且您认识一个客户

00:13:34.230 --> 00:13:39.350
或模板或类似的东西

00:13:36.150 --> 00:13:42.650
沿着那些线

00:13:39.350 --> 00:13:44.510
你知道我很期待

00:13:42.650 --> 00:13:45.440
但采取某种方式仍然有用

00:13:44.510 --> 00:13:46.670
看着它，了解什么

00:13:45.440 --> 00:13:50.000
发生了，所以我们要用Lum buck 

00:13:46.670 --> 00:13:50.960
这就是我们真正需要的

00:13:50.000 --> 00:13:53.600
我想我们要使用反应式

00:13:50.960 --> 00:13:55.190
东西，所以我带进去，那是

00:13:53.600 --> 00:13:57.370
我们只是要建立一个名为

00:13:55.190 --> 00:14:01.160
我们的插座，我们要点击生成

00:13:57.370 --> 00:14:02.780
我们正在使用 spring boot 

00:14:01.160 --> 00:14:08.270
反过来建立在Spring之上

00:14:02.780 --> 00:14:13.450
框架5.1所以还不存在

00:14:08.270 --> 00:14:13.450
 5.2好

00:14:26.770 --> 00:14:39.370
现在我们不会花一整天

00:14:31.190 --> 00:14:39.370
这虽然我们不能谢谢你

00:14:42.280 --> 00:14:47.300
好吧，我们要做的是

00:14:45.800 --> 00:14:49.280
将构建一些应用程序

00:14:47.300 --> 00:14:50.780
在这里展示一些概念，我们将

00:14:49.280 --> 00:14:52.010
从非常简单的事情开始

00:14:50.780 --> 00:14:53.570
只是说我想提出要求， 

00:14:52.010 --> 00:14:58.130
回应，但不仅仅是得到

00:14:53.570 --> 00:15:04.150
他们的单一价值被称为

00:14:58.130 --> 00:15:04.150
打包我们的请求响应

00:15:05.290 --> 00:15:16.240
请求响应好，并执行此操作

00:15:18.040 --> 00:15:22.580
好了，所以我们来了

00:15:20.570 --> 00:15:23.360
请求响应类型以及所有我要

00:15:22.580 --> 00:15:25.640
我要做的是建立一个简单的

00:15:23.360 --> 00:15:27.350
将启动的应用程序

00:15:25.640 --> 00:15:28.850
我会在这里有两件事

00:15:27.350 --> 00:15:30.170
将会有两件事

00:15:28.850 --> 00:15:36.640
启动并在不同的端口上监听

00:15:30.170 --> 00:15:36.640
当然要记住那些东西

00:15:36.760 --> 00:15:41.240
可以将它们分开燃烧

00:15:39.230 --> 00:15:43.400
客户我要生产一个制作人

00:15:41.240 --> 00:15:45.260
消费者，他们可以并愿意

00:15:43.400 --> 00:15:46.850
通常在单独的流程中运行，但是

00:15:45.260 --> 00:15:48.800
弄清楚并弄清楚

00:15:46.850 --> 00:15:49.850
简单又有点看这些东西如何

00:15:48.800 --> 00:15:52.940
互相看

00:15:49.850 --> 00:15:54.560
我发现发展这些有启发性

00:15:52.940 --> 00:15:58.190
同一系列中的各种事物

00:15:54.560 --> 00:16:01.280
代码页，然后担心他们

00:15:58.190 --> 00:16:04.750
他们分开两个独立的过程

00:16:01.280 --> 00:16:12.070
以后可以单独使用微服务

00:16:04.750 --> 00:16:17.320
公共静态void主字符串args 

00:16:12.070 --> 00:16:17.320
春季申请点跑

00:16:22.680 --> 00:16:35.620
请求/响应顶级参数好

00:16:30.900 --> 00:16:38.440
春天很好的应用程序好吧

00:16:35.620 --> 00:16:42.910
你知道我们的春天吗

00:16:38.440 --> 00:16:45.040
脚手架，如果你会和从这里

00:16:42.910 --> 00:16:46.570
我们将开发一个制作人和一个

00:16:45.040 --> 00:16:48.270
消费者，我们的生产者将成为

00:16:46.570 --> 00:16:54.940
很简单，我们将其称为

00:16:48.270 --> 00:16:59.470
消费者，这将是春天的光芒，我们

00:16:54.940 --> 00:17:01.810
希望它启动有序的工具

00:16:59.470 --> 00:17:04.480
我给它一个好消息界面

00:17:01.810 --> 00:17:06.610
在这里，因为为什么不因为我们有

00:17:04.480 --> 00:17:11.640
某些生命周期问题，所以我们想要

00:17:06.610 --> 00:17:13.810
这个开始以后不要这样

00:17:11.640 --> 00:17:15.940
您要开始的最低优先级

00:17:13.810 --> 00:17:18.850
在生产者之后的服务器之后

00:17:15.940 --> 00:17:28.270
先生，我们要请一位消费者来做

00:17:18.850 --> 00:17:32.170
上课哦，先生下令，我们会说

00:17:28.270 --> 00:17:36.730
顺序点最高优先级可以

00:17:32.170 --> 00:17:40.360
现在非常清楚，我们想要

00:17:36.730 --> 00:17:42.190
生产者响应传入的请求

00:17:40.360 --> 00:17:43.750
所以我要听一个事件，你

00:17:42.190 --> 00:17:45.850
可以在麻省理工学院使用注释

00:17:43.750 --> 00:17:46.990
我经常做的先生，没关系

00:17:45.850 --> 00:17:51.880
在这种情况下，我已经有一些

00:17:46.990 --> 00:17:53.440
接口好了，我们去了

00:17:51.880 --> 00:17:55.690
所以我要听那个事件

00:17:53.440 --> 00:17:58.750
当那件事发生时，我要开始

00:17:55.690 --> 00:18:00.220
使用我们的套接字再次提供数据

00:17:58.750 --> 00:18:02.410
我们将使用较低级别的套接字

00:18:00.220 --> 00:18:04.900
 API，所以这里没有什么特别的

00:18:02.410 --> 00:18:06.100
这只是一个看起来非常简单的API 

00:18:04.900 --> 00:18:07.900
就像您拥有的任何其他网络API 

00:18:06.100 --> 00:18:09.880
可能与你可能

00:18:07.900 --> 00:18:13.570
已经很熟悉了，我们将创建一个

00:18:09.880 --> 00:18:15.280
会以

00:18:13.570 --> 00:18:17.050
数据只是任意反应流

00:18:15.280 --> 00:18:20.340
我的意思是说我只是要用

00:18:17.050 --> 00:18:23.800
反应堆的权利，顺便说一句，我需要

00:18:20.340 --> 00:18:25.240
发表评论，我要带

00:18:23.800 --> 00:18:27.450
春天的心情启动器，但我们不需要

00:18:25.240 --> 00:18:27.450
这个

00:18:27.600 --> 00:18:34.480
杜威，您知道可能很安全， 

00:18:32.889 --> 00:18:38.730
留在那儿以防万一

00:18:34.480 --> 00:18:41.679
要建立一个生产者，生产者是

00:18:38.730 --> 00:18:45.789
将要监听传入的请求，所以

00:18:41.679 --> 00:18:47.169
我们的插座工厂知道我要添加

00:18:45.789 --> 00:18:48.759
我们第二个依赖

00:18:47.169 --> 00:18:50.710
好吧，如果我有，我们必须这样做

00:18:48.759 --> 00:18:52.779
超越自己有一个很好的

00:18:50.710 --> 00:18:53.529
我们将添加不同的

00:18:52.779 --> 00:18:55.480
这里的依赖

00:18:53.529 --> 00:18:59.409
通常当您添加我们的插座时

00:18:55.480 --> 00:19:00.999
不必担心您知道

00:18:59.409 --> 00:19:02.669
可以安全地使用这两个要求，他就是

00:19:00.999 --> 00:19:07.200
我们将使用我们的插座

00:19:02.669 --> 00:19:13.360
套接字传输让我们看这里

00:19:07.200 --> 00:19:15.490
依赖，这是这些文章

00:19:13.360 --> 00:19:18.730
为我保持插座运输的整洁

00:19:15.490 --> 00:19:26.559
我们要用全部十一十四

00:19:18.730 --> 00:19:32.169
我想哦11好的，我希望

00:19:26.559 --> 00:19:35.369
在编译时引入核心是

00:19:32.169 --> 00:19:35.369
所以我们可以带进去

00:19:40.309 --> 00:19:45.320
好吧，好吧，有一个

00:19:50.930 --> 00:19:56.720
好吧，所以我们有插座

00:19:55.270 --> 00:20:07.330
开始了

00:19:56.720 --> 00:20:09.650
现在我们的插座工厂点接收点

00:20:07.330 --> 00:20:10.670
插座接受器现在插座接受器

00:20:09.650 --> 00:20:11.900
很直，这实际上是

00:20:10.670 --> 00:20:13.640
工作的实质发生在哪里

00:20:11.900 --> 00:20:16.460
我们要把它移到这里，我要

00:20:13.640 --> 00:20:19.460
说套接字接受器和我们的工作

00:20:16.460 --> 00:20:22.340
有人要求提供

00:20:19.460 --> 00:20:24.890
发布者和mono只是一个包装

00:20:22.340 --> 00:20:29.600
我们的插座，所以您得到了什么

00:20:24.890 --> 00:20:31.700
是传入的发件人我们的套接字， 

00:20:29.600 --> 00:20:34.400
这是您要设置的元数据

00:20:31.700 --> 00:20:37.400
它，你知道你可以返回一个

00:20:34.400 --> 00:20:38.270
全新我们的插座在这里

00:20:37.400 --> 00:20:40.540
我们要做什么我们要来

00:20:38.270 --> 00:20:46.340
再过一遍再做一次

00:20:40.540 --> 00:20:49.640
这是插座

00:20:46.340 --> 00:20:51.770
承兑人，我现在要使用交通工具

00:20:49.640 --> 00:20:54.590
在这里我通常使用TCP服务器

00:20:51.770 --> 00:20:58.310
运输，但请记住我们的插座

00:20:54.590 --> 00:21:00.980
不在乎你知道它在某种程度上

00:20:58.310 --> 00:21:02.750
它实际上是与协议无关的

00:21:00.980 --> 00:21:05.210
运输不可知的所以记得我说过

00:21:02.750 --> 00:21:06.260
早些时候WebSocket颇具吸引力

00:21:05.210 --> 00:21:08.440
对于某些用例，但它们没有

00:21:06.260 --> 00:21:10.460
具有应用程序级别的语义

00:21:08.440 --> 00:21:14.840
你可以解决这个问题

00:21:10.460 --> 00:21:20.540
实际上是一个WebSocket传输权网站

00:21:14.840 --> 00:21:23.090
很好的运输，服务器运输

00:21:20.540 --> 00:21:24.710
你去那里创造七千

00:21:23.090 --> 00:21:26.720
一两个，例如，您可以使用

00:21:24.710 --> 00:21:29.450
相反，这是对的，您现在可以

00:21:26.720 --> 00:21:31.850
通过WebSocket进行相同的通信

00:21:29.450 --> 00:21:32.960
协议和端口，它将完成

00:21:31.850 --> 00:21:34.670
消息支付，但其他一切

00:21:32.960 --> 00:21:35.750
就我们的插座而言，所以您

00:21:34.670 --> 00:21:36.950
可以做到这一点，如果你想要做到这一点

00:21:35.750 --> 00:21:38.120
轻松将其整合到我们的

00:21:36.950 --> 00:21:41.660
只讲网络的环境

00:21:38.120 --> 00:21:43.700
套接字，但我要使用TCP，因为

00:21:41.660 --> 00:21:45.020
这是快速的，而且有效，是我们

00:21:43.700 --> 00:21:47.920
没有理由在此使用WebSockets 

00:21:45.020 --> 00:21:51.740
特殊情况下，我将开始

00:21:47.920 --> 00:21:53.540
我将在响应中阻止的代码

00:21:51.740 --> 00:21:56.000
在服务器下的那里好

00:21:53.540 --> 00:22:00.470
现在您可以在这里看到实际的工作

00:21:56.000 --> 00:22:01.910
正在生产我们的插座，所以这是

00:22:00.470 --> 00:22:04.990
容易，您只是说我要退货

00:22:01.910 --> 00:22:04.990
抽象我们的套接字

00:22:08.020 --> 00:22:11.020
好的

00:22:11.350 --> 00:22:34.160
他们说只返回单型

00:22:25.190 --> 00:22:34.549
抽象的，这意味着那里的课程

00:22:34.160 --> 00:22:36.799
我们去

00:22:34.549 --> 00:22:40.640
这个课有几种方法

00:22:36.799 --> 00:22:42.830
可以看到你看到我们的插座非常

00:22:40.640 --> 00:22:44.690
灵活，您可以看到它是运输工具

00:22:42.830 --> 00:22:46.370
不可知论者可以看到它的支持

00:22:44.690 --> 00:22:48.830
多种消息交换模式

00:22:46.370 --> 00:22:50.480
即发即弃请求响应

00:22:48.830 --> 00:22:52.370
请求三年期和请求渠道，以及

00:22:50.480 --> 00:22:53.900
元数据推送，我们将回到所有

00:22:52.370 --> 00:22:55.640
那些在一秒钟，它支持

00:22:53.900 --> 00:22:57.530
还是不同的编码

00:22:55.640 --> 00:23:00.380
没有指定数据的编码

00:22:57.530 --> 00:23:03.110
在有效负载中，因此当您发送数据时

00:23:00.380 --> 00:23:05.690
从一个生产者到一个消费者

00:23:03.110 --> 00:23:06.919
必须同意我们的先验编码

00:23:05.690 --> 00:23:08.480
您实际上可以知道的数据

00:23:06.919 --> 00:23:10.400
你可以发送，但每个人都可以发送

00:23:08.480 --> 00:23:11.360
可以发送JSON的JSON协议

00:23:10.400 --> 00:23:13.190
缓冲区，您可以做任何您想做的

00:23:11.360 --> 00:23:15.799
这里没有要求你

00:23:13.190 --> 00:23:17.720
做一件事情或另一件事

00:23:15.799 --> 00:23:19.640
急于来回

00:23:17.720 --> 00:23:21.370
这些有效载荷包络对象

00:23:19.640 --> 00:23:24.980
字节这些基本上是字节缓冲区

00:23:21.370 --> 00:23:26.330
嗯，现在让我们看看这个

00:23:24.980 --> 00:23:30.980
解雇法说

00:23:26.330 --> 00:23:34.640
生产者哦，抱歉消费者要去

00:23:30.980 --> 00:23:36.320
向我们发送请求，我们将

00:23:34.640 --> 00:23:37.910
我们将要承认

00:23:36.320 --> 00:23:39.799
请求，所以我们这些是回调

00:23:37.910 --> 00:23:42.530
当某人被调用的方法

00:23:39.799 --> 00:23:44.630
客户端发送请求到时发送

00:23:42.530 --> 00:23:46.640
我们作为服务还可以，所以

00:23:44.630 --> 00:23:48.740
即发即弃方法需要有效载荷

00:23:46.640 --> 00:23:50.510
有效载荷只是一个值而已

00:23:48.740 --> 00:23:52.340
一个值，可能是一个字节，可能是

00:23:50.510 --> 00:23:54.049
一个字符串，它可以是任何您想要的

00:23:52.340 --> 00:23:55.640
可以序列化Java对象

00:23:54.049 --> 00:23:56.809
你知道不要那样做，但是可能是我

00:23:55.640 --> 00:23:59.510
意味着可以随便你

00:23:56.809 --> 00:24:01.610
关键是那只是一个

00:23:59.510 --> 00:24:02.900
事情，你的工作就是接受它

00:24:01.610 --> 00:24:04.070
处理您需要做的一切

00:24:02.900 --> 00:24:06.710
它，但你没有发送

00:24:04.070 --> 00:24:08.150
回应回来回应只是单声道

00:24:06.710 --> 00:24:11.650
避免通过致电获得

00:24:08.150 --> 00:24:11.650
点右

00:24:12.510 --> 00:24:17.130
所以反应最活跃的反应堆

00:24:15.480 --> 00:24:19.790
反应性的流，你可以只点

00:24:17.130 --> 00:24:22.320
那是一种选择

00:24:19.790 --> 00:24:23.669
请求响应也很

00:24:22.320 --> 00:24:26.040
直接，这是更多

00:24:23.669 --> 00:24:28.470
自然，这是我想，如果你在

00:24:26.040 --> 00:24:31.140
怀疑你可能会从这项权利开始

00:24:28.470 --> 00:24:33.600
请求响应只是说我在期待

00:24:31.140 --> 00:24:36.360
发送单个发行单

00:24:33.600 --> 00:24:39.390
有效负载到服务器，我期望

00:24:36.360 --> 00:24:42.929
一个有效载荷返回，所以它是一个价值

00:24:39.390 --> 00:24:44.700
一值进出请求流在哪里

00:24:42.929 --> 00:24:46.970
事情开始变得越来越有趣， 

00:24:44.700 --> 00:24:49.230
您现在拥有更多有状态的权利

00:24:46.970 --> 00:24:51.000
在这里，您有一家发布商

00:24:49.230 --> 00:24:53.370
发送回客户端，以便客户端

00:24:51.000 --> 00:24:55.500
向您发送有效载荷请求，并

00:24:53.370 --> 00:24:57.600
然后您发回发布者，您

00:24:55.500 --> 00:24:59.309
注意这些是Manos和通量

00:24:57.600 --> 00:25:01.110
这些来自反应堆，而不仅仅是

00:24:59.309 --> 00:25:02.760
您知道这不仅是工作

00:25:01.110 --> 00:25:05.760
勃起梦的出版商这些是

00:25:02.760 --> 00:25:06.929
实际上来自反应堆的特定亚型

00:25:05.760 --> 00:25:09.740
健身中内置的

00:25:06.929 --> 00:25:12.270
从Facebook协议这个项目，所以

00:25:09.740 --> 00:25:14.190
在这里你知道想象你正在做

00:25:12.270 --> 00:25:15.660
找到全部或您正在做的你知道

00:25:14.190 --> 00:25:17.340
股票行情更新或诸如此类的东西

00:25:15.660 --> 00:25:20.160
可以说把所有股票行情发给我

00:25:17.340 --> 00:25:22.710
您知道的股票更新

00:25:20.160 --> 00:25:24.809
然后股票代码为

00:25:22.710 --> 00:25:26.520
您在有效载荷中发送的内容以及

00:25:24.809 --> 00:25:27.510
通量是每秒更新一次

00:25:26.520 --> 00:25:30.780
不管每一次心跳事件

00:25:27.510 --> 00:25:35.280
指示所有新的更新，并且

00:25:30.780 --> 00:25:38.510
最后，您已经完成了

00:25:35.280 --> 00:25:41.700
来回你知道双向

00:25:38.510 --> 00:25:42.750
频道，然后在这种情况下，您发送一个

00:25:41.700 --> 00:25:45.000
价值流，你得到一个

00:25:42.750 --> 00:25:46.980
正确地流走你的身体，这非常

00:25:45.000 --> 00:25:49.799
方便，然后这一个

00:25:46.980 --> 00:25:55.919
不是你通常不使用的你

00:25:49.799 --> 00:25:57.470
这样来回交流数据

00:25:55.919 --> 00:25:59.520
这更多是关于交流

00:25:57.470 --> 00:26:05.630
可用性，这更多是关于租赁

00:25:59.520 --> 00:26:05.630
你知道告诉

00:26:07.300 --> 00:26:11.080
您知道的请求者会继续执行

00:26:09.429 --> 00:26:14.350
请求者，应该推

00:26:11.080 --> 00:26:15.670
回到制作人，好吧，让我们

00:26:14.350 --> 00:26:16.840
尝试记住的东西

00:26:15.670 --> 00:26:18.610
抛弃式的遗忘很好，如果你想

00:26:16.840 --> 00:26:21.370
发送数据并且您要确保

00:26:18.610 --> 00:26:22.630
机械既可以

00:26:21.370 --> 00:26:25.750
消费者中的生产者可以拆除

00:26:22.630 --> 00:26:27.429
自己尽快，你

00:26:25.750 --> 00:26:29.440
知道减轻胶带，因此您可以使用

00:26:27.429 --> 00:26:31.720
那个请求的响应是相当

00:26:29.440 --> 00:26:33.190
简单明了，所以我想那很好

00:26:31.720 --> 00:26:33.580
只是让您有点探索

00:26:33.190 --> 00:26:35.710
你自己

00:26:33.580 --> 00:26:37.330
让我们请求流，以便我们

00:26:35.710 --> 00:26:39.580
提出要求，我要寄回

00:26:37.330 --> 00:26:41.380
价值流好吧，我们要

00:26:39.580 --> 00:26:44.650
假设有人会要求我们

00:26:41.380 --> 00:26:47.470
有人要连接到端口7,000 

00:26:44.650 --> 00:26:49.450
在我们的服务器上，当他们这样做时

00:26:47.470 --> 00:26:51.250
他们会遇到这个我们的

00:26:49.450 --> 00:26:54.130
在那里监听的套接字因子

00:26:51.250 --> 00:26:56.110
它会调用套接字接受器

00:26:54.130 --> 00:26:58.210
然后将被指控

00:26:56.110 --> 00:26:59.800
产生这个摘要我们的套接字

00:26:58.210 --> 00:27:01.450
我们发回正确的东西

00:26:59.800 --> 00:27:04.230
将会投入使用

00:27:01.450 --> 00:27:06.520
听取并回复发件人，并且

00:27:04.230 --> 00:27:08.890
我们发回的东西可以是任何东西

00:27:06.520 --> 00:27:15.760
想要吧，我可以想象你

00:27:08.890 --> 00:27:18.570
有一个产生字符串的服务

00:27:15.760 --> 00:27:24.120
值可以，字符串a的发布者

00:27:18.570 --> 00:27:27.790
字符串流也是如此，因此请通知

00:27:24.120 --> 00:27:29.350
通知还可以，所以我们只是

00:27:27.790 --> 00:27:31.900
会做一件你见过的很普通的事

00:27:29.350 --> 00:27:37.720
在确定返回之前，我先执行此操作

00:27:31.900 --> 00:27:41.470
流甚至生成这将是

00:27:37.720 --> 00:27:45.160
一个新的供应商，它得到了

00:27:41.470 --> 00:27:52.740
字符串，我要说回声你好

00:27:45.160 --> 00:27:57.750
现在点立即点到字符串并

00:27:52.740 --> 00:27:57.750
将会成为信息流中的发布者

00:27:58.890 --> 00:28:01.890
好的

00:28:02.600 --> 00:28:09.570
好吧，好吧，那是我的

00:28:06.200 --> 00:28:12.150
永无止境的数据流，您知道

00:28:09.570 --> 00:28:15.990
我要延迟一下，我实际上要插入

00:28:12.150 --> 00:28:19.350
彼此之间有一秒钟的长时间停顿

00:28:15.990 --> 00:28:20.820
发布的发射项目，那将是

00:28:19.350 --> 00:28:23.310
我要发回的出版商

00:28:20.820 --> 00:28:24.510
让我们发送一连串的字符串

00:28:23.310 --> 00:28:26.970
这可能是任何东西

00:28:24.510 --> 00:28:28.650
您知道自定义对象或foo或a 

00:28:26.970 --> 00:28:30.450
只要你知道就禁止

00:28:28.650 --> 00:28:32.370
因为您可以将其放入有效载荷中，所以我们

00:28:30.450 --> 00:28:34.800
工作是接受字符串的发布者

00:28:32.370 --> 00:28:35.880
并变成有效载荷的发布者

00:28:34.800 --> 00:28:38.010
这很简单

00:28:35.880 --> 00:28:39.630
因为一旦你可以得到这个对象

00:28:38.010 --> 00:28:41.520
您的字节或字符串

00:28:39.630 --> 00:28:46.170
从那里很容易

00:28:41.520 --> 00:28:47.910
在这种情况下，也许我们可以拥有

00:28:46.170 --> 00:28:50.510
如此命名我对此的想法

00:28:47.910 --> 00:28:57.360
让我们实际使用一个屏幕名称

00:28:50.510 --> 00:28:58.320
我现在要打个招呼

00:28:57.360 --> 00:29:02.060
好的

00:28:58.320 --> 00:29:04.590
不错，所以我们要问候

00:29:02.060 --> 00:29:08.010
有自己名字的请求者好吧

00:29:04.590 --> 00:29:10.890
在这里我要说的是有效载荷没有得到

00:29:08.010 --> 00:29:12.300
 utf-8数据utf-8是您的字符串

00:29:10.890 --> 00:29:15.570
可以看到我们可以得到一个字节缓冲区

00:29:12.300 --> 00:29:22.940
如果您想但我想要utf-8 

00:29:15.570 --> 00:29:25.110
数据，这样我就可以恢复正常， 

00:29:22.940 --> 00:29:32.280
我们要寄回给我们

00:29:25.110 --> 00:29:36.150
说出姓名和我们发送的值

00:29:32.280 --> 00:29:38.760
返回将返回有关的通知

00:29:36.150 --> 00:29:41.300
名称，我们可以找回出版商

00:29:38.760 --> 00:29:48.080
所以请大家问候一下

00:29:41.300 --> 00:29:51.080
并变成有效载荷的发布者

00:29:48.080 --> 00:29:51.080
好的

00:29:52.370 --> 00:30:05.630
默认有效负载暗率呼吸还可以

00:30:02.740 --> 00:30:07.789
那可能是lambda方法

00:30:05.630 --> 00:30:09.049
参考即使没有不好就这样

00:30:07.789 --> 00:30:12.860
我们在默认箱子上所做的一切

00:30:09.049 --> 00:30:14.960
你会看到我不应该有

00:30:12.860 --> 00:30:16.460
如此之快的默认利率需要

00:30:14.960 --> 00:30:18.200
默认有效载荷箱占用一个字节

00:30:16.460 --> 00:30:20.390
缓冲区需要一个字节缓冲区我的缓冲区

00:30:18.200 --> 00:30:22.580
它需要一个有效载荷，它需要一辆汽车

00:30:20.390 --> 00:30:24.620
顺序，所以我只是在使用我依赖

00:30:22.580 --> 00:30:26.750
在采用

00:30:24.620 --> 00:30:30.890
串好车序列好吧，我就是

00:30:26.750 --> 00:30:32.960
说字符串好，然后崩溃是

00:30:30.890 --> 00:30:35.630
很好，就是这样

00:30:32.960 --> 00:30:36.890
我们的服务器还可以，这相当我

00:30:35.630 --> 00:30:38.409
认为我们可以同意这是相当公平的

00:30:36.890 --> 00:30:40.460
直截了当

00:30:38.409 --> 00:30:44.419
您甚至可以将其重写为lambda 

00:30:40.460 --> 00:30:46.400
很好，所以有我们的制作人

00:30:44.419 --> 00:30:48.260
我们有这个非常简单的例子

00:30:46.400 --> 00:30:51.140
但是如果肯（肯）在哪里可以找到出版商

00:30:48.260 --> 00:30:52.490
任何弹簧数据中的T 

00:30:51.140 --> 00:30:55.520
支持反应式编程的项目

00:30:52.490 --> 00:30:59.990
对 spring data 反应性MongoDB 

00:30:55.520 --> 00:31:02.179
 spring data 反应式Redis和

00:30:59.990 --> 00:31:04.580
您可以在Cassandra中使用Couchbase 

00:31:02.179 --> 00:31:07.370
两个DBC反应式续集数据访问

00:31:04.580 --> 00:31:10.100
分层喷涂新生的弹簧数据

00:31:07.370 --> 00:31:11.450
或者TBC项目也支持这一点

00:31:10.100 --> 00:31:13.970
我们可以做各种有趣的事情

00:31:11.450 --> 00:31:16.640
我们可以从大量数据中获取数据的东西

00:31:13.970 --> 00:31:19.490
不同的地方，实际上我们可以

00:31:16.640 --> 00:31:21.260
充当消费者，您知道我们可以

00:31:19.490 --> 00:31:22.760
我们可能会消耗一个

00:31:21.260 --> 00:31:24.740
微服务对其进行转换，然后

00:31:22.760 --> 00:31:26.600
发送到另一个

00:31:24.740 --> 00:31:27.860
微服务，我们可以充当桥梁

00:31:26.600 --> 00:31:29.900
做这样的事情很自然

00:31:27.860 --> 00:31:32.510
因为我们只有出版商

00:31:29.900 --> 00:31:33.830
来回来回或从

00:31:32.510 --> 00:31:36.799
现在，我们可以做各种

00:31:33.830 --> 00:31:40.030
有趣的事情就是我们

00:31:36.799 --> 00:31:43.370
从现在开始消费方

00:31:40.030 --> 00:31:46.450
同样容易，所以我们说它将

00:31:43.370 --> 00:31:46.450
具有内部功能的应用程序

00:31:47.110 --> 00:31:54.140
应用就绪事件以及

00:31:51.860 --> 00:31:55.970
消费者方面，我们要说的是

00:31:54.140 --> 00:32:00.500
想开始一个新的香肠

00:31:55.970 --> 00:32:02.570
工厂，我们将使用

00:32:00.500 --> 00:32:03.900
 TCP客户端传输而不是服务器

00:32:02.570 --> 00:32:06.930
运输

00:32:03.900 --> 00:32:08.640
在7,000端口上，我将开始

00:32:06.930 --> 00:32:12.210
要求我要绘制许多我们的地图

00:32:08.640 --> 00:32:13.560
我们要说一次

00:32:12.210 --> 00:32:17.880
我们已经连接好了，我们还给了它

00:32:13.560 --> 00:32:22.700
在我们的套接字客户端实例上

00:32:17.880 --> 00:32:26.940
这样做，我要订阅或

00:32:22.700 --> 00:32:28.920
更好的与块或只是

00:32:26.940 --> 00:32:31.470
订阅我想我们一旦做好就可以了

00:32:28.920 --> 00:32:34.170
假设我们的插座点和

00:32:31.470 --> 00:32:37.860
要求一些数据，所以我们要

00:32:34.170 --> 00:32:40.590
与我们的客户发送请求

00:32:37.860 --> 00:32:42.480
插入我们的发送权限，这就是这个

00:32:40.590 --> 00:32:44.160
其实你知道你应该想到

00:32:42.480 --> 00:32:46.800
这是发送者，我们的套接字

00:32:44.160 --> 00:32:52.380
实例，当我们这样做时，我们将

00:32:46.800 --> 00:32:54.270
发送我们的名字，让我们带来所有提示

00:32:52.380 --> 00:32:57.390
对，所以我们要发送该流

00:32:54.270 --> 00:32:58.740
当我们这样做时，我们可以获得

00:32:57.390 --> 00:33:01.470
回应和回应

00:32:58.740 --> 00:33:03.660
我们要回来的是一个有效载荷

00:33:01.470 --> 00:33:04.950
我们将变成一串

00:33:03.660 --> 00:33:09.270
当然我们要去掉弦

00:33:04.950 --> 00:33:13.350
我认为从那里开始有价值

00:33:09.270 --> 00:33:14.580
可以记录每个人去吧，还有什么

00:33:13.350 --> 00:33:19.470
订阅他们做各种事情

00:33:14.580 --> 00:33:30.240
所以在下一个日志信息上做，我要

00:33:19.470 --> 00:33:31.890
只需将结果log4j记录到已经这样

00:33:30.240 --> 00:33:36.180
每个返回的价值我们都会

00:33:31.890 --> 00:33:44.690
将其注销好吧，或者您实际上知道

00:33:36.180 --> 00:33:44.690
就在这里结果爱那个信息

00:33:45.260 --> 00:33:48.260
处理中

00:33:50.390 --> 00:33:57.850
新结果还可以

00:34:00.929 --> 00:34:07.819
非常酷，所以我们去那里是我们的

00:34:03.779 --> 00:34:12.139
服务器返回新结果

00:34:07.819 --> 00:34:12.139
在不同的时间还可以

00:34:25.460 --> 00:34:30.220
好，所以现在让我们运行这个

00:34:27.530 --> 00:34:30.220
看看会发生什么

00:34:41.190 --> 00:34:43.849
哎呀

00:34:51.130 --> 00:34:59.530
已经有人在那儿了吗

00:34:52.780 --> 00:35:02.830
只是基督毫米或7001，因为哦，七

00:34:59.530 --> 00:35:04.900
哈哈，实际上是正确的，所以700是一个

00:35:02.830 --> 00:35:07.210
我需要跑步作为路线

00:35:04.900 --> 00:35:20.250
那不过7000井，这很容易，所以让我们

00:35:07.210 --> 00:35:22.270
只要修复好吧就可以关闭

00:35:20.250 --> 00:35:24.040
我们去那里，所以你会知道

00:35:22.270 --> 00:35:26.320
消费者在哪里

00:35:24.040 --> 00:35:28.360
处理消息你好字符串提示

00:35:26.320 --> 00:35:33.130
机翼提示，该消息正在发送

00:35:28.360 --> 00:35:35.950
每秒输出50 51 52 53等等等等等

00:35:33.130 --> 00:35:37.150
所以这是一个非常简单的例子

00:35:35.950 --> 00:35:39.220
我们正在通过获取一个请求

00:35:37.150 --> 00:35:41.110
返回的数据流可能是

00:35:39.220 --> 00:35:44.650
当然只有一种价值的出版商

00:35:41.110 --> 00:35:46.480
对，这是你知道的

00:35:44.650 --> 00:35:48.310
在此之前，那将是

00:35:46.480 --> 00:35:49.480
容易，但更有趣

00:35:48.310 --> 00:35:52.570
看看我们如何做一个反应

00:35:49.480 --> 00:35:55.200
现在流回所有这是相当

00:35:52.570 --> 00:35:59.020
简单的让我们看一下

00:35:55.200 --> 00:36:05.020
稍微多一点的例子好吧

00:35:59.020 --> 00:36:10.270
让我们谈谈双工通道

00:36:05.020 --> 00:36:15.970
好的，在这里我要玩

00:36:10.270 --> 00:36:20.820
乒乓球，这将回来， 

00:36:15.970 --> 00:36:20.820
一如既往地如此公共静态

00:36:24.299 --> 00:36:32.920
看着我，好吧，那年春天

00:36:29.230 --> 00:36:37.450
启动应用程序，我们要说

00:36:32.920 --> 00:36:40.690
春季申请但运行乒乓点

00:36:37.450 --> 00:36:43.089
班级组织不错，所以我们有

00:36:40.690 --> 00:36:44.970
应用程序，我们有两件事是

00:36:43.089 --> 00:36:50.759
会发生在这里，我们有ping和

00:36:44.970 --> 00:36:54.789
与乒乓球，这是弹簧梁

00:36:50.759 --> 00:37:00.460
这样，这将是一个

00:36:54.789 --> 00:37:11.099
应用程序监听器已准备就绪

00:37:00.460 --> 00:37:14.230
事件好吗打开那好

00:37:11.099 --> 00:37:16.920
只要复制粘贴一些代码在这里

00:37:14.230 --> 00:37:22.509
事情进展得更快一点，所以

00:37:16.920 --> 00:37:26.410
 ping即使ping通

00:37:22.509 --> 00:37:28.210
是客户端，是服务器

00:37:26.410 --> 00:37:31.230
那就是在

00:37:28.210 --> 00:37:33.789
第一个请求已经发出，所以乒乓球

00:37:31.230 --> 00:37:36.130
真的，我们应该确保

00:37:33.789 --> 00:37:37.890
首先开始吧，所以

00:37:36.130 --> 00:37:42.660
下令

00:37:37.890 --> 00:37:47.519
好吧好吧

00:37:42.660 --> 00:37:47.519
点的最高优先级

00:37:49.850 --> 00:37:53.960
和

00:37:55.790 --> 00:38:07.410
在这里订购返回的订购点Louis 

00:38:05.160 --> 00:38:11.670
现在很酷

00:38:07.410 --> 00:38:14.190
好，所以乒乓球必须先启动

00:38:11.670 --> 00:38:17.780
希望情况如此，现在我们

00:38:14.190 --> 00:38:22.920
要发送，我们将发送请求

00:38:17.780 --> 00:38:24.150
为服务器，我们要

00:38:22.920 --> 00:38:26.040
得到回应，只会

00:38:24.150 --> 00:38:28.080
不断更新彼此，我们要做

00:38:26.040 --> 00:38:29.640
一个简单的状态机

00:38:28.080 --> 00:38:31.800
要看里斯看

00:38:29.640 --> 00:38:33.810
传入请求，然后基于该请求

00:38:31.800 --> 00:38:35.910
请求发回乒乓球或乒乓球

00:38:33.810 --> 00:38:40.100
好吧，让我们提取出逻辑

00:38:35.910 --> 00:38:46.710
直到这里一个单一的静态字符串

00:38:40.100 --> 00:38:52.620
回复字符串并说点是否等于

00:38:46.710 --> 00:38:56.420
忽略大小写ping，然后我们返回哦，是的

00:38:52.620 --> 00:39:01.830
点等于等于忽略大小写返回

00:38:56.420 --> 00:39:06.080
粉红色的简单的权利，否则抛出一个新的

00:39:01.830 --> 00:39:18.000
非法参数异常传入

00:39:06.080 --> 00:39:20.130
值必须是粉红色或还可以

00:39:18.000 --> 00:39:23.520
所以有我简单的乒乓球回复

00:39:20.130 --> 00:39:29.430
方法现在让我们先实现ping 

00:39:23.520 --> 00:39:31.380
因为那可以说更有趣，我

00:39:29.430 --> 00:39:34.950
猜它更容易吧，一切都很漂亮

00:39:31.380 --> 00:39:36.060
好，但是这是他们这是一个

00:39:34.950 --> 00:39:38.010
从第一次开始就开始的好地方

00:39:36.060 --> 00:39:39.120
首先在代码页上

00:39:38.010 --> 00:39:41.520
创建一个记录器，以便我们有一些东西

00:39:39.120 --> 00:39:43.290
要记录的日志，我会宣布

00:39:41.520 --> 00:39:49.520
我们正在启动应用程序，所以

00:39:43.290 --> 00:39:53.010
开始该类的日志点未获取名称

00:39:49.520 --> 00:39:57.510
我们要做的就是说我们的

00:39:53.010 --> 00:39:59.940
插座工厂点连接点运输

00:39:57.510 --> 00:40:02.970
消除了tcp客户端传输

00:39:59.940 --> 00:40:04.680
创造重要的七千听

00:40:02.970 --> 00:40:06.330
顺便说一句，你可以

00:40:04.680 --> 00:40:08.460
在那里也指定，您可以绑定

00:40:06.330 --> 00:40:10.109
到某个IP地址等，但是

00:40:08.460 --> 00:40:15.000
我只是去找你知道零零

00:40:10.109 --> 00:40:18.240
零零和7000开始平面图很多

00:40:15.000 --> 00:40:20.520
得到一个插座好，所以这一切都相当

00:40:18.240 --> 00:40:22.650
熟悉的您在此之前已完成此操作

00:40:20.520 --> 00:40:26.130
点块，请确保我们得到了

00:40:22.650 --> 00:40:28.830
现在给定套接字，我们要

00:40:26.130 --> 00:40:31.349
发送频道请求，然后发送

00:40:28.830 --> 00:40:36.869
定向数据流，所以在这里

00:40:31.349 --> 00:40:40.609
我要在的频道发送请求

00:40:36.869 --> 00:40:48.830
间隔好吧，我要说通量点

00:40:40.609 --> 00:40:48.830
一秒点图的间隔时间

00:40:51.230 --> 00:41:01.099
好吧，我把它变成默认

00:40:58.320 --> 00:41:09.320
装在箱子里的有效载荷

00:41:01.099 --> 00:41:09.320
好吧好吧，我要映射到

00:41:09.859 --> 00:41:14.480
你知道我们什么时候做的

00:41:12.030 --> 00:41:18.599
请求让我们看看这里

00:41:14.480 --> 00:41:20.490
就是这样，我们要

00:41:18.599 --> 00:41:23.220
是的，看起来不错，所以在

00:41:20.490 --> 00:41:25.980
请求频道，我们将进行地图

00:41:23.220 --> 00:41:29.849
每个回应都会返回一个

00:41:25.980 --> 00:41:32.460
像这样的字符串，所以我要映射每个

00:41:29.849 --> 00:41:45.170
我只想装每个的

00:41:32.460 --> 00:41:52.349
这些日志中，信息接收到字符串

00:41:45.170 --> 00:41:54.540
在上课时不要叫我名字

00:41:52.349 --> 00:41:57.300
就拿其中的十个好吧，所以我们

00:41:54.540 --> 00:41:59.400
不想永远跑然后

00:41:57.300 --> 00:42:06.319
最后你知道你应该做的一件事

00:41:59.400 --> 00:42:14.400
我最后没有做

00:42:06.319 --> 00:42:15.509
被安排好吧，那是什么

00:42:14.400 --> 00:42:18.479
发生在这里，让我们看一下这段代码

00:42:15.509 --> 00:42:20.999
这里不要看

00:42:18.479 --> 00:42:25.400
没事，所以我们现在有了

00:42:20.999 --> 00:42:29.089
产生新价值的出版商

00:42:25.400 --> 00:42:29.089
每10秒

00:42:36.640 --> 00:42:41.790
每10产生一个新的价值

00:42:38.290 --> 00:42:41.790
秒MC我在做什么错

00:42:44.100 --> 00:42:57.760
间隔好，要映射好吗

00:42:52.720 --> 00:43:00.190
哦，标签，我试图不标签

00:42:57.760 --> 00:43:01.150
没关系，我们去坐

00:43:00.190 --> 00:43:04.000
盯着明显的头发

00:43:01.150 --> 00:43:09.160
好吧，现在我们有了这个，让我们看看

00:43:04.000 --> 00:43:15.370
这是ping的基本代码

00:43:09.160 --> 00:43:17.020
基本上在乒乓球和掌心

00:43:15.370 --> 00:43:17.950
一边，我们还有一点

00:43:17.020 --> 00:43:18.850
情报在这里，我们必须有一个

00:43:17.950 --> 00:43:20.070
多一点智慧哦

00:43:18.850 --> 00:43:23.860
自然

00:43:20.070 --> 00:43:27.400
所以我们在乒乓球里做

00:43:23.860 --> 00:43:30.310
一边我们要听我们的插座

00:43:27.400 --> 00:43:34.030
工厂你没有看到你的点受体

00:43:30.310 --> 00:43:46.920
我们将把自己当作一个插座

00:43:34.030 --> 00:43:46.920
接受者首先好，这个

00:43:47.539 --> 00:43:58.140
传输TCP服务器传输创建

00:43:52.380 --> 00:44:00.150
 7,000点开始点订阅好

00:43:58.140 --> 00:44:01.650
那里有那个，然后

00:44:00.150 --> 00:44:04.999
实际坐在插座上的工作

00:44:01.650 --> 00:44:11.339
这就是我们在这里做的事

00:44:04.999 --> 00:44:12.989
我们说单声道我们想创建一个

00:44:11.339 --> 00:44:14.900
新摘要我们的套接字就像

00:44:12.989 --> 00:44:24.619
之前

00:44:14.900 --> 00:44:27.769
所以我们要请求一个频道

00:44:24.619 --> 00:44:36.359
所以单字型

00:44:27.769 --> 00:44:44.969
 RS很好，在这个回应中说了一个通量

00:44:36.359 --> 00:44:48.749
负载点映射负载

00:44:44.969 --> 00:44:52.999
负八位，直到下一个让我们记录

00:44:48.749 --> 00:44:52.999
这是一个字符串

00:45:02.090 --> 00:45:20.270
流哦，获取类的更大的注解

00:45:11.240 --> 00:45:23.500
已经存在并映射我们的价值

00:45:20.270 --> 00:45:28.090
开始使用乒乓球

00:45:23.500 --> 00:45:31.730
我要把它变成有效载荷

00:45:28.090 --> 00:45:33.590
好吧，整个事情又回来了吗

00:45:31.730 --> 00:45:35.840
我们去的就是全部

00:45:33.590 --> 00:45:37.790
我是说我爱那是对的

00:45:35.840 --> 00:45:40.520
这很简单，所以我们说什么时候

00:45:37.790 --> 00:45:43.130
有人请求带有值的渠道

00:45:40.520 --> 00:45:44.770
在它里面，我们要花点时间

00:45:43.130 --> 00:45:47.360
发布者，并将其转变为潮流

00:45:44.770 --> 00:45:50.450
那么我们必须将其中的每个价值

00:45:47.360 --> 00:45:52.340
传入负载的发布者将其转过来

00:45:50.450 --> 00:45:54.560
到一个字符串，然后注销我们

00:45:52.340 --> 00:45:55.940
收到，然后我们将创建一个

00:45:54.560 --> 00:45:57.200
因此，如果字符串

00:45:55.940 --> 00:46:00.560
我们收到的是ping然后我们要

00:45:57.200 --> 00:46:02.150
通过乒乓球发回，反之亦然

00:46:00.560 --> 00:46:03.650
然后我们将回复发送回去

00:46:02.150 --> 00:46:06.430
好

00:46:03.650 --> 00:46:08.750
你知道我实际上可以

00:46:06.430 --> 00:46:11.720
做过我可能曾经做过的事情

00:46:08.750 --> 00:46:13.190
在这里打电话回覆

00:46:11.720 --> 00:46:17.050
我也可以做到

00:46:13.190 --> 00:46:18.860
本可以看着你知道的我

00:46:17.050 --> 00:46:20.960
本来可以做很多很多的

00:46:18.860 --> 00:46:22.280
这里的事情也可以处理，但是我们

00:46:20.960 --> 00:46:24.290
已经知道这将是那样，让我们

00:46:22.280 --> 00:46:25.760
我更有趣的是

00:46:24.290 --> 00:46:27.850
发生了什么事

00:46:25.760 --> 00:46:31.550
好的，所以当我们这样做时， 

00:46:27.850 --> 00:46:34.870
这是乒乓球应用程序，所以

00:46:31.550 --> 00:46:34.870
我会开始那个

00:46:44.850 --> 00:46:51.660
我们在那里，所以它将继续10 

00:46:47.650 --> 00:46:51.660
循环一个希望

00:46:53.220 --> 00:46:59.849
好吧，那不是很酷

00:46:56.309 --> 00:47:02.220
所以很明显收到乒乓球

00:46:59.849 --> 00:47:06.089
我收到的第一件事已收到

00:47:02.220 --> 00:47:08.700
 ping in pong，然后我们发回

00:47:06.089 --> 00:47:13.890
乒乓球在这里被承认

00:47:08.700 --> 00:47:15.780
然后我们收到ping等，这样

00:47:13.890 --> 00:47:17.700
你可以看到来回的球

00:47:15.780 --> 00:47:20.780
在两个方向上来回移动

00:47:17.700 --> 00:47:22.680
不同的生产者和消费者

00:47:20.780 --> 00:47:24.359
希望你有所感激

00:47:22.680 --> 00:47:26.460
因为现在这里可能

00:47:24.359 --> 00:47:28.500
到目前为止，尚有所有协议

00:47:26.460 --> 00:47:30.510
各种有趣的可能性

00:47:28.500 --> 00:47:31.970
是所有课程的开始

00:47:30.510 --> 00:47:35.309
一切将从Spring Framework开始

00:47:31.970 --> 00:47:43.369
 5.2将会看到我们的支持

00:47:35.309 --> 00:47:43.369
套接字网站我们的套接字github在这里

00:47:44.630 --> 00:47:51.930
我们的插座本身有一些有趣的地方

00:47:49.500 --> 00:47:55.339
东西来了，那里有棉花

00:47:51.930 --> 00:47:58.140
绑定显然要来了

00:47:55.339 --> 00:48:00.329
僵尸网络实现即将到来

00:47:58.140 --> 00:48:02.700
很酷的不同运输之一

00:48:00.329 --> 00:48:06.210
支持超级的亚伦

00:48:02.700 --> 00:48:09.029
开发的超快速协议

00:48:06.210 --> 00:48:10.440
马丁·汤普森（Martin Thompson）等人与您

00:48:09.029 --> 00:48:13.500
知道你是否想要的是

00:48:10.440 --> 00:48:15.299
绝对同情机器

00:48:13.500 --> 00:48:16.740
这个协议不，不是

00:48:15.299 --> 00:48:18.420
比这个要好得多，所以这是

00:48:16.740 --> 00:48:21.109
您可以使用的交通工具

00:48:18.420 --> 00:48:26.069
您只需添加库并使用

00:48:21.109 --> 00:48:28.680
有一个让我看到有一个Python 

00:48:26.069 --> 00:48:30.270
然后去我不确定的绑定

00:48:28.680 --> 00:48:32.599
那里取得了任何进展

00:48:30.270 --> 00:48:36.650
但这很有趣

00:48:32.599 --> 00:48:40.069
据我所记得，有一个

00:48:36.650 --> 00:48:40.069
负载均衡器

00:48:43.380 --> 00:48:46.380
仓库

00:48:47.329 --> 00:48:54.409
还是吮吸，让我们看看我们的第二个爪哇哦

00:48:51.099 --> 00:48:55.909
是的，有一个负载均衡的例子

00:48:54.409 --> 00:48:58.130
那里有一个负载支架

00:48:55.909 --> 00:49:00.769
人口众多的作品

00:48:58.130 --> 00:49:02.749
很好，有千分尺插管

00:49:00.769 --> 00:49:04.130
因此您实际上可以捕获指标并

00:49:02.749 --> 00:49:05.869
您我们已经谈到了千分尺

00:49:04.130 --> 00:49:08.149
上一期的 spring 技巧 I 

00:49:05.869 --> 00:49:09.019
鼓励您找到该视频， 

00:49:08.149 --> 00:49:11.209
观看以了解更多信息

00:49:09.019 --> 00:49:13.159
千分尺-您知道的好东西

00:49:11.209 --> 00:49:15.890
来了，事实上更多的例子

00:49:13.159 --> 00:49:19.279
知道II基于我们所说的一些内容

00:49:15.890 --> 00:49:21.109
关于今天的想法

00:49:19.279 --> 00:49:23.029
例如，如果您想要更多示例

00:49:21.109 --> 00:49:25.249
应该捐赠解决这个代码，但是

00:49:23.029 --> 00:49:27.439
还看这个空间，所以我们的插座女士

00:49:25.249 --> 00:49:28.459
对，那你知道有趣的手表

00:49:27.439 --> 00:49:30.380
空间，因为我们要

00:49:28.459 --> 00:49:34.249
就像我在春季从核心5.2所说的那样

00:49:30.380 --> 00:49:35.809
我们应该为我们插管

00:49:34.249 --> 00:49:37.729
套接字本身在框架中

00:49:35.809 --> 00:49:41.029
组件模型要多一点

00:49:37.729 --> 00:49:42.499
高级一点自然地

00:49:41.029 --> 00:49:44.119
映射到您的业务对象到您的

00:49:42.499 --> 00:49:47.119
那么我们的业务领域

00:49:44.119 --> 00:49:49.549
插座系数通过um连接

00:49:47.119 --> 00:49:53.059
你知道你通常会

00:49:49.549 --> 00:49:55.789
我的消费者只有一个客户

00:49:53.059 --> 00:49:57.259
这个案子是坪，只有一个

00:49:55.789 --> 00:49:58.519
曾经要求，但您通常会

00:49:57.259 --> 00:50:00.979
您通常不会那样做吗

00:49:58.519 --> 00:50:03.049
通常你会开始，但是你知道

00:50:00.979 --> 00:50:06.079
您的构造函数开始

00:50:03.049 --> 00:50:06.919
我们的套接字客户端，然后每当您

00:50:06.079 --> 00:50:08.329
需要提出要求

00:50:06.919 --> 00:50:09.829
每当有人，每当客户

00:50:08.329 --> 00:50:11.479
发出请求，您将获得一个指向

00:50:09.829 --> 00:50:12.769
我们的套接字客户端并提出请求

00:50:11.479 --> 00:50:15.349
对，所以这是他们，这是你的

00:50:12.769 --> 00:50:17.419
网关（如果要连接到或套接字） 

00:50:15.349 --> 00:50:19.069
服务，因此您将采购此藏匿处

00:50:17.419 --> 00:50:21.769
这会在构造函数中对其进行初始化

00:50:19.069 --> 00:50:25.549
然后一遍又一遍地使用它

00:50:21.769 --> 00:50:26.749
我希望我的朋友们都可以

00:50:25.549 --> 00:50:28.159
我希望你从中得到一些东西

00:50:26.749 --> 00:50:30.109
你会检查我希望的网站

00:50:28.159 --> 00:50:32.869
您将按照我们的介绍进行操作

00:50:30.109 --> 00:50:34.969
在2019年，我们将有一个

00:50:32.869 --> 00:50:37.819
更好，更大的插座支持

00:50:34.969 --> 00:50:39.529
在适当的框架中，我希望

00:50:37.819 --> 00:50:40.819
你会考虑你的可能性

00:50:39.529 --> 00:50:42.499
知道你可以做反应性续集数据

00:50:40.819 --> 00:50:45.259
访问您具有反应性的Web套接字

00:50:42.499 --> 00:50:47.359
您具有用于HTTP的反应式Web流量

00:50:45.259 --> 00:50:50.119
现在您已经有了我们的插座，什么时间

00:50:47.359 --> 00:50:52.429
基于基础而活着

00:50:50.119 --> 00:50:54.589
我拥有反应堆框架

00:50:52.429 --> 00:50:57.739
而且我想强调的是

00:50:54.589 --> 00:51:00.369
这不是做反应堆的唯一方法

00:50:57.739 --> 00:51:02.440
现在基于RPC 

00:51:00.369 --> 00:51:04.630
但我最喜欢的是

00:51:02.440 --> 00:51:05.950
最具潜力的

00:51:04.630 --> 00:51:12.029
有些人可能是

00:51:05.950 --> 00:51:16.329
对GRP C编译器感兴趣

00:51:12.029 --> 00:51:18.849
 Facebook权利Facebook没有

00:51:16.329 --> 00:51:21.999
来自Salesforce Salesforce的GRP C 

00:51:18.849 --> 00:51:24.489
编译器专业人士编译器插件

00:51:21.999 --> 00:51:27.369
然后生成基于反应堆的

00:51:24.489 --> 00:51:28.719
您知道的那种服务

00:51:27.369 --> 00:51:31.059
有趣，但当然那

00:51:28.719 --> 00:51:33.789
限制您使用G RPC的限制

00:51:31.059 --> 00:51:36.219
也就是说，它运行在HTTP 2之上

00:51:33.789 --> 00:51:38.440
它假设您要使用

00:51:36.219 --> 00:51:41.680
 Google Google协议缓冲区等

00:51:38.440 --> 00:51:45.430
你知道这可能会限制

00:51:41.680 --> 00:51:46.630
你知道不是我不认为是

00:51:45.430 --> 00:51:48.160
几乎有些灵活，这是记住

00:51:46.630 --> 00:51:50.739
开发我们的套接字的人

00:51:48.160 --> 00:51:52.569
他们在Facebook上知道gr PC 

00:51:50.739 --> 00:51:53.769
他们当然知道是什么

00:51:52.569 --> 00:51:55.509
有可能，他们仍然选择

00:51:53.769 --> 00:51:57.969
发展自己的道路

00:51:55.509 --> 00:51:59.950
因为那是一个更好的解决方案，所以我的

00:51:57.969 --> 00:52:01.690
我说的朋友非常感谢你

00:51:59.950 --> 00:52:05.160
看着我希望你从中得到一些东西

00:52:01.690 --> 00:52:05.160
这个，我们下次见

00:52:10.420 --> 00:52:12.480
您

