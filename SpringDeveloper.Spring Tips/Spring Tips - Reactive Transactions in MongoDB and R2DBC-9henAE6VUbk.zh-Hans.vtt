WEBVTT
Kind: captions
Language: zh-Hans

00:00:25.160 --> 00:00:29.369
嗨， Spring 粉丝们欢迎来到另一个

00:00:27.630 --> 00:00:30.689
在此安装Spring 提示

00:00:29.369 --> 00:00:33.090
分期付款，我们将谈论一个大

00:00:30.689 --> 00:00:35.699
我们刚刚推出的令人兴奋的新功能

00:00:33.090 --> 00:00:39.079
在上周的史诗般的 Spring I / O上宣布

00:00:35.699 --> 00:00:42.780
会议在西班牙巴塞罗那举行

00:00:39.079 --> 00:00:44.250
确实可以确保安全或

00:00:42.780 --> 00:00:46.649
马来西亚人的支持已经

00:00:44.250 --> 00:00:48.269
以某种形式存在于另一种

00:00:46.649 --> 00:00:53.519
要进行的不同项目的数量

00:00:48.269 --> 00:00:54.750
说被动交易，所以我们有两个

00:00:53.519 --> 00:00:56.879
支持的有趣项目

00:00:54.750 --> 00:00:59.070
目前的交易

00:00:56.879 --> 00:01:02.100
反应空间，我们有MongoDB作为

00:00:59.070 --> 00:01:04.920
的4.0版本现在支持跨

00:01:02.100 --> 00:01:07.920
谨慎的文件，我们有两个

00:01:04.920 --> 00:01:09.090
 DB C是反应式SPI和

00:01:07.920 --> 00:01:11.159
不同的实现数量

00:01:09.090 --> 00:01:13.890
根据那个spi与续集说话

00:01:11.159 --> 00:01:15.090
数据存储，这两个都是反应性的

00:01:13.890 --> 00:01:17.220
他们从头开始支持

00:01:15.090 --> 00:01:18.630
从头开始的异步IO 

00:01:17.220 --> 00:01:21.570
他们提供交易支持，因此

00:01:18.630 --> 00:01:24.290
这是一个机会

00:01:21.570 --> 00:01:27.899
抽象，所以虽然已经有

00:01:24.290 --> 00:01:29.490
我在MongoDB中提供个人支持

00:01:27.899 --> 00:01:32.520
一个MongoDB项目的 Spring 

00:01:29.490 --> 00:01:33.870
在RT DBC项目中进行交易

00:01:32.520 --> 00:01:36.979
那里那里还没有

00:01:33.870 --> 00:01:39.479
某种常见的标准化

00:01:36.979 --> 00:01:41.400
两者的整合就像

00:01:39.479 --> 00:01:44.340
现在有Springs平台

00:01:41.400 --> 00:01:46.500
事务管理器层次结构，所以我们

00:01:44.340 --> 00:01:47.520
要谈论的是新的支持

00:01:46.500 --> 00:01:49.860
我们将在两者中进行研究

00:01:47.520 --> 00:01:51.180
 MongoDB和RT BC无关紧要

00:01:49.860 --> 00:01:54.330
我当然会建立的例子

00:01:51.180 --> 00:01:55.260
在这里开始道格拉斯带来国际劳工组织

00:01:54.330 --> 00:01:57.390
所以我要继续建立一个新的

00:01:55.260 --> 00:02:00.869
应用程序，我将其称为rx TX 

00:01:57.390 --> 00:02:03.780
将使用反应式MongoDB，而我们使用Lombok 

00:02:00.869 --> 00:02:05.850
我们将使用让我们只使用一个

00:02:03.780 --> 00:02:08.239
反应式网页实际上我会摆脱

00:02:05.850 --> 00:02:13.290
以后，但我们会保留在那里

00:02:08.239 --> 00:02:16.620
我想那可能就是我们所要做的

00:02:13.290 --> 00:02:22.129
现在需要，我会介绍给

00:02:16.620 --> 00:02:29.269
 spring boot 的om3打开

00:02:22.129 --> 00:02:29.269
下载ale或x TX dot zip 

00:02:40.400 --> 00:02:45.110
这将旋转，当然首先

00:02:43.819 --> 00:02:47.090
我们要去做的事情

00:02:45.110 --> 00:02:50.150
首先要使用MongoDB，我们将在

00:02:47.090 --> 00:02:52.430
首先是MongoDB条款，我有MongoDB 

00:02:50.150 --> 00:02:55.370
现在在我的本地计算机上运行

00:02:52.430 --> 00:02:56.810
介意你不能只使用常规的

00:02:55.370 --> 00:02:58.819
你刚安装了一个

00:02:56.810 --> 00:03:00.739
结果安装将无法正常工作

00:02:58.819 --> 00:03:03.590
原因是因为您必须

00:03:00.739 --> 00:03:05.959
有一个副本集，所以我有这个

00:03:03.590 --> 00:03:08.480
我用的愚蠢的脚本，也许你

00:03:05.959 --> 00:03:12.319
可能还想使用以获取一个

00:03:08.480 --> 00:03:16.010
本地副本集进行，所以有

00:03:12.319 --> 00:03:17.989
脚本正确，所以我正在创建一个

00:03:16.010 --> 00:03:19.910
数据目录创建数据目录

00:03:17.989 --> 00:03:22.489
然后其中将做MongoDB复制

00:03:19.910 --> 00:03:23.510
设置等于我的副本集数据库路径数据

00:03:22.489 --> 00:03:25.099
等等等等等等

00:03:23.510 --> 00:03:27.709
然后我评估的背景

00:03:25.099 --> 00:03:29.540
副本表示发起到

00:03:27.709 --> 00:03:30.950
初始化副本集，以便

00:03:29.540 --> 00:03:36.200
这就是我要做的事情

00:03:30.950 --> 00:03:37.640
以某种方式工作的MongoDB实例

00:03:36.200 --> 00:03:40.010
我可以直接使用交易

00:03:37.640 --> 00:03:45.700
据我所知MongoDB为此- 

00:03:40.010 --> 00:03:49.880
应该有分布式交易

00:03:45.700 --> 00:03:52.069
好吧，您知道多个节点，但是现在

00:03:49.880 --> 00:03:53.810
这是我想的，我认为是

00:03:52.069 --> 00:03:55.250
限于我的意思是至少一个节点

00:03:53.810 --> 00:03:56.750
一个复制品说我不太确定

00:03:55.250 --> 00:03:59.120
究竟如何运作，但我知道你

00:03:56.750 --> 00:04:03.950
需要一个副本集，所以我们有这个

00:03:59.120 --> 00:04:05.540
现在您可以在这里使用我们的应用程序了

00:04:03.950 --> 00:04:08.720
我要在这里做正常的事情

00:04:05.540 --> 00:04:11.120
创建是让我们看看我想我想要

00:04:08.720 --> 00:04:17.599
字体要大一点，不是吗

00:04:11.120 --> 00:04:20.479
字体好吧，我们去

00:04:17.599 --> 00:04:24.919
我们希望那些可以说24 

00:04:20.479 --> 00:04:27.229
好，我们将创建一个对象

00:04:24.919 --> 00:04:32.560
显然将数据写入数据库

00:04:27.229 --> 00:04:38.630
扣住客户，我们将有一个私人

00:04:32.560 --> 00:04:43.280
字符串ID私人字符串电子邮件

00:04:38.630 --> 00:04:45.740
电子邮件有效，然后它将成为文档

00:04:43.280 --> 00:04:47.780
当然会有一个主键

00:04:45.740 --> 00:04:49.390
将使用添加文件记录一点地图

00:04:47.780 --> 00:04:53.719
 ID注解

00:04:49.390 --> 00:04:56.269
所有args构造函数中的数据

00:04:53.719 --> 00:04:58.009
北欧的构造函数，所以

00:04:56.269 --> 00:04:59.419
正常的东西，我要创建一个

00:04:58.009 --> 00:05:02.689
存储库以持久化和管理

00:04:59.419 --> 00:05:08.269
该实体的实例当然使用

00:05:02.689 --> 00:05:10.069
无功信用库管理

00:05:08.269 --> 00:05:12.979
实体客户的类型是

00:05:10.069 --> 00:05:16.219
字符串uh和类型的主键

00:05:12.979 --> 00:05:18.319
然后很有趣，我想使用UM，所以我

00:05:16.219 --> 00:05:19.789
会创建一个测试权限，但是顺序

00:05:18.319 --> 00:05:21.919
为了这个工作，我需要一些东西

00:05:19.789 --> 00:05:27.069
为了从中受益

00:05:21.919 --> 00:05:32.149
 Springs交易支持如此基础

00:05:27.069 --> 00:05:34.219
交易运营商在这里为了

00:05:32.149 --> 00:05:34.939
要工作，我需要创建一些

00:05:34.219 --> 00:05:38.360
这里的事情

00:05:34.939 --> 00:05:40.159
因此交易操作员会创建传递

00:05:38.360 --> 00:05:42.669
在反应陷阱和交易中

00:05:40.159 --> 00:05:46.129
经理和交易经理

00:05:42.669 --> 00:05:47.809
实施过程当然有所不同

00:05:46.129 --> 00:05:51.889
持久性技术到另一个如此

00:05:47.809 --> 00:05:58.360
我们将使用Mongo交易

00:05:51.889 --> 00:06:05.349
经理好，让我们说新的Mongo 

00:05:58.360 --> 00:06:11.269
交易这里最好的方法

00:06:05.349 --> 00:06:13.069
反应性Mongo交易经理和

00:06:11.269 --> 00:06:14.629
这是这种常见的实现

00:06:13.069 --> 00:06:17.239
类型称为被动交易管理器

00:06:14.629 --> 00:06:21.349
反过来，它期待一个反应性的蒙哥

00:06:17.239 --> 00:06:29.319
数据库工厂如此反应Mongo 

00:06:21.349 --> 00:06:33.199
数据库工厂已经存在，然后是DBF 

00:06:29.319 --> 00:06:37.879
得到东西，所以现在有

00:06:33.199 --> 00:06:39.919
现在应该足够了

00:06:37.879 --> 00:06:41.779
测试代码，实际上我们将尝试

00:06:39.919 --> 00:06:45.829
出来的时候，我要创造一个

00:06:41.779 --> 00:06:47.209
创建了处理此问题的服务权

00:06:45.829 --> 00:06:49.279
事务逻辑，所以我们有一个

00:06:47.209 --> 00:06:52.279
存储库对

00:06:49.279 --> 00:06:53.839
样样你知道克鲁德风格

00:06:52.279 --> 00:06:57.169
东西创建阅读更新删除你知道

00:06:53.839 --> 00:06:58.639
无聊的数据生命周期管理

00:06:57.169 --> 00:07:01.220
好吧，很简单的东西

00:06:58.639 --> 00:07:04.199
现在我们要创建一个客户

00:07:01.220 --> 00:07:09.000
服务，我们将有一种方法

00:07:04.199 --> 00:07:10.470
在这里返回保存的客户， 

00:07:09.000 --> 00:07:14.849
要大量写

00:07:10.470 --> 00:07:17.160
根据他们的电子邮件，很好

00:07:14.849 --> 00:07:20.069
简单的事情，我要实现

00:07:17.160 --> 00:07:21.870
作为一个em，这是一个需要的东西

00:07:20.069 --> 00:07:23.490
现在多次写入有更好的

00:07:21.870 --> 00:07:26.789
做到这一点的方法，但我想拥有

00:07:23.490 --> 00:07:29.520
多个独立的离散写入，因此

00:07:26.789 --> 00:07:32.490
我要做的是，让我们创建一个

00:07:29.520 --> 00:07:36.690
电子邮件名称之外的发布者

00:07:32.490 --> 00:07:42.060
而是我要接受每封电子邮件， 

00:07:36.690 --> 00:07:43.650
把它变成新客户好吧，我是

00:07:42.060 --> 00:07:45.990
要带走这些顾客中的每一个

00:07:43.650 --> 00:07:50.270
并按顺序将其写入数据

00:07:45.990 --> 00:07:50.270
为此，我当然需要注入我的

00:07:51.470 --> 00:07:56.750
这里的客户资料库

00:07:56.870 --> 00:08:03.690
我们将使其成为一项服务。 

00:08:00.900 --> 00:08:04.830
龙目岛合成一个构造函数，所以

00:08:03.690 --> 00:08:07.110
就知道创建一个构造函数

00:08:04.830 --> 00:08:08.880
对于最后一点的任何领域

00:08:07.110 --> 00:08:12.780
 kata一个参数和一些存储

00:08:08.880 --> 00:08:17.520
那让我先做然后再做客户

00:08:12.780 --> 00:08:21.539
立即在“保存客户”中发布

00:08:17.520 --> 00:08:24.300
有我们的整个管道，所以有我的

00:08:21.539 --> 00:08:28.590
数据，现在我要做的就是

00:08:24.300 --> 00:08:30.380
要使用，我们将得到三个

00:08:28.590 --> 00:08:32.729
三层不同

00:08:30.380 --> 00:08:37.349
交易管理方法

00:08:32.729 --> 00:08:40.829
好吧，第一个是我

00:08:37.349 --> 00:08:45.029
认为最灵活，所以这个点很好

00:08:40.829 --> 00:08:51.920
我们需要一个交易运营商，所以

00:08:45.029 --> 00:08:51.920
私人交易运营商可以

00:08:52.060 --> 00:08:56.220
这有点像交易

00:08:54.790 --> 00:09:00.130
模板的权利，你可以就可以

00:08:56.220 --> 00:09:01.960
提供新的交易回调权限

00:09:00.130 --> 00:09:04.480
而您提供的发布商是

00:09:01.960 --> 00:09:06.190
在交易中退还东西

00:09:04.480 --> 00:09:08.290
在这种情况下，我可以退货

00:09:06.190 --> 00:09:09.570
正确的记住我们没有执行

00:09:08.290 --> 00:09:12.970
任何正确的事，我们实际上不是

00:09:09.570 --> 00:09:15.190
执行我们制造了感冒

00:09:12.970 --> 00:09:16.930
流水线处理冷数据流

00:09:15.190 --> 00:09:19.180
没有实际的数据流过

00:09:16.930 --> 00:09:21.280
即使我们定义了

00:09:19.180 --> 00:09:23.560
或以外的交易或

00:09:21.280 --> 00:09:25.900
而是我们定义定义的逻辑

00:09:23.560 --> 00:09:27.310
有交易，您知道语义，我们

00:09:25.900 --> 00:09:28.930
在交易之外定义

00:09:27.310 --> 00:09:30.580
阻止无关紧要，因为我们

00:09:28.930 --> 00:09:33.100
不执行它只会给你

00:09:30.580 --> 00:09:35.280
在以下情况下订阅

00:09:33.100 --> 00:09:37.660
交易，当然这是一个

00:09:35.280 --> 00:09:38.220
非常适合lambda，所以这非常

00:09:37.660 --> 00:09:42.790
简单

00:09:38.220 --> 00:09:43.930
然后我们就可以了，这就是这个

00:09:42.790 --> 00:09:45.550
交易模板很好，因为

00:09:43.930 --> 00:09:47.860
你实际上可以知道那只是

00:09:45.550 --> 00:09:49.270
返回与我们完全相同的东西

00:09:47.860 --> 00:09:50.980
给它返回我们的出版商

00:09:49.270 --> 00:09:52.960
客户，然后我可以撰写

00:09:50.980 --> 00:09:55.060
与其他流，我可以继续

00:09:52.960 --> 00:09:57.460
处理它，但只处理里面的东西

00:09:55.060 --> 00:09:59.290
该交易运营商的

00:09:57.460 --> 00:10:01.630
 executes块将在内部执行

00:09:59.290 --> 00:10:03.100
在交易主体中

00:10:01.630 --> 00:10:06.520
现在我们有了这个，让我们创建一个简单的

00:10:03.100 --> 00:10:10.540
测试简单，测试出结果

00:10:06.520 --> 00:10:17.080
好的，这将是一个公众

00:10:10.540 --> 00:10:20.980
与Spring一起运行的类渲染点

00:10:17.080 --> 00:10:23.700
类Spring 循环测试，我们只是

00:10:20.980 --> 00:10:32.040
基本上会创建一个测试脚本

00:10:23.700 --> 00:10:35.040
好的，所以测试一下public void保存一切吧

00:10:32.040 --> 00:10:35.040
抛出

00:10:37.170 --> 00:10:48.900
我们去了，我们要注入我们的

00:10:42.600 --> 00:10:52.570
交易操作员没事

00:10:48.900 --> 00:10:55.590
实际上，我们不会注入

00:10:52.570 --> 00:10:58.590
这里的客户服务我们会说客户

00:10:55.590 --> 00:10:58.590
服务

00:11:00.070 --> 00:11:03.699
我要做的就是写

00:11:01.870 --> 00:11:05.860
现在我没有一些数据到数据库

00:11:03.699 --> 00:11:08.079
实际定义什么会失败，所以这

00:11:05.860 --> 00:11:10.149
这是一条幸福的道路

00:11:08.079 --> 00:11:11.529
我没有对此进行任何验证

00:11:10.149 --> 00:11:13.120
假设我经历了每个

00:11:11.529 --> 00:11:16.029
发行人中的客户

00:11:13.120 --> 00:11:17.920
我决定哦，你知道吗

00:11:16.029 --> 00:11:20.259
这些邮件无效

00:11:17.920 --> 00:11:22.709
好吧，我不能坚持下去，所以我要

00:11:20.259 --> 00:11:30.220
再做一件事我要说好

00:11:22.709 --> 00:11:34.660
我们要断言顾客得到了

00:11:30.220 --> 00:11:36.550
电子邮件点包含并写是否

00:11:34.660 --> 00:11:38.620
不包含它，那么它将抛出一个

00:11:36.550 --> 00:11:39.850
异常和事务运算符

00:11:38.620 --> 00:11:41.920
会看到它，然后我们将滚动

00:11:39.850 --> 00:11:43.959
退回交易将发出错误

00:11:41.920 --> 00:11:49.199
基本上然后回滚

00:11:43.959 --> 00:11:53.170
交易，因此电子邮件中必须包含

00:11:49.199 --> 00:11:54.699
好的，有我们的更新代码，所以现在

00:11:53.170 --> 00:11:56.560
要测试那个脚本亚当我是什么

00:11:54.699 --> 00:11:58.029
我要做的是写一些数据到

00:11:56.560 --> 00:11:58.930
首先我要说的数据库

00:11:58.029 --> 00:12:02.319
全部都会删除其中的所有内容

00:11:58.930 --> 00:12:04.930
数据库，所以我们说创建这个点

00:12:02.319 --> 00:12:07.240
客户服务点或对不起需要

00:12:04.930 --> 00:12:09.459
仓库来做到这一点，所以我在做什么

00:12:07.240 --> 00:12:12.819
我正在使用反应堆吗

00:12:09.459 --> 00:12:14.380
步骤验证器当然要简短

00:12:12.819 --> 00:12:16.779
运行该测试的工作

00:12:14.380 --> 00:12:22.949
反应性依赖这里的东西

00:12:16.779 --> 00:12:26.350
客户暂停驱动器全部删除，然后

00:12:22.949 --> 00:12:28.630
我希望它是完整的我

00:12:26.350 --> 00:12:30.790
认为可行，让我们尝试一下

00:12:28.630 --> 00:12:31.870
应该可以，所以我要重置

00:12:30.790 --> 00:12:34.649
数据库中应该没有任何内容

00:12:31.870 --> 00:12:34.649
此时的数据库

00:12:45.040 --> 00:12:49.690
好吧，现在让我们写一些数据

00:12:47.770 --> 00:12:56.170
所以当你说这副牌客户

00:12:49.690 --> 00:12:59.170
或在插入点上有一个点不是真的

00:12:56.170 --> 00:13:06.910
想说点这个客服

00:12:59.170 --> 00:13:13.990
点保存全部将是八点

00:13:06.910 --> 00:13:16.630
在Viacom C，C冷静，d @d冷静，所以

00:13:13.990 --> 00:13:19.630
我们预计会有四项记录

00:13:16.630 --> 00:13:23.830
现在在数据库中，所以期待下一次计数

00:13:19.630 --> 00:13:25.330
将是四个，我们应该有四个

00:13:23.830 --> 00:13:27.730
相同操作的结果

00:13:25.330 --> 00:13:30.730
这些都是有效的电子邮件

00:13:27.730 --> 00:13:32.080
关于我们进行查询以查找

00:13:30.730 --> 00:13:35.500
海军要确认的一切

00:13:32.080 --> 00:13:37.300
所以我会说点创建这个

00:13:35.500 --> 00:13:42.850
客户服务就像我们的债务一样好

00:13:37.300 --> 00:13:48.460
找到所有期望的存储库

00:13:42.850 --> 00:13:55.150
计数将等于四个好吧

00:13:48.460 --> 00:13:57.550
然后最后让我们写两个

00:13:55.150 --> 00:13:59.740
不良记录到数据库并确认

00:13:57.550 --> 00:14:02.100
在我们写完之后

00:13:59.740 --> 00:14:04.660
要采取，所以我们应该看到它回滚

00:14:02.100 --> 00:14:05.950
所以我们应该看到总数

00:14:04.660 --> 00:14:07.330
数据库中的记录数为

00:14:05.950 --> 00:14:13.660
还是四个还好

00:14:07.330 --> 00:14:21.490
因此，让我们再次尝试点保存所有

00:14:13.660 --> 00:14:23.290
知道一个并期望错误点验证

00:14:21.490 --> 00:14:25.210
所以我们期望这应该

00:14:23.290 --> 00:14:28.390
导致错误，我们期待

00:14:25.210 --> 00:14:29.980
既没有记录也没有第一

00:14:28.390 --> 00:14:32.970
第二个是一个

00:14:29.980 --> 00:14:32.970
这样写在这里

00:14:35.190 --> 00:14:42.850
好吧，我们可以尝试一个

00:14:40.720 --> 00:14:47.440
你知道什么尝试八对我平息他们

00:14:42.850 --> 00:14:50.740
去吧，这是一个或更好的ii 

00:14:47.440 --> 00:14:53.020
冷静好吧，所以我们应该看到其中之一

00:14:50.740 --> 00:14:55.480
没有写，所以我们应该看到

00:14:53.020 --> 00:14:57.070
他们都回滚，即使一个

00:14:55.480 --> 00:14:59.680
是有效的，因为这是一个

00:14:57.070 --> 00:15:05.440
例外，所以现在我们要说这个

00:14:59.680 --> 00:15:08.950
点客户服务点对不起

00:15:05.440 --> 00:15:15.610
找到所有点的存储库期待下一个

00:15:08.950 --> 00:15:20.860
在这里计数，应该等于

00:15:15.610 --> 00:15:23.430
四站好，让我们看看会发生什么

00:15:20.860 --> 00:15:23.430
如果我们运行这个

00:15:34.800 --> 00:15:38.730
好吧，我们在做什么错

00:15:47.790 --> 00:15:49.820
哦

00:15:50.440 --> 00:15:58.199
正确的期待下一个肯定

00:15:55.839 --> 00:15:58.199
再次

00:16:08.330 --> 00:16:12.560
好吧，即使我们

00:16:11.240 --> 00:16:15.020
有两张唱片，我们有一张

00:16:12.560 --> 00:16:16.550
定期记录一个错误，当我们

00:16:15.020 --> 00:16:18.140
对我们只有的数据库进行了查询

00:16:16.550 --> 00:16:20.810
四记录在当地人的石头和

00:16:18.140 --> 00:16:23.090
那就是说这两个是

00:16:20.810 --> 00:16:24.380
回滚他们在那里

00:16:23.090 --> 00:16:26.120
相同的交易相同的逻辑

00:16:24.380 --> 00:16:28.130
交易，所以我们可以看到我们

00:16:26.120 --> 00:16:31.580
使用事务运算符来做

00:16:28.130 --> 00:16:33.890
包含所有这些权利

00:16:31.580 --> 00:16:36.560
现在在一个逻辑事务中进行逻辑

00:16:33.890 --> 00:16:38.630
这是在

00:16:36.560 --> 00:16:39.710
 Spring 是非常低级的，但是

00:16:38.630 --> 00:16:42.050
很好，因为你可以给它任何

00:16:39.710 --> 00:16:46.070
发布者，它将关闭该发布者

00:16:42.050 --> 00:16:48.440
在交易中，就像我说的那样

00:16:46.070 --> 00:16:50.360
非常类似于交易模板

00:16:48.440 --> 00:16:52.370
和Spring Framework ，这当然

00:16:50.360 --> 00:16:54.410
确实存在于Spring Framework中，您可以

00:16:52.370 --> 00:16:56.360
看到这实际上是 Spring 的一部分

00:16:54.410 --> 00:17:00.470
框架交易支持

00:16:56.360 --> 00:17:01.730
在PAC包装下反应还好吧

00:17:00.470 --> 00:17:05.180
这是另一种方式

00:17:01.730 --> 00:17:10.430
真的是说我们

00:17:05.180 --> 00:17:13.780
要这样做

00:17:10.430 --> 00:17:17.200
交易算子点交易

00:17:13.780 --> 00:17:21.830
这样，所以你就回来

00:17:17.200 --> 00:17:24.800
客户可以，所以我们在这里

00:17:21.830 --> 00:17:26.450
实际使用事务运算符

00:17:24.800 --> 00:17:27.680
再次，但我们实际上是将其添加到

00:17:26.450 --> 00:17:29.510
现有管道的末端而不是

00:17:27.680 --> 00:17:31.040
比包装它的效果应该是

00:17:29.510 --> 00:17:33.310
同样，让我们​​运行测试，看看有什么

00:17:31.040 --> 00:17:33.310
发生

00:17:42.630 --> 00:17:46.049
好吧，我们的测试产品行得通

00:17:45.419 --> 00:17:49.890
正好

00:17:46.049 --> 00:17:53.070
现在我们可以做到的另一种方法是

00:17:49.890 --> 00:17:55.049
我们可以使用声明式交易

00:17:53.070 --> 00:17:56.429
管理好，这是一种

00:17:55.049 --> 00:17:59.370
作品是你说安东尼会交易

00:17:56.429 --> 00:18:01.350
您的管理，就像在

00:17:59.370 --> 00:18:03.660
 Spring 就像定期同步

00:18:01.350 --> 00:18:06.390
您只能说阻止交易

00:18:03.660 --> 00:18:12.530
添加事务性并返回

00:18:06.390 --> 00:18:12.530
所以我们不再需要这个了

00:18:26.360 --> 00:18:30.590
是的，还不错吧，这三个不同

00:18:29.120 --> 00:18:32.630
使用交易管理的方式

00:18:30.590 --> 00:18:36.409
支持这里我们已经为MongoDB完成了

00:18:32.630 --> 00:18:38.769
现在让我们尝试RTD BC 

00:18:36.409 --> 00:18:40.700
 TBC并没有很多，它必须明显改变

00:18:38.769 --> 00:18:42.140
你知道他们不是同一种

00:18:40.700 --> 00:18:44.120
资料储存库过时的文件

00:18:42.140 --> 00:18:45.740
数据库是一个续集数据存储

00:18:44.120 --> 00:18:48.110
我将使用测验

00:18:45.740 --> 00:18:50.450
把这个物体变成具有

00:18:48.110 --> 00:18:53.240
单调递增主键

00:18:50.450 --> 00:18:54.980
得到真正的文档注释，我去

00:18:53.240 --> 00:18:57.590
回到我的构建，我要替换

00:18:54.980 --> 00:18:59.870
一些依赖关系，即妈妈

00:18:57.590 --> 00:19:03.769
得到同等的支持

00:18:59.870 --> 00:19:10.760
新的交易支持

00:19:03.769 --> 00:19:16.220
管理，所以摆脱它，我们

00:19:10.760 --> 00:19:18.350
想要一个新的实验依赖性，所以我

00:19:16.220 --> 00:19:20.360
需要实际上这不是实际上

00:19:18.350 --> 00:19:23.090
 spring boot 或Spring 数据的一部分

00:19:20.360 --> 00:19:25.760
释放链，所以我需要带进去

00:19:23.090 --> 00:19:31.650
这个自定义的东西在这里依赖

00:19:25.760 --> 00:19:37.049
管理依赖

00:19:31.650 --> 00:19:42.779
依赖Spring Boot的依赖是

00:19:37.049 --> 00:19:52.590
 GBC，这是0.1点o 2 m 1和

00:19:42.779 --> 00:19:56.490
这将是一个掌上型输入全部

00:19:52.590 --> 00:19:59.520
对，所以有那个

00:19:56.490 --> 00:20:02.610
现在我们可以携带设备的地方

00:19:59.520 --> 00:20:04.429
 TBC的适当依赖项

00:20:02.610 --> 00:20:06.330
本身包括这个新的

00:20:04.429 --> 00:20:08.970
实验性的，但你非常了解

00:20:06.330 --> 00:20:11.100
有趣且很有前途的汽车

00:20:08.970 --> 00:20:13.520
我们TBC的配置好了

00:20:11.100 --> 00:20:24.240
也是新的，它是 spring boot 

00:20:13.520 --> 00:20:31.470
开始，是的，把它带进去， 

00:20:24.240 --> 00:20:34.350
这样我们也可以带来

00:20:31.470 --> 00:20:36.299
我们的TVC的 spring boot 启动器

00:20:34.350 --> 00:20:38.399
没有 Spring 的数据，所以如果你不想

00:20:36.299 --> 00:20:39.840
存储库支持，那么您就不需要

00:20:38.399 --> 00:20:41.070
需要你不需要把它带进你

00:20:39.840 --> 00:20:43.080
可以带进DBC，您知道

00:20:41.070 --> 00:20:45.149
数据库客户端和类似的东西

00:20:43.080 --> 00:20:47.159
但是，无论如何，这都是这些

00:20:45.149 --> 00:20:49.980
都是每个人的贷方额度

00:20:47.159 --> 00:20:57.090
不是MongoDB，所以我已经发布测验了

00:20:49.980 --> 00:21:02.130
所以不，我们要兰花UVC驱动程序

00:20:57.090 --> 00:21:04.610
我们不是吗，那是我欠我们的

00:21:02.130 --> 00:21:04.610
公元前

00:21:09.029 --> 00:21:14.910
好的

00:21:11.140 --> 00:21:14.910
我们想抓住您的支持

00:21:16.210 --> 00:21:25.870
好东西，现在让我们看看

00:21:22.840 --> 00:21:26.560
否则我必须改变得很好

00:21:25.870 --> 00:21:32.250
会的

00:21:26.560 --> 00:21:32.250
其实我觉得差不多

00:21:37.570 --> 00:21:41.020
好吧，我想他

00:21:44.680 --> 00:21:49.300
我当然要改变这个

00:21:47.230 --> 00:21:51.100
是弧形TBC交易经理，并且

00:21:49.300 --> 00:21:53.530
它需要一个指向连接的指针

00:21:51.100 --> 00:21:56.320
工厂和连接工厂

00:21:53.530 --> 00:21:58.390
当然是我们习惯的事情

00:21:56.320 --> 00:22:00.880
描述我们与数据库的连接

00:21:58.390 --> 00:22:04.810
文章数据库，我们将成为

00:22:00.880 --> 00:22:10.960
在这里使用任何连接工厂

00:22:04.810 --> 00:22:12.340
 Postgres连接返回三和中

00:22:10.960 --> 00:22:16.780
为了获得那个连接工厂

00:22:12.340 --> 00:22:18.100
我将使用属性注入URL 

00:22:16.780 --> 00:22:25.090
占位符，我们将在

00:22:18.100 --> 00:22:32.410
第二个 Spring 是-你看到

00:22:25.090 --> 00:22:36.100
工厂中的URL连接dot获取URL 

00:22:32.410 --> 00:22:38.530
好的，所以现在

00:22:36.100 --> 00:22:45.040
当然我们需要财产本身或

00:22:38.530 --> 00:22:50.130
可以算出现在等于然后

00:22:45.040 --> 00:22:53.640
是我的数据库的JDBC URL，例如

00:22:50.130 --> 00:22:53.640
你稍等一会儿

00:23:05.540 --> 00:23:18.050
好吧，这是我们的DC，这是新的

00:23:10.880 --> 00:23:27.160
协议前缀：PostgreSQL：用于此类

00:23:18.050 --> 00:23:31.940
在本地主机的四个斜杠命令

00:23:27.160 --> 00:23:34.010
五四三二网站订单还可以

00:23:31.940 --> 00:23:35.960
所以这就是我的数据库正在运行

00:23:34.010 --> 00:23:38.560
我的本地机器在这里尝试

00:23:35.960 --> 00:23:38.560
再次相同的测试

00:23:49.540 --> 00:23:53.890
很酷，所以又有相同的测试

00:23:51.820 --> 00:23:56.430
再次用新代码编写，您

00:23:53.890 --> 00:23:58.720
可以看到我们能够知道

00:23:56.430 --> 00:24:03.280
得到相同的结果，我们看到了

00:23:58.720 --> 00:24:07.420
相同行为的订单订单全选

00:24:03.280 --> 00:24:09.330
从客户那里，我们看到的是正确的

00:24:07.420 --> 00:24:19.180
我必须去这里的四个记录

00:24:09.330 --> 00:24:25.090
 MongoDB客户必将成为DB 

00:24:19.180 --> 00:24:26.200
发现这里有我们的完整记录

00:24:25.090 --> 00:24:27.250
在我的朋友们，我希望你能得到一些东西

00:24:26.200 --> 00:24:28.930
因此，我希望你能给出

00:24:27.250 --> 00:24:29.710
新给予新交易

00:24:28.930 --> 00:24:31.780
支持尝试

00:24:29.710 --> 00:24:33.160
显然有很多有趣的事情

00:24:31.780 --> 00:24:35.020
这里的机会越来越多

00:24:33.160 --> 00:24:36.600
数据库进入在线状态

00:24:35.020 --> 00:24:40.570
支持和反应

00:24:36.600 --> 00:24:42.760
插管，我认为这意味着支持

00:24:40.570 --> 00:24:45.640
现在，整个类的预加载

00:24:42.760 --> 00:24:47.710
我们认为这是无法实现的

00:24:45.640 --> 00:24:50.440
在反应世界中无法获得的是

00:24:47.710 --> 00:24:52.030
现在可用，令人兴奋

00:24:50.440 --> 00:24:55.140
非常感谢您的收看和

00:24:52.030 --> 00:24:55.140
总是我们下次见

00:25:00.620 --> 00:25:02.680
您

