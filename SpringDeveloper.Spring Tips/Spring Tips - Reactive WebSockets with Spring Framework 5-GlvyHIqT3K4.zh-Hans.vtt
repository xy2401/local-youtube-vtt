WEBVTT
Kind: captions
Language: zh-Hans

00:00:25.200 --> 00:00:29.950
嗨，春季粉丝们欢迎来到另一个

00:00:27.760 --> 00:00:31.060
在此安装弹簧提示

00:00:29.950 --> 00:00:34.330
分期付款，我们将研究如何

00:00:31.060 --> 00:00:37.150
使用创建基于Web套接字的API 

00:00:34.330 --> 00:00:39.489
新的反应式Spring Web Flex API和

00:00:37.150 --> 00:00:41.770
当我们看Spring Framework 5的时候

00:00:39.489 --> 00:00:44.170
我们最后看了我们的服务和事件

00:00:41.770 --> 00:00:46.150
看到建立服务器端推送

00:00:44.170 --> 00:00:48.879
使用服务和事件的机制，以及

00:00:46.150 --> 00:00:51.370
 Spring Web Flex API是认知上的

00:00:48.879 --> 00:00:53.739
非常简单，我们不必做

00:00:51.370 --> 00:00:55.629
精神上或其他方面的很多体操

00:00:53.739 --> 00:00:57.940
使这项工作，我们会发现

00:00:55.629 --> 00:01:00.400
今天，当我们建立网站时也是如此

00:00:57.940 --> 00:01:02.290
现在我们可以建立套接字API 

00:01:00.400 --> 00:01:05.110
实际的API本身，我们需要客户权限

00:01:02.290 --> 00:01:09.130
所以我们要建立一个琐碎的客户

00:01:05.110 --> 00:01:12.820
今天使用angular for和angular for 

00:01:09.130 --> 00:01:16.509
您使用一种称为

00:01:12.820 --> 00:01:19.210
打字稿，所以我们可以说ng new wshh 

00:01:16.509 --> 00:01:24.210
客户，这实际上需要大约

00:01:19.210 --> 00:01:24.210
一分钟的时间来减轻

00:02:39.310 --> 00:02:44.780
现在我们有一个新客户

00:02:42.710 --> 00:02:47.360
就像我说的那样打开这个罪犯的身份证

00:02:44.780 --> 00:02:49.310
这个项目正在使用角度

00:02:47.360 --> 00:02:52.310
依次使用打字稿，我们现在

00:02:49.310 --> 00:02:55.340
选择使用角度和打字稿

00:02:52.310 --> 00:02:56.750
因为这是一个非常熟悉的环境

00:02:55.340 --> 00:02:59.300
有史以来很熟悉的语言

00:02:56.750 --> 00:03:00.980
您曾经使用Cottman构建任何东西

00:02:59.300 --> 00:03:03.050
这将为服务器端的权利

00:03:00.980 --> 00:03:04.910
这是一个很好的借口，因为我们

00:03:03.050 --> 00:03:06.770
已经都使用外语了

00:03:04.910 --> 00:03:09.290
这个客户也要建立服务

00:03:06.770 --> 00:03:10.160
使用大陆实施

00:03:09.290 --> 00:03:12.530
编程语言

00:03:10.160 --> 00:03:15.020
弹簧靴很容易在本地支持

00:03:12.530 --> 00:03:16.430
所以我们有了新的应用程序， 

00:03:15.020 --> 00:03:18.160
将构建您知道的应用程序

00:03:16.430 --> 00:03:19.850
我们只是要建立一个非常简单的

00:03:18.160 --> 00:03:21.890
组件在这里，我们要去

00:03:19.850 --> 00:03:23.990
根组件称为AB组件， 

00:03:21.890 --> 00:03:27.800
我们将建立一个简单的模板

00:03:23.990 --> 00:03:29.240
顺便说一句，我们不会指定您

00:03:27.800 --> 00:03:30.610
知道一个人只是为了保留东西

00:03:29.240 --> 00:03:32.720
简单

00:03:30.610 --> 00:03:34.370
我从树上学到了这个

00:03:32.720 --> 00:03:36.460
人们不要让它产生

00:03:34.370 --> 00:03:38.750
您的JavaScript，所以我要说H1 

00:03:36.460 --> 00:03:42.590
文件，想法是我们要有一个

00:03:38.750 --> 00:03:44.480
列出任何新文件的服务

00:03:42.590 --> 00:03:45.980
出现在目录中不是很好

00:03:44.480 --> 00:03:49.040
有趣的例子，但确实如此

00:03:45.980 --> 00:03:51.620
确实使我们能够演示

00:03:49.040 --> 00:03:53.690
我们使用几个不同的概念

00:03:51.620 --> 00:03:55.730
网站API和反应式

00:03:53.690 --> 00:03:57.500
在后台水暖我们

00:03:55.730 --> 00:03:59.720
会有文件清单，但是

00:03:57.500 --> 00:04:01.520
现在你知道这只是最简单的

00:03:59.720 --> 00:04:03.590
机械周，我们可以这样工作

00:04:01.520 --> 00:04:05.630
我们可以稍后再存根

00:04:03.590 --> 00:04:09.530
然后看看它是否有效，让我们说

00:04:05.630 --> 00:04:15.250
我们将有一个div的集合

00:04:09.530 --> 00:04:17.570
元素列表中的每一项

00:04:15.250 --> 00:04:18.919
文件事件正确，所以我们说

00:04:17.570 --> 00:04:22.850
里面有一个新文件，他们被发送了

00:04:18.919 --> 00:04:25.310
通过WebSockets到客户端

00:04:22.850 --> 00:04:27.140
然后使用更新的

00:04:25.310 --> 00:04:30.320
更新集合的信息

00:04:27.140 --> 00:04:33.440
这样可以让客户满意

00:04:30.320 --> 00:04:35.330
我想说让文件f，我们将

00:04:33.440 --> 00:04:37.610
写出有关文件的信息

00:04:35.330 --> 00:04:40.730
所以我们要写出

00:04:37.610 --> 00:04:45.110
路径以及会话ID，因此我们将

00:04:40.730 --> 00:04:46.540
说跨度样式字体大小等于

00:04:45.110 --> 00:04:48.970
较小的

00:04:46.540 --> 00:04:51.520
然后我们写出会话ID 

00:04:48.970 --> 00:04:53.590
因此会话ID非常好，现在我们已经

00:04:51.520 --> 00:04:55.750
现在我们当然需要

00:04:53.590 --> 00:04:59.440
实际定义类型，以便当您

00:04:55.750 --> 00:05:02.620
像这样定义一个接口文件事件

00:04:59.440 --> 00:05:07.210
我要给它一个路径字符串

00:05:02.620 --> 00:05:10.990
会话ID字符串，我们将其写为

00:05:07.210 --> 00:05:13.180
现在，我们将创建一个字段

00:05:10.990 --> 00:05:16.930
管理我们的数组，我们的文件数组位于

00:05:13.180 --> 00:05:19.600
使文件事件等于空

00:05:16.930 --> 00:05:21.220
数组列出一个空数组，现在我们需要一个

00:05:19.600 --> 00:05:22.770
构造函数，然后在

00:05:21.220 --> 00:05:25.810
构造函数，我们将使用

00:05:22.770 --> 00:05:28.480
 WebSocket客户端，所以我要说新的

00:05:25.810 --> 00:05:33.100
网络套接字，在这种情况下，我们将使用

00:05:28.480 --> 00:05:35.260
当然是8080的WS前缀

00:05:33.100 --> 00:05:36.940
我们的服务正在运行，我们需要一个

00:05:35.260 --> 00:05:38.200
端点名称，因此输入名称可以是

00:05:36.940 --> 00:05:41.200
任何我真正要称呼的东西

00:05:38.200 --> 00:05:43.800
 WS文件，我们将在此处使用

00:05:41.200 --> 00:05:46.270
客户代码，我要说这个点

00:05:43.800 --> 00:05:48.670
信息等于我要给它一个

00:05:46.270 --> 00:05:50.830
回调，回调将是

00:05:48.670 --> 00:05:53.200
它会包含一条消息，参数

00:05:50.830 --> 00:05:54.940
这里是消息事件类型，所以消息

00:05:53.200 --> 00:05:57.510
事件等于然后我们要

00:05:54.940 --> 00:05:59.680
在这里提供一个lambda到回调

00:05:57.510 --> 00:06:01.120
调用，将要发生的是

00:05:59.680 --> 00:06:03.250
当我们收到新消息事件时

00:06:01.120 --> 00:06:04.630
取消引用我要去的数据

00:06:03.250 --> 00:06:06.610
将其存储在一个变量中

00:06:04.630 --> 00:06:09.550
实际上，因为它会存储为Const 

00:06:06.610 --> 00:06:11.740
我们永远都不会改变它，而我们

00:06:09.550 --> 00:06:15.340
会解析它会来的

00:06:11.740 --> 00:06:16.990
我们期望以字符串形式输入，然后我们可以

00:06:15.340 --> 00:06:19.330
把那个解析的东西放到一个

00:06:16.990 --> 00:06:21.010
归档文件，因此实际上数据是

00:06:19.330 --> 00:06:24.460
它的文件尝试，我们知道，因为

00:06:21.010 --> 00:06:25.930
这是你知道设计

00:06:24.460 --> 00:06:27.880
方式，但我们不需要这多余的东西

00:06:25.930 --> 00:06:30.040
在声明中完成它确实输入

00:06:27.880 --> 00:06:32.110
推论很好，最后我们

00:06:30.040 --> 00:06:36.550
要将这些数据写入文件

00:06:32.110 --> 00:06:39.010
收藏，你知道我们的模板

00:06:36.550 --> 00:06:40.660
很好，因为双向绑定

00:06:39.010 --> 00:06:42.490
地方感谢角度它将更新

00:06:40.660 --> 00:06:44.470
与新数据有关

00:06:42.490 --> 00:06:46.390
这就是我们为客户所需要的

00:06:44.470 --> 00:06:47.830
使一切正常运行的经验

00:06:46.390 --> 00:06:50.260
让我们开始吧

00:06:47.830 --> 00:06:56.370
在这里运行的应用程序相同

00:06:50.260 --> 00:06:56.370
打开节点

00:06:57.020 --> 00:07:02.939
它将启动运行的浏览器

00:07:00.210 --> 00:07:04.379
该应用程序首先导入4200 

00:07:02.939 --> 00:07:06.779
它加载的时间有点慢，但是你

00:07:04.379 --> 00:07:08.099
知道我们可以看到它正在工作

00:07:06.779 --> 00:07:09.090
连接，您可以看看是否

00:07:08.099 --> 00:07:10.650
这里的控制台和网络

00:07:09.090 --> 00:07:12.689
活动尝试连接

00:07:10.650 --> 00:07:14.550
本地主机8080 WS文件，但是

00:07:12.689 --> 00:07:16.770
什么都没发生，我们需要提供

00:07:14.550 --> 00:07:18.389
工作服务，让我们做到这一点

00:07:16.770 --> 00:07:20.460
我要去那个春天开始

00:07:18.389 --> 00:07:21.810
要去棉花你知道副本

00:07:20.460 --> 00:07:23.879
我要选择Kotlin作为我的语言

00:07:21.810 --> 00:07:26.550
在这里，我们将使用弹簧靴

00:07:23.879 --> 00:07:28.319
点om3，所以这是最新的

00:07:26.550 --> 00:07:30.360
截至本修订版的最佳春季靴

00:07:28.319 --> 00:07:33.569
截至目前，这使我们能够建立

00:07:30.360 --> 00:07:35.009
你知道反应式应用程序使用

00:07:33.569 --> 00:07:36.779
弹簧架5和无功

00:07:35.009 --> 00:07:38.550
支持其中，所以我要使用

00:07:36.779 --> 00:07:40.349
反应性网络，我们当然要

00:07:38.550 --> 00:07:42.090
使用spring集成，我们会回来的

00:07:40.349 --> 00:07:43.919
到我们正在做的一点

00:07:42.090 --> 00:07:47.430
有点，但是现在我们拥有了一切

00:07:43.919 --> 00:07:53.300
需要，让我们转到这里的控制台

00:07:47.430 --> 00:07:58.560
一级解压缩WS服务CD WS服务

00:07:53.300 --> 00:08:02.430
现在我们打开它

00:07:58.560 --> 00:08:05.279
有了一个新项目，所以第一个目标应该是

00:08:02.430 --> 00:08:07.020
只是为了定义一个骨骼锯

00:08:05.279 --> 00:08:08.969
 Web套接字的某种服务

00:08:07.020 --> 00:08:10.770
发送基本数据并不一定要

00:08:08.969 --> 00:08:12.689
特别有趣，我们只想

00:08:10.770 --> 00:08:16.319
证明该管道正在工作，并且

00:08:12.689 --> 00:08:19.080
所以我们将首先进行WS服务

00:08:16.319 --> 00:08:20.729
应用程序，让我们得到一些

00:08:19.080 --> 00:08:25.229
配置，所以我要一个网站

00:08:20.729 --> 00:08:27.719
套接字配置类和

00:08:25.229 --> 00:08:33.419
配置类定义了三件事

00:08:27.719 --> 00:08:36.659
首先要定义一个网络

00:08:33.419 --> 00:08:41.669
套接字处理程序和Web套接字处理程序

00:08:36.659 --> 00:08:47.420
是响应请求的组件

00:08:41.669 --> 00:08:47.420
所以我说返回Web套接字处理程序

00:08:48.370 --> 00:08:52.750
好的，我们当然会

00:08:51.340 --> 00:08:55.240
他们在这里的合同是

00:08:52.750 --> 00:08:59.850
返回数据最终不得不返回

00:08:55.240 --> 00:08:59.850
一个空的我们必须返回

00:09:00.150 --> 00:09:04.300
呼叫会话点的返回值

00:09:02.590 --> 00:09:07.180
发送或类似的权利单声道

00:09:04.300 --> 00:09:10.720
空可能会正确工作，所以

00:09:07.180 --> 00:09:11.910
让我们尝试返回此操作

00:09:10.720 --> 00:09:19.480
工作

00:09:11.910 --> 00:09:21.130
没有空的外观让我们看一下这款显示器

00:09:19.480 --> 00:09:22.630
与WebSocket处理程序期望

00:09:21.130 --> 00:09:34.290
单声道无效，所以我们可以返回

00:09:22.630 --> 00:09:34.290
单点d通量MD 

00:09:36.540 --> 00:09:41.010
是的，我们现在可以返回null 

00:09:39.959 --> 00:09:42.149
不管我们要做什么

00:09:41.010 --> 00:09:45.839
还是回到这个，让我们离开那个

00:09:42.149 --> 00:09:51.839
现在可以做，然后我们需要一个

00:09:45.839 --> 00:09:56.220
 WebSocket处理程序适配器进入网络

00:09:51.839 --> 00:09:58.230
插座和ER适配器非常好

00:09:56.220 --> 00:10:01.320
一个人很简单，然后我们

00:09:58.230 --> 00:10:08.310
需要一个有趣的处理程序映射，并且

00:10:01.320 --> 00:10:12.779
它们的映射等于处理程序映射， 

00:10:08.310 --> 00:10:15.769
处理程序映射是一个

00:10:12.779 --> 00:10:19.680
旨在告诉Spring Web运行时

00:10:15.769 --> 00:10:22.889
什么组件安装到

00:10:19.680 --> 00:10:26.490
哪个端点指向如此简单的网址， 

00:10:22.889 --> 00:10:28.769
他们的映射，重要的是我们需要

00:10:26.490 --> 00:10:30.510
你知道这有一定顺序

00:10:28.769 --> 00:10:32.970
我们只说十个

00:10:30.510 --> 00:10:35.399
这里的东西非零，我们需要

00:10:32.970 --> 00:10:37.230
然后给它一个URL的集合， 

00:10:35.399 --> 00:10:39.389
在这里，我们将使用地图，以便

00:10:37.230 --> 00:10:41.579
我们需要这些便捷的地图之一

00:10:39.389 --> 00:10:45.510
我要说的是Builder API的共同点

00:10:41.579 --> 00:10:48.209
入站WS文件应映射到

00:10:45.510 --> 00:10:50.010
 WS H是我们在那里的组成部分， 

00:10:48.209 --> 00:10:52.110
然后我们返回这个定义腿像

00:10:50.010 --> 00:10:54.510
好的，所以有我们的处理程序映射

00:10:52.110 --> 00:10:56.639
我们的网络套接字处理程序适配器，然后

00:10:54.510 --> 00:10:57.870
终于我们的网络套接字处理程序了

00:10:56.639 --> 00:11:00.779
我们在这里可以做的最简单的事情是

00:10:57.870 --> 00:11:02.819
只是为了使用会话返回数据

00:11:00.779 --> 00:11:05.310
方法，因此会话我们知道，如果我们

00:11:02.819 --> 00:11:07.290
已发送的会话发送并传递

00:11:05.310 --> 00:11:09.510
 WebSocket消息的发布者

00:11:07.290 --> 00:11:09.690
会满足合同，所以我们做

00:11:09.510 --> 00:11:17.959
那

00:11:09.690 --> 00:11:19.800
阀门发行商等于通量接触

00:11:17.959 --> 00:11:20.880
产生，我们将产生

00:11:19.800 --> 00:11:22.649
这里有一些数据，因为我要

00:11:20.880 --> 00:11:26.870
可以合作的东西，我们将产生

00:11:22.649 --> 00:11:26.870
一些数据使用

00:11:29.360 --> 00:11:42.450
同步

00:11:31.260 --> 00:11:43.740
类型文件事件接收器正常且

00:11:42.450 --> 00:11:45.780
当然我们没有那个类型文件

00:11:43.740 --> 00:11:48.480
事件，是从这里创建的

00:11:45.780 --> 00:11:50.850
目的是要匹配我们的结构

00:11:48.480 --> 00:11:52.290
客户不是我们需要它，而是

00:11:50.850 --> 00:11:56.720
就我们的目的而言很方便

00:11:52.290 --> 00:11:56.720
为了使该演示具有相似的对象

00:11:57.890 --> 00:12:01.650
好吧，我要使用数据类

00:12:00.030 --> 00:12:03.060
在科特林，这使得

00:12:01.650 --> 00:12:04.740
生成Gator setter以将所有字符串

00:12:03.060 --> 00:12:08.100
这种东西，所以我们现在可以使用

00:12:04.740 --> 00:12:09.750
那我们必须返回一些数据

00:12:08.100 --> 00:12:13.650
对，所以我们有一个盆，我们有一个水槽

00:12:09.750 --> 00:12:16.550
为我们创造的，我们的工作是

00:12:13.650 --> 00:12:18.960
返回水槽，然后放所有

00:12:16.550 --> 00:12:21.360
您知道将数据生成到该接收器中

00:12:18.960 --> 00:12:24.270
所以当我产生一个新的记录类型

00:12:21.360 --> 00:12:26.790
像这样的文件事件，我们只是

00:12:24.270 --> 00:12:31.410
要对数据进行硬编码，因此会话1 

00:12:26.790 --> 00:12:33.810
 2 3甚至更好，我们可以系统

00:12:31.410 --> 00:12:37.740
当前的时间磨工和路径

00:12:33.810 --> 00:12:42.780
会好起来的abc，所以在那里

00:12:37.740 --> 00:12:46.080
有我们的自定义生成器，我们可以

00:12:42.780 --> 00:12:51.150
返回我们可以说我们想要那个

00:12:46.080 --> 00:12:55.320
发布商然后映射其输出

00:12:51.150 --> 00:12:57.360
是将文件事件转换为字符串吗？ 

00:12:55.320 --> 00:12:59.400
因为我们需要一个字符串，所以让我们使用

00:12:57.360 --> 00:13:03.090
杰克逊对象映射器，所以我们将保存

00:12:59.400 --> 00:13:08.820
它是杰克逊对象映射器，我会说我

00:13:03.090 --> 00:13:11.910
想要将其映射到字符串，因为它是一个

00:13:08.820 --> 00:13:14.600
 Lambda中的隐式参数（如果您

00:13:11.910 --> 00:13:16.770
有一个明确的

00:13:14.600 --> 00:13:18.600
参数和lambda回调方法

00:13:16.770 --> 00:13:21.600
你知道功能接口

00:13:18.600 --> 00:13:23.430
 Kotlin为其赋予了隐式名称，或者

00:13:21.600 --> 00:13:25.530
你当然可以给它一个参数

00:13:23.430 --> 00:13:27.480
像这样的名字

00:13:25.530 --> 00:13:29.400
更长的作品，但这就是我在这里

00:13:27.480 --> 00:13:33.450
这样很好，然后我们需要映射

00:13:29.400 --> 00:13:36.660
像我们一样将其转换为短信

00:13:33.450 --> 00:13:39.930
在取得整数之前，我们可以

00:13:36.660 --> 00:13:41.660
把那个出版商放回去

00:13:39.930 --> 00:13:47.140
对，是的，我们是

00:13:41.660 --> 00:13:47.140
现在你有

00:14:34.030 --> 00:14:38.440
啊我忘了指定返回值

00:14:36.670 --> 00:14:42.430
很好，所以现在我们有一个返回值

00:14:38.440 --> 00:14:44.020
在那里，我们其他一切都应该工作

00:14:42.430 --> 00:14:47.620
正如我们期望的那样，所以现在

00:14:44.020 --> 00:14:50.560
这个基本的WebSocket处理程序没什么

00:14:47.620 --> 00:14:51.880
特别有趣的是你

00:14:50.560 --> 00:14:53.350
知道它演示了如何生成

00:14:51.880 --> 00:14:55.570
一些数据当然唯一的问题是

00:14:53.350 --> 00:14:57.880
是如果我们让它像您一样运行

00:14:55.570 --> 00:15:00.070
知道尖叫会和它一样快

00:14:57.880 --> 00:15:01.660
无法停止，我们的浏览器会

00:15:00.070 --> 00:15:04.240
很快就会进入内存，所以让我们

00:15:01.660 --> 00:15:06.010
让我们说一秒钟吧

00:15:04.240 --> 00:15:07.420
我们要插入人为的延迟

00:15:06.010 --> 00:15:09.580
但只是意味着我们可以做，因为

00:15:07.420 --> 00:15:12.160
我们在后台有一个调度程序

00:15:09.580 --> 00:15:14.200
这里是反应堆项目

00:15:12.160 --> 00:15:16.120
支撑春季的反应性支撑

00:15:14.200 --> 00:15:18.310
 5给了我们一个调度程序，让我们继续吧

00:15:16.120 --> 00:15:19.540
旋转这个应用程序，让我们

00:15:18.310 --> 00:15:21.400
下次我会忘记

00:15:19.540 --> 00:15:23.680
确保这个实例是这个

00:15:21.400 --> 00:15:26.160
应用程序只是一个实例，因此

00:15:23.680 --> 00:15:28.710
这样它将杀死那里的实例

00:15:26.160 --> 00:15:31.270
我们将在此处刷新浏览器，然后

00:15:28.710 --> 00:15:33.820
在那里，我们每一秒钟都得到一个新的

00:15:31.270 --> 00:15:37.090
结果现在我们可以在这里停止，但我想要

00:15:33.820 --> 00:15:38.320
将我们的Web套接字API连接到事物

00:15:37.090 --> 00:15:40.120
世界上正在发生的事情，所以

00:15:38.320 --> 00:15:42.210
再一次，我只是从那个借来的

00:15:40.120 --> 00:15:44.860
我们上次看到的例子

00:15:42.210 --> 00:15:48.010
我要采用的春季整合

00:15:44.860 --> 00:15:50.680
该API产生新消息

00:15:48.010 --> 00:15:54.580
每当有新的情况下给客户

00:15:50.680 --> 00:15:56.380
文件，我们将使用它作为

00:15:54.580 --> 00:15:58.600
使用Spring集成的机会

00:15:56.380 --> 00:16:01.660
对，这不是每个活动的API 

00:15:58.600 --> 00:16:04.000
但是它提供了事件驱动的排序

00:16:01.660 --> 00:16:06.250
然后可以插入的适配器

00:16:04.000 --> 00:16:09.010
反应性世界在这里，我们

00:16:06.250 --> 00:16:11.350
要做的是在

00:16:09.010 --> 00:16:16.260
我们希望新邮件能够包装

00:16:11.350 --> 00:16:22.170
阅读有趣的传入文件频道

00:16:16.260 --> 00:16:24.640
等于已发布的订阅频道，并且

00:16:22.170 --> 00:16:26.800
然后定义好重写此代码

00:16:24.640 --> 00:16:28.060
一点点利用

00:16:26.800 --> 00:16:29.860
该新频道，但现在我们要谈

00:16:28.060 --> 00:16:31.120
关于它如何进入该渠道的

00:16:29.860 --> 00:16:33.250
一秒钟后，我们将建立一个

00:16:31.120 --> 00:16:37.890
入站适配器文件入站适配器

00:16:33.250 --> 00:16:41.080
使用spring集成入站

00:16:37.890 --> 00:16:44.200
适配器和同等支持

00:16:41.080 --> 00:16:46.709
 Spring集成文件模块对我们

00:16:44.200 --> 00:16:49.920
可以做到，但是现在

00:16:46.709 --> 00:16:53.459
让我们集中精力运行这段代码，以便

00:16:49.920 --> 00:16:57.779
我们创建一个添加到的处理程序

00:16:53.459 --> 00:16:59.309
当我们创建新的通量时该通道

00:16:57.779 --> 00:17:01.139
对于给定的会话，我将创建一个

00:16:59.309 --> 00:17:03.809
给定会话的新发布者，因此

00:17:01.139 --> 00:17:06.000
让我们在这里重写一下这段代码

00:17:03.809 --> 00:17:07.500
要摆脱所有这一切，摆脱

00:17:06.000 --> 00:17:08.760
我们不会打电话给generate 

00:17:07.500 --> 00:17:10.500
我们不再合成数据

00:17:08.760 --> 00:17:13.949
根据我们要创造的消费者

00:17:10.500 --> 00:17:18.360
一个发布商，我们将为此

00:17:13.949 --> 00:17:20.370
有机会指定发生什么情况

00:17:18.360 --> 00:17:24.529
在这里，我们可以给她回电

00:17:20.370 --> 00:17:26.669
有机会指定要做什么，以及

00:17:24.529 --> 00:17:28.230
我们将发送该Pub将不会发送此邮件

00:17:26.669 --> 00:17:30.539
将数据发送到发布者

00:17:28.230 --> 00:17:32.640
就像之前一样，在这种情况下

00:17:30.539 --> 00:17:34.679
我们将做更多的工作

00:17:32.640 --> 00:17:39.330
但这将在其他地方完成

00:17:34.679 --> 00:17:44.070
对，所以我们要说我们想

00:17:39.330 --> 00:17:46.890
实际发送一个WebSocket消息好吗

00:17:44.070 --> 00:17:56.309
为了完成这项工作，我们要

00:17:46.890 --> 00:18:00.799
先说注册连接到

00:17:56.309 --> 00:18:04.260
客户，然后我们想

00:18:00.799 --> 00:18:05.549
正确连接到客户，所以我们有

00:18:04.260 --> 00:18:08.159
这一点我们需要做两件事

00:18:05.549 --> 00:18:13.100
代码，我认为做到这一点的最佳方法

00:18:08.159 --> 00:18:16.440
将保留会话ID的映射

00:18:13.100 --> 00:18:18.690
我们要附加的两个处理程序

00:18:16.440 --> 00:18:21.299
写入我们的频道

00:18:18.690 --> 00:18:23.580
每当有消息从这里到达

00:18:21.299 --> 00:18:25.200
特定于此特定的WebSocket 

00:18:23.580 --> 00:18:28.880
对，所以我要说你知道

00:18:25.200 --> 00:18:34.820
连接将等于

00:18:28.880 --> 00:18:36.960
字符串类型的并发哈希图，其字符串

00:18:34.820 --> 00:18:39.270
有效载荷是消息处理程序类型

00:18:36.960 --> 00:18:40.890
那是春天的消息

00:18:39.270 --> 00:18:42.870
处理程序组件正确，所以我们要

00:18:40.890 --> 00:18:44.789
创建一个自定义消息头类型

00:18:42.870 --> 00:18:49.850
然后将保留在该列表中

00:18:44.789 --> 00:18:52.230
所以我们要说课程转发

00:18:49.850 --> 00:18:55.320
消息处理程序

00:18:52.230 --> 00:18:56.940
这将覆盖它的

00:18:55.320 --> 00:19:01.730
将使用而不是WebSocket 

00:18:56.940 --> 00:19:06.809
会话，它将使用同步WebSocket 

00:19:01.730 --> 00:19:10.289
 WebSocket消息类型的流量同步和

00:19:06.809 --> 00:19:11.820
它会扩展消息头

00:19:10.289 --> 00:19:14.820
界面，所以我们必须

00:19:11.820 --> 00:19:16.679
履行我们可以做的合同

00:19:14.820 --> 00:19:19.049
很简单，所以我们去了

00:19:16.679 --> 00:19:22.169
所以我们在那里有我们的自定义类

00:19:19.049 --> 00:19:27.539
知道我们要存储会话ID，所以

00:19:22.169 --> 00:19:29.309
说一个ID等于该ID的会话，我们

00:19:27.539 --> 00:19:33.450
知道我们需要一个物体

00:19:29.309 --> 00:19:34.860
所以Val Oh M等于对象成员

00:19:33.450 --> 00:19:38.429
其实我们可以只用一个

00:19:34.860 --> 00:19:41.669
范围会很好，所以现在让我们

00:19:38.429 --> 00:19:43.289
写这段代码，我们要说的是

00:19:41.669 --> 00:19:45.000
当我们创建一个

00:19:43.289 --> 00:19:47.100
新的发布者，我们不会产生新的

00:19:45.000 --> 00:19:48.510
超越我们所做的一切的价值观

00:19:47.100 --> 00:19:50.940
这里基本上有一个构造函数

00:19:48.510 --> 00:19:54.090
工厂中的发布商的工厂方法

00:19:50.940 --> 00:19:55.799
在这种情况下，我们将产生一个新的

00:19:54.090 --> 00:19:58.110
通过产生一个

00:19:55.799 --> 00:20:00.690
通过调用相同的值将新值同步

00:19:58.110 --> 00:20:04.019
每当文件到达时的下一个时间

00:20:00.690 --> 00:20:06.090
入站通道，所以我们需要使用

00:20:04.019 --> 00:20:09.149
我们指向本次会议以及

00:20:06.090 --> 00:20:11.820
在此消息处理程序中同步以发布

00:20:09.149 --> 00:20:13.110
一条消息，以便您知道我们将要做

00:20:11.820 --> 00:20:18.000
一秒钟之后，我们要说

00:20:13.110 --> 00:20:21.090
您知道消息，我们将取消引用

00:20:18.000 --> 00:20:24.299
到有效载荷等于消息

00:20:21.090 --> 00:20:26.010
有效负载作为文件权利，因为我们知道

00:20:24.299 --> 00:20:29.730
这将是Java和IO成为Java IO 

00:20:26.010 --> 00:20:32.639
文件，所以我们将使用它，然后

00:20:29.730 --> 00:20:36.840
将得到我们有一个文件

00:20:32.639 --> 00:20:40.590
因此，Fe等于文件事件，而

00:20:36.840 --> 00:20:42.690
会话ID当然是会话

00:20:40.590 --> 00:20:44.990
我们之前记录的ID和

00:20:42.690 --> 00:20:44.990
路径

00:20:45.280 --> 00:21:02.980
我们将成为有效载荷绝对路径

00:20:57.280 --> 00:21:04.540
所以我们在那里，然后我们

00:21:02.980 --> 00:21:07.120
把它变成一串当然

00:21:04.540 --> 00:21:10.750
正如我们之前所做的，我们将说Val字符串

00:21:07.120 --> 00:21:14.680
等于om点右值作为字符串fe 

00:21:10.750 --> 00:21:18.550
然后我们将其转换为文本

00:21:14.680 --> 00:21:21.310
消息TM会话点文本消息

00:21:18.550 --> 00:21:23.530
传递这个字符串，然后最后

00:21:21.310 --> 00:21:26.080
我们将像以前一样使用同步发送

00:21:23.530 --> 00:21:28.780
在此之前，TM正确地传递了

00:21:26.080 --> 00:21:30.430
相同的处理代码，除了现在

00:21:28.780 --> 00:21:33.460
在春季末完成

00:21:30.430 --> 00:21:34.840
整合流程正确，这就是为什么

00:21:33.460 --> 00:21:38.080
是连接，我们要

00:21:34.840 --> 00:21:39.730
说，每当有新消息

00:21:38.080 --> 00:21:41.530
我们为新的

00:21:39.730 --> 00:21:43.540
会话以从

00:21:41.530 --> 00:21:46.660
客户，我们要创建一个

00:21:43.540 --> 00:21:48.310
将通过其键通过其ID映射它

00:21:46.660 --> 00:21:51.220
在这里，我们将使用转发

00:21:48.310 --> 00:21:56.020
会话中传递的消息处理程序

00:21:51.220 --> 00:21:58.380
和同步，然后一旦完成

00:21:56.020 --> 00:22:00.340
我们将要使用该频道

00:21:58.380 --> 00:22:03.040
对，我创造出我们要

00:22:00.340 --> 00:22:05.650
取消引用我们拥有的渠道

00:22:03.040 --> 00:22:07.800
在那里配置好了，所以我们说

00:22:05.650 --> 00:22:11.310
传入文件通道点订阅

00:22:07.800 --> 00:22:14.830
当然通过连接

00:22:11.310 --> 00:22:18.340
 ID密钥消息已通过的会话

00:22:14.830 --> 00:22:21.550
现在在另一边

00:22:18.340 --> 00:22:23.680
发布者不见了，我们需要清理

00:22:21.550 --> 00:22:27.880
我们也不想这样的连接

00:22:23.680 --> 00:22:29.470
许多连接和订户

00:22:27.880 --> 00:22:31.780
通道无缘无故会成为记忆

00:22:29.470 --> 00:22:34.780
否则泄漏，所以在这种情况下，我们要

00:22:31.780 --> 00:22:36.490
清理那些多余的资源

00:22:34.780 --> 00:22:38.380
当然，理想的时间是

00:22:36.490 --> 00:22:40.690
当他们的客户断开连接时，我们

00:22:38.380 --> 00:22:42.490
可以通过覆盖最终做到的事情来解决

00:22:40.690 --> 00:22:46.180
方法在这里，所以我要说

00:22:42.490 --> 00:22:49.080
传入文件通道退订， 

00:22:46.180 --> 00:22:52.240
我们将查找您知道的

00:22:49.080 --> 00:22:53.920
地图中的消息处理程序以及

00:22:52.240 --> 00:22:57.140
然后当然可以做到了

00:22:53.920 --> 00:22:59.690
说删除的连接

00:22:57.140 --> 00:23:02.270
您知道会话ID现在有问题

00:22:59.690 --> 00:23:03.680
我们可以在之后将其从地图上删除

00:23:02.270 --> 00:23:04.820
我们已经取消订阅了，我们想要

00:23:03.680 --> 00:23:07.220
确保没有机上

00:23:04.820 --> 00:23:11.480
交易第一，所以我们去了

00:23:07.220 --> 00:23:13.160
现在，我们已经写了一点

00:23:11.480 --> 00:23:15.560
代码，当然我只是在运行

00:23:13.160 --> 00:23:17.150
发布者在这里发送数据回去

00:23:15.560 --> 00:23:19.010
应该注意到，不知道

00:23:17.150 --> 00:23:21.350
提及您可以阅读它只是

00:23:19.010 --> 00:23:23.360
发布它是一个通量，所以它是一个

00:23:21.350 --> 00:23:25.460
传入WebSocket消息的发布者

00:23:23.360 --> 00:23:27.050
但那是你知道那是一个客户

00:23:25.460 --> 00:23:29.660
发起的交易我们不是很多

00:23:27.050 --> 00:23:32.210
对我们感兴趣，因为我们是服务器或

00:23:29.660 --> 00:23:35.030
服务启动交易权，所以

00:23:32.210 --> 00:23:37.610
这里我们去这是我们的基本安排

00:23:35.030 --> 00:23:39.910
我们有一个消息处理程序

00:23:37.610 --> 00:23:42.530
每次有新的时候都要创建

00:23:39.910 --> 00:23:44.840
 WebSocket请求或WebSocket会话

00:23:42.530 --> 00:23:46.960
在WebSocket会话启动时启动

00:23:44.840 --> 00:23:49.280
首先，我们创建了一个发布商

00:23:46.960 --> 00:23:51.680
将被定义为

00:23:49.280 --> 00:23:53.720
只要有，就会产生一个新值

00:23:51.680 --> 00:23:55.760
一个事件，然后当然是事件

00:23:53.720 --> 00:23:57.470
必须来自某个地方

00:23:55.760 --> 00:23:59.090
它会通过传入渠道

00:23:57.470 --> 00:24:01.550
但是我们仍然需要整合流程

00:23:59.090 --> 00:24:03.010
为了实现它，所以让我们联系起来

00:24:01.550 --> 00:24:10.990
现在也是，所以我们要说传入

00:24:03.010 --> 00:24:15.820
传入文件流集成流

00:24:10.990 --> 00:24:18.890
等于来自和的积分流类型

00:24:15.820 --> 00:24:21.920
我们将使用床适配器中的文件

00:24:18.890 --> 00:24:24.380
在这里我们需要提供一个文件

00:24:21.920 --> 00:24:26.390
指针，我实际上并不需要

00:24:24.380 --> 00:24:29.300
在这种情况下，我可以使用该值

00:24:26.390 --> 00:24:30.560
您知道的注释使用拼写或

00:24:29.300 --> 00:24:32.090
财产占位符解析或

00:24:30.560 --> 00:24:34.550
这样的东西，所以我要用

00:24:32.090 --> 00:24:36.890
家用台式机，但这当然是

00:24:34.550 --> 00:24:38.900
苏格兰和科特林拥有自己的财产

00:24:36.890 --> 00:24:41.030
它看起来像文本中的占位符分辨率

00:24:38.900 --> 00:24:42.620
与斯普林斯完全一样，所以我们有

00:24:41.030 --> 00:24:44.270
确保该语言不

00:24:42.620 --> 00:24:45.620
尝试解决这些变量或

00:24:44.270 --> 00:24:47.210
这些表达式，因为这不是

00:24:45.620 --> 00:24:48.650
你知道它不会在

00:24:47.210 --> 00:24:50.600
棉花语言中的Java 

00:24:48.650 --> 00:24:52.370
春天会在春天

00:24:50.600 --> 00:24:54.530
应用程序上下文中这些值

00:24:52.370 --> 00:24:56.540
居住，所以我们使用它逃脱它

00:24:54.530 --> 00:24:59.090
反斜杠在那里，所以我们说的是

00:24:56.540 --> 00:25:00.410
创建一个躺在床上的适配器

00:24:59.090 --> 00:25:02.240
目录在那里创建目录，如果

00:25:00.410 --> 00:25:04.730
它不存在，然后我们想

00:25:02.240 --> 00:25:06.890
创建一个极地，所以我要说创建一个

00:25:04.730 --> 00:25:09.190
具有以下类型的极坐标

00:25:06.890 --> 00:25:15.090
元数据直到pm点

00:25:09.190 --> 00:25:18.700
 pm点固定汇率，然后使用

00:25:15.090 --> 00:25:20.650
然后在消息到达时进行评分

00:25:18.700 --> 00:25:22.960
我们将在收到的邮件上发送它

00:25:20.650 --> 00:25:26.110
文件频道，然后我们将获得

00:25:22.960 --> 00:25:27.660
整个构建的流程，然后将其存储在那里

00:25:26.110 --> 00:25:33.490
所以我们去那里是我们的

00:25:27.660 --> 00:25:36.040
整合流程和我们的嵌入深度

00:25:33.490 --> 00:25:37.570
那里和极地将作出回应

00:25:36.040 --> 00:25:41.320
适配器发出的消息

00:25:37.570 --> 00:25:42.340
等等，这样就可以看一下

00:25:41.320 --> 00:25:44.500
当前方向看目录

00:25:42.340 --> 00:25:47.710
在这里指定，我们将其称为文件

00:25:44.500 --> 00:25:49.420
家用台式机在创建目录中是否

00:25:47.710 --> 00:25:51.340
它不存在，您应该扫描

00:25:49.420 --> 00:25:53.920
每隔一秒钟或每1000个目录

00:25:51.340 --> 00:25:55.480
任何新数据的毫秒数（如果有） 

00:25:53.920 --> 00:25:57.760
是否有任何新文件

00:25:55.480 --> 00:25:59.770
送春天之前没来

00:25:57.760 --> 00:26:01.390
传入文件上的框架消息

00:25:59.770 --> 00:26:03.550
渠道，然后另一件事

00:26:01.390 --> 00:26:07.410
最终我们会听得很好

00:26:03.550 --> 00:26:09.880
这里有一个创建新的设置

00:26:07.410 --> 00:26:12.040
订户在该频道上收听

00:26:09.880 --> 00:26:14.680
每当有新的Web套接字会话时

00:26:12.040 --> 00:26:16.720
所以基本上我们是在动态添加

00:26:14.680 --> 00:26:19.360
并根据

00:26:16.720 --> 00:26:23.700
 WebSocket的启动或终止

00:26:19.360 --> 00:26:23.700
会话，所以让我们重新启动

00:26:29.610 --> 00:26:38.820
现在我们去浏览器刷新，我们

00:26:34.830 --> 00:26:51.770
必须去命令行CD 

00:26:38.820 --> 00:27:01.710
触摸桌面1 2 3等，这是一个

00:26:51.770 --> 00:27:04.950
客户如果可以的话，再去碰4 

00:27:01.710 --> 00:27:08.130
在这里看到旧的浏览器和

00:27:04.950 --> 00:27:09.870
新的浏览器会看到新文件，但他们

00:27:08.130 --> 00:27:13.020
有不同的会议，所以我们

00:27:09.870 --> 00:27:14.040
现在有2位订阅者正在收听

00:27:13.020 --> 00:27:16.860
记录，您可以看到反映

00:27:14.040 --> 00:27:18.300
这里也说收到

00:27:16.860 --> 00:27:22.560
文件频道现在有2个订阅者

00:27:18.300 --> 00:27:25.740
让我们杀死这个隐身会话

00:27:22.560 --> 00:27:27.780
然后您会看到该传入文件

00:27:25.740 --> 00:27:30.000
频道现在有一个订阅者

00:27:27.780 --> 00:27:32.400
是的那个是那个

00:27:30.000 --> 00:27:33.930
仍然活跃，所以它会自我清洁， 

00:27:32.400 --> 00:27:36.600
好好照顾自己，所以我们在这里

00:27:33.930 --> 00:27:38.550
如何使用反应式API进行构建

00:27:36.600 --> 00:27:41.010
一个WebSocket应用程序，您将看到

00:27:38.550 --> 00:27:43.110
认知上是我仍然找到这个

00:27:41.010 --> 00:27:46.550
说实话，平易近人

00:27:43.110 --> 00:27:49.950
然后是Spring框架方法

00:27:46.550 --> 00:27:51.210
春天的方法框架

00:27:49.950 --> 00:27:53.250
在春季使用WebSockets 

00:27:51.210 --> 00:27:56.220
方法框架工作得很好

00:27:53.250 --> 00:27:57.630
它基于

00:27:56.220 --> 00:27:59.520
 Spring框架中的消息传递权利

00:27:57.630 --> 00:28:02.400
所以他们发送了消息传递模板和所有

00:27:59.520 --> 00:28:05.340
确实允许工作是

00:28:02.400 --> 00:28:07.170
是什么让我们提取了春天

00:28:05.340 --> 00:28:08.880
整合信息和春天

00:28:07.170 --> 00:28:10.530
弹簧整合型

00:28:08.880 --> 00:28:11.940
整合并在春季投入使用

00:28:10.530 --> 00:28:14.370
框架是它的基础

00:28:11.940 --> 00:28:16.830
运动，所以我为所有人感到高兴

00:28:14.370 --> 00:28:19.830
这项工作，但我觉得它很自然

00:28:16.830 --> 00:28:21.780
考虑一下你知道的最终事情

00:28:19.830 --> 00:28:25.350
可能或

00:28:21.780 --> 00:28:28.500
与发布者互动可能不会发生

00:28:25.350 --> 00:28:29.190
流发布者，所以您知道很多

00:28:28.500 --> 00:28:32.280
那里的好东西

00:28:29.190 --> 00:28:35.630
很好，非常感谢

00:28:32.280 --> 00:28:35.630
下次再见

00:28:43.570 --> 00:28:45.630
您

