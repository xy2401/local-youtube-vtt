WEBVTT
Kind: captions
Language: zh-Hans

00:00:25.820 --> 00:00:31.039
我 Spring 的歌迷欢迎来到另一个

00:00:29.210 --> 00:00:32.780
今天我们将介绍 spring 技巧 

00:00:31.039 --> 00:00:34.160
谈论Redis Redis已经成为

00:00:32.780 --> 00:00:35.960
足够作为一般用途

00:00:34.160 --> 00:00:38.270
每个人都是的电器

00:00:35.960 --> 00:00:40.520
在某个时候安装或使用的

00:00:38.270 --> 00:00:41.960
更容易获得

00:00:40.520 --> 00:00:43.280
因为使用起来很简单

00:00:41.960 --> 00:00:46.370
易于操作且易于安装

00:00:43.280 --> 00:00:47.750
但是因为一切顺利

00:00:46.370 --> 00:00:50.420
使其无法访问

00:00:47.750 --> 00:00:51.980
甚至支持某人

00:00:50.420 --> 00:00:54.410
可以使用memcache D使用它

00:00:51.980 --> 00:00:57.170
协议及其背后的公司Redis 

00:00:54.410 --> 00:00:59.660
实验室在做到这一点方面做得很出色

00:00:57.170 --> 00:01:01.250
尽可能容易食用， 

00:00:59.660 --> 00:01:03.289
不同目标平台的数量

00:01:01.250 --> 00:01:04.970
您实际上可以使用Redis为例

00:01:03.289 --> 00:01:07.430
在云内存中，他们拥有

00:01:04.970 --> 00:01:08.869
为使用提供了支持

00:01:07.430 --> 00:01:11.509
关键的云铸造厂或关键的网络

00:01:08.869 --> 00:01:15.920
服务托管多租户云

00:01:11.509 --> 00:01:17.060
平台Redis实验室也去了，我认为

00:01:15.920 --> 00:01:18.850
超越他们提供的一些

00:01:17.060 --> 00:01:20.869
使Redis真正有用的功能

00:01:18.850 --> 00:01:22.700
适口，例如股票

00:01:20.869 --> 00:01:24.770
 Redis开箱即用的开源

00:01:22.700 --> 00:01:27.229
 Redis具有很强的对应性

00:01:24.770 --> 00:01:28.910
现在有一台服务器一个数据库，所以我

00:01:27.229 --> 00:01:29.930
有多个数据库，那么它变成

00:01:28.910 --> 00:01:31.640
一点TD，所以您必须运行多个

00:01:29.930 --> 00:01:35.390
服务器，他们有一个产品，允许

00:01:31.640 --> 00:01:36.860
然后您可以管理所有正确的Dave 

00:01:35.390 --> 00:01:39.439
 Nielsen在他喜欢的Redis实验室工作

00:01:36.860 --> 00:01:43.040
开玩笑说这是很难的DBMS，对吧

00:01:39.439 --> 00:01:45.140
 Redis数据库管理系统

00:01:43.040 --> 00:01:47.119
与我的续集Oracle或发布方式相同

00:01:45.140 --> 00:01:47.840
卡是我们的DBMS，但就其而言

00:01:47.119 --> 00:01:49.579
当然，他们在谈论

00:01:47.840 --> 00:01:52.100
关系数据库管理系统

00:01:49.579 --> 00:01:55.070
现在我认为Redis是最普遍的

00:01:52.100 --> 00:01:59.329
用作键值存储，但

00:01:55.070 --> 00:02:02.479
我认为驳回或忽略了

00:01:59.329 --> 00:02:04.189
大量的功能

00:02:02.479 --> 00:02:05.570
 Redis提供的功能

00:02:04.189 --> 00:02:07.460
有很多很好的用例

00:02:05.570 --> 00:02:08.720
我认为Redis支持大多数

00:02:07.460 --> 00:02:10.790
我们只是理所当然，甚至不

00:02:08.720 --> 00:02:13.010
知道他们在那里，直到我们忽略了

00:02:10.790 --> 00:02:16.160
本期的目的是

00:02:13.010 --> 00:02:19.100
看看这巨大的只是瑞士的

00:02:16.160 --> 00:02:21.950
这把名副其实的瑞士军刀

00:02:19.100 --> 00:02:23.239
 Redis的功能

00:02:21.950 --> 00:02:24.860
了解如何使用它来构建应用程序并查看

00:02:23.239 --> 00:02:27.170
 Spring 的不同方面

00:02:24.860 --> 00:02:29.329
生态系统使其使用并与之合作

00:02:27.170 --> 00:02:32.750
非常简单，所以我们要建立一个

00:02:29.329 --> 00:02:34.010
从这里开始新的应用程序

00:02:32.750 --> 00:02:36.049
揭开面纱，我们将采取

00:02:34.010 --> 00:02:39.610
自动配置的管理员

00:02:36.049 --> 00:02:42.560
 Spring 的 Spring 引导和Redis 

00:02:39.610 --> 00:02:44.090
在这里建立应用程序

00:02:42.560 --> 00:02:47.870
叫这个Redis，所以我看不到Redis 

00:02:44.090 --> 00:02:50.240
像这样，我们使用数据Redis 

00:02:47.870 --> 00:02:51.590
支持好

00:02:50.240 --> 00:02:52.880
现在您注意到实际上有一个

00:02:51.590 --> 00:02:54.190
反应性变量我们可以使用

00:02:52.880 --> 00:02:58.030
以及，但我将只使用常规

00:02:54.190 --> 00:03:02.600
 Redis将使用我们将使用的Lombok 

00:02:58.030 --> 00:03:04.790
会话支持，我们将使用

00:03:02.600 --> 00:03:09.920
缓存抽象支持

00:03:04.790 --> 00:03:10.910
我们将使用网络支持

00:03:09.920 --> 00:03:14.120
我们有很多不同的地方

00:03:10.910 --> 00:03:16.130
在这里我们要在我们的应用程序中

00:03:14.120 --> 00:03:17.420
为了能够建立

00:03:16.130 --> 00:03:18.650
这个应用程序，我们将建立一个网站

00:03:17.420 --> 00:03:20.860
应用程序，所以我将使用时间叶作为

00:03:18.650 --> 00:03:23.570
好吧，只是很多不同

00:03:20.860 --> 00:03:24.470
我们可以使用您的功能

00:03:23.570 --> 00:03:26.270
知道构建一个非常简单的应用程序

00:03:24.470 --> 00:03:28.160
但我们会遇到很多不同

00:03:26.270 --> 00:03:29.780
很快就一点都不专注

00:03:28.160 --> 00:03:31.370
这是一件特别的事

00:03:29.780 --> 00:03:33.890
不客气的Redis的杂货店

00:03:31.370 --> 00:03:37.250
好吧，我要构建一个应用程序

00:03:33.890 --> 00:03:42.290
在这里ueo reddit zip在我的文件夹中打开它

00:03:37.250 --> 00:03:45.980
 IDE，然后我们要

00:03:42.290 --> 00:03:47.440
然后直接进入海岸

00:03:45.980 --> 00:03:49.700
对，所以我要构建一个应用程序

00:03:47.440 --> 00:03:51.860
为了能够将其部署到

00:03:49.700 --> 00:03:55.340
后来我们进入云资金商， 

00:03:51.860 --> 00:03:57.220
需要添加公共池依赖项

00:03:55.340 --> 00:04:01.370
所以我必须记得在这里做

00:03:57.220 --> 00:04:10.840
等待所有位下载全部

00:04:01.370 --> 00:04:14.630
右手掌，XML没问题，所以公共池

00:04:10.840 --> 00:04:20.239
太好了，我们在那里

00:04:14.630 --> 00:04:21.290
新的服务器半径应用程序，我们

00:04:20.239 --> 00:04:22.880
将构建到某些应用程序，所以我们将

00:04:21.290 --> 00:04:24.620
从我认为我们大多数人开始

00:04:22.880 --> 00:04:27.350
熟悉哪个是Redis 

00:04:24.620 --> 00:04:30.230
模板现在Spring Boot自动配置

00:04:27.350 --> 00:04:31.460
几个Redis在这里转换，让我们

00:04:30.230 --> 00:04:34.130
看见证人自动配置

00:04:31.460 --> 00:04:38.840
在这里，我们看到我们是两个

00:04:34.130 --> 00:04:40.820
两个不同Redis的配置

00:04:38.840 --> 00:04:42.470
客户端库现在另一个

00:04:40.820 --> 00:04:44.180
您可能会欣赏的是Redis 

00:04:42.470 --> 00:04:46.880
本身就是Spring 数据速率的支撑

00:04:44.180 --> 00:04:48.440
看Redis模板很旧

00:04:46.880 --> 00:04:50.630
这是第一个

00:04:48.440 --> 00:04:52.630
我们添加到spring数据的模块

00:04:50.630 --> 00:04:53.830
 neo4j之后

00:04:52.630 --> 00:04:55.990
从一开始我就认为

00:04:53.830 --> 00:04:58.600
这几乎已经到了

00:04:55.990 --> 00:05:01.389
八年后的2011年，所以

00:04:58.600 --> 00:05:02.260
很长时间以来，我们一直在提供这种支持

00:05:01.389 --> 00:05:04.360
 Spring 的数据，这是原始的之一

00:05:02.260 --> 00:05:06.250
模块，所以它经历了很多

00:05:04.360 --> 00:05:07.990
进化论，但从根本上讲

00:05:06.250 --> 00:05:09.460
核心总是有一些核心

00:05:07.990 --> 00:05:11.229
包括这个右派在内的概念

00:05:09.460 --> 00:05:12.790
这个右派模板

00:05:11.229 --> 00:05:15.130
与春季的其他模板非常相似

00:05:12.790 --> 00:05:17.620
框架生态系统是

00:05:15.130 --> 00:05:19.540
处理乏味的资源初始化

00:05:17.620 --> 00:05:21.490
以及收购和收购以及

00:05:19.540 --> 00:05:23.760
让我们只关注业务逻辑

00:05:21.490 --> 00:05:26.229
我们想要表达的东西

00:05:23.760 --> 00:05:29.860
发出查询并进行更新，以及

00:05:26.229 --> 00:05:32.020
等等很容易做到

00:05:29.860 --> 00:05:34.630
单线通常以及

00:05:32.020 --> 00:05:37.150
我们不想像你一样浪费时间

00:05:34.630 --> 00:05:38.740
知道建立连接和设置

00:05:37.150 --> 00:05:40.150
进行会议以及所有这些东西

00:05:38.740 --> 00:05:41.560
管理所有结果集和所有

00:05:40.150 --> 00:05:43.360
这些东西只是能够迭代

00:05:41.560 --> 00:05:46.030
他们所有的东西都由我们来管理

00:05:43.360 --> 00:05:48.520
此模板此模板已锁定

00:05:46.030 --> 00:05:49.930
它在密钥方面是通用的

00:05:48.520 --> 00:05:52.150
我们将要使用的类型，请记住

00:05:49.930 --> 00:05:54.669
从根本上说，Redis是关键值存储

00:05:52.150 --> 00:05:55.930
但价值观本身可以是全部

00:05:54.669 --> 00:05:58.930
您可以拥有的各种不同的东西

00:05:55.930 --> 00:06:01.630
其他词典或地图权利，或者他们

00:05:58.930 --> 00:06:04.539
将其称为哈希值，您可以拥有一个

00:06:01.630 --> 00:06:07.479
提示正确，因此您可以模拟发布/订阅

00:06:04.539 --> 00:06:10.289
发红，你可以做，你可以有地理

00:06:07.479 --> 00:06:12.639
空间索引作为您可以做的值

00:06:10.289 --> 00:06:14.169
原子序号和信号量

00:06:12.639 --> 00:06:16.000
作为价值的东西，所以有一个

00:06:14.169 --> 00:06:17.650
许多非常复杂的价值观

00:06:16.000 --> 00:06:19.450
你可以放在那里，但最终他们

00:06:17.650 --> 00:06:22.330
有一把钥匙，当然还有你的价值观

00:06:19.450 --> 00:06:26.110
可能是任意的，您知道斑点

00:06:22.330 --> 00:06:27.070
数据，这是第一件事

00:06:26.110 --> 00:06:30.220
我们在这里必须了解的是

00:06:27.070 --> 00:06:33.099
 Redis不在乎我们如何编码我们的

00:06:30.220 --> 00:06:34.599
数据可以只存在于Redis中

00:06:33.099 --> 00:06:37.060
例如一系列字节

00:06:34.599 --> 00:06:38.950
像JSON一样生活，您知道

00:06:37.060 --> 00:06:41.620
您希望由客户决定

00:06:38.950 --> 00:06:44.590
该数据库以指定何时

00:06:41.620 --> 00:06:45.669
您现在在此处创建模板

00:06:44.590 --> 00:06:48.280
我想指出的是

00:06:45.669 --> 00:06:49.900
两种不同的类配置

00:06:48.280 --> 00:06:52.389
对于两种不同类型的客户

00:06:49.900 --> 00:06:54.729
嫉妒和生菜都是三分之二

00:06:52.389 --> 00:06:57.070
方Java客户端，可用于

00:06:54.729 --> 00:06:57.639
与Redis交谈，我们都支持

00:06:57.070 --> 00:07:00.219
他们

00:06:57.639 --> 00:07:02.860
我们为双方提供连接工厂

00:07:00.219 --> 00:07:04.360
他们中的一个，所以在这里我们将创建一个

00:07:02.860 --> 00:07:05.650
依次注入的模板的速率

00:07:04.360 --> 00:07:07.030
 Redis连接工厂

00:07:05.650 --> 00:07:08.980
你知道的其中之一

00:07:07.030 --> 00:07:10.480
您知道这些实现中的

00:07:08.980 --> 00:07:11.830
我自动认为实际上有一个

00:07:10.480 --> 00:07:13.570
第三，但这不是自动的

00:07:11.830 --> 00:07:18.250
第三个的配置，所以我们

00:07:13.570 --> 00:07:20.440
我们支持我们可以配置我们的方式

00:07:18.250 --> 00:07:22.330
 see完全依赖数据，所以我们已经

00:07:20.440 --> 00:07:23.470
得到了这个自定义的raddest模板，让我们

00:07:22.330 --> 00:07:24.880
继续并创建我们自己的

00:07:23.470 --> 00:07:26.560
看看它是如何工作的以及如何

00:07:24.880 --> 00:07:28.090
可以看到这里我们有一个字符串

00:07:26.560 --> 00:07:30.010
 Redis模板此字符串Redis 

00:07:28.090 --> 00:07:32.380
模板只是一个Redis模板， 

00:07:30.010 --> 00:07:34.360
字符串类型right和的键和值

00:07:32.380 --> 00:07:36.670
您可以在这里看到他们已经

00:07:34.360 --> 00:07:38.800
指定了Eliezer的权限，所以这是一个

00:07:36.670 --> 00:07:41.770
一切都用字符串消毒器

00:07:38.800 --> 00:07:43.870
默认情况下，但是当将Redis与

00:07:41.770 --> 00:07:46.540
与基于JVM的应用程序一起使用

00:07:43.870 --> 00:07:49.120
您将获得Java IO序列化，因此

00:07:46.540 --> 00:07:50.860
默认配置为Java JDK 

00:07:49.120 --> 00:07:52.890
序列化可能会或可能不会

00:07:50.860 --> 00:07:57.190
如果完全在内部使用Redis的话

00:07:52.890 --> 00:07:59.350
同类Java的上下文

00:07:57.190 --> 00:08:01.360
基于或基于JVM的应用程序

00:07:59.350 --> 00:08:03.670
很好，但是如果您将Redis与

00:08:01.360 --> 00:08:05.050
多个客户和多种语言

00:08:03.670 --> 00:08:06.370
当然，你想

00:08:05.050 --> 00:08:09.040
远离它，你可以让我们

00:08:06.370 --> 00:08:15.990
让我们看一下让我们看一下

00:08:09.040 --> 00:08:19.830
在这里进行自定义配置

00:08:15.990 --> 00:08:21.910
我们将创建一个新的Redis模板， 

00:08:19.830 --> 00:08:24.070
我们的with模板将有

00:08:21.910 --> 00:08:26.260
序列化的自定义配置

00:08:24.070 --> 00:08:28.000
所以说我们只为

00:08:26.260 --> 00:08:29.440
现在作为一个例子，我们不会

00:08:28.000 --> 00:08:33.760
不会保留在这里，但让我们

00:08:29.440 --> 00:08:37.570
创建一个类型为cat的类，它将是

00:08:33.760 --> 00:08:38.740
弦猫可以告诉我我要

00:08:37.570 --> 00:08:41.950
有一个休息模板，可以让我工作

00:08:38.740 --> 00:08:43.630
与键，并在猫的名字和猫权利

00:08:41.950 --> 00:08:44.980
所以谁在乎这种类型的

00:08:43.630 --> 00:08:46.960
但是只要说我想要这个就足够了

00:08:44.980 --> 00:08:50.410
前提是现在我要有一个

00:08:46.960 --> 00:08:53.170
读取string和cat类型的模板

00:08:50.410 --> 00:08:55.390
好的，我现在需要配置

00:08:53.170 --> 00:08:57.670
值灭菌器关键灭菌器哈希

00:08:55.390 --> 00:08:59.560
卫星服务的关键服务和哈希袋

00:08:57.670 --> 00:09:02.100
所以实际上实际上只是

00:08:59.560 --> 00:09:05.920
在这种情况下，两个，这是一个Redis 

00:09:02.100 --> 00:09:07.810
新型的消毒器和

00:09:05.920 --> 00:09:10.500
在这种情况下，我只想使用磁盘

00:09:07.810 --> 00:09:15.940
通用Jackson到JSON消毒器

00:09:10.500 --> 00:09:17.210
序列化到，或者我什至可以说杰克逊

00:09:15.940 --> 00:09:22.430
我们去

00:09:17.210 --> 00:09:25.430
猫猫课，所以这是正确的价值

00:09:22.430 --> 00:09:26.690
我们要说的是价值，这可以是

00:09:25.430 --> 00:09:29.420
猫，如果我们喜欢它并不重要

00:09:26.690 --> 00:09:31.790
然后我们要为钥匙做一个

00:09:29.420 --> 00:09:36.940
我认为只要一个键就可以了

00:09:31.790 --> 00:09:43.340
西里尔是我们自己的Redis 

00:09:36.940 --> 00:09:44.810
字符串，看看我们得到了多少

00:09:43.340 --> 00:09:46.940
在这里我们想要不同的选择

00:09:44.810 --> 00:09:54.770
在消毒器上串一下

00:09:46.940 --> 00:09:56.810
输入字符串Redis序列化器，然后

00:09:54.770 --> 00:09:58.850
不需要看括号，我

00:09:56.810 --> 00:10:01.220
知道一般大小，没有参数

00:09:58.850 --> 00:10:02.660
在那里，我们将成为的价值观

00:10:01.220 --> 00:10:07.940
用这个编码，用那个编码

00:10:02.660 --> 00:10:13.210
所以钥匙西里尔激光钥匙模板点

00:10:07.940 --> 00:10:17.840
值消毒器值模板点

00:10:13.210 --> 00:10:22.610
散列值激光值模板点

00:10:17.840 --> 00:10:25.340
哈希键灭菌器键好吧

00:10:22.610 --> 00:10:27.500
我们现在已经知道哈希值和

00:10:25.340 --> 00:10:29.060
哈希键和常规键值

00:10:27.500 --> 00:10:30.860
我们将使用与您相同的名称

00:10:29.060 --> 00:10:32.390
说谎，所以这实际上是很好，我们

00:10:30.860 --> 00:10:33.320
可以保持原样，但就我们而言

00:10:32.390 --> 00:10:35.270
我们要表达一些

00:10:33.320 --> 00:10:36.830
不同的术语配置

00:10:35.270 --> 00:10:38.060
只是猫，我只想示范

00:10:36.830 --> 00:10:39.920
这将如何工作，当然我

00:10:38.060 --> 00:10:42.050
不需要，甚至不需要

00:10:39.920 --> 00:10:44.060
公开，以便有效地取代

00:10:42.050 --> 00:10:46.700
我们在其中的配置

00:10:44.060 --> 00:10:48.320
自动配置，如果我们想要的话

00:10:46.700 --> 00:10:50.120
我们的目标是离开的价格

00:10:48.320 --> 00:10:51.830
自动配置是我只想要你

00:10:50.120 --> 00:10:54.710
欣赏一些灵活性

00:10:51.830 --> 00:10:58.400
你在这里配置你知道

00:10:54.710 --> 00:11:01.360
 Redis及其连接现在有些

00:10:58.400 --> 00:11:04.760
自动配置使我们可以与

00:11:01.360 --> 00:11:05.630
有了一个正确的模板，我们可以使用

00:11:04.760 --> 00:11:07.610
模板，这样我们就可以创建

00:11:05.630 --> 00:11:09.140
一类应用程序编写器，但是

00:11:07.610 --> 00:11:10.880
我们将创建很多应用程序

00:11:09.140 --> 00:11:16.220
跑步者，我想知道你

00:11:10.880 --> 00:11:18.650
我有点想拥有一种

00:11:16.220 --> 00:11:20.390
触发每个应用程序的种类

00:11:18.650 --> 00:11:21.800
赢家，所以我们可以在

00:11:20.390 --> 00:11:23.510
我今天想要开发的输出

00:11:21.800 --> 00:11:26.960
在这里创造一件小东西

00:11:23.510 --> 00:11:28.550
应用程序运行程序，然后对其进行调整

00:11:26.960 --> 00:11:30.190
然后在它前面打印出标题

00:11:28.550 --> 00:11:32.620
运行我们的跑步者

00:11:30.190 --> 00:11:34.600
传递下去，我们将注入

00:11:32.620 --> 00:11:36.550
重用龙目岛做草坪护理

00:11:34.600 --> 00:11:39.550
没错，所以我会看到一个博客，然后

00:11:36.550 --> 00:11:43.750
说记录信息，然后标题将是

00:11:39.550 --> 00:11:45.759
大写，我们还好吧

00:11:43.750 --> 00:11:47.319
有我们的冠军选手，我们

00:11:45.759 --> 00:11:49.079
我们要用这个公平吗

00:11:47.319 --> 00:11:51.370
次数，让我们继续前进， 

00:11:49.079 --> 00:11:54.040
建立我们的第一个应用程序

00:11:51.370 --> 00:11:58.350
应用程序很好地使用此模板

00:11:54.040 --> 00:11:58.350
我们将触及一个

00:11:58.709 --> 00:12:03.519
被低估的特征是

00:12:01.180 --> 00:12:04.959
 Redis可以支持地理定位

00:12:03.519 --> 00:12:07.329
所以我们要说我想做

00:12:04.959 --> 00:12:08.829
地理在这里，我们要创建

00:12:07.329 --> 00:12:13.949
我们要创建一些地理区域

00:12:08.829 --> 00:12:17.939
冠军亚军地理，我将创建一个

00:12:13.949 --> 00:12:21.189
这里的lambda args好吧

00:12:17.939 --> 00:12:24.149
现在这个冠军亚军

00:12:21.189 --> 00:12:26.470
使用以下命令将数据写入数据库

00:12:24.149 --> 00:12:27.399
这个模板最直

00:12:26.470 --> 00:12:30.459
我们在这里得到的模板

00:12:27.399 --> 00:12:32.350
所以renas模板的类型为string和

00:12:30.459 --> 00:12:34.480
字符串对我们来说很好，我们使用

00:12:32.350 --> 00:12:37.810
字符串作家模板没有t点

00:12:34.480 --> 00:12:38.680
我们将获得地理信息系统的机会

00:12:37.810 --> 00:12:40.540
这将给我们地理

00:12:38.680 --> 00:12:41.889
操作而不是哈希操作

00:12:40.540 --> 00:12:45.160
不是我们可以用来管理的

00:12:41.889 --> 00:12:47.639
分布式列表或值，或者您知道

00:12:45.160 --> 00:12:50.350
任何成本或原语，而是

00:12:47.639 --> 00:12:53.490
我要取消的地理操作

00:12:50.350 --> 00:12:56.769
存储在这里的变量中

00:12:53.490 --> 00:12:58.839
我们将使用地理位置或此处的地理位置来

00:12:56.769 --> 00:13:01.930
将一些记录记录到数据库中

00:12:58.839 --> 00:13:05.199
所以我要说添加，当我添加一个

00:13:01.930 --> 00:13:06.339
记录在一个城市和意大利附近，这是

00:13:05.199 --> 00:13:09.130
实际上是从域名借来的

00:13:06.339 --> 00:13:11.589
在Spring 数据里面

00:13:09.130 --> 00:13:13.360
 Spring 的数据示例项目，所以如果

00:13:11.589 --> 00:13:16.300
您在春季访问github.com- 

00:13:13.360 --> 00:13:17.860
春季项目-数据-示例

00:13:16.300 --> 00:13:19.779
您会发现许多不同的地方

00:13:17.860 --> 00:13:22.959
选项在这里好，所以我们要使用

00:13:19.779 --> 00:13:24.759
点的类型或极端形式

00:13:22.959 --> 00:13:26.259
数据Adagio，这实际上是一种类型

00:13:24.759 --> 00:13:28.750
在Spring数据框架中， 

00:13:26.259 --> 00:13:30.850
在这里，我要繁琐地复制和粘贴

00:13:28.750 --> 00:13:36.399
或更确切地说，我只是要大声打字

00:13:30.850 --> 00:13:42.810
所以三六一三八九好

00:13:36.399 --> 00:13:48.590
三8.11五五五

00:13:42.810 --> 00:13:53.250
六个好，那将是我们的好

00:13:48.590 --> 00:13:55.590
将一分二加到

00:13:53.250 --> 00:13:58.470
地理位置，所以它是一个索引

00:13:55.590 --> 00:14:01.380
在那个钥匙周围或附近

00:13:58.470 --> 00:14:02.940
与那个城市的钥匙相关联

00:14:01.380 --> 00:14:04.410
所以这里的参数如果你想

00:14:02.940 --> 00:14:06.810
你看这说我们要加

00:14:04.410 --> 00:14:08.480
关键点，然后是名字

00:14:06.810 --> 00:14:10.760
会员权利

00:14:08.480 --> 00:14:21.230
我要再做三遍

00:14:10.760 --> 00:14:31.520
第二次指向一个508 

00:14:21.230 --> 00:14:35.990
七二六九三7.5哦二六

00:14:31.520 --> 00:14:41.970
六点九分，这个地方将被称为

00:14:35.990 --> 00:14:44.840
猫计时你，这是第二个

00:14:41.970 --> 00:14:50.190
例如第三个例子

00:14:44.840 --> 00:14:53.070
 3.58，那是我认为正确的三分法

00:14:50.190 --> 00:15:02.130
这样就可以了，那是三个

00:14:53.070 --> 00:15:04.620
七三一7.3一六六六七

00:15:02.130 --> 00:15:06.330
好的，七个，所以我认为是对的

00:15:04.620 --> 00:15:08.820
走，让我在这里再次确认一下

00:15:06.330 --> 00:15:10.860
回顾这些数字一三三

00:15:08.820 --> 00:15:15.440
六一三八九一三三

00:15:10.860 --> 00:15:18.900
六一三八九好

00:15:15.440 --> 00:15:21.930
三八一一然后五五

00:15:18.900 --> 00:15:24.840
五六所以三八一一五

00:15:21.930 --> 00:15:29.940
五五和那六个好第二盘

00:15:24.840 --> 00:15:34.830
是一508七二六九一508 

00:15:29.940 --> 00:15:38.400
 72-69好三七五哦二六

00:15:34.830 --> 00:15:43.050
六九三七五哦二六六

00:15:38.400 --> 00:15:44.820
九大下一盘是一三五

00:15:43.050 --> 00:15:48.480
八三三三三

00:15:44.820 --> 00:15:51.810
这样看起来正确37.3一六六

00:15:48.480 --> 00:15:55.530
七个三7.31 667好，所以我们有

00:15:51.810 --> 00:15:56.460
现在正确的数据，我们要

00:15:55.530 --> 00:15:57.720
用它来

00:15:56.460 --> 00:16:01.080
创建一个圆圈，我要画一个

00:15:57.720 --> 00:16:03.330
圈出这些点之一，然后

00:16:01.080 --> 00:16:10.020
看看那个圆圈内的东西，所以我

00:16:03.330 --> 00:16:18.300
要说新圈子新观点好吧， 

00:16:10.020 --> 00:16:25.770
我们将使用一三五八三

00:16:18.300 --> 00:16:30.900
三三三七三一六

00:16:25.770 --> 00:16:36.150
六七所以一五五八三

00:16:30.900 --> 00:16:39.660
三三三七三一六

00:16:36.150 --> 00:16:41.490
六六七好，我们要告诉

00:16:39.660 --> 00:16:44.250
它指定您的距离

00:16:41.490 --> 00:16:49.380
用100知道这一点

00:16:44.250 --> 00:16:51.930
公里，因此Redis地理位置命令点了一个

00:16:49.380 --> 00:16:53.910
另一个点距离单位

00:16:51.930 --> 00:16:56.160
公里非常好，所以这是我们的

00:16:53.910 --> 00:16:57.810
圈子，现在我们将使用Redis 

00:16:56.160 --> 00:17:00.090
问它在那点上

00:16:57.810 --> 00:17:03.540
圈，所以我们可以说地理结果是

00:17:00.090 --> 00:17:11.220
实际上只能说这些数据或RT否

00:17:03.540 --> 00:17:12.930
抱歉，地理圆点半径，我们

00:17:11.220 --> 00:17:15.199
会问它所有的东西

00:17:12.930 --> 00:17:18.000
半径，我们要在该键内说

00:17:15.199 --> 00:17:20.910
然后给它一个圆点

00:17:18.000 --> 00:17:23.970
在这里，这将为我们提供

00:17:20.910 --> 00:17:27.540
一切顺利，现在我们可以

00:17:23.970 --> 00:17:32.180
在此处访问这些地理位置结果中的每一个

00:17:27.540 --> 00:17:37.860
让我们看看它会被定位

00:17:32.180 --> 00:17:41.130
是的，结果是要访问我们

00:17:37.860 --> 00:17:46.350
将访问每个G的每个结果点

00:17:41.130 --> 00:17:47.940
我们的日志信息串好，这样

00:17:46.350 --> 00:17:49.170
嗯，我们可以获得内容

00:17:47.940 --> 00:17:51.390
我想实际上可能甚至

00:17:49.170 --> 00:17:56.720
这更容易使地理结果认为

00:17:51.390 --> 00:18:01.380
获取每个点的内容点，所以请参阅

00:17:56.720 --> 00:18:02.190
日志信息将其查看为字符串，让我们来看一下

00:18:01.380 --> 00:18:04.730
是什么让我们运行这个

00:18:02.190 --> 00:18:04.730
程序看看

00:18:19.040 --> 00:18:25.040
好的，所以其中两个要点

00:18:21.650 --> 00:18:28.550
在该区域内的巴勒莫和东方

00:18:25.040 --> 00:18:29.810
有时候我很温柔

00:18:28.550 --> 00:18:32.530
对非常好，所以您知道

00:18:29.810 --> 00:18:35.720
简单的例子，但它可以工作，你知道

00:18:32.530 --> 00:18:37.070
显然你不会希望

00:18:35.720 --> 00:18:37.910
这个很难有这个硬编码

00:18:37.070 --> 00:18:39.830
将是您可以加载的内容

00:18:37.910 --> 00:18:41.300
从GIS数据库或类似的东西

00:18:39.830 --> 00:18:42.440
但是这里有很多可能性

00:18:41.300 --> 00:18:45.860
对，你可以做一些非常非常的事情

00:18:42.440 --> 00:18:47.990
在这里可以非常快速地处理地理信息

00:18:45.860 --> 00:18:50.180
支持您了解常见的地理空间种类

00:18:47.990 --> 00:18:52.010
您可能想要的查询

00:18:50.180 --> 00:18:53.810
现在支持一个应用程序

00:18:52.010 --> 00:18:57.380
常见用例，这是很常见的用法

00:18:53.810 --> 00:18:59.000
案例是要利用地理来工作

00:18:57.380 --> 00:18:59.900
作为地理空间数据，这只是其中之一

00:18:59.000 --> 00:19:01.760
这些只是众多事物之一

00:18:59.900 --> 00:19:04.250
 Redis做的很好

00:19:01.760 --> 00:19:05.900
您可以使用GIS后发布或

00:19:04.250 --> 00:19:08.000
 post cos世界或MongoDB或

00:19:05.900 --> 00:19:09.320
 Couchbase他们都具有地理空间暴击

00:19:08.000 --> 00:19:10.370
支持，如果你已经有

00:19:09.320 --> 00:19:12.110
 Redis你也可以使用它

00:19:10.370 --> 00:19:13.250
对，所以这是其中之一

00:19:12.110 --> 00:19:18.650
你可以做到的事情

00:19:13.250 --> 00:19:19.820
盒子好了，现在让我们谈一个

00:19:18.650 --> 00:19:21.380
该模板的其他内容

00:19:19.820 --> 00:19:24.920
支持，我们看到了最红的

00:19:21.380 --> 00:19:31.310
模板支持是T点散列

00:19:24.920 --> 00:19:33.200
因此，哈希和哈希运算的哈希运算

00:19:31.310 --> 00:19:34.940
你做一个哈希运算，这让

00:19:33.200 --> 00:19:38.180
您要做的是创建关联的地图

00:19:34.940 --> 00:19:39.500
用一个很棒的钥匙，所以你有

00:19:38.180 --> 00:19:42.610
基本存储记录的能力

00:19:39.500 --> 00:19:44.330
您可以存储整个记录

00:19:42.610 --> 00:19:45.500
与您可能会说出的钥匙相关联

00:19:44.330 --> 00:19:46.910
这就是你所知道的全部名字

00:19:45.500 --> 00:19:51.080
和姓氏，他们通过ID发送电子邮件

00:19:46.910 --> 00:19:52.880
为此用户名或其他任何方式

00:19:51.080 --> 00:19:55.070
只需按ID查找即可， 

00:19:52.880 --> 00:19:57.320
用于存储记录的自然事物

00:19:55.070 --> 00:19:59.210
实际上，我们可以支持存储库

00:19:57.320 --> 00:20:01.040
所以另一个概念

00:19:59.210 --> 00:20:03.080
 spring data 项目就是这个概念

00:20:01.040 --> 00:20:05.720
现在是一个存储库

00:20:03.080 --> 00:20:07.040
数据只是

00:20:05.720 --> 00:20:09.290
中心方法的配置

00:20:07.040 --> 00:20:12.320
根据名称建立查询

00:20:09.290 --> 00:20:13.100
接口和Spring 数据中的方法

00:20:12.320 --> 00:20:16.250
有很多不同

00:20:13.100 --> 00:20:18.200
具有不同功能的实现

00:20:16.250 --> 00:20:20.210
项目，这些都是这些

00:20:18.200 --> 00:20:21.560
尽我们最大的努力去支持

00:20:20.210 --> 00:20:23.650
我们不是要提供错觉

00:20:21.560 --> 00:20:26.030
某些事情可能

00:20:23.650 --> 00:20:27.470
不支持它的东西，但我们可以

00:20:26.030 --> 00:20:29.930
实际上是基本的风格

00:20:27.470 --> 00:20:31.200
仓库与Redis一起工作，所以我们开始吧

00:20:29.930 --> 00:20:34.559
让我们创建一个

00:20:31.200 --> 00:20:37.919
一个简单的类型在这里称为订单和

00:20:34.559 --> 00:20:40.260
这将是可序列化的，我们

00:20:37.919 --> 00:20:44.700
想要订单支持ID，因此我们将

00:20:40.260 --> 00:20:46.769
用 Spring 说私人长号

00:20:44.700 --> 00:20:48.510
框架数据让我们降低ID 

00:20:46.769 --> 00:20:54.720
在那里输入索引

00:20:48.510 --> 00:20:57.539
日期权索引私有日期

00:20:54.720 --> 00:21:04.470
正确的告诉你直到日期，我们会

00:20:57.539 --> 00:21:04.830
对所有订单项列表的引用

00:21:04.470 --> 00:21:09.090
对

00:21:04.830 --> 00:21:10.940
因此，现在找到非常好的订单项

00:21:09.090 --> 00:21:15.659
这种类型的课程，我们当然需要这种类型

00:21:10.940 --> 00:21:17.279
类订单项实现可序列化

00:21:15.659 --> 00:21:19.799
我们将回到那种类型

00:21:17.279 --> 00:21:23.070
可以，但现在我们知道这种类型

00:21:19.799 --> 00:21:24.539
我们的类型会支持它吗

00:21:23.070 --> 00:21:27.510
将使用以下方式保留在数据库中

00:21:24.539 --> 00:21:28.830
我们知道Redis哈希功能

00:21:27.510 --> 00:21:31.320
我们需要吸气剂和吸气剂，所以我

00:21:28.830 --> 00:21:33.539
要说数据和所有弧线

00:21:31.320 --> 00:21:35.070
构造函数，没有岩石构造函数

00:21:33.539 --> 00:21:37.409
实际上不需要纽瓦克的

00:21:35.070 --> 00:21:39.929
 Spring数据的构造函数不是

00:21:37.409 --> 00:21:41.519
像jpoa，您需要它，但我想要一个

00:21:39.929 --> 00:21:43.529
没有参数构造函数，因为

00:21:41.519 --> 00:21:45.960
这些都可能方便

00:21:43.529 --> 00:21:47.070
是可选的，但这就是好的程序

00:21:45.960 --> 00:21:49.529
实践说如果你想有一个

00:21:47.070 --> 00:21:50.760
有效的有效Li构造对象您

00:21:49.529 --> 00:21:53.669
应该学习如何能够构建

00:21:50.760 --> 00:21:55.019
通过构造函数，所以也许我

00:21:53.669 --> 00:21:57.830
不需要知道我们的构造函数

00:21:55.019 --> 00:22:00.450
现在就离开吧，好吧，我有一个

00:21:57.830 --> 00:22:04.019
年龄不完全不是我想要的

00:22:00.450 --> 00:22:06.630
那里的订单，订单将有行

00:22:04.019 --> 00:22:13.950
项目和订单项将位于

00:22:06.630 --> 00:22:17.269
索引所有私人长期订单ID 

00:22:13.950 --> 00:22:21.179
正确，并将在id处有一个ID 

00:22:17.269 --> 00:22:25.529
私人长ID，就是私人

00:22:21.179 --> 00:22:30.240
字符串描述，现在我们要

00:22:25.529 --> 00:22:35.610
要保留的项目以及九个项目

00:22:30.240 --> 00:22:37.649
它会拥有所有相同的东西

00:22:35.610 --> 00:22:39.510
和以前一样，我们需要创建

00:22:37.649 --> 00:22:41.669
现在，当我们生成存储库

00:22:39.510 --> 00:22:43.110
说索引索引意味着您知道

00:22:41.669 --> 00:22:44.399
它会创建一个密钥，它将成为

00:22:43.110 --> 00:22:44.880
我能够去抬头

00:22:44.399 --> 00:22:48.360
这个记录

00:22:44.880 --> 00:22:50.190
根据这个值，我保持正确的态度

00:22:48.360 --> 00:22:52.320
如果您要创建一个自定义的

00:22:50.190 --> 00:22:54.960
创建一个我可以使用的额外插槽

00:22:52.320 --> 00:22:57.570
以此快速引用此类型

00:22:54.960 --> 00:22:59.700
的价值，我不必担心

00:22:57.570 --> 00:23:01.740
太多了，但是当

00:22:59.700 --> 00:23:03.690
使用Redis这些类型的Redis哈希

00:23:01.740 --> 00:23:06.450
并已索引到特定于

00:23:03.690 --> 00:23:08.430
 spring数据Redis支持ID 

00:23:06.450 --> 00:23:10.740
注解是spring数据的通用属性

00:23:08.430 --> 00:23:13.260
 Orem抽象的机制

00:23:10.740 --> 00:23:14.940
支持这个，但是你知道我们出去了

00:23:13.260 --> 00:23:16.800
她为Redis做这项工作的方式

00:23:14.940 --> 00:23:18.210
这是非常有价值的

00:23:16.800 --> 00:23:20.490
使我们能够对复杂模型进行建模

00:23:18.210 --> 00:23:22.800
事情，并且仍然高效地这样做

00:23:20.490 --> 00:23:24.600
方式，但是那表示我们不承诺

00:23:22.800 --> 00:23:27.390
你知道我们可以做某些事情

00:23:24.600 --> 00:23:28.980
只是对某事不合理

00:23:27.390 --> 00:23:32.010
像不支持的视网膜

00:23:28.980 --> 00:23:34.020
也许是临时查询支持

00:23:32.010 --> 00:23:35.570
您可能期望使用我的

00:23:34.020 --> 00:23:38.610
续集或类似的东西，所以

00:23:35.570 --> 00:23:41.550
订单项必须管理其订单项

00:23:38.610 --> 00:23:44.400
 long类型和接口的主键

00:23:41.550 --> 00:23:49.830
订单存储库将要扩展

00:23:44.400 --> 00:23:52.470
负载类型为

00:23:49.830 --> 00:23:55.320
订单和ID好吗

00:23:52.470 --> 00:23:56.630
所以现在可能有两种类型

00:23:55.320 --> 00:24:02.250
在这里有一个自定义查找器方法

00:23:56.630 --> 00:24:06.710
假设我想收集你

00:24:02.250 --> 00:24:12.930
知道，假设我想找到订单

00:24:06.710 --> 00:24:14.400
在其日期之前罚款，在适当的时候日期D 

00:24:12.930 --> 00:24:18.540
我可以做到这一点实际上

00:24:14.400 --> 00:24:20.760
与我们的Redis一起很好

00:24:18.540 --> 00:24:21.810
这里说抽象，我们想

00:24:20.760 --> 00:24:23.910
创建一些数据，我们必须创建一个

00:24:21.810 --> 00:24:27.720
支持此功能的应用程序运行程序

00:24:23.910 --> 00:24:33.470
如此红的数据是如此的存储库， 

00:24:27.720 --> 00:24:38.250
什么叫亚军

00:24:33.470 --> 00:24:41.610
存储库args，我们将继续

00:24:38.250 --> 00:24:42.960
运行它，我们要去的仓库

00:24:41.610 --> 00:24:43.950
向我们写入一些数据到数据库

00:24:42.960 --> 00:24:45.120
我们将会有几张唱片

00:24:43.950 --> 00:24:48.660
首先要看清楚，所以我需要

00:24:45.120 --> 00:24:51.720
创建订单ID，以便订单ID长

00:24:48.660 --> 00:24:53.400
我需要生成一个ID 

00:24:51.720 --> 00:24:55.410
都在这里很方便

00:24:53.400 --> 00:24:56.900
因为我今天要做很多

00:24:55.410 --> 00:25:03.280
所以我们会说

00:24:56.900 --> 00:25:05.990
长温度等于下一个新的随机点

00:25:03.280 --> 00:25:10.100
很长，可能是负面的，所以我

00:25:05.990 --> 00:25:13.910
会说数学点最高温度或最高温度

00:25:10.100 --> 00:25:18.470
负数倍，我将退还

00:25:13.910 --> 00:25:19.430
所以有我们生成的ID和我

00:25:18.470 --> 00:25:20.570
想做的就是我要创建一些

00:25:19.430 --> 00:25:24.110
不同的订单项，我将保存

00:25:20.570 --> 00:25:31.250
首先，数组点作为列表新行

00:25:24.110 --> 00:25:34.190
物料订单ID生成ID，我们

00:25:31.250 --> 00:25:38.470
例如将其称为柱塞

00:25:34.190 --> 00:25:42.730
一个新的订单项将是订单ID 

00:25:38.470 --> 00:25:50.120
生成ID，汤和新订单项

00:25:42.730 --> 00:25:52.430
将是订单ID生成ID，您

00:25:50.120 --> 00:25:54.490
知道什么是好咖啡

00:25:52.430 --> 00:25:56.810
好吧，现在我们有了这些类型

00:25:54.490 --> 00:25:58.130
得到了这些记录，我将保存到

00:25:56.810 --> 00:26:00.380
因此，我们需要实际

00:25:58.130 --> 00:26:05.980
拜访每个人，然后保存它们，所以我

00:26:00.380 --> 00:26:08.900
要说项目列表点流点图

00:26:05.980 --> 00:26:11.900
和订单项存储库中的通行证

00:26:08.900 --> 00:26:15.560
所以我们在这里做这样的订单项

00:26:11.900 --> 00:26:21.160
存储库，在这里我将说存储库

00:26:15.560 --> 00:26:23.450
点保存它，它当然是

00:26:21.160 --> 00:26:26.270
通用那里用一种方法代替它

00:26:23.450 --> 00:26:27.440
参考，如果我们想要，那么我们需要

00:26:26.270 --> 00:26:29.330
订阅，所以我们需要实际

00:26:27.440 --> 00:26:33.410
访问返回的每条记录， 

00:26:29.330 --> 00:26:35.360
我们将针对每个LI系统说

00:26:33.410 --> 00:26:35.860
猜猜我们可以直接使用日志否

00:26:35.360 --> 00:26:40.070
问题

00:26:35.860 --> 00:26:41.290
李，所以我排队很不错

00:26:40.070 --> 00:26:47.180
看看我们现在有了这些

00:26:41.290 --> 00:26:48.290
不同的记录，应该工作

00:26:47.180 --> 00:26:50.530
让我们继续运行此命令，看看有什么

00:26:48.290 --> 00:26:50.530
我们得到

00:26:58.520 --> 00:27:03.180
好的，那是那三个记录

00:27:01.350 --> 00:27:09.290
保存完之后，让我们

00:27:03.180 --> 00:27:11.670
创建订单等于新订单

00:27:09.290 --> 00:27:14.910
在这里，订单ID将通过

00:27:11.670 --> 00:27:16.950
间接地，新日期将是这个日期

00:27:14.910 --> 00:27:18.510
就在这里，埃琳娜，物品清单

00:27:16.950 --> 00:27:20.760
就是这个，现在我们要保存这个

00:27:18.510 --> 00:27:25.410
我们也要说注入

00:27:20.760 --> 00:27:29.210
订单存储库，因此订单存储库和

00:27:25.410 --> 00:27:33.060
我想我可以将其重命名为订单项

00:27:29.210 --> 00:27:36.950
仓库，我会说订单仓库

00:27:33.060 --> 00:27:38.940
点保存命令，这将给我们一个

00:27:36.950 --> 00:27:41.100
结果已保存在数据库中

00:27:38.940 --> 00:27:44.730
然后我们可以检查它，我们可以说

00:27:41.100 --> 00:27:47.970
订单库点查找时间

00:27:44.730 --> 00:27:50.640
订单点获得胜利，所以这应该返回

00:27:47.970 --> 00:27:54.630
如果一切按计划进行，务虚会

00:27:50.640 --> 00:27:57.390
知道找到了，你知道它将

00:27:54.630 --> 00:27:58.920
返回我想的集合，或者我们

00:27:57.390 --> 00:28:01.710
如果我们想甚至不能做一个可选的

00:27:58.920 --> 00:28:02.970
我们本可以说T find的可选

00:28:01.710 --> 00:28:05.460
如果我们知道只有一个

00:28:02.970 --> 00:28:09.090
或零，所以我们走了，所以我们得到了

00:28:05.460 --> 00:28:12.750
现在，让我们访问这些记录

00:28:09.090 --> 00:28:16.950
因此，我们将说每个日志都找到了

00:28:12.750 --> 00:28:18.720
点信息找到字符串好所以

00:28:16.950 --> 00:28:21.300
我正在访问返回的数据

00:28:18.720 --> 00:28:22.470
我查询完数据库后

00:28:21.300 --> 00:28:26.010
将其写入数据库后， 

00:28:22.470 --> 00:28:28.500
我要跑那我们去，所以他

00:28:26.010 --> 00:28:30.150
把它写到数据库中，我们发现它

00:28:28.500 --> 00:28:32.580
这个记录回来了，我们当然得到了

00:28:30.150 --> 00:28:34.200
对其中订单项的引用

00:28:32.580 --> 00:28:37.410
对，所以描述是柱塞

00:28:34.200 --> 00:28:38.640
汤和咖啡杯

00:28:37.410 --> 00:28:39.960
它只是为我们自动完成的

00:28:38.640 --> 00:28:42.720
现在，如果我们看看发生了什么

00:28:39.960 --> 00:28:44.790
如果你现在在这里幕后

00:28:42.720 --> 00:28:46.950
可以看到它实际上是一个整体

00:28:44.790 --> 00:28:48.240
用于管理所有这些的模式

00:28:46.950 --> 00:28:50.340
我是对的，只是为我管理

00:28:48.240 --> 00:28:52.140
不必担心，它是

00:28:50.340 --> 00:28:54.810
有索引，有关系

00:28:52.140 --> 00:28:56.820
当等时所有这些按键命令

00:28:54.810 --> 00:29:00.030
就像为我们所做的一样，所以我们不

00:28:56.820 --> 00:29:01.679
不必担心你知道这一切

00:29:00.030 --> 00:29:03.179
一种复杂的东西摆脱是

00:29:01.679 --> 00:29:04.060
很高兴做到这一点

00:29:03.179 --> 00:29:05.890
有一点

00:29:04.060 --> 00:29:07.480
此处需要手动组装以及

00:29:05.890 --> 00:29:08.710
 Spring数据抽象可以做到这一点

00:29:07.480 --> 00:29:12.490
为我们，以便我们现在可以得到最好的

00:29:08.710 --> 00:29:13.750
在这里使用Redis可以，所以

00:29:12.490 --> 00:29:15.580
这是一个非常简单的例子

00:29:13.750 --> 00:29:16.540
一个我们正在使用我们在后面使用哈希

00:29:15.580 --> 00:29:17.950
对的场景这实际上是

00:29:16.540 --> 00:29:20.950
从根本上变成

00:29:17.950 --> 00:29:23.110
散列和与以及键和值是

00:29:20.950 --> 00:29:23.920
使用Redis的基本原子，但是

00:29:23.110 --> 00:29:27.100
它做的事情非常复杂

00:29:23.920 --> 00:29:29.830
最重要的是，我们可以专注于

00:29:27.100 --> 00:29:31.120
高阶业务逻辑问题

00:29:29.830 --> 00:29:32.800
接下来我们要关注的是

00:29:31.120 --> 00:29:36.100
当我们看着和我们的小游览

00:29:32.800 --> 00:29:38.710
的威尼斯是用它来

00:29:36.100 --> 00:29:40.900
发布/订阅权这是很常见的

00:29:38.710 --> 00:29:42.000
我想发布的用例

00:29:40.900 --> 00:29:44.740
从一个音符传达到另一个音符

00:29:42.000 --> 00:29:47.040
在我使用某种中间件的地方

00:29:44.740 --> 00:29:49.120
当然可以安装Apache Kafka或

00:29:47.040 --> 00:29:50.860
 RabbitMQ，这些都是增长， 

00:29:49.120 --> 00:29:52.720
两者都是不错的选择，甚至是JMS 

00:29:50.860 --> 00:29:54.790
经纪人，尽管有原因

00:29:52.720 --> 00:29:56.890
您可能要避免最后一个

00:29:54.790 --> 00:30:02.770
但是Redis实际上你知道这很好

00:29:56.890 --> 00:30:05.350
是不是不是不是不是最多

00:30:02.770 --> 00:30:06.400
功能完整的消息代理

00:30:05.350 --> 00:30:07.900
业务，但如果您已经掌握了

00:30:06.400 --> 00:30:09.730
已安装，而您尝试做的简单

00:30:07.900 --> 00:30:11.440
 pub / sub，那么这可能就是您所需要的

00:30:09.730 --> 00:30:13.000
特别是如果您只是在做一个状态

00:30:11.440 --> 00:30:15.160
更新或者就可以了

00:30:13.000 --> 00:30:16.480
如果在这里失去信息

00:30:15.160 --> 00:30:18.970
您正在尝试进行金融交易

00:30:16.480 --> 00:30:20.350
那好吧，大概

00:30:18.970 --> 00:30:23.170
最好使用Rabbitmq或

00:30:20.350 --> 00:30:24.610
卡夫卡没错，但我们要走了

00:30:23.170 --> 00:30:26.560
好吧，我们会知道的

00:30:24.610 --> 00:30:28.270
我们有聊天权，我们是其中之一

00:30:26.560 --> 00:30:29.560
我们的状态通知，或者您知道

00:30:28.270 --> 00:30:31.360
总统的意识或类似的东西

00:30:29.560 --> 00:30:32.920
这是一个完美的选择

00:30:31.360 --> 00:30:35.020
因为它会在记忆中

00:30:32.920 --> 00:30:37.270
会闪电般飞速前进，客户

00:30:35.020 --> 00:30:38.740
将能够让您知道发布

00:30:37.270 --> 00:30:42.910
消息实际上是一个主题

00:30:38.740 --> 00:30:45.550
只是一把钥匙，而我们却排在后面

00:30:42.910 --> 00:30:46.960
场景，然后它们可以消耗

00:30:45.550 --> 00:30:49.930
所以我们实际上有它的支持

00:30:46.960 --> 00:30:57.190
春季也是如此，让我们来创建

00:30:49.930 --> 00:30:58.570
是一个发送消息的应用程序

00:30:57.190 --> 00:31:00.580
所以在这里我要创建一个

00:30:58.570 --> 00:31:05.700
应用程序编写者是一个应用程序

00:31:00.580 --> 00:31:12.870
跑步者发布者/订阅者，我们将返回一个

00:31:05.700 --> 00:31:12.870
标题为pubscribe subscribe 

00:31:12.889 --> 00:31:22.499
好吧，抄写到那里去

00:31:17.279 --> 00:31:25.139
 args，我们将使用它

00:31:22.499 --> 00:31:28.679
发布/订阅端点使用此

00:31:25.139 --> 00:31:29.879
跑步者现在要发送一条消息，那就是

00:31:28.679 --> 00:31:32.009
那是容易的部分

00:31:29.879 --> 00:31:34.409
我的意思是生产者和消费者

00:31:32.009 --> 00:31:36.089
真的很容易，但我要使用

00:31:34.409 --> 00:31:37.259
在这里休息模板，所以写在

00:31:36.089 --> 00:31:40.559
字符串类型的右派模板和

00:31:37.259 --> 00:31:43.289
字符串RT，我们要说RT点

00:31:40.559 --> 00:31:45.659
转换并发送，我们将创建

00:31:43.289 --> 00:31:50.099
此处的频道共享频道主题

00:31:45.659 --> 00:31:53.039
所以我猜私有的最终字符串主题

00:31:50.099 --> 00:31:54.599
无论谁在乎聊天好吧，我

00:31:53.039 --> 00:32:01.259
要说我要发信息

00:31:54.599 --> 00:32:03.929
这个话题，所以我们可以选择

00:32:01.259 --> 00:32:05.339
只是你知道那里好，并且消息

00:32:03.929 --> 00:32:08.459
我要发送的是任意的

00:32:05.339 --> 00:32:12.389
这里的消息可能是您知道的

00:32:08.459 --> 00:32:13.950
可能是json编码，可能是

00:32:12.389 --> 00:32:15.659
字符串它可以是您想要的任何东西

00:32:13.950 --> 00:32:16.829
但是我们依赖默认字符串

00:32:15.659 --> 00:32:21.869
在这里消毒，我要

00:32:16.829 --> 00:32:26.159
在即时点发送字符串你好世界

00:32:21.869 --> 00:32:29.579
现在点到字符串好了，所以我要发送

00:32:26.159 --> 00:32:31.349
时间编码的消息，现在我需要

00:32:29.579 --> 00:32:32.579
消耗掉那条消息现在我可以吐了

00:32:31.349 --> 00:32:34.709
另一个音符，这将非常容易

00:32:32.579 --> 00:32:36.119
但是既然我们已经了解了

00:32:34.709 --> 00:32:37.769
会工作，我想救自己

00:32:36.119 --> 00:32:40.469
一些打字时间，我要继续

00:32:37.769 --> 00:32:43.529
在此处创建消息侦听器使用者

00:32:40.469 --> 00:32:45.749
在相同的音符中，所以我

00:32:43.529 --> 00:32:47.309
我正在向Redis发送消息

00:32:45.749 --> 00:32:48.809
它会马上被送回来

00:32:47.309 --> 00:32:50.579
到同一个节点

00:32:48.809 --> 00:32:52.469
客户，所以实际上是

00:32:50.579 --> 00:32:55.409
与其说的话一样的网络跳数

00:32:52.469 --> 00:32:56.909
你知道不是真的要付出

00:32:55.409 --> 00:32:58.709
给定的项目，但我只想

00:32:56.909 --> 00:33:01.559
演示这是如何工作的，这样

00:32:58.709 --> 00:33:04.649
现在创建一个消息监听器

00:33:01.559 --> 00:33:06.149
这将响应消息， 

00:33:04.649 --> 00:33:08.129
然后在 Spring ，我们有了这个

00:33:06.149 --> 00:33:11.190
消息侦听器容器的概念

00:33:08.129 --> 00:33:12.809
对，所以消息侦听器容器

00:33:11.190 --> 00:33:17.249
我要用剩下的Redis 

00:33:12.809 --> 00:33:19.429
消息监听器容器和这个

00:33:17.249 --> 00:33:21.119
 reddit reddit消息监听器容器

00:33:19.429 --> 00:33:22.739
需要一个证人

00:33:21.119 --> 00:33:24.419
它需要一个消息监听器，所以让我们

00:33:22.739 --> 00:33:25.290
创建Redis消息，这是我们的

00:33:24.419 --> 00:33:33.420
容器

00:33:25.290 --> 00:33:35.160
像这样，MLC需要连接

00:33:33.420 --> 00:33:39.690
工厂当然可以注入

00:33:35.160 --> 00:33:44.730
 Redis连接工厂很好，我

00:33:39.690 --> 00:33:46.530
会说CF，我们会说m LLC点

00:33:44.730 --> 00:33:48.300
需要我们不需要消息监听器

00:33:46.530 --> 00:33:51.330
好吧，所以我们也需要这样做

00:33:48.300 --> 00:33:52.620
消息侦听器将是ml 

00:33:51.330 --> 00:33:54.420
我们将在稍后再讨论

00:33:52.620 --> 00:33:56.910
那么我们需要一个模式主题

00:33:54.420 --> 00:33:59.580
要告诉它使用这个点主题

00:33:56.910 --> 00:34:01.320
和以前一样就这样

00:33:59.580 --> 00:34:03.600
那是MLC本身，但我们需要

00:34:01.320 --> 00:34:06.060
消息监听器，让我们做到这一点

00:34:03.600 --> 00:34:07.470
容易一点，所以毫升等于新的

00:34:06.060 --> 00:34:10.409
消息不是很简单

00:34:07.470 --> 00:34:13.560
界面，在这里我们将采取

00:34:10.409 --> 00:34:15.300
来自痛苦的木头的数据，只是记录

00:34:13.560 --> 00:34:18.620
只是确认它是

00:34:15.300 --> 00:34:20.850
正如我们期望的那样

00:34:18.620 --> 00:34:22.679
枚举值好吧，让我们

00:34:20.850 --> 00:34:25.880
让我们在这里做，我们要说

00:34:22.679 --> 00:34:30.030
字符串字符串等于新字符串

00:34:25.880 --> 00:34:33.000
消息点获取正文

00:34:30.030 --> 00:34:36.360
这些是进来的字节，我们想要

00:34:33.000 --> 00:34:42.450
登出很长时间，以至于没有新信息

00:34:36.360 --> 00:34:46.520
消息或来自OK的消息，它将是

00:34:42.450 --> 00:34:46.520
这个点主题或主题

00:34:48.240 --> 00:34:55.030
好的STR非常酷，现在我们可以使用它了

00:34:52.840 --> 00:34:58.000
留言者可以吗

00:34:55.030 --> 00:34:59.350
好用lambda代替它，所以他们

00:34:58.000 --> 00:35:01.720
回想一下，我们去了，所以有我们的太太。 

00:34:59.350 --> 00:35:07.090
位置容器和我们的进货

00:35:01.720 --> 00:35:08.590
消息，我们现在可以读取数据

00:35:07.090 --> 00:35:09.910
让我们让我们看看会发生什么

00:35:08.590 --> 00:35:11.140
让我们继续运行，现在继续

00:35:09.910 --> 00:35:13.810
请注意，此消息将是

00:35:11.140 --> 00:35:16.480
带外异步接收

00:35:13.810 --> 00:35:19.780
所以我们将看到标题

00:35:16.480 --> 00:35:21.760
发布/订阅并打印

00:35:19.780 --> 00:35:25.390
也许可以说

00:35:21.760 --> 00:35:32.050
发布/订阅在哪里打印

00:35:25.390 --> 00:35:38.910
结果发现我做了什么

00:35:32.050 --> 00:35:38.910
错误的消息侦听器容器

00:35:42.880 --> 00:35:45.880
留言者

00:35:54.300 --> 00:35:57.170
信息

00:36:11.740 --> 00:36:18.790
他们打开容器，我回来了

00:36:15.119 --> 00:36:20.320
没有看到它在做，我看到它在做

00:36:18.790 --> 00:36:23.310
这不是我，所以他们发表了

00:36:20.320 --> 00:36:28.359
有一个发布/订阅点

00:36:23.310 --> 00:36:33.369
然后我做错了

00:36:28.359 --> 00:36:35.700
转换并发送给主题你好

00:36:33.369 --> 00:36:35.700
世界

00:36:42.609 --> 00:36:50.559
是的，看起来不错，不是吗

00:36:47.900 --> 00:36:50.559
是吗

00:36:52.220 --> 00:36:56.710
我明显缺少明显的东西

00:37:25.760 --> 00:37:28.760
发布/订阅

00:37:33.490 --> 00:37:45.490
和主题

00:37:38.630 --> 00:37:47.780
假设该信息称为聊天记录

00:37:45.490 --> 00:37:52.150
我们这次可以再试一次吗

00:37:47.780 --> 00:37:52.150
调试器让我们看看我们得到了什么

00:38:01.570 --> 00:38:06.610
这不是我的工作方式

00:38:05.260 --> 00:38:10.030
期待它，所以让我看看这是一个

00:38:06.610 --> 00:38:14.910
在容器中传送此消息文艺复兴

00:38:10.030 --> 00:38:14.910
是啊

00:38:43.730 --> 00:38:48.020
我有一些 bean 的名字

00:38:46.910 --> 00:38:50.390
没有 bean ，其他光束发生冲突

00:38:48.020 --> 00:38:52.160
输入，所以我将其重命名为监听器，然后

00:38:50.390 --> 00:38:53.930
收到来自您好聊天世界的消息等等

00:38:52.160 --> 00:38:56.060
等等等等好，这样才能真正起作用

00:38:53.930 --> 00:38:57.140
那是一个我是一个神秘的人，所以

00:38:56.060 --> 00:38:58.520
他们要走了，我想我们刚刚学会了

00:38:57.140 --> 00:39:00.410
新的东西不要使用名称和

00:38:58.520 --> 00:39:02.450
我刚刚曾经给你起名字

00:39:00.410 --> 00:39:05.030
容器，但是一旦执行一次

00:39:02.450 --> 00:39:06.619
您已经更改了它，它将起作用

00:39:05.030 --> 00:39:08.869
所以在这里，我们有一个消息， 

00:39:06.619 --> 00:39:10.820
没有响应的容器

00:39:08.869 --> 00:39:12.320
收到传入的消息，它可以

00:39:10.820 --> 00:39:13.369
用它做点什么，所以现在你可以做

00:39:12.320 --> 00:39:16.010
这里有各种各样有趣的事情

00:39:13.369 --> 00:39:18.740
可以根据您的了解创建主题

00:39:16.010 --> 00:39:19.850
好吧，这是这里的话题

00:39:18.740 --> 00:39:22.040
您可以创建某种主题

00:39:19.850 --> 00:39:23.840
有一个唯一的密钥，只有一个生产者

00:39:22.040 --> 00:39:24.980
消费者会同意您可以做到的

00:39:23.840 --> 00:39:27.290
广播他们，你可以做各种各样的

00:39:24.980 --> 00:39:29.840
您在这里基本了解的事情

00:39:27.290 --> 00:39:31.760
消息传递原语正确，所以到目前为止

00:39:29.840 --> 00:39:33.290
另一件事只是

00:39:31.760 --> 00:39:35.600
开箱即用的支持

00:39:33.290 --> 00:39:38.270
 Redis鲜为人知的功能

00:39:35.600 --> 00:39:40.550
希望您能利用我们的权利

00:39:38.270 --> 00:39:42.380
还支持将Redis用于密钥和

00:39:40.550 --> 00:39:43.430
自然地重视价值，并且有很多

00:39:42.380 --> 00:39:46.130
您想在不同的地方

00:39:43.430 --> 00:39:47.660
做到这一点，包括缓存，这样

00:39:46.130 --> 00:39:49.910
当您缓存数据时，让我移动它

00:39:47.660 --> 00:39:51.770
代码到代码页顶部

00:39:49.910 --> 00:39:54.050
我们在那里，我们要做的是

00:39:51.770 --> 00:39:55.430
想缓存我们知道的数据

00:39:54.050 --> 00:39:57.859
我们创造的也许

00:39:55.430 --> 00:40:00.140
到达很昂贵，所以可以说

00:39:57.859 --> 00:40:05.480
启用此处右上方的缓存，然后

00:40:00.140 --> 00:40:08.930
如此强大的缓存能力，在我们的构建中，您

00:40:05.480 --> 00:40:15.530
会看到我们在构建中

00:40:08.930 --> 00:40:21.170
我们有spring数据Redis依赖

00:40:15.530 --> 00:40:23.780
并且该依赖项具有一个缓存

00:40:21.170 --> 00:40:25.430
经理抽象，所以它会工作

00:40:23.780 --> 00:40:27.440
与at enable结合使用

00:40:25.430 --> 00:40:28.760
缓存注释，如果我们要这样做

00:40:27.440 --> 00:40:32.690
它的工作将需要一个缓存

00:40:28.760 --> 00:40:34.220
经理实施，我们可以

00:40:32.690 --> 00:40:36.410
相当容易地配置，让我们做

00:40:34.220 --> 00:40:41.060
在这里我们会说那个 bean 我想我们

00:40:36.410 --> 00:40:46.820
可以在这里在bean缓存中做到这一点

00:40:41.060 --> 00:40:48.980
经理Redis缓存，您知道还可以， 

00:40:46.820 --> 00:40:51.950
这将创建缓存管理器， 

00:40:48.980 --> 00:40:54.490
我们要说返回新的我们要

00:40:51.950 --> 00:40:57.230
使用其余的高速缓存管理器构建器

00:40:54.490 --> 00:41:01.310
方法在这里-缓存管理器

00:40:57.230 --> 00:41:05.690
点，我要注入的建设者

00:41:01.310 --> 00:41:09.800
见证连接工厂会说

00:41:05.690 --> 00:41:11.330
生成器点CF可以正常构建

00:41:09.800 --> 00:41:13.550
有我们的Redis缓存管理器

00:41:11.330 --> 00:41:15.190
抽象实现，现在我们

00:41:13.550 --> 00:41:18.740
可以创建有状态的东西

00:41:15.190 --> 00:41:20.780
保护潜在的表演者

00:41:18.740 --> 00:41:23.360
和昂贵，我们希望能够

00:41:20.780 --> 00:41:25.220
记住或记住结果

00:41:23.360 --> 00:41:26.570
方法调用，所以我不会做不

00:41:25.220 --> 00:41:28.160
这里的目标不是做一个整体

00:41:26.570 --> 00:41:29.150
缓存管理器简介

00:41:28.160 --> 00:41:31.070
抽象虽然你应该

00:41:29.150 --> 00:41:32.540
绝对会研究它，但是我

00:41:31.070 --> 00:41:33.980
想创建你知道我想

00:41:32.540 --> 00:41:36.350
演示这是如何无缝进行的

00:41:33.980 --> 00:41:39.140
与Redis合作，所以我要创建一个订单

00:41:36.350 --> 00:41:41.060
服务，让我们说好吧，所以订购

00:41:39.140 --> 00:41:41.920
服务，此订单服务正在进行

00:41:41.060 --> 00:41:44.810
成为

00:41:41.920 --> 00:41:46.370
可兑现的，所以我要支持缓存

00:41:44.810 --> 00:41:49.700
从此方法返回的结果

00:41:46.370 --> 00:41:52.030
因此，通过ID查找公共秩序ID 

00:41:49.700 --> 00:41:55.400
这里我要说的是添加可缓存的

00:41:52.030 --> 00:41:58.760
我们要说的很好，您知道订购者

00:41:55.400 --> 00:42:00.890
 ID，以便从中查找记录

00:41:58.760 --> 00:42:03.260
这种方法会占用那里

00:42:00.890 --> 00:42:07.280
查找并查找查找和Redis 

00:42:03.260 --> 00:42:07.850
任何来自此的数据

00:42:07.280 --> 00:42:11.030
我再试一次

00:42:07.850 --> 00:42:12.440
当您调用此方法时，它将看到

00:42:11.030 --> 00:42:14.180
首先，如果有结果

00:42:12.440 --> 00:42:16.370
已经存储在记录中

00:42:14.180 --> 00:42:18.200
具有此键和另一个的数据库

00:42:16.370 --> 00:42:20.390
你知道的钥匙组合

00:42:18.200 --> 00:42:22.160
根据此处的名称以及

00:42:20.390 --> 00:42:23.360
定位方法的参数和

00:42:22.160 --> 00:42:26.660
有争论

00:42:23.360 --> 00:42:30.410
您可以用来清洁卫生

00:42:26.660 --> 00:42:32.090
控制您知道哪个键应该

00:42:30.410 --> 00:42:34.070
使用哪个

00:42:32.090 --> 00:42:36.140
调用应用于逐出数据

00:42:34.070 --> 00:42:37.550
从缓存中

00:42:36.140 --> 00:42:39.350
让我们假设我们想要每一个

00:42:37.550 --> 00:42:41.630
在那里争论有助于关键

00:42:39.350 --> 00:42:44.260
然后用来返回这个

00:42:41.630 --> 00:42:48.650
解决的结果，所以现在让我们说返回

00:42:44.260 --> 00:42:51.280
新订单传递ID和新订单

00:42:48.650 --> 00:42:53.900
日间调整或只是空列表

00:42:51.280 --> 00:42:56.150
订单项现在我们要做的是

00:42:53.900 --> 00:42:58.370
是我们要创造一个人造的

00:42:56.150 --> 00:43:02.090
睡觉，所以需要一秒钟来解决

00:42:58.370 --> 00:43:04.610
如果有人想打电话给第二

00:43:02.090 --> 00:43:08.480
却没有

00:43:04.610 --> 00:43:09.590
缓存，然后让我们

00:43:08.480 --> 00:43:10.240
十秒钟，实际上

00:43:09.590 --> 00:43:12.580
可察觉的

00:43:10.240 --> 00:43:14.760
好吧，然后否则，呃

00:43:12.580 --> 00:43:18.570
直接思考我们

00:43:14.760 --> 00:43:25.810
杨梅现金还可以，所以在日志中说

00:43:18.570 --> 00:43:30.520
我们会说好错误信息

00:43:25.810 --> 00:43:34.869
猜测异常实际上甚至没有

00:43:30.520 --> 00:43:37.480
只是要做新的事情

00:43:34.869 --> 00:43:38.830
时间例外没事吧

00:43:37.480 --> 00:43:40.420
甚至在乎这个都不需要

00:43:38.830 --> 00:43:42.130
日志，因此我们正在创建工件

00:43:40.420 --> 00:43:46.869
只是将结果返回到关心

00:43:42.130 --> 00:43:49.119
结果，但我们想诱导

00:43:46.869 --> 00:43:51.670
人工睡眠以确保

00:43:49.119 --> 00:43:54.010
我们可以看到它进行的速度有多快

00:43:51.670 --> 00:43:58.000
让我们从

00:43:54.010 --> 00:44:00.160
跑步者的资料库，并证明

00:43:58.000 --> 00:44:01.930
它正在工作，所以有了新的一束光芒

00:44:00.160 --> 00:44:05.710
该特定的应用程序运行程序

00:44:01.930 --> 00:44:10.240
缓存，我们将使用此订单服务

00:44:05.710 --> 00:44:13.450
为我们创建的订单

00:44:10.240 --> 00:44:15.130
我将其保存为订单服务订单吗

00:44:13.450 --> 00:44:20.580
服务我做得不好

00:44:15.130 --> 00:44:25.270
今天的单词，所以订购服务和标题

00:44:20.580 --> 00:44:27.190
缓存好东西，所以有这个

00:44:25.270 --> 00:44:30.790
在订单服务中，我们将

00:44:27.190 --> 00:44:32.050
调用该方法，所以我们将这样做

00:44:30.790 --> 00:44:34.390
不同的时间数，所以我是

00:44:32.050 --> 00:44:35.290
我要做的是测量每个

00:44:34.390 --> 00:44:38.590
调用

00:44:35.290 --> 00:44:39.430
所以我们会说可运行的

00:44:38.590 --> 00:44:43.270
要做到这一点，最简单的方法是

00:44:39.430 --> 00:44:50.160
为此，我们可以创建一种保存方法

00:44:43.270 --> 00:44:50.160
让我们看课

00:44:52.489 --> 00:44:58.589
是的

00:44:53.730 --> 00:45:04.259
私人长措施，我们要

00:44:58.589 --> 00:45:05.130
采取一个可运行的是，我们将保存

00:45:04.259 --> 00:45:08.579
当前时间

00:45:05.130 --> 00:45:12.150
所以开始等于系统当前时间Milly 

00:45:08.579 --> 00:45:14.670
多头止损等于当前系统

00:45:12.150 --> 00:45:18.739
迷你时间，我们将运行我们的数据

00:45:14.670 --> 00:45:18.739
运行并

00:45:25.549 --> 00:45:33.549
那私人好吗？ 

00:45:29.179 --> 00:45:37.130
我们要转身返回停止-开始

00:45:33.549 --> 00:45:38.839
这就是那里的测量方法

00:45:37.130 --> 00:45:43.599
我们要测量一些亚军

00:45:38.839 --> 00:45:45.849
可以衡量的是

00:45:43.599 --> 00:45:51.109
就是这样，我要说

00:45:45.849 --> 00:45:55.609
可以通过ID 1l运行订单服务点

00:45:51.109 --> 00:46:00.130
所以现在我要打印出

00:45:55.609 --> 00:46:07.869
这样的时机，让我们说我们有

00:46:00.130 --> 00:46:13.939
首先记录该信息，我们将打印出

00:46:07.869 --> 00:46:18.799
可以，所以两次，两次，三次

00:46:13.939 --> 00:46:21.140
次，所以我们现在有三个

00:46:18.799 --> 00:46:23.529
相同基本事物的调用

00:46:21.140 --> 00:46:26.089
每次都会运行此调用， 

00:46:23.529 --> 00:46:27.979
我们希望会看到所有结果

00:46:26.089 --> 00:46:29.809
对，所以我们会说你知道叫这个

00:46:27.979 --> 00:46:32.059
然后告诉我们我们现在得到了什么

00:46:29.809 --> 00:46:36.829
让我们看看为什么这仍然令人沮丧哦

00:46:32.059 --> 00:46:39.549
这是因为M检查禁用

00:46:36.829 --> 00:46:39.549
那个检查

00:46:41.700 --> 00:46:46.120
好吧，现在让我们继续运行

00:46:44.530 --> 00:46:48.160
这次我们要再次运行它

00:46:46.120 --> 00:46:49.570
缓存时称为缓存

00:46:48.160 --> 00:46:51.610
第一次相同的查询

00:46:49.570 --> 00:46:59.680
我们应该说十秒钟

00:46:51.610 --> 00:47:01.180
所以它称缓存为

00:46:59.680 --> 00:47:03.880
当然这里很乏味的时间

00:47:01.180 --> 00:47:06.670
也是第一次花了十

00:47:03.880 --> 00:47:08.470
一千零九毫秒

00:47:06.670 --> 00:47:09.910
迟了十秒零九密耳，所以

00:47:08.470 --> 00:47:11.650
第一次实际访问是9 

00:47:09.910 --> 00:47:13.510
第二次花了毫秒

00:47:11.650 --> 00:47:15.100
第三次以毫秒为单位

00:47:13.510 --> 00:47:16.570
毫秒，或者您知道的那么少

00:47:15.100 --> 00:47:18.220
这可能实际上是

00:47:16.570 --> 00:47:19.690
纳秒级粒度I 

00:47:18.220 --> 00:47:21.220
不知道我就知道了

00:47:19.690 --> 00:47:23.920
它给我们的是四舍五入

00:47:21.220 --> 00:47:25.630
当然正确，所以重点是我们有

00:47:23.920 --> 00:47:26.980
能够真正快速使用的能力

00:47:25.630 --> 00:47:29.980
记忆权，我们得到

00:47:26.980 --> 00:47:35.080
自由和幕后，你知道是否

00:47:29.980 --> 00:47:39.250
我们看看这个键，我们有调用

00:47:35.080 --> 00:47:41.280
它基于其中的ID，所以让我们看看

00:47:39.250 --> 00:47:43.840
我什至不确定我是否能发现EM 

00:47:41.280 --> 00:47:45.970
这是关于调用

00:47:43.840 --> 00:47:46.600
用来制造的咒语

00:47:45.970 --> 00:47:50.830
那个电话

00:47:46.600 --> 00:47:55.900
好吧，命令哦，如果是那样

00:47:50.830 --> 00:47:57.700
无论如何正在为我们做

00:47:55.900 --> 00:48:00.070
自动哦，他们只是由

00:47:57.700 --> 00:48:01.570
一种权利，那就是咒语

00:48:00.070 --> 00:48:12.720
如果我们看着那等一下，如果你看着

00:48:01.570 --> 00:48:12.720
值顺序好吗，所以键和

00:48:16.880 --> 00:48:29.630
获得价值

00:48:33.050 --> 00:48:36.050
读

00:48:46.599 --> 00:48:57.609
好吧，所以我们试图获得价值

00:48:50.519 --> 00:48:59.079
一把钥匙，如果我说实话我不知道

00:48:57.609 --> 00:49:01.059
您应该使用的命令

00:48:59.079 --> 00:49:04.650
他们摆脱了CLI，我总是会做

00:49:01.059 --> 00:49:07.569
它来自Springs，所以它是关键吗

00:49:04.650 --> 00:49:10.299
让我们在那里尝试一下

00:49:07.569 --> 00:49:12.339
我们说的有意义，所以贴在你那里

00:49:10.299 --> 00:49:14.200
去，所以有Java cos编码

00:49:12.339 --> 00:49:16.210
再次使用该对象，您可以使用自定义

00:49:14.200 --> 00:49:17.229
消毒器，但您可以看到它已经

00:49:16.210 --> 00:49:20.019
我们需要的相同信息

00:49:17.229 --> 00:49:21.729
有订单和对齐的项目， 

00:49:20.019 --> 00:49:23.619
你知道所有需要的位

00:49:21.729 --> 00:49:26.890
使这项工作成为Java util日期

00:49:23.619 --> 00:49:28.359
所有的东西都好吧

00:49:26.890 --> 00:49:30.269
所以有记忆的版本

00:49:28.359 --> 00:49:32.170
记录，那会起作用的，你知道

00:49:30.269 --> 00:49:34.180
尽管有序列化问题

00:49:32.170 --> 00:49:36.220
可以跨多个虚拟

00:49:34.180 --> 00:49:38.109
机器，如果我们有十台

00:49:36.220 --> 00:49:40.599
不同的应用程序Web应用程序

00:49:38.109 --> 00:49:42.400
他们在那里打电话给

00:49:40.599 --> 00:49:44.109
这个订单服务和一个客户

00:49:42.400 --> 00:49:46.509
一个Web服务上的通话一个

00:49:44.109 --> 00:49:48.009
应用程序实例，然后是其他客户端

00:49:46.509 --> 00:49:49.930
访问同一条记录

00:49:48.009 --> 00:49:51.569
应用程序实例将从中受益

00:49:49.930 --> 00:49:55.239
查找，当然你可以有

00:49:51.569 --> 00:49:57.969
缓存逐出注释可以逐出

00:49:55.239 --> 00:50:00.039
说public void更新长ID，而您

00:49:57.969 --> 00:50:02.140
可以说您知道已将其逐出

00:50:00.039 --> 00:50:04.239
根据此方法调用记录

00:50:02.140 --> 00:50:07.210
我们实际上会使记录无效

00:50:04.239 --> 00:50:10.930
根据调用在存储库中

00:50:07.210 --> 00:50:14.349
好的，所以现在谈到网络

00:50:10.930 --> 00:50:17.499
非常合乎逻辑的用例

00:50:14.349 --> 00:50:19.989
像雷纳斯这样的现金就是用它来

00:50:17.499 --> 00:50:22.390
会话存储权，让我们带上

00:50:19.989 --> 00:50:24.579
应用程序备份就绪

00:50:22.390 --> 00:50:26.200
应用程序，我们有这个应用程序

00:50:24.579 --> 00:50:29.440
现在正在运行，该应用程序正在

00:50:26.200 --> 00:50:30.789
跑步，我们有嗯，你不知道

00:50:29.440 --> 00:50:32.799
 WebM现在指向，让我们继续吧

00:50:30.789 --> 00:50:35.229
并做到这一点，我们将建立一个简单的

00:50:32.799 --> 00:50:40.089
将使用HTTP的网络端点

00:50:35.229 --> 00:50:41.950
会议，所以我们会说我想做什么

00:50:40.089 --> 00:50:47.789
写我可以在这里说

00:50:41.950 --> 00:50:50.559
你知道的课程

00:50:47.789 --> 00:50:54.329
控制器好，这将

00:50:50.559 --> 00:50:56.769
成为已记录的Spring MVC控制器

00:50:54.329 --> 00:50:58.809
这将具有一个会话属性

00:50:56.769 --> 00:50:59.870
叫做购物车，我们将返回

00:50:58.809 --> 00:51:05.480
一秒钟

00:50:59.870 --> 00:51:07.010
以及我们要创建的数据

00:51:05.480 --> 00:51:08.920
属性，所以会发生的是

00:51:07.010 --> 00:51:11.890
我们要返回一个

00:51:08.920 --> 00:51:16.460
购物车

00:51:11.890 --> 00:51:23.500
好吧，像这样的阶级和购物

00:51:16.460 --> 00:51:26.810
购物车将有一个订单集合

00:51:23.500 --> 00:51:31.760
订单，这必须是所有C可靠的

00:51:26.810 --> 00:51:33.110
所以你应该使用一点

00:51:31.760 --> 00:51:36.290
这里需要更多的照顾，但我要使用

00:51:33.110 --> 00:51:39.530
非常简单，非常简单

00:51:36.290 --> 00:51:44.420
线程天真的方法在这里，所以我要

00:51:39.530 --> 00:51:47.090
说公共无效和秩序，我用

00:51:44.420 --> 00:51:51.620
这里的订单对象

00:51:47.090 --> 00:51:53.420
这个订单点加订单好

00:51:51.620 --> 00:51:57.710
我将在这里有另一个终点

00:51:53.420 --> 00:52:01.420
返回订单的集合get 

00:51:57.710 --> 00:52:04.940
命令好吧，让我们返回这个点

00:52:01.420 --> 00:52:06.500
订单点到那里，所以这是我非常

00:52:04.940 --> 00:52:08.750
简单的购物车，我们想要

00:52:06.500 --> 00:52:11.870
购物车要持久，所以我

00:52:08.750 --> 00:52:17.840
还要使其可序列化

00:52:11.870 --> 00:52:21.080
我们想支持我的工作

00:52:17.840 --> 00:52:24.140
的问题扩大了一部分

00:52:21.080 --> 00:52:27.170
问题，现在让我确认

00:52:24.140 --> 00:52:31.970
一切都很好，所以

00:52:27.170 --> 00:52:34.070
这是会话属性，所以

00:52:31.970 --> 00:52:36.370
将会发生什么事

00:52:34.070 --> 00:52:38.540
 Spring MVC控制器被加载

00:52:36.370 --> 00:52:41.990
这里会有某些终点

00:52:38.540 --> 00:52:45.680
会寻找一辆手推车，然后

00:52:41.990 --> 00:52:46.550
如果他们在会话中寻找购物车

00:52:45.680 --> 00:52:48.080
找不到它们，他们将不得不

00:52:46.550 --> 00:52:50.030
创建一个他们可以

00:52:48.080 --> 00:52:52.070
用作数据的支撑

00:52:50.030 --> 00:52:53.960
将在一个人的生命周期中被创造

00:52:52.070 --> 00:52:55.850
是处理程序方法，因此它将

00:52:53.960 --> 00:52:58.430
模型属性方法

00:52:55.850 --> 00:53:00.560
出售新实例的控制器

00:52:58.430 --> 00:53:02.540
那辆车的东西，所以回来了

00:53:00.560 --> 00:53:05.750
购物车，所以这将是空的

00:53:02.540 --> 00:53:10.010
我要记录你知道的生产或

00:53:05.750 --> 00:53:11.549
创建新的购物车好了，我要去

00:53:10.010 --> 00:53:14.190
记录

00:53:11.549 --> 00:53:16.829
然后我要使用它们，我说那是

00:53:14.190 --> 00:53:19.770
在此处创建一个定单，称为订单

00:53:16.829 --> 00:53:21.750
你知道点Redis或其他任何东西

00:53:19.770 --> 00:53:25.650
用命令叫它，如果你想

00:53:21.750 --> 00:53:27.450
将要返回的HTML页面

00:53:25.650 --> 00:53:30.569
时间，如果并且那将注入这个

00:53:27.450 --> 00:53:33.480
模型属性模型属性购物车

00:53:30.569 --> 00:53:36.210
这将是购物车，所以购物

00:53:33.480 --> 00:53:37.950
购物车到购物车，我们将创建一个

00:53:36.210 --> 00:53:39.750
模型让我带一些模型来渲染

00:53:37.950 --> 00:53:41.609
这里的视图和模型只是

00:53:39.750 --> 00:53:45.750
里面会有一些数据

00:53:41.609 --> 00:53:47.190
属性订单，它将被购物车杀死

00:53:45.750 --> 00:53:49.619
得到订单，所以我们要做的是

00:53:47.190 --> 00:53:53.849
每当有人去这个终点

00:53:49.619 --> 00:53:56.490
我们要添加一个新订单，我们

00:53:53.849 --> 00:53:59.029
将有一个私人原子私人

00:53:56.490 --> 00:54:05.130
原子长权，所以私人决赛

00:53:59.029 --> 00:54:10.200
原子长新原子长我叫

00:54:05.130 --> 00:54:13.410
这个ID，我们将在这里添加订单

00:54:10.200 --> 00:54:20.400
就像这样，我们将说ID点增量和

00:54:13.410 --> 00:54:23.490
获取新日期，收藏集为空

00:54:20.400 --> 00:54:25.799
列出，以便当我分别添加新记录时

00:54:23.490 --> 00:54:28.349
时间，然后渲染一个名为

00:54:25.799 --> 00:54:29.430
尚未激活的订单

00:54:28.349 --> 00:54:32.430
查看我们要去的被叫定单

00:54:29.430 --> 00:54:33.539
在视图中进行迭代，以便进行审查

00:54:32.430 --> 00:54:34.710
有人将这个端点称为

00:54:33.539 --> 00:54:37.859
我们将向

00:54:34.710 --> 00:54:39.059
会话中的购物车

00:54:37.859 --> 00:54:40.619
如果记录不存在，会话也不会

00:54:39.059 --> 00:54:43.589
存在于会话中，然后它将

00:54:40.619 --> 00:54:46.859
将此模型属性方法称为

00:54:43.589 --> 00:54:48.059
然后就可以使用它- 

00:54:46.859 --> 00:54:49.559
它会以一种

00:54:48.059 --> 00:54:51.480
参数，我要添加一条新记录

00:54:49.559 --> 00:54:53.299
因此，随着时间的推移，我们进行了相同的会话

00:54:51.480 --> 00:54:56.339
应该看到越来越多的

00:54:53.299 --> 00:54:58.049
购物车中的订单，但如果您开始

00:54:56.339 --> 00:54:59.670
新的会话，只是应该设置

00:54:58.049 --> 00:55:01.980
回到零，我们应该看到它说

00:54:59.670 --> 00:55:05.039
马上创建一个新的购物车

00:55:01.980 --> 00:55:06.539
好吧，现在我们需要一个

00:55:05.039 --> 00:55:08.880
模板某种视图，所以这是

00:55:06.539 --> 00:55:12.029
为什么我加时间他们害怕所以来源

00:55:08.880 --> 00:55:13.950
我将要使用的主要资源模板

00:55:12.029 --> 00:55:17.579
在此处创建一个名为订单点的文件

00:55:13.950 --> 00:55:19.770
 HTML和HTML文件的顺序

00:55:17.579 --> 00:55:22.170
只是我们要你知道我

00:55:19.770 --> 00:55:24.960
我不会饶你的我会饶大家的

00:55:22.170 --> 00:55:29.369
这个实时编码在那里，所以桌面

00:55:24.960 --> 00:55:33.570
 Redis源资源模板或

00:55:29.369 --> 00:55:38.280
学习HTML剪贴板好人，所以

00:55:33.570 --> 00:55:43.170
非常非常简单的Redis命令

00:55:38.280 --> 00:55:46.830
是正确的命令，我们要做的是

00:55:43.170 --> 00:55:49.140
想渲染一个div元素，而是

00:55:46.830 --> 00:55:51.510
我们将为每个渲染两个范围

00:55:49.140 --> 00:55:53.730
我从中归属的订单中的订单哦

00:55:51.510 --> 00:55:56.210
查看Evan模型时， 

00:55:53.730 --> 00:55:58.619
取消引用ID和何时

00:55:56.210 --> 00:56:00.240
属性顺序正确，所以我认为

00:55:58.619 --> 00:56:02.099
那应该是我们唯一的东西

00:56:00.240 --> 00:56:04.530
现在需要做的是启用Spring 

00:56:02.099 --> 00:56:06.540
春季会议是设施

00:56:04.530 --> 00:56:12.119
让我们换出HTTP Servlet 

00:56:06.540 --> 00:56:14.130
会话并将其替换为

00:56:12.119 --> 00:56:15.960
我们选择的可插入会话存储

00:56:14.130 --> 00:56:18.089
在这里，我们正在使用威尼斯，我们可以使用

00:56:15.960 --> 00:56:21.720
 H缓存或内存中，或者我们可以使用

00:56:18.089 --> 00:56:22.830
 MongoDB或JBC或榛树种姓或您

00:56:21.720 --> 00:56:25.650
在这里知道许多不同的选择

00:56:22.830 --> 00:56:26.849
但是Redis对此是一个不错的选择

00:56:25.650 --> 00:56:30.570
所以我们要删除一组

00:56:26.849 --> 00:56:38.130
会话，我们启动了应用程序，因此

00:56:30.570 --> 00:56:41.339
现在，如果我们去哪里，我们说我们在

00:56:38.130 --> 00:56:44.369
会在

00:56:41.339 --> 00:56:45.290
浏览器localhost 8080特殊

00:56:44.369 --> 00:56:50.099
命令

00:56:45.290 --> 00:56:51.839
如果我现在去1 2 3 4 5 6 7等

00:56:50.099 --> 00:56:53.910
创建一个新实例去同一个

00:56:51.839 --> 00:56:55.920
端点，你可以看到它已经得到了你

00:56:53.910 --> 00:56:59.030
知道这是ID，所以编号是9 

00:56:55.920 --> 00:57:02.339
显然是一个不同的实例，但这是

00:56:59.030 --> 00:57:05.700
增加你知道彼此独立

00:57:02.339 --> 00:57:07.859
其他的对，所以我有两个

00:57:05.700 --> 00:57:15.089
这里的不同会议

00:57:07.859 --> 00:57:17.520
被存储在Redis中，所以密钥和你

00:57:15.089 --> 00:57:19.589
可以看到春季课程到期了

00:57:17.520 --> 00:57:21.119
这里还有另一个属性

00:57:19.589 --> 00:57:24.570
如果我能在那里也有 Spring 

00:57:21.119 --> 00:57:26.460
会话到期春季会话等

00:57:24.570 --> 00:57:28.830
所以我们有不同的会议

00:57:26.460 --> 00:57:30.540
坚持在这里，由我们为我们管理

00:57:28.830 --> 00:57:32.760
不同的应用程序实例，所以如果我

00:57:30.540 --> 00:57:35.400
打算把另一个例子

00:57:32.760 --> 00:57:36.620
在此应用程序然后

00:57:35.400 --> 00:57:38.810
不知何故

00:57:36.620 --> 00:57:42.140
在端口8081上调用该应用程序

00:57:38.810 --> 00:57:43.910
例如然后给相同的cookie 

00:57:42.140 --> 00:57:47.240
同一氏族说我应该得到饼干

00:57:43.910 --> 00:57:48.560
相同的结果，所以没有

00:57:47.240 --> 00:57:50.570
那是你知道的，这是非常简单的

00:57:48.560 --> 00:57:52.810
使用Redis作为会话的示例

00:57:50.570 --> 00:57:56.660
只需在我们实际上可以插入的地方

00:57:52.810 --> 00:57:58.730
注入我在这里使用spring MVC，但是

00:57:56.660 --> 00:58:00.560
您可以注入您的春季MVC 

00:57:58.730 --> 00:58:03.740
控制器，您可以说HTTP会话

00:58:00.560 --> 00:58:07.730
会议，然后也这样做

00:58:03.740 --> 00:58:10.940
工作正常，它将插入

00:58:07.730 --> 00:58:12.740
我们拥有的春季会议适配器

00:58:10.940 --> 00:58:15.410
自动为您配置，以便

00:58:12.740 --> 00:58:17.090
您知道的独立于

00:58:15.410 --> 00:58:18.830
您可以在这里编程模型

00:58:17.090 --> 00:58:20.750
实际创建我拥有网络的网络服务

00:58:18.830 --> 00:58:22.940
您知道的服务器注释组件

00:58:20.750 --> 00:58:25.070
简单的servlet，然后

00:58:22.940 --> 00:58:26.720
反过来也不要在这里读我们

00:58:25.070 --> 00:58:28.940
所以它适用于每个层次

00:58:26.720 --> 00:58:30.200
免费发生，所以现在我们有一个

00:58:28.940 --> 00:58:31.790
水平可扩展会话

00:58:30.200 --> 00:58:33.860
持久性意味着如果一个节点

00:58:31.790 --> 00:58:36.170
跌倒，他们吃饱了，他们得到

00:58:33.860 --> 00:58:39.590
将绑定加载到会话的另一个节点

00:58:36.170 --> 00:58:40.970
状态还没有丢失好吧，所以现在

00:58:39.590 --> 00:58:42.050
现在我们有了一个Web应用程序

00:58:40.970 --> 00:58:44.120
我们有许多不同的用途

00:58:42.050 --> 00:58:45.860
我想我们在这里展示的案例

00:58:44.120 --> 00:58:46.610
我们应该好好部署吗

00:58:45.860 --> 00:58:49.700
所以我要接受这个申请

00:58:46.610 --> 00:58:50.630
我要添加一个Cloud Foundry清单

00:58:49.700 --> 00:58:55.340
到应用程序

00:58:50.630 --> 00:58:59.210
所以CD Redis复制桌面Redis清单

00:58:55.340 --> 00:59:02.540
在这里，你可以看到，如果我看着

00:58:59.210 --> 00:59:03.770
清单上的清单上说

00:59:02.540 --> 00:59:05.960
应用程序将被称为春季

00:59:03.770 --> 00:59:07.580
提示Redis，它将使用银行业务

00:59:05.960 --> 00:59:09.530
Spring 式尖头炉的服务以及

00:59:07.580 --> 00:59:12.200
我再次使用关键的Web服务

00:59:09.530 --> 00:59:13.910
在这里，我可以去CF市场， 

00:59:12.200 --> 00:59:16.370
我得到了所有不同的

00:59:13.910 --> 00:59:18.590
服务或为此提供的服务

00:59:16.370 --> 00:59:19.820
托管多租户云产品

00:59:18.590 --> 00:59:25.460
像Heroku或类似的东西

00:59:19.820 --> 00:59:28.280
我们这里有一个Redis实例

00:59:25.460 --> 00:59:34.820
是我们的Redis支持的新产品，没有PMS 

00:59:28.280 --> 00:59:37.730
等于PQ-云埃博拉病毒，所以有

00:59:34.820 --> 00:59:42.080
你知道不同的配额

00:59:37.730 --> 00:59:46.130
这里有不同的SLA选项，我有

00:59:42.080 --> 00:59:47.330
这个CF的实例

00:59:46.130 --> 00:59:50.600
为了服务，我有一个实例

00:59:47.330 --> 00:59:52.220
 st vitus Rinna的云100兆字节计划

00:59:50.600 --> 00:59:57.100
我有一个名为st的应用程序

00:59:52.220 --> 00:59:59.740
见证我现在要去cfd-f st Redis 

00:59:57.100 --> 01:00:02.570
好的，所以我要删除该应用程序

00:59:59.740 --> 01:00:06.580
已经被部署，所以现在

01:00:02.570 --> 01:00:08.900
与Redis实例解除绑定

01:00:06.580 --> 01:00:14.660
我将删除我的服务

01:00:08.900 --> 01:00:15.920
要删除CFDA-des-f st Redis so 

01:00:14.660 --> 01:00:18.380
我现在也要删除该服务

01:00:15.920 --> 01:00:20.750
我们将拥有全新的一切

01:00:18.380 --> 01:00:27.380
会在new上创建服务，因此CF c 

01:00:20.750 --> 01:00:35.600
 s st Redis，所以我们读为云100 

01:00:27.380 --> 01:00:37.370
兆字节st Redis好，所以我们去了

01:00:35.600 --> 01:00:40.370
现在我要做一个行家清洁

01:00:37.370 --> 01:00:41.870
包，这将建立

01:00:40.370 --> 01:00:43.940
罐子应用Springwood 

01:00:41.870 --> 01:00:45.170
应用程序，它将运行

01:00:43.940 --> 01:00:47.150
应用程序，所以我们将看到所有相同的

01:00:45.170 --> 01:00:48.950
运行时看到的熟悉的日志

01:00:47.150 --> 01:00:53.240
在IDE中的应用程序

01:00:48.950 --> 01:00:59.690
要将其部署到平台上

01:00:53.240 --> 01:01:01.550
所以现在我们说CF push-P target Venice 

01:00:59.690 --> 01:01:06.170
我们要给它取一个逻辑名称

01:01:01.550 --> 01:01:07.640
叫圣维特，但我们知道吗

01:01:06.170 --> 01:01:09.560
认为会自动，但我认为

01:01:07.640 --> 01:01:12.770
它将这个push命令与

01:01:09.560 --> 01:01:14.690
表现出来，但让我想，我想

01:01:12.770 --> 01:01:17.540
很好，让我们尝试创建应用

01:01:14.690 --> 01:01:21.020
 st vitus使用圆形绑定此路线

01:01:17.540 --> 01:01:23.990
到上传这个我不确定

01:01:21.020 --> 01:01:26.060
如果我们已经将圣维特绑定到

01:01:23.990 --> 01:01:28.250
它或如果要咨询

01:01:26.060 --> 01:01:30.290
体现哦，是的，这是使用

01:01:28.250 --> 01:01:33.710
清单，因此它已经绑定了

01:01:30.290 --> 01:01:34.940
圣维特斯名称服务

01:01:33.710 --> 01:01:36.920
应用程序，因此现在它正在上传

01:01:34.940 --> 01:01:38.570
应用程序，平台将是

01:01:36.920 --> 01:01:39.620
看一下传入的工件

01:01:38.570 --> 01:01:41.800
会意识到这是一个罐子

01:01:39.620 --> 01:01:43.580
应用它会给它一个

01:01:41.800 --> 01:01:45.080
具有一切所需的文件系统

01:01:43.580 --> 01:01:46.970
阅读以在此运行应用程序

01:01:45.080 --> 01:01:48.560
案例工作的虚拟机将

01:01:46.970 --> 01:01:53.050
给它一个我们在这里看到的路线

01:01:48.560 --> 01:01:56.630
我希望的应用程序的vitus dot c 

01:01:53.050 --> 01:01:58.700
让我们看看这里有什么

01:01:56.630 --> 01:02:01.340
所以它将使用一个构建包

01:01:58.700 --> 01:02:05.060
决定什么文件系统的东西

01:02:01.340 --> 01:02:08.330
需要运行它的应用程序

01:02:05.060 --> 01:02:11.900
必然会选择Java 

01:02:08.330 --> 01:02:13.130
构建包，然后它将开始

01:02:11.900 --> 01:02:15.470
应用程序将使

01:02:13.130 --> 01:02:16.610
文件系统放入一个容器中

01:02:15.470 --> 01:02:18.040
然后立即在整个群集中计划

01:02:16.610 --> 01:02:20.480
我们能做的是

01:02:18.040 --> 01:02:23.990
集群我们的应用程序，我们可以说CF 

01:02:20.480 --> 01:02:26.600
规模-我-实际上是

01:02:23.990 --> 01:02:28.100
应用程序实例数

01:02:26.600 --> 01:02:29.990
本身，但他们都在与

01:02:28.100 --> 01:02:30.980
同样持久的权利商店，即使

01:02:29.990 --> 01:02:32.780
我们打了不同的实例

01:02:30.980 --> 01:02:40.970
应用程序，我们仍然会获取数据

01:02:32.780 --> 01:02:44.170
好吧，让我们看看等待根

01:02:40.970 --> 01:02:44.170
构建包开始

01:03:02.370 --> 01:03:08.120
很好创建容器上传

01:03:05.430 --> 01:03:08.120
应用程序

01:03:25.420 --> 01:03:30.280
现在该工件应该是UM 

01:03:28.300 --> 01:03:32.040
现在随时在这里旋转，现在上传

01:03:30.280 --> 01:03:34.540
完成

01:03:32.040 --> 01:03:38.290
我将输入完全不确定

01:03:34.540 --> 01:03:41.280
一个实例的零是

01:03:38.290 --> 01:03:41.280
一跑

01:03:47.609 --> 01:03:51.269
我们去了所以有我们的应用程序

01:03:49.650 --> 01:03:55.890
在此端点启动并运行

01:03:51.269 --> 01:03:59.130
好吧，这叫做命令

01:03:55.890 --> 01:04:04.680
对，所以第一次打电话第二次打电话第三次

01:03:59.130 --> 01:04:06.299
在这里打电话并做同样的事情

01:04:04.680 --> 01:04:07.979
所以现在我们有了一个您知道的应用程序

01:04:06.299 --> 01:04:10.049
两个不同的两个不同的会议

01:04:07.979 --> 01:04:14.150
被坚持现在让我们去

01:04:10.049 --> 01:04:18.479
向前并扩大规模，这样CF规模

01:04:14.150 --> 01:04:22.019
 -我-圣-对，所以我要加倍

01:04:18.479 --> 01:04:25.559
该应用程序实例CF上的负载

01:04:22.019 --> 01:04:28.259
我现在要关注的日志

01:04:25.559 --> 01:04:32.160
这个实例，当我提出请求

01:04:28.259 --> 01:04:34.849
在这里你可以看到他们要求来

01:04:32.160 --> 01:04:39.839
进入左侧的应用程序

01:04:34.849 --> 01:04:42.329
路由器11的路由器0，让我们看看

01:04:39.839 --> 01:04:44.039
它实际上表明是吗

01:04:42.329 --> 01:04:50.880
其他应用程序仍在运行中

01:04:44.039 --> 01:04:54.150
 proc web 1好，所以我们现在得到了两个

01:04:50.880 --> 01:04:55.349
配置不同应用程序的方式

01:04:54.150 --> 01:04:57.299
让他们旋转起来，我们将开始

01:04:55.349 --> 01:05:02.599
能够轮询请求

01:04:57.299 --> 01:05:02.599
跨多个实例好吧

01:05:15.730 --> 01:05:27.730
好的，刷新，刷新，刷新，注意如何

01:05:23.980 --> 01:05:30.760
在这种情况下，因为我们正在运行它

01:05:27.730 --> 01:05:32.800
有相同的会话，但已处理

01:05:30.760 --> 01:05:34.839
在不同的JVM上，我们知道

01:05:32.800 --> 01:05:36.880
已在JVM上处理，因为ID为

01:05:34.839 --> 01:05:40.329
 3好吧，记住我们有

01:05:36.880 --> 01:05:41.920
长期以来，这是JVM 

01:05:40.329 --> 01:05:43.690
具体你知道它的内在状态

01:05:41.920 --> 01:05:45.790
但是内部状态是外部

01:05:43.690 --> 01:05:47.589
状态是会话本身

01:05:45.790 --> 01:05:49.720
由Redis管理，仅此而已

01:05:47.589 --> 01:05:51.940
透明的，所以你知道，我们有

01:05:49.720 --> 01:05:54.490
同一主机，我们应该具有相同的主机

01:05:51.940 --> 01:05:57.190
是cookie同一会话cookie 

01:05:54.490 --> 01:05:59.800
击中同一台主机，您知道我们有一个

01:05:57.190 --> 01:06:01.270
在后台加载保镖，我们

01:05:59.800 --> 01:06:02.710
正确地进行不同的会话

01:06:01.270 --> 01:06:03.910
获得不同的应用程序实例

01:06:02.710 --> 01:06:05.349
我们知道，因为

01:06:03.910 --> 01:06:07.750
那些州的情况不同

01:06:05.349 --> 01:06:09.400
不同的ATM，但我们仍然能够

01:06:07.750 --> 01:06:11.710
看到和一起购物

01:06:09.400 --> 01:06:13.060
两个便笺上的购物车，所以这是其中之一

01:06:11.710 --> 01:06:14.650
 Redis的例子只是

01:06:13.060 --> 01:06:16.540
透明，你知道你可以做的事情

01:06:14.650 --> 01:06:17.920
只是分层到您的

01:06:16.540 --> 01:06:18.609
应用程序，并获得所有这些惊人的

01:06:17.920 --> 01:06:21.040
功能性

01:06:18.609 --> 01:06:21.880
现在我们已经很长时间了

01:06:21.040 --> 01:06:23.109
我们在这里看到了不同的东西

01:06:21.880 --> 01:06:25.150
缓存相关的冥想

01:06:23.109 --> 01:06:26.950
会议，我们看了仓库

01:06:25.150 --> 01:06:28.750
看了地理地理空间支持我

01:06:26.950 --> 01:06:34.300
将不得不发布/订阅支持

01:06:28.750 --> 01:06:36.430
我们看着你知道你知道缓存

01:06:34.300 --> 01:06:38.140
只是通用缓存本身

01:06:36.430 --> 01:06:39.220
这里有很多不同的东西，但是

01:06:38.140 --> 01:06:42.099
我们才刚刚开始刮擦表面

01:06:39.220 --> 01:06:43.839
正如我所说，Redis是一支多变的瑞士军队

01:06:42.099 --> 01:06:45.069
它支持的功能刀

01:06:43.839 --> 01:06:46.839
不同事物的数量和

01:06:45.069 --> 01:06:48.369
 Spring 的生态系统，我们可以很好地利用它

01:06:46.839 --> 01:06:50.050
效果以及我们可以做到的每一层

01:06:48.369 --> 01:06:52.690
甚至有一个名为spring pod的项目

01:06:50.050 --> 01:06:55.119
网关建立在

01:06:52.690 --> 01:06:56.560
您在春季知道的反应式支持

01:06:55.119 --> 01:06:57.940
框架五，Spring 网通量及全部

01:06:56.560 --> 01:07:00.220
那，我已经完成了以前的视频

01:06:57.940 --> 01:07:02.260
Spring 卡网关本身，在那里我们

01:07:00.220 --> 01:07:03.970
看着使用 Spring Cloud 游戏我们

01:07:02.260 --> 01:07:06.270
需要很好地创建一个速率限制器

01:07:03.970 --> 01:07:09.160
必须保持外部状态外在

01:07:06.270 --> 01:07:10.990
声明某个地方，以便创建游览

01:07:09.160 --> 01:07:13.480
例如在Redis中，实际上

01:07:10.990 --> 01:07:15.250
使用他们的反应性RedisSpring 数据

01:07:13.480 --> 01:07:16.720
我什至没有去过的模块

01:07:15.250 --> 01:07:19.180
在这里使用，因为它仍然只是

01:07:16.720 --> 01:07:20.319
你知道所有这些想法都适用

01:07:19.180 --> 01:07:21.430
知道可以使用非常方便

01:07:20.319 --> 01:07:24.150
这是传统的

01:07:21.430 --> 01:07:27.400
基于servlet的架构

01:07:24.150 --> 01:07:28.839
我的朋友非常感谢你

01:07:27.400 --> 01:07:29.110
看我希望你喜欢我们

01:07:28.839 --> 01:07:31.410
看到

01:07:29.110 --> 01:07:31.410
下次

01:07:37.750 --> 01:07:39.810
您

