WEBVTT
Kind: captions
Language: zh-Hans

00:00:13.750 --> 00:00:17.710
嘿，今天的春季歌迷，我们要去

00:00:16.270 --> 00:00:19.449
向前看一些

00:00:17.710 --> 00:00:21.160
春季的低层接口

00:00:19.449 --> 00:00:22.360
框架本身，使您可以编写

00:00:21.160 --> 00:00:24.520
更了解

00:00:22.360 --> 00:00:26.669
容器中的应用程序上下文为什么

00:00:24.520 --> 00:00:29.189
想做到这一点有点

00:00:26.669 --> 00:00:31.300
视情况而定，但

00:00:29.189 --> 00:00:32.829
足以说明您不必

00:00:31.300 --> 00:00:34.510
经常这样做，所以我只想

00:00:32.829 --> 00:00:36.730
解释一些这些东西是什么

00:00:34.510 --> 00:00:38.890
这些机会是什么？ 

00:00:36.730 --> 00:00:40.210
我想告诉你你可能拥有的东西

00:00:38.890 --> 00:00:41.590
看过但不太了解，因为

00:00:40.210 --> 00:00:43.960
使用一些不常见

00:00:41.590 --> 00:00:46.570
这些东西在java配置中

00:00:43.960 --> 00:00:49.449
仿佛 Spring 布丁的世界

00:00:46.570 --> 00:00:52.600
和春季3数据或更高版本，但如果您已经

00:00:49.449 --> 00:00:54.579
有旧代码，您可能已经看到这些

00:00:52.600 --> 00:00:56.710
周围的事情，所以这可能是有用的

00:00:54.579 --> 00:00:58.030
读一些其中的东西，也许

00:00:56.710 --> 00:00:58.960
您甚至还会学到一些新东西

00:00:58.030 --> 00:01:00.729
所以继续前进，我们将继续前进， 

00:00:58.960 --> 00:01:02.440
在这里创建一个新的新项目

00:01:00.729 --> 00:01:03.760
我不会带进来的 Spring 

00:01:02.440 --> 00:01:05.409
任何具体的我什么都不需要

00:01:03.760 --> 00:01:07.090
具体我只是要用Spring 

00:01:05.409 --> 00:01:09.490
框架本身的应用程序上下文

00:01:07.090 --> 00:01:12.100
而所有的一切都由我为

00:01:09.490 --> 00:01:14.740
 Spring Boot Starter默认取决于

00:01:12.100 --> 00:01:17.710
通过不选择任何东西来添加它

00:01:14.740 --> 00:01:18.700
 Spring 的初始值设定项，让我开始

00:01:17.710 --> 00:01:19.990
这个，我们要谈论的是

00:01:18.700 --> 00:01:21.160
今天我们要谈几个

00:01:19.990 --> 00:01:22.930
不同的东西我们第一件事

00:01:21.160 --> 00:01:24.580
要看的是如何管理

00:01:22.930 --> 00:01:27.540
对象的生命周期正确

00:01:24.580 --> 00:01:30.040
太好了，让我们继续创建一个

00:01:27.540 --> 00:01:31.780
这里有两个类，两个对象

00:01:30.040 --> 00:01:35.650
彼此合作的

00:01:31.780 --> 00:01:37.690
对方都是一个foo类的类吧

00:01:35.650 --> 00:01:39.640
他们彼此相关

00:01:37.690 --> 00:01:41.620
因此从理论上讲， 

00:01:39.640 --> 00:01:44.770
对另一个的依赖

00:01:41.620 --> 00:01:47.500
构造函数现在我在这里有一个对象

00:01:44.770 --> 00:01:49.630
我可以对你进行初始化

00:01:47.500 --> 00:01:51.580
完全了解foo 

00:01:49.630 --> 00:01:54.490
构造函数对，这是个好地方

00:01:51.580 --> 00:01:56.710
说出逻辑，因为到目前为止

00:01:54.490 --> 00:01:59.020
拥有全部，因为我拥有全部

00:01:56.710 --> 00:02:01.060
协作对象-需要设置

00:01:59.020 --> 00:02:01.690
在有效状态下提供

00:02:01.060 --> 00:02:03.850
构造函数

00:02:01.690 --> 00:02:05.800
我很好，但是有时候我可能有

00:02:03.850 --> 00:02:07.720
二传手我可能还有其他事情

00:02:05.800 --> 00:02:09.849
以后提供，所以也许我不明白

00:02:07.720 --> 00:02:12.519
他们都在构造函数中，也许我有

00:02:09.849 --> 00:02:15.580
初始化通过

00:02:12.519 --> 00:02:18.489
在这里的二传手，直到会说cetera 

00:02:15.580 --> 00:02:22.060
瞧，我现在需要一些回电

00:02:18.489 --> 00:02:23.830
在构造函数和

00:02:22.060 --> 00:02:25.450
二传手已经跑了，为此，我们

00:02:23.830 --> 00:02:27.340
要看一些我们可以看的

00:02:25.450 --> 00:02:29.470
 Spring 初始化在两个

00:02:27.340 --> 00:02:31.150
对，所以初始化光束是一个

00:02:29.470 --> 00:02:32.920
自春季以来的界面

00:02:31.150 --> 00:02:34.660
从纳 bean 开始的第一天，至少

00:02:32.920 --> 00:02:37.239
在此之前还有一段时间

00:02:34.660 --> 00:02:38.860
我们有一个理想的机会去做

00:02:37.239 --> 00:02:42.580
你们当中的人知道验证权，我要

00:02:38.860 --> 00:02:44.560
验证栏不能为空

00:02:42.580 --> 00:02:46.599
正确的，如果它是旧的，将有

00:02:44.560 --> 00:02:49.330
麻烦，让我们继续，现在定义

00:02:46.599 --> 00:02:51.489
这种类型的foo 

00:02:49.330 --> 00:02:55.590
或这里的光束提供器方法

00:02:51.489 --> 00:02:57.310
我们会说Beam foo返回一个新的foo， 

00:02:55.590 --> 00:02:58.900
显然，这会抛出

00:02:57.310 --> 00:03:01.690
例外，因为它没有aa 

00:02:58.900 --> 00:03:04.360
酒吧，所以我们必须立即吃

00:03:01.690 --> 00:03:05.440
带酒吧的食物

00:03:04.360 --> 00:03:06.880
这个工作，但让我们证明

00:03:05.440 --> 00:03:09.220
在调用properties方法之后

00:03:06.880 --> 00:03:11.410
这个有两个属性的方法也是

00:03:09.220 --> 00:03:13.630
做任何复杂事情的好地方

00:03:11.410 --> 00:03:16.290
状态设置等等，这是一个

00:03:13.630 --> 00:03:16.290
自然的地方

00:03:23.090 --> 00:03:27.920
您

00:03:25.069 --> 00:03:29.030
所以我们去吧，不能没有，这是

00:03:27.920 --> 00:03:30.950
我们所期望的正确，我们也可以

00:03:29.030 --> 00:03:33.709
想像一下，我们也可以

00:03:30.950 --> 00:03:35.030
想像要处理破坏

00:03:33.709 --> 00:03:36.830
逻辑在这里，我们正在创建我们有

00:03:35.030 --> 00:03:38.060
一个不错的二级构造函数

00:03:36.830 --> 00:03:39.530
与这类东西有关

00:03:38.060 --> 00:03:41.000
经过属性方法也许我们想要

00:03:39.530 --> 00:03:43.610
做建筑也许想

00:03:41.000 --> 00:03:44.720
明确知道该字段以

00:03:43.610 --> 00:03:45.980
触发垃圾收集器

00:03:44.720 --> 00:03:48.650
可以被垃圾收集了吧

00:03:45.980 --> 00:03:51.680
这是一个依赖或范围

00:03:48.650 --> 00:03:54.920
例如，在这种情况下，我也可以

00:03:51.680 --> 00:03:56.180
实施正确的一次性光束

00:03:54.920 --> 00:03:58.519
一次性光束是一个回调

00:03:56.180 --> 00:04:00.620
这也是如果你是镜像

00:03:58.519 --> 00:04:03.620
所有初始化光束等等

00:04:00.620 --> 00:04:07.160
我们要说这开始，你知道这个

00:04:03.620 --> 00:04:10.160
起始栏等于“否” 

00:04:07.160 --> 00:04:12.129
记住Java不像C ++没有

00:04:10.160 --> 00:04:15.140
最终答案的明确概念，但

00:04:12.129 --> 00:04:17.979
取消引用变量可以帮助

00:04:15.140 --> 00:04:20.690
垃圾收集器的想法

00:04:17.979 --> 00:04:22.850
拥有的自由度

00:04:20.690 --> 00:04:25.010
垃圾收集对象，所以这是

00:04:22.850 --> 00:04:27.470
非常非常方便，现在这非常

00:04:25.010 --> 00:04:29.090
在这种情况下，侵害权是我的平原

00:04:27.470 --> 00:04:31.280
老物件也许是我的帽子服务

00:04:29.090 --> 00:04:33.139
或任何知道 Spring 和

00:04:31.280 --> 00:04:35.870
没什么大不了的，我是说你

00:04:33.139 --> 00:04:38.060
无论如何都会意识到 Spring 

00:04:35.870 --> 00:04:40.870
可能会争论生命周期回调

00:04:38.060 --> 00:04:44.330
方法应特别有效

00:04:40.870 --> 00:04:46.460
或不论容器如何工作

00:04:44.330 --> 00:04:47.360
那当然是对的

00:04:46.460 --> 00:04:49.729
没有理由你不能例如

00:04:47.360 --> 00:04:51.770
删除那些接口，尤其是使用

00:04:49.729 --> 00:04:53.710
 Java配置权，如果你有XML 

00:04:51.770 --> 00:04:55.940
没有理由你不能只说

00:04:53.710 --> 00:04:59.180
你知道这样，你不能只是

00:04:55.940 --> 00:05:02.900
调用after属性设置方法foo 

00:04:59.180 --> 00:05:04.870
属性设置后加点等等

00:05:02.900 --> 00:05:10.610
那里一切都会好起来的

00:05:04.870 --> 00:05:12.500
但这需要

00:05:10.610 --> 00:05:16.070
代码来调用该方法，所以我想

00:05:12.500 --> 00:05:17.000
真正的论点在这里真正的

00:05:16.070 --> 00:05:18.680
最好的方法就是使用

00:05:17.000 --> 00:05:21.910
面向对象的最佳实践和通过

00:05:18.680 --> 00:05:24.229
它们作为构造函数参数

00:05:21.910 --> 00:05:26.270
你可能想中学

00:05:24.229 --> 00:05:28.130
这样的构造逻辑和你

00:05:26.270 --> 00:05:29.660
想要自动调用它

00:05:28.130 --> 00:05:32.510
当使用能够理解的容器时

00:05:29.660 --> 00:05:34.849
他们，因此我们可以使用J的hard 250 

00:05:32.510 --> 00:05:37.280
 J或250是一个很老的标准

00:05:34.849 --> 00:05:38.810
在Java EE 5中问世，它描述了

00:05:37.280 --> 00:05:42.740
基本生命周期

00:05:38.810 --> 00:05:46.460
所以在这里我可以在销毁前使用

00:05:42.740 --> 00:05:49.760
在这里我可以用抱歉代替张贴

00:05:46.460 --> 00:05:53.120
构造并在销毁前就这样

00:05:49.760 --> 00:05:56.360
如果一切顺利，现在就在这里摧毁

00:05:53.120 --> 00:05:57.380
计划我们应该看到相同的

00:05:56.360 --> 00:05:59.360
初始化错误

00:05:57.380 --> 00:06:02.260
我认为验证逻辑应该是

00:05:59.360 --> 00:06:02.260
到位

00:06:04.110 --> 00:06:08.520
这样我们就可以看到

00:06:06.479 --> 00:06:09.599
同样的效果就在这里

00:06:08.520 --> 00:06:12.659
哥哥，当名字完全

00:06:09.599 --> 00:06:13.979
权利后随心所欲或您知道设定

00:06:12.659 --> 00:06:15.840
随便你叫什么

00:06:13.979 --> 00:06:16.590
没关系没关系吧

00:06:15.840 --> 00:06:20.189
方法的名称是完全

00:06:16.590 --> 00:06:22.110
现在任意，这给了我们一些控制

00:06:20.189 --> 00:06:25.139
在整个生命周期中，对象自然

00:06:22.110 --> 00:06:26.909
我们可能有比

00:06:25.139 --> 00:06:29.099
只是一种可能会或可能不会的感觉

00:06:26.909 --> 00:06:33.599
不，也许我们有，也许我们正在尝试

00:06:29.099 --> 00:06:34.860
创建一个长时间运行的对象

00:06:33.599 --> 00:06:36.300
也许你在管理一些事情

00:06:34.860 --> 00:06:37.740
非常有状态且沉重，您想

00:06:36.300 --> 00:06:39.180
您想要能够启动和停止

00:06:37.740 --> 00:06:41.849
销毁并收集垃圾

00:06:39.180 --> 00:06:43.169
根据这些资源来管理这些大量资源

00:06:41.849 --> 00:06:45.120
应用程序容器的生命周期

00:06:43.169 --> 00:06:47.129
这是很常见的，例如

00:06:45.120 --> 00:06:49.409
春季创新，我们有很多

00:06:47.129 --> 00:06:50.879
可以用于不同的适配器

00:06:49.409 --> 00:06:53.159
这些与外界合作

00:06:50.879 --> 00:06:55.650
适配器旋转它们开始

00:06:53.159 --> 00:06:57.210
监视外部事件源以了解

00:06:55.650 --> 00:06:58.259
某种变化，然后根据

00:06:57.210 --> 00:07:00.389
他们发布的事件源

00:06:58.259 --> 00:07:03.599
信息进入应用程序上下文

00:07:00.389 --> 00:07:05.039
供下游组件使用Spring 

00:07:03.599 --> 00:07:06.810
否定这些是非常有状态的

00:07:05.039 --> 00:07:08.279
接收时适配器是有状态的

00:07:06.810 --> 00:07:10.409
来自消息队列的消息

00:07:08.279 --> 00:07:13.020
消息精灵在队列中处理

00:07:10.409 --> 00:07:14.550
将它们发送到下游等，等等

00:07:13.020 --> 00:07:16.440
在这种情况下，我们需要的不仅仅是

00:07:14.550 --> 00:07:18.120
只是您知道对象初始化

00:07:16.440 --> 00:07:20.039
和破坏，我们需要思考

00:07:18.120 --> 00:07:22.259
关于如何管理服务等

00:07:20.039 --> 00:07:24.509
首先，您知道这种情况下的课程是

00:07:22.259 --> 00:07:26.250
产生的葫芦或吊钩

00:07:24.509 --> 00:07:28.139
该服务，因此我们将创建一个

00:07:26.250 --> 00:07:30.990
实现智能的对象

00:07:28.139 --> 00:07:32.550
生命周期回调方法现在很聪明

00:07:30.990 --> 00:07:38.009
生命周期，在这种情况下实际上是

00:07:32.550 --> 00:07:42.839
非常简单的权利，所以是一个明智的生命周期

00:07:38.009 --> 00:07:44.190
对象只是一个对象

00:07:42.839 --> 00:07:45.389
实际上实现生活

00:07:44.190 --> 00:07:47.599
周期我想我们应该从

00:07:45.389 --> 00:07:50.310
首先，让我们继续前进， 

00:07:47.599 --> 00:07:52.229
减少到只是一个合同

00:07:50.310 --> 00:07:54.539
生命周期在这里，所以您必须

00:07:52.229 --> 00:07:56.520
开始停止并运行方法

00:07:54.539 --> 00:07:58.770
这些方法你可以看到

00:07:56.520 --> 00:07:59.879
该应用程序是否可以应用

00:07:58.770 --> 00:08:01.610
查看组件是否正在运行

00:07:59.879 --> 00:08:03.509
他们是否可以

00:08:01.610 --> 00:08:05.339
他们是否有基础设施

00:08:03.509 --> 00:08:07.919
组件正在使用的组件

00:08:05.339 --> 00:08:09.810
运行，你有薄荷坚持

00:08:07.919 --> 00:08:12.509
明确启动和停止

00:08:09.810 --> 00:08:13.680
服务那里的东西增强

00:08:12.509 --> 00:08:16.170
这个版本叫做智能激光

00:08:13.680 --> 00:08:21.660
聪明的我的周期

00:08:16.170 --> 00:08:23.160
智慧的生命周期为您带来额外的收益

00:08:21.660 --> 00:08:24.690
您可以在这里告诉spring的方法

00:08:23.160 --> 00:08:26.700
自动启动该组件或

00:08:24.690 --> 00:08:28.800
否则你可以提供破坏

00:08:26.700 --> 00:08:30.360
 JVM获取时发生的回调

00:08:28.800 --> 00:08:32.570
当应用程序可以关闭时关闭

00:08:30.360 --> 00:08:34.680
下降或首先发生的事情

00:08:32.570 --> 00:08:38.820
在这里回调以开始和停止

00:08:34.680 --> 00:08:40.680
但当然停止可能不会发生

00:08:38.820 --> 00:08:43.020
足够快的权利，所以它非常有用

00:08:40.680 --> 00:08:45.960
提供可以

00:08:43.020 --> 00:08:48.030
在JVM上运行，关闭钩子，我们

00:08:45.960 --> 00:08:49.860
在这里有一个状态对象，我们可以

00:08:48.030 --> 00:08:51.630
用于确定对象是否为

00:08:49.860 --> 00:08:54.990
运行，我们也有这个订单的想法

00:08:51.630 --> 00:08:57.270
一个阶段的顺序

00:08:54.990 --> 00:08:58.800
申请应该正确执行

00:08:57.270 --> 00:09:02.540
那是非常非常有用的

00:08:58.800 --> 00:09:04.020
特别是这样他们放宽对象

00:09:02.540 --> 00:09:05.690
如果您有很棒的东西很有用

00:09:04.020 --> 00:09:10.050
有状态的，也许一个人依赖

00:09:05.690 --> 00:09:21.420
其他正确的东西，所以我们在这里

00:09:10.050 --> 00:09:26.580
界面，我们可以看到有

00:09:21.420 --> 00:09:28.950
不同的知名阶段对不起你

00:09:26.580 --> 00:09:32.430
可以看到阶段只是一个

00:09:28.950 --> 00:09:36.510
数字正确的数字，但它落入

00:09:32.430 --> 00:09:38.010
零，那就意味着它没有

00:09:36.510 --> 00:09:41.730
特殊进口权无特殊要求

00:09:38.010 --> 00:09:43.230
重要性，但要由您提供

00:09:41.730 --> 00:09:45.180
如果您想订购该阶段

00:09:43.230 --> 00:09:47.970
正确的目的，所以它在这里使用

00:09:45.180 --> 00:09:51.330
生命周期处理器或默认处理器

00:09:47.970 --> 00:09:55.920
喜欢我的Spring 循环处理器

00:09:51.330 --> 00:09:57.600
用于告知您荣誉

00:09:55.920 --> 00:09:59.940
存在生命周期接口

00:09:57.600 --> 00:10:01.500
编码它最终创建对象并

00:09:59.940 --> 00:10:03.480
最终将具有

00:10:01.500 --> 00:10:06.840
同一生命周期组中的同一阶段

00:10:03.480 --> 00:10:08.250
因此，您可以通过某种方式

00:10:06.840 --> 00:10:13.530
说这会在之前发生

00:10:08.250 --> 00:10:15.900
等等，好吧，这是长寿的

00:10:13.530 --> 00:10:17.790
组件这再次是我认为

00:10:15.900 --> 00:10:19.230
当你需要这个的时候，你非常

00:10:17.790 --> 00:10:21.900
在编写组件的领域

00:10:19.230 --> 00:10:23.760
明确依赖生命周期

00:10:21.900 --> 00:10:25.980
Spring 框架的功能

00:10:23.760 --> 00:10:28.380
集装箱不仅是即时的飞机

00:10:25.980 --> 00:10:29.410
对象有时候你很复杂

00:10:28.380 --> 00:10:31.750
那些

00:10:29.410 --> 00:10:33.040
更多或者也许是您

00:10:31.750 --> 00:10:35.410
不要直接实例化，也许你

00:10:33.040 --> 00:10:37.180
有物体住在其他地方

00:10:35.410 --> 00:10:39.940
它们在应用程序外部

00:10:37.180 --> 00:10:41.920
上下文，因此您想提供一个

00:10:39.940 --> 00:10:45.009
该对象的定义

00:10:41.920 --> 00:10:47.139
当然，你要看的东西

00:10:45.009 --> 00:10:49.600
从简迪开始，现在简迪现在是

00:10:47.139 --> 00:10:50.769
目录是您知道的Java本机目录

00:10:49.600 --> 00:10:52.870
代表Java命名和目录

00:10:50.769 --> 00:10:55.750
界面，这是一种看待方式

00:10:52.870 --> 00:10:57.639
在上下文中上调键和值

00:10:55.750 --> 00:10:59.500
在很多应用中很常见

00:10:57.639 --> 00:11:01.360
服务器，所以这是一种很旧的

00:10:59.500 --> 00:11:03.129
想法，但与什么仍然有密切关系

00:11:01.360 --> 00:11:05.050
我们正在尝试在这种情况下

00:11:03.129 --> 00:11:07.060
 Jane Di Spring没有实例化

00:11:05.050 --> 00:11:09.279
对象，而是管理对象

00:11:07.060 --> 00:11:10.959
通过查找对象来确定上下文

00:11:09.279 --> 00:11:13.000
一些其他的事情和一些其他的记忆

00:11:10.959 --> 00:11:14.560
在JVM中正确的位置

00:11:13.000 --> 00:11:16.300
应用服务器的情况

00:11:14.560 --> 00:11:19.529
由应用程序管理的内存

00:11:16.300 --> 00:11:22.120
服务器与您的应用程序位于同一位置

00:11:19.529 --> 00:11:24.519
所以我们希望能够取消引用

00:11:22.120 --> 00:11:25.839
那个对象来查找并制作它

00:11:24.519 --> 00:11:27.850
可用于我们的代码，所以也许想

00:11:25.839 --> 00:11:29.649
查找数据源应用程序

00:11:27.850 --> 00:11:30.910
服务器将管理数据源

00:11:29.649 --> 00:11:32.949
它会管理连接池

00:11:30.910 --> 00:11:34.870
将为我们提供一切，我们想要

00:11:32.949 --> 00:11:37.089
在我们的春季托管代码中使用它

00:11:34.870 --> 00:11:39.430
谁想要在这里注入数据源

00:11:37.089 --> 00:11:43.420
我们可以使用工厂光束，所以我们

00:11:39.430 --> 00:11:45.930
实际上可以创建一个简迪工厂

00:11:43.420 --> 00:11:48.779
光束在物体工厂中的均值

00:11:45.930 --> 00:11:55.060
 Janie Hydrick拖拉机横梁像这样和

00:11:48.779 --> 00:11:56.589
简迪（Jane di fetch）工厂光束

00:11:55.060 --> 00:12:00.779
我们可以提供的很多参数

00:11:56.589 --> 00:12:03.370
对，所以设置您知道的设置

00:12:00.779 --> 00:12:05.290
简·迪（Jane di）将简命名为10，但如果您

00:12:03.370 --> 00:12:07.509
想要资源Ref他们期望的类型

00:12:05.290 --> 00:12:08.680
如果您想知道我们很多

00:12:07.509 --> 00:12:10.689
我们可以提供的不同的东西

00:12:08.680 --> 00:12:12.519
这里包括它的属性值

00:12:10.689 --> 00:12:13.990
我们可以用来参考简迪

00:12:12.519 --> 00:12:15.069
您知道要解决的环境

00:12:13.990 --> 00:12:17.290
首先是实际环境

00:12:15.069 --> 00:12:19.480
所有这些东西都有望成为

00:12:17.290 --> 00:12:22.360
提供，但最后一次全部

00:12:19.480 --> 00:12:29.170
一旦我们返回，那是 Spring 

00:12:22.360 --> 00:12:31.240
我们返回FB右Spring 将占据所有

00:12:29.170 --> 00:12:32.290
这些变量考虑到工厂

00:12:31.240 --> 00:12:36.009
将所有这些变量纳入

00:12:32.290 --> 00:12:40.059
帐户，然后在获取中使用它们

00:12:36.009 --> 00:12:42.160
这里的对象方法，所以获取对象

00:12:40.059 --> 00:12:43.360
返回此Jane di对象中的哪个

00:12:42.160 --> 00:12:46.149
当然是那个对象

00:12:43.360 --> 00:12:48.070
在之后寻找你

00:12:46.149 --> 00:12:49.600
有人说属性方法，所以他

00:12:48.070 --> 00:12:51.579
说珍妮·海德里克挠着简的

00:12:49.600 --> 00:12:54.459
对象部分ridge工厂有点

00:12:51.579 --> 00:12:56.170
伟大的简对象部分C等等等

00:12:54.459 --> 00:12:58.990
对，所以否则我们正在寻找它

00:12:56.170 --> 00:13:01.209
因此， 

00:12:58.990 --> 00:13:03.640
对象很复杂，但我们不在乎

00:13:01.209 --> 00:13:05.019
因为我们需要知道的是

00:13:03.640 --> 00:13:06.550
我们将有一个数据源

00:13:05.019 --> 00:13:08.410
正确的类型将为我们管理

00:13:06.550 --> 00:13:10.180
好的，所以我们可以在 Spring 时冲刺

00:13:08.410 --> 00:13:12.370
运行它实际上并不会

00:13:10.180 --> 00:13:14.079
实际上管理这个工厂光束

00:13:12.370 --> 00:13:15.579
它要管理的产品

00:13:14.079 --> 00:13:17.620
在这种情况下，工厂主要是

00:13:15.579 --> 00:13:21.040
工厂光束将成为

00:13:17.620 --> 00:13:22.600
通过调用返回

00:13:21.040 --> 00:13:25.029
詹迪这样的背景，但要抬头

00:13:22.600 --> 00:13:28.140
什么是花花公子一个回退回退我们

00:13:25.029 --> 00:13:30.490
有一个被返回的对象， 

00:13:28.140 --> 00:13:32.230
在这种情况下对象的类型

00:13:30.490 --> 00:13:35.980
只是撒谎而已

00:13:32.230 --> 00:13:37.750
 Spring 喜欢知道你知道喜欢

00:13:35.980 --> 00:13:40.329
知道如果可以转换为什么类型

00:13:37.750 --> 00:13:42.610
必要的，例如，它提供了

00:13:40.329 --> 00:13:44.290
回调接口在这里合同

00:13:42.610 --> 00:13:46.510
工厂是一种方法

00:13:44.290 --> 00:13:48.519
此处称为获取对象类型的接口

00:13:46.510 --> 00:13:49.870
你应该返回的类型

00:13:48.519 --> 00:13:53.529
返回的对象，以便

00:13:49.870 --> 00:13:54.790
 Spring 可以做你之前知道的验证

00:13:53.529 --> 00:13:56.290
应用程序启动它想要

00:13:54.790 --> 00:13:57.760
验证是否存在一个对象

00:13:56.290 --> 00:14:00.730
上下文中的某种类型

00:13:57.760 --> 00:14:02.050
看到有关数据源的参考

00:14:00.730 --> 00:14:04.089
一些组件代码需要

00:14:02.050 --> 00:14:05.680
注射它不知道从哪里得到

00:14:04.089 --> 00:14:06.940
但是它只是想证明还是想要

00:14:05.680 --> 00:14:09.040
知道里面有什么

00:14:06.940 --> 00:14:10.600
最终会导致

00:14:09.040 --> 00:14:12.220
这种类型的光束和事实

00:14:10.600 --> 00:14:13.930
最终结果是

00:14:12.220 --> 00:14:17.050
这种类型的，因此通过回调

00:14:13.930 --> 00:14:19.180
方法，我们可以避免强迫Spring 

00:14:17.050 --> 00:14:20.980
你知道积极实例化和

00:14:19.180 --> 00:14:22.630
早于数据源

00:14:20.980 --> 00:14:23.920
需要，所以让我们做一个非常简单的

00:14:22.630 --> 00:14:29.260
例如，假设我们要创建

00:14:23.920 --> 00:14:32.500
一个公共的静态类foo，我们将采取

00:14:29.260 --> 00:14:35.949
会创建一个公共静态变量

00:14:32.500 --> 00:14:39.459
 foo类工厂

00:14:35.949 --> 00:14:41.709
 Bean实现工厂类型

00:14:39.459 --> 00:14:44.260
 foo，我们将创建自己的非常非常

00:14:41.709 --> 00:14:46.180
简单的foo好，所以这里的想法是

00:14:44.260 --> 00:14:48.250
有复杂的初始化要隐藏

00:14:46.180 --> 00:14:50.740
逻辑，也许我有，也许foo是

00:14:48.250 --> 00:14:56.509
在这种情况下实际上是一个接口

00:14:50.740 --> 00:15:01.949
我们有公共静态类foo一

00:14:56.509 --> 00:15:04.410
公共静态食品-当然

00:15:01.949 --> 00:15:06.839
这不必是静态的， 

00:15:04.410 --> 00:15:08.339
也许以我为例

00:15:06.839 --> 00:15:11.100
 bean 我想有一个布尔值说

00:15:08.339 --> 00:15:14.699
更喜欢一项权利，所以我会说那是

00:15:11.100 --> 00:15:15.660
默认情况下会是真的，但是

00:15:14.699 --> 00:15:18.930
可能是别的东西

00:15:15.660 --> 00:15:20.160
好吧，我们那里的塞特犬，我们知道

00:15:18.930 --> 00:15:21.779
那个物体不管什么类型

00:15:20.160 --> 00:15:24.569
将会是foo类型，所以我们可以知道

00:15:21.779 --> 00:15:26.309
关于那个 Spring ，哦，抱歉，我们可以告诉

00:15:24.569 --> 00:15:30.720
关于这里和对象的 Spring 

00:15:26.309 --> 00:15:32.040
类型方法，我们知道它将是我们

00:15:30.720 --> 00:15:33.449
知道这可能是一个依赖

00:15:32.040 --> 00:15:35.399
我们可以拥有多个范围的东西

00:15:33.449 --> 00:15:36.839
在应用程序上下文中，所以我只是

00:15:35.399 --> 00:15:38.670
喜欢默认保留为false，但是

00:15:36.839 --> 00:15:40.079
我想你没有理由

00:15:38.670 --> 00:15:41.339
绝对确定永远不会

00:15:40.079 --> 00:15:43.259
将不止一个

00:15:41.339 --> 00:15:44.519
说那是不对的

00:15:43.259 --> 00:15:46.559
只是一个建议，有一些

00:15:44.519 --> 00:15:49.589
这些情况下，Spring 将超越

00:15:46.559 --> 00:15:51.930
那种有价值的行为，所以要坚持下去

00:15:49.589 --> 00:15:53.339
现在，让我们在这里创建傻瓜

00:15:51.930 --> 00:15:56.069
我们会说返回这种类型更喜欢

00:15:53.339 --> 00:16:02.370
 foo一个或更喜欢一个（如果是这样） 

00:15:56.069 --> 00:16:06.689
新foo一个否则是新傻瓜-好的

00:16:02.370 --> 00:16:08.430
我们正在创建一个不同的对象

00:16:06.689 --> 00:16:13.410
基于配置，所以这不是

00:16:08.430 --> 00:16:14.519
与变体相同

00:16:13.410 --> 00:16:16.860
对象中的构造

00:16:14.519 --> 00:16:18.569
现在可以自己建造

00:16:16.860 --> 00:16:20.910
实际上只是在上面添加了一个组件

00:16:18.569 --> 00:16:22.079
这个，但是记住你会用这个

00:16:20.910 --> 00:16:25.620
事实不止一次

00:16:22.079 --> 00:16:34.100
所以我会说在正式工厂

00:16:25.620 --> 00:16:37.649
 bean foo返回新的foo工厂bean 

00:16:34.100 --> 00:16:43.589
我们在那里，我会得到的食物

00:16:37.649 --> 00:16:45.629
默认情况下，这是第一个

00:16:43.589 --> 00:16:47.519
一对食物我可以改变

00:16:45.629 --> 00:16:48.959
没错，所以我要做的是

00:16:47.519 --> 00:16:50.370
我正在创建一个工厂 bean Spring 

00:16:48.959 --> 00:16:52.199
不在乎这个对象

00:16:50.370 --> 00:16:53.850
不知道看到的工厂

00:16:52.199 --> 00:16:55.769
工厂的商品是这个

00:16:53.850 --> 00:16:57.540
这在这里很常见

00:16:55.769 --> 00:16:59.040
在他复杂的地方之前

00:16:57.540 --> 00:17:00.420
初始化和唯一的方法

00:16:59.040 --> 00:17:03.629
在 Spring 创建这些对象是为了

00:17:00.420 --> 00:17:05.159
现在使用XML当然我们有Java 

00:17:03.629 --> 00:17:07.199
配置这些Java 

00:17:05.159 --> 00:17:08.640
配置方法非常非常

00:17:07.199 --> 00:17:09.720
多功能，您可以用Java做任何事情

00:17:08.640 --> 00:17:11.520
他们也想在这里

00:17:09.720 --> 00:17:13.830
到达了物体，所以没有

00:17:11.520 --> 00:17:16.500
真的有一个没有真正真实的理由

00:17:13.830 --> 00:17:17.760
我有这个额外适配器的原因

00:17:16.500 --> 00:17:19.530
这是一个很好的盘子，这是一个好主意

00:17:17.760 --> 00:17:21.120
编纂的好地方

00:17:19.530 --> 00:17:23.130
建设权建设是一个

00:17:21.120 --> 00:17:25.700
这样做很有趣，这是

00:17:23.130 --> 00:17:28.110
工厂模式的实现

00:17:25.700 --> 00:17:31.050
但这是我非常重要的一件事

00:17:28.110 --> 00:17:32.760
不会特别推荐新的

00:17:31.050 --> 00:17:35.370
代码，如果您使用的是Java配置

00:17:32.760 --> 00:17:37.050
您可以摆脱创建

00:17:35.370 --> 00:17:39.780
 Java config方法中的对象

00:17:37.050 --> 00:17:41.520
本身或使用构建器或自定义

00:17:39.780 --> 00:17:42.720
对象的权利，你不是我们有自定义

00:17:41.520 --> 00:17:45.030
做很多艰苦工作的对象

00:17:42.720 --> 00:17:51.530
为您服务，所以您可以说返回新的jndi 

00:17:45.030 --> 00:17:55.530
数据源查找印度ID数据，所以没有

00:17:51.530 --> 00:17:57.960
定位器委托查找，然后传递

00:17:55.530 --> 00:17:59.730
 Jan di字符串正确，所以您得到一个

00:17:57.960 --> 00:18:00.780
开箱即用的很多功能

00:17:59.730 --> 00:18:03.060
真的不需要工厂Beam 

00:18:00.780 --> 00:18:04.920
了，但是如果你看到它的话

00:18:03.060 --> 00:18:06.210
了解它在做什么很有用

00:18:04.920 --> 00:18:08.010
正确并了解如何使用

00:18:06.210 --> 00:18:10.080
里面有很多事实

00:18:08.010 --> 00:18:12.300
你在我的镜子里可以想象得到的 Spring 

00:18:10.080 --> 00:18:13.890
带有几个春季罐子的课堂路径

00:18:12.300 --> 00:18:15.660
在上课的路上，我已经拥有了所有这些

00:18:13.890 --> 00:18:18.600
不同的工厂 bean 让我

00:18:15.660 --> 00:18:21.210
创建事务的缓存和日期/时间

00:18:18.600 --> 00:18:22.680
以及JMX基础架构和服务以及

00:18:21.210 --> 00:18:25.710
线程池和任务执行程序以及

00:18:22.680 --> 00:18:27.450
 Yambol工厂和所有这些不同

00:18:25.710 --> 00:18:28.890
对的事情这些都是

00:18:27.450 --> 00:18:31.040
我有课垫，他们有

00:18:28.890 --> 00:18:36.210
永远都在这最后一节

00:18:31.040 --> 00:18:38.370
让我们来看看新事物

00:18:36.210 --> 00:18:39.990
 Spring Framework 中的一个不错的工具

00:18:38.370 --> 00:18:42.030
 4.3如果您正在使用Spring 

00:18:39.990 --> 00:18:44.070
引导1.4，它已经包含Spring 

00:18:42.030 --> 00:18:46.440
框架4.3相当新

00:18:44.070 --> 00:18:47.850
刚在今年早些时候问世

00:18:46.440 --> 00:18:50.610
包含一个不错的功能，称为注入

00:18:47.850 --> 00:18:53.340
这点非常受启发

00:18:50.610 --> 00:18:55.470
 CDI中具有相同名称的类，这样

00:18:53.340 --> 00:18:57.330
注射点非常有用

00:18:55.470 --> 00:18:59.130
如果您想让代码知道

00:18:57.330 --> 00:19:03.110
被注入的对象

00:18:59.130 --> 00:19:05.400
我很难想到

00:19:03.110 --> 00:19:07.050
除了那个以外的任何其他例子

00:19:05.400 --> 00:19:08.940
很明显地

00:19:07.050 --> 00:19:09.930
很常见的是

00:19:08.940 --> 00:19:11.640
记录器，所以我们要继续

00:19:09.930 --> 00:19:14.610
创建一个记录器，我们要说我想要

00:19:11.640 --> 00:19:16.920
创建一个记录器，我将使用

00:19:14.610 --> 00:19:21.450
在此处创建注入点类型

00:19:16.920 --> 00:19:23.030
知道其他类的记录器

00:19:21.450 --> 00:19:24.620
 int正在

00:19:23.030 --> 00:19:27.170
注入它，所以我会说注入点

00:19:24.620 --> 00:19:33.470
声明元素或着色

00:19:27.170 --> 00:19:33.920
输入获取名称，我宁愿获取成员

00:19:33.470 --> 00:19:39.770
演出

00:19:33.920 --> 00:19:42.770
声明班级名称可以，所以我已经

00:19:39.770 --> 00:19:45.320
他们提供了更大的啤酒，现在我可以

00:19:42.770 --> 00:19:46.070
创建一个需要它的组件

00:19:45.320 --> 00:19:47.540
当然我要有多个

00:19:46.070 --> 00:19:50.000
组件正确，我将拥有多个

00:19:47.540 --> 00:19:51.740
每个都有自己的组件

00:19:50.000 --> 00:19:53.930
对了，这就是我的重点

00:19:51.740 --> 00:19:55.670
想要一个日志或具有它的

00:19:53.930 --> 00:19:57.320
在这里所在的班级上重视

00:19:55.670 --> 00:19:58.460
存在否则我会拥有你

00:19:57.320 --> 00:20:01.880
知道否则我可以做旧的

00:19:58.460 --> 00:20:05.350
这样的方式记录组件，如果我做了

00:20:01.880 --> 00:20:11.360
旧的方式我会喜欢

00:20:05.350 --> 00:20:13.280
 logger.log或lager正确获得更大的啤酒，并且

00:20:11.360 --> 00:20:16.040
我只是说上课就行了

00:20:13.280 --> 00:20:17.660
当然，但是它最终变得越来越

00:20:16.040 --> 00:20:19.820
乏味的权利，所以在这种情况下，我要

00:20:17.660 --> 00:20:21.790
只是注入啤酒，现在我有

00:20:19.820 --> 00:20:23.960
它可以集中管理，我实际上可以

00:20:21.790 --> 00:20:26.390
一次更改配置

00:20:23.960 --> 00:20:27.650
影响所有如此配置的标签，但

00:20:26.390 --> 00:20:29.450
因为我可能有多个组成部分

00:20:27.650 --> 00:20:30.950
每个人都有自己的班级，我不想

00:20:29.450 --> 00:20:34.250
单身人士，这是行不通的，我想要

00:20:30.950 --> 00:20:35.360
使它成为原型

00:20:34.250 --> 00:20:37.300
我会做的，我会把它变成一个

00:20:35.360 --> 00:20:39.470
原型，您可以将其用于其他

00:20:37.300 --> 00:20:41.750
范围也可以说哦，我想

00:20:39.470 --> 00:20:43.520
进行会话雕刻或其他操作

00:20:41.750 --> 00:20:44.750
关键是它的原型很好

00:20:43.520 --> 00:20:47.120
足够便宜的东西

00:20:44.750 --> 00:20:48.890
很重要，所以我现在有了一个

00:20:47.120 --> 00:20:50.210
将被注射，我可以再次

00:20:48.890 --> 00:20:52.220
这增加了电线，但要记住另一个

00:20:50.210 --> 00:20:57.520
 4.3的好感觉是我不需要

00:20:52.220 --> 00:21:00.740
好的，所以我们只使用一个更大的问候

00:20:57.520 --> 00:21:03.650
世界悠久，现在我们可以开始了

00:21:00.740 --> 00:21:05.120
我们应该看到记录器记录为

00:21:03.650 --> 00:21:06.890
尽管它已在

00:21:05.120 --> 00:21:10.180
登录组件，这当然在

00:21:06.890 --> 00:21:12.170
定义Spring 内部的转弯

00:21:10.180 --> 00:21:15.380
应用程序，我们在那里

00:21:12.170 --> 00:21:16.580
你好，世界很好，这很酷

00:21:15.380 --> 00:21:17.870
功能我认为我认为这非常有用

00:21:16.580 --> 00:21:20.210
您会发现很多用途

00:21:17.870 --> 00:21:21.350
希望在您的代码中肯定是

00:21:20.210 --> 00:21:24.080
这不是延长寿命的唯一方法

00:21:21.350 --> 00:21:27.160
当我在Twitter上谈论这一点时， 

00:21:24.080 --> 00:21:30.980
在星巴克，有几个人回应

00:21:27.160 --> 00:21:32.600
在日志中提到高飞

00:21:30.980 --> 00:21:34.220
注释，这是时髦的语言

00:21:32.600 --> 00:21:36.050
本身有一个长度注释

00:21:34.220 --> 00:21:37.850
那和龙目岛

00:21:36.050 --> 00:21:39.620
大概是借用或至少是

00:21:37.850 --> 00:21:42.740
受Goo V的启发

00:21:39.620 --> 00:21:48.320
在4 J注释处也有一个SL 

00:21:42.740 --> 00:21:50.440
使用用户代码进行哪种编译

00:21:48.320 --> 00:21:54.500
时间或运行基本初始化时间

00:21:50.440 --> 00:21:55.610
插入或插入记录器的magic 2 

00:21:54.500 --> 00:21:58.160
可以与知名的

00:21:55.610 --> 00:21:59.690
变量类型，一切都很好， 

00:21:58.160 --> 00:22:01.700
好，我只是觉得这有点

00:21:59.690 --> 00:22:03.530
如果您使用Spring ，这很好

00:22:01.700 --> 00:22:05.030
您是否要删除这些公开的

00:22:03.530 --> 00:22:05.450
所有您的静态最终记录器

00:22:05.030 --> 00:22:07.820
码

00:22:05.450 --> 00:22:11.410
很好，非常感谢

00:22:07.820 --> 00:22:11.410
我非常希望你喜欢我会看到你结束

00:22:17.660 --> 00:22:19.720
您

