WEBVTT
Kind: captions
Language: zh-Hans

00:00:26.570 --> 00:00:30.869
嗨，春季粉丝们欢迎来到另一个

00:00:28.890 --> 00:00:32.400
在此安装弹簧提示

00:00:30.869 --> 00:00:33.630
一周的分期付款

00:00:32.400 --> 00:00:36.780
看看刚刚发生的事情

00:00:33.630 --> 00:00:39.020
发布了一个全新的东西，我们只是

00:00:36.780 --> 00:00:42.840
最近几天在

00:00:39.020 --> 00:00:46.050
好的老式IO博客

00:00:42.840 --> 00:00:53.610
值得信赖的尊敬的春天L博客

00:00:46.050 --> 00:00:56.460
是春季的新支撑

00:00:53.610 --> 00:01:00.570
匹配卡夫卡对的妈妈会

00:00:56.460 --> 00:01:02.519
 haseen传说中的春季批次之一

00:01:00.570 --> 00:01:05.700
团队成员刚刚宣布了这一点，而我

00:01:02.519 --> 00:01:07.860
猜猜大块的

00:01:05.700 --> 00:01:10.260
贡献来自社区

00:01:07.860 --> 00:01:13.860
我要去的Matthew Calais 

00:01:10.260 --> 00:01:15.180
猜猜，但哦，不，哦，哦，维也纳，我不

00:01:13.860 --> 00:01:16.950
知道我确定是法国人，我应该

00:01:15.180 --> 00:01:20.220
知道如何发音，但II不

00:01:16.950 --> 00:01:22.790
知道哪种方式谢谢你，所以

00:01:20.220 --> 00:01:26.640
关键是我们有了这个不错的新支持

00:01:22.790 --> 00:01:29.100
在春季比赛中与Kafka合作

00:01:26.640 --> 00:01:34.650
我刚从巴西回来时

00:01:29.100 --> 00:01:41.040
在巴西，假设您知道七个

00:01:34.650 --> 00:01:44.220
四五天前，现在是星期三

00:01:41.040 --> 00:01:45.930
就在这上升的时候，我在

00:01:44.220 --> 00:01:48.450
巴西不到一个星期前

00:01:45.930 --> 00:01:49.620
好吧，让我们说这是一个星期前

00:01:48.450 --> 00:01:51.690
我在巴西和很多人聊天

00:01:49.620 --> 00:01:53.160
巴西银行，他们正在使用春季

00:01:51.690 --> 00:01:55.290
批处理他们正在开始新项目， 

00:01:53.160 --> 00:01:57.530
我现在喜欢流媒体春季批

00:01:55.290 --> 00:02:00.210
处理我爱的消息我爱

00:01:57.530 --> 00:02:02.490
整合我喜欢所有这些东西

00:02:00.210 --> 00:02:05.100
与某种流有关

00:02:02.490 --> 00:02:07.560
工作负载和数据移动

00:02:05.100 --> 00:02:08.610
处理管道，但在末尾

00:02:07.560 --> 00:02:10.560
那天有一些事情

00:02:08.610 --> 00:02:11.760
自然地将它们借给我

00:02:10.560 --> 00:02:13.650
想到一个很多人的问题

00:02:11.760 --> 00:02:15.209
奋斗是我如何弥合这些

00:02:13.650 --> 00:02:17.879
我有两个宇宙

00:02:15.209 --> 00:02:19.830
天生有限，他们有时间限制

00:02:17.879 --> 00:02:23.640
他们开着窗户，无论我们做什么

00:02:19.830 --> 00:02:25.019
需要你所知道的一切

00:02:23.640 --> 00:02:27.450
您需要了解的任何东西

00:02:25.019 --> 00:02:30.060
了解他们是有限的

00:02:27.450 --> 00:02:31.409
可能有一些东西

00:02:30.060 --> 00:02:33.600
已处理，并且有报告

00:02:31.409 --> 00:02:35.280
派人去管理

00:02:33.600 --> 00:02:37.890
可以完成任何类型的分析

00:02:35.280 --> 00:02:38.700
对，所以这是很常见的事情

00:02:37.890 --> 00:02:40.739
我该怎么办

00:02:38.700 --> 00:02:43.290
带我的流处理管道

00:02:40.739 --> 00:02:45.420
这些正在产生数据的东西

00:02:43.290 --> 00:02:47.069
根据他们在线上的时间

00:02:45.420 --> 00:02:49.890
我们生活的交易世界

00:02:47.069 --> 00:02:53.060
我该如何将其转化为数据

00:02:49.890 --> 00:02:57.090
要做的当然是

00:02:53.060 --> 00:02:58.349
现在将其转发到春季批处理

00:02:57.090 --> 00:03:00.330
春天批次很棒，因为它可以

00:02:58.349 --> 00:03:03.000
处理大量数据并弹跳

00:03:00.330 --> 00:03:04.410
批处理中内置了很多东西

00:03:03.000 --> 00:03:07.110
只是让生活变得轻松很多

00:03:04.410 --> 00:03:08.250
我认为大多数人不是真的

00:03:07.110 --> 00:03:10.019
欣赏，直到他们喜欢

00:03:08.250 --> 00:03:11.910
授予春季批可以做什么，但

00:03:10.019 --> 00:03:14.280
例如春季批处理在

00:03:11.910 --> 00:03:16.290
背景，它有一个数据库

00:03:14.280 --> 00:03:18.870
元数据系统，那就是元数据

00:03:16.290 --> 00:03:21.360
系统存储在某个地方

00:03:18.870 --> 00:03:22.829
一个由

00:03:21.360 --> 00:03:26.250
默认将其存储在续集数据中

00:03:22.829 --> 00:03:28.950
存储的好处是

00:03:26.250 --> 00:03:31.920
春季批处理工作

00:03:28.950 --> 00:03:33.480
无论如何，领域模型是一项工作，由

00:03:31.920 --> 00:03:35.670
多个步骤，每个步骤描述

00:03:33.480 --> 00:03:41.099
如何阅读然后写作以及

00:03:35.670 --> 00:03:43.380
可选地，处理写入作业的数据

00:03:41.099 --> 00:03:45.540
它具有有关该状态的元数据

00:03:43.380 --> 00:03:47.579
执行该工作的工作

00:03:45.540 --> 00:03:49.980
保留在数据库中，所以如果

00:03:47.579 --> 00:03:52.049
想要的东西应该出问题了

00:03:49.980 --> 00:03:53.250
当你在现实中工作时发生

00:03:52.049 --> 00:03:56.459
正确的世界将会有数据

00:03:53.250 --> 00:03:59.010
有时编码失败

00:03:56.459 --> 00:04:02.010
或类似的东西，我看到我

00:03:59.010 --> 00:04:03.720
认为Holden Corral刚刚发了推文，或者

00:04:02.010 --> 00:04:05.609
转推或她观察到的内容

00:04:03.720 --> 00:04:07.230
或您知道哦，年龄2高音我

00:04:05.609 --> 00:04:08.220
不知道她刚刚发过推文

00:04:07.230 --> 00:04:14.850
我以为是真的

00:04:08.220 --> 00:04:16.709
有趣的是，如果我们所有的JSON都为um 

00:04:14.850 --> 00:04:18.479
我们需要所有JSON的架构

00:04:16.709 --> 00:04:23.460
我再次在这里释义，但如果我们

00:04:18.479 --> 00:04:24.599
需要一个JSON文件和一个架构文件

00:04:23.460 --> 00:04:26.220
我们所有的杰森，然后我们就不会

00:04:24.599 --> 00:04:27.840
基本上任何数据

00:04:26.220 --> 00:04:30.419
我不知道那是什么

00:04:27.840 --> 00:04:32.099
我可以玩我的意思是我可能有

00:04:30.419 --> 00:04:33.479
好让它脱离了上下文，这让我

00:04:32.099 --> 00:04:35.729
虽然笑，因为这是对的

00:04:33.479 --> 00:04:40.440
有一种巨大的

00:04:35.729 --> 00:04:42.330
数据的世界，我们需要

00:04:40.440 --> 00:04:44.479
尽我们所能写的，以及

00:04:42.330 --> 00:04:47.250
我就是这么认为的

00:04:44.479 --> 00:04:49.050
这些天工作已经完成

00:04:47.250 --> 00:04:55.440
只是规范那个家伙的东西

00:04:49.050 --> 00:04:56.940
对，所以我们要做什么

00:04:55.440 --> 00:05:00.330
从我们想要的现实世界中获取数据

00:04:56.940 --> 00:05:02.130
从路上拿走并处理它

00:05:00.330 --> 00:05:04.320
我想到的最简单的方法是

00:05:02.130 --> 00:05:06.150
春天批春施洗

00:05:04.320 --> 00:05:08.340
元数据系统出现问题

00:05:06.150 --> 00:05:10.170
如果您有病或在您身上无效

00:05:08.340 --> 00:05:12.870
知道无效的格式化数据可以

00:05:10.170 --> 00:05:13.530
作为操作员干预工作， 

00:05:12.870 --> 00:05:15.420
重新启动

00:05:13.530 --> 00:05:18.780
您还可以提供启发式

00:05:15.420 --> 00:05:20.550
如果我失败，可以说很好，你知道一些

00:05:18.780 --> 00:05:22.380
数据的百分比或一定数量的

00:05:20.550 --> 00:05:23.880
数据记录然后继续

00:05:22.380 --> 00:05:26.040
整个工作都失败了，但如果仅仅是

00:05:23.880 --> 00:05:29.850
小，你知道它是否是

00:05:26.040 --> 00:05:31.230
数据，那么你就知道不用打扰了

00:05:29.850 --> 00:05:33.090
不要为失败而烦恼

00:05:31.230 --> 00:05:34.940
只是忽略那些有效的记录

00:05:33.090 --> 00:05:38.040
大块的所以你有一个

00:05:34.940 --> 00:05:40.800
步骤和步骤处理他们读取数据

00:05:38.040 --> 00:05:44.300
也许你知道X的数量

00:05:40.800 --> 00:05:47.160
记录X的大小

00:05:44.300 --> 00:05:49.560
您可以负担得起的边界

00:05:47.160 --> 00:05:51.419
记忆在同一时间和失去

00:05:49.560 --> 00:05:52.770
可能正确，因为如果您输了一个

00:05:51.419 --> 00:05:56.730
记录在块中，然后记录整个块

00:05:52.770 --> 00:05:59.610
它可能会丢失，所以块是

00:05:56.730 --> 00:06:01.980
这也是你的表现单位

00:05:59.610 --> 00:06:04.229
知道我要写多少条记录

00:06:01.980 --> 00:06:06.660
到交易中的下游事物

00:06:04.229 --> 00:06:08.570
现在逻辑交易，如果不是实际的

00:06:06.660 --> 00:06:12.030
所谓的交易权

00:06:08.570 --> 00:06:13.320
所以你知道我不想复习所有

00:06:12.030 --> 00:06:15.930
我们已经完成了春季批处理

00:06:13.320 --> 00:06:17.370
实际上是较早的 spring 技巧 之一

00:06:15.930 --> 00:06:19.680
我做过比较受欢迎的影片之一

00:06:17.370 --> 00:06:21.720
确实是一个春天的提示， 

00:06:19.680 --> 00:06:23.370
看着春天的101批春

00:06:21.720 --> 00:06:25.669
回到基础101我认为是

00:06:23.370 --> 00:06:30.090
有趣的是这种可能性

00:06:25.669 --> 00:06:32.010
通过消息将批处理桥接

00:06:30.090 --> 00:06:33.270
使用这个新的Kafka支持

00:06:32.010 --> 00:06:34.470
那就是我们今天要做的朋友

00:06:33.270 --> 00:06:37.440
我们要看看这个

00:06:34.470 --> 00:06:39.000
我们可以从中获得非常酷的东西

00:06:37.440 --> 00:06:41.340
春天的初始化器，我们当然可以

00:06:39.000 --> 00:06:43.500
像往常一样建立新项目

00:06:41.340 --> 00:06:45.600
将是这个已经可用了吗

00:06:43.500 --> 00:06:49.320
该Kafka支持将可用

00:06:45.600 --> 00:06:51.510
在 spring boot 2.2立方米的时候

00:06:49.320 --> 00:06:53.760
出去，与此同时它可用

00:06:51.510 --> 00:06:56.729
在快照中，所以它是一个

00:06:53.760 --> 00:06:59.580
回去那200平方米，我

00:06:56.729 --> 00:07:01.050
将要使用 spring boot 纹身

00:06:59.580 --> 00:07:05.970
哦，快照哪个实习生

00:07:01.050 --> 00:07:09.150
拉入弹簧批4.20平方米好

00:07:05.970 --> 00:07:11.400
我只是叫这批BK卡夫卡

00:07:09.150 --> 00:07:13.259
好吧，我们要带卡夫卡

00:07:11.400 --> 00:07:15.210
依赖和Spring批处理

00:07:13.259 --> 00:07:18.120
依赖和h2现在我们又不是

00:07:15.210 --> 00:07:19.860
除了春天，在这里用JDBC做任何事情

00:07:18.120 --> 00:07:22.289
批处理需要保留其元数据

00:07:19.860 --> 00:07:24.169
在某处我会给它一个内存数据

00:07:22.289 --> 00:07:27.930
你可以把它指向的商店

00:07:24.169 --> 00:07:29.370
几乎任何现代的续集JDBC 

00:07:27.930 --> 00:07:32.370
数据存储，它将做正确的事

00:07:29.370 --> 00:07:34.080
但我只想快速重新朗诵

00:07:32.370 --> 00:07:41.780
循环，所以让我们继续并生成一个

00:07:34.080 --> 00:07:41.780
我们在这里打开这个项目

00:07:47.900 --> 00:07:51.140
好吧

00:07:54.680 --> 00:07:58.259
所以我们需要配置一些东西

00:07:57.240 --> 00:08:05.340
想要先解决这个问题

00:07:58.259 --> 00:08:06.360
因为还早，你知道

00:08:05.340 --> 00:08:08.550
对于这个项目，我还早

00:08:06.360 --> 00:08:10.860
也许可以记住它，但是如果我

00:08:08.550 --> 00:08:12.870
把它，但我可能会得到我可能

00:08:10.860 --> 00:08:13.889
后来遇到奇怪的错误，所以我们

00:08:12.870 --> 00:08:16.650
需要几件事，这些只是

00:08:13.889 --> 00:08:18.150
常规 spring boot 和卡夫卡弹簧

00:08:16.650 --> 00:08:18.810
支持属性就没有了

00:08:18.150 --> 00:08:23.129
特别在这里

00:08:18.810 --> 00:08:24.930
所以我们希望消费者财产可以

00:08:23.129 --> 00:08:27.199
我们要传播我们要工作

00:08:24.930 --> 00:08:29.460
首先在我们的代码中添加数据

00:08:27.199 --> 00:08:32.419
我们不创建实体或对象

00:08:29.460 --> 00:08:41.060
或称为猜测客户的详细信息

00:08:32.419 --> 00:08:42.930
摆脱所有的问题，这样客户

00:08:41.060 --> 00:08:48.300
那将是我们的事， 

00:08:42.930 --> 00:08:50.910
客户将在这里有一个领域

00:08:48.300 --> 00:08:54.240
有一个ID，并将有一个名为

00:08:50.910 --> 00:08:56.790
字符串名称，您知道我的想法

00:08:54.240 --> 00:08:58.079
忘了带上我忘了的游戏

00:08:56.790 --> 00:09:00.149
带上龙目岛，所以我会继续

00:08:58.079 --> 00:09:01.440
只需手动添加即可，我将使用Java 

00:09:00.149 --> 00:09:03.269
莱文我应该做的我应该做的

00:09:01.440 --> 00:09:05.640
已经在

00:09:03.269 --> 00:09:08.010
初始化器，但幸运的是，这是

00:09:05.640 --> 00:09:09.360
即使在账单中也只是微不足道的，因为

00:09:08.010 --> 00:09:11.760
所有的do依赖项都被管理

00:09:09.360 --> 00:09:13.890
我们，所以我并没有付出很多

00:09:11.760 --> 00:09:15.570
不读，没有不菲的代价

00:09:13.890 --> 00:09:17.579
我知道这里的复杂性

00:09:15.570 --> 00:09:19.199
 goop ID和工件

00:09:17.579 --> 00:09:20.970
版本，所有排除项目和所有

00:09:19.199 --> 00:09:24.089
这些东西已经是强制性的了

00:09:20.970 --> 00:09:25.949
 spring boot 好吧，那我们该怎么办

00:09:24.089 --> 00:09:29.579
会有一个消费者，你可以看到

00:09:25.949 --> 00:09:32.930
我们的实体将使用您知道

00:09:29.579 --> 00:09:36.120
龙目岛给我们的所有东西

00:09:32.930 --> 00:09:38.310
生成一些构造函数的构造函数

00:09:36.120 --> 00:09:40.880
而且你知道字符串等于哈希码

00:09:38.310 --> 00:09:44.850
等等等等，现在我们知道了

00:09:40.880 --> 00:09:48.140
我们需要，因为它是卡夫卡，我们需要

00:09:44.850 --> 00:09:51.570
指定密钥D序列化器

00:09:48.140 --> 00:09:55.500
好吧，我想用久

00:09:51.570 --> 00:09:59.300
反序列化ER，因为我们的ID已获得

00:09:55.500 --> 00:10:02.820
沿着右边，这是这里

00:09:59.300 --> 00:10:04.820
一遍又一遍我应该

00:10:02.820 --> 00:10:09.150
并且可能应该在

00:10:04.820 --> 00:10:10.620
只是卡夫卡在春天，我已经完成了

00:10:09.150 --> 00:10:12.180
你看过我的话题

00:10:10.620 --> 00:10:14.520
春天的云流他们见过我说话

00:10:12.180 --> 00:10:16.050
关于um​​ spring代码流Kafka 

00:10:14.520 --> 00:10:18.170
溪流特别是春云

00:10:16.050 --> 00:10:21.300
流适用于RabbitMQ或Kafka或

00:10:18.170 --> 00:10:24.720
您知道Amazon Kinesis或Google的ABS 

00:10:21.300 --> 00:10:27.210
云发布/订阅或其他任何东西，但是就像

00:10:24.720 --> 00:10:29.070
轻松与Spring Cloud Stream一起使用

00:10:27.210 --> 00:10:31.140
和卡夫卡，但我也确实想要一个

00:10:29.070 --> 00:10:36.150
春季云流卡夫卡流

00:10:31.140 --> 00:10:39.620
很有趣嗯好的好的

00:10:36.150 --> 00:10:42.750
现在我们想要的是价值

00:10:39.620 --> 00:10:44.660
反序列化，所以我要说不

00:10:42.750 --> 00:10:48.840
你以后你会看到

00:10:44.660 --> 00:10:52.700
确保不要误拼两次

00:10:48.840 --> 00:10:55.650
我将使用JSON反序列化器

00:10:52.700 --> 00:10:59.690
对我来说这是一个春季项目

00:10:55.650 --> 00:11:04.050
这里不是这个

00:10:59.690 --> 00:11:09.740
那里你还好，所以我有这个副本

00:11:04.050 --> 00:11:14.160
参考还可以

00:11:09.740 --> 00:11:16.820
嗯，当我们给它一个树冠ID和

00:11:14.160 --> 00:11:29.010
实际上，所以我要称呼它

00:11:16.820 --> 00:11:35.520
客户群商品，生产者将

00:11:29.010 --> 00:11:37.050
是他序列化不会很长

00:11:35.520 --> 00:11:39.510
消毒器，所以我会很长一段时间

00:11:37.050 --> 00:11:41.760
消毒器以及同样的想法我

00:11:39.510 --> 00:11:43.380
只是想拥有一件会

00:11:41.760 --> 00:11:45.720
处理密钥的持久性

00:11:43.380 --> 00:11:49.080
卡夫卡咖啡，但这种概念

00:11:45.720 --> 00:11:51.120
消息和消息具有密钥，然后

00:11:49.080 --> 00:11:52.740
身体，身体就是价值，现在

00:11:51.120 --> 00:11:55.140
你有这个的原因

00:11:52.740 --> 00:11:57.240
钥匙的概念是因为事实

00:11:55.140 --> 00:11:58.800
真的，你不是在和一个

00:11:57.240 --> 00:12:01.860
消息队列您正在处理的内容

00:11:58.800 --> 00:12:03.690
是仅追加日志，是数据存储

00:12:01.860 --> 00:12:05.730
因此，这使您可以

00:12:03.690 --> 00:12:07.320
用春云流咳

00:12:05.730 --> 00:12:10.020
流做一些很有趣的事情

00:12:07.320 --> 00:12:13.030
治咳嗽之类的东西

00:12:10.020 --> 00:12:14.050
数据库权限和

00:12:13.030 --> 00:12:19.060
效果是您必须

00:12:14.050 --> 00:12:21.990
基本上考虑好钥匙

00:12:19.060 --> 00:12:23.890
没什么大不了的，我们可以处理

00:12:21.990 --> 00:12:25.840
不知道我们能否应付更多

00:12:23.890 --> 00:12:26.200
但期待我能正确处理

00:12:25.840 --> 00:12:31.110
对

00:12:26.200 --> 00:12:38.610
有你的激光，我们想要

00:12:31.110 --> 00:12:44.230
客户ID为什么是这样，请是

00:12:38.610 --> 00:12:46.870
好吧，一件事将是

00:12:44.230 --> 00:12:49.330
问题是它会问我们

00:12:46.870 --> 00:12:50.620
解码我们要的数据

00:12:49.330 --> 00:12:52.630
要写两个程序，他们

00:12:50.620 --> 00:12:55.060
将数据从一个节点发送到另一个

00:12:52.630 --> 00:12:56.860
我们要经过卡夫卡等等

00:12:55.060 --> 00:12:59.110
另一个因为数据突然弹出

00:12:56.860 --> 00:13:00.760
方面，我们必须将其反序列化很多

00:12:59.110 --> 00:13:02.440
我们将使用杰克逊

00:13:00.760 --> 00:13:04.030
默认情况下不只是

00:13:02.440 --> 00:13:07.420
反序列化任意对象

00:13:04.030 --> 00:13:10.710
告诉它基本放松和方式

00:13:07.420 --> 00:13:16.150
您使用受信任的程序包来执行此操作

00:13:10.710 --> 00:13:21.810
卡夫卡的消费属性是春天

00:13:16.150 --> 00:13:27.880
 json受信任的软件包等于星号

00:13:21.810 --> 00:13:30.910
打包好的包装

00:13:27.880 --> 00:13:37.330
终于我们要发送信息了

00:13:30.910 --> 00:13:40.540
到Kafka主题，因为它是

00:13:37.330 --> 00:13:42.520
他们说提示你需要全部卡夫卡的方式

00:13:40.540 --> 00:13:44.380
正确，我们要指定默认值

00:13:42.520 --> 00:13:45.850
一个卡夫卡模板好吧

00:13:44.380 --> 00:13:46.930
这是双方共同的一切

00:13:45.850 --> 00:13:50.650
生产者和消费者

00:13:46.930 --> 00:13:52.600
现在让我们分解这些例子

00:13:50.650 --> 00:13:54.280
我们将创建一个生产者

00:13:52.600 --> 00:13:56.460
春天的应用

00:13:54.280 --> 00:13:58.660
批处理应用程序只是从

00:13:56.460 --> 00:13:59.920
好吧，实际上我要合成一些

00:13:58.660 --> 00:14:02.560
数据只会是一件事情

00:13:59.920 --> 00:14:03.850
只是将数据注入Kafka，然后

00:14:02.560 --> 00:14:05.620
会有其他事情发生

00:14:03.850 --> 00:14:06.850
读取器端读取数据

00:14:05.620 --> 00:14:08.410
排队并将其写入其他内容

00:14:06.850 --> 00:14:10.810
我不想真正进入

00:14:08.410 --> 00:14:14.440
配置您知道文件的业务

00:14:10.810 --> 00:14:17.140
入站，您知道文件项读取器，并且

00:14:14.440 --> 00:14:18.220
或平面文件项目阅读器和Mongo项目

00:14:17.140 --> 00:14:20.320
作家之类的东西，所以我

00:14:18.220 --> 00:14:21.730
只是为了那些没有的东西

00:14:20.320 --> 00:14:24.460
与卡夫卡有关

00:14:21.730 --> 00:14:26.980
您是否知道我们的不变式

00:14:24.460 --> 00:14:28.570
演示，我只是提供假人

00:14:26.980 --> 00:14:31.390
接口的实现为

00:14:28.570 --> 00:14:34.900
预期，我们将主要关注

00:14:31.390 --> 00:14:36.370
卡夫卡制作人怎么办

00:14:34.900 --> 00:14:38.860
应用程序这将是事情

00:14:36.370 --> 00:14:40.330
我们将数据泵入Kafka 

00:14:38.860 --> 00:14:42.280
经纪人，这将是一个春季批

00:14:40.330 --> 00:14:44.170
应用程序和您拥有的第一件事

00:14:42.280 --> 00:14:45.610
当然要安装

00:14:44.170 --> 00:14:49.300
除了摇摆之外还有些东西

00:14:45.610 --> 00:14:52.530
批处理和春季引导宁可如此工作

00:14:49.300 --> 00:14:52.530
让我们做到这一点，让我们得到另一种方式

00:14:53.700 --> 00:15:18.030
好吧，我们现在有了这个，我们现在有了

00:15:04.330 --> 00:15:18.030
所以这个春天的应用程序运行正常

00:15:18.900 --> 00:15:23.920
好吧，现在有一个

00:15:21.820 --> 00:15:26.320
我们需要告诉的春季徽章申请

00:15:23.920 --> 00:15:30.100
 spring boot 继续前进，并创建一个

00:15:26.320 --> 00:15:31.600
春季批作业存储库和启动器

00:15:30.100 --> 00:15:32.980
和所有的东西，为了

00:15:31.600 --> 00:15:35.140
发生，我们需要在启用批量时说

00:15:32.980 --> 00:15:36.700
处理，这是困难的部分

00:15:35.140 --> 00:15:38.800
对，这是我们要做的大部分事情

00:15:36.700 --> 00:15:40.080
使春季批工作唯一

00:15:38.800 --> 00:15:42.580
然后，我们需要提供一个

00:15:40.080 --> 00:15:45.040
工作的定义和工作需要

00:15:42.580 --> 00:15:46.630
有一些步骤，你知道的一切

00:15:45.040 --> 00:15:49.360
东西，所以我们要

00:15:46.630 --> 00:15:52.930
创建一个将读取数据的作家

00:15:49.360 --> 00:15:57.970
从这个任意的只是变种

00:15:52.930 --> 00:16:03.010
虚拟读者好吧，所以我们不想我们

00:15:57.970 --> 00:16:07.480
想要一个可以正常工作的光束

00:16:03.010 --> 00:16:10.060
为了创建光束，我们要

00:16:07.480 --> 00:16:16.080
注入一些我们需要的东西

00:16:10.060 --> 00:16:20.410
至少其中一个是工作建设者工厂

00:16:16.080 --> 00:16:22.750
好吧，离工厂又一步了，所以我

00:16:20.410 --> 00:16:24.250
倾向于将这些带入每个

00:16:22.750 --> 00:16:28.480
这些天我构建的春季批处理应用程序

00:16:24.250 --> 00:16:30.070
他们只是帮忙，我要注入

00:16:28.480 --> 00:16:31.450
这些进入我的构造函数里面

00:16:30.070 --> 00:16:33.160
这是我的主要应用

00:16:31.450 --> 00:16:34.210
我们将要使用的配置类

00:16:33.160 --> 00:16:35.350
将它们注入构造函数中，但是

00:16:34.210 --> 00:16:37.540
而不是写构造函数

00:16:35.350 --> 00:16:41.190
我将使用必需的圆弧构造函数

00:16:37.540 --> 00:16:46.780
我们会做的很好，所以这个点

00:16:41.190 --> 00:16:49.390
工作建立一个工厂点得到我没有的工作

00:16:46.780 --> 00:16:54.960
知道什么工作让我不给

00:16:49.390 --> 00:16:59.560
那不是好工作

00:16:54.960 --> 00:17:03.670
工作，但QuickTime确实拖了这个

00:16:59.560 --> 00:17:05.709
电脑掉下来好吧，然后进一步

00:17:03.670 --> 00:17:09.610
我们要走一步，我们会回来

00:17:05.709 --> 00:17:16.040
很快就达到了这个定义

00:17:09.610 --> 00:17:23.720
一步好回到你身边

00:17:16.040 --> 00:17:25.880
但是开始是可以的，我们会

00:17:23.720 --> 00:17:29.390
增加一个新的一个ID 

00:17:25.880 --> 00:17:31.420
增量器只需创建一个新的唯一ID 

00:17:29.390 --> 00:17:33.680
工作本身，所以如果我需要

00:17:31.420 --> 00:17:36.050
指向一个特定的人说我们

00:17:33.680 --> 00:17:37.310
开始那个我有一个就是那个

00:17:36.050 --> 00:17:41.060
可以完成这项工作的参数

00:17:37.310 --> 00:17:43.730
含义独特，很好，所以我们已经

00:17:41.060 --> 00:17:45.680
现在只需一步就可以完成基本工作

00:17:43.730 --> 00:17:47.960
正如我在步骤之前所说的那样

00:17:45.680 --> 00:17:52.250
了解读者作家的三件事

00:17:47.960 --> 00:17:54.710
处理器，所以我们要做的就是

00:17:52.250 --> 00:17:59.690
使用步骤构建的东西

00:17:54.710 --> 00:18:04.040
工厂-你知道那是一个

00:17:59.690 --> 00:18:06.770
那一转大块说十

00:18:04.040 --> 00:18:09.350
一次记录并为了

00:18:06.770 --> 00:18:12.170
我们将要读写数据

00:18:09.350 --> 00:18:17.560
客户类型还可以

00:18:12.170 --> 00:18:17.560
甚至不要从我们的DTL和

00:18:18.040 --> 00:18:25.340
我们将要读取数据，所以我们来

00:18:22.730 --> 00:18:29.300
回到一秒钟，但足够了

00:18:25.340 --> 00:18:33.490
说这将是一个非常不变的

00:18:29.300 --> 00:18:41.060
所以领导者等于新项目领导者

00:18:33.490 --> 00:18:45.400
没什么特别的，我在这里实体类型

00:18:41.060 --> 00:18:45.400
顾客还可以

00:18:46.190 --> 00:18:52.980
读，没关系，所以有一点

00:18:50.460 --> 00:19:00.900
读者，我们将在

00:18:52.980 --> 00:19:01.919
其次是作家和作品

00:19:00.900 --> 00:19:04.500
作家我想做的是

00:19:01.919 --> 00:19:05.880
用卡夫卡吧，所以这是

00:19:04.500 --> 00:19:10.190
橡胶遇上了这条路

00:19:05.880 --> 00:19:17.309
分开的光束，我们只说一声

00:19:10.190 --> 00:19:20.730
卡夫卡项目作家管理实体

00:19:17.309 --> 00:19:22.220
唇型长按键型

00:19:20.730 --> 00:19:30.750
顾客

00:19:22.220 --> 00:19:36.679
 Kafka项目市长好吧好吧，我们

00:19:30.750 --> 00:19:39.690
再过一遍再说

00:19:36.679 --> 00:19:41.100
好吧，这是我们的基本要求

00:19:39.690 --> 00:19:42.240
我们将在这里使用一个生成器

00:19:41.100 --> 00:19:47.039
必须做很多工作才能做到这一点

00:19:42.240 --> 00:19:48.659
工作卡夫卡项目作家点想要

00:19:47.039 --> 00:19:54.990
建设者假人这么咳嗽的作家

00:19:48.659 --> 00:19:57.120
构建器构建Kafka模板将注入

00:19:54.990 --> 00:19:59.370
 Kafka模板在

00:19:57.120 --> 00:20:01.860
同样的方式 spring boot 会

00:19:59.370 --> 00:20:11.730
自动配置该对象

00:20:01.860 --> 00:20:17.340
对我们来说基于汽车

00:20:11.730 --> 00:20:19.580
配置，所以我们真的需要获取

00:20:17.340 --> 00:20:19.580
那

00:20:20.950 --> 00:20:27.170
好吧，我们已经有了它，我想我们

00:20:25.880 --> 00:20:29.390
已经注入了代码，不是吗

00:20:27.170 --> 00:20:32.750
知道应该没问题，我将其注入

00:20:29.390 --> 00:20:35.450
这里而不是晴天会使

00:20:32.750 --> 00:20:38.230
参数列表在那里，我为什么不

00:20:35.450 --> 00:20:40.340
大概再用一次

00:20:38.230 --> 00:20:41.690
它抱怨它不是，它不能

00:20:40.340 --> 00:20:44.090
按类型查找它，但这是IntelliJ 

00:20:41.690 --> 00:20:48.380
踩踏而不是实际的状态

00:20:44.090 --> 00:20:51.710
这个世界我还有什么要说的

00:20:48.380 --> 00:20:53.540
如何把一个物体变成一个

00:20:51.710 --> 00:20:55.430
它可以发送以执行的操作

00:20:53.540 --> 00:20:56.570
那，你只有一把钥匙，所以我

00:20:55.430 --> 00:20:59.600
告诉它如何转换

00:20:56.570 --> 00:21:05.600
客户成为客户的关键

00:20:59.600 --> 00:21:08.500
如果我们正确的对象是

00:21:05.600 --> 00:21:08.500
新客户

00:21:09.730 --> 00:21:19.420
好吧，所以客户的转换器很久了

00:21:21.130 --> 00:21:35.990
你去那里卡夫卡项目作家的钥匙

00:21:29.020 --> 00:21:44.920
然后值好吧好吧所以

00:21:35.990 --> 00:21:44.920
客户点获取ID正确

00:21:49.300 --> 00:21:53.450
似乎很简单，我想我可以

00:21:51.530 --> 00:21:58.940
我想我能做到

00:21:53.450 --> 00:22:00.290
应该可行，我们已经有了主题

00:21:58.940 --> 00:22:03.080
指定主题，所以我们唯一要做的就是

00:22:00.290 --> 00:22:03.920
现在需要的是我们的读者是真的我

00:22:03.080 --> 00:22:07.450
认为这很公平

00:22:03.920 --> 00:22:07.450
公鸡项目对

00:22:07.460 --> 00:22:13.970
最后是我们的读者现在是读者

00:22:11.930 --> 00:22:18.290
这件事要做的就是

00:22:13.970 --> 00:22:22.250
使用原子创建一个新的唯一ID 

00:22:18.290 --> 00:22:24.290
好吧，这只是虚拟数据，您可以

00:22:22.250 --> 00:22:26.900
从任何可以获取数据的地方

00:22:24.290 --> 00:22:29.450
有一个项目阅读器

00:22:26.900 --> 00:22:34.880
此列表很长，因此您可以看到neo4j 

00:22:29.450 --> 00:22:40.370
并休眠j BCE和json-ld if'和

00:22:34.880 --> 00:22:42.920
列表，Mongo，存储库和XML 

00:22:40.370 --> 00:22:44.990
和文件，存储过程以及所有

00:22:42.920 --> 00:22:46.130
这些事情，所以这是

00:22:44.990 --> 00:22:51.559
很好的权利，我们不必担心

00:22:46.130 --> 00:22:57.250
那，但我要合成一些

00:22:51.559 --> 00:23:04.360
此处为虚拟数据，ID为

00:22:57.250 --> 00:23:04.360
增加并实际上变得更好

00:23:05.710 --> 00:23:16.820
我们要说的是我是否吃光了增量

00:23:10.250 --> 00:23:21.710
并获得少于10,000，那么我们想要

00:23:16.820 --> 00:23:25.040
把窗户切成客户，我

00:23:21.710 --> 00:23:31.780
会说math.random是否大于

00:23:25.040 --> 00:23:36.080
 0.5增益，否则就可以了

00:23:31.780 --> 00:23:38.330
并在我们变成零的地方找到我

00:23:36.080 --> 00:23:40.340
 null表示批次结束，因此再次

00:23:38.330 --> 00:23:44.270
如果您想像，这非常适合

00:23:40.340 --> 00:23:46.549
您有一份将内容写到

00:23:44.270 --> 00:23:49.250
卡夫卡宁愿我们的话题排队

00:23:46.549 --> 00:23:51.500
晚上有东西出现

00:23:49.250 --> 00:23:53.330
不管每小时，然后

00:23:51.500 --> 00:23:55.520
消耗了该队列中的所有内容

00:23:53.330 --> 00:23:57.380
该主题，然后进行一些处理

00:23:55.520 --> 00:23:59.299
它将其写入CSV文件

00:23:57.380 --> 00:24:01.340
任何您知道的标准ETL到数据库

00:23:59.299 --> 00:24:03.620
或者在这种情况下，您正在

00:24:01.340 --> 00:24:06.049
来自流式传输系统的数据

00:24:03.620 --> 00:24:07.220
将其纳入持久性档案

00:24:06.049 --> 00:24:08.780
想要将其存储在数据库中

00:24:07.220 --> 00:24:10.730
否或类似的春季批

00:24:08.780 --> 00:24:12.950
对此非常完美，因为现在您知道

00:24:10.730 --> 00:24:14.870
你可以点击任何数据

00:24:12.950 --> 00:24:16.250
从流媒体系统中出来一次

00:24:14.870 --> 00:24:18.559
完成后，将其发送到

00:24:16.250 --> 00:24:20.450
你知道缓冲区很大的地方

00:24:18.559 --> 00:24:21.559
这样您就可以随时知道

00:24:20.450 --> 00:24:23.780
半小时十分钟五分钟

00:24:21.559 --> 00:24:26.270
不管有多少数据，您都可以运行

00:24:23.780 --> 00:24:30.320
随便什么工作都会开始

00:24:26.270 --> 00:24:32.990
提取数据，然后您知道

00:24:30.320 --> 00:24:35.000
将其写入后端系统，以便

00:24:32.990 --> 00:24:37.040
在这里，我只是在创建一个读者

00:24:35.000 --> 00:24:39.320
只会继续产生新记录

00:24:37.040 --> 00:24:41.270
直到我有10,000条记录

00:24:39.320 --> 00:24:43.340
完成后，将发送null使其返回

00:24:41.270 --> 00:24:46.220
 null，这告诉Spring Batch停止

00:24:43.340 --> 00:24:49.190
试图阅读，它将被阅读

00:24:46.220 --> 00:24:51.500
一种继续阅读的方式

00:24:49.190 --> 00:24:52.910
它会一直叫杂草直到达到

00:24:51.500 --> 00:24:55.490
这个块的大小

00:24:52.910 --> 00:24:58.010
将所有读取的项目累积到一个

00:24:55.490 --> 00:25:00.500
容器收集并运送到

00:24:58.010 --> 00:25:02.360
作家，作家是卡夫卡

00:25:00.500 --> 00:25:07.460
闲置的编写器，以便您使用块大小

00:25:02.360 --> 00:25:09.679
看到我在这里下达工作

00:25:07.460 --> 00:25:11.150
十将做一千遍

00:25:09.679 --> 00:25:14.090
基本上会累积十

00:25:11.150 --> 00:25:16.280
一次写入内存，然后全部写入

00:25:14.090 --> 00:25:18.200
十个给卡夫卡项目作家

00:25:16.280 --> 00:25:18.970
打算尝试做一个更大的

00:25:18.200 --> 00:25:21.130
试图去的人

00:25:18.970 --> 00:25:23.290
如果不是的话，您会尽快知道

00:25:21.130 --> 00:25:25.120
实际事务，因此，如果使用JDBC 

00:25:23.290 --> 00:25:27.190
这是实际的交易

00:25:25.120 --> 00:25:28.810
实际上把一切合乎逻辑

00:25:27.190 --> 00:25:30.700
交易，如果失败

00:25:28.810 --> 00:25:34.450
将这十个记录中的任何一个写在

00:25:30.700 --> 00:25:36.900
回滚称为十行，所以让我们来看看

00:25:34.450 --> 00:25:40.060
看起来很正常

00:25:36.900 --> 00:25:41.500
好，不需要，有我们的，有

00:25:40.060 --> 00:25:46.990
我们的代码是一个程序

00:25:41.500 --> 00:25:49.920
写数据，所以我要做的是

00:25:46.990 --> 00:26:00.340
我要把卡夫卡警察猫放在这里

00:25:49.920 --> 00:26:03.280
好吧，所以我们要卡夫卡猫和主题

00:26:00.340 --> 00:26:09.130
成为客户，还有什么需要

00:26:03.280 --> 00:26:13.780
它需要经纪人-是本地主机9090 

00:26:09.130 --> 00:26:17.470
 -好的，所以我们有数据

00:26:13.780 --> 00:26:18.760
之前我要去做我所要做的

00:26:17.470 --> 00:26:19.240
我要重新开始

00:26:18.760 --> 00:26:22.720
一切

00:26:19.240 --> 00:26:26.050
我将使用重置我的Kafka设置

00:26:22.720 --> 00:26:28.540
我正在使用融合桌面的东西， 

00:26:26.050 --> 00:26:30.760
它可以解决所有问题，所以我

00:26:28.540 --> 00:26:51.270
不用担心，让我

00:26:30.760 --> 00:26:51.270
看到源好东西好

00:26:55.960 --> 00:26:59.860
所以我只重设所有东西

00:26:57.879 --> 00:27:05.649
没有车，你知道我刚刚重新安装

00:26:59.860 --> 00:27:07.619
你从无到有现在所知道的一切

00:27:05.649 --> 00:27:09.820
您可以看到这不存在

00:27:07.619 --> 00:27:12.639
没有数据就没有

00:27:09.820 --> 00:27:15.039
对，所以我现在需要运行该程序

00:27:12.639 --> 00:27:17.499
这实际上会初始化我的

00:27:15.039 --> 00:27:19.889
目的地，所以这是我的制片人

00:27:17.499 --> 00:27:19.889
运行

00:27:30.950 --> 00:27:35.570
好吧，所以程序运行起来并不需要

00:27:33.950 --> 00:27:38.389
即使我的CPU也很长

00:27:35.570 --> 00:27:41.659
固定为QuickTime录音等等

00:27:38.389 --> 00:27:43.609
如果我去这里，你会看到我得到你

00:27:41.659 --> 00:27:45.049
知道我以为我的所有数据

00:27:43.609 --> 00:27:55.070
应该可以的，那就是

00:27:45.049 --> 00:27:59.899
现在好现在我们拥有的一切

00:27:55.070 --> 00:28:01.489
卡夫卡中的数据

00:27:59.899 --> 00:28:03.200
排队，现在我想阅读，不是吗

00:28:01.489 --> 00:28:07.899
所以我现在想去创建一个

00:28:03.200 --> 00:28:07.899
消费者应用程序，所以在这里

00:28:08.590 --> 00:28:23.419
您知道的卡夫卡消费者

00:28:18.739 --> 00:28:24.499
我们将在这里进行消费者应用程序

00:28:23.419 --> 00:28:25.669
反向中同样的事情

00:28:24.499 --> 00:28:29.090
读取已写入的数据

00:28:25.669 --> 00:28:33.320
数据库或在这种情况下到Kafka这样

00:28:29.090 --> 00:28:35.989
 Springwood的应用方式

00:28:33.320 --> 00:28:37.190
就像一个很普通的事情是使用

00:28:35.989 --> 00:28:38.720
春季比赛和春季比赛

00:28:37.190 --> 00:28:40.460
在一起，所以也许你正在使用弹簧

00:28:38.720 --> 00:28:42.169
插管，您正在进行消息传递

00:28:40.460 --> 00:28:43.909
这就是正在产生的东西

00:28:42.169 --> 00:28:46.149
数据正确，您就可以

00:28:43.909 --> 00:28:48.769
里面有数据的通道

00:28:46.149 --> 00:28:50.720
有一种叫做工作启动的东西

00:28:48.769 --> 00:28:52.249
消息处理程序，它来自

00:28:50.720 --> 00:28:54.799
春季批次整合项目和

00:28:52.249 --> 00:28:57.649
那是什么呢？ 

00:28:54.799 --> 00:28:59.090
您向该职位发送消息

00:28:57.649 --> 00:29:00.679
启动消息标题告诉它什么

00:28:59.090 --> 00:29:02.419
您要启动的工作以及什么

00:29:00.679 --> 00:29:03.769
您要使用的参数以及

00:29:02.419 --> 00:29:05.690
一条消息的结果

00:29:03.769 --> 00:29:08.210
渠道将启动春季批

00:29:05.690 --> 00:29:10.519
默认情况下，我们使用它的方式

00:29:08.210 --> 00:29:12.499
现在，当您运行spring boot时

00:29:10.519 --> 00:29:13.820
程序自动启动任何

00:29:12.499 --> 00:29:15.980
春季批处理作业

00:29:13.820 --> 00:29:17.570
应用程序上下文，但是如果您想

00:29:15.980 --> 00:29:19.700
由于某种原因而工作

00:29:17.570 --> 00:29:21.470
处理管道，也许您会看到一个文件

00:29:19.700 --> 00:29:24.710
或类似的东西，你可以说哦，我

00:29:21.470 --> 00:29:26.480
这是春天的入站文件适配器

00:29:24.710 --> 00:29:28.970
聚合提示通知通知

00:29:26.480 --> 00:29:31.009
是一个新文件并且以某种形式挂载

00:29:28.970 --> 00:29:32.600
或你知道的东西，然后

00:29:31.009 --> 00:29:34.669
开始执行ETL的工作

00:29:32.600 --> 00:29:40.279
然后将数据写入Kafka 

00:29:34.669 --> 00:29:41.570
对或者你知道什么然后

00:29:40.279 --> 00:29:43.159
如果将其写入Kafka可以

00:29:41.570 --> 00:29:44.750
触发某种流

00:29:43.159 --> 00:29:46.460
处理管道，然后有一个

00:29:44.750 --> 00:29:47.390
放，然后需要装回

00:29:46.460 --> 00:29:49.370
进入数据库，那就是

00:29:47.390 --> 00:29:51.290
春季批可以再次帮助您

00:29:49.370 --> 00:29:52.550
 REIT作为倾听者和消费者

00:29:51.290 --> 00:29:55.820
我们在这里要看的东西

00:29:52.550 --> 00:29:58.370
所以我们需要相同的种类

00:29:55.820 --> 00:30:03.860
基本设置的第一次

00:29:58.370 --> 00:30:09.130
我们有一个桌子弹簧批次好

00:30:03.860 --> 00:30:09.130
我想我们的批处理很好

00:30:09.280 --> 00:30:35.590
公共静态无效意味着已经可以了

00:30:25.850 --> 00:30:38.510
运行消费者应用程序点类很酷

00:30:35.590 --> 00:30:45.380
我们想要做的好

00:30:38.510 --> 00:30:46.790
做好工作，以便创建

00:30:45.380 --> 00:30:49.970
我们需要这份工作午餐

00:30:46.790 --> 00:30:52.280
工厂和步骤对不起工作

00:30:49.970 --> 00:30:56.590
建造者工厂和步骤建造者

00:30:52.280 --> 00:30:56.590
工厂和以前一样

00:31:06.269 --> 00:31:15.879
建造者工厂好吗

00:31:14.499 --> 00:31:18.249
在我将其注入到

00:31:15.879 --> 00:31:20.169
建设者，我会说必修课

00:31:18.249 --> 00:31:22.539
我将创建一个构造函数

00:31:20.169 --> 00:31:24.460
具有参数和的构造函数

00:31:22.539 --> 00:31:26.889
这些字段的存储

00:31:24.460 --> 00:31:28.179
自动初始化他们这样做

00:31:26.889 --> 00:31:30.479
如果我按下alt，该怎么办

00:31:28.179 --> 00:31:33.100
输入只是生成构造函数， 

00:31:30.479 --> 00:31:39.239
一旦我有了工作，我想做什么

00:31:33.100 --> 00:31:42.869
想说工作建立者工厂点得到

00:31:39.239 --> 00:31:42.869
工作随便

00:31:44.369 --> 00:32:02.499
实施者新的NID增量器启动

00:31:53.220 --> 00:32:13.139
建立正确，我们需要一步，所以回来

00:32:02.499 --> 00:32:13.139
第二个礼物

00:32:18.770 --> 00:32:34.039
好吧，我们的步骤是您再次知道

00:32:31.289 --> 00:32:37.260
我们将要读取数据，所以什么也没有

00:32:34.039 --> 00:32:40.400
特别喜欢这里

00:32:37.260 --> 00:32:40.400
使用步进滤波器工厂

00:32:43.880 --> 00:32:47.669
你应该给他们更多的描述性

00:32:45.870 --> 00:32:49.320
之所以命名，是因为记住了

00:32:47.669 --> 00:32:51.090
持久到数据库，这就是我们的方式

00:32:49.320 --> 00:32:53.520
可以查询此特定状态

00:32:51.090 --> 00:32:57.090
以后再做，所以不要像我一样做

00:32:53.520 --> 00:32:58.500
做得更好，我知道你可以，所以我们再次

00:32:57.090 --> 00:33:00.510
我们要在这里阅读，所以大块

00:32:58.500 --> 00:33:02.100
真的是我们要写的东西

00:33:00.510 --> 00:33:04.710
这种情况下我要写到控制台

00:33:02.100 --> 00:33:06.960
我要写一个我要插入

00:33:04.710 --> 00:33:10.530
一个虚拟物品作家，只会记录

00:33:06.960 --> 00:33:11.610
所有的数据都没什么有趣的，所以

00:33:10.530 --> 00:33:14.850
到底什么块并不重要

00:33:11.610 --> 00:33:20.030
大小是没有风险的

00:33:14.850 --> 00:33:22.440
就像不堪重负的危险

00:33:20.030 --> 00:33:25.919
没有真正的风险，真的，你知道我只是

00:33:22.440 --> 00:33:27.000
要登录到他，但你应该

00:33:25.919 --> 00:33:29.789
绝对应该多加注意

00:33:27.000 --> 00:33:32.000
你说的比我说的要多

00:33:29.789 --> 00:33:33.780
真的需要我不写保存

00:33:32.000 --> 00:33:35.940
那一刻你可以使用的好点

00:33:33.780 --> 00:33:41.460
卡夫卡作为登台的一种方式

00:33:35.940 --> 00:33:43.049
吸收写作，所以科克伦可以接受

00:33:41.460 --> 00:33:44.840
你不确定是否有很多

00:33:43.049 --> 00:33:46.950
需要写入的数据

00:33:44.840 --> 00:33:49.169
后续数据存储，例如Oracle或

00:33:46.950 --> 00:33:51.090
不会掉的东西你知道你

00:33:49.169 --> 00:33:54.240
不能删除相同数量的数据

00:33:51.090 --> 00:33:56.010
在您无法写入的Oracle数据库上

00:33:54.240 --> 00:33:57.450
 Oracle Oracle数据库，即使您

00:33:56.010 --> 00:33:58.740
删除所有索引和所有东西

00:33:57.450 --> 00:34:01.500
你只是不会写

00:33:58.740 --> 00:34:02.640
尽快到Kafka，所以这

00:34:01.500 --> 00:34:04.440
可能恰好是那种东西

00:34:02.640 --> 00:34:06.690
你有什么可以

00:34:04.440 --> 00:34:08.669
排空队列，然后尝试

00:34:06.690 --> 00:34:10.320
慢慢写入Oracle数据库，然后

00:34:08.669 --> 00:34:12.270
你可以用春季批处理来做你

00:34:10.320 --> 00:34:13.760
你实际上知道远程分块吗

00:34:12.270 --> 00:34:16.560
你实际上在哪里分拆

00:34:13.760 --> 00:34:19.440
它实际上散布在哪里工作或

00:34:16.560 --> 00:34:22.409
群集上的节点，然后拉入

00:34:19.440 --> 00:34:24.929
您知道的来自Kafka的数据

00:34:22.409 --> 00:34:26.700
我能想象你知道拉吗

00:34:24.929 --> 00:34:29.010
来自不同主题的数据或

00:34:26.700 --> 00:34:30.210
卡夫卡上每个分区的不同分区

00:34:29.010 --> 00:34:31.169
例如节点

00:34:30.210 --> 00:34:33.030
你知道很多事情

00:34:31.169 --> 00:34:34.950
春季批次中的机会

00:34:33.030 --> 00:34:38.369
框架本身

00:34:34.950 --> 00:34:41.270
与Kafka一起使他们变得更好

00:34:38.369 --> 00:34:47.819
这也是为了规模而建立的

00:34:41.270 --> 00:34:52.679
一步建立工厂作家将

00:34:47.819 --> 00:35:04.950
作为我们作家的负责人插入

00:34:52.679 --> 00:35:06.540
项目编写者客户还可以， 

00:35:04.950 --> 00:35:21.660
当您使用时，我将使用记录器

00:35:06.540 --> 00:35:25.140
 log4j好的，注销我要执行的操作

00:35:21.660 --> 00:35:26.670
对于收藏中的每个项目

00:35:25.140 --> 00:35:29.089
的项目，所以我要说的项目

00:35:26.670 --> 00:35:29.089
每个

00:35:35.610 --> 00:35:49.860
好的，那好吧

00:35:45.810 --> 00:35:51.330
那就是这里真正的魔力

00:35:49.860 --> 00:35:53.670
我想在这边展示的是

00:35:51.330 --> 00:36:00.780
当然是卡夫卡的读者

00:35:53.670 --> 00:36:02.640
读者慢慢说，读者好吗，我们

00:36:00.780 --> 00:36:10.670
提供光束已经不行了，让我们

00:36:02.640 --> 00:36:20.970
在这里做，所以我一直是卡卡项目

00:36:10.670 --> 00:36:24.300
读者简单，对，对，好吧，首先

00:36:20.970 --> 00:36:32.940
首先，我们需要一个新的卡夫卡物品

00:36:24.300 --> 00:36:34.740
读者生成器，这将是一个骰子

00:36:32.940 --> 00:36:39.530
字符串很长，不是吗？ 

00:36:34.740 --> 00:36:39.530
长和一个客户

00:36:47.340 --> 00:36:53.470
那我要分区什么

00:36:49.660 --> 00:36:55.210
在这一点上，我们用一只脚

00:36:53.470 --> 00:36:58.390
需要一些消费者属性，这

00:36:55.210 --> 00:37:01.120
您知道我们可以从中获得一些帮助的地方

00:36:58.390 --> 00:37:08.020
这里的自动配置栏道具

00:37:01.120 --> 00:37:10.570
等于您的属性还可以，我需要什么

00:37:08.020 --> 00:37:12.100
是添加的消费者属性

00:37:10.570 --> 00:37:15.220
为属性文件申请

00:37:12.100 --> 00:37:17.170
的属性都注入

00:37:15.220 --> 00:37:20.680
咳嗽特性的对象

00:37:17.170 --> 00:37:23.830
在幕后，这有点像

00:37:20.680 --> 00:37:25.480
从iam auto泄漏的东西

00:37:23.830 --> 00:37:30.760
配置，但我确实需要它，所以我会

00:37:25.480 --> 00:37:38.230
使用该属性道具

00:37:30.760 --> 00:37:41.800
所有这些属性点了我想要的

00:37:38.230 --> 00:37:50.520
那些消费者属性我猜这

00:37:41.800 --> 00:37:50.520
看起来还好吧

00:37:55.830 --> 00:38:05.860
给它起个名字

00:38:02.080 --> 00:38:11.920
客户服务员

00:38:05.860 --> 00:38:18.640
确定并建立，不想保存

00:38:11.920 --> 00:38:20.610
声明你敢责骂你好吧哦，我们

00:38:18.640 --> 00:38:24.310
需要话题告诉我，我们需要告诉它

00:38:20.610 --> 00:38:27.010
我们需要告诉它从哪里读取

00:38:24.310 --> 00:38:30.240
对，因此主题将是

00:38:27.010 --> 00:38:30.240
我们在属性文件中说的正确

00:38:30.660 --> 00:38:35.110
所以我也可以注入

00:38:33.130 --> 00:38:36.430
我可能不应该重复

00:38:35.110 --> 00:38:38.320
这是默认主题

00:38:36.430 --> 00:38:40.630
读者为作者感到抱歉，并在

00:38:38.320 --> 00:38:42.790
消费者方面在这里的客户

00:38:40.630 --> 00:38:47.680
他们在共享相同的地址

00:38:42.790 --> 00:38:53.500
经纪人好吧，我想就是我们需要的

00:38:47.680 --> 00:38:55.360
插入卡夫卡项目阅读器中，我得到了

00:38:53.500 --> 00:38:56.470
作家，所以我们知道我们已经有数据

00:38:55.360 --> 00:39:00.130
在数据库中，我们已经看到

00:38:56.470 --> 00:39:01.960
右二写了一些数据给卡夫卡

00:39:00.130 --> 00:39:06.910
在这里，我们需要提取数据

00:39:01.960 --> 00:39:12.090
现在出去好了，所以所有的让我们

00:39:06.910 --> 00:39:12.090
现在使用此消费者阅读它

00:39:20.480 --> 00:39:23.650
然后我们去

00:39:29.119 --> 00:39:36.619
不能很好地托管此主题分区

00:39:33.259 --> 00:39:37.849
这似乎不公平吗，我是零

00:39:36.619 --> 00:39:41.689
应该做零

00:39:37.849 --> 00:39:45.380
我不是我是哪种书呆子

00:39:41.689 --> 00:39:47.869
没有使用零的Visual Basic书呆子

00:39:45.380 --> 00:39:48.229
什么样的好吧我有什么

00:39:47.869 --> 00:40:04.929
现在完成

00:39:48.229 --> 00:40:04.929
哦，它说我无法将字符串转换为

00:40:08.170 --> 00:40:17.080
那我为什么搞砸了

00:40:14.770 --> 00:40:21.490
这里的属性配置

00:40:17.080 --> 00:40:25.500
查看消费者方面的价值-塞拉利昂

00:40:21.490 --> 00:40:32.100
 Lazard is Jason-消毒器长久

00:40:25.500 --> 00:40:32.100
似乎合法的可信软件包是正确的

00:40:32.940 --> 00:40:37.260
我不知何故

00:40:42.400 --> 00:40:45.510
在哪里

00:41:03.350 --> 00:41:06.220
嗯

00:41:08.240 --> 00:41:19.500
正确的物品正确的我有什么

00:41:16.700 --> 00:41:20.600
我的意思是我有不正确的数据

00:41:19.500 --> 00:41:30.510
有作家

00:41:20.600 --> 00:41:35.810
作者是我的一个问题

00:41:30.510 --> 00:41:35.810
读者请参阅由

00:42:01.910 --> 00:42:12.460
长期客户长期客户

00:42:23.500 --> 00:42:36.470
不可修改的收藏所以说

00:42:32.990 --> 00:42:46.510
它具有它所具有的价值

00:42:36.470 --> 00:42:49.010
看到埃利泽在我身上很有价值

00:42:46.510 --> 00:42:51.619
那里有一个属性元素，所以它

00:42:49.010 --> 00:42:55.460
试图使用默认值哦

00:42:51.619 --> 00:42:56.920
太糟糕了，好了，如果您

00:42:55.460 --> 00:42:59.810
不能点击里面的

00:42:56.920 --> 00:43:02.450
 IDE是因为我正在使用属性

00:42:59.810 --> 00:43:04.760
只是任意图的元素

00:43:02.450 --> 00:43:05.990
键和值只是它不是

00:43:04.760 --> 00:43:07.849
什么意思，所以它试图使用

00:43:05.990 --> 00:43:09.319
默认，难怪它是如此难过

00:43:07.849 --> 00:43:11.150
好的，所以我们去了

00:43:09.319 --> 00:43:12.680
当我现在修复它时看看

00:43:11.150 --> 00:43:15.349
了解正确的DC Eliezer， 

00:43:12.680 --> 00:43:17.030
有我所有的数据，还有我的朋友

00:43:15.349 --> 00:43:19.940
看起来非常快

00:43:17.030 --> 00:43:23.000
看看使用Kafka和spring batch和

00:43:19.940 --> 00:43:24.760
再次，真正的机会是

00:43:23.000 --> 00:43:27.800
在创新中有可能

00:43:24.760 --> 00:43:29.930
将流媒体集成到徽章和

00:43:27.800 --> 00:43:32.540
成批的流用例想象

00:43:29.930 --> 00:43:33.609
从消息队列中取出数据，以及

00:43:32.540 --> 00:43:36.230
然后写成某种

00:43:33.609 --> 00:43:38.690
永久存储或归档在或

00:43:36.230 --> 00:43:42.890
不管把它放在仓库里

00:43:38.690 --> 00:43:44.420
分析，这正是那种

00:43:42.890 --> 00:43:47.060
您需要写入的胶水代码

00:43:44.420 --> 00:43:48.369
完成这样的工作，它可以

00:43:47.060 --> 00:43:50.660
也是你做的地方

00:43:48.369 --> 00:43:51.880
本身就是春天

00:43:50.660 --> 00:43:54.859
批处理非常适合这种东西

00:43:51.880 --> 00:43:57.109
总而言之，我很高兴看到这个

00:43:54.859 --> 00:43:58.670
土地和春天回来，我希望你能给

00:43:57.109 --> 00:44:01.280
一枪和反馈显然我们

00:43:58.670 --> 00:44:03.140
尚未g8，所以越早越好

00:44:01.280 --> 00:44:06.460
好，非常感谢您的收看和

00:44:03.140 --> 00:44:06.460
下次我们再见

00:44:11.790 --> 00:44:13.850
您

