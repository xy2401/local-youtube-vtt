WEBVTT
Kind: captions
Language: zh-Hans

00:00:15.030 --> 00:00:19.470
嘿，今天的春季粉丝

00:00:17.490 --> 00:00:22.529
春天的技巧，我们要去看看

00:00:19.470 --> 00:00:25.020
如何建立复杂的整合流程

00:00:22.529 --> 00:00:28.140
和流处理解决方案，使用

00:00:25.020 --> 00:00:30.150
先前视频中的Spring Cloud Dataflow 

00:00:28.140 --> 00:00:31.619
我们以 Spring Integration 的方式

00:00:30.150 --> 00:00:34.260
基于消息传递和事件的构建

00:00:31.619 --> 00:00:37.410
基于系统的集成

00:00:34.260 --> 00:00:39.120
活动条款，然后我们看了看

00:00:37.410 --> 00:00:41.010
数据如何从一个节点流到另一个节点

00:00:39.120 --> 00:00:42.750
就渠道而言， 

00:00:41.010 --> 00:00:45.480
随后的视频介绍了如何构建

00:00:42.750 --> 00:00:47.670
基于消息传递的微服务使用

00:00:45.480 --> 00:00:50.340
spring-cloud-streamspring-cloud-stream

00:00:47.670 --> 00:00:52.500
建立在 Spring Integration 的基础上

00:00:50.340 --> 00:00:55.590
减轻了指定

00:00:52.500 --> 00:00:59.460
繁琐的适配器入站和

00:00:55.590 --> 00:01:01.140
我们在春季使用的出站渠道

00:00:59.460 --> 00:01:02.520
磨碎仍然存在，但我们没有

00:01:01.140 --> 00:01:04.920
不得不担心这些事情

00:01:02.520 --> 00:01:07.740
与其他节点交谈以使用其他服务

00:01:04.920 --> 00:01:09.210
连通性是商品

00:01:07.740 --> 00:01:11.460
这是一个沉迷于一件事情

00:01:09.210 --> 00:01:12.810
进入配置文件，其余的

00:01:11.460 --> 00:01:15.000
这是一种适用并基于

00:01:12.810 --> 00:01:16.140
约定，所以我们得到的结果

00:01:15.000 --> 00:01:18.240
互相交谈的系统

00:01:16.140 --> 00:01:20.340
我们有点商品化了

00:01:18.240 --> 00:01:22.200
运输，我们用什么做

00:01:20.340 --> 00:01:24.180
称为 Spring Cloud Stream 粘合剂

00:01:22.200 --> 00:01:25.310
那里有几种粘合剂

00:01:24.180 --> 00:01:28.020
尤其是

00:01:25.310 --> 00:01:31.500
 rabbitmq和apache kafka，所以你可以

00:01:28.020 --> 00:01:33.060
建立基于Spring Cloud Stream的服务

00:01:31.500 --> 00:01:36.509
互相交谈的微服务

00:01:33.060 --> 00:01:38.909
使用 Spring Cloud Stream Rabbitmq或

00:01:36.509 --> 00:01:40.799
 Spring Cloud Stream Apache Kafka和我们

00:01:38.909 --> 00:01:42.540
可以只写通用的代码

00:01:40.799 --> 00:01:44.430
 Spring Integration 渠道无

00:01:42.540 --> 00:01:47.610
更加明智的是

00:01:44.430 --> 00:01:49.079
今天，这些基础组件

00:01:47.610 --> 00:01:52.650
会得到所谓的春天云

00:01:49.079 --> 00:01:55.979
数据流弹簧云数据流是一种方法

00:01:52.650 --> 00:01:58.170
编排微服务的基础

00:01:55.979 --> 00:02:00.930
在基于

00:01:58.170 --> 00:02:02.579
这些模块接受的 Spring Cloud Stream 

00:02:00.930 --> 00:02:04.530
数据产生的数据，有时

00:02:02.579 --> 00:02:08.610
可以选择接受和产生数据

00:02:04.530 --> 00:02:10.380
和Spring Cloud Dataflow重写或

00:02:08.610 --> 00:02:13.170
提供某种配置

00:02:10.380 --> 00:02:15.209
传入的传入通道和

00:02:13.170 --> 00:02:17.760
出站通道，所以真的是唯一

00:02:15.209 --> 00:02:20.370
使用Spring Cloud的要求

00:02:17.760 --> 00:02:22.320
 Spring Cloud Dataflow中的流模块

00:02:20.370 --> 00:02:23.640
是它产生了一些消息，如果

00:02:22.320 --> 00:02:25.260
它会在

00:02:23.640 --> 00:02:28.140
众所周知的消息通道称为输出

00:02:25.260 --> 00:02:29.200
然后它接受消息，如果

00:02:28.140 --> 00:02:30.720
要接受

00:02:29.200 --> 00:02:32.950
在一个称为输入的知名频道上

00:02:30.720 --> 00:02:34.330
春天的云数据流，那么你就知道

00:02:32.950 --> 00:02:37.150
它为那些存储状态

00:02:34.330 --> 00:02:38.349
它会知道的描述

00:02:37.150 --> 00:02:40.660
Spring Cloud的位置

00:02:38.349 --> 00:02:43.630
流模块在以下方面

00:02:40.660 --> 00:02:47.349
 Maven存储库或Docker映像或

00:02:43.630 --> 00:02:49.810
这样的事情，然后您提供

00:02:47.349 --> 00:02:51.489
您提供有关DSL的描述

00:02:49.810 --> 00:02:53.440
组成的

00:02:51.489 --> 00:02:55.569
这些不同的方面

00:02:53.440 --> 00:02:58.569
什么叫流，又叫流

00:02:55.569 --> 00:03:00.790
是无限的，你知道无限的

00:02:58.569 --> 00:03:03.160
永无休止的东西

00:03:00.790 --> 00:03:07.480
数据以及是否可能永久存在

00:03:03.160 --> 00:03:09.100
任务是不同的方式

00:03:07.480 --> 00:03:11.590
一项任务可以处理

00:03:09.100 --> 00:03:13.180
批处理作业的有限数据量

00:03:11.590 --> 00:03:15.430
例子是有限的数据

00:03:13.180 --> 00:03:18.250
 Spring代码数据流可以管理和

00:03:15.430 --> 00:03:22.690
既有任务又有编舞

00:03:18.250 --> 00:03:25.150
流您的任务可能例如是

00:03:22.690 --> 00:03:28.209
您想要的Spring Batch处理工作

00:03:25.150 --> 00:03:30.099
可以从

00:03:28.209 --> 00:03:32.709
单身的地方，所以春天的云

00:03:30.099 --> 00:03:33.940
数据流服务为您做到这一点

00:03:32.709 --> 00:03:36.310
使它保持状态的服务

00:03:33.940 --> 00:03:39.040
数据库，然后您可以作为操作员进入

00:03:36.310 --> 00:03:42.010
到那个服务器，然后

00:03:39.040 --> 00:03:45.100
用它来制作迷你平板或某种显示器

00:03:42.010 --> 00:03:47.260
这些嗯这些流和任务，所以

00:03:45.100 --> 00:03:49.209
让我们去做，我有一个FTP服务器

00:03:47.260 --> 00:03:50.890
运行，您可能会记得

00:03:49.209 --> 00:03:52.299
春季否定视频，我们建立了一个

00:03:50.890 --> 00:03:54.700
从

00:03:52.299 --> 00:03:56.350
 FTP目录，然后我们将其写出

00:03:54.700 --> 00:03:58.690
到FTP服务器，您就知道了

00:03:56.350 --> 00:04:00.730
很多非常非常简单的

00:03:58.690 --> 00:04:03.340
转型，今天我们将做

00:04:00.730 --> 00:04:05.260
同样的东西，甚至更少的代码

00:04:03.340 --> 00:04:08.350
我们将减少的认知开销

00:04:05.260 --> 00:04:12.549
现在使用数据流像我一样

00:04:08.350 --> 00:04:14.769
说与底层无关

00:04:12.549 --> 00:04:16.239
分布机制还记得

00:04:14.769 --> 00:04:19.479
去编排或编舞

00:04:16.239 --> 00:04:23.139
而是您在一个网站上的不同服务

00:04:19.479 --> 00:04:25.539
分布式拓扑，例如COD 

00:04:23.139 --> 00:04:27.310
家庭或导弹或纱线

00:04:25.539 --> 00:04:30.130
没关系，所以我们要继续

00:04:27.310 --> 00:04:32.260
说数据流服务，我会带

00:04:30.130 --> 00:04:34.150
在本地数据流服务器中

00:04:32.260 --> 00:04:37.330
现在就可以了

00:04:34.150 --> 00:04:39.010
如果我们想提供h2数据源

00:04:37.330 --> 00:04:40.599
或其他一些数据源，但是

00:04:39.010 --> 00:04:41.240
已经在内存中嵌入了

00:04:40.599 --> 00:04:43.340
过时的

00:04:41.240 --> 00:04:45.729
到数据源，这样就可以正常工作

00:04:43.340 --> 00:04:48.620
让我们继续前进，点击产生

00:04:45.729 --> 00:04:59.840
打开它，我们的IDE不会

00:04:48.620 --> 00:05:02.120
真正重要的是哪个IDE，现在我们要做

00:04:59.840 --> 00:05:04.280
一如既往的春天

00:05:02.120 --> 00:05:05.750
这些天基于引导的服务我们添加了一个

00:05:04.280 --> 00:05:08.020
注释和自动配置

00:05:05.750 --> 00:05:15.440
剩下的了，所以我们可以旋转它

00:05:08.020 --> 00:05:17.659
港口93 93好的品质在工作中问你

00:05:15.440 --> 00:05:19.360
我想您会首先注意到

00:05:17.659 --> 00:05:21.550
最重要的是当应用程序启动时

00:05:19.360 --> 00:05:24.110
然后是应用程序

00:05:21.550 --> 00:05:26.449
本身已经启动并正在运行，这是一个

00:05:24.110 --> 00:05:27.830
相当复杂的API，但是

00:05:26.449 --> 00:05:29.720
已经为我们编写了，所以这是一个API 

00:05:27.830 --> 00:05:34.580
不用担心，所以我们去这里

00:05:29.720 --> 00:05:37.659
现在到本地主机93 93，您可以看到

00:05:34.580 --> 00:05:39.560
这是超媒体或如何

00:05:37.659 --> 00:05:41.630
其余端点是端点

00:05:39.560 --> 00:05:44.330
对于API本身，您不必使用

00:05:41.630 --> 00:05:45.830
这个API直接用于最远的事情

00:05:44.330 --> 00:05:50.300
从它开始，我们可以使用仪表板

00:05:45.830 --> 00:05:53.659
所以在这里我去仪表板，你

00:05:50.300 --> 00:05:55.699
可以看到我在这里有几种选择

00:05:53.659 --> 00:05:58.070
可以获取有关服务器的信息

00:05:55.699 --> 00:05:59.930
本身，我可以看看分析

00:05:58.070 --> 00:06:01.250
因为你知道柜台和类似的东西

00:05:59.930 --> 00:06:04.370
这一点我们会回到

00:06:01.250 --> 00:06:06.460
我可以看看正在进行的工作

00:06:04.370 --> 00:06:08.509
正在运行或任何这是一个

00:06:06.460 --> 00:06:10.789
深入挖掘Spring Batch作业

00:06:08.509 --> 00:06:13.940
特别是我可以看一下这个任务

00:06:10.789 --> 00:06:16.250
这是一个称为

00:06:13.940 --> 00:06:19.370
任务，其中可能包括Spring Batch处理

00:06:16.250 --> 00:06:20.569
例如工作，然后我可以

00:06:19.370 --> 00:06:21.919
当然看看我们

00:06:20.569 --> 00:06:24.050
将在一分钟内创建， 

00:06:21.919 --> 00:06:26.090
运行时，现在运行时是指

00:06:24.050 --> 00:06:30.199
弹簧可用的组件

00:06:26.090 --> 00:06:32.930
云流应用程序和任务

00:06:30.199 --> 00:06:34.580
可用的使用权是

00:06:32.930 --> 00:06:38.240
在这种情况下正在某处运行

00:06:34.580 --> 00:06:41.810
我们的本地计算机和应用程序指的是

00:06:38.240 --> 00:06:43.789
在这种情况下，罐子的模块或

00:06:41.810 --> 00:06:45.710
码头工人图像或其他

00:06:43.789 --> 00:06:47.960
可用于

00:06:45.710 --> 00:06:50.089
我可以组成复杂的解决方案

00:06:47.960 --> 00:06:52.909
通过提供注册新的应用程序

00:06:50.089 --> 00:06:54.790
名称组件的类型和URL 

00:06:52.909 --> 00:06:57.160
在这种情况下，也许我是

00:06:54.790 --> 00:06:59.140
甚至URL，例如maven io spring 

00:06:57.160 --> 00:07:00.640
你知道这是一个老样子

00:06:59.140 --> 00:07:02.170
那将甚至解决

00:07:00.640 --> 00:07:04.450
您本地的本地Maven存储库

00:07:02.170 --> 00:07:07.720
或者您可以指定一个存储库

00:07:04.450 --> 00:07:09.750
你想用而不是我用什么

00:07:07.720 --> 00:07:12.130
我想做的是我要批量导入

00:07:09.750 --> 00:07:13.860
一些现有的乐高积木

00:07:12.130 --> 00:07:15.850
由spring cloud dataflow提供

00:07:13.860 --> 00:07:17.260
我可以通过大量操作来做到这一点

00:07:15.850 --> 00:07:20.130
导入应用程序，我可以在这里看到

00:07:17.260 --> 00:07:23.440
有四组预配置

00:07:20.130 --> 00:07:26.170
流应用程序和两组

00:07:23.440 --> 00:07:29.500
预配置任务应用程序

00:07:26.170 --> 00:07:31.930
流根据

00:07:29.500 --> 00:07:33.610
活页夹RabbitMQ或Apache Kafka的类型

00:07:31.930 --> 00:07:35.800
以及格式是否为码头工人

00:07:33.610 --> 00:07:38.170
图片或罐子将其写入，它知道如何

00:07:35.800 --> 00:07:42.100
既部署又执行，我们将

00:07:38.170 --> 00:07:44.140
继续并导入所有RabbitMQ 

00:07:42.100 --> 00:07:45.490
基于所有的Maven坐标

00:07:44.140 --> 00:07:48.160
现有的罐子，所以这又是指

00:07:45.490 --> 00:07:50.980
只是一连串的不同罐子

00:07:48.160 --> 00:07:52.990
包含Spring Cloud Stream应用程序

00:07:50.980 --> 00:07:56.790
或真正的好应用程序和

00:07:52.990 --> 00:07:59.590
当它打印的数据流使用那些

00:07:56.790 --> 00:08:00.970
这些流模块只是

00:07:59.590 --> 00:08:03.040
正确启动它们就是我的意思

00:08:00.970 --> 00:08:04.660
它会部署它们，所以现在如果我们去

00:08:03.040 --> 00:08:06.580
对于应用程序，我们可以看到所有不同的地方

00:08:04.660 --> 00:08:09.220
组件，在输出中，我们可以

00:08:06.580 --> 00:08:10.780
具体看有三个

00:08:09.220 --> 00:08:15.610
这里反映的主要成分

00:08:10.780 --> 00:08:17.170
有文件是相当来源

00:08:15.610 --> 00:08:19.780
产生一个知名的消息

00:08:17.170 --> 00:08:22.600
通道称为输出

00:08:19.780 --> 00:08:24.010
接收消息的处理器和

00:08:22.600 --> 00:08:25.360
知名输入通道再写

00:08:24.010 --> 00:08:27.940
在知名输出上显示一条消息

00:08:25.360 --> 00:08:29.530
通道，有接收器

00:08:27.940 --> 00:08:31.990
在一个著名的输入通道上

00:08:29.530 --> 00:08:35.020
对，所以这些是春天穿的衣服

00:08:31.990 --> 00:08:36.460
模块唯一的约定

00:08:35.020 --> 00:08:38.169
他们必须具备的素质

00:08:36.460 --> 00:08:41.919
可用作那里的过程的来源

00:08:38.169 --> 00:08:45.160
是一个水槽，因为它们暴露了春天

00:08:41.919 --> 00:08:47.380
云流通道称为输出和

00:08:45.160 --> 00:08:50.290
输入或有时两者都输入

00:08:47.380 --> 00:08:51.670
处理器，所以现在我们有了

00:08:50.290 --> 00:08:53.140
这些应用程序让我们继续构建一个

00:08:51.670 --> 00:08:55.720
流出来，所以我要去

00:08:53.140 --> 00:08:57.010
流标签，在这里我们可以看到我们

00:08:55.720 --> 00:08:58.240
没有现有的流定义

00:08:57.010 --> 00:09:00.700
让我们继续前进，创造一个我们

00:08:58.240 --> 00:09:02.350
将使用此可视化编辑器

00:09:00.700 --> 00:09:03.850
支持两种输入之一

00:09:02.350 --> 00:09:08.420
我们可以使用

00:09:03.850 --> 00:09:09.740
春天的云数据流DSL或我们可以使用

00:09:08.420 --> 00:09:12.589
一种直观的方式来做，让我们开始吧

00:09:09.740 --> 00:09:14.329
与DSL匹配的DSL或

00:09:12.589 --> 00:09:16.160
看起来对任何人都很熟悉

00:09:14.329 --> 00:09:18.709
曾经用过bash，所以我要说

00:09:16.160 --> 00:09:21.620
从文件源获取数据并写入

00:09:18.709 --> 00:09:24.170
它到FTP接收器FTP接收器需要

00:09:21.620 --> 00:09:25.899
有关放置在哪里的一些信息

00:09:24.170 --> 00:09:27.860
文件自然会是这样

00:09:25.899 --> 00:09:29.630
最终它将成为一个正在运行的Java 

00:09:27.860 --> 00:09:31.550
过程在某个地方运行，所以我们可以

00:09:29.630 --> 00:09:33.560
提供传递给他们的参数

00:09:31.550 --> 00:09:34.970
运行过程和我们相同的方式

00:09:33.560 --> 00:09:36.440
任何其他Springwood应用程序

00:09:34.970 --> 00:09:38.089
作为环境的达什提论点

00:09:36.440 --> 00:09:39.949
就像在这种情况下

00:09:38.089 --> 00:09:42.050
更方便地将它们作为一部分提供

00:09:39.949 --> 00:09:46.850
这里的定义，所以FTP点

00:09:42.050 --> 00:09:48.649
工厂点主机等于localhost对

00:09:46.850 --> 00:09:50.870
我们可以复制并粘贴其中一些

00:09:48.649 --> 00:09:56.829
值走得更快一点，所以FTP到

00:09:50.870 --> 00:10:04.209
密码等于spring FTP类型的用户名

00:09:56.829 --> 00:10:06.380
等于J长FTP点端口等于2121 

00:10:04.209 --> 00:10:08.540
等等，我们可以做到这一点

00:10:06.380 --> 00:10:10.190
当然和视觉工具意识到

00:10:08.540 --> 00:10:13.040
他们，但我们也可以编辑这些

00:10:10.190 --> 00:10:14.589
视觉上正确的属性，所以我们可以

00:10:13.040 --> 00:10:16.790
单击那里的小齿轮图标，然后

00:10:14.589 --> 00:10:18.800
我们可以指定例如我们想要的

00:10:16.790 --> 00:10:20.180
和中出现的所有文件

00:10:18.800 --> 00:10:22.220
我们要监视的目录

00:10:20.180 --> 00:10:23.839
拆分并单独发布

00:10:22.220 --> 00:10:26.360
每行的消息称为

00:10:23.839 --> 00:10:29.510
行模式，我们可以指定我们想要

00:10:26.360 --> 00:10:31.640
监视在我的计算机上调用的目录

00:10:29.510 --> 00:10:35.360
桌面，然后我们在监视器上

00:10:31.640 --> 00:10:36.649
只有点txt类型的文件，然后

00:10:35.360 --> 00:10:38.959
防止重复，所以我认为

00:10:36.649 --> 00:10:40.940
其他一切看起来都很好，我们也想要

00:10:38.959 --> 00:10:42.949
指定有关FTP的信息

00:10:40.940 --> 00:10:44.000
服务器本身，所以我想自动

00:10:42.949 --> 00:10:47.839
创建目录，它们必须是

00:10:44.000 --> 00:10:51.529
服务器（如果不存在）我要使用

00:10:47.839 --> 00:10:54.290
绝对是一个临时文件名，我

00:10:51.529 --> 00:10:57.380
想要使用表达式到达

00:10:54.290 --> 00:10:58.970
名字本身，所以我会说T数学点

00:10:57.380 --> 00:11:00.920
随机标头点找到了它们，这是什么

00:10:58.970 --> 00:11:03.560
将会发生的是它将采取

00:11:00.920 --> 00:11:06.709
即将收到的传入消息

00:11:03.560 --> 00:11:08.360
由我们的文件提供或产生

00:11:06.709 --> 00:11:10.699
源与 Spring Integration 

00:11:08.360 --> 00:11:12.529
对于入站文件适配器，它会

00:11:10.699 --> 00:11:15.019
包含标题，特别是

00:11:12.529 --> 00:11:16.730
标头称为文件名，通常

00:11:15.019 --> 00:11:18.890
将使用该文件名来写

00:11:16.730 --> 00:11:20.810
文件到FTP服务器，所以如果我把

00:11:18.890 --> 00:11:22.400
 txt和in中名为food的文件

00:11:20.810 --> 00:11:24.560
它会上传的目录

00:11:22.400 --> 00:11:27.710
到FTP服务器，如点txt，但在

00:11:24.560 --> 00:11:30.230
这样的话我要把它分成点

00:11:27.710 --> 00:11:32.480
按行txt，因此我需要确保

00:11:30.230 --> 00:11:34.720
即使多封邮件

00:11:32.480 --> 00:11:37.220
带有相同的文件名

00:11:34.720 --> 00:11:38.540
我们将他们与众不同

00:11:37.220 --> 00:11:38.930
不想让他们都覆盖每个

00:11:38.540 --> 00:11:40.880
其他

00:11:38.930 --> 00:11:42.980
所以我们要使用一个表达式

00:11:40.880 --> 00:11:45.260
 Spring Expression Language 表达

00:11:42.980 --> 00:11:46.490
提供一个随机数，然后

00:11:45.260 --> 00:11:49.670
我们最初拥有的文件的名称

00:11:46.490 --> 00:11:52.010
好吧，我们在那里

00:11:49.670 --> 00:11:53.030
现在您可以看到此处的用户界面是

00:11:52.010 --> 00:11:55.520
有点麻烦

00:11:53.030 --> 00:11:57.290
 Spring Expression Language 声明

00:11:55.520 --> 00:11:59.180
问题，我们只是引用它， 

00:11:57.290 --> 00:12:00.950
现在一切似乎都在整理

00:11:59.180 --> 00:12:02.810
这当然很有趣，但是

00:12:00.950 --> 00:12:05.300
这是你知道的，这就是我们所管理的

00:12:02.810 --> 00:12:08.360
上次要做的，让我们一起去

00:12:05.300 --> 00:12:10.130
更有趣的解决方案，所以

00:12:08.360 --> 00:12:11.000
如果我们能接受的话

00:12:10.130 --> 00:12:14.060
将要从文件中产生

00:12:11.000 --> 00:12:15.950
来源，然后自动大写

00:12:14.060 --> 00:12:17.750
他们使用处理器，变压器

00:12:15.950 --> 00:12:21.880
特别的，让我们继续进行排序

00:12:17.750 --> 00:12:24.260
通过断开连接到流中

00:12:21.880 --> 00:12:29.570
将此组件连接到该组件，然后连接

00:12:24.260 --> 00:12:32.570
它代替这个和那个，所以现在如果

00:12:29.570 --> 00:12:34.760
我们来看文件模式是行

00:12:32.570 --> 00:12:35.810
目录是相同的文本向上的文本是

00:12:34.760 --> 00:12:38.360
相同的东西基本上是

00:12:35.810 --> 00:12:40.730
一样，但我们必须提供

00:12:38.360 --> 00:12:44.450
变压器，这是什么期望

00:12:40.730 --> 00:12:46.400
是spring春天的表达语言

00:12:44.450 --> 00:12:52.340
声明将向

00:12:46.400 --> 00:12:55.700
例如大写，点击确定，我们

00:12:52.340 --> 00:12:59.450
 FTP组件将正常工作

00:12:55.700 --> 00:13:01.370
一切都如我们所愿

00:12:59.450 --> 00:13:02.900
也可以想像要记录数据

00:13:01.370 --> 00:13:06.110
从这个变压器出来的

00:13:02.900 --> 00:13:09.080
确实是文件源，所以在这种情况下

00:13:06.110 --> 00:13:12.560
我们可以使用一种叫做水龙头的东西

00:13:09.080 --> 00:13:14.390
从消息中获取数据的方式

00:13:12.560 --> 00:13:18.020
生产成分，即aa 

00:13:14.390 --> 00:13:19.580
源或处理器，但不接收器和

00:13:18.020 --> 00:13:22.550
然后将其转移到其他

00:13:19.580 --> 00:13:24.590
组件，例如一个日志接收器

00:13:22.550 --> 00:13:27.470
我们可以通过抓住水龙头端口来做到这一点

00:13:24.590 --> 00:13:29.270
在这里并将其连接到日志

00:13:27.470 --> 00:13:33.530
好的，所以我们在那里

00:13:29.270 --> 00:13:35.510
还有我们稍微复杂一点的

00:13:33.530 --> 00:13:37.430
你可以看到春天的定义

00:13:35.510 --> 00:13:40.490
数据电话弹簧云和弹簧流量

00:13:37.430 --> 00:13:42.800
给了我们的流定义名称

00:13:40.490 --> 00:13:44.750
对我们来说，这个名字用来

00:13:42.800 --> 00:13:47.210
在这里描述水龙头，所以我们说

00:13:44.750 --> 00:13:50.360
来自称为转换的组件

00:13:47.210 --> 00:13:52.880
流内称为流一的流

00:13:50.360 --> 00:13:55.610
日志组件右侧的信息

00:13:52.880 --> 00:13:57.530
日志组件，我们可以再次做

00:13:55.610 --> 00:13:59.570
您可以指定级别，例如

00:13:57.530 --> 00:14:02.320
我们可以指定某种表达式

00:13:59.570 --> 00:14:04.640
正确转换数据

00:14:02.320 --> 00:14:06.560
好吧，所以我们在那里

00:14:04.640 --> 00:14:10.010
简单的定义，让我们继续前进， 

00:14:06.560 --> 00:14:14.390
创建该流或什至那些流

00:14:10.010 --> 00:14:21.260
我们将把这个文件称为FTP 

00:14:14.390 --> 00:14:24.260
我们将呼叫此行进行记录

00:14:21.260 --> 00:14:25.610
当我们创建

00:14:24.260 --> 00:14:28.010
我们也可能在同一定义上

00:14:25.610 --> 00:14:30.620
俯冲而去

00:14:28.010 --> 00:14:31.670
部署它们，让我们开始创建它

00:14:30.620 --> 00:14:32.240
要去创造我们的流

00:14:31.670 --> 00:14:34.520
为了我们

00:14:32.240 --> 00:14:37.220
我们可以通过转到

00:14:34.520 --> 00:14:39.010
流页面，我们可以在这里看到

00:14:37.220 --> 00:14:41.030
有两件事正在部署

00:14:39.010 --> 00:14:43.160
有些国家应该过渡到

00:14:41.030 --> 00:14:45.350
现在随时可以部署

00:14:43.160 --> 00:14:47.480
部署只是意味着启动Java 

00:14:45.350 --> 00:14:49.880
在本地计算机上使用jar进行处理

00:14:47.480 --> 00:14:51.230
所以我们有两个流

00:14:49.880 --> 00:14:53.450
转由几个不同的组成

00:14:51.230 --> 00:14:55.280
因此即使我们有两个

00:14:53.450 --> 00:14:56.990
在这里流可能变成五个或

00:14:55.280 --> 00:15:00.260
六个或四个或五个或任何其他

00:14:56.990 --> 00:15:01.910
我猜是不同的Java进程

00:15:00.260 --> 00:15:03.770
我必须解析以找出答案

00:15:01.910 --> 00:15:05.450
所以他们都已经部署了，我们可以看到

00:15:03.770 --> 00:15:07.250
到底有多少人被部署

00:15:05.450 --> 00:15:10.220
去运行时，你还没有

00:15:07.250 --> 00:15:12.620
你知道我们是否做过PSA UX 

00:15:10.220 --> 00:15:14.420
 Java流程的四个流程

00:15:12.620 --> 00:15:16.310
我们不知道这就是为什么

00:15:14.420 --> 00:15:18.380
这就是这四个过程

00:15:16.310 --> 00:15:20.780
四件事，如果我们点击这些，我们可以

00:15:18.380 --> 00:15:23.180
看到该组件正在运行

00:15:20.780 --> 00:15:25.460
有一个标准的错误日志和一个标准

00:15:23.180 --> 00:15:26.840
退出日志，我们可以看到淡水河谷的URL 

00:15:25.460 --> 00:15:30.200
 bot和其中的工作目录

00:15:26.840 --> 00:15:31.880
它正在运行，标准错误和

00:15:30.200 --> 00:15:34.250
标准输出对于

00:15:31.880 --> 00:15:35.840
日志组件，因为毕竟

00:15:34.250 --> 00:15:38.870
将记录我们看到的数据

00:15:35.840 --> 00:15:41.090
让我们在那里获取该URL，然后关闭

00:15:38.870 --> 00:15:42.380
让我们设置好舞台，以便我们

00:15:41.090 --> 00:15:45.920
在本地计算机上运行的FTP服务器

00:15:42.380 --> 00:15:47.190
在后台，我们有一个桌面

00:15:45.920 --> 00:15:49.230
在这里和

00:15:47.190 --> 00:15:53.900
放目录什么都没有，让我们

00:15:49.230 --> 00:15:56.040
在此处监视此组件的日志

00:15:53.900 --> 00:15:59.190
这样就可以运行了

00:15:56.040 --> 00:16:02.250
日志同步Rabbit应用程序已启动并且

00:15:59.190 --> 00:16:05.820
为我们而奔跑，我们将要做什么

00:16:02.250 --> 00:16:09.720
是我们要在其中写入一些数据

00:16:05.820 --> 00:16:11.370
文本文件，然后写入该文本文件

00:16:09.720 --> 00:16:13.740
到输入目录，所以我将

00:16:11.370 --> 00:16:17.480
用小写字母写一些名字

00:16:13.740 --> 00:16:22.440
说马克和乔希，马克和德和

00:16:17.480 --> 00:16:25.890
迈克尔·迈克尔（Michael Michael）和伊莉亚（Illya）以及埃里克（Eric）和

00:16:22.440 --> 00:16:28.800
如此将名称保存到输入

00:16:25.890 --> 00:16:31.740
目录名称点txt这些都是

00:16:28.800 --> 00:16:33.900
小写字母也保存在那里

00:16:31.740 --> 00:16:36.120
 ws目录中没有任何内容或单词

00:16:33.900 --> 00:16:37.410
在FTP WS目录下， 

00:16:36.120 --> 00:16:39.390
保存这一点，我们应该能够去

00:16:37.410 --> 00:16:41.010
 FTP目录并确认

00:16:39.390 --> 00:16:46.320
一切都写成大写

00:16:41.010 --> 00:16:48.240
 o桌面FTP WS现在拥有所有功能

00:16:46.320 --> 00:16:50.130
文件，但没有任何新行

00:16:48.240 --> 00:16:56.570
因此，让我们转到桌面FTP WS 

00:16:50.130 --> 00:17:01.260
目录并找到每个结尾为

00:16:56.570 --> 00:17:04.380
 txt，我们将遍历每一个点击它们

00:17:01.260 --> 00:17:05.579
然后回显新行，然后被

00:17:04.380 --> 00:17:07.709
完成它，所以我们就在那里

00:17:05.579 --> 00:17:09.689
名称，但现在它们是大写的，所以

00:17:07.709 --> 00:17:11.520
这是我们创造的一种方式

00:17:09.689 --> 00:17:13.680
复杂的流程是使用视觉

00:17:11.520 --> 00:17:15.209
设计时间工具非常有用

00:17:13.680 --> 00:17:17.459
因为您可以讯问

00:17:15.209 --> 00:17:18.750
您可以使用的应用程序状态

00:17:17.459 --> 00:17:21.870
可以管理他们，所以同样如此

00:17:18.750 --> 00:17:24.209
对于任务，您实际上只是注册了一个

00:17:21.870 --> 00:17:26.850
像你一样在罐子里做Spring Batch处理工作

00:17:24.209 --> 00:17:28.560
我们的组件可以在这里吗

00:17:26.850 --> 00:17:30.500
注册一个应用程序，它可能是

00:17:28.560 --> 00:17:33.440
我们可以在此处看到的类型任务

00:17:30.500 --> 00:17:35.190
或任何可以实施的

00:17:33.440 --> 00:17:38.760
应用程序运行程序或命令行

00:17:35.190 --> 00:17:40.950
天气虽然这也是一个任务

00:17:38.760 --> 00:17:42.480
是一种讯问和合作的方式

00:17:40.950 --> 00:17:46.320
服务器的另一个是使用

00:17:42.480 --> 00:17:48.420
数据流外壳程序，所以到目前为止

00:17:46.320 --> 00:17:49.500
使用视觉设计创造事物

00:17:48.420 --> 00:17:51.210
工具，因为我认为这非常好

00:17:49.500 --> 00:17:53.670
工作方式，但也有数据流

00:17:51.210 --> 00:17:59.490
显示您可以下载的示例

00:17:53.670 --> 00:18:02.430
在Maven Repo com上

00:17:59.490 --> 00:18:04.080
或搜索该组织的专家

00:18:02.430 --> 00:18:06.840
最新版本是一个数据一个

00:18:04.080 --> 00:18:08.550
截至该日期发布，但您知道

00:18:06.840 --> 00:18:10.320
随时回来找我

00:18:08.550 --> 00:18:15.720
这里有罐子，所以我可以说约翰- 

00:18:10.320 --> 00:18:18.630
罐子壳，罐子在那里，我是

00:18:15.720 --> 00:18:20.580
将默认连接到93 91 93 93 

00:18:18.630 --> 00:18:22.230
服务器正在运行，但是

00:18:20.580 --> 00:18:24.540
您可以指定应该在哪里找到

00:18:22.230 --> 00:18:25.710
我可以看到的所有应用列表

00:18:24.540 --> 00:18:27.660
所有的组件

00:18:25.710 --> 00:18:30.420
开箱即用在这里注册

00:18:27.660 --> 00:18:32.100
使用我可以看到流写相同

00:18:30.420 --> 00:18:34.050
所有相同的信息

00:18:32.100 --> 00:18:38.490
我们使用，审讯和工作的

00:18:34.050 --> 00:18:40.320
在数据流中

00:18:38.490 --> 00:18:42.570
服务器本身可从

00:18:40.320 --> 00:18:44.400
外壳，任何人都可以指出他们的外壳

00:18:42.570 --> 00:18:45.570
到服务器的实例，即使您

00:18:44.400 --> 00:18:49.590
没有访问服务器本身的权限

00:18:45.570 --> 00:18:51.450
直接就可以了

00:18:49.590 --> 00:18:52.650
看起来如此简短以及如何创建

00:18:51.450 --> 00:18:54.270
真的很有趣

00:18:52.650 --> 00:18:56.910
我们研究过的解决方案

00:18:54.270 --> 00:18:58.200
建立在我们从视频中学到的知识的基础上

00:18:56.910 --> 00:19:00.360
看着春天的云数据流和

00:18:58.200 --> 00:19:02.700
春天的云流和春天

00:19:00.360 --> 00:19:04.800
整合真的很不错

00:19:02.700 --> 00:19:06.240
复杂的流处理解决方案

00:19:04.800 --> 00:19:09.330
潜在的无穷数据量

00:19:06.240 --> 00:19:11.610
或批处理或任务怪异的

00:19:09.330 --> 00:19:13.040
工作量，因为春季云数据流

00:19:11.610 --> 00:19:15.630
管理状态，我们有一个简单的方法

00:19:13.040 --> 00:19:18.570
监视和管理这些工作

00:19:15.630 --> 00:19:21.450
我们可以启动任务的任务

00:19:18.570 --> 00:19:23.460
穿着容易穿上衣服

00:19:21.450 --> 00:19:26.040
了解方式，很容易看到

00:19:23.460 --> 00:19:28.590
很容易看到我们如何建立

00:19:26.040 --> 00:19:29.910
通过组成更复杂的解决方案

00:19:28.590 --> 00:19:31.560
这些小乐高积木对，这是

00:19:29.910 --> 00:19:34.380
甚至没有编码我在这里所做的

00:19:31.560 --> 00:19:36.150
真的，我的意思是你可以建立

00:19:34.380 --> 00:19:38.220
适用于任何用途的复杂解决方案

00:19:36.150 --> 00:19:41.580
案子，我很喜欢补救

00:19:38.220 --> 00:19:44.160
想象一下建立一个流程

00:19:41.580 --> 00:19:45.420
查看了来自Cloud的日志

00:19:44.160 --> 00:19:47.030
例如铸造厂就可以

00:19:45.420 --> 00:19:49.460
注册Cloud Foundry laga Gator 

00:19:47.030 --> 00:19:52.980
源，然后您可以编写一个

00:19:49.460 --> 00:19:55.830
仅保留数据的处理器

00:19:52.980 --> 00:19:58.620
匹配某种格式然后写

00:19:55.830 --> 00:20:00.780
一个你知道的数据，然后写

00:19:58.620 --> 00:20:02.880
在这种情况下，它会流到水槽

00:20:00.780 --> 00:20:05.700
价值计数器，因此您实际上可以保留

00:20:02.880 --> 00:20:07.080
 Redis中的计数器，每次出现

00:20:05.700 --> 00:20:08.940
通过该处理器的消息

00:20:07.080 --> 00:20:10.400
那基本上可以做grep，所以现在你

00:20:08.940 --> 00:20:11.660
有一个简单的方法

00:20:10.400 --> 00:20:13.070
你知道基于那个计数器

00:20:11.660 --> 00:20:15.110
另一个流程，你可以说好吗

00:20:13.070 --> 00:20:16.430
然后计数器变得大于十

00:20:15.110 --> 00:20:18.230
也许我们应该发送电子邮件或

00:20:16.430 --> 00:20:20.240
有人应该我们启动服务器或

00:20:18.230 --> 00:20:21.770
正确的事情很容易

00:20:20.240 --> 00:20:23.210
把这些东西拉在一起

00:20:21.770 --> 00:20:25.790
声明上正确，您可以描述

00:20:23.210 --> 00:20:27.530
临时流动，即使您没有

00:20:25.790 --> 00:20:30.440
想到所有可能的整合

00:20:27.530 --> 00:20:33.290
流程，您可以进行一些返工和创建

00:20:30.440 --> 00:20:37.150
新的飞行中，好的，谢谢

00:20:33.290 --> 00:20:37.150
非常期待在下一个视频中见到您

00:20:42.650 --> 00:20:44.710
您

