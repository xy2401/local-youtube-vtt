WEBVTT
Kind: captions
Language: zh-Hans

00:00:26.400 --> 00:00:30.970
欢迎来到 Spring 的另一期

00:00:28.630 --> 00:00:32.829
在本周分期付款中的提示

00:00:30.970 --> 00:00:34.480
去看一下Spring Cloud Gateway 

00:00:32.829 --> 00:00:36.309
 Spring Cloud Gateway是一项新技术

00:00:34.480 --> 00:00:38.350
旨在提供很多

00:00:36.309 --> 00:00:39.640
相同的网关样式功能

00:00:38.350 --> 00:00:43.030
您可能曾经熟悉过

00:00:39.640 --> 00:00:44.440
在本期中使用Netflix Zul 

00:00:43.030 --> 00:00:47.320
我们将看一些功能

00:00:44.440 --> 00:00:48.970
在Spring Cloud Gateway提供的

00:00:47.320 --> 00:00:51.040
盒子里的一些你

00:00:48.970 --> 00:00:52.480
可能无法在Netflix中找到

00:00:51.040 --> 00:00:54.820
是蔚蓝

00:00:52.480 --> 00:00:57.129
现在可能会出现问题，为什么

00:00:54.820 --> 00:00:59.949
我们是否创建了 Spring 洪水门户，如果

00:00:57.129 --> 00:01:03.460
我们已经有了Netflix变焦

00:00:59.949 --> 00:01:05.670
首先是Netflix的原因数量

00:01:03.460 --> 00:01:08.110
祖尔（Zul）本身并没有真正看到很多

00:01:05.670 --> 00:01:09.939
尚未进化的某种进化

00:01:08.110 --> 00:01:13.210
最近没有进步很多

00:01:09.939 --> 00:01:14.770
最近一次，所以我们不确定

00:01:13.210 --> 00:01:17.560
该项目的进行我们知道Netflix 

00:01:14.770 --> 00:01:18.700
还老了还不在这里，那是一个

00:01:17.560 --> 00:01:20.320
释放本来应该更多

00:01:18.700 --> 00:01:22.780
与我们希望拥有的一致

00:01:20.320 --> 00:01:24.670
包括对整合的支持

00:01:22.780 --> 00:01:27.670
与诸如

00:01:24.670 --> 00:01:28.780
示例反应堆，结果

00:01:27.670 --> 00:01:30.009
它没有某些功能

00:01:28.780 --> 00:01:31.960
你知道很多人的工作

00:01:30.009 --> 00:01:33.880
一直在呼吁包括支持

00:01:31.960 --> 00:01:38.679
代理其他类型的协议，例如

00:01:33.880 --> 00:01:40.270
 WebSockets以及一种

00:01:38.679 --> 00:01:42.670
更灵活的组件模型

00:01:40.270 --> 00:01:45.429
我们想要的很多这些东西

00:01:42.670 --> 00:01:47.200
解决方案中的某种整合

00:01:45.429 --> 00:01:49.329
没有他们都是如此，非常你

00:01:47.200 --> 00:01:51.340
非常了解你也会

00:01:49.329 --> 00:01:53.560
发现Netflix Zul无法打开

00:01:51.340 --> 00:01:55.119
采购很多真正有用的东西

00:01:53.560 --> 00:01:57.549
诸如限速器之类的东西

00:01:55.119 --> 00:01:59.350
 Netflix专有的内容

00:01:57.549 --> 00:02:02.229
这是他们自己做的方式

00:01:59.350 --> 00:02:03.999
可能当然，也可能不是最好的

00:02:02.229 --> 00:02:05.679
所有人的解决方案，自然而然

00:02:03.999 --> 00:02:07.299
完全可以理解的是

00:02:05.679 --> 00:02:09.310
一直开源，直到我们知道

00:02:07.299 --> 00:02:10.899
作为一个社区并被迫捍卫

00:02:09.310 --> 00:02:12.220
我们自己，这没什么大不了，但

00:02:10.899 --> 00:02:14.980
那就是你可以得到的那些东西之一

00:02:12.220 --> 00:02:15.910
在 Spring Cloud 网关中开箱即用

00:02:14.980 --> 00:02:17.980
让我们来看看我们要

00:02:15.910 --> 00:02:19.630
看看今天，但在我们之前

00:02:17.980 --> 00:02:21.940
建立边缘服务，让我们建立一个

00:02:19.630 --> 00:02:23.500
与之对话的下游服务

00:02:21.940 --> 00:02:25.000
为了交谈以发现它

00:02:23.500 --> 00:02:26.350
找到它，我们将站起来

00:02:25.000 --> 00:02:29.380
服务注册表，因此我们将首先这样做

00:02:26.350 --> 00:02:30.970
在这里创建一个尤里卡服务

00:02:29.380 --> 00:02:36.490
像往常一样右击并产生

00:02:30.970 --> 00:02:38.650
我们将在这里转到我们的IDE 

00:02:36.490 --> 00:02:42.130
我要在这里打开它

00:02:38.650 --> 00:02:46.750
我们的ID，它将对

00:02:42.130 --> 00:02:48.640
一个使其可用，以便其他

00:02:46.750 --> 00:02:49.870
微服务，包括服务

00:02:48.640 --> 00:02:51.970
那将要建立的和我们的优势

00:02:49.870 --> 00:02:54.130
服务我们的网关可以找到两件事

00:02:51.970 --> 00:02:55.660
对，所以首先要做的是

00:02:54.130 --> 00:02:57.010
使这个应用成为 Spring 

00:02:55.660 --> 00:03:00.700
 spring boot 应用的心情

00:02:57.010 --> 00:03:04.180
在端口87-61上运行我要说的是

00:03:00.700 --> 00:03:06.010
尤里卡（Eureka）可以向自己注册

00:03:04.180 --> 00:03:07.510
自己和魔鬼说那是假的

00:03:06.010 --> 00:03:09.400
以及我在获取时要查找的内容

00:03:07.510 --> 00:03:11.440
注册表不需要我们是注册表所以

00:03:09.400 --> 00:03:13.240
我们会做到这两者或做得更好

00:03:11.440 --> 00:03:14.710
不做那些我要说的名字

00:03:13.240 --> 00:03:16.090
 Rica服务器现在可以吗

00:03:14.710 --> 00:03:17.920
应该是正确的，我们在这里

00:03:16.090 --> 00:03:20.170
 classpathSpring 卡启动器尤里卡

00:03:17.920 --> 00:03:23.260
服务器，因此请相信并开始

00:03:20.170 --> 00:03:25.240
现在将在端口87-61上

00:03:23.260 --> 00:03:26.830
一旦完成，我们现在可以建立一个

00:03:25.240 --> 00:03:30.370
客服谈谈

00:03:26.830 --> 00:03:32.440
现在，该服务将使用新的

00:03:30.370 --> 00:03:37.600
最新和最大的服务响应位

00:03:32.440 --> 00:03:41.790
所以我们用2.0和6来做 spring boot 

00:03:37.600 --> 00:03:44.740
我们使用的反应式Web反应式MongoDB 

00:03:41.790 --> 00:03:46.300
 lombok 自然，我不需要

00:03:44.740 --> 00:03:48.550
我们希望您能获得尤里卡的服务器支持

00:03:46.300 --> 00:03:51.160
 Iike发现，所以我们将其引入

00:03:48.550 --> 00:03:52.900
否则我认为就是这样

00:03:51.160 --> 00:03:54.010
您可能知道执行器可能

00:03:52.900 --> 00:03:59.560
一个好主意，所以我们有那些

00:03:54.010 --> 00:04:07.990
让我们点击生成并打开它

00:03:59.560 --> 00:04:08.950
客户服务还好，所以第一件事

00:04:07.990 --> 00:04:11.050
首先，我们要给它起个名字

00:04:08.950 --> 00:04:13.720
 Spring 申请名称等于客户

00:04:11.050 --> 00:04:16.900
 -服务，然后是客户服务

00:04:13.720 --> 00:04:18.100
本身要参加

00:04:16.900 --> 00:04:20.410
服务注册和发现权

00:04:18.100 --> 00:04:21.220
现在截至 Spring Finchley 

00:04:20.410 --> 00:04:23.530
这就是我们在

00:04:21.220 --> 00:04:24.820
我们不再需要classpath 

00:04:23.530 --> 00:04:26.440
将发现客户端注释正确

00:04:24.820 --> 00:04:27.220
你可能已经习惯了

00:04:26.440 --> 00:04:29.530
那样做

00:04:27.220 --> 00:04:30.670
那不再需要了

00:04:29.530 --> 00:04:32.220
放置正确，所以当我们开始这个

00:04:30.670 --> 00:04:34.840
应用程序将注册自己

00:04:32.220 --> 00:04:36.490
与服务注册表，所以再次

00:04:34.840 --> 00:04:38.320
将成为一个应用程序管理什么

00:04:36.490 --> 00:04:40.690
客户类型的实体只是一个

00:04:38.320 --> 00:04:44.640
稻草人的例子在这里强而有力

00:04:40.690 --> 00:04:47.390
因此，私有字符串ID私有字符串名称

00:04:44.640 --> 00:04:50.570
假设一个ID 

00:04:47.390 --> 00:04:55.490
并记录那里，我们在那里

00:04:50.570 --> 00:04:57.110
现在我们需要一个at数据

00:04:55.490 --> 00:04:59.000
构造函数在没有构造的地方

00:04:57.110 --> 00:05:01.040
这里所有来自 lombok 的人

00:04:59.000 --> 00:05:02.090
合成构造函数Gator setter 

00:05:01.040 --> 00:05:04.190
两种字符串方法

00:05:02.090 --> 00:05:05.900
的东西，当然我们需要一些东西

00:05:04.190 --> 00:05:09.140
用它来操纵

00:05:05.900 --> 00:05:14.060
这种类型，因此创建存储库扩展

00:05:09.140 --> 00:05:15.440
反应性Mongo存储库管理

00:05:14.060 --> 00:05:17.720
主要客户的类型客户的实体

00:05:15.440 --> 00:05:21.200
类型为long的键，然后我们将保存

00:05:17.720 --> 00:05:23.810
来自数据库中的数据，因此它将是

00:05:21.200 --> 00:05:26.740
应用程序运行器，我们要

00:05:23.810 --> 00:05:28.700
在这里注入客户资料库

00:05:26.740 --> 00:05:32.270
我们会说回报

00:05:28.700 --> 00:05:38.720
 CR开始写了一个返回参数，我们

00:05:32.270 --> 00:05:47.690
要说CR删除所有然后C然后

00:05:38.720 --> 00:05:51.490
我们会说助焊剂只是abc映射到您

00:05:47.690 --> 00:05:55.970
在这里认识一个新的客户对象

00:05:51.490 --> 00:06:00.770
的ID为l 

00:05:55.970 --> 00:06:04.450
命名，然后将其映射到记录

00:06:00.770 --> 00:06:08.990
我们像这样保存在数据库中

00:06:04.450 --> 00:06:11.600
然后我要说CR找到所有

00:06:08.990 --> 00:06:16.220
它将订阅系统

00:06:11.600 --> 00:06:18.860
打印行还不错，所以我们到了

00:06:16.220 --> 00:06:20.060
现在数据库中有我们的日期

00:06:18.860 --> 00:06:21.140
想要有一个端点来

00:06:20.060 --> 00:06:22.790
访问这些东西，我们将采取

00:06:21.140 --> 00:06:25.190
Spring 一弯曲的优点

00:06:22.790 --> 00:06:26.510
反应式Web运行时而不是Spring 

00:06:25.190 --> 00:06:32.000
框架5，所以我们说路由器

00:06:26.510 --> 00:06:35.990
功能路由器功能路由路由

00:06:32.000 --> 00:06:40.430
打开功能点路由器

00:06:35.990 --> 00:06:45.320
请求predicate先获取

00:06:40.430 --> 00:06:47.960
当然终点是客户，所以

00:06:45.320 --> 00:06:50.600
我想说一个请求然后返回

00:06:47.960 --> 00:06:53.570
响应，以便服务器响应点ok点

00:06:50.600 --> 00:06:57.170
身体，我们要注入客户

00:06:53.570 --> 00:06:58.830
储存库在这里做我们的工作，所以CR CR 

00:06:57.170 --> 00:07:03.270
找到所有

00:06:58.830 --> 00:07:05.460
客户点类就是这样，我们

00:07:03.270 --> 00:07:07.470
还有其他路线，让我们

00:07:05.460 --> 00:07:13.460
整理东西简化事情

00:07:07.470 --> 00:07:13.460
有点在这里，所以摆脱所有的好处

00:07:15.740 --> 00:07:27.389
还有我们想要得到什么

00:07:20.479 --> 00:07:32.190
客户ID可以的点体CR 

00:07:27.389 --> 00:07:34.919
找到我的身份证，我会说客户网

00:07:32.190 --> 00:07:37.380
上课，我们很好，我们想要一个

00:07:34.919 --> 00:07:39.300
更多端点，这将是

00:07:37.380 --> 00:07:42.810
这将是我们可以做的

00:07:39.300 --> 00:07:45.530
用于引入延迟，因此我们只调用

00:07:42.810 --> 00:07:49.169
只是我们称之为延迟而已

00:07:45.530 --> 00:07:51.750
我们要说的只是一个请求

00:07:49.169 --> 00:07:53.370
你好，世界

00:07:51.750 --> 00:08:00.449
延迟时可以提出要求

00:07:53.370 --> 00:08:04.110
元素就在那里10秒

00:08:00.449 --> 00:08:06.060
我们是，我们将返回这个

00:08:04.110 --> 00:08:13.080
整个事情都推迟了

00:08:06.060 --> 00:08:15.659
作为回应，所以点体还可以

00:08:13.080 --> 00:08:18.979
像这样回来我们在那里

00:08:15.659 --> 00:08:18.979
我们的端点，看看是否一切正常

00:08:22.520 --> 00:08:25.760
好吧

00:08:37.159 --> 00:08:40.719
那里我们还好

00:08:46.020 --> 00:08:54.850
不对，我们可以在这里进入控制台

00:08:49.020 --> 00:08:58.150
卷曲HTP localhost ：8080这样

00:08:54.850 --> 00:09:08.370
客户似乎还可以，让我们尝试

00:08:58.150 --> 00:09:11.320
特别的记录在这里

00:09:08.370 --> 00:09:14.770
有一个记录让我们证明

00:09:11.320 --> 00:09:20.110
点的延迟是一两个

00:09:14.770 --> 00:09:25.150
三四五六七七八九十

00:09:20.110 --> 00:09:27.160
有没有我们可以

00:09:25.150 --> 00:09:29.250
所以有一张唱片就这样

00:09:27.160 --> 00:09:31.420
所有的端点都在工作

00:09:29.250 --> 00:09:34.510
我们将看看为什么我们需要延迟

00:09:31.420 --> 00:09:36.370
稍等一下就可以了

00:09:34.510 --> 00:09:38.800
现在我们有了三个不同的终点

00:09:36.370 --> 00:09:41.700
我们可以使用它，因为我们就是我们知道的

00:09:38.800 --> 00:09:44.620
如果您愿意我们的反馈意见

00:09:41.700 --> 00:09:46.180
机制，现在让我们建立一个优势

00:09:44.620 --> 00:09:47.200
源，所以我要回去开始

00:09:46.180 --> 00:09:48.490
 Spring ，我们将使用

00:09:47.200 --> 00:09:50.410
最新的最大 Spring 

00:09:48.490 --> 00:09:53.170
将要使用执行器或使用

00:09:50.410 --> 00:09:55.450
它使用的网关支持

00:09:53.170 --> 00:10:01.300
反应式网络支持

00:09:55.450 --> 00:10:04.870
所以反应性的网站，我想用别的

00:10:01.300 --> 00:10:08.700
我们需要吗我们需要安全

00:10:04.870 --> 00:10:16.650
支持，让我们在这里看看

00:10:08.700 --> 00:10:19.390
安全，需要Redis支持，我

00:10:16.650 --> 00:10:22.000
认为那会做我认为就足够了

00:10:19.390 --> 00:10:24.280
让我检查一下让我考虑一下

00:10:22.000 --> 00:10:26.770
在这里，我们有反应性的网络支持

00:10:24.280 --> 00:10:31.930
我们有安全，我们想要历史

00:10:26.770 --> 00:10:33.700
支持断路器，红色为

00:10:31.930 --> 00:10:35.500
网络看起来还不错

00:10:33.700 --> 00:10:37.360
哦，尤里卡（Eureka）当然需要

00:10:35.500 --> 00:10:39.130
当然，这也是很好

00:10:37.360 --> 00:10:41.260
我将其称为边缘服务

00:10:39.130 --> 00:10:42.850
这当然会与

00:10:41.260 --> 00:10:45.310
我们的下游客户服务

00:10:42.850 --> 00:10:47.650
通过服务注册表完全一样

00:10:45.310 --> 00:10:51.570
我们刚站起来的那一副

00:10:47.650 --> 00:10:51.570
我们服务

00:10:54.040 --> 00:11:00.080
好的，所以我们有一个新的应用程序

00:10:57.350 --> 00:11:02.690
让我们看看边缘服务应用程序

00:11:00.080 --> 00:11:04.300
申请将是 Spring 

00:11:02.690 --> 00:11:07.220
 cloud Gateway项目，如果您曾经使用过

00:11:04.300 --> 00:11:08.360
带有 Spring Cloud 的Netflix Zul，然后您

00:11:07.220 --> 00:11:11.540
知道你可以做的一件好事

00:11:08.360 --> 00:11:13.880
就是说启用Zul服务器，或者

00:11:11.540 --> 00:11:15.230
无法双重代理，它将

00:11:13.880 --> 00:11:17.540
自动为您设置路线

00:11:15.230 --> 00:11:20.360
映射到

00:11:17.540 --> 00:11:22.520
路由在服务注册表中，因此我们可以

00:11:20.360 --> 00:11:24.410
得到与第一个相似的效果

00:11:22.520 --> 00:11:26.120
都参加服务注册

00:11:24.410 --> 00:11:27.350
通过说你知道而发现

00:11:26.120 --> 00:11:28.730
给它起个名字，我们也想

00:11:27.350 --> 00:11:30.830
区分我们的港口，否则我们会

00:11:28.730 --> 00:11:33.110
发生端口冲突，我们可以得到

00:11:30.830 --> 00:11:36.860
只是通过做路线，然后

00:11:33.110 --> 00:11:39.650
我们可以做发现客户路线

00:11:36.860 --> 00:11:42.500
定义定位器，因此您知道DS 

00:11:39.650 --> 00:11:43.870
发现路线，当然是有序的

00:11:42.500 --> 00:11:46.670
为我们进行配置，我们需要一个

00:11:43.870 --> 00:11:50.000
发现客户，我说新发现

00:11:46.670 --> 00:11:52.220
客户端路由定义定位器全部

00:11:50.000 --> 00:11:54.910
好的，让我们看看您跑步时会得到什么

00:11:52.220 --> 00:11:54.910
这个应用程序

00:12:02.850 --> 00:12:08.830
现在已经可以看到

00:12:06.490 --> 00:12:15.459
问题我已经看到一个问题

00:12:08.830 --> 00:12:19.420
因为我们首先没有安全性

00:12:15.459 --> 00:12:23.829
很好，所以那个实例没有用

00:12:19.420 --> 00:12:28.560
所以我们的服务注册表不是87-61 

00:12:23.829 --> 00:12:28.560
现在跑步为什么不

00:12:44.280 --> 00:12:47.950
好的

00:12:45.580 --> 00:12:50.680
我忽略了开始之前

00:12:47.950 --> 00:12:52.900
进入它，所以现在很快乐

00:12:50.680 --> 00:12:57.910
客户服务令我们满意

00:12:52.900 --> 00:12:59.020
启动它，它仍然会失败

00:12:57.910 --> 00:13:01.240
我刚才提到的原因是

00:12:59.020 --> 00:13:03.580
我们忘记了为

00:13:01.240 --> 00:13:05.260
片刻，让我们回去删除

00:13:03.580 --> 00:13:06.520
我们提供的安全性仅用于

00:13:05.260 --> 00:13:19.710
一会儿我们会把它拿回来

00:13:06.520 --> 00:13:19.710
我们从哪里开始一切正常

00:13:28.410 --> 00:13:33.490
很好，所以如果我们去 localhost 

00:13:32.440 --> 00:13:38.310
卷曲

00:13:33.490 --> 00:13:42.149
他们应该是localhost：8080一

00:13:38.310 --> 00:13:46.149
客户-为此类客户提供服务

00:13:42.149 --> 00:13:48.040
厄瓜多尔看看我们有

00:13:46.149 --> 00:13:49.089
客户被代理

00:13:48.040 --> 00:13:51.579
下游服务，那当然是

00:13:49.089 --> 00:13:54.010
负载平衡了，所以

00:13:51.579 --> 00:13:56.890
相当于单线注释

00:13:54.010 --> 00:13:58.180
在动物园里，但是我们可以做很多事情

00:13:56.890 --> 00:13:59.500
更正确的是实际上有许多

00:13:58.180 --> 00:14:01.779
做更多事情的不同方法

00:13:59.500 --> 00:14:03.310
实际上是一种基于财产的机制

00:14:01.779 --> 00:14:04.750
好吧，我碰巧更喜欢Java 

00:14:03.310 --> 00:14:06.640
配置DSL，所以我想使用

00:14:04.750 --> 00:14:12.880
而有效的方法是您创建一个

00:14:06.640 --> 00:14:18.540
路由定位器对象，因此网关路由

00:14:12.880 --> 00:14:22.450
然后使用路线点定位器点

00:14:18.540 --> 00:14:25.209
 DSL，看起来像这样，所以路由

00:14:22.450 --> 00:14:26.860
定位点的建立，这是在哪里

00:14:25.209 --> 00:14:28.450
我们创建了不同的路线，因此

00:14:26.860 --> 00:14:30.760
创建一个非常简单的路线，只是一个基本的

00:14:28.450 --> 00:14:33.160
代理首先好，这将是

00:14:30.760 --> 00:14:35.440
我们将要呼叫的端点

00:14:33.160 --> 00:14:36.790
开始，这将是一条称为开始的路线

00:14:35.440 --> 00:14:38.320
这将匹配某个

00:14:36.790 --> 00:14:41.050
predicate，有很多事情

00:14:38.320 --> 00:14:43.750
您可以在这里使用predicate

00:14:41.050 --> 00:14:45.670
可以说正确的道路，我想让你知道

00:14:43.750 --> 00:14:50.290
每当有人向

00:14:45.670 --> 00:14:52.360
边缘服务本身，我希望成为

00:14:50.290 --> 00:14:54.730
匹配您知道开始的路径

00:14:52.360 --> 00:14:57.040
等等，我还可以做更多

00:14:54.730 --> 00:14:59.010
我可以做的有趣的事情来接待你

00:14:57.040 --> 00:15:04.390
知道路由请求predicate统计主机

00:14:59.010 --> 00:15:05.740
等于您知道食物平静和连锁

00:15:04.390 --> 00:15:07.990
他们在一起很好所以必须平等

00:15:05.740 --> 00:15:09.970
食物平静，你知道如此疯狂地开始自由

00:15:07.990 --> 00:15:11.980
来然后去到四个斜杠

00:15:09.970 --> 00:15:14.740
就我们而言，因为我没有任何主机

00:15:11.980 --> 00:15:17.380
或为我的本地计算机设置的V主机

00:15:14.740 --> 00:15:19.870
这样做就可以了，所以有我们的要求

00:15:17.380 --> 00:15:22.360
predicate，然后我们需要

00:15:19.870 --> 00:15:24.670
对实际端点的请求，让我们

00:15:22.360 --> 00:15:27.760
就目前而言，代理最幸福的地方

00:15:24.670 --> 00:15:29.620
地球在I / O 4开始 Spring 

00:15:27.760 --> 00:15:31.480
斜线八十好吧，这是一个基本的

00:15:29.620 --> 00:15:33.640
代理我们不是你知道什么时候有人

00:15:31.480 --> 00:15:35.500
去 localhost 8080这样的

00:15:33.640 --> 00:15:37.300
开始，他们将得到的内容

00:15:35.500 --> 00:15:40.110
好像是在此渲染

00:15:37.300 --> 00:15:43.630
机器，所以让我们尝试一下

00:15:40.110 --> 00:15:44.800
 localhost ：8080一个正斜杠开始

00:15:43.630 --> 00:15:46.840
我们在那里

00:15:44.800 --> 00:15:48.820
我们知道一些风格

00:15:46.840 --> 00:15:51.220
工作表和其他链接的资产

00:15:48.820 --> 00:15:53.620
相对于服务器没有

00:15:51.220 --> 00:15:56.260
工作，但这确实是输出

00:15:53.620 --> 00:15:58.660
从实际的Web服务开始

00:15:56.260 --> 00:16:00.010
我们为您免费提供了所有这些

00:15:58.660 --> 00:16:03.120
而且很快就可以看到

00:16:00.010 --> 00:16:05.170
代理完全没有懈怠

00:16:03.120 --> 00:16:06.730
注意，我必须指定端口

00:16:05.170 --> 00:16:08.650
那是让你绊倒的一件事

00:16:06.730 --> 00:16:10.120
记得要指定端口

00:16:08.650 --> 00:16:11.650
它将使用端口8080 

00:16:10.120 --> 00:16:13.420
在这种情况下当然是8081 

00:16:11.650 --> 00:16:14.800
这就是我们正在使用的端口

00:16:13.420 --> 00:16:17.620
不是您想要的所有东西，所以这是一个

00:16:14.800 --> 00:16:19.330
基本代理，你可以做其他种类的

00:16:17.620 --> 00:16:22.000
这里的事情你可能还记得祖尔

00:16:19.330 --> 00:16:26.260
可以使服务员的负载达到平衡

00:16:22.000 --> 00:16:29.700
负载均衡代理正确，所以在这里

00:16:26.260 --> 00:16:33.430
会说我们想得到

00:16:29.700 --> 00:16:36.610
客户正确的DC我想我们可以

00:16:33.430 --> 00:16:41.920
说或那将在那里你去

00:16:36.610 --> 00:16:46.750
predicate将是路径L II和URI 

00:16:41.920 --> 00:16:48.490
这将是LD：客户-服务

00:16:46.750 --> 00:16:50.710
正斜杠客户，所以我们实际上是

00:16:48.490 --> 00:16:54.010
现在利用尤里卡意识

00:16:50.710 --> 00:16:55.240
 URI好吧，这将与

00:16:54.010 --> 00:16:59.080
服务注册表，它将给我们回馈

00:16:55.240 --> 00:17:01.360
结果等它将做我们所要做的

00:16:59.080 --> 00:17:04.360
本来期望但没有

00:17:01.360 --> 00:17:08.110
花很多时间在这里

00:17:04.360 --> 00:17:09.880
我们是说，有客户

00:17:08.110 --> 00:17:13.360
你知道他们那里发生了什么

00:17:09.880 --> 00:17:14.650
客户去了用户 Spring 

00:17:13.360 --> 00:17:15.880
云发现客户端抽象去了

00:17:14.650 --> 00:17:18.520
到服务注册表得到了所有

00:17:15.880 --> 00:17:20.140
服务实例返回，然后传递给

00:17:18.520 --> 00:17:21.610
像缎带一样的东西做客户

00:17:20.140 --> 00:17:22.689
有负载平衡，我们选择了一个

00:17:21.610 --> 00:17:24.610
实例并路由请求

00:17:22.689 --> 00:17:26.050
最终将全部实例设置为

00:17:24.610 --> 00:17:28.089
眨眼间就发生了

00:17:26.050 --> 00:17:29.620
这很方便，所以

00:17:28.089 --> 00:17:31.510
一个非常简单的代理服务器就可以了

00:17:29.620 --> 00:17:38.220
但是我们可以做更多有趣的事情

00:17:31.510 --> 00:17:38.220
好吧，我们可以例如介绍

00:17:38.340 --> 00:17:46.900
自定义过滤器，这样就可以了

00:17:40.810 --> 00:17:50.710
这里是一个自定义过滤器，我们

00:17:46.900 --> 00:17:53.830
要说路线C f1 

00:17:50.710 --> 00:17:58.120
predicate的路径等于2 CF 

00:17:53.830 --> 00:18:01.450
 1，并且URI将实现负载均衡

00:17:58.120 --> 00:18:03.820
客户-为此类客户提供服务

00:18:01.450 --> 00:18:05.080
但是在我们这样做之前，我们需要过滤

00:18:03.820 --> 00:18:06.970
好吧，那些数字方式

00:18:05.080 --> 00:18:09.370
指定您可以旋转指定的过滤器

00:18:06.970 --> 00:18:12.010
它一次想要一个或提供

00:18:09.370 --> 00:18:14.649
他们都按照特定的顺序

00:18:12.010 --> 00:18:15.700
做到这一点，我们的过滤器将是

00:18:14.649 --> 00:18:17.679
非常简单的一个，我们要创建一个

00:18:15.700 --> 00:18:21.820
默认情况下自定义一个，所以我们要说

00:18:17.679 --> 00:18:27.990
交换链等于我们的工作是

00:18:21.820 --> 00:18:33.000
然后回应，所以我们要说一个

00:18:27.990 --> 00:18:35.020
过滤器对不起休息链过滤器

00:18:33.000 --> 00:18:36.159
在这种情况下交换，我们只是

00:18:35.020 --> 00:18:37.539
你知道这就像服务器

00:18:36.159 --> 00:18:40.830
过滤器API，我们将要

00:18:37.539 --> 00:18:43.360
实际递归调用另一个

00:18:40.830 --> 00:18:45.760
过滤链，然后我们

00:18:43.360 --> 00:18:49.390
要处理响应，然后

00:18:45.760 --> 00:18:51.070
我要说的是可运行的单点

00:18:49.390 --> 00:18:52.120
我们要说我要

00:18:51.070 --> 00:18:54.070
提供一个可运行的地方

00:18:52.120 --> 00:18:56.289
处理后运行

00:18:54.070 --> 00:18:59.380
所有下游的处理

00:18:56.289 --> 00:19:00.130
链式过滤器正确，所以我们要做

00:18:59.380 --> 00:19:03.820
这样的话我们要说

00:19:00.130 --> 00:19:08.950
交换点我要说些什么

00:19:03.820 --> 00:19:11.080
回应交流未得到回应

00:19:08.950 --> 00:19:14.049
要将其存储在变量中

00:19:11.080 --> 00:19:16.720
服务器HTTP响应良好

00:19:14.049 --> 00:19:18.250
我会说HTTP响应点状态

00:19:16.720 --> 00:19:20.409
代码，让我们修复它们，我不

00:19:18.250 --> 00:19:23.260
关心它冲突好吧，有它

00:19:20.409 --> 00:19:27.190
应为响应点，异质点

00:19:23.260 --> 00:19:28.630
内容类型媒体类型PDF可以，所以

00:19:27.190 --> 00:19:31.059
这是一个非常简单的过滤器过滤器，所以

00:19:28.630 --> 00:19:34.270
现在有人去四点到五点

00:19:31.059 --> 00:19:37.840
 CF他们应该看到它没有

00:19:34.270 --> 00:19:38.679
返回该状态或内容类型

00:19:37.840 --> 00:19:40.390
那本来可以从

00:19:38.679 --> 00:19:42.220
实际服务和实际服务

00:19:40.390 --> 00:19:44.710
您可能还记得我们当然可以

00:19:42.220 --> 00:19:51.309
去LV，让我们在这里比较一下

00:19:44.710 --> 00:19:53.049
 LV vs. CF如果我们到这里去LV-V 

00:19:51.309 --> 00:19:56.860
详细查看那里的详细信息

00:19:53.049 --> 00:19:58.090
 H为200，内容类型为

00:19:56.860 --> 00:20:00.010
等于在JSON中倡导

00:19:58.090 --> 00:20:02.679
那是原始的网络服务

00:20:00.010 --> 00:20:03.660
基本上，这里我们将使用CF 

00:20:02.679 --> 00:20:06.180
一

00:20:03.660 --> 00:20:07.620
您可以看到我们遇到了4/9冲突， 

00:20:06.180 --> 00:20:10.590
当然，内容类型是PDF 

00:20:07.620 --> 00:20:11.730
在这种情况下，你知道那里没有

00:20:10.590 --> 00:20:13.470
显然没有韵律或理由

00:20:11.730 --> 00:20:15.420
那是胡说八道这不是什么

00:20:13.470 --> 00:20:16.830
实际服务返回了，没有了

00:20:15.420 --> 00:20:18.360
在这种情况下将其寄回的原因是

00:20:16.830 --> 00:20:20.100
只是表明一点正确是

00:20:18.360 --> 00:20:22.050
您可以覆盖或更改行为

00:20:20.100 --> 00:20:23.810
那里的答复，所以再次

00:20:22.050 --> 00:20:26.460
网关是一个解决的好地方

00:20:23.810 --> 00:20:28.980
横切关注点

00:20:26.460 --> 00:20:31.170
身份验证授权zip压缩

00:20:28.980 --> 00:20:33.080
和压缩路由知道

00:20:31.170 --> 00:20:35.400
你想在十字架上做什么

00:20:33.080 --> 00:20:37.620
您可以在一个地方进行服务的方式

00:20:35.400 --> 00:20:38.970
这里的负载均衡

00:20:37.620 --> 00:20:40.770
的东西住在这里的边缘

00:20:38.970 --> 00:20:42.690
应该是您第一个致电的港口

00:20:40.770 --> 00:20:45.480
来自外部的请求

00:20:42.690 --> 00:20:47.340
你知道你真正的客户在跟谁说话

00:20:45.480 --> 00:20:49.020
您的下游服务，以便您可以

00:20:47.340 --> 00:20:49.620
各种交叉的东西

00:20:49.020 --> 00:20:52.980
现在这里

00:20:49.620 --> 00:20:55.800
在这种情况下，我使用了自定义过滤器

00:20:52.980 --> 00:20:57.060
让我们看一个自定义过滤器

00:20:55.800 --> 00:21:00.480
你知道只是使用常规过滤器

00:20:57.060 --> 00:21:02.280
对，所以我们将使用精心定制的

00:21:00.480 --> 00:21:03.300
过滤，但我们不会提供

00:21:02.280 --> 00:21:08.520
这次我们自己的过滤器

00:21:03.300 --> 00:21:15.440
说路线等于让我们看看做了什么

00:21:08.520 --> 00:21:15.440
我在那边过滤哦

00:21:20.559 --> 00:21:30.090
属于这个，我们是

00:21:22.749 --> 00:21:35.409
这里我们说CF 2点predicate路径

00:21:30.090 --> 00:21:37.899
 CF 2和URI当然和我们之前一样

00:21:35.409 --> 00:21:40.590
负载均衡的客户服务

00:21:37.899 --> 00:21:44.499
端点，因为为什么不

00:21:40.590 --> 00:21:45.669
我们要在这里做的是

00:21:44.499 --> 00:21:47.590
会利用一些

00:21:45.669 --> 00:21:50.019
开箱即用的，您知道的

00:21:47.590 --> 00:21:51.730
功能在这里，所以也许我会改变

00:21:50.019 --> 00:21:56.950
这条路其实我可能想要这条路

00:21:51.730 --> 00:21:59.110
是CF 2星号星号，我们是

00:21:56.950 --> 00:22:01.059
会说请求将

00:21:59.110 --> 00:22:04.330
独自去客户服务

00:22:01.059 --> 00:22:09.490
而过滤器将是

00:22:04.330 --> 00:22:11.440
重写路径，以便网关过滤点

00:22:09.490 --> 00:22:12.249
重写路径以及我们要做的事情

00:22:11.440 --> 00:22:15.820
是要使用正则表达式

00:22:12.249 --> 00:22:18.249
修改即将到来的请求

00:22:15.820 --> 00:22:21.460
修改请求的路径

00:22:18.249 --> 00:22:23.379
来到边缘然后那条路

00:22:21.460 --> 00:22:26.529
将被发送到

00:22:23.379 --> 00:22:27.789
下游服务正确，所以我们可以

00:22:26.529 --> 00:22:29.409
在这里提供一条路径，但这将是

00:22:27.789 --> 00:22:31.330
忽略对了，它将被替换

00:22:29.409 --> 00:22:33.460
用我们用这里替代的任何东西

00:22:31.330 --> 00:22:37.269
所以我们要说一个请求何时到来

00:22:33.460 --> 00:22:40.960
在我们要说我们想捕捉

00:22:37.269 --> 00:22:41.830
您知道的该客户ID，并且可以

00:22:40.960 --> 00:22:48.970
什么都可以

00:22:41.830 --> 00:22:50.169
这是我们的正则表达式

00:22:48.970 --> 00:22:52.749
永远不会出错

00:22:50.169 --> 00:22:54.970
这将提供替代品，所以我

00:22:52.749 --> 00:22:57.970
想说相反，路径应该是

00:22:54.970 --> 00:22:59.259
我们捕获为客户ID的任何内容

00:22:57.970 --> 00:23:01.749
他们是你知道的

00:22:59.259 --> 00:23:03.490
这条路径的路段将是

00:23:01.749 --> 00:23:05.139
替代提取并制成

00:23:03.490 --> 00:23:07.210
在这里可用，如果您曾经有过

00:23:05.139 --> 00:23:08.830
做过nginx或者你曾经做过mod 

00:23:07.210 --> 00:23:09.340
重写或类似的东西并追加

00:23:08.830 --> 00:23:11.080
阿帕奇

00:23:09.340 --> 00:23:12.940
这应该看起来很熟悉

00:23:11.080 --> 00:23:15.940
事实是你可以拥有相同的力量

00:23:12.940 --> 00:23:18.100
在您的 Spring 剪裁中开箱即用

00:23:15.940 --> 00:23:20.470
网关，让我们以示例为例

00:23:18.100 --> 00:23:23.470
当您请求

00:23:20.470 --> 00:23:26.169
本地8080 1cf到边缘服务

00:23:23.470 --> 00:23:28.269
用于在客户中传递斜线星号

00:23:26.169 --> 00:23:30.279
我就是那个ID那就是那个CID 

00:23:28.269 --> 00:23:32.919
简短而可爱，没有

00:23:30.279 --> 00:23:33.880
原因是当您使用客户ID 

00:23:32.919 --> 00:23:37.540
您提供

00:23:33.880 --> 00:23:39.790
我们将提供您知道的分组

00:23:37.540 --> 00:23:43.020
在这里分组模式循环，我们

00:23:39.790 --> 00:23:46.510
要给它起个名字， 

00:23:43.020 --> 00:23:49.900
然后，我们将使用该捕获的元素并

00:23:46.510 --> 00:23:51.450
将其绑定到替换权，以便

00:23:49.900 --> 00:23:53.410
我们将请求转发给

00:23:51.450 --> 00:23:56.470
负载均衡的客户服务

00:23:53.410 --> 00:24:04.390
斜杠的客户捕获的cid好吧

00:23:56.470 --> 00:24:07.690
让我们看看看起来像什么

00:24:04.390 --> 00:24:10.000
我们得到的是我的第一个吗

00:24:07.690 --> 00:24:14.590
只是拿东西的ID 

00:24:10.000 --> 00:24:17.350
好的CF贴到那里，我们可以

00:24:14.590 --> 00:24:19.180
看到我们得到了一个记录，我们

00:24:17.350 --> 00:24:23.140
能够拨打 localhost CF 

00:24:19.180 --> 00:24:25.570
到ID，我们得到了

00:24:23.140 --> 00:24:27.250
下游服务，从而使

00:24:25.570 --> 00:24:28.690
我们能够改变事情，所以你

00:24:27.250 --> 00:24:29.770
可以一起改变这些过滤器

00:24:28.690 --> 00:24:32.260
可以做各种各样的事情

00:24:29.770 --> 00:24:34.480
做非常定制的非常动态的处理

00:24:32.260 --> 00:24:35.860
在这里，您甚至可以存储所有这些自定义

00:24:34.480 --> 00:24:37.360
按照您想要的确切顺序过滤

00:24:35.860 --> 00:24:40.140
如我们先前所见，它们在列表中

00:24:37.360 --> 00:24:43.150
然后将它们应用于其他

00:24:40.140 --> 00:24:45.940
网关边缘边缘服务或端点

00:24:43.150 --> 00:24:47.200
好吧，那我觉得有些失望

00:24:45.940 --> 00:24:49.270
这就是您期望的很多，所以

00:24:47.200 --> 00:24:52.060
习俗多一点参与

00:24:49.270 --> 00:24:57.790
这里稍微有趣的选项

00:24:52.060 --> 00:24:59.800
一种选择是使用电路

00:24:57.790 --> 00:25:01.450
断路器正确，所以我们把他的家伙

00:24:59.800 --> 00:25:04.320
命令行上课我很抱歉

00:25:01.450 --> 00:25:07.720
路径，我们可以使用该断路器

00:25:04.320 --> 00:25:09.280
保护我们提出的要求

00:25:07.720 --> 00:25:10.660
通过边缘服务给我们

00:25:09.280 --> 00:25:11.920
下游服务以及我们所做的任何事情

00:25:10.660 --> 00:25:14.950
可以作证

00:25:11.920 --> 00:25:19.900
对于特定的hystrix命令可以

00:25:14.950 --> 00:25:23.170
在这里申请，让我们创建一个路线简历

00:25:19.900 --> 00:25:28.960
predicate当然就是

00:25:23.170 --> 00:25:32.170
路径CV和URL将被加载

00:25:28.960 --> 00:25:37.300
平衡的客户-服务向前

00:25:32.170 --> 00:25:40.660
大幅度削减客户，过滤器即将开始

00:25:37.300 --> 00:25:42.880
成为网关过滤器网关过滤器

00:25:40.660 --> 00:25:44.740
点hystrix，让我给它一个命令

00:25:42.880 --> 00:25:47.620
名称，让我们想象一下，他们

00:25:44.740 --> 00:25:49.000
做足够有想象力的认证机构

00:25:47.620 --> 00:25:50.890
这样就可以创建一个历史命令

00:25:49.000 --> 00:25:52.299
它会包装对

00:25:50.890 --> 00:25:53.559
该命令中的下游服务

00:25:52.299 --> 00:25:55.390
现在是什么让您脱颖而出

00:25:53.559 --> 00:25:58.000
盒子不多，我是说会

00:25:55.390 --> 00:25:59.590
它会将您的命令包装成被子

00:25:58.000 --> 00:26:01.630
您可以在该命令中调用

00:25:59.590 --> 00:26:04.539
然后你知道什么成立，然后我们上交

00:26:01.630 --> 00:26:07.360
以HTV 200为例，它将为您提供

00:26:04.539 --> 00:26:09.549
如果有问题，则默认响应

00:26:07.360 --> 00:26:12.250
通话中有误，但您也可以

00:26:09.549 --> 00:26:15.220
指定超时等内容

00:26:12.250 --> 00:26:16.779
指定等待多长时间

00:26:15.220 --> 00:26:18.190
给一个请求镜头或你知道

00:26:16.779 --> 00:26:20.409
等等，所以您这里有很多控制权

00:26:18.190 --> 00:26:23.590
您可以按实例名称进行操作

00:26:20.409 --> 00:26:27.250
实际上每个命令指定每个电路

00:26:23.590 --> 00:26:30.340
您知道CV特定的配置或

00:26:27.250 --> 00:26:32.470
您可以指定默认断路器

00:26:30.340 --> 00:26:34.000
属性，让我们做默认电路

00:26:32.470 --> 00:26:37.690
我要去的断路器属性

00:26:34.000 --> 00:26:41.529
并指定hystrix doc命令

00:26:37.690 --> 00:26:45.419
点默认点执行即隔离

00:26:41.529 --> 00:26:50.289
那个超时的线程

00:26:45.419 --> 00:26:53.289
毫秒等于5,000现在我们看到

00:26:50.289 --> 00:26:54.880
历史命令默认执行于

00:26:53.289 --> 00:27:00.730
隔离线程时间（以毫秒为单位） 

00:26:54.880 --> 00:27:02.350
到了5000我想你可以

00:27:00.730 --> 00:27:04.149
说简历，我忘了具体

00:27:02.350 --> 00:27:06.700
语法，但我们只是默认

00:27:04.149 --> 00:27:09.059
这将是全球设置

00:27:06.700 --> 00:27:11.140
一旦完成，就适用于所有内容

00:27:09.059 --> 00:27:12.580
而不是打电话给客户，所以让我们

00:27:11.140 --> 00:27:14.260
叫点延迟记住我们的

00:27:12.580 --> 00:27:17.340
延迟点延迟点是

00:27:14.260 --> 00:27:21.460
只会在10秒后回应

00:27:17.340 --> 00:27:25.299
所以我们在这里说的是

00:27:21.460 --> 00:27:27.429
要超时并返回默认值

00:27:25.299 --> 00:27:29.289
如果需要的时间超过五

00:27:27.429 --> 00:27:31.120
秒显然这些都是淫秽的

00:27:29.289 --> 00:27:32.500
大量的你不会

00:27:31.120 --> 00:27:34.330
希望你不会有要求

00:27:32.500 --> 00:27:36.640
甚至需要接近5的东西

00:27:34.330 --> 00:27:38.679
秒，但我这样做是因为我想要

00:27:36.640 --> 00:27:40.840
我们来证明这里发生了什么

00:27:38.679 --> 00:27:45.000
好的，让我们看一下看起来

00:27:40.840 --> 00:27:45.000
像在行动，好吧，我们开始

00:27:48.410 --> 00:27:56.429
好吧

00:27:50.040 --> 00:27:58.470
所以让我们请求电路

00:27:56.429 --> 00:28:03.960
打破终点，我们将得到一个

00:27:58.470 --> 00:28:06.660
响应，你去，所以我们得到了504 

00:28:03.960 --> 00:28:09.600
网关超时是因为

00:28:06.660 --> 00:28:11.400
请求花了太长时间，所以这个

00:28:09.600 --> 00:28:15.870
当然，嗯，你知道我们

00:28:11.400 --> 00:28:17.160
演示如果

00:28:15.870 --> 00:28:18.330
服务已关闭，例如

00:28:17.160 --> 00:28:19.830
响应缓慢很明显

00:28:18.330 --> 00:28:21.929
该服务现在可用，但是它

00:28:19.830 --> 00:28:23.250
花了太长时间，所以我们时间装箱了

00:28:21.929 --> 00:28:24.750
该请求，我们得到了默认值

00:28:23.250 --> 00:28:26.280
行为，以便您可以进行各种

00:28:24.750 --> 00:28:28.260
有趣的事情在这里你可以

00:28:26.280 --> 00:28:30.419
做你在这里看到的，你实际上可以

00:28:28.260 --> 00:28:31.980
你知道然后点什么然后

00:28:30.419 --> 00:28:33.270
开始处理响应发送

00:28:31.980 --> 00:28:34.799
不同的标题或发送不同的标题

00:28:33.270 --> 00:28:36.990
回应任何正确的事情，所以很多

00:28:34.799 --> 00:28:39.450
这里的选项，您可以做的另一件事

00:28:36.990 --> 00:28:41.309
使您的服务更强大

00:28:39.450 --> 00:28:44.040
使用限速权，让我们看一下

00:28:41.309 --> 00:28:46.500
速率限制或定界符，以及

00:28:44.040 --> 00:28:52.169
我们要在这里做的是

00:28:46.500 --> 00:28:56.400
要创建一个称为RL的路线

00:28:52.169 --> 00:29:01.500
将有一个predicate路径RL和

00:28:56.400 --> 00:29:04.530
您知道网址将达到负载均衡

00:29:01.500 --> 00:29:06.900
客户服务正斜线

00:29:04.530 --> 00:29:09.090
客户，我们需要提供

00:29:06.900 --> 00:29:10.620
现在过滤器与

00:29:09.090 --> 00:29:15.240
其他我们必须实际

00:29:10.620 --> 00:29:16.200
配置请求权限限制器，以便

00:29:15.240 --> 00:29:23.880
让我们在这里做，我们将有一个

00:29:16.200 --> 00:29:28.230
请求速率限制器在这里可以RL 

00:29:23.880 --> 00:29:29.580
并且需要在其中进行配置

00:29:28.230 --> 00:29:32.400
为了它做它的工作，所以我们

00:29:29.580 --> 00:29:34.169
要说我们的l点层，我们

00:29:32.400 --> 00:29:36.660
要给它装满一些

00:29:34.169 --> 00:29:37.799
我们可以使用的参数你知道

00:29:36.660 --> 00:29:39.980
您需要知道的是

00:29:37.799 --> 00:29:43.620
请求该请求速率限制器

00:29:39.980 --> 00:29:45.390
工厂的意思是要去那

00:29:43.620 --> 00:29:48.720
请求速率限制或网关过滤器

00:29:45.390 --> 00:29:50.460
工厂将反过来取决于

00:29:48.720 --> 00:29:53.250
权利的特定实现

00:29:50.460 --> 00:29:56.370
限制器好吧，我碰巧知道

00:29:53.250 --> 00:29:58.330
实施是Redis速率限制

00:29:56.370 --> 00:30:01.360
限制器，这就是为什么我有

00:29:58.330 --> 00:30:02.919
 Redis也在类路径上

00:30:01.360 --> 00:30:04.570
需要Spring Security ，所以我要去

00:30:02.919 --> 00:30:08.230
继续并恢复我们将要谈论的内容

00:30:04.570 --> 00:30:09.490
为什么一秒钟，但我们有Redis，我们

00:30:08.230 --> 00:30:11.320
有安全感，所以我们知道

00:30:09.490 --> 00:30:13.570
将使用基于Redis的速率限制器

00:30:11.320 --> 00:30:19.620
使用基于Reddest的Redis的原因

00:30:13.570 --> 00:30:22.269
速率限制器是因为它将

00:30:19.620 --> 00:30:24.220
它会保持安全的权利

00:30:22.269 --> 00:30:26.679
必须保持状态它将保持计数

00:30:24.220 --> 00:30:29.500
如果您愿意将请求

00:30:26.679 --> 00:30:34.899
下游服务，它需要知道如何

00:30:29.500 --> 00:30:37.899
区分我想你的要求

00:30:34.899 --> 00:30:40.389
可以使它成为学习率

00:30:37.899 --> 00:30:42.250
说明所有要求的政策

00:30:40.389 --> 00:30:44.519
该服务应限制在您身上

00:30:42.250 --> 00:30:48.070
知道并要求一秒钟

00:30:44.519 --> 00:30:50.500
但是这个默认实现

00:30:48.070 --> 00:30:52.269
期待一个特定的钥匙，这样

00:30:50.500 --> 00:30:54.700
密钥，您可以根据需要提供任何方式

00:30:52.269 --> 00:30:56.649
默认情况下使用的密钥

00:30:54.700 --> 00:31:00.730
在默认情况下是一个直的限制器

00:30:56.649 --> 00:31:03.039
这里的配置是什么

00:31:00.730 --> 00:31:04.600
原则就是安全

00:31:03.039 --> 00:31:05.919
校长，这就是我们要做的

00:31:04.600 --> 00:31:08.200
是我们要使用安全性

00:31:05.919 --> 00:31:10.659
原则，根据

00:31:08.200 --> 00:31:12.519
发出请求的用户名，因此

00:31:10.659 --> 00:31:13.899
我们需要为

00:31:12.519 --> 00:31:16.570
该工作什么这种配置

00:31:13.899 --> 00:31:19.870
说我们期望得到五个

00:31:16.570 --> 00:31:22.389
每秒请求数

00:31:19.870 --> 00:31:23.919
容量为十，所以非常低

00:31:22.389 --> 00:31:26.139
级别显然您知道一些网站

00:31:23.919 --> 00:31:30.820
每秒执行一千万个请求

00:31:26.139 --> 00:31:31.720
这只是一个演示，好吧

00:31:30.820 --> 00:31:33.820
所以我们要做的是

00:31:31.720 --> 00:31:35.110
首先配置spring安全性，然后

00:31:33.820 --> 00:31:37.630
反应性Spring 安全性同样如此

00:31:35.110 --> 00:31:40.090
我们会说启用Web Flex安全性

00:31:37.630 --> 00:31:44.820
就是这样，我们需要解决两个问题

00:31:40.090 --> 00:31:47.649
有关身份验证授权

00:31:44.820 --> 00:31:54.720
对的好

00:31:47.649 --> 00:31:57.630
我要说束反应对不起地图

00:31:54.720 --> 00:32:02.580
反应式用户详细信息服务

00:31:57.630 --> 00:32:07.110
身份验证以及我说的新地图

00:32:02.580 --> 00:32:14.259
用户使用默认密码编码器点

00:32:07.110 --> 00:32:16.840
好的，并与用户和

00:32:14.259 --> 00:32:19.799
用户名将是用户，因为为什么不

00:32:16.840 --> 00:32:23.019
密码vpw，所以非常简单

00:32:19.799 --> 00:32:24.970
你知道认证机制

00:32:23.019 --> 00:32:26.950
将使用用户详细信息服务

00:32:24.970 --> 00:32:28.870
具有以下功能的反应式用户详细信息服务

00:32:26.950 --> 00:32:31.750
一个具有默认密码的用户，以及

00:32:28.870 --> 00:32:33.580
使用用户名user和的Kozar编码器

00:32:31.750 --> 00:32:37.440
密码，密码的作用是

00:32:33.580 --> 00:32:42.669
等于用户，我们现在需要

00:32:37.440 --> 00:32:46.149
授权元素好，Dean和这里

00:32:42.669 --> 00:32:49.299
这将期待虚无你能

00:32:46.149 --> 00:32:54.450
知道授权学习注入

00:32:49.299 --> 00:32:59.980
服务器HTTP安全性让我们看看

00:32:54.450 --> 00:33:02.139
安全和我说退货安全

00:32:59.980 --> 00:33:04.049
点它只会看到什么

00:33:02.139 --> 00:33:06.100
我们

00:33:04.049 --> 00:33:14.639
过滤器链那里就是

00:33:06.100 --> 00:33:18.490
返回值好了现在安全点

00:33:14.639 --> 00:33:21.250
授权交换路径匹配正在进行

00:33:18.490 --> 00:33:23.470
等于一个限速器

00:33:21.250 --> 00:33:24.940
所以任何要进行速率限制的事情都会发生

00:33:23.470 --> 00:33:31.570
这将是需要的

00:33:24.940 --> 00:33:34.000
身份验证，但您知道

00:33:31.570 --> 00:33:36.039
这样的交换将被允许

00:33:34.000 --> 00:33:37.690
其他一切都将敞开

00:33:36.039 --> 00:33:40.629
一个端点的正确限制

00:33:37.690 --> 00:33:46.539
点或要求身份验证会说

00:33:40.629 --> 00:33:48.600
最后他们应该是基础的，非常好

00:33:46.539 --> 00:33:51.700
所以这里有我们的配置

00:33:48.600 --> 00:33:53.200
那只是非常基本的反应堆

00:33:51.700 --> 00:33:54.669
我们实际研究的安全性之间

00:33:53.200 --> 00:33:57.639
我们之前的反应式Spring 安全性

00:33:54.669 --> 00:33:59.799
分期付款，所以您应该参考

00:33:57.639 --> 00:34:01.029
视频的更多细节，说我

00:33:59.799 --> 00:34:02.230
认为我们一切就绪

00:34:01.029 --> 00:34:04.840
让我们继续并重新启动

00:34:02.230 --> 00:34:05.799
应用程序，然后确认

00:34:04.840 --> 00:34:06.639
基础工作首先

00:34:05.799 --> 00:34:08.679
好吧，这就是我们想要做的

00:34:06.639 --> 00:34:12.429
现在只是为了确认给定

00:34:08.679 --> 00:34:13.260
经过验证的尝试或要求您

00:34:12.429 --> 00:34:20.080
采用

00:34:13.260 --> 00:34:23.980
 pwe HTTP localhost 8080赢得了，我们说

00:34:20.080 --> 00:34:25.990
我说我的工作正常，我们得到了

00:34:23.980 --> 00:34:30.879
没问题，我们没问题

00:34:25.990 --> 00:34:33.220
这些要求我现在不能提出五个

00:34:30.879 --> 00:34:36.040
在这里请求我的手

00:34:33.220 --> 00:34:37.690
其实所以我我要你知道

00:34:36.040 --> 00:34:39.909
我在这里示范的目的

00:34:37.690 --> 00:34:42.429
做点丑事

00:34:39.909 --> 00:34:45.129
它将起作用，我们将创建一个

00:34:42.429 --> 00:34:47.109
同一Java客户端处理

00:34:45.129 --> 00:34:48.250
显然应该知道你是否

00:34:47.109 --> 00:34:49.990
是一个测试，它可以住在其他地方

00:34:48.250 --> 00:34:51.970
但我只想吃点东西

00:34:49.990 --> 00:34:54.760
锤击服务，以便我们看到

00:34:51.970 --> 00:34:56.190
回来的回应，所以我们

00:34:54.760 --> 00:35:00.930
要创建一个非常简单的

00:34:56.190 --> 00:35:04.210
应用程序运行器并为此做

00:35:00.930 --> 00:35:08.980
我们将需要一个被动的网站

00:35:04.210 --> 00:35:14.020
客户端，因此Web客户端点创建点

00:35:08.980 --> 00:35:15.900
或对不起构建器点过滤器交换

00:35:14.020 --> 00:35:25.089
过滤器功能基本认证

00:35:15.900 --> 00:35:28.630
用户和PW并构建该C，所以这是我们的

00:35:25.089 --> 00:35:30.970
网络客户端，当我们制作那些

00:35:28.630 --> 00:35:32.710
我们要去的要求

00:35:30.970 --> 00:35:34.780
产生许多要求，所以我们

00:35:32.710 --> 00:35:37.450
目标是产生五个以上

00:35:34.780 --> 00:35:42.010
每秒明显的请求，因此我们将

00:35:37.450 --> 00:35:44.770
说流中的磁通点，我想我们

00:35:42.010 --> 00:35:47.830
可以在JDK流中使用某些东西

00:35:44.770 --> 00:35:54.330
库以生成值序列

00:35:47.830 --> 00:35:59.530
流点范围是0到100 

00:35:54.330 --> 00:36:02.740
我们将平铺该响应或

00:35:59.530 --> 00:36:03.880
该数据，所以整数或我们想要它

00:36:02.740 --> 00:36:05.800
被装箱就是它的抱怨

00:36:03.880 --> 00:36:07.630
关于整数流完成了

00:36:05.800 --> 00:36:09.250
不是整数流，而是

00:36:07.630 --> 00:36:10.980
默认情况下在流中，因此我们必须取消装箱

00:36:09.250 --> 00:36:13.359
它，他们将为每个发言

00:36:10.980 --> 00:36:15.040
您实际上知道我们不知道的号码

00:36:13.359 --> 00:36:17.470
关心其他语言，我们可以

00:36:15.040 --> 00:36:18.820
只是说，但我们说数字或

00:36:17.470 --> 00:36:24.999
不管谁在乎

00:36:18.820 --> 00:36:28.680
所以对于每个数字我们想要

00:36:24.999 --> 00:36:32.289
发出请求，以便客户端获取该URI 

00:36:28.680 --> 00:36:35.140
等于HTTP，我们将自称

00:36:32.289 --> 00:36:37.630
基本上在我们自己的港口上

00:36:35.140 --> 00:36:39.489
现在编辑端点，我要

00:36:37.630 --> 00:36:44.589
得到交换回应，我们将

00:36:39.489 --> 00:36:47.140
将客户的反应映射为某种东西

00:36:44.589 --> 00:36:48.219
我们可以使用的CR而不是实体

00:36:47.140 --> 00:36:50.019
我们将不在乎

00:36:48.219 --> 00:36:54.479
有效负载，我们只想让字符串返回

00:36:50.019 --> 00:37:01.390
一个问题，然后我们想将其映射

00:36:54.479 --> 00:37:04.469
所以我们将响应映射到

00:37:01.390 --> 00:37:09.430
将消息直接转换为字符串数据格式

00:37:04.469 --> 00:37:12.579
你知道状态就是这个

00:37:09.430 --> 00:37:19.029
身体将是这个，我们会说我们的

00:37:12.579 --> 00:37:22.180
点状态代码值和我们的

00:37:19.029 --> 00:37:24.369
身体好，所以我们有信息

00:37:22.180 --> 00:37:30.279
我们已经绘制的地图，现在我们只是古怪的

00:37:24.369 --> 00:37:32.109
 ribe system.out.print我的好吧

00:37:30.279 --> 00:37:34.029
看起来不错，看起来像那样

00:37:32.109 --> 00:37:35.680
给我们我们想要的，让我们尝试一下

00:37:34.029 --> 00:37:38.799
这个应用程序，我们应该看到

00:37:35.680 --> 00:37:42.390
而当其中五个通过

00:37:38.799 --> 00:37:43.749
并非每一秒钟他们都做得对

00:37:42.390 --> 00:37:48.039
你去

00:37:43.749 --> 00:37:49.059
所以你看到一个通过了大部分

00:37:48.039 --> 00:37:51.160
他们不是因为我们要走一点

00:37:49.059 --> 00:37:55.329
太快了，他走了五个

00:37:51.160 --> 00:37:56.489
一次，然后大部分时间等

00:37:55.329 --> 00:37:58.599
这种方式不一定

00:37:56.489 --> 00:38:00.249
顺序权我正在使用新的主动

00:37:58.599 --> 00:38:01.630
在这里支持，所以根据定义

00:38:00.249 --> 00:38:05.019
这些请求中有一个可能有

00:38:01.630 --> 00:38:07.719
是否同时发生

00:38:05.019 --> 00:38:10.059
状态代码为29的请求太多

00:38:07.719 --> 00:38:11.289
对，所以它被拒绝是对的

00:38:10.059 --> 00:38:13.390
限于对下游的请求

00:38:11.289 --> 00:38:16.900
每个用户的服务（如果有） 

00:38:13.390 --> 00:38:19.210
然后由其他用户验证

00:38:16.900 --> 00:38:21.130
这不会是这不会是一个

00:38:19.210 --> 00:38:23.410
问题很好，所以我们只看了

00:38:21.130 --> 00:38:27.309
 Spring 可以做的几件事

00:38:23.410 --> 00:38:29.240
云网关的应用程序是

00:38:27.309 --> 00:38:31.490
你懂

00:38:29.240 --> 00:38:33.020
这很简单，我可以确定

00:38:31.490 --> 00:38:35.030
可以想像很多事情你可以做

00:38:33.020 --> 00:38:38.270
超越这一件事值得

00:38:35.030 --> 00:38:39.589
理解当然是如果

00:38:38.270 --> 00:38:42.050
与其余的整合

00:38:39.589 --> 00:38:44.000
把你知道的叠放在 Spring 的云里，所以你

00:38:42.050 --> 00:38:45.770
可以像网关一样看到 Spring 

00:38:44.000 --> 00:38:47.450
在其他地方使用的能力

00:38:45.770 --> 00:38:49.579
操纵路线非常有用

00:38:47.450 --> 00:38:51.020
还有关于

00:38:49.579 --> 00:38:52.490
这些说唱，你可以在这里看到

00:38:51.020 --> 00:39:03.069
执行器就好了，所以如果我要去

00:38:52.490 --> 00:39:08.109
这个端点在这里让我们看看curl HTTP 

00:39:03.069 --> 00:39:11.720
 localhost ：8080我们没事吧

00:39:08.109 --> 00:39:13.309
执行器终点，你知道我可以

00:39:11.720 --> 00:39:15.079
我把这些路线我可以询问

00:39:13.309 --> 00:39:18.040
他们我可以操纵他们，我可以做的一切

00:39:15.079 --> 00:39:21.619
可以动态添加的各种内容或

00:39:18.040 --> 00:39:23.270
在运行过程中修改路由，以便

00:39:21.619 --> 00:39:25.250
这些执行器指向表面

00:39:23.270 --> 00:39:28.520
信息非常方便

00:39:25.250 --> 00:39:31.670
你知道我们只是个开始

00:39:28.520 --> 00:39:33.530
我说的只是我们的开始

00:39:31.670 --> 00:39:35.299
可能性，我们已经做了很多

00:39:33.530 --> 00:39:36.920
这里的事情很简单

00:39:35.299 --> 00:39:39.309
我已经展示了许多概念

00:39:36.920 --> 00:39:43.150
在这里，但还有更多，我和

00:39:39.309 --> 00:39:46.700
我相信你也可以想象他们

00:39:43.150 --> 00:39:49.990
非常感谢您的收看

00:39:46.700 --> 00:39:49.990
下次再见

00:39:56.990 --> 00:39:59.050
您

