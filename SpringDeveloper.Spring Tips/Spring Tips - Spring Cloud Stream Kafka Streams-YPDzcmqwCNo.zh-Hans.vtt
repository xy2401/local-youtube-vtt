WEBVTT
Kind: captions
Language: zh-Hans

00:00:25.920 --> 00:00:30.360
嗨，体育迷们欢迎来到另一个

00:00:28.680 --> 00:00:32.310
在其中安装的Spring 头

00:00:30.360 --> 00:00:33.960
我们将在

00:00:32.310 --> 00:00:36.360
特别是我们要看一下卡夫卡

00:00:33.960 --> 00:00:38.520
穿过Spring Cloud的镜头

00:00:36.360 --> 00:00:40.680
现在我们在上一个视频中观看了

00:00:38.520 --> 00:00:42.840
在 Spring 的云流中，我们每天

00:00:40.680 --> 00:00:45.840
看着洒水和RabbitMQ 

00:00:42.840 --> 00:00:47.700
现在散落的溪流是

00:00:45.840 --> 00:00:49.920
处理连通性的框架

00:00:47.700 --> 00:00:51.210
不同的消息传递技术和

00:00:49.920 --> 00:00:53.250
允许我们按照以下方式编写代码

00:00:51.210 --> 00:00:55.620
这类有用的编程API 

00:00:53.250 --> 00:00:57.540
默认的方法是

00:00:55.620 --> 00:01:00.090
使用Spring Framework消息传递

00:00:57.540 --> 00:01:02.640
您知道消息的频道和消息

00:01:00.090 --> 00:01:04.619
类型，所以这些类型是

00:01:02.640 --> 00:01:05.759
 Spring 的云流，但那不是

00:01:04.619 --> 00:01:08.280
原因是没有理由你不能

00:01:05.759 --> 00:01:09.509
今天也使用其他绑定

00:01:08.280 --> 00:01:11.490
我们要看 Spring 的云流

00:01:09.509 --> 00:01:13.860
和卡夫卡流，它使我们能够工作

00:01:11.490 --> 00:01:15.899
来自kafka流的绑定

00:01:13.860 --> 00:01:19.080
现在我们要建立一个简单的项目

00:01:15.899 --> 00:01:21.360
分析应用程序，我将使用

00:01:19.080 --> 00:01:24.600
卡夫卡支持 Spring Cloud Stream 

00:01:21.360 --> 00:01:25.890
支持龙目岛，网络对此提供支持

00:01:24.600 --> 00:01:29.490
将给我们一个新项目，我们可以

00:01:25.890 --> 00:01:31.229
在我们的IDE上打开，然后您

00:01:29.490 --> 00:01:32.460
知道这个API会建立一个简单的

00:01:31.229 --> 00:01:35.430
应用分析应用程序

00:01:32.460 --> 00:01:37.049
流程事件说出来

00:01:35.430 --> 00:01:38.549
某种想象中的网站或

00:01:37.049 --> 00:01:40.890
像这样的数据，我们

00:01:38.549 --> 00:01:44.010
我们将要去的过程

00:01:40.890 --> 00:01:45.780
需要去综合我们要

00:01:44.010 --> 00:01:47.610
创建一些你知道的数据

00:01:45.780 --> 00:01:49.049
实际上有人在点击

00:01:47.610 --> 00:01:50.340
例如在一个网站周围

00:01:49.049 --> 00:01:51.930
将合成一些数据以便

00:01:50.340 --> 00:01:53.940
这样做我们会定期使用 Spring 

00:01:51.930 --> 00:01:55.380
云流，然后只有那时

00:01:53.940 --> 00:01:59.100
我们将开始使用Spring 云

00:01:55.380 --> 00:02:02.729
流和kafka流到

00:01:59.100 --> 00:02:06.210
处理该数据到与

00:02:02.729 --> 00:02:07.439
有了这些数据，所以这里有两个活页夹

00:02:06.210 --> 00:02:14.489
Spring Cloud同样的应用

00:02:07.439 --> 00:02:17.940
流活页夹卡夫卡流和 Spring 

00:02:14.489 --> 00:02:21.420
云流卡夫卡确定活页夹卡夫卡所以我

00:02:17.940 --> 00:02:24.989
认为那是正确的

00:02:21.420 --> 00:02:27.890
让我们继续并确保给它一个

00:02:24.989 --> 00:02:27.890
第二这里下载

00:02:36.620 --> 00:02:43.700
所以大概是核心会议

00:02:44.870 --> 00:02:49.410
看起来是正确的版本

00:02:47.790 --> 00:02:50.370
这样就可以开始了

00:02:49.410 --> 00:02:54.239
并构建一个应用程序

00:02:50.370 --> 00:02:55.349
现在，我们将数据写入我们的Kafka经纪人

00:02:54.239 --> 00:02:56.190
应该稍微谈谈卡夫卡

00:02:55.349 --> 00:02:59.790
在这里我们应该了解它是什么

00:02:56.190 --> 00:03:01.470
 Kafka从现在开始就是一个消息代理

00:02:59.790 --> 00:03:03.330
专利，现在是Apache项目， 

00:03:01.470 --> 00:03:06.030
非常受欢迎，尤其是在

00:03:03.330 --> 00:03:06.989
网络巨人的网络巨人

00:03:06.030 --> 00:03:10.170
首先有很多原因

00:03:06.989 --> 00:03:11.640
具有非常非常灵活的拓扑或

00:03:10.170 --> 00:03:13.650
域模型，它给你一个非常

00:03:11.640 --> 00:03:17.579
灵活的方式来描述不同

00:03:13.650 --> 00:03:19.470
系统吧，它可以用来

00:03:17.579 --> 00:03:22.560
做pub / sub或qtq或点对点

00:03:19.470 --> 00:03:26.060
而不是消息传递，而是

00:03:22.560 --> 00:03:28.620
允许允许那种灵活性

00:03:26.060 --> 00:03:29.549
分区和组是通用的，因此

00:03:28.620 --> 00:03:31.379
实际上你可以做一些

00:03:29.549 --> 00:03:32.549
除此之外，你还有其他事情

00:03:31.379 --> 00:03:34.470
可以做一些非常有趣的事

00:03:32.549 --> 00:03:36.000
实际上例如具有点对点

00:03:34.470 --> 00:03:40.319
消息也很多

00:03:36.000 --> 00:03:42.209
订户，例如你可以

00:03:40.319 --> 00:03:43.530
知道你可以扩大规模并做负荷

00:03:42.209 --> 00:03:45.420
用相同的原语平衡

00:03:43.530 --> 00:03:48.260
这不一定总是正确的

00:03:45.420 --> 00:03:50.519
其他消息传递系统Kafka 

00:03:48.260 --> 00:03:52.319
最终当你问是否问

00:03:50.519 --> 00:03:53.489
在卡夫卡工作的人是什么

00:03:52.319 --> 00:03:55.019
他们是否是传统的

00:03:53.489 --> 00:03:56.400
企业消息传递代理之类的

00:03:55.019 --> 00:03:58.680
他们更有可能讲

00:03:56.400 --> 00:04:01.489
你这是一个复制的日志

00:03:58.680 --> 00:04:04.560
它实际上是一个日志

00:04:01.489 --> 00:04:07.440
记录按顺序存储在那里

00:04:04.560 --> 00:04:08.639
可以是多个消息

00:04:07.440 --> 00:04:10.650
当然顺序，他们是

00:04:08.639 --> 00:04:12.810
放入一个类别，该类别是

00:04:10.650 --> 00:04:14.040
称为主题，因此在JMS或

00:04:12.810 --> 00:04:17.010
 Rabbitmq或您拥有的顶级产品

00:04:14.040 --> 00:04:19.349
原谅的交流等等，卡夫卡就这些

00:04:17.010 --> 00:04:21.450
只是主题，您将记录放入

00:04:19.349 --> 00:04:23.070
这些类别称为主题

00:04:21.450 --> 00:04:25.169
记录是我们可以想到的消息

00:04:23.070 --> 00:04:26.639
它们作为消息，但在主题内

00:04:25.169 --> 00:04:28.349
可以有多个分区，这些

00:04:26.639 --> 00:04:30.150
分区意味着您实际上可以

00:04:28.349 --> 00:04:31.470
你知道吗只有你知道你有

00:04:30.150 --> 00:04:33.840
保证只在内部订购

00:04:31.470 --> 00:04:36.590
一个分区的好处是

00:04:33.840 --> 00:04:40.020
我每个人可以有多个消费者

00:04:36.590 --> 00:04:41.340
处理不同的分区，但是

00:04:40.020 --> 00:04:43.500
他们仍然在同一个地方工作

00:04:41.340 --> 00:04:46.870
主题很好，所以它们变得线性

00:04:43.500 --> 00:04:48.730
线性可线性化

00:04:46.870 --> 00:04:50.620
也可以做的处理

00:04:48.730 --> 00:04:52.300
同时非常非常非常

00:04:50.620 --> 00:04:56.680
方便非常非常方便的质量

00:04:52.300 --> 00:04:58.180
也是内置的复制日志

00:04:56.680 --> 00:04:59.500
对此进行了优化的方式

00:04:58.180 --> 00:05:01.570
专门针对大型应用进行了优化

00:04:59.500 --> 00:05:03.580
大量的数据，所以实际上我们是

00:05:01.570 --> 00:05:05.410
在这里处理的是您的数据库

00:05:03.580 --> 00:05:08.350
可以像FIFO一样对待

00:05:05.410 --> 00:05:12.790
具有您可以读取的数据的数据库

00:05:08.350 --> 00:05:14.350
一进一出就像一个像一个像

00:05:12.790 --> 00:05:17.530
营养信息将该数据库排队

00:05:14.350 --> 00:05:19.510
我的意思是你知道查询时间

00:05:17.530 --> 00:05:21.669
消息中恒定的查询时间

00:05:19.510 --> 00:05:23.169
数据库意味着您可以拥有10个

00:05:21.669 --> 00:05:25.180
千字节的数据，或者您可以拥有10 

00:05:23.169 --> 00:05:27.370
 TB级数据的寻道时间

00:05:25.180 --> 00:05:29.200
特定记录的时间索引

00:05:27.370 --> 00:05:31.150
它是不变的，这给你一些

00:05:29.200 --> 00:05:32.980
非常非常非常有用的属性

00:05:31.150 --> 00:05:35.440
尤其是大规模的时候

00:05:32.980 --> 00:05:36.250
处理恒定的负载就可以了

00:05:35.440 --> 00:05:37.660
我们现在有一些

00:05:36.250 --> 00:05:39.430
简化我们要做的是

00:05:37.660 --> 00:05:43.870
创建一个写数据的应用程序

00:05:39.430 --> 00:05:45.639
给我们给我们的卡夫卡经纪人我有卡夫卡

00:05:43.870 --> 00:05:46.750
我在后台运行在这里

00:05:45.639 --> 00:05:48.160
动物园管理员实例，然后我

00:05:46.750 --> 00:05:49.930
启动卡夫卡，你可以

00:05:48.160 --> 00:05:52.390
下载预建的呃你知道的

00:05:49.930 --> 00:05:54.460
卡夫卡草的分布

00:05:52.390 --> 00:05:58.390
 Apache网站并启动它们

00:05:54.460 --> 00:05:59.410
好，我有我们的新应用程序，所以

00:05:58.390 --> 00:06:01.930
我要建立一个应用程序

00:05:59.410 --> 00:06:04.660
产生数据，所以它将被写入

00:06:01.930 --> 00:06:07.570
类型页面视图的数据右页面视图

00:06:04.660 --> 00:06:11.020
事件或只是，这被称为页面

00:06:07.570 --> 00:06:12.280
查看事件确定和页面查看事件

00:06:11.020 --> 00:06:14.320
将包含有关谁的信息

00:06:12.280 --> 00:06:16.900
提出有关该页面的请求

00:06:14.320 --> 00:06:18.280
他们正在查看和持续时间

00:06:16.900 --> 00:06:20.110
正确查看给定的时间

00:06:18.280 --> 00:06:22.539
现在我要用一美元

00:06:20.110 --> 00:06:25.450
创建一些你知道的细节选举的东西

00:06:22.539 --> 00:06:28.870
在这里，我们将创建一个页面

00:06:25.450 --> 00:06:31.360
查看事件源，我们将创建一个

00:06:28.870 --> 00:06:33.810
当

00:06:31.360 --> 00:06:36.760
应用程序站起来，它将

00:06:33.810 --> 00:06:37.780
当数据写入数据库时

00:06:36.760 --> 00:06:39.970
启动它将会有这个回调

00:06:37.780 --> 00:06:41.140
那是我向该经纪人数据的地方

00:06:39.970 --> 00:06:43.630
其实这个卡夫卡经纪人，所以我们

00:06:41.140 --> 00:06:45.820
要说这是一个组成部分

00:06:43.630 --> 00:06:47.860
轮到要使用常规Spring 

00:06:45.820 --> 00:06:49.210
云流绑定在这里再次如此

00:06:47.860 --> 00:06:52.450
需要注意的地方

00:06:49.210 --> 00:06:55.090
那最后一个视频，所以我们要

00:06:52.450 --> 00:06:58.240
创建一个界面并定义一些

00:06:55.090 --> 00:06:59.770
引导一些输出通道， 

00:06:58.240 --> 00:07:00.650
我们可以发送消息以及我们的原因

00:06:59.770 --> 00:07:03.320
有这种

00:07:00.650 --> 00:07:05.600
二元性此双重程序模型是因为

00:07:03.320 --> 00:07:09.979
无法将消息写入

00:07:05.600 --> 00:07:11.720
卡夫卡流直接卡夫卡流

00:07:09.979 --> 00:07:14.000
奥尔顿只是一个话题，你的方式

00:07:11.720 --> 00:07:15.770
将消息写入Kafka流或

00:07:14.000 --> 00:07:16.940
 Kafka中的主题只是写消息

00:07:15.770 --> 00:07:19.220
正确的话题

00:07:16.940 --> 00:07:21.590
 Kafka流是您在以下情况下使用的API： 

00:07:19.220 --> 00:07:23.030
您正在使用数据，因此我们将使用

00:07:21.590 --> 00:07:25.580
消息渠道和传统

00:07:23.030 --> 00:07:27.860
 Spring 洪水要写给卡夫卡

00:07:25.580 --> 00:07:30.520
但另一方面，我们可以

00:07:27.860 --> 00:07:34.190
使用Kafka流来处理数据

00:07:30.520 --> 00:07:35.660
好吧，让我们看一下字符串想要调用

00:07:34.190 --> 00:07:40.220
这就是我要称之为的

00:07:35.660 --> 00:07:44.949
这将是页面浏览量

00:07:40.220 --> 00:07:50.570
频道，因此当页面查看时

00:07:44.949 --> 00:07:53.360
页面浏览量很好，所以这是一个

00:07:50.570 --> 00:07:55.370
有点长，但它可能只是PV 

00:07:53.360 --> 00:08:00.340
好吧，让页面浏览量变大

00:07:55.370 --> 00:08:02.479
页面浏览量，我将告诉

00:08:00.340 --> 00:08:07.880
这节课我要告诉 Spring 

00:08:02.479 --> 00:08:09.169
但我想在这里注入这种类型

00:08:07.880 --> 00:08:12.889
构造函数让我们创建一个

00:08:09.169 --> 00:08:17.990
构造函数，我们实际上想

00:08:12.889 --> 00:08:20.660
注入分析绑定绑定，以便

00:08:17.990 --> 00:08:21.860
绑定点支付树现在按顺序

00:08:20.660 --> 00:08:22.970
让 Spring 的云流知道要做什么

00:08:21.860 --> 00:08:26.660
使用我们需要的这种绑定类型

00:08:22.970 --> 00:08:28.160
实际上和分析分析绑定

00:08:26.660 --> 00:08:29.599
点咖啡因可在此处进行绑定

00:08:28.160 --> 00:08:30.500
那个绑定的名字，那么 Spring 

00:08:29.599 --> 00:08:32.000
不变，我们要做的是

00:08:30.500 --> 00:08:34.250
看看这个界面，它将

00:08:32.000 --> 00:08:36.020
这些频道的名称和

00:08:34.250 --> 00:08:37.430
任何类型或任何绑定

00:08:36.020 --> 00:08:38.719
会放在这个界面中， 

00:08:37.430 --> 00:08:39.860
看一下你知道的配置

00:08:38.719 --> 00:08:41.150
在我们将要查看的属性文件中

00:08:39.860 --> 00:08:44.330
一秒钟，它会把那个

00:08:41.150 --> 00:08:45.680
与我们的经纪人建立联系，让我们

00:08:44.330 --> 00:08:47.810
这样做，让我们回到盐水上层

00:08:45.680 --> 00:08:50.390
我们的配置文件在这里，我们需要

00:08:47.810 --> 00:08:52.900
一般配置一些东西，这样

00:08:50.390 --> 00:08:54.110
首先让我们做一些默认设置

00:08:52.900 --> 00:08:56.959
默认值

00:08:54.110 --> 00:09:00.800
我希望这些成为适用于

00:08:56.959 --> 00:09:02.510
发送到任何地方的每条消息

00:09:00.800 --> 00:09:05.380
我们之间的咖啡钙卡夫卡代码如此

00:09:02.510 --> 00:09:08.540
洒水卡夫卡流点

00:09:05.380 --> 00:09:13.829
二进制配置先提交

00:09:08.540 --> 00:09:16.959
所有三个提交该间隔

00:09:13.829 --> 00:09:20.199
毫秒等于一千，所以我们有

00:09:16.959 --> 00:09:23.499
一秒钟的委员会间隔

00:09:20.199 --> 00:09:26.680
需要一个默认的消毒钥匙，所以

00:09:23.499 --> 00:09:28.529
作为一个社会的默认钥匙消毒器

00:09:26.680 --> 00:09:32.819
卡夫卡（Kafka）宣布，所以星期六是一个

00:09:28.529 --> 00:09:33.939
序列化器，今年少了西尔

00:09:32.819 --> 00:09:37.240
实现者

00:09:33.939 --> 00:09:39.279
 D消毒器好了，你必须

00:09:37.240 --> 00:09:41.110
现在为键和值指定

00:09:39.279 --> 00:09:43.720
当我们谈论一个

00:09:41.110 --> 00:09:46.449
 Kafka上下文中的每条消息都有一个密钥

00:09:43.720 --> 00:09:47.829
与该消息相关联的

00:09:46.449 --> 00:09:50.499
它有一个付款，现在的价值

00:09:47.829 --> 00:09:52.089
卡夫卡不在乎那些有效载荷

00:09:50.499 --> 00:09:53.920
是，甚至你有那些钥匙

00:09:52.089 --> 00:09:55.480
告诉它这是一个数组

00:09:53.920 --> 00:09:57.399
个字节或一个字符串，或者您知道您

00:09:55.480 --> 00:09:58.839
应该使用JSON，或者您应该或者您

00:09:57.399 --> 00:10:01.329
应该使用Avro这实际上是一个非常

00:09:58.839 --> 00:10:02.170
常见的例子是像pro这样的模式

00:10:01.329 --> 00:10:03.519
那是你必须拥有的

00:10:02.170 --> 00:10:05.649
最后你会发现你必须

00:10:03.519 --> 00:10:07.899
指定并担心很多

00:10:05.649 --> 00:10:08.829
你在不同的地方知道什么时候

00:10:07.899 --> 00:10:10.749
与Kafka合作，我们将

00:10:08.829 --> 00:10:12.790
请事先指定，因为我没有

00:10:10.749 --> 00:10:14.559
我想只记得

00:10:12.790 --> 00:10:19.629
事情看起来还不错，还是看

00:10:14.559 --> 00:10:22.839
 Apache Kafka的共同点，就是让我

00:10:19.629 --> 00:10:24.480
先生，不记得是这节课

00:10:22.839 --> 00:10:26.769
在这里，我们要参考

00:10:24.480 --> 00:10:31.259
我们将参考这个

00:10:26.769 --> 00:10:37.350
这个工厂的星期六上课

00:10:31.259 --> 00:10:40.240
叫做凝视DES，我们在那里使用它

00:10:37.350 --> 00:10:47.769
对于钥匙，我们将使用Spring 抱歉

00:10:40.240 --> 00:10:52.439
在周六为

00:10:47.769 --> 00:10:56.319
我们将使用默认值的值

00:10:52.439 --> 00:10:59.620
但那里的价值离开那

00:10:56.319 --> 00:11:01.660
好吧，所以我们去那里

00:10:59.620 --> 00:11:05.920
我们的配置默认配置

00:11:01.660 --> 00:11:09.129
现在针对这个特殊的

00:11:05.920 --> 00:11:12.459
我们将要建立绑定的东西

00:11:09.129 --> 00:11:15.100
网页浏览量还可以，所以 Spring 

00:11:12.459 --> 00:11:16.839
云流绑定这是

00:11:15.100 --> 00:11:17.410
传统，这是外观，这看起来

00:11:16.839 --> 00:11:18.790
非常熟悉

00:11:17.410 --> 00:11:21.069
这就是你甚至会写的

00:11:18.790 --> 00:11:23.350
与rabbitmq一起撒流

00:11:21.069 --> 00:11:25.930
绑定点我们称之为什么

00:11:23.350 --> 00:11:32.320
称此接口为PV 

00:11:25.930 --> 00:11:35.860
好点的目的地等于PV好，所以我

00:11:32.320 --> 00:11:40.480
想说综合浏览量PV复数对

00:11:35.860 --> 00:11:43.570
并且我们还想指定我们

00:11:40.480 --> 00:11:45.130
应该配置好一些

00:11:43.570 --> 00:11:47.380
关于生产者的事情

00:11:45.130 --> 00:11:49.150
我们想要将标头模式配置为

00:11:47.380 --> 00:11:50.830
好吧，所以我们去那里

00:11:49.150 --> 00:11:52.170
这就是我们需要的基础

00:11:50.830 --> 00:11:54.640
为此，让我们看看是否可行

00:11:52.170 --> 00:11:55.690
我们现在要合成一些数据，以便

00:11:54.640 --> 00:11:58.750
让我们考虑一下我们如何做到这一点

00:11:55.690 --> 00:12:01.270
有一些我要在这里有一些名字

00:11:58.750 --> 00:12:06.810
名称等于数组点作为列表，并且

00:12:01.270 --> 00:12:12.820
会是um会是一些名字

00:12:06.810 --> 00:12:24.630
我很确定还有一个P网，因此

00:12:12.820 --> 00:12:28.180
轻笑SCH AC在o0tg杀死Abel 

00:12:24.630 --> 00:12:33.370
罗素好吧，我们有几个人

00:12:28.180 --> 00:12:36.550
这里实际上是示例名称

00:12:33.370 --> 00:12:38.440
费舍尔，我们有些人

00:12:36.550 --> 00:12:41.260
在消息传递方面工作

00:12:38.440 --> 00:12:42.670
等等，我可以不必

00:12:41.260 --> 00:12:44.440
那里很好，所以有我们的名字

00:12:42.670 --> 00:12:46.690
然后有一些页面可以

00:12:44.440 --> 00:12:49.900
网站上的页面，所以说

00:12:46.690 --> 00:12:51.190
您知道的博客Sitemap英语我确定

00:12:49.900 --> 00:12:52.570
希望因为所有网站都很好

00:12:51.190 --> 00:12:55.840
网站将有一个Spring 初始化器

00:12:52.570 --> 00:12:57.700
当然，人们有新闻快讯

00:12:55.840 --> 00:13:04.180
网站kala发现他们应该

00:12:57.700 --> 00:13:06.220
还有什么我们想要的

00:13:04.180 --> 00:13:07.030
好的，所以现在我们有了一些名字

00:13:06.220 --> 00:13:08.590
我们要做的是

00:13:07.030 --> 00:13:12.280
生成我们要运行一个线程

00:13:08.590 --> 00:13:13.660
那个会定期

00:13:12.280 --> 00:13:15.640
将一些数据写入消息队列

00:13:13.660 --> 00:13:20.470
对，这样线程就可以运行

00:13:15.640 --> 00:13:23.380
由遗嘱执行人送出休息

00:13:20.470 --> 00:13:26.560
使用所有人的正面的留言

00:13:23.380 --> 00:13:27.700
其次，我们去那里是我们的

00:13:26.560 --> 00:13:29.490
现在可以运行了，我们需要实际保存

00:13:27.700 --> 00:13:31.990
一些数据，所以我们做的是int 

00:13:29.490 --> 00:13:37.420
让我们看看我们想获得随机名称

00:13:31.990 --> 00:13:45.080
和一个随机页面，因此我们的页面等于new 

00:13:37.420 --> 00:13:49.390
随机点next int和

00:13:45.080 --> 00:13:52.700
何时花费其他页面大小和

00:13:49.390 --> 00:13:57.470
那是一个数字，所以让我们开始

00:13:52.700 --> 00:14:03.170
两页中的数字点获取，然后

00:13:57.470 --> 00:14:05.090
我们的名字叫点大小好，这样

00:14:03.170 --> 00:14:07.820
看起来那将是正确的，所以

00:14:05.090 --> 00:14:09.380
随机页面的随机名称，我们将发送

00:14:07.820 --> 00:14:11.540
这些数据将在我们将构建的消息中

00:14:09.380 --> 00:14:13.250
这里是一个消息生成器点

00:14:11.540 --> 00:14:15.350
有效载荷，有效载荷当然是

00:14:13.250 --> 00:14:17.420
将成为页面视图类型的对象

00:14:15.350 --> 00:14:20.000
今晚有活动，让我们做一个新页面

00:14:17.420 --> 00:14:24.170
查看事件，我们会说这个名字

00:14:20.000 --> 00:14:26.570
是页面上的随机名称是随机的

00:14:24.170 --> 00:14:28.010
页面和持续时间在这种情况下

00:14:26.570 --> 00:14:32.110
所以我们有一些需要配合的东西

00:14:28.010 --> 00:14:35.600
以后将是十个或一个

00:14:32.110 --> 00:14:36.830
一千个为什么为什么不让我们就这样

00:14:35.600 --> 00:14:38.720
有一些我们可以分叉的东西

00:14:36.830 --> 00:14:40.340
只要更长的数据

00:14:38.720 --> 00:14:42.050
大于十的我们将对其进行过滤

00:14:40.340 --> 00:14:44.330
以后出去好吧，我要说页面

00:14:42.050 --> 00:14:46.310
查看事件我想设置标题和

00:14:44.330 --> 00:14:49.580
该标题将是一个关键，所以我

00:14:46.310 --> 00:14:52.730
要说卡夫卡标题点消息密钥

00:14:49.580 --> 00:14:55.400
在这种情况下，关键是

00:14:52.730 --> 00:15:00.050
查看名称而不是页面查看事件

00:14:55.400 --> 00:15:01.370
没有获得用户ID Duncan字节，然后

00:15:00.050 --> 00:15:02.930
我们会建立记录好吗

00:15:01.370 --> 00:15:05.330
我会给我们一个对象，然后

00:15:02.930 --> 00:15:08.780
发送该输出通道，所以现在我们

00:15:05.330 --> 00:15:12.830
可以做到这一点，以便该页面可以查看

00:15:08.780 --> 00:15:14.800
点向所有人发送消息，这样

00:15:12.830 --> 00:15:16.820
有我们的记录就有我们的数据

00:15:14.800 --> 00:15:21.800
有一切，我们

00:15:16.820 --> 00:15:24.380
期待现在一切，让我们继续前进， 

00:15:21.800 --> 00:15:26.390
看看现在能给我们带来什么，我要去

00:15:24.380 --> 00:15:28.790
提前将其包装在try-catch中

00:15:26.390 --> 00:15:30.470
因为如果你不抓的话它很安静

00:15:28.790 --> 00:15:33.050
您不会知道的任何错误

00:15:30.470 --> 00:15:39.010
让我们来做我们需要的那个日志点错误

00:15:33.050 --> 00:15:42.639
一个记录器，我想我们可以使用该记录了， 

00:15:39.010 --> 00:15:47.269
这里的日志点

00:15:42.639 --> 00:15:49.750
信息是我们的错误，不，他们去了

00:15:47.269 --> 00:15:49.750
另一个不是吗

00:15:50.589 --> 00:16:08.660
 log4j爱情extern评论日志哇女孩

00:16:02.060 --> 00:16:13.399
是的，这实际上是什么？ 

00:16:08.660 --> 00:16:17.360
给你任何让我们做的

00:16:13.399 --> 00:16:21.709
手动发私人最终日志日志

00:16:17.360 --> 00:16:26.149
等于工厂没有获得良好的日志

00:16:21.709 --> 00:16:32.990
瞧，所以我现在有这个日志了

00:16:26.149 --> 00:16:38.000
似乎很沮丧哦错误的登录再见

00:16:32.990 --> 00:16:42.379
你，你好，好吧，这是

00:16:38.000 --> 00:16:42.879
现在我们说一个对数点错误

00:16:42.379 --> 00:16:45.079
对

00:16:42.879 --> 00:16:46.189
这样就可以了

00:16:45.079 --> 00:16:48.470
编码问题不会发送此

00:16:46.189 --> 00:16:49.730
留言将很快找到它

00:16:48.470 --> 00:16:51.410
好吧，我们要安排这个

00:16:49.730 --> 00:16:53.060
线程每隔一秒钟发送一次

00:16:51.410 --> 00:16:56.240
随机名称和周围的新记录

00:16:53.060 --> 00:16:58.630
在随机用户和随机页面上看到

00:16:56.240 --> 00:16:58.630
怎么了

00:17:06.340 --> 00:17:10.840
我没有看到任何错误，我应该

00:17:08.770 --> 00:17:15.400
收到确认消息

00:17:10.840 --> 00:17:20.340
在这里记录信息发送的消息

00:17:15.400 --> 00:17:20.340
串好

00:17:28.520 --> 00:17:31.940
好的，所以有一个消息是

00:17:30.230 --> 00:17:33.710
发送有一个页面，你可以

00:17:31.940 --> 00:17:37.520
看到它有随机的名称和用户

00:17:33.710 --> 00:17:38.840
随机持续时间等，所以现在我们

00:17:37.520 --> 00:17:40.490
有一个数据源，我们可以

00:17:38.840 --> 00:17:43.040
我们要处理这些数据的过程

00:17:40.490 --> 00:17:44.900
使用Kafka流，所以我们再次使用

00:17:43.040 --> 00:17:47.270
卡夫卡流卡夫卡流是

00:17:44.900 --> 00:17:49.790
处理API是流处理

00:17:47.270 --> 00:17:50.750
 API，可以用来做很多

00:17:49.790 --> 00:17:54.020
你本来会做的同样的事情

00:17:50.750 --> 00:17:59.450
考虑使用类似Apache的东西

00:17:54.020 --> 00:18:01.270
暴风雨或火花或类似的东西

00:17:59.450 --> 00:18:03.230
这些是流处理引擎

00:18:01.270 --> 00:18:08.540
但是有很大的不同

00:18:03.230 --> 00:18:10.250
这里为了使用卡夫卡流所有

00:18:08.540 --> 00:18:12.410
您需要的是Kafka流是一个图书馆吗

00:18:10.250 --> 00:18:14.750
只是它在上下文中运行的库

00:18:12.410 --> 00:18:16.460
您的计算机上的应用程序

00:18:14.750 --> 00:18:17.570
在同一笔记中，它不需要

00:18:16.460 --> 00:18:19.370
单独的集群，不需要

00:18:17.570 --> 00:18:22.309
单独的处理拓扑不会

00:18:19.370 --> 00:18:25.010
需要一个自定义序列化结构

00:18:22.309 --> 00:18:27.740
您的工作量或运行量

00:18:25.010 --> 00:18:30.050
在您的代码中，因此您可以挂断电话

00:18:27.740 --> 00:18:31.850
 Kafka将处理流从

00:18:30.050 --> 00:18:34.790
像我们这样的 spring boot 应用程序

00:18:31.850 --> 00:18:36.770
在这里，并利用它

00:18:34.790 --> 00:18:38.540
他们没有额外的并发症

00:18:36.770 --> 00:18:39.920
对，这只是一个存在的图书馆

00:18:38.540 --> 00:18:41.510
在快速的道路上，这是一个编程

00:18:39.920 --> 00:18:44.390
模型，因此可以很好地与

00:18:41.510 --> 00:18:45.920
您拥有的任何其他JVM代码，以及

00:18:44.390 --> 00:18:48.860
使其变得无价，这意味着您可以

00:18:45.920 --> 00:18:50.240
轻松部署此应用程序

00:18:48.860 --> 00:18:51.559
你可以拿这个，这只是一个常规

00:18:50.240 --> 00:18:54.220
 Spring ，您可以采取的应用程序

00:18:51.559 --> 00:18:56.809
这，你知道你连接到

00:18:54.220 --> 00:19:00.230
您知道托管的冲突云

00:18:56.809 --> 00:19:02.179
合流的Apache Kafka版本

00:19:00.230 --> 00:19:03.890
卡夫卡背后的公司，你可以

00:19:02.179 --> 00:19:06.050
部署这个，你可以得到一个

00:19:03.890 --> 00:19:07.940
在冲突云上帐户，然后

00:19:06.050 --> 00:19:09.710
暴露给正在运行的应用程序

00:19:07.940 --> 00:19:12.140
在云供应商和Web服务上

00:19:09.710 --> 00:19:13.640
您可以与之交谈的示例权利

00:19:12.140 --> 00:19:15.530
可以轻松地将其部署到任何公众

00:19:13.640 --> 00:19:17.090
基础设施，那就很好了

00:19:15.530 --> 00:19:19.400
您不必担心13 

00:19:17.090 --> 00:19:20.630
部署Spark及其所有网络

00:19:19.400 --> 00:19:22.040
要求和所有这些东西是

00:19:20.630 --> 00:19:23.690
只是常规的Springwood应用程序

00:19:22.040 --> 00:19:25.460
当然有状态

00:19:23.690 --> 00:19:27.110
状态，但该状态保持在

00:19:25.460 --> 00:19:28.790
经纪所有您需要的能力

00:19:27.110 --> 00:19:31.550
运行此代码以进行处理

00:19:28.790 --> 00:19:32.660
卡夫卡流是卡夫卡就这样

00:19:31.550 --> 00:19:35.030
你弄清楚如何安装

00:19:32.660 --> 00:19:37.910
在融合云的情况下是

00:19:35.030 --> 00:19:39.650
超级，一旦你知道超级简单

00:19:37.910 --> 00:19:41.809
知道你完成了欧洲

00:19:39.650 --> 00:19:44.960
你去参加比赛了

00:19:41.809 --> 00:19:48.320
保持在处理之间

00:19:44.960 --> 00:19:50.779
卡夫卡本身内部的国家商店或

00:19:48.320 --> 00:19:53.359
它被保存在主题中，或者被保存在您体内

00:19:50.779 --> 00:19:55.249
知道各种各样的角落和缝隙

00:19:53.359 --> 00:19:56.779
在您的Kafka经纪人本身和

00:19:55.249 --> 00:19:58.999
该状态的复制已完成

00:19:56.779 --> 00:20:00.679
对你们来说，猜猜卡夫卡是什么

00:19:58.999 --> 00:20:02.330
如果您拥有卡夫卡，那么再次

00:20:00.679 --> 00:20:03.979
你想出了扩大规模的秘诀

00:20:02.330 --> 00:20:06.710
或优先处理

00:20:03.979 --> 00:20:08.899
卡夫卡，那么你做对了，我不

00:20:06.710 --> 00:20:10.249
需要任何额外的东西和那个状态

00:20:08.899 --> 00:20:14.450
也很有用，请看这里，让我们

00:20:10.249 --> 00:20:16.190
创建一个umSpring 切割组合

00:20:14.450 --> 00:20:18.499
传入的消息，所以消息

00:20:16.190 --> 00:20:23.749
将是字符串类型的

00:20:18.499 --> 00:20:25.489
这里的用户ID和有效负载

00:20:23.749 --> 00:20:28.179
可以进行网页浏览活动，所以我

00:20:25.489 --> 00:20:32.149
将创建Kafka流活页夹或

00:20:28.179 --> 00:20:33.499
为此绑定，因此在输入和

00:20:32.149 --> 00:20:41.989
我要在这里创建一个新变量

00:20:33.499 --> 00:20:45.529
和中的电视浏览量中的电视浏览量

00:20:41.989 --> 00:20:50.359
这将是K流和流页面视图

00:20:45.529 --> 00:20:53.479
活动页面浏览量还可以，因此

00:20:50.359 --> 00:20:55.849
您的传入消息您的传入消息

00:20:53.479 --> 00:20:57.559
卡夫卡流和此卡夫卡流

00:20:55.849 --> 00:20:59.659
显然您知道这是API 

00:20:57.559 --> 00:21:01.820
你可以自己创建这个

00:20:59.659 --> 00:21:04.039
有一个那个来

00:21:01.820 --> 00:21:05.059
繁琐的配置正在完成

00:21:04.039 --> 00:21:08.119
在这个 Spring 的课堂流中充满

00:21:05.059 --> 00:21:09.799
案例和布线，我会看到它

00:21:08.119 --> 00:21:11.809
这是在外部完成的，因此没有

00:21:09.799 --> 00:21:13.070
在此代码中提及主题

00:21:11.809 --> 00:21:16.820
我们有一个类型化的对象，我们可以

00:21:13.070 --> 00:21:19.159
让我们一起进行页面浏览

00:21:16.820 --> 00:21:20.359
所以我们在这里，在

00:21:19.159 --> 00:21:22.489
传入端，我们将拥有

00:21:20.359 --> 00:21:25.639
基本上是一样的东西

00:21:22.489 --> 00:21:29.629
同样的事情，但在反向所以PV 

00:21:25.639 --> 00:21:32.239
成为消费者，而不是消费者

00:21:29.629 --> 00:21:36.320
标头错误的生产者

00:21:32.239 --> 00:21:37.729
对，那就是我想我们

00:21:36.320 --> 00:21:38.330
为此，让我们继续看看

00:21:37.729 --> 00:21:40.309
怎么了

00:21:38.330 --> 00:21:42.259
我们需要实际处理这些数据

00:21:40.309 --> 00:21:43.429
现在，我们定义了绑定，但是

00:21:42.259 --> 00:21:45.919
最好的部分是我们现在可以

00:21:43.429 --> 00:21:48.109
使用此绑定来处理数据，以便

00:21:45.919 --> 00:21:54.730
让我们创建一个Spring Crud Stream 

00:21:48.109 --> 00:21:57.940
处理接收器，因此我们的页面浏览量

00:21:54.730 --> 00:22:01.379
事件同步好，这将是

00:21:57.940 --> 00:22:05.999
流侦听器公共无效过程

00:22:01.379 --> 00:22:11.009
输入分析绑定类

00:22:05.999 --> 00:22:15.399
没关系，而且

00:22:11.009 --> 00:22:22.749
我们将有K个流流页面视图

00:22:15.399 --> 00:22:29.320
事件事件好吧，让我们这样做

00:22:22.749 --> 00:22:33.340
所以现在私人最终日志工厂日志

00:22:29.320 --> 00:22:39.820
已经登录了，所以我们的传入

00:22:33.340 --> 00:22:43.090
消息事件以及我们想要做什么

00:22:39.820 --> 00:22:45.879
想获取这些数据并与之合作

00:22:43.090 --> 00:22:47.080
因此，让我们看点事件，我们知道

00:22:45.879 --> 00:22:50.919
我们将要获得的数据

00:22:47.080 --> 00:22:55.419
进来，我们想过滤它

00:22:50.919 --> 00:22:57.879
首先，我想说过滤一个新的

00:22:55.419 --> 00:23:00.159
谓词或提供谓词对象

00:22:57.879 --> 00:23:01.629
有类型的字符串和页面视图和

00:23:00.159 --> 00:23:03.700
这些都是卡夫卡事件

00:23:01.629 --> 00:23:05.499
这些不是来自Java 8的流类型

00:23:03.700 --> 00:23:07.210
所以这在理论上是有效的

00:23:05.499 --> 00:23:09.129
在较旧的API中工作的是较旧的JVM 

00:23:07.210 --> 00:23:10.690
虽然实际上冻结了 Spring 

00:23:09.129 --> 00:23:12.730
但是你在Java 8世界中

00:23:10.690 --> 00:23:14.549
如果使用前Muto，你们都应该

00:23:12.730 --> 00:23:16.809
顺便说一句，因为它不在通用航空中

00:23:14.549 --> 00:23:18.820
无论如何，您在Java 8 plus世界中

00:23:16.809 --> 00:23:21.549
所以我们要说价值点得到

00:23:18.820 --> 00:23:23.769
持续时间获取持续时间大于

00:23:21.549 --> 00:23:26.350
我们在哪里说十秒钟，所以

00:23:23.769 --> 00:23:27.879
我们的第一位lambda在那里，如果

00:23:26.350 --> 00:23:30.610
如果我们做到了，那么我们想

00:23:27.879 --> 00:23:31.990
我想说我想要一张地图

00:23:30.610 --> 00:23:34.419
要重新分配数据，所以我要

00:23:31.990 --> 00:23:36.190
我有记录流，所以每个

00:23:34.419 --> 00:23:39.340
记录将通过此过滤器

00:23:36.190 --> 00:23:41.860
方法，然后将其传递给此方法

00:23:39.340 --> 00:23:43.570
在这里我要分区

00:23:41.860 --> 00:23:46.029
流，我要说确定新密钥， 

00:23:43.570 --> 00:23:49.450
您应该管理的价值

00:23:46.029 --> 00:23:52.509
围绕页面和

00:23:49.450 --> 00:23:54.700
计数，所以我要说值点得到

00:23:52.509 --> 00:23:56.139
页，这我可以做0谁

00:23:54.700 --> 00:23:58.119
很好，我们实际上甚至都没有

00:23:56.139 --> 00:24:00.820
想要我们甚至不想要的号码

00:23:58.119 --> 00:24:04.269
我们关心的是价值

00:24:00.820 --> 00:24:04.899
计数，所以现在我们要创建一个

00:24:04.269 --> 00:24:06.850
计数

00:24:04.899 --> 00:24:09.009
好吧，让我们实际上只是

00:24:06.850 --> 00:24:11.440
在这里把这件外套打扫干净

00:24:09.009 --> 00:24:14.620
玩用lambda代替不要

00:24:11.440 --> 00:24:16.269
甚至需要那种好东西，现在我们要去

00:24:14.620 --> 00:24:18.909
在这里存储一些数据，所以我们要

00:24:16.269 --> 00:24:22.059
说他们想创造一个

00:24:18.909 --> 00:24:25.389
流中的所有记录

00:24:22.059 --> 00:24:27.820
好，以便创建该计数

00:24:25.389 --> 00:24:30.009
需要分组我想分组

00:24:27.820 --> 00:24:32.169
是的，在这种情况下，关键是我可以通过

00:24:30.009 --> 00:24:34.450
如果我喜欢使用自定义键值映射器

00:24:32.169 --> 00:24:35.919
输出类型是字符串或

00:24:34.450 --> 00:24:39.490
我想用作按键的豹

00:24:35.919 --> 00:24:41.980
这是你知道的字符串

00:24:39.490 --> 00:24:43.450
等，所以关键的价值和我想要的

00:24:41.980 --> 00:24:45.370
要做的只是按好键分区

00:24:43.450 --> 00:24:46.750
这是一个快捷语法

00:24:45.370 --> 00:24:47.919
那我当然可以做一个lambda但是

00:24:46.750 --> 00:24:50.529
甚至有一个甚至更好

00:24:47.919 --> 00:24:51.850
再见密钥，现在我要存储

00:24:50.529 --> 00:24:53.080
计数，并且该计数是有状态的

00:24:51.850 --> 00:24:54.820
记住我们要做的是在哪里

00:24:53.080 --> 00:24:57.159
每当每一个消息传来

00:24:54.820 --> 00:24:59.679
每次有消息通过

00:24:57.159 --> 00:25:01.330
具有此密钥的处理流程

00:24:59.679 --> 00:25:03.610
在这种情况下，关键是

00:25:01.330 --> 00:25:06.220
页面，所以假设有一条消息

00:25:03.610 --> 00:25:08.259
在和页面初始化好我

00:25:06.220 --> 00:25:09.519
想要保持计数，我该怎么办

00:25:08.259 --> 00:25:11.470
保持，我不想保留在

00:25:09.519 --> 00:25:13.240
 JVM上的相同注释在此发布

00:25:11.470 --> 00:25:13.690
本身，我将其保留在

00:25:13.240 --> 00:25:15.700
经纪人

00:25:13.690 --> 00:25:17.980
所以实际上有一个整体

00:25:15.700 --> 00:25:21.519
你知道的持久子系统

00:25:17.980 --> 00:25:23.529
这是暴露给你的，而不仅仅是

00:25:21.519 --> 00:25:26.440
这个话题的想法还可以通过

00:25:23.529 --> 00:25:27.399
这个物化视图的想法，所以我

00:25:26.440 --> 00:25:29.379
想要保持该数量，然后

00:25:27.399 --> 00:25:32.139
增加数字，所以我要说

00:25:29.379 --> 00:25:35.679
体现为，我给它起一个名字

00:25:32.139 --> 00:25:38.500
我给它一个字符串页面浏览量

00:25:35.679 --> 00:25:40.299
页数实例化视图可以

00:25:38.500 --> 00:25:46.539
所以我将使用分析绑定

00:25:40.299 --> 00:25:48.070
那里的页面数不变

00:25:46.539 --> 00:25:53.620
物化视图可以

00:25:48.070 --> 00:25:54.789
 MD等等，所以我们不需要做

00:25:53.620 --> 00:25:56.679
可以配置的任何东西

00:25:54.789 --> 00:25:57.389
视图，但这很好，因为我们会发现

00:25:56.679 --> 00:25:59.200
后来我们可以

00:25:57.389 --> 00:26:01.509
审讯这种matthias的观点

00:25:59.200 --> 00:26:03.129
实际上以独立于

00:26:01.509 --> 00:26:06.519
这个消息传递的抽象

00:26:03.129 --> 00:26:08.500
只是卡夫卡给你，所以计数是

00:26:06.519 --> 00:26:10.600
现在，如果你看，如果你看

00:26:08.500 --> 00:26:12.549
返回来自的返回值

00:26:10.600 --> 00:26:15.639
算数电话，你得到的东西叫做

00:26:12.549 --> 00:26:17.769
 K表和ak表是不同的

00:26:15.639 --> 00:26:20.980
事例比事例流

00:26:17.769 --> 00:26:23.500
是连续的消息序列

00:26:20.980 --> 00:26:25.300
有些可能与您所知道的完全相同

00:26:23.500 --> 00:26:27.280
它们可能具有与以下相同的数据和密钥

00:26:25.300 --> 00:26:30.850
以前的消息，但这没关系

00:26:27.280 --> 00:26:34.390
这是持续不断的

00:26:30.850 --> 00:26:39.070
无界的流作为蛋糕桌

00:26:34.390 --> 00:26:43.360
是，而且永远都是最新的

00:26:39.070 --> 00:26:45.240
给定键的值可以，在这种情况下

00:26:43.360 --> 00:26:47.620
流可能有五个或十个

00:26:45.240 --> 00:26:48.730
相同键的消息可能全部

00:26:47.620 --> 00:26:50.140
也许他们有不同的价值观，也许

00:26:48.730 --> 00:26:51.490
他们没有，但你会拥有你

00:26:50.140 --> 00:26:53.320
如果您丢失大小写字符串，则能够

00:26:51.490 --> 00:26:55.330
您将可以访问全部十个

00:26:53.320 --> 00:26:57.309
那些具有相同密钥的消息

00:26:55.330 --> 00:26:59.320
 K表中您将有一个条目

00:26:57.309 --> 00:27:01.480
键，然后是最新的观察值

00:26:59.320 --> 00:27:03.309
对于那个关键的权利，所以这就像在

00:27:01.480 --> 00:27:05.500
时间像数据库表一样

00:27:03.309 --> 00:27:07.330
日志与事件顺序

00:27:05.500 --> 00:27:08.590
导致了变化，所以我们可以

00:27:07.330 --> 00:27:10.540
用这个K实际处理事物

00:27:08.590 --> 00:27:11.679
表，这很有趣

00:27:10.540 --> 00:27:14.110
本身，但我真正想做的是

00:27:11.679 --> 00:27:18.790
我要获取即将到来的数据

00:27:14.110 --> 00:27:20.800
从K表转为流

00:27:18.790 --> 00:27:22.360
然后将这些结果发送给另一个

00:27:20.800 --> 00:27:25.450
主题，以便我们可以在另一方面

00:27:22.360 --> 00:27:27.250
一边处理它们，一边进入k表

00:27:25.450 --> 00:27:29.020
另一段代码现在有很多

00:27:27.250 --> 00:27:30.280
你们当中有一个区别

00:27:29.020 --> 00:27:34.690
这是非常有趣的区别

00:27:30.280 --> 00:27:36.700
案例流和K表之间是

00:27:34.690 --> 00:27:40.900
卡夫卡流的原因之一是

00:27:36.700 --> 00:27:42.010
如此强大以至于二元性导致

00:27:40.900 --> 00:27:50.320
很多真的很强大

00:27:42.010 --> 00:27:55.270
卡夫卡的机会

00:27:50.320 --> 00:27:57.700
流事物可以从一个流到另一个

00:27:55.270 --> 00:28:01.059
其他非常流畅，所以我可以有一个卡夫卡

00:27:57.700 --> 00:28:02.320
流向我展示所有

00:28:01.059 --> 00:28:04.750
导致某事的事件，我可以

00:28:02.320 --> 00:28:06.130
有一张桌子给我看

00:28:04.750 --> 00:28:07.750
更改您知道的最终值

00:28:06.130 --> 00:28:09.490
那些东西记录得很好，我也可以

00:28:07.750 --> 00:28:12.070
然后把那个最终值列表

00:28:09.490 --> 00:28:13.540
进入事件，所以我实际上可以

00:28:12.070 --> 00:28:15.570
可以做你知道的事情

00:28:13.540 --> 00:28:18.670
以这种方式非常自然地采购

00:28:15.570 --> 00:28:21.280
你可能有一个卡夫卡

00:28:18.670 --> 00:28:24.400
具有所有

00:28:21.280 --> 00:28:27.940
曾经飞行的人

00:28:24.400 --> 00:28:30.040
正确，而卡夫卡表可以显示

00:28:27.940 --> 00:28:32.500
你多少人

00:28:30.040 --> 00:28:37.120
例如，飞行了一年或

00:28:32.500 --> 00:28:38.710
一个多月到不同国家

00:28:37.120 --> 00:28:41.050
东西，所以你可以说给定一个

00:28:38.710 --> 00:28:43.870
国家让我知道人数

00:28:41.050 --> 00:28:46.090
已经去那个国家了，这个

00:28:43.870 --> 00:28:48.730
带我们到另一个地方

00:28:46.090 --> 00:28:50.260
向您显示了一个计数，这个计数是

00:28:48.730 --> 00:28:51.910
在这种情况下，绝对数为K 

00:28:50.260 --> 00:28:53.470
表是一个绝对数字

00:28:51.910 --> 00:28:54.610
你会知道每一个

00:28:53.470 --> 00:28:56.860
见过的消息

00:28:54.610 --> 00:28:58.230
给我看看计数，但也许我不想

00:28:56.860 --> 00:29:00.790
也许我想真正得到一个

00:28:58.230 --> 00:29:02.620
算上最后一个小时的一切

00:29:00.790 --> 00:29:09.300
对，我实际上可以做到

00:29:02.620 --> 00:29:12.130
说由时间窗点

00:29:09.300 --> 00:29:15.220
比方说一千毫秒吧

00:29:12.130 --> 00:29:18.730
我一分钟一秒钟或六十秒

00:29:15.220 --> 00:29:19.690
所以现在我有一个开窗的桌子

00:29:18.730 --> 00:29:22.180
这实际上有点不同

00:29:19.690 --> 00:29:25.840
星期五，您可以看到它是

00:29:22.180 --> 00:29:27.400
窗口很长，所以会告诉我是否

00:29:25.840 --> 00:29:29.380
如果我将状态拉出

00:29:27.400 --> 00:29:30.940
另一面实际上会告诉我时间

00:29:29.380 --> 00:29:32.320
差距会告诉我你从中知道

00:29:30.940 --> 00:29:33.370
这个小时到这个小时，然后从

00:29:32.320 --> 00:29:35.200
像这个小时然后这个时代

00:29:33.370 --> 00:29:38.140
这个小时就是你将要拨打的号码

00:29:35.200 --> 00:29:41.500
得到你会寻求一个数组

00:29:38.140 --> 00:29:43.030
带有键的窗口，然后

00:29:41.500 --> 00:29:44.560
您将能够提取出

00:29:43.030 --> 00:29:46.390
在特定时间的那个窗口

00:29:44.560 --> 00:29:48.670
团体，这很方便

00:29:46.390 --> 00:29:51.010
因为你可以做像我一样的事情

00:29:48.670 --> 00:29:52.990
桶数据，你可以说好吧，这是

00:29:51.010 --> 00:29:54.910
现在是处理时间了

00:29:52.990 --> 00:29:55.960
那就是事件的时间

00:29:54.910 --> 00:29:58.270
这是这个东西的活动时间

00:29:55.960 --> 00:30:00.490
发生在现实世界中， 

00:29:58.270 --> 00:30:01.000
我想弄清楚什么

00:30:00.490 --> 00:30:03.940
看起来像

00:30:01.000 --> 00:30:07.090
后来对你积极地回溯

00:30:03.940 --> 00:30:08.890
知道我可以对我进行司法统计

00:30:07.090 --> 00:30:11.650
可以处理我可以使用的数据

00:30:08.890 --> 00:30:12.730
数据以找出事物发生的频率

00:30:11.650 --> 00:30:13.930
发生，那个状态也是

00:30:12.730 --> 00:30:14.980
有些东西你必须留在某个地方

00:30:13.930 --> 00:30:17.230
这是有这个的好地方

00:30:14.980 --> 00:30:19.450
一种统一的持久性方法

00:30:17.230 --> 00:30:22.030
对，所以你甚至可以知道这些

00:30:19.450 --> 00:30:25.960
您可以起源K表的TK表

00:30:22.030 --> 00:30:27.970
您实际上可以创建一个K表

00:30:25.960 --> 00:30:29.170
通过从

00:30:27.970 --> 00:30:30.700
数据库甚至可能是固定的

00:30:29.170 --> 00:30:32.650
数据库，但您可以将其放入K 

00:30:30.700 --> 00:30:34.540
桌子，然后最好的部分是一旦你

00:30:32.650 --> 00:30:37.570
有这些K表，他们是你知道的

00:30:34.540 --> 00:30:39.610
他们是他们建立的，你可以加入

00:30:37.570 --> 00:30:41.860
 K表，所以我可以有一个K表

00:30:39.610 --> 00:30:44.020
在另一个K表上联接，左联接

00:30:41.860 --> 00:30:45.549
你知道外加入利乐

00:30:44.020 --> 00:30:47.470
对于案件流也是如此， 

00:30:45.549 --> 00:30:50.200
我这里没有案子哦，我知道

00:30:47.470 --> 00:30:52.210
我可以说很多事件点连接K表

00:30:50.200 --> 00:30:56.919
那将加入事件

00:30:52.210 --> 00:30:59.650
留下了K中的记录

00:30:56.919 --> 00:31:01.510
在他们的T右边的桌子上，只要

00:30:59.650 --> 00:31:03.250
因为K表的键与

00:31:01.510 --> 00:31:05.470
一个事件，那么他们将

00:31:03.250 --> 00:31:08.169
匹配，我将得到结果

00:31:05.470 --> 00:31:13.929
是让我们看看确定表，这是一个愚蠢的

00:31:08.169 --> 00:31:21.730
例子，但是如果我做到了，我有什么

00:31:13.929 --> 00:31:24.250
在这里K表等，然后你可以

00:31:21.730 --> 00:31:26.799
提供新的价值竞合者，使新的价值

00:31:24.250 --> 00:31:34.049
联合甚至更好，但只剩下

00:31:26.799 --> 00:31:38.440
加入K表和新价值联合

00:31:34.049 --> 00:31:40.210
依此类推，结果是您得到了

00:31:38.440 --> 00:31:42.159
流或随便你

00:31:40.210 --> 00:31:43.450
结果是，这是你知道的

00:31:42.159 --> 00:31:45.429
左边的值和

00:31:43.450 --> 00:31:46.960
对，我应该将它们汇总

00:31:45.429 --> 00:31:49.030
以某种方式，当然我可能有

00:31:46.960 --> 00:31:50.950
没有左加入，你知道这意味着我有

00:31:49.030 --> 00:31:52.600
左边的一切之一，但我

00:31:50.950 --> 00:31:54.880
可能会缺少一些匹配项

00:31:52.600 --> 00:31:56.590
例如，所以你知道就像

00:31:54.880 --> 00:31:58.240
像关系数据库一样的续集数据库

00:31:56.590 --> 00:31:59.919
数据库（如果您曾经从事过此类工作） 

00:31:58.240 --> 00:32:01.330
以前的成语现在你已经吃饱了

00:31:59.919 --> 00:32:03.880
控制结果流让我们

00:32:01.330 --> 00:32:08.080
说这是一个字符串好吧，让我们说

00:32:03.880 --> 00:32:10.470
不知何故我得到了一个字符串，我可以

00:32:08.080 --> 00:32:10.470
说

00:32:12.899 --> 00:32:17.940
是蒸汽，产生的串流

00:32:16.529 --> 00:32:20.339
或可能是一个更好的例子

00:32:17.940 --> 00:32:21.349
是约会或其他意思，所以您可以

00:32:20.339 --> 00:32:26.429
了解这里发生了什么

00:32:21.349 --> 00:32:30.089
日期日期对，所以现在这变成了

00:32:26.429 --> 00:32:31.679
迄今为止的字符串匹配

00:32:30.089 --> 00:32:33.389
强大的功能，您现在可以在

00:32:31.679 --> 00:32:35.099
你知道这两个都是移动目标

00:32:33.389 --> 00:32:36.509
那里都在不断更新

00:32:35.099 --> 00:32:38.519
但是现在你有能力

00:32:36.509 --> 00:32:40.289
记忆中或飞行中

00:32:38.519 --> 00:32:41.609
在两个不同的地方做这些连接

00:32:40.289 --> 00:32:43.259
您可以做的不同的数据集

00:32:41.609 --> 00:32:45.210
相关性你可以说很好

00:32:43.259 --> 00:32:46.529
首先知道这里的所有

00:32:45.210 --> 00:32:48.239
点击了特定内容的人

00:32:46.529 --> 00:32:53.210
页面，然后在这里是K表

00:32:48.239 --> 00:32:55.440
告诉你你知道的

00:32:53.210 --> 00:32:58.440
有关该页面的相关信息

00:32:55.440 --> 00:32:59.639
你认识的人或可以打破的人

00:32:58.440 --> 00:33:01.259
记录下用户信息，也许我已经

00:32:59.639 --> 00:33:02.999
这里的用户信息我可以说还可以

00:33:01.259 --> 00:33:05.070
这是他们的网页浏览量

00:33:02.999 --> 00:33:07.259
然后我可以将其加入到

00:33:05.070 --> 00:33:08.429
的所有地理分布

00:33:07.259 --> 00:33:11.339
不同的人，不同的用户，我可以

00:33:08.429 --> 00:33:14.219
说旧金山和那个人

00:33:11.339 --> 00:33:16.440
城市，我可以安排，以便双方

00:33:14.219 --> 00:33:18.779
加入了用户ID，我可以找到

00:33:16.440 --> 00:33:20.549
有多少人访问特定页面

00:33:18.779 --> 00:33:21.479
例如，来自给定的区域

00:33:20.549 --> 00:33:24.989
可以做一些非常非常复杂的事情

00:33:21.479 --> 00:33:26.460
通过利用这一点

00:33:24.989 --> 00:33:28.349
连接能力和事实

00:33:26.460 --> 00:33:30.599
你有这些关键表与

00:33:28.349 --> 00:33:33.529
流，但他们是他们最终

00:33:30.599 --> 00:33:35.460
两者都有主题支持，所以

00:33:33.529 --> 00:33:39.719
我们想要做的就是要接受这个

00:33:35.460 --> 00:33:43.349
数据并将其转换为流并发送

00:33:39.719 --> 00:33:45.119
流返回以发送结果

00:33:43.349 --> 00:33:46.979
流到另一个主题，所以我

00:33:45.119 --> 00:33:50.549
要说一串字符串

00:33:46.979 --> 00:33:55.950
很久，我们要说的发送到和

00:33:50.549 --> 00:33:57.479
这将是全部页面数

00:33:55.950 --> 00:34:02.789
正确，因此分析功能可以绑定该页面

00:33:57.479 --> 00:34:08.220
数出页面数出来好吗

00:34:02.789 --> 00:34:11.490
不断的PC退出，我们将进入

00:34:08.220 --> 00:34:15.149
我们知道一切都会好起来的

00:34:11.490 --> 00:34:17.970
所以回到这里的代码

00:34:15.149 --> 00:34:20.190
改变我们的处理器，所以

00:34:17.970 --> 00:34:21.880
这种情况下，我们需要返回

00:34:20.190 --> 00:34:26.500
数据如此返回

00:34:21.880 --> 00:34:27.610
像那样，是的，有点

00:34:26.500 --> 00:34:28.750
更容易阅读到那里，这是一个

00:34:27.610 --> 00:34:30.610
好一点，所以我们说

00:34:28.750 --> 00:34:32.530
处理输入的数据

00:34:30.610 --> 00:34:33.970
网页浏览量会给我们一种

00:34:32.530 --> 00:34:35.380
流，我们要把它变成

00:34:33.970 --> 00:34:38.800
在这另一种流

00:34:35.380 --> 00:34:40.690
情况下这是两个计数的页面流

00:34:38.800 --> 00:34:42.850
对，这是总数，然后

00:34:40.690 --> 00:34:45.460
我要列出的是

00:34:42.850 --> 00:34:47.410
把那张桌子变成溪流，所以现在

00:34:45.460 --> 00:34:50.380
我会得到一个新的话题

00:34:47.410 --> 00:34:52.120
新主题将包含所有键和

00:34:50.380 --> 00:34:52.630
任何时候只要有关键变化我都会得到一个新的

00:34:52.120 --> 00:34:54.280
记录

00:34:52.630 --> 00:34:55.990
好吧，所以如果关键是你知道

00:34:54.280 --> 00:34:57.220
初始值设定项，第一个值是一个

00:34:55.990 --> 00:34:58.450
我会得到一个新记录的

00:34:57.220 --> 00:35:00.480
一个然后如果有人设置

00:34:58.450 --> 00:35:03.010
记录下来，以了解他们是否

00:35:00.480 --> 00:35:04.740
计数增加-什么-然后我会得到

00:35:03.010 --> 00:35:07.090
该等的新记录，但我不会

00:35:04.740 --> 00:35:08.230
你知道我想我要去

00:35:07.090 --> 00:35:11.020
每个事件我都会得到

00:35:08.230 --> 00:35:15.070
更改正确的四个计数，所以

00:35:11.020 --> 00:35:17.350
现在我们需要

00:35:15.070 --> 00:35:18.970
配置这个输出通道这个

00:35:17.350 --> 00:35:20.980
输出绑定在这里，所以我就是

00:35:18.970 --> 00:35:22.900
在这里转发消息，这是一个

00:35:20.980 --> 00:35:25.330
处理器，那么他实际上应该调用

00:35:22.900 --> 00:35:27.760
这是消息传递池中的处理器

00:35:25.330 --> 00:35:29.560
 page.you事件处理器，我要去

00:35:27.760 --> 00:35:32.200
发送此页面计数和

00:35:29.560 --> 00:35:38.980
页面计数绑定将是

00:35:32.200 --> 00:35:43.450
只是这将是aaa案例

00:35:38.980 --> 00:35:44.620
梦想，但我们把它当作是

00:35:43.450 --> 00:35:52.750
这是我们要发送的密钥流

00:35:44.620 --> 00:35:59.590
出，因此输出和页数出K 

00:35:52.750 --> 00:36:01.480
流字符串长页全部计数

00:35:59.590 --> 00:36:07.860
对，所以有一个页面

00:36:01.480 --> 00:36:11.170
算出来，现在我们要

00:36:07.860 --> 00:36:13.840
处理这些数据，所以我们要处理

00:36:11.170 --> 00:36:20.410
数据输入，所以我们现在也有了

00:36:13.840 --> 00:36:23.830
输入K表，因此输入页数

00:36:20.410 --> 00:36:27.570
这里我们要定义一个K表

00:36:23.830 --> 00:36:29.630
类型的字符串太长，因此页数在

00:36:27.570 --> 00:36:31.790
好吧

00:36:29.630 --> 00:36:33.920
所以现在我们需要配置

00:36:31.790 --> 00:36:38.630
页数进出，让我们开始吧

00:36:33.920 --> 00:36:46.670
在配置文件中，以便页面计数

00:36:38.630 --> 00:36:49.220
让我们来看看

00:36:46.670 --> 00:36:50.510
对于配置，这会有点

00:36:49.220 --> 00:36:54.590
更麻烦的是我们必须实际指定

00:36:50.510 --> 00:36:56.120
这里有很多配置，但是

00:36:54.590 --> 00:36:58.370
为此我们确实获得了很多好处

00:36:56.120 --> 00:36:59.870
至少它至少我们知道它是你

00:36:58.370 --> 00:37:01.970
知道这样做是有好处的

00:36:59.870 --> 00:37:04.100
我们想要镜像我们的代码的东西

00:37:01.970 --> 00:37:06.230
非常复杂

00:37:04.100 --> 00:37:08.680
它作为配置参数，所以这里

00:37:06.230 --> 00:37:11.690
我们要说 Spring 的云流

00:37:08.680 --> 00:37:16.880
绑定点我们怎么说我们称之为

00:37:11.690 --> 00:37:18.890
 um PC out PC out点目标等于

00:37:16.880 --> 00:37:22.510
个，让我们称之为

00:37:18.890 --> 00:37:27.380
主题和PC输出点生产者

00:37:22.510 --> 00:37:28.760
点使用本机编码等于true和

00:37:27.380 --> 00:37:30.800
那么我们需要指定

00:37:28.760 --> 00:37:33.920
值中的键的序列化

00:37:30.800 --> 00:37:36.470
对于这个特定的频道，如此 Spring ，我们

00:37:33.920 --> 00:37:42.590
可以在这里复制这个基本想法

00:37:36.470 --> 00:37:45.230
它的前缀好吧，所以 Spring 的云

00:37:42.590 --> 00:37:47.780
溪流粘合剂，洒水咳嗽

00:37:45.230 --> 00:37:56.170
束缚者的家伙

00:37:47.780 --> 00:37:59.660
绑定点PC输出点生产者点

00:37:56.170 --> 00:38:01.400
值是关键三分之一，所以

00:37:59.660 --> 00:38:05.600
关键，所以德将非常类似于

00:38:01.400 --> 00:38:08.990
这将是三分之一弦，但是

00:38:05.600 --> 00:38:10.730
在这里，我们要用一个很长的塞拉先生

00:38:08.990 --> 00:38:14.960
一天没事，所以钥匙里有钥匙

00:38:10.730 --> 00:38:19.310
价值先生在那里，当你做同样的

00:38:14.960 --> 00:38:20.330
另一面的东西也会

00:38:19.310 --> 00:38:21.530
即使我不这样做也可能仍然可以工作

00:38:20.330 --> 00:38:22.790
麻烦，但我们确实需要完成这项工作

00:38:21.530 --> 00:38:25.130
所以现在就做吧

00:38:22.790 --> 00:38:26.840
主要位在这里主要不同

00:38:25.130 --> 00:38:30.380
当然是同一目的地

00:38:26.840 --> 00:38:37.430
对，所以我们知道那是很好的PC 

00:38:30.380 --> 00:38:39.140
并再次插入PC，在这里我们还需要

00:38:37.430 --> 00:38:40.850
一群专属的消费群体

00:38:39.140 --> 00:38:42.380
我要说的是该小组正在

00:38:40.850 --> 00:38:43.280
被称为和平，是的

00:38:42.380 --> 00:38:50.150
问题

00:38:43.280 --> 00:38:53.060
这里我要指定PC端PC端

00:38:50.150 --> 00:38:56.920
消费者消费者关键先生

00:38:53.060 --> 00:39:00.050
跳得很好，所以给了我们一个

00:38:56.920 --> 00:39:02.210
我们使用本地编码的目的地

00:39:00.050 --> 00:39:10.010
我们要指定的标头模式

00:39:02.210 --> 00:39:12.980
当然，标题模式会出错

00:39:10.010 --> 00:39:15.020
我要指定的一个是

00:39:12.980 --> 00:39:21.280
对吧，让我们带来梦想吧

00:39:15.020 --> 00:39:28.060
我想指定一个这样的消费者

00:39:21.280 --> 00:39:30.470
点头模式等于原始模式

00:39:28.060 --> 00:39:33.340
这也是一个消费者，因为

00:39:30.470 --> 00:39:40.970
传入的数据，所以我们有消费者

00:39:33.340 --> 00:39:44.900
到处都是正确的权利，让我们看看

00:39:40.970 --> 00:39:48.320
就是我们一二三四

00:39:44.900 --> 00:39:49.370
五六，所以看起来不错我

00:39:48.320 --> 00:39:51.860
认为那是对的，仅此而已

00:39:49.370 --> 00:39:53.360
需要做这项工作

00:39:51.860 --> 00:39:56.020
影片内容类型假定为

00:39:53.360 --> 00:40:01.400
内容类型我不确定

00:39:56.020 --> 00:40:06.410
内容类型等于应用程序

00:40:01.400 --> 00:40:09.170
 JSON可以，现在可以了

00:40:06.410 --> 00:40:11.960
我们有更新的配置

00:40:09.170 --> 00:40:13.820
现在有一个页面进出我们

00:40:11.960 --> 00:40:16.640
进出页面的页面让我们移动

00:40:13.820 --> 00:40:22.520
在这里与其相关的东西

00:40:16.640 --> 00:40:26.450
页面浏览量页面计数输出页面计数

00:40:22.520 --> 00:40:28.820
输入页面数出来，仅此而已

00:40:26.450 --> 00:40:30.380
这是现在的配置，如果这

00:40:28.820 --> 00:40:33.080
正确进行，我们现在应该能够

00:40:30.380 --> 00:40:36.440
编写一些代码来处理

00:40:33.080 --> 00:40:40.820
数据来自K表，所以

00:40:36.440 --> 00:40:45.650
添加组件公共静态类页面

00:40:40.820 --> 00:40:49.220
计数同步好了，我们要开始了

00:40:45.650 --> 00:40:55.570
有一个流监听器，我们会说

00:40:49.220 --> 00:41:02.650
分析绑定点页数

00:40:55.570 --> 00:41:10.600
我们在输入时进入了公共无效流程

00:41:02.650 --> 00:41:17.090
这将是一个很长的关键表字符串

00:41:10.600 --> 00:41:19.790
做好准备，所以现在我们有了

00:41:17.090 --> 00:41:22.369
有计数，在计数中

00:41:19.790 --> 00:41:23.930
部分，我们将只访问

00:41:22.369 --> 00:41:26.180
数据，所以我们可以说流我要去

00:41:23.930 --> 00:41:28.550
从桌子变成小溪， 

00:41:26.180 --> 00:41:31.220
然后我们将使用

00:41:28.550 --> 00:41:32.720
每个动作的新动作，我都会记录下来

00:41:31.220 --> 00:41:34.160
退出，所以我们只是注销数据

00:41:32.720 --> 00:41:37.400
只是为了确认我们的想法

00:41:34.160 --> 00:41:42.710
发生，因此最终日志日志等于日志

00:41:37.400 --> 00:41:49.480
工厂尚未获取日志，那就是

00:41:42.710 --> 00:41:54.170
只需注销所有内容，再加上一个加值

00:41:49.480 --> 00:41:55.280
所以有一个让我们看看我们得到的是

00:41:54.170 --> 00:41:59.390
那应该工作，应该应该

00:41:55.280 --> 00:42:03.260
看起来很简单的工作

00:41:59.390 --> 00:42:05.030
现在正在处理的页面计数接收器

00:42:03.260 --> 00:42:06.590
将要从中发送的数据

00:42:05.030 --> 00:42:09.080
处理的东西，以便数据将

00:42:06.590 --> 00:42:10.880
进来它会被发送出去

00:42:09.080 --> 00:42:13.130
处理器，它将被发送到页面

00:42:10.880 --> 00:42:15.920
算出主题，我们可以看到

00:42:13.130 --> 00:42:17.960
页面计数出主题指向个人电脑

00:42:15.920 --> 00:42:19.520
然后在另一边输入

00:42:17.960 --> 00:42:21.200
将有一个输入来处理

00:42:19.520 --> 00:42:22.850
来自PC的数据，因为我现在正在做这一切

00:42:21.200 --> 00:42:24.290
在相同的应用程序中，但可以

00:42:22.850 --> 00:42:26.300
想象没有理由

00:42:24.290 --> 00:42:28.310
不能是不同的接收者和来源

00:42:26.300 --> 00:42:30.530
在不同的微服务中不同

00:42:28.310 --> 00:42:32.060
每个应用程序专注于一个

00:42:30.530 --> 00:42:34.730
的特定方面

00:42:32.060 --> 00:42:35.750
应用程序就可以了

00:42:34.730 --> 00:42:39.430
让我们看看是否行得通

00:42:35.750 --> 00:42:39.430
并开始运行

00:42:44.070 --> 00:42:50.130
寄出一个好消息，希望是

00:42:47.050 --> 00:42:50.130
去这里工作

00:42:59.869 --> 00:43:04.010
他们在某处是差事

00:43:12.920 --> 00:43:16.970
我们去看看那页数

00:43:15.140 --> 00:43:19.490
印加人现在正在获取数据，因此您可以看到

00:43:16.970 --> 00:43:21.170
这是这些的数量

00:43:19.490 --> 00:43:23.330
曾经看到过的消息

00:43:21.170 --> 00:43:25.130
特定页面反映在这里

00:43:23.330 --> 00:43:26.330
控制台好，所以可以正常工作了

00:43:25.130 --> 00:43:28.550
我们得到它，我们定期

00:43:26.330 --> 00:43:30.440
从表中获取数据， 

00:43:28.550 --> 00:43:32.120
现在向我们展示聚合

00:43:30.440 --> 00:43:33.860
我希望能够检查此数据

00:43:32.120 --> 00:43:35.870
对，这很好，我有这个

00:43:33.860 --> 00:43:37.760
然后能够掌握其状态的能力

00:43:35.870 --> 00:43:39.650
真正记得我们所说的数据

00:43:37.760 --> 00:43:41.060
也被写到州立商店

00:43:39.650 --> 00:43:43.640
对的就是这个东西

00:43:41.060 --> 00:43:45.830
状态存储是可查询的，因此相当

00:43:43.640 --> 00:43:48.200
在表面上休息一下

00:43:45.830 --> 00:43:52.970
风险控制者要公开的信息

00:43:48.200 --> 00:43:56.210
静态类计数其余控制器全部

00:43:52.970 --> 00:44:00.590
对，我要注入

00:43:56.210 --> 00:44:02.660
可查询的商店注册表并创建一个

00:44:00.590 --> 00:44:05.180
构造函数参数不能在这里

00:44:02.660 --> 00:44:06.860
端点获取映射，我将其称为

00:44:05.180 --> 00:44:10.340
缺乏更好的计数终点

00:44:06.860 --> 00:44:14.720
名称，只是它会

00:44:10.340 --> 00:44:19.640
算数，我们会把它们叫回

00:44:14.720 --> 00:44:26.980
在第二个字符串long中

00:44:19.640 --> 00:44:31.160
计数等于新的哈希图

00:44:26.980 --> 00:44:32.420
重新格式化好吧，我们还有另一个

00:44:31.160 --> 00:44:33.560
计数，而我要做的就是

00:44:32.420 --> 00:44:35.750
要使用那个寄存器，我要说

00:44:33.560 --> 00:44:37.280
这不注册点变得可信

00:44:35.750 --> 00:44:40.040
商店，我将使用该名称

00:44:37.280 --> 00:44:44.660
我们在绑定中创建了页面

00:44:40.040 --> 00:44:48.320
抱歉，页面计数分析绑定点

00:44:44.660 --> 00:44:50.270
页数MV和数据类型I 

00:44:48.320 --> 00:44:52.220
回去，我必须指定一个可信的

00:44:50.270 --> 00:44:55.100
存储类型我想要返回的数据类型

00:44:52.220 --> 00:44:56.890
虽然是一个关键值存储

00:44:55.100 --> 00:44:59.720
有窗户商店例如

00:44:56.890 --> 00:45:00.710
我们可以知道对应

00:44:59.720 --> 00:45:02.600
如果我们拥有的话，您将获得的数据

00:45:00.710 --> 00:45:05.180
在此之前使用过窗口运算符

00:45:02.600 --> 00:45:08.500
情况下，我们只有简单的键值，所以

00:45:05.180 --> 00:45:11.450
我们会把它拉回来好吧

00:45:08.500 --> 00:45:14.450
渴望存储所有数据

00:45:11.450 --> 00:45:16.280
它回来是一个关键

00:45:14.450 --> 00:45:20.120
字符串的Redis等值太长

00:45:16.280 --> 00:45:21.260
对，所以有这个，现在我要

00:45:20.120 --> 00:45:24.500
拜访那个日期我要说可查询的

00:45:21.260 --> 00:45:25.640
储存所有想法，这将使我

00:45:24.500 --> 00:45:28.609
迭代器

00:45:25.640 --> 00:45:33.829
我将在访问所有数据的同时

00:45:28.609 --> 00:45:36.619
所有下一个都有所有下一个点，我们将

00:45:33.829 --> 00:45:41.059
可以存储，所以我们要添加

00:45:36.619 --> 00:45:45.319
这到一个计数点目录值点

00:45:41.059 --> 00:45:49.039
键值点值，将返回

00:45:45.319 --> 00:45:50.329
很重要，所以这里有我们的简单地图

00:45:49.039 --> 00:45:51.859
我们只是吃完所有数据

00:45:50.329 --> 00:45:53.420
我要休息一下

00:45:51.859 --> 00:45:54.950
然后有人可以击中的端点

00:45:53.420 --> 00:45:56.630
在处理过程中看到

00:45:54.950 --> 00:45:58.900
情况如何，让我们看看

00:45:56.630 --> 00:45:58.900
看起来像

00:46:15.760 --> 00:46:29.180
好吧，我们得到了一些数据

00:46:18.770 --> 00:46:30.920
处理过的东西正在前进

00:46:29.180 --> 00:46:34.039
从一根电线穿过

00:46:30.920 --> 00:46:35.859
到另一个节点，时不时地

00:46:34.039 --> 00:46:41.720
我们在那里得到一些数据，现在我们去

00:46:35.859 --> 00:46:43.579
本地主机8080正斜杠计数和

00:46:41.720 --> 00:46:46.130
我们得到此JSON，向我们显示

00:46:43.579 --> 00:46:48.559
更新计数正确的数据在这里

00:46:46.130 --> 00:46:51.559
正在缓慢但稳定地更新为

00:46:48.559 --> 00:46:54.950
反映出我们在

00:46:51.559 --> 00:46:56.650
桌子好吧，所以我们只看了

00:46:54.950 --> 00:46:58.970
这里有几件事我们已经看过了

00:46:56.650 --> 00:47:01.390
我们看过一个冲刺的乡下人

00:46:58.970 --> 00:47:04.910
卡夫卡，虽然那只是一个快速

00:47:01.390 --> 00:47:05.809
回顾对我们的回顾

00:47:04.910 --> 00:47:08.240
在我们谈论之前看过

00:47:05.809 --> 00:47:11.089
 Spring Cloud Stream 和RabbitMQ，我们

00:47:08.240 --> 00:47:13.309
看着你知道的基本生产

00:47:11.089 --> 00:47:15.079
数据输入卡夫卡，我们谈论一下卡夫卡

00:47:13.309 --> 00:47:17.930
本身是非常有趣的

00:47:15.079 --> 00:47:19.520
技术，嗯，我们看到了

00:47:17.930 --> 00:47:21.049
用的越来越多了

00:47:19.520 --> 00:47:23.059
已经为数以千计的不同提供动力

00:47:21.049 --> 00:47:24.589
我记得这是现在的网站

00:47:23.059 --> 00:47:28.880
至少要几年

00:47:24.589 --> 00:47:31.430
几年来有个大故事

00:47:28.880 --> 00:47:33.619
 Netflix正在使用Kafka， 

00:47:31.430 --> 00:47:35.119
做十亿左右的事

00:47:33.619 --> 00:47:37.130
一天或类似的事件

00:47:35.119 --> 00:47:38.930
疯狂的事，一些疯狂的事

00:47:37.130 --> 00:47:40.369
那里通过的数据集卡夫卡

00:47:38.930 --> 00:47:41.779
系统没问题，那是几年

00:47:40.369 --> 00:47:44.119
至少在两年前

00:47:41.779 --> 00:47:45.829
也许更多，所以这是一回事

00:47:44.119 --> 00:47:46.970
我们看着我们看着他们 Spring 

00:47:45.829 --> 00:47:48.109
云流卡夫卡，然后我们看了看

00:47:46.970 --> 00:47:50.270
的

00:47:48.109 --> 00:47:55.369
 Kafka流支持正确，所以我们

00:47:50.270 --> 00:47:56.329
 Kafka流支持是关键

00:47:55.369 --> 00:47:57.770
我们在这里谈论的是

00:47:56.329 --> 00:47:59.480
我们想要关注的重点

00:47:57.770 --> 00:48:02.510
今天，让我们能够

00:47:59.480 --> 00:48:04.490
写入数据，然后对其进行处理以流式传输

00:48:02.510 --> 00:48:06.230
在它上面，然后我们进行流处理

00:48:04.490 --> 00:48:07.849
说我们知道它只是嵌入在我们的

00:48:06.230 --> 00:48:09.109
您看到的Springwood应用程序

00:48:07.849 --> 00:48:10.760
这个没什么特别的

00:48:09.109 --> 00:48:12.890
就是我可以部署的所谓的胖子罐

00:48:10.760 --> 00:48:14.630
它可以将finder爬到这里

00:48:12.890 --> 00:48:16.220
两个关键你知道关键

00:48:14.630 --> 00:48:17.630
我们可以部署的kubernetes服务PCAST 

00:48:16.220 --> 00:48:20.900
意思是说你想要什么

00:48:17.630 --> 00:48:22.549
可以将您知道的这些应用程序部署到

00:48:20.900 --> 00:48:24.770
直到像你一样云

00:48:22.549 --> 00:48:26.450
其他 Spring 优惠申请和

00:48:24.770 --> 00:48:28.230
 Kafka流支持在这里使用Kafka 

00:48:26.450 --> 00:48:30.300
作为商店，所以

00:48:28.230 --> 00:48:31.710
真的所有魔术都在发生， 

00:48:30.300 --> 00:48:32.850
你一定是因为你在交易

00:48:31.710 --> 00:48:34.440
与一家商店，并成为传感器

00:48:32.850 --> 00:48:35.609
涉及灭菌，您会看到

00:48:34.440 --> 00:48:36.750
那是前面和中心， 

00:48:35.609 --> 00:48:39.810
我们在这里要做的很多事情

00:48:36.750 --> 00:48:41.850
无论如何，您会看到“星期六”这个词

00:48:39.810 --> 00:48:43.500
那是一些东西的表面

00:48:41.850 --> 00:48:45.330
与以下事实有关： 

00:48:43.500 --> 00:48:47.010
持久数据最终记住

00:48:45.330 --> 00:48:49.109
卡夫卡不在乎，只是看到

00:48:47.010 --> 00:48:51.540
一堆无关紧要的字节

00:48:49.109 --> 00:48:54.140
这些字节的内容是什么

00:48:51.540 --> 00:48:57.000
一定然后最后我们

00:48:54.140 --> 00:48:58.710
宁愿继续，我们看到你

00:48:57.000 --> 00:49:00.810
可以做一些非常非常了解的事情

00:48:58.710 --> 00:49:03.840
用Spring进行有趣的路由

00:49:00.810 --> 00:49:05.490
云流，所以在这里我有一个输入K 

00:49:03.840 --> 00:49:07.590
字符串到页面查看事件的流，以及

00:49:05.490 --> 00:49:09.869
然后我说这是一个处理器，所以我

00:49:07.590 --> 00:49:16.380
创建的K字符串流太长了

00:49:09.869 --> 00:49:19.290
在这里只使用了一个值，但是没有

00:49:16.380 --> 00:49:23.130
我不能举例的原因

00:49:19.290 --> 00:49:24.750
实际发送给多个主题

00:49:23.130 --> 00:49:26.369
您可以发送两个实际上是

00:49:24.750 --> 00:49:29.369
数组，所以我可以发送这个

00:49:26.369 --> 00:49:31.619
数据到多对多

00:49:29.369 --> 00:49:33.000
多个主题的目的地，您

00:49:31.619 --> 00:49:34.230
知道这很棒，如果您正在参加活动

00:49:33.000 --> 00:49:36.570
采购以及我实际上可以说很好

00:49:34.230 --> 00:49:37.890
这是系统的状态，但是

00:49:36.570 --> 00:49:39.900
我希望其他人对此感兴趣

00:49:37.890 --> 00:49:41.220
根据状态更新自己

00:49:39.900 --> 00:49:43.470
例如知道它，这样您就可以

00:49:41.220 --> 00:49:44.970
在那儿做一些有趣的事情

00:49:43.470 --> 00:49:47.100
加入数据的可能性

00:49:44.970 --> 00:49:49.109
认为是你所知道的最多的之一

00:49:47.100 --> 00:49:50.640
您拥有的强大机会

00:49:49.109 --> 00:49:52.710
他们相信，这里有卡夫卡溪流

00:49:50.640 --> 00:49:56.190
接受两组不同的数据

00:49:52.710 --> 00:49:58.380
实时合并它们

00:49:56.190 --> 00:50:00.630
处理并合成

00:49:58.380 --> 00:50:01.950
数据我们还看了窗口

00:50:00.630 --> 00:50:04.170
是另一个非常神奇的功能

00:50:01.950 --> 00:50:05.400
您可以在卡夫卡溪流中进行

00:50:04.170 --> 00:50:08.880
状态被保存在某个地方

00:50:05.400 --> 00:50:10.619
在经纪人中，如果您

00:50:08.880 --> 00:50:12.300
比较一下，你知道这看起来非常

00:50:10.619 --> 00:50:15.060
熟悉Spring代码流

00:50:12.300 --> 00:50:16.680
支持反应堆，这样您就可以

00:50:15.060 --> 00:50:19.200
出版商等等，但这是状态

00:50:16.680 --> 00:50:20.580
因为反应堆是在内存中

00:50:19.200 --> 00:50:21.780
它在Java进程中的Java代码

00:50:20.580 --> 00:50:23.730
所以如果你想拥有的话

00:50:21.780 --> 00:50:25.470
需要在其中复制的状态

00:50:23.730 --> 00:50:26.790
节点没有办法做卡夫卡

00:50:25.470 --> 00:50:28.650
流使您能够扩展

00:50:26.790 --> 00:50:30.240
跨任意数量的节点

00:50:28.650 --> 00:50:31.619
并仍然保持一致

00:50:30.240 --> 00:50:34.350
所有正在处理的图片

00:50:31.619 --> 00:50:37.230
没有的东西等等

00:50:34.350 --> 00:50:38.910
状态管理已为您完成

00:50:37.230 --> 00:50:40.590
看着一张桌子，就像我说的K桌子

00:50:38.910 --> 00:50:42.040
是不同的略有不同的野兽

00:50:40.590 --> 00:50:43.240
但有双重性是对的

00:50:42.040 --> 00:50:44.770
让一个梦想成真

00:50:43.240 --> 00:50:46.360
并让关键表成为案例

00:50:44.770 --> 00:50:47.860
流，你可以在这里看到

00:50:46.360 --> 00:50:51.100
他们有一个关键表成为

00:50:47.860 --> 00:50:52.420
流等等，反之亦然，然后我们

00:50:51.100 --> 00:50:53.890
看着国家商店的权利

00:50:52.420 --> 00:50:56.650
国营商店，我只是用其中之一

00:50:53.890 --> 00:50:59.170
这里的例子，但你知道的表

00:50:56.650 --> 00:51:00.550
我们正在创造状态

00:50:59.170 --> 00:51:02.650
被写在某个地方

00:51:00.550 --> 00:51:03.880
具有审讯能力，因此您可以

00:51:02.650 --> 00:51:05.860
实际上看那个状态就像一个

00:51:03.880 --> 00:51:07.450
数据库，它成为键值存储

00:51:05.860 --> 00:51:09.520
那真的很强大，所以现在我

00:51:07.450 --> 00:51:11.110
其实只要你知道

00:51:09.520 --> 00:51:14.230
我可以强迫我所有的不同

00:51:11.110 --> 00:51:16.360
分散的数据集到一个关键表中

00:51:14.230 --> 00:51:18.280
或案例流，然后我可以处理它

00:51:16.360 --> 00:51:20.640
在这段代码中非常简单， 

00:51:18.280 --> 00:51:22.690
按摩等等，我可以这样做

00:51:20.640 --> 00:51:24.850
与规模无关，我是说我可以

00:51:22.690 --> 00:51:26.290
扩展到我们所说的情况

00:51:24.850 --> 00:51:28.150
 Netflix每天发生数十亿个事件，并且

00:51:26.290 --> 00:51:33.820
所以仍然是相同的基础

00:51:28.150 --> 00:51:36.610
现在，当我们使用洒水机制

00:51:33.820 --> 00:51:38.230
流和kafka流，我们得到了很多

00:51:36.610 --> 00:51:40.270
我们当然会建立的好处

00:51:38.230 --> 00:51:41.140
 spring boot 的顶部

00:51:40.270 --> 00:51:43.120
自动配置

00:51:41.140 --> 00:51:45.460
就像这样，记得我们有 Spring 

00:51:43.120 --> 00:51:47.020
卡夫卡项目是

00:51:45.460 --> 00:51:47.950
这里所有的自动配置

00:51:47.020 --> 00:51:49.900
给你自动的东西

00:51:47.950 --> 00:51:52.210
 Kafka模板的配置

00:51:49.900 --> 00:51:54.670
例如和您的消费者等等

00:51:52.210 --> 00:51:57.880
所以在你知道我可以说 Spring 

00:51:54.670 --> 00:52:02.800
卡夫卡引导服务器等于满吧

00:51:57.880 --> 00:52:04.660
我可以指向制作人

00:52:02.800 --> 00:52:06.790
信息客户ID观察者激光器

00:52:04.660 --> 00:52:09.100
我可以在此指定的所有内容

00:52:06.790 --> 00:52:09.970
基础最基本的水平，这是

00:52:09.100 --> 00:52:11.380
你必须要的那种东西

00:52:09.970 --> 00:52:13.780
记得在使用时设定

00:52:11.380 --> 00:52:16.330
融合云托管了一个Kafka 

00:52:13.780 --> 00:52:18.610
在 spring boot 中的示例示例权

00:52:16.330 --> 00:52:20.260
而这正是卡夫卡 Spring 的来临

00:52:18.610 --> 00:52:22.840
 Apache Kafka项目的项目 Spring 

00:52:20.260 --> 00:52:24.610
然后我们有 Spring 的云，我们有了 Spring 

00:52:22.840 --> 00:52:27.100
灌溉与卡夫卡社会创新

00:52:24.610 --> 00:52:28.420
和卡夫卡在横幅上有一个适配器

00:52:27.100 --> 00:52:29.920
午睡和Spring 适配器

00:52:28.420 --> 00:52:31.660
整合，然后我们有了 Spring 

00:52:29.920 --> 00:52:32.890
云流卡夫卡的支持是什么

00:52:31.660 --> 00:52:34.870
我们在这里看，然后有

00:52:32.890 --> 00:52:36.880
 Spring Cloud Stream 卡夫卡流

00:52:34.870 --> 00:52:38.320
支持，所以可能有点头晕

00:52:36.880 --> 00:52:39.730
但您可以在这里看到最高的

00:52:38.320 --> 00:52:41.500
最抽象的那些水平

00:52:39.730 --> 00:52:43.840
 api是 Spring 代码流Kafka 

00:52:41.500 --> 00:52:45.340
流支持我们获得了巨大的力量

00:52:43.840 --> 00:52:50.160
真的真的很方便

00:52:45.340 --> 00:52:55.830
加工技术

00:52:50.160 --> 00:53:00.510
好吧，我们看上去也是如此

00:52:55.830 --> 00:53:02.250
简要介绍了我们讨论的拓扑

00:53:00.510 --> 00:53:03.900
关于Kafka系统的拓扑，但是

00:53:02.250 --> 00:53:05.100
了解它真的很重要

00:53:03.900 --> 00:53:07.530
我们利用了事实

00:53:05.100 --> 00:53:08.910
这里有分区

00:53:07.530 --> 00:53:10.500
有小组，所以你在一眼看到

00:53:08.910 --> 00:53:12.930
我不得不使用一个小组，这允许

00:53:10.500 --> 00:53:15.120
必须有多个消费者

00:53:12.930 --> 00:53:17.190
收听您知道的其他流的听众

00:53:15.120 --> 00:53:18.330
那是很重要的部分

00:53:17.190 --> 00:53:19.290
你会发现什么时候得到的

00:53:18.330 --> 00:53:21.530
你潜入卡夫卡

00:53:19.290 --> 00:53:23.750
你需要真正关心的

00:53:21.530 --> 00:53:26.220
分区，您需要关心

00:53:23.750 --> 00:53:27.630
那里的消费者

00:53:26.220 --> 00:53:30.420
消费者中生产者的概念

00:53:27.630 --> 00:53:32.790
并且消费者最终包含了

00:53:30.420 --> 00:53:35.100
它知道它所知道的偏移量

00:53:32.790 --> 00:53:36.840
那个顺序有多少条记录

00:53:35.100 --> 00:53:38.700
它已读取的记录日志，它可以

00:53:36.840 --> 00:53:40.080
控制它可以寻求的

00:53:38.700 --> 00:53:42.120
最新的偏移量，只需从

00:53:40.080 --> 00:53:43.740
新的我开始处理并耗尽

00:53:42.120 --> 00:53:45.360
来自新队列的队列，或者可以去

00:53:43.740 --> 00:53:47.970
回到第一个并重播

00:53:45.360 --> 00:53:49.290
每个现有的消息和卡夫卡

00:53:47.970 --> 00:53:51.570
本身有一个日志

00:53:49.290 --> 00:53:53.160
这样他就可以将数据存储在文件中

00:53:51.570 --> 00:53:54.450
我说的系统可以是10 

00:53:53.160 --> 00:53:56.910
千字节或10 TB 

00:53:54.450 --> 00:53:58.140
没关系，所以你有很多

00:53:56.910 --> 00:54:00.180
的力量使它成为一个

00:53:58.140 --> 00:54:01.590
非常非常可靠的大型系统

00:54:00.180 --> 00:54:03.030
大量的数据，特别是大量

00:54:01.590 --> 00:54:05.010
需要处理的数据

00:54:03.030 --> 00:54:06.900
实时，当然，如果您在做

00:54:05.010 --> 00:54:09.150
就 spring boot 而言，它不能

00:54:06.900 --> 00:54:11.520
让我的朋友们变得更简单

00:54:09.150 --> 00:54:13.850
非常感谢您，我们将再见

00:54:11.520 --> 00:54:13.850
下次

00:54:19.660 --> 00:54:21.720
您

