WEBVTT
Kind: captions
Language: zh-Hans

00:00:13.820 --> 00:00:17.850
在今天的分期付款中吸引粉丝

00:00:16.099 --> 00:00:20.220
我们要去的 Spring 提示

00:00:17.850 --> 00:00:22.620
使用Spring Cloud Stream的应用程序

00:00:20.220 --> 00:00:24.060
在之前的视频中，我们看了 Spring 

00:00:22.620 --> 00:00:26.340
整合是一种构建方式

00:00:24.060 --> 00:00:28.619
干净的事件驱动的应用程序

00:00:26.340 --> 00:00:30.150
一致的方式，我们看到的一件事

00:00:28.619 --> 00:00:33.690
 Spring 的整合视频是

00:00:30.150 --> 00:00:35.520
消息通道可用于连接

00:00:33.690 --> 00:00:37.140
不同的组件

00:00:35.520 --> 00:00:38.820
在同一个虚拟机中或

00:00:37.140 --> 00:00:40.920
确实是分布的组件

00:00:38.820 --> 00:00:41.730
因为你可以在终点站

00:00:40.920 --> 00:00:44.790
这些不同渠道的难易程度

00:00:41.730 --> 00:00:46.199
适配器，这些适配器是其中之一

00:00:44.790 --> 00:00:49.080
Spring 的多种类型

00:00:46.199 --> 00:00:51.720
适配器随附的集成是

00:00:49.080 --> 00:00:53.879
旨在转变一个Spring Framework 

00:00:51.720 --> 00:00:56.430
通过Spring传递的消息

00:00:53.879 --> 00:00:58.159
框架消息通道成东西

00:00:56.430 --> 00:01:00.809
可以在外界使用

00:00:58.159 --> 00:01:03.269
我们可以使用Patrick Kafka我们可以

00:01:00.809 --> 00:01:05.610
使用uki，您知道我们可以使用它们Redis 

00:01:03.269 --> 00:01:07.170
我们可以使用Twitter，我们可以使用

00:01:05.610 --> 00:01:09.360
电子邮件，我们可以使用任何您使用的东西

00:01:07.170 --> 00:01:12.750
可以想象根据

00:01:09.360 --> 00:01:14.790
事件或消息可以改编为

00:01:12.750 --> 00:01:16.530
 Spring Framework消息，让我可以听

00:01:14.790 --> 00:01:18.600
来自外部的消息或事件

00:01:16.530 --> 00:01:20.760
每当有一封新电子邮件时我都可以说

00:01:18.600 --> 00:01:23.729
到达IMAP服务器IMAP空闲

00:01:20.760 --> 00:01:25.680
支持电子邮件服务发布

00:01:23.729 --> 00:01:27.630
消息或每当有新消息

00:01:25.680 --> 00:01:29.159
到达JMS代理发布

00:01:27.630 --> 00:01:30.689
消息，然后我将听

00:01:29.159 --> 00:01:33.210
另一端末尾的消息

00:01:30.689 --> 00:01:34.560
该频道的内容，所以我们有两个

00:01:33.210 --> 00:01:35.909
这里发生的事情我们有一个

00:01:34.560 --> 00:01:37.710
监视外部的组件

00:01:35.909 --> 00:01:39.840
世界，一旦它意识到

00:01:37.710 --> 00:01:42.030
事件将消息发布到该事件中

00:01:39.840 --> 00:01:43.200
频道和课程的另一面

00:01:42.030 --> 00:01:45.240
我们有一个监听它的组件

00:01:43.200 --> 00:01:47.369
同样，我们可以有一个组件

00:01:45.240 --> 00:01:49.859
发布消息需要一些东西

00:01:47.369 --> 00:01:51.390
一条消息或生成一条消息，并且

00:01:49.859 --> 00:01:54.929
然后将其写到出站

00:01:51.390 --> 00:01:56.130
适配器以这种方式进入消息

00:01:54.929 --> 00:01:57.929
通道，然后在另一侧

00:01:56.130 --> 00:02:00.090
我们有一个监听器，一个出站适配器

00:01:57.929 --> 00:02:01.679
转换来自Spring的消息

00:02:00.090 --> 00:02:03.119
框架化成可以

00:02:01.679 --> 00:02:05.609
用在外面的世界也许

00:02:03.119 --> 00:02:09.330
翻译Spring Framework消息

00:02:05.609 --> 00:02:11.820
到Twitter消息或

00:02:09.330 --> 00:02:13.170
 FTP服务器或任何写号码

00:02:11.820 --> 00:02:15.990
您可以与我们交流的事情

00:02:13.170 --> 00:02:17.790
这些适配器无数，所以 Spring 

00:02:15.990 --> 00:02:20.340
否定是非常好的基础

00:02:17.790 --> 00:02:22.380
用于基于消息的集成权

00:02:20.340 --> 00:02:24.750
这是最持久的方式

00:02:22.380 --> 00:02:27.950
整合服务，尤其是那些

00:02:24.750 --> 00:02:30.210
由网络分区分隔

00:02:27.950 --> 00:02:31.800
消息传递有很多好处

00:02:30.210 --> 00:02:34.050
暂时解耦

00:02:31.800 --> 00:02:35.640
就是说两个

00:02:34.050 --> 00:02:37.440
生产者和消费者还活着， 

00:02:35.640 --> 00:02:39.840
醒着并且能够同时回应

00:02:37.440 --> 00:02:41.760
我可以在一条消息中写一条消息的时间

00:02:39.840 --> 00:02:43.650
经纪人，只要该经纪人有

00:02:41.760 --> 00:02:47.010
确认消息并存储

00:02:43.650 --> 00:02:48.720
持久地，消费者才能走过来

00:02:47.010 --> 00:02:50.340
以后再追溯李

00:02:48.720 --> 00:02:51.840
使用消息，这是一个

00:02:50.340 --> 00:02:53.490
消息传递的好处

00:02:51.840 --> 00:02:55.950
我不在乎位置分离

00:02:53.490 --> 00:02:59.430
作为消息的产生者或消费者

00:02:55.950 --> 00:03:01.170
消息在何处结束或在何处

00:02:59.430 --> 00:03:02.850
起源于我只是在乎

00:03:01.170 --> 00:03:04.800
那位经纪人在哪里，所以我可以

00:03:02.850 --> 00:03:06.330
我想要许多不同的客户， 

00:03:04.800 --> 00:03:07.590
他们可以住在任何地方

00:03:06.330 --> 00:03:09.480
他们想要正确，他们不必进入

00:03:07.590 --> 00:03:10.590
特定的IP或位置或其他任何内容

00:03:09.480 --> 00:03:12.540
否则我只需要担心

00:03:10.590 --> 00:03:14.940
找到那个经纪人，实际上

00:03:12.540 --> 00:03:16.470
经纪人可以扩大规模，这样我们就可以

00:03:14.940 --> 00:03:18.210
该经纪人的实例数量与

00:03:16.470 --> 00:03:20.220
我们需要并水平缩放它

00:03:18.210 --> 00:03:23.250
所以说我要用很容易

00:03:20.220 --> 00:03:26.430
多播，我将使用环

00:03:23.250 --> 00:03:28.980
找到经纪人，然后与之交谈

00:03:26.430 --> 00:03:31.640
通过在消息队列方面进行工作

00:03:28.980 --> 00:03:33.960
我们被迫将我们的商品商品化

00:03:31.640 --> 00:03:36.930
我们应该强制进行的互动

00:03:33.960 --> 00:03:39.120
使用某种商品协议或

00:03:36.930 --> 00:03:40.800
有效载荷而不是互相交谈

00:03:39.120 --> 00:03:43.590
对，所以一个系统都没关系

00:03:40.800 --> 00:03:47.130
会说您知道Java，然后会讲

00:03:43.590 --> 00:03:48.600
网络然后说一个C 

00:03:47.130 --> 00:03:49.920
他们都可以说话，只要他们可以

00:03:48.600 --> 00:03:52.230
与该消息经纪人交谈，所以我们已经

00:03:49.920 --> 00:03:54.330
现在也扩大了我们的

00:03:52.230 --> 00:03:56.130
我们与其他不同种类的整合

00:03:54.330 --> 00:03:58.770
例如，这是不同的客户

00:03:56.130 --> 00:04:00.420
比使用RPC或

00:03:58.770 --> 00:04:02.610
类似的东西就是技术

00:04:00.420 --> 00:04:04.470
具体的，所以我们可以从中获得很多好处

00:04:02.610 --> 00:04:07.080
使用我们无法获得的消息

00:04:04.470 --> 00:04:08.670
同步RPC交互类型

00:04:07.080 --> 00:04:12.300
像你这样的

00:04:08.670 --> 00:04:14.040
例如EJB权利，因此消息传递是

00:04:12.300 --> 00:04:15.510
这不是一个新主意，但恰好是

00:04:14.040 --> 00:04:17.040
非常适合我们正在尝试的内容

00:04:15.510 --> 00:04:19.410
在微服务世界里做什么

00:04:17.040 --> 00:04:21.530
一切真的只是分布式的

00:04:19.410 --> 00:04:25.080
系统不同的组件和

00:04:21.530 --> 00:04:27.540
消息传递特别允许它允许

00:04:25.080 --> 00:04:30.570
我们来谈谈遗留系统

00:04:27.540 --> 00:04:32.280
可能讲的不一样

00:04:30.570 --> 00:04:34.830
语言是我们要尝试的一种

00:04:32.280 --> 00:04:37.200
这么说整合 Spring Integration 

00:04:34.830 --> 00:04:39.690
特别适合那个，但是

00:04:37.200 --> 00:04:42.000
当我们试图建立现代微型

00:04:39.690 --> 00:04:44.220
我们不尝试整合的服务

00:04:42.000 --> 00:04:45.720
我们正在构建的旧系统

00:04:44.220 --> 00:04:50.010
系统在

00:04:45.720 --> 00:04:54.780
在2016年或以后，这些要素

00:04:50.010 --> 00:04:56.880
可能将能够在

00:04:54.780 --> 00:04:58.710
使用JSON或XML或

00:04:56.880 --> 00:05:02.280
那里有点现代

00:04:58.710 --> 00:05:04.500
他们可能会支持访问

00:05:02.280 --> 00:05:06.720
到现代经纪人映射现代信息

00:05:04.500 --> 00:05:09.150
排队正确，所以我们可以理所当然

00:05:06.720 --> 00:05:11.190
我们的mut我们基于消息的微

00:05:09.150 --> 00:05:14.160
今天的服务将可以使用

00:05:11.190 --> 00:05:16.350
例如RabbitMQ或Apache Kafka或

00:05:14.160 --> 00:05:19.140
无论如何，在这种情况下，我们不会

00:05:16.350 --> 00:05:20.760
真的需要充分的灵活性

00:05:19.140 --> 00:05:22.620
 Spring 的创新使我们很高兴

00:05:20.760 --> 00:05:24.480
能够与任何旧系统通话

00:05:22.620 --> 00:05:26.730
太阳，并能够与之对话

00:05:24.480 --> 00:05:28.380
讯息条款，但那额外

00:05:26.730 --> 00:05:30.630
灵活性是以拥有为代价的

00:05:28.380 --> 00:05:32.640
配置和指定种类

00:05:30.630 --> 00:05:33.960
适配器再次很好这很好

00:05:32.640 --> 00:05:35.790
我们有那些适配器很好

00:05:33.960 --> 00:05:38.640
我们有这些组件是

00:05:35.790 --> 00:05:40.350
在蜡笔盒中，如果您愿意

00:05:38.640 --> 00:05:43.740
你那种人知道装满了

00:05:40.350 --> 00:05:45.690
颜色我们有那些选择，但是如果我们

00:05:43.740 --> 00:05:47.160
只是要使用rabbitmq，或者

00:05:45.690 --> 00:05:49.020
我们将使用Apache Kafka 

00:05:47.160 --> 00:05:51.950
然后必须为

00:05:49.020 --> 00:05:54.660
您知道的每一个新通讯

00:05:51.950 --> 00:05:56.450
中继每个新的互动

00:05:54.660 --> 00:05:59.400
组件之间可能会变得乏味

00:05:56.450 --> 00:06:01.350
我想要的是工作的灵活性

00:05:59.400 --> 00:06:03.810
就我想要的消息而言

00:06:01.350 --> 00:06:05.340
工作的灵活性

00:06:03.810 --> 00:06:06.660
消息队列并加以利用

00:06:05.340 --> 00:06:09.060
所有这些好处，但我不想

00:06:06.660 --> 00:06:11.660
必须写太多的代码以至于我最终

00:06:09.060 --> 00:06:15.480
遗憾的决定使用

00:06:11.660 --> 00:06:16.500
消息传递正确，所以如果我们愿意

00:06:15.480 --> 00:06:18.830
认为我们将要使用

00:06:16.500 --> 00:06:21.900
一些现代的商品

00:06:18.830 --> 00:06:23.520
 Apache Kafka RabbitMQ或其他任何东西

00:06:21.900 --> 00:06:25.410
我们可以找到一个活页夹

00:06:23.520 --> 00:06:28.380
然后我们可以使用所谓的Spring 

00:06:25.410 --> 00:06:30.360
云流Spring 云流生成

00:06:28.380 --> 00:06:34.770
在 Spring Integration 的基础上， 

00:06:30.360 --> 00:06:36.030
它具有与a相同的思想

00:06:34.770 --> 00:06:38.700
消息通过的消息通道

00:06:36.030 --> 00:06:40.440
通过了，但它使他们使

00:06:38.700 --> 00:06:42.900
配置和约定问题

00:06:40.440 --> 00:06:44.340
这些组件的接线

00:06:42.900 --> 00:06:46.590
让我们继续构建一个简单的

00:06:44.340 --> 00:06:48.990
生产者在这里，好吧，我们说生产者

00:06:46.590 --> 00:06:51.180
生产者将是一个网络

00:06:48.990 --> 00:06:52.560
应用程序，所以我们有一个休息点

00:06:51.180 --> 00:06:54.300
我们将在其中发送一些数据

00:06:52.560 --> 00:06:55.440
将端点休息到另一个服务，以便

00:06:54.300 --> 00:06:57.390
我们将使用 Spring Cloud Stream 

00:06:55.440 --> 00:06:58.860
我们将使用随机提示流处理

00:06:57.390 --> 00:07:01.259
在 spring boot 

00:06:58.860 --> 00:07:02.789
我们将使用执行器，因为

00:07:01.259 --> 00:07:04.949
很高兴能够可视化，我们可以

00:07:02.789 --> 00:07:06.599
也可以使用整合

00:07:04.949 --> 00:07:08.879
不需要整合支持

00:07:06.599 --> 00:07:11.129
这里是因为 Spring 的云流和

00:07:08.879 --> 00:07:13.110
洒流RabbitMQ带来了

00:07:11.129 --> 00:07:14.280
我们要做的最小位

00:07:13.110 --> 00:07:16.259
消息传递，但是拥有

00:07:14.280 --> 00:07:17.759
如果我们将集成组件设置在那里

00:07:16.259 --> 00:07:20.340
想要实际上我们真的不需要它

00:07:17.759 --> 00:07:23.340
对于生产者，我们可以做到吗

00:07:20.340 --> 00:07:24.900
没有那我们可以得到很多

00:07:23.340 --> 00:07:27.000
说那是我们的制片人，然后让我们

00:07:24.900 --> 00:07:29.610
产生消费者的东西会

00:07:27.000 --> 00:07:31.590
听消息，然后你

00:07:29.610 --> 00:07:33.659
知道接受数据然后做

00:07:31.590 --> 00:07:37.860
和他们在一起，所以我们用h2 

00:07:33.659 --> 00:07:42.090
 JP a将删除我们的网络支持

00:07:37.860 --> 00:07:43.919
我真的不需要了，我

00:07:42.090 --> 00:07:45.060
认为那会做到的，哦，我们可以

00:07:43.919 --> 00:07:47.729
为此使用集成

00:07:45.060 --> 00:07:49.469
集成使用喷雾符号

00:07:47.729 --> 00:07:50.879
组件模型以响应

00:07:49.469 --> 00:07:54.090
传入消息好，所以有

00:07:50.879 --> 00:07:55.830
现在让我们建立一个简单的制作人

00:07:54.090 --> 00:07:59.460
现在我的机器上有一个

00:07:55.830 --> 00:08:02.039
疯狂的MQ已经正常运行，所以我已经

00:07:59.460 --> 00:08:03.509
我们交谈时在我的机器上安装了RabbitMQ 

00:08:02.039 --> 00:08:06.330
它在后台运行

00:08:03.509 --> 00:08:09.210
在另一个我们可以得到的节点上运行

00:08:06.330 --> 00:08:11.310
到，而我们要做的就是

00:08:09.210 --> 00:08:12.629
设置产生一个

00:08:11.310 --> 00:08:13.919
每当有人叫休息的消息

00:08:12.629 --> 00:08:16.289
端点，然后我们要写

00:08:13.919 --> 00:08:19.229
消息发送到REM提示，然后接收

00:08:16.289 --> 00:08:20.729
全部交付给我们的消费者

00:08:19.229 --> 00:08:22.710
 Spring 的云流再次，如果你

00:08:20.729 --> 00:08:25.199
如果你还没有看到 Spring 的消极情绪

00:08:22.710 --> 00:08:27.150
视频，这将对

00:08:25.199 --> 00:08:28.589
首先了解那里发生了什么

00:08:27.150 --> 00:08:29.939
在我们深入杂草之前

00:08:28.589 --> 00:08:31.199
这个你不需要知道的

00:08:29.939 --> 00:08:33.240
喷洒创新，但很高兴知道

00:08:31.199 --> 00:08:34.919
关于那种全能

00:08:33.240 --> 00:08:36.839
我们正在做的事情

00:08:34.919 --> 00:08:39.510
因为您可以随时下拉

00:08:36.839 --> 00:08:41.729
变成Spring 符号，所以我们开始

00:08:39.510 --> 00:08:42.899
我们有一个应用程序，我们要去

00:08:41.729 --> 00:08:44.820
与另一服务交谈

00:08:42.899 --> 00:08:46.170
在这种情况下，您所知道的服务就是

00:08:44.820 --> 00:08:47.130
称其为消费者，因为它

00:08:46.170 --> 00:08:49.820
没有特别的

00:08:47.130 --> 00:08:52.589
有趣的面额我不是

00:08:49.820 --> 00:08:54.540
建立一个特别合理的

00:08:52.589 --> 00:08:56.640
这里的示例我只是设置一个基本的

00:08:54.540 --> 00:08:59.370
 pub / sub或生产者-消费者类型的

00:08:56.640 --> 00:09:01.290
交流，以便我们提供其他服务

00:08:59.370 --> 00:09:02.820
我们想和那个服务谈谈

00:09:01.290 --> 00:09:04.860
需要有一个我们可以进入的渠道

00:09:02.820 --> 00:09:06.980
发送消息，让我们先构建

00:09:04.860 --> 00:09:09.000
一个简单的手腕控制器

00:09:06.980 --> 00:09:12.860
好吧，我们将建立其余的控制器， 

00:09:09.000 --> 00:09:17.910
现在，当有人去

00:09:12.860 --> 00:09:19.920
得到映射，我们要说发送

00:09:17.910 --> 00:09:21.300
消息实际上我想我们可以做到

00:09:19.920 --> 00:09:23.340
贴图如何映射，让我们

00:09:21.300 --> 00:09:26.220
只是做一个贴图，我们将

00:09:23.340 --> 00:09:31.140
现在在/等接受消息

00:09:26.220 --> 00:09:35.790
 public public void在这里发布我们

00:09:31.140 --> 00:09:41.280
发布，我们要去

00:09:35.790 --> 00:09:43.800
 Expect是类型映射的JSON结构

00:09:41.280 --> 00:09:49.980
好的，所以我们要发送一个

00:09:43.800 --> 00:09:51.120
 JSON主体在这里，我们要做的是

00:09:49.980 --> 00:09:53.990
我们想在任何时候写该信息

00:09:51.120 --> 00:09:56.430
有人打电话给正斜线

00:09:53.990 --> 00:09:58.440
你知道打招呼就打招呼吧

00:09:56.430 --> 00:10:01.440
我们将在其中传递参数

00:09:58.440 --> 00:10:06.830
路径变量那里叫名字所以

00:10:01.440 --> 00:10:08.820
每当有人发送消息

00:10:06.830 --> 00:10:10.230
更好的是我们会做到的

00:10:08.820 --> 00:10:12.570
只需明确发送一条消息

00:10:10.230 --> 00:10:13.890
很简单，我们不必推理或

00:10:12.570 --> 00:10:15.690
考虑得太对了，所以

00:10:13.890 --> 00:10:18.660
每当有人发送

00:10:15.690 --> 00:10:19.800
有人发布到此端点

00:10:18.660 --> 00:10:23.880
要发送消息给某人

00:10:19.800 --> 00:10:28.290
对，我们要说问候等于

00:10:23.880 --> 00:10:29.340
你好，名字好，现在我们要

00:10:28.290 --> 00:10:31.200
将该消息发布到下游

00:10:29.340 --> 00:10:32.610
服务，如果我可以休息的话

00:10:31.200 --> 00:10:35.130
服务，如果下游服务手册

00:10:32.610 --> 00:10:36.540
休息我可以在这种情况下使用休息，但是我

00:10:35.130 --> 00:10:38.820
可以使用其余模板，然后制作

00:10:36.540 --> 00:10:40.380
如果需要，可以致电该服务，但

00:10:38.820 --> 00:10:41.610
我不想真的接受

00:10:40.380 --> 00:10:43.680
理所当然的，我不想理所当然

00:10:41.610 --> 00:10:45.600
该服务在所有时间都可用

00:10:43.680 --> 00:10:46.920
时间可能在

00:10:45.600 --> 00:10:48.090
这次，如果不是

00:10:46.920 --> 00:10:49.410
有空的话我就打电话给

00:10:48.090 --> 00:10:50.970
我不打算去的服务

00:10:49.410 --> 00:10:53.100
最终将State放到这里

00:10:50.970 --> 00:10:54.810
对，我需要保证这些数据

00:10:53.100 --> 00:10:57.180
最终在任何时候交付

00:10:54.810 --> 00:10:58.620
可能，所以当我要建立你

00:10:57.180 --> 00:11:00.330
知道我们需要的某种认知系统

00:10:58.620 --> 00:11:02.370
确保这些事情能够

00:11:00.330 --> 00:11:03.840
即使面对拓扑也是正确的事情

00:11:02.370 --> 00:11:06.240
变化和失败，在这种情况下

00:11:03.840 --> 00:11:08.220
消息传递更合适，所以我们要

00:11:06.240 --> 00:11:10.370
如我所说，使用 Spring Cloud Stream 

00:11:08.220 --> 00:11:12.810
在我们有 Spring 的云流之前

00:11:10.370 --> 00:11:14.250
这里的课程路径上有RabbitMQ 

00:11:12.810 --> 00:11:16.620
是我们可以使用的其他粘合剂

00:11:14.250 --> 00:11:18.120
当然，但是我们有随机的队列

00:11:16.620 --> 00:11:21.270
我的机器工作正常，所以我们将使用

00:11:18.120 --> 00:11:23.970
为了使这项工作我

00:11:21.270 --> 00:11:25.440
需要找到一个与此相关的连接

00:11:23.970 --> 00:11:26.910
其他服务

00:11:25.440 --> 00:11:28.410
所以我们声明式地这样做

00:11:26.910 --> 00:11:31.260
使用界面，所以我要打电话

00:11:28.410 --> 00:11:32.940
生产者渠道接口和

00:11:31.260 --> 00:11:35.700
这个名字是完全和完全的

00:11:32.940 --> 00:11:38.130
任意的，我们需要定义

00:11:35.700 --> 00:11:39.360
这是我们的消息渠道

00:11:38.130 --> 00:11:41.880
在这种情况下想交流

00:11:39.360 --> 00:11:43.770
我只有一个频道，名字

00:11:41.880 --> 00:11:45.300
在这种情况下，因为我

00:11:43.770 --> 00:11:48.110
懒惰，我真的没有更多

00:11:45.300 --> 00:11:49.830
想象中的名字是消费者，即

00:11:48.110 --> 00:11:52.620
我们将要发送的服务

00:11:49.830 --> 00:11:54.240
信息是我们当地的逻辑

00:11:52.620 --> 00:11:56.370
观点，这与无关

00:11:54.240 --> 00:11:59.070
经纪人本身的任何东西都是

00:11:56.370 --> 00:12:00.870
完全是我们对

00:11:59.070 --> 00:12:02.070
下游消息传递微服务我们

00:12:00.870 --> 00:12:04.560
现在不在乎rabbim队列

00:12:02.070 --> 00:12:06.720
我们真的不在乎我们

00:12:04.560 --> 00:12:08.520
只是在乎我们在做什么

00:12:06.720 --> 00:12:10.560
现在的代码，这是一个频道

00:12:08.520 --> 00:12:13.200
可以发送信息，所以我要去

00:12:10.560 --> 00:12:14.760
现在用广告输出对此进行注释

00:12:13.200 --> 00:12:16.980
在这里可能有多个定义

00:12:14.760 --> 00:12:18.510
对，我们在微服务系统中

00:12:16.980 --> 00:12:21.330
可能有不同的服务

00:12:18.510 --> 00:12:23.370
某种设置和服务于

00:12:21.330 --> 00:12:24.990
域的不同部分

00:12:23.370 --> 00:12:26.910
正确的业务逻辑，因此您可能

00:12:24.990 --> 00:12:28.230
有一个你知道的渠道

00:12:26.910 --> 00:12:29.400
客户服务和另一个

00:12:28.230 --> 00:12:30.810
订购服务，另一项用于

00:12:29.400 --> 00:12:33.000
履行服务，另一项用于

00:12:30.810 --> 00:12:35.190
无论正确的不同渠道

00:12:33.000 --> 00:12:36.480
不同的下游消息传递服务

00:12:35.190 --> 00:12:38.600
在这种情况下，我们只有一个

00:12:36.480 --> 00:12:41.280
我们将其称为消费者，因此

00:12:38.600 --> 00:12:43.890
现在可以，以便

00:12:41.280 --> 00:12:46.730
激活我们说的 Spring Cloud Stream 

00:12:43.890 --> 00:12:48.950
启用绑定，我们对此进行介绍

00:12:46.730 --> 00:12:53.700
我们刚刚定义的接口

00:12:48.950 --> 00:12:56.400
创建了这个光束，现在这个生产者

00:12:53.700 --> 00:13:01.710
通道的东西可以注射

00:12:56.400 --> 00:13:02.700
注入生产者的渠道和使用

00:13:01.710 --> 00:13:03.540
正确，所以我要创建一个

00:13:02.700 --> 00:13:06.120
在这里的构造函数，我将创建一个

00:13:03.540 --> 00:13:11.190
构造函数，我将注入

00:13:06.120 --> 00:13:13.140
制作人频道在这里，请记住我

00:13:11.190 --> 00:13:15.660
使用Spring Framework 4.3，因为我

00:13:13.140 --> 00:13:17.400
使用 spring boot 1.4和收缩4.3我

00:13:15.660 --> 00:13:18.930
不需要有线注释中的广告

00:13:17.400 --> 00:13:20.970
好吧，我会把它留在这里

00:13:18.930 --> 00:13:21.990
试图记住这样做和所有

00:13:20.970 --> 00:13:24.480
我要做的就是我要存储

00:13:21.990 --> 00:13:26.220
消息通道本身正确，我不知道

00:13:24.480 --> 00:13:28.980
关心中间接口

00:13:26.220 --> 00:13:30.210
但我很高兴知道我能得到

00:13:28.980 --> 00:13:32.430
如果需要的话可以访问它，所以我可以说

00:13:30.210 --> 00:13:36.300
荷兰消费者等于渠道

00:13:32.430 --> 00:13:39.420
输出或那个消费者

00:13:36.300 --> 00:13:40.620
现在我可以发送一条消息，所以这是

00:13:39.420 --> 00:13:42.810
将成为Spring Framework的信息

00:13:40.620 --> 00:13:44.310
这是相同类型的消息

00:13:42.810 --> 00:13:46.080
使用Spring Framework时使用的

00:13:44.310 --> 00:13:48.360
支持WebSockets- 

00:13:46.080 --> 00:13:50.070
这就是您所知道的消息对象， 

00:13:48.360 --> 00:13:53.160
消息生成器以及所有这些

00:13:50.070 --> 00:13:54.930
消息通道，所有歌剧都来了

00:13:53.160 --> 00:13:57.720
从Spring集成和Spring 

00:13:54.930 --> 00:13:59.340
它的框架已合并到

00:13:57.720 --> 00:14:00.270
框架的正确权利，现在已经成为一部分

00:13:59.340 --> 00:14:03.240
 Spring Framework的诞生

00:14:00.270 --> 00:14:04.560
超过一年，所以如果你有

00:14:03.240 --> 00:14:08.220
Spring 集成和Spring 框架

00:14:04.560 --> 00:14:12.630
紧扣并喜欢Spring Framework 

00:14:08.220 --> 00:14:14.790
这些类型的版本好吧，所以

00:14:12.630 --> 00:14:15.930
有效负载和我们的消息生成器

00:14:14.790 --> 00:14:17.760
有效载荷当然将是

00:14:15.930 --> 00:14:20.220
弦，那里没什么好看的

00:14:17.760 --> 00:14:21.810
然后要正确地建立它，所以你

00:14:20.220 --> 00:14:24.240
知道只是建立一个消息，这是

00:14:21.810 --> 00:14:26.940
一个建设者，所以我可以让你知道

00:14:24.240 --> 00:14:28.620
例如标题，我可以添加错误和

00:14:26.940 --> 00:14:30.270
所以我可以添加一个错误通道，但是

00:14:28.620 --> 00:14:33.120
在这种情况下，我只想让您知道

00:14:30.270 --> 00:14:37.070
尽快描述消息

00:14:33.120 --> 00:14:41.340
可能，因此该点消费者点发送

00:14:37.070 --> 00:14:44.240
消息好了，现在我们写了这个

00:14:41.340 --> 00:14:47.400
就我们而言，整个应用程序

00:14:44.240 --> 00:14:48.390
逻辑用例

00:14:47.400 --> 00:14:49.950
我们正在尝试做我们正在尝试发送

00:14:48.390 --> 00:14:52.230
一条消息发送到其他端点，然后

00:14:49.950 --> 00:14:54.780
发送给我们的消费者服务

00:14:52.230 --> 00:14:56.520
到目前为止尚未定义或制作

00:14:54.780 --> 00:14:59.640
具体是什么意思

00:14:56.520 --> 00:15:02.430
消费者服务要做到这一点，我们需要

00:14:59.640 --> 00:15:07.140
配置我们需要配置我们的

00:15:02.430 --> 00:15:08.550
申请交谈随机写

00:15:07.140 --> 00:15:11.190
我们使用约定这样做

00:15:08.550 --> 00:15:15.420
记得我们有 Spring 的云流

00:15:11.190 --> 00:15:17.100
在类路径和自动上的rabbitmq 

00:15:15.420 --> 00:15:19.080
配置spring boot auto 

00:15:17.100 --> 00:15:21.540
 RabbitMQ的配置已经

00:15:19.080 --> 00:15:23.610
可传递地添加到类路径中，因此

00:15:21.540 --> 00:15:25.110
传递性地我们将狂犬病

00:15:23.610 --> 00:15:27.900
 mq连接工厂，我可以

00:15:25.110 --> 00:15:29.610
指定您知道详细信息

00:15:27.900 --> 00:15:30.960
那疯狂的mq连接工厂

00:15:29.610 --> 00:15:32.970
使用任何众所周知的属性

00:15:30.960 --> 00:15:35.010
 Spring 的一切，那个rabbitmq这样的 Spring 

00:15:32.970 --> 00:15:36.750
 Reb mq在地址和主机上

00:15:35.010 --> 00:15:38.280
以及所有的端口和密码

00:15:36.750 --> 00:15:40.290
这东西，但我们拥有的

00:15:38.280 --> 00:15:41.580
默认权，我们拥有的

00:15:40.290 --> 00:15:44.910
默认情况下出现随机队列

00:15:41.580 --> 00:15:48.840
它连接到 localhost 等等

00:15:44.910 --> 00:15:51.500
这样就可以了，所以

00:15:48.840 --> 00:15:51.500
这是

00:15:51.650 --> 00:15:56.640
好吧，它将连接到57 56 72 

00:15:54.990 --> 00:15:58.380
它已经在那里要连接

00:15:56.640 --> 00:16:00.090
到 localhost ，您可以在这里看到

00:15:58.380 --> 00:16:01.380
就足够了

00:16:00.090 --> 00:16:02.940
在我的本地计算机上运行，​​但保持在

00:16:01.380 --> 00:16:05.310
介意您应该并且可以超越

00:16:02.940 --> 00:16:06.780
那些当你需要我所需要的

00:16:05.310 --> 00:16:09.830
我需要定义绑定吗

00:16:06.780 --> 00:16:15.140
虽然所以我说春耕

00:16:09.830 --> 00:16:18.300
绑定点消费者到目的地

00:16:15.140 --> 00:16:23.160
等于消费者，这将

00:16:18.300 --> 00:16:25.110
对应于约定的集合点

00:16:23.160 --> 00:16:27.810
指向rev MQ代理，因此请记住

00:16:25.110 --> 00:16:29.430
在RabbitMQ RabbitMQ是一个有点

00:16:27.810 --> 00:16:32.640
例如与JMS在

00:16:29.430 --> 00:16:37.620
 JMS您有一个豪华的JMS目的地

00:16:32.640 --> 00:16:40.440
目的地是逻辑地址，如果

00:16:37.620 --> 00:16:42.060
您将在两个经纪人之间

00:16:40.440 --> 00:16:44.040
生产者和消费者需要

00:16:42.060 --> 00:16:45.360
在随机队列中同意，有一点

00:16:44.040 --> 00:16:47.250
还有一些额外的间接

00:16:45.360 --> 00:16:49.440
在拉比德被称为交易所

00:16:47.250 --> 00:16:52.410
 mq，如果您将消息发送到

00:16:49.440 --> 00:16:54.210
交换交换有

00:16:52.410 --> 00:16:56.400
然后决定如何路由的能力

00:16:54.210 --> 00:16:58.260
消息发送到适当的队列，以便

00:16:56.400 --> 00:16:59.790
消费者连接到队列

00:16:58.260 --> 00:17:01.950
生产者连接到交易所， 

00:16:59.790 --> 00:17:05.310
交换之间的交接

00:17:01.950 --> 00:17:06.900
并且队列不是不是静态的，它可以

00:17:05.310 --> 00:17:09.240
以后更改吧，您可以更改它

00:17:06.900 --> 00:17:10.830
经纪人本身因此增加了

00:17:09.240 --> 00:17:12.360
能够进行额外的路由选择

00:17:10.830 --> 00:17:14.040
事实上，您最方便的事情之一

00:17:12.360 --> 00:17:16.380
可以做到实际上有Reb mq 

00:17:14.040 --> 00:17:18.120
将消息从交易所写入

00:17:16.380 --> 00:17:20.310
然后将另一个队列路由到

00:17:18.120 --> 00:17:21.930
另一个队列等等，直到永远

00:17:20.310 --> 00:17:24.000
交付给消费者，以便您可以添加

00:17:21.930 --> 00:17:26.580
额外的步骤，您可以添加一个额外的位

00:17:24.000 --> 00:17:28.350
间接和处理都在内部

00:17:26.580 --> 00:17:31.560
而不是在AMQP中排队

00:17:28.350 --> 00:17:33.570
协议，因此我们将其发送到

00:17:31.560 --> 00:17:36.660
习惯上称为消费者的交易所

00:17:33.570 --> 00:17:37.980
那会变成一个队列

00:17:36.660 --> 00:17:40.230
另一边，我们要告诉你

00:17:37.980 --> 00:17:41.790
给相同的名字，它将使用一个

00:17:40.230 --> 00:17:43.680
正确路由键，它将做

00:17:41.790 --> 00:17:46.260
路由键，以找出

00:17:43.680 --> 00:17:48.420
排队，它应该从右说话

00:17:46.260 --> 00:17:51.200
来自交易所，所以有

00:17:48.420 --> 00:17:55.590
让我们在端口上启动应用程序

00:17:51.200 --> 00:17:57.300
 8000也会有这个

00:17:55.590 --> 00:18:00.450
足够的权利，这将是我们的简单

00:17:57.300 --> 00:18:02.630
 rabbim队列生产者让我们开始

00:18:00.450 --> 00:18:02.630
上

00:18:13.440 --> 00:18:18.510
好的，那应该足够了

00:18:16.830 --> 00:18:20.790
现在让我们继续看一下

00:18:18.510 --> 00:18:21.870
消费者另一边

00:18:20.790 --> 00:18:23.700
对，我们必须继续并建立一个

00:18:21.870 --> 00:18:26.730
消费者将采取

00:18:23.700 --> 00:18:28.710
生产者传入的消息来自

00:18:26.730 --> 00:18:30.660
 RabbitMQ，然后将其打印出来

00:18:28.710 --> 00:18:33.450
我们只确认收到

00:18:30.660 --> 00:18:37.020
该消息正确，所以我们说消费者

00:18:33.450 --> 00:18:38.880
应用程序，在这种情况下，我们要

00:18:37.020 --> 00:18:43.550
在反向中做同样的事情

00:18:38.880 --> 00:18:47.190
会说界面消费者渠道

00:18:43.550 --> 00:18:50.130
我们将在输入中说这是

00:18:47.190 --> 00:18:52.680
相反的权利，这是一条信息

00:18:50.130 --> 00:18:54.870
会接受交货，这是一个渠道

00:18:52.680 --> 00:18:57.120
接受传入消息的传递并

00:18:54.870 --> 00:18:58.800
在这种情况下，频道名称为

00:18:57.120 --> 00:19:00.180
无论您想要什么，我们实际上都可以

00:18:58.800 --> 00:19:04.200
如果需要的话，称其为生产者

00:19:00.180 --> 00:19:06.240
因此，当消息进入时，我们将

00:19:04.200 --> 00:19:08.670
路由到这个频道，我们想要

00:19:06.240 --> 00:19:10.770
听那条消息，所以说

00:19:08.670 --> 00:19:15.720
在启用绑定时，我们要说的是

00:19:10.770 --> 00:19:18.210
消费者渠道课程，然后我们将

00:19:15.720 --> 00:19:22.260
定义一个Spring 集成集成

00:19:18.210 --> 00:19:23.760
正确流动，这是我的首选方式

00:19:22.260 --> 00:19:25.740
喜欢做很多我喜欢使用的

00:19:23.760 --> 00:19:27.120
 Spring 的否定，因为我有很多

00:19:25.740 --> 00:19:28.920
回到 Spring 回归，但

00:19:27.120 --> 00:19:30.750
就是这样，还有一个组件模型

00:19:28.920 --> 00:19:32.190
您可以使用解释代码流

00:19:30.750 --> 00:19:34.620
正确的，您可以使用组件模型

00:19:32.190 --> 00:19:39.930
被流媒体俱乐部以声明方式

00:19:34.620 --> 00:19:42.150
知道将线的方法调用到

00:19:39.930 --> 00:19:44.400
新消息的到来使集成

00:19:42.150 --> 00:19:46.260
从中流出点，我们将采取

00:19:44.400 --> 00:19:47.670
我们新不断的优势

00:19:46.260 --> 00:19:50.190
这样就建立了消费者渠道

00:19:47.670 --> 00:19:54.990
这就是我要说的C点

00:19:50.190 --> 00:19:56.130
输入抱歉的生产者句柄以及我们

00:19:54.990 --> 00:19:58.500
想做的就是我想知道的时候

00:19:56.130 --> 00:19:59.910
只是接受传入的有效载荷和

00:19:58.500 --> 00:20:01.800
有效载荷是字符串类型，所以我要去

00:19:59.910 --> 00:20:03.180
说那个课，然后我们

00:20:01.800 --> 00:20:06.600
必须提供一个lambda 

00:20:03.180 --> 00:20:07.860
接受标题和有效载荷

00:20:06.600 --> 00:20:09.360
那我们就用它做些什么

00:20:07.860 --> 00:20:12.090
我们现在要做的是

00:20:09.360 --> 00:20:14.340
只是要转不行，那我们要走了

00:20:12.090 --> 00:20:16.380
创建管道的流程

00:20:14.340 --> 00:20:18.510
在那里，现在我们可以现在重新访问

00:20:16.380 --> 00:20:20.040
我们知道东西有点联系

00:20:18.510 --> 00:20:23.730
在一起，所以我要做的就是

00:20:20.040 --> 00:20:26.530
即将记录传入的数据，这样

00:20:23.730 --> 00:20:30.429
我会用

00:20:26.530 --> 00:20:35.400
记录器在这里或类型，如果您看到

00:20:30.429 --> 00:20:37.270
您最近看过的影片越多

00:20:35.400 --> 00:20:39.760
您可以在其中使用的组件

00:20:37.270 --> 00:20:40.900
 Spring 的框架，使您的代码更多

00:20:39.760 --> 00:20:43.360
 Spring 意识到一件美好的事

00:20:40.900 --> 00:20:44.860
我们有一个注射点

00:20:43.360 --> 00:20:46.870
这是一个非常方便的对象

00:20:44.860 --> 00:20:49.750
在那里，让我们做的是

00:20:46.870 --> 00:20:57.299
这样定义记录器，所以注入

00:20:49.750 --> 00:21:05.140
指向IP，它将记录器变成点记录器

00:20:57.299 --> 00:21:07.840
 IP点获取声明的类型获取名称正确

00:21:05.140 --> 00:21:15.070
这样就可以了，现在我们可以注入

00:21:07.840 --> 00:21:21.580
记录器也在这里，我们可以

00:21:15.070 --> 00:21:24.429
说日志或点信息新消息有效负载

00:21:21.580 --> 00:21:25.750
好吧，我们还好，所以现在有我们

00:21:24.429 --> 00:21:27.130
消费者会吐出来的

00:21:25.750 --> 00:21:29.080
将要收听的消息是

00:21:27.130 --> 00:21:30.789
进入这个输入通道， 

00:21:29.080 --> 00:21:33.039
消息一到达我们

00:21:30.789 --> 00:21:35.140
要将其传递给此服务

00:21:33.039 --> 00:21:37.659
激活此句柄方法，然后

00:21:35.140 --> 00:21:40.059
处理方法将简单地打印

00:21:37.659 --> 00:21:41.039
出来的消息就可以了

00:21:40.059 --> 00:21:44.340
开始了

00:21:41.039 --> 00:21:44.340
旋转起来

00:21:55.750 --> 00:22:02.110
好的，这已经启动并运行我们的另一个

00:22:00.400 --> 00:22:08.289
 8000端口上的服务继续

00:22:02.110 --> 00:22:10.330
向它发送消息，我们说让我们

00:22:08.289 --> 00:22:11.530
看到我们想要整理一下东西，以便我们可以

00:22:10.330 --> 00:22:14.049
仍然在这里看到发生了什么

00:22:11.530 --> 00:22:19.110
控制台，我们要说curl减去D 

00:22:14.049 --> 00:22:21.909
这是要发布到 localhost 的方法

00:22:19.110 --> 00:22:23.830
 8004会议我已经忘记了什么

00:22:21.909 --> 00:22:26.980
东西的名字叫名字，所以

00:22:23.830 --> 00:22:32.669
问候世界好吧，所以我们应该看看

00:22:26.980 --> 00:22:32.669
一切都按计划进行你好世界好吗

00:22:36.909 --> 00:22:42.309
啊，这还没有完成，我们没有

00:22:39.519 --> 00:22:46.330
看到消息到达，因为我们

00:22:42.309 --> 00:22:47.320
没有指定我们没有指定的消费者

00:22:46.330 --> 00:22:48.369
看到它，我们没有，我们没有看到它

00:22:47.320 --> 00:22:50.229
到达是因为我们尚未指定

00:22:48.369 --> 00:22:53.789
消费相反

00:22:50.229 --> 00:22:58.169
如此配置， Spring Cloud Stream 

00:22:53.789 --> 00:23:01.119
绑定点消费者到目的地

00:22:58.169 --> 00:23:05.909
等于，我们在这里说什么

00:23:01.119 --> 00:23:08.259
商定的集合点等于

00:23:05.909 --> 00:23:09.999
好吧，这就是生产者平等

00:23:08.259 --> 00:23:12.429
消费者权益，因此我们将继续

00:23:09.999 --> 00:23:13.899
向该交易所发送消息并

00:23:12.429 --> 00:23:14.799
指出这可能是你知道什么

00:23:13.899 --> 00:23:16.179
实际上我们可以称之为

00:23:14.799 --> 00:23:17.590
问候，嘿，我们应该这样做，我们会

00:23:16.179 --> 00:23:19.359
称这两个生产者的问候

00:23:17.590 --> 00:23:20.499
那里的消费者不是真的

00:23:19.359 --> 00:23:22.899
没关系，那太好了

00:23:20.499 --> 00:23:25.690
商定的集合点

00:23:22.899 --> 00:23:27.700
 rebbe MQ经纪人，你不知道吗

00:23:25.690 --> 00:23:29.139
可以更改，如果我想要这是Java 

00:23:27.700 --> 00:23:31.269
这是消息通道

00:23:29.139 --> 00:23:32.830
我们在Java代码中创建了

00:23:31.269 --> 00:23:34.419
不能改变它必须匹配里面的东西

00:23:32.830 --> 00:23:35.799
 Java代码，但只要两者都

00:23:34.419 --> 00:23:37.269
生产者和消费者对此表示同意

00:23:35.799 --> 00:23:39.309
他们都在同一个话题

00:23:37.269 --> 00:23:42.999
 rabbitmq经纪人，然后事情会起作用

00:23:39.309 --> 00:23:44.950
很好，所以这是消费者， 

00:23:42.999 --> 00:23:49.119
这将正常工作，这将

00:23:44.950 --> 00:23:53.499
工作很好，你知道我们可以开始了

00:23:49.119 --> 00:23:56.200
应用程序再试一次，现在有

00:23:53.499 --> 00:24:00.369
正确的消息说你好世界的事情

00:23:56.200 --> 00:24:05.009
很好，但是会发生什么

00:24:00.369 --> 00:24:07.330
如果我们将端口设置为零，然后

00:24:05.009 --> 00:24:09.789
我们开始这个，开始一些

00:24:07.330 --> 00:24:10.960
不同的时间，好吧，我们要去

00:24:09.789 --> 00:24:12.879
开始几个不同的实例

00:24:10.960 --> 00:24:14.619
将仅禁用单个实例

00:24:12.879 --> 00:24:18.159
我要打的东西在这里套用

00:24:14.619 --> 00:24:19.809
好的，然后我将重新启动我的使用者

00:24:18.159 --> 00:24:22.239
创建使用者的另一个实例

00:24:19.809 --> 00:24:23.950
我也要让他们两个跑

00:24:22.239 --> 00:24:26.679
同时，这是五十

00:24:23.950 --> 00:24:28.929
一三七七这是另一个

00:24:26.679 --> 00:24:30.960
在港口运行良好，我不知道我们会

00:24:28.929 --> 00:24:30.960
看到

00:24:38.000 --> 00:24:42.620
所以五一四有一一和五一

00:24:41.120 --> 00:24:43.730
三七七所以我要去

00:24:42.620 --> 00:24:44.630
现在要做的就是我要发送相同的

00:24:43.730 --> 00:24:47.840
我要发送另一个消息

00:24:44.630 --> 00:24:49.160
给我的制片人的讯息

00:24:47.840 --> 00:24:51.020
然后发布消息，我们已经

00:24:49.160 --> 00:24:53.750
现在有两个消费者你怎么想

00:24:51.020 --> 00:24:55.610
将会在世界上发生你好世界

00:24:53.750 --> 00:24:58.220
一个港口和世界上的消费者

00:24:55.610 --> 00:24:59.720
再有一个不是的端口

00:24:58.220 --> 00:25:00.830
我认为我们大多数人都是

00:24:59.720 --> 00:25:03.200
可能是期望的

00:25:00.830 --> 00:25:05.630
我们已经将消息广播给两个

00:25:03.200 --> 00:25:07.700
不同的消费者，这也许很好

00:25:05.630 --> 00:25:12.170
很好，但是如果我要建立一个系统

00:25:07.700 --> 00:25:13.790
我想让您知道的地方

00:25:12.170 --> 00:25:15.830
消息传递给一层和一层

00:25:13.790 --> 00:25:17.000
只有一个消费者，那么这可能是

00:25:15.830 --> 00:25:19.370
不是我想要的，而不是

00:25:17.000 --> 00:25:21.830
通过增加更多消费者来实现负载平衡

00:25:19.370 --> 00:25:24.080
划分我复制的作品

00:25:21.830 --> 00:25:25.880
我已经广播了作品，那是

00:25:24.080 --> 00:25:31.870
那不是我想要的，所以我想要的

00:25:25.880 --> 00:25:34.910
在我的消费者中做的是一个定义组

00:25:31.870 --> 00:25:36.500
好吧，我可以随便叫这个

00:25:34.910 --> 00:25:39.620
这个名字在这里组名是

00:25:36.500 --> 00:25:41.390
完全任意，这是一个消费者

00:25:39.620 --> 00:25:43.460
组和 Spring Cloud Stream 

00:25:41.390 --> 00:25:45.410
说法是，如果我有一个

00:25:43.460 --> 00:25:47.420
或同一组中有更多消费者

00:25:45.410 --> 00:25:49.910
该组中的一个实例将获得任何

00:25:47.420 --> 00:25:52.430
一个给定的消息，因此它是专用于

00:25:49.910 --> 00:25:54.440
其中的成员

00:25:52.430 --> 00:25:56.870
组邮件将被传递

00:25:54.440 --> 00:25:58.100
专用于一个节点，所以我要

00:25:56.870 --> 00:26:00.170
称呼为问候组，我们

00:25:58.100 --> 00:26:02.780
要继续并重新启动此实例

00:26:00.170 --> 00:26:06.260
在这里，然后这个实例大声疾呼

00:26:02.780 --> 00:26:08.210
那里的一个人那里是这个

00:26:06.260 --> 00:26:09.620
我们将重新启动这个，所以现在我已经

00:26:08.210 --> 00:26:12.700
用这个新的重启了他们两个

00:26:09.620 --> 00:26:12.700
配置权

00:26:22.240 --> 00:26:29.470
现在两个事情都按计划进行了

00:26:25.570 --> 00:26:31.720
应该看到它是51469这是51 

00:26:29.470 --> 00:26:36.520
 472我们应该看到传递的消息

00:26:31.720 --> 00:26:37.750
我们只有一个消费者

00:26:36.520 --> 00:26:40.480
应该只在一个Canto上看到它

00:26:37.750 --> 00:26:41.860
节点，所以让我们再试一次，我们可以

00:26:40.480 --> 00:26:43.060
它没有送到这个

00:26:41.860 --> 00:26:45.280
希望能送到这个

00:26:43.060 --> 00:26:46.960
那里是世界，所以现在我们

00:26:45.280 --> 00:26:48.790
消费者群体已经完成了我们的预期

00:26:46.960 --> 00:26:50.230
看看我是否再打一个电话

00:26:48.790 --> 00:26:52.450
可能是我们的负荷反弹了

00:26:50.230 --> 00:26:54.010
第二个没错，所以我们

00:26:52.450 --> 00:26:55.810
现在有效地负载平衡工作

00:26:54.010 --> 00:26:57.430
这被称为偷工

00:26:55.810 --> 00:26:58.930
对，我们可以拥有尽可能多的消费者

00:26:57.430 --> 00:27:00.280
我们需要另一种方式

00:26:58.930 --> 00:27:03.250
这种模式的另一个名字叫做

00:27:00.280 --> 00:27:04.420
侵略性的消费者权利

00:27:03.250 --> 00:27:07.300
发生的事情是我们正在采取尽可能多的措施

00:27:04.420 --> 00:27:09.130
从队列中尽力而为，但如果我们

00:27:07.300 --> 00:27:10.570
有更多的消费者，我们能够

00:27:09.130 --> 00:27:12.070
划分我们处理这项工作的能力

00:27:10.570 --> 00:27:14.800
例如，这是理想的选择

00:27:12.070 --> 00:27:18.330
使用Cloud Foundry好吧，这是

00:27:14.800 --> 00:27:18.330
我们研究了如果有

00:27:18.480 --> 00:27:23.560
消费者的一个或多个实例

00:27:21.070 --> 00:27:25.750
如果我们为零会发生什么

00:27:23.560 --> 00:27:26.950
发生了，那么我们怎么知道你知道如何

00:27:25.750 --> 00:27:29.620
我们是否确保如果我们提供了

00:27:26.950 --> 00:27:31.240
消息是消息

00:27:29.620 --> 00:27:33.340
即使没有

00:27:31.240 --> 00:27:35.100
消费者默认情况下不是

00:27:33.340 --> 00:27:38.500
我们将拥有的行为

00:27:35.100 --> 00:27:41.830
如果我们有零个服务实例

00:27:38.500 --> 00:27:44.410
可用，那么该消息将坐下

00:27:41.830 --> 00:27:45.880
在经纪人处休眠，它仍然在那里

00:27:44.410 --> 00:27:48.280
它已被经纪人承认，但

00:27:45.880 --> 00:27:49.540
我们没有什么要收货的

00:27:48.280 --> 00:27:51.310
该消息的目的是为了

00:27:49.540 --> 00:27:54.940
所以我们现在要做的是

00:27:51.310 --> 00:27:57.880
我们的订阅持久权是这样

00:27:54.940 --> 00:28:00.990
我们要在这里带走， 

00:27:57.880 --> 00:28:05.860
要说生产者那耐用的子

00:28:00.990 --> 00:28:07.300
下巴脚本等于真的好吧，所以现在

00:28:05.860 --> 00:28:08.560
为此，我们具有三个属性

00:28:07.300 --> 00:28:10.360
我们刚刚制作的制作人频道

00:28:08.560 --> 00:28:12.460
在我们的定义中描述

00:28:10.360 --> 00:28:14.050
制片人是我现在要去的这个频道

00:28:12.460 --> 00:28:21.520
说订阅是持久的

00:28:14.050 --> 00:28:24.100
所以如果我们杀了这个然后杀了这个

00:28:21.520 --> 00:28:27.930
他们中的人走了，我在这里没有实例

00:28:24.100 --> 00:28:29.890
再见，我在这里没有实例

00:28:27.930 --> 00:28:32.860
现在我要再发送一条消息

00:28:29.890 --> 00:28:35.890
我会说你好世界持久世界吧

00:28:32.860 --> 00:28:37.000
我们现在应该看到

00:28:35.890 --> 00:28:41.560
启动，我要发送消息

00:28:37.000 --> 00:28:44.950
哦，糟糕，我们将发送邮件给我

00:28:41.560 --> 00:28:47.500
比如说你再次知道

00:28:44.950 --> 00:28:49.150
所以我们现在应该有两个消息

00:28:47.500 --> 00:28:51.400
已发送给经纪人但尚未

00:28:49.150 --> 00:28:52.900
确认尚未交付，所以我们

00:28:51.400 --> 00:28:55.720
将要启动一个这样的实例

00:28:52.900 --> 00:28:57.790
这个消费者，我们应该看到它复古

00:28:55.720 --> 00:29:00.190
积极消费具有

00:28:57.790 --> 00:29:08.170
已在以下位置交付给RabbitMQ 

00:29:00.190 --> 00:29:10.000
控制台在这里，你好耐用

00:29:08.170 --> 00:29:13.600
再次问好，所以它工作正常，我们已经

00:29:10.000 --> 00:29:16.390
我们已成功从发出了一条消息

00:29:13.600 --> 00:29:17.980
从生产者到生产者的消费者

00:29:16.390 --> 00:29:19.930
经纪人，然后到消费者，但

00:29:17.980 --> 00:29:20.740
我们也照顾了你

00:29:19.930 --> 00:29:22.150
我们已经研究了如何做

00:29:20.740 --> 00:29:23.740
发布/订阅以及

00:29:22.150 --> 00:29:25.570
点对点的消息传递和

00:29:23.740 --> 00:29:27.190
我们研究了如何构建系统

00:29:25.570 --> 00:29:28.930
面对

00:29:27.190 --> 00:29:30.820
毕竟服务中断和故障

00:29:28.930 --> 00:29:32.860
这是使用的最大好处之一

00:29:30.820 --> 00:29:34.720
消息代理是存储的能力

00:29:32.860 --> 00:29:36.790
然后转发那些消息， 

00:29:34.720 --> 00:29:38.680
让我们有能力接受然后采取

00:29:36.790 --> 00:29:39.880
停止服务并仍然保证

00:29:38.680 --> 00:29:41.380
一切最终都会得到处理

00:29:39.880 --> 00:29:44.350
对，我们无法撤下我们的

00:29:41.380 --> 00:29:45.460
消费者是否需要升级

00:29:44.350 --> 00:29:47.860
而且您知道部署新版本

00:29:45.460 --> 00:29:49.930
在不丢失数据的情况下

00:29:47.860 --> 00:29:51.880
最终一致，我们最终

00:29:49.930 --> 00:29:53.650
处理数据，世界将

00:29:51.880 --> 00:29:57.100
汇聚到一个众所周知的国家

00:29:53.650 --> 00:29:59.020
最终，这是一个简短的外观

00:29:57.100 --> 00:30:00.730
在 Spring 的云流现在 Spring 的云

00:29:59.020 --> 00:30:02.350
流构建冲压Spring 集成

00:30:00.730 --> 00:30:03.760
在后面的视频中，我们将看

00:30:02.350 --> 00:30:05.340
所谓的Spring Cloud Dataflow 

00:30:03.760 --> 00:30:09.280
这样就很简单了

00:30:05.340 --> 00:30:11.290
组成或排序的Koya图很多

00:30:09.280 --> 00:30:13.210
基于小型消息传递的微服务

00:30:11.290 --> 00:30:14.850
像这样支持流

00:30:13.210 --> 00:30:17.380
正确地处理

00:30:14.850 --> 00:30:21.070
通过以下方式使消息永久存在

00:30:17.380 --> 00:30:22.960
一系列基于消息的服务

00:30:21.070 --> 00:30:24.820
得出更复杂的结果

00:30:22.960 --> 00:30:26.790
例如管道和过滤器模型

00:30:24.820 --> 00:30:29.110
你就是，如果你已经

00:30:26.790 --> 00:30:31.030
在UNIX命令行shell中使用了bash 

00:30:29.110 --> 00:30:34.050
好，非常感谢您的收看

00:30:31.030 --> 00:30:34.050
下次见

00:30:40.000 --> 00:30:42.060
您

