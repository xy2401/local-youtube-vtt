WEBVTT
Kind: captions
Language: zh-Hans

00:00:25.000 --> 00:00:29.240
嗨，春季粉丝在本期中

00:00:27.860 --> 00:00:31.880
 Spring 的技巧，我们要看看

00:00:29.240 --> 00:00:33.680
我现在不怪Spring Shell项目

00:00:31.880 --> 00:00:35.630
如果你还没有听说的话

00:00:33.680 --> 00:00:37.520
好吧，这是一个相当

00:00:35.630 --> 00:00:40.220
雷达项目招标，那就是

00:00:37.520 --> 00:00:42.190
因为很大程度上最大的消费者是

00:00:40.220 --> 00:00:44.690
其他项目对Spring Shell

00:00:42.190 --> 00:00:46.970
源于spring roo a的代码库

00:00:44.690 --> 00:00:50.780
我们发起了十多个项目

00:00:46.970 --> 00:00:52.250
年前，它在那里为我们的CLI服务

00:00:50.780 --> 00:00:54.920
用例权，我们让他们建立了一个

00:00:52.250 --> 00:00:56.780
客户端您所使用的命令行客户端

00:00:54.920 --> 00:00:59.150
可以使用，它是交互式的， 

00:00:56.780 --> 00:01:01.820
该命令行是

00:00:59.150 --> 00:01:04.250
您与框架进行了互动

00:01:01.820 --> 00:01:06.470
在运行时，我们采用了该源

00:01:04.250 --> 00:01:08.750
源代码，它还可以生存

00:01:06.470 --> 00:01:12.320
这是一个已经在其他项目中使用的

00:01:08.750 --> 00:01:14.740
但最值得注意的是它经常抛光

00:01:12.320 --> 00:01:17.330
我们做了一些努力来支持

00:01:14.740 --> 00:01:20.600
我们的Spring XD用例

00:01:17.330 --> 00:01:23.150
当然现在是 Spring Cloud 数据流了

00:01:20.600 --> 00:01:27.260
原始源代码基于J线

00:01:23.150 --> 00:01:28.579
因此，您知道的基本控制台

00:01:27.260 --> 00:01:30.950
线支持所有这些东西

00:01:28.579 --> 00:01:32.540
由J线和Spring 支持

00:01:30.950 --> 00:01:36.079
 shell有点像

00:01:32.540 --> 00:01:38.299
最重要的是，它刚刚达到一个新的

00:01:36.079 --> 00:01:39.950
具有里程碑意义的是om2，所以

00:01:38.299 --> 00:01:42.469
有一个新版本的新版本

00:01:39.950 --> 00:01:43.759
它看起来非常有前途，其中之一

00:01:42.469 --> 00:01:45.200
此新版本的最大功能

00:01:43.759 --> 00:01:46.640
是基于 spring boot 的

00:01:45.200 --> 00:01:49.549
有一个完整的自动配置

00:01:46.640 --> 00:01:51.439
机制和框架等等

00:01:49.549 --> 00:01:54.229
让我们来看一下，我

00:01:51.439 --> 00:01:58.159
没有幻想，或者你知道错觉

00:01:54.229 --> 00:02:01.100
而不是人的市场

00:01:58.159 --> 00:02:03.020
建立基于外壳的应用程序

00:02:01.100 --> 00:02:04.159
不是说这将是下一个大

00:02:03.020 --> 00:02:06.350
你们都应该用光并做的事情

00:02:04.159 --> 00:02:08.179
但是如果您有某种后端

00:02:06.350 --> 00:02:10.670
用例或某种工具

00:02:08.179 --> 00:02:12.320
需要构建操作工具或

00:02:10.670 --> 00:02:14.750
只是某种仪表板而已

00:02:12.320 --> 00:02:17.390
确保可能存在用例

00:02:14.750 --> 00:02:18.950
为了它的产生和成为

00:02:17.390 --> 00:02:21.920
用外壳支撑着一个外壳

00:02:18.950 --> 00:02:24.350
基于用户界面而不是

00:02:21.920 --> 00:02:25.610
也许功能更全的网站

00:02:24.350 --> 00:02:28.760
需要的申请

00:02:25.610 --> 00:02:29.930
发展相当长的时间

00:02:28.760 --> 00:02:32.870
知道也许你只是想要

00:02:29.930 --> 00:02:34.670
您可以用来管理批处理

00:02:32.870 --> 00:02:36.020
例如工作，或者您想要一些东西

00:02:34.670 --> 00:02:37.790
你可以用来

00:02:36.020 --> 00:02:40.490
与您的后端互动

00:02:37.790 --> 00:02:42.560
 REST API可以提取任何数据

00:02:40.490 --> 00:02:43.640
用例时刻，您知道您可以

00:02:42.560 --> 00:02:45.380
很快得到一个可以工作的原型

00:02:43.640 --> 00:02:49.040
与外壳，而这需要一个

00:02:45.380 --> 00:02:50.750
相当多的时间

00:02:49.040 --> 00:02:53.870
获得相同的体验

00:02:50.750 --> 00:02:58.070
同一种互动互动

00:02:53.870 --> 00:02:58.730
与网络应用程序，你知道这一点

00:02:58.070 --> 00:03:00.200
不适合所有人

00:02:58.730 --> 00:03:01.970
要记住的一件事是

00:03:00.200 --> 00:03:04.760
是贝壳，所以这将是

00:03:01.970 --> 00:03:06.950
它只会利用

00:03:04.760 --> 00:03:08.930
在UNIX上更容易使用的功能

00:03:06.950 --> 00:03:10.580
或UNIX风格的操作系统

00:03:08.930 --> 00:03:11.780
说你仍然应该在Windows上工作

00:03:10.580 --> 00:03:14.590
我们当然知道它可以

00:03:11.780 --> 00:03:18.470
 Windows与cygwin和and等

00:03:14.590 --> 00:03:20.510
您知道UNIX风格的um模式

00:03:18.470 --> 00:03:22.430
 Windows的功能，所以我们不构建

00:03:20.510 --> 00:03:24.920
新的CRM，它将成为一个应用程序

00:03:22.430 --> 00:03:26.930
您可以用来与CRM对话的

00:03:24.920 --> 00:03:28.760
我当然没有血清

00:03:26.930 --> 00:03:30.080
您可以用来管理的应用

00:03:28.760 --> 00:03:32.660
客户数据，这只是一个非常

00:03:30.080 --> 00:03:35.570
我认为我们会选择无聊的领域

00:03:32.660 --> 00:03:38.150
所以我们称其为CRM Shell 

00:03:35.570 --> 00:03:40.760
我们将使用龙目岛支持， 

00:03:38.150 --> 00:03:44.150
 spring boot ，当你旋转时旋转得很好

00:03:40.760 --> 00:03:45.170
引导-现在有五个没有外壳

00:03:44.150 --> 00:03:47.120
复选框

00:03:45.170 --> 00:03:48.380
至少还没有，这有点

00:03:47.120 --> 00:03:50.120
简直让人不知所措，我希望看到

00:03:48.380 --> 00:03:52.790
变化，但我们选择的原因

00:03:50.120 --> 00:03:56.410
那个om5是因为我们想要

00:03:52.790 --> 00:03:59.030
里程碑，你知道快照

00:03:56.410 --> 00:04:01.459
仓库编辑器臂甚至正确建立

00:03:59.030 --> 00:04:04.220
所以通过选择m5我们已经得到了

00:04:01.459 --> 00:04:05.390
是免费的，而不是依靠

00:04:04.220 --> 00:04:08.959
假设我们会说话

00:04:05.390 --> 00:04:14.750
到Maven中央存储库

00:04:08.959 --> 00:04:21.070
因此，让我们打开构建，然后添加

00:04:14.750 --> 00:04:25.820
 Spring ，她将从那里开始，所以春季秀

00:04:21.070 --> 00:04:32.770
开始，也许没事或 Spring 

00:04:25.820 --> 00:04:37.730
框架，而不是云，但她会

00:04:32.770 --> 00:04:42.140
版本是1000点m2 

00:04:37.730 --> 00:04:45.650
如果可以的话，那么我们的新产品

00:04:42.140 --> 00:04:49.150
我说过，CRM Shell将进行管理

00:04:45.650 --> 00:04:51.040
 CRM中的数据，因此我们没有

00:04:49.150 --> 00:04:52.960
那种类型的人会

00:04:51.040 --> 00:04:55.930
可以管理那个人的东西

00:04:52.960 --> 00:04:57.480
我们不会真正使用我不

00:04:55.930 --> 00:04:59.260
有一个REST API，我没有实际的

00:04:57.480 --> 00:05:01.060
坚持听到我这样的话

00:04:59.260 --> 00:05:04.090
没有复杂的代码，我们只是

00:05:01.060 --> 00:05:06.220
要创建一个简单的模拟API，所以

00:05:04.090 --> 00:05:08.710
用词疯狂地工作，所以它是

00:05:06.220 --> 00:05:13.960
将支持其类型的人的数据

00:05:08.710 --> 00:05:16.900
带有长ID和好名字

00:05:13.960 --> 00:05:18.990
那就是我们希望能够工作

00:05:16.900 --> 00:05:25.210
有了这些数据，我们就可以找到一个人

00:05:18.990 --> 00:05:27.430
服务，服务将是一个

00:05:25.210 --> 00:05:28.360
支持我不知道会发生什么

00:05:27.430 --> 00:05:30.700
支持它将支持许多

00:05:28.360 --> 00:05:34.440
支持的不同用例

00:05:30.700 --> 00:05:36.420
是用户连接好吗，所以我们说

00:05:34.440 --> 00:05:39.310
现在我会返回false 

00:05:36.420 --> 00:05:44.820
它会支持连接好吧，所以

00:05:39.310 --> 00:05:48.520
避免连接字符串用户字符串PW 

00:05:44.820 --> 00:05:51.040
它支持断开连接，所以我会得到

00:05:48.520 --> 00:05:54.190
回到它会支持返回一个

00:05:51.040 --> 00:05:58.720
凭身份证的人没事，所以

00:05:54.190 --> 00:06:07.200
我们还需要什么

00:05:58.720 --> 00:06:09.090
通过名称查找所有人，因此找到字符串名称

00:06:07.200 --> 00:06:12.530
对

00:06:09.090 --> 00:06:14.760
很好，那就是我们的表面积API 

00:06:12.530 --> 00:06:16.830
自然，我们需要他们知道有一个

00:06:14.760 --> 00:06:18.930
实际需要的数据很少

00:06:16.830 --> 00:06:20.669
数据以使其正常工作，所以让我们

00:06:18.930 --> 00:06:21.930
继续写一些数据

00:06:20.669 --> 00:06:24.150
梁被初始化，我们将继续

00:06:21.930 --> 00:06:26.070
将一些数据写入数据库，我们的

00:06:24.150 --> 00:06:28.970
在这种情况下，我使用的是巨型数据库

00:06:26.070 --> 00:06:35.520
你知道讽刺的空气报价是

00:06:28.970 --> 00:06:38.580
将人的ID本地地图映射到

00:06:35.520 --> 00:06:41.120
人记录自己，当然是

00:06:38.580 --> 00:06:44.639
在内存中，但仍然只是一张地图还可以

00:06:41.120 --> 00:06:47.430
所以这个点的人会触摸把所有

00:06:44.639 --> 00:06:49.860
我们必须放入数据图

00:06:47.430 --> 00:06:51.479
我们会说流媒体我会得到一些

00:06:49.860 --> 00:07:04.460
样本数据对一些带有日期的样本

00:06:51.479 --> 00:07:04.460
一些类似的名字，所以斯特凡斯特凡

00:07:05.060 --> 00:07:28.650
詹姆斯，我们还想要什么，所以有一个

00:07:26.400 --> 00:07:32.970
名称的数量，我们将映射

00:07:28.650 --> 00:07:34.620
命名为新的人物实体，因此

00:07:32.970 --> 00:07:37.140
那当然是为了捕捉

00:07:34.620 --> 00:07:40.020
我们需要以某种方式生成它的ID 

00:07:37.140 --> 00:07:44.580
我将使用原子长生成

00:07:40.020 --> 00:07:45.960
它，我们会说ID点增量和

00:07:44.580 --> 00:07:48.570
得到，我们将名称传递给他们

00:07:45.960 --> 00:07:51.060
属性在这里，然后我们得到了

00:07:48.570 --> 00:07:55.010
命名，所以现在我们要收集所有

00:07:51.060 --> 00:07:58.080
进入地图，然后将其添加到我们的

00:07:55.010 --> 00:08:00.810
现有的地图，为了做到这一点，我

00:07:58.080 --> 00:08:02.450
需要提供购买功能

00:08:00.810 --> 00:08:05.430
第一个功能是说给定一个

00:08:02.450 --> 00:08:07.740
人给我一把钥匙，我该怎么做

00:08:05.430 --> 00:08:09.389
返回ID，第二个会说

00:08:07.740 --> 00:08:13.500
给我一个价值当然是

00:08:09.389 --> 00:08:18.720
 P本身，我们将存储所有这些

00:08:13.500 --> 00:08:28.800
进入数据库，让我们看看我们到了这里

00:08:18.720 --> 00:08:31.650
哦，错误的路线可以和人贴图

00:08:28.800 --> 00:08:33.510
将存储它，就是这样

00:08:31.650 --> 00:08:35.940
腿就是一切的所在

00:08:33.510 --> 00:08:38.580
那张地图好，所以有我们的样本

00:08:35.940 --> 00:08:40.080
应用程序启动时的数据

00:08:38.580 --> 00:08:42.409
继续执行此代码，以便

00:08:40.080 --> 00:08:46.040
我们会有一些私人决赛

00:08:42.409 --> 00:08:50.900
是的，对不起，原子的金条

00:08:46.040 --> 00:08:55.500
连接不等于没有原子金

00:08:50.900 --> 00:09:00.780
我会说这个点连接起来

00:08:55.500 --> 00:09:04.590
很棒的开始连接那集是

00:09:00.780 --> 00:09:07.530
等于true这个点连接了那个

00:09:04.590 --> 00:09:15.210
我说这个的时候set等于false 

00:09:07.530 --> 00:09:20.220
点人们没有身份证，最后这

00:09:15.210 --> 00:09:26.690
点人们点值点流点

00:09:20.220 --> 00:09:30.600
过滤包含名称的PP 

00:09:26.690 --> 00:09:35.550
好的名字，就是这样

00:09:30.600 --> 00:09:38.670
小写到少量案例收集

00:09:35.550 --> 00:09:42.089
全部放入列表，然后我们去

00:09:38.670 --> 00:09:43.560
有我们的基本终点，不是

00:09:42.089 --> 00:09:44.670
非常花哨的域名，我不在乎

00:09:43.560 --> 00:09:46.740
关于域名，当我有一些

00:09:44.670 --> 00:09:49.110
我们可以用来简单的东西

00:09:46.740 --> 00:09:50.700
例如我们现在有服务

00:09:49.110 --> 00:09:52.650
知道了，让我们建立一个外壳吧

00:09:50.700 --> 00:09:54.630
建立一个我们可以互动的外壳

00:09:52.650 --> 00:09:57.540
与那个数据库，所以我们将有一个

00:09:54.630 --> 00:09:59.580
我们的第一套操作课

00:09:57.540 --> 00:10:01.740
我们的第一组命令支持

00:09:59.580 --> 00:10:04.589
正确的连接性，所以我们称之为

00:10:01.740 --> 00:10:06.320
连接命令和顺序

00:10:04.589 --> 00:10:09.839
当我注入它来完成它的工作时

00:10:06.320 --> 00:10:15.180
人的服务，或者我们可以给我们打电话

00:10:09.839 --> 00:10:17.430
 CRM服务权利无一例外

00:10:15.180 --> 00:10:20.190
是的，所有这些都会起作用，所以我要

00:10:17.430 --> 00:10:22.830
无论如何在这里注入CRM服务

00:10:20.190 --> 00:10:26.130
那就不要把它变成外壳

00:10:22.830 --> 00:10:29.970
组件，然后将其注入

00:10:26.130 --> 00:10:31.260
构造函数，我们用它来创建

00:10:29.970 --> 00:10:32.080
我们的第一个命令，所以让我们创建一个

00:10:31.260 --> 00:10:34.060
在这里命令

00:10:32.080 --> 00:10:37.080
正确连接，需要两个

00:10:34.060 --> 00:10:42.100
参数用户名和密码

00:10:37.080 --> 00:10:44.110
我将其称为

00:10:42.100 --> 00:10:45.580
给它一个字符串，以便连接到CRM 

00:10:44.110 --> 00:10:47.470
这是对我们的描述

00:10:45.580 --> 00:10:51.760
要在这里做，当然就我们而言

00:10:47.470 --> 00:10:53.350
我们只是要连接转发

00:10:51.760 --> 00:10:55.480
现在可以输入用户名和密码了

00:10:53.350 --> 00:10:56.590
想像一下要向

00:10:55.480 --> 00:10:58.240
客户端发生了什么我不想

00:10:56.590 --> 00:10:59.850
与客户交谈，让我们看看

00:10:58.240 --> 00:11:06.120
首先在这里发生什么，让我们运行这个

00:10:59.850 --> 00:11:06.120
我们会说CD 

00:11:14.200 --> 00:11:22.870
等于真正的全新安装，我会做

00:11:22.209 --> 00:11:28.589
那

00:11:22.870 --> 00:11:28.589
 Java-Jar Target的首席执行官Nichelle 

00:11:31.950 --> 00:11:35.790
好吧，你可以在顶部看到

00:11:34.470 --> 00:11:38.399
我们有一点提示可以说

00:11:35.790 --> 00:11:39.870
好吧，告诉我一些帮助的命令

00:11:38.399 --> 00:11:41.940
向我展示了所有内置命令

00:11:39.870 --> 00:11:44.600
包括一个声明控制台的

00:11:41.940 --> 00:11:46.800
退出退出板条箱或控制C和D 

00:11:44.600 --> 00:11:48.540
帮助将向您显示所有命令，因此

00:11:46.800 --> 00:11:50.490
这就是我刚刚为了得到

00:11:48.540 --> 00:11:52.889
此清单实际上是脚本

00:11:50.490 --> 00:11:54.779
需要一个文件，它将允许我

00:11:52.889 --> 00:11:56.459
提供我可以提供的任何命令

00:11:54.779 --> 00:11:58.019
我可以在文件中提供它们的外壳

00:11:56.459 --> 00:12:01.019
并正确编写脚本，我可以使其自动化

00:11:58.019 --> 00:12:02.070
当然还有我们的一个自定义连接

00:12:01.019 --> 00:12:02.370
命令，让我们看一下看起来

00:12:02.070 --> 00:12:06.720
喜欢

00:12:02.370 --> 00:12:09.060
连接等于用户名J密码为P 

00:12:06.720 --> 00:12:11.339
我们去了那里所以我们没有你知道

00:12:09.060 --> 00:12:13.380
没事没错，但没错

00:12:11.339 --> 00:12:15.360
就我而言，你知道我们

00:12:13.380 --> 00:12:17.670
不知道发生了什么事吧

00:12:15.360 --> 00:12:19.260
没有任何反馈，让我们报告

00:12:17.670 --> 00:12:21.269
回到客户那里发生了什么

00:12:19.260 --> 00:12:25.560
但是当我们这样做时，我想确保

00:12:21.269 --> 00:12:29.490
我们得到了报告的配方

00:12:25.560 --> 00:12:31.230
回到客户正确的一次

00:12:29.490 --> 00:12:34.380
然后重新使用该配方，这样

00:12:31.230 --> 00:12:35.490
而不是你知道重塑去和

00:12:34.380 --> 00:12:37.529
我以抽象的方式记录它

00:12:35.490 --> 00:12:39.269
会创造一些

00:12:37.529 --> 00:12:41.190
管理控制台输出的服务

00:12:39.269 --> 00:12:42.899
因为这又是实际的

00:12:41.190 --> 00:12:45.029
这个应用程序的能力是我们

00:12:42.899 --> 00:12:46.230
与你认识的客户交谈

00:12:45.029 --> 00:12:52.440
在控制台上，这不只是关于

00:12:46.230 --> 00:12:55.740
博客，所以控制台服务和所有

00:12:52.440 --> 00:13:00.449
我们要做的是管理

00:12:55.740 --> 00:13:03.050
与系统的交互基本上是这样的

00:13:00.449 --> 00:13:05.279
好吧，指向这里公共无效的权利

00:13:03.050 --> 00:13:07.500
字符串消息，它将需要一个

00:13:05.279 --> 00:13:10.589
参数数组（如果有） 

00:13:07.500 --> 00:13:19.980
可用，我会说出这个点

00:13:10.589 --> 00:13:26.699
点打印好了，这个点出来

00:13:19.980 --> 00:13:28.410
打印F消息和组织以

00:13:26.699 --> 00:13:30.690
通过它，我们必须将其转换为

00:13:28.410 --> 00:13:33.839
阵列，他们会说出那个点

00:13:30.690 --> 00:13:36.329
打印线非常好，所以我们的

00:13:33.839 --> 00:13:39.410
基本的控制台输出，我有点喜欢

00:13:36.329 --> 00:13:43.410
颜色，我帮助他们申请，所以我会

00:13:39.410 --> 00:13:44.800
抓取颜色代码，是ANSI颜色

00:13:43.410 --> 00:13:47.769
这里的代码和

00:13:44.800 --> 00:13:49.420
用这两个两个加倍我们的输出

00:13:47.769 --> 00:13:52.149
这里有点好，所以私人决赛

00:13:49.420 --> 00:13:55.390
字符串，请参阅重置南希黄色

00:13:52.149 --> 00:13:57.700
我们要说的是首先脱颖而出

00:13:55.390 --> 00:14:03.519
打印行还是不打印

00:13:57.700 --> 00:14:06.339
看到黄色没事，那将是事前

00:14:03.519 --> 00:14:08.230
重置，看到重置非常好，所以现在

00:14:06.339 --> 00:14:10.890
让我们重写一下或重新编写这段代码

00:14:08.230 --> 00:14:14.680
在这里反映出我们拥有的事实

00:14:10.890 --> 00:14:21.490
完成了我们期望做的私人工作

00:14:14.680 --> 00:14:23.339
最终控制台服务控制台以及

00:14:21.490 --> 00:14:27.459
注入到构造函数中

00:14:23.339 --> 00:14:33.940
我们将在此处报告，以便此点控制台

00:14:27.459 --> 00:14:35.860
点右连接用户名可以

00:14:33.940 --> 00:14:44.920
不错，让我们看看发生了什么

00:14:35.860 --> 00:14:50.110
为我们做的，所以我们在这里走了，所以如果

00:14:44.920 --> 00:14:52.500
我们去这里连接它说连接J 

00:14:50.110 --> 00:14:55.270
它是黄色的，所以我用了

00:14:52.500 --> 00:14:56.589
那里的ANSI颜色代码表示

00:14:55.270 --> 00:14:58.420
以下文字应为彩色， 

00:14:56.589 --> 00:15:00.250
然后当我点击重置时，它会返回

00:14:58.420 --> 00:15:02.890
不管有什么颜色

00:15:00.250 --> 00:15:04.570
对的，这样的作品似乎是

00:15:02.890 --> 00:15:10.000
让我们继续实施我们的工作

00:15:04.570 --> 00:15:11.589
在此断开功能

00:15:10.000 --> 00:15:15.430
是非常简单的权利，我们只是

00:15:11.589 --> 00:15:20.890
说公共无效断开连接，我会

00:15:15.430 --> 00:15:23.829
说这个点Cor m点断开所有

00:15:20.890 --> 00:15:26.890
可以想象的问题是

00:15:23.829 --> 00:15:28.360
这些东西不应该在

00:15:26.890 --> 00:15:30.820
在同一时间，所以我有两个

00:15:28.360 --> 00:15:32.440
这里有不同的命令，但我想

00:15:30.820 --> 00:15:33.910
给客户一些反馈

00:15:32.440 --> 00:15:35.470
当我连接时

00:15:33.910 --> 00:15:36.910
我可以断开连接，但是当我不连接时

00:15:35.470 --> 00:15:39.160
连接我不应该

00:15:36.910 --> 00:15:41.560
断开连接，因为那是

00:15:39.160 --> 00:15:42.579
无理的权利，如果我是

00:15:41.560 --> 00:15:45.130
已经连接，我不应该

00:15:42.579 --> 00:15:47.620
重新连接正确，所以我们需要

00:15:45.130 --> 00:15:49.230
提供某种视觉反馈，所以我

00:15:47.620 --> 00:15:52.680
要做的就是创建一个

00:15:49.230 --> 00:15:52.680
可用性对象

00:15:54.889 --> 00:16:01.350
询问时返回客户

00:16:00.209 --> 00:16:02.699
写框架会给我们一个

00:16:01.350 --> 00:16:03.509
我们可以向客户发出信号的机会

00:16:02.699 --> 00:16:05.490
您应该使用哪一个

00:16:03.509 --> 00:16:08.310
通过创建一个或通过注释方法

00:16:05.490 --> 00:16:09.839
使用shell方法的可用性，然后

00:16:08.310 --> 00:16:13.230
返回可用性对象，并

00:16:09.839 --> 00:16:17.160
此可用性对象将由

00:16:13.230 --> 00:16:19.170
 shell组件中的所有命令

00:16:17.160 --> 00:16:20.910
确定是否应该

00:16:19.170 --> 00:16:24.329
是否变灰

00:16:20.910 --> 00:16:25.439
是否被激活，这不是我们所需要的

00:16:24.329 --> 00:16:27.180
希望这很有趣，因为它给

00:16:25.439 --> 00:16:28.769
您提供反馈的一种方法

00:16:27.180 --> 00:16:32.129
我想要的是与众不同

00:16:28.769 --> 00:16:34.110
为此的可用性，然后我为此

00:16:32.129 --> 00:16:35.550
显然，这必须是排他的

00:16:34.110 --> 00:16:37.259
彼此之间，所以还有另一个

00:16:35.550 --> 00:16:41.449
方便的机制在这里我们可以

00:16:37.259 --> 00:16:44.279
说可用性断开，然后

00:16:41.449 --> 00:16:47.310
后缀名称为available，并且

00:16:44.279 --> 00:16:48.899
我们的工作是说好断开只是

00:16:47.310 --> 00:16:51.089
当我们连接时可用

00:16:48.899 --> 00:16:56.819
连接好的步血清

00:16:51.089 --> 00:17:00.300
可用性可用，否则

00:16:56.819 --> 00:17:01.589
你知道你没有连接好吗

00:17:00.300 --> 00:17:04.650
慈善直接

00:17:01.589 --> 00:17:06.150
按照惯例， 

00:17:04.650 --> 00:17:08.880
寻找可用性

00:17:06.150 --> 00:17:13.490
方法类似，我们可以做同样的事情

00:17:08.880 --> 00:17:13.490
这里的连接命令

00:17:15.760 --> 00:17:20.740
然后该卷就被释放了

00:17:18.309 --> 00:17:23.500
相反，所以我们要说

00:17:20.740 --> 00:17:26.260
我们没有连接，那么这是

00:17:23.500 --> 00:17:29.860
可用，否则我们会说

00:17:26.260 --> 00:17:36.210
您已经连接好了，让我们

00:17:29.860 --> 00:17:36.210
清理一下，我们将再次开始

00:17:38.309 --> 00:17:43.179
好吧

00:17:40.530 --> 00:17:43.690
所以实际上在我超前之前

00:17:43.179 --> 00:17:47.020
我

00:17:43.690 --> 00:17:51.720
帮助表明我们无法断开连接，但是

00:17:47.020 --> 00:17:56.890
我们可以连接好用户名和密码

00:17:51.720 --> 00:18:00.429
 P任何好的帮助再次向我表明

00:17:56.890 --> 00:18:02.290
现在断开连接可见，但是我

00:18:00.429 --> 00:18:04.360
无法连接星号信号

00:18:02.290 --> 00:18:06.490
目前无法使用

00:18:04.360 --> 00:18:08.770
好吧，那行得通，但为了我

00:18:06.490 --> 00:18:10.990
为了获得反馈，我必须使用

00:18:08.770 --> 00:18:13.210
每次查看帮助命令

00:18:10.990 --> 00:18:16.059
命令旁边的星号

00:18:13.210 --> 00:18:18.520
我喜欢做的是

00:18:16.059 --> 00:18:19.600
提示中显示的信息如此

00:18:18.520 --> 00:18:23.010
当批评家的时候我们要做

00:18:19.600 --> 00:18:27.150
自定义提示提供程序已连接

00:18:23.010 --> 00:18:29.440
提示提供者实施提示

00:18:27.150 --> 00:18:32.490
提供程序提示提供程序回调

00:18:29.440 --> 00:18:35.799
方法中的回调接口

00:18:32.490 --> 00:18:38.440
Spring Shell项目，工作非常

00:18:35.799 --> 00:18:41.080
简单，当被问到时，我们将其提示

00:18:38.440 --> 00:18:43.840
它将代替shell显示：您

00:18:41.080 --> 00:18:49.660
知道更多然后正确，所以我们要

00:18:43.840 --> 00:18:51.970
说我拥有私人最终CRM服务CRM 

00:18:49.660 --> 00:18:58.990
构造函数参数，我们将说

00:18:51.970 --> 00:19:02.790
字符串消息等于Spring CRM will 

00:18:58.990 --> 00:19:11.380
有一点价值，会说

00:19:02.790 --> 00:19:14.980
字符串格式还可以，然后在输出中

00:19:11.380 --> 00:19:18.440
在这里，我们要说这点血清

00:19:14.980 --> 00:19:27.390
已连接

00:19:18.440 --> 00:19:31.950
否则断开连接好该死好吧

00:19:27.390 --> 00:19:33.660
空间，所以我们现在就去，我们只是返回

00:19:31.950 --> 00:19:35.070
属性字符串可能很多

00:19:33.660 --> 00:19:37.020
如果想要的话还有更多的事情，但是

00:19:35.070 --> 00:19:39.179
我们的目的只是字符串

00:19:37.020 --> 00:19:40.170
对，那就很简单，让我们

00:19:39.179 --> 00:19:48.809
继续并重新启动，让我们看看

00:19:40.170 --> 00:19:53.690
碰巧那里是 Spring 

00:19:48.809 --> 00:19:56.040
血清断开连接好吗，如果我们

00:19:53.690 --> 00:19:57.840
连接是的，它说连接了J，并且它

00:19:56.040 --> 00:19:59.670
说连接到那里，所以我们有

00:19:57.840 --> 00:20:01.590
更可见更有用

00:19:59.670 --> 00:20:03.630
那里的反馈，我认为这是

00:20:01.590 --> 00:20:05.760
方便，当然您可以使用

00:20:03.630 --> 00:20:09.900
害怕你知道实体切割机和所有

00:20:05.760 --> 00:20:11.309
这些东西都适用于那里

00:20:09.900 --> 00:20:12.660
所以我们已经有了并建立一个新的

00:20:11.309 --> 00:20:14.370
命令让我们建立一些

00:20:12.660 --> 00:20:16.320
让我们可以与

00:20:14.370 --> 00:20:19.710
数据人记录人

00:20:16.320 --> 00:20:25.380
所以我们将创建一个新的命令分组

00:20:19.710 --> 00:20:26.760
在这里我会说全班同学都评论

00:20:25.380 --> 00:20:29.400
对，所以这使我们可以与

00:20:26.760 --> 00:20:31.770
目录，这只是一个外壳

00:20:29.400 --> 00:20:34.470
组件，我们在这里有一个端点

00:20:31.770 --> 00:20:36.929
返回它将会是一个目录

00:20:34.470 --> 00:20:39.200
端点，它将与

00:20:36.929 --> 00:20:46.290
类型人的记录所以有这个

00:20:39.200 --> 00:20:48.200
 shell方法目录与

00:20:46.290 --> 00:20:51.390
目录好，所以有我们的

00:20:48.200 --> 00:20:54.900
方便的命令，我们将

00:20:51.390 --> 00:20:56.940
基本上编辑我们将要找到的

00:20:54.900 --> 00:20:59.340
人，然后对其进行正确的编辑，但

00:20:56.940 --> 00:21:00.870
问题是Spring Shell没有

00:20:59.340 --> 00:21:03.660
知道一个人对，我们这个人是

00:21:00.870 --> 00:21:05.429
一个实体，它是一个领域模型，它是一个

00:21:03.660 --> 00:21:07.950
细节是很多事情，但是

00:21:05.429 --> 00:21:09.960
它不是Spring Shell类型，所以我们需要

00:21:07.950 --> 00:21:12.420
我们需要教它怎么做

00:21:09.960 --> 00:21:13.920
当我们在这里可以使用

00:21:12.420 --> 00:21:15.780
转换器框架中的基板

00:21:13.920 --> 00:21:17.280
 Spring ，自从我就去过那里

00:21:15.780 --> 00:21:20.340
不知道有3个dotto 

00:21:17.280 --> 00:21:22.050
永远是我们使用的一种机制

00:21:20.340 --> 00:21:23.100
充耳不闻

00:21:22.050 --> 00:21:25.050
域和反之亦然

00:21:23.100 --> 00:21:26.640
它已在所有框架中使用

00:21:25.050 --> 00:21:29.340
我们所有人的整个生态系统

00:21:26.640 --> 00:21:31.299
 Pingdom，所以如果您不形成绑定

00:21:29.340 --> 00:21:32.350
 Spring MVC或Web Flex 

00:21:31.299 --> 00:21:33.879
如果使用Spring ，就使用它

00:21:32.350 --> 00:21:35.649
创新或您是否正在做某些事情

00:21:33.879 --> 00:21:40.029
 Spring Expression Language 构造if 

00:21:35.649 --> 00:21:41.860
你在做你知道什么

00:21:40.029 --> 00:21:43.179
随处可见的事物数量

00:21:41.860 --> 00:21:45.549
你可以想到的是

00:21:43.179 --> 00:21:46.899
某种转换器转换

00:21:45.549 --> 00:21:48.429
服务机制在那里某处

00:21:46.899 --> 00:21:49.779
我们将创建一个自定义转换器

00:21:48.429 --> 00:21:51.730
这将被插入

00:21:49.779 --> 00:21:54.129
正如我所说的，转换服务

00:21:51.730 --> 00:21:56.350
 Spring 的至少十年我

00:21:54.129 --> 00:22:02.289
我猜大概十年了，我要说

00:21:56.350 --> 00:22:06.700
类人转换器

00:22:02.289 --> 00:22:08.980
类型字符串二类人的转换器

00:22:06.700 --> 00:22:13.529
合同很简单

00:22:08.980 --> 00:22:15.340
说给定来源转换记录

00:22:13.529 --> 00:22:18.039
所以我们要做的是

00:22:15.340 --> 00:22:19.989
假设该字符串是

00:22:18.039 --> 00:22:22.450
要输入的是统一的，因为我们

00:22:19.989 --> 00:22:23.919
可以解析统一的权利，这就是我

00:22:22.450 --> 00:22:26.190
我有一个正则表达式

00:22:23.919 --> 00:22:29.799
想到这里，我们将用它来

00:22:26.190 --> 00:22:32.889
缩短解析时间

00:22:29.799 --> 00:22:39.429
我梦dream以求的架构，所以

00:22:32.889 --> 00:22:40.960
私人决赛，我们是如此常规

00:22:39.429 --> 00:22:42.580
表达模式，那会是什么

00:22:40.960 --> 00:22:47.289
寻找以下记录

00:22:42.580 --> 00:22:51.009
这样的形式，你知道fubar吧

00:22:47.289 --> 00:22:52.359
它只会保留42个，这是

00:22:51.009 --> 00:22:54.429
会有一个叫做

00:22:52.359 --> 00:22:57.609
支持那个号码好吧，所以

00:22:54.429 --> 00:23:02.850
我想说这个的时候我们想用那个

00:22:57.609 --> 00:23:08.249
点图案点匹配您的来源， 

00:23:02.850 --> 00:23:12.549
如果找到匹配项或点，则映射到匹配器

00:23:08.249 --> 00:23:14.139
然后说匹配或点循环，我们

00:23:12.549 --> 00:23:17.769
不想整个表达，我们只是

00:23:14.139 --> 00:23:19.629
想要与您匹配的那一组

00:23:17.769 --> 00:23:20.799
知道内在括号就可以了

00:23:19.629 --> 00:23:29.200
那是第一组，我们想

00:23:20.799 --> 00:23:38.680
说字符串utils是否具有文本组

00:23:29.200 --> 00:23:43.210
然后长死解析长循环，我

00:23:38.680 --> 00:23:44.620
会说长id等于，我们会看

00:23:43.210 --> 00:23:46.720
在今年获得专利服务

00:23:44.620 --> 00:23:48.040
在这里，所以我们没有CM服务

00:23:46.720 --> 00:23:56.050
就在这里，让我们开始吧

00:23:48.040 --> 00:23:58.690
私人最终CRM服务，好吧，我有一个

00:23:56.050 --> 00:24:02.650
构造函数参数，我们会说

00:23:58.690 --> 00:24:03.820
这会使血清点正确找到我的ID吗

00:24:02.650 --> 00:24:04.530
这正是我们想要做的

00:24:03.820 --> 00:24:07.240
毕竟

00:24:04.530 --> 00:24:08.590
否则我们就把它打开

00:24:07.240 --> 00:24:11.050
那是相当简单的

00:24:08.590 --> 00:24:18.340
实现让我们继续尝试

00:24:11.050 --> 00:24:21.780
那个现在不知道事实

00:24:18.340 --> 00:24:25.300
我们期待某种模式的坚定

00:24:21.780 --> 00:24:26.680
知名文字会打扰您

00:24:25.300 --> 00:24:29.050
现在我们只是试图证明

00:24:26.680 --> 00:24:32.920
会起作用，但正如我们将看到的那样

00:24:29.050 --> 00:24:37.390
为我们装满汽车，让我们

00:24:32.920 --> 00:24:39.180
看到目录的人好吧，所以我们

00:24:37.390 --> 00:24:44.890
知道如果是这样的形式

00:24:39.180 --> 00:24:46.740
不管什么都行，我们也一样

00:24:44.890 --> 00:24:55.720
我们没有做任何事情，我们必须

00:24:46.740 --> 00:24:59.940
给我们控制台服务控制台， 

00:24:55.720 --> 00:25:03.360
我会说这个dot console dot right 

00:24:59.940 --> 00:25:03.360
与...合作

00:25:06.530 --> 00:25:17.150
知道名字的人有我们的

00:25:12.240 --> 00:25:17.150
我们去重写代码

00:25:19.809 --> 00:25:27.330
现在对目录人愚弄

00:25:32.020 --> 00:25:37.880
我们去那里，所以他们是常客

00:25:36.530 --> 00:25:40.039
表达正确，它说如果我

00:25:37.880 --> 00:25:42.289
有那个模式没关系

00:25:40.039 --> 00:25:44.809
 -括号后可以是数字

00:25:42.289 --> 00:25:46.190
字符空间，只要

00:25:44.809 --> 00:25:48.980
没错，它将能够提取

00:25:46.190 --> 00:25:50.929
 ID找到记录，然后打印出来

00:25:48.980 --> 00:25:52.789
与Brian Brian合作的过程

00:25:50.929 --> 00:25:54.770
现在当然一切都很好

00:25:52.789 --> 00:25:58.190
很好，但是我们的用户多久一次

00:25:54.770 --> 00:25:59.919
知道那个模式或想记住它

00:25:58.190 --> 00:26:02.299
首先，然后是第二

00:25:59.919 --> 00:26:03.710
他们不会知道你知道哪个ID 

00:26:02.299 --> 00:26:05.299
对应于哪个用户，所以这是

00:26:03.710 --> 00:26:07.039
真的很痛苦，我们想让他们

00:26:05.299 --> 00:26:08.659
搜索，所以我要做的是

00:26:07.039 --> 00:26:11.270
将为他们提供一种获取途径

00:26:08.659 --> 00:26:13.280
自动完成，因为他们键入和

00:26:11.270 --> 00:26:14.990
键入标签，他们将获得反馈

00:26:13.280 --> 00:26:17.000
从系统告诉他们

00:26:14.990 --> 00:26:19.340
可以匹配搜索的记录

00:26:17.000 --> 00:26:25.600
所以在这里我要提供一个价值

00:26:19.340 --> 00:26:29.480
提供者，因此，班级人员提供者

00:26:25.600 --> 00:26:33.080
实现价值提供者，工作是

00:26:29.480 --> 00:26:35.210
非常简单，这是一个组成部分和Spring 

00:26:33.080 --> 00:26:39.400
外壳，并需要了解有关

00:26:35.210 --> 00:26:43.370
我们在这里的论据是

00:26:39.400 --> 00:26:45.679
外壳选项，我将介绍一下

00:26:43.370 --> 00:26:48.080
它在那里使用类文字语法

00:26:45.679 --> 00:26:50.480
所以我们说经营这个价值提供者

00:26:48.080 --> 00:26:52.669
当他们检查此值时

00:26:50.480 --> 00:26:55.580
类型和我们所提供的价值提供者

00:26:52.669 --> 00:26:58.850
要写有一个非常简单的工作

00:26:55.580 --> 00:27:01.070
它说什么时候进来， 

00:26:58.850 --> 00:27:04.669
参数获取素数知道类型是一个符号

00:27:01.070 --> 00:27:11.809
从人保持的所有折叠迹象

00:27:04.669 --> 00:27:17.150
它，然后你知道返回记录，所以

00:27:11.809 --> 00:27:20.049
私人最终CRM服务CRM拥有一个

00:27:17.150 --> 00:27:20.049
构造函数参数

00:27:20.999 --> 00:27:31.019
好好把它移到那里，让我们看看

00:27:26.129 --> 00:27:34.379
我们要说的是字符串当前输入

00:27:31.019 --> 00:27:38.699
等于完成上下文当前单词

00:27:34.379 --> 00:27:45.209
直到光标，我们要说这个

00:27:38.699 --> 00:27:47.399
点血清点按名称查找

00:27:45.209 --> 00:27:51.419
当前输入，然后我们将

00:27:47.399 --> 00:27:55.349
流式传输，然后我们将其旋转

00:27:51.419 --> 00:27:59.669
纳入完成建议书中

00:27:55.349 --> 00:28:06.419
所以我们首先得到了一个地图，所以P字符串

00:27:59.669 --> 00:28:07.049
像这样的格式

00:28:06.419 --> 00:28:10.879
对

00:28:07.049 --> 00:28:16.049
所以它将是P获得ID P获得名称

00:28:10.879 --> 00:28:22.979
那个地图完成建议

00:28:16.049 --> 00:28:26.279
新的，所以我们重写了

00:28:22.979 --> 00:28:27.899
代码，我们要做的就是说

00:28:26.279 --> 00:28:29.549
查找与该记录匹配的所有记录

00:28:27.899 --> 00:28:32.279
当前输入的字符串是

00:28:29.549 --> 00:28:34.499
这一点就在这里拿来创造

00:28:32.279 --> 00:28:36.179
我们没有在那个模式中对它进行编码

00:28:34.499 --> 00:28:39.389
我们之前讨论过的使用

00:28:36.179 --> 00:28:41.959
完成建议，然后点击继续

00:28:39.389 --> 00:28:41.959
让我们再试一次

00:28:44.899 --> 00:28:51.839
好的目录看看我们得到

00:28:50.039 --> 00:28:53.579
自动完成这些不同的

00:28:51.839 --> 00:28:56.729
记录是因为我没有输入

00:28:53.579 --> 00:28:58.829
任何东西，如果我只输入BR 

00:28:56.729 --> 00:29:00.719
例如，我有两个建议，布莱恩

00:28:58.829 --> 00:29:03.509
所以，布莱恩关闭了，当然我

00:29:00.719 --> 00:29:06.059
可以按跳动去，它说我

00:29:03.509 --> 00:29:08.279
和Brian一起工​​作L，所以我们

00:29:06.059 --> 00:29:10.289
现在走，我们已经看到了

00:29:08.279 --> 00:29:12.509
只是几种使用

00:29:10.289 --> 00:29:14.339
 spring shell项目来构建一个

00:29:12.509 --> 00:29:15.749
应用程序现在有一点

00:29:14.339 --> 00:29:16.559
在这里擦亮其余的东西

00:29:15.749 --> 00:29:18.479
我们要谈论的不是

00:29:16.559 --> 00:29:20.339
严格来说是Spring Shell

00:29:18.479 --> 00:29:21.449
具体的，但这是你可能会做的

00:29:20.339 --> 00:29:23.939
关心何时构建外壳

00:29:21.449 --> 00:29:25.619
基于应用程序首先考虑

00:29:23.939 --> 00:29:27.379
在我开始时，我们已经正确记录了日志

00:29:25.619 --> 00:29:30.329
应用程序把所有这些东西

00:29:27.379 --> 00:29:31.469
有点使经验混乱，如果

00:29:30.329 --> 00:29:33.569
你不在乎我不在乎，但是如果

00:29:31.469 --> 00:29:34.119
您确实很容易解决该问题

00:29:33.569 --> 00:29:35.559
对你

00:29:34.119 --> 00:29:39.279
去建立并保持记录，我

00:29:35.559 --> 00:29:46.509
会马上下载老鹰，所以我

00:29:39.279 --> 00:29:47.979
试试吧

00:29:46.509 --> 00:29:51.689
好多了，现在我们可以说

00:29:47.979 --> 00:29:53.889
连接Eagles用户名J密码P 

00:29:51.689 --> 00:29:56.139
连接，现在很干净

00:29:53.889 --> 00:29:58.659
碰巧是这个要求的忠实粉丝

00:29:56.139 --> 00:30:01.329
任何认识我的人都知道这是

00:29:58.659 --> 00:30:03.899
我知道我在罚款中排名

00:30:01.329 --> 00:30:06.639
说的世界艺术杰作

00:30:03.899 --> 00:30:08.709
也许你很喜欢你

00:30:06.639 --> 00:30:11.499
要更改它，没关系，您知道

00:30:08.709 --> 00:30:13.499
可以，我可以，我可以

00:30:11.499 --> 00:30:16.089
为什么你不应该这样做

00:30:13.499 --> 00:30:18.699
我们要把篮子换成

00:30:16.089 --> 00:30:21.459
 ASCII艺术这里的横幅艺术品

00:30:18.699 --> 00:30:25.149
好，我要复制一个预先写好的

00:30:21.459 --> 00:30:31.539
横幅txt到我的下载shellcode 

00:30:25.149 --> 00:30:32.049
来源主要资源横幅点txt全部

00:30:31.539 --> 00:30:34.569
对

00:30:32.049 --> 00:30:40.449
我想实际上就是这样

00:30:34.569 --> 00:30:42.369
只是重建它还不错吧

00:30:40.449 --> 00:30:45.999
 spring crm spring tip slide有一个

00:30:42.369 --> 00:30:49.569
 Twitter的处理还可以，所以我们还是

00:30:45.999 --> 00:30:50.889
我们仍然需要运行java-jar吗

00:30:49.569 --> 00:30:52.989
你注意到我必须享受-jar 

00:30:50.889 --> 00:30:55.029
目标等等等等，那是因为

00:30:52.989 --> 00:30:56.859
这只是一个罐子这是一个胖罐子

00:30:55.029 --> 00:30:59.409
你知道所有需要的东西

00:30:56.859 --> 00:31:01.479
除了JDK之外，它的内部是

00:30:59.409 --> 00:31:03.819
仍然你需要你需要你需要

00:31:01.479 --> 00:31:05.379
告诉D衰减正确运行，所以我们

00:31:03.819 --> 00:31:08.769
可以更进一步

00:31:05.379 --> 00:31:10.509
自定义构建本身，所以在这里

00:31:08.769 --> 00:31:12.759
会在 Spring 去做插件

00:31:10.509 --> 00:31:20.129
启动Maven插件并使之成为

00:31:12.759 --> 00:31:25.959
行政罐子，将要发生的是

00:31:20.129 --> 00:31:28.149
我可以不用

00:31:25.959 --> 00:31:29.319
必须使用Java CLI或Java 

00:31:28.149 --> 00:31:31.569
命令，它仍然会在那里

00:31:29.319 --> 00:31:33.819
最终不需要它，但是你

00:31:31.569 --> 00:31:38.679
知道我也不必担心

00:31:33.819 --> 00:31:42.000
好多了，还不错吧，还不错，所以

00:31:38.679 --> 00:31:46.679
我们有一个用户名

00:31:42.000 --> 00:31:51.269
密码P好，我们可以建立一个目录

00:31:46.679 --> 00:31:56.940
用这些记录之一搜索很好，我们

00:31:51.269 --> 00:31:59.759
可以断开连接，我们可以退出

00:31:56.940 --> 00:32:01.710
所以我和那个朋友一起看过

00:31:59.759 --> 00:32:03.990
我们看过的Spring Shell项目

00:32:01.710 --> 00:32:05.460
如何建立一个简单的基于Spring 的外壳

00:32:03.990 --> 00:32:07.409
应用程序值得理解

00:32:05.460 --> 00:32:09.600
 Spring 你可以做的一切

00:32:07.409 --> 00:32:11.279
知道然后打印出来就可以

00:32:09.600 --> 00:32:13.379
Spring Shell，所以你可以有这个

00:32:11.279 --> 00:32:15.450
连接到基于WebSocket的聊天

00:32:13.379 --> 00:32:18.480
例如，您可以使用它与

00:32:15.450 --> 00:32:19.860
使用Spring Web Flex Web的REST API 

00:32:18.480 --> 00:32:22.169
客户或休息模板或曾经

00:32:19.860 --> 00:32:26.129
与后端后端服务交谈

00:32:22.169 --> 00:32:28.549
可能会带动

00:32:26.129 --> 00:32:31.080
您知道Spring Batch作业或

00:32:28.549 --> 00:32:32.309
发送消息到频道或

00:32:31.080 --> 00:32:35.100
做任何你想做的事

00:32:32.309 --> 00:32:36.750
所有这只是一个很好的易于使用的易于

00:32:35.100 --> 00:32:39.000
脚本易于自动化，易于交互

00:32:36.750 --> 00:32:41.399
工具轻巧

00:32:39.000 --> 00:32:43.769
不需要很多，不需要很多

00:32:41.399 --> 00:32:46.379
谈论这个罐子的资源

00:32:43.769 --> 00:32:48.750
移动它，所以我们有血清

00:32:46.379 --> 00:32:50.429
这是整个罐子里的12米格

00:32:48.750 --> 00:32:52.889
罐子里的所有功能

00:32:50.429 --> 00:32:55.139
一切都是-谈论罐子，所以

00:32:52.889 --> 00:32:57.419
我们得到了我们没有去看

00:32:55.139 --> 00:32:58.500
我的意思是其他一些功能

00:32:57.419 --> 00:32:59.759
显然可以想象

00:32:58.500 --> 00:33:03.000
除此以外，还有很多其他功能

00:32:59.759 --> 00:33:04.559
这可以使某些参数

00:33:03.000 --> 00:33:06.539
您的命令可选

00:33:04.559 --> 00:33:09.539
例子，更重要的是

00:33:06.539 --> 00:33:11.360
甚至支持杰克指挥官

00:33:09.539 --> 00:33:16.460
由创建的一个单独的项目

00:33:11.360 --> 00:33:18.570
塞德里克说的是

00:33:16.460 --> 00:33:21.179
例如测试G的绅士

00:33:18.570 --> 00:33:22.830
他创建了一个用于绑定的项目

00:33:21.179 --> 00:33:24.779
命令行中的参数

00:33:22.830 --> 00:33:26.700
被称为杰克指挥官，他们非常

00:33:24.779 --> 00:33:27.779
有用，可以在Spring 上使用

00:33:26.700 --> 00:33:33.870
外壳，如果您想要的话，那么您可以

00:33:27.779 --> 00:33:35.970
将参数绑定到命令到POJO 

00:33:33.870 --> 00:33:39.149
而不是必须声明习俗

00:33:35.970 --> 00:33:43.710
参数或更确切地说是

00:33:39.149 --> 00:33:45.629
每个命令方法在这里，你知道

00:33:43.710 --> 00:33:47.220
除此以外，还有很多其他的事情

00:33:45.629 --> 00:33:48.419
现在是早期，但这是

00:33:47.220 --> 00:33:49.110
仍然是第二个里程碑，所以如果你

00:33:48.419 --> 00:33:54.390
有反馈

00:33:49.110 --> 00:33:57.010
我敢肯定Spring Shell团队和

00:33:54.390 --> 00:34:00.010
最终更大的 Spring Cloud 

00:33:57.010 --> 00:34:01.270
数据流以及所有基于项目的项目

00:34:00.010 --> 00:34:03.180
在春季，所有这些项目都会

00:34:01.270 --> 00:34:05.080
感谢所有反馈，以便如此

00:34:03.180 --> 00:34:07.480
试试看

00:34:05.080 --> 00:34:10.320
让我们知道，谢谢

00:34:07.480 --> 00:34:10.320
看着下次见

00:34:16.780 --> 00:34:18.840
您

