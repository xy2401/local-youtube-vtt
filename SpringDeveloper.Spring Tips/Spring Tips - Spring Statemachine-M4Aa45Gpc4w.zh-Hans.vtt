WEBVTT
Kind: captions
Language: zh-Hans

00:00:25.820 --> 00:00:30.020
嗨，本期 Spring 粉丝

00:00:28.400 --> 00:00:32.390
 Spring 的技巧，我们要看看

00:00:30.020 --> 00:00:34.010
Spring Statemachine现在Spring 状态

00:00:32.390 --> 00:00:35.600
机器是一个项目，使我们能够

00:00:34.010 --> 00:00:38.540
只描述状态机

00:00:35.600 --> 00:00:39.890
基本上包含众所周知的东西

00:00:38.540 --> 00:00:40.850
从一个很好理解的过渡

00:00:39.890 --> 00:00:43.699
向另一个国家陈述

00:00:40.850 --> 00:00:44.840
你可能已经建立了一百万个州

00:00:43.699 --> 00:00:46.670
生活中的机器

00:00:44.840 --> 00:00:49.129
完全可以进行任何类型的编程

00:00:46.670 --> 00:00:51.290
的if-then-else语句

00:00:49.129 --> 00:00:53.710
这个例子在某个时候会构成一个

00:00:51.290 --> 00:00:55.879
状态机案例说明

00:00:53.710 --> 00:00:57.470
构成任何状态机

00:00:55.879 --> 00:00:59.149
您拥有或删除或转换的地方

00:00:57.470 --> 00:01:01.579
可预测的确定性转变

00:00:59.149 --> 00:01:02.750
从一种状态到另一种状态

00:01:01.579 --> 00:01:04.489
与之相关的动作是

00:01:02.750 --> 00:01:07.039
状态机，所以状态机是

00:01:04.489 --> 00:01:08.630
我们所做的非常基本的部分

00:01:07.039 --> 00:01:10.700
往往不归结为这些

00:01:08.630 --> 00:01:11.990
丑陋的if语句是小精灵

00:01:10.700 --> 00:01:14.810
陈述之类的东西，以及

00:01:11.990 --> 00:01:16.940
更糟糕的是，如果您有复杂的状态，那么您

00:01:14.810 --> 00:01:18.320
必须在现场评估该状态

00:01:16.940 --> 00:01:19.880
你在哪里保持这个体重

00:01:18.320 --> 00:01:21.530
您实际上正在将状态处理为

00:01:19.880 --> 00:01:23.750
反对更高层次的

00:01:21.530 --> 00:01:27.020
使解脱变得非常有用

00:01:23.750 --> 00:01:28.399
的进展流

00:01:27.020 --> 00:01:30.860
从一个状态到

00:01:28.399 --> 00:01:32.840
另一个进入一个单独的平面

00:01:30.860 --> 00:01:35.030
我们可以在这里建模的地方

00:01:32.840 --> 00:01:36.619
可以对此进行推理，然后

00:01:35.030 --> 00:01:38.630
编码实际的业务逻辑

00:01:36.619 --> 00:01:39.770
与那些相关的回应

00:01:38.630 --> 00:01:41.420
状态更改正确，所以您有

00:01:39.770 --> 00:01:42.799
而不是一堆业务逻辑

00:01:41.420 --> 00:01:45.470
你有一堆

00:01:42.799 --> 00:01:46.909
该站点上的if-then-else语句

00:01:45.470 --> 00:01:48.560
您在哪里做决定

00:01:46.909 --> 00:01:50.869
决定下一步做什么而不是

00:01:48.560 --> 00:01:53.780
保持您的业务逻辑

00:01:50.869 --> 00:01:55.610
在一个地方然后采取行动

00:01:53.780 --> 00:01:57.170
或经理或其他人，或者您知道一些

00:01:55.610 --> 00:02:00.470
描述应该发生什么的方式

00:01:57.170 --> 00:02:02.930
基于该状态，这是它的

00:02:00.470 --> 00:02:04.460
这很有用，因为如果您想

00:02:02.930 --> 00:02:06.649
更改工作流前端以更改

00:02:04.460 --> 00:02:08.390
一件事发展到另一件事

00:02:06.649 --> 00:02:10.070
可以在一个地方做到这一点

00:02:08.390 --> 00:02:11.090
不得不冲刷所有不同的东西

00:02:10.070 --> 00:02:14.360
您拥有的代码库中的图层

00:02:11.090 --> 00:02:16.610
所有这些复杂的决定都这样说

00:02:14.360 --> 00:02:19.400
机器很有价值，为此

00:02:16.610 --> 00:02:21.769
他们也形成的原因也给了我们

00:02:19.400 --> 00:02:23.630
一种思考问题的好方法

00:02:21.769 --> 00:02:25.070
我们的应用进展如何

00:02:23.630 --> 00:02:27.079
事情应该发生怎么办

00:02:25.070 --> 00:02:28.730
在其中进行业务项目建模

00:02:27.079 --> 00:02:30.530
状态机的条件是非常

00:02:28.730 --> 00:02:32.570
有用的想法，即使你不打算

00:02:30.530 --> 00:02:34.940
在代码级别使用状态机

00:02:32.570 --> 00:02:36.680
例如，这就是为什么UML具有

00:02:34.940 --> 00:02:38.239
支持描述状态机

00:02:36.680 --> 00:02:39.020
写状态机非常非常

00:02:38.239 --> 00:02:44.530
我们重要的部分

00:02:39.020 --> 00:02:48.320
人们想在某个时候做

00:02:44.530 --> 00:02:51.890
将业务与代码和

00:02:48.320 --> 00:02:53.420
状态机提供了一个合理的地方

00:02:51.890 --> 00:02:56.480
商业和技术都在这里

00:02:53.420 --> 00:02:58.670
人们可以对界面进行排序

00:02:56.480 --> 00:03:00.440
商业启发法

00:02:58.670 --> 00:03:02.480
对我们的业务而言

00:03:00.440 --> 00:03:03.710
组织可以按照以下方式建模

00:03:02.480 --> 00:03:06.020
状态机，然后可以是

00:03:03.710 --> 00:03:09.010
翻译成代码状态机给

00:03:06.020 --> 00:03:12.020
我们也是一种描述状态的方式

00:03:09.010 --> 00:03:13.730
长期运行的过程，所以如果您

00:03:12.020 --> 00:03:16.010
具有长期运行的过程

00:03:13.730 --> 00:03:17.450
运动部件，这可能非常有用

00:03:16.010 --> 00:03:19.820
能够看一些东西然后说哦

00:03:17.450 --> 00:03:21.410
我们在哪里取得进展

00:03:19.820 --> 00:03:23.360
这个过程，如果有的话

00:03:21.410 --> 00:03:25.490
该过程中的步骤应该失败，我们可以

00:03:23.360 --> 00:03:26.780
我们可以看看状态

00:03:25.490 --> 00:03:28.370
机器说好，我们应该恢复

00:03:26.780 --> 00:03:30.470
从这里开始，我们执行

00:03:28.370 --> 00:03:33.590
五种状态机受益

00:03:30.470 --> 00:03:36.260
可以查询

00:03:33.590 --> 00:03:38.780
他们可以问他们我们在哪里

00:03:36.260 --> 00:03:40.790
在此履行流程中知道

00:03:38.780 --> 00:03:43.190
例子假设我正在执行订单

00:03:40.790 --> 00:03:45.800
或类似的东西，我们有一个

00:03:43.190 --> 00:03:50.030
这样做涉及的步骤数

00:03:45.800 --> 00:03:52.550
来自人和安东·米斯（Anton Mis）演员

00:03:50.030 --> 00:03:54.140
可以戳国家

00:03:52.550 --> 00:03:56.150
机器，走吧，我们在前进

00:03:54.140 --> 00:03:58.730
两个接下来会发生什么，好的，这是步骤

00:03:56.150 --> 00:04:00.380
三个等等非常有用，所以

00:03:58.730 --> 00:04:02.650
状态机给我们很多

00:04:00.380 --> 00:04:04.670
好处是它们很方便

00:04:02.650 --> 00:04:06.470
技术之间的观念互换

00:04:04.670 --> 00:04:08.300
和商务上他们很方便，因为

00:04:06.470 --> 00:04:10.209
他们给我们提供了一种方式来跟踪

00:04:08.300 --> 00:04:12.709
某种工作的进展

00:04:10.209 --> 00:04:14.450
在分布式环境中特别有用

00:04:12.709 --> 00:04:16.340
系统场景中，我们有可能

00:04:14.450 --> 00:04:17.870
很多动作部分，很多演员

00:04:16.340 --> 00:04:19.640
系统，您希望能够

00:04:17.870 --> 00:04:23.419
了解并跟踪其进度

00:04:19.640 --> 00:04:26.510
他们或他们的活动如此陈述

00:04:23.419 --> 00:04:28.460
机器从根本上讲非常简单

00:04:26.510 --> 00:04:29.930
如果您将这个想法更进一步的话

00:04:28.460 --> 00:04:33.980
如果您有这个想法想要

00:04:29.930 --> 00:04:36.410
摆脱国家或

00:04:33.980 --> 00:04:39.860
从一个国家到另一个国家的运动

00:04:36.410 --> 00:04:41.090
你知道高阶构造你

00:04:39.860 --> 00:04:43.190
看到很多不同的选择

00:04:41.090 --> 00:04:46.040
他们中的很多人往往非常公平

00:04:43.190 --> 00:04:46.940
繁重的工作流引擎，为您处理

00:04:46.040 --> 00:04:48.919
了解业务流程管理

00:04:46.940 --> 00:04:52.300
解决方案和

00:04:48.919 --> 00:04:55.599
我认为这将是一个很好的主题

00:04:52.300 --> 00:04:59.270
我肯定是另一期

00:04:55.599 --> 00:05:01.939
我已经做过讲座和文章等等

00:04:59.270 --> 00:05:04.240
例如活动和 Spring 

00:05:01.939 --> 00:05:06.919
活动是工作流引擎中的BPM 

00:05:04.240 --> 00:05:11.030
可以与Spring Boot一起使用

00:05:06.919 --> 00:05:14.000
这些天实际上活动有一些

00:05:11.030 --> 00:05:17.569
叉子，所以在公社上有叉子

00:05:14.000 --> 00:05:19.310
其中有一家名为global的新公司

00:05:17.569 --> 00:05:20.870
基于活动，所以有一个

00:05:19.310 --> 00:05:22.490
很多有趣的肥沃的

00:05:20.870 --> 00:05:26.029
研究只是在那一个

00:05:22.490 --> 00:05:27.080
 bpmn的特定角

00:05:26.029 --> 00:05:28.550
宇宙，更不用说所有

00:05:27.080 --> 00:05:30.110
其他实现方式

00:05:28.550 --> 00:05:31.490
当然有很多我们可以

00:05:30.110 --> 00:05:32.960
在其他部分谈论

00:05:31.490 --> 00:05:34.789
今天我想集中精力

00:05:32.960 --> 00:05:36.770
重量项目称为Spring 状态

00:05:34.789 --> 00:05:39.439
机器，它给你非常简单

00:05:36.770 --> 00:05:42.620
 DSL，用于描述状态机

00:05:39.439 --> 00:05:44.569
它在里面，你可以做些事情

00:05:42.620 --> 00:05:48.409
像坚持状态一样

00:05:44.569 --> 00:05:50.779
机器，如果你想你可以描述

00:05:48.409 --> 00:05:52.789
复杂的等级进展和

00:05:50.779 --> 00:05:54.110
你知道过渡，如果你想，但所有

00:05:52.789 --> 00:05:55.969
这些东西你必须增加额外的权利

00:05:54.110 --> 00:05:57.889
默认情况下，它们只是一个DSL 

00:05:55.969 --> 00:05:59.289
描述状态及其状态

00:05:57.889 --> 00:06:01.479
进展以及哪些事件可以

00:05:59.289 --> 00:06:04.339
无法激活这些过渡，因此

00:06:01.479 --> 00:06:06.259
我们将继续建立一个

00:06:04.339 --> 00:06:09.639
今天和这里的全新项目

00:06:06.259 --> 00:06:12.800
正常的地方在这里，所以我想看看

00:06:09.639 --> 00:06:15.110
好吧，开始穿线I / O会建立一个

00:06:12.800 --> 00:06:17.779
我要叫这个应用程序

00:06:15.110 --> 00:06:19.729
服务很好，当我们不需要时

00:06:17.779 --> 00:06:22.069
除了网路以外，这里的一切

00:06:19.729 --> 00:06:24.250
支持，让我们继续前进，好吧，我

00:06:22.069 --> 00:06:26.120
意思是我不确定我们是否需要

00:06:24.250 --> 00:06:29.449
是的，我们不需要它

00:06:26.120 --> 00:06:35.060
让我们离开，所以我们将建立一个

00:06:29.449 --> 00:06:37.370
在这里申请并点击产生您

00:06:35.060 --> 00:06:41.379
知道我确实想要一些我想要JDBC的东西

00:06:37.370 --> 00:06:45.949
我想要JP，而不想要h2，所以让我

00:06:41.379 --> 00:06:50.229
杀死错误下载的版本

00:06:45.949 --> 00:06:53.060
那里好，那么JDBC JPA是什么

00:06:50.229 --> 00:06:55.879
我认为那会继续

00:06:53.060 --> 00:06:57.819
龙目岛当然很好，所以现在

00:06:55.879 --> 00:07:00.020
注意，现在没有

00:06:57.819 --> 00:07:02.029
复选框，我认为这将会改变

00:07:00.020 --> 00:07:02.569
很快，如果不是全部的话

00:07:02.029 --> 00:07:04.399
当然添加

00:07:02.569 --> 00:07:05.719
但与此同时，我们只需要

00:07:04.399 --> 00:07:07.159
自己添加它只是一个小

00:07:05.719 --> 00:07:08.929
依赖性不是很大

00:07:07.159 --> 00:07:10.279
神性不是一个整体

00:07:08.929 --> 00:07:12.949
项目生态系统只是其中之一

00:07:10.279 --> 00:07:14.449
图书馆一个项目，而不是谁和小

00:07:12.949 --> 00:07:15.919
有一些有趣的项目

00:07:14.449 --> 00:07:17.839
您可以使用任何模块

00:07:15.919 --> 00:07:22.189
还是不写我碰巧喜欢我

00:07:17.839 --> 00:07:23.689
希望我觉得很适合你

00:07:22.189 --> 00:07:26.029
知道空间有一个真的

00:07:23.689 --> 00:07:28.490
描述复杂的好空间

00:07:26.029 --> 00:07:29.899
过渡和调和

00:07:28.490 --> 00:07:32.479
这些过渡（如果您曾经使用过） 

00:07:29.899 --> 00:07:34.520
传奇模式对，这就是传奇

00:07:32.479 --> 00:07:36.589
模式要求你有一个传奇

00:07:34.520 --> 00:07:38.119
执行协调员，您可以建模

00:07:36.589 --> 00:07:40.099
用Spring Statemachine

00:07:38.119 --> 00:07:44.389
例子saga saga模式很棒

00:07:40.099 --> 00:07:47.180
建立共识的方式

00:07:44.389 --> 00:07:49.339
跨多个您知道的工作负载

00:07:47.180 --> 00:07:52.550
跨多个工作单元

00:07:49.339 --> 00:07:54.709
分布式系统或发布在

00:07:52.550 --> 00:07:56.300
长期运行的单节点事务

00:07:54.709 --> 00:07:57.949
这是一个很好的例子，你可以

00:07:56.300 --> 00:08:00.619
用Spring Statemachine来实现

00:07:57.949 --> 00:08:02.449
您可以为更复杂的业务建模

00:08:00.619 --> 00:08:04.580
需要某种形式的过程

00:08:02.449 --> 00:08:05.779
代表与实际分开

00:08:04.580 --> 00:08:08.149
实现，您可以使用

00:08:05.779 --> 00:08:09.559
Spring Statemachine也可以

00:08:08.149 --> 00:08:11.479
假设我们有一个非常简单的

00:08:09.559 --> 00:08:14.300
订购服务还可以，所以我们先

00:08:11.479 --> 00:08:15.529
现在在这里添加我们的依赖项

00:08:14.300 --> 00:08:17.330
字体有点太小了，让我

00:08:15.529 --> 00:08:21.860
使字体变大一点

00:08:17.330 --> 00:08:23.379
好的22好，我们要去了

00:08:21.860 --> 00:08:27.559
提前添加Spring StatemachineI 

00:08:23.379 --> 00:08:31.699
为了我自己的目的在这里保留了

00:08:27.559 --> 00:08:39.919
我不会添加的依赖

00:08:31.699 --> 00:08:41.419
在这里一二三一

00:08:39.919 --> 00:08:42.800
二三是Spring Statemachine

00:08:41.419 --> 00:08:44.180
那是我们要去的版本

00:08:42.800 --> 00:08:45.670
使用，因此我们可以创建新服务

00:08:44.180 --> 00:08:48.170
现在在我们这样做之前

00:08:45.670 --> 00:08:49.880
配置状态机本身

00:08:48.170 --> 00:08:51.139
所以我们要做的第一件事是

00:08:49.880 --> 00:08:56.380
创建我们要去的配置类

00:08:51.139 --> 00:09:01.149
说一个简单的枚举状态机

00:08:56.380 --> 00:09:01.149
配置扩展状态机

00:09:01.209 --> 00:09:06.500
配置适配器的权利以及我们

00:09:04.610 --> 00:09:09.230
我们要做的是为国家建模

00:09:06.500 --> 00:09:11.269
具有众所周知状态的机器

00:09:09.230 --> 00:09:12.740
我们产生了两个众所周知的事件

00:09:11.269 --> 00:09:16.550
会成为平常的事情

00:09:12.740 --> 00:09:17.720
这很多，所以你需要的状态

00:09:16.550 --> 00:09:18.830
你知道你可以做到，你可以描述

00:09:17.720 --> 00:09:20.930
根据那些字符串的状态

00:09:18.830 --> 00:09:22.040
或者你可以用你自己来形容

00:09:20.930 --> 00:09:25.459
知道我认为这实际上是很多

00:09:22.040 --> 00:09:26.720
这里有更多可口的选择

00:09:25.459 --> 00:09:28.940
因为它给你一个很好的类型安全

00:09:26.720 --> 00:09:34.519
这样描述已知状态的方式

00:09:28.940 --> 00:09:36.440
枚举顺序状态，我们要说

00:09:34.519 --> 00:09:37.670
有人做某事的时候

00:09:36.440 --> 00:09:40.459
某种泰勒上的命令

00:09:37.670 --> 00:09:42.430
网站上将收到他们的订单

00:09:40.459 --> 00:09:45.980
提交，所以我要说提交和

00:09:42.430 --> 00:09:47.899
有偿，还有什么我想

00:09:45.980 --> 00:09:49.880
那就是你认识的人拿走

00:09:47.899 --> 00:09:52.720
订单放进盒子，盖上邮票

00:09:49.880 --> 00:09:54.890
它发出它或取消它，所以

00:09:52.720 --> 00:09:56.120
无论出于何种原因，您都可以取消

00:09:54.890 --> 00:09:58.760
订单，我们可能会更复杂

00:09:56.120 --> 00:10:00.050
何时进行商业笑护

00:09:58.760 --> 00:10:01.700
有人可以取消它，但是

00:10:00.050 --> 00:10:03.740
现在就说您可以

00:10:01.700 --> 00:10:05.450
随时取消它，然后有

00:10:03.740 --> 00:10:07.370
事件触发的知名事件

00:10:05.450 --> 00:10:09.860
这些状态会发生变化，例如

00:10:07.370 --> 00:10:12.589
有人发送付款事件，然后

00:10:09.860 --> 00:10:15.050
正确地进入有偿状态

00:10:12.589 --> 00:10:17.630
当有人发送履行

00:10:15.050 --> 00:10:19.910
事件进入完成状态

00:10:17.630 --> 00:10:22.420
当然，当有人发送取消消息时

00:10:19.910 --> 00:10:24.740
事件进入取消状态，因此

00:10:22.420 --> 00:10:26.329
现在我们要做的是说

00:10:24.740 --> 00:10:27.520
我们要建立一个状态机

00:10:26.329 --> 00:10:30.050
这些订单状态

00:10:27.520 --> 00:10:33.760
好吧，这是一个国家，首先

00:10:30.050 --> 00:10:36.560
那么事件是第二个轨道事件

00:10:33.760 --> 00:10:39.950
好了，这是一个配置

00:10:36.560 --> 00:10:43.480
类，我们想使用at enable 

00:10:39.950 --> 00:10:45.709
状态机工厂对，这是

00:10:43.480 --> 00:10:47.750
这是指能力

00:10:45.709 --> 00:10:51.709
Spring Statemachine要么保留一个

00:10:47.750 --> 00:10:54.040
一种或两种全局状态机

00:10:51.709 --> 00:10:56.360
出售状态机的新实例

00:10:54.040 --> 00:10:58.250
出于您的目的，我想

00:10:56.360 --> 00:11:00.470
实际上是不同的情况，所以我

00:10:58.250 --> 00:11:01.640
现在要在这里使用工厂机制

00:11:00.470 --> 00:11:03.440
据我了解，该系统

00:11:01.640 --> 00:11:05.240
实际上，您可以使用

00:11:03.440 --> 00:11:07.100
没有状态的Spring State Machine项目

00:11:05.240 --> 00:11:08.750
 Spring 吧，我正在用一点

00:11:07.100 --> 00:11:09.860
 Spring ，因为我认为它适合那里，但是

00:11:08.750 --> 00:11:11.270
它是如此简单

00:11:09.860 --> 00:11:14.420
从根本上来说，只有一个

00:11:11.270 --> 00:11:18.079
您可以使用的构建器DSL，但我认为

00:11:14.420 --> 00:11:19.640
可以按原样使用它，所以

00:11:18.079 --> 00:11:24.019
我们要做的第一件事实际上

00:11:19.640 --> 00:11:28.470
我们要做两件事

00:11:24.019 --> 00:11:33.000
首先，我们需要配置

00:11:28.470 --> 00:11:37.350
引擎本身正确，因此

00:11:33.000 --> 00:11:41.879
覆盖配置让我们看看状态

00:11:37.350 --> 00:11:45.000
机器配置configure是

00:11:41.879 --> 00:11:48.389
引擎本身，在这里我们要说

00:11:45.000 --> 00:11:49.769
配置点我想改变

00:11:48.389 --> 00:11:52.170
配置，我们将启动它

00:11:49.769 --> 00:11:54.269
自动将其设置为false，然后

00:11:52.170 --> 00:11:55.319
我们要指定一个监听器， 

00:11:54.269 --> 00:11:57.180
实际上我们可以不需要

00:11:55.319 --> 00:12:00.899
现在，但我们可以提供一个状态

00:11:57.180 --> 00:12:04.019
机器监听器正确，所以在这里

00:12:00.899 --> 00:12:06.240
有一些我们可以使用的东西

00:12:04.019 --> 00:12:11.970
侦听器中的状态机，让我们看看

00:12:06.240 --> 00:12:14.670
这是一个订单状态订单事件，我们

00:12:11.970 --> 00:12:16.050
覆盖这些接口中的任何一个

00:12:14.670 --> 00:12:18.000
方法正确，所以我有一个

00:12:16.050 --> 00:12:20.639
适配器在这里，但如果我要覆盖

00:12:18.000 --> 00:12:22.410
正确的界面我会得到一些

00:12:20.639 --> 00:12:23.790
不同的回调方法是

00:12:22.410 --> 00:12:28.980
有点有趣，你知道我

00:12:23.790 --> 00:12:32.310
认为是国家改变方法，所以

00:12:28.980 --> 00:12:36.319
状态已更改，已进入或已退出

00:12:32.310 --> 00:12:39.180
因此，这使我们能够看到他们

00:12:36.319 --> 00:12:40.649
当状态去的时候一致

00:12:39.180 --> 00:12:41.970
机器已经从一种状态变为

00:12:40.649 --> 00:12:44.430
另一个，让我们实际提取

00:12:41.970 --> 00:12:46.290
在那里进入一个单独的班级，我们

00:12:44.430 --> 00:12:48.449
实际上可以存储我们不拥有的权利

00:12:46.290 --> 00:12:49.620
必须保持这个实际上我们很好

00:12:48.449 --> 00:12:51.350
可以呀，我们走了，所以走了

00:12:49.620 --> 00:12:54.990
那是我的，我的适配器很简单

00:12:51.350 --> 00:12:57.060
这些都是没有应用程序就没有操作

00:12:54.990 --> 00:12:58.410
基于接口的方法，因此您可以

00:12:57.060 --> 00:12:59.550
无论你想要什么，我都会

00:12:58.410 --> 00:13:00.899
我要做的是记录下来，我已经

00:12:59.550 --> 00:13:03.899
龙目岛在上课之路，所以我要

00:13:00.899 --> 00:13:07.790
在日志中使用以生成记录器，我将

00:13:03.899 --> 00:13:12.839
只是登录我会说日志信息状态已更改

00:13:07.790 --> 00:13:16.279
而来自将是某种东西，我们将

00:13:12.839 --> 00:13:19.889
一会儿再说两个

00:13:16.279 --> 00:13:26.610
会是其他的东西，然后这样

00:13:19.889 --> 00:13:29.490
让我们看看字符串点格式，我

00:13:26.610 --> 00:13:35.360
要说点到字符串或实际上

00:13:29.490 --> 00:13:37.949
让我们从加好开始，然后再到加

00:13:35.360 --> 00:13:41.850
好吧，有一个简单的监听器

00:13:37.949 --> 00:13:43.290
这其实很漂亮，你知道你

00:13:41.850 --> 00:13:44.880
我们不需要先这样做，但是

00:13:43.290 --> 00:13:46.170
一直很高兴我喜欢

00:13:44.880 --> 00:13:48.329
我们正在使用我们不想的工厂

00:13:46.170 --> 00:13:49.889
启动一个你知道的状态机

00:13:48.329 --> 00:13:52.050
启动应用程序时是全局的

00:13:49.889 --> 00:13:54.000
好吧，我们将立即禁用它

00:13:52.050 --> 00:13:56.339
现在第一件事我们想要的下一件事

00:13:54.000 --> 00:13:59.130
要覆盖的是状态机

00:13:56.339 --> 00:14:01.019
状态机陈述自己

00:13:59.130 --> 00:14:03.060
对，所以我们需要实际告诉

00:14:01.019 --> 00:14:04.259
关于不同状态的状态机

00:14:03.060 --> 00:14:09.420
我们使用状态机状态

00:14:04.259 --> 00:14:13.259
配置，我们会说点与

00:14:09.420 --> 00:14:18.480
最初的国家点，所以我们要去

00:14:13.259 --> 00:14:20.459
要做的是我们将提供aaaa 

00:14:18.480 --> 00:14:27.060
我们试图描述的有向图

00:14:20.459 --> 00:14:29.670
你会知道哪些状态

00:14:27.060 --> 00:14:31.310
状态是一种起源

00:14:29.670 --> 00:14:35.509
状态机是

00:14:31.310 --> 00:14:37.589
终止，哪些是终止

00:14:35.509 --> 00:14:39.360
正确的进展

00:14:37.589 --> 00:14:41.790
可以保持或维持的状态

00:14:39.360 --> 00:14:43.500
无论如何，我们可以做复杂的事情

00:14:41.790 --> 00:14:45.990
在这里我们可以进行拆分和合并

00:14:43.500 --> 00:14:48.480
而且您知道我们可以描述自定义

00:14:45.990 --> 00:14:49.439
事情在这里，但出于我们的目的，我们只是

00:14:48.480 --> 00:14:50.069
想描述哪个是

00:14:49.439 --> 00:14:52.920
最初的

00:14:50.069 --> 00:14:55.319
所以最初将是

00:14:52.920 --> 00:14:59.189
提交权利，因此必须订购

00:14:55.319 --> 00:15:00.480
机器或订单状态而不是提交

00:14:59.189 --> 00:15:01.560
那就是那第一个状态

00:15:00.480 --> 00:15:03.209
我们的状态机将在

00:15:01.560 --> 00:15:03.990
启动，我们将有另一个状态

00:15:03.209 --> 00:15:07.589
叫

00:15:03.990 --> 00:15:11.220
订购订单各国已付款然后有

00:15:07.589 --> 00:15:15.480
是两个终端，一个叫做

00:15:11.220 --> 00:15:18.540
命令各国履行了义务

00:15:15.480 --> 00:15:21.149
被称为订单状态点已全部取消

00:15:18.540 --> 00:15:24.569
对，所以有两个两个不同

00:15:21.149 --> 00:15:26.430
可以完成的状态

00:15:24.569 --> 00:15:28.620
工作流程，这样我们就可以正确结束

00:15:26.430 --> 00:15:30.029
尚未履行，或者我们可以取消权利

00:15:28.620 --> 00:15:32.610
这些都是最终条件

00:15:30.029 --> 00:15:34.259
如果我们完成状态机的工作流程

00:15:32.610 --> 00:15:36.319
可以进入任何一个州

00:15:34.259 --> 00:15:39.209
现在最后我们需要实际描述

00:15:36.319 --> 00:15:40.170
从一种状态到

00:15:39.209 --> 00:15:43.790
另一个在这里

00:15:40.170 --> 00:15:47.430
我们将使用状态机转换

00:15:43.790 --> 00:15:49.860
正确配置，让我们看看这是

00:15:47.430 --> 00:15:53.250
这个这里和这里

00:15:49.860 --> 00:15:54.809
当我说过渡时，这里是点

00:15:53.250 --> 00:15:55.260
你会看到有很多不同

00:15:54.809 --> 00:15:56.550
类型

00:15:55.260 --> 00:15:59.750
过渡的权利有很多不同

00:15:56.550 --> 00:16:04.170
有很多不同的方式

00:15:59.750 --> 00:16:07.590
要触发或激活的转换

00:16:04.170 --> 00:16:08.840
还有很多不同种类的

00:16:07.590 --> 00:16:10.770
 [音乐] 

00:16:08.840 --> 00:16:13.200
过渡自己和事物

00:16:10.770 --> 00:16:14.510
你实际上可以和他们在一起，所以如果你

00:16:13.200 --> 00:16:17.010
例如有一个状态机

00:16:14.510 --> 00:16:19.320
刚开始，它从头开始

00:16:17.010 --> 00:16:20.400
如果你从a知道a到a到z 

00:16:19.320 --> 00:16:22.470
然后是B然后是C然后是D 

00:16:20.400 --> 00:16:25.310
直接进行，完全无需干预

00:16:22.470 --> 00:16:27.420
完全被称为本地

00:16:25.310 --> 00:16:30.600
您可以说的过渡权

00:16:27.420 --> 00:16:34.260
本地来源，来源将是

00:16:30.600 --> 00:16:36.750
例如说订单状态点

00:16:34.260 --> 00:16:42.740
提交点，然后目标

00:16:36.750 --> 00:16:45.300
被命令说我们安全吗

00:16:42.740 --> 00:16:46.830
是的，是的，所以会

00:16:45.300 --> 00:16:48.630
如果我们要创建一个状态机

00:16:46.830 --> 00:16:50.250
这样它会启动它会

00:16:48.630 --> 00:16:52.290
从直接提交到实现，以及

00:16:50.250 --> 00:16:53.670
只要尽快

00:16:52.290 --> 00:16:55.020
该程序启动它将继续

00:16:53.670 --> 00:16:57.900
这样做没什么用

00:16:55.020 --> 00:17:00.870
通常你想知道，除非你

00:16:57.900 --> 00:17:02.910
想要自动推进令牌

00:17:00.870 --> 00:17:03.900
你知道代表或他们的令牌

00:17:02.910 --> 00:17:05.640
代表您想要的每个州

00:17:03.900 --> 00:17:07.260
自动将其前进到下一个

00:17:05.640 --> 00:17:09.329
说明应用程序何时启动或

00:17:07.260 --> 00:17:10.620
基于它进入了什么

00:17:09.329 --> 00:17:13.290
其他状态则可能有用

00:17:10.620 --> 00:17:14.699
但就我们而言，我们可以知道

00:17:13.290 --> 00:17:16.620
我们的状态机只在

00:17:14.699 --> 00:17:18.630
到目前为止对某种事件的反应

00:17:16.620 --> 00:17:23.220
更常见的是，我发现

00:17:18.630 --> 00:17:25.199
外在的，所以外在给你

00:17:23.220 --> 00:17:27.329
 DSL中的三个选项让您

00:17:25.199 --> 00:17:30.840
指定来源，因此一个来源是

00:17:27.329 --> 00:17:34.800
提交权利，目标正在

00:17:30.840 --> 00:17:37.440
得到报酬，然后

00:17:34.800 --> 00:17:42.090
可以触发过渡就是报酬

00:17:37.440 --> 00:17:43.800
好吧，那是你所知道的

00:17:42.090 --> 00:17:46.410
我们关心的状态转换

00:17:43.800 --> 00:17:53.450
另一个是，在这里我们要说

00:17:46.410 --> 00:17:56.160
源或带有外部第一个点的点

00:17:53.450 --> 00:17:58.790
让我们来看看保持这个小清洁剂吧

00:17:56.160 --> 00:18:06.220
像那样尝试吧，我们去了这么多源

00:17:58.790 --> 00:18:12.830
已达成付费目标

00:18:06.220 --> 00:18:15.619
事件在那里实现，我们

00:18:12.830 --> 00:18:17.269
去那你就知道另一个

00:18:15.619 --> 00:18:19.639
进展，所以它会从

00:18:17.269 --> 00:18:21.710
随行并付清

00:18:19.639 --> 00:18:24.259
然后从那里到付费

00:18:21.710 --> 00:18:30.159
满足事件的完成

00:18:24.259 --> 00:18:36.139
其他要与外部对不起

00:18:30.159 --> 00:18:40.009
具有外部源订单状态

00:18:36.139 --> 00:18:42.799
提交取消，因此能够

00:18:40.009 --> 00:18:45.590
支持取消，并在任何时候

00:18:42.799 --> 00:18:51.320
权利因此被取消，基于已取消

00:18:45.590 --> 00:18:56.409
活动取消好了，我们要

00:18:51.320 --> 00:18:59.929
在这里再次复制

00:18:56.409 --> 00:19:01.359
支付给您，知道它是否在页面日期中

00:18:59.929 --> 00:19:02.570
当我也可以取消它时

00:19:01.359 --> 00:19:04.309
这里

00:19:02.570 --> 00:19:09.769
支付基于取消的取消

00:19:04.309 --> 00:19:11.419
事件，最后我想取消它

00:19:09.769 --> 00:19:15.980
如果它处于完成状态，那么

00:19:11.419 --> 00:19:19.489
与外部的来源实现了

00:19:15.980 --> 00:19:22.820
目标将被取消，然后发生事件

00:19:19.489 --> 00:19:25.009
将会被取消，我们在那里

00:19:22.820 --> 00:19:27.769
所以有很多不同的状态

00:19:25.009 --> 00:19:31.220
在这里，这是从你知道的

00:19:27.769 --> 00:19:32.779
提交到已付

00:19:31.220 --> 00:19:34.220
当然，这是我们的最后一项权利

00:19:32.779 --> 00:19:37.489
这就是我们的成功

00:19:34.220 --> 00:19:39.109
完成工作流程或状态机

00:19:37.489 --> 00:19:41.509
也已经提交取消我们有

00:19:39.109 --> 00:19:43.609
支付给取消并履行

00:19:41.509 --> 00:19:45.049
取消，然后有人可能会说

00:19:43.609 --> 00:19:46.100
这不是很有用，所以也许我们会

00:19:45.049 --> 00:19:46.399
实际上摆脱了那个权利吧

00:19:46.100 --> 00:19:47.749
不

00:19:46.399 --> 00:19:49.009
我不确定那是不是全部

00:19:47.749 --> 00:19:52.100
这么多用所有有用的

00:19:49.009 --> 00:19:53.269
他们都是终端国家，但是很好

00:19:52.100 --> 00:19:56.960
我们去那里我们那里我们那里

00:19:53.269 --> 00:19:59.440
国家，那是我们的权利

00:19:56.960 --> 00:20:03.590
我们已经配置了一个状态机

00:19:59.440 --> 00:20:05.570
你知道这是很多配置，但是

00:20:03.590 --> 00:20:07.059
您会得到一个有效的结果，所以让我们

00:20:05.570 --> 00:20:11.690
实际尝试一下，让我们实际使用

00:20:07.059 --> 00:20:14.539
状态机，只有你知道

00:20:11.690 --> 00:20:18.590
推进它，让我们使用它来

00:20:14.539 --> 00:20:19.210
移动数据以移动表示的令牌

00:20:18.590 --> 00:20:20.260
但

00:20:19.210 --> 00:20:21.610
从一个状态到另一状态的状态机

00:20:20.260 --> 00:20:23.559
所以我实际上要创建一个

00:20:21.610 --> 00:20:25.450
创建那个的命令行运行器

00:20:23.559 --> 00:20:28.210
管理状态机

00:20:25.450 --> 00:20:31.169
工厂，所以上课者实施

00:20:28.210 --> 00:20:35.549
应用程序运行程序，我们将注入

00:20:31.169 --> 00:20:42.880
私人最终状态机工厂

00:20:35.549 --> 00:20:44.850
订单状态订单事件工厂全部

00:20:42.880 --> 00:20:50.220
对

00:20:44.850 --> 00:20:59.049
输入那个好吧，看看那个

00:20:50.220 --> 00:21:05.500
所以这个点工厂点得到状态

00:20:59.049 --> 00:21:06.970
机器这东西工厂不明白

00:21:05.500 --> 00:21:10.299
状态机，实际上就是这样

00:21:06.970 --> 00:21:11.470
那就是我们拥有的结果

00:21:10.299 --> 00:21:12.850
状态机，我们有一个有效的新

00:21:11.470 --> 00:21:14.289
我们可以的状态机实例

00:21:12.850 --> 00:21:16.000
还为您提供一个唯一的ID 

00:21:14.289 --> 00:21:17.919
喜欢有多个实例，所以也许

00:21:16.000 --> 00:21:21.010
你有一个状态机，你知道

00:21:17.919 --> 00:21:22.779
特定订单号右订单75 

00:21:21.010 --> 00:21:23.649
随便你想要什么

00:21:22.779 --> 00:21:25.929
每当你想能够

00:21:23.649 --> 00:21:27.190
相关或能够知道

00:21:25.929 --> 00:21:29.500
将状态机关联到

00:21:27.190 --> 00:21:30.490
无论你处于何种外部状态

00:21:29.500 --> 00:21:32.080
让我们看看实际上发生了什么

00:21:30.490 --> 00:21:35.409
它让我们与此互动

00:21:32.080 --> 00:21:37.500
机器点开始正确，所以说出来

00:21:35.409 --> 00:21:39.820
开始，然后我们说一个机器点

00:21:37.500 --> 00:21:42.659
取得状态，这会给我们

00:21:39.820 --> 00:21:45.250
当前状态，我们将获得ID 

00:21:42.659 --> 00:21:47.679
然后这个名字好吧，让我们

00:21:45.250 --> 00:21:51.100
打印出来实际上是一个日志

00:21:47.679 --> 00:21:57.730
出来，当它是一个帽子日志，我们会去

00:21:51.100 --> 00:22:04.470
这里的日志信息当前状态是

00:21:57.730 --> 00:22:04.470
好的运行代码

00:22:11.570 --> 00:22:19.879
好吧，我们得到了什么，所以状态

00:22:18.320 --> 00:22:21.559
改变了，我们看到了听众的状态

00:22:19.879 --> 00:22:24.080
从Noll改变了，所以你知道

00:22:21.559 --> 00:22:25.850
第一个反对提交的州

00:22:24.080 --> 00:22:27.649
挖掘它，以便它在第一次启动时

00:22:25.850 --> 00:22:30.799
它会自动转到初始

00:22:27.649 --> 00:22:32.809
提交的状态，我们可以看到

00:22:30.799 --> 00:22:34.369
机器实际上已经启动，所以

00:22:32.809 --> 00:22:35.659
这些是不同的状态

00:22:34.369 --> 00:22:38.629
当前状态是这里提交的

00:22:35.659 --> 00:22:42.139
它的UUID，并且您是随机的

00:22:38.629 --> 00:22:44.029
知道我们给它的ID，我们将其打印出来

00:22:42.139 --> 00:22:45.979
它说提交的当前状态

00:22:44.029 --> 00:22:47.299
对，就是他们编程

00:22:45.979 --> 00:22:49.190
在这一点上完成了，让我们

00:22:47.299 --> 00:22:52.759
现在继续前进，我们想说

00:22:49.190 --> 00:22:55.549
触发运动完成

00:22:52.759 --> 00:22:57.049
支付，所以现在我们可以发送事件我们

00:22:55.549 --> 00:22:59.210
可以通过几种不同的方式做到这一点

00:22:57.049 --> 00:23:02.210
说订单事件，然后传递

00:22:59.210 --> 00:23:06.649
事件顺序事件点之一

00:23:02.210 --> 00:23:10.070
实现那会给我们更多

00:23:06.649 --> 00:23:16.460
现在再把它放在那里

00:23:10.070 --> 00:23:20.119
我们将运行该应用程序，这样

00:23:16.460 --> 00:23:24.710
如果我们再看看这个当前状态

00:23:20.119 --> 00:23:27.529
提交哦，我做错了什么，我们说

00:23:24.710 --> 00:23:29.059
哦，它已经提交了，我们必须付钱

00:23:27.529 --> 00:23:30.889
看到我不能，那实际上是一件好事

00:23:29.059 --> 00:23:33.769
那是一个很好的演示，我不能从

00:23:30.889 --> 00:23:36.259
提交实现我必须去

00:23:33.769 --> 00:23:37.940
通过可预知的知名度

00:23:36.259 --> 00:23:40.129
声明这里正确，它不会让我

00:23:37.940 --> 00:23:41.509
进入无效状态，所以我不会

00:23:40.129 --> 00:23:43.429
能够做外面的事情

00:23:41.509 --> 00:23:45.320
状态机的设计

00:23:43.429 --> 00:23:47.419
这正是我们想要的权利

00:23:45.320 --> 00:23:48.259
可预测的确定性进展

00:23:47.419 --> 00:23:52.099
我们想知道这是不可能的

00:23:48.259 --> 00:23:53.960
偶然到达一个你也知道

00:23:52.099 --> 00:23:55.519
在处理过程中遥遥领先

00:23:53.960 --> 00:23:57.200
前提是所有

00:23:55.519 --> 00:24:00.139
以前的状态是

00:23:57.200 --> 00:24:02.919
满意，所以我们处于当前状态

00:24:00.139 --> 00:24:04.970
等于有偿权利，所以我们知道我们得到了

00:24:02.919 --> 00:24:06.739
这是第二次

00:24:04.970 --> 00:24:10.669
提交了第一个状态，然后

00:24:06.739 --> 00:24:13.429
它说现在付款，这就是发送

00:24:10.669 --> 00:24:15.320
另一个事件发送事件，这次

00:24:13.429 --> 00:24:16.999
而不是使用您知道的对象

00:24:15.320 --> 00:24:18.590
本身将使用

00:24:16.999 --> 00:24:20.570
 Spring Framework 消息生成器Spring 

00:24:18.590 --> 00:24:22.999
您知道Spring Framework 

00:24:20.570 --> 00:24:24.820
消息传递消息生成器，这是

00:24:22.999 --> 00:24:26.019
您用于的同一消息生成器

00:24:24.820 --> 00:24:27.880
带来相同的整合

00:24:26.019 --> 00:24:31.029
用于WebSocket支持和

00:24:27.880 --> 00:24:33.580
 Spring MVC是您知道的

00:24:31.029 --> 00:24:35.740
 JMS消息传递模板和JMS 

00:24:33.580 --> 00:24:37.570
以及mqp消息传递模板以及所有

00:24:35.740 --> 00:24:39.880
这些东西都使用相同的基本东西

00:24:37.570 --> 00:24:40.960
在这里，我要说有效载荷和

00:24:39.880 --> 00:24:43.389
我们要说什么，有效载荷是

00:24:40.960 --> 00:24:46.750
当然会成为一个事件命令事件

00:24:43.389 --> 00:24:49.419
点想要实现正确的呼声

00:24:46.750 --> 00:24:50.679
满足我要去建立那个

00:24:49.419 --> 00:24:53.049
之所以如此重要，是因为您

00:24:50.679 --> 00:24:55.570
实际上可以制造出我们拥有的理由

00:24:53.049 --> 00:24:58.840
第二个变体是因为您可以

00:24:55.570 --> 00:25:03.580
制作具有正确标题的邮件

00:24:58.840 --> 00:25:06.250
可以说将标头设置为a等于B 

00:25:03.580 --> 00:25:08.529
例子，就像我们在边框中看到的那样

00:25:06.250 --> 00:25:11.139
这些标题可能会在

00:25:08.529 --> 00:25:14.830
您的代码需要组件逻辑，因此

00:25:11.139 --> 00:25:20.909
让我们将其移至此处然后运行

00:25:14.830 --> 00:25:20.909
该应用程序，让我们看看放手

00:25:22.230 --> 00:25:27.370
很棒，所以我们可以看到最新的

00:25:24.879 --> 00:25:29.799
现在状态已经实现了，所以

00:25:27.370 --> 00:25:31.570
我们得到了充实的支持， 

00:25:29.799 --> 00:25:33.669
我们已经提交了报酬， 

00:25:31.570 --> 00:25:35.830
实现了预期的工作，我们

00:25:33.669 --> 00:25:36.789
可以与状态机进行交互

00:25:35.830 --> 00:25:39.580
任何时候

00:25:36.789 --> 00:25:41.110
我们得到了一种众所周知的东西

00:25:39.580 --> 00:25:43.870
众所周知的数量

00:25:41.110 --> 00:25:45.399
一切都很好

00:25:43.870 --> 00:25:48.250
当然，但是到了最后

00:25:45.399 --> 00:25:50.799
只是你知道这就是我们

00:25:48.250 --> 00:25:52.000
在内存中移动状态，我们不是

00:25:50.799 --> 00:25:53.769
根据它做正确的事

00:25:52.000 --> 00:25:55.090
我们实际上并没有对此采取行动，所以您

00:25:53.769 --> 00:25:57.220
有几个地方可以

00:25:55.090 --> 00:26:02.080
首先要做到这一点

00:25:57.220 --> 00:26:04.899
提供状态输入处理程序

00:26:02.080 --> 00:26:07.450
所以你可以说基于

00:26:04.899 --> 00:26:13.090
根据某人的命令说

00:26:07.450 --> 00:26:17.200
输入您拥有的提交状态

00:26:13.090 --> 00:26:21.269
处理程序，所以一个新动作看起来像那样

00:26:17.200 --> 00:26:23.980
对，所以你的工作是做某事

00:26:21.269 --> 00:26:26.919
反映出当时的状态

00:26:23.980 --> 00:26:28.750
也许你想写一条记录到

00:26:26.919 --> 00:26:30.669
数据库，也许你想发送一个

00:26:28.750 --> 00:26:32.129
通知或发送消息

00:26:30.669 --> 00:26:36.659
提示或您想要的任何东西

00:26:32.129 --> 00:26:41.679
输入已提交

00:26:36.659 --> 00:26:44.889
对，您可能会有新数据，但是

00:26:41.679 --> 00:26:47.499
您实际上可以拥有的数据是

00:26:44.889 --> 00:26:50.799
以此顺序编码，因此您可能会

00:26:47.499 --> 00:26:52.089
可能有来自

00:26:50.799 --> 00:26:53.830
我们之前谈到的消息

00:26:52.089 --> 00:26:56.619
实际上可以将其拉出此处，如果

00:26:53.830 --> 00:26:58.570
您想让上下文获得事件

00:26:56.619 --> 00:27:01.359
对，这是活动得到扩展

00:26:58.570 --> 00:27:06.369
声明您可以正确获取变量，因此

00:27:01.359 --> 00:27:10.019
如果我想获取或可以获取订单ID 

00:27:06.369 --> 00:27:16.089
默认值，所以说它是负数

00:27:10.019 --> 00:27:20.589
长单号，所以我现在是班级点

00:27:16.089 --> 00:27:22.779
我们在那里，所以这就是我

00:27:20.589 --> 00:27:26.049
提取负数或

00:27:22.779 --> 00:27:28.559
来自扩展状态的订单ID 

00:27:26.049 --> 00:27:31.509
和状态机，所以让我们实际

00:27:28.559 --> 00:27:34.179
让我们看看是否可以将其发送到

00:27:31.509 --> 00:27:35.709
启动之前的状态机

00:27:34.179 --> 00:27:40.329
对，所以我们进入状态

00:27:35.709 --> 00:27:45.609
机器订单ID是，它将写入

00:27:40.329 --> 00:27:46.749
退出订单ID好，现在我们必须

00:27:45.609 --> 00:27:49.809
实际发送的订单ID是

00:27:46.749 --> 00:27:50.799
使其正常工作的前提是

00:27:49.809 --> 00:27:52.659
失败了，它会炸成碎片

00:27:50.799 --> 00:27:56.440
如果我们没有那个

00:27:52.659 --> 00:27:59.190
订单ID，让我们回到我们的状态

00:27:56.440 --> 00:28:02.859
我们开始之前的机器

00:27:59.190 --> 00:28:06.219
扩展状态获取变量，如果

00:28:02.859 --> 00:28:09.399
缺少订单ID，我们实际上会说

00:28:06.219 --> 00:28:10.809
我实际上将其提取到

00:28:09.399 --> 00:28:15.549
稍后再分开值，所以我们会说长

00:28:10.809 --> 00:28:18.509
订单ID等于此，我们将其放入

00:28:15.549 --> 00:28:20.190
在这里，我们会说长串

00:28:18.509 --> 00:28:23.440
订单编号

00:28:20.190 --> 00:28:25.119
我将订单ID放在那里

00:28:23.440 --> 00:28:27.159
在我们启动之前把它放在那里

00:28:25.119 --> 00:28:28.959
我们启动

00:28:27.159 --> 00:28:31.619
状态机现在让我们再次运行它

00:28:28.959 --> 00:28:36.509
看看我们得到了什么

00:28:31.619 --> 00:28:36.509
好吧，如果我们去这里

00:28:38.410 --> 00:28:47.860
好的订单ID是1 3 2 3 2 

00:28:46.270 --> 00:28:49.630
期待正确并喝酒提交状态

00:28:47.860 --> 00:28:52.330
所以在这里我们有能力传播

00:28:49.630 --> 00:28:54.100
你知道要从一个国家延续下去

00:28:52.330 --> 00:28:56.650
图中的另一个节点和

00:28:54.100 --> 00:28:57.940
状态机这很方便

00:28:56.650 --> 00:28:59.950
你可以做各种各样的手或逻辑

00:28:57.940 --> 00:29:00.880
在那里，它可以处理逻辑

00:28:59.950 --> 00:29:02.620
在这里或者你可以打电话给另一个

00:29:00.880 --> 00:29:04.660
您可以调用其他功能的功能

00:29:02.620 --> 00:29:05.950
对，所以您实际上可以使用spring 

00:29:04.660 --> 00:29:07.330
集成在这里你可以使用spring 

00:29:05.950 --> 00:29:09.760
批处理您可以做任何您想做的事

00:29:07.330 --> 00:29:12.910
但您可以维持这种

00:29:09.760 --> 00:29:15.610
国家 Spring 的著名进展

00:29:12.910 --> 00:29:17.080
状态机是有用的

00:29:15.610 --> 00:29:19.510
就像我说的那样

00:29:17.080 --> 00:29:20.650
我认为在这些长期存在的情况下很有用

00:29:19.510 --> 00:29:24.130
分布式交易或

00:29:20.650 --> 00:29:25.780
您所知道的场景中的分布式工作人员

00:29:24.130 --> 00:29:28.360
我们有很多运动部件

00:29:25.780 --> 00:29:32.370
协调他们的状态好，所以这是

00:29:28.360 --> 00:29:34.810
您将如何提供自己的风俗习惯

00:29:32.370 --> 00:29:36.580
正确的行为，那就是

00:29:34.810 --> 00:29:41.410
那很方便

00:29:36.580 --> 00:29:43.240
我想你知道我们现在也看过

00:29:41.410 --> 00:29:45.040
如何启动实例的方式

00:29:43.240 --> 00:29:46.660
状态机以及如何激活

00:29:45.040 --> 00:29:47.710
让我们继续进行评论

00:29:46.660 --> 00:29:50.290
现在，让我们实际包装一个

00:29:47.710 --> 00:29:52.540
围绕这台机器的服务

00:29:50.290 --> 00:29:54.070
集为我们管理我们的实体并做到

00:29:52.540 --> 00:29:55.450
你知道的东西看起来很像

00:29:54.070 --> 00:29:58.600
编写了业务逻辑，所以我要去

00:29:55.450 --> 00:30:02.040
创建订单服务类将是

00:29:58.600 --> 00:30:05.560
订单服务类订单服务，以及

00:30:02.040 --> 00:30:09.490
我们将在这里使用JPA来描述订单

00:30:05.560 --> 00:30:13.600
所以在实体上的课程顺序

00:30:09.490 --> 00:30:14.860
有一个私人的长ID私人什么

00:30:13.600 --> 00:30:16.870
否则我们需要我猜很多吗

00:30:14.860 --> 00:30:20.700
该ID实际上就是我们真正需要的

00:30:16.870 --> 00:30:25.150
是不是这样，日期我们可以说是日期时间

00:30:20.700 --> 00:30:26.710
你知道每当工作是什么时候

00:30:25.150 --> 00:30:28.840
是什么时候下订单

00:30:26.710 --> 00:30:31.840
这就是我们需要ID的本质

00:30:28.840 --> 00:30:33.610
在产生价值的过程中，所以我们想要

00:30:31.840 --> 00:30:35.650
那当然是为了

00:30:33.610 --> 00:30:37.390
当你得到她一些二传手时会很有用

00:30:35.650 --> 00:30:39.970
所以我们将再次使用Lombok的所有参数

00:30:37.390 --> 00:30:42.010
数据构造函数

00:30:39.970 --> 00:30:43.840
得到你知道吸气剂的枪， 

00:30:42.010 --> 00:30:47.660
设置所有这些东西，所以这就是GPA 

00:30:43.840 --> 00:30:58.310
这些3a龙目岛对

00:30:47.660 --> 00:31:00.080
好吧，让我们看看好吧，我们有那样的方法

00:30:58.310 --> 00:31:02.350
我想我们现在需要一个存储库，所以

00:31:00.080 --> 00:31:06.980
让我们继续构建一个存储库

00:31:02.350 --> 00:31:09.350
接口订单存储库扩展了jpay 

00:31:06.980 --> 00:31:11.180
存储库管理实体是超级

00:31:09.350 --> 00:31:13.550
我要输入其伴侣案的订单

00:31:11.180 --> 00:31:15.140
很长时间，我们实际上不会在

00:31:13.550 --> 00:31:16.580
我们的服务，所以在我们的服务中

00:31:15.140 --> 00:31:20.930
将注入存储库为私有

00:31:16.580 --> 00:31:23.960
最终订单存储库和我们的服务

00:31:20.930 --> 00:31:25.850
将有几种不同的方法

00:31:23.960 --> 00:31:28.100
写一些，我觉得还不错

00:31:25.850 --> 00:31:29.210
显而易见，让我们看一下第一个

00:31:28.100 --> 00:31:32.270
这是我们实际上要执行的命令

00:31:29.210 --> 00:31:33.620
当有人给我们一个订单时创建一个订单

00:31:32.270 --> 00:31:35.000
日期，我想那是唯一的事情

00:31:33.620 --> 00:31:38.390
我们毕竟需要约会时间

00:31:35.000 --> 00:31:40.100
我们要说的是公共秩序

00:31:38.390 --> 00:31:42.050
可以命令它不是真的

00:31:40.100 --> 00:31:42.770
当我有一个新方法时，事关重大

00:31:42.050 --> 00:31:44.810
在这里订购

00:31:42.770 --> 00:31:46.940
所以给定一个，你知道我们可以称之为

00:31:44.810 --> 00:31:49.730
板条箱或其他我想可以去的东西

00:31:46.940 --> 00:31:52.580
我会说有人给我们一个

00:31:49.730 --> 00:31:55.340
我们要创建订单的日期

00:31:52.580 --> 00:32:00.260
我们可以说我们把这个命令

00:31:55.340 --> 00:32:05.240
存储库点保存新订单，并且

00:32:00.260 --> 00:32:07.610
第一个参数是我们不使用的ID 

00:32:05.240 --> 00:32:09.170
需要我们还应该有实际的

00:32:07.610 --> 00:32:10.970
实际状态不应该等待，为什么不

00:32:09.170 --> 00:32:12.550
秩序将从一个国家进步

00:32:10.970 --> 00:32:14.450
到另一个，所以我们要设法做到这一点

00:32:12.550 --> 00:32:16.550
让我们来看看

00:32:14.450 --> 00:32:19.490
我们如何保持我们想要的状态

00:32:16.550 --> 00:32:20.660
我们希望此订单转到

00:32:19.490 --> 00:32:23.030
众所周知的州，那些可以

00:32:20.660 --> 00:32:26.300
对应于州和

00:32:23.030 --> 00:32:29.810
状态机，所以我们将其存储为

00:32:26.300 --> 00:32:30.950
一个字符串，但我们实际上要创建

00:32:29.810 --> 00:32:33.620
我要创建的构造函数

00:32:30.950 --> 00:32:36.920
可以使用我们的枚举的构造函数

00:32:33.620 --> 00:32:41.930
值，所以我要说日期D然后

00:32:36.920 --> 00:32:46.250
订单状态OS，因此该日期

00:32:41.930 --> 00:32:51.230
时间等于D此点状态等于OS 

00:32:46.250 --> 00:32:52.640
可以的名字，所以这是字符串

00:32:51.230 --> 00:32:54.500
枚举的表示形式，这是一个

00:32:52.640 --> 00:32:55.880
 Java是不对的

00:32:54.500 --> 00:32:58.340
产生名字的能力

00:32:55.880 --> 00:33:00.600
基本上对应于

00:32:58.340 --> 00:33:04.080
您在单位单元格中看到的符号

00:33:00.600 --> 00:33:05.880
直到在我们的情况下，它将是一个

00:33:04.080 --> 00:33:07.860
你知道所有的事情都实现了

00:33:05.880 --> 00:33:10.470
好吧，也许我会公开

00:33:07.860 --> 00:33:11.700
好，这个主意当然会

00:33:10.470 --> 00:33:14.250
自动自动和评论和

00:33:11.700 --> 00:33:17.460
由JP为我们生成

00:33:14.250 --> 00:33:19.620
所以我们在这里使用这个新版本

00:33:17.460 --> 00:33:22.740
新的构造函数，订单状态将

00:33:19.620 --> 00:33:25.919
当然会实现或我开始

00:33:22.740 --> 00:33:27.779
提交权，我在欺骗

00:33:25.919 --> 00:33:30.299
那里我应该检查一下

00:33:27.779 --> 00:33:31.380
是一个状态机，但让我们假设我们

00:33:30.299 --> 00:33:33.210
已经知道我们可以接受

00:33:31.380 --> 00:33:35.190
开始时授予所有订单

00:33:33.210 --> 00:33:39.419
处于订单状态提交状态

00:33:35.190 --> 00:33:42.299
非常好，你知道我们甚至

00:33:39.419 --> 00:33:48.049
有一些吸气剂和二传手

00:33:42.299 --> 00:33:51.750
所以公共秩序状态得到秩序状态

00:33:48.049 --> 00:33:55.470
把这个点状状态我要说

00:33:51.750 --> 00:33:57.450
秩序表明权利的价值和我

00:33:55.470 --> 00:33:59.039
得到那个字符串，并使用它来到达

00:33:57.450 --> 00:34:03.750
在枚举中，我们将有一个

00:33:59.039 --> 00:34:07.440
编写者以及设置订单状态

00:34:03.750 --> 00:34:10.139
订单状态并将其写出

00:34:07.440 --> 00:34:12.690
这个点状态等于游戏说

00:34:10.139 --> 00:34:15.780
之前，我们甚至可以使用它

00:34:12.690 --> 00:34:24.389
此处的cetera设置了订单状态哦是

00:34:15.780 --> 00:34:25.560
很好，所以现在我们需要

00:34:24.389 --> 00:34:27.089
管理该状态，我们实际上需要

00:34:25.560 --> 00:34:28.980
管理状态机，让我们

00:34:27.089 --> 00:34:31.710
想象在跑步者中，我们实际上是

00:34:28.980 --> 00:34:33.169
会在这里打电话给那个订购服务

00:34:31.710 --> 00:34:37.260
所以我们去跑步吧

00:34:33.169 --> 00:34:38.760
跑步者在这里，我要移动我们的

00:34:37.260 --> 00:34:42.179
点餐服务更接近

00:34:38.760 --> 00:34:44.520
在靠近跑步者的地方工作，所以我们

00:34:42.179 --> 00:34:46.919
可以与

00:34:44.520 --> 00:34:48.300
有点轻松，好吧，我们在那里

00:34:46.919 --> 00:34:50.099
订单服务就在

00:34:48.300 --> 00:34:51.810
跑步者，我们将摆脱所有

00:34:50.099 --> 00:34:53.970
因为我们已经了解了什么

00:34:51.810 --> 00:34:54.990
在那里发生，我们要做到

00:34:53.970 --> 00:34:58.050
让一切都变得容易一些

00:34:54.990 --> 00:35:00.569
视线在这里，所以我要把它移到

00:34:58.050 --> 00:35:02.490
顶部，这样我们就可以来回平衡

00:35:00.569 --> 00:35:03.569
这个跑步者将是我们简单的小家伙

00:35:02.490 --> 00:35:06.480
测试，我们大概应该

00:35:03.569 --> 00:35:08.430
写一个测试，但让我们保持它

00:35:06.480 --> 00:35:11.760
相同的代码页在这里我们可以吗

00:35:08.430 --> 00:35:13.500
所以订单将是我要去的订单

00:35:11.760 --> 00:35:15.480
使用订单服务

00:35:13.500 --> 00:35:16.670
所以我们会说订购服务不会

00:35:15.480 --> 00:35:21.530
拒绝我们不再需要这个

00:35:16.670 --> 00:35:25.619
注入订单服务订单服务

00:35:21.530 --> 00:35:27.270
添加构造函数摆脱

00:35:25.619 --> 00:35:29.430
订单服务中的工厂

00:35:27.270 --> 00:35:31.550
为我们埋葬在订单服务中

00:35:29.430 --> 00:35:35.250
要说这个订单服务点

00:35:31.550 --> 00:35:40.890
创建新订单服务还可以

00:35:35.250 --> 00:35:46.590
所以这些现在是我们的订单

00:35:40.890 --> 00:35:48.570
我们想要更改订单的权利

00:35:46.590 --> 00:35:50.910
也许我们有不同的业务逻辑

00:35:48.570 --> 00:35:52.590
对的事情我们实际上可以请你

00:35:50.910 --> 00:35:54.570
知道有人点击按钮，然后

00:35:52.590 --> 00:35:57.359
是，但是我们要确保

00:35:54.570 --> 00:35:59.700
工作流移至已付款状态

00:35:57.359 --> 00:36:01.140
然后你知道的人也许他们

00:35:59.700 --> 00:36:02.160
也许他们已经填写了表格， 

00:36:01.140 --> 00:36:03.570
他们已经填写了信用卡

00:36:02.160 --> 00:36:04.950
信息，所以我想确保

00:36:03.570 --> 00:36:07.349
状态机反映出

00:36:04.950 --> 00:36:09.869
付了钱，最后你知道了

00:36:07.349 --> 00:36:13.050
一天后，标签被打印出来， 

00:36:09.869 --> 00:36:15.540
放在盒子上，现在订购

00:36:13.050 --> 00:36:17.070
履行了所有权利，所以我们要

00:36:15.540 --> 00:36:19.230
确保当他们单击该按钮时

00:36:17.070 --> 00:36:21.720
他们在仓库里的手机

00:36:19.230 --> 00:36:25.200
该命令也反映了该状态

00:36:21.720 --> 00:36:26.369
我们需要某种方式告诉他们你

00:36:25.200 --> 00:36:27.599
知道我们会想像一个数字

00:36:26.369 --> 00:36:29.250
我们将要去的不同方法

00:36:27.599 --> 00:36:32.339
向前并实施一种

00:36:29.250 --> 00:36:33.839
此处移动命令的综合方法

00:36:32.339 --> 00:36:37.380
从一个州到另一个州，但是你可以

00:36:33.839 --> 00:36:39.960
想像一下您拥有相同的基本逻辑

00:36:37.380 --> 00:36:41.070
知道在不同的位置重复使用

00:36:39.960 --> 00:36:42.119
您知道的功能与众不同

00:36:41.070 --> 00:36:46.830
知道这是一项支持服务

00:36:42.119 --> 00:36:48.540
不同的客户会交谈，所以让我们

00:36:46.830 --> 00:36:53.960
继续做下去，好吧

00:36:48.540 --> 00:36:58.339
这里的方法叫做change好的，所以改

00:36:53.960 --> 00:37:04.470
在我们的订单服务中

00:36:58.339 --> 00:37:06.060
 change方法将返回状态

00:37:04.470 --> 00:37:12.530
机器本身很好，所以我们想

00:37:06.060 --> 00:37:14.970
实际上有状态机本身

00:37:12.530 --> 00:37:18.119
但我认为，为了做到这一点，我们可以

00:37:14.970 --> 00:37:19.920
实际需要一种方法

00:37:18.119 --> 00:37:22.260
实际上是为

00:37:19.920 --> 00:37:23.790
给定顺序，让我们开始吧

00:37:22.260 --> 00:37:25.830
业务逻辑事物

00:37:23.790 --> 00:37:27.280
对象焦点的东西，这就是你

00:37:25.830 --> 00:37:34.810
知道她在乎这就是新兴市场

00:37:27.280 --> 00:37:37.180
就是这样，当我订购ID时， 

00:37:34.810 --> 00:37:40.120
将有一个订单事件参数

00:37:37.180 --> 00:37:41.760
在这里为了这个工作我们

00:37:40.120 --> 00:37:50.200
需要有一种到达的方法

00:37:41.760 --> 00:37:51.880
状态机，所以SM，我们需要

00:37:50.200 --> 00:37:55.210
到达状态机，让我们

00:37:51.880 --> 00:37:58.720
只需说出这一步，我们就可以

00:37:55.210 --> 00:38:00.460
传递订单ID并创建

00:37:58.720 --> 00:38:01.810
是这里的私有实现方法

00:38:00.460 --> 00:38:04.600
因为有很多需要

00:38:01.810 --> 00:38:05.920
发生在这里，所以第一件事首先我们

00:38:04.600 --> 00:38:07.720
需要查询我们需要的记录

00:38:05.920 --> 00:38:09.490
在这里查找ID，以便我实际

00:38:07.720 --> 00:38:13.120
首先让我们返回

00:38:09.490 --> 00:38:14.260
编译并做一些事情

00:38:13.120 --> 00:38:16.180
我们需要在那里做，但是首先我们

00:38:14.260 --> 00:38:17.350
需要到达，我们需要出售一个新的

00:38:16.180 --> 00:38:19.090
实例，所以我们实际上不会

00:38:17.350 --> 00:38:20.470
坚持状态机本身，但我们

00:38:19.090 --> 00:38:21.940
需要给状态机补水

00:38:20.470 --> 00:38:24.340
需要工厂新的状态机

00:38:21.940 --> 00:38:25.660
根据订单，然后将其推送到

00:38:24.340 --> 00:38:27.820
如果命令立即进入特定状态

00:38:25.660 --> 00:38:29.380
反映了一个事实，那就是

00:38:27.820 --> 00:38:30.730
已经实现了，那么我们想要

00:38:29.380 --> 00:38:33.010
我们对应的状态机武器

00:38:30.730 --> 00:38:34.480
从这种构建方法回到

00:38:33.010 --> 00:38:35.890
反映这一点，所以我们需要做一些

00:38:34.480 --> 00:38:38.590
这里的事情首先要查找

00:38:35.890 --> 00:38:40.450
订购现有的一个此点顺序

00:38:38.590 --> 00:38:44.050
通过其订单ID查找一个的存储库

00:38:40.450 --> 00:38:48.210
然后我们要反过来

00:38:44.050 --> 00:38:55.950
密钥，因此订单ID t等于长点

00:38:48.210 --> 00:38:59.290
字符串顺序点获取ID，然后我

00:38:55.950 --> 00:39:06.130
想要工厂一个新的状态机，所以

00:38:59.290 --> 00:39:09.040
订单状态的订单事件SM等于

00:39:06.130 --> 00:39:10.690
这个点工厂，我们需要状态

00:39:09.040 --> 00:39:13.390
机器工厂所以这个点状态

00:39:10.690 --> 00:39:17.640
机器工厂哦，你没有

00:39:13.390 --> 00:39:22.060
在这里注入了私人决赛

00:39:17.640 --> 00:39:28.810
状态机工厂，将要订购

00:39:22.060 --> 00:39:31.110
国令活动工厂

00:39:28.810 --> 00:39:34.690
好东西好好看

00:39:31.110 --> 00:39:36.610
这个点工厂点获取状态机

00:39:34.690 --> 00:39:39.610
传递ID，想法是

00:39:36.610 --> 00:39:41.020
那里的订单ID键很好，这就是我们的

00:39:39.610 --> 00:39:42.490
状态机，但再次这种状态

00:39:41.020 --> 00:39:44.290
机器还没启动还记得

00:39:42.490 --> 00:39:45.580
我们在调用开始之前就用过它

00:39:44.290 --> 00:39:48.520
我们必须做所有这些事情，但是当我们

00:39:45.580 --> 00:39:50.350
呼叫开始它将在提交开始

00:39:48.520 --> 00:39:52.930
这个订单可能是

00:39:50.350 --> 00:39:54.460
你知道所有，但实现了

00:39:52.930 --> 00:39:58.840
所以我们要好，我必须做一些

00:39:54.460 --> 00:40:04.330
这里的事情我们需要真正告诉

00:39:58.840 --> 00:40:06.370
状态机以将自己重置为我们的

00:40:04.330 --> 00:40:09.460
特定状态，所以让我们在这里做

00:40:06.370 --> 00:40:11.140
我们要说状态机

00:40:09.460 --> 00:40:13.360
首先不要停止我们不想要的

00:40:11.140 --> 00:40:15.370
首先运行（如果已经运行） 

00:40:13.360 --> 00:40:17.800
开始，然后我们要

00:40:15.370 --> 00:40:20.500
其实会说SM点得到状态

00:40:17.800 --> 00:40:21.820
机器访问权，这是猜测

00:40:20.500 --> 00:40:24.610
这使我们有能力做一些

00:40:21.820 --> 00:40:25.990
拜访节点中的事物

00:40:24.610 --> 00:40:27.730
状态机的有向图

00:40:25.990 --> 00:40:30.520
这样我们就可以获得状态机访问器

00:40:27.730 --> 00:40:32.260
然后我们可以参观所有地区

00:40:30.520 --> 00:40:34.360
是的，当您想到一个

00:40:32.260 --> 00:40:35.650
您需要了解的状态机

00:40:34.360 --> 00:40:37.540
状态机可以自己

00:40:35.650 --> 00:40:39.400
可以在其他状态机上递归

00:40:37.540 --> 00:40:40.750
有节点然后导致其他状态

00:40:39.400 --> 00:40:43.600
您知道的机器是分层的

00:40:40.750 --> 00:40:44.980
某种时尚或，所以你有这些

00:40:43.600 --> 00:40:46.240
这些被称为区域

00:40:44.980 --> 00:40:47.890
这些状态机是否嵌套

00:40:46.240 --> 00:40:51.640
这是一个地区，我想去参观

00:40:47.890 --> 00:40:53.860
每个地区，所以我要去参观每个

00:40:51.640 --> 00:40:56.820
这里的区域，所以我要说

00:40:53.860 --> 00:41:00.100
所有地区，我将提供

00:40:56.820 --> 00:41:04.690
状态机功能如此新的状态

00:41:00.100 --> 00:41:08.860
机器，功能和状态

00:41:04.690 --> 00:41:12.700
机器功能有一个非常简单的应用

00:41:08.860 --> 00:41:16.480
方法，在那里我给了SMA 

00:41:12.700 --> 00:41:20.380
状态机访问，所以我会说SMA 

00:41:16.480 --> 00:41:21.280
状态SMA点重置状态机，因此

00:41:20.380 --> 00:41:22.750
那是我要做的第一件事

00:41:21.280 --> 00:41:25.630
我要确保我们有一个

00:41:22.750 --> 00:41:27.970
新的默认状态机上下文

00:41:25.630 --> 00:41:30.580
此处将其作为第一个参数

00:41:27.970 --> 00:41:32.830
声明我希望我们的物体处于

00:41:30.580 --> 00:41:34.630
我要去提取我要去

00:41:32.830 --> 00:41:39.140
看物体的当前状态

00:41:34.630 --> 00:41:44.150
订单点获取订单状态

00:41:39.140 --> 00:41:45.619
然后在这里使用它，所以我

00:41:44.150 --> 00:41:47.720
重置我告诉状态机

00:41:45.619 --> 00:41:50.359
即使你被正确提交

00:41:47.720 --> 00:41:51.739
现在我要把你强行带到任何地方

00:41:50.359 --> 00:41:53.390
声明你应该在

00:41:51.739 --> 00:41:55.400
我们可以让您知道可预测的

00:41:53.390 --> 00:41:57.650
从这里开始然后

00:41:55.400 --> 00:42:05.599
其他一切都可以

00:41:57.650 --> 00:42:10.130
现在知道正确的声纳

00:42:05.599 --> 00:42:12.589
对，当然这可以是lambda 

00:42:10.130 --> 00:42:14.509
来是一件好事

00:42:12.589 --> 00:42:17.630
等等，我们可能真的需要这个

00:42:14.509 --> 00:42:19.249
稍后，让我们保持现状，但是我们

00:42:17.630 --> 00:42:22.400
当然可以让你可以使用

00:42:19.249 --> 00:42:25.819
 Java 7中的钻石语法

00:42:22.400 --> 00:42:29.749
所以我们现在已经有了

00:42:25.819 --> 00:42:32.599
认为应该这样做，所以让我们实际上

00:42:29.749 --> 00:42:40.249
启动状态机以立即启动

00:42:32.599 --> 00:42:43.579
它并返回现在当然

00:42:40.249 --> 00:42:46.489
出现的问题是你知道如何

00:42:43.579 --> 00:42:48.470
我们要坚持这个记录如何

00:42:46.489 --> 00:42:49.970
这个储存库会发现

00:42:48.470 --> 00:42:53.180
首先记录一些东西

00:42:49.970 --> 00:42:56.539
需要注意保持这种状态

00:42:53.180 --> 00:42:58.099
随着实体本身的变化而改变

00:42:56.539 --> 00:42:59.660
当实体当他们当陈述

00:42:58.099 --> 00:43:02.660
我要更新的状态机更改

00:42:59.660 --> 00:43:04.460
 Jaypee实体上的那个state字段，所以

00:43:02.660 --> 00:43:09.279
在这里我们需要添加一个状态机

00:43:04.460 --> 00:43:12.890
这里是拦截器，所以我们说SMA点

00:43:09.279 --> 00:43:16.190
和状态机拦截器的新状态

00:43:12.890 --> 00:43:18.680
机器拦截器，这给了我

00:43:16.190 --> 00:43:19.759
也许我应该使用适配器将使用

00:43:18.680 --> 00:43:21.609
这里的适配器，因为有一个

00:43:19.759 --> 00:43:25.509
各种不同的回调方法和

00:43:21.609 --> 00:43:30.500
这是订单状态和订单事件

00:43:25.509 --> 00:43:40.880
好吧，摆脱掉

00:43:30.500 --> 00:43:44.060
好吧，好吧，我们需要写

00:43:40.880 --> 00:43:46.070
在将状态写入数据库之前

00:43:44.060 --> 00:43:47.060
每个状态的改变，或者我们可以做

00:43:46.070 --> 00:43:48.920
我猜它真的没有

00:43:47.060 --> 00:43:52.040
很重要，但出于我们的目的，我想

00:43:48.920 --> 00:43:54.380
把它写在数据库里，你

00:43:52.040 --> 00:43:56.780
知道没有理由使用这种方法

00:43:54.380 --> 00:43:58.490
不能在同一资源中发生

00:43:56.780 --> 00:44:00.650
如果您坚持要进行本地交易

00:43:58.490 --> 00:44:02.090
你知道这是一个状态变化

00:44:00.650 --> 00:44:03.920
这将发生在我们的JP实体中

00:44:02.090 --> 00:44:05.240
没有理由改变状态

00:44:03.920 --> 00:44:07.730
不可能在同一背景下发生

00:44:05.240 --> 00:44:09.380
与您的业务逻辑相同的线程

00:44:07.730 --> 00:44:10.790
也会发生变化，但在这种情况下

00:44:09.380 --> 00:44:13.010
你不知道你也可以做到吗

00:44:10.790 --> 00:44:15.910
您也可以完全坚持

00:44:13.010 --> 00:44:18.800
与您的实体权利分开

00:44:15.910 --> 00:44:21.710
好的，所以P状态改变了我们要做什么

00:44:18.800 --> 00:44:27.230
要做的是说我们在期待

00:44:21.710 --> 00:44:29.870
您知道的参数头

00:44:27.230 --> 00:44:31.250
在触发状态的事件中

00:44:29.870 --> 00:44:33.320
改变一切，这就是为什么我们表现出

00:44:31.250 --> 00:44:34.610
您是消息生成器的变体，还是

00:44:33.320 --> 00:44:36.410
您正在发送一个变体

00:44:34.610 --> 00:44:38.210
事件可以进入状态机

00:44:36.410 --> 00:44:39.800
发送枚举值或我们可以

00:44:38.210 --> 00:44:43.130
发送一个Spring Framework 消息

00:44:39.800 --> 00:44:44.810
带有标题和该标题的消息

00:44:43.130 --> 00:44:45.830
选项是，假设这就是

00:44:44.810 --> 00:44:49.340
我们将要使用，因为那还没有

00:44:45.830 --> 00:44:51.050
传达参数标题的能力

00:44:49.340 --> 00:44:52.640
正确的价值观，我们可以传递给

00:44:51.050 --> 00:44:58.160
我们可以在其中使用的状态机

00:44:52.640 --> 00:45:01.070
保留我们的数据的情况，所以我们

00:44:58.160 --> 00:45:07.100
要说如果我们

00:45:01.070 --> 00:45:09.410
在这里给出不是null吧，所以

00:45:07.100 --> 00:45:11.810
我要说如果它存在，那么我们

00:45:09.410 --> 00:45:13.190
想用它做些什么

00:45:11.810 --> 00:45:18.950
我要做好，我们想得到

00:45:13.190 --> 00:45:20.750
删除ID，以便订单ID为值

00:45:18.950 --> 00:45:25.310
我们将从消息中得到

00:45:20.750 --> 00:45:29.810
获取标题点获取或默认值，它是

00:45:25.310 --> 00:45:31.160
将被称为订单ID负数

00:45:29.810 --> 00:45:33.650
我们实际上看着这个完全一样

00:45:31.160 --> 00:45:40.180
更早的事情，我们要说

00:45:33.650 --> 00:45:43.700
已知的可选点

00:45:40.180 --> 00:45:48.740
是的，如果那是已知的，那么

00:45:43.700 --> 00:45:52.369
而是如果它是当前的订单ID，那么我们

00:45:48.740 --> 00:45:55.339
想处理它，所以我们有ID 

00:45:52.369 --> 00:46:00.290
如果存在，我们将得到

00:45:55.339 --> 00:46:04.190
订单订单等于订单库点

00:46:00.290 --> 00:46:07.099
找到一个，我们将订单ID放入

00:46:04.190 --> 00:46:08.660
从数据库中获取它

00:46:07.099 --> 00:46:13.059
更新状态，所以我要说命令

00:46:08.660 --> 00:46:15.500
点设置状态，状态将为

00:46:13.059 --> 00:46:17.420
无论我们进展到什么状态

00:46:15.500 --> 00:46:20.710
那状态当然会传递给

00:46:17.420 --> 00:46:23.569
在这里回调，以便获得ID点名称

00:46:20.710 --> 00:46:25.160
今晚写出来，否则我们可以

00:46:23.569 --> 00:46:26.780
我想实际上只是一个集合或状态

00:46:25.160 --> 00:46:34.010
这样说会容易些，或者

00:46:26.780 --> 00:46:35.750
呆在那里，我们去点ID就好了

00:46:34.010 --> 00:46:40.700
就在那里，我们想说

00:46:35.750 --> 00:46:44.690
订购资料库点安全，因此非常订购

00:46:40.700 --> 00:46:48.380
很好，那就是发生了什么事

00:46:44.690 --> 00:46:50.599
这里我们有一个回调，当状态

00:46:48.380 --> 00:46:52.760
机器进入特定阶段

00:46:50.599 --> 00:46:55.309
想在它进入之前写

00:46:52.760 --> 00:46:58.520
写下即将发生的状态

00:46:55.309 --> 00:47:00.920
到达，你知道我们想做

00:46:58.520 --> 00:47:04.040
我们想要将其与订单联系起来

00:47:00.920 --> 00:47:09.530
本身，我们需要通过链接来做到这一点

00:47:04.040 --> 00:47:11.660
我们将我们的变化与我们联系起来

00:47:09.530 --> 00:47:14.540
告诉我们哪个顺序的参数

00:47:11.660 --> 00:47:21.170
在这里受到影响，所以让我们重新来看一下

00:47:14.540 --> 00:47:23.260
这里的代码清理一点点所有

00:47:21.170 --> 00:47:23.260
对

00:47:23.400 --> 00:47:30.160
好，这样有点干净我喜欢

00:47:27.190 --> 00:47:32.500
而且我都是关于干净代码的，所以我们已经

00:47:30.160 --> 00:47:34.060
现在有我们的状态机

00:47:32.500 --> 00:47:35.890
状态机访问器，所有这一切是

00:47:34.060 --> 00:47:37.780
在每一个全新的配置

00:47:35.890 --> 00:47:39.550
状态机正确，所以再次状态

00:47:37.780 --> 00:47:40.660
机器是很轻的物体，但是

00:47:39.550 --> 00:47:41.800
我们将做一些非常重量级的

00:47:40.660 --> 00:47:44.890
事情将要与数据库对话

00:47:41.800 --> 00:47:46.150
和持久状态非常非常容易

00:47:44.890 --> 00:47:48.880
尽管Ryan不需要花很多钱

00:47:46.150 --> 00:47:51.370
这与国家机器的发展息息相关

00:47:48.880 --> 00:47:52.480
陈述和我们的业务逻辑，所以我们

00:47:51.370 --> 00:47:54.250
会得到两全其美的

00:47:52.480 --> 00:47:56.710
我们的业务逻辑是干净的

00:47:54.250 --> 00:47:58.870
你知道状态机的权威

00:47:56.710 --> 00:48:02.710
这些事物的模型

00:47:58.870 --> 00:48:04.720
进步等等，现在还好吧

00:48:02.710 --> 00:48:08.890
让我们看看如果我们跑步

00:48:04.720 --> 00:48:09.940
这是正确的事情，所以我们想成为

00:48:08.890 --> 00:48:11.680
能够做到这一点实际上会创建一个

00:48:09.940 --> 00:48:13.600
建立状态的状态机

00:48:11.680 --> 00:48:15.970
我们要建造的机器来改变

00:48:13.600 --> 00:48:18.310
神话的状态

00:48:15.970 --> 00:48:21.700
状态机，所以也许我们可以做

00:48:18.310 --> 00:48:24.150
这也许我们实际上是说嘿

00:48:21.700 --> 00:48:27.130
然后在这里我们可以说我们可以拥有

00:48:24.150 --> 00:48:31.780
你知道多少钱的一些性质

00:48:27.130 --> 00:48:36.880
付钱给你，我知道我不知道

00:48:31.780 --> 00:48:39.310
付款确认号权利和

00:48:36.880 --> 00:48:41.650
那么我们实际上可以发送一条消息

00:48:39.310 --> 00:48:43.750
我们可以说消息生成器的思想

00:48:41.650 --> 00:48:47.530
有有效载荷，当然还有有效载荷

00:48:43.750 --> 00:48:51.120
在这种情况下，付款事件还可以吗

00:48:47.530 --> 00:48:56.290
订单订单

00:48:51.120 --> 00:48:58.570
事件点a和我们需要的标题

00:48:56.290 --> 00:49:02.350
当然，我们必须拥有的是

00:48:58.570 --> 00:49:05.760
订单ID，所以有订单ID和

00:49:02.350 --> 00:49:05.760
我们将像这样构建该消息

00:49:06.030 --> 00:49:11.050
但是我们也可以让你知道

00:49:08.560 --> 00:49:14.760
如付款确认号

00:49:11.050 --> 00:49:17.380
正确设置抬头付款确认

00:49:14.760 --> 00:49:18.550
数字或你知道我不知道的价格

00:49:17.380 --> 00:49:20.050
知道什么不是我真正的

00:49:18.550 --> 00:49:21.550
可以在本例中实际使用

00:49:20.050 --> 00:49:23.110
但是很高兴知道我们

00:49:21.550 --> 00:49:24.550
可以把它送进州

00:49:23.110 --> 00:49:26.770
机器，然后他们可以做为

00:49:24.550 --> 00:49:30.010
我们已经看到了它想要的任何东西

00:49:26.770 --> 00:49:35.990
那我要说机器或SM点

00:49:30.010 --> 00:49:40.460
发送事件事件消息，所以付费消息

00:49:35.990 --> 00:49:44.430
付款信息没问题，那就是

00:49:40.460 --> 00:49:46.440
第一件事，我们知道这将是

00:49:44.430 --> 00:49:47.760
叫做订单ID，所以我们可以这样

00:49:46.440 --> 00:49:49.800
理想情况下，您保留的东西

00:49:47.760 --> 00:49:55.590
到您已经提取到单个

00:49:49.800 --> 00:49:56.700
字段，以便您拥有订单ID标头

00:49:55.590 --> 00:49:58.710
你应该把那个作为

00:49:56.700 --> 00:50:01.710
在某个地方不变，然后我们用它

00:49:58.710 --> 00:50:05.070
在班级中如此私人的静态决赛

00:50:01.710 --> 00:50:06.600
我们去那里的订单ID标题

00:50:05.070 --> 00:50:08.760
你实际上可以拥有相同的东西

00:50:06.600 --> 00:50:11.880
这些是众所周知的

00:50:08.760 --> 00:50:13.800
标头很好，所以这就是付款

00:50:11.880 --> 00:50:18.840
方法我们还想要什么

00:50:13.800 --> 00:50:22.500
这应该很好，我们想要

00:50:18.840 --> 00:50:25.920
有另一种方法可以实现它

00:50:22.500 --> 00:50:30.480
对，所以说我们有相同的

00:50:25.920 --> 00:50:34.830
我要打电话给基本签名

00:50:30.480 --> 00:50:38.430
这个满足，也许现在

00:50:34.830 --> 00:50:39.900
满足方法获取地址

00:50:38.430 --> 00:50:42.510
你要去的地方

00:50:39.900 --> 00:50:43.980
包裹你知道地址在哪里

00:50:42.510 --> 00:50:45.960
不管你要寄给我什么

00:50:43.980 --> 00:50:48.870
不知道这可能会花费你什么

00:50:45.960 --> 00:50:49.890
知道这可能是你想要的

00:50:48.870 --> 00:50:51.030
对，你想要什么？ 

00:50:49.890 --> 00:50:53.220
任何其他信息想要

00:50:51.030 --> 00:50:54.660
有助于对象图

00:50:53.220 --> 00:50:56.550
在这里，但出于所有目的，我们只是

00:50:54.660 --> 00:50:57.750
有一个实现方法，并且基本相同

00:50:56.550 --> 00:51:02.090
结构正确，我要建立我们的

00:50:57.750 --> 00:51:09.000
状态机，然后我们将

00:51:02.090 --> 00:51:18.380
通过发送将其移至特定状态

00:51:09.000 --> 00:51:18.380
安排一个合适的活动，让我们这样做

00:51:20.520 --> 00:51:25.900
好吧，在这种情况下，我们没有

00:51:23.470 --> 00:51:30.610
来了确认，所以我们会说短信

00:51:25.900 --> 00:51:34.660
点发送事件付款消息和这个

00:51:30.610 --> 00:51:38.890
将会是一个满足的消息

00:51:34.660 --> 00:51:41.110
然后我们把sm变好，所以我们有

00:51:38.890 --> 00:51:45.390
履行方式以及付款方式

00:51:41.110 --> 00:51:47.770
然后在这里再次实现

00:51:45.390 --> 00:51:54.630
当我们开始时当我们开始时

00:51:47.770 --> 00:51:57.310
我们希望它获得状态的机器

00:51:54.630 --> 00:52:00.640
基于订单状态

00:51:57.310 --> 00:52:07.660
对，所以这里要发生的是

00:52:00.640 --> 00:52:09.580
我们要致敬

00:52:07.660 --> 00:52:11.830
改变将创造一个

00:52:09.580 --> 00:52:14.110
在这里状态新的状态机

00:52:11.830 --> 00:52:16.320
机器本身将要查找

00:52:14.110 --> 00:52:19.810
在数据库中记录对象

00:52:16.320 --> 00:52:22.210
它会打开事件的包装

00:52:19.810 --> 00:52:24.460
消息状态订单状态

00:52:22.210 --> 00:52:26.560
确保在我们达到目标时

00:52:24.460 --> 00:52:29.340
行，该状态机已经

00:52:26.560 --> 00:52:32.290
在那个状态下，所以如果它处于状态

00:52:29.340 --> 00:52:33.730
完成了第三个，那么你知道

00:52:32.290 --> 00:52:35.800
状态机将反映出

00:52:33.730 --> 00:52:36.730
现在我们到第二行

00:52:35.800 --> 00:52:38.830
显然，在第二行中

00:52:36.730 --> 00:52:40.570
假设它处于已付款状态或您曾经

00:52:38.830 --> 00:52:41.950
知道它刚刚提交，所以它会在

00:52:40.570 --> 00:52:43.690
任何状态应该由

00:52:41.950 --> 00:52:46.210
它离开dist up构建的时间

00:52:43.690 --> 00:52:47.770
方法，最后我们要移动

00:52:46.210 --> 00:52:49.510
通过发送一个

00:52:47.770 --> 00:52:51.610
消息进入其中，这将

00:52:49.510 --> 00:52:53.500
触发此状态更改前的事情

00:52:51.610 --> 00:52:55.480
这将更新持久性

00:52:53.500 --> 00:52:56.650
状态在数据库中的日期，所以所有

00:52:55.480 --> 00:52:59.020
你很快就会发生

00:52:56.650 --> 00:53:01.840
知道我们实际上已经有了你

00:52:59.020 --> 00:53:03.910
知道这一点，我们正在读取数据

00:53:01.840 --> 00:53:05.260
从订单对象中，我们正在阅读

00:53:03.910 --> 00:53:06.940
从或持久顺序中得出状态

00:53:05.260 --> 00:53:09.490
对象并将我们的机器设置为

00:53:06.940 --> 00:53:11.170
并以此设置更改

00:53:09.490 --> 00:53:13.660
或将更改同步到

00:53:11.170 --> 00:53:16.540
状态机对命令本身如此

00:53:13.660 --> 00:53:17.860
双向持久性好吧

00:53:16.540 --> 00:53:19.450
我们有我们的订购服务，让我们使用

00:53:17.860 --> 00:53:21.880
这在我们的跑步者这里

00:53:19.450 --> 00:53:26.970
跑步者，嘿，我们很好，我们去了，所以订单

00:53:21.880 --> 00:53:29.470
然后按照顺序

00:53:26.970 --> 00:53:30.490
我们将发送一些消息

00:53:29.470 --> 00:53:32.950
猜猜吧，我们将使用订购服务

00:53:30.490 --> 00:53:35.849
我们要说我们已经创建了一个新的

00:53:32.950 --> 00:53:38.290
立即履行，以便订购医生获得ID 

00:53:35.849 --> 00:53:42.849
好吧不，我们要先付钱

00:53:38.290 --> 00:53:46.720
对，所以付出，我们将拥有一切

00:53:42.849 --> 00:53:48.250
我不知道UUID不会随机Doug来

00:53:46.720 --> 00:53:50.740
加强好吧，所以我们有两个

00:53:48.250 --> 00:53:52.329
现在，如果我们愿意，我们可以

00:53:50.740 --> 00:53:53.770
实际上看一下状态机

00:53:52.329 --> 00:54:00.760
这就是为什么我们退回它的原因

00:53:53.770 --> 00:54:06.070
付款状态机，我们会说一个

00:54:00.760 --> 00:54:11.320
关闭状态机付款事件获取

00:54:06.070 --> 00:54:20.730
状态而不是点获取ID点名称已记录

00:54:11.320 --> 00:54:24.820
打电话后付款就可以了

00:54:20.730 --> 00:54:27.450
好，就是这样，我们要

00:54:24.820 --> 00:54:31.359
这里有另一个叫做实现

00:54:27.450 --> 00:54:32.410
我要说实现，我们知道

00:54:31.359 --> 00:54:36.300
不想吃第二个参数

00:54:32.410 --> 00:54:38.470
所以我们会在调用完成后使用

00:54:36.300 --> 00:54:40.839
我想我们实际上应该

00:54:38.470 --> 00:54:44.319
打电话后也有这个出现

00:54:40.839 --> 00:54:47.380
让我们在状态权上戳一下

00:54:44.319 --> 00:54:48.400
在创建之后，在这种情况下， 

00:54:47.380 --> 00:54:49.569
我们实际上没有它，所以也许我们

00:54:48.400 --> 00:54:51.310
应该把它还给我们

00:54:49.569 --> 00:54:53.530
本来可以有状态

00:54:51.310 --> 00:54:54.970
机器返回那里，但现在

00:54:53.530 --> 00:55:00.069
很好，让我们这样想

00:54:54.970 --> 00:55:02.200
好吧，所以在打电话给我们后，我们可以

00:55:00.069 --> 00:55:03.720
看看所有的当前状态

00:55:02.200 --> 00:55:06.720
对

00:55:03.720 --> 00:55:06.720
完成

00:55:07.470 --> 00:55:18.650
完成状态机可以了

00:55:19.910 --> 00:55:27.420
所以我们做错了什么

00:55:22.940 --> 00:55:29.910
插入一跳简单的新手

00:55:27.420 --> 00:55:32.520
错误顺序是保留关键字， 

00:55:29.910 --> 00:55:36.150
续集，我应该知道

00:55:32.520 --> 00:55:38.760
让我们改变一下JPA实体

00:55:36.150 --> 00:55:40.910
是我们的GP实体在这里所有

00:55:38.760 --> 00:55:40.910
对

00:55:42.020 --> 00:55:49.040
名称等于订单，确定好，再试一次

00:55:51.170 --> 00:55:58.710
好吧，让我们看看我们拥有什么

00:55:53.990 --> 00:56:00.780
所以启动状态机就开始了

00:55:58.710 --> 00:56:10.109
具有这四个州的州

00:56:00.780 --> 00:56:20.130
从已提交更改为已提交

00:56:10.109 --> 00:56:21.690
是的，要付高就可以了

00:56:20.130 --> 00:56:24.480
也许凯撒在这里低头看

00:56:21.690 --> 00:56:28.040
付完金后，那是有偿的权利

00:56:24.480 --> 00:56:30.510
调用完成后的当前状态

00:56:28.040 --> 00:56:33.570
我在那发送了错误的事件吗

00:56:30.510 --> 00:56:36.869
现在在日志中填写方法

00:56:33.570 --> 00:56:38.190
说哦，是的，所以实现

00:56:36.869 --> 00:56:39.210
我们必须发送正确的事件的东西

00:56:38.190 --> 00:56:41.160
显然，这不会在

00:56:39.210 --> 00:56:43.290
这样，它会保留在旧的

00:56:41.160 --> 00:56:46.600
声明为已付款或已付款

00:56:43.290 --> 00:56:49.300
状态还好

00:56:46.600 --> 00:56:51.070
所以在我们打电话完成结果之后

00:56:49.300 --> 00:56:53.050
是我们完成之后

00:56:51.070 --> 00:56:56.680
所谓付出的结果是国家

00:56:53.050 --> 00:56:58.510
机器说已付款，如果您

00:56:56.680 --> 00:57:00.640
知道我们可以通过以下方式确认这一点

00:56:58.510 --> 00:57:02.050
看着物体和每一步

00:57:00.640 --> 00:57:08.820
好看看订单本身

00:57:02.050 --> 00:57:08.820
让我们在哪里渲染好

00:57:10.980 --> 00:57:14.770
我们将查找记录为

00:57:13.030 --> 00:57:16.060
好吧，这次我想我们可以

00:57:14.770 --> 00:57:18.520
只返回订单的方法

00:57:16.060 --> 00:57:23.890
本身，所以让我们去订购

00:57:18.520 --> 00:57:28.230
服务在这里，看看订单

00:57:23.890 --> 00:57:35.500
通过ID长的想法吧，所以这个想法

00:57:28.230 --> 00:57:37.270
按ID罚款，我们会打印出来的

00:57:35.500 --> 00:57:39.730
所以最后两个方法返回状态

00:57:37.270 --> 00:57:40.810
机器，但不是订单，但我们只是

00:57:39.730 --> 00:57:42.010
当我们只想戳它时

00:57:40.810 --> 00:57:43.990
看看发生了什么，只是为了证明我

00:57:42.010 --> 00:57:49.560
认为它按预期工作，所以在这里

00:57:43.990 --> 00:57:54.660
我们实际上会说记录信息顺序

00:57:49.560 --> 00:57:58.000
通过ID等于订购服务点

00:57:54.660 --> 00:57:59.230
现在传递订单获取ID 

00:57:58.000 --> 00:58:06.550
当然，我们可以复制下来

00:57:59.230 --> 00:58:10.720
在这里再次运行代码做了什么

00:58:06.550 --> 00:58:12.040
我们得到了，所以秩序等于履行

00:58:10.720 --> 00:58:14.980
状态等于在那里实现

00:58:12.040 --> 00:58:16.000
国家等于在那里支付

00:58:14.980 --> 00:58:18.700
您可以看到它正在同步

00:58:16.000 --> 00:58:21.520
来回改变，所以我们已经

00:58:18.700 --> 00:58:23.410
只是看了一个非常简短的介绍

00:58:21.520 --> 00:58:25.300
Spring Statemachine有一个整体

00:58:23.410 --> 00:58:27.040
现在有很多可能性

00:58:25.300 --> 00:58:28.810
有一个新的协议 Spring Cloud 

00:58:27.040 --> 00:58:32.050
船长，我希望也能涵盖

00:58:28.810 --> 00:58:34.960
本期Spring 技巧的另一部分

00:58:32.050 --> 00:58:37.930
云船长那种部署和

00:58:34.960 --> 00:58:40.600
管理生命周期状态

00:58:37.930 --> 00:58:42.910
复杂应用的过渡

00:58:40.600 --> 00:58:45.880
进入像这样的云环境

00:58:42.910 --> 00:58:48.070
云铸造厂或kubernetes，它有一个

00:58:45.880 --> 00:58:50.020
需要有向图，有一个

00:58:48.070 --> 00:58:51.640
说明您在哪里部署应用程序

00:58:50.020 --> 00:58:53.530
好，否则我们必须将其回滚或

00:58:51.640 --> 00:58:55.360
这种东西目前是正确的

00:58:53.530 --> 00:58:57.760
现在进行了硬编码，但我们认为这将是

00:58:55.360 --> 00:58:59.050
非常适合 Spring 之类的东西

00:58:57.760 --> 00:59:00.490
状态机可能会发生，我们

00:58:59.050 --> 00:59:03.130
不知道有你

00:59:00.490 --> 00:59:04.270
适用于任何地方的Spring Statemachine

00:59:03.130 --> 00:59:07.600
希望能够描述图

00:59:04.270 --> 00:59:10.869
分别，所以我写了一个公平的

00:59:07.600 --> 00:59:12.130
此处的代码数量，但在顶层

00:59:10.869 --> 00:59:14.430
我们关心的是， 

00:59:12.130 --> 00:59:16.300
这些众所周知的过渡及其

00:59:14.430 --> 00:59:18.160
可预见的你可以讯问你

00:59:16.300 --> 00:59:19.210
可以打印出来，你可以知道商店

00:59:18.160 --> 00:59:21.790
你可以用它做所有这些事情

00:59:19.210 --> 00:59:23.200
你有一种普通的交谈方式

00:59:21.790 --> 00:59:25.900
关于这个状态的转变

00:59:23.200 --> 00:59:27.390
是的，这使您的代码与

00:59:25.900 --> 00:59:30.280
企业正试图做正确的事

00:59:27.390 --> 00:59:31.360
好的，所以我的朋友们谢谢

00:59:30.280 --> 00:59:33.630
这么多的观看，我们会见到你

00:59:31.360 --> 00:59:33.630
下次

00:59:42.260 --> 00:59:44.320
您

