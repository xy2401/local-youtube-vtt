WEBVTT
Kind: captions
Language: zh-Hans

00:00:24.890 --> 00:00:29.689
我 Spring 的粉丝们欢迎来到另一个

00:00:27.410 --> 00:00:33.200
一如既往的 Spring 技巧分期付款

00:00:29.689 --> 00:00:34.880
很高兴今天能加入你们，我很激动

00:00:33.200 --> 00:00:38.120
关于今天的话题，如果我是

00:00:34.880 --> 00:00:40.190
老实说，我们将谈论Kotlin

00:00:38.120 --> 00:00:41.420
特别是我们要重温

00:00:40.190 --> 00:00:43.220
我们已经谈论过的Coughlin 

00:00:41.420 --> 00:00:46.010
 Coughlin对此多次

00:00:43.220 --> 00:00:49.540
我们的简明截屏，但我们

00:00:46.010 --> 00:00:53.360
将特别关注协同例程

00:00:49.540 --> 00:00:55.580
现在我等了这么久的原因

00:00:53.360 --> 00:00:57.229
谈论它是因为我想得到

00:00:55.580 --> 00:01:00.229
没错，事情在不断变化

00:00:57.229 --> 00:01:02.540
如果你愿意，当我看着它的时候

00:01:00.229 --> 00:01:05.570
次，最后终于终于Kotlin

00:01:02.540 --> 00:01:07.970
 1.3已经发布， 

00:01:05.570 --> 00:01:11.590
对Kotlin本身的核心支持是

00:01:07.970 --> 00:01:13.670
现在已经可以普遍使用了

00:01:11.590 --> 00:01:15.979
还有一些其他的东西不是

00:01:13.670 --> 00:01:17.270
相当普遍

00:01:15.979 --> 00:01:19.100
你会看到我要拉

00:01:17.270 --> 00:01:21.049
有些作品还不是最终的，但是

00:01:19.100 --> 00:01:22.729
他们相对稳定，人们

00:01:21.049 --> 00:01:26.450
使用它们，效果很好， 

00:01:22.729 --> 00:01:29.720
你会发现，你甚至知道一个

00:01:26.450 --> 00:01:31.820
特别好的方面

00:01:29.720 --> 00:01:33.980
稳定性是当我寻找

00:01:31.820 --> 00:01:36.530
您知道想法或文档，并且

00:01:33.980 --> 00:01:38.510
像这样的事情我找到了答案

00:01:36.530 --> 00:01:41.780
最合适的权利

00:01:38.510 --> 00:01:44.540
时间是适用的，所以这告诉

00:01:41.780 --> 00:01:46.790
我，嗯，它长期保持稳定

00:01:44.540 --> 00:01:48.260
足以让他们的工作语录

00:01:46.790 --> 00:01:50.990
关于它，这是值得赞扬的

00:01:48.260 --> 00:01:52.790
那些为Kotlin本身工作的团队

00:01:50.990 --> 00:01:54.890
听我的小播客的你们中

00:01:52.790 --> 00:01:56.750
和引导性播客当然可用

00:01:54.890 --> 00:01:58.760
在所有锅底世界上，我们都知道

00:01:56.750 --> 00:02:01.400
下载播客的平台

00:01:58.760 --> 00:02:04.610
可通过所有流行的播客获得

00:02:01.400 --> 00:02:07.370
包括Apple iTunes，对不起，我

00:02:04.610 --> 00:02:09.259
猜测设计调整了Google Play和

00:02:07.370 --> 00:02:12.470
为您中的那些人提供Spotify课程

00:02:09.259 --> 00:02:14.750
听我什至有幸

00:02:12.470 --> 00:02:17.540
采访罗马共同队

00:02:14.750 --> 00:02:20.209
几周前的拉泽罗夫

00:02:17.540 --> 00:02:22.940
面试绝对让人着迷

00:02:20.209 --> 00:02:23.900
如果你想要更多的回头

00:02:22.940 --> 00:02:25.220
我们要谈论的背景

00:02:23.900 --> 00:02:27.049
关于今天，如果我们运行更多细节

00:02:25.220 --> 00:02:28.400
我们今天要谈的就是你

00:02:27.049 --> 00:02:30.670
绝对应该是那个播客

00:02:28.400 --> 00:02:33.080
而当你在它，请订阅

00:02:30.670 --> 00:02:34.850
但我们要去看看

00:02:33.080 --> 00:02:36.260
就像转化为我们的东西一样

00:02:34.850 --> 00:02:37.490
今天使用Kotlin构建应用程序

00:02:36.260 --> 00:02:38.980
不会使用最新的和最大的

00:02:37.490 --> 00:02:41.329
 spring boot 

00:02:38.980 --> 00:02:44.090
 3em3我们是否要称呼它

00:02:41.329 --> 00:02:49.069
编码青少年好哈哈，所以他们做到了

00:02:44.090 --> 00:02:52.489
他们将K换成C，所以你知道

00:02:49.069 --> 00:02:55.010
太酷了，我们就是这些反应灵敏的网站

00:02:52.489 --> 00:03:00.230
支持我们使用反应式MongoDB 

00:02:55.010 --> 00:03:02.450
支持我们将使用我猜那是

00:03:00.230 --> 00:03:03.530
好的，我想就是这样

00:03:02.450 --> 00:03:06.290
我们需要什么我可以得到

00:03:03.530 --> 00:03:07.849
从初始化器um我们可以使用

00:03:06.290 --> 00:03:09.829
是的，我们可以使用MongoDB 

00:03:07.849 --> 00:03:11.780
不错的是，我们还可以使用- 

00:03:09.829 --> 00:03:15.019
 DBC，我想我们也会做

00:03:11.780 --> 00:03:17.000
但请记住，您不必

00:03:15.019 --> 00:03:19.340
这不是一开始就没有

00:03:17.000 --> 00:03:21.199
此处的复选框，但正如我们所见

00:03:19.340 --> 00:03:22.969
先前的视频实验支持

00:03:21.199 --> 00:03:24.469
传播实验自动配置

00:03:22.969 --> 00:03:27.230
支持这一点，所以也许我们会去

00:03:24.469 --> 00:03:29.269
我们看看我是否能知道

00:03:27.230 --> 00:03:30.739
无论哪种方式，您都可以知道

00:03:29.269 --> 00:03:31.790
您今天要看到的内容也适用

00:03:30.739 --> 00:03:34.370
显然有不同的地方

00:03:31.790 --> 00:03:37.699
域模型和不同的数据类型，但是

00:03:34.370 --> 00:03:39.379
扩展功能

00:03:37.699 --> 00:03:41.180
我们将介绍的是

00:03:39.379 --> 00:03:44.629
适用于MongoDB的情况类似

00:03:41.180 --> 00:03:47.060
适用于我们的-DBC好的，所以我们

00:03:44.629 --> 00:03:49.159
我要给我们一个新的

00:03:47.060 --> 00:03:50.870
项目，我将打开它，并在

00:03:49.159 --> 00:03:53.180
我们可以花点时间欣赏的方式

00:03:50.870 --> 00:03:58.459
这个崭新的时髦真令人赞叹

00:03:53.180 --> 00:04:00.439
基于反应的um spring初始化器是

00:03:58.459 --> 00:04:01.970
看着那你甚至都不知道

00:04:00.439 --> 00:04:04.959
代码正确的地方就是

00:04:01.970 --> 00:04:09.709
只是你所知道的真的很漂亮

00:04:04.959 --> 00:04:12.970
反应是，有些东西很难

00:04:09.709 --> 00:04:16.159
渗透到手工解析方面

00:04:12.970 --> 00:04:17.269
用肉眼看，但是很棒的东西

00:04:16.159 --> 00:04:21.259
发生在那很酷，所以

00:04:17.269 --> 00:04:24.789
真的很快，你知道吗，反正我们

00:04:21.259 --> 00:04:24.789
去打开那个

00:04:35.610 --> 00:04:40.500
好吧，一旦加载

00:04:39.599 --> 00:04:42.180
我们要做的第一件事是

00:04:40.500 --> 00:04:43.770
看看带来了正确的

00:04:42.180 --> 00:04:48.379
依赖使这项工作正常

00:04:43.770 --> 00:04:48.379
我们将其关闭

00:04:56.090 --> 00:04:59.290
好吧加油

00:05:03.300 --> 00:05:10.199
这个已经存在好吗

00:05:07.680 --> 00:05:14.520
东西，所以我们要建立一个

00:05:10.199 --> 00:05:15.690
应用程序在这里，我们去之前

00:05:14.520 --> 00:05:17.099
当然太远了

00:05:15.690 --> 00:05:19.080
添加正确的依赖关系并

00:05:17.099 --> 00:05:20.699
配置正确的东西来做到这一点

00:05:19.080 --> 00:05:22.530
工作，所以我要做的第一件事是

00:05:20.699 --> 00:05:24.930
拉Kotlin版本确保

00:05:22.530 --> 00:05:26.789
那是1.3英里3.1很好

00:05:24.930 --> 00:05:30.120
然后我们要指定一个版本

00:05:26.789 --> 00:05:32.009
对于棉煤常规库

00:05:30.120 --> 00:05:34.370
我称它们为x co例程，这是

00:05:32.009 --> 00:05:37.770
有点像孵化器库

00:05:34.370 --> 00:05:41.190
主要支持之外的共同点

00:05:37.770 --> 00:05:42.840
在主要支持之外

00:05:41.190 --> 00:05:44.130
共同例程和顺便说一句

00:05:42.840 --> 00:05:46.800
这是设计使然的

00:05:44.130 --> 00:05:48.509
精心设计的支持方面

00:05:46.800 --> 00:05:50.419
对于Kotlin合作会议，是

00:05:48.509 --> 00:05:52.199
那个我认为有一个关键字

00:05:50.419 --> 00:05:54.479
暂停，我认为那是唯一的事情

00:05:52.199 --> 00:05:56.699
那是独一无二的，其他一切都是

00:05:54.479 --> 00:05:58.050
设计为正确的功能

00:05:56.699 --> 00:05:59.970
模型实际上足够灵活

00:05:58.050 --> 00:06:02.490
您可以将其用作生成器或

00:05:59.970 --> 00:06:07.199
您可以将其用作某种

00:06:02.490 --> 00:06:08.669
于2012年在c-sharp上执行async / await和

00:06:07.199 --> 00:06:10.800
所以他们真的很高兴

00:06:08.669 --> 00:06:13.560
植入如此灵活的基础

00:06:10.800 --> 00:06:14.909
事，然后服从第三方

00:06:13.560 --> 00:06:16.949
库来填补空白

00:06:14.909 --> 00:06:19.680
他们认为合适的任何方式

00:06:16.949 --> 00:06:21.060
这个API确实表现不错

00:06:19.680 --> 00:06:23.340
所以我们会在这里看到

00:06:21.060 --> 00:06:26.870
其实看到了一些

00:06:23.340 --> 00:06:31.620
图书馆好吧，我们得到了什么，我们得到了

00:06:26.870 --> 00:06:35.460
我们想要抓住的依赖Lennox Cole 

00:06:31.620 --> 00:06:35.960
例程很酷的例程真的很活跃

00:06:35.460 --> 00:06:38.639
短剑

00:06:35.960 --> 00:06:42.000
好的，所以您可以看到我们有一个适配器

00:06:38.639 --> 00:06:47.550
对于反应堆好吧，我会回到那个问题上

00:06:42.000 --> 00:06:49.259
一秒钟，当然版本是

00:06:47.550 --> 00:06:54.270
一个属性，所以Kotler协同工作

00:06:49.259 --> 00:06:56.009
版本好东西复制那个和

00:06:54.270 --> 00:06:59.789
我们有耦合代码更改版本

00:06:56.009 --> 00:07:01.620
四个核心在这里，我们也很好

00:06:59.789 --> 00:07:06.120
东西还好，所以我们有核心要素

00:07:01.620 --> 00:07:07.520
嗯，我想我们需要争论或

00:07:06.120 --> 00:07:11.069
 ABC，我将它们带入

00:07:07.520 --> 00:07:13.520
好吧也许用他们也许我们不会

00:07:11.069 --> 00:07:13.520
知道我在说

00:07:14.030 --> 00:07:22.910
复制添加，我们需要他们

00:07:18.680 --> 00:07:22.910
那里的依赖管理部分

00:07:25.550 --> 00:07:38.730
好吧，我想连接到我的信任

00:07:32.730 --> 00:07:40.830
 Costco的数据库很好，我们

00:07:38.730 --> 00:07:42.690
需要知道我想

00:07:40.830 --> 00:07:47.030
我们的TBC，您将摆脱MongoDB 

00:07:42.690 --> 00:07:56.760
因为我非常喜欢我们成为C 

00:07:47.030 --> 00:07:58.080
好东西，现在在我们的代码中

00:07:56.760 --> 00:08:00.360
一分钟内访问所有东西

00:07:58.080 --> 00:08:03.270
但是在我们的代码中，让我们注释掉春季

00:08:00.360 --> 00:08:06.810
暂时启动，我们要

00:08:03.270 --> 00:08:09.420
首先，让我们看看我们是否

00:08:06.810 --> 00:08:11.430
可以使基本代码正常工作

00:08:09.420 --> 00:08:12.960
我要创建一个或两个函数

00:08:11.430 --> 00:08:18.390
这将有助于我们在这里的工作

00:08:12.960 --> 00:08:22.800
将其注释掉并创建一个

00:08:18.390 --> 00:08:24.270
这里的功能是向我们发送日志数据

00:08:22.800 --> 00:08:30.930
会创建一个随东西而变的函数

00:08:24.270 --> 00:08:42.030
出来，我们需要记录当前

00:08:30.930 --> 00:08:47.190
线程名称，如果有则记录一条消息

00:08:42.030 --> 00:08:49.620
它给了我们，我们现在就去

00:08:47.190 --> 00:08:54.110
这将是有用的，然后我们还将

00:08:49.620 --> 00:08:59.780
马上记录当前时间

00:08:54.110 --> 00:08:59.780
点现在好了

00:09:00.390 --> 00:09:07.480
然后我们走了，所以现在我们有了一个东西

00:09:05.740 --> 00:09:08.920
我们可以用来做笔记，我只是

00:09:07.480 --> 00:09:10.510
这只是一个功能，只是一个公众

00:09:08.920 --> 00:09:13.300
静态无效主大陆程序

00:09:10.510 --> 00:09:14.649
不管你知道 Spring 还是

00:09:13.300 --> 00:09:16.360
这样的事情，我们可以探索

00:09:14.649 --> 00:09:17.649
代码例程背后的想法还可以

00:09:16.360 --> 00:09:18.850
当我们专注于美好的时候

00:09:17.649 --> 00:09:20.380
风中的东西三看那

00:09:18.850 --> 00:09:24.010
甚至不再遇到这种

00:09:20.380 --> 00:09:26.500
酷，我是粉丝，让我们看看我们有

00:09:24.010 --> 00:09:29.290
我们将使用预览

00:09:26.500 --> 00:09:31.390
 Colin Cowie团队的流程版本

00:09:29.290 --> 00:09:32.050
这个注解告诉你情报

00:09:31.390 --> 00:09:34.750
离开我们一个人

00:09:32.050 --> 00:09:35.700
当我们知道不要打扰我们时

00:09:34.750 --> 00:09:40.920
提醒您，这是一个

00:09:35.700 --> 00:09:40.920
实验权非常方便， 

00:09:41.100 --> 00:09:45.430
我们将需要我们将

00:09:43.930 --> 00:09:48.820
现在试验皮质类药物

00:09:45.430 --> 00:09:50.709
到清单上，让我们四舍五入

00:09:48.820 --> 00:09:54.279
首先在某些背景下

00:09:50.709 --> 00:09:59.980
团队是一种异步方法

00:09:54.279 --> 00:10:02.680
编程好吧，它们是一种移动方式

00:09:59.980 --> 00:10:05.769
现在处理当前线程

00:10:02.680 --> 00:10:10.480
有很多方法可以做到这一点

00:10:05.769 --> 00:10:12.130
很多方法可以做到这一点，但是你可以

00:10:10.480 --> 00:10:15.060
自己创建一个线程并移动它

00:10:12.130 --> 00:10:17.410
可以在后台使用

00:10:15.060 --> 00:10:19.959
推迟，或者你知道你没有承诺

00:10:17.410 --> 00:10:22.510
 api或可计算的期货之类的东西

00:10:19.959 --> 00:10:24.040
那当然也很好

00:10:22.510 --> 00:10:25.930
这个问题，你甚至可以使用

00:10:24.040 --> 00:10:27.220
反应类型不错，我很喜欢

00:10:25.930 --> 00:10:28.839
反应型显然你看到我

00:10:27.220 --> 00:10:32.829
谈论很多

00:10:28.839 --> 00:10:35.620
这些类型是我们实际使用的

00:10:32.829 --> 00:10:37.870
这些反应类型，但我们要使用

00:10:35.620 --> 00:10:39.820
他们通过此教练API可以

00:10:37.870 --> 00:10:42.310
例程是他们给我们一种方法

00:10:39.820 --> 00:10:46.029
告诉语言，嘿，这件事

00:10:42.310 --> 00:10:49.829
我想异步运行，但我

00:10:46.029 --> 00:10:52.089
想要恢复执行代码为

00:10:49.829 --> 00:10:54.519
虽然我正在同步运行

00:10:52.089 --> 00:10:59.019
运作的方式是当你

00:10:54.519 --> 00:11:04.510
创建一个函数，假设您知道

00:10:59.019 --> 00:11:06.579
像这样的东西异步

00:11:04.510 --> 00:11:10.910
这不是教练吗？ 

00:11:06.579 --> 00:11:14.600
执行此操作时出现的吊带碗

00:11:10.910 --> 00:11:19.060
然后你说好

00:11:14.600 --> 00:11:22.460
哇等于1然后你说嗯

00:11:19.060 --> 00:11:24.950
返回字符串你知道

00:11:22.460 --> 00:11:31.130
我只是得到像这样的假东西

00:11:24.950 --> 00:11:33.730
好的，你好，你说Val消息等于

00:11:31.130 --> 00:11:38.120
做的是异步的，然后你说

00:11:33.730 --> 00:11:40.130
如果您要运行此值，则等于

00:11:38.120 --> 00:11:42.640
代码什么都不会是

00:11:40.130 --> 00:11:44.660
特别的，但是你可以运行这个

00:11:42.640 --> 00:11:48.140
好吧，在这种情况下您不需要

00:11:44.660 --> 00:11:51.440
可以在单独的线程上运行

00:11:48.140 --> 00:11:54.680
当然我想在这里发生的是你

00:11:51.440 --> 00:11:56.270
知道你好，我什么参数

00:11:54.680 --> 00:11:58.250
想要发生的是，我们做到了

00:11:56.270 --> 00:12:02.510
代码中的一行，然后我们进入

00:11:58.250 --> 00:12:04.610
行，然后此代码将此主要

00:12:02.510 --> 00:12:07.730
您知道的所有方法

00:12:04.610 --> 00:12:11.300
目的就止于此

00:12:07.730 --> 00:12:13.940
发生是执行移至此

00:12:11.300 --> 00:12:19.340
日期做一些异步的事情

00:12:13.940 --> 00:12:21.140
异步功能和状态

00:12:19.340 --> 00:12:22.730
我们在这里要做的事情

00:12:21.140 --> 00:12:26.480
在这里打印所有东西之后

00:12:22.730 --> 00:12:30.170
知道打印线等等，你知道的一切

00:12:26.480 --> 00:12:36.440
东西被包裹在lambda中了

00:12:30.170 --> 00:12:40.670
像这样的Val回调还可以吧

00:12:36.440 --> 00:12:42.710
正确的权限，此回调被传递

00:12:40.670 --> 00:12:45.500
进入这个功能

00:12:42.710 --> 00:12:48.080
所以真的就是这样的编译器

00:12:45.500 --> 00:12:51.320
希望我们通过为我们编写这段代码来

00:12:48.080 --> 00:12:55.100
它传入回调，然后

00:12:51.320 --> 00:12:59.930
然后在函数完成之后

00:12:55.100 --> 00:13:04.970
确保我们知道

00:12:59.930 --> 00:13:07.550
写一个正确的字符串

00:13:04.970 --> 00:13:10.100
确保在我们完成后

00:13:07.550 --> 00:13:13.850
这里的业务逻辑

00:13:10.100 --> 00:13:16.370
我们正在努力做到这一点

00:13:13.850 --> 00:13:19.400
回调并允许它完成

00:13:16.370 --> 00:13:22.400
在这条线之后，所以效果是

00:13:19.400 --> 00:13:28.880
那不是我很抱歉

00:13:22.400 --> 00:13:31.100
你知道那的效果是

00:13:28.880 --> 00:13:34.339
从我们的角度来看我们

00:13:31.100 --> 00:13:36.400
正在写的东西

00:13:34.339 --> 00:13:41.870
这样看起来像这样执行

00:13:36.400 --> 00:13:44.600
然后我做了一些异步的事情

00:13:41.870 --> 00:13:46.400
然后只有Val V等于2 

00:13:44.600 --> 00:13:48.770
和打印行发生在

00:13:46.400 --> 00:13:50.630
该命令，但实际上是什么

00:13:48.770 --> 00:13:52.370
发生的是有这种幻想

00:13:50.630 --> 00:13:54.680
状态被传递到

00:13:52.370 --> 00:13:56.600
功能，并在以后保留

00:13:54.680 --> 00:13:59.510
像逻辑这样的业务就完成了

00:13:56.600 --> 00:14:01.430
被叫，然后你知道看起来像

00:13:59.510 --> 00:14:03.500
它回到了你开始的地方

00:14:01.430 --> 00:14:05.779
你之前有三行

00:14:03.500 --> 00:14:07.250
按照你在那里的顺序

00:14:05.779 --> 00:14:09.140
还是很像三行

00:14:07.250 --> 00:14:11.089
感觉这里有些逻辑

00:14:09.140 --> 00:14:13.339
然后说对了，B就是这个

00:14:11.089 --> 00:14:15.350
那会发生的，那很棒

00:14:13.339 --> 00:14:17.180
对的，我正在使用的那个状态

00:14:15.350 --> 00:14:18.830
一个lambda来证明这个想法

00:14:17.180 --> 00:14:20.810
在这里，但这被称为延续

00:14:18.830 --> 00:14:22.970
对，实际上是一个物体

00:14:20.810 --> 00:14:24.710
当编译器为您插入

00:14:22.970 --> 00:14:26.089
看到您具有的功能

00:14:24.710 --> 00:14:29.300
应该暂停

00:14:26.089 --> 00:14:32.529
现在这并没有暂停我刚刚

00:14:29.300 --> 00:14:34.970
告诉你这里实际上并没有暂停

00:14:32.529 --> 00:14:36.620
为了告诉编译器

00:14:34.970 --> 00:14:39.290
首先要暂停

00:14:36.620 --> 00:14:41.600
你必须用全部暂停标记

00:14:39.290 --> 00:14:44.990
对，这是一个漂亮的立方体，现在您可以

00:14:41.600 --> 00:14:46.430
看到这里没有什么你

00:14:44.990 --> 00:14:48.080
可以看出这不是特别的权利

00:14:46.430 --> 00:14:50.450
其实我还没做

00:14:48.080 --> 00:14:52.459
暂停的任何东西，以及

00:14:50.450 --> 00:14:55.339
原因是因为如果我要跑步

00:14:52.459 --> 00:14:57.200
耗时的权利

00:14:55.339 --> 00:14:58.910
在这段代码中，它会坐在那里

00:14:57.200 --> 00:15:00.709
挡住它就像坐在那里

00:14:58.910 --> 00:15:03.830
还有其他如果我尝试做线程

00:15:00.709 --> 00:15:05.839
例如点睡眠，你可以看到

00:15:03.830 --> 00:15:08.089
该工具会告诉我哦，那不是

00:15:05.839 --> 00:15:10.339
很好，使用不当，我也是

00:15:08.089 --> 00:15:12.890
返回那里是不适当的使用

00:15:10.339 --> 00:15:14.120
 API的作用，但实际上是结果

00:15:12.890 --> 00:15:16.490
如果你曾经是

00:15:14.120 --> 00:15:18.140
即使这样也可以调用此代码

00:15:16.490 --> 00:15:21.740
这是暂停的标记

00:15:18.140 --> 00:15:27.740
对，您要做的就是

00:15:21.740 --> 00:15:29.860
与上下文一起使用对不起，上下文是

00:15:27.740 --> 00:15:29.860
它

00:15:32.129 --> 00:15:41.919
您必须使用上下文

00:15:40.569 --> 00:15:43.600
我必须得到一些东西的名字

00:15:41.919 --> 00:15:45.009
 API并没有那么重要

00:15:43.600 --> 00:15:47.470
真的不想投入太多

00:15:45.009 --> 00:15:51.910
那，但是你必须使用一些东西

00:15:47.470 --> 00:15:54.129
教运行时如何做这件事

00:15:51.910 --> 00:15:55.480
异步对，你怎么样

00:15:54.129 --> 00:15:56.470
你如何弄清楚你什么时候

00:15:55.480 --> 00:15:57.730
你如何弄清楚如何开始

00:15:56.470 --> 00:15:59.829
以及你如何看待它的外观

00:15:57.730 --> 00:16:01.509
就像完成时那样，我认为

00:15:59.829 --> 00:16:03.189
它被称为上下文或其他

00:16:01.509 --> 00:16:04.959
这样的结果是你

00:16:03.189 --> 00:16:06.069
实际上教你

00:16:04.959 --> 00:16:08.439
教运行时如何做到这一点

00:16:06.069 --> 00:16:09.999
阻碍你教学的东西

00:16:08.439 --> 00:16:11.079
它可以在哪个部分启动

00:16:09.999 --> 00:16:12.819
背景以及什么时候

00:16:11.079 --> 00:16:14.499
完成后就可以拍摄了

00:16:12.819 --> 00:16:16.779
作为异步事物， 

00:16:14.499 --> 00:16:17.980
您也可以将其移至线程

00:16:16.779 --> 00:16:20.529
基本上，您将其移动到

00:16:17.980 --> 00:16:25.749
安排时间，以便与上下文相关的事物

00:16:20.529 --> 00:16:26.949
这样做对您来说是正确的，所以大多数

00:16:25.749 --> 00:16:29.769
时间，您不必担心

00:16:26.949 --> 00:16:30.609
您将不必希望大部分

00:16:29.769 --> 00:16:32.559
时间你不用担心

00:16:30.609 --> 00:16:34.989
如何使事物同步

00:16:32.559 --> 00:16:37.899
通过此适配器感到异步

00:16:34.989 --> 00:16:40.419
代码重要的是要理解的是

00:16:37.899 --> 00:16:42.579
有很多功能

00:16:40.419 --> 00:16:44.829
您可以在Kotlin中进行的API调用的数量

00:16:42.579 --> 00:16:46.689
在Kotlin X和春季在

00:16:44.829 --> 00:16:47.439
将军已经支持并执行

00:16:46.689 --> 00:16:50.439
这个给你

00:16:47.439 --> 00:16:52.419
所以反应堆代码使用

00:16:50.439 --> 00:16:54.669
使用这些东西的发布者

00:16:52.419 --> 00:16:56.379
是你可以开始，然后你那个

00:16:54.669 --> 00:16:58.449
有自己的方式来完成你认识你

00:16:56.379 --> 00:17:01.959
您可以订阅并获得结果吗

00:16:58.449 --> 00:17:05.319
他们发射出我们可以的物品

00:17:01.959 --> 00:17:08.230
通常使发布者适应

00:17:05.319 --> 00:17:12.100
看起来像吊带的东西

00:17:08.230 --> 00:17:13.630
通用功能，所以我们完成了

00:17:12.100 --> 00:17:14.980
为您自动写入

00:17:13.630 --> 00:17:17.260
整个过程中有很多不同的地方

00:17:14.980 --> 00:17:20.019
必应这样的生态系统

00:17:17.260 --> 00:17:22.899
支持很多它最初首次亮相

00:17:20.019 --> 00:17:24.220
在春季foo，我做了微框架

00:17:22.899 --> 00:17:26.799
一会儿的 Spring 提示视频

00:17:24.220 --> 00:17:30.490
以及春季foo看了很多

00:17:26.799 --> 00:17:31.990
这些不同的api，而我不是

00:17:30.490 --> 00:17:33.580
不知道我们是否甚至对Cortines感兴趣

00:17:31.990 --> 00:17:35.320
在那里，但关键是它非常容易

00:17:33.580 --> 00:17:37.269
与秘密团队合作，现在你

00:17:35.320 --> 00:17:39.879
有点了解你的想法

00:17:37.269 --> 00:17:41.920
得到了这个可以暂停的关键字

00:17:39.879 --> 00:17:45.520
用于也可以进行实习的功能

00:17:41.920 --> 00:17:47.230
所有阻止你的事情

00:17:45.520 --> 00:17:48.190
知道现在你有我想我希望

00:17:47.230 --> 00:17:49.630
你对可能的想法

00:17:48.190 --> 00:17:51.760
现在让我们来看一下

00:17:49.630 --> 00:17:54.160
在实践中，让我们写一些基本的

00:17:51.760 --> 00:17:57.040
协同程序代码以了解什么

00:17:54.160 --> 00:17:58.690
假设我要启动一些

00:17:57.040 --> 00:18:02.530
异步行为好，所以我要

00:17:58.690 --> 00:18:05.740
注意，让我们实际创建一堆

00:18:02.530 --> 00:18:08.020
在这里功能一个，我会说一个好

00:18:05.740 --> 00:18:09.480
我会说mmm我想耽误你

00:18:08.020 --> 00:18:13.090
今天想打电话给我

00:18:09.480 --> 00:18:14.980
非阻塞线程睡眠好

00:18:13.090 --> 00:18:18.900
所以我要睡一个

00:18:14.980 --> 00:18:21.370
第二可以，但是为了打电话

00:18:18.900 --> 00:18:23.080
这是编译器错误，说嘿

00:18:21.370 --> 00:18:26.050
你做不到，你需要调用它

00:18:23.080 --> 00:18:27.790
从KO例行程序或其他暂停中

00:18:26.050 --> 00:18:29.890
好吧，我要在

00:18:27.790 --> 00:18:34.840
我要说的是蛋白质的整体背景

00:18:29.890 --> 00:18:36.460
范围点束，然后这样

00:18:34.840 --> 00:18:37.570
现在我叫午餐，如果你看

00:18:36.460 --> 00:18:39.850
午餐文件

00:18:37.570 --> 00:18:41.710
这只是发射它只是发射一个

00:18:39.850 --> 00:18:43.300
新的Co例程而不会阻塞

00:18:41.710 --> 00:18:45.640
当前线程，它返回一个

00:18:43.300 --> 00:18:52.000
参考作为工作好吧，所以我实际上

00:18:45.640 --> 00:18:54.850
 Val工作为什么我不能工作

00:18:52.000 --> 00:18:56.770
好吧，现在我可以说它取消了

00:18:54.850 --> 00:18:58.720
可以取消，如果我想取消

00:18:56.770 --> 00:19:00.370
加入吧，我可以取消像

00:18:58.720 --> 00:19:04.270
我可以做的其他代码青少年

00:19:00.370 --> 00:19:05.800
如果我想在这里各种各样的事情

00:19:04.270 --> 00:19:07.030
在哪种情况下它会停止，所以

00:19:05.800 --> 00:19:09.310
有趣的是，现在您已经

00:19:07.030 --> 00:19:12.220
停止异步的方式

00:19:09.310 --> 00:19:14.260
事情虽然已经完成了

00:19:12.220 --> 00:19:17.140
一些有趣的东西，让我们看看

00:19:14.260 --> 00:19:21.370
没关系，我要结束

00:19:17.140 --> 00:19:24.370
好的，我要记录一下结果

00:19:21.370 --> 00:19:27.280
然后我会注意到我要开始

00:19:24.370 --> 00:19:29.460
好的，让我们看看它的外观

00:19:27.280 --> 00:19:29.460
喜欢

00:19:43.900 --> 00:19:59.120
好的，我开始做某事

00:19:56.750 --> 00:20:00.680
哦，你不需要这么做

00:19:59.120 --> 00:20:03.980
知道发生了什么我知道发生了什么

00:20:00.680 --> 00:20:05.630
这是异步的，很明显，所以我

00:20:03.980 --> 00:20:07.550
将使程序成为一般

00:20:05.630 --> 00:20:09.320
不管我做什么事

00:20:07.550 --> 00:20:11.030
他们睡了十秒钟

00:20:09.320 --> 00:20:13.130
这样就不会杀死

00:20:11.030 --> 00:20:14.690
任何八个异步之前的进程

00:20:13.130 --> 00:20:18.530
优秀的线程有机会

00:20:14.690 --> 00:20:21.710
开始运行，所以我们此时开始

00:20:18.530 --> 00:20:25.430
好，七点钟

00:20:21.710 --> 00:20:28.760
三分十五秒

00:20:25.430 --> 00:20:32.090
我们期待它入睡哦，我

00:20:28.760 --> 00:20:34.040
实际上让它睡了十秒钟，所以

00:20:32.090 --> 00:20:35.540
它实际上跑了更长的时间，因为我们

00:20:34.040 --> 00:20:36.860
一般只给了十秒钟

00:20:35.540 --> 00:20:42.170
我应该把这个设为20 

00:20:36.860 --> 00:20:43.670
我再次犯了这个错误

00:20:42.170 --> 00:20:45.680
你去那里我可以看到它实际上

00:20:43.670 --> 00:20:46.760
完成，让我们组成20您可以看到

00:20:45.680 --> 00:20:48.290
它在另一个线程中完成

00:20:46.760 --> 00:20:50.990
好吧，这很简单

00:20:48.290 --> 00:20:52.280
对，我的意思是我要在这里启动代码

00:20:50.990 --> 00:20:54.500
如果我有一些东西

00:20:52.280 --> 00:20:57.590
暂停，我可以在其中启动它

00:20:54.500 --> 00:20:58.760
好的，那就是那一件事

00:20:57.590 --> 00:21:01.460
让我们看另一个例子

00:20:58.760 --> 00:21:03.140
 -好的，我要继续创造

00:21:01.460 --> 00:21:07.270
功能之内的功能，因为它

00:21:03.140 --> 00:21:07.270
苏格兰，这就是我现在所能拥有的一切

00:21:08.470 --> 00:21:13.520
如果我想让你看到

00:21:11.180 --> 00:21:15.620
在这种情况下，这是第一

00:21:13.520 --> 00:21:16.880
显然是异步的，就像

00:21:15.620 --> 00:21:20.480
线程就像我创建了一个新线程

00:21:16.880 --> 00:21:22.610
它停止了

00:21:20.480 --> 00:21:27.470
你知道我开始后就完成了

00:21:22.610 --> 00:21:29.750
 Facebook，但是如果我想要事情怎么办

00:21:27.470 --> 00:21:31.120
像我想要ABC一样线性运行

00:21:29.750 --> 00:21:33.710
希望能够说出这个

00:21:31.120 --> 00:21:36.920
异步运行ABC 

00:21:33.710 --> 00:21:38.720
我可以使用运行阻止，这就是

00:21:36.920 --> 00:21:42.680
我会在主要代码中使用这是

00:21:38.720 --> 00:21:44.570
适应代码暂停的好方法

00:21:42.680 --> 00:21:45.920
正确的主代码，您可能会

00:21:44.570 --> 00:21:47.300
在您的顶层使用此

00:21:45.920 --> 00:21:50.330
应用程序，然后一切

00:21:47.300 --> 00:21:52.780
那是暂停功能，所以我在这里

00:21:50.330 --> 00:22:00.160
要说笔记

00:21:52.780 --> 00:22:01.350
开始好吧，请注意停止，然后在这里

00:22:00.160 --> 00:22:08.770
我要在这里做

00:22:01.350 --> 00:22:13.980
延迟两秒钟，然后运行音符

00:22:08.770 --> 00:22:19.750
阻挡让我们全心全意阻挡终点， 

00:22:13.980 --> 00:22:23.430
开始好吧，那我们需要跑哦

00:22:19.750 --> 00:22:23.430
我必须调用它

00:22:30.330 --> 00:22:34.020
好的，所以开始阻止开始阻止

00:22:33.420 --> 00:22:37.220
结束

00:22:34.020 --> 00:22:41.660
对，所以我在阻塞端

00:22:37.220 --> 00:22:47.940
今天发生了，所以我可以看到它说

00:22:41.660 --> 00:22:50.190
 29等等等等然后31好吧，我睡了

00:22:47.940 --> 00:22:52.320
持续两秒钟，然后完成

00:22:50.190 --> 00:22:54.600
这种情况下所有东西都是线性的

00:22:52.320 --> 00:22:56.250
然后线性，他们实际上会继续

00:22:54.600 --> 00:22:58.440
好像我们要他们纠正

00:22:56.250 --> 00:22:59.850
很好，实际上给了

00:22:58.440 --> 00:23:01.230
你有能力强迫事物

00:22:59.850 --> 00:23:03.570
如果碰巧按一定顺序坐下

00:23:01.230 --> 00:23:05.780
你现在不确定他们呢

00:23:03.570 --> 00:23:12.480
三个有趣的下一个例子是什么

00:23:05.780 --> 00:23:14.760
三个我们要看一个水槽

00:23:12.480 --> 00:23:17.790
好吧，让我们说我有一堆

00:23:14.760 --> 00:23:19.530
我想把它们加起来

00:23:17.790 --> 00:23:20.910
好的，这是我从中得到的一个例子

00:23:19.530 --> 00:23:22.830
我认为文档相当

00:23:20.910 --> 00:23:29.670
说明性的，我会为你做的

00:23:22.830 --> 00:23:33.150
所以递延等于一百万还可以

00:23:29.670 --> 00:23:34.860
所以我要总结我每个人

00:23:33.150 --> 00:23:36.720
要创建一个范围，这是常见的

00:23:34.860 --> 00:23:38.940
用于创建范围1到a的语法

00:23:36.720 --> 00:23:41.310
万个数字好，然后我要

00:23:38.940 --> 00:23:44.220
映射每个地图，在Kotlin中

00:23:41.310 --> 00:23:45.420
像这样指定一辆婴儿车

00:23:44.220 --> 00:23:47.790
可以只使用每个隐式变量

00:23:45.420 --> 00:23:51.440
这是因为包括例如

00:23:47.790 --> 00:23:51.440
我想做的就是我要回来

00:23:52.640 --> 00:24:00.930
每个项目每个数字都可以

00:23:57.560 --> 00:24:02.910
我要睡一秒钟所以让我

00:24:00.930 --> 00:24:06.870
只是退还他们，但在我这样做之前

00:24:02.910 --> 00:24:10.740
我要睡一秒钟

00:24:06.870 --> 00:24:13.490
当然要睡觉我需要我

00:24:10.740 --> 00:24:16.200
需要异步运行此代码哦

00:24:13.490 --> 00:24:17.670
对，所以实际上让我们尝试一下

00:24:16.200 --> 00:24:20.220
尝试做线程，睡觉什么

00:24:17.670 --> 00:24:20.760
发生在你身上好吧，如果我做一个线程

00:24:20.220 --> 00:24:23.370
在睡觉

00:24:20.760 --> 00:24:25.440
将会发生什么我要去

00:24:23.370 --> 00:24:29.400
然后经过这个范围我

00:24:25.440 --> 00:24:31.290
要说推迟点再见

00:24:29.400 --> 00:24:36.000
我要说再见

00:24:31.290 --> 00:24:39.690
好吧，结果是

00:24:36.000 --> 00:24:41.270
总和将是所有的总和

00:24:39.690 --> 00:24:43.220
这些数字涉及

00:24:41.270 --> 00:24:45.380
我只是要成为一个自我

00:24:43.220 --> 00:24:48.170
只是说要接受并添加正确

00:24:45.380 --> 00:24:52.640
我不会做别的事情，所以

00:24:48.170 --> 00:24:53.630
事情中的每个数字都很好

00:24:52.640 --> 00:24:55.490
这意味着首先看起来像什么

00:24:53.630 --> 00:24:57.650
所有这意味着它将创造一个

00:24:55.490 --> 00:24:59.180
百万数字，每次趋向

00:24:57.650 --> 00:25:00.590
睡一秒钟我没有那种

00:24:59.180 --> 00:25:02.810
时间我没有一百万秒

00:25:00.590 --> 00:25:04.130
等待这个结果好吧，所以我

00:25:02.810 --> 00:25:06.080
甚至都不会为这个而烦恼

00:25:04.130 --> 00:25:10.520
您，我们可以，我们现在可以运行它

00:25:06.080 --> 00:25:19.090
可以尝试一些我们永远不会得到的笔记

00:25:10.520 --> 00:25:19.090
在时间之前就可以了

00:25:20.840 --> 00:25:27.409
好吧，那不是一个好习惯

00:25:26.149 --> 00:25:29.029
这不是一个伟大的结果，我们

00:25:27.409 --> 00:25:30.379
不喜欢这里发生的事情，但是

00:25:29.029 --> 00:25:34.850
我让它运行半秒钟或

00:25:30.379 --> 00:25:37.159
两个或五个或任何东西，如果可以的话

00:25:34.850 --> 00:25:38.149
甚至听到我的电脑在挣扎

00:25:37.159 --> 00:25:44.029
因为它不喜欢什么

00:25:38.149 --> 00:25:45.889
发生了，好吧，是的

00:25:44.029 --> 00:25:49.370
对吧，现在如果我想这样做

00:25:45.889 --> 00:25:51.769
如果我想增加一百万怎么办

00:25:49.370 --> 00:25:55.129
一百万秒，但我想

00:25:51.769 --> 00:25:57.259
做这个异步，这样我睡觉

00:25:55.129 --> 00:26:00.230
但我看到没有阻止父母

00:25:57.259 --> 00:26:07.490
在这种情况下，我可以全局

00:26:00.230 --> 00:26:08.690
范围点异步，这里我的意思是

00:26:07.490 --> 00:26:10.940
使用线程睡眠的

00:26:08.690 --> 00:26:13.129
已经建立不适合我

00:26:10.940 --> 00:26:17.749
我要做的就是整个区域

00:26:13.129 --> 00:26:23.779
我没有返回好，现在呢

00:26:17.749 --> 00:26:27.970
我现在得到的是推迟的结果

00:26:23.779 --> 00:26:31.220
调用异步是类型T的延迟

00:26:27.970 --> 00:26:32.720
好，这样才能获得价值

00:26:31.220 --> 00:26:35.570
现在，现在我所拥有的现在，现在我所拥有的

00:26:32.720 --> 00:26:38.899
是一个延迟序列，因此

00:26:35.570 --> 00:26:41.799
我需要称重的每个值都可以

00:26:38.899 --> 00:26:46.519
但是当然是为了称重

00:26:41.799 --> 00:26:48.289
我需要成为代码团队的一员

00:26:46.519 --> 00:26:50.690
正确的即时通讯使用延期我需要

00:26:48.289 --> 00:26:51.649
还要在代码团队内部运行

00:26:50.690 --> 00:26:57.320
我要站在一边我要说

00:26:51.649 --> 00:26:59.840
运行阻止，所以现在发生了什么

00:26:57.320 --> 00:27:02.450
我有一个延期的收藏

00:26:59.840 --> 00:27:05.749
参观一百万件物品，我要

00:27:02.450 --> 00:27:07.519
创建一百万个不是线程的权利

00:27:05.749 --> 00:27:09.139
轻质纤维那种你不知道

00:27:07.519 --> 00:27:10.669
我当然不想的线程

00:27:09.139 --> 00:27:14.059
在这台机器上创建一百万个线程

00:27:10.669 --> 00:27:16.539
哦，我需要打三个电话，看看

00:27:14.059 --> 00:27:16.539
我们能做到这一点

00:27:20.920 --> 00:27:23.640
所以

00:27:25.380 --> 00:27:30.630
好，结果就是数字

00:27:27.960 --> 00:27:32.400
正确，如果您使用一百万个数字

00:27:30.630 --> 00:27:33.990
将它们加在一起，您就正确了， 

00:27:32.400 --> 00:27:38.250
并没有花很长时间

00:27:33.990 --> 00:27:40.410
 10 20到24，所以2 2秒继续前进

00:27:38.250 --> 00:27:42.870
上的许多载体线程

00:27:40.410 --> 00:27:44.070
 JVM上的操作系统不是

00:27:42.870 --> 00:27:44.340
如果创造一百万个，则变成一百万个

00:27:44.070 --> 00:27:46.320
那些

00:27:44.340 --> 00:27:47.880
它只是非常有效地继续工作

00:27:46.320 --> 00:27:50.100
然后关闭线程，这样我就可以

00:27:47.880 --> 00:27:53.070
尽快完成一百万件事

00:27:50.100 --> 00:27:56.400
而且因为它有这个异步

00:27:53.070 --> 00:27:59.070
涂料在这里，因为你知道我们使用

00:27:56.400 --> 00:28:01.669
此版本的非阻塞版本

00:27:59.070 --> 00:28:05.549
睡一觉就睡着了

00:28:01.669 --> 00:28:06.690
告诉运行时，嘿，我不再使用

00:28:05.549 --> 00:28:09.750
这个线程可以被其他人使用

00:28:06.690 --> 00:28:11.640
所以当你知道当一个人终于

00:28:09.750 --> 00:28:13.350
到一百万，最后一个

00:28:11.640 --> 00:28:14.640
一秒钟就得到了线程

00:28:13.350 --> 00:28:15.809
并能够释放自己， 

00:28:14.640 --> 00:28:17.610
 Tamayo她能够使用它，依此类推

00:28:15.809 --> 00:28:20.490
所以它只是一直保持这样快

00:28:17.610 --> 00:28:22.080
这意味着所有

00:28:20.490 --> 00:28:23.070
计算只花了两秒钟

00:28:22.080 --> 00:28:27.919
那很方便

00:28:23.070 --> 00:28:27.919
好的，那这个呢

00:28:30.860 --> 00:28:35.330
让我们现在看看我已经向您展示了

00:28:33.320 --> 00:28:39.019
使用延期和延期很棒

00:28:35.330 --> 00:28:40.250
对于单个值数据，可以单个

00:28:39.019 --> 00:28:41.809
您要返回的数据的值

00:28:40.250 --> 00:28:44.419
有点像一个完整的

00:28:41.809 --> 00:28:45.740
未来，但它适用于涂料

00:28:44.419 --> 00:28:47.510
你会看到我们也一样

00:28:45.740 --> 00:28:49.399
异步的好处

00:28:47.510 --> 00:28:51.320
编程，但我们并没有真正处理

00:28:49.399 --> 00:28:53.000
非常复杂，我们如何

00:28:51.320 --> 00:28:54.830
做倒计时比赛或循环

00:28:53.000 --> 00:28:57.140
障碍或诸如信号量之类的东西

00:28:54.830 --> 00:28:59.029
好的，所以现在我要看看

00:28:57.140 --> 00:29:00.529
另一个例子，我们现在要

00:28:59.029 --> 00:29:06.080
看看我该如何解决

00:29:00.529 --> 00:29:08.440
拥有大量数据，显然是

00:29:06.080 --> 00:29:10.730
一个非常简单的例子就是

00:29:08.440 --> 00:29:13.039
反应式代码就可以让您成为发布者

00:29:10.730 --> 00:29:15.769
但默认情况下，发布商不知道

00:29:13.039 --> 00:29:18.250
他们不知道如何通过共同例程

00:29:15.769 --> 00:29:20.299
默认-他们不，他们看起来不

00:29:18.250 --> 00:29:23.090
同步在那里

00:29:20.299 --> 00:29:24.679
很明显这种病

00:29:23.090 --> 00:29:26.330
那里的行为，所以你不能写

00:29:24.679 --> 00:29:28.370
看起来像同步的代码

00:29:26.330 --> 00:29:32.450
阻止代码，所以我现在要做什么

00:29:28.370 --> 00:29:37.840
我要介绍一种新型的

00:29:32.450 --> 00:29:46.460
叫做流程还行，所以这里很有趣，四个

00:29:37.840 --> 00:29:48.919
这将是四，我会说我

00:29:46.460 --> 00:29:52.220
想要有一个整数集合

00:29:48.919 --> 00:29:53.720
流事件还可以，这是另一个

00:29:52.220 --> 00:29:56.059
例如，我认为我从

00:29:53.720 --> 00:29:57.320
文档或罗马和

00:29:56.059 --> 00:30:00.139
这些都关闭了，所以很棒的视频博客

00:29:57.320 --> 00:30:02.720
值得一游的方式，所以流程很亲切

00:30:00.139 --> 00:30:05.029
像发布者一样，但具有代码提示

00:30:02.720 --> 00:30:06.289
好，所以我要创建一个浮动

00:30:05.029 --> 00:30:09.320
要创建一个流程，我要

00:30:06.289 --> 00:30:11.120
向该流程中发送值，我可以做

00:30:09.320 --> 00:30:12.980
无论我想要什么节奏

00:30:11.120 --> 00:30:15.590
非常类似于使用助焊剂板条箱和反应堆

00:30:12.980 --> 00:30:17.000
墙我正在创造一个东西， 

00:30:15.590 --> 00:30:23.049
定期散发价值，所以我要

00:30:17.000 --> 00:30:23.049
在110声中为我说声

00:30:23.590 --> 00:30:33.909
好吧，我要睡一会儿

00:30:29.429 --> 00:30:37.450
在每个之间，然后我将省略

00:30:33.909 --> 00:30:39.429
项目，现在我有一个流程

00:30:37.450 --> 00:30:41.409
它要有十个项目，我是

00:30:39.429 --> 00:30:42.399
现在要遍历，但是

00:30:41.409 --> 00:30:44.830
为了做到这一点，我需要做的

00:30:42.399 --> 00:30:51.399
这和这里的胶层适配器

00:30:44.830 --> 00:30:56.429
我会说开始收集

00:30:51.399 --> 00:30:56.429
注销涂料数据，因此请注意

00:30:57.330 --> 00:31:04.110
好东西，我们将呼吁

00:31:22.950 --> 00:31:31.559
好的，所以我们正在这样做，实际上

00:31:27.629 --> 00:31:32.879
访问您知道的数据

00:31:31.559 --> 00:31:34.739
实际创建一个发出数据的流

00:31:32.879 --> 00:31:36.029
定期关于这件事的好处

00:31:34.739 --> 00:31:38.489
即使需要时间

00:31:36.029 --> 00:31:40.350
再一次，我们不知道那不是什么

00:31:38.489 --> 00:31:42.809
一定我们不坐在那里

00:31:40.350 --> 00:31:44.039
那个线程浪费了那个线程，所以

00:31:42.809 --> 00:31:46.169
没有人可以使用它，我们可以下车

00:31:44.039 --> 00:31:47.820
那个线程权利就是好处

00:31:46.169 --> 00:31:48.929
在这种情况下，这是主线程

00:31:47.820 --> 00:31:51.149
但是想像一下

00:31:48.929 --> 00:31:52.499
您想摆脱的第三个泳池

00:31:51.149 --> 00:31:54.570
在雨滴之间

00:31:52.499 --> 00:31:56.220
之间的新数据的发射等

00:31:54.570 --> 00:31:57.809
你想要其他的东西能够

00:31:56.220 --> 00:31:59.549
现在可以重复使用，因为

00:31:57.809 --> 00:32:12.419
延迟不会阻止客户端线程

00:31:59.549 --> 00:32:14.759
我认为这里的电话打印好五个

00:32:12.419 --> 00:32:17.309
现在是时候让我们看看这一切

00:32:14.759 --> 00:32:18.600
玩到 Spring 好吧，我想做

00:32:17.309 --> 00:32:19.919
虽然我们要创建一些

00:32:18.600 --> 00:32:23.369
正确的数据，我们要退出一些数据

00:32:19.919 --> 00:32:27.350
将以正常方式启动

00:32:23.369 --> 00:32:31.259
所以我们先说五个好吧

00:32:27.350 --> 00:32:36.929
我们将创建一个数据类调用

00:32:31.259 --> 00:32:43.619
关于ID int名称字符串的保留

00:32:36.929 --> 00:32:49.460
好的，哇，名字字符串，我们要

00:32:43.619 --> 00:32:49.460
有一个班级预订仓库

00:32:49.519 --> 00:32:54.049
好吧哇

00:32:55.269 --> 00:33:06.470
戴维斯（Davis）安静的DBC不错，好东西

00:33:04.220 --> 00:33:08.629
好吧，现在我要有一个存储库

00:33:06.470 --> 00:33:10.279
那将使用r2 DC 

00:33:08.629 --> 00:33:11.059
 Davies客户我应该将其设为私有

00:33:10.279 --> 00:33:13.070
那很好

00:33:11.059 --> 00:33:16.690
好的做法，它将有一个

00:33:13.070 --> 00:33:18.679
使用数据库客户端和

00:33:16.690 --> 00:33:20.809
现在我要使用的是

00:33:18.679 --> 00:33:22.100
戴维斯客户请我续集

00:33:20.809 --> 00:33:23.480
我毕业的数据存储

00:33:22.100 --> 00:33:25.909
编写我们需要的背景

00:33:23.480 --> 00:33:27.379
配置一个连接工厂，所以我

00:33:25.909 --> 00:33:28.609
将运行我的屏幕良好的应用程序

00:33:27.379 --> 00:33:35.019
我们将提供一些配置

00:33:28.609 --> 00:33:35.019
在这里大约几分钟就可以了

00:33:41.330 --> 00:33:48.919
好吧，让我们看看这里会退出beans

00:33:45.279 --> 00:33:50.149
使用DSL和Cottman实现功能

00:33:48.919 --> 00:33:51.499
您不必使用的团队定义

00:33:50.149 --> 00:33:53.539
这你可以使用Java配置或任何

00:33:51.499 --> 00:33:55.009
但是当我穿棉布的时候我很喜欢

00:33:53.539 --> 00:33:56.720
陷入世界，所以我要创造

00:33:55.009 --> 00:34:02.440
在这里连接工厂的光束

00:33:56.720 --> 00:34:07.179
连接工厂连接工厂

00:34:02.440 --> 00:34:09.290
点了，我将参考我的

00:34:07.179 --> 00:34:13.879
春季铁水环境

00:34:09.290 --> 00:34:17.210
并拔出这里称为

00:34:13.879 --> 00:34:18.679
Spring 点是两个DB c WR l， 

00:34:17.210 --> 00:34:22.599
可能是众所周知的，所以我需要强制

00:34:18.679 --> 00:34:24.829
所以我们意识到这个事实

00:34:22.599 --> 00:34:27.589
然后你走了，那是我的光芒

00:34:24.829 --> 00:34:29.929
我们TBC的连接工厂，我需要一个

00:34:27.589 --> 00:34:34.250
我们可能没有的预订库

00:34:29.929 --> 00:34:37.429
还是现在就完成，我会

00:34:34.250 --> 00:34:40.159
再次使用ref告诉它注入

00:34:37.429 --> 00:34:42.260
根据您的类型对另一个梁的引用

00:34:40.159 --> 00:34:44.569
可以根据我是否有推断

00:34:42.260 --> 00:34:46.579
批准的泛型参数

00:34:44.569 --> 00:34:48.109
这是戴维斯的客户，所以可以

00:34:46.579 --> 00:34:50.720
实际捕捉到这就像是

00:34:48.109 --> 00:34:52.639
能够捕获通用类型信息

00:34:50.720 --> 00:34:55.599
在Java中，您实际上无法做到，但是

00:34:52.639 --> 00:34:59.569
你可以以共同的权利做到这一点

00:34:55.599 --> 00:35:00.799
最后我们要创建一个

00:34:59.569 --> 00:35:05.059
 Web端点，我们将在一秒钟内完成

00:35:00.799 --> 00:35:09.530
但让我们摆脱的是，我要留下来

00:35:05.059 --> 00:35:11.089
在初始化器中哦，不，我们实际上需要

00:35:09.530 --> 00:35:14.210
运行应用程序，所以我会说运行

00:35:11.089 --> 00:35:19.880
应用程序和应用程序的

00:35:14.210 --> 00:35:21.319
 Coughlin型我开始涂涂料好了

00:35:19.880 --> 00:35:24.549
我们需要再次创建该主类

00:35:21.319 --> 00:35:24.549
所以我们开始

00:35:29.510 --> 00:35:41.670
冷套路的应用还可以吧

00:35:37.620 --> 00:35:43.200
好东西好吗

00:35:41.670 --> 00:35:48.660
那些beans有涂层

00:35:43.200 --> 00:35:50.460
应用程序以及我们需要的内部

00:35:48.660 --> 00:35:52.130
添加一个it adder初始化程序，那就是

00:35:50.460 --> 00:35:53.910
我们可以在其中传递beans的地方

00:35:52.130 --> 00:35:55.050
你知道的功能初始化器

00:35:53.910 --> 00:35:59.010
您的功能性均值注册

00:35:55.050 --> 00:36:00.930
大小调整器，现在完成了

00:35:59.010 --> 00:36:03.300
建立一个体育运动的仓库

00:36:00.930 --> 00:36:06.390
支持您知道

00:36:03.300 --> 00:36:07.800
我们的TBC数据库

00:36:06.390 --> 00:36:15.690
我要说的数据库暂停乐趣

00:36:07.800 --> 00:36:19.590
找到一个好的，我要说给

00:36:15.690 --> 00:36:22.050
 Spring 来了，我想要结果

00:36:19.590 --> 00:36:26.040
如果可能的话，现在保留

00:36:22.050 --> 00:36:27.870
常见的保留意见是

00:36:26.040 --> 00:36:30.240
知道是否要问他们一个问题

00:36:27.870 --> 00:36:33.030
标记，所以我要说我想要

00:36:30.240 --> 00:36:37.860
这是众所周知的，我要说我

00:36:33.030 --> 00:36:44.010
想执行查询，而我想

00:36:37.860 --> 00:36:50.820
找到续集，我会说“全选” 

00:36:44.010 --> 00:36:54.510
名称等于名称的保留

00:36:50.820 --> 00:37:02.340
好吧，当我绑定

00:36:54.510 --> 00:37:05.310
以参数名称命名，假设为

00:37:02.340 --> 00:37:07.620
类型，我想要这个，我要使用

00:37:05.310 --> 00:37:10.170
扩展功能在这里

00:37:07.620 --> 00:37:11.700
捕获那些通用信息，我就是

00:37:10.170 --> 00:37:14.280
现在要获取它返回的是

00:37:11.700 --> 00:37:16.470
提取规范和反应式世界

00:37:14.280 --> 00:37:18.120
你只说全部而已

00:37:16.470 --> 00:37:21.150
那会给你一个出版商

00:37:18.120 --> 00:37:23.700
保留好，但是我们正在使用

00:37:21.150 --> 00:37:26.370
棉花API，我们实际上可以使用这些

00:37:23.700 --> 00:37:29.490
扩展功能，包括一个或

00:37:26.370 --> 00:37:31.770
 null，实际上将采取此措施

00:37:29.490 --> 00:37:34.140
把它变成一个返回的东西

00:37:31.770 --> 00:37:35.790
解析为价值权，但是当

00:37:34.140 --> 00:37:37.260
有人称我们不是

00:37:35.790 --> 00:37:39.120
要坐在那里等待价值

00:37:37.260 --> 00:37:41.130
我意识到这实际上会触发

00:37:39.120 --> 00:37:43.380
线程的暂停和

00:37:41.130 --> 00:37:44.609
有趣，那么我们将继续， 

00:37:43.380 --> 00:37:46.410
我要继续下去

00:37:44.609 --> 00:37:48.779
延续，但我会过去

00:37:46.410 --> 00:37:50.849
所以此功能之前的内容

00:37:48.779 --> 00:37:53.880
呼叫之前有什么

00:37:50.849 --> 00:37:56.519
运作良好，我们将在之后接载

00:37:53.880 --> 00:37:58.369
就像完成一样完成

00:37:56.519 --> 00:38:01.289
在同一线程上好

00:37:58.369 --> 00:38:03.630
让我们找到一个有趣的东西

00:38:01.289 --> 00:38:09.750
对，一切都很好，这里我没有用

00:38:03.630 --> 00:38:11.009
我不会做的所有事情

00:38:09.750 --> 00:38:13.529
我要做的就是将其转换为流

00:38:11.009 --> 00:38:15.509
好吧，所以我想做的是

00:38:13.529 --> 00:38:19.880
从数据库中获取所有值

00:38:15.509 --> 00:38:25.079
会说DB C点选择来自

00:38:19.880 --> 00:38:28.769
保留点的类型和类型

00:38:25.079 --> 00:38:31.079
当然要预约，我在这里

00:38:28.769 --> 00:38:32.640
要把它变成流动，所以流动是

00:38:31.079 --> 00:38:35.609
我以前跟你说的那件事

00:38:32.640 --> 00:38:37.319
支持迭代或使用

00:38:35.609 --> 00:38:42.269
异步值流，例如

00:38:37.319 --> 00:38:46.769
出版商可以，以便获取

00:38:42.269 --> 00:38:50.069
流程有一个扩展功能很好

00:38:46.769 --> 00:38:51.089
现在我们可以使用该权限以及什么

00:38:50.069 --> 00:38:54.359
我想做的就是我要用这个

00:38:51.089 --> 00:38:55.529
建立REST API和

00:38:54.359 --> 00:38:57.599
如果有的话，我们再次有机会

00:38:55.529 --> 00:38:58.799
要建造一个信路由器，现在你

00:38:57.599 --> 00:39:00.599
可能记得当我向你展示时

00:38:58.799 --> 00:39:04.109
在没有DSL之前， 

00:39:00.599 --> 00:39:05.759
可以用于功能性反应式HTTP 

00:39:04.109 --> 00:39:08.190
端点，还有更好的DSL 

00:39:05.759 --> 00:39:09.690
一般而言，如果你想做凉

00:39:08.190 --> 00:39:12.029
基于常规的Web应用程序

00:39:09.690 --> 00:39:13.829
您可以执行的反应式Web应用程序

00:39:12.029 --> 00:39:16.049
那也是唯一的

00:39:13.829 --> 00:39:17.400
开关是假设我创建了一个

00:39:16.049 --> 00:39:19.589
对此我有参考

00:39:17.400 --> 00:39:21.720
我的预订库唯一

00:39:19.589 --> 00:39:24.509
现在换的是你用煤

00:39:21.720 --> 00:39:26.490
路由器等，以共同例程路由器

00:39:24.509 --> 00:39:32.849
而不是带有的铃声路由器

00:39:26.490 --> 00:39:37.680
你说预订服务器的地方

00:39:32.849 --> 00:39:39.420
那个身体反应很好，我们不是

00:39:37.680 --> 00:39:42.569
要使用体液，我们需要身体

00:39:39.420 --> 00:39:47.690
没关系，我是为了做到这一点

00:39:42.569 --> 00:39:50.599
我要说RR点很酷

00:39:47.690 --> 00:39:58.010
我会说我想变得特别

00:39:50.599 --> 00:40:00.230
我顺便说一句，身体流动

00:39:58.010 --> 00:40:02.270
重量是异步的，这是一个

00:40:00.230 --> 00:40:04.400
歌手不多，这是扩展类型

00:40:02.270 --> 00:40:05.660
好吧，这是一个扩展功能

00:40:04.400 --> 00:40:08.170
被添加到这种类型的

00:40:05.660 --> 00:40:11.000
全部存在于Java API中

00:40:08.170 --> 00:40:12.500
赞美大陆DSL的力量

00:40:11.000 --> 00:40:16.520
扩展好吗

00:40:12.500 --> 00:40:22.040
然后我们要寄回的尸体

00:40:16.520 --> 00:40:28.160
在这种情况下，RR点找到一个，并且

00:40:22.040 --> 00:40:29.780
名称将是请求字母，因此

00:40:28.160 --> 00:40:31.940
 X是请求

00:40:29.780 --> 00:40:33.020
这是要求，实际上有一个

00:40:31.940 --> 00:40:35.599
调用请求的参数

00:40:33.020 --> 00:40:36.530
这是一个servlet，这是一个服务器请求，但是

00:40:35.599 --> 00:40:39.020
我只是要使用隐式

00:40:36.530 --> 00:40:42.349
我将找到的参数称为

00:40:39.020 --> 00:40:46.730
数据找到其名称，如果该数据

00:40:42.349 --> 00:40:53.930
如果不是的话，那会很棒

00:40:46.730 --> 00:41:00.000
抛出法律论据异常好吧

00:40:53.930 --> 00:41:06.080
名称无效

00:41:00.000 --> 00:41:09.780
然后我将发送响应点正文

00:41:06.080 --> 00:41:12.450
等一下，现在我只是说一个

00:41:09.780 --> 00:41:15.330
我不需要的单个值

00:41:12.450 --> 00:41:18.270
在那里提供支持，但他们都是你们

00:41:15.330 --> 00:41:19.410
知道他们的书由cogent提供支持

00:41:18.270 --> 00:41:25.800
名字太酷了

00:41:19.410 --> 00:41:29.150
好吧，那么我现在做错了什么呢？ 

00:41:25.800 --> 00:41:32.490
这不是你去的地方吗

00:41:29.150 --> 00:41:36.080
很好，现在让我们再尝试一次

00:41:32.490 --> 00:41:41.780
时间，而不是打电话给我5 

00:41:36.080 --> 00:41:41.780
 6五是什么5介意

00:41:51.770 --> 00:42:03.200
好的，所以本地主机保留

00:41:57.099 --> 00:42:06.290
好东西，有我们的数据

00:42:03.200 --> 00:42:09.080
特别有效的记录，所以

00:42:06.290 --> 00:42:12.920
我们刚刚使用了协同例程支持

00:42:09.080 --> 00:42:14.839
进入康普顿的 Spring ，我们看着我

00:42:12.920 --> 00:42:17.420
意思是你知道我没意思

00:42:14.839 --> 00:42:19.190
希望对你们所有人都新鲜

00:42:17.420 --> 00:42:21.080
我们已经看过以前的事情

00:42:19.190 --> 00:42:25.910
看了功能性反应式DSL 

00:42:21.080 --> 00:42:28.609
 Kotlin在我们看完2d BC之前

00:42:25.910 --> 00:42:29.810
在正确之前，我们着眼于程序化

00:42:28.609 --> 00:42:33.290
来自的十亿注册

00:42:29.810 --> 00:42:35.060
在我们研究如何注册之前

00:42:33.290 --> 00:42:36.680
你知道对

00:42:35.060 --> 00:42:38.300
数据库客户端和mithra反应

00:42:36.680 --> 00:42:40.400
 MongoDB模板有扩展

00:42:38.300 --> 00:42:42.890
诸如风管流量和点以及

00:42:40.400 --> 00:42:44.420
如此对未来的妈妈

00:42:42.890 --> 00:42:47.150
模板以及其他模板

00:42:44.420 --> 00:42:49.400
再次希望这都不是超级

00:42:47.150 --> 00:42:52.270
对你的心情只是所有的融合

00:42:49.400 --> 00:42:55.930
在一起真的很好

00:42:52.270 --> 00:42:58.520
在第I栏的协同例程世界中

00:42:55.930 --> 00:42:59.960
我真的很想谢谢你的倾听

00:42:58.520 --> 00:43:02.300
希望你从中得到一些东西

00:42:59.960 --> 00:43:04.640
显然，我们才刚刚开始

00:43:02.300 --> 00:43:06.349
真正有趣的是

00:43:04.640 --> 00:43:08.690
不是我们所做的，而是我们所做的

00:43:06.349 --> 00:43:10.760
现在可以做正确的Kotlin协同例程是

00:43:08.690 --> 00:43:13.400
支持我们对协同例程的支持

00:43:10.760 --> 00:43:16.160
如您所见，这些功能

00:43:13.400 --> 00:43:19.310
反应堆类型，我们正在做大

00:43:16.160 --> 00:43:21.560
尽可能多地支持反应式

00:43:19.310 --> 00:43:22.970
尽可能用于各种用途

00:43:21.560 --> 00:43:25.220
有道理的案例

00:43:22.970 --> 00:43:26.960
我很高兴看到我很高兴

00:43:25.220 --> 00:43:29.780
这对那些

00:43:26.960 --> 00:43:30.980
我在Kotlin中构建应用程序

00:43:29.780 --> 00:43:32.660
很多想使用的人

00:43:30.980 --> 00:43:34.220
他们在Kotlin的例行公事

00:43:32.660 --> 00:43:35.630
当我向他们展示所有支持时感到震惊

00:43:34.220 --> 00:43:37.250
有很多人在使用

00:43:35.630 --> 00:43:40.430
 Kotlin和他们在

00:43:37.250 --> 00:43:42.349
在这种情况下，Android他们不想

00:43:40.430 --> 00:43:45.859
阻止主线程记住在UI中

00:43:42.349 --> 00:43:47.810
像Android或swing或

00:43:45.859 --> 00:43:49.970
这样的事情非常重要

00:43:47.810 --> 00:43:51.440
您的代码不会在用户界面上消失

00:43:49.970 --> 00:43:54.080
您需要摆脱的线程

00:43:51.440 --> 00:43:56.180
线程，以便您可以绘画

00:43:54.080 --> 00:43:58.400
尽可能快地自己

00:43:56.180 --> 00:44:00.200
如果您坐在那里等待，请重新显示自己

00:43:58.400 --> 00:44:02.300
用于数据下载的东西将冻结

00:44:00.200 --> 00:44:03.859
所以有这样一个很好的框架

00:44:02.300 --> 00:44:05.090
您可以在其中编写如下代码

00:44:03.859 --> 00:44:06.410
它是同步的

00:44:05.090 --> 00:44:08.720
并得到您期望的结果

00:44:06.410 --> 00:44:10.250
在这种情况下，我可以要求

00:44:08.720 --> 00:44:11.540
单一记录我没有

00:44:10.250 --> 00:44:13.070
发布者回来，我只得到一个

00:44:11.540 --> 00:44:14.960
记录回来，看起来像在工作

00:44:13.070 --> 00:44:16.820
这样我的代码就是这样写的

00:44:14.960 --> 00:44:19.220
我得到了那种确定性

00:44:16.820 --> 00:44:21.320
不用担心我不担心

00:44:19.220 --> 00:44:23.630
关于你知道回调，你知道

00:44:21.320 --> 00:44:28.790
去回调地狱，能够

00:44:23.630 --> 00:44:29.390
这么容易，那么好得到的是

00:44:28.790 --> 00:44:31.430
大不了的

00:44:29.390 --> 00:44:34.520
现在Kotlin当然支持

00:44:31.430 --> 00:44:36.890
是新的，但是关于协同例程的想法是

00:44:34.520 --> 00:44:38.720
一点也不新，我认为C锐化

00:44:36.890 --> 00:44:41.390
是第一种拥有它的大语言

00:44:38.720 --> 00:44:45.760
早在2012年，就在七年前

00:44:41.390 --> 00:44:48.620
和Python最近做对了Python 

00:44:45.760 --> 00:44:50.090
 3死了，我不知道其中的七个

00:44:48.620 --> 00:44:53.140
通过这六个也许是

00:44:50.090 --> 00:44:53.140
那里相当新的东西async / await 

00:44:53.440 --> 00:44:58.430
其他语言也有类似的东西

00:44:56.060 --> 00:45:00.580
对，我真的很兴奋

00:44:58.430 --> 00:45:02.870
看看这个与此有什么关系

00:45:00.580 --> 00:45:04.730
为我们装作一个社区，因为

00:45:02.870 --> 00:45:06.890
显然，尽管我们与

00:45:04.730 --> 00:45:09.050
一个Android用例，其中很多

00:45:06.890 --> 00:45:11.410
人们正在使用Kotlin我们都知道

00:45:09.050 --> 00:45:13.820
不要阻塞是非常重要的

00:45:11.410 --> 00:45:15.710
你知道服务器上的buck线程

00:45:13.820 --> 00:45:18.260
因为线程很昂贵，所以它们

00:45:15.710 --> 00:45:20.810
昂贵的资源，敬请期待

00:45:18.260 --> 00:45:22.900
朋友，一如既往地非常感谢

00:45:20.810 --> 00:45:22.900
观看

00:45:28.480 --> 00:45:30.540
您

