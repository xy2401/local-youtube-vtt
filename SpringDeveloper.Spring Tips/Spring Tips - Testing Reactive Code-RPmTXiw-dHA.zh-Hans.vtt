WEBVTT
Kind: captions
Language: zh-Hans

00:00:25.170 --> 00:00:30.190
嗨， Spring 粉丝们欢迎来到另一个

00:00:28.000 --> 00:00:32.320
本视频中的 spring 技巧 分期付款

00:00:30.190 --> 00:00:34.239
我们将回到主题

00:00:32.320 --> 00:00:36.010
在上一期的测试中，我们

00:00:34.239 --> 00:00:37.540
看了测试，我们为您覆盖

00:00:36.010 --> 00:00:39.040
知道相当大的队伍

00:00:37.540 --> 00:00:41.620
您可能想在其中使用的东西

00:00:39.040 --> 00:00:43.540
在 Spring 生态系统中进行测试

00:00:41.620 --> 00:00:46.090
相当传统的微服务

00:00:43.540 --> 00:00:48.790
基于Spring Boot的应用程序或

00:00:46.090 --> 00:00:49.660
如果你愿意的话， Spring 的云

00:00:48.790 --> 00:00:52.030
应用领域

00:00:49.660 --> 00:00:55.000
我从小开始，然后按照自己的方式工作

00:00:52.030 --> 00:00:56.860
在今年 Spring 的微服务中

00:00:55.000 --> 00:00:58.570
这个后续的 spring 技巧 ，我们要做

00:00:56.860 --> 00:01:00.250
你知道的基本相同

00:00:58.570 --> 00:01:03.100
域模型的一切都一样，但我们

00:01:00.250 --> 00:01:05.259
会在反应性的情况下这样做

00:01:03.100 --> 00:01:07.750
这是这个时的正确编程

00:01:05.259 --> 00:01:09.040
带来了一些不同的挑战

00:01:07.750 --> 00:01:10.390
挑战，而我们不必

00:01:09.040 --> 00:01:12.850
当我们做的时候真正面对

00:01:10.390 --> 00:01:16.930
当我们测试某种传统

00:01:12.850 --> 00:01:19.479
基于Spring MVC Servlet的非反应式

00:01:16.930 --> 00:01:21.009
这样的数据访问和Web端点

00:01:19.479 --> 00:01:24.399
在这部影片中，我们基本上要做

00:01:21.009 --> 00:01:25.990
同样的事情，但要在上下文中这样做

00:01:24.399 --> 00:01:28.660
反应式编程或通过

00:01:25.990 --> 00:01:29.860
反应性编程的镜头像往常一样

00:01:28.660 --> 00:01:31.299
我们将从这里开始，并开始

00:01:29.860 --> 00:01:32.920
 Spring ，我/我们将建立一个

00:01:31.299 --> 00:01:36.250
生产者应用程序，这将是一个

00:01:32.920 --> 00:01:37.900
服务数据的东西，我们要

00:01:36.250 --> 00:01:39.490
使用最新和最伟大的那个

00:01:37.900 --> 00:01:42.159
我们要创建一个快照

00:01:39.490 --> 00:01:44.100
使用的反应式Web应用程序

00:01:42.159 --> 00:01:47.799
龙目岛，可以用 Spring 的云

00:01:44.100 --> 00:01:49.689
合同验证程序，它将使用它

00:01:47.799 --> 00:01:51.150
反应性MongoDB我已经正确，我已经正确

00:01:49.689 --> 00:01:53.920
我在本地计算机上运行的MongoDB 

00:01:51.150 --> 00:01:57.640
此刻，所以我们将使用它

00:01:53.920 --> 00:02:00.759
我将转到此处的控制台并打开

00:01:57.640 --> 00:02:02.140
像往常一样在我的IDE中提高我的生产者，等等

00:02:00.759 --> 00:02:03.939
我们要做的非常非常

00:02:02.140 --> 00:02:05.650
简单的应用程序就是我们要开车

00:02:03.939 --> 00:02:09.100
这个应用程序的发展

00:02:05.650 --> 00:02:11.470
首先通过构建测试来进行应用

00:02:09.100 --> 00:02:14.579
这样做的好处是我们可以

00:02:11.470 --> 00:02:16.930
我们可以像我上次解释的那样

00:02:14.579 --> 00:02:22.540
安慰，知道我们每一次测试

00:02:16.930 --> 00:02:23.980
可能会导致我们工作的结果

00:02:22.540 --> 00:02:25.360
不必做，这不是我的琐事

00:02:23.980 --> 00:02:26.709
要求我们必须循环回去， 

00:02:25.360 --> 00:02:29.410
写完作品后要做

00:02:26.709 --> 00:02:30.790
编码，这是我们已经通过的

00:02:29.410 --> 00:02:33.370
我们已经做到这一点

00:02:30.790 --> 00:02:34.810
绿色也提供了

00:02:33.370 --> 00:02:37.120
每次测试时功能正确

00:02:34.810 --> 00:02:38.650
当我们首先编写测试时通过

00:02:37.120 --> 00:02:40.060
定义还提供了

00:02:38.650 --> 00:02:41.709
我们正在测试而不是

00:02:40.060 --> 00:02:43.659
传递未来，然后走向

00:02:41.709 --> 00:02:45.909
返回并编写测试，感觉

00:02:43.659 --> 00:02:48.700
有点像我们要触发的琐事

00:02:45.909 --> 00:02:50.769
最终你击中的多巴胺知道

00:02:48.700 --> 00:02:53.860
从那种感觉中得到的快感

00:02:50.769 --> 00:02:56.290
您正在快速进步，所以我们

00:02:53.860 --> 00:02:59.500
首先要写一个测试，我们要做

00:02:56.290 --> 00:03:01.090
因此，请转到测试包源

00:02:59.500 --> 00:03:02.859
当然要测试资源，我要

00:03:01.090 --> 00:03:04.510
去生产者应用测试，这个

00:03:02.859 --> 00:03:07.480
是全新的 Spring 良好应用程序

00:03:04.510 --> 00:03:08.859
这给了我们骨骼测试课

00:03:07.480 --> 00:03:10.420
在这里，但我们要删除它，因为

00:03:08.859 --> 00:03:11.590
其实这不是一个很好的测试

00:03:10.420 --> 00:03:14.200
这不是我们想要开始我们的方式

00:03:11.590 --> 00:03:17.109
开发，我们的第一个测试正在进行

00:03:14.200 --> 00:03:18.549
关心某件事

00:03:17.109 --> 00:03:21.280
在这种情况下，它将是一个实体

00:03:18.549 --> 00:03:23.680
将数据写入数据库的实体

00:03:21.280 --> 00:03:25.420
这将是一个预订实体， 

00:03:23.680 --> 00:03:27.280
你知道我只想创建一个

00:03:25.420 --> 00:03:30.970
预订POJO测试这将

00:03:27.280 --> 00:03:32.620
关注自己的目标能力

00:03:30.970 --> 00:03:34.359
具有我们期望的结构

00:03:32.620 --> 00:03:35.739
所以我要创建标准库存

00:03:34.359 --> 00:03:40.090
标准J单元测试

00:03:35.739 --> 00:03:42.340
好的，所以您知道创建的公共无效

00:03:40.090 --> 00:03:48.519
只是非常简单，没有幻想

00:03:42.340 --> 00:03:49.750
在所有应用程序中，我们将创建

00:03:48.519 --> 00:03:54.669
预约

00:03:49.750 --> 00:03:56.049
好吧，所以保留R等于new 

00:03:54.669 --> 00:03:58.299
保留当然，我们有一个

00:03:56.049 --> 00:04:01.510
测试失败即不是

00:03:58.299 --> 00:04:02.680
编译，所以我们需要做

00:04:01.510 --> 00:04:04.569
编译，所以我们通过编写来做到这一点

00:04:02.680 --> 00:04:06.519
生产代码IntelliJ确实可以

00:04:04.569 --> 00:04:08.859
在这里指导我们指导或很长一段路

00:04:06.519 --> 00:04:12.340
所以我已经解决了你的那种问题

00:04:08.859 --> 00:04:15.099
我现在知道要说失败测试

00:04:12.340 --> 00:04:20.739
到UM有一个构造函数

00:04:15.099 --> 00:04:22.780
它的第一个参数是ID，第二个参数

00:04:20.739 --> 00:04:25.780
参数将是保留名称

00:04:22.780 --> 00:04:27.909
现在我可以自己编写这段代码，但是

00:04:25.780 --> 00:04:29.500
我很懒，所以我要用龙目岛

00:04:27.909 --> 00:04:32.889
班级路径上的线框

00:04:29.500 --> 00:04:35.830
我将用它来生成

00:04:32.889 --> 00:04:39.490
通过编译时代码生成

00:04:35.830 --> 00:04:44.860
 ID字段和预订名称字段

00:04:39.490 --> 00:04:46.240
所以私人字串保留名称和我

00:04:44.860 --> 00:04:48.070
不需要构造函数更多

00:04:46.240 --> 00:04:50.409
写龙目岛会为我做的

00:04:48.070 --> 00:04:51.940
那就是我的对象的结构， 

00:04:50.409 --> 00:04:53.380
实际上，我现在要做的就是

00:04:51.940 --> 00:04:55.570
我要确认

00:04:53.380 --> 00:04:59.250
就像之前您了解基础知识一样

00:04:55.570 --> 00:05:02.980
工作，所以我要说我们的证件号码

00:04:59.250 --> 00:05:04.120
等于你知道好吧，这不是很

00:05:02.980 --> 00:05:05.470
好，我们要说确定不

00:05:04.120 --> 00:05:05.860
实际上这是一个更好的测试，所以我

00:05:05.470 --> 00:05:10.950
说

00:05:05.860 --> 00:05:14.590
搜索知道并证明效果很好

00:05:10.950 --> 00:05:18.090
让我们看看还有什么要用的

00:05:14.590 --> 00:05:22.540
 hamcrest比赛者，所以我们可以说

00:05:18.090 --> 00:05:27.070
我们的机票预订名称匹配器

00:05:22.540 --> 00:05:29.680
对这个没有什么反应

00:05:27.070 --> 00:05:31.390
但这确实给了我们机会

00:05:29.680 --> 00:05:33.310
复习基础知识，我们当然可以

00:05:31.390 --> 00:05:36.160
在某些Jaso中使用断言

00:05:33.310 --> 00:05:37.990
尚未保留的断言

00:05:36.160 --> 00:05:41.680
名称，这给了我们这个不错的汽车

00:05:37.990 --> 00:05:44.830
完成您知道类型敏感的流体

00:05:41.680 --> 00:05:47.050
自动完成选项的类型

00:05:44.830 --> 00:05:48.910
知道在这里，所以我们可以说简

00:05:47.050 --> 00:05:50.290
好了，所以我们有三个测试

00:05:48.910 --> 00:05:54.660
非常简单，我们可以运行此代码

00:05:50.290 --> 00:05:54.660
就像写的一样，让我们​​看看我们得到了什么

00:06:06.220 --> 00:06:10.330
好吧，好吧，我们继续前进

00:06:08.710 --> 00:06:11.890
一点点，我们知道我们有一个基本的

00:06:10.330 --> 00:06:13.390
 POJO你知道的结构

00:06:11.890 --> 00:06:15.010
对象是正确的，为什么我们可以

00:06:13.390 --> 00:06:17.260
写东西到田里拉

00:06:15.010 --> 00:06:20.140
再次退出，并做到这一点

00:06:17.260 --> 00:06:21.880
基本的询问性戳

00:06:20.140 --> 00:06:23.320
该对象，但现在我想创建一个

00:06:21.880 --> 00:06:27.130
实体就是说我们

00:06:23.320 --> 00:06:29.170
然后可以坚持到MongoDB，所以我要

00:06:27.130 --> 00:06:31.270
创建一个我想在其中的文档的实体

00:06:29.170 --> 00:06:33.040
在这种情况下，它称为文档， 

00:06:31.270 --> 00:06:35.440
我们推出了MongoDB，说你有你

00:06:33.040 --> 00:06:37.990
有一个表的集合， 

00:06:35.440 --> 00:06:39.880
在收集多个文件中

00:06:37.990 --> 00:06:42.970
在那和表中的行

00:06:39.880 --> 00:06:44.560
基本上所以预订文件测试

00:06:42.970 --> 00:06:46.810
我们在这里要做的就是

00:06:44.560 --> 00:06:48.130
确认当我将数据写入

00:06:46.810 --> 00:06:51.160
我可以将其拉回数据库

00:06:48.130 --> 00:06:52.900
再次知道你的完整性

00:06:51.160 --> 00:06:55.810
正确并与我们所有人一起解决

00:06:52.900 --> 00:07:00.100
所有这些仍然是我们联系的方式

00:06:55.810 --> 00:07:03.070
他们给我，所以坚持抛出异常

00:07:00.100 --> 00:07:05.140
我要把这些数据写到

00:07:03.070 --> 00:07:07.510
现在我需要在这里建立数据库

00:07:05.140 --> 00:07:09.490
 MongoDB现在当然有 Spring 

00:07:07.510 --> 00:07:11.320
靴子，这样 spring boot 可以自动配置

00:07:09.490 --> 00:07:14.050
连接工厂与

00:07:11.320 --> 00:07:15.730
数据库，我们可以使用自动

00:07:14.050 --> 00:07:17.590
配置以创建连接

00:07:15.730 --> 00:07:19.600
工厂并创建一个MongoDB模板

00:07:17.590 --> 00:07:21.700
所有这些我可以做的

00:07:19.600 --> 00:07:23.770
如您本人所知，而是

00:07:21.700 --> 00:07:27.940
我要使用一个测试切片，所以测试切片

00:07:23.770 --> 00:07:29.770
是让我们激活的东西

00:07:27.940 --> 00:07:32.650
应用程序上下文的某些部分

00:07:29.770 --> 00:07:33.940
在 Spring ，然后揭露那个或你

00:07:32.650 --> 00:07:35.470
知道在测试中利用这一点

00:07:33.940 --> 00:07:37.390
无需立即使用ATAR和

00:07:35.470 --> 00:07:39.070
构建整个spring应用程序

00:07:37.390 --> 00:07:41.110
上下文，因为我真的不想

00:07:39.070 --> 00:07:42.700
当我全部都在这里测试网络层

00:07:41.110 --> 00:07:44.860
试图做到他们不认为受测

00:07:42.700 --> 00:07:47.229
在这种情况下的变体是

00:07:44.860 --> 00:07:48.550
持久逻辑，特别是

00:07:47.229 --> 00:07:51.070
处理MongoDB的持久项目

00:07:48.550 --> 00:07:52.660
所以其余所有这些东西都可以

00:07:51.070 --> 00:07:54.700
现在被忽略了

00:07:52.660 --> 00:07:56.890
不变的，它不在测试中，为什么

00:07:54.700 --> 00:07:59.800
只需实例化这些对象

00:07:56.890 --> 00:08:01.210
能够编写此测试以及

00:07:59.800 --> 00:08:02.919
另一种选择当然是我不写

00:08:01.210 --> 00:08:04.240
我不允许任何人写

00:08:02.919 --> 00:08:05.560
我不让 Spring 做任何事

00:08:04.240 --> 00:08:07.900
的工作，这是我认为

00:08:05.560 --> 00:08:09.630
那是我更糟糕的选择

00:08:07.900 --> 00:08:12.490
而不需要重复配方

00:08:09.630 --> 00:08:14.140
用于在之间构造这些对象

00:08:12.490 --> 00:08:17.260
我的测试和实际生产代码

00:08:14.140 --> 00:08:18.729
所以我要去这些测试片

00:08:17.260 --> 00:08:19.960
这是您可以做到这一点的一种方法

00:08:18.729 --> 00:08:23.550
我们可以在

00:08:19.960 --> 00:08:28.449
然后我说这将要运行

00:08:23.550 --> 00:08:30.759
与 Spring 瑞纳点班一起运行所以这里

00:08:28.449 --> 00:08:33.310
我告诉Spring Boot这是一个

00:08:30.759 --> 00:08:35.560
 Spring ，这是一个不当的太阳珍妮

00:08:33.310 --> 00:08:37.180
第四单元这是一门课

00:08:35.560 --> 00:08:38.860
会在 Spring 之前进行管理

00:08:37.180 --> 00:08:41.080
将成为该对象的生命周期

00:08:38.860 --> 00:08:43.390
以及注入的字段和所有其他

00:08:41.080 --> 00:08:45.070
将在 Spring 之前管理，我是

00:08:43.390 --> 00:08:48.010
告诉 Spring 这件事

00:08:45.070 --> 00:08:51.070
希望所有位都与MongoDB有关

00:08:48.010 --> 00:08:53.890
在场，我可以注入

00:08:51.070 --> 00:08:57.399
反应性Mongo模板

00:08:53.890 --> 00:08:58.750
好吧，那么反应灵敏的Mongo模板以及什么

00:08:57.399 --> 00:09:00.220
我想写的是

00:08:58.750 --> 00:09:01.839
数据，所以我要写一些数据， 

00:09:00.220 --> 00:09:05.709
那我要证明那个数据

00:09:01.839 --> 00:09:08.410
存在，让我们创建一个反应式

00:09:05.709 --> 00:09:09.700
发布者，这又是一个反应

00:09:08.410 --> 00:09:11.560
发布商，我们已经研究了反应式

00:09:09.700 --> 00:09:17.730
流规范多次

00:09:11.560 --> 00:09:21.130
在此之前，让我们来看一个预订

00:09:17.730 --> 00:09:23.470
 2号，我要映射每个

00:09:21.130 --> 00:09:27.820
这些保留到数据库中，这样

00:09:23.470 --> 00:09:30.190
此点反应式反应式Mongo- 

00:09:27.820 --> 00:09:32.980
保存的模板以及我们保存的时间

00:09:30.190 --> 00:09:34.329
我们得到的是

00:09:32.980 --> 00:09:37.329
出版商自行发布，所以我

00:09:34.329 --> 00:09:39.370
去平面图，有我们的

00:09:37.329 --> 00:09:42.430
发布者反应性发布者我们

00:09:39.370 --> 00:09:44.829
数据流直接保存的记录

00:09:42.430 --> 00:09:45.790
所以有节省，当然还有

00:09:44.829 --> 00:09:46.630
我真的想做的就是想跳

00:09:45.790 --> 00:09:49.480
一切先

00:09:46.630 --> 00:09:53.980
所以我说反应性Mongo模板删除

00:09:49.480 --> 00:09:58.300
全部或您知道液滴收集或

00:09:53.980 --> 00:09:58.570
像这样的东西很好用

00:09:58.300 --> 00:10:02.110
那

00:09:58.570 --> 00:10:05.440
所有数据已保存，所以我们可以说让我们看看

00:10:02.110 --> 00:10:07.029
删除集合，我们将删除

00:10:05.440 --> 00:10:09.750
称为预订类的集合

00:10:07.029 --> 00:10:13.899
然后我们要写这些数据

00:10:09.750 --> 00:10:17.490
保存，然后我们要做什么

00:10:13.899 --> 00:10:21.370
好吧，我们想确认一下，如果

00:10:17.490 --> 00:10:24.130
拉回数据，例如

00:10:21.370 --> 00:10:29.620
所以预留对模板是被动的

00:10:24.130 --> 00:10:31.329
找到所有保留点类

00:10:29.620 --> 00:10:33.520
期望拥有我们期望

00:10:31.329 --> 00:10:33.730
发出两个记录，我们不希望

00:10:33.520 --> 00:10:36.339
那些

00:10:33.730 --> 00:10:38.050
记录有一定的形状

00:10:36.339 --> 00:10:40.720
应该有一个称为保留的字段

00:10:38.050 --> 00:10:43.240
名称，其值为一和二

00:10:40.720 --> 00:10:49.829
分别，其ID字段应

00:10:43.240 --> 00:10:54.100
理想情况下请不要互动

00:10:49.829 --> 00:10:55.959
好了，这是一个反应性管道，所以

00:10:54.100 --> 00:10:57.820
真的，我有点混合设置

00:10:55.959 --> 00:10:59.860
此测试的行为和拆卸

00:10:57.820 --> 00:11:01.860
实际测试本身的行为以及

00:10:59.860 --> 00:11:06.910
原因是因为我不能依靠

00:11:01.860 --> 00:11:09.310
在测试中执行的事情，例如

00:11:06.910 --> 00:11:12.579
在方法实际执行之前

00:11:09.310 --> 00:11:14.440
在测试本身的逻辑之前

00:11:12.579 --> 00:11:16.510
就是说这是一个反应性管道

00:11:14.440 --> 00:11:19.029
谁知道这些线程在哪个线程上

00:11:16.510 --> 00:11:20.440
事情会继续下去，所以我会

00:11:19.029 --> 00:11:23.620
把他们绑在一起，我要说

00:11:20.440 --> 00:11:25.510
删除所有内容，然后保存数据，然后

00:11:23.620 --> 00:11:27.250
证明当我保存它可以拉它

00:11:25.510 --> 00:11:28.570
再次退出并得到我的结果

00:11:27.250 --> 00:11:32.829
期待我期待着

00:11:28.570 --> 00:11:34.389
将会只有两个记录

00:11:32.829 --> 00:11:37.269
为了证明我要使用

00:11:34.389 --> 00:11:39.790
步骤验证程序，这是一个不错的API 

00:11:37.269 --> 00:11:43.540
 Spring Web Flex反应式Web运行时

00:11:39.790 --> 00:11:47.019
我要说的是创建一个验证器

00:11:43.540 --> 00:11:49.389
发布商，我希望当

00:11:47.019 --> 00:11:50.800
我写的数据你知道他们

00:11:49.389 --> 00:11:52.350
匹配这个谓词，所以我要创建

00:11:50.800 --> 00:11:58.680
这里的谓词与

00:11:52.350 --> 00:12:02.290
保留好，所以有一个新的谓词

00:11:58.680 --> 00:12:07.350
好了，我在这里说预订

00:12:02.290 --> 00:12:09.910
获得预订名称等于一或

00:12:07.350 --> 00:12:15.819
预订点获取预订名称

00:12:09.910 --> 00:12:17.260
等于两个好，所以我的

00:12:15.819 --> 00:12:18.490
我要去的简单谓词对象

00:12:17.260 --> 00:12:20.740
确认我们的数据

00:12:18.490 --> 00:12:24.160
期望已经写的确实

00:12:20.740 --> 00:12:31.949
被写，我们也想确认

00:12:24.160 --> 00:12:37.139
那个保留点ID不知道

00:12:31.949 --> 00:12:37.139
预订获取ID 

00:12:37.850 --> 00:12:42.300
我们在那里

00:12:41.279 --> 00:12:44.879
所以有点复杂

00:12:42.300 --> 00:12:46.199
扭曲了一点考验，但我是在说这个

00:12:44.879 --> 00:12:48.060
必须不是一个旧的，它必须是

00:12:46.199 --> 00:12:50.129
一两个好吧，非常非常简单， 

00:12:48.060 --> 00:12:51.089
这个谓词我会进入这里

00:12:50.129 --> 00:12:54.209
那么我会说我想验证

00:12:51.089 --> 00:12:57.000
完成吧，让我们看看我们

00:12:54.209 --> 00:13:04.220
现在，当我们运行此代码时，让我们看看

00:12:57.000 --> 00:13:04.220
在这里，我们去whoops重新编译运行

00:13:13.500 --> 00:13:16.430
好的

00:13:23.900 --> 00:13:28.760
嗯，有两个记录是

00:13:26.540 --> 00:13:31.279
承认，所以我需要我要考虑

00:13:28.760 --> 00:13:32.690
通过期望他们两个

00:13:31.279 --> 00:13:35.510
所以我要说下一个期待

00:13:32.690 --> 00:13:38.570
它匹配两次，但这就是为什么我

00:13:35.510 --> 00:13:40.100
甚至抓到我什至都占了

00:13:38.570 --> 00:13:42.620
他们被录取，但实际上并没有

00:13:40.100 --> 00:13:44.089
正确运行测试仪，这样

00:13:42.620 --> 00:13:46.040
我们去了那里，所以现在我们知道，如果我们

00:13:44.089 --> 00:13:48.290
使用库存标准的反应型

00:13:46.040 --> 00:13:50.779
我们可以向其中写入数据的Mongo模板

00:13:48.290 --> 00:13:52.820
我们期望的数据库是

00:13:50.779 --> 00:13:54.110
你知道本身很有趣，并给予

00:13:52.820 --> 00:13:55.700
我们有机会看到这里的台阶

00:13:54.110 --> 00:13:57.740
步骤验证器确实是

00:13:55.700 --> 00:13:59.450
反应性的主力

00:13:57.740 --> 00:14:02.060
测试套件，我们要做的所有事情

00:13:59.450 --> 00:14:03.080
很多时候在反应性世界中做

00:14:02.060 --> 00:14:04.820
你会发现自己，我们会来

00:14:03.080 --> 00:14:06.950
在一步验证，这是一件事

00:14:04.820 --> 00:14:09.500
真的很好，甚至有一个

00:14:06.950 --> 00:14:11.630
虚拟时间，所以我可以说这是一个

00:14:09.500 --> 00:14:14.930
发布者我可以给它一个发布者

00:14:11.630 --> 00:14:21.950
它要的，你会知道我可以的

00:14:14.930 --> 00:14:25.310
然后告诉它要等我就可以

00:14:21.950 --> 00:14:27.350
告诉它等待一段时间，例如

00:14:25.310 --> 00:14:29.000
我可以说这发行人好

00:14:27.350 --> 00:14:30.770
会承认你知道一个新的价值

00:14:29.000 --> 00:14:34.430
每秒钟我发布的内容

00:14:30.770 --> 00:14:39.200
在这种情况下，它只是一个流量

00:14:34.430 --> 00:14:42.980
只是不会延迟

00:14:39.200 --> 00:14:45.440
元素秒的持续时间，所以这里

00:14:42.980 --> 00:14:47.720
我实际上是给它一个动态的

00:14:45.440 --> 00:14:49.870
加载将产生

00:14:47.720 --> 00:14:54.709
我说的是每秒新价值

00:14:49.870 --> 00:14:56.450
等你知道十秒钟，然后

00:14:54.709 --> 00:15:00.260
验证完成，我可以

00:14:56.450 --> 00:15:05.209
验证您知道期望您知道期望

00:15:00.260 --> 00:15:06.860
下一张沙发，那是我的两个

00:15:05.209 --> 00:15:08.779
期待两个记录，所以我在这里

00:15:06.860 --> 00:15:10.640
实际上创建的发布商具有

00:15:08.779 --> 00:15:15.080
调度程序需要我利用

00:15:10.640 --> 00:15:17.570
调度程序，但我不是，我不是

00:15:15.080 --> 00:15:19.700
要等你知道十秒钟

00:15:17.570 --> 00:15:21.529
这是我实际上在嘲笑的虚拟假货

00:15:19.700 --> 00:15:22.850
在这里发挥作用的调度程序

00:15:21.529 --> 00:15:23.240
这是你其中的一件事

00:15:22.850 --> 00:15:26.080
应该知道

00:15:23.240 --> 00:15:29.660
记住当您编写反应式代码时

00:15:26.080 --> 00:15:30.860
时间是API的维度，对吧

00:15:29.660 --> 00:15:33.320
可以实际使用它，您可以计划

00:15:30.860 --> 00:15:35.450
围绕它，你可以，你可以假设

00:15:33.320 --> 00:15:37.579
就在那里，所以这是其中之一

00:15:35.450 --> 00:15:38.089
关于验证者的美好之处

00:15:37.579 --> 00:15:39.470
可以做各种各样的事

00:15:38.089 --> 00:15:42.470
我在这里用僵硬的验证程序

00:15:39.470 --> 00:15:44.689
刚刚验证您知道我是否说创建

00:15:42.470 --> 00:15:46.850
然后留下任何东西，然后我可以

00:15:44.689 --> 00:15:49.029
说我想期待下一次

00:15:46.850 --> 00:15:51.110
不要期望我能得到某些结果

00:15:49.029 --> 00:15:53.059
期望某些东西订阅

00:15:51.110 --> 00:15:55.100
我可以期待各种各样的东西

00:15:53.059 --> 00:15:56.089
我可以期待这里有趣的事情

00:15:55.100 --> 00:15:58.370
例如有一个错误

00:15:56.089 --> 00:16:00.230
他们已经通过了on箭头

00:15:58.370 --> 00:16:03.290
订户的各种方法

00:16:00.230 --> 00:16:06.529
有趣的事情好了，所以我们要

00:16:03.290 --> 00:16:11.689
利用它，因为我们现在可以了

00:16:06.529 --> 00:16:12.889
我们有一个基本的实体

00:16:11.689 --> 00:16:14.809
我们想要它吗我想我们

00:16:12.889 --> 00:16:16.670
假设现在我们有了我想要的

00:16:14.809 --> 00:16:17.779
创建存储库不是吗，所以我

00:16:16.670 --> 00:16:27.199
我想说一个仓库

00:16:17.779 --> 00:16:29.480
预留存储库测试以及

00:16:27.199 --> 00:16:33.439
存储库测试将用于

00:16:29.480 --> 00:16:35.329
验证您知道我们何时发出

00:16:33.439 --> 00:16:40.399
查询我们获得正确的结果

00:16:35.329 --> 00:16:51.499
因此您无法通过预订找到全部

00:16:40.399 --> 00:16:56.179
名字抛出异常好了，我要

00:16:51.499 --> 00:17:03.740
创建 Spring 赢家，以对不起与

00:16:56.179 --> 00:17:07.429
拆分好，然后再次与

00:17:03.740 --> 00:17:10.220
测试好东西，所以现在我

00:17:07.429 --> 00:17:13.209
我要做的就是创建一个简单的

00:17:10.220 --> 00:17:19.610
例子我是说自动有线私人

00:17:13.209 --> 00:17:21.949
预订库，当然

00:17:19.610 --> 00:17:25.760
这里我们缺少生产代码，所以

00:17:21.949 --> 00:17:27.439
用IDE来走路，它是

00:17:25.760 --> 00:17:31.640
将成为一个接口，它扩展了

00:17:27.439 --> 00:17:33.080
反应性Mongo资料库管理

00:17:31.640 --> 00:17:35.179
其预订类型的实体

00:17:33.080 --> 00:17:37.190
我不需要的字符串类型的主键

00:17:35.179 --> 00:17:39.799
测试这些方法我很了解

00:17:37.190 --> 00:17:42.279
反应性方法指令你

00:17:39.799 --> 00:17:46.700
知道暗含的样式方法

00:17:42.279 --> 00:17:48.200
在这将是正确的，不是

00:17:46.700 --> 00:17:50.450
这里的目标是测试我的

00:17:48.200 --> 00:17:54.049
自定义查找器方法

00:17:50.450 --> 00:17:57.679
例如，这个是通过预订找到的

00:17:54.049 --> 00:18:00.590
将变成的名称字符串RN 

00:17:57.679 --> 00:18:01.909
艾比（Abby）有疑问，我们可以为您

00:18:00.590 --> 00:18:04.159
知道询问我们可以说好找到

00:18:01.909 --> 00:18:07.580
和中的所有记录

00:18:04.159 --> 00:18:11.090
预订或预订名称：RN 

00:18:07.580 --> 00:18:12.739
好吧，所以有我们的

00:18:11.090 --> 00:18:13.999
自定义查询让我们测试一下方式

00:18:12.739 --> 00:18:15.139
我们可以首先测试一下

00:18:13.999 --> 00:18:17.359
清除数据库，然后

00:18:15.139 --> 00:18:19.220
向其中写入一些数据，然后

00:18:17.359 --> 00:18:20.480
然后再把它拉出来

00:18:19.220 --> 00:18:22.820
查询与以前一样

00:18:20.480 --> 00:18:28.309
好吧好吧，但是这次我们要说

00:18:22.820 --> 00:18:32.779
 Flex潜水只是一个B点图，我想我们

00:18:28.309 --> 00:18:43.460
可以做平面地图好吧名字新

00:18:32.779 --> 00:18:45.399
保留好吧，没有名字，我们想

00:18:43.460 --> 00:18:47.840
拯救那不是我，所以我们要说

00:18:45.399 --> 00:18:52.279
这个点保留允许

00:18:47.840 --> 00:18:58.669
保存好，所以整个

00:18:52.279 --> 00:19:01.970
的东西，我要保存所有的数据

00:18:58.669 --> 00:19:03.619
对，我要知道，我们

00:19:01.970 --> 00:19:05.690
知道它已经保存了，我们想

00:19:03.619 --> 00:19:08.029
无论如何实际上要清理，所以我们想要

00:19:05.690 --> 00:19:14.139
说点保留冒名顶替者

00:19:08.029 --> 00:19:16.519
删除所有然后传递的那个

00:19:14.139 --> 00:19:20.059
这个点保留杰出

00:19:16.519 --> 00:19:27.859
全部以预订名称命名，您知道

00:19:20.059 --> 00:19:29.720
让我们再试一次让我们做C的D 

00:19:27.859 --> 00:19:35.210
再次C，所以我们将在

00:19:29.720 --> 00:19:39.019
在那里，我要寻找C，我是

00:19:35.210 --> 00:19:42.169
然后验证所有结果

00:19:39.019 --> 00:19:44.749
正如我们期望的那样

00:19:42.169 --> 00:19:49.879
记录以键入C，所以我们说步骤

00:19:44.749 --> 00:19:51.919
验证点创建通量验证或

00:19:49.879 --> 00:19:54.379
期待下一场比赛或期待

00:19:51.919 --> 00:19:56.679
下一次计数将是要验证

00:19:54.379 --> 00:19:58.730
完全正确，所以我们有

00:19:56.679 --> 00:20:00.710
存储库，所以我只是在写数据

00:19:58.730 --> 00:20:02.029
到数据库，我正在删除所有内容

00:20:00.710 --> 00:20:04.280
首先，抱歉，我要删除

00:20:02.029 --> 00:20:06.230
一切先，然后我要成为

00:20:04.280 --> 00:20:08.060
运行数据到数据库，然后

00:20:06.230 --> 00:20:09.890
我会插上它，你知道我会把它拉回来的

00:20:08.060 --> 00:20:11.810
再次使用这个取景器

00:20:09.890 --> 00:20:14.650
仅匹配具有C作为的结果

00:20:11.810 --> 00:20:14.650
这个名字，所以让我们尝试

00:20:24.679 --> 00:20:32.640
好吧，看起来很棒

00:20:27.679 --> 00:20:35.250
所以现在我们需要做的很好

00:20:32.640 --> 00:20:38.070
嗯，我认为我们应该

00:20:35.250 --> 00:20:39.600
测试我们的REST API，我们有spring数据

00:20:38.070 --> 00:20:41.880
我们有实体，我们有

00:20:39.600 --> 00:20:46.110
搜寻器方法就可以了

00:20:41.880 --> 00:20:47.519
很好，所以现在让我们测试一下

00:20:46.110 --> 00:20:53.570
 rest API，让我们构建一个简单的REST 

00:20:47.519 --> 00:21:02.370
 API，我们要说休息

00:20:53.570 --> 00:21:04.139
测试还可以，这里我将使用

00:21:02.370 --> 00:21:06.659
你在这里知道的不同切片

00:21:04.139 --> 00:21:08.730
到目前为止，我们已经使用过网络羡慕网络

00:21:06.659 --> 00:21:11.720
数据Mongo测试，现在我要使用网络

00:21:08.730 --> 00:21:19.919
 flex test right这是一个Web flex测试， 

00:21:11.720 --> 00:21:23.039
与 Spring 跑垒员全班一起跑步

00:21:19.919 --> 00:21:25.230
对，在这里我们要测试

00:21:23.039 --> 00:21:27.149
当我们调用HTTP GET时， 

00:21:25.230 --> 00:21:29.039
拨打HTTP GET预订电话

00:21:27.149 --> 00:21:31.380
我们应该获取数据的端点

00:21:29.039 --> 00:21:35.779
返回我们期望的，让我们尝试一下

00:21:31.380 --> 00:21:42.059
出去所以公共无效得到所有保留

00:21:35.779 --> 00:21:43.200
抛出异常并为了使

00:21:42.059 --> 00:21:44.880
这个电话我们不会使用

00:21:43.200 --> 00:21:46.470
 mahkum，您看到客户，而是使用

00:21:44.880 --> 00:21:48.659
网络测试客户端

00:21:46.470 --> 00:21:52.110
等同于这个新世界

00:21:48.659 --> 00:22:02.340
这是一个Web测试客户端，而不是Web Flex测试

00:21:52.110 --> 00:22:10.730
网络测试客户端没问题，所以我

00:22:02.340 --> 00:22:15.929
要说点获取点URI HTTP本地主机

00:22:10.730 --> 00:22:20.669
 8080用于斜线保留点交换

00:22:15.929 --> 00:22:22.110
在这里，哦，在这里，我们必须戳一下

00:22:20.669 --> 00:22:23.700
结果数据并不意味着我要

00:22:22.110 --> 00:22:25.799
戳一下返回的结果

00:22:23.700 --> 00:22:27.269
从这个REST API，所以我想我想

00:22:25.799 --> 00:22:30.330
断言某些我想搜索的东西

00:22:27.269 --> 00:22:32.070
例如，状态还可以，我想

00:22:30.330 --> 00:22:34.649
期望有一种内容类型

00:22:32.070 --> 00:22:36.450
具有一定值的标头

00:22:34.649 --> 00:22:37.309
最后我想戳一下

00:22:36.450 --> 00:22:39.620
我想要的数据

00:22:37.309 --> 00:22:41.690
期望身体与

00:22:39.620 --> 00:22:45.200
某种结构，所以我要说

00:22:41.690 --> 00:22:46.759
它具有相邻的路径匹配，所以我认为

00:22:45.200 --> 00:22:48.980
我要说先比赛第一场比赛

00:22:46.759 --> 00:22:54.970
数组中的元素，应该

00:22:48.980 --> 00:22:59.059
等于1我要匹配

00:22:54.970 --> 00:23:02.210
第一预订名称的权利和

00:22:59.059 --> 00:23:03.529
应该等于好的

00:23:02.210 --> 00:23:05.230
你知道我们可以走得更远

00:23:03.529 --> 00:23:10.279
让我们走的更远，让我们说

00:23:05.230 --> 00:23:12.289
让我们复制这个，这样我们可以

00:23:10.279 --> 00:23:15.549
确认我们有一个多值数组

00:23:12.289 --> 00:23:17.899
这将被称为B 

00:23:15.549 --> 00:23:23.929
我们去了，所以有我们的网络测试

00:23:17.899 --> 00:23:25.669
客户，你知道那会失败

00:23:23.929 --> 00:23:28.929
显然，我们没有把其余的写在

00:23:25.669 --> 00:23:28.929
点，但让我们继续尝试一下

00:23:31.720 --> 00:23:35.200
看看我们得到了什么

00:23:37.520 --> 00:23:41.570
好吧，首先，那不是

00:23:40.490 --> 00:23:43.160
工作显然是行不通的

00:23:41.570 --> 00:23:44.809
因为为此，让我们来解决这个问题

00:23:43.160 --> 00:23:48.170
现在让我们回到生产代码

00:23:44.809 --> 00:23:53.679
和我们的生产代码，我们可以创建一个

00:23:48.170 --> 00:23:58.580
新班下课预定

00:23:53.679 --> 00:23:59.600
休息配置好了，我在这里

00:23:58.580 --> 00:24:02.780
将创建一个功能性反应

00:23:59.600 --> 00:24:08.080
端点使用Spring Framework五

00:24:02.780 --> 00:24:15.530
功能性反应式API，因此服务器响应

00:24:08.080 --> 00:24:17.780
路由配置并为了

00:24:15.530 --> 00:24:20.240
创建我将要注入的端点

00:24:17.780 --> 00:24:23.840
我的黑坑我实际上可以做

00:24:20.240 --> 00:24:29.059
这里不会死的，所以我们说注射

00:24:23.840 --> 00:24:36.790
保留资料库好吧我

00:24:29.059 --> 00:24:40.670
将此点转为路由器功能

00:24:36.790 --> 00:24:45.980
请求谓词s-点得到四个斜杠

00:24:40.670 --> 00:24:49.970
保留和新的处理程序功能

00:24:45.980 --> 00:24:51.800
和这里的目标一样

00:24:49.970 --> 00:24:54.440
我已经完成了这个特定的端点

00:24:51.800 --> 00:24:58.610
五次，所以我知道

00:24:54.440 --> 00:25:00.559
将要工作，但对

00:24:58.610 --> 00:25:02.630
提前定义合同

00:25:00.559 --> 00:25:04.580
明确思考我想要什么

00:25:02.630 --> 00:25:06.140
通过运行该端点来执行

00:25:04.580 --> 00:25:08.390
测试我有点知道这是我

00:25:06.140 --> 00:25:10.520
会期望这将提供内容

00:25:08.390 --> 00:25:14.809
应用程序类型Jason utf-8 

00:25:10.520 --> 00:25:18.700
我希望身体是从

00:25:14.809 --> 00:25:20.630
仓库，所以我们说这是最终的

00:25:18.700 --> 00:25:22.040
我们发回的数据类型

00:25:20.630 --> 00:25:24.679
这是

00:25:22.040 --> 00:25:26.330
现在保留，这有点冗长

00:25:24.679 --> 00:25:29.570
所以我们在这里用一个不错的东西清理一下

00:25:26.330 --> 00:25:32.890
 Java 8功能反应式Lambda 

00:25:29.570 --> 00:25:40.340
中心，你知道静态导入友好

00:25:32.890 --> 00:25:44.450
 API好吧，好吧，看好吧

00:25:40.340 --> 00:25:46.040
现在我们有了数据，仅此而已

00:25:44.450 --> 00:25:48.230
那就是我们的功能性反应终点

00:25:46.040 --> 00:25:50.450
对，有一个非常简单的终点

00:25:48.230 --> 00:25:51.200
现在让我们确认这是否可行

00:25:50.450 --> 00:25:53.270
仍然不会

00:25:51.200 --> 00:26:03.950
我们将在第二秒看到

00:25:53.270 --> 00:26:07.460
不同的原因没事吧

00:26:03.950 --> 00:26:09.790
说它找不到这个休息

00:26:07.460 --> 00:26:11.840
这是因为我们的测试代码

00:26:09.790 --> 00:26:12.860
不知道其余的

00:26:11.840 --> 00:26:15.410
我们实际需要的配置

00:26:12.860 --> 00:26:17.450
实际上明确地把它带入我们

00:26:15.410 --> 00:26:19.070
可以这样做，但仍然会失败

00:26:17.450 --> 00:26:26.180
仍然会失败，这很漂亮

00:26:19.070 --> 00:26:28.130
压抑是不是但是要注意

00:26:26.180 --> 00:26:29.710
它失败的原因是

00:26:28.130 --> 00:26:31.790
没有这样的存在

00:26:29.710 --> 00:26:36.350
保留资源库，所以这又是

00:26:31.790 --> 00:26:37.850
该测试切片告诉的测试切片

00:26:36.350 --> 00:26:39.530
Spring 以选择性地加载对象

00:26:37.850 --> 00:26:41.210
与将要发生的事情有关

00:26:39.530 --> 00:26:42.950
您知道在这种情况下正在测试中的网络

00:26:41.210 --> 00:26:44.240
层，这意味着所有其他

00:26:42.950 --> 00:26:47.030
像妈妈这样的事情

00:26:44.240 --> 00:26:48.020
例如不是您知道存储库

00:26:47.030 --> 00:26:49.610
他们没有被加载，他们没有

00:26:48.020 --> 00:26:51.950
被实例化什么也没做

00:26:49.610 --> 00:26:55.610
在那件事上，所以我们需要

00:26:51.950 --> 00:26:56.900
来模拟那个仓库，我们

00:26:55.610 --> 00:26:59.240
知道为了让我们做到这一点

00:26:56.900 --> 00:27:01.220
休息电话我要为此保留

00:26:59.240 --> 00:27:03.140
仓库如此明确，我们需要

00:27:01.220 --> 00:27:05.840
预订资料库，但我不是

00:27:03.140 --> 00:27:07.160
我不是你知道它不存在

00:27:05.840 --> 00:27:08.630
不是瞬间，不是

00:27:07.160 --> 00:27:10.340
数字，所以我需要模拟一下

00:27:08.630 --> 00:27:13.130
对象，最简单的方法是

00:27:10.340 --> 00:27:16.550
使用Spring Framework 1.4模拟

00:27:13.130 --> 00:27:20.090
 bean 卫生，这是做什么的

00:27:16.550 --> 00:27:21.860
让我，你知道告诉 Spring 

00:27:20.090 --> 00:27:24.290
替换这个bean来替换任何

00:27:21.860 --> 00:27:26.990
此类型的bean的实例

00:27:24.290 --> 00:27:28.940
这个mockito模拟将

00:27:26.990 --> 00:27:30.500
为我们创建（如果尚未创建） 

00:27:28.940 --> 00:27:32.030
如果应用程序上下文中存在

00:27:30.500 --> 00:27:33.620
 bean，如果没有类型的bean 

00:27:32.030 --> 00:27:35.930
在这种情况下，保留库

00:27:33.620 --> 00:27:38.450
然后将创建一个

00:27:35.930 --> 00:27:42.070
模拟我们想要的是一个存根，虽然不是

00:27:38.450 --> 00:27:44.270
模拟，所以我们要说模拟点

00:27:42.070 --> 00:27:47.720
这个保留或暂停权利， 

00:27:44.270 --> 00:27:55.000
找到所有，当你说然后返回

00:27:47.720 --> 00:28:00.230
通量点只是新的保留说一个

00:27:55.000 --> 00:28:03.500
新的保留可以，所以现在

00:28:00.230 --> 00:28:04.760
我们已经告诉我们我们真的已经预先设定好了

00:28:03.500 --> 00:28:06.860
我们的模拟

00:28:04.760 --> 00:28:09.050
现在是一个存根，它有一个

00:28:06.860 --> 00:28:12.080
会用那几周的数据回应

00:28:09.050 --> 00:28:14.980
我们已经给它回应了，所以

00:28:12.080 --> 00:28:14.980
开始

00:28:22.170 --> 00:28:26.850
好的，还不错，所以我们现在有了REST API 

00:28:24.960 --> 00:28:28.680
我们已经得到了我们能够测试

00:28:26.850 --> 00:28:30.390
从正确的REST API一直

00:28:28.680 --> 00:28:31.620
下降到最低层的方式

00:28:30.390 --> 00:28:33.840
测试真的很快

00:28:31.620 --> 00:28:35.970
这花费了333毫秒的启动时间

00:28:33.840 --> 00:28:37.530
网络的网络测试达到了终点

00:28:35.970 --> 00:28:39.330
确认返回的字节

00:28:37.530 --> 00:28:40.770
看起来如果我们期望字节

00:28:39.330 --> 00:28:44.180
发出HTTP端点请求

00:28:40.770 --> 00:28:47.490
你知道在一种实际的生火中

00:28:44.180 --> 00:28:49.410
例子还可以，我们也没有支付

00:28:47.490 --> 00:28:52.800
您知道配置所有

00:28:49.410 --> 00:28:54.390
现在我要构建数据库的东西

00:28:52.800 --> 00:28:57.090
客户，所以我们有服务，让我们

00:28:54.390 --> 00:28:59.280
在这里建立客户我要回去

00:28:57.090 --> 00:29:02.850
我将建立一个名为

00:28:59.280 --> 00:29:05.070
消费者，我们将再次使用2.11 

00:29:02.850 --> 00:29:06.810
使用存根运行器支持时

00:29:05.070 --> 00:29:08.610
我们要用龙目岛我要用

00:29:06.810 --> 00:29:11.190
我们不需要的反应式网络支持

00:29:08.610 --> 00:29:15.270
当然这里有MongoDB，所以我将点击generate 

00:29:11.190 --> 00:29:22.610
给消费者，我们会回去

00:29:15.270 --> 00:29:24.750
为我们建立了一个小消费者， 

00:29:22.610 --> 00:29:25.980
现在我们要做的就是开车

00:29:24.750 --> 00:29:30.090
我们将建立一个客户，我们

00:29:25.980 --> 00:29:36.720
可以用来和我们的REST API对话

00:29:30.090 --> 00:29:38.280
所以我去消费者应用程序去

00:29:36.720 --> 00:29:43.770
消费者的测试代码

00:29:38.280 --> 00:29:45.540
现在正确的应用程序与

00:29:43.770 --> 00:29:47.010
在我们继续前进之前，只有你

00:29:45.540 --> 00:29:48.780
我知道我们实际上可以

00:29:47.010 --> 00:29:51.510
保持这个很好，但是你知道

00:29:48.780 --> 00:29:54.090
我们不是，我们只有一个测试

00:29:51.510 --> 00:29:59.300
所以我们重命名一下

00:29:54.090 --> 00:30:04.080
更合适的预订客户最好

00:29:59.300 --> 00:30:10.890
好的，我们要测试一下

00:30:04.080 --> 00:30:13.230
可以得到所有的预订好东西

00:30:10.890 --> 00:30:15.510
当我测试要扔的时候

00:30:13.230 --> 00:30:17.130
例外，如果我们需要并且为了

00:30:15.510 --> 00:30:19.200
拨打电话，我们将注入

00:30:17.130 --> 00:30:21.240
预订客户当然

00:30:19.200 --> 00:30:22.530
我们还没有定义它不会继续

00:30:21.240 --> 00:30:23.940
非常远的权利，我们不会得到非常

00:30:22.530 --> 00:30:26.040
没有那个客户，我们继续前进

00:30:23.940 --> 00:30:28.770
并创建它，客户端将有一个

00:30:26.040 --> 00:30:32.430
给我们一个请求，一个非常简单的工作

00:30:28.770 --> 00:30:34.250
保留和发行人

00:30:32.430 --> 00:30:35.860
当然我们没有出版商

00:30:34.250 --> 00:30:40.059
而保留

00:30:35.860 --> 00:30:43.120
而是我们需要定义我可以

00:30:40.059 --> 00:30:46.830
在这里做

00:30:43.120 --> 00:30:55.049
相当详细的客户端细节

00:30:46.830 --> 00:30:57.370
字符串名称私有字符串ID可以

00:30:55.049 --> 00:31:00.670
现在有一个客户端表示

00:30:57.370 --> 00:31:03.340
我们想要龙目岛的其余部分

00:31:00.670 --> 00:31:07.900
在这里吃饭好吗

00:31:03.340 --> 00:31:11.190
现在有了适当的位置，我需要走

00:31:07.900 --> 00:31:15.870
回到我的客户代码，我要说

00:31:11.190 --> 00:31:18.730
这个点客户端点得到所有保留

00:31:15.870 --> 00:31:22.000
好吧，我们要说一步验证器

00:31:18.730 --> 00:31:24.100
点创建所有保留，我们将

00:31:22.000 --> 00:31:25.360
期待我们期待什么

00:31:24.100 --> 00:31:28.150
我们要说两个

00:31:25.360 --> 00:31:30.280
记录好，所以有两个记录，所以我们将

00:31:28.150 --> 00:31:35.260
给它一个谓词和谓词

00:31:30.280 --> 00:31:44.590
将非常简单等于

00:31:35.260 --> 00:31:46.960
新的谓词，我们将说P，我们将

00:31:44.590 --> 00:31:48.970
验证我是否完成另一个谓词

00:31:46.960 --> 00:31:58.530
会说我和你一样

00:31:48.970 --> 00:32:10.630
我们都想说得到ID字符串utils 

00:31:58.530 --> 00:32:17.940
点作为文本可以，保留点得到

00:32:10.630 --> 00:32:24.210
名字等于简或

00:32:17.940 --> 00:32:27.850
保留点获取名称等于John 

00:32:24.210 --> 00:32:32.250
好，所以我们的超级简单

00:32:27.850 --> 00:32:36.059
谓词我们只是像这样放置

00:32:32.250 --> 00:32:36.059
好吧，现在

00:32:36.470 --> 00:32:40.730
这是我们非常简单的谓词

00:32:38.929 --> 00:32:42.670
一个简单的逻辑，让我们继续运行

00:32:40.730 --> 00:32:44.570
我完全有信心

00:32:42.670 --> 00:32:45.860
好吧，那可能行不通，让我们

00:32:44.570 --> 00:32:46.520
只是继续尝试，尽管你

00:32:45.860 --> 00:32:49.120
永远不知道

00:32:46.520 --> 00:32:52.690
好的工作可能会变得神奇

00:32:49.120 --> 00:32:52.690
可能是那样的夜晚

00:33:00.670 --> 00:33:07.240
好吧，这给了我们希望，没有

00:33:04.780 --> 00:33:09.550
现在我想相信

00:33:07.240 --> 00:33:11.170
你知道但还没有结束，所以我们

00:33:09.550 --> 00:33:13.330
甚至没有预订客户让

00:33:11.170 --> 00:33:14.350
一个工作的人，我们远没有

00:33:13.330 --> 00:33:16.390
 Spring 担心，这甚至没有

00:33:14.350 --> 00:33:18.370
存在，所以不会使我们走得更远

00:33:16.390 --> 00:33:20.050
哦，是的，我们可以再次开始

00:33:18.370 --> 00:33:21.550
让我再试一次，但我想

00:33:20.050 --> 00:33:22.810
我们可以适应，我们可以推测

00:33:21.550 --> 00:33:24.550
不会走的太远，因为我们

00:33:22.810 --> 00:33:27.220
我们这里什么也没发生

00:33:24.550 --> 00:33:29.980
让我们更进一步，我们需要一个

00:33:27.220 --> 00:33:32.380
 Web客户端反应式Web客户端是一个

00:33:29.980 --> 00:33:34.930
我们可以用来休息的HTTP客户端

00:33:32.380 --> 00:33:37.720
反应性地调用以便

00:33:34.930 --> 00:33:43.600
工作，我们将需要一个类型的网梁

00:33:37.720 --> 00:33:53.010
客户，所以这里我们是网络客户，我们

00:33:43.600 --> 00:34:01.570
需要Web客户端构建器和构建器

00:33:53.010 --> 00:34:05.130
点构建，这样我们就可以

00:34:01.570 --> 00:34:10.630
说这个点网络客户端点得到点URI 

00:34:05.130 --> 00:34:14.770
 HTTP本地主机8080的斜线

00:34:10.630 --> 00:34:17.890
保留点取回点身体牙齿

00:34:14.770 --> 00:34:19.960
助焊剂将成为保留课程， 

00:34:17.890 --> 00:34:21.610
这就是我们的全部

00:34:19.960 --> 00:34:25.350
现在当然应该可以工作

00:34:21.610 --> 00:34:25.350
正确，继续尝试

00:34:32.869 --> 00:34:36.440
没那么多，我想我们都可以

00:34:34.669 --> 00:34:38.450
看到即使有一个

00:34:36.440 --> 00:34:39.739
完美的客户，我们只是没有

00:34:38.450 --> 00:34:41.719
如果我们没有一个，它将走得很远

00:34:39.739 --> 00:34:43.700
工作服务，而我们确实有一个

00:34:41.719 --> 00:34:45.139
工作服务没有运行，我

00:34:43.700 --> 00:34:46.369
真的不想在其中运行

00:34:45.139 --> 00:34:49.399
为了能够确认这一点

00:34:46.369 --> 00:34:51.979
你会很漂亮的作品

00:34:49.399 --> 00:34:53.960
敌对的是那里，你知道那里的

00:34:51.979 --> 00:34:55.460
我们可以在这里做很多事情

00:34:53.960 --> 00:34:58.130
可以启动整个系统，并且

00:34:55.460 --> 00:35:00.079
测试它，但这几乎不是单元测试或

00:34:58.130 --> 00:35:01.549
甚至是轻量级的组件

00:35:00.079 --> 00:35:03.079
测试更像是

00:35:01.549 --> 00:35:05.150
集成测试或端到端测试

00:35:03.079 --> 00:35:06.650
或烟雾测试，那就是

00:35:05.150 --> 00:35:11.930
没有足够的启动器

00:35:06.650 --> 00:35:14.390
你用英语知道的比例

00:35:11.930 --> 00:35:16.549
语言你可以说的友好的话

00:35:14.390 --> 00:35:17.960
向某人问好或欢迎

00:35:16.549 --> 00:35:19.309
如果有人来和你一起工作

00:35:17.960 --> 00:35:21.140
如果他们加入您的团队，那就来吧

00:35:19.309 --> 00:35:24.289
想拆开一件非常友好的东西

00:35:21.140 --> 00:35:26.180
用英语说是欢迎和如何

00:35:24.289 --> 00:35:28.009
我可以帮你一个非常敌对的事情吗

00:35:26.180 --> 00:35:29.779
这里要说英语

00:35:28.009 --> 00:35:31.969
正确部署这个kubernetes集群

00:35:29.779 --> 00:35:33.950
没有什么可以使某人的敌人更快

00:35:31.969 --> 00:35:35.329
然后贴上100个虚拟

00:35:33.950 --> 00:35:36.920
我说的是机器

00:35:35.329 --> 00:35:38.690
那么你可以开始，你可以开始

00:35:36.920 --> 00:35:40.819
开发这个小微服务

00:35:38.690 --> 00:35:42.920
您正在尝试的工作，所以我们

00:35:40.819 --> 00:35:45.469
需要绕过那件事，我们

00:35:42.920 --> 00:35:45.890
可以做的就是模拟这个REST API 

00:35:45.469 --> 00:35:47.960
知道

00:35:45.890 --> 00:35:49.130
奇怪，但我们可以做到，所以让我们考虑一下

00:35:47.960 --> 00:35:51.859
关于我们该怎么做，我们可以

00:35:49.130 --> 00:35:55.069
使用电线模拟电线模拟是一个API，因此我们

00:35:51.859 --> 00:35:58.999
可以说自动配置电线模拟，我们

00:35:55.069 --> 00:36:04.339
希望它在端口8080上运行

00:35:58.999 --> 00:36:05.900
电线模拟API将提供休息

00:36:04.339 --> 00:36:08.539
磁带会站起来假的REST API 

00:36:05.900 --> 00:36:10.130
那回应你知道的

00:36:08.539 --> 00:36:14.710
预编程的响应，因此需要

00:36:10.130 --> 00:36:17.479
电线的模拟存根模拟点ini' 

00:36:14.710 --> 00:36:22.509
 Cuauhtemoc URL匹配斜杠

00:36:17.479 --> 00:36:22.509
保留和我想说的一切

00:36:22.660 --> 00:36:34.190
它将返回电线模拟响应

00:36:28.900 --> 00:36:36.460
带标头HTTP标头的点内容

00:36:34.190 --> 00:36:36.460
类型

00:36:38.640 --> 00:36:52.150
 HTTP标头点内容类型媒体类型

00:36:47.219 --> 00:36:57.849
应用程序JSON utf-8值还可以

00:36:52.150 --> 00:36:58.900
和正确的标题，我们想

00:36:57.849 --> 00:37:01.179
猜想我们已经完成了

00:36:58.900 --> 00:37:05.410
现在状态为a的梅利莎应该是

00:37:01.179 --> 00:37:06.969
状态点好没值，然后

00:37:05.410 --> 00:37:09.549
终于有了一个身体，我要去

00:37:06.969 --> 00:37:15.189
提供一个预编程的字符串体

00:37:09.549 --> 00:37:16.839
这里有一些数据就是这样

00:37:15.189 --> 00:37:19.929
那就是事物的结构

00:37:16.839 --> 00:37:23.529
返回时，让我们继续前进

00:37:19.929 --> 00:37:26.079
在这里制作我无法等待的回应

00:37:23.529 --> 00:37:29.859
 Java的十二个多行字符串哦

00:37:26.079 --> 00:37:33.309
哈哈，但与此同时我只是

00:37:29.859 --> 00:37:35.319
用老式的方式和字符串来执行此操作

00:37:33.309 --> 00:37:37.769
文字原始字符串和工作很好

00:37:35.319 --> 00:37:40.630
那会很棒

00:37:37.769 --> 00:37:42.219
这在Scala中也很简单

00:37:40.630 --> 00:37:49.019
高飞或Kotlin现在我们没有

00:37:42.219 --> 00:37:49.019
等待，但是你知道Yolo，所以我一个

00:37:49.229 --> 00:38:00.099
让我们摆脱它，让事情变得

00:37:51.729 --> 00:38:06.130
小双赢，我们想说

00:38:00.099 --> 00:38:12.910
名字，这将是简，好的

00:38:06.130 --> 00:38:16.089
我们的第一张唱片，约翰好吧， 

00:38:12.910 --> 00:38:18.160
那太酷了，所以我们去了

00:38:16.089 --> 00:38:21.039
有我们的硬编码杰森字符串， 

00:38:18.160 --> 00:38:24.339
期望被放回任何人

00:38:21.039 --> 00:38:26.439
在测试过程中谁去

00:38:24.339 --> 00:38:27.699
本地主机8080或任何此端口

00:38:26.439 --> 00:38:29.619
在这种情况下，端口正在运行

00:38:27.699 --> 00:38:32.140
在这里可以指定8080 

00:38:29.619 --> 00:38:34.479
然后询问您是否知道使用HTTP GET 

00:38:32.140 --> 00:38:36.099
请求此内容，这将

00:38:34.479 --> 00:38:38.079
当然要拆掉整个东西

00:38:36.099 --> 00:38:39.459
这整个假服务器将旋转起来， 

00:38:38.079 --> 00:38:40.929
然后在这个时候被拆除

00:38:39.459 --> 00:38:43.900
测试时它关闭的东西

00:38:40.929 --> 00:38:46.049
关闭，让我们尝试一下

00:38:43.900 --> 00:38:46.049
认为

00:38:55.800 --> 00:39:07.440
好吧，我们什么时候想念啊，我要做

00:39:02.950 --> 00:39:07.440
这两次与以前不同

00:39:15.590 --> 00:39:19.950
已经很高兴了

00:39:18.060 --> 00:39:21.690
很棒，这就是我们正在做的

00:39:19.950 --> 00:39:23.250
预期一切似乎

00:39:21.690 --> 00:39:25.890
好吧，我们有一个绿色的客户，我们有

00:39:23.250 --> 00:39:29.160
绿色消费者和绿色服务，以及

00:39:25.890 --> 00:39:31.110
绿色生产者，但你知道

00:39:29.160 --> 00:39:33.120
我认为很清楚

00:39:31.110 --> 00:39:34.290
那是绿色吗

00:39:33.120 --> 00:39:36.630
事情实际上不起作用，并且

00:39:34.290 --> 00:39:38.730
原因是因为我们正在建立这个

00:39:36.630 --> 00:39:40.830
错误假设下的整个客户

00:39:38.730 --> 00:39:43.230
沿第二条路线喂食

00:39:40.830 --> 00:39:44.900
指望属性的名称， 

00:39:43.230 --> 00:39:47.130
它从保留名称到名称

00:39:44.900 --> 00:39:49.290
因此，尽管客户端绿色

00:39:47.130 --> 00:39:54.110
实际上是完全不同的

00:39:49.290 --> 00:39:56.520
在服务上输入正确的信息，因此在这里

00:39:54.110 --> 00:39:58.830
我有保留名就是我的名字

00:39:56.520 --> 00:40:01.110
应该一直在使用

00:39:58.830 --> 00:40:02.760
生产者方面和最

00:40:01.110 --> 00:40:05.280
这整个事情的欺骗性部分是

00:40:02.760 --> 00:40:07.560
他们俩都是绿色的，似乎都

00:40:05.280 --> 00:40:08.970
似乎都认为一切

00:40:07.560 --> 00:40:11.520
很好，但是我们会

00:40:08.970 --> 00:40:13.170
生产大概或至少

00:40:11.520 --> 00:40:15.300
集成测试并发现

00:40:13.170 --> 00:40:16.410
虽然这根本不起作用绿色

00:40:15.300 --> 00:40:18.390
双方都是，这有点

00:40:16.410 --> 00:40:20.220
你知道那会动摇一点

00:40:18.390 --> 00:40:23.730
如果您希望有

00:40:20.220 --> 00:40:25.440
已经被抓了，你知道我们吗

00:40:23.730 --> 00:40:27.090
做一个整体，那么这将是一个

00:40:25.440 --> 00:40:29.220
编译器会告诉编译器错误

00:40:27.090 --> 00:40:30.960
你，你打破了一个东西

00:40:29.220 --> 00:40:33.090
您所依赖的是预期的类型

00:40:30.960 --> 00:40:35.610
当其他东西绑定到它上去工作

00:40:33.090 --> 00:40:37.380
你知道一个客户消费了，在这里

00:40:35.610 --> 00:40:40.170
我们有一个REST API我们的网络合同

00:40:37.380 --> 00:40:45.240
这就是非常严格的

00:40:40.170 --> 00:40:47.310
所以解决这个问题的一种方法是给你

00:40:45.240 --> 00:40:49.260
我想知道我会使用RPC，但是那你就输了

00:40:47.310 --> 00:40:51.600
开放网络的一些好处和

00:40:49.260 --> 00:40:52.920
如果那是你的那是你的包，那么

00:40:51.600 --> 00:40:56.820
当然那不是一个选择

00:40:52.920 --> 00:40:58.170
所以我们想要获得信心

00:40:56.820 --> 00:41:00.120
我们正在建造的东西是

00:40:58.170 --> 00:41:01.140
实际上那个东西和那个东西

00:41:00.120 --> 00:41:05.120
我们正在测试的实际上是

00:41:01.140 --> 00:41:07.740
生产中存在的东西，所以在这里

00:41:05.120 --> 00:41:10.110
我们要做的是使用消费者驱动的

00:41:07.740 --> 00:41:12.480
使用Spring Cloud Contract的合约

00:41:10.110 --> 00:41:15.750
现在，以消费者为导向的合同相当合理

00:41:12.480 --> 00:41:18.210
简单明了，它们是定义的方式

00:41:15.750 --> 00:41:22.380
测试这些合同得到的单元测试

00:41:18.210 --> 00:41:24.060
转换成单元测试

00:41:22.380 --> 00:41:25.500
然后针对您的代码运行，它是

00:41:24.060 --> 00:41:27.350
几乎就像我们写的一样

00:41:25.500 --> 00:41:29.600
这个这个

00:41:27.350 --> 00:41:31.100
我们之前写的其余测试

00:41:29.600 --> 00:41:34.580
这就是我们要做的，好吧，我们

00:41:31.100 --> 00:41:38.180
要为我们编写一个非常简单的测试

00:41:34.580 --> 00:41:42.590
应用程序，该测试将

00:41:38.180 --> 00:41:44.090
它会扩展某种基础

00:41:42.590 --> 00:41:45.350
测试它是否必须执行相同的设置

00:41:44.090 --> 00:41:47.720
等等，让我们回到我们的

00:41:45.350 --> 00:41:51.080
生产者方面，这是服务

00:41:47.720 --> 00:41:54.080
我要使用Spring Cloud Contract 

00:41:51.080 --> 00:41:55.960
我们将配置该插件

00:41:54.080 --> 00:41:59.750
现在我有了插件配置

00:41:55.960 --> 00:42:09.800
躺在周围没有人被抓住

00:41:59.750 --> 00:42:11.690
太不知道了，所以有那个副本

00:42:09.800 --> 00:42:15.650
并粘贴好，所以我有

00:42:11.690 --> 00:42:17.030
插件，爸爸，那是什么

00:42:15.650 --> 00:42:18.470
就是说我有 Spring 了

00:42:17.030 --> 00:42:22.370
上的云合约Maven插件

00:42:18.470 --> 00:42:23.690
生产者方版本202和我的

00:42:22.370 --> 00:42:24.710
我们将在合同中看到的合同

00:42:23.690 --> 00:42:28.160
这些实际上是时髦的

00:42:24.710 --> 00:42:29.870
定义一个

00:42:28.160 --> 00:42:32.270
与他们定义的服务进行交互

00:42:29.870 --> 00:42:34.190
客户应该如何与给定的人交谈

00:42:32.270 --> 00:42:35.770
服务他们定义那个客户

00:42:34.190 --> 00:42:38.900
应该从给定的服务中期望

00:42:35.770 --> 00:42:41.780
这些期望变成了

00:42:38.900 --> 00:42:44.870
在这里进行的测试

00:42:41.780 --> 00:42:50.210
针对我们实际的真实API的服务

00:42:44.870 --> 00:42:54.500
 REST API，所以如果是绿色，那么我们

00:42:50.210 --> 00:42:58.400
可以安装或部署存根定义

00:42:54.500 --> 00:42:59.840
你基本上知道一个

00:42:58.400 --> 00:43:02.780
创建所需的配置

00:42:59.840 --> 00:43:05.090
电线模拟API被部署， 

00:43:02.780 --> 00:43:08.510
那么现在我们可以在消费者方面

00:43:05.090 --> 00:43:10.850
消耗那些存根定义

00:43:08.510 --> 00:43:14.450
建立符合实际情况的模拟API 

00:43:10.850 --> 00:43:16.420
这项生产服务等等

00:43:14.450 --> 00:43:19.460
考虑到这一点，让我们创建一个非常简单的

00:43:16.420 --> 00:43:20.930
合同，合同将得到

00:43:19.460 --> 00:43:23.300
我说的这个插件

00:43:20.930 --> 00:43:26.420
是执法的一部分

00:43:23.300 --> 00:43:27.470
合同机制好，所以我在这里

00:43:26.420 --> 00:43:34.660
要说源测试

00:43:27.470 --> 00:43:39.760
资源合同还可以

00:43:34.660 --> 00:43:47.600
在这里得到一个新文件，如果我们全部

00:43:39.760 --> 00:43:52.540
预订doc电影，这只是一个

00:43:47.600 --> 00:43:52.540
 gue我们可以使用的VDSL请求

00:43:52.660 --> 00:44:00.800
响应，我们描述了API，所以我

00:43:58.220 --> 00:44:07.610
要说什么时候应该返回

00:44:00.800 --> 00:44:10.340
所有保留都可以，要求是

00:44:07.610 --> 00:44:15.110
将会转到称为

00:44:10.340 --> 00:44:18.620
保留将要使用的方法

00:44:15.110 --> 00:44:20.960
 HT t得到的响应将是状态

00:44:18.620 --> 00:44:27.400
你知道的代码200我想我们可以

00:44:20.960 --> 00:44:30.440
使用H作为状态，此处是点值， 

00:44:27.400 --> 00:44:38.290
内容类型或我猜标题

00:44:30.440 --> 00:44:38.290
和C标头内容类型媒体类型

00:44:39.910 --> 00:44:50.090
点应用程序Jason utf-8值和

00:44:43.850 --> 00:44:52.610
我猜身体会如下

00:44:50.090 --> 00:44:54.830
我们可以使用您知道的GUI对象

00:44:52.610 --> 00:44:57.170
文字语法在这里创建一个Jason 

00:44:54.830 --> 00:44:59.050
像结构，有点像

00:44:57.170 --> 00:45:06.200
选项，我们可以做到，我们可以说

00:44:59.050 --> 00:45:10.490
预订名称Jane即预订

00:45:06.200 --> 00:45:12.680
叫约翰，好吧，这是杰森

00:45:10.490 --> 00:45:15.320
像结构，我可以轻松地使用

00:45:12.680 --> 00:45:17.000
正确的字符串我可以做我所做的事

00:45:15.320 --> 00:45:18.830
当然还有Java代码，但是

00:45:17.000 --> 00:45:21.320
这很古怪，所以更容易

00:45:18.830 --> 00:45:25.910
只是说你知道写东西

00:45:21.320 --> 00:45:30.760
就像JSON一样，所以您

00:45:25.910 --> 00:45:36.100
知道我们的ID一号预订

00:45:30.760 --> 00:45:36.100
名字简

00:45:36.460 --> 00:45:45.050
好吧-约翰好吧，这是我们的

00:45:43.400 --> 00:45:47.750
 JSON输出，我们有多行

00:45:45.050 --> 00:45:49.520
字符串数组，这样就可以了

00:45:47.750 --> 00:45:51.380
这实际上只是

00:45:49.520 --> 00:45:53.480
是结果，所以现在我们

00:45:51.380 --> 00:45:55.340
期望这会导致某些结果

00:45:53.480 --> 00:45:57.410
你知道我们期待这

00:45:55.340 --> 00:45:59.750
将变成一个测试，将

00:45:57.410 --> 00:46:02.900
然后在四点调用我们的实际REST API 

00:45:59.750 --> 00:46:06.080
使用HTTP GET和

00:46:02.900 --> 00:46:07.640
它会导致回应

00:46:06.080 --> 00:46:09.500
返回其状态应为状态

00:46:07.640 --> 00:46:11.480
代码200及其常量类型应为

00:46:09.500 --> 00:46:14.210
应用程序Jason utf-8值及其

00:46:11.480 --> 00:46:17.090
身体在结构上应该与此匹配

00:46:14.210 --> 00:46:19.070
应该具有两个对象的JSON 

00:46:17.090 --> 00:46:21.410
在他身上记录两张记录，其中一张有

00:46:19.070 --> 00:46:24.230
彼此的想法是两个ID 

00:46:21.410 --> 00:46:26.240
首先要预约的是简和

00:46:24.230 --> 00:46:30.970
第二个应该是约翰，依此类推， 

00:46:26.240 --> 00:46:33.740
现在，为了使它起作用，我们需要

00:46:30.970 --> 00:46:36.020
设置我们需要的基本信息

00:46:33.740 --> 00:46:38.950
正确设置马赫信息

00:46:36.020 --> 00:46:43.609
因为就在我们的模拟MVC之前

00:46:38.950 --> 00:46:44.180
我们在这里使用模拟网络测试客户端代码

00:46:43.609 --> 00:46:49.369
模仿

00:46:44.180 --> 00:46:51.650
和模拟 bean 告诉Spring创建一个

00:46:49.369 --> 00:46:53.210
每当有人的时候，虚拟的数据集

00:46:51.650 --> 00:46:54.140
很好地调用了预订存储库

00:46:53.210 --> 00:46:56.930
为此需要做同样的事情

00:46:54.140 --> 00:46:58.790
合同和公寓编译器

00:46:56.930 --> 00:47:02.600
插件，尽管我们的构建插件会

00:46:58.790 --> 00:47:07.160
需要知道我们来自什么基类

00:47:02.600 --> 00:47:12.109
合同可以延伸到继承

00:47:07.160 --> 00:47:13.430
设置逻辑好，我们需要提供

00:47:12.109 --> 00:47:21.590
因此，让我们创建该基类

00:47:13.430 --> 00:47:22.940
在这里，基类看起来全部

00:47:21.590 --> 00:47:25.300
在一起很熟悉，如果您曾经使用过

00:47:22.940 --> 00:47:29.690
你知道，因为我们只是在

00:47:25.300 --> 00:47:32.690
另一方面，基类是

00:47:29.690 --> 00:47:34.190
只会与

00:47:32.690 --> 00:47:38.270
模仿位和最后一位

00:47:34.190 --> 00:47:39.710
放心的api的初始化

00:47:38.270 --> 00:47:42.890
这是根据这是API 

00:47:39.710 --> 00:47:44.210
支撑Spring 式合约发动机

00:47:42.890 --> 00:47:46.340
我们需要做一些设置

00:47:44.210 --> 00:47:47.700
对于那是我承认的一点

00:47:46.340 --> 00:47:49.800
奇怪但是

00:47:47.700 --> 00:47:52.710
你知道它有用，所以谁在乎服务器

00:47:49.800 --> 00:47:53.820
点端口等于零并告诉它运行

00:47:52.710 --> 00:47:55.260
我们要告诉这个当地人

00:47:53.820 --> 00:47:57.000
应用程序在随机端口上运行

00:47:55.260 --> 00:48:00.090
假设我们要在网络上运行

00:47:57.000 --> 00:48:04.620
环境等于Web环境点

00:48:00.090 --> 00:48:07.910
我们想要基类的随机端口

00:48:04.620 --> 00:48:12.600
我参加了 Spring 跑步者圆点课程

00:48:07.910 --> 00:48:14.250
要导入我们的配置

00:48:12.600 --> 00:48:17.780
迈克（Mike）就像预约之前一样

00:48:14.250 --> 00:48:19.830
其余配置有这个

00:48:17.780 --> 00:48:23.400
因为它将在随机端口上运行

00:48:19.830 --> 00:48:26.910
我想注入那个端口然后取

00:48:23.400 --> 00:48:30.540
优点是我要使用模拟

00:48:26.910 --> 00:48:40.470
 bean 注入我们的保留

00:48:30.540 --> 00:48:48.770
好的仓库，我们先说

00:48:40.470 --> 00:48:55.740
公共无效设置引发异常

00:48:48.770 --> 00:48:58.590
现在mockito点赢得了这个点

00:48:55.740 --> 00:49:04.260
保留将发布令状，然后查找所有

00:48:58.590 --> 00:49:07.440
返回流量只是新的保留

00:49:04.260 --> 00:49:14.870
额外的一个，我们想要一些数据约翰

00:49:07.440 --> 00:49:18.690
简和对约翰的新保留权

00:49:14.870 --> 00:49:20.550
然后终于要休息了

00:49:18.690 --> 00:49:28.860
放心，我们需要做的

00:49:20.550 --> 00:49:32.550
此代码库URI等于HTTP localhost 

00:49:28.860 --> 00:49:34.830
当然港口就是那个港口

00:49:32.550 --> 00:49:36.420
好的，所以有我们的更新代码

00:49:34.830 --> 00:49:40.890
就像您知道已更新以反映

00:49:36.420 --> 00:49:42.630
我们建造的新现实

00:49:40.890 --> 00:49:48.180
插件知道我们已经拥有的这个基类

00:49:42.630 --> 00:49:50.010
在这里配置了很多，所以我们说孔

00:49:48.180 --> 00:49:51.540
示例生产者基类，因为

00:49:50.010 --> 00:49:53.310
这是反应性的，我们有这个东西

00:49:51.540 --> 00:49:54.810
如果您现在将测试模式显式调用

00:49:53.310 --> 00:49:56.580
没有这个，它将尝试做

00:49:54.810 --> 00:49:58.680
模拟NB C样式测试，但现在

00:49:56.580 --> 00:50:00.060
它正在进行更具反应性的测试

00:49:58.680 --> 00:50:00.920
因为它知道这个网站

00:50:00.060 --> 00:50:03.110
在

00:50:00.920 --> 00:50:06.110
使用反应性Spring 腹板挠性腹板

00:50:03.110 --> 00:50:09.920
运行时而不是仅仅带我

00:50:06.110 --> 00:50:11.060
基于海的servlet运行时好吧好吧

00:50:09.920 --> 00:50:12.650
我们去看看是否可行

00:50:11.060 --> 00:50:15.620
让我们看看是否可行，我们只能

00:50:12.650 --> 00:50:17.750
可以通过访问我们的网站找到答案

00:50:15.620 --> 00:50:21.790
生产者行家清洁

00:50:17.750 --> 00:50:21.790
打包运行只是尝试安装

00:50:37.670 --> 00:50:44.540
行之有效的好东西，我们可以证明

00:50:40.549 --> 00:50:47.299
负面的当然是通过这样做

00:50:44.540 --> 00:50:50.140
例如珍妮特（Janet） 

00:50:47.299 --> 00:50:50.140
我得到的拖延

00:51:01.600 --> 00:51:05.770
你可以看到它坏了， 

00:51:04.060 --> 00:51:07.900
这份合同是否已通过测试

00:51:05.770 --> 00:51:10.810
对我们来说这是一个创意

00:51:07.900 --> 00:51:17.820
由插件和合同强制

00:51:10.810 --> 00:51:17.820
验证程序测试当然是这样的

00:51:19.830 --> 00:51:25.210
就是这样，这是一个诱饵，这是一个

00:51:22.630 --> 00:51:27.700
测试扩展了基类，它是

00:51:25.210 --> 00:51:30.010
使用放心的请求

00:51:27.700 --> 00:51:31.540
戳我们的预订端点

00:51:30.010 --> 00:51:32.800
正在搜索内容类型为

00:51:31.540 --> 00:51:35.140
相邻的应用程序看起来像

00:51:32.800 --> 00:51:36.970
身体看起来像那样，然后

00:51:35.140 --> 00:51:38.350
字符串保留名称的名称是

00:51:36.970 --> 00:51:40.270
在这种情况下等于詹娜特

00:51:38.350 --> 00:51:43.360
那是行不通的，所以我们回去

00:51:40.270 --> 00:51:45.640
并修复它，构建应该是绿色的

00:51:43.360 --> 00:51:47.650
再次，直到mave install及其原因

00:51:45.640 --> 00:51:48.670
我安装这个的原因是

00:51:47.650 --> 00:51:49.900
从命令行运行此

00:51:48.670 --> 00:51:51.820
安装这是因为我要

00:51:49.900 --> 00:51:55.360
想建立是否成功

00:51:51.820 --> 00:51:58.540
想要部署的存根

00:51:55.360 --> 00:52:01.140
我们的模拟存根进入我的本地专家

00:51:58.540 --> 00:52:03.610
存储库或更合理

00:52:01.140 --> 00:52:04.990
环境我会做一个git push和

00:52:03.610 --> 00:52:07.090
然后在持续整合中

00:52:04.990 --> 00:52:08.110
环境会导致你

00:52:07.090 --> 00:52:09.670
知道我会进行所有测试，如果

00:52:08.110 --> 00:52:10.840
他们都是绿色的，我会做专家

00:52:09.670 --> 00:52:13.090
部署，这将归我

00:52:10.840 --> 00:52:15.550
人为因素或我的联系或其他任何因素

00:52:13.090 --> 00:52:18.490
那将是很好的共享

00:52:15.550 --> 00:52:20.410
原谅我与消费者之间的联系

00:52:18.490 --> 00:52:21.730
和他们将分享人工制品的生产者

00:52:20.410 --> 00:52:25.420
他们是他们会想要的文物

00:52:21.730 --> 00:52:27.310
分享在这种情况下是存根，所以你

00:52:25.420 --> 00:52:28.330
看到我们有罐子

00:52:27.310 --> 00:52:30.580
按正常安装

00:52:28.330 --> 00:52:32.620
我们再次非常重视XML 

00:52:30.580 --> 00:52:36.670
正常情况下，我们的存根是

00:52:32.620 --> 00:52:39.070
有趣的是，存根只是

00:52:36.670 --> 00:52:42.720
您足够了解我们的配置

00:52:39.070 --> 00:52:47.040
客户现在启动Web应用程序

00:52:42.720 --> 00:52:50.560
使用看起来可疑的电线模拟

00:52:47.040 --> 00:52:52.710
可疑地喜欢我们已经拥有的API 

00:52:50.560 --> 00:52:55.660
刚刚建成，让我们回到我们的

00:52:52.710 --> 00:52:57.280
客户或消费者现在就清理它

00:52:55.660 --> 00:52:58.900
代码，我们实际上可以删除

00:52:57.280 --> 00:53:02.500
我最喜欢的东西

00:52:58.900 --> 00:53:03.850
编码好再见，然后代替

00:53:02.500 --> 00:53:06.190
明确使用电线模拟的过程

00:53:03.850 --> 00:53:09.280
将要使用存根运行器，所以自动

00:53:06.190 --> 00:53:13.360
配置存根赢家并在此处使用

00:53:09.280 --> 00:53:15.640
 com示例工件是我们的小组

00:53:13.360 --> 00:53:17.080
 ID和生产者

00:53:15.640 --> 00:53:18.640
您将要使用的神器头

00:53:17.080 --> 00:53:20.530
有意义的最新版本Ryan 

00:53:18.640 --> 00:53:22.480
因为我们想使用最新的

00:53:20.530 --> 00:53:24.040
每次部署的版本

00:53:22.480 --> 00:53:25.900
你确实会推动制作人

00:53:24.040 --> 00:53:28.750
合同在哪里

00:53:25.900 --> 00:53:31.030
部署到工件或

00:53:28.750 --> 00:53:33.730
环境，大概是希望

00:53:31.030 --> 00:53:35.410
敲木头也将导致

00:53:33.730 --> 00:53:37.300
被推入生产的建筑

00:53:35.410 --> 00:53:38.740
所以我们要从客户那里得到什么

00:53:37.300 --> 00:53:40.630
假设这是不同的观点

00:53:38.740 --> 00:53:43.300
团队在不同的空间工作

00:53:40.630 --> 00:53:46.120
我们要使用的是下拉

00:53:43.300 --> 00:53:48.070
 IV Maven依赖项的运行时排序

00:53:46.120 --> 00:53:50.710
解析器要做的是

00:53:48.070 --> 00:53:53.380
下拉那个的最新版本

00:53:50.710 --> 00:53:54.610
与代码相对应的存根

00:53:53.380 --> 00:53:56.200
这就是生产中为什么我们要

00:53:54.610 --> 00:53:58.690
用更少的东西来测试我们的客户

00:53:56.200 --> 00:53:59.890
比最新和最伟大的版本

00:53:58.690 --> 00:54:01.960
代码当然是东西

00:53:59.890 --> 00:54:03.670
如果这个工作，如果这个客户是

00:54:01.960 --> 00:54:06.220
部署到生产它将不得不

00:54:03.670 --> 00:54:09.190
与之抗衡，所以我要说下拉

00:54:06.220 --> 00:54:10.510
生产者工件存根下拉

00:54:09.190 --> 00:54:13.030
这是最新版本

00:54:10.510 --> 00:54:14.830
标志是，然后终于开始

00:54:13.030 --> 00:54:17.080
在端口上生成的yr模拟应用程序

00:54:14.830 --> 00:54:20.770
 8080就像我们使用线模拟一样

00:54:17.080 --> 00:54:22.630
明确地，我们可以告诉这个应用程序

00:54:20.770 --> 00:54:24.250
您知道我们在使用Maven吗

00:54:22.630 --> 00:54:26.470
 Java代码在这里可以这么说或行家

00:54:24.250 --> 00:54:28.000
我们正在将依赖项下载为

00:54:26.470 --> 00:54:30.100
虽然我们是行家，所以我们必须

00:54:28.000 --> 00:54:32.080
告诉它在哪里可以找到存根

00:54:30.100 --> 00:54:34.150
是看在类路径上看

00:54:32.080 --> 00:54:36.400
我当地的M2资料库

00:54:34.150 --> 00:54:37.660
想在这种情况下做或看起来

00:54:36.400 --> 00:54:40.120
神器错误查看配置

00:54:37.660 --> 00:54:41.200
的工件或工件存储库

00:54:40.120 --> 00:54:43.900
您的环境，但我要看一下

00:54:41.200 --> 00:54:46.660
在当地，你知道家里有两个

00:54:43.900 --> 00:54:49.840
我要说的是本地存储库

00:54:46.660 --> 00:54:51.100
在那里，我认为我们还可以

00:54:49.840 --> 00:54:52.420
认为实际上其他一切仍然存在

00:54:51.100 --> 00:54:54.070
客户端不需要的方式

00:54:52.420 --> 00:54:56.590
改变我们要做的就是摆脱

00:54:54.070 --> 00:54:58.060
自那以来的愚蠢电线模拟代码

00:54:56.590 --> 00:55:02.250
现在将被暂时转移

00:54:58.060 --> 00:55:02.250
解决，我们可以重新启动

00:55:13.730 --> 00:55:20.130
好吧，我认为我们做错了什么

00:55:17.640 --> 00:55:23.099
我们刚刚发现了这个错误，呵呵

00:55:20.130 --> 00:55:25.650
期望ID为的预订

00:55:23.099 --> 00:55:28.079
一个且名称等于null null 

00:55:25.650 --> 00:55:28.440
指针非常清楚，没有

00:55:28.079 --> 00:55:30.059
工作

00:55:28.440 --> 00:55:32.130
名字不是偶然的事情

00:55:30.059 --> 00:55:33.210
电汇，我们可以通过

00:55:32.130 --> 00:55:36.900
看到它说那个保留

00:55:33.210 --> 00:55:39.390
名字等于简而不是名字

00:55:36.900 --> 00:55:42.059
捕捉到的不兼容

00:55:39.390 --> 00:55:43.470
客户与

00:55:42.059 --> 00:55:45.359
否则会有的服务

00:55:43.470 --> 00:55:46.589
注定了我们在生产中的应用，因此

00:55:45.359 --> 00:55:50.880
让我们重构一下代码

00:55:46.589 --> 00:55:54.050
我们在这里考虑很好的编译只是

00:55:50.880 --> 00:55:57.710
确保一切再次开心， 

00:55:54.050 --> 00:56:00.710
如果可以的话，我们将重新开始测试

00:55:57.710 --> 00:56:00.710
好

00:56:11.700 --> 00:56:17.450
好吧，现在还是坏了，为什么

00:56:19.970 --> 00:56:39.950
我们期望预订名称是我们的

00:56:32.640 --> 00:56:39.950
合同上说简和约翰

00:56:59.040 --> 00:57:02.030
所以

00:57:06.299 --> 00:57:09.410
多么好奇

00:57:24.830 --> 00:57:37.960
所以有我们的客户代码平静的例子

00:57:28.820 --> 00:57:40.460
生产者8080我们要确认

00:57:37.960 --> 00:57:50.080
当我们打电话给所有预订

00:57:40.460 --> 00:57:50.080
那让我们看看

00:57:55.260 --> 00:58:04.680
安装正确的冷静的例子

00:58:00.609 --> 00:58:04.680
制片人很棒

00:58:05.940 --> 00:58:11.340
收到的任务

00:58:08.230 --> 00:58:13.810
我想念这里明显的东西吗

00:58:11.340 --> 00:58:22.330
自动配置步进方式平静示例

00:58:13.810 --> 00:58:24.900
制片人我挑逗存根模式斯普林伍德

00:58:22.330 --> 00:58:24.900
测试

00:58:32.180 --> 00:58:35.349
变化和约翰

00:58:48.930 --> 00:58:52.520
我有些奇怪吗

00:59:07.380 --> 00:59:18.210
如果我们去这里真是太奇怪了

00:59:15.900 --> 00:59:19.970
显然返回了这两个记录，所以

00:59:18.210 --> 00:59:23.599
在这种情况下，我想知道是否可以

00:59:19.970 --> 00:59:28.799
我有些傻

00:59:23.599 --> 00:59:33.390
仓库也许平静的例子甚至

00:59:28.799 --> 00:59:35.190
干净的安装和生产方

00:59:33.390 --> 00:59:38.190
很明显说玫瑰红预订

00:59:35.190 --> 00:59:41.130
内容ID的一个预订名称是Jane 

00:59:38.190 --> 00:59:43.640
然后是约翰，这就是为什么

00:59:41.130 --> 00:59:46.349
无效，它不是有效的JSON数组

00:59:43.640 --> 00:59:48.839
对，所以这很有趣

00:59:46.349 --> 00:59:51.240
不知道有什么事吗

00:59:48.839 --> 00:59:55.069
有了它，让我们再试一次

00:59:51.240 --> 00:59:55.069
清理中间清理安装

01:00:00.280 --> 01:00:04.140
我应该使用对象字面量

01:00:01.900 --> 01:00:10.600
语法在这里我很喜欢

01:00:04.140 --> 01:00:11.470
有理由确定这是问题

01:00:10.600 --> 01:00:15.700
这样可行

01:00:11.470 --> 01:00:17.940
现在，如果我们再回到客户那里

01:00:15.700 --> 01:00:17.940
时间

01:00:28.030 --> 01:00:31.690
好的，这样就解决了

01:00:30.100 --> 01:00:34.180
问题是我当时没有发送

01:00:31.690 --> 01:00:36.400
有效，我发回的记录不是

01:00:34.180 --> 01:00:37.720
到，所以我那不匹配， 

01:00:36.400 --> 01:00:39.580
那就是我们要说的重点

01:00:37.720 --> 01:00:41.350
想确保这些东西匹配

01:00:39.580 --> 01:00:43.390
那里我们去那里我们写了一个

01:00:41.350 --> 01:00:45.310
 Spring 合同的定义可以

01:00:43.390 --> 01:00:47.020
针对我们的反应式网络端点进行测试

01:00:45.310 --> 01:00:49.240
我们可以确保

01:00:47.020 --> 01:00:52.450
客户和我们确保的服务

01:00:49.240 --> 01:00:53.830
该系统工作正常，我们可以

01:00:52.450 --> 01:00:56.800
现在你知道这些东西脱钩了

01:00:53.830 --> 01:00:58.150
显然，如果您不使用

01:00:56.800 --> 01:00:59.830
知道测试的 Spring 合同

01:00:58.150 --> 01:01:01.570
客户可能正在做一个

01:00:59.830 --> 01:01:05.740
 iPhone开发围绕html5或

01:01:01.570 --> 01:01:08.410
您可以使用的东西，例如

01:01:05.740 --> 01:01:11.260
spring-cloud-contract的东西一罐

01:01:08.410 --> 01:01:15.190
这样，您可以使用

01:01:11.260 --> 01:01:16.920
那样的脚本，那个脚本

01:01:15.190 --> 01:01:19.390
脚本说好，我要运行这个罐子

01:01:16.920 --> 01:01:21.490
传递工作离线属性

01:01:19.390 --> 01:01:23.500
填充模式等于本地，我想

01:01:21.490 --> 01:01:26.200
运行这个平静的例子，让我们在这说

01:01:23.500 --> 01:01:32.890
情况将是生产者加8080，所以

01:01:26.200 --> 01:01:42.280
让我们更新该文件Emacs，我会

01:01:32.890 --> 01:01:47.410
说制片人还可以，那就是

01:01:42.280 --> 01:01:51.810
会旋转一个API，这是假的

01:01:47.410 --> 01:01:51.810
 API oops 

01:02:16.569 --> 01:02:26.469
哦，好吧，我对此深有怀疑

01:02:22.539 --> 01:02:33.539
一个与我对JDK的选择有关

01:02:26.469 --> 01:02:41.109
您只是在想SDK这个Java SDK 

01:02:33.539 --> 01:02:47.859
现在使用Java 8，然后尝试

01:02:41.109 --> 01:02:49.630
再次不确定为什么会这样，但是我

01:02:47.859 --> 01:02:57.209
对此有怀疑

01:02:49.630 --> 01:02:59.469
所以在83年很重要

01:02:57.209 --> 01:03:01.660
有我们的API，所以选择

01:02:59.469 --> 01:03:03.459
其中是我默认使用Java 11 

01:03:01.660 --> 01:03:05.589
我想我可能有旧版本

01:03:03.459 --> 01:03:07.029
顽固地敦促我们的API 

01:03:05.589 --> 01:03:09.429
但是在Java上运行就可以了

01:03:07.029 --> 01:03:11.049
所以那应该带你到你的地方

01:03:09.429 --> 01:03:12.549
想去，当然，如果你看到了

01:03:11.049 --> 01:03:14.979
上一个视频，您知道这是

01:03:12.549 --> 01:03:17.380
字符串俱乐部合同是吗

01:03:14.979 --> 01:03:18.519
比何时更有趣

01:03:17.380 --> 01:03:20.829
我在这里展示了它实际上可以使用

01:03:18.519 --> 01:03:22.900
支持消息，你知道我会起来的

01:03:20.829 --> 01:03:26.739
用Kafka或类似的东西

01:03:22.900 --> 01:03:28.299
习惯于存根服务

01:03:26.739 --> 01:03:29.979
注册表，他们不通过

01:03:28.299 --> 01:03:31.299
发现干净的抽象，所以你知道

01:03:29.979 --> 01:03:33.640
您可以在这里做很多事情

01:03:31.299 --> 01:03:36.939
只是REST API，但这很有趣

01:03:33.640 --> 01:03:38.799
方法，它有助于确保

01:03:36.939 --> 01:03:40.650
生产者和消费者都匹配并且

01:03:38.799 --> 01:03:42.969
你不必站得满满的

01:03:40.650 --> 01:03:44.650
复制或复制

01:03:42.969 --> 01:03:46.049
整个生产系统只是为了能够

01:03:44.650 --> 01:03:48.819
测试好像您正在生产中

01:03:46.049 --> 01:03:52.380
我的朋友非常感谢

01:03:48.819 --> 01:03:52.380
看，下次见

01:03:57.860 --> 01:03:59.920
您

