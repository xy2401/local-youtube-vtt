WEBVTT
Kind: captions
Language: zh-Hans

00:00:25.400 --> 00:00:29.610
嗨，春季粉丝们欢迎来到另一个

00:00:27.630 --> 00:00:31.980
在此安装弹簧提示

00:00:29.610 --> 00:00:33.330
分期付款，我们将看看

00:00:31.980 --> 00:00:35.129
解决一个非常普遍的问题

00:00:33.330 --> 00:00:39.150
我给你的东西有点

00:00:35.129 --> 00:00:41.250
有点小角落的情况

00:00:39.150 --> 00:00:42.420
生态系统，但没有一个

00:00:41.250 --> 00:00:44.730
引起很多人的兴趣

00:00:42.420 --> 00:00:46.830
开始考虑这是怎么做的

00:00:44.730 --> 00:00:49.280
我将状态传播到

00:00:46.830 --> 00:00:51.300
反应管道的不同阶段

00:00:49.280 --> 00:00:53.970
因此，请考虑一下这里发生的情况

00:00:51.300 --> 00:00:56.010
与之形成鲜明对比的反应世界

00:00:53.970 --> 00:00:59.340
更传统的方法

00:00:56.010 --> 00:01:00.690
处理将什么Web请求放入和

00:00:59.340 --> 00:01:04.229
解决这些问题

00:01:00.690 --> 00:01:05.850
反应性世界代码不是

00:01:04.229 --> 00:01:08.640
保证在给定线程上执行

00:01:05.850 --> 00:01:10.440
所以这就是我所说的与

00:01:08.640 --> 00:01:13.050
您可能在使用

00:01:10.440 --> 00:01:14.970
对不起，非反应性代码在

00:01:13.050 --> 00:01:17.610
例如， 

00:01:14.970 --> 00:01:20.009
 servlet引擎，除非您有

00:01:17.610 --> 00:01:22.440
否则默认指定是一个

00:01:20.009 --> 00:01:24.210
每个请求的线程数，因此有一个请求

00:01:22.440 --> 00:01:25.500
并且有一个线程托管

00:01:24.210 --> 00:01:27.810
请求和得到的响应

00:01:25.500 --> 00:01:29.100
为该要求而生产的

00:01:27.810 --> 00:01:31.140
发生在单个环境中

00:01:29.100 --> 00:01:33.180
线程等机械，您知道一个

00:01:31.140 --> 00:01:35.280
我们所使用的机制

00:01:33.180 --> 00:01:36.990
我们已经习惯了线程

00:01:35.280 --> 00:01:38.909
那些在我们的服务中为我们服务的当地人

00:01:36.990 --> 00:01:40.380
案件，但他们开始崩溃

00:01:38.909 --> 00:01:42.420
引入同步性后

00:01:40.380 --> 00:01:44.220
也就是说工作的可能性

00:01:42.420 --> 00:01:47.250
会跳到另一个线程

00:01:44.220 --> 00:01:49.770
执行是非常真实的

00:01:47.250 --> 00:01:51.750
反应世界的可能性

00:01:49.770 --> 00:01:55.140
可以执行的编程

00:01:51.750 --> 00:01:56.640
很容易经常跳一个你的线程

00:01:55.140 --> 00:01:58.530
知道从一个线程跳到另一个线程

00:01:56.640 --> 00:02:01.350
在生产过程中

00:01:58.530 --> 00:02:02.790
回应，那么我们如何解决这个问题，我们

00:02:01.350 --> 00:02:04.770
确实需要解决这个问题，这是这个

00:02:02.790 --> 00:02:06.390
是必须解决的问题

00:02:04.770 --> 00:02:08.160
为了解决诸如交易之类的问题

00:02:06.390 --> 00:02:10.110
管理和划分直到

00:02:08.160 --> 00:02:11.700
为了解决诸如安全之类的问题

00:02:10.110 --> 00:02:14.040
上下文传播权这些是

00:02:11.700 --> 00:02:17.549
春天本身依赖的东西

00:02:14.040 --> 00:02:20.130
较低的级别，但您可能没有

00:02:17.549 --> 00:02:21.570
必须直接互动这是一个问题

00:02:20.130 --> 00:02:24.060
有了它，您可能不必直接

00:02:21.570 --> 00:02:27.209
互动，但需要解决

00:02:24.060 --> 00:02:28.489
今天我们要去看看

00:02:27.209 --> 00:02:31.489
叫做反应堆的机制

00:02:28.489 --> 00:02:31.489
语境

00:02:32.720 --> 00:02:36.600
因此构建一个名为

00:02:34.680 --> 00:02:39.570
最奇怪的用途，我们只是要使用

00:02:36.600 --> 00:02:41.190
反应式网络支持

00:02:39.570 --> 00:02:42.990
哦，龙目鼬鼠，我要回来做我的

00:02:41.190 --> 00:02:44.370
生活好一点好命中产生

00:02:42.990 --> 00:03:02.240
这会给我们一个新的zip文件

00:02:44.370 --> 00:03:04.230
我会在这里打开我们去的

00:03:02.240 --> 00:03:05.820
我们将展示一个非常简单的

00:03:04.230 --> 00:03:08.040
首先我们要示范

00:03:05.820 --> 00:03:10.560
只要你知道一个简单的休息终点

00:03:08.040 --> 00:03:19.250
产生一些数据，我们将采取

00:03:10.560 --> 00:03:22.260
看看我们如何使用这些数据，好吧

00:03:19.250 --> 00:03:24.000
让我们假设在我们的基本应用程序中

00:03:22.260 --> 00:03:27.120
这是我们要构建的应用程序

00:03:24.000 --> 00:03:29.160
让我们摆脱这一个摆脱

00:03:27.120 --> 00:03:33.420
我将在这里创建一个基本的

00:03:29.160 --> 00:03:35.130
好吧，让我们看看我们要创建

00:03:33.420 --> 00:03:37.860
一个包装，我想首先

00:03:35.130 --> 00:03:40.200
如此简单，然后放在简单包装中

00:03:37.860 --> 00:03:46.260
当你有一个新的班级叫做

00:03:40.200 --> 00:03:47.730
简单的应用程序还可以

00:03:46.260 --> 00:03:48.810
就像其他任何东西一样

00:03:47.730 --> 00:03:52.709
跳板的应用程序将是

00:03:48.810 --> 00:03:55.770
公共静态无效主要还可以

00:03:52.709 --> 00:03:58.590
组织，我感谢IntelliJ是

00:03:55.770 --> 00:04:02.790
想在25年后提醒我

00:03:58.590 --> 00:04:04.310
我应该下一个括号

00:04:02.790 --> 00:04:06.300
类型而不是参数

00:04:04.310 --> 00:04:08.190
像这样的变量名

00:04:06.300 --> 00:04:10.860
如果这样做，我一直在这样做

00:04:08.190 --> 00:04:12.959
我那黄色的亮点，我会去那里

00:04:10.860 --> 00:04:13.980
周围的变量名谢谢

00:04:12.959 --> 00:04:16.470
我一直这样做是因为我来了

00:04:13.980 --> 00:04:21.239
来自C，所以很抱歉，所以无论如何

00:04:16.470 --> 00:04:24.120
春季应用程序点运行简单

00:04:21.239 --> 00:04:25.710
应用程序点类以及我们

00:04:24.120 --> 00:04:26.910
当

00:04:25.710 --> 00:04:30.060
应用程序启动，我们将有一个

00:04:26.910 --> 00:04:35.430
其余端点，所以我们将其称为

00:04:30.060 --> 00:04:38.220
只是数据，我们将返回一些

00:04:35.430 --> 00:04:39.630
数据还可以，数据将来自

00:04:38.220 --> 00:04:41.460
创建发布者时的发布者

00:04:39.630 --> 00:04:42.840
一秒钟我们希望这是休息

00:04:41.460 --> 00:04:44.220
控制器，当然，我们将在

00:04:42.840 --> 00:04:45.810
休息控制器

00:04:44.220 --> 00:04:47.100
我们将提供一些

00:04:45.810 --> 00:04:50.250
数据，那么我从哪里获得该发布商

00:04:47.100 --> 00:04:53.370
现在要记住屏幕的变化

00:04:50.250 --> 00:04:55.710
这是被动式的发布者

00:04:53.370 --> 00:04:58.080
流将发出数据项

00:04:55.710 --> 00:05:00.210
然后订户可以订阅

00:04:58.080 --> 00:05:02.460
并在不同的线程上处理

00:05:00.210 --> 00:05:05.250
在一纳秒内可能是一年

00:05:02.460 --> 00:05:08.100
对，我们无法保证您

00:05:05.250 --> 00:05:09.030
时间上的耦合好吗

00:05:08.100 --> 00:05:12.630
我们要做的是建立一个

00:05:09.030 --> 00:05:14.370
返回的发布商只是

00:05:12.630 --> 00:05:16.620
做一些简单的事情，比如说我

00:05:14.370 --> 00:05:19.650
创建一个具有名称或

00:05:16.620 --> 00:05:25.050
字母，我猜你可以叫助焊剂点

00:05:19.650 --> 00:05:29.940
只是公元前好，然后我们有一个通量

00:05:25.050 --> 00:05:33.360
整数的所有正确数字

00:05:29.940 --> 00:05:34.920
助焊剂点一二三好

00:05:33.360 --> 00:05:37.169
好，现在我们有了，现在我们需要

00:05:34.920 --> 00:05:44.610
让我们组成它们，让我们说通量点

00:05:37.169 --> 00:05:48.570
邮政编码点图元组，我们

00:05:44.610 --> 00:05:52.200
要带元组得到t1并置

00:05:48.570 --> 00:05:54.120
用冒号和元组得到t2是这个

00:05:52.200 --> 00:05:55.770
有用，但可以说明

00:05:54.120 --> 00:05:57.030
我们正在创建发布商

00:05:55.770 --> 00:06:01.530
管道

00:05:57.030 --> 00:06:08.040
好吧，如此结合，然后我们将

00:06:01.530 --> 00:06:09.840
现在发送回我想要这些数据给我

00:06:08.040 --> 00:06:13.169
希望这些发布者首先

00:06:09.840 --> 00:06:14.910
宣布他们在哪里，在什么地方

00:06:13.169 --> 00:06:17.580
他们正在运行的线程，然后我也

00:06:14.910 --> 00:06:20.760
希望他们能够在

00:06:17.580 --> 00:06:24.030
单独的线程，所以我要创建一个

00:06:20.760 --> 00:06:27.320
此处的方法的专用静态通量

00:06:24.030 --> 00:06:33.390
最长好的，我们只是要

00:06:27.320 --> 00:06:35.700
那里的通用参数还可以

00:06:33.390 --> 00:06:40.229
我们会说我们想做

00:06:35.700 --> 00:06:41.490
点在下一个右边，所以我们要

00:06:40.229 --> 00:06:44.610
这里要做的是我们将提供一个

00:06:41.490 --> 00:06:48.630
每当调用回调

00:06:44.610 --> 00:06:50.910
可以进行任何处理

00:06:48.630 --> 00:06:53.729
其实我们也要做每件事

00:06:50.910 --> 00:06:55.380
那也许你知道更多

00:06:53.729 --> 00:06:58.050
有趣，我不知道还有更多吗

00:06:55.380 --> 00:07:02.500
有趣的是

00:06:58.050 --> 00:07:03.849
是的，所以我想再做一个

00:07:02.500 --> 00:07:05.349
那是第一步

00:07:03.849 --> 00:07:06.669
好吧，这就是我们要做的一切

00:07:05.349 --> 00:07:11.319
这是我们要消耗的

00:07:06.669 --> 00:07:13.000
字符串，然后我们要说

00:07:11.319 --> 00:07:15.009
订阅，我们将要

00:07:13.000 --> 00:07:16.720
订阅自定义调度程序

00:07:15.009 --> 00:07:17.979
问题是，当然是什么针

00:07:16.720 --> 00:07:21.610
什么调度程序，所以我要创建

00:07:17.979 --> 00:07:28.930
我猜测或表示最终的但计划程序

00:07:21.610 --> 00:07:32.650
调度程序等于来自的调度程序点

00:07:28.930 --> 00:07:35.919
执行者执行者点新的修复线程

00:07:32.650 --> 00:07:37.539
游泳池好了，你去，所以有我的

00:07:35.919 --> 00:07:38.740
新的调度程序，我正在削减自定义

00:07:37.539 --> 00:07:40.930
安排你是否应该这样做

00:07:38.740 --> 00:07:42.669
大多数时候可能不正确

00:07:40.930 --> 00:07:44.919
调度程序将是默认的

00:07:42.669 --> 00:07:46.720
由数字支持

00:07:44.919 --> 00:07:48.490
对应于

00:07:46.720 --> 00:07:50.860
您拥有的核心数，每个核心

00:07:48.490 --> 00:07:54.880
充当事件循环，只要没有

00:07:50.860 --> 00:07:56.440
您的任何处理都不会垄断

00:07:54.880 --> 00:07:58.780
正在运行的线程

00:07:56.440 --> 00:08:01.090
它并没有做任何事情

00:07:58.780 --> 00:08:02.500
需要切换到I / O，然后您

00:08:01.090 --> 00:08:03.759
真的不需要这种权利不需要

00:08:02.500 --> 00:08:05.770
管理这个，但是如果你在做

00:08:03.759 --> 00:08:07.750
 JDBC之类的东西

00:08:05.770 --> 00:08:09.969
阻止斐波那契或

00:08:07.750 --> 00:08:13.509
密码学或比特币或其他

00:08:09.969 --> 00:08:15.039
你应该在一个你知道的工作上完成工作

00:08:13.509 --> 00:08:17.650
必须扩大互动

00:08:15.039 --> 00:08:19.240
有更多的线程，所以它可能

00:08:17.650 --> 00:08:22.120
在这种情况下变得有用

00:08:19.240 --> 00:08:23.949
我只是要提供额外的线程

00:08:22.120 --> 00:08:27.130
好了，所以我们去了

00:08:23.949 --> 00:08:29.229
我正在通过以下方式更改即将到来的发布者

00:08:27.130 --> 00:08:30.909
首先我要配置

00:08:29.229 --> 00:08:33.430
注销信息我要注销

00:08:30.909 --> 00:08:37.060
通过使用任何log4j获得该信息

00:08:33.430 --> 00:08:39.520
更长的时间，可以插入那么长的时间

00:08:37.060 --> 00:08:41.020
信息T，当然这可能是

00:08:39.520 --> 00:08:43.329
写成lambda，可以是

00:08:41.020 --> 00:08:44.950
像这样写为根方法参考

00:08:43.329 --> 00:08:51.570
很好，那还不错

00:08:44.950 --> 00:08:56.550
所以我们要说准备好一个

00:08:51.570 --> 00:08:56.550
并准备

00:08:58.339 --> 00:09:04.100
然后我们就可以了，还有我的

00:09:02.189 --> 00:09:06.420
结合你知道

00:09:04.100 --> 00:09:09.959
预处理到发布者，我只是

00:09:06.420 --> 00:09:11.959
会把合并的那一转

00:09:09.959 --> 00:09:15.329
所以现在让我们说我们转身

00:09:11.959 --> 00:09:17.249
阅读所有权利，现在我们可以重新启动

00:09:15.329 --> 00:09:22.920
这个应用程序让我们看看我们得到了什么

00:09:17.249 --> 00:09:28.069
去吧去吧，假设我们可以内联

00:09:22.920 --> 00:09:28.069
同时在这里闲逛好

00:09:36.370 --> 00:09:40.520
直到今天仍然认为我们有旧的

00:09:38.450 --> 00:09:42.890
一说老公共静虚

00:09:40.520 --> 00:09:45.680
我们首先出售它们的主要方式

00:09:42.890 --> 00:09:56.800
初始化项目，所以没有

00:09:45.680 --> 00:10:00.260
更长的时间还不错，所以现在卷曲HTP 

00:09:56.800 --> 00:10:01.940
本地主机：8080 / data很好

00:10:00.260 --> 00:10:04.640
很简单，有我们的数据， 

00:10:01.940 --> 00:10:05.720
当我们注销时，您可以看到

00:10:04.640 --> 00:10:08.960
事情在不同的地方执行

00:10:05.720 --> 00:10:12.980
对数字执行的线程正确

00:10:08.960 --> 00:10:16.730
线程3这是合并的

00:10:12.980 --> 00:10:18.620
线程3以及两个字母都在这里结束

00:10:16.730 --> 00:10:24.680
哦，是的，所有这些字母都在线程上

00:10:18.620 --> 00:10:27.470
 2，这里是3，但是这里

00:10:24.680 --> 00:10:29.690
是组合的线程，所以它

00:10:27.470 --> 00:10:33.260
在线程3上，所以他们将一个与

00:10:29.690 --> 00:10:35.030
然后就在线程前进中，所以

00:10:33.260 --> 00:10:37.700
您可以看到基于

00:10:35.030 --> 00:10:39.080
无论它需要什么标准

00:10:37.700 --> 00:10:41.210
围绕不同的线程工作，那就是

00:10:39.080 --> 00:10:43.280
这是正确的功能之一

00:10:41.210 --> 00:10:44.660
响应式API可以，但是可以

00:10:43.280 --> 00:10:45.770
使事情变得更加复杂

00:10:44.660 --> 00:10:47.510
意味着我们不能认为是理所当然的

00:10:45.770 --> 00:10:50.090
如果我们在

00:10:47.510 --> 00:10:52.190
那个地方那个著名的数据

00:10:50.090 --> 00:10:55.280
然后将可见并可供

00:10:52.190 --> 00:10:58.370
在这个管道中发生的一切

00:10:55.280 --> 00:10:59.480
到此为止，我们不能

00:10:58.370 --> 00:11:01.160
我们不能认为这是理所当然的

00:10:59.480 --> 00:11:03.320
因为虽然这些东西看起来

00:11:01.160 --> 00:11:04.880
势在必行

00:11:03.320 --> 00:11:06.350
我们写的东西是顺序的

00:11:04.880 --> 00:11:07.820
他们是事实的事实是

00:11:06.350 --> 00:11:09.770
这些事情可能是同时发生的

00:11:07.820 --> 00:11:11.210
他们可能并发正确的事情

00:11:09.770 --> 00:11:14.390
可能在同一时间发生

00:11:11.210 --> 00:11:16.400
不同的线程，所以我们需要

00:11:14.390 --> 00:11:18.490
依靠其他一些机制

00:11:16.400 --> 00:11:24.440
做到这一点的方法是提供一个

00:11:18.490 --> 00:11:26.300
订阅者上下文现在可以了，虽然我可以

00:11:24.440 --> 00:11:27.710
文字是一个对象，它只是一个

00:11:26.300 --> 00:11:32.540
字典基本上是字典

00:11:27.710 --> 00:11:38.030
您有权访问的

00:11:32.540 --> 00:11:40.940
该反应堆将采用的管道

00:11:38.030 --> 00:11:43.220
关心为您永存权利， 

00:11:40.940 --> 00:11:44.690
这样做的好处是您可以

00:11:43.220 --> 00:11:46.670
这些数据可用，您可以做到这一点

00:11:44.690 --> 00:11:48.450
数据

00:11:46.670 --> 00:11:50.220
在一开始就可用

00:11:48.450 --> 00:11:51.780
管道，即使它跨过

00:11:50.220 --> 00:11:54.210
不同的线程边界

00:11:51.780 --> 00:11:54.750
仅对那个阶段可见

00:11:54.210 --> 00:11:55.860
管道

00:11:54.750 --> 00:11:57.750
不管是哪个线程

00:11:55.860 --> 00:12:00.770
运行，所以我们可以用它来

00:11:57.750 --> 00:12:04.530
传播例如你知道

00:12:00.770 --> 00:12:06.020
应用程序令牌和标头以及三个

00:12:04.530 --> 00:12:09.480
认证原则和

00:12:06.020 --> 00:12:11.670
交易，你知道什么

00:12:09.480 --> 00:12:17.490
您希望一生都可以访问

00:12:11.670 --> 00:12:19.410
一个给定的发行商，好吧，让我们做

00:12:17.490 --> 00:12:22.620
我们要在这里

00:12:19.410 --> 00:12:24.270
准备方法，让我们尝试一下

00:12:22.620 --> 00:12:26.850
只是这个还行，所以我要给

00:12:24.270 --> 00:12:28.980
这是一个订户上下文，好吧，我要

00:12:26.850 --> 00:12:32.040
说订户上下文，我的工作是

00:12:28.980 --> 00:12:34.380
给定一个上下文非常简单的返回

00:12:32.040 --> 00:12:35.430
我可以做任何我想做的事

00:12:34.380 --> 00:12:38.160
可以改变它的环境

00:12:35.430 --> 00:12:43.920
可以覆盖它，我可以为它做贡献

00:12:38.160 --> 00:12:45.840
等等等，这是一个选择，你

00:12:43.920 --> 00:12:49.130
知道对我有用，我实际上可以做一个

00:12:45.840 --> 00:12:52.440
设置或应用或其他任何选项

00:12:49.130 --> 00:12:54.510
只是提供参考

00:12:52.440 --> 00:12:57.320
本身使用方便的构建器

00:12:54.510 --> 00:13:02.430
方法，所以在这里我可以说上下文是

00:12:57.320 --> 00:13:05.100
 UID，您知道这将是我的关闭ID或

00:13:02.430 --> 00:13:07.980
好的，您的用户名就可以了

00:13:05.100 --> 00:13:12.900
让我们来看看，然后我们实际上可以

00:13:07.980 --> 00:13:17.180
将UID点随机存储到字符串永不消失

00:13:12.900 --> 00:13:23.220
那是一个随机的字符串

00:13:17.180 --> 00:13:24.840
将在里面的内部可见

00:13:23.220 --> 00:13:27.690
该管道的各个阶段

00:13:24.840 --> 00:13:29.250
所以我们实际上添加该管道

00:13:27.690 --> 00:13:32.010
实际上，现在您知道因为我们

00:13:29.250 --> 00:13:33.600
看到合并的字母可以

00:13:32.010 --> 00:13:35.610
跨不同的线程执行，所以现在

00:13:33.600 --> 00:13:38.700
让我们证明说吧

00:13:35.610 --> 00:13:41.190
每一个都行，所以我要放一个消费者

00:13:38.700 --> 00:13:42.660
这将消耗一个信号，在这里

00:13:41.190 --> 00:13:44.400
信号代表什么

00:13:42.660 --> 00:13:49.010
方法被称为是下一步吗

00:13:44.400 --> 00:13:54.060
是否在订阅等，所以信号不我

00:13:49.010 --> 00:13:56.250
说出信号点是否在下一个右边或

00:13:54.060 --> 00:13:59.670
如果不在下一个地方则放另一种方式

00:13:56.250 --> 00:14:00.040
现在返回，否则我们要处理

00:13:59.670 --> 00:14:02.589
我们想要

00:14:00.040 --> 00:14:04.329
实际上，您知道从

00:14:02.589 --> 00:14:06.100
信号中的骗局，所以我们可以说

00:14:04.329 --> 00:14:11.079
信号没有上下文

00:14:06.100 --> 00:14:14.199
好的，这样我们就可以看

00:14:11.079 --> 00:14:18.250
好把钥匙放在上面，所以钥匙是

00:14:14.199 --> 00:14:28.540
称为用户ID，因此您可以说get或

00:14:18.250 --> 00:14:31.779
默认，我们可以说全部获取该密钥

00:14:28.540 --> 00:14:39.060
那里是我们的UID，我们可以注销

00:14:31.779 --> 00:14:45.630
此管道阶段的日志信息用户标识

00:14:39.060 --> 00:14:54.069
或数据，然后将是信号点

00:14:45.630 --> 00:14:58.930
获取字符串点是信号是用户标识

00:14:54.069 --> 00:15:01.720
天气，所以我要登出

00:14:58.930 --> 00:15:03.639
在下一个方法调用中的数据

00:15:01.720 --> 00:15:05.769
然后我注销用户ID 

00:15:03.639 --> 00:15:07.899
一直伴随着

00:15:05.769 --> 00:15:10.230
有了这种互动，让我们尝试

00:15:07.899 --> 00:15:10.230
这个出来

00:15:24.000 --> 00:15:27.240
你去

00:15:28.050 --> 00:15:34.810
看看那个，现在当我做

00:15:31.810 --> 00:15:38.530
请求此管道阶段的用户标识

00:15:34.810 --> 00:15:45.970
 1 B 2和C 3完全相同

00:15:38.530 --> 00:15:50.860
现在记住这些

00:15:45.970 --> 00:15:52.720
都在线程10上

00:15:50.860 --> 00:15:55.270
你知道不同的线程，所以你可以

00:15:52.720 --> 00:15:56.470
看到我们有一个事实，这些东西

00:15:55.270 --> 00:16:00.220
正在穿越不同的道路

00:15:56.470 --> 00:16:01.090
这是9那是1，这是一样的

00:16:00.220 --> 00:16:05.470
物线9 

00:16:01.090 --> 00:16:08.320
这是B 2 C的线程10 

00:16:05.470 --> 00:16:09.940
 3拍就10 

00:16:08.320 --> 00:16:11.440
非常简单的权利，我是说你

00:16:09.940 --> 00:16:13.690
可以看到这里发生了什么

00:16:11.440 --> 00:16:15.970
只需使用订户上下文

00:16:13.690 --> 00:16:17.380
创建一个充当

00:16:15.970 --> 00:16:19.870
基本上是一本字典，你可以看到

00:16:17.380 --> 00:16:21.730
那里有一堆你

00:16:19.870 --> 00:16:24.880
知道你可以和你一起工作

00:16:21.730 --> 00:16:27.640
或者你可以提供一个转变

00:16:24.880 --> 00:16:28.660
需要当前上下文的函数

00:16:27.640 --> 00:16:30.880
你可以用你可以一个新的

00:16:28.660 --> 00:16:33.820
具有现有值的上下文

00:16:30.880 --> 00:16:35.410
从现有环境中

00:16:33.820 --> 00:16:38.260
有新值，当我们插入

00:16:35.410 --> 00:16:40.030
好的，那是理论上的

00:16:38.260 --> 00:16:44.470
这在

00:16:40.030 --> 00:16:47.140
春天，例如在春季安全中

00:16:44.470 --> 00:16:49.560
对，所以如果你去春季安全

00:16:47.140 --> 00:16:52.320
在这里，我们要寻找

00:16:49.560 --> 00:16:59.620
反应堆环境腹板过滤器

00:16:52.320 --> 00:17:05.980
上下文网络过滤器安全性还可以， 

00:16:59.620 --> 00:17:09.280
在那里，您可以使用此代码

00:17:05.980 --> 00:17:11.620
例子是春季安全

00:17:09.280 --> 00:17:13.900
集成反应式代码和此

00:17:11.620 --> 00:17:16.240
实际上是一个反应式网页过滤器

00:17:13.900 --> 00:17:17.710
这是一个弹簧什么web柔韧性过滤器

00:17:16.240 --> 00:17:24.430
它不是servlet过滤器-Web Flex 

00:17:17.710 --> 00:17:26.920
过滤器，它又有一个方法

00:17:24.430 --> 00:17:30.400
称为筛选器，它需要一个幕后HTTP 

00:17:26.920 --> 00:17:32.370
请求和链，我们配置

00:17:30.400 --> 00:17:36.730
我们说的过滤器链式过滤器交换

00:17:32.370 --> 00:17:38.890
传播你知道允许事情

00:17:36.730 --> 00:17:40.600
下游为

00:17:38.890 --> 00:17:41.890
管道三个活动管道，然后

00:17:40.600 --> 00:17:45.550
终于在那末尾

00:17:41.890 --> 00:17:47.350
添加我订阅一个上下文

00:17:45.550 --> 00:17:50.260
当前的上下文检查，看是否

00:17:47.350 --> 00:17:54.340
有一个钥匙，如果有的话，我们把它打开

00:17:50.260 --> 00:17:55.900
否则，我们将创建一个新的上下文或

00:17:54.340 --> 00:17:58.000
实际上是哪个改变了上下文

00:17:55.900 --> 00:17:59.440
向其添加安全上下文

00:17:58.000 --> 00:18:02.290
他们做出反应，所以春季安全

00:17:59.440 --> 00:18:04.450
安全上下文是一件事

00:18:02.290 --> 00:18:07.000
当前经过身份验证的用户，因此

00:18:04.450 --> 00:18:08.890
您发布HTTP帖子或基于表单

00:18:07.000 --> 00:18:10.750
登录以将信息传递给

00:18:08.890 --> 00:18:13.960
某种身份验证管理器

00:18:10.750 --> 00:18:16.120
然后要么确认您知道

00:18:13.960 --> 00:18:19.900
它确认这是那个人或

00:18:16.120 --> 00:18:22.570
客户或任何声称自己的客户

00:18:19.900 --> 00:18:25.240
你知道它自称是

00:18:22.570 --> 00:18:27.100
如果是这样的话，那就藏起来

00:18:25.240 --> 00:18:28.660
结果认证对象

00:18:27.100 --> 00:18:32.380
安全的地方

00:18:28.660 --> 00:18:34.570
上下文持有者，那就是

00:18:32.380 --> 00:18:36.010
通过以下方式提供的上下文

00:18:34.570 --> 00:18:38.890
这个过滤器在所有的开始

00:18:36.010 --> 00:18:41.140
 Web请求在Spring Web Flex中出现，所以现在

00:18:38.890 --> 00:18:43.690
 Spring Security中代码中的任何地方

00:18:41.140 --> 00:18:45.010
您可以注入当前经过身份验证的

00:18:43.690 --> 00:18:47.830
校长，因为春季安全可以

00:18:45.010 --> 00:18:50.070
看一下当前的管道

00:18:47.830 --> 00:18:52.570
通过此反应式Web过滤器修改并

00:18:50.070 --> 00:18:54.130
查看上下文并提取出来

00:18:52.570 --> 00:18:55.810
安全上下文类型的对象

00:18:54.130 --> 00:18:57.850
类是我正在使用的另一件事

00:18:55.810 --> 00:18:58.960
关键在这里，但想像我想存储

00:18:57.850 --> 00:19:01.090
一些更有趣的数据

00:18:58.960 --> 00:19:03.670
可以说您知道课程用户ID的统计信息

00:19:01.090 --> 00:19:04.060
好的，我可以做类似的事情

00:19:03.670 --> 00:19:10.930
这个

00:19:04.060 --> 00:19:13.780
我是UID字符串，当然您知道吗

00:19:10.930 --> 00:19:15.730
可以做到，那将在我身边

00:19:13.780 --> 00:19:17.770
可以说而不是使用钥匙

00:19:15.730 --> 00:19:19.720
正确的班级类型

00:19:17.770 --> 00:19:21.940
并将其与

00:19:19.720 --> 00:19:24.010
管道也很明显

00:19:21.940 --> 00:19:26.530
数据越小越好，但是

00:19:24.010 --> 00:19:28.240
关键是你们都可以做得很好

00:19:26.530 --> 00:19:30.010
所以这是一个非常简单的抽象想法

00:19:28.240 --> 00:19:33.370
我希望春季安全可以

00:19:30.010 --> 00:19:36.220
现在查看可能的应用程序

00:19:33.370 --> 00:19:39.250
我在这里更具体一点

00:19:36.220 --> 00:19:42.480
要直接举一个例子

00:19:39.250 --> 00:19:44.680
甚至我都不会打扰

00:19:42.480 --> 00:19:46.690
写这个，我什至不必写

00:19:44.680 --> 00:19:48.160
这你知道我自己，我什至没有

00:19:46.690 --> 00:19:50.770
想象这是一个很好的例子

00:19:48.160 --> 00:19:53.350
由反应堆团队传奇

00:19:50.770 --> 00:19:56.380
反应堆反应忍者

00:19:53.350 --> 00:20:02.770
非凡的海员博斯利

00:19:56.380 --> 00:20:05.080
从C Mon Bosley上下文记录

00:20:02.770 --> 00:20:08.280
让我们看看我是否可以找到这个

00:20:05.080 --> 00:20:12.820
很棒的书好吧，所以这个博客来自

00:20:08.280 --> 00:20:14.260
今年早些时候着眼于使用MDC 

00:20:12.820 --> 00:20:16.690
看反应上下文对象

00:20:14.260 --> 00:20:18.490
并以此作为使

00:20:16.690 --> 00:20:20.320
 MDC在那里的背景

00:20:18.490 --> 00:20:21.820
可用于记录，因此当您登录时

00:20:20.320 --> 00:20:23.320
删除日志中的内容

00:20:21.820 --> 00:20:25.210
信息键和值可以是

00:20:23.320 --> 00:20:26.800
与具有

00:20:25.210 --> 00:20:28.690
传统上一直基于

00:20:26.800 --> 00:20:32.620
该线程本地，因此在此博客中

00:20:28.690 --> 00:20:35.220
西蒙妮看着你怎么知道

00:20:32.620 --> 00:20:39.250
返工永远如此微小

00:20:35.220 --> 00:20:41.140
利用新的上下文对象

00:20:39.250 --> 00:20:42.490
在反应堆中，所以我要告诉你

00:20:41.140 --> 00:20:44.650
那实际上就是我们要做的

00:20:42.490 --> 00:20:46.390
接下来看，这是一个非常简单的示例， 

00:20:44.650 --> 00:20:49.240
它很好地展示了事物

00:20:46.390 --> 00:20:50.380
非常漂亮，所以我不是

00:20:49.240 --> 00:20:52.960
完全不同的东西

00:20:50.380 --> 00:20:54.760
达不到他的标准

00:20:52.960 --> 00:20:56.820
据说我只是要用那个所以我们

00:20:54.760 --> 00:21:02.050
要创建一个非常简单的MDC 

00:20:56.820 --> 00:21:03.340
应用程序，这个应用程序是

00:21:02.050 --> 00:21:05.620
将成为Springwood应用程序

00:21:03.340 --> 00:21:08.440
这将是我要有一个记录器

00:21:05.620 --> 00:21:09.970
它将成为救援的核心

00:21:08.440 --> 00:21:13.300
我们要去做的是

00:21:09.970 --> 00:21:16.660
证明我们可以回应

00:21:13.300 --> 00:21:19.270
 HTTP请求并提供

00:21:16.660 --> 00:21:20.920
回应，我们可以关联信息

00:21:19.270 --> 00:21:22.540
与可见的请求

00:21:20.920 --> 00:21:26.260
然后将其提供给

00:21:22.540 --> 00:21:28.540
日志记录上下文名称日志记录主机

00:21:26.260 --> 00:21:30.850
数据上下文好吧，我该怎么办

00:21:28.540 --> 00:21:36.040
现在就像他做了一个

00:21:30.850 --> 00:21:37.020
餐厅服务，服务来了

00:21:36.040 --> 00:21:41.170
上

00:21:37.020 --> 00:21:45.790
该服务将为

00:21:41.170 --> 00:21:50.200
他去哪家餐馆的问题

00:21:45.790 --> 00:21:52.540
允许其以最高价格访问

00:21:50.200 --> 00:21:56.710
我们去了，我们将使用双

00:21:52.540 --> 00:22:01.570
和价格好，当我是

00:21:56.710 --> 00:22:03.080
这里的细节双人间餐厅

00:22:01.570 --> 00:22:10.720
价格

00:22:03.080 --> 00:22:14.890
人私有字符串名称可以

00:22:10.720 --> 00:22:14.890
这将是公共静态无效主体

00:22:15.550 --> 00:22:23.530
没有我，我不会走的太远

00:22:17.840 --> 00:22:28.190
期待所有春季申请

00:22:23.530 --> 00:22:31.910
春季应用程序运行MDC 

00:22:28.190 --> 00:22:33.950
应用点类ARDS非常好，所以

00:22:31.910 --> 00:22:35.750
我们去那里那就是现在

00:22:33.950 --> 00:22:41.440
我们会提供申请吗

00:22:35.750 --> 00:22:45.380
有好的构造函数， 

00:22:41.440 --> 00:22:50.390
我们将在我们返回数据时

00:22:45.380 --> 00:22:51.830
在这里把数据和我们的数据

00:22:50.390 --> 00:22:53.600
只是会有一些硬编码的数据

00:22:51.830 --> 00:22:54.350
只会引用一些数据，因为

00:22:53.600 --> 00:22:56.210
我实际上没有数据库

00:22:54.350 --> 00:22:58.070
虽然与此有关

00:22:56.210 --> 00:23:00.290
都是被动的，所以我们可以和我们交谈

00:22:58.070 --> 00:23:02.120
 UBC我们可以使用反应式MongoDB您

00:23:00.290 --> 00:23:04.430
可以使用反应性Couchbase或

00:23:02.120 --> 00:23:06.650
 Cassandra或Redis一切正常

00:23:04.430 --> 00:23:10.340
很好，但我只是要综合

00:23:06.650 --> 00:23:12.320
演示中的一些数据

00:23:10.340 --> 00:23:15.790
构造函数在这里，为了做到这一点

00:23:12.320 --> 00:23:18.680
我将创建一个集合

00:23:15.790 --> 00:23:23.470
数据的硬编码响应好私有

00:23:18.680 --> 00:23:23.470
最终收藏

00:23:23.690 --> 00:23:34.910
好的餐馆餐馆等于你

00:23:29.020 --> 00:23:36.920
并发跳过此设置

00:23:34.910 --> 00:23:41.620
那必须是可比的，所以我们将

00:23:36.920 --> 00:23:47.470
设定新的比较巡演，我要说哦

00:23:41.620 --> 00:23:58.630
一个要价的人我要去做

00:23:47.470 --> 00:24:01.210
与第一回合相比加倍

00:23:58.630 --> 00:24:11.300
二

00:24:01.210 --> 00:24:12.620
好吧，我们将创建该集合

00:24:11.300 --> 00:24:13.880
在集合中，我们将

00:24:12.620 --> 00:24:15.950
有一些数据我要写一些

00:24:13.880 --> 00:24:21.770
通过生成旧式的beta 

00:24:15.950 --> 00:24:23.120
都是说我在流点中

00:24:21.770 --> 00:24:26.210
只是想建立一个范围而已

00:24:23.120 --> 00:24:32.840
建立从零到十二的范围

00:24:26.210 --> 00:24:40.870
对象II整数到字符串餐厅

00:24:32.840 --> 00:24:40.870
我可以，这样就可以了

00:24:46.270 --> 00:25:02.960
好吧，新餐厅，它将是一个

00:24:58.100 --> 00:25:16.220
加倍，所以我们接下来要说新的随机点

00:25:02.960 --> 00:25:18.860
双倍我不加点100好，然后

00:25:16.220 --> 00:25:21.620
名称将是字符串，然后是每个

00:25:18.860 --> 00:25:23.240
我想我们可以只是想要的其中之一

00:25:21.620 --> 00:25:30.500
设置为a我们将其添加到

00:25:23.240 --> 00:25:35.870
那里的每个收藏

00:25:30.500 --> 00:25:39.200
点餐厅集合，好吗

00:25:35.870 --> 00:25:40.790
似乎很简单，所以我们

00:25:39.200 --> 00:25:41.720
只是要在中启动应用程序

00:25:40.790 --> 00:25:44.210
我们要写的构造函数

00:25:41.720 --> 00:25:45.830
一堆记录到那个集合

00:25:44.210 --> 00:25:47.420
这将是可比的

00:25:45.830 --> 00:25:49.400
为阅读而优化

00:25:47.420 --> 00:25:51.230
这就是为什么不是

00:25:49.400 --> 00:25:56.000
不太适合，但无论是演示

00:25:51.230 --> 00:26:01.040
好吧，非常简单的演示，这不是

00:25:56.000 --> 00:26:03.230
更长的真正的好餐厅还可以，所以

00:26:01.040 --> 00:26:05.390
这是我们的数据，这是我们的

00:26:03.230 --> 00:26:08.180
发布者，这是我们的反应性终点

00:26:05.390 --> 00:26:11.570
我们要说的是

00:26:08.180 --> 00:26:18.290
查找记录时说要获取数据

00:26:11.570 --> 00:26:21.170
点这个点餐厅点你好

00:26:18.290 --> 00:26:27.550
流，如果我想当你过滤

00:26:21.170 --> 00:26:27.550
说餐厅，那将是

00:26:28.150 --> 00:26:34.220
当我说餐厅医生套件价格时

00:26:31.220 --> 00:26:39.020
每人小于或等于最大

00:26:34.220 --> 00:26:40.670
价格合适，这样就可以

00:26:39.020 --> 00:26:44.260
符合我们谓词的餐厅

00:26:40.670 --> 00:26:46.370
好的

00:26:44.260 --> 00:26:50.260
简单，从中我们可以得到一个

00:26:46.370 --> 00:26:54.140
发布者，因此流中的flex点是

00:26:50.260 --> 00:26:55.760
好的，那就是基本的演示

00:26:54.140 --> 00:26:56.810
好的，那很简单，我们

00:26:55.760 --> 00:26:58.940
要创建一个休息控制器

00:26:56.810 --> 00:27:06.980
以防万一是那个数据

00:26:58.940 --> 00:27:14.900
所以您知道用户ID的危机

00:27:06.980 --> 00:27:17.960
餐馆餐馆让我们来做

00:27:14.900 --> 00:27:23.500
这很容易，所以我要假设

00:27:17.960 --> 00:27:27.470
价格作为一个类别作为一个作为

00:27:23.500 --> 00:27:29.930
区分这里，但我希望用户

00:27:27.470 --> 00:27:32.510
生活中可见的ID信息

00:27:29.930 --> 00:27:35.660
的要求，因此我将

00:27:32.510 --> 00:27:37.010
说这是路径变量， 

00:27:35.660 --> 00:27:39.740
您也可以使用请求参数

00:27:37.010 --> 00:27:44.650
没关系，在这里，双

00:27:39.740 --> 00:27:49.610
将是路径变量的两倍价格

00:27:44.650 --> 00:27:58.150
好吧，所以我们想注入

00:27:49.610 --> 00:27:58.150
像这样的餐厅服务

00:27:58.230 --> 00:28:05.400
他们已经把这个停靠了

00:28:03.210 --> 00:28:09.929
餐厅服务点以最高价获得

00:28:05.400 --> 00:28:12.390
价格，我想在登录时使用该上下文

00:28:09.929 --> 00:28:14.220
在此发布者中获取信息

00:28:12.390 --> 00:28:16.740
这个被动的发布者我想

00:28:14.220 --> 00:28:20.130
我要注销信息吗

00:28:16.740 --> 00:28:23.250
关于搜索，然后我想注销

00:28:20.130 --> 00:28:26.580
搜索的结果，然后我

00:28:23.250 --> 00:28:28.950
想注销当前知道的

00:28:26.580 --> 00:28:32.400
当前的应用程序ID，现在让我们

00:28:28.950 --> 00:28:41.340
在这里改变我们的小出版商

00:28:32.400 --> 00:28:46.169
因此专用于此的私人静态批次

00:28:41.340 --> 00:28:53.299
好的，牙齿消费者密钥登录下一步，然后

00:28:46.169 --> 00:29:01.590
这将是消费者的长期声明

00:28:53.299 --> 00:29:04.350
好吧，所以有我我是我的经理， 

00:29:01.590 --> 00:29:10.280
我要做的就是改变

00:29:04.350 --> 00:29:13.770
这我要改变你知道避免

00:29:10.280 --> 00:29:19.500
调整结果好吧，所以我想

00:29:13.770 --> 00:29:22.830
餐馆的变化，我们会做

00:29:19.500 --> 00:29:26.270
使用它，所以我想说适应您

00:29:22.830 --> 00:29:32.250
可以肯定用过滤器做到这一点

00:29:26.270 --> 00:29:36.000
结果，我将返回

00:29:32.250 --> 00:29:37.410
和以前一样的餐厅，这是我们

00:29:36.000 --> 00:29:39.320
会做所有的工作

00:29:37.410 --> 00:29:46.350
改变这个结果，所以我要说

00:29:39.320 --> 00:29:47.850
第一次返回单点只是紧张

00:29:46.350 --> 00:29:50.490
格式，所以我要注销

00:29:47.850 --> 00:29:54.150
管道开始寻找

00:29:50.490 --> 00:29:55.570
餐厅，我想我们实际上可以

00:29:54.150 --> 00:30:08.480
嗯

00:29:55.570 --> 00:30:17.570
传递价格UID和价格还可以

00:30:08.480 --> 00:30:26.629
串双价，价格更低

00:30:17.570 --> 00:30:29.149
那好吧，所以美元符号

00:30:26.629 --> 00:30:30.830
用户ID正确，然后在您输入字符串时

00:30:29.149 --> 00:30:39.379
这样的格式，所以UID 

00:30:30.830 --> 00:30:43.909
正确的价格UID，然后从那里开始

00:30:39.379 --> 00:30:46.519
我要说的是做每个，我是

00:30:43.909 --> 00:30:49.580
要注销返回的结果

00:30:46.519 --> 00:30:51.499
所以先登录，然后就可以了

00:30:49.580 --> 00:30:54.230
在我传递给它的消费者中

00:30:51.499 --> 00:30:58.100
我要做的就是日志和

00:30:54.230 --> 00:30:58.669
然后我会说我想得到

00:30:58.100 --> 00:31:04.789
结果

00:30:58.669 --> 00:31:08.330
所以餐厅服务开始让我最大

00:31:04.789 --> 00:31:10.879
价格，实际上我们已经有了

00:31:08.330 --> 00:31:13.070
别这样，我不需要重做

00:31:10.879 --> 00:31:17.240
搜索，我们只是将其传递通过，然后

00:31:13.070 --> 00:31:21.529
然后从那里我想记录更多

00:31:17.240 --> 00:31:22.999
数据，所以我在这里说的要记住

00:31:21.529 --> 00:31:24.830
餐厅数据将是我们得到的

00:31:22.999 --> 00:31:35.720
在这一点上，我在这里要说

00:31:24.830 --> 00:31:39.350
记录该信息发现餐厅还可以

00:31:35.720 --> 00:31:43.129
然后我们就是那个名字或到达

00:31:39.350 --> 00:31:45.639
得到每人的价格，然后最终

00:31:43.129 --> 00:31:52.999
我将设置订户上下文

00:31:45.639 --> 00:31:55.730
是API ID的上下文，它将是

00:31:52.999 --> 00:32:00.879
 UID暴露的就是我的身份

00:31:55.730 --> 00:32:00.879
我真的想在那里编码好吗

00:32:02.150 --> 00:32:06.380
所以现在怎么了

00:32:20.860 --> 00:32:24.240
我会做的每个

00:32:28.180 --> 00:32:31.050
好的

00:32:51.670 --> 00:32:54.960
问题是什么

00:32:56.950 --> 00:33:00.510
我们准备去

00:33:01.630 --> 00:33:15.090
啊，不希望这是T的信号

00:33:09.570 --> 00:33:17.799
好的，那将是一家餐厅

00:33:15.090 --> 00:33:19.270
完美吧，所以我们已经

00:33:17.799 --> 00:33:21.039
餐厅有点多余， 

00:33:19.270 --> 00:33:23.500
我正在解决一个真实的问题

00:33:21.039 --> 00:33:26.590
很高兴我们修复了现在我要做什么

00:33:23.500 --> 00:33:29.940
我要说的是这种方法

00:33:26.590 --> 00:33:34.450
找到实际工作的地方

00:33:29.940 --> 00:33:36.520
餐厅好吧，这是一个不错的但丁

00:33:34.450 --> 00:33:38.140
意大利人用眼睛如此原谅我

00:33:36.520 --> 00:33:41.429
拼写就没事了，所以现在

00:33:38.140 --> 00:33:45.669
我们给了我们简单的工作一个信号

00:33:41.429 --> 00:33:49.630
当我说如果我们要返回一个

00:33:45.669 --> 00:33:56.740
信号在下一个或者不是

00:33:49.630 --> 00:33:58.059
然后返回就可以了，但是我们要

00:33:56.740 --> 00:34:04.750
从当前数据中获取数据

00:33:58.059 --> 00:34:08.230
上下文，所以我要说这样的PID 

00:34:04.750 --> 00:34:11.470
我要询问当前的情况

00:34:08.230 --> 00:34:13.990
得到或空着，当你看着空着

00:34:11.470 --> 00:34:15.669
对于我认为是UID的API ID， 

00:34:13.990 --> 00:34:18.940
我们称之为什么，我要说

00:34:15.669 --> 00:34:20.649
好吧，如果不是的话，我们要

00:34:18.940 --> 00:34:22.960
使用时处理是否存在

00:34:20.649 --> 00:34:24.580
不是我们要去处理

00:34:22.960 --> 00:34:27.940
弄错了我生成了这个项目

00:34:24.580 --> 00:34:29.710
使用Java 1.8但实际上使用1111 

00:34:27.940 --> 00:34:31.450
无论如何，这是一个更好的版本， 

00:34:29.710 --> 00:34:34.139
一些不错的API在这里使我

00:34:31.450 --> 00:34:38.080
想要在这里做一点简单

00:34:34.139 --> 00:34:40.240
好吧好吧所以我想做的就是我要

00:34:38.080 --> 00:34:41.919
说那个想法是否存在，我要去

00:34:40.240 --> 00:34:47.169
说给我它或可选的是

00:34:41.919 --> 00:34:50.020
空我要说的是API ID点

00:34:47.169 --> 00:34:52.060
目前，否则，如果它在那里使用它

00:34:50.020 --> 00:34:54.010
否则运行可运行的

00:34:52.060 --> 00:34:57.190
在Java 8中不存在，但是在那里

00:34:54.010 --> 00:35:00.400
在工作中，在这种情况下为9或11，那么

00:34:57.190 --> 00:35:04.240
我要说的是

00:35:00.400 --> 00:35:05.670
有一个字符串yep的使用者

00:35:04.240 --> 00:35:08.039
当下

00:35:05.670 --> 00:35:15.319
好吧，现在你知道的喜欢

00:35:08.039 --> 00:35:20.960
我要说的就是UID 

00:35:15.319 --> 00:35:23.549
不然现在就跑牛市

00:35:20.960 --> 00:35:26.099
好的还不错吧

00:35:23.549 --> 00:35:29.750
因此，可运行性将非常简单

00:35:26.099 --> 00:35:29.750
我们只是说我要注销数据

00:35:29.809 --> 00:35:44.309
假设日志语句文档接受并

00:35:40.549 --> 00:35:44.789
我要打电话通知时间去买一些

00:35:44.309 --> 00:35:47.460
测井

00:35:44.789 --> 00:35:50.010
我记得这种方法需要

00:35:47.460 --> 00:35:52.470
消费者和我传递的消费者

00:35:50.010 --> 00:35:56.430
所发出的价值，以及

00:35:52.470 --> 00:36:00.349
我可以随心所欲地处理它

00:35:56.430 --> 00:36:03.420
在那里，但是我想乘UID， 

00:36:00.349 --> 00:36:06.510
将其附加到当前的MDC，我可以

00:36:03.420 --> 00:36:09.390
使用自动方便地执行此操作

00:36:06.510 --> 00:36:15.410
可关闭的功能，所以有一个MDC 

00:36:09.390 --> 00:36:19.410
可以关闭，所以我可以说尝试关闭

00:36:15.410 --> 00:36:24.059
等于将MDC设为可关闭状态的MDC 

00:36:19.410 --> 00:36:26.640
这个演示的范围还活着

00:36:24.059 --> 00:36:29.970
互动，但不再正确了

00:36:26.640 --> 00:36:36.859
方便，所以当你知道里面

00:36:29.970 --> 00:36:36.859
在那里我把它放在这里

00:36:37.560 --> 00:36:49.830
点运行正常，所以有点混乱

00:36:44.130 --> 00:36:52.950
如果您认为我可以授予您，那么让我们

00:36:49.830 --> 00:36:54.980
在这里查看发生了什么事

00:36:52.950 --> 00:36:56.670
每一个都有消费的消费者

00:36:54.980 --> 00:36:59.520
咒语，我想我们可以打电话给

00:36:56.670 --> 00:37:00.810
每个，但实际上我们只关心

00:36:59.520 --> 00:37:02.340
关于接下来的事件是什么

00:37:00.810 --> 00:37:05.420
我们正在做的是我们正在过滤掉那些

00:37:02.340 --> 00:37:09.030
如果我们正在运行下一个事件或

00:37:05.420 --> 00:37:11.850
方法或其他方法，然后我们看一下

00:37:09.030 --> 00:37:13.470
当前的情况，我们要求

00:37:11.850 --> 00:37:14.730
实际上只是称这个UID为

00:37:13.470 --> 00:37:16.650
一致，实际上我可以

00:37:14.730 --> 00:37:18.090
提取所有这些，我可以做

00:37:16.650 --> 00:37:27.560
当然可以做得更好

00:37:18.090 --> 00:37:29.670
这是一个私有的最终静态字符串， 

00:37:27.560 --> 00:37:32.820
会在各处使用相同的密钥

00:37:29.670 --> 00:37:34.590
无论是在上下文中还是在我的MDC中

00:37:32.820 --> 00:37:36.690
范围或其他

00:37:34.590 --> 00:37:43.310
好，这样可以使事情变得一点点

00:37:36.690 --> 00:37:47.610
更简单，我将其重命名为UID 

00:37:43.310 --> 00:37:50.430
可选，我们可以，所以现在我们可以

00:37:47.610 --> 00:37:52.680
看到我会有某种UID 

00:37:50.430 --> 00:37:56.460
那是沿着包装的

00:37:52.680 --> 00:38:01.230
整个生命周期中的包装范围

00:37:56.460 --> 00:38:03.990
发布商，我将在此处访问该UID 

00:38:01.230 --> 00:38:06.330
如果下次在

00:38:03.990 --> 00:38:09.000
我们的下一个方法被调用，然后我会

00:38:06.330 --> 00:38:13.470
我会检查它是否在下一个

00:38:09.000 --> 00:38:17.910
在下一个然后我将运行此块

00:38:13.470 --> 00:38:20.400
附加当前数据的代码

00:38:17.910 --> 00:38:22.490
 UID将其添加到的上下文

00:38:20.400 --> 00:38:24.690
记录器的当前MDC上下文

00:38:22.490 --> 00:38:26.100
在相同的键下不必

00:38:24.690 --> 00:38:27.810
相同的钥匙可能是您想要的任何东西

00:38:26.100 --> 00:38:30.090
但我要这样附和

00:38:27.810 --> 00:38:32.550
附上课程一次

00:38:30.090 --> 00:38:34.020
我将运行实际的操作

00:38:32.550 --> 00:38:36.470
我们想要做的工作是

00:38:34.020 --> 00:38:39.030
回调这里的消费者

00:38:36.470 --> 00:38:40.680
客户代码将传递给我们，所以我只是

00:38:39.030 --> 00:38:43.170
调用日志，我基本上是在调用

00:38:40.680 --> 00:38:45.180
某人给我的功能

00:38:43.170 --> 00:38:47.220
打电话给我要用

00:38:45.180 --> 00:38:49.500
一直以来的价值

00:38:47.220 --> 00:38:49.900
在当前信号中为我提供

00:38:49.500 --> 00:38:51.580
目前

00:38:49.900 --> 00:38:55.780
当前值的生成

00:38:51.580 --> 00:38:58.150
发射好了，所以它要么存在

00:38:55.780 --> 00:39:02.020
反应堆中存在UID 

00:38:58.150 --> 00:39:04.900
在这种情况下，我将其插入

00:39:02.020 --> 00:39:07.330
记录MDC，然后运行

00:39:04.900 --> 00:39:08.890
消费者或它不存在

00:39:07.330 --> 00:39:10.330
案例我只是经营消费者，但要么

00:39:08.890 --> 00:39:12.250
它必须运行的方式只是一个

00:39:10.330 --> 00:39:15.280
我们是否设置任何东西

00:39:12.250 --> 00:39:20.170
在运行Emma DMDC之前

00:39:15.280 --> 00:39:24.060
好，那是设定的基本要素

00:39:20.170 --> 00:39:26.650
被发现的反应堆环境

00:39:24.060 --> 00:39:33.540
期待我错过了什么

00:39:26.650 --> 00:39:33.540
哦，好吧，那权利看起来不错

00:39:36.360 --> 00:39:40.780
那里应该可以的

00:39:39.100 --> 00:39:42.790
更好，所以现在唯一的

00:39:40.780 --> 00:39:44.320
剩下的当然是建立

00:39:42.790 --> 00:39:46.990
记录模式，以便我们可以实际

00:39:44.320 --> 00:39:48.190
看看如何注销，这就是

00:39:46.990 --> 00:39:50.350
在春天做起来很容易，但是-所以

00:39:48.190 --> 00:39:55.420
我们只是要自定义日志记录

00:39:50.350 --> 00:40:07.530
模式在这里模式控制台等于和

00:39:55.420 --> 00:40:15.960
我们想说磅洋红色线青色

00:40:07.530 --> 00:40:15.960
 X UID好

00:40:16.880 --> 00:40:37.470
突出显示五级记录器

00:40:26.420 --> 00:40:41.370
 36点M消息，然后我们走了

00:40:37.470 --> 00:40:43.620
这就是我们的自定义记录器

00:40:41.370 --> 00:40:44.940
踢，所以你可以看到直到现在我

00:40:43.620 --> 00:40:47.220
得到了这种默认的 spring boot 

00:40:44.940 --> 00:40:50.130
很好的记录模式

00:40:47.220 --> 00:40:55.490
很好，但我们希望看到该当前应用

00:40:50.130 --> 00:40:55.490
 ID，所以我们现在使用的是UI 

00:41:00.050 --> 00:41:04.340
 oops已经运行应用程序的端口

00:41:02.880 --> 00:41:07.020
已经在同一端口上运行

00:41:04.340 --> 00:41:09.980
所以我们停止它并重新启动

00:41:07.020 --> 00:41:09.980
 MDC应用

00:41:14.510 --> 00:41:20.880
好的，它已经启动并正在运行，现在我想要

00:41:18.090 --> 00:41:22.020
我说我去的时候去拜访这个终点

00:41:20.880 --> 00:41:26.970
也一个

00:41:22.020 --> 00:41:29.670
因此将成为餐馆和

00:41:26.970 --> 00:41:32.540
价格将是，所以我们不知道是什么

00:41:29.670 --> 00:41:32.540
我们要的价格

00:41:33.440 --> 00:41:37.580
您应该已经注销了这些价格

00:41:40.650 --> 00:41:44.210
好吧，我想从统计学上讲

00:41:43.290 --> 00:41:53.540
会小于那个

00:41:44.210 --> 00:41:53.540
好吧，所以JQ点名称

00:42:08.410 --> 00:42:18.290
它看起来不错，让我们看看

00:42:15.440 --> 00:42:20.650
统计上让我们看看

00:42:18.290 --> 00:42:20.650
较小的

00:42:25.850 --> 00:42:30.510
是的，如果我减少了

00:42:28.410 --> 00:42:32.790
从统计上选择您知道的东西

00:42:30.510 --> 00:42:34.950
只有1％的结果会

00:42:32.790 --> 00:42:38.190
小于一项权利，所以那是呃

00:42:34.950 --> 00:42:40.140
大约可以，比不到还好

00:42:38.190 --> 00:42:54.810
等于当我做

00:42:40.140 --> 00:42:57.020
这些要求现在让我们看看我想要

00:42:54.810 --> 00:43:00.710
登出信息不是吗

00:42:57.020 --> 00:43:00.710
我们有什么在这里

00:43:04.410 --> 00:43:07.609
日志声明

00:43:09.330 --> 00:43:20.700
日志信息日志信息找到餐厅get 

00:43:14.130 --> 00:43:26.940
名称这里是一个线程这里是应用程序ID 

00:43:20.700 --> 00:43:32.670
对1212与我们有12间餐厅

00:43:26.940 --> 00:43:35.340
所以现在如果我变成15岁，您可以看到

00:43:32.670 --> 00:43:37.350
它说15所以实际上是这样

00:43:35.340 --> 00:43:38.760
用线程破坏请求

00:43:37.350 --> 00:43:40.620
很难证明这一点

00:43:38.760 --> 00:43:45.240
否则我的意思是让我们看看那里的卷曲

00:43:40.620 --> 00:43:52.530
应该是一个小拉发布嘿

00:43:45.240 --> 00:43:53.910
知道20家餐厅101好的，所以

00:43:52.530 --> 00:43:56.520
我实际上有两组不同的数据

00:43:53.910 --> 00:44:01.680
那里只有两套结果，但是

00:43:56.520 --> 00:44:04.350
现在我们应该看到20和15，依此类推

00:44:01.680 --> 00:44:05.880
好的，这是一个非常简单的示例

00:44:04.350 --> 00:44:08.910
但这确实证明了这很有用

00:44:05.880 --> 00:44:10.770
 API很好，这里的MDC API 

00:44:08.910 --> 00:44:12.690
 SL 4j非常方便，您可以

00:44:10.770 --> 00:44:14.310
这是一个抽象，所以我们可以轻松地

00:44:12.690 --> 00:44:17.220
在某些事情上的通用方式

00:44:14.310 --> 00:44:19.320
上下文很高兴我们有这个

00:44:17.220 --> 00:44:20.430
 API，您可以通过其他方式使用它

00:44:19.320 --> 00:44:22.140
想要有一个我确定你能想到的

00:44:20.430 --> 00:44:24.600
您想永久保留的东西

00:44:22.140 --> 00:44:27.420
沿着给定反应堆的生命周期

00:44:24.600 --> 00:44:30.600
管道，这就是你的做法

00:44:27.420 --> 00:44:32.730
只需将事物添加到上下文中即可

00:44:30.600 --> 00:44:34.980
订户上下文，然后您可以

00:44:32.730 --> 00:44:37.560
把那些东西拉出来

00:44:34.980 --> 00:44:37.920
您的经理或其他任何地方

00:44:37.560 --> 00:44:39.240
管道

00:44:37.920 --> 00:44:42.810
你可以把它藏在你可以的地方

00:44:39.240 --> 00:44:44.310
做各种有趣的事情，所以我的

00:44:42.810 --> 00:44:46.110
的朋友，非常感谢你

00:44:44.310 --> 00:44:47.610
看着并再次向海员表示感谢

00:44:46.110 --> 00:44:50.010
博斯利（Bosley）有很好的榜样

00:44:47.610 --> 00:44:52.290
很平淡，对于您的博客

00:44:50.010 --> 00:44:56.340
所有人都应该去读记得吗

00:44:52.290 --> 00:44:58.430
这种机制支撑了很多

00:44:56.340 --> 00:45:01.140
我们在其中进行交易划分

00:44:58.430 --> 00:45:02.130
和安全上下文传播全部

00:45:01.140 --> 00:45:04.200
这些事情，你可以

00:45:02.130 --> 00:45:05.880
想像一下，想在旧时做

00:45:04.200 --> 00:45:07.680
使用线程本地人的旧世界，你可以

00:45:05.880 --> 00:45:09.240
现在在反应堆中做，我认为这是

00:45:07.680 --> 00:45:12.360
那些设置反应堆的东西之一

00:45:09.240 --> 00:45:14.580
领先于其他一些技术

00:45:12.360 --> 00:45:15.990
在同一类别中

00:45:14.580 --> 00:45:17.610
打包，因为这实际上是其中之一

00:45:15.990 --> 00:45:19.980
很多人没有的东西

00:45:17.610 --> 00:45:21.780
我认为这是一个非常有趣的地方

00:45:19.980 --> 00:45:23.170
与那个我的没关系

00:45:21.780 --> 00:45:24.760
像我这样的朋友非常感谢你

00:45:23.170 --> 00:45:27.060
为了观看，我们会见到你

00:45:24.760 --> 00:45:27.060
下次

00:45:32.400 --> 00:45:34.460
您

