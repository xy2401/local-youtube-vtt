WEBVTT
Kind: captions
Language: zh-Hans

00:00:15.030 --> 00:00:19.480
嗨， Spring 粉丝在本期中

00:00:17.830 --> 00:00:22.000
我们想看看的 Spring 提示

00:00:19.480 --> 00:00:24.190
不是一个特定的项目，而那个

00:00:22.000 --> 00:00:27.400
我们要特别关注的问题

00:00:24.190 --> 00:00:29.470
看一下各种实用程序

00:00:27.400 --> 00:00:32.980
 Spring Framework 内部的类

00:00:29.470 --> 00:00:35.020
而不是 Spring ，这些不是

00:00:32.980 --> 00:00:35.980
与任何一件特定的事情有关

00:00:35.020 --> 00:00:37.810
就像您看到的那样，我们要走了

00:00:35.980 --> 00:00:40.570
通过很多不同的用途

00:00:37.810 --> 00:00:42.880
今天的案例我只想浮出水面

00:00:40.570 --> 00:00:44.829
这些，因为如果您使用Spring 

00:00:42.880 --> 00:00:45.820
而你想利用一些

00:00:44.829 --> 00:00:47.800
这个功能已经是

00:00:45.820 --> 00:00:49.900
那里你不需要伸手去拿

00:00:47.800 --> 00:00:51.520
如果您不需要另一个库，并且

00:00:49.900 --> 00:00:53.170
很有可能是功能

00:00:51.520 --> 00:00:55.330
意味着已经在一个Ds实用程序类中

00:00:53.170 --> 00:00:57.700
现在不是说你

00:00:55.330 --> 00:01:00.070
如果其他库不应该使用

00:00:57.700 --> 00:01:02.440
满足您的用例，但我觉得

00:01:00.070 --> 00:01:05.140
堆砌其中一些

00:01:02.440 --> 00:01:08.140
实用程序类现在可能非常有用

00:01:05.140 --> 00:01:09.880
我们将在其中研究所有这些

00:01:08.140 --> 00:01:12.100
只是在稻草人中非常简单的术语

00:01:09.880 --> 00:01:13.570
这样的例子，所以我将建立一个新的

00:01:12.100 --> 00:01:15.850
这里的例子，我们将其称为

00:01:13.570 --> 00:01:18.909
是你会去实用程序应用程序

00:01:15.850 --> 00:01:22.659
给它起一个util例子名称， 

00:01:18.909 --> 00:01:26.469
我只带龙目岛

00:01:22.659 --> 00:01:28.179
是Java注释处理器，用于

00:01:26.469 --> 00:01:30.130
编译时的冥想

00:01:28.179 --> 00:01:31.630
处理器将带来Web支持

00:01:30.130 --> 00:01:33.159
因为我要建立一个网站

00:01:31.630 --> 00:01:35.649
申请后，我们将带来一个AOP 

00:01:33.159 --> 00:01:38.770
支持，因为我们正在使用它，我们将

00:01:35.649 --> 00:01:41.350
看看规格简和代理，然后我

00:01:38.770 --> 00:01:42.429
想应该去做，你又知道

00:01:41.350 --> 00:01:44.049
我这样做是为了

00:01:42.429 --> 00:01:47.679
要点击的东西

00:01:44.049 --> 00:01:49.630
锻炼身体，所以我们不是

00:01:47.679 --> 00:01:50.770
试图但目的不是看

00:01:49.630 --> 00:01:52.420
今天如何构建Web应用程序

00:01:50.770 --> 00:01:55.899
是要看一些实用程序

00:01:52.420 --> 00:01:58.990
上课好了，我们第一件事

00:01:55.899 --> 00:02:01.479
要看的是 Spring 包装如何

00:01:58.990 --> 00:02:05.649
实用程序类我们该怎么写

00:02:01.479 --> 00:02:07.659
代码和模式是相当

00:02:05.649 --> 00:02:12.580
如果您上课，一贯的权利

00:02:07.659 --> 00:02:15.640
就像成为utils一样，这里是 Spring 

00:02:12.580 --> 00:02:19.480
类型的框架实现

00:02:15.640 --> 00:02:21.190
叫做binutils是utils是一个类

00:02:19.480 --> 00:02:24.849
我们在工艺路线上

00:02:21.190 --> 00:02:27.920
在这里预测了源代码

00:02:24.849 --> 00:02:30.690
那班是

00:02:27.920 --> 00:02:32.040
抽象的权利，所以该类不能

00:02:30.690 --> 00:02:33.870
实例化您不期望

00:02:32.040 --> 00:02:35.700
创建这个的任何实例

00:02:33.870 --> 00:02:39.660
状态，然后方法是

00:02:35.700 --> 00:02:41.460
现在是静态的，我们在感觉到的地方做

00:02:39.660 --> 00:02:44.640
适当的信号表明其中一些

00:02:41.460 --> 00:02:48.060
方法仅用于框架，因此

00:02:44.640 --> 00:02:50.640
您可以很好地查看Java文档

00:02:48.060 --> 00:02:52.710
对于这些不同的实用程序

00:02:50.640 --> 00:02:54.390
他们很多班很普通

00:02:52.710 --> 00:02:56.310
足够，它们已经被使用，并且在

00:02:54.390 --> 00:02:57.840
足够长的时间框架

00:02:56.310 --> 00:02:59.820
稳定并可以从中受益

00:02:57.840 --> 00:03:02.280
当然可以作为马s和其他图书馆

00:02:59.820 --> 00:03:03.660
但请记住，我们会

00:03:02.280 --> 00:03:05.700
要么提供改变很多事情

00:03:03.660 --> 00:03:08.400
然后您会清楚地看到排序

00:03:05.700 --> 00:03:10.200
 Java文档中放样的

00:03:08.400 --> 00:03:11.670
对，所以当您只想创建一个

00:03:10.200 --> 00:03:15.150
学习班你可以考虑一下

00:03:11.670 --> 00:03:17.070
模式使其抽象，然后放入

00:03:15.150 --> 00:03:19.950
你知道创建静态实用程序方法

00:03:17.070 --> 00:03:21.209
它的价值在于没有

00:03:19.950 --> 00:03:23.640
副作用没有状态，如果

00:03:21.209 --> 00:03:25.709
有国家，明确地是你

00:03:23.640 --> 00:03:27.930
知道单例静态变量

00:03:25.709 --> 00:03:29.220
大家好，现在让我们来看看

00:03:27.930 --> 00:03:32.010
我们的示例在这里，我们有一个实用程序

00:03:29.220 --> 00:03:36.780
示例应用程序，我们将

00:03:32.010 --> 00:03:38.010
建立一个类只是一个简单的类

00:03:36.780 --> 00:03:39.840
是我们的命令行运行者

00:03:38.010 --> 00:03:41.370
将有一束提交命令

00:03:39.840 --> 00:03:43.890
冠军和指挥官的天气

00:03:41.370 --> 00:03:46.280
会变得不敏感

00:03:43.890 --> 00:03:49.320
应用程序启动，我们将

00:03:46.280 --> 00:03:50.640
管理一个具有

00:03:49.320 --> 00:03:51.840
简单的稻草人课，所以我们有

00:03:50.640 --> 00:03:55.769
与之一起工作的东西，所以我们要

00:03:51.840 --> 00:03:57.600
创建一个称为演示类的类，然后我

00:03:55.769 --> 00:04:00.480
知道谁真的在乎这将是一个

00:03:57.600 --> 00:04:03.450
您知道的Spring 元件或Spring 

00:04:00.480 --> 00:04:04.920
接下来，让我们将其制作成

00:04:03.450 --> 00:04:08.190
数据类，因为这将是长期的损失

00:04:04.920 --> 00:04:09.630
我们要创建一个all参数的类型

00:04:08.190 --> 00:04:11.730
好的构造函数

00:04:09.630 --> 00:04:13.260
那我想有一个领域

00:04:11.730 --> 00:04:17.669
我们可以反思地与之合作

00:04:13.260 --> 00:04:23.300
待会儿再来

00:04:17.669 --> 00:04:28.710
的字符串映射的私有最终列表

00:04:23.300 --> 00:04:32.250
对象好吧，我们要称呼这个哦

00:04:28.710 --> 00:04:33.180
这是我们要去的清单

00:04:32.250 --> 00:04:36.090
称之为我们的清单

00:04:33.180 --> 00:04:38.400
而且我们真的没有我没有

00:04:36.090 --> 00:04:40.320
尤其是你知道我不知道的任何事情

00:04:38.400 --> 00:04:41.050
有什么特别的想法

00:04:40.320 --> 00:04:42.729
一世

00:04:41.050 --> 00:04:44.860
然后偷那些想要的东西

00:04:42.729 --> 00:04:47.190
有很多通用参数

00:04:44.860 --> 00:04:49.720
通用类型，这将是一个

00:04:47.190 --> 00:04:52.750
私有最终字段，但是因为我们使用

00:04:49.720 --> 00:04:55.840
这个Lombok Java模仿处理器

00:04:52.750 --> 00:04:58.000
将能够调用获取列表

00:04:55.840 --> 00:05:00.280
并在这个类上设置列表是

00:04:58.000 --> 00:05:02.860
一个组件是一个工作，它是一个工作javabean 

00:05:00.280 --> 00:05:06.960
属性的种类可以是

00:05:02.860 --> 00:05:11.710
那个光束会说演示课演示

00:05:06.960 --> 00:05:15.699
课或只返回新的演示课，例如

00:05:11.710 --> 00:05:17.409
所以那里就是我们的简单

00:05:15.699 --> 00:05:19.090
我们已经完成的实例或简单光束

00:05:17.409 --> 00:05:21.750
没什么，我们只是去

00:05:19.090 --> 00:05:23.620
注入那里，我们现在可以使用它

00:05:21.750 --> 00:05:25.050
你知道我们可以做很多事情

00:05:23.620 --> 00:05:27.729
在这里做很多事情

00:05:25.050 --> 00:05:30.009
你可以想像的东西

00:05:27.729 --> 00:05:31.840
这样简单的事情

00:05:30.009 --> 00:05:34.330
也许我想也许我想确认

00:05:31.840 --> 00:05:36.159
该属性列表未知

00:05:34.330 --> 00:05:38.440
对，所以我们已经可以看到一个用例

00:05:36.159 --> 00:05:39.819
对于非常方便的实用程序之一

00:05:38.440 --> 00:05:41.860
 Spring 的联系

00:05:39.819 --> 00:05:43.659
坚定自己的断言阶级

00:05:41.860 --> 00:05:45.520
断言类有很多方法

00:05:43.659 --> 00:05:49.029
就像您在获得它时所发现的

00:05:45.520 --> 00:05:52.300
验证或断言状态

00:05:49.029 --> 00:05:54.009
你知道领域对象之前

00:05:52.300 --> 00:05:57.310
您对他们进行操作，这是您知道的

00:05:54.009 --> 00:05:58.690
设计我想要的合同

00:05:57.310 --> 00:05:59.770
提出一些前提条件并断言

00:05:58.690 --> 00:06:01.779
这些前提是正确的

00:05:59.770 --> 00:06:05.949
在我们对他们进行操作之前

00:06:01.779 --> 00:06:07.360
使后面的代码很多

00:06:05.949 --> 00:06:10.659
您可以理解的更合理的权利

00:06:07.360 --> 00:06:12.550
某些条件已经存在

00:06:10.659 --> 00:06:14.740
命令执行，或者您可以进行构建

00:06:12.550 --> 00:06:19.569
在那条线右边，所以我们说

00:06:14.740 --> 00:06:22.990
这个领域必须在那里，所以我们会说

00:06:19.569 --> 00:06:27.069
演示没有正确的列表

00:06:22.990 --> 00:06:29.289
不能被正确知道，所以有我们

00:06:27.069 --> 00:06:30.250
第一个示例正确吧，让我们继续前进， 

00:06:29.289 --> 00:06:33.159
运行这个，我们会看到

00:06:30.250 --> 00:06:37.090
应用程序旋转起来，我们应该能够

00:06:33.159 --> 00:06:41.020
看看结果就可以了

00:06:37.090 --> 00:06:46.150
现在让我们更改此名称，它将称为

00:06:41.020 --> 00:06:47.770
传承我们的荣誉，哦，这是最终决定

00:06:46.150 --> 00:06:50.199
变量，所以让它成为非最终的

00:06:47.770 --> 00:06:53.320
编译时过程将进行编码

00:06:50.199 --> 00:06:54.480
生成一个设置列表，让我们称它为null吧

00:06:53.320 --> 00:06:56.670
现在我们应该看到

00:06:54.480 --> 00:06:59.670
当我们重新运行它时， 

00:06:56.670 --> 00:07:02.310
抛出一个异常，该异常由

00:06:59.670 --> 00:07:06.000
作为非法论证例外的方式

00:07:02.310 --> 00:07:07.650
所以您现在可以免费获得它，让我们

00:07:06.000 --> 00:07:09.690
看这里

00:07:07.650 --> 00:07:13.440
我们不需要参数构造函数

00:07:09.690 --> 00:07:18.930
好吧，所以我们没有参数构造函数

00:07:13.440 --> 00:07:21.150
在那边学习代码， 

00:07:18.930 --> 00:07:22.500
应用程序启动它说很少

00:07:21.150 --> 00:07:23.790
竞选活动的特殊论点

00:07:22.500 --> 00:07:25.650
以及随后的任何代码

00:07:23.790 --> 00:07:27.900
断言必须是真实的，您不需要

00:07:25.650 --> 00:07:31.020
您不需要乱扔所有代码

00:07:27.900 --> 00:07:32.610
与你知道如果没有检查和所有

00:07:31.020 --> 00:07:33.540
这些东西，编译器甚至都不会

00:07:32.610 --> 00:07:36.870
警告您，因为它会知道

00:07:33.540 --> 00:07:39.780
你知道那对你很酷

00:07:36.870 --> 00:07:40.830
对，所以我认为这是一种方便

00:07:39.780 --> 00:07:42.780
一直在用

00:07:40.830 --> 00:07:45.750
Spring Framework本身一直

00:07:42.780 --> 00:07:49.110
在我们想要发挥作用的任何地方

00:07:45.750 --> 00:07:51.000
对象的状态或验证某些

00:07:49.110 --> 00:07:53.010
前提是我们对各种

00:07:51.000 --> 00:07:54.540
断言类的方法在这里

00:07:53.010 --> 00:07:56.550
这里有一种方法可以检查

00:07:54.540 --> 00:07:58.560
我们正在检查一个实例的单词

00:07:56.550 --> 00:08:00.240
的对象可分配给某个对象

00:07:58.560 --> 00:08:02.880
进行检查以查看是否全部

00:08:00.240 --> 00:08:05.220
查看集合角色的元素

00:08:02.880 --> 00:08:08.250
查看对象，地图或数组

00:08:05.220 --> 00:08:10.650
为空以查看是否包含表达式

00:08:08.250 --> 00:08:12.840
一般是否正确，以查看文本是否在其中

00:08:10.650 --> 00:08:14.970
另一个文本以查看文本是否为空或

00:08:12.840 --> 00:08:17.490
不是说，是否有一个

00:08:14.970 --> 00:08:19.860
珍惜那里，你知道很多非常非常

00:08:17.490 --> 00:08:21.450
这里方便的方法就是这样

00:08:19.860 --> 00:08:22.950
几乎只有一个叫状态

00:08:21.450 --> 00:08:24.930
让我们只用布尔值和

00:08:22.950 --> 00:08:26.940
状态消息是错误的，它

00:08:24.930 --> 00:08:28.890
为您传达正确的信息，以便您可以

00:08:26.940 --> 00:08:30.330
你可以在那里随意使用它们

00:08:28.890 --> 00:08:33.690
以为你会发现他们是

00:08:30.330 --> 00:08:38.930
一旦我有了，现在很方便

00:08:33.690 --> 00:08:42.150
我的 bean 我会介意的

00:08:38.930 --> 00:08:43.440
你知道检查我也许我想

00:08:42.150 --> 00:08:46.710
看看那个存在的属性

00:08:43.440 --> 00:08:48.240
对，这毕竟是Java的意思

00:08:46.710 --> 00:08:51.030
它具有杂耍特性

00:08:48.240 --> 00:08:52.980
这个属性有一个吸气剂

00:08:51.030 --> 00:08:55.050
毕竟，让我们来看一下

00:08:52.980 --> 00:08:59.870
让我们在这里创建一个称为bean的方法

00:08:55.050 --> 00:09:03.450
并且在bean方法中将枚举

00:08:59.870 --> 00:09:04.860
中的属性描述符

00:09:03.450 --> 00:09:06.960
在bean中的应用相当

00:09:04.860 --> 00:09:08.240
我们要说的是

00:09:06.960 --> 00:09:11.149
进行演示

00:09:08.240 --> 00:09:14.600
课堂演示，我们将其放在这里

00:09:11.149 --> 00:09:18.199
演示，在那里我们可以说一个财产或

00:09:14.600 --> 00:09:21.999
开始是utils获取属性

00:09:18.199 --> 00:09:24.589
描述符演示点好类和这个

00:09:21.999 --> 00:09:25.999
给我一些财产

00:09:24.589 --> 00:09:28.879
然后我们可以使用的描述符

00:09:25.999 --> 00:09:33.259
可以说属性描述符PD 

00:09:28.879 --> 00:09:39.129
描述符，让我们如此私密地登录

00:09:33.259 --> 00:09:46.009
静态最终日志叔叔的日志扇区e 

00:09:39.129 --> 00:09:52.670
获取日志倾斜示例应用程序

00:09:46.009 --> 00:10:00.290
好吧，所以我们要说

00:09:52.670 --> 00:10:02.720
该点日志R Sloan信息PD点得到

00:10:00.290 --> 00:10:05.720
好的名字，所以我们应该看到

00:10:02.720 --> 00:10:08.509
一种类型，不同的集合

00:10:05.720 --> 00:10:10.850
自动捕获的属性

00:10:08.509 --> 00:10:14.749
对我们来说，让我们看看它的外观

00:10:10.850 --> 00:10:23.869
就像我们在这里学习代码一样

00:10:14.749 --> 00:10:31.509
已经定义了演示类了

00:10:23.869 --> 00:10:31.509
我们伤害了你所有的建设者

00:10:34.760 --> 00:10:40.670
好吧，所以当我运行这个我得到

00:10:39.110 --> 00:10:41.899
他们获得以下属性或

00:10:40.670 --> 00:10:44.180
我可以访问的属性称为类

00:10:41.899 --> 00:10:46.339
显然是指上课，然后

00:10:44.180 --> 00:10:49.579
有一个叫做列表的属性，所以

00:10:46.339 --> 00:10:51.680
你知道这些是javabean属性

00:10:49.579 --> 00:11:01.100
说明，以便我实际上您可以知道

00:10:51.680 --> 00:11:05.870
让我们来看PD正常PD点取得领先

00:11:01.100 --> 00:11:08.510
例如等于等于簧片的方法

00:11:05.870 --> 00:11:10.040
方法管道名称正确，我们不是

00:11:08.510 --> 00:11:11.389
知道在这种情况下，有趣的是

00:11:10.040 --> 00:11:13.940
有趣特性的方法

00:11:11.389 --> 00:11:15.230
看起来很有趣的跳跃

00:11:13.940 --> 00:11:16.639
现在没有任何作家对

00:11:15.230 --> 00:11:18.199
方法，这样我们就不用麻烦了

00:11:16.639 --> 00:11:20.540
但是你可以测试一下

00:11:18.199 --> 00:11:22.279
例子，所以这里的类

00:11:20.540 --> 00:11:24.829
属性称为class和leave 

00:11:22.279 --> 00:11:26.360
该方法称为获取列表和获取类

00:11:24.829 --> 00:11:27.920
在那会处理你

00:11:26.360 --> 00:11:30.889
返回对Java的引用

00:11:27.920 --> 00:11:33.079
反射方法对象，我很好

00:11:30.889 --> 00:11:34.970
好，所以我们有一个光束

00:11:33.079 --> 00:11:36.350
 utils，该梁utils为您提供了

00:11:34.970 --> 00:11:37.610
一大堆不同的呃

00:11:36.350 --> 00:11:39.380
复制属性的便捷方法

00:11:37.610 --> 00:11:42.740
从一个物体到另一个寻找一个

00:11:39.380 --> 00:11:44.089
属于某种类型的财产

00:11:42.740 --> 00:11:47.389
并根据对象固定八个对象

00:11:44.089 --> 00:11:49.130
你知道的课程只是一般的答案

00:11:47.389 --> 00:11:51.620
一些非常常见的问题，这是非常

00:11:49.130 --> 00:11:53.120
我认为与某些类型的

00:11:51.620 --> 00:11:56.360
您可能会发现的某种功能

00:11:53.120 --> 00:11:57.769
常见空白是utils打字机

00:11:56.360 --> 00:11:59.750
一直存在

00:11:57.769 --> 00:12:00.949
如果你想使用那很好

00:11:59.750 --> 00:12:02.779
但是有很多共同点

00:12:00.949 --> 00:12:04.519
你将需要我们在这里

00:12:02.779 --> 00:12:07.510
细节还好，所以有一个

00:12:04.519 --> 00:12:10.819
我想现在想做的事

00:12:07.510 --> 00:12:12.860
你知道什么时候只是低层次的

00:12:10.819 --> 00:12:14.690
与您相反的低反射

00:12:12.860 --> 00:12:14.990
了解 Bean type 和软糖成分，以及

00:12:14.690 --> 00:12:16.250
依此类推

00:12:14.990 --> 00:12:18.260
没有其他的事情

00:12:16.250 --> 00:12:20.300
也希望能够进行检查

00:12:18.260 --> 00:12:23.569
假设我们将此方法重命名为

00:12:20.300 --> 00:12:27.860
 bean utils，我们将创建一个新的

00:12:23.569 --> 00:12:31.370
这里的方法称为类utils， 

00:12:27.860 --> 00:12:34.100
经典的工具方法，我们将采取

00:12:31.370 --> 00:12:37.100
以此为基础进行检查的机会

00:12:34.100 --> 00:12:39.440
类型的运行时状态的种类

00:12:37.100 --> 00:12:41.149
使用反射，所以说我想要

00:12:39.440 --> 00:12:42.199
获取构造函数事件类型，所以我

00:12:41.149 --> 00:12:48.529
可以说类工具

00:12:42.199 --> 00:12:50.569
 dot get获取构造函数（如果有） 

00:12:48.529 --> 00:12:52.730
说那堂课，我们有

00:12:50.569 --> 00:12:54.319
没有参数，我是说你知道我们知道

00:12:52.730 --> 00:12:57.290
没有参数构造函数

00:12:54.319 --> 00:13:03.310
所以说一个演示类的构造函数

00:12:57.290 --> 00:13:09.069
这个点记录荷兰信息记录信息

00:13:03.310 --> 00:13:10.999
演示类的构造函数就是这个

00:13:09.069 --> 00:13:12.920
让我们实际使用它来创建

00:13:10.999 --> 00:13:15.199
对象，所以我们将说新实例和

00:13:12.920 --> 00:13:16.939
这里没有参数，这样很好

00:13:15.199 --> 00:13:20.540
是餐厅的嘴唇将围绕这

00:13:16.939 --> 00:13:28.779
有了try-catch，我们只需要

00:13:20.540 --> 00:13:28.779
在这种情况下一种捕获方法可以

00:13:29.800 --> 00:13:35.540
例外，我们是

00:13:33.079 --> 00:13:37.699
所以这会给我回馈

00:13:35.540 --> 00:13:43.009
我备份和演示类的实例，所以

00:13:37.699 --> 00:13:48.490
假设您记录下您知道的新信息

00:13:43.009 --> 00:13:53.589
实例演示类演示类

00:13:48.490 --> 00:13:53.589
好吧，让我们运行它，看看我们得到了什么

00:13:56.710 --> 00:14:04.460
好吧，这是我的新实例对象

00:14:02.510 --> 00:14:07.430
看起来就像我们期望的那样

00:14:04.460 --> 00:14:09.980
有一个简单的对象与

00:14:07.430 --> 00:14:11.810
你知道它有可制造的外观

00:14:09.980 --> 00:14:13.670
一个空数组列表，它在那里

00:14:11.810 --> 00:14:15.440
这是一个无效的状态，没有例外

00:14:13.670 --> 00:14:17.240
或抛出，那将是我的数学

00:14:15.440 --> 00:14:19.100
与之互动的能力

00:14:17.240 --> 00:14:21.560
使用Lu键入，我们可以使用

00:14:19.100 --> 00:14:22.850
原始类文字定义我们

00:14:21.560 --> 00:14:24.980
肯定可以到达那里，但是有一个

00:14:22.850 --> 00:14:28.370
经典中的许多便捷方法

00:14:24.980 --> 00:14:30.130
工具类，例如确定

00:14:28.370 --> 00:14:33.340
两种类型之间的共同祖先

00:14:30.130 --> 00:14:36.380
连锁店的班级和

00:14:33.340 --> 00:14:38.900
把它们变成一个字符串，你知道

00:14:36.380 --> 00:14:40.310
找到一个给定名字的班级

00:14:38.900 --> 00:14:42.110
某些类加载器找到所有

00:14:40.310 --> 00:14:43.700
给定光束中的界面得到

00:14:42.110 --> 00:14:45.680
默认类照片获取方法等

00:14:43.700 --> 00:14:48.310
等等等我会很方便的

00:14:45.680 --> 00:14:50.600
现在发生的事情另一件事

00:14:48.310 --> 00:14:52.670
另一种方法可以输入另一个

00:14:50.600 --> 00:14:54.760
中的便捷实用程序类

00:14:52.670 --> 00:14:57.830
 Spring 学期是系统属性

00:14:54.760 --> 00:14:59.240
 utils和我们要使用的原因

00:14:57.830 --> 00:15:01.370
这是因为我们希望能够

00:14:59.240 --> 00:15:02.960
谈论某些文件的位置

00:15:01.370 --> 00:15:05.390
所以首先是直的

00:15:02.960 --> 00:15:09.020
系统属性的故事，所以我们可以

00:15:05.390 --> 00:15:10.750
知道，所以我们可以解决这个问题

00:15:09.020 --> 00:15:13.250
首先，这里是系统属性，直到

00:15:10.750 --> 00:15:15.530
我们要做的就是解决

00:15:13.250 --> 00:15:18.320
用户在家，如果您了解很多

00:15:15.530 --> 00:15:20.060
 spring boot 的工作原理是它能映射全部

00:15:18.320 --> 00:15:21.590
环境变量万物

00:15:20.060 --> 00:15:23.600
在环境中了解所有

00:15:21.590 --> 00:15:25.910
系统中获得E＆V的东西

00:15:23.600 --> 00:15:27.560
和获得属性的系统

00:15:25.910 --> 00:15:29.270
他们进入 Spring 的环境

00:15:27.560 --> 00:15:31.610
抽象环境抽象

00:15:29.270 --> 00:15:35.080
只是美化的键和值的映射

00:15:31.610 --> 00:15:38.270
所以像家庭用户这样的事情就变成了

00:15:35.080 --> 00:15:40.460
可注入或可解决的财产

00:15:38.270 --> 00:15:43.220
在 Spring 应用程序上下文中

00:15:40.460 --> 00:15:44.960
系统适当的实用程序使其非常

00:15:43.220 --> 00:15:48.440
易于创建，您知道要解决

00:15:44.960 --> 00:15:55.460
字符串中的占位符，所以让我们

00:15:48.440 --> 00:15:58.700
说我的主目录是用户dot home 

00:15:55.460 --> 00:16:00.050
好的，那是我正在使用的字符串值

00:15:58.700 --> 00:16:02.480
系统

00:16:00.050 --> 00:16:05.510
我正在使用系统属性的已解析文本

00:16:02.480 --> 00:16:08.360
 utils，我要解决，我要去

00:16:05.510 --> 00:16:18.170
注销解决

00:16:08.360 --> 00:16:20.990
文字还可以，我们说现在就运行

00:16:18.170 --> 00:16:23.000
我们当然可以调用系统

00:16:20.990 --> 00:16:26.300
在这种情况下获取属性以用于

00:16:23.000 --> 00:16:28.819
回家，但是没有你真是太好了

00:16:26.300 --> 00:16:30.829
知道我们可以使用Spring 财产的地方

00:16:28.819 --> 00:16:32.569
字符串中的所有解析语法

00:16:30.829 --> 00:16:35.509
在这里并获得正确的结果，所以

00:16:32.569 --> 00:16:38.180
现在非常方便，我想使用

00:16:35.509 --> 00:16:39.350
创建文件的便利和

00:16:38.180 --> 00:16:41.750
没有人去做，他们想要一个

00:16:39.350 --> 00:16:45.319
现在，现在显示另一种可能的方式

00:16:41.750 --> 00:16:47.389
在Spring Framework 中输入

00:16:45.319 --> 00:16:49.100
是工具类型的文件副本吗

00:16:47.389 --> 00:16:52.040
的人曾经相信你

00:16:49.100 --> 00:16:54.740
 T是副本的书面代码， 

00:16:52.040 --> 00:16:57.439
到处走动，您就会知道字节

00:16:54.740 --> 00:17:00.290
知道要成为您的领导者

00:16:57.439 --> 00:17:01.850
从一个读者到另一个读者的数据

00:17:00.290 --> 00:17:03.560
来自阅读器的数据并将其打开

00:17:01.850 --> 00:17:07.189
到流中，您知道很多共同点

00:17:03.560 --> 00:17:09.439
无聊的灵魂消灭无聊的灵魂

00:17:07.189 --> 00:17:15.679
任何东西的输入和输出

00:17:09.439 --> 00:17:22.059
所以在这种情况下，我想看一下文件

00:17:15.679 --> 00:17:25.730
复制utils自己的文件复制utils可以

00:17:22.059 --> 00:17:29.059
好的方法在那里

00:17:25.730 --> 00:17:30.320
文件复制详细信息我想做的是我

00:17:29.059 --> 00:17:34.490
想说文件副本

00:17:30.320 --> 00:17:36.380
直到点，我要复制数据

00:17:34.490 --> 00:17:38.030
从读者到字符串

00:17:36.380 --> 00:17:43.100
好吧，让我们在这里创建一个读者

00:17:38.030 --> 00:17:45.530
我们的新文件阅读器和文件阅读器

00:17:43.100 --> 00:17:51.770
将期待一个文件指针

00:17:45.530 --> 00:17:54.020
自然可以，所以我们的方式

00:17:51.770 --> 00:17:55.760
要建立该文件是要

00:17:54.020 --> 00:17:58.340
使用系统属性工具来解决

00:17:55.760 --> 00:18:04.309
占位符，我只说用户点

00:17:58.340 --> 00:18:08.600
家，我将其指向台式机

00:18:04.309 --> 00:18:14.600
 Flash内容点txt正确，如果我看

00:18:08.600 --> 00:18:19.560
这是一个JavaniñoJava IO文件

00:18:14.600 --> 00:18:25.350
只是普通的JDK类型就可以了

00:18:19.560 --> 00:18:28.540
好的，有我的文件和文件阅读器

00:18:25.350 --> 00:18:30.640
之所以抱怨是因为我们抛出了

00:18:28.540 --> 00:18:36.940
例外，所以我们会抓住你的

00:18:30.640 --> 00:18:38.530
运行时异常II，现在我想

00:18:36.940 --> 00:18:42.460
得到那个文件的内容，所以我

00:18:38.530 --> 00:18:45.900
要说比较好，我只说

00:18:42.460 --> 00:18:45.900
我想把它放在那里

00:18:52.200 --> 00:18:57.580
简化一点，我们现在

00:18:55.450 --> 00:19:03.100
想做的就是我要记录的内容

00:18:57.580 --> 00:19:05.680
所以我说文件的日志内容

00:19:03.100 --> 00:19:08.110
想要使用文件复制效用点和我

00:19:05.680 --> 00:19:12.630
想要将阅读器复制到字符串中

00:19:08.110 --> 00:19:17.230
像这样好，所以使用Java 7 

00:19:12.630 --> 00:19:23.040
自动关闭功能，您可以尝试

00:19:17.230 --> 00:19:25.660
具有我的能力

00:19:23.040 --> 00:19:26.860
自动关闭可关闭的资源

00:19:25.660 --> 00:19:30.190
追随者或输入之类的东西

00:19:26.860 --> 00:19:31.600
流或其他

00:19:30.190 --> 00:19:34.180
我们可以看到， 

00:19:31.600 --> 00:19:38.950
您知道它等于您好屏幕的文件

00:19:34.180 --> 00:19:39.430
提示，指导我们了解什么

00:19:38.950 --> 00:19:42.040
是真实的

00:19:39.430 --> 00:19:44.110
所以我的 Spring 提示

00:19:42.040 --> 00:19:45.580
桌面，我们可以看到所有结果

00:19:44.110 --> 00:19:47.440
对，这很方便，我们有

00:19:45.580 --> 00:19:48.730
我相信其他方法很少

00:19:47.440 --> 00:19:53.110
你可以想象用例

00:19:48.730 --> 00:19:54.970
好吧，最终副本工具就是副本

00:19:53.110 --> 00:19:57.100
从一个二进制文件到一个输出文件

00:19:54.970 --> 00:19:58.840
从二进制优化复制流副本

00:19:57.100 --> 00:20:00.610
从一个文件复制到另一个文件

00:19:58.840 --> 00:20:02.620
输入流到输出流副本

00:20:00.610 --> 00:20:03.880
到您知道封面文件的字节数组

00:20:02.620 --> 00:20:06.010
咬伤恢复的输入流

00:20:03.880 --> 00:20:08.380
字节数组很方便你

00:20:06.010 --> 00:20:13.120
知道数据窃听或咬人

00:20:08.380 --> 00:20:15.900
好的方法，现在让我们

00:20:13.120 --> 00:20:23.230
谈论我们可以做的一些事情

00:20:15.900 --> 00:20:24.520
您知道要使用网络层

00:20:23.230 --> 00:20:27.580
正确，我们要做的就是

00:20:24.520 --> 00:20:29.080
阅读网络层及其相关的工作

00:20:27.580 --> 00:20:31.630
你知道

00:20:29.080 --> 00:20:34.570
影响某事或与之合作

00:20:31.630 --> 00:20:35.710
基于httpservlet的代码好吧，我要去

00:20:34.570 --> 00:20:36.910
在这里创建一个简单的 rest controller 

00:20:35.710 --> 00:20:39.550
这就是为什么我增加了 spring boot 

00:20:36.910 --> 00:20:40.990
启动Web端点以了解

00:20:39.550 --> 00:20:45.280
应用程序的相对入门者

00:20:40.990 --> 00:20:47.560
想说公共静态类简单

00:20:45.280 --> 00:20:49.870
 rest controller ，我们不在乎

00:20:47.560 --> 00:20:51.700
压榨控制器就这么多

00:20:49.870 --> 00:20:55.690
情况，我们将有一个简单的

00:20:51.700 --> 00:20:58.150
端点在这里称为高

00:20:55.690 --> 00:21:00.130
只是要避免一个高方法

00:20:58.150 --> 00:21:02.010
这将是我看到的展示， 

00:21:00.130 --> 00:21:04.060
指向正确，所以它将返回

00:21:02.010 --> 00:21:05.770
在这种情况下，返回什么都不是

00:21:04.060 --> 00:21:08.680
要告诉Spring实体做什么

00:21:05.770 --> 00:21:10.360
注入服务器请求，我再次

00:21:08.680 --> 00:21:11.980
不希望您注入我们或

00:21:10.360 --> 00:21:14.590
要求实际上是否很好

00:21:11.980 --> 00:21:16.960
 Spring MVC代码应该绝对

00:21:14.590 --> 00:21:18.310
永远不要使用不应该使用的HTTP请求

00:21:16.960 --> 00:21:19.990
需要它，我知道有很多

00:21:18.310 --> 00:21:23.200
 Spring 的设施让您

00:21:19.990 --> 00:21:24.790
超越和不依赖于

00:21:23.200 --> 00:21:26.320
低级Servlet请求，但如果您

00:21:24.790 --> 00:21:28.270
肯定会写关于服务器的代码

00:21:26.320 --> 00:21:31.390
可能非常有用的组件

00:21:28.270 --> 00:21:34.300
知道你知道api是

00:21:31.390 --> 00:21:36.100
可以使没有该代码的工作变得容易

00:21:34.300 --> 00:21:38.830
即使你不是在 Spring 

00:21:36.100 --> 00:21:40.570
环境不错，所以我在这里

00:21:38.830 --> 00:21:42.670
说我想获取一个参数让我们

00:21:40.570 --> 00:21:49.500
说我想拥有年龄参数ID 

00:21:42.670 --> 00:21:49.500
所以我要说那个服务请求

00:21:49.560 --> 00:21:55.540
 utils点进入参数我要

00:21:53.800 --> 00:21:57.340
注入或传递请求

00:21:55.540 --> 00:21:58.660
以及要转到的参数名称

00:21:57.340 --> 00:22:03.160
是年龄，我将使用默认值

00:21:58.660 --> 00:22:06.550
我不知道一项权利或18项权利

00:22:03.160 --> 00:22:09.700
知道所以让我们说你知道吗

00:22:06.550 --> 00:22:11.050
我们甚至可以有一个负值，所以我们

00:22:09.700 --> 00:22:13.000
可以说给我们一个负值，所以如果

00:22:11.050 --> 00:22:14.830
你知道我们会得到一个价值，如果

00:22:13.000 --> 00:22:16.180
这不是输入的内容

00:22:14.830 --> 00:22:20.190
的要求，我们知道

00:22:16.180 --> 00:22:25.240
是错的，所以在这里

00:22:20.190 --> 00:22:27.550
年龄就是您知道我们可以做其他事情的年龄

00:22:25.240 --> 00:22:30.100
我们可以在网上找到的东西

00:22:27.550 --> 00:22:33.910
服务器临时目录也是如此

00:22:30.100 --> 00:22:36.520
我们可以使用网络实用工具

00:22:33.910 --> 00:22:38.140
 temp亲爱的，这需要一台服务器

00:22:36.520 --> 00:22:40.150
上下文，我们当然可以通过

00:22:38.140 --> 00:22:41.210
从HD仆人中取消引用

00:22:40.150 --> 00:22:44.660
这样的要求

00:22:41.210 --> 00:22:48.200
这实际上是一个Java util文件

00:22:44.660 --> 00:22:52.430
点IO文件，我们可以确认为

00:22:48.200 --> 00:22:57.710
好吧，临时目录不完整

00:22:52.430 --> 00:23:02.720
 Tomcat是通过那里的所以

00:22:57.710 --> 00:23:03.890
过去还可以，如果我们

00:23:02.720 --> 00:23:05.000
在servlet环境中，我们正在使用

00:23:03.890 --> 00:23:06.980
 Spring ，这就是你

00:23:05.000 --> 00:23:08.780
可能在现代代码中没有，但是如果

00:23:06.980 --> 00:23:12.050
你真的很老而你

00:23:08.780 --> 00:23:14.900
知道破坏旧代码是

00:23:12.050 --> 00:23:17.990
可以在 Spring 升起

00:23:14.900 --> 00:23:20.180
申请，然后提倡辩护人进入

00:23:17.990 --> 00:23:22.250
组件代码中没有的bean 

00:23:20.180 --> 00:23:24.410
不然你知道住在 Spring 

00:23:22.250 --> 00:23:25.640
因此，如果您有servlet并且它们

00:23:24.410 --> 00:23:28.700
想与

00:23:25.640 --> 00:23:30.170
由 Spring 管理，那个上下文是

00:23:28.700 --> 00:23:32.690
称为网络应用上下文

00:23:30.170 --> 00:23:35.920
这里有一个非常方便的方法

00:23:32.690 --> 00:23:39.230
请求可以帮助您的上下文工具

00:23:35.920 --> 00:23:43.160
找到给定的Web应用程序上下文

00:23:39.230 --> 00:23:44.240
请求和服务器类型的servlet 

00:23:43.160 --> 00:23:46.490
在这种情况下，您需要

00:23:44.240 --> 00:23:48.530
该Web应用程序的服务器上下文

00:23:46.490 --> 00:23:50.870
上下文实际上是

00:23:48.530 --> 00:23:52.910
应用程序上下文，这是一个 Spring 

00:23:50.870 --> 00:23:55.400
您可以使用的应用程序上下文

00:23:52.910 --> 00:23:59.390
现在查找您知道您引用了

00:23:55.400 --> 00:24:01.820
就像您在很旧的屏幕代码中一样

00:23:59.390 --> 00:24:05.630
所以我实际上只是问 Spring 

00:24:01.820 --> 00:24:08.660
用于指向环境bean的指针

00:24:05.630 --> 00:24:11.650
对那个 Spring 的环境对象

00:24:08.660 --> 00:24:14.330
为您维护，我们可以用它来

00:24:11.650 --> 00:24:18.880
不管我在这里没有财产

00:24:14.330 --> 00:24:25.630
正确，这样我就可以将物业用户点回家

00:24:18.880 --> 00:24:31.430
日志信息Web应用程序上下文

00:24:25.630 --> 00:24:34.340
已解析的属性等于您好，只需登录

00:24:31.430 --> 00:24:35.510
以及运行，如果您运行

00:24:34.340 --> 00:24:37.100
它不是要你知道我们必须

00:24:35.510 --> 00:24:38.870
实际上现在调用它，所以我要

00:24:37.100 --> 00:24:40.790
我要做的是创建一个

00:24:38.870 --> 00:24:45.730
在这里调用一个

00:24:40.790 --> 00:24:50.170
终点，所以在我们喧闹的赛跑者中

00:24:45.730 --> 00:24:50.170
我们将有一个网络方法好

00:24:50.600 --> 00:24:55.340
我将创建一个简单的休息

00:24:52.010 --> 00:24:59.660
模板RT等于新的休息模板

00:24:55.340 --> 00:25:01.820
和我们的用户模板以获取响应

00:24:59.660 --> 00:25:04.700
或仅触发电话的操作

00:25:01.820 --> 00:25:06.830
本地主机：8080这样的喜，我不

00:25:04.700 --> 00:25:09.020
非常在乎这里的返回值

00:25:06.830 --> 00:25:10.340
我只想致电服务， 

00:25:09.020 --> 00:25:13.100
确认当我致电服务时，我们

00:25:10.340 --> 00:25:16.010
在命令行上看到他们认识的人

00:25:13.100 --> 00:25:19.539
用户的输出转化为潜在客户

00:25:16.010 --> 00:25:19.539
好吧，让我们看看它看起来像什么

00:25:26.590 --> 00:25:32.150
好吧，所以脾气蛋不利

00:25:30.800 --> 00:25:34.250
一个，所以我们实际上没有提交年龄

00:25:32.150 --> 00:25:35.780
如果我们可以，尽管您知道

00:25:34.250 --> 00:25:38.660
请求参数临时

00:25:35.780 --> 00:25:41.600
目录是私有var文件夹的

00:25:38.660 --> 00:25:43.910
法律Tomcat点不管正确指向

00:25:41.600 --> 00:25:45.440
工作Tomcat本地化路由，然后

00:25:43.910 --> 00:25:48.230
单词应用上下文结果

00:25:45.440 --> 00:25:50.570
属性等于用户Jayla，您知道

00:25:48.230 --> 00:25:53.870
你刚才看到的，所以我们再次

00:25:50.570 --> 00:25:56.300
与我们的应用程序交谈

00:25:53.870 --> 00:25:58.910
到我们的 Spring 服务中

00:25:56.300 --> 00:26:00.410
 Servlet API和某些时间的服务

00:25:58.910 --> 00:26:02.030
服务代码库非常

00:26:00.410 --> 00:26:05.990
方便尝试做事

00:26:02.030 --> 00:26:08.960
在应用程序里面好吧

00:26:05.990 --> 00:26:11.870
这里还有其他一些便利

00:26:08.960 --> 00:26:17.210
对，我想做的就是

00:26:11.870 --> 00:26:18.680
看一种低层次的

00:26:17.210 --> 00:26:21.440
我想从一个低层次的角度

00:26:18.680 --> 00:26:24.230
对对象的低层次透视

00:26:21.440 --> 00:26:29.360
由Springs AOP机制管理

00:26:24.230 --> 00:26:32.020
对，所以 Spring 使它变得非常简单

00:26:29.360 --> 00:26:33.620
将业务逻辑引入对象

00:26:32.020 --> 00:26:35.510
声明性地放在一个地方

00:26:33.620 --> 00:26:37.310
特别是如果您有减少顾虑

00:26:35.510 --> 00:26:39.320
诸如交易管理和

00:26:37.310 --> 00:26:40.970
日志记录，您知道审计什么

00:26:39.320 --> 00:26:43.010
你不管这些担心是什么

00:26:40.970 --> 00:26:45.050
介绍这些非常简单

00:26:43.010 --> 00:26:48.380
有关使用面向方面的问题

00:26:45.050 --> 00:26:49.430
用我们这样做的方式进行编程

00:26:48.380 --> 00:26:51.350
 Spring 的工作方式

00:26:49.430 --> 00:26:53.060
最终为您做到的是

00:26:51.350 --> 00:26:54.530
创建一个代理，它可以做到这一点

00:26:53.060 --> 00:26:56.390
几种不同的方式，如果你只是

00:26:54.530 --> 00:26:59.510
在介绍行为时使用

00:26:56.390 --> 00:27:00.980
基于到它的接口

00:26:59.510 --> 00:27:02.750
有趣的介绍混凝土

00:27:00.980 --> 00:27:05.360
行为变成某种类型的光束

00:27:02.750 --> 00:27:06.770
接口，那么我们可以使用常规的JDK 

00:27:05.360 --> 00:27:08.570
受支持的代理

00:27:06.770 --> 00:27:10.070
在JDK中已经有十多年了

00:27:08.570 --> 00:27:11.210
否则我们必须使用一些

00:27:10.070 --> 00:27:14.750
更复杂的东西

00:27:11.210 --> 00:27:17.830
叫做工程代理，所以你知道

00:27:14.750 --> 00:27:20.600
能够自省和与之合作

00:27:17.830 --> 00:27:23.060
代理光束在某些情况下可能非常有用

00:27:20.600 --> 00:27:26.950
非常晦涩

00:27:23.060 --> 00:27:30.520
理所当然，但有时仍然有用

00:27:26.950 --> 00:27:33.940
情况合适，所以让我们介绍一个

00:27:30.520 --> 00:27:36.410
简单的方面

00:27:33.940 --> 00:27:37.970
改变我们应用程序的行为

00:27:36.410 --> 00:27:39.290
所以我们要做的是

00:27:37.970 --> 00:27:43.270
上午

00:27:39.290 --> 00:27:48.560
在我们的演示类上的一种方法是

00:27:43.270 --> 00:27:49.520
当应用程序在其中时调用

00:27:48.560 --> 00:27:51.290
你知道的科学权利

00:27:49.520 --> 00:27:53.750
在光束投入使用之前

00:27:51.290 --> 00:27:55.580
我们将有一个可能的方法

00:27:53.750 --> 00:27:56.870
就在这里设置在那里，我们去

00:27:55.580 --> 00:27:58.970
只是叫这开始我们就去

00:27:56.870 --> 00:28:00.920
绝对记得难忘的权利， 

00:27:58.970 --> 00:28:04.370
在开始的方法中，我要做的就是

00:28:00.920 --> 00:28:10.160
只是记录我们正在寻找正确的日志

00:28:04.370 --> 00:28:11.390
这是一个日志数据信息，何时开始

00:28:10.160 --> 00:28:13.310
 Spring 开始了，这将是

00:28:11.390 --> 00:28:14.570
等效于初始化光束，所以它将

00:28:13.310 --> 00:28:17.120
在应用程序之后调用该方法

00:28:14.570 --> 00:28:19.100
我的意思是说

00:28:17.120 --> 00:28:21.410
构成所有属性

00:28:19.100 --> 00:28:24.320
已经满意，这是通过

00:28:21.410 --> 00:28:25.760
构造方法或设置方法

00:28:24.320 --> 00:28:27.800
我们现在想做的是可以

00:28:25.760 --> 00:28:30.290
在这个特定的之前运行的

00:28:27.800 --> 00:28:32.030
方法被称为琐碎的方面

00:28:30.290 --> 00:28:36.830
所以我要在这里创造一个方面

00:28:32.030 --> 00:28:39.650
欣喜若狂的方面，一个简单的方面

00:28:36.830 --> 00:28:41.630
之前，我要 Spring 

00:28:39.650 --> 00:28:43.250
处理这个光束，所以我必须轮流

00:28:41.630 --> 00:28:44.860
它变成一个组件，这不是一个

00:28:43.250 --> 00:28:47.450
刻板印象注解更像是

00:28:44.860 --> 00:28:52.370
 Spring 其他零件的质量

00:28:47.450 --> 00:28:57.440
并将创造出

00:28:52.370 --> 00:29:00.920
在执行之前执行

00:28:57.440 --> 00:29:02.090
在任何组件上都可以使用begin方法，因此

00:29:00.920 --> 00:29:06.610
在这种情况下，我们显然要

00:29:02.090 --> 00:29:08.570
知道它只会匹配我们的

00:29:06.610 --> 00:29:10.070
特别是我们的小样课程

00:29:08.570 --> 00:29:11.150
在这里，但你知道我想拥有

00:29:10.070 --> 00:29:13.820
这里有一些需要配合的东西，所以我们

00:29:11.150 --> 00:29:18.130
要说什么时候有人打电话给婴儿

00:29:13.820 --> 00:29:25.360
对于方法传递连接点

00:29:18.130 --> 00:29:25.360
好的，这里只是记录点信息

00:29:25.540 --> 00:29:37.010
之前并在该点记录该信息

00:29:32.180 --> 00:29:38.870
点两个字符串好吧，如果那样

00:29:37.010 --> 00:29:45.380
我们希望他们，我们应该看到这些

00:29:38.870 --> 00:29:49.580
之前打印了两行

00:29:45.380 --> 00:29:52.300
再次呼叫最终被呼叫

00:29:49.580 --> 00:30:03.310
好的，让我们看看实际情况

00:29:52.300 --> 00:30:08.350
证明工作就可以了

00:30:03.310 --> 00:30:14.880
做了一些我没有介绍的东西

00:30:08.350 --> 00:30:17.770
我没有绿色指针告诉ALP支持

00:30:14.880 --> 00:30:22.300
确保我已经激活

00:30:17.770 --> 00:30:28.290
面向方面的产品代理权

00:30:22.300 --> 00:30:36.490
代理不，我还是做错了什么

00:30:28.290 --> 00:30:44.110
让我们看看我们有一个简单的方面

00:30:36.490 --> 00:30:47.940
在任何begin方法上运行，我

00:30:44.110 --> 00:30:47.940
应该这样做让我们获得签名

00:30:54.730 --> 00:31:02.710
我们这里有一个叫做big的组件

00:30:58.450 --> 00:31:05.520
基因看起来还不错，让我们看看

00:31:02.710 --> 00:31:07.900
我想我可能刚刚创作的作品

00:31:05.520 --> 00:31:10.990
无效的参考没有看起来像

00:31:07.900 --> 00:31:14.430
我做了一些愚蠢的错误

00:31:10.990 --> 00:31:14.430
指针 bean 哦

00:31:15.810 --> 00:31:20.650
我们现在有更多的物业，所以

00:31:19.000 --> 00:31:24.580
显然我们不是一个财产

00:31:20.650 --> 00:31:26.290
确实能够获得簧片方法

00:31:24.580 --> 00:31:28.360
这是我们介绍AOP的地方

00:31:26.290 --> 00:31:30.280
我们引入的框架符合我们

00:31:28.360 --> 00:31:32.860
介绍了一些编织的类型

00:31:30.280 --> 00:31:34.240
进入我们的代码，除非

00:31:32.860 --> 00:31:36.280
你正在做一些低级的

00:31:34.240 --> 00:31:38.980
反思，因为代理是

00:31:36.280 --> 00:31:40.630
最终运行时与

00:31:38.980 --> 00:31:42.760
我们期望他们的类型

00:31:40.630 --> 00:31:46.120
对象已实现相同

00:31:42.760 --> 00:31:48.490
像我们给它的光束一样收缩

00:31:46.120 --> 00:31:50.170
修改它为我们，但它增加了额外的

00:31:48.490 --> 00:31:51.760
最后的事情就像我一样

00:31:50.170 --> 00:31:54.610
一些专门的课程

00:31:51.760 --> 00:31:56.530
做一些你知道的子类型

00:31:54.610 --> 00:31:58.060
它需要做的是使其看起来像

00:31:56.530 --> 00:31:59.680
我们可以选择这种行为而无需

00:31:58.060 --> 00:32:01.630
实际修改代码，即使

00:31:59.680 --> 00:32:03.250
最终做到了，所以我要走了

00:32:01.630 --> 00:32:05.110
继续并删除它，因为我们现在

00:32:03.250 --> 00:32:06.730
绊倒某种财产， 

00:32:05.110 --> 00:32:08.980
没有读压区，可能有一个

00:32:06.730 --> 00:32:11.500
设置方法，但是你知道

00:32:08.980 --> 00:32:25.150
我们不称它为好，所以当

00:32:11.500 --> 00:32:27.040
我这样做是为了让我看到这里

00:32:25.150 --> 00:32:28.720
一切似乎都很好，我们是

00:32:27.040 --> 00:32:30.370
清楚获得AOP支持正在起作用

00:32:28.720 --> 00:32:33.130
现在让我们继续检查

00:32:30.370 --> 00:32:34.720
让我们继续审问

00:32:33.130 --> 00:32:38.650
所有这些的状态，因此我们将使用

00:32:34.720 --> 00:32:40.660
 AOP实用程序和 Spring 在这里，我会

00:32:38.650 --> 00:32:43.060
说然后我想去上课

00:32:40.660 --> 00:32:49.510
我想看看他们是否在这里演示

00:32:43.060 --> 00:32:53.770
上课示范，我要说一句直到

00:32:49.510 --> 00:32:57.670
不获得目标课程的示范课程和

00:32:53.770 --> 00:33:01.990
这给我的是实际的

00:32:57.670 --> 00:33:03.640
 bean 实际类型早些

00:33:01.990 --> 00:33:05.110
源类型是源类型

00:33:03.640 --> 00:33:08.630
原始键入我们放入其中的网站

00:33:05.110 --> 00:33:10.220
而不是实现的子

00:33:08.630 --> 00:33:13.790
是为我们动态创建的

00:33:10.220 --> 00:33:21.110
一次，所以我们在这里传递了这个东西

00:33:13.790 --> 00:33:28.400
它会说班是目标

00:33:21.110 --> 00:33:33.560
上课好，博客类型信息，然后我们将

00:33:28.400 --> 00:33:38.870
问它是AOP代理还是AOP utils 

00:33:33.560 --> 00:33:40.940
是LP代理吗，我们想要

00:33:38.870 --> 00:33:43.690
如果它是通用的

00:33:40.940 --> 00:33:46.760
播种的专业代理，所以再次

00:33:43.690 --> 00:33:48.440
知道差异就是全部

00:33:46.760 --> 00:33:59.110
有用，但这可能是我们想要的东西

00:33:48.440 --> 00:34:02.600
这样做，让我们看看如何做到这一点

00:33:59.110 --> 00:34:04.160
它既是AOP代理又是cg 

00:34:02.600 --> 00:34:05.930
在这种情况下很好的财产

00:34:04.160 --> 00:34:08.480
现在我们可以方便

00:34:05.930 --> 00:34:10.730
检查一下，现在我们进入了

00:34:08.480 --> 00:34:13.850
在我们之前的社区问题

00:34:10.730 --> 00:34:16.940
绊倒在原本是

00:34:13.850 --> 00:34:19.629
当我们添加Aspectj代理时引入

00:34:16.940 --> 00:34:22.070
我们D何时启用了该行为

00:34:19.629 --> 00:34:24.800
方面被编织成一个组件

00:34:22.070 --> 00:34:25.970
代码，它造成了一个混乱，我们

00:34:24.800 --> 00:34:27.919
不容易理解

00:34:25.970 --> 00:34:29.570
因为有些字段不是

00:34:27.919 --> 00:34:32.000
可见我们正在工作的类型

00:34:29.570 --> 00:34:34.100
与存在于运行时谢谢

00:34:32.000 --> 00:34:36.620
他们所做的那种亚型

00:34:34.100 --> 00:34:39.409
发生幻想的子类型，所以它

00:34:36.620 --> 00:34:42.260
有一种方法可以很好地解决

00:34:39.409 --> 00:34:44.570
枚举字段和方法等

00:34:42.260 --> 00:34:47.090
所以我们接下来来看一下反射

00:34:44.570 --> 00:34:52.850
 Spring 里面的细节也是如此

00:34:47.090 --> 00:34:59.030
我在哪里，我的命令行在哪里

00:34:52.850 --> 00:35:02.210
亚军在这里好，我将使用任何

00:34:59.030 --> 00:35:05.870
这里的方法调用反射

00:35:02.210 --> 00:35:07.760
说反射实用程序调用或Spring 

00:35:05.870 --> 00:35:09.410
框架，它们给我们带来了如此方便

00:35:07.760 --> 00:35:15.020
你知道几种使

00:35:09.410 --> 00:35:18.730
处理简单的事情很简单

00:35:15.020 --> 00:35:22.070
可能摇晃或可能引起麻烦

00:35:18.730 --> 00:35:25.550
在某些物体上，所以

00:35:22.070 --> 00:35:29.510
我想找到给定的所有字段

00:35:25.550 --> 00:35:30.530
上课的权利，所以演示课上课了

00:35:29.510 --> 00:35:32.270
要给我它要问我

00:35:30.530 --> 00:35:34.250
进行新的现场回拨和通话

00:35:32.270 --> 00:35:36.230
返回它只是一个回调接口

00:35:34.250 --> 00:35:38.920
就像模板方法一样， 

00:35:36.230 --> 00:35:44.810
字段，在那里我可以说记录该信息

00:35:38.920 --> 00:35:47.510
字段等于两个字符串可以的字段

00:35:44.810 --> 00:35:54.610
当然，Scalia工作8 lambda是

00:35:47.510 --> 00:35:58.280
我认为很方便，我们可以使用

00:35:54.610 --> 00:36:01.130
反射实用程序以及找到

00:35:58.280 --> 00:36:03.380
我们班级或演示中的特定领域

00:36:01.130 --> 00:36:07.160
类类型在这种情况下是类字段

00:36:03.380 --> 00:36:09.910
将被称为列表，然后

00:36:07.160 --> 00:36:14.860
将那个和那个字段作为java.lang 

00:36:09.910 --> 00:36:17.150
反映领域，我可以用它来

00:36:14.860 --> 00:36:18.800
你知道我想我可以检查

00:36:17.150 --> 00:36:22.520
可以找到很多有关它的信息

00:36:18.800 --> 00:36:24.170
该信息列表的字符串，我可以

00:36:22.520 --> 00:36:25.730
注销，但这将是一个

00:36:24.170 --> 00:36:27.200
信息有限，所以我们来看看

00:36:25.730 --> 00:36:30.680
一秒钟内添加称为

00:36:27.200 --> 00:36:34.190
可分辨的类型

00:36:30.680 --> 00:36:40.820
关于此的更多信息

00:36:34.190 --> 00:36:43.940
好的，这是一个私人最后的妈妈

00:36:40.820 --> 00:36:45.260
字段等于私有，您知道

00:36:43.940 --> 00:36:48.110
我们发现的一个字段等于

00:36:45.260 --> 00:36:50.900
私有最终Java util列表的列表

00:36:48.110 --> 00:36:52.220
当然，当我们检查一个

00:36:50.900 --> 00:36:55.100
特别是一个，我们得到完全相同的

00:36:52.220 --> 00:36:58.340
结果我本可以做同样的事情

00:36:55.100 --> 00:37:02.810
与方法有关的事情，所以我

00:36:58.340 --> 00:37:07.010
可以说该类方法记录的演示类

00:37:02.810 --> 00:37:12.610
信息方法等于说方法

00:37:07.010 --> 00:37:12.610
完成字符串并运行它

00:37:19.810 --> 00:37:28.510
好的，我们可以在这里看到我们有一个

00:37:22.920 --> 00:37:29.890
更多的代码，然后我们可能已经

00:37:28.510 --> 00:37:32.680
知道，当然这是一面

00:37:29.890 --> 00:37:37.510
 AspectJ支持的效果为

00:37:32.680 --> 00:37:38.910
以及Lombok的预处理器

00:37:37.510 --> 00:37:41.680
您知道代理是在编译时

00:37:38.910 --> 00:37:43.570
即将推出的处理器

00:37:41.680 --> 00:37:44.530
进入我们的代码，所以我们得到了所有

00:37:43.570 --> 00:37:46.890
自由权利，我们得到了所有这些额外的

00:37:44.530 --> 00:37:48.910
即使我们可能不是

00:37:46.890 --> 00:37:50.260
特别意识到这一点，这非常

00:37:48.910 --> 00:37:53.020
方便，我们可以看到所有的东西和

00:37:50.260 --> 00:37:55.420
我们可以看到所有已添加到我们的

00:37:53.020 --> 00:37:57.340
类，我们可以知道所有迭代

00:37:55.420 --> 00:37:59.700
类中的方法

00:37:57.340 --> 00:38:02.740
现在我想回去封印这个领域

00:37:59.700 --> 00:38:04.030
有一个通用参数，所以它在

00:38:02.740 --> 00:38:05.920
为了了解更多

00:38:04.030 --> 00:38:10.140
关于我要使用可解析的

00:38:05.920 --> 00:38:16.300
我可以说RT类型是可解析的点

00:38:10.140 --> 00:38:22.600
现场，我可以通过存在的底漆

00:38:16.300 --> 00:38:24.630
在这里，你知道的RP会给我

00:38:22.600 --> 00:38:28.180
这种能力使我有能力

00:38:24.630 --> 00:38:32.350
找出什么遗传参数或

00:38:28.180 --> 00:38:33.340
特定字段的参数是

00:38:32.350 --> 00:38:35.320
所以在这种情况下，他们知道这是一个

00:38:33.340 --> 00:38:39.220
某些动力学图谱列表

00:38:35.320 --> 00:38:42.340
参数，以便将秋季RT中的数据记录到

00:38:39.220 --> 00:38:44.580
像这样的字符串运行反射

00:38:42.340 --> 00:38:44.580
方法

00:38:49.369 --> 00:38:55.920
好的，当我们这样做时，我们可以看到

00:38:53.220 --> 00:38:57.749
它向我们展示了一个Java列表Java util映射

00:38:55.920 --> 00:39:00.960
 java.lang字符串java.lang对象如此

00:38:57.749 --> 00:39:02.819
它知道我们的通用类型

00:39:00.960 --> 00:39:05.849
实例变量对，这非常

00:39:02.819 --> 00:39:09.089
方便，我们可以深入了解

00:39:05.849 --> 00:39:11.640
可以说给我一个通用参数

00:39:09.089 --> 00:39:13.289
你知道得到仿制药，然后我们

00:39:11.640 --> 00:39:15.420
可以放弃一个特定的通用名

00:39:13.289 --> 00:39:19.559
参数，我们甚至可以解决它

00:39:15.420 --> 00:39:21.420
更进一步，我们可以走，也可以保持

00:39:19.559 --> 00:39:23.880
我们可以递归下去

00:39:21.420 --> 00:39:24.839
找到通用参数并检查

00:39:23.880 --> 00:39:26.460
他们等等

00:39:24.839 --> 00:39:28.259
动态地对，这非常非常

00:39:26.460 --> 00:39:29.490
如果有的话，可以使用的强大功能

00:39:28.259 --> 00:39:33.960
这里的通用类型

00:39:29.490 --> 00:39:39.950
和你的系统好吧，让我们看看

00:39:33.960 --> 00:39:39.950
今天我们已经看过

00:39:40.579 --> 00:39:44.999
他们看过的梁工具

00:39:43.140 --> 00:39:47.640
 util，所以它是一个属性，直到文件复制

00:39:44.999 --> 00:39:49.980
 util Web，您知道一些我们

00:39:47.640 --> 00:39:53.910
帮助您获得Web LP支持

00:39:49.980 --> 00:39:54.839
反思支持，这些是

00:39:53.910 --> 00:39:56.609
刚开始的时候

00:39:54.839 --> 00:39:58.410
实际上还有很多其他的

00:39:56.609 --> 00:40:02.220
我们甚至没有机会

00:39:58.410 --> 00:40:03.749
看这里，但我想你可以我

00:40:02.220 --> 00:40:05.940
认为你应该有什么想法

00:40:03.749 --> 00:40:07.230
如果你看起来就在那里

00:40:05.940 --> 00:40:09.359
更有可能找到一些东西

00:40:07.230 --> 00:40:11.759
可能对您有帮助，所以不要那么快

00:40:09.359 --> 00:40:14.069
赶紧带来另一个

00:40:11.759 --> 00:40:15.299
现在我们劝阻您

00:40:14.069 --> 00:40:18.170
从一些使用一些行

00:40:15.299 --> 00:40:19.950
在某些情况下，他绝对应该

00:40:18.170 --> 00:40:22.619
我刚刚向您展示的实用程序类

00:40:19.950 --> 00:40:24.269
这里不保证稳定

00:40:22.619 --> 00:40:26.249
这个例子很好，所以如果你能找到一些

00:40:24.269 --> 00:40:27.180
将要制作的图书馆

00:40:26.249 --> 00:40:30.089
对你的保证，你就是

00:40:27.180 --> 00:40:31.049
愿意承担额外的依赖

00:40:30.089 --> 00:40:32.309
没关系

00:40:31.049 --> 00:40:33.960
绝对正确，但如果您只是

00:40:32.309 --> 00:40:35.849
寻找一些方便的

00:40:33.960 --> 00:40:37.349
您可能会发现这些是艺术

00:40:35.849 --> 00:40:38.579
在课堂上，他们在那里

00:40:37.349 --> 00:40:40.440
已经经过战斗测试，他们正在

00:40:38.579 --> 00:40:41.819
它们被组件中的组件使用

00:40:40.440 --> 00:40:44.569
 Spring Framework 和 Spring 生态系统

00:40:41.819 --> 00:40:46.069
很长一段时间，所以他们肯定

00:40:44.569 --> 00:40:48.450
有用和值得

00:40:46.069 --> 00:40:51.630
希望他们会为您服务， 

00:40:48.450 --> 00:40:53.309
有一天以某种方式

00:40:51.630 --> 00:40:56.210
非常感谢您的观看和

00:40:53.309 --> 00:40:56.210
下次见

00:41:02.340 --> 00:41:04.400
您

