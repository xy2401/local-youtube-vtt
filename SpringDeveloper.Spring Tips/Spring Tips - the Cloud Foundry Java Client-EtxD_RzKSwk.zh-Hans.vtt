WEBVTT
Kind: captions
Language: zh-Hans

00:00:25.910 --> 00:00:30.289
您好史蒂夫，欢迎来到另一个

00:00:28.460 --> 00:00:31.279
 Spring 技巧的分期付款和这个

00:00:30.289 --> 00:00:33.949
分期付款，我们将看看

00:00:31.279 --> 00:00:37.489
基于反应堆的Cloud Foundry Java客户端

00:00:33.949 --> 00:00:40.699
 3.3版本-无论您知道-在

00:00:37.489 --> 00:00:43.430
那一点，所以这个反应堆的3.3 X 

00:00:40.699 --> 00:00:45.320
客户对我来说很有趣

00:00:43.430 --> 00:00:47.690
使您能够与

00:00:45.320 --> 00:00:49.309
 Cloud Foundry API，可让您

00:00:47.690 --> 00:00:51.050
编写与客户一起使用的程序

00:00:49.309 --> 00:00:54.470
在API下做所有各种各样的事情

00:00:51.050 --> 00:00:55.879
 clarinha可以做的事情有一个

00:00:54.470 --> 00:00:59.559
您可能会这样做的很多原因

00:00:55.879 --> 00:01:02.570
正确的常见原因是

00:00:59.559 --> 00:01:05.030
因为你想控制或互动

00:01:02.570 --> 00:01:07.210
用平台来操纵所有

00:01:05.030 --> 00:01:10.220
它可以让您控制的事物

00:01:07.210 --> 00:01:12.350
以编程的方式很好，一个

00:01:10.220 --> 00:01:14.630
有充分的理由或理由

00:01:12.350 --> 00:01:17.299
当您阅读持续交付时

00:01:14.630 --> 00:01:19.340
和他们一起预定法利， 

00:01:17.299 --> 00:01:23.780
谦虚的连续交付

00:01:19.340 --> 00:01:25.220
书中谈到一种

00:01:23.780 --> 00:01:27.890
一种工具每一种工具

00:01:25.220 --> 00:01:30.079
环境它可以的一个应用程序

00:01:27.890 --> 00:01:32.890
正确部署所有东西

00:01:30.079 --> 00:01:35.719
通常会写那种代码

00:01:32.890 --> 00:01:37.490
你看不到，但我在用巨人

00:01:35.719 --> 00:01:40.729
空气报价滴在这里很多人

00:01:37.490 --> 00:01:43.759
很好地使用该代码

00:01:40.729 --> 00:01:45.289
使用bash write和bash并不是真的

00:01:43.759 --> 00:01:46.579
这么灵活，可能会很慢

00:01:45.289 --> 00:01:50.389
对，所以如果您使用云

00:01:46.579 --> 00:01:53.509
通过bash与Java客户一起融资

00:01:50.389 --> 00:01:54.950
那当然是可行的，但是你你

00:01:53.509 --> 00:01:56.899
失去测试的能力，就失去了

00:01:54.950 --> 00:01:58.969
与该代码进行交互的能力，以及

00:01:56.899 --> 00:02:01.130
重构成某种程度的扩展

00:01:58.969 --> 00:02:02.600
 bash变得很难扩展

00:02:01.130 --> 00:02:05.329
甚至具有功能的特定点

00:02:02.600 --> 00:02:07.159
如此法西斯主义不会让你非常

00:02:05.329 --> 00:02:09.319
远，您确实需要使用bash作为

00:02:07.159 --> 00:02:11.569
我希望太阳多了否则云

00:02:09.319 --> 00:02:14.330
铸造厂需要您运行一些

00:02:11.569 --> 00:02:16.400
在执行CF推送之前先执行命令

00:02:14.330 --> 00:02:18.410
具有明显的权利，你可能会

00:02:16.400 --> 00:02:20.150
示例要求您的应用程序是

00:02:18.410 --> 00:02:22.430
绑定到我的续集实例或

00:02:20.150 --> 00:02:23.870
您知道键值存储或

00:02:22.430 --> 00:02:25.970
不管您的支持服务是什么

00:02:23.870 --> 00:02:27.980
没有办法在

00:02:25.970 --> 00:02:29.660
清单我需要Cloud Foundry请

00:02:27.980 --> 00:02:31.790
创建此后备实例

00:02:29.660 --> 00:02:33.650
服务，然后在同一清单中

00:02:31.790 --> 00:02:35.690
该支持服务规定的

00:02:33.650 --> 00:02:37.190
应该绑定到您的应用程序

00:02:35.690 --> 00:02:39.560
可以指定您可以说的后一点

00:02:37.190 --> 00:02:39.980
我有一个支持服务

00:02:39.560 --> 00:02:42.349
已经

00:02:39.980 --> 00:02:44.690
由任何人在那里创建

00:02:42.349 --> 00:02:47.269
知道什么，我想成为我想

00:02:44.690 --> 00:02:48.170
将此应用程序绑定到该应用程序，但是您可以

00:02:47.269 --> 00:02:49.760
必须创建该应用程序

00:02:48.170 --> 00:02:51.620
某处，所以如果没有别的你

00:02:49.760 --> 00:02:53.989
 CF推送刚刚成为对CF的命令

00:02:51.620 --> 00:02:56.180
创建服务，然后指定

00:02:53.989 --> 00:02:58.160
服务名称和实例

00:02:56.180 --> 00:02:59.780
类型，我宁愿计划类型

00:02:58.160 --> 00:03:01.280
然后是该实例的名称

00:02:59.780 --> 00:03:03.470
服务，然后将其绑定到

00:03:01.280 --> 00:03:05.030
该应用程序，如果你想做

00:03:03.470 --> 00:03:06.230
您只想做的更复杂的事情

00:03:05.030 --> 00:03:07.640
检查舞台是否要看

00:03:06.230 --> 00:03:08.690
已经部署的应用程序

00:03:07.640 --> 00:03:10.489
您不想创建服务，如果

00:03:08.690 --> 00:03:12.410
它已经创建了，例如你

00:03:10.489 --> 00:03:14.810
想做，如果你想避免

00:03:12.410 --> 00:03:16.790
想要部署服务代理

00:03:14.810 --> 00:03:19.280
部署自定义路线，所有这些

00:03:16.790 --> 00:03:22.940
对bash有点痛苦

00:03:19.280 --> 00:03:24.859
对，所以我们虽然我喜欢bash但我不喜欢

00:03:22.940 --> 00:03:25.879
相信我们应该花我不多的钱

00:03:24.859 --> 00:03:27.799
相信你应该花很多时间

00:03:25.879 --> 00:03:29.269
特别是与业务有关

00:03:27.799 --> 00:03:31.910
我们非常关注的逻辑

00:03:29.269 --> 00:03:33.349
 bash，所以我们想要一种

00:03:31.910 --> 00:03:34.700
应用一种我们所需要的东西

00:03:33.349 --> 00:03:37.010
可以用来部署相同的

00:03:34.700 --> 00:03:38.299
各种环境下的工作软件

00:03:37.010 --> 00:03:40.190
在每个环境中

00:03:38.299 --> 00:03:42.590
主要租户之一，包含

00:03:40.190 --> 00:03:45.410
交付就是那一切

00:03:42.590 --> 00:03:47.389
执行所有的

00:03:45.410 --> 00:03:49.180
需要重新创建您的状态

00:03:47.389 --> 00:03:52.579
系统应受版本控制

00:03:49.180 --> 00:03:54.859
包括配置和

00:03:52.579 --> 00:03:56.900
环境的创造

00:03:54.859 --> 00:03:59.209
他们自己，当书是

00:03:56.900 --> 00:04:01.849
写的意思是也许

00:03:59.209 --> 00:04:03.889
虚拟机还原中的资产

00:04:01.849 --> 00:04:05.440
控制的还是虚拟的，也许他们可能是

00:04:03.889 --> 00:04:08.030
甚至虚拟机本身

00:04:05.440 --> 00:04:12.440
这些天我们不需要去那个农场

00:04:08.030 --> 00:04:14.239
我们可以假设给定一个普通的香草排序

00:04:12.440 --> 00:04:16.459
我们的云资金安装

00:04:14.239 --> 00:04:18.919
可以接受我们的应用程序和二进制文件

00:04:16.459 --> 00:04:21.590
你知道是由建筑创造的

00:04:18.919 --> 00:04:23.780
申请并根据清单申请

00:04:21.590 --> 00:04:27.740
和任何东西，并获得可复制

00:04:23.780 --> 00:04:29.150
结果，但仍然有食谱

00:04:27.740 --> 00:04:30.860
超越清单是有趣的， 

00:04:29.150 --> 00:04:31.910
我们不想用bash来做，所以这是

00:04:30.860 --> 00:04:34.729
一件事真的很好

00:04:31.910 --> 00:04:36.139
 Cloud Foundry Java客户端是

00:04:34.729 --> 00:04:37.760
你得到你有能力真正

00:04:36.139 --> 00:04:39.590
与API进行交互，您可以使用

00:04:37.760 --> 00:04:40.760
编译器指导您，什么是

00:04:39.590 --> 00:04:42.710
正确，什么不正确，你得到

00:04:40.760 --> 00:04:44.389
更多的反馈是，如果

00:04:42.710 --> 00:04:46.160
如果您正在使用反应式API 

00:04:44.389 --> 00:04:49.520
使用Java的反应式内容

00:04:46.160 --> 00:04:50.599
客户它可以做更多坦率的事情

00:04:49.520 --> 00:04:52.700
然后是命令行

00:04:50.599 --> 00:04:53.300
客户端可以记住命令行

00:04:52.700 --> 00:04:56.629
客户

00:04:53.300 --> 00:04:59.419
以程序正确的方式编写

00:04:56.629 --> 00:05:01.280
您要发布的语言代码

00:04:59.419 --> 00:05:02.810
一个命令接一个命令，所以您发出

00:05:01.280 --> 00:05:05.180
第一个命令，然后第二个

00:05:02.810 --> 00:05:07.849
然后是第三个，依此类推， 

00:05:05.180 --> 00:05:10.099
如果效率低下

00:05:07.849 --> 00:05:11.509
第一个命令很好，太糟糕了吧

00:05:10.099 --> 00:05:13.159
第二个命令将不得不等待

00:05:11.509 --> 00:05:15.050
直到第一个完成

00:05:13.159 --> 00:05:17.479
利用机会

00:05:15.050 --> 00:05:19.669
闲事的例子

00:05:17.479 --> 00:05:22.099
是连续的，或者不是

00:05:19.669 --> 00:05:23.449
可以使并发成为并发

00:05:22.099 --> 00:05:25.159
正确没有流水线

00:05:23.449 --> 00:05:27.080
所以我们有能力接受

00:05:25.159 --> 00:05:28.580
管理流水线，因为卡

00:05:27.080 --> 00:05:30.560
来自Java客户端的基于项目

00:05:28.580 --> 00:05:32.719
你对此毫无疑问的反应堆

00:05:30.560 --> 00:05:35.509
要点是Spring Framework 的基础

00:05:32.719 --> 00:05:37.789
法式反应性故事尤其如此

00:05:35.509 --> 00:05:40.909
支撑了Webb的Webb通量Webber 

00:05:37.789 --> 00:05:43.250
运行时，所以我们想利用

00:05:40.909 --> 00:05:44.389
反应式建筑的效率

00:05:43.250 --> 00:05:45.289
编码并记住很多我们所要做的

00:05:44.389 --> 00:05:48.259
部署应用程序时在这里做

00:05:45.289 --> 00:05:50.180
是I / O，所以这是完美的选择

00:05:48.259 --> 00:05:53.360
反应堆和反应式编程

00:05:50.180 --> 00:05:58.520
一般是I / O敏感和

00:05:53.360 --> 00:06:01.639
我驱动了什么代码另一件事

00:05:58.520 --> 00:06:04.159
我真的很喜欢使用Java 

00:06:01.639 --> 00:06:07.789
这里的客户是反应式Cloud Foundry 

00:06:04.159 --> 00:06:09.650
 Java客户端就是那样做的

00:06:07.789 --> 00:06:12.139
继续，每个您知道的精神

00:06:09.650 --> 00:06:13.460
它确实给了我们一个配方，我们可以

00:06:12.139 --> 00:06:17.270
用于跨多个应用程序的部署

00:06:13.460 --> 00:06:18.889
您的环境，从某种意义上讲， 

00:06:17.270 --> 00:06:21.229
安装脚本正确的是安装

00:06:18.889 --> 00:06:24.229
该exe文件，如果你想它是一个程序

00:06:21.229 --> 00:06:26.029
我们可以用来部署

00:06:24.229 --> 00:06:27.529
应用本身，逻辑可以

00:06:26.029 --> 00:06:31.009
实际上在应用程序本身中

00:06:27.529 --> 00:06:32.960
想象你拥有逻辑

00:06:31.009 --> 00:06:35.180
在部署的代码库本身中

00:06:32.960 --> 00:06:37.819
本身，你可以说可以指出

00:06:35.180 --> 00:06:40.430
无论您知道什么云机器， 

00:06:37.819 --> 00:06:43.250
想要并说出部署自己和你

00:06:40.430 --> 00:06:45.469
知道谁更好地部署系统

00:06:43.250 --> 00:06:47.300
那么软件本身就是

00:06:45.469 --> 00:06:49.759
这与旧的分类有很大的不同

00:06:47.300 --> 00:06:52.069
婴儿床模型的地方，你有东西

00:06:49.759 --> 00:06:53.690
现成的，如果它是基于云的

00:06:52.069 --> 00:06:55.849
如果是分布式系统的话

00:06:53.690 --> 00:06:57.409
弄清楚如何

00:06:55.849 --> 00:06:58.750
部署它，这实际上是要

00:06:57.409 --> 00:07:00.620
部署自身所需的一切是

00:06:58.750 --> 00:07:03.349
熟悉的基础，所以还有更多

00:07:00.620 --> 00:07:04.710
专业的感觉，特别是

00:07:03.349 --> 00:07:06.810
没有机会

00:07:04.710 --> 00:07:08.100
下游有人得到它的机会

00:07:06.810 --> 00:07:10.110
错误的，因为他们只会使用

00:07:08.100 --> 00:07:13.050
完全相同的安装脚本或第六个

00:07:10.110 --> 00:07:16.890
就像我看到的那样安装程序

00:07:13.050 --> 00:07:18.330
 Kelsey Hightower的精彩演讲，他

00:07:16.890 --> 00:07:20.280
在谈论他在说这个想法

00:07:18.330 --> 00:07:25.880
关于他所谓的自我部署

00:07:20.280 --> 00:07:28.110
应用程序，他他掺杂了重击

00:07:25.880 --> 00:07:30.540
他认为这是人们的原因

00:07:28.110 --> 00:07:31.950
离开IT，我认为他的表现很棒

00:07:30.540 --> 00:07:33.930
指向那里，他谈到

00:07:31.950 --> 00:07:36.240
在您的应用程序中的命令

00:07:33.930 --> 00:07:38.610
实际提升您知道您的应用程序

00:07:36.240 --> 00:07:39.540
在他的情况下到一个云平台上

00:07:38.610 --> 00:07:43.140
谈论kubernetes是

00:07:39.540 --> 00:07:45.600
当然也是一种选择，但我认为

00:07:43.140 --> 00:07:47.310
它适用于任何事物

00:07:45.600 --> 00:07:49.920
基于云的，当然有一个API 

00:07:47.310 --> 00:07:51.240
内容是这里的绝佳选择

00:07:49.920 --> 00:07:53.330
因为你不需要更多了

00:07:51.240 --> 00:07:56.730
比代码库本身的二进制文件

00:07:53.330 --> 00:07:57.960
为了这个工作而

00:07:56.730 --> 00:07:59.550
您需要一个容器的社区或

00:07:57.960 --> 00:08:01.170
正确的事情，所以这实际上是

00:07:59.550 --> 00:08:03.450
对我们来说是一个理想的机会，所以我们要

00:08:01.170 --> 00:08:05.790
继续演示反应性

00:08:03.450 --> 00:08:08.730
云供应商客户端，看看它如何

00:08:05.790 --> 00:08:10.500
现在允许我使用API 

00:08:08.730 --> 00:08:12.450
朋友肯尼·布斯塔尼（Kenny Bustani）和我

00:08:10.500 --> 00:08:15.120
这本书叫做云原生Java， 

00:08:12.450 --> 00:08:17.940
在书中，我们有集成测试

00:08:15.120 --> 00:08:20.250
这些集成测试都是

00:08:17.940 --> 00:08:22.170
使用反应式API驱动

00:08:20.250 --> 00:08:26.580
适用于新Java客户端权利的反应性云

00:08:22.170 --> 00:08:28.890
 API允许我们提供给客户

00:08:26.580 --> 00:08:32.160
聊聊我们的存在，你知道那种烟

00:08:28.890 --> 00:08:34.500
测试结束测试我们的聊天我们

00:08:32.160 --> 00:08:36.270
章节中的示例

00:08:34.500 --> 00:08:39.240
我认为经验非常

00:08:36.270 --> 00:08:40.620
对我们非常有用，因为我们看到了

00:08:39.240 --> 00:08:43.520
组成所有这些不同的东西

00:08:40.620 --> 00:08:46.980
以及如何部署有效的应用程序

00:08:43.520 --> 00:08:48.780
你充满信心地知道我们会

00:08:46.980 --> 00:08:50.340
正确的结果，而且速度更快

00:08:48.780 --> 00:08:52.050
就像我说的，因为我们正在使用他们的

00:08:50.340 --> 00:08:53.490
回到API能够更快

00:08:52.050 --> 00:08:56.820
比起我们写的

00:08:53.490 --> 00:08:59.340
使用云的等效命令

00:08:56.820 --> 00:09:00.660
 Foundry CF客户端和bash脚本

00:08:59.340 --> 00:09:02.070
实际上在某些情况下要快得多

00:09:00.660 --> 00:09:02.940
因为我们可以利用

00:09:02.070 --> 00:09:04.830
并发等等

00:09:02.940 --> 00:09:06.420
因此，让我们利用这一优势继续前进

00:09:04.830 --> 00:09:08.640
你知道去 Spring 开始

00:09:06.420 --> 00:09:11.520
今天我将在这里构建一个应用程序

00:09:08.640 --> 00:09:14.910
我们将使用 spring boot 到该om7 

00:09:11.520 --> 00:09:18.150
而我们是您，我们将使用一些

00:09:14.910 --> 00:09:19.590
自动配置

00:09:18.150 --> 00:09:22.560
现在澄清新的Java客户端

00:09:19.590 --> 00:09:24.600
自动配置尚未找到

00:09:22.560 --> 00:09:26.700
稳定的房屋权利，这实际上是一个

00:09:24.600 --> 00:09:29.430
拉请求是优秀的

00:09:26.700 --> 00:09:32.160
现在我认为它将降落在

00:09:29.430 --> 00:09:35.940
Spring Cloud云代工模块为

00:09:32.160 --> 00:09:37.470
里面的一种模块

00:09:35.940 --> 00:09:38.700
在里面的神器，所以你

00:09:37.470 --> 00:09:40.800
只要你知道你就能

00:09:38.700 --> 00:09:41.850
带来Spring Cloud Finchley，这是

00:09:40.800 --> 00:09:43.650
可能会在 Spring 住

00:09:41.850 --> 00:09:44.760
云芬奇利是哪个版本

00:09:43.650 --> 00:09:48.360
 Spring 的云将基于

00:09:44.760 --> 00:09:52.320
 spring boot 到本身会

00:09:48.360 --> 00:09:54.330
在2018年前几个月登陆

00:09:52.320 --> 00:09:56.070
这将是您在春季切工中知道的

00:09:54.330 --> 00:09:57.810
最终 Spring 会成功

00:09:56.070 --> 00:09:59.490
引导到那个哦，所以我们在谈论一个

00:09:57.810 --> 00:10:00.840
至少在此之前几个月

00:09:59.490 --> 00:10:01.920
代码是最终的，但我只是认为

00:10:00.840 --> 00:10:03.600
真的很有趣，所以我想

00:10:01.920 --> 00:10:04.530
给你看一个演示，让我们开始吧

00:10:03.600 --> 00:10:07.380
前进并带来春季引导

00:10:04.530 --> 00:10:08.670
 om7我们使用反应式网络支持， 

00:10:07.380 --> 00:10:09.930
我要带上 Spring 的云

00:10:08.670 --> 00:10:11.580
依赖不是因为我实际上需要

00:10:09.930 --> 00:10:14.340
Spring Cloud中的任何东西，但是因为我

00:10:11.580 --> 00:10:15.630
想要Maven依赖和

00:10:14.340 --> 00:10:17.700
葡萄酒和所有这些东西，我们仍然

00:10:15.630 --> 00:10:18.840
要做一些设置

00:10:17.700 --> 00:10:22.410
在那里，那没关系，所以我要打开

00:10:18.840 --> 00:10:26.250
这应该给 Spring 

00:10:22.410 --> 00:10:32.910
芬奇利俱乐部m4 m5好，我们来

00:10:26.250 --> 00:10:35.100
打开那第一件事

00:10:32.910 --> 00:10:38.160
我们将需要做的之前我们也要做

00:10:35.100 --> 00:10:41.220
要走的很远是

00:10:38.160 --> 00:10:42.810
 Cloud的Spring Cloud依赖关系

00:10:41.220 --> 00:10:44.130
铸造权，这是因为

00:10:42.810 --> 00:10:47.130
它不是代码库的一部分

00:10:44.130 --> 00:10:49.380
我们必须要有我的意思和干净

00:10:47.130 --> 00:10:51.480
在本地安装，但您希望

00:10:49.380 --> 00:10:55.640
到时候不会有这个问题

00:10:51.480 --> 00:10:55.640
你正在这样做，所以 Spring 的云

00:10:55.940 --> 00:11:05.880
云代工厂的依赖关系很好- 

00:10:59.880 --> 00:11:09.360
要构建快照，我们会说

00:11:05.880 --> 00:11:13.170
这是一棵棕榈树，我们会说

00:11:09.360 --> 00:11:16.140
范围是导入好，所以有

00:11:13.170 --> 00:11:18.540
那是 Spring 的云500 

00:11:16.140 --> 00:11:21.620
依赖，最后我们需要

00:11:18.540 --> 00:11:21.620
带来 Spring 的云

00:11:23.390 --> 00:11:29.550
五百条评论对，所以评论

00:11:27.180 --> 00:11:32.010
这是自动配置的地方

00:11:29.550 --> 00:11:33.720
活在当下，就像我说的那样

00:11:32.010 --> 00:11:35.550
可能会改变，这是一个单独的

00:11:33.720 --> 00:11:37.410
与...无关的模块

00:11:35.550 --> 00:11:40.350
服务注册和发现

00:11:37.410 --> 00:11:42.089
支持以及其他Web过滤器

00:11:40.350 --> 00:11:44.399
在 Spring Cloud 平台中

00:11:42.089 --> 00:11:45.930
某种模块，这是

00:11:44.399 --> 00:11:48.149
 Cloud Foundry的配置

00:11:45.930 --> 00:11:50.790
客户，所以也许是一个更好的工件

00:11:48.149 --> 00:11:52.740
 Spring 的云平台给客户

00:11:50.790 --> 00:11:53.760
它将改变，但我们显然会

00:11:52.740 --> 00:11:57.029
在文档上，否则他们会得到

00:11:53.760 --> 00:11:59.339
仓库什么都发生了，所以

00:11:57.029 --> 00:12:03.450
我们拥有的一切都给了我们

00:11:59.339 --> 00:12:05.070
自动配置的Cloud Foundry Java 

00:12:03.450 --> 00:12:09.360
客户端和该自动配置

00:12:05.070 --> 00:12:10.110
里面有很多活动部件

00:12:09.360 --> 00:12:12.089
新的Java客户端的云

00:12:10.110 --> 00:12:14.310
实际上，没有一个特别困难

00:12:12.089 --> 00:12:16.680
你可以看一下云供应商

00:12:14.310 --> 00:12:18.089
 Java客户网站，您会发现

00:12:16.680 --> 00:12:20.220
显示您的示例配置

00:12:18.089 --> 00:12:21.450
所有的运动件，但是有

00:12:20.220 --> 00:12:23.160
很多移动的东西，所以很好

00:12:21.450 --> 00:12:26.520
自动选择

00:12:23.160 --> 00:12:27.959
照顾我们，自信给我们

00:12:26.520 --> 00:12:29.850
像我一样编写应用程序的能力

00:12:27.959 --> 00:12:31.920
说与云资金互动

00:12:29.850 --> 00:12:33.240
有信心我们可以做很多事情

00:12:31.920 --> 00:12:35.070
您可以部署应用程序

00:12:33.240 --> 00:12:38.070
缩放它们，您可以创建自定义路线

00:12:35.070 --> 00:12:40.380
为他们，你知道你可以创造吗

00:12:38.070 --> 00:12:41.670
支持服务，如果

00:12:40.380 --> 00:12:46.350
你想改变你的计划

00:12:41.670 --> 00:12:49.709
可以创建服务经纪人

00:12:46.350 --> 00:12:51.150
基本上API是自己进行中介

00:12:49.709 --> 00:12:52.740
访问支持服务的东西

00:12:51.150 --> 00:12:55.470
例如数据库或消息队列或

00:12:52.740 --> 00:12:56.940
键值存储什么都可以

00:12:55.470 --> 00:13:00.029
动态安装那些

00:12:56.940 --> 00:13:04.110
转弯可以有依赖的支持

00:13:00.029 --> 00:13:07.490
您可以推送应用程序的服务

00:13:04.110 --> 00:13:10.200
你知道可以查询API吗

00:13:07.490 --> 00:13:12.029
部署您可以做的自定义路线服务

00:13:10.200 --> 00:13:13.860
各种事情都可以

00:13:12.029 --> 00:13:16.140
实际推送容器图像，如果您

00:13:13.860 --> 00:13:17.550
希望你可以在这里做各种各样的事情

00:13:16.140 --> 00:13:18.630
更何况安全方面

00:13:17.550 --> 00:13:20.310
是的，我的意思是有些事情

00:13:18.630 --> 00:13:22.740
使用客户端确实做得很好

00:13:20.310 --> 00:13:23.399
没有等效的Java客户端

00:13:22.740 --> 00:13:25.680
或类似的

00:13:23.399 --> 00:13:28.649
 CF客户端本身中的某种命令

00:13:25.680 --> 00:13:30.720
因此在CF CLI客户端本身中

00:13:28.649 --> 00:13:32.810
我的朋友乔什·麦肯齐（Josh Mackenzie）和

00:13:30.720 --> 00:13:36.150
我示范了我们什么时候做的

00:13:32.810 --> 00:13:41.460
众筹现场课程

00:13:36.150 --> 00:13:46.800
因为培生（Pearson）正在使用众筹

00:13:41.460 --> 00:13:48.570
 Java客户端跨所有功能

00:13:46.800 --> 00:13:50.820
特定应用

00:13:48.570 --> 00:13:51.750
组织或空间，所以假设我们

00:13:50.820 --> 00:13:53.490
想经历所有

00:13:51.750 --> 00:13:56.430
使用部署的应用程序

00:13:53.490 --> 00:13:58.260
 Java构建包，我们知道

00:13:56.430 --> 00:13:59.220
构建包已更新，并且

00:13:58.260 --> 00:14:01.050
重要的重要安全

00:13:59.220 --> 00:14:03.420
脆弱性，所以我要做的是

00:14:01.050 --> 00:14:05.730
想要强迫云晴重新启动

00:14:03.420 --> 00:14:07.590
有Java帐单包或

00:14:05.730 --> 00:14:09.600
 the.net药包或其他

00:14:07.590 --> 00:14:11.760
使用新的法案佩奇，你知道他们是否

00:14:09.600 --> 00:14:13.020
重新启动并且它们没有固定到

00:14:11.760 --> 00:14:14.910
版本的特定版本

00:14:13.020 --> 00:14:16.020
的构建包，然后他们会得到

00:14:14.910 --> 00:14:18.420
最新的构建包将具有

00:14:16.020 --> 00:14:19.740
安全漏洞补丁，所以我们

00:14:18.420 --> 00:14:21.780
希望那是一件有趣的事情

00:14:19.740 --> 00:14:24.690
可以，但是没有类似的按钮

00:14:21.780 --> 00:14:26.790
没有像您知道的那样重启

00:14:24.690 --> 00:14:28.620
工作应用中的所有内容

00:14:26.790 --> 00:14:30.720
在太空中的组织中

00:14:28.620 --> 00:14:33.210
您可以轻松编写该代码Fredi 

00:14:30.720 --> 00:14:37.530
使用Cloud Foundry Java客户端

00:14:33.210 --> 00:14:39.060
好吧，让我们看一下演示，让我

00:14:37.530 --> 00:14:46.170
使这个字体大一点

00:14:39.060 --> 00:14:50.450
朋友好吧，我会说使其非常22 

00:14:46.170 --> 00:14:55.170
好吧，好了，我们要

00:14:50.450 --> 00:14:56.970
应用程序运行程序和窒息

00:14:55.170 --> 00:14:58.020
获胜者将需要它

00:14:56.970 --> 00:14:59.790
你知道那将是

00:14:58.020 --> 00:15:01.050
实际上持有我们的业务对象

00:14:59.790 --> 00:15:02.850
再次没有理由这一定是

00:15:01.050 --> 00:15:04.800
一个应用程序编写者，这可能是一个

00:15:02.850 --> 00:15:06.930
 REST API您可以拥有一个休息端点

00:15:04.800 --> 00:15:08.790
 Spring Web Flex其余端点

00:15:06.930 --> 00:15:10.410
这是您知道的Spring Web Flex 

00:15:08.790 --> 00:15:12.780
这是使用反应式网络支持

00:15:10.410 --> 00:15:14.780
不是spring MVC，而是spring web flex和

00:15:12.780 --> 00:15:16.860
我们已经在很多地方谈论过

00:15:14.780 --> 00:15:18.060
在许多场合的机会

00:15:16.860 --> 00:15:21.360
以前的视频，所以我鼓励您

00:15:18.060 --> 00:15:23.280
检查那些我们可以休息一下

00:15:21.360 --> 00:15:24.540
端点，例如操纵

00:15:23.280 --> 00:15:26.280
部署该软件，我们可以

00:15:24.540 --> 00:15:28.320
有一个Spring Shell应用程序

00:15:26.280 --> 00:15:29.790
另一个真正引人注目的选择是您

00:15:28.320 --> 00:15:32.640
知道在上一个视频中，我们看了

00:15:29.790 --> 00:15:36.480
Spring Shell，我们研究了它如何

00:15:32.640 --> 00:15:40.710
用于创建易于使用的外壳

00:15:36.480 --> 00:15:42.570
我们可以动态互动

00:15:40.710 --> 00:15:44.970
你可以编写一个涟漪，然后

00:15:42.570 --> 00:15:46.380
如此想象一下，拥有一个

00:15:44.970 --> 00:15:48.490
旨在让人们部署您的

00:15:46.380 --> 00:15:51.730
您可以指定自定义的应用程序

00:15:48.490 --> 00:15:53.320
您可以询问的参数

00:15:51.730 --> 00:15:54.370
系统状态运行状况检查

00:15:53.320 --> 00:15:55.600
每个人都可以做的所有事情

00:15:54.370 --> 00:15:59.470
各种各样的事情，你也可以

00:15:55.600 --> 00:16:01.330
就像我说的在命令中使用它

00:15:59.470 --> 00:16:02.890
你知道命令停止在你刚刚运行的地方

00:16:01.330 --> 00:16:05.380
它，它只是做一些事情而不是

00:16:02.890 --> 00:16:06.640
有涟漪，所以这只是一个

00:16:05.380 --> 00:16:10.450
应用程序运行器，我们只是

00:16:06.640 --> 00:16:11.860
在其中创建逻辑，这不是

00:16:10.450 --> 00:16:13.120
没事的唯一方法就是好

00:16:11.860 --> 00:16:14.800
我们要做的第一件事就是说

00:16:13.120 --> 00:16:16.209
我们有一个罐子，我们要

00:16:14.800 --> 00:16:17.950
实际上必须在某个地方部署一个罐子

00:16:16.209 --> 00:16:21.040
因此，请确保我们有一个罐子

00:16:17.950 --> 00:16:23.230
假设这个罐子是由

00:16:21.040 --> 00:16:25.240
 Spring 的框架资源吧

00:16:23.230 --> 00:16:28.870
是我们的罐子，我们学到的二进制文件

00:16:25.240 --> 00:16:32.770
部署，所以假设jar点存在

00:16:28.870 --> 00:16:34.270
 jar必须存在，我们要失败

00:16:32.770 --> 00:16:35.860
如果那不是真的，那么在哪里编程

00:16:34.270 --> 00:16:37.810
这个罐子来自好，我们必须

00:16:35.860 --> 00:16:40.930
自然地注入它，所以让我们注入它

00:16:37.810 --> 00:16:43.779
作为文物，让我们看看它会

00:16:40.930 --> 00:16:44.770
做一个神器，你知道罐子神器

00:16:43.779 --> 00:16:48.640
我们去那就是我们要去的

00:16:44.770 --> 00:16:50.170
依靠，我想这使我们

00:16:48.640 --> 00:16:52.120
接下来的一点是我们从哪里得到

00:16:50.170 --> 00:16:53.440
该罐子，让我们运行这段代码

00:16:52.120 --> 00:16:55.860
看看会发生什么

00:16:53.440 --> 00:16:55.860
会失败

00:17:02.260 --> 00:17:05.260
对

00:17:10.290 --> 00:17:15.270
好的，所以我们没有环境

00:17:13.320 --> 00:17:20.250
变量称为Johnartifact，让我们

00:17:15.270 --> 00:17:24.060
在这里设置，我们将设置

00:17:20.250 --> 00:17:26.430
环境变量，我们将创建一个

00:17:24.060 --> 00:17:27.690
新罐子或新罐子，我很容易受到伤害

00:17:26.430 --> 00:17:29.340
应该在传送带上做到这一点

00:17:27.690 --> 00:17:31.980
这可能是命令行参数

00:17:29.340 --> 00:17:34.710
您可以使用Commons Ops，您知道

00:17:31.980 --> 00:17:36.840
斑驳的评论操作例如

00:17:34.710 --> 00:17:38.820
管理您知道的环境

00:17:36.840 --> 00:17:41.790
您甚至可以使用spring的参数

00:17:38.820 --> 00:17:44.130
您知道的属性配置属性

00:17:41.790 --> 00:17:46.230
实际绑定属性的pogos 

00:17:44.130 --> 00:17:48.480
到光束，然后取消引用

00:17:46.230 --> 00:17:50.730
您知道的命令行中的属性

00:17:48.480 --> 00:17:53.010
在这个申请贷款人中，你可以吗

00:17:50.730 --> 00:17:54.390
可以在这里使用各种各样的东西

00:17:53.010 --> 00:17:57.570
知道这是否是贝壳

00:17:54.390 --> 00:17:59.400
您指定的内容--随便

00:17:57.570 --> 00:18:01.050
罐子，但在这种情况下很难

00:17:59.400 --> 00:18:02.640
编码，所以我要说

00:18:01.050 --> 00:18:04.890
我的身上会有一个罐子

00:18:02.640 --> 00:18:06.810
现在我不叫桌面的藏身罐

00:18:04.890 --> 00:18:07.950
实际上有那个罐子，所以这会

00:18:06.810 --> 00:18:10.020
仍然失败至少我们指定的

00:18:07.950 --> 00:18:11.130
在环境变量中

00:18:10.020 --> 00:18:15.830
我们想要什么，让我们继续前进， 

00:18:11.130 --> 00:18:22.850
现在就创建那个罐子吧，所以CD 

00:18:15.830 --> 00:18:28.970
 mcdeere应用程序CD应用程序touch hi dot groovy 

00:18:22.850 --> 00:18:36.540
 Emacs AIGU静止控制器

00:18:28.970 --> 00:18:42.860
读数取决于控制器好吗def hi 

00:18:36.540 --> 00:18:42.860
路径变量字符串名称

00:18:44.559 --> 00:19:01.940
问候呼吸你好好得到

00:18:57.379 --> 00:19:04.519
映射嗨名字问号好

00:19:01.940 --> 00:19:08.359
好看看那个保存Spring 罐

00:19:04.519 --> 00:19:10.489
隐藏的时髦我想我们应该跑

00:19:08.359 --> 00:19:12.169
首先让我们做一下，你知道我

00:19:10.489 --> 00:19:13.459
知道我犯了一个错误好吧，让我们修复它

00:19:12.169 --> 00:19:15.999
我们来了

00:19:13.459 --> 00:19:18.469
我们该怎么办

00:19:15.999 --> 00:19:28.119
支架在那里奔跑并躲藏起来

00:19:18.469 --> 00:19:31.009
 groovy好的看起来不错localhost嗨

00:19:28.119 --> 00:19:36.559
世界还可以，你还可以

00:19:31.009 --> 00:19:39.049
 Spring 的提示非常好，所以现在 Spring 

00:19:36.559 --> 00:19:44.119
罐子，我们要正确创建一个

00:19:39.049 --> 00:19:49.129
我将提交的应用程序点属性

00:19:44.119 --> 00:19:51.729
说管理点安全Dardenne老

00:19:49.129 --> 00:19:54.769
等于假好吧

00:19:51.729 --> 00:19:57.529
Spring 罐，我们想要

00:19:54.769 --> 00:20:02.509
执行器位实际上我们不是Emacs 

00:19:57.529 --> 00:20:06.139
抢 spring boot 的藏身之处

00:20:02.509 --> 00:20:08.719
起动器执行器这将是云

00:20:06.139 --> 00:20:16.419
毕竟如此 Spring 

00:20:08.719 --> 00:20:20.809
罐子藏身罐Java-John Hyde罐子

00:20:16.419 --> 00:20:27.409
让我们看看看起来是否很好

00:20:20.809 --> 00:20:31.489
好的e和V好吧，所以现在复制

00:20:27.409 --> 00:20:33.469
隐藏罐子到桌面，那

00:20:31.489 --> 00:20:37.659
应该符合我们的环境

00:20:33.469 --> 00:20:37.659
期待我们尝试一下

00:20:42.690 --> 00:20:45.789
 [音乐] 

00:20:58.179 --> 00:21:13.419
也必须存在它不存在

00:21:00.579 --> 00:21:16.989
让我们看看那里的Jhelum桌面吧

00:21:13.419 --> 00:21:21.629
这是张家的家，只是一个饼图效果

00:21:16.989 --> 00:21:27.819
哦，需要使用文件来解决

00:21:21.629 --> 00:21:30.669
前缀那里好吧，为什么让我们重新启动

00:21:27.819 --> 00:21:39.729
 IntelliJ在这里给我无限的机会

00:21:30.669 --> 00:21:49.679
麻烦看演示我们想要的想法

00:21:39.729 --> 00:21:49.679
好的XML 

00:21:55.350 --> 00:22:03.039
好的，所以我们有我们的应用程序

00:21:57.460 --> 00:22:04.450
让我们看看是否可以再次运行它

00:22:03.039 --> 00:22:07.509
仍然有我们的环境变量

00:22:04.450 --> 00:22:13.630
当然不是问题了，所以我们

00:22:07.509 --> 00:22:17.710
称之为罐子神器，它将

00:22:13.630 --> 00:22:25.019
等于家庭监狱自己的桌面

00:22:17.710 --> 00:22:25.019
藏身罐好吧， 

00:22:29.250 --> 00:22:32.030
再次运行

00:22:42.320 --> 00:22:45.320
好的

00:22:49.010 --> 00:22:59.630
运行是移位f10，所以移位函数f2 

00:22:54.190 --> 00:23:00.980
好吧，看起来很高兴，所以

00:22:59.630 --> 00:23:02.960
现在我们要部署什么

00:23:00.980 --> 00:23:04.790
我们的应用程序实际上在我们之前

00:23:02.960 --> 00:23:06.950
部署我们的应用程序，我们需要申请

00:23:04.790 --> 00:23:12.410
服务好吧号

00:23:06.950 --> 00:23:15.080
一口井是部署P my 

00:23:12.410 --> 00:23:16.910
续集支持服务正确怎么办

00:23:15.080 --> 00:23:18.380
我的意思是，如果您曾经使用过

00:23:16.910 --> 00:23:22.100
云外国人，你知道它有一个

00:23:18.380 --> 00:23:23.870
很棒的目录，所以CF目录或

00:23:22.100 --> 00:23:26.450
市场而不是有服务

00:23:23.870 --> 00:23:28.580
市场和这个市场的变化

00:23:26.450 --> 00:23:29.900
从一个棉花安装到另一个

00:23:28.580 --> 00:23:33.020
现在我们正在使用关键网络

00:23:29.900 --> 00:23:35.120
服务是托管的多租户排序

00:23:33.020 --> 00:23:38.060
安装众筹的过程

00:23:35.120 --> 00:23:43.520
关键本身维持在公共云上

00:23:38.060 --> 00:23:46.610
基础设施，因此我们将其用于

00:23:43.520 --> 00:23:47.900
支持服务，我们使用不同的云

00:23:46.610 --> 00:23:50.330
您知道软件的提供商

00:23:47.900 --> 00:23:53.090
服务提供商，这些都非常

00:23:50.330 --> 00:23:56.230
很好，非常有用，如果您正在跑步

00:23:53.090 --> 00:23:59.060
在前提条件下，您可能会提供

00:23:56.230 --> 00:24:00.140
您的组织感觉需要在那里

00:23:59.060 --> 00:24:02.540
所以你自己部署了它们

00:24:00.140 --> 00:24:04.370
可能会有一个关键的

00:24:02.540 --> 00:24:05.240
很多时候的Cloud Foundry 

00:24:04.370 --> 00:24:07.400
与您看到的不同

00:24:05.240 --> 00:24:09.320
托管在这里，如果您使用公共场所

00:24:07.400 --> 00:24:12.650
像Google或Microsoft这样的云

00:24:09.320 --> 00:24:14.740
有并保持自己的服务

00:24:12.650 --> 00:24:16.520
经纪人的独特和

00:24:14.740 --> 00:24:18.410
这些不同的增值

00:24:16.520 --> 00:24:20.180
环境，以便您可以使用

00:24:18.410 --> 00:24:21.470
例如大桌子和谷歌在

00:24:20.180 --> 00:24:23.150
 Google Cloud用于运行关键云

00:24:21.470 --> 00:24:24.950
在Google云端之上提供资金

00:24:23.150 --> 00:24:27.080
看到你认识一个服务经纪人

00:24:24.950 --> 00:24:27.980
可以让您与这些话题交谈

00:24:27.080 --> 00:24:32.030
在这里，我们有很多不同的

00:24:27.980 --> 00:24:34.070
我这里的服务我想用P我的

00:24:32.030 --> 00:24:36.170
例如续集，这是一个很好的

00:24:34.070 --> 00:24:39.560
当您查看目录时，您会看到

00:24:36.170 --> 00:24:41.240
没有星号的那个

00:24:39.560 --> 00:24:42.830
这是一个条目吗

00:24:41.240 --> 00:24:44.510
是上的服务提供商的名称

00:24:42.830 --> 00:24:46.550
左这里的不同计划

00:24:44.510 --> 00:24:48.500
用逗号分隔没有

00:24:46.550 --> 00:24:50.510
星号是免费的，因此所有这些服务

00:24:48.500 --> 00:24:51.890
所有这些服务提供商的经纪人

00:24:50.510 --> 00:24:53.330
拥有免费套餐，因此您可以尝试

00:24:51.890 --> 00:24:56.090
有些东西都是免费的

00:24:53.330 --> 00:24:58.160
你知道他们只是想让你使用它

00:24:56.090 --> 00:24:59.840
是的，但是你可以看到

00:24:58.160 --> 00:25:01.340
不自由的星号

00:24:59.840 --> 00:25:02.970
所以你会跟你说话以确保你

00:25:01.340 --> 00:25:04.379
有点像

00:25:02.970 --> 00:25:06.240
咨询服务经纪人

00:25:04.379 --> 00:25:09.809
服务提供商找出成本

00:25:06.240 --> 00:25:12.000
时间，但其中许多是免费的

00:25:09.809 --> 00:25:14.009
就像我说的，几乎所有人都在旁边

00:25:12.000 --> 00:25:18.720
据我所知，他们都应该

00:25:14.009 --> 00:25:20.490
自由了，他们派了一层

00:25:18.720 --> 00:25:22.830
所以我们要使用PMI续集，因为

00:25:20.490 --> 00:25:24.450
不是一个简单的续集数据库

00:25:22.830 --> 00:25:26.549
应用程序不使用我的续集，但

00:25:24.450 --> 00:25:27.720
这既不是这里也不是我们

00:25:26.549 --> 00:25:29.840
我们想做的是一个

00:25:27.720 --> 00:25:31.919
小我们的小罐子我们的藏身罐

00:25:29.840 --> 00:25:33.899
现在需要我的续集，我们不能

00:25:31.919 --> 00:25:35.940
没有我的续集就开始

00:25:33.899 --> 00:25:38.159
实例绑定到应用程序，如果我们

00:25:35.940 --> 00:25:40.379
自从

00:25:38.159 --> 00:25:41.789
应用程序充满信心的是

00:25:40.379 --> 00:25:43.200
将环境变量注入

00:25:41.789 --> 00:25:45.360
包含您的运行过程

00:25:43.200 --> 00:25:48.870
在这种情况下，您的Java代码就显得愚蠢

00:25:45.360 --> 00:25:50.730
 Springwood应用程序和邀请叛逆者

00:25:48.870 --> 00:25:53.970
包含所需的凭据

00:25:50.730 --> 00:25:55.769
与我的顺序交谈，如果我的

00:25:53.970 --> 00:25:57.570
顺序应该永远失败

00:25:55.769 --> 00:25:59.399
您的平台，您的服务提供商将

00:25:57.570 --> 00:26:00.240
提供不同的环境变量

00:25:59.399 --> 00:26:01.559
那会把你指向不同的

00:26:00.240 --> 00:26:03.809
希望有相同数据的实例

00:26:01.559 --> 00:26:05.759
是否可用取决于云

00:26:03.809 --> 00:26:07.440
提供者维护诸如备份之类的东西

00:26:05.759 --> 00:26:09.600
依此类推，但关键是我们的代码

00:26:07.440 --> 00:26:10.769
不需要改变，我们只需补水

00:26:09.600 --> 00:26:12.840
这些来自环境的凭证

00:26:10.769 --> 00:26:14.970
变量是12的帐篷之一

00:26:12.840 --> 00:26:18.000
事实陷阱是它是无状态的，我们

00:26:14.970 --> 00:26:19.769
可以将其指向不同的服务

00:26:18.000 --> 00:26:21.149
在质量保证和阶段开发中

00:26:19.769 --> 00:26:22.649
生产和多种环境

00:26:21.149 --> 00:26:24.120
如果我们从

00:26:22.649 --> 00:26:25.559
一个容器到另一个数据

00:26:24.120 --> 00:26:26.759
在另一个中心应该只是一个

00:26:25.559 --> 00:26:29.700
改变环境的问题

00:26:26.759 --> 00:26:31.230
变量，这就是当前的功能

00:26:29.700 --> 00:26:33.659
为了您，我们坚持认为

00:26:31.230 --> 00:26:34.950
我们做的簿记管理

00:26:33.659 --> 00:26:36.149
确保那些环境造反者指出

00:26:34.950 --> 00:26:38.250
可以实际使用的东西

00:26:36.149 --> 00:26:41.159
为您准备的

00:26:38.250 --> 00:26:43.440
已取得其凭证

00:26:41.159 --> 00:26:45.389
专门针对

00:26:43.440 --> 00:26:48.750
您的应用程序，所以我想创建

00:26:45.389 --> 00:26:50.549
那些支持服务的人

00:26:48.750 --> 00:26:52.080
首先，让我们这样做

00:26:50.549 --> 00:26:55.980
您想创建一个服务，所以我

00:26:52.080 --> 00:26:59.070
要说我们想创建一个服务，如果

00:26:55.980 --> 00:27:01.220
如果它在那儿就在雾中

00:26:59.070 --> 00:27:05.730
没有那里，所以如果优质的服务

00:27:01.220 --> 00:27:10.049
实例，如果丢失，我要去

00:27:05.730 --> 00:27:12.130
当我用我的续集我要做

00:27:10.049 --> 00:27:16.790
猜猜我们说肥皂

00:27:12.130 --> 00:27:22.130
 -我的续集，我们想要我们想要

00:27:16.790 --> 00:27:26.540
有一个特殊的名字，所以我们称它为

00:27:22.130 --> 00:27:29.930
你知道带提示我的续集，我们

00:27:26.540 --> 00:27:32.810
想要我想要的东西，我想我们

00:27:29.930 --> 00:27:34.220
应该获得免费的权利，我们将

00:27:32.810 --> 00:27:35.690
谈论我们如何在

00:27:34.220 --> 00:27:36.920
第二个，但说我们有这个

00:27:35.690 --> 00:27:39.410
需要两个字符串的方法

00:27:36.920 --> 00:27:42.280
好的，服务很好，如果没事的话

00:27:39.410 --> 00:27:46.460
所以字符串将成为服务

00:27:42.280 --> 00:27:48.050
名称，然后实例名称之一

00:27:46.460 --> 00:27:49.430
我们想要您想要的逻辑名称

00:27:48.050 --> 00:27:51.170
给它，以便我们可以参考它

00:27:49.430 --> 00:27:53.030
以后好吧，我们要去

00:27:51.170 --> 00:27:55.550
如果要创建服务实例

00:27:53.030 --> 00:27:57.590
它丢失了，我们必须做一些

00:27:55.550 --> 00:27:58.400
漂亮，你知道我们必须审问

00:27:57.590 --> 00:28:00.170
使该系统状态

00:27:58.400 --> 00:28:02.030
工作，让我们看看我们如何做到这一点

00:28:00.170 --> 00:28:05.570
首先，我想看看

00:28:02.030 --> 00:28:07.580
需要使用API​​时

00:28:05.570 --> 00:28:09.380
 API，因此我们可以在此处注入该API 

00:28:07.580 --> 00:28:11.870
使用上述自动

00:28:09.380 --> 00:28:13.190
配置了Cloud Foundry Java客户端，因此

00:28:11.870 --> 00:28:15.710
我将使用Cloud Foundry 

00:28:13.190 --> 00:28:17.720
这里的操作，我称之为

00:28:15.710 --> 00:28:19.670
操作会将其注入

00:28:17.720 --> 00:28:25.040
应用程序的构造函数非常好

00:28:19.670 --> 00:28:31.160
现在我可以把它放在楼上

00:28:25.040 --> 00:28:33.380
现在去，我们要说

00:28:31.160 --> 00:28:35.240
我们要首先弄清楚是否

00:28:33.380 --> 00:28:38.690
服务已经存在，所以我们说

00:28:35.240 --> 00:28:40.340
该操作具有点服务， 

00:28:38.690 --> 00:28:41.900
我想我们可以列出实例和

00:28:40.340 --> 00:28:43.520
然后我们要过滤对

00:28:41.900 --> 00:28:46.700
要过滤实例，所以我

00:28:43.520 --> 00:28:50.120
要说过滤器si，我们要

00:28:46.700 --> 00:28:53.900
说我没有名字所以我不知道

00:28:50.120 --> 00:28:57.380
名称点等于忽略大小写实例

00:28:53.900 --> 00:29:01.520
名称或对不起，实例名称正确

00:28:57.380 --> 00:29:06.380
所以现在这将给我们

00:29:01.520 --> 00:29:07.850
向发布商询问您的情况

00:29:06.380 --> 00:29:09.230
如果我们刚刚完成列出一个自治领

00:29:07.850 --> 00:29:10.820
会给我们所有的服务

00:29:09.230 --> 00:29:12.200
但是在这里，我们只过滤到

00:29:10.820 --> 00:29:14.120
我们希望您注意到的那一件事很容易

00:29:12.200 --> 00:29:15.230
那就是你知道的那种

00:29:14.120 --> 00:29:16.730
我说过的话从舌头上滚下来

00:29:15.230 --> 00:29:18.170
这个点操作我说我想

00:29:16.730 --> 00:29:20.210
使用服务，然后我想

00:29:18.170 --> 00:29:21.200
具体看一下所有的清单

00:29:20.210 --> 00:29:23.000
他们，然后我想过滤

00:29:21.200 --> 00:29:25.090
对，如果我这样做了

00:29:23.000 --> 00:29:26.170
点应用

00:29:25.090 --> 00:29:28.330
支持在那里与

00:29:26.170 --> 00:29:30.640
管理组织的申请

00:29:28.330 --> 00:29:33.610
从管理构建包进阶

00:29:30.640 --> 00:29:35.650
事情本身给了我们您知道的sh代码

00:29:33.610 --> 00:29:37.450
这不太有趣

00:29:35.650 --> 00:29:39.400
您知道动态网络的策略

00:29:37.450 --> 00:29:40.860
政策路由服务管理

00:29:39.400 --> 00:29:42.850
空间管理空间本身

00:29:40.860 --> 00:29:45.760
像你在跑的堆栈

00:29:42.850 --> 00:29:47.830
您是否正在将应用程序部署到Linux？ 

00:29:45.760 --> 00:29:49.540
知道在Linux干细胞下切割

00:29:47.830 --> 00:29:52.060
正在使用Windows虚拟机

00:29:49.540 --> 00:29:55.210
我基本上是启动Windows容器的

00:29:52.060 --> 00:29:57.280
在Windows Windows Server 2016中，您知道

00:29:55.210 --> 00:29:58.810
所有这些东西都在这里描述和

00:29:57.280 --> 00:30:00.130
以此API为模型，但您有

00:29:58.810 --> 00:30:01.990
与REST API对话的场景

00:30:00.130 --> 00:30:03.160
好了，所以它正在与REST API通讯

00:30:01.990 --> 00:30:05.590
但我们不必担心我们

00:30:03.160 --> 00:30:07.060
有一个很好的类型安全客户端

00:30:05.590 --> 00:30:09.760
为我们知道所有这些东西

00:30:07.060 --> 00:30:12.160
有我们的出版商会告诉我们

00:30:09.760 --> 00:30:18.280
如果某物存在正确的话

00:30:12.160 --> 00:30:26.130
所以现在我们要做的是

00:30:18.280 --> 00:30:33.160
想要我们想要创建服务

00:30:26.130 --> 00:30:37.810
首先是我们的创意服务，但

00:30:33.160 --> 00:30:40.200
只有在没有现存的情况下

00:30:37.810 --> 00:30:44.080
我们会说我们想做

00:30:40.200 --> 00:30:46.990
现有的思想开关（如果为空） 

00:30:44.080 --> 00:30:48.850
所以如果这个发布者

00:30:46.990 --> 00:30:50.260
回来，它没有价值，记得

00:30:48.850 --> 00:30:52.990
这是反应式流发布者

00:30:50.260 --> 00:30:54.820
这是一个会通知我们的对象

00:30:52.990 --> 00:30:57.010
每当有新记录时

00:30:54.820 --> 00:30:59.700
通知我们该通知是

00:30:57.010 --> 00:31:02.140
打电话，你知道它会发出

00:30:59.700 --> 00:31:04.360
在这种情况下正确的对象可能

00:31:02.140 --> 00:31:06.280
如果不发出任何东西就不要遗漏

00:31:04.360 --> 00:31:08.050
那么它是空的，我们想要

00:31:06.280 --> 00:31:09.910
我们必须要分类切换流

00:31:08.050 --> 00:31:11.620
基本上正确，我们无法继续

00:31:09.910 --> 00:31:13.450
处理后，我们不能链接任何东西

00:31:11.620 --> 00:31:14.680
那是因为没有没有

00:31:13.450 --> 00:31:17.380
那将会发生，所以我们需要切换

00:31:14.680 --> 00:31:20.710
并改用其他发布商

00:31:17.380 --> 00:31:25.530
处理这个要求，这就是我们

00:31:20.710 --> 00:31:25.530
要做的是我们要做的是

00:31:26.450 --> 00:31:35.060
切换到板条箱右侧，让我们切换到

00:31:30.590 --> 00:31:41.360
一个板条箱在那里，然后我们将返回

00:31:35.060 --> 00:31:43.790
一个或一个空的，这将是一个你

00:31:41.360 --> 00:31:45.890
知道结果没事

00:31:43.790 --> 00:31:47.810
这样的服务实例摘要如此

00:31:45.890 --> 00:31:49.280
我们需要在这里打电话

00:31:47.810 --> 00:31:54.320
一个地方，那个箱子会说

00:31:49.280 --> 00:31:57.470
此操作点服务点列表

00:31:54.320 --> 00:31:58.820
服务产品以及我们要做什么

00:31:57.470 --> 00:32:00.500
现在我们在看目录

00:31:58.820 --> 00:32:02.210
就在我们查看所有

00:32:00.500 --> 00:32:04.010
提供我们已经提供的服务

00:32:02.210 --> 00:32:05.600
在我们的帐户中，您知道我吗

00:32:04.010 --> 00:32:07.730
已经创建了一个实例

00:32:05.600 --> 00:32:09.590
服务，但是你知道并且是

00:32:07.730 --> 00:32:11.390
如果已经给出了逻辑名

00:32:09.590 --> 00:32:13.100
我现在将被称为实例名称

00:32:11.390 --> 00:32:14.780
查看目录以做

00:32:13.100 --> 00:32:17.660
我需要发送命令，这

00:32:14.780 --> 00:32:18.620
是他们众筹Java的地方

00:32:17.660 --> 00:32:20.840
计划很有意思

00:32:18.620 --> 00:32:24.890
这些大量使用建设者并接受它

00:32:20.840 --> 00:32:26.690
接受或离开它，但是它是什么

00:32:24.890 --> 00:32:29.420
我们必须在这里使用，你知道这是

00:32:26.690 --> 00:32:31.880
这么大的API太灵活了

00:32:29.420 --> 00:32:33.800
认为这实际上给了你一个你知道的

00:32:31.880 --> 00:32:35.870
这是您可以做的所有事情

00:32:33.800 --> 00:32:37.160
这是我的观点，没有那里

00:32:35.870 --> 00:32:38.570
没有什么对你隐藏

00:32:37.160 --> 00:32:40.430
那样很好，所以

00:32:38.570 --> 00:32:42.140
我要说看目录

00:32:40.430 --> 00:32:44.180
然后过滤返回的结果

00:32:42.140 --> 00:32:45.590
记得我在提供服务

00:32:44.180 --> 00:32:47.570
提供，所以我要预测我想要一个

00:32:45.590 --> 00:32:52.220
筛选以提供产品，我会

00:32:47.570 --> 00:32:55.430
说标签是否等于服务

00:32:52.220 --> 00:32:57.410
我们想看看服务名称，然后我

00:32:55.430 --> 00:32:58.580
想要得到的结果你知道

00:32:57.410 --> 00:32:59.830
现在我们有一家出版商，如果您

00:32:58.580 --> 00:33:05.350
看着这实际上是一个

00:32:59.830 --> 00:33:08.870
数据发布者，这是一箱

00:33:05.350 --> 00:33:11.240
发布者，因此它是服务的发布者

00:33:08.870 --> 00:33:17.020
现在提供产品，我们希望

00:33:11.240 --> 00:33:18.770
实际过滤并将其转化为

00:33:17.020 --> 00:33:20.390
其他的东西，所以这是我们

00:33:18.770 --> 00:33:26.480
叫做flatmap，所以我要

00:33:20.390 --> 00:33:28.160
埃索在这里，我们将在平面图中说

00:33:26.480 --> 00:33:29.960
我们要创造一个我们要

00:33:28.160 --> 00:33:32.240
确定服务工厂的正确性

00:33:29.960 --> 00:33:34.130
服务提供中有哪些服务计划

00:33:32.240 --> 00:33:35.870
是服务工厂的集合，所以

00:33:34.130 --> 00:33:38.200
我们将分配服务计划

00:33:35.870 --> 00:33:42.220
到这里的变量

00:33:38.200 --> 00:33:45.669
计划以及在计划中

00:33:42.220 --> 00:33:47.289
参观计划，看看是否有任何计划

00:33:45.669 --> 00:33:49.539
是自由的权利，所以这是我们想要的

00:33:47.289 --> 00:33:54.489
弄清楚它是免费的，所以我要

00:33:49.539 --> 00:33:56.399
说计划梦点过滤器，我要

00:33:54.489 --> 00:33:59.980
需要一个谓词，基本上

00:33:56.399 --> 00:34:01.629
服务计划现在免费

00:33:59.980 --> 00:34:02.559
应该是可插入的，我说这将是

00:34:01.629 --> 00:34:04.239
有些东西会很高兴

00:34:02.559 --> 00:34:08.349
可插拔的，所以在这里我们要说

00:34:04.239 --> 00:34:11.230
谓词服务计划怀孕工具包

00:34:08.349 --> 00:34:19.149
正确的时间谓词在这里，我们将

00:34:11.230 --> 00:34:20.770
说服务计划谓词，我们想要

00:34:19.149 --> 00:34:22.089
找到第一个回来的

00:34:20.770 --> 00:34:24.099
他们中的任何一个也许只有

00:34:22.089 --> 00:34:26.379
一个或不是你知道我们没有

00:34:24.099 --> 00:34:28.000
它会工作，但我们真的想要印度人

00:34:26.379 --> 00:34:31.780
还是第一个我想都没关系

00:34:28.000 --> 00:34:34.089
如果一个人回来很棒，那将会给

00:34:31.780 --> 00:34:35.349
我们包含他们的第一个流

00:34:34.089 --> 00:34:37.569
在这种情况下实际上记录正确

00:34:35.349 --> 00:34:38.919
给我们一个可选的权利，所以我不

00:34:37.569 --> 00:34:40.929
想要我实际需要的可选件

00:34:38.919 --> 00:34:42.040
那里的价值，否则我们需要

00:34:40.929 --> 00:34:46.919
抛出异常是非常非常的

00:34:42.040 --> 00:34:51.490
错了，不然会让你知道新的

00:34:46.919 --> 00:34:59.040
运行时异常，所以运行时异常

00:34:51.490 --> 00:35:04.780
找不到服务找不到服务

00:34:59.040 --> 00:35:09.460
服务称为服务名称正确

00:35:04.780 --> 00:35:13.270
那就是你要签署的没关系

00:35:09.460 --> 00:35:15.910
直到变量存在服务计划，所以

00:35:13.270 --> 00:35:18.160
有免费服务计划免费服务

00:35:15.910 --> 00:35:22.150
我们想要的实例，所以我会说免费

00:35:18.160 --> 00:35:24.490
我想做的就是使用

00:35:22.150 --> 00:35:25.930
创建服务实例的权利

00:35:24.490 --> 00:35:29.950
所以我们要创建一个服务

00:35:25.930 --> 00:35:35.140
实例，我们要说我是这个点

00:35:29.950 --> 00:35:37.150
背诵操作思想服务点

00:35:35.140 --> 00:35:39.549
创建实例并想要传递一个

00:35:37.150 --> 00:35:42.990
创建服务实例请求，以便

00:35:39.549 --> 00:35:42.990
创建服务实例

00:35:43.190 --> 00:35:51.750
请求点构建器点，然后我们

00:35:47.040 --> 00:35:56.030
将传递计划名称和

00:35:51.750 --> 00:36:00.540
套餐名称当然是免费套餐

00:35:56.030 --> 00:36:02.880
名字，所以我们的名字在那里

00:36:00.540 --> 00:36:05.910
我们将传递服务名称

00:36:02.880 --> 00:36:07.530
那应该是服务名称

00:36:05.910 --> 00:36:09.540
在那里，我们将通过

00:36:07.530 --> 00:36:13.080
服务实例名称，然后

00:36:09.540 --> 00:36:15.210
是实例名称，我认为

00:36:13.080 --> 00:36:17.490
成为我们需要的一切，让我们开始建设

00:36:15.210 --> 00:36:21.180
现在这将给我们一个要求

00:36:17.490 --> 00:36:23.270
可以通过那里，所以这是一项付费服务

00:36:21.180 --> 00:36:31.710
实例请求伟大按那里

00:36:23.270 --> 00:36:33.240
好了，所以我们现在有了一些代码

00:36:31.710 --> 00:36:37.080
在这里，我们要创建一个

00:36:33.240 --> 00:36:38.940
使用创建服务实例

00:36:37.080 --> 00:36:40.619
您知道的服务服务子分组

00:36:38.940 --> 00:36:43.200
操作中的功能和

00:36:40.619 --> 00:36:44.910
 -我知道的关于ap的操作

00:36:43.200 --> 00:36:47.190
回到平台的方式

00:36:44.910 --> 00:36:52.260
操作API是一种

00:36:47.190 --> 00:36:53.310
高级的东西，这是一个，你

00:36:52.260 --> 00:36:55.380
知道它具有所有功能

00:36:53.310 --> 00:36:57.420
您想要的高级功能

00:36:55.380 --> 00:37:00.690
期待您使用的是C f / c Li 

00:36:57.420 --> 00:37:04.710
而且该功能很好地分组了

00:37:00.690 --> 00:37:06.570
进入这类子api， 

00:37:04.710 --> 00:37:08.160
轮到不得不组成较低的水平

00:37:06.570 --> 00:37:10.619
原始物实际上有一些东西

00:37:08.160 --> 00:37:13.770
称为Cloud Foundry客户端， 

00:37:10.619 --> 00:37:16.740
客户资助的客户水平很低

00:37:13.770 --> 00:37:18.180
它提供了更多控制权，因此，如果您

00:37:16.740 --> 00:37:20.040
在中找不到您需要的东西

00:37:18.180 --> 00:37:22.500
云为您可能检查的操作

00:37:20.040 --> 00:37:24.240
客户，但客户并不总是

00:37:22.500 --> 00:37:25.859
有你想要的东西，例如工作

00:37:24.240 --> 00:37:27.480
实际将应用程序推送到

00:37:25.859 --> 00:37:29.430
平台即部署

00:37:27.480 --> 00:37:32.250
实际组成的应用程序

00:37:29.430 --> 00:37:35.250
本身还有许多其他较小的事物， 

00:37:32.250 --> 00:37:36.690
所有那些个别的东西都是

00:37:35.250 --> 00:37:39.540
您将在客户端找到的内容

00:37:36.690 --> 00:37:43.490
部分操作本身是

00:37:39.540 --> 00:37:45.119
实际上是操作API，因此

00:37:43.490 --> 00:37:47.280
你知道很多事情正在发生

00:37:45.119 --> 00:37:48.540
当您进行推送时，它将获得服务

00:37:47.280 --> 00:37:49.680
它正在推路线，正在推

00:37:48.540 --> 00:37:51.540
应用程序正在做各种各样的事情

00:37:49.680 --> 00:37:53.040
你不能拿的东西

00:37:51.540 --> 00:37:55.230
如果您愿意的话可以授予

00:37:53.040 --> 00:37:57.030
分开那个细节

00:37:55.230 --> 00:37:59.730
您可以通过深入研究客户端来做到这一点

00:37:57.030 --> 00:38:01.590
好的，所以我们现在有他们，我们

00:37:59.730 --> 00:38:04.140
确实需要提供额外的运算符

00:38:01.590 --> 00:38:06.720
在那里，这是一项服务计划是免费的

00:38:04.140 --> 00:38:08.760
太好了，这就是我们提供的价值

00:38:06.720 --> 00:38:14.190
那里好吧，现在我们有了

00:38:08.760 --> 00:38:18.990
我们是说我们要

00:38:14.190 --> 00:38:20.930
创建服务，然后当我们

00:38:18.990 --> 00:38:24.869
现在将其设为此处的返回值

00:38:20.930 --> 00:38:29.060
不是超级有用的权利，这是做什么的

00:38:24.869 --> 00:38:29.060
我们得到如果我们分配给它，这是一个

00:38:30.230 --> 00:38:37.109
无效的权利不完全是我们

00:38:33.960 --> 00:38:43.460
想要所以我想做的是

00:38:37.109 --> 00:38:45.900
说然后我想找到现有的

00:38:43.460 --> 00:38:47.340
现在我要确认服务实例

00:38:45.900 --> 00:38:48.780
一切都只是由

00:38:47.340 --> 00:38:52.500
再次读取数据，所以我会说

00:38:48.780 --> 00:38:55.490
那么很多现有的，当然

00:38:52.500 --> 00:39:01.170
将其翻转为服务实例

00:38:55.490 --> 00:39:03.780
总结，所以创建，所以我们要

00:39:01.170 --> 00:39:06.420
我们要做的是

00:39:03.780 --> 00:39:09.570
创建我们将要经历的

00:39:06.420 --> 00:39:11.010
创建它，然后将其返回

00:39:09.570 --> 00:39:12.150
搜索它，您知道权利

00:39:11.010 --> 00:39:13.200
链接到我们要写的是

00:39:12.150 --> 00:39:14.670
要创建一个新服务，他们

00:39:13.200 --> 00:39:16.140
将查找该服务并返回

00:39:14.670 --> 00:39:18.390
包含该服务的发布者

00:39:16.140 --> 00:39:22.320
实际的逻辑如下

00:39:18.390 --> 00:39:25.410
会说寻找它，你知道是否

00:39:22.320 --> 00:39:27.960
在那里创建，然后无论您做什么

00:39:25.410 --> 00:39:29.580
吸收现在返回的流量

00:39:27.960 --> 00:39:31.740
你会有助焊剂的权利，这是

00:39:29.580 --> 00:39:32.820
结果实际上是通量良好

00:39:31.740 --> 00:39:36.420
我们知道那只会是一个

00:39:32.820 --> 00:39:39.240
对象，所以我们只说接受它，然后

00:39:36.420 --> 00:39:41.580
把它变成单声道

00:39:39.240 --> 00:39:43.470
单核反应堆是一个世界

00:39:41.580 --> 00:39:45.750
产生零或一的发布者

00:39:43.470 --> 00:39:48.359
价值观和变化是出版商

00:39:45.750 --> 00:39:51.240
在其中产生0到n值

00:39:48.359 --> 00:39:54.300
可能是无限的权利，所以我们

00:39:51.240 --> 00:39:55.650
说我们想返回我们想要

00:39:54.300 --> 00:39:58.350
说当我寻找现有的

00:39:55.650 --> 00:40:00.090
如果没有现有记录，则记录

00:39:58.350 --> 00:40:01.830
然后使用该发布者

00:40:00.090 --> 00:40:04.080
创建一个新的，当然它将

00:40:01.830 --> 00:40:05.280
通过返回您知道自己是否结束

00:40:04.080 --> 00:40:07.080
他们存在，它将寻找现有的

00:40:05.280 --> 00:40:09.000
一个，然后我们把整个事情

00:40:07.080 --> 00:40:14.119
结果我们将其返回

00:40:09.000 --> 00:40:16.380
所以让我们返回所有这样的

00:40:14.119 --> 00:40:18.119
这意味着我们需要一个发布者

00:40:16.380 --> 00:40:21.559
才能恢复服务

00:40:18.119 --> 00:40:25.770
实例摘要，所以这是

00:40:21.559 --> 00:40:27.599
服务实例摘要还可以

00:40:25.770 --> 00:40:30.059
如果缺少我们的创建服务实例

00:40:27.599 --> 00:40:31.890
现在这就是一个大出版商写的

00:40:30.059 --> 00:40:33.240
这实际上就是所有这些

00:40:31.890 --> 00:40:35.280
所有这些不同的东西

00:40:33.240 --> 00:40:38.490
小流量和分支等等

00:40:35.280 --> 00:40:41.250
全部合并成一个大发行商

00:40:38.490 --> 00:40:43.559
有多个步骤或阶段可以

00:40:41.250 --> 00:40:45.290
反应堆发动机可以通过的管道

00:40:43.559 --> 00:40:48.030
对我们来说可以的管道

00:40:45.290 --> 00:40:55.220
现在当然在这里为我们管理

00:40:48.030 --> 00:40:57.390
你知道在这里创建服务，我们有一个

00:40:55.220 --> 00:40:59.760
我们有一个出版商，什么都没有

00:40:57.390 --> 00:41:01.500
发生了，没事了

00:40:59.760 --> 00:41:04.349
但是因为我们实际上需要参观

00:41:01.500 --> 00:41:06.420
返回的数据，我们需要

00:41:04.349 --> 00:41:09.270
您知道那是一个结果是

00:41:06.420 --> 00:41:10.500
我们实际上必须订阅

00:41:09.270 --> 00:41:13.680
在反应世界中又一次

00:41:10.500 --> 00:41:14.730
发布者什么都不激活

00:41:13.680 --> 00:41:16.140
如果我运行这段代码会发生

00:41:14.730 --> 00:41:17.790
我们刚才写的没有

00:41:16.140 --> 00:41:20.520
激活什么都不会实际执行

00:41:17.790 --> 00:41:21.839
直到有人打电话订阅

00:41:20.520 --> 00:41:23.010
发布者，所以我们要一个

00:41:21.839 --> 00:41:26.040
发布者，所以我们只想说

00:41:23.010 --> 00:41:27.660
在这里订阅，我们将假设

00:41:26.040 --> 00:41:30.630
从那发出的最后一件事

00:41:27.660 --> 00:41:31.680
发布者将是你

00:41:30.630 --> 00:41:33.839
知道我们已经完成的确认

00:41:31.680 --> 00:41:35.730
对，所以我们要说X爱那个

00:41:33.839 --> 00:41:39.119
信息，我们需要日志护理，让我们开始吧

00:41:35.730 --> 00:41:42.450
日志日志等于日志工厂医生获取的日志

00:41:39.119 --> 00:41:51.109
一路走好，我们要

00:41:42.450 --> 00:41:59.339
说出您的申请信息

00:41:51.109 --> 00:42:04.770
部署并绑定到服务好吧，我们

00:41:59.339 --> 00:42:09.500
需要这个单引号，你知道

00:42:04.770 --> 00:42:09.500
数秒即可部署

00:42:09.550 --> 00:42:19.600
现在我们需要提供一些字符串

00:42:13.510 --> 00:42:21.490
在那里格式化参数

00:42:19.600 --> 00:42:23.800
情况下，提取这个很有用

00:42:21.490 --> 00:42:26.680
出来，所以这是服务名称

00:42:23.800 --> 00:42:29.650
还有服务实例名称

00:42:26.680 --> 00:42:32.710
我们将通过这个， 

00:42:29.650 --> 00:42:33.790
说你的申请叫我

00:42:32.710 --> 00:42:39.130
要称呼这个好，我们需要给

00:42:33.790 --> 00:42:41.650
它的名字正确，所以我们知道不会

00:42:39.130 --> 00:42:45.810
即将在这里部署应用程序

00:42:41.650 --> 00:42:50.110
我们将此字符串称为应用程序名称等于

00:42:45.810 --> 00:42:53.350
 st app春季提示应用程序还不错

00:42:50.110 --> 00:42:56.440
您的应用程序已经部署好了

00:42:53.350 --> 00:42:58.060
并绑定到称为实例的服务

00:42:56.440 --> 00:43:02.890
我们将重命名为的名称

00:42:58.060 --> 00:43:04.960
服务实例名称，我们需要

00:43:02.890 --> 00:43:07.810
提供一个持续时间，所以让我们

00:43:04.960 --> 00:43:10.870
实际上开始计时正确

00:43:07.810 --> 00:43:16.380
早于等于系统点

00:43:10.870 --> 00:43:16.380
当前时间毫秒，这将是

00:43:16.500 --> 00:43:24.190
系统点当前时间晚启动

00:43:20.680 --> 00:43:27.600
所以我们会在这里看到持续时间增量

00:43:24.190 --> 00:43:31.210
那给我们带来了什么呢？ 

00:43:27.600 --> 00:43:35.770
一个错误，我们需要为此编译

00:43:31.210 --> 00:43:38.050
运行格式良好的字符串

00:43:35.770 --> 00:43:39.760
好的，所以我们有第一个出版商

00:43:38.050 --> 00:43:42.340
我们要我们实际上是你

00:43:39.760 --> 00:43:44.500
知道这样做会做的不好

00:43:42.340 --> 00:43:45.610
它要做的是创造

00:43:44.500 --> 00:43:47.010
服务，如果它不存在，那么让我们

00:43:45.610 --> 00:43:53.440
去看看我是否已经得到服务

00:43:47.010 --> 00:43:57.450
好的CF没问题，所以我要删除

00:43:53.440 --> 00:43:59.410
这个CF t减去FC和jameise相等

00:43:57.450 --> 00:44:00.770
我不需要删除的任何行为

00:43:59.410 --> 00:44:06.640
任何东西

00:44:00.770 --> 00:44:06.640
我虽然不能想要那个

00:44:07.839 --> 00:44:11.140
不，还好

00:44:11.560 --> 00:44:23.150
 CFS我们有两项服务CF D-f CN j 

00:44:18.589 --> 00:44:26.750
高清是一个好习惯，让我们摆脱它，然后

00:44:23.150 --> 00:44:29.119
我们将删除CN j我的续集

00:44:26.750 --> 00:44:33.050
那是我需要卡的两个应用

00:44:29.119 --> 00:44:34.339
 DV由于其他原因稍后会指出

00:44:33.050 --> 00:44:38.119
现在我只有一项服务

00:44:34.339 --> 00:44:39.380
我还没有任何应用程序，所以现在让我们运行

00:44:38.119 --> 00:44:44.950
这段代码让我们看看发生了什么

00:44:39.380 --> 00:44:44.950
我们会说我要它运行

00:44:49.710 --> 00:44:54.359
好的，再次是一个Web应用程序

00:44:53.309 --> 00:44:56.819
有趣的是你有

00:44:54.359 --> 00:44:58.530
了解这个管道可以

00:44:56.819 --> 00:45:01.109
进程可以异步运行

00:44:58.530 --> 00:45:03.809
对，所以这是此命令行

00:45:01.109 --> 00:45:05.640
跑步者，它可能会长久完成

00:45:03.809 --> 00:45:08.430
在此发布者完成工作之前

00:45:05.640 --> 00:45:11.160
这就是为什么如果你没有东西

00:45:08.430 --> 00:45:13.710
就像Web Flex API或spring 

00:45:11.160 --> 00:45:15.510
 MVC保持插座打开，因此

00:45:13.710 --> 00:45:17.550
保持流程运行，您可能会

00:45:15.510 --> 00:45:19.290
认为这是行不通的

00:45:17.550 --> 00:45:21.089
异步对，这没有

00:45:19.290 --> 00:45:23.280
没有理由这个发布者

00:45:21.089 --> 00:45:25.200
必须执行其不同阶段

00:45:23.280 --> 00:45:27.630
它可以做的主线程

00:45:25.200 --> 00:45:29.490
通常会以其他方式执行，而您

00:45:27.630 --> 00:45:31.920
可以说我当然可以控制

00:45:29.490 --> 00:45:34.890
想订阅一个特定的

00:45:31.920 --> 00:45:37.410
调度程序，所以您知道调度程序或点

00:45:34.890 --> 00:45:39.750
弹性的或弹性调度程序

00:45:37.410 --> 00:45:41.309
和他们在一起生活的时间

00:45:39.750 --> 00:45:43.140
东西，或者你可以做各种各样的事情

00:45:41.309 --> 00:45:45.300
在这里控制计划，但要保持

00:45:43.140 --> 00:45:49.980
记住尝试这个开始

00:45:45.300 --> 00:45:52.440
开始不是在这里

00:45:49.980 --> 00:45:54.480
最终在这里没有被捕获

00:45:52.440 --> 00:45:56.609
在最后阶段捕获

00:45:54.480 --> 00:45:57.809
管道正确，就是这样

00:45:56.609 --> 00:46:01.319
本身很有趣

00:45:57.809 --> 00:46:02.430
让我们来看看CF是否有效

00:46:01.319 --> 00:46:04.440
有 Spring 的提示，我的续集是

00:46:02.430 --> 00:46:07.020
创建了如果我们运行代码会发生什么

00:46:04.440 --> 00:46:07.920
再次正确，我们知道这应该

00:46:07.020 --> 00:46:09.359
做正确的事，如果已经

00:46:07.920 --> 00:46:13.200
在那里，如果它是

00:46:09.359 --> 00:46:16.440
不在那里，我们应该得到结果，所以

00:46:13.200 --> 00:46:17.099
没关系，所以什么都没有改变

00:46:16.440 --> 00:46:19.109
很好

00:46:17.099 --> 00:46:20.730
好吧，现在我们要部署

00:46:19.109 --> 00:46:25.260
我要部署的应用程序权限

00:46:20.730 --> 00:46:26.309
应用程序，然后我们要部署

00:46:25.260 --> 00:46:27.660
然后将其正确绑定，这样

00:46:26.309 --> 00:46:29.250
现在实际部署应用程序

00:46:27.660 --> 00:46:31.349
我们有一家发布商

00:46:29.250 --> 00:46:32.520
服务实例，如果现在不见了

00:46:31.349 --> 00:46:37.770
想部署应用程序，所以我

00:46:32.520 --> 00:46:40.309
会说推送应用程序和

00:46:37.770 --> 00:46:42.359
应用程序将使用应用程序名称和

00:46:40.309 --> 00:46:45.329
我想我们要多少个副本

00:46:42.359 --> 00:46:48.780
现在想要为什么不这样做，我们会通过

00:46:45.329 --> 00:46:50.849
在罐子里，我们要开始

00:46:48.780 --> 00:46:52.710
假设我们不想

00:46:50.849 --> 00:46:53.549
正确开始，我们将继续努力，但是

00:46:52.710 --> 00:46:56.040
我们不想开始自己的

00:46:53.549 --> 00:46:57.930
众筹（如果您部署了

00:46:56.040 --> 00:46:59.730
应用程序，但您需要诸如

00:46:57.930 --> 00:47:00.480
您想要绑定它的支持服务

00:46:59.730 --> 00:47:02.339
在启动应用程序之前

00:47:00.480 --> 00:47:03.089
否则应用程序将启动

00:47:02.339 --> 00:47:04.680
并寻找

00:47:03.089 --> 00:47:06.059
或消息队列或其他任何内容

00:47:04.680 --> 00:47:07.559
失败，所以启动毫无意义

00:47:06.059 --> 00:47:09.450
我们虽然想部署应用程序

00:47:07.559 --> 00:47:10.710
因此它有一个逻辑名称

00:47:09.450 --> 00:47:12.809
我们可以参考它并进行操作

00:47:10.710 --> 00:47:16.039
它，但我们不想启动它

00:47:12.809 --> 00:47:23.539
让我们创建一个称为push ok的方法

00:47:16.039 --> 00:47:26.369
复制副本jar开始，您知道开始正确了

00:47:23.539 --> 00:47:28.499
所以我们不想开始

00:47:26.369 --> 00:47:32.670
说正确的方式，所以我们不想

00:47:28.499 --> 00:47:35.519
开始它是真的，所以让我们开始吧

00:47:32.670 --> 00:47:36.900
回到这一点，在推动中，我们要

00:47:35.519 --> 00:47:38.249
到我们实际上要推动

00:47:36.900 --> 00:47:42.180
应用程序jar本身，所以我要

00:47:38.249 --> 00:47:44.700
说路径路径等于这是Java 

00:47:42.180 --> 00:47:48.749
和IO文件库，我当然要去

00:47:44.700 --> 00:47:49.140
说jar获取文件到达正确的路径

00:47:48.749 --> 00:47:51.660
好

00:47:49.140 --> 00:47:55.440
我们将在这里添加一个例外

00:47:51.660 --> 00:48:00.170
这个例外很好，然后我们想

00:47:55.440 --> 00:48:04.589
说我们关闭加上操作点

00:48:00.170 --> 00:48:07.769
应用程序点推送和即将推送

00:48:04.589 --> 00:48:08.460
平台上的应用程序

00:48:07.769 --> 00:48:11.160
应用

00:48:08.460 --> 00:48:12.839
你知道会用到的

00:48:11.160 --> 00:48:16.259
我们刚刚创建的路径

00:48:12.839 --> 00:48:19.609
所以PTH那里我们要说不开始不

00:48:16.259 --> 00:48:22.619
开始，我们要给它一个

00:48:19.609 --> 00:48:26.190
实例计数，因此实例副本

00:48:22.619 --> 00:48:29.460
而是我们要告诉我们

00:48:26.190 --> 00:48:32.430
想要有一个特定的名字，所以

00:48:29.460 --> 00:48:35.400
我们将在其中为其指定应用名称

00:48:32.430 --> 00:48:38.789
认为这足以考虑

00:48:35.400 --> 00:48:40.920
在这里，就足够了，那又怎样

00:48:38.789 --> 00:48:42.329
我们想做我们想确认吗

00:48:40.920 --> 00:48:43.829
我们得到了想要的数据

00:48:42.329 --> 00:48:47.269
确认申请已完成

00:48:43.829 --> 00:48:49.979
那我们说点运算

00:48:47.269 --> 00:48:53.940
应用程序点获取获取应用程序

00:48:49.979 --> 00:48:57.479
要求那个建造者那个点

00:48:53.940 --> 00:48:59.009
为应用命名，可以吗？ 

00:48:57.479 --> 00:49:05.720
如果我们将其分配给

00:48:59.009 --> 00:49:08.130
结果应用程序详细信息mano好的

00:49:05.720 --> 00:49:09.960
所以这里有我们的申请细节

00:49:08.130 --> 00:49:13.040
当我们转向那实际上

00:49:09.960 --> 00:49:17.760
返回或当我们转过这里

00:49:13.040 --> 00:49:19.590
好吧，看起来我们有

00:49:17.760 --> 00:49:21.870
我们在那里需要的一切，如果我们认为

00:49:19.590 --> 00:49:23.490
关于我们刚刚想做的事情

00:49:21.870 --> 00:49:26.130
再次撰写，这是很大的

00:49:23.490 --> 00:49:29.820
一个大的小狗发布管道，所以我们

00:49:26.130 --> 00:49:34.920
可以说先创建

00:49:29.820 --> 00:49:35.370
服务，如果它丢失，然后执行

00:49:34.920 --> 00:49:38.070
以下

00:49:35.370 --> 00:49:40.740
右暂停，这是发布管道

00:49:38.070 --> 00:49:43.590
然后想订阅该权利

00:49:40.740 --> 00:49:45.390
所以看看那有多干净

00:49:43.590 --> 00:49:47.010
实际部署我们首先要说的是

00:49:45.390 --> 00:49:51.120
创建服务实例（如果有） 

00:49:47.010 --> 00:49:54.090
缺少然后完成此操作

00:49:51.120 --> 00:49:58.530
然后，因为这正在产生价值

00:49:54.090 --> 00:50:00.180
现在订阅好，记得我们告诉过

00:49:58.530 --> 00:50:03.420
它不会启动它，所以我们实际上需要

00:50:00.180 --> 00:50:04.890
现在重新启动它，我们需要开始

00:50:03.420 --> 00:50:06.870
应用程序，但实际上

00:50:04.890 --> 00:50:08.460
需要绑定服务，所以我们推

00:50:06.870 --> 00:50:10.920
应用程序，但目前有

00:50:08.460 --> 00:50:12.870
没有迹象表明该应用程序

00:50:10.920 --> 00:50:18.110
应该绑定到服务，所以我们

00:50:12.870 --> 00:50:25.130
需要说然后绑定应用程序

00:50:18.110 --> 00:50:27.900
服务实例和应用程序

00:50:25.130 --> 00:50:31.140
应先输入名称，然后再输入

00:50:27.900 --> 00:50:35.460
服务名称第二个好吧

00:50:31.140 --> 00:50:37.680
让我们在这里创建该方法好吧

00:50:35.460 --> 00:50:38.940
在这里，我们将使用

00:50:37.680 --> 00:50:42.390
再说一次操作

00:50:38.940 --> 00:50:44.640
返回这个点操作点我

00:50:42.390 --> 00:50:47.280
我想我们想为您服务

00:50:44.640 --> 00:50:52.890
在以下位置绑定查找服务实例请求

00:50:47.280 --> 00:50:55.170
生成器，在这里我们将使用

00:50:52.890 --> 00:51:00.590
服务实例名称服务实例

00:50:55.170 --> 00:51:00.590
命名应用名称应用名称

00:51:00.770 --> 00:51:03.770
然后

00:51:04.960 --> 00:51:09.590
那好吧

00:51:07.580 --> 00:51:11.360
然后我们需要确认，所以我猜我们

00:51:09.590 --> 00:51:14.420
可以吗

00:51:11.360 --> 00:51:16.310
就像现在在这里

00:51:14.420 --> 00:51:17.990
得到一个空的单声道吧

00:51:16.310 --> 00:51:19.700
它会完成，但我们必须

00:51:17.990 --> 00:51:21.980
看着他们听一听

00:51:19.700 --> 00:51:23.510
例如终止出版商，而我

00:51:21.980 --> 00:51:25.280
想要我想要继续处理

00:51:23.510 --> 00:51:28.160
这样，而不是在这里终止

00:51:25.280 --> 00:51:30.380
与一个空的基于空的单声道我想

00:51:28.160 --> 00:51:34.550
实际上是再次切换，所以我只是

00:51:30.380 --> 00:51:37.130
要返回一个你知道布尔值是真的

00:51:34.550 --> 00:51:38.780
确认一切都和我们一样

00:51:37.130 --> 00:51:39.890
期望真实是好的，因为如果我们

00:51:38.780 --> 00:51:41.210
没有真正注意到的事情是

00:51:39.890 --> 00:51:43.130
对，这也很好，因为

00:51:41.210 --> 00:51:44.720
这是发布商可以拥有的价值

00:51:43.130 --> 00:51:45.980
省略，这实际上是我们想要的

00:51:44.720 --> 00:51:48.470
为了能够继续链接

00:51:45.980 --> 00:51:50.840
这个和其他的肉汤一起加工

00:51:48.470 --> 00:51:58.300
马无信退还金银模型

00:51:50.840 --> 00:52:01.910
好吧好吧转弯那里我们很好

00:51:58.300 --> 00:52:04.790
所以有我们的单声道，我们可以继续

00:52:01.910 --> 00:52:05.950
链接，因此将服务绑定到应用程序

00:52:04.790 --> 00:52:08.540
所以我们要说推送应用程序

00:52:05.950 --> 00:52:11.240
然后将服务实例绑定到

00:52:08.540 --> 00:52:13.250
应用程序，那么现在我们需要重新启动

00:52:11.240 --> 00:52:14.770
服务正确，所以重新启动

00:52:13.250 --> 00:52:19.970
应用程序，所以重新启动

00:52:14.770 --> 00:52:21.890
应用程序名称，这是

00:52:19.970 --> 00:52:23.330
也很容易，所以创建

00:52:21.890 --> 00:52:27.680
方法，它将是布尔值的单声道

00:52:23.330 --> 00:52:32.030
就像以前一样，我要去

00:52:27.680 --> 00:52:35.710
说我们转向运营点应用

00:52:32.030 --> 00:52:40.220
点，我们启动，我们启动应用程序

00:52:35.710 --> 00:52:44.830
请求构建器点名称，这是

00:52:40.220 --> 00:52:48.470
应用名称，因此在这里我们完成了构建和

00:52:44.830 --> 00:52:52.340
然后返回布尔值的单点

00:52:48.470 --> 00:52:54.110
真的和以前一样好，现在我们

00:52:52.340 --> 00:52:56.420
可以再次改变它，所以我们要说

00:52:54.110 --> 00:52:58.940
如果缺少该服务，则创建该服务

00:52:56.420 --> 00:53:00.350
公开推送应用程序然后绑定

00:52:58.940 --> 00:53:02.330
服务实例的应用

00:53:00.350 --> 00:53:04.760
然后重新启动应用程序，然后

00:53:02.330 --> 00:53:10.100
最终一旦我们有一个在这种情况下

00:53:04.760 --> 00:53:13.160
你会知道我们最后的真实价值吗

00:53:10.100 --> 00:53:14.810
收到一次，我们实际上并没有

00:53:13.160 --> 00:53:16.500
关心，但这就是那就是那

00:53:14.810 --> 00:53:19.050
将会是

00:53:16.500 --> 00:53:20.190
从此阶段输出的发射值

00:53:19.050 --> 00:53:22.350
管道正确，所以我们可以

00:53:20.190 --> 00:53:24.150
实际上只是在其他地方称它为X 

00:53:22.350 --> 00:53:29.070
可以像Scala这样的语言

00:53:24.150 --> 00:53:30.510
例如下划线，那么您知道X我们

00:53:29.070 --> 00:53:32.760
无法做到这一点，但X可以

00:53:30.510 --> 00:53:35.550
好吧，我想就是这样

00:53:32.760 --> 00:53:37.590
有点有趣

00:53:35.550 --> 00:53:41.490
流程，让我们继续运行并

00:53:37.590 --> 00:53:49.350
首先看看我们还好吧，让我们

00:53:41.490 --> 00:53:54.320
继续前进，看看CF的CF团队s- f 

00:53:49.350 --> 00:53:54.320
我的续集，所以我要删除它

00:53:55.520 --> 00:54:04.700
好的，现在应该部署

00:54:02.040 --> 00:54:08.160
此应用程序应该

00:54:04.700 --> 00:54:09.120
部署两个实例的应用程序和

00:54:08.160 --> 00:54:11.520
记住会发生什么

00:54:09.120 --> 00:54:13.440
把那个罐子拿走-是的

00:54:11.520 --> 00:54:15.630
会将应用程序推送到

00:54:13.440 --> 00:54:17.010
平台，但不会开始

00:54:15.630 --> 00:54:18.390
知道平台会看到

00:54:17.010 --> 00:54:20.310
传入的罐子，它将创建一个

00:54:18.390 --> 00:54:21.750
从那个罐子里拿出来的容器

00:54:20.310 --> 00:54:23.940
放下一个文件系统，它拥有一切

00:54:21.750 --> 00:54:25.860
需要阅读才能运行该程序

00:54:23.940 --> 00:54:31.260
在这种情况下包括jdk的应用程序

00:54:25.860 --> 00:54:32.760
一个JVM，你会知道

00:54:31.260 --> 00:54:34.350
检查传入的工件，所以不要

00:54:32.760 --> 00:54:36.540
知道这是一个Java应用程序

00:54:34.350 --> 00:54:39.210
点瓶，如果我们要上传点波形

00:54:36.540 --> 00:54:41.220
它将下载apache tomcat，如果

00:54:39.210 --> 00:54:43.590
那是Ruby和rails，或者你知道

00:54:41.220 --> 00:54:44.790
或它会做的任何事情

00:54:43.590 --> 00:54:46.080
正确的东西在那里，但是在

00:54:44.790 --> 00:54:48.240
这种情况是点罐子

00:54:46.080 --> 00:54:50.550
只是Java jar，所以它将下载JDK 

00:54:48.240 --> 00:54:51.660
在这种情况下，它将是JDK 8或

00:54:50.550 --> 00:54:53.310
无论最新和最伟大的是什么

00:54:51.660 --> 00:54:55.770
默认情况下在托管上受支持

00:54:53.310 --> 00:54:58.290
平台，顺便说一句，我认为

00:54:55.770 --> 00:54:59.550
对使用Java 9的初步支持

00:54:58.290 --> 00:55:00.720
覆盖构建包，那就是

00:54:59.550 --> 00:55:05.460
我们可以指定的东西

00:55:00.720 --> 00:55:07.440
如果我们现在想非常具体

00:55:05.460 --> 00:55:08.850
首先要做所有的事情

00:55:07.440 --> 00:55:11.630
创建一个文件系统

00:55:08.850 --> 00:55:15.770
把它放进一个容器里

00:55:11.630 --> 00:55:19.550
如果我们告诉它，它将开始

00:55:15.770 --> 00:55:22.530
供应它，你知道

00:55:19.550 --> 00:55:25.020
部署在整个集群中

00:55:22.530 --> 00:55:27.150
案件花了我们20抱歉73毫秒

00:55:25.020 --> 00:55:30.750
所以73秒和73点

00:55:27.150 --> 00:55:33.060
六秒钟，如果我们看着这个，你可以

00:55:30.750 --> 00:55:35.850
看我的续集在那儿吗

00:55:33.060 --> 00:55:38.070
绑定到名为st app SF或CF的此应用程序

00:55:35.850 --> 00:55:43.770
这是apps命令， 

00:55:38.070 --> 00:55:51.000
应用，如果我们去找你，你会知道像

00:55:43.770 --> 00:55:53.640
好Spring 的提示好吧，那些

00:55:51.000 --> 00:55:55.590
现在已部署云资金应用程序

00:55:53.640 --> 00:55:57.510
我们在这里所做的是我们知道

00:55:55.590 --> 00:55:59.190
我们必须交配一些你

00:55:57.510 --> 00:56:02.100
可以进行四到五行打击

00:55:59.190 --> 00:56:04.860
仅用130种左右的Java 

00:56:02.100 --> 00:56:06.660
现在的代码会更好，你知道我们

00:56:04.860 --> 00:56:08.520
可以不同意或者我们可以

00:56:06.660 --> 00:56:11.790
当然可以讨论，但是

00:56:08.520 --> 00:56:13.440
关键是这是更容易维护的权利

00:56:11.790 --> 00:56:14.670
你可以看一下这段代码，你可以改变

00:56:13.440 --> 00:56:17.250
你可以做更多互动的事情

00:56:14.670 --> 00:56:19.740
有了它，您也可以做很多事

00:56:17.250 --> 00:56:21.600
您可以安排的更复杂的事情

00:56:19.740 --> 00:56:23.190
发生某些事情的例子

00:56:21.600 --> 00:56:24.510
您可以询问状态并存储

00:56:23.190 --> 00:56:26.010
事物和变量更多

00:56:24.510 --> 00:56:29.550
一种自然的方式

00:56:26.010 --> 00:56:31.320
 bash，您可以在此基础上构建工具

00:56:29.550 --> 00:56:32.370
对，没有理由你不能

00:56:31.320 --> 00:56:34.470
建立整个连续交付

00:56:32.370 --> 00:56:36.990
管道，然后对此进行编程

00:56:34.470 --> 00:56:38.790
不，你不是，你不动

00:56:36.990 --> 00:56:41.370
您周围的基础设施就是您

00:56:38.790 --> 00:56:43.020
使用API​​是为了创建api，因此

00:56:41.370 --> 00:56:45.390
就像我说的那样给你很大的力量

00:56:43.020 --> 00:56:47.730
像拥有可运送物品的想法

00:56:45.390 --> 00:56:50.370
基于Spring Shell的应用程序

00:56:47.730 --> 00:56:52.170
知道你可以把它连续

00:56:50.370 --> 00:56:54.510
您可以说交付管道正确-- 

00:56:52.170 --> 00:56:56.700
副本等于五，然后

00:56:54.510 --> 00:56:57.960
将其指向罐子，然后他们会做

00:56:56.700 --> 00:56:59.580
其余的它确切地知道是什么

00:56:57.960 --> 00:57:01.260
需要确保这个东西是

00:56:59.580 --> 00:57:02.850
正确运行并经过反复试验

00:57:01.260 --> 00:57:04.440
经过验证的解决方案，您也可以使用

00:57:02.850 --> 00:57:06.030
这在你的烟雾测试中，你知道要

00:57:04.440 --> 00:57:07.530
确保端到端的作品

00:57:06.030 --> 00:57:10.020
启动并运行这是非常简单的

00:57:07.530 --> 00:57:12.930
例子，但是如您所见，API有很多

00:57:10.020 --> 00:57:14.040
力量，您可以做所有事情

00:57:12.930 --> 00:57:15.930
您可以从CF命令行执行

00:57:14.040 --> 00:57:16.950
在某些情况下甚至更正确

00:57:15.930 --> 00:57:20.850
因为你可以在低层次

00:57:16.950 --> 00:57:25.920
然后将api用于聚合

00:57:20.850 --> 00:57:28.380
 CF CLI很好

00:57:25.920 --> 00:57:29.420
非常感谢您的收看，我们会

00:57:28.380 --> 00:57:31.480
下次见

00:57:29.420 --> 00:57:31.480
您

00:57:38.779 --> 00:57:40.839
您

