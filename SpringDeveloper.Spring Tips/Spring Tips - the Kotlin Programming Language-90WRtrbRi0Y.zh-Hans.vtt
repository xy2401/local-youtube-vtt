WEBVTT
Kind: captions
Language: zh-Hans

00:00:13.750 --> 00:00:17.920
嘿，今天的 Spring 歌迷，我们要

00:00:16.390 --> 00:00:21.039
快速的外观，顺便说一句我应该

00:00:17.920 --> 00:00:22.810
在Kotlin迅速强调这个词

00:00:21.039 --> 00:00:25.539
编程语言的重点

00:00:22.810 --> 00:00:26.680
这期是要看它

00:00:25.539 --> 00:00:29.199
看起来很简单

00:00:26.680 --> 00:00:31.869
棉花和与

00:00:29.199 --> 00:00:34.030
 Spring 和短篇小说带走了

00:00:31.869 --> 00:00:36.370
我会继续破坏它

00:00:34.030 --> 00:00:37.989
几乎没有什么额外的你

00:00:36.370 --> 00:00:40.270
需要了解四月才能

00:00:37.989 --> 00:00:42.160
能够与Spring 一起使用，因为它

00:00:40.270 --> 00:00:44.770
只是适合那些你们

00:00:42.160 --> 00:00:46.030
不知道Kotlin是基于JBM的

00:00:44.770 --> 00:00:47.739
编程语言来自

00:00:46.030 --> 00:00:49.929
从它的释放

00:00:47.739 --> 00:00:51.609
来自JetBrains的人们，他们已经

00:00:49.929 --> 00:00:53.890
发布了这种单独的语言

00:00:51.609 --> 00:00:55.359
自然地作为一种语言

00:00:53.890 --> 00:00:57.690
由JetBrains的人们开发

00:00:55.359 --> 00:00:59.920
具有一流的整合

00:00:57.690 --> 00:01:01.870
 IntelliJ，但有一些插件

00:00:59.920 --> 00:01:04.300
允许您以其他ID使用它

00:01:01.870 --> 00:01:06.640
以及事实上我可能会误会

00:01:04.300 --> 00:01:08.020
但我认为德国人实际上

00:01:06.640 --> 00:01:10.680
开发了Eclipse插件，我

00:01:08.020 --> 00:01:14.979
觉得很棒

00:01:10.680 --> 00:01:17.770
因此 Spring ， 

00:01:14.979 --> 00:01:19.810
它是一个JVM公民，自然工作

00:01:17.770 --> 00:01:22.330
这些都可以

00:01:19.810 --> 00:01:25.330
 JVM上支持的语言

00:01:22.330 --> 00:01:28.120
注释和对象正确，如果

00:01:25.330 --> 00:01:30.370
您正在使用Scala，如果

00:01:28.120 --> 00:01:32.500
您正在使用可以正常进行的销售

00:01:30.370 --> 00:01:33.880
如果使用groovy可以正常工作，如果

00:01:32.500 --> 00:01:36.190
使用科特曼，所以今天我们要

00:01:33.880 --> 00:01:38.230
快看一下Kotlin好吧

00:01:36.190 --> 00:01:40.480
所以我们要打造美丽的棉花

00:01:38.230 --> 00:01:44.920
这里的例子，我将建立一个网站

00:01:40.480 --> 00:01:46.180
我将与MongoDB交谈的应用程序

00:01:44.920 --> 00:01:47.260
认为那是你知道我们不会

00:01:46.180 --> 00:01:49.090
今天花了太长时间，所以我们将建立一个

00:01:47.260 --> 00:01:50.470
简单的应用程序，但为了得到

00:01:49.090 --> 00:01:52.450
 cotman支持，您需要切换到

00:01:50.470 --> 00:01:54.220
完整版，然后在这里下到

00:01:52.450 --> 00:01:56.770
语言部分正确等等

00:01:54.220 --> 00:01:58.840
在这里我们可以看到三个很好的支持

00:01:56.770 --> 00:02:01.210
你知道开箱即用的语言

00:01:58.840 --> 00:02:02.800
要在这里选择科特曼，那就是

00:02:01.210 --> 00:02:04.540
其他一切都一样吗

00:02:02.800 --> 00:02:06.130
否则在这里我们不需要改变

00:02:04.540 --> 00:02:08.349
做其他特别的事情，我们会打

00:02:06.130 --> 00:02:10.690
生成，我们将获得一个zip文件

00:02:08.349 --> 00:02:12.849
我们可以在我们的IDE中打开它

00:02:10.690 --> 00:02:15.519
我要使用IntelliJ 

00:02:12.849 --> 00:02:17.860
它可以正常工作和其他语言

00:02:15.519 --> 00:02:19.120
是他们的ID，但我不知道

00:02:17.860 --> 00:02:21.159
对你说实话

00:02:19.120 --> 00:02:23.620
经验是一件事就是棉花

00:02:21.159 --> 00:02:26.350
这些天变得非常流行

00:02:23.620 --> 00:02:27.390
只是获得了一流的

00:02:26.350 --> 00:02:28.710
支持中

00:02:27.390 --> 00:02:31.530
在Gradle构建工具中，因此您现在可以

00:02:28.710 --> 00:02:33.570
使用Kotlin编写Gradle构建文件

00:02:31.530 --> 00:02:36.030
和卡特曼已经很久没有了

00:02:33.570 --> 00:02:38.310
在Android上得到很好的支持，这往往会

00:02:36.030 --> 00:02:40.560
落后一两代

00:02:38.310 --> 00:02:43.590
 JVM互操作性，因此您可以编写

00:02:40.560 --> 00:02:46.440
在Java上运行的Kotlin程序之一

00:02:43.590 --> 00:02:48.870
例如Android上的七个

00:02:46.440 --> 00:02:50.760
非常非常酷，因为Kotlin是

00:02:48.870 --> 00:02:52.560
实际上是Java的j的超集

00:02:50.760 --> 00:02:54.270
语言语法权利不是

00:02:52.560 --> 00:02:57.090
不是所有功能都一​​样

00:02:54.270 --> 00:02:58.650
如果您要比较复选框

00:02:57.090 --> 00:03:00.720
通过复选框您将获得的与众不同的地方

00:02:58.650 --> 00:03:03.750
与Java相比，您会发现有一些

00:03:00.720 --> 00:03:05.820
 Kotlin和and and还有更多美好之处

00:03:03.750 --> 00:03:07.890
毫无疑问，Java时代肯定是

00:03:05.820 --> 00:03:09.930
取得进步，Java 9看起来像一个

00:03:07.890 --> 00:03:11.280
向前迈出了不错的一步，依此类推，但是

00:03:09.930 --> 00:03:12.959
许多令人兴奋的功能

00:03:11.280 --> 00:03:15.480
关于Java路线图中的Java 

00:03:12.959 --> 00:03:16.920
喜欢有类型的可能性

00:03:15.480 --> 00:03:20.220
对变量的推论

00:03:16.920 --> 00:03:21.480
 Val和var已经存在

00:03:20.220 --> 00:03:23.400
常见的，它已经在那里，而且

00:03:21.480 --> 00:03:26.760
工作，它可以使用它并运行

00:03:23.400 --> 00:03:29.670
罚款旧的虚拟机，所以有

00:03:26.760 --> 00:03:30.660
如果您愿意，没有理由延迟

00:03:29.670 --> 00:03:32.989
发挥这些功能，让我们开始吧

00:03:30.660 --> 00:03:35.850
向前看这里的应用程序

00:03:32.989 --> 00:03:38.580
我们要打开Kotlin

00:03:35.850 --> 00:03:40.560
应用程序，它只是一个KT文件而已

00:03:38.580 --> 00:03:43.519
 IntelliJ内部和第一件事

00:03:40.560 --> 00:03:46.019
你看是我们有一个主要方法

00:03:43.519 --> 00:03:48.330
在课外定义

00:03:46.019 --> 00:03:50.610
可能有点，可能有点

00:03:48.330 --> 00:03:52.080
对于那些

00:03:50.610 --> 00:03:53.519
您习惯Java， 

00:03:52.080 --> 00:03:56.010
独立功能在这里

00:03:53.519 --> 00:03:58.950
无需限制范围

00:03:56.010 --> 00:04:00.480
一个特定的阶级另一件事

00:03:58.950 --> 00:04:03.239
您可能会注意到这是打开钥匙

00:04:00.480 --> 00:04:04.560
词，这是一个要求，当

00:04:03.239 --> 00:04:06.750
你在用Spring ，所以当你在

00:04:04.560 --> 00:04:09.060
你用Spring 常识

00:04:06.750 --> 00:04:11.220
几乎你要做的一切

00:04:09.060 --> 00:04:13.590
在棉花世界中开放和开放意味着

00:04:11.220 --> 00:04:17.130
那班不是最后的

00:04:13.590 --> 00:04:19.680
默认说类和函数

00:04:17.130 --> 00:04:21.330
在Cottman中相当于Java 

00:04:19.680 --> 00:04:25.110
最后的关键词被密封在那里

00:04:21.330 --> 00:04:27.120
他们不是要成为子类，而是你

00:04:25.110 --> 00:04:28.169
必须要显式切换

00:04:27.120 --> 00:04:29.550
该行为，所以这是默认行为

00:04:28.169 --> 00:04:32.580
而在Java中，一切都打开了

00:04:29.550 --> 00:04:33.750
必须使用final将其锁定在棉花中

00:04:32.580 --> 00:04:36.330
一切都已锁定，您必须

00:04:33.750 --> 00:04:37.800
将其打开以使其全部打开

00:04:36.330 --> 00:04:40.169
您必须这样做的原因是

00:04:37.800 --> 00:04:40.940
因为 Spring 为了做好工作

00:04:40.169 --> 00:04:42.080
如

00:04:40.940 --> 00:04:44.630
依赖注入容器

00:04:42.080 --> 00:04:46.360
提供的服务可以创造很多

00:04:44.630 --> 00:04:48.740
代理，这些代理基于

00:04:46.360 --> 00:04:50.930
您知道代理通常基于

00:04:48.740 --> 00:04:53.090
我们动态子类化或

00:04:50.930 --> 00:04:54.680
正确的类型，如果我们不能这样做

00:04:53.090 --> 00:04:56.420
您的方法是最终的，所以您将

00:04:54.680 --> 00:04:58.400
如果您要

00:04:56.420 --> 00:05:01.220
使您所有的Java代码最终定稿

00:04:58.400 --> 00:05:02.960
你会发现工作中遇到麻烦

00:05:01.220 --> 00:05:03.980
 Spring 也在那里，这是

00:05:02.960 --> 00:05:04.940
不太 Spring ，我的意思是其他

00:05:03.980 --> 00:05:09.140
做任何形式的框架

00:05:04.940 --> 00:05:10.880
像冬眠者一样的倒影

00:05:09.140 --> 00:05:13.010
几乎所有东西都会有麻烦

00:05:10.880 --> 00:05:15.020
具有这些类型，因此开放

00:05:13.010 --> 00:05:16.970
是默认值，那是我认为

00:05:15.020 --> 00:05:18.680
一点多余的话

00:05:16.970 --> 00:05:21.310
当您移动到此位置时，将会通过

00:05:18.680 --> 00:05:23.300
通用语言，但这是一个

00:05:21.310 --> 00:05:25.730
总的来说，我认为这是一种非常简洁的语言

00:05:23.300 --> 00:05:26.780
因此，让我们继续尝试，我们将

00:05:25.730 --> 00:05:29.270
继续并构建一个简单的应用程序

00:05:26.780 --> 00:05:31.550
我们将有一个实体，一个开放实体

00:05:29.270 --> 00:05:33.350
实际上是数据实体

00:05:31.550 --> 00:05:35.780
我们将创建一个类型

00:05:33.350 --> 00:05:39.800
创建一个叫做人的类型

00:05:35.780 --> 00:05:47.410
人是我们想要的阶级权利

00:05:39.800 --> 00:05:50.210
实现，但是这个类是一个

00:05:47.410 --> 00:05:51.470
只是一个POJO，它将拥有D 

00:05:50.210 --> 00:05:53.840
有在商店中的字段

00:05:51.470 --> 00:05:55.580
使用Spring数据MongoDB的数据库和

00:05:53.840 --> 00:05:59.450
所以虽然我可以上一堂课

00:05:55.580 --> 00:06:01.910
这样我真正想要的是我想要一个

00:05:59.450 --> 00:06:03.890
有字段的类，我要吸气剂

00:06:01.910 --> 00:06:05.210
和二传手，我想一些

00:06:03.890 --> 00:06:06.740
构造函数，我想要两个字符串

00:06:05.210 --> 00:06:09.350
方法和复制方法，我要全部

00:06:06.740 --> 00:06:10.820
这样的东西，所以考夫曼有

00:06:09.350 --> 00:06:12.260
特殊实体的特殊种类

00:06:10.820 --> 00:06:16.460
所谓的数据类

00:06:12.260 --> 00:06:18.500
类权利，因此数据类非常

00:06:16.460 --> 00:06:20.450
他们期望构造函数和

00:06:18.500 --> 00:06:22.520
所以这也是另一个区别

00:06:20.450 --> 00:06:25.820
您在J和

00:06:22.520 --> 00:06:27.590
 Java与更现代的jvm语言

00:06:25.820 --> 00:06:29.300
是我们可以在

00:06:27.590 --> 00:06:31.310
类定义权是主要的

00:06:29.300 --> 00:06:33.470
构造函数辅助构造函数

00:06:31.310 --> 00:06:35.419
另一种形式，但对于数据类，我们

00:06:33.470 --> 00:06:37.160
这是非常方便的

00:06:35.419 --> 00:06:38.300
构造函数，我们可以定义字段

00:06:37.160 --> 00:06:41.690
那是预期的，所以我要说

00:06:38.300 --> 00:06:43.760
我期望一个可变的领域

00:06:41.690 --> 00:06:46.300
名字和一个可变字段

00:06:43.760 --> 00:06:52.400
 ID的可变字段中的姓氏

00:06:46.300 --> 00:06:54.050
好在卡林，这是你必须去的

00:06:52.400 --> 00:06:54.680
使事情变得易变

00:06:54.050 --> 00:06:57.199
对

00:06:54.680 --> 00:06:58.610
默认情况下，所有内容都是不可变的，因此，如果

00:06:57.199 --> 00:07:01.070
您想表达一个价值可以是

00:06:58.610 --> 00:07:03.949
更改后，您必须使用特定类型的

00:07:01.070 --> 00:07:06.199
前缀var而不能是

00:07:03.949 --> 00:07:08.600
改变后一直不变

00:07:06.199 --> 00:07:10.250
初始化是Val对，所以这

00:07:08.600 --> 00:07:13.280
这是一个等同于说

00:07:10.250 --> 00:07:14.600
 final int我等于10对，你可以

00:07:13.280 --> 00:07:18.560
它永远是10，你不能

00:07:14.600 --> 00:07:21.190
一旦初始化就更改它

00:07:18.560 --> 00:07:24.680
我们希望这是一个我们希望这是

00:07:21.190 --> 00:07:26.360
可变并附带Kotlin数据

00:07:24.680 --> 00:07:28.580
类将为我们创建一个二传手

00:07:26.360 --> 00:07:30.740
好，这也改变了产生的东西

00:07:28.580 --> 00:07:33.350
由编译器自动为我们

00:07:30.740 --> 00:07:36.169
我们将创建一个名为var的变量

00:07:33.350 --> 00:07:38.479
字段，然后在

00:07:36.169 --> 00:07:41.150
变量名对，这很漂亮

00:07:38.479 --> 00:07:43.190
通用约定pascal约定

00:07:41.150 --> 00:07:45.110
为事物命名，所以我们要说

00:07:43.190 --> 00:07:48.020
现在我们有了一个名字

00:07:45.110 --> 00:07:49.550
可能不正确var与您不同

00:07:48.020 --> 00:07:52.280
知道它可能会改变的事实是

00:07:49.550 --> 00:07:55.099
与可能的想法不同

00:07:52.280 --> 00:07:58.940
不，所以我们需要说

00:07:55.099 --> 00:08:00.650
可以为null，因此我们将使用它

00:07:58.940 --> 00:08:03.320
这个问号运算符来表示

00:08:00.650 --> 00:08:05.240
好的，那我们要保存我们的最后一个

00:08:03.320 --> 00:08:07.580
我们会说这也是一个字符串

00:08:05.240 --> 00:08:10.250
问号等于null，然后我们

00:08:07.580 --> 00:08:12.460
要创建一个ID，以便ID和我们的字符串

00:08:10.250 --> 00:08:14.840
你知道这又是另一个字符串

00:08:12.460 --> 00:08:17.900
好吧，我们现在知道我在做什么

00:08:14.840 --> 00:08:20.060
说我在这里有三个领域

00:08:17.900 --> 00:08:21.949
优先和ID 

00:08:20.060 --> 00:08:25.220
这些都是可变的，他们可能会改变

00:08:21.949 --> 00:08:28.190
也许在那里改变类型的字符串和

00:08:25.220 --> 00:08:30.380
他们有正确的默认值，所以我

00:08:28.190 --> 00:08:32.150
将Knowle分配给他们，但您可以

00:08:30.380 --> 00:08:33.950
给他们分配你知道一些任意的

00:08:32.150 --> 00:08:35.839
正确的字符串可能是

00:08:33.950 --> 00:08:37.849
在这种情况下将是默认值

00:08:35.839 --> 00:08:40.279
但这对我们来说就足够了

00:08:37.849 --> 00:08:41.930
离开它就在右边，所以我们

00:08:40.279 --> 00:08:44.630
这就是我们所需要的

00:08:41.930 --> 00:08:46.970
今天要做的第一件事你很有用

00:08:44.630 --> 00:08:48.290
定义这个类，我们可以将其注释为

00:08:46.970 --> 00:08:50.420
我们会别的，所以我们要

00:08:48.290 --> 00:08:53.779
将其设为ID字段，我们将调用

00:08:50.420 --> 00:08:54.230
这是一个 spring data 文件，还可以

00:08:53.779 --> 00:08:55.339
我们去

00:08:54.230 --> 00:08:57.529
我们不必执行任何代码生成

00:08:55.339 --> 00:08:59.089
智能内无命令

00:08:57.529 --> 00:09:00.320
生成获取器和设置器，以及

00:08:59.089 --> 00:09:02.300
构造函数以及字符串方法和

00:09:00.320 --> 00:09:04.040
等于方法刚完成的所有工作

00:09:02.300 --> 00:09:05.900
我们，现在我们可以从事

00:09:04.040 --> 00:09:07.640
实际使用数据库的过程

00:09:05.900 --> 00:09:09.680
我将创建一个

00:09:07.640 --> 00:09:12.500
对，就像通常情况下对

00:09:09.680 --> 00:09:14.630
人员资料库 spring data 人员

00:09:12.500 --> 00:09:16.070
仓库，我要继承

00:09:14.630 --> 00:09:18.769
 Jaypee储存库就是为了做到这一点

00:09:16.070 --> 00:09:21.790
并使用冒号运算符

00:09:18.769 --> 00:09:25.190
子类型和子类型的统一语法

00:09:21.790 --> 00:09:27.470
接口的实现，所以我会说

00:09:25.190 --> 00:09:29.870
 JP仓库，而不是Mongo仓库

00:09:27.470 --> 00:09:33.170
对不起，Mongo实体存储库

00:09:29.870 --> 00:09:36.260
主键是类型的类型人

00:09:33.170 --> 00:09:37.880
字符串，然后就可以了

00:09:36.260 --> 00:09:40.010
对，我什至不必这样做

00:09:37.880 --> 00:09:42.050
虽然事实上我可能会

00:09:40.010 --> 00:09:43.850
让我们继续讨论

00:09:42.050 --> 00:09:48.470
接口定义在这里，所以我

00:09:43.850 --> 00:09:54.110
都会说有趣，我会回来

00:09:48.470 --> 00:09:56.660
返回一个正确的人流，这个

00:09:54.110 --> 00:09:58.519
当然只是Java JDK 8流

00:09:56.660 --> 00:10:00.769
您在JDK中可以做的一切

00:09:58.519 --> 00:10:02.720
在这里，我也将使用自定义查询

00:10:00.769 --> 00:10:04.250
归还一切，我们在那里

00:10:02.720 --> 00:10:06.019
我的界面非常简单

00:10:04.250 --> 00:10:07.880
 Spring 的数据将为我和

00:10:06.019 --> 00:10:10.519
现在实施我接下来要做的是

00:10:07.880 --> 00:10:12.260
我想创建一些示例数据

00:10:10.519 --> 00:10:15.230
我想放一些样本数据，然后

00:10:12.260 --> 00:10:18.560
使用该样本数据来了解

00:10:15.230 --> 00:10:20.540
可以合作的东西，所以我们继续

00:10:18.560 --> 00:10:23.230
并实施命令行运行程序

00:10:20.540 --> 00:10:26.120
对，这是我的命令行运行器

00:10:23.230 --> 00:10:27.620
合同，您可以看到我需要

00:10:26.120 --> 00:10:29.360
覆盖此方法，我已经覆盖了

00:10:27.620 --> 00:10:31.699
从命令行运行方法

00:10:29.360 --> 00:10:34.730
为了做我的工作，我需要

00:10:31.699 --> 00:10:37.040
一个人的资料库，所以我会说

00:10:34.730 --> 00:10:40.100
人库人库

00:10:37.040 --> 00:10:41.899
现在是构造函数参数

00:10:40.100 --> 00:10:45.010
你知道我现在告诉 Spring 

00:10:41.899 --> 00:10:47.320
希望将该依赖项作为

00:10:45.010 --> 00:10:50.600
构造函数参数，当然在

00:10:47.320 --> 00:10:52.940
 spring 4.3是spring boot 1.4 

00:10:50.600 --> 00:10:54.529
正在使用，我们甚至不需要提供

00:10:52.940 --> 00:10:56.329
该权利的自动白色注释

00:10:54.529 --> 00:10:57.529
所以这将正常工作，这是

00:10:56.329 --> 00:11:00.079
相当于我创建了一个

00:10:57.529 --> 00:11:02.360
配置类创建了一个独占

00:11:00.079 --> 00:11:03.970
构造函数，然后将其保留为

00:11:02.360 --> 00:11:05.779
是你不知道与

00:11:03.970 --> 00:11:06.740
参数，我什至不必

00:11:05.779 --> 00:11:08.600
定义字段的权利

00:11:06.740 --> 00:11:10.579
 Spring 会后悔棉花，会给

00:11:08.600 --> 00:11:12.050
我可以将变量作为字段

00:11:10.579 --> 00:11:14.180
然后在我的方法内部引用

00:11:12.050 --> 00:11:16.120
这一步的人有仓库等所有

00:11:14.180 --> 00:11:19.220
这些东西有用，所以让我们继续前进， 

00:11:16.120 --> 00:11:21.920
迭代一些名称，我们将创建

00:11:19.220 --> 00:11:30.370
我会说一些样本记录

00:11:21.920 --> 00:11:34.899
菲尔·韦伯·戴夫父亲斯宾塞·吉布

00:11:30.370 --> 00:11:49.389
好吧，我们这里只有一些名字

00:11:34.899 --> 00:11:50.870
布莱恩·克拉夫（Brian Clough）的《塞巴斯蒂昂·德·卢兹·马克（Leb Sebastiao de Luz Marc）》 

00:11:49.389 --> 00:11:52.550
费舍尔我们在那里

00:11:50.870 --> 00:11:53.569
所以我们有一些记录，还有我

00:11:52.550 --> 00:11:55.550
想做的就是你知道我要

00:11:53.569 --> 00:11:57.620
访问每条记录，所以这又是一个

00:11:55.550 --> 00:12:00.139
仔细检查每个名字的好机会

00:11:57.620 --> 00:12:01.670
我要映射它，在这里你可以看到

00:12:00.139 --> 00:12:02.990
 map方法期望它是

00:12:01.670 --> 00:12:04.970
与您期望的相同的地图方法

00:12:02.990 --> 00:12:07.009
从Java 8开始，但我已经足够通过了

00:12:04.970 --> 00:12:11.149
功能，我不需要提供

00:12:07.009 --> 00:12:12.860
括号，因此地图语法（如果我

00:12:11.149 --> 00:12:14.899
想要我可以打印就可以

00:12:12.860 --> 00:12:16.790
带有隐式参数的东西

00:12:14.899 --> 00:12:18.649
对，这实际上是我的lambda 

00:12:16.790 --> 00:12:20.899
要提供它没有它有一个

00:12:18.649 --> 00:12:22.939
参数称为I t 

00:12:20.899 --> 00:12:26.449
我可以给它默认的隐式参数

00:12:22.939 --> 00:12:28.610
我可以说FN首先适合

00:12:26.449 --> 00:12:30.230
资产姓氏，然后我可以定界

00:12:28.610 --> 00:12:32.899
来自其余部分的参数块

00:12:30.230 --> 00:12:35.180
通过使用方法lambda块

00:12:32.899 --> 00:12:38.990
我说的箭头语法FN我是

00:12:35.180 --> 00:12:42.410
通过将FN分解成地图

00:12:38.990 --> 00:12:44.209
最后声明的一半正确

00:12:42.410 --> 00:12:46.459
你知道那种表达

00:12:44.209 --> 00:12:47.420
该块是由什么返回的

00:12:46.459 --> 00:12:50.480
这样我就不必显式地

00:12:47.420 --> 00:12:52.670
返回任何东西，所以有然后

00:12:50.480 --> 00:12:54.829
我要去拜访每一个人

00:12:52.670 --> 00:12:57.889
其中之一记录了两个极点，如果

00:12:54.829 --> 00:13:00.380
你会喜欢这样，我想保存

00:12:57.889 --> 00:13:03.800
存储库中的一些数据，所以我会说

00:13:00.380 --> 00:13:06.860
我不需要创建新的新人

00:13:03.800 --> 00:13:09.439
我只是说一个人然后我

00:13:06.860 --> 00:13:14.899
写一些记录，所以名字

00:13:09.439 --> 00:13:16.370
是0名字的元组吗？ 

00:13:14.899 --> 00:13:21.350
姓氏是姓氏

00:13:16.370 --> 00:13:22.550
之一，ID自动

00:13:21.350 --> 00:13:23.660
提供给我们正确的Spring 数据将

00:13:22.550 --> 00:13:25.279
为我们做到这一点，所以我们不需要

00:13:23.660 --> 00:13:27.319
实现那是另一回事

00:13:25.279 --> 00:13:29.750
关于这些可选的默认

00:13:27.319 --> 00:13:31.069
参数就像有多个

00:13:29.750 --> 00:13:32.240
我可以使用不同的构造函数

00:13:31.069 --> 00:13:34.100
有一个占用一个字段的构造函数

00:13:32.240 --> 00:13:34.820
或采用两个字段的构造函数或

00:13:34.100 --> 00:13:36.890
两个构造

00:13:34.820 --> 00:13:38.000
拿了所有三个，这只是暗示

00:13:36.890 --> 00:13:40.310
对我们来说

00:13:38.000 --> 00:13:41.540
我们不只有一种

00:13:40.310 --> 00:13:43.760
这里的构造函数，我们不必担心

00:13:41.540 --> 00:13:44.780
关于提供所有这些重载和

00:13:43.760 --> 00:13:48.040
所有这些为我们完成的事情

00:13:44.780 --> 00:13:50.780
通过拥有共同点而自动完成，现在我

00:13:48.040 --> 00:13:53.330
可以访问我的存储库，我可以说

00:13:50.780 --> 00:13:54.320
让我们找到所有记录，甚至

00:13:53.330 --> 00:13:59.120
最好让我们把它们全部找到

00:13:54.320 --> 00:14:01.490
消费者作为流，我将去参观

00:13:59.120 --> 00:14:04.930
现在将其打印在正确的位置

00:14:01.490 --> 00:14:09.380
正如我所说的，这种情况是

00:14:04.930 --> 00:14:11.060
 lambda的参数，以防万一

00:14:09.380 --> 00:14:13.670
我数据库中有任何现有数据

00:14:11.060 --> 00:14:15.200
我会全部删除，现在可以

00:14:13.670 --> 00:14:16.820
已经注意到一些默认类型

00:14:15.200 --> 00:14:19.970
在这里返回，例如在无效

00:14:16.820 --> 00:14:22.120
 Java这个Java无效

00:14:19.970 --> 00:14:24.410
自动完成

00:14:22.120 --> 00:14:25.520
我们被认为是单位

00:14:24.410 --> 00:14:30.770
对，所以这是默认设置

00:14:25.520 --> 00:14:32.420
 Kotlin就是这样谈论虚无

00:14:30.770 --> 00:14:34.910
Kotlin有特别的收藏作为

00:14:32.420 --> 00:14:37.580
好吧，你可以说收藏让我

00:14:34.910 --> 00:14:41.110
可以在这里尝试地图，这样Kotlin点

00:14:37.580 --> 00:14:44.000
收集这些稍微多一点

00:14:41.110 --> 00:14:46.460
方便的类型已针对

00:14:44.000 --> 00:14:48.410
与Kotlin程序的互动

00:14:46.460 --> 00:14:51.560
基于基本类型和

00:14:48.410 --> 00:14:52.940
在JDK内部，所以您知道是否可以

00:14:51.560 --> 00:14:56.930
如果不能的话用那些很棒的东西

00:14:52.940 --> 00:14:58.880
嗯，就是这样，让我们​​开始吧

00:14:56.930 --> 00:15:02.240
向前并开始它现在我们在

00:14:58.880 --> 00:15:04.370
现在在43行

00:15:02.240 --> 00:15:06.680
代码，您显然知道

00:15:04.370 --> 00:15:08.630
代码并没有真正告诉您很多

00:15:06.680 --> 00:15:11.030
关于程序的优点或

00:15:08.630 --> 00:15:12.620
复杂程度或其他任何我想要的

00:15:11.030 --> 00:15:15.800
你有点欣赏这是什么

00:15:12.620 --> 00:15:18.260
看起来像是Java，然后如果

00:15:15.800 --> 00:15:20.660
如果您了解Kotlin sidon语法，那么

00:15:18.260 --> 00:15:22.670
快进，你知道从哪一两天

00:15:20.660 --> 00:15:26.060
现在，您就可以表达

00:15:22.670 --> 00:15:27.260
自己在文字评论中会吗

00:15:26.060 --> 00:15:28.520
能够编辑去不得不了解

00:15:27.260 --> 00:15:29.840
这里发生了什么，我会争辩

00:15:28.520 --> 00:15:31.550
是的，我会争辩说，即使

00:15:29.840 --> 00:15:33.320
您正在使用常规Java 

00:15:31.550 --> 00:15:35.270
而且您之前在之前都没有看到评论

00:15:33.320 --> 00:15:36.500
所有您将能够快速添加

00:15:35.270 --> 00:15:38.990
一眼就知道这里发生了什么

00:15:36.500 --> 00:15:40.160
因为你减少了

00:15:38.990 --> 00:15:41.990
你只需要你甚至没有

00:15:40.160 --> 00:15:43.940
上下滚动真的是我的意思是

00:15:41.990 --> 00:15:46.100
一直向下滚动II仍然适合

00:15:43.940 --> 00:15:48.040
和代码页中的所有内容

00:15:46.100 --> 00:15:50.739
让我们继续运行

00:15:48.040 --> 00:15:52.029
我们将使用我们拥有的Kotlin 

00:15:50.739 --> 00:15:54.759
创建一个您知道IntelliJ不

00:15:52.029 --> 00:15:56.230
有没有完全按照我的意愿做

00:15:54.759 --> 00:15:58.660
喜欢它做它正在尝试运行它

00:15:56.230 --> 00:16:00.850
作为Java应用程序，所以我会说好的

00:15:58.660 --> 00:16:03.819
然后我会说我会运行这个

00:16:00.850 --> 00:16:06.339
作为一个Cottman应用程序，所以

00:16:03.819 --> 00:16:07.720
创建这个，你知道

00:16:06.339 --> 00:16:09.369
 Spring 佛陀的智力支持

00:16:07.720 --> 00:16:12.220
是相当不错的事情之一

00:16:09.369 --> 00:16:15.639
默认情况下启用它会

00:16:12.220 --> 00:16:16.869
确保如果您有网站

00:16:15.639 --> 00:16:18.100
阻止端口的应用程序

00:16:16.869 --> 00:16:19.389
例如，它将杀死现有的生产线

00:16:18.100 --> 00:16:21.309
然后重新开始，我们没有这个

00:16:19.389 --> 00:16:23.589
一直以来冲突气氛很差，所以我

00:16:21.309 --> 00:16:28.230
要说只有一个实例我要去

00:16:23.589 --> 00:16:28.230
点击应用，然后我们将运行它

00:16:38.040 --> 00:16:45.170
现在编译是一个可以说是

00:16:40.830 --> 00:16:47.130
在Kotlin慢一点，这是事实， 

00:16:45.170 --> 00:16:49.140
现在看来， 

00:16:47.130 --> 00:16:51.300
尽管时间过长

00:16:49.140 --> 00:16:53.010
通常非常非常快，实际上

00:16:51.300 --> 00:16:57.180
考虑到所有额外的语法，真的很快

00:16:53.010 --> 00:17:00.030
 Kotlin支持，但我看到了

00:16:57.180 --> 00:17:02.730
很棒的博客，如果我能找到它，我会

00:17:00.030 --> 00:17:04.320
将其链接到YouTube视频中，但我看到了一个

00:17:02.730 --> 00:17:09.600
前一周也有很棒的博客

00:17:04.320 --> 00:17:13.380
关于Cotton的编译速度等等

00:17:09.600 --> 00:17:17.010
衡量其效果如何

00:17:13.380 --> 00:17:22.699
与长期的项目，所以实际上你

00:17:17.010 --> 00:17:22.699
可以使用Cottman并运行该应用程序

00:17:27.280 --> 00:17:31.700
我们去了，所以我们的记录是正确的

00:17:29.590 --> 00:17:33.200
有我们的有我们的数据有所有

00:17:31.700 --> 00:17:35.710
我数据库中的记录

00:17:33.200 --> 00:17:40.180
现在在我的应用程序中

00:17:35.710 --> 00:17:47.330
我不需要的嵌入式Web服务器

00:17:40.180 --> 00:17:48.500
所以摆脱它，总是开始

00:17:47.330 --> 00:17:50.540
只是看看是否有一点

00:17:48.500 --> 00:17:55.160
快一点，因为现在看来

00:17:50.540 --> 00:17:56.390
爬行你的一件事

00:17:55.160 --> 00:17:58.070
知道这里值得关注的是

00:17:56.390 --> 00:18:01.700
我们有Kotlin标准实验室

00:17:58.070 --> 00:18:03.770
这基本上就是

00:18:01.700 --> 00:18:05.540
 spring boot 初始化为你做

00:18:03.770 --> 00:18:08.600
当您像这样使用Kotlin时， 

00:18:05.540 --> 00:18:09.830
在这里添加Maven插件并添加

00:18:08.600 --> 00:18:11.930
标准库，所以我已经完成了

00:18:09.830 --> 00:18:14.120
我的环境没有设置

00:18:11.930 --> 00:18:15.410
任何自定义的JDK是我不是我不是

00:18:14.120 --> 00:18:17.360
做任何事情，这完全是一个

00:18:15.410 --> 00:18:19.310
我的Maven构建的功能，所以任何人

00:18:17.360 --> 00:18:23.330
可以编译他们不需要的代码

00:18:19.310 --> 00:18:24.740
设置自定义SDK或自定义路径，或者

00:18:23.330 --> 00:18:26.720
他们刚刚做过一些清洁工作

00:18:24.740 --> 00:18:27.860
安装，使其完美中断

00:18:26.720 --> 00:18:30.650
与生态系统的其余部分

00:18:27.860 --> 00:18:32.900
团队的其他成员等等

00:18:30.650 --> 00:18:34.610
你知道的科特兰图书馆可能很棒

00:18:32.900 --> 00:18:38.710
打包罐子，然后可以重复使用

00:18:34.610 --> 00:18:38.710
等等，让我们看看发生了什么

00:18:38.800 --> 00:18:44.120
有我们的记录就有我们的数据

00:18:41.720 --> 00:18:47.270
一切似乎都快乐得多，所以在那里

00:18:44.120 --> 00:18:49.610
我们去，现在有一个应用程序

00:18:47.270 --> 00:18:54.140
开始将数据写入数据库

00:18:49.610 --> 00:18:55.940
在枚举数据之内等等

00:18:54.140 --> 00:18:58.400
这样我们现在就很干净了

00:18:55.940 --> 00:19:01.460
我们知道这是一种语言，看起来非常

00:18:58.400 --> 00:19:03.020
使用Java或电影的熟悉的临时工

00:19:01.460 --> 00:19:04.160
或其他任何东西，我希望你能给

00:19:03.020 --> 00:19:06.620
一枪，真的很棒

00:19:04.160 --> 00:19:07.880
推荐Kotlin的东西

00:19:06.620 --> 00:19:10.190
谈到这里，我们专门

00:19:07.880 --> 00:19:11.060
您可能想知道什么时候的事情

00:19:10.190 --> 00:19:13.520
与 spring boot 一起使用

00:19:11.060 --> 00:19:15.650
应用程序，但正如我所说的那样

00:19:13.520 --> 00:19:17.330
您知道非常好的语法功能

00:19:15.650 --> 00:19:19.430
除了类型推断

00:19:17.330 --> 00:19:22.820
对于路线图的讨论来自

00:19:19.430 --> 00:19:26.240
 Java除了真正的

00:19:22.820 --> 00:19:28.340
复杂的类型系统和分类

00:19:26.240 --> 00:19:30.380
对可变性的默认支持等等

00:19:28.340 --> 00:19:32.300
在上面还有一些其他的优点

00:19:30.380 --> 00:19:33.950
例如扩展功能

00:19:32.300 --> 00:19:36.410
可以实际将功能添加到任何

00:19:33.950 --> 00:19:37.820
事实之后的任意类型

00:19:36.410 --> 00:19:39.130
说盖亚语，例如，如果您想

00:19:37.820 --> 00:19:43.540
添加一个

00:19:39.130 --> 00:19:45.730
佛陀的拳法也许是

00:19:43.540 --> 00:19:47.290
更改JDK是字符串的方式

00:19:45.730 --> 00:19:52.030
你可以说功能的课堂作品

00:19:47.290 --> 00:19:54.990
字符串点美化，然后说返回

00:19:52.030 --> 00:19:57.820
或你不需要返回美丽

00:19:54.990 --> 00:20:02.440
这个权利，现在你在任何地方都有

00:19:57.820 --> 00:20:06.760
如果我正确的话，你可以说嘘

00:20:02.440 --> 00:20:11.410
那就是内置的

00:20:06.760 --> 00:20:12.730
到默认的字符串类排序

00:20:11.410 --> 00:20:14.530
现在就可以处理所有代码

00:20:12.730 --> 00:20:16.210
现在您可以使用便捷的方法

00:20:14.530 --> 00:20:18.190
而不是将它们分开

00:20:16.210 --> 00:20:20.080
随播对象，您可以执行此操作

00:20:18.190 --> 00:20:22.750
也可以顺便说一句

00:20:20.080 --> 00:20:24.130
可以看到您可以具有

00:20:22.750 --> 00:20:26.350
也都是独立的，这是另一个

00:20:24.130 --> 00:20:28.780
很好，你可以知道你可以

00:20:26.350 --> 00:20:31.630
模拟纯粹的事物

00:20:28.780 --> 00:20:33.010
功能位，然后分享很多

00:20:31.630 --> 00:20:35.800
更自然地代替鞋拔

00:20:33.010 --> 00:20:37.750
他们采取这种方法

00:20:35.800 --> 00:20:39.550
我不能为你工作

00:20:37.750 --> 00:20:42.210
会把这个包起来，我下次见

00:20:39.550 --> 00:20:42.210
时间非常感谢

00:20:50.210 --> 00:20:52.270
您

