WEBVTT
Kind: captions
Language: zh-Hans

00:00:25.290 --> 00:00:29.440
 iSpring粉丝欢迎来到另一个

00:00:27.220 --> 00:00:30.400
在此安装Spring 提示

00:00:29.440 --> 00:00:33.400
分期付款，我们将看看

00:00:30.400 --> 00:00:34.630
 Spring Boot Maven插件正确，所以我们

00:00:33.400 --> 00:00:35.710
要在这里建立一个新的应用程序

00:00:34.630 --> 00:00:37.150
一个真正关心它的演示并不是真的

00:00:35.710 --> 00:00:40.000
不管应用程序是什么

00:00:37.150 --> 00:00:41.020
添加到网络支持中，我猜是

00:00:40.000 --> 00:00:42.010
其他一切都将独自离开

00:00:41.020 --> 00:00:43.510
因为我们不会转发你

00:00:42.010 --> 00:00:45.309
充满活力，如我们所愿

00:00:43.510 --> 00:00:48.220
在我们要使用的插件上

00:00:45.309 --> 00:00:51.040
用于构建它，所以让我们打开我们的

00:00:48.220 --> 00:00:54.750
终端，然后打开

00:00:51.040 --> 00:00:54.750
应用这里我们

00:00:57.270 --> 00:01:01.120
所以让我们打开ID 

00:00:59.890 --> 00:01:03.310
我本来可以选择的常规行家

00:01:01.120 --> 00:01:05.350
摇篮和相同的事物适用于

00:01:03.310 --> 00:01:07.600
摇篮世界，但我会留给你

00:01:05.350 --> 00:01:10.930
是你知道的运动吗

00:01:07.600 --> 00:01:13.810
文档研究有点像

00:01:10.930 --> 00:01:16.860
类似物我们所有的东西

00:01:13.810 --> 00:01:18.940
可以在这里谈论同样适用

00:01:16.860 --> 00:01:20.440
所以我们有简单的应用程序

00:01:18.940 --> 00:01:21.700
同样，这并不重要

00:01:20.440 --> 00:01:24.280
应用程序本身并不实际

00:01:21.700 --> 00:01:27.310
我们可以创建一个 rest controller 

00:01:24.280 --> 00:01:32.500
例如，只说获取映射即可

00:01:27.310 --> 00:01:34.780
和字符串嗨返回

00:01:32.500 --> 00:01:36.880
你好，所以这是我的基本

00:01:34.780 --> 00:01:39.330
我们有一个Springwood应用程序构建

00:01:36.880 --> 00:01:42.520
好吧，这是一个 spring boot 

00:01:39.330 --> 00:01:45.039
应用程序是一个jar应用程序

00:01:42.520 --> 00:01:48.490
所谓的胖子和胖子

00:01:45.039 --> 00:01:49.569
有 spring boot Maven插件，并

00:01:48.490 --> 00:01:51.550
了解并欣赏这是什么

00:01:49.569 --> 00:01:57.250
 Maven插件我们应该删除它吗

00:01:51.550 --> 00:02:03.450
第一个权利，所以让我们在这里和CD 

00:01:57.250 --> 00:02:07.350
下载演示maven全新安装

00:02:03.450 --> 00:02:07.350
包装甚至都没关系

00:02:09.509 --> 00:02:13.630
然后我们得到了编译后的代码

00:02:11.830 --> 00:02:15.970
如果我们看目标目录

00:02:13.630 --> 00:02:19.320
在演示jar上是12 KB，但是我

00:02:15.970 --> 00:02:21.520
不能正确运行它没有

00:02:19.320 --> 00:02:25.330
元在工厂，它没有一个

00:02:21.520 --> 00:02:28.750
该meta条目内的清单文件，以及

00:02:25.330 --> 00:02:31.450
该清单将告诉JVM什么

00:02:28.750 --> 00:02:32.500
上课主要是什么

00:02:31.450 --> 00:02:34.660
具有公共静态无效性的类

00:02:32.500 --> 00:02:37.990
具有该信息的主要方法

00:02:34.660 --> 00:02:39.880
 JVM然后可以运行代码，您知道

00:02:37.990 --> 00:02:41.709
没有它就启动我们的应用程序

00:02:39.880 --> 00:02:43.570
只是一个罐子里充满了可能是

00:02:41.709 --> 00:02:45.850
作为库加载到其他库中

00:02:43.570 --> 00:02:48.610
 JVM进程，但并没有结束

00:02:45.850 --> 00:02:51.430
本身构成一个可运行的罐子

00:02:48.610 --> 00:02:53.230
如果您指定主

00:02:51.430 --> 00:02:54.489
手动对其进行分类也是

00:02:53.230 --> 00:02:56.530
一个选项，但您还必须指定

00:02:54.489 --> 00:02:57.700
现在的班级路径这里的班级路径

00:02:56.530 --> 00:03:00.670
无处可寻我是说整个

00:02:57.700 --> 00:03:02.260
目标目录是260 16 KB，但是

00:03:00.670 --> 00:03:03.820
当然，您知道我已经嵌入

00:03:02.260 --> 00:03:05.590
我有Tomcat我有 spring boot 

00:03:03.820 --> 00:03:07.060
启动一个引入Tomcat的网站

00:03:05.590 --> 00:03:09.400
我们知道至少是你知道10 

00:03:07.060 --> 00:03:11.320
兆字节，所以显然不是

00:03:09.400 --> 00:03:13.900
我可以在代码中执行的所有操作

00:03:11.320 --> 00:03:15.880
在这里复制依赖项，我可以使用

00:03:13.900 --> 00:03:22.630
主要依赖插件Maven 

00:03:15.880 --> 00:03:28.989
依赖项复制DIP结尾和C的和是

00:03:22.630 --> 00:03:39.269
那个让我们看看

00:03:28.989 --> 00:03:39.269
 Maven依赖并看到依赖

00:03:39.550 --> 00:03:51.340
哦，难怪一切都没有用

00:03:43.540 --> 00:03:53.970
哈哈哈错误的文件夹让我们看到所有没事

00:03:51.340 --> 00:03:53.970
让我们尝试一下

00:04:00.410 --> 00:04:05.940
我们去了那真是太难了

00:04:03.150 --> 00:04:07.620
依赖性复制了依赖性，您

00:04:05.940 --> 00:04:08.819
可以看到复制了所有这些

00:04:07.620 --> 00:04:10.770
我需要的不同依赖

00:04:08.819 --> 00:04:16.380
将应用程序放入目标

00:04:10.770 --> 00:04:18.600
 / CD目标的斜杠目录和

00:04:16.380 --> 00:04:20.639
然后有一个依赖目录

00:04:18.600 --> 00:04:21.600
在那里您可以看到所需的所有罐子

00:04:20.639 --> 00:04:23.370
运行此应用程序的一切

00:04:21.600 --> 00:04:24.600
里面的东西或所有的东西

00:04:23.370 --> 00:04:26.310
使此应用程序正常运行所需

00:04:24.600 --> 00:04:28.230
对，所以如果我看这个目录

00:04:26.310 --> 00:04:30.150
本身是18兆字节

00:04:28.230 --> 00:04:32.130
整个事情都是正确的，包括网络

00:04:30.150 --> 00:04:34.680
支持，旋转和记录以及所有

00:04:32.130 --> 00:04:36.840
那其他东西很好冬眠

00:04:34.680 --> 00:04:39.110
验证器，是的，所以一切都还好

00:04:36.840 --> 00:04:41.310
所以我们现在有了一个简单的应用程序

00:04:39.110 --> 00:04:43.350
好吧，如果我们想运行它，我们必须

00:04:41.310 --> 00:04:46.740
自己手动指定类路径

00:04:43.350 --> 00:04:48.180
 Java减去CP，然后列出所有

00:04:46.740 --> 00:04:50.460
列出所有的类

00:04:48.180 --> 00:04:54.060
将罐子放在dependi目录中，然后

00:04:50.460 --> 00:04:56.220
给它主要的主要班级

00:04:54.060 --> 00:04:57.690
所以我们离有用很远

00:04:56.220 --> 00:05:02.040
这就是为什么这个Maven插件是如此

00:04:57.690 --> 00:05:05.150
首先，这个插件很有价值

00:05:02.040 --> 00:05:08.010
在三个和一个清单中创建一个meta 

00:05:05.150 --> 00:05:09.750
直到春天在哪里找到启用

00:05:08.010 --> 00:05:11.130
代码，但实际上确实可以

00:05:09.750 --> 00:05:14.130
比实际看到的更多

00:05:11.130 --> 00:05:15.510
将所有其他罐子嵌入

00:05:14.130 --> 00:05:17.850
建立档案，这就是为什么如果我

00:05:15.510 --> 00:05:24.510
再次运行此代码甚至可以清除

00:05:17.850 --> 00:05:28.229
包那里我们去那里我们

00:05:24.510 --> 00:05:30.630
 CD目标我在这里还有另一个罐子， 

00:05:28.229 --> 00:05:32.550
这个罐子是14梅格的右边，那是

00:05:30.630 --> 00:05:35.750
所有库的压缩版本

00:05:32.550 --> 00:05:38.700
我们在这个罐子之前看过的一个

00:05:35.750 --> 00:05:41.400
只需要的独立的东西

00:05:38.700 --> 00:05:45.229
 JVM甚至JDI都没有的JRE 

00:05:41.400 --> 00:05:48.240
意味着一个JRE，就是我的意思是

00:05:45.229 --> 00:05:51.470
罐子本身是独立的，所以

00:05:48.240 --> 00:05:56.940
我可以做Java-jar演示快照jar 

00:05:51.470 --> 00:05:58.979
之所以有效，是因为

00:05:56.940 --> 00:06:01.169
插件配置一切，让我们

00:05:58.979 --> 00:06:05.669
看一下罐子的结构

00:06:01.169 --> 00:06:07.649
明白我的意思，所以演示好吧，我

00:06:05.669 --> 00:06:12.189
应该让我看看我是否

00:06:07.649 --> 00:06:14.199
鹦鹉螺，我们将保留一切

00:06:12.189 --> 00:06:20.099
除了删除你的东西外

00:06:14.199 --> 00:06:23.889
没有我们在这里Jar xvf 

00:06:20.099 --> 00:06:27.099
演示直接，所以现在，如果我们看一下

00:06:23.889 --> 00:06:29.379
目录输出在这里你可以看到

00:06:27.099 --> 00:06:31.869
 jar中的内容包括启动

00:06:29.379 --> 00:06:33.539
 meta F和org当然会忽略这个罐子

00:06:31.869 --> 00:06:41.129
因为那是原始的罐子本身

00:06:33.539 --> 00:06:45.039
 org，如果我们看这棵树，org是

00:06:41.129 --> 00:06:46.659
组织在组织 Spring Framework 启动

00:06:45.039 --> 00:06:48.550
 loader存档，这些都是实际的Java 

00:06:46.659 --> 00:06:50.919
放在我们根源的类

00:06:48.550 --> 00:06:52.839
像我们正常编译的魅力

00:06:50.919 --> 00:06:55.149
如果没有春天，代码就可以了

00:06:52.839 --> 00:06:57.099
启动Maven插件，所以这是代码

00:06:55.149 --> 00:06:58.749
 JVM实际上会正确运行

00:06:57.099 --> 00:07:00.999
这是正确的正确位置

00:06:58.749 --> 00:07:02.289
是的，在正确的地方

00:07:00.999 --> 00:07:07.899
他们中的G找到并加载它

00:07:02.289 --> 00:07:10.149
通常，此代码实际上提供了

00:07:07.899 --> 00:07:13.869
它自己的类流量提供

00:07:10.149 --> 00:07:16.300
它自己的类加载器和自己的想法

00:07:13.869 --> 00:07:18.490
一个jar文件，您可以在这里看到我们

00:07:16.300 --> 00:07:22.059
实际上有一个称为jar文件的类

00:07:18.490 --> 00:07:26.769
这个jar文件类从

00:07:22.059 --> 00:07:28.539
 Java util jar jar文件类

00:07:26.769 --> 00:07:29.559
该jar类的直接替换

00:07:28.539 --> 00:07:31.899
顺便说一句，这很好，因为它

00:07:29.559 --> 00:07:33.939
意味着工具可以使用此

00:07:31.899 --> 00:07:36.879
机制，如果他们想要，它仍然会

00:07:33.939 --> 00:07:40.119
工作正常，但所有这些都可以说这段代码

00:07:36.879 --> 00:07:42.399
描述了自定义类加载器和

00:07:40.119 --> 00:07:46.839
使用罐子和

00:07:42.399 --> 00:07:47.919
该方案支持您看到的嵌套罐子

00:07:46.839 --> 00:07:49.629
在这里，我们在buti'm 

00:07:47.919 --> 00:07:51.399
目录中有我们的类

00:07:49.629 --> 00:07:53.379
实际应用程序本身的代码

00:07:51.399 --> 00:07:55.839
我们写信给你知道我的小憩

00:07:53.379 --> 00:07:57.819
控制器，然后喜

00:07:55.839 --> 00:08:00.519
支持的路径，所以这是

00:07:57.819 --> 00:08:01.990
如果没有你我们会拥有的东西

00:08:00.519 --> 00:08:03.159
知道我们是否没有使用Maven插件

00:08:01.990 --> 00:08:04.990
这些东西将是根源

00:08:03.159 --> 00:08:06.939
这个Lib目录在末尾

00:08:04.990 --> 00:08:08.229
不会在那里，这个库

00:08:06.939 --> 00:08:10.360
目录是所有的类路径

00:08:08.229 --> 00:08:12.249
我们在依赖项中看到的东西

00:08:10.360 --> 00:08:14.559
我运行那个Maven之前的目录

00:08:12.249 --> 00:08:16.479
依赖项复制依赖项命令

00:08:14.559 --> 00:08:17.589
这是所需的类路径

00:08:16.479 --> 00:08:19.060
支持应用程序这是

00:08:17.589 --> 00:08:22.240
应用程序本身以及

00:08:19.060 --> 00:08:25.330
然后回到org目录中

00:08:22.240 --> 00:08:28.150
描述代码的层次结构是

00:08:25.330 --> 00:08:30.490
设计用于支持加载和

00:08:28.150 --> 00:08:34.090
解决并运行应用程序

00:08:30.490 --> 00:08:37.540
在buti'm目录中，因此

00:08:34.090 --> 00:08:40.840
这是一个与之完全不同的方案

00:08:37.540 --> 00:08:42.220
一个你可能习惯了，你可能已经看到

00:08:40.840 --> 00:08:43.990
其他企图让您

00:08:42.220 --> 00:08:46.030
同样的效果，还有超级

00:08:43.990 --> 00:08:47.350
插件和阴影插件uber Java 

00:08:46.030 --> 00:08:48.910
以这种方式插入阴影插件

00:08:47.350 --> 00:08:50.320
这些是不同的Maven插件

00:08:48.910 --> 00:08:53.770
那里试图给你

00:08:50.320 --> 00:08:56.770
独立的罐子，它们都非常

00:08:53.770 --> 00:09:03.310
有趣，但其中大多数我们都有

00:08:56.770 --> 00:09:06.370
发现他们试图将罐子炸成

00:09:03.310 --> 00:09:07.240
一个全局名称空间，您知道

00:09:06.370 --> 00:09:11.140
您很快就会遇到情况

00:09:07.240 --> 00:09:12.820
你有冲突的地方

00:09:11.140 --> 00:09:14.050
自己震撼他们的内容

00:09:12.820 --> 00:09:15.490
罐子爆炸成一个整体

00:09:14.050 --> 00:09:16.840
命名空间，然后发生冲突

00:09:15.490 --> 00:09:18.760
你需要调和那些

00:09:16.840 --> 00:09:20.860
冲突，这很乏味

00:09:18.760 --> 00:09:22.440
你得到像元这样的东西

00:09:20.860 --> 00:09:24.490
基础设施您当然知道

00:09:22.440 --> 00:09:27.010
每个罐子都会有一个

00:09:24.490 --> 00:09:29.290
那里有一些常数，或者只是它们

00:09:27.010 --> 00:09:30.190
可以，你必须调和

00:09:29.290 --> 00:09:33.430
调和那里的差异

00:09:30.190 --> 00:09:36.790
很快就会变得乏味，所以我们

00:09:33.430 --> 00:09:38.590
发现您知道并不难

00:09:36.790 --> 00:09:41.560
支持以此方式进行实际操作

00:09:38.590 --> 00:09:44.650
支持jar中的代码解析

00:09:41.560 --> 00:09:46.770
因为我们在这里，那就是那里

00:09:44.650 --> 00:09:49.210
整个定制方案唯一

00:09:46.770 --> 00:09:52.090
我们的自定义方案的限制是

00:09:49.210 --> 00:09:54.340
如果您正在编写使用

00:09:52.090 --> 00:09:55.270
不会的系统类加载器

00:09:54.340 --> 00:09:57.460
以您期望的方式工作

00:09:55.270 --> 00:10:00.730
相反，您应该使用上下文

00:09:57.460 --> 00:10:02.470
类加载器正确，所以如果您正在编写

00:10:00.730 --> 00:10:03.430
使用类加载器的代码

00:10:02.470 --> 00:10:04.660
了解类加载器，那么您将

00:10:03.430 --> 00:10:06.370
知道那不意味着什么

00:10:04.660 --> 00:10:07.840
太好了，你可能没事吧

00:10:06.370 --> 00:10:10.780
不用最担心

00:10:07.840 --> 00:10:12.580
大多数框架使用的库

00:10:10.780 --> 00:10:14.550
上下文类加载器，所以这是

00:10:12.580 --> 00:10:16.810
这不是您遇到的问题

00:10:14.550 --> 00:10:18.370
除了非常特殊的情况

00:10:16.810 --> 00:10:20.850
但除此之外，这将正常工作

00:10:18.370 --> 00:10:23.140
这实际上是一个独立的罐子

00:10:20.850 --> 00:10:25.480
这颗星星不是你想要的

00:10:23.140 --> 00:10:28.240
放在其他罐子的类路径上

00:10:25.480 --> 00:10:30.520
尽管您知道其他应用程序

00:10:28.240 --> 00:10:32.710
通过以这种方式构建它，您可以

00:10:30.520 --> 00:10:34.960
 JVM很难加载它

00:10:32.710 --> 00:10:36.010
图书馆无法正常工作

00:10:34.960 --> 00:10:37.540
您会期望的，但这很好

00:10:36.010 --> 00:10:41.100
我们试图构建一个应用程序不是

00:10:37.540 --> 00:10:43.300
作为独立的图书馆，所以我们有

00:10:41.100 --> 00:10:45.010
应用程序中的所有内容，以及

00:10:43.300 --> 00:10:47.710
您知道应用程序就可以了

00:10:45.010 --> 00:10:52.570
现在就像你说的，我们可以做到

00:10:47.710 --> 00:10:54.760
工作-jar演示点快照jar我们可以

00:10:52.570 --> 00:10:58.630
覆盖属性，例如端口

00:10:54.760 --> 00:11:01.450
我可以说出口服务器端口档案

00:10:58.630 --> 00:11:08.680
导出服务器下划线端口等于

00:11:01.450 --> 00:11:12.790
 8020，然后互相做一个jar演示

00:11:08.680 --> 00:11:16.390
现在应用程序在端口上旋转

00:11:12.790 --> 00:11:17.980
 80 20对，所以您可以看到我们

00:11:16.390 --> 00:11:19.750
能够更改默认行为我

00:11:17.980 --> 00:11:24.300
在这里可以有一个属性文件

00:11:19.750 --> 00:11:29.530
说回声服务器端口等于t10 

00:11:24.300 --> 00:11:31.720
应用程序属性，然后只有您

00:11:29.530 --> 00:11:37.060
在同一目录中知道并打开它

00:11:31.720 --> 00:11:40.300
再次关闭这个并打开那个

00:11:37.060 --> 00:11:42.280
一个，你可以看到这里我有猫

00:11:40.300 --> 00:11:47.010
应用程序属性，我已经

00:11:42.280 --> 00:11:49.900
 Java罐子-罐子演示罐子和

00:11:47.010 --> 00:11:51.490
我说我想跑到80 80端口

00:11:49.900 --> 00:11:52.810
那个小狗文件，我们在那里，所以我

00:11:51.490 --> 00:11:54.100
能够更改的默认行为

00:11:52.810 --> 00:11:56.140
我能够构建的应用程序

00:11:54.100 --> 00:11:58.120
我需要的独立应用程序

00:11:56.140 --> 00:12:00.010
要做的是管理启动和停止， 

00:11:58.120 --> 00:12:02.680
重新启动并在应用程序中显示状态

00:12:00.010 --> 00:12:04.020
我需要拖尾原木等等

00:12:02.680 --> 00:12:06.640
人们使用的常见原因

00:12:04.020 --> 00:12:09.100
像Tomcat这样的应用服务器

00:12:06.640 --> 00:12:10.690
这是迄今为止最倾斜的

00:12:09.100 --> 00:12:13.180
 Java社区中的应用程序服务器

00:12:10.690 --> 00:12:17.460
和生态系统的原因更多

00:12:13.180 --> 00:12:20.140
人们使用它是因为他们想要

00:12:17.460 --> 00:12:22.780
拥有生命周期管理权

00:12:20.140 --> 00:12:26.520
应用程序本身的生命周期

00:12:22.780 --> 00:12:28.690
开始停止下面的日志等

00:12:26.520 --> 00:12:30.070
在这种情况下，您必须重新发明

00:12:28.690 --> 00:12:32.740
在这种情况下，到目前为止我们还没有

00:12:30.070 --> 00:12:34.420
具有大部分功能， 

00:12:32.740 --> 00:12:36.580
此外，没有简单的方法

00:12:34.420 --> 00:12:39.580
处理这个，你必须要做

00:12:36.580 --> 00:12:42.090
你必须做的当然不是

00:12:39.580 --> 00:12:44.170
痛苦但乏味的工作

00:12:42.090 --> 00:12:45.220
将其作为服务安装在您的

00:12:44.170 --> 00:12:46.270
操作系统（如果正在运行） 

00:12:45.220 --> 00:12:47.860
在生产环境中

00:12:46.270 --> 00:12:51.610
它很有可能会成为某种形式

00:12:47.860 --> 00:12:53.050
是UNIX风格的，所以是Linux，所以您

00:12:51.610 --> 00:12:54.820
想要将其安装为服务

00:12:53.050 --> 00:12:55.900
这样当应用程序运行时

00:12:54.820 --> 00:12:57.610
当环境风化

00:12:55.900 --> 00:12:59.560
启动，它将成为

00:12:57.610 --> 00:13:03.010
当环境

00:12:59.560 --> 00:13:03.940
本身就被摧毁了，所以全部都是一种

00:13:03.010 --> 00:13:04.840
作为读者的练习

00:13:03.940 --> 00:13:08.590
那就是您正在使用的应用程序

00:13:04.840 --> 00:13:10.000
表示我们没有使用服务器的服务器

00:13:08.590 --> 00:13:11.350
嵌入式应用服务器

00:13:10.000 --> 00:13:12.820
网络服务器，所以我们需要解决

00:13:11.350 --> 00:13:16.180
问题自己，这很容易做到

00:13:12.820 --> 00:13:17.830
在这里使用旋转启动配置

00:13:16.180 --> 00:13:20.230
有很多配置选项

00:13:17.830 --> 00:13:23.890
这里是Spring Boot Maven插件

00:13:20.230 --> 00:13:25.630
正确的，您可以指定诸如

00:13:23.890 --> 00:13:27.550
您要运行哪个Java代理自定义

00:13:25.630 --> 00:13:28.810
您要运行的classes目录

00:13:27.550 --> 00:13:32.650
知道要包括哪些工件

00:13:28.810 --> 00:13:34.260
或排除您要指定JMX 

00:13:32.650 --> 00:13:38.650
暴击你知道你不会

00:13:34.260 --> 00:13:40.020
指定您知道的宝石X属性

00:13:38.650 --> 00:13:42.790
您可以在这里做很多不同的事情

00:13:40.020 --> 00:13:44.500
在 spring boot 的Maven插件中

00:13:42.790 --> 00:13:48.370
插件，但我们关心的是

00:13:44.500 --> 00:13:49.570
罐子是否执行

00:13:48.370 --> 00:13:52.120
我们将使其具有执行力或同等水平

00:13:49.570 --> 00:13:53.200
默认情况下为true，这是一个执行器，但

00:13:52.120 --> 00:13:54.970
那跟什么不太一样

00:13:53.200 --> 00:13:59.530
我们在说这是什么

00:13:54.970 --> 00:14:01.750
我们正在建造的是一种新的

00:13:59.530 --> 00:14:04.530
行政罐，所以行家清洁安妮的主要

00:14:01.750 --> 00:14:04.530
清洁包装

00:14:09.550 --> 00:14:18.640
好吧，MMM种子目标现在相同

00:14:13.210 --> 00:14:20.170
基本上像以前的14兆，但

00:14:18.640 --> 00:14:25.330
这是不同的

00:14:20.170 --> 00:14:27.730
没那么对，所以我刚做的就是

00:14:25.330 --> 00:14:31.030
较少的演示零一个快照jar和

00:14:27.730 --> 00:14:33.220
我遇到了一个shell脚本， 

00:14:31.030 --> 00:14:35.050
 shell脚本实际上是第一个

00:14:33.220 --> 00:14:39.520
标头，如果它是第一部分

00:14:35.050 --> 00:14:42.730
 jar档案和标头的内容

00:14:39.520 --> 00:14:43.960
 shell脚本做了很多

00:14:42.730 --> 00:14:46.900
对您而言，它实际上做了很多事情

00:14:43.960 --> 00:14:48.850
东西给你，它会安装一个PID 

00:14:46.900 --> 00:14:54.190
您知道安装目录的目录

00:14:48.850 --> 00:14:55.570
将付费文件存储在您可以看到的地方

00:14:54.190 --> 00:15:00.400
应用程序的状态

00:14:55.570 --> 00:15:02.200
您知道它管理的文件夹将其记录

00:15:00.400 --> 00:15:04.150
管理应用程序的权限

00:15:02.200 --> 00:15:05.890
它本身给你的功能，你

00:15:04.150 --> 00:15:08.050
可以用来查看应用程序是否

00:15:05.890 --> 00:15:10.900
运行你可以说P你知道它是

00:15:08.050 --> 00:15:13.600
例如运行，你知道吗

00:15:10.900 --> 00:15:18.250
这里没有很多支持

00:15:13.600 --> 00:15:20.410
希望你自己阅读所有这些

00:15:18.250 --> 00:15:21.940
但足以说有很多

00:15:20.410 --> 00:15:25.210
启动和停止功能

00:15:21.940 --> 00:15:27.310
和状态查看以及停止和

00:15:25.210 --> 00:15:28.690
强制重新加载并运行

00:15:27.310 --> 00:15:34.300
应用程序，您可以在此处看到所有内容

00:15:28.690 --> 00:15:36.220
命令正确，所以这些命令都是

00:15:34.300 --> 00:15:38.860
支持他们非常有用， 

00:15:36.220 --> 00:15:42.270
他们有用的原因是因为您可以

00:15:38.860 --> 00:15:45.010
将它们与广告结合使用或

00:15:42.270 --> 00:15:49.360
您知道的系统V风格初始化

00:15:45.010 --> 00:15:51.460
因此，脚本是指脚本

00:15:49.360 --> 00:15:53.890
该脚本实际上在

00:15:51.460 --> 00:15:56.110
 JVM以此来运行jar 

00:15:53.890 --> 00:15:57.820
脚本确实是它实际上加载了罐子

00:15:56.110 --> 00:15:59.980
本身对这件外套这本剧本

00:15:57.820 --> 00:16:02.680
然后由操作系统运行

00:15:59.980 --> 00:16:04.540
加载自身，它读取自己的文件并

00:16:02.680 --> 00:16:08.410
加载罐子，罐子当然是

00:16:04.540 --> 00:16:10.480
您在此处看到的二进制数据

00:16:08.410 --> 00:16:13.330
我屏幕上的gobbledygook就是全部

00:16:10.480 --> 00:16:14.920
罐子中的内容编码为

00:16:13.330 --> 00:16:15.940
那和那个shell脚本和

00:16:14.920 --> 00:16:18.490
了解你如何工作

00:16:15.940 --> 00:16:21.340
考虑操作系统如何读取

00:16:18.490 --> 00:16:22.300
操作系统读取的文件权限

00:16:21.340 --> 00:16:23.590
程序的

00:16:22.300 --> 00:16:25.900
内存从顶部开始

00:16:23.590 --> 00:16:28.870
转到EOF文件结尾标记

00:16:25.900 --> 00:16:31.650
对，那只是大多数

00:16:28.870 --> 00:16:34.270
 UNIX操作系统可运行JVM 

00:16:31.650 --> 00:16:38.020
与操作系统杂草相反

00:16:34.270 --> 00:16:39.760
这是我们的档案和应用程序， 

00:16:38.020 --> 00:16:41.980
反转它从末尾读取

00:16:39.760 --> 00:16:44.860
存档直到文件开始

00:16:41.980 --> 00:16:46.120
当然，没有理由

00:16:44.860 --> 00:16:47.200
那两件事必须达成共识

00:16:46.120 --> 00:16:49.530
在开始的时候没有理由

00:16:47.200 --> 00:16:51.610
操作系统文件必须

00:16:49.530 --> 00:16:53.830
与开始处对齐

00:16:51.610 --> 00:16:55.690
实际上，您可以为JVM存档

00:16:53.830 --> 00:16:56.920
如果你保持一些非常有趣的事情

00:16:55.690 --> 00:17:00.910
这些东西分开，这就是我们

00:16:56.920 --> 00:17:02.260
在这里，我们的shell脚本有一个

00:17:00.910 --> 00:17:04.840
文件结束标记

00:17:02.260 --> 00:17:07.300
系统然后读取和shell脚本

00:17:04.840 --> 00:17:10.300
然后读自己，给你你知道的

00:17:07.300 --> 00:17:14.020
它将自己的内容提供给JVM 

00:17:10.300 --> 00:17:15.910
通过从末尾阅读来做到这一点

00:17:14.020 --> 00:17:17.200
外壳脚本

00:17:15.910 --> 00:17:19.540
文件标记的开头是

00:17:17.200 --> 00:17:20.770
你当然知道

00:17:19.540 --> 00:17:23.050
 Shell脚本，它是第一个字节

00:17:20.770 --> 00:17:24.280
在shell脚本之后，你知道

00:17:23.050 --> 00:17:27.910
那里有差异，但是

00:17:24.280 --> 00:17:31.630
现在工作的好处是

00:17:27.910 --> 00:17:33.220
我当然可以做这个演示

00:17:31.630 --> 00:17:35.260
不必说Java-char 

00:17:33.220 --> 00:17:37.030
我只是像

00:17:35.260 --> 00:17:41.800
执行shell脚本对我的操作

00:17:37.030 --> 00:17:43.960
系统我仍然需要一个JVM，但我

00:17:41.800 --> 00:17:46.390
只是我已经具备了这种能力，而我

00:17:43.960 --> 00:17:49.960
现在可以在编织D和

00:17:46.390 --> 00:17:52.560
系统D，所以是一个压区T 

00:17:49.960 --> 00:17:52.560
插入

00:17:54.180 --> 00:18:00.200
好吧，所以你说的确切

00:17:57.420 --> 00:18:06.900
是的，这是一个平静的小摇篮

00:18:00.200 --> 00:18:10.310
配置，您现在可以使用此

00:18:06.900 --> 00:18:16.140
广告或系统精灵就在这里

00:18:10.310 --> 00:18:18.270
你他们去须藤LLNS我的罐子，它说

00:18:16.140 --> 00:18:19.650
它等我的应用程序，然后一次

00:18:18.270 --> 00:18:23.400
这样就可以说服务我的应用程序了

00:18:19.650 --> 00:18:25.410
例如开始，这样你就可以得到

00:18:23.400 --> 00:18:26.580
以以下方式管理应用程序的能力

00:18:25.410 --> 00:18:28.800
操作系统上的服务

00:18:26.580 --> 00:18:29.820
像我的续集或其他任何东西

00:18:28.800 --> 00:18:31.680
您正在作为守护程序运行

00:18:29.820 --> 00:18:33.570
背景，当然还有日志

00:18:31.680 --> 00:18:34.890
写入var日志应用名称

00:18:33.570 --> 00:18:38.340
而且实际上有一种报酬

00:18:34.890 --> 00:18:42.300
由操作系统为您管理

00:18:38.340 --> 00:18:43.470
脚本本身也可以

00:18:42.300 --> 00:18:46.020
告诉操作系统启动

00:18:43.470 --> 00:18:49.950
自动使用更新我们的CD 

00:18:46.020 --> 00:18:51.990
默认优先级等，所以你

00:18:49.950 --> 00:18:53.850
你知道很多事情可以在这里做

00:18:51.990 --> 00:18:56.220
也可以查看文档

00:18:53.850 --> 00:18:58.140
有关如何正确保护它的信息

00:18:56.220 --> 00:18:59.940
仅当它在安全的环境中运行时

00:18:58.140 --> 00:19:02.250
保护过程并具有一定的

00:18:59.940 --> 00:19:04.830
您知道很多保护权限

00:19:02.250 --> 00:19:06.720
选项正确，所以我可以证明

00:19:04.830 --> 00:19:09.930
你自己衡量的一件事我

00:19:06.720 --> 00:19:11.220
真的想知道你要确保

00:19:09.930 --> 00:19:11.820
可以改变一切的感觉

00:19:11.220 --> 00:19:13.620
对

00:19:11.820 --> 00:19:15.150
包括shell脚本本身

00:19:13.620 --> 00:19:17.250
可以提供您自己的自定义外壳脚本

00:19:15.150 --> 00:19:18.270
你甚至可以复制我们的，只有你

00:19:17.250 --> 00:19:21.140
知道可以稍微改变一下

00:19:18.270 --> 00:19:23.280
在此处提供自定义的shell脚本，然后

00:19:21.140 --> 00:19:24.960
提供您自己的嵌入式午餐脚本

00:19:23.280 --> 00:19:28.530
那个长脚本可以做什么你

00:19:24.960 --> 00:19:30.000
现在想要，也许您想覆盖

00:19:28.530 --> 00:19:31.230
只是内部使用的属性

00:19:30.000 --> 00:19:33.030
我们的大型脚本也很好

00:19:31.230 --> 00:19:35.010
你可以在这里做很多选择

00:19:33.030 --> 00:19:36.810
我鼓励您证明这一点并

00:19:35.010 --> 00:19:39.270
稍后进行探索，但对于

00:19:36.810 --> 00:19:43.220
我们的目的，我认为这是一个好习惯

00:19:39.270 --> 00:19:46.830
足够的介绍关于

00:19:43.220 --> 00:19:48.750
这个字符是它是独立的我

00:19:46.830 --> 00:19:52.140
正如我所说的，这是一个独立的

00:19:48.750 --> 00:19:55.290
演示应用程序，我们有

00:19:52.140 --> 00:19:56.610
我们这里有一个终点

00:19:55.290 --> 00:19:58.860
控制器，我们有三行代码

00:19:56.610 --> 00:20:01.950
那需要三行代码

00:19:58.860 --> 00:20:03.720
太空中的18兆字节似乎

00:20:01.950 --> 00:20:05.070
有点不相称，但你确实

00:20:03.720 --> 00:20:08.070
我们刚刚看到的好处

00:20:05.070 --> 00:20:10.980
由于

00:20:08.070 --> 00:20:14.240
它位于所有库中

00:20:10.980 --> 00:20:19.440
应用程序归档二进制文件本身

00:20:14.240 --> 00:20:20.490
那说事情可能会更紧凑

00:20:19.440 --> 00:20:23.280
同意他们可能会更苗条

00:20:20.490 --> 00:20:26.100
有点方便，这是

00:20:23.280 --> 00:20:27.600
如果您开始存档只是一个问题

00:20:26.100 --> 00:20:29.640
这些这些二进制文件和类似的东西

00:20:27.600 --> 00:20:32.160
像您的Nexus存储库工件

00:20:29.640 --> 00:20:34.170
您可能不想在那里存储18 

00:20:32.160 --> 00:20:35.460
每一次兆字节就这样

00:20:34.170 --> 00:20:37.200
只是一个微不足道的应用程序

00:20:35.460 --> 00:20:40.470
甚至开始添加其他东西，所以

00:20:37.200 --> 00:20:42.900
在这种情况下，您可能会喜欢

00:20:40.470 --> 00:20:45.360
您可以立即使用瘦启动器

00:20:42.900 --> 00:20:47.070
薄咒是一个定制的专家

00:20:45.360 --> 00:20:49.470
自定义spring boot maven插件布局

00:20:47.070 --> 00:20:51.510
布局是用于

00:20:49.470 --> 00:20:53.430
 Spring Boot Maven插件，您可以

00:20:51.510 --> 00:20:54.900
覆盖，并且有一些默认值

00:20:53.430 --> 00:20:56.730
布置这个罐子的点线和

00:20:54.900 --> 00:20:58.680
然后有一个新的

00:20:56.730 --> 00:21:01.200
父亲是谁的联合创始人

00:20:58.680 --> 00:21:02.700
 spring boot 和Spring 云都有

00:21:01.200 --> 00:21:05.040
创建了这个叫做 spring boot 

00:21:02.700 --> 00:21:06.710
薄启动器，它是一个你不知道的

00:21:05.040 --> 00:21:10.310
 spring boot 本身的正式一部分

00:21:06.710 --> 00:21:13.260
但这已经非常有用了， 

00:21:10.310 --> 00:21:16.920
你会发现春天的渴望

00:21:13.260 --> 00:21:18.270
启动瘦咒的代码是相当

00:21:16.920 --> 00:21:20.520
很容易上手，所以在这里我们要

00:21:18.270 --> 00:21:21.960
赢了，我们将超越春天

00:21:20.520 --> 00:21:29.040
启动插件在这里，我们要添加这个

00:21:21.960 --> 00:21:35.370
到这里来启动我们的Spring Boot插件

00:21:29.040 --> 00:21:39.690
哎呀不需要这个

00:21:35.370 --> 00:21:43.200
不需要那个，我们需要版本

00:21:39.690 --> 00:21:50.460
是一个不是哦，六个，我想是的1.6 

00:21:43.200 --> 00:21:56.700
发布，所以他们回来了，有一个自定义

00:21:50.460 --> 00:21:58.200
版本和我们的自定义Maven插件

00:21:56.700 --> 00:22:01.350
自己的自定义 spring boot 的布局

00:21:58.200 --> 00:22:04.289
是的，但是布局具有我们的一切

00:22:01.350 --> 00:22:08.240
需要运行应用程序但

00:22:04.289 --> 00:22:11.249
瘦启动布局确实做到了

00:22:08.240 --> 00:22:13.559
安装在二进制文件中

00:22:11.249 --> 00:22:15.539
解决自己的上课道路的能力

00:22:13.559 --> 00:22:17.460
使用Maven使用你知道相同

00:22:15.539 --> 00:22:28.740
 Maven的依赖管理机制

00:22:17.460 --> 00:22:31.980
这里的Maven清洁包CD目标吗

00:22:28.740 --> 00:22:35.039
您-HS演示糟糕，我在那里做了什么

00:22:31.980 --> 00:22:36.600
你介意追逐好吗20 KB 

00:22:35.039 --> 00:22:37.830
对，所以比我们大一点

00:22:36.600 --> 00:22:39.570
在我们第一次有看到

00:22:37.830 --> 00:22:44.070
完全没有插件，但仍然

00:22:39.570 --> 00:22:45.539
很小，如果我们运行这个

00:22:44.070 --> 00:22:47.730
应用程序仍然可以正常工作

00:22:45.539 --> 00:22:49.710
所以Java-快照jar的jarred演示

00:22:47.730 --> 00:22:51.990
我们在那里，你可以看到它，你知道

00:22:49.710 --> 00:22:54.210
该应用程序尽快启动

00:22:51.990 --> 00:22:57.090
我们期望除了它正在解决

00:22:54.210 --> 00:22:58.590
它的类路径（如果现在）是动态的

00:22:57.090 --> 00:23:01.619
现在它正在寻找当地的新兴市场- 

00:22:58.590 --> 00:23:03.119
你知道我当地的M2仓库

00:23:01.619 --> 00:23:04.440
目录，并找到所有

00:23:03.119 --> 00:23:06.659
在那个图书馆

00:23:04.440 --> 00:23:08.610
仓库目录，这是你知道的

00:23:06.659 --> 00:23:10.740
根据需要动态加载

00:23:08.610 --> 00:23:13.590
我可以告诉它加载那些依赖

00:23:10.740 --> 00:23:18.990
在一个单独的班级里我可以说工作

00:23:13.590 --> 00:23:21.450
向上-细点根是我认为的

00:23:18.990 --> 00:23:25.789
没错，我要

00:23:21.450 --> 00:23:25.789
说是的，放下我的星星

00:23:27.500 --> 00:23:43.460
瘦小的荷兰人，我认为那是那条路

00:23:36.620 --> 00:23:46.190
我说那是简历库，你可以看到

00:23:43.460 --> 00:23:48.350
当我说稀薄等于根的时候

00:23:46.190 --> 00:23:50.659
在其中创建了一个名为Lib的目录

00:23:48.350 --> 00:23:51.889
我们看到它的存储库目录

00:23:50.659 --> 00:23:53.779
已经创建了它创建的类路径

00:23:51.889 --> 00:23:55.070
一个基本上有

00:23:53.779 --> 00:23:57.409
运行此程序所需的所有工件

00:23:55.070 --> 00:24:00.019
应用程序，所以它使用了行家

00:23:57.409 --> 00:24:01.970
依赖解析机制

00:24:00.019 --> 00:24:04.250
启动了应用程序

00:24:01.970 --> 00:24:06.110
解决所有依赖项并将其放入

00:24:04.250 --> 00:24:08.330
当然，如果我运行

00:24:06.110 --> 00:24:11.440
你再次知道相同的命令

00:24:08.330 --> 00:24:13.639
完全相同的调用，它不需要

00:24:11.440 --> 00:24:14.600
解决它们就在那里缓存正确

00:24:13.639 --> 00:24:17.899
那就是最初发生的事情

00:24:14.600 --> 00:24:20.299
它运行的时间，我运行了该命令

00:24:17.899 --> 00:24:23.059
相对于本地m2存储库

00:24:20.299 --> 00:24:25.370
目录，然后它正常工作

00:24:23.059 --> 00:24:28.100
所以我在说根等于Lib 

00:24:25.370 --> 00:24:32.240
工作-jar演示完成了一切，哦，见到你

00:24:28.100 --> 00:24:34.669
目标好吧，所以不必再次

00:24:32.240 --> 00:24:36.440
解决任何问题，现在考虑

00:24:34.669 --> 00:24:37.879
您没有的操作系​​统

00:24:36.440 --> 00:24:38.809
类路径上的依赖项

00:24:37.879 --> 00:24:41.360
你在本地机器上什么都没有

00:24:38.809 --> 00:24:44.120
本地m2上没有任何内容

00:24:41.360 --> 00:24:46.519
那时你需要

00:24:44.120 --> 00:24:47.929
互联网连接正确，所以本机

00:24:46.519 --> 00:24:49.250
您显然需要正确下载

00:24:47.929 --> 00:24:52.070
没有它，这是行不通的

00:24:49.250 --> 00:24:53.929
依赖性，从而增加了启动时间

00:24:52.070 --> 00:24:55.190
希望你时间很快

00:24:53.929 --> 00:24:58.429
功能无疑是您在

00:24:55.190 --> 00:25:00.110
生产数据中心，但这是一个成本

00:24:58.429 --> 00:25:02.659
你必须准备支付

00:25:00.110 --> 00:25:06.139
您可以预先将其缓存

00:25:02.659 --> 00:25:07.730
实际上可以分阶段使用

00:25:06.139 --> 00:25:10.070
库，您可以依赖

00:25:07.730 --> 00:25:12.470
如果您愿意的话，请实际进行预检

00:25:10.070 --> 00:25:14.539
在这种情况下，您可以获得所有库

00:25:12.470 --> 00:25:16.879
下载，然后将它们缓存为您

00:25:14.539 --> 00:25:19.039
例如在这里写这样的Java- 

00:25:16.879 --> 00:25:20.840
那根牙齿等于罐子等于我们

00:25:19.039 --> 00:25:22.639
在这里，你知道那样会

00:25:20.840 --> 00:25:28.419
下载所有内容

00:25:22.639 --> 00:25:32.830
您可以通过以下目录进行试运行

00:25:28.419 --> 00:25:36.139
在此指定属性

00:25:32.830 --> 00:25:37.460
等于真实，那实际上

00:25:36.139 --> 00:25:38.960
为您下载依赖项并

00:25:37.460 --> 00:25:40.550
不启动代码，以便您获得

00:25:38.960 --> 00:25:42.050
两全其美，您可以下载

00:25:40.550 --> 00:25:44.180
一切，然后开始

00:25:42.050 --> 00:25:46.250
应用程序保证它会

00:25:44.180 --> 00:25:47.450
当您正确启动它时就可以工作

00:25:46.250 --> 00:25:51.650
好处当然是你

00:25:47.450 --> 00:25:53.030
你能拥有所有的防御能力吗

00:25:51.650 --> 00:25:54.290
需要运行该应用程序，但是您

00:25:53.030 --> 00:25:57.830
不必存储内置的

00:25:54.290 --> 00:26:00.350
具有所有依赖项的应用程序

00:25:57.830 --> 00:26:03.650
包含在工件中，或者或者您知道

00:26:00.350 --> 00:26:05.000
 Nexus资料库只能在

00:26:03.650 --> 00:26:07.340
需要它的容器本身

00:26:05.000 --> 00:26:08.210
或者你可以做所有的事情

00:26:07.340 --> 00:26:10.610
动态地知道你可以

00:26:08.210 --> 00:26:11.690
选择最薄的最小容器

00:26:10.610 --> 00:26:15.620
您的操作系统所需的

00:26:11.690 --> 00:26:18.530
然后只用一个小罐子

00:26:15.620 --> 00:26:19.820
并下载

00:26:18.530 --> 00:26:21.350
依赖您需要的类路径

00:26:19.820 --> 00:26:23.180
对于该应用程序将只工作

00:26:21.350 --> 00:26:24.530
只要您的平台很好

00:26:23.180 --> 00:26:27.890
适用于云的任何技术

00:26:24.530 --> 00:26:30.020
计算不需要

00:26:27.890 --> 00:26:30.890
超时正确，希望您不需要

00:26:30.020 --> 00:26:33.080
渴望下载所有这些

00:26:30.890 --> 00:26:35.240
依赖，如果你能做到

00:26:33.080 --> 00:26:38.030
那个超时那么好

00:26:35.240 --> 00:26:40.670
这个琐碎的Spring Boot应用程序

00:26:38.030 --> 00:26:41.930
我刚建在这里很小

00:26:40.670 --> 00:26:43.850
足够快

00:26:41.930 --> 00:26:44.840
将下载并正常工作

00:26:43.850 --> 00:26:46.340
像云铸造厂

00:26:44.840 --> 00:26:48.290
对，所以如果我要推动

00:26:46.340 --> 00:26:51.830
您可以看到这里的应用程序

00:26:48.290 --> 00:26:54.770
在这里CF Push可能是我的应用减去P 

00:26:51.830 --> 00:26:57.350
目标演示jar，然后指定一个

00:26:54.770 --> 00:26:59.690
构建包，这实际上将上演

00:26:57.350 --> 00:27:01.370
在应用程序尝试执行之前先进行jar 

00:26:59.690 --> 00:27:03.350
启动，所以它是一个插入自身

00:27:01.370 --> 00:27:04.540
终生融入云端

00:27:03.350 --> 00:27:07.450
在应用生命周期内停留在云中

00:27:04.540 --> 00:27:09.740
在应用程序启动之前

00:27:07.450 --> 00:27:11.450
下载所有罐子，然后执行

00:27:09.740 --> 00:27:12.920
做好我的开始，所以你不再

00:27:11.450 --> 00:27:14.600
你不反对那个

00:27:12.920 --> 00:27:17.240
超时，但是即使我只是要做

00:27:14.600 --> 00:27:20.240
 CF推我的应用程序指定此jar和

00:27:17.240 --> 00:27:21.320
忽略您知道的构建

00:27:20.240 --> 00:27:22.550
这个琐碎的应用

00:27:21.320 --> 00:27:24.590
绝对正确，它足够小

00:27:22.550 --> 00:27:28.100
我可以在那个时候完成

00:27:24.590 --> 00:27:29.150
在适用时间之前

00:27:28.100 --> 00:27:31.580
因此您可以使用自定义版本

00:27:29.150 --> 00:27:33.200
打包以解决这个问题，或者你可以

00:27:31.580 --> 00:27:34.760
你知道它是否足够小

00:27:33.200 --> 00:27:36.020
适合，你甚至可能没有

00:27:34.760 --> 00:27:37.520
谁知道我的意思是问题是

00:27:36.020 --> 00:27:39.500
这是一个不错的选择， 

00:27:37.520 --> 00:27:40.850
少数情况下会出现问题

00:27:39.500 --> 00:27:42.140
我能想到的唯一地方

00:27:40.850 --> 00:27:44.270
可能有问题，如果您正在跑步

00:27:42.140 --> 00:27:45.680
启动时超时

00:27:44.270 --> 00:27:47.510
对，因为这必须要做

00:27:45.680 --> 00:27:50.240
程序运行时所有这些我

00:27:47.510 --> 00:27:51.170
想要它何时启动，所以保持

00:27:50.240 --> 00:27:54.500
心里

00:27:51.170 --> 00:27:56.510
而且你知道

00:27:54.500 --> 00:27:58.310
我喜欢瘦的方法

00:27:56.510 --> 00:27:59.630
就像两全其美一样

00:27:58.310 --> 00:28:02.420
也可以做一些有趣的事情，因为

00:27:59.630 --> 00:28:05.750
记得上课的路

00:28:02.420 --> 00:28:07.070
在应用程序外部提供，如果

00:28:05.750 --> 00:28:09.200
您想要的实际上可以提供

00:28:07.070 --> 00:28:10.970
细化属性文件，然后

00:28:09.200 --> 00:28:11.930
包含自己的依赖清单

00:28:10.970 --> 00:28:14.900
正确，这实际上是正在发生的事情

00:28:11.930 --> 00:28:16.870
在这里，如果你看这个字符，让我看看

00:28:14.900 --> 00:28:20.290
你再打开一次

00:28:16.870 --> 00:28:25.250
我只会抓住那个删除的那个

00:28:20.290 --> 00:28:27.130
我会说解压缩你去看看你

00:28:25.250 --> 00:28:31.130
看这里的目录你可以看到

00:28:27.130 --> 00:28:33.710
该目录包含Menem代码

00:28:31.130 --> 00:28:35.690
包含一个薄罐包装类

00:28:33.710 --> 00:28:38.660
反过来正在使这种昏暗

00:28:35.690 --> 00:28:39.890
应用程序和您的Maven Pom 

00:28:38.660 --> 00:28:41.900
使用中的Maven Pom 

00:28:39.890 --> 00:28:43.130
存档以解决依赖关系，但

00:28:41.900 --> 00:28:44.750
您可以在

00:28:43.130 --> 00:28:49.930
您也可以提供自定义格式

00:28:44.750 --> 00:28:54.200
您的自定义预科文件太薄了

00:28:49.930 --> 00:28:56.210
属性正确，所以在这里说

00:28:54.200 --> 00:28:57.890
依赖项Spring Boots Starter Web 

00:28:56.210 --> 00:28:59.120
等于org Spring Framework boot spring 

00:28:57.890 --> 00:29:01.310
引导正确地启动网站，这是

00:28:59.120 --> 00:29:04.190
你是一个外在的削减，你知道习惯

00:29:01.310 --> 00:29:06.020
依赖关系，您可以将其用作

00:29:04.190 --> 00:29:09.260
您可以覆盖课程的课程路径

00:29:06.020 --> 00:29:11.000
应用程序内部的路径

00:29:09.260 --> 00:29:12.710
因此，如果您想升级Spring 

00:29:11.000 --> 00:29:13.610
心情和春天的云，但没有别的

00:29:12.710 --> 00:29:15.770
你知道你想改变

00:29:13.610 --> 00:29:18.020
依赖版本，例如um you 

00:29:15.770 --> 00:29:20.270
可以通过取代炸弹来做到这一点

00:29:18.020 --> 00:29:23.780
部分，所以在这里

00:29:20.270 --> 00:29:25.250
说BMS是 spring boot 专家

00:29:23.780 --> 00:29:27.790
炸毁物料依赖清单

00:29:25.250 --> 00:29:29.930
Spring 启动依赖的炸弹

00:29:27.790 --> 00:29:31.730
等于Oryx带来了免费的mcboot spring 

00:29:29.930 --> 00:29:34.720
启动依赖项1.5乘以6确实如此

00:29:31.730 --> 00:29:37.610
在这里，它将被强制升级

00:29:34.720 --> 00:29:39.830
意识到特殊处罚21.5 

00:29:37.610 --> 00:29:41.390
点六点用Spring 的一切

00:29:39.830 --> 00:29:42.980
靴子炸弹会在春天的木头

00:29:41.390 --> 00:29:45.320
应用程序就是现在的一切

00:29:42.980 --> 00:29:48.050
别着急赢得5.6点

00:29:45.320 --> 00:29:50.810
现在我建议重新编译代码

00:29:48.050 --> 00:29:52.010
在生产代码中执行此操作

00:29:50.810 --> 00:29:53.780
当然不是我意思是你绝对应该

00:29:52.010 --> 00:29:55.400
绝对经历回归

00:29:53.780 --> 00:29:57.020
测试和审核以及所有这些东西

00:29:55.400 --> 00:30:00.310
如果紧要的话，这可能非常方便

00:29:57.020 --> 00:30:04.250
您需要这样做，并且您知道可以

00:30:00.310 --> 00:30:05.600
我们尽力使事情如此

00:30:04.250 --> 00:30:07.550
他们来来回回地工作

00:30:05.600 --> 00:30:08.330
并转发兼容，你知道

00:30:07.550 --> 00:30:11.649
显然我们不

00:30:08.330 --> 00:30:14.179
这与一个巨人，你知道1.56 

00:30:11.649 --> 00:30:19.909
 23.0你知道颠簸之类的东西

00:30:14.179 --> 00:30:21.620
那，但是你会的

00:30:19.909 --> 00:30:22.610
如果你知道的话，你会过得更好

00:30:21.620 --> 00:30:24.380
如果您有安全漏洞

00:30:22.610 --> 00:30:25.880
您需要立即修补

00:30:24.380 --> 00:30:28.070
诸如此类的权利

00:30:25.880 --> 00:30:29.960
方便，所以您有很多选择

00:30:28.070 --> 00:30:31.640
这里有很多选择来运行您的

00:30:29.960 --> 00:30:34.640
 Springwood应用程序，我们再次

00:30:31.640 --> 00:30:36.380
谈到我已经谈到了servlet 

00:30:34.640 --> 00:30:38.120
上一个容器选项

00:30:36.380 --> 00:30:38.840
以前的春季小贴士，那不是什么

00:30:38.120 --> 00:30:41.240
我们正在谈论这里，我们正在谈论

00:30:38.840 --> 00:30:42.200
关于Spring Boot Maven插件和一个

00:30:41.240 --> 00:30:44.769
不同策略的数量

00:30:42.200 --> 00:30:46.850
运行它们还值得注意的是， 

00:30:44.769 --> 00:30:50.269
我展示的所谓的胖子罐子里的东西

00:30:46.850 --> 00:30:51.380
您可以与酒吧一起使用

00:30:50.269 --> 00:30:52.789
我们向您展示的第一种方法

00:30:51.380 --> 00:30:54.260
没有它的Maven插件

00:30:52.789 --> 00:30:55.610
执行官，你可以用一个点

00:30:54.260 --> 00:30:56.929
 Waar以及实际上让您

00:30:55.610 --> 00:30:58.970
两全其美，您可以部署

00:30:56.929 --> 00:31:02.659
进入服务器容器环境

00:30:58.970 --> 00:31:04.220
也做java-jar我的dot wah正确和

00:31:02.659 --> 00:31:05.799
真正进入UM的过程

00:31:04.220 --> 00:31:07.940
在两种环境中都起作用的东西

00:31:05.799 --> 00:31:10.639
所以这里有很多选择

00:31:07.940 --> 00:31:11.690
灵活性现在不是一件事

00:31:10.639 --> 00:31:13.850
在那里，我很想看到

00:31:11.690 --> 00:31:16.370
尤其是今天，he9 Java 

00:31:13.850 --> 00:31:18.559
 9是为此拥有的能力

00:31:16.370 --> 00:31:22.970
对于我们之前看到的shell脚本

00:31:18.559 --> 00:31:25.130
下载我是现代GDK和J的JDK 

00:31:22.970 --> 00:31:27.230
 9i我认为这是

00:31:25.130 --> 00:31:29.539
它提供了模块化，并且

00:31:27.230 --> 00:31:32.179
模块化主要适用于JVM 

00:31:29.539 --> 00:31:33.799
本身，您可以将JVM分解为

00:31:32.179 --> 00:31:35.120
较小的模块，然后您就可以

00:31:33.799 --> 00:31:37.370
重新包装和任何范围，但你

00:31:35.120 --> 00:31:39.590
想要，所以你可以例如建立

00:31:37.370 --> 00:31:42.769
没有代码的JRE 

00:31:39.590 --> 00:31:43.789
科巴很好，你知道我们不是

00:31:42.769 --> 00:31:46.700
在以后应用和使用

00:31:43.789 --> 00:31:49.700
应用程序，以便我们可以将其删除

00:31:46.700 --> 00:31:51.470
可以有一个自定义的可再发行JRE 

00:31:49.700 --> 00:31:54.250
而且我认为Oracle甚至发出信号

00:31:51.470 --> 00:31:58.789
他们希望应用程序能够将

00:31:54.250 --> 00:31:59.929
 JVM和他们期望Java 9 

00:31:58.789 --> 00:32:02.389
工作，我是杰里，要运到

00:31:59.929 --> 00:32:03.620
应用程序，以便使其更容易

00:32:02.389 --> 00:32:04.850
为开发人员提供一致的

00:32:03.620 --> 00:32:06.500
立即体验

00:32:04.850 --> 00:32:08.779
他们会发布很多新的

00:32:06.500 --> 00:32:10.519
每六个月进行一次游戏

00:32:08.779 --> 00:32:13.100
他们要做的事

00:32:10.519 --> 00:32:14.990
一年两次这样的事情

00:32:13.100 --> 00:32:16.520
所以油漆可能很有价值

00:32:14.990 --> 00:32:18.289
您的应用程序到特定的JVM 

00:32:16.520 --> 00:32:20.659
反对依靠任何居民

00:32:18.289 --> 00:32:22.370
 JVM在操作系统上，因此我们将

00:32:20.659 --> 00:32:23.780
看到，我认为那将是一个

00:32:22.370 --> 00:32:25.340
有趣的扩展，你可以做到

00:32:23.780 --> 00:32:26.510
当然可以，因为你

00:32:25.340 --> 00:32:29.390
可以控制启动脚本

00:32:26.510 --> 00:32:30.230
为您提供自己的杰瑞解决方案

00:32:29.390 --> 00:32:33.550
我们实际上可以下载的机制

00:32:30.230 --> 00:32:36.530
自己的而不是Java 

00:32:33.550 --> 00:32:39.590
包含的Java命令检测逻辑

00:32:36.530 --> 00:32:42.230
他们的启动脚本现在就可以了

00:32:39.590 --> 00:32:43.670
这样，我们查看了默认

00:32:42.230 --> 00:32:46.220
 spring boot 和行家的行为

00:32:43.670 --> 00:32:48.230
没有Maven插件的插件，我们得到了

00:32:46.220 --> 00:32:50.300
到一个罐子里，我们看着你怎么能

00:32:48.230 --> 00:32:51.320
如果没有的话，解析类路径

00:32:50.300 --> 00:32:52.820
那个插头，我们看着春天

00:32:51.320 --> 00:32:54.920
启动Maven插件，看到了什么

00:32:52.820 --> 00:32:56.540
默认行为让您了解我们

00:32:54.920 --> 00:32:58.850
一些配置选项和

00:32:56.540 --> 00:33:01.760
看到你可以改变很多

00:32:58.850 --> 00:33:03.980
关于产生的脂肪罐的事情

00:33:01.760 --> 00:33:05.929
使用maven插件，我们还查看了

00:33:03.980 --> 00:33:08.240
高管的所有选择权

00:33:05.929 --> 00:33:09.770
您进入的执行启动脚本

00:33:08.240 --> 00:33:10.970
 UNIX操作系统以及如何

00:33:09.770 --> 00:33:13.580
允许您在以下位置运行应用程序

00:33:10.970 --> 00:33:16.130
系统D和init.d 

00:33:13.580 --> 00:33:19.010
风格的环境，然后我们终于

00:33:16.130 --> 00:33:21.110
看着许多可能之一

00:33:19.010 --> 00:33:22.970
这种布局称为薄

00:33:21.110 --> 00:33:25.850
适用于 spring boot 的布局

00:33:22.970 --> 00:33:28.990
 maven插件，这是Dave的一个项目

00:33:25.850 --> 00:33:32.420
先生博士当我组队时的戴夫下

00:33:28.990 --> 00:33:33.620
成员，然后我们讨论了一些

00:33:32.420 --> 00:33:36.350
如果你用这双鞋的话

00:33:33.620 --> 00:33:38.030
方法和您可能拥有的某些美德

00:33:36.350 --> 00:33:39.559
如果您使用这种方法，那么

00:33:38.030 --> 00:33:42.429
非常感谢您的观看和

00:33:39.559 --> 00:33:42.429
下次见

00:33:49.059 --> 00:33:51.120
您

