WEBVTT
Kind: captions
Language: zh-Hans

00:00:13.680 --> 00:00:17.100
嗨，本周的春季乐队

00:00:15.870 --> 00:00:19.590
我们将要介绍的春季分期提示

00:00:17.100 --> 00:00:22.560
看看我们将继续我们的

00:00:19.590 --> 00:00:24.869
看看春季五的漂亮功能

00:00:22.560 --> 00:00:26.490
特别是新功能

00:00:24.869 --> 00:00:29.490
 spring webflix模块是

00:00:26.490 --> 00:00:32.430
与之相邻的反应式Web层

00:00:29.490 --> 00:00:34.410
春季NBC，但对我们有效并提供支持

00:00:32.430 --> 00:00:37.110
基于它的反应式运行时权限

00:00:34.410 --> 00:00:39.000
项目反应堆和一些表面

00:00:37.110 --> 00:00:40.470
 API，然后在其中进行抽象

00:00:39.000 --> 00:00:42.989
思考事物的方式

00:00:40.470 --> 00:00:45.239
总是对组件模型

00:00:42.989 --> 00:00:48.120
现在使用其中一些与

00:00:45.239 --> 00:00:50.750
您可以在Spring MVC中使用什么以及

00:00:48.120 --> 00:00:53.579
您可能已经关联或可能是

00:00:50.750 --> 00:00:54.840
习惯于春季MVC，但是

00:00:53.579 --> 00:00:56.309
这是不同的，因为当然

00:00:54.840 --> 00:00:59.610
范式的本质是不同的

00:00:56.309 --> 00:01:02.219
一件事是不同的，我认为

00:00:59.610 --> 00:01:05.339
更好的是我们如何消费

00:01:02.219 --> 00:01:07.440
正确的服务是什么

00:01:05.339 --> 00:01:09.899
我们有剩下的模板吗

00:01:07.440 --> 00:01:11.880
春天的webflix，以及我们如何类似

00:01:09.899 --> 00:01:14.039
从客户端测试您是否知道

00:01:11.880 --> 00:01:15.210
透视服务所以为了

00:01:14.039 --> 00:01:18.119
证明我们将要建立一个

00:01:15.210 --> 00:01:19.680
反应性应用程序和

00:01:18.119 --> 00:01:21.000
应用程序将利用

00:01:19.680 --> 00:01:23.640
 Spring Web List模块当然是哪个

00:01:21.000 --> 00:01:26.070
由Spring 5提供

00:01:23.640 --> 00:01:28.110
到夏天为止什么都可以

00:01:26.070 --> 00:01:31.229
我们会满足你自己，你知道满意

00:01:28.110 --> 00:01:33.540
自己使用Spring WA flex 

00:01:31.229 --> 00:01:34.950
模块作为支撑和Spring 引导至

00:01:33.540 --> 00:01:37.470
快照的内容，所以我将

00:01:34.950 --> 00:01:41.400
反应性的网络支持，我来打

00:01:37.470 --> 00:01:42.750
生成并在我们的应用程序中

00:01:41.400 --> 00:01:44.610
要建立一个简单的领域，我

00:01:42.750 --> 00:01:46.409
我不想的帝国域

00:01:44.610 --> 00:01:47.490
花太多时间在实际服务上

00:01:46.409 --> 00:01:51.750
我只想问一些关于

00:01:47.490 --> 00:01:56.280
我们可以知道玩和实验吗

00:01:51.750 --> 00:01:57.509
对，所以这是我们的新服务，我

00:01:56.280 --> 00:01:59.640
总是原谅我要带的

00:01:57.509 --> 00:02:01.650
在龙目岛，因为我确实有一个简单的

00:01:59.640 --> 00:02:03.689
我要创建的实体

00:02:01.650 --> 00:02:09.979
你知道这很乏味，或者为什么我

00:02:03.689 --> 00:02:13.220
手动编写代码，所以说龙目岛

00:02:09.979 --> 00:02:15.209
好吧，现在龙目岛是一个编译时间

00:02:13.220 --> 00:02:18.299
注释处理器

00:02:15.209 --> 00:02:19.980
对我来说，琐碎的事

00:02:18.299 --> 00:02:21.269
我们可以合作的实体

00:02:19.980 --> 00:02:22.709
真的需要我要创建

00:02:21.269 --> 00:02:23.220
客户与服务在同一个

00:02:22.709 --> 00:02:25.109
项目

00:02:23.220 --> 00:02:27.060
在大多数情况下，自然会

00:02:25.109 --> 00:02:28.530
在单独的项目中，但

00:02:27.060 --> 00:02:30.270
我想证明的是重点

00:02:28.530 --> 00:02:31.560
而不是特别如何旋转

00:02:30.270 --> 00:02:33.720
无关的枪骑兵的新项目

00:02:31.560 --> 00:02:36.360
在这里，我要好好服务

00:02:33.720 --> 00:02:41.000
我们去叫反应性的基础项目

00:02:36.360 --> 00:02:49.730
好吧，我们将在这里提供新服务

00:02:41.000 --> 00:02:52.290
和新客户都可以，并且在服务中

00:02:49.730 --> 00:02:57.120
我们想创建一个响应式服务

00:02:52.290 --> 00:02:58.470
应用，因此只是典型的Spring 

00:02:57.120 --> 00:03:02.820
良好的应用Spring 完成

00:02:58.470 --> 00:03:07.440
应用程序，我们将做这个

00:03:02.820 --> 00:03:09.150
 rest controller ，我们将提供

00:03:07.440 --> 00:03:11.640
公共静态void主字符串参数

00:03:09.150 --> 00:03:14.880
我将要使用的回调数组

00:03:11.640 --> 00:03:18.600
说春季应用程序运行反应

00:03:14.880 --> 00:03:20.730
服务应用程序返回类args好

00:03:18.600 --> 00:03:22.620
现在有我们的终点

00:03:20.730 --> 00:03:24.960
有我们最好的身体休息

00:03:22.620 --> 00:03:27.360
挥杆动作到目前为止效果很好

00:03:24.960 --> 00:03:29.790
你知道四处走动谈论

00:03:27.360 --> 00:03:31.950
所以让我们建立一个事件是什么

00:03:29.790 --> 00:03:33.870
事件所有任何类型的DTO对吧

00:03:31.950 --> 00:03:36.300
不太在乎域名，所以

00:03:33.870 --> 00:03:39.090
关闭您可以拥有一个字段的数据

00:03:36.300 --> 00:03:40.500
私人长ID，并且有日期

00:03:39.090 --> 00:03:43.770
因为为什么不

00:03:40.500 --> 00:03:46.860
好了，所以我们走了，那里是我们的三个

00:03:43.770 --> 00:03:49.890
领域，我们可能应该建立一个

00:03:46.860 --> 00:03:52.200
现在所有参数的构造函数都很好

00:03:49.890 --> 00:03:56.160
第一个端点只会传回

00:03:52.200 --> 00:03:58.830
单个事件，其ID正确，因此它将

00:03:56.160 --> 00:04:04.070
一个可以说是潜在的马诺

00:03:58.830 --> 00:04:04.070
无限无限流或无限

00:04:05.480 --> 00:04:13.710
在此有价值的容器对象

00:04:09.690 --> 00:04:19.950
案子只有一项权利，所以它将

00:04:13.710 --> 00:04:25.130
通过ID包含模拟事件，并且

00:04:19.950 --> 00:04:26.880
路径变量将对ID进行编码， 

00:04:25.130 --> 00:04:28.440
我们不会花太多时间

00:04:26.880 --> 00:04:30.330
关于这一点，我想说的只是

00:04:28.440 --> 00:04:32.400
我们只是要硬编码一个新的

00:04:30.330 --> 00:04:33.840
有点正确，所以我什至没有

00:04:32.400 --> 00:04:34.890
甚至没有连接数据库

00:04:33.840 --> 00:04:36.900
分类，因为它真的

00:04:34.890 --> 00:04:37.950
这次我们不在乎

00:04:36.900 --> 00:04:38.810
想要与之合作的东西

00:04:37.950 --> 00:04:40.220
那就是

00:04:38.810 --> 00:04:42.560
这些情况下如何获得一个特定的ID 

00:04:40.220 --> 00:04:45.230
这被称为mano它的值为零或

00:04:42.560 --> 00:04:48.139
一个值，然后另一种情况是

00:04:45.230 --> 00:04:50.930
我们将重新考虑我们的服务， 

00:04:48.139 --> 00:04:52.970
上一部影片中的活动讨论

00:04:50.930 --> 00:04:57.520
我们将创建一个

00:04:52.970 --> 00:05:00.770
每秒都会返回记录，因此

00:04:57.520 --> 00:05:03.320
事件，这将是一个变化

00:05:00.770 --> 00:05:04.669
将是一个返回一个

00:05:03.320 --> 00:05:09.830
潜在的无限数量的值

00:05:04.669 --> 00:05:11.330
是的，所以一连串的事件，我们不会

00:05:09.830 --> 00:05:12.590
想要生成实际事件

00:05:11.330 --> 00:05:15.080
无限权利，我不想称呼

00:05:12.590 --> 00:05:17.419
我想对熵进行排序的数据库

00:05:15.080 --> 00:05:21.530
我将创建一个连续的稳定

00:05:17.419 --> 00:05:22.820
流类型基于调度程序

00:05:21.530 --> 00:05:25.070
我想要的每一秒钟都有一个新

00:05:22.820 --> 00:05:27.290
我想要一个新事件，所以

00:05:25.070 --> 00:05:28.930
为此，我需要建立几个

00:05:27.290 --> 00:05:34.460
事件，因此产生了一些变化

00:05:28.930 --> 00:05:36.410
对于事件本身是正确的，这

00:05:34.460 --> 00:05:40.490
会很容易，因为我会建立一个

00:05:36.410 --> 00:05:41.780
方案我反应一个Java 8流，并在

00:05:40.490 --> 00:05:45.410
为了做到这一点，我可以使用流回

00:05:41.780 --> 00:05:47.870
创建方法在这里生成相当和

00:05:45.410 --> 00:05:50.450
生成方法需要一个供应商， 

00:05:47.870 --> 00:05:52.820
供应商只是希望我退货

00:05:50.450 --> 00:05:56.060
的价值，所以我可以硬编码

00:05:52.820 --> 00:05:57.289
当前时间和日期，然后我们

00:05:56.060 --> 00:06:02.300
那是我的第一个，然后下一个

00:05:57.289 --> 00:06:09.250
我们想要的是持续时间通量，所以

00:06:02.300 --> 00:06:09.250
我要说给我们写弹性但

00:06:10.690 --> 00:06:18.919
间隔持续时间（秒）和

00:06:16.220 --> 00:06:21.950
我们去那就是我们的通量

00:06:18.919 --> 00:06:23.539
只要您知道，就发出新值

00:06:21.950 --> 00:06:24.800
第二个是道路，我们要走

00:06:23.539 --> 00:06:28.330
将它们合并在一起，所以我要

00:06:24.800 --> 00:06:32.590
说它把它们拉在一起事件流和

00:06:28.330 --> 00:06:37.700
持续时间变化和我们想做什么

00:06:32.590 --> 00:06:39.800
就是将您知道的每个地图都映射到

00:06:37.700 --> 00:06:41.270
我们可以得到的通量是

00:06:39.800 --> 00:06:43.130
会是两个螺栓，并有两个

00:06:41.270 --> 00:06:47.930
参数，所以它是两个的元组

00:06:43.130 --> 00:06:51.830
基本上我们要映射元组T 

00:06:47.930 --> 00:06:54.710
 git T到不后悔T一

00:06:51.830 --> 00:06:57.080
而且我们还可以，所以这就是我们的

00:06:54.710 --> 00:06:59.780
值，现在这可能是一种方法

00:06:57.080 --> 00:07:00.470
参考一点清洁工，我认为是对的

00:06:59.780 --> 00:07:02.300
我们去

00:07:00.470 --> 00:07:04.009
很好，那是我们两个

00:07:02.300 --> 00:07:08.150
服务器端事件或两个服务器端事件

00:07:04.009 --> 00:07:09.349
端点，如果我们运行它，我们会做饭

00:07:08.150 --> 00:07:12.800
我们可以确认一切正常

00:07:09.349 --> 00:07:18.879
通过在这里使用命令行，让我们

00:07:12.800 --> 00:07:22.550
请参见curl HTTP localhost 8080全斜杠

00:07:18.879 --> 00:07:25.280
事件四斜线让我们说一个好吧

00:07:22.550 --> 00:07:27.620
现在让我们在那里尝试所有这些

00:07:25.280 --> 00:07:29.349
我们去，所以我喜欢我提出要求时

00:07:27.620 --> 00:07:31.219
每隔一秒就会产生一个新值

00:07:29.349 --> 00:07:34.789
心跳或类似的东西

00:07:31.219 --> 00:07:36.680
所以现在我想建立一个客户好

00:07:34.789 --> 00:07:43.099
再加上没有声音反应的客户端

00:07:36.680 --> 00:07:48.610
应用那是什么

00:07:43.099 --> 00:07:48.610
已经运行了，让我们杀死它并运行它

00:07:51.710 --> 00:07:58.280
哦，因为智力困惑，因为

00:07:54.080 --> 00:08:03.820
我ob灭了这里的第一个客户

00:07:58.280 --> 00:08:03.820
我们将再次创建它，运行这个

00:08:06.310 --> 00:08:12.710
好吧，让我们再试一次，这样

00:08:09.680 --> 00:08:18.410
每秒都在工作正确的心跳

00:08:12.710 --> 00:08:18.979
和事件4/22对，这样就可以了

00:08:18.410 --> 00:08:20.720
马上

00:08:18.979 --> 00:08:22.430
在这种情况下，我们有两个不同的两个

00:08:20.720 --> 00:08:24.380
那些已经启动并正在运行的端点

00:08:22.430 --> 00:08:27.530
建立客户让我们建立客户

00:08:24.380 --> 00:08:29.479
实际上是在

00:08:27.530 --> 00:08:30.740
例如行使这项服务

00:08:29.479 --> 00:08:32.000
事件极端，所以这实际上是

00:08:30.740 --> 00:08:34.070
你无法真正做到的

00:08:32.000 --> 00:08:36.409
轻松处理其余模板

00:08:34.070 --> 00:08:37.909
对，所以很高兴我们可以做到这一点

00:08:36.409 --> 00:08:39.890
因为我们有一个能够

00:08:37.909 --> 00:08:42.950
处理反应性的有效载荷

00:08:39.890 --> 00:08:44.959
这种情况下特别长或

00:08:42.950 --> 00:08:48.110
也许永无止境的有效载荷

00:08:44.959 --> 00:08:53.390
我们会说反应式客户端应用程序

00:08:48.110 --> 00:08:55.810
而且因为我走了懒惰的道路

00:08:53.390 --> 00:08:58.310
为了简单起见，我必须

00:08:55.810 --> 00:08:59.660
记住要更改我们所使用的端口

00:08:58.310 --> 00:09:02.779
启动此应用程序，否则

00:08:59.660 --> 00:09:04.250
将与

00:09:02.779 --> 00:09:05.660
服务，因为它们在同一节点上

00:09:04.250 --> 00:09:08.089
他们正在保存，他们正在分享

00:09:05.660 --> 00:09:15.850
相同的自动配置，因此我们将创建

00:09:08.089 --> 00:09:18.140
一个新的Spring Boot应用程序好

00:09:15.850 --> 00:09:24.880
响应式客户端应用程序按类

00:09:18.140 --> 00:09:28.630
 args，我们说那是建造者

00:09:24.880 --> 00:09:28.630
春季应用程序构建器

00:09:31.730 --> 00:09:40.180
好的属性是

00:09:35.540 --> 00:09:44.899
单个属性在这里服务器点端口

00:09:40.180 --> 00:09:47.779
等于80 81，还可以

00:09:44.899 --> 00:09:49.130
默认值是80 

00:09:47.779 --> 00:09:53.420
这些服务本身正在运行什么

00:09:49.130 --> 00:09:55.699
现在让我们有足够的空间来

00:09:53.420 --> 00:09:57.380
建立一个客户，所以我们需要春天

00:09:55.699 --> 00:09:59.930
弹性客户端类型，称为网络

00:09:57.380 --> 00:10:02.529
客户，你可以初始化一个

00:09:59.930 --> 00:10:05.240
一个空的像这样的

00:10:02.529 --> 00:10:06.680
你知道准备和指向

00:10:05.240 --> 00:10:08.690
特定的服务端点，因此

00:10:06.680 --> 00:10:10.310
我们将在这里做什么，然后我们可以使用

00:10:08.690 --> 00:10:14.120
在我们的命令行运行器中

00:10:10.310 --> 00:10:17.620
可以说命令行Runner Demerol外观

00:10:14.120 --> 00:10:19.670
在相应地注入我们的客户

00:10:17.620 --> 00:10:21.380
我想做的就是打电话给那个

00:10:19.670 --> 00:10:24.230
服务终结点事件终结点

00:10:21.380 --> 00:10:25.790
然后看到结果，现在再想一想

00:10:24.230 --> 00:10:27.199
关于我们之前必须要做的

00:10:25.790 --> 00:10:30.260
其余的其余模板

00:10:27.199 --> 00:10:32.120
将获得有效载荷，然后将其传递

00:10:30.260 --> 00:10:34.310
在这种情况下很好地连接到转换器

00:10:32.120 --> 00:10:35.269
桶是无限的，所以我们需要成为

00:10:34.310 --> 00:10:37.130
一点点更聪明

00:10:35.269 --> 00:10:38.899
关于我们如何处理客户的方式

00:10:37.130 --> 00:10:40.910
处理结果，幸运的是

00:10:38.899 --> 00:10:42.680
如果我们

00:10:40.910 --> 00:10:45.019
调用返回一百万的端点

00:10:42.680 --> 00:10:48.920
记录将网络带入网络客户端

00:10:45.019 --> 00:10:53.990
不想退缩，所以我们可以说

00:10:48.920 --> 00:10:55.540
客户点获取点URI我要说的是

00:10:53.990 --> 00:10:58.940
那么我们想把事件弄清楚

00:10:55.540 --> 00:11:02.720
我们可以说，我们正在接受

00:10:58.940 --> 00:11:13.970
一种特定类型的数据权利，因此媒体

00:11:02.720 --> 00:11:17.329
类型选择流媒体类型文本事件

00:11:13.970 --> 00:11:18.860
流好，然后我们说

00:11:17.329 --> 00:11:22.010
我进行实际的任务，所以继续

00:11:18.860 --> 00:11:24.260
发出请求，然后从那里开始

00:11:22.010 --> 00:11:27.529
必须接受他们的回应

00:11:24.260 --> 00:11:29.750
客户回应并告诉工作客户

00:11:27.529 --> 00:11:32.750
我们要如何转换它，您知道如何

00:11:29.750 --> 00:11:36.279
我们期望什么样的身体

00:11:32.750 --> 00:11:38.990
回来，所以我们想要的是

00:11:36.279 --> 00:11:41.089
事件客户我们班，我再次

00:11:38.990 --> 00:11:43.939
通过服务共享同一事件

00:11:41.089 --> 00:11:45.529
在这里实施，但

00:11:43.939 --> 00:11:46.939
你知道在一个适当的系统中

00:11:45.529 --> 00:11:48.979
您甚至可能拥有两种不同的类型

00:11:46.939 --> 00:11:50.569
客户端表示形式添加EPO或

00:11:48.979 --> 00:11:52.459
随便你怎么用

00:11:50.569 --> 00:11:53.959
所以现在我要取得结果

00:11:52.459 --> 00:11:57.470
要消耗掉我得到的结果

00:11:53.959 --> 00:11:58.569
现在有活动来了，我就是

00:11:57.470 --> 00:12:00.619
我要做的就是写出来

00:11:58.569 --> 00:12:03.949
我要承认一个事实

00:12:00.619 --> 00:12:07.749
我已收到有关Easy B的事件科学

00:12:03.949 --> 00:12:11.089
 T，这自然很适合

00:12:07.749 --> 00:12:12.379
乱成一团的格里芬现在可以了

00:12:11.089 --> 00:12:14.209
值得注意的是，我们可以拥有

00:12:12.379 --> 00:12:15.679
在这里做了很多其他事情

00:12:14.209 --> 00:12:17.329
我们可以应用任何

00:12:15.679 --> 00:12:19.669
您期望从flex和

00:12:17.329 --> 00:12:22.609
所以我们可以指定很多

00:12:19.669 --> 00:12:24.019
便利标题和cookie以及

00:12:22.609 --> 00:12:25.819
我们想要的东西

00:12:24.019 --> 00:12:28.159
要求，所以我们有能力真正

00:12:25.819 --> 00:12:31.970
改变你知道做有趣的事情

00:12:28.159 --> 00:12:33.889
与请求本身和客户端

00:12:31.970 --> 00:12:35.179
本身不只是为了让你

00:12:33.889 --> 00:12:38.239
知道头上的铅等

00:12:35.179 --> 00:12:40.039
您也可以为

00:12:38.239 --> 00:12:42.019
如果需要，可以正确过滤

00:12:40.039 --> 00:12:43.669
 return返回一个Web客户端，所以您

00:12:42.019 --> 00:12:46.269
可以贡献一个过滤器，然后

00:12:43.669 --> 00:12:48.379
也适用于它所调用的一些

00:12:46.269 --> 00:12:49.939
那是一个理想的地方，例如

00:12:48.379 --> 00:12:52.129
插入验证和

00:12:49.939 --> 00:12:53.989
你知道耶稣编码或任何你

00:12:52.129 --> 00:12:55.579
需要让你在那里做

00:12:53.989 --> 00:12:57.079
让我们继续运行此Web客户端

00:12:55.579 --> 00:12:57.949
现在的例子现在要运行一个

00:12:57.079 --> 00:12:59.659
端口8081 

00:12:57.949 --> 00:13:03.669
如果一切顺利，我们应该

00:12:59.659 --> 00:13:07.129
在控制台上查看事件

00:13:03.669 --> 00:13:17.929
从服务交付无效

00:13:07.129 --> 00:13:21.349
源类型是我沿着字符串走的吗

00:13:17.929 --> 00:13:24.319
 args好吧，现在我们在做饭，所以

00:13:21.349 --> 00:13:26.809
你知道我们的心跳价值

00:13:24.319 --> 00:13:27.949
每秒钟我们看到一个新值

00:13:26.809 --> 00:13:29.749
很好，就是这样

00:13:27.949 --> 00:13:31.609
当然，它按预期工作

00:13:29.749 --> 00:13:33.169
而且会无限期地继续下去

00:13:31.609 --> 00:13:34.789
永远不会用完内存，这是

00:13:33.169 --> 00:13:37.429
做正确的事情将要加载

00:13:34.789 --> 00:13:40.069
您在页面中知道的一定数量

00:13:37.429 --> 00:13:41.869
将呈现它，然后预加载和

00:13:40.069 --> 00:13:44.119
等等，但是因为我

00:13:41.869 --> 00:13:46.119
试图-等待-尝试的方式

00:13:44.119 --> 00:13:49.159
正确地转换它，所以这些是

00:13:46.119 --> 00:13:51.349
反应性客户有时我不想要

00:13:49.159 --> 00:13:52.639
实际上使用客户只是一个电话

00:13:51.349 --> 00:13:55.429
当我另一个服务中心

00:13:52.639 --> 00:13:56.350
像我们的客户一样测试我的服务

00:13:55.429 --> 00:13:58.150
想确认一下

00:13:56.350 --> 00:13:59.230
服务工作方式

00:13:58.150 --> 00:14:01.270
该客户会正确处理

00:13:59.230 --> 00:14:03.010
这是一个伪集成测试， 

00:14:01.270 --> 00:14:06.190
这是非常贷款的功能之一

00:14:03.010 --> 00:14:11.590
关于Thea spring MVC模块，您

00:14:06.190 --> 00:14:14.230
有能力模拟

00:14:11.590 --> 00:14:16.000
正确的客户端视角

00:14:14.230 --> 00:14:18.220
致电该服务，以便我创建

00:14:16.000 --> 00:14:21.460
在这里进行测试，我们将演示

00:14:18.220 --> 00:14:25.470
最新的网络测试客户端

00:14:21.460 --> 00:14:28.210
春天五的里程碑

00:14:25.470 --> 00:14:28.630
所以我们将使用通常的春季亚军

00:14:28.210 --> 00:14:31.810
贝雷塔

00:14:28.630 --> 00:14:41.220
所以春天的冬天，我们要去

00:14:31.810 --> 00:14:47.050
自己建立一个网络测试客户端

00:14:41.220 --> 00:14:49.810
所以私人网站测试客户端这个点网

00:14:47.050 --> 00:14:52.120
测试客户等于网络测试客户股票

00:14:49.810 --> 00:14:54.400
我们在这里有两个选择

00:14:52.120 --> 00:14:56.740
可以将我们的网络测试客户端绑定到实际

00:14:54.400 --> 00:14:58.510
服务器这不同于

00:14:56.740 --> 00:15:00.190
在您之前模拟MVC事情

00:14:58.510 --> 00:15:02.260
一直在与应用程序对话

00:15:00.190 --> 00:15:04.960
上下文本身，您可以做同样的事情

00:15:02.260 --> 00:15:06.070
在这里您可以与spring web flex交谈

00:15:04.960 --> 00:15:09.010
机械在同一应用中

00:15:06.070 --> 00:15:10.600
您会在此过程中知道

00:15:09.010 --> 00:15:12.010
并通过相同的路线

00:15:10.600 --> 00:15:13.480
组件，但您实际上不是

00:15:12.010 --> 00:15:16.270
连接到套接字正在发送

00:15:13.480 --> 00:15:18.400
在这种情况下，您可以要求

00:15:16.270 --> 00:15:20.140
绑定到服务器，那可能就是你

00:15:18.400 --> 00:15:21.280
知道他们可能会非常有用

00:15:20.140 --> 00:15:23.110
试图在进行集成测试

00:15:21.280 --> 00:15:25.780
另一个项目也许我们有点

00:15:23.110 --> 00:15:28.600
大量测试的结果

00:15:25.780 --> 00:15:30.040
通过实际的端点，它可以

00:15:28.600 --> 00:15:31.360
绑定到应用程序上下文绑定到

00:15:30.040 --> 00:15:33.790
特定的控制器，因此您可以

00:15:31.360 --> 00:15:35.740
实际上在这里实例化控制器

00:15:33.790 --> 00:15:37.270
 M反应式服务复制

00:15:35.740 --> 00:15:39.130
并将其传递到那里，然后

00:15:37.270 --> 00:15:40.420
当然，如果您知道，但是如果您去过

00:15:39.130 --> 00:15:42.610
按照我们一直在谈论

00:15:40.420 --> 00:15:44.440
在春季和春季v偏心

00:15:42.610 --> 00:15:46.810
春天的提示，你知道有

00:15:44.440 --> 00:15:48.580
功能性反应终点和排气

00:15:46.810 --> 00:15:50.350
该API的核心是

00:15:48.580 --> 00:15:52.870
路由器功能，因此您可以通过

00:15:50.350 --> 00:15:55.840
在这里，实际上有一个你知道的

00:15:52.870 --> 00:15:59.050
描述了一个不同的目录

00:15:55.840 --> 00:16:00.760
端点和路由，让我们看看

00:15:59.050 --> 00:16:02.200
试试这个，这是新的，所以我们会做

00:16:00.760 --> 00:16:03.760
好说的话，我们要用

00:16:02.200 --> 00:16:05.590
基本网址，或者我们可以使用构建器

00:16:03.760 --> 00:16:11.470
工厂，但我们只会使用基本网址

00:16:05.590 --> 00:16:17.050
 8080的主机好，我们将构建

00:16:11.470 --> 00:16:18.730
因此，不难称呼

00:16:17.050 --> 00:16:21.820
特定的端点，所以我们可以这样说

00:16:18.730 --> 00:16:23.560
但是测试客户的感受如何

00:16:21.820 --> 00:16:25.570
这里非常熟悉的圆柱体

00:16:23.560 --> 00:16:28.690
与我们仅使用的内容非常相似

00:16:25.570 --> 00:16:30.820
网络客户端本身，我们希望

00:16:28.690 --> 00:16:37.000
通过URL调用端点，因此我们可以

00:16:30.820 --> 00:16:41.500
只是说事件，比如说42，然后我们

00:16:37.000 --> 00:16:44.760
可以说我们想全部接受杰森

00:16:41.500 --> 00:16:47.920
对，所以我们可以说应用程序JSON和

00:16:44.760 --> 00:16:51.840
我们可以说我们想要

00:16:47.920 --> 00:16:55.630
发出请求，我们可以期待

00:16:51.840 --> 00:16:58.120
您知道的状态还可以

00:16:55.630 --> 00:17:01.600
在这种情况下，我们期望在200 

00:16:58.120 --> 00:17:02.980
我们可以期待，而我们可以断言所有

00:17:01.600 --> 00:17:06.550
那里的那些东西以及

00:17:02.980 --> 00:17:08.350
我们应该得到的有效载荷的类型

00:17:06.550 --> 00:17:10.300
回到响应的主体

00:17:08.350 --> 00:17:12.370
存在或不存在特定的

00:17:10.300 --> 00:17:14.350
标头等，但在这种情况下，我认为

00:17:12.370 --> 00:17:16.450
我们有足够的去做，所以让我们继续

00:17:14.350 --> 00:17:26.410
看看看起来像什么

00:17:16.450 --> 00:17:26.860
是的，这很好，我们的测试是

00:17:26.410 --> 00:17:28.090
绿色

00:17:26.860 --> 00:17:30.400
一切都快乐，我们当然应该

00:17:28.090 --> 00:17:32.980
确认否定即可

00:17:30.400 --> 00:17:35.260
如果我们尝试并确认

00:17:32.980 --> 00:17:37.600
这是一个箭头，返回500 

00:17:35.260 --> 00:17:41.230
但它应该会失败，所以让我们开始吧

00:17:37.600 --> 00:17:45.400
向前并开始，然后我们去

00:17:41.230 --> 00:17:47.440
所以我们的测试速度很快

00:17:45.400 --> 00:17:48.700
等待整个服务器启动

00:17:47.440 --> 00:17:50.320
或者在这种情况下，我们已经知道了

00:17:48.700 --> 00:17:51.540
运行，但如果我们不需要

00:17:50.320 --> 00:17:53.710
例如使用应用程序上下文

00:17:51.540 --> 00:17:55.720
我们有能力做须藤

00:17:53.710 --> 00:17:56.890
集成测试我们可以做很多事情

00:17:55.720 --> 00:18:00.130
这些现在非常非常快

00:17:56.890 --> 00:18:02.620
 Springwood助焊剂本身当然非常

00:18:00.130 --> 00:18:04.180
非常快，因此在本期中，我们已经

00:18:02.620 --> 00:18:06.610
看了如何消费服务

00:18:04.180 --> 00:18:09.910
使用网络客户端和网络测试

00:18:06.610 --> 00:18:11.920
客户我们看了这有什么相似之处

00:18:09.910 --> 00:18:14.020
其余模板放入模拟MVC中

00:18:11.920 --> 00:18:16.900
您可能会使用的一种设备

00:18:14.020 --> 00:18:18.520
熟悉并熟练掌握MVC 

00:18:16.900 --> 00:18:20.380
当然那些组件是

00:18:18.520 --> 00:18:20.950
仍然在那里，这也值得

00:18:20.380 --> 00:18:24.220
注意到你

00:18:20.950 --> 00:18:26.380
与您一起使用Web客户端一无所知

00:18:24.220 --> 00:18:29.920
您可以将其与传统的

00:18:26.380 --> 00:18:32.140
非反应式服务没有理由

00:18:29.920 --> 00:18:34.450
您不能只在

00:18:32.140 --> 00:18:35.560
例如，代替其余模板

00:18:34.450 --> 00:18:38.560
对

00:18:35.560 --> 00:18:39.970
无论哪种方式，您都可以选择

00:18:38.560 --> 00:18:42.630
非常感谢您的收看

00:18:39.970 --> 00:18:42.630
我们下次见

